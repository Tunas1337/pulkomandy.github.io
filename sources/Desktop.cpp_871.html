
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Desktop.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2016, Haiku.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Adrian Oanca &lt;adioanca@cotty.iren.ro&gt;</a>
<a name="ln7"> *		Stephan Aßmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln8"> *		Axel Dörfler &lt;axeld@pinc-software.de&gt;</a>
<a name="ln9"> *		Andrej Spielmann &lt;andrej.spielmann@seh.ox.ac.uk&gt;</a>
<a name="ln10"> *		Brecht Machiels &lt;brecht@mos6581.org&gt;</a>
<a name="ln11"> *		Clemens Zeidler &lt;haiku@clemens-zeidler.de&gt;</a>
<a name="ln12"> *		Ingo Weinhold &lt;ingo_weinhold@gmx.de&gt;</a>
<a name="ln13"> *		Joseph Groover &lt;looncraz@looncraz.net&gt;</a>
<a name="ln14"> */</a>
<a name="ln15"> </a>
<a name="ln16"> </a>
<a name="ln17">/*!	Class used to encapsulate desktop management */</a>
<a name="ln18"> </a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;Desktop.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;stdio.h&gt;</a>
<a name="ln23">#include &lt;string.h&gt;</a>
<a name="ln24">#include &lt;syslog.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;Debug.h&gt;</a>
<a name="ln27">#include &lt;debugger.h&gt;</a>
<a name="ln28">#include &lt;DirectWindow.h&gt;</a>
<a name="ln29">#include &lt;Entry.h&gt;</a>
<a name="ln30">#include &lt;FindDirectory.h&gt;</a>
<a name="ln31">#include &lt;Message.h&gt;</a>
<a name="ln32">#include &lt;MessageFilter.h&gt;</a>
<a name="ln33">#include &lt;Path.h&gt;</a>
<a name="ln34">#include &lt;Region.h&gt;</a>
<a name="ln35">#include &lt;Roster.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;PrivateScreen.h&gt;</a>
<a name="ln38">#include &lt;ServerProtocol.h&gt;</a>
<a name="ln39">#include &lt;ViewPrivate.h&gt;</a>
<a name="ln40">#include &lt;WindowInfo.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;AppServer.h&quot;</a>
<a name="ln43">#include &quot;ClickTarget.h&quot;</a>
<a name="ln44">#include &quot;DecorManager.h&quot;</a>
<a name="ln45">#include &quot;DesktopSettingsPrivate.h&quot;</a>
<a name="ln46">#include &quot;DrawingEngine.h&quot;</a>
<a name="ln47">#include &quot;FontManager.h&quot;</a>
<a name="ln48">#include &quot;HWInterface.h&quot;</a>
<a name="ln49">#include &quot;InputManager.h&quot;</a>
<a name="ln50">#include &quot;Screen.h&quot;</a>
<a name="ln51">#include &quot;ServerApp.h&quot;</a>
<a name="ln52">#include &quot;ServerConfig.h&quot;</a>
<a name="ln53">#include &quot;ServerCursor.h&quot;</a>
<a name="ln54">#include &quot;ServerWindow.h&quot;</a>
<a name="ln55">#include &quot;SystemPalette.h&quot;</a>
<a name="ln56">#include &quot;WindowPrivate.h&quot;</a>
<a name="ln57">#include &quot;Window.h&quot;</a>
<a name="ln58">#include &quot;Workspace.h&quot;</a>
<a name="ln59">#include &quot;WorkspacesView.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61">#if TEST_MODE</a>
<a name="ln62">#	include &quot;EventStream.h&quot;</a>
<a name="ln63">#endif</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">//#define DEBUG_DESKTOP</a>
<a name="ln67">#ifdef DEBUG_DESKTOP</a>
<a name="ln68">#	define STRACE(a) printf a</a>
<a name="ln69">#else</a>
<a name="ln70">#	define STRACE(a) ;</a>
<a name="ln71">#endif</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">static inline float</a>
<a name="ln75">square_vector_length(float x, float y)</a>
<a name="ln76">{</a>
<a name="ln77">	return x * x + y * y;</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80"> </a>
<a name="ln81">static inline float</a>
<a name="ln82">square_distance(const BPoint&amp; a, const BPoint&amp; b)</a>
<a name="ln83">{</a>
<a name="ln84">	return square_vector_length(a.x - b.x, a.y - b.y);</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87"> </a>
<a name="ln88">class KeyboardFilter : public EventFilter {</a>
<a name="ln89">	public:</a>
<a name="ln90">		KeyboardFilter(Desktop* desktop);</a>
<a name="ln91"> </a>
<a name="ln92">		virtual filter_result Filter(BMessage* message, EventTarget** _target,</a>
<a name="ln93">			int32* _viewToken, BMessage* latestMouseMoved);</a>
<a name="ln94">		virtual void RemoveTarget(EventTarget* target);</a>
<a name="ln95"> </a>
<a name="ln96">	private:</a>
<a name="ln97">		void _UpdateFocus(int32 key, uint32 modifiers, EventTarget** _target);</a>
<a name="ln98"> </a>
<a name="ln99">		Desktop*		fDesktop;</a>
<a name="ln100">		EventTarget*	fLastFocus;</a>
<a name="ln101">		bigtime_t		fTimestamp;</a>
<a name="ln102">};</a>
<a name="ln103"> </a>
<a name="ln104"> </a>
<a name="ln105">class MouseFilter : public EventFilter {</a>
<a name="ln106">public:</a>
<a name="ln107">	MouseFilter(Desktop* desktop);</a>
<a name="ln108"> </a>
<a name="ln109">	virtual filter_result Filter(BMessage* message, EventTarget** _target,</a>
<a name="ln110">		int32* _viewToken, BMessage* latestMouseMoved);</a>
<a name="ln111"> </a>
<a name="ln112">private:</a>
<a name="ln113">	Desktop*	fDesktop;</a>
<a name="ln114">	int32		fLastClickButtons;</a>
<a name="ln115">	int32		fLastClickModifiers;</a>
<a name="ln116">	int32		fResetClickCount;</a>
<a name="ln117">	BPoint		fLastClickPoint;</a>
<a name="ln118">	ClickTarget	fLastClickTarget;</a>
<a name="ln119">};</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">//	#pragma mark -</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">KeyboardFilter::KeyboardFilter(Desktop* desktop)</a>
<a name="ln126">	:</a>
<a name="ln127">	fDesktop(desktop),</a>
<a name="ln128">	fLastFocus(NULL),</a>
<a name="ln129">	fTimestamp(0)</a>
<a name="ln130">{</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">void</a>
<a name="ln135">KeyboardFilter::_UpdateFocus(int32 key, uint32 modifiers, EventTarget** _target)</a>
<a name="ln136">{</a>
<a name="ln137">	if (!fDesktop-&gt;LockSingleWindow())</a>
<a name="ln138">		return;</a>
<a name="ln139"> </a>
<a name="ln140">	EventTarget* focus = fDesktop-&gt;KeyboardEventTarget();</a>
<a name="ln141"> </a>
<a name="ln142">#if 0</a>
<a name="ln143">	bigtime_t now = system_time();</a>
<a name="ln144"> </a>
<a name="ln145">	// TODO: this is a try to not steal focus from the current window</a>
<a name="ln146">	//	in case you enter some text and a window pops up you haven't</a>
<a name="ln147">	//	triggered yourself (like a pop-up window in your browser while</a>
<a name="ln148">	//	you're typing a password in another window) - maybe this should</a>
<a name="ln149">	//	be done differently, though (using something like B_LOCK_WINDOW_FOCUS)</a>
<a name="ln150">	//	(at least B_WINDOW_ACTIVATED must be postponed)</a>
<a name="ln151"> </a>
<a name="ln152">	if (fLastFocus == NULL</a>
<a name="ln153">		|| (focus != fLastFocus &amp;&amp; now - fTimestamp &gt; 100000)) {</a>
<a name="ln154">		// if the time span between the key presses is very short</a>
<a name="ln155">		// we keep our previous focus alive - this is safe even</a>
<a name="ln156">		// if the target doesn't exist anymore, as we don't reset</a>
<a name="ln157">		// it, and the event focus passed in is always valid (or NULL)</a>
<a name="ln158">		*_target = focus;</a>
<a name="ln159">		fLastFocus = focus;</a>
<a name="ln160">	}</a>
<a name="ln161">#endif</a>
<a name="ln162">	*_target = focus;</a>
<a name="ln163">	fLastFocus = focus;</a>
<a name="ln164"> </a>
<a name="ln165">	fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln166"> </a>
<a name="ln167">#if 0</a>
<a name="ln168">	// we always allow to switch focus after the enter key has pressed</a>
<a name="ln169">	if (key == B_ENTER || modifiers == B_COMMAND_KEY</a>
<a name="ln170">		|| modifiers == B_CONTROL_KEY || modifiers == B_OPTION_KEY)</a>
<a name="ln171">		fTimestamp = 0;</a>
<a name="ln172">	else</a>
<a name="ln173">		fTimestamp = now;</a>
<a name="ln174">#endif</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">filter_result</a>
<a name="ln179">KeyboardFilter::Filter(BMessage* message, EventTarget** _target,</a>
<a name="ln180">	int32* /*_viewToken*/, BMessage* /*latestMouseMoved*/)</a>
<a name="ln181">{</a>
<a name="ln182">	int32 key = 0;</a>
<a name="ln183">	int32 modifiers = 0;</a>
<a name="ln184"> </a>
<a name="ln185">	message-&gt;FindInt32(&quot;key&quot;, &amp;key);</a>
<a name="ln186">	message-&gt;FindInt32(&quot;modifiers&quot;, &amp;modifiers);</a>
<a name="ln187"> </a>
<a name="ln188">	if ((message-&gt;what == B_KEY_DOWN || message-&gt;what == B_UNMAPPED_KEY_DOWN)) {</a>
<a name="ln189">		// Check for safe video mode (shift + cmd + ctrl + escape)</a>
<a name="ln190">		if (key == 0x01 &amp;&amp; (modifiers &amp; B_COMMAND_KEY) != 0</a>
<a name="ln191">			&amp;&amp; (modifiers &amp; B_CONTROL_KEY) != 0</a>
<a name="ln192">			&amp;&amp; (modifiers &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln193">			system(&quot;screenmode --fall-back &amp;&quot;);</a>
<a name="ln194">			return B_SKIP_MESSAGE;</a>
<a name="ln195">		}</a>
<a name="ln196"> </a>
<a name="ln197">		bool takeWindow = (modifiers &amp; B_SHIFT_KEY) != 0</a>
<a name="ln198">			|| fDesktop-&gt;MouseEventWindow() != NULL;</a>
<a name="ln199">		if (key &gt;= B_F1_KEY &amp;&amp; key &lt;= B_F12_KEY) {</a>
<a name="ln200">			// workspace change</a>
<a name="ln201"> </a>
<a name="ln202">#if !TEST_MODE</a>
<a name="ln203">			if ((modifiers &amp; (B_COMMAND_KEY | B_CONTROL_KEY | B_OPTION_KEY))</a>
<a name="ln204">					== B_COMMAND_KEY)</a>
<a name="ln205">#else</a>
<a name="ln206">			if ((modifiers &amp; B_CONTROL_KEY) != 0)</a>
<a name="ln207">#endif</a>
<a name="ln208">			{</a>
<a name="ln209">				STRACE((&quot;Set Workspace %&quot; B_PRId32 &quot;\n&quot;, key - 1));</a>
<a name="ln210"> </a>
<a name="ln211">				fDesktop-&gt;SetWorkspaceAsync(key - B_F1_KEY, takeWindow);</a>
<a name="ln212">				return B_SKIP_MESSAGE;</a>
<a name="ln213">			}</a>
<a name="ln214">		} if (key == 0x11</a>
<a name="ln215">			&amp;&amp; (modifiers &amp; (B_COMMAND_KEY | B_CONTROL_KEY | B_OPTION_KEY))</a>
<a name="ln216">					== B_COMMAND_KEY) {</a>
<a name="ln217">			// switch to previous workspace (command + `)</a>
<a name="ln218">			fDesktop-&gt;SetWorkspaceAsync(-1, takeWindow);</a>
<a name="ln219">			return B_SKIP_MESSAGE;</a>
<a name="ln220">		}</a>
<a name="ln221">	}</a>
<a name="ln222"> </a>
<a name="ln223">	if (message-&gt;what == B_KEY_DOWN</a>
<a name="ln224">		|| message-&gt;what == B_MODIFIERS_CHANGED</a>
<a name="ln225">		|| message-&gt;what == B_UNMAPPED_KEY_DOWN</a>
<a name="ln226">		|| message-&gt;what == B_INPUT_METHOD_EVENT)</a>
<a name="ln227">		_UpdateFocus(key, modifiers, _target);</a>
<a name="ln228"> </a>
<a name="ln229">	return fDesktop-&gt;KeyEvent(message-&gt;what, key, modifiers);</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">void</a>
<a name="ln234">KeyboardFilter::RemoveTarget(EventTarget* target)</a>
<a name="ln235">{</a>
<a name="ln236">	if (target == fLastFocus)</a>
<a name="ln237">		fLastFocus = NULL;</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">//	#pragma mark -</a>
<a name="ln242"> </a>
<a name="ln243"> </a>
<a name="ln244">MouseFilter::MouseFilter(Desktop* desktop)</a>
<a name="ln245">	:</a>
<a name="ln246">	fDesktop(desktop),</a>
<a name="ln247">	fLastClickButtons(0),</a>
<a name="ln248">	fLastClickModifiers(0),</a>
<a name="ln249">	fResetClickCount(0),</a>
<a name="ln250">	fLastClickPoint(),</a>
<a name="ln251">	fLastClickTarget()</a>
<a name="ln252">{</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255"> </a>
<a name="ln256">filter_result</a>
<a name="ln257">MouseFilter::Filter(BMessage* message, EventTarget** _target, int32* _viewToken,</a>
<a name="ln258">	BMessage* latestMouseMoved)</a>
<a name="ln259">{</a>
<a name="ln260">	BPoint where;</a>
<a name="ln261">	if (message-&gt;FindPoint(&quot;where&quot;, &amp;where) != B_OK)</a>
<a name="ln262">		return B_DISPATCH_MESSAGE;</a>
<a name="ln263"> </a>
<a name="ln264">	int32 buttons;</a>
<a name="ln265">	if (message-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons) != B_OK)</a>
<a name="ln266">		buttons = 0;</a>
<a name="ln267"> </a>
<a name="ln268">	if (!fDesktop-&gt;LockAllWindows())</a>
<a name="ln269">		return B_DISPATCH_MESSAGE;</a>
<a name="ln270"> </a>
<a name="ln271">	int32 viewToken = B_NULL_TOKEN;</a>
<a name="ln272"> </a>
<a name="ln273">	Window* window = fDesktop-&gt;MouseEventWindow();</a>
<a name="ln274">	if (window == NULL)</a>
<a name="ln275">		window = fDesktop-&gt;WindowAt(where);</a>
<a name="ln276"> </a>
<a name="ln277">	if (window != NULL) {</a>
<a name="ln278">		// dispatch event to the window</a>
<a name="ln279">		switch (message-&gt;what) {</a>
<a name="ln280">			case B_MOUSE_DOWN:</a>
<a name="ln281">			{</a>
<a name="ln282">				int32 windowToken = window-&gt;ServerWindow()-&gt;ServerToken();</a>
<a name="ln283"> </a>
<a name="ln284">				// First approximation of click count validation. We reset the</a>
<a name="ln285">				// click count when modifiers or pressed buttons have changed</a>
<a name="ln286">				// or when we've got a different click target, or when the</a>
<a name="ln287">				// previous click location is too far from the new one. We can</a>
<a name="ln288">				// only check the window of the click target here; we'll recheck</a>
<a name="ln289">				// after asking the window.</a>
<a name="ln290">				int32 modifiers = message-&gt;FindInt32(&quot;modifiers&quot;);</a>
<a name="ln291"> </a>
<a name="ln292">				int32 originalClickCount = message-&gt;FindInt32(&quot;clicks&quot;);</a>
<a name="ln293">				if (originalClickCount &lt;= 0)</a>
<a name="ln294">					originalClickCount = 1;</a>
<a name="ln295"> </a>
<a name="ln296">				int32 clickCount = originalClickCount;</a>
<a name="ln297">				if (clickCount &gt; 1) {</a>
<a name="ln298">					if (modifiers != fLastClickModifiers</a>
<a name="ln299">						|| buttons != fLastClickButtons</a>
<a name="ln300">						|| !fLastClickTarget.IsValid()</a>
<a name="ln301">						|| fLastClickTarget.WindowToken() != windowToken</a>
<a name="ln302">						|| square_distance(where, fLastClickPoint) &gt;= 16</a>
<a name="ln303">						|| clickCount - fResetClickCount &lt; 1) {</a>
<a name="ln304">						clickCount = 1;</a>
<a name="ln305">					} else</a>
<a name="ln306">						clickCount -= fResetClickCount;</a>
<a name="ln307">				}</a>
<a name="ln308"> </a>
<a name="ln309">				// notify the window</a>
<a name="ln310">				ClickTarget clickTarget;</a>
<a name="ln311">				window-&gt;MouseDown(message, where, fLastClickTarget, clickCount,</a>
<a name="ln312">					clickTarget);</a>
<a name="ln313"> </a>
<a name="ln314">				// If the click target changed, always reset the click count.</a>
<a name="ln315">				if (clickCount != 1 &amp;&amp; clickTarget != fLastClickTarget)</a>
<a name="ln316">					clickCount = 1;</a>
<a name="ln317"> </a>
<a name="ln318">				// update our click count management attributes</a>
<a name="ln319">				fResetClickCount = originalClickCount - clickCount;</a>
<a name="ln320">				fLastClickTarget = clickTarget;</a>
<a name="ln321">				fLastClickButtons = buttons;</a>
<a name="ln322">				fLastClickModifiers = modifiers;</a>
<a name="ln323">				fLastClickPoint = where;</a>
<a name="ln324"> </a>
<a name="ln325">				// get the view token from the click target</a>
<a name="ln326">				if (clickTarget.GetType() == ClickTarget::TYPE_WINDOW_CONTENTS)</a>
<a name="ln327">					viewToken = clickTarget.WindowElement();</a>
<a name="ln328"> </a>
<a name="ln329">				// update the message's &quot;clicks&quot; field, if necessary</a>
<a name="ln330">				if (clickCount != originalClickCount) {</a>
<a name="ln331">					if (message-&gt;HasInt32(&quot;clicks&quot;))</a>
<a name="ln332">						message-&gt;ReplaceInt32(&quot;clicks&quot;, clickCount);</a>
<a name="ln333">					else</a>
<a name="ln334">						message-&gt;AddInt32(&quot;clicks&quot;, clickCount);</a>
<a name="ln335">				}</a>
<a name="ln336"> </a>
<a name="ln337">				// notify desktop listeners</a>
<a name="ln338">				fDesktop-&gt;NotifyMouseDown(window, message, where);</a>
<a name="ln339">				break;</a>
<a name="ln340">			}</a>
<a name="ln341"> </a>
<a name="ln342">			case B_MOUSE_UP:</a>
<a name="ln343">				window-&gt;MouseUp(message, where, &amp;viewToken);</a>
<a name="ln344">				if (buttons == 0)</a>
<a name="ln345">					fDesktop-&gt;SetMouseEventWindow(NULL);</a>
<a name="ln346">				fDesktop-&gt;NotifyMouseUp(window, message, where);</a>
<a name="ln347">				break;</a>
<a name="ln348"> </a>
<a name="ln349">			case B_MOUSE_MOVED:</a>
<a name="ln350">				window-&gt;MouseMoved(message, where, &amp;viewToken,</a>
<a name="ln351">					latestMouseMoved == NULL || latestMouseMoved == message,</a>
<a name="ln352">					false);</a>
<a name="ln353">				fDesktop-&gt;NotifyMouseMoved(window, message, where);</a>
<a name="ln354">				break;</a>
<a name="ln355">		}</a>
<a name="ln356"> </a>
<a name="ln357">		if (viewToken != B_NULL_TOKEN) {</a>
<a name="ln358">			fDesktop-&gt;SetViewUnderMouse(window, viewToken);</a>
<a name="ln359"> </a>
<a name="ln360">			*_viewToken = viewToken;</a>
<a name="ln361">			*_target = &amp;window-&gt;EventTarget();</a>
<a name="ln362">		}</a>
<a name="ln363">	} else if (message-&gt;what == B_MOUSE_DOWN) {</a>
<a name="ln364">		// the mouse-down didn't hit a window -- reset the click target</a>
<a name="ln365">		fResetClickCount = 0;</a>
<a name="ln366">		fLastClickTarget = ClickTarget();</a>
<a name="ln367">		fLastClickButtons = message-&gt;FindInt32(&quot;buttons&quot;);</a>
<a name="ln368">		fLastClickModifiers = message-&gt;FindInt32(&quot;modifiers&quot;);</a>
<a name="ln369">		fLastClickPoint = where;</a>
<a name="ln370">	}</a>
<a name="ln371"> </a>
<a name="ln372">	if (window == NULL || viewToken == B_NULL_TOKEN) {</a>
<a name="ln373">		// mouse is not over a window or over a decorator</a>
<a name="ln374">		fDesktop-&gt;SetViewUnderMouse(window, B_NULL_TOKEN);</a>
<a name="ln375">		fDesktop-&gt;SetCursor(NULL);</a>
<a name="ln376"> </a>
<a name="ln377">		*_target = NULL;</a>
<a name="ln378">	}</a>
<a name="ln379"> </a>
<a name="ln380">	fDesktop-&gt;SetLastMouseState(where, buttons, window);</a>
<a name="ln381"> </a>
<a name="ln382">	fDesktop-&gt;NotifyMouseEvent(message);</a>
<a name="ln383"> </a>
<a name="ln384">	fDesktop-&gt;UnlockAllWindows();</a>
<a name="ln385"> </a>
<a name="ln386">	return B_DISPATCH_MESSAGE;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">//	#pragma mark -</a>
<a name="ln391"> </a>
<a name="ln392"> </a>
<a name="ln393">static inline uint32</a>
<a name="ln394">workspace_to_workspaces(int32 index)</a>
<a name="ln395">{</a>
<a name="ln396">	return 1UL &lt;&lt; index;</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">static inline bool</a>
<a name="ln401">workspace_in_workspaces(int32 index, uint32 workspaces)</a>
<a name="ln402">{</a>
<a name="ln403">	return (workspaces &amp; (1UL &lt;&lt; index)) != 0;</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">//	#pragma mark -</a>
<a name="ln408"> </a>
<a name="ln409"> </a>
<a name="ln410">Desktop::Desktop(uid_t userID, const char* targetScreen)</a>
<a name="ln411">	:</a>
<a name="ln412">	MessageLooper(&quot;desktop&quot;),</a>
<a name="ln413"> </a>
<a name="ln414">	fUserID(userID),</a>
<a name="ln415">	fTargetScreen(strdup(targetScreen)),</a>
<a name="ln416">	fSettings(NULL),</a>
<a name="ln417">	fSharedReadOnlyArea(-1),</a>
<a name="ln418">	fApplicationsLock(&quot;application list&quot;),</a>
<a name="ln419">	fShutdownSemaphore(-1),</a>
<a name="ln420">	fShutdownCount(0),</a>
<a name="ln421">	fScreenLock(&quot;screen lock&quot;),</a>
<a name="ln422">	fDirectScreenLock(&quot;direct screen lock&quot;),</a>
<a name="ln423">	fDirectScreenTeam(-1),</a>
<a name="ln424">	fCurrentWorkspace(0),</a>
<a name="ln425">	fPreviousWorkspace(0),</a>
<a name="ln426">	fAllWindows(kAllWindowList),</a>
<a name="ln427">	fSubsetWindows(kSubsetList),</a>
<a name="ln428">	fFocusList(kFocusList),</a>
<a name="ln429">	fWorkspacesViews(false),</a>
<a name="ln430"> </a>
<a name="ln431">	fWorkspacesLock(&quot;workspaces list&quot;),</a>
<a name="ln432">	fWindowLock(&quot;window lock&quot;),</a>
<a name="ln433"> </a>
<a name="ln434">	fMouseEventWindow(NULL),</a>
<a name="ln435">	fWindowUnderMouse(NULL),</a>
<a name="ln436">	fLockedFocusWindow(NULL),</a>
<a name="ln437">	fViewUnderMouse(B_NULL_TOKEN),</a>
<a name="ln438">	fLastMousePosition(B_ORIGIN),</a>
<a name="ln439">	fLastMouseButtons(0),</a>
<a name="ln440"> </a>
<a name="ln441">	fFocus(NULL),</a>
<a name="ln442">	fFront(NULL),</a>
<a name="ln443">	fBack(NULL)</a>
<a name="ln444">{</a>
<a name="ln445">	memset(fLastWorkspaceFocus, 0, sizeof(fLastWorkspaceFocus));</a>
<a name="ln446"> </a>
<a name="ln447">	char name[B_OS_NAME_LENGTH];</a>
<a name="ln448">	Desktop::_GetLooperName(name, sizeof(name));</a>
<a name="ln449"> </a>
<a name="ln450">	fMessagePort = create_port(DEFAULT_MONITOR_PORT_SIZE, name);</a>
<a name="ln451">	if (fMessagePort &lt; B_OK)</a>
<a name="ln452">		return;</a>
<a name="ln453"> </a>
<a name="ln454">	fLink.SetReceiverPort(fMessagePort);</a>
<a name="ln455"> </a>
<a name="ln456">	// register listeners</a>
<a name="ln457">	RegisterListener(&amp;fStackAndTile);</a>
<a name="ln458"> </a>
<a name="ln459">	const DesktopListenerList&amp; newListeners</a>
<a name="ln460">		= gDecorManager.GetDesktopListeners();</a>
<a name="ln461">	for (int i = 0; i &lt; newListeners.CountItems(); i++)</a>
<a name="ln462"> 		RegisterListener(newListeners.ItemAt(i));</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465"> </a>
<a name="ln466">Desktop::~Desktop()</a>
<a name="ln467">{</a>
<a name="ln468">	delete fSettings;</a>
<a name="ln469"> </a>
<a name="ln470">	delete_area(fSharedReadOnlyArea);</a>
<a name="ln471">	delete_port(fMessagePort);</a>
<a name="ln472">	gFontManager-&gt;DetachUser(fUserID);</a>
<a name="ln473"> </a>
<a name="ln474">	free(fTargetScreen);</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477"> </a>
<a name="ln478">void</a>
<a name="ln479">Desktop::RegisterListener(DesktopListener* listener)</a>
<a name="ln480">{</a>
<a name="ln481">	DesktopObservable::RegisterListener(listener, this);</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484"> </a>
<a name="ln485">/*!	This method is allowed to throw exceptions.</a>
<a name="ln486">*/</a>
<a name="ln487">status_t</a>
<a name="ln488">Desktop::Init()</a>
<a name="ln489">{</a>
<a name="ln490">	if (fMessagePort &lt; B_OK)</a>
<a name="ln491">		return fMessagePort;</a>
<a name="ln492"> </a>
<a name="ln493">	// the system palette needs to be initialized before the</a>
<a name="ln494">	// desktop settings, since it is used there already</a>
<a name="ln495">	InitializeColorMap();</a>
<a name="ln496"> </a>
<a name="ln497">	const size_t areaSize = B_PAGE_SIZE;</a>
<a name="ln498">	char name[B_OS_NAME_LENGTH];</a>
<a name="ln499">	snprintf(name, sizeof(name), &quot;d:%d:shared read only&quot;, fUserID);</a>
<a name="ln500">	fSharedReadOnlyArea = create_area(name, (void **)&amp;fServerReadOnlyMemory,</a>
<a name="ln501">		B_ANY_ADDRESS, areaSize, B_NO_LOCK, B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln502">	if (fSharedReadOnlyArea &lt; B_OK)</a>
<a name="ln503">		return fSharedReadOnlyArea;</a>
<a name="ln504"> </a>
<a name="ln505">	gFontManager-&gt;AttachUser(fUserID);</a>
<a name="ln506"> </a>
<a name="ln507">	fSettings = new DesktopSettingsPrivate(fServerReadOnlyMemory);</a>
<a name="ln508"> </a>
<a name="ln509">	for (int32 i = 0; i &lt; kMaxWorkspaces; i++) {</a>
<a name="ln510">		_Windows(i).SetIndex(i);</a>
<a name="ln511">		fWorkspaces[i].RestoreConfiguration(*fSettings-&gt;WorkspacesMessage(i));</a>
<a name="ln512">	}</a>
<a name="ln513"> </a>
<a name="ln514">	fVirtualScreen.SetConfiguration(*this,</a>
<a name="ln515">		fWorkspaces[0].CurrentScreenConfiguration());</a>
<a name="ln516"> </a>
<a name="ln517">	if (fVirtualScreen.HWInterface() == NULL) {</a>
<a name="ln518">		debug_printf(&quot;Could not initialize graphics output. Exiting.\n&quot;);</a>
<a name="ln519">		return B_ERROR;</a>
<a name="ln520">	}</a>
<a name="ln521"> </a>
<a name="ln522">	fVirtualScreen.HWInterface()-&gt;MoveCursorTo(</a>
<a name="ln523">		fVirtualScreen.Frame().Width() / 2,</a>
<a name="ln524">		fVirtualScreen.Frame().Height() / 2);</a>
<a name="ln525"> </a>
<a name="ln526">#if TEST_MODE</a>
<a name="ln527">	gInputManager-&gt;AddStream(new InputServerStream);</a>
<a name="ln528">#endif</a>
<a name="ln529"> </a>
<a name="ln530">	EventStream* stream = fVirtualScreen.HWInterface()-&gt;CreateEventStream();</a>
<a name="ln531">	if (stream == NULL)</a>
<a name="ln532">		stream = gInputManager-&gt;GetStream();</a>
<a name="ln533"> </a>
<a name="ln534">	fEventDispatcher.SetDesktop(this);</a>
<a name="ln535">	fEventDispatcher.SetTo(stream);</a>
<a name="ln536">	if (fEventDispatcher.InitCheck() != B_OK)</a>
<a name="ln537">		_LaunchInputServer();</a>
<a name="ln538"> </a>
<a name="ln539">	fEventDispatcher.SetHWInterface(fVirtualScreen.HWInterface());</a>
<a name="ln540"> </a>
<a name="ln541">	fEventDispatcher.SetMouseFilter(new MouseFilter(this));</a>
<a name="ln542">	fEventDispatcher.SetKeyboardFilter(new KeyboardFilter(this));</a>
<a name="ln543"> </a>
<a name="ln544">	// draw the background</a>
<a name="ln545"> </a>
<a name="ln546">	fScreenRegion = fVirtualScreen.Frame();</a>
<a name="ln547"> </a>
<a name="ln548">	BRegion stillAvailableOnScreen;</a>
<a name="ln549">	_RebuildClippingForAllWindows(stillAvailableOnScreen);</a>
<a name="ln550">	_SetBackground(stillAvailableOnScreen);</a>
<a name="ln551"> </a>
<a name="ln552">	SetCursor(NULL);</a>
<a name="ln553">		// this will set the default cursor</a>
<a name="ln554"> </a>
<a name="ln555">	fVirtualScreen.HWInterface()-&gt;SetCursorVisible(true);</a>
<a name="ln556"> </a>
<a name="ln557">	return B_OK;</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560"> </a>
<a name="ln561">/*!	\brief Send a quick (no attachments) message to all applications.</a>
<a name="ln562"> </a>
<a name="ln563">	Quite useful for notification for things like server shutdown, system</a>
<a name="ln564">	color changes, etc.</a>
<a name="ln565">*/</a>
<a name="ln566">void</a>
<a name="ln567">Desktop::BroadcastToAllApps(int32 code)</a>
<a name="ln568">{</a>
<a name="ln569">	BAutolock locker(fApplicationsLock);</a>
<a name="ln570"> </a>
<a name="ln571">	for (int32 i = fApplications.CountItems(); i-- &gt; 0;) {</a>
<a name="ln572">		fApplications.ItemAt(i)-&gt;PostMessage(code);</a>
<a name="ln573">	}</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576"> </a>
<a name="ln577">/*!	\brief Send a quick (no attachments) message to all windows.</a>
<a name="ln578">*/</a>
<a name="ln579">void</a>
<a name="ln580">Desktop::BroadcastToAllWindows(int32 code)</a>
<a name="ln581">{</a>
<a name="ln582">	AutoReadLocker _(fWindowLock);</a>
<a name="ln583"> </a>
<a name="ln584">	for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln585">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln586">		window-&gt;ServerWindow()-&gt;PostMessage(code);</a>
<a name="ln587">	}</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590"> </a>
<a name="ln591">int32</a>
<a name="ln592">Desktop::GetAllWindowTargets(DelayedMessage&amp; message)</a>
<a name="ln593">{</a>
<a name="ln594">	AutoReadLocker _(fWindowLock);</a>
<a name="ln595">	int32 count = 0;</a>
<a name="ln596"> </a>
<a name="ln597">	for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln598">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln599">		message.AddTarget(window-&gt;ServerWindow()-&gt;MessagePort());</a>
<a name="ln600">		++count;</a>
<a name="ln601">	}</a>
<a name="ln602"> </a>
<a name="ln603">	return count;</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606"> </a>
<a name="ln607">int32</a>
<a name="ln608">Desktop::GetAllAppTargets(DelayedMessage&amp; message)</a>
<a name="ln609">{</a>
<a name="ln610">	BAutolock _(fApplicationsLock);</a>
<a name="ln611"> </a>
<a name="ln612">	for (int32 index = 0; index &lt; fApplications.CountItems(); ++index)</a>
<a name="ln613">		message.AddTarget(fApplications.ItemAt(index)-&gt;MessagePort());</a>
<a name="ln614"> </a>
<a name="ln615">	return fApplications.CountItems();</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">filter_result</a>
<a name="ln620">Desktop::KeyEvent(uint32 what, int32 key, int32 modifiers)</a>
<a name="ln621">{</a>
<a name="ln622">	filter_result result = B_DISPATCH_MESSAGE;</a>
<a name="ln623">	if (LockAllWindows()) {</a>
<a name="ln624">		Window* window = MouseEventWindow();</a>
<a name="ln625">		if (window == NULL)</a>
<a name="ln626">			window = WindowAt(fLastMousePosition);</a>
<a name="ln627"> </a>
<a name="ln628">		if (window != NULL) {</a>
<a name="ln629">			if (what == B_MODIFIERS_CHANGED)</a>
<a name="ln630">				window-&gt;ModifiersChanged(modifiers);</a>
<a name="ln631">		}</a>
<a name="ln632"> </a>
<a name="ln633">		if (NotifyKeyPressed(what, key, modifiers))</a>
<a name="ln634">			result = B_SKIP_MESSAGE;</a>
<a name="ln635"> </a>
<a name="ln636">		UnlockAllWindows();</a>
<a name="ln637">	}</a>
<a name="ln638"> </a>
<a name="ln639">	return result;</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642"> </a>
<a name="ln643">// #pragma mark - Mouse and cursor methods</a>
<a name="ln644"> </a>
<a name="ln645"> </a>
<a name="ln646">void</a>
<a name="ln647">Desktop::SetCursor(ServerCursor* newCursor)</a>
<a name="ln648">{</a>
<a name="ln649">	if (newCursor == NULL)</a>
<a name="ln650">		newCursor = fCursorManager.GetCursor(B_CURSOR_ID_SYSTEM_DEFAULT);</a>
<a name="ln651"> </a>
<a name="ln652">	if (newCursor == fCursor)</a>
<a name="ln653">		return;</a>
<a name="ln654"> </a>
<a name="ln655">	fCursor = newCursor;</a>
<a name="ln656"> </a>
<a name="ln657">	if (fManagementCursor.Get() == NULL)</a>
<a name="ln658">		HWInterface()-&gt;SetCursor(newCursor);</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661"> </a>
<a name="ln662">ServerCursorReference</a>
<a name="ln663">Desktop::Cursor() const</a>
<a name="ln664">{</a>
<a name="ln665">	return fCursor;</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668"> </a>
<a name="ln669">void</a>
<a name="ln670">Desktop::SetManagementCursor(ServerCursor* newCursor)</a>
<a name="ln671">{</a>
<a name="ln672">	if (newCursor == fManagementCursor)</a>
<a name="ln673">		return;</a>
<a name="ln674"> </a>
<a name="ln675">	fManagementCursor = newCursor;</a>
<a name="ln676"> </a>
<a name="ln677">	HWInterface()-&gt;SetCursor(newCursor != NULL ? newCursor : fCursor.Get());</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680"> </a>
<a name="ln681">void</a>
<a name="ln682">Desktop::SetLastMouseState(const BPoint&amp; position, int32 buttons,</a>
<a name="ln683">	Window* windowUnderMouse)</a>
<a name="ln684">{</a>
<a name="ln685">	// The all-window-lock is write-locked.</a>
<a name="ln686">	fLastMousePosition = position;</a>
<a name="ln687">	fLastMouseButtons = buttons;</a>
<a name="ln688"> </a>
<a name="ln689">	if (fLastMouseButtons == 0 &amp;&amp; fLockedFocusWindow) {</a>
<a name="ln690">		fLockedFocusWindow = NULL;</a>
<a name="ln691">		if (fSettings-&gt;FocusFollowsMouse())</a>
<a name="ln692">			SetFocusWindow(windowUnderMouse);</a>
<a name="ln693">	}</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696"> </a>
<a name="ln697">void</a>
<a name="ln698">Desktop::GetLastMouseState(BPoint* position, int32* buttons) const</a>
<a name="ln699">{</a>
<a name="ln700">	*position = fLastMousePosition;</a>
<a name="ln701">	*buttons = fLastMouseButtons;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">//	#pragma mark - Screen methods</a>
<a name="ln706"> </a>
<a name="ln707"> </a>
<a name="ln708">status_t</a>
<a name="ln709">Desktop::SetScreenMode(int32 workspace, int32 id, const display_mode&amp; mode,</a>
<a name="ln710">	bool makeDefault)</a>
<a name="ln711">{</a>
<a name="ln712">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln713"> </a>
<a name="ln714">	if (workspace == B_CURRENT_WORKSPACE_INDEX)</a>
<a name="ln715">		workspace = fCurrentWorkspace;</a>
<a name="ln716"> </a>
<a name="ln717">	if (workspace &lt; 0 || workspace &gt;= kMaxWorkspaces)</a>
<a name="ln718">		return B_BAD_VALUE;</a>
<a name="ln719"> </a>
<a name="ln720">	Screen* screen = fVirtualScreen.ScreenByID(id);</a>
<a name="ln721">	if (screen == NULL)</a>
<a name="ln722">		return B_NAME_NOT_FOUND;</a>
<a name="ln723"> </a>
<a name="ln724">	// Check if the mode has actually changed</a>
<a name="ln725"> </a>
<a name="ln726">	if (workspace == fCurrentWorkspace) {</a>
<a name="ln727">		// retrieve from current screen</a>
<a name="ln728">		display_mode oldMode;</a>
<a name="ln729">		screen-&gt;GetMode(oldMode);</a>
<a name="ln730"> </a>
<a name="ln731">		if (!memcmp(&amp;oldMode, &amp;mode, sizeof(display_mode)))</a>
<a name="ln732">			return B_OK;</a>
<a name="ln733"> </a>
<a name="ln734">		// Set the new one</a>
<a name="ln735"> </a>
<a name="ln736">		_SuspendDirectFrameBufferAccess();</a>
<a name="ln737"> </a>
<a name="ln738">		AutoWriteLocker locker(fScreenLock);</a>
<a name="ln739"> </a>
<a name="ln740">		status_t status = screen-&gt;SetMode(mode);</a>
<a name="ln741">		if (status != B_OK) {</a>
<a name="ln742">			locker.Unlock();</a>
<a name="ln743"> </a>
<a name="ln744">			_ResumeDirectFrameBufferAccess();</a>
<a name="ln745">			return status;</a>
<a name="ln746">		}</a>
<a name="ln747">	} else {</a>
<a name="ln748">		// retrieve from settings</a>
<a name="ln749">		screen_configuration* configuration</a>
<a name="ln750">			= fWorkspaces[workspace].CurrentScreenConfiguration().CurrentByID(</a>
<a name="ln751">				screen-&gt;ID());</a>
<a name="ln752">		if (configuration != NULL</a>
<a name="ln753">			&amp;&amp; !memcmp(&amp;configuration-&gt;mode, &amp;mode, sizeof(display_mode)))</a>
<a name="ln754">			return B_OK;</a>
<a name="ln755">	}</a>
<a name="ln756"> </a>
<a name="ln757">	// Update our configurations</a>
<a name="ln758"> </a>
<a name="ln759">	monitor_info info;</a>
<a name="ln760">	bool hasInfo = screen-&gt;GetMonitorInfo(info) == B_OK;</a>
<a name="ln761"> </a>
<a name="ln762">	fWorkspaces[workspace].CurrentScreenConfiguration().Set(id,</a>
<a name="ln763">		hasInfo ? &amp;info : NULL, screen-&gt;Frame(), mode);</a>
<a name="ln764">	if (makeDefault) {</a>
<a name="ln765">		fWorkspaces[workspace].StoredScreenConfiguration().Set(id,</a>
<a name="ln766">			hasInfo ? &amp;info : NULL, screen-&gt;Frame(), mode);</a>
<a name="ln767">		StoreWorkspaceConfiguration(workspace);</a>
<a name="ln768">	}</a>
<a name="ln769"> </a>
<a name="ln770">	_ScreenChanged(screen);</a>
<a name="ln771">	if (workspace == fCurrentWorkspace)</a>
<a name="ln772">		_ResumeDirectFrameBufferAccess();</a>
<a name="ln773"> </a>
<a name="ln774">	return B_OK;</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777"> </a>
<a name="ln778">status_t</a>
<a name="ln779">Desktop::GetScreenMode(int32 workspace, int32 id, display_mode&amp; mode)</a>
<a name="ln780">{</a>
<a name="ln781">	AutoReadLocker _(fScreenLock);</a>
<a name="ln782"> </a>
<a name="ln783">	if (workspace == B_CURRENT_WORKSPACE_INDEX)</a>
<a name="ln784">		workspace = fCurrentWorkspace;</a>
<a name="ln785"> </a>
<a name="ln786">	if (workspace &lt; 0 || workspace &gt;= kMaxWorkspaces)</a>
<a name="ln787">		return B_BAD_VALUE;</a>
<a name="ln788"> </a>
<a name="ln789">	if (workspace == fCurrentWorkspace) {</a>
<a name="ln790">		// retrieve from current screen</a>
<a name="ln791">		Screen* screen = fVirtualScreen.ScreenByID(id);</a>
<a name="ln792">		if (screen == NULL)</a>
<a name="ln793">			return B_NAME_NOT_FOUND;</a>
<a name="ln794"> </a>
<a name="ln795">		screen-&gt;GetMode(mode);</a>
<a name="ln796">		return B_OK;</a>
<a name="ln797">	}</a>
<a name="ln798"> </a>
<a name="ln799">	// retrieve from settings</a>
<a name="ln800">	screen_configuration* configuration</a>
<a name="ln801">		= fWorkspaces[workspace].CurrentScreenConfiguration().CurrentByID(id);</a>
<a name="ln802">	if (configuration == NULL)</a>
<a name="ln803">		return B_NAME_NOT_FOUND;</a>
<a name="ln804"> </a>
<a name="ln805">	mode = configuration-&gt;mode;</a>
<a name="ln806">	return B_OK;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">status_t</a>
<a name="ln811">Desktop::GetScreenFrame(int32 workspace, int32 id, BRect&amp; frame)</a>
<a name="ln812">{</a>
<a name="ln813">	AutoReadLocker _(fScreenLock);</a>
<a name="ln814"> </a>
<a name="ln815">	if (workspace == B_CURRENT_WORKSPACE_INDEX)</a>
<a name="ln816">		workspace = fCurrentWorkspace;</a>
<a name="ln817"> </a>
<a name="ln818">	if (workspace &lt; 0 || workspace &gt;= kMaxWorkspaces)</a>
<a name="ln819">		return B_BAD_VALUE;</a>
<a name="ln820"> </a>
<a name="ln821">	if (workspace == fCurrentWorkspace) {</a>
<a name="ln822">		// retrieve from current screen</a>
<a name="ln823">		Screen* screen = fVirtualScreen.ScreenByID(id);</a>
<a name="ln824">		if (screen == NULL)</a>
<a name="ln825">			return B_NAME_NOT_FOUND;</a>
<a name="ln826"> </a>
<a name="ln827">		frame = screen-&gt;Frame();</a>
<a name="ln828">		return B_OK;</a>
<a name="ln829">	}</a>
<a name="ln830"> </a>
<a name="ln831">	// retrieve from settings</a>
<a name="ln832">	screen_configuration* configuration</a>
<a name="ln833">		= fWorkspaces[workspace].CurrentScreenConfiguration().CurrentByID(id);</a>
<a name="ln834">	if (configuration == NULL)</a>
<a name="ln835">		return B_NAME_NOT_FOUND;</a>
<a name="ln836"> </a>
<a name="ln837">	frame = configuration-&gt;frame;</a>
<a name="ln838">	return B_OK;</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841"> </a>
<a name="ln842">void</a>
<a name="ln843">Desktop::RevertScreenModes(uint32 workspaces)</a>
<a name="ln844">{</a>
<a name="ln845">	if (workspaces == 0)</a>
<a name="ln846">		return;</a>
<a name="ln847"> </a>
<a name="ln848">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln849"> </a>
<a name="ln850">	for (int32 workspace = 0; workspace &lt; kMaxWorkspaces; workspace++) {</a>
<a name="ln851">		if ((workspaces &amp; (1U &lt;&lt; workspace)) == 0)</a>
<a name="ln852">			continue;</a>
<a name="ln853"> </a>
<a name="ln854">		// Revert all screens on this workspace</a>
<a name="ln855"> </a>
<a name="ln856">		// TODO: ideally, we would know which screens to revert - this way, too</a>
<a name="ln857">		// many of them could be reverted</a>
<a name="ln858"> </a>
<a name="ln859">		for (int32 index = 0; index &lt; fVirtualScreen.CountScreens(); index++) {</a>
<a name="ln860">			Screen* screen = fVirtualScreen.ScreenAt(index);</a>
<a name="ln861"> </a>
<a name="ln862">			// retrieve configurations</a>
<a name="ln863">			screen_configuration* stored = fWorkspaces[workspace]</a>
<a name="ln864">				.StoredScreenConfiguration().CurrentByID(screen-&gt;ID());</a>
<a name="ln865">			screen_configuration* current = fWorkspaces[workspace]</a>
<a name="ln866">				.CurrentScreenConfiguration().CurrentByID(screen-&gt;ID());</a>
<a name="ln867"> </a>
<a name="ln868">			if ((stored != NULL &amp;&amp; current != NULL</a>
<a name="ln869">					&amp;&amp; !memcmp(&amp;stored-&gt;mode, &amp;current-&gt;mode,</a>
<a name="ln870">							sizeof(display_mode)))</a>
<a name="ln871">				|| (stored == NULL &amp;&amp; current == NULL))</a>
<a name="ln872">				continue;</a>
<a name="ln873"> </a>
<a name="ln874">			if (stored == NULL) {</a>
<a name="ln875">				fWorkspaces[workspace].CurrentScreenConfiguration()</a>
<a name="ln876">					.Remove(current);</a>
<a name="ln877"> </a>
<a name="ln878">				if (workspace == fCurrentWorkspace) {</a>
<a name="ln879">					_SuspendDirectFrameBufferAccess();</a>
<a name="ln880">					_SetCurrentWorkspaceConfiguration();</a>
<a name="ln881">					_ResumeDirectFrameBufferAccess();</a>
<a name="ln882">				}</a>
<a name="ln883">			} else</a>
<a name="ln884">				SetScreenMode(workspace, screen-&gt;ID(), stored-&gt;mode, false);</a>
<a name="ln885">		}</a>
<a name="ln886">	}</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889"> </a>
<a name="ln890">status_t</a>
<a name="ln891">Desktop::LockDirectScreen(team_id team)</a>
<a name="ln892">{</a>
<a name="ln893">	// TODO: BWindowScreens should use the same mechanism as BDirectWindow,</a>
<a name="ln894">	// which would make this method superfluous.</a>
<a name="ln895"> </a>
<a name="ln896">	status_t status = fDirectScreenLock.LockWithTimeout(1000000L);</a>
<a name="ln897">	if (status == B_OK)</a>
<a name="ln898">		fDirectScreenTeam = team;</a>
<a name="ln899"> </a>
<a name="ln900">	return status;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903"> </a>
<a name="ln904">status_t</a>
<a name="ln905">Desktop::UnlockDirectScreen(team_id team)</a>
<a name="ln906">{</a>
<a name="ln907">	if (fDirectScreenTeam == team) {</a>
<a name="ln908">		fDirectScreenLock.Unlock();</a>
<a name="ln909">		fDirectScreenTeam = -1;</a>
<a name="ln910">		return B_OK;</a>
<a name="ln911">	}</a>
<a name="ln912"> </a>
<a name="ln913">	return B_PERMISSION_DENIED;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">// #pragma mark - Workspaces methods</a>
<a name="ln918"> </a>
<a name="ln919"> </a>
<a name="ln920">/*!	Changes the current workspace to the one specified by \a index.</a>
<a name="ln921">*/</a>
<a name="ln922">void</a>
<a name="ln923">Desktop::SetWorkspaceAsync(int32 index, bool moveFocusWindow)</a>
<a name="ln924">{</a>
<a name="ln925">	BPrivate::LinkSender link(MessagePort());</a>
<a name="ln926">	link.StartMessage(AS_ACTIVATE_WORKSPACE);</a>
<a name="ln927">	link.Attach&lt;int32&gt;(index);</a>
<a name="ln928">	link.Attach&lt;bool&gt;(moveFocusWindow);</a>
<a name="ln929">	link.Flush();</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932"> </a>
<a name="ln933">/*!	Changes the current workspace to the one specified by \a index.</a>
<a name="ln934">	You must not hold any window lock when calling this method.</a>
<a name="ln935">*/</a>
<a name="ln936">void</a>
<a name="ln937">Desktop::SetWorkspace(int32 index, bool moveFocusWindow)</a>
<a name="ln938">{</a>
<a name="ln939">	LockAllWindows();</a>
<a name="ln940">	DesktopSettings settings(this);</a>
<a name="ln941"> </a>
<a name="ln942">	if (index &lt; 0 || index &gt;= settings.WorkspacesCount()</a>
<a name="ln943">		|| index == fCurrentWorkspace) {</a>
<a name="ln944">		UnlockAllWindows();</a>
<a name="ln945">		return;</a>
<a name="ln946">	}</a>
<a name="ln947"> </a>
<a name="ln948">	_SetWorkspace(index, moveFocusWindow);</a>
<a name="ln949">	UnlockAllWindows();</a>
<a name="ln950"> </a>
<a name="ln951">	_SendFakeMouseMoved();</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954"> </a>
<a name="ln955">status_t</a>
<a name="ln956">Desktop::SetWorkspacesLayout(int32 newColumns, int32 newRows)</a>
<a name="ln957">{</a>
<a name="ln958">	int32 newCount = newColumns * newRows;</a>
<a name="ln959">	if (newCount &lt; 1 || newCount &gt; kMaxWorkspaces)</a>
<a name="ln960">		return B_BAD_VALUE;</a>
<a name="ln961"> </a>
<a name="ln962">	if (!LockAllWindows())</a>
<a name="ln963">		return B_ERROR;</a>
<a name="ln964"> </a>
<a name="ln965">	fSettings-&gt;SetWorkspacesLayout(newColumns, newRows);</a>
<a name="ln966"> </a>
<a name="ln967">	// either update the workspaces window, or switch to</a>
<a name="ln968">	// the last available workspace - which will update</a>
<a name="ln969">	// the workspaces window automatically</a>
<a name="ln970">	bool workspaceChanged = CurrentWorkspace() &gt;= newCount;</a>
<a name="ln971">	if (workspaceChanged)</a>
<a name="ln972">		_SetWorkspace(newCount - 1);</a>
<a name="ln973">	else</a>
<a name="ln974">		_WindowChanged(NULL);</a>
<a name="ln975"> </a>
<a name="ln976">	UnlockAllWindows();</a>
<a name="ln977"> </a>
<a name="ln978">	if (workspaceChanged)</a>
<a name="ln979">		_SendFakeMouseMoved();</a>
<a name="ln980"> </a>
<a name="ln981">	return B_OK;</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984"> </a>
<a name="ln985">/*!	Returns the virtual screen frame of the workspace specified by \a index.</a>
<a name="ln986">*/</a>
<a name="ln987">BRect</a>
<a name="ln988">Desktop::WorkspaceFrame(int32 index) const</a>
<a name="ln989">{</a>
<a name="ln990">	BRect frame;</a>
<a name="ln991">	if (index == fCurrentWorkspace)</a>
<a name="ln992">		frame = fVirtualScreen.Frame();</a>
<a name="ln993">	else if (index &gt;= 0 &amp;&amp; index &lt; fSettings-&gt;WorkspacesCount()) {</a>
<a name="ln994">		BMessage screenData;</a>
<a name="ln995">		if (fSettings-&gt;WorkspacesMessage(index)-&gt;FindMessage(&quot;screen&quot;,</a>
<a name="ln996">				&amp;screenData) != B_OK</a>
<a name="ln997">			|| screenData.FindRect(&quot;frame&quot;, &amp;frame) != B_OK) {</a>
<a name="ln998">			frame = fVirtualScreen.Frame();</a>
<a name="ln999">		}</a>
<a name="ln1000">	}</a>
<a name="ln1001"> </a>
<a name="ln1002">	return frame;</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005"> </a>
<a name="ln1006">/*!	\brief Stores the workspace configuration.</a>
<a name="ln1007">	You must hold the window lock when calling this method.</a>
<a name="ln1008">*/</a>
<a name="ln1009">void</a>
<a name="ln1010">Desktop::StoreWorkspaceConfiguration(int32 index)</a>
<a name="ln1011">{</a>
<a name="ln1012">	// Retrieve settings</a>
<a name="ln1013"> </a>
<a name="ln1014">	BMessage settings;</a>
<a name="ln1015">	fWorkspaces[index].StoreConfiguration(settings);</a>
<a name="ln1016"> </a>
<a name="ln1017">	// and store them</a>
<a name="ln1018"> </a>
<a name="ln1019">	fSettings-&gt;SetWorkspacesMessage(index, settings);</a>
<a name="ln1020">	fSettings-&gt;Save(kWorkspacesSettings);</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023"> </a>
<a name="ln1024">void</a>
<a name="ln1025">Desktop::AddWorkspacesView(WorkspacesView* view)</a>
<a name="ln1026">{</a>
<a name="ln1027">	if (view-&gt;Window() == NULL || view-&gt;Window()-&gt;IsHidden())</a>
<a name="ln1028">		return;</a>
<a name="ln1029"> </a>
<a name="ln1030">	BAutolock _(fWorkspacesLock);</a>
<a name="ln1031"> </a>
<a name="ln1032">	if (!fWorkspacesViews.HasItem(view))</a>
<a name="ln1033">		fWorkspacesViews.AddItem(view);</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">void</a>
<a name="ln1038">Desktop::RemoveWorkspacesView(WorkspacesView* view)</a>
<a name="ln1039">{</a>
<a name="ln1040">	BAutolock _(fWorkspacesLock);</a>
<a name="ln1041">	fWorkspacesViews.RemoveItem(view);</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044"> </a>
<a name="ln1045">//	#pragma mark - Methods for Window manipulation</a>
<a name="ln1046"> </a>
<a name="ln1047"> </a>
<a name="ln1048">/*!	\brief Activates or focusses the window based on the pointer position.</a>
<a name="ln1049">*/</a>
<a name="ln1050">void</a>
<a name="ln1051">Desktop::SelectWindow(Window* window)</a>
<a name="ln1052">{</a>
<a name="ln1053">	if (fSettings-&gt;ClickToFocusMouse()) {</a>
<a name="ln1054">		// Only bring the window to front when it is not the window under the</a>
<a name="ln1055">		// mouse pointer. This should result in sensible behaviour.</a>
<a name="ln1056">		if (window != fWindowUnderMouse</a>
<a name="ln1057">			|| (window == fWindowUnderMouse &amp;&amp; window != FocusWindow()))</a>
<a name="ln1058">			ActivateWindow(window);</a>
<a name="ln1059">		else</a>
<a name="ln1060">			SetFocusWindow(window);</a>
<a name="ln1061">	} else</a>
<a name="ln1062">		ActivateWindow(window);</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065"> </a>
<a name="ln1066">/*!	\brief Tries to move the specified window to the front of the screen,</a>
<a name="ln1067">		and make it the focus window.</a>
<a name="ln1068"> </a>
<a name="ln1069">	If there are any modal windows on this screen, it might not actually</a>
<a name="ln1070">	become the frontmost window, though, as modal windows stay in front</a>
<a name="ln1071">	of their subset.</a>
<a name="ln1072">*/</a>
<a name="ln1073">void</a>
<a name="ln1074">Desktop::ActivateWindow(Window* window)</a>
<a name="ln1075">{</a>
<a name="ln1076">	STRACE((&quot;ActivateWindow(%p, %s)\n&quot;, window, window</a>
<a name="ln1077">		? window-&gt;Title() : &quot;&lt;none&gt;&quot;));</a>
<a name="ln1078"> </a>
<a name="ln1079">	if (window == NULL) {</a>
<a name="ln1080">		fBack = NULL;</a>
<a name="ln1081">		fFront = NULL;</a>
<a name="ln1082">		return;</a>
<a name="ln1083">	}</a>
<a name="ln1084">	if (window-&gt;Workspaces() == 0 &amp;&amp; window-&gt;IsNormal())</a>
<a name="ln1085">		return;</a>
<a name="ln1086"> </a>
<a name="ln1087">	AutoWriteLocker allWindowLocker(fWindowLock);</a>
<a name="ln1088"> </a>
<a name="ln1089">	NotifyWindowActivated(window);</a>
<a name="ln1090"> </a>
<a name="ln1091">	bool windowOnOtherWorkspace = !window-&gt;InWorkspace(fCurrentWorkspace);</a>
<a name="ln1092">	if (windowOnOtherWorkspace</a>
<a name="ln1093">		&amp;&amp; (window-&gt;Flags() &amp; B_NOT_ANCHORED_ON_ACTIVATE) == 0) {</a>
<a name="ln1094">		if ((window-&gt;Flags() &amp; B_NO_WORKSPACE_ACTIVATION) == 0) {</a>
<a name="ln1095">			// Switch to the workspace on which this window is</a>
<a name="ln1096">			// (we'll take the first one that the window is on)</a>
<a name="ln1097">			uint32 workspaces = window-&gt;Workspaces();</a>
<a name="ln1098">			for (int32 i = 0; i &lt; fSettings-&gt;WorkspacesCount(); i++) {</a>
<a name="ln1099">				uint32 workspace = workspace_to_workspaces(i);</a>
<a name="ln1100">				if (workspaces &amp; workspace) {</a>
<a name="ln1101">					SetWorkspace(i);</a>
<a name="ln1102">					windowOnOtherWorkspace = false;</a>
<a name="ln1103">					break;</a>
<a name="ln1104">				}</a>
<a name="ln1105">			}</a>
<a name="ln1106">		} else</a>
<a name="ln1107">			return;</a>
<a name="ln1108">	}</a>
<a name="ln1109"> </a>
<a name="ln1110">	if (windowOnOtherWorkspace) {</a>
<a name="ln1111">		if (!window-&gt;IsNormal()) {</a>
<a name="ln1112">			// Bring a window to front that this floating window belongs to</a>
<a name="ln1113">			Window* front = _LastFocusSubsetWindow(window);</a>
<a name="ln1114">			if (front == NULL) {</a>
<a name="ln1115">				// We can't do anything about those.</a>
<a name="ln1116">				return;</a>
<a name="ln1117">			}</a>
<a name="ln1118"> </a>
<a name="ln1119">			ActivateWindow(front);</a>
<a name="ln1120"> </a>
<a name="ln1121">			if (!window-&gt;InWorkspace(fCurrentWorkspace)) {</a>
<a name="ln1122">				// This window can't be made active</a>
<a name="ln1123">				return;</a>
<a name="ln1124">			}</a>
<a name="ln1125">		} else {</a>
<a name="ln1126">			// Bring the window to the current workspace</a>
<a name="ln1127">			// TODO: what if this window is on multiple workspaces?!?</a>
<a name="ln1128">			uint32 workspaces = workspace_to_workspaces(fCurrentWorkspace);</a>
<a name="ln1129">			SetWindowWorkspaces(window, workspaces);</a>
<a name="ln1130">		}</a>
<a name="ln1131">	}</a>
<a name="ln1132"> </a>
<a name="ln1133">	if (window-&gt;IsMinimized()) {</a>
<a name="ln1134">		// Unlike WindowAction(), this is called from the application itself,</a>
<a name="ln1135">		// so we will just unminimize the window here.</a>
<a name="ln1136">		window-&gt;SetMinimized(false);</a>
<a name="ln1137">		ShowWindow(window);</a>
<a name="ln1138">	}</a>
<a name="ln1139"> </a>
<a name="ln1140">	if (window == FrontWindow()) {</a>
<a name="ln1141">		// see if there is a normal B_AVOID_FRONT window still in front of us</a>
<a name="ln1142">		Window* avoidsFront = window-&gt;NextWindow(fCurrentWorkspace);</a>
<a name="ln1143">		while (avoidsFront &amp;&amp; avoidsFront-&gt;IsNormal()</a>
<a name="ln1144">			&amp;&amp; (avoidsFront-&gt;Flags() &amp; B_AVOID_FRONT) == 0) {</a>
<a name="ln1145">			avoidsFront = avoidsFront-&gt;NextWindow(fCurrentWorkspace);</a>
<a name="ln1146">		}</a>
<a name="ln1147"> </a>
<a name="ln1148">		if (avoidsFront == NULL) {</a>
<a name="ln1149">			// we're already the frontmost window, we might just not have focus</a>
<a name="ln1150">			// yet</a>
<a name="ln1151">			if ((window-&gt;Flags() &amp; B_AVOID_FOCUS) == 0)</a>
<a name="ln1152">				SetFocusWindow(window);</a>
<a name="ln1153">			return;</a>
<a name="ln1154">		}</a>
<a name="ln1155">	}</a>
<a name="ln1156"> </a>
<a name="ln1157">	WindowList windows(kWorkingList);</a>
<a name="ln1158">	Window* frontmost = window-&gt;Frontmost();</a>
<a name="ln1159">	const Window* lastWindowUnderMouse = fWindowUnderMouse;</a>
<a name="ln1160"> </a>
<a name="ln1161">	CurrentWindows().RemoveWindow(window);</a>
<a name="ln1162">	windows.AddWindow(window);</a>
<a name="ln1163">	window-&gt;MoveToTopStackLayer();</a>
<a name="ln1164"> </a>
<a name="ln1165">	if (frontmost != NULL &amp;&amp; frontmost-&gt;IsModal()) {</a>
<a name="ln1166">		// all modal windows follow their subsets to the front</a>
<a name="ln1167">		// (ie. they are staying in front of them, but they are</a>
<a name="ln1168">		// not supposed to change their order because of that)</a>
<a name="ln1169"> </a>
<a name="ln1170">		Window* nextModal;</a>
<a name="ln1171">		for (Window* modal = frontmost; modal != NULL; modal = nextModal) {</a>
<a name="ln1172">			// get the next modal window</a>
<a name="ln1173">			nextModal = modal-&gt;NextWindow(fCurrentWorkspace);</a>
<a name="ln1174">			while (nextModal != NULL &amp;&amp; !nextModal-&gt;IsModal()) {</a>
<a name="ln1175">				nextModal = nextModal-&gt;NextWindow(fCurrentWorkspace);</a>
<a name="ln1176">			}</a>
<a name="ln1177">			if (nextModal != NULL &amp;&amp; !nextModal-&gt;HasInSubset(window))</a>
<a name="ln1178">				nextModal = NULL;</a>
<a name="ln1179"> </a>
<a name="ln1180">			CurrentWindows().RemoveWindow(modal);</a>
<a name="ln1181">			windows.AddWindow(modal);</a>
<a name="ln1182">		}</a>
<a name="ln1183">	}</a>
<a name="ln1184"> </a>
<a name="ln1185">	_BringWindowsToFront(windows, kWorkingList, true);</a>
<a name="ln1186"> </a>
<a name="ln1187">	if ((window-&gt;Flags() &amp; B_AVOID_FOCUS) == 0)</a>
<a name="ln1188">		SetFocusWindow(window);</a>
<a name="ln1189"> </a>
<a name="ln1190">	bool sendFakeMouseMoved = _CheckSendFakeMouseMoved(lastWindowUnderMouse);</a>
<a name="ln1191"> </a>
<a name="ln1192">	allWindowLocker.Unlock();</a>
<a name="ln1193"> </a>
<a name="ln1194">	if (sendFakeMouseMoved)</a>
<a name="ln1195">		_SendFakeMouseMoved();</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>
<a name="ln1198"> </a>
<a name="ln1199">void</a>
<a name="ln1200">Desktop::SendWindowBehind(Window* window, Window* behindOf, bool sendStack)</a>
<a name="ln1201">{</a>
<a name="ln1202">	if (!LockAllWindows())</a>
<a name="ln1203">		return;</a>
<a name="ln1204"> </a>
<a name="ln1205">	Window* orgWindow = window;</a>
<a name="ln1206">	WindowStack* stack = window-&gt;GetWindowStack();</a>
<a name="ln1207">	if (sendStack &amp;&amp; stack != NULL)</a>
<a name="ln1208">		window = stack-&gt;TopLayerWindow();</a>
<a name="ln1209"> </a>
<a name="ln1210">	// TODO: should the &quot;not in current workspace&quot; be handled anyway?</a>
<a name="ln1211">	//	(the code below would have to be changed then, though)</a>
<a name="ln1212">	if (window == BackWindow()</a>
<a name="ln1213">		|| !window-&gt;InWorkspace(fCurrentWorkspace)</a>
<a name="ln1214">		|| (behindOf != NULL &amp;&amp; !behindOf-&gt;InWorkspace(fCurrentWorkspace))) {</a>
<a name="ln1215">		UnlockAllWindows();</a>
<a name="ln1216">		return;</a>
<a name="ln1217">	}</a>
<a name="ln1218"> </a>
<a name="ln1219">	// Is this a valid behindOf window?</a>
<a name="ln1220">	if (behindOf != NULL &amp;&amp; window-&gt;HasInSubset(behindOf))</a>
<a name="ln1221">		behindOf = NULL;</a>
<a name="ln1222"> </a>
<a name="ln1223">	// what is currently visible of the window</a>
<a name="ln1224">	// might be dirty after the window is send to back</a>
<a name="ln1225">	BRegion dirty(window-&gt;VisibleRegion());</a>
<a name="ln1226"> </a>
<a name="ln1227">	Window* backmost = window-&gt;Backmost(behindOf);</a>
<a name="ln1228">	const Window* lastWindowUnderMouse = fWindowUnderMouse;</a>
<a name="ln1229"> </a>
<a name="ln1230">	CurrentWindows().RemoveWindow(window);</a>
<a name="ln1231">	CurrentWindows().AddWindow(window, backmost</a>
<a name="ln1232">		? backmost-&gt;NextWindow(fCurrentWorkspace) : BackWindow());</a>
<a name="ln1233"> </a>
<a name="ln1234">	BRegion dummy;</a>
<a name="ln1235">	_RebuildClippingForAllWindows(dummy);</a>
<a name="ln1236"> </a>
<a name="ln1237">	// only redraw the top layer window to avoid flicker</a>
<a name="ln1238">	if (sendStack) {</a>
<a name="ln1239">		// mark everything dirty that is no longer visible</a>
<a name="ln1240">		BRegion clean(window-&gt;VisibleRegion());</a>
<a name="ln1241">		dirty.Exclude(&amp;clean);</a>
<a name="ln1242">		MarkDirty(dirty);</a>
<a name="ln1243">	}</a>
<a name="ln1244"> </a>
<a name="ln1245">	_UpdateFronts();</a>
<a name="ln1246">	if (fSettings-&gt;FocusFollowsMouse())</a>
<a name="ln1247">		SetFocusWindow(WindowAt(fLastMousePosition));</a>
<a name="ln1248">	else if (fSettings-&gt;NormalMouse())</a>
<a name="ln1249">		SetFocusWindow(NULL);</a>
<a name="ln1250"> </a>
<a name="ln1251">	_WindowChanged(window);</a>
<a name="ln1252"> </a>
<a name="ln1253">	if (sendStack &amp;&amp; stack != NULL) {</a>
<a name="ln1254">		for (int32 i = 0; i &lt; stack-&gt;CountWindows(); i++) {</a>
<a name="ln1255">			Window* stackWindow = stack-&gt;LayerOrder().ItemAt(i);</a>
<a name="ln1256">			if (stackWindow == window)</a>
<a name="ln1257">				continue;</a>
<a name="ln1258">			SendWindowBehind(stackWindow, behindOf, false);</a>
<a name="ln1259">		}</a>
<a name="ln1260">	}</a>
<a name="ln1261"> </a>
<a name="ln1262">	bool sendFakeMouseMoved = _CheckSendFakeMouseMoved(lastWindowUnderMouse);</a>
<a name="ln1263">	NotifyWindowSentBehind(orgWindow, behindOf);</a>
<a name="ln1264"> </a>
<a name="ln1265">	UnlockAllWindows();</a>
<a name="ln1266"> </a>
<a name="ln1267">	if (sendFakeMouseMoved)</a>
<a name="ln1268">		_SendFakeMouseMoved();</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271"> </a>
<a name="ln1272">void</a>
<a name="ln1273">Desktop::ShowWindow(Window* window)</a>
<a name="ln1274">{</a>
<a name="ln1275">	if (!window-&gt;IsHidden())</a>
<a name="ln1276">		return;</a>
<a name="ln1277"> </a>
<a name="ln1278">	AutoWriteLocker locker(fWindowLock);</a>
<a name="ln1279"> </a>
<a name="ln1280">	window-&gt;SetHidden(false);</a>
<a name="ln1281">	fFocusList.AddWindow(window);</a>
<a name="ln1282"> </a>
<a name="ln1283">	// If the window is on the current workspace, we'll show it. Special</a>
<a name="ln1284">	// handling for floating windows, as they can only be shown if their</a>
<a name="ln1285">	// subset is.</a>
<a name="ln1286">	if (window-&gt;InWorkspace(fCurrentWorkspace)</a>
<a name="ln1287">		|| (window-&gt;IsFloating() &amp;&amp; _LastFocusSubsetWindow(window) != NULL)) {</a>
<a name="ln1288">		_ShowWindow(window, true);</a>
<a name="ln1289">		_UpdateSubsetWorkspaces(window);</a>
<a name="ln1290">		ActivateWindow(window);</a>
<a name="ln1291">	} else {</a>
<a name="ln1292">		// then we don't need to send the fake mouse event either</a>
<a name="ln1293">		_WindowChanged(window);</a>
<a name="ln1294">		return;</a>
<a name="ln1295">	}</a>
<a name="ln1296"> </a>
<a name="ln1297">	if (window-&gt;HasWorkspacesViews()) {</a>
<a name="ln1298">		// find workspaces views in view hierarchy</a>
<a name="ln1299">		BAutolock _(fWorkspacesLock);</a>
<a name="ln1300">		window-&gt;FindWorkspacesViews(fWorkspacesViews);</a>
<a name="ln1301">	}</a>
<a name="ln1302"> </a>
<a name="ln1303">	// If the mouse cursor is directly over the newly visible window,</a>
<a name="ln1304">	// we'll send a fake mouse moved message to the window, so that</a>
<a name="ln1305">	// it knows the mouse is over it.</a>
<a name="ln1306"> </a>
<a name="ln1307">	_SendFakeMouseMoved(window);</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">void</a>
<a name="ln1312">Desktop::HideWindow(Window* window, bool fromMinimize)</a>
<a name="ln1313">{</a>
<a name="ln1314">	if (window-&gt;IsHidden())</a>
<a name="ln1315">		return;</a>
<a name="ln1316"> </a>
<a name="ln1317">	if (!LockAllWindows())</a>
<a name="ln1318">		return;</a>
<a name="ln1319"> </a>
<a name="ln1320">	window-&gt;SetHidden(true);</a>
<a name="ln1321">	fFocusList.RemoveWindow(window);</a>
<a name="ln1322"> </a>
<a name="ln1323">	if (fMouseEventWindow == window) {</a>
<a name="ln1324">		// Make its decorator lose the current mouse action</a>
<a name="ln1325">		BMessage message;</a>
<a name="ln1326">		int32 viewToken;</a>
<a name="ln1327">		window-&gt;MouseUp(&amp;message, fLastMousePosition, &amp;viewToken);</a>
<a name="ln1328"> </a>
<a name="ln1329">		fMouseEventWindow = NULL;</a>
<a name="ln1330">	}</a>
<a name="ln1331"> </a>
<a name="ln1332">	if (fLockedFocusWindow == window) {</a>
<a name="ln1333">		// Remove the focus lock so the focus can be changed below</a>
<a name="ln1334">		fLockedFocusWindow = NULL;</a>
<a name="ln1335">	}</a>
<a name="ln1336"> </a>
<a name="ln1337">	if (window-&gt;InWorkspace(fCurrentWorkspace)) {</a>
<a name="ln1338">		_UpdateSubsetWorkspaces(window);</a>
<a name="ln1339">		_HideWindow(window);</a>
<a name="ln1340">		_UpdateFronts();</a>
<a name="ln1341">	} else</a>
<a name="ln1342">		_WindowChanged(window);</a>
<a name="ln1343"> </a>
<a name="ln1344">	if (FocusWindow() == window)</a>
<a name="ln1345">		SetFocusWindow();</a>
<a name="ln1346"> </a>
<a name="ln1347">	_WindowRemoved(window);</a>
<a name="ln1348"> </a>
<a name="ln1349">	if (window-&gt;HasWorkspacesViews()) {</a>
<a name="ln1350">		// remove workspaces views from this window</a>
<a name="ln1351">		BObjectList&lt;WorkspacesView&gt; list(false);</a>
<a name="ln1352">		window-&gt;FindWorkspacesViews(list);</a>
<a name="ln1353"> </a>
<a name="ln1354">		BAutolock _(fWorkspacesLock);</a>
<a name="ln1355"> </a>
<a name="ln1356">		while (WorkspacesView* view = list.RemoveItemAt(0)) {</a>
<a name="ln1357">			fWorkspacesViews.RemoveItem(view);</a>
<a name="ln1358">		}</a>
<a name="ln1359">	}</a>
<a name="ln1360"> </a>
<a name="ln1361">	NotifyWindowHidden(window, fromMinimize);</a>
<a name="ln1362"> </a>
<a name="ln1363">	UnlockAllWindows();</a>
<a name="ln1364"> </a>
<a name="ln1365">	if (window == fWindowUnderMouse)</a>
<a name="ln1366">		_SendFakeMouseMoved();</a>
<a name="ln1367">}</a>
<a name="ln1368"> </a>
<a name="ln1369"> </a>
<a name="ln1370">void</a>
<a name="ln1371">Desktop::MinimizeWindow(Window* window, bool minimize)</a>
<a name="ln1372">{</a>
<a name="ln1373">	if (!LockAllWindows())</a>
<a name="ln1374">		return;</a>
<a name="ln1375"> </a>
<a name="ln1376">	if (minimize &amp;&amp; !window-&gt;IsHidden()) {</a>
<a name="ln1377">		HideWindow(window, true);</a>
<a name="ln1378">		window-&gt;SetMinimized(minimize);</a>
<a name="ln1379">		NotifyWindowMinimized(window, minimize);</a>
<a name="ln1380">	} else if (!minimize &amp;&amp; window-&gt;IsHidden()) {</a>
<a name="ln1381">		ActivateWindow(window);</a>
<a name="ln1382">			// this will unminimize the window for us</a>
<a name="ln1383">		NotifyWindowMinimized(window, minimize);</a>
<a name="ln1384">	}</a>
<a name="ln1385"> </a>
<a name="ln1386">	UnlockAllWindows();</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389"> </a>
<a name="ln1390">void</a>
<a name="ln1391">Desktop::MoveWindowBy(Window* window, float x, float y, int32 workspace)</a>
<a name="ln1392">{</a>
<a name="ln1393">	if (x == 0 &amp;&amp; y == 0)</a>
<a name="ln1394">		return;</a>
<a name="ln1395"> </a>
<a name="ln1396">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1397"> </a>
<a name="ln1398">	Window* topWindow = window-&gt;TopLayerStackWindow();</a>
<a name="ln1399">	if (topWindow != NULL)</a>
<a name="ln1400">		window = topWindow;</a>
<a name="ln1401"> </a>
<a name="ln1402">	if (workspace == -1)</a>
<a name="ln1403">		workspace = fCurrentWorkspace;</a>
<a name="ln1404">	if (!window-&gt;IsVisible() || workspace != fCurrentWorkspace) {</a>
<a name="ln1405">		if (workspace != fCurrentWorkspace) {</a>
<a name="ln1406">			WindowStack* stack = window-&gt;GetWindowStack();</a>
<a name="ln1407">			if (stack != NULL) {</a>
<a name="ln1408">				for (int32 s = 0; s &lt; stack-&gt;CountWindows(); s++) {</a>
<a name="ln1409">					Window* stackWindow = stack-&gt;WindowAt(s);</a>
<a name="ln1410">					// move the window on another workspace - this doesn't</a>
<a name="ln1411">					// change it's current position</a>
<a name="ln1412">					if (stackWindow-&gt;Anchor(workspace).position</a>
<a name="ln1413">						== kInvalidWindowPosition) {</a>
<a name="ln1414">						stackWindow-&gt;Anchor(workspace).position</a>
<a name="ln1415">							= stackWindow-&gt;Frame().LeftTop();</a>
<a name="ln1416">					}</a>
<a name="ln1417"> </a>
<a name="ln1418">					stackWindow-&gt;Anchor(workspace).position += BPoint(x, y);</a>
<a name="ln1419">					stackWindow-&gt;SetCurrentWorkspace(workspace);</a>
<a name="ln1420">					_WindowChanged(stackWindow);</a>
<a name="ln1421">				}</a>
<a name="ln1422">			}</a>
<a name="ln1423">		} else</a>
<a name="ln1424">			window-&gt;MoveBy((int32)x, (int32)y);</a>
<a name="ln1425"> </a>
<a name="ln1426">		NotifyWindowMoved(window);</a>
<a name="ln1427">		return;</a>
<a name="ln1428">	}</a>
<a name="ln1429"> </a>
<a name="ln1430">	// the dirty region starts with the visible area of the window being moved</a>
<a name="ln1431">	BRegion newDirtyRegion(window-&gt;VisibleRegion());</a>
<a name="ln1432"> </a>
<a name="ln1433">	// stop direct frame buffer access</a>
<a name="ln1434">	bool direct = false;</a>
<a name="ln1435">	if (window-&gt;ServerWindow()-&gt;IsDirectlyAccessing()) {</a>
<a name="ln1436">		window-&gt;ServerWindow()-&gt;HandleDirectConnection(B_DIRECT_STOP);</a>
<a name="ln1437">		direct = true;</a>
<a name="ln1438">	}</a>
<a name="ln1439"> </a>
<a name="ln1440">	window-&gt;MoveBy((int32)x, (int32)y);</a>
<a name="ln1441"> </a>
<a name="ln1442">	BRegion background;</a>
<a name="ln1443">	_RebuildClippingForAllWindows(background);</a>
<a name="ln1444"> </a>
<a name="ln1445">	// construct the region that is possible to be blitted</a>
<a name="ln1446">	// to move the contents of the window</a>
<a name="ln1447">	BRegion copyRegion(window-&gt;VisibleRegion());</a>
<a name="ln1448">	copyRegion.OffsetBy((int32)-x, (int32)-y);</a>
<a name="ln1449">	copyRegion.IntersectWith(&amp;newDirtyRegion);</a>
<a name="ln1450">		// newDirtyRegion == the windows old visible region</a>
<a name="ln1451"> </a>
<a name="ln1452">	// include the the new visible region of the window being</a>
<a name="ln1453">	// moved into the dirty region (for now)</a>
<a name="ln1454">	newDirtyRegion.Include(&amp;window-&gt;VisibleRegion());</a>
<a name="ln1455"> </a>
<a name="ln1456">	// NOTE: Having all windows locked should prevent any</a>
<a name="ln1457">	// problems with locking the drawing engine here.</a>
<a name="ln1458">	if (GetDrawingEngine()-&gt;LockParallelAccess()) {</a>
<a name="ln1459">		GetDrawingEngine()-&gt;CopyRegion(&amp;copyRegion, (int32)x, (int32)y);</a>
<a name="ln1460">		GetDrawingEngine()-&gt;UnlockParallelAccess();</a>
<a name="ln1461">	}</a>
<a name="ln1462"> </a>
<a name="ln1463">	// in the dirty region, exclude the parts that we</a>
<a name="ln1464">	// could move by blitting</a>
<a name="ln1465">	copyRegion.OffsetBy((int32)x, (int32)y);</a>
<a name="ln1466">	newDirtyRegion.Exclude(&amp;copyRegion);</a>
<a name="ln1467"> </a>
<a name="ln1468">	MarkDirty(newDirtyRegion);</a>
<a name="ln1469">	_SetBackground(background);</a>
<a name="ln1470">	_WindowChanged(window);</a>
<a name="ln1471"> </a>
<a name="ln1472">	// resume direct frame buffer access</a>
<a name="ln1473">	if (direct) {</a>
<a name="ln1474">		// TODO: the clipping actually only changes when we move our window</a>
<a name="ln1475">		// off screen, or behind some other window</a>
<a name="ln1476">		window-&gt;ServerWindow()-&gt;HandleDirectConnection(</a>
<a name="ln1477">			B_DIRECT_START | B_BUFFER_MOVED | B_CLIPPING_MODIFIED);</a>
<a name="ln1478">	}</a>
<a name="ln1479"> </a>
<a name="ln1480">	NotifyWindowMoved(window);</a>
<a name="ln1481">}</a>
<a name="ln1482"> </a>
<a name="ln1483"> </a>
<a name="ln1484">void</a>
<a name="ln1485">Desktop::ResizeWindowBy(Window* window, float x, float y)</a>
<a name="ln1486">{</a>
<a name="ln1487">	if (x == 0 &amp;&amp; y == 0)</a>
<a name="ln1488">		return;</a>
<a name="ln1489"> </a>
<a name="ln1490">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1491"> </a>
<a name="ln1492">	Window* topWindow = window-&gt;TopLayerStackWindow();</a>
<a name="ln1493">	if (topWindow)</a>
<a name="ln1494">		window = topWindow;</a>
<a name="ln1495"> </a>
<a name="ln1496">	if (!window-&gt;IsVisible()) {</a>
<a name="ln1497">		window-&gt;ResizeBy((int32)x, (int32)y, NULL);</a>
<a name="ln1498">		NotifyWindowResized(window);</a>
<a name="ln1499">		return;</a>
<a name="ln1500">	}</a>
<a name="ln1501"> </a>
<a name="ln1502">	// the dirty region for the inside of the window is</a>
<a name="ln1503">	// constructed by the window itself in ResizeBy()</a>
<a name="ln1504">	BRegion newDirtyRegion;</a>
<a name="ln1505">	// track the dirty region outside the window in case</a>
<a name="ln1506">	// it is shrunk in &quot;previouslyOccupiedRegion&quot;</a>
<a name="ln1507">	BRegion previouslyOccupiedRegion(window-&gt;VisibleRegion());</a>
<a name="ln1508"> </a>
<a name="ln1509">	// stop direct frame buffer access</a>
<a name="ln1510">	bool direct = false;</a>
<a name="ln1511">	if (window-&gt;ServerWindow()-&gt;IsDirectlyAccessing()) {</a>
<a name="ln1512">		window-&gt;ServerWindow()-&gt;HandleDirectConnection(B_DIRECT_STOP);</a>
<a name="ln1513">		direct = true;</a>
<a name="ln1514">	}</a>
<a name="ln1515"> </a>
<a name="ln1516">	window-&gt;ResizeBy((int32)x, (int32)y, &amp;newDirtyRegion);</a>
<a name="ln1517"> </a>
<a name="ln1518">	BRegion background;</a>
<a name="ln1519">	_RebuildClippingForAllWindows(background);</a>
<a name="ln1520"> </a>
<a name="ln1521">	// we just care for the region outside the window</a>
<a name="ln1522">	previouslyOccupiedRegion.Exclude(&amp;window-&gt;VisibleRegion());</a>
<a name="ln1523"> </a>
<a name="ln1524">	// make sure the window cannot mark stuff dirty outside</a>
<a name="ln1525">	// its visible region...</a>
<a name="ln1526">	newDirtyRegion.IntersectWith(&amp;window-&gt;VisibleRegion());</a>
<a name="ln1527">	// ...because we do this outself</a>
<a name="ln1528">	newDirtyRegion.Include(&amp;previouslyOccupiedRegion);</a>
<a name="ln1529"> </a>
<a name="ln1530">	MarkDirty(newDirtyRegion);</a>
<a name="ln1531">	_SetBackground(background);</a>
<a name="ln1532">	_WindowChanged(window);</a>
<a name="ln1533"> </a>
<a name="ln1534">	// resume direct frame buffer access</a>
<a name="ln1535">	if (direct) {</a>
<a name="ln1536">		window-&gt;ServerWindow()-&gt;HandleDirectConnection(</a>
<a name="ln1537">			B_DIRECT_START | B_BUFFER_RESIZED | B_CLIPPING_MODIFIED);</a>
<a name="ln1538">	}</a>
<a name="ln1539"> </a>
<a name="ln1540">	NotifyWindowResized(window);</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543"> </a>
<a name="ln1544">bool</a>
<a name="ln1545">Desktop::SetWindowTabLocation(Window* window, float location, bool isShifting)</a>
<a name="ln1546">{</a>
<a name="ln1547">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1548"> </a>
<a name="ln1549">	BRegion dirty;</a>
<a name="ln1550">	bool changed = window-&gt;SetTabLocation(location, isShifting, dirty);</a>
<a name="ln1551">	if (changed)</a>
<a name="ln1552">		RebuildAndRedrawAfterWindowChange(window, dirty);</a>
<a name="ln1553"> </a>
<a name="ln1554">	NotifyWindowTabLocationChanged(window, location, isShifting);</a>
<a name="ln1555"> </a>
<a name="ln1556">	return changed;</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559"> </a>
<a name="ln1560">bool</a>
<a name="ln1561">Desktop::SetWindowDecoratorSettings(Window* window, const BMessage&amp; settings)</a>
<a name="ln1562">{</a>
<a name="ln1563">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1564"> </a>
<a name="ln1565">	BRegion dirty;</a>
<a name="ln1566">	bool changed = window-&gt;SetDecoratorSettings(settings, dirty);</a>
<a name="ln1567">	bool listenerChanged = SetDecoratorSettings(window, settings);</a>
<a name="ln1568">	if (changed || listenerChanged)</a>
<a name="ln1569">		RebuildAndRedrawAfterWindowChange(window, dirty);</a>
<a name="ln1570"> </a>
<a name="ln1571">	return changed;</a>
<a name="ln1572">}</a>
<a name="ln1573"> </a>
<a name="ln1574"> </a>
<a name="ln1575">void</a>
<a name="ln1576">Desktop::SetWindowWorkspaces(Window* window, uint32 workspaces)</a>
<a name="ln1577">{</a>
<a name="ln1578">	LockAllWindows();</a>
<a name="ln1579"> </a>
<a name="ln1580">	if (window-&gt;IsNormal() &amp;&amp; workspaces == B_CURRENT_WORKSPACE)</a>
<a name="ln1581">		workspaces = workspace_to_workspaces(CurrentWorkspace());</a>
<a name="ln1582"> </a>
<a name="ln1583">	WindowStack* stack = window-&gt;GetWindowStack();</a>
<a name="ln1584">	if (stack != NULL) {</a>
<a name="ln1585">		for (int32 s = 0; s &lt; stack-&gt;CountWindows(); s++) {</a>
<a name="ln1586">			window = stack-&gt;LayerOrder().ItemAt(s);</a>
<a name="ln1587"> </a>
<a name="ln1588">			uint32 oldWorkspaces = window-&gt;Workspaces();</a>
<a name="ln1589">			window-&gt;WorkspacesChanged(oldWorkspaces, workspaces);</a>
<a name="ln1590">			_ChangeWindowWorkspaces(window, oldWorkspaces, workspaces);</a>
<a name="ln1591">		}</a>
<a name="ln1592">	}</a>
<a name="ln1593">	UnlockAllWindows();</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596"> </a>
<a name="ln1597">/*!	\brief Adds the window to the desktop.</a>
<a name="ln1598">	At this point, the window is still hidden and must be shown explicitly</a>
<a name="ln1599">	via ShowWindow().</a>
<a name="ln1600">*/</a>
<a name="ln1601">void</a>
<a name="ln1602">Desktop::AddWindow(Window *window)</a>
<a name="ln1603">{</a>
<a name="ln1604">	LockAllWindows();</a>
<a name="ln1605"> </a>
<a name="ln1606">	fAllWindows.AddWindow(window);</a>
<a name="ln1607">	if (!window-&gt;IsNormal())</a>
<a name="ln1608">		fSubsetWindows.AddWindow(window);</a>
<a name="ln1609"> </a>
<a name="ln1610">	if (window-&gt;IsNormal()) {</a>
<a name="ln1611">		if (window-&gt;Workspaces() == B_CURRENT_WORKSPACE)</a>
<a name="ln1612">			window-&gt;SetWorkspaces(workspace_to_workspaces(CurrentWorkspace()));</a>
<a name="ln1613">	} else {</a>
<a name="ln1614">		// subset windows are visible on all workspaces their subset is on</a>
<a name="ln1615">		window-&gt;SetWorkspaces(window-&gt;SubsetWorkspaces());</a>
<a name="ln1616">	}</a>
<a name="ln1617"> </a>
<a name="ln1618">	_ChangeWindowWorkspaces(window, 0, window-&gt;Workspaces());</a>
<a name="ln1619"> </a>
<a name="ln1620">	NotifyWindowAdded(window);</a>
<a name="ln1621"> </a>
<a name="ln1622">	UnlockAllWindows();</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625"> </a>
<a name="ln1626">void</a>
<a name="ln1627">Desktop::RemoveWindow(Window *window)</a>
<a name="ln1628">{</a>
<a name="ln1629">	LockAllWindows();</a>
<a name="ln1630"> </a>
<a name="ln1631">	if (!window-&gt;IsHidden())</a>
<a name="ln1632">		HideWindow(window);</a>
<a name="ln1633"> </a>
<a name="ln1634">	fAllWindows.RemoveWindow(window);</a>
<a name="ln1635">	if (!window-&gt;IsNormal())</a>
<a name="ln1636">		fSubsetWindows.RemoveWindow(window);</a>
<a name="ln1637"> </a>
<a name="ln1638">	_ChangeWindowWorkspaces(window, window-&gt;Workspaces(), 0);</a>
<a name="ln1639"> </a>
<a name="ln1640">	NotifyWindowRemoved(window);</a>
<a name="ln1641"> </a>
<a name="ln1642">	UnlockAllWindows();</a>
<a name="ln1643"> </a>
<a name="ln1644">	// make sure this window won't get any events anymore</a>
<a name="ln1645"> </a>
<a name="ln1646">	EventDispatcher().RemoveTarget(window-&gt;EventTarget());</a>
<a name="ln1647">}</a>
<a name="ln1648"> </a>
<a name="ln1649"> </a>
<a name="ln1650">bool</a>
<a name="ln1651">Desktop::AddWindowToSubset(Window* subset, Window* window)</a>
<a name="ln1652">{</a>
<a name="ln1653">	if (!subset-&gt;AddToSubset(window))</a>
<a name="ln1654">		return false;</a>
<a name="ln1655"> </a>
<a name="ln1656">	_ChangeWindowWorkspaces(subset, subset-&gt;Workspaces(),</a>
<a name="ln1657">		subset-&gt;SubsetWorkspaces());</a>
<a name="ln1658">	return true;</a>
<a name="ln1659">}</a>
<a name="ln1660"> </a>
<a name="ln1661"> </a>
<a name="ln1662">void</a>
<a name="ln1663">Desktop::RemoveWindowFromSubset(Window* subset, Window* window)</a>
<a name="ln1664">{</a>
<a name="ln1665">	subset-&gt;RemoveFromSubset(window);</a>
<a name="ln1666">	_ChangeWindowWorkspaces(subset, subset-&gt;Workspaces(),</a>
<a name="ln1667">		subset-&gt;SubsetWorkspaces());</a>
<a name="ln1668">}</a>
<a name="ln1669"> </a>
<a name="ln1670"> </a>
<a name="ln1671">void</a>
<a name="ln1672">Desktop::FontsChanged(Window* window)</a>
<a name="ln1673">{</a>
<a name="ln1674">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1675"> </a>
<a name="ln1676">	BRegion dirty;</a>
<a name="ln1677">	window-&gt;FontsChanged(&amp;dirty);</a>
<a name="ln1678"> </a>
<a name="ln1679">	RebuildAndRedrawAfterWindowChange(window, dirty);</a>
<a name="ln1680">}</a>
<a name="ln1681"> </a>
<a name="ln1682"> </a>
<a name="ln1683">void</a>
<a name="ln1684">Desktop::ColorUpdated(Window* window, color_which which, rgb_color color)</a>
<a name="ln1685">{</a>
<a name="ln1686">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1687"> </a>
<a name="ln1688">	window-&gt;TopView()-&gt;ColorUpdated(which, color);</a>
<a name="ln1689"> </a>
<a name="ln1690">	switch (which) {</a>
<a name="ln1691">		case B_WINDOW_TAB_COLOR:</a>
<a name="ln1692">		case B_WINDOW_TEXT_COLOR:</a>
<a name="ln1693">		case B_WINDOW_INACTIVE_TAB_COLOR:</a>
<a name="ln1694">		case B_WINDOW_INACTIVE_TEXT_COLOR:</a>
<a name="ln1695">		case B_WINDOW_BORDER_COLOR:</a>
<a name="ln1696">		case B_WINDOW_INACTIVE_BORDER_COLOR:</a>
<a name="ln1697">			break;</a>
<a name="ln1698">		default:</a>
<a name="ln1699">			return;</a>
<a name="ln1700">	}</a>
<a name="ln1701"> </a>
<a name="ln1702">	BRegion dirty;</a>
<a name="ln1703">	window-&gt;ColorsChanged(&amp;dirty);</a>
<a name="ln1704">	RebuildAndRedrawAfterWindowChange(window, dirty);</a>
<a name="ln1705">}</a>
<a name="ln1706"> </a>
<a name="ln1707"> </a>
<a name="ln1708">void</a>
<a name="ln1709">Desktop::SetWindowLook(Window* window, window_look newLook)</a>
<a name="ln1710">{</a>
<a name="ln1711">	if (window-&gt;Look() == newLook)</a>
<a name="ln1712">		return;</a>
<a name="ln1713"> </a>
<a name="ln1714">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1715"> </a>
<a name="ln1716">	BRegion dirty;</a>
<a name="ln1717">	window-&gt;SetLook(newLook, &amp;dirty);</a>
<a name="ln1718">		// TODO: test what happens when the window</a>
<a name="ln1719">		// finds out it needs to resize itself...</a>
<a name="ln1720"> </a>
<a name="ln1721">	RebuildAndRedrawAfterWindowChange(window, dirty);</a>
<a name="ln1722"> </a>
<a name="ln1723">	NotifyWindowLookChanged(window, newLook);</a>
<a name="ln1724">}</a>
<a name="ln1725"> </a>
<a name="ln1726"> </a>
<a name="ln1727">void</a>
<a name="ln1728">Desktop::SetWindowFeel(Window* window, window_feel newFeel)</a>
<a name="ln1729">{</a>
<a name="ln1730">	if (window-&gt;Feel() == newFeel)</a>
<a name="ln1731">		return;</a>
<a name="ln1732"> </a>
<a name="ln1733">	LockAllWindows();</a>
<a name="ln1734"> </a>
<a name="ln1735">	bool wasNormal = window-&gt;IsNormal();</a>
<a name="ln1736"> </a>
<a name="ln1737">	window-&gt;SetFeel(newFeel);</a>
<a name="ln1738"> </a>
<a name="ln1739">	// move the window out of or into the subset window list as needed</a>
<a name="ln1740">	if (window-&gt;IsNormal() &amp;&amp; !wasNormal)</a>
<a name="ln1741">		fSubsetWindows.RemoveWindow(window);</a>
<a name="ln1742">	else if (!window-&gt;IsNormal() &amp;&amp; wasNormal)</a>
<a name="ln1743">		fSubsetWindows.AddWindow(window);</a>
<a name="ln1744"> </a>
<a name="ln1745">	// A normal window that was once a floating or modal window will</a>
<a name="ln1746">	// adopt the window's current workspaces</a>
<a name="ln1747"> </a>
<a name="ln1748">	if (!window-&gt;IsNormal()) {</a>
<a name="ln1749">		_ChangeWindowWorkspaces(window, window-&gt;Workspaces(),</a>
<a name="ln1750">			window-&gt;SubsetWorkspaces());</a>
<a name="ln1751">	}</a>
<a name="ln1752"> </a>
<a name="ln1753">	// make sure the window has the correct position in the window lists</a>
<a name="ln1754">	// (ie. all floating windows have to be on the top, ...)</a>
<a name="ln1755"> </a>
<a name="ln1756">	for (int32 i = 0; i &lt; kMaxWorkspaces; i++) {</a>
<a name="ln1757">		if (!workspace_in_workspaces(i, window-&gt;Workspaces()))</a>
<a name="ln1758">			continue;</a>
<a name="ln1759"> </a>
<a name="ln1760">		bool changed = false;</a>
<a name="ln1761">		BRegion visibleBefore;</a>
<a name="ln1762">		if (i == fCurrentWorkspace &amp;&amp; window-&gt;IsVisible())</a>
<a name="ln1763">			visibleBefore = window-&gt;VisibleRegion();</a>
<a name="ln1764"> </a>
<a name="ln1765">		Window* backmost = window-&gt;Backmost(_Windows(i).LastWindow(), i);</a>
<a name="ln1766">		if (backmost != NULL) {</a>
<a name="ln1767">			// check if the backmost window is really behind it</a>
<a name="ln1768">			Window* previous = window-&gt;PreviousWindow(i);</a>
<a name="ln1769">			while (previous != NULL) {</a>
<a name="ln1770">				if (previous == backmost)</a>
<a name="ln1771">					break;</a>
<a name="ln1772"> </a>
<a name="ln1773">				previous = previous-&gt;PreviousWindow(i);</a>
<a name="ln1774">			}</a>
<a name="ln1775"> </a>
<a name="ln1776">			if (previous == NULL) {</a>
<a name="ln1777">				// need to reinsert window before its backmost window</a>
<a name="ln1778">				_Windows(i).RemoveWindow(window);</a>
<a name="ln1779">				_Windows(i).AddWindow(window, backmost-&gt;NextWindow(i));</a>
<a name="ln1780">				changed = true;</a>
<a name="ln1781">			}</a>
<a name="ln1782">		}</a>
<a name="ln1783"> </a>
<a name="ln1784">		Window* frontmost = window-&gt;Frontmost(_Windows(i).FirstWindow(), i);</a>
<a name="ln1785">		if (frontmost != NULL) {</a>
<a name="ln1786">			// check if the frontmost window is really in front of it</a>
<a name="ln1787">			Window* next = window-&gt;NextWindow(i);</a>
<a name="ln1788">			while (next != NULL) {</a>
<a name="ln1789">				if (next == frontmost)</a>
<a name="ln1790">					break;</a>
<a name="ln1791"> </a>
<a name="ln1792">				next = next-&gt;NextWindow(i);</a>
<a name="ln1793">			}</a>
<a name="ln1794"> </a>
<a name="ln1795">			if (next == NULL) {</a>
<a name="ln1796">				// need to reinsert window behind its frontmost window</a>
<a name="ln1797">				_Windows(i).RemoveWindow(window);</a>
<a name="ln1798">				_Windows(i).AddWindow(window, frontmost);</a>
<a name="ln1799">				changed = true;</a>
<a name="ln1800">			}</a>
<a name="ln1801">		}</a>
<a name="ln1802"> </a>
<a name="ln1803">		if (i == fCurrentWorkspace &amp;&amp; changed) {</a>
<a name="ln1804">			BRegion dummy;</a>
<a name="ln1805">			_RebuildClippingForAllWindows(dummy);</a>
<a name="ln1806"> </a>
<a name="ln1807">			// mark everything dirty that is no longer visible, or</a>
<a name="ln1808">			// is now visible and wasn't before</a>
<a name="ln1809">			BRegion visibleAfter(window-&gt;VisibleRegion());</a>
<a name="ln1810">			BRegion dirty(visibleAfter);</a>
<a name="ln1811">			dirty.Exclude(&amp;visibleBefore);</a>
<a name="ln1812">			visibleBefore.Exclude(&amp;visibleAfter);</a>
<a name="ln1813">			dirty.Include(&amp;visibleBefore);</a>
<a name="ln1814"> </a>
<a name="ln1815">			MarkDirty(dirty);</a>
<a name="ln1816">		}</a>
<a name="ln1817">	}</a>
<a name="ln1818"> </a>
<a name="ln1819">	_UpdateFronts();</a>
<a name="ln1820"> </a>
<a name="ln1821">	if (window == FocusWindow() &amp;&amp; !window-&gt;IsVisible())</a>
<a name="ln1822">		SetFocusWindow();</a>
<a name="ln1823"> </a>
<a name="ln1824">	NotifyWindowFeelChanged(window, newFeel);</a>
<a name="ln1825"> </a>
<a name="ln1826">	UnlockAllWindows();</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829"> </a>
<a name="ln1830">void</a>
<a name="ln1831">Desktop::SetWindowFlags(Window *window, uint32 newFlags)</a>
<a name="ln1832">{</a>
<a name="ln1833">	if (window-&gt;Flags() == newFlags)</a>
<a name="ln1834">		return;</a>
<a name="ln1835"> </a>
<a name="ln1836">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1837"> </a>
<a name="ln1838">	BRegion dirty;</a>
<a name="ln1839">	window-&gt;SetFlags(newFlags, &amp;dirty);</a>
<a name="ln1840">		// TODO: test what happens when the window</a>
<a name="ln1841">		// finds out it needs to resize itself...</a>
<a name="ln1842"> </a>
<a name="ln1843">	RebuildAndRedrawAfterWindowChange(window, dirty);</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846"> </a>
<a name="ln1847">void</a>
<a name="ln1848">Desktop::SetWindowTitle(Window *window, const char* title)</a>
<a name="ln1849">{</a>
<a name="ln1850">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln1851"> </a>
<a name="ln1852">	BRegion dirty;</a>
<a name="ln1853">	window-&gt;SetTitle(title, dirty);</a>
<a name="ln1854"> </a>
<a name="ln1855">	RebuildAndRedrawAfterWindowChange(window, dirty);</a>
<a name="ln1856">}</a>
<a name="ln1857"> </a>
<a name="ln1858"> </a>
<a name="ln1859">/*!	Returns the window under the mouse cursor.</a>
<a name="ln1860">	You need to have acquired the All Windows lock when calling this method.</a>
<a name="ln1861">*/</a>
<a name="ln1862">Window*</a>
<a name="ln1863">Desktop::WindowAt(BPoint where)</a>
<a name="ln1864">{</a>
<a name="ln1865">	for (Window* window = CurrentWindows().LastWindow(); window;</a>
<a name="ln1866">			window = window-&gt;PreviousWindow(fCurrentWorkspace)) {</a>
<a name="ln1867">		if (window-&gt;IsVisible() &amp;&amp; window-&gt;VisibleRegion().Contains(where))</a>
<a name="ln1868">			return window-&gt;StackedWindowAt(where);</a>
<a name="ln1869">	}</a>
<a name="ln1870"> </a>
<a name="ln1871">	return NULL;</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874"> </a>
<a name="ln1875">void</a>
<a name="ln1876">Desktop::SetMouseEventWindow(Window* window)</a>
<a name="ln1877">{</a>
<a name="ln1878">	fMouseEventWindow = window;</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881"> </a>
<a name="ln1882">void</a>
<a name="ln1883">Desktop::SetViewUnderMouse(const Window* window, int32 viewToken)</a>
<a name="ln1884">{</a>
<a name="ln1885">	fWindowUnderMouse = window;</a>
<a name="ln1886">	fViewUnderMouse = viewToken;</a>
<a name="ln1887">}</a>
<a name="ln1888"> </a>
<a name="ln1889"> </a>
<a name="ln1890">int32</a>
<a name="ln1891">Desktop::ViewUnderMouse(const Window* window)</a>
<a name="ln1892">{</a>
<a name="ln1893">	if (window != NULL &amp;&amp; fWindowUnderMouse == window)</a>
<a name="ln1894">		return fViewUnderMouse;</a>
<a name="ln1895"> </a>
<a name="ln1896">	return B_NULL_TOKEN;</a>
<a name="ln1897">}</a>
<a name="ln1898"> </a>
<a name="ln1899"> </a>
<a name="ln1900">/*!	Returns the current keyboard event target candidate - which is either the</a>
<a name="ln1901">	top-most window (in case it has the kAcceptKeyboardFocusFlag flag set), or</a>
<a name="ln1902">	the one having focus.</a>
<a name="ln1903">	The window lock must be held when calling this function.</a>
<a name="ln1904">*/</a>
<a name="ln1905">EventTarget*</a>
<a name="ln1906">Desktop::KeyboardEventTarget()</a>
<a name="ln1907">{</a>
<a name="ln1908">	// Get the top most non-hidden window</a>
<a name="ln1909">	Window* window = CurrentWindows().LastWindow();</a>
<a name="ln1910">	while (window != NULL &amp;&amp; window-&gt;IsHidden()) {</a>
<a name="ln1911">		window = window-&gt;PreviousWindow(fCurrentWorkspace);</a>
<a name="ln1912">	}</a>
<a name="ln1913"> </a>
<a name="ln1914">	if (window != NULL &amp;&amp; (window-&gt;Flags() &amp; kAcceptKeyboardFocusFlag) != 0)</a>
<a name="ln1915">		return &amp;window-&gt;EventTarget();</a>
<a name="ln1916"> </a>
<a name="ln1917">	if (FocusWindow() != NULL)</a>
<a name="ln1918">		return &amp;FocusWindow()-&gt;EventTarget();</a>
<a name="ln1919"> </a>
<a name="ln1920">	return NULL;</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923"> </a>
<a name="ln1924">/*!	Tries to set the focus to the specified \a focus window. It will make sure,</a>
<a name="ln1925">	however, that the window actually can have focus. You are allowed to pass</a>
<a name="ln1926">	in a NULL pointer for \a focus.</a>
<a name="ln1927"> </a>
<a name="ln1928">	Besides the B_AVOID_FOCUS flag, a modal window, or a BWindowScreen can both</a>
<a name="ln1929">	prevent it from getting focus.</a>
<a name="ln1930"> </a>
<a name="ln1931">	In any case, this method makes sure that there is a focus window, if there</a>
<a name="ln1932">	is any window at all, that is.</a>
<a name="ln1933">*/</a>
<a name="ln1934">void</a>
<a name="ln1935">Desktop::SetFocusWindow(Window* nextFocus)</a>
<a name="ln1936">{</a>
<a name="ln1937">	if (!LockAllWindows())</a>
<a name="ln1938">		return;</a>
<a name="ln1939"> </a>
<a name="ln1940">	// test for B_LOCK_WINDOW_FOCUS</a>
<a name="ln1941">	if (fLockedFocusWindow &amp;&amp; nextFocus != fLockedFocusWindow) {</a>
<a name="ln1942">		UnlockAllWindows();</a>
<a name="ln1943">		return;</a>
<a name="ln1944">	}</a>
<a name="ln1945"> </a>
<a name="ln1946">	bool hasModal = _WindowHasModal(nextFocus);</a>
<a name="ln1947">	bool hasWindowScreen = false;</a>
<a name="ln1948"> </a>
<a name="ln1949">	if (!hasModal &amp;&amp; nextFocus != NULL) {</a>
<a name="ln1950">		// Check whether or not a window screen is in front of the window</a>
<a name="ln1951">		// (if it has a modal, the right thing is done, anyway)</a>
<a name="ln1952">		Window* window = nextFocus;</a>
<a name="ln1953">		while (true) {</a>
<a name="ln1954">			window = window-&gt;NextWindow(fCurrentWorkspace);</a>
<a name="ln1955">			if (window == NULL || window-&gt;Feel() == kWindowScreenFeel)</a>
<a name="ln1956">				break;</a>
<a name="ln1957">		}</a>
<a name="ln1958">		if (window != NULL)</a>
<a name="ln1959">			hasWindowScreen = true;</a>
<a name="ln1960">	}</a>
<a name="ln1961"> </a>
<a name="ln1962">	if (nextFocus == fFocus &amp;&amp; nextFocus != NULL &amp;&amp; !nextFocus-&gt;IsHidden()</a>
<a name="ln1963">		&amp;&amp; (nextFocus-&gt;Flags() &amp; B_AVOID_FOCUS) == 0</a>
<a name="ln1964">		&amp;&amp; !hasModal &amp;&amp; !hasWindowScreen) {</a>
<a name="ln1965">		// the window that is supposed to get focus already has focus</a>
<a name="ln1966">		UnlockAllWindows();</a>
<a name="ln1967">		return;</a>
<a name="ln1968">	}</a>
<a name="ln1969"> </a>
<a name="ln1970">	uint32 listIndex = fCurrentWorkspace;</a>
<a name="ln1971">	WindowList* list = &amp;_Windows(fCurrentWorkspace);</a>
<a name="ln1972">	if (!fSettings-&gt;NormalMouse()) {</a>
<a name="ln1973">		listIndex = kFocusList;</a>
<a name="ln1974">		list = &amp;fFocusList;</a>
<a name="ln1975">	}</a>
<a name="ln1976"> </a>
<a name="ln1977">	if (nextFocus == NULL || hasModal || hasWindowScreen) {</a>
<a name="ln1978">		nextFocus = list-&gt;LastWindow();</a>
<a name="ln1979"> </a>
<a name="ln1980">		if (fSettings-&gt;NormalMouse()) {</a>
<a name="ln1981">			// If the last window having focus is a window that cannot make it</a>
<a name="ln1982">			// to the front, we use that as the next focus</a>
<a name="ln1983">			Window* lastFocus = fFocusList.LastWindow();</a>
<a name="ln1984">			if (lastFocus != NULL &amp;&amp; !lastFocus-&gt;SupportsFront()</a>
<a name="ln1985">				&amp;&amp; _WindowCanHaveFocus(lastFocus)) {</a>
<a name="ln1986">				nextFocus = lastFocus;</a>
<a name="ln1987">			}</a>
<a name="ln1988">		}</a>
<a name="ln1989">	}</a>
<a name="ln1990"> </a>
<a name="ln1991">	// make sure no window is chosen that doesn't want focus or cannot have it</a>
<a name="ln1992">	while (nextFocus != NULL &amp;&amp; !_WindowCanHaveFocus(nextFocus)) {</a>
<a name="ln1993">		nextFocus = nextFocus-&gt;PreviousWindow(listIndex);</a>
<a name="ln1994">	}</a>
<a name="ln1995"> </a>
<a name="ln1996">	if (fFocus == nextFocus) {</a>
<a name="ln1997">		// turns out the window that is supposed to get focus now already has it</a>
<a name="ln1998">		UnlockAllWindows();</a>
<a name="ln1999">		return;</a>
<a name="ln2000">	}</a>
<a name="ln2001"> </a>
<a name="ln2002">	team_id oldActiveApp = -1;</a>
<a name="ln2003">	team_id newActiveApp = -1;</a>
<a name="ln2004"> </a>
<a name="ln2005">	if (fFocus != NULL) {</a>
<a name="ln2006">		fFocus-&gt;SetFocus(false);</a>
<a name="ln2007">		oldActiveApp = fFocus-&gt;ServerWindow()-&gt;App()-&gt;ClientTeam();</a>
<a name="ln2008">	}</a>
<a name="ln2009"> </a>
<a name="ln2010">	fFocus = nextFocus;</a>
<a name="ln2011"> </a>
<a name="ln2012">	if (fFocus != NULL) {</a>
<a name="ln2013">		fFocus-&gt;SetFocus(true);</a>
<a name="ln2014">		newActiveApp = fFocus-&gt;ServerWindow()-&gt;App()-&gt;ClientTeam();</a>
<a name="ln2015"> </a>
<a name="ln2016">		// move current focus to the end of the focus list</a>
<a name="ln2017">		fFocusList.RemoveWindow(fFocus);</a>
<a name="ln2018">		fFocusList.AddWindow(fFocus);</a>
<a name="ln2019">	}</a>
<a name="ln2020"> </a>
<a name="ln2021">	if (newActiveApp == -1) {</a>
<a name="ln2022">		// make sure the cursor is visible</a>
<a name="ln2023">		HWInterface()-&gt;SetCursorVisible(true);</a>
<a name="ln2024">	}</a>
<a name="ln2025"> </a>
<a name="ln2026">	UnlockAllWindows();</a>
<a name="ln2027"> </a>
<a name="ln2028">	// change the &quot;active&quot; app if appropriate</a>
<a name="ln2029">	if (oldActiveApp == newActiveApp)</a>
<a name="ln2030">		return;</a>
<a name="ln2031"> </a>
<a name="ln2032">	BAutolock locker(fApplicationsLock);</a>
<a name="ln2033"> </a>
<a name="ln2034">	for (int32 i = 0; i &lt; fApplications.CountItems(); i++) {</a>
<a name="ln2035">		ServerApp* app = fApplications.ItemAt(i);</a>
<a name="ln2036"> </a>
<a name="ln2037">		if (oldActiveApp != -1 &amp;&amp; app-&gt;ClientTeam() == oldActiveApp)</a>
<a name="ln2038">			app-&gt;Activate(false);</a>
<a name="ln2039">		else if (newActiveApp != -1 &amp;&amp; app-&gt;ClientTeam() == newActiveApp)</a>
<a name="ln2040">			app-&gt;Activate(true);</a>
<a name="ln2041">	}</a>
<a name="ln2042">}</a>
<a name="ln2043"> </a>
<a name="ln2044"> </a>
<a name="ln2045">void</a>
<a name="ln2046">Desktop::SetFocusLocked(const Window* window)</a>
<a name="ln2047">{</a>
<a name="ln2048">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln2049"> </a>
<a name="ln2050">	if (window != NULL) {</a>
<a name="ln2051">		// Don't allow this to be set when no mouse buttons</a>
<a name="ln2052">		// are pressed. (BView::SetMouseEventMask() should only be called</a>
<a name="ln2053">		// from mouse hooks.)</a>
<a name="ln2054">		if (fLastMouseButtons == 0)</a>
<a name="ln2055">			return;</a>
<a name="ln2056">	}</a>
<a name="ln2057"> </a>
<a name="ln2058">	fLockedFocusWindow = window;</a>
<a name="ln2059">}</a>
<a name="ln2060"> </a>
<a name="ln2061"> </a>
<a name="ln2062">Window*</a>
<a name="ln2063">Desktop::FindWindowByClientToken(int32 token, team_id teamID)</a>
<a name="ln2064">{</a>
<a name="ln2065">	for (Window *window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2066">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2067">		if (window-&gt;ServerWindow()-&gt;ClientToken() == token</a>
<a name="ln2068">			&amp;&amp; window-&gt;ServerWindow()-&gt;ClientTeam() == teamID) {</a>
<a name="ln2069">			return window;</a>
<a name="ln2070">		}</a>
<a name="ln2071">	}</a>
<a name="ln2072"> </a>
<a name="ln2073">	return NULL;</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076"> </a>
<a name="ln2077">::EventTarget*</a>
<a name="ln2078">Desktop::FindTarget(BMessenger&amp; messenger)</a>
<a name="ln2079">{</a>
<a name="ln2080">	for (Window *window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2081">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2082">		if (window-&gt;EventTarget().Messenger() == messenger)</a>
<a name="ln2083">			return &amp;window-&gt;EventTarget();</a>
<a name="ln2084">	}</a>
<a name="ln2085"> </a>
<a name="ln2086">	return NULL;</a>
<a name="ln2087">}</a>
<a name="ln2088"> </a>
<a name="ln2089"> </a>
<a name="ln2090">void</a>
<a name="ln2091">Desktop::MarkDirty(BRegion&amp; region)</a>
<a name="ln2092">{</a>
<a name="ln2093">	if (region.CountRects() == 0)</a>
<a name="ln2094">		return;</a>
<a name="ln2095"> </a>
<a name="ln2096">	if (LockAllWindows()) {</a>
<a name="ln2097">		// send redraw messages to all windows intersecting the dirty region</a>
<a name="ln2098">		_TriggerWindowRedrawing(region);</a>
<a name="ln2099"> </a>
<a name="ln2100">		UnlockAllWindows();</a>
<a name="ln2101">	}</a>
<a name="ln2102">}</a>
<a name="ln2103"> </a>
<a name="ln2104"> </a>
<a name="ln2105">void</a>
<a name="ln2106">Desktop::Redraw()</a>
<a name="ln2107">{</a>
<a name="ln2108">	BRegion dirty(fVirtualScreen.Frame());</a>
<a name="ln2109">	MarkDirty(dirty);</a>
<a name="ln2110">}</a>
<a name="ln2111"> </a>
<a name="ln2112"> </a>
<a name="ln2113">/*!	\brief Redraws the background (ie. the desktop window, if any).</a>
<a name="ln2114">*/</a>
<a name="ln2115">void</a>
<a name="ln2116">Desktop::RedrawBackground()</a>
<a name="ln2117">{</a>
<a name="ln2118">	LockAllWindows();</a>
<a name="ln2119"> </a>
<a name="ln2120">	BRegion redraw;</a>
<a name="ln2121"> </a>
<a name="ln2122">	Window* window = CurrentWindows().FirstWindow();</a>
<a name="ln2123">	if (window != NULL &amp;&amp; window-&gt;Feel() == kDesktopWindowFeel) {</a>
<a name="ln2124">		redraw = window-&gt;VisibleContentRegion();</a>
<a name="ln2125"> </a>
<a name="ln2126">		// look for desktop background view, and update its background color</a>
<a name="ln2127">		// TODO: is there a better way to do this?</a>
<a name="ln2128">		View* view = window-&gt;TopView();</a>
<a name="ln2129">		if (view != NULL)</a>
<a name="ln2130">			view = view-&gt;FirstChild();</a>
<a name="ln2131"> </a>
<a name="ln2132">		while (view != NULL) {</a>
<a name="ln2133">			if (view-&gt;IsDesktopBackground()) {</a>
<a name="ln2134">				view-&gt;SetViewColor(fWorkspaces[fCurrentWorkspace].Color());</a>
<a name="ln2135">				break;</a>
<a name="ln2136">			}</a>
<a name="ln2137">			view = view-&gt;NextSibling();</a>
<a name="ln2138">		}</a>
<a name="ln2139"> </a>
<a name="ln2140">		window-&gt;ProcessDirtyRegion(redraw);</a>
<a name="ln2141">	} else {</a>
<a name="ln2142">		redraw = BackgroundRegion();</a>
<a name="ln2143">		fBackgroundRegion.MakeEmpty();</a>
<a name="ln2144">		_SetBackground(redraw);</a>
<a name="ln2145">	}</a>
<a name="ln2146"> </a>
<a name="ln2147">	_WindowChanged(NULL);</a>
<a name="ln2148">		// update workspaces view as well</a>
<a name="ln2149"> </a>
<a name="ln2150">	UnlockAllWindows();</a>
<a name="ln2151">}</a>
<a name="ln2152"> </a>
<a name="ln2153"> </a>
<a name="ln2154">bool</a>
<a name="ln2155">Desktop::ReloadDecor(DecorAddOn* oldDecor)</a>
<a name="ln2156">{</a>
<a name="ln2157">	AutoWriteLocker _(fWindowLock);</a>
<a name="ln2158"> </a>
<a name="ln2159">	bool returnValue = true;</a>
<a name="ln2160"> </a>
<a name="ln2161">	if (oldDecor != NULL) {</a>
<a name="ln2162">		const DesktopListenerList* oldListeners</a>
<a name="ln2163">			= &amp;oldDecor-&gt;GetDesktopListeners();</a>
<a name="ln2164">		for (int i = 0; i &lt; oldListeners-&gt;CountItems(); i++)</a>
<a name="ln2165">			UnregisterListener(oldListeners-&gt;ItemAt(i));</a>
<a name="ln2166">	}</a>
<a name="ln2167"> </a>
<a name="ln2168">	for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2169">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2170">		BRegion oldBorder;</a>
<a name="ln2171">		window-&gt;GetBorderRegion(&amp;oldBorder);</a>
<a name="ln2172"> </a>
<a name="ln2173">		if (!window-&gt;ReloadDecor()) {</a>
<a name="ln2174">			// prevent unloading previous add-on</a>
<a name="ln2175">			returnValue = false;</a>
<a name="ln2176">		}</a>
<a name="ln2177"> </a>
<a name="ln2178">		BRegion border;</a>
<a name="ln2179">		window-&gt;GetBorderRegion(&amp;border);</a>
<a name="ln2180"> </a>
<a name="ln2181">		border.Include(&amp;oldBorder);</a>
<a name="ln2182">		RebuildAndRedrawAfterWindowChange(window, border);</a>
<a name="ln2183">	}</a>
<a name="ln2184"> </a>
<a name="ln2185">	// register new listeners</a>
<a name="ln2186">	const DesktopListenerList&amp; newListeners</a>
<a name="ln2187">		= gDecorManager.GetDesktopListeners();</a>
<a name="ln2188">	for (int i = 0; i &lt; newListeners.CountItems(); i++)</a>
<a name="ln2189"> 		RegisterListener(newListeners.ItemAt(i));</a>
<a name="ln2190"> </a>
<a name="ln2191"> 	return returnValue;</a>
<a name="ln2192">}</a>
<a name="ln2193"> </a>
<a name="ln2194"> </a>
<a name="ln2195">void</a>
<a name="ln2196">Desktop::MinimizeApplication(team_id team)</a>
<a name="ln2197">{</a>
<a name="ln2198">	AutoWriteLocker locker(fWindowLock);</a>
<a name="ln2199"> </a>
<a name="ln2200">	// Just minimize all windows of that application</a>
<a name="ln2201"> </a>
<a name="ln2202">	for (Window *window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2203">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2204">		if (window-&gt;ServerWindow()-&gt;ClientTeam() != team)</a>
<a name="ln2205">			continue;</a>
<a name="ln2206"> </a>
<a name="ln2207">		window-&gt;ServerWindow()-&gt;NotifyMinimize(true);</a>
<a name="ln2208">	}</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211"> </a>
<a name="ln2212">void</a>
<a name="ln2213">Desktop::BringApplicationToFront(team_id team)</a>
<a name="ln2214">{</a>
<a name="ln2215">	AutoWriteLocker locker(fWindowLock);</a>
<a name="ln2216"> </a>
<a name="ln2217">	// TODO: for now, just maximize all windows of that application</a>
<a name="ln2218">	// TODO: have the ability to lock the current workspace</a>
<a name="ln2219"> </a>
<a name="ln2220">	for (Window *window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2221">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2222">		if (window-&gt;ServerWindow()-&gt;ClientTeam() != team)</a>
<a name="ln2223">			continue;</a>
<a name="ln2224"> </a>
<a name="ln2225">		window-&gt;ServerWindow()-&gt;NotifyMinimize(false);</a>
<a name="ln2226">	}</a>
<a name="ln2227">}</a>
<a name="ln2228"> </a>
<a name="ln2229"> </a>
<a name="ln2230">void</a>
<a name="ln2231">Desktop::WindowAction(int32 windowToken, int32 action)</a>
<a name="ln2232">{</a>
<a name="ln2233">	if (action != B_MINIMIZE_WINDOW &amp;&amp; action != B_BRING_TO_FRONT)</a>
<a name="ln2234">		return;</a>
<a name="ln2235"> </a>
<a name="ln2236">	LockAllWindows();</a>
<a name="ln2237"> </a>
<a name="ln2238">	::ServerWindow* serverWindow;</a>
<a name="ln2239">	Window* window;</a>
<a name="ln2240">	if (BPrivate::gDefaultTokens.GetToken(windowToken,</a>
<a name="ln2241">			B_SERVER_TOKEN, (void**)&amp;serverWindow) != B_OK</a>
<a name="ln2242">		|| (window = serverWindow-&gt;Window()) == NULL) {</a>
<a name="ln2243">		UnlockAllWindows();</a>
<a name="ln2244">		return;</a>
<a name="ln2245">	}</a>
<a name="ln2246"> </a>
<a name="ln2247">	if (action == B_BRING_TO_FRONT &amp;&amp; !window-&gt;IsMinimized()) {</a>
<a name="ln2248">		// the window is visible, we just need to make it the front window</a>
<a name="ln2249">		ActivateWindow(window);</a>
<a name="ln2250">	} else {</a>
<a name="ln2251">		// if not, ask the window if it wants to be unminimized</a>
<a name="ln2252">		serverWindow-&gt;NotifyMinimize(action == B_MINIMIZE_WINDOW);</a>
<a name="ln2253">	}</a>
<a name="ln2254"> </a>
<a name="ln2255">	UnlockAllWindows();</a>
<a name="ln2256">}</a>
<a name="ln2257"> </a>
<a name="ln2258"> </a>
<a name="ln2259">void</a>
<a name="ln2260">Desktop::WriteWindowList(team_id team, BPrivate::LinkSender&amp; sender)</a>
<a name="ln2261">{</a>
<a name="ln2262">	AutoWriteLocker locker(fWindowLock);</a>
<a name="ln2263"> </a>
<a name="ln2264">	// compute the number of windows</a>
<a name="ln2265"> </a>
<a name="ln2266">	int32 count = 0;</a>
<a name="ln2267"> </a>
<a name="ln2268">	for (Window *window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2269">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2270">		if (team &lt; B_OK || window-&gt;ServerWindow()-&gt;ClientTeam() == team)</a>
<a name="ln2271">			count++;</a>
<a name="ln2272">	}</a>
<a name="ln2273"> </a>
<a name="ln2274">	// write list</a>
<a name="ln2275"> </a>
<a name="ln2276">	sender.StartMessage(B_OK);</a>
<a name="ln2277">	sender.Attach&lt;int32&gt;(count);</a>
<a name="ln2278"> </a>
<a name="ln2279">	// first write the windows of the current workspace correctly ordered</a>
<a name="ln2280">	for (Window *window = CurrentWindows().LastWindow(); window != NULL;</a>
<a name="ln2281">			window = window-&gt;PreviousWindow(fCurrentWorkspace)) {</a>
<a name="ln2282">		if (team &gt;= B_OK &amp;&amp; window-&gt;ServerWindow()-&gt;ClientTeam() != team)</a>
<a name="ln2283">			continue;</a>
<a name="ln2284"> </a>
<a name="ln2285">		sender.Attach&lt;int32&gt;(window-&gt;ServerWindow()-&gt;ServerToken());</a>
<a name="ln2286">	}</a>
<a name="ln2287"> </a>
<a name="ln2288">	// then write all the other windows</a>
<a name="ln2289">	for (Window *window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2290">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2291">		if ((team &gt;= B_OK &amp;&amp; window-&gt;ServerWindow()-&gt;ClientTeam() != team)</a>
<a name="ln2292">			|| window-&gt;InWorkspace(fCurrentWorkspace))</a>
<a name="ln2293">			continue;</a>
<a name="ln2294"> </a>
<a name="ln2295">		sender.Attach&lt;int32&gt;(window-&gt;ServerWindow()-&gt;ServerToken());</a>
<a name="ln2296">	}</a>
<a name="ln2297"> </a>
<a name="ln2298">	sender.Flush();</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301"> </a>
<a name="ln2302">void</a>
<a name="ln2303">Desktop::WriteWindowInfo(int32 serverToken, BPrivate::LinkSender&amp; sender)</a>
<a name="ln2304">{</a>
<a name="ln2305">	AutoWriteLocker locker(fWindowLock);</a>
<a name="ln2306">	BAutolock tokenLocker(BPrivate::gDefaultTokens);</a>
<a name="ln2307"> </a>
<a name="ln2308">	::ServerWindow* window;</a>
<a name="ln2309">	if (BPrivate::gDefaultTokens.GetToken(serverToken,</a>
<a name="ln2310">			B_SERVER_TOKEN, (void**)&amp;window) != B_OK) {</a>
<a name="ln2311">		sender.StartMessage(B_ENTRY_NOT_FOUND);</a>
<a name="ln2312">		sender.Flush();</a>
<a name="ln2313">		return;</a>
<a name="ln2314">	}</a>
<a name="ln2315"> </a>
<a name="ln2316">	window_info info;</a>
<a name="ln2317">	window-&gt;GetInfo(info);</a>
<a name="ln2318"> </a>
<a name="ln2319">	float tabSize = 0.0;</a>
<a name="ln2320">	float borderSize = 0.0;</a>
<a name="ln2321">	::Window* tmp = window-&gt;Window();</a>
<a name="ln2322">	if (tmp) {</a>
<a name="ln2323">		BMessage message;</a>
<a name="ln2324">		if (tmp-&gt;GetDecoratorSettings(&amp;message)) {</a>
<a name="ln2325">			BRect tabFrame;</a>
<a name="ln2326">			message.FindRect(&quot;tab frame&quot;, &amp;tabFrame);</a>
<a name="ln2327">			tabSize = tabFrame.bottom - tabFrame.top;</a>
<a name="ln2328">			message.FindFloat(&quot;border width&quot;, &amp;borderSize);</a>
<a name="ln2329">		}</a>
<a name="ln2330">	}</a>
<a name="ln2331"> </a>
<a name="ln2332">	int32 length = window-&gt;Title() ? strlen(window-&gt;Title()) : 0;</a>
<a name="ln2333"> </a>
<a name="ln2334">	sender.StartMessage(B_OK);</a>
<a name="ln2335">	sender.Attach&lt;int32&gt;(sizeof(client_window_info) + length);</a>
<a name="ln2336">	sender.Attach(&amp;info, sizeof(window_info));</a>
<a name="ln2337">	sender.Attach&lt;float&gt;(tabSize);</a>
<a name="ln2338">	sender.Attach&lt;float&gt;(borderSize);</a>
<a name="ln2339"> </a>
<a name="ln2340">	if (length &gt; 0)</a>
<a name="ln2341">		sender.Attach(window-&gt;Title(), length + 1);</a>
<a name="ln2342">	else</a>
<a name="ln2343">		sender.Attach&lt;char&gt;('\0');</a>
<a name="ln2344"> </a>
<a name="ln2345">	sender.Flush();</a>
<a name="ln2346">}</a>
<a name="ln2347"> </a>
<a name="ln2348"> </a>
<a name="ln2349">void</a>
<a name="ln2350">Desktop::WriteWindowOrder(int32 workspace, BPrivate::LinkSender&amp; sender)</a>
<a name="ln2351">{</a>
<a name="ln2352">	LockSingleWindow();</a>
<a name="ln2353"> </a>
<a name="ln2354">	if (workspace &lt; 0)</a>
<a name="ln2355">		workspace = fCurrentWorkspace;</a>
<a name="ln2356">	else if (workspace &gt;= kMaxWorkspaces) {</a>
<a name="ln2357">		sender.StartMessage(B_BAD_VALUE);</a>
<a name="ln2358">		sender.Flush();</a>
<a name="ln2359">		UnlockSingleWindow();</a>
<a name="ln2360">		return;</a>
<a name="ln2361">	}</a>
<a name="ln2362"> </a>
<a name="ln2363">	int32 count = _Windows(workspace).Count();</a>
<a name="ln2364"> </a>
<a name="ln2365">	// write list</a>
<a name="ln2366"> </a>
<a name="ln2367">	sender.StartMessage(B_OK);</a>
<a name="ln2368">	sender.Attach&lt;int32&gt;(count);</a>
<a name="ln2369"> </a>
<a name="ln2370">	for (Window *window = _Windows(workspace).LastWindow(); window != NULL;</a>
<a name="ln2371">			window = window-&gt;PreviousWindow(workspace)) {</a>
<a name="ln2372">		sender.Attach&lt;int32&gt;(window-&gt;ServerWindow()-&gt;ServerToken());</a>
<a name="ln2373">	}</a>
<a name="ln2374"> </a>
<a name="ln2375">	sender.Flush();</a>
<a name="ln2376"> </a>
<a name="ln2377">	UnlockSingleWindow();</a>
<a name="ln2378">}</a>
<a name="ln2379"> </a>
<a name="ln2380"> </a>
<a name="ln2381">void</a>
<a name="ln2382">Desktop::WriteApplicationOrder(int32 workspace, BPrivate::LinkSender&amp; sender)</a>
<a name="ln2383">{</a>
<a name="ln2384">	fApplicationsLock.Lock();</a>
<a name="ln2385">	LockSingleWindow();</a>
<a name="ln2386"> </a>
<a name="ln2387">	int32 maxCount = fApplications.CountItems();</a>
<a name="ln2388"> </a>
<a name="ln2389">	fApplicationsLock.Unlock();</a>
<a name="ln2390">		// as long as we hold the window lock, no new window can appear</a>
<a name="ln2391"> </a>
<a name="ln2392">	if (workspace &lt; 0)</a>
<a name="ln2393">		workspace = fCurrentWorkspace;</a>
<a name="ln2394">	else if (workspace &gt;= kMaxWorkspaces) {</a>
<a name="ln2395">		sender.StartMessage(B_BAD_VALUE);</a>
<a name="ln2396">		sender.Flush();</a>
<a name="ln2397">		UnlockSingleWindow();</a>
<a name="ln2398">		return;</a>
<a name="ln2399">	}</a>
<a name="ln2400"> </a>
<a name="ln2401">	// compute the list of applications on this workspace</a>
<a name="ln2402"> </a>
<a name="ln2403">	team_id* teams = (team_id*)malloc(maxCount * sizeof(team_id));</a>
<a name="ln2404">	if (teams == NULL) {</a>
<a name="ln2405">		sender.StartMessage(B_NO_MEMORY);</a>
<a name="ln2406">		sender.Flush();</a>
<a name="ln2407">		UnlockSingleWindow();</a>
<a name="ln2408">		return;</a>
<a name="ln2409">	}</a>
<a name="ln2410"> </a>
<a name="ln2411">	int32 count = 0;</a>
<a name="ln2412"> </a>
<a name="ln2413">	for (Window *window = _Windows(workspace).LastWindow(); window != NULL;</a>
<a name="ln2414">			window = window-&gt;PreviousWindow(workspace)) {</a>
<a name="ln2415">		team_id team = window-&gt;ServerWindow()-&gt;ClientTeam();</a>
<a name="ln2416">		if (count &gt; 1) {</a>
<a name="ln2417">			// see if we already have this team</a>
<a name="ln2418">			bool found = false;</a>
<a name="ln2419">			for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2420">				if (teams[i] == team) {</a>
<a name="ln2421">					found = true;</a>
<a name="ln2422">					break;</a>
<a name="ln2423">				}</a>
<a name="ln2424">			}</a>
<a name="ln2425">			if (found)</a>
<a name="ln2426">				continue;</a>
<a name="ln2427">		}</a>
<a name="ln2428"> </a>
<a name="ln2429">		ASSERT(count &lt; maxCount);</a>
<a name="ln2430">		teams[count++] = team;</a>
<a name="ln2431">	}</a>
<a name="ln2432"> </a>
<a name="ln2433">	UnlockSingleWindow();</a>
<a name="ln2434"> </a>
<a name="ln2435">	// write list</a>
<a name="ln2436"> </a>
<a name="ln2437">	sender.StartMessage(B_OK);</a>
<a name="ln2438">	sender.Attach&lt;int32&gt;(count);</a>
<a name="ln2439"> </a>
<a name="ln2440">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2441">		sender.Attach&lt;int32&gt;(teams[i]);</a>
<a name="ln2442">	}</a>
<a name="ln2443"> </a>
<a name="ln2444">	sender.Flush();</a>
<a name="ln2445">	free(teams);</a>
<a name="ln2446">}</a>
<a name="ln2447"> </a>
<a name="ln2448"> </a>
<a name="ln2449">void</a>
<a name="ln2450">Desktop::_LaunchInputServer()</a>
<a name="ln2451">{</a>
<a name="ln2452">	BRoster roster;</a>
<a name="ln2453">	status_t status = roster.Launch(&quot;application/x-vnd.Be-input_server&quot;);</a>
<a name="ln2454">	if (status == B_OK || status == B_ALREADY_RUNNING)</a>
<a name="ln2455">		return;</a>
<a name="ln2456"> </a>
<a name="ln2457">	// Could not load input_server by signature, try well-known location</a>
<a name="ln2458"> </a>
<a name="ln2459">	BEntry entry;</a>
<a name="ln2460">	BPath inputServerPath;</a>
<a name="ln2461">	if (find_directory(B_SYSTEM_SERVERS_DIRECTORY, &amp;inputServerPath) == B_OK</a>
<a name="ln2462">		&amp;&amp; inputServerPath.Append(&quot;input_server&quot;) == B_OK) {</a>
<a name="ln2463">		entry.SetTo(inputServerPath.Path());</a>
<a name="ln2464">	} else</a>
<a name="ln2465">		entry.SetTo(&quot;/system/servers/input_server&quot;);</a>
<a name="ln2466">	entry_ref ref;</a>
<a name="ln2467">	status_t entryStatus = entry.GetRef(&amp;ref);</a>
<a name="ln2468">	if (entryStatus == B_OK)</a>
<a name="ln2469">		entryStatus = roster.Launch(&amp;ref);</a>
<a name="ln2470">	if (entryStatus == B_OK || entryStatus == B_ALREADY_RUNNING) {</a>
<a name="ln2471">		syslog(LOG_ERR, &quot;Failed to launch the input server by signature: %s!\n&quot;,</a>
<a name="ln2472">			strerror(status));</a>
<a name="ln2473">		return;</a>
<a name="ln2474">	}</a>
<a name="ln2475"> </a>
<a name="ln2476">	syslog(LOG_ERR, &quot;Failed to launch the input server: %s!\n&quot;,</a>
<a name="ln2477">		strerror(entryStatus));</a>
<a name="ln2478">}</a>
<a name="ln2479"> </a>
<a name="ln2480"> </a>
<a name="ln2481">void</a>
<a name="ln2482">Desktop::_GetLooperName(char* name, size_t length)</a>
<a name="ln2483">{</a>
<a name="ln2484">	snprintf(name, length, &quot;d:%d:%s&quot;, fUserID,</a>
<a name="ln2485">		fTargetScreen == NULL ? &quot;baron&quot; : fTargetScreen);</a>
<a name="ln2486">}</a>
<a name="ln2487"> </a>
<a name="ln2488"> </a>
<a name="ln2489">void</a>
<a name="ln2490">Desktop::_PrepareQuit()</a>
<a name="ln2491">{</a>
<a name="ln2492">	// let's kill all remaining applications</a>
<a name="ln2493"> </a>
<a name="ln2494">	fApplicationsLock.Lock();</a>
<a name="ln2495"> </a>
<a name="ln2496">	int32 count = fApplications.CountItems();</a>
<a name="ln2497">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2498">		ServerApp *app = fApplications.ItemAt(i);</a>
<a name="ln2499">		team_id clientTeam = app-&gt;ClientTeam();</a>
<a name="ln2500"> </a>
<a name="ln2501">		app-&gt;Quit();</a>
<a name="ln2502">		kill_team(clientTeam);</a>
<a name="ln2503">	}</a>
<a name="ln2504"> </a>
<a name="ln2505">	// wait for the last app to die</a>
<a name="ln2506">	if (count &gt; 0) {</a>
<a name="ln2507">		acquire_sem_etc(fShutdownSemaphore, fShutdownCount, B_RELATIVE_TIMEOUT,</a>
<a name="ln2508">			250000);</a>
<a name="ln2509">	}</a>
<a name="ln2510"> </a>
<a name="ln2511">	fApplicationsLock.Unlock();</a>
<a name="ln2512">}</a>
<a name="ln2513"> </a>
<a name="ln2514"> </a>
<a name="ln2515">void</a>
<a name="ln2516">Desktop::_DispatchMessage(int32 code, BPrivate::LinkReceiver&amp; link)</a>
<a name="ln2517">{</a>
<a name="ln2518">	switch (code) {</a>
<a name="ln2519">		case AS_CREATE_APP:</a>
<a name="ln2520">		{</a>
<a name="ln2521">			// Create the ServerApp to node monitor a new BApplication</a>
<a name="ln2522"> </a>
<a name="ln2523">			// Attached data:</a>
<a name="ln2524">			// 1) port_id - receiver port of a regular app</a>
<a name="ln2525">			// 2) port_id - client looper port - for sending messages to the</a>
<a name="ln2526">			//		client</a>
<a name="ln2527">			// 2) team_id - app's team ID</a>
<a name="ln2528">			// 3) int32 - handler token of the regular app</a>
<a name="ln2529">			// 4) char * - signature of the regular app</a>
<a name="ln2530"> </a>
<a name="ln2531">			// Find the necessary data</a>
<a name="ln2532">			team_id	clientTeamID = -1;</a>
<a name="ln2533">			port_id	clientLooperPort = -1;</a>
<a name="ln2534">			port_id clientReplyPort = -1;</a>
<a name="ln2535">			int32 htoken = B_NULL_TOKEN;</a>
<a name="ln2536">			char* appSignature = NULL;</a>
<a name="ln2537"> </a>
<a name="ln2538">			link.Read&lt;port_id&gt;(&amp;clientReplyPort);</a>
<a name="ln2539">			link.Read&lt;port_id&gt;(&amp;clientLooperPort);</a>
<a name="ln2540">			link.Read&lt;team_id&gt;(&amp;clientTeamID);</a>
<a name="ln2541">			link.Read&lt;int32&gt;(&amp;htoken);</a>
<a name="ln2542">			if (link.ReadString(&amp;appSignature) != B_OK)</a>
<a name="ln2543">				break;</a>
<a name="ln2544"> </a>
<a name="ln2545">			ServerApp* app = new (std::nothrow) ServerApp(this, clientReplyPort,</a>
<a name="ln2546">				clientLooperPort, clientTeamID, htoken, appSignature);</a>
<a name="ln2547">			status_t status = B_OK;</a>
<a name="ln2548">			if (app == NULL)</a>
<a name="ln2549">				status = B_NO_MEMORY;</a>
<a name="ln2550">			if (status == B_OK)</a>
<a name="ln2551">				status = app-&gt;InitCheck();</a>
<a name="ln2552">			if (status == B_OK)</a>
<a name="ln2553">				status = app-&gt;Run();</a>
<a name="ln2554">			if (status == B_OK) {</a>
<a name="ln2555">				// add the new ServerApp to the known list of ServerApps</a>
<a name="ln2556">				fApplicationsLock.Lock();</a>
<a name="ln2557">				fApplications.AddItem(app);</a>
<a name="ln2558">				fApplicationsLock.Unlock();</a>
<a name="ln2559">			} else {</a>
<a name="ln2560">				delete app;</a>
<a name="ln2561"> </a>
<a name="ln2562">				// if everything went well, ServerApp::Run() will notify</a>
<a name="ln2563">				// the client - but since it didn't, we do it here</a>
<a name="ln2564">				BPrivate::LinkSender reply(clientReplyPort);</a>
<a name="ln2565">				reply.StartMessage(status);</a>
<a name="ln2566">				reply.Flush();</a>
<a name="ln2567">			}</a>
<a name="ln2568"> </a>
<a name="ln2569">			// This is necessary because BPortLink::ReadString allocates memory</a>
<a name="ln2570">			free(appSignature);</a>
<a name="ln2571">			break;</a>
<a name="ln2572">		}</a>
<a name="ln2573"> </a>
<a name="ln2574">		case AS_DELETE_APP:</a>
<a name="ln2575">		{</a>
<a name="ln2576">			// Delete a ServerApp. Received only from the respective ServerApp</a>
<a name="ln2577">			// when a BApplication asks it to quit.</a>
<a name="ln2578"> </a>
<a name="ln2579">			// Attached Data:</a>
<a name="ln2580">			// 1) thread_id - thread ID of the ServerApp to be deleted</a>
<a name="ln2581"> </a>
<a name="ln2582">			thread_id thread = -1;</a>
<a name="ln2583">			if (link.Read&lt;thread_id&gt;(&amp;thread) &lt; B_OK)</a>
<a name="ln2584">				break;</a>
<a name="ln2585"> </a>
<a name="ln2586">			fApplicationsLock.Lock();</a>
<a name="ln2587"> </a>
<a name="ln2588">			// Run through the list of apps and nuke the proper one</a>
<a name="ln2589"> </a>
<a name="ln2590">			int32 count = fApplications.CountItems();</a>
<a name="ln2591">			ServerApp* removeApp = NULL;</a>
<a name="ln2592"> </a>
<a name="ln2593">			for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2594">				ServerApp* app = fApplications.ItemAt(i);</a>
<a name="ln2595"> </a>
<a name="ln2596">				if (app-&gt;Thread() == thread) {</a>
<a name="ln2597">					fApplications.RemoveItemAt(i);</a>
<a name="ln2598">					removeApp = app;</a>
<a name="ln2599">					break;</a>
<a name="ln2600">				}</a>
<a name="ln2601">			}</a>
<a name="ln2602"> </a>
<a name="ln2603">			fApplicationsLock.Unlock();</a>
<a name="ln2604"> </a>
<a name="ln2605">			if (removeApp != NULL)</a>
<a name="ln2606">				removeApp-&gt;Quit(fShutdownSemaphore);</a>
<a name="ln2607"> </a>
<a name="ln2608">			if (fQuitting &amp;&amp; count &lt;= 1) {</a>
<a name="ln2609">				// wait for the last app to die</a>
<a name="ln2610">				acquire_sem_etc(fShutdownSemaphore, fShutdownCount,</a>
<a name="ln2611">					B_RELATIVE_TIMEOUT, 500000);</a>
<a name="ln2612">				PostMessage(kMsgQuitLooper);</a>
<a name="ln2613">			}</a>
<a name="ln2614">			break;</a>
<a name="ln2615">		}</a>
<a name="ln2616"> </a>
<a name="ln2617">		case AS_ACTIVATE_APP:</a>
<a name="ln2618">		{</a>
<a name="ln2619">			// Someone is requesting to activation of a certain app.</a>
<a name="ln2620"> </a>
<a name="ln2621">			// Attached data:</a>
<a name="ln2622">			// 1) port_id reply port</a>
<a name="ln2623">			// 2) team_id team</a>
<a name="ln2624"> </a>
<a name="ln2625">			status_t status;</a>
<a name="ln2626"> </a>
<a name="ln2627">			// get the parameters</a>
<a name="ln2628">			port_id replyPort;</a>
<a name="ln2629">			team_id team;</a>
<a name="ln2630">			if (link.Read(&amp;replyPort) == B_OK</a>
<a name="ln2631">				&amp;&amp; link.Read(&amp;team) == B_OK)</a>
<a name="ln2632">				status = _ActivateApp(team);</a>
<a name="ln2633">			else</a>
<a name="ln2634">				status = B_ERROR;</a>
<a name="ln2635"> </a>
<a name="ln2636">			// send the reply</a>
<a name="ln2637">			BPrivate::PortLink replyLink(replyPort);</a>
<a name="ln2638">			replyLink.StartMessage(status);</a>
<a name="ln2639">			replyLink.Flush();</a>
<a name="ln2640">			break;</a>
<a name="ln2641">		}</a>
<a name="ln2642"> </a>
<a name="ln2643">		case AS_APP_CRASHED:</a>
<a name="ln2644">		case AS_DUMP_ALLOCATOR:</a>
<a name="ln2645">		case AS_DUMP_BITMAPS:</a>
<a name="ln2646">		{</a>
<a name="ln2647">			BAutolock locker(fApplicationsLock);</a>
<a name="ln2648"> </a>
<a name="ln2649">			team_id team;</a>
<a name="ln2650">			if (link.Read(&amp;team) != B_OK)</a>
<a name="ln2651">				break;</a>
<a name="ln2652"> </a>
<a name="ln2653">			for (int32 i = 0; i &lt; fApplications.CountItems(); i++) {</a>
<a name="ln2654">				ServerApp* app = fApplications.ItemAt(i);</a>
<a name="ln2655"> </a>
<a name="ln2656">				if (app-&gt;ClientTeam() == team)</a>
<a name="ln2657">					app-&gt;PostMessage(code);</a>
<a name="ln2658">			}</a>
<a name="ln2659">			break;</a>
<a name="ln2660">		}</a>
<a name="ln2661"> </a>
<a name="ln2662">		case AS_EVENT_STREAM_CLOSED:</a>
<a name="ln2663">			_LaunchInputServer();</a>
<a name="ln2664">			break;</a>
<a name="ln2665"> </a>
<a name="ln2666">		case B_QUIT_REQUESTED:</a>
<a name="ln2667">			// We've been asked to quit, so (for now) broadcast to all</a>
<a name="ln2668">			// test apps to quit. This situation will occur only when the</a>
<a name="ln2669">			// server is compiled as a regular Be application.</a>
<a name="ln2670"> </a>
<a name="ln2671">			fApplicationsLock.Lock();</a>
<a name="ln2672">			fShutdownSemaphore = create_sem(0, &quot;desktop shutdown&quot;);</a>
<a name="ln2673">			fShutdownCount = fApplications.CountItems();</a>
<a name="ln2674">			fApplicationsLock.Unlock();</a>
<a name="ln2675"> </a>
<a name="ln2676">			fQuitting = true;</a>
<a name="ln2677">			BroadcastToAllApps(AS_QUIT_APP);</a>
<a name="ln2678"> </a>
<a name="ln2679">			// We now need to process the remaining AS_DELETE_APP messages and</a>
<a name="ln2680">			// wait for the kMsgShutdownServer message.</a>
<a name="ln2681">			// If an application does not quit as asked, the picasso thread</a>
<a name="ln2682">			// will send us this message in 2-3 seconds.</a>
<a name="ln2683"> </a>
<a name="ln2684">			// if there are no apps to quit, shutdown directly</a>
<a name="ln2685">			if (fShutdownCount == 0)</a>
<a name="ln2686">				PostMessage(kMsgQuitLooper);</a>
<a name="ln2687">			break;</a>
<a name="ln2688"> </a>
<a name="ln2689">		case AS_ACTIVATE_WORKSPACE:</a>
<a name="ln2690">		{</a>
<a name="ln2691">			int32 index;</a>
<a name="ln2692">			link.Read&lt;int32&gt;(&amp;index);</a>
<a name="ln2693">			if (index == -1)</a>
<a name="ln2694">				index = fPreviousWorkspace;</a>
<a name="ln2695"> </a>
<a name="ln2696">			bool moveFocusWindow;</a>
<a name="ln2697">			link.Read&lt;bool&gt;(&amp;moveFocusWindow);</a>
<a name="ln2698"> </a>
<a name="ln2699">			SetWorkspace(index, moveFocusWindow);</a>
<a name="ln2700">			break;</a>
<a name="ln2701">		}</a>
<a name="ln2702"> </a>
<a name="ln2703">		case AS_TALK_TO_DESKTOP_LISTENER:</a>
<a name="ln2704">		{</a>
<a name="ln2705">			port_id clientReplyPort;</a>
<a name="ln2706">			if (link.Read&lt;port_id&gt;(&amp;clientReplyPort) != B_OK)</a>
<a name="ln2707">				break;</a>
<a name="ln2708"> </a>
<a name="ln2709">			BPrivate::LinkSender reply(clientReplyPort);</a>
<a name="ln2710">			AutoWriteLocker locker(fWindowLock);</a>
<a name="ln2711">			if (MessageForListener(NULL, link, reply) != true) {</a>
<a name="ln2712">				// unhandled message, at least send an error if needed</a>
<a name="ln2713">				if (link.NeedsReply()) {</a>
<a name="ln2714">					reply.StartMessage(B_ERROR);</a>
<a name="ln2715">					reply.Flush();</a>
<a name="ln2716">				}</a>
<a name="ln2717">			}</a>
<a name="ln2718">			break;</a>
<a name="ln2719">		}</a>
<a name="ln2720"> </a>
<a name="ln2721">		case AS_SET_UI_COLOR:</a>
<a name="ln2722">		{</a>
<a name="ln2723">			color_which which;</a>
<a name="ln2724">			rgb_color color;</a>
<a name="ln2725"> </a>
<a name="ln2726">			if (link.Read&lt;color_which&gt;(&amp;which) == B_OK</a>
<a name="ln2727">					&amp;&amp; link.Read&lt;rgb_color&gt;(&amp;color) == B_OK) {</a>
<a name="ln2728"> </a>
<a name="ln2729">				const char* colorName = ui_color_name(which);</a>
<a name="ln2730">				fPendingColors.SetColor(colorName, color);</a>
<a name="ln2731"> </a>
<a name="ln2732">				DelayedMessage delayed(AS_SET_UI_COLORS, DM_60HZ_DELAY);</a>
<a name="ln2733">				delayed.AddTarget(MessagePort());</a>
<a name="ln2734">				delayed.SetMerge(DM_MERGE_CANCEL);</a>
<a name="ln2735"> </a>
<a name="ln2736">				delayed.Attach&lt;bool&gt;(true);</a>
<a name="ln2737">				delayed.Flush();</a>
<a name="ln2738">			}</a>
<a name="ln2739"> </a>
<a name="ln2740">			break;</a>
<a name="ln2741">		}</a>
<a name="ln2742"> </a>
<a name="ln2743">		case AS_SET_UI_COLORS:</a>
<a name="ln2744">		{</a>
<a name="ln2745">			bool flushPendingOnly = false;</a>
<a name="ln2746"> </a>
<a name="ln2747">			if (link.Read&lt;bool&gt;(&amp;flushPendingOnly) != B_OK</a>
<a name="ln2748">				|| (flushPendingOnly &amp;&amp;</a>
<a name="ln2749">						fPendingColors.CountNames(B_RGB_32_BIT_TYPE) == 0)) {</a>
<a name="ln2750">				break;</a>
<a name="ln2751">			}</a>
<a name="ln2752"> </a>
<a name="ln2753">			if (!flushPendingOnly) {</a>
<a name="ln2754">				// Client wants to set a color map</a>
<a name="ln2755">				color_which which = B_NO_COLOR;</a>
<a name="ln2756">				rgb_color color;</a>
<a name="ln2757"> </a>
<a name="ln2758">				do {</a>
<a name="ln2759">					if (link.Read&lt;color_which&gt;(&amp;which) != B_OK</a>
<a name="ln2760">						|| link.Read&lt;rgb_color&gt;(&amp;color) != B_OK)</a>
<a name="ln2761">						break;</a>
<a name="ln2762"> </a>
<a name="ln2763">					fPendingColors.SetColor(ui_color_name(which), color);</a>
<a name="ln2764">				} while (which != B_NO_COLOR);</a>
<a name="ln2765">			}</a>
<a name="ln2766"> </a>
<a name="ln2767">			_FlushPendingColors();</a>
<a name="ln2768">			break;</a>
<a name="ln2769">		}</a>
<a name="ln2770"> </a>
<a name="ln2771">		// ToDo: Remove this again. It is a message sent by the</a>
<a name="ln2772">		// invalidate_on_exit kernel debugger add-on to trigger a redraw</a>
<a name="ln2773">		// after exiting a kernel debugger session.</a>
<a name="ln2774">		case 'KDLE':</a>
<a name="ln2775">		{</a>
<a name="ln2776">			BRegion dirty;</a>
<a name="ln2777">			dirty.Include(fVirtualScreen.Frame());</a>
<a name="ln2778">			MarkDirty(dirty);</a>
<a name="ln2779">			break;</a>
<a name="ln2780">		}</a>
<a name="ln2781"> </a>
<a name="ln2782">		default:</a>
<a name="ln2783">			printf(&quot;Desktop %d:%s received unexpected code %&quot; B_PRId32 &quot;\n&quot;, 0,</a>
<a name="ln2784">				&quot;baron&quot;, code);</a>
<a name="ln2785"> </a>
<a name="ln2786">			if (link.NeedsReply()) {</a>
<a name="ln2787">				// the client is now blocking and waiting for a reply!</a>
<a name="ln2788">				fLink.StartMessage(B_ERROR);</a>
<a name="ln2789">				fLink.Flush();</a>
<a name="ln2790">			}</a>
<a name="ln2791">			break;</a>
<a name="ln2792">	}</a>
<a name="ln2793">}</a>
<a name="ln2794"> </a>
<a name="ln2795"> </a>
<a name="ln2796">WindowList&amp;</a>
<a name="ln2797">Desktop::CurrentWindows()</a>
<a name="ln2798">{</a>
<a name="ln2799">	return fWorkspaces[fCurrentWorkspace].Windows();</a>
<a name="ln2800">}</a>
<a name="ln2801"> </a>
<a name="ln2802"> </a>
<a name="ln2803">WindowList&amp;</a>
<a name="ln2804">Desktop::AllWindows()</a>
<a name="ln2805">{</a>
<a name="ln2806">	return fAllWindows;</a>
<a name="ln2807">}</a>
<a name="ln2808"> </a>
<a name="ln2809"> </a>
<a name="ln2810">Window*</a>
<a name="ln2811">Desktop::WindowForClientLooperPort(port_id port)</a>
<a name="ln2812">{</a>
<a name="ln2813">	ASSERT_MULTI_LOCKED(fWindowLock);</a>
<a name="ln2814"> </a>
<a name="ln2815">	for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2816">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2817">		if (window-&gt;ServerWindow()-&gt;ClientLooperPort() == port)</a>
<a name="ln2818">			return window;</a>
<a name="ln2819">	}</a>
<a name="ln2820">	return NULL;</a>
<a name="ln2821">}</a>
<a name="ln2822"> </a>
<a name="ln2823"> </a>
<a name="ln2824">WindowList&amp;</a>
<a name="ln2825">Desktop::_Windows(int32 index)</a>
<a name="ln2826">{</a>
<a name="ln2827">	ASSERT(index &gt;= 0 &amp;&amp; index &lt; kMaxWorkspaces);</a>
<a name="ln2828">	return fWorkspaces[index].Windows();</a>
<a name="ln2829">}</a>
<a name="ln2830"> </a>
<a name="ln2831"> </a>
<a name="ln2832">void</a>
<a name="ln2833">Desktop::_FlushPendingColors()</a>
<a name="ln2834">{</a>
<a name="ln2835">	// Update all windows while we are holding the write lock.</a>
<a name="ln2836"> </a>
<a name="ln2837">	int32 count = fPendingColors.CountNames(B_RGB_32_BIT_TYPE);</a>
<a name="ln2838">	if (count == 0)</a>
<a name="ln2839">		return;</a>
<a name="ln2840"> </a>
<a name="ln2841">	bool changed[count];</a>
<a name="ln2842">	LockedDesktopSettings settings(this);</a>
<a name="ln2843">	settings.SetUIColors(fPendingColors, &amp;changed[0]);</a>
<a name="ln2844"> </a>
<a name="ln2845">	int32 index = 0;</a>
<a name="ln2846">	char* name = NULL;</a>
<a name="ln2847">	type_code type = B_RGB_32_BIT_TYPE;</a>
<a name="ln2848">	rgb_color color;</a>
<a name="ln2849">	color_which which = B_NO_COLOR;</a>
<a name="ln2850">	BMessage clientMessage(B_COLORS_UPDATED);</a>
<a name="ln2851"> </a>
<a name="ln2852">	while (fPendingColors.GetInfo(type, index, &amp;name, &amp;type) == B_OK) {</a>
<a name="ln2853">		which = which_ui_color(name);</a>
<a name="ln2854">		if (which == B_NO_COLOR || fPendingColors.FindColor(name,</a>
<a name="ln2855">				&amp;color) != B_OK || !changed[index]) {</a>
<a name="ln2856">			++index;</a>
<a name="ln2857">			continue;</a>
<a name="ln2858">		}</a>
<a name="ln2859"> </a>
<a name="ln2860">		for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln2861">				window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln2862">			ColorUpdated(window, which, color);</a>
<a name="ln2863">		}</a>
<a name="ln2864"> </a>
<a name="ln2865">		// Ensure client only gets list of changed colors</a>
<a name="ln2866">		clientMessage.AddColor(name, color);</a>
<a name="ln2867">		++index;</a>
<a name="ln2868">	}</a>
<a name="ln2869"> </a>
<a name="ln2870">	// Notify client applications</a>
<a name="ln2871">	BAutolock appListLock(fApplicationsLock);</a>
<a name="ln2872">	for (int32 index = 0; index &lt; fApplications.CountItems(); ++index) {</a>
<a name="ln2873">		fApplications.ItemAt(index)-&gt;SendMessageToClient(&amp;clientMessage);</a>
<a name="ln2874">	}</a>
<a name="ln2875"> </a>
<a name="ln2876">	fPendingColors.MakeEmpty();</a>
<a name="ln2877">}</a>
<a name="ln2878"> </a>
<a name="ln2879"> </a>
<a name="ln2880">void</a>
<a name="ln2881">Desktop::_UpdateFloating(int32 previousWorkspace, int32 nextWorkspace,</a>
<a name="ln2882">	Window* mouseEventWindow)</a>
<a name="ln2883">{</a>
<a name="ln2884">	if (previousWorkspace == -1)</a>
<a name="ln2885">		previousWorkspace = fCurrentWorkspace;</a>
<a name="ln2886">	if (nextWorkspace == -1)</a>
<a name="ln2887">		nextWorkspace = previousWorkspace;</a>
<a name="ln2888"> </a>
<a name="ln2889">	for (Window* floating = fSubsetWindows.FirstWindow(); floating != NULL;</a>
<a name="ln2890">			floating = floating-&gt;NextWindow(kSubsetList)) {</a>
<a name="ln2891">		// we only care about app/subset floating windows</a>
<a name="ln2892">		if (floating-&gt;Feel() != B_FLOATING_SUBSET_WINDOW_FEEL</a>
<a name="ln2893">			&amp;&amp; floating-&gt;Feel() != B_FLOATING_APP_WINDOW_FEEL)</a>
<a name="ln2894">			continue;</a>
<a name="ln2895"> </a>
<a name="ln2896">		if (fFront != NULL &amp;&amp; fFront-&gt;IsNormal()</a>
<a name="ln2897">			&amp;&amp; floating-&gt;HasInSubset(fFront)) {</a>
<a name="ln2898">			// is now visible</a>
<a name="ln2899">			if (_Windows(previousWorkspace).HasWindow(floating)</a>
<a name="ln2900">				&amp;&amp; previousWorkspace != nextWorkspace</a>
<a name="ln2901">				&amp;&amp; !floating-&gt;InSubsetWorkspace(previousWorkspace)) {</a>
<a name="ln2902">				// but no longer on the previous workspace</a>
<a name="ln2903">				_Windows(previousWorkspace).RemoveWindow(floating);</a>
<a name="ln2904">				floating-&gt;SetCurrentWorkspace(-1);</a>
<a name="ln2905">			}</a>
<a name="ln2906"> </a>
<a name="ln2907">			if (!_Windows(nextWorkspace).HasWindow(floating)) {</a>
<a name="ln2908">				// but wasn't before</a>
<a name="ln2909">				_Windows(nextWorkspace).AddWindow(floating,</a>
<a name="ln2910">					floating-&gt;Frontmost(_Windows(nextWorkspace).FirstWindow(),</a>
<a name="ln2911">					nextWorkspace));</a>
<a name="ln2912">				floating-&gt;SetCurrentWorkspace(nextWorkspace);</a>
<a name="ln2913">				if (mouseEventWindow != fFront)</a>
<a name="ln2914">					_ShowWindow(floating);</a>
<a name="ln2915"> </a>
<a name="ln2916">				// TODO: put the floating last in the floating window list to</a>
<a name="ln2917">				// preserve the on screen window order</a>
<a name="ln2918">			}</a>
<a name="ln2919">		} else if (_Windows(previousWorkspace).HasWindow(floating)</a>
<a name="ln2920">			&amp;&amp; !floating-&gt;InSubsetWorkspace(previousWorkspace)) {</a>
<a name="ln2921">			// was visible, but is no longer</a>
<a name="ln2922"> </a>
<a name="ln2923">			_Windows(previousWorkspace).RemoveWindow(floating);</a>
<a name="ln2924">			floating-&gt;SetCurrentWorkspace(-1);</a>
<a name="ln2925">			_HideWindow(floating);</a>
<a name="ln2926"> </a>
<a name="ln2927">			if (FocusWindow() == floating)</a>
<a name="ln2928">				SetFocusWindow();</a>
<a name="ln2929">		}</a>
<a name="ln2930">	}</a>
<a name="ln2931">}</a>
<a name="ln2932"> </a>
<a name="ln2933"> </a>
<a name="ln2934">/*!	Search the visible windows for a valid back window</a>
<a name="ln2935">	(only desktop windows can't be back windows)</a>
<a name="ln2936">*/</a>
<a name="ln2937">void</a>
<a name="ln2938">Desktop::_UpdateBack()</a>
<a name="ln2939">{</a>
<a name="ln2940">	fBack = NULL;</a>
<a name="ln2941"> </a>
<a name="ln2942">	for (Window* window = CurrentWindows().FirstWindow(); window != NULL;</a>
<a name="ln2943">			window = window-&gt;NextWindow(fCurrentWorkspace)) {</a>
<a name="ln2944">		if (window-&gt;IsHidden() || window-&gt;Feel() == kDesktopWindowFeel)</a>
<a name="ln2945">			continue;</a>
<a name="ln2946"> </a>
<a name="ln2947">		fBack = window;</a>
<a name="ln2948">		break;</a>
<a name="ln2949">	}</a>
<a name="ln2950">}</a>
<a name="ln2951"> </a>
<a name="ln2952"> </a>
<a name="ln2953">/*!	Search the visible windows for a valid front window</a>
<a name="ln2954">	(only normal and modal windows can be front windows)</a>
<a name="ln2955"> </a>
<a name="ln2956">	The only place where you don't want to update floating windows is</a>
<a name="ln2957">	during a workspace change - because then you'll call _UpdateFloating()</a>
<a name="ln2958">	yourself.</a>
<a name="ln2959">*/</a>
<a name="ln2960">void</a>
<a name="ln2961">Desktop::_UpdateFront(bool updateFloating)</a>
<a name="ln2962">{</a>
<a name="ln2963">	fFront = NULL;</a>
<a name="ln2964"> </a>
<a name="ln2965">	for (Window* window = CurrentWindows().LastWindow(); window != NULL;</a>
<a name="ln2966">			window = window-&gt;PreviousWindow(fCurrentWorkspace)) {</a>
<a name="ln2967">		if (window-&gt;IsHidden() || window-&gt;IsFloating()</a>
<a name="ln2968">			|| !window-&gt;SupportsFront())</a>
<a name="ln2969">			continue;</a>
<a name="ln2970"> </a>
<a name="ln2971">		fFront = window;</a>
<a name="ln2972">		break;</a>
<a name="ln2973">	}</a>
<a name="ln2974"> </a>
<a name="ln2975">	if (updateFloating)</a>
<a name="ln2976">		_UpdateFloating();</a>
<a name="ln2977">}</a>
<a name="ln2978"> </a>
<a name="ln2979"> </a>
<a name="ln2980">void</a>
<a name="ln2981">Desktop::_UpdateFronts(bool updateFloating)</a>
<a name="ln2982">{</a>
<a name="ln2983">	_UpdateBack();</a>
<a name="ln2984">	_UpdateFront(updateFloating);</a>
<a name="ln2985">}</a>
<a name="ln2986"> </a>
<a name="ln2987"> </a>
<a name="ln2988">bool</a>
<a name="ln2989">Desktop::_WindowHasModal(Window* window) const</a>
<a name="ln2990">{</a>
<a name="ln2991">	if (window == NULL)</a>
<a name="ln2992">		return false;</a>
<a name="ln2993"> </a>
<a name="ln2994">	for (Window* modal = fSubsetWindows.FirstWindow(); modal != NULL;</a>
<a name="ln2995">			modal = modal-&gt;NextWindow(kSubsetList)) {</a>
<a name="ln2996">		// only visible modal windows count</a>
<a name="ln2997">		if (!modal-&gt;IsModal() || modal-&gt;IsHidden())</a>
<a name="ln2998">			continue;</a>
<a name="ln2999"> </a>
<a name="ln3000">		if (modal-&gt;HasInSubset(window))</a>
<a name="ln3001">			return true;</a>
<a name="ln3002">	}</a>
<a name="ln3003"> </a>
<a name="ln3004">	return false;</a>
<a name="ln3005">}</a>
<a name="ln3006"> </a>
<a name="ln3007"> </a>
<a name="ln3008">/*!	Determines whether or not the specified \a window can have focus at all.</a>
<a name="ln3009">*/</a>
<a name="ln3010">bool</a>
<a name="ln3011">Desktop::_WindowCanHaveFocus(Window* window) const</a>
<a name="ln3012">{</a>
<a name="ln3013">	return window != NULL</a>
<a name="ln3014">		&amp;&amp; window-&gt;InWorkspace(fCurrentWorkspace)</a>
<a name="ln3015">		&amp;&amp; (window-&gt;Flags() &amp; B_AVOID_FOCUS) == 0</a>
<a name="ln3016">		&amp;&amp; !_WindowHasModal(window)</a>
<a name="ln3017">		&amp;&amp; !window-&gt;IsHidden();</a>
<a name="ln3018">}</a>
<a name="ln3019"> </a>
<a name="ln3020"> </a>
<a name="ln3021">/*!	You must at least hold a single window lock when calling this method.</a>
<a name="ln3022">*/</a>
<a name="ln3023">void</a>
<a name="ln3024">Desktop::_WindowChanged(Window* window)</a>
<a name="ln3025">{</a>
<a name="ln3026">	ASSERT_MULTI_LOCKED(fWindowLock);</a>
<a name="ln3027"> </a>
<a name="ln3028">	BAutolock _(fWorkspacesLock);</a>
<a name="ln3029"> </a>
<a name="ln3030">	for (uint32 i = fWorkspacesViews.CountItems(); i-- &gt; 0;) {</a>
<a name="ln3031">		WorkspacesView* view = fWorkspacesViews.ItemAt(i);</a>
<a name="ln3032">		view-&gt;WindowChanged(window);</a>
<a name="ln3033">	}</a>
<a name="ln3034">}</a>
<a name="ln3035"> </a>
<a name="ln3036"> </a>
<a name="ln3037">/*!	You must at least hold a single window lock when calling this method.</a>
<a name="ln3038">*/</a>
<a name="ln3039">void</a>
<a name="ln3040">Desktop::_WindowRemoved(Window* window)</a>
<a name="ln3041">{</a>
<a name="ln3042">	ASSERT_MULTI_LOCKED(fWindowLock);</a>
<a name="ln3043"> </a>
<a name="ln3044">	BAutolock _(fWorkspacesLock);</a>
<a name="ln3045"> </a>
<a name="ln3046">	for (uint32 i = fWorkspacesViews.CountItems(); i-- &gt; 0;) {</a>
<a name="ln3047">		WorkspacesView* view = fWorkspacesViews.ItemAt(i);</a>
<a name="ln3048">		view-&gt;WindowRemoved(window);</a>
<a name="ln3049">	}</a>
<a name="ln3050">}</a>
<a name="ln3051"> </a>
<a name="ln3052"> </a>
<a name="ln3053">/*!	Shows the window on the screen - it does this independently of the</a>
<a name="ln3054">	Window::IsHidden() state.</a>
<a name="ln3055">*/</a>
<a name="ln3056">void</a>
<a name="ln3057">Desktop::_ShowWindow(Window* window, bool affectsOtherWindows)</a>
<a name="ln3058">{</a>
<a name="ln3059">	BRegion background;</a>
<a name="ln3060">	_RebuildClippingForAllWindows(background);</a>
<a name="ln3061">	_SetBackground(background);</a>
<a name="ln3062">	_WindowChanged(window);</a>
<a name="ln3063"> </a>
<a name="ln3064">	BRegion dirty(window-&gt;VisibleRegion());</a>
<a name="ln3065"> </a>
<a name="ln3066">	if (!affectsOtherWindows) {</a>
<a name="ln3067">		// everything that is now visible in the</a>
<a name="ln3068">		// window needs a redraw, but other windows</a>
<a name="ln3069">		// are not affected, we can call ProcessDirtyRegion()</a>
<a name="ln3070">		// of the window, and don't have to use MarkDirty()</a>
<a name="ln3071">		window-&gt;ProcessDirtyRegion(dirty);</a>
<a name="ln3072">	} else</a>
<a name="ln3073">		MarkDirty(dirty);</a>
<a name="ln3074"> </a>
<a name="ln3075">	if (window-&gt;ServerWindow()-&gt;HasDirectFrameBufferAccess()) {</a>
<a name="ln3076">		window-&gt;ServerWindow()-&gt;HandleDirectConnection(</a>
<a name="ln3077">			B_DIRECT_START | B_BUFFER_RESET);</a>
<a name="ln3078">	}</a>
<a name="ln3079">}</a>
<a name="ln3080"> </a>
<a name="ln3081"> </a>
<a name="ln3082">/*!	Hides the window from the screen - it does this independently of the</a>
<a name="ln3083">	Window::IsHidden() state.</a>
<a name="ln3084">*/</a>
<a name="ln3085">void</a>
<a name="ln3086">Desktop::_HideWindow(Window* window)</a>
<a name="ln3087">{</a>
<a name="ln3088">	if (window-&gt;ServerWindow()-&gt;IsDirectlyAccessing())</a>
<a name="ln3089">		window-&gt;ServerWindow()-&gt;HandleDirectConnection(B_DIRECT_STOP);</a>
<a name="ln3090"> </a>
<a name="ln3091">	// after rebuilding the clipping,</a>
<a name="ln3092">	// this window will not have a visible</a>
<a name="ln3093">	// region anymore, so we need to remember</a>
<a name="ln3094">	// it now</a>
<a name="ln3095">	// (actually that's not true, since</a>
<a name="ln3096">	// hidden windows are excluded from the</a>
<a name="ln3097">	// clipping calculation, but anyways)</a>
<a name="ln3098">	BRegion dirty(window-&gt;VisibleRegion());</a>
<a name="ln3099"> </a>
<a name="ln3100">	BRegion background;</a>
<a name="ln3101">	_RebuildClippingForAllWindows(background);</a>
<a name="ln3102">	_SetBackground(background);</a>
<a name="ln3103">	_WindowChanged(window);</a>
<a name="ln3104"> </a>
<a name="ln3105">	MarkDirty(dirty);</a>
<a name="ln3106">}</a>
<a name="ln3107"> </a>
<a name="ln3108"> </a>
<a name="ln3109">/*!	Updates the workspaces of all subset windows with regard to the</a>
<a name="ln3110">	specifed window.</a>
<a name="ln3111">	If newIndex is not -1, it will move all subset windows that belong to</a>
<a name="ln3112">	the specifed window to the new workspace; this form is only called by</a>
<a name="ln3113">	SetWorkspace().</a>
<a name="ln3114">*/</a>
<a name="ln3115">void</a>
<a name="ln3116">Desktop::_UpdateSubsetWorkspaces(Window* window, int32 previousIndex,</a>
<a name="ln3117">	int32 newIndex)</a>
<a name="ln3118">{</a>
<a name="ln3119">	STRACE((&quot;_UpdateSubsetWorkspaces(window %p, %s)\n&quot;, window,</a>
<a name="ln3120">		window-&gt;Title()));</a>
<a name="ln3121"> </a>
<a name="ln3122">	// if the window is hidden, the subset windows are up-to-date already</a>
<a name="ln3123">	if (!window-&gt;IsNormal() || window-&gt;IsHidden())</a>
<a name="ln3124">		return;</a>
<a name="ln3125"> </a>
<a name="ln3126">	for (Window* subset = fSubsetWindows.FirstWindow(); subset != NULL;</a>
<a name="ln3127">			subset = subset-&gt;NextWindow(kSubsetList)) {</a>
<a name="ln3128">		if (subset-&gt;Feel() == B_MODAL_ALL_WINDOW_FEEL</a>
<a name="ln3129">			|| subset-&gt;Feel() == B_FLOATING_ALL_WINDOW_FEEL) {</a>
<a name="ln3130">			// These windows are always visible on all workspaces,</a>
<a name="ln3131">			// no need to update them.</a>
<a name="ln3132">			continue;</a>
<a name="ln3133">		}</a>
<a name="ln3134"> </a>
<a name="ln3135">		if (subset-&gt;IsFloating()) {</a>
<a name="ln3136">			// Floating windows are inserted and removed to the current</a>
<a name="ln3137">			// workspace as the need arises - they are not handled here</a>
<a name="ln3138">			// but in _UpdateFront()</a>
<a name="ln3139">			continue;</a>
<a name="ln3140">		}</a>
<a name="ln3141"> </a>
<a name="ln3142">		if (subset-&gt;HasInSubset(window)) {</a>
<a name="ln3143">			// adopt the workspace change</a>
<a name="ln3144">			SetWindowWorkspaces(subset, subset-&gt;SubsetWorkspaces());</a>
<a name="ln3145">		}</a>
<a name="ln3146">	}</a>
<a name="ln3147">}</a>
<a name="ln3148"> </a>
<a name="ln3149"> </a>
<a name="ln3150">/*!	\brief Adds or removes the window to or from the workspaces it's on.</a>
<a name="ln3151">*/</a>
<a name="ln3152">void</a>
<a name="ln3153">Desktop::_ChangeWindowWorkspaces(Window* window, uint32 oldWorkspaces,</a>
<a name="ln3154">	uint32 newWorkspaces)</a>
<a name="ln3155">{</a>
<a name="ln3156">	if (oldWorkspaces == newWorkspaces)</a>
<a name="ln3157">		return;</a>
<a name="ln3158"> </a>
<a name="ln3159">	// apply changes to the workspaces' window lists</a>
<a name="ln3160"> </a>
<a name="ln3161">	LockAllWindows();</a>
<a name="ln3162"> </a>
<a name="ln3163">	// NOTE: we bypass the anchor-mechanism by intention when switching</a>
<a name="ln3164">	// the workspace programmatically.</a>
<a name="ln3165"> </a>
<a name="ln3166">	for (int32 i = 0; i &lt; kMaxWorkspaces; i++) {</a>
<a name="ln3167">		if (workspace_in_workspaces(i, oldWorkspaces)) {</a>
<a name="ln3168">			// window is on this workspace, is it anymore?</a>
<a name="ln3169">			if (!workspace_in_workspaces(i, newWorkspaces)) {</a>
<a name="ln3170">				_Windows(i).RemoveWindow(window);</a>
<a name="ln3171">				if (fLastWorkspaceFocus[i] == window)</a>
<a name="ln3172">					fLastWorkspaceFocus[i] = NULL;</a>
<a name="ln3173"> </a>
<a name="ln3174">				if (i == CurrentWorkspace()) {</a>
<a name="ln3175">					// remove its appearance from the current workspace</a>
<a name="ln3176">					window-&gt;SetCurrentWorkspace(-1);</a>
<a name="ln3177"> </a>
<a name="ln3178">					if (!window-&gt;IsHidden())</a>
<a name="ln3179">						_HideWindow(window);</a>
<a name="ln3180">				}</a>
<a name="ln3181">			}</a>
<a name="ln3182">		} else {</a>
<a name="ln3183">			// window was not on this workspace, is it now?</a>
<a name="ln3184">			if (workspace_in_workspaces(i, newWorkspaces)) {</a>
<a name="ln3185">				_Windows(i).AddWindow(window,</a>
<a name="ln3186">					window-&gt;Frontmost(_Windows(i).FirstWindow(), i));</a>
<a name="ln3187"> </a>
<a name="ln3188">				if (i == CurrentWorkspace()) {</a>
<a name="ln3189">					// make the window visible in current workspace</a>
<a name="ln3190">					window-&gt;SetCurrentWorkspace(fCurrentWorkspace);</a>
<a name="ln3191"> </a>
<a name="ln3192">					if (!window-&gt;IsHidden()) {</a>
<a name="ln3193">						// This only affects other windows if this window has</a>
<a name="ln3194">						// floating or modal windows that need to be shown as</a>
<a name="ln3195">						// well</a>
<a name="ln3196">						// TODO: take care of this</a>
<a name="ln3197">						_ShowWindow(window, FrontWindow() == window);</a>
<a name="ln3198">					}</a>
<a name="ln3199">				}</a>
<a name="ln3200">			}</a>
<a name="ln3201">		}</a>
<a name="ln3202">	}</a>
<a name="ln3203"> </a>
<a name="ln3204">	// If the window is visible only on one workspace, we set it's current</a>
<a name="ln3205">	// position in that workspace (so that WorkspacesView will find us).</a>
<a name="ln3206">	int32 firstWorkspace = -1;</a>
<a name="ln3207">	for (int32 i = 0; i &lt; kMaxWorkspaces; i++) {</a>
<a name="ln3208">		if ((newWorkspaces &amp; (1L &lt;&lt; i)) != 0) {</a>
<a name="ln3209">			if (firstWorkspace != -1) {</a>
<a name="ln3210">				firstWorkspace = -1;</a>
<a name="ln3211">				break;</a>
<a name="ln3212">			}</a>
<a name="ln3213">			firstWorkspace = i;</a>
<a name="ln3214">		}</a>
<a name="ln3215">	}</a>
<a name="ln3216">	if (firstWorkspace &gt;= 0)</a>
<a name="ln3217">		window-&gt;Anchor(firstWorkspace).position = window-&gt;Frame().LeftTop();</a>
<a name="ln3218"> </a>
<a name="ln3219">	// take care about modals and floating windows</a>
<a name="ln3220">	_UpdateSubsetWorkspaces(window);</a>
<a name="ln3221"> </a>
<a name="ln3222">	NotifyWindowWorkspacesChanged(window, newWorkspaces);</a>
<a name="ln3223"> </a>
<a name="ln3224">	UnlockAllWindows();</a>
<a name="ln3225">}</a>
<a name="ln3226"> </a>
<a name="ln3227"> </a>
<a name="ln3228">void</a>
<a name="ln3229">Desktop::_BringWindowsToFront(WindowList&amp; windows, int32 list, bool wereVisible)</a>
<a name="ln3230">{</a>
<a name="ln3231">	// we don't need to redraw what is currently</a>
<a name="ln3232">	// visible of the window</a>
<a name="ln3233">	BRegion clean;</a>
<a name="ln3234"> </a>
<a name="ln3235">	for (Window* window = windows.FirstWindow(); window != NULL;</a>
<a name="ln3236">			window = window-&gt;NextWindow(list)) {</a>
<a name="ln3237">		if (wereVisible)</a>
<a name="ln3238">			clean.Include(&amp;window-&gt;VisibleRegion());</a>
<a name="ln3239"> </a>
<a name="ln3240">		CurrentWindows().AddWindow(window,</a>
<a name="ln3241">			window-&gt;Frontmost(CurrentWindows().FirstWindow(),</a>
<a name="ln3242">				fCurrentWorkspace));</a>
<a name="ln3243"> </a>
<a name="ln3244">		_WindowChanged(window);</a>
<a name="ln3245">	}</a>
<a name="ln3246"> </a>
<a name="ln3247">	BRegion dummy;</a>
<a name="ln3248">	_RebuildClippingForAllWindows(dummy);</a>
<a name="ln3249"> </a>
<a name="ln3250">	// redraw what became visible of the window(s)</a>
<a name="ln3251"> </a>
<a name="ln3252">	BRegion dirty;</a>
<a name="ln3253">	for (Window* window = windows.FirstWindow(); window != NULL;</a>
<a name="ln3254">			window = window-&gt;NextWindow(list)) {</a>
<a name="ln3255">		dirty.Include(&amp;window-&gt;VisibleRegion());</a>
<a name="ln3256">	}</a>
<a name="ln3257"> </a>
<a name="ln3258">	dirty.Exclude(&amp;clean);</a>
<a name="ln3259">	MarkDirty(dirty);</a>
<a name="ln3260"> </a>
<a name="ln3261">	_UpdateFront();</a>
<a name="ln3262"> </a>
<a name="ln3263">	if (windows.FirstWindow() == fBack || fBack == NULL)</a>
<a name="ln3264">		_UpdateBack();</a>
<a name="ln3265">}</a>
<a name="ln3266"> </a>
<a name="ln3267"> </a>
<a name="ln3268">/*!	Returns the last focussed non-hidden subset window belonging to the</a>
<a name="ln3269">	specified \a window.</a>
<a name="ln3270">*/</a>
<a name="ln3271">Window*</a>
<a name="ln3272">Desktop::_LastFocusSubsetWindow(Window* window)</a>
<a name="ln3273">{</a>
<a name="ln3274">	if (window == NULL)</a>
<a name="ln3275">		return NULL;</a>
<a name="ln3276"> </a>
<a name="ln3277">	for (Window* front = fFocusList.LastWindow(); front != NULL;</a>
<a name="ln3278">			front = front-&gt;PreviousWindow(kFocusList)) {</a>
<a name="ln3279">		if (front != window &amp;&amp; !front-&gt;IsHidden()</a>
<a name="ln3280">			&amp;&amp; window-&gt;HasInSubset(front))</a>
<a name="ln3281">			return front;</a>
<a name="ln3282">	}</a>
<a name="ln3283"> </a>
<a name="ln3284">	return NULL;</a>
<a name="ln3285">}</a>
<a name="ln3286"> </a>
<a name="ln3287"> </a>
<a name="ln3288">/*!	\brief Checks whether or not a fake mouse moved message needs to be sent</a>
<a name="ln3289">	to the previous mouse window.</a>
<a name="ln3290"> </a>
<a name="ln3291">	You need to have the all window lock held when calling this method.</a>
<a name="ln3292">*/</a>
<a name="ln3293">bool</a>
<a name="ln3294">Desktop::_CheckSendFakeMouseMoved(const Window* lastWindowUnderMouse)</a>
<a name="ln3295">{</a>
<a name="ln3296">	Window* window = WindowAt(fLastMousePosition);</a>
<a name="ln3297">	return window != lastWindowUnderMouse;</a>
<a name="ln3298">}</a>
<a name="ln3299"> </a>
<a name="ln3300"> </a>
<a name="ln3301">/*!	\brief Sends a fake B_MOUSE_MOVED event to the window under the mouse,</a>
<a name="ln3302">		and also updates the current view under the mouse.</a>
<a name="ln3303"> </a>
<a name="ln3304">	This has only to be done in case the view changed without mouse movement,</a>
<a name="ln3305">	ie. because of a workspace change, a closing window, or programmatic window</a>
<a name="ln3306">	movement.</a>
<a name="ln3307"> </a>
<a name="ln3308">	You must not have locked any windows when calling this method.</a>
<a name="ln3309">*/</a>
<a name="ln3310">void</a>
<a name="ln3311">Desktop::_SendFakeMouseMoved(Window* window)</a>
<a name="ln3312">{</a>
<a name="ln3313">	int32 viewToken = B_NULL_TOKEN;</a>
<a name="ln3314">	EventTarget* target = NULL;</a>
<a name="ln3315"> </a>
<a name="ln3316">	LockAllWindows();</a>
<a name="ln3317"> </a>
<a name="ln3318">	if (window == NULL)</a>
<a name="ln3319">		window = WindowAt(fLastMousePosition);</a>
<a name="ln3320"> </a>
<a name="ln3321">	if (window != NULL) {</a>
<a name="ln3322">		BMessage message;</a>
<a name="ln3323">		window-&gt;MouseMoved(&amp;message, fLastMousePosition, &amp;viewToken, true,</a>
<a name="ln3324">			true);</a>
<a name="ln3325"> </a>
<a name="ln3326">		if (viewToken != B_NULL_TOKEN)</a>
<a name="ln3327">			target = &amp;window-&gt;EventTarget();</a>
<a name="ln3328">	}</a>
<a name="ln3329"> </a>
<a name="ln3330">	if (viewToken != B_NULL_TOKEN)</a>
<a name="ln3331">		SetViewUnderMouse(window, viewToken);</a>
<a name="ln3332">	else {</a>
<a name="ln3333">		SetViewUnderMouse(NULL, B_NULL_TOKEN);</a>
<a name="ln3334">		SetCursor(NULL);</a>
<a name="ln3335">	}</a>
<a name="ln3336"> </a>
<a name="ln3337">	UnlockAllWindows();</a>
<a name="ln3338"> </a>
<a name="ln3339">	if (target != NULL)</a>
<a name="ln3340">		EventDispatcher().SendFakeMouseMoved(*target, viewToken);</a>
<a name="ln3341">}</a>
<a name="ln3342"> </a>
<a name="ln3343"> </a>
<a name="ln3344">Screen*</a>
<a name="ln3345">Desktop::_DetermineScreenFor(BRect frame)</a>
<a name="ln3346">{</a>
<a name="ln3347">	AutoReadLocker _(fScreenLock);</a>
<a name="ln3348"> </a>
<a name="ln3349">	// TODO: choose the screen depending on where most of the area is</a>
<a name="ln3350">	return fVirtualScreen.ScreenAt(0);</a>
<a name="ln3351">}</a>
<a name="ln3352"> </a>
<a name="ln3353"> </a>
<a name="ln3354">void</a>
<a name="ln3355">Desktop::_RebuildClippingForAllWindows(BRegion&amp; stillAvailableOnScreen)</a>
<a name="ln3356">{</a>
<a name="ln3357">	// the available region on screen starts with the entire screen area</a>
<a name="ln3358">	// each window on the screen will take a portion from that area</a>
<a name="ln3359"> </a>
<a name="ln3360">	// figure out what the entire screen area is</a>
<a name="ln3361">	stillAvailableOnScreen = fScreenRegion;</a>
<a name="ln3362"> </a>
<a name="ln3363">	// set clipping of each window</a>
<a name="ln3364">	for (Window* window = CurrentWindows().LastWindow(); window != NULL;</a>
<a name="ln3365">			window = window-&gt;PreviousWindow(fCurrentWorkspace)) {</a>
<a name="ln3366">		if (!window-&gt;IsHidden()) {</a>
<a name="ln3367">			window-&gt;SetClipping(&amp;stillAvailableOnScreen);</a>
<a name="ln3368">			window-&gt;SetScreen(_DetermineScreenFor(window-&gt;Frame()));</a>
<a name="ln3369"> </a>
<a name="ln3370">			if (window-&gt;ServerWindow()-&gt;IsDirectlyAccessing()) {</a>
<a name="ln3371">				window-&gt;ServerWindow()-&gt;HandleDirectConnection(</a>
<a name="ln3372">					B_DIRECT_MODIFY | B_CLIPPING_MODIFIED);</a>
<a name="ln3373">			}</a>
<a name="ln3374"> </a>
<a name="ln3375">			// that windows region is not available on screen anymore</a>
<a name="ln3376">			stillAvailableOnScreen.Exclude(&amp;window-&gt;VisibleRegion());</a>
<a name="ln3377">		}</a>
<a name="ln3378">	}</a>
<a name="ln3379">}</a>
<a name="ln3380"> </a>
<a name="ln3381"> </a>
<a name="ln3382">void</a>
<a name="ln3383">Desktop::_TriggerWindowRedrawing(BRegion&amp; newDirtyRegion)</a>
<a name="ln3384">{</a>
<a name="ln3385">	// send redraw messages to all windows intersecting the dirty region</a>
<a name="ln3386">	for (Window* window = CurrentWindows().LastWindow(); window != NULL;</a>
<a name="ln3387">			window = window-&gt;PreviousWindow(fCurrentWorkspace)) {</a>
<a name="ln3388">		if (!window-&gt;IsHidden()</a>
<a name="ln3389">			&amp;&amp; newDirtyRegion.Intersects(window-&gt;VisibleRegion().Frame()))</a>
<a name="ln3390">			window-&gt;ProcessDirtyRegion(newDirtyRegion);</a>
<a name="ln3391">	}</a>
<a name="ln3392">}</a>
<a name="ln3393"> </a>
<a name="ln3394"> </a>
<a name="ln3395">void</a>
<a name="ln3396">Desktop::_SetBackground(BRegion&amp; background)</a>
<a name="ln3397">{</a>
<a name="ln3398">	// NOTE: the drawing operation is caried out</a>
<a name="ln3399">	// in the clipping region rebuild, but it is</a>
<a name="ln3400">	// ok actually, because it also avoids trails on</a>
<a name="ln3401">	// moving windows</a>
<a name="ln3402"> </a>
<a name="ln3403">	// remember the region not covered by any windows</a>
<a name="ln3404">	// and redraw the dirty background</a>
<a name="ln3405">	BRegion dirtyBackground(background);</a>
<a name="ln3406">	dirtyBackground.Exclude(&amp;fBackgroundRegion);</a>
<a name="ln3407">	dirtyBackground.IntersectWith(&amp;background);</a>
<a name="ln3408">	fBackgroundRegion = background;</a>
<a name="ln3409">	if (dirtyBackground.Frame().IsValid()) {</a>
<a name="ln3410">		if (GetDrawingEngine()-&gt;LockParallelAccess()) {</a>
<a name="ln3411">			GetDrawingEngine()-&gt;FillRegion(dirtyBackground,</a>
<a name="ln3412">				fWorkspaces[fCurrentWorkspace].Color());</a>
<a name="ln3413"> </a>
<a name="ln3414">			GetDrawingEngine()-&gt;UnlockParallelAccess();</a>
<a name="ln3415">		}</a>
<a name="ln3416">	}</a>
<a name="ln3417">}</a>
<a name="ln3418"> </a>
<a name="ln3419"> </a>
<a name="ln3420">//!	The all window lock must be held when calling this function.</a>
<a name="ln3421">void</a>
<a name="ln3422">Desktop::RebuildAndRedrawAfterWindowChange(Window* changedWindow,</a>
<a name="ln3423">	BRegion&amp; dirty)</a>
<a name="ln3424">{</a>
<a name="ln3425">	ASSERT_MULTI_WRITE_LOCKED(fWindowLock);</a>
<a name="ln3426">	if (!changedWindow-&gt;IsVisible() || dirty.CountRects() == 0)</a>
<a name="ln3427">		return;</a>
<a name="ln3428"> </a>
<a name="ln3429">	// The following loop is pretty much a copy of</a>
<a name="ln3430">	// _RebuildClippingForAllWindows(), but will also</a>
<a name="ln3431">	// take care about restricting our dirty region.</a>
<a name="ln3432"> </a>
<a name="ln3433">	// figure out what the entire screen area is</a>
<a name="ln3434">	BRegion stillAvailableOnScreen(fScreenRegion);</a>
<a name="ln3435"> </a>
<a name="ln3436">	// set clipping of each window</a>
<a name="ln3437">	for (Window* window = CurrentWindows().LastWindow(); window != NULL;</a>
<a name="ln3438">			window = window-&gt;PreviousWindow(fCurrentWorkspace)) {</a>
<a name="ln3439">		if (!window-&gt;IsHidden()) {</a>
<a name="ln3440">			if (window == changedWindow)</a>
<a name="ln3441">				dirty.IntersectWith(&amp;stillAvailableOnScreen);</a>
<a name="ln3442"> </a>
<a name="ln3443">			window-&gt;SetClipping(&amp;stillAvailableOnScreen);</a>
<a name="ln3444">			window-&gt;SetScreen(_DetermineScreenFor(window-&gt;Frame()));</a>
<a name="ln3445"> </a>
<a name="ln3446">			if (window-&gt;ServerWindow()-&gt;IsDirectlyAccessing()) {</a>
<a name="ln3447">				window-&gt;ServerWindow()-&gt;HandleDirectConnection(</a>
<a name="ln3448">					B_DIRECT_MODIFY | B_CLIPPING_MODIFIED);</a>
<a name="ln3449">			}</a>
<a name="ln3450"> </a>
<a name="ln3451">			// that windows region is not available on screen anymore</a>
<a name="ln3452">			stillAvailableOnScreen.Exclude(&amp;window-&gt;VisibleRegion());</a>
<a name="ln3453">		}</a>
<a name="ln3454">	}</a>
<a name="ln3455"> </a>
<a name="ln3456">	_SetBackground(stillAvailableOnScreen);</a>
<a name="ln3457">	_WindowChanged(changedWindow);</a>
<a name="ln3458"> </a>
<a name="ln3459">	_TriggerWindowRedrawing(dirty);</a>
<a name="ln3460">}</a>
<a name="ln3461"> </a>
<a name="ln3462"> </a>
<a name="ln3463">//! Suspend all windows with direct access to the frame buffer</a>
<a name="ln3464">void</a>
<a name="ln3465">Desktop::_SuspendDirectFrameBufferAccess()</a>
<a name="ln3466">{</a>
<a name="ln3467">	ASSERT_MULTI_LOCKED(fWindowLock);</a>
<a name="ln3468"> </a>
<a name="ln3469">	for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln3470">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln3471">		if (window-&gt;ServerWindow()-&gt;IsDirectlyAccessing())</a>
<a name="ln3472">			window-&gt;ServerWindow()-&gt;HandleDirectConnection(B_DIRECT_STOP);</a>
<a name="ln3473">	}</a>
<a name="ln3474">}</a>
<a name="ln3475"> </a>
<a name="ln3476"> </a>
<a name="ln3477">//! Resume all windows with direct access to the frame buffer</a>
<a name="ln3478">void</a>
<a name="ln3479">Desktop::_ResumeDirectFrameBufferAccess()</a>
<a name="ln3480">{</a>
<a name="ln3481">	ASSERT_MULTI_LOCKED(fWindowLock);</a>
<a name="ln3482"> </a>
<a name="ln3483">	for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln3484">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln3485">		if (window-&gt;IsHidden() || !window-&gt;InWorkspace(fCurrentWorkspace))</a>
<a name="ln3486">			continue;</a>
<a name="ln3487"> </a>
<a name="ln3488">		if (window-&gt;ServerWindow()-&gt;HasDirectFrameBufferAccess()) {</a>
<a name="ln3489">			window-&gt;ServerWindow()-&gt;HandleDirectConnection(</a>
<a name="ln3490">				B_DIRECT_START | B_BUFFER_RESET, B_MODE_CHANGED);</a>
<a name="ln3491">		}</a>
<a name="ln3492">	}</a>
<a name="ln3493">}</a>
<a name="ln3494"> </a>
<a name="ln3495"> </a>
<a name="ln3496">void</a>
<a name="ln3497">Desktop::ScreenChanged(Screen* screen)</a>
<a name="ln3498">{</a>
<a name="ln3499">	AutoWriteLocker windowLocker(fWindowLock);</a>
<a name="ln3500"> </a>
<a name="ln3501">	AutoWriteLocker screenLocker(fScreenLock);</a>
<a name="ln3502">	screen-&gt;SetPreferredMode();</a>
<a name="ln3503">	screenLocker.Unlock();</a>
<a name="ln3504"> </a>
<a name="ln3505">	_ScreenChanged(screen);</a>
<a name="ln3506">}</a>
<a name="ln3507"> </a>
<a name="ln3508"> </a>
<a name="ln3509">void</a>
<a name="ln3510">Desktop::_ScreenChanged(Screen* screen)</a>
<a name="ln3511">{</a>
<a name="ln3512">	ASSERT_MULTI_WRITE_LOCKED(fWindowLock);</a>
<a name="ln3513"> </a>
<a name="ln3514">	// the entire screen is dirty, because we're actually</a>
<a name="ln3515">	// operating on an all new buffer in memory</a>
<a name="ln3516">	BRegion dirty(screen-&gt;Frame());</a>
<a name="ln3517"> </a>
<a name="ln3518">	// update our cached screen region</a>
<a name="ln3519">	fScreenRegion.Set(screen-&gt;Frame());</a>
<a name="ln3520">	gInputManager-&gt;UpdateScreenBounds(screen-&gt;Frame());</a>
<a name="ln3521"> </a>
<a name="ln3522">	BRegion background;</a>
<a name="ln3523">	_RebuildClippingForAllWindows(background);</a>
<a name="ln3524"> </a>
<a name="ln3525">	fBackgroundRegion.MakeEmpty();</a>
<a name="ln3526">		// makes sure that the complete background is redrawn</a>
<a name="ln3527">	_SetBackground(background);</a>
<a name="ln3528"> </a>
<a name="ln3529">	// figure out dirty region</a>
<a name="ln3530">	dirty.Exclude(&amp;background);</a>
<a name="ln3531">	_TriggerWindowRedrawing(dirty);</a>
<a name="ln3532"> </a>
<a name="ln3533">	// send B_SCREEN_CHANGED to windows on that screen</a>
<a name="ln3534">	BMessage update(B_SCREEN_CHANGED);</a>
<a name="ln3535">	update.AddInt64(&quot;when&quot;, real_time_clock_usecs());</a>
<a name="ln3536">	update.AddRect(&quot;frame&quot;, screen-&gt;Frame());</a>
<a name="ln3537">	update.AddInt32(&quot;mode&quot;, screen-&gt;ColorSpace());</a>
<a name="ln3538"> </a>
<a name="ln3539">	fVirtualScreen.UpdateFrame();</a>
<a name="ln3540"> </a>
<a name="ln3541">	for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln3542">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln3543">		if (window-&gt;Screen() == screen)</a>
<a name="ln3544">			window-&gt;ServerWindow()-&gt;ScreenChanged(&amp;update);</a>
<a name="ln3545">	}</a>
<a name="ln3546">}</a>
<a name="ln3547"> </a>
<a name="ln3548"> </a>
<a name="ln3549">/*!	\brief activate one of the app's windows.</a>
<a name="ln3550">*/</a>
<a name="ln3551">status_t</a>
<a name="ln3552">Desktop::_ActivateApp(team_id team)</a>
<a name="ln3553">{</a>
<a name="ln3554">	// search for an unhidden window in the current workspace</a>
<a name="ln3555"> </a>
<a name="ln3556">	AutoWriteLocker locker(fWindowLock);</a>
<a name="ln3557"> </a>
<a name="ln3558">	for (Window* window = CurrentWindows().LastWindow(); window != NULL;</a>
<a name="ln3559">			window = window-&gt;PreviousWindow(fCurrentWorkspace)) {</a>
<a name="ln3560">		if (!window-&gt;IsHidden() &amp;&amp; window-&gt;IsNormal()</a>
<a name="ln3561">			&amp;&amp; window-&gt;ServerWindow()-&gt;ClientTeam() == team) {</a>
<a name="ln3562">			ActivateWindow(window);</a>
<a name="ln3563">			return B_OK;</a>
<a name="ln3564">		}</a>
<a name="ln3565">	}</a>
<a name="ln3566"> </a>
<a name="ln3567">	// search for an unhidden window to give focus to</a>
<a name="ln3568"> </a>
<a name="ln3569">	for (Window* window = fAllWindows.FirstWindow(); window != NULL;</a>
<a name="ln3570">			window = window-&gt;NextWindow(kAllWindowList)) {</a>
<a name="ln3571">		// if window is a normal window of the team, and not hidden,</a>
<a name="ln3572">		// we've found our target</a>
<a name="ln3573">		if (!window-&gt;IsHidden() &amp;&amp; window-&gt;IsNormal()</a>
<a name="ln3574">			&amp;&amp; window-&gt;ServerWindow()-&gt;ClientTeam() == team) {</a>
<a name="ln3575">			ActivateWindow(window);</a>
<a name="ln3576">			return B_OK;</a>
<a name="ln3577">		}</a>
<a name="ln3578">	}</a>
<a name="ln3579"> </a>
<a name="ln3580">	// TODO: we cannot maximize minimized windows here (with the window lock</a>
<a name="ln3581">	// write locked). To work-around this, we could forward the request to</a>
<a name="ln3582">	// the ServerApp of this team - it maintains its own window list, and can</a>
<a name="ln3583">	// therefore call ActivateWindow() without holding the window lock.</a>
<a name="ln3584">	return B_BAD_VALUE;</a>
<a name="ln3585">}</a>
<a name="ln3586"> </a>
<a name="ln3587"> </a>
<a name="ln3588">void</a>
<a name="ln3589">Desktop::_SetCurrentWorkspaceConfiguration()</a>
<a name="ln3590">{</a>
<a name="ln3591">	ASSERT_MULTI_WRITE_LOCKED(fWindowLock);</a>
<a name="ln3592"> </a>
<a name="ln3593">	status_t status = fDirectScreenLock.LockWithTimeout(1000000L);</a>
<a name="ln3594">	if (status != B_OK) {</a>
<a name="ln3595">		// The application having the direct screen lock didn't give it up in</a>
<a name="ln3596">		// time, make it crash</a>
<a name="ln3597">		syslog(LOG_ERR, &quot;Team %&quot; B_PRId32 &quot; did not give up its direct screen &quot;</a>
<a name="ln3598">			&quot;lock.\n&quot;, fDirectScreenTeam);</a>
<a name="ln3599"> </a>
<a name="ln3600">		debug_thread(fDirectScreenTeam);</a>
<a name="ln3601">		fDirectScreenTeam = -1;</a>
<a name="ln3602">	} else</a>
<a name="ln3603">		fDirectScreenLock.Unlock();</a>
<a name="ln3604"> </a>
<a name="ln3605">	AutoWriteLocker _(fScreenLock);</a>
<a name="ln3606"> </a>
<a name="ln3607">	uint32 changedScreens;</a>
<a name="ln3608">	fVirtualScreen.SetConfiguration(*this,</a>
<a name="ln3609">		fWorkspaces[fCurrentWorkspace].CurrentScreenConfiguration(),</a>
<a name="ln3610">		&amp;changedScreens);</a>
<a name="ln3611"> </a>
<a name="ln3612">	for (int32 i = 0; changedScreens != 0; i++, changedScreens /= 2) {</a>
<a name="ln3613">		if ((changedScreens &amp; (1 &lt;&lt; i)) != 0)</a>
<a name="ln3614">			_ScreenChanged(fVirtualScreen.ScreenAt(i));</a>
<a name="ln3615">	}</a>
<a name="ln3616">}</a>
<a name="ln3617"> </a>
<a name="ln3618"> </a>
<a name="ln3619">/*!	Changes the current workspace to the one specified by \a index.</a>
<a name="ln3620">	You must hold the all window lock when calling this method.</a>
<a name="ln3621">*/</a>
<a name="ln3622">void</a>
<a name="ln3623">Desktop::_SetWorkspace(int32 index, bool moveFocusWindow)</a>
<a name="ln3624">{</a>
<a name="ln3625">	ASSERT_MULTI_WRITE_LOCKED(fWindowLock);</a>
<a name="ln3626"> </a>
<a name="ln3627">	int32 previousIndex = fCurrentWorkspace;</a>
<a name="ln3628">	rgb_color previousColor = fWorkspaces[fCurrentWorkspace].Color();</a>
<a name="ln3629">	bool movedMouseEventWindow = false;</a>
<a name="ln3630">	Window* movedWindow = NULL;</a>
<a name="ln3631">	if (moveFocusWindow) {</a>
<a name="ln3632">		if (fMouseEventWindow != NULL)</a>
<a name="ln3633">			movedWindow = fMouseEventWindow;</a>
<a name="ln3634">		else</a>
<a name="ln3635">			movedWindow = FocusWindow();</a>
<a name="ln3636">	}</a>
<a name="ln3637"> </a>
<a name="ln3638">	if (movedWindow != NULL) {</a>
<a name="ln3639">		if (movedWindow-&gt;IsNormal()) {</a>
<a name="ln3640">			if (!movedWindow-&gt;InWorkspace(index)) {</a>
<a name="ln3641">				// The window currently being dragged will follow us to this</a>
<a name="ln3642">				// workspace if it's not already on it.</a>
<a name="ln3643">				// But only normal windows are following</a>
<a name="ln3644">				uint32 oldWorkspaces = movedWindow-&gt;Workspaces();</a>
<a name="ln3645"> </a>
<a name="ln3646">				WindowStack* stack = movedWindow-&gt;GetWindowStack();</a>
<a name="ln3647">				if (stack != NULL) {</a>
<a name="ln3648">					for (int32 s = 0; s &lt; stack-&gt;CountWindows(); s++) {</a>
<a name="ln3649">						Window* stackWindow = stack-&gt;LayerOrder().ItemAt(s);</a>
<a name="ln3650"> </a>
<a name="ln3651">						_Windows(previousIndex).RemoveWindow(stackWindow);</a>
<a name="ln3652">						_Windows(index).AddWindow(stackWindow,</a>
<a name="ln3653">							stackWindow-&gt;Frontmost(</a>
<a name="ln3654">								_Windows(index).FirstWindow(), index));</a>
<a name="ln3655"> </a>
<a name="ln3656">						// send B_WORKSPACES_CHANGED message</a>
<a name="ln3657">						stackWindow-&gt;WorkspacesChanged(oldWorkspaces,</a>
<a name="ln3658">							stackWindow-&gt;Workspaces());</a>
<a name="ln3659">					}</a>
<a name="ln3660">				}</a>
<a name="ln3661">				// TODO: subset windows will always flicker this way</a>
<a name="ln3662"> </a>
<a name="ln3663">				movedMouseEventWindow = true;</a>
<a name="ln3664"> </a>
<a name="ln3665">				NotifyWindowWorkspacesChanged(movedWindow,</a>
<a name="ln3666">					movedWindow-&gt;Workspaces());</a>
<a name="ln3667">			} else {</a>
<a name="ln3668">				// make sure it's frontmost</a>
<a name="ln3669">				_Windows(index).RemoveWindow(movedWindow);</a>
<a name="ln3670">				_Windows(index).AddWindow(movedWindow,</a>
<a name="ln3671">					movedWindow-&gt;Frontmost(_Windows(index).FirstWindow(),</a>
<a name="ln3672">					index));</a>
<a name="ln3673">			}</a>
<a name="ln3674">		}</a>
<a name="ln3675"> </a>
<a name="ln3676">		movedWindow-&gt;Anchor(index).position = movedWindow-&gt;Frame().LeftTop();</a>
<a name="ln3677">	}</a>
<a name="ln3678"> </a>
<a name="ln3679">	if (movedWindow == NULL || movedWindow-&gt;InWorkspace(previousIndex))</a>
<a name="ln3680">		fLastWorkspaceFocus[previousIndex] = FocusWindow();</a>
<a name="ln3681">	else</a>
<a name="ln3682">		fLastWorkspaceFocus[previousIndex] = NULL;</a>
<a name="ln3683"> </a>
<a name="ln3684">	// build region of windows that are no longer visible in the new workspace</a>
<a name="ln3685"> </a>
<a name="ln3686">	BRegion dirty;</a>
<a name="ln3687"> </a>
<a name="ln3688">	for (Window* window = CurrentWindows().FirstWindow();</a>
<a name="ln3689">			window != NULL; window = window-&gt;NextWindow(previousIndex)) {</a>
<a name="ln3690">		// store current position in Workspace anchor</a>
<a name="ln3691">		window-&gt;Anchor(previousIndex).position = window-&gt;Frame().LeftTop();</a>
<a name="ln3692"> </a>
<a name="ln3693">		if (!window-&gt;IsHidden()</a>
<a name="ln3694">			&amp;&amp; window-&gt;ServerWindow()-&gt;IsDirectlyAccessing())</a>
<a name="ln3695">			window-&gt;ServerWindow()-&gt;HandleDirectConnection(B_DIRECT_STOP);</a>
<a name="ln3696"> </a>
<a name="ln3697">		window-&gt;WorkspaceActivated(previousIndex, false);</a>
<a name="ln3698"> </a>
<a name="ln3699">		if (window-&gt;InWorkspace(index))</a>
<a name="ln3700">			continue;</a>
<a name="ln3701"> </a>
<a name="ln3702">		if (!window-&gt;IsHidden()) {</a>
<a name="ln3703">			// this window will no longer be visible</a>
<a name="ln3704">			dirty.Include(&amp;window-&gt;VisibleRegion());</a>
<a name="ln3705">		}</a>
<a name="ln3706"> </a>
<a name="ln3707">		window-&gt;SetCurrentWorkspace(-1);</a>
<a name="ln3708">	}</a>
<a name="ln3709"> </a>
<a name="ln3710">	fPreviousWorkspace = fCurrentWorkspace;</a>
<a name="ln3711">	fCurrentWorkspace = index;</a>
<a name="ln3712"> </a>
<a name="ln3713">	// Change the display modes, if needed</a>
<a name="ln3714">	_SetCurrentWorkspaceConfiguration();</a>
<a name="ln3715"> </a>
<a name="ln3716">	// Show windows, and include them in the changed region - but only</a>
<a name="ln3717">	// those that were not visible before (or whose position changed)</a>
<a name="ln3718"> </a>
<a name="ln3719">	WindowList windows(kWorkingList);</a>
<a name="ln3720">	BList previousRegions;</a>
<a name="ln3721"> </a>
<a name="ln3722">	for (Window* window = _Windows(index).FirstWindow();</a>
<a name="ln3723">			window != NULL; window = window-&gt;NextWindow(index)) {</a>
<a name="ln3724">		BPoint position = window-&gt;Anchor(index).position;</a>
<a name="ln3725"> </a>
<a name="ln3726">		window-&gt;SetCurrentWorkspace(index);</a>
<a name="ln3727"> </a>
<a name="ln3728">		if (window-&gt;IsHidden())</a>
<a name="ln3729">			continue;</a>
<a name="ln3730"> </a>
<a name="ln3731">		if (position == kInvalidWindowPosition) {</a>
<a name="ln3732">			// if you enter a workspace for the first time, the position</a>
<a name="ln3733">			// of the window in the previous workspace is adopted</a>
<a name="ln3734">			position = window-&gt;Frame().LeftTop();</a>
<a name="ln3735">				// TODO: make sure the window is still on-screen if it</a>
<a name="ln3736">				//	was before!</a>
<a name="ln3737">		}</a>
<a name="ln3738"> </a>
<a name="ln3739">		if (!window-&gt;InWorkspace(previousIndex)) {</a>
<a name="ln3740">			// This window was not visible before, make sure its frame</a>
<a name="ln3741">			// is up-to-date</a>
<a name="ln3742">			if (window-&gt;Frame().LeftTop() != position) {</a>
<a name="ln3743">				BPoint offset = position - window-&gt;Frame().LeftTop();</a>
<a name="ln3744">				window-&gt;MoveBy((int32)offset.x, (int32)offset.y);</a>
<a name="ln3745">			}</a>
<a name="ln3746">			continue;</a>
<a name="ln3747">		}</a>
<a name="ln3748"> </a>
<a name="ln3749">		if (window-&gt;Frame().LeftTop() != position) {</a>
<a name="ln3750">			// the window was visible before, but its on-screen location changed</a>
<a name="ln3751">			BPoint offset = position - window-&gt;Frame().LeftTop();</a>
<a name="ln3752">			MoveWindowBy(window, offset.x, offset.y);</a>
<a name="ln3753">				// TODO: be a bit smarter than this...</a>
<a name="ln3754">		} else {</a>
<a name="ln3755">			// We need to remember the previous visible region of the</a>
<a name="ln3756">			// window if they changed their order</a>
<a name="ln3757">			BRegion* region = new (std::nothrow)</a>
<a name="ln3758">				BRegion(window-&gt;VisibleRegion());</a>
<a name="ln3759">			if (region != NULL) {</a>
<a name="ln3760">				if (previousRegions.AddItem(region))</a>
<a name="ln3761">					windows.AddWindow(window);</a>
<a name="ln3762">				else</a>
<a name="ln3763">					delete region;</a>
<a name="ln3764">			}</a>
<a name="ln3765">		}</a>
<a name="ln3766">	}</a>
<a name="ln3767"> </a>
<a name="ln3768">	_UpdateFronts(false);</a>
<a name="ln3769">	_UpdateFloating(previousIndex, index,</a>
<a name="ln3770">		movedMouseEventWindow ? movedWindow : NULL);</a>
<a name="ln3771"> </a>
<a name="ln3772">	BRegion stillAvailableOnScreen;</a>
<a name="ln3773">	_RebuildClippingForAllWindows(stillAvailableOnScreen);</a>
<a name="ln3774">	_SetBackground(stillAvailableOnScreen);</a>
<a name="ln3775"> </a>
<a name="ln3776">	for (Window* window = _Windows(index).FirstWindow(); window != NULL;</a>
<a name="ln3777">			window = window-&gt;NextWindow(index)) {</a>
<a name="ln3778">		// send B_WORKSPACE_ACTIVATED message</a>
<a name="ln3779">		window-&gt;WorkspaceActivated(index, true);</a>
<a name="ln3780"> </a>
<a name="ln3781">		if (!window-&gt;IsHidden()</a>
<a name="ln3782">			&amp;&amp; window-&gt;ServerWindow()-&gt;HasDirectFrameBufferAccess()) {</a>
<a name="ln3783">			window-&gt;ServerWindow()-&gt;HandleDirectConnection(</a>
<a name="ln3784">				B_DIRECT_START | B_BUFFER_RESET, B_MODE_CHANGED);</a>
<a name="ln3785">		}</a>
<a name="ln3786"> </a>
<a name="ln3787">		if (window-&gt;InWorkspace(previousIndex) || window-&gt;IsHidden()</a>
<a name="ln3788">			|| (window == movedWindow &amp;&amp; movedWindow-&gt;IsNormal())</a>
<a name="ln3789">			|| (!window-&gt;IsNormal()</a>
<a name="ln3790">				&amp;&amp; window-&gt;HasInSubset(movedWindow))) {</a>
<a name="ln3791">			// This window was visible before, and is already handled in the</a>
<a name="ln3792">			// above loop</a>
<a name="ln3793">			continue;</a>
<a name="ln3794">		}</a>
<a name="ln3795"> </a>
<a name="ln3796">		dirty.Include(&amp;window-&gt;VisibleRegion());</a>
<a name="ln3797">	}</a>
<a name="ln3798"> </a>
<a name="ln3799">	// Catch order changes in the new workspaces window list</a>
<a name="ln3800">	int32 i = 0;</a>
<a name="ln3801">	for (Window* window = windows.FirstWindow(); window != NULL;</a>
<a name="ln3802">			window = window-&gt;NextWindow(kWorkingList), i++) {</a>
<a name="ln3803">		BRegion* region = (BRegion*)previousRegions.ItemAt(i);</a>
<a name="ln3804">		region-&gt;ExclusiveInclude(&amp;window-&gt;VisibleRegion());</a>
<a name="ln3805">		dirty.Include(region);</a>
<a name="ln3806">		delete region;</a>
<a name="ln3807">	}</a>
<a name="ln3808"> </a>
<a name="ln3809">	// Set new focus, but keep focus to a floating window if still visible</a>
<a name="ln3810">	if (movedWindow != NULL)</a>
<a name="ln3811">		SetFocusWindow(movedWindow);</a>
<a name="ln3812">	else if (!_Windows(index).HasWindow(FocusWindow())</a>
<a name="ln3813">		|| (FocusWindow() != NULL &amp;&amp; !FocusWindow()-&gt;IsFloating()))</a>
<a name="ln3814">		SetFocusWindow(fLastWorkspaceFocus[index]);</a>
<a name="ln3815"> </a>
<a name="ln3816">	_WindowChanged(NULL);</a>
<a name="ln3817">	MarkDirty(dirty);</a>
<a name="ln3818"> </a>
<a name="ln3819">#if 0</a>
<a name="ln3820">	// Show the dirty regions of this workspace switch</a>
<a name="ln3821">	if (GetDrawingEngine()-&gt;LockParallelAccess()) {</a>
<a name="ln3822">		GetDrawingEngine()-&gt;FillRegion(dirty, (rgb_color){255, 0, 0});</a>
<a name="ln3823">		GetDrawingEngine()-&gt;UnlockParallelAccess();</a>
<a name="ln3824">		snooze(100000);</a>
<a name="ln3825">	}</a>
<a name="ln3826">#endif</a>
<a name="ln3827"> </a>
<a name="ln3828">	if (previousColor != fWorkspaces[fCurrentWorkspace].Color())</a>
<a name="ln3829">		RedrawBackground();</a>
<a name="ln3830">}</a>

</code></pre>
<div class="balloon" rel="214"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v646/" target="_blank">V646</a> Consider inspecting the application's logic. It's possible that 'else' keyword is missing.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
