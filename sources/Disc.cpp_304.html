
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Disc.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2003-2011, Haiku, Inc.</a>
<a name="ln3"> * Distributed under the terms of the MIT license.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Tyler Akidau, haiku@akidau.net</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">/*!	\file Disc.cpp</a>
<a name="ln11"> </a>
<a name="ln12">	Disc class implementation, used to enumerate the CD/DVD sessions.</a>
<a name="ln13"> </a>
<a name="ln14">	The protocols followed in this module are based on information</a>
<a name="ln15">	taken from the &quot;SCSI-3 Multimedia Commands&quot; draft, revision 10A.</a>
<a name="ln16"> </a>
<a name="ln17">	The SCSI command of interest is &quot;READ TOC/PMA/ATIP&quot;, command</a>
<a name="ln18">	number \c 0x43.</a>
<a name="ln19"> </a>
<a name="ln20">	The format of interest for said command is &quot;Full TOC&quot;, format</a>
<a name="ln21">	number \c 0x2.</a>
<a name="ln22">*/</a>
<a name="ln23"> </a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;Disc.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;DiskDeviceDefs.h&gt;</a>
<a name="ln28">#include &lt;DiskDeviceTypes.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;Debug.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">DBG(static const char* kModuleDebugName = &quot;session&quot;);</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">/*! \brief An item that can be stored in a List object.</a>
<a name="ln37">*/</a>
<a name="ln38">struct list_item {</a>
<a name="ln39">public:</a>
<a name="ln40">	list_item(uint32 index, list_item* next = NULL)</a>
<a name="ln41">		:</a>
<a name="ln42">		index(index),</a>
<a name="ln43">		next(next)</a>
<a name="ln44">	{</a>
<a name="ln45">	}</a>
<a name="ln46"> </a>
<a name="ln47">	int32		index;</a>
<a name="ln48">	list_item*	next;</a>
<a name="ln49">};</a>
<a name="ln50"> </a>
<a name="ln51"> </a>
<a name="ln52">/*! \brief A simple, singly linked list.</a>
<a name="ln53">*/</a>
<a name="ln54">class List {</a>
<a name="ln55">public:</a>
<a name="ln56">	List();</a>
<a name="ln57">	~List();</a>
<a name="ln58"> </a>
<a name="ln59">	list_item* Find(int32 index) const;</a>
<a name="ln60">	void Add(list_item* item);</a>
<a name="ln61">	void Clear();</a>
<a name="ln62">	void SortAndRemoveDuplicates();</a>
<a name="ln63"> </a>
<a name="ln64">	list_item* First() const;</a>
<a name="ln65">	list_item* Last() const;</a>
<a name="ln66"> </a>
<a name="ln67">private:</a>
<a name="ln68">	list_item*	fFirst;</a>
<a name="ln69">	list_item*	fLast;</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">/*! \brief Keeps track of track information.</a>
<a name="ln74">*/</a>
<a name="ln75">struct track : public list_item {</a>
<a name="ln76">public:</a>
<a name="ln77">	track(uint32 index, off_t startLBA, uint8 control, uint8 adr,</a>
<a name="ln78">			track* next = NULL)</a>
<a name="ln79">		:</a>
<a name="ln80">		list_item(index, next),</a>
<a name="ln81">		start_lba(startLBA),</a>
<a name="ln82">		control(control),</a>
<a name="ln83">		adr(adr)</a>
<a name="ln84">	{</a>
<a name="ln85">	}</a>
<a name="ln86"> </a>
<a name="ln87">	off_t	start_lba;</a>
<a name="ln88">	uint8	control;</a>
<a name="ln89">		// Used to check for Yellow/Red Book mixed-mode CDs.</a>
<a name="ln90">	uint8	adr;</a>
<a name="ln91">		// only used to give what are probably useless warnings</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">/*! \brief Keeps track of session information.</a>
<a name="ln96">*/</a>
<a name="ln97">struct session : public list_item {</a>
<a name="ln98">public:</a>
<a name="ln99">	session(uint32 index, session* next = NULL);</a>
<a name="ln100"> </a>
<a name="ln101">	bool first_track_hint_is_set();</a>
<a name="ln102">	bool last_track_hint_is_set();</a>
<a name="ln103">	bool end_lba_is_set();	// also implies control and adr are set</a>
<a name="ln104"> </a>
<a name="ln105">	bool is_audio();</a>
<a name="ln106"> </a>
<a name="ln107">	int8	first_track_hint;</a>
<a name="ln108">	int8	last_track_hint;</a>
<a name="ln109">	int8	control;</a>
<a name="ln110">	int8	adr;</a>
<a name="ln111">	off_t	end_lba;</a>
<a name="ln112"> </a>
<a name="ln113">	List	track_list;</a>
<a name="ln114">};</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">//	#pragma mark - Helper functions</a>
<a name="ln118"> </a>
<a name="ln119"> </a>
<a name="ln120">#ifdef DEBUG</a>
<a name="ln121">/*</a>
<a name="ln122">static void</a>
<a name="ln123">dump_scsi_command(raw_device_command* cmd)</a>
<a name="ln124">{</a>
<a name="ln125">	int i;</a>
<a name="ln126">	uint j;</a>
<a name="ln127">	scsi_table_of_contents_command* scsi_command</a>
<a name="ln128">		= (scsi_table_of_contents_command*)(&amp;(cmd-&gt;command));</a>
<a name="ln129"> </a>
<a name="ln130">	for (i = 0; i &lt; cmd-&gt;command_length; i++)</a>
<a name="ln131">		TRACE((&quot;%.2x,&quot;, cmd-&gt;command[i]));</a>
<a name="ln132">	TRACE((&quot;\n&quot;));</a>
<a name="ln133"> </a>
<a name="ln134">	TRACE((&quot;raw_device_command:\n&quot;));</a>
<a name="ln135">	TRACE((&quot;  command:\n&quot;));</a>
<a name="ln136">	TRACE((&quot;    command = %d (0x%.2x)\n&quot;, scsi_command-&gt;command,</a>
<a name="ln137">		scsi_command-&gt;command));</a>
<a name="ln138">	TRACE((&quot;    msf     = %d\n&quot;, scsi_command-&gt;msf));</a>
<a name="ln139">	TRACE((&quot;    format  = %d (0x%.2x)\n&quot;, scsi_command-&gt;format,</a>
<a name="ln140">		scsi_command-&gt;format));</a>
<a name="ln141">	TRACE((&quot;    number  = %d\n&quot;, scsi_command-&gt;number));</a>
<a name="ln142">	TRACE((&quot;    length  = %d\n&quot;,</a>
<a name="ln143">		B_BENDIAN_TO_HOST_INT16(scsi_command-&gt;length)));</a>
<a name="ln144">	TRACE((&quot;    control = %d\n&quot;, scsi_command-&gt;control));</a>
<a name="ln145">	TRACE((&quot;  command_length    = %d\n&quot;, cmd-&gt;command_length));</a>
<a name="ln146">	TRACE((&quot;  flags             = %d\n&quot;, cmd-&gt;flags));</a>
<a name="ln147">	TRACE((&quot;  scsi_status       = 0x%x\n&quot;, cmd-&gt;scsi_status));</a>
<a name="ln148">	TRACE((&quot;  cam_status        = 0x%x\n&quot;, cmd-&gt;cam_status));</a>
<a name="ln149">	TRACE((&quot;  data              = %p\n&quot;, cmd-&gt;data));</a>
<a name="ln150">	TRACE((&quot;  data_length       = %ld\n&quot;, cmd-&gt;data_length));</a>
<a name="ln151">	TRACE((&quot;  sense_data        = %p\n&quot;, cmd-&gt;sense_data));</a>
<a name="ln152">	TRACE((&quot;  sense_data_length = %ld\n&quot;, cmd-&gt;sense_data_length));</a>
<a name="ln153">	TRACE((&quot;  timeout           = %lld\n&quot;, cmd-&gt;timeout));</a>
<a name="ln154">	TRACE((&quot;data dump:\n&quot;));</a>
<a name="ln155">	for (j = 0; j &lt; 2048; j++) {//cmd-&gt;data_length; j++) {</a>
<a name="ln156">		uchar c = ((uchar*)cmd-&gt;data)[j];</a>
<a name="ln157"> </a>
<a name="ln158">		if (('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')</a>
<a name="ln159">			|| ('0' &lt;= c &amp;&amp; c &lt;= '9'))</a>
<a name="ln160">			TRACE((&quot;\\%c,&quot;, c));</a>
<a name="ln161">		else</a>
<a name="ln162">			TRACE((&quot;%.2x,&quot;, c));</a>
<a name="ln163">	}</a>
<a name="ln164">	TRACE((&quot;\n&quot;));</a>
<a name="ln165">	TRACE((&quot;sense_data dump:\n&quot;));</a>
<a name="ln166">	for (j = 0; j &lt; cmd-&gt;sense_data_length; j++) {</a>
<a name="ln167">		uchar c = ((uchar*)cmd-&gt;sense_data)[j];</a>
<a name="ln168">		if (('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z')</a>
<a name="ln169">			|| ('0' &lt;= c &amp;&amp; c &lt;= '9'))</a>
<a name="ln170">			TRACE((&quot;%c&quot;, c));</a>
<a name="ln171">		else if (c == 0)</a>
<a name="ln172">			TRACE((&quot;_&quot;));</a>
<a name="ln173">		else</a>
<a name="ln174">			TRACE((&quot;-&quot;));</a>
<a name="ln175">	}</a>
<a name="ln176">	TRACE((&quot;\n&quot;));</a>
<a name="ln177">}</a>
<a name="ln178">*/</a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">static void</a>
<a name="ln182">dump_full_table_of_contents(uchar* data, uint16 dataLength)</a>
<a name="ln183">{</a>
<a name="ln184">	cdrom_table_of_contents_header* header</a>
<a name="ln185">		= (cdrom_table_of_contents_header*)data;</a>
<a name="ln186">	cdrom_full_table_of_contents_entry* entries</a>
<a name="ln187">		= (cdrom_full_table_of_contents_entry*)(data + 4);</a>
<a name="ln188">	int headerLength = B_BENDIAN_TO_HOST_INT16(header-&gt;length);</a>
<a name="ln189"> </a>
<a name="ln190">	if (dataLength &lt; headerLength) {</a>
<a name="ln191">		TRACE((&quot;dump_full_table_of_contents: warning, data buffer not large &quot;</a>
<a name="ln192">			&quot;enough (%d &lt; %d)\n&quot;, dataLength, headerLength));</a>
<a name="ln193">		headerLength = dataLength;</a>
<a name="ln194">	}</a>
<a name="ln195"> </a>
<a name="ln196">	TRACE((&quot;%s: table of contents dump:\n&quot;, kModuleDebugName));</a>
<a name="ln197">	TRACE((&quot;--------------------------------------------------\n&quot;));</a>
<a name="ln198">	TRACE((&quot;header:\n&quot;));</a>
<a name="ln199">	TRACE((&quot;  length = %d\n&quot;, headerLength));</a>
<a name="ln200">	TRACE((&quot;  first  = %d\n&quot;, header-&gt;first));</a>
<a name="ln201">	TRACE((&quot;  last   = %d\n&quot;, header-&gt;last));</a>
<a name="ln202"> </a>
<a name="ln203">	int count = (headerLength - 2) / sizeof(cdrom_full_table_of_contents_entry);</a>
<a name="ln204">	TRACE((&quot;\n&quot;));</a>
<a name="ln205">	TRACE((&quot;entry count = %d\n&quot;, count));</a>
<a name="ln206"> </a>
<a name="ln207">	for (int i = 0; i &lt; count; i++) {</a>
<a name="ln208">		TRACE((&quot;\n&quot;));</a>
<a name="ln209">		TRACE((&quot;entry #%d:\n&quot;, i));</a>
<a name="ln210">		TRACE((&quot;  session  = %d\n&quot;, entries[i].session));</a>
<a name="ln211">		TRACE((&quot;  adr      = %d\n&quot;, entries[i].adr));</a>
<a name="ln212">		TRACE((&quot;  control  = %d (%s track, copy %s)\n&quot;, entries[i].control,</a>
<a name="ln213">			(entries[i].control &amp; kControlDataTrack ? &quot;data&quot; : &quot;audio&quot;),</a>
<a name="ln214">			(entries[i].control &amp; kControlCopyPermitted</a>
<a name="ln215">				? &quot;permitted&quot; : &quot;prohibited&quot;)));</a>
<a name="ln216">		TRACE((&quot;  tno      = %d\n&quot;, entries[i].tno));</a>
<a name="ln217">		TRACE((&quot;  point    = %d (0x%.2x)\n&quot;, entries[i].point,</a>
<a name="ln218">			entries[i].point));</a>
<a name="ln219">		TRACE((&quot;  minutes  = %d\n&quot;, entries[i].minutes));</a>
<a name="ln220">		TRACE((&quot;  frames   = %d\n&quot;, entries[i].seconds));</a>
<a name="ln221">		TRACE((&quot;  seconds  = %d\n&quot;, entries[i].frames));</a>
<a name="ln222">		TRACE((&quot;  zero     = %d\n&quot;, entries[i].zero));</a>
<a name="ln223">		TRACE((&quot;  pminutes = %d\n&quot;, entries[i].pminutes));</a>
<a name="ln224">		TRACE((&quot;  pseconds = %d\n&quot;, entries[i].pseconds));</a>
<a name="ln225">		TRACE((&quot;  pframes  = %d\n&quot;, entries[i].pframes));</a>
<a name="ln226">		TRACE((&quot;  lba      = %&quot; B_PRId64 &quot;\n&quot;,</a>
<a name="ln227">			msf_to_lba(make_msf_address(entries[i].pminutes,</a>
<a name="ln228">			entries[i].pseconds, entries[i].pframes))));</a>
<a name="ln229">	}</a>
<a name="ln230">	TRACE((&quot;--------------------------------------------------\n&quot;));</a>
<a name="ln231">}</a>
<a name="ln232">#endif	// DEBUG</a>
<a name="ln233"> </a>
<a name="ln234"> </a>
<a name="ln235">static status_t</a>
<a name="ln236">read_table_of_contents(int deviceFD, uint32 first_session, uchar* buffer,</a>
<a name="ln237">	uint16 buffer_length, bool msf)</a>
<a name="ln238">{</a>
<a name="ln239">	scsi_table_of_contents_command scsi_command;</a>
<a name="ln240">	raw_device_command raw_command;</a>
<a name="ln241">	const uint32 sense_data_length = 1024;</a>
<a name="ln242">	uchar sense_data[sense_data_length];</a>
<a name="ln243">	status_t error = buffer ? B_OK : B_BAD_VALUE;</a>
<a name="ln244"> </a>
<a name="ln245">	DEBUG_INIT_ETC(NULL, (&quot;fd: %d, buffer: %p, buffer_length: %d&quot;,</a>
<a name="ln246">		deviceFD, buffer, buffer_length));</a>
<a name="ln247"> </a>
<a name="ln248">	if (error)</a>
<a name="ln249">		return error;</a>
<a name="ln250"> </a>
<a name="ln251">	// This does not always work on the first try, so do it twice just in case.</a>
<a name="ln252">	for (int attempt = 0; attempt &lt; 2; attempt++) {</a>
<a name="ln253">		// Init the scsi command and copy it into the &quot;raw scsi command&quot;</a>
<a name="ln254">		// ioctl struct</a>
<a name="ln255">		memset(raw_command.command, 0, 16);</a>
<a name="ln256">		scsi_command.command = 0x43;</a>
<a name="ln257">		scsi_command.msf = 1;</a>
<a name="ln258">		scsi_command.format = kFullTableOfContentsFormat;</a>
<a name="ln259">		scsi_command.number = first_session;</a>
<a name="ln260">		scsi_command.length = B_HOST_TO_BENDIAN_INT16(buffer_length);</a>
<a name="ln261">		scsi_command.control = 0;</a>
<a name="ln262">		scsi_command.reserved0 = scsi_command.reserved1 = scsi_command.reserved2</a>
<a name="ln263">			= scsi_command.reserved3 = scsi_command.reserved4</a>
<a name="ln264">			= scsi_command.reserved5 = scsi_command.reserved6 = 0;</a>
<a name="ln265">		memcpy(raw_command.command, &amp;scsi_command, sizeof(scsi_command));</a>
<a name="ln266"> </a>
<a name="ln267">		// Init the rest of the raw command</a>
<a name="ln268">		raw_command.command_length = 10;</a>
<a name="ln269">		raw_command.flags = kScsiFlags;</a>
<a name="ln270">		raw_command.scsi_status = 0;</a>
<a name="ln271">		raw_command.cam_status = 0;</a>
<a name="ln272">		raw_command.data = buffer;</a>
<a name="ln273">		raw_command.data_length = buffer_length;</a>
<a name="ln274">		memset(raw_command.data, 0, raw_command.data_length);</a>
<a name="ln275">		raw_command.sense_data = sense_data;</a>
<a name="ln276">		raw_command.sense_data_length = sense_data_length;</a>
<a name="ln277">		memset(raw_command.sense_data, 0, raw_command.sense_data_length);</a>
<a name="ln278">		raw_command.timeout = kScsiTimeout;</a>
<a name="ln279"> </a>
<a name="ln280">		if (ioctl(deviceFD, B_RAW_DEVICE_COMMAND, &amp;raw_command) == 0) {</a>
<a name="ln281">			if (raw_command.scsi_status == 0 &amp;&amp; raw_command.cam_status == 1) {</a>
<a name="ln282">				// SUCCESS!!!</a>
<a name="ln283">				DBG(dump_full_table_of_contents(buffer, buffer_length));</a>
<a name="ln284">				return B_OK;</a>
<a name="ln285">			} else {</a>
<a name="ln286">				error = B_FILE_ERROR;</a>
<a name="ln287">				TRACE((&quot;%s: scsi ioctl succeeded, but scsi command failed\n&quot;,</a>
<a name="ln288">					kModuleDebugName));</a>
<a name="ln289">			}</a>
<a name="ln290">		} else {</a>
<a name="ln291">			error = errno;</a>
<a name="ln292">			TRACE((&quot;%s: scsi command failed with error 0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln293">				kModuleDebugName, error));</a>
<a name="ln294">		}</a>
<a name="ln295">	}</a>
<a name="ln296"> </a>
<a name="ln297">	return error;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301">//	#pragma mark - List</a>
<a name="ln302">// TODO: get rid of this, and use the standard DoublyLinkedList</a>
<a name="ln303"> </a>
<a name="ln304"> </a>
<a name="ln305">/*! \brief Creates an empty list.</a>
<a name="ln306">*/</a>
<a name="ln307">List::List()</a>
<a name="ln308">	:</a>
<a name="ln309">	fFirst(NULL),</a>
<a name="ln310">	fLast(NULL)</a>
<a name="ln311">{</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314"> </a>
<a name="ln315">List::~List()</a>
<a name="ln316">{</a>
<a name="ln317">	Clear();</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">/*! \brief Returns the ListItem with the given index, or NULL if not found.</a>
<a name="ln322">*/</a>
<a name="ln323">list_item*</a>
<a name="ln324">List::Find(int32 index) const</a>
<a name="ln325">{</a>
<a name="ln326">//	TRACE((&quot;%s: List::Find(%ld)\n&quot;, kModuleDebugName, index));</a>
<a name="ln327">	list_item* item = fFirst;</a>
<a name="ln328">	while (item &amp;&amp; item-&gt;index != index) {</a>
<a name="ln329">		item = item-&gt;next;</a>
<a name="ln330">	}</a>
<a name="ln331">	return item;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">/*! \brief Adds the given item to the end of the list.</a>
<a name="ln336"> </a>
<a name="ln337">	\param item The item to add (may not be NULL)</a>
<a name="ln338">*/</a>
<a name="ln339">void</a>
<a name="ln340">List::Add(list_item* item)</a>
<a name="ln341">{</a>
<a name="ln342">//	TRACE((&quot;%s: List::Add(%p)\n&quot;, kModuleDebugName, item));</a>
<a name="ln343">	if (item) {</a>
<a name="ln344">		item-&gt;next = NULL;</a>
<a name="ln345">		if (fLast) {</a>
<a name="ln346">			fLast-&gt;next = item;</a>
<a name="ln347">			fLast = item;</a>
<a name="ln348">		} else {</a>
<a name="ln349">			fFirst = fLast = item;</a>
<a name="ln350">		}</a>
<a name="ln351">	} else {</a>
<a name="ln352">		TRACE((&quot;%s: List::Add(): NULL item parameter\n&quot;, kModuleDebugName));</a>
<a name="ln353">	}</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356"> </a>
<a name="ln357">/*! \brief Clears the list.</a>
<a name="ln358">*/</a>
<a name="ln359">void</a>
<a name="ln360">List::Clear()</a>
<a name="ln361">{</a>
<a name="ln362">	list_item* item = fFirst;</a>
<a name="ln363">	while (item) {</a>
<a name="ln364">		list_item* next = item-&gt;next;</a>
<a name="ln365">		delete item;</a>
<a name="ln366">		item = next;</a>
<a name="ln367">	}</a>
<a name="ln368">	fFirst = fLast = NULL;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371"> </a>
<a name="ln372">/*! \brief Bubble sorts the list by index, removing any duplicates</a>
<a name="ln373">	(the first instance is kept).</a>
<a name="ln374"> </a>
<a name="ln375">	\todo I believe duplicate removal is actually unnecessary, but</a>
<a name="ln376">		I need to verify that.</a>
<a name="ln377">*/</a>
<a name="ln378">void</a>
<a name="ln379">List::SortAndRemoveDuplicates()</a>
<a name="ln380">{</a>
<a name="ln381">	bool sorted = false;</a>
<a name="ln382">	while (!sorted) {</a>
<a name="ln383">		sorted = true;</a>
<a name="ln384"> </a>
<a name="ln385">		list_item* prev = NULL;</a>
<a name="ln386">		list_item* item = fFirst;</a>
<a name="ln387">		list_item* next = NULL;</a>
<a name="ln388">		while (item &amp;&amp; item-&gt;next) {</a>
<a name="ln389">			next = item-&gt;next;</a>
<a name="ln390">//			dprintf(&quot;List::Sort: %ld -&gt; %ld\n&quot;, item-&gt;index, next-&gt;index);</a>
<a name="ln391">			if (item-&gt;index &gt; next-&gt;index) {</a>
<a name="ln392">				sorted = false;</a>
<a name="ln393"> </a>
<a name="ln394">				// Keep fLast up to date</a>
<a name="ln395">				if (next == fLast)</a>
<a name="ln396">					fLast = item;</a>
<a name="ln397"> </a>
<a name="ln398">				// Swap</a>
<a name="ln399">				if (prev) {</a>
<a name="ln400">					// item is not fFirst</a>
<a name="ln401">					prev-&gt;next = next;</a>
<a name="ln402">					item-&gt;next = next-&gt;next;</a>
<a name="ln403">					next-&gt;next = item;</a>
<a name="ln404">				} else {</a>
<a name="ln405">					// item must be fFirst</a>
<a name="ln406">					fFirst = next;</a>
<a name="ln407">					item-&gt;next = next-&gt;next;</a>
<a name="ln408">					next-&gt;next = item;</a>
<a name="ln409">				}</a>
<a name="ln410">			} else if (item-&gt;index == next-&gt;index) {</a>
<a name="ln411">				// Duplicate indicies</a>
<a name="ln412">				TRACE((&quot;%s: List::SortAndRemoveDuplicates: duplicate indicies &quot;</a>
<a name="ln413">					&quot;found (#%&quot; B_PRId32 &quot;); keeping first instance\n&quot;,</a>
<a name="ln414">					kModuleDebugName, item-&gt;index));</a>
<a name="ln415">				item-&gt;next = next-&gt;next;</a>
<a name="ln416">				delete next;</a>
<a name="ln417">				next = item-&gt;next;</a>
<a name="ln418">				continue;</a>
<a name="ln419">			}</a>
<a name="ln420">			prev = item;</a>
<a name="ln421">			item = next;</a>
<a name="ln422">		}</a>
<a name="ln423">	}</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426"> </a>
<a name="ln427">/*! \brief Returns the first item in the list, or NULL if empty</a>
<a name="ln428">*/</a>
<a name="ln429">list_item*</a>
<a name="ln430">List::First() const</a>
<a name="ln431">{</a>
<a name="ln432">	return fFirst;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435"> </a>
<a name="ln436">/*! \brief Returns the last item in the list, or NULL if empty</a>
<a name="ln437">*/</a>
<a name="ln438">list_item*</a>
<a name="ln439">List::Last() const</a>
<a name="ln440">{</a>
<a name="ln441">	return fLast;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">//	#pragma mark - session</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">/*! \brief Creates an unitialized session object</a>
<a name="ln449">*/</a>
<a name="ln450">session::session(uint32 index, session* next)</a>
<a name="ln451">	:</a>
<a name="ln452">	list_item(index, next),</a>
<a name="ln453">	first_track_hint(-1),</a>
<a name="ln454">	last_track_hint(-1),</a>
<a name="ln455">	control(-1),</a>
<a name="ln456">	adr(-1),</a>
<a name="ln457">	end_lba(0)</a>
<a name="ln458">{</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461"> </a>
<a name="ln462">/*! \brief Returns true if the \a first_track_hint member has not been</a>
<a name="ln463">	set to a legal value yet.</a>
<a name="ln464">*/</a>
<a name="ln465">bool</a>
<a name="ln466">session::first_track_hint_is_set()</a>
<a name="ln467">{</a>
<a name="ln468">	return 1 &lt;= first_track_hint &amp;&amp; first_track_hint &lt;= 99;</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">/*! \brief Returns true if the \a last_track_hint member has not been</a>
<a name="ln473">	set to a legal value yet.</a>
<a name="ln474">*/</a>
<a name="ln475">bool</a>
<a name="ln476">session::last_track_hint_is_set()</a>
<a name="ln477">{</a>
<a name="ln478">	return 1 &lt;= last_track_hint &amp;&amp; last_track_hint &lt;= 99;</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481"> </a>
<a name="ln482">/*! \brief Returns true if the \a end_lba member has not been</a>
<a name="ln483">	set to a legal value yet.</a>
<a name="ln484"> </a>
<a name="ln485">	The result of this function also signals that the \a control</a>
<a name="ln486">	and \a adr members have or have not been set, since they are</a>
<a name="ln487">	set at the same time as \a end_lba.</a>
<a name="ln488">*/</a>
<a name="ln489">bool</a>
<a name="ln490">session::end_lba_is_set()</a>
<a name="ln491">{</a>
<a name="ln492">	return end_lba &gt; 0;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495"> </a>
<a name="ln496">/*! \brief Returns true if the session is flagged as being audio.</a>
<a name="ln497"> </a>
<a name="ln498">	If the \c control value for the session has not been set, returns</a>
<a name="ln499">	false.</a>
<a name="ln500">*/</a>
<a name="ln501">bool</a>
<a name="ln502">session::is_audio()</a>
<a name="ln503">{</a>
<a name="ln504">	return end_lba_is_set() &amp;&amp; !(control &amp; kControlDataTrack);</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507"> </a>
<a name="ln508">//	#pragma mark - Disc</a>
<a name="ln509"> </a>
<a name="ln510"> </a>
<a name="ln511">/*! \brief Creates a new Disc object by parsing the given table of contents</a>
<a name="ln512">	entries and checking the resultant data structure for errors and</a>
<a name="ln513">	warnings.</a>
<a name="ln514"> </a>
<a name="ln515">	If successful, subsequent calls to InitCheck() will return \c B_OK,</a>
<a name="ln516">	elsewise they will return an error code.</a>
<a name="ln517">*/</a>
<a name="ln518">Disc::Disc(int fd)</a>
<a name="ln519">	:</a>
<a name="ln520">	fInitStatus(B_NO_INIT),</a>
<a name="ln521">	fSessionList(new List)</a>
<a name="ln522">{</a>
<a name="ln523">	DEBUG_INIT_ETC(&quot;Disc&quot;, (&quot;fd: %d&quot;, fd));</a>
<a name="ln524"> </a>
<a name="ln525">	uchar data[kBlockSize];</a>
<a name="ln526">/*</a>
<a name="ln527">	if (!error)</a>
<a name="ln528">		error = sessionInfo &amp;&amp; index &gt;= 0 ? B_OK : B_BAD_VALUE;</a>
<a name="ln529">	int32 session = index+1;</a>
<a name="ln530">		// Check for a valid session index</a>
<a name="ln531">		if (session &lt; 1 || session &gt; 99)</a>
<a name="ln532">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln533">*/</a>
<a name="ln534"> </a>
<a name="ln535">	status_t error = fSessionList ? B_OK : B_NO_MEMORY;</a>
<a name="ln536"> </a>
<a name="ln537">	// Attempt to read the table of contents, first in lba mode, then in msf</a>
<a name="ln538">	// mode</a>
<a name="ln539">	if (!error)</a>
<a name="ln540">		error = read_table_of_contents(fd, 1, data, kBlockSize, false);</a>
<a name="ln541">	if (error) {</a>
<a name="ln542">		TRACE((&quot;%s: lba read_toc failed, trying msf instead\n&quot;,</a>
<a name="ln543">			kModuleDebugName));</a>
<a name="ln544">		error = read_table_of_contents(fd, 1, data, kBlockSize, true);</a>
<a name="ln545">	}</a>
<a name="ln546"> </a>
<a name="ln547">	// Interpret the data returned, if successful</a>
<a name="ln548">	if (!error) {</a>
<a name="ln549">		cdrom_table_of_contents_header* header;</a>
<a name="ln550">		cdrom_full_table_of_contents_entry* entries;</a>
<a name="ln551">		int count;</a>
<a name="ln552"> </a>
<a name="ln553">		header = (cdrom_table_of_contents_header*)data;</a>
<a name="ln554">		entries = (cdrom_full_table_of_contents_entry*)(data + 4);</a>
<a name="ln555">		header-&gt;length = B_BENDIAN_TO_HOST_INT16(header-&gt;length);</a>
<a name="ln556"> </a>
<a name="ln557">		count = (header-&gt;length - 2)</a>
<a name="ln558">			/ sizeof(cdrom_full_table_of_contents_entry);</a>
<a name="ln559"> </a>
<a name="ln560">		count = _AdjustForYellowBook(entries, count);</a>
<a name="ln561">		error = _ParseTableOfContents(entries, count);</a>
<a name="ln562">//		Dump();</a>
<a name="ln563">		if (!error) {</a>
<a name="ln564">			_SortAndRemoveDuplicates();</a>
<a name="ln565">			error = _CheckForErrorsAndWarnings();</a>
<a name="ln566">		}</a>
<a name="ln567">	}</a>
<a name="ln568"> </a>
<a name="ln569">	PRINT((&quot;Setting init status to 0x%&quot; B_PRIx32 &quot;, `%s'\n&quot;, error,</a>
<a name="ln570">		strerror(error)));</a>
<a name="ln571">	fInitStatus = error;</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574"> </a>
<a name="ln575">/*! \brief Destroys the Disc's internal list.</a>
<a name="ln576">*/</a>
<a name="ln577">Disc::~Disc()</a>
<a name="ln578">{</a>
<a name="ln579">	delete fSessionList;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582"> </a>
<a name="ln583">/*! \brief Returns \c B_OK if the object was successfully initialized, or</a>
<a name="ln584">	an error code if not.</a>
<a name="ln585">*/</a>
<a name="ln586">status_t</a>
<a name="ln587">Disc::InitCheck()</a>
<a name="ln588">{</a>
<a name="ln589">	return fInitStatus;</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592"> </a>
<a name="ln593">/*! \brief Stores the info for the given session (using 0 based indicies) in the</a>
<a name="ln594">	struct pointed to by \a sessionInfo.</a>
<a name="ln595"> </a>
<a name="ln596">	Returns \c B_ENTRY_NOT_FOUND if no such session exists.</a>
<a name="ln597">*/</a>
<a name="ln598">Session*</a>
<a name="ln599">Disc::GetSession(int32 index)</a>
<a name="ln600">{</a>
<a name="ln601">	DEBUG_INIT_ETC(&quot;Disc&quot;, (&quot;index: %&quot; B_PRId32, index));</a>
<a name="ln602">	int32 counter = -1;</a>
<a name="ln603">	for (session* session = (struct session*)fSessionList-&gt;First(); session;</a>
<a name="ln604">			session = (struct session*)session-&gt;next) {</a>
<a name="ln605">		if (session-&gt;is_audio()) {</a>
<a name="ln606">			counter++;</a>
<a name="ln607">				// only one session per audio session</a>
<a name="ln608">			if (counter == index) {</a>
<a name="ln609">				// Found an audio session. Take the start of the first</a>
<a name="ln610">				// track with the end of session.</a>
<a name="ln611">				track* track = (struct track*)session-&gt;track_list.First();</a>
<a name="ln612">				if (track != NULL) {</a>
<a name="ln613">					PRINT((&quot;found session #%&quot; B_PRId32 &quot; info (audio session)&quot;</a>
<a name="ln614">							&quot;\n&quot;, index));</a>
<a name="ln615"> </a>
<a name="ln616">					off_t startLBA = track-&gt;start_lba;</a>
<a name="ln617">					off_t endLBA = session-&gt;end_lba;</a>
<a name="ln618"> </a>
<a name="ln619">					off_t offset = startLBA * kBlockSize;</a>
<a name="ln620">					off_t size = (endLBA - startLBA) * kBlockSize;</a>
<a name="ln621"> </a>
<a name="ln622">					Session* result = new Session(offset, size, kBlockSize,</a>
<a name="ln623">						index, B_PARTITION_READ_ONLY,</a>
<a name="ln624">						kPartitionTypeAudioSession);</a>
<a name="ln625">					if (result == NULL) {</a>
<a name="ln626">						PRINT((&quot;Error allocating new Session object; out of &quot;</a>
<a name="ln627">							&quot;memory!\n&quot;));</a>
<a name="ln628">					}</a>
<a name="ln629">					return result;</a>
<a name="ln630">				} else {</a>
<a name="ln631">					PRINT((&quot;Error: session #%&quot; B_PRId32 &quot; is an audio session &quot;</a>
<a name="ln632">						&quot;with no tracks!\n&quot;, index));</a>
<a name="ln633">					return NULL;</a>
<a name="ln634">				}</a>
<a name="ln635">			}</a>
<a name="ln636">		} else {</a>
<a name="ln637">			for (track* track = (struct track*)session-&gt;track_list.First();</a>
<a name="ln638">					track; track = (struct track*)track-&gt;next) {</a>
<a name="ln639">				counter++;</a>
<a name="ln640">				if (counter == index) {</a>
<a name="ln641">					PRINT((&quot;found session #%&quot; B_PRId32 &quot; info (data session)\n&quot;,</a>
<a name="ln642">						index));</a>
<a name="ln643"> </a>
<a name="ln644">					off_t startLBA = track-&gt;start_lba;</a>
<a name="ln645">					if (startLBA &lt; 0) {</a>
<a name="ln646">						WARN((&quot;%s: warning: invalid negative start LBA of %&quot;</a>
<a name="ln647">							B_PRId64 &quot; for data track assuming 0\n&quot;,</a>
<a name="ln648">							kModuleDebugName, startLBA));</a>
<a name="ln649">						startLBA = 0;</a>
<a name="ln650">					}</a>
<a name="ln651"> </a>
<a name="ln652">					off_t endLBA = track-&gt;next</a>
<a name="ln653">						? ((struct track*)track-&gt;next)-&gt;start_lba</a>
<a name="ln654">						: session-&gt;end_lba;</a>
<a name="ln655"> </a>
<a name="ln656">					off_t offset = startLBA * kBlockSize;</a>
<a name="ln657">					off_t size = (endLBA - startLBA) * kBlockSize;</a>
<a name="ln658"> </a>
<a name="ln659">					Session* result = new Session(offset, size, kBlockSize,</a>
<a name="ln660">						index, B_PARTITION_READ_ONLY,</a>
<a name="ln661">						kPartitionTypeDataSession);</a>
<a name="ln662">					if (result == NULL) {</a>
<a name="ln663">						PRINT((&quot;Error allocating new Session object; out of &quot;</a>
<a name="ln664">							&quot;memory!\n&quot;));</a>
<a name="ln665">					}</a>
<a name="ln666">					return result;</a>
<a name="ln667">				}</a>
<a name="ln668">			}</a>
<a name="ln669">		}</a>
<a name="ln670">	}</a>
<a name="ln671"> </a>
<a name="ln672">	PRINT((&quot;no session #%&quot; B_PRId32 &quot; found!\n&quot;, index));</a>
<a name="ln673">	return NULL;</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676"> </a>
<a name="ln677">/*! \brief Dumps a printout of the disc using TRACE.</a>
<a name="ln678">*/</a>
<a name="ln679">void</a>
<a name="ln680">Disc::Dump()</a>
<a name="ln681">{</a>
<a name="ln682">	TRACE((&quot;%s: Disc dump:\n&quot;, kModuleDebugName));</a>
<a name="ln683">	session* session = (struct session*)fSessionList-&gt;First();</a>
<a name="ln684">	while (session != NULL) {</a>
<a name="ln685">		TRACE((&quot;session %&quot; B_PRId32 &quot;:\n&quot;, session-&gt;index));</a>
<a name="ln686">		TRACE((&quot;  first track hint: %d\n&quot;, session-&gt;first_track_hint));</a>
<a name="ln687">		TRACE((&quot;  last track hint:  %d\n&quot;, session-&gt;last_track_hint));</a>
<a name="ln688">		TRACE((&quot;  end_lba:          %&quot; B_PRId64 &quot;\n&quot;, session-&gt;end_lba));</a>
<a name="ln689">		TRACE((&quot;  control:          %d (%s session, copy %s)\n&quot;,</a>
<a name="ln690">			session-&gt;control, (session-&gt;control &amp; kControlDataTrack</a>
<a name="ln691">				? &quot;data&quot; : &quot;audio&quot;),</a>
<a name="ln692">			(session-&gt;control &amp; kControlCopyPermitted</a>
<a name="ln693">				? &quot;permitted&quot; : &quot;prohibited&quot;)));</a>
<a name="ln694">		TRACE((&quot;  adr:              %d\n&quot;, session-&gt;adr));</a>
<a name="ln695">		track* track = (struct track*)session-&gt;track_list.First();</a>
<a name="ln696">		while (track != NULL) {</a>
<a name="ln697">			TRACE((&quot;  track %&quot; B_PRId32 &quot;:\n&quot;, track-&gt;index));</a>
<a name="ln698">			TRACE((&quot;    start_lba: %&quot; B_PRId64 &quot;\n&quot;, track-&gt;start_lba));</a>
<a name="ln699">			track = (struct track*)track-&gt;next;</a>
<a name="ln700">		}</a>
<a name="ln701">		session = (struct session*)session-&gt;next;</a>
<a name="ln702">	}</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">/*! \brief Checks for Yellow Book data tracks in audio sessions and if found</a>
<a name="ln707">	inserts them as a new data session.</a>
<a name="ln708">*/</a>
<a name="ln709">uint32</a>
<a name="ln710">Disc::_AdjustForYellowBook(cdrom_full_table_of_contents_entry entries[],</a>
<a name="ln711">	uint32 count)</a>
<a name="ln712">{</a>
<a name="ln713">	uint8 foundCount = 0;</a>
<a name="ln714">	uint8 endLBAEntry = 0;</a>
<a name="ln715">	uint8 trackTwo = 0;</a>
<a name="ln716"> </a>
<a name="ln717">	// Make sure TOC has only one session and that it is audio.</a>
<a name="ln718">	bool sessionIsAudio = true;</a>
<a name="ln719">	for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln720">		if (entries[i].point == 0xa2) {</a>
<a name="ln721">			if ((entries[i].control &amp; kControlDataTrack) != 0) {</a>
<a name="ln722">				sessionIsAudio = false;</a>
<a name="ln723">				break;</a>
<a name="ln724">			}</a>
<a name="ln725">			foundCount++;</a>
<a name="ln726">			endLBAEntry = i;</a>
<a name="ln727">		}</a>
<a name="ln728">	}</a>
<a name="ln729">	if (!sessionIsAudio || foundCount != 1)</a>
<a name="ln730">		return count;</a>
<a name="ln731"> </a>
<a name="ln732">	TRACE((&quot;%s: Single audio session, checking for data track\n&quot;,</a>
<a name="ln733">		kModuleDebugName));</a>
<a name="ln734"> </a>
<a name="ln735">	// See if there are any data tracks.</a>
<a name="ln736">	for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln737">		if (entries[i].point &gt; 0 &amp;&amp; entries[i].point &lt; 100</a>
<a name="ln738">			&amp;&amp; (entries[i].control &amp; kControlDataTrack) != 0) {</a>
<a name="ln739">			if (entries[i].point == 1) {</a>
<a name="ln740">				// Create a new endLBA point for session one.</a>
<a name="ln741">				entries[count] = entries[endLBAEntry];</a>
<a name="ln742">				entries[count].control = entries[i].control;</a>
<a name="ln743"> </a>
<a name="ln744">				// Get track two and use it's start as</a>
<a name="ln745">				// the end of our new session.</a>
<a name="ln746">				for (uint8 j = 0; j &lt; count; j++) {</a>
<a name="ln747">					if (entries[j].point == 2) {</a>
<a name="ln748">						trackTwo = j;</a>
<a name="ln749">						break;</a>
<a name="ln750">					}</a>
<a name="ln751">				}</a>
<a name="ln752">				entries[count].pminutes = entries[trackTwo].pminutes;</a>
<a name="ln753">				entries[count].pseconds = entries[trackTwo].pseconds;</a>
<a name="ln754">				entries[count].pframes = entries[trackTwo].pframes;</a>
<a name="ln755"> </a>
<a name="ln756">				// Change the other points to session two.</a>
<a name="ln757">				for (uint32 j = 0; j &lt; count; j++) {</a>
<a name="ln758">					entries[j].session = 2;</a>
<a name="ln759">				}</a>
<a name="ln760">				entries[i].session = 1;</a>
<a name="ln761"> </a>
<a name="ln762">				count++;</a>
<a name="ln763">				TRACE((&quot;%s: first track is data, adjusted TOC\n&quot;,</a>
<a name="ln764">					kModuleDebugName));</a>
<a name="ln765">				break;</a>
<a name="ln766">			} else {</a>
<a name="ln767">				// Change the track to session two.</a>
<a name="ln768">				entries[i].session = 2;</a>
<a name="ln769"> </a>
<a name="ln770">				// Create a new endLBA point for session two.</a>
<a name="ln771">				entries[count] = entries[endLBAEntry];</a>
<a name="ln772">				entries[count].session = 2;</a>
<a name="ln773">				entries[count].control = entries[i].control;</a>
<a name="ln774"> </a>
<a name="ln775">				// Use the beginning of the data track as the</a>
<a name="ln776">				// end of the previous session.</a>
<a name="ln777">				entries[endLBAEntry].pminutes = entries[i].pminutes;</a>
<a name="ln778">				entries[endLBAEntry].pseconds = entries[i].pseconds;</a>
<a name="ln779">				entries[endLBAEntry].pframes = entries[i].pframes;</a>
<a name="ln780"> </a>
<a name="ln781">				count++;</a>
<a name="ln782">				TRACE((&quot;%s: last track is data, adjusted TOC\n&quot;,</a>
<a name="ln783">					kModuleDebugName));</a>
<a name="ln784">				break;</a>
<a name="ln785">			}</a>
<a name="ln786">		}</a>
<a name="ln787">	}</a>
<a name="ln788">	return count;</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791"> </a>
<a name="ln792">/*! \brief Reads through the given table of contents data and creates an</a>
<a name="ln793">	unsorted, unverified (i.e. non-error-checked) list of sessions and tracks.</a>
<a name="ln794">*/</a>
<a name="ln795">status_t</a>
<a name="ln796">Disc::_ParseTableOfContents(cdrom_full_table_of_contents_entry entries[],</a>
<a name="ln797">	uint32 count)</a>
<a name="ln798">{</a>
<a name="ln799">	DEBUG_INIT_ETC(&quot;Disc&quot;, (&quot;entries: %p, count: %&quot; B_PRIu32, entries, count));</a>
<a name="ln800"> </a>
<a name="ln801">	for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln802">		// Find or create the appropriate session</a>
<a name="ln803">		uint8 sessionIndex = entries[i].session;</a>
<a name="ln804">		session* session = (struct session*)fSessionList-&gt;Find(sessionIndex);</a>
<a name="ln805">		if (session == NULL) {</a>
<a name="ln806">			session = new struct session(sessionIndex);</a>
<a name="ln807">			if (session == NULL)</a>
<a name="ln808">				return B_NO_MEMORY;</a>
<a name="ln809"> </a>
<a name="ln810">			fSessionList-&gt;Add(session);</a>
<a name="ln811">		}</a>
<a name="ln812"> </a>
<a name="ln813">		uint8 point = entries[i].point;</a>
<a name="ln814"> </a>
<a name="ln815">		switch (point) {</a>
<a name="ln816">			// first track hint</a>
<a name="ln817">			case 0xA0:</a>
<a name="ln818">				if (!session-&gt;first_track_hint_is_set()) {</a>
<a name="ln819">					int8 firstTrackHint = entries[i].pminutes;</a>
<a name="ln820">					if (1 &lt;= firstTrackHint &amp;&amp; firstTrackHint &lt;= 99) {</a>
<a name="ln821">						session-&gt;first_track_hint = firstTrackHint;</a>
<a name="ln822">					} else {</a>
<a name="ln823">						WARN((&quot;%s: warning: illegal first track hint %d found &quot;</a>
<a name="ln824">							&quot;for session %d\n&quot;, kModuleDebugName,</a>
<a name="ln825">							firstTrackHint, sessionIndex));</a>
<a name="ln826">					}</a>
<a name="ln827">				} else {</a>
<a name="ln828">					WARN((&quot;%s: warning: duplicated first track hint values &quot;</a>
<a name="ln829">						&quot;found for session %d; using first value &quot;</a>
<a name="ln830">						&quot;encountered: %d&quot;, kModuleDebugName, sessionIndex,</a>
<a name="ln831">						session-&gt;first_track_hint));</a>
<a name="ln832">				}</a>
<a name="ln833">				break;</a>
<a name="ln834"> </a>
<a name="ln835">			// last track hint</a>
<a name="ln836">			case 0xA1:</a>
<a name="ln837">				if (!session-&gt;last_track_hint_is_set()) {</a>
<a name="ln838">					int8 lastTrackHint = entries[i].pminutes;</a>
<a name="ln839">					if (1 &lt;= lastTrackHint &amp;&amp; lastTrackHint &lt;= 99) {</a>
<a name="ln840">						session-&gt;last_track_hint = lastTrackHint;</a>
<a name="ln841">					} else {</a>
<a name="ln842">						WARN((&quot;%s: warning: illegal last track hint %d found &quot;</a>
<a name="ln843">							&quot;for session %d\n&quot;, kModuleDebugName,</a>
<a name="ln844">							lastTrackHint, sessionIndex));</a>
<a name="ln845">					}</a>
<a name="ln846">				} else {</a>
<a name="ln847">					WARN((&quot;%s: warning: duplicate last track hint values found &quot;</a>
<a name="ln848">						&quot;for session %d; using first value encountered: %d&quot;,</a>
<a name="ln849">						kModuleDebugName, sessionIndex,</a>
<a name="ln850">						session-&gt;last_track_hint));</a>
<a name="ln851">				}</a>
<a name="ln852">				break;</a>
<a name="ln853"> </a>
<a name="ln854">			// end of session address</a>
<a name="ln855">			case 0xA2:</a>
<a name="ln856">				if (!session-&gt;end_lba_is_set()) {</a>
<a name="ln857">					off_t endLBA = msf_to_lba(make_msf_address(</a>
<a name="ln858">						entries[i].pminutes, entries[i].pseconds,</a>
<a name="ln859">						entries[i].pframes));</a>
<a name="ln860">					if (endLBA &gt; 0) {</a>
<a name="ln861">						session-&gt;end_lba = endLBA;</a>
<a name="ln862">						// We also grab the session's control and adr values</a>
<a name="ln863">						// from this entry</a>
<a name="ln864">						session-&gt;control = entries[i].control;</a>
<a name="ln865">						session-&gt;adr = entries[i].adr;</a>
<a name="ln866">					} else {</a>
<a name="ln867">						WARN((&quot;%s: warning: illegal end lba %&quot; B_PRId64 &quot; found&quot;</a>
<a name="ln868">							&quot; for session %d\n&quot;, kModuleDebugName, endLBA,</a>
<a name="ln869">							sessionIndex));</a>
<a name="ln870">					}</a>
<a name="ln871">				} else {</a>
<a name="ln872">					WARN((&quot;%s: warning: duplicate end lba values found for &quot;</a>
<a name="ln873">						&quot;session %d; using first value encountered: %&quot; B_PRId64,</a>
<a name="ln874">						kModuleDebugName, sessionIndex, session-&gt;end_lba));</a>
<a name="ln875">				}</a>
<a name="ln876">				break;</a>
<a name="ln877"> </a>
<a name="ln878">			// Valid, but uninteresting, points</a>
<a name="ln879">			case 0xB0:</a>
<a name="ln880">			case 0xB1:</a>
<a name="ln881">			case 0xB2:</a>
<a name="ln882">			case 0xB3:</a>
<a name="ln883">			case 0xB4:</a>
<a name="ln884">			case 0xC0:</a>
<a name="ln885">			case 0xC1:</a>
<a name="ln886">				break;</a>
<a name="ln887"> </a>
<a name="ln888">			default:</a>
<a name="ln889">				// Anything else had better be a valid track number,</a>
<a name="ln890">				// or it's an invalid point</a>
<a name="ln891">				if (1 &lt;= point &amp;&amp; point &lt;= 99) {</a>
<a name="ln892">					// Create and add the track. We'll weed out any duplicates</a>
<a name="ln893">					// later.</a>
<a name="ln894">					uint8 trackIndex = point;</a>
<a name="ln895">					off_t startLBA = msf_to_lba(make_msf_address(</a>
<a name="ln896">						entries[i].pminutes, entries[i].pseconds,</a>
<a name="ln897">						entries[i].pframes));</a>
<a name="ln898">					// The control and adr values grabbed here are only used</a>
<a name="ln899">					// later on to signal a warning if they don't match the</a>
<a name="ln900">					// corresponding values of the parent session.</a>
<a name="ln901">					track* track = new(std::nothrow) struct track(trackIndex,</a>
<a name="ln902">						startLBA, entries[i].control, entries[i].adr);</a>
<a name="ln903">					if (track == NULL)</a>
<a name="ln904">						return B_NO_MEMORY;</a>
<a name="ln905"> </a>
<a name="ln906">					session-&gt;track_list.Add(track);</a>
<a name="ln907">				} else {</a>
<a name="ln908">					WARN((&quot;%s: warning: illegal point 0x%2x found in table of &quot;</a>
<a name="ln909">						&quot;contents\n&quot;, kModuleDebugName, point));</a>
<a name="ln910">				}</a>
<a name="ln911">				break;</a>
<a name="ln912">		}</a>
<a name="ln913">	}</a>
<a name="ln914">	return B_OK;</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917"> </a>
<a name="ln918">/*! \brief Bubble sorts the session list and each session's track lists,</a>
<a name="ln919">	removing all but the first of any duplicates (by index) found along</a>
<a name="ln920">	the way.</a>
<a name="ln921">*/</a>
<a name="ln922">void</a>
<a name="ln923">Disc::_SortAndRemoveDuplicates()</a>
<a name="ln924">{</a>
<a name="ln925">	fSessionList-&gt;SortAndRemoveDuplicates();</a>
<a name="ln926">	session* session = (struct session*)fSessionList-&gt;First();</a>
<a name="ln927">	while (session != NULL) {</a>
<a name="ln928">		session-&gt;track_list.SortAndRemoveDuplicates();</a>
<a name="ln929">		session = (struct session*)session-&gt;next;</a>
<a name="ln930">	}</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933"> </a>
<a name="ln934">/*	\brief Checks the sessions and tracks for any anomalies.</a>
<a name="ln935"> </a>
<a name="ln936">	Errors will return an error code, warnings will return B_OK.</a>
<a name="ln937">	Both will print a notification using TRACE.</a>
<a name="ln938"> </a>
<a name="ln939">	Anomalies that result in errors:</a>
<a name="ln940">	- Sessions with no end_lba set</a>
<a name="ln941">	- Sessions with no tracks</a>
<a name="ln942"> </a>
<a name="ln943">	Anomalies that result in warnings:</a>
<a name="ln944">	- Inaccurate first_track_hint and/or last_track_hint values</a>
<a name="ln945">	- Sequences of sessions or tracks that do not start at 1,</a>
<a name="ln946">	  do not end at or before 99, or are not strictly ascending.</a>
<a name="ln947">	  (all tracks are checked as a single sequence, since track</a>
<a name="ln948">	  numbering does not restart with each session).</a>
<a name="ln949">	- Tracks with different control and/or adr values than their</a>
<a name="ln950">	  parent session</a>
<a name="ln951"> </a>
<a name="ln952">	Anomalies that are currently *not* checked:</a>
<a name="ln953">	- First Track Hint or Last Track Hint control and adr values</a>
<a name="ln954">	  that do not match the values for their session; Ingo's copy</a>
<a name="ln955">	  of the BeOS R5 CD is like this, but I don't believe it's</a>
<a name="ln956">	  a matter we need to worry about. This could certainly be</a>
<a name="ln957">	  changed in the future if needed.</a>
<a name="ln958">*/</a>
<a name="ln959">status_t</a>
<a name="ln960">Disc::_CheckForErrorsAndWarnings() {</a>
<a name="ln961">	int32 lastSessionIndex = 0;</a>
<a name="ln962">	int32 lastTrackIndex = 0;</a>
<a name="ln963"> </a>
<a name="ln964">	for (session* session = (struct session*)fSessionList-&gt;First(); session;</a>
<a name="ln965">			session = (struct session*)session-&gt;next) {</a>
<a name="ln966">		// Check for errors</a>
<a name="ln967"> </a>
<a name="ln968">		// missing end lba</a>
<a name="ln969">		if (!session-&gt;end_lba_is_set()) {</a>
<a name="ln970">			TRACE((&quot;%s: Disc::_CheckForErrorsAndWarnings: error: no end of &quot;</a>
<a name="ln971">				&quot;session address for session #%&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln972">				kModuleDebugName, session-&gt;index));</a>
<a name="ln973">			return B_ERROR;</a>
<a name="ln974">		}</a>
<a name="ln975"> </a>
<a name="ln976">		// empty track list</a>
<a name="ln977">		track* track = (struct track*)session-&gt;track_list.First();</a>
<a name="ln978">		if (track == NULL) {</a>
<a name="ln979">			TRACE((&quot;%s: Disc::_CheckForErrorsAndWarnings: error: session #%&quot;</a>
<a name="ln980">				B_PRId32 &quot;has no tracks\n&quot;, kModuleDebugName, session-&gt;index));</a>
<a name="ln981">			return B_ERROR;</a>
<a name="ln982">		}</a>
<a name="ln983"> </a>
<a name="ln984">		// Check for warnings</a>
<a name="ln985"> </a>
<a name="ln986">		// incorrect first track hint</a>
<a name="ln987">		if (session-&gt;first_track_hint_is_set()</a>
<a name="ln988">			&amp;&amp; session-&gt;first_track_hint != track-&gt;index) {</a>
<a name="ln989">			TRACE((&quot;%s: Disc::_CheckForErrorsAndWarnings: warning: session &quot;</a>
<a name="ln990">				&quot;#%&quot; B_PRId32 &quot;: first track hint (%d) doesn't match actual &quot;</a>
<a name="ln991">				&quot;first track (%&quot; B_PRId32 &quot;)\n&quot;, kModuleDebugName,</a>
<a name="ln992">				session-&gt;index, session-&gt;first_track_hint, track-&gt;index));</a>
<a name="ln993">		}</a>
<a name="ln994"> </a>
<a name="ln995">		// incorrect last track hint</a>
<a name="ln996">		struct track* last = (struct track*)session-&gt;track_list.Last();</a>
<a name="ln997">		if (session-&gt;last_track_hint_is_set() &amp;&amp; last</a>
<a name="ln998">			&amp;&amp; session-&gt;last_track_hint != last-&gt;index) {</a>
<a name="ln999">			TRACE((&quot;%s: Disc::_CheckForErrorsAndWarnings: warning: session &quot;</a>
<a name="ln1000">				&quot;#%&quot; B_PRId32 &quot;: last track hint (%d) doesn't match actual &quot;</a>
<a name="ln1001">				&quot;last track (%&quot; B_PRId32 &quot;)\n&quot;, kModuleDebugName,</a>
<a name="ln1002">				session-&gt;index, session-&gt;last_track_hint, last-&gt;index));</a>
<a name="ln1003">		}</a>
<a name="ln1004"> </a>
<a name="ln1005">		// invalid session sequence</a>
<a name="ln1006">		if (lastSessionIndex + 1 != session-&gt;index) {</a>
<a name="ln1007">			TRACE((&quot;%s: Disc::_CheckForErrorsAndWarnings: warning: index for &quot;</a>
<a name="ln1008">				&quot;session #%&quot; B_PRId32 &quot; is out of sequence (should have been #%&quot;</a>
<a name="ln1009">				B_PRId32 &quot;)\n&quot;,	kModuleDebugName, session-&gt;index,</a>
<a name="ln1010">				lastSessionIndex));</a>
<a name="ln1011">		}</a>
<a name="ln1012">		lastSessionIndex = session-&gt;index;</a>
<a name="ln1013"> </a>
<a name="ln1014">		for (; track; track = (struct track*)track-&gt;next) {</a>
<a name="ln1015">			// invalid track sequence</a>
<a name="ln1016">			if (lastTrackIndex + 1 != track-&gt;index) {</a>
<a name="ln1017">				TRACE((&quot;%s: Disc::_CheckForErrorsAndWarnings: warning: index &quot;</a>
<a name="ln1018">					&quot;for track #%&quot; B_PRId32 &quot; is out of sequence (should have &quot;</a>
<a name="ln1019">					&quot;been #%&quot; B_PRId32 &quot;)\n&quot;, kModuleDebugName, track-&gt;index,</a>
<a name="ln1020">					lastTrackIndex));</a>
<a name="ln1021">			}</a>
<a name="ln1022">			lastTrackIndex = track-&gt;index;</a>
<a name="ln1023"> </a>
<a name="ln1024">			// mismatched control</a>
<a name="ln1025">			if (track-&gt;control != session-&gt;control) {</a>
<a name="ln1026">				TRACE((&quot;%s: Disc::_CheckForErrorsAndWarnings: warning: control &quot;</a>
<a name="ln1027">					&quot;for track #%&quot; B_PRId32 &quot; (%d, %s track, copy %s) does not &quot;</a>
<a name="ln1028">					&quot;match control for parent session #%&quot; B_PRId32 &quot; (%d, %s &quot;</a>
<a name="ln1029">					&quot;session, copy %s)\n&quot;, kModuleDebugName, track-&gt;index,</a>
<a name="ln1030">					track-&gt;control,</a>
<a name="ln1031">					(track-&gt;control &amp; kControlDataTrack ? &quot;data&quot; : &quot;audio&quot;),</a>
<a name="ln1032">					(track-&gt;control &amp; kControlCopyPermitted</a>
<a name="ln1033">						? &quot;permitted&quot; : &quot;prohibited&quot;),</a>
<a name="ln1034">					session-&gt;index, session-&gt;control,</a>
<a name="ln1035">					(session-&gt;control &amp; kControlDataTrack ? &quot;data&quot; : &quot;audio&quot;),</a>
<a name="ln1036">					(session-&gt;control &amp; kControlCopyPermitted</a>
<a name="ln1037">						? &quot;permitted&quot; : &quot;prohibited&quot;)));</a>
<a name="ln1038">			}</a>
<a name="ln1039"> </a>
<a name="ln1040">			// mismatched adr</a>
<a name="ln1041">			if (track-&gt;adr != session-&gt;adr) {</a>
<a name="ln1042">				TRACE((&quot;%s: Disc::_CheckForErrorsAndWarnings: warning: adr &quot;</a>
<a name="ln1043">					&quot;for track #%&quot; B_PRId32 &quot; (adr = %d) does not match adr &quot;</a>
<a name="ln1044">					&quot;for parent session #%&quot; B_PRId32 &quot; (adr = %d)\n&quot;,</a>
<a name="ln1045">					kModuleDebugName, track-&gt;index, track-&gt;adr, session-&gt;index,</a>
<a name="ln1046">					session-&gt;adr));</a>
<a name="ln1047">			}</a>
<a name="ln1048">		}</a>
<a name="ln1049">	}</a>
<a name="ln1050"> </a>
<a name="ln1051">	return B_OK;</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055">//	#pragma mark - Session</a>
<a name="ln1056"> </a>
<a name="ln1057"> </a>
<a name="ln1058">Session::Session(off_t offset, off_t size, uint32 blockSize, int32 index,</a>
<a name="ln1059">		uint32 flags, const char* type)</a>
<a name="ln1060">	:</a>
<a name="ln1061">	fOffset(offset),</a>
<a name="ln1062">	fSize(size),</a>
<a name="ln1063">	fBlockSize(blockSize),</a>
<a name="ln1064">	fIndex(index),</a>
<a name="ln1065">	fFlags(flags),</a>
<a name="ln1066">	fType(strdup(type))</a>
<a name="ln1067">{</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070"> </a>
<a name="ln1071">Session::~Session()</a>
<a name="ln1072">{</a>
<a name="ln1073">	free(fType);</a>
<a name="ln1074">}</a>

</code></pre>
<div class="balloon" rel="265"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'raw_command.command'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
