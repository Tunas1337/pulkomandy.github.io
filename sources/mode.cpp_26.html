
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>mode.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Support for i915 chipset and up based on the X driver,</a>
<a name="ln6"> * Copyright 2006-2007 Intel Corporation.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Authors:</a>
<a name="ln9"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln10"> */</a>
<a name="ln11"> </a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;math.h&gt;</a>
<a name="ln14">#include &lt;stdio.h&gt;</a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;Debug.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;create_display_modes.h&gt;</a>
<a name="ln20">#include &lt;ddc.h&gt;</a>
<a name="ln21">#include &lt;edid.h&gt;</a>
<a name="ln22">#include &lt;validate_display_mode.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;accelerant_protos.h&quot;</a>
<a name="ln25">#include &quot;accelerant.h&quot;</a>
<a name="ln26">#include &quot;pll.h&quot;</a>
<a name="ln27">#include &quot;Ports.h&quot;</a>
<a name="ln28">#include &quot;utility.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">#undef TRACE</a>
<a name="ln32">#define TRACE_MODE</a>
<a name="ln33">#ifdef TRACE_MODE</a>
<a name="ln34">#	define TRACE(x...) _sPrintf(&quot;intel_extreme: &quot; x)</a>
<a name="ln35">#else</a>
<a name="ln36">#	define TRACE(x...)</a>
<a name="ln37">#endif</a>
<a name="ln38"> </a>
<a name="ln39">#define ERROR(x...) _sPrintf(&quot;intel_extreme: &quot; x)</a>
<a name="ln40">#define CALLED(x...) TRACE(&quot;CALLED %s\n&quot;, __PRETTY_FUNCTION__)</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">#if 0</a>
<a name="ln44">// This hack needs to die. Leaving in for a little while</a>
<a name="ln45">// incase we *really* need it.</a>
<a name="ln46">static void</a>
<a name="ln47">retrieve_current_mode(display_mode&amp; mode, uint32 pllRegister)</a>
<a name="ln48">{</a>
<a name="ln49">	uint32 pll = read32(pllRegister);</a>
<a name="ln50">	uint32 pllDivisor;</a>
<a name="ln51">	uint32 hTotalRegister;</a>
<a name="ln52">	uint32 vTotalRegister;</a>
<a name="ln53">	uint32 hSyncRegister;</a>
<a name="ln54">	uint32 vSyncRegister;</a>
<a name="ln55">	uint32 imageSizeRegister;</a>
<a name="ln56">	uint32 controlRegister;</a>
<a name="ln57"> </a>
<a name="ln58">	if (pllRegister == INTEL_DISPLAY_A_PLL) {</a>
<a name="ln59">		pllDivisor = read32((pll &amp; DISPLAY_PLL_DIVISOR_1) != 0</a>
<a name="ln60">			? INTEL_DISPLAY_A_PLL_DIVISOR_1 : INTEL_DISPLAY_A_PLL_DIVISOR_0);</a>
<a name="ln61"> </a>
<a name="ln62">		hTotalRegister = INTEL_DISPLAY_A_HTOTAL;</a>
<a name="ln63">		vTotalRegister = INTEL_DISPLAY_A_VTOTAL;</a>
<a name="ln64">		hSyncRegister = INTEL_DISPLAY_A_HSYNC;</a>
<a name="ln65">		vSyncRegister = INTEL_DISPLAY_A_VSYNC;</a>
<a name="ln66">		imageSizeRegister = INTEL_DISPLAY_A_IMAGE_SIZE;</a>
<a name="ln67">		controlRegister = INTEL_DISPLAY_A_CONTROL;</a>
<a name="ln68">	} else if (pllRegister == INTEL_DISPLAY_B_PLL) {</a>
<a name="ln69">		pllDivisor = read32((pll &amp; DISPLAY_PLL_DIVISOR_1) != 0</a>
<a name="ln70">			? INTEL_DISPLAY_B_PLL_DIVISOR_1 : INTEL_DISPLAY_B_PLL_DIVISOR_0);</a>
<a name="ln71"> </a>
<a name="ln72">		hTotalRegister = INTEL_DISPLAY_B_HTOTAL;</a>
<a name="ln73">		vTotalRegister = INTEL_DISPLAY_B_VTOTAL;</a>
<a name="ln74">		hSyncRegister = INTEL_DISPLAY_B_HSYNC;</a>
<a name="ln75">		vSyncRegister = INTEL_DISPLAY_B_VSYNC;</a>
<a name="ln76">		imageSizeRegister = INTEL_DISPLAY_B_IMAGE_SIZE;</a>
<a name="ln77">		controlRegister = INTEL_DISPLAY_B_CONTROL;</a>
<a name="ln78">	} else {</a>
<a name="ln79">		ERROR(&quot;%s: PLL not supported\n&quot;, __func__);</a>
<a name="ln80">		return;</a>
<a name="ln81">	}</a>
<a name="ln82"> </a>
<a name="ln83">	pll_divisors divisors;</a>
<a name="ln84">	if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_PIN)) {</a>
<a name="ln85">		divisors.m1 = 0;</a>
<a name="ln86">		divisors.m2 = (pllDivisor &amp; DISPLAY_PLL_IGD_M2_DIVISOR_MASK)</a>
<a name="ln87">			&gt;&gt; DISPLAY_PLL_M2_DIVISOR_SHIFT;</a>
<a name="ln88">		divisors.n = ((pllDivisor &amp; DISPLAY_PLL_IGD_N_DIVISOR_MASK)</a>
<a name="ln89">			&gt;&gt; DISPLAY_PLL_N_DIVISOR_SHIFT) - 1;</a>
<a name="ln90">	} else {</a>
<a name="ln91">		divisors.m1 = (pllDivisor &amp; DISPLAY_PLL_M1_DIVISOR_MASK)</a>
<a name="ln92">			&gt;&gt; DISPLAY_PLL_M1_DIVISOR_SHIFT;</a>
<a name="ln93">		divisors.m2 = (pllDivisor &amp; DISPLAY_PLL_M2_DIVISOR_MASK)</a>
<a name="ln94">			&gt;&gt; DISPLAY_PLL_M2_DIVISOR_SHIFT;</a>
<a name="ln95">		divisors.n = (pllDivisor &amp; DISPLAY_PLL_N_DIVISOR_MASK)</a>
<a name="ln96">			&gt;&gt; DISPLAY_PLL_N_DIVISOR_SHIFT;</a>
<a name="ln97">	}</a>
<a name="ln98"> </a>
<a name="ln99">	pll_limits limits;</a>
<a name="ln100">	get_pll_limits(&amp;limits, false);</a>
<a name="ln101">		// TODO: Detect LVDS connector vs assume no</a>
<a name="ln102"> </a>
<a name="ln103">	if (gInfo-&gt;shared_info-&gt;device_type.Generation() &gt;= 3) {</a>
<a name="ln104"> </a>
<a name="ln105">		if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_PIN)) {</a>
<a name="ln106">			divisors.post1 = (pll &amp; DISPLAY_PLL_IGD_POST1_DIVISOR_MASK)</a>
<a name="ln107">				&gt;&gt; DISPLAY_PLL_IGD_POST1_DIVISOR_SHIFT;</a>
<a name="ln108">		} else {</a>
<a name="ln109">			divisors.post1 = (pll &amp; DISPLAY_PLL_9xx_POST1_DIVISOR_MASK)</a>
<a name="ln110">				&gt;&gt; DISPLAY_PLL_POST1_DIVISOR_SHIFT;</a>
<a name="ln111">		}</a>
<a name="ln112"> </a>
<a name="ln113">		if (pllRegister == INTEL_DISPLAY_B_PLL</a>
<a name="ln114">			&amp;&amp; !gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_96x)) {</a>
<a name="ln115">			// TODO: Fix this? Need to support dual channel LVDS.</a>
<a name="ln116">			divisors.post2 = LVDS_POST2_RATE_SLOW;</a>
<a name="ln117">		} else {</a>
<a name="ln118">			if ((pll &amp; DISPLAY_PLL_DIVIDE_HIGH) != 0)</a>
<a name="ln119">				divisors.post2 = limits.max.post2;</a>
<a name="ln120">			else</a>
<a name="ln121">				divisors.post2 = limits.min.post2;</a>
<a name="ln122">		}</a>
<a name="ln123">	} else {</a>
<a name="ln124">		// 8xx</a>
<a name="ln125">		divisors.post1 = (pll &amp; DISPLAY_PLL_POST1_DIVISOR_MASK)</a>
<a name="ln126">			&gt;&gt; DISPLAY_PLL_POST1_DIVISOR_SHIFT;</a>
<a name="ln127"> </a>
<a name="ln128">		if ((pll &amp; DISPLAY_PLL_DIVIDE_4X) != 0)</a>
<a name="ln129">			divisors.post2 = limits.max.post2;</a>
<a name="ln130">		else</a>
<a name="ln131">			divisors.post2 = limits.min.post2;</a>
<a name="ln132">	}</a>
<a name="ln133"> </a>
<a name="ln134">	divisors.m = 5 * divisors.m1 + divisors.m2;</a>
<a name="ln135">	divisors.post = divisors.post1 * divisors.post2;</a>
<a name="ln136"> </a>
<a name="ln137">	float referenceClock</a>
<a name="ln138">		= gInfo-&gt;shared_info-&gt;pll_info.reference_frequency / 1000.0f;</a>
<a name="ln139">	float pixelClock</a>
<a name="ln140">		= ((referenceClock * divisors.m) / divisors.n) / divisors.post;</a>
<a name="ln141"> </a>
<a name="ln142">	// timing</a>
<a name="ln143"> </a>
<a name="ln144">	mode.timing.pixel_clock = uint32(pixelClock * 1000);</a>
<a name="ln145">	mode.timing.flags = 0;</a>
<a name="ln146"> </a>
<a name="ln147">	uint32 value = read32(hTotalRegister);</a>
<a name="ln148">	mode.timing.h_total = (value &gt;&gt; 16) + 1;</a>
<a name="ln149">	mode.timing.h_display = (value &amp; 0xffff) + 1;</a>
<a name="ln150"> </a>
<a name="ln151">	value = read32(hSyncRegister);</a>
<a name="ln152">	mode.timing.h_sync_end = (value &gt;&gt; 16) + 1;</a>
<a name="ln153">	mode.timing.h_sync_start = (value &amp; 0xffff) + 1;</a>
<a name="ln154"> </a>
<a name="ln155">	value = read32(vTotalRegister);</a>
<a name="ln156">	mode.timing.v_total = (value &gt;&gt; 16) + 1;</a>
<a name="ln157">	mode.timing.v_display = (value &amp; 0xffff) + 1;</a>
<a name="ln158"> </a>
<a name="ln159">	value = read32(vSyncRegister);</a>
<a name="ln160">	mode.timing.v_sync_end = (value &gt;&gt; 16) + 1;</a>
<a name="ln161">	mode.timing.v_sync_start = (value &amp; 0xffff) + 1;</a>
<a name="ln162"> </a>
<a name="ln163">	// image size and color space</a>
<a name="ln164"> </a>
<a name="ln165">	value = read32(imageSizeRegister);</a>
<a name="ln166">	mode.virtual_width = (value &gt;&gt; 16) + 1;</a>
<a name="ln167">	mode.virtual_height = (value &amp; 0xffff) + 1;</a>
<a name="ln168"> </a>
<a name="ln169">	// using virtual size based on image size is the 'proper' way to do it,</a>
<a name="ln170">	// however the bios appears to be suggesting scaling or somesuch, so ignore</a>
<a name="ln171">	// the proper virtual dimension for now if they'd suggest a smaller size.</a>
<a name="ln172">	if (mode.virtual_width &lt; mode.timing.h_display)</a>
<a name="ln173">		mode.virtual_width = mode.timing.h_display;</a>
<a name="ln174">	if (mode.virtual_height &lt; mode.timing.v_display)</a>
<a name="ln175">		mode.virtual_height = mode.timing.v_display;</a>
<a name="ln176"> </a>
<a name="ln177">	value = read32(controlRegister);</a>
<a name="ln178">	switch (value &amp; DISPLAY_CONTROL_COLOR_MASK) {</a>
<a name="ln179">		case DISPLAY_CONTROL_RGB32:</a>
<a name="ln180">		default:</a>
<a name="ln181">			mode.space = B_RGB32;</a>
<a name="ln182">			break;</a>
<a name="ln183">		case DISPLAY_CONTROL_RGB16:</a>
<a name="ln184">			mode.space = B_RGB16;</a>
<a name="ln185">			break;</a>
<a name="ln186">		case DISPLAY_CONTROL_RGB15:</a>
<a name="ln187">			mode.space = B_RGB15;</a>
<a name="ln188">			break;</a>
<a name="ln189">		case DISPLAY_CONTROL_CMAP8:</a>
<a name="ln190">			mode.space = B_CMAP8;</a>
<a name="ln191">			break;</a>
<a name="ln192">	}</a>
<a name="ln193"> </a>
<a name="ln194">	mode.h_display_start = 0;</a>
<a name="ln195">	mode.v_display_start = 0;</a>
<a name="ln196">	mode.flags = B_8_BIT_DAC | B_HARDWARE_CURSOR | B_PARALLEL_ACCESS</a>
<a name="ln197">		| B_DPMS | B_SUPPORTS_OVERLAYS;</a>
<a name="ln198">}</a>
<a name="ln199">#endif</a>
<a name="ln200"> </a>
<a name="ln201"> </a>
<a name="ln202">static void</a>
<a name="ln203">get_color_space_format(const display_mode &amp;mode, uint32 &amp;colorMode,</a>
<a name="ln204">	uint32 &amp;bytesPerRow, uint32 &amp;bitsPerPixel)</a>
<a name="ln205">{</a>
<a name="ln206">	uint32 bytesPerPixel;</a>
<a name="ln207"> </a>
<a name="ln208">	switch (mode.space) {</a>
<a name="ln209">		case B_RGB32_LITTLE:</a>
<a name="ln210">			colorMode = DISPLAY_CONTROL_RGB32;</a>
<a name="ln211">			bytesPerPixel = 4;</a>
<a name="ln212">			bitsPerPixel = 32;</a>
<a name="ln213">			break;</a>
<a name="ln214">		case B_RGB16_LITTLE:</a>
<a name="ln215">			colorMode = DISPLAY_CONTROL_RGB16;</a>
<a name="ln216">			bytesPerPixel = 2;</a>
<a name="ln217">			bitsPerPixel = 16;</a>
<a name="ln218">			break;</a>
<a name="ln219">		case B_RGB15_LITTLE:</a>
<a name="ln220">			colorMode = DISPLAY_CONTROL_RGB15;</a>
<a name="ln221">			bytesPerPixel = 2;</a>
<a name="ln222">			bitsPerPixel = 15;</a>
<a name="ln223">			break;</a>
<a name="ln224">		case B_CMAP8:</a>
<a name="ln225">		default:</a>
<a name="ln226">			colorMode = DISPLAY_CONTROL_CMAP8;</a>
<a name="ln227">			bytesPerPixel = 1;</a>
<a name="ln228">			bitsPerPixel = 8;</a>
<a name="ln229">			break;</a>
<a name="ln230">	}</a>
<a name="ln231"> </a>
<a name="ln232">	bytesPerRow = mode.virtual_width * bytesPerPixel;</a>
<a name="ln233"> </a>
<a name="ln234">	// Make sure bytesPerRow is a multiple of 64</a>
<a name="ln235">	// TODO: check if the older chips have the same restriction!</a>
<a name="ln236">	if ((bytesPerRow &amp; 63) != 0)</a>
<a name="ln237">		bytesPerRow = (bytesPerRow + 63) &amp; ~63;</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">static bool</a>
<a name="ln242">sanitize_display_mode(display_mode&amp; mode)</a>
<a name="ln243">{</a>
<a name="ln244">	// Some cards only support even pixel counts, while others require an odd</a>
<a name="ln245">	// one.</a>
<a name="ln246">	uint16 pixelCount = 1;</a>
<a name="ln247">	if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_Gxx)</a>
<a name="ln248">			|| gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_96x)</a>
<a name="ln249">			|| gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_94x)</a>
<a name="ln250">			|| gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_91x)</a>
<a name="ln251">			|| gInfo-&gt;shared_info-&gt;device_type.InFamily(INTEL_FAMILY_8xx)</a>
<a name="ln252">			|| gInfo-&gt;shared_info-&gt;device_type.InFamily(INTEL_FAMILY_7xx)) {</a>
<a name="ln253">		pixelCount = 2;</a>
<a name="ln254">	}</a>
<a name="ln255"> </a>
<a name="ln256">	// TODO: verify constraints - these are more or less taken from the</a>
<a name="ln257">	// radeon driver!</a>
<a name="ln258">	display_constraints constraints = {</a>
<a name="ln259">		// resolution</a>
<a name="ln260">		320, 8192, 200, 4096,</a>
<a name="ln261">		// pixel clock</a>
<a name="ln262">		gInfo-&gt;shared_info-&gt;pll_info.min_frequency,</a>
<a name="ln263">		gInfo-&gt;shared_info-&gt;pll_info.max_frequency,</a>
<a name="ln264">		// horizontal</a>
<a name="ln265">		{pixelCount, 0, 8160, 32, 8192, 0, 8192},</a>
<a name="ln266">		{1, 1, 4092, 2, 63, 1, 4096}</a>
<a name="ln267">	};</a>
<a name="ln268"> </a>
<a name="ln269">	return sanitize_display_mode(mode, constraints,</a>
<a name="ln270">		gInfo-&gt;has_edid ? &amp;gInfo-&gt;edid_info : NULL);</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273"> </a>
<a name="ln274">// #pragma mark -</a>
<a name="ln275"> </a>
<a name="ln276"> </a>
<a name="ln277">static void</a>
<a name="ln278">set_frame_buffer_registers(uint32 baseRegister, uint32 surfaceRegister)</a>
<a name="ln279">{</a>
<a name="ln280">	intel_shared_info &amp;sharedInfo = *gInfo-&gt;shared_info;</a>
<a name="ln281">	display_mode &amp;mode = gInfo-&gt;current_mode;</a>
<a name="ln282"> </a>
<a name="ln283">	if (sharedInfo.device_type.InGroup(INTEL_GROUP_96x)</a>
<a name="ln284">		|| sharedInfo.device_type.InGroup(INTEL_GROUP_G4x)</a>
<a name="ln285">		|| sharedInfo.device_type.InGroup(INTEL_GROUP_ILK)</a>
<a name="ln286">		|| sharedInfo.device_type.InFamily(INTEL_FAMILY_SER5)</a>
<a name="ln287">		|| sharedInfo.device_type.InFamily(INTEL_FAMILY_SOC0)) {</a>
<a name="ln288">		write32(baseRegister, mode.v_display_start * sharedInfo.bytes_per_row</a>
<a name="ln289">			+ mode.h_display_start * (sharedInfo.bits_per_pixel + 7) / 8);</a>
<a name="ln290">		read32(baseRegister);</a>
<a name="ln291">		write32(surfaceRegister, sharedInfo.frame_buffer_offset);</a>
<a name="ln292">		read32(surfaceRegister);</a>
<a name="ln293">	} else {</a>
<a name="ln294">		write32(baseRegister, sharedInfo.frame_buffer_offset</a>
<a name="ln295">			+ mode.v_display_start * sharedInfo.bytes_per_row</a>
<a name="ln296">			+ mode.h_display_start * (sharedInfo.bits_per_pixel + 7) / 8);</a>
<a name="ln297">		read32(baseRegister);</a>
<a name="ln298">	}</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301"> </a>
<a name="ln302">void</a>
<a name="ln303">set_frame_buffer_base()</a>
<a name="ln304">{</a>
<a name="ln305">	// TODO we always set both displays to the same address. When we support</a>
<a name="ln306">	// multiple framebuffers, they should get different addresses here.</a>
<a name="ln307">	set_frame_buffer_registers(INTEL_DISPLAY_A_BASE, INTEL_DISPLAY_A_SURFACE);</a>
<a name="ln308">	set_frame_buffer_registers(INTEL_DISPLAY_B_BASE, INTEL_DISPLAY_B_SURFACE);</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311"> </a>
<a name="ln312">/*!	Creates the initial mode list of the primary accelerant.</a>
<a name="ln313">	It's called from intel_init_accelerant().</a>
<a name="ln314">*/</a>
<a name="ln315">status_t</a>
<a name="ln316">create_mode_list(void)</a>
<a name="ln317">{</a>
<a name="ln318">	CALLED();</a>
<a name="ln319"> </a>
<a name="ln320">	for (uint32 i = 0; i &lt; gInfo-&gt;port_count; i++) {</a>
<a name="ln321">		if (gInfo-&gt;ports[i] == NULL)</a>
<a name="ln322">			continue;</a>
<a name="ln323"> </a>
<a name="ln324">		status_t status = gInfo-&gt;ports[i]-&gt;GetEDID(&amp;gInfo-&gt;edid_info);</a>
<a name="ln325">		if (status == B_OK)</a>
<a name="ln326">			gInfo-&gt;has_edid = true;</a>
<a name="ln327">	}</a>
<a name="ln328"> </a>
<a name="ln329">	display_mode* list;</a>
<a name="ln330">	uint32 count = 0;</a>
<a name="ln331"> </a>
<a name="ln332">	// If no EDID, but have vbt from driver, use that mode</a>
<a name="ln333">	if (!gInfo-&gt;has_edid &amp;&amp; gInfo-&gt;shared_info-&gt;got_vbt) {</a>
<a name="ln334">		// We could not read any EDID info. Fallback to creating a list with</a>
<a name="ln335">		// only the mode set up by the BIOS.</a>
<a name="ln336"> </a>
<a name="ln337">		// TODO: support lower modes via scaling and windowing</a>
<a name="ln338">		gInfo-&gt;mode_list_area = create_display_modes(&quot;intel extreme modes&quot;,</a>
<a name="ln339">			NULL, &amp;gInfo-&gt;shared_info-&gt;panel_mode, 1, NULL, 0, NULL,</a>
<a name="ln340">			&amp;list, &amp;count);</a>
<a name="ln341">	} else {</a>
<a name="ln342">		// Otherwise return the 'real' list of modes</a>
<a name="ln343">		gInfo-&gt;mode_list_area = create_display_modes(&quot;intel extreme modes&quot;,</a>
<a name="ln344">			gInfo-&gt;has_edid ? &amp;gInfo-&gt;edid_info : NULL, NULL, 0, NULL, 0, NULL,</a>
<a name="ln345">			&amp;list, &amp;count);</a>
<a name="ln346">	}</a>
<a name="ln347"> </a>
<a name="ln348">	if (gInfo-&gt;mode_list_area &lt; B_OK)</a>
<a name="ln349">		return gInfo-&gt;mode_list_area;</a>
<a name="ln350"> </a>
<a name="ln351">	gInfo-&gt;mode_list = list;</a>
<a name="ln352">	gInfo-&gt;shared_info-&gt;mode_list_area = gInfo-&gt;mode_list_area;</a>
<a name="ln353">	gInfo-&gt;shared_info-&gt;mode_count = count;</a>
<a name="ln354"> </a>
<a name="ln355">	return B_OK;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358"> </a>
<a name="ln359">void</a>
<a name="ln360">wait_for_vblank(void)</a>
<a name="ln361">{</a>
<a name="ln362">	acquire_sem_etc(gInfo-&gt;shared_info-&gt;vblank_sem, 1, B_RELATIVE_TIMEOUT,</a>
<a name="ln363">		25000);</a>
<a name="ln364">		// With the output turned off via DPMS, we might not get any interrupts</a>
<a name="ln365">		// anymore that's why we don't wait forever for it.</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368"> </a>
<a name="ln369">//	#pragma mark -</a>
<a name="ln370"> </a>
<a name="ln371"> </a>
<a name="ln372">uint32</a>
<a name="ln373">intel_accelerant_mode_count(void)</a>
<a name="ln374">{</a>
<a name="ln375">	CALLED();</a>
<a name="ln376">	return gInfo-&gt;shared_info-&gt;mode_count;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379"> </a>
<a name="ln380">status_t</a>
<a name="ln381">intel_get_mode_list(display_mode* modeList)</a>
<a name="ln382">{</a>
<a name="ln383">	CALLED();</a>
<a name="ln384">	memcpy(modeList, gInfo-&gt;mode_list,</a>
<a name="ln385">		gInfo-&gt;shared_info-&gt;mode_count * sizeof(display_mode));</a>
<a name="ln386">	return B_OK;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">status_t</a>
<a name="ln391">intel_propose_display_mode(display_mode* target, const display_mode* low,</a>
<a name="ln392">	const display_mode* high)</a>
<a name="ln393">{</a>
<a name="ln394">	CALLED();</a>
<a name="ln395"> </a>
<a name="ln396">	// first search for the specified mode in the list, if no mode is found</a>
<a name="ln397">	// try to fix the target mode in sanitize_display_mode</a>
<a name="ln398">	// TODO: Only sanitize_display_mode should be used. However, at the moments</a>
<a name="ln399">	// the mode constraints are not optimal and do not work for all</a>
<a name="ln400">	// configurations.</a>
<a name="ln401">	for (uint32 i = 0; i &lt; gInfo-&gt;shared_info-&gt;mode_count; i++) {</a>
<a name="ln402">		display_mode *mode = &amp;gInfo-&gt;mode_list[i];</a>
<a name="ln403"> </a>
<a name="ln404">		// TODO: improve this, ie. adapt pixel clock to allowed values!!!</a>
<a name="ln405"> </a>
<a name="ln406">		if (target-&gt;virtual_width != mode-&gt;virtual_width</a>
<a name="ln407">			|| target-&gt;virtual_height != mode-&gt;virtual_height</a>
<a name="ln408">			|| target-&gt;space != mode-&gt;space) {</a>
<a name="ln409">			continue;</a>
<a name="ln410">		}</a>
<a name="ln411"> </a>
<a name="ln412">		*target = *mode;</a>
<a name="ln413">		return B_OK;</a>
<a name="ln414">	}</a>
<a name="ln415"> </a>
<a name="ln416">	sanitize_display_mode(*target);</a>
<a name="ln417"> </a>
<a name="ln418">	return is_display_mode_within_bounds(*target, *low, *high)</a>
<a name="ln419">		? B_OK : B_BAD_VALUE;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">status_t</a>
<a name="ln424">intel_set_display_mode(display_mode* mode)</a>
<a name="ln425">{</a>
<a name="ln426">	TRACE(&quot;%s(%&quot; B_PRIu16 &quot;x%&quot; B_PRIu16 &quot;)\n&quot;, __func__,</a>
<a name="ln427">		mode-&gt;virtual_width, mode-&gt;virtual_height);</a>
<a name="ln428"> </a>
<a name="ln429">	if (mode == NULL)</a>
<a name="ln430">		return B_BAD_VALUE;</a>
<a name="ln431"> </a>
<a name="ln432">	display_mode target = *mode;</a>
<a name="ln433"> </a>
<a name="ln434">	// TODO: it may be acceptable to continue when using panel fitting or</a>
<a name="ln435">	// centering, since the data from propose_display_mode will not actually be</a>
<a name="ln436">	// used as is in this case.</a>
<a name="ln437">	if (sanitize_display_mode(target)) {</a>
<a name="ln438">		TRACE(&quot;Video mode was adjusted by sanitize_display_mode\n&quot;);</a>
<a name="ln439">		TRACE(&quot;Initial mode: Hd %d Hs %d He %d Ht %d Vd %d Vs %d Ve %d Vt %d\n&quot;,</a>
<a name="ln440">			mode-&gt;timing.h_display, mode-&gt;timing.h_sync_start,</a>
<a name="ln441">			mode-&gt;timing.h_sync_end, mode-&gt;timing.h_total,</a>
<a name="ln442">			mode-&gt;timing.v_display, mode-&gt;timing.v_sync_start,</a>
<a name="ln443">			mode-&gt;timing.v_sync_end, mode-&gt;timing.v_total);</a>
<a name="ln444">		TRACE(&quot;Sanitized: Hd %d Hs %d He %d Ht %d Vd %d Vs %d Ve %d Vt %d\n&quot;,</a>
<a name="ln445">			target.timing.h_display, target.timing.h_sync_start,</a>
<a name="ln446">			target.timing.h_sync_end, target.timing.h_total,</a>
<a name="ln447">			target.timing.v_display, target.timing.v_sync_start,</a>
<a name="ln448">			target.timing.v_sync_end, target.timing.v_total);</a>
<a name="ln449">	}</a>
<a name="ln450"> </a>
<a name="ln451">	uint32 colorMode, bytesPerRow, bitsPerPixel;</a>
<a name="ln452">	get_color_space_format(target, colorMode, bytesPerRow, bitsPerPixel);</a>
<a name="ln453"> </a>
<a name="ln454">	// TODO: do not go further if the mode is identical to the current one.</a>
<a name="ln455">	// This would avoid the screen being off when switching workspaces when they</a>
<a name="ln456">	// have the same resolution.</a>
<a name="ln457"> </a>
<a name="ln458">	intel_shared_info &amp;sharedInfo = *gInfo-&gt;shared_info;</a>
<a name="ln459">	Autolock locker(sharedInfo.accelerant_lock);</a>
<a name="ln460"> </a>
<a name="ln461">	// First register dump</a>
<a name="ln462">	//dump_registers();</a>
<a name="ln463"> </a>
<a name="ln464">	// TODO: This may not be neccesary</a>
<a name="ln465">	set_display_power_mode(B_DPMS_OFF);</a>
<a name="ln466"> </a>
<a name="ln467">	// free old and allocate new frame buffer in graphics memory</a>
<a name="ln468"> </a>
<a name="ln469">	intel_free_memory(sharedInfo.frame_buffer);</a>
<a name="ln470"> </a>
<a name="ln471">	addr_t base;</a>
<a name="ln472">	if (intel_allocate_memory(bytesPerRow * target.virtual_height, 0,</a>
<a name="ln473">			base) &lt; B_OK) {</a>
<a name="ln474">		// oh, how did that happen? Unfortunately, there is no really good way</a>
<a name="ln475">		// back</a>
<a name="ln476">		if (intel_allocate_memory(gInfo-&gt;current_mode.virtual_height</a>
<a name="ln477">				* sharedInfo.bytes_per_row, 0, base) == B_OK) {</a>
<a name="ln478">			sharedInfo.frame_buffer = base;</a>
<a name="ln479">			sharedInfo.frame_buffer_offset = base</a>
<a name="ln480">				- (addr_t)sharedInfo.graphics_memory;</a>
<a name="ln481">			set_frame_buffer_base();</a>
<a name="ln482">		}</a>
<a name="ln483"> </a>
<a name="ln484">		TRACE(&quot;%s: Failed to allocate framebuffer !\n&quot;, __func__);</a>
<a name="ln485">		return B_NO_MEMORY;</a>
<a name="ln486">	}</a>
<a name="ln487"> </a>
<a name="ln488">	// clear frame buffer before using it</a>
<a name="ln489">	memset((uint8*)base, 0, bytesPerRow * target.virtual_height);</a>
<a name="ln490">	sharedInfo.frame_buffer = base;</a>
<a name="ln491">	sharedInfo.frame_buffer_offset = base - (addr_t)sharedInfo.graphics_memory;</a>
<a name="ln492"> </a>
<a name="ln493">#if 0</a>
<a name="ln494">	if ((gInfo-&gt;head_mode &amp; HEAD_MODE_TESTING) != 0) {</a>
<a name="ln495">		// 1. Enable panel power as needed to retrieve panel configuration</a>
<a name="ln496">		// (use AUX VDD enable bit)</a>
<a name="ln497">			// skip, did detection already, might need that before that though</a>
<a name="ln498"> </a>
<a name="ln499">		// 2. Enable PCH clock reference source and PCH SSC modulator,</a>
<a name="ln500">		// wait for warmup (Can be done anytime before enabling port)</a>
<a name="ln501">			// skip, most certainly already set up by bios to use other ports,</a>
<a name="ln502">			// will need for coldstart though</a>
<a name="ln503"> </a>
<a name="ln504">		// 3. If enabling CPU embedded DisplayPort A: (Can be done anytime</a>
<a name="ln505">		// before enabling CPU pipe or port)</a>
<a name="ln506">		//	a.	Enable PCH 120MHz clock source output to CPU, wait for DMI</a>
<a name="ln507">		//		latency</a>
<a name="ln508">		//	b.	Configure and enable CPU DisplayPort PLL in the DisplayPort A</a>
<a name="ln509">		//		register, wait for warmup</a>
<a name="ln510">			// skip, not doing eDP right now, should go into</a>
<a name="ln511">			// EmbeddedDisplayPort class though</a>
<a name="ln512"> </a>
<a name="ln513">		// 4. If enabling port on PCH: (Must be done before enabling CPU pipe</a>
<a name="ln514">		// or FDI)</a>
<a name="ln515">		//	a.	Enable PCH FDI Receiver PLL, wait for warmup plus DMI latency</a>
<a name="ln516">		//	b.	Switch from Rawclk to PCDclk in FDI Receiver (FDI A OR FDI B)</a>
<a name="ln517">		//	c.	[DevSNB] Enable CPU FDI Transmitter PLL, wait for warmup</a>
<a name="ln518">		//	d.	[DevILK] CPU FDI PLL is always on and does not need to be</a>
<a name="ln519">		//		enabled</a>
<a name="ln520">		FDILink* link = pipe-&gt;FDILink();</a>
<a name="ln521">		if (link != NULL) {</a>
<a name="ln522">			link-&gt;Receiver().EnablePLL();</a>
<a name="ln523">			link-&gt;Receiver().SwitchClock(true);</a>
<a name="ln524">			link-&gt;Transmitter().EnablePLL();</a>
<a name="ln525">		}</a>
<a name="ln526"> </a>
<a name="ln527">		// 5. Enable CPU panel fitter if needed for hires, required for VGA</a>
<a name="ln528">		// (Can be done anytime before enabling CPU pipe)</a>
<a name="ln529">		PanelFitter* fitter = pipe-&gt;PanelFitter();</a>
<a name="ln530">		if (fitter != NULL)</a>
<a name="ln531">			fitter-&gt;Enable(mode);</a>
<a name="ln532"> </a>
<a name="ln533">		// 6. Configure CPU pipe timings, M/N/TU, and other pipe settings</a>
<a name="ln534">		// (Can be done anytime before enabling CPU pipe)</a>
<a name="ln535">		pll_divisors divisors;</a>
<a name="ln536">		compute_pll_divisors(target, divisors, false);</a>
<a name="ln537">		pipe-&gt;ConfigureTimings(divisors);</a>
<a name="ln538"> </a>
<a name="ln539">		// 7. Enable CPU pipe</a>
<a name="ln540">		pipe-&gt;Enable();</a>
<a name="ln541"> </a>
<a name="ln542">8. Configure and enable CPU planes (VGA or hires)</a>
<a name="ln543">9. If enabling port on PCH:</a>
<a name="ln544">		//	a.   Program PCH FDI Receiver TU size same as Transmitter TU size for TU error checking</a>
<a name="ln545">		//	b.   Train FDI</a>
<a name="ln546">		//		i. Set pre-emphasis and voltage (iterate if training steps fail)</a>
<a name="ln547">                    ii. Enable CPU FDI Transmitter and PCH FDI Receiver with Training Pattern 1 enabled.</a>
<a name="ln548">                   iii. Wait for FDI training pattern 1 time</a>
<a name="ln549">                   iv. Read PCH FDI Receiver ISR ([DevIBX-B+] IIR) for bit lock in bit 8 (retry at least once if no lock)</a>
<a name="ln550">                    v. Enable training pattern 2 on CPU FDI Transmitter and PCH FDI Receiver</a>
<a name="ln551">                   vi.  Wait for FDI training pattern 2 time</a>
<a name="ln552">                  vii. Read PCH FDI Receiver ISR ([DevIBX-B+] IIR) for symbol lock in bit 9 (retry at least once if no</a>
<a name="ln553">                        lock)</a>
<a name="ln554">                  viii. Enable normal pixel output on CPU FDI Transmitter and PCH FDI Receiver</a>
<a name="ln555">                   ix.  Wait for FDI idle pattern time for link to become active</a>
<a name="ln556">         c.   Configure and enable PCH DPLL, wait for PCH DPLL warmup (Can be done anytime before enabling</a>
<a name="ln557">              PCH transcoder)</a>
<a name="ln558">         d.   [DevCPT] Configure DPLL SEL to set the DPLL to transcoder mapping and enable DPLL to the</a>
<a name="ln559">              transcoder.</a>
<a name="ln560">         e.   [DevCPT] Configure DPLL_CTL DPLL_HDMI_multipler.</a>
<a name="ln561">         f.   Configure PCH transcoder timings, M/N/TU, and other transcoder settings (should match CPU settings).</a>
<a name="ln562">         g.   [DevCPT] Configure and enable Transcoder DisplayPort Control if DisplayPort will be used</a>
<a name="ln563">         h.   Enable PCH transcoder</a>
<a name="ln564">10. Enable ports (DisplayPort must enable in training pattern 1)</a>
<a name="ln565">11. Enable panel power through panel power sequencing</a>
<a name="ln566">12. Wait for panel power sequencing to reach enabled steady state</a>
<a name="ln567">13. Disable panel power override</a>
<a name="ln568">14. If DisplayPort, complete link training</a>
<a name="ln569">15. Enable panel backlight</a>
<a name="ln570">	}</a>
<a name="ln571">#endif</a>
<a name="ln572"> </a>
<a name="ln573">	// make sure VGA display is disabled</a>
<a name="ln574">	write32(INTEL_VGA_DISPLAY_CONTROL, VGA_DISPLAY_DISABLED);</a>
<a name="ln575">	read32(INTEL_VGA_DISPLAY_CONTROL);</a>
<a name="ln576"> </a>
<a name="ln577">	// Go over each port and set the display mode</a>
<a name="ln578">	for (uint32 i = 0; i &lt; gInfo-&gt;port_count; i++) {</a>
<a name="ln579">		if (gInfo-&gt;ports[i] == NULL)</a>
<a name="ln580">			continue;</a>
<a name="ln581">		if (!gInfo-&gt;ports[i]-&gt;IsConnected())</a>
<a name="ln582">			continue;</a>
<a name="ln583"> </a>
<a name="ln584">		status_t status = gInfo-&gt;ports[i]-&gt;SetDisplayMode(&amp;target, colorMode);</a>
<a name="ln585">		if (status != B_OK)</a>
<a name="ln586">			ERROR(&quot;%s: Unable to set display mode!\n&quot;, __func__);</a>
<a name="ln587">	}</a>
<a name="ln588"> </a>
<a name="ln589">	TRACE(&quot;%s: Port configuration completed successfully!\n&quot;, __func__);</a>
<a name="ln590"> </a>
<a name="ln591">	// We set the same color mode across all pipes</a>
<a name="ln592">	program_pipe_color_modes(colorMode);</a>
<a name="ln593"> </a>
<a name="ln594">	// TODO: This may not be neccesary (see DPMS OFF at top)</a>
<a name="ln595">	set_display_power_mode(sharedInfo.dpms_mode);</a>
<a name="ln596"> </a>
<a name="ln597">	// Changing bytes per row seems to be ignored if the plane/pipe is turned</a>
<a name="ln598">	// off</a>
<a name="ln599"> </a>
<a name="ln600">	// Always set both pipes, just in case</a>
<a name="ln601">	// TODO rework this when we get multiple head support with different</a>
<a name="ln602">	// resolutions</a>
<a name="ln603">	write32(INTEL_DISPLAY_A_BYTES_PER_ROW, bytesPerRow);</a>
<a name="ln604">	write32(INTEL_DISPLAY_B_BYTES_PER_ROW, bytesPerRow);</a>
<a name="ln605"> </a>
<a name="ln606">	// update shared info</a>
<a name="ln607">	gInfo-&gt;current_mode = target;</a>
<a name="ln608"> </a>
<a name="ln609">	// TODO: move to gInfo</a>
<a name="ln610">	sharedInfo.bytes_per_row = bytesPerRow;</a>
<a name="ln611">	sharedInfo.bits_per_pixel = bitsPerPixel;</a>
<a name="ln612"> </a>
<a name="ln613">	set_frame_buffer_base();</a>
<a name="ln614">		// triggers writing back double-buffered registers</a>
<a name="ln615"> </a>
<a name="ln616">	// Second register dump</a>
<a name="ln617">	//dump_registers();</a>
<a name="ln618"> </a>
<a name="ln619">	return B_OK;</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622"> </a>
<a name="ln623">status_t</a>
<a name="ln624">intel_get_display_mode(display_mode* _currentMode)</a>
<a name="ln625">{</a>
<a name="ln626">	CALLED();</a>
<a name="ln627"> </a>
<a name="ln628">	*_currentMode = gInfo-&gt;current_mode;</a>
<a name="ln629"> </a>
<a name="ln630">	// This seems unreliable. We should always know the current_mode</a>
<a name="ln631">	//retrieve_current_mode(*_currentMode, INTEL_DISPLAY_A_PLL);</a>
<a name="ln632">	return B_OK;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635"> </a>
<a name="ln636">status_t</a>
<a name="ln637">intel_get_edid_info(void* info, size_t size, uint32* _version)</a>
<a name="ln638">{</a>
<a name="ln639">	CALLED();</a>
<a name="ln640"> </a>
<a name="ln641">	if (!gInfo-&gt;has_edid)</a>
<a name="ln642">		return B_ERROR;</a>
<a name="ln643">	if (size &lt; sizeof(struct edid1_info))</a>
<a name="ln644">		return B_BUFFER_OVERFLOW;</a>
<a name="ln645"> </a>
<a name="ln646">	memcpy(info, &amp;gInfo-&gt;edid_info, sizeof(struct edid1_info));</a>
<a name="ln647">	*_version = EDID_VERSION_1;</a>
<a name="ln648">	return B_OK;</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651"> </a>
<a name="ln652">static int32_t</a>
<a name="ln653">intel_get_backlight_register(bool read)</a>
<a name="ln654">{</a>
<a name="ln655">	if (gInfo-&gt;shared_info-&gt;pch_info == INTEL_PCH_NONE)</a>
<a name="ln656">		return MCH_BLC_PWM_CTL;</a>
<a name="ln657">	</a>
<a name="ln658">	if (read)</a>
<a name="ln659">		return PCH_SBLC_PWM_CTL2;</a>
<a name="ln660">	else</a>
<a name="ln661">		return PCH_BLC_PWM_CTL;</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664"> </a>
<a name="ln665">status_t</a>
<a name="ln666">intel_set_brightness(float brightness)</a>
<a name="ln667">{</a>
<a name="ln668">	CALLED();</a>
<a name="ln669"> </a>
<a name="ln670">	if (brightness &lt; 0 || brightness &gt; 1)</a>
<a name="ln671">		return B_BAD_VALUE;</a>
<a name="ln672"> </a>
<a name="ln673">	uint32_t period = read32(intel_get_backlight_register(true)) &gt;&gt; 16;</a>
<a name="ln674">	uint32_t duty = (uint32_t)(period * brightness) &amp; 0xfffe;</a>
<a name="ln675">		/* Setting the low bit seems to give strange results on some Atom machines */</a>
<a name="ln676">	write32(intel_get_backlight_register(false), duty | (period &lt;&lt; 16));</a>
<a name="ln677"> </a>
<a name="ln678">	return B_OK;</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681"> </a>
<a name="ln682">status_t</a>
<a name="ln683">intel_get_brightness(float* brightness)</a>
<a name="ln684">{</a>
<a name="ln685">	CALLED();</a>
<a name="ln686"> </a>
<a name="ln687">	if (brightness == NULL)</a>
<a name="ln688">		return B_BAD_VALUE;</a>
<a name="ln689"> </a>
<a name="ln690">	uint16_t period = read32(intel_get_backlight_register(true)) &gt;&gt; 16;</a>
<a name="ln691">	uint16_t   duty = read32(intel_get_backlight_register(false)) &amp; 0xffff;</a>
<a name="ln692">	*brightness = (float)duty / period;</a>
<a name="ln693"> </a>
<a name="ln694">	return B_OK;</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697"> </a>
<a name="ln698">status_t</a>
<a name="ln699">intel_get_frame_buffer_config(frame_buffer_config* config)</a>
<a name="ln700">{</a>
<a name="ln701">	CALLED();</a>
<a name="ln702"> </a>
<a name="ln703">	uint32 offset = gInfo-&gt;shared_info-&gt;frame_buffer_offset;</a>
<a name="ln704"> </a>
<a name="ln705">	config-&gt;frame_buffer = gInfo-&gt;shared_info-&gt;graphics_memory + offset;</a>
<a name="ln706">	config-&gt;frame_buffer_dma</a>
<a name="ln707">		= (uint8*)gInfo-&gt;shared_info-&gt;physical_graphics_memory + offset;</a>
<a name="ln708">	config-&gt;bytes_per_row = gInfo-&gt;shared_info-&gt;bytes_per_row;</a>
<a name="ln709"> </a>
<a name="ln710">	return B_OK;</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">status_t</a>
<a name="ln715">intel_get_pixel_clock_limits(display_mode* mode, uint32* _low, uint32* _high)</a>
<a name="ln716">{</a>
<a name="ln717">	CALLED();</a>
<a name="ln718"> </a>
<a name="ln719">	if (_low != NULL) {</a>
<a name="ln720">		// lower limit of about 48Hz vertical refresh</a>
<a name="ln721">		uint32 totalClocks = (uint32)mode-&gt;timing.h_total</a>
<a name="ln722">			* (uint32)mode-&gt;timing.v_total;</a>
<a name="ln723">		uint32 low = (totalClocks * 48L) / 1000L;</a>
<a name="ln724">		if (low &lt; gInfo-&gt;shared_info-&gt;pll_info.min_frequency)</a>
<a name="ln725">			low = gInfo-&gt;shared_info-&gt;pll_info.min_frequency;</a>
<a name="ln726">		else if (low &gt; gInfo-&gt;shared_info-&gt;pll_info.max_frequency)</a>
<a name="ln727">			return B_ERROR;</a>
<a name="ln728"> </a>
<a name="ln729">		*_low = low;</a>
<a name="ln730">	}</a>
<a name="ln731"> </a>
<a name="ln732">	if (_high != NULL)</a>
<a name="ln733">		*_high = gInfo-&gt;shared_info-&gt;pll_info.max_frequency;</a>
<a name="ln734"> </a>
<a name="ln735">	return B_OK;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">status_t</a>
<a name="ln740">intel_move_display(uint16 horizontalStart, uint16 verticalStart)</a>
<a name="ln741">{</a>
<a name="ln742">	CALLED();</a>
<a name="ln743"> </a>
<a name="ln744">	intel_shared_info &amp;sharedInfo = *gInfo-&gt;shared_info;</a>
<a name="ln745">	Autolock locker(sharedInfo.accelerant_lock);</a>
<a name="ln746"> </a>
<a name="ln747">	display_mode &amp;mode = gInfo-&gt;current_mode;</a>
<a name="ln748"> </a>
<a name="ln749">	if (horizontalStart + mode.timing.h_display &gt; mode.virtual_width</a>
<a name="ln750">		|| verticalStart + mode.timing.v_display &gt; mode.virtual_height)</a>
<a name="ln751">		return B_BAD_VALUE;</a>
<a name="ln752"> </a>
<a name="ln753">	mode.h_display_start = horizontalStart;</a>
<a name="ln754">	mode.v_display_start = verticalStart;</a>
<a name="ln755"> </a>
<a name="ln756">	set_frame_buffer_base();</a>
<a name="ln757"> </a>
<a name="ln758">	return B_OK;</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761"> </a>
<a name="ln762">status_t</a>
<a name="ln763">intel_get_timing_constraints(display_timing_constraints* constraints)</a>
<a name="ln764">{</a>
<a name="ln765">	CALLED();</a>
<a name="ln766">	return B_ERROR;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">void</a>
<a name="ln771">intel_set_indexed_colors(uint count, uint8 first, uint8* colors, uint32 flags)</a>
<a name="ln772">{</a>
<a name="ln773">	TRACE(&quot;%s(colors = %p, first = %u)\n&quot;, __func__, colors, first);</a>
<a name="ln774"> </a>
<a name="ln775">	if (colors == NULL)</a>
<a name="ln776">		return;</a>
<a name="ln777"> </a>
<a name="ln778">	Autolock locker(gInfo-&gt;shared_info-&gt;accelerant_lock);</a>
<a name="ln779"> </a>
<a name="ln780">	for (; count-- &gt; 0; first++) {</a>
<a name="ln781">		uint32 color = colors[0] &lt;&lt; 16 | colors[1] &lt;&lt; 8 | colors[2];</a>
<a name="ln782">		colors += 3;</a>
<a name="ln783"> </a>
<a name="ln784">		write32(INTEL_DISPLAY_A_PALETTE + first * sizeof(uint32), color);</a>
<a name="ln785">		write32(INTEL_DISPLAY_B_PALETTE + first * sizeof(uint32), color);</a>
<a name="ln786">	}</a>
<a name="ln787">}</a>

</code></pre>
<div class="balloon" rel="426"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'mode' pointer was utilized before it was verified against nullptr. Check lines: 426, 429.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
