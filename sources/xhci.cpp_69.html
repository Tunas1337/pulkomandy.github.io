
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-11" />
  <title>xhci.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2011-2019, Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Augustin Cavalier &lt;waddlesplash&gt;</a>
<a name="ln7"> *		Jian Chiang &lt;j.jian.chiang@gmail.com&gt;</a>
<a name="ln8"> *		Jérôme Duval &lt;jerome.duval@gmail.com&gt;</a>
<a name="ln9"> *		Akshay Jaggi &lt;akshay1994.leo@gmail.com&gt;</a>
<a name="ln10"> *		Michael Lotz &lt;mmlr@mlotz.ch&gt;</a>
<a name="ln11"> */</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;module.h&gt;</a>
<a name="ln15">#include &lt;PCI.h&gt;</a>
<a name="ln16">#include &lt;PCI_x86.h&gt;</a>
<a name="ln17">#include &lt;USB3.h&gt;</a>
<a name="ln18">#include &lt;KernelExport.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;util/AutoLock.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;xhci.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#define USB_MODULE_NAME	&quot;xhci&quot;</a>
<a name="ln25"> </a>
<a name="ln26">pci_module_info *XHCI::sPCIModule = NULL;</a>
<a name="ln27">pci_x86_module_info *XHCI::sPCIx86Module = NULL;</a>
<a name="ln28"> </a>
<a name="ln29"> </a>
<a name="ln30">static int32</a>
<a name="ln31">xhci_std_ops(int32 op, ...)</a>
<a name="ln32">{</a>
<a name="ln33">	switch (op) {</a>
<a name="ln34">		case B_MODULE_INIT:</a>
<a name="ln35">			TRACE_MODULE(&quot;xhci init module\n&quot;);</a>
<a name="ln36">			return B_OK;</a>
<a name="ln37">		case B_MODULE_UNINIT:</a>
<a name="ln38">			TRACE_MODULE(&quot;xhci uninit module\n&quot;);</a>
<a name="ln39">			return B_OK;</a>
<a name="ln40">	}</a>
<a name="ln41"> </a>
<a name="ln42">	return EINVAL;</a>
<a name="ln43">}</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">static const char*</a>
<a name="ln47">xhci_error_string(uint32 error)</a>
<a name="ln48">{</a>
<a name="ln49">	switch (error) {</a>
<a name="ln50">		case COMP_INVALID: return &quot;Invalid&quot;;</a>
<a name="ln51">		case COMP_SUCCESS: return &quot;Success&quot;;</a>
<a name="ln52">		case COMP_DATA_BUFFER: return &quot;Data buffer&quot;;</a>
<a name="ln53">		case COMP_BABBLE: return &quot;Babble detected&quot;;</a>
<a name="ln54">		case COMP_USB_TRANSACTION: return &quot;USB transaction&quot;;</a>
<a name="ln55">		case COMP_TRB: return &quot;TRB&quot;;</a>
<a name="ln56">		case COMP_STALL: return &quot;Stall&quot;;</a>
<a name="ln57">		case COMP_RESOURCE: return &quot;Resource&quot;;</a>
<a name="ln58">		case COMP_BANDWIDTH: return &quot;Bandwidth&quot;;</a>
<a name="ln59">		case COMP_NO_SLOTS: return &quot;No slots&quot;;</a>
<a name="ln60">		case COMP_INVALID_STREAM: return &quot;Invalid stream&quot;;</a>
<a name="ln61">		case COMP_SLOT_NOT_ENABLED: return &quot;Slot not enabled&quot;;</a>
<a name="ln62">		case COMP_ENDPOINT_NOT_ENABLED: return &quot;Endpoint not enabled&quot;;</a>
<a name="ln63">		case COMP_SHORT_PACKET: return &quot;Short packet&quot;;</a>
<a name="ln64">		case COMP_RING_UNDERRUN: return &quot;Ring underrun&quot;;</a>
<a name="ln65">		case COMP_RING_OVERRUN: return &quot;Ring overrun&quot;;</a>
<a name="ln66">		case COMP_VF_RING_FULL: return &quot;VF Event Ring Full&quot;;</a>
<a name="ln67">		case COMP_PARAMETER: return &quot;Parameter&quot;;</a>
<a name="ln68">		case COMP_BANDWIDTH_OVERRUN: return &quot;Bandwidth overrun&quot;;</a>
<a name="ln69">		case COMP_CONTEXT_STATE: return &quot;Context state&quot;;</a>
<a name="ln70">		case COMP_NO_PING_RESPONSE: return &quot;No ping response&quot;;</a>
<a name="ln71">		case COMP_EVENT_RING_FULL: return &quot;Event ring full&quot;;</a>
<a name="ln72">		case COMP_INCOMPATIBLE_DEVICE: return &quot;Incompatible device&quot;;</a>
<a name="ln73">		case COMP_MISSED_SERVICE: return &quot;Missed service&quot;;</a>
<a name="ln74">		case COMP_COMMAND_RING_STOPPED: return &quot;Command ring stopped&quot;;</a>
<a name="ln75">		case COMP_COMMAND_ABORTED: return &quot;Command aborted&quot;;</a>
<a name="ln76">		case COMP_STOPPED: return &quot;Stopped&quot;;</a>
<a name="ln77">		case COMP_LENGTH_INVALID: return &quot;Length invalid&quot;;</a>
<a name="ln78">		case COMP_MAX_EXIT_LATENCY: return &quot;Max exit latency too large&quot;;</a>
<a name="ln79">		case COMP_ISOC_OVERRUN: return &quot;Isoch buffer overrun&quot;;</a>
<a name="ln80">		case COMP_EVENT_LOST: return &quot;Event lost&quot;;</a>
<a name="ln81">		case COMP_UNDEFINED: return &quot;Undefined&quot;;</a>
<a name="ln82">		case COMP_INVALID_STREAM_ID: return &quot;Invalid stream ID&quot;;</a>
<a name="ln83">		case COMP_SECONDARY_BANDWIDTH: return &quot;Secondary bandwidth&quot;;</a>
<a name="ln84">		case COMP_SPLIT_TRANSACTION: return &quot;Split transaction&quot;;</a>
<a name="ln85"> </a>
<a name="ln86">		default: return &quot;Undefined&quot;;</a>
<a name="ln87">	}</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">usb_host_controller_info xhci_module = {</a>
<a name="ln92">	{</a>
<a name="ln93">		&quot;busses/usb/xhci&quot;,</a>
<a name="ln94">		0,</a>
<a name="ln95">		xhci_std_ops</a>
<a name="ln96">	},</a>
<a name="ln97">	NULL,</a>
<a name="ln98">	XHCI::AddTo</a>
<a name="ln99">};</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">module_info *modules[] = {</a>
<a name="ln103">	(module_info *)&amp;xhci_module,</a>
<a name="ln104">	NULL</a>
<a name="ln105">};</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">status_t</a>
<a name="ln109">XHCI::AddTo(Stack *stack)</a>
<a name="ln110">{</a>
<a name="ln111">	if (!sPCIModule) {</a>
<a name="ln112">		status_t status = get_module(B_PCI_MODULE_NAME,</a>
<a name="ln113">			(module_info **)&amp;sPCIModule);</a>
<a name="ln114">		if (status &lt; B_OK) {</a>
<a name="ln115">			TRACE_MODULE_ERROR(&quot;getting pci module failed! 0x%08&quot; B_PRIx32</a>
<a name="ln116">				&quot;\n&quot;, status);</a>
<a name="ln117">			return status;</a>
<a name="ln118">		}</a>
<a name="ln119">	}</a>
<a name="ln120"> </a>
<a name="ln121">	TRACE_MODULE(&quot;searching devices\n&quot;);</a>
<a name="ln122">	bool found = false;</a>
<a name="ln123">	pci_info *item = new(std::nothrow) pci_info;</a>
<a name="ln124">	if (item == NULL) {</a>
<a name="ln125">		sPCIModule = NULL;</a>
<a name="ln126">		put_module(B_PCI_MODULE_NAME);</a>
<a name="ln127">		return B_NO_MEMORY;</a>
<a name="ln128">	}</a>
<a name="ln129"> </a>
<a name="ln130">	// Try to get the PCI x86 module as well so we can enable possible MSIs.</a>
<a name="ln131">	if (sPCIx86Module == NULL &amp;&amp; get_module(B_PCI_X86_MODULE_NAME,</a>
<a name="ln132">			(module_info **)&amp;sPCIx86Module) != B_OK) {</a>
<a name="ln133">		// If it isn't there, that's not critical though.</a>
<a name="ln134">		TRACE_MODULE_ERROR(&quot;failed to get pci x86 module\n&quot;);</a>
<a name="ln135">		sPCIx86Module = NULL;</a>
<a name="ln136">	}</a>
<a name="ln137"> </a>
<a name="ln138">	for (int32 i = 0; sPCIModule-&gt;get_nth_pci_info(i, item) &gt;= B_OK; i++) {</a>
<a name="ln139">		if (item-&gt;class_base == PCI_serial_bus &amp;&amp; item-&gt;class_sub == PCI_usb</a>
<a name="ln140">			&amp;&amp; item-&gt;class_api == PCI_usb_xhci) {</a>
<a name="ln141">			TRACE_MODULE(&quot;found device at PCI:%d:%d:%d\n&quot;,</a>
<a name="ln142">				item-&gt;bus, item-&gt;device, item-&gt;function);</a>
<a name="ln143">			XHCI *bus = new(std::nothrow) XHCI(item, stack);</a>
<a name="ln144">			if (bus == NULL) {</a>
<a name="ln145">				delete item;</a>
<a name="ln146">				sPCIModule = NULL;</a>
<a name="ln147">				put_module(B_PCI_MODULE_NAME);</a>
<a name="ln148">				if (sPCIx86Module != NULL)</a>
<a name="ln149">					put_module(B_PCI_X86_MODULE_NAME);</a>
<a name="ln150">				return B_NO_MEMORY;</a>
<a name="ln151">			}</a>
<a name="ln152"> </a>
<a name="ln153">			// The bus will put the PCI modules when it is destroyed, so get</a>
<a name="ln154">			// them again to increase their reference count.</a>
<a name="ln155">			get_module(B_PCI_MODULE_NAME, (module_info **)&amp;sPCIModule);</a>
<a name="ln156">			if (sPCIx86Module != NULL)</a>
<a name="ln157">				get_module(B_PCI_X86_MODULE_NAME, (module_info **)&amp;sPCIx86Module);</a>
<a name="ln158"> </a>
<a name="ln159">			if (bus-&gt;InitCheck() &lt; B_OK) {</a>
<a name="ln160">				TRACE_MODULE_ERROR(&quot;bus failed init check\n&quot;);</a>
<a name="ln161">				delete bus;</a>
<a name="ln162">				continue;</a>
<a name="ln163">			}</a>
<a name="ln164"> </a>
<a name="ln165">			// the bus took it away</a>
<a name="ln166">			item = new(std::nothrow) pci_info;</a>
<a name="ln167"> </a>
<a name="ln168">			if (bus-&gt;Start() != B_OK) {</a>
<a name="ln169">				delete bus;</a>
<a name="ln170">				continue;</a>
<a name="ln171">			}</a>
<a name="ln172">			found = true;</a>
<a name="ln173">		}</a>
<a name="ln174">	}</a>
<a name="ln175"> </a>
<a name="ln176">	// The modules will have been gotten again if we successfully</a>
<a name="ln177">	// initialized a bus, so we should put them here.</a>
<a name="ln178">	put_module(B_PCI_MODULE_NAME);</a>
<a name="ln179">	if (sPCIx86Module != NULL)</a>
<a name="ln180">		put_module(B_PCI_X86_MODULE_NAME);</a>
<a name="ln181"> </a>
<a name="ln182">	if (!found)</a>
<a name="ln183">		TRACE_MODULE_ERROR(&quot;no devices found\n&quot;);</a>
<a name="ln184">	delete item;</a>
<a name="ln185">	return found ? B_OK : ENODEV;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">XHCI::XHCI(pci_info *info, Stack *stack)</a>
<a name="ln190">	:	BusManager(stack),</a>
<a name="ln191">		fRegisterArea(-1),</a>
<a name="ln192">		fRegisters(NULL),</a>
<a name="ln193">		fPCIInfo(info),</a>
<a name="ln194">		fStack(stack),</a>
<a name="ln195">		fIRQ(0),</a>
<a name="ln196">		fUseMSI(false),</a>
<a name="ln197">		fErstArea(-1),</a>
<a name="ln198">		fDcbaArea(-1),</a>
<a name="ln199">		fCmdCompSem(-1),</a>
<a name="ln200">		fStopThreads(false),</a>
<a name="ln201">		fRootHub(NULL),</a>
<a name="ln202">		fRootHubAddress(0),</a>
<a name="ln203">		fPortCount(0),</a>
<a name="ln204">		fSlotCount(0),</a>
<a name="ln205">		fScratchpadCount(0),</a>
<a name="ln206">		fContextSizeShift(0),</a>
<a name="ln207">		fFinishedHead(NULL),</a>
<a name="ln208">		fFinishTransfersSem(-1),</a>
<a name="ln209">		fFinishThread(-1),</a>
<a name="ln210">		fEventSem(-1),</a>
<a name="ln211">		fEventThread(-1),</a>
<a name="ln212">		fEventIdx(0),</a>
<a name="ln213">		fCmdIdx(0),</a>
<a name="ln214">		fEventCcs(1),</a>
<a name="ln215">		fCmdCcs(1)</a>
<a name="ln216">{</a>
<a name="ln217">	B_INITIALIZE_SPINLOCK(&amp;fSpinlock);</a>
<a name="ln218">	mutex_init(&amp;fFinishedLock, &quot;XHCI finished transfers&quot;);</a>
<a name="ln219">	mutex_init(&amp;fEventLock, &quot;XHCI event handler&quot;);</a>
<a name="ln220"> </a>
<a name="ln221">	if (BusManager::InitCheck() &lt; B_OK) {</a>
<a name="ln222">		TRACE_ERROR(&quot;bus manager failed to init\n&quot;);</a>
<a name="ln223">		return;</a>
<a name="ln224">	}</a>
<a name="ln225"> </a>
<a name="ln226">	TRACE(&quot;constructing new XHCI host controller driver\n&quot;);</a>
<a name="ln227">	fInitOK = false;</a>
<a name="ln228"> </a>
<a name="ln229">	// enable busmaster and memory mapped access</a>
<a name="ln230">	uint16 command = sPCIModule-&gt;read_pci_config(fPCIInfo-&gt;bus,</a>
<a name="ln231">		fPCIInfo-&gt;device, fPCIInfo-&gt;function, PCI_command, 2);</a>
<a name="ln232">	command &amp;= ~(PCI_command_io | PCI_command_int_disable);</a>
<a name="ln233">	command |= PCI_command_master | PCI_command_memory;</a>
<a name="ln234"> </a>
<a name="ln235">	sPCIModule-&gt;write_pci_config(fPCIInfo-&gt;bus, fPCIInfo-&gt;device,</a>
<a name="ln236">		fPCIInfo-&gt;function, PCI_command, 2, command);</a>
<a name="ln237"> </a>
<a name="ln238">	// map the registers (low + high for 64-bit when requested)</a>
<a name="ln239">	phys_addr_t physicalAddress = fPCIInfo-&gt;u.h0.base_registers[0];</a>
<a name="ln240">	physicalAddress &amp;= PCI_address_memory_32_mask;</a>
<a name="ln241">	if ((fPCIInfo-&gt;u.h0.base_register_flags[0] &amp; 0xC) == PCI_address_type_64)</a>
<a name="ln242">		physicalAddress += (phys_addr_t)fPCIInfo-&gt;u.h0.base_registers[1] &lt;&lt; 32;</a>
<a name="ln243"> </a>
<a name="ln244">	size_t mapSize = fPCIInfo-&gt;u.h0.base_register_sizes[0];</a>
<a name="ln245"> </a>
<a name="ln246">	TRACE(&quot;map physical memory %08&quot; B_PRIxPHYSADDR &quot;, size: %&quot; B_PRIuSIZE &quot;\n&quot;,</a>
<a name="ln247">		physicalAddress, mapSize);</a>
<a name="ln248"> </a>
<a name="ln249">	fRegisterArea = map_physical_memory(&quot;XHCI memory mapped registers&quot;,</a>
<a name="ln250">		physicalAddress, mapSize, B_ANY_KERNEL_BLOCK_ADDRESS,</a>
<a name="ln251">		B_KERNEL_READ_AREA | B_KERNEL_WRITE_AREA,</a>
<a name="ln252">		(void **)&amp;fRegisters);</a>
<a name="ln253">	if (fRegisterArea &lt; B_OK) {</a>
<a name="ln254">		TRACE_ERROR(&quot;failed to map register memory\n&quot;);</a>
<a name="ln255">		return;</a>
<a name="ln256">	}</a>
<a name="ln257"> </a>
<a name="ln258">	// determine the register offsets</a>
<a name="ln259">	fCapabilityRegisterOffset = 0;</a>
<a name="ln260">	fOperationalRegisterOffset = HCI_CAPLENGTH(ReadCapReg32(XHCI_HCI_CAPLENGTH));</a>
<a name="ln261">	fRuntimeRegisterOffset = ReadCapReg32(XHCI_RTSOFF) &amp; ~0x1F;</a>
<a name="ln262">	fDoorbellRegisterOffset = ReadCapReg32(XHCI_DBOFF) &amp; ~0x3;</a>
<a name="ln263"> </a>
<a name="ln264">	TRACE(&quot;mapped registers: %p\n&quot;, fRegisters);</a>
<a name="ln265">	TRACE(&quot;operational register offset: %&quot; B_PRId32 &quot;\n&quot;, fOperationalRegisterOffset);</a>
<a name="ln266">	TRACE(&quot;runtime register offset: %&quot; B_PRId32 &quot;\n&quot;, fRuntimeRegisterOffset);</a>
<a name="ln267">	TRACE(&quot;doorbell register offset: %&quot; B_PRId32 &quot;\n&quot;, fDoorbellRegisterOffset);</a>
<a name="ln268"> </a>
<a name="ln269">	TRACE_ALWAYS(&quot;interface version: 0x%04&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln270">		HCI_VERSION(ReadCapReg32(XHCI_HCI_VERSION)));</a>
<a name="ln271">	TRACE_ALWAYS(&quot;structural parameters: 1:0x%08&quot; B_PRIx32 &quot; 2:0x%08&quot;</a>
<a name="ln272">		B_PRIx32 &quot; 3:0x%08&quot; B_PRIx32 &quot;\n&quot;, ReadCapReg32(XHCI_HCSPARAMS1),</a>
<a name="ln273">		ReadCapReg32(XHCI_HCSPARAMS2), ReadCapReg32(XHCI_HCSPARAMS3));</a>
<a name="ln274"> </a>
<a name="ln275">	uint32 cparams = ReadCapReg32(XHCI_HCCPARAMS);</a>
<a name="ln276">	if (cparams == 0xffffffff)</a>
<a name="ln277">		return;</a>
<a name="ln278">	TRACE_ALWAYS(&quot;capability params: 0x%08&quot; B_PRIx32 &quot;\n&quot;, cparams);</a>
<a name="ln279"> </a>
<a name="ln280">	// if 64 bytes context structures, then 1</a>
<a name="ln281">	fContextSizeShift = HCC_CSZ(cparams);</a>
<a name="ln282"> </a>
<a name="ln283">	// Assume ownership of the controller from the BIOS.</a>
<a name="ln284">	uint32 eec = 0xffffffff;</a>
<a name="ln285">	uint32 eecp = HCS0_XECP(cparams) &lt;&lt; 2;</a>
<a name="ln286">	for (; eecp != 0 &amp;&amp; XECP_NEXT(eec); eecp += XECP_NEXT(eec) &lt;&lt; 2) {</a>
<a name="ln287">		TRACE(&quot;eecp register: 0x%08&quot; B_PRIx32 &quot;\n&quot;, eecp);</a>
<a name="ln288"> </a>
<a name="ln289">		eec = ReadCapReg32(eecp);</a>
<a name="ln290">		if (XECP_ID(eec) != XHCI_LEGSUP_CAPID)</a>
<a name="ln291">			continue;</a>
<a name="ln292"> </a>
<a name="ln293">		if (eec &amp; XHCI_LEGSUP_BIOSOWNED) {</a>
<a name="ln294">			TRACE_ALWAYS(&quot;the host controller is bios owned, claiming&quot;</a>
<a name="ln295">				&quot; ownership\n&quot;);</a>
<a name="ln296">			WriteCapReg32(eecp, eec | XHCI_LEGSUP_OSOWNED);</a>
<a name="ln297"> </a>
<a name="ln298">			for (int32 i = 0; i &lt; 20; i++) {</a>
<a name="ln299">				eec = ReadCapReg32(eecp);</a>
<a name="ln300"> </a>
<a name="ln301">				if ((eec &amp; XHCI_LEGSUP_BIOSOWNED) == 0)</a>
<a name="ln302">					break;</a>
<a name="ln303"> </a>
<a name="ln304">				TRACE_ALWAYS(&quot;controller is still bios owned, waiting\n&quot;);</a>
<a name="ln305">				snooze(50000);</a>
<a name="ln306">			}</a>
<a name="ln307"> </a>
<a name="ln308">			if (eec &amp; XHCI_LEGSUP_BIOSOWNED) {</a>
<a name="ln309">				TRACE_ERROR(&quot;bios won't give up control over the host &quot;</a>
<a name="ln310">					&quot;controller (ignoring)\n&quot;);</a>
<a name="ln311">			} else if (eec &amp; XHCI_LEGSUP_OSOWNED) {</a>
<a name="ln312">				TRACE_ALWAYS(&quot;successfully took ownership of the host &quot;</a>
<a name="ln313">					&quot;controller\n&quot;);</a>
<a name="ln314">			}</a>
<a name="ln315"> </a>
<a name="ln316">			// Force off the BIOS owned flag, and clear all SMIs. Some BIOSes</a>
<a name="ln317">			// do indicate a successful handover but do not remove their SMIs</a>
<a name="ln318">			// and then freeze the system when interrupts are generated.</a>
<a name="ln319">			WriteCapReg32(eecp, eec &amp; ~XHCI_LEGSUP_BIOSOWNED);</a>
<a name="ln320">		}</a>
<a name="ln321">		break;</a>
<a name="ln322">	}</a>
<a name="ln323">	uint32 legctlsts = ReadCapReg32(eecp + XHCI_LEGCTLSTS);</a>
<a name="ln324">	legctlsts &amp;= XHCI_LEGCTLSTS_DISABLE_SMI;</a>
<a name="ln325">	legctlsts |= XHCI_LEGCTLSTS_EVENTS_SMI;</a>
<a name="ln326">	WriteCapReg32(eecp + XHCI_LEGCTLSTS, legctlsts);</a>
<a name="ln327"> </a>
<a name="ln328">	// On Intel's Panther Point and Lynx Point Chipset taking ownership</a>
<a name="ln329">	// of EHCI owned ports, is what we do here.</a>
<a name="ln330">	if (fPCIInfo-&gt;vendor_id == PCI_VENDOR_INTEL) {</a>
<a name="ln331">		switch (fPCIInfo-&gt;device_id) {</a>
<a name="ln332">			case PCI_DEVICE_INTEL_PANTHER_POINT_XHCI:</a>
<a name="ln333">			case PCI_DEVICE_INTEL_LYNX_POINT_XHCI:</a>
<a name="ln334">			case PCI_DEVICE_INTEL_LYNX_POINT_LP_XHCI:</a>
<a name="ln335">			case PCI_DEVICE_INTEL_BAYTRAIL_XHCI:</a>
<a name="ln336">			case PCI_DEVICE_INTEL_WILDCAT_POINT_XHCI:</a>
<a name="ln337">			case PCI_DEVICE_INTEL_WILDCAT_POINT_LP_XHCI:</a>
<a name="ln338">				_SwitchIntelPorts();</a>
<a name="ln339">				break;</a>
<a name="ln340">		}</a>
<a name="ln341">	}</a>
<a name="ln342"> </a>
<a name="ln343">	// halt the host controller</a>
<a name="ln344">	if (ControllerHalt() &lt; B_OK) {</a>
<a name="ln345">		return;</a>
<a name="ln346">	}</a>
<a name="ln347"> </a>
<a name="ln348">	// reset the host controller</a>
<a name="ln349">	if (ControllerReset() &lt; B_OK) {</a>
<a name="ln350">		TRACE_ERROR(&quot;host controller failed to reset\n&quot;);</a>
<a name="ln351">		return;</a>
<a name="ln352">	}</a>
<a name="ln353"> </a>
<a name="ln354">	fCmdCompSem = create_sem(0, &quot;XHCI Command Complete&quot;);</a>
<a name="ln355">	fFinishTransfersSem = create_sem(0, &quot;XHCI Finish Transfers&quot;);</a>
<a name="ln356">	fEventSem = create_sem(0, &quot;XHCI Event&quot;);</a>
<a name="ln357">	if (fFinishTransfersSem &lt; B_OK || fCmdCompSem &lt; B_OK || fEventSem &lt; B_OK) {</a>
<a name="ln358">		TRACE_ERROR(&quot;failed to create semaphores\n&quot;);</a>
<a name="ln359">		return;</a>
<a name="ln360">	}</a>
<a name="ln361"> </a>
<a name="ln362">	// create finisher service thread</a>
<a name="ln363">	fFinishThread = spawn_kernel_thread(FinishThread, &quot;xhci finish thread&quot;,</a>
<a name="ln364">		B_NORMAL_PRIORITY, (void *)this);</a>
<a name="ln365">	resume_thread(fFinishThread);</a>
<a name="ln366"> </a>
<a name="ln367">	// create finisher service thread</a>
<a name="ln368">	fEventThread = spawn_kernel_thread(EventThread, &quot;xhci event thread&quot;,</a>
<a name="ln369">		B_NORMAL_PRIORITY, (void *)this);</a>
<a name="ln370">	resume_thread(fEventThread);</a>
<a name="ln371"> </a>
<a name="ln372">	// Find the right interrupt vector, using MSIs if available.</a>
<a name="ln373">	fIRQ = fPCIInfo-&gt;u.h0.interrupt_line;</a>
<a name="ln374">	if (sPCIx86Module != NULL &amp;&amp; sPCIx86Module-&gt;get_msi_count(fPCIInfo-&gt;bus,</a>
<a name="ln375">			fPCIInfo-&gt;device, fPCIInfo-&gt;function) &gt;= 1) {</a>
<a name="ln376">		uint8 msiVector = 0;</a>
<a name="ln377">		if (sPCIx86Module-&gt;configure_msi(fPCIInfo-&gt;bus, fPCIInfo-&gt;device,</a>
<a name="ln378">				fPCIInfo-&gt;function, 1, &amp;msiVector) == B_OK</a>
<a name="ln379">			&amp;&amp; sPCIx86Module-&gt;enable_msi(fPCIInfo-&gt;bus, fPCIInfo-&gt;device,</a>
<a name="ln380">				fPCIInfo-&gt;function) == B_OK) {</a>
<a name="ln381">			TRACE_ALWAYS(&quot;using message signaled interrupts\n&quot;);</a>
<a name="ln382">			fIRQ = msiVector;</a>
<a name="ln383">			fUseMSI = true;</a>
<a name="ln384">		}</a>
<a name="ln385">	}</a>
<a name="ln386"> </a>
<a name="ln387">	if (fIRQ == 0 || fIRQ == 0xFF) {</a>
<a name="ln388">		TRACE_MODULE_ERROR(&quot;device PCI:%d:%d:%d was assigned an invalid IRQ\n&quot;,</a>
<a name="ln389">			fPCIInfo-&gt;bus, fPCIInfo-&gt;device, fPCIInfo-&gt;function);</a>
<a name="ln390">		return;</a>
<a name="ln391">	}</a>
<a name="ln392"> </a>
<a name="ln393">	// Install the interrupt handler</a>
<a name="ln394">	TRACE(&quot;installing interrupt handler\n&quot;);</a>
<a name="ln395">	install_io_interrupt_handler(fIRQ, InterruptHandler, (void *)this, 0);</a>
<a name="ln396"> </a>
<a name="ln397">	memset(fPortSpeeds, 0, sizeof(fPortSpeeds));</a>
<a name="ln398">	memset(fPortSlots, 0, sizeof(fPortSlots));</a>
<a name="ln399">	memset(fDevices, 0, sizeof(fDevices));</a>
<a name="ln400"> </a>
<a name="ln401">	fInitOK = true;</a>
<a name="ln402">	TRACE(&quot;XHCI host controller driver constructed\n&quot;);</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405"> </a>
<a name="ln406">XHCI::~XHCI()</a>
<a name="ln407">{</a>
<a name="ln408">	TRACE(&quot;tear down XHCI host controller driver\n&quot;);</a>
<a name="ln409"> </a>
<a name="ln410">	WriteOpReg(XHCI_CMD, 0);</a>
<a name="ln411"> </a>
<a name="ln412">	int32 result = 0;</a>
<a name="ln413">	fStopThreads = true;</a>
<a name="ln414">	delete_sem(fCmdCompSem);</a>
<a name="ln415">	delete_sem(fFinishTransfersSem);</a>
<a name="ln416">	delete_sem(fEventSem);</a>
<a name="ln417">	wait_for_thread(fFinishThread, &amp;result);</a>
<a name="ln418">	wait_for_thread(fEventThread, &amp;result);</a>
<a name="ln419"> </a>
<a name="ln420">	mutex_destroy(&amp;fFinishedLock);</a>
<a name="ln421">	mutex_destroy(&amp;fEventLock);</a>
<a name="ln422"> </a>
<a name="ln423">	remove_io_interrupt_handler(fIRQ, InterruptHandler, (void *)this);</a>
<a name="ln424"> </a>
<a name="ln425">	delete_area(fRegisterArea);</a>
<a name="ln426">	delete_area(fErstArea);</a>
<a name="ln427">	for (uint32 i = 0; i &lt; fScratchpadCount; i++)</a>
<a name="ln428">		delete_area(fScratchpadArea[i]);</a>
<a name="ln429">	delete_area(fDcbaArea);</a>
<a name="ln430"> </a>
<a name="ln431">	if (fUseMSI &amp;&amp; sPCIx86Module != NULL) {</a>
<a name="ln432">		sPCIx86Module-&gt;disable_msi(fPCIInfo-&gt;bus,</a>
<a name="ln433">			fPCIInfo-&gt;device, fPCIInfo-&gt;function);</a>
<a name="ln434">		sPCIx86Module-&gt;unconfigure_msi(fPCIInfo-&gt;bus,</a>
<a name="ln435">			fPCIInfo-&gt;device, fPCIInfo-&gt;function);</a>
<a name="ln436">	}</a>
<a name="ln437">	put_module(B_PCI_MODULE_NAME);</a>
<a name="ln438">	if (sPCIx86Module != NULL)</a>
<a name="ln439">		put_module(B_PCI_X86_MODULE_NAME);</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442"> </a>
<a name="ln443">void</a>
<a name="ln444">XHCI::_SwitchIntelPorts()</a>
<a name="ln445">{</a>
<a name="ln446">	TRACE(&quot;Intel xHC Controller\n&quot;);</a>
<a name="ln447">	TRACE(&quot;Looking for EHCI owned ports\n&quot;);</a>
<a name="ln448">	uint32 ports = sPCIModule-&gt;read_pci_config(fPCIInfo-&gt;bus,</a>
<a name="ln449">		fPCIInfo-&gt;device, fPCIInfo-&gt;function, XHCI_INTEL_USB3PRM, 4);</a>
<a name="ln450">	TRACE(&quot;Superspeed Ports: 0x%&quot; B_PRIx32 &quot;\n&quot;, ports);</a>
<a name="ln451">	sPCIModule-&gt;write_pci_config(fPCIInfo-&gt;bus, fPCIInfo-&gt;device,</a>
<a name="ln452">		fPCIInfo-&gt;function, XHCI_INTEL_USB3_PSSEN, 4, ports);</a>
<a name="ln453">	ports = sPCIModule-&gt;read_pci_config(fPCIInfo-&gt;bus,</a>
<a name="ln454">		fPCIInfo-&gt;device, fPCIInfo-&gt;function, XHCI_INTEL_USB3_PSSEN, 4);</a>
<a name="ln455">	TRACE(&quot;Superspeed ports now under XHCI : 0x%&quot; B_PRIx32 &quot;\n&quot;, ports);</a>
<a name="ln456">	ports = sPCIModule-&gt;read_pci_config(fPCIInfo-&gt;bus,</a>
<a name="ln457">		fPCIInfo-&gt;device, fPCIInfo-&gt;function, XHCI_INTEL_USB2PRM, 4);</a>
<a name="ln458">	TRACE(&quot;USB 2.0 Ports : 0x%&quot; B_PRIx32 &quot;\n&quot;, ports);</a>
<a name="ln459">	sPCIModule-&gt;write_pci_config(fPCIInfo-&gt;bus, fPCIInfo-&gt;device,</a>
<a name="ln460">		fPCIInfo-&gt;function, XHCI_INTEL_XUSB2PR, 4, ports);</a>
<a name="ln461">	ports = sPCIModule-&gt;read_pci_config(fPCIInfo-&gt;bus,</a>
<a name="ln462">		fPCIInfo-&gt;device, fPCIInfo-&gt;function, XHCI_INTEL_XUSB2PR, 4);</a>
<a name="ln463">	TRACE(&quot;USB 2.0 ports now under XHCI: 0x%&quot; B_PRIx32 &quot;\n&quot;, ports);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">status_t</a>
<a name="ln468">XHCI::Start()</a>
<a name="ln469">{</a>
<a name="ln470">	TRACE_ALWAYS(&quot;starting XHCI host controller\n&quot;);</a>
<a name="ln471">	TRACE(&quot;usbcmd: 0x%08&quot; B_PRIx32 &quot;; usbsts: 0x%08&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln472">		ReadOpReg(XHCI_CMD), ReadOpReg(XHCI_STS));</a>
<a name="ln473"> </a>
<a name="ln474">	if (WaitOpBits(XHCI_STS, STS_CNR, 0) != B_OK) {</a>
<a name="ln475">		TRACE(&quot;Start() failed STS_CNR\n&quot;);</a>
<a name="ln476">	}</a>
<a name="ln477"> </a>
<a name="ln478">	if ((ReadOpReg(XHCI_CMD) &amp; CMD_RUN) != 0) {</a>
<a name="ln479">		TRACE_ERROR(&quot;Start() warning, starting running XHCI controller!\n&quot;);</a>
<a name="ln480">	}</a>
<a name="ln481"> </a>
<a name="ln482">	if ((ReadOpReg(XHCI_PAGESIZE) &amp; (1 &lt;&lt; 0)) == 0) {</a>
<a name="ln483">		TRACE_ERROR(&quot;Controller does not support 4K page size.\n&quot;);</a>
<a name="ln484">		return B_ERROR;</a>
<a name="ln485">	}</a>
<a name="ln486"> </a>
<a name="ln487">	// read port count from capability register</a>
<a name="ln488">	uint32 capabilities = ReadCapReg32(XHCI_HCSPARAMS1);</a>
<a name="ln489">	fPortCount = HCS_MAX_PORTS(capabilities);</a>
<a name="ln490">	if (fPortCount == 0) {</a>
<a name="ln491">		TRACE_ERROR(&quot;Invalid number of ports: %u\n&quot;, fPortCount);</a>
<a name="ln492">		return B_ERROR;</a>
<a name="ln493">	}</a>
<a name="ln494"> </a>
<a name="ln495">	fSlotCount = HCS_MAX_SLOTS(capabilities);</a>
<a name="ln496">	if (fSlotCount &gt; XHCI_MAX_DEVICES)</a>
<a name="ln497">		fSlotCount = XHCI_MAX_DEVICES;</a>
<a name="ln498">	WriteOpReg(XHCI_CONFIG, fSlotCount);</a>
<a name="ln499"> </a>
<a name="ln500">	// find out which protocol is used for each port</a>
<a name="ln501">	uint8 portFound = 0;</a>
<a name="ln502">	uint32 cparams = ReadCapReg32(XHCI_HCCPARAMS);</a>
<a name="ln503">	uint32 eec = 0xffffffff;</a>
<a name="ln504">	uint32 eecp = HCS0_XECP(cparams) &lt;&lt; 2;</a>
<a name="ln505">	for (; eecp != 0 &amp;&amp; XECP_NEXT(eec) &amp;&amp; portFound &lt; fPortCount;</a>
<a name="ln506">		eecp += XECP_NEXT(eec) &lt;&lt; 2) {</a>
<a name="ln507">		eec = ReadCapReg32(eecp);</a>
<a name="ln508">		if (XECP_ID(eec) != XHCI_SUPPORTED_PROTOCOLS_CAPID)</a>
<a name="ln509">			continue;</a>
<a name="ln510">		if (XHCI_SUPPORTED_PROTOCOLS_0_MAJOR(eec) &gt; 3)</a>
<a name="ln511">			continue;</a>
<a name="ln512">		uint32 temp = ReadCapReg32(eecp + 8);</a>
<a name="ln513">		uint32 offset = XHCI_SUPPORTED_PROTOCOLS_1_OFFSET(temp);</a>
<a name="ln514">		uint32 count = XHCI_SUPPORTED_PROTOCOLS_1_COUNT(temp);</a>
<a name="ln515">		if (offset == 0 || count == 0)</a>
<a name="ln516">			continue;</a>
<a name="ln517">		offset--;</a>
<a name="ln518">		for (uint32 i = offset; i &lt; offset + count; i++) {</a>
<a name="ln519">			if (XHCI_SUPPORTED_PROTOCOLS_0_MAJOR(eec) == 0x3)</a>
<a name="ln520">				fPortSpeeds[i] = USB_SPEED_SUPER;</a>
<a name="ln521">			else</a>
<a name="ln522">				fPortSpeeds[i] = USB_SPEED_HIGHSPEED;</a>
<a name="ln523">			TRACE(&quot;speed for port %&quot; B_PRId32 &quot; is %s\n&quot;, i,</a>
<a name="ln524">				fPortSpeeds[i] == USB_SPEED_SUPER ? &quot;super&quot; : &quot;high&quot;);</a>
<a name="ln525">		}</a>
<a name="ln526">		portFound += count;</a>
<a name="ln527">	}</a>
<a name="ln528"> </a>
<a name="ln529">	uint32 params2 = ReadCapReg32(XHCI_HCSPARAMS2);</a>
<a name="ln530">	fScratchpadCount = HCS_MAX_SC_BUFFERS(params2);</a>
<a name="ln531">	if (fScratchpadCount &gt; XHCI_MAX_SCRATCHPADS) {</a>
<a name="ln532">		TRACE_ERROR(&quot;Invalid number of scratchpads: %&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln533">			fScratchpadCount);</a>
<a name="ln534">		return B_ERROR;</a>
<a name="ln535">	}</a>
<a name="ln536"> </a>
<a name="ln537">	uint32 params3 = ReadCapReg32(XHCI_HCSPARAMS3);</a>
<a name="ln538">	fExitLatMax = HCS_U1_DEVICE_LATENCY(params3)</a>
<a name="ln539">		+ HCS_U2_DEVICE_LATENCY(params3);</a>
<a name="ln540"> </a>
<a name="ln541">	// clear interrupts &amp; disable device notifications</a>
<a name="ln542">	WriteOpReg(XHCI_STS, ReadOpReg(XHCI_STS));</a>
<a name="ln543">	WriteOpReg(XHCI_DNCTRL, 0);</a>
<a name="ln544"> </a>
<a name="ln545">	// allocate Device Context Base Address array</a>
<a name="ln546">	phys_addr_t dmaAddress;</a>
<a name="ln547">	fDcbaArea = fStack-&gt;AllocateArea((void **)&amp;fDcba, &amp;dmaAddress,</a>
<a name="ln548">		sizeof(*fDcba), &quot;DCBA Area&quot;);</a>
<a name="ln549">	if (fDcbaArea &lt; B_OK) {</a>
<a name="ln550">		TRACE_ERROR(&quot;unable to create the DCBA area\n&quot;);</a>
<a name="ln551">		return B_ERROR;</a>
<a name="ln552">	}</a>
<a name="ln553">	memset(fDcba, 0, sizeof(*fDcba));</a>
<a name="ln554">	memset(fScratchpadArea, 0, sizeof(fScratchpadArea));</a>
<a name="ln555">	memset(fScratchpad, 0, sizeof(fScratchpad));</a>
<a name="ln556"> </a>
<a name="ln557">	// setting the first address to the scratchpad array address</a>
<a name="ln558">	fDcba-&gt;baseAddress[0] = dmaAddress</a>
<a name="ln559">		+ offsetof(struct xhci_device_context_array, scratchpad);</a>
<a name="ln560"> </a>
<a name="ln561">	// fill up the scratchpad array with scratchpad pages</a>
<a name="ln562">	for (uint32 i = 0; i &lt; fScratchpadCount; i++) {</a>
<a name="ln563">		phys_addr_t scratchDmaAddress;</a>
<a name="ln564">		fScratchpadArea[i] = fStack-&gt;AllocateArea((void **)&amp;fScratchpad[i],</a>
<a name="ln565">			&amp;scratchDmaAddress, B_PAGE_SIZE, &quot;Scratchpad Area&quot;);</a>
<a name="ln566">		if (fScratchpadArea[i] &lt; B_OK) {</a>
<a name="ln567">			TRACE_ERROR(&quot;unable to create the scratchpad area\n&quot;);</a>
<a name="ln568">			return B_ERROR;</a>
<a name="ln569">		}</a>
<a name="ln570">		fDcba-&gt;scratchpad[i] = scratchDmaAddress;</a>
<a name="ln571">	}</a>
<a name="ln572"> </a>
<a name="ln573">	TRACE(&quot;setting DCBAAP %&quot; B_PRIxPHYSADDR &quot;\n&quot;, dmaAddress);</a>
<a name="ln574">	WriteOpReg(XHCI_DCBAAP_LO, (uint32)dmaAddress);</a>
<a name="ln575">	WriteOpReg(XHCI_DCBAAP_HI, (uint32)(dmaAddress &gt;&gt; 32));</a>
<a name="ln576"> </a>
<a name="ln577">	// allocate Event Ring Segment Table</a>
<a name="ln578">	uint8 *addr;</a>
<a name="ln579">	fErstArea = fStack-&gt;AllocateArea((void **)&amp;addr, &amp;dmaAddress,</a>
<a name="ln580">		(XHCI_MAX_COMMANDS + XHCI_MAX_EVENTS) * sizeof(xhci_trb)</a>
<a name="ln581">		+ sizeof(xhci_erst_element),</a>
<a name="ln582">		&quot;USB XHCI ERST CMD_RING and EVENT_RING Area&quot;);</a>
<a name="ln583"> </a>
<a name="ln584">	if (fErstArea &lt; B_OK) {</a>
<a name="ln585">		TRACE_ERROR(&quot;unable to create the ERST AND RING area\n&quot;);</a>
<a name="ln586">		delete_area(fDcbaArea);</a>
<a name="ln587">		return B_ERROR;</a>
<a name="ln588">	}</a>
<a name="ln589">	fErst = (xhci_erst_element *)addr;</a>
<a name="ln590">	memset(fErst, 0, (XHCI_MAX_COMMANDS + XHCI_MAX_EVENTS) * sizeof(xhci_trb)</a>
<a name="ln591">		+ sizeof(xhci_erst_element));</a>
<a name="ln592"> </a>
<a name="ln593">	// fill with Event Ring Segment Base Address and Event Ring Segment Size</a>
<a name="ln594">	fErst-&gt;rs_addr = dmaAddress + sizeof(xhci_erst_element);</a>
<a name="ln595">	fErst-&gt;rs_size = XHCI_MAX_EVENTS;</a>
<a name="ln596">	fErst-&gt;rsvdz = 0;</a>
<a name="ln597"> </a>
<a name="ln598">	addr += sizeof(xhci_erst_element);</a>
<a name="ln599">	fEventRing = (xhci_trb *)addr;</a>
<a name="ln600">	addr += XHCI_MAX_EVENTS * sizeof(xhci_trb);</a>
<a name="ln601">	fCmdRing = (xhci_trb *)addr;</a>
<a name="ln602"> </a>
<a name="ln603">	TRACE(&quot;setting ERST size\n&quot;);</a>
<a name="ln604">	WriteRunReg32(XHCI_ERSTSZ(0), XHCI_ERSTS_SET(1));</a>
<a name="ln605"> </a>
<a name="ln606">	TRACE(&quot;setting ERDP addr = 0x%&quot; B_PRIx64 &quot;\n&quot;, fErst-&gt;rs_addr);</a>
<a name="ln607">	WriteRunReg32(XHCI_ERDP_LO(0), (uint32)fErst-&gt;rs_addr);</a>
<a name="ln608">	WriteRunReg32(XHCI_ERDP_HI(0), (uint32)(fErst-&gt;rs_addr &gt;&gt; 32));</a>
<a name="ln609"> </a>
<a name="ln610">	TRACE(&quot;setting ERST base addr = 0x%&quot; B_PRIxPHYSADDR &quot;\n&quot;, dmaAddress);</a>
<a name="ln611">	WriteRunReg32(XHCI_ERSTBA_LO(0), (uint32)dmaAddress);</a>
<a name="ln612">	WriteRunReg32(XHCI_ERSTBA_HI(0), (uint32)(dmaAddress &gt;&gt; 32));</a>
<a name="ln613"> </a>
<a name="ln614">	dmaAddress += sizeof(xhci_erst_element) + XHCI_MAX_EVENTS</a>
<a name="ln615">		* sizeof(xhci_trb);</a>
<a name="ln616"> </a>
<a name="ln617">	// Make sure the Command Ring is stopped</a>
<a name="ln618">	if ((ReadOpReg(XHCI_CRCR_LO) &amp; CRCR_CRR) != 0) {</a>
<a name="ln619">		TRACE_ALWAYS(&quot;Command Ring is running, send stop/cancel\n&quot;);</a>
<a name="ln620">		WriteOpReg(XHCI_CRCR_LO, CRCR_CS);</a>
<a name="ln621">		WriteOpReg(XHCI_CRCR_HI, 0);</a>
<a name="ln622">		WriteOpReg(XHCI_CRCR_LO, CRCR_CA);</a>
<a name="ln623">		WriteOpReg(XHCI_CRCR_HI, 0);</a>
<a name="ln624">		snooze(1000);</a>
<a name="ln625">		if ((ReadOpReg(XHCI_CRCR_LO) &amp; CRCR_CRR) != 0) {</a>
<a name="ln626">			TRACE_ERROR(&quot;Command Ring still running after stop/cancel\n&quot;);</a>
<a name="ln627">		}</a>
<a name="ln628">	}</a>
<a name="ln629">	TRACE(&quot;setting CRCR addr = 0x%&quot; B_PRIxPHYSADDR &quot;\n&quot;, dmaAddress);</a>
<a name="ln630">	WriteOpReg(XHCI_CRCR_LO, (uint32)dmaAddress | CRCR_RCS);</a>
<a name="ln631">	WriteOpReg(XHCI_CRCR_HI, (uint32)(dmaAddress &gt;&gt; 32));</a>
<a name="ln632">	// link trb</a>
<a name="ln633">	fCmdRing[XHCI_MAX_COMMANDS - 1].address = dmaAddress;</a>
<a name="ln634"> </a>
<a name="ln635">	TRACE(&quot;setting interrupt rate\n&quot;);</a>
<a name="ln636"> </a>
<a name="ln637">	// Setting IMOD below 0x3F8 on Intel Lynx Point can cause IRQ lockups</a>
<a name="ln638">	if (fPCIInfo-&gt;vendor_id == PCI_VENDOR_INTEL</a>
<a name="ln639">		&amp;&amp; (fPCIInfo-&gt;device_id == PCI_DEVICE_INTEL_PANTHER_POINT_XHCI</a>
<a name="ln640">			|| fPCIInfo-&gt;device_id == PCI_DEVICE_INTEL_LYNX_POINT_XHCI</a>
<a name="ln641">			|| fPCIInfo-&gt;device_id == PCI_DEVICE_INTEL_LYNX_POINT_LP_XHCI</a>
<a name="ln642">			|| fPCIInfo-&gt;device_id == PCI_DEVICE_INTEL_BAYTRAIL_XHCI</a>
<a name="ln643">			|| fPCIInfo-&gt;device_id == PCI_DEVICE_INTEL_WILDCAT_POINT_XHCI)) {</a>
<a name="ln644">		WriteRunReg32(XHCI_IMOD(0), 0x000003f8); // 4000 irq/s</a>
<a name="ln645">	} else {</a>
<a name="ln646">		WriteRunReg32(XHCI_IMOD(0), 0x000001f4); // 8000 irq/s</a>
<a name="ln647">	}</a>
<a name="ln648"> </a>
<a name="ln649">	TRACE(&quot;enabling interrupt\n&quot;);</a>
<a name="ln650">	WriteRunReg32(XHCI_IMAN(0), ReadRunReg32(XHCI_IMAN(0)) | IMAN_INTR_ENA);</a>
<a name="ln651"> </a>
<a name="ln652">	WriteOpReg(XHCI_CMD, CMD_RUN | CMD_INTE | CMD_HSEE);</a>
<a name="ln653"> </a>
<a name="ln654">	// wait for start up state</a>
<a name="ln655">	if (WaitOpBits(XHCI_STS, STS_HCH, 0) != B_OK) {</a>
<a name="ln656">		TRACE_ERROR(&quot;HCH start up timeout\n&quot;);</a>
<a name="ln657">	}</a>
<a name="ln658"> </a>
<a name="ln659">	fRootHubAddress = AllocateAddress();</a>
<a name="ln660">	fRootHub = new(std::nothrow) XHCIRootHub(RootObject(), fRootHubAddress);</a>
<a name="ln661">	if (!fRootHub) {</a>
<a name="ln662">		TRACE_ERROR(&quot;no memory to allocate root hub\n&quot;);</a>
<a name="ln663">		return B_NO_MEMORY;</a>
<a name="ln664">	}</a>
<a name="ln665"> </a>
<a name="ln666">	if (fRootHub-&gt;InitCheck() &lt; B_OK) {</a>
<a name="ln667">		TRACE_ERROR(&quot;root hub failed init check\n&quot;);</a>
<a name="ln668">		return fRootHub-&gt;InitCheck();</a>
<a name="ln669">	}</a>
<a name="ln670"> </a>
<a name="ln671">	SetRootHub(fRootHub);</a>
<a name="ln672"> </a>
<a name="ln673">	TRACE_ALWAYS(&quot;successfully started the controller\n&quot;);</a>
<a name="ln674">#ifdef TRACE_USB</a>
<a name="ln675">	TRACE(&quot;No-Op test...\n&quot;);</a>
<a name="ln676">	status_t noopResult = Noop();</a>
<a name="ln677">	TRACE(&quot;No-Op %ssuccessful\n&quot;, noopResult &lt; B_OK ? &quot;un&quot; : &quot;&quot;);</a>
<a name="ln678">#endif</a>
<a name="ln679"> </a>
<a name="ln680">	//DumpRing(fCmdRing, (XHCI_MAX_COMMANDS - 1));</a>
<a name="ln681"> </a>
<a name="ln682">	return BusManager::Start();</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">status_t</a>
<a name="ln687">XHCI::SubmitTransfer(Transfer *transfer)</a>
<a name="ln688">{</a>
<a name="ln689">	// short circuit the root hub</a>
<a name="ln690">	if (transfer-&gt;TransferPipe()-&gt;DeviceAddress() == fRootHubAddress)</a>
<a name="ln691">		return fRootHub-&gt;ProcessTransfer(this, transfer);</a>
<a name="ln692"> </a>
<a name="ln693">	TRACE(&quot;SubmitTransfer()\n&quot;);</a>
<a name="ln694">	Pipe *pipe = transfer-&gt;TransferPipe();</a>
<a name="ln695">	if ((pipe-&gt;Type() &amp; USB_OBJECT_ISO_PIPE) != 0)</a>
<a name="ln696">		return B_UNSUPPORTED;</a>
<a name="ln697">	if ((pipe-&gt;Type() &amp; USB_OBJECT_CONTROL_PIPE) != 0)</a>
<a name="ln698">		return SubmitControlRequest(transfer);</a>
<a name="ln699">	return SubmitNormalRequest(transfer);</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702"> </a>
<a name="ln703">status_t</a>
<a name="ln704">XHCI::SubmitControlRequest(Transfer *transfer)</a>
<a name="ln705">{</a>
<a name="ln706">	Pipe *pipe = transfer-&gt;TransferPipe();</a>
<a name="ln707">	usb_request_data *requestData = transfer-&gt;RequestData();</a>
<a name="ln708">	bool directionIn = (requestData-&gt;RequestType &amp; USB_REQTYPE_DEVICE_IN) != 0;</a>
<a name="ln709"> </a>
<a name="ln710">	xhci_endpoint *endpoint = (xhci_endpoint *)pipe-&gt;ControllerCookie();</a>
<a name="ln711">	if (endpoint == NULL) {</a>
<a name="ln712">		TRACE_ERROR(&quot;invalid endpoint!\n&quot;);</a>
<a name="ln713">		return B_BAD_VALUE;</a>
<a name="ln714">	}</a>
<a name="ln715">	status_t status = transfer-&gt;InitKernelAccess();</a>
<a name="ln716">	if (status != B_OK)</a>
<a name="ln717">		return status;</a>
<a name="ln718"> </a>
<a name="ln719">	TRACE(&quot;SubmitControlRequest() length %d\n&quot;, requestData-&gt;Length);</a>
<a name="ln720"> </a>
<a name="ln721">	xhci_td *descriptor = CreateDescriptor(3, 1, requestData-&gt;Length);</a>
<a name="ln722">	if (descriptor == NULL)</a>
<a name="ln723">		return B_NO_MEMORY;</a>
<a name="ln724">	descriptor-&gt;transfer = transfer;</a>
<a name="ln725"> </a>
<a name="ln726">	// Setup Stage</a>
<a name="ln727">	uint8 index = 0;</a>
<a name="ln728">	memcpy(&amp;descriptor-&gt;trbs[index].address, requestData,</a>
<a name="ln729">		sizeof(usb_request_data));</a>
<a name="ln730">	descriptor-&gt;trbs[index].status = TRB_2_IRQ(0) | TRB_2_BYTES(8);</a>
<a name="ln731">	descriptor-&gt;trbs[index].flags</a>
<a name="ln732">		= TRB_3_TYPE(TRB_TYPE_SETUP_STAGE) | TRB_3_IDT_BIT | TRB_3_CYCLE_BIT;</a>
<a name="ln733">	if (requestData-&gt;Length &gt; 0) {</a>
<a name="ln734">		descriptor-&gt;trbs[index].flags |=</a>
<a name="ln735">			directionIn ? TRB_3_TRT_IN : TRB_3_TRT_OUT;</a>
<a name="ln736">	}</a>
<a name="ln737"> </a>
<a name="ln738">	index++;</a>
<a name="ln739"> </a>
<a name="ln740">	// Data Stage (if any)</a>
<a name="ln741">	if (requestData-&gt;Length &gt; 0) {</a>
<a name="ln742">		descriptor-&gt;trbs[index].address = descriptor-&gt;buffer_addrs[0];</a>
<a name="ln743">		descriptor-&gt;trbs[index].status = TRB_2_IRQ(0)</a>
<a name="ln744">			| TRB_2_BYTES(requestData-&gt;Length)</a>
<a name="ln745">			| TRB_2_TD_SIZE(0);</a>
<a name="ln746">		descriptor-&gt;trbs[index].flags = TRB_3_TYPE(TRB_TYPE_DATA_STAGE)</a>
<a name="ln747">				| (directionIn ? (TRB_3_DIR_IN | TRB_3_ISP_BIT) : 0)</a>
<a name="ln748">				| TRB_3_CYCLE_BIT;</a>
<a name="ln749"> </a>
<a name="ln750">		if (!directionIn) {</a>
<a name="ln751">			transfer-&gt;PrepareKernelAccess();</a>
<a name="ln752">			memcpy(descriptor-&gt;buffers[0],</a>
<a name="ln753">				(uint8 *)transfer-&gt;Vector()[0].iov_base, requestData-&gt;Length);</a>
<a name="ln754">		}</a>
<a name="ln755"> </a>
<a name="ln756">		index++;</a>
<a name="ln757">	}</a>
<a name="ln758"> </a>
<a name="ln759">	// Status Stage</a>
<a name="ln760">	descriptor-&gt;trbs[index].address = 0;</a>
<a name="ln761">	descriptor-&gt;trbs[index].status = TRB_2_IRQ(0);</a>
<a name="ln762">	descriptor-&gt;trbs[index].flags = TRB_3_TYPE(TRB_TYPE_STATUS_STAGE)</a>
<a name="ln763">			| ((directionIn &amp;&amp; requestData-&gt;Length &gt; 0) ? 0 : TRB_3_DIR_IN)</a>
<a name="ln764">			| TRB_3_CHAIN_BIT | TRB_3_ENT_BIT | TRB_3_CYCLE_BIT;</a>
<a name="ln765">		// Status Stage is an OUT transfer when the device is sending data</a>
<a name="ln766">		// (XHCI 1.2 § 4.11.2.2 Table 4-7 p213), and the CHAIN bit must be</a>
<a name="ln767">		// set when using an Event Data TRB (as _LinkDescriptorForPipe does)</a>
<a name="ln768">		// (XHCI 1.2 § 6.4.1.2.3 Table 6-31 p472)</a>
<a name="ln769"> </a>
<a name="ln770">	descriptor-&gt;trb_used = index + 1;</a>
<a name="ln771"> </a>
<a name="ln772">	status = _LinkDescriptorForPipe(descriptor, endpoint);</a>
<a name="ln773">	if (status != B_OK) {</a>
<a name="ln774">		FreeDescriptor(descriptor);</a>
<a name="ln775">		return status;</a>
<a name="ln776">	}</a>
<a name="ln777">	TRACE(&quot;SubmitControlRequest() request linked\n&quot;);</a>
<a name="ln778"> </a>
<a name="ln779">	return B_OK;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782"> </a>
<a name="ln783">status_t</a>
<a name="ln784">XHCI::SubmitNormalRequest(Transfer *transfer)</a>
<a name="ln785">{</a>
<a name="ln786">	TRACE(&quot;SubmitNormalRequest() length %ld\n&quot;, transfer-&gt;DataLength());</a>
<a name="ln787"> </a>
<a name="ln788">	Pipe *pipe = transfer-&gt;TransferPipe();</a>
<a name="ln789">	xhci_endpoint *endpoint = (xhci_endpoint *)pipe-&gt;ControllerCookie();</a>
<a name="ln790">	if (endpoint == NULL)</a>
<a name="ln791">		return B_BAD_VALUE;</a>
<a name="ln792">	bool directionIn = (pipe-&gt;Direction() == Pipe::In);</a>
<a name="ln793"> </a>
<a name="ln794">	status_t status = transfer-&gt;InitKernelAccess();</a>
<a name="ln795">	if (status != B_OK)</a>
<a name="ln796">		return status;</a>
<a name="ln797"> </a>
<a name="ln798">	// Compute the size to use for the TRBs, and then how many TRBs</a>
<a name="ln799">	// of this size we will need. We always need at least 1, of course.</a>
<a name="ln800">	const size_t dataLength = transfer-&gt;DataLength(),</a>
<a name="ln801">		maxPacketSize = pipe-&gt;MaxPacketSize(),</a>
<a name="ln802">		packetsPerTrb = 4;</a>
<a name="ln803">	const size_t trbSize = packetsPerTrb * maxPacketSize;</a>
<a name="ln804">	int32 trbCount = (dataLength + trbSize - 1) / trbSize;</a>
<a name="ln805"> </a>
<a name="ln806">	xhci_td *td = CreateDescriptor(trbCount, trbCount, trbSize);</a>
<a name="ln807">	if (td == NULL)</a>
<a name="ln808">		return B_NO_MEMORY;</a>
<a name="ln809"> </a>
<a name="ln810">	// Normal Stage</a>
<a name="ln811">	size_t remaining = dataLength;</a>
<a name="ln812">	int32 remainingPackets = (remaining - trbSize) / maxPacketSize;</a>
<a name="ln813">	for (int32 i = 0; i &lt; trbCount; i++) {</a>
<a name="ln814">		// The &quot;TD Size&quot; field of a transfer TRB indicates the number of</a>
<a name="ln815">		// remaining maximum-size *packets* in this TD, *not* including the</a>
<a name="ln816">		// packets in the current TRB, and capped at 31 if there are more</a>
<a name="ln817">		// than 31 packets remaining in the TD. (XHCI 1.1 § 4.11.2.4 p210.)</a>
<a name="ln818">		int32 tdSize = remainingPackets &gt; 31 ? 31 : remainingPackets;</a>
<a name="ln819">		if (tdSize &lt; 0)</a>
<a name="ln820">			tdSize = 0;</a>
<a name="ln821">		int32 trbLength = remaining &lt; trbSize ? remaining : trbSize;</a>
<a name="ln822"> </a>
<a name="ln823">		td-&gt;trbs[i].address = td-&gt;buffer_addrs[i];</a>
<a name="ln824">		td-&gt;trbs[i].status = TRB_2_IRQ(0)</a>
<a name="ln825">			| TRB_2_BYTES(trbLength)</a>
<a name="ln826">			| TRB_2_TD_SIZE(tdSize);</a>
<a name="ln827">		td-&gt;trbs[i].flags = TRB_3_TYPE(TRB_TYPE_NORMAL)</a>
<a name="ln828">			| TRB_3_CYCLE_BIT | TRB_3_CHAIN_BIT</a>
<a name="ln829">			| (directionIn ? TRB_3_ISP_BIT : 0);</a>
<a name="ln830"> </a>
<a name="ln831">		td-&gt;trb_used++;</a>
<a name="ln832">		remaining -= trbLength;</a>
<a name="ln833">		remainingPackets -= packetsPerTrb;</a>
<a name="ln834">	}</a>
<a name="ln835"> </a>
<a name="ln836">	// Set the ENT (Evaluate Next TRB) bit, so that the HC will not switch</a>
<a name="ln837">	// contexts before evaluating the Link TRB that _LinkDescriptorForPipe</a>
<a name="ln838">	// will insert, as otherwise there would be a race between us freeing</a>
<a name="ln839">	// and unlinking the descriptor, and the controller evaluating the Link TRB</a>
<a name="ln840">	// and thus getting back onto the main ring and executing the Event Data</a>
<a name="ln841">	// TRB that generates the interrupt for this transfer.</a>
<a name="ln842">	//</a>
<a name="ln843">	// Note that we *do not* unset the CHAIN bit in this TRB, thus including</a>
<a name="ln844">	// the Link TRB in this TD formally, which is required when using the</a>
<a name="ln845">	// ENT bit. (XHCI 1.1 § 4.12.3 p241.)</a>
<a name="ln846">	td-&gt;trbs[td-&gt;trb_used - 1].flags |= TRB_3_ENT_BIT;</a>
<a name="ln847"> </a>
<a name="ln848">	if (!directionIn) {</a>
<a name="ln849">		TRACE(&quot;copying out iov count %ld\n&quot;, transfer-&gt;VectorCount());</a>
<a name="ln850">		transfer-&gt;PrepareKernelAccess();</a>
<a name="ln851">		WriteDescriptor(td, transfer-&gt;Vector(), transfer-&gt;VectorCount());</a>
<a name="ln852">	}</a>
<a name="ln853"> </a>
<a name="ln854">	td-&gt;transfer = transfer;</a>
<a name="ln855">	status = _LinkDescriptorForPipe(td, endpoint);</a>
<a name="ln856">	if (status != B_OK) {</a>
<a name="ln857">		FreeDescriptor(td);</a>
<a name="ln858">		return status;</a>
<a name="ln859">	}</a>
<a name="ln860">	TRACE(&quot;SubmitNormalRequest() request linked\n&quot;);</a>
<a name="ln861"> </a>
<a name="ln862">	return B_OK;</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865"> </a>
<a name="ln866">status_t</a>
<a name="ln867">XHCI::CancelQueuedTransfers(Pipe *pipe, bool force)</a>
<a name="ln868">{</a>
<a name="ln869">	TRACE_ALWAYS(&quot;cancel queued transfers for pipe %p (%d)\n&quot;, pipe,</a>
<a name="ln870">		pipe-&gt;EndpointAddress());</a>
<a name="ln871"> </a>
<a name="ln872">	xhci_endpoint *endpoint = (xhci_endpoint *)pipe-&gt;ControllerCookie();</a>
<a name="ln873">	if (endpoint == NULL || endpoint-&gt;trbs == NULL) {</a>
<a name="ln874">		// Someone's de-allocated this pipe or endpoint in the meantime.</a>
<a name="ln875">		// (Possibly AllocateDevice failed, and we were the temporary pipe.)</a>
<a name="ln876">		return B_NO_INIT;</a>
<a name="ln877">	}</a>
<a name="ln878"> </a>
<a name="ln879">	MutexLocker endpointLocker(endpoint-&gt;lock);</a>
<a name="ln880"> </a>
<a name="ln881">	if (endpoint-&gt;td_head == NULL) {</a>
<a name="ln882">		// There aren't any currently pending transfers to cancel.</a>
<a name="ln883">		return B_OK;</a>
<a name="ln884">	}</a>
<a name="ln885"> </a>
<a name="ln886">	// Get the head TD from the endpoint. We don't want to free the TDs while</a>
<a name="ln887">	// holding the endpoint lock, as the callbacks could potentially cause</a>
<a name="ln888">	// deadlocks.</a>
<a name="ln889">	xhci_td* td_head = endpoint-&gt;td_head;</a>
<a name="ln890">	endpoint-&gt;td_head = NULL;</a>
<a name="ln891"> </a>
<a name="ln892">	if (StopEndpoint(false, endpoint-&gt;id + 1, endpoint-&gt;device-&gt;slot) == B_OK) {</a>
<a name="ln893">		// Clear the endpoint's TRBs.</a>
<a name="ln894">		memset(endpoint-&gt;trbs, 0, sizeof(xhci_trb) * XHCI_ENDPOINT_RING_SIZE);</a>
<a name="ln895">		endpoint-&gt;used = 0;</a>
<a name="ln896">		endpoint-&gt;current = 0;</a>
<a name="ln897"> </a>
<a name="ln898">		// Set dequeue pointer location to the beginning of the ring.</a>
<a name="ln899">		SetTRDequeue(endpoint-&gt;trb_addr, 0, endpoint-&gt;id + 1,</a>
<a name="ln900">			endpoint-&gt;device-&gt;slot);</a>
<a name="ln901"> </a>
<a name="ln902">		// We don't need to do anything else to restart the ring, as it will resume</a>
<a name="ln903">		// operation as normal upon the next doorbell. (XHCI 1.1 § 4.6.9 p132.)</a>
<a name="ln904">	} else {</a>
<a name="ln905">		// We couldn't stop the endpoint. Most likely the device has been</a>
<a name="ln906">		// removed and the endpoint was stopped by the hardware.</a>
<a name="ln907">		TRACE(&quot;CancelQueuedTransfers: could not stop endpoint\n&quot;);</a>
<a name="ln908">	}</a>
<a name="ln909"> </a>
<a name="ln910">	endpointLocker.Unlock();</a>
<a name="ln911"> </a>
<a name="ln912">	xhci_td* td;</a>
<a name="ln913">	while ((td = td_head) != NULL) {</a>
<a name="ln914">		td_head = td_head-&gt;next;</a>
<a name="ln915"> </a>
<a name="ln916">		// We can't cancel or delete transfers under &quot;force&quot;, as they probably</a>
<a name="ln917">		// are not safe to use anymore.</a>
<a name="ln918">		if (!force &amp;&amp; td-&gt;transfer != NULL) {</a>
<a name="ln919">			td-&gt;transfer-&gt;Finished(B_CANCELED, 0);</a>
<a name="ln920">			delete td-&gt;transfer;</a>
<a name="ln921">			td-&gt;transfer = NULL;</a>
<a name="ln922">		}</a>
<a name="ln923">		FreeDescriptor(td);</a>
<a name="ln924">	}</a>
<a name="ln925"> </a>
<a name="ln926">	return B_OK;</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930">status_t</a>
<a name="ln931">XHCI::StartDebugTransfer(Transfer *transfer)</a>
<a name="ln932">{</a>
<a name="ln933">	Pipe *pipe = transfer-&gt;TransferPipe();</a>
<a name="ln934">	xhci_endpoint *endpoint = (xhci_endpoint *)pipe-&gt;ControllerCookie();</a>
<a name="ln935">	if (endpoint == NULL)</a>
<a name="ln936">		return B_BAD_VALUE;</a>
<a name="ln937"> </a>
<a name="ln938">	// Check all locks that we are going to hit when running transfers.</a>
<a name="ln939">	if (mutex_trylock(&amp;endpoint-&gt;lock) != B_OK)</a>
<a name="ln940">		return B_WOULD_BLOCK;</a>
<a name="ln941">	if (mutex_trylock(&amp;fFinishedLock) != B_OK) {</a>
<a name="ln942">		mutex_unlock(&amp;endpoint-&gt;lock);</a>
<a name="ln943">		return B_WOULD_BLOCK;</a>
<a name="ln944">	}</a>
<a name="ln945">	if (mutex_trylock(&amp;fEventLock) != B_OK) {</a>
<a name="ln946">		mutex_unlock(&amp;endpoint-&gt;lock);</a>
<a name="ln947">		mutex_unlock(&amp;fFinishedLock);</a>
<a name="ln948">		return B_WOULD_BLOCK;</a>
<a name="ln949">	}</a>
<a name="ln950">	mutex_unlock(&amp;endpoint-&gt;lock);</a>
<a name="ln951">	mutex_unlock(&amp;fFinishedLock);</a>
<a name="ln952">	mutex_unlock(&amp;fEventLock);</a>
<a name="ln953"> </a>
<a name="ln954">	status_t status = SubmitTransfer(transfer);</a>
<a name="ln955">	if (status != B_OK)</a>
<a name="ln956">		return status;</a>
<a name="ln957"> </a>
<a name="ln958">	// The endpoint's head TD is the TD of the just-submitted transfer.</a>
<a name="ln959">	// Just like EHCI, abuse the callback cookie to hold the TD pointer.</a>
<a name="ln960">	transfer-&gt;SetCallback(NULL, endpoint-&gt;td_head);</a>
<a name="ln961"> </a>
<a name="ln962">	return B_OK;</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965"> </a>
<a name="ln966">status_t</a>
<a name="ln967">XHCI::CheckDebugTransfer(Transfer *transfer)</a>
<a name="ln968">{</a>
<a name="ln969">	xhci_td *transfer_td = (xhci_td *)transfer-&gt;CallbackCookie();</a>
<a name="ln970">	if (transfer_td == NULL)</a>
<a name="ln971">		return B_NO_INIT;</a>
<a name="ln972"> </a>
<a name="ln973">	// Process events once, and then look for it in the finished list.</a>
<a name="ln974">	ProcessEvents();</a>
<a name="ln975">	xhci_td *previous = NULL;</a>
<a name="ln976">	for (xhci_td *td = fFinishedHead; td != NULL; td = td-&gt;next) {</a>
<a name="ln977">		if (td != transfer_td) {</a>
<a name="ln978">			previous = td;</a>
<a name="ln979">			continue;</a>
<a name="ln980">		}</a>
<a name="ln981"> </a>
<a name="ln982">		// We've found it!</a>
<a name="ln983">		if (previous == NULL) {</a>
<a name="ln984">			fFinishedHead = fFinishedHead-&gt;next;</a>
<a name="ln985">		} else {</a>
<a name="ln986">			previous-&gt;next = td-&gt;next;</a>
<a name="ln987">		}</a>
<a name="ln988"> </a>
<a name="ln989">		bool directionIn = (transfer-&gt;TransferPipe()-&gt;Direction() != Pipe::Out);</a>
<a name="ln990">		status_t status = (td-&gt;trb_completion_code == COMP_SUCCESS</a>
<a name="ln991">			|| td-&gt;trb_completion_code == COMP_SHORT_PACKET) ? B_OK : B_ERROR;</a>
<a name="ln992"> </a>
<a name="ln993">		if (status == B_OK &amp;&amp; directionIn)</a>
<a name="ln994">			ReadDescriptor(td, transfer-&gt;Vector(), transfer-&gt;VectorCount());</a>
<a name="ln995"> </a>
<a name="ln996">		FreeDescriptor(td);</a>
<a name="ln997">		transfer-&gt;SetCallback(NULL, NULL);</a>
<a name="ln998">		return status;</a>
<a name="ln999">	}</a>
<a name="ln1000"> </a>
<a name="ln1001">	// We didn't find it.</a>
<a name="ln1002">	spin(75);</a>
<a name="ln1003">	return B_DEV_PENDING;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006"> </a>
<a name="ln1007">void</a>
<a name="ln1008">XHCI::CancelDebugTransfer(Transfer *transfer)</a>
<a name="ln1009">{</a>
<a name="ln1010">	while (CheckDebugTransfer(transfer) == B_DEV_PENDING)</a>
<a name="ln1011">		spin(100);</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014"> </a>
<a name="ln1015">status_t</a>
<a name="ln1016">XHCI::NotifyPipeChange(Pipe *pipe, usb_change change)</a>
<a name="ln1017">{</a>
<a name="ln1018">	TRACE(&quot;pipe change %d for pipe %p (%d)\n&quot;, change, pipe,</a>
<a name="ln1019">		pipe-&gt;EndpointAddress());</a>
<a name="ln1020"> </a>
<a name="ln1021">	switch (change) {</a>
<a name="ln1022">	case USB_CHANGE_CREATED:</a>
<a name="ln1023">		return _InsertEndpointForPipe(pipe);</a>
<a name="ln1024">	case USB_CHANGE_DESTROYED:</a>
<a name="ln1025">		return _RemoveEndpointForPipe(pipe);</a>
<a name="ln1026"> </a>
<a name="ln1027">	case USB_CHANGE_PIPE_POLICY_CHANGED:</a>
<a name="ln1028">		// We don't care about these, at least for now.</a>
<a name="ln1029">		return B_OK;</a>
<a name="ln1030">	}</a>
<a name="ln1031"> </a>
<a name="ln1032">	TRACE_ERROR(&quot;unknown pipe change!\n&quot;);</a>
<a name="ln1033">	return B_UNSUPPORTED;</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">xhci_td *</a>
<a name="ln1038">XHCI::CreateDescriptor(uint32 trbCount, uint32 bufferCount, size_t bufferSize)</a>
<a name="ln1039">{</a>
<a name="ln1040">	const bool inKDL = debug_debugger_running();</a>
<a name="ln1041"> </a>
<a name="ln1042">	xhci_td *result;</a>
<a name="ln1043">	if (!inKDL) {</a>
<a name="ln1044">		result = (xhci_td*)calloc(1, sizeof(xhci_td));</a>
<a name="ln1045">	} else {</a>
<a name="ln1046">		// Just use the physical memory allocator while in KDL; it's less</a>
<a name="ln1047">		// secure than using the regular heap, but it's easier to deal with.</a>
<a name="ln1048">		phys_addr_t dummy;</a>
<a name="ln1049">		fStack-&gt;AllocateChunk((void **)&amp;result, &amp;dummy, sizeof(xhci_td));</a>
<a name="ln1050">	}</a>
<a name="ln1051"> </a>
<a name="ln1052">	if (result == NULL) {</a>
<a name="ln1053">		TRACE_ERROR(&quot;failed to allocate a transfer descriptor\n&quot;);</a>
<a name="ln1054">		return NULL;</a>
<a name="ln1055">	}</a>
<a name="ln1056"> </a>
<a name="ln1057">	// We always allocate 1 more TRB than requested, so that</a>
<a name="ln1058">	// _LinkDescriptorForPipe() has room to insert a link TRB.</a>
<a name="ln1059">	trbCount++;</a>
<a name="ln1060">	if (fStack-&gt;AllocateChunk((void **)&amp;result-&gt;trbs, &amp;result-&gt;trb_addr,</a>
<a name="ln1061">			(trbCount * sizeof(xhci_trb))) &lt; B_OK) {</a>
<a name="ln1062">		TRACE_ERROR(&quot;failed to allocate TRBs\n&quot;);</a>
<a name="ln1063">		FreeDescriptor(result);</a>
<a name="ln1064">		return NULL;</a>
<a name="ln1065">	}</a>
<a name="ln1066">	result-&gt;trb_count = trbCount;</a>
<a name="ln1067">	result-&gt;trb_used = 0;</a>
<a name="ln1068"> </a>
<a name="ln1069">	if (bufferSize &gt; 0) {</a>
<a name="ln1070">		// Due to how the USB stack allocates physical memory, we can't just</a>
<a name="ln1071">		// request one large chunk the size of the transfer, and so instead we</a>
<a name="ln1072">		// create a series of buffers as requested by our caller.</a>
<a name="ln1073"> </a>
<a name="ln1074">		// We store the buffer pointers and addresses in one memory block.</a>
<a name="ln1075">		if (!inKDL) {</a>
<a name="ln1076">			result-&gt;buffers = (void**)calloc(bufferCount,</a>
<a name="ln1077">				(sizeof(void*) + sizeof(phys_addr_t)));</a>
<a name="ln1078">		} else {</a>
<a name="ln1079">			phys_addr_t dummy;</a>
<a name="ln1080">			fStack-&gt;AllocateChunk((void **)&amp;result-&gt;buffers, &amp;dummy,</a>
<a name="ln1081">				bufferCount * (sizeof(void*) + sizeof(phys_addr_t)));</a>
<a name="ln1082">		}</a>
<a name="ln1083">		if (result-&gt;buffers == NULL) {</a>
<a name="ln1084">			TRACE_ERROR(&quot;unable to allocate space for buffer infos\n&quot;);</a>
<a name="ln1085">			FreeDescriptor(result);</a>
<a name="ln1086">			return NULL;</a>
<a name="ln1087">		}</a>
<a name="ln1088">		result-&gt;buffer_addrs = (phys_addr_t*)&amp;result-&gt;buffers[bufferCount];</a>
<a name="ln1089"> </a>
<a name="ln1090">		// Optimization: If the requested total size of all buffers is less</a>
<a name="ln1091">		// than 32*B_PAGE_SIZE (the maximum size that the physical memory</a>
<a name="ln1092">		// allocator can handle), we allocate only one buffer and segment it.</a>
<a name="ln1093">		size_t totalSize = bufferSize * bufferCount;</a>
<a name="ln1094">		if (totalSize &lt; (32 * B_PAGE_SIZE)) {</a>
<a name="ln1095">			if (fStack-&gt;AllocateChunk(&amp;result-&gt;buffers[0],</a>
<a name="ln1096">					&amp;result-&gt;buffer_addrs[0], totalSize) &lt; B_OK) {</a>
<a name="ln1097">				TRACE_ERROR(&quot;unable to allocate space for large buffer (size %ld)\n&quot;,</a>
<a name="ln1098">					totalSize);</a>
<a name="ln1099">				FreeDescriptor(result);</a>
<a name="ln1100">				return NULL;</a>
<a name="ln1101">			}</a>
<a name="ln1102">			for (uint32 i = 1; i &lt; bufferCount; i++) {</a>
<a name="ln1103">				result-&gt;buffers[i] = (void*)((addr_t)(result-&gt;buffers[i - 1])</a>
<a name="ln1104">					+ bufferSize);</a>
<a name="ln1105">				result-&gt;buffer_addrs[i] = result-&gt;buffer_addrs[i - 1]</a>
<a name="ln1106">					+ bufferSize;</a>
<a name="ln1107">			}</a>
<a name="ln1108">		} else {</a>
<a name="ln1109">			// Otherwise, we allocate each buffer individually.</a>
<a name="ln1110">			for (uint32 i = 0; i &lt; bufferCount; i++) {</a>
<a name="ln1111">				if (fStack-&gt;AllocateChunk(&amp;result-&gt;buffers[i],</a>
<a name="ln1112">						&amp;result-&gt;buffer_addrs[i], bufferSize) &lt; B_OK) {</a>
<a name="ln1113">					TRACE_ERROR(&quot;unable to allocate space for the buffer (size %ld)\n&quot;,</a>
<a name="ln1114">						bufferSize);</a>
<a name="ln1115">					FreeDescriptor(result);</a>
<a name="ln1116">					return NULL;</a>
<a name="ln1117">				}</a>
<a name="ln1118">			}</a>
<a name="ln1119">		}</a>
<a name="ln1120">	} else {</a>
<a name="ln1121">		result-&gt;buffers = NULL;</a>
<a name="ln1122">		result-&gt;buffer_addrs = NULL;</a>
<a name="ln1123">	}</a>
<a name="ln1124">	result-&gt;buffer_size = bufferSize;</a>
<a name="ln1125">	result-&gt;buffer_count = bufferCount;</a>
<a name="ln1126"> </a>
<a name="ln1127">	// Initialize all other fields.</a>
<a name="ln1128">	result-&gt;transfer = NULL;</a>
<a name="ln1129">	result-&gt;trb_completion_code = 0;</a>
<a name="ln1130">	result-&gt;trb_left = 0;</a>
<a name="ln1131">	result-&gt;next = NULL;</a>
<a name="ln1132"> </a>
<a name="ln1133">	TRACE(&quot;CreateDescriptor allocated %p, buffer_size %ld, buffer_count %&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln1134">		result, result-&gt;buffer_size, result-&gt;buffer_count);</a>
<a name="ln1135"> </a>
<a name="ln1136">	return result;</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139"> </a>
<a name="ln1140">void</a>
<a name="ln1141">XHCI::FreeDescriptor(xhci_td *descriptor)</a>
<a name="ln1142">{</a>
<a name="ln1143">	if (descriptor == NULL)</a>
<a name="ln1144">		return;</a>
<a name="ln1145"> </a>
<a name="ln1146">	const bool inKDL = debug_debugger_running();</a>
<a name="ln1147"> </a>
<a name="ln1148">	if (descriptor-&gt;trbs != NULL) {</a>
<a name="ln1149">		fStack-&gt;FreeChunk(descriptor-&gt;trbs, descriptor-&gt;trb_addr,</a>
<a name="ln1150">			(descriptor-&gt;trb_count * sizeof(xhci_trb)));</a>
<a name="ln1151">	}</a>
<a name="ln1152">	if (descriptor-&gt;buffers != NULL) {</a>
<a name="ln1153">		size_t totalSize = descriptor-&gt;buffer_size * descriptor-&gt;buffer_count;</a>
<a name="ln1154">		if (totalSize &lt; (32 * B_PAGE_SIZE)) {</a>
<a name="ln1155">			// This was allocated as one contiguous buffer.</a>
<a name="ln1156">			fStack-&gt;FreeChunk(descriptor-&gt;buffers[0], descriptor-&gt;buffer_addrs[0],</a>
<a name="ln1157">				totalSize);</a>
<a name="ln1158">		} else {</a>
<a name="ln1159">			for (uint32 i = 0; i &lt; descriptor-&gt;buffer_count; i++) {</a>
<a name="ln1160">				if (descriptor-&gt;buffers[i] == NULL)</a>
<a name="ln1161">					continue;</a>
<a name="ln1162">				fStack-&gt;FreeChunk(descriptor-&gt;buffers[i], descriptor-&gt;buffer_addrs[i],</a>
<a name="ln1163">					descriptor-&gt;buffer_size);</a>
<a name="ln1164">			}</a>
<a name="ln1165">		}</a>
<a name="ln1166"> </a>
<a name="ln1167">		if (!inKDL) {</a>
<a name="ln1168">			free(descriptor-&gt;buffers);</a>
<a name="ln1169">		} else {</a>
<a name="ln1170">			fStack-&gt;FreeChunk(descriptor-&gt;buffers, 0,</a>
<a name="ln1171">				descriptor-&gt;buffer_count * (sizeof(void*) + sizeof(phys_addr_t)));</a>
<a name="ln1172">		}</a>
<a name="ln1173">	}</a>
<a name="ln1174"> </a>
<a name="ln1175">	if (!inKDL)</a>
<a name="ln1176">		free(descriptor);</a>
<a name="ln1177">	else</a>
<a name="ln1178">		fStack-&gt;FreeChunk(descriptor, 0, sizeof(xhci_td));</a>
<a name="ln1179">}</a>
<a name="ln1180"> </a>
<a name="ln1181"> </a>
<a name="ln1182">size_t</a>
<a name="ln1183">XHCI::WriteDescriptor(xhci_td *descriptor, iovec *vector, size_t vectorCount)</a>
<a name="ln1184">{</a>
<a name="ln1185">	size_t written = 0;</a>
<a name="ln1186"> </a>
<a name="ln1187">	size_t bufIdx = 0, bufUsed = 0;</a>
<a name="ln1188">	for (size_t vecIdx = 0; vecIdx &lt; vectorCount; vecIdx++) {</a>
<a name="ln1189">		size_t length = vector[vecIdx].iov_len;</a>
<a name="ln1190"> </a>
<a name="ln1191">		while (length &gt; 0 &amp;&amp; bufIdx &lt; descriptor-&gt;buffer_count) {</a>
<a name="ln1192">			size_t toCopy = min_c(length, descriptor-&gt;buffer_size - bufUsed);</a>
<a name="ln1193">			memcpy((uint8 *)descriptor-&gt;buffers[bufIdx] + bufUsed,</a>
<a name="ln1194">				(uint8 *)vector[vecIdx].iov_base + (vector[vecIdx].iov_len - length),</a>
<a name="ln1195">				toCopy);</a>
<a name="ln1196"> </a>
<a name="ln1197">			written += toCopy;</a>
<a name="ln1198">			bufUsed += toCopy;</a>
<a name="ln1199">			length -= toCopy;</a>
<a name="ln1200">			if (bufUsed == descriptor-&gt;buffer_size) {</a>
<a name="ln1201">				bufIdx++;</a>
<a name="ln1202">				bufUsed = 0;</a>
<a name="ln1203">			}</a>
<a name="ln1204">		}</a>
<a name="ln1205">	}</a>
<a name="ln1206"> </a>
<a name="ln1207">	TRACE(&quot;wrote descriptor (%&quot; B_PRIuSIZE &quot; bytes)\n&quot;, written);</a>
<a name="ln1208">	return written;</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211"> </a>
<a name="ln1212">size_t</a>
<a name="ln1213">XHCI::ReadDescriptor(xhci_td *descriptor, iovec *vector, size_t vectorCount)</a>
<a name="ln1214">{</a>
<a name="ln1215">	size_t read = 0;</a>
<a name="ln1216"> </a>
<a name="ln1217">	size_t bufIdx = 0, bufUsed = 0;</a>
<a name="ln1218">	for (size_t vecIdx = 0; vecIdx &lt; vectorCount; vecIdx++) {</a>
<a name="ln1219">		size_t length = vector[vecIdx].iov_len;</a>
<a name="ln1220"> </a>
<a name="ln1221">		while (length &gt; 0 &amp;&amp; bufIdx &lt; descriptor-&gt;buffer_count) {</a>
<a name="ln1222">			size_t toCopy = min_c(length, descriptor-&gt;buffer_size - bufUsed);</a>
<a name="ln1223">			memcpy((uint8 *)vector[vecIdx].iov_base + (vector[vecIdx].iov_len - length),</a>
<a name="ln1224">				(uint8 *)descriptor-&gt;buffers[bufIdx] + bufUsed, toCopy);</a>
<a name="ln1225"> </a>
<a name="ln1226">			read += toCopy;</a>
<a name="ln1227">			bufUsed += toCopy;</a>
<a name="ln1228">			length -= toCopy;</a>
<a name="ln1229">			if (bufUsed == descriptor-&gt;buffer_size) {</a>
<a name="ln1230">				bufIdx++;</a>
<a name="ln1231">				bufUsed = 0;</a>
<a name="ln1232">			}</a>
<a name="ln1233">		}</a>
<a name="ln1234">	}</a>
<a name="ln1235"> </a>
<a name="ln1236">	TRACE(&quot;read descriptor (%&quot; B_PRIuSIZE &quot; bytes)\n&quot;, read);</a>
<a name="ln1237">	return read;</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240"> </a>
<a name="ln1241">Device *</a>
<a name="ln1242">XHCI::AllocateDevice(Hub *parent, int8 hubAddress, uint8 hubPort,</a>
<a name="ln1243">	usb_speed speed)</a>
<a name="ln1244">{</a>
<a name="ln1245">	TRACE(&quot;AllocateDevice hubAddress %d hubPort %d speed %d\n&quot;, hubAddress,</a>
<a name="ln1246">		hubPort, speed);</a>
<a name="ln1247"> </a>
<a name="ln1248">	uint8 slot = XHCI_MAX_SLOTS;</a>
<a name="ln1249">	if (EnableSlot(&amp;slot) != B_OK) {</a>
<a name="ln1250">		TRACE_ERROR(&quot;AllocateDevice() failed enable slot\n&quot;);</a>
<a name="ln1251">		return NULL;</a>
<a name="ln1252">	}</a>
<a name="ln1253"> </a>
<a name="ln1254">	if (slot == 0 || slot &gt; fSlotCount) {</a>
<a name="ln1255">		TRACE_ERROR(&quot;AllocateDevice() bad slot\n&quot;);</a>
<a name="ln1256">		return NULL;</a>
<a name="ln1257">	}</a>
<a name="ln1258"> </a>
<a name="ln1259">	if (fDevices[slot].state != XHCI_STATE_DISABLED) {</a>
<a name="ln1260">		TRACE_ERROR(&quot;AllocateDevice() slot already used\n&quot;);</a>
<a name="ln1261">		return NULL;</a>
<a name="ln1262">	}</a>
<a name="ln1263"> </a>
<a name="ln1264">	struct xhci_device *device = &amp;fDevices[slot];</a>
<a name="ln1265">	memset(device, 0, sizeof(struct xhci_device));</a>
<a name="ln1266">	device-&gt;state = XHCI_STATE_ENABLED;</a>
<a name="ln1267">	device-&gt;slot = slot;</a>
<a name="ln1268"> </a>
<a name="ln1269">	device-&gt;input_ctx_area = fStack-&gt;AllocateArea((void **)&amp;device-&gt;input_ctx,</a>
<a name="ln1270">		&amp;device-&gt;input_ctx_addr, sizeof(*device-&gt;input_ctx) &lt;&lt; fContextSizeShift,</a>
<a name="ln1271">		&quot;XHCI input context&quot;);</a>
<a name="ln1272">	if (device-&gt;input_ctx_area &lt; B_OK) {</a>
<a name="ln1273">		TRACE_ERROR(&quot;unable to create a input context area\n&quot;);</a>
<a name="ln1274">		device-&gt;state = XHCI_STATE_DISABLED;</a>
<a name="ln1275">		return NULL;</a>
<a name="ln1276">	}</a>
<a name="ln1277"> </a>
<a name="ln1278">	memset(device-&gt;input_ctx, 0, sizeof(*device-&gt;input_ctx) &lt;&lt; fContextSizeShift);</a>
<a name="ln1279">	_WriteContext(&amp;device-&gt;input_ctx-&gt;input.dropFlags, 0);</a>
<a name="ln1280">	_WriteContext(&amp;device-&gt;input_ctx-&gt;input.addFlags, 3);</a>
<a name="ln1281"> </a>
<a name="ln1282">	uint32 route = 0;</a>
<a name="ln1283">	uint8 routePort = hubPort;</a>
<a name="ln1284">	uint8 rhPort = hubPort;</a>
<a name="ln1285">	for (Device *hubDevice = parent; hubDevice != RootObject();</a>
<a name="ln1286">		hubDevice = (Device *)hubDevice-&gt;Parent()) {</a>
<a name="ln1287"> </a>
<a name="ln1288">		rhPort = routePort;</a>
<a name="ln1289">		if (hubDevice-&gt;Parent() == RootObject())</a>
<a name="ln1290">			break;</a>
<a name="ln1291">		route *= 16;</a>
<a name="ln1292">		if (hubPort &gt; 15)</a>
<a name="ln1293">			route += 15;</a>
<a name="ln1294">		else</a>
<a name="ln1295">			route += routePort;</a>
<a name="ln1296"> </a>
<a name="ln1297">		routePort = hubDevice-&gt;HubPort();</a>
<a name="ln1298">	}</a>
<a name="ln1299"> </a>
<a name="ln1300">	// Get speed of port, only if device connected to root hub port</a>
<a name="ln1301">	// else we have to rely on value reported by the Hub Explore thread</a>
<a name="ln1302">	if (route == 0) {</a>
<a name="ln1303">		GetPortSpeed(hubPort - 1, &amp;speed);</a>
<a name="ln1304">		TRACE(&quot;speed updated %d\n&quot;, speed);</a>
<a name="ln1305">	}</a>
<a name="ln1306"> </a>
<a name="ln1307">	uint32 dwslot0 = SLOT_0_NUM_ENTRIES(1) | SLOT_0_ROUTE(route);</a>
<a name="ln1308"> </a>
<a name="ln1309">	// add the speed</a>
<a name="ln1310">	switch (speed) {</a>
<a name="ln1311">	case USB_SPEED_LOWSPEED:</a>
<a name="ln1312">		dwslot0 |= SLOT_0_SPEED(2);</a>
<a name="ln1313">		break;</a>
<a name="ln1314">	case USB_SPEED_HIGHSPEED:</a>
<a name="ln1315">		dwslot0 |= SLOT_0_SPEED(3);</a>
<a name="ln1316">		break;</a>
<a name="ln1317">	case USB_SPEED_FULLSPEED:</a>
<a name="ln1318">		dwslot0 |= SLOT_0_SPEED(1);</a>
<a name="ln1319">		break;</a>
<a name="ln1320">	case USB_SPEED_SUPER:</a>
<a name="ln1321">		dwslot0 |= SLOT_0_SPEED(4);</a>
<a name="ln1322">		break;</a>
<a name="ln1323">	default:</a>
<a name="ln1324">		TRACE_ERROR(&quot;unknown usb speed\n&quot;);</a>
<a name="ln1325">		break;</a>
<a name="ln1326">	}</a>
<a name="ln1327"> </a>
<a name="ln1328">	_WriteContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot0, dwslot0);</a>
<a name="ln1329">	// TODO enable power save</a>
<a name="ln1330">	_WriteContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot1, SLOT_1_RH_PORT(rhPort));</a>
<a name="ln1331">	uint32 dwslot2 = SLOT_2_IRQ_TARGET(0);</a>
<a name="ln1332"> </a>
<a name="ln1333">	// If LS/FS device connected to non-root HS device</a>
<a name="ln1334">	if (route != 0 &amp;&amp; parent-&gt;Speed() == USB_SPEED_HIGHSPEED</a>
<a name="ln1335">		&amp;&amp; (speed == USB_SPEED_LOWSPEED || speed == USB_SPEED_FULLSPEED)) {</a>
<a name="ln1336">		struct xhci_device *parenthub = (struct xhci_device *)</a>
<a name="ln1337">			parent-&gt;ControllerCookie();</a>
<a name="ln1338">		dwslot2 |= SLOT_2_PORT_NUM(hubPort);</a>
<a name="ln1339">		dwslot2 |= SLOT_2_TT_HUB_SLOT(parenthub-&gt;slot);</a>
<a name="ln1340">	}</a>
<a name="ln1341"> </a>
<a name="ln1342">	_WriteContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot2, dwslot2);</a>
<a name="ln1343"> </a>
<a name="ln1344">	_WriteContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot3, SLOT_3_SLOT_STATE(0)</a>
<a name="ln1345">		| SLOT_3_DEVICE_ADDRESS(0));</a>
<a name="ln1346"> </a>
<a name="ln1347">	TRACE(&quot;slot 0x%08&quot; B_PRIx32 &quot; 0x%08&quot; B_PRIx32 &quot; 0x%08&quot; B_PRIx32 &quot; 0x%08&quot; B_PRIx32</a>
<a name="ln1348">		&quot;\n&quot;, _ReadContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot0),</a>
<a name="ln1349">		_ReadContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot1),</a>
<a name="ln1350">		_ReadContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot2),</a>
<a name="ln1351">		_ReadContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot3));</a>
<a name="ln1352"> </a>
<a name="ln1353">	device-&gt;device_ctx_area = fStack-&gt;AllocateArea((void **)&amp;device-&gt;device_ctx,</a>
<a name="ln1354">		&amp;device-&gt;device_ctx_addr, sizeof(*device-&gt;device_ctx) &lt;&lt; fContextSizeShift,</a>
<a name="ln1355">		&quot;XHCI device context&quot;);</a>
<a name="ln1356">	if (device-&gt;device_ctx_area &lt; B_OK) {</a>
<a name="ln1357">		TRACE_ERROR(&quot;unable to create a device context area\n&quot;);</a>
<a name="ln1358">		delete_area(device-&gt;input_ctx_area);</a>
<a name="ln1359">		memset(device, 0, sizeof(xhci_device));</a>
<a name="ln1360">		device-&gt;state = XHCI_STATE_DISABLED;</a>
<a name="ln1361">		return NULL;</a>
<a name="ln1362">	}</a>
<a name="ln1363">	memset(device-&gt;device_ctx, 0, sizeof(*device-&gt;device_ctx) &lt;&lt; fContextSizeShift);</a>
<a name="ln1364"> </a>
<a name="ln1365">	device-&gt;trb_area = fStack-&gt;AllocateArea((void **)&amp;device-&gt;trbs,</a>
<a name="ln1366">		&amp;device-&gt;trb_addr, sizeof(xhci_trb) * (XHCI_MAX_ENDPOINTS - 1)</a>
<a name="ln1367">			* XHCI_ENDPOINT_RING_SIZE, &quot;XHCI endpoint trbs&quot;);</a>
<a name="ln1368">	if (device-&gt;trb_area &lt; B_OK) {</a>
<a name="ln1369">		TRACE_ERROR(&quot;unable to create a device trbs area\n&quot;);</a>
<a name="ln1370">		delete_area(device-&gt;input_ctx_area);</a>
<a name="ln1371">		delete_area(device-&gt;device_ctx_area);</a>
<a name="ln1372">		memset(device, 0, sizeof(xhci_device));</a>
<a name="ln1373">		device-&gt;state = XHCI_STATE_DISABLED;</a>
<a name="ln1374">		return NULL;</a>
<a name="ln1375">	}</a>
<a name="ln1376"> </a>
<a name="ln1377">	// set up slot pointer to device context</a>
<a name="ln1378">	fDcba-&gt;baseAddress[slot] = device-&gt;device_ctx_addr;</a>
<a name="ln1379"> </a>
<a name="ln1380">	size_t maxPacketSize;</a>
<a name="ln1381">	switch (speed) {</a>
<a name="ln1382">	case USB_SPEED_LOWSPEED:</a>
<a name="ln1383">	case USB_SPEED_FULLSPEED:</a>
<a name="ln1384">		maxPacketSize = 8;</a>
<a name="ln1385">		break;</a>
<a name="ln1386">	case USB_SPEED_HIGHSPEED:</a>
<a name="ln1387">		maxPacketSize = 64;</a>
<a name="ln1388">		break;</a>
<a name="ln1389">	default:</a>
<a name="ln1390">		maxPacketSize = 512;</a>
<a name="ln1391">		break;</a>
<a name="ln1392">	}</a>
<a name="ln1393"> </a>
<a name="ln1394">	// configure the Control endpoint 0</a>
<a name="ln1395">	if (ConfigureEndpoint(slot, 0, USB_OBJECT_CONTROL_PIPE, false,</a>
<a name="ln1396">			device-&gt;trb_addr, 0, maxPacketSize, speed, 0, 0) != B_OK) {</a>
<a name="ln1397">		TRACE_ERROR(&quot;unable to configure default control endpoint\n&quot;);</a>
<a name="ln1398">		delete_area(device-&gt;input_ctx_area);</a>
<a name="ln1399">		delete_area(device-&gt;device_ctx_area);</a>
<a name="ln1400">		delete_area(device-&gt;trb_area);</a>
<a name="ln1401">		memset(device, 0, sizeof(xhci_device));</a>
<a name="ln1402">		device-&gt;state = XHCI_STATE_DISABLED;</a>
<a name="ln1403">		return NULL;</a>
<a name="ln1404">	}</a>
<a name="ln1405"> </a>
<a name="ln1406">	mutex_init(&amp;device-&gt;endpoints[0].lock, &quot;xhci endpoint lock&quot;);</a>
<a name="ln1407">	device-&gt;endpoints[0].device = device;</a>
<a name="ln1408">	device-&gt;endpoints[0].id = 0;</a>
<a name="ln1409">	device-&gt;endpoints[0].td_head = NULL;</a>
<a name="ln1410">	device-&gt;endpoints[0].used = 0;</a>
<a name="ln1411">	device-&gt;endpoints[0].current = 0;</a>
<a name="ln1412">	device-&gt;endpoints[0].trbs = device-&gt;trbs;</a>
<a name="ln1413">	device-&gt;endpoints[0].trb_addr = device-&gt;trb_addr;</a>
<a name="ln1414"> </a>
<a name="ln1415">	// device should get to addressed state (bsr = 0)</a>
<a name="ln1416">	if (SetAddress(device-&gt;input_ctx_addr, false, slot) != B_OK) {</a>
<a name="ln1417">		TRACE_ERROR(&quot;unable to set address\n&quot;);</a>
<a name="ln1418">		delete_area(device-&gt;input_ctx_area);</a>
<a name="ln1419">		delete_area(device-&gt;device_ctx_area);</a>
<a name="ln1420">		delete_area(device-&gt;trb_area);</a>
<a name="ln1421">		memset(device, 0, sizeof(xhci_device));</a>
<a name="ln1422">		device-&gt;state = XHCI_STATE_DISABLED;</a>
<a name="ln1423">		return NULL;</a>
<a name="ln1424">	}</a>
<a name="ln1425"> </a>
<a name="ln1426">	device-&gt;state = XHCI_STATE_ADDRESSED;</a>
<a name="ln1427">	device-&gt;address = SLOT_3_DEVICE_ADDRESS_GET(_ReadContext(</a>
<a name="ln1428">		&amp;device-&gt;device_ctx-&gt;slot.dwslot3));</a>
<a name="ln1429"> </a>
<a name="ln1430">	TRACE(&quot;device: address 0x%x state 0x%08&quot; B_PRIx32 &quot;\n&quot;, device-&gt;address,</a>
<a name="ln1431">		SLOT_3_SLOT_STATE_GET(_ReadContext(</a>
<a name="ln1432">			&amp;device-&gt;device_ctx-&gt;slot.dwslot3)));</a>
<a name="ln1433">	TRACE(&quot;endpoint0 state 0x%08&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln1434">		ENDPOINT_0_STATE_GET(_ReadContext(</a>
<a name="ln1435">			&amp;device-&gt;device_ctx-&gt;endpoints[0].dwendpoint0)));</a>
<a name="ln1436"> </a>
<a name="ln1437">	// Create a temporary pipe with the new address</a>
<a name="ln1438">	ControlPipe pipe(parent);</a>
<a name="ln1439">	pipe.SetControllerCookie(&amp;device-&gt;endpoints[0]);</a>
<a name="ln1440">	pipe.InitCommon(device-&gt;address + 1, 0, speed, Pipe::Default, maxPacketSize, 0,</a>
<a name="ln1441">		hubAddress, hubPort);</a>
<a name="ln1442"> </a>
<a name="ln1443">	// Get the device descriptor</a>
<a name="ln1444">	// Just retrieve the first 8 bytes of the descriptor -&gt; minimum supported</a>
<a name="ln1445">	// size of any device. It is enough because it includes the device type.</a>
<a name="ln1446"> </a>
<a name="ln1447">	size_t actualLength = 0;</a>
<a name="ln1448">	usb_device_descriptor deviceDescriptor;</a>
<a name="ln1449"> </a>
<a name="ln1450">	TRACE(&quot;getting the device descriptor\n&quot;);</a>
<a name="ln1451">	status_t status = pipe.SendRequest(</a>
<a name="ln1452">		USB_REQTYPE_DEVICE_IN | USB_REQTYPE_STANDARD,		// type</a>
<a name="ln1453">		USB_REQUEST_GET_DESCRIPTOR,							// request</a>
<a name="ln1454">		USB_DESCRIPTOR_DEVICE &lt;&lt; 8,							// value</a>
<a name="ln1455">		0,													// index</a>
<a name="ln1456">		8,													// length</a>
<a name="ln1457">		(void *)&amp;deviceDescriptor,							// buffer</a>
<a name="ln1458">		8,													// buffer length</a>
<a name="ln1459">		&amp;actualLength);										// actual length</a>
<a name="ln1460"> </a>
<a name="ln1461">	if (actualLength != 8) {</a>
<a name="ln1462">		TRACE_ERROR(&quot;error while getting the device descriptor: %s\n&quot;,</a>
<a name="ln1463">			strerror(status));</a>
<a name="ln1464">		delete_area(device-&gt;input_ctx_area);</a>
<a name="ln1465">		delete_area(device-&gt;device_ctx_area);</a>
<a name="ln1466">		delete_area(device-&gt;trb_area);</a>
<a name="ln1467">		memset(device, 0, sizeof(xhci_device));</a>
<a name="ln1468">		device-&gt;state = XHCI_STATE_DISABLED;</a>
<a name="ln1469">		return NULL;</a>
<a name="ln1470">	}</a>
<a name="ln1471"> </a>
<a name="ln1472">	TRACE(&quot;device_class: %d device_subclass %d device_protocol %d\n&quot;,</a>
<a name="ln1473">		deviceDescriptor.device_class, deviceDescriptor.device_subclass,</a>
<a name="ln1474">		deviceDescriptor.device_protocol);</a>
<a name="ln1475"> </a>
<a name="ln1476">	if (speed == USB_SPEED_FULLSPEED &amp;&amp; deviceDescriptor.max_packet_size_0 != 8) {</a>
<a name="ln1477">		TRACE(&quot;Full speed device with different max packet size for Endpoint 0\n&quot;);</a>
<a name="ln1478">		uint32 dwendpoint1 = _ReadContext(</a>
<a name="ln1479">			&amp;device-&gt;input_ctx-&gt;endpoints[0].dwendpoint1);</a>
<a name="ln1480">		dwendpoint1 &amp;= ~ENDPOINT_1_MAXPACKETSIZE(0xffff);</a>
<a name="ln1481">		dwendpoint1 |= ENDPOINT_1_MAXPACKETSIZE(</a>
<a name="ln1482">			deviceDescriptor.max_packet_size_0);</a>
<a name="ln1483">		_WriteContext(&amp;device-&gt;input_ctx-&gt;endpoints[0].dwendpoint1,</a>
<a name="ln1484">			dwendpoint1);</a>
<a name="ln1485">		_WriteContext(&amp;device-&gt;input_ctx-&gt;input.dropFlags, 0);</a>
<a name="ln1486">		_WriteContext(&amp;device-&gt;input_ctx-&gt;input.addFlags, (1 &lt;&lt; 1));</a>
<a name="ln1487">		EvaluateContext(device-&gt;input_ctx_addr, device-&gt;slot);</a>
<a name="ln1488">	}</a>
<a name="ln1489"> </a>
<a name="ln1490">	Device *deviceObject = NULL;</a>
<a name="ln1491">	if (deviceDescriptor.device_class == 0x09) {</a>
<a name="ln1492">		TRACE(&quot;creating new Hub\n&quot;);</a>
<a name="ln1493">		TRACE(&quot;getting the hub descriptor\n&quot;);</a>
<a name="ln1494">		size_t actualLength = 0;</a>
<a name="ln1495">		usb_hub_descriptor hubDescriptor;</a>
<a name="ln1496">		status = pipe.SendRequest(</a>
<a name="ln1497">			USB_REQTYPE_DEVICE_IN | USB_REQTYPE_CLASS,			// type</a>
<a name="ln1498">			USB_REQUEST_GET_DESCRIPTOR,							// request</a>
<a name="ln1499">			USB_DESCRIPTOR_HUB &lt;&lt; 8,							// value</a>
<a name="ln1500">			0,													// index</a>
<a name="ln1501">			sizeof(usb_hub_descriptor),							// length</a>
<a name="ln1502">			(void *)&amp;hubDescriptor,								// buffer</a>
<a name="ln1503">			sizeof(usb_hub_descriptor),							// buffer length</a>
<a name="ln1504">			&amp;actualLength);</a>
<a name="ln1505"> </a>
<a name="ln1506">		if (actualLength != sizeof(usb_hub_descriptor)) {</a>
<a name="ln1507">			TRACE_ERROR(&quot;error while getting the hub descriptor: %s\n&quot;,</a>
<a name="ln1508">				strerror(status));</a>
<a name="ln1509">			delete_area(device-&gt;input_ctx_area);</a>
<a name="ln1510">			delete_area(device-&gt;device_ctx_area);</a>
<a name="ln1511">			delete_area(device-&gt;trb_area);</a>
<a name="ln1512">			memset(device, 0, sizeof(xhci_device));</a>
<a name="ln1513">			device-&gt;state = XHCI_STATE_DISABLED;</a>
<a name="ln1514">			return NULL;</a>
<a name="ln1515">		}</a>
<a name="ln1516"> </a>
<a name="ln1517">		uint32 dwslot0 = _ReadContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot0);</a>
<a name="ln1518">		dwslot0 |= SLOT_0_HUB_BIT;</a>
<a name="ln1519">		_WriteContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot0, dwslot0);</a>
<a name="ln1520">		uint32 dwslot1 = _ReadContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot1);</a>
<a name="ln1521">		dwslot1 |= SLOT_1_NUM_PORTS(hubDescriptor.num_ports);</a>
<a name="ln1522">		_WriteContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot1, dwslot1);</a>
<a name="ln1523">		if (speed == USB_SPEED_HIGHSPEED) {</a>
<a name="ln1524">			uint32 dwslot2 = _ReadContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot2);</a>
<a name="ln1525">			dwslot2 |= SLOT_2_TT_TIME(HUB_TTT_GET(hubDescriptor.characteristics));</a>
<a name="ln1526">			_WriteContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot2, dwslot2);</a>
<a name="ln1527">		}</a>
<a name="ln1528"> </a>
<a name="ln1529">		deviceObject = new(std::nothrow) Hub(parent, hubAddress, hubPort,</a>
<a name="ln1530">			deviceDescriptor, device-&gt;address + 1, speed, false, device);</a>
<a name="ln1531">	} else {</a>
<a name="ln1532">		TRACE(&quot;creating new device\n&quot;);</a>
<a name="ln1533">		deviceObject = new(std::nothrow) Device(parent, hubAddress, hubPort,</a>
<a name="ln1534">			deviceDescriptor, device-&gt;address + 1, speed, false, device);</a>
<a name="ln1535">	}</a>
<a name="ln1536">	if (deviceObject == NULL || deviceObject-&gt;InitCheck() != B_OK) {</a>
<a name="ln1537">		if (deviceObject == NULL) {</a>
<a name="ln1538">			TRACE_ERROR(&quot;no memory to allocate device\n&quot;);</a>
<a name="ln1539">		} else {</a>
<a name="ln1540">			TRACE_ERROR(&quot;device object failed to initialize\n&quot;);</a>
<a name="ln1541">		}</a>
<a name="ln1542">		delete_area(device-&gt;input_ctx_area);</a>
<a name="ln1543">		delete_area(device-&gt;device_ctx_area);</a>
<a name="ln1544">		delete_area(device-&gt;trb_area);</a>
<a name="ln1545">		memset(device, 0, sizeof(xhci_device));</a>
<a name="ln1546">		device-&gt;state = XHCI_STATE_DISABLED;</a>
<a name="ln1547">		return NULL;</a>
<a name="ln1548">	}</a>
<a name="ln1549"> </a>
<a name="ln1550">	// We don't want to disable the default endpoint, naturally, which would</a>
<a name="ln1551">	// otherwise happen when this Pipe object is destroyed.</a>
<a name="ln1552">	pipe.SetControllerCookie(NULL);</a>
<a name="ln1553"> </a>
<a name="ln1554">	fPortSlots[hubPort] = slot;</a>
<a name="ln1555">	TRACE(&quot;AllocateDevice() port %d slot %d\n&quot;, hubPort, slot);</a>
<a name="ln1556">	return deviceObject;</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559"> </a>
<a name="ln1560">void</a>
<a name="ln1561">XHCI::FreeDevice(Device *device)</a>
<a name="ln1562">{</a>
<a name="ln1563">	uint8 slot = fPortSlots[device-&gt;HubPort()];</a>
<a name="ln1564">	TRACE(&quot;FreeDevice() port %d slot %d\n&quot;, device-&gt;HubPort(), slot);</a>
<a name="ln1565"> </a>
<a name="ln1566">	// Delete the device first, so it cleans up its pipes and tells us</a>
<a name="ln1567">	// what we need to destroy before we tear down our internal state.</a>
<a name="ln1568">	delete device;</a>
<a name="ln1569"> </a>
<a name="ln1570">	DisableSlot(slot);</a>
<a name="ln1571">	fDcba-&gt;baseAddress[slot] = 0;</a>
<a name="ln1572">	fPortSlots[device-&gt;HubPort()] = 0;</a>
<a name="ln1573">	delete_area(fDevices[slot].trb_area);</a>
<a name="ln1574">	delete_area(fDevices[slot].input_ctx_area);</a>
<a name="ln1575">	delete_area(fDevices[slot].device_ctx_area);</a>
<a name="ln1576"> </a>
<a name="ln1577">	memset(&amp;fDevices[slot], 0, sizeof(xhci_device));</a>
<a name="ln1578">	fDevices[slot].state = XHCI_STATE_DISABLED;</a>
<a name="ln1579">}</a>
<a name="ln1580"> </a>
<a name="ln1581"> </a>
<a name="ln1582">status_t</a>
<a name="ln1583">XHCI::_InsertEndpointForPipe(Pipe *pipe)</a>
<a name="ln1584">{</a>
<a name="ln1585">	TRACE(&quot;insert endpoint for pipe %p (%d)\n&quot;, pipe, pipe-&gt;EndpointAddress());</a>
<a name="ln1586"> </a>
<a name="ln1587">	if (pipe-&gt;ControllerCookie() != NULL</a>
<a name="ln1588">			|| pipe-&gt;Parent()-&gt;Type() != USB_OBJECT_DEVICE) {</a>
<a name="ln1589">		// default pipe is already referenced</a>
<a name="ln1590">		return B_OK;</a>
<a name="ln1591">	}</a>
<a name="ln1592"> </a>
<a name="ln1593">	Device* usbDevice = (Device *)pipe-&gt;Parent();</a>
<a name="ln1594">	struct xhci_device *device = (struct xhci_device *)</a>
<a name="ln1595">		usbDevice-&gt;ControllerCookie();</a>
<a name="ln1596">	if (usbDevice-&gt;Parent() == RootObject())</a>
<a name="ln1597">		return B_OK;</a>
<a name="ln1598">	if (device == NULL) {</a>
<a name="ln1599">		panic(&quot;_InsertEndpointForPipe device is NULL\n&quot;);</a>
<a name="ln1600">		return B_NO_INIT;</a>
<a name="ln1601">	}</a>
<a name="ln1602"> </a>
<a name="ln1603">	uint8 id = (2 * pipe-&gt;EndpointAddress()</a>
<a name="ln1604">		+ (pipe-&gt;Direction() != Pipe::Out ? 1 : 0)) - 1;</a>
<a name="ln1605">	if (id &gt;= XHCI_MAX_ENDPOINTS - 1)</a>
<a name="ln1606">		return B_BAD_VALUE;</a>
<a name="ln1607"> </a>
<a name="ln1608">	if (id &gt; 0) {</a>
<a name="ln1609">		uint32 devicedwslot0 = _ReadContext(&amp;device-&gt;device_ctx-&gt;slot.dwslot0);</a>
<a name="ln1610">		if (SLOT_0_NUM_ENTRIES_GET(devicedwslot0) == 1) {</a>
<a name="ln1611">			uint32 inputdwslot0 = _ReadContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot0);</a>
<a name="ln1612">			inputdwslot0 &amp;= ~(SLOT_0_NUM_ENTRIES(0x1f));</a>
<a name="ln1613">			inputdwslot0 |= SLOT_0_NUM_ENTRIES(XHCI_MAX_ENDPOINTS - 1);</a>
<a name="ln1614">			_WriteContext(&amp;device-&gt;input_ctx-&gt;slot.dwslot0, inputdwslot0);</a>
<a name="ln1615">			EvaluateContext(device-&gt;input_ctx_addr, device-&gt;slot);</a>
<a name="ln1616">		}</a>
<a name="ln1617"> </a>
<a name="ln1618">		mutex_init(&amp;device-&gt;endpoints[id].lock, &quot;xhci endpoint lock&quot;);</a>
<a name="ln1619">		MutexLocker endpointLocker(device-&gt;endpoints[id].lock);</a>
<a name="ln1620"> </a>
<a name="ln1621">		device-&gt;endpoints[id].device = device;</a>
<a name="ln1622">		device-&gt;endpoints[id].id = id;</a>
<a name="ln1623">		device-&gt;endpoints[id].td_head = NULL;</a>
<a name="ln1624">		device-&gt;endpoints[id].used = 0;</a>
<a name="ln1625">		device-&gt;endpoints[id].current = 0;</a>
<a name="ln1626"> </a>
<a name="ln1627">		device-&gt;endpoints[id].trbs = device-&gt;trbs</a>
<a name="ln1628">			+ id * XHCI_ENDPOINT_RING_SIZE;</a>
<a name="ln1629">		device-&gt;endpoints[id].trb_addr = device-&gt;trb_addr</a>
<a name="ln1630">			+ id * XHCI_ENDPOINT_RING_SIZE * sizeof(xhci_trb);</a>
<a name="ln1631">		memset(device-&gt;endpoints[id].trbs, 0,</a>
<a name="ln1632">			sizeof(xhci_trb) * XHCI_ENDPOINT_RING_SIZE);</a>
<a name="ln1633"> </a>
<a name="ln1634">		TRACE(&quot;_InsertEndpointForPipe trbs device %p endpoint %p\n&quot;,</a>
<a name="ln1635">			device-&gt;trbs, device-&gt;endpoints[id].trbs);</a>
<a name="ln1636">		TRACE(&quot;_InsertEndpointForPipe trb_addr device 0x%&quot; B_PRIxPHYSADDR</a>
<a name="ln1637">			&quot; endpoint 0x%&quot; B_PRIxPHYSADDR &quot;\n&quot;, device-&gt;trb_addr,</a>
<a name="ln1638">			device-&gt;endpoints[id].trb_addr);</a>
<a name="ln1639"> </a>
<a name="ln1640">		uint8 endpoint = id + 1;</a>
<a name="ln1641"> </a>
<a name="ln1642">		TRACE(&quot;trb_addr 0x%&quot; B_PRIxPHYSADDR &quot;\n&quot;, device-&gt;endpoints[id].trb_addr);</a>
<a name="ln1643"> </a>
<a name="ln1644">		status_t status = ConfigureEndpoint(device-&gt;slot, id, pipe-&gt;Type(),</a>
<a name="ln1645">			pipe-&gt;Direction() == Pipe::In, device-&gt;endpoints[id].trb_addr,</a>
<a name="ln1646">			pipe-&gt;Interval(), pipe-&gt;MaxPacketSize(), usbDevice-&gt;Speed(),</a>
<a name="ln1647">			pipe-&gt;MaxBurst(), pipe-&gt;BytesPerInterval());</a>
<a name="ln1648">		if (status != B_OK) {</a>
<a name="ln1649">			TRACE_ERROR(&quot;unable to configure endpoint\n&quot;);</a>
<a name="ln1650">			return status;</a>
<a name="ln1651">		}</a>
<a name="ln1652"> </a>
<a name="ln1653">		_WriteContext(&amp;device-&gt;input_ctx-&gt;input.dropFlags, 0);</a>
<a name="ln1654">		_WriteContext(&amp;device-&gt;input_ctx-&gt;input.addFlags,</a>
<a name="ln1655">			(1 &lt;&lt; endpoint) | (1 &lt;&lt; 0));</a>
<a name="ln1656"> </a>
<a name="ln1657">		if (endpoint &gt; 1)</a>
<a name="ln1658">			ConfigureEndpoint(device-&gt;input_ctx_addr, false, device-&gt;slot);</a>
<a name="ln1659">		else</a>
<a name="ln1660">			EvaluateContext(device-&gt;input_ctx_addr, device-&gt;slot);</a>
<a name="ln1661"> </a>
<a name="ln1662">		TRACE(&quot;device: address 0x%x state 0x%08&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln1663">			device-&gt;address, SLOT_3_SLOT_STATE_GET(_ReadContext(</a>
<a name="ln1664">				&amp;device-&gt;device_ctx-&gt;slot.dwslot3)));</a>
<a name="ln1665">		TRACE(&quot;endpoint[0] state 0x%08&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln1666">			ENDPOINT_0_STATE_GET(_ReadContext(</a>
<a name="ln1667">				&amp;device-&gt;device_ctx-&gt;endpoints[0].dwendpoint0)));</a>
<a name="ln1668">		TRACE(&quot;endpoint[%d] state 0x%08&quot; B_PRIx32 &quot;\n&quot;, id,</a>
<a name="ln1669">			ENDPOINT_0_STATE_GET(_ReadContext(</a>
<a name="ln1670">				&amp;device-&gt;device_ctx-&gt;endpoints[id].dwendpoint0)));</a>
<a name="ln1671"> </a>
<a name="ln1672">		device-&gt;state = XHCI_STATE_CONFIGURED;</a>
<a name="ln1673">	}</a>
<a name="ln1674">	pipe-&gt;SetControllerCookie(&amp;device-&gt;endpoints[id]);</a>
<a name="ln1675"> </a>
<a name="ln1676">	TRACE(&quot;_InsertEndpointForPipe for pipe %p at id %d\n&quot;, pipe, id);</a>
<a name="ln1677"> </a>
<a name="ln1678">	return B_OK;</a>
<a name="ln1679">}</a>
<a name="ln1680"> </a>
<a name="ln1681"> </a>
<a name="ln1682">status_t</a>
<a name="ln1683">XHCI::_RemoveEndpointForPipe(Pipe *pipe)</a>
<a name="ln1684">{</a>
<a name="ln1685">	TRACE(&quot;remove endpoint for pipe %p (%d)\n&quot;, pipe, pipe-&gt;EndpointAddress());</a>
<a name="ln1686"> </a>
<a name="ln1687">	if (pipe-&gt;Parent()-&gt;Type() != USB_OBJECT_DEVICE)</a>
<a name="ln1688">		return B_OK;</a>
<a name="ln1689">	Device* usbDevice = (Device *)pipe-&gt;Parent();</a>
<a name="ln1690">	if (usbDevice-&gt;Parent() == RootObject())</a>
<a name="ln1691">		return B_BAD_VALUE;</a>
<a name="ln1692"> </a>
<a name="ln1693">	xhci_endpoint *endpoint = (xhci_endpoint *)pipe-&gt;ControllerCookie();</a>
<a name="ln1694">	if (endpoint == NULL || endpoint-&gt;trbs == NULL)</a>
<a name="ln1695">		return B_NO_INIT;</a>
<a name="ln1696"> </a>
<a name="ln1697">	xhci_device *device = endpoint-&gt;device;</a>
<a name="ln1698"> </a>
<a name="ln1699">	if (endpoint-&gt;id &gt; 0) {</a>
<a name="ln1700">		mutex_lock(&amp;endpoint-&gt;lock);</a>
<a name="ln1701"> </a>
<a name="ln1702">		uint8 epNumber = endpoint-&gt;id + 1;</a>
<a name="ln1703">		StopEndpoint(true, epNumber, device-&gt;slot);</a>
<a name="ln1704"> </a>
<a name="ln1705">		mutex_destroy(&amp;endpoint-&gt;lock);</a>
<a name="ln1706">		memset(endpoint, 0, sizeof(xhci_endpoint));</a>
<a name="ln1707"> </a>
<a name="ln1708">		_WriteContext(&amp;device-&gt;input_ctx-&gt;input.dropFlags, (1 &lt;&lt; epNumber));</a>
<a name="ln1709">		_WriteContext(&amp;device-&gt;input_ctx-&gt;input.addFlags, 0);</a>
<a name="ln1710"> </a>
<a name="ln1711">		if (epNumber &gt; 1)</a>
<a name="ln1712">			ConfigureEndpoint(device-&gt;input_ctx_addr, true, device-&gt;slot);</a>
<a name="ln1713">		else</a>
<a name="ln1714">			EvaluateContext(device-&gt;input_ctx_addr, device-&gt;slot);</a>
<a name="ln1715"> </a>
<a name="ln1716">		device-&gt;state = XHCI_STATE_ADDRESSED;</a>
<a name="ln1717">	}</a>
<a name="ln1718">	pipe-&gt;SetControllerCookie(NULL);</a>
<a name="ln1719"> </a>
<a name="ln1720">	return B_OK;</a>
<a name="ln1721">}</a>
<a name="ln1722"> </a>
<a name="ln1723"> </a>
<a name="ln1724">status_t</a>
<a name="ln1725">XHCI::_LinkDescriptorForPipe(xhci_td *descriptor, xhci_endpoint *endpoint)</a>
<a name="ln1726">{</a>
<a name="ln1727">	TRACE(&quot;_LinkDescriptorForPipe\n&quot;);</a>
<a name="ln1728"> </a>
<a name="ln1729">	// We must check this before we lock the endpoint, because if it is</a>
<a name="ln1730">	// NULL, the mutex is probably uninitialized, too.</a>
<a name="ln1731">	if (endpoint-&gt;device == NULL) {</a>
<a name="ln1732">		TRACE_ERROR(&quot;trying to submit a transfer to a non-existent endpoint!\n&quot;);</a>
<a name="ln1733">		return B_NO_INIT;</a>
<a name="ln1734">	}</a>
<a name="ln1735"> </a>
<a name="ln1736">	// Use mutex_trylock first, in case we are in KDL.</a>
<a name="ln1737">	if (mutex_trylock(&amp;endpoint-&gt;lock) != B_OK)</a>
<a name="ln1738">		mutex_lock(&amp;endpoint-&gt;lock);</a>
<a name="ln1739"> </a>
<a name="ln1740">	// &quot;used&quot; refers to the number of currently linked TDs, not the number of</a>
<a name="ln1741">	// used TRBs on the ring (we use 2 TRBs on the ring per transfer.)</a>
<a name="ln1742">	if (endpoint-&gt;used &gt;= (XHCI_MAX_TRANSFERS - 1)) {</a>
<a name="ln1743">		TRACE_ERROR(&quot;_LinkDescriptorForPipe max transfers count exceeded\n&quot;);</a>
<a name="ln1744">		mutex_unlock(&amp;endpoint-&gt;lock);</a>
<a name="ln1745">		return B_BAD_VALUE;</a>
<a name="ln1746">	}</a>
<a name="ln1747"> </a>
<a name="ln1748">	endpoint-&gt;used++;</a>
<a name="ln1749">	descriptor-&gt;next = endpoint-&gt;td_head;</a>
<a name="ln1750">	endpoint-&gt;td_head = descriptor;</a>
<a name="ln1751"> </a>
<a name="ln1752">	const uint8 current = endpoint-&gt;current,</a>
<a name="ln1753">		eventdata = current + 1;</a>
<a name="ln1754">	uint8 next = eventdata + 1;</a>
<a name="ln1755"> </a>
<a name="ln1756">	TRACE(&quot;_LinkDescriptorForPipe current %d, next %d\n&quot;, current, next);</a>
<a name="ln1757"> </a>
<a name="ln1758">	// Compute link.</a>
<a name="ln1759">	addr_t addr = endpoint-&gt;trb_addr + eventdata * sizeof(xhci_trb);</a>
<a name="ln1760">	descriptor-&gt;trbs[descriptor-&gt;trb_used].address = addr;</a>
<a name="ln1761">	descriptor-&gt;trbs[descriptor-&gt;trb_used].status = TRB_2_IRQ(0);</a>
<a name="ln1762">	descriptor-&gt;trbs[descriptor-&gt;trb_used].flags = TRB_3_TYPE(TRB_TYPE_LINK)</a>
<a name="ln1763">		| TRB_3_CHAIN_BIT | TRB_3_CYCLE_BIT;</a>
<a name="ln1764"> </a>
<a name="ln1765">#if !B_HOST_IS_LENDIAN</a>
<a name="ln1766">	// Convert endianness.</a>
<a name="ln1767">	for (uint32 i = 0; i &lt;= descriptor-&gt;trb_used; i++) {</a>
<a name="ln1768">		descriptor-&gt;trbs[i].address =</a>
<a name="ln1769">			B_HOST_TO_LENDIAN_INT64(descriptor-&gt;trbs[i].address);</a>
<a name="ln1770">		descriptor-&gt;trbs[i].status =</a>
<a name="ln1771">			B_HOST_TO_LENDIAN_INT32(descriptor-&gt;trbs[i].status);</a>
<a name="ln1772">		descriptor-&gt;trbs[i].flags =</a>
<a name="ln1773">			B_HOST_TO_LENDIAN_INT32(descriptor-&gt;trbs[i].flags);</a>
<a name="ln1774">	}</a>
<a name="ln1775">#endif</a>
<a name="ln1776"> </a>
<a name="ln1777">	// Link the descriptor.</a>
<a name="ln1778">	endpoint-&gt;trbs[current].address =</a>
<a name="ln1779">		B_HOST_TO_LENDIAN_INT64(descriptor-&gt;trb_addr);</a>
<a name="ln1780">	endpoint-&gt;trbs[current].status =</a>
<a name="ln1781">		B_HOST_TO_LENDIAN_INT32(TRB_2_IRQ(0));</a>
<a name="ln1782">	endpoint-&gt;trbs[current].flags =</a>
<a name="ln1783">		B_HOST_TO_LENDIAN_INT32(TRB_3_TYPE(TRB_TYPE_LINK));</a>
<a name="ln1784"> </a>
<a name="ln1785">	// Set up the Event Data TRB (XHCI 1.2 § 4.11.5.2 p230.)</a>
<a name="ln1786">	//</a>
<a name="ln1787">	// We do this on the main ring for two reasons: first, to avoid a small</a>
<a name="ln1788">	// potential race between the interrupt and the controller evaluating</a>
<a name="ln1789">	// the link TRB to get back onto the ring; and second, because many</a>
<a name="ln1790">	// controllers throw errors if the target of a Link TRB is not valid</a>
<a name="ln1791">	// (i.e. does not have its Cycle Bit set.)</a>
<a name="ln1792">	//</a>
<a name="ln1793">	// We also set the &quot;address&quot; field, which the controller will copy</a>
<a name="ln1794">	// verbatim into the TRB it posts to the event ring, to be the last</a>
<a name="ln1795">	// &quot;real&quot; TRB in the TD; this will allow us to determine what transfer</a>
<a name="ln1796">	// the resulting Transfer Event TRB refers to.</a>
<a name="ln1797">	endpoint-&gt;trbs[eventdata].address =</a>
<a name="ln1798">		B_HOST_TO_LENDIAN_INT64(descriptor-&gt;trb_addr</a>
<a name="ln1799">			+ (descriptor-&gt;trb_used - 1) * sizeof(xhci_trb));</a>
<a name="ln1800">	endpoint-&gt;trbs[eventdata].status =</a>
<a name="ln1801">		B_HOST_TO_LENDIAN_INT32(TRB_2_IRQ(0));</a>
<a name="ln1802">	endpoint-&gt;trbs[eventdata].flags =</a>
<a name="ln1803">		B_HOST_TO_LENDIAN_INT32(TRB_3_TYPE(TRB_TYPE_EVENT_DATA)</a>
<a name="ln1804">			| TRB_3_IOC_BIT | TRB_3_CYCLE_BIT);</a>
<a name="ln1805"> </a>
<a name="ln1806">	if (next == (XHCI_ENDPOINT_RING_SIZE - 1)) {</a>
<a name="ln1807">		// We always use 2 TRBs per _Link..() call, so if &quot;next&quot; is the last</a>
<a name="ln1808">		// TRB in the ring, we need to generate a link TRB at &quot;next&quot;, and</a>
<a name="ln1809">		// then wrap it to 0.</a>
<a name="ln1810">		endpoint-&gt;trbs[next].address =</a>
<a name="ln1811">			B_HOST_TO_LENDIAN_INT64(endpoint-&gt;trb_addr);</a>
<a name="ln1812">		endpoint-&gt;trbs[next].status =</a>
<a name="ln1813">			B_HOST_TO_LENDIAN_INT32(TRB_2_IRQ(0));</a>
<a name="ln1814">		endpoint-&gt;trbs[next].flags =</a>
<a name="ln1815">			B_HOST_TO_LENDIAN_INT32(TRB_3_TYPE(TRB_TYPE_LINK) | TRB_3_CYCLE_BIT);</a>
<a name="ln1816"> </a>
<a name="ln1817">		next = 0;</a>
<a name="ln1818">	}</a>
<a name="ln1819"> </a>
<a name="ln1820">	endpoint-&gt;trbs[next].address = 0;</a>
<a name="ln1821">	endpoint-&gt;trbs[next].status = 0;</a>
<a name="ln1822">	endpoint-&gt;trbs[next].flags = 0;</a>
<a name="ln1823"> </a>
<a name="ln1824">	// Everything is ready, so write the cycle bit.</a>
<a name="ln1825">	endpoint-&gt;trbs[current].flags |= B_HOST_TO_LENDIAN_INT32(TRB_3_CYCLE_BIT);</a>
<a name="ln1826"> </a>
<a name="ln1827">	TRACE(&quot;_LinkDescriptorForPipe pCurrent %p phys 0x%&quot; B_PRIxPHYSADDR</a>
<a name="ln1828">		&quot; 0x%&quot; B_PRIxPHYSADDR &quot; 0x%08&quot; B_PRIx32 &quot;\n&quot;, &amp;endpoint-&gt;trbs[current],</a>
<a name="ln1829">		endpoint-&gt;trb_addr + current * sizeof(struct xhci_trb),</a>
<a name="ln1830">		endpoint-&gt;trbs[current].address,</a>
<a name="ln1831">		B_LENDIAN_TO_HOST_INT32(endpoint-&gt;trbs[current].flags));</a>
<a name="ln1832"> </a>
<a name="ln1833">	endpoint-&gt;current = next;</a>
<a name="ln1834">	mutex_unlock(&amp;endpoint-&gt;lock);</a>
<a name="ln1835"> </a>
<a name="ln1836">	TRACE(&quot;Endpoint status 0x%08&quot; B_PRIx32 &quot; 0x%08&quot; B_PRIx32 &quot; 0x%016&quot; B_PRIx64 &quot;\n&quot;,</a>
<a name="ln1837">		_ReadContext(&amp;endpoint-&gt;device-&gt;device_ctx-&gt;endpoints[endpoint-&gt;id].dwendpoint0),</a>
<a name="ln1838">		_ReadContext(&amp;endpoint-&gt;device-&gt;device_ctx-&gt;endpoints[endpoint-&gt;id].dwendpoint1),</a>
<a name="ln1839">		_ReadContext(&amp;endpoint-&gt;device-&gt;device_ctx-&gt;endpoints[endpoint-&gt;id].qwendpoint2));</a>
<a name="ln1840"> </a>
<a name="ln1841">	Ring(endpoint-&gt;device-&gt;slot, endpoint-&gt;id + 1);</a>
<a name="ln1842"> </a>
<a name="ln1843">	TRACE(&quot;Endpoint status 0x%08&quot; B_PRIx32 &quot; 0x%08&quot; B_PRIx32 &quot; 0x%016&quot; B_PRIx64 &quot;\n&quot;,</a>
<a name="ln1844">		_ReadContext(&amp;endpoint-&gt;device-&gt;device_ctx-&gt;endpoints[endpoint-&gt;id].dwendpoint0),</a>
<a name="ln1845">		_ReadContext(&amp;endpoint-&gt;device-&gt;device_ctx-&gt;endpoints[endpoint-&gt;id].dwendpoint1),</a>
<a name="ln1846">		_ReadContext(&amp;endpoint-&gt;device-&gt;device_ctx-&gt;endpoints[endpoint-&gt;id].qwendpoint2));</a>
<a name="ln1847"> </a>
<a name="ln1848">	return B_OK;</a>
<a name="ln1849">}</a>
<a name="ln1850"> </a>
<a name="ln1851"> </a>
<a name="ln1852">status_t</a>
<a name="ln1853">XHCI::_UnlinkDescriptorForPipe(xhci_td *descriptor, xhci_endpoint *endpoint)</a>
<a name="ln1854">{</a>
<a name="ln1855">	TRACE(&quot;_UnlinkDescriptorForPipe\n&quot;);</a>
<a name="ln1856">	// We presume that the caller has already locked or owns the endpoint.</a>
<a name="ln1857"> </a>
<a name="ln1858">	endpoint-&gt;used--;</a>
<a name="ln1859">	if (descriptor == endpoint-&gt;td_head) {</a>
<a name="ln1860">		endpoint-&gt;td_head = descriptor-&gt;next;</a>
<a name="ln1861">		descriptor-&gt;next = NULL;</a>
<a name="ln1862">		return B_OK;</a>
<a name="ln1863">	} else {</a>
<a name="ln1864">		for (xhci_td *td = endpoint-&gt;td_head; td-&gt;next != NULL; td = td-&gt;next) {</a>
<a name="ln1865">			if (td-&gt;next == descriptor) {</a>
<a name="ln1866">				td-&gt;next = descriptor-&gt;next;</a>
<a name="ln1867">				descriptor-&gt;next = NULL;</a>
<a name="ln1868">				return B_OK;</a>
<a name="ln1869">			}</a>
<a name="ln1870">		}</a>
<a name="ln1871">	}</a>
<a name="ln1872"> </a>
<a name="ln1873">	endpoint-&gt;used++;</a>
<a name="ln1874">	return B_ERROR;</a>
<a name="ln1875">}</a>
<a name="ln1876"> </a>
<a name="ln1877"> </a>
<a name="ln1878">status_t</a>
<a name="ln1879">XHCI::ConfigureEndpoint(uint8 slot, uint8 number, uint8 type, bool directionIn,</a>
<a name="ln1880">	uint64 ringAddr, uint16 interval, uint16 maxPacketSize, usb_speed speed,</a>
<a name="ln1881">	uint8 maxBurst, uint16 bytesPerInterval)</a>
<a name="ln1882">{</a>
<a name="ln1883">	struct xhci_device* device = &amp;fDevices[slot];</a>
<a name="ln1884"> </a>
<a name="ln1885">	uint32 dwendpoint0 = 0;</a>
<a name="ln1886">	uint32 dwendpoint1 = 0;</a>
<a name="ln1887">	uint64 qwendpoint2 = 0;</a>
<a name="ln1888">	uint32 dwendpoint4 = 0;</a>
<a name="ln1889"> </a>
<a name="ln1890">	// Compute and assign the endpoint type. (XHCI 1.1 § 6.2.3 Table 6-9 p429.)</a>
<a name="ln1891">	uint8 xhciType = 4;</a>
<a name="ln1892">	if ((type &amp; USB_OBJECT_INTERRUPT_PIPE) != 0)</a>
<a name="ln1893">		xhciType = 3;</a>
<a name="ln1894">	if ((type &amp; USB_OBJECT_BULK_PIPE) != 0)</a>
<a name="ln1895">		xhciType = 2;</a>
<a name="ln1896">	if ((type &amp; USB_OBJECT_ISO_PIPE) != 0)</a>
<a name="ln1897">		xhciType = 1;</a>
<a name="ln1898">	xhciType |= directionIn ? (1 &lt;&lt; 2) : 0;</a>
<a name="ln1899">	dwendpoint1 |= ENDPOINT_1_EPTYPE(xhciType);</a>
<a name="ln1900"> </a>
<a name="ln1901">	// Compute and assign interval. (XHCI 1.1 § 6.2.3.6 p433.)</a>
<a name="ln1902">	uint16 calcInterval;</a>
<a name="ln1903">	if ((type &amp; USB_OBJECT_BULK_PIPE) != 0</a>
<a name="ln1904">			|| (type &amp; USB_OBJECT_CONTROL_PIPE) != 0) {</a>
<a name="ln1905">		// Bulk and Control endpoints never issue NAKs.</a>
<a name="ln1906">		calcInterval = 0;</a>
<a name="ln1907">	} else {</a>
<a name="ln1908">		switch (speed) {</a>
<a name="ln1909">		case USB_SPEED_FULLSPEED:</a>
<a name="ln1910">			if ((type &amp; USB_OBJECT_ISO_PIPE) != 0) {</a>
<a name="ln1911">				// Convert 1-16 into 3-18.</a>
<a name="ln1912">				calcInterval = min_c(max_c(interval, 1), 16) + 2;</a>
<a name="ln1913">				break;</a>
<a name="ln1914">			}</a>
<a name="ln1915"> </a>
<a name="ln1916">			// fall through</a>
<a name="ln1917">		case USB_SPEED_LOWSPEED: {</a>
<a name="ln1918">			// Convert 1ms-255ms into 3-10.</a>
<a name="ln1919"> </a>
<a name="ln1920">			// Find the index of the highest set bit in &quot;interval&quot;.</a>
<a name="ln1921">			uint32 temp = min_c(max_c(interval, 1), 255);</a>
<a name="ln1922">			for (calcInterval = 0; temp != 1; calcInterval++)</a>
<a name="ln1923">				temp = temp &gt;&gt; 1;</a>
<a name="ln1924">			calcInterval += 3;</a>
<a name="ln1925">			break;</a>
<a name="ln1926">		}</a>
<a name="ln1927"> </a>
<a name="ln1928">		case USB_SPEED_HIGHSPEED:</a>
<a name="ln1929">		case USB_SPEED_SUPER:</a>
<a name="ln1930">		default:</a>
<a name="ln1931">			// Convert 1-16 into 0-15.</a>
<a name="ln1932">			calcInterval = min_c(max_c(interval, 1), 16) - 1;</a>
<a name="ln1933">			break;</a>
<a name="ln1934">		}</a>
<a name="ln1935">	}</a>
<a name="ln1936">	dwendpoint0 |= ENDPOINT_0_INTERVAL(calcInterval);</a>
<a name="ln1937"> </a>
<a name="ln1938">	// For non-isochronous endpoints, we want the controller to retry failed</a>
<a name="ln1939">	// transfers, if possible. (XHCI 1.1 § 4.10.2.3 p189.)</a>
<a name="ln1940">	if ((type &amp; USB_OBJECT_ISO_PIPE) == 0)</a>
<a name="ln1941">		dwendpoint1 |= ENDPOINT_1_CERR(3);</a>
<a name="ln1942"> </a>
<a name="ln1943">	// Assign maximum burst size. For USB3 devices this is passed in; for</a>
<a name="ln1944">	// all other devices we compute it. (XHCI 1.1 § 4.8.2 p154.)</a>
<a name="ln1945">	if (speed == USB_SPEED_HIGHSPEED &amp;&amp; (type &amp; (USB_OBJECT_INTERRUPT_PIPE</a>
<a name="ln1946">			| USB_OBJECT_ISO_PIPE)) != 0) {</a>
<a name="ln1947">		maxBurst = (maxPacketSize &amp; 0x1800) &gt;&gt; 11;</a>
<a name="ln1948">	} else if (speed != USB_SPEED_SUPER) {</a>
<a name="ln1949">		maxBurst = 0;</a>
<a name="ln1950">	}</a>
<a name="ln1951">	dwendpoint1 |= ENDPOINT_1_MAXBURST(maxBurst);</a>
<a name="ln1952"> </a>
<a name="ln1953">	// Assign maximum packet size, set the ring address, and set the</a>
<a name="ln1954">	// &quot;Dequeue Cycle State&quot; bit. (XHCI 1.1 § 6.2.3 Table 6-10 p430.)</a>
<a name="ln1955">	dwendpoint1 |= ENDPOINT_1_MAXPACKETSIZE(maxPacketSize);</a>
<a name="ln1956">	qwendpoint2 |= ENDPOINT_2_DCS_BIT | ringAddr;</a>
<a name="ln1957"> </a>
<a name="ln1958">	// Assign average TRB length.</a>
<a name="ln1959">	if ((type &amp; USB_OBJECT_CONTROL_PIPE) != 0) {</a>
<a name="ln1960">		// Control pipes are a special case, as they rarely have</a>
<a name="ln1961">		// outbound transfers of any substantial size.</a>
<a name="ln1962">		dwendpoint4 |= ENDPOINT_4_AVGTRBLENGTH(8);</a>
<a name="ln1963">	} else {</a>
<a name="ln1964">		dwendpoint4 |= ENDPOINT_4_AVGTRBLENGTH(maxPacketSize * 4);</a>
<a name="ln1965">	}</a>
<a name="ln1966"> </a>
<a name="ln1967">	// Assign maximum ESIT payload. (XHCI 1.1 § 4.14.2 p250.)</a>
<a name="ln1968">	if ((type &amp; (USB_OBJECT_INTERRUPT_PIPE | USB_OBJECT_ISO_PIPE)) != 0) {</a>
<a name="ln1969">		// TODO: For SuperSpeedPlus endpoints, there is yet another descriptor</a>
<a name="ln1970">		// for isochronous endpoints that specifies the maximum ESIT payload.</a>
<a name="ln1971">		// We don't fetch this yet, so just fall back to the USB2 computation</a>
<a name="ln1972">		// method if bytesPerInterval is 0.</a>
<a name="ln1973">		if (speed == USB_SPEED_SUPER &amp;&amp; bytesPerInterval != 0)</a>
<a name="ln1974">			dwendpoint4 |= ENDPOINT_4_MAXESITPAYLOAD(bytesPerInterval);</a>
<a name="ln1975">		else if (speed &gt;= USB_SPEED_HIGHSPEED)</a>
<a name="ln1976">			dwendpoint4 |= ENDPOINT_4_MAXESITPAYLOAD((maxBurst + 1) * maxPacketSize);</a>
<a name="ln1977">	}</a>
<a name="ln1978"> </a>
<a name="ln1979">	_WriteContext(&amp;device-&gt;input_ctx-&gt;endpoints[number].dwendpoint0,</a>
<a name="ln1980">		dwendpoint0);</a>
<a name="ln1981">	_WriteContext(&amp;device-&gt;input_ctx-&gt;endpoints[number].dwendpoint1,</a>
<a name="ln1982">		dwendpoint1);</a>
<a name="ln1983">	_WriteContext(&amp;device-&gt;input_ctx-&gt;endpoints[number].qwendpoint2,</a>
<a name="ln1984">		qwendpoint2);</a>
<a name="ln1985">	_WriteContext(&amp;device-&gt;input_ctx-&gt;endpoints[number].dwendpoint4,</a>
<a name="ln1986">		dwendpoint4);</a>
<a name="ln1987"> </a>
<a name="ln1988">	TRACE(&quot;endpoint 0x%&quot; B_PRIx32 &quot; 0x%&quot; B_PRIx32 &quot; 0x%&quot; B_PRIx64 &quot; 0x%&quot;</a>
<a name="ln1989">		B_PRIx32 &quot;\n&quot;,</a>
<a name="ln1990">		_ReadContext(&amp;device-&gt;input_ctx-&gt;endpoints[number].dwendpoint0),</a>
<a name="ln1991">		_ReadContext(&amp;device-&gt;input_ctx-&gt;endpoints[number].dwendpoint1),</a>
<a name="ln1992">		_ReadContext(&amp;device-&gt;input_ctx-&gt;endpoints[number].qwendpoint2),</a>
<a name="ln1993">		_ReadContext(&amp;device-&gt;input_ctx-&gt;endpoints[number].dwendpoint4));</a>
<a name="ln1994"> </a>
<a name="ln1995">	return B_OK;</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998"> </a>
<a name="ln1999">status_t</a>
<a name="ln2000">XHCI::GetPortSpeed(uint8 index, usb_speed* speed)</a>
<a name="ln2001">{</a>
<a name="ln2002">	uint32 portStatus = ReadOpReg(XHCI_PORTSC(index));</a>
<a name="ln2003"> </a>
<a name="ln2004">	switch (PS_SPEED_GET(portStatus)) {</a>
<a name="ln2005">	case 3:</a>
<a name="ln2006">		*speed = USB_SPEED_HIGHSPEED;</a>
<a name="ln2007">		break;</a>
<a name="ln2008">	case 2:</a>
<a name="ln2009">		*speed = USB_SPEED_LOWSPEED;</a>
<a name="ln2010">		break;</a>
<a name="ln2011">	case 1:</a>
<a name="ln2012">		*speed = USB_SPEED_FULLSPEED;</a>
<a name="ln2013">		break;</a>
<a name="ln2014">	case 4:</a>
<a name="ln2015">		*speed = USB_SPEED_SUPER;</a>
<a name="ln2016">		break;</a>
<a name="ln2017">	default:</a>
<a name="ln2018">		TRACE(&quot;Non Standard Port Speed\n&quot;);</a>
<a name="ln2019">		TRACE(&quot;Assuming Superspeed\n&quot;);</a>
<a name="ln2020">		*speed = USB_SPEED_SUPER;</a>
<a name="ln2021">		break;</a>
<a name="ln2022">	}</a>
<a name="ln2023"> </a>
<a name="ln2024">	return B_OK;</a>
<a name="ln2025">}</a>
<a name="ln2026"> </a>
<a name="ln2027"> </a>
<a name="ln2028">status_t</a>
<a name="ln2029">XHCI::GetPortStatus(uint8 index, usb_port_status* status)</a>
<a name="ln2030">{</a>
<a name="ln2031">	if (index &gt;= fPortCount)</a>
<a name="ln2032">		return B_BAD_INDEX;</a>
<a name="ln2033"> </a>
<a name="ln2034">	status-&gt;status = status-&gt;change = 0;</a>
<a name="ln2035">	uint32 portStatus = ReadOpReg(XHCI_PORTSC(index));</a>
<a name="ln2036">	TRACE(&quot;port %&quot; B_PRId8 &quot; status=0x%08&quot; B_PRIx32 &quot;\n&quot;, index, portStatus);</a>
<a name="ln2037"> </a>
<a name="ln2038">	// build the status</a>
<a name="ln2039">	switch (PS_SPEED_GET(portStatus)) {</a>
<a name="ln2040">	case 3:</a>
<a name="ln2041">		status-&gt;status |= PORT_STATUS_HIGH_SPEED;</a>
<a name="ln2042">		break;</a>
<a name="ln2043">	case 2:</a>
<a name="ln2044">		status-&gt;status |= PORT_STATUS_LOW_SPEED;</a>
<a name="ln2045">		break;</a>
<a name="ln2046">	default:</a>
<a name="ln2047">		break;</a>
<a name="ln2048">	}</a>
<a name="ln2049"> </a>
<a name="ln2050">	if (portStatus &amp; PS_CCS)</a>
<a name="ln2051">		status-&gt;status |= PORT_STATUS_CONNECTION;</a>
<a name="ln2052">	if (portStatus &amp; PS_PED)</a>
<a name="ln2053">		status-&gt;status |= PORT_STATUS_ENABLE;</a>
<a name="ln2054">	if (portStatus &amp; PS_OCA)</a>
<a name="ln2055">		status-&gt;status |= PORT_STATUS_OVER_CURRENT;</a>
<a name="ln2056">	if (portStatus &amp; PS_PR)</a>
<a name="ln2057">		status-&gt;status |= PORT_STATUS_RESET;</a>
<a name="ln2058">	if (portStatus &amp; PS_PP) {</a>
<a name="ln2059">		if (fPortSpeeds[index] == USB_SPEED_SUPER)</a>
<a name="ln2060">			status-&gt;status |= PORT_STATUS_SS_POWER;</a>
<a name="ln2061">		else</a>
<a name="ln2062">			status-&gt;status |= PORT_STATUS_POWER;</a>
<a name="ln2063">	}</a>
<a name="ln2064"> </a>
<a name="ln2065">	// build the change</a>
<a name="ln2066">	if (portStatus &amp; PS_CSC)</a>
<a name="ln2067">		status-&gt;change |= PORT_STATUS_CONNECTION;</a>
<a name="ln2068">	if (portStatus &amp; PS_PEC)</a>
<a name="ln2069">		status-&gt;change |= PORT_STATUS_ENABLE;</a>
<a name="ln2070">	if (portStatus &amp; PS_OCC)</a>
<a name="ln2071">		status-&gt;change |= PORT_STATUS_OVER_CURRENT;</a>
<a name="ln2072">	if (portStatus &amp; PS_PRC)</a>
<a name="ln2073">		status-&gt;change |= PORT_STATUS_RESET;</a>
<a name="ln2074"> </a>
<a name="ln2075">	if (fPortSpeeds[index] == USB_SPEED_SUPER) {</a>
<a name="ln2076">		if (portStatus &amp; PS_PLC)</a>
<a name="ln2077">			status-&gt;change |= PORT_CHANGE_LINK_STATE;</a>
<a name="ln2078">		if (portStatus &amp; PS_WRC)</a>
<a name="ln2079">			status-&gt;change |= PORT_CHANGE_BH_PORT_RESET;</a>
<a name="ln2080">	}</a>
<a name="ln2081"> </a>
<a name="ln2082">	return B_OK;</a>
<a name="ln2083">}</a>
<a name="ln2084"> </a>
<a name="ln2085"> </a>
<a name="ln2086">status_t</a>
<a name="ln2087">XHCI::SetPortFeature(uint8 index, uint16 feature)</a>
<a name="ln2088">{</a>
<a name="ln2089">	TRACE(&quot;set port feature index %u feature %u\n&quot;, index, feature);</a>
<a name="ln2090">	if (index &gt;= fPortCount)</a>
<a name="ln2091">		return B_BAD_INDEX;</a>
<a name="ln2092"> </a>
<a name="ln2093">	uint32 portRegister = XHCI_PORTSC(index);</a>
<a name="ln2094">	uint32 portStatus = ReadOpReg(portRegister) &amp; ~PS_CLEAR;</a>
<a name="ln2095"> </a>
<a name="ln2096">	switch (feature) {</a>
<a name="ln2097">	case PORT_SUSPEND:</a>
<a name="ln2098">		if ((portStatus &amp; PS_PED) == 0 || (portStatus &amp; PS_PR)</a>
<a name="ln2099">			|| (portStatus &amp; PS_PLS_MASK) &gt;= PS_XDEV_U3) {</a>
<a name="ln2100">			TRACE_ERROR(&quot;USB core suspending device not in U0/U1/U2.\n&quot;);</a>
<a name="ln2101">			return B_BAD_VALUE;</a>
<a name="ln2102">		}</a>
<a name="ln2103">		portStatus &amp;= ~PS_PLS_MASK;</a>
<a name="ln2104">		WriteOpReg(portRegister, portStatus | PS_LWS | PS_XDEV_U3);</a>
<a name="ln2105">		break;</a>
<a name="ln2106"> </a>
<a name="ln2107">	case PORT_RESET:</a>
<a name="ln2108">		WriteOpReg(portRegister, portStatus | PS_PR);</a>
<a name="ln2109">		break;</a>
<a name="ln2110"> </a>
<a name="ln2111">	case PORT_POWER:</a>
<a name="ln2112">		WriteOpReg(portRegister, portStatus | PS_PP);</a>
<a name="ln2113">		break;</a>
<a name="ln2114">	default:</a>
<a name="ln2115">		return B_BAD_VALUE;</a>
<a name="ln2116">	}</a>
<a name="ln2117">	ReadOpReg(portRegister);</a>
<a name="ln2118">	return B_OK;</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121"> </a>
<a name="ln2122">status_t</a>
<a name="ln2123">XHCI::ClearPortFeature(uint8 index, uint16 feature)</a>
<a name="ln2124">{</a>
<a name="ln2125">	TRACE(&quot;clear port feature index %u feature %u\n&quot;, index, feature);</a>
<a name="ln2126">	if (index &gt;= fPortCount)</a>
<a name="ln2127">		return B_BAD_INDEX;</a>
<a name="ln2128"> </a>
<a name="ln2129">	uint32 portRegister = XHCI_PORTSC(index);</a>
<a name="ln2130">	uint32 portStatus = ReadOpReg(portRegister) &amp; ~PS_CLEAR;</a>
<a name="ln2131"> </a>
<a name="ln2132">	switch (feature) {</a>
<a name="ln2133">	case PORT_SUSPEND:</a>
<a name="ln2134">		portStatus = ReadOpReg(portRegister);</a>
<a name="ln2135">		if (portStatus &amp; PS_PR)</a>
<a name="ln2136">			return B_BAD_VALUE;</a>
<a name="ln2137">		if (portStatus &amp; PS_XDEV_U3) {</a>
<a name="ln2138">			if ((portStatus &amp; PS_PED) == 0)</a>
<a name="ln2139">				return B_BAD_VALUE;</a>
<a name="ln2140">			portStatus &amp;= ~PS_PLS_MASK;</a>
<a name="ln2141">			WriteOpReg(portRegister, portStatus | PS_XDEV_U0 | PS_LWS);</a>
<a name="ln2142">		}</a>
<a name="ln2143">		break;</a>
<a name="ln2144">	case PORT_ENABLE:</a>
<a name="ln2145">		WriteOpReg(portRegister, portStatus | PS_PED);</a>
<a name="ln2146">		break;</a>
<a name="ln2147">	case PORT_POWER:</a>
<a name="ln2148">		WriteOpReg(portRegister, portStatus &amp; ~PS_PP);</a>
<a name="ln2149">		break;</a>
<a name="ln2150">	case C_PORT_CONNECTION:</a>
<a name="ln2151">		WriteOpReg(portRegister, portStatus | PS_CSC);</a>
<a name="ln2152">		break;</a>
<a name="ln2153">	case C_PORT_ENABLE:</a>
<a name="ln2154">		WriteOpReg(portRegister, portStatus | PS_PEC);</a>
<a name="ln2155">		break;</a>
<a name="ln2156">	case C_PORT_OVER_CURRENT:</a>
<a name="ln2157">		WriteOpReg(portRegister, portStatus | PS_OCC);</a>
<a name="ln2158">		break;</a>
<a name="ln2159">	case C_PORT_RESET:</a>
<a name="ln2160">		WriteOpReg(portRegister, portStatus | PS_PRC);</a>
<a name="ln2161">		break;</a>
<a name="ln2162">	case C_PORT_BH_PORT_RESET:</a>
<a name="ln2163">		WriteOpReg(portRegister, portStatus | PS_WRC);</a>
<a name="ln2164">		break;</a>
<a name="ln2165">	case C_PORT_LINK_STATE:</a>
<a name="ln2166">		WriteOpReg(portRegister, portStatus | PS_PLC);</a>
<a name="ln2167">		break;</a>
<a name="ln2168">	default:</a>
<a name="ln2169">		return B_BAD_VALUE;</a>
<a name="ln2170">	}</a>
<a name="ln2171"> </a>
<a name="ln2172">	ReadOpReg(portRegister);</a>
<a name="ln2173">	return B_OK;</a>
<a name="ln2174">}</a>
<a name="ln2175"> </a>
<a name="ln2176"> </a>
<a name="ln2177">status_t</a>
<a name="ln2178">XHCI::ControllerHalt()</a>
<a name="ln2179">{</a>
<a name="ln2180">	// Mask off run state</a>
<a name="ln2181">	WriteOpReg(XHCI_CMD, ReadOpReg(XHCI_CMD) &amp; ~CMD_RUN);</a>
<a name="ln2182"> </a>
<a name="ln2183">	// wait for shutdown state</a>
<a name="ln2184">	if (WaitOpBits(XHCI_STS, STS_HCH, STS_HCH) != B_OK) {</a>
<a name="ln2185">		TRACE_ERROR(&quot;HCH shutdown timeout\n&quot;);</a>
<a name="ln2186">		return B_ERROR;</a>
<a name="ln2187">	}</a>
<a name="ln2188">	return B_OK;</a>
<a name="ln2189">}</a>
<a name="ln2190"> </a>
<a name="ln2191"> </a>
<a name="ln2192">status_t</a>
<a name="ln2193">XHCI::ControllerReset()</a>
<a name="ln2194">{</a>
<a name="ln2195">	TRACE(&quot;ControllerReset() cmd: 0x%&quot; B_PRIx32 &quot; sts: 0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln2196">		ReadOpReg(XHCI_CMD), ReadOpReg(XHCI_STS));</a>
<a name="ln2197">	WriteOpReg(XHCI_CMD, ReadOpReg(XHCI_CMD) | CMD_HCRST);</a>
<a name="ln2198"> </a>
<a name="ln2199">	if (WaitOpBits(XHCI_CMD, CMD_HCRST, 0) != B_OK) {</a>
<a name="ln2200">		TRACE_ERROR(&quot;ControllerReset() failed CMD_HCRST\n&quot;);</a>
<a name="ln2201">		return B_ERROR;</a>
<a name="ln2202">	}</a>
<a name="ln2203"> </a>
<a name="ln2204">	if (WaitOpBits(XHCI_STS, STS_CNR, 0) != B_OK) {</a>
<a name="ln2205">		TRACE_ERROR(&quot;ControllerReset() failed STS_CNR\n&quot;);</a>
<a name="ln2206">		return B_ERROR;</a>
<a name="ln2207">	}</a>
<a name="ln2208"> </a>
<a name="ln2209">	return B_OK;</a>
<a name="ln2210">}</a>
<a name="ln2211"> </a>
<a name="ln2212"> </a>
<a name="ln2213">int32</a>
<a name="ln2214">XHCI::InterruptHandler(void* data)</a>
<a name="ln2215">{</a>
<a name="ln2216">	return ((XHCI*)data)-&gt;Interrupt();</a>
<a name="ln2217">}</a>
<a name="ln2218"> </a>
<a name="ln2219"> </a>
<a name="ln2220">int32</a>
<a name="ln2221">XHCI::Interrupt()</a>
<a name="ln2222">{</a>
<a name="ln2223">	SpinLocker _(&amp;fSpinlock);</a>
<a name="ln2224"> </a>
<a name="ln2225">	uint32 status = ReadOpReg(XHCI_STS);</a>
<a name="ln2226">	uint32 temp = ReadRunReg32(XHCI_IMAN(0));</a>
<a name="ln2227">	WriteOpReg(XHCI_STS, status);</a>
<a name="ln2228">	WriteRunReg32(XHCI_IMAN(0), temp);</a>
<a name="ln2229"> </a>
<a name="ln2230">	int32 result = B_HANDLED_INTERRUPT;</a>
<a name="ln2231"> </a>
<a name="ln2232">	if ((status &amp; STS_HCH) != 0) {</a>
<a name="ln2233">		TRACE_ERROR(&quot;Host Controller halted\n&quot;);</a>
<a name="ln2234">		return result;</a>
<a name="ln2235">	}</a>
<a name="ln2236">	if ((status &amp; STS_HSE) != 0) {</a>
<a name="ln2237">		TRACE_ERROR(&quot;Host System Error\n&quot;);</a>
<a name="ln2238">		return result;</a>
<a name="ln2239">	}</a>
<a name="ln2240">	if ((status &amp; STS_HCE) != 0) {</a>
<a name="ln2241">		TRACE_ERROR(&quot;Host Controller Error\n&quot;);</a>
<a name="ln2242">		return result;</a>
<a name="ln2243">	}</a>
<a name="ln2244"> </a>
<a name="ln2245">	if ((status &amp; STS_EINT) == 0) {</a>
<a name="ln2246">		TRACE(&quot;STS: 0x%&quot; B_PRIx32 &quot; IRQ_PENDING: 0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln2247">			status, temp);</a>
<a name="ln2248">		return B_UNHANDLED_INTERRUPT;</a>
<a name="ln2249">	}</a>
<a name="ln2250"> </a>
<a name="ln2251">	TRACE(&quot;Event Interrupt\n&quot;);</a>
<a name="ln2252">	release_sem_etc(fEventSem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln2253">	return B_INVOKE_SCHEDULER;</a>
<a name="ln2254">}</a>
<a name="ln2255"> </a>
<a name="ln2256"> </a>
<a name="ln2257">void</a>
<a name="ln2258">XHCI::Ring(uint8 slot, uint8 endpoint)</a>
<a name="ln2259">{</a>
<a name="ln2260">	TRACE(&quot;Ding Dong! slot:%d endpoint %d\n&quot;, slot, endpoint)</a>
<a name="ln2261">	if ((slot == 0 &amp;&amp; endpoint &gt; 0) || (slot &gt; 0 &amp;&amp; endpoint == 0))</a>
<a name="ln2262">		panic(&quot;Ring() invalid slot/endpoint combination\n&quot;);</a>
<a name="ln2263">	if (slot &gt; fSlotCount || endpoint &gt;= XHCI_MAX_ENDPOINTS)</a>
<a name="ln2264">		panic(&quot;Ring() invalid slot or endpoint\n&quot;);</a>
<a name="ln2265"> </a>
<a name="ln2266">	WriteDoorReg32(XHCI_DOORBELL(slot), XHCI_DOORBELL_TARGET(endpoint)</a>
<a name="ln2267">		| XHCI_DOORBELL_STREAMID(0));</a>
<a name="ln2268">	/* Flush PCI posted writes */</a>
<a name="ln2269">	ReadDoorReg32(XHCI_DOORBELL(slot));</a>
<a name="ln2270">}</a>
<a name="ln2271"> </a>
<a name="ln2272"> </a>
<a name="ln2273">void</a>
<a name="ln2274">XHCI::QueueCommand(xhci_trb* trb)</a>
<a name="ln2275">{</a>
<a name="ln2276">	uint8 i, j;</a>
<a name="ln2277">	uint32 temp;</a>
<a name="ln2278"> </a>
<a name="ln2279">	i = fCmdIdx;</a>
<a name="ln2280">	j = fCmdCcs;</a>
<a name="ln2281"> </a>
<a name="ln2282">	TRACE(&quot;command[%u] = %&quot; B_PRId32 &quot; (0x%016&quot; B_PRIx64 &quot;, 0x%08&quot; B_PRIx32</a>
<a name="ln2283">		&quot;, 0x%08&quot; B_PRIx32 &quot;)\n&quot;, i, TRB_3_TYPE_GET(trb-&gt;flags), trb-&gt;address,</a>
<a name="ln2284">		trb-&gt;status, trb-&gt;flags);</a>
<a name="ln2285"> </a>
<a name="ln2286">	fCmdRing[i].address = trb-&gt;address;</a>
<a name="ln2287">	fCmdRing[i].status = trb-&gt;status;</a>
<a name="ln2288">	temp = trb-&gt;flags;</a>
<a name="ln2289"> </a>
<a name="ln2290">	if (j)</a>
<a name="ln2291">		temp |= TRB_3_CYCLE_BIT;</a>
<a name="ln2292">	else</a>
<a name="ln2293">		temp &amp;= ~TRB_3_CYCLE_BIT;</a>
<a name="ln2294">	temp &amp;= ~TRB_3_TC_BIT;</a>
<a name="ln2295">	fCmdRing[i].flags = B_HOST_TO_LENDIAN_INT32(temp);</a>
<a name="ln2296"> </a>
<a name="ln2297">	fCmdAddr = fErst-&gt;rs_addr + (XHCI_MAX_EVENTS + i) * sizeof(xhci_trb);</a>
<a name="ln2298"> </a>
<a name="ln2299">	i++;</a>
<a name="ln2300"> </a>
<a name="ln2301">	if (i == (XHCI_MAX_COMMANDS - 1)) {</a>
<a name="ln2302">		temp = TRB_3_TYPE(TRB_TYPE_LINK) | TRB_3_TC_BIT;</a>
<a name="ln2303">		if (j)</a>
<a name="ln2304">			temp |= TRB_3_CYCLE_BIT;</a>
<a name="ln2305">		fCmdRing[i].flags = B_HOST_TO_LENDIAN_INT32(temp);</a>
<a name="ln2306"> </a>
<a name="ln2307">		i = 0;</a>
<a name="ln2308">		j ^= 1;</a>
<a name="ln2309">	}</a>
<a name="ln2310"> </a>
<a name="ln2311">	fCmdIdx = i;</a>
<a name="ln2312">	fCmdCcs = j;</a>
<a name="ln2313">}</a>
<a name="ln2314"> </a>
<a name="ln2315"> </a>
<a name="ln2316">void</a>
<a name="ln2317">XHCI::HandleCmdComplete(xhci_trb* trb)</a>
<a name="ln2318">{</a>
<a name="ln2319">	TRACE(&quot;HandleCmdComplete trb %p\n&quot;, trb);</a>
<a name="ln2320"> </a>
<a name="ln2321">	if (fCmdAddr == trb-&gt;address) {</a>
<a name="ln2322">		TRACE(&quot;Received command event\n&quot;);</a>
<a name="ln2323">		fCmdResult[0] = trb-&gt;status;</a>
<a name="ln2324">		fCmdResult[1] = B_LENDIAN_TO_HOST_INT32(trb-&gt;flags);</a>
<a name="ln2325">		release_sem_etc(fCmdCompSem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln2326">	}</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329"> </a>
<a name="ln2330">void</a>
<a name="ln2331">XHCI::HandleTransferComplete(xhci_trb* trb)</a>
<a name="ln2332">{</a>
<a name="ln2333">	TRACE(&quot;HandleTransferComplete trb %p\n&quot;, trb);</a>
<a name="ln2334"> </a>
<a name="ln2335">	const uint32 flags = B_LENDIAN_TO_HOST_INT32(trb-&gt;flags);</a>
<a name="ln2336">	const uint8 endpointNumber = TRB_3_ENDPOINT_GET(flags),</a>
<a name="ln2337">		slot = TRB_3_SLOT_GET(flags);</a>
<a name="ln2338"> </a>
<a name="ln2339">	if (slot &gt; fSlotCount)</a>
<a name="ln2340">		TRACE_ERROR(&quot;invalid slot\n&quot;);</a>
<a name="ln2341">	if (endpointNumber == 0 || endpointNumber &gt;= XHCI_MAX_ENDPOINTS) {</a>
<a name="ln2342">		TRACE_ERROR(&quot;invalid endpoint\n&quot;);</a>
<a name="ln2343">		return;</a>
<a name="ln2344">	}</a>
<a name="ln2345"> </a>
<a name="ln2346">	xhci_device *device = &amp;fDevices[slot];</a>
<a name="ln2347">	xhci_endpoint *endpoint = &amp;device-&gt;endpoints[endpointNumber - 1];</a>
<a name="ln2348"> </a>
<a name="ln2349">	if (endpoint-&gt;trbs == NULL) {</a>
<a name="ln2350">		TRACE_ERROR(&quot;got TRB but endpoint is not allocated!\n&quot;);</a>
<a name="ln2351">		return;</a>
<a name="ln2352">	}</a>
<a name="ln2353"> </a>
<a name="ln2354">	// Use mutex_trylock first, in case we are in KDL.</a>
<a name="ln2355">	MutexLocker endpointLocker(endpoint-&gt;lock,</a>
<a name="ln2356">		mutex_trylock(&amp;endpoint-&gt;lock) == B_OK);</a>
<a name="ln2357">	if (!endpointLocker.IsLocked()) {</a>
<a name="ln2358">		// We failed to get the lock. Most likely it was destroyed</a>
<a name="ln2359">		// while we were waiting for it.</a>
<a name="ln2360">		return;</a>
<a name="ln2361">	}</a>
<a name="ln2362"> </a>
<a name="ln2363">	// In the case of an Event Data TRB, the &quot;transferred&quot; field refers</a>
<a name="ln2364">	// to the actual number of bytes transferred across the whole TD.</a>
<a name="ln2365">	// (XHCI 1.2 § 6.4.2.1 Table 6-38 p478.)</a>
<a name="ln2366">	const uint8 completionCode = TRB_2_COMP_CODE_GET(trb-&gt;status);</a>
<a name="ln2367">	int32 transferred = TRB_2_REM_GET(trb-&gt;status), remainder = -1;</a>
<a name="ln2368"> </a>
<a name="ln2369">	TRACE(&quot;HandleTransferComplete: ed %d, code %d, transferred %d\n&quot;,</a>
<a name="ln2370">		  (flags &amp; TRB_3_EVENT_DATA_BIT), completionCode, transferred);</a>
<a name="ln2371"> </a>
<a name="ln2372">	if ((flags &amp; TRB_3_EVENT_DATA_BIT) == 0) {</a>
<a name="ln2373">		TRACE_ALWAYS(&quot;got an interrupt for a non-Event Data TRB!\n&quot;);</a>
<a name="ln2374">		remainder = transferred;</a>
<a name="ln2375">		transferred = -1;</a>
<a name="ln2376">	}</a>
<a name="ln2377"> </a>
<a name="ln2378">	const phys_addr_t source = B_LENDIAN_TO_HOST_INT64(trb-&gt;address);</a>
<a name="ln2379">	for (xhci_td *td = endpoint-&gt;td_head; td != NULL; td = td-&gt;next) {</a>
<a name="ln2380">		int64 offset = (source - td-&gt;trb_addr) / sizeof(xhci_trb);</a>
<a name="ln2381">		if (offset &lt; 0 || offset &gt;= td-&gt;trb_count)</a>
<a name="ln2382">			continue;</a>
<a name="ln2383"> </a>
<a name="ln2384">		TRACE(&quot;HandleTransferComplete td %p trb %&quot; B_PRId64 &quot; found\n&quot;,</a>
<a name="ln2385">			td, offset);</a>
<a name="ln2386"> </a>
<a name="ln2387">		// The TRB at offset trb_used will be the link TRB, which we do not</a>
<a name="ln2388">		// care about (and should not generate an interrupt at all.) We really</a>
<a name="ln2389">		// care about the properly last TRB, at index &quot;count - 1&quot;, which the</a>
<a name="ln2390">		// Event Data TRB that _LinkDescriptorForPipe creates points to.</a>
<a name="ln2391">		//</a>
<a name="ln2392">		// But if we have an unsuccessful completion code, the transfer</a>
<a name="ln2393">		// likely failed midway; so just accept it anyway.</a>
<a name="ln2394">		if (offset == (td-&gt;trb_used - 1) || completionCode != COMP_SUCCESS) {</a>
<a name="ln2395">			_UnlinkDescriptorForPipe(td, endpoint);</a>
<a name="ln2396">			endpointLocker.Unlock();</a>
<a name="ln2397"> </a>
<a name="ln2398">			td-&gt;trb_completion_code = completionCode;</a>
<a name="ln2399">			td-&gt;td_transferred = transferred;</a>
<a name="ln2400">			td-&gt;trb_left = remainder;</a>
<a name="ln2401"> </a>
<a name="ln2402">			// add descriptor to finished list</a>
<a name="ln2403">			if (mutex_trylock(&amp;fFinishedLock) != B_OK)</a>
<a name="ln2404">				mutex_lock(&amp;fFinishedLock);</a>
<a name="ln2405">			td-&gt;next = fFinishedHead;</a>
<a name="ln2406">			fFinishedHead = td;</a>
<a name="ln2407">			mutex_unlock(&amp;fFinishedLock);</a>
<a name="ln2408"> </a>
<a name="ln2409">			release_sem_etc(fFinishTransfersSem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln2410">			TRACE(&quot;HandleTransferComplete td %p done\n&quot;, td);</a>
<a name="ln2411">		} else {</a>
<a name="ln2412">			TRACE_ERROR(&quot;successful TRB 0x%&quot; B_PRIxPHYSADDR &quot; was found, but it wasn't &quot;</a>
<a name="ln2413">				&quot;the last in the TD!\n&quot;, source);</a>
<a name="ln2414">		}</a>
<a name="ln2415">		return;</a>
<a name="ln2416">	}</a>
<a name="ln2417">	TRACE_ERROR(&quot;TRB 0x%&quot; B_PRIxPHYSADDR &quot; was not found in the endpoint!\n&quot;, source);</a>
<a name="ln2418">}</a>
<a name="ln2419"> </a>
<a name="ln2420"> </a>
<a name="ln2421">void</a>
<a name="ln2422">XHCI::DumpRing(xhci_trb *trbs, uint32 size)</a>
<a name="ln2423">{</a>
<a name="ln2424">	if (!Lock()) {</a>
<a name="ln2425">		TRACE(&quot;Unable to get lock!\n&quot;);</a>
<a name="ln2426">		return;</a>
<a name="ln2427">	}</a>
<a name="ln2428"> </a>
<a name="ln2429">	for (uint32 i = 0; i &lt; size; i++) {</a>
<a name="ln2430">		TRACE(&quot;command[%&quot; B_PRId32 &quot;] = %&quot; B_PRId32 &quot; (0x%016&quot; B_PRIx64 &quot;,&quot;</a>
<a name="ln2431">			&quot; 0x%08&quot; B_PRIx32 &quot;, 0x%08&quot; B_PRIx32 &quot;)\n&quot;, i,</a>
<a name="ln2432">			TRB_3_TYPE_GET(B_LENDIAN_TO_HOST_INT32(trbs[i].flags)),</a>
<a name="ln2433">			trbs[i].address, trbs[i].status, trbs[i].flags);</a>
<a name="ln2434">	}</a>
<a name="ln2435"> </a>
<a name="ln2436">	Unlock();</a>
<a name="ln2437">}</a>
<a name="ln2438"> </a>
<a name="ln2439"> </a>
<a name="ln2440">status_t</a>
<a name="ln2441">XHCI::DoCommand(xhci_trb* trb)</a>
<a name="ln2442">{</a>
<a name="ln2443">	if (!Lock()) {</a>
<a name="ln2444">		TRACE(&quot;Unable to get lock!\n&quot;);</a>
<a name="ln2445">		return B_ERROR;</a>
<a name="ln2446">	}</a>
<a name="ln2447"> </a>
<a name="ln2448">	QueueCommand(trb);</a>
<a name="ln2449">	Ring(0, 0);</a>
<a name="ln2450"> </a>
<a name="ln2451">	if (acquire_sem_etc(fCmdCompSem, 1, B_RELATIVE_TIMEOUT, 1 * 1000 * 1000) &lt; B_OK) {</a>
<a name="ln2452">		TRACE(&quot;Unable to obtain fCmdCompSem!\n&quot;);</a>
<a name="ln2453">		Unlock();</a>
<a name="ln2454">		return B_TIMED_OUT;</a>
<a name="ln2455">	}</a>
<a name="ln2456">	// eat up sems that have been released by multiple interrupts</a>
<a name="ln2457">	int32 semCount = 0;</a>
<a name="ln2458">	get_sem_count(fCmdCompSem, &amp;semCount);</a>
<a name="ln2459">	if (semCount &gt; 0)</a>
<a name="ln2460">		acquire_sem_etc(fCmdCompSem, semCount, B_RELATIVE_TIMEOUT, 0);</a>
<a name="ln2461"> </a>
<a name="ln2462">	status_t status = B_OK;</a>
<a name="ln2463">	uint32 completionCode = TRB_2_COMP_CODE_GET(fCmdResult[0]);</a>
<a name="ln2464">	TRACE(&quot;Command Complete. Result: %&quot; B_PRId32 &quot;\n&quot;, completionCode);</a>
<a name="ln2465">	if (completionCode != COMP_SUCCESS) {</a>
<a name="ln2466">		TRACE_ERROR(&quot;unsuccessful command %&quot; B_PRId32 &quot;, error %s (%&quot; B_PRId32 &quot;)\n&quot;,</a>
<a name="ln2467">			TRB_3_TYPE_GET(trb-&gt;flags), xhci_error_string(completionCode),</a>
<a name="ln2468">			completionCode);</a>
<a name="ln2469">		status = B_IO_ERROR;</a>
<a name="ln2470">	}</a>
<a name="ln2471"> </a>
<a name="ln2472">	trb-&gt;status = fCmdResult[0];</a>
<a name="ln2473">	trb-&gt;flags = fCmdResult[1];</a>
<a name="ln2474">	TRACE(&quot;Storing trb 0x%08&quot; B_PRIx32 &quot; 0x%08&quot; B_PRIx32 &quot;\n&quot;, trb-&gt;status,</a>
<a name="ln2475">		trb-&gt;flags);</a>
<a name="ln2476"> </a>
<a name="ln2477">	Unlock();</a>
<a name="ln2478">	return status;</a>
<a name="ln2479">}</a>
<a name="ln2480"> </a>
<a name="ln2481"> </a>
<a name="ln2482">status_t</a>
<a name="ln2483">XHCI::Noop()</a>
<a name="ln2484">{</a>
<a name="ln2485">	TRACE(&quot;Issue No-Op\n&quot;);</a>
<a name="ln2486">	xhci_trb trb;</a>
<a name="ln2487">	trb.address = 0;</a>
<a name="ln2488">	trb.status = 0;</a>
<a name="ln2489">	trb.flags = TRB_3_TYPE(TRB_TYPE_CMD_NOOP);</a>
<a name="ln2490"> </a>
<a name="ln2491">	return DoCommand(&amp;trb);</a>
<a name="ln2492">}</a>
<a name="ln2493"> </a>
<a name="ln2494"> </a>
<a name="ln2495">status_t</a>
<a name="ln2496">XHCI::EnableSlot(uint8* slot)</a>
<a name="ln2497">{</a>
<a name="ln2498">	TRACE(&quot;Enable Slot\n&quot;);</a>
<a name="ln2499">	xhci_trb trb;</a>
<a name="ln2500">	trb.address = 0;</a>
<a name="ln2501">	trb.status = 0;</a>
<a name="ln2502">	trb.flags = TRB_3_TYPE(TRB_TYPE_ENABLE_SLOT);</a>
<a name="ln2503"> </a>
<a name="ln2504">	status_t status = DoCommand(&amp;trb);</a>
<a name="ln2505">	if (status != B_OK)</a>
<a name="ln2506">		return status;</a>
<a name="ln2507"> </a>
<a name="ln2508">	*slot = TRB_3_SLOT_GET(trb.flags);</a>
<a name="ln2509">	return *slot != 0 ? B_OK : B_BAD_VALUE;</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512"> </a>
<a name="ln2513">status_t</a>
<a name="ln2514">XHCI::DisableSlot(uint8 slot)</a>
<a name="ln2515">{</a>
<a name="ln2516">	TRACE(&quot;Disable Slot\n&quot;);</a>
<a name="ln2517">	xhci_trb trb;</a>
<a name="ln2518">	trb.address = 0;</a>
<a name="ln2519">	trb.status = 0;</a>
<a name="ln2520">	trb.flags = TRB_3_TYPE(TRB_TYPE_DISABLE_SLOT) | TRB_3_SLOT(slot);</a>
<a name="ln2521"> </a>
<a name="ln2522">	return DoCommand(&amp;trb);</a>
<a name="ln2523">}</a>
<a name="ln2524"> </a>
<a name="ln2525"> </a>
<a name="ln2526">status_t</a>
<a name="ln2527">XHCI::SetAddress(uint64 inputContext, bool bsr, uint8 slot)</a>
<a name="ln2528">{</a>
<a name="ln2529">	TRACE(&quot;Set Address\n&quot;);</a>
<a name="ln2530">	xhci_trb trb;</a>
<a name="ln2531">	trb.address = inputContext;</a>
<a name="ln2532">	trb.status = 0;</a>
<a name="ln2533">	trb.flags = TRB_3_TYPE(TRB_TYPE_ADDRESS_DEVICE) | TRB_3_SLOT(slot);</a>
<a name="ln2534"> </a>
<a name="ln2535">	if (bsr)</a>
<a name="ln2536">		trb.flags |= TRB_3_BSR_BIT;</a>
<a name="ln2537"> </a>
<a name="ln2538">	return DoCommand(&amp;trb);</a>
<a name="ln2539">}</a>
<a name="ln2540"> </a>
<a name="ln2541"> </a>
<a name="ln2542">status_t</a>
<a name="ln2543">XHCI::ConfigureEndpoint(uint64 inputContext, bool deconfigure, uint8 slot)</a>
<a name="ln2544">{</a>
<a name="ln2545">	TRACE(&quot;Configure Endpoint\n&quot;);</a>
<a name="ln2546">	xhci_trb trb;</a>
<a name="ln2547">	trb.address = inputContext;</a>
<a name="ln2548">	trb.status = 0;</a>
<a name="ln2549">	trb.flags = TRB_3_TYPE(TRB_TYPE_CONFIGURE_ENDPOINT) | TRB_3_SLOT(slot);</a>
<a name="ln2550"> </a>
<a name="ln2551">	if (deconfigure)</a>
<a name="ln2552">		trb.flags |= TRB_3_DCEP_BIT;</a>
<a name="ln2553"> </a>
<a name="ln2554">	return DoCommand(&amp;trb);</a>
<a name="ln2555">}</a>
<a name="ln2556"> </a>
<a name="ln2557"> </a>
<a name="ln2558">status_t</a>
<a name="ln2559">XHCI::EvaluateContext(uint64 inputContext, uint8 slot)</a>
<a name="ln2560">{</a>
<a name="ln2561">	TRACE(&quot;Evaluate Context\n&quot;);</a>
<a name="ln2562">	xhci_trb trb;</a>
<a name="ln2563">	trb.address = inputContext;</a>
<a name="ln2564">	trb.status = 0;</a>
<a name="ln2565">	trb.flags = TRB_3_TYPE(TRB_TYPE_EVALUATE_CONTEXT) | TRB_3_SLOT(slot);</a>
<a name="ln2566"> </a>
<a name="ln2567">	return DoCommand(&amp;trb);</a>
<a name="ln2568">}</a>
<a name="ln2569"> </a>
<a name="ln2570"> </a>
<a name="ln2571">status_t</a>
<a name="ln2572">XHCI::ResetEndpoint(bool preserve, uint8 endpoint, uint8 slot)</a>
<a name="ln2573">{</a>
<a name="ln2574">	TRACE(&quot;Reset Endpoint\n&quot;);</a>
<a name="ln2575">	xhci_trb trb;</a>
<a name="ln2576">	trb.address = 0;</a>
<a name="ln2577">	trb.status = 0;</a>
<a name="ln2578">	trb.flags = TRB_3_TYPE(TRB_TYPE_RESET_ENDPOINT)</a>
<a name="ln2579">		| TRB_3_SLOT(slot) | TRB_3_ENDPOINT(endpoint);</a>
<a name="ln2580">	if (preserve)</a>
<a name="ln2581">		trb.flags |= TRB_3_PRSV_BIT;</a>
<a name="ln2582"> </a>
<a name="ln2583">	return DoCommand(&amp;trb);</a>
<a name="ln2584">}</a>
<a name="ln2585"> </a>
<a name="ln2586"> </a>
<a name="ln2587">status_t</a>
<a name="ln2588">XHCI::StopEndpoint(bool suspend, uint8 endpoint, uint8 slot)</a>
<a name="ln2589">{</a>
<a name="ln2590">	TRACE(&quot;Stop Endpoint\n&quot;);</a>
<a name="ln2591">	xhci_trb trb;</a>
<a name="ln2592">	trb.address = 0;</a>
<a name="ln2593">	trb.status = 0;</a>
<a name="ln2594">	trb.flags = TRB_3_TYPE(TRB_TYPE_STOP_ENDPOINT)</a>
<a name="ln2595">		| TRB_3_SLOT(slot) | TRB_3_ENDPOINT(endpoint);</a>
<a name="ln2596">	if (suspend)</a>
<a name="ln2597">		trb.flags |= TRB_3_SUSPEND_ENDPOINT_BIT;</a>
<a name="ln2598"> </a>
<a name="ln2599">	return DoCommand(&amp;trb);</a>
<a name="ln2600">}</a>
<a name="ln2601"> </a>
<a name="ln2602"> </a>
<a name="ln2603">status_t</a>
<a name="ln2604">XHCI::SetTRDequeue(uint64 dequeue, uint16 stream, uint8 endpoint, uint8 slot)</a>
<a name="ln2605">{</a>
<a name="ln2606">	TRACE(&quot;Set TR Dequeue\n&quot;);</a>
<a name="ln2607">	xhci_trb trb;</a>
<a name="ln2608">	trb.address = dequeue | ENDPOINT_2_DCS_BIT;</a>
<a name="ln2609">		// The DCS bit is copied from the address field as in ConfigureEndpoint.</a>
<a name="ln2610">		// (XHCI 1.1 § 4.6.10 p142.)</a>
<a name="ln2611">	trb.status = TRB_2_STREAM(stream);</a>
<a name="ln2612">	trb.flags = TRB_3_TYPE(TRB_TYPE_SET_TR_DEQUEUE)</a>
<a name="ln2613">		| TRB_3_SLOT(slot) | TRB_3_ENDPOINT(endpoint);</a>
<a name="ln2614"> </a>
<a name="ln2615">	return DoCommand(&amp;trb);</a>
<a name="ln2616">}</a>
<a name="ln2617"> </a>
<a name="ln2618"> </a>
<a name="ln2619">status_t</a>
<a name="ln2620">XHCI::ResetDevice(uint8 slot)</a>
<a name="ln2621">{</a>
<a name="ln2622">	TRACE(&quot;Reset Device\n&quot;);</a>
<a name="ln2623">	xhci_trb trb;</a>
<a name="ln2624">	trb.address = 0;</a>
<a name="ln2625">	trb.status = 0;</a>
<a name="ln2626">	trb.flags = TRB_3_TYPE(TRB_TYPE_RESET_DEVICE) | TRB_3_SLOT(slot);</a>
<a name="ln2627"> </a>
<a name="ln2628">	return DoCommand(&amp;trb);</a>
<a name="ln2629">}</a>
<a name="ln2630"> </a>
<a name="ln2631"> </a>
<a name="ln2632">int32</a>
<a name="ln2633">XHCI::EventThread(void* data)</a>
<a name="ln2634">{</a>
<a name="ln2635">	((XHCI *)data)-&gt;CompleteEvents();</a>
<a name="ln2636">	return B_OK;</a>
<a name="ln2637">}</a>
<a name="ln2638"> </a>
<a name="ln2639"> </a>
<a name="ln2640">void</a>
<a name="ln2641">XHCI::CompleteEvents()</a>
<a name="ln2642">{</a>
<a name="ln2643">	while (!fStopThreads) {</a>
<a name="ln2644">		if (acquire_sem(fEventSem) &lt; B_OK)</a>
<a name="ln2645">			continue;</a>
<a name="ln2646"> </a>
<a name="ln2647">		// eat up sems that have been released by multiple interrupts</a>
<a name="ln2648">		int32 semCount = 0;</a>
<a name="ln2649">		get_sem_count(fEventSem, &amp;semCount);</a>
<a name="ln2650">		if (semCount &gt; 0)</a>
<a name="ln2651">			acquire_sem_etc(fEventSem, semCount, B_RELATIVE_TIMEOUT, 0);</a>
<a name="ln2652"> </a>
<a name="ln2653">		ProcessEvents();</a>
<a name="ln2654">	}</a>
<a name="ln2655">}</a>
<a name="ln2656"> </a>
<a name="ln2657"> </a>
<a name="ln2658">void</a>
<a name="ln2659">XHCI::ProcessEvents()</a>
<a name="ln2660">{</a>
<a name="ln2661">	// Use mutex_trylock first, in case we are in KDL.</a>
<a name="ln2662">	MutexLocker locker(fEventLock, mutex_trylock(&amp;fEventLock) == B_OK);</a>
<a name="ln2663">	if (!locker.IsLocked()) {</a>
<a name="ln2664">		// We failed to get the lock. This really should not happen.</a>
<a name="ln2665">		TRACE_ERROR(&quot;failed to acquire event lock!\n&quot;);</a>
<a name="ln2666">		return;</a>
<a name="ln2667">	}</a>
<a name="ln2668"> </a>
<a name="ln2669">	uint16 i = fEventIdx;</a>
<a name="ln2670">	uint8 j = fEventCcs;</a>
<a name="ln2671">	uint8 t = 2;</a>
<a name="ln2672"> </a>
<a name="ln2673">	while (1) {</a>
<a name="ln2674">		uint32 temp = B_LENDIAN_TO_HOST_INT32(fEventRing[i].flags);</a>
<a name="ln2675">		uint8 event = TRB_3_TYPE_GET(temp);</a>
<a name="ln2676">		TRACE(&quot;event[%u] = %u (0x%016&quot; B_PRIx64 &quot; 0x%08&quot; B_PRIx32 &quot; 0x%08&quot;</a>
<a name="ln2677">			B_PRIx32 &quot;)\n&quot;, i, event, fEventRing[i].address,</a>
<a name="ln2678">			fEventRing[i].status, B_LENDIAN_TO_HOST_INT32(fEventRing[i].flags));</a>
<a name="ln2679">		uint8 k = (temp &amp; TRB_3_CYCLE_BIT) ? 1 : 0;</a>
<a name="ln2680">		if (j != k)</a>
<a name="ln2681">			break;</a>
<a name="ln2682"> </a>
<a name="ln2683">		switch (event) {</a>
<a name="ln2684">		case TRB_TYPE_COMMAND_COMPLETION:</a>
<a name="ln2685">			HandleCmdComplete(&amp;fEventRing[i]);</a>
<a name="ln2686">			break;</a>
<a name="ln2687">		case TRB_TYPE_TRANSFER:</a>
<a name="ln2688">			HandleTransferComplete(&amp;fEventRing[i]);</a>
<a name="ln2689">			break;</a>
<a name="ln2690">		case TRB_TYPE_PORT_STATUS_CHANGE:</a>
<a name="ln2691">			TRACE(&quot;port change detected\n&quot;);</a>
<a name="ln2692">			break;</a>
<a name="ln2693">		default:</a>
<a name="ln2694">			TRACE_ERROR(&quot;Unhandled event = %u\n&quot;, event);</a>
<a name="ln2695">			break;</a>
<a name="ln2696">		}</a>
<a name="ln2697"> </a>
<a name="ln2698">		i++;</a>
<a name="ln2699">		if (i == XHCI_MAX_EVENTS) {</a>
<a name="ln2700">			i = 0;</a>
<a name="ln2701">			j ^= 1;</a>
<a name="ln2702">			if (!--t)</a>
<a name="ln2703">				break;</a>
<a name="ln2704">		}</a>
<a name="ln2705">	}</a>
<a name="ln2706"> </a>
<a name="ln2707">	fEventIdx = i;</a>
<a name="ln2708">	fEventCcs = j;</a>
<a name="ln2709"> </a>
<a name="ln2710">	uint64 addr = fErst-&gt;rs_addr + i * sizeof(xhci_trb);</a>
<a name="ln2711">	addr |= ERST_EHB;</a>
<a name="ln2712">	WriteRunReg32(XHCI_ERDP_LO(0), (uint32)addr);</a>
<a name="ln2713">	WriteRunReg32(XHCI_ERDP_HI(0), (uint32)(addr &gt;&gt; 32));</a>
<a name="ln2714">}</a>
<a name="ln2715"> </a>
<a name="ln2716"> </a>
<a name="ln2717">int32</a>
<a name="ln2718">XHCI::FinishThread(void* data)</a>
<a name="ln2719">{</a>
<a name="ln2720">	((XHCI *)data)-&gt;FinishTransfers();</a>
<a name="ln2721">	return B_OK;</a>
<a name="ln2722">}</a>
<a name="ln2723"> </a>
<a name="ln2724"> </a>
<a name="ln2725">void</a>
<a name="ln2726">XHCI::FinishTransfers()</a>
<a name="ln2727">{</a>
<a name="ln2728">	while (!fStopThreads) {</a>
<a name="ln2729">		if (acquire_sem(fFinishTransfersSem) &lt; B_OK)</a>
<a name="ln2730">			continue;</a>
<a name="ln2731"> </a>
<a name="ln2732">		// eat up sems that have been released by multiple interrupts</a>
<a name="ln2733">		int32 semCount = 0;</a>
<a name="ln2734">		get_sem_count(fFinishTransfersSem, &amp;semCount);</a>
<a name="ln2735">		if (semCount &gt; 0)</a>
<a name="ln2736">			acquire_sem_etc(fFinishTransfersSem, semCount, B_RELATIVE_TIMEOUT, 0);</a>
<a name="ln2737"> </a>
<a name="ln2738">		mutex_lock(&amp;fFinishedLock);</a>
<a name="ln2739">		TRACE(&quot;finishing transfers\n&quot;);</a>
<a name="ln2740">		while (fFinishedHead != NULL) {</a>
<a name="ln2741">			xhci_td* td = fFinishedHead;</a>
<a name="ln2742">			fFinishedHead = td-&gt;next;</a>
<a name="ln2743">			td-&gt;next = NULL;</a>
<a name="ln2744">			mutex_unlock(&amp;fFinishedLock);</a>
<a name="ln2745"> </a>
<a name="ln2746">			TRACE(&quot;finishing transfer td %p\n&quot;, td);</a>
<a name="ln2747"> </a>
<a name="ln2748">			Transfer* transfer = td-&gt;transfer;</a>
<a name="ln2749">			bool directionIn = (transfer-&gt;TransferPipe()-&gt;Direction() != Pipe::Out);</a>
<a name="ln2750"> </a>
<a name="ln2751">			status_t callbackStatus = B_OK;</a>
<a name="ln2752">			switch (td-&gt;trb_completion_code) {</a>
<a name="ln2753">				case COMP_SHORT_PACKET:</a>
<a name="ln2754">				case COMP_SUCCESS:</a>
<a name="ln2755">					callbackStatus = B_OK;</a>
<a name="ln2756">					break;</a>
<a name="ln2757">				case COMP_DATA_BUFFER:</a>
<a name="ln2758">					callbackStatus = directionIn ? B_DEV_DATA_OVERRUN</a>
<a name="ln2759">						: B_DEV_DATA_UNDERRUN;</a>
<a name="ln2760">					break;</a>
<a name="ln2761">				case COMP_BABBLE:</a>
<a name="ln2762">					callbackStatus = directionIn ? B_DEV_FIFO_OVERRUN</a>
<a name="ln2763">						: B_DEV_FIFO_UNDERRUN;</a>
<a name="ln2764">					break;</a>
<a name="ln2765">				case COMP_USB_TRANSACTION:</a>
<a name="ln2766">					callbackStatus = B_DEV_CRC_ERROR;</a>
<a name="ln2767">					break;</a>
<a name="ln2768">				case COMP_STALL:</a>
<a name="ln2769">					callbackStatus = B_DEV_STALLED;</a>
<a name="ln2770">					break;</a>
<a name="ln2771">				default:</a>
<a name="ln2772">					callbackStatus = B_DEV_STALLED;</a>
<a name="ln2773">					break;</a>
<a name="ln2774">			}</a>
<a name="ln2775"> </a>
<a name="ln2776">			size_t actualLength = transfer-&gt;DataLength();</a>
<a name="ln2777">			if (td-&gt;trb_completion_code != COMP_SUCCESS) {</a>
<a name="ln2778">				actualLength = td-&gt;td_transferred;</a>
<a name="ln2779">				if (td-&gt;td_transferred == -1)</a>
<a name="ln2780">					actualLength = transfer-&gt;DataLength() - td-&gt;trb_left;</a>
<a name="ln2781">				TRACE(&quot;transfer not successful, actualLength=%&quot; B_PRIuSIZE &quot;\n&quot;,</a>
<a name="ln2782">					actualLength);</a>
<a name="ln2783">			}</a>
<a name="ln2784">			if (callbackStatus == B_OK) {</a>
<a name="ln2785">				if (directionIn &amp;&amp; actualLength &gt; 0) {</a>
<a name="ln2786">					TRACE(&quot;copying in iov count %ld\n&quot;, transfer-&gt;VectorCount());</a>
<a name="ln2787">					transfer-&gt;PrepareKernelAccess();</a>
<a name="ln2788">					ReadDescriptor(td, transfer-&gt;Vector(),</a>
<a name="ln2789">						transfer-&gt;VectorCount());</a>
<a name="ln2790">				}</a>
<a name="ln2791">			}</a>
<a name="ln2792">			transfer-&gt;Finished(callbackStatus, actualLength);</a>
<a name="ln2793">			delete transfer;</a>
<a name="ln2794">			FreeDescriptor(td);</a>
<a name="ln2795">			mutex_lock(&amp;fFinishedLock);</a>
<a name="ln2796">		}</a>
<a name="ln2797">		mutex_unlock(&amp;fFinishedLock);</a>
<a name="ln2798">	}</a>
<a name="ln2799">}</a>
<a name="ln2800"> </a>
<a name="ln2801"> </a>
<a name="ln2802">inline void</a>
<a name="ln2803">XHCI::WriteOpReg(uint32 reg, uint32 value)</a>
<a name="ln2804">{</a>
<a name="ln2805">	*(volatile uint32 *)(fRegisters + fOperationalRegisterOffset + reg) = value;</a>
<a name="ln2806">}</a>
<a name="ln2807"> </a>
<a name="ln2808"> </a>
<a name="ln2809">inline uint32</a>
<a name="ln2810">XHCI::ReadOpReg(uint32 reg)</a>
<a name="ln2811">{</a>
<a name="ln2812">	return *(volatile uint32 *)(fRegisters + fOperationalRegisterOffset + reg);</a>
<a name="ln2813">}</a>
<a name="ln2814"> </a>
<a name="ln2815"> </a>
<a name="ln2816">inline status_t</a>
<a name="ln2817">XHCI::WaitOpBits(uint32 reg, uint32 mask, uint32 expected)</a>
<a name="ln2818">{</a>
<a name="ln2819">	int loops = 0;</a>
<a name="ln2820">	uint32 value = ReadOpReg(reg);</a>
<a name="ln2821">	while ((value &amp; mask) != expected) {</a>
<a name="ln2822">		snooze(1000);</a>
<a name="ln2823">		value = ReadOpReg(reg);</a>
<a name="ln2824">		if (loops == 100) {</a>
<a name="ln2825">			TRACE(&quot;delay waiting on reg 0x%&quot; B_PRIX32 &quot; match 0x%&quot; B_PRIX32</a>
<a name="ln2826">				&quot; (0x%&quot; B_PRIX32 &quot;)\n&quot;,	reg, expected, mask);</a>
<a name="ln2827">		} else if (loops &gt; 250) {</a>
<a name="ln2828">			TRACE_ERROR(&quot;timeout waiting on reg 0x%&quot; B_PRIX32</a>
<a name="ln2829">				&quot; match 0x%&quot; B_PRIX32 &quot; (0x%&quot; B_PRIX32 &quot;)\n&quot;, reg, expected,</a>
<a name="ln2830">				mask);</a>
<a name="ln2831">			return B_ERROR;</a>
<a name="ln2832">		}</a>
<a name="ln2833">		loops++;</a>
<a name="ln2834">	}</a>
<a name="ln2835">	return B_OK;</a>
<a name="ln2836">}</a>
<a name="ln2837"> </a>
<a name="ln2838"> </a>
<a name="ln2839">inline uint32</a>
<a name="ln2840">XHCI::ReadCapReg32(uint32 reg)</a>
<a name="ln2841">{</a>
<a name="ln2842">	return *(volatile uint32 *)(fRegisters + fCapabilityRegisterOffset + reg);</a>
<a name="ln2843">}</a>
<a name="ln2844"> </a>
<a name="ln2845"> </a>
<a name="ln2846">inline void</a>
<a name="ln2847">XHCI::WriteCapReg32(uint32 reg, uint32 value)</a>
<a name="ln2848">{</a>
<a name="ln2849">	*(volatile uint32 *)(fRegisters + fCapabilityRegisterOffset + reg) = value;</a>
<a name="ln2850">}</a>
<a name="ln2851"> </a>
<a name="ln2852"> </a>
<a name="ln2853">inline uint32</a>
<a name="ln2854">XHCI::ReadRunReg32(uint32 reg)</a>
<a name="ln2855">{</a>
<a name="ln2856">	return *(volatile uint32 *)(fRegisters + fRuntimeRegisterOffset + reg);</a>
<a name="ln2857">}</a>
<a name="ln2858"> </a>
<a name="ln2859"> </a>
<a name="ln2860">inline void</a>
<a name="ln2861">XHCI::WriteRunReg32(uint32 reg, uint32 value)</a>
<a name="ln2862">{</a>
<a name="ln2863">	*(volatile uint32 *)(fRegisters + fRuntimeRegisterOffset + reg) = value;</a>
<a name="ln2864">}</a>
<a name="ln2865"> </a>
<a name="ln2866"> </a>
<a name="ln2867">inline uint32</a>
<a name="ln2868">XHCI::ReadDoorReg32(uint32 reg)</a>
<a name="ln2869">{</a>
<a name="ln2870">	return *(volatile uint32 *)(fRegisters + fDoorbellRegisterOffset + reg);</a>
<a name="ln2871">}</a>
<a name="ln2872"> </a>
<a name="ln2873"> </a>
<a name="ln2874">inline void</a>
<a name="ln2875">XHCI::WriteDoorReg32(uint32 reg, uint32 value)</a>
<a name="ln2876">{</a>
<a name="ln2877">	*(volatile uint32 *)(fRegisters + fDoorbellRegisterOffset + reg) = value;</a>
<a name="ln2878">}</a>
<a name="ln2879"> </a>
<a name="ln2880"> </a>
<a name="ln2881">inline addr_t</a>
<a name="ln2882">XHCI::_OffsetContextAddr(addr_t p)</a>
<a name="ln2883">{</a>
<a name="ln2884">	if (fContextSizeShift == 1) {</a>
<a name="ln2885">		// each structure is page aligned, each pointer is 32 bits aligned</a>
<a name="ln2886">		uint32 offset = p &amp; ((B_PAGE_SIZE - 1) &amp; ~31U);</a>
<a name="ln2887">		p += offset;</a>
<a name="ln2888">	}</a>
<a name="ln2889">	return p;</a>
<a name="ln2890">}</a>
<a name="ln2891"> </a>
<a name="ln2892">inline uint32</a>
<a name="ln2893">XHCI::_ReadContext(uint32* p)</a>
<a name="ln2894">{</a>
<a name="ln2895">	p = (uint32*)_OffsetContextAddr((addr_t)p);</a>
<a name="ln2896">	return *p;</a>
<a name="ln2897">}</a>
<a name="ln2898"> </a>
<a name="ln2899"> </a>
<a name="ln2900">inline void</a>
<a name="ln2901">XHCI::_WriteContext(uint32* p, uint32 value)</a>
<a name="ln2902">{</a>
<a name="ln2903">	p = (uint32*)_OffsetContextAddr((addr_t)p);</a>
<a name="ln2904">	*p = value;</a>
<a name="ln2905">}</a>
<a name="ln2906"> </a>
<a name="ln2907"> </a>
<a name="ln2908">inline uint64</a>
<a name="ln2909">XHCI::_ReadContext(uint64* p)</a>
<a name="ln2910">{</a>
<a name="ln2911">	p = (uint64*)_OffsetContextAddr((addr_t)p);</a>
<a name="ln2912">	return *p;</a>
<a name="ln2913">}</a>
<a name="ln2914"> </a>
<a name="ln2915"> </a>
<a name="ln2916">inline void</a>
<a name="ln2917">XHCI::_WriteContext(uint64* p, uint64 value)</a>
<a name="ln2918">{</a>
<a name="ln2919">	p = (uint64*)_OffsetContextAddr((addr_t)p);</a>
<a name="ln2920">	*p = value;</a>
<a name="ln2921">}</a>

</code></pre>
<div class="balloon" rel="1657"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'endpoint > 1' is always true.</p></div>
<div class="balloon" rel="1572"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v774/" target="_blank">V774</a> The 'device' pointer was used after the memory was released.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
