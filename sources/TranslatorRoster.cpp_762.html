
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>TranslatorRoster.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2015, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> *		Markus Himmel, markus@himmel-villmar.de</a>
<a name="ln8"> *		Michael Wilber</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11">/*!</a>
<a name="ln12">	This class is the guts of the translation kit, it makes the</a>
<a name="ln13">	whole thing happen. It bridges the applications using this</a>
<a name="ln14">	object with the translators that the apps need to access.</a>
<a name="ln15">*/</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;TranslatorRoster.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;new&gt;</a>
<a name="ln20">#include &lt;strings.h&gt;</a>
<a name="ln21">#include &lt;stdio.h&gt;</a>
<a name="ln22">#include &lt;stdlib.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;Application.h&gt;</a>
<a name="ln25">#include &lt;Autolock.h&gt;</a>
<a name="ln26">#include &lt;Directory.h&gt;</a>
<a name="ln27">#include &lt;FindDirectory.h&gt;</a>
<a name="ln28">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln29">#include &lt;Path.h&gt;</a>
<a name="ln30">#include &lt;String.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;driver_settings.h&gt;</a>
<a name="ln33">#include &lt;image.h&gt;</a>
<a name="ln34">#include &lt;safemode_defs.h&gt;</a>
<a name="ln35">#include &lt;syscalls.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;FuncTranslator.h&quot;</a>
<a name="ln38">#include &quot;TranslatorRosterPrivate.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">namespace BPrivate {</a>
<a name="ln42"> </a>
<a name="ln43">class QuarantineTranslatorImage {</a>
<a name="ln44">public:</a>
<a name="ln45">								QuarantineTranslatorImage(</a>
<a name="ln46">									BTranslatorRoster::Private&amp; privateRoster);</a>
<a name="ln47">								~QuarantineTranslatorImage();</a>
<a name="ln48"> </a>
<a name="ln49">			void				Put(const entry_ref&amp; ref);</a>
<a name="ln50">			void				Remove();</a>
<a name="ln51"> </a>
<a name="ln52">private:</a>
<a name="ln53">			BTranslatorRoster::Private&amp; fRoster;</a>
<a name="ln54">			entry_ref			fRef;</a>
<a name="ln55">			bool				fRemove;</a>
<a name="ln56">};</a>
<a name="ln57"> </a>
<a name="ln58">}	// namespace BPrivate</a>
<a name="ln59"> </a>
<a name="ln60">// Extensions used in the extension BMessage, defined in TranslatorFormats.h</a>
<a name="ln61">char B_TRANSLATOR_EXT_HEADER_ONLY[]			= &quot;/headerOnly&quot;;</a>
<a name="ln62">char B_TRANSLATOR_EXT_DATA_ONLY[]			= &quot;/dataOnly&quot;;</a>
<a name="ln63">char B_TRANSLATOR_EXT_COMMENT[]				= &quot;/comment&quot;;</a>
<a name="ln64">char B_TRANSLATOR_EXT_TIME[]				= &quot;/time&quot;;</a>
<a name="ln65">char B_TRANSLATOR_EXT_FRAME[]				= &quot;/frame&quot;;</a>
<a name="ln66">char B_TRANSLATOR_EXT_BITMAP_RECT[]			= &quot;bits/Rect&quot;;</a>
<a name="ln67">char B_TRANSLATOR_EXT_BITMAP_COLOR_SPACE[]	= &quot;bits/space&quot;;</a>
<a name="ln68">char B_TRANSLATOR_EXT_BITMAP_PALETTE[]		= &quot;bits/palette&quot;;</a>
<a name="ln69">char B_TRANSLATOR_EXT_SOUND_CHANNEL[]		= &quot;nois/channel&quot;;</a>
<a name="ln70">char B_TRANSLATOR_EXT_SOUND_MONO[]			= &quot;nois/mono&quot;;</a>
<a name="ln71">char B_TRANSLATOR_EXT_SOUND_MARKER[]		= &quot;nois/marker&quot;;</a>
<a name="ln72">char B_TRANSLATOR_EXT_SOUND_LOOP[]			= &quot;nois/loop&quot;;</a>
<a name="ln73"> </a>
<a name="ln74">BTranslatorRoster* BTranslatorRoster::sDefaultRoster = NULL;</a>
<a name="ln75"> </a>
<a name="ln76"> </a>
<a name="ln77">namespace BPrivate {</a>
<a name="ln78"> </a>
<a name="ln79">/*!</a>
<a name="ln80">	The purpose of this class is to put a translator entry_ref into - and remove</a>
<a name="ln81">	it from the list of translators on destruction (if Remove() was called</a>
<a name="ln82">	before).</a>
<a name="ln83"> </a>
<a name="ln84">	This is used in Private::CreateTranslators() in case a translator hides a</a>
<a name="ln85">	previous one (ie. if you install a translator in the user's translators</a>
<a name="ln86">	directory that has the same name as one in the system's directory, it will</a>
<a name="ln87">	hide this entry).</a>
<a name="ln88">*/</a>
<a name="ln89">QuarantineTranslatorImage::QuarantineTranslatorImage(</a>
<a name="ln90">	BTranslatorRoster::Private&amp; privateRoster)</a>
<a name="ln91">	:</a>
<a name="ln92">	fRoster(privateRoster),</a>
<a name="ln93">	fRemove(false)</a>
<a name="ln94">{</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">QuarantineTranslatorImage::~QuarantineTranslatorImage()</a>
<a name="ln99">{</a>
<a name="ln100">	if (fRef.device == -1 || !fRemove)</a>
<a name="ln101">		return;</a>
<a name="ln102"> </a>
<a name="ln103">	fRoster.RemoveTranslators(fRef);</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">void</a>
<a name="ln108">QuarantineTranslatorImage::Put(const entry_ref&amp; ref)</a>
<a name="ln109">{</a>
<a name="ln110">	fRef = ref;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113"> </a>
<a name="ln114">void</a>
<a name="ln115">QuarantineTranslatorImage::Remove()</a>
<a name="ln116">{</a>
<a name="ln117">	fRemove = true;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">}	// namespace BPrivate</a>
<a name="ln121"> </a>
<a name="ln122"> </a>
<a name="ln123">//	#pragma mark -</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">BTranslatorRoster::Private::Private()</a>
<a name="ln127">	:</a>
<a name="ln128">	BHandler(&quot;translator roster&quot;),</a>
<a name="ln129">	BLocker(&quot;translator list&quot;),</a>
<a name="ln130">	fABISubDirectory(NULL),</a>
<a name="ln131">	fNextID(1),</a>
<a name="ln132">	fLazyScanning(true),</a>
<a name="ln133">	fSafeMode(false)</a>
<a name="ln134">{</a>
<a name="ln135">	char parameter[32];</a>
<a name="ln136">	size_t parameterLength = sizeof(parameter);</a>
<a name="ln137"> </a>
<a name="ln138">	if (_kern_get_safemode_option(B_SAFEMODE_SAFE_MODE, parameter,</a>
<a name="ln139">			&amp;parameterLength) == B_OK) {</a>
<a name="ln140">		if (!strcasecmp(parameter, &quot;enabled&quot;) || !strcasecmp(parameter, &quot;on&quot;)</a>
<a name="ln141">			|| !strcasecmp(parameter, &quot;true&quot;) || !strcasecmp(parameter, &quot;yes&quot;)</a>
<a name="ln142">			|| !strcasecmp(parameter, &quot;enable&quot;) || !strcmp(parameter, &quot;1&quot;))</a>
<a name="ln143">			fSafeMode = true;</a>
<a name="ln144">	}</a>
<a name="ln145"> </a>
<a name="ln146">	if (_kern_get_safemode_option(B_SAFEMODE_DISABLE_USER_ADD_ONS, parameter,</a>
<a name="ln147">			&amp;parameterLength) == B_OK) {</a>
<a name="ln148">		if (!strcasecmp(parameter, &quot;enabled&quot;) || !strcasecmp(parameter, &quot;on&quot;)</a>
<a name="ln149">			|| !strcasecmp(parameter, &quot;true&quot;) || !strcasecmp(parameter, &quot;yes&quot;)</a>
<a name="ln150">			|| !strcasecmp(parameter, &quot;enable&quot;) || !strcmp(parameter, &quot;1&quot;))</a>
<a name="ln151">			fSafeMode = true;</a>
<a name="ln152">	}</a>
<a name="ln153"> </a>
<a name="ln154">	// We might run in compatibility mode on a system with a different ABI. The</a>
<a name="ln155">	// translators matching our ABI can usually be found in respective</a>
<a name="ln156">	// subdirectories of the translator directories.</a>
<a name="ln157">	system_info info;</a>
<a name="ln158">	if (get_system_info(&amp;info) == B_OK</a>
<a name="ln159">		&amp;&amp; (info.abi &amp; B_HAIKU_ABI_MAJOR)</a>
<a name="ln160">			!= (B_HAIKU_ABI &amp; B_HAIKU_ABI_MAJOR)) {</a>
<a name="ln161">			switch (B_HAIKU_ABI &amp; B_HAIKU_ABI_MAJOR) {</a>
<a name="ln162">				case B_HAIKU_ABI_GCC_2:</a>
<a name="ln163">					fABISubDirectory = &quot;gcc2&quot;;</a>
<a name="ln164">					break;</a>
<a name="ln165">				case B_HAIKU_ABI_GCC_4:</a>
<a name="ln166">					fABISubDirectory = &quot;gcc4&quot;;</a>
<a name="ln167">					break;</a>
<a name="ln168">			}</a>
<a name="ln169">	}</a>
<a name="ln170"> </a>
<a name="ln171">	// we're sneaking us into the BApplication</a>
<a name="ln172">	if (be_app != NULL &amp;&amp; be_app-&gt;Lock()) {</a>
<a name="ln173">		be_app-&gt;AddHandler(this);</a>
<a name="ln174">		be_app-&gt;Unlock();</a>
<a name="ln175">	}</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">BTranslatorRoster::Private::~Private()</a>
<a name="ln180">{</a>
<a name="ln181">	stop_watching(this);</a>
<a name="ln182"> </a>
<a name="ln183">	if (Looper() &amp;&amp; LockLooper()) {</a>
<a name="ln184">		BLooper* looper = Looper();</a>
<a name="ln185">		Looper()-&gt;RemoveHandler(this);</a>
<a name="ln186">		looper-&gt;Unlock();</a>
<a name="ln187">	}</a>
<a name="ln188"> </a>
<a name="ln189">	// Release all translators, so that they can delete themselves</a>
<a name="ln190"> </a>
<a name="ln191">	TranslatorMap::iterator iterator = fTranslators.begin();</a>
<a name="ln192">	std::set&lt;image_id&gt; images;</a>
<a name="ln193"> </a>
<a name="ln194">	while (iterator != fTranslators.end()) {</a>
<a name="ln195">		BTranslator* translator = iterator-&gt;second.translator;</a>
<a name="ln196"> </a>
<a name="ln197">		images.insert(iterator-&gt;second.image);</a>
<a name="ln198">		translator-&gt;Release();</a>
<a name="ln199"> </a>
<a name="ln200">		iterator++;</a>
<a name="ln201">	}</a>
<a name="ln202"> </a>
<a name="ln203">	// Unload all images</a>
<a name="ln204"> </a>
<a name="ln205">	std::set&lt;image_id&gt;::const_iterator imageIterator = images.begin();</a>
<a name="ln206"> </a>
<a name="ln207">	while (imageIterator != images.end()) {</a>
<a name="ln208">		unload_add_on(*imageIterator);</a>
<a name="ln209">		imageIterator++;</a>
<a name="ln210">	}</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">void</a>
<a name="ln215">BTranslatorRoster::Private::MessageReceived(BMessage* message)</a>
<a name="ln216">{</a>
<a name="ln217">	switch (message-&gt;what) {</a>
<a name="ln218">		case B_NODE_MONITOR:</a>
<a name="ln219">		{</a>
<a name="ln220">			BAutolock locker(this);</a>
<a name="ln221"> </a>
<a name="ln222">			printf(&quot;translator roster node monitor: &quot;);</a>
<a name="ln223">			message-&gt;PrintToStream();</a>
<a name="ln224"> </a>
<a name="ln225">			int32 opcode;</a>
<a name="ln226">			if (message-&gt;FindInt32(&quot;opcode&quot;, &amp;opcode) != B_OK)</a>
<a name="ln227">				return;</a>
<a name="ln228"> </a>
<a name="ln229">			switch (opcode) {</a>
<a name="ln230">				case B_ENTRY_CREATED:</a>
<a name="ln231">				{</a>
<a name="ln232">					const char* name;</a>
<a name="ln233">					node_ref nodeRef;</a>
<a name="ln234">					if (message-&gt;FindInt32(&quot;device&quot;, &amp;nodeRef.device) != B_OK</a>
<a name="ln235">						|| message-&gt;FindInt64(&quot;directory&quot;, &amp;nodeRef.node)</a>
<a name="ln236">							!= B_OK</a>
<a name="ln237">						|| message-&gt;FindString(&quot;name&quot;, &amp;name) != B_OK)</a>
<a name="ln238">						break;</a>
<a name="ln239"> </a>
<a name="ln240">					// TODO: make this better (possible under Haiku)</a>
<a name="ln241">					snooze(100000);</a>
<a name="ln242">						// let the font be written completely before trying to</a>
<a name="ln243">						// open it</a>
<a name="ln244"> </a>
<a name="ln245">					_EntryAdded(nodeRef, name);</a>
<a name="ln246">					break;</a>
<a name="ln247">				}</a>
<a name="ln248"> </a>
<a name="ln249">				case B_ENTRY_MOVED:</a>
<a name="ln250">				{</a>
<a name="ln251">					// has the entry been moved into a monitored directory or</a>
<a name="ln252">					// has it been removed from one?</a>
<a name="ln253">					const char* name;</a>
<a name="ln254">					node_ref toNodeRef;</a>
<a name="ln255">					node_ref fromNodeRef;</a>
<a name="ln256">					node_ref nodeRef;</a>
<a name="ln257"> </a>
<a name="ln258">					if (message-&gt;FindInt32(&quot;device&quot;, &amp;nodeRef.device) != B_OK</a>
<a name="ln259">						|| message-&gt;FindInt64(&quot;to directory&quot;, &amp;toNodeRef.node)</a>
<a name="ln260">							!= B_OK</a>
<a name="ln261">						|| message-&gt;FindInt64(&quot;from directory&quot;,</a>
<a name="ln262">							(int64*)&amp;fromNodeRef.node) != B_OK</a>
<a name="ln263">						|| message-&gt;FindInt64(&quot;node&quot;, (int64*)&amp;nodeRef.node)</a>
<a name="ln264">							!= B_OK</a>
<a name="ln265">						|| message-&gt;FindString(&quot;name&quot;, &amp;name) != B_OK)</a>
<a name="ln266">						break;</a>
<a name="ln267"> </a>
<a name="ln268">					fromNodeRef.device = nodeRef.device;</a>
<a name="ln269">					toNodeRef.device = nodeRef.device;</a>
<a name="ln270"> </a>
<a name="ln271">					// Do we know this one yet?</a>
<a name="ln272">					translator_item* item = _FindTranslator(nodeRef);</a>
<a name="ln273">					if (item == NULL) {</a>
<a name="ln274">						// it's a new one!</a>
<a name="ln275">						if (_IsKnownDirectory(toNodeRef))</a>
<a name="ln276">							_EntryAdded(toNodeRef, name);</a>
<a name="ln277">						break;</a>
<a name="ln278">					}</a>
<a name="ln279"> </a>
<a name="ln280">					if (!_IsKnownDirectory(toNodeRef)) {</a>
<a name="ln281">						// translator got removed</a>
<a name="ln282">						_RemoveTranslators(&amp;nodeRef);</a>
<a name="ln283">						break;</a>
<a name="ln284">					}</a>
<a name="ln285"> </a>
<a name="ln286">					// the name may have changed</a>
<a name="ln287">					item-&gt;ref.set_name(name);</a>
<a name="ln288">					item-&gt;ref.directory = toNodeRef.node;</a>
<a name="ln289"> </a>
<a name="ln290">					if (_IsKnownDirectory(fromNodeRef)</a>
<a name="ln291">						&amp;&amp; _IsKnownDirectory(toNodeRef)) {</a>
<a name="ln292">						// TODO: we should rescan for the name, there might be</a>
<a name="ln293">						// name clashes with translators in other directories</a>
<a name="ln294">						// (as well as old ones revealed)</a>
<a name="ln295">						break;</a>
<a name="ln296">					}</a>
<a name="ln297">					break;</a>
<a name="ln298">				}</a>
<a name="ln299"> </a>
<a name="ln300">				case B_ENTRY_REMOVED:</a>
<a name="ln301">				{</a>
<a name="ln302">					node_ref nodeRef;</a>
<a name="ln303">					uint64 directoryNode;</a>
<a name="ln304">					if (message-&gt;FindInt32(&quot;device&quot;, &amp;nodeRef.device) != B_OK</a>
<a name="ln305">						|| message-&gt;FindInt64(&quot;directory&quot;,</a>
<a name="ln306">							(int64*)&amp;directoryNode) != B_OK</a>
<a name="ln307">						|| message-&gt;FindInt64(&quot;node&quot;, &amp;nodeRef.node) != B_OK)</a>
<a name="ln308">						break;</a>
<a name="ln309"> </a>
<a name="ln310">					translator_item* item = _FindTranslator(nodeRef);</a>
<a name="ln311">					if (item != NULL)</a>
<a name="ln312">						_RemoveTranslators(&amp;nodeRef);</a>
<a name="ln313">					break;</a>
<a name="ln314">				}</a>
<a name="ln315">			}</a>
<a name="ln316">			break;</a>
<a name="ln317">		}</a>
<a name="ln318"> </a>
<a name="ln319">		case B_DELETE_TRANSLATOR:</a>
<a name="ln320">		{</a>
<a name="ln321">			// A translator's refcount has been reduced to zero and it wants</a>
<a name="ln322">			// us to delete it.</a>
<a name="ln323">			int32 id;</a>
<a name="ln324">			void* self;</a>
<a name="ln325">			if (message-&gt;FindInt32(&quot;id&quot;, &amp;id) == B_OK</a>
<a name="ln326">				&amp;&amp; message-&gt;FindPointer(&quot;ptr&quot;, &amp;self) == B_OK) {</a>
<a name="ln327">				_TranslatorDeleted(id, (BTranslator*)self);</a>
<a name="ln328">			}</a>
<a name="ln329">			break;</a>
<a name="ln330">		}</a>
<a name="ln331"> </a>
<a name="ln332">		default:</a>
<a name="ln333">			BHandler::MessageReceived(message);</a>
<a name="ln334">			break;</a>
<a name="ln335">	}</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338"> </a>
<a name="ln339">void</a>
<a name="ln340">BTranslatorRoster::Private::AddDefaultPaths()</a>
<a name="ln341">{</a>
<a name="ln342">	// add user directories first, so that they can override system translators</a>
<a name="ln343">	const directory_which paths[] = {</a>
<a name="ln344">		B_USER_NONPACKAGED_ADDONS_DIRECTORY,</a>
<a name="ln345">		B_USER_ADDONS_DIRECTORY,</a>
<a name="ln346">		B_SYSTEM_NONPACKAGED_ADDONS_DIRECTORY,</a>
<a name="ln347">		B_SYSTEM_ADDONS_DIRECTORY,</a>
<a name="ln348">	};</a>
<a name="ln349"> </a>
<a name="ln350">	for (uint32 i = fSafeMode ? 4 : 0; i &lt; sizeof(paths) / sizeof(paths[0]);</a>
<a name="ln351">			i++) {</a>
<a name="ln352">		BPath path;</a>
<a name="ln353">		status_t status = find_directory(paths[i], &amp;path, true);</a>
<a name="ln354">		if (status == B_OK &amp;&amp; path.Append(&quot;Translators&quot;) == B_OK) {</a>
<a name="ln355">			mkdir(path.Path(), 0755);</a>
<a name="ln356">				// make sure the directory exists before we add it</a>
<a name="ln357">			AddPath(path.Path());</a>
<a name="ln358">		}</a>
<a name="ln359">	}</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">/*!</a>
<a name="ln364">	Adds the colon separated list of directories to the roster.</a>
<a name="ln365"> </a>
<a name="ln366">	Note, the order in which these directories are added to actually matters,</a>
<a name="ln367">	translators with the same name will be taken from the earlier directory</a>
<a name="ln368">	first. See _CompareTranslatorDirectoryPriority().</a>
<a name="ln369">*/</a>
<a name="ln370">status_t</a>
<a name="ln371">BTranslatorRoster::Private::AddPaths(const char* paths)</a>
<a name="ln372">{</a>
<a name="ln373">	if (paths == NULL)</a>
<a name="ln374">		return B_BAD_VALUE;</a>
<a name="ln375"> </a>
<a name="ln376">	status_t status = B_OK;</a>
<a name="ln377">	int32 added = 0;</a>
<a name="ln378"> </a>
<a name="ln379">	while (paths != NULL) {</a>
<a name="ln380">		const char* end = strchr(paths, ':');</a>
<a name="ln381">		BString path;</a>
<a name="ln382"> </a>
<a name="ln383">		if (end != NULL) {</a>
<a name="ln384">			path.SetTo(paths, end - 1 - paths);</a>
<a name="ln385">			paths = end + 1;</a>
<a name="ln386">		} else {</a>
<a name="ln387">			path.SetTo(paths);</a>
<a name="ln388">			paths = NULL;</a>
<a name="ln389">		}</a>
<a name="ln390"> </a>
<a name="ln391">		// Keep the last error that occured, and return it</a>
<a name="ln392">		// but don't overwrite it, if the last path was</a>
<a name="ln393">		// added successfully.</a>
<a name="ln394">		int32 count;</a>
<a name="ln395">		status_t error = AddPath(path.String(), &amp;count);</a>
<a name="ln396">		if (error != B_NO_ERROR)</a>
<a name="ln397">			status = error;</a>
<a name="ln398"> </a>
<a name="ln399">		added += count;</a>
<a name="ln400">	}</a>
<a name="ln401"> </a>
<a name="ln402">	if (added == 0)</a>
<a name="ln403">		return status;</a>
<a name="ln404"> </a>
<a name="ln405">	return B_OK;</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408"> </a>
<a name="ln409">/*!</a>
<a name="ln410">	Adds a new directory to the roster.</a>
<a name="ln411"> </a>
<a name="ln412">	Note, the order in which these directories are added to actually matters,</a>
<a name="ln413">	see AddPaths().</a>
<a name="ln414">*/</a>
<a name="ln415">status_t</a>
<a name="ln416">BTranslatorRoster::Private::AddPath(const char* path, int32* _added)</a>
<a name="ln417">{</a>
<a name="ln418">	BDirectory directory(path);</a>
<a name="ln419">	status_t status = directory.InitCheck();</a>
<a name="ln420">	if (status != B_OK)</a>
<a name="ln421">		return status;</a>
<a name="ln422"> </a>
<a name="ln423">	// if a subdirectory for our ABI exists, use that instead</a>
<a name="ln424">	if (fABISubDirectory != NULL) {</a>
<a name="ln425">		BEntry entry(&amp;directory, fABISubDirectory);</a>
<a name="ln426">		if (entry.IsDirectory()) {</a>
<a name="ln427">			status = directory.SetTo(&amp;entry);</a>
<a name="ln428">			if (status != B_OK)</a>
<a name="ln429">				return status;</a>
<a name="ln430">		}</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433">	node_ref nodeRef;</a>
<a name="ln434">	status = directory.GetNodeRef(&amp;nodeRef);</a>
<a name="ln435">	if (status &lt; B_OK)</a>
<a name="ln436">		return status;</a>
<a name="ln437"> </a>
<a name="ln438">	// do we know this directory already?</a>
<a name="ln439">	if (_IsKnownDirectory(nodeRef))</a>
<a name="ln440">		return B_OK;</a>
<a name="ln441"> </a>
<a name="ln442">	if (Looper() != NULL) {</a>
<a name="ln443">		// watch that directory</a>
<a name="ln444">		watch_node(&amp;nodeRef, B_WATCH_DIRECTORY, this);</a>
<a name="ln445">		fDirectories.push_back(nodeRef);</a>
<a name="ln446">	}</a>
<a name="ln447"> </a>
<a name="ln448">	int32 count = 0;</a>
<a name="ln449">	int32 files = 0;</a>
<a name="ln450"> </a>
<a name="ln451">	entry_ref ref;</a>
<a name="ln452">	while (directory.GetNextRef(&amp;ref) == B_OK) {</a>
<a name="ln453">		BEntry entry(&amp;ref);</a>
<a name="ln454">		if (entry.IsDirectory())</a>
<a name="ln455">			continue;</a>
<a name="ln456">		if (CreateTranslators(ref, count) == B_OK)</a>
<a name="ln457">			count++;</a>
<a name="ln458"> </a>
<a name="ln459">		files++;</a>
<a name="ln460">	}</a>
<a name="ln461"> </a>
<a name="ln462">	if (_added)</a>
<a name="ln463">		*_added = count;</a>
<a name="ln464"> </a>
<a name="ln465">	if (files != 0 &amp;&amp; count == 0)</a>
<a name="ln466">		return B_BAD_VALUE;</a>
<a name="ln467"> </a>
<a name="ln468">	return B_OK;</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">status_t</a>
<a name="ln473">BTranslatorRoster::Private::AddTranslator(BTranslator* translator,</a>
<a name="ln474">	image_id image, const entry_ref* ref, ino_t node)</a>
<a name="ln475">{</a>
<a name="ln476">	BAutolock locker(this);</a>
<a name="ln477"> </a>
<a name="ln478">	translator_item item;</a>
<a name="ln479">	item.translator = translator;</a>
<a name="ln480">	item.image = image;</a>
<a name="ln481">	item.node = node;</a>
<a name="ln482">	if (ref != NULL)</a>
<a name="ln483">		item.ref = *ref;</a>
<a name="ln484"> </a>
<a name="ln485">	try {</a>
<a name="ln486">		fTranslators[fNextID] = item;</a>
<a name="ln487">	} catch (...) {</a>
<a name="ln488">		return B_NO_MEMORY;</a>
<a name="ln489">	}</a>
<a name="ln490"> </a>
<a name="ln491">	translator-&gt;fOwningRoster = this;</a>
<a name="ln492">	translator-&gt;fID = fNextID++;</a>
<a name="ln493">	return B_OK;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496"> </a>
<a name="ln497">void</a>
<a name="ln498">BTranslatorRoster::Private::RemoveTranslators(entry_ref&amp; ref)</a>
<a name="ln499">{</a>
<a name="ln500">	_RemoveTranslators(NULL, &amp;ref);</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503"> </a>
<a name="ln504">BTranslator*</a>
<a name="ln505">BTranslatorRoster::Private::FindTranslator(translator_id id)</a>
<a name="ln506">{</a>
<a name="ln507">	if (!IsLocked()) {</a>
<a name="ln508">		debugger(&quot;translator must be locked!&quot;);</a>
<a name="ln509">		return NULL;</a>
<a name="ln510">	}</a>
<a name="ln511"> </a>
<a name="ln512">	const translator_item* item = _FindTranslator(id);</a>
<a name="ln513">	if (item != NULL)</a>
<a name="ln514">		return item-&gt;translator;</a>
<a name="ln515"> </a>
<a name="ln516">	return NULL;</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">status_t</a>
<a name="ln521">BTranslatorRoster::Private::GetTranslatorData(image_id image,</a>
<a name="ln522">	translator_data&amp; data)</a>
<a name="ln523">{</a>
<a name="ln524">	// If this is a translator add-on, it is in the C format</a>
<a name="ln525">	memset(&amp;data, 0, sizeof(translator_data));</a>
<a name="ln526"> </a>
<a name="ln527">	// find all the symbols</a>
<a name="ln528"> </a>
<a name="ln529">	int32* version;</a>
<a name="ln530">	if (get_image_symbol(image, &quot;translatorName&quot;, B_SYMBOL_TYPE_DATA,</a>
<a name="ln531">			(void**)&amp;data.name) &lt; B_OK</a>
<a name="ln532">		|| get_image_symbol(image, &quot;translatorInfo&quot;, B_SYMBOL_TYPE_DATA,</a>
<a name="ln533">			(void**)&amp;data.info) &lt; B_OK</a>
<a name="ln534">		|| get_image_symbol(image, &quot;translatorVersion&quot;, B_SYMBOL_TYPE_DATA,</a>
<a name="ln535">			(void**)&amp;version) &lt; B_OK || version == NULL</a>
<a name="ln536">		|| get_image_symbol(image, &quot;inputFormats&quot;, B_SYMBOL_TYPE_DATA,</a>
<a name="ln537">			(void**)&amp;data.input_formats) &lt; B_OK</a>
<a name="ln538">		|| get_image_symbol(image, &quot;outputFormats&quot;, B_SYMBOL_TYPE_DATA,</a>
<a name="ln539">			(void**)&amp;data.output_formats) &lt; B_OK</a>
<a name="ln540">		|| get_image_symbol(image, &quot;Identify&quot;, B_SYMBOL_TYPE_TEXT,</a>
<a name="ln541">			(void**)&amp;data.identify_hook) &lt; B_OK</a>
<a name="ln542">		|| get_image_symbol(image, &quot;Translate&quot;, B_SYMBOL_TYPE_TEXT,</a>
<a name="ln543">			(void**)&amp;data.translate_hook) &lt; B_OK) {</a>
<a name="ln544">		return B_BAD_TYPE;</a>
<a name="ln545">	}</a>
<a name="ln546"> </a>
<a name="ln547">	data.version = *version;</a>
<a name="ln548"> </a>
<a name="ln549">	// those calls are optional</a>
<a name="ln550">	get_image_symbol(image, &quot;MakeConfig&quot;, B_SYMBOL_TYPE_TEXT,</a>
<a name="ln551">		(void**)&amp;data.make_config_hook);</a>
<a name="ln552">	get_image_symbol(image, &quot;GetConfigMessage&quot;, B_SYMBOL_TYPE_TEXT,</a>
<a name="ln553">		(void**)&amp;data.get_config_message_hook);</a>
<a name="ln554"> </a>
<a name="ln555">	return B_OK;</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558"> </a>
<a name="ln559">status_t</a>
<a name="ln560">BTranslatorRoster::Private::CreateTranslators(const entry_ref&amp; ref,</a>
<a name="ln561">	int32&amp; count, BMessage* update)</a>
<a name="ln562">{</a>
<a name="ln563">	BAutolock locker(this);</a>
<a name="ln564"> </a>
<a name="ln565">	BPrivate::QuarantineTranslatorImage quarantine(*this);</a>
<a name="ln566"> </a>
<a name="ln567">	const translator_item* item = _FindTranslator(ref.name);</a>
<a name="ln568">	if (item != NULL) {</a>
<a name="ln569">		// check if the known translator has a higher priority</a>
<a name="ln570">		if (_CompareTranslatorDirectoryPriority(item-&gt;ref, ref) &lt;= 0) {</a>
<a name="ln571">			// keep the existing add-on</a>
<a name="ln572">			return B_OK;</a>
<a name="ln573">		}</a>
<a name="ln574"> </a>
<a name="ln575">		// replace existing translator(s) if the new translator succeeds</a>
<a name="ln576">		quarantine.Put(item-&gt;ref);</a>
<a name="ln577">	}</a>
<a name="ln578"> </a>
<a name="ln579">	BEntry entry(&amp;ref);</a>
<a name="ln580">	node_ref nodeRef;</a>
<a name="ln581">	status_t status = entry.GetNodeRef(&amp;nodeRef);</a>
<a name="ln582">	if (status &lt; B_OK)</a>
<a name="ln583">		return status;</a>
<a name="ln584"> </a>
<a name="ln585">	BPath path(&amp;ref);</a>
<a name="ln586">	image_id image = load_add_on(path.Path());</a>
<a name="ln587">	if (image &lt; B_OK)</a>
<a name="ln588">		return image;</a>
<a name="ln589"> </a>
<a name="ln590">	// Function pointer used to create post R4.5 style translators</a>
<a name="ln591">	BTranslator *(*makeNthTranslator)(int32 n, image_id you, uint32 flags, ...);</a>
<a name="ln592"> </a>
<a name="ln593">	status = get_image_symbol(image, &quot;make_nth_translator&quot;,</a>
<a name="ln594">		B_SYMBOL_TYPE_TEXT, (void**)&amp;makeNthTranslator);</a>
<a name="ln595">	if (status == B_OK) {</a>
<a name="ln596">		// If the translator add-on supports the post R4.5</a>
<a name="ln597">		// translator creation mechanism, keep loading translators</a>
<a name="ln598">		// until MakeNthTranslator stops returning them.</a>
<a name="ln599">		BTranslator* translator = NULL;</a>
<a name="ln600">		int32 created = 0;</a>
<a name="ln601">		for (int32 n = 0; (translator = makeNthTranslator(n, image, 0)) != NULL;</a>
<a name="ln602">				n++) {</a>
<a name="ln603">			if (AddTranslator(translator, image, &amp;ref, nodeRef.node) == B_OK) {</a>
<a name="ln604">				if (update)</a>
<a name="ln605">					update-&gt;AddInt32(&quot;translator_id&quot;, translator-&gt;fID);</a>
<a name="ln606">				fImageOrigins.insert(std::make_pair(translator, image));</a>
<a name="ln607">				count++;</a>
<a name="ln608">				created++;</a>
<a name="ln609">			} else {</a>
<a name="ln610">				translator-&gt;Release();</a>
<a name="ln611">					// this will delete the translator</a>
<a name="ln612">			}</a>
<a name="ln613">		}</a>
<a name="ln614"> </a>
<a name="ln615">		if (created == 0) {</a>
<a name="ln616">			unload_add_on(image);</a>
<a name="ln617">		} else {</a>
<a name="ln618">			// Initial refcount for the image that was just loaded</a>
<a name="ln619">			fKnownImages.insert(std::make_pair(image, created));</a>
<a name="ln620">		}</a>
<a name="ln621"> </a>
<a name="ln622">		quarantine.Remove();</a>
<a name="ln623">		return B_OK;</a>
<a name="ln624">	}</a>
<a name="ln625"> </a>
<a name="ln626">	// If this is a translator add-on, it is in the C format</a>
<a name="ln627">	translator_data translatorData;</a>
<a name="ln628">	status = GetTranslatorData(image, translatorData);</a>
<a name="ln629"> </a>
<a name="ln630">	// add this translator to the list</a>
<a name="ln631">	BPrivate::BFuncTranslator* translator = NULL;</a>
<a name="ln632">	if (status == B_OK) {</a>
<a name="ln633">		translator = new (std::nothrow) BPrivate::BFuncTranslator(</a>
<a name="ln634">			translatorData);</a>
<a name="ln635">		if (translator == NULL)</a>
<a name="ln636">			status = B_NO_MEMORY;</a>
<a name="ln637">	}</a>
<a name="ln638"> </a>
<a name="ln639">	if (status == B_OK)</a>
<a name="ln640">		status = AddTranslator(translator, image, &amp;ref, nodeRef.node);</a>
<a name="ln641"> </a>
<a name="ln642">	if (status == B_OK) {</a>
<a name="ln643">		if (update)</a>
<a name="ln644">			update-&gt;AddInt32(&quot;translator_id&quot;, translator-&gt;fID);</a>
<a name="ln645">		quarantine.Remove();</a>
<a name="ln646">		count++;</a>
<a name="ln647">	} else</a>
<a name="ln648">		unload_add_on(image);</a>
<a name="ln649"> </a>
<a name="ln650">	return status;</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">status_t</a>
<a name="ln655">BTranslatorRoster::Private::StartWatching(BMessenger target)</a>
<a name="ln656">{</a>
<a name="ln657">	try {</a>
<a name="ln658">		fMessengers.push_back(target);</a>
<a name="ln659">	} catch (...) {</a>
<a name="ln660">		return B_NO_MEMORY;</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	if (fLazyScanning) {</a>
<a name="ln664">		fLazyScanning = false;</a>
<a name="ln665">			// Since we now have someone to report to, we cannot lazily</a>
<a name="ln666">			// adopt changes to the translator any longer</a>
<a name="ln667"> </a>
<a name="ln668">		_RescanChanged();</a>
<a name="ln669">	}</a>
<a name="ln670"> </a>
<a name="ln671">	return B_OK;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">status_t</a>
<a name="ln676">BTranslatorRoster::Private::StopWatching(BMessenger target)</a>
<a name="ln677">{</a>
<a name="ln678">	MessengerList::iterator iterator = fMessengers.begin();</a>
<a name="ln679"> </a>
<a name="ln680">	while (iterator != fMessengers.end()) {</a>
<a name="ln681">		if (*iterator == target) {</a>
<a name="ln682">			fMessengers.erase(iterator);</a>
<a name="ln683">			if (fMessengers.empty())</a>
<a name="ln684">				fLazyScanning = true;</a>
<a name="ln685"> </a>
<a name="ln686">			return B_OK;</a>
<a name="ln687">		}</a>
<a name="ln688"> </a>
<a name="ln689">		iterator++;</a>
<a name="ln690">	}</a>
<a name="ln691"> </a>
<a name="ln692">	return B_BAD_VALUE;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">status_t</a>
<a name="ln697">BTranslatorRoster::Private::StoreTranslators(BMessage&amp; archive)</a>
<a name="ln698">{</a>
<a name="ln699">	BAutolock locker(this);</a>
<a name="ln700"> </a>
<a name="ln701">	TranslatorMap::const_iterator iterator = fTranslators.begin();</a>
<a name="ln702"> </a>
<a name="ln703">	while (iterator != fTranslators.end()) {</a>
<a name="ln704">		const translator_item&amp; item = iterator-&gt;second;</a>
<a name="ln705">		BPath path(&amp;item.ref);</a>
<a name="ln706">		if (path.InitCheck() == B_OK)</a>
<a name="ln707">			archive.AddString(&quot;be:translator_path&quot;, path.Path());</a>
<a name="ln708"> </a>
<a name="ln709">		iterator++;</a>
<a name="ln710">	}</a>
<a name="ln711"> </a>
<a name="ln712">	return B_OK;</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715"> </a>
<a name="ln716">status_t</a>
<a name="ln717">BTranslatorRoster::Private::Identify(BPositionIO* source,</a>
<a name="ln718">	BMessage* ioExtension, uint32 hintType, const char* hintMIME,</a>
<a name="ln719">	uint32 wantType, translator_info* _info)</a>
<a name="ln720">{</a>
<a name="ln721">	BAutolock locker(this);</a>
<a name="ln722"> </a>
<a name="ln723">	_RescanChanged();</a>
<a name="ln724"> </a>
<a name="ln725">	TranslatorMap::const_iterator iterator = fTranslators.begin();</a>
<a name="ln726">	BMessage baseExtension;</a>
<a name="ln727">	if (ioExtension != NULL)</a>
<a name="ln728">		baseExtension = *ioExtension;</a>
<a name="ln729"> </a>
<a name="ln730">	float bestWeight = 0.0f;</a>
<a name="ln731"> </a>
<a name="ln732">	while (iterator != fTranslators.end()) {</a>
<a name="ln733">		BTranslator&amp; translator = *iterator-&gt;second.translator;</a>
<a name="ln734"> </a>
<a name="ln735">		off_t pos = source-&gt;Seek(0, SEEK_SET);</a>
<a name="ln736">		if (pos != 0)</a>
<a name="ln737">			return pos &lt; 0 ? (status_t)pos : B_IO_ERROR;</a>
<a name="ln738"> </a>
<a name="ln739">		int32 formatsCount = 0;</a>
<a name="ln740">		const translation_format* formats = translator.InputFormats(</a>
<a name="ln741">			&amp;formatsCount);</a>
<a name="ln742">		const translation_format* format = _CheckHints(formats, formatsCount,</a>
<a name="ln743">			hintType, hintMIME);</a>
<a name="ln744"> </a>
<a name="ln745">		BMessage extension(baseExtension);</a>
<a name="ln746">		translator_info info;</a>
<a name="ln747">		if (translator.Identify(source, format, &amp;extension, &amp;info, wantType)</a>
<a name="ln748">				== B_OK) {</a>
<a name="ln749">			float weight = info.quality * info.capability;</a>
<a name="ln750">			if (weight &gt; bestWeight) {</a>
<a name="ln751">				if (ioExtension != NULL)</a>
<a name="ln752">					*ioExtension = extension;</a>
<a name="ln753">				bestWeight = weight;</a>
<a name="ln754"> </a>
<a name="ln755">				info.translator = iterator-&gt;first;</a>
<a name="ln756">				memcpy(_info, &amp;info, sizeof(translator_info));</a>
<a name="ln757">			}</a>
<a name="ln758">		}</a>
<a name="ln759"> </a>
<a name="ln760">		iterator++;</a>
<a name="ln761">	}</a>
<a name="ln762"> </a>
<a name="ln763">	if (bestWeight &gt; 0.0f)</a>
<a name="ln764">		return B_OK;</a>
<a name="ln765"> </a>
<a name="ln766">	return B_NO_TRANSLATOR;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">status_t</a>
<a name="ln771">BTranslatorRoster::Private::GetTranslators(BPositionIO* source,</a>
<a name="ln772">	BMessage* ioExtension, uint32 hintType, const char* hintMIME,</a>
<a name="ln773">	uint32 wantType, translator_info** _info, int32* _numInfo)</a>
<a name="ln774">{</a>
<a name="ln775">	BAutolock locker(this);</a>
<a name="ln776"> </a>
<a name="ln777">	_RescanChanged();</a>
<a name="ln778"> </a>
<a name="ln779">	int32 arraySize = fTranslators.size();</a>
<a name="ln780">	translator_info* array = new (std::nothrow) translator_info[arraySize];</a>
<a name="ln781">	if (array == NULL)</a>
<a name="ln782">		return B_NO_MEMORY;</a>
<a name="ln783"> </a>
<a name="ln784">	TranslatorMap::const_iterator iterator = fTranslators.begin();</a>
<a name="ln785">	int32 count = 0;</a>
<a name="ln786"> </a>
<a name="ln787">	while (iterator != fTranslators.end()) {</a>
<a name="ln788">		BTranslator&amp; translator = *iterator-&gt;second.translator;</a>
<a name="ln789"> </a>
<a name="ln790">		off_t pos = source-&gt;Seek(0, SEEK_SET);</a>
<a name="ln791">		if (pos != 0) {</a>
<a name="ln792">			delete[] array;</a>
<a name="ln793">			return pos &lt; 0 ? status_t(pos) : B_IO_ERROR;</a>
<a name="ln794">		}</a>
<a name="ln795"> </a>
<a name="ln796">		int32 formatsCount = 0;</a>
<a name="ln797">		const translation_format* formats = translator.InputFormats(</a>
<a name="ln798">			&amp;formatsCount);</a>
<a name="ln799">		const translation_format* format = _CheckHints(formats, formatsCount,</a>
<a name="ln800">			hintType, hintMIME);</a>
<a name="ln801"> </a>
<a name="ln802">		translator_info info;</a>
<a name="ln803">		if (translator.Identify(source, format, ioExtension, &amp;info, wantType)</a>
<a name="ln804">				== B_OK) {</a>
<a name="ln805">			info.translator = iterator-&gt;first;</a>
<a name="ln806">			array[count++] = info;</a>
<a name="ln807">		}</a>
<a name="ln808"> </a>
<a name="ln809">		iterator++;</a>
<a name="ln810">	}</a>
<a name="ln811"> </a>
<a name="ln812">	*_info = array;</a>
<a name="ln813">	*_numInfo = count;</a>
<a name="ln814">	qsort(array, count, sizeof(translator_info),</a>
<a name="ln815">		BTranslatorRoster::Private::_CompareSupport);</a>
<a name="ln816">		// translators are sorted by best support</a>
<a name="ln817"> </a>
<a name="ln818">	return B_OK;</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821"> </a>
<a name="ln822">status_t</a>
<a name="ln823">BTranslatorRoster::Private::GetAllTranslators(translator_id** _ids,</a>
<a name="ln824">	int32* _count)</a>
<a name="ln825">{</a>
<a name="ln826">	BAutolock locker(this);</a>
<a name="ln827"> </a>
<a name="ln828">	_RescanChanged();</a>
<a name="ln829"> </a>
<a name="ln830">	int32 arraySize = fTranslators.size();</a>
<a name="ln831">	translator_id* array = new (std::nothrow) translator_id[arraySize];</a>
<a name="ln832">	if (array == NULL)</a>
<a name="ln833">		return B_NO_MEMORY;</a>
<a name="ln834"> </a>
<a name="ln835">	TranslatorMap::const_iterator iterator = fTranslators.begin();</a>
<a name="ln836">	int32 count = 0;</a>
<a name="ln837"> </a>
<a name="ln838">	while (iterator != fTranslators.end()) {</a>
<a name="ln839">		array[count++] = iterator-&gt;first;</a>
<a name="ln840">		iterator++;</a>
<a name="ln841">	}</a>
<a name="ln842"> </a>
<a name="ln843">	*_ids = array;</a>
<a name="ln844">	*_count = count;</a>
<a name="ln845">	return B_OK;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848"> </a>
<a name="ln849">status_t</a>
<a name="ln850">BTranslatorRoster::Private::GetRefFor(translator_id id, entry_ref&amp; ref)</a>
<a name="ln851">{</a>
<a name="ln852">	BAutolock locker(this);</a>
<a name="ln853"> </a>
<a name="ln854">	const translator_item* item = _FindTranslator(id);</a>
<a name="ln855">	if (item == NULL)</a>
<a name="ln856">		return B_NO_TRANSLATOR;</a>
<a name="ln857"> </a>
<a name="ln858">	BEntry entry(&amp;item-&gt;ref);</a>
<a name="ln859">	if (entry.InitCheck() == B_OK &amp;&amp; entry.Exists() &amp;&amp; entry.IsFile()) {</a>
<a name="ln860">		ref = item-&gt;ref;</a>
<a name="ln861">		return B_OK;</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	return B_ERROR;</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867"> </a>
<a name="ln868">void</a>
<a name="ln869">BTranslatorRoster::Private::_TranslatorDeleted(translator_id id, BTranslator* self)</a>
<a name="ln870">{</a>
<a name="ln871">	BAutolock locker(this);</a>
<a name="ln872"> </a>
<a name="ln873">	TranslatorMap::iterator iterator = fTranslators.find(id);</a>
<a name="ln874">	if (iterator != fTranslators.end())</a>
<a name="ln875">		fTranslators.erase(iterator);</a>
<a name="ln876"> </a>
<a name="ln877">	image_id image = fImageOrigins[self];</a>
<a name="ln878"> </a>
<a name="ln879">	delete self;</a>
<a name="ln880"> </a>
<a name="ln881">	int32 former = atomic_add(&amp;fKnownImages[image], -1);</a>
<a name="ln882">	if (former == 1) {</a>
<a name="ln883">		unload_add_on(image);</a>
<a name="ln884">		fImageOrigins.erase(self);</a>
<a name="ln885">		fKnownImages.erase(image);</a>
<a name="ln886">	}</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889"> </a>
<a name="ln890">/*static*/ int</a>
<a name="ln891">BTranslatorRoster::Private::_CompareSupport(const void* _a, const void* _b)</a>
<a name="ln892">{</a>
<a name="ln893">	const translator_info* infoA = (const translator_info*)_a;</a>
<a name="ln894">	const translator_info* infoB = (const translator_info*)_b;</a>
<a name="ln895"> </a>
<a name="ln896">	float weightA = infoA-&gt;quality * infoA-&gt;capability;</a>
<a name="ln897">	float weightB = infoB-&gt;quality * infoB-&gt;capability;</a>
<a name="ln898"> </a>
<a name="ln899">	if (weightA == weightB)</a>
<a name="ln900">		return 0;</a>
<a name="ln901">	if (weightA &gt; weightB)</a>
<a name="ln902">		return -1;</a>
<a name="ln903"> </a>
<a name="ln904">	return 1;</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907"> </a>
<a name="ln908">/*!</a>
<a name="ln909">	In lazy mode, freshly installed translator are not scanned immediately</a>
<a name="ln910">	when they become available. Instead, they are put into a set.</a>
<a name="ln911"> </a>
<a name="ln912">	When a method is called that may be interested in these new translators,</a>
<a name="ln913">	they are scanned on the fly. Since lazy mode also means that this roster</a>
<a name="ln914">	does not have any listeners, we don't need to notify anyone about those</a>
<a name="ln915">	changes.</a>
<a name="ln916">*/</a>
<a name="ln917">void</a>
<a name="ln918">BTranslatorRoster::Private::_RescanChanged()</a>
<a name="ln919">{</a>
<a name="ln920">	while (!fRescanEntries.empty()) {</a>
<a name="ln921">		EntryRefSet::iterator iterator = fRescanEntries.begin();</a>
<a name="ln922">		int32 count;</a>
<a name="ln923">		CreateTranslators(*iterator, count);</a>
<a name="ln924"> </a>
<a name="ln925">		fRescanEntries.erase(iterator);</a>
<a name="ln926">	}</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930">/*!</a>
<a name="ln931">	Tests if the hints provided for a source stream are compatible to</a>
<a name="ln932">	the formats the translator exports.</a>
<a name="ln933">*/</a>
<a name="ln934">const translation_format*</a>
<a name="ln935">BTranslatorRoster::Private::_CheckHints(const translation_format* formats,</a>
<a name="ln936">	int32 formatsCount, uint32 hintType, const char* hintMIME)</a>
<a name="ln937">{</a>
<a name="ln938">	if (formats == NULL || formatsCount &lt;= 0 || (!hintType &amp;&amp; hintMIME == NULL))</a>
<a name="ln939">		return NULL;</a>
<a name="ln940"> </a>
<a name="ln941">	// The provided MIME type hint may be a super type</a>
<a name="ln942">	int32 super = 0;</a>
<a name="ln943">	if (hintMIME &amp;&amp; !strchr(hintMIME, '/'))</a>
<a name="ln944">		super = strlen(hintMIME);</a>
<a name="ln945"> </a>
<a name="ln946">	// scan for suitable format</a>
<a name="ln947">	for (int32 i = 0; i &lt; formatsCount &amp;&amp; formats[i].type; i++) {</a>
<a name="ln948">		if (formats[i].type == hintType</a>
<a name="ln949">			|| (hintMIME</a>
<a name="ln950">				&amp;&amp; ((super &amp;&amp; !strncmp(formats[i].MIME, hintMIME, super))</a>
<a name="ln951">					|| !strcmp(formats[i].MIME, hintMIME))))</a>
<a name="ln952">			return &amp;formats[i];</a>
<a name="ln953">	}</a>
<a name="ln954"> </a>
<a name="ln955">	return NULL;</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958"> </a>
<a name="ln959">const translator_item*</a>
<a name="ln960">BTranslatorRoster::Private::_FindTranslator(translator_id id) const</a>
<a name="ln961">{</a>
<a name="ln962">	TranslatorMap::const_iterator iterator = fTranslators.find(id);</a>
<a name="ln963">	if (iterator == fTranslators.end())</a>
<a name="ln964">		return NULL;</a>
<a name="ln965"> </a>
<a name="ln966">	return &amp;iterator-&gt;second;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969"> </a>
<a name="ln970">const translator_item*</a>
<a name="ln971">BTranslatorRoster::Private::_FindTranslator(const char* name) const</a>
<a name="ln972">{</a>
<a name="ln973">	if (name == NULL)</a>
<a name="ln974">		return NULL;</a>
<a name="ln975"> </a>
<a name="ln976">	TranslatorMap::const_iterator iterator = fTranslators.begin();</a>
<a name="ln977"> </a>
<a name="ln978">	while (iterator != fTranslators.end()) {</a>
<a name="ln979">		const translator_item&amp; item = iterator-&gt;second;</a>
<a name="ln980">		if (item.ref.name != NULL &amp;&amp; !strcmp(item.ref.name, name))</a>
<a name="ln981">			return &amp;item;</a>
<a name="ln982"> </a>
<a name="ln983">		iterator++;</a>
<a name="ln984">	}</a>
<a name="ln985"> </a>
<a name="ln986">	return NULL;</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989"> </a>
<a name="ln990">const translator_item*</a>
<a name="ln991">BTranslatorRoster::Private::_FindTranslator(entry_ref&amp; ref) const</a>
<a name="ln992">{</a>
<a name="ln993">	if (ref.name == NULL)</a>
<a name="ln994">		return NULL;</a>
<a name="ln995"> </a>
<a name="ln996">	TranslatorMap::const_iterator iterator = fTranslators.begin();</a>
<a name="ln997"> </a>
<a name="ln998">	while (iterator != fTranslators.end()) {</a>
<a name="ln999">		const translator_item&amp; item = iterator-&gt;second;</a>
<a name="ln1000">		if (item.ref == ref)</a>
<a name="ln1001">			return &amp;item;</a>
<a name="ln1002"> </a>
<a name="ln1003">		iterator++;</a>
<a name="ln1004">	}</a>
<a name="ln1005"> </a>
<a name="ln1006">	return NULL;</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009"> </a>
<a name="ln1010">translator_item*</a>
<a name="ln1011">BTranslatorRoster::Private::_FindTranslator(node_ref&amp; nodeRef)</a>
<a name="ln1012">{</a>
<a name="ln1013">	if (nodeRef.device &lt; 0)</a>
<a name="ln1014">		return NULL;</a>
<a name="ln1015"> </a>
<a name="ln1016">	TranslatorMap::iterator iterator = fTranslators.begin();</a>
<a name="ln1017"> </a>
<a name="ln1018">	while (iterator != fTranslators.end()) {</a>
<a name="ln1019">		translator_item&amp; item = iterator-&gt;second;</a>
<a name="ln1020">		if (item.ref.device == nodeRef.device</a>
<a name="ln1021">			&amp;&amp; item.node == nodeRef.node)</a>
<a name="ln1022">			return &amp;item;</a>
<a name="ln1023"> </a>
<a name="ln1024">		iterator++;</a>
<a name="ln1025">	}</a>
<a name="ln1026"> </a>
<a name="ln1027">	return NULL;</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030"> </a>
<a name="ln1031">/*!</a>
<a name="ln1032">	Directories added to the roster have a certain priority - the first entry</a>
<a name="ln1033">	to be added has the highest priority; if a translator with the same name</a>
<a name="ln1034">	is to be found in two directories, the one with the higher priority is</a>
<a name="ln1035">	chosen.</a>
<a name="ln1036">*/</a>
<a name="ln1037">int32</a>
<a name="ln1038">BTranslatorRoster::Private::_CompareTranslatorDirectoryPriority(</a>
<a name="ln1039">	const entry_ref&amp; a, const entry_ref&amp; b) const</a>
<a name="ln1040">{</a>
<a name="ln1041">	// priority is determined by the order in the list</a>
<a name="ln1042"> </a>
<a name="ln1043">	node_ref nodeRefA;</a>
<a name="ln1044">	nodeRefA.device = a.device;</a>
<a name="ln1045">	nodeRefA.node = a.directory;</a>
<a name="ln1046"> </a>
<a name="ln1047">	node_ref nodeRefB;</a>
<a name="ln1048">	nodeRefB.device = b.device;</a>
<a name="ln1049">	nodeRefB.node = b.directory;</a>
<a name="ln1050"> </a>
<a name="ln1051">	NodeRefList::const_iterator iterator = fDirectories.begin();</a>
<a name="ln1052"> </a>
<a name="ln1053">	while (iterator != fDirectories.end()) {</a>
<a name="ln1054">		if (*iterator == nodeRefA)</a>
<a name="ln1055">			return -1;</a>
<a name="ln1056">		if (*iterator == nodeRefB)</a>
<a name="ln1057">			return 1;</a>
<a name="ln1058"> </a>
<a name="ln1059">		iterator++;</a>
<a name="ln1060">	}</a>
<a name="ln1061"> </a>
<a name="ln1062">	return 0;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065"> </a>
<a name="ln1066">bool</a>
<a name="ln1067">BTranslatorRoster::Private::_IsKnownDirectory(const node_ref&amp; nodeRef) const</a>
<a name="ln1068">{</a>
<a name="ln1069">	NodeRefList::const_iterator iterator = fDirectories.begin();</a>
<a name="ln1070"> </a>
<a name="ln1071">	while (iterator != fDirectories.end()) {</a>
<a name="ln1072">		if (*iterator == nodeRef)</a>
<a name="ln1073">			return true;</a>
<a name="ln1074"> </a>
<a name="ln1075">		iterator++;</a>
<a name="ln1076">	}</a>
<a name="ln1077"> </a>
<a name="ln1078">	return false;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081"> </a>
<a name="ln1082">void</a>
<a name="ln1083">BTranslatorRoster::Private::_RemoveTranslators(const node_ref* nodeRef,</a>
<a name="ln1084">	const entry_ref* ref)</a>
<a name="ln1085">{</a>
<a name="ln1086">	if (ref == NULL &amp;&amp; nodeRef == NULL)</a>
<a name="ln1087">		return;</a>
<a name="ln1088"> </a>
<a name="ln1089">	TranslatorMap::iterator iterator = fTranslators.begin();</a>
<a name="ln1090">	BMessage update(B_TRANSLATOR_REMOVED);</a>
<a name="ln1091"> </a>
<a name="ln1092">	while (iterator != fTranslators.end()) {</a>
<a name="ln1093">		TranslatorMap::iterator next = iterator;</a>
<a name="ln1094">		next++;</a>
<a name="ln1095"> </a>
<a name="ln1096">		const translator_item&amp; item = iterator-&gt;second;</a>
<a name="ln1097">		if ((ref != NULL &amp;&amp; item.ref == *ref)</a>
<a name="ln1098">			|| (nodeRef != NULL &amp;&amp; item.ref.device == nodeRef-&gt;device</a>
<a name="ln1099">				&amp;&amp; item.node == nodeRef-&gt;node)) {</a>
<a name="ln1100">			item.translator-&gt;Release();</a>
<a name="ln1101">			update.AddInt32(&quot;translator_id&quot;, iterator-&gt;first);</a>
<a name="ln1102"> </a>
<a name="ln1103">			fTranslators.erase(iterator);</a>
<a name="ln1104">		}</a>
<a name="ln1105"> </a>
<a name="ln1106">		iterator = next;</a>
<a name="ln1107">	}</a>
<a name="ln1108"> </a>
<a name="ln1109">	_NotifyListeners(update);</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112"> </a>
<a name="ln1113">void</a>
<a name="ln1114">BTranslatorRoster::Private::_EntryAdded(const node_ref&amp; nodeRef,</a>
<a name="ln1115">	const char* name)</a>
<a name="ln1116">{</a>
<a name="ln1117">	entry_ref ref;</a>
<a name="ln1118">	ref.device = nodeRef.device;</a>
<a name="ln1119">	ref.directory = nodeRef.node;</a>
<a name="ln1120">	ref.set_name(name);</a>
<a name="ln1121"> </a>
<a name="ln1122">	_EntryAdded(ref);</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">/*!</a>
<a name="ln1127">	In lazy mode, the entry is marked to be rescanned on next use of any</a>
<a name="ln1128">	translation method (that could make use of it).</a>
<a name="ln1129">	In non-lazy mode, the translators for this entry are created directly</a>
<a name="ln1130">	and listeners notified.</a>
<a name="ln1131"> </a>
<a name="ln1132">	Called by the node monitor handling.</a>
<a name="ln1133">*/</a>
<a name="ln1134">void</a>
<a name="ln1135">BTranslatorRoster::Private::_EntryAdded(const entry_ref&amp; ref)</a>
<a name="ln1136">{</a>
<a name="ln1137">	BEntry entry;</a>
<a name="ln1138">	if (entry.SetTo(&amp;ref) != B_OK || !entry.IsFile())</a>
<a name="ln1139">		return;</a>
<a name="ln1140"> </a>
<a name="ln1141">	if (fLazyScanning) {</a>
<a name="ln1142">		fRescanEntries.insert(ref);</a>
<a name="ln1143">		return;</a>
<a name="ln1144">	}</a>
<a name="ln1145"> </a>
<a name="ln1146">	BMessage update(B_TRANSLATOR_ADDED);</a>
<a name="ln1147">	int32 count = 0;</a>
<a name="ln1148">	CreateTranslators(ref, count, &amp;update);</a>
<a name="ln1149"> </a>
<a name="ln1150">	_NotifyListeners(update);</a>
<a name="ln1151">}</a>
<a name="ln1152"> </a>
<a name="ln1153"> </a>
<a name="ln1154">void</a>
<a name="ln1155">BTranslatorRoster::Private::_NotifyListeners(BMessage&amp; update) const</a>
<a name="ln1156">{</a>
<a name="ln1157">	MessengerList::const_iterator iterator = fMessengers.begin();</a>
<a name="ln1158"> </a>
<a name="ln1159">	while (iterator != fMessengers.end()) {</a>
<a name="ln1160">		(*iterator).SendMessage(&amp;update);</a>
<a name="ln1161">		iterator++;</a>
<a name="ln1162">	}</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165"> </a>
<a name="ln1166">//	#pragma mark -</a>
<a name="ln1167"> </a>
<a name="ln1168"> </a>
<a name="ln1169">BTranslatorReleaseDelegate::BTranslatorReleaseDelegate(BTranslator* translator)</a>
<a name="ln1170">	:</a>
<a name="ln1171">	fUnderlying(translator)</a>
<a name="ln1172">{</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176">void</a>
<a name="ln1177">BTranslatorReleaseDelegate::Release()</a>
<a name="ln1178">{</a>
<a name="ln1179">	fUnderlying-&gt;Release();</a>
<a name="ln1180">	// ReleaseDelegate is only allowed to release a translator once.</a>
<a name="ln1181">	delete this;</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184"> </a>
<a name="ln1185">//	#pragma mark -</a>
<a name="ln1186"> </a>
<a name="ln1187"> </a>
<a name="ln1188">BTranslatorRoster::BTranslatorRoster()</a>
<a name="ln1189">{</a>
<a name="ln1190">	_Initialize();</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193"> </a>
<a name="ln1194">BTranslatorRoster::BTranslatorRoster(BMessage* model)</a>
<a name="ln1195">{</a>
<a name="ln1196">	_Initialize();</a>
<a name="ln1197"> </a>
<a name="ln1198">	if (model) {</a>
<a name="ln1199">		const char* path;</a>
<a name="ln1200">		for (int32 i = 0;</a>
<a name="ln1201">			model-&gt;FindString(&quot;be:translator_path&quot;, i, &amp;path) == B_OK; i++) {</a>
<a name="ln1202">			BEntry entry(path);</a>
<a name="ln1203">			entry_ref ref;</a>
<a name="ln1204">			if (entry.GetRef(&amp;ref) == B_OK) {</a>
<a name="ln1205">				int32 count = 0;</a>
<a name="ln1206">				fPrivate-&gt;CreateTranslators(ref, count);</a>
<a name="ln1207">			}</a>
<a name="ln1208">		}</a>
<a name="ln1209">	}</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212"> </a>
<a name="ln1213">BTranslatorRoster::~BTranslatorRoster()</a>
<a name="ln1214">{</a>
<a name="ln1215">	// If the default BTranslatorRoster is being</a>
<a name="ln1216">	// deleted, set the pointer to the default</a>
<a name="ln1217">	// BTranslatorRoster to NULL</a>
<a name="ln1218">	if (sDefaultRoster == this)</a>
<a name="ln1219">		sDefaultRoster = NULL;</a>
<a name="ln1220"> </a>
<a name="ln1221">	delete fPrivate;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224"> </a>
<a name="ln1225">void</a>
<a name="ln1226">BTranslatorRoster::_Initialize()</a>
<a name="ln1227">{</a>
<a name="ln1228">	fPrivate = new BTranslatorRoster::Private();</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231"> </a>
<a name="ln1232">status_t</a>
<a name="ln1233">BTranslatorRoster::Archive(BMessage* into, bool deep) const</a>
<a name="ln1234">{</a>
<a name="ln1235">	status_t status = BArchivable::Archive(into, deep);</a>
<a name="ln1236">	if (status != B_OK)</a>
<a name="ln1237">		return status;</a>
<a name="ln1238"> </a>
<a name="ln1239">	return fPrivate-&gt;StoreTranslators(*into);</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242"> </a>
<a name="ln1243">BArchivable*</a>
<a name="ln1244">BTranslatorRoster::Instantiate(BMessage* from)</a>
<a name="ln1245">{</a>
<a name="ln1246">	if (!from || !validate_instantiation(from, &quot;BTranslatorRoster&quot;))</a>
<a name="ln1247">		return NULL;</a>
<a name="ln1248"> </a>
<a name="ln1249">	return new BTranslatorRoster(from);</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252"> </a>
<a name="ln1253">BTranslatorRoster*</a>
<a name="ln1254">BTranslatorRoster::Default()</a>
<a name="ln1255">{</a>
<a name="ln1256">	static int32 lock = 0;</a>
<a name="ln1257"> </a>
<a name="ln1258">	if (sDefaultRoster != NULL)</a>
<a name="ln1259">		return sDefaultRoster;</a>
<a name="ln1260"> </a>
<a name="ln1261">	if (atomic_add(&amp;lock, 1) != 0) {</a>
<a name="ln1262">		// Just wait for the default translator to be instantiated</a>
<a name="ln1263">		while (sDefaultRoster == NULL)</a>
<a name="ln1264">			snooze(10000);</a>
<a name="ln1265"> </a>
<a name="ln1266">		atomic_add(&amp;lock, -1);</a>
<a name="ln1267">		return sDefaultRoster;</a>
<a name="ln1268">	}</a>
<a name="ln1269"> </a>
<a name="ln1270">	// If the default translators have not been loaded,</a>
<a name="ln1271">	// create a new BTranslatorRoster for them, and load them.</a>
<a name="ln1272">	if (sDefaultRoster == NULL) {</a>
<a name="ln1273">		BTranslatorRoster* roster = new BTranslatorRoster();</a>
<a name="ln1274">		roster-&gt;AddTranslators(NULL);</a>
<a name="ln1275"> </a>
<a name="ln1276">		sDefaultRoster = roster;</a>
<a name="ln1277">			// this will unlock any other threads waiting for</a>
<a name="ln1278">			// the default roster to become available</a>
<a name="ln1279">	}</a>
<a name="ln1280"> </a>
<a name="ln1281">	atomic_add(&amp;lock, -1);</a>
<a name="ln1282">	return sDefaultRoster;</a>
<a name="ln1283">}</a>
<a name="ln1284"> </a>
<a name="ln1285"> </a>
<a name="ln1286">/*!</a>
<a name="ln1287">	This function takes a string of colon delimited paths, and adds</a>
<a name="ln1288">	the translators from those paths to this BTranslatorRoster.</a>
<a name="ln1289"> </a>
<a name="ln1290">	If load_path is NULL, it parses the environment variable</a>
<a name="ln1291">	TRANSLATORS. If that does not exist, it uses the system paths:</a>
<a name="ln1292">		/boot/home/config/add-ons/Translators,</a>
<a name="ln1293">		/system/add-ons/Translators.</a>
<a name="ln1294">*/</a>
<a name="ln1295">status_t</a>
<a name="ln1296">BTranslatorRoster::AddTranslators(const char* path)</a>
<a name="ln1297">{</a>
<a name="ln1298">	if (path == NULL)</a>
<a name="ln1299">		path = getenv(&quot;TRANSLATORS&quot;);</a>
<a name="ln1300">	if (path == NULL) {</a>
<a name="ln1301">		fPrivate-&gt;AddDefaultPaths();</a>
<a name="ln1302">		return B_OK;</a>
<a name="ln1303">	}</a>
<a name="ln1304"> </a>
<a name="ln1305">	return fPrivate-&gt;AddPaths(path);</a>
<a name="ln1306">}</a>
<a name="ln1307"> </a>
<a name="ln1308"> </a>
<a name="ln1309">/*!</a>
<a name="ln1310">	Adds a BTranslator based object to the BTranslatorRoster.</a>
<a name="ln1311">	When you add a BTranslator roster, it is Acquire()'d by</a>
<a name="ln1312">	BTranslatorRoster; it is Release()'d when the</a>
<a name="ln1313">	BTranslatorRoster is deleted.</a>
<a name="ln1314"> </a>
<a name="ln1315">	\param translator the translator to be added to the</a>
<a name="ln1316">		BTranslatorRoster</a>
<a name="ln1317"> </a>
<a name="ln1318">	\return B_BAD_VALUE, if translator is NULL,</a>
<a name="ln1319">		B_OK if all went well</a>
<a name="ln1320">*/</a>
<a name="ln1321">status_t</a>
<a name="ln1322">BTranslatorRoster::AddTranslator(BTranslator* translator)</a>
<a name="ln1323">{</a>
<a name="ln1324">	if (!translator)</a>
<a name="ln1325">		return B_BAD_VALUE;</a>
<a name="ln1326"> </a>
<a name="ln1327">	return fPrivate-&gt;AddTranslator(translator);</a>
<a name="ln1328">}</a>
<a name="ln1329"> </a>
<a name="ln1330"> </a>
<a name="ln1331">bool</a>
<a name="ln1332">BTranslatorRoster::IsTranslator(entry_ref* ref)</a>
<a name="ln1333">{</a>
<a name="ln1334">	if (ref == NULL)</a>
<a name="ln1335">		return false;</a>
<a name="ln1336"> </a>
<a name="ln1337">	BPath path(ref);</a>
<a name="ln1338">	image_id image = load_add_on(path.Path());</a>
<a name="ln1339">	if (image &lt; B_OK)</a>
<a name="ln1340">		return false;</a>
<a name="ln1341"> </a>
<a name="ln1342">	// Function pointer used to create post R4.5 style translators</a>
<a name="ln1343">	BTranslator* (*makeNthTranslator)(int32 n, image_id you, uint32 flags, ...);</a>
<a name="ln1344"> </a>
<a name="ln1345">	status_t status = get_image_symbol(image, &quot;make_nth_translator&quot;,</a>
<a name="ln1346">		B_SYMBOL_TYPE_TEXT, (void**)&amp;makeNthTranslator);</a>
<a name="ln1347">	if (status &lt; B_OK) {</a>
<a name="ln1348">		// If this is a translator add-on, it is in the C format</a>
<a name="ln1349">		translator_data translatorData;</a>
<a name="ln1350">		status = fPrivate-&gt;GetTranslatorData(image, translatorData);</a>
<a name="ln1351">	}</a>
<a name="ln1352"> </a>
<a name="ln1353">	unload_add_on(image);</a>
<a name="ln1354">	return status == B_OK;</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357"> </a>
<a name="ln1358">/*!</a>
<a name="ln1359">	This function determines which translator is best suited</a>
<a name="ln1360">	to convert the data from \a source.</a>
<a name="ln1361"> </a>
<a name="ln1362">	\param source the data to be identified</a>
<a name="ln1363">	\param ioExtension the configuration data for the translator</a>
<a name="ln1364">	\param _info the information about the chosen translator is put here</a>
<a name="ln1365">	\param hintType a hint about the type of data that is in \a source, set</a>
<a name="ln1366">		it to zero if the type is not known</a>
<a name="ln1367">	\param hintMIME a hint about the MIME type of \a source, set it to NULL</a>
<a name="ln1368">		if the type is not known.</a>
<a name="ln1369">	\param wantType the desired output type - if zero, any type is okay.</a>
<a name="ln1370"> </a>
<a name="ln1371">	\return B_OK, identification of \a source was successful,</a>
<a name="ln1372">		B_NO_TRANSLATOR, no appropriate translator found,</a>
<a name="ln1373">		and other errors from accessing the source stream</a>
<a name="ln1374">*/</a>
<a name="ln1375">status_t</a>
<a name="ln1376">BTranslatorRoster::Identify(BPositionIO* source, BMessage* ioExtension,</a>
<a name="ln1377">	translator_info* _info, uint32 hintType, const char* hintMIME,</a>
<a name="ln1378">	uint32 wantType)</a>
<a name="ln1379">{</a>
<a name="ln1380">	if (source == NULL || _info == NULL)</a>
<a name="ln1381">		return B_BAD_VALUE;</a>
<a name="ln1382"> </a>
<a name="ln1383">	return fPrivate-&gt;Identify(source, ioExtension, hintType, hintMIME, wantType,</a>
<a name="ln1384">		_info);</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387"> </a>
<a name="ln1388">/*!</a>
<a name="ln1389">	Finds all translators capable of handling the data in \a source</a>
<a name="ln1390">	and puts them into the outInfo array (which you must delete</a>
<a name="ln1391">	yourself when you are done with it). Specifying a value for</a>
<a name="ln1392">	\a hintType, \a hintMIME and/or \a wantType causes only the</a>
<a name="ln1393">	translators that satisfy them to be included in the outInfo.</a>
<a name="ln1394"> </a>
<a name="ln1395">	\param source the data to be translated</a>
<a name="ln1396">	\param ioExtension the configuration data for the translator</a>
<a name="ln1397">	\param _info, the array of acceptable translators is stored here if</a>
<a name="ln1398">		the function succeeds. It's the caller's responsibility to free</a>
<a name="ln1399">		the array using delete[].</a>
<a name="ln1400">	\param _numInfo, number of entries in the \a _info array</a>
<a name="ln1401">	\param hintType a hint about the type of data that is in \a source, set</a>
<a name="ln1402">		it to zero if the type is not known</a>
<a name="ln1403">	\param hintMIME a hint about the MIME type of \a source, set it to NULL</a>
<a name="ln1404">		if the type is not known.</a>
<a name="ln1405">	\param wantType the desired output type - if zero, any type is okay.</a>
<a name="ln1406"> </a>
<a name="ln1407">	\return B_OK, successfully indentified the data in \a source</a>
<a name="ln1408">		B_NO_TRANSLATOR, no translator could handle \a source</a>
<a name="ln1409">		other errors, problems using \a source</a>
<a name="ln1410">*/</a>
<a name="ln1411">status_t</a>
<a name="ln1412">BTranslatorRoster::GetTranslators(BPositionIO* source, BMessage* ioExtension,</a>
<a name="ln1413">	translator_info** _info, int32* _numInfo, uint32 hintType,</a>
<a name="ln1414">	const char* hintMIME, uint32 wantType)</a>
<a name="ln1415">{</a>
<a name="ln1416">	if (source == NULL || _info == NULL || _numInfo == NULL)</a>
<a name="ln1417">		return B_BAD_VALUE;</a>
<a name="ln1418"> </a>
<a name="ln1419">	return fPrivate-&gt;GetTranslators(source, ioExtension, hintType, hintMIME,</a>
<a name="ln1420">		wantType, _info, _numInfo);</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423"> </a>
<a name="ln1424">/*!</a>
<a name="ln1425">	Returns an array in \a _ids of all of the translators stored by this</a>
<a name="ln1426">	object.</a>
<a name="ln1427">	You must free the array using delete[] when you are done with it.</a>
<a name="ln1428"> </a>
<a name="ln1429">	\param _ids the array is stored there (you own the array).</a>
<a name="ln1430">	\param _count number of IDs in the array.</a>
<a name="ln1431">*/</a>
<a name="ln1432">status_t</a>
<a name="ln1433">BTranslatorRoster::GetAllTranslators(translator_id** _ids, int32* _count)</a>
<a name="ln1434">{</a>
<a name="ln1435">	if (_ids == NULL || _count == NULL)</a>
<a name="ln1436">		return B_BAD_VALUE;</a>
<a name="ln1437"> </a>
<a name="ln1438">	return fPrivate-&gt;GetAllTranslators(_ids, _count);</a>
<a name="ln1439">}</a>
<a name="ln1440"> </a>
<a name="ln1441"> </a>
<a name="ln1442">/*!</a>
<a name="ln1443">	Returns information about the translator with the specified</a>
<a name="ln1444">	translator \a id.</a>
<a name="ln1445">	You must not free any of the data you get back.</a>
<a name="ln1446"> </a>
<a name="ln1447">	\param id identifies which translator you want info for</a>
<a name="ln1448">	\param _name the translator name is put here</a>
<a name="ln1449">	\param _info the translator description is put here</a>
<a name="ln1450">	\param _version the translation version is put here</a>
<a name="ln1451"> </a>
<a name="ln1452">	\return B_OK if successful,</a>
<a name="ln1453">		B_BAD_VALUE, if all parameters are NULL</a>
<a name="ln1454">		B_NO_TRANSLATOR, \id didn't identify an existing translator</a>
<a name="ln1455">*/</a>
<a name="ln1456">status_t</a>
<a name="ln1457">BTranslatorRoster::GetTranslatorInfo(translator_id id, const char** _name,</a>
<a name="ln1458">	const char** _info, int32* _version)</a>
<a name="ln1459">{</a>
<a name="ln1460">	if (_name == NULL &amp;&amp; _info == NULL &amp;&amp; _version == NULL)</a>
<a name="ln1461">		return B_BAD_VALUE;</a>
<a name="ln1462"> </a>
<a name="ln1463">	BAutolock locker(fPrivate);</a>
<a name="ln1464"> </a>
<a name="ln1465">	BTranslator* translator = fPrivate-&gt;FindTranslator(id);</a>
<a name="ln1466">	if (translator == NULL)</a>
<a name="ln1467">		return B_NO_TRANSLATOR;</a>
<a name="ln1468"> </a>
<a name="ln1469">	if (_name)</a>
<a name="ln1470">		*_name = translator-&gt;TranslatorName();</a>
<a name="ln1471">	if (_info)</a>
<a name="ln1472">		*_info = translator-&gt;TranslatorInfo();</a>
<a name="ln1473">	if (_version)</a>
<a name="ln1474">		*_version = translator-&gt;TranslatorVersion();</a>
<a name="ln1475"> </a>
<a name="ln1476">	return B_OK;</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479"> </a>
<a name="ln1480">/*!</a>
<a name="ln1481">	Returns all of the input formats for the translator specified</a>
<a name="ln1482">	by \a id.</a>
<a name="ln1483">	You must not free any of the data you get back.</a>
<a name="ln1484"> </a>
<a name="ln1485">	\param id identifies which translator you want the input formats for</a>
<a name="ln1486">	\param _formats array of input formats</a>
<a name="ln1487">	\param _numFormats number of formats in the array</a>
<a name="ln1488"> </a>
<a name="ln1489">	\return B_OK if successful,</a>
<a name="ln1490">		B_BAD_VALUE, if any parameter is NULL</a>
<a name="ln1491">		B_NO_TRANSLATOR, \id didn't identify an existing translator</a>
<a name="ln1492">*/</a>
<a name="ln1493">status_t</a>
<a name="ln1494">BTranslatorRoster::GetInputFormats(translator_id id,</a>
<a name="ln1495">	const translation_format** _formats, int32* _numFormats)</a>
<a name="ln1496">{</a>
<a name="ln1497">	if (_formats == NULL || _numFormats == NULL)</a>
<a name="ln1498">		return B_BAD_VALUE;</a>
<a name="ln1499"> </a>
<a name="ln1500">	BAutolock locker(fPrivate);</a>
<a name="ln1501"> </a>
<a name="ln1502">	BTranslator* translator = fPrivate-&gt;FindTranslator(id);</a>
<a name="ln1503">	if (translator == NULL)</a>
<a name="ln1504">		return B_NO_TRANSLATOR;</a>
<a name="ln1505"> </a>
<a name="ln1506">	*_formats = translator-&gt;InputFormats(_numFormats);</a>
<a name="ln1507">	return B_OK;</a>
<a name="ln1508">}</a>
<a name="ln1509"> </a>
<a name="ln1510"> </a>
<a name="ln1511">/*!</a>
<a name="ln1512">	Returns all of the output formats for the translator specified</a>
<a name="ln1513">	by \a id.</a>
<a name="ln1514">	You must not free any of the data you get back.</a>
<a name="ln1515"> </a>
<a name="ln1516">	\param id identifies which translator you want the output formats for</a>
<a name="ln1517">	\param _formats array of output formats</a>
<a name="ln1518">	\param _numFormats number of formats in the array</a>
<a name="ln1519"> </a>
<a name="ln1520">	\return B_OK if successful,</a>
<a name="ln1521">		B_BAD_VALUE, if any parameter is NULL</a>
<a name="ln1522">		B_NO_TRANSLATOR, \id didn't identify an existing translator</a>
<a name="ln1523">*/</a>
<a name="ln1524">status_t</a>
<a name="ln1525">BTranslatorRoster::GetOutputFormats(translator_id id,</a>
<a name="ln1526">	const translation_format** _formats, int32* _numFormats)</a>
<a name="ln1527">{</a>
<a name="ln1528">	if (_formats == NULL || _numFormats == NULL)</a>
<a name="ln1529">		return B_BAD_VALUE;</a>
<a name="ln1530"> </a>
<a name="ln1531">	BAutolock locker(fPrivate);</a>
<a name="ln1532"> </a>
<a name="ln1533">	BTranslator* translator = fPrivate-&gt;FindTranslator(id);</a>
<a name="ln1534">	if (translator == NULL)</a>
<a name="ln1535">		return B_NO_TRANSLATOR;</a>
<a name="ln1536"> </a>
<a name="ln1537">	*_formats = translator-&gt;OutputFormats(_numFormats);</a>
<a name="ln1538">	return B_OK;</a>
<a name="ln1539">}</a>
<a name="ln1540"> </a>
<a name="ln1541"> </a>
<a name="ln1542">/*!</a>
<a name="ln1543">	This function is the whole point of the Translation Kit.</a>
<a name="ln1544">	This is for translating the data in \a source to \a destination</a>
<a name="ln1545">	using the format \a wantOutType.</a>
<a name="ln1546"> </a>
<a name="ln1547">	\param source the data to be translated</a>
<a name="ln1548">	\param ioExtension the configuration data for the translator</a>
<a name="ln1549">	\param info information about translator to use (can be NULL, in which</a>
<a name="ln1550">		case the \a source is identified first)</a>
<a name="ln1551">	\param destination where \a source is translated to</a>
<a name="ln1552">	\param hintType a hint about the type of data that is in \a source, set</a>
<a name="ln1553">		it to zero if the type is not known</a>
<a name="ln1554">	\param hintMIME a hint about the MIME type of \a source, set it to NULL</a>
<a name="ln1555">		if the type is not known.</a>
<a name="ln1556">	\param wantType the desired output type - if zero, any type is okay.</a>
<a name="ln1557"> </a>
<a name="ln1558">	\return B_OK, translation of \a source was successful,</a>
<a name="ln1559">		B_NO_TRANSLATOR, no appropriate translator found,</a>
<a name="ln1560">		and other errors from accessing the source and destination streams</a>
<a name="ln1561">*/</a>
<a name="ln1562">status_t</a>
<a name="ln1563">BTranslatorRoster::Translate(BPositionIO* source, const translator_info* info,</a>
<a name="ln1564">	BMessage* ioExtension, BPositionIO* destination, uint32 wantOutType,</a>
<a name="ln1565">	uint32 hintType, const char* hintMIME)</a>
<a name="ln1566">{</a>
<a name="ln1567">	if (source == NULL || destination == NULL)</a>
<a name="ln1568">		return B_BAD_VALUE;</a>
<a name="ln1569"> </a>
<a name="ln1570">	translator_info infoBuffer;</a>
<a name="ln1571"> </a>
<a name="ln1572">	if (info == NULL) {</a>
<a name="ln1573">		// look for a suitable translator</a>
<a name="ln1574">		status_t status = fPrivate-&gt;Identify(source, ioExtension, hintType,</a>
<a name="ln1575">			hintMIME, wantOutType, &amp;infoBuffer);</a>
<a name="ln1576">		if (status &lt; B_OK)</a>
<a name="ln1577">			return status;</a>
<a name="ln1578"> </a>
<a name="ln1579">		info = &amp;infoBuffer;</a>
<a name="ln1580">	}</a>
<a name="ln1581"> </a>
<a name="ln1582">	if (!fPrivate-&gt;Lock())</a>
<a name="ln1583">		return B_ERROR;</a>
<a name="ln1584"> </a>
<a name="ln1585">	BTranslator* translator = fPrivate-&gt;FindTranslator(info-&gt;translator);</a>
<a name="ln1586">	if (translator != NULL) {</a>
<a name="ln1587">		translator-&gt;Acquire();</a>
<a name="ln1588">			// make sure this translator is not removed while we're playing with</a>
<a name="ln1589">			// it; translating shouldn't be serialized!</a>
<a name="ln1590">	}</a>
<a name="ln1591"> </a>
<a name="ln1592">	fPrivate-&gt;Unlock();</a>
<a name="ln1593"> </a>
<a name="ln1594">	if (translator == NULL)</a>
<a name="ln1595">		return B_NO_TRANSLATOR;</a>
<a name="ln1596"> </a>
<a name="ln1597">	status_t status = B_OK;</a>
<a name="ln1598">	off_t pos = source-&gt;Seek(0, SEEK_SET);</a>
<a name="ln1599">	if (pos != 0)</a>
<a name="ln1600">		status = pos &lt; 0 ? (status_t)pos : B_IO_ERROR;</a>
<a name="ln1601">	if (status == B_OK) {</a>
<a name="ln1602">		status = translator-&gt;Translate(source, info, ioExtension, wantOutType,</a>
<a name="ln1603">			destination);</a>
<a name="ln1604">	}</a>
<a name="ln1605">	translator-&gt;Release();</a>
<a name="ln1606"> </a>
<a name="ln1607">	return status;</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610"> </a>
<a name="ln1611">/*!</a>
<a name="ln1612">	This function is the whole point of the Translation Kit.</a>
<a name="ln1613">	This is for translating the data in \a source to \a destination</a>
<a name="ln1614">	using the format \a wantOutType and the translator identified</a>
<a name="ln1615">	by \a id.</a>
<a name="ln1616"> </a>
<a name="ln1617">	\param id the translator to be used</a>
<a name="ln1618">	\param source the data to be translated</a>
<a name="ln1619">	\param ioExtension the configuration data for the translator</a>
<a name="ln1620">	\param destination where \a source is translated to</a>
<a name="ln1621">	\param wantType the desired output type - if zero, any type is okay.</a>
<a name="ln1622"> </a>
<a name="ln1623">	\return B_OK, translation of \a source was successful,</a>
<a name="ln1624">		B_NO_TRANSLATOR, no appropriate translator found,</a>
<a name="ln1625">		and other errors from accessing the source and destination streams</a>
<a name="ln1626">*/</a>
<a name="ln1627">status_t</a>
<a name="ln1628">BTranslatorRoster::Translate(translator_id id, BPositionIO* source,</a>
<a name="ln1629">	BMessage* ioExtension, BPositionIO* destination, uint32 wantOutType)</a>
<a name="ln1630">{</a>
<a name="ln1631">	if (source == NULL || destination == NULL)</a>
<a name="ln1632">		return B_BAD_VALUE;</a>
<a name="ln1633"> </a>
<a name="ln1634">	if (!fPrivate-&gt;Lock())</a>
<a name="ln1635">		return B_ERROR;</a>
<a name="ln1636"> </a>
<a name="ln1637">	BTranslator* translator = fPrivate-&gt;FindTranslator(id);</a>
<a name="ln1638">	if (translator != NULL) {</a>
<a name="ln1639">		translator-&gt;Acquire();</a>
<a name="ln1640">			// make sure this translator is not removed while we're playing with</a>
<a name="ln1641">			// it; translating shouldn't be serialized!</a>
<a name="ln1642">	}</a>
<a name="ln1643"> </a>
<a name="ln1644">	fPrivate-&gt;Unlock();</a>
<a name="ln1645"> </a>
<a name="ln1646">	if (translator == NULL)</a>
<a name="ln1647">		return B_NO_TRANSLATOR;</a>
<a name="ln1648"> </a>
<a name="ln1649">	status_t status;</a>
<a name="ln1650">	off_t pos = source-&gt;Seek(0, SEEK_SET);</a>
<a name="ln1651">	if (pos == 0) {</a>
<a name="ln1652">		translator_info info;</a>
<a name="ln1653">		status = translator-&gt;Identify(source, NULL, ioExtension, &amp;info,</a>
<a name="ln1654">			wantOutType);</a>
<a name="ln1655">		if (status &gt;= B_OK) {</a>
<a name="ln1656">			off_t pos = source-&gt;Seek(0, SEEK_SET);</a>
<a name="ln1657">			if (pos != 0)</a>
<a name="ln1658">				status = pos &lt; 0 ? (status_t)pos : B_IO_ERROR;</a>
<a name="ln1659">			else {</a>
<a name="ln1660">				status = translator-&gt;Translate(source, &amp;info, ioExtension,</a>
<a name="ln1661">					wantOutType, destination);</a>
<a name="ln1662">			}</a>
<a name="ln1663">		}</a>
<a name="ln1664">	} else</a>
<a name="ln1665">		status = pos &lt; 0 ? (status_t)pos : B_IO_ERROR;</a>
<a name="ln1666">	translator-&gt;Release();</a>
<a name="ln1667"> </a>
<a name="ln1668">	return status;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671"> </a>
<a name="ln1672">/*!</a>
<a name="ln1673">	Creates a BView in \a _view for configuring the translator specified</a>
<a name="ln1674">	by \a id. Not all translators support this, though.</a>
<a name="ln1675"> </a>
<a name="ln1676">	\param id identifies which translator you want the input formats for</a>
<a name="ln1677">	\param ioExtension the configuration data for the translator</a>
<a name="ln1678">	\param _view the view for configuring the translator</a>
<a name="ln1679">	\param _extent the bounds for the (resizable) view</a>
<a name="ln1680"> </a>
<a name="ln1681">	\return B_OK if successful,</a>
<a name="ln1682">		B_BAD_VALUE, if any parameter is NULL</a>
<a name="ln1683">		B_NO_TRANSLATOR, \id didn't identify an existing translator</a>
<a name="ln1684">*/</a>
<a name="ln1685">status_t</a>
<a name="ln1686">BTranslatorRoster::MakeConfigurationView(translator_id id,</a>
<a name="ln1687">	BMessage* ioExtension, BView** _view, BRect* _extent)</a>
<a name="ln1688">{</a>
<a name="ln1689">	if (_view == NULL || _extent == NULL)</a>
<a name="ln1690">		return B_BAD_VALUE;</a>
<a name="ln1691"> </a>
<a name="ln1692">	BAutolock locker(fPrivate);</a>
<a name="ln1693"> </a>
<a name="ln1694">	BTranslator* translator = fPrivate-&gt;FindTranslator(id);</a>
<a name="ln1695">	if (translator == NULL)</a>
<a name="ln1696">		return B_NO_TRANSLATOR;</a>
<a name="ln1697"> </a>
<a name="ln1698">	return translator-&gt;MakeConfigurationView(ioExtension, _view, _extent);</a>
<a name="ln1699">}</a>
<a name="ln1700"> </a>
<a name="ln1701"> </a>
<a name="ln1702">BTranslatorReleaseDelegate*</a>
<a name="ln1703">BTranslatorRoster::AcquireTranslator(int32 id)</a>
<a name="ln1704">{</a>
<a name="ln1705">	BAutolock locker(fPrivate);</a>
<a name="ln1706"> </a>
<a name="ln1707">	BTranslator* translator = fPrivate-&gt;FindTranslator(id);</a>
<a name="ln1708">	if (translator == NULL)</a>
<a name="ln1709">		return NULL;</a>
<a name="ln1710"> </a>
<a name="ln1711">	translator-&gt;Acquire();</a>
<a name="ln1712">	return new BTranslatorReleaseDelegate(translator);</a>
<a name="ln1713">}</a>
<a name="ln1714"> </a>
<a name="ln1715"> </a>
<a name="ln1716">/*!</a>
<a name="ln1717">	Gets the configuration setttings for the translator</a>
<a name="ln1718">	specified by \a id and puts them into \a ioExtension.</a>
<a name="ln1719"> </a>
<a name="ln1720">	\param id identifies which translator you want the input formats for</a>
<a name="ln1721">	\param ioExtension the configuration data for the translator</a>
<a name="ln1722"> </a>
<a name="ln1723">	\return B_OK if successful,</a>
<a name="ln1724">		B_BAD_VALUE, if \a ioExtension is NULL</a>
<a name="ln1725">		B_NO_TRANSLATOR, \id didn't identify an existing translator</a>
<a name="ln1726">*/</a>
<a name="ln1727">status_t</a>
<a name="ln1728">BTranslatorRoster::GetConfigurationMessage(translator_id id,</a>
<a name="ln1729">	BMessage* ioExtension)</a>
<a name="ln1730">{</a>
<a name="ln1731">	if (!ioExtension)</a>
<a name="ln1732">		return B_BAD_VALUE;</a>
<a name="ln1733"> </a>
<a name="ln1734">	BAutolock locker(fPrivate);</a>
<a name="ln1735"> </a>
<a name="ln1736">	BTranslator* translator = fPrivate-&gt;FindTranslator(id);</a>
<a name="ln1737">	if (translator == NULL)</a>
<a name="ln1738">		return B_NO_TRANSLATOR;</a>
<a name="ln1739"> </a>
<a name="ln1740">	return translator-&gt;GetConfigurationMessage(ioExtension);</a>
<a name="ln1741">}</a>
<a name="ln1742"> </a>
<a name="ln1743"> </a>
<a name="ln1744">/*!</a>
<a name="ln1745">	Gets the entry_ref for the given translator (of course, this works only</a>
<a name="ln1746">	for disk based translators).</a>
<a name="ln1747"> </a>
<a name="ln1748">	\param id identifies which translator you want the input formats for</a>
<a name="ln1749">	\param ref the entry ref is stored there</a>
<a name="ln1750"> </a>
<a name="ln1751">	\return B_OK if successful,</a>
<a name="ln1752">		B_ERROR, if this is not a disk based translator</a>
<a name="ln1753">		B_BAD_VALUE, if \a ref is NULL</a>
<a name="ln1754">		B_NO_TRANSLATOR, \id didn't identify an existing translator</a>
<a name="ln1755">*/</a>
<a name="ln1756">status_t</a>
<a name="ln1757">BTranslatorRoster::GetRefFor(translator_id id, entry_ref* ref)</a>
<a name="ln1758">{</a>
<a name="ln1759">	if (ref == NULL)</a>
<a name="ln1760">		return B_BAD_VALUE;</a>
<a name="ln1761"> </a>
<a name="ln1762">	return fPrivate-&gt;GetRefFor(id, *ref);</a>
<a name="ln1763">}</a>
<a name="ln1764"> </a>
<a name="ln1765"> </a>
<a name="ln1766">status_t</a>
<a name="ln1767">BTranslatorRoster::StartWatching(BMessenger target)</a>
<a name="ln1768">{</a>
<a name="ln1769">	return fPrivate-&gt;StartWatching(target);</a>
<a name="ln1770">}</a>
<a name="ln1771"> </a>
<a name="ln1772"> </a>
<a name="ln1773">status_t</a>
<a name="ln1774">BTranslatorRoster::StopWatching(BMessenger target)</a>
<a name="ln1775">{</a>
<a name="ln1776">	return fPrivate-&gt;StopWatching(target);</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779"> </a>
<a name="ln1780">//	#pragma mark - private</a>
<a name="ln1781"> </a>
<a name="ln1782"> </a>
<a name="ln1783">BTranslatorRoster::BTranslatorRoster(const BTranslatorRoster &amp;other)</a>
<a name="ln1784">{</a>
<a name="ln1785">}</a>
<a name="ln1786"> </a>
<a name="ln1787"> </a>
<a name="ln1788">BTranslatorRoster &amp;</a>
<a name="ln1789">BTranslatorRoster::operator=(const BTranslatorRoster &amp;tr)</a>
<a name="ln1790">{</a>
<a name="ln1791">	return *this;</a>
<a name="ln1792">}</a>
<a name="ln1793"> </a>
<a name="ln1794"> </a>
<a name="ln1795">#if __GNUC__ == 2	// gcc 2</a>
<a name="ln1796"> </a>
<a name="ln1797">/*static*/ const char*</a>
<a name="ln1798">BTranslatorRoster::Version(int32* outCurVersion, int32* outMinVersion,</a>
<a name="ln1799">	int32 inAppVersion)</a>
<a name="ln1800">{</a>
<a name="ln1801">	if (!outCurVersion || !outMinVersion)</a>
<a name="ln1802">		return &quot;&quot;;</a>
<a name="ln1803"> </a>
<a name="ln1804">	static char vString[50];</a>
<a name="ln1805">	static char vDate[] = __DATE__;</a>
<a name="ln1806">	if (!vString[0]) {</a>
<a name="ln1807">		sprintf(vString, &quot;Translation Kit v%d.%d.%d %s\n&quot;,</a>
<a name="ln1808">			int(B_TRANSLATION_MAJOR_VERSION(B_TRANSLATION_CURRENT_VERSION)),</a>
<a name="ln1809">			int(B_TRANSLATION_MINOR_VERSION(B_TRANSLATION_CURRENT_VERSION)),</a>
<a name="ln1810">			int(B_TRANSLATION_REVISION_VERSION(B_TRANSLATION_CURRENT_VERSION)),</a>
<a name="ln1811">			vDate);</a>
<a name="ln1812">	}</a>
<a name="ln1813">	*outCurVersion = B_TRANSLATION_CURRENT_VERSION;</a>
<a name="ln1814">	*outMinVersion = B_TRANSLATION_MIN_VERSION;</a>
<a name="ln1815">	return vString;</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818">#endif	// gcc 2</a>
<a name="ln1819"> </a>
<a name="ln1820"> </a>
<a name="ln1821">void BTranslatorRoster::ReservedTranslatorRoster1() {}</a>
<a name="ln1822">void BTranslatorRoster::ReservedTranslatorRoster2() {}</a>
<a name="ln1823">void BTranslatorRoster::ReservedTranslatorRoster3() {}</a>
<a name="ln1824">void BTranslatorRoster::ReservedTranslatorRoster4() {}</a>
<a name="ln1825">void BTranslatorRoster::ReservedTranslatorRoster5() {}</a>
<a name="ln1826">void BTranslatorRoster::ReservedTranslatorRoster6() {}</a>

</code></pre>
<div class="balloon" rel="884"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v774/" target="_blank">V774</a> The 'self' pointer was used after the memory was released.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
