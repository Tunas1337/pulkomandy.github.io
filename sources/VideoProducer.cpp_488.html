
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>VideoProducer.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	Copyright (c) 1998-99, Be Incorporated, All Rights Reserved.</a>
<a name="ln2"> *	Distributed under the terms of the Be Sample Code license.</a>
<a name="ln3"> *</a>
<a name="ln4"> *	Copyright (c) 2000-2008, Ingo Weinhold &lt;ingo_weinhold@gmx.de&gt;,</a>
<a name="ln5"> *	Copyright (c) 2000-2008, Stephan AÃŸmus &lt;superstippi@gmx.de&gt;,</a>
<a name="ln6"> *	All Rights Reserved. Distributed under the terms of the MIT license.</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;VideoProducer.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;Autolock.h&gt;</a>
<a name="ln16">#include &lt;Buffer.h&gt;</a>
<a name="ln17">#include &lt;BufferGroup.h&gt;</a>
<a name="ln18">#include &lt;TimeSource.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;NodeManager.h&quot;</a>
<a name="ln21">#include &quot;VideoSupplier.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23"> </a>
<a name="ln24">// debugging</a>
<a name="ln25">//#define TRACE_VIDEO_PRODUCER</a>
<a name="ln26">#ifdef TRACE_VIDEO_PRODUCER</a>
<a name="ln27"># define	TRACE(x...) printf(&quot;VideoProducer::&quot;); printf(x)</a>
<a name="ln28"># define	FUNCTION(x...) TRACE(x)</a>
<a name="ln29"># define	ERROR(x...) fprintf(stderr, &quot;VideoProducer::&quot;); fprintf(stderr, x)</a>
<a name="ln30">#else</a>
<a name="ln31"># define	TRACE(x...)</a>
<a name="ln32"># define	FUNCTION(x...)</a>
<a name="ln33"># define	ERROR(x...) fprintf(stderr, &quot;VideoProducer::&quot;); fprintf(stderr, x)</a>
<a name="ln34">#endif</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">#define BUFFER_COUNT 3</a>
<a name="ln38"> </a>
<a name="ln39">#define TOUCH(x) ((void)(x))</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">VideoProducer::VideoProducer(BMediaAddOn* addon, const char* name,</a>
<a name="ln43">		int32 internalId, NodeManager* manager, VideoSupplier* supplier)</a>
<a name="ln44">	: BMediaNode(name),</a>
<a name="ln45">	  BMediaEventLooper(),</a>
<a name="ln46">	  BBufferProducer(B_MEDIA_RAW_VIDEO),</a>
<a name="ln47">	  fInitStatus(B_NO_INIT),</a>
<a name="ln48">	  fInternalID(internalId),</a>
<a name="ln49">	  fAddOn(addon),</a>
<a name="ln50">	  fBufferGroup(NULL),</a>
<a name="ln51">	  fUsedBufferGroup(NULL),</a>
<a name="ln52">	  fThread(-1),</a>
<a name="ln53">	  fFrameSync(-1),</a>
<a name="ln54">	  fFrame(0),</a>
<a name="ln55">	  fFrameBase(0),</a>
<a name="ln56">	  fPerformanceTimeBase(0),</a>
<a name="ln57">	  fBufferLatency(0),</a>
<a name="ln58">	  fRunning(false),</a>
<a name="ln59">	  fConnected(false),</a>
<a name="ln60">	  fEnabled(false),</a>
<a name="ln61">	  fManager(manager),</a>
<a name="ln62">	  fSupplier(supplier)</a>
<a name="ln63">{</a>
<a name="ln64">	fOutput.destination = media_destination::null;</a>
<a name="ln65">	fInitStatus = B_OK;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">VideoProducer::~VideoProducer()</a>
<a name="ln70">{</a>
<a name="ln71">	if (fInitStatus == B_OK) {</a>
<a name="ln72">		// Clean up after ourselves, in case the application didn't make us</a>
<a name="ln73">		// do so.</a>
<a name="ln74">		if (fConnected)</a>
<a name="ln75">			Disconnect(fOutput.source, fOutput.destination);</a>
<a name="ln76">		if (fRunning)</a>
<a name="ln77">			_HandleStop();</a>
<a name="ln78">	}</a>
<a name="ln79">	Quit();</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">BMediaAddOn*</a>
<a name="ln84">VideoProducer::AddOn(int32* _internalId) const</a>
<a name="ln85">{</a>
<a name="ln86">	if (_internalId)</a>
<a name="ln87">		*_internalId = fInternalID;</a>
<a name="ln88">	return fAddOn;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">status_t</a>
<a name="ln93">VideoProducer::HandleMessage(int32 message, const void* data, size_t size)</a>
<a name="ln94">{</a>
<a name="ln95">	return B_ERROR;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">void</a>
<a name="ln100">VideoProducer::SetTimeSource(BTimeSource* timeSource)</a>
<a name="ln101">{</a>
<a name="ln102">	// Tell frame generation thread to recalculate delay value</a>
<a name="ln103">	release_sem(fFrameSync);</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">void</a>
<a name="ln108">VideoProducer::NodeRegistered()</a>
<a name="ln109">{</a>
<a name="ln110">	if (fInitStatus != B_OK) {</a>
<a name="ln111">		ReportError(B_NODE_IN_DISTRESS);</a>
<a name="ln112">		return;</a>
<a name="ln113">	}</a>
<a name="ln114"> </a>
<a name="ln115">	fOutput.node = Node();</a>
<a name="ln116">	fOutput.source.port = ControlPort();</a>
<a name="ln117">	fOutput.source.id = 0;</a>
<a name="ln118">	fOutput.destination = media_destination::null;</a>
<a name="ln119">	strcpy(fOutput.name, Name());</a>
<a name="ln120"> </a>
<a name="ln121">	// fill with wild cards at this point in time</a>
<a name="ln122">	fOutput.format.type = B_MEDIA_RAW_VIDEO;</a>
<a name="ln123">	fOutput.format.u.raw_video = media_raw_video_format::wildcard;</a>
<a name="ln124">	fOutput.format.u.raw_video.interlace = 1;</a>
<a name="ln125">	fOutput.format.u.raw_video.display.format = B_NO_COLOR_SPACE;</a>
<a name="ln126">	fOutput.format.u.raw_video.display.bytes_per_row = 0;</a>
<a name="ln127">	fOutput.format.u.raw_video.display.line_width = 0;</a>
<a name="ln128">	fOutput.format.u.raw_video.display.line_count = 0;</a>
<a name="ln129"> </a>
<a name="ln130">	// start the BMediaEventLooper control loop running</a>
<a name="ln131">	Run();</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134"> </a>
<a name="ln135">void</a>
<a name="ln136">VideoProducer::Start(bigtime_t performanceTime)</a>
<a name="ln137">{</a>
<a name="ln138">	// notify the manager in case we were started from the outside world</a>
<a name="ln139">//	fManager-&gt;StartPlaying();</a>
<a name="ln140"> </a>
<a name="ln141">	BMediaEventLooper::Start(performanceTime);</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144"> </a>
<a name="ln145">void</a>
<a name="ln146">VideoProducer::Stop(bigtime_t performanceTime, bool immediate)</a>
<a name="ln147">{</a>
<a name="ln148">	// notify the manager in case we were stopped from the outside world</a>
<a name="ln149">//	fManager-&gt;StopPlaying();</a>
<a name="ln150"> </a>
<a name="ln151">	BMediaEventLooper::Stop(performanceTime, immediate);</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">void</a>
<a name="ln156">VideoProducer::Seek(bigtime_t media_time, bigtime_t performanceTime)</a>
<a name="ln157">{</a>
<a name="ln158">	BMediaEventLooper::Seek(media_time, performanceTime);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">void</a>
<a name="ln163">VideoProducer::HandleEvent(const media_timed_event* event,</a>
<a name="ln164">		bigtime_t lateness, bool realTimeEvent)</a>
<a name="ln165">{</a>
<a name="ln166">	TOUCH(lateness); TOUCH(realTimeEvent);</a>
<a name="ln167"> </a>
<a name="ln168">	switch (event-&gt;type) {</a>
<a name="ln169">		case BTimedEventQueue::B_START:</a>
<a name="ln170">			_HandleStart(event-&gt;event_time);</a>
<a name="ln171">			break;</a>
<a name="ln172">		case BTimedEventQueue::B_STOP:</a>
<a name="ln173">		{</a>
<a name="ln174">			EventQueue()-&gt;FlushEvents(event-&gt;event_time,</a>
<a name="ln175">				BTimedEventQueue::B_ALWAYS,</a>
<a name="ln176">				true, BTimedEventQueue::B_HANDLE_BUFFER);</a>
<a name="ln177">			_HandleStop();</a>
<a name="ln178">			break;</a>
<a name="ln179">		}</a>
<a name="ln180">		case BTimedEventQueue::B_WARP:</a>
<a name="ln181">			_HandleTimeWarp(event-&gt;bigdata);</a>
<a name="ln182">			break;</a>
<a name="ln183">		case BTimedEventQueue::B_SEEK:</a>
<a name="ln184">			_HandleSeek(event-&gt;bigdata);</a>
<a name="ln185">			break;</a>
<a name="ln186">		case BTimedEventQueue::B_HANDLE_BUFFER:</a>
<a name="ln187">		case BTimedEventQueue::B_DATA_STATUS:</a>
<a name="ln188">		case BTimedEventQueue::B_PARAMETER:</a>
<a name="ln189">		default:</a>
<a name="ln190">			TRACE(&quot;HandleEvent: Unhandled event -- %lx\n&quot;, event-&gt;type);</a>
<a name="ln191">			break;</a>
<a name="ln192">	}</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196">status_t</a>
<a name="ln197">VideoProducer::DeleteHook(BMediaNode* node)</a>
<a name="ln198">{</a>
<a name="ln199">	return BMediaEventLooper::DeleteHook(node);</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">status_t</a>
<a name="ln204">VideoProducer::FormatSuggestionRequested(media_type type, int32 quality,</a>
<a name="ln205">	media_format* _format)</a>
<a name="ln206">{</a>
<a name="ln207">	FUNCTION(&quot;FormatSuggestionRequested\n&quot;);</a>
<a name="ln208"> </a>
<a name="ln209">	if (type != B_MEDIA_ENCODED_VIDEO)</a>
<a name="ln210">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln211"> </a>
<a name="ln212">	TOUCH(quality);</a>
<a name="ln213"> </a>
<a name="ln214">	*_format = fOutput.format;</a>
<a name="ln215">	return B_OK;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">status_t</a>
<a name="ln220">VideoProducer::FormatProposal(const media_source&amp; output, media_format* format)</a>
<a name="ln221">{</a>
<a name="ln222">	#ifdef TRACE_VIDEO_PRODUCER</a>
<a name="ln223">		char string[256];</a>
<a name="ln224">		string_for_format(*format, string, 256);</a>
<a name="ln225">		FUNCTION(&quot;FormatProposal(%s)\n&quot;, string);</a>
<a name="ln226">	#endif</a>
<a name="ln227"> </a>
<a name="ln228">	if (!format)</a>
<a name="ln229">		return B_BAD_VALUE;</a>
<a name="ln230"> </a>
<a name="ln231">	if (output != fOutput.source)</a>
<a name="ln232">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln233"> </a>
<a name="ln234">	status_t ret = format_is_compatible(*format, fOutput.format) ?</a>
<a name="ln235">		B_OK : B_MEDIA_BAD_FORMAT;</a>
<a name="ln236">	if (ret != B_OK) {</a>
<a name="ln237">		ERROR(&quot;FormatProposal() error: %s\n&quot;, strerror(ret));</a>
<a name="ln238">		char string[512];</a>
<a name="ln239">		string_for_format(*format, string, sizeof(string));</a>
<a name="ln240">		ERROR(&quot;  requested: %s\n&quot;, string);</a>
<a name="ln241">		string_for_format(fOutput.format, string, sizeof(string));</a>
<a name="ln242">		ERROR(&quot;  output:    %s\n&quot;, string);</a>
<a name="ln243">	}</a>
<a name="ln244"> </a>
<a name="ln245">	// change any wild cards to specific values</a>
<a name="ln246"> </a>
<a name="ln247">	return ret;</a>
<a name="ln248"> </a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251"> </a>
<a name="ln252">status_t</a>
<a name="ln253">VideoProducer::FormatChangeRequested(const media_source&amp; source,</a>
<a name="ln254">	const media_destination&amp; destination, media_format* ioFormat,</a>
<a name="ln255">	int32 *_deprecated_)</a>
<a name="ln256">{</a>
<a name="ln257">	TOUCH(destination); TOUCH(ioFormat); TOUCH(_deprecated_);</a>
<a name="ln258"> </a>
<a name="ln259">	if (source != fOutput.source)</a>
<a name="ln260">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln261"> </a>
<a name="ln262">	return B_ERROR;</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265"> </a>
<a name="ln266">status_t</a>
<a name="ln267">VideoProducer::GetNextOutput(int32* cookie, media_output* outOutput)</a>
<a name="ln268">{</a>
<a name="ln269">	if (!outOutput)</a>
<a name="ln270">		return B_BAD_VALUE;</a>
<a name="ln271"> </a>
<a name="ln272">	if ((*cookie) != 0)</a>
<a name="ln273">		return B_BAD_INDEX;</a>
<a name="ln274"> </a>
<a name="ln275">	*outOutput = fOutput;</a>
<a name="ln276">	(*cookie)++;</a>
<a name="ln277"> </a>
<a name="ln278">	return B_OK;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">status_t</a>
<a name="ln283">VideoProducer::DisposeOutputCookie(int32 cookie)</a>
<a name="ln284">{</a>
<a name="ln285">	TOUCH(cookie);</a>
<a name="ln286"> </a>
<a name="ln287">	return B_OK;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290"> </a>
<a name="ln291">status_t</a>
<a name="ln292">VideoProducer::SetBufferGroup(const media_source&amp; forSource,</a>
<a name="ln293">	BBufferGroup *group)</a>
<a name="ln294">{</a>
<a name="ln295">	if (forSource != fOutput.source)</a>
<a name="ln296">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln297"> </a>
<a name="ln298">	TRACE(&quot;VideoProducer::SetBufferGroup() - using buffer group of &quot;</a>
<a name="ln299">		&quot;consumer.\n&quot;);</a>
<a name="ln300">	fUsedBufferGroup = group;</a>
<a name="ln301"> </a>
<a name="ln302">	return B_OK;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305"> </a>
<a name="ln306">status_t</a>
<a name="ln307">VideoProducer::VideoClippingChanged(const media_source&amp; forSource,</a>
<a name="ln308">	int16 numShorts, int16* clipData, const media_video_display_info&amp; display,</a>
<a name="ln309">	int32* _deprecated_)</a>
<a name="ln310">{</a>
<a name="ln311">	TOUCH(forSource); TOUCH(numShorts); TOUCH(clipData);</a>
<a name="ln312">	TOUCH(display); TOUCH(_deprecated_);</a>
<a name="ln313"> </a>
<a name="ln314">	return B_ERROR;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">status_t</a>
<a name="ln319">VideoProducer::GetLatency(bigtime_t* _latency)</a>
<a name="ln320">{</a>
<a name="ln321">	if (!_latency)</a>
<a name="ln322">		return B_BAD_VALUE;</a>
<a name="ln323"> </a>
<a name="ln324">	*_latency = EventLatency() + SchedulingLatency();</a>
<a name="ln325"> </a>
<a name="ln326">	return B_OK;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">status_t</a>
<a name="ln331">VideoProducer::PrepareToConnect(const media_source&amp; source,</a>
<a name="ln332">	const media_destination&amp; destination, media_format* format,</a>
<a name="ln333">	media_source* outSource, char* outName)</a>
<a name="ln334">{</a>
<a name="ln335">	FUNCTION(&quot;PrepareToConnect() %ldx%ld\n&quot;,</a>
<a name="ln336">		format-&gt;u.raw_video.display.line_width,</a>
<a name="ln337">		format-&gt;u.raw_video.display.line_count);</a>
<a name="ln338"> </a>
<a name="ln339">	if (fConnected) {</a>
<a name="ln340">		ERROR(&quot;PrepareToConnect() - already connected!\n&quot;);</a>
<a name="ln341">		return B_MEDIA_ALREADY_CONNECTED;</a>
<a name="ln342">	}</a>
<a name="ln343"> </a>
<a name="ln344">	if (source != fOutput.source)</a>
<a name="ln345">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln346"> </a>
<a name="ln347">	if (fOutput.destination != media_destination::null) {</a>
<a name="ln348">		ERROR(&quot;PrepareToConnect() - destination != null.\n&quot;);</a>
<a name="ln349">		return B_MEDIA_ALREADY_CONNECTED;</a>
<a name="ln350">	}</a>
<a name="ln351"> </a>
<a name="ln352">	// The format parameter comes in with the suggested format, and may be</a>
<a name="ln353">	// specialized as desired by the node</a>
<a name="ln354">	if (!format_is_compatible(*format, fOutput.format)) {</a>
<a name="ln355">		ERROR(&quot;PrepareToConnect() - incompatible format.\n&quot;);</a>
<a name="ln356">		*format = fOutput.format;</a>
<a name="ln357">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln358">	}</a>
<a name="ln359"> </a>
<a name="ln360">	if (format-&gt;u.raw_video.display.line_width == 0)</a>
<a name="ln361">		format-&gt;u.raw_video.display.line_width = 384;</a>
<a name="ln362">	if (format-&gt;u.raw_video.display.line_count == 0)</a>
<a name="ln363">		format-&gt;u.raw_video.display.line_count = 288;</a>
<a name="ln364">	if (format-&gt;u.raw_video.field_rate == 0)</a>
<a name="ln365">		format-&gt;u.raw_video.field_rate = 25.0;</a>
<a name="ln366">	if (format-&gt;u.raw_video.display.bytes_per_row == 0)</a>
<a name="ln367">		format-&gt;u.raw_video.display.bytes_per_row = format-&gt;u.raw_video.display.line_width * 4;</a>
<a name="ln368"> </a>
<a name="ln369">	*outSource = fOutput.source;</a>
<a name="ln370">	strcpy(outName, fOutput.name);</a>
<a name="ln371"> </a>
<a name="ln372">	return B_OK;</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375"> </a>
<a name="ln376">void</a>
<a name="ln377">VideoProducer::Connect(status_t error, const media_source&amp; source,</a>
<a name="ln378">	const media_destination&amp; destination, const media_format&amp; format,</a>
<a name="ln379">	char* _name)</a>
<a name="ln380">{</a>
<a name="ln381">	FUNCTION(&quot;Connect() %ldx%ld\n&quot;,</a>
<a name="ln382">		format.u.raw_video.display.line_width,</a>
<a name="ln383">		format.u.raw_video.display.line_count);</a>
<a name="ln384"> </a>
<a name="ln385">	if (fConnected) {</a>
<a name="ln386">		ERROR(&quot;Connect() - already connected.\n&quot;);</a>
<a name="ln387">		return;</a>
<a name="ln388">	}</a>
<a name="ln389"> </a>
<a name="ln390">	if (source != fOutput.source) {</a>
<a name="ln391">		ERROR(&quot;Connect() - wrong source.\n&quot;);</a>
<a name="ln392">		return;</a>
<a name="ln393">	}</a>
<a name="ln394">	if (error != B_OK) {</a>
<a name="ln395">		ERROR(&quot;Connect() - consumer error: %s\n&quot;, strerror(error));</a>
<a name="ln396">		return;</a>
<a name="ln397">	}</a>
<a name="ln398">	if (!const_cast&lt;media_format*&gt;(&amp;format)-&gt;Matches(&amp;fOutput.format)) {</a>
<a name="ln399">		ERROR(&quot;Connect() - format mismatch.\n&quot;);</a>
<a name="ln400">		return;</a>
<a name="ln401">	}</a>
<a name="ln402"> </a>
<a name="ln403">	fOutput.destination = destination;</a>
<a name="ln404">	strcpy(_name, fOutput.name);</a>
<a name="ln405">	fConnectedFormat = format.u.raw_video;</a>
<a name="ln406">	fBufferDuration = 20000;</a>
<a name="ln407"> </a>
<a name="ln408">	if (fConnectedFormat.field_rate != 0.0f) {</a>
<a name="ln409">		fPerformanceTimeBase = fPerformanceTimeBase</a>
<a name="ln410">			+ (bigtime_t)((fFrame - fFrameBase)</a>
<a name="ln411">				* 1000000LL / fConnectedFormat.field_rate);</a>
<a name="ln412">		fFrameBase = fFrame;</a>
<a name="ln413">		fBufferDuration = bigtime_t(1000000LL / fConnectedFormat.field_rate);</a>
<a name="ln414">	}</a>
<a name="ln415"> </a>
<a name="ln416">	if (fConnectedFormat.display.bytes_per_row == 0) {</a>
<a name="ln417">		ERROR(&quot;Connect() - connected format still has BPR wildcard!\n&quot;);</a>
<a name="ln418">		fConnectedFormat.display.bytes_per_row</a>
<a name="ln419">			= 4 * fConnectedFormat.display.line_width;</a>
<a name="ln420">	}</a>
<a name="ln421"> </a>
<a name="ln422">	// Create the buffer group</a>
<a name="ln423">	if (fUsedBufferGroup == NULL) {</a>
<a name="ln424">		fBufferGroup = new BBufferGroup(fConnectedFormat.display.bytes_per_row</a>
<a name="ln425">			* fConnectedFormat.display.line_count, BUFFER_COUNT);</a>
<a name="ln426">		status_t err = fBufferGroup-&gt;InitCheck();</a>
<a name="ln427">		if (err &lt; B_OK) {</a>
<a name="ln428">			delete fBufferGroup;</a>
<a name="ln429">			fBufferGroup = NULL;</a>
<a name="ln430">			ERROR(&quot;Connect() - buffer group error: %s\n&quot;, strerror(err));</a>
<a name="ln431">			return;</a>
<a name="ln432">		}</a>
<a name="ln433">		fUsedBufferGroup = fBufferGroup;</a>
<a name="ln434">	}</a>
<a name="ln435"> </a>
<a name="ln436">	// get the latency</a>
<a name="ln437">	fBufferLatency = (BUFFER_COUNT - 1) * fBufferDuration;</a>
<a name="ln438"> </a>
<a name="ln439">	int32 bufferCount;</a>
<a name="ln440">	if (fUsedBufferGroup-&gt;CountBuffers(&amp;bufferCount) == B_OK) {</a>
<a name="ln441">		// recompute the latency</a>
<a name="ln442">		fBufferLatency = (bufferCount - 1) * fBufferDuration;</a>
<a name="ln443">	}</a>
<a name="ln444"> </a>
<a name="ln445">	bigtime_t latency = 0;</a>
<a name="ln446">	media_node_id tsID = 0;</a>
<a name="ln447">	FindLatencyFor(fOutput.destination, &amp;latency, &amp;tsID);</a>
<a name="ln448">	SetEventLatency(latency + fBufferLatency);</a>
<a name="ln449"> </a>
<a name="ln450">	fConnected = true;</a>
<a name="ln451">	fEnabled = true;</a>
<a name="ln452"> </a>
<a name="ln453">	// Tell frame generation thread to recalculate delay value</a>
<a name="ln454">	release_sem(fFrameSync);</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458">void</a>
<a name="ln459">VideoProducer::Disconnect(const media_source&amp; source,</a>
<a name="ln460">	const media_destination&amp; destination)</a>
<a name="ln461">{</a>
<a name="ln462">	FUNCTION(&quot;Disconnect()\n&quot;);</a>
<a name="ln463"> </a>
<a name="ln464">	if (!fConnected) {</a>
<a name="ln465">		ERROR(&quot;Disconnect() - Not connected\n&quot;);</a>
<a name="ln466">		return;</a>
<a name="ln467">	}</a>
<a name="ln468"> </a>
<a name="ln469">	if ((source != fOutput.source) || (destination != fOutput.destination)) {</a>
<a name="ln470">		ERROR(&quot;Disconnect() - Bad source and/or destination\n&quot;);</a>
<a name="ln471">		return;</a>
<a name="ln472">	}</a>
<a name="ln473"> </a>
<a name="ln474">	fEnabled = false;</a>
<a name="ln475">	fOutput.destination = media_destination::null;</a>
<a name="ln476"> </a>
<a name="ln477">	if (fLock.Lock()) {</a>
<a name="ln478">		// Always delete the buffer group, even if it is not ours.</a>
<a name="ln479">		// (See BeBook::SetBufferGroup()).</a>
<a name="ln480">		delete fUsedBufferGroup;</a>
<a name="ln481">		if (fBufferGroup != fUsedBufferGroup)</a>
<a name="ln482">			delete fBufferGroup;</a>
<a name="ln483">		fUsedBufferGroup = NULL;</a>
<a name="ln484">		fBufferGroup = NULL;</a>
<a name="ln485">		fLock.Unlock();</a>
<a name="ln486">	}</a>
<a name="ln487"> </a>
<a name="ln488">	fConnected = false;</a>
<a name="ln489">	TRACE(&quot;Disconnect() done\n&quot;);</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">void</a>
<a name="ln494">VideoProducer::LateNoticeReceived(const media_source &amp;source,</a>
<a name="ln495">		bigtime_t how_much, bigtime_t performanceTime)</a>
<a name="ln496">{</a>
<a name="ln497">	TOUCH(source); TOUCH(how_much); TOUCH(performanceTime);</a>
<a name="ln498">	TRACE(&quot;Late!!!\n&quot;);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">void</a>
<a name="ln503">VideoProducer::EnableOutput(const media_source&amp; source, bool enabled,</a>
<a name="ln504">	int32* _deprecated_)</a>
<a name="ln505">{</a>
<a name="ln506">	TOUCH(_deprecated_);</a>
<a name="ln507"> </a>
<a name="ln508">	if (source != fOutput.source)</a>
<a name="ln509">		return;</a>
<a name="ln510"> </a>
<a name="ln511">	fEnabled = enabled;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514"> </a>
<a name="ln515">status_t</a>
<a name="ln516">VideoProducer::SetPlayRate(int32 numer, int32 denom)</a>
<a name="ln517">{</a>
<a name="ln518">	TOUCH(numer); TOUCH(denom);</a>
<a name="ln519"> </a>
<a name="ln520">	return B_ERROR;</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523"> </a>
<a name="ln524">void</a>
<a name="ln525">VideoProducer::AdditionalBufferRequested(const media_source&amp; source,</a>
<a name="ln526">	media_buffer_id prevBuffer, bigtime_t prevTime,</a>
<a name="ln527">	const media_seek_tag* prevTag)</a>
<a name="ln528">{</a>
<a name="ln529">	TOUCH(source); TOUCH(prevBuffer); TOUCH(prevTime); TOUCH(prevTag);</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532"> </a>
<a name="ln533">void</a>
<a name="ln534">VideoProducer::LatencyChanged(const media_source&amp; source,</a>
<a name="ln535">	const media_destination&amp; destination,</a>
<a name="ln536">	bigtime_t newLatency, uint32 flags)</a>
<a name="ln537">{</a>
<a name="ln538">	TOUCH(source); TOUCH(destination); TOUCH(newLatency); TOUCH(flags);</a>
<a name="ln539">	TRACE(&quot;Latency changed!\n&quot;);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">// #pragma mark -</a>
<a name="ln544"> </a>
<a name="ln545"> </a>
<a name="ln546">void</a>
<a name="ln547">VideoProducer::_HandleStart(bigtime_t performanceTime)</a>
<a name="ln548">{</a>
<a name="ln549">	// Start producing frames, even if the output hasn't been connected yet.</a>
<a name="ln550">	TRACE(&quot;_HandleStart(%Ld)\n&quot;, performanceTime);</a>
<a name="ln551"> </a>
<a name="ln552">	if (fRunning) {</a>
<a name="ln553">		TRACE(&quot;_HandleStart: Node already started\n&quot;);</a>
<a name="ln554">		return;</a>
<a name="ln555">	}</a>
<a name="ln556"> </a>
<a name="ln557">	fFrame = 0;</a>
<a name="ln558">	fFrameBase = 0;</a>
<a name="ln559">	fPerformanceTimeBase = performanceTime;</a>
<a name="ln560"> </a>
<a name="ln561">	fFrameSync = create_sem(0, &quot;frame synchronization&quot;);</a>
<a name="ln562">	if (fFrameSync &lt; B_OK)</a>
<a name="ln563">		return;</a>
<a name="ln564"> </a>
<a name="ln565">	fThread = spawn_thread(_FrameGeneratorThreadEntry, &quot;frame generator&quot;,</a>
<a name="ln566">		B_NORMAL_PRIORITY, this);</a>
<a name="ln567">	if (fThread &lt; B_OK) {</a>
<a name="ln568">		delete_sem(fFrameSync);</a>
<a name="ln569">		return;</a>
<a name="ln570">	}</a>
<a name="ln571"> </a>
<a name="ln572">	resume_thread(fThread);</a>
<a name="ln573">	fRunning = true;</a>
<a name="ln574">	return;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577"> </a>
<a name="ln578">void</a>
<a name="ln579">VideoProducer::_HandleStop()</a>
<a name="ln580">{</a>
<a name="ln581">	TRACE(&quot;_HandleStop()\n&quot;);</a>
<a name="ln582"> </a>
<a name="ln583">	if (!fRunning) {</a>
<a name="ln584">		TRACE(&quot;_HandleStop: Node isn't running\n&quot;);</a>
<a name="ln585">		return;</a>
<a name="ln586">	}</a>
<a name="ln587"> </a>
<a name="ln588">	delete_sem(fFrameSync);</a>
<a name="ln589">	wait_for_thread(fThread, &amp;fThread);</a>
<a name="ln590"> </a>
<a name="ln591">	fRunning = false;</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594"> </a>
<a name="ln595">void</a>
<a name="ln596">VideoProducer::_HandleTimeWarp(bigtime_t performanceTime)</a>
<a name="ln597">{</a>
<a name="ln598">	fPerformanceTimeBase = performanceTime;</a>
<a name="ln599">	fFrameBase = fFrame;</a>
<a name="ln600"> </a>
<a name="ln601">	// Tell frame generation thread to recalculate delay value</a>
<a name="ln602">	release_sem(fFrameSync);</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606">void</a>
<a name="ln607">VideoProducer::_HandleSeek(bigtime_t performanceTime)</a>
<a name="ln608">{</a>
<a name="ln609">	fPerformanceTimeBase = performanceTime;</a>
<a name="ln610">	fFrameBase = fFrame;</a>
<a name="ln611"> </a>
<a name="ln612">	// Tell frame generation thread to recalculate delay value</a>
<a name="ln613">	release_sem(fFrameSync);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616"> </a>
<a name="ln617">int32</a>
<a name="ln618">VideoProducer::_FrameGeneratorThreadEntry(void* data)</a>
<a name="ln619">{</a>
<a name="ln620">	return ((VideoProducer*)data)-&gt;_FrameGeneratorThread();</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623"> </a>
<a name="ln624">int32</a>
<a name="ln625">VideoProducer::_FrameGeneratorThread()</a>
<a name="ln626">{</a>
<a name="ln627">	bool forceSendingBuffer = true;</a>
<a name="ln628">	int32 droppedFrames = 0;</a>
<a name="ln629">	const int32 kMaxDroppedFrames = 15;</a>
<a name="ln630">	bool running = true;</a>
<a name="ln631">	while (running) {</a>
<a name="ln632">		TRACE(&quot;_FrameGeneratorThread: loop: %Ld\n&quot;, fFrame);</a>
<a name="ln633">		// lock the node manager</a>
<a name="ln634">		status_t err = fManager-&gt;LockWithTimeout(10000);</a>
<a name="ln635">		bool ignoreEvent = false;</a>
<a name="ln636">		// Data to be retrieved from the node manager.</a>
<a name="ln637">		bigtime_t performanceTime = 0;</a>
<a name="ln638">		bigtime_t nextPerformanceTime = 0;</a>
<a name="ln639">		bigtime_t waitUntil = 0;</a>
<a name="ln640">		bigtime_t nextWaitUntil = 0;</a>
<a name="ln641">		int32 playingDirection = 0;</a>
<a name="ln642">		int64 playlistFrame = 0;</a>
<a name="ln643">		switch (err) {</a>
<a name="ln644">			case B_OK: {</a>
<a name="ln645">				TRACE(&quot;_FrameGeneratorThread: node manager successfully &quot;</a>
<a name="ln646">					&quot;locked\n&quot;);</a>
<a name="ln647">				if (droppedFrames &gt; 0)</a>
<a name="ln648">					fManager-&gt;FrameDropped();</a>
<a name="ln649">				// get the times for the current and the next frame</a>
<a name="ln650">				performanceTime = fManager-&gt;TimeForFrame(fFrame);</a>
<a name="ln651">				nextPerformanceTime = fManager-&gt;TimeForFrame(fFrame + 1);</a>
<a name="ln652">				waitUntil = TimeSource()-&gt;RealTimeFor(fPerformanceTimeBase</a>
<a name="ln653">					+ performanceTime, fBufferLatency);</a>
<a name="ln654">				nextWaitUntil = TimeSource()-&gt;RealTimeFor(fPerformanceTimeBase</a>
<a name="ln655">					+ nextPerformanceTime, fBufferLatency);</a>
<a name="ln656">				// get playing direction and playlist frame for the current</a>
<a name="ln657">				// frame</a>
<a name="ln658">				bool newPlayingState;</a>
<a name="ln659">				playlistFrame = fManager-&gt;PlaylistFrameAtFrame(fFrame,</a>
<a name="ln660">					playingDirection, newPlayingState);</a>
<a name="ln661">				TRACE(&quot;_FrameGeneratorThread: performance time: %Ld, &quot;</a>
<a name="ln662">					&quot;playlist frame: %lld\n&quot;, performanceTime, playlistFrame);</a>
<a name="ln663">				forceSendingBuffer |= newPlayingState;</a>
<a name="ln664">				fManager-&gt;SetCurrentVideoTime(nextPerformanceTime);</a>
<a name="ln665">				fManager-&gt;Unlock();</a>
<a name="ln666">				break;</a>
<a name="ln667">			}</a>
<a name="ln668">			case B_TIMED_OUT:</a>
<a name="ln669">				TRACE(&quot;_FrameGeneratorThread: Couldn't lock the node &quot;</a>
<a name="ln670">					&quot;manager.\n&quot;);</a>
<a name="ln671">				ignoreEvent = true;</a>
<a name="ln672">				waitUntil = system_time() - 1;</a>
<a name="ln673">				break;</a>
<a name="ln674">			default:</a>
<a name="ln675">				ERROR(&quot;_FrameGeneratorThread: Couldn't lock the node manager. &quot;</a>
<a name="ln676">					&quot;Terminating video producer frame generator thread.\n&quot;);</a>
<a name="ln677">				TRACE(&quot;_FrameGeneratorThread: frame generator thread done.\n&quot;);</a>
<a name="ln678">				// do not access any member variables, since this could</a>
<a name="ln679">				// also mean the Node has been deleted</a>
<a name="ln680">				return B_OK;</a>
<a name="ln681">		}</a>
<a name="ln682"> </a>
<a name="ln683">		TRACE(&quot;_FrameGeneratorThread: waiting (%Ld)...\n&quot;, waitUntil);</a>
<a name="ln684">		// wait until...</a>
<a name="ln685">		err = acquire_sem_etc(fFrameSync, 1, B_ABSOLUTE_TIMEOUT, waitUntil);</a>
<a name="ln686">		// The only acceptable responses are B_OK and B_TIMED_OUT. Everything</a>
<a name="ln687">		// else means the thread should quit. Deleting the semaphore, as in</a>
<a name="ln688">		// VideoProducer::_HandleStop(), will trigger this behavior.</a>
<a name="ln689">		switch (err) {</a>
<a name="ln690">			case B_OK:</a>
<a name="ln691">				TRACE(&quot;_FrameGeneratorThread: going back to sleep.\n&quot;);</a>
<a name="ln692">				break;</a>
<a name="ln693">			case B_TIMED_OUT:</a>
<a name="ln694">				TRACE(&quot;_FrameGeneratorThread: timed out =&gt; event\n&quot;);</a>
<a name="ln695">				// Catch the cases in which the node manager could not be</a>
<a name="ln696">				// locked and we therefore have no valid data to work with,</a>
<a name="ln697">				// or the producer is not running or enabled.</a>
<a name="ln698">				if (ignoreEvent || !fRunning || !fEnabled) {</a>
<a name="ln699">					TRACE(&quot;_FrameGeneratorThread: ignore event\n&quot;);</a>
<a name="ln700">					// nothing to do</a>
<a name="ln701">				} else if (!forceSendingBuffer</a>
<a name="ln702">					&amp;&amp; nextWaitUntil &lt; system_time() - fBufferLatency</a>
<a name="ln703">					&amp;&amp; droppedFrames &lt; kMaxDroppedFrames) {</a>
<a name="ln704">					// Drop frame if it's at least a frame late.</a>
<a name="ln705">					if (playingDirection &gt; 0) {</a>
<a name="ln706">						printf(&quot;VideoProducer: dropped frame (%&quot; B_PRId64</a>
<a name="ln707">							&quot;) (perf. time %&quot; B_PRIdBIGTIME &quot;)\n&quot;, fFrame,</a>
<a name="ln708">							performanceTime);</a>
<a name="ln709">					}</a>
<a name="ln710">					// next frame</a>
<a name="ln711">					droppedFrames++;</a>
<a name="ln712">					fFrame++;</a>
<a name="ln713">				} else if (playingDirection != 0 || forceSendingBuffer) {</a>
<a name="ln714">					// Send buffers only, if playing, the node is running and</a>
<a name="ln715">					// the output has been enabled</a>
<a name="ln716">					TRACE(&quot;_FrameGeneratorThread: produce frame\n&quot;);</a>
<a name="ln717">					BAutolock _(fLock);</a>
<a name="ln718">					// Fetch a buffer from the buffer group</a>
<a name="ln719">					fUsedBufferGroup-&gt;WaitForBuffers();</a>
<a name="ln720">					BBuffer* buffer = fUsedBufferGroup-&gt;RequestBuffer(</a>
<a name="ln721">						fConnectedFormat.display.bytes_per_row</a>
<a name="ln722">						* fConnectedFormat.display.line_count, 0LL);</a>
<a name="ln723">					if (buffer == NULL) {</a>
<a name="ln724">						// Wait until a buffer becomes available again</a>
<a name="ln725">						ERROR(&quot;_FrameGeneratorThread: no buffer!\n&quot;);</a>
<a name="ln726">						break;</a>
<a name="ln727">					}</a>
<a name="ln728">					// Fill out the details about this buffer.</a>
<a name="ln729">					media_header* h = buffer-&gt;Header();</a>
<a name="ln730">					h-&gt;type = B_MEDIA_RAW_VIDEO;</a>
<a name="ln731">					h-&gt;time_source = TimeSource()-&gt;ID();</a>
<a name="ln732">					h-&gt;size_used = fConnectedFormat.display.bytes_per_row</a>
<a name="ln733">						* fConnectedFormat.display.line_count;</a>
<a name="ln734">					// For a buffer originating from a device, you might</a>
<a name="ln735">					// want to calculate this based on the</a>
<a name="ln736">					// PerformanceTimeFor the time your buffer arrived at</a>
<a name="ln737">					// the hardware (plus any applicable adjustments).</a>
<a name="ln738">					h-&gt;start_time = fPerformanceTimeBase + performanceTime;</a>
<a name="ln739">					h-&gt;file_pos = 0;</a>
<a name="ln740">					h-&gt;orig_size = 0;</a>
<a name="ln741">					h-&gt;data_offset = 0;</a>
<a name="ln742">					h-&gt;u.raw_video.field_gamma = 1.0;</a>
<a name="ln743">					h-&gt;u.raw_video.field_sequence = fFrame;</a>
<a name="ln744">					h-&gt;u.raw_video.field_number = 0;</a>
<a name="ln745">					h-&gt;u.raw_video.pulldown_number = 0;</a>
<a name="ln746">					h-&gt;u.raw_video.first_active_line = 1;</a>
<a name="ln747">					h-&gt;u.raw_video.line_count</a>
<a name="ln748">						= fConnectedFormat.display.line_count;</a>
<a name="ln749">					// Fill in a frame</a>
<a name="ln750">					TRACE(&quot;_FrameGeneratorThread: frame: %Ld, &quot;</a>
<a name="ln751">						&quot;playlistFrame: %Ld\n&quot;, fFrame, playlistFrame);</a>
<a name="ln752">					bool wasCached = false;</a>
<a name="ln753">					err = fSupplier-&gt;FillBuffer(playlistFrame,</a>
<a name="ln754">						buffer-&gt;Data(), fConnectedFormat, forceSendingBuffer,</a>
<a name="ln755">						wasCached);</a>
<a name="ln756">					if (err == B_TIMED_OUT) {</a>
<a name="ln757">						// Don't send the buffer if there was insufficient</a>
<a name="ln758">						// time for rendering, this will leave the last</a>
<a name="ln759">						// valid frame on screen until we catch up, instead</a>
<a name="ln760">						// of going black.</a>
<a name="ln761">						wasCached = true;</a>
<a name="ln762">						err = B_OK;</a>
<a name="ln763">					}</a>
<a name="ln764">					// clean the buffer if something went wrong</a>
<a name="ln765">					if (err != B_OK &amp;&amp; err != B_LAST_BUFFER_ERROR) {</a>
<a name="ln766">						// TODO: should use &quot;back value&quot; according</a>
<a name="ln767">						// to color space!</a>
<a name="ln768">						memset(buffer-&gt;Data(), 0, h-&gt;size_used);</a>
<a name="ln769">						err = B_OK;</a>
<a name="ln770">					} else if (err == B_LAST_BUFFER_ERROR)</a>
<a name="ln771">						running = false;</a>
<a name="ln772">					// Send the buffer on down to the consumer</a>
<a name="ln773">					if (wasCached || (err = SendBuffer(buffer, fOutput.source,</a>
<a name="ln774">							fOutput.destination) != B_OK)) {</a>
<a name="ln775">						// If there is a problem sending the buffer,</a>
<a name="ln776">						// or if we don't send the buffer because its</a>
<a name="ln777">						// contents are the same as the last one,</a>
<a name="ln778">						// return it to its buffer group.</a>
<a name="ln779">						buffer-&gt;Recycle();</a>
<a name="ln780">						// we tell the supplier to delete</a>
<a name="ln781">						// its caches if there was a problem sending</a>
<a name="ln782">						// the buffer</a>
<a name="ln783">						if (err != B_OK) {</a>
<a name="ln784">							ERROR(&quot;_FrameGeneratorThread: Error &quot;</a>
<a name="ln785">								&quot;sending buffer\n&quot;);</a>
<a name="ln786">							fSupplier-&gt;DeleteCaches();</a>
<a name="ln787">						}</a>
<a name="ln788">					}</a>
<a name="ln789">					// Only if everything went fine we clear the flag</a>
<a name="ln790">					// that forces us to send a buffer even if not</a>
<a name="ln791">					// playing.</a>
<a name="ln792">					if (err == B_OK)</a>
<a name="ln793">						forceSendingBuffer = false;</a>
<a name="ln794">					// next frame</a>
<a name="ln795">					fFrame++;</a>
<a name="ln796">					droppedFrames = 0;</a>
<a name="ln797">				} else {</a>
<a name="ln798">					TRACE(&quot;_FrameGeneratorThread: not playing\n&quot;);</a>
<a name="ln799">					// next frame</a>
<a name="ln800">					fFrame++;</a>
<a name="ln801">				}</a>
<a name="ln802">				break;</a>
<a name="ln803">			default:</a>
<a name="ln804">				TRACE(&quot;_FrameGeneratorThread: Couldn't acquire semaphore. &quot;</a>
<a name="ln805">					&quot;Error: %s\n&quot;, strerror(err));</a>
<a name="ln806">				running = false;</a>
<a name="ln807">				break;</a>
<a name="ln808">		}</a>
<a name="ln809">	}</a>
<a name="ln810">	TRACE(&quot;_FrameGeneratorThread: frame generator thread done.\n&quot;);</a>
<a name="ln811">	return B_OK;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>

</code></pre>
<div class="balloon" rel="773"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B != C' kind. The expression is calculated as following: 'A = (B != C)'.</p></div>
<div class="balloon" rel="42"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fBufferDuration, fConnectedFormat.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
