
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>HaikuControlLook.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009, Stephan Aßmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln3"> * Copyright 2012-2017 Haiku, Inc. All rights reserved.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Authors:</a>
<a name="ln7"> *		Stephan Aßmus, superstippi@gmx.de</a>
<a name="ln8"> *		John Scipione, jscipione@gmail.com</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;HaikuControlLook.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;algorithm&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;Bitmap.h&gt;</a>
<a name="ln17">#include &lt;Control.h&gt;</a>
<a name="ln18">#include &lt;GradientLinear.h&gt;</a>
<a name="ln19">#include &lt;LayoutUtils.h&gt;</a>
<a name="ln20">#include &lt;Region.h&gt;</a>
<a name="ln21">#include &lt;Shape.h&gt;</a>
<a name="ln22">#include &lt;String.h&gt;</a>
<a name="ln23">#include &lt;View.h&gt;</a>
<a name="ln24">#include &lt;Window.h&gt;</a>
<a name="ln25">#include &lt;WindowPrivate.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27"> </a>
<a name="ln28">namespace BPrivate {</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">static const float kEdgeBevelLightTint = 0.59;</a>
<a name="ln32">static const float kEdgeBevelShadowTint = 1.0735;</a>
<a name="ln33">static const float kHoverTintFactor = 0.85;</a>
<a name="ln34"> </a>
<a name="ln35">static const float kButtonPopUpIndicatorWidth = 11;</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">HaikuControlLook::HaikuControlLook()</a>
<a name="ln39">	:</a>
<a name="ln40">	fCachedOutline(false)</a>
<a name="ln41">{</a>
<a name="ln42">}</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">HaikuControlLook::~HaikuControlLook()</a>
<a name="ln46">{</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">BAlignment</a>
<a name="ln51">HaikuControlLook::DefaultLabelAlignment() const</a>
<a name="ln52">{</a>
<a name="ln53">	return BAlignment(B_ALIGN_LEFT, B_ALIGN_VERTICAL_CENTER);</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">float</a>
<a name="ln58">HaikuControlLook::DefaultLabelSpacing() const</a>
<a name="ln59">{</a>
<a name="ln60">	return ceilf(be_plain_font-&gt;Size() / 2.0);</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">float</a>
<a name="ln65">HaikuControlLook::DefaultItemSpacing() const</a>
<a name="ln66">{</a>
<a name="ln67">	return ceilf(be_plain_font-&gt;Size() * 0.85);</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">uint32</a>
<a name="ln72">HaikuControlLook::Flags(BControl* control) const</a>
<a name="ln73">{</a>
<a name="ln74">	uint32 flags = B_IS_CONTROL;</a>
<a name="ln75"> </a>
<a name="ln76">	if (!control-&gt;IsEnabled())</a>
<a name="ln77">		flags |= B_DISABLED;</a>
<a name="ln78"> </a>
<a name="ln79">	if (control-&gt;IsFocus() &amp;&amp; control-&gt;Window() != NULL</a>
<a name="ln80">		&amp;&amp; control-&gt;Window()-&gt;IsActive()) {</a>
<a name="ln81">		flags |= B_FOCUSED;</a>
<a name="ln82">	}</a>
<a name="ln83"> </a>
<a name="ln84">	switch (control-&gt;Value()) {</a>
<a name="ln85">		case B_CONTROL_ON:</a>
<a name="ln86">			flags |= B_ACTIVATED;</a>
<a name="ln87">			break;</a>
<a name="ln88">		case B_CONTROL_PARTIALLY_ON:</a>
<a name="ln89">			flags |= B_PARTIALLY_ACTIVATED;</a>
<a name="ln90">			break;</a>
<a name="ln91">	}</a>
<a name="ln92"> </a>
<a name="ln93">	if (control-&gt;Parent() != NULL</a>
<a name="ln94">		&amp;&amp; (control-&gt;Parent()-&gt;Flags() &amp; B_DRAW_ON_CHILDREN) != 0) {</a>
<a name="ln95">		// In this constellation, assume we want to render the control</a>
<a name="ln96">		// against the already existing view contents of the parent view.</a>
<a name="ln97">		flags |= B_BLEND_FRAME;</a>
<a name="ln98">	}</a>
<a name="ln99"> </a>
<a name="ln100">	return flags;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103"> </a>
<a name="ln104">// #pragma mark -</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">void</a>
<a name="ln108">HaikuControlLook::DrawButtonFrame(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln109">	const rgb_color&amp; base, const rgb_color&amp; background, uint32 flags,</a>
<a name="ln110">	uint32 borders)</a>
<a name="ln111">{</a>
<a name="ln112">	_DrawButtonFrame(view, rect, updateRect, 0.0f, 0.0f, 0.0f, 0.0f, base,</a>
<a name="ln113">		background, 1.0, 1.0, flags, borders);</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">void</a>
<a name="ln118">HaikuControlLook::DrawButtonFrame(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln119">	float radius, const rgb_color&amp; base, const rgb_color&amp; background, uint32 flags,</a>
<a name="ln120">	uint32 borders)</a>
<a name="ln121">{</a>
<a name="ln122">	_DrawButtonFrame(view, rect, updateRect, radius, radius, radius, radius,</a>
<a name="ln123">		base, background, 1.0, 1.0, flags, borders);</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">void</a>
<a name="ln128">HaikuControlLook::DrawButtonFrame(BView* view, BRect&amp; rect,</a>
<a name="ln129">	const BRect&amp; updateRect, float leftTopRadius, float rightTopRadius,</a>
<a name="ln130">	float leftBottomRadius, float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln131">	const rgb_color&amp; background, uint32 flags,</a>
<a name="ln132">	uint32 borders)</a>
<a name="ln133">{</a>
<a name="ln134">	_DrawButtonFrame(view, rect, updateRect, leftTopRadius, rightTopRadius,</a>
<a name="ln135">		leftBottomRadius, rightBottomRadius, base, background,</a>
<a name="ln136">		1.0, 1.0, flags, borders);</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">void</a>
<a name="ln141">HaikuControlLook::DrawButtonBackground(BView* view, BRect&amp; rect,</a>
<a name="ln142">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln143">	uint32 borders, orientation orientation)</a>
<a name="ln144">{</a>
<a name="ln145">	_DrawButtonBackground(view, rect, updateRect, 0.0f, 0.0f, 0.0f, 0.0f,</a>
<a name="ln146">		base, false, flags, borders, orientation);</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150">void</a>
<a name="ln151">HaikuControlLook::DrawButtonBackground(BView* view, BRect&amp; rect,</a>
<a name="ln152">	const BRect&amp; updateRect, float radius, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln153">	uint32 borders, orientation orientation)</a>
<a name="ln154">{</a>
<a name="ln155">	_DrawButtonBackground(view, rect, updateRect, radius, radius, radius,</a>
<a name="ln156">		radius, base, false, flags, borders, orientation);</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">void</a>
<a name="ln161">HaikuControlLook::DrawButtonBackground(BView* view, BRect&amp; rect,</a>
<a name="ln162">	const BRect&amp; updateRect, float leftTopRadius, float rightTopRadius,</a>
<a name="ln163">	float leftBottomRadius, float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln164">	uint32 flags, uint32 borders, orientation orientation)</a>
<a name="ln165">{</a>
<a name="ln166">	_DrawButtonBackground(view, rect, updateRect, leftTopRadius,</a>
<a name="ln167">		rightTopRadius, leftBottomRadius, rightBottomRadius, base, false, flags,</a>
<a name="ln168">		borders, orientation);</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">void</a>
<a name="ln173">HaikuControlLook::DrawMenuBarBackground(BView* view, BRect&amp; rect,</a>
<a name="ln174">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln175">	uint32 borders)</a>
<a name="ln176">{</a>
<a name="ln177">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln178">		return;</a>
<a name="ln179"> </a>
<a name="ln180">	// the surface edges</a>
<a name="ln181"> </a>
<a name="ln182">	// colors</a>
<a name="ln183">	float topTint;</a>
<a name="ln184">	float bottomTint;</a>
<a name="ln185"> </a>
<a name="ln186">	if ((flags &amp; B_ACTIVATED) != 0) {</a>
<a name="ln187">		rgb_color bevelColor1 = tint_color(base, 1.40);</a>
<a name="ln188">		rgb_color bevelColor2 = tint_color(base, 1.25);</a>
<a name="ln189"> </a>
<a name="ln190">		topTint = 1.25;</a>
<a name="ln191">		bottomTint = 1.20;</a>
<a name="ln192"> </a>
<a name="ln193">		_DrawFrame(view, rect,</a>
<a name="ln194">			bevelColor1, bevelColor1,</a>
<a name="ln195">			bevelColor2, bevelColor2,</a>
<a name="ln196">			borders &amp; B_TOP_BORDER);</a>
<a name="ln197">	} else {</a>
<a name="ln198">		rgb_color cornerColor = tint_color(base, 0.9);</a>
<a name="ln199">		rgb_color bevelColorTop = tint_color(base, 0.5);</a>
<a name="ln200">		rgb_color bevelColorLeft = tint_color(base, 0.7);</a>
<a name="ln201">		rgb_color bevelColorRightBottom = tint_color(base, 1.08);</a>
<a name="ln202"> </a>
<a name="ln203">		topTint = 0.69;</a>
<a name="ln204">		bottomTint = 1.03;</a>
<a name="ln205"> </a>
<a name="ln206">		_DrawFrame(view, rect,</a>
<a name="ln207">			bevelColorLeft, bevelColorTop,</a>
<a name="ln208">			bevelColorRightBottom, bevelColorRightBottom,</a>
<a name="ln209">			cornerColor, cornerColor,</a>
<a name="ln210">			borders);</a>
<a name="ln211">	}</a>
<a name="ln212"> </a>
<a name="ln213">	// draw surface top</a>
<a name="ln214">	_FillGradient(view, rect, base, topTint, bottomTint);</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">void</a>
<a name="ln219">HaikuControlLook::DrawMenuFieldFrame(BView* view, BRect&amp; rect,</a>
<a name="ln220">	const BRect&amp; updateRect, const rgb_color&amp; base,</a>
<a name="ln221">	const rgb_color&amp; background, uint32 flags, uint32 borders)</a>
<a name="ln222">{</a>
<a name="ln223">	_DrawButtonFrame(view, rect, updateRect, 0.0f, 0.0f, 0.0f, 0.0f, base,</a>
<a name="ln224">		background, 0.6, 1.0, flags, borders);</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">void</a>
<a name="ln229">HaikuControlLook::DrawMenuFieldFrame(BView* view, BRect&amp; rect,</a>
<a name="ln230">	const BRect&amp; updateRect, float radius, const rgb_color&amp; base,</a>
<a name="ln231">	const rgb_color&amp; background, uint32 flags, uint32 borders)</a>
<a name="ln232">{</a>
<a name="ln233">	_DrawButtonFrame(view, rect, updateRect, radius, radius, radius, radius,</a>
<a name="ln234">		base, background, 0.6, 1.0, flags, borders);</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">void</a>
<a name="ln239">HaikuControlLook::DrawMenuFieldFrame(BView* view, BRect&amp; rect,</a>
<a name="ln240">	const BRect&amp; updateRect, float leftTopRadius,</a>
<a name="ln241">	float rightTopRadius, float leftBottomRadius,</a>
<a name="ln242">	float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln243">	const rgb_color&amp; background, uint32 flags, uint32 borders)</a>
<a name="ln244">{</a>
<a name="ln245">	_DrawButtonFrame(view, rect, updateRect, leftTopRadius, rightTopRadius,</a>
<a name="ln246">		leftBottomRadius, rightBottomRadius, base, background, 0.6, 1.0,</a>
<a name="ln247">		flags, borders);</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250"> </a>
<a name="ln251">void</a>
<a name="ln252">HaikuControlLook::DrawMenuFieldBackground(BView* view, BRect&amp; rect,</a>
<a name="ln253">	const BRect&amp; updateRect, const rgb_color&amp; base, bool popupIndicator,</a>
<a name="ln254">	uint32 flags)</a>
<a name="ln255">{</a>
<a name="ln256">	_DrawMenuFieldBackgroundOutside(view, rect, updateRect,</a>
<a name="ln257">		0.0f, 0.0f, 0.0f, 0.0f, base, popupIndicator, flags);</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260"> </a>
<a name="ln261">void</a>
<a name="ln262">HaikuControlLook::DrawMenuFieldBackground(BView* view, BRect&amp; rect,</a>
<a name="ln263">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln264">	uint32 borders)</a>
<a name="ln265">{</a>
<a name="ln266">	_DrawMenuFieldBackgroundInside(view, rect, updateRect,</a>
<a name="ln267">		0.0f, 0.0f, 0.0f, 0.0f, base, flags, borders);</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270"> </a>
<a name="ln271">void</a>
<a name="ln272">HaikuControlLook::DrawMenuFieldBackground(BView* view, BRect&amp; rect,</a>
<a name="ln273">	const BRect&amp; updateRect, float radius, const rgb_color&amp; base,</a>
<a name="ln274">	bool popupIndicator, uint32 flags)</a>
<a name="ln275">{</a>
<a name="ln276">	_DrawMenuFieldBackgroundOutside(view, rect, updateRect, radius, radius,</a>
<a name="ln277">		radius, radius, base, popupIndicator, flags);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280"> </a>
<a name="ln281">void</a>
<a name="ln282">HaikuControlLook::DrawMenuFieldBackground(BView* view, BRect&amp; rect,</a>
<a name="ln283">	const BRect&amp; updateRect, float leftTopRadius, float rightTopRadius,</a>
<a name="ln284">	float leftBottomRadius, float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln285">	bool popupIndicator, uint32 flags)</a>
<a name="ln286">{</a>
<a name="ln287">	_DrawMenuFieldBackgroundOutside(view, rect, updateRect, leftTopRadius,</a>
<a name="ln288">		rightTopRadius, leftBottomRadius, rightBottomRadius, base,</a>
<a name="ln289">		popupIndicator, flags);</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292"> </a>
<a name="ln293">void</a>
<a name="ln294">HaikuControlLook::DrawMenuBackground(BView* view, BRect&amp; rect,</a>
<a name="ln295">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln296">	uint32 borders)</a>
<a name="ln297">{</a>
<a name="ln298">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln299">		return;</a>
<a name="ln300"> </a>
<a name="ln301">	// surface top color</a>
<a name="ln302">	rgb_color background = tint_color(base, 0.75);</a>
<a name="ln303"> </a>
<a name="ln304">	// inner bevel colors</a>
<a name="ln305">	rgb_color bevelLightColor;</a>
<a name="ln306">	rgb_color bevelShadowColor;</a>
<a name="ln307"> </a>
<a name="ln308">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln309">		bevelLightColor = tint_color(background, 0.80);</a>
<a name="ln310">		bevelShadowColor = tint_color(background, 1.07);</a>
<a name="ln311">	} else {</a>
<a name="ln312">		bevelLightColor = tint_color(background, 0.6);</a>
<a name="ln313">		bevelShadowColor = tint_color(background, 1.12);</a>
<a name="ln314">	}</a>
<a name="ln315"> </a>
<a name="ln316">	// draw inner bevel</a>
<a name="ln317">	_DrawFrame(view, rect,</a>
<a name="ln318">		bevelLightColor, bevelLightColor,</a>
<a name="ln319">		bevelShadowColor, bevelShadowColor,</a>
<a name="ln320">		borders);</a>
<a name="ln321"> </a>
<a name="ln322">	// draw surface top</a>
<a name="ln323">	view-&gt;SetHighColor(background);</a>
<a name="ln324">	view-&gt;FillRect(rect);</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">void</a>
<a name="ln329">HaikuControlLook::DrawMenuItemBackground(BView* view, BRect&amp; rect,</a>
<a name="ln330">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln331">	uint32 borders)</a>
<a name="ln332">{</a>
<a name="ln333">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln334">		return;</a>
<a name="ln335"> </a>
<a name="ln336">	// surface edges</a>
<a name="ln337">	float topTint;</a>
<a name="ln338">	float bottomTint;</a>
<a name="ln339">	rgb_color selectedColor = base;</a>
<a name="ln340"> </a>
<a name="ln341">	if ((flags &amp; B_ACTIVATED) != 0) {</a>
<a name="ln342">		topTint = 0.9;</a>
<a name="ln343">		bottomTint = 1.05;</a>
<a name="ln344">	} else if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln345">		topTint = 0.80;</a>
<a name="ln346">		bottomTint = 1.07;</a>
<a name="ln347">	} else {</a>
<a name="ln348">		topTint = 0.6;</a>
<a name="ln349">		bottomTint = 1.12;</a>
<a name="ln350">	}</a>
<a name="ln351"> </a>
<a name="ln352">	rgb_color bevelLightColor = tint_color(selectedColor, topTint);</a>
<a name="ln353">	rgb_color bevelShadowColor = tint_color(selectedColor, bottomTint);</a>
<a name="ln354"> </a>
<a name="ln355">	// draw surface edges</a>
<a name="ln356">	_DrawFrame(view, rect,</a>
<a name="ln357">		bevelLightColor, bevelLightColor,</a>
<a name="ln358">		bevelShadowColor, bevelShadowColor,</a>
<a name="ln359">		borders);</a>
<a name="ln360"> </a>
<a name="ln361">	// draw surface top</a>
<a name="ln362">	view-&gt;SetLowColor(selectedColor);</a>
<a name="ln363">//	_FillGradient(view, rect, selectedColor, topTint, bottomTint);</a>
<a name="ln364">	_FillGradient(view, rect, selectedColor, bottomTint, topTint);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368">void</a>
<a name="ln369">HaikuControlLook::DrawStatusBar(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln370">	const rgb_color&amp; base, const rgb_color&amp; barColor, float progressPosition)</a>
<a name="ln371">{</a>
<a name="ln372">	if (!rect.Intersects(updateRect))</a>
<a name="ln373">		return;</a>
<a name="ln374"> </a>
<a name="ln375">	_DrawOuterResessedFrame(view, rect, base, 0.6);</a>
<a name="ln376"> </a>
<a name="ln377">	// colors</a>
<a name="ln378">	rgb_color dark1BorderColor = tint_color(base, 1.3);</a>
<a name="ln379">	rgb_color dark2BorderColor = tint_color(base, 1.2);</a>
<a name="ln380">	rgb_color dark1FilledBorderColor = tint_color(barColor, 1.20);</a>
<a name="ln381">	rgb_color dark2FilledBorderColor = tint_color(barColor, 1.45);</a>
<a name="ln382"> </a>
<a name="ln383">	BRect filledRect(rect);</a>
<a name="ln384">	filledRect.right = progressPosition - 1;</a>
<a name="ln385"> </a>
<a name="ln386">	BRect nonfilledRect(rect);</a>
<a name="ln387">	nonfilledRect.left = progressPosition;</a>
<a name="ln388"> </a>
<a name="ln389">	bool filledSurface = filledRect.Width() &gt; 0;</a>
<a name="ln390">	bool nonfilledSurface = nonfilledRect.Width() &gt; 0;</a>
<a name="ln391"> </a>
<a name="ln392">	if (filledSurface) {</a>
<a name="ln393">		_DrawFrame(view, filledRect,</a>
<a name="ln394">			dark1FilledBorderColor, dark1FilledBorderColor,</a>
<a name="ln395">			dark2FilledBorderColor, dark2FilledBorderColor);</a>
<a name="ln396"> </a>
<a name="ln397">		_FillGlossyGradient(view, filledRect, barColor, 0.55, 0.68, 0.76, 0.90);</a>
<a name="ln398">	}</a>
<a name="ln399"> </a>
<a name="ln400">	if (nonfilledSurface) {</a>
<a name="ln401">		_DrawFrame(view, nonfilledRect, dark1BorderColor, dark1BorderColor,</a>
<a name="ln402">			dark2BorderColor, dark2BorderColor,</a>
<a name="ln403">			B_TOP_BORDER | B_BOTTOM_BORDER | B_RIGHT_BORDER);</a>
<a name="ln404"> </a>
<a name="ln405">		if (nonfilledRect.left &lt; nonfilledRect.right) {</a>
<a name="ln406">			// shadow from fill bar, or left border</a>
<a name="ln407">			rgb_color leftBorder = dark1BorderColor;</a>
<a name="ln408">			if (filledSurface)</a>
<a name="ln409">				leftBorder = tint_color(base, 0.50);</a>
<a name="ln410">			view-&gt;SetHighColor(leftBorder);</a>
<a name="ln411">			view-&gt;StrokeLine(nonfilledRect.LeftTop(),</a>
<a name="ln412">				nonfilledRect.LeftBottom());</a>
<a name="ln413">			nonfilledRect.left++;</a>
<a name="ln414">		}</a>
<a name="ln415"> </a>
<a name="ln416">		_FillGradient(view, nonfilledRect, base, 0.25, 0.06);</a>
<a name="ln417">	}</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420"> </a>
<a name="ln421">void</a>
<a name="ln422">HaikuControlLook::DrawCheckBox(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln423">	const rgb_color&amp; base, uint32 flags)</a>
<a name="ln424">{</a>
<a name="ln425">	if (!rect.Intersects(updateRect))</a>
<a name="ln426">		return;</a>
<a name="ln427"> </a>
<a name="ln428">	rgb_color dark1BorderColor;</a>
<a name="ln429">	rgb_color dark2BorderColor;</a>
<a name="ln430">	rgb_color navigationColor = ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln431"> </a>
<a name="ln432">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln433">		_DrawOuterResessedFrame(view, rect, base, 0.0, 1.0, flags);</a>
<a name="ln434"> </a>
<a name="ln435">		dark1BorderColor = tint_color(base, 1.15);</a>
<a name="ln436">		dark2BorderColor = tint_color(base, 1.15);</a>
<a name="ln437">	} else if ((flags &amp; B_CLICKED) != 0) {</a>
<a name="ln438">		dark1BorderColor = tint_color(base, 1.50);</a>
<a name="ln439">		dark2BorderColor = tint_color(base, 1.48);</a>
<a name="ln440"> </a>
<a name="ln441">		_DrawFrame(view, rect,</a>
<a name="ln442">			dark1BorderColor, dark1BorderColor,</a>
<a name="ln443">			dark2BorderColor, dark2BorderColor);</a>
<a name="ln444"> </a>
<a name="ln445">		dark2BorderColor = dark1BorderColor;</a>
<a name="ln446">	} else {</a>
<a name="ln447">		_DrawOuterResessedFrame(view, rect, base, 0.6, 1.0, flags);</a>
<a name="ln448"> </a>
<a name="ln449">		dark1BorderColor = tint_color(base, 1.40);</a>
<a name="ln450">		dark2BorderColor = tint_color(base, 1.38);</a>
<a name="ln451">	}</a>
<a name="ln452"> </a>
<a name="ln453">	if ((flags &amp; B_FOCUSED) != 0) {</a>
<a name="ln454">		dark1BorderColor = navigationColor;</a>
<a name="ln455">		dark2BorderColor = navigationColor;</a>
<a name="ln456">	}</a>
<a name="ln457"> </a>
<a name="ln458">	_DrawFrame(view, rect,</a>
<a name="ln459">		dark1BorderColor, dark1BorderColor,</a>
<a name="ln460">		dark2BorderColor, dark2BorderColor);</a>
<a name="ln461"> </a>
<a name="ln462">	if ((flags &amp; B_DISABLED) != 0)</a>
<a name="ln463">		_FillGradient(view, rect, base, 0.4, 0.2);</a>
<a name="ln464">	else</a>
<a name="ln465">		_FillGradient(view, rect, base, 0.15, 0.0);</a>
<a name="ln466"> </a>
<a name="ln467">	rgb_color markColor;</a>
<a name="ln468">	if (_RadioButtonAndCheckBoxMarkColor(base, markColor, flags)) {</a>
<a name="ln469">		view-&gt;SetHighColor(markColor);</a>
<a name="ln470"> </a>
<a name="ln471">		BFont font;</a>
<a name="ln472">		view-&gt;GetFont(&amp;font);</a>
<a name="ln473">		float inset = std::max(2.0f, roundf(font.Size() / 6));</a>
<a name="ln474">		rect.InsetBy(inset, inset);</a>
<a name="ln475"> </a>
<a name="ln476">		float penSize = std::max(1.0f, ceilf(rect.Width() / 3.5f));</a>
<a name="ln477">		if (penSize &gt; 1.0f &amp;&amp; fmodf(penSize, 2.0f) == 0.0f) {</a>
<a name="ln478">			// Tweak ends to &quot;include&quot; the pixel at the index,</a>
<a name="ln479">			// we need to do this in order to produce results like R5,</a>
<a name="ln480">			// where coordinates were inclusive</a>
<a name="ln481">			rect.right++;</a>
<a name="ln482">			rect.bottom++;</a>
<a name="ln483">		}</a>
<a name="ln484"> </a>
<a name="ln485">		view-&gt;SetPenSize(penSize);</a>
<a name="ln486">		view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln487">		view-&gt;StrokeLine(rect.LeftTop(), rect.RightBottom());</a>
<a name="ln488">		view-&gt;StrokeLine(rect.LeftBottom(), rect.RightTop());</a>
<a name="ln489">	}</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">void</a>
<a name="ln494">HaikuControlLook::DrawRadioButton(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln495">	const rgb_color&amp; base, uint32 flags)</a>
<a name="ln496">{</a>
<a name="ln497">	if (!rect.Intersects(updateRect))</a>
<a name="ln498">		return;</a>
<a name="ln499"> </a>
<a name="ln500">	rgb_color borderColor;</a>
<a name="ln501">	rgb_color bevelLight;</a>
<a name="ln502">	rgb_color bevelShadow;</a>
<a name="ln503">	rgb_color navigationColor = ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln504"> </a>
<a name="ln505">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln506">		borderColor = tint_color(base, 1.15);</a>
<a name="ln507">		bevelLight = base;</a>
<a name="ln508">		bevelShadow = base;</a>
<a name="ln509">	} else if ((flags &amp; B_CLICKED) != 0) {</a>
<a name="ln510">		borderColor = tint_color(base, 1.50);</a>
<a name="ln511">		bevelLight = borderColor;</a>
<a name="ln512">		bevelShadow = borderColor;</a>
<a name="ln513">	} else {</a>
<a name="ln514">		borderColor = tint_color(base, 1.45);</a>
<a name="ln515">		bevelLight = tint_color(base, 0.55);</a>
<a name="ln516">		bevelShadow = tint_color(base, 1.11);</a>
<a name="ln517">	}</a>
<a name="ln518"> </a>
<a name="ln519">	if ((flags &amp; B_FOCUSED) != 0) {</a>
<a name="ln520">		borderColor = navigationColor;</a>
<a name="ln521">	}</a>
<a name="ln522"> </a>
<a name="ln523">	BGradientLinear bevelGradient;</a>
<a name="ln524">	bevelGradient.AddColor(bevelShadow, 0);</a>
<a name="ln525">	bevelGradient.AddColor(bevelLight, 255);</a>
<a name="ln526">	bevelGradient.SetStart(rect.LeftTop());</a>
<a name="ln527">	bevelGradient.SetEnd(rect.RightBottom());</a>
<a name="ln528"> </a>
<a name="ln529">	view-&gt;FillEllipse(rect, bevelGradient);</a>
<a name="ln530">	rect.InsetBy(1, 1);</a>
<a name="ln531"> </a>
<a name="ln532">	bevelGradient.MakeEmpty();</a>
<a name="ln533">	bevelGradient.AddColor(borderColor, 0);</a>
<a name="ln534">	bevelGradient.AddColor(tint_color(borderColor, 0.8), 255);</a>
<a name="ln535">	view-&gt;FillEllipse(rect, bevelGradient);</a>
<a name="ln536">	rect.InsetBy(1, 1);</a>
<a name="ln537"> </a>
<a name="ln538">	float topTint;</a>
<a name="ln539">	float bottomTint;</a>
<a name="ln540">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln541">		topTint = 0.4;</a>
<a name="ln542">		bottomTint = 0.2;</a>
<a name="ln543">	} else {</a>
<a name="ln544">		topTint = 0.15;</a>
<a name="ln545">		bottomTint = 0.0;</a>
<a name="ln546">	}</a>
<a name="ln547"> </a>
<a name="ln548">	BGradientLinear gradient;</a>
<a name="ln549">	_MakeGradient(gradient, rect, base, topTint, bottomTint);</a>
<a name="ln550">	view-&gt;FillEllipse(rect, gradient);</a>
<a name="ln551"> </a>
<a name="ln552">	rgb_color markColor;</a>
<a name="ln553">	if (_RadioButtonAndCheckBoxMarkColor(base, markColor, flags)) {</a>
<a name="ln554">		view-&gt;SetHighColor(markColor);</a>
<a name="ln555">		BFont font;</a>
<a name="ln556">		view-&gt;GetFont(&amp;font);</a>
<a name="ln557">		float inset = roundf(font.Size() / 4);</a>
<a name="ln558">		rect.InsetBy(inset, inset);</a>
<a name="ln559">		view-&gt;FillEllipse(rect);</a>
<a name="ln560">	}</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563"> </a>
<a name="ln564">void</a>
<a name="ln565">HaikuControlLook::DrawScrollBarBackground(BView* view, BRect&amp; rect1, BRect&amp; rect2,</a>
<a name="ln566">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln567">	orientation orientation)</a>
<a name="ln568">{</a>
<a name="ln569">	DrawScrollBarBackground(view, rect1, updateRect, base, flags, orientation);</a>
<a name="ln570">	DrawScrollBarBackground(view, rect2, updateRect, base, flags, orientation);</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573"> </a>
<a name="ln574">void</a>
<a name="ln575">HaikuControlLook::DrawScrollBarBackground(BView* view, BRect&amp; rect,</a>
<a name="ln576">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln577">	orientation orientation)</a>
<a name="ln578">{</a>
<a name="ln579">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln580">		return;</a>
<a name="ln581"> </a>
<a name="ln582">	float gradient1Tint;</a>
<a name="ln583">	float gradient2Tint;</a>
<a name="ln584">	float darkEdge1Tint;</a>
<a name="ln585">	float darkEdge2Tint;</a>
<a name="ln586">	float shadowTint;</a>
<a name="ln587"> </a>
<a name="ln588">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln589">		gradient1Tint = 0.9;</a>
<a name="ln590">		gradient2Tint = 0.8;</a>
<a name="ln591">		darkEdge1Tint = B_DARKEN_2_TINT;</a>
<a name="ln592">		darkEdge2Tint = B_DARKEN_2_TINT;</a>
<a name="ln593">		shadowTint = gradient1Tint;</a>
<a name="ln594">	} else {</a>
<a name="ln595">		gradient1Tint = 1.10;</a>
<a name="ln596">		gradient2Tint = 1.05;</a>
<a name="ln597">		darkEdge1Tint = B_DARKEN_3_TINT;</a>
<a name="ln598">		darkEdge2Tint = B_DARKEN_2_TINT;</a>
<a name="ln599">		shadowTint = gradient1Tint;</a>
<a name="ln600">	}</a>
<a name="ln601"> </a>
<a name="ln602">	rgb_color darkEdge1 = tint_color(base, darkEdge1Tint);</a>
<a name="ln603">	rgb_color darkEdge2 = tint_color(base, darkEdge2Tint);</a>
<a name="ln604">	rgb_color shadow = tint_color(base, shadowTint);</a>
<a name="ln605"> </a>
<a name="ln606">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln607">		// dark vertical line on left edge</a>
<a name="ln608">		if (rect.Width() &gt; 0) {</a>
<a name="ln609">			view-&gt;SetHighColor(darkEdge1);</a>
<a name="ln610">			view-&gt;StrokeLine(rect.LeftTop(), rect.LeftBottom());</a>
<a name="ln611">			rect.left++;</a>
<a name="ln612">		}</a>
<a name="ln613">		// dark vertical line on right edge</a>
<a name="ln614">		if (rect.Width() &gt;= 0) {</a>
<a name="ln615">			view-&gt;SetHighColor(darkEdge2);</a>
<a name="ln616">			view-&gt;StrokeLine(rect.RightTop(), rect.RightBottom());</a>
<a name="ln617">			rect.right--;</a>
<a name="ln618">		}</a>
<a name="ln619">		// vertical shadow line after left edge</a>
<a name="ln620">		if (rect.Width() &gt;= 0) {</a>
<a name="ln621">			view-&gt;SetHighColor(shadow);</a>
<a name="ln622">			view-&gt;StrokeLine(rect.LeftTop(), rect.LeftBottom());</a>
<a name="ln623">			rect.left++;</a>
<a name="ln624">		}</a>
<a name="ln625">		// fill</a>
<a name="ln626">		if (rect.Width() &gt;= 0) {</a>
<a name="ln627">			_FillGradient(view, rect, base, gradient1Tint, gradient2Tint,</a>
<a name="ln628">				orientation);</a>
<a name="ln629">		}</a>
<a name="ln630">	} else {</a>
<a name="ln631">		// dark vertical line on top edge</a>
<a name="ln632">		if (rect.Height() &gt; 0) {</a>
<a name="ln633">			view-&gt;SetHighColor(darkEdge1);</a>
<a name="ln634">			view-&gt;StrokeLine(rect.LeftTop(), rect.RightTop());</a>
<a name="ln635">			rect.top++;</a>
<a name="ln636">		}</a>
<a name="ln637">		// dark vertical line on bottom edge</a>
<a name="ln638">		if (rect.Height() &gt;= 0) {</a>
<a name="ln639">			view-&gt;SetHighColor(darkEdge2);</a>
<a name="ln640">			view-&gt;StrokeLine(rect.LeftBottom(), rect.RightBottom());</a>
<a name="ln641">			rect.bottom--;</a>
<a name="ln642">		}</a>
<a name="ln643">		// horizontal shadow line after top edge</a>
<a name="ln644">		if (rect.Height() &gt;= 0) {</a>
<a name="ln645">			view-&gt;SetHighColor(shadow);</a>
<a name="ln646">			view-&gt;StrokeLine(rect.LeftTop(), rect.RightTop());</a>
<a name="ln647">			rect.top++;</a>
<a name="ln648">		}</a>
<a name="ln649">		// fill</a>
<a name="ln650">		if (rect.Height() &gt;= 0) {</a>
<a name="ln651">			_FillGradient(view, rect, base, gradient1Tint, gradient2Tint,</a>
<a name="ln652">				orientation);</a>
<a name="ln653">		}</a>
<a name="ln654">	}</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657"> </a>
<a name="ln658">void</a>
<a name="ln659">HaikuControlLook::DrawScrollViewFrame(BView* view, BRect&amp; rect,</a>
<a name="ln660">	const BRect&amp; updateRect, BRect verticalScrollBarFrame,</a>
<a name="ln661">	BRect horizontalScrollBarFrame, const rgb_color&amp; base,</a>
<a name="ln662">	border_style borderStyle, uint32 flags, uint32 _borders)</a>
<a name="ln663">{</a>
<a name="ln664">	// calculate scroll corner rect before messing with the &quot;rect&quot;</a>
<a name="ln665">	BRect scrollCornerFillRect(rect.right, rect.bottom,</a>
<a name="ln666">		rect.right, rect.bottom);</a>
<a name="ln667"> </a>
<a name="ln668">	if (horizontalScrollBarFrame.IsValid())</a>
<a name="ln669">		scrollCornerFillRect.left = horizontalScrollBarFrame.right + 1;</a>
<a name="ln670"> </a>
<a name="ln671">	if (verticalScrollBarFrame.IsValid())</a>
<a name="ln672">		scrollCornerFillRect.top = verticalScrollBarFrame.bottom + 1;</a>
<a name="ln673"> </a>
<a name="ln674">	if (borderStyle == B_NO_BORDER) {</a>
<a name="ln675">		if (scrollCornerFillRect.IsValid()) {</a>
<a name="ln676">			view-&gt;SetHighColor(base);</a>
<a name="ln677">			view-&gt;FillRect(scrollCornerFillRect);</a>
<a name="ln678">		}</a>
<a name="ln679">		return;</a>
<a name="ln680">	}</a>
<a name="ln681"> </a>
<a name="ln682">	bool excludeScrollCorner = borderStyle == B_FANCY_BORDER</a>
<a name="ln683">		&amp;&amp; horizontalScrollBarFrame.IsValid()</a>
<a name="ln684">		&amp;&amp; verticalScrollBarFrame.IsValid();</a>
<a name="ln685"> </a>
<a name="ln686">	uint32 borders = _borders;</a>
<a name="ln687">	if (excludeScrollCorner) {</a>
<a name="ln688">		rect.bottom = horizontalScrollBarFrame.top;</a>
<a name="ln689">		rect.right = verticalScrollBarFrame.left;</a>
<a name="ln690">		borders &amp;= ~(B_RIGHT_BORDER | B_BOTTOM_BORDER);</a>
<a name="ln691">	}</a>
<a name="ln692"> </a>
<a name="ln693">	rgb_color scrollbarFrameColor = tint_color(base, B_DARKEN_2_TINT);</a>
<a name="ln694"> </a>
<a name="ln695">	if (borderStyle == B_FANCY_BORDER)</a>
<a name="ln696">		_DrawOuterResessedFrame(view, rect, base, 1.0, 1.0, flags, borders);</a>
<a name="ln697"> </a>
<a name="ln698">	if ((flags &amp; B_FOCUSED) != 0) {</a>
<a name="ln699">		rgb_color focusColor = ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln700">		_DrawFrame(view, rect, focusColor, focusColor, focusColor, focusColor,</a>
<a name="ln701">			borders);</a>
<a name="ln702">	} else {</a>
<a name="ln703">		_DrawFrame(view, rect, scrollbarFrameColor, scrollbarFrameColor,</a>
<a name="ln704">			scrollbarFrameColor, scrollbarFrameColor, borders);</a>
<a name="ln705">	}</a>
<a name="ln706"> </a>
<a name="ln707">	if (excludeScrollCorner) {</a>
<a name="ln708">		horizontalScrollBarFrame.InsetBy(-1, -1);</a>
<a name="ln709">		// do not overdraw the top edge</a>
<a name="ln710">		horizontalScrollBarFrame.top += 2;</a>
<a name="ln711">		borders = _borders;</a>
<a name="ln712">		borders &amp;= ~B_TOP_BORDER;</a>
<a name="ln713">		_DrawOuterResessedFrame(view, horizontalScrollBarFrame, base,</a>
<a name="ln714">			1.0, 1.0, flags, borders);</a>
<a name="ln715">		_DrawFrame(view, horizontalScrollBarFrame, scrollbarFrameColor,</a>
<a name="ln716">			scrollbarFrameColor, scrollbarFrameColor, scrollbarFrameColor,</a>
<a name="ln717">			borders);</a>
<a name="ln718"> </a>
<a name="ln719">		verticalScrollBarFrame.InsetBy(-1, -1);</a>
<a name="ln720">		// do not overdraw the left edge</a>
<a name="ln721">		verticalScrollBarFrame.left += 2;</a>
<a name="ln722">		borders = _borders;</a>
<a name="ln723">		borders &amp;= ~B_LEFT_BORDER;</a>
<a name="ln724">		_DrawOuterResessedFrame(view, verticalScrollBarFrame, base,</a>
<a name="ln725">			1.0, 1.0, flags, borders);</a>
<a name="ln726">		_DrawFrame(view, verticalScrollBarFrame, scrollbarFrameColor,</a>
<a name="ln727">			scrollbarFrameColor, scrollbarFrameColor, scrollbarFrameColor,</a>
<a name="ln728">			borders);</a>
<a name="ln729"> </a>
<a name="ln730">		// exclude recessed frame</a>
<a name="ln731">		scrollCornerFillRect.top++;</a>
<a name="ln732">		scrollCornerFillRect.left++;</a>
<a name="ln733">	}</a>
<a name="ln734"> </a>
<a name="ln735">	if (scrollCornerFillRect.IsValid()) {</a>
<a name="ln736">		view-&gt;SetHighColor(base);</a>
<a name="ln737">		view-&gt;FillRect(scrollCornerFillRect);</a>
<a name="ln738">	}</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741"> </a>
<a name="ln742">void</a>
<a name="ln743">HaikuControlLook::DrawArrowShape(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln744">	const rgb_color&amp; base, uint32 direction, uint32 flags, float tint)</a>
<a name="ln745">{</a>
<a name="ln746">	BPoint tri1, tri2, tri3;</a>
<a name="ln747">	float hInset = rect.Width() / 3;</a>
<a name="ln748">	float vInset = rect.Height() / 3;</a>
<a name="ln749">	rect.InsetBy(hInset, vInset);</a>
<a name="ln750"> </a>
<a name="ln751">	switch (direction) {</a>
<a name="ln752">		case B_LEFT_ARROW:</a>
<a name="ln753">			tri1.Set(rect.right, rect.top);</a>
<a name="ln754">			tri2.Set(rect.right - rect.Width() / 1.33,</a>
<a name="ln755">				(rect.top + rect.bottom + 1) / 2);</a>
<a name="ln756">			tri3.Set(rect.right, rect.bottom + 1);</a>
<a name="ln757">			break;</a>
<a name="ln758">		case B_RIGHT_ARROW:</a>
<a name="ln759">			tri1.Set(rect.left + 1, rect.bottom + 1);</a>
<a name="ln760">			tri2.Set(rect.left + 1 + rect.Width() / 1.33,</a>
<a name="ln761">				(rect.top + rect.bottom + 1) / 2);</a>
<a name="ln762">			tri3.Set(rect.left + 1, rect.top);</a>
<a name="ln763">			break;</a>
<a name="ln764">		case B_UP_ARROW:</a>
<a name="ln765">			tri1.Set(rect.left, rect.bottom);</a>
<a name="ln766">			tri2.Set((rect.left + rect.right + 1) / 2,</a>
<a name="ln767">				rect.bottom - rect.Height() / 1.33);</a>
<a name="ln768">			tri3.Set(rect.right + 1, rect.bottom);</a>
<a name="ln769">			break;</a>
<a name="ln770">		case B_DOWN_ARROW:</a>
<a name="ln771">		default:</a>
<a name="ln772">			tri1.Set(rect.left, rect.top + 1);</a>
<a name="ln773">			tri2.Set((rect.left + rect.right + 1) / 2,</a>
<a name="ln774">				rect.top + 1 + rect.Height() / 1.33);</a>
<a name="ln775">			tri3.Set(rect.right + 1, rect.top + 1);</a>
<a name="ln776">			break;</a>
<a name="ln777">		case B_LEFT_UP_ARROW:</a>
<a name="ln778">			tri1.Set(rect.left, rect.bottom);</a>
<a name="ln779">			tri2.Set(rect.left, rect.top);</a>
<a name="ln780">			tri3.Set(rect.right - 1, rect.top);</a>
<a name="ln781">			break;</a>
<a name="ln782">		case B_RIGHT_UP_ARROW:</a>
<a name="ln783">			tri1.Set(rect.left + 1, rect.top);</a>
<a name="ln784">			tri2.Set(rect.right, rect.top);</a>
<a name="ln785">			tri3.Set(rect.right, rect.bottom);</a>
<a name="ln786">			break;</a>
<a name="ln787">		case B_RIGHT_DOWN_ARROW:</a>
<a name="ln788">			tri1.Set(rect.right, rect.top);</a>
<a name="ln789">			tri2.Set(rect.right, rect.bottom);</a>
<a name="ln790">			tri3.Set(rect.left + 1, rect.bottom);</a>
<a name="ln791">			break;</a>
<a name="ln792">		case B_LEFT_DOWN_ARROW:</a>
<a name="ln793">			tri1.Set(rect.right - 1, rect.bottom);</a>
<a name="ln794">			tri2.Set(rect.left, rect.bottom);</a>
<a name="ln795">			tri3.Set(rect.left, rect.top);</a>
<a name="ln796">			break;</a>
<a name="ln797">	}</a>
<a name="ln798"> </a>
<a name="ln799">	BShape arrowShape;</a>
<a name="ln800">	arrowShape.MoveTo(tri1);</a>
<a name="ln801">	arrowShape.LineTo(tri2);</a>
<a name="ln802">	arrowShape.LineTo(tri3);</a>
<a name="ln803"> </a>
<a name="ln804">	if ((flags &amp; B_DISABLED) != 0)</a>
<a name="ln805">		tint = (tint + B_NO_TINT + B_NO_TINT) / 3;</a>
<a name="ln806"> </a>
<a name="ln807">	view-&gt;SetHighColor(tint_color(base, tint));</a>
<a name="ln808"> </a>
<a name="ln809">	float penSize = view-&gt;PenSize();</a>
<a name="ln810">	drawing_mode mode = view-&gt;DrawingMode();</a>
<a name="ln811"> </a>
<a name="ln812">	view-&gt;MovePenTo(BPoint(0, 0));</a>
<a name="ln813"> </a>
<a name="ln814">	view-&gt;SetPenSize(ceilf(hInset / 2.0));</a>
<a name="ln815">	view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln816">	view-&gt;StrokeShape(&amp;arrowShape);</a>
<a name="ln817"> </a>
<a name="ln818">	view-&gt;SetPenSize(penSize);</a>
<a name="ln819">	view-&gt;SetDrawingMode(mode);</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822"> </a>
<a name="ln823">rgb_color</a>
<a name="ln824">HaikuControlLook::SliderBarColor(const rgb_color&amp; base)</a>
<a name="ln825">{</a>
<a name="ln826">	return tint_color(ui_color(B_PANEL_BACKGROUND_COLOR), B_DARKEN_1_TINT);</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829"> </a>
<a name="ln830">void</a>
<a name="ln831">HaikuControlLook::DrawSliderBar(BView* view, BRect rect, const BRect&amp; updateRect,</a>
<a name="ln832">	const rgb_color&amp; base, rgb_color leftFillColor, rgb_color rightFillColor,</a>
<a name="ln833">	float sliderScale, uint32 flags, orientation orientation)</a>
<a name="ln834">{</a>
<a name="ln835">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln836">		return;</a>
<a name="ln837"> </a>
<a name="ln838">	// save the clipping constraints of the view</a>
<a name="ln839">	view-&gt;PushState();</a>
<a name="ln840"> </a>
<a name="ln841">	// separate the bar in two sides</a>
<a name="ln842">	float sliderPosition;</a>
<a name="ln843">	BRect leftBarSide = rect;</a>
<a name="ln844">	BRect rightBarSide = rect;</a>
<a name="ln845"> </a>
<a name="ln846">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln847">		sliderPosition = floorf(rect.left + 2 + (rect.Width() - 2)</a>
<a name="ln848">			* sliderScale);</a>
<a name="ln849">		leftBarSide.right = sliderPosition - 1;</a>
<a name="ln850">		rightBarSide.left = sliderPosition;</a>
<a name="ln851">	} else {</a>
<a name="ln852">		// NOTE: position is reverse of coords</a>
<a name="ln853">		sliderPosition = floorf(rect.top + 2 + (rect.Height() - 2)</a>
<a name="ln854">			* (1.0 - sliderScale));</a>
<a name="ln855">		leftBarSide.top = sliderPosition;</a>
<a name="ln856">		rightBarSide.bottom = sliderPosition - 1;</a>
<a name="ln857">	}</a>
<a name="ln858"> </a>
<a name="ln859">	// fill the background for the corners, exclude the middle bar for now</a>
<a name="ln860">	BRegion region(rect);</a>
<a name="ln861">	region.Exclude(rightBarSide);</a>
<a name="ln862">	view-&gt;ConstrainClippingRegion(&amp;region);</a>
<a name="ln863"> </a>
<a name="ln864">	view-&gt;PushState();</a>
<a name="ln865"> </a>
<a name="ln866">	DrawSliderBar(view, rect, updateRect, base, leftFillColor, flags,</a>
<a name="ln867">		orientation);</a>
<a name="ln868"> </a>
<a name="ln869">	view-&gt;PopState();</a>
<a name="ln870"> </a>
<a name="ln871">	region.Set(rect);</a>
<a name="ln872">	region.Exclude(leftBarSide);</a>
<a name="ln873">	view-&gt;ConstrainClippingRegion(&amp;region);</a>
<a name="ln874"> </a>
<a name="ln875">	view-&gt;PushState();</a>
<a name="ln876"> </a>
<a name="ln877">	DrawSliderBar(view, rect, updateRect, base, rightFillColor, flags,</a>
<a name="ln878">		orientation);</a>
<a name="ln879"> </a>
<a name="ln880">	view-&gt;PopState();</a>
<a name="ln881"> </a>
<a name="ln882">	// restore the clipping constraints of the view</a>
<a name="ln883">	view-&gt;PopState();</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886"> </a>
<a name="ln887">void</a>
<a name="ln888">HaikuControlLook::DrawSliderBar(BView* view, BRect rect, const BRect&amp; updateRect,</a>
<a name="ln889">	const rgb_color&amp; base, rgb_color fillColor, uint32 flags,</a>
<a name="ln890">	orientation orientation)</a>
<a name="ln891">{</a>
<a name="ln892">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln893">		return;</a>
<a name="ln894"> </a>
<a name="ln895">	// separate the rect into corners</a>
<a name="ln896">	BRect leftCorner(rect);</a>
<a name="ln897">	BRect rightCorner(rect);</a>
<a name="ln898">	BRect barRect(rect);</a>
<a name="ln899"> </a>
<a name="ln900">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln901">		leftCorner.right = leftCorner.left + leftCorner.Height();</a>
<a name="ln902">		rightCorner.left = rightCorner.right - rightCorner.Height();</a>
<a name="ln903">		barRect.left += ceilf(barRect.Height() / 2);</a>
<a name="ln904">		barRect.right -= ceilf(barRect.Height() / 2);</a>
<a name="ln905">	} else {</a>
<a name="ln906">		leftCorner.bottom = leftCorner.top + leftCorner.Width();</a>
<a name="ln907">		rightCorner.top = rightCorner.bottom - rightCorner.Width();</a>
<a name="ln908">		barRect.top += ceilf(barRect.Width() / 2);</a>
<a name="ln909">		barRect.bottom -= ceilf(barRect.Width() / 2);</a>
<a name="ln910">	}</a>
<a name="ln911"> </a>
<a name="ln912">	// fill the background for the corners, exclude the middle bar for now</a>
<a name="ln913">	BRegion region(rect);</a>
<a name="ln914">	region.Exclude(barRect);</a>
<a name="ln915">	view-&gt;ConstrainClippingRegion(&amp;region);</a>
<a name="ln916"> </a>
<a name="ln917">	if ((flags &amp; B_BLEND_FRAME) == 0) {</a>
<a name="ln918">		view-&gt;SetHighColor(base);</a>
<a name="ln919">		view-&gt;FillRect(rect);</a>
<a name="ln920">	}</a>
<a name="ln921"> </a>
<a name="ln922">	// figure out the tints to be used</a>
<a name="ln923">	float edgeLightTint;</a>
<a name="ln924">	float edgeShadowTint;</a>
<a name="ln925">	float frameLightTint;</a>
<a name="ln926">	float frameShadowTint;</a>
<a name="ln927">	float fillLightTint;</a>
<a name="ln928">	float fillShadowTint;</a>
<a name="ln929">	uint8 edgeLightAlpha;</a>
<a name="ln930">	uint8 edgeShadowAlpha;</a>
<a name="ln931">	uint8 frameLightAlpha;</a>
<a name="ln932">	uint8 frameShadowAlpha;</a>
<a name="ln933"> </a>
<a name="ln934">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln935">		edgeLightTint = 1.0;</a>
<a name="ln936">		edgeShadowTint = 1.0;</a>
<a name="ln937">		frameLightTint = 1.20;</a>
<a name="ln938">		frameShadowTint = 1.25;</a>
<a name="ln939">		fillLightTint = 0.9;</a>
<a name="ln940">		fillShadowTint = 1.05;</a>
<a name="ln941">		edgeLightAlpha = 12;</a>
<a name="ln942">		edgeShadowAlpha = 12;</a>
<a name="ln943">		frameLightAlpha = 40;</a>
<a name="ln944">		frameShadowAlpha = 45;</a>
<a name="ln945"> </a>
<a name="ln946">		fillColor.red = uint8(fillColor.red * 0.4 + base.red * 0.6);</a>
<a name="ln947">		fillColor.green = uint8(fillColor.green * 0.4 + base.green * 0.6);</a>
<a name="ln948">		fillColor.blue = uint8(fillColor.blue * 0.4 + base.blue * 0.6);</a>
<a name="ln949">	} else {</a>
<a name="ln950">		edgeLightTint = 0.65;</a>
<a name="ln951">		edgeShadowTint = 1.07;</a>
<a name="ln952">		frameLightTint = 1.40;</a>
<a name="ln953">		frameShadowTint = 1.50;</a>
<a name="ln954">		fillLightTint = 0.8;</a>
<a name="ln955">		fillShadowTint = 1.1;</a>
<a name="ln956">		edgeLightAlpha = 15;</a>
<a name="ln957">		edgeShadowAlpha = 15;</a>
<a name="ln958">		frameLightAlpha = 92;</a>
<a name="ln959">		frameShadowAlpha = 107;</a>
<a name="ln960">	}</a>
<a name="ln961"> </a>
<a name="ln962">	rgb_color edgeLightColor;</a>
<a name="ln963">	rgb_color edgeShadowColor;</a>
<a name="ln964">	rgb_color frameLightColor;</a>
<a name="ln965">	rgb_color frameShadowColor;</a>
<a name="ln966">	rgb_color fillLightColor = tint_color(fillColor, fillLightTint);</a>
<a name="ln967">	rgb_color fillShadowColor = tint_color(fillColor, fillShadowTint);</a>
<a name="ln968"> </a>
<a name="ln969">	drawing_mode oldMode = view-&gt;DrawingMode();</a>
<a name="ln970"> </a>
<a name="ln971">	if ((flags &amp; B_BLEND_FRAME) != 0) {</a>
<a name="ln972">		edgeLightColor = (rgb_color){ 255, 255, 255, edgeLightAlpha };</a>
<a name="ln973">		edgeShadowColor = (rgb_color){ 0, 0, 0, edgeShadowAlpha };</a>
<a name="ln974">		frameLightColor = (rgb_color){ 0, 0, 0, frameLightAlpha };</a>
<a name="ln975">		frameShadowColor = (rgb_color){ 0, 0, 0, frameShadowAlpha };</a>
<a name="ln976"> </a>
<a name="ln977">		view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln978">	} else {</a>
<a name="ln979">		edgeLightColor = tint_color(base, edgeLightTint);</a>
<a name="ln980">		edgeShadowColor = tint_color(base, edgeShadowTint);</a>
<a name="ln981">		frameLightColor = tint_color(fillColor, frameLightTint);</a>
<a name="ln982">		frameShadowColor = tint_color(fillColor, frameShadowTint);</a>
<a name="ln983">	}</a>
<a name="ln984"> </a>
<a name="ln985">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln986">		_DrawRoundBarCorner(view, leftCorner, updateRect, edgeLightColor,</a>
<a name="ln987">			edgeShadowColor, frameLightColor, frameShadowColor, fillLightColor,</a>
<a name="ln988">			fillShadowColor, 1.0, 1.0, 0.0, -1.0, orientation);</a>
<a name="ln989"> </a>
<a name="ln990">		_DrawRoundBarCorner(view, rightCorner, updateRect, edgeLightColor,</a>
<a name="ln991">			edgeShadowColor, frameLightColor, frameShadowColor, fillLightColor,</a>
<a name="ln992">			fillShadowColor, 0.0, 1.0, -1.0, -1.0, orientation);</a>
<a name="ln993">	} else {</a>
<a name="ln994">		_DrawRoundBarCorner(view, leftCorner, updateRect, edgeLightColor,</a>
<a name="ln995">			edgeShadowColor, frameLightColor, frameShadowColor, fillLightColor,</a>
<a name="ln996">			fillShadowColor, 1.0, 1.0, -1.0, 0.0, orientation);</a>
<a name="ln997"> </a>
<a name="ln998">		_DrawRoundBarCorner(view, rightCorner, updateRect, edgeLightColor,</a>
<a name="ln999">			edgeShadowColor, frameLightColor, frameShadowColor, fillLightColor,</a>
<a name="ln1000">			fillShadowColor, 1.0, 0.0, -1.0, -1.0, orientation);</a>
<a name="ln1001">	}</a>
<a name="ln1002"> </a>
<a name="ln1003">	view-&gt;ConstrainClippingRegion(NULL);</a>
<a name="ln1004"> </a>
<a name="ln1005">	view-&gt;BeginLineArray(4);</a>
<a name="ln1006">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln1007">		view-&gt;AddLine(barRect.LeftTop(), barRect.RightTop(), edgeShadowColor);</a>
<a name="ln1008">		view-&gt;AddLine(barRect.LeftBottom(), barRect.RightBottom(),</a>
<a name="ln1009">			edgeLightColor);</a>
<a name="ln1010">		barRect.InsetBy(0, 1);</a>
<a name="ln1011">		view-&gt;AddLine(barRect.LeftTop(), barRect.RightTop(), frameShadowColor);</a>
<a name="ln1012">		view-&gt;AddLine(barRect.LeftBottom(), barRect.RightBottom(),</a>
<a name="ln1013">			frameLightColor);</a>
<a name="ln1014">		barRect.InsetBy(0, 1);</a>
<a name="ln1015">	} else {</a>
<a name="ln1016">		view-&gt;AddLine(barRect.LeftTop(), barRect.LeftBottom(), edgeShadowColor);</a>
<a name="ln1017">		view-&gt;AddLine(barRect.RightTop(), barRect.RightBottom(),</a>
<a name="ln1018">			edgeLightColor);</a>
<a name="ln1019">		barRect.InsetBy(1, 0);</a>
<a name="ln1020">		view-&gt;AddLine(barRect.LeftTop(), barRect.LeftBottom(), frameShadowColor);</a>
<a name="ln1021">		view-&gt;AddLine(barRect.RightTop(), barRect.RightBottom(),</a>
<a name="ln1022">			frameLightColor);</a>
<a name="ln1023">		barRect.InsetBy(1, 0);</a>
<a name="ln1024">	}</a>
<a name="ln1025">	view-&gt;EndLineArray();</a>
<a name="ln1026"> </a>
<a name="ln1027">	view-&gt;SetDrawingMode(oldMode);</a>
<a name="ln1028"> </a>
<a name="ln1029">	_FillGradient(view, barRect, fillColor, fillShadowTint, fillLightTint,</a>
<a name="ln1030">		orientation);</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033"> </a>
<a name="ln1034">void</a>
<a name="ln1035">HaikuControlLook::DrawSliderThumb(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln1036">	const rgb_color&amp; base, uint32 flags, orientation orientation)</a>
<a name="ln1037">{</a>
<a name="ln1038">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln1039">		return;</a>
<a name="ln1040"> </a>
<a name="ln1041">	// figure out frame color</a>
<a name="ln1042">	rgb_color frameLightColor;</a>
<a name="ln1043">	rgb_color frameShadowColor;</a>
<a name="ln1044">	rgb_color shadowColor = (rgb_color){ 0, 0, 0, 60 };</a>
<a name="ln1045"> </a>
<a name="ln1046">	if ((flags &amp; B_FOCUSED) != 0) {</a>
<a name="ln1047">		// focused</a>
<a name="ln1048">		frameLightColor = ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln1049">		frameShadowColor = frameLightColor;</a>
<a name="ln1050">	} else {</a>
<a name="ln1051">		// figure out the tints to be used</a>
<a name="ln1052">		float frameLightTint;</a>
<a name="ln1053">		float frameShadowTint;</a>
<a name="ln1054"> </a>
<a name="ln1055">		if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1056">			frameLightTint = 1.30;</a>
<a name="ln1057">			frameShadowTint = 1.35;</a>
<a name="ln1058">			shadowColor.alpha = 30;</a>
<a name="ln1059">		} else {</a>
<a name="ln1060">			frameLightTint = 1.6;</a>
<a name="ln1061">			frameShadowTint = 1.65;</a>
<a name="ln1062">		}</a>
<a name="ln1063"> </a>
<a name="ln1064">		frameLightColor = tint_color(base, frameLightTint);</a>
<a name="ln1065">		frameShadowColor = tint_color(base, frameShadowTint);</a>
<a name="ln1066">	}</a>
<a name="ln1067"> </a>
<a name="ln1068">	BRect originalRect(rect);</a>
<a name="ln1069">	rect.right--;</a>
<a name="ln1070">	rect.bottom--;</a>
<a name="ln1071"> </a>
<a name="ln1072">	_DrawFrame(view, rect, frameLightColor, frameLightColor,</a>
<a name="ln1073">		frameShadowColor, frameShadowColor);</a>
<a name="ln1074"> </a>
<a name="ln1075">	flags &amp;= ~B_ACTIVATED;</a>
<a name="ln1076">	DrawButtonBackground(view, rect, updateRect, base, flags);</a>
<a name="ln1077"> </a>
<a name="ln1078">	// thumb shadow</a>
<a name="ln1079">	view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln1080">	view-&gt;SetHighColor(shadowColor);</a>
<a name="ln1081">	originalRect.left++;</a>
<a name="ln1082">	originalRect.top++;</a>
<a name="ln1083">	view-&gt;StrokeLine(originalRect.LeftBottom(), originalRect.RightBottom());</a>
<a name="ln1084">	originalRect.bottom--;</a>
<a name="ln1085">	view-&gt;StrokeLine(originalRect.RightTop(), originalRect.RightBottom());</a>
<a name="ln1086"> </a>
<a name="ln1087">	// thumb edge</a>
<a name="ln1088">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln1089">		rect.InsetBy(0, floorf(rect.Height() / 4));</a>
<a name="ln1090">		rect.left = floorf((rect.left + rect.right) / 2);</a>
<a name="ln1091">		rect.right = rect.left + 1;</a>
<a name="ln1092">		shadowColor = tint_color(base, B_DARKEN_2_TINT);</a>
<a name="ln1093">		shadowColor.alpha = 128;</a>
<a name="ln1094">		view-&gt;SetHighColor(shadowColor);</a>
<a name="ln1095">		view-&gt;StrokeLine(rect.LeftTop(), rect.LeftBottom());</a>
<a name="ln1096">		rgb_color lightColor = tint_color(base, B_LIGHTEN_2_TINT);</a>
<a name="ln1097">		lightColor.alpha = 128;</a>
<a name="ln1098">		view-&gt;SetHighColor(lightColor);</a>
<a name="ln1099">		view-&gt;StrokeLine(rect.RightTop(), rect.RightBottom());</a>
<a name="ln1100">	} else {</a>
<a name="ln1101">		rect.InsetBy(floorf(rect.Width() / 4), 0);</a>
<a name="ln1102">		rect.top = floorf((rect.top + rect.bottom) / 2);</a>
<a name="ln1103">		rect.bottom = rect.top + 1;</a>
<a name="ln1104">		shadowColor = tint_color(base, B_DARKEN_2_TINT);</a>
<a name="ln1105">		shadowColor.alpha = 128;</a>
<a name="ln1106">		view-&gt;SetHighColor(shadowColor);</a>
<a name="ln1107">		view-&gt;StrokeLine(rect.LeftTop(), rect.RightTop());</a>
<a name="ln1108">		rgb_color lightColor = tint_color(base, B_LIGHTEN_2_TINT);</a>
<a name="ln1109">		lightColor.alpha = 128;</a>
<a name="ln1110">		view-&gt;SetHighColor(lightColor);</a>
<a name="ln1111">		view-&gt;StrokeLine(rect.LeftBottom(), rect.RightBottom());</a>
<a name="ln1112">	}</a>
<a name="ln1113"> </a>
<a name="ln1114">	view-&gt;SetDrawingMode(B_OP_COPY);</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117"> </a>
<a name="ln1118">void</a>
<a name="ln1119">HaikuControlLook::DrawSliderTriangle(BView* view, BRect&amp; rect,</a>
<a name="ln1120">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln1121">	orientation orientation)</a>
<a name="ln1122">{</a>
<a name="ln1123">	DrawSliderTriangle(view, rect, updateRect, base, base, flags, orientation);</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126"> </a>
<a name="ln1127">void</a>
<a name="ln1128">HaikuControlLook::DrawSliderTriangle(BView* view, BRect&amp; rect,</a>
<a name="ln1129">	const BRect&amp; updateRect, const rgb_color&amp; base, const rgb_color&amp; fill,</a>
<a name="ln1130">	uint32 flags, orientation orientation)</a>
<a name="ln1131">{</a>
<a name="ln1132">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln1133">		return;</a>
<a name="ln1134"> </a>
<a name="ln1135">	// figure out frame color</a>
<a name="ln1136">	rgb_color frameLightColor;</a>
<a name="ln1137">	rgb_color frameShadowColor;</a>
<a name="ln1138">	rgb_color shadowColor = (rgb_color){ 0, 0, 0, 60 };</a>
<a name="ln1139"> </a>
<a name="ln1140">	float topTint = 0.49;</a>
<a name="ln1141">	float middleTint1 = 0.62;</a>
<a name="ln1142">	float middleTint2 = 0.76;</a>
<a name="ln1143">	float bottomTint = 0.90;</a>
<a name="ln1144"> </a>
<a name="ln1145">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1146">		topTint = (topTint + B_NO_TINT) / 2;</a>
<a name="ln1147">		middleTint1 = (middleTint1 + B_NO_TINT) / 2;</a>
<a name="ln1148">		middleTint2 = (middleTint2 + B_NO_TINT) / 2;</a>
<a name="ln1149">		bottomTint = (bottomTint + B_NO_TINT) / 2;</a>
<a name="ln1150">	} else if ((flags &amp; B_HOVER) != 0) {</a>
<a name="ln1151">		topTint *= kHoverTintFactor;</a>
<a name="ln1152">		middleTint1 *= kHoverTintFactor;</a>
<a name="ln1153">		middleTint2 *= kHoverTintFactor;</a>
<a name="ln1154">		bottomTint *= kHoverTintFactor;</a>
<a name="ln1155">	}</a>
<a name="ln1156"> </a>
<a name="ln1157">	if ((flags &amp; B_FOCUSED) != 0) {</a>
<a name="ln1158">		// focused</a>
<a name="ln1159">		frameLightColor = ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln1160">		frameShadowColor = frameLightColor;</a>
<a name="ln1161">	} else {</a>
<a name="ln1162">		// figure out the tints to be used</a>
<a name="ln1163">		float frameLightTint;</a>
<a name="ln1164">		float frameShadowTint;</a>
<a name="ln1165"> </a>
<a name="ln1166">		if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1167">			frameLightTint = 1.30;</a>
<a name="ln1168">			frameShadowTint = 1.35;</a>
<a name="ln1169">			shadowColor.alpha = 30;</a>
<a name="ln1170">		} else {</a>
<a name="ln1171">			frameLightTint = 1.6;</a>
<a name="ln1172">			frameShadowTint = 1.65;</a>
<a name="ln1173">		}</a>
<a name="ln1174"> </a>
<a name="ln1175">		frameLightColor = tint_color(base, frameLightTint);</a>
<a name="ln1176">		frameShadowColor = tint_color(base, frameShadowTint);</a>
<a name="ln1177">	}</a>
<a name="ln1178"> </a>
<a name="ln1179">	// make room for the shadow</a>
<a name="ln1180">	rect.right--;</a>
<a name="ln1181">	rect.bottom--;</a>
<a name="ln1182"> </a>
<a name="ln1183">	uint32 viewFlags = view-&gt;Flags();</a>
<a name="ln1184">	view-&gt;SetFlags(viewFlags | B_SUBPIXEL_PRECISE);</a>
<a name="ln1185">	view-&gt;SetLineMode(B_ROUND_CAP, B_ROUND_JOIN);</a>
<a name="ln1186"> </a>
<a name="ln1187">	float centerh = (rect.left + rect.right) / 2;</a>
<a name="ln1188">	float centerv = (rect.top + rect.bottom) / 2;</a>
<a name="ln1189"> </a>
<a name="ln1190">	BShape shape;</a>
<a name="ln1191">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln1192">		shape.MoveTo(BPoint(rect.left + 0.5, rect.bottom + 0.5));</a>
<a name="ln1193">		shape.LineTo(BPoint(rect.right + 0.5, rect.bottom + 0.5));</a>
<a name="ln1194">		shape.LineTo(BPoint(rect.right + 0.5, rect.bottom - 1 + 0.5));</a>
<a name="ln1195">		shape.LineTo(BPoint(centerh + 0.5, rect.top + 0.5));</a>
<a name="ln1196">		shape.LineTo(BPoint(rect.left + 0.5, rect.bottom - 1 + 0.5));</a>
<a name="ln1197">	} else {</a>
<a name="ln1198">		shape.MoveTo(BPoint(rect.right + 0.5, rect.top + 0.5));</a>
<a name="ln1199">		shape.LineTo(BPoint(rect.right + 0.5, rect.bottom + 0.5));</a>
<a name="ln1200">		shape.LineTo(BPoint(rect.right - 1 + 0.5, rect.bottom + 0.5));</a>
<a name="ln1201">		shape.LineTo(BPoint(rect.left + 0.5, centerv + 0.5));</a>
<a name="ln1202">		shape.LineTo(BPoint(rect.right - 1 + 0.5, rect.top + 0.5));</a>
<a name="ln1203">	}</a>
<a name="ln1204">	shape.Close();</a>
<a name="ln1205"> </a>
<a name="ln1206">	view-&gt;MovePenTo(BPoint(1, 1));</a>
<a name="ln1207"> </a>
<a name="ln1208">	view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln1209">	view-&gt;SetHighColor(shadowColor);</a>
<a name="ln1210">	view-&gt;StrokeShape(&amp;shape);</a>
<a name="ln1211"> </a>
<a name="ln1212">	view-&gt;MovePenTo(B_ORIGIN);</a>
<a name="ln1213"> </a>
<a name="ln1214">	view-&gt;SetDrawingMode(B_OP_COPY);</a>
<a name="ln1215">	view-&gt;SetHighColor(frameLightColor);</a>
<a name="ln1216">	view-&gt;StrokeShape(&amp;shape);</a>
<a name="ln1217"> </a>
<a name="ln1218">	rect.InsetBy(1, 1);</a>
<a name="ln1219">	shape.Clear();</a>
<a name="ln1220">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln1221">		shape.MoveTo(BPoint(rect.left, rect.bottom + 1));</a>
<a name="ln1222">		shape.LineTo(BPoint(rect.right + 1, rect.bottom + 1));</a>
<a name="ln1223">		shape.LineTo(BPoint(centerh + 0.5, rect.top));</a>
<a name="ln1224">	} else {</a>
<a name="ln1225">		shape.MoveTo(BPoint(rect.right + 1, rect.top));</a>
<a name="ln1226">		shape.LineTo(BPoint(rect.right + 1, rect.bottom + 1));</a>
<a name="ln1227">		shape.LineTo(BPoint(rect.left, centerv + 0.5));</a>
<a name="ln1228">	}</a>
<a name="ln1229">	shape.Close();</a>
<a name="ln1230"> </a>
<a name="ln1231">	BGradientLinear gradient;</a>
<a name="ln1232">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1233">		_MakeGradient(gradient, rect, fill, topTint, bottomTint);</a>
<a name="ln1234">	} else {</a>
<a name="ln1235">		_MakeGlossyGradient(gradient, rect, fill, topTint, middleTint1,</a>
<a name="ln1236">			middleTint2, bottomTint);</a>
<a name="ln1237">	}</a>
<a name="ln1238"> </a>
<a name="ln1239">	view-&gt;FillShape(&amp;shape, gradient);</a>
<a name="ln1240"> </a>
<a name="ln1241">	view-&gt;SetFlags(viewFlags);</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244"> </a>
<a name="ln1245">void</a>
<a name="ln1246">HaikuControlLook::DrawSliderHashMarks(BView* view, BRect&amp; rect,</a>
<a name="ln1247">	const BRect&amp; updateRect, const rgb_color&amp; base, int32 count,</a>
<a name="ln1248">	hash_mark_location location, uint32 flags, orientation orientation)</a>
<a name="ln1249">{</a>
<a name="ln1250">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln1251">		return;</a>
<a name="ln1252"> </a>
<a name="ln1253">	rgb_color lightColor;</a>
<a name="ln1254">	rgb_color darkColor;</a>
<a name="ln1255"> </a>
<a name="ln1256">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1257">		lightColor = tint_color(base, 0.9);</a>
<a name="ln1258">		darkColor = tint_color(base, 1.07);</a>
<a name="ln1259">	} else {</a>
<a name="ln1260">		lightColor = tint_color(base, 0.8);</a>
<a name="ln1261">		darkColor = tint_color(base, 1.14);</a>
<a name="ln1262">	}</a>
<a name="ln1263"> </a>
<a name="ln1264">	int32 hashMarkCount = std::max(count, (int32)2);</a>
<a name="ln1265">		// draw at least two hashmarks at min/max if</a>
<a name="ln1266">		// fHashMarks != B_HASH_MARKS_NONE</a>
<a name="ln1267">	float factor;</a>
<a name="ln1268">	float startPos;</a>
<a name="ln1269">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln1270">		factor = (rect.Width() - 2) / (hashMarkCount - 1);</a>
<a name="ln1271">		startPos = rect.left + 1;</a>
<a name="ln1272">	} else {</a>
<a name="ln1273">		factor = (rect.Height() - 2) / (hashMarkCount - 1);</a>
<a name="ln1274">		startPos = rect.top + 1;</a>
<a name="ln1275">	}</a>
<a name="ln1276"> </a>
<a name="ln1277">	if (location &amp; B_HASH_MARKS_TOP) {</a>
<a name="ln1278">		view-&gt;BeginLineArray(hashMarkCount * 2);</a>
<a name="ln1279"> </a>
<a name="ln1280">		if (orientation == B_HORIZONTAL) {</a>
<a name="ln1281">			float pos = startPos;</a>
<a name="ln1282">			for (int32 i = 0; i &lt; hashMarkCount; i++) {</a>
<a name="ln1283">				view-&gt;AddLine(BPoint(pos, rect.top),</a>
<a name="ln1284">							  BPoint(pos, rect.top + 4), darkColor);</a>
<a name="ln1285">				view-&gt;AddLine(BPoint(pos + 1, rect.top),</a>
<a name="ln1286">							  BPoint(pos + 1, rect.top + 4), lightColor);</a>
<a name="ln1287"> </a>
<a name="ln1288">				pos += factor;</a>
<a name="ln1289">			}</a>
<a name="ln1290">		} else {</a>
<a name="ln1291">			float pos = startPos;</a>
<a name="ln1292">			for (int32 i = 0; i &lt; hashMarkCount; i++) {</a>
<a name="ln1293">				view-&gt;AddLine(BPoint(rect.left, pos),</a>
<a name="ln1294">							  BPoint(rect.left + 4, pos), darkColor);</a>
<a name="ln1295">				view-&gt;AddLine(BPoint(rect.left, pos + 1),</a>
<a name="ln1296">							  BPoint(rect.left + 4, pos + 1), lightColor);</a>
<a name="ln1297"> </a>
<a name="ln1298">				pos += factor;</a>
<a name="ln1299">			}</a>
<a name="ln1300">		}</a>
<a name="ln1301"> </a>
<a name="ln1302">		view-&gt;EndLineArray();</a>
<a name="ln1303">	}</a>
<a name="ln1304"> </a>
<a name="ln1305">	if ((location &amp; B_HASH_MARKS_BOTTOM) != 0) {</a>
<a name="ln1306">		view-&gt;BeginLineArray(hashMarkCount * 2);</a>
<a name="ln1307"> </a>
<a name="ln1308">		if (orientation == B_HORIZONTAL) {</a>
<a name="ln1309">			float pos = startPos;</a>
<a name="ln1310">			for (int32 i = 0; i &lt; hashMarkCount; i++) {</a>
<a name="ln1311">				view-&gt;AddLine(BPoint(pos, rect.bottom - 4),</a>
<a name="ln1312">							  BPoint(pos, rect.bottom), darkColor);</a>
<a name="ln1313">				view-&gt;AddLine(BPoint(pos + 1, rect.bottom - 4),</a>
<a name="ln1314">							  BPoint(pos + 1, rect.bottom), lightColor);</a>
<a name="ln1315"> </a>
<a name="ln1316">				pos += factor;</a>
<a name="ln1317">			}</a>
<a name="ln1318">		} else {</a>
<a name="ln1319">			float pos = startPos;</a>
<a name="ln1320">			for (int32 i = 0; i &lt; hashMarkCount; i++) {</a>
<a name="ln1321">				view-&gt;AddLine(BPoint(rect.right - 4, pos),</a>
<a name="ln1322">							  BPoint(rect.right, pos), darkColor);</a>
<a name="ln1323">				view-&gt;AddLine(BPoint(rect.right - 4, pos + 1),</a>
<a name="ln1324">							  BPoint(rect.right, pos + 1), lightColor);</a>
<a name="ln1325"> </a>
<a name="ln1326">				pos += factor;</a>
<a name="ln1327">			}</a>
<a name="ln1328">		}</a>
<a name="ln1329"> </a>
<a name="ln1330">		view-&gt;EndLineArray();</a>
<a name="ln1331">	}</a>
<a name="ln1332">}</a>
<a name="ln1333"> </a>
<a name="ln1334"> </a>
<a name="ln1335">void</a>
<a name="ln1336">HaikuControlLook::DrawActiveTab(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln1337">	const rgb_color&amp; base, uint32 flags, uint32 borders, uint32 side)</a>
<a name="ln1338">{</a>
<a name="ln1339">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln1340">		return;</a>
<a name="ln1341"> </a>
<a name="ln1342">	// Snap the rectangle to pixels to avoid rounding errors.</a>
<a name="ln1343">	rect.left = floorf(rect.left);</a>
<a name="ln1344">	rect.right = floorf(rect.right);</a>
<a name="ln1345">	rect.top = floorf(rect.top);</a>
<a name="ln1346">	rect.bottom = floorf(rect.bottom);</a>
<a name="ln1347"> </a>
<a name="ln1348">	// save the clipping constraints of the view</a>
<a name="ln1349">	view-&gt;PushState();</a>
<a name="ln1350"> </a>
<a name="ln1351">	// set clipping constraints to updateRect</a>
<a name="ln1352">	BRegion clipping(updateRect);</a>
<a name="ln1353">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln1354"> </a>
<a name="ln1355">	rgb_color edgeShadowColor;</a>
<a name="ln1356">	rgb_color edgeLightColor;</a>
<a name="ln1357">	rgb_color frameShadowColor;</a>
<a name="ln1358">	rgb_color frameLightColor;</a>
<a name="ln1359">	rgb_color bevelShadowColor;</a>
<a name="ln1360">	rgb_color bevelLightColor;</a>
<a name="ln1361">	BGradientLinear fillGradient;</a>
<a name="ln1362">	fillGradient.SetStart(rect.LeftTop() + BPoint(3, 3));</a>
<a name="ln1363">	fillGradient.SetEnd(rect.LeftBottom() + BPoint(3, -3));</a>
<a name="ln1364"> </a>
<a name="ln1365">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1366">		edgeLightColor = base;</a>
<a name="ln1367">		edgeShadowColor = base;</a>
<a name="ln1368">		frameLightColor = tint_color(base, 1.25);</a>
<a name="ln1369">		frameShadowColor = tint_color(base, 1.30);</a>
<a name="ln1370">		bevelLightColor = tint_color(base, 0.8);</a>
<a name="ln1371">		bevelShadowColor = tint_color(base, 1.07);</a>
<a name="ln1372">		fillGradient.AddColor(tint_color(base, 0.85), 0);</a>
<a name="ln1373">		fillGradient.AddColor(base, 255);</a>
<a name="ln1374">	} else {</a>
<a name="ln1375">		edgeLightColor = tint_color(base, 0.80);</a>
<a name="ln1376">		edgeShadowColor = tint_color(base, 1.03);</a>
<a name="ln1377">		frameLightColor = tint_color(base, 1.30);</a>
<a name="ln1378">		frameShadowColor = tint_color(base, 1.30);</a>
<a name="ln1379">		bevelLightColor = tint_color(base, 0.6);</a>
<a name="ln1380">		bevelShadowColor = tint_color(base, 1.07);</a>
<a name="ln1381">		fillGradient.AddColor(tint_color(base, 0.75), 0);</a>
<a name="ln1382">		fillGradient.AddColor(tint_color(base, 1.03), 255);</a>
<a name="ln1383">	}</a>
<a name="ln1384"> </a>
<a name="ln1385">	static const float kRoundCornerRadius = 4.0f;</a>
<a name="ln1386"> </a>
<a name="ln1387">	// left top corner dimensions</a>
<a name="ln1388">	BRect leftTopCorner(rect);</a>
<a name="ln1389">	leftTopCorner.right = floorf(leftTopCorner.left + kRoundCornerRadius);</a>
<a name="ln1390">	leftTopCorner.bottom = floorf(rect.top + kRoundCornerRadius);</a>
<a name="ln1391"> </a>
<a name="ln1392">	// right top corner dimensions</a>
<a name="ln1393">	BRect rightTopCorner(rect);</a>
<a name="ln1394">	rightTopCorner.left = floorf(rightTopCorner.right - kRoundCornerRadius);</a>
<a name="ln1395">	rightTopCorner.bottom = floorf(rect.top + kRoundCornerRadius);</a>
<a name="ln1396"> </a>
<a name="ln1397">	// left bottom corner dimensions</a>
<a name="ln1398">	BRect leftBottomCorner(rect);</a>
<a name="ln1399">	leftBottomCorner.right = floorf(leftBottomCorner.left + kRoundCornerRadius);</a>
<a name="ln1400">	leftBottomCorner.top = floorf(rect.bottom - kRoundCornerRadius);</a>
<a name="ln1401"> </a>
<a name="ln1402">	// right bottom corner dimensions</a>
<a name="ln1403">	BRect rightBottomCorner(rect);</a>
<a name="ln1404">	rightBottomCorner.left = floorf(rightBottomCorner.right</a>
<a name="ln1405">		- kRoundCornerRadius);</a>
<a name="ln1406">	rightBottomCorner.top = floorf(rect.bottom - kRoundCornerRadius);</a>
<a name="ln1407"> </a>
<a name="ln1408">	switch (side) {</a>
<a name="ln1409">		case B_TOP_BORDER:</a>
<a name="ln1410">			clipping.Exclude(leftTopCorner);</a>
<a name="ln1411">			clipping.Exclude(rightTopCorner);</a>
<a name="ln1412"> </a>
<a name="ln1413">			// draw the left top corner</a>
<a name="ln1414">			_DrawRoundCornerLeftTop(view, leftTopCorner, updateRect, base,</a>
<a name="ln1415">				edgeShadowColor, frameLightColor, bevelLightColor,</a>
<a name="ln1416">				fillGradient);</a>
<a name="ln1417">			// draw the right top corner</a>
<a name="ln1418">			_DrawRoundCornerRightTop(view, rightTopCorner, updateRect, base,</a>
<a name="ln1419">				edgeShadowColor, edgeLightColor, frameLightColor,</a>
<a name="ln1420">				frameShadowColor, bevelLightColor, bevelShadowColor,</a>
<a name="ln1421">				fillGradient);</a>
<a name="ln1422">			break;</a>
<a name="ln1423">		case B_BOTTOM_BORDER:</a>
<a name="ln1424">			clipping.Exclude(leftBottomCorner);</a>
<a name="ln1425">			clipping.Exclude(rightBottomCorner);</a>
<a name="ln1426"> </a>
<a name="ln1427">			// draw the left bottom corner</a>
<a name="ln1428">			_DrawRoundCornerLeftBottom(view, leftBottomCorner, updateRect, base,</a>
<a name="ln1429">				edgeShadowColor, edgeLightColor, frameLightColor,</a>
<a name="ln1430">				frameShadowColor, bevelLightColor, bevelShadowColor,</a>
<a name="ln1431">				fillGradient);</a>
<a name="ln1432">			// draw the right bottom corner</a>
<a name="ln1433">			_DrawRoundCornerRightBottom(view, rightBottomCorner, updateRect,</a>
<a name="ln1434">				base, edgeLightColor, frameShadowColor, bevelShadowColor,</a>
<a name="ln1435">				fillGradient);</a>
<a name="ln1436">			break;</a>
<a name="ln1437">		case B_LEFT_BORDER:</a>
<a name="ln1438">			clipping.Exclude(leftTopCorner);</a>
<a name="ln1439">			clipping.Exclude(leftBottomCorner);</a>
<a name="ln1440"> </a>
<a name="ln1441">			// draw the left top corner</a>
<a name="ln1442">			_DrawRoundCornerLeftTop(view, leftTopCorner, updateRect, base,</a>
<a name="ln1443">				edgeShadowColor, frameLightColor, bevelLightColor,</a>
<a name="ln1444">				fillGradient);</a>
<a name="ln1445">			// draw the left bottom corner</a>
<a name="ln1446">			_DrawRoundCornerLeftBottom(view, leftBottomCorner, updateRect, base,</a>
<a name="ln1447">				edgeShadowColor, edgeLightColor, frameLightColor,</a>
<a name="ln1448">				frameShadowColor, bevelLightColor, bevelShadowColor,</a>
<a name="ln1449">				fillGradient);</a>
<a name="ln1450">			break;</a>
<a name="ln1451">		case B_RIGHT_BORDER:</a>
<a name="ln1452">			clipping.Exclude(rightTopCorner);</a>
<a name="ln1453">			clipping.Exclude(rightBottomCorner);</a>
<a name="ln1454"> </a>
<a name="ln1455">			// draw the right top corner</a>
<a name="ln1456">			_DrawRoundCornerRightTop(view, rightTopCorner, updateRect, base,</a>
<a name="ln1457">				edgeShadowColor, edgeLightColor, frameLightColor,</a>
<a name="ln1458">				frameShadowColor, bevelLightColor, bevelShadowColor,</a>
<a name="ln1459">				fillGradient);</a>
<a name="ln1460">			// draw the right bottom corner</a>
<a name="ln1461">			_DrawRoundCornerRightBottom(view, rightBottomCorner, updateRect,</a>
<a name="ln1462">				base, edgeLightColor, frameShadowColor, bevelShadowColor,</a>
<a name="ln1463">				fillGradient);</a>
<a name="ln1464">			break;</a>
<a name="ln1465">	}</a>
<a name="ln1466"> </a>
<a name="ln1467">	// clip out the corners</a>
<a name="ln1468">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln1469"> </a>
<a name="ln1470">	uint32 bordersToDraw = 0;</a>
<a name="ln1471">	switch (side) {</a>
<a name="ln1472">		case B_TOP_BORDER:</a>
<a name="ln1473">			bordersToDraw = (B_LEFT_BORDER | B_TOP_BORDER | B_RIGHT_BORDER);</a>
<a name="ln1474">			break;</a>
<a name="ln1475">		case B_BOTTOM_BORDER:</a>
<a name="ln1476">			bordersToDraw = (B_LEFT_BORDER | B_BOTTOM_BORDER | B_RIGHT_BORDER);</a>
<a name="ln1477">			break;</a>
<a name="ln1478">		case B_LEFT_BORDER:</a>
<a name="ln1479">			bordersToDraw = (B_LEFT_BORDER | B_BOTTOM_BORDER | B_TOP_BORDER);</a>
<a name="ln1480">			break;</a>
<a name="ln1481">		case B_RIGHT_BORDER:</a>
<a name="ln1482">			bordersToDraw = (B_RIGHT_BORDER | B_BOTTOM_BORDER | B_TOP_BORDER);</a>
<a name="ln1483">			break;</a>
<a name="ln1484">	}</a>
<a name="ln1485"> </a>
<a name="ln1486">	// draw the rest of frame and fill</a>
<a name="ln1487">	_DrawFrame(view, rect, edgeShadowColor, edgeShadowColor, edgeLightColor,</a>
<a name="ln1488">		edgeLightColor, borders);</a>
<a name="ln1489">	if (side == B_TOP_BORDER || side == B_BOTTOM_BORDER) {</a>
<a name="ln1490">		if ((borders &amp; B_LEFT_BORDER) == 0)</a>
<a name="ln1491">			rect.left++;</a>
<a name="ln1492">		if ((borders &amp; B_RIGHT_BORDER) == 0)</a>
<a name="ln1493">			rect.right--;</a>
<a name="ln1494">	} else if (side == B_LEFT_BORDER || side == B_RIGHT_BORDER) {</a>
<a name="ln1495">		if ((borders &amp; B_TOP_BORDER) == 0)</a>
<a name="ln1496">			rect.top++;</a>
<a name="ln1497">		if ((borders &amp; B_BOTTOM_BORDER) == 0)</a>
<a name="ln1498">			rect.bottom--;</a>
<a name="ln1499">	}</a>
<a name="ln1500"> </a>
<a name="ln1501">	_DrawFrame(view, rect, frameLightColor, frameLightColor, frameShadowColor,</a>
<a name="ln1502">		frameShadowColor, bordersToDraw);</a>
<a name="ln1503"> </a>
<a name="ln1504">	_DrawFrame(view, rect, bevelLightColor, bevelLightColor, bevelShadowColor,</a>
<a name="ln1505">		bevelShadowColor);</a>
<a name="ln1506"> </a>
<a name="ln1507">	view-&gt;FillRect(rect, fillGradient);</a>
<a name="ln1508"> </a>
<a name="ln1509">	// restore the clipping constraints of the view</a>
<a name="ln1510">	view-&gt;PopState();</a>
<a name="ln1511">}</a>
<a name="ln1512"> </a>
<a name="ln1513"> </a>
<a name="ln1514">void</a>
<a name="ln1515">HaikuControlLook::DrawInactiveTab(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln1516">	const rgb_color&amp; base, uint32 flags, uint32 borders, uint32 side)</a>
<a name="ln1517">{</a>
<a name="ln1518">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln1519">		return;</a>
<a name="ln1520"> </a>
<a name="ln1521">	rgb_color edgeShadowColor;</a>
<a name="ln1522">	rgb_color edgeLightColor;</a>
<a name="ln1523">	rgb_color frameShadowColor;</a>
<a name="ln1524">	rgb_color frameLightColor;</a>
<a name="ln1525">	rgb_color bevelShadowColor;</a>
<a name="ln1526">	rgb_color bevelLightColor;</a>
<a name="ln1527">	BGradientLinear fillGradient;</a>
<a name="ln1528">	fillGradient.SetStart(rect.LeftTop() + BPoint(3, 3));</a>
<a name="ln1529">	fillGradient.SetEnd(rect.LeftBottom() + BPoint(3, -3));</a>
<a name="ln1530"> </a>
<a name="ln1531">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1532">		edgeLightColor = base;</a>
<a name="ln1533">		edgeShadowColor = base;</a>
<a name="ln1534">		frameLightColor = tint_color(base, 1.25);</a>
<a name="ln1535">		frameShadowColor = tint_color(base, 1.30);</a>
<a name="ln1536">		bevelLightColor = tint_color(base, 0.8);</a>
<a name="ln1537">		bevelShadowColor = tint_color(base, 1.07);</a>
<a name="ln1538">		fillGradient.AddColor(tint_color(base, 0.85), 0);</a>
<a name="ln1539">		fillGradient.AddColor(base, 255);</a>
<a name="ln1540">	} else {</a>
<a name="ln1541">		edgeLightColor = tint_color(base, 0.80);</a>
<a name="ln1542">		edgeShadowColor = tint_color(base, 1.03);</a>
<a name="ln1543">		frameLightColor = tint_color(base, 1.30);</a>
<a name="ln1544">		frameShadowColor = tint_color(base, 1.30);</a>
<a name="ln1545">		bevelLightColor = tint_color(base, 1.10);</a>
<a name="ln1546">		bevelShadowColor = tint_color(base, 1.17);</a>
<a name="ln1547">		fillGradient.AddColor(tint_color(base, 1.12), 0);</a>
<a name="ln1548">		fillGradient.AddColor(tint_color(base, 1.08), 255);</a>
<a name="ln1549">	}</a>
<a name="ln1550"> </a>
<a name="ln1551">	BRect background = rect;</a>
<a name="ln1552">	switch (side) {</a>
<a name="ln1553">		case B_TOP_BORDER:</a>
<a name="ln1554">			rect.top += 4;</a>
<a name="ln1555">			background.bottom = rect.top;</a>
<a name="ln1556">			break;</a>
<a name="ln1557">		case B_BOTTOM_BORDER:</a>
<a name="ln1558">			rect.bottom -= 4;</a>
<a name="ln1559">			background.top = rect.bottom;</a>
<a name="ln1560">			break;</a>
<a name="ln1561">		case B_LEFT_BORDER:</a>
<a name="ln1562">			rect.left += 4;</a>
<a name="ln1563">			background.right = rect.left;</a>
<a name="ln1564">			break;</a>
<a name="ln1565">		case B_RIGHT_BORDER:</a>
<a name="ln1566">			rect.right -= 4;</a>
<a name="ln1567">			background.left = rect.right;</a>
<a name="ln1568">		break;</a>
<a name="ln1569">	}</a>
<a name="ln1570"> </a>
<a name="ln1571">	// active tabs stand out at the top, but this is an inactive tab</a>
<a name="ln1572">	view-&gt;SetHighColor(base);</a>
<a name="ln1573">	view-&gt;FillRect(background);</a>
<a name="ln1574"> </a>
<a name="ln1575">	// frame and fill</a>
<a name="ln1576">	_DrawFrame(view, rect, edgeShadowColor, edgeShadowColor, edgeLightColor,</a>
<a name="ln1577">		edgeLightColor, borders);</a>
<a name="ln1578"> </a>
<a name="ln1579">	_DrawFrame(view, rect, frameLightColor, frameLightColor, frameShadowColor,</a>
<a name="ln1580">		frameShadowColor, borders);</a>
<a name="ln1581"> </a>
<a name="ln1582">	if (rect.IsValid()) {</a>
<a name="ln1583">		if (side == B_TOP_BORDER || side == B_BOTTOM_BORDER) {</a>
<a name="ln1584">			_DrawFrame(view, rect, bevelShadowColor, bevelShadowColor,</a>
<a name="ln1585">				bevelLightColor, bevelLightColor, B_LEFT_BORDER &amp; ~borders);</a>
<a name="ln1586">		} else if (side == B_LEFT_BORDER || side == B_RIGHT_BORDER) {</a>
<a name="ln1587">			_DrawFrame(view, rect, bevelShadowColor, bevelShadowColor,</a>
<a name="ln1588">				bevelLightColor, bevelLightColor, B_TOP_BORDER &amp; ~borders);</a>
<a name="ln1589">		}</a>
<a name="ln1590">	} else {</a>
<a name="ln1591">		if (side == B_TOP_BORDER || side == B_BOTTOM_BORDER) {</a>
<a name="ln1592">			if ((B_LEFT_BORDER &amp; ~borders) != 0)</a>
<a name="ln1593">				rect.left++;</a>
<a name="ln1594">		} else if (side == B_LEFT_BORDER || side == B_RIGHT_BORDER) {</a>
<a name="ln1595">			if ((B_TOP_BORDER &amp; ~borders) != 0)</a>
<a name="ln1596">				rect.top++;</a>
<a name="ln1597">		}</a>
<a name="ln1598">	}</a>
<a name="ln1599"> </a>
<a name="ln1600">	view-&gt;FillRect(rect, fillGradient);</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603"> </a>
<a name="ln1604">void</a>
<a name="ln1605">HaikuControlLook::DrawSplitter(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln1606">	const rgb_color&amp; base, orientation orientation, uint32 flags,</a>
<a name="ln1607">	uint32 borders)</a>
<a name="ln1608">{</a>
<a name="ln1609">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln1610">		return;</a>
<a name="ln1611"> </a>
<a name="ln1612">	rgb_color background;</a>
<a name="ln1613">	if ((flags &amp; (B_CLICKED | B_ACTIVATED)) != 0)</a>
<a name="ln1614">		background = tint_color(base, B_DARKEN_1_TINT);</a>
<a name="ln1615">	else</a>
<a name="ln1616">		background = base;</a>
<a name="ln1617"> </a>
<a name="ln1618">	rgb_color light = tint_color(background, 0.6);</a>
<a name="ln1619">	rgb_color shadow = tint_color(background, 1.21);</a>
<a name="ln1620"> </a>
<a name="ln1621">	// frame</a>
<a name="ln1622">	if (borders != 0 &amp;&amp; rect.Width() &gt; 3 &amp;&amp; rect.Height() &gt; 3)</a>
<a name="ln1623">		DrawRaisedBorder(view, rect, updateRect, background, flags, borders);</a>
<a name="ln1624"> </a>
<a name="ln1625">	// dots and rest of background</a>
<a name="ln1626">	if (orientation == B_HORIZONTAL) {</a>
<a name="ln1627">		if (rect.Width() &gt; 2) {</a>
<a name="ln1628">			// background on left/right</a>
<a name="ln1629">			BRegion region(rect);</a>
<a name="ln1630">			rect.left = floorf((rect.left + rect.right) / 2.0 - 0.5);</a>
<a name="ln1631">			rect.right = rect.left + 1;</a>
<a name="ln1632">			region.Exclude(rect);</a>
<a name="ln1633">			view-&gt;SetHighColor(background);</a>
<a name="ln1634">			view-&gt;FillRegion(&amp;region);</a>
<a name="ln1635">		}</a>
<a name="ln1636"> </a>
<a name="ln1637">		BPoint dot = rect.LeftTop();</a>
<a name="ln1638">		BPoint stop = rect.LeftBottom();</a>
<a name="ln1639">		int32 num = 1;</a>
<a name="ln1640">		while (dot.y &lt;= stop.y) {</a>
<a name="ln1641">			rgb_color col1;</a>
<a name="ln1642">			rgb_color col2;</a>
<a name="ln1643">			switch (num) {</a>
<a name="ln1644">				case 1:</a>
<a name="ln1645">					col1 = background;</a>
<a name="ln1646">					col2 = background;</a>
<a name="ln1647">					break;</a>
<a name="ln1648">				case 2:</a>
<a name="ln1649">					col1 = shadow;</a>
<a name="ln1650">					col2 = background;</a>
<a name="ln1651">					break;</a>
<a name="ln1652">				case 3:</a>
<a name="ln1653">				default:</a>
<a name="ln1654">					col1 = background;</a>
<a name="ln1655">					col2 = light;</a>
<a name="ln1656">					num = 0;</a>
<a name="ln1657">					break;</a>
<a name="ln1658">			}</a>
<a name="ln1659">			view-&gt;SetHighColor(col1);</a>
<a name="ln1660">			view-&gt;StrokeLine(dot, dot, B_SOLID_HIGH);</a>
<a name="ln1661">			view-&gt;SetHighColor(col2);</a>
<a name="ln1662">			dot.x++;</a>
<a name="ln1663">			view-&gt;StrokeLine(dot, dot, B_SOLID_HIGH);</a>
<a name="ln1664">			dot.x -= 1.0;</a>
<a name="ln1665">			// next pixel</a>
<a name="ln1666">			num++;</a>
<a name="ln1667">			dot.y++;</a>
<a name="ln1668">		}</a>
<a name="ln1669">	} else {</a>
<a name="ln1670">		if (rect.Height() &gt; 2) {</a>
<a name="ln1671">			// background on left/right</a>
<a name="ln1672">			BRegion region(rect);</a>
<a name="ln1673">			rect.top = floorf((rect.top + rect.bottom) / 2.0 - 0.5);</a>
<a name="ln1674">			rect.bottom = rect.top + 1;</a>
<a name="ln1675">			region.Exclude(rect);</a>
<a name="ln1676">			view-&gt;SetHighColor(background);</a>
<a name="ln1677">			view-&gt;FillRegion(&amp;region);</a>
<a name="ln1678">		}</a>
<a name="ln1679"> </a>
<a name="ln1680">		BPoint dot = rect.LeftTop();</a>
<a name="ln1681">		BPoint stop = rect.RightTop();</a>
<a name="ln1682">		int32 num = 1;</a>
<a name="ln1683">		while (dot.x &lt;= stop.x) {</a>
<a name="ln1684">			rgb_color col1;</a>
<a name="ln1685">			rgb_color col2;</a>
<a name="ln1686">			switch (num) {</a>
<a name="ln1687">				case 1:</a>
<a name="ln1688">					col1 = background;</a>
<a name="ln1689">					col2 = background;</a>
<a name="ln1690">					break;</a>
<a name="ln1691">				case 2:</a>
<a name="ln1692">					col1 = shadow;</a>
<a name="ln1693">					col2 = background;</a>
<a name="ln1694">					break;</a>
<a name="ln1695">				case 3:</a>
<a name="ln1696">				default:</a>
<a name="ln1697">					col1 = background;</a>
<a name="ln1698">					col2 = light;</a>
<a name="ln1699">					num = 0;</a>
<a name="ln1700">					break;</a>
<a name="ln1701">			}</a>
<a name="ln1702">			view-&gt;SetHighColor(col1);</a>
<a name="ln1703">			view-&gt;StrokeLine(dot, dot, B_SOLID_HIGH);</a>
<a name="ln1704">			view-&gt;SetHighColor(col2);</a>
<a name="ln1705">			dot.y++;</a>
<a name="ln1706">			view-&gt;StrokeLine(dot, dot, B_SOLID_HIGH);</a>
<a name="ln1707">			dot.y -= 1.0;</a>
<a name="ln1708">			// next pixel</a>
<a name="ln1709">			num++;</a>
<a name="ln1710">			dot.x++;</a>
<a name="ln1711">		}</a>
<a name="ln1712">	}</a>
<a name="ln1713">}</a>
<a name="ln1714"> </a>
<a name="ln1715"> </a>
<a name="ln1716">// #pragma mark -</a>
<a name="ln1717"> </a>
<a name="ln1718"> </a>
<a name="ln1719">void</a>
<a name="ln1720">HaikuControlLook::DrawBorder(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln1721">	const rgb_color&amp; base, border_style borderStyle, uint32 flags,</a>
<a name="ln1722">	uint32 borders)</a>
<a name="ln1723">{</a>
<a name="ln1724">	if (borderStyle == B_NO_BORDER)</a>
<a name="ln1725">		return;</a>
<a name="ln1726"> </a>
<a name="ln1727">	rgb_color scrollbarFrameColor = tint_color(base, B_DARKEN_2_TINT);</a>
<a name="ln1728">	if ((flags &amp; B_FOCUSED) != 0)</a>
<a name="ln1729">		scrollbarFrameColor = ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln1730"> </a>
<a name="ln1731">	if (borderStyle == B_FANCY_BORDER)</a>
<a name="ln1732">		_DrawOuterResessedFrame(view, rect, base, 1.0, 1.0, flags, borders);</a>
<a name="ln1733"> </a>
<a name="ln1734">	_DrawFrame(view, rect, scrollbarFrameColor, scrollbarFrameColor,</a>
<a name="ln1735">		scrollbarFrameColor, scrollbarFrameColor, borders);</a>
<a name="ln1736">}</a>
<a name="ln1737"> </a>
<a name="ln1738"> </a>
<a name="ln1739">void</a>
<a name="ln1740">HaikuControlLook::DrawRaisedBorder(BView* view, BRect&amp; rect,</a>
<a name="ln1741">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln1742">	uint32 borders)</a>
<a name="ln1743">{</a>
<a name="ln1744">	rgb_color lightColor;</a>
<a name="ln1745">	rgb_color shadowColor;</a>
<a name="ln1746"> </a>
<a name="ln1747">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1748">		lightColor = base;</a>
<a name="ln1749">		shadowColor = base;</a>
<a name="ln1750">	} else {</a>
<a name="ln1751">		lightColor = tint_color(base, 0.85);</a>
<a name="ln1752">		shadowColor = tint_color(base, 1.07);</a>
<a name="ln1753">	}</a>
<a name="ln1754"> </a>
<a name="ln1755">	_DrawFrame(view, rect, lightColor, lightColor, shadowColor, shadowColor,</a>
<a name="ln1756">		borders);</a>
<a name="ln1757">}</a>
<a name="ln1758"> </a>
<a name="ln1759"> </a>
<a name="ln1760">void</a>
<a name="ln1761">HaikuControlLook::DrawTextControlBorder(BView* view, BRect&amp; rect,</a>
<a name="ln1762">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln1763">	uint32 borders)</a>
<a name="ln1764">{</a>
<a name="ln1765">	if (!rect.Intersects(updateRect))</a>
<a name="ln1766">		return;</a>
<a name="ln1767"> </a>
<a name="ln1768">	rgb_color dark1BorderColor;</a>
<a name="ln1769">	rgb_color dark2BorderColor;</a>
<a name="ln1770">	rgb_color navigationColor = ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln1771">	rgb_color invalidColor = ui_color(B_FAILURE_COLOR);</a>
<a name="ln1772"> </a>
<a name="ln1773">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1774">		_DrawOuterResessedFrame(view, rect, base, 0.0, 1.0, flags, borders);</a>
<a name="ln1775"> </a>
<a name="ln1776">		if ((flags &amp; B_BLEND_FRAME) != 0)</a>
<a name="ln1777">			dark1BorderColor = (rgb_color){ 0, 0, 0, 40 };</a>
<a name="ln1778">		else</a>
<a name="ln1779">			dark1BorderColor = tint_color(base, 1.15);</a>
<a name="ln1780">		dark2BorderColor = dark1BorderColor;</a>
<a name="ln1781">	} else if ((flags &amp; B_CLICKED) != 0) {</a>
<a name="ln1782">		dark1BorderColor = tint_color(base, 1.50);</a>
<a name="ln1783">		dark2BorderColor = tint_color(base, 1.49);</a>
<a name="ln1784"> </a>
<a name="ln1785">		// BCheckBox uses this to indicate the clicked state...</a>
<a name="ln1786">		_DrawFrame(view, rect,</a>
<a name="ln1787">			dark1BorderColor, dark1BorderColor,</a>
<a name="ln1788">			dark2BorderColor, dark2BorderColor);</a>
<a name="ln1789"> </a>
<a name="ln1790">		dark2BorderColor = dark1BorderColor;</a>
<a name="ln1791">	} else {</a>
<a name="ln1792">		_DrawOuterResessedFrame(view, rect, base, 0.6, 1.0, flags, borders);</a>
<a name="ln1793"> </a>
<a name="ln1794">		if ((flags &amp; B_BLEND_FRAME) != 0) {</a>
<a name="ln1795">			dark1BorderColor = (rgb_color){ 0, 0, 0, 102 };</a>
<a name="ln1796">			dark2BorderColor = (rgb_color){ 0, 0, 0, 97 };</a>
<a name="ln1797">		} else {</a>
<a name="ln1798">			dark1BorderColor = tint_color(base, 1.40);</a>
<a name="ln1799">			dark2BorderColor = tint_color(base, 1.38);</a>
<a name="ln1800">		}</a>
<a name="ln1801">	}</a>
<a name="ln1802"> </a>
<a name="ln1803">	if ((flags &amp; B_DISABLED) == 0 &amp;&amp; (flags &amp; B_FOCUSED) != 0) {</a>
<a name="ln1804">		dark1BorderColor = navigationColor;</a>
<a name="ln1805">		dark2BorderColor = navigationColor;</a>
<a name="ln1806">	}</a>
<a name="ln1807"> </a>
<a name="ln1808">	if ((flags &amp; B_DISABLED) == 0 &amp;&amp; (flags &amp; B_INVALID) != 0) {</a>
<a name="ln1809">		dark1BorderColor = invalidColor;</a>
<a name="ln1810">		dark2BorderColor = invalidColor;</a>
<a name="ln1811">	}</a>
<a name="ln1812"> </a>
<a name="ln1813">	if ((flags &amp; B_BLEND_FRAME) != 0) {</a>
<a name="ln1814">		drawing_mode oldMode = view-&gt;DrawingMode();</a>
<a name="ln1815">		view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln1816"> </a>
<a name="ln1817">		_DrawFrame(view, rect,</a>
<a name="ln1818">			dark1BorderColor, dark1BorderColor,</a>
<a name="ln1819">			dark2BorderColor, dark2BorderColor, borders);</a>
<a name="ln1820"> </a>
<a name="ln1821">		view-&gt;SetDrawingMode(oldMode);</a>
<a name="ln1822">	} else {</a>
<a name="ln1823">		_DrawFrame(view, rect,</a>
<a name="ln1824">			dark1BorderColor, dark1BorderColor,</a>
<a name="ln1825">			dark2BorderColor, dark2BorderColor, borders);</a>
<a name="ln1826">	}</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829"> </a>
<a name="ln1830">void</a>
<a name="ln1831">HaikuControlLook::DrawGroupFrame(BView* view, BRect&amp; rect, const BRect&amp; updateRect,</a>
<a name="ln1832">	const rgb_color&amp; base, uint32 borders)</a>
<a name="ln1833">{</a>
<a name="ln1834">	rgb_color frameColor = tint_color(base, 1.30);</a>
<a name="ln1835">	rgb_color bevelLight = tint_color(base, 0.8);</a>
<a name="ln1836">	rgb_color bevelShadow = tint_color(base, 1.03);</a>
<a name="ln1837"> </a>
<a name="ln1838">	_DrawFrame(view, rect, bevelShadow, bevelShadow, bevelLight, bevelLight,</a>
<a name="ln1839">		borders);</a>
<a name="ln1840"> </a>
<a name="ln1841">	_DrawFrame(view, rect, frameColor, frameColor, frameColor, frameColor,</a>
<a name="ln1842">		borders);</a>
<a name="ln1843"> </a>
<a name="ln1844">	_DrawFrame(view, rect, bevelLight, bevelLight, bevelShadow, bevelShadow,</a>
<a name="ln1845">		borders);</a>
<a name="ln1846">}</a>
<a name="ln1847"> </a>
<a name="ln1848"> </a>
<a name="ln1849">void</a>
<a name="ln1850">HaikuControlLook::DrawLabel(BView* view, const char* label, BRect rect,</a>
<a name="ln1851">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln1852">	const rgb_color* textColor)</a>
<a name="ln1853">{</a>
<a name="ln1854">	DrawLabel(view, label, NULL, rect, updateRect, base, flags,</a>
<a name="ln1855">		DefaultLabelAlignment(), textColor);</a>
<a name="ln1856">}</a>
<a name="ln1857"> </a>
<a name="ln1858"> </a>
<a name="ln1859">void</a>
<a name="ln1860">HaikuControlLook::DrawLabel(BView* view, const char* label, BRect rect,</a>
<a name="ln1861">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln1862">	const BAlignment&amp; alignment, const rgb_color* textColor)</a>
<a name="ln1863">{</a>
<a name="ln1864">	DrawLabel(view, label, NULL, rect, updateRect, base, flags, alignment,</a>
<a name="ln1865">		textColor);</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868"> </a>
<a name="ln1869">void</a>
<a name="ln1870">HaikuControlLook::DrawLabel(BView* view, const char* label, const rgb_color&amp; base,</a>
<a name="ln1871">	uint32 flags, const BPoint&amp; where, const rgb_color* textColor)</a>
<a name="ln1872">{</a>
<a name="ln1873">	// setup the text color</a>
<a name="ln1874"> </a>
<a name="ln1875">	BWindow* window = view-&gt;Window();</a>
<a name="ln1876">	bool isDesktop = window</a>
<a name="ln1877">		&amp;&amp; window-&gt;Feel() == kDesktopWindowFeel</a>
<a name="ln1878">		&amp;&amp; window-&gt;Look() == kDesktopWindowLook</a>
<a name="ln1879">		&amp;&amp; view-&gt;Parent()</a>
<a name="ln1880">		&amp;&amp; view-&gt;Parent()-&gt;Parent() == NULL</a>
<a name="ln1881">		&amp;&amp; (flags &amp; B_IGNORE_OUTLINE) == 0;</a>
<a name="ln1882"> </a>
<a name="ln1883">	rgb_color low;</a>
<a name="ln1884">	rgb_color color;</a>
<a name="ln1885">	rgb_color glowColor;</a>
<a name="ln1886"> </a>
<a name="ln1887">	if (textColor != NULL)</a>
<a name="ln1888">		glowColor = *textColor;</a>
<a name="ln1889">	else if ((flags &amp; B_IS_CONTROL) != 0)</a>
<a name="ln1890">		glowColor = ui_color(B_CONTROL_TEXT_COLOR);</a>
<a name="ln1891">	else</a>
<a name="ln1892">		glowColor = ui_color(B_PANEL_TEXT_COLOR);</a>
<a name="ln1893"> </a>
<a name="ln1894">	color = glowColor;</a>
<a name="ln1895"> </a>
<a name="ln1896">	if (isDesktop)</a>
<a name="ln1897">		low = view-&gt;Parent()-&gt;ViewColor();</a>
<a name="ln1898">	else</a>
<a name="ln1899">		low = base;</a>
<a name="ln1900"> </a>
<a name="ln1901">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln1902">		color.red = (uint8)(((int32)low.red + color.red + 1) / 2);</a>
<a name="ln1903">		color.green = (uint8)(((int32)low.green + color.green + 1) / 2);</a>
<a name="ln1904">		color.blue = (uint8)(((int32)low.blue + color.blue + 1) / 2);</a>
<a name="ln1905">	}</a>
<a name="ln1906"> </a>
<a name="ln1907">	drawing_mode oldMode = view-&gt;DrawingMode();</a>
<a name="ln1908"> </a>
<a name="ln1909">	if (isDesktop) {</a>
<a name="ln1910">		// enforce proper use of desktop label colors</a>
<a name="ln1911">		if (low.Brightness() &lt; 100) {</a>
<a name="ln1912">			if (textColor == NULL)</a>
<a name="ln1913">				color = make_color(255, 255, 255);</a>
<a name="ln1914"> </a>
<a name="ln1915">			glowColor = make_color(0, 0, 0);</a>
<a name="ln1916">		} else {</a>
<a name="ln1917">			if (textColor == NULL)</a>
<a name="ln1918">				color = make_color(0, 0, 0);</a>
<a name="ln1919"> </a>
<a name="ln1920">			glowColor = make_color(255, 255, 255);</a>
<a name="ln1921">		}</a>
<a name="ln1922"> </a>
<a name="ln1923">		// drawing occurs on the desktop</a>
<a name="ln1924">		if (fCachedWorkspace != current_workspace()) {</a>
<a name="ln1925">			int8 indice = 0;</a>
<a name="ln1926">			int32 mask;</a>
<a name="ln1927">			bool tmpOutline;</a>
<a name="ln1928">			while (fBackgroundInfo.FindInt32(&quot;be:bgndimginfoworkspaces&quot;,</a>
<a name="ln1929">					indice, &amp;mask) == B_OK</a>
<a name="ln1930">				&amp;&amp; fBackgroundInfo.FindBool(&quot;be:bgndimginfoerasetext&quot;,</a>
<a name="ln1931">					indice, &amp;tmpOutline) == B_OK) {</a>
<a name="ln1932"> </a>
<a name="ln1933">				if (((1 &lt;&lt; current_workspace()) &amp; mask) != 0) {</a>
<a name="ln1934">					fCachedOutline = tmpOutline;</a>
<a name="ln1935">					fCachedWorkspace = current_workspace();</a>
<a name="ln1936">					break;</a>
<a name="ln1937">				}</a>
<a name="ln1938">				indice++;</a>
<a name="ln1939">			}</a>
<a name="ln1940">		}</a>
<a name="ln1941"> </a>
<a name="ln1942">		if (fCachedOutline) {</a>
<a name="ln1943">			BFont font;</a>
<a name="ln1944">			view-&gt;GetFont(&amp;font);</a>
<a name="ln1945"> </a>
<a name="ln1946">			view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln1947">			view-&gt;SetBlendingMode(B_CONSTANT_ALPHA, B_ALPHA_OVERLAY);</a>
<a name="ln1948">			// Draw glow or outline</a>
<a name="ln1949">			if (glowColor.Brightness() &gt; 128) {</a>
<a name="ln1950">				font.SetFalseBoldWidth(2.0);</a>
<a name="ln1951">				view-&gt;SetFont(&amp;font, B_FONT_FALSE_BOLD_WIDTH);</a>
<a name="ln1952"> </a>
<a name="ln1953">				glowColor.alpha = 30;</a>
<a name="ln1954">				view-&gt;SetHighColor(glowColor);</a>
<a name="ln1955">				view-&gt;DrawString(label, where);</a>
<a name="ln1956"> </a>
<a name="ln1957">				font.SetFalseBoldWidth(1.0);</a>
<a name="ln1958">				view-&gt;SetFont(&amp;font, B_FONT_FALSE_BOLD_WIDTH);</a>
<a name="ln1959"> </a>
<a name="ln1960">				glowColor.alpha = 65;</a>
<a name="ln1961">				view-&gt;SetHighColor(glowColor);</a>
<a name="ln1962">				view-&gt;DrawString(label, where);</a>
<a name="ln1963"> </a>
<a name="ln1964">				font.SetFalseBoldWidth(0.0);</a>
<a name="ln1965">				view-&gt;SetFont(&amp;font, B_FONT_FALSE_BOLD_WIDTH);</a>
<a name="ln1966">			} else {</a>
<a name="ln1967">				font.SetFalseBoldWidth(1.0);</a>
<a name="ln1968">				view-&gt;SetFont(&amp;font, B_FONT_FALSE_BOLD_WIDTH);</a>
<a name="ln1969"> </a>
<a name="ln1970">				glowColor.alpha = 30;</a>
<a name="ln1971">				view-&gt;SetHighColor(glowColor);</a>
<a name="ln1972">				view-&gt;DrawString(label, where);</a>
<a name="ln1973"> </a>
<a name="ln1974">				font.SetFalseBoldWidth(0.0);</a>
<a name="ln1975">				view-&gt;SetFont(&amp;font, B_FONT_FALSE_BOLD_WIDTH);</a>
<a name="ln1976"> </a>
<a name="ln1977">				glowColor.alpha = 200;</a>
<a name="ln1978">				view-&gt;SetHighColor(glowColor);</a>
<a name="ln1979">				view-&gt;DrawString(label, BPoint(where.x + 1, where.y + 1));</a>
<a name="ln1980">			}</a>
<a name="ln1981">		}</a>
<a name="ln1982">	}</a>
<a name="ln1983"> </a>
<a name="ln1984">	view-&gt;SetHighColor(color);</a>
<a name="ln1985">	view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln1986">	view-&gt;DrawString(label, where);</a>
<a name="ln1987">	view-&gt;SetDrawingMode(oldMode);</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990"> </a>
<a name="ln1991">void</a>
<a name="ln1992">HaikuControlLook::DrawLabel(BView* view, const char* label, const BBitmap* icon,</a>
<a name="ln1993">	BRect rect, const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln1994">	const BAlignment&amp; alignment, const rgb_color* textColor)</a>
<a name="ln1995">{</a>
<a name="ln1996">	if (!rect.Intersects(updateRect))</a>
<a name="ln1997">		return;</a>
<a name="ln1998"> </a>
<a name="ln1999">	if (label == NULL &amp;&amp; icon == NULL)</a>
<a name="ln2000">		return;</a>
<a name="ln2001"> </a>
<a name="ln2002">	if (label == NULL) {</a>
<a name="ln2003">		// icon only</a>
<a name="ln2004">		BRect alignedRect = BLayoutUtils::AlignInFrame(rect,</a>
<a name="ln2005">			icon-&gt;Bounds().Size(), alignment);</a>
<a name="ln2006">		drawing_mode oldMode = view-&gt;DrawingMode();</a>
<a name="ln2007">		view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln2008">		view-&gt;DrawBitmap(icon, alignedRect.LeftTop());</a>
<a name="ln2009">		view-&gt;SetDrawingMode(oldMode);</a>
<a name="ln2010">		return;</a>
<a name="ln2011">	}</a>
<a name="ln2012"> </a>
<a name="ln2013">	// label, possibly with icon</a>
<a name="ln2014">	float availableWidth = rect.Width() + 1;</a>
<a name="ln2015">	float width = 0;</a>
<a name="ln2016">	float textOffset = 0;</a>
<a name="ln2017">	float height = 0;</a>
<a name="ln2018"> </a>
<a name="ln2019">	if (icon != NULL) {</a>
<a name="ln2020">		width = icon-&gt;Bounds().Width() + DefaultLabelSpacing() + 1;</a>
<a name="ln2021">		height = icon-&gt;Bounds().Height() + 1;</a>
<a name="ln2022">		textOffset = width;</a>
<a name="ln2023">		availableWidth -= textOffset;</a>
<a name="ln2024">	}</a>
<a name="ln2025"> </a>
<a name="ln2026">	// truncate the label if necessary and get the width and height</a>
<a name="ln2027">	BString truncatedLabel(label);</a>
<a name="ln2028"> </a>
<a name="ln2029">	BFont font;</a>
<a name="ln2030">	view-&gt;GetFont(&amp;font);</a>
<a name="ln2031"> </a>
<a name="ln2032">	font.TruncateString(&amp;truncatedLabel, B_TRUNCATE_END, availableWidth);</a>
<a name="ln2033">	width += ceilf(font.StringWidth(truncatedLabel.String()));</a>
<a name="ln2034"> </a>
<a name="ln2035">	font_height fontHeight;</a>
<a name="ln2036">	font.GetHeight(&amp;fontHeight);</a>
<a name="ln2037">	float textHeight = ceilf(fontHeight.ascent) + ceilf(fontHeight.descent);</a>
<a name="ln2038">	height = std::max(height, textHeight);</a>
<a name="ln2039"> </a>
<a name="ln2040">	// handle alignment</a>
<a name="ln2041">	BRect alignedRect(BLayoutUtils::AlignOnRect(rect,</a>
<a name="ln2042">		BSize(width - 1, height - 1), alignment));</a>
<a name="ln2043"> </a>
<a name="ln2044">	if (icon != NULL) {</a>
<a name="ln2045">		BPoint location(alignedRect.LeftTop());</a>
<a name="ln2046">		if (icon-&gt;Bounds().Height() + 1 &lt; height)</a>
<a name="ln2047">			location.y += ceilf((height - icon-&gt;Bounds().Height() - 1) / 2);</a>
<a name="ln2048"> </a>
<a name="ln2049">		drawing_mode oldMode = view-&gt;DrawingMode();</a>
<a name="ln2050">		view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln2051">		view-&gt;DrawBitmap(icon, location);</a>
<a name="ln2052">		view-&gt;SetDrawingMode(oldMode);</a>
<a name="ln2053">	}</a>
<a name="ln2054"> </a>
<a name="ln2055">	BPoint location(alignedRect.left + textOffset,</a>
<a name="ln2056">		alignedRect.top + ceilf(fontHeight.ascent));</a>
<a name="ln2057">	if (textHeight &lt; height)</a>
<a name="ln2058">		location.y += ceilf((height - textHeight) / 2);</a>
<a name="ln2059"> </a>
<a name="ln2060">	DrawLabel(view, truncatedLabel.String(), base, flags, location, textColor);</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063"> </a>
<a name="ln2064">void</a>
<a name="ln2065">HaikuControlLook::GetFrameInsets(frame_type frameType, uint32 flags, float&amp; _left,</a>
<a name="ln2066">	float&amp; _top, float&amp; _right, float&amp; _bottom)</a>
<a name="ln2067">{</a>
<a name="ln2068">	// All frames have the same inset on each side.</a>
<a name="ln2069">	float inset = 0;</a>
<a name="ln2070"> </a>
<a name="ln2071">	switch (frameType) {</a>
<a name="ln2072">		case B_BUTTON_FRAME:</a>
<a name="ln2073">			inset = (flags &amp; B_DEFAULT_BUTTON) != 0 ? 5 : 2;</a>
<a name="ln2074">			break;</a>
<a name="ln2075">		case B_GROUP_FRAME:</a>
<a name="ln2076">		case B_MENU_FIELD_FRAME:</a>
<a name="ln2077">			inset = 3;</a>
<a name="ln2078">			break;</a>
<a name="ln2079">		case B_SCROLL_VIEW_FRAME:</a>
<a name="ln2080">		case B_TEXT_CONTROL_FRAME:</a>
<a name="ln2081">			inset = 2;</a>
<a name="ln2082">			break;</a>
<a name="ln2083">	}</a>
<a name="ln2084"> </a>
<a name="ln2085">	_left = inset;</a>
<a name="ln2086">	_top = inset;</a>
<a name="ln2087">	_right = inset;</a>
<a name="ln2088">	_bottom = inset;</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091"> </a>
<a name="ln2092">void</a>
<a name="ln2093">HaikuControlLook::GetBackgroundInsets(background_type backgroundType,</a>
<a name="ln2094">	uint32 flags, float&amp; _left, float&amp; _top, float&amp; _right, float&amp; _bottom)</a>
<a name="ln2095">{</a>
<a name="ln2096">	// Most backgrounds have the same inset on each side.</a>
<a name="ln2097">	float inset = 0;</a>
<a name="ln2098"> </a>
<a name="ln2099">	switch (backgroundType) {</a>
<a name="ln2100">		case B_BUTTON_BACKGROUND:</a>
<a name="ln2101">		case B_MENU_BACKGROUND:</a>
<a name="ln2102">		case B_MENU_BAR_BACKGROUND:</a>
<a name="ln2103">		case B_MENU_FIELD_BACKGROUND:</a>
<a name="ln2104">		case B_MENU_ITEM_BACKGROUND:</a>
<a name="ln2105">			inset = 1;</a>
<a name="ln2106">			break;</a>
<a name="ln2107">		case B_BUTTON_WITH_POP_UP_BACKGROUND:</a>
<a name="ln2108">			_left = 1;</a>
<a name="ln2109">			_top = 1;</a>
<a name="ln2110">			_right = 1 + kButtonPopUpIndicatorWidth;</a>
<a name="ln2111">			_bottom = 1;</a>
<a name="ln2112">			return;</a>
<a name="ln2113">		case B_HORIZONTAL_SCROLL_BAR_BACKGROUND:</a>
<a name="ln2114">			_left = 2;</a>
<a name="ln2115">			_top = 0;</a>
<a name="ln2116">			_right = 1;</a>
<a name="ln2117">			_bottom = 0;</a>
<a name="ln2118">			return;</a>
<a name="ln2119">		case B_VERTICAL_SCROLL_BAR_BACKGROUND:</a>
<a name="ln2120">			_left = 0;</a>
<a name="ln2121">			_top = 2;</a>
<a name="ln2122">			_right = 0;</a>
<a name="ln2123">			_bottom = 1;</a>
<a name="ln2124">			return;</a>
<a name="ln2125">	}</a>
<a name="ln2126"> </a>
<a name="ln2127">	_left = inset;</a>
<a name="ln2128">	_top = inset;</a>
<a name="ln2129">	_right = inset;</a>
<a name="ln2130">	_bottom = inset;</a>
<a name="ln2131">}</a>
<a name="ln2132"> </a>
<a name="ln2133"> </a>
<a name="ln2134">void</a>
<a name="ln2135">HaikuControlLook::DrawButtonWithPopUpBackground(BView* view, BRect&amp; rect,</a>
<a name="ln2136">	const BRect&amp; updateRect, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln2137">	uint32 borders, orientation orientation)</a>
<a name="ln2138">{</a>
<a name="ln2139">	_DrawButtonBackground(view, rect, updateRect, 0.0f, 0.0f, 0.0f, 0.0f,</a>
<a name="ln2140">		base, true, flags, borders, orientation);</a>
<a name="ln2141">}</a>
<a name="ln2142"> </a>
<a name="ln2143"> </a>
<a name="ln2144">void</a>
<a name="ln2145">HaikuControlLook::DrawButtonWithPopUpBackground(BView* view, BRect&amp; rect,</a>
<a name="ln2146">	const BRect&amp; updateRect, float radius, const rgb_color&amp; base, uint32 flags,</a>
<a name="ln2147">	uint32 borders, orientation orientation)</a>
<a name="ln2148">{</a>
<a name="ln2149">	_DrawButtonBackground(view, rect, updateRect, radius, radius, radius,</a>
<a name="ln2150">		radius, base, true, flags, borders, orientation);</a>
<a name="ln2151">}</a>
<a name="ln2152"> </a>
<a name="ln2153"> </a>
<a name="ln2154">void</a>
<a name="ln2155">HaikuControlLook::DrawButtonWithPopUpBackground(BView* view, BRect&amp; rect,</a>
<a name="ln2156">	const BRect&amp; updateRect, float leftTopRadius, float rightTopRadius,</a>
<a name="ln2157">	float leftBottomRadius, float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln2158">	uint32 flags, uint32 borders, orientation orientation)</a>
<a name="ln2159">{</a>
<a name="ln2160">	_DrawButtonBackground(view, rect, updateRect, leftTopRadius,</a>
<a name="ln2161">		rightTopRadius, leftBottomRadius, rightBottomRadius, base, true, flags,</a>
<a name="ln2162">		borders, orientation);</a>
<a name="ln2163">}</a>
<a name="ln2164"> </a>
<a name="ln2165"> </a>
<a name="ln2166">// #pragma mark -</a>
<a name="ln2167"> </a>
<a name="ln2168"> </a>
<a name="ln2169">void</a>
<a name="ln2170">HaikuControlLook::_DrawButtonFrame(BView* view, BRect&amp; rect,</a>
<a name="ln2171">	const BRect&amp; updateRect, float leftTopRadius, float rightTopRadius,</a>
<a name="ln2172">	float leftBottomRadius, float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln2173">	const rgb_color&amp; background, float contrast, float brightness,</a>
<a name="ln2174">	uint32 flags, uint32 borders)</a>
<a name="ln2175">{</a>
<a name="ln2176">	if (!rect.IsValid())</a>
<a name="ln2177">		return;</a>
<a name="ln2178"> </a>
<a name="ln2179">	// save the clipping constraints of the view</a>
<a name="ln2180">	view-&gt;PushState();</a>
<a name="ln2181"> </a>
<a name="ln2182">	// set clipping constraints to updateRect</a>
<a name="ln2183">	BRegion clipping(updateRect);</a>
<a name="ln2184">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln2185"> </a>
<a name="ln2186">	// If the button is flat and neither activated nor otherwise highlighted</a>
<a name="ln2187">	// (mouse hovering or focussed), draw it flat.</a>
<a name="ln2188">	if ((flags &amp; B_FLAT) != 0</a>
<a name="ln2189">		&amp;&amp; (flags &amp; (B_ACTIVATED | B_PARTIALLY_ACTIVATED)) == 0</a>
<a name="ln2190">		&amp;&amp; ((flags &amp; (B_HOVER | B_FOCUSED)) == 0</a>
<a name="ln2191">			|| (flags &amp; B_DISABLED) != 0)) {</a>
<a name="ln2192">		_DrawFrame(view, rect, background, background, background,</a>
<a name="ln2193">			background, borders);</a>
<a name="ln2194">		_DrawFrame(view, rect, background, background, background,</a>
<a name="ln2195">			background, borders);</a>
<a name="ln2196">		view-&gt;PopState();</a>
<a name="ln2197">		return;</a>
<a name="ln2198">	}</a>
<a name="ln2199"> </a>
<a name="ln2200">	// outer edge colors</a>
<a name="ln2201">	rgb_color edgeLightColor;</a>
<a name="ln2202">	rgb_color edgeShadowColor;</a>
<a name="ln2203"> </a>
<a name="ln2204">	// default button frame color</a>
<a name="ln2205">	rgb_color defaultIndicatorColor = ui_color(B_CONTROL_BORDER_COLOR);</a>
<a name="ln2206">	rgb_color cornerBgColor;</a>
<a name="ln2207"> </a>
<a name="ln2208">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln2209">		defaultIndicatorColor = disable_color(defaultIndicatorColor,</a>
<a name="ln2210">			background);</a>
<a name="ln2211">	}</a>
<a name="ln2212"> </a>
<a name="ln2213">	drawing_mode oldMode = view-&gt;DrawingMode();</a>
<a name="ln2214"> </a>
<a name="ln2215">	if ((flags &amp; B_DEFAULT_BUTTON) != 0) {</a>
<a name="ln2216">		cornerBgColor = defaultIndicatorColor;</a>
<a name="ln2217">		edgeLightColor = _EdgeLightColor(defaultIndicatorColor,</a>
<a name="ln2218">			contrast * ((flags &amp; B_DISABLED) != 0 ? 0.3 : 0.8),</a>
<a name="ln2219">			brightness * ((flags &amp; B_DISABLED) != 0 ? 1.0 : 0.9), flags);</a>
<a name="ln2220">		edgeShadowColor = _EdgeShadowColor(defaultIndicatorColor,</a>
<a name="ln2221">			contrast * ((flags &amp; B_DISABLED) != 0 ? 0.3 : 0.8),</a>
<a name="ln2222">			brightness * ((flags &amp; B_DISABLED) != 0 ? 1.0 : 0.9), flags);</a>
<a name="ln2223"> </a>
<a name="ln2224">		// draw default button indicator</a>
<a name="ln2225">		// Allow a 1-pixel border of the background to come through.</a>
<a name="ln2226">		rect.InsetBy(1, 1);</a>
<a name="ln2227"> </a>
<a name="ln2228">		view-&gt;SetHighColor(defaultIndicatorColor);</a>
<a name="ln2229">		view-&gt;StrokeRoundRect(rect, leftTopRadius, leftTopRadius);</a>
<a name="ln2230">		rect.InsetBy(1, 1);</a>
<a name="ln2231"> </a>
<a name="ln2232">		view-&gt;StrokeRoundRect(rect, leftTopRadius, leftTopRadius);</a>
<a name="ln2233">		rect.InsetBy(1, 1);</a>
<a name="ln2234">	} else {</a>
<a name="ln2235">		cornerBgColor = background;</a>
<a name="ln2236">		if ((flags &amp; B_BLEND_FRAME) != 0) {</a>
<a name="ln2237">			// set the background color to transparent for the case</a>
<a name="ln2238">			// that we are on the desktop</a>
<a name="ln2239">			cornerBgColor.alpha = 0;</a>
<a name="ln2240">			view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln2241">		}</a>
<a name="ln2242"> </a>
<a name="ln2243">		edgeLightColor = _EdgeLightColor(background,</a>
<a name="ln2244">			contrast * ((flags &amp; B_DISABLED) != 0 ? 0.0 : 1.0),</a>
<a name="ln2245">			brightness * 1.0, flags);</a>
<a name="ln2246">		edgeShadowColor = _EdgeShadowColor(background,</a>
<a name="ln2247">			contrast * (flags &amp; B_DISABLED) != 0 ? 0.0 : 1.0,</a>
<a name="ln2248">			brightness * 1.0, flags);</a>
<a name="ln2249">	}</a>
<a name="ln2250"> </a>
<a name="ln2251">	// frame colors</a>
<a name="ln2252">	rgb_color frameLightColor  = _FrameLightColor(base, flags);</a>
<a name="ln2253">	rgb_color frameShadowColor = _FrameShadowColor(base, flags);</a>
<a name="ln2254"> </a>
<a name="ln2255">	// rounded corners</a>
<a name="ln2256"> </a>
<a name="ln2257">	if ((borders &amp; B_LEFT_BORDER) != 0 &amp;&amp; (borders &amp; B_TOP_BORDER) != 0</a>
<a name="ln2258">		&amp;&amp; leftTopRadius &gt; 0) {</a>
<a name="ln2259">		// draw left top rounded corner</a>
<a name="ln2260">		BRect leftTopCorner(floorf(rect.left), floorf(rect.top),</a>
<a name="ln2261">			floorf(rect.left + leftTopRadius),</a>
<a name="ln2262">			floorf(rect.top + leftTopRadius));</a>
<a name="ln2263">		clipping.Exclude(leftTopCorner);</a>
<a name="ln2264">		_DrawRoundCornerFrameLeftTop(view, leftTopCorner, updateRect,</a>
<a name="ln2265">			cornerBgColor, edgeShadowColor, frameLightColor);</a>
<a name="ln2266">	}</a>
<a name="ln2267"> </a>
<a name="ln2268">	if ((borders &amp; B_TOP_BORDER) != 0 &amp;&amp; (borders &amp; B_RIGHT_BORDER) != 0</a>
<a name="ln2269">		&amp;&amp; rightTopRadius &gt; 0) {</a>
<a name="ln2270">		// draw right top rounded corner</a>
<a name="ln2271">		BRect rightTopCorner(floorf(rect.right - rightTopRadius),</a>
<a name="ln2272">			floorf(rect.top), floorf(rect.right),</a>
<a name="ln2273">			floorf(rect.top + rightTopRadius));</a>
<a name="ln2274">		clipping.Exclude(rightTopCorner);</a>
<a name="ln2275">		_DrawRoundCornerFrameRightTop(view, rightTopCorner, updateRect,</a>
<a name="ln2276">			cornerBgColor, edgeShadowColor, edgeLightColor,</a>
<a name="ln2277">			frameLightColor, frameShadowColor);</a>
<a name="ln2278">	}</a>
<a name="ln2279"> </a>
<a name="ln2280">	if ((borders &amp; B_LEFT_BORDER) != 0 &amp;&amp; (borders &amp; B_BOTTOM_BORDER) != 0</a>
<a name="ln2281">		&amp;&amp; leftBottomRadius &gt; 0) {</a>
<a name="ln2282">		// draw left bottom rounded corner</a>
<a name="ln2283">		BRect leftBottomCorner(floorf(rect.left),</a>
<a name="ln2284">			floorf(rect.bottom - leftBottomRadius),</a>
<a name="ln2285">			floorf(rect.left + leftBottomRadius), floorf(rect.bottom));</a>
<a name="ln2286">		clipping.Exclude(leftBottomCorner);</a>
<a name="ln2287">		_DrawRoundCornerFrameLeftBottom(view, leftBottomCorner, updateRect,</a>
<a name="ln2288">			cornerBgColor, edgeShadowColor, edgeLightColor,</a>
<a name="ln2289">			frameLightColor, frameShadowColor);</a>
<a name="ln2290">	}</a>
<a name="ln2291"> </a>
<a name="ln2292">	if ((borders &amp; B_RIGHT_BORDER) != 0 &amp;&amp; (borders &amp; B_BOTTOM_BORDER) != 0</a>
<a name="ln2293">		&amp;&amp; rightBottomRadius &gt; 0) {</a>
<a name="ln2294">		// draw right bottom rounded corner</a>
<a name="ln2295">		BRect rightBottomCorner(floorf(rect.right - rightBottomRadius),</a>
<a name="ln2296">			floorf(rect.bottom - rightBottomRadius), floorf(rect.right),</a>
<a name="ln2297">			floorf(rect.bottom));</a>
<a name="ln2298">		clipping.Exclude(rightBottomCorner);</a>
<a name="ln2299">		_DrawRoundCornerFrameRightBottom(view, rightBottomCorner,</a>
<a name="ln2300">			updateRect, cornerBgColor, edgeLightColor, frameShadowColor);</a>
<a name="ln2301">	}</a>
<a name="ln2302"> </a>
<a name="ln2303">	// clip out the corners</a>
<a name="ln2304">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln2305"> </a>
<a name="ln2306">	// draw outer edge</a>
<a name="ln2307">	if ((flags &amp; B_DEFAULT_BUTTON) != 0) {</a>
<a name="ln2308">		_DrawOuterResessedFrame(view, rect, defaultIndicatorColor,</a>
<a name="ln2309">			contrast * ((flags &amp; B_DISABLED) != 0 ? 0.3 : 0.8),</a>
<a name="ln2310">			brightness * ((flags &amp; B_DISABLED) != 0 ? 1.0 : 0.9),</a>
<a name="ln2311">			flags, borders);</a>
<a name="ln2312">	} else {</a>
<a name="ln2313">		_DrawOuterResessedFrame(view, rect, background,</a>
<a name="ln2314">			contrast * ((flags &amp; B_DISABLED) != 0 ? 0.0 : 1.0),</a>
<a name="ln2315">			brightness * 1.0, flags, borders);</a>
<a name="ln2316">	}</a>
<a name="ln2317"> </a>
<a name="ln2318">	view-&gt;SetDrawingMode(oldMode);</a>
<a name="ln2319"> </a>
<a name="ln2320">	// draw frame</a>
<a name="ln2321">	if ((flags &amp; B_BLEND_FRAME) != 0) {</a>
<a name="ln2322">		drawing_mode oldDrawingMode = view-&gt;DrawingMode();</a>
<a name="ln2323">		view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln2324"> </a>
<a name="ln2325">		_DrawFrame(view, rect, frameLightColor, frameLightColor,</a>
<a name="ln2326">			frameShadowColor, frameShadowColor, borders);</a>
<a name="ln2327"> </a>
<a name="ln2328">		view-&gt;SetDrawingMode(oldDrawingMode);</a>
<a name="ln2329">	} else {</a>
<a name="ln2330">		_DrawFrame(view, rect, frameLightColor, frameLightColor,</a>
<a name="ln2331">			frameShadowColor, frameShadowColor, borders);</a>
<a name="ln2332">	}</a>
<a name="ln2333"> </a>
<a name="ln2334">	// restore the clipping constraints of the view</a>
<a name="ln2335">	view-&gt;PopState();</a>
<a name="ln2336">}</a>
<a name="ln2337"> </a>
<a name="ln2338"> </a>
<a name="ln2339">void</a>
<a name="ln2340">HaikuControlLook::_DrawOuterResessedFrame(BView* view, BRect&amp; rect,</a>
<a name="ln2341">	const rgb_color&amp; base, float contrast, float brightness, uint32 flags,</a>
<a name="ln2342">	uint32 borders)</a>
<a name="ln2343">{</a>
<a name="ln2344">	rgb_color edgeLightColor = _EdgeLightColor(base, contrast,</a>
<a name="ln2345">		brightness, flags);</a>
<a name="ln2346">	rgb_color edgeShadowColor = _EdgeShadowColor(base, contrast,</a>
<a name="ln2347">		brightness, flags);</a>
<a name="ln2348"> </a>
<a name="ln2349">	if ((flags &amp; B_BLEND_FRAME) != 0) {</a>
<a name="ln2350">		// assumes the background has already been painted</a>
<a name="ln2351">		drawing_mode oldDrawingMode = view-&gt;DrawingMode();</a>
<a name="ln2352">		view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln2353"> </a>
<a name="ln2354">		_DrawFrame(view, rect, edgeShadowColor, edgeShadowColor,</a>
<a name="ln2355">			edgeLightColor, edgeLightColor, borders);</a>
<a name="ln2356"> </a>
<a name="ln2357">		view-&gt;SetDrawingMode(oldDrawingMode);</a>
<a name="ln2358">	} else {</a>
<a name="ln2359">		_DrawFrame(view, rect, edgeShadowColor, edgeShadowColor,</a>
<a name="ln2360">			edgeLightColor, edgeLightColor, borders);</a>
<a name="ln2361">	}</a>
<a name="ln2362">}</a>
<a name="ln2363"> </a>
<a name="ln2364"> </a>
<a name="ln2365">void</a>
<a name="ln2366">HaikuControlLook::_DrawFrame(BView* view, BRect&amp; rect, const rgb_color&amp; left,</a>
<a name="ln2367">	const rgb_color&amp; top, const rgb_color&amp; right, const rgb_color&amp; bottom,</a>
<a name="ln2368">	uint32 borders)</a>
<a name="ln2369">{</a>
<a name="ln2370">	view-&gt;BeginLineArray(4);</a>
<a name="ln2371"> </a>
<a name="ln2372">	if (borders &amp; B_LEFT_BORDER) {</a>
<a name="ln2373">		view-&gt;AddLine(</a>
<a name="ln2374">			BPoint(rect.left, rect.bottom),</a>
<a name="ln2375">			BPoint(rect.left, rect.top), left);</a>
<a name="ln2376">		rect.left++;</a>
<a name="ln2377">	}</a>
<a name="ln2378">	if (borders &amp; B_TOP_BORDER) {</a>
<a name="ln2379">		view-&gt;AddLine(</a>
<a name="ln2380">			BPoint(rect.left, rect.top),</a>
<a name="ln2381">			BPoint(rect.right, rect.top), top);</a>
<a name="ln2382">		rect.top++;</a>
<a name="ln2383">	}</a>
<a name="ln2384">	if (borders &amp; B_RIGHT_BORDER) {</a>
<a name="ln2385">		view-&gt;AddLine(</a>
<a name="ln2386">			BPoint(rect.right, rect.top),</a>
<a name="ln2387">			BPoint(rect.right, rect.bottom), right);</a>
<a name="ln2388">		rect.right--;</a>
<a name="ln2389">	}</a>
<a name="ln2390">	if (borders &amp; B_BOTTOM_BORDER) {</a>
<a name="ln2391">		view-&gt;AddLine(</a>
<a name="ln2392">			BPoint(rect.left, rect.bottom),</a>
<a name="ln2393">			BPoint(rect.right, rect.bottom), bottom);</a>
<a name="ln2394">		rect.bottom--;</a>
<a name="ln2395">	}</a>
<a name="ln2396"> </a>
<a name="ln2397">	view-&gt;EndLineArray();</a>
<a name="ln2398">}</a>
<a name="ln2399"> </a>
<a name="ln2400"> </a>
<a name="ln2401">void</a>
<a name="ln2402">HaikuControlLook::_DrawFrame(BView* view, BRect&amp; rect, const rgb_color&amp; left,</a>
<a name="ln2403">	const rgb_color&amp; top, const rgb_color&amp; right, const rgb_color&amp; bottom,</a>
<a name="ln2404">	const rgb_color&amp; rightTop, const rgb_color&amp; leftBottom, uint32 borders)</a>
<a name="ln2405">{</a>
<a name="ln2406">	view-&gt;BeginLineArray(6);</a>
<a name="ln2407"> </a>
<a name="ln2408">	if (borders &amp; B_TOP_BORDER) {</a>
<a name="ln2409">		if (borders &amp; B_RIGHT_BORDER) {</a>
<a name="ln2410">			view-&gt;AddLine(</a>
<a name="ln2411">				BPoint(rect.left, rect.top),</a>
<a name="ln2412">				BPoint(rect.right - 1, rect.top), top);</a>
<a name="ln2413">			view-&gt;AddLine(</a>
<a name="ln2414">				BPoint(rect.right, rect.top),</a>
<a name="ln2415">				BPoint(rect.right, rect.top), rightTop);</a>
<a name="ln2416">		} else {</a>
<a name="ln2417">			view-&gt;AddLine(</a>
<a name="ln2418">				BPoint(rect.left, rect.top),</a>
<a name="ln2419">				BPoint(rect.right, rect.top), top);</a>
<a name="ln2420">		}</a>
<a name="ln2421">		rect.top++;</a>
<a name="ln2422">	}</a>
<a name="ln2423"> </a>
<a name="ln2424">	if (borders &amp; B_LEFT_BORDER) {</a>
<a name="ln2425">		view-&gt;AddLine(</a>
<a name="ln2426">			BPoint(rect.left, rect.top),</a>
<a name="ln2427">			BPoint(rect.left, rect.bottom - 1), left);</a>
<a name="ln2428">		view-&gt;AddLine(</a>
<a name="ln2429">			BPoint(rect.left, rect.bottom),</a>
<a name="ln2430">			BPoint(rect.left, rect.bottom), leftBottom);</a>
<a name="ln2431">		rect.left++;</a>
<a name="ln2432">	}</a>
<a name="ln2433"> </a>
<a name="ln2434">	if (borders &amp; B_BOTTOM_BORDER) {</a>
<a name="ln2435">		view-&gt;AddLine(</a>
<a name="ln2436">			BPoint(rect.left, rect.bottom),</a>
<a name="ln2437">			BPoint(rect.right, rect.bottom), bottom);</a>
<a name="ln2438">		rect.bottom--;</a>
<a name="ln2439">	}</a>
<a name="ln2440"> </a>
<a name="ln2441">	if (borders &amp; B_RIGHT_BORDER) {</a>
<a name="ln2442">		view-&gt;AddLine(</a>
<a name="ln2443">			BPoint(rect.right, rect.bottom),</a>
<a name="ln2444">			BPoint(rect.right, rect.top), right);</a>
<a name="ln2445">		rect.right--;</a>
<a name="ln2446">	}</a>
<a name="ln2447"> </a>
<a name="ln2448">	view-&gt;EndLineArray();</a>
<a name="ln2449">}</a>
<a name="ln2450"> </a>
<a name="ln2451"> </a>
<a name="ln2452">void</a>
<a name="ln2453">HaikuControlLook::_DrawButtonBackground(BView* view, BRect&amp; rect,</a>
<a name="ln2454">	const BRect&amp; updateRect, float leftTopRadius, float rightTopRadius,</a>
<a name="ln2455">	float leftBottomRadius, float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln2456">	bool popupIndicator, uint32 flags, uint32 borders, orientation orientation)</a>
<a name="ln2457">{</a>
<a name="ln2458">	if (!rect.IsValid())</a>
<a name="ln2459">		return;</a>
<a name="ln2460"> </a>
<a name="ln2461">	// save the clipping constraints of the view</a>
<a name="ln2462">	view-&gt;PushState();</a>
<a name="ln2463"> </a>
<a name="ln2464">	// set clipping constraints to updateRect</a>
<a name="ln2465">	BRegion clipping(updateRect);</a>
<a name="ln2466">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln2467"> </a>
<a name="ln2468">	// If the button is flat and neither activated nor otherwise highlighted</a>
<a name="ln2469">	// (mouse hovering or focussed), draw it flat.</a>
<a name="ln2470">	if ((flags &amp; B_FLAT) != 0</a>
<a name="ln2471">		&amp;&amp; (flags &amp; (B_ACTIVATED | B_PARTIALLY_ACTIVATED)) == 0</a>
<a name="ln2472">		&amp;&amp; ((flags &amp; (B_HOVER | B_FOCUSED)) == 0</a>
<a name="ln2473">			|| (flags &amp; B_DISABLED) != 0)) {</a>
<a name="ln2474">		_DrawFlatButtonBackground(view, rect, updateRect, base, popupIndicator,</a>
<a name="ln2475">			flags, borders, orientation);</a>
<a name="ln2476">	} else {</a>
<a name="ln2477">		_DrawNonFlatButtonBackground(view, rect, updateRect, clipping,</a>
<a name="ln2478">			leftTopRadius, rightTopRadius, leftBottomRadius, rightBottomRadius,</a>
<a name="ln2479">			base, popupIndicator, flags, borders, orientation);</a>
<a name="ln2480">	}</a>
<a name="ln2481"> </a>
<a name="ln2482">	// restore the clipping constraints of the view</a>
<a name="ln2483">	view-&gt;PopState();</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486"> </a>
<a name="ln2487">void</a>
<a name="ln2488">HaikuControlLook::_DrawFlatButtonBackground(BView* view, BRect&amp; rect,</a>
<a name="ln2489">	const BRect&amp; updateRect, const rgb_color&amp; base, bool popupIndicator,</a>
<a name="ln2490">	uint32 flags, uint32 borders, orientation orientation)</a>
<a name="ln2491">{</a>
<a name="ln2492">	_DrawFrame(view, rect, base, base, base, base, borders);</a>
<a name="ln2493">		// Not an actual frame, but the method insets our rect as needed.</a>
<a name="ln2494"> </a>
<a name="ln2495">	view-&gt;SetHighColor(base);</a>
<a name="ln2496">	view-&gt;FillRect(rect);</a>
<a name="ln2497"> </a>
<a name="ln2498">	if (popupIndicator) {</a>
<a name="ln2499">		BRect indicatorRect(rect);</a>
<a name="ln2500">		rect.right -= kButtonPopUpIndicatorWidth;</a>
<a name="ln2501">		indicatorRect.left = rect.right + 3;</a>
<a name="ln2502">			// 2 pixels for the separator</a>
<a name="ln2503"> </a>
<a name="ln2504">		view-&gt;SetHighColor(base);</a>
<a name="ln2505">		view-&gt;FillRect(indicatorRect);</a>
<a name="ln2506"> </a>
<a name="ln2507">		_DrawPopUpMarker(view, indicatorRect, base, flags);</a>
<a name="ln2508">	}</a>
<a name="ln2509">}</a>
<a name="ln2510"> </a>
<a name="ln2511"> </a>
<a name="ln2512">void</a>
<a name="ln2513">HaikuControlLook::_DrawNonFlatButtonBackground(BView* view, BRect&amp; rect,</a>
<a name="ln2514">	const BRect&amp; updateRect, BRegion&amp; clipping, float leftTopRadius,</a>
<a name="ln2515">	float rightTopRadius, float leftBottomRadius, float rightBottomRadius,</a>
<a name="ln2516">	const rgb_color&amp; base, bool popupIndicator, uint32 flags, uint32 borders,</a>
<a name="ln2517">	orientation orientation)</a>
<a name="ln2518">{</a>
<a name="ln2519">	// inner bevel colors</a>
<a name="ln2520">	rgb_color bevelLightColor  = _BevelLightColor(base, flags);</a>
<a name="ln2521">	rgb_color bevelShadowColor = _BevelShadowColor(base, flags);</a>
<a name="ln2522"> </a>
<a name="ln2523">	// button background color</a>
<a name="ln2524">	rgb_color buttonBgColor;</a>
<a name="ln2525">	if ((flags &amp; B_DISABLED) != 0)</a>
<a name="ln2526">		buttonBgColor = tint_color(base, 0.7);</a>
<a name="ln2527">	else</a>
<a name="ln2528">		buttonBgColor = tint_color(base, B_LIGHTEN_1_TINT);</a>
<a name="ln2529"> </a>
<a name="ln2530">	// surface top gradient</a>
<a name="ln2531">	BGradientLinear fillGradient;</a>
<a name="ln2532">	_MakeButtonGradient(fillGradient, rect, base, flags, orientation);</a>
<a name="ln2533"> </a>
<a name="ln2534">	// rounded corners</a>
<a name="ln2535"> </a>
<a name="ln2536">	if ((borders &amp; B_LEFT_BORDER) != 0 &amp;&amp; (borders &amp; B_TOP_BORDER) != 0</a>
<a name="ln2537">		&amp;&amp; leftTopRadius &gt; 0) {</a>
<a name="ln2538">		// draw left top rounded corner</a>
<a name="ln2539">		BRect leftTopCorner(floorf(rect.left), floorf(rect.top),</a>
<a name="ln2540">			floorf(rect.left + leftTopRadius - 2.0),</a>
<a name="ln2541">			floorf(rect.top + leftTopRadius - 2.0));</a>
<a name="ln2542">		clipping.Exclude(leftTopCorner);</a>
<a name="ln2543">		_DrawRoundCornerBackgroundLeftTop(view, leftTopCorner, updateRect,</a>
<a name="ln2544">			bevelLightColor, fillGradient);</a>
<a name="ln2545">	}</a>
<a name="ln2546"> </a>
<a name="ln2547">	if ((borders &amp; B_TOP_BORDER) != 0 &amp;&amp; (borders &amp; B_RIGHT_BORDER) != 0</a>
<a name="ln2548">		&amp;&amp; rightTopRadius &gt; 0) {</a>
<a name="ln2549">		// draw right top rounded corner</a>
<a name="ln2550">		BRect rightTopCorner(floorf(rect.right - rightTopRadius + 2.0),</a>
<a name="ln2551">			floorf(rect.top), floorf(rect.right),</a>
<a name="ln2552">			floorf(rect.top + rightTopRadius - 2.0));</a>
<a name="ln2553">		clipping.Exclude(rightTopCorner);</a>
<a name="ln2554">		_DrawRoundCornerBackgroundRightTop(view, rightTopCorner,</a>
<a name="ln2555">			updateRect, bevelLightColor, bevelShadowColor, fillGradient);</a>
<a name="ln2556">	}</a>
<a name="ln2557"> </a>
<a name="ln2558">	if ((borders &amp; B_LEFT_BORDER) != 0 &amp;&amp; (borders &amp; B_BOTTOM_BORDER) != 0</a>
<a name="ln2559">		&amp;&amp; leftBottomRadius &gt; 0) {</a>
<a name="ln2560">		// draw left bottom rounded corner</a>
<a name="ln2561">		BRect leftBottomCorner(floorf(rect.left),</a>
<a name="ln2562">			floorf(rect.bottom - leftBottomRadius + 2.0),</a>
<a name="ln2563">			floorf(rect.left + leftBottomRadius - 2.0),</a>
<a name="ln2564">			floorf(rect.bottom));</a>
<a name="ln2565">		clipping.Exclude(leftBottomCorner);</a>
<a name="ln2566">		_DrawRoundCornerBackgroundLeftBottom(view, leftBottomCorner,</a>
<a name="ln2567">			updateRect, bevelLightColor, bevelShadowColor, fillGradient);</a>
<a name="ln2568">	}</a>
<a name="ln2569"> </a>
<a name="ln2570">	if ((borders &amp; B_RIGHT_BORDER) != 0 &amp;&amp; (borders &amp; B_BOTTOM_BORDER) != 0</a>
<a name="ln2571">		&amp;&amp; rightBottomRadius &gt; 0) {</a>
<a name="ln2572">		// draw right bottom rounded corner</a>
<a name="ln2573">		BRect rightBottomCorner(floorf(rect.right - rightBottomRadius + 2.0),</a>
<a name="ln2574">			floorf(rect.bottom - rightBottomRadius + 2.0), floorf(rect.right),</a>
<a name="ln2575">			floorf(rect.bottom));</a>
<a name="ln2576">		clipping.Exclude(rightBottomCorner);</a>
<a name="ln2577">		_DrawRoundCornerBackgroundRightBottom(view, rightBottomCorner,</a>
<a name="ln2578">			updateRect, bevelShadowColor, fillGradient);</a>
<a name="ln2579">	}</a>
<a name="ln2580"> </a>
<a name="ln2581">	// clip out the corners</a>
<a name="ln2582">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln2583"> </a>
<a name="ln2584">	// draw inner bevel</a>
<a name="ln2585"> </a>
<a name="ln2586">	if ((flags &amp; B_ACTIVATED) != 0) {</a>
<a name="ln2587">		view-&gt;BeginLineArray(4);</a>
<a name="ln2588"> </a>
<a name="ln2589">		// shadow along left/top borders</a>
<a name="ln2590">		if (borders &amp; B_LEFT_BORDER) {</a>
<a name="ln2591">			view-&gt;AddLine(BPoint(rect.left, rect.top),</a>
<a name="ln2592">				BPoint(rect.left, rect.bottom), bevelLightColor);</a>
<a name="ln2593">			rect.left++;</a>
<a name="ln2594">		}</a>
<a name="ln2595">		if (borders &amp; B_TOP_BORDER) {</a>
<a name="ln2596">			view-&gt;AddLine(BPoint(rect.left, rect.top),</a>
<a name="ln2597">				BPoint(rect.right, rect.top), bevelLightColor);</a>
<a name="ln2598">			rect.top++;</a>
<a name="ln2599">		}</a>
<a name="ln2600"> </a>
<a name="ln2601">		// softer shadow along left/top borders</a>
<a name="ln2602">		if (borders &amp; B_LEFT_BORDER) {</a>
<a name="ln2603">			view-&gt;AddLine(BPoint(rect.left, rect.top),</a>
<a name="ln2604">				BPoint(rect.left, rect.bottom), bevelShadowColor);</a>
<a name="ln2605">			rect.left++;</a>
<a name="ln2606">		}</a>
<a name="ln2607">		if (borders &amp; B_TOP_BORDER) {</a>
<a name="ln2608">			view-&gt;AddLine(BPoint(rect.left, rect.top),</a>
<a name="ln2609">				BPoint(rect.right, rect.top), bevelShadowColor);</a>
<a name="ln2610">			rect.top++;</a>
<a name="ln2611">		}</a>
<a name="ln2612"> </a>
<a name="ln2613">		view-&gt;EndLineArray();</a>
<a name="ln2614">	} else {</a>
<a name="ln2615">		_DrawFrame(view, rect,</a>
<a name="ln2616">			bevelLightColor, bevelLightColor,</a>
<a name="ln2617">			bevelShadowColor, bevelShadowColor,</a>
<a name="ln2618">			buttonBgColor, buttonBgColor, borders);</a>
<a name="ln2619">	}</a>
<a name="ln2620"> </a>
<a name="ln2621">	if (popupIndicator) {</a>
<a name="ln2622">		BRect indicatorRect(rect);</a>
<a name="ln2623">		rect.right -= kButtonPopUpIndicatorWidth;</a>
<a name="ln2624">		indicatorRect.left = rect.right + 3;</a>
<a name="ln2625">			// 2 pixels for the separator</a>
<a name="ln2626"> </a>
<a name="ln2627">		// Even when depressed we want the pop-up indicator background and</a>
<a name="ln2628">		// separator to cover the area up to the top.</a>
<a name="ln2629">		if ((flags &amp; B_ACTIVATED) != 0)</a>
<a name="ln2630">			indicatorRect.top--;</a>
<a name="ln2631"> </a>
<a name="ln2632">		// draw the separator</a>
<a name="ln2633">		rgb_color separatorBaseColor = base;</a>
<a name="ln2634">		if ((flags &amp; B_ACTIVATED) != 0)</a>
<a name="ln2635">			separatorBaseColor = tint_color(base, B_DARKEN_1_TINT);</a>
<a name="ln2636"> </a>
<a name="ln2637">		rgb_color separatorLightColor = _EdgeLightColor(separatorBaseColor,</a>
<a name="ln2638">			(flags &amp; B_DISABLED) != 0 ? 0.7 : 1.0, 1.0, flags);</a>
<a name="ln2639">		rgb_color separatorShadowColor = _EdgeShadowColor(separatorBaseColor,</a>
<a name="ln2640">			(flags &amp; B_DISABLED) != 0 ? 0.7 : 1.0, 1.0, flags);</a>
<a name="ln2641"> </a>
<a name="ln2642">		view-&gt;BeginLineArray(2);</a>
<a name="ln2643"> </a>
<a name="ln2644">		view-&gt;AddLine(BPoint(indicatorRect.left - 2, indicatorRect.top),</a>
<a name="ln2645">			BPoint(indicatorRect.left - 2, indicatorRect.bottom),</a>
<a name="ln2646">			separatorShadowColor);</a>
<a name="ln2647">		view-&gt;AddLine(BPoint(indicatorRect.left - 1, indicatorRect.top),</a>
<a name="ln2648">			BPoint(indicatorRect.left - 1, indicatorRect.bottom),</a>
<a name="ln2649">			separatorLightColor);</a>
<a name="ln2650"> </a>
<a name="ln2651">		view-&gt;EndLineArray();</a>
<a name="ln2652"> </a>
<a name="ln2653">		// draw background and pop-up marker</a>
<a name="ln2654">		_DrawMenuFieldBackgroundInside(view, indicatorRect, updateRect,</a>
<a name="ln2655">			0.0f, rightTopRadius, 0.0f, rightBottomRadius, base, flags, 0);</a>
<a name="ln2656"> </a>
<a name="ln2657">		if ((flags &amp; B_ACTIVATED) != 0)</a>
<a name="ln2658">			indicatorRect.top++;</a>
<a name="ln2659"> </a>
<a name="ln2660">		_DrawPopUpMarker(view, indicatorRect, base, flags);</a>
<a name="ln2661">	}</a>
<a name="ln2662"> </a>
<a name="ln2663">	// fill in the background</a>
<a name="ln2664">	view-&gt;FillRect(rect, fillGradient);</a>
<a name="ln2665">}</a>
<a name="ln2666"> </a>
<a name="ln2667"> </a>
<a name="ln2668">void</a>
<a name="ln2669">HaikuControlLook::_DrawPopUpMarker(BView* view, const BRect&amp; rect,</a>
<a name="ln2670">	const rgb_color&amp; base, uint32 flags)</a>
<a name="ln2671">{</a>
<a name="ln2672">	BPoint center(roundf((rect.left + rect.right) / 2.0),</a>
<a name="ln2673">		roundf((rect.top + rect.bottom) / 2.0));</a>
<a name="ln2674">	BPoint triangle[3];</a>
<a name="ln2675">	triangle[0] = center + BPoint(-2.5, -0.5);</a>
<a name="ln2676">	triangle[1] = center + BPoint(2.5, -0.5);</a>
<a name="ln2677">	triangle[2] = center + BPoint(0.0, 2.0);</a>
<a name="ln2678"> </a>
<a name="ln2679">	uint32 viewFlags = view-&gt;Flags();</a>
<a name="ln2680">	view-&gt;SetFlags(viewFlags | B_SUBPIXEL_PRECISE);</a>
<a name="ln2681"> </a>
<a name="ln2682">	rgb_color markColor;</a>
<a name="ln2683">	if ((flags &amp; B_DISABLED) != 0)</a>
<a name="ln2684">		markColor = tint_color(base, 1.35);</a>
<a name="ln2685">	else</a>
<a name="ln2686">		markColor = tint_color(base, 1.65);</a>
<a name="ln2687"> </a>
<a name="ln2688">	view-&gt;SetHighColor(markColor);</a>
<a name="ln2689">	view-&gt;FillTriangle(triangle[0], triangle[1], triangle[2]);</a>
<a name="ln2690"> </a>
<a name="ln2691">	view-&gt;SetFlags(viewFlags);</a>
<a name="ln2692">}</a>
<a name="ln2693"> </a>
<a name="ln2694"> </a>
<a name="ln2695">void</a>
<a name="ln2696">HaikuControlLook::_DrawMenuFieldBackgroundOutside(BView* view, BRect&amp; rect,</a>
<a name="ln2697">	const BRect&amp; updateRect, float leftTopRadius, float rightTopRadius,</a>
<a name="ln2698">	float leftBottomRadius, float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln2699">	bool popupIndicator, uint32 flags)</a>
<a name="ln2700">{</a>
<a name="ln2701">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln2702">		return;</a>
<a name="ln2703"> </a>
<a name="ln2704">	if (popupIndicator) {</a>
<a name="ln2705">		BRect leftRect(rect);</a>
<a name="ln2706">		leftRect.right -= 10;</a>
<a name="ln2707"> </a>
<a name="ln2708">		BRect rightRect(rect);</a>
<a name="ln2709">		rightRect.left = rightRect.right - 9;</a>
<a name="ln2710"> </a>
<a name="ln2711">		_DrawMenuFieldBackgroundInside(view, leftRect, updateRect,</a>
<a name="ln2712">			leftTopRadius, 0.0f, leftBottomRadius, 0.0f, base, flags,</a>
<a name="ln2713">			B_LEFT_BORDER | B_TOP_BORDER | B_BOTTOM_BORDER);</a>
<a name="ln2714"> </a>
<a name="ln2715">		_DrawMenuFieldBackgroundInside(view, rightRect, updateRect,</a>
<a name="ln2716">			0.0f, rightTopRadius, 0.0f, rightBottomRadius, base, flags,</a>
<a name="ln2717">			B_TOP_BORDER | B_RIGHT_BORDER | B_BOTTOM_BORDER);</a>
<a name="ln2718"> </a>
<a name="ln2719">		_DrawPopUpMarker(view, rightRect, base, flags);</a>
<a name="ln2720"> </a>
<a name="ln2721">		// draw a line on the left of the popup frame</a>
<a name="ln2722">		rgb_color bevelShadowColor = _BevelShadowColor(base, flags);</a>
<a name="ln2723">		view-&gt;SetHighColor(bevelShadowColor);</a>
<a name="ln2724">		BPoint leftTopCorner(floorf(rightRect.left - 1.0),</a>
<a name="ln2725">			floorf(rightRect.top - 1.0));</a>
<a name="ln2726">		BPoint leftBottomCorner(floorf(rightRect.left - 1.0),</a>
<a name="ln2727">			floorf(rightRect.bottom + 1.0));</a>
<a name="ln2728">		view-&gt;StrokeLine(leftTopCorner, leftBottomCorner);</a>
<a name="ln2729"> </a>
<a name="ln2730">		rect = leftRect;</a>
<a name="ln2731">	} else {</a>
<a name="ln2732">		_DrawMenuFieldBackgroundInside(view, rect, updateRect, leftTopRadius,</a>
<a name="ln2733">			rightTopRadius, leftBottomRadius, rightBottomRadius, base, flags);</a>
<a name="ln2734">	}</a>
<a name="ln2735">}</a>
<a name="ln2736"> </a>
<a name="ln2737"> </a>
<a name="ln2738">void</a>
<a name="ln2739">HaikuControlLook::_DrawMenuFieldBackgroundInside(BView* view, BRect&amp; rect,</a>
<a name="ln2740">	const BRect&amp; updateRect, float leftTopRadius, float rightTopRadius,</a>
<a name="ln2741">	float leftBottomRadius, float rightBottomRadius, const rgb_color&amp; base,</a>
<a name="ln2742">	uint32 flags, uint32 borders)</a>
<a name="ln2743">{</a>
<a name="ln2744">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln2745">		return;</a>
<a name="ln2746"> </a>
<a name="ln2747">	// save the clipping constraints of the view</a>
<a name="ln2748">	view-&gt;PushState();</a>
<a name="ln2749"> </a>
<a name="ln2750">	// set clipping constraints to updateRect</a>
<a name="ln2751">	BRegion clipping(updateRect);</a>
<a name="ln2752">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln2753"> </a>
<a name="ln2754">	// frame colors</a>
<a name="ln2755">	rgb_color frameLightColor  = _FrameLightColor(base, flags);</a>
<a name="ln2756">	rgb_color frameShadowColor = _FrameShadowColor(base, flags);</a>
<a name="ln2757"> </a>
<a name="ln2758">	// indicator background color</a>
<a name="ln2759">	rgb_color indicatorBase;</a>
<a name="ln2760">	if ((borders &amp; B_LEFT_BORDER) != 0)</a>
<a name="ln2761">		indicatorBase = base;</a>
<a name="ln2762">	else {</a>
<a name="ln2763">		if ((flags &amp; B_DISABLED) != 0)</a>
<a name="ln2764">			indicatorBase = tint_color(base, 1.05);</a>
<a name="ln2765">		else</a>
<a name="ln2766">			indicatorBase = tint_color(base, 1.12);</a>
<a name="ln2767">	}</a>
<a name="ln2768"> </a>
<a name="ln2769">	// bevel colors</a>
<a name="ln2770">	rgb_color cornerColor = tint_color(indicatorBase, 0.85);</a>
<a name="ln2771">	rgb_color bevelColor1 = tint_color(indicatorBase, 0.3);</a>
<a name="ln2772">	rgb_color bevelColor2 = tint_color(indicatorBase, 0.5);</a>
<a name="ln2773">	rgb_color bevelColor3 = tint_color(indicatorBase, 1.03);</a>
<a name="ln2774"> </a>
<a name="ln2775">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln2776">		cornerColor = tint_color(indicatorBase, 0.8);</a>
<a name="ln2777">		bevelColor1 = tint_color(indicatorBase, 0.7);</a>
<a name="ln2778">		bevelColor2 = tint_color(indicatorBase, 0.8);</a>
<a name="ln2779">		bevelColor3 = tint_color(indicatorBase, 1.01);</a>
<a name="ln2780">	} else {</a>
<a name="ln2781">		cornerColor = tint_color(indicatorBase, 0.85);</a>
<a name="ln2782">		bevelColor1 = tint_color(indicatorBase, 0.3);</a>
<a name="ln2783">		bevelColor2 = tint_color(indicatorBase, 0.5);</a>
<a name="ln2784">		bevelColor3 = tint_color(indicatorBase, 1.03);</a>
<a name="ln2785">	}</a>
<a name="ln2786"> </a>
<a name="ln2787">	// surface top gradient</a>
<a name="ln2788">	BGradientLinear fillGradient;</a>
<a name="ln2789">	_MakeButtonGradient(fillGradient, rect, indicatorBase, flags);</a>
<a name="ln2790"> </a>
<a name="ln2791">	// rounded corners</a>
<a name="ln2792"> </a>
<a name="ln2793">	if ((borders &amp; B_LEFT_BORDER) != 0 &amp;&amp; (borders &amp; B_TOP_BORDER) != 0</a>
<a name="ln2794">		&amp;&amp; leftTopRadius &gt; 0) {</a>
<a name="ln2795">		// draw left top rounded corner</a>
<a name="ln2796">		BRect leftTopCorner(floorf(rect.left), floorf(rect.top),</a>
<a name="ln2797">			floorf(rect.left + leftTopRadius - 2.0),</a>
<a name="ln2798">			floorf(rect.top + leftTopRadius - 2.0));</a>
<a name="ln2799">		clipping.Exclude(leftTopCorner);</a>
<a name="ln2800"> </a>
<a name="ln2801">		BRegion cornerClipping(leftTopCorner);</a>
<a name="ln2802">		view-&gt;ConstrainClippingRegion(&amp;cornerClipping);</a>
<a name="ln2803"> </a>
<a name="ln2804">		BRect ellipseRect(leftTopCorner);</a>
<a name="ln2805">		ellipseRect.InsetBy(-1.0, -1.0);</a>
<a name="ln2806">		ellipseRect.right = ellipseRect.left + ellipseRect.Width() * 2;</a>
<a name="ln2807">		ellipseRect.bottom = ellipseRect.top + ellipseRect.Height() * 2;</a>
<a name="ln2808"> </a>
<a name="ln2809">		// draw the frame (again)</a>
<a name="ln2810">		view-&gt;SetHighColor(frameLightColor);</a>
<a name="ln2811">		view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln2812"> </a>
<a name="ln2813">		// draw the bevel and background</a>
<a name="ln2814">		_DrawRoundCornerBackgroundLeftTop(view, leftTopCorner, updateRect,</a>
<a name="ln2815">			bevelColor1, fillGradient);</a>
<a name="ln2816">	}</a>
<a name="ln2817"> </a>
<a name="ln2818">	if ((borders &amp; B_TOP_BORDER) != 0 &amp;&amp; (borders &amp; B_RIGHT_BORDER) != 0</a>
<a name="ln2819">		&amp;&amp; rightTopRadius &gt; 0) {</a>
<a name="ln2820">		// draw right top rounded corner</a>
<a name="ln2821">		BRect rightTopCorner(floorf(rect.right - rightTopRadius + 2.0),</a>
<a name="ln2822">			floorf(rect.top), floorf(rect.right),</a>
<a name="ln2823">			floorf(rect.top + rightTopRadius - 2.0));</a>
<a name="ln2824">		clipping.Exclude(rightTopCorner);</a>
<a name="ln2825"> </a>
<a name="ln2826">		BRegion cornerClipping(rightTopCorner);</a>
<a name="ln2827">		view-&gt;ConstrainClippingRegion(&amp;cornerClipping);</a>
<a name="ln2828"> </a>
<a name="ln2829">		BRect ellipseRect(rightTopCorner);</a>
<a name="ln2830">		ellipseRect.InsetBy(-1.0, -1.0);</a>
<a name="ln2831">		ellipseRect.left = ellipseRect.right - ellipseRect.Width() * 2;</a>
<a name="ln2832">		ellipseRect.bottom = ellipseRect.top + ellipseRect.Height() * 2;</a>
<a name="ln2833"> </a>
<a name="ln2834">		// draw the frame (again)</a>
<a name="ln2835">		if (frameLightColor == frameShadowColor) {</a>
<a name="ln2836">			view-&gt;SetHighColor(frameLightColor);</a>
<a name="ln2837">			view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln2838">		} else {</a>
<a name="ln2839">			BGradientLinear gradient;</a>
<a name="ln2840">			gradient.AddColor(frameLightColor, 0);</a>
<a name="ln2841">			gradient.AddColor(frameShadowColor, 255);</a>
<a name="ln2842">			gradient.SetStart(rightTopCorner.LeftTop());</a>
<a name="ln2843">			gradient.SetEnd(rightTopCorner.RightBottom());</a>
<a name="ln2844">			view-&gt;FillEllipse(ellipseRect, gradient);</a>
<a name="ln2845">		}</a>
<a name="ln2846"> </a>
<a name="ln2847">		// draw the bevel and background</a>
<a name="ln2848">		_DrawRoundCornerBackgroundRightTop(view, rightTopCorner, updateRect,</a>
<a name="ln2849">			bevelColor1, bevelColor3, fillGradient);</a>
<a name="ln2850">	}</a>
<a name="ln2851"> </a>
<a name="ln2852">	if ((borders &amp; B_LEFT_BORDER) != 0 &amp;&amp; (borders &amp; B_BOTTOM_BORDER) != 0</a>
<a name="ln2853">		&amp;&amp; leftBottomRadius &gt; 0) {</a>
<a name="ln2854">		// draw left bottom rounded corner</a>
<a name="ln2855">		BRect leftBottomCorner(floorf(rect.left),</a>
<a name="ln2856">			floorf(rect.bottom - leftBottomRadius + 2.0),</a>
<a name="ln2857">			floorf(rect.left + leftBottomRadius - 2.0),</a>
<a name="ln2858">			floorf(rect.bottom));</a>
<a name="ln2859">		clipping.Exclude(leftBottomCorner);</a>
<a name="ln2860"> </a>
<a name="ln2861">		BRegion cornerClipping(leftBottomCorner);</a>
<a name="ln2862">		view-&gt;ConstrainClippingRegion(&amp;cornerClipping);</a>
<a name="ln2863"> </a>
<a name="ln2864">		BRect ellipseRect(leftBottomCorner);</a>
<a name="ln2865">		ellipseRect.InsetBy(-1.0, -1.0);</a>
<a name="ln2866">		ellipseRect.right = ellipseRect.left + ellipseRect.Width() * 2;</a>
<a name="ln2867">		ellipseRect.top = ellipseRect.bottom - ellipseRect.Height() * 2;</a>
<a name="ln2868"> </a>
<a name="ln2869">		// draw the frame (again)</a>
<a name="ln2870">		if (frameLightColor == frameShadowColor) {</a>
<a name="ln2871">			view-&gt;SetHighColor(frameLightColor);</a>
<a name="ln2872">			view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln2873">		} else {</a>
<a name="ln2874">			BGradientLinear gradient;</a>
<a name="ln2875">			gradient.AddColor(frameLightColor, 0);</a>
<a name="ln2876">			gradient.AddColor(frameShadowColor, 255);</a>
<a name="ln2877">			gradient.SetStart(leftBottomCorner.LeftTop());</a>
<a name="ln2878">			gradient.SetEnd(leftBottomCorner.RightBottom());</a>
<a name="ln2879">			view-&gt;FillEllipse(ellipseRect, gradient);</a>
<a name="ln2880">		}</a>
<a name="ln2881"> </a>
<a name="ln2882">		// draw the bevel and background</a>
<a name="ln2883">		_DrawRoundCornerBackgroundLeftBottom(view, leftBottomCorner,</a>
<a name="ln2884">			updateRect, bevelColor2, bevelColor3, fillGradient);</a>
<a name="ln2885">	}</a>
<a name="ln2886"> </a>
<a name="ln2887">	if ((borders &amp; B_RIGHT_BORDER) != 0 &amp;&amp; (borders &amp; B_BOTTOM_BORDER) != 0</a>
<a name="ln2888">		&amp;&amp; rightBottomRadius &gt; 0) {</a>
<a name="ln2889">		// draw right bottom rounded corner</a>
<a name="ln2890">		BRect rightBottomCorner(floorf(rect.right - rightBottomRadius + 2.0),</a>
<a name="ln2891">			floorf(rect.bottom - rightBottomRadius + 2.0), floorf(rect.right),</a>
<a name="ln2892">			floorf(rect.bottom));</a>
<a name="ln2893">		clipping.Exclude(rightBottomCorner);</a>
<a name="ln2894"> </a>
<a name="ln2895">		BRegion cornerClipping(rightBottomCorner);</a>
<a name="ln2896">		view-&gt;ConstrainClippingRegion(&amp;cornerClipping);</a>
<a name="ln2897"> </a>
<a name="ln2898">		BRect ellipseRect(rightBottomCorner);</a>
<a name="ln2899">		ellipseRect.InsetBy(-1.0, -1.0);</a>
<a name="ln2900">		ellipseRect.left = ellipseRect.right - ellipseRect.Width() * 2;</a>
<a name="ln2901">		ellipseRect.top = ellipseRect.bottom - ellipseRect.Height() * 2;</a>
<a name="ln2902"> </a>
<a name="ln2903">		// draw the frame (again)</a>
<a name="ln2904">		view-&gt;SetHighColor(frameShadowColor);</a>
<a name="ln2905">		view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln2906"> </a>
<a name="ln2907">		// draw the bevel and background</a>
<a name="ln2908">		_DrawRoundCornerBackgroundRightBottom(view, rightBottomCorner,</a>
<a name="ln2909">			updateRect, bevelColor3, fillGradient);</a>
<a name="ln2910">	}</a>
<a name="ln2911"> </a>
<a name="ln2912">	// clip out the corners</a>
<a name="ln2913">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln2914"> </a>
<a name="ln2915">	// draw the bevel</a>
<a name="ln2916">	_DrawFrame(view, rect,</a>
<a name="ln2917">		bevelColor2, bevelColor1,</a>
<a name="ln2918">		bevelColor3, bevelColor3,</a>
<a name="ln2919">		cornerColor, cornerColor,</a>
<a name="ln2920">		borders);</a>
<a name="ln2921"> </a>
<a name="ln2922">	// fill in the background</a>
<a name="ln2923">	view-&gt;FillRect(rect, fillGradient);</a>
<a name="ln2924"> </a>
<a name="ln2925">	// restore the clipping constraints of the view</a>
<a name="ln2926">	view-&gt;PopState();</a>
<a name="ln2927">}</a>
<a name="ln2928"> </a>
<a name="ln2929"> </a>
<a name="ln2930">void</a>
<a name="ln2931">HaikuControlLook::_DrawRoundCornerLeftTop(BView* view, BRect&amp; cornerRect,</a>
<a name="ln2932">	const BRect&amp; updateRect, const rgb_color&amp; background,</a>
<a name="ln2933">	const rgb_color&amp; edgeColor, const rgb_color&amp; frameColor,</a>
<a name="ln2934">	const rgb_color&amp; bevelColor, const BGradientLinear&amp; fillGradient)</a>
<a name="ln2935">{</a>
<a name="ln2936">	_DrawRoundCornerFrameLeftTop(view, cornerRect, updateRect,</a>
<a name="ln2937">		background, edgeColor, frameColor);</a>
<a name="ln2938">	_DrawRoundCornerBackgroundLeftTop(view, cornerRect, updateRect,</a>
<a name="ln2939">		bevelColor, fillGradient);</a>
<a name="ln2940">}</a>
<a name="ln2941"> </a>
<a name="ln2942"> </a>
<a name="ln2943">void</a>
<a name="ln2944">HaikuControlLook::_DrawRoundCornerFrameLeftTop(BView* view, BRect&amp; cornerRect,</a>
<a name="ln2945">	const BRect&amp; updateRect, const rgb_color&amp; background,</a>
<a name="ln2946">	const rgb_color&amp; edgeColor, const rgb_color&amp; frameColor)</a>
<a name="ln2947">{</a>
<a name="ln2948">	// constrain clipping region to corner</a>
<a name="ln2949">	BRegion clipping(cornerRect);</a>
<a name="ln2950">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln2951"> </a>
<a name="ln2952">	// background</a>
<a name="ln2953">	view-&gt;SetHighColor(background);</a>
<a name="ln2954">	view-&gt;FillRect(cornerRect);</a>
<a name="ln2955"> </a>
<a name="ln2956">	// outer edge</a>
<a name="ln2957">	BRect ellipseRect(cornerRect);</a>
<a name="ln2958">	ellipseRect.right = ellipseRect.left + ellipseRect.Width() * 2;</a>
<a name="ln2959">	ellipseRect.bottom = ellipseRect.top + ellipseRect.Height() * 2;</a>
<a name="ln2960"> </a>
<a name="ln2961">	view-&gt;SetHighColor(edgeColor);</a>
<a name="ln2962">	view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln2963"> </a>
<a name="ln2964">	// frame</a>
<a name="ln2965">	ellipseRect.InsetBy(1, 1);</a>
<a name="ln2966">	cornerRect.left++;</a>
<a name="ln2967">	cornerRect.top++;</a>
<a name="ln2968">	view-&gt;SetHighColor(frameColor);</a>
<a name="ln2969">	view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln2970"> </a>
<a name="ln2971">	// prepare for bevel</a>
<a name="ln2972">	cornerRect.left++;</a>
<a name="ln2973">	cornerRect.top++;</a>
<a name="ln2974">}</a>
<a name="ln2975"> </a>
<a name="ln2976"> </a>
<a name="ln2977">void</a>
<a name="ln2978">HaikuControlLook::_DrawRoundCornerBackgroundLeftTop(BView* view, BRect&amp; cornerRect,</a>
<a name="ln2979">	const BRect&amp; updateRect, const rgb_color&amp; bevelColor,</a>
<a name="ln2980">	const BGradientLinear&amp; fillGradient)</a>
<a name="ln2981">{</a>
<a name="ln2982">	// constrain clipping region to corner</a>
<a name="ln2983">	BRegion clipping(cornerRect);</a>
<a name="ln2984">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln2985"> </a>
<a name="ln2986">	BRect ellipseRect(cornerRect);</a>
<a name="ln2987">	ellipseRect.right = ellipseRect.left + ellipseRect.Width() * 2;</a>
<a name="ln2988">	ellipseRect.bottom = ellipseRect.top + ellipseRect.Height() * 2;</a>
<a name="ln2989"> </a>
<a name="ln2990">	// bevel</a>
<a name="ln2991">	view-&gt;SetHighColor(bevelColor);</a>
<a name="ln2992">	view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln2993"> </a>
<a name="ln2994">	// gradient</a>
<a name="ln2995">	ellipseRect.InsetBy(1, 1);</a>
<a name="ln2996">	view-&gt;FillEllipse(ellipseRect, fillGradient);</a>
<a name="ln2997">}</a>
<a name="ln2998"> </a>
<a name="ln2999"> </a>
<a name="ln3000">void</a>
<a name="ln3001">HaikuControlLook::_DrawRoundCornerRightTop(BView* view, BRect&amp; cornerRect,</a>
<a name="ln3002">	const BRect&amp; updateRect, const rgb_color&amp; background,</a>
<a name="ln3003">	const rgb_color&amp; edgeTopColor, const rgb_color&amp; edgeRightColor,</a>
<a name="ln3004">	const rgb_color&amp; frameTopColor, const rgb_color&amp; frameRightColor,</a>
<a name="ln3005">	const rgb_color&amp; bevelTopColor, const rgb_color&amp; bevelRightColor,</a>
<a name="ln3006">	const BGradientLinear&amp; fillGradient)</a>
<a name="ln3007">{</a>
<a name="ln3008">	_DrawRoundCornerFrameRightTop(view, cornerRect, updateRect,</a>
<a name="ln3009">		background, edgeTopColor, edgeRightColor, frameTopColor,</a>
<a name="ln3010">		frameRightColor);</a>
<a name="ln3011">	_DrawRoundCornerBackgroundRightTop(view, cornerRect, updateRect,</a>
<a name="ln3012">		bevelTopColor, bevelRightColor, fillGradient);</a>
<a name="ln3013">}</a>
<a name="ln3014"> </a>
<a name="ln3015"> </a>
<a name="ln3016">void</a>
<a name="ln3017">HaikuControlLook::_DrawRoundCornerFrameRightTop(BView* view, BRect&amp; cornerRect,</a>
<a name="ln3018">	const BRect&amp; updateRect, const rgb_color&amp; background,</a>
<a name="ln3019">	const rgb_color&amp; edgeTopColor, const rgb_color&amp; edgeRightColor,</a>
<a name="ln3020">	const rgb_color&amp; frameTopColor, const rgb_color&amp; frameRightColor)</a>
<a name="ln3021">{</a>
<a name="ln3022">	// constrain clipping region to corner</a>
<a name="ln3023">	BRegion clipping(cornerRect);</a>
<a name="ln3024">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln3025"> </a>
<a name="ln3026">	// background</a>
<a name="ln3027">	view-&gt;SetHighColor(background);</a>
<a name="ln3028">	view-&gt;FillRect(cornerRect);</a>
<a name="ln3029"> </a>
<a name="ln3030">	// outer edge</a>
<a name="ln3031">	BRect ellipseRect(cornerRect);</a>
<a name="ln3032">	ellipseRect.left = ellipseRect.right - ellipseRect.Width() * 2;</a>
<a name="ln3033">	ellipseRect.bottom = ellipseRect.top + ellipseRect.Height() * 2;</a>
<a name="ln3034"> </a>
<a name="ln3035">	BGradientLinear gradient;</a>
<a name="ln3036">	gradient.AddColor(edgeTopColor, 0);</a>
<a name="ln3037">	gradient.AddColor(edgeRightColor, 255);</a>
<a name="ln3038">	gradient.SetStart(cornerRect.LeftTop());</a>
<a name="ln3039">	gradient.SetEnd(cornerRect.RightBottom());</a>
<a name="ln3040">	view-&gt;FillEllipse(ellipseRect, gradient);</a>
<a name="ln3041"> </a>
<a name="ln3042">	// frame</a>
<a name="ln3043">	ellipseRect.InsetBy(1, 1);</a>
<a name="ln3044">	cornerRect.right--;</a>
<a name="ln3045">	cornerRect.top++;</a>
<a name="ln3046">	if (frameTopColor == frameRightColor) {</a>
<a name="ln3047">		view-&gt;SetHighColor(frameTopColor);</a>
<a name="ln3048">		view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln3049">	} else {</a>
<a name="ln3050">		gradient.SetColor(0, frameTopColor);</a>
<a name="ln3051">		gradient.SetColor(1, frameRightColor);</a>
<a name="ln3052">		gradient.SetStart(cornerRect.LeftTop());</a>
<a name="ln3053">		gradient.SetEnd(cornerRect.RightBottom());</a>
<a name="ln3054">		view-&gt;FillEllipse(ellipseRect, gradient);</a>
<a name="ln3055">	}</a>
<a name="ln3056"> </a>
<a name="ln3057">	// prepare for bevel</a>
<a name="ln3058">	cornerRect.right--;</a>
<a name="ln3059">	cornerRect.top++;</a>
<a name="ln3060">}</a>
<a name="ln3061"> </a>
<a name="ln3062"> </a>
<a name="ln3063">void</a>
<a name="ln3064">HaikuControlLook::_DrawRoundCornerBackgroundRightTop(BView* view, BRect&amp; cornerRect,</a>
<a name="ln3065">	const BRect&amp; updateRect, const rgb_color&amp; bevelTopColor,</a>
<a name="ln3066">	const rgb_color&amp; bevelRightColor, const BGradientLinear&amp; fillGradient)</a>
<a name="ln3067">{</a>
<a name="ln3068">	// constrain clipping region to corner</a>
<a name="ln3069">	BRegion clipping(cornerRect);</a>
<a name="ln3070">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln3071"> </a>
<a name="ln3072">	BRect ellipseRect(cornerRect);</a>
<a name="ln3073">	ellipseRect.left = ellipseRect.right - ellipseRect.Width() * 2;</a>
<a name="ln3074">	ellipseRect.bottom = ellipseRect.top + ellipseRect.Height() * 2;</a>
<a name="ln3075"> </a>
<a name="ln3076">	// bevel</a>
<a name="ln3077">	BGradientLinear gradient;</a>
<a name="ln3078">	gradient.AddColor(bevelTopColor, 0);</a>
<a name="ln3079">	gradient.AddColor(bevelRightColor, 255);</a>
<a name="ln3080">	gradient.SetStart(cornerRect.LeftTop());</a>
<a name="ln3081">	gradient.SetEnd(cornerRect.RightBottom());</a>
<a name="ln3082">	view-&gt;FillEllipse(ellipseRect, gradient);</a>
<a name="ln3083"> </a>
<a name="ln3084">	// gradient</a>
<a name="ln3085">	ellipseRect.InsetBy(1, 1);</a>
<a name="ln3086">	view-&gt;FillEllipse(ellipseRect, fillGradient);</a>
<a name="ln3087">}</a>
<a name="ln3088"> </a>
<a name="ln3089"> </a>
<a name="ln3090">void</a>
<a name="ln3091">HaikuControlLook::_DrawRoundCornerLeftBottom(BView* view, BRect&amp; cornerRect,</a>
<a name="ln3092">	const BRect&amp; updateRect, const rgb_color&amp; background,</a>
<a name="ln3093">	const rgb_color&amp; edgeLeftColor, const rgb_color&amp; edgeBottomColor,</a>
<a name="ln3094">	const rgb_color&amp; frameLeftColor, const rgb_color&amp; frameBottomColor,</a>
<a name="ln3095">	const rgb_color&amp; bevelLeftColor, const rgb_color&amp; bevelBottomColor,</a>
<a name="ln3096">	const BGradientLinear&amp; fillGradient)</a>
<a name="ln3097">{</a>
<a name="ln3098">	_DrawRoundCornerFrameLeftBottom(view, cornerRect, updateRect,</a>
<a name="ln3099">		background, edgeLeftColor, edgeBottomColor, frameLeftColor,</a>
<a name="ln3100">		frameBottomColor);</a>
<a name="ln3101">	_DrawRoundCornerBackgroundLeftBottom(view, cornerRect, updateRect,</a>
<a name="ln3102">		bevelLeftColor, bevelBottomColor, fillGradient);</a>
<a name="ln3103">}</a>
<a name="ln3104"> </a>
<a name="ln3105"> </a>
<a name="ln3106">void</a>
<a name="ln3107">HaikuControlLook::_DrawRoundCornerFrameLeftBottom(BView* view, BRect&amp; cornerRect,</a>
<a name="ln3108">	const BRect&amp; updateRect, const rgb_color&amp; background,</a>
<a name="ln3109">	const rgb_color&amp; edgeLeftColor, const rgb_color&amp; edgeBottomColor,</a>
<a name="ln3110">	const rgb_color&amp; frameLeftColor, const rgb_color&amp; frameBottomColor)</a>
<a name="ln3111">{</a>
<a name="ln3112">	// constrain clipping region to corner</a>
<a name="ln3113">	BRegion clipping(cornerRect);</a>
<a name="ln3114">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln3115"> </a>
<a name="ln3116">	// background</a>
<a name="ln3117">	view-&gt;SetHighColor(background);</a>
<a name="ln3118">	view-&gt;FillRect(cornerRect);</a>
<a name="ln3119"> </a>
<a name="ln3120">	// outer edge</a>
<a name="ln3121">	BRect ellipseRect(cornerRect);</a>
<a name="ln3122">	ellipseRect.right = ellipseRect.left + ellipseRect.Width() * 2;</a>
<a name="ln3123">	ellipseRect.top = ellipseRect.bottom - ellipseRect.Height() * 2;</a>
<a name="ln3124"> </a>
<a name="ln3125">	BGradientLinear gradient;</a>
<a name="ln3126">	gradient.AddColor(edgeLeftColor, 0);</a>
<a name="ln3127">	gradient.AddColor(edgeBottomColor, 255);</a>
<a name="ln3128">	gradient.SetStart(cornerRect.LeftTop());</a>
<a name="ln3129">	gradient.SetEnd(cornerRect.RightBottom());</a>
<a name="ln3130">	view-&gt;FillEllipse(ellipseRect, gradient);</a>
<a name="ln3131"> </a>
<a name="ln3132">	// frame</a>
<a name="ln3133">	ellipseRect.InsetBy(1, 1);</a>
<a name="ln3134">	cornerRect.left++;</a>
<a name="ln3135">	cornerRect.bottom--;</a>
<a name="ln3136">	if (frameLeftColor == frameBottomColor) {</a>
<a name="ln3137">		view-&gt;SetHighColor(frameLeftColor);</a>
<a name="ln3138">		view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln3139">	} else {</a>
<a name="ln3140">		gradient.SetColor(0, frameLeftColor);</a>
<a name="ln3141">		gradient.SetColor(1, frameBottomColor);</a>
<a name="ln3142">		gradient.SetStart(cornerRect.LeftTop());</a>
<a name="ln3143">		gradient.SetEnd(cornerRect.RightBottom());</a>
<a name="ln3144">		view-&gt;FillEllipse(ellipseRect, gradient);</a>
<a name="ln3145">	}</a>
<a name="ln3146"> </a>
<a name="ln3147">	// prepare for bevel</a>
<a name="ln3148">	cornerRect.left++;</a>
<a name="ln3149">	cornerRect.bottom--;</a>
<a name="ln3150">}</a>
<a name="ln3151"> </a>
<a name="ln3152"> </a>
<a name="ln3153">void</a>
<a name="ln3154">HaikuControlLook::_DrawRoundCornerBackgroundLeftBottom(BView* view, BRect&amp; cornerRect,</a>
<a name="ln3155">	const BRect&amp; updateRect, const rgb_color&amp; bevelLeftColor,</a>
<a name="ln3156">	const rgb_color&amp; bevelBottomColor, const BGradientLinear&amp; fillGradient)</a>
<a name="ln3157">{</a>
<a name="ln3158">	// constrain clipping region to corner</a>
<a name="ln3159">	BRegion clipping(cornerRect);</a>
<a name="ln3160">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln3161"> </a>
<a name="ln3162">	BRect ellipseRect(cornerRect);</a>
<a name="ln3163">	ellipseRect.right = ellipseRect.left + ellipseRect.Width() * 2;</a>
<a name="ln3164">	ellipseRect.top = ellipseRect.bottom - ellipseRect.Height() * 2;</a>
<a name="ln3165"> </a>
<a name="ln3166">	// bevel</a>
<a name="ln3167">	BGradientLinear gradient;</a>
<a name="ln3168">	gradient.AddColor(bevelLeftColor, 0);</a>
<a name="ln3169">	gradient.AddColor(bevelBottomColor, 255);</a>
<a name="ln3170">	gradient.SetStart(cornerRect.LeftTop());</a>
<a name="ln3171">	gradient.SetEnd(cornerRect.RightBottom());</a>
<a name="ln3172">	view-&gt;FillEllipse(ellipseRect, gradient);</a>
<a name="ln3173"> </a>
<a name="ln3174">	// gradient</a>
<a name="ln3175">	ellipseRect.InsetBy(1, 1);</a>
<a name="ln3176">	view-&gt;FillEllipse(ellipseRect, fillGradient);</a>
<a name="ln3177">}</a>
<a name="ln3178"> </a>
<a name="ln3179"> </a>
<a name="ln3180">void</a>
<a name="ln3181">HaikuControlLook::_DrawRoundCornerRightBottom(BView* view, BRect&amp; cornerRect,</a>
<a name="ln3182">	const BRect&amp; updateRect, const rgb_color&amp; background,</a>
<a name="ln3183">	const rgb_color&amp; edgeColor, const rgb_color&amp; frameColor,</a>
<a name="ln3184">	const rgb_color&amp; bevelColor, const BGradientLinear&amp; fillGradient)</a>
<a name="ln3185">{</a>
<a name="ln3186">	_DrawRoundCornerFrameRightBottom(view, cornerRect, updateRect,</a>
<a name="ln3187">		background, edgeColor, frameColor);</a>
<a name="ln3188">	_DrawRoundCornerBackgroundRightBottom(view, cornerRect, updateRect,</a>
<a name="ln3189">		bevelColor, fillGradient);</a>
<a name="ln3190">}</a>
<a name="ln3191"> </a>
<a name="ln3192"> </a>
<a name="ln3193">void</a>
<a name="ln3194">HaikuControlLook::_DrawRoundCornerFrameRightBottom(BView* view, BRect&amp; cornerRect,</a>
<a name="ln3195">	const BRect&amp; updateRect, const rgb_color&amp; background,</a>
<a name="ln3196">	const rgb_color&amp; edgeColor, const rgb_color&amp; frameColor)</a>
<a name="ln3197">{</a>
<a name="ln3198">	// constrain clipping region to corner</a>
<a name="ln3199">	BRegion clipping(cornerRect);</a>
<a name="ln3200">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln3201"> </a>
<a name="ln3202">	// background</a>
<a name="ln3203">	view-&gt;SetHighColor(background);</a>
<a name="ln3204">	view-&gt;FillRect(cornerRect);</a>
<a name="ln3205"> </a>
<a name="ln3206">	// outer edge</a>
<a name="ln3207">	BRect ellipseRect(cornerRect);</a>
<a name="ln3208">	ellipseRect.left = ellipseRect.right - ellipseRect.Width() * 2;</a>
<a name="ln3209">	ellipseRect.top = ellipseRect.bottom - ellipseRect.Height() * 2;</a>
<a name="ln3210"> </a>
<a name="ln3211">	view-&gt;SetHighColor(edgeColor);</a>
<a name="ln3212">	view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln3213"> </a>
<a name="ln3214">	// frame</a>
<a name="ln3215">	ellipseRect.InsetBy(1, 1);</a>
<a name="ln3216">	cornerRect.right--;</a>
<a name="ln3217">	cornerRect.bottom--;</a>
<a name="ln3218">	view-&gt;SetHighColor(frameColor);</a>
<a name="ln3219">	view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln3220"> </a>
<a name="ln3221">	// prepare for bevel</a>
<a name="ln3222">	cornerRect.right--;</a>
<a name="ln3223">	cornerRect.bottom--;</a>
<a name="ln3224">}</a>
<a name="ln3225"> </a>
<a name="ln3226"> </a>
<a name="ln3227">void</a>
<a name="ln3228">HaikuControlLook::_DrawRoundCornerBackgroundRightBottom(BView* view,</a>
<a name="ln3229">	BRect&amp; cornerRect, const BRect&amp; updateRect, const rgb_color&amp; bevelColor,</a>
<a name="ln3230">	const BGradientLinear&amp; fillGradient)</a>
<a name="ln3231">{</a>
<a name="ln3232">	// constrain clipping region to corner</a>
<a name="ln3233">	BRegion clipping(cornerRect);</a>
<a name="ln3234">	view-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln3235"> </a>
<a name="ln3236">	BRect ellipseRect(cornerRect);</a>
<a name="ln3237">	ellipseRect.left = ellipseRect.right - ellipseRect.Width() * 2;</a>
<a name="ln3238">	ellipseRect.top = ellipseRect.bottom - ellipseRect.Height() * 2;</a>
<a name="ln3239"> </a>
<a name="ln3240">	// bevel</a>
<a name="ln3241">	view-&gt;SetHighColor(bevelColor);</a>
<a name="ln3242">	view-&gt;FillEllipse(ellipseRect);</a>
<a name="ln3243"> </a>
<a name="ln3244">	// gradient</a>
<a name="ln3245">	ellipseRect.InsetBy(1, 1);</a>
<a name="ln3246">	view-&gt;FillEllipse(ellipseRect, fillGradient);</a>
<a name="ln3247">}</a>
<a name="ln3248"> </a>
<a name="ln3249"> </a>
<a name="ln3250">void</a>
<a name="ln3251">HaikuControlLook::_DrawRoundBarCorner(BView* view, BRect&amp; rect,</a>
<a name="ln3252">	const BRect&amp; updateRect,</a>
<a name="ln3253">	const rgb_color&amp; edgeLightColor, const rgb_color&amp; edgeShadowColor,</a>
<a name="ln3254">	const rgb_color&amp; frameLightColor, const rgb_color&amp; frameShadowColor,</a>
<a name="ln3255">	const rgb_color&amp; fillLightColor, const rgb_color&amp; fillShadowColor,</a>
<a name="ln3256">	float leftInset, float topInset, float rightInset, float bottomInset,</a>
<a name="ln3257">	orientation orientation)</a>
<a name="ln3258">{</a>
<a name="ln3259">	if (!rect.IsValid() || !rect.Intersects(updateRect))</a>
<a name="ln3260">		return;</a>
<a name="ln3261"> </a>
<a name="ln3262">	BGradientLinear gradient;</a>
<a name="ln3263">	gradient.AddColor(edgeShadowColor, 0);</a>
<a name="ln3264">	gradient.AddColor(edgeLightColor, 255);</a>
<a name="ln3265">	gradient.SetStart(rect.LeftTop());</a>
<a name="ln3266">	if (orientation == B_HORIZONTAL)</a>
<a name="ln3267">		gradient.SetEnd(rect.LeftBottom());</a>
<a name="ln3268">	else</a>
<a name="ln3269">		gradient.SetEnd(rect.RightTop());</a>
<a name="ln3270"> </a>
<a name="ln3271">	view-&gt;FillEllipse(rect, gradient);</a>
<a name="ln3272"> </a>
<a name="ln3273">	rect.left += leftInset;</a>
<a name="ln3274">	rect.top += topInset;</a>
<a name="ln3275">	rect.right += rightInset;</a>
<a name="ln3276">	rect.bottom += bottomInset;</a>
<a name="ln3277"> </a>
<a name="ln3278">	gradient.MakeEmpty();</a>
<a name="ln3279">	gradient.AddColor(frameShadowColor, 0);</a>
<a name="ln3280">	gradient.AddColor(frameLightColor, 255);</a>
<a name="ln3281">	gradient.SetStart(rect.LeftTop());</a>
<a name="ln3282">	if (orientation == B_HORIZONTAL)</a>
<a name="ln3283">		gradient.SetEnd(rect.LeftBottom());</a>
<a name="ln3284">	else</a>
<a name="ln3285">		gradient.SetEnd(rect.RightTop());</a>
<a name="ln3286"> </a>
<a name="ln3287">	view-&gt;FillEllipse(rect, gradient);</a>
<a name="ln3288"> </a>
<a name="ln3289">	rect.left += leftInset;</a>
<a name="ln3290">	rect.top += topInset;</a>
<a name="ln3291">	rect.right += rightInset;</a>
<a name="ln3292">	rect.bottom += bottomInset;</a>
<a name="ln3293"> </a>
<a name="ln3294">	gradient.MakeEmpty();</a>
<a name="ln3295">	gradient.AddColor(fillShadowColor, 0);</a>
<a name="ln3296">	gradient.AddColor(fillLightColor, 255);</a>
<a name="ln3297">	gradient.SetStart(rect.LeftTop());</a>
<a name="ln3298">	if (orientation == B_HORIZONTAL)</a>
<a name="ln3299">		gradient.SetEnd(rect.LeftBottom());</a>
<a name="ln3300">	else</a>
<a name="ln3301">		gradient.SetEnd(rect.RightTop());</a>
<a name="ln3302"> </a>
<a name="ln3303">	view-&gt;FillEllipse(rect, gradient);</a>
<a name="ln3304">}</a>
<a name="ln3305"> </a>
<a name="ln3306"> </a>
<a name="ln3307">rgb_color</a>
<a name="ln3308">HaikuControlLook::_EdgeLightColor(const rgb_color&amp; base, float contrast,</a>
<a name="ln3309">	float brightness, uint32 flags)</a>
<a name="ln3310">{</a>
<a name="ln3311">	rgb_color edgeLightColor;</a>
<a name="ln3312"> </a>
<a name="ln3313">	if ((flags &amp; B_BLEND_FRAME) != 0) {</a>
<a name="ln3314">		uint8 alpha = uint8(20 * contrast);</a>
<a name="ln3315">		uint8 white = uint8(255 * brightness);</a>
<a name="ln3316"> </a>
<a name="ln3317">		edgeLightColor = (rgb_color){ white, white, white, alpha };</a>
<a name="ln3318">	} else {</a>
<a name="ln3319">		// colors</a>
<a name="ln3320">		float tintLight = kEdgeBevelLightTint;</a>
<a name="ln3321"> </a>
<a name="ln3322">		if (contrast == 0.0)</a>
<a name="ln3323">			tintLight = B_NO_TINT;</a>
<a name="ln3324">		else if (contrast != 1.0)</a>
<a name="ln3325">			tintLight = B_NO_TINT + (tintLight - B_NO_TINT) * contrast;</a>
<a name="ln3326"> </a>
<a name="ln3327">		edgeLightColor = tint_color(base, tintLight);</a>
<a name="ln3328"> </a>
<a name="ln3329">		if (brightness &lt; 1.0) {</a>
<a name="ln3330">			edgeLightColor.red = uint8(edgeLightColor.red * brightness);</a>
<a name="ln3331">			edgeLightColor.green = uint8(edgeLightColor.green * brightness);</a>
<a name="ln3332">			edgeLightColor.blue = uint8(edgeLightColor.blue * brightness);</a>
<a name="ln3333">		}</a>
<a name="ln3334">	}</a>
<a name="ln3335"> </a>
<a name="ln3336">	return edgeLightColor;</a>
<a name="ln3337">}</a>
<a name="ln3338"> </a>
<a name="ln3339"> </a>
<a name="ln3340">rgb_color</a>
<a name="ln3341">HaikuControlLook::_EdgeShadowColor(const rgb_color&amp; base, float contrast,</a>
<a name="ln3342">	float brightness, uint32 flags)</a>
<a name="ln3343">{</a>
<a name="ln3344">	rgb_color edgeShadowColor;</a>
<a name="ln3345"> </a>
<a name="ln3346">	if ((flags &amp; B_BLEND_FRAME) != 0) {</a>
<a name="ln3347">		uint8 alpha = uint8(20 * contrast);</a>
<a name="ln3348">		edgeShadowColor = (rgb_color){ 0, 0, 0, alpha };</a>
<a name="ln3349">	} else {</a>
<a name="ln3350">		float tintShadow = kEdgeBevelShadowTint;</a>
<a name="ln3351"> </a>
<a name="ln3352">		if (contrast == 0.0)</a>
<a name="ln3353">			tintShadow = B_NO_TINT;</a>
<a name="ln3354">		else if (contrast != 1.0)</a>
<a name="ln3355">			tintShadow = B_NO_TINT + (tintShadow - B_NO_TINT) * contrast;</a>
<a name="ln3356"> </a>
<a name="ln3357">		edgeShadowColor = tint_color(base, tintShadow);</a>
<a name="ln3358"> </a>
<a name="ln3359">		if (brightness &lt; 1.0) {</a>
<a name="ln3360">			edgeShadowColor.red = uint8(edgeShadowColor.red * brightness);</a>
<a name="ln3361">			edgeShadowColor.green = uint8(edgeShadowColor.green * brightness);</a>
<a name="ln3362">			edgeShadowColor.blue = uint8(edgeShadowColor.blue * brightness);</a>
<a name="ln3363">		}</a>
<a name="ln3364">	}</a>
<a name="ln3365"> </a>
<a name="ln3366">	return edgeShadowColor;</a>
<a name="ln3367">}</a>
<a name="ln3368"> </a>
<a name="ln3369"> </a>
<a name="ln3370">rgb_color</a>
<a name="ln3371">HaikuControlLook::_FrameLightColor(const rgb_color&amp; base, uint32 flags)</a>
<a name="ln3372">{</a>
<a name="ln3373">	if ((flags &amp; B_FOCUSED) != 0)</a>
<a name="ln3374">		return ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln3375"> </a>
<a name="ln3376">	if ((flags &amp; B_ACTIVATED) != 0)</a>
<a name="ln3377">		return _FrameShadowColor(base, flags &amp; ~B_ACTIVATED);</a>
<a name="ln3378"> </a>
<a name="ln3379">	rgb_color frameLightColor;</a>
<a name="ln3380"> </a>
<a name="ln3381">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln3382">		// TODO: B_BLEND_FRAME</a>
<a name="ln3383">		frameLightColor = tint_color(base, 1.145);</a>
<a name="ln3384"> </a>
<a name="ln3385">		if ((flags &amp; B_DEFAULT_BUTTON) != 0)</a>
<a name="ln3386">			frameLightColor = tint_color(frameLightColor, 1.14);</a>
<a name="ln3387">	} else {</a>
<a name="ln3388">		if ((flags &amp; B_BLEND_FRAME) != 0)</a>
<a name="ln3389">			frameLightColor = (rgb_color){ 0, 0, 0, 75 };</a>
<a name="ln3390">		else</a>
<a name="ln3391">			frameLightColor = tint_color(base, 1.33);</a>
<a name="ln3392"> </a>
<a name="ln3393">		if ((flags &amp; B_DEFAULT_BUTTON) != 0)</a>
<a name="ln3394">			frameLightColor = tint_color(frameLightColor, 1.35);</a>
<a name="ln3395">	}</a>
<a name="ln3396"> </a>
<a name="ln3397">	return frameLightColor;</a>
<a name="ln3398">}</a>
<a name="ln3399"> </a>
<a name="ln3400"> </a>
<a name="ln3401">rgb_color</a>
<a name="ln3402">HaikuControlLook::_FrameShadowColor(const rgb_color&amp; base, uint32 flags)</a>
<a name="ln3403">{</a>
<a name="ln3404">	if ((flags &amp; B_FOCUSED) != 0)</a>
<a name="ln3405">		return ui_color(B_KEYBOARD_NAVIGATION_COLOR);</a>
<a name="ln3406"> </a>
<a name="ln3407">	if ((flags &amp; B_ACTIVATED) != 0)</a>
<a name="ln3408">		return _FrameLightColor(base, flags &amp; ~B_ACTIVATED);</a>
<a name="ln3409"> </a>
<a name="ln3410">	rgb_color frameShadowColor;</a>
<a name="ln3411"> </a>
<a name="ln3412">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln3413">		// TODO: B_BLEND_FRAME</a>
<a name="ln3414">		frameShadowColor = tint_color(base, 1.24);</a>
<a name="ln3415"> </a>
<a name="ln3416">		if ((flags &amp; B_DEFAULT_BUTTON) != 0) {</a>
<a name="ln3417">			frameShadowColor = tint_color(base, 1.145);</a>
<a name="ln3418">			frameShadowColor = tint_color(frameShadowColor, 1.12);</a>
<a name="ln3419">		}</a>
<a name="ln3420">	} else {</a>
<a name="ln3421">		if ((flags &amp; B_DEFAULT_BUTTON) != 0) {</a>
<a name="ln3422">			if ((flags &amp; B_BLEND_FRAME) != 0)</a>
<a name="ln3423">				frameShadowColor = (rgb_color){ 0, 0, 0, 75 };</a>
<a name="ln3424">			else</a>
<a name="ln3425">				frameShadowColor = tint_color(base, 1.33);</a>
<a name="ln3426"> </a>
<a name="ln3427">			frameShadowColor = tint_color(frameShadowColor, 1.5);</a>
<a name="ln3428">		} else {</a>
<a name="ln3429">			if ((flags &amp; B_BLEND_FRAME) != 0)</a>
<a name="ln3430">				frameShadowColor = (rgb_color){ 0, 0, 0, 95 };</a>
<a name="ln3431">			else</a>
<a name="ln3432">				frameShadowColor = tint_color(base, 1.47);</a>
<a name="ln3433">		}</a>
<a name="ln3434">	}</a>
<a name="ln3435"> </a>
<a name="ln3436">	return frameShadowColor;</a>
<a name="ln3437">}</a>
<a name="ln3438"> </a>
<a name="ln3439"> </a>
<a name="ln3440">rgb_color</a>
<a name="ln3441">HaikuControlLook::_BevelLightColor(const rgb_color&amp; base, uint32 flags)</a>
<a name="ln3442">{</a>
<a name="ln3443">	rgb_color bevelLightColor = tint_color(base, 0.2);</a>
<a name="ln3444"> </a>
<a name="ln3445">	if ((flags &amp; B_DISABLED) != 0)</a>
<a name="ln3446">		bevelLightColor = tint_color(base, B_LIGHTEN_1_TINT);</a>
<a name="ln3447"> </a>
<a name="ln3448">	if ((flags &amp; B_ACTIVATED) != 0)</a>
<a name="ln3449">		bevelLightColor = tint_color(base, B_DARKEN_1_TINT);</a>
<a name="ln3450"> </a>
<a name="ln3451">	return bevelLightColor;</a>
<a name="ln3452">}</a>
<a name="ln3453"> </a>
<a name="ln3454"> </a>
<a name="ln3455">rgb_color</a>
<a name="ln3456">HaikuControlLook::_BevelShadowColor(const rgb_color&amp; base, uint32 flags)</a>
<a name="ln3457">{</a>
<a name="ln3458">	rgb_color bevelShadowColor = tint_color(base, 1.08);</a>
<a name="ln3459"> </a>
<a name="ln3460">	if ((flags &amp; B_DISABLED) != 0)</a>
<a name="ln3461">		bevelShadowColor = base;</a>
<a name="ln3462"> </a>
<a name="ln3463">	if ((flags &amp; B_ACTIVATED) != 0)</a>
<a name="ln3464">		bevelShadowColor = tint_color(base, B_DARKEN_1_TINT);</a>
<a name="ln3465"> </a>
<a name="ln3466">	return bevelShadowColor;</a>
<a name="ln3467">}</a>
<a name="ln3468"> </a>
<a name="ln3469"> </a>
<a name="ln3470">void</a>
<a name="ln3471">HaikuControlLook::_FillGradient(BView* view, const BRect&amp; rect,</a>
<a name="ln3472">	const rgb_color&amp; base, float topTint, float bottomTint,</a>
<a name="ln3473">	orientation orientation)</a>
<a name="ln3474">{</a>
<a name="ln3475">	BGradientLinear gradient;</a>
<a name="ln3476">	_MakeGradient(gradient, rect, base, topTint, bottomTint, orientation);</a>
<a name="ln3477">	view-&gt;FillRect(rect, gradient);</a>
<a name="ln3478">}</a>
<a name="ln3479"> </a>
<a name="ln3480"> </a>
<a name="ln3481">void</a>
<a name="ln3482">HaikuControlLook::_FillGlossyGradient(BView* view, const BRect&amp; rect,</a>
<a name="ln3483">	const rgb_color&amp; base, float topTint, float middle1Tint,</a>
<a name="ln3484">	float middle2Tint, float bottomTint, orientation orientation)</a>
<a name="ln3485">{</a>
<a name="ln3486">	BGradientLinear gradient;</a>
<a name="ln3487">	_MakeGlossyGradient(gradient, rect, base, topTint, middle1Tint,</a>
<a name="ln3488">		middle2Tint, bottomTint, orientation);</a>
<a name="ln3489">	view-&gt;FillRect(rect, gradient);</a>
<a name="ln3490">}</a>
<a name="ln3491"> </a>
<a name="ln3492"> </a>
<a name="ln3493">void</a>
<a name="ln3494">HaikuControlLook::_MakeGradient(BGradientLinear&amp; gradient, const BRect&amp; rect,</a>
<a name="ln3495">	const rgb_color&amp; base, float topTint, float bottomTint,</a>
<a name="ln3496">	orientation orientation) const</a>
<a name="ln3497">{</a>
<a name="ln3498">	gradient.AddColor(tint_color(base, topTint), 0);</a>
<a name="ln3499">	gradient.AddColor(tint_color(base, bottomTint), 255);</a>
<a name="ln3500">	gradient.SetStart(rect.LeftTop());</a>
<a name="ln3501">	if (orientation == B_HORIZONTAL)</a>
<a name="ln3502">		gradient.SetEnd(rect.LeftBottom());</a>
<a name="ln3503">	else</a>
<a name="ln3504">		gradient.SetEnd(rect.RightTop());</a>
<a name="ln3505">}</a>
<a name="ln3506"> </a>
<a name="ln3507"> </a>
<a name="ln3508">void</a>
<a name="ln3509">HaikuControlLook::_MakeGlossyGradient(BGradientLinear&amp; gradient, const BRect&amp; rect,</a>
<a name="ln3510">	const rgb_color&amp; base, float topTint, float middle1Tint,</a>
<a name="ln3511">	float middle2Tint, float bottomTint,</a>
<a name="ln3512">	orientation orientation) const</a>
<a name="ln3513">{</a>
<a name="ln3514">	gradient.AddColor(tint_color(base, topTint), 0);</a>
<a name="ln3515">	gradient.AddColor(tint_color(base, middle1Tint), 132);</a>
<a name="ln3516">	gradient.AddColor(tint_color(base, middle2Tint), 136);</a>
<a name="ln3517">	gradient.AddColor(tint_color(base, bottomTint), 255);</a>
<a name="ln3518">	gradient.SetStart(rect.LeftTop());</a>
<a name="ln3519">	if (orientation == B_HORIZONTAL)</a>
<a name="ln3520">		gradient.SetEnd(rect.LeftBottom());</a>
<a name="ln3521">	else</a>
<a name="ln3522">		gradient.SetEnd(rect.RightTop());</a>
<a name="ln3523">}</a>
<a name="ln3524"> </a>
<a name="ln3525"> </a>
<a name="ln3526">void</a>
<a name="ln3527">HaikuControlLook::_MakeButtonGradient(BGradientLinear&amp; gradient, BRect&amp; rect,</a>
<a name="ln3528">	const rgb_color&amp; base, uint32 flags, orientation orientation) const</a>
<a name="ln3529">{</a>
<a name="ln3530">	float topTint = 0.49;</a>
<a name="ln3531">	float middleTint1 = 0.62;</a>
<a name="ln3532">	float middleTint2 = 0.76;</a>
<a name="ln3533">	float bottomTint = 0.90;</a>
<a name="ln3534"> </a>
<a name="ln3535">	if ((flags &amp; B_ACTIVATED) != 0) {</a>
<a name="ln3536">		topTint = 1.11;</a>
<a name="ln3537">		bottomTint = 1.08;</a>
<a name="ln3538">	}</a>
<a name="ln3539"> </a>
<a name="ln3540">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln3541">		topTint = (topTint + B_NO_TINT) / 2;</a>
<a name="ln3542">		middleTint1 = (middleTint1 + B_NO_TINT) / 2;</a>
<a name="ln3543">		middleTint2 = (middleTint2 + B_NO_TINT) / 2;</a>
<a name="ln3544">		bottomTint = (bottomTint + B_NO_TINT) / 2;</a>
<a name="ln3545">	} else if ((flags &amp; B_HOVER) != 0) {</a>
<a name="ln3546">		topTint *= kHoverTintFactor;</a>
<a name="ln3547">		middleTint1 *= kHoverTintFactor;</a>
<a name="ln3548">		middleTint2 *= kHoverTintFactor;</a>
<a name="ln3549">		bottomTint *= kHoverTintFactor;</a>
<a name="ln3550">	}</a>
<a name="ln3551"> </a>
<a name="ln3552">	if ((flags &amp; B_ACTIVATED) != 0) {</a>
<a name="ln3553">		_MakeGradient(gradient, rect, base, topTint, bottomTint, orientation);</a>
<a name="ln3554">	} else {</a>
<a name="ln3555">		_MakeGlossyGradient(gradient, rect, base, topTint, middleTint1,</a>
<a name="ln3556">			middleTint2, bottomTint, orientation);</a>
<a name="ln3557">	}</a>
<a name="ln3558">}</a>
<a name="ln3559"> </a>
<a name="ln3560"> </a>
<a name="ln3561"> </a>
<a name="ln3562">bool</a>
<a name="ln3563">HaikuControlLook::_RadioButtonAndCheckBoxMarkColor(const rgb_color&amp; base,</a>
<a name="ln3564">	rgb_color&amp; color, uint32 flags) const</a>
<a name="ln3565">{</a>
<a name="ln3566">	if ((flags &amp; (B_ACTIVATED | B_PARTIALLY_ACTIVATED | B_CLICKED)) == 0) {</a>
<a name="ln3567">		// no mark to be drawn at all</a>
<a name="ln3568">		return false;</a>
<a name="ln3569">	}</a>
<a name="ln3570"> </a>
<a name="ln3571">	color = ui_color(B_CONTROL_MARK_COLOR);</a>
<a name="ln3572"> </a>
<a name="ln3573">	float mix = 1.0;</a>
<a name="ln3574"> </a>
<a name="ln3575">	if ((flags &amp; B_DISABLED) != 0) {</a>
<a name="ln3576">		// activated, but disabled</a>
<a name="ln3577">		mix = 0.4;</a>
<a name="ln3578">	} else if ((flags &amp; B_CLICKED) != 0) {</a>
<a name="ln3579">		if ((flags &amp; B_ACTIVATED) != 0) {</a>
<a name="ln3580">			// losing activation</a>
<a name="ln3581">			mix = 0.7;</a>
<a name="ln3582">		} else {</a>
<a name="ln3583">			// becoming activated (or losing partial activation)</a>
<a name="ln3584">			mix = 0.3;</a>
<a name="ln3585">		}</a>
<a name="ln3586">	} else if ((flags &amp; B_PARTIALLY_ACTIVATED) != 0) {</a>
<a name="ln3587">		// partially activated</a>
<a name="ln3588">		mix = 0.5;</a>
<a name="ln3589">	} else {</a>
<a name="ln3590">		// simply activated</a>
<a name="ln3591">	}</a>
<a name="ln3592"> </a>
<a name="ln3593">	color.red = uint8(color.red * mix + base.red * (1.0 - mix));</a>
<a name="ln3594">	color.green = uint8(color.green * mix + base.green * (1.0 - mix));</a>
<a name="ln3595">	color.blue = uint8(color.blue * mix + base.blue * (1.0 - mix));</a>
<a name="ln3596"> </a>
<a name="ln3597">	return true;</a>
<a name="ln3598">}</a>
<a name="ln3599"> </a>
<a name="ln3600"> </a>
<a name="ln3601">} // namespace BPrivate</a>

</code></pre>
<div class="balloon" rel="2005"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'icon' pointer was utilized before it was verified against nullptr. Check lines: 2005, 2019.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
