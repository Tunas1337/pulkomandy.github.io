
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>kernel_interface.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2016, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;dirent.h&gt;</a>
<a name="ln8">#include &lt;errno.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10">#include &lt;stdlib.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;sys/stat.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;FindDirectory.h&gt;</a>
<a name="ln15">#include &lt;fs_info.h&gt;</a>
<a name="ln16">#include &lt;fs_interface.h&gt;</a>
<a name="ln17">#include &lt;KernelExport.h&gt;</a>
<a name="ln18">#include &lt;Mime.h&gt;</a>
<a name="ln19">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln20">#include &lt;TypeConstants.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln23">#include &lt;util/SinglyLinkedList.h&gt;</a>
<a name="ln24">#include &lt;util/DoublyLinkedList.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;cdda.h&quot;</a>
<a name="ln27">#include &quot;cddb.h&quot;</a>
<a name="ln28">#include &quot;Lock.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">//#define TRACE_CDDA</a>
<a name="ln32">#ifdef TRACE_CDDA</a>
<a name="ln33">#	define TRACE(x) dprintf x</a>
<a name="ln34">#else</a>
<a name="ln35">#	define TRACE(x)</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">class Attribute;</a>
<a name="ln40">class Inode;</a>
<a name="ln41">struct attr_cookie;</a>
<a name="ln42">struct dir_cookie;</a>
<a name="ln43"> </a>
<a name="ln44">typedef DoublyLinkedList&lt;Attribute&gt; AttributeList;</a>
<a name="ln45">typedef SinglyLinkedList&lt;attr_cookie&gt; AttrCookieList;</a>
<a name="ln46"> </a>
<a name="ln47">struct riff_header {</a>
<a name="ln48">	uint32		magic;</a>
<a name="ln49">	uint32		length;</a>
<a name="ln50">	uint32		id;</a>
<a name="ln51">} _PACKED;</a>
<a name="ln52"> </a>
<a name="ln53">struct riff_chunk {</a>
<a name="ln54">	uint32		fourcc;</a>
<a name="ln55">	uint32		length;</a>
<a name="ln56">} _PACEKD;</a>
<a name="ln57"> </a>
<a name="ln58">struct wav_format_chunk : riff_chunk {</a>
<a name="ln59">	uint16		format_tag;</a>
<a name="ln60">	uint16		channels;</a>
<a name="ln61">	uint32		samples_per_second;</a>
<a name="ln62">	uint32		average_bytes_per_second;</a>
<a name="ln63">	uint16		block_align;</a>
<a name="ln64">	uint16		bits_per_sample;</a>
<a name="ln65">} _PACKED;</a>
<a name="ln66"> </a>
<a name="ln67">struct wav_header {</a>
<a name="ln68">	riff_header			header;</a>
<a name="ln69">	wav_format_chunk	format;</a>
<a name="ln70">	riff_chunk			data;</a>
<a name="ln71">} _PACKED;</a>
<a name="ln72"> </a>
<a name="ln73">enum attr_mode {</a>
<a name="ln74">	kDiscIDAttributes,</a>
<a name="ln75">	kSharedAttributes,</a>
<a name="ln76">	kDeviceAttributes</a>
<a name="ln77">};</a>
<a name="ln78"> </a>
<a name="ln79">class Volume {</a>
<a name="ln80">public:</a>
<a name="ln81">							Volume(fs_volume* fsVolume);</a>
<a name="ln82">							~Volume();</a>
<a name="ln83"> </a>
<a name="ln84">			status_t		InitCheck();</a>
<a name="ln85"> </a>
<a name="ln86">			fs_volume*		FSVolume() const { return fFSVolume; }</a>
<a name="ln87">			dev_t			ID() const { return fFSVolume-&gt;id; }</a>
<a name="ln88">			uint32			DiscID() const { return fDiscID; }</a>
<a name="ln89">			Inode&amp;			RootNode() const { return *fRootNode; }</a>
<a name="ln90"> </a>
<a name="ln91">			status_t		Mount(const char* device);</a>
<a name="ln92">			int				Device() const { return fDevice; }</a>
<a name="ln93">			ino_t			GetNextNodeID() { return fNextID++; }</a>
<a name="ln94"> </a>
<a name="ln95">			const char*		Name() const { return fName; }</a>
<a name="ln96">			status_t		SetName(const char* name);</a>
<a name="ln97"> </a>
<a name="ln98">			Semaphore&amp;		Lock();</a>
<a name="ln99"> </a>
<a name="ln100">			Inode*			Find(ino_t id);</a>
<a name="ln101">			Inode*			Find(const char* name);</a>
<a name="ln102"> </a>
<a name="ln103">			Inode*			FirstEntry() const { return fFirstEntry; }</a>
<a name="ln104"> </a>
<a name="ln105">			off_t			NumBlocks() const { return fNumBlocks; }</a>
<a name="ln106">			size_t			BufferSize() const { return 32 * kFrameSize; }</a>
<a name="ln107">								// TODO: for now</a>
<a name="ln108"> </a>
<a name="ln109">			void			SetCDDBLookupsEnabled(bool doLookup);</a>
<a name="ln110"> </a>
<a name="ln111">	static	void			DetermineName(uint32 cddbId, int device, char* name,</a>
<a name="ln112">								size_t length);</a>
<a name="ln113"> </a>
<a name="ln114">private:</a>
<a name="ln115">			Inode*			_CreateNode(Inode* parent, const char* name,</a>
<a name="ln116">								uint64 start, uint64 frames, int32 type);</a>
<a name="ln117">			int				_OpenAttributes(int mode,</a>
<a name="ln118">								enum attr_mode attrMode = kDiscIDAttributes);</a>
<a name="ln119">			void			_RestoreAttributes();</a>
<a name="ln120">			void			_RestoreAttributes(int fd);</a>
<a name="ln121">			void			_StoreAttributes();</a>
<a name="ln122">			void			_RestoreSharedAttributes();</a>
<a name="ln123">			void			_StoreSharedAttributes();</a>
<a name="ln124"> </a>
<a name="ln125">			Semaphore		fLock;</a>
<a name="ln126">			fs_volume*		fFSVolume;</a>
<a name="ln127">			int				fDevice;</a>
<a name="ln128">			uint32			fDiscID;</a>
<a name="ln129">			Inode*			fRootNode;</a>
<a name="ln130">			ino_t			fNextID;</a>
<a name="ln131">			char*			fName;</a>
<a name="ln132">			off_t			fNumBlocks;</a>
<a name="ln133">			bool 			fIgnoreCDDBLookupChanges;</a>
<a name="ln134"> </a>
<a name="ln135">			// root directory contents - we don't support other directories</a>
<a name="ln136">			Inode*			fFirstEntry;</a>
<a name="ln137">};</a>
<a name="ln138"> </a>
<a name="ln139">class Attribute : public DoublyLinkedListLinkImpl&lt;Attribute&gt; {</a>
<a name="ln140">public:</a>
<a name="ln141">							Attribute(const char* name, type_code type);</a>
<a name="ln142">							~Attribute();</a>
<a name="ln143"> </a>
<a name="ln144">			status_t		InitCheck() const</a>
<a name="ln145">								{ return fName != NULL ? B_OK : B_NO_MEMORY; }</a>
<a name="ln146">			status_t		SetTo(const char* name, type_code type);</a>
<a name="ln147">			void			SetType(type_code type)</a>
<a name="ln148">								{ fType = type; }</a>
<a name="ln149"> </a>
<a name="ln150">			status_t		ReadAt(off_t offset, uint8* buffer,</a>
<a name="ln151">								size_t* _length);</a>
<a name="ln152">			status_t		WriteAt(off_t offset, const uint8* buffer,</a>
<a name="ln153">								size_t* _length);</a>
<a name="ln154">			void			Truncate();</a>
<a name="ln155">			status_t		SetSize(off_t size);</a>
<a name="ln156"> </a>
<a name="ln157">			const char*		Name() const { return fName; }</a>
<a name="ln158">			off_t			Size() const { return fSize; }</a>
<a name="ln159">			type_code		Type() const { return fType; }</a>
<a name="ln160">			uint8*			Data() const { return fData; }</a>
<a name="ln161"> </a>
<a name="ln162">			bool			IsProtectedNamespace();</a>
<a name="ln163">	static	bool			IsProtectedNamespace(const char* name);</a>
<a name="ln164"> </a>
<a name="ln165">private:</a>
<a name="ln166">			char*			fName;</a>
<a name="ln167">			type_code		fType;</a>
<a name="ln168">			uint8*			fData;</a>
<a name="ln169">			off_t			fSize;</a>
<a name="ln170">};</a>
<a name="ln171"> </a>
<a name="ln172">class Inode {</a>
<a name="ln173">public:</a>
<a name="ln174">							Inode(Volume* volume, Inode* parent,</a>
<a name="ln175">								const char* name, uint64 start, uint64 frames,</a>
<a name="ln176">								int32 type);</a>
<a name="ln177">							~Inode();</a>
<a name="ln178"> </a>
<a name="ln179">			status_t		InitCheck();</a>
<a name="ln180">			ino_t			ID() const { return fID; }</a>
<a name="ln181"> </a>
<a name="ln182">			const char*		Name() const { return fName; }</a>
<a name="ln183">			status_t		SetName(const char* name);</a>
<a name="ln184"> </a>
<a name="ln185">			int32			Type() const</a>
<a name="ln186">								{ return fType; }</a>
<a name="ln187">			gid_t			GroupID() const</a>
<a name="ln188">								{ return fGroupID; }</a>
<a name="ln189">			uid_t			UserID() const</a>
<a name="ln190">								{ return fUserID; }</a>
<a name="ln191">			time_t			CreationTime() const</a>
<a name="ln192">								{ return fCreationTime; }</a>
<a name="ln193">			time_t			ModificationTime() const</a>
<a name="ln194">								{ return fModificationTime; }</a>
<a name="ln195">			uint64			StartFrame() const</a>
<a name="ln196">								{ return fStartFrame; }</a>
<a name="ln197">			uint64			FrameCount() const</a>
<a name="ln198">								{ return fFrameCount; }</a>
<a name="ln199">			uint64			Size() const</a>
<a name="ln200">								{ return fFrameCount * kFrameSize; }</a>
<a name="ln201">									// does not include the WAV header</a>
<a name="ln202"> </a>
<a name="ln203">			Attribute*		FindAttribute(const char* name) const;</a>
<a name="ln204">			status_t		AddAttribute(Attribute* attribute, bool overwrite);</a>
<a name="ln205">			status_t		AddAttribute(const char* name, type_code type,</a>
<a name="ln206">								bool overwrite, const uint8* data,</a>
<a name="ln207">								size_t length);</a>
<a name="ln208">			status_t		AddAttribute(const char* name, type_code type,</a>
<a name="ln209">								const char* string);</a>
<a name="ln210">			status_t		AddAttribute(const char* name, type_code type,</a>
<a name="ln211">								uint32 value);</a>
<a name="ln212">			status_t		AddAttribute(const char* name, type_code type,</a>
<a name="ln213">								uint64 value);</a>
<a name="ln214">			status_t		RemoveAttribute(const char* name,</a>
<a name="ln215">								bool checkNamespace = false);</a>
<a name="ln216"> </a>
<a name="ln217">			void			AddAttrCookie(attr_cookie* cookie);</a>
<a name="ln218">			void			RemoveAttrCookie(attr_cookie* cookie);</a>
<a name="ln219">			void			RewindAttrCookie(attr_cookie* cookie);</a>
<a name="ln220"> </a>
<a name="ln221">			AttributeList::ConstIterator Attributes() const</a>
<a name="ln222">								{ return fAttributes.GetIterator(); }</a>
<a name="ln223"> </a>
<a name="ln224">			const wav_header* WAVHeader() const</a>
<a name="ln225">								{ return &amp;fWAVHeader; }</a>
<a name="ln226"> </a>
<a name="ln227">			Inode*			Next() const { return fNext; }</a>
<a name="ln228">			void			SetNext(Inode *inode) { fNext = inode; }</a>
<a name="ln229"> </a>
<a name="ln230">private:</a>
<a name="ln231">			Inode*			fNext;</a>
<a name="ln232">			ino_t			fID;</a>
<a name="ln233">			int32			fType;</a>
<a name="ln234">			char*			fName;</a>
<a name="ln235">			gid_t			fGroupID;</a>
<a name="ln236">			uid_t			fUserID;</a>
<a name="ln237">			time_t			fCreationTime;</a>
<a name="ln238">			time_t			fModificationTime;</a>
<a name="ln239">			uint64			fStartFrame;</a>
<a name="ln240">			uint64			fFrameCount;</a>
<a name="ln241">			AttributeList	fAttributes;</a>
<a name="ln242">			AttrCookieList	fAttrCookies;</a>
<a name="ln243">			wav_header		fWAVHeader;</a>
<a name="ln244">};</a>
<a name="ln245"> </a>
<a name="ln246">struct dir_cookie {</a>
<a name="ln247">	Inode*		current;</a>
<a name="ln248">	int			state;	// iteration state</a>
<a name="ln249">};</a>
<a name="ln250"> </a>
<a name="ln251">// directory iteration states</a>
<a name="ln252">enum {</a>
<a name="ln253">	ITERATION_STATE_DOT		= 0,</a>
<a name="ln254">	ITERATION_STATE_DOT_DOT	= 1,</a>
<a name="ln255">	ITERATION_STATE_OTHERS	= 2,</a>
<a name="ln256">	ITERATION_STATE_BEGIN	= ITERATION_STATE_DOT,</a>
<a name="ln257">};</a>
<a name="ln258"> </a>
<a name="ln259">struct attr_cookie : SinglyLinkedListLinkImpl&lt;attr_cookie&gt; {</a>
<a name="ln260">	Attribute*	current;</a>
<a name="ln261">};</a>
<a name="ln262"> </a>
<a name="ln263">struct file_cookie {</a>
<a name="ln264">	int			open_mode;</a>
<a name="ln265">	off_t		buffer_offset;</a>
<a name="ln266">	void*		buffer;</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">static const uint32 kMaxAttributeSize = 65536;</a>
<a name="ln270">static const uint32 kMaxAttributes = 64;</a>
<a name="ln271"> </a>
<a name="ln272">static const char* kProtectedAttrNamespace = &quot;CD:&quot;;</a>
<a name="ln273"> </a>
<a name="ln274">static const char* kCddbIdAttribute = &quot;CD:cddbid&quot;;</a>
<a name="ln275">static const char* kDoLookupAttribute = &quot;CD:do_lookup&quot;;</a>
<a name="ln276">static const char* kTocAttribute = &quot;CD:toc&quot;;</a>
<a name="ln277"> </a>
<a name="ln278">extern fs_volume_ops gCDDAVolumeOps;</a>
<a name="ln279">extern fs_vnode_ops gCDDAVnodeOps;</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">//	#pragma mark helper functions</a>
<a name="ln283"> </a>
<a name="ln284"> </a>
<a name="ln285">/*!	Determines if the attribute is shared among all devices or among</a>
<a name="ln286">	all CDs in a specific device.</a>
<a name="ln287">	We use this to share certain Tracker attributes.</a>
<a name="ln288">*/</a>
<a name="ln289">static bool</a>
<a name="ln290">is_special_attribute(const char* name, attr_mode attrMode)</a>
<a name="ln291">{</a>
<a name="ln292">	if (attrMode == kDeviceAttributes) {</a>
<a name="ln293">		static const char* kAttributes[] = {</a>
<a name="ln294">			&quot;_trk/windframe&quot;,</a>
<a name="ln295">			&quot;_trk/pinfo&quot;,</a>
<a name="ln296">			&quot;_trk/pinfo_le&quot;,</a>
<a name="ln297">			NULL,</a>
<a name="ln298">		};</a>
<a name="ln299"> </a>
<a name="ln300">		for (int32 i = 0; kAttributes[i]; i++) {</a>
<a name="ln301">			if (!strcmp(name, kAttributes[i]))</a>
<a name="ln302">				return true;</a>
<a name="ln303">		}</a>
<a name="ln304">	} else if (attrMode == kSharedAttributes) {</a>
<a name="ln305">		static const char* kAttributes[] = {</a>
<a name="ln306">			&quot;_trk/columns&quot;,</a>
<a name="ln307">			&quot;_trk/columns_le&quot;,</a>
<a name="ln308">			&quot;_trk/viewstate&quot;,</a>
<a name="ln309">			&quot;_trk/viewstate_le&quot;,</a>
<a name="ln310">			NULL,</a>
<a name="ln311">		};</a>
<a name="ln312"> </a>
<a name="ln313">		for (int32 i = 0; kAttributes[i]; i++) {</a>
<a name="ln314">			if (!strcmp(name, kAttributes[i]))</a>
<a name="ln315">				return true;</a>
<a name="ln316">		}</a>
<a name="ln317">	}</a>
<a name="ln318"> </a>
<a name="ln319">	return false;</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322"> </a>
<a name="ln323">static void</a>
<a name="ln324">write_line(int fd, const char* line)</a>
<a name="ln325">{</a>
<a name="ln326">	if (line == NULL)</a>
<a name="ln327">		line = &quot;&quot;;</a>
<a name="ln328"> </a>
<a name="ln329">	size_t length = strlen(line);</a>
<a name="ln330">	write(fd, line, length);</a>
<a name="ln331">	write(fd, &quot;\n&quot;, 1);</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">static void</a>
<a name="ln336">write_attributes(int fd, Inode* inode, attr_mode attrMode = kDiscIDAttributes)</a>
<a name="ln337">{</a>
<a name="ln338">	// count attributes</a>
<a name="ln339"> </a>
<a name="ln340">	AttributeList::ConstIterator iterator = inode-&gt;Attributes();</a>
<a name="ln341">	uint32 count = 0;</a>
<a name="ln342">	while (iterator.HasNext()) {</a>
<a name="ln343">		Attribute* attribute = iterator.Next();</a>
<a name="ln344">		if ((attrMode == kDiscIDAttributes</a>
<a name="ln345">			|| is_special_attribute(attribute-&gt;Name(), attrMode))</a>
<a name="ln346">				&amp;&amp; !attribute-&gt;IsProtectedNamespace())</a>
<a name="ln347">			count++;</a>
<a name="ln348">	}</a>
<a name="ln349"> </a>
<a name="ln350">	// we're artificially limiting the attribute count per inode</a>
<a name="ln351">	if (count &gt; kMaxAttributes)</a>
<a name="ln352">		count = kMaxAttributes;</a>
<a name="ln353"> </a>
<a name="ln354">	count = B_HOST_TO_BENDIAN_INT32(count);</a>
<a name="ln355">	write(fd, &amp;count, sizeof(uint32));</a>
<a name="ln356"> </a>
<a name="ln357">	// write attributes</a>
<a name="ln358"> </a>
<a name="ln359">	iterator.Rewind();</a>
<a name="ln360"> </a>
<a name="ln361">	while (iterator.HasNext()) {</a>
<a name="ln362">		Attribute* attribute = iterator.Next();</a>
<a name="ln363">		if ((attrMode != kDiscIDAttributes</a>
<a name="ln364">			&amp;&amp; !is_special_attribute(attribute-&gt;Name(), attrMode))</a>
<a name="ln365">				|| attribute-&gt;IsProtectedNamespace())</a>
<a name="ln366">			continue;</a>
<a name="ln367"> </a>
<a name="ln368">		uint32 type = B_HOST_TO_BENDIAN_INT32(attribute-&gt;Type());</a>
<a name="ln369">		write(fd, &amp;type, sizeof(uint32));</a>
<a name="ln370"> </a>
<a name="ln371">		uint8 length = strlen(attribute-&gt;Name());</a>
<a name="ln372">		write(fd, &amp;length, 1);</a>
<a name="ln373">		write(fd, attribute-&gt;Name(), length);</a>
<a name="ln374"> </a>
<a name="ln375">		uint32 size = B_HOST_TO_BENDIAN_INT32(attribute-&gt;Size());</a>
<a name="ln376">		write(fd, &amp;size, sizeof(uint32));</a>
<a name="ln377">		if (size != 0)</a>
<a name="ln378">			write(fd, attribute-&gt;Data(), attribute-&gt;Size());</a>
<a name="ln379"> </a>
<a name="ln380">		if (--count == 0)</a>
<a name="ln381">			break;</a>
<a name="ln382">	}</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385"> </a>
<a name="ln386">static bool</a>
<a name="ln387">read_line(int fd, char* line, size_t length)</a>
<a name="ln388">{</a>
<a name="ln389">	bool first = true;</a>
<a name="ln390">	size_t pos = 0;</a>
<a name="ln391">	char c;</a>
<a name="ln392"> </a>
<a name="ln393">	while (read(fd, &amp;c, 1) == 1) {</a>
<a name="ln394">		first = false;</a>
<a name="ln395"> </a>
<a name="ln396">		if (c == '\n')</a>
<a name="ln397">			break;</a>
<a name="ln398">		if (pos &lt; length)</a>
<a name="ln399">			line[pos] = c;</a>
<a name="ln400"> </a>
<a name="ln401">		pos++;</a>
<a name="ln402">	}</a>
<a name="ln403"> </a>
<a name="ln404">	if (pos &gt;= length - 1)</a>
<a name="ln405">		pos = length - 1;</a>
<a name="ln406">	line[pos] = '\0';</a>
<a name="ln407"> </a>
<a name="ln408">	return !first;</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411"> </a>
<a name="ln412">static bool</a>
<a name="ln413">read_attributes(int fd, Inode* inode)</a>
<a name="ln414">{</a>
<a name="ln415">	uint32 count;</a>
<a name="ln416">	if (read(fd, &amp;count, sizeof(uint32)) != (ssize_t)sizeof(uint32))</a>
<a name="ln417">		return false;</a>
<a name="ln418"> </a>
<a name="ln419">	count = B_BENDIAN_TO_HOST_INT32(count);</a>
<a name="ln420">	if (count &gt; kMaxAttributes)</a>
<a name="ln421">		return false;</a>
<a name="ln422"> </a>
<a name="ln423">	for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln424">		char name[B_ATTR_NAME_LENGTH + 1];</a>
<a name="ln425">		uint32 type, size;</a>
<a name="ln426">		uint8 length;</a>
<a name="ln427">		if (read(fd, &amp;type, sizeof(uint32)) != (ssize_t)sizeof(uint32)</a>
<a name="ln428">			|| read(fd, &amp;length, 1) != 1</a>
<a name="ln429">			|| read(fd, name, length) != length</a>
<a name="ln430">			|| read(fd, &amp;size, sizeof(uint32)) != (ssize_t)sizeof(uint32))</a>
<a name="ln431">			return false;</a>
<a name="ln432"> </a>
<a name="ln433">		type = B_BENDIAN_TO_HOST_INT32(type);</a>
<a name="ln434">		size = B_BENDIAN_TO_HOST_INT32(size);</a>
<a name="ln435">		name[length] = '\0';</a>
<a name="ln436"> </a>
<a name="ln437">		Attribute* attribute = new(std::nothrow) Attribute(name, type);</a>
<a name="ln438">		if (attribute == NULL)</a>
<a name="ln439">			return false;</a>
<a name="ln440"> </a>
<a name="ln441">		if (attribute-&gt;IsProtectedNamespace()) {</a>
<a name="ln442">			// Attributes in the protected namespace are handled internally</a>
<a name="ln443">			// so we do not load them even if they are present in the</a>
<a name="ln444">			// attributes file.</a>
<a name="ln445">			delete attribute;</a>
<a name="ln446">			continue;</a>
<a name="ln447">		}</a>
<a name="ln448">		if (attribute-&gt;SetSize(size) != B_OK</a>
<a name="ln449">			|| inode-&gt;AddAttribute(attribute, true) != B_OK) {</a>
<a name="ln450">			delete attribute;</a>
<a name="ln451">		} else</a>
<a name="ln452">			read(fd, attribute-&gt;Data(), size);</a>
<a name="ln453">	}</a>
<a name="ln454"> </a>
<a name="ln455">	return true;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459">static int</a>
<a name="ln460">open_attributes(uint32 cddbID, int deviceFD, int mode,</a>
<a name="ln461">	enum attr_mode attrMode)</a>
<a name="ln462">{</a>
<a name="ln463">	char* path = (char*)malloc(B_PATH_NAME_LENGTH);</a>
<a name="ln464">	if (path == NULL)</a>
<a name="ln465">		return -1;</a>
<a name="ln466"> </a>
<a name="ln467">	MemoryDeleter deleter(path);</a>
<a name="ln468">	bool create = (mode &amp; O_WRONLY) != 0;</a>
<a name="ln469"> </a>
<a name="ln470">	if (find_directory(B_USER_SETTINGS_DIRECTORY, -1, create, path,</a>
<a name="ln471">			B_PATH_NAME_LENGTH) != B_OK) {</a>
<a name="ln472">		return -1;</a>
<a name="ln473">	}</a>
<a name="ln474"> </a>
<a name="ln475">	strlcat(path, &quot;/cdda&quot;, B_PATH_NAME_LENGTH);</a>
<a name="ln476">	if (create)</a>
<a name="ln477">		mkdir(path, 0755);</a>
<a name="ln478"> </a>
<a name="ln479">	if (attrMode == kDiscIDAttributes) {</a>
<a name="ln480">		char id[64];</a>
<a name="ln481">		snprintf(id, sizeof(id), &quot;/%08&quot; B_PRIx32, cddbID);</a>
<a name="ln482">		strlcat(path, id, B_PATH_NAME_LENGTH);</a>
<a name="ln483">	} else if (attrMode == kDeviceAttributes) {</a>
<a name="ln484">		uint32 length = strlen(path);</a>
<a name="ln485">		char* deviceName = path + length;</a>
<a name="ln486">		if (ioctl(deviceFD, B_GET_PATH_FOR_DEVICE, deviceName,</a>
<a name="ln487">				B_PATH_NAME_LENGTH - length) &lt; B_OK) {</a>
<a name="ln488">			return B_ERROR;</a>
<a name="ln489">		}</a>
<a name="ln490"> </a>
<a name="ln491">		deviceName++;</a>
<a name="ln492"> </a>
<a name="ln493">		// replace slashes in the device path</a>
<a name="ln494">		while (deviceName[0]) {</a>
<a name="ln495">			if (deviceName[0] == '/')</a>
<a name="ln496">				deviceName[0] = '_';</a>
<a name="ln497"> </a>
<a name="ln498">			deviceName++;</a>
<a name="ln499">		}</a>
<a name="ln500">	} else</a>
<a name="ln501">		strlcat(path, &quot;/shared&quot;, B_PATH_NAME_LENGTH);</a>
<a name="ln502"> </a>
<a name="ln503">	return open(path, mode | (create ? O_CREAT | O_TRUNC : 0), 0644);</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506"> </a>
<a name="ln507">static void</a>
<a name="ln508">fill_stat_buffer(Volume* volume, Inode* inode, Attribute* attribute,</a>
<a name="ln509">	struct stat&amp; stat)</a>
<a name="ln510">{</a>
<a name="ln511">	stat.st_dev = volume-&gt;FSVolume()-&gt;id;</a>
<a name="ln512">	stat.st_ino = inode-&gt;ID();</a>
<a name="ln513"> </a>
<a name="ln514">	if (attribute != NULL) {</a>
<a name="ln515">		stat.st_size = attribute-&gt;Size();</a>
<a name="ln516">		stat.st_blocks = 0;</a>
<a name="ln517">		stat.st_mode = S_ATTR | 0666;</a>
<a name="ln518">		stat.st_type = attribute-&gt;Type();</a>
<a name="ln519">	} else {</a>
<a name="ln520">		stat.st_size = inode-&gt;Size() + sizeof(wav_header);</a>
<a name="ln521">		stat.st_blocks = inode-&gt;Size() / 512;</a>
<a name="ln522">		stat.st_mode = inode-&gt;Type();</a>
<a name="ln523">		stat.st_type = 0;</a>
<a name="ln524">	}</a>
<a name="ln525"> </a>
<a name="ln526">	stat.st_nlink = 1;</a>
<a name="ln527">	stat.st_blksize = 2048;</a>
<a name="ln528"> </a>
<a name="ln529">	stat.st_uid = inode-&gt;UserID();</a>
<a name="ln530">	stat.st_gid = inode-&gt;GroupID();</a>
<a name="ln531"> </a>
<a name="ln532">	stat.st_atim.tv_sec = time(NULL);</a>
<a name="ln533">	stat.st_atim.tv_nsec = 0;</a>
<a name="ln534">	stat.st_mtim.tv_sec = stat.st_ctim.tv_sec = inode-&gt;ModificationTime();</a>
<a name="ln535">	stat.st_ctim.tv_nsec = stat.st_mtim.tv_nsec = 0;</a>
<a name="ln536">	stat.st_crtim.tv_sec = inode-&gt;CreationTime();</a>
<a name="ln537">	stat.st_crtim.tv_nsec = 0;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540"> </a>
<a name="ln541">bool</a>
<a name="ln542">is_data_track(const scsi_toc_track&amp; track)</a>
<a name="ln543">{</a>
<a name="ln544">	return (track.control &amp; 4) != 0;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547"> </a>
<a name="ln548">uint32</a>
<a name="ln549">count_audio_tracks(scsi_toc_toc* toc)</a>
<a name="ln550">{</a>
<a name="ln551">	uint32 trackCount = toc-&gt;last_track + 1 - toc-&gt;first_track;</a>
<a name="ln552">	uint32 count = 0;</a>
<a name="ln553">	for (uint32 i = 0; i &lt; trackCount; i++) {</a>
<a name="ln554">		if (!is_data_track(toc-&gt;tracks[i]))</a>
<a name="ln555">			count++;</a>
<a name="ln556">	}</a>
<a name="ln557"> </a>
<a name="ln558">	return count;</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561"> </a>
<a name="ln562">//	#pragma mark - Volume class</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">Volume::Volume(fs_volume* fsVolume)</a>
<a name="ln566">	:</a>
<a name="ln567">	fLock(&quot;cdda&quot;),</a>
<a name="ln568">	fFSVolume(fsVolume),</a>
<a name="ln569">	fDevice(-1),</a>
<a name="ln570">	fRootNode(NULL),</a>
<a name="ln571">	fNextID(1),</a>
<a name="ln572">	fName(NULL),</a>
<a name="ln573">	fNumBlocks(0),</a>
<a name="ln574">	fIgnoreCDDBLookupChanges(false),</a>
<a name="ln575">	fFirstEntry(NULL)</a>
<a name="ln576">{</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579"> </a>
<a name="ln580">Volume::~Volume()</a>
<a name="ln581">{</a>
<a name="ln582">	if (fRootNode) {</a>
<a name="ln583">		_StoreAttributes();</a>
<a name="ln584">		_StoreSharedAttributes();</a>
<a name="ln585">	}</a>
<a name="ln586"> </a>
<a name="ln587">	if (fDevice &gt;= 0)</a>
<a name="ln588">		close(fDevice);</a>
<a name="ln589"> </a>
<a name="ln590">	// put_vnode on the root to release the ref to it</a>
<a name="ln591">	if (fRootNode)</a>
<a name="ln592">		put_vnode(FSVolume(), fRootNode-&gt;ID());</a>
<a name="ln593"> </a>
<a name="ln594">	delete fRootNode;</a>
<a name="ln595"> </a>
<a name="ln596">	Inode* inode;</a>
<a name="ln597">	Inode* next;</a>
<a name="ln598"> </a>
<a name="ln599">	for (inode = fFirstEntry; inode != NULL; inode = next) {</a>
<a name="ln600">		next = inode-&gt;Next();</a>
<a name="ln601">		delete inode;</a>
<a name="ln602">	}</a>
<a name="ln603"> </a>
<a name="ln604">	free(fName);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607"> </a>
<a name="ln608">status_t</a>
<a name="ln609">Volume::InitCheck()</a>
<a name="ln610">{</a>
<a name="ln611">	if (fLock.InitCheck() &lt; B_OK)</a>
<a name="ln612">		return B_ERROR;</a>
<a name="ln613"> </a>
<a name="ln614">	return B_OK;</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617"> </a>
<a name="ln618">status_t</a>
<a name="ln619">Volume::Mount(const char* device)</a>
<a name="ln620">{</a>
<a name="ln621">	fDevice = open(device, O_RDONLY);</a>
<a name="ln622">	if (fDevice &lt; 0)</a>
<a name="ln623">		return errno;</a>
<a name="ln624"> </a>
<a name="ln625">	scsi_toc_toc* toc = (scsi_toc_toc*)malloc(1024);</a>
<a name="ln626">	if (toc == NULL)</a>
<a name="ln627">		return B_NO_MEMORY;</a>
<a name="ln628"> </a>
<a name="ln629">	MemoryDeleter deleter(toc);</a>
<a name="ln630"> </a>
<a name="ln631">	status_t status = read_table_of_contents(fDevice, toc, 1024);</a>
<a name="ln632">	// there has to be at least one audio track</a>
<a name="ln633">	if (status == B_OK &amp;&amp; count_audio_tracks(toc) == 0)</a>
<a name="ln634">		status = B_BAD_TYPE;</a>
<a name="ln635"> </a>
<a name="ln636">	if (status != B_OK)</a>
<a name="ln637">		return status;</a>
<a name="ln638"> </a>
<a name="ln639">	fDiscID = compute_cddb_disc_id(*toc);</a>
<a name="ln640"> </a>
<a name="ln641">	// create the root vnode</a>
<a name="ln642">	fRootNode = _CreateNode(NULL, &quot;&quot;, 0, 0, S_IFDIR | 0777);</a>
<a name="ln643">	if (fRootNode == NULL)</a>
<a name="ln644">		status = B_NO_MEMORY;</a>
<a name="ln645">	if (status == B_OK) {</a>
<a name="ln646">		status = publish_vnode(FSVolume(), fRootNode-&gt;ID(), fRootNode,</a>
<a name="ln647">			&amp;gCDDAVnodeOps, fRootNode-&gt;Type(), 0);</a>
<a name="ln648">	}</a>
<a name="ln649">	if (status != B_OK)</a>
<a name="ln650">		return status;</a>
<a name="ln651"> </a>
<a name="ln652">	bool doLookup = true;</a>
<a name="ln653">	cdtext text;</a>
<a name="ln654">	int fd = _OpenAttributes(O_RDONLY);</a>
<a name="ln655">	if (fd &lt; 0) {</a>
<a name="ln656">		// We do not seem to have an attribute file so this is probably the</a>
<a name="ln657">		// first time this CD is inserted. In this case, try to read CD-Text</a>
<a name="ln658">		// data.</a>
<a name="ln659">		if (read_cdtext(fDevice, text) == B_OK)</a>
<a name="ln660">			doLookup = false;</a>
<a name="ln661">		else</a>
<a name="ln662">			TRACE((&quot;CDDA: no CD-Text found.\n&quot;));</a>
<a name="ln663">	} else {</a>
<a name="ln664">		doLookup = false;</a>
<a name="ln665">	}</a>
<a name="ln666"> </a>
<a name="ln667">	int32 trackCount = toc-&gt;last_track + 1 - toc-&gt;first_track;</a>
<a name="ln668">	off_t totalFrames = 0;</a>
<a name="ln669">	char title[256];</a>
<a name="ln670"> </a>
<a name="ln671">	for (int32 i = 0; i &lt; trackCount; i++) {</a>
<a name="ln672">		scsi_cd_msf&amp; next = toc-&gt;tracks[i + 1].start.time;</a>
<a name="ln673">			// the last track is always lead-out</a>
<a name="ln674">		scsi_cd_msf&amp; start = toc-&gt;tracks[i].start.time;</a>
<a name="ln675">		int32 track = i + 1;</a>
<a name="ln676"> </a>
<a name="ln677">		uint64 startFrame = start.minute * kFramesPerMinute</a>
<a name="ln678">			+ start.second * kFramesPerSecond + start.frame;</a>
<a name="ln679">		uint64 frames = next.minute * kFramesPerMinute</a>
<a name="ln680">			+ next.second * kFramesPerSecond + next.frame</a>
<a name="ln681">			- startFrame;</a>
<a name="ln682"> </a>
<a name="ln683">		// Adjust length of the last audio track according to the Blue Book</a>
<a name="ln684">		// specification in case of an Enhanced CD</a>
<a name="ln685">		if (i + 1 &lt; trackCount &amp;&amp; is_data_track(toc-&gt;tracks[i + 1])</a>
<a name="ln686">			&amp;&amp; !is_data_track(toc-&gt;tracks[i]))</a>
<a name="ln687">			frames -= kDataTrackLeadGap;</a>
<a name="ln688"> </a>
<a name="ln689">		totalFrames += frames;</a>
<a name="ln690"> </a>
<a name="ln691">		if (is_data_track(toc-&gt;tracks[i]))</a>
<a name="ln692">			continue;</a>
<a name="ln693"> </a>
<a name="ln694">		if (text.titles[i] != NULL) {</a>
<a name="ln695">			if (text.artists[i] != NULL) {</a>
<a name="ln696">				snprintf(title, sizeof(title), &quot;%02&quot; B_PRId32 &quot;. %s - %s.wav&quot;,</a>
<a name="ln697">					track, text.artists[i], text.titles[i]);</a>
<a name="ln698">			} else {</a>
<a name="ln699">				snprintf(title, sizeof(title), &quot;%02&quot; B_PRId32 &quot;. %s.wav&quot;,</a>
<a name="ln700">					track, text.titles[i]);</a>
<a name="ln701">			}</a>
<a name="ln702">		} else</a>
<a name="ln703">			snprintf(title, sizeof(title), &quot;Track %02&quot; B_PRId32 &quot;.wav&quot;, track);</a>
<a name="ln704"> </a>
<a name="ln705">		// remove '/' and '\n' from title</a>
<a name="ln706">		for (int32 j = 0; title[j]; j++) {</a>
<a name="ln707">			if (title[j] == '/')</a>
<a name="ln708">				title[j] = '-';</a>
<a name="ln709">			else if (title[j] == '\n')</a>
<a name="ln710">				title[j] = ' ';</a>
<a name="ln711">		}</a>
<a name="ln712"> </a>
<a name="ln713">		Inode* inode = _CreateNode(fRootNode, title, startFrame, frames,</a>
<a name="ln714">			S_IFREG | 0444);</a>
<a name="ln715">		if (inode == NULL)</a>
<a name="ln716">			continue;</a>
<a name="ln717"> </a>
<a name="ln718">		// add attributes</a>
<a name="ln719"> </a>
<a name="ln720">		inode-&gt;AddAttribute(&quot;Audio:Artist&quot;, B_STRING_TYPE,</a>
<a name="ln721">			text.artists[i] != NULL ? text.artists[i] : text.artist);</a>
<a name="ln722">		inode-&gt;AddAttribute(&quot;Audio:Album&quot;, B_STRING_TYPE, text.album);</a>
<a name="ln723">		inode-&gt;AddAttribute(&quot;Audio:Title&quot;, B_STRING_TYPE, text.titles[i]);</a>
<a name="ln724">		inode-&gt;AddAttribute(&quot;Audio:Genre&quot;, B_STRING_TYPE, text.genre);</a>
<a name="ln725">		inode-&gt;AddAttribute(&quot;Audio:Track&quot;, B_INT32_TYPE, (uint32)track);</a>
<a name="ln726">		inode-&gt;AddAttribute(&quot;Audio:Bitrate&quot;, B_STRING_TYPE, &quot;1411 kbps&quot;);</a>
<a name="ln727">		inode-&gt;AddAttribute(&quot;Media:Length&quot;, B_INT64_TYPE,</a>
<a name="ln728">			inode-&gt;FrameCount() * 1000000L / kFramesPerSecond);</a>
<a name="ln729">		inode-&gt;AddAttribute(&quot;BEOS:TYPE&quot;, B_MIME_STRING_TYPE, &quot;audio/x-wav&quot;);</a>
<a name="ln730">	}</a>
<a name="ln731"> </a>
<a name="ln732">	// Add CD:cddbid attribute.</a>
<a name="ln733">	fRootNode-&gt;AddAttribute(kCddbIdAttribute, B_UINT32_TYPE, fDiscID);</a>
<a name="ln734"> </a>
<a name="ln735">	// Add CD:do_lookup attribute.</a>
<a name="ln736">	SetCDDBLookupsEnabled(doLookup);</a>
<a name="ln737"> </a>
<a name="ln738">	// Add CD:toc attribute.</a>
<a name="ln739">	fRootNode-&gt;AddAttribute(kTocAttribute, B_RAW_TYPE, true,</a>
<a name="ln740">		(const uint8*)toc, B_BENDIAN_TO_HOST_INT16(toc-&gt;data_length) + 2);</a>
<a name="ln741"> </a>
<a name="ln742">	_RestoreSharedAttributes();</a>
<a name="ln743">	if (fd &gt;= 0) {</a>
<a name="ln744">		_RestoreAttributes(fd);</a>
<a name="ln745">		close(fd);</a>
<a name="ln746">	}</a>
<a name="ln747"> </a>
<a name="ln748">	// determine volume title</a>
<a name="ln749">	DetermineName(fDiscID, fDevice, title, sizeof(title));</a>
<a name="ln750"> </a>
<a name="ln751">	fName = strdup(title);</a>
<a name="ln752">	if (fName == NULL)</a>
<a name="ln753">		return B_NO_MEMORY;</a>
<a name="ln754"> </a>
<a name="ln755">	fNumBlocks = totalFrames;</a>
<a name="ln756">	return B_OK;</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759"> </a>
<a name="ln760">status_t</a>
<a name="ln761">Volume::SetName(const char* name)</a>
<a name="ln762">{</a>
<a name="ln763">	if (name == NULL || !name[0])</a>
<a name="ln764">		return B_BAD_VALUE;</a>
<a name="ln765"> </a>
<a name="ln766">	name = strdup(name);</a>
<a name="ln767">	if (name == NULL)</a>
<a name="ln768">		return B_NO_MEMORY;</a>
<a name="ln769"> </a>
<a name="ln770">	free(fName);</a>
<a name="ln771">	fName = (char*)name;</a>
<a name="ln772">	return B_OK;</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775"> </a>
<a name="ln776">Semaphore&amp;</a>
<a name="ln777">Volume::Lock()</a>
<a name="ln778">{</a>
<a name="ln779">	return fLock;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782"> </a>
<a name="ln783">Inode*</a>
<a name="ln784">Volume::Find(ino_t id)</a>
<a name="ln785">{</a>
<a name="ln786">	for (Inode* inode = fFirstEntry; inode != NULL; inode = inode-&gt;Next()) {</a>
<a name="ln787">		if (inode-&gt;ID() == id)</a>
<a name="ln788">			return inode;</a>
<a name="ln789">	}</a>
<a name="ln790"> </a>
<a name="ln791">	return NULL;</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">Inode*</a>
<a name="ln796">Volume::Find(const char* name)</a>
<a name="ln797">{</a>
<a name="ln798">	if (!strcmp(name, &quot;.&quot;)</a>
<a name="ln799">		|| !strcmp(name, &quot;..&quot;))</a>
<a name="ln800">		return fRootNode;</a>
<a name="ln801"> </a>
<a name="ln802">	for (Inode* inode = fFirstEntry; inode != NULL; inode = inode-&gt;Next()) {</a>
<a name="ln803">		if (!strcmp(inode-&gt;Name(), name))</a>
<a name="ln804">			return inode;</a>
<a name="ln805">	}</a>
<a name="ln806"> </a>
<a name="ln807">	return NULL;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810"> </a>
<a name="ln811">void</a>
<a name="ln812">Volume::SetCDDBLookupsEnabled(bool doLookup)</a>
<a name="ln813">{</a>
<a name="ln814">	if (!fIgnoreCDDBLookupChanges) {</a>
<a name="ln815">		fRootNode-&gt;AddAttribute(kDoLookupAttribute, B_BOOL_TYPE, true,</a>
<a name="ln816">			(const uint8*)&amp;doLookup, sizeof(bool));</a>
<a name="ln817">	}</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820"> </a>
<a name="ln821">/*static*/ void</a>
<a name="ln822">Volume::DetermineName(uint32 cddbID, int device, char* name, size_t length)</a>
<a name="ln823">{</a>
<a name="ln824">	name[0] = '\0';</a>
<a name="ln825"> </a>
<a name="ln826">	int attrFD = open_attributes(cddbID, device, O_RDONLY,</a>
<a name="ln827">		kDiscIDAttributes);</a>
<a name="ln828">	if (attrFD &lt; 0) {</a>
<a name="ln829">		// We do not have attributes set. Read CD text.</a>
<a name="ln830">		cdtext text;</a>
<a name="ln831">		if (read_cdtext(device, text) == B_OK) {</a>
<a name="ln832">			if (text.artist != NULL &amp;&amp; text.album != NULL)</a>
<a name="ln833">				snprintf(name, length, &quot;%s - %s&quot;, text.artist, text.album);</a>
<a name="ln834">			else if (text.artist != NULL || text.album != NULL) {</a>
<a name="ln835">				snprintf(name, length, &quot;%s&quot;, text.artist != NULL</a>
<a name="ln836">					? text.artist : text.album);</a>
<a name="ln837">			}</a>
<a name="ln838">		}</a>
<a name="ln839">	} else {</a>
<a name="ln840">		// We have an attribute file. Read name from it.</a>
<a name="ln841">		if (!read_line(attrFD, name, length))</a>
<a name="ln842">			name[0] = '\0';</a>
<a name="ln843"> </a>
<a name="ln844">		close(attrFD);</a>
<a name="ln845">	}</a>
<a name="ln846"> </a>
<a name="ln847">	if (!name[0])</a>
<a name="ln848">		strlcpy(name, &quot;Audio CD&quot;, length);</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851"> </a>
<a name="ln852">Inode*</a>
<a name="ln853">Volume::_CreateNode(Inode* parent, const char* name, uint64 start,</a>
<a name="ln854">	uint64 frames, int32 type)</a>
<a name="ln855">{</a>
<a name="ln856">	Inode* inode = new(std::nothrow) Inode(this, parent, name, start, frames,</a>
<a name="ln857">		type);</a>
<a name="ln858">	if (inode == NULL)</a>
<a name="ln859">		return NULL;</a>
<a name="ln860"> </a>
<a name="ln861">	if (inode-&gt;InitCheck() != B_OK) {</a>
<a name="ln862">		delete inode;</a>
<a name="ln863">		return NULL;</a>
<a name="ln864">	}</a>
<a name="ln865"> </a>
<a name="ln866">	if (S_ISREG(type)) {</a>
<a name="ln867">		// we need to order it by track for compatibility with BeOS' cdda</a>
<a name="ln868">		Inode* current = fFirstEntry;</a>
<a name="ln869">		Inode* last = NULL;</a>
<a name="ln870">		while (current != NULL) {</a>
<a name="ln871">			last = current;</a>
<a name="ln872">			current = current-&gt;Next();</a>
<a name="ln873">		}</a>
<a name="ln874"> </a>
<a name="ln875">		if (last)</a>
<a name="ln876">			last-&gt;SetNext(inode);</a>
<a name="ln877">		else</a>
<a name="ln878">			fFirstEntry = inode;</a>
<a name="ln879">	}</a>
<a name="ln880"> </a>
<a name="ln881">	return inode;</a>
<a name="ln882">}</a>
<a name="ln883"> </a>
<a name="ln884"> </a>
<a name="ln885">/*!	Opens the file that contains the volume and inode titles as well as all</a>
<a name="ln886">	of their attributes.</a>
<a name="ln887">	The attributes are stored in files below B_USER_SETTINGS_DIRECTORY/cdda.</a>
<a name="ln888">*/</a>
<a name="ln889">int</a>
<a name="ln890">Volume::_OpenAttributes(int mode, enum attr_mode attrMode)</a>
<a name="ln891">{</a>
<a name="ln892">	return open_attributes(fDiscID, fDevice, mode, attrMode);</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895"> </a>
<a name="ln896">/*!	Reads the attributes, if any, that belong to the CD currently being</a>
<a name="ln897">	mounted.</a>
<a name="ln898">*/</a>
<a name="ln899">void</a>
<a name="ln900">Volume::_RestoreAttributes()</a>
<a name="ln901">{</a>
<a name="ln902">	int fd = _OpenAttributes(O_RDONLY);</a>
<a name="ln903">	if (fd &lt; 0)</a>
<a name="ln904">		return;</a>
<a name="ln905"> </a>
<a name="ln906">	_RestoreAttributes(fd);</a>
<a name="ln907"> </a>
<a name="ln908">	close(fd);</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911"> </a>
<a name="ln912">void</a>
<a name="ln913">Volume::_RestoreAttributes(int fd)</a>
<a name="ln914">{</a>
<a name="ln915">	char line[B_FILE_NAME_LENGTH];</a>
<a name="ln916">	if (!read_line(fd, line, B_FILE_NAME_LENGTH))</a>
<a name="ln917">		return;</a>
<a name="ln918"> </a>
<a name="ln919">	SetName(line);</a>
<a name="ln920"> </a>
<a name="ln921">	for (Inode* inode = fFirstEntry; inode != NULL; inode = inode-&gt;Next()) {</a>
<a name="ln922">		if (!read_line(fd, line, B_FILE_NAME_LENGTH))</a>
<a name="ln923">			break;</a>
<a name="ln924"> </a>
<a name="ln925">		inode-&gt;SetName(line);</a>
<a name="ln926">	}</a>
<a name="ln927"> </a>
<a name="ln928">	if (read_attributes(fd, fRootNode)) {</a>
<a name="ln929">		for (Inode* inode = fFirstEntry; inode != NULL; inode = inode-&gt;Next()) {</a>
<a name="ln930">			if (!read_attributes(fd, inode))</a>
<a name="ln931">				break;</a>
<a name="ln932">		}</a>
<a name="ln933">	}</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936"> </a>
<a name="ln937">void</a>
<a name="ln938">Volume::_StoreAttributes()</a>
<a name="ln939">{</a>
<a name="ln940">	int fd = _OpenAttributes(O_WRONLY);</a>
<a name="ln941">	if (fd &lt; 0)</a>
<a name="ln942">		return;</a>
<a name="ln943"> </a>
<a name="ln944">	write_line(fd, Name());</a>
<a name="ln945"> </a>
<a name="ln946">	for (Inode* inode = fFirstEntry; inode != NULL; inode = inode-&gt;Next()) {</a>
<a name="ln947">		write_line(fd, inode-&gt;Name());</a>
<a name="ln948">	}</a>
<a name="ln949"> </a>
<a name="ln950">	write_attributes(fd, fRootNode);</a>
<a name="ln951"> </a>
<a name="ln952">	for (Inode* inode = fFirstEntry; inode != NULL; inode = inode-&gt;Next()) {</a>
<a name="ln953">		write_attributes(fd, inode);</a>
<a name="ln954">	}</a>
<a name="ln955"> </a>
<a name="ln956">	close(fd);</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959"> </a>
<a name="ln960">/*!	Restores the attributes, if any, that are shared between CDs; some are</a>
<a name="ln961">	stored per device, others are stored for all CDs no matter which device.</a>
<a name="ln962">*/</a>
<a name="ln963">void</a>
<a name="ln964">Volume::_RestoreSharedAttributes()</a>
<a name="ln965">{</a>
<a name="ln966">	// Don't affect CDDB lookup status while changing shared attributes</a>
<a name="ln967">	fIgnoreCDDBLookupChanges = true;</a>
<a name="ln968"> </a>
<a name="ln969">	// device attributes overwrite shared attributes</a>
<a name="ln970">	int fd = _OpenAttributes(O_RDONLY, kSharedAttributes);</a>
<a name="ln971">	if (fd &gt;= 0) {</a>
<a name="ln972">		read_attributes(fd, fRootNode);</a>
<a name="ln973">		close(fd);</a>
<a name="ln974">	}</a>
<a name="ln975"> </a>
<a name="ln976">	fd = _OpenAttributes(O_RDONLY, kDeviceAttributes);</a>
<a name="ln977">	if (fd &gt;= 0) {</a>
<a name="ln978">		read_attributes(fd, fRootNode);</a>
<a name="ln979">		close(fd);</a>
<a name="ln980">	}</a>
<a name="ln981"> </a>
<a name="ln982">	fIgnoreCDDBLookupChanges = false;</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985"> </a>
<a name="ln986">void</a>
<a name="ln987">Volume::_StoreSharedAttributes()</a>
<a name="ln988">{</a>
<a name="ln989">	// write shared and device specific settings</a>
<a name="ln990"> </a>
<a name="ln991">	int fd = _OpenAttributes(O_WRONLY, kSharedAttributes);</a>
<a name="ln992">	if (fd &gt;= 0) {</a>
<a name="ln993">		write_attributes(fd, fRootNode, kSharedAttributes);</a>
<a name="ln994">		close(fd);</a>
<a name="ln995">	}</a>
<a name="ln996"> </a>
<a name="ln997">	fd = _OpenAttributes(O_WRONLY, kDeviceAttributes);</a>
<a name="ln998">	if (fd &gt;= 0) {</a>
<a name="ln999">		write_attributes(fd, fRootNode, kDeviceAttributes);</a>
<a name="ln1000">		close(fd);</a>
<a name="ln1001">	}</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004"> </a>
<a name="ln1005">//	#pragma mark - Attribute class</a>
<a name="ln1006"> </a>
<a name="ln1007"> </a>
<a name="ln1008">Attribute::Attribute(const char* name, type_code type)</a>
<a name="ln1009">	:</a>
<a name="ln1010">	fName(NULL),</a>
<a name="ln1011">	fType(0),</a>
<a name="ln1012">	fData(NULL),</a>
<a name="ln1013">	fSize(0)</a>
<a name="ln1014">{</a>
<a name="ln1015">	SetTo(name, type);</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018"> </a>
<a name="ln1019">Attribute::~Attribute()</a>
<a name="ln1020">{</a>
<a name="ln1021">	free(fName);</a>
<a name="ln1022">	free(fData);</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025"> </a>
<a name="ln1026">status_t</a>
<a name="ln1027">Attribute::SetTo(const char* name, type_code type)</a>
<a name="ln1028">{</a>
<a name="ln1029">	if (name == NULL || !name[0])</a>
<a name="ln1030">		return B_BAD_VALUE;</a>
<a name="ln1031"> </a>
<a name="ln1032">	name = strdup(name);</a>
<a name="ln1033">	if (name == NULL)</a>
<a name="ln1034">		return B_NO_MEMORY;</a>
<a name="ln1035"> </a>
<a name="ln1036">	free(fName);</a>
<a name="ln1037"> </a>
<a name="ln1038">	fName = (char*)name;</a>
<a name="ln1039">	fType = type;</a>
<a name="ln1040">	return B_OK;</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043"> </a>
<a name="ln1044">status_t</a>
<a name="ln1045">Attribute::ReadAt(off_t offset, uint8* buffer, size_t* _length)</a>
<a name="ln1046">{</a>
<a name="ln1047">	size_t length = *_length;</a>
<a name="ln1048"> </a>
<a name="ln1049">	if (offset &lt; 0)</a>
<a name="ln1050">		return B_BAD_VALUE;</a>
<a name="ln1051">	if (offset &gt;= fSize) {</a>
<a name="ln1052">		*_length = 0;</a>
<a name="ln1053">		return B_OK;</a>
<a name="ln1054">	}</a>
<a name="ln1055">	if (offset + (off_t)length &gt; fSize)</a>
<a name="ln1056">		length = fSize - offset;</a>
<a name="ln1057"> </a>
<a name="ln1058">	if (user_memcpy(buffer, fData + offset, length) &lt; B_OK)</a>
<a name="ln1059">		return B_BAD_ADDRESS;</a>
<a name="ln1060"> </a>
<a name="ln1061">	*_length = length;</a>
<a name="ln1062">	return B_OK;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065"> </a>
<a name="ln1066">/*!	Writes to the attribute and enlarges it as needed.</a>
<a name="ln1067">	An attribute has a maximum size of 65536 bytes for now.</a>
<a name="ln1068">*/</a>
<a name="ln1069">status_t</a>
<a name="ln1070">Attribute::WriteAt(off_t offset, const uint8* buffer, size_t* _length)</a>
<a name="ln1071">{</a>
<a name="ln1072">	size_t length = *_length;</a>
<a name="ln1073"> </a>
<a name="ln1074">	if (offset &lt; 0)</a>
<a name="ln1075">		return B_BAD_VALUE;</a>
<a name="ln1076"> </a>
<a name="ln1077">	// we limit the attribute size to something reasonable</a>
<a name="ln1078">	off_t end = offset + length;</a>
<a name="ln1079">	if (end &gt; kMaxAttributeSize) {</a>
<a name="ln1080">		end = kMaxAttributeSize;</a>
<a name="ln1081">		length = end - offset;</a>
<a name="ln1082">	}</a>
<a name="ln1083">	if (offset &gt; end) {</a>
<a name="ln1084">		*_length = 0;</a>
<a name="ln1085">		return E2BIG;</a>
<a name="ln1086">	}</a>
<a name="ln1087"> </a>
<a name="ln1088">	if (end &gt; fSize) {</a>
<a name="ln1089">		// make room in the data stream</a>
<a name="ln1090">		uint8* data = (uint8*)realloc(fData, end);</a>
<a name="ln1091">		if (data == NULL)</a>
<a name="ln1092">			return B_NO_MEMORY;</a>
<a name="ln1093"> </a>
<a name="ln1094">		if (fSize &lt; offset)</a>
<a name="ln1095">			memset(data + fSize, 0, offset - fSize);</a>
<a name="ln1096"> </a>
<a name="ln1097">		fData = data;</a>
<a name="ln1098">		fSize = end;</a>
<a name="ln1099">	}</a>
<a name="ln1100"> </a>
<a name="ln1101">	if (user_memcpy(fData + offset, buffer, length) &lt; B_OK)</a>
<a name="ln1102">		return B_BAD_ADDRESS;</a>
<a name="ln1103"> </a>
<a name="ln1104">	*_length = length;</a>
<a name="ln1105">	return B_OK;</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108"> </a>
<a name="ln1109">//!	Removes all data from the attribute.</a>
<a name="ln1110">void</a>
<a name="ln1111">Attribute::Truncate()</a>
<a name="ln1112">{</a>
<a name="ln1113">	free(fData);</a>
<a name="ln1114">	fData = NULL;</a>
<a name="ln1115">	fSize = 0;</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118"> </a>
<a name="ln1119">/*!	Resizes the data part of an attribute to the requested amount \a size.</a>
<a name="ln1120">	An attribute has a maximum size of 65536 bytes for now.</a>
<a name="ln1121">*/</a>
<a name="ln1122">status_t</a>
<a name="ln1123">Attribute::SetSize(off_t size)</a>
<a name="ln1124">{</a>
<a name="ln1125">	if (size &gt; kMaxAttributeSize)</a>
<a name="ln1126">		return E2BIG;</a>
<a name="ln1127"> </a>
<a name="ln1128">	uint8* data = (uint8*)realloc(fData, size);</a>
<a name="ln1129">	if (data == NULL)</a>
<a name="ln1130">		return B_NO_MEMORY;</a>
<a name="ln1131"> </a>
<a name="ln1132">	if (fSize &lt; size)</a>
<a name="ln1133">		memset(data + fSize, 0, size - fSize);</a>
<a name="ln1134"> </a>
<a name="ln1135">	fData = data;</a>
<a name="ln1136">	fSize = size;</a>
<a name="ln1137">	return B_OK;</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140"> </a>
<a name="ln1141">bool</a>
<a name="ln1142">Attribute::IsProtectedNamespace()</a>
<a name="ln1143">{</a>
<a name="ln1144">	// Check if the attribute is in the restricted namespace. Attributes in</a>
<a name="ln1145">	// this namespace should not be edited by the user as they are handled</a>
<a name="ln1146">	// internally by the add-on. Calls the static version.</a>
<a name="ln1147">	return IsProtectedNamespace(fName);</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150"> </a>
<a name="ln1151">bool</a>
<a name="ln1152">Attribute::IsProtectedNamespace(const char* name)</a>
<a name="ln1153">{</a>
<a name="ln1154">	// Convenience static version of the above method. Usually called when we</a>
<a name="ln1155">	// don't have a constructed Attribute object handy.</a>
<a name="ln1156">	return strncmp(kProtectedAttrNamespace, name,</a>
<a name="ln1157">		strlen(kProtectedAttrNamespace)) == 0;</a>
<a name="ln1158">}</a>
<a name="ln1159"> </a>
<a name="ln1160"> </a>
<a name="ln1161">//	#pragma mark - Inode class</a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164">Inode::Inode(Volume* volume, Inode* parent, const char* name, uint64 start,</a>
<a name="ln1165">		uint64 frames, int32 type)</a>
<a name="ln1166">	:</a>
<a name="ln1167">	fNext(NULL)</a>
<a name="ln1168">{</a>
<a name="ln1169">	memset(&amp;fWAVHeader, 0, sizeof(wav_header));</a>
<a name="ln1170"> </a>
<a name="ln1171">	fID = volume-&gt;GetNextNodeID();</a>
<a name="ln1172">	fType = type;</a>
<a name="ln1173">	fStartFrame = start;</a>
<a name="ln1174">	fFrameCount = frames;</a>
<a name="ln1175"> </a>
<a name="ln1176">	fUserID = geteuid();</a>
<a name="ln1177">	fGroupID = parent ? parent-&gt;GroupID() : getegid();</a>
<a name="ln1178"> </a>
<a name="ln1179">	fCreationTime = fModificationTime = time(NULL);</a>
<a name="ln1180"> </a>
<a name="ln1181">	fName = strdup(name);</a>
<a name="ln1182">	if (fName == NULL)</a>
<a name="ln1183">		return;</a>
<a name="ln1184"> </a>
<a name="ln1185">	if (frames) {</a>
<a name="ln1186">		// initialize WAV header</a>
<a name="ln1187"> </a>
<a name="ln1188">		// RIFF header</a>
<a name="ln1189">		fWAVHeader.header.magic = B_HOST_TO_BENDIAN_INT32('RIFF');</a>
<a name="ln1190">		fWAVHeader.header.length = B_HOST_TO_LENDIAN_INT32(Size()</a>
<a name="ln1191">			+ sizeof(wav_header) - sizeof(riff_chunk));</a>
<a name="ln1192">		fWAVHeader.header.id = B_HOST_TO_BENDIAN_INT32('WAVE');</a>
<a name="ln1193"> </a>
<a name="ln1194">		// 'fmt ' format chunk</a>
<a name="ln1195">		fWAVHeader.format.fourcc = B_HOST_TO_BENDIAN_INT32('fmt ');</a>
<a name="ln1196">		fWAVHeader.format.length = B_HOST_TO_LENDIAN_INT32(</a>
<a name="ln1197">			sizeof(wav_format_chunk) - sizeof(riff_chunk));</a>
<a name="ln1198">		fWAVHeader.format.format_tag = B_HOST_TO_LENDIAN_INT16(1);</a>
<a name="ln1199">		fWAVHeader.format.channels = B_HOST_TO_LENDIAN_INT16(2);</a>
<a name="ln1200">		fWAVHeader.format.samples_per_second = B_HOST_TO_LENDIAN_INT32(44100);</a>
<a name="ln1201">		fWAVHeader.format.average_bytes_per_second = B_HOST_TO_LENDIAN_INT32(</a>
<a name="ln1202">			44100 * sizeof(uint16) * 2);</a>
<a name="ln1203">		fWAVHeader.format.block_align = B_HOST_TO_LENDIAN_INT16(4);</a>
<a name="ln1204">		fWAVHeader.format.bits_per_sample = B_HOST_TO_LENDIAN_INT16(16);</a>
<a name="ln1205"> </a>
<a name="ln1206">		// 'data' chunk</a>
<a name="ln1207">		fWAVHeader.data.fourcc = B_HOST_TO_BENDIAN_INT32('data');</a>
<a name="ln1208">		fWAVHeader.data.length = B_HOST_TO_LENDIAN_INT32(Size());</a>
<a name="ln1209">	}</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212"> </a>
<a name="ln1213">Inode::~Inode()</a>
<a name="ln1214">{</a>
<a name="ln1215">	free(const_cast&lt;char*&gt;(fName));</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218"> </a>
<a name="ln1219">status_t</a>
<a name="ln1220">Inode::InitCheck()</a>
<a name="ln1221">{</a>
<a name="ln1222">	if (fName == NULL)</a>
<a name="ln1223">		return B_NO_MEMORY;</a>
<a name="ln1224"> </a>
<a name="ln1225">	return B_OK;</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228"> </a>
<a name="ln1229">status_t</a>
<a name="ln1230">Inode::SetName(const char* name)</a>
<a name="ln1231">{</a>
<a name="ln1232">	if (name == NULL || !name[0]</a>
<a name="ln1233">		|| strchr(name, '/') != NULL</a>
<a name="ln1234">		|| strchr(name, '\n') != NULL)</a>
<a name="ln1235">		return B_BAD_VALUE;</a>
<a name="ln1236"> </a>
<a name="ln1237">	name = strdup(name);</a>
<a name="ln1238">	if (name == NULL)</a>
<a name="ln1239">		return B_NO_MEMORY;</a>
<a name="ln1240"> </a>
<a name="ln1241">	free(fName);</a>
<a name="ln1242">	fName = (char*)name;</a>
<a name="ln1243">	return B_OK;</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246"> </a>
<a name="ln1247">Attribute*</a>
<a name="ln1248">Inode::FindAttribute(const char* name) const</a>
<a name="ln1249">{</a>
<a name="ln1250">	if (name == NULL || !name[0])</a>
<a name="ln1251">		return NULL;</a>
<a name="ln1252"> </a>
<a name="ln1253">	AttributeList::ConstIterator iterator = fAttributes.GetIterator();</a>
<a name="ln1254"> </a>
<a name="ln1255">	while (iterator.HasNext()) {</a>
<a name="ln1256">		Attribute* attribute = iterator.Next();</a>
<a name="ln1257">		if (!strcmp(attribute-&gt;Name(), name))</a>
<a name="ln1258">			return attribute;</a>
<a name="ln1259">	}</a>
<a name="ln1260"> </a>
<a name="ln1261">	return NULL;</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264"> </a>
<a name="ln1265">status_t</a>
<a name="ln1266">Inode::AddAttribute(Attribute* attribute, bool overwrite)</a>
<a name="ln1267">{</a>
<a name="ln1268">	Attribute* oldAttribute = FindAttribute(attribute-&gt;Name());</a>
<a name="ln1269">	if (oldAttribute != NULL) {</a>
<a name="ln1270">		if (!overwrite)</a>
<a name="ln1271">			return B_NAME_IN_USE;</a>
<a name="ln1272"> </a>
<a name="ln1273">		fAttributes.Remove(oldAttribute);</a>
<a name="ln1274">		delete oldAttribute;</a>
<a name="ln1275">	}</a>
<a name="ln1276"> </a>
<a name="ln1277">	fAttributes.Add(attribute);</a>
<a name="ln1278">	return B_OK;</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281"> </a>
<a name="ln1282">status_t</a>
<a name="ln1283">Inode::AddAttribute(const char* name, type_code type, bool overwrite,</a>
<a name="ln1284">	const uint8* data, size_t length)</a>
<a name="ln1285">{</a>
<a name="ln1286">	Attribute* attribute = new(std::nothrow) Attribute(name, type);</a>
<a name="ln1287">	if (attribute == NULL)</a>
<a name="ln1288">		return B_NO_MEMORY;</a>
<a name="ln1289"> </a>
<a name="ln1290">	status_t status = attribute-&gt;InitCheck();</a>
<a name="ln1291">	if (status == B_OK &amp;&amp; data != NULL &amp;&amp; length != 0)</a>
<a name="ln1292">		status = attribute-&gt;WriteAt(0, data, &amp;length);</a>
<a name="ln1293">	if (status == B_OK)</a>
<a name="ln1294">		status = AddAttribute(attribute, overwrite);</a>
<a name="ln1295">	if (status != B_OK) {</a>
<a name="ln1296">		delete attribute;</a>
<a name="ln1297">		return status;</a>
<a name="ln1298">	}</a>
<a name="ln1299"> </a>
<a name="ln1300">	return B_OK;</a>
<a name="ln1301">}</a>
<a name="ln1302"> </a>
<a name="ln1303"> </a>
<a name="ln1304">status_t</a>
<a name="ln1305">Inode::AddAttribute(const char* name, type_code type, const char* string)</a>
<a name="ln1306">{</a>
<a name="ln1307">	if (string == NULL)</a>
<a name="ln1308">		return B_BAD_VALUE;</a>
<a name="ln1309"> </a>
<a name="ln1310">	return AddAttribute(name, type, true, (const uint8*)string,</a>
<a name="ln1311">		strlen(string));</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314"> </a>
<a name="ln1315">status_t</a>
<a name="ln1316">Inode::AddAttribute(const char* name, type_code type, uint32 value)</a>
<a name="ln1317">{</a>
<a name="ln1318">	uint32 data = B_HOST_TO_LENDIAN_INT32(value);</a>
<a name="ln1319">	return AddAttribute(name, type, true, (const uint8*)&amp;data, sizeof(uint32));</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322"> </a>
<a name="ln1323">status_t</a>
<a name="ln1324">Inode::AddAttribute(const char* name, type_code type, uint64 value)</a>
<a name="ln1325">{</a>
<a name="ln1326">	uint64 data = B_HOST_TO_LENDIAN_INT64(value);</a>
<a name="ln1327">	return AddAttribute(name, type, true, (const uint8*)&amp;data, sizeof(uint64));</a>
<a name="ln1328">}</a>
<a name="ln1329"> </a>
<a name="ln1330"> </a>
<a name="ln1331">status_t</a>
<a name="ln1332">Inode::RemoveAttribute(const char* name, bool checkNamespace)</a>
<a name="ln1333">{</a>
<a name="ln1334">	if (name == NULL || !name[0])</a>
<a name="ln1335">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1336"> </a>
<a name="ln1337">	AttributeList::Iterator iterator = fAttributes.GetIterator();</a>
<a name="ln1338"> </a>
<a name="ln1339">	while (iterator.HasNext()) {</a>
<a name="ln1340">		Attribute* attribute = iterator.Next();</a>
<a name="ln1341">		if (!strcmp(attribute-&gt;Name(), name)) {</a>
<a name="ln1342">			// check for restricted namespace if required.</a>
<a name="ln1343">			if (checkNamespace &amp;&amp; attribute-&gt;IsProtectedNamespace())</a>
<a name="ln1344">				return B_NOT_ALLOWED;</a>
<a name="ln1345">			// look for attribute in cookies</a>
<a name="ln1346">			AttrCookieList::Iterator i = fAttrCookies.GetIterator();</a>
<a name="ln1347">			while (i.HasNext()) {</a>
<a name="ln1348">				attr_cookie* cookie = i.Next();</a>
<a name="ln1349">				if (cookie-&gt;current == attribute) {</a>
<a name="ln1350">					cookie-&gt;current</a>
<a name="ln1351">						= attribute-&gt;GetDoublyLinkedListLink()-&gt;next;</a>
<a name="ln1352">				}</a>
<a name="ln1353">			}</a>
<a name="ln1354"> </a>
<a name="ln1355">			iterator.Remove();</a>
<a name="ln1356">			delete attribute;</a>
<a name="ln1357">			return B_OK;</a>
<a name="ln1358">		}</a>
<a name="ln1359">	}</a>
<a name="ln1360"> </a>
<a name="ln1361">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln1362">}</a>
<a name="ln1363"> </a>
<a name="ln1364"> </a>
<a name="ln1365">void</a>
<a name="ln1366">Inode::AddAttrCookie(attr_cookie* cookie)</a>
<a name="ln1367">{</a>
<a name="ln1368">	fAttrCookies.Add(cookie);</a>
<a name="ln1369">	RewindAttrCookie(cookie);</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372"> </a>
<a name="ln1373">void</a>
<a name="ln1374">Inode::RemoveAttrCookie(attr_cookie* cookie)</a>
<a name="ln1375">{</a>
<a name="ln1376">	if (!fAttrCookies.Remove(cookie))</a>
<a name="ln1377">		panic(&quot;Tried to remove %p which is not in cookie list.&quot;, cookie);</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380"> </a>
<a name="ln1381">void</a>
<a name="ln1382">Inode::RewindAttrCookie(attr_cookie* cookie)</a>
<a name="ln1383">{</a>
<a name="ln1384">	cookie-&gt;current = fAttributes.First();</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387"> </a>
<a name="ln1388">//	#pragma mark - Module API</a>
<a name="ln1389"> </a>
<a name="ln1390"> </a>
<a name="ln1391">static float</a>
<a name="ln1392">cdda_identify_partition(int fd, partition_data* partition, void** _cookie)</a>
<a name="ln1393">{</a>
<a name="ln1394">	scsi_toc_toc* toc = (scsi_toc_toc*)malloc(2048);</a>
<a name="ln1395">	if (toc == NULL)</a>
<a name="ln1396">		return B_NO_MEMORY;</a>
<a name="ln1397"> </a>
<a name="ln1398">	status_t status = read_table_of_contents(fd, toc, 2048);</a>
<a name="ln1399"> </a>
<a name="ln1400">	// If we succeeded in reading the toc, check the tracks in the</a>
<a name="ln1401">	// partition, which may not be the whole CD, and if any are audio,</a>
<a name="ln1402">	// claim the partition.</a>
<a name="ln1403">	if (status == B_OK) {</a>
<a name="ln1404">		uint32 trackCount = toc-&gt;last_track + (uint32)1 - toc-&gt;first_track;</a>
<a name="ln1405">		uint64 sessionStartLBA = partition-&gt;offset / partition-&gt;block_size;</a>
<a name="ln1406">		uint64 sessionEndLBA	= sessionStartLBA</a>
<a name="ln1407">			+ (partition-&gt;size / partition-&gt;block_size);</a>
<a name="ln1408">		TRACE((&quot;cdda_identify_partition: session at %lld-%lld\n&quot;,</a>
<a name="ln1409">			sessionStartLBA, sessionEndLBA));</a>
<a name="ln1410">		status = B_ENTRY_NOT_FOUND;</a>
<a name="ln1411">		for (uint32 i = 0; i &lt; trackCount; i++) {</a>
<a name="ln1412">			// We have to get trackLBA from track.start.time since</a>
<a name="ln1413">			// track.start.lba is useless for this.</a>
<a name="ln1414">			// This is how session gets it.</a>
<a name="ln1415">			uint64 trackLBA</a>
<a name="ln1416">				= ((toc-&gt;tracks[i].start.time.minute * kFramesPerMinute)</a>
<a name="ln1417">					+ (toc-&gt;tracks[i].start.time.second * kFramesPerSecond)</a>
<a name="ln1418">					+ toc-&gt;tracks[i].start.time.frame - 150);</a>
<a name="ln1419">			if (trackLBA &gt;= sessionStartLBA &amp;&amp; trackLBA &lt; sessionEndLBA) {</a>
<a name="ln1420">				if (is_data_track(toc-&gt;tracks[i])) {</a>
<a name="ln1421">					TRACE((&quot;cdda_identify_partition: track %ld at %lld is &quot;</a>
<a name="ln1422">						&quot;data\n&quot;, i + 1, trackLBA));</a>
<a name="ln1423">					status = B_BAD_TYPE;</a>
<a name="ln1424">				} else {</a>
<a name="ln1425">					TRACE((&quot;cdda_identify_partition: track %ld at %lld is &quot;</a>
<a name="ln1426">						&quot;audio\n&quot;, i + 1, trackLBA));</a>
<a name="ln1427">					status = B_OK;</a>
<a name="ln1428">					break;</a>
<a name="ln1429">				}</a>
<a name="ln1430">			}</a>
<a name="ln1431">		}</a>
<a name="ln1432">	}</a>
<a name="ln1433"> </a>
<a name="ln1434">	if (status != B_OK) {</a>
<a name="ln1435">		free(toc);</a>
<a name="ln1436">		return status;</a>
<a name="ln1437">	}</a>
<a name="ln1438"> </a>
<a name="ln1439">	*_cookie = toc;</a>
<a name="ln1440">	return 0.8f;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443"> </a>
<a name="ln1444">static status_t</a>
<a name="ln1445">cdda_scan_partition(int fd, partition_data* partition, void* _cookie)</a>
<a name="ln1446">{</a>
<a name="ln1447">	scsi_toc_toc* toc = (scsi_toc_toc*)_cookie;</a>
<a name="ln1448"> </a>
<a name="ln1449">	partition-&gt;status = B_PARTITION_VALID;</a>
<a name="ln1450">	partition-&gt;flags |= B_PARTITION_FILE_SYSTEM;</a>
<a name="ln1451"> </a>
<a name="ln1452">	// compute length</a>
<a name="ln1453"> </a>
<a name="ln1454">	uint32 lastTrack = toc-&gt;last_track + 1 - toc-&gt;first_track;</a>
<a name="ln1455">	scsi_cd_msf&amp; end = toc-&gt;tracks[lastTrack].start.time;</a>
<a name="ln1456"> </a>
<a name="ln1457">	partition-&gt;content_size = off_t(end.minute * kFramesPerMinute</a>
<a name="ln1458">		+ end.second * kFramesPerSecond + end.frame) * kFrameSize;</a>
<a name="ln1459">	partition-&gt;block_size = kFrameSize;</a>
<a name="ln1460"> </a>
<a name="ln1461">	// determine volume title</a>
<a name="ln1462"> </a>
<a name="ln1463">	char name[256];</a>
<a name="ln1464">	Volume::DetermineName(compute_cddb_disc_id(*toc), fd, name, sizeof(name));</a>
<a name="ln1465"> </a>
<a name="ln1466">	partition-&gt;content_name = strdup(name);</a>
<a name="ln1467">	if (partition-&gt;content_name == NULL)</a>
<a name="ln1468">		return B_NO_MEMORY;</a>
<a name="ln1469"> </a>
<a name="ln1470">	return B_OK;</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473"> </a>
<a name="ln1474">static void</a>
<a name="ln1475">cdda_free_identify_partition_cookie(partition_data* partition, void* _cookie)</a>
<a name="ln1476">{</a>
<a name="ln1477">	free(_cookie);</a>
<a name="ln1478">}</a>
<a name="ln1479"> </a>
<a name="ln1480"> </a>
<a name="ln1481">static status_t</a>
<a name="ln1482">cdda_mount(fs_volume* fsVolume, const char* device, uint32 flags,</a>
<a name="ln1483">	const char* args, ino_t* _rootVnodeID)</a>
<a name="ln1484">{</a>
<a name="ln1485">	TRACE((&quot;cdda_mount: entry\n&quot;));</a>
<a name="ln1486"> </a>
<a name="ln1487">	Volume* volume = new(std::nothrow) Volume(fsVolume);</a>
<a name="ln1488">	if (volume == NULL)</a>
<a name="ln1489">		return B_NO_MEMORY;</a>
<a name="ln1490"> </a>
<a name="ln1491">	status_t status = volume-&gt;InitCheck();</a>
<a name="ln1492">	if (status == B_OK)</a>
<a name="ln1493">		status = volume-&gt;Mount(device);</a>
<a name="ln1494"> </a>
<a name="ln1495">	if (status &lt; B_OK) {</a>
<a name="ln1496">		delete volume;</a>
<a name="ln1497">		return status;</a>
<a name="ln1498">	}</a>
<a name="ln1499"> </a>
<a name="ln1500">	*_rootVnodeID = volume-&gt;RootNode().ID();</a>
<a name="ln1501">	fsVolume-&gt;private_volume = volume;</a>
<a name="ln1502">	fsVolume-&gt;ops = &amp;gCDDAVolumeOps;</a>
<a name="ln1503"> </a>
<a name="ln1504">	return B_OK;</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507"> </a>
<a name="ln1508">static status_t</a>
<a name="ln1509">cdda_unmount(fs_volume* _volume)</a>
<a name="ln1510">{</a>
<a name="ln1511">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1512"> </a>
<a name="ln1513">	TRACE((&quot;cdda_unmount: entry fs = %p\n&quot;, _volume));</a>
<a name="ln1514">	delete volume;</a>
<a name="ln1515"> </a>
<a name="ln1516">	return 0;</a>
<a name="ln1517">}</a>
<a name="ln1518"> </a>
<a name="ln1519"> </a>
<a name="ln1520">static status_t</a>
<a name="ln1521">cdda_read_fs_stat(fs_volume* _volume, struct fs_info* info)</a>
<a name="ln1522">{</a>
<a name="ln1523">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1524">	Locker locker(volume-&gt;Lock());</a>
<a name="ln1525"> </a>
<a name="ln1526">	// File system flags.</a>
<a name="ln1527">	info-&gt;flags = B_FS_IS_PERSISTENT | B_FS_HAS_ATTR | B_FS_HAS_MIME</a>
<a name="ln1528">		| B_FS_IS_REMOVABLE;</a>
<a name="ln1529">	info-&gt;io_size = 65536;</a>
<a name="ln1530"> </a>
<a name="ln1531">	info-&gt;block_size = 2048;</a>
<a name="ln1532">	info-&gt;total_blocks = volume-&gt;NumBlocks();</a>
<a name="ln1533">	info-&gt;free_blocks = 0;</a>
<a name="ln1534"> </a>
<a name="ln1535">	// Volume name</a>
<a name="ln1536">	strlcpy(info-&gt;volume_name, volume-&gt;Name(), sizeof(info-&gt;volume_name));</a>
<a name="ln1537"> </a>
<a name="ln1538">	// File system name</a>
<a name="ln1539">	strlcpy(info-&gt;fsh_name, &quot;cdda&quot;, sizeof(info-&gt;fsh_name));</a>
<a name="ln1540"> </a>
<a name="ln1541">	return B_OK;</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544"> </a>
<a name="ln1545">static status_t</a>
<a name="ln1546">cdda_write_fs_stat(fs_volume* _volume, const struct fs_info* info, uint32 mask)</a>
<a name="ln1547">{</a>
<a name="ln1548">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1549">	Locker locker(volume-&gt;Lock());</a>
<a name="ln1550"> </a>
<a name="ln1551">	status_t status = B_BAD_VALUE;</a>
<a name="ln1552"> </a>
<a name="ln1553">	if ((mask &amp; FS_WRITE_FSINFO_NAME) != 0) {</a>
<a name="ln1554">		status = volume-&gt;SetName(info-&gt;volume_name);</a>
<a name="ln1555">	}</a>
<a name="ln1556"> </a>
<a name="ln1557">	return status;</a>
<a name="ln1558">}</a>
<a name="ln1559"> </a>
<a name="ln1560"> </a>
<a name="ln1561">static status_t</a>
<a name="ln1562">cdda_sync(fs_volume* _volume)</a>
<a name="ln1563">{</a>
<a name="ln1564">	TRACE((&quot;cdda_sync: entry\n&quot;));</a>
<a name="ln1565"> </a>
<a name="ln1566">	return B_OK;</a>
<a name="ln1567">}</a>
<a name="ln1568"> </a>
<a name="ln1569"> </a>
<a name="ln1570">static status_t</a>
<a name="ln1571">cdda_lookup(fs_volume* _volume, fs_vnode* _dir, const char* name, ino_t* _id)</a>
<a name="ln1572">{</a>
<a name="ln1573">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1574">	status_t status;</a>
<a name="ln1575"> </a>
<a name="ln1576">	TRACE((&quot;cdda_lookup: entry dir %p, name '%s'\n&quot;, _dir, name));</a>
<a name="ln1577"> </a>
<a name="ln1578">	Inode* directory = (Inode*)_dir-&gt;private_node;</a>
<a name="ln1579">	if (!S_ISDIR(directory-&gt;Type()))</a>
<a name="ln1580">		return B_NOT_A_DIRECTORY;</a>
<a name="ln1581"> </a>
<a name="ln1582">	Locker _(volume-&gt;Lock());</a>
<a name="ln1583"> </a>
<a name="ln1584">	Inode* inode = volume-&gt;Find(name);</a>
<a name="ln1585">	if (inode == NULL)</a>
<a name="ln1586">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1587"> </a>
<a name="ln1588">	status = get_vnode(volume-&gt;FSVolume(), inode-&gt;ID(), NULL);</a>
<a name="ln1589">	if (status &lt; B_OK)</a>
<a name="ln1590">		return status;</a>
<a name="ln1591"> </a>
<a name="ln1592">	*_id = inode-&gt;ID();</a>
<a name="ln1593">	return B_OK;</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596"> </a>
<a name="ln1597">static status_t</a>
<a name="ln1598">cdda_get_vnode_name(fs_volume* _volume, fs_vnode* _node, char* buffer,</a>
<a name="ln1599">	size_t bufferSize)</a>
<a name="ln1600">{</a>
<a name="ln1601">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1602">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln1603"> </a>
<a name="ln1604">	TRACE((&quot;cdda_get_vnode_name(): inode = %p\n&quot;, inode));</a>
<a name="ln1605"> </a>
<a name="ln1606">	Locker _(volume-&gt;Lock());</a>
<a name="ln1607">	strlcpy(buffer, inode-&gt;Name(), bufferSize);</a>
<a name="ln1608">	return B_OK;</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611"> </a>
<a name="ln1612">static status_t</a>
<a name="ln1613">cdda_get_vnode(fs_volume* _volume, ino_t id, fs_vnode* _node, int* _type,</a>
<a name="ln1614">	uint32* _flags, bool reenter)</a>
<a name="ln1615">{</a>
<a name="ln1616">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1617">	Inode* inode;</a>
<a name="ln1618"> </a>
<a name="ln1619">	TRACE((&quot;cdda_getvnode: asking for vnode 0x%Lx, r %d\n&quot;, id, reenter));</a>
<a name="ln1620"> </a>
<a name="ln1621">	inode = volume-&gt;Find(id);</a>
<a name="ln1622">	if (inode == NULL)</a>
<a name="ln1623">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1624"> </a>
<a name="ln1625">	_node-&gt;private_node = inode;</a>
<a name="ln1626">	_node-&gt;ops = &amp;gCDDAVnodeOps;</a>
<a name="ln1627">	*_type = inode-&gt;Type();</a>
<a name="ln1628">	*_flags = 0;</a>
<a name="ln1629">	return B_OK;</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632"> </a>
<a name="ln1633">static status_t</a>
<a name="ln1634">cdda_put_vnode(fs_volume* _volume, fs_vnode* _node, bool reenter)</a>
<a name="ln1635">{</a>
<a name="ln1636">	return B_OK;</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639"> </a>
<a name="ln1640">static status_t</a>
<a name="ln1641">cdda_open(fs_volume* _volume, fs_vnode* _node, int openMode, void** _cookie)</a>
<a name="ln1642">{</a>
<a name="ln1643">	TRACE((&quot;cdda_open(): node = %p, openMode = %d\n&quot;, _node, openMode));</a>
<a name="ln1644"> </a>
<a name="ln1645">	file_cookie* cookie = (file_cookie*)malloc(sizeof(file_cookie));</a>
<a name="ln1646">	if (cookie == NULL)</a>
<a name="ln1647">		return B_NO_MEMORY;</a>
<a name="ln1648"> </a>
<a name="ln1649">	TRACE((&quot;  open cookie = %p\n&quot;, cookie));</a>
<a name="ln1650">	cookie-&gt;open_mode = openMode;</a>
<a name="ln1651">	cookie-&gt;buffer = NULL;</a>
<a name="ln1652"> </a>
<a name="ln1653">	*_cookie = (void*)cookie;</a>
<a name="ln1654"> </a>
<a name="ln1655">	return B_OK;</a>
<a name="ln1656">}</a>
<a name="ln1657"> </a>
<a name="ln1658"> </a>
<a name="ln1659">static status_t</a>
<a name="ln1660">cdda_close(fs_volume* _volume, fs_vnode* _node, void* _cookie)</a>
<a name="ln1661">{</a>
<a name="ln1662">	return B_OK;</a>
<a name="ln1663">}</a>
<a name="ln1664"> </a>
<a name="ln1665"> </a>
<a name="ln1666">static status_t</a>
<a name="ln1667">cdda_free_cookie(fs_volume* _volume, fs_vnode* _node, void* _cookie)</a>
<a name="ln1668">{</a>
<a name="ln1669">	file_cookie* cookie = (file_cookie*)_cookie;</a>
<a name="ln1670"> </a>
<a name="ln1671">	TRACE((&quot;cdda_freecookie: entry vnode %p, cookie %p\n&quot;, _node, _cookie));</a>
<a name="ln1672"> </a>
<a name="ln1673">	free(cookie);</a>
<a name="ln1674">	return B_OK;</a>
<a name="ln1675">}</a>
<a name="ln1676"> </a>
<a name="ln1677"> </a>
<a name="ln1678">static status_t</a>
<a name="ln1679">cdda_fsync(fs_volume* _volume, fs_vnode* _node)</a>
<a name="ln1680">{</a>
<a name="ln1681">	return B_OK;</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684"> </a>
<a name="ln1685">static status_t</a>
<a name="ln1686">cdda_read(fs_volume* _volume, fs_vnode* _node, void* _cookie, off_t offset,</a>
<a name="ln1687">	void* buffer, size_t* _length)</a>
<a name="ln1688">{</a>
<a name="ln1689">	file_cookie* cookie = (file_cookie*)_cookie;</a>
<a name="ln1690">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1691">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln1692"> </a>
<a name="ln1693">	TRACE((&quot;cdda_read(vnode = %p, offset %Ld, length = %lu, mode = %d)\n&quot;,</a>
<a name="ln1694">		_node, offset, *_length, cookie-&gt;open_mode));</a>
<a name="ln1695"> </a>
<a name="ln1696">	if (S_ISDIR(inode-&gt;Type()))</a>
<a name="ln1697">		return B_IS_A_DIRECTORY;</a>
<a name="ln1698">	if (offset &lt; 0)</a>
<a name="ln1699">		return B_BAD_VALUE;</a>
<a name="ln1700"> </a>
<a name="ln1701">	off_t maxSize = inode-&gt;Size() + sizeof(wav_header);</a>
<a name="ln1702">	if (offset &gt;= maxSize) {</a>
<a name="ln1703">		*_length = 0;</a>
<a name="ln1704">		return B_OK;</a>
<a name="ln1705">	}</a>
<a name="ln1706"> </a>
<a name="ln1707">	if (cookie-&gt;buffer == NULL) {</a>
<a name="ln1708">		// TODO: move that to open() to make sure reading can't fail for this reason?</a>
<a name="ln1709">		cookie-&gt;buffer = malloc(volume-&gt;BufferSize());</a>
<a name="ln1710">		if (cookie-&gt;buffer == NULL)</a>
<a name="ln1711">			return B_NO_MEMORY;</a>
<a name="ln1712"> </a>
<a name="ln1713">		cookie-&gt;buffer_offset = -1;</a>
<a name="ln1714">	}</a>
<a name="ln1715"> </a>
<a name="ln1716">	size_t length = *_length;</a>
<a name="ln1717">	if (offset + (off_t)length &gt; maxSize)</a>
<a name="ln1718">		length = maxSize - offset;</a>
<a name="ln1719"> </a>
<a name="ln1720">	status_t status = B_OK;</a>
<a name="ln1721">	size_t bytesRead = 0;</a>
<a name="ln1722"> </a>
<a name="ln1723">	if (offset &lt; (off_t)sizeof(wav_header)) {</a>
<a name="ln1724">		// read fake WAV header</a>
<a name="ln1725">		size_t size = sizeof(wav_header) - offset;</a>
<a name="ln1726">		size = min_c(size, length);</a>
<a name="ln1727"> </a>
<a name="ln1728">		if (user_memcpy(buffer, (uint8*)inode-&gt;WAVHeader() + offset, size)</a>
<a name="ln1729">				&lt; B_OK)</a>
<a name="ln1730">			return B_BAD_ADDRESS;</a>
<a name="ln1731"> </a>
<a name="ln1732">		buffer = (void*)((uint8*)buffer + size);</a>
<a name="ln1733">		length -= size;</a>
<a name="ln1734">		bytesRead += size;</a>
<a name="ln1735">		offset = 0;</a>
<a name="ln1736">	} else</a>
<a name="ln1737">		offset -= sizeof(wav_header);</a>
<a name="ln1738"> </a>
<a name="ln1739">	if (length &gt; 0) {</a>
<a name="ln1740">		// read actual CD data</a>
<a name="ln1741">		offset += inode-&gt;StartFrame() * kFrameSize;</a>
<a name="ln1742"> </a>
<a name="ln1743">		status = read_cdda_data(volume-&gt;Device(),</a>
<a name="ln1744">			inode-&gt;StartFrame() + inode-&gt;FrameCount(), offset, buffer, length,</a>
<a name="ln1745">			cookie-&gt;buffer_offset, cookie-&gt;buffer, volume-&gt;BufferSize());</a>
<a name="ln1746"> </a>
<a name="ln1747">		bytesRead += length;</a>
<a name="ln1748">	}</a>
<a name="ln1749">	if (status == B_OK)</a>
<a name="ln1750">		*_length = bytesRead;</a>
<a name="ln1751"> </a>
<a name="ln1752">	return status;</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755"> </a>
<a name="ln1756">static bool</a>
<a name="ln1757">cdda_can_page(fs_volume* _volume, fs_vnode* _node, void* cookie)</a>
<a name="ln1758">{</a>
<a name="ln1759">	return false;</a>
<a name="ln1760">}</a>
<a name="ln1761"> </a>
<a name="ln1762"> </a>
<a name="ln1763">static status_t</a>
<a name="ln1764">cdda_read_pages(fs_volume* _volume, fs_vnode* _node, void* cookie, off_t pos,</a>
<a name="ln1765">	const iovec* vecs, size_t count, size_t* _numBytes)</a>
<a name="ln1766">{</a>
<a name="ln1767">	return B_NOT_ALLOWED;</a>
<a name="ln1768">}</a>
<a name="ln1769"> </a>
<a name="ln1770"> </a>
<a name="ln1771">static status_t</a>
<a name="ln1772">cdda_write_pages(fs_volume* _volume, fs_vnode* _node, void* cookie, off_t pos,</a>
<a name="ln1773">	const iovec* vecs, size_t count, size_t* _numBytes)</a>
<a name="ln1774">{</a>
<a name="ln1775">	return B_NOT_ALLOWED;</a>
<a name="ln1776">}</a>
<a name="ln1777"> </a>
<a name="ln1778"> </a>
<a name="ln1779">static status_t</a>
<a name="ln1780">cdda_read_stat(fs_volume* _volume, fs_vnode* _node, struct stat* stat)</a>
<a name="ln1781">{</a>
<a name="ln1782">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1783">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln1784"> </a>
<a name="ln1785">	TRACE((&quot;cdda_read_stat: vnode %p (0x%Lx), stat %p\n&quot;, inode, inode-&gt;ID(),</a>
<a name="ln1786">		stat));</a>
<a name="ln1787"> </a>
<a name="ln1788">	fill_stat_buffer(volume, inode, NULL, *stat);</a>
<a name="ln1789"> </a>
<a name="ln1790">	return B_OK;</a>
<a name="ln1791">}</a>
<a name="ln1792"> </a>
<a name="ln1793"> </a>
<a name="ln1794">status_t</a>
<a name="ln1795">cdda_rename(fs_volume* _volume, fs_vnode* _oldDir, const char* oldName,</a>
<a name="ln1796">	fs_vnode* _newDir, const char* newName)</a>
<a name="ln1797">{</a>
<a name="ln1798">	if (_oldDir-&gt;private_node != _newDir-&gt;private_node)</a>
<a name="ln1799">		return B_BAD_VALUE;</a>
<a name="ln1800"> </a>
<a name="ln1801">	// we only have a single directory which simplifies things a bit :-)</a>
<a name="ln1802"> </a>
<a name="ln1803">	Volume *volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1804">	Locker _(volume-&gt;Lock());</a>
<a name="ln1805"> </a>
<a name="ln1806">	Inode* inode = volume-&gt;Find(oldName);</a>
<a name="ln1807">	if (inode == NULL)</a>
<a name="ln1808">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1809"> </a>
<a name="ln1810">	if (volume-&gt;Find(newName) != NULL)</a>
<a name="ln1811">		return B_NAME_IN_USE;</a>
<a name="ln1812"> </a>
<a name="ln1813">	status_t status = inode-&gt;SetName(newName);</a>
<a name="ln1814">	if (status == B_OK) {</a>
<a name="ln1815">		// One of the tracks had its name edited from outside the filesystem</a>
<a name="ln1816">		// add-on. Disable CDDB lookups. Note this will usually mean that the</a>
<a name="ln1817">		// user manually renamed a track or that cddblinkd (or other program)</a>
<a name="ln1818">		// did this so we do not want to do it again.</a>
<a name="ln1819">		volume-&gt;SetCDDBLookupsEnabled(false);</a>
<a name="ln1820"> </a>
<a name="ln1821">		notify_entry_moved(volume-&gt;ID(), volume-&gt;RootNode().ID(), oldName,</a>
<a name="ln1822">			volume-&gt;RootNode().ID(), newName, inode-&gt;ID());</a>
<a name="ln1823">	}</a>
<a name="ln1824"> </a>
<a name="ln1825">	return status;</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828"> </a>
<a name="ln1829">//	#pragma mark - directory functions</a>
<a name="ln1830"> </a>
<a name="ln1831"> </a>
<a name="ln1832">static status_t</a>
<a name="ln1833">cdda_open_dir(fs_volume* _volume, fs_vnode* _node, void** _cookie)</a>
<a name="ln1834">{</a>
<a name="ln1835">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1836"> </a>
<a name="ln1837">	TRACE((&quot;cdda_open_dir(): vnode = %p\n&quot;, _node));</a>
<a name="ln1838"> </a>
<a name="ln1839">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln1840">	if (!S_ISDIR(inode-&gt;Type()))</a>
<a name="ln1841">		return B_NOT_A_DIRECTORY;</a>
<a name="ln1842"> </a>
<a name="ln1843">	if (inode != &amp;volume-&gt;RootNode())</a>
<a name="ln1844">		panic(&quot;pipefs: found directory that's not the root!&quot;);</a>
<a name="ln1845"> </a>
<a name="ln1846">	dir_cookie* cookie = (dir_cookie*)malloc(sizeof(dir_cookie));</a>
<a name="ln1847">	if (cookie == NULL)</a>
<a name="ln1848">		return B_NO_MEMORY;</a>
<a name="ln1849"> </a>
<a name="ln1850">	cookie-&gt;current = volume-&gt;FirstEntry();</a>
<a name="ln1851">	cookie-&gt;state = ITERATION_STATE_BEGIN;</a>
<a name="ln1852"> </a>
<a name="ln1853">	*_cookie = (void*)cookie;</a>
<a name="ln1854">	return B_OK;</a>
<a name="ln1855">}</a>
<a name="ln1856"> </a>
<a name="ln1857"> </a>
<a name="ln1858">static status_t</a>
<a name="ln1859">cdda_read_dir(fs_volume* _volume, fs_vnode* _node, void* _cookie,</a>
<a name="ln1860">	struct dirent* buffer, size_t bufferSize, uint32* _num)</a>
<a name="ln1861">{</a>
<a name="ln1862">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1863">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln1864"> </a>
<a name="ln1865">	TRACE((&quot;cdda_read_dir: vnode %p, cookie %p, buffer = %p, bufferSize = %ld,&quot;</a>
<a name="ln1866">		&quot; num = %p\n&quot;, _node, _cookie, buffer, bufferSize,_num));</a>
<a name="ln1867"> </a>
<a name="ln1868">	if ((Inode*)_node-&gt;private_node != &amp;volume-&gt;RootNode())</a>
<a name="ln1869">		return B_BAD_VALUE;</a>
<a name="ln1870"> </a>
<a name="ln1871">	Locker _(volume-&gt;Lock());</a>
<a name="ln1872"> </a>
<a name="ln1873">	dir_cookie* cookie = (dir_cookie*)_cookie;</a>
<a name="ln1874">	Inode* childNode = NULL;</a>
<a name="ln1875">	const char* name = NULL;</a>
<a name="ln1876">	Inode* nextChildNode = NULL;</a>
<a name="ln1877">	int nextState = cookie-&gt;state;</a>
<a name="ln1878">	uint32 max = *_num;</a>
<a name="ln1879">	uint32 count = 0;</a>
<a name="ln1880"> </a>
<a name="ln1881">	while (count &lt; max &amp;&amp; bufferSize &gt; sizeof(dirent)) {</a>
<a name="ln1882">		switch (cookie-&gt;state) {</a>
<a name="ln1883">			case ITERATION_STATE_DOT:</a>
<a name="ln1884">				childNode = inode;</a>
<a name="ln1885">				name = &quot;.&quot;;</a>
<a name="ln1886">				nextChildNode = volume-&gt;FirstEntry();</a>
<a name="ln1887">				nextState = cookie-&gt;state + 1;</a>
<a name="ln1888">				break;</a>
<a name="ln1889">			case ITERATION_STATE_DOT_DOT:</a>
<a name="ln1890">				childNode = inode; // parent of the root node is the root node</a>
<a name="ln1891">				name = &quot;..&quot;;</a>
<a name="ln1892">				nextChildNode = volume-&gt;FirstEntry();</a>
<a name="ln1893">				nextState = cookie-&gt;state + 1;</a>
<a name="ln1894">				break;</a>
<a name="ln1895">			default:</a>
<a name="ln1896">				childNode = cookie-&gt;current;</a>
<a name="ln1897">				if (childNode) {</a>
<a name="ln1898">					name = childNode-&gt;Name();</a>
<a name="ln1899">					nextChildNode = childNode-&gt;Next();</a>
<a name="ln1900">				}</a>
<a name="ln1901">				break;</a>
<a name="ln1902">		}</a>
<a name="ln1903"> </a>
<a name="ln1904">		if (childNode == NULL) {</a>
<a name="ln1905">			// we're at the end of the directory</a>
<a name="ln1906">			break;</a>
<a name="ln1907">		}</a>
<a name="ln1908"> </a>
<a name="ln1909">		buffer-&gt;d_dev = volume-&gt;FSVolume()-&gt;id;</a>
<a name="ln1910">		buffer-&gt;d_ino = childNode-&gt;ID();</a>
<a name="ln1911">		buffer-&gt;d_reclen = strlen(name) + sizeof(struct dirent);</a>
<a name="ln1912"> </a>
<a name="ln1913">		if (buffer-&gt;d_reclen &gt; bufferSize) {</a>
<a name="ln1914">			if (count == 0)</a>
<a name="ln1915">				return ENOBUFS;</a>
<a name="ln1916"> </a>
<a name="ln1917">			break;</a>
<a name="ln1918">		}</a>
<a name="ln1919"> </a>
<a name="ln1920">		strcpy(buffer-&gt;d_name, name);</a>
<a name="ln1921"> </a>
<a name="ln1922">		bufferSize -= buffer-&gt;d_reclen;</a>
<a name="ln1923">		buffer = (struct dirent*)((uint8*)buffer + buffer-&gt;d_reclen);</a>
<a name="ln1924">		count++;</a>
<a name="ln1925"> </a>
<a name="ln1926">		cookie-&gt;current = nextChildNode;</a>
<a name="ln1927">		cookie-&gt;state = nextState;</a>
<a name="ln1928">	}</a>
<a name="ln1929"> </a>
<a name="ln1930">	*_num = count;</a>
<a name="ln1931">	return B_OK;</a>
<a name="ln1932">}</a>
<a name="ln1933"> </a>
<a name="ln1934"> </a>
<a name="ln1935">static status_t</a>
<a name="ln1936">cdda_rewind_dir(fs_volume* _volume, fs_vnode* _node, void* _cookie)</a>
<a name="ln1937">{</a>
<a name="ln1938">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1939"> </a>
<a name="ln1940">	dir_cookie* cookie = (dir_cookie*)_cookie;</a>
<a name="ln1941">	cookie-&gt;current = volume-&gt;FirstEntry();</a>
<a name="ln1942">	cookie-&gt;state = ITERATION_STATE_BEGIN;</a>
<a name="ln1943"> </a>
<a name="ln1944">	return B_OK;</a>
<a name="ln1945">}</a>
<a name="ln1946"> </a>
<a name="ln1947"> </a>
<a name="ln1948">static status_t</a>
<a name="ln1949">cdda_close_dir(fs_volume* _volume, fs_vnode* _node, void* _cookie)</a>
<a name="ln1950">{</a>
<a name="ln1951">	TRACE((&quot;cdda_close: entry vnode %p, cookie %p\n&quot;, _node, _cookie));</a>
<a name="ln1952"> </a>
<a name="ln1953">	return 0;</a>
<a name="ln1954">}</a>
<a name="ln1955"> </a>
<a name="ln1956"> </a>
<a name="ln1957">static status_t</a>
<a name="ln1958">cdda_free_dir_cookie(fs_volume* _volume, fs_vnode* _node, void* _cookie)</a>
<a name="ln1959">{</a>
<a name="ln1960">	dir_cookie* cookie = (dir_cookie*)_cookie;</a>
<a name="ln1961"> </a>
<a name="ln1962">	TRACE((&quot;cdda_freecookie: entry vnode %p, cookie %p\n&quot;, _node, cookie));</a>
<a name="ln1963"> </a>
<a name="ln1964">	free(cookie);</a>
<a name="ln1965">	return 0;</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968"> </a>
<a name="ln1969">//	#pragma mark - attribute functions</a>
<a name="ln1970"> </a>
<a name="ln1971"> </a>
<a name="ln1972">static status_t</a>
<a name="ln1973">cdda_open_attr_dir(fs_volume* _volume, fs_vnode* _node, void** _cookie)</a>
<a name="ln1974">{</a>
<a name="ln1975">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln1976">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln1977"> </a>
<a name="ln1978">	attr_cookie* cookie = new(std::nothrow) attr_cookie;</a>
<a name="ln1979">	if (cookie == NULL)</a>
<a name="ln1980">		return B_NO_MEMORY;</a>
<a name="ln1981"> </a>
<a name="ln1982">	Locker _(volume-&gt;Lock());</a>
<a name="ln1983"> </a>
<a name="ln1984">	inode-&gt;AddAttrCookie(cookie);</a>
<a name="ln1985">	*_cookie = cookie;</a>
<a name="ln1986">	return B_OK;</a>
<a name="ln1987">}</a>
<a name="ln1988"> </a>
<a name="ln1989"> </a>
<a name="ln1990">static status_t</a>
<a name="ln1991">cdda_close_attr_dir(fs_volume* _volume, fs_vnode* _node, void* _cookie)</a>
<a name="ln1992">{</a>
<a name="ln1993">	return B_OK;</a>
<a name="ln1994">}</a>
<a name="ln1995"> </a>
<a name="ln1996"> </a>
<a name="ln1997">static status_t</a>
<a name="ln1998">cdda_free_attr_dir_cookie(fs_volume* _volume, fs_vnode* _node, void* _cookie)</a>
<a name="ln1999">{</a>
<a name="ln2000">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2001">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2002">	attr_cookie* cookie = (attr_cookie*)_cookie;</a>
<a name="ln2003"> </a>
<a name="ln2004">	Locker _(volume-&gt;Lock());</a>
<a name="ln2005"> </a>
<a name="ln2006">	inode-&gt;RemoveAttrCookie(cookie);</a>
<a name="ln2007">	delete cookie;</a>
<a name="ln2008">	return B_OK;</a>
<a name="ln2009">}</a>
<a name="ln2010"> </a>
<a name="ln2011"> </a>
<a name="ln2012">static status_t</a>
<a name="ln2013">cdda_rewind_attr_dir(fs_volume* _volume, fs_vnode* _node, void* _cookie)</a>
<a name="ln2014">{</a>
<a name="ln2015">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2016">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2017">	attr_cookie* cookie = (attr_cookie*)_cookie;</a>
<a name="ln2018"> </a>
<a name="ln2019">	Locker _(volume-&gt;Lock());</a>
<a name="ln2020"> </a>
<a name="ln2021">	inode-&gt;RewindAttrCookie(cookie);</a>
<a name="ln2022">	return B_OK;</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025"> </a>
<a name="ln2026">static status_t</a>
<a name="ln2027">cdda_read_attr_dir(fs_volume* _volume, fs_vnode* _node, void* _cookie,</a>
<a name="ln2028">	struct dirent* dirent, size_t bufferSize, uint32* _num)</a>
<a name="ln2029">{</a>
<a name="ln2030">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2031">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2032">	attr_cookie* cookie = (attr_cookie*)_cookie;</a>
<a name="ln2033"> </a>
<a name="ln2034">	Locker _(volume-&gt;Lock());</a>
<a name="ln2035">	Attribute* attribute = cookie-&gt;current;</a>
<a name="ln2036"> </a>
<a name="ln2037">	if (attribute == NULL) {</a>
<a name="ln2038">		*_num = 0;</a>
<a name="ln2039">		return B_OK;</a>
<a name="ln2040">	}</a>
<a name="ln2041"> </a>
<a name="ln2042">	size_t length = strlcpy(dirent-&gt;d_name, attribute-&gt;Name(), bufferSize);</a>
<a name="ln2043">	dirent-&gt;d_dev = volume-&gt;FSVolume()-&gt;id;</a>
<a name="ln2044">	dirent-&gt;d_ino = inode-&gt;ID();</a>
<a name="ln2045">	dirent-&gt;d_reclen = sizeof(struct dirent) + length;</a>
<a name="ln2046"> </a>
<a name="ln2047">	cookie-&gt;current = attribute-&gt;GetDoublyLinkedListLink()-&gt;next;</a>
<a name="ln2048">	*_num = 1;</a>
<a name="ln2049">	return B_OK;</a>
<a name="ln2050">}</a>
<a name="ln2051"> </a>
<a name="ln2052"> </a>
<a name="ln2053">static status_t</a>
<a name="ln2054">cdda_create_attr(fs_volume* _volume, fs_vnode* _node, const char* name,</a>
<a name="ln2055">	uint32 type, int openMode, void** _cookie)</a>
<a name="ln2056">{</a>
<a name="ln2057">	Volume *volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2058">	Inode *inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2059"> </a>
<a name="ln2060">	Locker _(volume-&gt;Lock());</a>
<a name="ln2061"> </a>
<a name="ln2062">	Attribute* attribute = inode-&gt;FindAttribute(name);</a>
<a name="ln2063">	if (attribute == NULL) {</a>
<a name="ln2064">		if (Attribute::IsProtectedNamespace(name))</a>
<a name="ln2065">			return B_NOT_ALLOWED;</a>
<a name="ln2066">		status_t status = inode-&gt;AddAttribute(name, type, true, NULL, 0);</a>
<a name="ln2067">		if (status != B_OK)</a>
<a name="ln2068">			return status;</a>
<a name="ln2069"> </a>
<a name="ln2070">		notify_attribute_changed(volume-&gt;ID(), -1, inode-&gt;ID(), name,</a>
<a name="ln2071">			B_ATTR_CREATED);</a>
<a name="ln2072">	} else if ((openMode &amp; O_EXCL) == 0) {</a>
<a name="ln2073">		if (attribute-&gt;IsProtectedNamespace())</a>
<a name="ln2074">			return B_NOT_ALLOWED;</a>
<a name="ln2075">		attribute-&gt;SetType(type);</a>
<a name="ln2076">		if ((openMode &amp; O_TRUNC) != 0)</a>
<a name="ln2077">			attribute-&gt;Truncate();</a>
<a name="ln2078">	} else</a>
<a name="ln2079">		return B_FILE_EXISTS;</a>
<a name="ln2080"> </a>
<a name="ln2081">	*_cookie = strdup(name);</a>
<a name="ln2082">	if (*_cookie == NULL)</a>
<a name="ln2083">		return B_NO_MEMORY;</a>
<a name="ln2084"> </a>
<a name="ln2085">	return B_OK;</a>
<a name="ln2086">}</a>
<a name="ln2087"> </a>
<a name="ln2088"> </a>
<a name="ln2089">static status_t</a>
<a name="ln2090">cdda_open_attr(fs_volume* _volume, fs_vnode* _node, const char* name,</a>
<a name="ln2091">	int openMode, void** _cookie)</a>
<a name="ln2092">{</a>
<a name="ln2093">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2094">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2095"> </a>
<a name="ln2096">	Locker _(volume-&gt;Lock());</a>
<a name="ln2097"> </a>
<a name="ln2098">	Attribute* attribute = inode-&gt;FindAttribute(name);</a>
<a name="ln2099">	if (attribute == NULL)</a>
<a name="ln2100">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2101"> </a>
<a name="ln2102">	*_cookie = strdup(name);</a>
<a name="ln2103">	if (*_cookie == NULL)</a>
<a name="ln2104">		return B_NO_MEMORY;</a>
<a name="ln2105"> </a>
<a name="ln2106">	return B_OK;</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109"> </a>
<a name="ln2110">static status_t</a>
<a name="ln2111">cdda_close_attr(fs_volume* _volume, fs_vnode* _node, void* cookie)</a>
<a name="ln2112">{</a>
<a name="ln2113">	return B_OK;</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116"> </a>
<a name="ln2117">static status_t</a>
<a name="ln2118">cdda_free_attr_cookie(fs_volume* _volume, fs_vnode* _node, void* cookie)</a>
<a name="ln2119">{</a>
<a name="ln2120">	free(cookie);</a>
<a name="ln2121">	return B_OK;</a>
<a name="ln2122">}</a>
<a name="ln2123"> </a>
<a name="ln2124"> </a>
<a name="ln2125">static status_t</a>
<a name="ln2126">cdda_read_attr(fs_volume* _volume, fs_vnode* _node, void* _cookie,</a>
<a name="ln2127">	off_t offset, void* buffer, size_t* _length)</a>
<a name="ln2128">{</a>
<a name="ln2129">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2130">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2131"> </a>
<a name="ln2132">	Locker _(volume-&gt;Lock());</a>
<a name="ln2133"> </a>
<a name="ln2134">	Attribute* attribute = inode-&gt;FindAttribute((const char*)_cookie);</a>
<a name="ln2135">	if (attribute == NULL)</a>
<a name="ln2136">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2137"> </a>
<a name="ln2138">	return attribute-&gt;ReadAt(offset, (uint8*)buffer, _length);</a>
<a name="ln2139">}</a>
<a name="ln2140"> </a>
<a name="ln2141"> </a>
<a name="ln2142">static status_t</a>
<a name="ln2143">cdda_write_attr(fs_volume* _volume, fs_vnode* _node, void* _cookie,</a>
<a name="ln2144">	off_t offset, const void* buffer, size_t* _length)</a>
<a name="ln2145">{</a>
<a name="ln2146">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2147">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2148"> </a>
<a name="ln2149">	Locker _(volume-&gt;Lock());</a>
<a name="ln2150"> </a>
<a name="ln2151">	Attribute* attribute = inode-&gt;FindAttribute((const char*)_cookie);</a>
<a name="ln2152">	if (attribute == NULL)</a>
<a name="ln2153">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2154"> </a>
<a name="ln2155">	if (attribute-&gt;IsProtectedNamespace())</a>
<a name="ln2156">		return B_NOT_ALLOWED;</a>
<a name="ln2157"> </a>
<a name="ln2158">	status_t status = attribute-&gt;WriteAt(offset, (uint8*)buffer, _length);</a>
<a name="ln2159">	if (status == B_OK) {</a>
<a name="ln2160">		notify_attribute_changed(volume-&gt;ID(), -1, inode-&gt;ID(),</a>
<a name="ln2161">			attribute-&gt;Name(), B_ATTR_CHANGED);</a>
<a name="ln2162">	}</a>
<a name="ln2163">	return status;</a>
<a name="ln2164">}</a>
<a name="ln2165"> </a>
<a name="ln2166"> </a>
<a name="ln2167">static status_t</a>
<a name="ln2168">cdda_read_attr_stat(fs_volume* _volume, fs_vnode* _node, void* _cookie,</a>
<a name="ln2169">	struct stat* stat)</a>
<a name="ln2170">{</a>
<a name="ln2171">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2172">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2173"> </a>
<a name="ln2174">	Locker _(volume-&gt;Lock());</a>
<a name="ln2175"> </a>
<a name="ln2176">	Attribute* attribute = inode-&gt;FindAttribute((const char*)_cookie);</a>
<a name="ln2177">	if (attribute == NULL)</a>
<a name="ln2178">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2179"> </a>
<a name="ln2180">	fill_stat_buffer(volume, inode, attribute, *stat);</a>
<a name="ln2181">	return B_OK;</a>
<a name="ln2182">}</a>
<a name="ln2183"> </a>
<a name="ln2184"> </a>
<a name="ln2185">static status_t</a>
<a name="ln2186">cdda_write_attr_stat(fs_volume* _volume, fs_vnode* _node, void* cookie,</a>
<a name="ln2187">	const struct stat* stat, int statMask)</a>
<a name="ln2188">{</a>
<a name="ln2189">	return EOPNOTSUPP;</a>
<a name="ln2190">}</a>
<a name="ln2191"> </a>
<a name="ln2192"> </a>
<a name="ln2193">static status_t</a>
<a name="ln2194">cdda_remove_attr(fs_volume* _volume, fs_vnode* _node, const char* name)</a>
<a name="ln2195">{</a>
<a name="ln2196">	if (name == NULL)</a>
<a name="ln2197">		return B_BAD_VALUE;</a>
<a name="ln2198"> </a>
<a name="ln2199">	Volume* volume = (Volume*)_volume-&gt;private_volume;</a>
<a name="ln2200">	Inode* inode = (Inode*)_node-&gt;private_node;</a>
<a name="ln2201"> </a>
<a name="ln2202">	Locker _(volume-&gt;Lock());</a>
<a name="ln2203"> </a>
<a name="ln2204">	status_t status = inode-&gt;RemoveAttribute(name, true);</a>
<a name="ln2205">	if (status == B_OK) {</a>
<a name="ln2206">		notify_attribute_changed(volume-&gt;ID(), -1, inode-&gt;ID(), name,</a>
<a name="ln2207">			B_ATTR_REMOVED);</a>
<a name="ln2208">	}</a>
<a name="ln2209"> </a>
<a name="ln2210">	return status;</a>
<a name="ln2211">}</a>
<a name="ln2212"> </a>
<a name="ln2213"> </a>
<a name="ln2214">fs_volume_ops gCDDAVolumeOps = {</a>
<a name="ln2215">	cdda_unmount,</a>
<a name="ln2216">	cdda_read_fs_stat,</a>
<a name="ln2217">	cdda_write_fs_stat,</a>
<a name="ln2218">	cdda_sync,</a>
<a name="ln2219">	cdda_get_vnode,</a>
<a name="ln2220"> </a>
<a name="ln2221">	// the other operations are not yet supported (indices, queries)</a>
<a name="ln2222">	NULL,</a>
<a name="ln2223">};</a>
<a name="ln2224"> </a>
<a name="ln2225">fs_vnode_ops gCDDAVnodeOps = {</a>
<a name="ln2226">	cdda_lookup,</a>
<a name="ln2227">	cdda_get_vnode_name,</a>
<a name="ln2228">	cdda_put_vnode,</a>
<a name="ln2229">	NULL,	// fs_remove_vnode()</a>
<a name="ln2230"> </a>
<a name="ln2231">	cdda_can_page,</a>
<a name="ln2232">	cdda_read_pages,</a>
<a name="ln2233">	cdda_write_pages,</a>
<a name="ln2234"> </a>
<a name="ln2235">	NULL,	// io()</a>
<a name="ln2236">	NULL,	// cancel_io()</a>
<a name="ln2237"> </a>
<a name="ln2238">	NULL,	// get_file_map()</a>
<a name="ln2239"> </a>
<a name="ln2240">	// common</a>
<a name="ln2241">	NULL,	// fs_ioctl()</a>
<a name="ln2242">	NULL,	// fs_set_flags()</a>
<a name="ln2243">	NULL,	// fs_select()</a>
<a name="ln2244">	NULL,	// fs_deselect()</a>
<a name="ln2245">	cdda_fsync,</a>
<a name="ln2246"> </a>
<a name="ln2247">	NULL,	// fs_read_link()</a>
<a name="ln2248">	NULL,	// fs_symlink()</a>
<a name="ln2249">	NULL,	// fs_link()</a>
<a name="ln2250">	NULL,	// fs_unlink()</a>
<a name="ln2251">	cdda_rename,</a>
<a name="ln2252"> </a>
<a name="ln2253">	NULL,	// fs_access()</a>
<a name="ln2254">	cdda_read_stat,</a>
<a name="ln2255">	NULL,	// fs_write_stat()</a>
<a name="ln2256">	NULL,	// fs_preallocate()</a>
<a name="ln2257"> </a>
<a name="ln2258">	// file</a>
<a name="ln2259">	NULL,	// fs_create()</a>
<a name="ln2260">	cdda_open,</a>
<a name="ln2261">	cdda_close,</a>
<a name="ln2262">	cdda_free_cookie,</a>
<a name="ln2263">	cdda_read,</a>
<a name="ln2264">	NULL,	// fs_write()</a>
<a name="ln2265"> </a>
<a name="ln2266">	// directory</a>
<a name="ln2267">	NULL,	// fs_create_dir()</a>
<a name="ln2268">	NULL,	// fs_remove_dir()</a>
<a name="ln2269">	cdda_open_dir,</a>
<a name="ln2270">	cdda_close_dir,</a>
<a name="ln2271">	cdda_free_dir_cookie,</a>
<a name="ln2272">	cdda_read_dir,</a>
<a name="ln2273">	cdda_rewind_dir,</a>
<a name="ln2274"> </a>
<a name="ln2275">	// attribute directory operations</a>
<a name="ln2276">	cdda_open_attr_dir,</a>
<a name="ln2277">	cdda_close_attr_dir,</a>
<a name="ln2278">	cdda_free_attr_dir_cookie,</a>
<a name="ln2279">	cdda_read_attr_dir,</a>
<a name="ln2280">	cdda_rewind_attr_dir,</a>
<a name="ln2281"> </a>
<a name="ln2282">	// attribute operations</a>
<a name="ln2283">	cdda_create_attr,</a>
<a name="ln2284">	cdda_open_attr,</a>
<a name="ln2285">	cdda_close_attr,</a>
<a name="ln2286">	cdda_free_attr_cookie,</a>
<a name="ln2287">	cdda_read_attr,</a>
<a name="ln2288">	cdda_write_attr,</a>
<a name="ln2289"> </a>
<a name="ln2290">	cdda_read_attr_stat,</a>
<a name="ln2291">	cdda_write_attr_stat,</a>
<a name="ln2292">	NULL,	// fs_rename_attr()</a>
<a name="ln2293">	cdda_remove_attr,</a>
<a name="ln2294"> </a>
<a name="ln2295">	NULL,	// fs_create_special_node()</a>
<a name="ln2296">};</a>
<a name="ln2297"> </a>
<a name="ln2298">static file_system_module_info sCDDAFileSystem = {</a>
<a name="ln2299">	{</a>
<a name="ln2300">		&quot;file_systems/cdda&quot; B_CURRENT_FS_API_VERSION,</a>
<a name="ln2301">		0,</a>
<a name="ln2302">		NULL,</a>
<a name="ln2303">	},</a>
<a name="ln2304"> </a>
<a name="ln2305">	&quot;cdda&quot;,					// short_name</a>
<a name="ln2306">	&quot;CDDA File System&quot;,		// pretty_name</a>
<a name="ln2307">	0,	// DDM flags</a>
<a name="ln2308"> </a>
<a name="ln2309">	cdda_identify_partition,</a>
<a name="ln2310">	cdda_scan_partition,</a>
<a name="ln2311">	cdda_free_identify_partition_cookie,</a>
<a name="ln2312">	NULL,	// free_partition_content_cookie()</a>
<a name="ln2313"> </a>
<a name="ln2314">	cdda_mount,</a>
<a name="ln2315"> </a>
<a name="ln2316">	// all other functions are not supported</a>
<a name="ln2317">	NULL,</a>
<a name="ln2318">};</a>
<a name="ln2319"> </a>
<a name="ln2320">module_info* modules[] = {</a>
<a name="ln2321">	(module_info*)&amp;sCDDAFileSystem,</a>
<a name="ln2322">	NULL,</a>
<a name="ln2323">};</a>

</code></pre>
<div class="balloon" rel="1457"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands, not the result.</p></div>
<div class="balloon" rel="1394"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v641/" target="_blank">V641</a> The size of the allocated memory buffer is not a multiple of the element size.</p></div>
<div class="balloon" rel="625"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v641/" target="_blank">V641</a> The size of the allocated memory buffer is not a multiple of the element size.</p></div>
<div class="balloon" rel="565"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fDiscID.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
