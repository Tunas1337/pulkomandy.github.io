
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ftp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: ftp.c,v 1.132 2005/05/14 15:26:43 lukem Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*-</a>
<a name="ln4"> * Copyright (c) 1996-2005 The NetBSD Foundation, Inc.</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This code is derived from software contributed to The NetBSD Foundation</a>
<a name="ln8"> * by Luke Mewburn.</a>
<a name="ln9"> *</a>
<a name="ln10"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln11"> * modification, are permitted provided that the following conditions</a>
<a name="ln12"> * are met:</a>
<a name="ln13"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln15"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln16"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln17"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln18"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln19"> *    must display the following acknowledgement:</a>
<a name="ln20"> *	This product includes software developed by the NetBSD</a>
<a name="ln21"> *	Foundation, Inc. and its contributors.</a>
<a name="ln22"> * 4. Neither the name of The NetBSD Foundation nor the names of its</a>
<a name="ln23"> *    contributors may be used to endorse or promote products derived</a>
<a name="ln24"> *    from this software without specific prior written permission.</a>
<a name="ln25"> *</a>
<a name="ln26"> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</a>
<a name="ln27"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</a>
<a name="ln28"> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln29"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</a>
<a name="ln30"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln31"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln32"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln33"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln34"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln35"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln36"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39">/*</a>
<a name="ln40"> * Copyright (c) 1985, 1989, 1993, 1994</a>
<a name="ln41"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln42"> *</a>
<a name="ln43"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln44"> * modification, are permitted provided that the following conditions</a>
<a name="ln45"> * are met:</a>
<a name="ln46"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln47"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln48"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln49"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln50"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln51"> * 3. Neither the name of the University nor the names of its contributors</a>
<a name="ln52"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln53"> *    without specific prior written permission.</a>
<a name="ln54"> *</a>
<a name="ln55"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln56"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln57"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln58"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln59"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln60"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln61"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln62"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln63"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln64"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln65"> * SUCH DAMAGE.</a>
<a name="ln66"> */</a>
<a name="ln67"> </a>
<a name="ln68">/*</a>
<a name="ln69"> * Copyright (C) 1997 and 1998 WIDE Project.</a>
<a name="ln70"> * All rights reserved.</a>
<a name="ln71"> *</a>
<a name="ln72"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln73"> * modification, are permitted provided that the following conditions</a>
<a name="ln74"> * are met:</a>
<a name="ln75"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln76"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln77"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln78"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln79"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln80"> * 3. Neither the name of the project nor the names of its contributors</a>
<a name="ln81"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln82"> *    without specific prior written permission.</a>
<a name="ln83"> *</a>
<a name="ln84"> * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln85"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln86"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln87"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE</a>
<a name="ln88"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln89"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln90"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln91"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln92"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln93"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln94"> * SUCH DAMAGE.</a>
<a name="ln95"> */</a>
<a name="ln96"> </a>
<a name="ln97">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln98"> </a>
<a name="ln99">#include &lt;sys/types.h&gt;</a>
<a name="ln100">#include &lt;sys/stat.h&gt;</a>
<a name="ln101">#include &lt;sys/socket.h&gt;</a>
<a name="ln102">#include &lt;sys/time.h&gt;</a>
<a name="ln103"> </a>
<a name="ln104">#include &lt;netinet/in.h&gt;</a>
<a name="ln105">#include &lt;netinet/ip.h&gt;</a>
<a name="ln106">#include &lt;arpa/inet.h&gt;</a>
<a name="ln107">#include &lt;arpa/ftp.h&gt;</a>
<a name="ln108">#include &lt;arpa/telnet.h&gt;</a>
<a name="ln109"> </a>
<a name="ln110">#include &lt;ctype.h&gt;</a>
<a name="ln111">#include &lt;err.h&gt;</a>
<a name="ln112">#include &lt;errno.h&gt;</a>
<a name="ln113">#include &lt;fcntl.h&gt;</a>
<a name="ln114">#include &lt;netdb.h&gt;</a>
<a name="ln115">#include &lt;stdio.h&gt;</a>
<a name="ln116">#include &lt;stdlib.h&gt;</a>
<a name="ln117">#include &lt;string.h&gt;</a>
<a name="ln118">#include &lt;time.h&gt;</a>
<a name="ln119">#include &lt;unistd.h&gt;</a>
<a name="ln120">#include &lt;stdarg.h&gt;</a>
<a name="ln121"> </a>
<a name="ln122">#include &quot;ftp_var.h&quot;</a>
<a name="ln123"> </a>
<a name="ln124">volatile sig_atomic_t	abrtflag;</a>
<a name="ln125">volatile sig_atomic_t	timeoutflag;</a>
<a name="ln126"> </a>
<a name="ln127">sigjmp_buf	ptabort;</a>
<a name="ln128">int	ptabflg;</a>
<a name="ln129">int	ptflag = 0;</a>
<a name="ln130">char	pasv[BUFSIZ];	/* passive port for proxy data connection */</a>
<a name="ln131"> </a>
<a name="ln132">static int empty(FILE *, FILE *, int);</a>
<a name="ln133"> </a>
<a name="ln134">struct sockinet {</a>
<a name="ln135">	union sockunion {</a>
<a name="ln136">		struct sockaddr_in  su_sin;</a>
<a name="ln137">#ifdef INET6</a>
<a name="ln138">		struct sockaddr_in6 su_sin6;</a>
<a name="ln139">#endif</a>
<a name="ln140">	} si_su;</a>
<a name="ln141">#if !HAVE_SOCKADDR_SA_LEN</a>
<a name="ln142">	int	si_len;</a>
<a name="ln143">#endif</a>
<a name="ln144">};</a>
<a name="ln145"> </a>
<a name="ln146">#if !HAVE_SOCKADDR_SA_LEN</a>
<a name="ln147"># define su_len		si_len</a>
<a name="ln148">#else</a>
<a name="ln149"># define su_len		si_su.su_sin.sin_len</a>
<a name="ln150">#endif</a>
<a name="ln151">#define su_family	si_su.su_sin.sin_family</a>
<a name="ln152">#define su_port		si_su.su_sin.sin_port</a>
<a name="ln153"> </a>
<a name="ln154">struct sockinet myctladdr, hisctladdr, data_addr;</a>
<a name="ln155"> </a>
<a name="ln156">char *</a>
<a name="ln157">hookup(char *host, char *port)</a>
<a name="ln158">{</a>
<a name="ln159">	int s = -1, error, portnum;</a>
<a name="ln160">	struct addrinfo hints, *res, *res0;</a>
<a name="ln161">	char hbuf[MAXHOSTNAMELEN];</a>
<a name="ln162">	static char hostnamebuf[MAXHOSTNAMELEN];</a>
<a name="ln163">	char *cause = &quot;unknown&quot;;</a>
<a name="ln164">	socklen_t len;</a>
<a name="ln165">	int on = 1;</a>
<a name="ln166"> </a>
<a name="ln167">	memset((char *)&amp;hisctladdr, 0, sizeof (hisctladdr));</a>
<a name="ln168">	memset((char *)&amp;myctladdr, 0, sizeof (myctladdr));</a>
<a name="ln169">	memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln170">	portnum = parseport(port, FTP_PORT);</a>
<a name="ln171">	hints.ai_flags = AI_CANONNAME;</a>
<a name="ln172">	hints.ai_family = family;</a>
<a name="ln173">	hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln174">	hints.ai_protocol = 0;</a>
<a name="ln175">	error = getaddrinfo(host, NULL, &amp;hints, &amp;res0);</a>
<a name="ln176">	if (error) {</a>
<a name="ln177">		warnx(&quot;%s&quot;, gai_strerror(error));</a>
<a name="ln178">		code = -1;</a>
<a name="ln179">		return (0);</a>
<a name="ln180">	}</a>
<a name="ln181"> </a>
<a name="ln182">	if (res0-&gt;ai_canonname)</a>
<a name="ln183">		(void)strlcpy(hostnamebuf, res0-&gt;ai_canonname,</a>
<a name="ln184">		    sizeof(hostnamebuf));</a>
<a name="ln185">	else</a>
<a name="ln186">		(void)strlcpy(hostnamebuf, host, sizeof(hostnamebuf));</a>
<a name="ln187">	hostname = hostnamebuf;</a>
<a name="ln188"> </a>
<a name="ln189">	for (res = res0; res; res = res-&gt;ai_next) {</a>
<a name="ln190">		/*</a>
<a name="ln191">		 * make sure that ai_addr is NOT an IPv4 mapped address.</a>
<a name="ln192">		 * IPv4 mapped address complicates too many things in FTP</a>
<a name="ln193">		 * protocol handling, as FTP protocol is defined differently</a>
<a name="ln194">		 * between IPv4 and IPv6.</a>
<a name="ln195">		 *</a>
<a name="ln196">		 * This may not be the best way to handle this situation,</a>
<a name="ln197">		 * since the semantics of IPv4 mapped address is defined in</a>
<a name="ln198">		 * the kernel.  There are configurations where we should use</a>
<a name="ln199">		 * IPv4 mapped address as native IPv6 address, not as</a>
<a name="ln200">		 * &quot;an IPv6 address that embeds IPv4 address&quot; (namely, SIIT).</a>
<a name="ln201">		 *</a>
<a name="ln202">		 * More complete solution would be to have an additional</a>
<a name="ln203">		 * getsockopt to grab &quot;real&quot; peername/sockname.  &quot;real&quot;</a>
<a name="ln204">		 * peername/sockname will be AF_INET if IPv4 mapped address</a>
<a name="ln205">		 * is used to embed IPv4 address, and will be AF_INET6 if</a>
<a name="ln206">		 * we use it as native.  What a mess!</a>
<a name="ln207">		 */</a>
<a name="ln208">		ai_unmapped(res);</a>
<a name="ln209">#if 0	/*old behavior*/</a>
<a name="ln210">		if (res != res0)	/* not on the first address */</a>
<a name="ln211">#else</a>
<a name="ln212">		if (res0-&gt;ai_next)	/* if we have multiple possibilities */</a>
<a name="ln213">#endif</a>
<a name="ln214">		{</a>
<a name="ln215">			if (getnameinfo(res-&gt;ai_addr, res-&gt;ai_addrlen,</a>
<a name="ln216">			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST))</a>
<a name="ln217">				strlcpy(hbuf, &quot;?&quot;, sizeof(hbuf));</a>
<a name="ln218">			fprintf(ttyout, &quot;Trying %s...\n&quot;, hbuf);</a>
<a name="ln219">		}</a>
<a name="ln220">		((struct sockaddr_in *)res-&gt;ai_addr)-&gt;sin_port = htons(portnum);</a>
<a name="ln221">		s = socket(res-&gt;ai_family, SOCK_STREAM, res-&gt;ai_protocol);</a>
<a name="ln222">		if (s &lt; 0) {</a>
<a name="ln223">			cause = &quot;socket&quot;;</a>
<a name="ln224">			continue;</a>
<a name="ln225">		}</a>
<a name="ln226">		error = xconnect(s, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a name="ln227">		if (error) {</a>
<a name="ln228">			/* this &quot;if&quot; clause is to prevent print warning twice */</a>
<a name="ln229">			if (res-&gt;ai_next) {</a>
<a name="ln230">				if (getnameinfo(res-&gt;ai_addr, res-&gt;ai_addrlen,</a>
<a name="ln231">				    hbuf, sizeof(hbuf), NULL, 0,</a>
<a name="ln232">				    NI_NUMERICHOST))</a>
<a name="ln233">					strlcpy(hbuf, &quot;?&quot;, sizeof(hbuf));</a>
<a name="ln234">				warn(&quot;connect to address %s&quot;, hbuf);</a>
<a name="ln235">			}</a>
<a name="ln236">			cause = &quot;connect&quot;;</a>
<a name="ln237">			close(s);</a>
<a name="ln238">			s = -1;</a>
<a name="ln239">			continue;</a>
<a name="ln240">		}</a>
<a name="ln241"> </a>
<a name="ln242">		/* finally we got one */</a>
<a name="ln243">		break;</a>
<a name="ln244">	}</a>
<a name="ln245">	if (s &lt; 0) {</a>
<a name="ln246">		warn(&quot;%s&quot;, cause);</a>
<a name="ln247">		code = -1;</a>
<a name="ln248">		freeaddrinfo(res0);</a>
<a name="ln249">		return 0;</a>
<a name="ln250">	}</a>
<a name="ln251">	memcpy(&amp;hisctladdr.si_su, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a name="ln252">	hisctladdr.su_len = res-&gt;ai_addrlen;</a>
<a name="ln253">	freeaddrinfo(res0);</a>
<a name="ln254">	res0 = res = NULL;</a>
<a name="ln255"> </a>
<a name="ln256">	len = hisctladdr.su_len;</a>
<a name="ln257">	if (getsockname(s, (struct sockaddr *)&amp;myctladdr.si_su, &amp;len) == -1) {</a>
<a name="ln258">		warn(&quot;getsockname&quot;);</a>
<a name="ln259">		code = -1;</a>
<a name="ln260">		goto bad;</a>
<a name="ln261">	}</a>
<a name="ln262">	myctladdr.su_len = len;</a>
<a name="ln263"> </a>
<a name="ln264">#ifdef IPTOS_LOWDELAY</a>
<a name="ln265">	if (hisctladdr.su_family == AF_INET) {</a>
<a name="ln266">		int tos = IPTOS_LOWDELAY;</a>
<a name="ln267">		if (setsockopt(s, IPPROTO_IP, IP_TOS,</a>
<a name="ln268">				(void *)&amp;tos, sizeof(tos)) == -1) {</a>
<a name="ln269">			if (debug)</a>
<a name="ln270">				warn(&quot;setsockopt %s (ignored)&quot;,</a>
<a name="ln271">				    &quot;IPTOS_LOWDELAY&quot;);</a>
<a name="ln272">		}</a>
<a name="ln273">	}</a>
<a name="ln274">#endif</a>
<a name="ln275">	cin = fdopen(s, &quot;r&quot;);</a>
<a name="ln276">	cout = fdopen(s, &quot;w&quot;);</a>
<a name="ln277">	if (cin == NULL || cout == NULL) {</a>
<a name="ln278">		warnx(&quot;fdopen failed.&quot;);</a>
<a name="ln279">		if (cin)</a>
<a name="ln280">			(void)fclose(cin);</a>
<a name="ln281">		if (cout)</a>
<a name="ln282">			(void)fclose(cout);</a>
<a name="ln283">		code = -1;</a>
<a name="ln284">		goto bad;</a>
<a name="ln285">	}</a>
<a name="ln286">	if (verbose)</a>
<a name="ln287">		fprintf(ttyout, &quot;Connected to %s.\n&quot;, hostname);</a>
<a name="ln288">	if (getreply(0) &gt; 2) {	/* read startup message from server */</a>
<a name="ln289">		if (cin)</a>
<a name="ln290">			(void)fclose(cin);</a>
<a name="ln291">		if (cout)</a>
<a name="ln292">			(void)fclose(cout);</a>
<a name="ln293">		code = -1;</a>
<a name="ln294">		goto bad;</a>
<a name="ln295">	}</a>
<a name="ln296"> </a>
<a name="ln297">	if (setsockopt(s, SOL_SOCKET, SO_OOBINLINE,</a>
<a name="ln298">			(void *)&amp;on, sizeof(on)) == -1) {</a>
<a name="ln299">		if (debug)</a>
<a name="ln300">			warn(&quot;setsockopt %s (ignored)&quot;, &quot;SO_OOBINLINE&quot;);</a>
<a name="ln301">	}</a>
<a name="ln302"> </a>
<a name="ln303">	return (hostname);</a>
<a name="ln304"> bad:</a>
<a name="ln305">	(void)close(s);</a>
<a name="ln306">	return (NULL);</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">void</a>
<a name="ln310">cmdabort(int notused)</a>
<a name="ln311">{</a>
<a name="ln312">	int oerrno = errno;</a>
<a name="ln313"> </a>
<a name="ln314">	sigint_raised = 1;</a>
<a name="ln315">	alarmtimer(0);</a>
<a name="ln316">	if (fromatty)</a>
<a name="ln317">		write(fileno(ttyout), &quot;\n&quot;, 1);</a>
<a name="ln318">	abrtflag++;</a>
<a name="ln319">	if (ptflag)</a>
<a name="ln320">		siglongjmp(ptabort, 1);</a>
<a name="ln321">	errno = oerrno;</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">void</a>
<a name="ln325">cmdtimeout(int notused)</a>
<a name="ln326">{</a>
<a name="ln327">	int oerrno = errno;</a>
<a name="ln328"> </a>
<a name="ln329">	alarmtimer(0);</a>
<a name="ln330">	if (fromatty)</a>
<a name="ln331">		write(fileno(ttyout), &quot;\n&quot;, 1);</a>
<a name="ln332">	timeoutflag++;</a>
<a name="ln333">	if (ptflag)</a>
<a name="ln334">		siglongjmp(ptabort, 1);</a>
<a name="ln335">	errno = oerrno;</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">/*VARARGS*/</a>
<a name="ln339">int</a>
<a name="ln340">command(const char *fmt, ...)</a>
<a name="ln341">{</a>
<a name="ln342">	va_list ap;</a>
<a name="ln343">	int r;</a>
<a name="ln344">	sigfunc oldsigint;</a>
<a name="ln345"> </a>
<a name="ln346">	if (debug) {</a>
<a name="ln347">		fputs(&quot;---&gt; &quot;, ttyout);</a>
<a name="ln348">		va_start(ap, fmt);</a>
<a name="ln349">		if (strncmp(&quot;PASS &quot;, fmt, 5) == 0)</a>
<a name="ln350">			fputs(&quot;PASS XXXX&quot;, ttyout);</a>
<a name="ln351">		else if (strncmp(&quot;ACCT &quot;, fmt, 5) == 0)</a>
<a name="ln352">			fputs(&quot;ACCT XXXX&quot;, ttyout);</a>
<a name="ln353">		else</a>
<a name="ln354">			vfprintf(ttyout, fmt, ap);</a>
<a name="ln355">		va_end(ap);</a>
<a name="ln356">		putc('\n', ttyout);</a>
<a name="ln357">	}</a>
<a name="ln358">	if (cout == NULL) {</a>
<a name="ln359">		warnx(&quot;No control connection for command.&quot;);</a>
<a name="ln360">		code = -1;</a>
<a name="ln361">		return (0);</a>
<a name="ln362">	}</a>
<a name="ln363"> </a>
<a name="ln364">	abrtflag = 0;</a>
<a name="ln365"> </a>
<a name="ln366">	oldsigint = xsignal(SIGINT, cmdabort);</a>
<a name="ln367"> </a>
<a name="ln368">	va_start(ap, fmt);</a>
<a name="ln369">	vfprintf(cout, fmt, ap);</a>
<a name="ln370">	va_end(ap);</a>
<a name="ln371">	fputs(&quot;\r\n&quot;, cout);</a>
<a name="ln372">	(void)fflush(cout);</a>
<a name="ln373">	cpend = 1;</a>
<a name="ln374">	r = getreply(!strcmp(fmt, &quot;QUIT&quot;));</a>
<a name="ln375">	if (abrtflag &amp;&amp; oldsigint != SIG_IGN)</a>
<a name="ln376">		(*oldsigint)(SIGINT);</a>
<a name="ln377">	(void)xsignal(SIGINT, oldsigint);</a>
<a name="ln378">	return (r);</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">int</a>
<a name="ln382">getreply(int expecteof)</a>
<a name="ln383">{</a>
<a name="ln384">	char current_line[BUFSIZ];	/* last line of previous reply */</a>
<a name="ln385">	int c, n, line;</a>
<a name="ln386">	int dig;</a>
<a name="ln387">	int originalcode = 0, continuation = 0;</a>
<a name="ln388">	sigfunc oldsigint, oldsigalrm;</a>
<a name="ln389">	int pflag = 0;</a>
<a name="ln390">	char *cp, *pt = pasv;</a>
<a name="ln391"> </a>
<a name="ln392">	abrtflag = 0;</a>
<a name="ln393">	timeoutflag = 0;</a>
<a name="ln394"> </a>
<a name="ln395">	oldsigint = xsignal(SIGINT, cmdabort);</a>
<a name="ln396">	oldsigalrm = xsignal(SIGALRM, cmdtimeout);</a>
<a name="ln397"> </a>
<a name="ln398">	for (line = 0 ;; line++) {</a>
<a name="ln399">		dig = n = code = 0;</a>
<a name="ln400">		cp = current_line;</a>
<a name="ln401">		while (alarmtimer(60),((c = getc(cin)) != '\n')) {</a>
<a name="ln402">			if (c == IAC) {     /* handle telnet commands */</a>
<a name="ln403">				switch (c = getc(cin)) {</a>
<a name="ln404">				case WILL:</a>
<a name="ln405">				case WONT:</a>
<a name="ln406">					c = getc(cin);</a>
<a name="ln407">					fprintf(cout, &quot;%c%c%c&quot;, IAC, DONT, c);</a>
<a name="ln408">					(void)fflush(cout);</a>
<a name="ln409">					break;</a>
<a name="ln410">				case DO:</a>
<a name="ln411">				case DONT:</a>
<a name="ln412">					c = getc(cin);</a>
<a name="ln413">					fprintf(cout, &quot;%c%c%c&quot;, IAC, WONT, c);</a>
<a name="ln414">					(void)fflush(cout);</a>
<a name="ln415">					break;</a>
<a name="ln416">				default:</a>
<a name="ln417">					break;</a>
<a name="ln418">				}</a>
<a name="ln419">				continue;</a>
<a name="ln420">			}</a>
<a name="ln421">			dig++;</a>
<a name="ln422">			if (c == EOF) {</a>
<a name="ln423">				/*</a>
<a name="ln424">				 * these will get trashed by pswitch()</a>
<a name="ln425">				 * in lostpeer()</a>
<a name="ln426">				 */</a>
<a name="ln427">				int reply_timeoutflag = timeoutflag;</a>
<a name="ln428">				int reply_abrtflag = abrtflag;</a>
<a name="ln429"> </a>
<a name="ln430">				alarmtimer(0);</a>
<a name="ln431">				if (expecteof &amp;&amp; feof(cin)) {</a>
<a name="ln432">					(void)xsignal(SIGINT, oldsigint);</a>
<a name="ln433">					(void)xsignal(SIGALRM, oldsigalrm);</a>
<a name="ln434">					code = 221;</a>
<a name="ln435">					return (0);</a>
<a name="ln436">				}</a>
<a name="ln437">				cpend = 0;</a>
<a name="ln438">				lostpeer(0);</a>
<a name="ln439">				if (verbose) {</a>
<a name="ln440">					if (reply_timeoutflag)</a>
<a name="ln441">						fputs(</a>
<a name="ln442">    &quot;421 Service not available, remote server timed out. Connection closed\n&quot;,</a>
<a name="ln443">						    ttyout);</a>
<a name="ln444">					else if (reply_abrtflag)</a>
<a name="ln445">						fputs(</a>
<a name="ln446">    &quot;421 Service not available, user interrupt. Connection closed.\n&quot;,</a>
<a name="ln447">						    ttyout);</a>
<a name="ln448">					else</a>
<a name="ln449">						fputs(</a>
<a name="ln450">    &quot;421 Service not available, remote server has closed connection.\n&quot;,</a>
<a name="ln451">						    ttyout);</a>
<a name="ln452">					(void)fflush(ttyout);</a>
<a name="ln453">				}</a>
<a name="ln454">				code = 421;</a>
<a name="ln455">				(void)xsignal(SIGINT, oldsigint);</a>
<a name="ln456">				(void)xsignal(SIGALRM, oldsigalrm);</a>
<a name="ln457">				return (4);</a>
<a name="ln458">			}</a>
<a name="ln459">			if (c != '\r' &amp;&amp; (verbose &gt; 0 ||</a>
<a name="ln460">			    ((verbose &gt; -1 &amp;&amp; n == '5' &amp;&amp; dig &gt; 4) &amp;&amp;</a>
<a name="ln461">			    (((!n &amp;&amp; c &lt; '5') || (n &amp;&amp; n &lt; '5'))</a>
<a name="ln462">			     || !retry_connect)))) {</a>
<a name="ln463">				if (proxflag &amp;&amp;</a>
<a name="ln464">				   (dig == 1 || (dig == 5 &amp;&amp; verbose == 0)))</a>
<a name="ln465">					fprintf(ttyout, &quot;%s:&quot;, hostname);</a>
<a name="ln466">				(void)putc(c, ttyout);</a>
<a name="ln467">			}</a>
<a name="ln468">			if (dig &lt; 4 &amp;&amp; isdigit(c))</a>
<a name="ln469">				code = code * 10 + (c - '0');</a>
<a name="ln470">			if (!pflag &amp;&amp; (code == 227 || code == 228))</a>
<a name="ln471">				pflag = 1;</a>
<a name="ln472">			else if (!pflag &amp;&amp; code == 229)</a>
<a name="ln473">				pflag = 100;</a>
<a name="ln474">			if (dig &gt; 4 &amp;&amp; pflag == 1 &amp;&amp; isdigit(c))</a>
<a name="ln475">				pflag = 2;</a>
<a name="ln476">			if (pflag == 2) {</a>
<a name="ln477">				if (c != '\r' &amp;&amp; c != ')') {</a>
<a name="ln478">					if (pt &lt; &amp;pasv[sizeof(pasv) - 1])</a>
<a name="ln479">						*pt++ = c;</a>
<a name="ln480">				} else {</a>
<a name="ln481">					*pt = '\0';</a>
<a name="ln482">					pflag = 3;</a>
<a name="ln483">				}</a>
<a name="ln484">			}</a>
<a name="ln485">			if (pflag == 100 &amp;&amp; c == '(')</a>
<a name="ln486">				pflag = 2;</a>
<a name="ln487">			if (dig == 4 &amp;&amp; c == '-') {</a>
<a name="ln488">				if (continuation)</a>
<a name="ln489">					code = 0;</a>
<a name="ln490">				continuation++;</a>
<a name="ln491">			}</a>
<a name="ln492">			if (n == 0)</a>
<a name="ln493">				n = c;</a>
<a name="ln494">			if (cp &lt; &amp;current_line[sizeof(current_line) - 1])</a>
<a name="ln495">				*cp++ = c;</a>
<a name="ln496">		}</a>
<a name="ln497">		if (verbose &gt; 0 || ((verbose &gt; -1 &amp;&amp; n == '5') &amp;&amp;</a>
<a name="ln498">		    (n &lt; '5' || !retry_connect))) {</a>
<a name="ln499">			(void)putc(c, ttyout);</a>
<a name="ln500">			(void)fflush (ttyout);</a>
<a name="ln501">		}</a>
<a name="ln502">		if (cp[-1] == '\r')</a>
<a name="ln503">			cp[-1] = '\0';</a>
<a name="ln504">		*cp = '\0';</a>
<a name="ln505">		if (line == 0)</a>
<a name="ln506">			(void)strlcpy(reply_string, current_line,</a>
<a name="ln507">			    sizeof(reply_string));</a>
<a name="ln508">		if (line &gt; 0 &amp;&amp; code == 0 &amp;&amp; reply_callback != NULL)</a>
<a name="ln509">			(*reply_callback)(current_line);</a>
<a name="ln510">		if (continuation &amp;&amp; code != originalcode) {</a>
<a name="ln511">			if (originalcode == 0)</a>
<a name="ln512">				originalcode = code;</a>
<a name="ln513">			continue;</a>
<a name="ln514">		}</a>
<a name="ln515">		if (n != '1')</a>
<a name="ln516">			cpend = 0;</a>
<a name="ln517">		alarmtimer(0);</a>
<a name="ln518">		(void)xsignal(SIGINT, oldsigint);</a>
<a name="ln519">		(void)xsignal(SIGALRM, oldsigalrm);</a>
<a name="ln520">		if (code == 421 || originalcode == 421)</a>
<a name="ln521">			lostpeer(0);</a>
<a name="ln522">		if (abrtflag &amp;&amp; oldsigint != cmdabort &amp;&amp; oldsigint != SIG_IGN)</a>
<a name="ln523">			(*oldsigint)(SIGINT);</a>
<a name="ln524">		if (timeoutflag &amp;&amp; oldsigalrm != cmdtimeout &amp;&amp;</a>
<a name="ln525">		    oldsigalrm != SIG_IGN)</a>
<a name="ln526">			(*oldsigalrm)(SIGINT);</a>
<a name="ln527">		return (n - '0');</a>
<a name="ln528">	}</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">static int</a>
<a name="ln532">empty(FILE *cin, FILE *din, int sec)</a>
<a name="ln533">{</a>
<a name="ln534">	int		nr, nfd;</a>
<a name="ln535">	struct pollfd	pfd[2];</a>
<a name="ln536"> </a>
<a name="ln537">	nfd = 0;</a>
<a name="ln538">	if (cin) {</a>
<a name="ln539">		pfd[nfd].fd = fileno(cin);</a>
<a name="ln540">		pfd[nfd++].events = POLLIN;</a>
<a name="ln541">	}</a>
<a name="ln542"> </a>
<a name="ln543">	if (din) {</a>
<a name="ln544">		pfd[nfd].fd = fileno(din);</a>
<a name="ln545">		pfd[nfd++].events = POLLIN;</a>
<a name="ln546">	}</a>
<a name="ln547"> </a>
<a name="ln548">	if ((nr = xpoll(pfd, nfd, sec * 1000)) &lt;= 0)</a>
<a name="ln549">		return nr;</a>
<a name="ln550"> </a>
<a name="ln551">	nr = 0;</a>
<a name="ln552">	nfd = 0;</a>
<a name="ln553">	if (cin)</a>
<a name="ln554">		nr |= (pfd[nfd++].revents &amp; POLLIN) ? 1 : 0;</a>
<a name="ln555">	if (din)</a>
<a name="ln556">		nr |= (pfd[nfd++].revents &amp; POLLIN) ? 2 : 0;</a>
<a name="ln557">	return nr;</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">sigjmp_buf	xferabort;</a>
<a name="ln561"> </a>
<a name="ln562">void</a>
<a name="ln563">abortxfer(int notused)</a>
<a name="ln564">{</a>
<a name="ln565">	char msgbuf[100];</a>
<a name="ln566">	size_t len;</a>
<a name="ln567"> </a>
<a name="ln568">	sigint_raised = 1;</a>
<a name="ln569">	alarmtimer(0);</a>
<a name="ln570">	mflag = 0;</a>
<a name="ln571">	abrtflag = 0;</a>
<a name="ln572">	switch (direction[0]) {</a>
<a name="ln573">	case 'r':</a>
<a name="ln574">		strlcpy(msgbuf, &quot;\nreceive&quot;, sizeof(msgbuf));</a>
<a name="ln575">		break;</a>
<a name="ln576">	case 's':</a>
<a name="ln577">		strlcpy(msgbuf, &quot;\nsend&quot;, sizeof(msgbuf));</a>
<a name="ln578">		break;</a>
<a name="ln579">	default:</a>
<a name="ln580">		errx(1, &quot;abortxfer called with unknown direction `%s'&quot;,</a>
<a name="ln581">		    direction);</a>
<a name="ln582">	}</a>
<a name="ln583">	len = strlcat(msgbuf, &quot; aborted. Waiting for remote to finish abort.\n&quot;,</a>
<a name="ln584">	    sizeof(msgbuf));</a>
<a name="ln585">	write(fileno(ttyout), msgbuf, len);</a>
<a name="ln586">	siglongjmp(xferabort, 1);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">void</a>
<a name="ln590">sendrequest(const char *cmd, const char *local, const char *remote,</a>
<a name="ln591">	    int printnames)</a>
<a name="ln592">{</a>
<a name="ln593">	struct stat st;</a>
<a name="ln594">	int c, d;</a>
<a name="ln595">	FILE *fin, *dout;</a>
<a name="ln596">	int (*closefunc)(FILE *);</a>
<a name="ln597">	sigfunc oldintr, oldintp;</a>
<a name="ln598">	volatile off_t hashbytes;</a>
<a name="ln599">	char *lmode, *bufp;</a>
<a name="ln600">	static size_t bufsize;</a>
<a name="ln601">	static char *buf;</a>
<a name="ln602">	int oprogress;</a>
<a name="ln603"> </a>
<a name="ln604">#ifdef __GNUC__			/* to shut up gcc warnings */</a>
<a name="ln605">	(void)&amp;fin;</a>
<a name="ln606">	(void)&amp;dout;</a>
<a name="ln607">	(void)&amp;closefunc;</a>
<a name="ln608">	(void)&amp;oldintr;</a>
<a name="ln609">	(void)&amp;oldintp;</a>
<a name="ln610">	(void)&amp;lmode;</a>
<a name="ln611">#endif</a>
<a name="ln612"> </a>
<a name="ln613">	hashbytes = mark;</a>
<a name="ln614">	direction = &quot;sent&quot;;</a>
<a name="ln615">	dout = NULL;</a>
<a name="ln616">	bytes = 0;</a>
<a name="ln617">	filesize = -1;</a>
<a name="ln618">	oprogress = progress;</a>
<a name="ln619">	if (verbose &amp;&amp; printnames) {</a>
<a name="ln620">		if (local &amp;&amp; *local != '-')</a>
<a name="ln621">			fprintf(ttyout, &quot;local: %s &quot;, local);</a>
<a name="ln622">		if (remote)</a>
<a name="ln623">			fprintf(ttyout, &quot;remote: %s\n&quot;, remote);</a>
<a name="ln624">	}</a>
<a name="ln625">	if (proxy) {</a>
<a name="ln626">		proxtrans(cmd, local, remote);</a>
<a name="ln627">		return;</a>
<a name="ln628">	}</a>
<a name="ln629">	if (curtype != type)</a>
<a name="ln630">		changetype(type, 0);</a>
<a name="ln631">	closefunc = NULL;</a>
<a name="ln632">	oldintr = NULL;</a>
<a name="ln633">	oldintp = NULL;</a>
<a name="ln634">	lmode = &quot;w&quot;;</a>
<a name="ln635">	if (sigsetjmp(xferabort, 1)) {</a>
<a name="ln636">		while (cpend)</a>
<a name="ln637">			(void)getreply(0);</a>
<a name="ln638">		code = -1;</a>
<a name="ln639">		goto cleanupsend;</a>
<a name="ln640">	}</a>
<a name="ln641">	(void)xsignal(SIGQUIT, psummary);</a>
<a name="ln642">	oldintr = xsignal(SIGINT, abortxfer);</a>
<a name="ln643">	if (strcmp(local, &quot;-&quot;) == 0) {</a>
<a name="ln644">		fin = stdin;</a>
<a name="ln645">		progress = 0;</a>
<a name="ln646">	} else if (*local == '|') {</a>
<a name="ln647">		oldintp = xsignal(SIGPIPE, SIG_IGN);</a>
<a name="ln648">		fin = popen(local + 1, &quot;r&quot;);</a>
<a name="ln649">		if (fin == NULL) {</a>
<a name="ln650">			warn(&quot;%s&quot;, local + 1);</a>
<a name="ln651">			code = -1;</a>
<a name="ln652">			goto cleanupsend;</a>
<a name="ln653">		}</a>
<a name="ln654">		progress = 0;</a>
<a name="ln655">		closefunc = pclose;</a>
<a name="ln656">	} else {</a>
<a name="ln657">		fin = fopen(local, &quot;r&quot;);</a>
<a name="ln658">		if (fin == NULL) {</a>
<a name="ln659">			warn(&quot;local: %s&quot;, local);</a>
<a name="ln660">			code = -1;</a>
<a name="ln661">			goto cleanupsend;</a>
<a name="ln662">		}</a>
<a name="ln663">		closefunc = fclose;</a>
<a name="ln664">		if (fstat(fileno(fin), &amp;st) &lt; 0 || !S_ISREG(st.st_mode)) {</a>
<a name="ln665">			fprintf(ttyout, &quot;%s: not a plain file.\n&quot;, local);</a>
<a name="ln666">			code = -1;</a>
<a name="ln667">			goto cleanupsend;</a>
<a name="ln668">		}</a>
<a name="ln669">		filesize = st.st_size;</a>
<a name="ln670">	}</a>
<a name="ln671">	if (initconn()) {</a>
<a name="ln672">		code = -1;</a>
<a name="ln673">		goto cleanupsend;</a>
<a name="ln674">	}</a>
<a name="ln675">	if (sigsetjmp(xferabort, 1))</a>
<a name="ln676">		goto abort;</a>
<a name="ln677"> </a>
<a name="ln678">	if (restart_point &amp;&amp;</a>
<a name="ln679">	    (strcmp(cmd, &quot;STOR&quot;) == 0 || strcmp(cmd, &quot;APPE&quot;) == 0)) {</a>
<a name="ln680">		int rc;</a>
<a name="ln681"> </a>
<a name="ln682">		rc = -1;</a>
<a name="ln683">		switch (curtype) {</a>
<a name="ln684">		case TYPE_A:</a>
<a name="ln685">			rc = fseeko(fin, restart_point, SEEK_SET);</a>
<a name="ln686">			break;</a>
<a name="ln687">		case TYPE_I:</a>
<a name="ln688">		case TYPE_L:</a>
<a name="ln689">			rc = lseek(fileno(fin), restart_point, SEEK_SET);</a>
<a name="ln690">			break;</a>
<a name="ln691">		}</a>
<a name="ln692">		if (rc &lt; 0) {</a>
<a name="ln693">			warn(&quot;local: %s&quot;, local);</a>
<a name="ln694">			goto cleanupsend;</a>
<a name="ln695">		}</a>
<a name="ln696">		if (command(&quot;REST &quot; LLF, (LLT)restart_point) != CONTINUE)</a>
<a name="ln697">			goto cleanupsend;</a>
<a name="ln698">		lmode = &quot;r+&quot;;</a>
<a name="ln699">	}</a>
<a name="ln700">	if (remote) {</a>
<a name="ln701">		if (command(&quot;%s %s&quot;, cmd, remote) != PRELIM)</a>
<a name="ln702">			goto cleanupsend;</a>
<a name="ln703">	} else {</a>
<a name="ln704">		if (command(&quot;%s&quot;, cmd) != PRELIM)</a>
<a name="ln705">			goto cleanupsend;</a>
<a name="ln706">	}</a>
<a name="ln707">	dirchange = 1;</a>
<a name="ln708">	dout = dataconn(lmode);</a>
<a name="ln709">	if (dout == NULL)</a>
<a name="ln710">		goto abort;</a>
<a name="ln711"> </a>
<a name="ln712">	if (sndbuf_size &gt; bufsize) {</a>
<a name="ln713">		if (buf)</a>
<a name="ln714">			(void)free(buf);</a>
<a name="ln715">		bufsize = sndbuf_size;</a>
<a name="ln716">		buf = xmalloc(bufsize);</a>
<a name="ln717">	}</a>
<a name="ln718"> </a>
<a name="ln719">	progressmeter(-1);</a>
<a name="ln720">	oldintp = xsignal(SIGPIPE, SIG_IGN);</a>
<a name="ln721"> </a>
<a name="ln722">	switch (curtype) {</a>
<a name="ln723"> </a>
<a name="ln724">	case TYPE_I:</a>
<a name="ln725">	case TYPE_L:</a>
<a name="ln726">		if (rate_put) {		/* rate limited */</a>
<a name="ln727">			while (1) {</a>
<a name="ln728">				struct timeval then, now, td;</a>
<a name="ln729">				off_t bufrem;</a>
<a name="ln730"> </a>
<a name="ln731">				(void)gettimeofday(&amp;then, NULL);</a>
<a name="ln732">				errno = c = d = 0;</a>
<a name="ln733">				bufrem = rate_put;</a>
<a name="ln734">				while (bufrem &gt; 0) {</a>
<a name="ln735">					if ((c = read(fileno(fin), buf,</a>
<a name="ln736">					    MIN(bufsize, bufrem))) &lt;= 0)</a>
<a name="ln737">						goto senddone;</a>
<a name="ln738">					bytes += c;</a>
<a name="ln739">					bufrem -= c;</a>
<a name="ln740">					for (bufp = buf; c &gt; 0;</a>
<a name="ln741">					    c -= d, bufp += d)</a>
<a name="ln742">						if ((d = write(fileno(dout),</a>
<a name="ln743">						    bufp, c)) &lt;= 0)</a>
<a name="ln744">							break;</a>
<a name="ln745">					if (d &lt; 0)</a>
<a name="ln746">						goto senddone;</a>
<a name="ln747">					if (hash &amp;&amp;</a>
<a name="ln748">					    (!progress || filesize &lt; 0) ) {</a>
<a name="ln749">						while (bytes &gt;= hashbytes) {</a>
<a name="ln750">							(void)putc('#', ttyout);</a>
<a name="ln751">							hashbytes += mark;</a>
<a name="ln752">						}</a>
<a name="ln753">						(void)fflush(ttyout);</a>
<a name="ln754">					}</a>
<a name="ln755">				}</a>
<a name="ln756">				while (1) {</a>
<a name="ln757">					(void)gettimeofday(&amp;now, NULL);</a>
<a name="ln758">					timersub(&amp;now, &amp;then, &amp;td);</a>
<a name="ln759">					if (td.tv_sec &gt; 0)</a>
<a name="ln760">						break;</a>
<a name="ln761">					usleep(1000000 - td.tv_usec);</a>
<a name="ln762">				}</a>
<a name="ln763">			}</a>
<a name="ln764">		} else {		/* simpler/faster; no rate limit */</a>
<a name="ln765">			while (1) {</a>
<a name="ln766">				errno = c = d = 0;</a>
<a name="ln767">				if ((c = read(fileno(fin), buf, bufsize)) &lt;= 0)</a>
<a name="ln768">					goto senddone;</a>
<a name="ln769">				bytes += c;</a>
<a name="ln770">				for (bufp = buf; c &gt; 0; c -= d, bufp += d)</a>
<a name="ln771">					if ((d = write(fileno(dout), bufp, c))</a>
<a name="ln772">					    &lt;= 0)</a>
<a name="ln773">						break;</a>
<a name="ln774">				if (d &lt; 0)</a>
<a name="ln775">					goto senddone;</a>
<a name="ln776">				if (hash &amp;&amp; (!progress || filesize &lt; 0) ) {</a>
<a name="ln777">					while (bytes &gt;= hashbytes) {</a>
<a name="ln778">						(void)putc('#', ttyout);</a>
<a name="ln779">						hashbytes += mark;</a>
<a name="ln780">					}</a>
<a name="ln781">					(void)fflush(ttyout);</a>
<a name="ln782">				}</a>
<a name="ln783">			}</a>
<a name="ln784">		}</a>
<a name="ln785"> senddone:</a>
<a name="ln786">		if (hash &amp;&amp; (!progress || filesize &lt; 0) &amp;&amp; bytes &gt; 0) {</a>
<a name="ln787">			if (bytes &lt; mark)</a>
<a name="ln788">				(void)putc('#', ttyout);</a>
<a name="ln789">			(void)putc('\n', ttyout);</a>
<a name="ln790">		}</a>
<a name="ln791">		if (c &lt; 0)</a>
<a name="ln792">			warn(&quot;local: %s&quot;, local);</a>
<a name="ln793">		if (d &lt; 0) {</a>
<a name="ln794">			if (errno != EPIPE)</a>
<a name="ln795">				warn(&quot;netout&quot;);</a>
<a name="ln796">			bytes = -1;</a>
<a name="ln797">		}</a>
<a name="ln798">		break;</a>
<a name="ln799"> </a>
<a name="ln800">	case TYPE_A:</a>
<a name="ln801">		while ((c = getc(fin)) != EOF) {</a>
<a name="ln802">			if (c == '\n') {</a>
<a name="ln803">				while (hash &amp;&amp; (!progress || filesize &lt; 0) &amp;&amp;</a>
<a name="ln804">				    (bytes &gt;= hashbytes)) {</a>
<a name="ln805">					(void)putc('#', ttyout);</a>
<a name="ln806">					(void)fflush(ttyout);</a>
<a name="ln807">					hashbytes += mark;</a>
<a name="ln808">				}</a>
<a name="ln809">				if (ferror(dout))</a>
<a name="ln810">					break;</a>
<a name="ln811">				(void)putc('\r', dout);</a>
<a name="ln812">				bytes++;</a>
<a name="ln813">			}</a>
<a name="ln814">			(void)putc(c, dout);</a>
<a name="ln815">			bytes++;</a>
<a name="ln816">#if 0	/* this violates RFC */</a>
<a name="ln817">			if (c == '\r') {</a>
<a name="ln818">				(void)putc('\0', dout);</a>
<a name="ln819">				bytes++;</a>
<a name="ln820">			}</a>
<a name="ln821">#endif</a>
<a name="ln822">		}</a>
<a name="ln823">		if (hash &amp;&amp; (!progress || filesize &lt; 0)) {</a>
<a name="ln824">			if (bytes &lt; hashbytes)</a>
<a name="ln825">				(void)putc('#', ttyout);</a>
<a name="ln826">			(void)putc('\n', ttyout);</a>
<a name="ln827">		}</a>
<a name="ln828">		if (ferror(fin))</a>
<a name="ln829">			warn(&quot;local: %s&quot;, local);</a>
<a name="ln830">		if (ferror(dout)) {</a>
<a name="ln831">			if (errno != EPIPE)</a>
<a name="ln832">				warn(&quot;netout&quot;);</a>
<a name="ln833">			bytes = -1;</a>
<a name="ln834">		}</a>
<a name="ln835">		break;</a>
<a name="ln836">	}</a>
<a name="ln837"> </a>
<a name="ln838">	progressmeter(1);</a>
<a name="ln839">	if (closefunc != NULL) {</a>
<a name="ln840">		(*closefunc)(fin);</a>
<a name="ln841">		fin = NULL;</a>
<a name="ln842">	}</a>
<a name="ln843">	(void)fclose(dout);</a>
<a name="ln844">	dout = NULL;</a>
<a name="ln845">	(void)getreply(0);</a>
<a name="ln846">	if (bytes &gt; 0)</a>
<a name="ln847">		ptransfer(0);</a>
<a name="ln848">	goto cleanupsend;</a>
<a name="ln849"> </a>
<a name="ln850"> abort:</a>
<a name="ln851">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln852">	oldintr = NULL;</a>
<a name="ln853">	if (!cpend) {</a>
<a name="ln854">		code = -1;</a>
<a name="ln855">		goto cleanupsend;</a>
<a name="ln856">	}</a>
<a name="ln857">	if (data &gt;= 0) {</a>
<a name="ln858">		(void)close(data);</a>
<a name="ln859">		data = -1;</a>
<a name="ln860">	}</a>
<a name="ln861">	if (dout) {</a>
<a name="ln862">		(void)fclose(dout);</a>
<a name="ln863">		dout = NULL;</a>
<a name="ln864">	}</a>
<a name="ln865">	(void)getreply(0);</a>
<a name="ln866">	code = -1;</a>
<a name="ln867">	if (bytes &gt; 0)</a>
<a name="ln868">		ptransfer(0);</a>
<a name="ln869"> </a>
<a name="ln870"> cleanupsend:</a>
<a name="ln871">	if (oldintr)</a>
<a name="ln872">		(void)xsignal(SIGINT, oldintr);</a>
<a name="ln873">	if (oldintp)</a>
<a name="ln874">		(void)xsignal(SIGPIPE, oldintp);</a>
<a name="ln875">	if (data &gt;= 0) {</a>
<a name="ln876">		(void)close(data);</a>
<a name="ln877">		data = -1;</a>
<a name="ln878">	}</a>
<a name="ln879">	if (closefunc != NULL &amp;&amp; fin != NULL)</a>
<a name="ln880">		(*closefunc)(fin);</a>
<a name="ln881">	if (dout)</a>
<a name="ln882">		(void)fclose(dout);</a>
<a name="ln883">	progress = oprogress;</a>
<a name="ln884">	restart_point = 0;</a>
<a name="ln885">	bytes = 0;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">void</a>
<a name="ln889">recvrequest(const char *cmd, const char *local, const char *remote,</a>
<a name="ln890">	    const char *lmode, int printnames, int ignorespecial)</a>
<a name="ln891">{</a>
<a name="ln892">	FILE *fout, *din;</a>
<a name="ln893">	int (*closefunc)(FILE *);</a>
<a name="ln894">	sigfunc oldintr, oldintp;</a>
<a name="ln895">	int c, d;</a>
<a name="ln896">	volatile int is_retr, tcrflag, bare_lfs;</a>
<a name="ln897">	static size_t bufsize;</a>
<a name="ln898">	static char *buf;</a>
<a name="ln899">	volatile off_t hashbytes;</a>
<a name="ln900">	struct stat st;</a>
<a name="ln901">	time_t mtime;</a>
<a name="ln902">	struct timeval tval[2];</a>
<a name="ln903">	int oprogress;</a>
<a name="ln904">	int opreserve;</a>
<a name="ln905"> </a>
<a name="ln906">#ifdef __GNUC__			/* to shut up gcc warnings */</a>
<a name="ln907">	(void)&amp;local;</a>
<a name="ln908">	(void)&amp;fout;</a>
<a name="ln909">	(void)&amp;din;</a>
<a name="ln910">	(void)&amp;closefunc;</a>
<a name="ln911">	(void)&amp;oldintr;</a>
<a name="ln912">	(void)&amp;oldintp;</a>
<a name="ln913">#endif</a>
<a name="ln914"> </a>
<a name="ln915">	fout = NULL;</a>
<a name="ln916">	din = NULL;</a>
<a name="ln917">	hashbytes = mark;</a>
<a name="ln918">	direction = &quot;received&quot;;</a>
<a name="ln919">	bytes = 0;</a>
<a name="ln920">	bare_lfs = 0;</a>
<a name="ln921">	filesize = -1;</a>
<a name="ln922">	oprogress = progress;</a>
<a name="ln923">	opreserve = preserve;</a>
<a name="ln924">	is_retr = (strcmp(cmd, &quot;RETR&quot;) == 0);</a>
<a name="ln925">	if (is_retr &amp;&amp; verbose &amp;&amp; printnames) {</a>
<a name="ln926">		if (local &amp;&amp; (ignorespecial || *local != '-'))</a>
<a name="ln927">			fprintf(ttyout, &quot;local: %s &quot;, local);</a>
<a name="ln928">		if (remote)</a>
<a name="ln929">			fprintf(ttyout, &quot;remote: %s\n&quot;, remote);</a>
<a name="ln930">	}</a>
<a name="ln931">	if (proxy &amp;&amp; is_retr) {</a>
<a name="ln932">		proxtrans(cmd, local, remote);</a>
<a name="ln933">		return;</a>
<a name="ln934">	}</a>
<a name="ln935">	closefunc = NULL;</a>
<a name="ln936">	oldintr = NULL;</a>
<a name="ln937">	oldintp = NULL;</a>
<a name="ln938">	tcrflag = !crflag &amp;&amp; is_retr;</a>
<a name="ln939">	if (sigsetjmp(xferabort, 1)) {</a>
<a name="ln940">		while (cpend)</a>
<a name="ln941">			(void)getreply(0);</a>
<a name="ln942">		code = -1;</a>
<a name="ln943">		goto cleanuprecv;</a>
<a name="ln944">	}</a>
<a name="ln945">	(void)xsignal(SIGQUIT, psummary);</a>
<a name="ln946">	oldintr = xsignal(SIGINT, abortxfer);</a>
<a name="ln947">	if (ignorespecial || (strcmp(local, &quot;-&quot;) &amp;&amp; *local != '|')) {</a>
<a name="ln948">		if (access(local, W_OK) &lt; 0) {</a>
<a name="ln949">			char *dir = strrchr(local, '/');</a>
<a name="ln950"> </a>
<a name="ln951">			if (errno != ENOENT &amp;&amp; errno != EACCES) {</a>
<a name="ln952">				warn(&quot;local: %s&quot;, local);</a>
<a name="ln953">				code = -1;</a>
<a name="ln954">				goto cleanuprecv;</a>
<a name="ln955">			}</a>
<a name="ln956">			if (dir != NULL)</a>
<a name="ln957">				*dir = 0;</a>
<a name="ln958">			d = access(dir == local ? &quot;/&quot; :</a>
<a name="ln959">			    dir ? local : &quot;.&quot;, W_OK);</a>
<a name="ln960">			if (dir != NULL)</a>
<a name="ln961">				*dir = '/';</a>
<a name="ln962">			if (d &lt; 0) {</a>
<a name="ln963">				warn(&quot;local: %s&quot;, local);</a>
<a name="ln964">				code = -1;</a>
<a name="ln965">				goto cleanuprecv;</a>
<a name="ln966">			}</a>
<a name="ln967">			if (!runique &amp;&amp; errno == EACCES &amp;&amp;</a>
<a name="ln968">			    chmod(local, (S_IRUSR|S_IWUSR)) &lt; 0) {</a>
<a name="ln969">				warn(&quot;local: %s&quot;, local);</a>
<a name="ln970">				code = -1;</a>
<a name="ln971">				goto cleanuprecv;</a>
<a name="ln972">			}</a>
<a name="ln973">			if (runique &amp;&amp; errno == EACCES &amp;&amp;</a>
<a name="ln974">			   (local = gunique(local)) == NULL) {</a>
<a name="ln975">				code = -1;</a>
<a name="ln976">				goto cleanuprecv;</a>
<a name="ln977">			}</a>
<a name="ln978">		}</a>
<a name="ln979">		else if (runique &amp;&amp; (local = gunique(local)) == NULL) {</a>
<a name="ln980">			code = -1;</a>
<a name="ln981">			goto cleanuprecv;</a>
<a name="ln982">		}</a>
<a name="ln983">	}</a>
<a name="ln984">	if (!is_retr) {</a>
<a name="ln985">		if (curtype != TYPE_A)</a>
<a name="ln986">			changetype(TYPE_A, 0);</a>
<a name="ln987">	} else {</a>
<a name="ln988">		if (curtype != type)</a>
<a name="ln989">			changetype(type, 0);</a>
<a name="ln990">		filesize = remotesize(remote, 0);</a>
<a name="ln991">		if (code == 421 || code == -1)</a>
<a name="ln992">			goto cleanuprecv;</a>
<a name="ln993">	}</a>
<a name="ln994">	if (initconn()) {</a>
<a name="ln995">		code = -1;</a>
<a name="ln996">		goto cleanuprecv;</a>
<a name="ln997">	}</a>
<a name="ln998">	if (sigsetjmp(xferabort, 1))</a>
<a name="ln999">		goto abort;</a>
<a name="ln1000">	if (is_retr &amp;&amp; restart_point &amp;&amp;</a>
<a name="ln1001">	    command(&quot;REST &quot; LLF, (LLT) restart_point) != CONTINUE)</a>
<a name="ln1002">		goto cleanuprecv;</a>
<a name="ln1003">	if (! EMPTYSTRING(remote)) {</a>
<a name="ln1004">		if (command(&quot;%s %s&quot;, cmd, remote) != PRELIM)</a>
<a name="ln1005">			goto cleanuprecv;</a>
<a name="ln1006">	} else {</a>
<a name="ln1007">		if (command(&quot;%s&quot;, cmd) != PRELIM)</a>
<a name="ln1008">			goto cleanuprecv;</a>
<a name="ln1009">	}</a>
<a name="ln1010">	din = dataconn(&quot;r&quot;);</a>
<a name="ln1011">	if (din == NULL)</a>
<a name="ln1012">		goto abort;</a>
<a name="ln1013">	if (!ignorespecial &amp;&amp; strcmp(local, &quot;-&quot;) == 0) {</a>
<a name="ln1014">		fout = stdout;</a>
<a name="ln1015">		progress = 0;</a>
<a name="ln1016">		preserve = 0;</a>
<a name="ln1017">	} else if (!ignorespecial &amp;&amp; *local == '|') {</a>
<a name="ln1018">		oldintp = xsignal(SIGPIPE, SIG_IGN);</a>
<a name="ln1019">		fout = popen(local + 1, &quot;w&quot;);</a>
<a name="ln1020">		if (fout == NULL) {</a>
<a name="ln1021">			warn(&quot;%s&quot;, local+1);</a>
<a name="ln1022">			goto abort;</a>
<a name="ln1023">		}</a>
<a name="ln1024">		progress = 0;</a>
<a name="ln1025">		preserve = 0;</a>
<a name="ln1026">		closefunc = pclose;</a>
<a name="ln1027">	} else {</a>
<a name="ln1028">		fout = fopen(local, lmode);</a>
<a name="ln1029">		if (fout == NULL) {</a>
<a name="ln1030">			warn(&quot;local: %s&quot;, local);</a>
<a name="ln1031">			goto abort;</a>
<a name="ln1032">		}</a>
<a name="ln1033">		closefunc = fclose;</a>
<a name="ln1034">	}</a>
<a name="ln1035"> </a>
<a name="ln1036">	if (fstat(fileno(fout), &amp;st) != -1 &amp;&amp; !S_ISREG(st.st_mode)) {</a>
<a name="ln1037">		progress = 0;</a>
<a name="ln1038">		preserve = 0;</a>
<a name="ln1039">	}</a>
<a name="ln1040">	if (rcvbuf_size &gt; bufsize) {</a>
<a name="ln1041">		if (buf)</a>
<a name="ln1042">			(void)free(buf);</a>
<a name="ln1043">		bufsize = rcvbuf_size;</a>
<a name="ln1044">		buf = xmalloc(bufsize);</a>
<a name="ln1045">	}</a>
<a name="ln1046"> </a>
<a name="ln1047">	progressmeter(-1);</a>
<a name="ln1048"> </a>
<a name="ln1049">	switch (curtype) {</a>
<a name="ln1050"> </a>
<a name="ln1051">	case TYPE_I:</a>
<a name="ln1052">	case TYPE_L:</a>
<a name="ln1053">		if (is_retr &amp;&amp; restart_point &amp;&amp;</a>
<a name="ln1054">		    lseek(fileno(fout), restart_point, SEEK_SET) &lt; 0) {</a>
<a name="ln1055">			warn(&quot;local: %s&quot;, local);</a>
<a name="ln1056">			goto cleanuprecv;</a>
<a name="ln1057">		}</a>
<a name="ln1058">		if (rate_get) {		/* rate limiting */</a>
<a name="ln1059">			while (1) {</a>
<a name="ln1060">				struct timeval then, now, td;</a>
<a name="ln1061">				off_t bufrem;</a>
<a name="ln1062"> </a>
<a name="ln1063">				(void)gettimeofday(&amp;then, NULL);</a>
<a name="ln1064">				errno = c = d = 0;</a>
<a name="ln1065">				for (bufrem = rate_get; bufrem &gt; 0; ) {</a>
<a name="ln1066">					if ((c = read(fileno(din), buf,</a>
<a name="ln1067">					    MIN(bufsize, bufrem))) &lt;= 0)</a>
<a name="ln1068">						goto recvdone;</a>
<a name="ln1069">					bytes += c;</a>
<a name="ln1070">					bufrem -=c;</a>
<a name="ln1071">					if ((d = write(fileno(fout), buf, c))</a>
<a name="ln1072">					    != c)</a>
<a name="ln1073">						goto recvdone;</a>
<a name="ln1074">					if (hash &amp;&amp;</a>
<a name="ln1075">					    (!progress || filesize &lt; 0)) {</a>
<a name="ln1076">						while (bytes &gt;= hashbytes) {</a>
<a name="ln1077">							(void)putc('#', ttyout);</a>
<a name="ln1078">							hashbytes += mark;</a>
<a name="ln1079">						}</a>
<a name="ln1080">						(void)fflush(ttyout);</a>
<a name="ln1081">					}</a>
<a name="ln1082">				}</a>
<a name="ln1083">					/* sleep until time is up */</a>
<a name="ln1084">				while (1) {</a>
<a name="ln1085">					(void)gettimeofday(&amp;now, NULL);</a>
<a name="ln1086">					timersub(&amp;now, &amp;then, &amp;td);</a>
<a name="ln1087">					if (td.tv_sec &gt; 0)</a>
<a name="ln1088">						break;</a>
<a name="ln1089">					usleep(1000000 - td.tv_usec);</a>
<a name="ln1090">				}</a>
<a name="ln1091">			}</a>
<a name="ln1092">		} else {		/* faster code (no limiting) */</a>
<a name="ln1093">			while (1) {</a>
<a name="ln1094">				errno = c = d = 0;</a>
<a name="ln1095">				if ((c = read(fileno(din), buf, bufsize)) &lt;= 0)</a>
<a name="ln1096">					goto recvdone;</a>
<a name="ln1097">				bytes += c;</a>
<a name="ln1098">				if ((d = write(fileno(fout), buf, c)) != c)</a>
<a name="ln1099">					goto recvdone;</a>
<a name="ln1100">				if (hash &amp;&amp; (!progress || filesize &lt; 0)) {</a>
<a name="ln1101">					while (bytes &gt;= hashbytes) {</a>
<a name="ln1102">						(void)putc('#', ttyout);</a>
<a name="ln1103">						hashbytes += mark;</a>
<a name="ln1104">					}</a>
<a name="ln1105">					(void)fflush(ttyout);</a>
<a name="ln1106">				}</a>
<a name="ln1107">			}</a>
<a name="ln1108">		}</a>
<a name="ln1109"> recvdone:</a>
<a name="ln1110">		if (hash &amp;&amp; (!progress || filesize &lt; 0) &amp;&amp; bytes &gt; 0) {</a>
<a name="ln1111">			if (bytes &lt; mark)</a>
<a name="ln1112">				(void)putc('#', ttyout);</a>
<a name="ln1113">			(void)putc('\n', ttyout);</a>
<a name="ln1114">		}</a>
<a name="ln1115">		if (c &lt; 0) {</a>
<a name="ln1116">			if (errno != EPIPE)</a>
<a name="ln1117">				warn(&quot;netin&quot;);</a>
<a name="ln1118">			bytes = -1;</a>
<a name="ln1119">		}</a>
<a name="ln1120">		if (d &lt; c) {</a>
<a name="ln1121">			if (d &lt; 0)</a>
<a name="ln1122">				warn(&quot;local: %s&quot;, local);</a>
<a name="ln1123">			else</a>
<a name="ln1124">				warnx(&quot;%s: short write&quot;, local);</a>
<a name="ln1125">		}</a>
<a name="ln1126">		break;</a>
<a name="ln1127"> </a>
<a name="ln1128">	case TYPE_A:</a>
<a name="ln1129">		if (is_retr &amp;&amp; restart_point) {</a>
<a name="ln1130">			int ch;</a>
<a name="ln1131">			off_t i;</a>
<a name="ln1132"> </a>
<a name="ln1133">			if (fseeko(fout, (off_t)0, SEEK_SET) &lt; 0)</a>
<a name="ln1134">				goto done;</a>
<a name="ln1135">			for (i = 0; i++ &lt; restart_point;) {</a>
<a name="ln1136">				if ((ch = getc(fout)) == EOF)</a>
<a name="ln1137">					goto done;</a>
<a name="ln1138">				if (ch == '\n')</a>
<a name="ln1139">					i++;</a>
<a name="ln1140">			}</a>
<a name="ln1141">			if (fseeko(fout, (off_t)0, SEEK_CUR) &lt; 0) {</a>
<a name="ln1142"> done:</a>
<a name="ln1143">				warn(&quot;local: %s&quot;, local);</a>
<a name="ln1144">				goto cleanuprecv;</a>
<a name="ln1145">			}</a>
<a name="ln1146">		}</a>
<a name="ln1147">		while ((c = getc(din)) != EOF) {</a>
<a name="ln1148">			if (c == '\n')</a>
<a name="ln1149">				bare_lfs++;</a>
<a name="ln1150">			while (c == '\r') {</a>
<a name="ln1151">				while (hash &amp;&amp; (!progress || filesize &lt; 0) &amp;&amp;</a>
<a name="ln1152">				    (bytes &gt;= hashbytes)) {</a>
<a name="ln1153">					(void)putc('#', ttyout);</a>
<a name="ln1154">					(void)fflush(ttyout);</a>
<a name="ln1155">					hashbytes += mark;</a>
<a name="ln1156">				}</a>
<a name="ln1157">				bytes++;</a>
<a name="ln1158">				if ((c = getc(din)) != '\n' || tcrflag) {</a>
<a name="ln1159">					if (ferror(fout))</a>
<a name="ln1160">						goto break2;</a>
<a name="ln1161">					(void)putc('\r', fout);</a>
<a name="ln1162">					if (c == '\0') {</a>
<a name="ln1163">						bytes++;</a>
<a name="ln1164">						goto contin2;</a>
<a name="ln1165">					}</a>
<a name="ln1166">					if (c == EOF)</a>
<a name="ln1167">						goto contin2;</a>
<a name="ln1168">				}</a>
<a name="ln1169">			}</a>
<a name="ln1170">			(void)putc(c, fout);</a>
<a name="ln1171">			bytes++;</a>
<a name="ln1172">	contin2:	;</a>
<a name="ln1173">		}</a>
<a name="ln1174"> break2:</a>
<a name="ln1175">		if (hash &amp;&amp; (!progress || filesize &lt; 0)) {</a>
<a name="ln1176">			if (bytes &lt; hashbytes)</a>
<a name="ln1177">				(void)putc('#', ttyout);</a>
<a name="ln1178">			(void)putc('\n', ttyout);</a>
<a name="ln1179">		}</a>
<a name="ln1180">		if (ferror(din)) {</a>
<a name="ln1181">			if (errno != EPIPE)</a>
<a name="ln1182">				warn(&quot;netin&quot;);</a>
<a name="ln1183">			bytes = -1;</a>
<a name="ln1184">		}</a>
<a name="ln1185">		if (ferror(fout))</a>
<a name="ln1186">			warn(&quot;local: %s&quot;, local);</a>
<a name="ln1187">		break;</a>
<a name="ln1188">	}</a>
<a name="ln1189"> </a>
<a name="ln1190">	progressmeter(1);</a>
<a name="ln1191">	if (closefunc != NULL) {</a>
<a name="ln1192">		(*closefunc)(fout);</a>
<a name="ln1193">		fout = NULL;</a>
<a name="ln1194">	}</a>
<a name="ln1195">	(void)fclose(din);</a>
<a name="ln1196">	din = NULL;</a>
<a name="ln1197">	(void)getreply(0);</a>
<a name="ln1198">	if (bare_lfs) {</a>
<a name="ln1199">		fprintf(ttyout,</a>
<a name="ln1200">		    &quot;WARNING! %d bare linefeeds received in ASCII mode.\n&quot;,</a>
<a name="ln1201">		    bare_lfs);</a>
<a name="ln1202">		fputs(&quot;File may not have transferred correctly.\n&quot;, ttyout);</a>
<a name="ln1203">	}</a>
<a name="ln1204">	if (bytes &gt;= 0 &amp;&amp; is_retr) {</a>
<a name="ln1205">		if (bytes &gt; 0)</a>
<a name="ln1206">			ptransfer(0);</a>
<a name="ln1207">		if (preserve &amp;&amp; (closefunc == fclose)) {</a>
<a name="ln1208">			mtime = remotemodtime(remote, 0);</a>
<a name="ln1209">			if (mtime != -1) {</a>
<a name="ln1210">				(void)gettimeofday(&amp;tval[0], NULL);</a>
<a name="ln1211">				tval[1].tv_sec = mtime;</a>
<a name="ln1212">				tval[1].tv_usec = 0;</a>
<a name="ln1213">				if (utimes(local, tval) == -1) {</a>
<a name="ln1214">					fprintf(ttyout,</a>
<a name="ln1215">				&quot;Can't change modification time on %s to %s&quot;,</a>
<a name="ln1216">					    local, asctime(localtime(&amp;mtime)));</a>
<a name="ln1217">				}</a>
<a name="ln1218">			}</a>
<a name="ln1219">		}</a>
<a name="ln1220">	}</a>
<a name="ln1221">	goto cleanuprecv;</a>
<a name="ln1222"> </a>
<a name="ln1223"> abort:</a>
<a name="ln1224">			/*</a>
<a name="ln1225">			 * abort using RFC 959 recommended IP,SYNC sequence</a>
<a name="ln1226">			 */</a>
<a name="ln1227">	if (! sigsetjmp(xferabort, 1)) {</a>
<a name="ln1228">			/* this is the first call */</a>
<a name="ln1229">		(void)xsignal(SIGINT, abort_squared);</a>
<a name="ln1230">		if (!cpend) {</a>
<a name="ln1231">			code = -1;</a>
<a name="ln1232">			goto cleanuprecv;</a>
<a name="ln1233">		}</a>
<a name="ln1234">		abort_remote(din);</a>
<a name="ln1235">	}</a>
<a name="ln1236">	code = -1;</a>
<a name="ln1237">	if (bytes &gt; 0)</a>
<a name="ln1238">		ptransfer(0);</a>
<a name="ln1239"> </a>
<a name="ln1240"> cleanuprecv:</a>
<a name="ln1241">	if (oldintr)</a>
<a name="ln1242">		(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1243">	if (oldintp)</a>
<a name="ln1244">		(void)xsignal(SIGPIPE, oldintp);</a>
<a name="ln1245">	if (data &gt;= 0) {</a>
<a name="ln1246">		(void)close(data);</a>
<a name="ln1247">		data = -1;</a>
<a name="ln1248">	}</a>
<a name="ln1249">	if (closefunc != NULL &amp;&amp; fout != NULL)</a>
<a name="ln1250">		(*closefunc)(fout);</a>
<a name="ln1251">	if (din)</a>
<a name="ln1252">		(void)fclose(din);</a>
<a name="ln1253">	progress = oprogress;</a>
<a name="ln1254">	preserve = opreserve;</a>
<a name="ln1255">	bytes = 0;</a>
<a name="ln1256">}</a>
<a name="ln1257"> </a>
<a name="ln1258">/*</a>
<a name="ln1259"> * Need to start a listen on the data channel before we send the command,</a>
<a name="ln1260"> * otherwise the server's connect may fail.</a>
<a name="ln1261"> */</a>
<a name="ln1262">int</a>
<a name="ln1263">initconn(void)</a>
<a name="ln1264">{</a>
<a name="ln1265">	char *p, *a;</a>
<a name="ln1266">	int result, tmpno = 0;</a>
<a name="ln1267">	int on = 1;</a>
<a name="ln1268">	int error;</a>
<a name="ln1269">	u_int addr[16], port[2];</a>
<a name="ln1270">	u_int af, hal, pal;</a>
<a name="ln1271">	socklen_t len;</a>
<a name="ln1272">	char *pasvcmd = NULL;</a>
<a name="ln1273"> </a>
<a name="ln1274">#ifdef INET6</a>
<a name="ln1275">	if (myctladdr.su_family == AF_INET6 &amp;&amp; debug &amp;&amp;</a>
<a name="ln1276">	    (IN6_IS_ADDR_LINKLOCAL(&amp;myctladdr.si_su.su_sin6.sin6_addr) ||</a>
<a name="ln1277">	     IN6_IS_ADDR_SITELOCAL(&amp;myctladdr.si_su.su_sin6.sin6_addr))) {</a>
<a name="ln1278">		warnx(&quot;use of scoped address can be troublesome&quot;);</a>
<a name="ln1279">	}</a>
<a name="ln1280">#endif</a>
<a name="ln1281"> reinit:</a>
<a name="ln1282">	if (passivemode) {</a>
<a name="ln1283">		data_addr = myctladdr;</a>
<a name="ln1284">		data = socket(data_addr.su_family, SOCK_STREAM, 0);</a>
<a name="ln1285">		if (data &lt; 0) {</a>
<a name="ln1286">			warn(&quot;socket&quot;);</a>
<a name="ln1287">			return (1);</a>
<a name="ln1288">		}</a>
<a name="ln1289">		if ((options &amp; SO_DEBUG) &amp;&amp;</a>
<a name="ln1290">		    setsockopt(data, SOL_SOCKET, SO_DEBUG,</a>
<a name="ln1291">				(void *)&amp;on, sizeof(on)) == -1) {</a>
<a name="ln1292">			if (debug)</a>
<a name="ln1293">				warn(&quot;setsockopt %s (ignored)&quot;, &quot;SO_DEBUG&quot;);</a>
<a name="ln1294">		}</a>
<a name="ln1295">		result = COMPLETE + 1;</a>
<a name="ln1296">		switch (data_addr.su_family) {</a>
<a name="ln1297">		case AF_INET:</a>
<a name="ln1298">			if (epsv4 &amp;&amp; !epsv4bad) {</a>
<a name="ln1299">				pasvcmd = &quot;EPSV&quot;;</a>
<a name="ln1300">				result = command(&quot;EPSV&quot;);</a>
<a name="ln1301">				if (!connected)</a>
<a name="ln1302">					return (1);</a>
<a name="ln1303">				/*</a>
<a name="ln1304">				 * this code is to be friendly with broken</a>
<a name="ln1305">				 * BSDI ftpd</a>
<a name="ln1306">				 */</a>
<a name="ln1307">				if (code / 10 == 22 &amp;&amp; code != 229) {</a>
<a name="ln1308">					fputs(</a>
<a name="ln1309">&quot;wrong server: return code must be 229\n&quot;,</a>
<a name="ln1310">						ttyout);</a>
<a name="ln1311">					result = COMPLETE + 1;</a>
<a name="ln1312">				}</a>
<a name="ln1313">				if (result != COMPLETE) {</a>
<a name="ln1314">					epsv4bad = 1;</a>
<a name="ln1315">					if (debug)</a>
<a name="ln1316">						fputs(</a>
<a name="ln1317">					&quot;disabling epsv4 for this connection\n&quot;,</a>
<a name="ln1318">						    ttyout);</a>
<a name="ln1319">				}</a>
<a name="ln1320">			}</a>
<a name="ln1321">			if (result != COMPLETE) {</a>
<a name="ln1322">				pasvcmd = &quot;PASV&quot;;</a>
<a name="ln1323">				result = command(&quot;PASV&quot;);</a>
<a name="ln1324">				if (!connected)</a>
<a name="ln1325">					return (1);</a>
<a name="ln1326">			}</a>
<a name="ln1327">			break;</a>
<a name="ln1328">#ifdef INET6</a>
<a name="ln1329">		case AF_INET6:</a>
<a name="ln1330">			pasvcmd = &quot;EPSV&quot;;</a>
<a name="ln1331">			result = command(&quot;EPSV&quot;);</a>
<a name="ln1332">			if (!connected)</a>
<a name="ln1333">				return (1);</a>
<a name="ln1334">			/* this code is to be friendly with broken BSDI ftpd */</a>
<a name="ln1335">			if (code / 10 == 22 &amp;&amp; code != 229) {</a>
<a name="ln1336">				fputs(</a>
<a name="ln1337">&quot;wrong server: return code must be 229\n&quot;,</a>
<a name="ln1338">					ttyout);</a>
<a name="ln1339">				result = COMPLETE + 1;</a>
<a name="ln1340">			}</a>
<a name="ln1341">			if (result != COMPLETE) {</a>
<a name="ln1342">				pasvcmd = &quot;LPSV&quot;;</a>
<a name="ln1343">				result = command(&quot;LPSV&quot;);</a>
<a name="ln1344">			}</a>
<a name="ln1345">			if (!connected)</a>
<a name="ln1346">				return (1);</a>
<a name="ln1347">			break;</a>
<a name="ln1348">#endif</a>
<a name="ln1349">		default:</a>
<a name="ln1350">			result = COMPLETE + 1;</a>
<a name="ln1351">			break;</a>
<a name="ln1352">		}</a>
<a name="ln1353">		if (result != COMPLETE) {</a>
<a name="ln1354">			if (activefallback) {</a>
<a name="ln1355">				(void)close(data);</a>
<a name="ln1356">				data = -1;</a>
<a name="ln1357">				passivemode = 0;</a>
<a name="ln1358">#if 0</a>
<a name="ln1359">				activefallback = 0;</a>
<a name="ln1360">#endif</a>
<a name="ln1361">				goto reinit;</a>
<a name="ln1362">			}</a>
<a name="ln1363">			fputs(&quot;Passive mode refused.\n&quot;, ttyout);</a>
<a name="ln1364">			goto bad;</a>
<a name="ln1365">		}</a>
<a name="ln1366"> </a>
<a name="ln1367">#define	pack2(var, off) \</a>
<a name="ln1368">	(((var[(off) + 0] &amp; 0xff) &lt;&lt; 8) | ((var[(off) + 1] &amp; 0xff) &lt;&lt; 0))</a>
<a name="ln1369">#define	pack4(var, off) \</a>
<a name="ln1370">	(((var[(off) + 0] &amp; 0xff) &lt;&lt; 24) | ((var[(off) + 1] &amp; 0xff) &lt;&lt; 16) | \</a>
<a name="ln1371">	 ((var[(off) + 2] &amp; 0xff) &lt;&lt; 8) | ((var[(off) + 3] &amp; 0xff) &lt;&lt; 0))</a>
<a name="ln1372">#define	UC(b)	(((int)b)&amp;0xff)</a>
<a name="ln1373"> </a>
<a name="ln1374">		/*</a>
<a name="ln1375">		 * What we've got at this point is a string of comma separated</a>
<a name="ln1376">		 * one-byte unsigned integer values, separated by commas.</a>
<a name="ln1377">		 */</a>
<a name="ln1378">		if (strcmp(pasvcmd, &quot;PASV&quot;) == 0) {</a>
<a name="ln1379">			if (data_addr.su_family != AF_INET) {</a>
<a name="ln1380">				fputs(</a>
<a name="ln1381">    &quot;Passive mode AF mismatch. Shouldn't happen!\n&quot;, ttyout);</a>
<a name="ln1382">				error = 1;</a>
<a name="ln1383">				goto bad;</a>
<a name="ln1384">			}</a>
<a name="ln1385">			if (code / 10 == 22 &amp;&amp; code != 227) {</a>
<a name="ln1386">				fputs(&quot;wrong server: return code must be 227\n&quot;,</a>
<a name="ln1387">					ttyout);</a>
<a name="ln1388">				error = 1;</a>
<a name="ln1389">				goto bad;</a>
<a name="ln1390">			}</a>
<a name="ln1391">			error = sscanf(pasv, &quot;%u,%u,%u,%u,%u,%u&quot;,</a>
<a name="ln1392">					&amp;addr[0], &amp;addr[1], &amp;addr[2], &amp;addr[3],</a>
<a name="ln1393">					&amp;port[0], &amp;port[1]);</a>
<a name="ln1394">			if (error != 6) {</a>
<a name="ln1395">				fputs(</a>
<a name="ln1396">&quot;Passive mode address scan failure. Shouldn't happen!\n&quot;, ttyout);</a>
<a name="ln1397">				error = 1;</a>
<a name="ln1398">				goto bad;</a>
<a name="ln1399">			}</a>
<a name="ln1400">			error = 0;</a>
<a name="ln1401">			memset(&amp;data_addr, 0, sizeof(data_addr));</a>
<a name="ln1402">			data_addr.su_family = AF_INET;</a>
<a name="ln1403">			data_addr.su_len = sizeof(struct sockaddr_in);</a>
<a name="ln1404">			data_addr.si_su.su_sin.sin_addr.s_addr =</a>
<a name="ln1405">			    htonl(pack4(addr, 0));</a>
<a name="ln1406">			data_addr.su_port = htons(pack2(port, 0));</a>
<a name="ln1407">		} else if (strcmp(pasvcmd, &quot;LPSV&quot;) == 0) {</a>
<a name="ln1408">			if (code / 10 == 22 &amp;&amp; code != 228) {</a>
<a name="ln1409">				fputs(&quot;wrong server: return code must be 228\n&quot;,</a>
<a name="ln1410">					ttyout);</a>
<a name="ln1411">				error = 1;</a>
<a name="ln1412">				goto bad;</a>
<a name="ln1413">			}</a>
<a name="ln1414">			switch (data_addr.su_family) {</a>
<a name="ln1415">			case AF_INET:</a>
<a name="ln1416">				error = sscanf(pasv,</a>
<a name="ln1417">&quot;%u,%u,%u,%u,%u,%u,%u,%u,%u&quot;,</a>
<a name="ln1418">					&amp;af, &amp;hal,</a>
<a name="ln1419">					&amp;addr[0], &amp;addr[1], &amp;addr[2], &amp;addr[3],</a>
<a name="ln1420">					&amp;pal, &amp;port[0], &amp;port[1]);</a>
<a name="ln1421">				if (error != 9) {</a>
<a name="ln1422">					fputs(</a>
<a name="ln1423">&quot;Passive mode address scan failure. Shouldn't happen!\n&quot;, ttyout);</a>
<a name="ln1424">					error = 1;</a>
<a name="ln1425">					goto bad;</a>
<a name="ln1426">				}</a>
<a name="ln1427">				if (af != 4 || hal != 4 || pal != 2) {</a>
<a name="ln1428">					fputs(</a>
<a name="ln1429">&quot;Passive mode AF mismatch. Shouldn't happen!\n&quot;, ttyout);</a>
<a name="ln1430">					error = 1;</a>
<a name="ln1431">					goto bad;</a>
<a name="ln1432">				}</a>
<a name="ln1433"> </a>
<a name="ln1434">				error = 0;</a>
<a name="ln1435">				memset(&amp;data_addr, 0, sizeof(data_addr));</a>
<a name="ln1436">				data_addr.su_family = AF_INET;</a>
<a name="ln1437">				data_addr.su_len = sizeof(struct sockaddr_in);</a>
<a name="ln1438">				data_addr.si_su.su_sin.sin_addr.s_addr =</a>
<a name="ln1439">				    htonl(pack4(addr, 0));</a>
<a name="ln1440">				data_addr.su_port = htons(pack2(port, 0));</a>
<a name="ln1441">				break;</a>
<a name="ln1442">#ifdef INET6</a>
<a name="ln1443">			case AF_INET6:</a>
<a name="ln1444">				error = sscanf(pasv,</a>
<a name="ln1445">&quot;%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u,%u&quot;,</a>
<a name="ln1446">					&amp;af, &amp;hal,</a>
<a name="ln1447">					&amp;addr[0], &amp;addr[1], &amp;addr[2], &amp;addr[3],</a>
<a name="ln1448">					&amp;addr[4], &amp;addr[5], &amp;addr[6], &amp;addr[7],</a>
<a name="ln1449">					&amp;addr[8], &amp;addr[9], &amp;addr[10],</a>
<a name="ln1450">					&amp;addr[11], &amp;addr[12], &amp;addr[13],</a>
<a name="ln1451">					&amp;addr[14], &amp;addr[15],</a>
<a name="ln1452">					&amp;pal, &amp;port[0], &amp;port[1]);</a>
<a name="ln1453">				if (error != 21) {</a>
<a name="ln1454">					fputs(</a>
<a name="ln1455">&quot;Passive mode address scan failure. Shouldn't happen!\n&quot;, ttyout);</a>
<a name="ln1456">					error = 1;</a>
<a name="ln1457">					goto bad;</a>
<a name="ln1458">				}</a>
<a name="ln1459">				if (af != 6 || hal != 16 || pal != 2) {</a>
<a name="ln1460">					fputs(</a>
<a name="ln1461">&quot;Passive mode AF mismatch. Shouldn't happen!\n&quot;, ttyout);</a>
<a name="ln1462">					error = 1;</a>
<a name="ln1463">					goto bad;</a>
<a name="ln1464">				}</a>
<a name="ln1465"> </a>
<a name="ln1466">				error = 0;</a>
<a name="ln1467">				memset(&amp;data_addr, 0, sizeof(data_addr));</a>
<a name="ln1468">				data_addr.su_family = AF_INET6;</a>
<a name="ln1469">				data_addr.su_len = sizeof(struct sockaddr_in6);</a>
<a name="ln1470">			    {</a>
<a name="ln1471">				int i;</a>
<a name="ln1472">				for (i = 0; i &lt; sizeof(struct in6_addr); i++) {</a>
<a name="ln1473">					data_addr.si_su.su_sin6.sin6_addr.s6_addr[i] =</a>
<a name="ln1474">					    UC(addr[i]);</a>
<a name="ln1475">				}</a>
<a name="ln1476">			    }</a>
<a name="ln1477">				data_addr.su_port = htons(pack2(port, 0));</a>
<a name="ln1478">				break;</a>
<a name="ln1479">#endif</a>
<a name="ln1480">			default:</a>
<a name="ln1481">				error = 1;</a>
<a name="ln1482">			}</a>
<a name="ln1483">		} else if (strcmp(pasvcmd, &quot;EPSV&quot;) == 0) {</a>
<a name="ln1484">			char delim[4];</a>
<a name="ln1485"> </a>
<a name="ln1486">			port[0] = 0;</a>
<a name="ln1487">			if (code / 10 == 22 &amp;&amp; code != 229) {</a>
<a name="ln1488">				fputs(&quot;wrong server: return code must be 229\n&quot;,</a>
<a name="ln1489">					ttyout);</a>
<a name="ln1490">				error = 1;</a>
<a name="ln1491">				goto bad;</a>
<a name="ln1492">			}</a>
<a name="ln1493">			if (sscanf(pasv, &quot;%c%c%c%d%c&quot;, &amp;delim[0],</a>
<a name="ln1494">					&amp;delim[1], &amp;delim[2], &amp;port[1],</a>
<a name="ln1495">					&amp;delim[3]) != 5) {</a>
<a name="ln1496">				fputs(&quot;parse error!\n&quot;, ttyout);</a>
<a name="ln1497">				error = 1;</a>
<a name="ln1498">				goto bad;</a>
<a name="ln1499">			}</a>
<a name="ln1500">			if (delim[0] != delim[1] || delim[0] != delim[2]</a>
<a name="ln1501">			 || delim[0] != delim[3]) {</a>
<a name="ln1502">				fputs(&quot;parse error!\n&quot;, ttyout);</a>
<a name="ln1503">				error = 1;</a>
<a name="ln1504">				goto bad;</a>
<a name="ln1505">			}</a>
<a name="ln1506">			data_addr = hisctladdr;</a>
<a name="ln1507">			data_addr.su_port = htons(port[1]);</a>
<a name="ln1508">		} else</a>
<a name="ln1509">			goto bad;</a>
<a name="ln1510"> </a>
<a name="ln1511">		while (xconnect(data, (struct sockaddr *)&amp;data_addr.si_su,</a>
<a name="ln1512">			    data_addr.su_len) &lt; 0) {</a>
<a name="ln1513">			if (activefallback) {</a>
<a name="ln1514">				(void)close(data);</a>
<a name="ln1515">				data = -1;</a>
<a name="ln1516">				passivemode = 0;</a>
<a name="ln1517">#if 0</a>
<a name="ln1518">				activefallback = 0;</a>
<a name="ln1519">#endif</a>
<a name="ln1520">				goto reinit;</a>
<a name="ln1521">			}</a>
<a name="ln1522">			warn(&quot;connect for data channel&quot;);</a>
<a name="ln1523">			goto bad;</a>
<a name="ln1524">		}</a>
<a name="ln1525">#ifdef IPTOS_THROUGHPUT</a>
<a name="ln1526">		if (data_addr.su_family == AF_INET) {</a>
<a name="ln1527">			on = IPTOS_THROUGHPUT;</a>
<a name="ln1528">			if (setsockopt(data, IPPROTO_IP, IP_TOS,</a>
<a name="ln1529">					(void *)&amp;on, sizeof(on)) == -1) {</a>
<a name="ln1530">				if (debug)</a>
<a name="ln1531">					warn(&quot;setsockopt %s (ignored)&quot;,</a>
<a name="ln1532">				    	    &quot;IPTOS_THROUGHPUT&quot;);</a>
<a name="ln1533">			}</a>
<a name="ln1534">		}</a>
<a name="ln1535">#endif</a>
<a name="ln1536">		return (0);</a>
<a name="ln1537">	}</a>
<a name="ln1538"> </a>
<a name="ln1539"> noport:</a>
<a name="ln1540">	data_addr = myctladdr;</a>
<a name="ln1541">	if (sendport)</a>
<a name="ln1542">		data_addr.su_port = 0;	/* let system pick one */</a>
<a name="ln1543">	if (data != -1)</a>
<a name="ln1544">		(void)close(data);</a>
<a name="ln1545">	data = socket(data_addr.su_family, SOCK_STREAM, 0);</a>
<a name="ln1546">	if (data &lt; 0) {</a>
<a name="ln1547">		warn(&quot;socket&quot;);</a>
<a name="ln1548">		if (tmpno)</a>
<a name="ln1549">			sendport = 1;</a>
<a name="ln1550">		return (1);</a>
<a name="ln1551">	}</a>
<a name="ln1552">	if (!sendport)</a>
<a name="ln1553">		if (setsockopt(data, SOL_SOCKET, SO_REUSEADDR,</a>
<a name="ln1554">				(void *)&amp;on, sizeof(on)) == -1) {</a>
<a name="ln1555">			warn(&quot;setsockopt %s&quot;, &quot;SO_REUSEADDR&quot;);</a>
<a name="ln1556">			goto bad;</a>
<a name="ln1557">		}</a>
<a name="ln1558">	if (bind(data, (struct sockaddr *)&amp;data_addr.si_su,</a>
<a name="ln1559">	    data_addr.su_len) &lt; 0) {</a>
<a name="ln1560">		warn(&quot;bind&quot;);</a>
<a name="ln1561">		goto bad;</a>
<a name="ln1562">	}</a>
<a name="ln1563">	if ((options &amp; SO_DEBUG) &amp;&amp;</a>
<a name="ln1564">	    setsockopt(data, SOL_SOCKET, SO_DEBUG,</a>
<a name="ln1565">			(void *)&amp;on, sizeof(on)) == -1) {</a>
<a name="ln1566">		if (debug)</a>
<a name="ln1567">			warn(&quot;setsockopt %s (ignored)&quot;, &quot;SO_DEBUG&quot;);</a>
<a name="ln1568">	}</a>
<a name="ln1569">	len = sizeof(data_addr.si_su);</a>
<a name="ln1570">	memset((char *)&amp;data_addr, 0, sizeof (data_addr));</a>
<a name="ln1571">	if (getsockname(data, (struct sockaddr *)&amp;data_addr.si_su, &amp;len) == -1) {</a>
<a name="ln1572">		warn(&quot;getsockname&quot;);</a>
<a name="ln1573">		goto bad;</a>
<a name="ln1574">	}</a>
<a name="ln1575">	data_addr.su_len = len;</a>
<a name="ln1576">	if (xlisten(data, 1) &lt; 0)</a>
<a name="ln1577">		warn(&quot;listen&quot;);</a>
<a name="ln1578"> </a>
<a name="ln1579">	if (sendport) {</a>
<a name="ln1580">		char hname[NI_MAXHOST], sname[NI_MAXSERV];</a>
<a name="ln1581">		int af;</a>
<a name="ln1582">		struct sockinet tmp;</a>
<a name="ln1583"> </a>
<a name="ln1584">		switch (data_addr.su_family) {</a>
<a name="ln1585">		case AF_INET:</a>
<a name="ln1586">			if (!epsv4 || epsv4bad) {</a>
<a name="ln1587">				result = COMPLETE + 1;</a>
<a name="ln1588">				break;</a>
<a name="ln1589">			}</a>
<a name="ln1590">			/* FALLTHROUGH */</a>
<a name="ln1591">#ifdef INET6</a>
<a name="ln1592">		case AF_INET6:</a>
<a name="ln1593">#endif</a>
<a name="ln1594">			af = (data_addr.su_family == AF_INET) ? 1 : 2;</a>
<a name="ln1595">			tmp = data_addr;</a>
<a name="ln1596">#ifdef INET6</a>
<a name="ln1597">			if (tmp.su_family == AF_INET6)</a>
<a name="ln1598">				tmp.si_su.su_sin6.sin6_scope_id = 0;</a>
<a name="ln1599">#endif</a>
<a name="ln1600">			if (getnameinfo((struct sockaddr *)&amp;tmp.si_su,</a>
<a name="ln1601">			    tmp.su_len, hname, sizeof(hname), sname,</a>
<a name="ln1602">			    sizeof(sname), NI_NUMERICHOST | NI_NUMERICSERV)) {</a>
<a name="ln1603">				result = ERROR;</a>
<a name="ln1604">			} else {</a>
<a name="ln1605">				result = command(&quot;EPRT |%d|%s|%s|&quot;, af, hname,</a>
<a name="ln1606">				    sname);</a>
<a name="ln1607">				if (!connected)</a>
<a name="ln1608">					return (1);</a>
<a name="ln1609">				if (result != COMPLETE) {</a>
<a name="ln1610">					epsv4bad = 1;</a>
<a name="ln1611">					if (debug)</a>
<a name="ln1612">						fputs(</a>
<a name="ln1613">					&quot;disabling epsv4 for this connection\n&quot;,</a>
<a name="ln1614">						    ttyout);</a>
<a name="ln1615">				}</a>
<a name="ln1616">			}</a>
<a name="ln1617">			break;</a>
<a name="ln1618">		default:</a>
<a name="ln1619">			result = COMPLETE + 1;</a>
<a name="ln1620">			break;</a>
<a name="ln1621">		}</a>
<a name="ln1622">		if (result == COMPLETE)</a>
<a name="ln1623">			goto skip_port;</a>
<a name="ln1624"> </a>
<a name="ln1625">		switch (data_addr.su_family) {</a>
<a name="ln1626">		case AF_INET:</a>
<a name="ln1627">			a = (char *)&amp;data_addr.si_su.su_sin.sin_addr;</a>
<a name="ln1628">			p = (char *)&amp;data_addr.su_port;</a>
<a name="ln1629">			result = command(&quot;PORT %d,%d,%d,%d,%d,%d&quot;,</a>
<a name="ln1630">				 UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),</a>
<a name="ln1631">				 UC(p[0]), UC(p[1]));</a>
<a name="ln1632">			break;</a>
<a name="ln1633">#ifdef INET6</a>
<a name="ln1634">		case AF_INET6:</a>
<a name="ln1635">			a = (char *)&amp;data_addr.si_su.su_sin6.sin6_addr;</a>
<a name="ln1636">			p = (char *)&amp;data_addr.su_port;</a>
<a name="ln1637">			result = command(</a>
<a name="ln1638">	&quot;LPRT %d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d&quot;,</a>
<a name="ln1639">				 6, 16,</a>
<a name="ln1640">				 UC(a[0]),UC(a[1]),UC(a[2]),UC(a[3]),</a>
<a name="ln1641">				 UC(a[4]),UC(a[5]),UC(a[6]),UC(a[7]),</a>
<a name="ln1642">				 UC(a[8]),UC(a[9]),UC(a[10]),UC(a[11]),</a>
<a name="ln1643">				 UC(a[12]),UC(a[13]),UC(a[14]),UC(a[15]),</a>
<a name="ln1644">				 2, UC(p[0]), UC(p[1]));</a>
<a name="ln1645">			break;</a>
<a name="ln1646">#endif</a>
<a name="ln1647">		default:</a>
<a name="ln1648">			result = COMPLETE + 1; /* xxx */</a>
<a name="ln1649">		}</a>
<a name="ln1650">		if (!connected)</a>
<a name="ln1651">			return (1);</a>
<a name="ln1652">	skip_port:</a>
<a name="ln1653"> </a>
<a name="ln1654">		if (result == ERROR &amp;&amp; sendport == -1) {</a>
<a name="ln1655">			sendport = 0;</a>
<a name="ln1656">			tmpno = 1;</a>
<a name="ln1657">			goto noport;</a>
<a name="ln1658">		}</a>
<a name="ln1659">		return (result != COMPLETE);</a>
<a name="ln1660">	}</a>
<a name="ln1661">	if (tmpno)</a>
<a name="ln1662">		sendport = 1;</a>
<a name="ln1663">#ifdef IPTOS_THROUGHPUT</a>
<a name="ln1664">	if (data_addr.su_family == AF_INET) {</a>
<a name="ln1665">		on = IPTOS_THROUGHPUT;</a>
<a name="ln1666">		if (setsockopt(data, IPPROTO_IP, IP_TOS,</a>
<a name="ln1667">				(void *)&amp;on, sizeof(on)) == -1)</a>
<a name="ln1668">			if (debug)</a>
<a name="ln1669">				warn(&quot;setsockopt %s (ignored)&quot;,</a>
<a name="ln1670">				    &quot;IPTOS_THROUGHPUT&quot;);</a>
<a name="ln1671">	}</a>
<a name="ln1672">#endif</a>
<a name="ln1673">	return (0);</a>
<a name="ln1674"> bad:</a>
<a name="ln1675">	(void)close(data);</a>
<a name="ln1676">	data = -1;</a>
<a name="ln1677">	if (tmpno)</a>
<a name="ln1678">		sendport = 1;</a>
<a name="ln1679">	return (1);</a>
<a name="ln1680">}</a>
<a name="ln1681"> </a>
<a name="ln1682">FILE *</a>
<a name="ln1683">dataconn(const char *lmode)</a>
<a name="ln1684">{</a>
<a name="ln1685">	struct sockinet	from;</a>
<a name="ln1686">	int		s, flags, rv, timeout;</a>
<a name="ln1687">	struct timeval	endtime, now, td;</a>
<a name="ln1688">	struct pollfd	pfd[1];</a>
<a name="ln1689">	socklen_t	fromlen;</a>
<a name="ln1690"> </a>
<a name="ln1691">	if (passivemode)	/* passive data connection */</a>
<a name="ln1692">		return (fdopen(data, lmode));</a>
<a name="ln1693"> </a>
<a name="ln1694">				/* active mode data connection */</a>
<a name="ln1695"> </a>
<a name="ln1696">	if ((flags = fcntl(data, F_GETFL, 0)) == -1)</a>
<a name="ln1697">		goto dataconn_failed;		/* get current socket flags  */</a>
<a name="ln1698">	if (fcntl(data, F_SETFL, flags | O_NONBLOCK) == -1)</a>
<a name="ln1699">		goto dataconn_failed;		/* set non-blocking connect */</a>
<a name="ln1700"> </a>
<a name="ln1701">		/* NOTE: we now must restore socket flags on successful exit */</a>
<a name="ln1702"> </a>
<a name="ln1703">				/* limit time waiting on listening socket */</a>
<a name="ln1704">	pfd[0].fd = data;</a>
<a name="ln1705">	pfd[0].events = POLLIN;</a>
<a name="ln1706">	(void)gettimeofday(&amp;endtime, NULL);	/* determine end time */</a>
<a name="ln1707">	endtime.tv_sec += (quit_time &gt; 0) ? quit_time: 60;</a>
<a name="ln1708">						/* without -q, default to 60s */</a>
<a name="ln1709">	do {</a>
<a name="ln1710">		(void)gettimeofday(&amp;now, NULL);</a>
<a name="ln1711">		timersub(&amp;endtime, &amp;now, &amp;td);</a>
<a name="ln1712">		timeout = td.tv_sec * 1000 + td.tv_usec/1000;</a>
<a name="ln1713">		if (timeout &lt; 0)</a>
<a name="ln1714">			timeout = 0;</a>
<a name="ln1715">		rv = xpoll(pfd, 1, timeout);</a>
<a name="ln1716">	} while (rv == -1 &amp;&amp; errno == EINTR);	/* loop until poll ! EINTR */</a>
<a name="ln1717">	if (rv == -1) {</a>
<a name="ln1718">		warn(&quot;poll waiting before accept&quot;);</a>
<a name="ln1719">		goto dataconn_failed;</a>
<a name="ln1720">	}</a>
<a name="ln1721">	if (rv == 0) {</a>
<a name="ln1722">		warn(&quot;poll timeout waiting before accept&quot;);</a>
<a name="ln1723">		goto dataconn_failed;</a>
<a name="ln1724">	}</a>
<a name="ln1725"> </a>
<a name="ln1726">				/* (non-blocking) accept the connection */</a>
<a name="ln1727">	fromlen = myctladdr.su_len;</a>
<a name="ln1728">	do {</a>
<a name="ln1729">		s = accept(data, (struct sockaddr *) &amp;from.si_su, &amp;fromlen);</a>
<a name="ln1730">	} while (s == -1 &amp;&amp; errno == EINTR);	/* loop until accept ! EINTR */</a>
<a name="ln1731">	if (s == -1) {</a>
<a name="ln1732">		warn(&quot;accept&quot;);</a>
<a name="ln1733">		goto dataconn_failed;</a>
<a name="ln1734">	}</a>
<a name="ln1735"> </a>
<a name="ln1736">	(void)close(data);</a>
<a name="ln1737">	data = s;</a>
<a name="ln1738">	if (fcntl(data, F_SETFL, flags) == -1)	/* restore socket flags */</a>
<a name="ln1739">		goto dataconn_failed;</a>
<a name="ln1740"> </a>
<a name="ln1741">#ifdef IPTOS_THROUGHPUT</a>
<a name="ln1742">	if (from.su_family == AF_INET) {</a>
<a name="ln1743">		int tos = IPTOS_THROUGHPUT;</a>
<a name="ln1744">		if (setsockopt(s, IPPROTO_IP, IP_TOS,</a>
<a name="ln1745">				(void *)&amp;tos, sizeof(tos)) == -1) {</a>
<a name="ln1746">			if (debug)</a>
<a name="ln1747">				warn(&quot;setsockopt %s (ignored)&quot;,</a>
<a name="ln1748">				    &quot;IPTOS_THROUGHPUT&quot;);</a>
<a name="ln1749">		}</a>
<a name="ln1750">	}</a>
<a name="ln1751">#endif</a>
<a name="ln1752">	return (fdopen(data, lmode));</a>
<a name="ln1753"> </a>
<a name="ln1754"> dataconn_failed:</a>
<a name="ln1755">	(void)close(data);</a>
<a name="ln1756">	data = -1;</a>
<a name="ln1757">	return (NULL);</a>
<a name="ln1758">}</a>
<a name="ln1759"> </a>
<a name="ln1760">void</a>
<a name="ln1761">psabort(int notused)</a>
<a name="ln1762">{</a>
<a name="ln1763">	int oerrno = errno;</a>
<a name="ln1764"> </a>
<a name="ln1765">	sigint_raised = 1;</a>
<a name="ln1766">	alarmtimer(0);</a>
<a name="ln1767">	abrtflag++;</a>
<a name="ln1768">	errno = oerrno;</a>
<a name="ln1769">}</a>
<a name="ln1770"> </a>
<a name="ln1771">void</a>
<a name="ln1772">pswitch(int flag)</a>
<a name="ln1773">{</a>
<a name="ln1774">	sigfunc oldintr;</a>
<a name="ln1775">	static struct comvars {</a>
<a name="ln1776">		int connect;</a>
<a name="ln1777">		char name[MAXHOSTNAMELEN];</a>
<a name="ln1778">		struct sockinet mctl;</a>
<a name="ln1779">		struct sockinet hctl;</a>
<a name="ln1780">		FILE *in;</a>
<a name="ln1781">		FILE *out;</a>
<a name="ln1782">		int tpe;</a>
<a name="ln1783">		int curtpe;</a>
<a name="ln1784">		int cpnd;</a>
<a name="ln1785">		int sunqe;</a>
<a name="ln1786">		int runqe;</a>
<a name="ln1787">		int mcse;</a>
<a name="ln1788">		int ntflg;</a>
<a name="ln1789">		char nti[17];</a>
<a name="ln1790">		char nto[17];</a>
<a name="ln1791">		int mapflg;</a>
<a name="ln1792">		char mi[MAXPATHLEN];</a>
<a name="ln1793">		char mo[MAXPATHLEN];</a>
<a name="ln1794">	} proxstruct, tmpstruct;</a>
<a name="ln1795">	struct comvars *ip, *op;</a>
<a name="ln1796"> </a>
<a name="ln1797">	abrtflag = 0;</a>
<a name="ln1798">	oldintr = xsignal(SIGINT, psabort);</a>
<a name="ln1799">	if (flag) {</a>
<a name="ln1800">		if (proxy)</a>
<a name="ln1801">			return;</a>
<a name="ln1802">		ip = &amp;tmpstruct;</a>
<a name="ln1803">		op = &amp;proxstruct;</a>
<a name="ln1804">		proxy++;</a>
<a name="ln1805">	} else {</a>
<a name="ln1806">		if (!proxy)</a>
<a name="ln1807">			return;</a>
<a name="ln1808">		ip = &amp;proxstruct;</a>
<a name="ln1809">		op = &amp;tmpstruct;</a>
<a name="ln1810">		proxy = 0;</a>
<a name="ln1811">	}</a>
<a name="ln1812">	ip-&gt;connect = connected;</a>
<a name="ln1813">	connected = op-&gt;connect;</a>
<a name="ln1814">	if (hostname)</a>
<a name="ln1815">		(void)strlcpy(ip-&gt;name, hostname, sizeof(ip-&gt;name));</a>
<a name="ln1816">	else</a>
<a name="ln1817">		ip-&gt;name[0] = '\0';</a>
<a name="ln1818">	hostname = op-&gt;name;</a>
<a name="ln1819">	ip-&gt;hctl = hisctladdr;</a>
<a name="ln1820">	hisctladdr = op-&gt;hctl;</a>
<a name="ln1821">	ip-&gt;mctl = myctladdr;</a>
<a name="ln1822">	myctladdr = op-&gt;mctl;</a>
<a name="ln1823">	ip-&gt;in = cin;</a>
<a name="ln1824">	cin = op-&gt;in;</a>
<a name="ln1825">	ip-&gt;out = cout;</a>
<a name="ln1826">	cout = op-&gt;out;</a>
<a name="ln1827">	ip-&gt;tpe = type;</a>
<a name="ln1828">	type = op-&gt;tpe;</a>
<a name="ln1829">	ip-&gt;curtpe = curtype;</a>
<a name="ln1830">	curtype = op-&gt;curtpe;</a>
<a name="ln1831">	ip-&gt;cpnd = cpend;</a>
<a name="ln1832">	cpend = op-&gt;cpnd;</a>
<a name="ln1833">	ip-&gt;sunqe = sunique;</a>
<a name="ln1834">	sunique = op-&gt;sunqe;</a>
<a name="ln1835">	ip-&gt;runqe = runique;</a>
<a name="ln1836">	runique = op-&gt;runqe;</a>
<a name="ln1837">	ip-&gt;mcse = mcase;</a>
<a name="ln1838">	mcase = op-&gt;mcse;</a>
<a name="ln1839">	ip-&gt;ntflg = ntflag;</a>
<a name="ln1840">	ntflag = op-&gt;ntflg;</a>
<a name="ln1841">	(void)strlcpy(ip-&gt;nti, ntin, sizeof(ip-&gt;nti));</a>
<a name="ln1842">	(void)strlcpy(ntin, op-&gt;nti, sizeof(ntin));</a>
<a name="ln1843">	(void)strlcpy(ip-&gt;nto, ntout, sizeof(ip-&gt;nto));</a>
<a name="ln1844">	(void)strlcpy(ntout, op-&gt;nto, sizeof(ntout));</a>
<a name="ln1845">	ip-&gt;mapflg = mapflag;</a>
<a name="ln1846">	mapflag = op-&gt;mapflg;</a>
<a name="ln1847">	(void)strlcpy(ip-&gt;mi, mapin, sizeof(ip-&gt;mi));</a>
<a name="ln1848">	(void)strlcpy(mapin, op-&gt;mi, sizeof(mapin));</a>
<a name="ln1849">	(void)strlcpy(ip-&gt;mo, mapout, sizeof(ip-&gt;mo));</a>
<a name="ln1850">	(void)strlcpy(mapout, op-&gt;mo, sizeof(mapout));</a>
<a name="ln1851">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1852">	if (abrtflag) {</a>
<a name="ln1853">		abrtflag = 0;</a>
<a name="ln1854">		(*oldintr)(SIGINT);</a>
<a name="ln1855">	}</a>
<a name="ln1856">}</a>
<a name="ln1857"> </a>
<a name="ln1858">void</a>
<a name="ln1859">abortpt(int notused)</a>
<a name="ln1860">{</a>
<a name="ln1861"> </a>
<a name="ln1862">	sigint_raised = 1;</a>
<a name="ln1863">	alarmtimer(0);</a>
<a name="ln1864">	if (fromatty)</a>
<a name="ln1865">		write(fileno(ttyout), &quot;\n&quot;, 1);</a>
<a name="ln1866">	ptabflg++;</a>
<a name="ln1867">	mflag = 0;</a>
<a name="ln1868">	abrtflag = 0;</a>
<a name="ln1869">	siglongjmp(ptabort, 1);</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872">void</a>
<a name="ln1873">proxtrans(const char *cmd, const char *local, const char *remote)</a>
<a name="ln1874">{</a>
<a name="ln1875">	sigfunc oldintr;</a>
<a name="ln1876">	int prox_type, nfnd;</a>
<a name="ln1877">	volatile int secndflag;</a>
<a name="ln1878">	char *cmd2;</a>
<a name="ln1879"> </a>
<a name="ln1880">#ifdef __GNUC__			/* to shut up gcc warnings */</a>
<a name="ln1881">	(void)&amp;oldintr;</a>
<a name="ln1882">	(void)&amp;cmd2;</a>
<a name="ln1883">#endif</a>
<a name="ln1884"> </a>
<a name="ln1885">	oldintr = NULL;</a>
<a name="ln1886">	secndflag = 0;</a>
<a name="ln1887">	if (strcmp(cmd, &quot;RETR&quot;))</a>
<a name="ln1888">		cmd2 = &quot;RETR&quot;;</a>
<a name="ln1889">	else</a>
<a name="ln1890">		cmd2 = runique ? &quot;STOU&quot; : &quot;STOR&quot;;</a>
<a name="ln1891">	if ((prox_type = type) == 0) {</a>
<a name="ln1892">		if (unix_server &amp;&amp; unix_proxy)</a>
<a name="ln1893">			prox_type = TYPE_I;</a>
<a name="ln1894">		else</a>
<a name="ln1895">			prox_type = TYPE_A;</a>
<a name="ln1896">	}</a>
<a name="ln1897">	if (curtype != prox_type)</a>
<a name="ln1898">		changetype(prox_type, 1);</a>
<a name="ln1899">	if (command(&quot;PASV&quot;) != COMPLETE) {</a>
<a name="ln1900">		fputs(&quot;proxy server does not support third party transfers.\n&quot;,</a>
<a name="ln1901">		    ttyout);</a>
<a name="ln1902">		return;</a>
<a name="ln1903">	}</a>
<a name="ln1904">	pswitch(0);</a>
<a name="ln1905">	if (!connected) {</a>
<a name="ln1906">		fputs(&quot;No primary connection.\n&quot;, ttyout);</a>
<a name="ln1907">		pswitch(1);</a>
<a name="ln1908">		code = -1;</a>
<a name="ln1909">		return;</a>
<a name="ln1910">	}</a>
<a name="ln1911">	if (curtype != prox_type)</a>
<a name="ln1912">		changetype(prox_type, 1);</a>
<a name="ln1913">	if (command(&quot;PORT %s&quot;, pasv) != COMPLETE) {</a>
<a name="ln1914">		pswitch(1);</a>
<a name="ln1915">		return;</a>
<a name="ln1916">	}</a>
<a name="ln1917">	if (sigsetjmp(ptabort, 1))</a>
<a name="ln1918">		goto abort;</a>
<a name="ln1919">	oldintr = xsignal(SIGINT, abortpt);</a>
<a name="ln1920">	if ((restart_point &amp;&amp;</a>
<a name="ln1921">	    (command(&quot;REST &quot; LLF, (LLT) restart_point) != CONTINUE))</a>
<a name="ln1922">	    || (command(&quot;%s %s&quot;, cmd, remote) != PRELIM)) {</a>
<a name="ln1923">		(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1924">		pswitch(1);</a>
<a name="ln1925">		return;</a>
<a name="ln1926">	}</a>
<a name="ln1927">	sleep(2);</a>
<a name="ln1928">	pswitch(1);</a>
<a name="ln1929">	secndflag++;</a>
<a name="ln1930">	if ((restart_point &amp;&amp;</a>
<a name="ln1931">	    (command(&quot;REST &quot; LLF, (LLT) restart_point) != CONTINUE))</a>
<a name="ln1932">	    || (command(&quot;%s %s&quot;, cmd2, local) != PRELIM))</a>
<a name="ln1933">		goto abort;</a>
<a name="ln1934">	ptflag++;</a>
<a name="ln1935">	(void)getreply(0);</a>
<a name="ln1936">	pswitch(0);</a>
<a name="ln1937">	(void)getreply(0);</a>
<a name="ln1938">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1939">	pswitch(1);</a>
<a name="ln1940">	ptflag = 0;</a>
<a name="ln1941">	fprintf(ttyout, &quot;local: %s remote: %s\n&quot;, local, remote);</a>
<a name="ln1942">	return;</a>
<a name="ln1943"> abort:</a>
<a name="ln1944">	if (sigsetjmp(xferabort, 1)) {</a>
<a name="ln1945">		(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1946">		return;</a>
<a name="ln1947">	}</a>
<a name="ln1948">	(void)xsignal(SIGINT, abort_squared);</a>
<a name="ln1949">	ptflag = 0;</a>
<a name="ln1950">	if (strcmp(cmd, &quot;RETR&quot;) &amp;&amp; !proxy)</a>
<a name="ln1951">		pswitch(1);</a>
<a name="ln1952">	else if (!strcmp(cmd, &quot;RETR&quot;) &amp;&amp; proxy)</a>
<a name="ln1953">		pswitch(0);</a>
<a name="ln1954">	if (!cpend &amp;&amp; !secndflag) {  /* only here if cmd = &quot;STOR&quot; (proxy=1) */</a>
<a name="ln1955">		if (command(&quot;%s %s&quot;, cmd2, local) != PRELIM) {</a>
<a name="ln1956">			pswitch(0);</a>
<a name="ln1957">			if (cpend)</a>
<a name="ln1958">				abort_remote(NULL);</a>
<a name="ln1959">		}</a>
<a name="ln1960">		pswitch(1);</a>
<a name="ln1961">		if (ptabflg)</a>
<a name="ln1962">			code = -1;</a>
<a name="ln1963">		(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1964">		return;</a>
<a name="ln1965">	}</a>
<a name="ln1966">	if (cpend)</a>
<a name="ln1967">		abort_remote(NULL);</a>
<a name="ln1968">	pswitch(!proxy);</a>
<a name="ln1969">	if (!cpend &amp;&amp; !secndflag) {  /* only if cmd = &quot;RETR&quot; (proxy=1) */</a>
<a name="ln1970">		if (command(&quot;%s %s&quot;, cmd2, local) != PRELIM) {</a>
<a name="ln1971">			pswitch(0);</a>
<a name="ln1972">			if (cpend)</a>
<a name="ln1973">				abort_remote(NULL);</a>
<a name="ln1974">			pswitch(1);</a>
<a name="ln1975">			if (ptabflg)</a>
<a name="ln1976">				code = -1;</a>
<a name="ln1977">			(void)xsignal(SIGINT, oldintr);</a>
<a name="ln1978">			return;</a>
<a name="ln1979">		}</a>
<a name="ln1980">	}</a>
<a name="ln1981">	if (cpend)</a>
<a name="ln1982">		abort_remote(NULL);</a>
<a name="ln1983">	pswitch(!proxy);</a>
<a name="ln1984">	if (cpend) {</a>
<a name="ln1985">		if ((nfnd = empty(cin, NULL, 10)) &lt;= 0) {</a>
<a name="ln1986">			if (nfnd &lt; 0)</a>
<a name="ln1987">				warn(&quot;abort&quot;);</a>
<a name="ln1988">			if (ptabflg)</a>
<a name="ln1989">				code = -1;</a>
<a name="ln1990">			lostpeer(0);</a>
<a name="ln1991">		}</a>
<a name="ln1992">		(void)getreply(0);</a>
<a name="ln1993">		(void)getreply(0);</a>
<a name="ln1994">	}</a>
<a name="ln1995">	if (proxy)</a>
<a name="ln1996">		pswitch(0);</a>
<a name="ln1997">	pswitch(1);</a>
<a name="ln1998">	if (ptabflg)</a>
<a name="ln1999">		code = -1;</a>
<a name="ln2000">	(void)xsignal(SIGINT, oldintr);</a>
<a name="ln2001">}</a>
<a name="ln2002"> </a>
<a name="ln2003">void</a>
<a name="ln2004">reset(int argc, char *argv[])</a>
<a name="ln2005">{</a>
<a name="ln2006">	int nfnd = 1;</a>
<a name="ln2007"> </a>
<a name="ln2008">	if (argc == 0 &amp;&amp; argv != NULL) {</a>
<a name="ln2009">		fprintf(ttyout, &quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln2010">		code = -1;</a>
<a name="ln2011">		return;</a>
<a name="ln2012">	}</a>
<a name="ln2013">	while (nfnd &gt; 0) {</a>
<a name="ln2014">		if ((nfnd = empty(cin, NULL, 0)) &lt; 0) {</a>
<a name="ln2015">			warn(&quot;reset&quot;);</a>
<a name="ln2016">			code = -1;</a>
<a name="ln2017">			lostpeer(0);</a>
<a name="ln2018">		} else if (nfnd)</a>
<a name="ln2019">			(void)getreply(0);</a>
<a name="ln2020">	}</a>
<a name="ln2021">}</a>
<a name="ln2022"> </a>
<a name="ln2023">char *</a>
<a name="ln2024">gunique(const char *local)</a>
<a name="ln2025">{</a>
<a name="ln2026">	static char new[MAXPATHLEN];</a>
<a name="ln2027">	char *cp = strrchr(local, '/');</a>
<a name="ln2028">	int d, count=0, len;</a>
<a name="ln2029">	char ext = '1';</a>
<a name="ln2030"> </a>
<a name="ln2031">	if (cp)</a>
<a name="ln2032">		*cp = '\0';</a>
<a name="ln2033">	d = access(cp == local ? &quot;/&quot; : cp ? local : &quot;.&quot;, W_OK);</a>
<a name="ln2034">	if (cp)</a>
<a name="ln2035">		*cp = '/';</a>
<a name="ln2036">	if (d &lt; 0) {</a>
<a name="ln2037">		warn(&quot;local: %s&quot;, local);</a>
<a name="ln2038">		return (NULL);</a>
<a name="ln2039">	}</a>
<a name="ln2040">	len = strlcpy(new, local, sizeof(new));</a>
<a name="ln2041">	cp = &amp;new[len];</a>
<a name="ln2042">	*cp++ = '.';</a>
<a name="ln2043">	while (!d) {</a>
<a name="ln2044">		if (++count == 100) {</a>
<a name="ln2045">			fputs(&quot;runique: can't find unique file name.\n&quot;,</a>
<a name="ln2046">			    ttyout);</a>
<a name="ln2047">			return (NULL);</a>
<a name="ln2048">		}</a>
<a name="ln2049">		*cp++ = ext;</a>
<a name="ln2050">		*cp = '\0';</a>
<a name="ln2051">		if (ext == '9')</a>
<a name="ln2052">			ext = '0';</a>
<a name="ln2053">		else</a>
<a name="ln2054">			ext++;</a>
<a name="ln2055">		if ((d = access(new, F_OK)) &lt; 0)</a>
<a name="ln2056">			break;</a>
<a name="ln2057">		if (ext != '0')</a>
<a name="ln2058">			cp--;</a>
<a name="ln2059">		else if (*(cp - 2) == '.')</a>
<a name="ln2060">			*(cp - 1) = '1';</a>
<a name="ln2061">		else {</a>
<a name="ln2062">			*(cp - 2) = *(cp - 2) + 1;</a>
<a name="ln2063">			cp--;</a>
<a name="ln2064">		}</a>
<a name="ln2065">	}</a>
<a name="ln2066">	return (new);</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">/*</a>
<a name="ln2070"> * abort_squared --</a>
<a name="ln2071"> *	aborts abort_remote(). lostpeer() is called because if the user is</a>
<a name="ln2072"> *	too impatient to wait or there's another problem then ftp really</a>
<a name="ln2073"> *	needs to get back to a known state.</a>
<a name="ln2074"> */</a>
<a name="ln2075">void</a>
<a name="ln2076">abort_squared(int dummy)</a>
<a name="ln2077">{</a>
<a name="ln2078">	char msgbuf[100];</a>
<a name="ln2079">	size_t len;</a>
<a name="ln2080"> </a>
<a name="ln2081">	sigint_raised = 1;</a>
<a name="ln2082">	alarmtimer(0);</a>
<a name="ln2083">	len = strlcpy(msgbuf, &quot;\nremote abort aborted; closing connection.\n&quot;,</a>
<a name="ln2084">	    sizeof(msgbuf));</a>
<a name="ln2085">	write(fileno(ttyout), msgbuf, len);</a>
<a name="ln2086">	lostpeer(0);</a>
<a name="ln2087">	siglongjmp(xferabort, 1);</a>
<a name="ln2088">}</a>
<a name="ln2089"> </a>
<a name="ln2090">void</a>
<a name="ln2091">abort_remote(FILE *din)</a>
<a name="ln2092">{</a>
<a name="ln2093">	char buf[BUFSIZ];</a>
<a name="ln2094">	int nfnd;</a>
<a name="ln2095"> </a>
<a name="ln2096">	if (cout == NULL) {</a>
<a name="ln2097">		warnx(&quot;Lost control connection for abort.&quot;);</a>
<a name="ln2098">		if (ptabflg)</a>
<a name="ln2099">			code = -1;</a>
<a name="ln2100">		lostpeer(0);</a>
<a name="ln2101">		return;</a>
<a name="ln2102">	}</a>
<a name="ln2103">	/*</a>
<a name="ln2104">	 * send IAC in urgent mode instead of DM because 4.3BSD places oob mark</a>
<a name="ln2105">	 * after urgent byte rather than before as is protocol now</a>
<a name="ln2106">	 */</a>
<a name="ln2107">	buf[0] = IAC;</a>
<a name="ln2108">	buf[1] = IP;</a>
<a name="ln2109">	buf[2] = IAC;</a>
<a name="ln2110">	if (send(fileno(cout), buf, 3, MSG_OOB) != 3)</a>
<a name="ln2111">		warn(&quot;abort&quot;);</a>
<a name="ln2112">	fprintf(cout, &quot;%cABOR\r\n&quot;, DM);</a>
<a name="ln2113">	(void)fflush(cout);</a>
<a name="ln2114">	if ((nfnd = empty(cin, din, 10)) &lt;= 0) {</a>
<a name="ln2115">		if (nfnd &lt; 0)</a>
<a name="ln2116">			warn(&quot;abort&quot;);</a>
<a name="ln2117">		if (ptabflg)</a>
<a name="ln2118">			code = -1;</a>
<a name="ln2119">		lostpeer(0);</a>
<a name="ln2120">	}</a>
<a name="ln2121">	if (din &amp;&amp; (nfnd &amp; 2)) {</a>
<a name="ln2122">		while (read(fileno(din), buf, BUFSIZ) &gt; 0)</a>
<a name="ln2123">			continue;</a>
<a name="ln2124">	}</a>
<a name="ln2125">	if (getreply(0) == ERROR &amp;&amp; code == 552) {</a>
<a name="ln2126">		/* 552 needed for nic style abort */</a>
<a name="ln2127">		(void)getreply(0);</a>
<a name="ln2128">	}</a>
<a name="ln2129">	(void)getreply(0);</a>
<a name="ln2130">}</a>
<a name="ln2131"> </a>
<a name="ln2132">void</a>
<a name="ln2133">ai_unmapped(struct addrinfo *ai)</a>
<a name="ln2134">{</a>
<a name="ln2135">#ifdef INET6</a>
<a name="ln2136">	struct sockaddr_in6 *sin6;</a>
<a name="ln2137">	struct sockaddr_in sin;</a>
<a name="ln2138">	socklen_t len;</a>
<a name="ln2139"> </a>
<a name="ln2140">	if (ai-&gt;ai_family != AF_INET6)</a>
<a name="ln2141">		return;</a>
<a name="ln2142">	if (ai-&gt;ai_addrlen != sizeof(struct sockaddr_in6) ||</a>
<a name="ln2143">	    sizeof(sin) &gt; ai-&gt;ai_addrlen)</a>
<a name="ln2144">		return;</a>
<a name="ln2145">	sin6 = (struct sockaddr_in6 *)ai-&gt;ai_addr;</a>
<a name="ln2146">	if (!IN6_IS_ADDR_V4MAPPED(&amp;sin6-&gt;sin6_addr))</a>
<a name="ln2147">		return;</a>
<a name="ln2148"> </a>
<a name="ln2149">	memset(&amp;sin, 0, sizeof(sin));</a>
<a name="ln2150">	sin.sin_family = AF_INET;</a>
<a name="ln2151">	len = sizeof(struct sockaddr_in);</a>
<a name="ln2152">	memcpy(&amp;sin.sin_addr, &amp;sin6-&gt;sin6_addr.s6_addr[12],</a>
<a name="ln2153">	    sizeof(sin.sin_addr));</a>
<a name="ln2154">	sin.sin_port = sin6-&gt;sin6_port;</a>
<a name="ln2155"> </a>
<a name="ln2156">	ai-&gt;ai_family = AF_INET;</a>
<a name="ln2157">#if HAVE_SOCKADDR_SA_LEN</a>
<a name="ln2158">	sin.sin_len = len;</a>
<a name="ln2159">#endif</a>
<a name="ln2160">	memcpy(ai-&gt;ai_addr, &amp;sin, len);</a>
<a name="ln2161">	ai-&gt;ai_addrlen = len;</a>
<a name="ln2162">#endif</a>
<a name="ln2163">}</a>

</code></pre>
<div class="balloon" rel="1594"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'data_addr.si_su.su_sin.sin_family == 1' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
