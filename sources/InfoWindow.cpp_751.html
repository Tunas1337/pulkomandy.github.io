
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>InfoWindow.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;InfoWindow.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;string.h&gt;</a>
<a name="ln39">#include &lt;stdio.h&gt;</a>
<a name="ln40">#include &lt;stdlib.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;Alert.h&gt;</a>
<a name="ln43">#include &lt;Catalog.h&gt;</a>
<a name="ln44">#include &lt;Debug.h&gt;</a>
<a name="ln45">#include &lt;Directory.h&gt;</a>
<a name="ln46">#include &lt;File.h&gt;</a>
<a name="ln47">#include &lt;Font.h&gt;</a>
<a name="ln48">#include &lt;Locale.h&gt;</a>
<a name="ln49">#include &lt;MenuField.h&gt;</a>
<a name="ln50">#include &lt;Mime.h&gt;</a>
<a name="ln51">#include &lt;NodeInfo.h&gt;</a>
<a name="ln52">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln53">#include &lt;Path.h&gt;</a>
<a name="ln54">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln55">#include &lt;Region.h&gt;</a>
<a name="ln56">#include &lt;Roster.h&gt;</a>
<a name="ln57">#include &lt;Screen.h&gt;</a>
<a name="ln58">#include &lt;ScrollView.h&gt;</a>
<a name="ln59">#include &lt;StringFormat.h&gt;</a>
<a name="ln60">#include &lt;SymLink.h&gt;</a>
<a name="ln61">#include &lt;TextView.h&gt;</a>
<a name="ln62">#include &lt;Volume.h&gt;</a>
<a name="ln63">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln64"> </a>
<a name="ln65">#include &quot;Attributes.h&quot;</a>
<a name="ln66">#include &quot;AutoLock.h&quot;</a>
<a name="ln67">#include &quot;Commands.h&quot;</a>
<a name="ln68">#include &quot;DialogPane.h&quot;</a>
<a name="ln69">#include &quot;FSUtils.h&quot;</a>
<a name="ln70">#include &quot;IconCache.h&quot;</a>
<a name="ln71">#include &quot;IconMenuItem.h&quot;</a>
<a name="ln72">#include &quot;Model.h&quot;</a>
<a name="ln73">#include &quot;NavMenu.h&quot;</a>
<a name="ln74">#include &quot;PoseView.h&quot;</a>
<a name="ln75">#include &quot;StringForSize.h&quot;</a>
<a name="ln76">#include &quot;Tracker.h&quot;</a>
<a name="ln77">#include &quot;WidgetAttributeText.h&quot;</a>
<a name="ln78"> </a>
<a name="ln79"> </a>
<a name="ln80">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln81">#define B_TRANSLATION_CONTEXT &quot;InfoWindow&quot;</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">namespace BPrivate {</a>
<a name="ln85"> </a>
<a name="ln86">// States for tracking the mouse</a>
<a name="ln87">enum track_state {</a>
<a name="ln88">	no_track = 0,</a>
<a name="ln89">	link_track,</a>
<a name="ln90">	path_track,</a>
<a name="ln91">	icon_track,</a>
<a name="ln92">	size_track,</a>
<a name="ln93">	open_only_track</a>
<a name="ln94">		// This is for items that can be opened, but can't be</a>
<a name="ln95">		// drag and dropped or renamed (Trash, Desktop Folder...)</a>
<a name="ln96">};</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">class TrackingView : public BControl {</a>
<a name="ln100">public:</a>
<a name="ln101">	TrackingView(BRect, const char* str, BMessage* message);</a>
<a name="ln102"> </a>
<a name="ln103">	virtual void MouseDown(BPoint);</a>
<a name="ln104">	virtual void MouseMoved(BPoint where, uint32 transit, const BMessage*);</a>
<a name="ln105">	virtual void MouseUp(BPoint);</a>
<a name="ln106">	virtual void Draw(BRect);</a>
<a name="ln107"> </a>
<a name="ln108">private:</a>
<a name="ln109">	bool fMouseDown;</a>
<a name="ln110">	bool fMouseInView;</a>
<a name="ln111">};</a>
<a name="ln112"> </a>
<a name="ln113"> </a>
<a name="ln114">class AttributeView : public BView {</a>
<a name="ln115">public:</a>
<a name="ln116">	AttributeView(BRect, Model*);</a>
<a name="ln117">	~AttributeView();</a>
<a name="ln118"> </a>
<a name="ln119">	void ModelChanged(Model*, BMessage*);</a>
<a name="ln120">	void ReLinkTargetModel(Model*);</a>
<a name="ln121">	void BeginEditingTitle();</a>
<a name="ln122">	void FinishEditingTitle(bool);</a>
<a name="ln123">	float CurrentFontHeight();</a>
<a name="ln124"> </a>
<a name="ln125">	BTextView* TextView() const { return fTitleEditView; }</a>
<a name="ln126"> </a>
<a name="ln127">	static filter_result TextViewFilter(BMessage*, BHandler**,</a>
<a name="ln128">		BMessageFilter*);</a>
<a name="ln129"> </a>
<a name="ln130">	off_t LastSize() const;</a>
<a name="ln131">	void SetLastSize(off_t);</a>
<a name="ln132"> </a>
<a name="ln133">	void SetSizeString(const char*);</a>
<a name="ln134"> </a>
<a name="ln135">	status_t BuildContextMenu(BMenu* parent);</a>
<a name="ln136"> </a>
<a name="ln137">	void SetPermissionsSwitchState(int32 state);</a>
<a name="ln138"> </a>
<a name="ln139">protected:</a>
<a name="ln140">	virtual void MouseDown(BPoint where);</a>
<a name="ln141">	virtual void MouseMoved(BPoint where, uint32, const BMessage* dragMessage);</a>
<a name="ln142">	virtual void MouseUp(BPoint where);</a>
<a name="ln143">	virtual void MessageReceived(BMessage* message);</a>
<a name="ln144">	virtual void AttachedToWindow();</a>
<a name="ln145">	virtual void Draw(BRect);</a>
<a name="ln146">	virtual void Pulse();</a>
<a name="ln147">	virtual void MakeFocus(bool focus);</a>
<a name="ln148">	virtual void WindowActivated(bool active);</a>
<a name="ln149"> </a>
<a name="ln150">private:</a>
<a name="ln151">	void InitStrings(const Model*);</a>
<a name="ln152">	void CheckAndSetSize();</a>
<a name="ln153">	void OpenLinkSource();</a>
<a name="ln154">	void OpenLinkTarget();</a>
<a name="ln155"> </a>
<a name="ln156">	BString fPathStr;</a>
<a name="ln157">	BString fLinkToStr;</a>
<a name="ln158">	BString fSizeString;</a>
<a name="ln159">	BString fModifiedStr;</a>
<a name="ln160">	BString fCreatedStr;</a>
<a name="ln161">	BString fKindStr;</a>
<a name="ln162">	BString fDescStr;</a>
<a name="ln163"> </a>
<a name="ln164">	off_t fFreeBytes;</a>
<a name="ln165">	off_t fLastSize;</a>
<a name="ln166"> </a>
<a name="ln167">	BRect fPathRect;</a>
<a name="ln168">	BRect fLinkRect;</a>
<a name="ln169">	BRect fDescRect;</a>
<a name="ln170">	BRect fTitleRect;</a>
<a name="ln171">	BRect fIconRect;</a>
<a name="ln172">	BRect fSizeRect;</a>
<a name="ln173">	BPoint fClickPoint;</a>
<a name="ln174">	float fDivider;</a>
<a name="ln175"> </a>
<a name="ln176">	BMenuField* fPreferredAppMenu;</a>
<a name="ln177">	Model* fModel;</a>
<a name="ln178">	Model* fIconModel;</a>
<a name="ln179">	BBitmap* fIcon;</a>
<a name="ln180">	bool fMouseDown;</a>
<a name="ln181">	bool fDragging;</a>
<a name="ln182">	bool fDoubleClick;</a>
<a name="ln183">	track_state fTrackingState;</a>
<a name="ln184">	bool fIsDropTarget;</a>
<a name="ln185">	BTextView* fTitleEditView;</a>
<a name="ln186">	PaneSwitch* fPermissionsSwitch;</a>
<a name="ln187">	BWindow* fPathWindow;</a>
<a name="ln188">	BWindow* fLinkWindow;</a>
<a name="ln189">	BWindow* fDescWindow;</a>
<a name="ln190">	color_which fCurrentLinkColorWhich;</a>
<a name="ln191">	color_which fCurrentPathColorWhich;</a>
<a name="ln192"> </a>
<a name="ln193">	typedef BView _inherited;</a>
<a name="ln194">};</a>
<a name="ln195"> </a>
<a name="ln196">}	// namespace BPrivate</a>
<a name="ln197"> </a>
<a name="ln198"> </a>
<a name="ln199">const float kDrawMargin = 3.0f;</a>
<a name="ln200">const float kBorderMargin = 15.0f;</a>
<a name="ln201">const float kBorderWidth = 32.0f;</a>
<a name="ln202"> </a>
<a name="ln203">// Offsets taken from TAlertView::Draw in BAlert.cpp</a>
<a name="ln204">const float kIconHorizOffset = 18.0f;</a>
<a name="ln205">const float kIconVertOffset = 6.0f;</a>
<a name="ln206"> </a>
<a name="ln207">// Amount you have to move the mouse before a drag starts</a>
<a name="ln208">const float kDragSlop = 3.0f;</a>
<a name="ln209"> </a>
<a name="ln210">const uint32 kSetPreferredApp = 'setp';</a>
<a name="ln211">const uint32 kSelectNewSymTarget = 'snew';</a>
<a name="ln212">const uint32 kNewTargetSelected = 'selc';</a>
<a name="ln213">const uint32 kRecalculateSize = 'resz';</a>
<a name="ln214">const uint32 kSetLinkTarget = 'link';</a>
<a name="ln215">const uint32 kPermissionsSelected = 'sepe';</a>
<a name="ln216">const uint32 kOpenLinkSource = 'opls';</a>
<a name="ln217">const uint32 kOpenLinkTarget = 'oplt';</a>
<a name="ln218"> </a>
<a name="ln219">const uint32 kPaneSwitchClosed = 0;</a>
<a name="ln220">const uint32 kPaneSwitchOpen = 2;</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">static void</a>
<a name="ln224">OpenParentAndSelectOriginal(const entry_ref* ref)</a>
<a name="ln225">{</a>
<a name="ln226">	BEntry entry(ref);</a>
<a name="ln227">	node_ref node;</a>
<a name="ln228">	entry.GetNodeRef(&amp;node);</a>
<a name="ln229"> </a>
<a name="ln230">	BEntry parent;</a>
<a name="ln231">	entry.GetParent(&amp;parent);</a>
<a name="ln232">	entry_ref parentRef;</a>
<a name="ln233">	parent.GetRef(&amp;parentRef);</a>
<a name="ln234"> </a>
<a name="ln235">	BMessage message(B_REFS_RECEIVED);</a>
<a name="ln236">	message.AddRef(&quot;refs&quot;, &amp;parentRef);</a>
<a name="ln237">	message.AddData(&quot;nodeRefToSelect&quot;, B_RAW_TYPE, &amp;node, sizeof(node_ref));</a>
<a name="ln238"> </a>
<a name="ln239">	be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242"> </a>
<a name="ln243">static BWindow*</a>
<a name="ln244">OpenToolTipWindow(BScreen&amp; screen, BRect rect, const char* name,</a>
<a name="ln245">	const char* string, BMessenger target, BMessage* message)</a>
<a name="ln246">{</a>
<a name="ln247">	font_height fontHeight;</a>
<a name="ln248">	be_plain_font-&gt;GetHeight(&amp;fontHeight);</a>
<a name="ln249">	float height = ceilf(fontHeight.ascent + fontHeight.descent);</a>
<a name="ln250">	rect.top = floorf(rect.top + (rect.Height() - height) / 2.0f);</a>
<a name="ln251">	rect.bottom = rect.top + height;</a>
<a name="ln252"> </a>
<a name="ln253">	rect.right = rect.left + ceilf(be_plain_font-&gt;StringWidth(string)) + 4;</a>
<a name="ln254">	if (rect.left &lt; 0)</a>
<a name="ln255">		rect.OffsetBy(-rect.left, 0);</a>
<a name="ln256">	else if (rect.right &gt; screen.Frame().right)</a>
<a name="ln257">		rect.OffsetBy(screen.Frame().right - rect.right, 0);</a>
<a name="ln258"> </a>
<a name="ln259">	BWindow* window = new BWindow(rect, name, B_BORDERED_WINDOW_LOOK,</a>
<a name="ln260">		B_FLOATING_ALL_WINDOW_FEEL,</a>
<a name="ln261">		B_NOT_MOVABLE | B_NOT_CLOSABLE | B_NOT_ZOOMABLE | B_NOT_MINIMIZABLE</a>
<a name="ln262">		| B_NOT_RESIZABLE | B_AVOID_FOCUS | B_NO_WORKSPACE_ACTIVATION</a>
<a name="ln263">		| B_WILL_ACCEPT_FIRST_CLICK | B_ASYNCHRONOUS_CONTROLS);</a>
<a name="ln264"> </a>
<a name="ln265">	TrackingView* trackingView = new TrackingView(window-&gt;Bounds(),</a>
<a name="ln266">		string, message);</a>
<a name="ln267">	trackingView-&gt;SetTarget(target);</a>
<a name="ln268">	window-&gt;AddChild(trackingView);</a>
<a name="ln269"> </a>
<a name="ln270">	window-&gt;Sync();</a>
<a name="ln271">	window-&gt;Show();</a>
<a name="ln272"> </a>
<a name="ln273">	return window;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276"> </a>
<a name="ln277">//	#pragma mark - BInfoWindow</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">BInfoWindow::BInfoWindow(Model* model, int32 group_index,</a>
<a name="ln281">	LockingList&lt;BWindow&gt;* list)</a>
<a name="ln282">	:</a>
<a name="ln283">	BWindow(BInfoWindow::InfoWindowRect(),</a>
<a name="ln284">		&quot;InfoWindow&quot;, B_TITLED_WINDOW,</a>
<a name="ln285">		B_NOT_RESIZABLE | B_NOT_ZOOMABLE, B_CURRENT_WORKSPACE),</a>
<a name="ln286">	fModel(model),</a>
<a name="ln287">	fStopCalc(false),</a>
<a name="ln288">	fIndex(group_index),</a>
<a name="ln289">	fCalcThreadID(-1),</a>
<a name="ln290">	fWindowList(list),</a>
<a name="ln291">	fPermissionsView(NULL),</a>
<a name="ln292">	fFilePanel(NULL),</a>
<a name="ln293">	fFilePanelOpen(false)</a>
<a name="ln294">{</a>
<a name="ln295">	SetPulseRate(1000000);</a>
<a name="ln296">		// we use pulse to check freebytes on volume</a>
<a name="ln297"> </a>
<a name="ln298">	TTracker::WatchNode(model-&gt;NodeRef(), B_WATCH_ALL | B_WATCH_MOUNT, this);</a>
<a name="ln299"> </a>
<a name="ln300">	// window list is Locked by Tracker around this constructor</a>
<a name="ln301">	if (list != NULL)</a>
<a name="ln302">		list-&gt;AddItem(this);</a>
<a name="ln303"> </a>
<a name="ln304">	AddShortcut('E', 0, new BMessage(kEditItem));</a>
<a name="ln305">	AddShortcut('O', 0, new BMessage(kOpenSelection));</a>
<a name="ln306">	AddShortcut('U', 0, new BMessage(kUnmountVolume));</a>
<a name="ln307">	AddShortcut('P', 0, new BMessage(kPermissionsSelected));</a>
<a name="ln308"> </a>
<a name="ln309">	Run();</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312"> </a>
<a name="ln313">BInfoWindow::~BInfoWindow()</a>
<a name="ln314">{</a>
<a name="ln315">	// Check to make sure the file panel is destroyed</a>
<a name="ln316">	delete fFilePanel;</a>
<a name="ln317">	delete fModel;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">BRect</a>
<a name="ln322">BInfoWindow::InfoWindowRect()</a>
<a name="ln323">{</a>
<a name="ln324">	// starting size of window</a>
<a name="ln325">	return BRect(70, 50, 385, 240);</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328"> </a>
<a name="ln329">void</a>
<a name="ln330">BInfoWindow::Quit()</a>
<a name="ln331">{</a>
<a name="ln332">	stop_watching(this);</a>
<a name="ln333"> </a>
<a name="ln334">	if (fWindowList) {</a>
<a name="ln335">		AutoLock&lt;LockingList&lt;BWindow&gt; &gt; lock(fWindowList);</a>
<a name="ln336">		fWindowList-&gt;RemoveItem(this);</a>
<a name="ln337">	}</a>
<a name="ln338"> </a>
<a name="ln339">	fStopCalc = true;</a>
<a name="ln340"> </a>
<a name="ln341">	// wait until CalcSize thread has terminated before closing window</a>
<a name="ln342">	status_t result;</a>
<a name="ln343">	wait_for_thread(fCalcThreadID, &amp;result);</a>
<a name="ln344"> </a>
<a name="ln345">	_inherited::Quit();</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">bool</a>
<a name="ln350">BInfoWindow::IsShowing(const node_ref* node) const</a>
<a name="ln351">{</a>
<a name="ln352">	return *TargetModel()-&gt;NodeRef() == *node;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355"> </a>
<a name="ln356">void</a>
<a name="ln357">BInfoWindow::Show()</a>
<a name="ln358">{</a>
<a name="ln359">	BModelOpener modelOpener(TargetModel());</a>
<a name="ln360">	if (TargetModel()-&gt;InitCheck() != B_OK) {</a>
<a name="ln361">		Close();</a>
<a name="ln362">		return;</a>
<a name="ln363">	}</a>
<a name="ln364"> </a>
<a name="ln365">	AutoLock&lt;BWindow&gt; lock(this);</a>
<a name="ln366"> </a>
<a name="ln367">	const BFont* font = be_plain_font;</a>
<a name="ln368">	float width = font-&gt;StringWidth(&quot;This is a really long string which we&quot;</a>
<a name="ln369">		&quot;will use to find the window width&quot;);</a>
<a name="ln370"> </a>
<a name="ln371">	// window height depends on file type</a>
<a name="ln372">	int lines = 9;</a>
<a name="ln373">	if (fModel-&gt;IsExecutable())</a>
<a name="ln374">		lines++;</a>
<a name="ln375">	float height = font-&gt;Size() * (lines * 2 + 1);</a>
<a name="ln376"> </a>
<a name="ln377">	ResizeTo(width, height);</a>
<a name="ln378"> </a>
<a name="ln379">	BRect attrRect(Bounds());</a>
<a name="ln380">	fAttributeView = new AttributeView(attrRect, TargetModel());</a>
<a name="ln381">	AddChild(fAttributeView);</a>
<a name="ln382"> </a>
<a name="ln383">	// position window appropriately based on index</a>
<a name="ln384">	BRect windRect(InfoWindowRect());</a>
<a name="ln385">	if ((fIndex + 2) % 2 == 1) {</a>
<a name="ln386">		windRect.OffsetBy(320, 0);</a>
<a name="ln387">		fIndex--;</a>
<a name="ln388">	}</a>
<a name="ln389"> </a>
<a name="ln390">	windRect.OffsetBy(fIndex * 8, fIndex * 8);</a>
<a name="ln391"> </a>
<a name="ln392">	// make sure window is visible on screen</a>
<a name="ln393">	BScreen screen(this);</a>
<a name="ln394">	if (!windRect.Intersects(screen.Frame()))</a>
<a name="ln395">		windRect.OffsetTo(50, 50);</a>
<a name="ln396"> </a>
<a name="ln397">	MoveTo(windRect.LeftTop());</a>
<a name="ln398"> </a>
<a name="ln399">	// volume case is handled by view</a>
<a name="ln400">	if (!TargetModel()-&gt;IsVolume() &amp;&amp; !TargetModel()-&gt;IsRoot()) {</a>
<a name="ln401">		if (TargetModel()-&gt;IsDirectory()) {</a>
<a name="ln402">			// if this is a folder then spawn thread to calculate size</a>
<a name="ln403">			SetSizeString(B_TRANSLATE(&quot;calculating&quot; B_UTF8_ELLIPSIS));</a>
<a name="ln404">			fCalcThreadID = spawn_thread(BInfoWindow::CalcSize, &quot;CalcSize&quot;,</a>
<a name="ln405">				B_NORMAL_PRIORITY, this);</a>
<a name="ln406">			resume_thread(fCalcThreadID);</a>
<a name="ln407">		} else {</a>
<a name="ln408">			fAttributeView-&gt;SetLastSize(TargetModel()-&gt;StatBuf()-&gt;st_size);</a>
<a name="ln409"> </a>
<a name="ln410">			BString sizeStr;</a>
<a name="ln411">			GetSizeString(sizeStr, fAttributeView-&gt;LastSize(), 0);</a>
<a name="ln412">			SetSizeString(sizeStr.String());</a>
<a name="ln413">		}</a>
<a name="ln414">	}</a>
<a name="ln415"> </a>
<a name="ln416">	BString buffer(B_TRANSLATE_COMMENT(&quot;%name info&quot;, &quot;InfoWindow Title&quot;));</a>
<a name="ln417">	buffer.ReplaceFirst(&quot;%name&quot;, TargetModel()-&gt;Name());</a>
<a name="ln418">	SetTitle(buffer.String());</a>
<a name="ln419"> </a>
<a name="ln420">	lock.Unlock();</a>
<a name="ln421">	_inherited::Show();</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425">void</a>
<a name="ln426">BInfoWindow::MessageReceived(BMessage* message)</a>
<a name="ln427">{</a>
<a name="ln428">	switch (message-&gt;what) {</a>
<a name="ln429">		case kRestoreState:</a>
<a name="ln430">			Show();</a>
<a name="ln431">			break;</a>
<a name="ln432"> </a>
<a name="ln433">		case kOpenSelection:</a>
<a name="ln434">		{</a>
<a name="ln435">			BMessage refsMessage(B_REFS_RECEIVED);</a>
<a name="ln436">			refsMessage.AddRef(&quot;refs&quot;, fModel-&gt;EntryRef());</a>
<a name="ln437"> </a>
<a name="ln438">			// add a messenger to the launch message that will be used to</a>
<a name="ln439">			// dispatch scripting calls from apps to the PoseView</a>
<a name="ln440">			refsMessage.AddMessenger(&quot;TrackerViewToken&quot;, BMessenger(this));</a>
<a name="ln441">			be_app-&gt;PostMessage(&amp;refsMessage);</a>
<a name="ln442">			break;</a>
<a name="ln443">		}</a>
<a name="ln444"> </a>
<a name="ln445">		case kEditItem:</a>
<a name="ln446">		{</a>
<a name="ln447">			BEntry entry(fModel-&gt;EntryRef());</a>
<a name="ln448">			if (!fModel-&gt;HasLocalizedName()</a>
<a name="ln449">				&amp;&amp; ConfirmChangeIfWellKnownDirectory(&amp;entry, kRename)) {</a>
<a name="ln450">				fAttributeView-&gt;BeginEditingTitle();</a>
<a name="ln451">			}</a>
<a name="ln452">			break;</a>
<a name="ln453">		}</a>
<a name="ln454"> </a>
<a name="ln455">		case kIdentifyEntry:</a>
<a name="ln456">		{</a>
<a name="ln457">			bool force = (modifiers() &amp; B_OPTION_KEY) != 0;</a>
<a name="ln458">			BEntry entry;</a>
<a name="ln459">			if (entry.SetTo(fModel-&gt;EntryRef(), true) == B_OK) {</a>
<a name="ln460">				BPath path;</a>
<a name="ln461">				if (entry.GetPath(&amp;path) == B_OK)</a>
<a name="ln462">					update_mime_info(path.Path(), true, false, force ? 2 : 1);</a>
<a name="ln463">			}</a>
<a name="ln464">			break;</a>
<a name="ln465">		}</a>
<a name="ln466"> </a>
<a name="ln467">		case kRecalculateSize:</a>
<a name="ln468">		{</a>
<a name="ln469">			fStopCalc = true;</a>
<a name="ln470">			// Wait until any current CalcSize thread has terminated before</a>
<a name="ln471">			// starting a new one</a>
<a name="ln472">			status_t result;</a>
<a name="ln473">			wait_for_thread(fCalcThreadID, &amp;result);</a>
<a name="ln474"> </a>
<a name="ln475">			// Start recalculating..</a>
<a name="ln476">			fStopCalc = false;</a>
<a name="ln477">			SetSizeString(B_TRANSLATE(&quot;calculating&quot; B_UTF8_ELLIPSIS));</a>
<a name="ln478">			fCalcThreadID = spawn_thread(BInfoWindow::CalcSize, &quot;CalcSize&quot;,</a>
<a name="ln479">				B_NORMAL_PRIORITY, this);</a>
<a name="ln480">			resume_thread(fCalcThreadID);</a>
<a name="ln481">			break;</a>
<a name="ln482">		}</a>
<a name="ln483"> </a>
<a name="ln484">		case kSetLinkTarget:</a>
<a name="ln485">			OpenFilePanel(fModel-&gt;EntryRef());</a>
<a name="ln486">			break;</a>
<a name="ln487"> </a>
<a name="ln488">		// An item was dropped into the window</a>
<a name="ln489">		case B_SIMPLE_DATA:</a>
<a name="ln490">			// If we are not a SymLink, just ignore the request</a>
<a name="ln491">			if (!fModel-&gt;IsSymLink())</a>
<a name="ln492">				break;</a>
<a name="ln493">			// supposed to fall through</a>
<a name="ln494">		// An item was selected from the file panel</a>
<a name="ln495">		// fall-through</a>
<a name="ln496">		case kNewTargetSelected:</a>
<a name="ln497">		{</a>
<a name="ln498">			// Extract the BEntry, and set its full path to the string value</a>
<a name="ln499">			BEntry targetEntry;</a>
<a name="ln500">			entry_ref ref;</a>
<a name="ln501">			BPath path;</a>
<a name="ln502"> </a>
<a name="ln503">			if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) == B_OK</a>
<a name="ln504">				&amp;&amp; targetEntry.SetTo(&amp;ref, true) == B_OK</a>
<a name="ln505">				&amp;&amp; targetEntry.Exists()) {</a>
<a name="ln506">				// We now have to re-target the broken symlink. Unfortunately,</a>
<a name="ln507">				// there's no way to change the target of an existing symlink.</a>
<a name="ln508">				// So we have to delete the old one and create a new one.</a>
<a name="ln509">				// First, stop watching the broken node</a>
<a name="ln510">				// (we don't want this window to quit when the node</a>
<a name="ln511">				// is removed.)</a>
<a name="ln512">				stop_watching(this);</a>
<a name="ln513"> </a>
<a name="ln514">				// Get the parent</a>
<a name="ln515">				BDirectory parent;</a>
<a name="ln516">				BEntry tmpEntry(TargetModel()-&gt;EntryRef());</a>
<a name="ln517">				if (tmpEntry.GetParent(&amp;parent) != B_OK)</a>
<a name="ln518">					break;</a>
<a name="ln519"> </a>
<a name="ln520">				// Preserve the name</a>
<a name="ln521">				BString name(TargetModel()-&gt;Name());</a>
<a name="ln522"> </a>
<a name="ln523">				// Extract path for new target</a>
<a name="ln524">				BEntry target(&amp;ref);</a>
<a name="ln525">				BPath targetPath;</a>
<a name="ln526">				if (target.GetPath(&amp;targetPath) != B_OK)</a>
<a name="ln527">					break;</a>
<a name="ln528"> </a>
<a name="ln529">				// Preserve the original attributes</a>
<a name="ln530">				AttributeStreamMemoryNode memoryNode;</a>
<a name="ln531">				{</a>
<a name="ln532">					BModelOpener opener(TargetModel());</a>
<a name="ln533">					AttributeStreamFileNode original(TargetModel()-&gt;Node());</a>
<a name="ln534">					memoryNode &lt;&lt; original;</a>
<a name="ln535">				}</a>
<a name="ln536"> </a>
<a name="ln537">				// Delete the broken node.</a>
<a name="ln538">				BEntry oldEntry(TargetModel()-&gt;EntryRef());</a>
<a name="ln539">				oldEntry.Remove();</a>
<a name="ln540"> </a>
<a name="ln541">				// Create new node</a>
<a name="ln542">				BSymLink link;</a>
<a name="ln543">				parent.CreateSymLink(name.String(), targetPath.Path(), &amp;link);</a>
<a name="ln544"> </a>
<a name="ln545">				// Update our Model()</a>
<a name="ln546">				BEntry symEntry(&amp;parent, name.String());</a>
<a name="ln547">				fModel-&gt;SetTo(&amp;symEntry);</a>
<a name="ln548"> </a>
<a name="ln549">				BModelWriteOpener opener(TargetModel());</a>
<a name="ln550"> </a>
<a name="ln551">				// Copy the attributes back</a>
<a name="ln552">				AttributeStreamFileNode newNode(TargetModel()-&gt;Node());</a>
<a name="ln553">				newNode &lt;&lt; memoryNode;</a>
<a name="ln554"> </a>
<a name="ln555">				// Start watching this again</a>
<a name="ln556">				TTracker::WatchNode(TargetModel()-&gt;NodeRef(),</a>
<a name="ln557">					B_WATCH_ALL | B_WATCH_MOUNT, this);</a>
<a name="ln558"> </a>
<a name="ln559">				// Tell the attribute view about this new model</a>
<a name="ln560">				fAttributeView-&gt;ReLinkTargetModel(TargetModel());</a>
<a name="ln561">			}</a>
<a name="ln562">			break;</a>
<a name="ln563">		}</a>
<a name="ln564"> </a>
<a name="ln565">		case B_CANCEL:</a>
<a name="ln566">			// File panel window has closed</a>
<a name="ln567">			delete fFilePanel;</a>
<a name="ln568">			fFilePanel = NULL;</a>
<a name="ln569">			// It's no longer open</a>
<a name="ln570">			fFilePanelOpen = false;</a>
<a name="ln571">			break;</a>
<a name="ln572"> </a>
<a name="ln573">		case kUnmountVolume:</a>
<a name="ln574">			// Sanity check that this isn't the boot volume</a>
<a name="ln575">			// (The unmount menu item has been disabled in this</a>
<a name="ln576">			// case, but the shortcut is still active)</a>
<a name="ln577">			if (fModel-&gt;IsVolume()) {</a>
<a name="ln578">				BVolume boot;</a>
<a name="ln579">				BVolumeRoster().GetBootVolume(&amp;boot);</a>
<a name="ln580">				BVolume volume(fModel-&gt;NodeRef()-&gt;device);</a>
<a name="ln581">				if (volume != boot) {</a>
<a name="ln582">					TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln583">					if (tracker != NULL)</a>
<a name="ln584">						tracker-&gt;SaveAllPoseLocations();</a>
<a name="ln585"> </a>
<a name="ln586">					BMessage unmountMessage(kUnmountVolume);</a>
<a name="ln587">					unmountMessage.AddInt32(&quot;device_id&quot;, volume.Device());</a>
<a name="ln588">					be_app-&gt;PostMessage(&amp;unmountMessage);</a>
<a name="ln589">				}</a>
<a name="ln590">			}</a>
<a name="ln591">			break;</a>
<a name="ln592"> </a>
<a name="ln593">		case kEmptyTrash:</a>
<a name="ln594">			FSEmptyTrash();</a>
<a name="ln595">			break;</a>
<a name="ln596"> </a>
<a name="ln597">		case B_NODE_MONITOR:</a>
<a name="ln598">			switch (message-&gt;FindInt32(&quot;opcode&quot;)) {</a>
<a name="ln599">				case B_ENTRY_REMOVED:</a>
<a name="ln600">				{</a>
<a name="ln601">					node_ref itemNode;</a>
<a name="ln602">					message-&gt;FindInt32(&quot;device&quot;, &amp;itemNode.device);</a>
<a name="ln603">					message-&gt;FindInt64(&quot;node&quot;, &amp;itemNode.node);</a>
<a name="ln604">					// our window itself may be deleted</a>
<a name="ln605">					if (*TargetModel()-&gt;NodeRef() == itemNode)</a>
<a name="ln606">						Close();</a>
<a name="ln607">					break;</a>
<a name="ln608">				}</a>
<a name="ln609"> </a>
<a name="ln610">				case B_ENTRY_MOVED:</a>
<a name="ln611">				case B_STAT_CHANGED:</a>
<a name="ln612">				case B_ATTR_CHANGED:</a>
<a name="ln613">					fAttributeView-&gt;ModelChanged(TargetModel(), message);</a>
<a name="ln614">						// must be called before the</a>
<a name="ln615">						// FilePermissionView::ModelChanged()</a>
<a name="ln616">						// call, because it changes the model...</a>
<a name="ln617">						// (bad style!)</a>
<a name="ln618"> </a>
<a name="ln619">					if (fPermissionsView != NULL)</a>
<a name="ln620">						fPermissionsView-&gt;ModelChanged(TargetModel());</a>
<a name="ln621">					break;</a>
<a name="ln622"> </a>
<a name="ln623">				case B_DEVICE_UNMOUNTED:</a>
<a name="ln624">				{</a>
<a name="ln625">					// We were watching a volume that is no longer</a>
<a name="ln626">					// mounted, we might as well quit</a>
<a name="ln627">					node_ref itemNode;</a>
<a name="ln628">					// Only the device information is available</a>
<a name="ln629">					message-&gt;FindInt32(&quot;device&quot;, &amp;itemNode.device);</a>
<a name="ln630">					if (TargetModel()-&gt;NodeRef()-&gt;device == itemNode.device)</a>
<a name="ln631">						Close();</a>
<a name="ln632">					break;</a>
<a name="ln633">				}</a>
<a name="ln634"> </a>
<a name="ln635">				default:</a>
<a name="ln636">					break;</a>
<a name="ln637">			}</a>
<a name="ln638">			break;</a>
<a name="ln639"> </a>
<a name="ln640">		case kPermissionsSelected:</a>
<a name="ln641">		{</a>
<a name="ln642">			BRect permissionsBounds(kBorderWidth + 1,</a>
<a name="ln643">						fAttributeView-&gt;Bounds().bottom,</a>
<a name="ln644">						fAttributeView-&gt;Bounds().right,</a>
<a name="ln645">						fAttributeView-&gt;Bounds().bottom + 103);</a>
<a name="ln646"> </a>
<a name="ln647">			if (fPermissionsView == NULL) {</a>
<a name="ln648">				// Only true on first call.</a>
<a name="ln649">				fPermissionsView = new FilePermissionsView(</a>
<a name="ln650">					permissionsBounds, fModel);</a>
<a name="ln651">				ResizeBy(0, permissionsBounds.Height());</a>
<a name="ln652">				fAttributeView-&gt;AddChild(fPermissionsView);</a>
<a name="ln653">				fAttributeView-&gt;SetPermissionsSwitchState(kPaneSwitchOpen);</a>
<a name="ln654">			} else if (fPermissionsView-&gt;IsHidden()) {</a>
<a name="ln655">				fPermissionsView-&gt;ModelChanged(fModel);</a>
<a name="ln656">				fPermissionsView-&gt;Show();</a>
<a name="ln657">				ResizeBy(0, permissionsBounds.Height());</a>
<a name="ln658">				fAttributeView-&gt;SetPermissionsSwitchState(kPaneSwitchOpen);</a>
<a name="ln659">			} else {</a>
<a name="ln660">				fPermissionsView-&gt;Hide();</a>
<a name="ln661">				ResizeBy(0, -permissionsBounds.Height());</a>
<a name="ln662">				fAttributeView-&gt;SetPermissionsSwitchState(kPaneSwitchClosed);</a>
<a name="ln663">			}</a>
<a name="ln664">			break;</a>
<a name="ln665">		}</a>
<a name="ln666"> </a>
<a name="ln667">		default:</a>
<a name="ln668">			_inherited::MessageReceived(message);</a>
<a name="ln669">			break;</a>
<a name="ln670">	}</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673"> </a>
<a name="ln674">void</a>
<a name="ln675">BInfoWindow::GetSizeString(BString&amp; result, off_t size, int32 fileCount)</a>
<a name="ln676">{</a>
<a name="ln677">	static BStringFormat sizeFormat(B_TRANSLATE(</a>
<a name="ln678">		&quot;{0, plural, one{(# byte)} other{(# bytes)}}&quot;));</a>
<a name="ln679">	static BStringFormat countFormat(B_TRANSLATE(</a>
<a name="ln680">		&quot;{0, plural, one{for # file} other{for # files}}&quot;));</a>
<a name="ln681"> </a>
<a name="ln682">	char sizeBuffer[128];</a>
<a name="ln683">	result &lt;&lt; string_for_size((double)size, sizeBuffer, sizeof(sizeBuffer));</a>
<a name="ln684"> </a>
<a name="ln685">	if (size &gt;= kKBSize) {</a>
<a name="ln686">		result &lt;&lt; &quot; &quot;;</a>
<a name="ln687"> </a>
<a name="ln688">		sizeFormat.Format(result, size);</a>
<a name="ln689">			// &quot;bytes&quot; translation could come from string_for_size</a>
<a name="ln690">			// which could be part of the localekit itself</a>
<a name="ln691">	}</a>
<a name="ln692"> </a>
<a name="ln693">	if (fileCount != 0) {</a>
<a name="ln694">		result &lt;&lt; &quot; &quot;;</a>
<a name="ln695">		countFormat.Format(result, fileCount);</a>
<a name="ln696">	}</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699"> </a>
<a name="ln700">int32</a>
<a name="ln701">BInfoWindow::CalcSize(void* castToWindow)</a>
<a name="ln702">{</a>
<a name="ln703">	BInfoWindow* window = static_cast&lt;BInfoWindow*&gt;(castToWindow);</a>
<a name="ln704">	BDirectory dir(window-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln705">	BDirectory trashDir;</a>
<a name="ln706">	FSGetTrashDir(&amp;trashDir, window-&gt;TargetModel()-&gt;EntryRef()-&gt;device);</a>
<a name="ln707">	if (dir.InitCheck() != B_OK) {</a>
<a name="ln708">		if (window-&gt;StopCalc())</a>
<a name="ln709">			return B_ERROR;</a>
<a name="ln710"> </a>
<a name="ln711">		AutoLock&lt;BWindow&gt; lock(window);</a>
<a name="ln712">		if (!lock)</a>
<a name="ln713">			return B_ERROR;</a>
<a name="ln714"> </a>
<a name="ln715">		window-&gt;SetSizeString(B_TRANSLATE(&quot;Error calculating folder size.&quot;));</a>
<a name="ln716">		return B_ERROR;</a>
<a name="ln717">	}</a>
<a name="ln718"> </a>
<a name="ln719">	BEntry dirEntry, trashEntry;</a>
<a name="ln720">	dir.GetEntry(&amp;dirEntry);</a>
<a name="ln721">	trashDir.GetEntry(&amp;trashEntry);</a>
<a name="ln722"> </a>
<a name="ln723">	BString sizeString;</a>
<a name="ln724"> </a>
<a name="ln725">	// check if user has asked for trash dir info</a>
<a name="ln726">	if (dirEntry != trashEntry) {</a>
<a name="ln727">		// if not, perform normal info calculations</a>
<a name="ln728">		off_t size = 0;</a>
<a name="ln729">		int32 fileCount = 0;</a>
<a name="ln730">		int32 dirCount = 0;</a>
<a name="ln731">		CopyLoopControl loopControl;</a>
<a name="ln732">		FSRecursiveCalcSize(window, &amp;loopControl, &amp;dir, &amp;size, &amp;fileCount,</a>
<a name="ln733">			&amp;dirCount);</a>
<a name="ln734"> </a>
<a name="ln735">		// got the size value, update the size string</a>
<a name="ln736">		GetSizeString(sizeString, size, fileCount);</a>
<a name="ln737">	} else {</a>
<a name="ln738">		// in the trash case, iterate through and sum up</a>
<a name="ln739">		// size/counts for all present trash dirs</a>
<a name="ln740">		off_t totalSize = 0, currentSize;</a>
<a name="ln741">		int32 totalFileCount = 0, currentFileCount;</a>
<a name="ln742">		int32 totalDirCount = 0, currentDirCount;</a>
<a name="ln743">		BVolumeRoster volRoster;</a>
<a name="ln744">		volRoster.Rewind();</a>
<a name="ln745">		BVolume volume;</a>
<a name="ln746">		while (volRoster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln747">			if (!volume.IsPersistent())</a>
<a name="ln748">				continue;</a>
<a name="ln749"> </a>
<a name="ln750">			currentSize = 0;</a>
<a name="ln751">			currentFileCount = 0;</a>
<a name="ln752">			currentDirCount = 0;</a>
<a name="ln753"> </a>
<a name="ln754">			BDirectory trashDir;</a>
<a name="ln755">			if (FSGetTrashDir(&amp;trashDir, volume.Device()) == B_OK) {</a>
<a name="ln756">				CopyLoopControl loopControl;</a>
<a name="ln757">				FSRecursiveCalcSize(window, &amp;loopControl, &amp;trashDir,</a>
<a name="ln758">					&amp;currentSize, &amp;currentFileCount, &amp;currentDirCount);</a>
<a name="ln759">				totalSize += currentSize;</a>
<a name="ln760">				totalFileCount += currentFileCount;</a>
<a name="ln761">				totalDirCount += currentDirCount;</a>
<a name="ln762">			}</a>
<a name="ln763">		}</a>
<a name="ln764">		GetSizeString(sizeString, totalSize, totalFileCount);</a>
<a name="ln765">	}</a>
<a name="ln766"> </a>
<a name="ln767">	if (window-&gt;StopCalc()) {</a>
<a name="ln768">		// window closed, bail</a>
<a name="ln769">		return B_OK;</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	AutoLock&lt;BWindow&gt; lock(window);</a>
<a name="ln773">	if (lock.IsLocked())</a>
<a name="ln774">		window-&gt;SetSizeString(sizeString.String());</a>
<a name="ln775"> </a>
<a name="ln776">	return B_OK;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779"> </a>
<a name="ln780">void</a>
<a name="ln781">BInfoWindow::SetSizeString(const char* sizeString)</a>
<a name="ln782">{</a>
<a name="ln783">	AttributeView* view</a>
<a name="ln784">		= dynamic_cast&lt;AttributeView*&gt;(FindView(&quot;attr_view&quot;));</a>
<a name="ln785">	if (view != NULL)</a>
<a name="ln786">		view-&gt;SetSizeString(sizeString);</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789"> </a>
<a name="ln790">void</a>
<a name="ln791">BInfoWindow::OpenFilePanel(const entry_ref* ref)</a>
<a name="ln792">{</a>
<a name="ln793">	// Open a file dialog box to allow the user to select a new target</a>
<a name="ln794">	// for the sym link</a>
<a name="ln795">	if (fFilePanel == NULL) {</a>
<a name="ln796">		BMessenger runner(this);</a>
<a name="ln797">		BMessage message(kNewTargetSelected);</a>
<a name="ln798">		fFilePanel = new BFilePanel(B_OPEN_PANEL, &amp;runner, ref,</a>
<a name="ln799">			B_FILE_NODE | B_SYMLINK_NODE | B_DIRECTORY_NODE,</a>
<a name="ln800">			false, &amp;message);</a>
<a name="ln801"> </a>
<a name="ln802">		if (fFilePanel != NULL) {</a>
<a name="ln803">			fFilePanel-&gt;SetButtonLabel(B_DEFAULT_BUTTON,</a>
<a name="ln804">				B_TRANSLATE(&quot;Select&quot;));</a>
<a name="ln805">			fFilePanel-&gt;Window()-&gt;ResizeTo(500, 300);</a>
<a name="ln806">			BString title(B_TRANSLATE_COMMENT(&quot;Link \&quot;%name\&quot; to:&quot;,</a>
<a name="ln807">				&quot;File dialog title for new sym link&quot;));</a>
<a name="ln808">			title.ReplaceFirst(&quot;%name&quot;, fModel-&gt;Name());</a>
<a name="ln809">			fFilePanel-&gt;Window()-&gt;SetTitle(title.String());</a>
<a name="ln810">			fFilePanel-&gt;Show();</a>
<a name="ln811">			fFilePanelOpen = true;</a>
<a name="ln812">		}</a>
<a name="ln813">	} else if (!fFilePanelOpen) {</a>
<a name="ln814">		fFilePanel-&gt;Show();</a>
<a name="ln815">		fFilePanelOpen = true;</a>
<a name="ln816">	} else {</a>
<a name="ln817">		fFilePanelOpen = true;</a>
<a name="ln818">		fFilePanel-&gt;Window()-&gt;Activate(true);</a>
<a name="ln819">	}</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822"> </a>
<a name="ln823">//	#pragma mark - AttributeView</a>
<a name="ln824"> </a>
<a name="ln825"> </a>
<a name="ln826">AttributeView::AttributeView(BRect rect, Model* model)</a>
<a name="ln827">	:</a>
<a name="ln828">	BView(rect, &quot;attr_view&quot;, B_FOLLOW_ALL_SIDES,</a>
<a name="ln829">		B_WILL_DRAW | B_PULSE_NEEDED),</a>
<a name="ln830">	fDivider(0),</a>
<a name="ln831">	fPreferredAppMenu(NULL),</a>
<a name="ln832">	fModel(model),</a>
<a name="ln833">	fIconModel(model),</a>
<a name="ln834">	fMouseDown(false),</a>
<a name="ln835">	fDragging(false),</a>
<a name="ln836">	fDoubleClick(false),</a>
<a name="ln837">	fTrackingState(no_track),</a>
<a name="ln838">	fIsDropTarget(false),</a>
<a name="ln839">	fTitleEditView(NULL),</a>
<a name="ln840">	fPathWindow(NULL),</a>
<a name="ln841">	fLinkWindow(NULL),</a>
<a name="ln842">	fDescWindow(NULL),</a>
<a name="ln843">	fCurrentLinkColorWhich(B_LINK_TEXT_COLOR),</a>
<a name="ln844">	fCurrentPathColorWhich(fCurrentLinkColorWhich)</a>
<a name="ln845">{</a>
<a name="ln846">	// Set view color to standard background grey</a>
<a name="ln847">	SetViewUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln848">	SetFont(be_plain_font);</a>
<a name="ln849">	// If the model is a symlink, then we deference the model to</a>
<a name="ln850">	// get the targets icon</a>
<a name="ln851">	if (fModel-&gt;IsSymLink()) {</a>
<a name="ln852">		Model* resolvedModel = new Model(model-&gt;EntryRef(), true, true);</a>
<a name="ln853">		if (resolvedModel-&gt;InitCheck() == B_OK)</a>
<a name="ln854">			fIconModel = resolvedModel;</a>
<a name="ln855">		// broken link, just show the symlink</a>
<a name="ln856">		else</a>
<a name="ln857">			delete resolvedModel;</a>
<a name="ln858">	}</a>
<a name="ln859"> </a>
<a name="ln860">	// Create the rect for displaying the icon</a>
<a name="ln861">	fIconRect.Set(0, 0, B_LARGE_ICON - 1, B_LARGE_ICON - 1);</a>
<a name="ln862">	// Offset taken from BAlert</a>
<a name="ln863">	fIconRect.OffsetBy(kIconHorizOffset, kIconVertOffset);</a>
<a name="ln864"> </a>
<a name="ln865">	// The title rect</a>
<a name="ln866">	// The magic numbers are used to properly calculate the rect so that</a>
<a name="ln867">	// when the editing text view is displayed, the position of the text</a>
<a name="ln868">	// does not change.</a>
<a name="ln869">	BFont currentFont;</a>
<a name="ln870">	font_height fontMetrics;</a>
<a name="ln871">	GetFont(&amp;currentFont);</a>
<a name="ln872">	currentFont.GetHeight(&amp;fontMetrics);</a>
<a name="ln873"> </a>
<a name="ln874">	fTitleRect.left = fIconRect.right + 5;</a>
<a name="ln875">	fTitleRect.top = 0;</a>
<a name="ln876">	fTitleRect.bottom = fontMetrics.ascent + 1;</a>
<a name="ln877">	fTitleRect.right = min_c(</a>
<a name="ln878">		fTitleRect.left + currentFont.StringWidth(fModel-&gt;Name()),</a>
<a name="ln879">		Bounds().Width() - 5);</a>
<a name="ln880">	// Offset so that it centers with the icon</a>
<a name="ln881">	fTitleRect.OffsetBy(0,</a>
<a name="ln882">		fIconRect.top + ((fIconRect.Height() - fTitleRect.Height()) / 2));</a>
<a name="ln883">	// Make some room for the border for when we are in edit mode</a>
<a name="ln884">	// (Negative numbers increase the size of the rect)</a>
<a name="ln885">	fTitleRect.InsetBy(-1, -2);</a>
<a name="ln886"> </a>
<a name="ln887">	fFreeBytes = -1;</a>
<a name="ln888">	fSizeString = &quot;&quot;;</a>
<a name="ln889">	fSizeRect.Set(0, 0, 0, 0);</a>
<a name="ln890"> </a>
<a name="ln891">	// Find offset for attributes, might be overiden below if there</a>
<a name="ln892">	// is a prefered handle menu displayed</a>
<a name="ln893">	currentFont.SetSize(currentFont.Size() - 2);</a>
<a name="ln894">	fDivider = currentFont.StringWidth(B_TRANSLATE(&quot;Description:&quot;))</a>
<a name="ln895">		+ kBorderMargin + kBorderWidth + 1;</a>
<a name="ln896">	// Add a preferred handler pop-up menu if this item</a>
<a name="ln897">	// is a file...This goes in place of the Link To:</a>
<a name="ln898">	// string...</a>
<a name="ln899">	if (model-&gt;IsFile()) {</a>
<a name="ln900">		BMimeType mime(fModel-&gt;MimeType());</a>
<a name="ln901">		BNodeInfo nodeInfo(fModel-&gt;Node());</a>
<a name="ln902"> </a>
<a name="ln903">		// But don't add the menu if the file is executable</a>
<a name="ln904">		if (!fModel-&gt;IsExecutable()) {</a>
<a name="ln905">			float lineHeight = CurrentFontHeight();</a>
<a name="ln906"> </a>
<a name="ln907">			BRect preferredAppRect(kBorderWidth + kBorderMargin,</a>
<a name="ln908">				fTitleRect.bottom + (lineHeight * 7),</a>
<a name="ln909">				Bounds().Width() - 5, fTitleRect.bottom + (lineHeight * 8));</a>
<a name="ln910">			fPreferredAppMenu = new BMenuField(preferredAppRect, &quot;&quot;, &quot;&quot;,</a>
<a name="ln911">				new BPopUpMenu(&quot;&quot;));</a>
<a name="ln912">			currentFont.SetSize(currentFont.Size() + 2);</a>
<a name="ln913">			fDivider = currentFont.StringWidth(B_TRANSLATE(&quot;Opens with:&quot;))</a>
<a name="ln914">				+ 5;</a>
<a name="ln915">			fPreferredAppMenu-&gt;SetDivider(fDivider);</a>
<a name="ln916">			fDivider += (preferredAppRect.left - 2);</a>
<a name="ln917">			fPreferredAppMenu-&gt;SetFont(&amp;currentFont);</a>
<a name="ln918">			fPreferredAppMenu-&gt;SetHighUIColor(B_PANEL_TEXT_COLOR);</a>
<a name="ln919">			fPreferredAppMenu-&gt;SetLabel(B_TRANSLATE(&quot;Opens with:&quot;));</a>
<a name="ln920"> </a>
<a name="ln921">			char prefSignature[B_MIME_TYPE_LENGTH];</a>
<a name="ln922">			nodeInfo.GetPreferredApp(prefSignature);</a>
<a name="ln923"> </a>
<a name="ln924">			BMessage supportingAppList;</a>
<a name="ln925">			mime.GetSupportingApps(&amp;supportingAppList);</a>
<a name="ln926"> </a>
<a name="ln927">			// Add the default menu item and set it to marked</a>
<a name="ln928">			BMenuItem* result;</a>
<a name="ln929">			result = new BMenuItem(B_TRANSLATE(&quot;Default application&quot;),</a>
<a name="ln930">				new BMessage(kSetPreferredApp));</a>
<a name="ln931">			result-&gt;SetTarget(this);</a>
<a name="ln932">			fPreferredAppMenu-&gt;Menu()-&gt;AddItem(result);</a>
<a name="ln933">			result-&gt;SetMarked(true);</a>
<a name="ln934"> </a>
<a name="ln935">			for (int32 index = 0; ; index++) {</a>
<a name="ln936">				const char* signature;</a>
<a name="ln937">				if (supportingAppList.FindString(&quot;applications&quot;, index,</a>
<a name="ln938">						&amp;signature) != B_OK) {</a>
<a name="ln939">					break;</a>
<a name="ln940">				}</a>
<a name="ln941"> </a>
<a name="ln942">				// Only add separator item if there are more items</a>
<a name="ln943">				if (index == 0)</a>
<a name="ln944">					fPreferredAppMenu-&gt;Menu()-&gt;AddSeparatorItem();</a>
<a name="ln945"> </a>
<a name="ln946">				BMessage* itemMessage = new BMessage(kSetPreferredApp);</a>
<a name="ln947">				itemMessage-&gt;AddString(&quot;signature&quot;, signature);</a>
<a name="ln948"> </a>
<a name="ln949">				status_t err = B_ERROR;</a>
<a name="ln950">				entry_ref entry;</a>
<a name="ln951"> </a>
<a name="ln952">				if (signature &amp;&amp; signature[0])</a>
<a name="ln953">					err = be_roster-&gt;FindApp(signature, &amp;entry);</a>
<a name="ln954"> </a>
<a name="ln955">				if (err != B_OK)</a>
<a name="ln956">					result = new BMenuItem(signature, itemMessage);</a>
<a name="ln957">				else</a>
<a name="ln958">					result = new BMenuItem(entry.name, itemMessage);</a>
<a name="ln959"> </a>
<a name="ln960">				result-&gt;SetTarget(this);</a>
<a name="ln961">				fPreferredAppMenu-&gt;Menu()-&gt;AddItem(result);</a>
<a name="ln962">				if (strcmp(signature, prefSignature) == 0)</a>
<a name="ln963">					result-&gt;SetMarked(true);</a>
<a name="ln964">			}</a>
<a name="ln965"> </a>
<a name="ln966">			AddChild(fPreferredAppMenu);</a>
<a name="ln967">		}</a>
<a name="ln968">	}</a>
<a name="ln969"> </a>
<a name="ln970">	fPermissionsSwitch = new PaneSwitch(BRect(), &quot;Permissions&quot;);</a>
<a name="ln971">	fPermissionsSwitch-&gt;SetMessage(new BMessage(kPermissionsSelected));</a>
<a name="ln972">	fPermissionsSwitch-&gt;SetLabels(NULL,	B_TRANSLATE(&quot;Permissions&quot;));</a>
<a name="ln973">	AddChild(fPermissionsSwitch);</a>
<a name="ln974">	fPermissionsSwitch-&gt;ResizeToPreferred();</a>
<a name="ln975">	fPermissionsSwitch-&gt;MoveTo(kBorderWidth + 3,</a>
<a name="ln976">		Bounds().bottom - 3 - fPermissionsSwitch-&gt;Bounds().Height());</a>
<a name="ln977"> </a>
<a name="ln978">	InitStrings(model);</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981"> </a>
<a name="ln982">AttributeView::~AttributeView()</a>
<a name="ln983">{</a>
<a name="ln984">	if (fPathWindow-&gt;Lock())</a>
<a name="ln985">		fPathWindow-&gt;Quit();</a>
<a name="ln986"> </a>
<a name="ln987">	if (fLinkWindow-&gt;Lock())</a>
<a name="ln988">		fLinkWindow-&gt;Quit();</a>
<a name="ln989"> </a>
<a name="ln990">	if (fDescWindow-&gt;Lock())</a>
<a name="ln991">		fDescWindow-&gt;Quit();</a>
<a name="ln992"> </a>
<a name="ln993">	if (fIconModel != fModel)</a>
<a name="ln994">		delete fIconModel;</a>
<a name="ln995">}</a>
<a name="ln996"> </a>
<a name="ln997"> </a>
<a name="ln998">void</a>
<a name="ln999">AttributeView::InitStrings(const Model* model)</a>
<a name="ln1000">{</a>
<a name="ln1001">	BMimeType mime;</a>
<a name="ln1002">	char kind[B_MIME_TYPE_LENGTH];</a>
<a name="ln1003"> </a>
<a name="ln1004">	ASSERT(model-&gt;IsNodeOpen());</a>
<a name="ln1005"> </a>
<a name="ln1006">	BRect drawBounds(Bounds());</a>
<a name="ln1007">	drawBounds.left = fDivider;</a>
<a name="ln1008"> </a>
<a name="ln1009">	// We'll do our own truncation later on in Draw()</a>
<a name="ln1010">	WidgetAttributeText::AttrAsString(model, &amp;fCreatedStr, kAttrStatCreated,</a>
<a name="ln1011">		B_TIME_TYPE, drawBounds.Width() - kBorderMargin, this);</a>
<a name="ln1012">	WidgetAttributeText::AttrAsString(model, &amp;fModifiedStr, kAttrStatModified,</a>
<a name="ln1013">		B_TIME_TYPE, drawBounds.Width() - kBorderMargin, this);</a>
<a name="ln1014">	WidgetAttributeText::AttrAsString(model, &amp;fPathStr, kAttrPath,</a>
<a name="ln1015">		B_STRING_TYPE, 0, this);</a>
<a name="ln1016"> </a>
<a name="ln1017">	// Use the same method as used to resolve fIconModel, which handles</a>
<a name="ln1018">	// both absolute and relative symlinks. if the link is broken, try to</a>
<a name="ln1019">	// get a little more information.</a>
<a name="ln1020">	if (model-&gt;IsSymLink()) {</a>
<a name="ln1021">		bool linked = false;</a>
<a name="ln1022"> </a>
<a name="ln1023">		Model resolvedModel(model-&gt;EntryRef(), true, true);</a>
<a name="ln1024">		if (resolvedModel.InitCheck() == B_OK) {</a>
<a name="ln1025">			// Get the path of the link</a>
<a name="ln1026">			BPath traversedPath;</a>
<a name="ln1027">			resolvedModel.GetPath(&amp;traversedPath);</a>
<a name="ln1028"> </a>
<a name="ln1029">			// If the BPath is initialized, then check the file for existence</a>
<a name="ln1030">			if (traversedPath.InitCheck() == B_OK) {</a>
<a name="ln1031">				BEntry entry(traversedPath.Path(), false);</a>
<a name="ln1032">					// look at the target itself</a>
<a name="ln1033">				if (entry.InitCheck() == B_OK &amp;&amp; entry.Exists())</a>
<a name="ln1034">					linked = true;</a>
<a name="ln1035">			}</a>
<a name="ln1036">		}</a>
<a name="ln1037"> </a>
<a name="ln1038">		// always show the target as it is: absolute or relative!</a>
<a name="ln1039">		BSymLink symLink(model-&gt;EntryRef());</a>
<a name="ln1040">		char linkToPath[B_PATH_NAME_LENGTH];</a>
<a name="ln1041">		symLink.ReadLink(linkToPath, B_PATH_NAME_LENGTH);</a>
<a name="ln1042">		fLinkToStr = linkToPath;</a>
<a name="ln1043">		if (!linked) {</a>
<a name="ln1044">			// link points to missing object</a>
<a name="ln1045">			fLinkToStr += B_TRANSLATE(&quot; (broken)&quot;);</a>
<a name="ln1046">		}</a>
<a name="ln1047">	} else if (model-&gt;IsExecutable()) {</a>
<a name="ln1048">		if (((Model*)model)-&gt;GetLongVersionString(fDescStr,</a>
<a name="ln1049">				B_APP_VERSION_KIND) == B_OK) {</a>
<a name="ln1050">			// we want a flat string, so replace all newlines and tabs</a>
<a name="ln1051">			// with spaces</a>
<a name="ln1052">			fDescStr.ReplaceAll('\n', ' ');</a>
<a name="ln1053">			fDescStr.ReplaceAll('\t', ' ');</a>
<a name="ln1054">		} else</a>
<a name="ln1055">			fDescStr = &quot;-&quot;;</a>
<a name="ln1056">	}</a>
<a name="ln1057"> </a>
<a name="ln1058">	if (mime.SetType(model-&gt;MimeType()) == B_OK</a>
<a name="ln1059">		&amp;&amp; mime.GetShortDescription(kind) == B_OK)</a>
<a name="ln1060">		fKindStr = kind;</a>
<a name="ln1061"> </a>
<a name="ln1062">	if (fKindStr.Length() == 0)</a>
<a name="ln1063">		fKindStr = model-&gt;MimeType();</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066"> </a>
<a name="ln1067">void</a>
<a name="ln1068">AttributeView::AttachedToWindow()</a>
<a name="ln1069">{</a>
<a name="ln1070">	BFont font(be_plain_font);</a>
<a name="ln1071"> </a>
<a name="ln1072">	font.SetSpacing(B_BITMAP_SPACING);</a>
<a name="ln1073">	SetFont(&amp;font);</a>
<a name="ln1074"> </a>
<a name="ln1075">	CheckAndSetSize();</a>
<a name="ln1076">	if (fPreferredAppMenu)</a>
<a name="ln1077">		fPreferredAppMenu-&gt;Menu()-&gt;SetTargetForItems(this);</a>
<a name="ln1078"> </a>
<a name="ln1079">	_inherited::AttachedToWindow();</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082"> </a>
<a name="ln1083">void</a>
<a name="ln1084">AttributeView::Pulse()</a>
<a name="ln1085">{</a>
<a name="ln1086">	CheckAndSetSize();</a>
<a name="ln1087">	_inherited::Pulse();</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090"> </a>
<a name="ln1091">void</a>
<a name="ln1092">AttributeView::ModelChanged(Model* model, BMessage* message)</a>
<a name="ln1093">{</a>
<a name="ln1094">	BRect drawBounds(Bounds());</a>
<a name="ln1095">	drawBounds.left = fDivider;</a>
<a name="ln1096"> </a>
<a name="ln1097">	switch (message-&gt;FindInt32(&quot;opcode&quot;)) {</a>
<a name="ln1098">		case B_ENTRY_MOVED:</a>
<a name="ln1099">		{</a>
<a name="ln1100">			node_ref dirNode;</a>
<a name="ln1101">			node_ref itemNode;</a>
<a name="ln1102">			dirNode.device = itemNode.device = message-&gt;FindInt32(&quot;device&quot;);</a>
<a name="ln1103">			message-&gt;FindInt64(&quot;to directory&quot;, &amp;dirNode.node);</a>
<a name="ln1104">			message-&gt;FindInt64(&quot;node&quot;, &amp;itemNode.node);</a>
<a name="ln1105"> </a>
<a name="ln1106">			const char* name;</a>
<a name="ln1107">			if (message-&gt;FindString(&quot;name&quot;, &amp;name) != B_OK)</a>
<a name="ln1108">				return;</a>
<a name="ln1109"> </a>
<a name="ln1110">			// ensure notification is for us</a>
<a name="ln1111">			if (*model-&gt;NodeRef() == itemNode</a>
<a name="ln1112">				// For volumes, the device ID is obviously not handled in a</a>
<a name="ln1113">				// consistent way; the node monitor sends us the ID of the</a>
<a name="ln1114">				// parent device, while the model is set to the device of the</a>
<a name="ln1115">				// volume directly - this hack works for volumes that are</a>
<a name="ln1116">				// mounted in the root directory</a>
<a name="ln1117">				|| (model-&gt;IsVolume()</a>
<a name="ln1118">					&amp;&amp; itemNode.device == 1</a>
<a name="ln1119">					&amp;&amp; itemNode.node == model-&gt;NodeRef()-&gt;node)) {</a>
<a name="ln1120">				model-&gt;UpdateEntryRef(&amp;dirNode, name);</a>
<a name="ln1121">				BString title;</a>
<a name="ln1122">				title &lt;&lt; name &lt;&lt; B_TRANSLATE(&quot; info&quot;);</a>
<a name="ln1123">				Window()-&gt;SetTitle(title.String());</a>
<a name="ln1124">				WidgetAttributeText::AttrAsString(model, &amp;fPathStr, kAttrPath,</a>
<a name="ln1125">					B_STRING_TYPE, 0, this);</a>
<a name="ln1126">				Invalidate();</a>
<a name="ln1127">			}</a>
<a name="ln1128">			break;</a>
<a name="ln1129">		}</a>
<a name="ln1130"> </a>
<a name="ln1131">		case B_STAT_CHANGED:</a>
<a name="ln1132">			if (model-&gt;OpenNode() == B_OK) {</a>
<a name="ln1133">				WidgetAttributeText::AttrAsString(model, &amp;fCreatedStr,</a>
<a name="ln1134">					kAttrStatCreated, B_TIME_TYPE, drawBounds.Width()</a>
<a name="ln1135">					- kBorderMargin, this);</a>
<a name="ln1136">				WidgetAttributeText::AttrAsString(model, &amp;fModifiedStr,</a>
<a name="ln1137">					kAttrStatModified, B_TIME_TYPE, drawBounds.Width()</a>
<a name="ln1138">					- kBorderMargin, this);</a>
<a name="ln1139"> </a>
<a name="ln1140">				// don't change the size if it's a directory</a>
<a name="ln1141">				if (!model-&gt;IsDirectory()) {</a>
<a name="ln1142">					fLastSize = model-&gt;StatBuf()-&gt;st_size;</a>
<a name="ln1143">					fSizeString = &quot;&quot;;</a>
<a name="ln1144">					BInfoWindow::GetSizeString(fSizeString, fLastSize, 0);</a>
<a name="ln1145">				}</a>
<a name="ln1146">				model-&gt;CloseNode();</a>
<a name="ln1147">			}</a>
<a name="ln1148">			break;</a>
<a name="ln1149"> </a>
<a name="ln1150">		case B_ATTR_CHANGED:</a>
<a name="ln1151">		{</a>
<a name="ln1152">			// watch for icon updates</a>
<a name="ln1153">			const char* attrName;</a>
<a name="ln1154">			if (message-&gt;FindString(&quot;attr&quot;, &amp;attrName) == B_OK) {</a>
<a name="ln1155">				if (strcmp(attrName, kAttrLargeIcon) == 0</a>
<a name="ln1156">					|| strcmp(attrName, kAttrIcon) == 0) {</a>
<a name="ln1157">					IconCache::sIconCache-&gt;IconChanged(model-&gt;ResolveIfLink());</a>
<a name="ln1158">					Invalidate();</a>
<a name="ln1159">				} else if (strcmp(attrName, kAttrMIMEType) == 0) {</a>
<a name="ln1160">					if (model-&gt;OpenNode() == B_OK) {</a>
<a name="ln1161">						model-&gt;AttrChanged(attrName);</a>
<a name="ln1162">						InitStrings(model);</a>
<a name="ln1163">						model-&gt;CloseNode();</a>
<a name="ln1164">					}</a>
<a name="ln1165">					Invalidate();</a>
<a name="ln1166">				}</a>
<a name="ln1167">			}</a>
<a name="ln1168">			break;</a>
<a name="ln1169">		}</a>
<a name="ln1170"> </a>
<a name="ln1171">		default:</a>
<a name="ln1172">			break;</a>
<a name="ln1173">	}</a>
<a name="ln1174"> </a>
<a name="ln1175">	// Update the icon stuff</a>
<a name="ln1176">	if (fIconModel != fModel) {</a>
<a name="ln1177">		delete fIconModel;</a>
<a name="ln1178">		fIconModel = NULL;</a>
<a name="ln1179">	}</a>
<a name="ln1180"> </a>
<a name="ln1181">	fModel = model;</a>
<a name="ln1182">	if (fModel-&gt;IsSymLink()) {</a>
<a name="ln1183">		// if we are looking at a symlink, deference the model and look</a>
<a name="ln1184">		// at the target</a>
<a name="ln1185">		Model* resolvedModel = new Model(model-&gt;EntryRef(), true, true);</a>
<a name="ln1186">		if (resolvedModel-&gt;InitCheck() == B_OK) {</a>
<a name="ln1187">			if (fIconModel != fModel)</a>
<a name="ln1188">				delete fIconModel;</a>
<a name="ln1189">			fIconModel = resolvedModel;</a>
<a name="ln1190">		} else {</a>
<a name="ln1191">			fIconModel = model;</a>
<a name="ln1192">			delete resolvedModel;</a>
<a name="ln1193">		}</a>
<a name="ln1194">		InitStrings(model);</a>
<a name="ln1195">		Invalidate();</a>
<a name="ln1196">	}</a>
<a name="ln1197"> </a>
<a name="ln1198">	drawBounds.left = fDivider;</a>
<a name="ln1199">	Invalidate(drawBounds);</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202"> </a>
<a name="ln1203">// This only applies to symlinks. If the target of the symlink</a>
<a name="ln1204">// was changed, then we have to update the entire model.</a>
<a name="ln1205">// (Since in order to re-target a symlink, we had to delete</a>
<a name="ln1206">// the old model and create a new one; BSymLink::SetTarget(),</a>
<a name="ln1207">// would be nice)</a>
<a name="ln1208"> </a>
<a name="ln1209">void</a>
<a name="ln1210">AttributeView::ReLinkTargetModel(Model* model)</a>
<a name="ln1211">{</a>
<a name="ln1212">	fModel = model;</a>
<a name="ln1213">	if (fModel-&gt;IsSymLink()) {</a>
<a name="ln1214">		Model* resolvedModel = new Model(model-&gt;EntryRef(), true, true);</a>
<a name="ln1215">		if (resolvedModel-&gt;InitCheck() == B_OK) {</a>
<a name="ln1216">			if (fIconModel != fModel)</a>
<a name="ln1217">				delete fIconModel;</a>
<a name="ln1218">			fIconModel = resolvedModel;</a>
<a name="ln1219">		} else {</a>
<a name="ln1220">			fIconModel = fModel;</a>
<a name="ln1221">			delete resolvedModel;</a>
<a name="ln1222">		}</a>
<a name="ln1223">	}</a>
<a name="ln1224">	InitStrings(model);</a>
<a name="ln1225">	Invalidate(Bounds());</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228"> </a>
<a name="ln1229">void</a>
<a name="ln1230">AttributeView::MouseDown(BPoint where)</a>
<a name="ln1231">{</a>
<a name="ln1232">	BEntry entry;</a>
<a name="ln1233">	fModel-&gt;GetEntry(&amp;entry);</a>
<a name="ln1234"> </a>
<a name="ln1235">	// Assume this isn't part of a double click</a>
<a name="ln1236">	fDoubleClick = false;</a>
<a name="ln1237"> </a>
<a name="ln1238">	// Start tracking the mouse if we are in any of the hotspots</a>
<a name="ln1239">	if (fLinkRect.Contains(where)) {</a>
<a name="ln1240">		InvertRect(fLinkRect);</a>
<a name="ln1241">		fTrackingState = link_track;</a>
<a name="ln1242">	} else if (fPathRect.Contains(where)) {</a>
<a name="ln1243">		InvertRect(fPathRect);</a>
<a name="ln1244">		fTrackingState = path_track;</a>
<a name="ln1245">	} else if (fTitleRect.Contains(where)) {</a>
<a name="ln1246">		if (!fModel-&gt;HasLocalizedName()</a>
<a name="ln1247">			&amp;&amp; ConfirmChangeIfWellKnownDirectory(&amp;entry, kRename, true)) {</a>
<a name="ln1248">			BeginEditingTitle();</a>
<a name="ln1249">		}</a>
<a name="ln1250">	} else if (fTitleEditView) {</a>
<a name="ln1251">		FinishEditingTitle(true);</a>
<a name="ln1252">	} else if (fSizeRect.Contains(where)) {</a>
<a name="ln1253">		if (fModel-&gt;IsDirectory() &amp;&amp; !fModel-&gt;IsVolume()</a>
<a name="ln1254">			&amp;&amp; !fModel-&gt;IsRoot()) {</a>
<a name="ln1255">			InvertRect(fSizeRect);</a>
<a name="ln1256">			fTrackingState = size_track;</a>
<a name="ln1257">		} else</a>
<a name="ln1258">			fTrackingState = no_track;</a>
<a name="ln1259">	} else if (fIconRect.Contains(where)) {</a>
<a name="ln1260">		uint32 buttons;</a>
<a name="ln1261">		Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons);</a>
<a name="ln1262">		if (SecondaryMouseButtonDown(modifiers(), buttons)) {</a>
<a name="ln1263">			// Show contextual menu</a>
<a name="ln1264">			BPopUpMenu* contextMenu</a>
<a name="ln1265">				= new BPopUpMenu(&quot;FileContext&quot;, false, false);</a>
<a name="ln1266">			if (contextMenu) {</a>
<a name="ln1267">				BuildContextMenu(contextMenu);</a>
<a name="ln1268">				contextMenu-&gt;SetAsyncAutoDestruct(true);</a>
<a name="ln1269">				contextMenu-&gt;Go(ConvertToScreen(where), true, true,</a>
<a name="ln1270">					ConvertToScreen(fIconRect));</a>
<a name="ln1271">			}</a>
<a name="ln1272">		} else {</a>
<a name="ln1273">			// Check to see if the point is actually on part of the icon,</a>
<a name="ln1274">			// versus just in the container rect. The icons are always</a>
<a name="ln1275">			// the large version</a>
<a name="ln1276">			BPoint offsetPoint;</a>
<a name="ln1277">			offsetPoint.x = where.x - fIconRect.left;</a>
<a name="ln1278">			offsetPoint.y = where.y - fIconRect.top;</a>
<a name="ln1279">			if (IconCache::sIconCache-&gt;IconHitTest(offsetPoint, fIconModel,</a>
<a name="ln1280">					kNormalIcon, B_LARGE_ICON)) {</a>
<a name="ln1281">				// Can't drag the trash anywhere..</a>
<a name="ln1282">				fTrackingState = fModel-&gt;IsTrash()</a>
<a name="ln1283">					? open_only_track : icon_track;</a>
<a name="ln1284"> </a>
<a name="ln1285">				// Check for possible double click</a>
<a name="ln1286">				if (abs((int32)(fClickPoint.x - where.x)) &lt; kDragSlop</a>
<a name="ln1287">					&amp;&amp; abs((int32)(fClickPoint.y - where.y)) &lt; kDragSlop) {</a>
<a name="ln1288">					int32 clickCount;</a>
<a name="ln1289">					Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;clicks&quot;,</a>
<a name="ln1290">						&amp;clickCount);</a>
<a name="ln1291"> </a>
<a name="ln1292">					// This checks the* previous* click point</a>
<a name="ln1293">					if (clickCount == 2) {</a>
<a name="ln1294">						offsetPoint.x = fClickPoint.x - fIconRect.left;</a>
<a name="ln1295">						offsetPoint.y = fClickPoint.y - fIconRect.top;</a>
<a name="ln1296">						fDoubleClick</a>
<a name="ln1297">							= IconCache::sIconCache-&gt;IconHitTest(offsetPoint,</a>
<a name="ln1298">							fIconModel, kNormalIcon, B_LARGE_ICON);</a>
<a name="ln1299">					}</a>
<a name="ln1300">				}</a>
<a name="ln1301">			}</a>
<a name="ln1302">		}</a>
<a name="ln1303">	}</a>
<a name="ln1304"> </a>
<a name="ln1305">	fClickPoint = where;</a>
<a name="ln1306">	fMouseDown = true;</a>
<a name="ln1307">	SetMouseEventMask(B_POINTER_EVENTS, B_NO_POINTER_HISTORY);</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">void</a>
<a name="ln1312">AttributeView::MouseMoved(BPoint where, uint32, const BMessage* dragMessage)</a>
<a name="ln1313">{</a>
<a name="ln1314">	if (dragMessage != NULL &amp;&amp; dragMessage-&gt;ReturnAddress() != BMessenger(this)</a>
<a name="ln1315">		&amp;&amp; dragMessage-&gt;what == B_SIMPLE_DATA</a>
<a name="ln1316">		&amp;&amp; BPoseView::CanHandleDragSelection(fModel, dragMessage,</a>
<a name="ln1317">			(modifiers() &amp; B_CONTROL_KEY) != 0)) {</a>
<a name="ln1318">		// highlight drag target</a>
<a name="ln1319">		bool overTarget = fIconRect.Contains(where);</a>
<a name="ln1320">		SetDrawingMode(B_OP_OVER);</a>
<a name="ln1321">		if (overTarget != fIsDropTarget) {</a>
<a name="ln1322">			IconCache::sIconCache-&gt;Draw(fIconModel, this, fIconRect.LeftTop(),</a>
<a name="ln1323">				overTarget ? kSelectedIcon : kNormalIcon, B_LARGE_ICON, true);</a>
<a name="ln1324">			fIsDropTarget = overTarget;</a>
<a name="ln1325">		}</a>
<a name="ln1326">	}</a>
<a name="ln1327"> </a>
<a name="ln1328">	fCurrentLinkColorWhich = B_LINK_TEXT_COLOR;</a>
<a name="ln1329">	fCurrentPathColorWhich = fCurrentLinkColorWhich;</a>
<a name="ln1330"> </a>
<a name="ln1331">	switch (fTrackingState) {</a>
<a name="ln1332">		case link_track:</a>
<a name="ln1333">			if (fLinkRect.Contains(where) != fMouseDown) {</a>
<a name="ln1334">				fMouseDown = !fMouseDown;</a>
<a name="ln1335">				InvertRect(fLinkRect);</a>
<a name="ln1336">			}</a>
<a name="ln1337">			break;</a>
<a name="ln1338"> </a>
<a name="ln1339">		case path_track:</a>
<a name="ln1340">			if (fPathRect.Contains(where) != fMouseDown) {</a>
<a name="ln1341">				fMouseDown = !fMouseDown;</a>
<a name="ln1342">				InvertRect(fPathRect);</a>
<a name="ln1343">			}</a>
<a name="ln1344">			break;</a>
<a name="ln1345"> </a>
<a name="ln1346">		case size_track:</a>
<a name="ln1347">			if (fSizeRect.Contains(where) != fMouseDown) {</a>
<a name="ln1348">				fMouseDown = !fMouseDown;</a>
<a name="ln1349">				InvertRect(fSizeRect);</a>
<a name="ln1350">			}</a>
<a name="ln1351">			break;</a>
<a name="ln1352"> </a>
<a name="ln1353">		case icon_track:</a>
<a name="ln1354">			if (fMouseDown &amp;&amp; !fDragging</a>
<a name="ln1355">				&amp;&amp; (abs((int32)(where.x - fClickPoint.x)) &gt; kDragSlop</a>
<a name="ln1356">					|| abs((int32)(where.y - fClickPoint.y)) &gt; kDragSlop)) {</a>
<a name="ln1357">				// Find the required height</a>
<a name="ln1358">				BFont font;</a>
<a name="ln1359">				GetFont(&amp;font);</a>
<a name="ln1360"> </a>
<a name="ln1361">				float height = CurrentFontHeight()</a>
<a name="ln1362">					+ fIconRect.Height() + 8;</a>
<a name="ln1363">				BRect rect(0, 0, min_c(fIconRect.Width()</a>
<a name="ln1364">						+ font.StringWidth(fModel-&gt;Name()) + 4,</a>
<a name="ln1365">					fIconRect.Width() * 3), height);</a>
<a name="ln1366">				BBitmap* dragBitmap = new BBitmap(rect, B_RGBA32, true);</a>
<a name="ln1367">				dragBitmap-&gt;Lock();</a>
<a name="ln1368">				BView* view = new BView(dragBitmap-&gt;Bounds(), &quot;&quot;,</a>
<a name="ln1369">					B_FOLLOW_NONE, 0);</a>
<a name="ln1370">				dragBitmap-&gt;AddChild(view);</a>
<a name="ln1371">				view-&gt;SetOrigin(0, 0);</a>
<a name="ln1372">				BRect clipRect(view-&gt;Bounds());</a>
<a name="ln1373">				BRegion newClip;</a>
<a name="ln1374">				newClip.Set(clipRect);</a>
<a name="ln1375">				view-&gt;ConstrainClippingRegion(&amp;newClip);</a>
<a name="ln1376"> </a>
<a name="ln1377">				// Transparent draw magic</a>
<a name="ln1378">				view-&gt;SetHighColor(0, 0, 0, 0);</a>
<a name="ln1379">				view-&gt;FillRect(view-&gt;Bounds());</a>
<a name="ln1380">				view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln1381">				rgb_color textColor = ui_color(B_PANEL_TEXT_COLOR);</a>
<a name="ln1382">				textColor.alpha = 128;</a>
<a name="ln1383">					// set transparency by value</a>
<a name="ln1384">				view-&gt;SetHighColor(textColor);</a>
<a name="ln1385">				view-&gt;SetBlendingMode(B_CONSTANT_ALPHA, B_ALPHA_COMPOSITE);</a>
<a name="ln1386"> </a>
<a name="ln1387">				// Draw the icon</a>
<a name="ln1388">				float hIconOffset = (rect.Width() - fIconRect.Width()) / 2;</a>
<a name="ln1389">				IconCache::sIconCache-&gt;Draw(fIconModel, view,</a>
<a name="ln1390">					BPoint(hIconOffset, 0), kNormalIcon, B_LARGE_ICON, true);</a>
<a name="ln1391"> </a>
<a name="ln1392">				// See if we need to truncate the string</a>
<a name="ln1393">				BString nameString(fModel-&gt;Name());</a>
<a name="ln1394">				if (view-&gt;StringWidth(fModel-&gt;Name()) &gt; rect.Width()) {</a>
<a name="ln1395">					view-&gt;TruncateString(&amp;nameString, B_TRUNCATE_END,</a>
<a name="ln1396">						rect.Width() - 5);</a>
<a name="ln1397">				}</a>
<a name="ln1398"> </a>
<a name="ln1399">				// Draw the label</a>
<a name="ln1400">				font_height fontHeight;</a>
<a name="ln1401">				font.GetHeight(&amp;fontHeight);</a>
<a name="ln1402">				float leftText = (view-&gt;StringWidth(nameString.String())</a>
<a name="ln1403">					- fIconRect.Width()) / 2;</a>
<a name="ln1404">				view-&gt;MovePenTo(BPoint(hIconOffset - leftText + 2,</a>
<a name="ln1405">					fIconRect.Height() + (fontHeight.ascent + 2)));</a>
<a name="ln1406">				view-&gt;DrawString(nameString.String());</a>
<a name="ln1407"> </a>
<a name="ln1408">				view-&gt;Sync();</a>
<a name="ln1409">				dragBitmap-&gt;Unlock();</a>
<a name="ln1410"> </a>
<a name="ln1411">				BMessage dragMessage(B_REFS_RECEIVED);</a>
<a name="ln1412">				dragMessage.AddPoint(&quot;click_pt&quot;, fClickPoint);</a>
<a name="ln1413">				BPoint tmpLoc;</a>
<a name="ln1414">				uint32 button;</a>
<a name="ln1415">				GetMouse(&amp;tmpLoc, &amp;button);</a>
<a name="ln1416">				if (button)</a>
<a name="ln1417">					dragMessage.AddInt32(&quot;buttons&quot;, (int32)button);</a>
<a name="ln1418"> </a>
<a name="ln1419">				dragMessage.AddInt32(&quot;be:actions&quot;,</a>
<a name="ln1420">					(modifiers() &amp; B_OPTION_KEY) != 0</a>
<a name="ln1421">						? B_COPY_TARGET : B_MOVE_TARGET);</a>
<a name="ln1422">				dragMessage.AddRef(&quot;refs&quot;, fModel-&gt;EntryRef());</a>
<a name="ln1423">				DragMessage(&amp;dragMessage, dragBitmap, B_OP_ALPHA,</a>
<a name="ln1424">					BPoint((fClickPoint.x - fIconRect.left)</a>
<a name="ln1425">					+ hIconOffset, fClickPoint.y - fIconRect.top), this);</a>
<a name="ln1426">				fDragging = true;</a>
<a name="ln1427">			}</a>
<a name="ln1428">			break;</a>
<a name="ln1429"> </a>
<a name="ln1430">		case open_only_track :</a>
<a name="ln1431">			// Special type of entry that can't be renamed or drag and dropped</a>
<a name="ln1432">			// It can only be opened by double clicking on the icon</a>
<a name="ln1433">			break;</a>
<a name="ln1434"> </a>
<a name="ln1435">		default:</a>
<a name="ln1436">		{</a>
<a name="ln1437">			// Only consider this if the window is the active window.</a>
<a name="ln1438">			// We have to manually get the mouse here in the event that the</a>
<a name="ln1439">			// mouse is over a pop-up window</a>
<a name="ln1440">			uint32 buttons;</a>
<a name="ln1441">			BPoint point;</a>
<a name="ln1442">			GetMouse(&amp;point, &amp;buttons);</a>
<a name="ln1443">			if (Window()-&gt;IsActive() &amp;&amp; !buttons) {</a>
<a name="ln1444">				// If we are down here, then that means that we're tracking</a>
<a name="ln1445">				// the mouse but not from a mouse down. In this case, we're</a>
<a name="ln1446">				// just interested in knowing whether or not we need to</a>
<a name="ln1447">				// display the &quot;pop-up&quot; version of the path or link text.</a>
<a name="ln1448">				BScreen screen(Window());</a>
<a name="ln1449">				BFont font;</a>
<a name="ln1450">				GetFont(&amp;font);</a>
<a name="ln1451">				float maxWidth = (Bounds().Width()</a>
<a name="ln1452">					- (fDivider + kBorderMargin));</a>
<a name="ln1453"> </a>
<a name="ln1454">				if (fPathRect.Contains(point)) {</a>
<a name="ln1455">					if (fCurrentPathColorWhich != B_LINK_HOVER_COLOR)</a>
<a name="ln1456">						fCurrentPathColorWhich = B_LINK_HOVER_COLOR;</a>
<a name="ln1457"> </a>
<a name="ln1458">					if (font.StringWidth(fPathStr.String()) &gt; maxWidth) {</a>
<a name="ln1459">						fTrackingState = no_track;</a>
<a name="ln1460">						BRect rect(fPathRect);</a>
<a name="ln1461">						rect.OffsetBy(Window()-&gt;Frame().left,</a>
<a name="ln1462">							Window()-&gt;Frame().top);</a>
<a name="ln1463"> </a>
<a name="ln1464">						if (fPathWindow == NULL</a>
<a name="ln1465">							|| BMessenger(fPathWindow).IsValid() == false) {</a>
<a name="ln1466">							fPathWindow = OpenToolTipWindow(screen, rect,</a>
<a name="ln1467">								&quot;fPathWindow&quot;, fPathStr.String(),</a>
<a name="ln1468">								BMessenger(this),</a>
<a name="ln1469">								new BMessage(kOpenLinkSource));</a>
<a name="ln1470">						}</a>
<a name="ln1471">					}</a>
<a name="ln1472">				} else if (fLinkRect.Contains(point)) {</a>
<a name="ln1473"> </a>
<a name="ln1474">					if (fCurrentLinkColorWhich != B_LINK_HOVER_COLOR)</a>
<a name="ln1475">						fCurrentLinkColorWhich = B_LINK_HOVER_COLOR;</a>
<a name="ln1476"> </a>
<a name="ln1477">					if (font.StringWidth(fLinkToStr.String()) &gt; maxWidth) {</a>
<a name="ln1478">						fTrackingState = no_track;</a>
<a name="ln1479">						BRect rect(fLinkRect);</a>
<a name="ln1480">						rect.OffsetBy(Window()-&gt;Frame().left,</a>
<a name="ln1481">							Window()-&gt;Frame().top);</a>
<a name="ln1482"> </a>
<a name="ln1483">						if (!fLinkWindow</a>
<a name="ln1484">							|| BMessenger(fLinkWindow).IsValid() == false) {</a>
<a name="ln1485">							fLinkWindow = OpenToolTipWindow(screen, rect,</a>
<a name="ln1486">								&quot;fLinkWindow&quot;, fLinkToStr.String(),</a>
<a name="ln1487">								BMessenger(this),</a>
<a name="ln1488">								new BMessage(kOpenLinkTarget));</a>
<a name="ln1489">						}</a>
<a name="ln1490">					}</a>
<a name="ln1491">				} else if (fDescRect.Contains(point)</a>
<a name="ln1492">					&amp;&amp; font.StringWidth(fDescStr.String()) &gt; maxWidth) {</a>
<a name="ln1493">					fTrackingState = no_track;</a>
<a name="ln1494">					BRect rect(fDescRect);</a>
<a name="ln1495">					rect.OffsetBy(Window()-&gt;Frame().left,</a>
<a name="ln1496">						Window()-&gt;Frame().top);</a>
<a name="ln1497"> </a>
<a name="ln1498">					if (!fDescWindow</a>
<a name="ln1499">						|| BMessenger(fDescWindow).IsValid() == false) {</a>
<a name="ln1500">						fDescWindow = OpenToolTipWindow(screen, rect,</a>
<a name="ln1501">							&quot;fDescWindow&quot;, fDescStr.String(),</a>
<a name="ln1502">							BMessenger(this), NULL);</a>
<a name="ln1503">					}</a>
<a name="ln1504">				}</a>
<a name="ln1505">			}</a>
<a name="ln1506">			break;</a>
<a name="ln1507">		}</a>
<a name="ln1508">	}</a>
<a name="ln1509"> </a>
<a name="ln1510">	DelayedInvalidate(16666, fPathRect);</a>
<a name="ln1511">	DelayedInvalidate(16666, fLinkRect);</a>
<a name="ln1512">}</a>
<a name="ln1513"> </a>
<a name="ln1514"> </a>
<a name="ln1515">void</a>
<a name="ln1516">AttributeView::OpenLinkSource()</a>
<a name="ln1517">{</a>
<a name="ln1518">	OpenParentAndSelectOriginal(fModel-&gt;EntryRef());</a>
<a name="ln1519">}</a>
<a name="ln1520"> </a>
<a name="ln1521"> </a>
<a name="ln1522">void</a>
<a name="ln1523">AttributeView::OpenLinkTarget()</a>
<a name="ln1524">{</a>
<a name="ln1525">	Model resolvedModel(fModel-&gt;EntryRef(), true, true);</a>
<a name="ln1526">	BEntry entry;</a>
<a name="ln1527">	if (resolvedModel.InitCheck() == B_OK) {</a>
<a name="ln1528">		// Get the path of the link</a>
<a name="ln1529">		BPath traversedPath;</a>
<a name="ln1530">		resolvedModel.GetPath(&amp;traversedPath);</a>
<a name="ln1531"> </a>
<a name="ln1532">		// If the BPath is initialized, then check the file for existence</a>
<a name="ln1533">		if (traversedPath.InitCheck() == B_OK)</a>
<a name="ln1534">			entry.SetTo(traversedPath.Path());</a>
<a name="ln1535">	}</a>
<a name="ln1536">	if (entry.InitCheck() != B_OK || !entry.Exists()) {</a>
<a name="ln1537">		// Open a file dialog panel to allow the user to relink.</a>
<a name="ln1538">		BInfoWindow* window = dynamic_cast&lt;BInfoWindow*&gt;(Window());</a>
<a name="ln1539">		if (window != NULL)</a>
<a name="ln1540">			window-&gt;OpenFilePanel(fModel-&gt;EntryRef());</a>
<a name="ln1541">	} else {</a>
<a name="ln1542">		entry_ref ref;</a>
<a name="ln1543">		entry.GetRef(&amp;ref);</a>
<a name="ln1544">		BPath path(&amp;ref);</a>
<a name="ln1545">		printf(&quot;Opening link target: %s\n&quot;, path.Path());</a>
<a name="ln1546">		OpenParentAndSelectOriginal(&amp;ref);</a>
<a name="ln1547">	}</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>
<a name="ln1550"> </a>
<a name="ln1551">void</a>
<a name="ln1552">AttributeView::MouseUp(BPoint where)</a>
<a name="ln1553">{</a>
<a name="ln1554">	// Are we in the link rect?</a>
<a name="ln1555">	if (fTrackingState == link_track &amp;&amp; fLinkRect.Contains(where)) {</a>
<a name="ln1556">		InvertRect(fLinkRect);</a>
<a name="ln1557">		OpenLinkTarget();</a>
<a name="ln1558">	} else if (fTrackingState == path_track &amp;&amp; fPathRect.Contains(where)) {</a>
<a name="ln1559">		InvertRect(fPathRect);</a>
<a name="ln1560">		OpenLinkSource();</a>
<a name="ln1561">	} else if ((fTrackingState == icon_track</a>
<a name="ln1562">			|| fTrackingState == open_only_track)</a>
<a name="ln1563">		&amp;&amp; fIconRect.Contains(where)) {</a>
<a name="ln1564">		// If it was a double click, then tell Tracker to open the item</a>
<a name="ln1565">		// The CurrentMessage() here does* not* have a &quot;clicks&quot; field,</a>
<a name="ln1566">		// which is why we are tracking the clicks with this temp var</a>
<a name="ln1567">		if (fDoubleClick) {</a>
<a name="ln1568">			// Double click, launch.</a>
<a name="ln1569">			BMessage message(B_REFS_RECEIVED);</a>
<a name="ln1570">			message.AddRef(&quot;refs&quot;, fModel-&gt;EntryRef());</a>
<a name="ln1571"> </a>
<a name="ln1572">			// add a messenger to the launch message that will be used to</a>
<a name="ln1573">			// dispatch scripting calls from apps to the PoseView</a>
<a name="ln1574">			message.AddMessenger(&quot;TrackerViewToken&quot;, BMessenger(this));</a>
<a name="ln1575">			be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln1576">			fDoubleClick = false;</a>
<a name="ln1577">		}</a>
<a name="ln1578">	} else if (fTrackingState == size_track &amp;&amp; fSizeRect.Contains(where)) {</a>
<a name="ln1579">		// Recalculate size</a>
<a name="ln1580">		Window()-&gt;PostMessage(kRecalculateSize);</a>
<a name="ln1581">	}</a>
<a name="ln1582"> </a>
<a name="ln1583">	// End mouse tracking</a>
<a name="ln1584">	fMouseDown = false;</a>
<a name="ln1585">	fDragging = false;</a>
<a name="ln1586">	fTrackingState = no_track;</a>
<a name="ln1587"> </a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590"> </a>
<a name="ln1591">void</a>
<a name="ln1592">AttributeView::CheckAndSetSize()</a>
<a name="ln1593">{</a>
<a name="ln1594">	if (fModel-&gt;IsVolume() || fModel-&gt;IsRoot()) {</a>
<a name="ln1595">		off_t freeBytes = 0;</a>
<a name="ln1596">		off_t capacity = 0;</a>
<a name="ln1597"> </a>
<a name="ln1598">		if (fModel-&gt;IsVolume()) {</a>
<a name="ln1599">			BVolume volume(fModel-&gt;NodeRef()-&gt;device);</a>
<a name="ln1600">			freeBytes = volume.FreeBytes();</a>
<a name="ln1601">			capacity = volume.Capacity();</a>
<a name="ln1602">		} else {</a>
<a name="ln1603">			// iterate over all volumes</a>
<a name="ln1604">			BVolumeRoster volumeRoster;</a>
<a name="ln1605">			BVolume volume;</a>
<a name="ln1606">			while (volumeRoster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln1607">				freeBytes += volume.FreeBytes();</a>
<a name="ln1608">				capacity += volume.Capacity();</a>
<a name="ln1609">			}</a>
<a name="ln1610">		}</a>
<a name="ln1611"> </a>
<a name="ln1612">		if (fFreeBytes == freeBytes)</a>
<a name="ln1613">			return;</a>
<a name="ln1614"> </a>
<a name="ln1615">		fFreeBytes = freeBytes;</a>
<a name="ln1616"> </a>
<a name="ln1617">		fSizeString.SetTo(B_TRANSLATE(&quot;%capacity (%used used -- %free free)&quot;));</a>
<a name="ln1618"> </a>
<a name="ln1619">		char sizeStr[128];</a>
<a name="ln1620">		string_for_size(capacity, sizeStr, sizeof(sizeStr));</a>
<a name="ln1621">		fSizeString.ReplaceFirst(&quot;%capacity&quot;, sizeStr);</a>
<a name="ln1622">		string_for_size(capacity - fFreeBytes, sizeStr, sizeof(sizeStr));</a>
<a name="ln1623">		fSizeString.ReplaceFirst(&quot;%used&quot;, sizeStr);</a>
<a name="ln1624">		string_for_size(fFreeBytes, sizeStr, sizeof(sizeStr));</a>
<a name="ln1625">		fSizeString.ReplaceFirst(&quot;%free&quot;, sizeStr);</a>
<a name="ln1626"> </a>
<a name="ln1627">	} else if (fModel-&gt;IsFile()) {</a>
<a name="ln1628">		// poll for size changes because they do not get node monitored</a>
<a name="ln1629">		// until a file gets closed (with the old BFS)</a>
<a name="ln1630">		StatStruct statBuf;</a>
<a name="ln1631">		BModelOpener opener(fModel);</a>
<a name="ln1632"> </a>
<a name="ln1633">		if (fModel-&gt;InitCheck() != B_OK</a>
<a name="ln1634">			|| fModel-&gt;Node()-&gt;GetStat(&amp;statBuf) != B_OK) {</a>
<a name="ln1635">			return;</a>
<a name="ln1636">		}</a>
<a name="ln1637"> </a>
<a name="ln1638">		if (fLastSize == statBuf.st_size)</a>
<a name="ln1639">			return;</a>
<a name="ln1640"> </a>
<a name="ln1641">		fLastSize = statBuf.st_size;</a>
<a name="ln1642">		fSizeString = &quot;&quot;;</a>
<a name="ln1643">		BInfoWindow::GetSizeString(fSizeString, fLastSize, 0);</a>
<a name="ln1644">	} else</a>
<a name="ln1645">		return;</a>
<a name="ln1646"> </a>
<a name="ln1647">	BRect bounds(Bounds());</a>
<a name="ln1648">	float lineHeight = CurrentFontHeight() + 2;</a>
<a name="ln1649">	bounds.Set(fDivider, fIconRect.bottom, bounds.right,</a>
<a name="ln1650">		fIconRect.bottom + lineHeight);</a>
<a name="ln1651">	Invalidate(bounds);</a>
<a name="ln1652">}</a>
<a name="ln1653"> </a>
<a name="ln1654"> </a>
<a name="ln1655">void</a>
<a name="ln1656">AttributeView::MessageReceived(BMessage* message)</a>
<a name="ln1657">{</a>
<a name="ln1658">	if (message-&gt;WasDropped()</a>
<a name="ln1659">		&amp;&amp; message-&gt;what == B_SIMPLE_DATA</a>
<a name="ln1660">		&amp;&amp; message-&gt;ReturnAddress() != BMessenger(this)</a>
<a name="ln1661">		&amp;&amp; fIconRect.Contains(ConvertFromScreen(message-&gt;DropPoint()))</a>
<a name="ln1662">		&amp;&amp; BPoseView::CanHandleDragSelection(fModel, message,</a>
<a name="ln1663">			(modifiers() &amp; B_CONTROL_KEY) != 0)) {</a>
<a name="ln1664">		BPoseView::HandleDropCommon(message, fModel, 0, this,</a>
<a name="ln1665">			message-&gt;DropPoint());</a>
<a name="ln1666">		Invalidate(fIconRect);</a>
<a name="ln1667">		return;</a>
<a name="ln1668">	}</a>
<a name="ln1669"> </a>
<a name="ln1670">	switch (message-&gt;what) {</a>
<a name="ln1671">		case kSetPreferredApp:</a>
<a name="ln1672">		{</a>
<a name="ln1673">			BNode node(fModel-&gt;EntryRef());</a>
<a name="ln1674">			BNodeInfo nodeInfo(&amp;node);</a>
<a name="ln1675"> </a>
<a name="ln1676">			const char* newSignature;</a>
<a name="ln1677">			if (message-&gt;FindString(&quot;signature&quot;, &amp;newSignature) != B_OK)</a>
<a name="ln1678">				newSignature = NULL;</a>
<a name="ln1679"> </a>
<a name="ln1680">			fModel-&gt;SetPreferredAppSignature(newSignature);</a>
<a name="ln1681">			nodeInfo.SetPreferredApp(newSignature);</a>
<a name="ln1682">			break;</a>
<a name="ln1683">		}</a>
<a name="ln1684"> </a>
<a name="ln1685">		case kOpenLinkSource:</a>
<a name="ln1686">			OpenLinkSource();</a>
<a name="ln1687">			break;</a>
<a name="ln1688"> </a>
<a name="ln1689">		case kOpenLinkTarget:</a>
<a name="ln1690">			OpenLinkTarget();</a>
<a name="ln1691">			break;</a>
<a name="ln1692"> </a>
<a name="ln1693">		default:</a>
<a name="ln1694">			_inherited::MessageReceived(message);</a>
<a name="ln1695">			break;</a>
<a name="ln1696">	}</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699"> </a>
<a name="ln1700">void</a>
<a name="ln1701">AttributeView::Draw(BRect)</a>
<a name="ln1702">{</a>
<a name="ln1703">	// Set the low color for anti-aliasing</a>
<a name="ln1704">	SetLowColor(ui_color(B_PANEL_BACKGROUND_COLOR));</a>
<a name="ln1705"> </a>
<a name="ln1706">	// Clear the old contents</a>
<a name="ln1707">	SetHighColor(ui_color(B_PANEL_BACKGROUND_COLOR));</a>
<a name="ln1708">	FillRect(Bounds());</a>
<a name="ln1709"> </a>
<a name="ln1710">	rgb_color labelColor = ui_color(B_PANEL_TEXT_COLOR);</a>
<a name="ln1711">	rgb_color attributeColor = mix_color(HighColor(), labelColor, 192);</a>
<a name="ln1712"> </a>
<a name="ln1713">	// Draw the dark grey area on the left</a>
<a name="ln1714">	BRect drawBounds(Bounds());</a>
<a name="ln1715">	drawBounds.right = kBorderWidth;</a>
<a name="ln1716">	SetHighUIColor(B_PANEL_BACKGROUND_COLOR, B_DARKEN_2_TINT);</a>
<a name="ln1717">	FillRect(drawBounds);</a>
<a name="ln1718"> </a>
<a name="ln1719">	// Draw the icon, straddling the border</a>
<a name="ln1720">	SetDrawingMode(B_OP_OVER);</a>
<a name="ln1721">	IconCache::sIconCache-&gt;Draw(fIconModel, this, fIconRect.LeftTop(),</a>
<a name="ln1722">		kNormalIcon, B_LARGE_ICON, true);</a>
<a name="ln1723">	SetDrawingMode(B_OP_COPY);</a>
<a name="ln1724">	// Font information</a>
<a name="ln1725">	font_height fontMetrics;</a>
<a name="ln1726">	BFont currentFont;</a>
<a name="ln1727">	float lineHeight = 0;</a>
<a name="ln1728">	float lineBase = 0;</a>
<a name="ln1729">	// Draw the main title if the user is not currently editing it</a>
<a name="ln1730">	if (fTitleEditView == NULL) {</a>
<a name="ln1731">		SetFont(be_bold_font);</a>
<a name="ln1732">		SetFontSize(be_bold_font-&gt;Size());</a>
<a name="ln1733">		GetFont(&amp;currentFont);</a>
<a name="ln1734">		currentFont.GetHeight(&amp;fontMetrics);</a>
<a name="ln1735">		lineHeight = CurrentFontHeight() + 5;</a>
<a name="ln1736">		lineBase = fTitleRect.bottom - fontMetrics.descent;</a>
<a name="ln1737">		SetHighColor(labelColor);</a>
<a name="ln1738">		MovePenTo(BPoint(fIconRect.right + 6, lineBase));</a>
<a name="ln1739"> </a>
<a name="ln1740">		// Recalculate the rect width</a>
<a name="ln1741">		fTitleRect.right = min_c(</a>
<a name="ln1742">				fTitleRect.left + currentFont.StringWidth(fModel-&gt;Name()),</a>
<a name="ln1743">			Bounds().Width() - 5);</a>
<a name="ln1744">		// Check for possible need of truncation</a>
<a name="ln1745">		if (StringWidth(fModel-&gt;Name()) &gt; fTitleRect.Width()) {</a>
<a name="ln1746">			BString nameString(fModel-&gt;Name());</a>
<a name="ln1747">			TruncateString(&amp;nameString, B_TRUNCATE_END,</a>
<a name="ln1748">				fTitleRect.Width() - 2);</a>
<a name="ln1749">			DrawString(nameString.String());</a>
<a name="ln1750">		} else</a>
<a name="ln1751">			DrawString(fModel-&gt;Name());</a>
<a name="ln1752">	}</a>
<a name="ln1753"> </a>
<a name="ln1754">	// Draw the attribute font stuff</a>
<a name="ln1755">	SetFont(be_plain_font);</a>
<a name="ln1756">	GetFontHeight(&amp;fontMetrics);</a>
<a name="ln1757">	lineHeight = CurrentFontHeight() + 5;</a>
<a name="ln1758"> </a>
<a name="ln1759">	// Starting base line for the first string</a>
<a name="ln1760">	lineBase = fTitleRect.bottom + lineHeight;</a>
<a name="ln1761"> </a>
<a name="ln1762">	// Capacity/size</a>
<a name="ln1763">	SetHighColor(labelColor);</a>
<a name="ln1764">	if (fModel-&gt;IsVolume() || fModel-&gt;IsRoot()) {</a>
<a name="ln1765">		MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Capacity:&quot;))),</a>
<a name="ln1766">			lineBase));</a>
<a name="ln1767">		DrawString(B_TRANSLATE(&quot;Capacity:&quot;));</a>
<a name="ln1768">	} else {</a>
<a name="ln1769">		MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Size:&quot;))),</a>
<a name="ln1770">			lineBase));</a>
<a name="ln1771">		fSizeRect.left = fDivider + 2;</a>
<a name="ln1772">		fSizeRect.top = lineBase - fontMetrics.ascent;</a>
<a name="ln1773">		fSizeRect.bottom = lineBase + fontMetrics.descent;</a>
<a name="ln1774">		DrawString(B_TRANSLATE(&quot;Size:&quot;));</a>
<a name="ln1775">	}</a>
<a name="ln1776"> </a>
<a name="ln1777">	MovePenTo(BPoint(fDivider + kDrawMargin, lineBase));</a>
<a name="ln1778">	SetHighColor(attributeColor);</a>
<a name="ln1779">	// Check for possible need of truncation</a>
<a name="ln1780">	if (StringWidth(fSizeString.String())</a>
<a name="ln1781">			&gt; (Bounds().Width() - (fDivider + kBorderMargin))) {</a>
<a name="ln1782">		BString tmpString(fSizeString.String());</a>
<a name="ln1783">		TruncateString(&amp;tmpString, B_TRUNCATE_MIDDLE,</a>
<a name="ln1784">			Bounds().Width() - (fDivider + kBorderMargin));</a>
<a name="ln1785">		DrawString(tmpString.String());</a>
<a name="ln1786">		fSizeRect.right = fSizeRect.left + StringWidth(tmpString.String())</a>
<a name="ln1787">			+ 3;</a>
<a name="ln1788">	} else {</a>
<a name="ln1789">		DrawString(fSizeString.String());</a>
<a name="ln1790">		fSizeRect.right = fSizeRect.left + StringWidth(fSizeString.String()) + 3;</a>
<a name="ln1791">	}</a>
<a name="ln1792">	lineBase += lineHeight;</a>
<a name="ln1793"> </a>
<a name="ln1794">	// Created</a>
<a name="ln1795">	SetHighColor(labelColor);</a>
<a name="ln1796">	MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Created:&quot;))),</a>
<a name="ln1797">		lineBase));</a>
<a name="ln1798">	DrawString(B_TRANSLATE(&quot;Created:&quot;));</a>
<a name="ln1799">	MovePenTo(BPoint(fDivider + kDrawMargin, lineBase));</a>
<a name="ln1800">	SetHighColor(attributeColor);</a>
<a name="ln1801">	DrawString(fCreatedStr.String());</a>
<a name="ln1802">	lineBase += lineHeight;</a>
<a name="ln1803"> </a>
<a name="ln1804">	// Modified</a>
<a name="ln1805">	MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Modified:&quot;))),</a>
<a name="ln1806">		lineBase));</a>
<a name="ln1807">	SetHighColor(labelColor);</a>
<a name="ln1808">	DrawString(B_TRANSLATE(&quot;Modified:&quot;));</a>
<a name="ln1809">	MovePenTo(BPoint(fDivider + kDrawMargin, lineBase));</a>
<a name="ln1810">	SetHighColor(attributeColor);</a>
<a name="ln1811">	DrawString(fModifiedStr.String());</a>
<a name="ln1812">	lineBase += lineHeight;</a>
<a name="ln1813"> </a>
<a name="ln1814">	// Kind</a>
<a name="ln1815">	MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Kind:&quot;))),</a>
<a name="ln1816">		lineBase));</a>
<a name="ln1817">	SetHighColor(labelColor);</a>
<a name="ln1818">	DrawString(B_TRANSLATE(&quot;Kind:&quot;));</a>
<a name="ln1819">	MovePenTo(BPoint(fDivider + kDrawMargin, lineBase));</a>
<a name="ln1820">	SetHighColor(attributeColor);</a>
<a name="ln1821">	DrawString(fKindStr.String());</a>
<a name="ln1822">	lineBase += lineHeight;</a>
<a name="ln1823"> </a>
<a name="ln1824">	BFont normalFont;</a>
<a name="ln1825">	GetFont(&amp;normalFont);</a>
<a name="ln1826"> </a>
<a name="ln1827">	// Path</a>
<a name="ln1828">	MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Location:&quot;))),</a>
<a name="ln1829">		lineBase));</a>
<a name="ln1830">	SetHighColor(labelColor);</a>
<a name="ln1831">	DrawString(B_TRANSLATE(&quot;Location:&quot;));</a>
<a name="ln1832"> </a>
<a name="ln1833">	MovePenTo(BPoint(fDivider + kDrawMargin, lineBase));</a>
<a name="ln1834">	SetHighUIColor(fCurrentPathColorWhich);</a>
<a name="ln1835"> </a>
<a name="ln1836">	// Check for truncation</a>
<a name="ln1837">	if (StringWidth(fPathStr.String()) &gt; (Bounds().Width()</a>
<a name="ln1838">			- (fDivider + kBorderMargin))) {</a>
<a name="ln1839">		BString nameString(fPathStr.String());</a>
<a name="ln1840">		TruncateString(&amp;nameString, B_TRUNCATE_MIDDLE,</a>
<a name="ln1841">			Bounds().Width() - (fDivider + kBorderMargin));</a>
<a name="ln1842">		DrawString(nameString.String());</a>
<a name="ln1843">	} else</a>
<a name="ln1844">		DrawString(fPathStr.String());</a>
<a name="ln1845"> </a>
<a name="ln1846">	// Cache the position of the path</a>
<a name="ln1847">	fPathRect.top = lineBase - fontMetrics.ascent;</a>
<a name="ln1848">	fPathRect.bottom = lineBase + fontMetrics.descent;</a>
<a name="ln1849">	fPathRect.left = fDivider + 2;</a>
<a name="ln1850">	fPathRect.right = fPathRect.left + StringWidth(fPathStr.String()) + 3;</a>
<a name="ln1851"> </a>
<a name="ln1852">	lineBase += lineHeight;</a>
<a name="ln1853"> </a>
<a name="ln1854">	// Link to/version</a>
<a name="ln1855">	if (fModel-&gt;IsSymLink()) {</a>
<a name="ln1856">		MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Link to:&quot;))),</a>
<a name="ln1857">			lineBase));</a>
<a name="ln1858">		SetHighColor(labelColor);</a>
<a name="ln1859">		DrawString(B_TRANSLATE(&quot;Link to:&quot;));</a>
<a name="ln1860">		MovePenTo(BPoint(fDivider + kDrawMargin, lineBase));</a>
<a name="ln1861">		SetHighUIColor(fCurrentLinkColorWhich);</a>
<a name="ln1862"> </a>
<a name="ln1863">		// Check for truncation</a>
<a name="ln1864">		if (StringWidth(fLinkToStr.String()) &gt; (Bounds().Width()</a>
<a name="ln1865">				- (fDivider + kBorderMargin))) {</a>
<a name="ln1866">			BString nameString(fLinkToStr.String());</a>
<a name="ln1867">			TruncateString(&amp;nameString, B_TRUNCATE_MIDDLE,</a>
<a name="ln1868">				Bounds().Width() - (fDivider + kBorderMargin));</a>
<a name="ln1869">			DrawString(nameString.String());</a>
<a name="ln1870">		} else</a>
<a name="ln1871">			DrawString(fLinkToStr.String());</a>
<a name="ln1872"> </a>
<a name="ln1873">		// Cache the position of the link field</a>
<a name="ln1874">		fLinkRect.top = lineBase - fontMetrics.ascent;</a>
<a name="ln1875">		fLinkRect.bottom = lineBase + fontMetrics.descent;</a>
<a name="ln1876">		fLinkRect.left = fDivider + 2;</a>
<a name="ln1877">		fLinkRect.right = fLinkRect.left + StringWidth(fLinkToStr.String())</a>
<a name="ln1878">			+ 3;</a>
<a name="ln1879"> </a>
<a name="ln1880">		// No description field</a>
<a name="ln1881">		fDescRect = BRect(-1, -1, -1, -1);</a>
<a name="ln1882">	} else if (fModel-&gt;IsExecutable()) {</a>
<a name="ln1883">		//Version</a>
<a name="ln1884">		MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Version:&quot;))),</a>
<a name="ln1885">			lineBase));</a>
<a name="ln1886">		SetHighColor(labelColor);</a>
<a name="ln1887">		DrawString(B_TRANSLATE(&quot;Version:&quot;));</a>
<a name="ln1888">		MovePenTo(BPoint(fDivider + kDrawMargin, lineBase));</a>
<a name="ln1889">		SetHighColor(attributeColor);</a>
<a name="ln1890">		BString nameString;</a>
<a name="ln1891">		if (fModel-&gt;GetVersionString(nameString, B_APP_VERSION_KIND) == B_OK)</a>
<a name="ln1892">			DrawString(nameString.String());</a>
<a name="ln1893">		else</a>
<a name="ln1894">			DrawString(&quot;-&quot;);</a>
<a name="ln1895">		lineBase += lineHeight;</a>
<a name="ln1896"> </a>
<a name="ln1897">		// Description</a>
<a name="ln1898">		MovePenTo(BPoint(fDivider - (StringWidth(B_TRANSLATE(&quot;Description:&quot;))),</a>
<a name="ln1899">			lineBase));</a>
<a name="ln1900">		SetHighColor(labelColor);</a>
<a name="ln1901">		DrawString(B_TRANSLATE(&quot;Description:&quot;));</a>
<a name="ln1902">		MovePenTo(BPoint(fDivider + kDrawMargin, lineBase));</a>
<a name="ln1903">		SetHighColor(attributeColor);</a>
<a name="ln1904">		// Check for truncation</a>
<a name="ln1905">		if (StringWidth(fDescStr.String()) &gt; (Bounds().Width()</a>
<a name="ln1906">				- (fDivider + kBorderMargin))) {</a>
<a name="ln1907">			BString nameString(fDescStr.String());</a>
<a name="ln1908">			TruncateString(&amp;nameString, B_TRUNCATE_MIDDLE,</a>
<a name="ln1909">				Bounds().Width() - (fDivider + kBorderMargin));</a>
<a name="ln1910">			DrawString(nameString.String());</a>
<a name="ln1911">		} else</a>
<a name="ln1912">			DrawString(fDescStr.String());</a>
<a name="ln1913"> </a>
<a name="ln1914">		// Cache the position of the description field</a>
<a name="ln1915">		fDescRect.top = lineBase - fontMetrics.ascent;</a>
<a name="ln1916">		fDescRect.bottom = lineBase + fontMetrics.descent;</a>
<a name="ln1917">		fDescRect.left = fDivider + 2;</a>
<a name="ln1918">		fDescRect.right = fDescRect.left + StringWidth(fDescStr.String()) + 3;</a>
<a name="ln1919"> </a>
<a name="ln1920">		// No link field</a>
<a name="ln1921">		fLinkRect = BRect(-1, -1, -1, -1);</a>
<a name="ln1922">	}</a>
<a name="ln1923">}</a>
<a name="ln1924"> </a>
<a name="ln1925"> </a>
<a name="ln1926">void</a>
<a name="ln1927">AttributeView::BeginEditingTitle()</a>
<a name="ln1928">{</a>
<a name="ln1929">	if (fTitleEditView != NULL)</a>
<a name="ln1930">		return;</a>
<a name="ln1931"> </a>
<a name="ln1932">	BFont font(be_plain_font);</a>
<a name="ln1933">	font.SetSize(font.Size() + 2);</a>
<a name="ln1934">	BRect textFrame(fTitleRect);</a>
<a name="ln1935">	textFrame.right = Bounds().Width() - 5;</a>
<a name="ln1936">	BRect textRect(textFrame);</a>
<a name="ln1937">	textRect.OffsetTo(0, 0);</a>
<a name="ln1938">	textRect.InsetBy(1, 1);</a>
<a name="ln1939"> </a>
<a name="ln1940">	// Just make it some really large size, since we don't do any line</a>
<a name="ln1941">	// wrapping. The text filter will make sure to scroll the cursor</a>
<a name="ln1942">	// into position</a>
<a name="ln1943"> </a>
<a name="ln1944">	textRect.right = 2000;</a>
<a name="ln1945">	fTitleEditView = new BTextView(textFrame, &quot;text_editor&quot;,</a>
<a name="ln1946">		textRect, &amp;font, 0, B_FOLLOW_ALL, B_WILL_DRAW);</a>
<a name="ln1947">	fTitleEditView-&gt;SetText(fModel-&gt;Name());</a>
<a name="ln1948">	DisallowFilenameKeys(fTitleEditView);</a>
<a name="ln1949"> </a>
<a name="ln1950">	// Reset the width of the text rect</a>
<a name="ln1951">	textRect = fTitleEditView-&gt;TextRect();</a>
<a name="ln1952">	textRect.right = fTitleEditView-&gt;LineWidth() + 20;</a>
<a name="ln1953">	fTitleEditView-&gt;SetTextRect(textRect);</a>
<a name="ln1954">	fTitleEditView-&gt;SetWordWrap(false);</a>
<a name="ln1955">	// Add filter for catching B_RETURN and B_ESCAPE key's</a>
<a name="ln1956">	fTitleEditView-&gt;AddFilter(</a>
<a name="ln1957">		new BMessageFilter(B_KEY_DOWN, AttributeView::TextViewFilter));</a>
<a name="ln1958"> </a>
<a name="ln1959">	BScrollView* scrollView = new BScrollView(&quot;BorderView&quot;, fTitleEditView,</a>
<a name="ln1960">		0, 0, false, false, B_PLAIN_BORDER);</a>
<a name="ln1961">	AddChild(scrollView);</a>
<a name="ln1962">	fTitleEditView-&gt;SelectAll();</a>
<a name="ln1963">	fTitleEditView-&gt;MakeFocus();</a>
<a name="ln1964"> </a>
<a name="ln1965">	Window()-&gt;UpdateIfNeeded();</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968"> </a>
<a name="ln1969">void</a>
<a name="ln1970">AttributeView::FinishEditingTitle(bool commit)</a>
<a name="ln1971">{</a>
<a name="ln1972">	if (fTitleEditView == NULL)</a>
<a name="ln1973">		return;</a>
<a name="ln1974"> </a>
<a name="ln1975">	bool reopen = false;</a>
<a name="ln1976"> </a>
<a name="ln1977">	const char* text = fTitleEditView-&gt;Text();</a>
<a name="ln1978">	uint32 length = strlen(text);</a>
<a name="ln1979">	if (commit &amp;&amp; strcmp(text, fModel-&gt;Name()) != 0</a>
<a name="ln1980">		&amp;&amp; length &lt; B_FILE_NAME_LENGTH) {</a>
<a name="ln1981">		BEntry entry(fModel-&gt;EntryRef());</a>
<a name="ln1982">		BDirectory parent;</a>
<a name="ln1983">		if (entry.InitCheck() == B_OK</a>
<a name="ln1984">			&amp;&amp; entry.GetParent(&amp;parent) == B_OK) {</a>
<a name="ln1985">			if (parent.Contains(text)) {</a>
<a name="ln1986">				BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1987">					B_TRANSLATE(&quot;That name is already taken. &quot;</a>
<a name="ln1988">					&quot;Please type another one.&quot;),</a>
<a name="ln1989">					B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln1990">					0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1991">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1992">				alert-&gt;Go();</a>
<a name="ln1993">				reopen = true;</a>
<a name="ln1994">			} else {</a>
<a name="ln1995">				if (fModel-&gt;IsVolume()) {</a>
<a name="ln1996">					BVolume	volume(fModel-&gt;NodeRef()-&gt;device);</a>
<a name="ln1997">					if (volume.InitCheck() == B_OK)</a>
<a name="ln1998">						volume.SetName(text);</a>
<a name="ln1999">				} else</a>
<a name="ln2000">					entry.Rename(text);</a>
<a name="ln2001"> </a>
<a name="ln2002">				// Adjust the size of the text rect</a>
<a name="ln2003">				BFont currentFont(be_plain_font);</a>
<a name="ln2004">				currentFont.SetSize(currentFont.Size() + 2);</a>
<a name="ln2005">				fTitleRect.right = min_c(fTitleRect.left</a>
<a name="ln2006">						+ currentFont.StringWidth(fTitleEditView-&gt;Text()),</a>
<a name="ln2007">					Bounds().Width() - 5);</a>
<a name="ln2008">			}</a>
<a name="ln2009">		}</a>
<a name="ln2010">	} else if (length &gt;= B_FILE_NAME_LENGTH) {</a>
<a name="ln2011">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln2012">			B_TRANSLATE(&quot;That name is too long. Please type another one.&quot;),</a>
<a name="ln2013">			B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln2014">			0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln2015">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2016">		alert-&gt;Go();</a>
<a name="ln2017">		reopen = true;</a>
<a name="ln2018">	}</a>
<a name="ln2019"> </a>
<a name="ln2020">	// Remove view</a>
<a name="ln2021">	BView* scrollView = fTitleEditView-&gt;Parent();</a>
<a name="ln2022">	RemoveChild(scrollView);</a>
<a name="ln2023">	delete scrollView;</a>
<a name="ln2024">	fTitleEditView = NULL;</a>
<a name="ln2025"> </a>
<a name="ln2026">	if (reopen)</a>
<a name="ln2027">		BeginEditingTitle();</a>
<a name="ln2028">}</a>
<a name="ln2029"> </a>
<a name="ln2030"> </a>
<a name="ln2031">void</a>
<a name="ln2032">AttributeView::MakeFocus(bool focus)</a>
<a name="ln2033">{</a>
<a name="ln2034">	if (!focus &amp;&amp; fTitleEditView != NULL)</a>
<a name="ln2035">		FinishEditingTitle(true);</a>
<a name="ln2036">}</a>
<a name="ln2037"> </a>
<a name="ln2038"> </a>
<a name="ln2039">void</a>
<a name="ln2040">AttributeView::WindowActivated(bool active)</a>
<a name="ln2041">{</a>
<a name="ln2042">	if (active)</a>
<a name="ln2043">		return;</a>
<a name="ln2044"> </a>
<a name="ln2045">	if (fTitleEditView != NULL)</a>
<a name="ln2046">		FinishEditingTitle(true);</a>
<a name="ln2047"> </a>
<a name="ln2048">	if (fPathWindow-&gt;Lock()) {</a>
<a name="ln2049">		fPathWindow-&gt;Quit();</a>
<a name="ln2050">		fPathWindow = NULL;</a>
<a name="ln2051">	}</a>
<a name="ln2052"> </a>
<a name="ln2053">	if (fLinkWindow-&gt;Lock()) {</a>
<a name="ln2054">		fLinkWindow-&gt;Quit();</a>
<a name="ln2055">		fLinkWindow = NULL;</a>
<a name="ln2056">	}</a>
<a name="ln2057"> </a>
<a name="ln2058">	if (fDescWindow-&gt;Lock()) {</a>
<a name="ln2059">		fDescWindow-&gt;Quit();</a>
<a name="ln2060">		fDescWindow = NULL;</a>
<a name="ln2061">	}</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064"> </a>
<a name="ln2065">float</a>
<a name="ln2066">AttributeView::CurrentFontHeight()</a>
<a name="ln2067">{</a>
<a name="ln2068">	BFont font;</a>
<a name="ln2069">	GetFont(&amp;font);</a>
<a name="ln2070">	font_height fontHeight;</a>
<a name="ln2071">	font.GetHeight(&amp;fontHeight);</a>
<a name="ln2072"> </a>
<a name="ln2073">	return fontHeight.ascent + fontHeight.descent + fontHeight.leading + 2;</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076"> </a>
<a name="ln2077">status_t</a>
<a name="ln2078">AttributeView::BuildContextMenu(BMenu* parent)</a>
<a name="ln2079">{</a>
<a name="ln2080">	if (parent == NULL)</a>
<a name="ln2081">		return B_BAD_VALUE;</a>
<a name="ln2082"> </a>
<a name="ln2083">	// Add navigation menu if this is not a symlink</a>
<a name="ln2084">	// Symlink's to directories are OK however!</a>
<a name="ln2085">	BEntry entry(fModel-&gt;EntryRef());</a>
<a name="ln2086">	entry_ref ref;</a>
<a name="ln2087">	entry.GetRef(&amp;ref);</a>
<a name="ln2088">	Model model(&amp;entry);</a>
<a name="ln2089">	bool navigate = false;</a>
<a name="ln2090">	if (model.InitCheck() == B_OK) {</a>
<a name="ln2091">		if (model.IsSymLink()) {</a>
<a name="ln2092">			// Check if it's to a directory</a>
<a name="ln2093">			if (entry.SetTo(model.EntryRef(), true) == B_OK) {</a>
<a name="ln2094">				navigate = entry.IsDirectory();</a>
<a name="ln2095">				entry.GetRef(&amp;ref);</a>
<a name="ln2096">			}</a>
<a name="ln2097">		} else if (model.IsDirectory() || model.IsVolume())</a>
<a name="ln2098">			navigate = true;</a>
<a name="ln2099">	}</a>
<a name="ln2100">	ModelMenuItem* navigationItem = NULL;</a>
<a name="ln2101">	if (navigate) {</a>
<a name="ln2102">		navigationItem = new ModelMenuItem(new Model(model),</a>
<a name="ln2103">			new BNavMenu(model.Name(), B_REFS_RECEIVED, be_app, Window()));</a>
<a name="ln2104"> </a>
<a name="ln2105">		// setup a navigation menu item which will dynamically load items</a>
<a name="ln2106">		// as menu items are traversed</a>
<a name="ln2107">		BNavMenu* navMenu = dynamic_cast&lt;BNavMenu*&gt;(navigationItem-&gt;Submenu());</a>
<a name="ln2108">		if (navMenu != NULL)</a>
<a name="ln2109">			navMenu-&gt;SetNavDir(&amp;ref);</a>
<a name="ln2110"> </a>
<a name="ln2111">		navigationItem-&gt;SetLabel(model.Name());</a>
<a name="ln2112">		navigationItem-&gt;SetEntry(&amp;entry);</a>
<a name="ln2113"> </a>
<a name="ln2114">		parent-&gt;AddItem(navigationItem, 0);</a>
<a name="ln2115">		parent-&gt;AddItem(new BSeparatorItem(), 1);</a>
<a name="ln2116"> </a>
<a name="ln2117">		BMessage* message = new BMessage(B_REFS_RECEIVED);</a>
<a name="ln2118">		message-&gt;AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln2119">		navigationItem-&gt;SetMessage(message);</a>
<a name="ln2120">		navigationItem-&gt;SetTarget(be_app);</a>
<a name="ln2121">	}</a>
<a name="ln2122"> </a>
<a name="ln2123">	parent-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open&quot;),</a>
<a name="ln2124">		new BMessage(kOpenSelection), 'O'));</a>
<a name="ln2125"> </a>
<a name="ln2126">	if (!model.IsDesktop() &amp;&amp; !model.IsRoot() &amp;&amp; !model.IsTrash()</a>
<a name="ln2127">		&amp;&amp; !fModel-&gt;HasLocalizedName()) {</a>
<a name="ln2128">		parent-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Edit name&quot;),</a>
<a name="ln2129">			new BMessage(kEditItem), 'E'));</a>
<a name="ln2130">		parent-&gt;AddSeparatorItem();</a>
<a name="ln2131"> </a>
<a name="ln2132">		if (fModel-&gt;IsVolume()) {</a>
<a name="ln2133">			BMenuItem* item = new BMenuItem(B_TRANSLATE(&quot;Unmount&quot;),</a>
<a name="ln2134">				new BMessage(kUnmountVolume), 'U');</a>
<a name="ln2135">			parent-&gt;AddItem(item);</a>
<a name="ln2136">			// volume model, enable/disable the Unmount item</a>
<a name="ln2137">			BVolume boot;</a>
<a name="ln2138">			BVolumeRoster().GetBootVolume(&amp;boot);</a>
<a name="ln2139">			BVolume volume;</a>
<a name="ln2140">			volume.SetTo(fModel-&gt;NodeRef()-&gt;device);</a>
<a name="ln2141">			if (volume == boot)</a>
<a name="ln2142">				item-&gt;SetEnabled(false);</a>
<a name="ln2143">		}</a>
<a name="ln2144">	}</a>
<a name="ln2145"> </a>
<a name="ln2146">	if (!model.IsRoot() &amp;&amp; !model.IsVolume() &amp;&amp; !model.IsTrash())</a>
<a name="ln2147">		parent-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Identify&quot;),</a>
<a name="ln2148">			new BMessage(kIdentifyEntry)));</a>
<a name="ln2149"> </a>
<a name="ln2150">	if (model.IsTrash())</a>
<a name="ln2151">		parent-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Empty Trash&quot;),</a>
<a name="ln2152">			new BMessage(kEmptyTrash)));</a>
<a name="ln2153"> </a>
<a name="ln2154">	BMenuItem* sizeItem = NULL;</a>
<a name="ln2155">	if (model.IsDirectory() &amp;&amp; !model.IsVolume() &amp;&amp; !model.IsRoot())  {</a>
<a name="ln2156">		parent-&gt;AddItem(sizeItem</a>
<a name="ln2157">				= new BMenuItem(B_TRANSLATE(&quot;Recalculate folder size&quot;),</a>
<a name="ln2158">			new BMessage(kRecalculateSize)));</a>
<a name="ln2159">	}</a>
<a name="ln2160"> </a>
<a name="ln2161">	if (model.IsSymLink()) {</a>
<a name="ln2162">		parent-&gt;AddItem(sizeItem</a>
<a name="ln2163">				= new BMenuItem(B_TRANSLATE(&quot;Set new link target&quot;),</a>
<a name="ln2164">			new BMessage(kSetLinkTarget)));</a>
<a name="ln2165">	}</a>
<a name="ln2166"> </a>
<a name="ln2167">	parent-&gt;AddItem(new BSeparatorItem());</a>
<a name="ln2168">	parent-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Permissions&quot;),</a>
<a name="ln2169">		new BMessage(kPermissionsSelected), 'P'));</a>
<a name="ln2170"> </a>
<a name="ln2171">	parent-&gt;SetFont(be_plain_font);</a>
<a name="ln2172">	parent-&gt;SetTargetForItems(this);</a>
<a name="ln2173"> </a>
<a name="ln2174">	// Reset the nav menu to be_app</a>
<a name="ln2175">	if (navigate)</a>
<a name="ln2176">		navigationItem-&gt;SetTarget(be_app);</a>
<a name="ln2177">	if (sizeItem)</a>
<a name="ln2178">		sizeItem-&gt;SetTarget(Window());</a>
<a name="ln2179"> </a>
<a name="ln2180">	return B_OK;</a>
<a name="ln2181">}</a>
<a name="ln2182"> </a>
<a name="ln2183"> </a>
<a name="ln2184">void</a>
<a name="ln2185">AttributeView::SetPermissionsSwitchState(int32 state)</a>
<a name="ln2186">{</a>
<a name="ln2187">	fPermissionsSwitch-&gt;SetValue(state);</a>
<a name="ln2188">	fPermissionsSwitch-&gt;Invalidate();</a>
<a name="ln2189">}</a>
<a name="ln2190"> </a>
<a name="ln2191"> </a>
<a name="ln2192">filter_result</a>
<a name="ln2193">AttributeView::TextViewFilter(BMessage* message, BHandler**,</a>
<a name="ln2194">	BMessageFilter* filter)</a>
<a name="ln2195">{</a>
<a name="ln2196">	uchar key;</a>
<a name="ln2197">	AttributeView* attribView = static_cast&lt;AttributeView*&gt;(</a>
<a name="ln2198">		static_cast&lt;BWindow*&gt;(filter-&gt;Looper())-&gt;FindView(&quot;attr_view&quot;));</a>
<a name="ln2199"> </a>
<a name="ln2200">	// Adjust the size of the text rect</a>
<a name="ln2201">	BRect nuRect(attribView-&gt;TextView()-&gt;TextRect());</a>
<a name="ln2202">	nuRect.right = attribView-&gt;TextView()-&gt;LineWidth() + 20;</a>
<a name="ln2203">	attribView-&gt;TextView()-&gt;SetTextRect(nuRect);</a>
<a name="ln2204"> </a>
<a name="ln2205">	// Make sure the cursor is in view</a>
<a name="ln2206">	attribView-&gt;TextView()-&gt;ScrollToSelection();</a>
<a name="ln2207">	if (message-&gt;FindInt8(&quot;byte&quot;, (int8*)&amp;key) != B_OK)</a>
<a name="ln2208">		return B_DISPATCH_MESSAGE;</a>
<a name="ln2209"> </a>
<a name="ln2210">	if (key == B_RETURN || key == B_ESCAPE) {</a>
<a name="ln2211">		attribView-&gt;FinishEditingTitle(key == B_RETURN);</a>
<a name="ln2212">		return B_SKIP_MESSAGE;</a>
<a name="ln2213">	}</a>
<a name="ln2214"> </a>
<a name="ln2215">	return B_DISPATCH_MESSAGE;</a>
<a name="ln2216">}</a>
<a name="ln2217"> </a>
<a name="ln2218"> </a>
<a name="ln2219">off_t</a>
<a name="ln2220">AttributeView::LastSize() const</a>
<a name="ln2221">{</a>
<a name="ln2222">	return fLastSize;</a>
<a name="ln2223">}</a>
<a name="ln2224"> </a>
<a name="ln2225"> </a>
<a name="ln2226">void</a>
<a name="ln2227">AttributeView::SetLastSize(off_t lastSize)</a>
<a name="ln2228">{</a>
<a name="ln2229">	fLastSize = lastSize;</a>
<a name="ln2230">}</a>
<a name="ln2231"> </a>
<a name="ln2232"> </a>
<a name="ln2233">void</a>
<a name="ln2234">AttributeView::SetSizeString(const char* sizeString)</a>
<a name="ln2235">{</a>
<a name="ln2236">	fSizeString = sizeString;</a>
<a name="ln2237"> </a>
<a name="ln2238">	BRect bounds(Bounds());</a>
<a name="ln2239">	float lineHeight = CurrentFontHeight() + 6;</a>
<a name="ln2240">	bounds.Set(fDivider, fIconRect.bottom, bounds.right,</a>
<a name="ln2241">		fIconRect.bottom + lineHeight);</a>
<a name="ln2242">	Invalidate(bounds);</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245"> </a>
<a name="ln2246">//	#pragma mark -</a>
<a name="ln2247"> </a>
<a name="ln2248"> </a>
<a name="ln2249">TrackingView::TrackingView(BRect frame, const char* str, BMessage* message)</a>
<a name="ln2250">	: BControl(frame, &quot;trackingView&quot;, str, message, B_FOLLOW_ALL,</a>
<a name="ln2251">		B_WILL_DRAW),</a>
<a name="ln2252">	fMouseDown(false),</a>
<a name="ln2253">	fMouseInView(false)</a>
<a name="ln2254">{</a>
<a name="ln2255">	SetViewUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln2256">	SetEventMask(B_POINTER_EVENTS, 0);</a>
<a name="ln2257">}</a>
<a name="ln2258"> </a>
<a name="ln2259"> </a>
<a name="ln2260">void</a>
<a name="ln2261">TrackingView::MouseDown(BPoint)</a>
<a name="ln2262">{</a>
<a name="ln2263">	if (Message() != NULL) {</a>
<a name="ln2264">		fMouseDown = true;</a>
<a name="ln2265">		fMouseInView = true;</a>
<a name="ln2266">		InvertRect(Bounds());</a>
<a name="ln2267">	}</a>
<a name="ln2268">}</a>
<a name="ln2269"> </a>
<a name="ln2270"> </a>
<a name="ln2271">void</a>
<a name="ln2272">TrackingView::MouseMoved(BPoint, uint32 transit, const BMessage*)</a>
<a name="ln2273">{</a>
<a name="ln2274">	if ((transit == B_ENTERED_VIEW || transit == B_EXITED_VIEW) &amp;&amp; fMouseDown)</a>
<a name="ln2275">		InvertRect(Bounds());</a>
<a name="ln2276"> </a>
<a name="ln2277">	fMouseInView = (transit == B_ENTERED_VIEW || transit == B_INSIDE_VIEW);</a>
<a name="ln2278">	DelayedInvalidate(16666, Bounds());</a>
<a name="ln2279">	if (!fMouseInView &amp;&amp; !fMouseDown)</a>
<a name="ln2280">		Window()-&gt;Close();</a>
<a name="ln2281">}</a>
<a name="ln2282"> </a>
<a name="ln2283"> </a>
<a name="ln2284">void</a>
<a name="ln2285">TrackingView::MouseUp(BPoint)</a>
<a name="ln2286">{</a>
<a name="ln2287">	if (Message() != NULL) {</a>
<a name="ln2288">		if (fMouseInView)</a>
<a name="ln2289">			Invoke();</a>
<a name="ln2290"> </a>
<a name="ln2291">		fMouseDown = false;</a>
<a name="ln2292">		Window()-&gt;Close();</a>
<a name="ln2293">	}</a>
<a name="ln2294">}</a>
<a name="ln2295"> </a>
<a name="ln2296"> </a>
<a name="ln2297">void</a>
<a name="ln2298">TrackingView::Draw(BRect)</a>
<a name="ln2299">{</a>
<a name="ln2300">	if (Message() != NULL)</a>
<a name="ln2301">		SetHighUIColor(fMouseInView ? B_LINK_HOVER_COLOR</a>
<a name="ln2302">			: B_LINK_TEXT_COLOR);</a>
<a name="ln2303">	else</a>
<a name="ln2304">		SetHighUIColor(B_PANEL_TEXT_COLOR);</a>
<a name="ln2305">	SetLowColor(ViewColor());</a>
<a name="ln2306"> </a>
<a name="ln2307">	font_height fontHeight;</a>
<a name="ln2308">	GetFontHeight(&amp;fontHeight);</a>
<a name="ln2309"> </a>
<a name="ln2310">	DrawString(Label(), BPoint(3, Bounds().Height() - fontHeight.descent));</a>
<a name="ln2311">}</a>

</code></pre>
<div class="balloon" rel="2018"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1994"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
