
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>info.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Read initialisation information from card */</a>
<a name="ln2">/* some bits are hacks, where PINS is not known */</a>
<a name="ln3">/* Author:</a>
<a name="ln4">   Rudolf Cornelissen 7/2003-5/2006</a>
<a name="ln5">*/</a>
<a name="ln6"> </a>
<a name="ln7">#define MODULE_BIT 0x00002000</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;std.h&quot;</a>
<a name="ln10"> </a>
<a name="ln11">static void detect_panels(void);</a>
<a name="ln12">static void setup_output_matrix(void);</a>
<a name="ln13">static void pins_cle266_fake(void);</a>
<a name="ln14">static void pinsnv5_nv5m64_fake(void);</a>
<a name="ln15">static void pinsnv6_fake(void);</a>
<a name="ln16">static void pinsnv10_arch_fake(void);</a>
<a name="ln17">static void pinsnv20_arch_fake(void);</a>
<a name="ln18">static void pinsnv30_arch_fake(void);</a>
<a name="ln19">static void getRAMsize(void);</a>
<a name="ln20">static void getstrap_arch_nv4(void);</a>
<a name="ln21">static void getstrap_arch_nv10_20_30_40(void);</a>
<a name="ln22">static status_t eng_crtc_setup_fifo(void);</a>
<a name="ln23"> </a>
<a name="ln24">/* Parse the BIOS PINS structure if there */</a>
<a name="ln25">status_t parse_pins ()</a>
<a name="ln26">{</a>
<a name="ln27">	uint8 *rom;</a>
<a name="ln28">	status_t result = B_ERROR;</a>
<a name="ln29"> </a>
<a name="ln30">	/* preset PINS read status to failed */</a>
<a name="ln31">	si-&gt;ps.pins_status = B_ERROR;</a>
<a name="ln32"> </a>
<a name="ln33">	/* check the validity of PINS */</a>
<a name="ln34">	LOG(2,(&quot;INFO: Reading PINS info\n&quot;));</a>
<a name="ln35">	rom = (uint8 *) si-&gt;rom_mirror;</a>
<a name="ln36">	/* check BIOS signature - this is defined in the PCI standard */</a>
<a name="ln37">	if (rom[0]!=0x55 || rom[1]!=0xaa)</a>
<a name="ln38">	{</a>
<a name="ln39">		LOG(8,(&quot;INFO: BIOS signature not found\n&quot;));</a>
<a name="ln40">		return B_ERROR;</a>
<a name="ln41">	}</a>
<a name="ln42">	LOG(2,(&quot;INFO: BIOS signature $AA55 found OK\n&quot;));</a>
<a name="ln43"> </a>
<a name="ln44">	/* find the PINS struct adress */</a>
<a name="ln45">	//fixme...</a>
<a name="ln46"> </a>
<a name="ln47">	/* check PINS read result */</a>
<a name="ln48">	if (result == B_ERROR)</a>
<a name="ln49">	{</a>
<a name="ln50">		LOG(8,(&quot;INFO: PINS read/decode/execute error\n&quot;));</a>
<a name="ln51">		return B_ERROR;</a>
<a name="ln52">	}</a>
<a name="ln53">	/* PINS scan succeeded */</a>
<a name="ln54">	si-&gt;ps.pins_status = B_OK;</a>
<a name="ln55">	LOG(2,(&quot;INFO: PINS scan completed succesfully\n&quot;));</a>
<a name="ln56">	return B_OK;</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">//fixme: move to crtc sourcefile, also setup for crtc2(?)</a>
<a name="ln60">static status_t	eng_crtc_setup_fifo()</a>
<a name="ln61">{</a>
<a name="ln62">	/* enable access to primary head */</a>
<a name="ln63">	set_crtc_owner(0);</a>
<a name="ln64"> </a>
<a name="ln65">	//fixme: setup according to colordepth and RAM bus width...</a>
<a name="ln66">	/* set CRTC FIFO burst size to 256 */</a>
<a name="ln67">	CRTCW(FIFO, 0x03);</a>
<a name="ln68"> </a>
<a name="ln69">	/* set CRTC FIFO low watermark to 32 */</a>
<a name="ln70">	CRTCW(FIFO_LWM, 0x20);</a>
<a name="ln71"> </a>
<a name="ln72">	return B_OK;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">/* (pre)set 'fixed' card specifications */</a>
<a name="ln76">void set_specs(void)</a>
<a name="ln77">{</a>
<a name="ln78">	LOG(8,(&quot;INFO: setting up card specifications\n&quot;));</a>
<a name="ln79"> </a>
<a name="ln80">	/* set failsave speeds */</a>
<a name="ln81">	switch (si-&gt;ps.card_arch)</a>
<a name="ln82">	{</a>
<a name="ln83">	case CLE266:</a>
<a name="ln84">	default:</a>
<a name="ln85">		pins_cle266_fake();</a>
<a name="ln86">		break;</a>
<a name="ln87">	}</a>
<a name="ln88"> </a>
<a name="ln89">	/* detect reference crystal frequency and dualhead */</a>
<a name="ln90">/*</a>
<a name="ln91">	switch (si-&gt;ps.card_arch)</a>
<a name="ln92">	{</a>
<a name="ln93">	case NV04A:</a>
<a name="ln94">		getstrap_arch_nv4();</a>
<a name="ln95">		break;</a>
<a name="ln96">	default:</a>
<a name="ln97">		getstrap_arch_nv10_20_30_40();</a>
<a name="ln98">		break;</a>
<a name="ln99">	}</a>
<a name="ln100">*/</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">/* this routine presumes the card was coldstarted by the card's BIOS for panel stuff */</a>
<a name="ln104">void fake_panel_start(void)</a>
<a name="ln105">{</a>
<a name="ln106">	LOG(8,(&quot;INFO: detecting RAM size\n&quot;));</a>
<a name="ln107"> </a>
<a name="ln108">	/* detect RAM amount */</a>
<a name="ln109">	getRAMsize();</a>
<a name="ln110"> </a>
<a name="ln111">	/* override memory detection if requested by user */</a>
<a name="ln112">	if (si-&gt;settings.memory != 0)</a>
<a name="ln113">	{</a>
<a name="ln114">		LOG(2,(&quot;INFO: forcing memory size (specified in settings file)\n&quot;));</a>
<a name="ln115">		si-&gt;ps.memory_size = si-&gt;settings.memory * 1024 * 1024;</a>
<a name="ln116">	}</a>
<a name="ln117"> </a>
<a name="ln118">	/* find out if the card has a tvout chip */</a>
<a name="ln119">	si-&gt;ps.tvout = false;</a>
<a name="ln120">	si-&gt;ps.tvout_chip_type = NONE;</a>
<a name="ln121">//fixme ;-)</a>
<a name="ln122">/*	if (i2c_maven_probe() == B_OK)</a>
<a name="ln123">	{</a>
<a name="ln124">		si-&gt;ps.tvout = true;</a>
<a name="ln125">		si-&gt;ps.tvout_chip_bus = ???;</a>
<a name="ln126">		si-&gt;ps.tvout_chip_type = ???;</a>
<a name="ln127">	}</a>
<a name="ln128">*/</a>
<a name="ln129"> </a>
<a name="ln130">	LOG(8,(&quot;INFO: faking panel startup\n&quot;));</a>
<a name="ln131"> </a>
<a name="ln132">	/* find out the BIOS preprogrammed panel use status... */</a>
<a name="ln133">//	detect_panels();</a>
<a name="ln134"> </a>
<a name="ln135">	/* determine and setup output devices and heads */</a>
<a name="ln136">	setup_output_matrix();</a>
<a name="ln137"> </a>
<a name="ln138">	/* select other CRTC for primary head use if specified by user in settings file */</a>
<a name="ln139">	if (si-&gt;ps.secondary_head &amp;&amp; si-&gt;settings.switchhead)</a>
<a name="ln140">	{</a>
<a name="ln141">		LOG(2,(&quot;INFO: inverting head use (specified in settings file)\n&quot;));</a>
<a name="ln142">		si-&gt;ps.crtc2_prim = !si-&gt;ps.crtc2_prim;</a>
<a name="ln143">	}</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">static void detect_panels()</a>
<a name="ln147">{</a>
<a name="ln148">	/* detect if the BIOS enabled LCD's (internal panels or DVI) or TVout */</a>
<a name="ln149"> </a>
<a name="ln150">	/* both external TMDS transmitters (used for LCD/DVI) and external TVencoders</a>
<a name="ln151">	 * (can) use the CRTC's in slaved mode. */</a>
<a name="ln152">	/* Note:</a>
<a name="ln153">	 * DFP's are programmed with standard VESA modelines by the card's BIOS! */</a>
<a name="ln154">	bool slaved_for_dev1 = false, slaved_for_dev2 = false;</a>
<a name="ln155">	bool tvout1 = false, tvout2 = false;</a>
<a name="ln156"> </a>
<a name="ln157">	/* check primary head: */</a>
<a name="ln158">	/* enable access to primary head */</a>
<a name="ln159">	set_crtc_owner(0);</a>
<a name="ln160"> </a>
<a name="ln161">	/* unlock head's registers for R/W access */</a>
<a name="ln162">	CRTCW(LOCK, 0x57);</a>
<a name="ln163">	CRTCW(VSYNCE ,(CRTCR(VSYNCE) &amp; 0x7f));</a>
<a name="ln164"> </a>
<a name="ln165">	LOG(2,(&quot;INFO: Dumping flatpanel related CRTC registers:\n&quot;));</a>
<a name="ln166">	/* related info PIXEL register:</a>
<a name="ln167">	 * b7: 1 = slaved mode										(all cards). */</a>
<a name="ln168">	LOG(2,(&quot;CRTC1: PIXEL register: $%02x\n&quot;, CRTCR(PIXEL)));</a>
<a name="ln169">	/* info LCD register:</a>
<a name="ln170">	 * b7: 1 = stereo view (shutter glasses use)				(all cards),</a>
<a name="ln171">	 * b5: 1 = power ext. TMDS (or something)/0 = TVout	use	(?)	(confirmed NV17, NV28),</a>
<a name="ln172">	 * b4: 1 = power ext. TMDS (or something)/0 = TVout use	(?)	(confirmed NV34),</a>
<a name="ln173">	 * b3: 1 = ??? (not panel related probably!)				(confirmed NV34),</a>
<a name="ln174">	 * b1: 1 = power ext. TMDS (or something) (?)				(confirmed NV05?, NV17),</a>
<a name="ln175">	 * b0: 1 = select panel encoder / 0 = select TVout encoder	(all cards). */</a>
<a name="ln176">	LOG(2,(&quot;CRTC1: LCD register: $%02x\n&quot;, CRTCR(LCD)));</a>
<a name="ln177">	/* info 0x59 register:</a>
<a name="ln178">	 * b0: 1 = enable ext. TMDS clock (DPMS)					(confirmed NV28, NV34). */</a>
<a name="ln179">	LOG(2,(&quot;CRTC1: register $59: $%02x\n&quot;, CRTCR(0x59)));</a>
<a name="ln180">	/* info 0x9f register:</a>
<a name="ln181">	 * b4: 0 = TVout use (?). */</a>
<a name="ln182">	LOG(2,(&quot;CRTC1: register $9f: $%02x\n&quot;, CRTCR(0x9f)));</a>
<a name="ln183"> </a>
<a name="ln184">	/* detect active slave device (if any) */</a>
<a name="ln185">	slaved_for_dev1 = (CRTCR(PIXEL) &amp; 0x80);</a>
<a name="ln186">	if (slaved_for_dev1)</a>
<a name="ln187">	{</a>
<a name="ln188">		/* if the panel isn't selected, tvout is.. */</a>
<a name="ln189">		tvout1 = !(CRTCR(LCD) &amp; 0x01);</a>
<a name="ln190">	}</a>
<a name="ln191"> </a>
<a name="ln192">	if (si-&gt;ps.secondary_head)</a>
<a name="ln193">	{</a>
<a name="ln194">		/* check secondary head: */</a>
<a name="ln195">		/* enable access to secondary head */</a>
<a name="ln196">		set_crtc_owner(1);</a>
<a name="ln197">		/* unlock head's registers for R/W access */</a>
<a name="ln198">		CRTC2W(LOCK, 0x57);</a>
<a name="ln199">		CRTC2W(VSYNCE ,(CRTC2R(VSYNCE) &amp; 0x7f));</a>
<a name="ln200"> </a>
<a name="ln201">		LOG(2,(&quot;CRTC2: PIXEL register: $%02x\n&quot;, CRTC2R(PIXEL)));</a>
<a name="ln202">		LOG(2,(&quot;CRTC2: LCD register: $%02x\n&quot;, CRTC2R(LCD)));</a>
<a name="ln203">		LOG(2,(&quot;CRTC2: register $59: $%02x\n&quot;, CRTC2R(0x59)));</a>
<a name="ln204">		LOG(2,(&quot;CRTC2: register $9f: $%02x\n&quot;, CRTC2R(0x9f)));</a>
<a name="ln205"> </a>
<a name="ln206">		/* detect active slave device (if any) */</a>
<a name="ln207">		slaved_for_dev2 = (CRTC2R(PIXEL) &amp; 0x80);</a>
<a name="ln208">		if (slaved_for_dev2)</a>
<a name="ln209">		{</a>
<a name="ln210">			/* if the panel isn't selected, tvout is.. */</a>
<a name="ln211">			tvout2 = !(CRTC2R(LCD) &amp; 0x01);</a>
<a name="ln212">		}</a>
<a name="ln213">	}</a>
<a name="ln214"> </a>
<a name="ln215">	LOG(2,(&quot;INFO: End flatpanel related CRTC registers dump.\n&quot;));</a>
<a name="ln216"> </a>
<a name="ln217">	/* do some presets */</a>
<a name="ln218">	si-&gt;ps.p1_timing.h_display = 0;</a>
<a name="ln219">	si-&gt;ps.p1_timing.v_display = 0;</a>
<a name="ln220">	si-&gt;ps.panel1_aspect = 0;</a>
<a name="ln221">	si-&gt;ps.p2_timing.h_display = 0;</a>
<a name="ln222">	si-&gt;ps.p2_timing.v_display = 0;</a>
<a name="ln223">	si-&gt;ps.panel2_aspect = 0;</a>
<a name="ln224">	si-&gt;ps.slaved_tmds1 = false;</a>
<a name="ln225">	si-&gt;ps.slaved_tmds2 = false;</a>
<a name="ln226">	si-&gt;ps.master_tmds1 = false;</a>
<a name="ln227">	si-&gt;ps.master_tmds2 = false;</a>
<a name="ln228">	si-&gt;ps.tmds1_active = false;</a>
<a name="ln229">	si-&gt;ps.tmds2_active = false;</a>
<a name="ln230">	/* determine the situation we are in... (regarding flatpanels) */</a>
<a name="ln231">	/* fixme: add VESA DDC EDID stuff one day... */</a>
<a name="ln232">	/* fixme: find out how to program those transmitters one day instead of</a>
<a name="ln233">	 * relying on the cards BIOS to do it. This adds TVout options where panels</a>
<a name="ln234">	 * are used!</a>
<a name="ln235">	 * Currently we'd loose the panel setup while not being able to restore it. */</a>
<a name="ln236"> </a>
<a name="ln237">	/* note: (facts)</a>
<a name="ln238">	 * -&gt; NV11 and NV17 laptops have LVDS panels, programmed in both sets registers;</a>
<a name="ln239">	 * -&gt; NV34 laptops have TMDS panels, programmed in only one set of registers;</a>
<a name="ln240">	 * -&gt; NV11, NV25 and NV34 DVI cards, so external panels (TMDS) are programmed</a>
<a name="ln241">	 *    in only one set of registers;</a>
<a name="ln242">	 * -&gt; a register-set's FP_TG_CTRL register, bit 31 tells you if a LVDS panel is</a>
<a name="ln243">	 *    connected to the primary head (0), or to the secondary head (1) except</a>
<a name="ln244">	 *    on some NV11's if this bit is '0' there;</a>
<a name="ln245">	 * -&gt; for LVDS panels both registersets are programmed identically by the card's</a>
<a name="ln246">	 *    BIOSes;</a>
<a name="ln247">	 * -&gt; the programmed set of registers tells you where a TMDS (DVI) panel is</a>
<a name="ln248">	 *    connected;</a>
<a name="ln249">	 * -&gt; On all cards a CRTC is used in slaved mode when a panel is connected,</a>
<a name="ln250">	 *    except on NV11: here master mode is (might be?) detected. */</a>
<a name="ln251">	/* note also:</a>
<a name="ln252">	 * external TMDS encoders are only used for logic-level translation: it's</a>
<a name="ln253">	 * modeline registers are not used. Instead the GPU's internal modeline registers</a>
<a name="ln254">	 * are used. The external encoder is not connected to a I2C bus (confirmed NV34). */</a>
<a name="ln255">	if (slaved_for_dev1 &amp;&amp; !tvout1)</a>
<a name="ln256">	{</a>
<a name="ln257">		uint16 width = ((DACR(FP_HDISPEND) &amp; 0x0000ffff) + 1);</a>
<a name="ln258">		uint16 height = ((DACR(FP_VDISPEND) &amp; 0x0000ffff) + 1);</a>
<a name="ln259">		if ((width &gt;= 640) &amp;&amp; (height &gt;= 480))</a>
<a name="ln260">		{</a>
<a name="ln261">			si-&gt;ps.slaved_tmds1 = true;</a>
<a name="ln262">			si-&gt;ps.tmds1_active = true;</a>
<a name="ln263">			si-&gt;ps.p1_timing.h_display = width;</a>
<a name="ln264">			si-&gt;ps.p1_timing.v_display = height;</a>
<a name="ln265">		}</a>
<a name="ln266">	}</a>
<a name="ln267"> </a>
<a name="ln268">	if (si-&gt;ps.secondary_head &amp;&amp; slaved_for_dev2 &amp;&amp; !tvout2)</a>
<a name="ln269">	{</a>
<a name="ln270">		uint16 width = ((DAC2R(FP_HDISPEND) &amp; 0x0000ffff) + 1);</a>
<a name="ln271">		uint16 height = ((DAC2R(FP_VDISPEND) &amp; 0x0000ffff) + 1);</a>
<a name="ln272">		if ((width &gt;= 640) &amp;&amp; (height &gt;= 480))</a>
<a name="ln273">		{</a>
<a name="ln274">			si-&gt;ps.slaved_tmds2 = true;</a>
<a name="ln275">			si-&gt;ps.tmds2_active = true;</a>
<a name="ln276">			si-&gt;ps.p2_timing.h_display = width;</a>
<a name="ln277">			si-&gt;ps.p2_timing.v_display = height;</a>
<a name="ln278">		}</a>
<a name="ln279">	}</a>
<a name="ln280"> </a>
<a name="ln281">	if ((si-&gt;ps.card_type == NV11) &amp;&amp;</a>
<a name="ln282">		!si-&gt;ps.slaved_tmds1 &amp;&amp; !tvout1)</a>
<a name="ln283">	{</a>
<a name="ln284">		uint16 width = ((DACR(FP_HDISPEND) &amp; 0x0000ffff) + 1);</a>
<a name="ln285">		uint16 height = ((DACR(FP_VDISPEND) &amp; 0x0000ffff) + 1);</a>
<a name="ln286">		if ((width &gt;= 640) &amp;&amp; (height &gt;= 480))</a>
<a name="ln287">		{</a>
<a name="ln288">			si-&gt;ps.master_tmds1 = true;</a>
<a name="ln289">			si-&gt;ps.tmds1_active = true;</a>
<a name="ln290">			si-&gt;ps.p1_timing.h_display = width;</a>
<a name="ln291">			si-&gt;ps.p1_timing.v_display = height;</a>
<a name="ln292">		}</a>
<a name="ln293">	}</a>
<a name="ln294"> </a>
<a name="ln295">	if ((si-&gt;ps.card_type == NV11) &amp;&amp;</a>
<a name="ln296">		si-&gt;ps.secondary_head &amp;&amp; !si-&gt;ps.slaved_tmds2 &amp;&amp; !tvout2)</a>
<a name="ln297">	{</a>
<a name="ln298">		uint16 width = ((DAC2R(FP_HDISPEND) &amp; 0x0000ffff) + 1);</a>
<a name="ln299">		uint16 height = ((DAC2R(FP_VDISPEND) &amp; 0x0000ffff) + 1);</a>
<a name="ln300">		if ((width &gt;= 640) &amp;&amp; (height &gt;= 480))</a>
<a name="ln301">		{</a>
<a name="ln302">			si-&gt;ps.master_tmds2 = true;</a>
<a name="ln303">			si-&gt;ps.tmds2_active = true;</a>
<a name="ln304">			si-&gt;ps.p2_timing.h_display = width;</a>
<a name="ln305">			si-&gt;ps.p2_timing.v_display = height;</a>
<a name="ln306">		}</a>
<a name="ln307">	}</a>
<a name="ln308"> </a>
<a name="ln309">	//fixme...:</a>
<a name="ln310">	//we are assuming that no DVI is used as external monitor on laptops;</a>
<a name="ln311">	//otherwise we probably get into trouble here if the checked specs match.</a>
<a name="ln312">	if (si-&gt;ps.laptop &amp;&amp; si-&gt;ps.tmds1_active &amp;&amp; si-&gt;ps.tmds2_active &amp;&amp;</a>
<a name="ln313">		((DACR(FP_TG_CTRL) &amp; 0x80000000) == (DAC2R(FP_TG_CTRL) &amp; 0x80000000)) &amp;&amp;</a>
<a name="ln314">		(si-&gt;ps.p1_timing.h_display == si-&gt;ps.p2_timing.h_display) &amp;&amp;</a>
<a name="ln315">		(si-&gt;ps.p1_timing.v_display == si-&gt;ps.p2_timing.v_display))</a>
<a name="ln316">	{</a>
<a name="ln317">		LOG(2,(&quot;INFO: correcting double detection of single panel!\n&quot;));</a>
<a name="ln318"> </a>
<a name="ln319">		if (si-&gt;ps.card_type == NV11)</a>
<a name="ln320">		{</a>
<a name="ln321">			/* LVDS panel is _always_ on CRTC2, so clear false primary detection */</a>
<a name="ln322">			si-&gt;ps.slaved_tmds1 = false;</a>
<a name="ln323">			si-&gt;ps.master_tmds1 = false;</a>
<a name="ln324">			si-&gt;ps.tmds1_active = false;</a>
<a name="ln325">			si-&gt;ps.p1_timing.h_display = 0;</a>
<a name="ln326">			si-&gt;ps.p1_timing.v_display = 0;</a>
<a name="ln327">		}</a>
<a name="ln328">		else</a>
<a name="ln329">		{</a>
<a name="ln330">			if (DACR(FP_TG_CTRL) &amp; 0x80000000)</a>
<a name="ln331">			{</a>
<a name="ln332">				/* LVDS panel is on CRTC2, so clear false primary detection */</a>
<a name="ln333">				si-&gt;ps.slaved_tmds1 = false;</a>
<a name="ln334">				si-&gt;ps.master_tmds1 = false;</a>
<a name="ln335">				si-&gt;ps.tmds1_active = false;</a>
<a name="ln336">				si-&gt;ps.p1_timing.h_display = 0;</a>
<a name="ln337">				si-&gt;ps.p1_timing.v_display = 0;</a>
<a name="ln338">			}</a>
<a name="ln339">			else</a>
<a name="ln340">			{</a>
<a name="ln341">				/* LVDS panel is on CRTC1, so clear false secondary detection */</a>
<a name="ln342">				si-&gt;ps.slaved_tmds2 = false;</a>
<a name="ln343">				si-&gt;ps.master_tmds2 = false;</a>
<a name="ln344">				si-&gt;ps.tmds2_active = false;</a>
<a name="ln345">				si-&gt;ps.p2_timing.h_display = 0;</a>
<a name="ln346">				si-&gt;ps.p2_timing.v_display = 0;</a>
<a name="ln347">			}</a>
<a name="ln348">		}</a>
<a name="ln349">	}</a>
<a name="ln350"> </a>
<a name="ln351">	/* fetch panel(s) modeline(s) */</a>
<a name="ln352">	if (si-&gt;ps.tmds1_active)</a>
<a name="ln353">	{</a>
<a name="ln354">		/* determine panel aspect ratio */</a>
<a name="ln355">		si-&gt;ps.panel1_aspect =</a>
<a name="ln356">			(si-&gt;ps.p1_timing.h_display / ((float)si-&gt;ps.p1_timing.v_display));</a>
<a name="ln357">		/* horizontal timing */</a>
<a name="ln358">		si-&gt;ps.p1_timing.h_sync_start = (DACR(FP_HSYNC_S) &amp; 0x0000ffff) + 1;</a>
<a name="ln359">		si-&gt;ps.p1_timing.h_sync_end = (DACR(FP_HSYNC_E) &amp; 0x0000ffff) + 1;</a>
<a name="ln360">		si-&gt;ps.p1_timing.h_total = (DACR(FP_HTOTAL) &amp; 0x0000ffff) + 1;</a>
<a name="ln361">		/* vertical timing */</a>
<a name="ln362">		si-&gt;ps.p1_timing.v_sync_start = (DACR(FP_VSYNC_S) &amp; 0x0000ffff) + 1;</a>
<a name="ln363">		si-&gt;ps.p1_timing.v_sync_end = (DACR(FP_VSYNC_E) &amp; 0x0000ffff) + 1;</a>
<a name="ln364">		si-&gt;ps.p1_timing.v_total = (DACR(FP_VTOTAL) &amp; 0x0000ffff) + 1;</a>
<a name="ln365">		/* sync polarity */</a>
<a name="ln366">		si-&gt;ps.p1_timing.flags = 0;</a>
<a name="ln367">		if (DACR(FP_TG_CTRL) &amp; 0x00000001) si-&gt;ps.p1_timing.flags |= B_POSITIVE_VSYNC;</a>
<a name="ln368">		if (DACR(FP_TG_CTRL) &amp; 0x00000010) si-&gt;ps.p1_timing.flags |= B_POSITIVE_HSYNC;</a>
<a name="ln369">		/* refreshrate:</a>
<a name="ln370">		 * fix a DVI or laptop flatpanel to 60Hz refresh! */</a>
<a name="ln371">		si-&gt;ps.p1_timing.pixel_clock =</a>
<a name="ln372">			(si-&gt;ps.p1_timing.h_total * si-&gt;ps.p1_timing.v_total * 60) / 1000;</a>
<a name="ln373">	}</a>
<a name="ln374">	if (si-&gt;ps.tmds2_active)</a>
<a name="ln375">	{</a>
<a name="ln376">		/* determine panel aspect ratio */</a>
<a name="ln377">		si-&gt;ps.panel2_aspect =</a>
<a name="ln378">			(si-&gt;ps.p2_timing.h_display / ((float)si-&gt;ps.p2_timing.v_display));</a>
<a name="ln379">		/* horizontal timing */</a>
<a name="ln380">		si-&gt;ps.p2_timing.h_sync_start = (DAC2R(FP_HSYNC_S) &amp; 0x0000ffff) + 1;</a>
<a name="ln381">		si-&gt;ps.p2_timing.h_sync_end = (DAC2R(FP_HSYNC_E) &amp; 0x0000ffff) + 1;</a>
<a name="ln382">		si-&gt;ps.p2_timing.h_total = (DAC2R(FP_HTOTAL) &amp; 0x0000ffff) + 1;</a>
<a name="ln383">		/* vertical timing */</a>
<a name="ln384">		si-&gt;ps.p2_timing.v_sync_start = (DAC2R(FP_VSYNC_S) &amp; 0x0000ffff) + 1;</a>
<a name="ln385">		si-&gt;ps.p2_timing.v_sync_end = (DAC2R(FP_VSYNC_E) &amp; 0x0000ffff) + 1;</a>
<a name="ln386">		si-&gt;ps.p2_timing.v_total = (DAC2R(FP_VTOTAL) &amp; 0x0000ffff) + 1;</a>
<a name="ln387">		/* sync polarity */</a>
<a name="ln388">		si-&gt;ps.p2_timing.flags = 0;</a>
<a name="ln389">		if (DAC2R(FP_TG_CTRL) &amp; 0x00000001) si-&gt;ps.p2_timing.flags |= B_POSITIVE_VSYNC;</a>
<a name="ln390">		if (DAC2R(FP_TG_CTRL) &amp; 0x00000010) si-&gt;ps.p2_timing.flags |= B_POSITIVE_HSYNC;</a>
<a name="ln391">		/* refreshrate:</a>
<a name="ln392">		 * fix a DVI or laptop flatpanel to 60Hz refresh! */</a>
<a name="ln393">		si-&gt;ps.p2_timing.pixel_clock =</a>
<a name="ln394">			(si-&gt;ps.p2_timing.h_total * si-&gt;ps.p2_timing.v_total * 60) / 1000;</a>
<a name="ln395">	}</a>
<a name="ln396"> </a>
<a name="ln397">	/* dump some panel configuration registers... */</a>
<a name="ln398">	LOG(2,(&quot;INFO: Dumping flatpanel registers:\n&quot;));</a>
<a name="ln399">	LOG(2,(&quot;DUALHEAD_CTRL: $%08x\n&quot;, ENG_REG32(RG32_DUALHEAD_CTRL)));</a>
<a name="ln400">	LOG(2,(&quot;DAC1: FP_HDISPEND: %d\n&quot;, DACR(FP_HDISPEND)));</a>
<a name="ln401">	LOG(2,(&quot;DAC1: FP_HTOTAL: %d\n&quot;, DACR(FP_HTOTAL)));</a>
<a name="ln402">	LOG(2,(&quot;DAC1: FP_HCRTC: %d\n&quot;, DACR(FP_HCRTC)));</a>
<a name="ln403">	LOG(2,(&quot;DAC1: FP_HSYNC_S: %d\n&quot;, DACR(FP_HSYNC_S)));</a>
<a name="ln404">	LOG(2,(&quot;DAC1: FP_HSYNC_E: %d\n&quot;, DACR(FP_HSYNC_E)));</a>
<a name="ln405">	LOG(2,(&quot;DAC1: FP_HVALID_S: %d\n&quot;, DACR(FP_HVALID_S)));</a>
<a name="ln406">	LOG(2,(&quot;DAC1: FP_HVALID_E: %d\n&quot;, DACR(FP_HVALID_E)));</a>
<a name="ln407"> </a>
<a name="ln408">	LOG(2,(&quot;DAC1: FP_VDISPEND: %d\n&quot;, DACR(FP_VDISPEND)));</a>
<a name="ln409">	LOG(2,(&quot;DAC1: FP_VTOTAL: %d\n&quot;, DACR(FP_VTOTAL)));</a>
<a name="ln410">	LOG(2,(&quot;DAC1: FP_VCRTC: %d\n&quot;, DACR(FP_VCRTC)));</a>
<a name="ln411">	LOG(2,(&quot;DAC1: FP_VSYNC_S: %d\n&quot;, DACR(FP_VSYNC_S)));</a>
<a name="ln412">	LOG(2,(&quot;DAC1: FP_VSYNC_E: %d\n&quot;, DACR(FP_VSYNC_E)));</a>
<a name="ln413">	LOG(2,(&quot;DAC1: FP_VVALID_S: %d\n&quot;, DACR(FP_VVALID_S)));</a>
<a name="ln414">	LOG(2,(&quot;DAC1: FP_VVALID_E: %d\n&quot;, DACR(FP_VVALID_E)));</a>
<a name="ln415"> </a>
<a name="ln416">	LOG(2,(&quot;DAC1: FP_CHKSUM: $%08x = (dec) %d\n&quot;, DACR(FP_CHKSUM),DACR(FP_CHKSUM)));</a>
<a name="ln417">	LOG(2,(&quot;DAC1: FP_TST_CTRL: $%08x\n&quot;, DACR(FP_TST_CTRL)));</a>
<a name="ln418">	LOG(2,(&quot;DAC1: FP_TG_CTRL: $%08x\n&quot;, DACR(FP_TG_CTRL)));</a>
<a name="ln419">	LOG(2,(&quot;DAC1: FP_DEBUG0: $%08x\n&quot;, DACR(FP_DEBUG0)));</a>
<a name="ln420">	LOG(2,(&quot;DAC1: FP_DEBUG1: $%08x\n&quot;, DACR(FP_DEBUG1)));</a>
<a name="ln421">	LOG(2,(&quot;DAC1: FP_DEBUG2: $%08x\n&quot;, DACR(FP_DEBUG2)));</a>
<a name="ln422">	LOG(2,(&quot;DAC1: FP_DEBUG3: $%08x\n&quot;, DACR(FP_DEBUG3)));</a>
<a name="ln423"> </a>
<a name="ln424">	LOG(2,(&quot;DAC1: FUNCSEL: $%08x\n&quot;, ENG_REG32(RG32_FUNCSEL)));</a>
<a name="ln425">	LOG(2,(&quot;DAC1: PANEL_PWR: $%08x\n&quot;, ENG_REG32(RG32_PANEL_PWR)));</a>
<a name="ln426"> </a>
<a name="ln427">	if(si-&gt;ps.secondary_head)</a>
<a name="ln428">	{</a>
<a name="ln429">		LOG(2,(&quot;DAC2: FP_HDISPEND: %d\n&quot;, DAC2R(FP_HDISPEND)));</a>
<a name="ln430">		LOG(2,(&quot;DAC2: FP_HTOTAL: %d\n&quot;, DAC2R(FP_HTOTAL)));</a>
<a name="ln431">		LOG(2,(&quot;DAC2: FP_HCRTC: %d\n&quot;, DAC2R(FP_HCRTC)));</a>
<a name="ln432">		LOG(2,(&quot;DAC2: FP_HSYNC_S: %d\n&quot;, DAC2R(FP_HSYNC_S)));</a>
<a name="ln433">		LOG(2,(&quot;DAC2: FP_HSYNC_E: %d\n&quot;, DAC2R(FP_HSYNC_E)));</a>
<a name="ln434">		LOG(2,(&quot;DAC2: FP_HVALID_S:%d\n&quot;, DAC2R(FP_HVALID_S)));</a>
<a name="ln435">		LOG(2,(&quot;DAC2: FP_HVALID_E: %d\n&quot;, DAC2R(FP_HVALID_E)));</a>
<a name="ln436"> </a>
<a name="ln437">		LOG(2,(&quot;DAC2: FP_VDISPEND: %d\n&quot;, DAC2R(FP_VDISPEND)));</a>
<a name="ln438">		LOG(2,(&quot;DAC2: FP_VTOTAL: %d\n&quot;, DAC2R(FP_VTOTAL)));</a>
<a name="ln439">		LOG(2,(&quot;DAC2: FP_VCRTC: %d\n&quot;, DAC2R(FP_VCRTC)));</a>
<a name="ln440">		LOG(2,(&quot;DAC2: FP_VSYNC_S: %d\n&quot;, DAC2R(FP_VSYNC_S)));</a>
<a name="ln441">		LOG(2,(&quot;DAC2: FP_VSYNC_E: %d\n&quot;, DAC2R(FP_VSYNC_E)));</a>
<a name="ln442">		LOG(2,(&quot;DAC2: FP_VVALID_S: %d\n&quot;, DAC2R(FP_VVALID_S)));</a>
<a name="ln443">		LOG(2,(&quot;DAC2: FP_VVALID_E: %d\n&quot;, DAC2R(FP_VVALID_E)));</a>
<a name="ln444"> </a>
<a name="ln445">		LOG(2,(&quot;DAC2: FP_CHKSUM: $%08x = (dec) %d\n&quot;, DAC2R(FP_CHKSUM),DAC2R(FP_CHKSUM)));</a>
<a name="ln446">		LOG(2,(&quot;DAC2: FP_TST_CTRL: $%08x\n&quot;, DAC2R(FP_TST_CTRL)));</a>
<a name="ln447">		LOG(2,(&quot;DAC2: FP_TG_CTRL: $%08x\n&quot;, DAC2R(FP_TG_CTRL)));</a>
<a name="ln448">		LOG(2,(&quot;DAC2: FP_DEBUG0: $%08x\n&quot;, DAC2R(FP_DEBUG0)));</a>
<a name="ln449">		LOG(2,(&quot;DAC2: FP_DEBUG1: $%08x\n&quot;, DAC2R(FP_DEBUG1)));</a>
<a name="ln450">		LOG(2,(&quot;DAC2: FP_DEBUG2: $%08x\n&quot;, DAC2R(FP_DEBUG2)));</a>
<a name="ln451">		LOG(2,(&quot;DAC2: FP_DEBUG3: $%08x\n&quot;, DAC2R(FP_DEBUG3)));</a>
<a name="ln452"> </a>
<a name="ln453">		LOG(2,(&quot;DAC2: FUNCSEL: $%08x\n&quot;, ENG_REG32(RG32_2FUNCSEL)));</a>
<a name="ln454">		LOG(2,(&quot;DAC2: PANEL_PWR: $%08x\n&quot;, ENG_REG32(RG32_2PANEL_PWR)));</a>
<a name="ln455">	}</a>
<a name="ln456">	LOG(2,(&quot;INFO: End flatpanel registers dump.\n&quot;));</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">static void setup_output_matrix()</a>
<a name="ln460">{</a>
<a name="ln461">	/* setup defaults: */</a>
<a name="ln462">	/* no monitors (output devices) detected */</a>
<a name="ln463">	si-&gt;ps.monitors = 0x00;</a>
<a name="ln464">	/* head 1 will be the primary head */</a>
<a name="ln465">	si-&gt;ps.crtc2_prim = false;</a>
<a name="ln466"> </a>
<a name="ln467">	/* setup output devices and heads */</a>
<a name="ln468">	if (0)//si-&gt;ps.secondary_head)</a>
<a name="ln469">	{</a>
<a name="ln470">		if (si-&gt;ps.card_type != NV11)</a>
<a name="ln471">		{</a>
<a name="ln472">			/* setup defaults: */</a>
<a name="ln473">			/* connect analog outputs straight through */</a>
<a name="ln474">			eng_general_output_select(false);</a>
<a name="ln475"> </a>
<a name="ln476">			/* presetup by the card's BIOS, we can't change this (lack of info) */</a>
<a name="ln477">			if (si-&gt;ps.tmds1_active) si-&gt;ps.monitors |= 0x01;</a>
<a name="ln478">			if (si-&gt;ps.tmds2_active) si-&gt;ps.monitors |= 0x10;</a>
<a name="ln479">			/* detect analog monitors (confirmed working OK on NV18, NV28 and NV34): */</a>
<a name="ln480">			/* sense analog monitor on primary connector */</a>
<a name="ln481">			if (eng_dac_crt_connected()) si-&gt;ps.monitors |= 0x02;</a>
<a name="ln482">			/* sense analog monitor on secondary connector */</a>
<a name="ln483">			if (eng_dac2_crt_connected()) si-&gt;ps.monitors |= 0x20;</a>
<a name="ln484"> </a>
<a name="ln485">			/* setup correct output and head use */</a>
<a name="ln486">			//fixme? add TVout (only, so no CRT(s) connected) support...</a>
<a name="ln487">			switch (si-&gt;ps.monitors)</a>
<a name="ln488">			{</a>
<a name="ln489">			case 0x00: /* no monitor found at all */</a>
<a name="ln490">				LOG(2,(&quot;INFO: head 1 has nothing connected;\n&quot;));</a>
<a name="ln491">				LOG(2,(&quot;INFO: head 2 has nothing connected:\n&quot;));</a>
<a name="ln492">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln493">				break;</a>
<a name="ln494">			case 0x01: /* digital panel on head 1, nothing on head 2 */</a>
<a name="ln495">				LOG(2,(&quot;INFO: head 1 has a digital panel;\n&quot;));</a>
<a name="ln496">				LOG(2,(&quot;INFO: head 2 has nothing connected:\n&quot;));</a>
<a name="ln497">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln498">				break;</a>
<a name="ln499">			case 0x02: /* analog panel or CRT on head 1, nothing on head 2 */</a>
<a name="ln500">				LOG(2,(&quot;INFO: head 1 has an analog panel or CRT;\n&quot;));</a>
<a name="ln501">				LOG(2,(&quot;INFO: head 2 has nothing connected:\n&quot;));</a>
<a name="ln502">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln503">				break;</a>
<a name="ln504">			case 0x03: /* both types on head 1, nothing on head 2 */</a>
<a name="ln505">				LOG(2,(&quot;INFO: head 1 has a digital panel AND an analog panel or CRT;\n&quot;));</a>
<a name="ln506">				LOG(2,(&quot;INFO: head 2 has nothing connected:\n&quot;));</a>
<a name="ln507">				LOG(2,(&quot;INFO: correcting...\n&quot;));</a>
<a name="ln508">				/* cross connect analog outputs so analog panel or CRT gets head 2 */</a>
<a name="ln509">				eng_general_output_select(true);</a>
<a name="ln510">				LOG(2,(&quot;INFO: head 1 has a digital panel;\n&quot;));</a>
<a name="ln511">				LOG(2,(&quot;INFO: head 2 has an analog panel or CRT:\n&quot;));</a>
<a name="ln512">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln513">				break;</a>
<a name="ln514">			case 0x10: /* nothing on head 1, digital panel on head 2 */</a>
<a name="ln515">				LOG(2,(&quot;INFO: head 1 has nothing connected;\n&quot;));</a>
<a name="ln516">				LOG(2,(&quot;INFO: head 2 has a digital panel:\n&quot;));</a>
<a name="ln517">				LOG(2,(&quot;INFO: defaulting to head 2 for primary use.\n&quot;));</a>
<a name="ln518">				si-&gt;ps.crtc2_prim = true;</a>
<a name="ln519">				break;</a>
<a name="ln520">			case 0x20: /* nothing on head 1, analog panel or CRT on head 2 */</a>
<a name="ln521">				LOG(2,(&quot;INFO: head 1 has nothing connected;\n&quot;));</a>
<a name="ln522">				LOG(2,(&quot;INFO: head 2 has an analog panel or CRT:\n&quot;));</a>
<a name="ln523">				LOG(2,(&quot;INFO: defaulting to head 2 for primary use.\n&quot;));</a>
<a name="ln524">				si-&gt;ps.crtc2_prim = true;</a>
<a name="ln525">				break;</a>
<a name="ln526">			case 0x30: /* nothing on head 1, both types on head 2 */</a>
<a name="ln527">				LOG(2,(&quot;INFO: head 1 has nothing connected;\n&quot;));</a>
<a name="ln528">				LOG(2,(&quot;INFO: head 2 has a digital panel AND an analog panel or CRT:\n&quot;));</a>
<a name="ln529">				LOG(2,(&quot;INFO: correcting...\n&quot;));</a>
<a name="ln530">				/* cross connect analog outputs so analog panel or CRT gets head 1 */</a>
<a name="ln531">				eng_general_output_select(true);</a>
<a name="ln532">				LOG(2,(&quot;INFO: head 1 has an analog panel or CRT;\n&quot;));</a>
<a name="ln533">				LOG(2,(&quot;INFO: head 2 has a digital panel:\n&quot;));</a>
<a name="ln534">				LOG(2,(&quot;INFO: defaulting to head 2 for primary use.\n&quot;));</a>
<a name="ln535">				si-&gt;ps.crtc2_prim = true;</a>
<a name="ln536">				break;</a>
<a name="ln537">			case 0x11: /* digital panels on both heads */</a>
<a name="ln538">				LOG(2,(&quot;INFO: head 1 has a digital panel;\n&quot;));</a>
<a name="ln539">				LOG(2,(&quot;INFO: head 2 has a digital panel:\n&quot;));</a>
<a name="ln540">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln541">				break;</a>
<a name="ln542">			case 0x12: /* analog panel or CRT on head 1, digital panel on head 2 */</a>
<a name="ln543">				LOG(2,(&quot;INFO: head 1 has an analog panel or CRT;\n&quot;));</a>
<a name="ln544">				LOG(2,(&quot;INFO: head 2 has a digital panel:\n&quot;));</a>
<a name="ln545">				LOG(2,(&quot;INFO: defaulting to head 2 for primary use.\n&quot;));</a>
<a name="ln546">				si-&gt;ps.crtc2_prim = true;</a>
<a name="ln547">				break;</a>
<a name="ln548">			case 0x21: /* digital panel on head 1, analog panel or CRT on head 2 */</a>
<a name="ln549">				LOG(2,(&quot;INFO: head 1 has a digital panel;\n&quot;));</a>
<a name="ln550">				LOG(2,(&quot;INFO: head 2 has an analog panel or CRT:\n&quot;));</a>
<a name="ln551">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln552">				break;</a>
<a name="ln553">			case 0x22: /* analog panel(s) or CRT(s) on both heads */</a>
<a name="ln554">				LOG(2,(&quot;INFO: head 1 has an analog panel or CRT;\n&quot;));</a>
<a name="ln555">				LOG(2,(&quot;INFO: head 2 has an analog panel or CRT:\n&quot;));</a>
<a name="ln556">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln557">				break;</a>
<a name="ln558">			default: /* more than two monitors connected to just two outputs: illegal! */</a>
<a name="ln559">				LOG(2,(&quot;INFO: illegal monitor setup ($%02x):\n&quot;, si-&gt;ps.monitors));</a>
<a name="ln560">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln561">				break;</a>
<a name="ln562">			}</a>
<a name="ln563">		}</a>
<a name="ln564">		else /* dualhead NV11 cards */</a>
<a name="ln565">		{</a>
<a name="ln566">			/* confirmed no analog output switch-options for NV11 */</a>
<a name="ln567">			LOG(2,(&quot;INFO: NV11 outputs are hardwired to be straight-through\n&quot;));</a>
<a name="ln568"> </a>
<a name="ln569">			/* presetup by the card's BIOS, we can't change this (lack of info) */</a>
<a name="ln570">			if (si-&gt;ps.tmds1_active) si-&gt;ps.monitors |= 0x01;</a>
<a name="ln571">			if (si-&gt;ps.tmds2_active) si-&gt;ps.monitors |= 0x10;</a>
<a name="ln572">			/* detect analog monitor (confirmed working OK on NV11): */</a>
<a name="ln573">			/* sense analog monitor on primary connector */</a>
<a name="ln574">			if (eng_dac_crt_connected()) si-&gt;ps.monitors |= 0x02;</a>
<a name="ln575">			/* (sense analog monitor on secondary connector is impossible on NV11) */</a>
<a name="ln576"> </a>
<a name="ln577">			/* setup correct output and head use */</a>
<a name="ln578">			//fixme? add TVout (only, so no CRT(s) connected) support...</a>
<a name="ln579">			switch (si-&gt;ps.monitors)</a>
<a name="ln580">			{</a>
<a name="ln581">			case 0x00: /* no monitor found at all */</a>
<a name="ln582">				LOG(2,(&quot;INFO: head 1 has nothing connected;\n&quot;));</a>
<a name="ln583">				LOG(2,(&quot;INFO: head 2 has nothing connected:\n&quot;));</a>
<a name="ln584">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln585">				break;</a>
<a name="ln586">			case 0x01: /* digital panel on head 1, nothing on head 2 */</a>
<a name="ln587">				LOG(2,(&quot;INFO: head 1 has a digital panel;\n&quot;));</a>
<a name="ln588">				LOG(2,(&quot;INFO: head 2 has nothing connected:\n&quot;));</a>
<a name="ln589">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln590">				break;</a>
<a name="ln591">			case 0x02: /* analog panel or CRT on head 1, nothing on head 2 */</a>
<a name="ln592">				LOG(2,(&quot;INFO: head 1 has an analog panel or CRT;\n&quot;));</a>
<a name="ln593">				LOG(2,(&quot;INFO: head 2 has nothing connected:\n&quot;));</a>
<a name="ln594">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln595">				break;</a>
<a name="ln596">			case 0x03: /* both types on head 1, nothing on head 2 */</a>
<a name="ln597">				LOG(2,(&quot;INFO: head 1 has a digital panel AND an analog panel or CRT;\n&quot;));</a>
<a name="ln598">				LOG(2,(&quot;INFO: head 2 has nothing connected:\n&quot;));</a>
<a name="ln599">				LOG(2,(&quot;INFO: correction not possible...\n&quot;));</a>
<a name="ln600">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln601">				break;</a>
<a name="ln602">			case 0x10: /* nothing on head 1, digital panel on head 2 */</a>
<a name="ln603">				LOG(2,(&quot;INFO: head 1 has nothing connected;\n&quot;));</a>
<a name="ln604">				LOG(2,(&quot;INFO: head 2 has a digital panel:\n&quot;));</a>
<a name="ln605">				LOG(2,(&quot;INFO: defaulting to head 2 for primary use.\n&quot;));</a>
<a name="ln606">				si-&gt;ps.crtc2_prim = true;</a>
<a name="ln607">				break;</a>
<a name="ln608">			case 0x11: /* digital panels on both heads */</a>
<a name="ln609">				LOG(2,(&quot;INFO: head 1 has a digital panel;\n&quot;));</a>
<a name="ln610">				LOG(2,(&quot;INFO: head 2 has a digital panel:\n&quot;));</a>
<a name="ln611">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln612">				break;</a>
<a name="ln613">			case 0x12: /* analog panel or CRT on head 1, digital panel on head 2 */</a>
<a name="ln614">				LOG(2,(&quot;INFO: head 1 has an analog panel or CRT;\n&quot;));</a>
<a name="ln615">				LOG(2,(&quot;INFO: head 2 has a digital panel:\n&quot;));</a>
<a name="ln616">				LOG(2,(&quot;INFO: defaulting to head 2 for primary use.\n&quot;));</a>
<a name="ln617">				si-&gt;ps.crtc2_prim = true;</a>
<a name="ln618">				break;</a>
<a name="ln619">			default: /* more than two monitors connected to just two outputs: illegal! */</a>
<a name="ln620">				LOG(2,(&quot;INFO: illegal monitor setup ($%02x):\n&quot;, si-&gt;ps.monitors));</a>
<a name="ln621">				LOG(2,(&quot;INFO: defaulting to head 1 for primary use.\n&quot;));</a>
<a name="ln622">				break;</a>
<a name="ln623">			}</a>
<a name="ln624">		}</a>
<a name="ln625">	}</a>
<a name="ln626">	else /* singlehead cards */</a>
<a name="ln627">	{</a>
<a name="ln628">//temporary (VIA)</a>
<a name="ln629">	si-&gt;ps.tmds1_active = false;</a>
<a name="ln630">	si-&gt;ps.tmds2_active = false;</a>
<a name="ln631"> </a>
<a name="ln632"> </a>
<a name="ln633">		/* presetup by the card's BIOS, we can't change this (lack of info) */</a>
<a name="ln634">		if (si-&gt;ps.tmds1_active) si-&gt;ps.monitors |= 0x01;</a>
<a name="ln635">		/* detect analog monitor (confirmed working OK on all cards): */</a>
<a name="ln636">		/* sense analog monitor on primary connector */</a>
<a name="ln637">//temporary (VIA)</a>
<a name="ln638">		if (1/*eng_dac_crt_connected()*/) si-&gt;ps.monitors |= 0x02;</a>
<a name="ln639"> </a>
<a name="ln640">		//fixme? add TVout (only, so no CRT connected) support...</a>
<a name="ln641">	}</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">void get_panel_modes(display_mode *p1, display_mode *p2, bool *pan1, bool *pan2)</a>
<a name="ln645">{</a>
<a name="ln646">	if (si-&gt;ps.tmds1_active)</a>
<a name="ln647">	{</a>
<a name="ln648">		/* timing ('modeline') */</a>
<a name="ln649">		p1-&gt;timing = si-&gt;ps.p1_timing;</a>
<a name="ln650">		/* setup the rest */</a>
<a name="ln651">		p1-&gt;space = B_CMAP8;</a>
<a name="ln652">		p1-&gt;virtual_width = p1-&gt;timing.h_display;</a>
<a name="ln653">		p1-&gt;virtual_height = p1-&gt;timing.v_display;</a>
<a name="ln654">		p1-&gt;h_display_start = 0;</a>
<a name="ln655">		p1-&gt;v_display_start = 0;</a>
<a name="ln656">		p1-&gt;flags = 0;</a>
<a name="ln657">		*pan1 = true;</a>
<a name="ln658">	}</a>
<a name="ln659">	else</a>
<a name="ln660">		*pan1 = false;</a>
<a name="ln661"> </a>
<a name="ln662">	if (si-&gt;ps.tmds2_active)</a>
<a name="ln663">	{</a>
<a name="ln664">		/* timing ('modeline') */</a>
<a name="ln665">		p2-&gt;timing = si-&gt;ps.p2_timing;</a>
<a name="ln666">		/* setup the rest */</a>
<a name="ln667">		p2-&gt;space = B_CMAP8;</a>
<a name="ln668">		p2-&gt;virtual_width = p2-&gt;timing.h_display;</a>
<a name="ln669">		p2-&gt;virtual_height = p2-&gt;timing.v_display;</a>
<a name="ln670">		p2-&gt;h_display_start = 0;</a>
<a name="ln671">		p2-&gt;v_display_start = 0;</a>
<a name="ln672">		p2-&gt;flags = 0;</a>
<a name="ln673">		*pan2 = true;</a>
<a name="ln674">	}</a>
<a name="ln675">	else</a>
<a name="ln676">		*pan2 = false;</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">static void pins_cle266_fake(void)</a>
<a name="ln680">{</a>
<a name="ln681">	si-&gt;ps.f_ref = 14.31818;</a>
<a name="ln682">	/* we have a standard PLL */</a>
<a name="ln683">	si-&gt;ps.ext_pll = false;</a>
<a name="ln684">	/* carefull not to take to high limits, and high should be &gt;= 2x low. */</a>
<a name="ln685">	si-&gt;ps.max_system_vco = 230;</a>
<a name="ln686">	si-&gt;ps.min_system_vco = 20;</a>
<a name="ln687">	si-&gt;ps.max_pixel_vco = 400; /* VESA BIOS uses upto 433Mhz */</a>
<a name="ln688">	si-&gt;ps.min_pixel_vco = 50; /* VESA BIOS uses downto 53.2Mhz */</a>
<a name="ln689">	si-&gt;ps.max_video_vco = 0;</a>
<a name="ln690">	si-&gt;ps.min_video_vco = 0;</a>
<a name="ln691">	si-&gt;ps.max_dac1_clock = 230;</a>
<a name="ln692">	si-&gt;ps.max_dac1_clock_8 = 230;</a>
<a name="ln693">	si-&gt;ps.max_dac1_clock_16 = 230;</a>
<a name="ln694">	/* 'failsave' values */</a>
<a name="ln695">	si-&gt;ps.max_dac1_clock_24 = 200;</a>
<a name="ln696">	si-&gt;ps.max_dac1_clock_32 = 180;</a>
<a name="ln697">	si-&gt;ps.max_dac1_clock_32dh = 180;</a>
<a name="ln698">	/* secondary head */</a>
<a name="ln699">	si-&gt;ps.max_dac2_clock = 0;</a>
<a name="ln700">	si-&gt;ps.max_dac2_clock_8 = 0;</a>
<a name="ln701">	si-&gt;ps.max_dac2_clock_16 = 0;</a>
<a name="ln702">	si-&gt;ps.max_dac2_clock_24 = 0;</a>
<a name="ln703">	si-&gt;ps.max_dac2_clock_32 = 0;</a>
<a name="ln704">	/* 'failsave' values */</a>
<a name="ln705">	si-&gt;ps.max_dac2_clock_32dh = 0;</a>
<a name="ln706">	//fixme: primary &amp; secondary_dvi should be overrule-able via skel.settings</a>
<a name="ln707">	si-&gt;ps.primary_dvi = false;</a>
<a name="ln708">	si-&gt;ps.secondary_dvi = false;</a>
<a name="ln709">	/* not used (yet) because no coldstart will be attempted (yet) */</a>
<a name="ln710">	si-&gt;ps.std_engine_clock = 90;</a>
<a name="ln711">	si-&gt;ps.std_memory_clock = 110;</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">static void pinsnv5_nv5m64_fake(void)</a>
<a name="ln715">{</a>
<a name="ln716">	/* we have a standard PLL */</a>
<a name="ln717">	si-&gt;ps.ext_pll = false;</a>
<a name="ln718">	/* carefull not to take to high limits, and high should be &gt;= 2x low. */</a>
<a name="ln719">	si-&gt;ps.max_system_vco = 300;</a>
<a name="ln720">	si-&gt;ps.min_system_vco = 128;</a>
<a name="ln721">	si-&gt;ps.max_pixel_vco = 300;</a>
<a name="ln722">	si-&gt;ps.min_pixel_vco = 128;</a>
<a name="ln723">	si-&gt;ps.max_video_vco = 0;</a>
<a name="ln724">	si-&gt;ps.min_video_vco = 0;</a>
<a name="ln725">	si-&gt;ps.max_dac1_clock = 300;</a>
<a name="ln726">	si-&gt;ps.max_dac1_clock_8 = 300;</a>
<a name="ln727">	si-&gt;ps.max_dac1_clock_16 = 300;</a>
<a name="ln728">	/* 'failsave' values */</a>
<a name="ln729">	si-&gt;ps.max_dac1_clock_24 = 270;</a>
<a name="ln730">	si-&gt;ps.max_dac1_clock_32 = 230;</a>
<a name="ln731">	si-&gt;ps.max_dac1_clock_32dh = 230;</a>
<a name="ln732">	/* secondary head */</a>
<a name="ln733">	si-&gt;ps.max_dac2_clock = 0;</a>
<a name="ln734">	si-&gt;ps.max_dac2_clock_8 = 0;</a>
<a name="ln735">	si-&gt;ps.max_dac2_clock_16 = 0;</a>
<a name="ln736">	si-&gt;ps.max_dac2_clock_24 = 0;</a>
<a name="ln737">	si-&gt;ps.max_dac2_clock_32 = 0;</a>
<a name="ln738">	/* 'failsave' values */</a>
<a name="ln739">	si-&gt;ps.max_dac2_clock_32dh = 0;</a>
<a name="ln740">	//fixme: primary &amp; secondary_dvi should be overrule-able via skel.settings</a>
<a name="ln741">	si-&gt;ps.primary_dvi = false;</a>
<a name="ln742">	si-&gt;ps.secondary_dvi = false;</a>
<a name="ln743">	/* not used (yet) because no coldstart will be attempted (yet) */</a>
<a name="ln744">	si-&gt;ps.std_engine_clock = 125;</a>
<a name="ln745">	si-&gt;ps.std_memory_clock = 150;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">static void pinsnv6_fake(void)</a>
<a name="ln749">{</a>
<a name="ln750">	/* we have a standard PLL */</a>
<a name="ln751">	si-&gt;ps.ext_pll = false;</a>
<a name="ln752">	/* carefull not to take to high limits, and high should be &gt;= 2x low. */</a>
<a name="ln753">	si-&gt;ps.max_system_vco = 300;</a>
<a name="ln754">	si-&gt;ps.min_system_vco = 128;</a>
<a name="ln755">	si-&gt;ps.max_pixel_vco = 300;</a>
<a name="ln756">	si-&gt;ps.min_pixel_vco = 128;</a>
<a name="ln757">	si-&gt;ps.max_video_vco = 0;</a>
<a name="ln758">	si-&gt;ps.min_video_vco = 0;</a>
<a name="ln759">	si-&gt;ps.max_dac1_clock = 300;</a>
<a name="ln760">	si-&gt;ps.max_dac1_clock_8 = 300;</a>
<a name="ln761">	si-&gt;ps.max_dac1_clock_16 = 300;</a>
<a name="ln762">	/* 'failsave' values */</a>
<a name="ln763">	si-&gt;ps.max_dac1_clock_24 = 270;</a>
<a name="ln764">	si-&gt;ps.max_dac1_clock_32 = 230;</a>
<a name="ln765">	si-&gt;ps.max_dac1_clock_32dh = 230;</a>
<a name="ln766">	/* secondary head */</a>
<a name="ln767">	si-&gt;ps.max_dac2_clock = 0;</a>
<a name="ln768">	si-&gt;ps.max_dac2_clock_8 = 0;</a>
<a name="ln769">	si-&gt;ps.max_dac2_clock_16 = 0;</a>
<a name="ln770">	si-&gt;ps.max_dac2_clock_24 = 0;</a>
<a name="ln771">	si-&gt;ps.max_dac2_clock_32 = 0;</a>
<a name="ln772">	/* 'failsave' values */</a>
<a name="ln773">	si-&gt;ps.max_dac2_clock_32dh = 0;</a>
<a name="ln774">	//fixme: primary &amp; secondary_dvi should be overrule-able via skel.settings</a>
<a name="ln775">	si-&gt;ps.primary_dvi = false;</a>
<a name="ln776">	si-&gt;ps.secondary_dvi = false;</a>
<a name="ln777">	/* not used (yet) because no coldstart will be attempted (yet) */</a>
<a name="ln778">	si-&gt;ps.std_engine_clock = 100;</a>
<a name="ln779">	si-&gt;ps.std_memory_clock = 125;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">static void pinsnv10_arch_fake(void)</a>
<a name="ln783">{</a>
<a name="ln784">	/* we have a standard PLL */</a>
<a name="ln785">	si-&gt;ps.ext_pll = false;</a>
<a name="ln786">	/* carefull not to take to high limits, and high should be &gt;= 2x low. */</a>
<a name="ln787">	si-&gt;ps.max_system_vco = 350;</a>
<a name="ln788">	si-&gt;ps.min_system_vco = 128;</a>
<a name="ln789">	si-&gt;ps.max_pixel_vco = 350;</a>
<a name="ln790">	si-&gt;ps.min_pixel_vco = 128;</a>
<a name="ln791">	si-&gt;ps.max_video_vco = 350;</a>
<a name="ln792">	si-&gt;ps.min_video_vco = 128;</a>
<a name="ln793">	si-&gt;ps.max_dac1_clock = 350;</a>
<a name="ln794">	si-&gt;ps.max_dac1_clock_8 = 350;</a>
<a name="ln795">	si-&gt;ps.max_dac1_clock_16 = 350;</a>
<a name="ln796">	/* 'failsave' values */</a>
<a name="ln797">	si-&gt;ps.max_dac1_clock_24 = 320;</a>
<a name="ln798">	si-&gt;ps.max_dac1_clock_32 = 280;</a>
<a name="ln799">	si-&gt;ps.max_dac1_clock_32dh = 250;</a>
<a name="ln800">	/* secondary head */</a>
<a name="ln801">	if (si-&gt;ps.card_type &lt; NV17)</a>
<a name="ln802">	{</a>
<a name="ln803">		/* if a GeForce2 has analog VGA dualhead capability,</a>
<a name="ln804">		 * it uses an external secondary DAC probably with limited capability. */</a>
<a name="ln805">		/* (called twinview technology) */</a>
<a name="ln806">		si-&gt;ps.max_dac2_clock = 200;</a>
<a name="ln807">		si-&gt;ps.max_dac2_clock_8 = 200;</a>
<a name="ln808">		si-&gt;ps.max_dac2_clock_16 = 200;</a>
<a name="ln809">		si-&gt;ps.max_dac2_clock_24 = 200;</a>
<a name="ln810">		si-&gt;ps.max_dac2_clock_32 = 200;</a>
<a name="ln811">		/* 'failsave' values */</a>
<a name="ln812">		si-&gt;ps.max_dac2_clock_32dh = 180;</a>
<a name="ln813">	}</a>
<a name="ln814">	else</a>
<a name="ln815">	{</a>
<a name="ln816">		/* GeForce4 cards have dual integrated DACs with identical capaability */</a>
<a name="ln817">		/* (called nview technology) */</a>
<a name="ln818">		si-&gt;ps.max_dac2_clock = 350;</a>
<a name="ln819">		si-&gt;ps.max_dac2_clock_8 = 350;</a>
<a name="ln820">		si-&gt;ps.max_dac2_clock_16 = 350;</a>
<a name="ln821">		/* 'failsave' values */</a>
<a name="ln822">		si-&gt;ps.max_dac2_clock_24 = 320;</a>
<a name="ln823">		si-&gt;ps.max_dac2_clock_32 = 280;</a>
<a name="ln824">		si-&gt;ps.max_dac2_clock_32dh = 250;</a>
<a name="ln825">	}</a>
<a name="ln826">	//fixme: primary &amp; secondary_dvi should be overrule-able via skel.settings</a>
<a name="ln827">	si-&gt;ps.primary_dvi = false;</a>
<a name="ln828">	si-&gt;ps.secondary_dvi = false;</a>
<a name="ln829">	/* not used (yet) because no coldstart will be attempted (yet) */</a>
<a name="ln830">	si-&gt;ps.std_engine_clock = 120;</a>
<a name="ln831">	si-&gt;ps.std_memory_clock = 150;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">static void pinsnv20_arch_fake(void)</a>
<a name="ln835">{</a>
<a name="ln836">	/* we have a standard PLL */</a>
<a name="ln837">	si-&gt;ps.ext_pll = false;</a>
<a name="ln838">	/* carefull not to take to high limits, and high should be &gt;= 2x low. */</a>
<a name="ln839">	si-&gt;ps.max_system_vco = 350;</a>
<a name="ln840">	si-&gt;ps.min_system_vco = 128;</a>
<a name="ln841">	si-&gt;ps.max_pixel_vco = 350;</a>
<a name="ln842">	si-&gt;ps.min_pixel_vco = 128;</a>
<a name="ln843">	si-&gt;ps.max_video_vco = 350;</a>
<a name="ln844">	si-&gt;ps.min_video_vco = 128;</a>
<a name="ln845">	si-&gt;ps.max_dac1_clock = 350;</a>
<a name="ln846">	si-&gt;ps.max_dac1_clock_8 = 350;</a>
<a name="ln847">	si-&gt;ps.max_dac1_clock_16 = 350;</a>
<a name="ln848">	/* 'failsave' values */</a>
<a name="ln849">	si-&gt;ps.max_dac1_clock_24 = 320;</a>
<a name="ln850">	si-&gt;ps.max_dac1_clock_32 = 280;</a>
<a name="ln851">	si-&gt;ps.max_dac1_clock_32dh = 250;</a>
<a name="ln852">	/* secondary head */</a>
<a name="ln853">	/* GeForce4 cards have dual integrated DACs with identical capaability */</a>
<a name="ln854">	/* (called nview technology) */</a>
<a name="ln855">	si-&gt;ps.max_dac2_clock = 350;</a>
<a name="ln856">	si-&gt;ps.max_dac2_clock_8 = 350;</a>
<a name="ln857">	si-&gt;ps.max_dac2_clock_16 = 350;</a>
<a name="ln858">	/* 'failsave' values */</a>
<a name="ln859">	si-&gt;ps.max_dac2_clock_24 = 320;</a>
<a name="ln860">	si-&gt;ps.max_dac2_clock_32 = 280;</a>
<a name="ln861">	si-&gt;ps.max_dac2_clock_32dh = 250;</a>
<a name="ln862">	//fixme: primary &amp; secondary_dvi should be overrule-able via skel.settings</a>
<a name="ln863">	si-&gt;ps.primary_dvi = false;</a>
<a name="ln864">	si-&gt;ps.secondary_dvi = false;</a>
<a name="ln865">	/* not used (yet) because no coldstart will be attempted (yet) */</a>
<a name="ln866">	si-&gt;ps.std_engine_clock = 175;</a>
<a name="ln867">	si-&gt;ps.std_memory_clock = 200;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">static void pinsnv30_arch_fake(void)</a>
<a name="ln871">{</a>
<a name="ln872">	/* determine PLL type */</a>
<a name="ln873">	LOG(8,(&quot;INFO: NV30 architecture chip, PIXPLLC2 DAC1 = $%08x, DAC2 = $%08x\n&quot;,</a>
<a name="ln874">		DACR(PIXPLLC2), DAC2R(PIXPLLC2)));</a>
<a name="ln875">	switch (si-&gt;ps.card_type)</a>
<a name="ln876">	{</a>
<a name="ln877">	case NV31:</a>
<a name="ln878">	case NV36:</a>
<a name="ln879">	case NV40:</a>
<a name="ln880">		/* we have a extended PLL */</a>
<a name="ln881">		si-&gt;ps.ext_pll = true;</a>
<a name="ln882">		break;</a>
<a name="ln883">	default:</a>
<a name="ln884">		/* we have a standard PLL */</a>
<a name="ln885">		si-&gt;ps.ext_pll = false;</a>
<a name="ln886">		break;</a>
<a name="ln887">	}</a>
<a name="ln888">	/* carefull not to take to high limits, and high should be &gt;= 2x low. */</a>
<a name="ln889">	si-&gt;ps.max_system_vco = 350;</a>
<a name="ln890">	si-&gt;ps.min_system_vco = 128;</a>
<a name="ln891">	si-&gt;ps.max_pixel_vco = 350;</a>
<a name="ln892">	si-&gt;ps.min_pixel_vco = 128;</a>
<a name="ln893">	si-&gt;ps.max_video_vco = 350;</a>
<a name="ln894">	si-&gt;ps.min_video_vco = 128;</a>
<a name="ln895">	si-&gt;ps.max_dac1_clock = 350;</a>
<a name="ln896">	si-&gt;ps.max_dac1_clock_8 = 350;</a>
<a name="ln897">	si-&gt;ps.max_dac1_clock_16 = 350;</a>
<a name="ln898">	/* 'failsave' values */</a>
<a name="ln899">	si-&gt;ps.max_dac1_clock_24 = 320;</a>
<a name="ln900">	si-&gt;ps.max_dac1_clock_32 = 280;</a>
<a name="ln901">	si-&gt;ps.max_dac1_clock_32dh = 250;</a>
<a name="ln902">	/* secondary head */</a>
<a name="ln903">	/* GeForceFX cards have dual integrated DACs with identical capaability */</a>
<a name="ln904">	/* (called nview technology) */</a>
<a name="ln905">	si-&gt;ps.max_dac2_clock = 350;</a>
<a name="ln906">	si-&gt;ps.max_dac2_clock_8 = 350;</a>
<a name="ln907">	si-&gt;ps.max_dac2_clock_16 = 350;</a>
<a name="ln908">	/* 'failsave' values */</a>
<a name="ln909">	si-&gt;ps.max_dac2_clock_24 = 320;</a>
<a name="ln910">	si-&gt;ps.max_dac2_clock_32 = 280;</a>
<a name="ln911">	si-&gt;ps.max_dac2_clock_32dh = 250;</a>
<a name="ln912">	//fixme: primary &amp; secondary_dvi should be overrule-able via skel.settings</a>
<a name="ln913">	si-&gt;ps.primary_dvi = false;</a>
<a name="ln914">	si-&gt;ps.secondary_dvi = false;</a>
<a name="ln915">	/* not used (yet) because no coldstart will be attempted (yet) */</a>
<a name="ln916">	si-&gt;ps.std_engine_clock = 190;</a>
<a name="ln917">	si-&gt;ps.std_memory_clock = 190;</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">static void getRAMsize(void)</a>
<a name="ln921">{</a>
<a name="ln922">	uint8 ram_size = 0;</a>
<a name="ln923"> </a>
<a name="ln924">	if (si-&gt;ps.card_arch == CLE266)</a>
<a name="ln925">	{</a>
<a name="ln926">		ram_size = SEQR(MSIZE_CLE266);</a>
<a name="ln927">	}</a>
<a name="ln928">	else</a>
<a name="ln929">	{</a>
<a name="ln930">		ram_size = SEQR(MSIZE_OTHER);</a>
<a name="ln931">	}</a>
<a name="ln932"> </a>
<a name="ln933">	if ((ram_size &gt; 16) &amp;&amp; (ram_size &lt;= 128))</a>
<a name="ln934">	{</a>
<a name="ln935">		/* 9.0 - 64.5Mb in 0.5Mb steps */</a>
<a name="ln936">		si-&gt;ps.memory_size = (ram_size + 1) * 512 * 1024;</a>
<a name="ln937">	}</a>
<a name="ln938">	else</a>
<a name="ln939">	{</a>
<a name="ln940">		if ((ram_size &gt; 0) &amp;&amp; (ram_size &lt;= 16))</a>
<a name="ln941">		{</a>
<a name="ln942">			/* 4 - 64Mb in 4Mb steps */</a>
<a name="ln943">			si-&gt;ps.memory_size = ram_size * 4 * 1024 * 1024;</a>
<a name="ln944">		}</a>
<a name="ln945">		else</a>
<a name="ln946">		{</a>
<a name="ln947">			LOG(8,(&quot;INFO: unable to detect RAMsize (read $%02x), assuming 16Mb\n&quot;));</a>
<a name="ln948">			si-&gt;ps.memory_size = 16 * 1024 * 1024;</a>
<a name="ln949">		}</a>
<a name="ln950">	}</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953">static void getstrap_arch_nv4(void)</a>
<a name="ln954">{</a>
<a name="ln955">	uint32 strapinfo = ENG_REG32(RG32_NVSTRAPINFO2);</a>
<a name="ln956"> </a>
<a name="ln957">	/* determine PLL reference crystal frequency */</a>
<a name="ln958">	if (strapinfo &amp; 0x00000040)</a>
<a name="ln959">		si-&gt;ps.f_ref = 14.31818;</a>
<a name="ln960">	else</a>
<a name="ln961">		si-&gt;ps.f_ref = 13.50000;</a>
<a name="ln962"> </a>
<a name="ln963">	/* these cards are always singlehead */</a>
<a name="ln964">	si-&gt;ps.secondary_head = false;</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">static void getstrap_arch_nv10_20_30_40(void)</a>
<a name="ln968">{</a>
<a name="ln969">	uint32 dev_manID = CFGR(DEVID);</a>
<a name="ln970">	uint32 strapinfo = ENG_REG32(RG32_NVSTRAPINFO2);</a>
<a name="ln971"> </a>
<a name="ln972">	/* determine PLL reference crystal frequency: three types are used... */</a>
<a name="ln973">	if (strapinfo &amp; 0x00000040)</a>
<a name="ln974">		si-&gt;ps.f_ref = 14.31818;</a>
<a name="ln975">	else</a>
<a name="ln976">		si-&gt;ps.f_ref = 13.50000;</a>
<a name="ln977"> </a>
<a name="ln978">	switch (dev_manID &amp; 0xfff0ffff)</a>
<a name="ln979">	{</a>
<a name="ln980">	/* Nvidia cards: */</a>
<a name="ln981">	case 0x004010de:</a>
<a name="ln982">	case 0x00c010de:</a>
<a name="ln983">	case 0x00f010de:</a>
<a name="ln984">	case 0x014010de:</a>
<a name="ln985">	case 0x017010de:</a>
<a name="ln986">	case 0x018010de:</a>
<a name="ln987">	case 0x01f010de:</a>
<a name="ln988">	case 0x025010de:</a>
<a name="ln989">	case 0x028010de:</a>
<a name="ln990">	case 0x030010de:</a>
<a name="ln991">	case 0x031010de:</a>
<a name="ln992">	case 0x032010de:</a>
<a name="ln993">	case 0x033010de:</a>
<a name="ln994">	case 0x034010de:</a>
<a name="ln995">	/* Varisys cards: */</a>
<a name="ln996">	case 0x35001888:</a>
<a name="ln997">		if (strapinfo &amp; 0x00400000) si-&gt;ps.f_ref = 27.00000;</a>
<a name="ln998">		break;</a>
<a name="ln999">	default:</a>
<a name="ln1000">		break;</a>
<a name="ln1001">	}</a>
<a name="ln1002"> </a>
<a name="ln1003">	/* determine if we have a dualhead card */</a>
<a name="ln1004">	switch (dev_manID &amp; 0xfff0ffff)</a>
<a name="ln1005">	{</a>
<a name="ln1006">	/* Nvidia cards: */</a>
<a name="ln1007">	case 0x004010de:</a>
<a name="ln1008">	case 0x00c010de:</a>
<a name="ln1009">	case 0x00f010de:</a>
<a name="ln1010">	case 0x011010de:</a>
<a name="ln1011">	case 0x014010de:</a>
<a name="ln1012">	case 0x017010de:</a>
<a name="ln1013">	case 0x018010de:</a>
<a name="ln1014">	case 0x01f010de:</a>
<a name="ln1015">	case 0x025010de:</a>
<a name="ln1016">	case 0x028010de:</a>
<a name="ln1017">	case 0x030010de:</a>
<a name="ln1018">	case 0x031010de:</a>
<a name="ln1019">	case 0x032010de:</a>
<a name="ln1020">	case 0x033010de:</a>
<a name="ln1021">	case 0x034010de:</a>
<a name="ln1022">	/* Varisys cards: */</a>
<a name="ln1023">	case 0x35001888:</a>
<a name="ln1024">		si-&gt;ps.secondary_head = true;</a>
<a name="ln1025">		break;</a>
<a name="ln1026">	default:</a>
<a name="ln1027">		si-&gt;ps.secondary_head = false;</a>
<a name="ln1028">		break;</a>
<a name="ln1029">	}</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">void dump_pins(void)</a>
<a name="ln1033">{</a>
<a name="ln1034">	char *msg = &quot;&quot;;</a>
<a name="ln1035"> </a>
<a name="ln1036">	LOG(2,(&quot;INFO: pinsdump follows:\n&quot;));</a>
<a name="ln1037">	LOG(2,(&quot;PLL type: &quot;));</a>
<a name="ln1038">	if (si-&gt;ps.ext_pll) LOG(2,(&quot;extended\n&quot;)); else LOG(2,(&quot;standard\n&quot;));</a>
<a name="ln1039">	LOG(2,(&quot;f_ref: %fMhz\n&quot;, si-&gt;ps.f_ref));</a>
<a name="ln1040">	LOG(2,(&quot;max_system_vco: %dMhz\n&quot;, si-&gt;ps.max_system_vco));</a>
<a name="ln1041">	LOG(2,(&quot;min_system_vco: %dMhz\n&quot;, si-&gt;ps.min_system_vco));</a>
<a name="ln1042">	LOG(2,(&quot;max_pixel_vco: %dMhz\n&quot;, si-&gt;ps.max_pixel_vco));</a>
<a name="ln1043">	LOG(2,(&quot;min_pixel_vco: %dMhz\n&quot;, si-&gt;ps.min_pixel_vco));</a>
<a name="ln1044">	LOG(2,(&quot;max_video_vco: %dMhz\n&quot;, si-&gt;ps.max_video_vco));</a>
<a name="ln1045">	LOG(2,(&quot;min_video_vco: %dMhz\n&quot;, si-&gt;ps.min_video_vco));</a>
<a name="ln1046">	LOG(2,(&quot;std_engine_clock: %dMhz\n&quot;, si-&gt;ps.std_engine_clock));</a>
<a name="ln1047">	LOG(2,(&quot;std_memory_clock: %dMhz\n&quot;, si-&gt;ps.std_memory_clock));</a>
<a name="ln1048">	LOG(2,(&quot;max_dac1_clock: %dMhz\n&quot;, si-&gt;ps.max_dac1_clock));</a>
<a name="ln1049">	LOG(2,(&quot;max_dac1_clock_8: %dMhz\n&quot;, si-&gt;ps.max_dac1_clock_8));</a>
<a name="ln1050">	LOG(2,(&quot;max_dac1_clock_16: %dMhz\n&quot;, si-&gt;ps.max_dac1_clock_16));</a>
<a name="ln1051">	LOG(2,(&quot;max_dac1_clock_24: %dMhz\n&quot;, si-&gt;ps.max_dac1_clock_24));</a>
<a name="ln1052">	LOG(2,(&quot;max_dac1_clock_32: %dMhz\n&quot;, si-&gt;ps.max_dac1_clock_32));</a>
<a name="ln1053">	LOG(2,(&quot;max_dac1_clock_32dh: %dMhz\n&quot;, si-&gt;ps.max_dac1_clock_32dh));</a>
<a name="ln1054">	LOG(2,(&quot;max_dac2_clock: %dMhz\n&quot;, si-&gt;ps.max_dac2_clock));</a>
<a name="ln1055">	LOG(2,(&quot;max_dac2_clock_8: %dMhz\n&quot;, si-&gt;ps.max_dac2_clock_8));</a>
<a name="ln1056">	LOG(2,(&quot;max_dac2_clock_16: %dMhz\n&quot;, si-&gt;ps.max_dac2_clock_16));</a>
<a name="ln1057">	LOG(2,(&quot;max_dac2_clock_24: %dMhz\n&quot;, si-&gt;ps.max_dac2_clock_24));</a>
<a name="ln1058">	LOG(2,(&quot;max_dac2_clock_32: %dMhz\n&quot;, si-&gt;ps.max_dac2_clock_32));</a>
<a name="ln1059">	LOG(2,(&quot;max_dac2_clock_32dh: %dMhz\n&quot;, si-&gt;ps.max_dac2_clock_32dh));</a>
<a name="ln1060">	LOG(2,(&quot;secondary_head: &quot;));</a>
<a name="ln1061">	if (si-&gt;ps.secondary_head) LOG(2,(&quot;present\n&quot;)); else LOG(2,(&quot;absent\n&quot;));</a>
<a name="ln1062">	LOG(2,(&quot;tvout: &quot;));</a>
<a name="ln1063">	if (si-&gt;ps.tvout) LOG(2,(&quot;present\n&quot;)); else LOG(2,(&quot;absent\n&quot;));</a>
<a name="ln1064">	/* setup TVout logmessage text */</a>
<a name="ln1065">	switch (si-&gt;ps.tvout_chip_type)</a>
<a name="ln1066">	{</a>
<a name="ln1067">	case NONE:</a>
<a name="ln1068">		msg = &quot;No&quot;;</a>
<a name="ln1069">		break;</a>
<a name="ln1070">	case CH7003:</a>
<a name="ln1071">		msg = &quot;Chrontel CH7003&quot;;</a>
<a name="ln1072">		break;</a>
<a name="ln1073">	case CH7004:</a>
<a name="ln1074">		msg = &quot;Chrontel CH7004&quot;;</a>
<a name="ln1075">		break;</a>
<a name="ln1076">	case CH7005:</a>
<a name="ln1077">		msg = &quot;Chrontel CH7005&quot;;</a>
<a name="ln1078">		break;</a>
<a name="ln1079">	case CH7006:</a>
<a name="ln1080">		msg = &quot;Chrontel CH7006&quot;;</a>
<a name="ln1081">		break;</a>
<a name="ln1082">	case CH7007:</a>
<a name="ln1083">		msg = &quot;Chrontel CH7007&quot;;</a>
<a name="ln1084">		break;</a>
<a name="ln1085">	case CH7008:</a>
<a name="ln1086">		msg = &quot;Chrontel CH7008&quot;;</a>
<a name="ln1087">		break;</a>
<a name="ln1088">	case SAA7102:</a>
<a name="ln1089">		msg = &quot;Philips SAA7102&quot;;</a>
<a name="ln1090">		break;</a>
<a name="ln1091">	case SAA7103:</a>
<a name="ln1092">		msg = &quot;Philips SAA7103&quot;;</a>
<a name="ln1093">		break;</a>
<a name="ln1094">	case SAA7104:</a>
<a name="ln1095">		msg = &quot;Philips SAA7104&quot;;</a>
<a name="ln1096">		break;</a>
<a name="ln1097">	case SAA7105:</a>
<a name="ln1098">		msg = &quot;Philips SAA7105&quot;;</a>
<a name="ln1099">		break;</a>
<a name="ln1100">	case BT868:</a>
<a name="ln1101">		msg = &quot;Brooktree/Conexant BT868&quot;;</a>
<a name="ln1102">		break;</a>
<a name="ln1103">	case BT869:</a>
<a name="ln1104">		msg = &quot;Brooktree/Conexant BT869&quot;;</a>
<a name="ln1105">		break;</a>
<a name="ln1106">	case CX25870:</a>
<a name="ln1107">		msg = &quot;Conexant CX25870&quot;;</a>
<a name="ln1108">		break;</a>
<a name="ln1109">	case CX25871:</a>
<a name="ln1110">		msg = &quot;Conexant CX25871&quot;;</a>
<a name="ln1111">		break;</a>
<a name="ln1112">	case NVIDIA:</a>
<a name="ln1113">		msg = &quot;Nvidia internal&quot;;</a>
<a name="ln1114">		break;</a>
<a name="ln1115">	default:</a>
<a name="ln1116">		msg = &quot;Unknown&quot;;</a>
<a name="ln1117">		break;</a>
<a name="ln1118">	}</a>
<a name="ln1119">	LOG(2, (&quot;%s TVout chip detected\n&quot;, msg));</a>
<a name="ln1120">//	LOG(2,(&quot;primary_dvi: &quot;));</a>
<a name="ln1121">//	if (si-&gt;ps.primary_dvi) LOG(2,(&quot;present\n&quot;)); else LOG(2,(&quot;absent\n&quot;));</a>
<a name="ln1122">//	LOG(2,(&quot;secondary_dvi: &quot;));</a>
<a name="ln1123">//	if (si-&gt;ps.secondary_dvi) LOG(2,(&quot;present\n&quot;)); else LOG(2,(&quot;absent\n&quot;));</a>
<a name="ln1124">	LOG(2,(&quot;card memory_size: %3.3fMb\n&quot;, (si-&gt;ps.memory_size / (1024.0 * 1024.0))));</a>
<a name="ln1125">	LOG(2,(&quot;laptop: &quot;));</a>
<a name="ln1126">	if (si-&gt;ps.laptop) LOG(2,(&quot;yes\n&quot;)); else LOG(2,(&quot;no\n&quot;));</a>
<a name="ln1127">	if (si-&gt;ps.tmds1_active)</a>
<a name="ln1128">	{</a>
<a name="ln1129">		LOG(2,(&quot;found DFP (digital flatpanel) on CRTC1; CRTC1 is &quot;));</a>
<a name="ln1130">		if (si-&gt;ps.slaved_tmds1) LOG(2,(&quot;slaved\n&quot;)); else LOG(2,(&quot;master\n&quot;));</a>
<a name="ln1131">		LOG(2,(&quot;panel width: %d, height: %d, aspect ratio: %1.2f\n&quot;,</a>
<a name="ln1132">			si-&gt;ps.p1_timing.h_display, si-&gt;ps.p1_timing.v_display, si-&gt;ps.panel1_aspect));</a>
<a name="ln1133">	}</a>
<a name="ln1134">	if (si-&gt;ps.tmds2_active)</a>
<a name="ln1135">	{</a>
<a name="ln1136">		LOG(2,(&quot;found DFP (digital flatpanel) on CRTC2; CRTC2 is &quot;));</a>
<a name="ln1137">		if (si-&gt;ps.slaved_tmds2) LOG(2,(&quot;slaved\n&quot;)); else LOG(2,(&quot;master\n&quot;));</a>
<a name="ln1138">		LOG(2,(&quot;panel width: %d, height: %d, aspect ratio: %1.2f\n&quot;,</a>
<a name="ln1139">			si-&gt;ps.p2_timing.h_display, si-&gt;ps.p2_timing.v_display, si-&gt;ps.panel2_aspect));</a>
<a name="ln1140">	}</a>
<a name="ln1141">	LOG(2,(&quot;monitor (output devices) setup matrix: $%02x\n&quot;, si-&gt;ps.monitors));</a>
<a name="ln1142">	LOG(2,(&quot;INFO: end pinsdump.\n&quot;));</a>
<a name="ln1143">}</a>

</code></pre>
<div class="balloon" rel="48"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'result == (- 1)' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
