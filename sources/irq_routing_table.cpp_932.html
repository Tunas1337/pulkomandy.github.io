
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>irq_routing_table.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2011, Michael Lotz mmlr@mlotz.ch.</a>
<a name="ln3"> * Copyright 2009, Clemens Zeidler haiku@clemens-zeidler.de.</a>
<a name="ln4"> * All rights reserved.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Distributed under the terms of the MIT License.</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;irq_routing_table.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;acpi.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;int.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;PCI.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">//#define TRACE_PRT</a>
<a name="ln20">#ifdef TRACE_PRT</a>
<a name="ln21">#	define TRACE(x...) dprintf(&quot;IRQRoutingTable: &quot; x)</a>
<a name="ln22">#else</a>
<a name="ln23">#	define TRACE(x...)</a>
<a name="ln24">#endif</a>
<a name="ln25"> </a>
<a name="ln26"> </a>
<a name="ln27">const char* kACPIPciRootName = &quot;PNP0A03&quot;;</a>
<a name="ln28">const char* kACPIPciExpressRootName = &quot;PNP0A08&quot;;</a>
<a name="ln29">	// Note that some configurations will still return the PCI express root</a>
<a name="ln30">	// when querying for the standard PCI root. This is due to the compatible ID</a>
<a name="ln31">	// fields in ACPI. TODO: Query both/the correct root device.</a>
<a name="ln32"> </a>
<a name="ln33">// TODO: as per PCI 3.0, the PCI module hardcodes it in various places as well.</a>
<a name="ln34">static const uint8 kMaxPCIFunctionCount = 8;</a>
<a name="ln35">static const uint8 kMaxPCIDeviceCount = 32;</a>
<a name="ln36">	// TODO: actually this is mechanism dependent</a>
<a name="ln37">static const uint8 kMaxISAInterrupts = 16;</a>
<a name="ln38"> </a>
<a name="ln39">irq_descriptor::irq_descriptor()</a>
<a name="ln40">	:</a>
<a name="ln41">	irq(0),</a>
<a name="ln42">	shareable(false),</a>
<a name="ln43">	polarity(B_HIGH_ACTIVE_POLARITY),</a>
<a name="ln44">	trigger_mode(B_EDGE_TRIGGERED)</a>
<a name="ln45">{</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">void</a>
<a name="ln50">print_irq_descriptor(const irq_descriptor&amp; descriptor)</a>
<a name="ln51">{</a>
<a name="ln52">	const char* activeHighString = &quot;active high&quot;;</a>
<a name="ln53">	const char* activeLowString = &quot; active low&quot;;</a>
<a name="ln54">	const char* levelTriggeredString = &quot;level triggered&quot;;</a>
<a name="ln55">	const char* edgeTriggeredString = &quot;edge triggered&quot;;</a>
<a name="ln56"> </a>
<a name="ln57">	dprintf(&quot;irq: %u, shareable: %u, polarity: %s, trigger_mode: %s\n&quot;,</a>
<a name="ln58">		descriptor.irq, descriptor.shareable,</a>
<a name="ln59">		descriptor.polarity == B_HIGH_ACTIVE_POLARITY ? activeHighString</a>
<a name="ln60">			: activeLowString,</a>
<a name="ln61">		descriptor.trigger_mode == B_LEVEL_TRIGGERED ? levelTriggeredString</a>
<a name="ln62">			: edgeTriggeredString);</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">static void</a>
<a name="ln67">print_irq_routing_entry(const irq_routing_entry&amp; entry)</a>
<a name="ln68">{</a>
<a name="ln69">	dprintf(&quot;address 0x%04&quot; B_PRIx64 &quot;; pin %u;&quot;, entry.device_address,</a>
<a name="ln70">		entry.pin);</a>
<a name="ln71"> </a>
<a name="ln72">	if (entry.source_index != 0)</a>
<a name="ln73">		dprintf(&quot; GSI %&quot; B_PRIu32 &quot;;&quot;, entry.source_index);</a>
<a name="ln74">	else</a>
<a name="ln75">		dprintf(&quot; source %p %&quot; B_PRIu32 &quot;;&quot;, entry.source, entry.source_index);</a>
<a name="ln76"> </a>
<a name="ln77">	dprintf(&quot; pci %u:%u pin %u func mask %&quot; B_PRIx32 &quot;; bios irq: %u; gsi %u;&quot;</a>
<a name="ln78">		&quot; config 0x%02x\n&quot;, entry.pci_bus, entry.pci_device, entry.pin + 1,</a>
<a name="ln79">		entry.pci_function_mask, entry.bios_irq, entry.irq,</a>
<a name="ln80">		entry.polarity | entry.trigger_mode);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">void</a>
<a name="ln85">print_irq_routing_table(const IRQRoutingTable&amp; table)</a>
<a name="ln86">{</a>
<a name="ln87">	dprintf(&quot;IRQ routing table with %i entries\n&quot;, (int)table.Count());</a>
<a name="ln88">	for (int i = 0; i &lt; table.Count(); i++)</a>
<a name="ln89">		print_irq_routing_entry(table.ElementAt(i));</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">static status_t</a>
<a name="ln94">update_pci_info_for_entry(pci_module_info* pci, const irq_routing_entry&amp; entry)</a>
<a name="ln95">{</a>
<a name="ln96">	uint32 updateCount = 0;</a>
<a name="ln97">	for (uint8 function = 0; function &lt; kMaxPCIFunctionCount; function++) {</a>
<a name="ln98">		if ((entry.pci_function_mask &amp; (1 &lt;&lt; function)) == 0)</a>
<a name="ln99">			continue;</a>
<a name="ln100"> </a>
<a name="ln101">		if (pci-&gt;update_interrupt_line(entry.pci_bus, entry.pci_device,</a>
<a name="ln102">			function, entry.irq) == B_OK) {</a>
<a name="ln103">			updateCount++;</a>
<a name="ln104">		}</a>
<a name="ln105">	}</a>
<a name="ln106"> </a>
<a name="ln107">	return updateCount &gt; 0 ? B_OK : B_ENTRY_NOT_FOUND;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">static status_t</a>
<a name="ln112">fill_pci_info_for_entry(pci_module_info* pci, irq_routing_entry&amp; entry)</a>
<a name="ln113">{</a>
<a name="ln114">	// check the base device at function 0</a>
<a name="ln115">	uint8 headerType = pci-&gt;read_pci_config(entry.pci_bus, entry.pci_device, 0,</a>
<a name="ln116">		PCI_header_type, 1);</a>
<a name="ln117">	if (headerType == 0xff) {</a>
<a name="ln118">		TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; entry not found\n&quot;,</a>
<a name="ln119">			entry.pci_bus, entry.pci_device);</a>
<a name="ln120">		// the device is not present</a>
<a name="ln121">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln122">	}</a>
<a name="ln123"> </a>
<a name="ln124">	// we have a device, check how many functions we need to iterate</a>
<a name="ln125">	uint8 functionCount = 1;</a>
<a name="ln126">	if ((headerType &amp; PCI_multifunction) != 0)</a>
<a name="ln127">		functionCount = kMaxPCIFunctionCount;</a>
<a name="ln128"> </a>
<a name="ln129">	for (uint8 function = 0; function &lt; functionCount; function++) {</a>
<a name="ln130">		// check for device presence by looking for a valid vendor</a>
<a name="ln131">		uint16 vendorId = pci-&gt;read_pci_config(entry.pci_bus, entry.pci_device,</a>
<a name="ln132">			function, PCI_vendor_id, 2);</a>
<a name="ln133">		if (vendorId == 0xffff) {</a>
<a name="ln134">			TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; vendor 0xffff\n&quot;,</a>
<a name="ln135">				entry.pci_bus, entry.pci_device, function);</a>
<a name="ln136">			continue;</a>
<a name="ln137">		}</a>
<a name="ln138"> </a>
<a name="ln139">		uint8 interruptPin = pci-&gt;read_pci_config(entry.pci_bus,</a>
<a name="ln140">			entry.pci_device, function, PCI_interrupt_pin, 1);</a>
<a name="ln141"> </a>
<a name="ln142">		// Finally match the pin with the entry, note that PCI pins are 1 based</a>
<a name="ln143">		// while ACPI ones are 0 based.</a>
<a name="ln144">		if (interruptPin != entry.pin + 1) {</a>
<a name="ln145">			TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; IRQ Pin %&quot; B_PRIu8</a>
<a name="ln146">				&quot; != %&quot; B_PRIu8 &quot;\n&quot;, entry.pci_bus, entry.pci_device, function,</a>
<a name="ln147">				interruptPin, entry.pin + 1);</a>
<a name="ln148">			continue;</a>
<a name="ln149">		}</a>
<a name="ln150"> </a>
<a name="ln151">		if (entry.bios_irq == 0) {</a>
<a name="ln152">			// Keep the originally assigned IRQ around so we can use it for</a>
<a name="ln153">			// white listing PCI IRQs in the ISA space as those are basically</a>
<a name="ln154">			// guaranteed not to overlap with ISA devices. Those white listed</a>
<a name="ln155">			// entries can then be used if we only have a 16 pin IO-APIC or if</a>
<a name="ln156">			// there are only legacy IRQ resources available for configuration</a>
<a name="ln157">			// (with bitmasks of 16 bits, limiting their range to ISA IRQs).</a>
<a name="ln158">			entry.bios_irq = pci-&gt;read_pci_config(entry.pci_bus,</a>
<a name="ln159">				entry.pci_device, function, PCI_interrupt_line, 1);</a>
<a name="ln160">		}</a>
<a name="ln161"> </a>
<a name="ln162">		entry.pci_function_mask |= 1 &lt;&lt; function;</a>
<a name="ln163">	}</a>
<a name="ln164"> </a>
<a name="ln165">	return entry.pci_function_mask != 0 ? B_OK : B_ENTRY_NOT_FOUND;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168"> </a>
<a name="ln169">static status_t</a>
<a name="ln170">choose_link_device_configurations(acpi_module_info* acpi,</a>
<a name="ln171">	IRQRoutingTable&amp; routingTable,</a>
<a name="ln172">	interrupt_available_check_function checkFunction)</a>
<a name="ln173">{</a>
<a name="ln174">	/*</a>
<a name="ln175">		Before configuring the link devices we have to take a few things into</a>
<a name="ln176">		consideration:</a>
<a name="ln177">		* Multiple PCI devices / functions may link to the same PCI link</a>
<a name="ln178">		  device, so we must ensure that we don't try to configure different</a>
<a name="ln179">		  IRQs for each device, overwriting the previous config of the</a>
<a name="ln180">		  respective link device.</a>
<a name="ln181">		* If we can't use non-ISA IRQs then we must ensure that we don't</a>
<a name="ln182">		  configure any IRQs that overlaps with ISA devices (as they use</a>
<a name="ln183">		  different triggering modes and polarity they aren't compatible).</a>
<a name="ln184">		  Since the ISA bus isn't enumerable we don't have any clues as to</a>
<a name="ln185">		  where an ISA device might be connected. The only safe assumption</a>
<a name="ln186">		  therefore is to only use IRQs that are known to be usable for PCI</a>
<a name="ln187">		  devices. In our case we can use all the previously assigned PCI</a>
<a name="ln188">		  interrupt_line IRQs as stored in the bios_irq field.</a>
<a name="ln189">	*/</a>
<a name="ln190"> </a>
<a name="ln191">	uint16 validForPCI = 0; // only applies to the ISA IRQs</a>
<a name="ln192">	uint16 irqUsage[256];</a>
<a name="ln193">	memset(irqUsage, 0, sizeof(irqUsage));</a>
<a name="ln194"> </a>
<a name="ln195">	// find all unique link devices and resolve their possible IRQs</a>
<a name="ln196">	Vector&lt;link_device*&gt; links;</a>
<a name="ln197">	for (int i = 0; i &lt; routingTable.Count(); i++) {</a>
<a name="ln198">		irq_routing_entry&amp; irqEntry = routingTable.ElementAt(i);</a>
<a name="ln199"> </a>
<a name="ln200">		if (irqEntry.bios_irq != 0 &amp;&amp; irqEntry.bios_irq != 255) {</a>
<a name="ln201">			if (irqEntry.bios_irq &lt; kMaxISAInterrupts)</a>
<a name="ln202">				validForPCI |= (1 &lt;&lt; irqEntry.bios_irq);</a>
<a name="ln203">		}</a>
<a name="ln204"> </a>
<a name="ln205">		if (irqEntry.source == NULL) {</a>
<a name="ln206">			// populate all hardwired GSI entries into our map</a>
<a name="ln207">			irqUsage[irqEntry.irq]++;</a>
<a name="ln208">			if (irqEntry.irq &lt; kMaxISAInterrupts)</a>
<a name="ln209">				validForPCI |= (1 &lt;&lt; irqEntry.irq);</a>
<a name="ln210">			continue;</a>
<a name="ln211">		}</a>
<a name="ln212"> </a>
<a name="ln213">		link_device* link = NULL;</a>
<a name="ln214">		for (int j = 0; j &lt; links.Count(); j++) {</a>
<a name="ln215">			link_device* existing = links.ElementAt(j);</a>
<a name="ln216">			if (existing-&gt;handle == irqEntry.source) {</a>
<a name="ln217">				link = existing;</a>
<a name="ln218">				break;</a>
<a name="ln219">			}</a>
<a name="ln220">		}</a>
<a name="ln221"> </a>
<a name="ln222">		if (link != NULL) {</a>
<a name="ln223">			link-&gt;used_by.PushBack(&amp;irqEntry);</a>
<a name="ln224">			continue;</a>
<a name="ln225">		}</a>
<a name="ln226"> </a>
<a name="ln227">		// A new link device, read possible IRQs and fill them in.</a>
<a name="ln228">		link = new(std::nothrow) link_device;</a>
<a name="ln229">		if (link == NULL) {</a>
<a name="ln230">			panic(&quot;ran out of memory while configuring irq link devices&quot;);</a>
<a name="ln231">			return B_NO_MEMORY;</a>
<a name="ln232">		}</a>
<a name="ln233"> </a>
<a name="ln234">		link-&gt;handle = irqEntry.source;</a>
<a name="ln235">		status_t status = read_possible_irqs(acpi, link-&gt;handle,</a>
<a name="ln236">			link-&gt;possible_irqs);</a>
<a name="ln237">		if (status != B_OK) {</a>
<a name="ln238">			panic(&quot;failed to read possible irqs of link device&quot;);</a>
<a name="ln239">			return status;</a>
<a name="ln240">		}</a>
<a name="ln241"> </a>
<a name="ln242">		status = read_current_irq(acpi, link-&gt;handle, link-&gt;current_irq);</a>
<a name="ln243">		if (status != B_OK) {</a>
<a name="ln244">			panic(&quot;failed to read current irq of link device&quot;);</a>
<a name="ln245">			return status;</a>
<a name="ln246">		}</a>
<a name="ln247"> </a>
<a name="ln248">		if (link-&gt;current_irq.irq &lt; kMaxISAInterrupts)</a>
<a name="ln249">			validForPCI |= (1 &lt;&lt; link-&gt;current_irq.irq);</a>
<a name="ln250"> </a>
<a name="ln251">		link-&gt;used_by.PushBack(&amp;irqEntry);</a>
<a name="ln252">		links.PushBack(link);</a>
<a name="ln253">	}</a>
<a name="ln254"> </a>
<a name="ln255">	for (int i = 0; i &lt; links.Count(); i++) {</a>
<a name="ln256">		link_device* link = links.ElementAt(i);</a>
<a name="ln257"> </a>
<a name="ln258">		int bestIRQIndex = 0;</a>
<a name="ln259">		uint16 bestIRQUsage = UINT16_MAX;</a>
<a name="ln260">		for (int j = 0; j &lt; link-&gt;possible_irqs.Count(); j++) {</a>
<a name="ln261">			irq_descriptor&amp; possibleIRQ = link-&gt;possible_irqs.ElementAt(j);</a>
<a name="ln262">			if (!checkFunction(possibleIRQ.irq)) {</a>
<a name="ln263">				// we can't address this pin</a>
<a name="ln264">				continue;</a>
<a name="ln265">			}</a>
<a name="ln266"> </a>
<a name="ln267">			if (possibleIRQ.irq &lt; kMaxISAInterrupts</a>
<a name="ln268">				&amp;&amp; (validForPCI &amp; (1 &lt;&lt; possibleIRQ.irq)) == 0) {</a>
<a name="ln269">				// better avoid that if possible</a>
<a name="ln270">				continue;</a>
<a name="ln271">			}</a>
<a name="ln272"> </a>
<a name="ln273">			if (irqUsage[possibleIRQ.irq] &lt; bestIRQUsage) {</a>
<a name="ln274">				bestIRQIndex = j;</a>
<a name="ln275">				bestIRQUsage = irqUsage[possibleIRQ.irq];</a>
<a name="ln276">			}</a>
<a name="ln277">		}</a>
<a name="ln278"> </a>
<a name="ln279">		// pick that one and update the counts</a>
<a name="ln280">		irq_descriptor&amp; chosenDescriptor</a>
<a name="ln281">			= link-&gt;possible_irqs.ElementAt(bestIRQIndex);</a>
<a name="ln282">		if (!checkFunction(chosenDescriptor.irq)) {</a>
<a name="ln283">			dprintf(&quot;chosen irq %u is not addressable\n&quot;, chosenDescriptor.irq);</a>
<a name="ln284">			return B_ERROR;</a>
<a name="ln285">		}</a>
<a name="ln286"> </a>
<a name="ln287">		irqUsage[chosenDescriptor.irq] += link-&gt;used_by.Count();</a>
<a name="ln288"> </a>
<a name="ln289">		for (int j = 0; j &lt; link-&gt;used_by.Count(); j++) {</a>
<a name="ln290">			irq_routing_entry* irqEntry = link-&gt;used_by.ElementAt(j);</a>
<a name="ln291">			irqEntry-&gt;needs_configuration = j == 0; // only configure once</a>
<a name="ln292">			irqEntry-&gt;irq = chosenDescriptor.irq;</a>
<a name="ln293">			irqEntry-&gt;polarity = chosenDescriptor.polarity;</a>
<a name="ln294">			irqEntry-&gt;trigger_mode = chosenDescriptor.trigger_mode;</a>
<a name="ln295">		}</a>
<a name="ln296"> </a>
<a name="ln297">		delete link;</a>
<a name="ln298">	}</a>
<a name="ln299"> </a>
<a name="ln300">	return B_OK;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">static status_t</a>
<a name="ln305">configure_link_devices(acpi_module_info* acpi, IRQRoutingTable&amp; routingTable)</a>
<a name="ln306">{</a>
<a name="ln307">	for (int i = 0; i &lt; routingTable.Count(); i++) {</a>
<a name="ln308">		irq_routing_entry&amp; irqEntry = routingTable.ElementAt(i);</a>
<a name="ln309">		if (!irqEntry.needs_configuration)</a>
<a name="ln310">			continue;</a>
<a name="ln311"> </a>
<a name="ln312">		irq_descriptor configuration;</a>
<a name="ln313">		configuration.irq = irqEntry.irq;</a>
<a name="ln314">		configuration.polarity = irqEntry.polarity;</a>
<a name="ln315">		configuration.trigger_mode = irqEntry.trigger_mode;</a>
<a name="ln316"> </a>
<a name="ln317">		status_t status = set_current_irq(acpi, irqEntry.source, configuration);</a>
<a name="ln318">		if (status != B_OK) {</a>
<a name="ln319">			dprintf(&quot;failed to set irq on link device, keeping current\n&quot;);</a>
<a name="ln320">			print_irq_descriptor(configuration);</a>
<a name="ln321"> </a>
<a name="ln322">			// we failed to set the resource, fall back to current</a>
<a name="ln323">			read_current_irq(acpi, irqEntry.source, configuration);</a>
<a name="ln324">			for (int j = i; j &lt; routingTable.Count(); j++) {</a>
<a name="ln325">				irq_routing_entry&amp; other = routingTable.ElementAt(j);</a>
<a name="ln326">				if (other.source == irqEntry.source) {</a>
<a name="ln327">					other.irq = configuration.irq;</a>
<a name="ln328">					other.polarity = configuration.polarity;</a>
<a name="ln329">					other.trigger_mode = configuration.trigger_mode;</a>
<a name="ln330">				}</a>
<a name="ln331">			}</a>
<a name="ln332">		}</a>
<a name="ln333"> </a>
<a name="ln334">		irqEntry.needs_configuration = false;</a>
<a name="ln335">	}</a>
<a name="ln336"> </a>
<a name="ln337">	return B_OK;</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340"> </a>
<a name="ln341">static status_t</a>
<a name="ln342">evaluate_integer(acpi_module_info* acpi, acpi_handle handle,</a>
<a name="ln343">	const char* method, uint64&amp; value)</a>
<a name="ln344">{</a>
<a name="ln345">	acpi_object_type result;</a>
<a name="ln346">	acpi_data resultBuffer;</a>
<a name="ln347">	resultBuffer.pointer = &amp;result;</a>
<a name="ln348">	resultBuffer.length = sizeof(result);</a>
<a name="ln349"> </a>
<a name="ln350">	status_t status = acpi-&gt;evaluate_method(handle, method, NULL,</a>
<a name="ln351">		&amp;resultBuffer);</a>
<a name="ln352">	if (status != B_OK)</a>
<a name="ln353">		return status;</a>
<a name="ln354"> </a>
<a name="ln355">	if (result.object_type != ACPI_TYPE_INTEGER)</a>
<a name="ln356">		return B_BAD_TYPE;</a>
<a name="ln357"> </a>
<a name="ln358">	value = result.integer.integer;</a>
<a name="ln359">	return B_OK;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">static status_t</a>
<a name="ln364">handle_routing_table_entry(acpi_module_info* acpi, pci_module_info* pci,</a>
<a name="ln365">	const acpi_pci_routing_table* acpiTable, uint8 currentBus,</a>
<a name="ln366">	irq_routing_entry&amp; irqEntry)</a>
<a name="ln367">{</a>
<a name="ln368">	bool noSource = acpiTable-&gt;Source[0] == '\0';</a>
<a name="ln369">		// The above line would be correct according to specs...</a>
<a name="ln370">	noSource = acpiTable-&gt;SourceIndex != 0;</a>
<a name="ln371">		// ... but we use this one as there seem to be quirks where</a>
<a name="ln372">		// a source is indicated but not actually present. With a source</a>
<a name="ln373">		// index != 0 a GSI is generally indicated.</a>
<a name="ln374"> </a>
<a name="ln375">	status_t status;</a>
<a name="ln376">	acpi_handle source;</a>
<a name="ln377">	if (!noSource) {</a>
<a name="ln378">		status = acpi-&gt;get_handle(NULL, acpiTable-&gt;Source, &amp;source);</a>
<a name="ln379">		if (status != B_OK) {</a>
<a name="ln380">			dprintf(&quot;failed to get handle to link device\n&quot;);</a>
<a name="ln381">			return status;</a>
<a name="ln382">		}</a>
<a name="ln383">	}</a>
<a name="ln384"> </a>
<a name="ln385">	memset(&amp;irqEntry, 0, sizeof(irq_routing_entry));</a>
<a name="ln386">	irqEntry.device_address = acpiTable-&gt;Address;</a>
<a name="ln387">	irqEntry.pin = acpiTable-&gt;Pin;</a>
<a name="ln388">	irqEntry.source = noSource ? NULL : source;</a>
<a name="ln389">	irqEntry.source_index = acpiTable-&gt;SourceIndex;</a>
<a name="ln390">	irqEntry.pci_bus = currentBus;</a>
<a name="ln391">	irqEntry.pci_device = (uint8)(acpiTable-&gt;Address &gt;&gt; 16);</a>
<a name="ln392"> </a>
<a name="ln393">	status = fill_pci_info_for_entry(pci, irqEntry);</a>
<a name="ln394">	if (status != B_OK) {</a>
<a name="ln395">		// Note: This isn't necesarily fatal, as there can be many entries in</a>
<a name="ln396">		// the table pointing to disabled/optional devices. Also they can be</a>
<a name="ln397">		// used to describe the full actual wireing regardless of the presence</a>
<a name="ln398">		// of devices, in which case many entries won't have a match.</a>
<a name="ln399">#ifdef TRACE_PRT</a>
<a name="ln400">		dprintf(&quot;no matching PCI device for irq entry: &quot;);</a>
<a name="ln401">		print_irq_routing_entry(irqEntry);</a>
<a name="ln402">#endif</a>
<a name="ln403">	} else {</a>
<a name="ln404">#ifdef TRACE_PRT</a>
<a name="ln405">		dprintf(&quot;found matching PCI device for irq entry: &quot;);</a>
<a name="ln406">		print_irq_routing_entry(irqEntry);</a>
<a name="ln407">#endif</a>
<a name="ln408">	}</a>
<a name="ln409"> </a>
<a name="ln410">	if (noSource) {</a>
<a name="ln411">		// fill in the GSI and config</a>
<a name="ln412">		irqEntry.needs_configuration = false;</a>
<a name="ln413">		irqEntry.irq = irqEntry.source_index;</a>
<a name="ln414">		irqEntry.polarity = B_LOW_ACTIVE_POLARITY;</a>
<a name="ln415">		irqEntry.trigger_mode = B_LEVEL_TRIGGERED;</a>
<a name="ln416">	}</a>
<a name="ln417"> </a>
<a name="ln418">	return B_OK;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">irq_routing_entry*</a>
<a name="ln423">find_routing_table_entry(IRQRoutingTable&amp; table, uint8 bus, uint8 device,</a>
<a name="ln424">	uint8 pin)</a>
<a name="ln425">{</a>
<a name="ln426">	for (int i = 0; i &lt; table.Count(); i++) {</a>
<a name="ln427">		irq_routing_entry&amp; irqEntry = table.ElementAt(i);</a>
<a name="ln428">		if (irqEntry.pci_bus != bus || irqEntry.pci_device != device)</a>
<a name="ln429">			continue;</a>
<a name="ln430"> </a>
<a name="ln431">		if (irqEntry.pin + 1 == pin)</a>
<a name="ln432">			return &amp;irqEntry;</a>
<a name="ln433">	}</a>
<a name="ln434"> </a>
<a name="ln435">	return NULL;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438"> </a>
<a name="ln439">static status_t</a>
<a name="ln440">ensure_all_functions_matched(pci_module_info* pci, uint8 bus,</a>
<a name="ln441">	IRQRoutingTable&amp; matchedTable, IRQRoutingTable&amp; unmatchedTable,</a>
<a name="ln442">	Vector&lt;pci_address&gt;&amp; parents)</a>
<a name="ln443">{</a>
<a name="ln444">	for (uint8 device = 0; device &lt; kMaxPCIDeviceCount; device++) {</a>
<a name="ln445">		if (pci-&gt;read_pci_config(bus, device, 0, PCI_vendor_id, 2) == 0xffff) {</a>
<a name="ln446">			TRACE(&quot;PCI bus %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; not present.\n&quot;,</a>
<a name="ln447">				bus, device);</a>
<a name="ln448">			// not present</a>
<a name="ln449">			continue;</a>
<a name="ln450">		}</a>
<a name="ln451"> </a>
<a name="ln452">		uint8 headerType = pci-&gt;read_pci_config(bus, device, 0,</a>
<a name="ln453">			PCI_header_type, 1);</a>
<a name="ln454"> </a>
<a name="ln455">		uint8 functionCount = 1;</a>
<a name="ln456">		if ((headerType &amp; PCI_multifunction) != 0)</a>
<a name="ln457">			functionCount = kMaxPCIFunctionCount;</a>
<a name="ln458"> </a>
<a name="ln459">		for (uint8 function = 0; function &lt; functionCount; function++) {</a>
<a name="ln460">			// check for device presence by looking for a valid vendor</a>
<a name="ln461">			if (pci-&gt;read_pci_config(bus, device, function, PCI_vendor_id, 2)</a>
<a name="ln462">				== 0xffff) {</a>
<a name="ln463">				// not present</a>
<a name="ln464">				TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; &quot;</a>
<a name="ln465">					&quot;not present.\n&quot;, bus, device, function);</a>
<a name="ln466">				continue;</a>
<a name="ln467">			}</a>
<a name="ln468"> </a>
<a name="ln469">			if (function &gt; 0) {</a>
<a name="ln470">				headerType = pci-&gt;read_pci_config(bus, device, function,</a>
<a name="ln471">					PCI_header_type, 1);</a>
<a name="ln472">			}</a>
<a name="ln473"> </a>
<a name="ln474">			// if this is a bridge, recurse down</a>
<a name="ln475">			if ((headerType &amp; PCI_header_type_mask)</a>
<a name="ln476">				== PCI_header_type_PCI_to_PCI_bridge) {</a>
<a name="ln477"> </a>
<a name="ln478">				pci_address pciAddress;</a>
<a name="ln479">				pciAddress.segment = 0;</a>
<a name="ln480">				pciAddress.bus = bus;</a>
<a name="ln481">				pciAddress.device = device;</a>
<a name="ln482">				pciAddress.function = function;</a>
<a name="ln483"> </a>
<a name="ln484">				parents.PushBack(pciAddress);</a>
<a name="ln485"> </a>
<a name="ln486">				uint8 secondaryBus = pci-&gt;read_pci_config(bus, device, function,</a>
<a name="ln487">					PCI_secondary_bus, 1);</a>
<a name="ln488">				if (secondaryBus != 0xff) {</a>
<a name="ln489">					ensure_all_functions_matched(pci, secondaryBus,</a>
<a name="ln490">						matchedTable, unmatchedTable, parents);</a>
<a name="ln491">				}</a>
<a name="ln492"> </a>
<a name="ln493">				parents.PopBack();</a>
<a name="ln494">			}</a>
<a name="ln495"> </a>
<a name="ln496">			uint8 interruptPin = pci-&gt;read_pci_config(bus, device, function,</a>
<a name="ln497">				PCI_interrupt_pin, 1);</a>
<a name="ln498">			if (interruptPin == 0 || interruptPin &gt; 4) {</a>
<a name="ln499">				TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; &quot;</a>
<a name="ln500">					&quot;not routed.\n&quot;, bus, device, function);</a>
<a name="ln501">				// not routed</a>
<a name="ln502">				continue;</a>
<a name="ln503">			}</a>
<a name="ln504"> </a>
<a name="ln505">			irq_routing_entry* irqEntry = find_routing_table_entry(matchedTable,</a>
<a name="ln506">				bus, device, interruptPin);</a>
<a name="ln507">			if (irqEntry != NULL) {</a>
<a name="ln508">				// we already have a matching entry for that device/pin, make</a>
<a name="ln509">				// sure the function mask includes us</a>
<a name="ln510">				TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; &quot;</a>
<a name="ln511">					&quot;already matched. Will mask.\n&quot;, bus, device, function);</a>
<a name="ln512">				irqEntry-&gt;pci_function_mask |= 1 &lt;&lt; function;</a>
<a name="ln513">				continue;</a>
<a name="ln514">			}</a>
<a name="ln515"> </a>
<a name="ln516">			TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; has %&quot; B_PRIu8 &quot; &quot;</a>
<a name="ln517">				&quot;parents, searching them...\n&quot;, bus, device, function,</a>
<a name="ln518">				parents.Count());</a>
<a name="ln519"> </a>
<a name="ln520">			// This function has no matching routing table entry yet. Try to</a>
<a name="ln521">			// figure one out in the parent, based on the device number and</a>
<a name="ln522">			// interrupt pin.</a>
<a name="ln523">			bool matched = false;</a>
<a name="ln524">			uint8 parentPin = ((device + interruptPin - 1) % 4) + 1;</a>
<a name="ln525">			for (int i = parents.Count() - 1; i &gt;= 0; i--) {</a>
<a name="ln526">				pci_address&amp; parent = parents.ElementAt(i);</a>
<a name="ln527">				irqEntry = find_routing_table_entry(matchedTable, parent.bus,</a>
<a name="ln528">					parent.device, parentPin);</a>
<a name="ln529">				if (irqEntry == NULL) {</a>
<a name="ln530">					// try the unmatched table as well</a>
<a name="ln531">					TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; &quot;</a>
<a name="ln532">						&quot;no matchedTable entry.\n&quot;, bus, device, function);</a>
<a name="ln533">					irqEntry = find_routing_table_entry(unmatchedTable,</a>
<a name="ln534">						parent.bus, parent.device, parentPin);</a>
<a name="ln535">				}</a>
<a name="ln536"> </a>
<a name="ln537">				if (irqEntry == NULL) {</a>
<a name="ln538">					// no match in that parent, go further up</a>
<a name="ln539">					parentPin = ((parent.device + parentPin - 1) % 4) + 1;</a>
<a name="ln540"> </a>
<a name="ln541">					TRACE(&quot;PCI %&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot; &quot;</a>
<a name="ln542">						&quot;no unmatchedTable entry, looking at parent pin %&quot;</a>
<a name="ln543">						B_PRIu8 &quot;...\n&quot;, bus, device, function, parentPin);</a>
<a name="ln544">					continue;</a>
<a name="ln545">				}</a>
<a name="ln546"> </a>
<a name="ln547">				// found a match, make a copy and add it to the table</a>
<a name="ln548">				irq_routing_entry newEntry = *irqEntry;</a>
<a name="ln549">				newEntry.device_address = (device &lt;&lt; 16) | 0xffff;</a>
<a name="ln550">				newEntry.pin = interruptPin - 1;</a>
<a name="ln551">				newEntry.pci_bus = bus;</a>
<a name="ln552">				newEntry.pci_device = device;</a>
<a name="ln553">				newEntry.pci_function_mask = 1 &lt;&lt; function;</a>
<a name="ln554"> </a>
<a name="ln555">				uint8 biosIRQ = pci-&gt;read_pci_config(bus, device, function,</a>
<a name="ln556">					PCI_interrupt_line, 1);</a>
<a name="ln557">				if (biosIRQ != 0 &amp;&amp; biosIRQ != 255) {</a>
<a name="ln558">					if (newEntry.bios_irq != 0 &amp;&amp; newEntry.bios_irq != 255</a>
<a name="ln559">						&amp;&amp; newEntry.bios_irq != biosIRQ) {</a>
<a name="ln560">						// If the function was actually routed to that pin,</a>
<a name="ln561">						// the two bios irqs should match. If they don't</a>
<a name="ln562">						// that means we're not correct in our routing</a>
<a name="ln563">						// assumption.</a>
<a name="ln564">						panic(&quot;calculated irq routing doesn't match bios for &quot;</a>
<a name="ln565">							&quot;PCI %u:%u:%u&quot;, bus, device, function);</a>
<a name="ln566">						return B_ERROR;</a>
<a name="ln567">					}</a>
<a name="ln568"> </a>
<a name="ln569">					newEntry.bios_irq = biosIRQ;</a>
<a name="ln570">				}</a>
<a name="ln571"> </a>
<a name="ln572">				dprintf(&quot;calculated irq routing entry: &quot;);</a>
<a name="ln573">				print_irq_routing_entry(newEntry);</a>
<a name="ln574"> </a>
<a name="ln575">				matchedTable.PushBack(newEntry);</a>
<a name="ln576">				matched = true;</a>
<a name="ln577">				break;</a>
<a name="ln578">			}</a>
<a name="ln579"> </a>
<a name="ln580">			if (!matched) {</a>
<a name="ln581">				uint32 interrupt_line = pci-&gt;read_pci_config(bus, device,</a>
<a name="ln582">					function, PCI_interrupt_line, 1);</a>
<a name="ln583">				// On x86, interrupt line 255 means &quot;unknown&quot; or &quot;no connection&quot;</a>
<a name="ln584">				// (PCI Local Bus spec 3.0, section 6.2.4 / page 223, footnote.)</a>
<a name="ln585">				if (interrupt_line == 0 || interrupt_line == 255) {</a>
<a name="ln586">					dprintf(&quot;assuming no interrupt use on PCI device&quot;</a>
<a name="ln587">						&quot; %u:%u:%u (bios irq 0, interrupt line %&quot; B_PRId32 &quot;)\n&quot;,</a>
<a name="ln588">						bus, device, function, interrupt_line);</a>
<a name="ln589">					continue;</a>
<a name="ln590">				}</a>
<a name="ln591"> </a>
<a name="ln592">				dprintf(&quot;WARNING: unable to find irq routing for PCI &quot;</a>
<a name="ln593">					&quot;%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;:%&quot; B_PRIu8 &quot;. Device may be &quot;</a>
<a name="ln594">					&quot;unstable / broken.\n&quot;, bus, device, function);</a>
<a name="ln595">				return B_ERROR;</a>
<a name="ln596">			}</a>
<a name="ln597">		}</a>
<a name="ln598">	}</a>
<a name="ln599"> </a>
<a name="ln600">	return B_OK;</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603"> </a>
<a name="ln604">static status_t</a>
<a name="ln605">read_irq_routing_table_recursive(acpi_module_info* acpi, pci_module_info* pci,</a>
<a name="ln606">	acpi_handle device, uint8 currentBus, IRQRoutingTable&amp; table,</a>
<a name="ln607">	IRQRoutingTable&amp; unmatchedTable, bool rootBridge,</a>
<a name="ln608">	interrupt_available_check_function checkFunction)</a>
<a name="ln609">{</a>
<a name="ln610">	if (!rootBridge) {</a>
<a name="ln611">		// check if this actually is a bridge</a>
<a name="ln612">		uint64 value;</a>
<a name="ln613">		pci_address pciAddress;</a>
<a name="ln614">		pciAddress.bus = currentBus;</a>
<a name="ln615">		if (evaluate_integer(acpi, device, &quot;_ADR&quot;, value) == B_OK) {</a>
<a name="ln616">			pciAddress.device = (uint8)(value &gt;&gt; 16);</a>
<a name="ln617">			pciAddress.function = (uint8)value;</a>
<a name="ln618">		} else {</a>
<a name="ln619">			pciAddress.device = 0;</a>
<a name="ln620">			pciAddress.function = 0;</a>
<a name="ln621">		}</a>
<a name="ln622"> </a>
<a name="ln623">		if (pciAddress.device &gt;= kMaxPCIDeviceCount</a>
<a name="ln624">			|| pciAddress.function &gt;= kMaxPCIFunctionCount) {</a>
<a name="ln625">			// we don't seem to be on the PCI bus anymore</a>
<a name="ln626">			// (just a different type of device)</a>
<a name="ln627">			return B_OK;</a>
<a name="ln628">		}</a>
<a name="ln629"> </a>
<a name="ln630">		// Verify that the device is really present...</a>
<a name="ln631">		uint16 deviceID = pci-&gt;read_pci_config(pciAddress.bus,</a>
<a name="ln632">			pciAddress.device, pciAddress.function, PCI_device_id, 2);</a>
<a name="ln633">		if (deviceID == 0xffff) {</a>
<a name="ln634">			// Not present or disabled.</a>
<a name="ln635">			TRACE(&quot;device not present\n&quot;);</a>
<a name="ln636">			return B_OK;</a>
<a name="ln637">		}</a>
<a name="ln638"> </a>
<a name="ln639">		// ... and that it really is a PCI bridge we support.</a>
<a name="ln640">		uint8 baseClass = pci-&gt;read_pci_config(pciAddress.bus,</a>
<a name="ln641">			pciAddress.device, pciAddress.function, PCI_class_base, 1);</a>
<a name="ln642">		uint8 subClass = pci-&gt;read_pci_config(pciAddress.bus,</a>
<a name="ln643">			pciAddress.device, pciAddress.function, PCI_class_sub, 1);</a>
<a name="ln644">		if (baseClass != PCI_bridge || subClass != PCI_pci) {</a>
<a name="ln645">			// Not a bridge or an unsupported one.</a>
<a name="ln646">			TRACE(&quot;not a PCI bridge\n&quot;);</a>
<a name="ln647">			return B_OK;</a>
<a name="ln648">		}</a>
<a name="ln649"> </a>
<a name="ln650">		uint8 headerType = pci-&gt;read_pci_config(pciAddress.bus,</a>
<a name="ln651">			pciAddress.device, pciAddress.function, PCI_header_type, 1);</a>
<a name="ln652"> </a>
<a name="ln653">		switch (headerType &amp; PCI_header_type_mask) {</a>
<a name="ln654">			case PCI_header_type_PCI_to_PCI_bridge:</a>
<a name="ln655">			case PCI_header_type_cardbus:</a>
<a name="ln656">				TRACE(&quot;found a PCI bridge (0x%02x)\n&quot;, headerType);</a>
<a name="ln657">				break;</a>
<a name="ln658"> </a>
<a name="ln659">			default:</a>
<a name="ln660">				// Unsupported header type.</a>
<a name="ln661">				TRACE(&quot;unsupported header type (0x%02x)\n&quot;, headerType);</a>
<a name="ln662">				return B_OK;</a>
<a name="ln663">		}</a>
<a name="ln664"> </a>
<a name="ln665">		// Find the secondary bus number (the &quot;downstream&quot; bus number for the</a>
<a name="ln666">		// attached devices) in the bridge configuration.</a>
<a name="ln667">		uint8 secondaryBus = pci-&gt;read_pci_config(pciAddress.bus,</a>
<a name="ln668">			pciAddress.device, pciAddress.function, PCI_secondary_bus, 1);</a>
<a name="ln669">		if (secondaryBus == 255) {</a>
<a name="ln670">			// The bus below this bridge is inactive, nothing to do.</a>
<a name="ln671">			TRACE(&quot;secondary bus is inactive\n&quot;);</a>
<a name="ln672">			return B_OK;</a>
<a name="ln673">		}</a>
<a name="ln674"> </a>
<a name="ln675">		// The secondary bus cannot be the same as the current one.</a>
<a name="ln676">		if (secondaryBus == currentBus) {</a>
<a name="ln677">			dprintf(&quot;invalid secondary bus %u on primary bus %u,&quot;</a>
<a name="ln678">				&quot; can't configure irq routing of devices below\n&quot;,</a>
<a name="ln679">				secondaryBus, currentBus);</a>
<a name="ln680">			// TODO: Maybe we want to just return B_OK anyway so that we don't</a>
<a name="ln681">			// fail this step. We ensure that we matched all devices at the</a>
<a name="ln682">			// end of preparation, so we'd detect missing child devices anyway</a>
<a name="ln683">			// and it would not cause us to fail for empty misconfigured busses</a>
<a name="ln684">			// that we don't actually care about.</a>
<a name="ln685">			return B_ERROR;</a>
<a name="ln686">		}</a>
<a name="ln687"> </a>
<a name="ln688">		// Everything below is now on the secondary bus.</a>
<a name="ln689">		TRACE(&quot;now scanning bus %u\n&quot;, secondaryBus);</a>
<a name="ln690">		currentBus = secondaryBus;</a>
<a name="ln691">	}</a>
<a name="ln692"> </a>
<a name="ln693">	acpi_data buffer;</a>
<a name="ln694">	buffer.pointer = NULL;</a>
<a name="ln695">	buffer.length = ACPI_ALLOCATE_BUFFER;</a>
<a name="ln696">	status_t status = acpi-&gt;get_irq_routing_table(device, &amp;buffer);</a>
<a name="ln697">	if (status == B_OK) {</a>
<a name="ln698">		TRACE(&quot;found irq routing table\n&quot;);</a>
<a name="ln699"> </a>
<a name="ln700">		acpi_pci_routing_table* acpiTable</a>
<a name="ln701">			= (acpi_pci_routing_table*)buffer.pointer;</a>
<a name="ln702">		while (acpiTable-&gt;Length) {</a>
<a name="ln703">			irq_routing_entry irqEntry;</a>
<a name="ln704">			status = handle_routing_table_entry(acpi, pci, acpiTable,</a>
<a name="ln705">				currentBus, irqEntry);</a>
<a name="ln706">			if (status == B_OK) {</a>
<a name="ln707">				if (irqEntry.source == NULL &amp;&amp; !checkFunction(irqEntry.irq)) {</a>
<a name="ln708">					dprintf(&quot;hardwired irq %u not addressable\n&quot;, irqEntry.irq);</a>
<a name="ln709">					free(buffer.pointer);</a>
<a name="ln710">					return B_ERROR;</a>
<a name="ln711">				}</a>
<a name="ln712"> </a>
<a name="ln713">				if (irqEntry.pci_function_mask != 0)</a>
<a name="ln714">					table.PushBack(irqEntry);</a>
<a name="ln715">				else</a>
<a name="ln716">					unmatchedTable.PushBack(irqEntry);</a>
<a name="ln717">			}</a>
<a name="ln718"> </a>
<a name="ln719">			acpiTable = (acpi_pci_routing_table*)((uint8*)acpiTable</a>
<a name="ln720">				+ acpiTable-&gt;Length);</a>
<a name="ln721">		}</a>
<a name="ln722"> </a>
<a name="ln723">		free(buffer.pointer);</a>
<a name="ln724">	} else {</a>
<a name="ln725">		TRACE(&quot;no irq routing table present\n&quot;);</a>
<a name="ln726">	}</a>
<a name="ln727"> </a>
<a name="ln728">	// recurse down the ACPI child devices</a>
<a name="ln729">	acpi_data pathBuffer;</a>
<a name="ln730">	pathBuffer.pointer = NULL;</a>
<a name="ln731">	pathBuffer.length = ACPI_ALLOCATE_BUFFER;</a>
<a name="ln732">	status = acpi-&gt;ns_handle_to_pathname(device, &amp;pathBuffer);</a>
<a name="ln733">	if (status != B_OK) {</a>
<a name="ln734">		dprintf(&quot;failed to resolve handle to path\n&quot;);</a>
<a name="ln735">		return status;</a>
<a name="ln736">	}</a>
<a name="ln737"> </a>
<a name="ln738">	char childName[255];</a>
<a name="ln739">	void* counter = NULL;</a>
<a name="ln740">	while (acpi-&gt;get_next_entry(ACPI_TYPE_DEVICE, (char*)pathBuffer.pointer,</a>
<a name="ln741">		childName, sizeof(childName), &amp;counter) == B_OK) {</a>
<a name="ln742"> </a>
<a name="ln743">		acpi_handle childHandle;</a>
<a name="ln744">		status = acpi-&gt;get_handle(NULL, childName, &amp;childHandle);</a>
<a name="ln745">		if (status != B_OK) {</a>
<a name="ln746">			dprintf(&quot;failed to get handle to child \&quot;%s\&quot;\n&quot;, childName);</a>
<a name="ln747">			break;</a>
<a name="ln748">		}</a>
<a name="ln749"> </a>
<a name="ln750">		TRACE(&quot;recursing down to child \&quot;%s\&quot;\n&quot;, childName);</a>
<a name="ln751">		status = read_irq_routing_table_recursive(acpi, pci, childHandle,</a>
<a name="ln752">			currentBus, table, unmatchedTable, false, checkFunction);</a>
<a name="ln753">		if (status != B_OK)</a>
<a name="ln754">			break;</a>
<a name="ln755">	}</a>
<a name="ln756"> </a>
<a name="ln757">	free(pathBuffer.pointer);</a>
<a name="ln758">	return status;</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761"> </a>
<a name="ln762">static status_t</a>
<a name="ln763">read_irq_routing_table(acpi_module_info* acpi, IRQRoutingTable&amp; table,</a>
<a name="ln764">	interrupt_available_check_function checkFunction)</a>
<a name="ln765">{</a>
<a name="ln766">	char rootPciName[255];</a>
<a name="ln767">	acpi_handle rootPciHandle;</a>
<a name="ln768">	rootPciName[0] = 0;</a>
<a name="ln769">	status_t status = acpi-&gt;get_device(kACPIPciRootName, 0, rootPciName, 255);</a>
<a name="ln770">	if (status != B_OK)</a>
<a name="ln771">		return status;</a>
<a name="ln772"> </a>
<a name="ln773">	status = acpi-&gt;get_handle(NULL, rootPciName, &amp;rootPciHandle);</a>
<a name="ln774">	if (status != B_OK)</a>
<a name="ln775">		return status;</a>
<a name="ln776"> </a>
<a name="ln777">	// We reset the root bus to 0 here. Any failed evaluation means default</a>
<a name="ln778">	// values, so we don't have to do anything in the error case.</a>
<a name="ln779">	uint8 rootBus = 0;</a>
<a name="ln780"> </a>
<a name="ln781">	uint64 value;</a>
<a name="ln782">	if (evaluate_integer(acpi, rootPciHandle, &quot;_BBN&quot;, value) == B_OK)</a>
<a name="ln783">		rootBus = (uint8)value;</a>
<a name="ln784"> </a>
<a name="ln785">#if 0</a>
<a name="ln786">	// TODO: handle</a>
<a name="ln787">	if (evaluate_integer(acpi, rootPciHandle, &quot;_SEG&quot;, value) == B_OK)</a>
<a name="ln788">		rootPciAddress.segment = (uint8)value;</a>
<a name="ln789">#endif</a>
<a name="ln790"> </a>
<a name="ln791">	pci_module_info* pci;</a>
<a name="ln792">	status = get_module(B_PCI_MODULE_NAME, (module_info**)&amp;pci);</a>
<a name="ln793">	if (status != B_OK) {</a>
<a name="ln794">		// shouldn't happen, since the PCI module is a dependency of the</a>
<a name="ln795">		// ACPI module and we shouldn't be here at all if it wasn't loaded</a>
<a name="ln796">		dprintf(&quot;failed to get PCI module!\n&quot;);</a>
<a name="ln797">		return status;</a>
<a name="ln798">	}</a>
<a name="ln799"> </a>
<a name="ln800">	IRQRoutingTable unmatchedTable;</a>
<a name="ln801">	status = read_irq_routing_table_recursive(acpi, pci, rootPciHandle, rootBus,</a>
<a name="ln802">		table, unmatchedTable, true, checkFunction);</a>
<a name="ln803">	if (status != B_OK) {</a>
<a name="ln804">		put_module(B_PCI_MODULE_NAME);</a>
<a name="ln805">		return status;</a>
<a name="ln806">	}</a>
<a name="ln807"> </a>
<a name="ln808">	if (table.Count() == 0) {</a>
<a name="ln809">		put_module(B_PCI_MODULE_NAME);</a>
<a name="ln810">		return B_ERROR;</a>
<a name="ln811">	}</a>
<a name="ln812"> </a>
<a name="ln813">	// Now go through all the PCI devices and verify that they have a routing</a>
<a name="ln814">	// table entry. For the devices without a match, we calculate their pins</a>
<a name="ln815">	// on the bridges and try to match these in the parent routing table. We</a>
<a name="ln816">	// do this recursively going up the tree until we find a match or arrive</a>
<a name="ln817">	// at the top.</a>
<a name="ln818">	Vector&lt;pci_address&gt; parents;</a>
<a name="ln819">	status = ensure_all_functions_matched(pci, rootBus, table, unmatchedTable,</a>
<a name="ln820">		parents);</a>
<a name="ln821"> </a>
<a name="ln822">	put_module(B_PCI_MODULE_NAME);</a>
<a name="ln823">	return status;</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826"> </a>
<a name="ln827">status_t</a>
<a name="ln828">prepare_irq_routing(acpi_module_info* acpi, IRQRoutingTable&amp; routingTable,</a>
<a name="ln829">	interrupt_available_check_function checkFunction)</a>
<a name="ln830">{</a>
<a name="ln831">	status_t status = read_irq_routing_table(acpi, routingTable, checkFunction);</a>
<a name="ln832">	if (status != B_OK)</a>
<a name="ln833">		return status;</a>
<a name="ln834"> </a>
<a name="ln835">	// resolve desired configuration of link devices</a>
<a name="ln836">	return choose_link_device_configurations(acpi, routingTable, checkFunction);</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839"> </a>
<a name="ln840">status_t</a>
<a name="ln841">enable_irq_routing(acpi_module_info* acpi, IRQRoutingTable&amp; routingTable)</a>
<a name="ln842">{</a>
<a name="ln843">	// configure the link devices; also resolves GSIs for link based entries</a>
<a name="ln844">	status_t status = configure_link_devices(acpi, routingTable);</a>
<a name="ln845">	if (status != B_OK) {</a>
<a name="ln846">		panic(&quot;failed to configure link devices&quot;);</a>
<a name="ln847">		return status;</a>
<a name="ln848">	}</a>
<a name="ln849"> </a>
<a name="ln850">	pci_module_info* pci;</a>
<a name="ln851">	status = get_module(B_PCI_MODULE_NAME, (module_info**)&amp;pci);</a>
<a name="ln852">	if (status != B_OK) {</a>
<a name="ln853">		// shouldn't happen, since the PCI module is a dependency of the</a>
<a name="ln854">		// ACPI module and we shouldn't be here at all if it wasn't loaded</a>
<a name="ln855">		dprintf(&quot;failed to get PCI module!\n&quot;);</a>
<a name="ln856">		return status;</a>
<a name="ln857">	}</a>
<a name="ln858"> </a>
<a name="ln859">	// update the PCI info now that all GSIs are known</a>
<a name="ln860">	for (int i = 0; i &lt; routingTable.Count(); i++) {</a>
<a name="ln861">		irq_routing_entry&amp; irqEntry = routingTable.ElementAt(i);</a>
<a name="ln862"> </a>
<a name="ln863">		status = update_pci_info_for_entry(pci, irqEntry);</a>
<a name="ln864">		if (status != B_OK) {</a>
<a name="ln865">			dprintf(&quot;failed to update interrupt_line for PCI %u:%u mask %&quot;</a>
<a name="ln866">				B_PRIx32 &quot;\n&quot;, irqEntry.pci_bus, irqEntry.pci_device,</a>
<a name="ln867">				irqEntry.pci_function_mask);</a>
<a name="ln868">		}</a>
<a name="ln869">	}</a>
<a name="ln870"> </a>
<a name="ln871">	put_module(B_PCI_MODULE_NAME);</a>
<a name="ln872">	return B_OK;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">static status_t</a>
<a name="ln877">read_irq_descriptor(acpi_module_info* acpi, acpi_handle device,</a>
<a name="ln878">	bool readCurrent, irq_descriptor* _descriptor,</a>
<a name="ln879">	irq_descriptor_list* descriptorList)</a>
<a name="ln880">{</a>
<a name="ln881">	acpi_data buffer;</a>
<a name="ln882">	buffer.pointer = NULL;</a>
<a name="ln883">	buffer.length = ACPI_ALLOCATE_BUFFER;</a>
<a name="ln884"> </a>
<a name="ln885">	status_t status;</a>
<a name="ln886">	if (readCurrent)</a>
<a name="ln887">		status = acpi-&gt;get_current_resources(device, &amp;buffer);</a>
<a name="ln888">	else</a>
<a name="ln889">		status = acpi-&gt;get_possible_resources(device, &amp;buffer);</a>
<a name="ln890"> </a>
<a name="ln891">	if (status != B_OK) {</a>
<a name="ln892">		dprintf(&quot;failed to read %s resources for irq\n&quot;,</a>
<a name="ln893">			readCurrent ? &quot;current&quot; : &quot;possible&quot;);</a>
<a name="ln894">		free(buffer.pointer);</a>
<a name="ln895">		return status;</a>
<a name="ln896">	}</a>
<a name="ln897"> </a>
<a name="ln898">	irq_descriptor descriptor;</a>
<a name="ln899">	descriptor.irq = 255;</a>
<a name="ln900"> </a>
<a name="ln901">	acpi_resource* resource = (acpi_resource*)buffer.pointer;</a>
<a name="ln902">	while (resource-&gt;Type != ACPI_RESOURCE_TYPE_END_TAG) {</a>
<a name="ln903">		switch (resource-&gt;Type) {</a>
<a name="ln904">			case ACPI_RESOURCE_TYPE_IRQ:</a>
<a name="ln905">			{</a>
<a name="ln906">				acpi_resource_irq&amp; irq = resource-&gt;Data.Irq;</a>
<a name="ln907">				if (irq.InterruptCount &lt; 1) {</a>
<a name="ln908">					dprintf(&quot;acpi irq resource with no interrupts\n&quot;);</a>
<a name="ln909">					break;</a>
<a name="ln910">				}</a>
<a name="ln911"> </a>
<a name="ln912">				descriptor.shareable = irq.Sharable != 0;</a>
<a name="ln913">				descriptor.trigger_mode = irq.Triggering == 0</a>
<a name="ln914">					? B_LEVEL_TRIGGERED : B_EDGE_TRIGGERED;</a>
<a name="ln915">				descriptor.polarity = irq.Polarity == 0</a>
<a name="ln916">					? B_HIGH_ACTIVE_POLARITY : B_LOW_ACTIVE_POLARITY;</a>
<a name="ln917"> </a>
<a name="ln918">				if (readCurrent)</a>
<a name="ln919">					descriptor.irq = irq.Interrupts[0];</a>
<a name="ln920">				else {</a>
<a name="ln921">					for (uint16 i = 0; i &lt; irq.InterruptCount; i++) {</a>
<a name="ln922">						descriptor.irq = irq.Interrupts[i];</a>
<a name="ln923">						descriptorList-&gt;PushBack(descriptor);</a>
<a name="ln924">					}</a>
<a name="ln925">				}</a>
<a name="ln926"> </a>
<a name="ln927">#ifdef TRACE_PRT</a>
<a name="ln928">				dprintf(&quot;acpi irq resource (%s):\n&quot;,</a>
<a name="ln929">					readCurrent ? &quot;current&quot; : &quot;possible&quot;);</a>
<a name="ln930">				dprintf(&quot;\ttriggering: %s\n&quot;,</a>
<a name="ln931">					irq.Triggering == 0 ? &quot;level&quot; : &quot;edge&quot;);</a>
<a name="ln932">				dprintf(&quot;\tpolarity: %s active\n&quot;,</a>
<a name="ln933">					irq.Polarity == 0 ? &quot;high&quot; : &quot;low&quot;);</a>
<a name="ln934">				dprintf(&quot;\tsharable: %s\n&quot;, irq.Sharable != 0 ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln935">				dprintf(&quot;\tcount: %u\n&quot;, irq.InterruptCount);</a>
<a name="ln936">				if (irq.InterruptCount &gt; 0) {</a>
<a name="ln937">					dprintf(&quot;\tinterrupts:&quot;);</a>
<a name="ln938">					for (uint16 i = 0; i &lt; irq.InterruptCount; i++)</a>
<a name="ln939">						dprintf(&quot; %u&quot;, irq.Interrupts[i]);</a>
<a name="ln940">					dprintf(&quot;\n&quot;);</a>
<a name="ln941">				}</a>
<a name="ln942">#endif</a>
<a name="ln943">				break;</a>
<a name="ln944">			}</a>
<a name="ln945"> </a>
<a name="ln946">			case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:</a>
<a name="ln947">			{</a>
<a name="ln948">				acpi_resource_extended_irq&amp; irq = resource-&gt;Data.ExtendedIrq;</a>
<a name="ln949">				if (irq.InterruptCount &lt; 1) {</a>
<a name="ln950">					dprintf(&quot;acpi extended irq resource with no interrupts\n&quot;);</a>
<a name="ln951">					break;</a>
<a name="ln952">				}</a>
<a name="ln953"> </a>
<a name="ln954">				descriptor.shareable = irq.Sharable != 0;</a>
<a name="ln955">				descriptor.trigger_mode = irq.Triggering == 0</a>
<a name="ln956">					? B_LEVEL_TRIGGERED : B_EDGE_TRIGGERED;</a>
<a name="ln957">				descriptor.polarity = irq.Polarity == 0</a>
<a name="ln958">					? B_HIGH_ACTIVE_POLARITY : B_LOW_ACTIVE_POLARITY;</a>
<a name="ln959"> </a>
<a name="ln960">				if (readCurrent)</a>
<a name="ln961">					descriptor.irq = irq.Interrupts[0];</a>
<a name="ln962">				else {</a>
<a name="ln963">					for (uint16 i = 0; i &lt; irq.InterruptCount; i++) {</a>
<a name="ln964">						descriptor.irq = irq.Interrupts[i];</a>
<a name="ln965">						descriptorList-&gt;PushBack(descriptor);</a>
<a name="ln966">					}</a>
<a name="ln967">				}</a>
<a name="ln968"> </a>
<a name="ln969">#ifdef TRACE_PRT</a>
<a name="ln970">				dprintf(&quot;acpi extended irq resource (%s):\n&quot;,</a>
<a name="ln971">					readCurrent ? &quot;current&quot; : &quot;possible&quot;);</a>
<a name="ln972">				dprintf(&quot;\tproducer: %s\n&quot;,</a>
<a name="ln973">					irq.ProducerConsumer ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln974">				dprintf(&quot;\ttriggering: %s\n&quot;,</a>
<a name="ln975">					irq.Triggering == 0 ? &quot;level&quot; : &quot;edge&quot;);</a>
<a name="ln976">				dprintf(&quot;\tpolarity: %s active\n&quot;,</a>
<a name="ln977">					irq.Polarity == 0 ? &quot;high&quot; : &quot;low&quot;);</a>
<a name="ln978">				dprintf(&quot;\tsharable: %s\n&quot;, irq.Sharable != 0 ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln979">				dprintf(&quot;\tcount: %u\n&quot;, irq.InterruptCount);</a>
<a name="ln980">				if (irq.InterruptCount &gt; 0) {</a>
<a name="ln981">					dprintf(&quot;\tinterrupts:&quot;);</a>
<a name="ln982">					for (uint16 i = 0; i &lt; irq.InterruptCount; i++)</a>
<a name="ln983">						dprintf(&quot; %u&quot;, irq.Interrupts[i]);</a>
<a name="ln984">					dprintf(&quot;\n&quot;);</a>
<a name="ln985">				}</a>
<a name="ln986">#endif</a>
<a name="ln987">				break;</a>
<a name="ln988">			}</a>
<a name="ln989">		}</a>
<a name="ln990"> </a>
<a name="ln991">		if (descriptor.irq != 255)</a>
<a name="ln992">			break;</a>
<a name="ln993"> </a>
<a name="ln994">		resource = (acpi_resource*)((uint8*)resource + resource-&gt;Length);</a>
<a name="ln995">	}</a>
<a name="ln996"> </a>
<a name="ln997">	free(buffer.pointer);</a>
<a name="ln998"> </a>
<a name="ln999">	if (descriptor.irq == 255)</a>
<a name="ln1000">		return B_ERROR;</a>
<a name="ln1001"> </a>
<a name="ln1002">	if (readCurrent)</a>
<a name="ln1003">		*_descriptor = descriptor;</a>
<a name="ln1004"> </a>
<a name="ln1005">	return B_OK;</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008"> </a>
<a name="ln1009">status_t</a>
<a name="ln1010">read_current_irq(acpi_module_info* acpi, acpi_handle device,</a>
<a name="ln1011">	irq_descriptor&amp; descriptor)</a>
<a name="ln1012">{</a>
<a name="ln1013">	return read_irq_descriptor(acpi, device, true, &amp;descriptor, NULL);</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016"> </a>
<a name="ln1017">status_t</a>
<a name="ln1018">read_possible_irqs(acpi_module_info* acpi, acpi_handle device,</a>
<a name="ln1019">	irq_descriptor_list&amp; descriptorList)</a>
<a name="ln1020">{</a>
<a name="ln1021">	return read_irq_descriptor(acpi, device, false, NULL, &amp;descriptorList);</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024"> </a>
<a name="ln1025">status_t</a>
<a name="ln1026">set_current_irq(acpi_module_info* acpi, acpi_handle device,</a>
<a name="ln1027">	const irq_descriptor&amp; descriptor)</a>
<a name="ln1028">{</a>
<a name="ln1029">	acpi_data buffer;</a>
<a name="ln1030">	buffer.pointer = NULL;</a>
<a name="ln1031">	buffer.length = ACPI_ALLOCATE_BUFFER;</a>
<a name="ln1032"> </a>
<a name="ln1033">	status_t status = acpi-&gt;get_current_resources(device, &amp;buffer);</a>
<a name="ln1034">	if (status != B_OK) {</a>
<a name="ln1035">		dprintf(&quot;failed to read current resources for irq\n&quot;);</a>
<a name="ln1036">		return status;</a>
<a name="ln1037">	}</a>
<a name="ln1038"> </a>
<a name="ln1039">	bool irqWritten = false;</a>
<a name="ln1040">	acpi_resource* resource = (acpi_resource*)buffer.pointer;</a>
<a name="ln1041">	while (resource-&gt;Type != ACPI_RESOURCE_TYPE_END_TAG) {</a>
<a name="ln1042">		switch (resource-&gt;Type) {</a>
<a name="ln1043">			case ACPI_RESOURCE_TYPE_IRQ:</a>
<a name="ln1044">			{</a>
<a name="ln1045">				acpi_resource_irq&amp; irq = resource-&gt;Data.Irq;</a>
<a name="ln1046">				if (irq.InterruptCount &lt; 1) {</a>
<a name="ln1047">					dprintf(&quot;acpi irq resource with no interrupts\n&quot;);</a>
<a name="ln1048">					break;</a>
<a name="ln1049">				}</a>
<a name="ln1050"> </a>
<a name="ln1051">				irq.Triggering</a>
<a name="ln1052">					= descriptor.trigger_mode == B_LEVEL_TRIGGERED ? 0 : 1;</a>
<a name="ln1053">				irq.Polarity</a>
<a name="ln1054">					= descriptor.polarity == B_HIGH_ACTIVE_POLARITY ? 0 : 1;</a>
<a name="ln1055">				irq.Sharable = descriptor.shareable ? 0 : 1;</a>
<a name="ln1056">				irq.InterruptCount = 1;</a>
<a name="ln1057">				irq.Interrupts[0] = descriptor.irq;</a>
<a name="ln1058"> </a>
<a name="ln1059">				irqWritten = true;</a>
<a name="ln1060">				break;</a>
<a name="ln1061">			}</a>
<a name="ln1062"> </a>
<a name="ln1063">			case ACPI_RESOURCE_TYPE_EXTENDED_IRQ:</a>
<a name="ln1064">			{</a>
<a name="ln1065">				acpi_resource_extended_irq&amp; irq = resource-&gt;Data.ExtendedIrq;</a>
<a name="ln1066">				if (irq.InterruptCount &lt; 1) {</a>
<a name="ln1067">					dprintf(&quot;acpi extended irq resource with no interrupts\n&quot;);</a>
<a name="ln1068">					break;</a>
<a name="ln1069">				}</a>
<a name="ln1070"> </a>
<a name="ln1071">				irq.Triggering</a>
<a name="ln1072">					= descriptor.trigger_mode == B_LEVEL_TRIGGERED ? 0 : 1;</a>
<a name="ln1073">				irq.Polarity</a>
<a name="ln1074">					= descriptor.polarity == B_HIGH_ACTIVE_POLARITY ? 0 : 1;</a>
<a name="ln1075">				irq.Sharable = descriptor.shareable ? 0 : 1;</a>
<a name="ln1076">				irq.InterruptCount = 1;</a>
<a name="ln1077">				irq.Interrupts[0] = descriptor.irq;</a>
<a name="ln1078"> </a>
<a name="ln1079">				irqWritten = true;</a>
<a name="ln1080">				break;</a>
<a name="ln1081">			}</a>
<a name="ln1082">		}</a>
<a name="ln1083"> </a>
<a name="ln1084">		if (irqWritten)</a>
<a name="ln1085">			break;</a>
<a name="ln1086"> </a>
<a name="ln1087">		resource = (acpi_resource*)((uint8*)resource + resource-&gt;Length);</a>
<a name="ln1088">	}</a>
<a name="ln1089"> </a>
<a name="ln1090">	if (irqWritten) {</a>
<a name="ln1091">		status = acpi-&gt;set_current_resources(device, &amp;buffer);</a>
<a name="ln1092">		if (status != B_OK)</a>
<a name="ln1093">			dprintf(&quot;failed to set irq resources\n&quot;);</a>
<a name="ln1094">	} else {</a>
<a name="ln1095">		dprintf(&quot;failed to write requested irq into resources\n&quot;);</a>
<a name="ln1096">		status = B_ERROR;</a>
<a name="ln1097">	}</a>
<a name="ln1098"> </a>
<a name="ln1099">	free(buffer.pointer);</a>
<a name="ln1100">	return status;</a>
<a name="ln1101">}</a>

</code></pre>
<div class="balloon" rel="239"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'link' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
