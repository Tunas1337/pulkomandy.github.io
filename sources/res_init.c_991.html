
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>res_init.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: res_init.c,v 1.31 2017/04/19 22:21:07 christos Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*</a>
<a name="ln4"> * Copyright (c) 1985, 1989, 1993</a>
<a name="ln5"> *    The Regents of the University of California.  All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln16"> *    must display the following acknowledgement:</a>
<a name="ln17"> * 	This product includes software developed by the University of</a>
<a name="ln18"> * 	California, Berkeley and its contributors.</a>
<a name="ln19"> * 4. Neither the name of the University nor the names of its contributors</a>
<a name="ln20"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln21"> *    without specific prior written permission.</a>
<a name="ln22"> *</a>
<a name="ln23"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln24"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln25"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln26"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln27"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln28"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln29"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln30"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln31"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln32"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln33"> * SUCH DAMAGE.</a>
<a name="ln34"> */</a>
<a name="ln35"> </a>
<a name="ln36">/*</a>
<a name="ln37"> * Portions Copyright (c) 1993 by Digital Equipment Corporation.</a>
<a name="ln38"> *</a>
<a name="ln39"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln40"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln41"> * copyright notice and this permission notice appear in all copies, and that</a>
<a name="ln42"> * the name of Digital Equipment Corporation not be used in advertising or</a>
<a name="ln43"> * publicity pertaining to distribution of the document or software without</a>
<a name="ln44"> * specific, written prior permission.</a>
<a name="ln45"> *</a>
<a name="ln46"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL</a>
<a name="ln47"> * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES</a>
<a name="ln48"> * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT</a>
<a name="ln49"> * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL</a>
<a name="ln50"> * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR</a>
<a name="ln51"> * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS</a>
<a name="ln52"> * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</a>
<a name="ln53"> * SOFTWARE.</a>
<a name="ln54"> */</a>
<a name="ln55"> </a>
<a name="ln56">/*</a>
<a name="ln57"> * Copyright (c) 2004 by Internet Systems Consortium, Inc. (&quot;ISC&quot;)</a>
<a name="ln58"> * Portions Copyright (c) 1996-1999 by Internet Software Consortium.</a>
<a name="ln59"> *</a>
<a name="ln60"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln61"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln62"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln63"> *</a>
<a name="ln64"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ISC DISCLAIMS ALL WARRANTIES</a>
<a name="ln65"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln66"> * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR</a>
<a name="ln67"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln68"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln69"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</a>
<a name="ln70"> * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln71"> */</a>
<a name="ln72"> </a>
<a name="ln73">#include &quot;port_before.h&quot;</a>
<a name="ln74"> </a>
<a name="ln75">#include &lt;sys/types.h&gt;</a>
<a name="ln76">#include &lt;sys/param.h&gt;</a>
<a name="ln77">#include &lt;sys/socket.h&gt;</a>
<a name="ln78">#include &lt;sys/time.h&gt;</a>
<a name="ln79"> </a>
<a name="ln80">#include &lt;netinet/in.h&gt;</a>
<a name="ln81">#include &lt;arpa/inet.h&gt;</a>
<a name="ln82">#include &lt;arpa/nameser.h&gt;</a>
<a name="ln83"> </a>
<a name="ln84">#include &lt;ctype.h&gt;</a>
<a name="ln85">#include &lt;stdio.h&gt;</a>
<a name="ln86">#include &lt;stdlib.h&gt;</a>
<a name="ln87">#include &lt;string.h&gt;</a>
<a name="ln88">#include &lt;unistd.h&gt;</a>
<a name="ln89">#include &lt;fcntl.h&gt;</a>
<a name="ln90">#include &lt;netdb.h&gt;</a>
<a name="ln91"> </a>
<a name="ln92">#ifndef HAVE_MD5</a>
<a name="ln93"># include &quot;../dst/md5.h&quot;</a>
<a name="ln94">#else</a>
<a name="ln95"># ifdef SOLARIS2</a>
<a name="ln96">#  include &lt;sys/md5.h&gt;</a>
<a name="ln97"># endif</a>
<a name="ln98">#endif</a>
<a name="ln99">#ifndef _MD5_H_</a>
<a name="ln100"># define _MD5_H_ 1	/*%&lt; make sure we do not include rsaref md5.h file */</a>
<a name="ln101">#endif</a>
<a name="ln102"> </a>
<a name="ln103">#include &quot;port_after.h&quot;</a>
<a name="ln104"> </a>
<a name="ln105">/* ensure that sockaddr_in6 and IN6ADDR_ANY_INIT are declared / defined */</a>
<a name="ln106">#include &lt;resolv.h&gt;</a>
<a name="ln107"> </a>
<a name="ln108">#include &lt;FindDirectory.h&gt;</a>
<a name="ln109"> </a>
<a name="ln110">#include &quot;res_private.h&quot;</a>
<a name="ln111"> </a>
<a name="ln112">#define RESOLVSORT</a>
<a name="ln113">/*% Options. Should all be left alone. */</a>
<a name="ln114">#ifndef DEBUG</a>
<a name="ln115">//#define DEBUG</a>
<a name="ln116">#endif</a>
<a name="ln117"> </a>
<a name="ln118">#ifdef SOLARIS2</a>
<a name="ln119">#include &lt;sys/systeminfo.h&gt;</a>
<a name="ln120">#endif</a>
<a name="ln121"> </a>
<a name="ln122">static void res_setoptions(res_state, const char *, const char *);</a>
<a name="ln123"> </a>
<a name="ln124">#ifdef RESOLVSORT</a>
<a name="ln125">static const char sort_mask[] = &quot;/&amp;&quot;;</a>
<a name="ln126">#define ISSORTMASK(ch) (strchr(sort_mask, ch) != NULL)</a>
<a name="ln127">static uint32_t net_mask __P((struct in_addr));</a>
<a name="ln128">#endif</a>
<a name="ln129"> </a>
<a name="ln130">#if !defined(isascii)	/*%&lt; XXX - could be a function */</a>
<a name="ln131"># define isascii(c) (!(c &amp; 0200))</a>
<a name="ln132">#endif</a>
<a name="ln133"> </a>
<a name="ln134">/*</a>
<a name="ln135"> * Resolver state default settings.</a>
<a name="ln136"> */</a>
<a name="ln137"> </a>
<a name="ln138">/*%</a>
<a name="ln139"> * Set up default settings.  If the configuration file exist, the values</a>
<a name="ln140"> * there will have precedence.  Otherwise, the server address is set to</a>
<a name="ln141"> * INADDR_ANY and the default domain name comes from the gethostname().</a>
<a name="ln142"> *</a>
<a name="ln143"> * An interrim version of this code (BIND 4.9, pre-4.4BSD) used 127.0.0.1</a>
<a name="ln144"> * rather than INADDR_ANY (&quot;0.0.0.0&quot;) as the default name server address</a>
<a name="ln145"> * since it was noted that INADDR_ANY actually meant ``the first interface</a>
<a name="ln146"> * you &quot;ifconfig&quot;'d at boot time'' and if this was a SLIP or PPP interface,</a>
<a name="ln147"> * it had to be &quot;up&quot; in order for you to reach your own name server.  It</a>
<a name="ln148"> * was later decided that since the recommended practice is to always</a>
<a name="ln149"> * install local static routes through 127.0.0.1 for all your network</a>
<a name="ln150"> * interfaces, that we could solve this problem without a code change.</a>
<a name="ln151"> *</a>
<a name="ln152"> * The configuration file should always be used, since it is the only way</a>
<a name="ln153"> * to specify a default domain.  If you are running a server on your local</a>
<a name="ln154"> * machine, you should say &quot;nameserver 0.0.0.0&quot; or &quot;nameserver 127.0.0.1&quot;</a>
<a name="ln155"> * in the configuration file.</a>
<a name="ln156"> *</a>
<a name="ln157"> * Return 0 if completes successfully, -1 on error</a>
<a name="ln158"> */</a>
<a name="ln159">int</a>
<a name="ln160">res_ninit(res_state statp) {</a>
<a name="ln161">	return (__res_vinit(statp, 0));</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">/*% This function has to be reachable by res_data.c but not publically. */</a>
<a name="ln165">int</a>
<a name="ln166">__res_vinit(res_state statp, int preinit) {</a>
<a name="ln167">	register FILE *fp;</a>
<a name="ln168">	register char *cp, **pp;</a>
<a name="ln169">	register int n;</a>
<a name="ln170">	char path[PATH_MAX];</a>
<a name="ln171">	char buf[BUFSIZ];</a>
<a name="ln172">	int nserv = 0;    /*%&lt; number of nameserver records read from file */</a>
<a name="ln173">	int haveenv = 0;</a>
<a name="ln174">	int havesearch = 0;</a>
<a name="ln175">#ifdef RESOLVSORT</a>
<a name="ln176">	int nsort = 0;</a>
<a name="ln177">	char *net;</a>
<a name="ln178">#endif</a>
<a name="ln179">	int dots;</a>
<a name="ln180">	union res_sockaddr_union u[2];</a>
<a name="ln181">	int maxns = MAXNS;</a>
<a name="ln182"> </a>
<a name="ln183">	RES_SET_H_ERRNO(statp, 0);</a>
<a name="ln184"> </a>
<a name="ln185">	if ((statp-&gt;options &amp; RES_INIT) != 0U)</a>
<a name="ln186">		res_ndestroy(statp);</a>
<a name="ln187"> </a>
<a name="ln188">	if (!preinit) {</a>
<a name="ln189">		statp-&gt;retrans = RES_TIMEOUT;</a>
<a name="ln190">		statp-&gt;retry = RES_DFLRETRY;</a>
<a name="ln191">		statp-&gt;options = RES_DEFAULT;</a>
<a name="ln192">	}</a>
<a name="ln193">	res_rndinit(statp);</a>
<a name="ln194">	statp-&gt;id = res_nrandomid(statp);</a>
<a name="ln195"> </a>
<a name="ln196">	memset(u, 0, sizeof(u));</a>
<a name="ln197">#ifdef USELOOPBACK</a>
<a name="ln198">	u[nserv].sin.sin_addr = inet_makeaddr(IN_LOOPBACKNET, 1);</a>
<a name="ln199">#else</a>
<a name="ln200">	u[nserv].sin.sin_addr.s_addr = INADDR_ANY;</a>
<a name="ln201">#endif</a>
<a name="ln202">	u[nserv].sin.sin_family = AF_INET;</a>
<a name="ln203">	u[nserv].sin.sin_port = htons(NAMESERVER_PORT);</a>
<a name="ln204">#ifdef HAVE_SA_LEN</a>
<a name="ln205">	u[nserv].sin.sin_len = sizeof(struct sockaddr_in);</a>
<a name="ln206">#endif</a>
<a name="ln207">	nserv++;</a>
<a name="ln208">#ifdef HAS_INET6_STRUCTS</a>
<a name="ln209">#ifdef USELOOPBACK</a>
<a name="ln210">	u[nserv].sin6.sin6_addr = in6addr_loopback;</a>
<a name="ln211">#else</a>
<a name="ln212">	u[nserv].sin6.sin6_addr = in6addr_any;</a>
<a name="ln213">#endif</a>
<a name="ln214">	u[nserv].sin6.sin6_family = AF_INET6;</a>
<a name="ln215">	u[nserv].sin6.sin6_port = htons(NAMESERVER_PORT);</a>
<a name="ln216">#ifdef HAVE_SA_LEN</a>
<a name="ln217">	u[nserv].sin6.sin6_len = sizeof(struct sockaddr_in6);</a>
<a name="ln218">#endif</a>
<a name="ln219">	nserv++;</a>
<a name="ln220">#endif</a>
<a name="ln221">	statp-&gt;nscount = 0;</a>
<a name="ln222">	statp-&gt;ndots = 1;</a>
<a name="ln223">	statp-&gt;pfcode = 0;</a>
<a name="ln224">	statp-&gt;_vcsock = -1;</a>
<a name="ln225">	statp-&gt;_flags = 0;</a>
<a name="ln226">	statp-&gt;qhook = NULL;</a>
<a name="ln227">	statp-&gt;rhook = NULL;</a>
<a name="ln228">	statp-&gt;_u._ext.nscount = 0;</a>
<a name="ln229">	statp-&gt;_u._ext.ext = malloc(sizeof(*statp-&gt;_u._ext.ext));</a>
<a name="ln230">	if (statp-&gt;_u._ext.ext != NULL) {</a>
<a name="ln231">	        memset(statp-&gt;_u._ext.ext, 0, sizeof(*statp-&gt;_u._ext.ext));</a>
<a name="ln232">		statp-&gt;_u._ext.ext-&gt;nsaddrs[0].sin = statp-&gt;nsaddr;</a>
<a name="ln233">		strcpy(statp-&gt;_u._ext.ext-&gt;nsuffix, &quot;ip6.arpa&quot;);</a>
<a name="ln234">		strcpy(statp-&gt;_u._ext.ext-&gt;nsuffix2, &quot;ip6.int&quot;);</a>
<a name="ln235">	} else {</a>
<a name="ln236">		/*</a>
<a name="ln237">		 * Historically res_init() rarely, if at all, failed.</a>
<a name="ln238">		 * Examples and applications exist which do not check</a>
<a name="ln239">		 * our return code.  Furthermore several applications</a>
<a name="ln240">		 * simply call us to get the systems domainname.  So</a>
<a name="ln241">		 * rather than immediately fail here we store the</a>
<a name="ln242">		 * failure, which is returned later, in h_errno.  And</a>
<a name="ln243">		 * prevent the collection of 'nameserver' information</a>
<a name="ln244">		 * by setting maxns to 0.  Thus applications that fail</a>
<a name="ln245">		 * to check our return code wont be able to make</a>
<a name="ln246">		 * queries anyhow.</a>
<a name="ln247">		 */</a>
<a name="ln248">		RES_SET_H_ERRNO(statp, NETDB_INTERNAL);</a>
<a name="ln249">		maxns = 0;</a>
<a name="ln250">	}</a>
<a name="ln251">#ifdef RESOLVSORT</a>
<a name="ln252">	statp-&gt;nsort = 0;</a>
<a name="ln253">#endif</a>
<a name="ln254">	res_setservers(statp, u, nserv);</a>
<a name="ln255"> </a>
<a name="ln256">#ifdef	SOLARIS2</a>
<a name="ln257">	/*</a>
<a name="ln258">	 * The old libresolv derived the defaultdomain from NIS/NIS+.</a>
<a name="ln259">	 * We want to keep this behaviour</a>
<a name="ln260">	 */</a>
<a name="ln261">	{</a>
<a name="ln262">		char buf[sizeof(statp-&gt;defdname)], *cp;</a>
<a name="ln263">		int ret;</a>
<a name="ln264"> </a>
<a name="ln265">		if ((ret = sysinfo(SI_SRPC_DOMAIN, buf, sizeof(buf))) &gt; 0 &amp;&amp;</a>
<a name="ln266">			(unsigned int)ret &lt;= sizeof(buf)) {</a>
<a name="ln267">			if (buf[0] == '+')</a>
<a name="ln268">				buf[0] = '.';</a>
<a name="ln269">			cp = strchr(buf, '.');</a>
<a name="ln270">			cp = (cp == NULL) ? buf : (cp + 1);</a>
<a name="ln271">			(void)strlcpy(statp-&gt;defdname, cp,</a>
<a name="ln272">			    sizeof(statp-&gt;defdname));</a>
<a name="ln273">		}</a>
<a name="ln274">	}</a>
<a name="ln275">#endif	/* SOLARIS2 */</a>
<a name="ln276"> </a>
<a name="ln277">	/* Allow user to override the local domain definition */</a>
<a name="ln278">	if ((cp = getenv(&quot;LOCALDOMAIN&quot;)) != NULL) {</a>
<a name="ln279">		(void)strncpy(statp-&gt;defdname, cp, sizeof(statp-&gt;defdname) - 1);</a>
<a name="ln280">		statp-&gt;defdname[sizeof(statp-&gt;defdname) - 1] = '\0';</a>
<a name="ln281">		haveenv++;</a>
<a name="ln282"> </a>
<a name="ln283">		/*</a>
<a name="ln284">		 * Set search list to be blank-separated strings</a>
<a name="ln285">		 * from rest of env value.  Permits users of LOCALDOMAIN</a>
<a name="ln286">		 * to still have a search list, and anyone to set the</a>
<a name="ln287">		 * one that they want to use as an individual (even more</a>
<a name="ln288">		 * important now that the rfc1535 stuff restricts searches)</a>
<a name="ln289">		 */</a>
<a name="ln290">		cp = statp-&gt;defdname;</a>
<a name="ln291">		pp = statp-&gt;dnsrch;</a>
<a name="ln292">		*pp++ = cp;</a>
<a name="ln293">		for (n = 0; *cp &amp;&amp; pp &lt; statp-&gt;dnsrch + MAXDNSRCH; cp++) {</a>
<a name="ln294">			if (*cp == '\n')	/*%&lt; silly backwards compat */</a>
<a name="ln295">				break;</a>
<a name="ln296">			else if (*cp == ' ' || *cp == '\t') {</a>
<a name="ln297">				*cp = 0;</a>
<a name="ln298">				n = 1;</a>
<a name="ln299">			} else if (n) {</a>
<a name="ln300">				*pp++ = cp;</a>
<a name="ln301">				n = 0;</a>
<a name="ln302">				havesearch = 1;</a>
<a name="ln303">			}</a>
<a name="ln304">		}</a>
<a name="ln305">		/* null terminate last domain if there are excess */</a>
<a name="ln306">		while (*cp != '\0' &amp;&amp; *cp != ' ' &amp;&amp; *cp != '\t' &amp;&amp; *cp != '\n')</a>
<a name="ln307">			cp++;</a>
<a name="ln308">		*cp = '\0';</a>
<a name="ln309">		*pp++ = 0;</a>
<a name="ln310">	}</a>
<a name="ln311"> </a>
<a name="ln312">#define	MATCH(line, name) \</a>
<a name="ln313">	(!strncmp(line, name, sizeof(name) - 1) &amp;&amp; \</a>
<a name="ln314">	(line[sizeof(name) - 1] == ' ' || \</a>
<a name="ln315">	 line[sizeof(name) - 1] == '\t'))</a>
<a name="ln316"> </a>
<a name="ln317">	if (find_directory(B_SYSTEM_SETTINGS_DIRECTORY, -1, false, path,</a>
<a name="ln318">			sizeof(path)) == B_OK)</a>
<a name="ln319">		strlcat(path, &quot;/network/resolv.conf&quot;, sizeof(path));</a>
<a name="ln320"> </a>
<a name="ln321">	nserv = 0;</a>
<a name="ln322">	if ((fp = fopen(path, &quot;re&quot;)) != NULL) {</a>
<a name="ln323">	    /* read the config file */</a>
<a name="ln324">	    while (fgets(buf, (int)sizeof(buf), fp) != NULL) {</a>
<a name="ln325">		/* skip comments */</a>
<a name="ln326">		if (*buf == ';' || *buf == '#')</a>
<a name="ln327">			continue;</a>
<a name="ln328">		/* read default domain name */</a>
<a name="ln329">		if (MATCH(buf, &quot;domain&quot;)) {</a>
<a name="ln330">		    if (haveenv)	/*%&lt; skip if have from environ */</a>
<a name="ln331">			    continue;</a>
<a name="ln332">		    cp = buf + sizeof(&quot;domain&quot;) - 1;</a>
<a name="ln333">		    while (*cp == ' ' || *cp == '\t')</a>
<a name="ln334">			    cp++;</a>
<a name="ln335">		    if ((*cp == '\0') || (*cp == '\n'))</a>
<a name="ln336">			    continue;</a>
<a name="ln337">		    strncpy(statp-&gt;defdname, cp, sizeof(statp-&gt;defdname) - 1);</a>
<a name="ln338">		    statp-&gt;defdname[sizeof(statp-&gt;defdname) - 1] = '\0';</a>
<a name="ln339">		    if ((cp = strpbrk(statp-&gt;defdname, &quot; \t\n&quot;)) != NULL)</a>
<a name="ln340">			    *cp = '\0';</a>
<a name="ln341">		    havesearch = 0;</a>
<a name="ln342">		    continue;</a>
<a name="ln343">		}</a>
<a name="ln344">		/* set search list */</a>
<a name="ln345">		if (MATCH(buf, &quot;search&quot;)) {</a>
<a name="ln346">		    if (haveenv)	/*%&lt; skip if have from environ */</a>
<a name="ln347">			    continue;</a>
<a name="ln348">		    cp = buf + sizeof(&quot;search&quot;) - 1;</a>
<a name="ln349">		    while (*cp == ' ' || *cp == '\t')</a>
<a name="ln350">			    cp++;</a>
<a name="ln351">		    if ((*cp == '\0') || (*cp == '\n'))</a>
<a name="ln352">			    continue;</a>
<a name="ln353">		    strncpy(statp-&gt;defdname, cp, sizeof(statp-&gt;defdname) - 1);</a>
<a name="ln354">		    statp-&gt;defdname[sizeof(statp-&gt;defdname) - 1] = '\0';</a>
<a name="ln355">		    if ((cp = strchr(statp-&gt;defdname, '\n')) != NULL)</a>
<a name="ln356">			    *cp = '\0';</a>
<a name="ln357">		    /*</a>
<a name="ln358">		     * Set search list to be blank-separated strings</a>
<a name="ln359">		     * on rest of line.</a>
<a name="ln360">		     */</a>
<a name="ln361">		    cp = statp-&gt;defdname;</a>
<a name="ln362">		    pp = statp-&gt;dnsrch;</a>
<a name="ln363">		    *pp++ = cp;</a>
<a name="ln364">		    for (n = 0; *cp &amp;&amp; pp &lt; statp-&gt;dnsrch + MAXDNSRCH; cp++) {</a>
<a name="ln365">			    if (*cp == ' ' || *cp == '\t') {</a>
<a name="ln366">				    *cp = 0;</a>
<a name="ln367">				    n = 1;</a>
<a name="ln368">			    } else if (n) {</a>
<a name="ln369">				    *pp++ = cp;</a>
<a name="ln370">				    n = 0;</a>
<a name="ln371">			    }</a>
<a name="ln372">		    }</a>
<a name="ln373">		    /* null terminate last domain if there are excess */</a>
<a name="ln374">		    while (*cp != '\0' &amp;&amp; *cp != ' ' &amp;&amp; *cp != '\t')</a>
<a name="ln375">			    cp++;</a>
<a name="ln376">		    *cp = '\0';</a>
<a name="ln377">		    *pp++ = 0;</a>
<a name="ln378">		    havesearch = 1;</a>
<a name="ln379">		    continue;</a>
<a name="ln380">		}</a>
<a name="ln381">		/* read nameservers to query */</a>
<a name="ln382">		if (MATCH(buf, &quot;nameserver&quot;) &amp;&amp; nserv &lt; maxns) {</a>
<a name="ln383">		    struct addrinfo hints, *ai;</a>
<a name="ln384">		    char sbuf[NI_MAXSERV];</a>
<a name="ln385">		    const size_t minsiz =</a>
<a name="ln386">		        sizeof(statp-&gt;_u._ext.ext-&gt;nsaddrs[0]);</a>
<a name="ln387"> </a>
<a name="ln388">		    cp = buf + sizeof(&quot;nameserver&quot;) - 1;</a>
<a name="ln389">		    while (*cp == ' ' || *cp == '\t')</a>
<a name="ln390">			cp++;</a>
<a name="ln391">		    cp[strcspn(cp, &quot;;# \t\n&quot;)] = '\0';</a>
<a name="ln392">		    if ((*cp != '\0') &amp;&amp; (*cp != '\n')) {</a>
<a name="ln393">			memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln394">			hints.ai_family = PF_UNSPEC;</a>
<a name="ln395">			hints.ai_socktype = SOCK_DGRAM;	/*dummy*/</a>
<a name="ln396">			hints.ai_flags = AI_NUMERICHOST;</a>
<a name="ln397">			sprintf(sbuf, &quot;%u&quot;, NAMESERVER_PORT);</a>
<a name="ln398">			if (getaddrinfo(cp, sbuf, &amp;hints, &amp;ai) == 0 &amp;&amp;</a>
<a name="ln399">			    ai-&gt;ai_addrlen &lt;= minsiz) {</a>
<a name="ln400">			    if (statp-&gt;_u._ext.ext != NULL) {</a>
<a name="ln401">				memcpy(&amp;statp-&gt;_u._ext.ext-&gt;nsaddrs[nserv],</a>
<a name="ln402">				    ai-&gt;ai_addr, ai-&gt;ai_addrlen);</a>
<a name="ln403">			    }</a>
<a name="ln404">			    if (ai-&gt;ai_addrlen &lt;=</a>
<a name="ln405">			        sizeof(statp-&gt;nsaddr_list[nserv])) {</a>
<a name="ln406">				memcpy(&amp;statp-&gt;nsaddr_list[nserv],</a>
<a name="ln407">				    ai-&gt;ai_addr, ai-&gt;ai_addrlen);</a>
<a name="ln408">			    } else</a>
<a name="ln409">				statp-&gt;nsaddr_list[nserv].sin_family = 0;</a>
<a name="ln410">			    freeaddrinfo(ai);</a>
<a name="ln411">			    nserv++;</a>
<a name="ln412">			}</a>
<a name="ln413">		    }</a>
<a name="ln414">		    continue;</a>
<a name="ln415">		}</a>
<a name="ln416">#ifdef RESOLVSORT</a>
<a name="ln417">		if (MATCH(buf, &quot;sortlist&quot;)) {</a>
<a name="ln418">		    struct in_addr a;</a>
<a name="ln419"> </a>
<a name="ln420">		    cp = buf + sizeof(&quot;sortlist&quot;) - 1;</a>
<a name="ln421">		    while (nsort &lt; MAXRESOLVSORT) {</a>
<a name="ln422">			while (*cp == ' ' || *cp == '\t')</a>
<a name="ln423">			    cp++;</a>
<a name="ln424">			if (*cp == '\0' || *cp == '\n' || *cp == ';')</a>
<a name="ln425">			    break;</a>
<a name="ln426">			net = cp;</a>
<a name="ln427">			while (*cp &amp;&amp; !ISSORTMASK(*cp) &amp;&amp; *cp != ';' &amp;&amp;</a>
<a name="ln428">			       isascii(*cp) &amp;&amp; !isspace((unsigned char)*cp))</a>
<a name="ln429">				cp++;</a>
<a name="ln430">			n = *cp;</a>
<a name="ln431">			*cp = 0;</a>
<a name="ln432">			if (inet_aton(net, &amp;a)) {</a>
<a name="ln433">			    statp-&gt;sort_list[nsort].addr = a;</a>
<a name="ln434">			    if (ISSORTMASK(n)) {</a>
<a name="ln435">				*cp++ = n;</a>
<a name="ln436">				net = cp;</a>
<a name="ln437">				while (*cp &amp;&amp; *cp != ';' &amp;&amp;</a>
<a name="ln438">					isascii(*cp) &amp;&amp;</a>
<a name="ln439">					!isspace((unsigned char)*cp))</a>
<a name="ln440">				    cp++;</a>
<a name="ln441">				n = *cp;</a>
<a name="ln442">				*cp = 0;</a>
<a name="ln443">				if (inet_aton(net, &amp;a)) {</a>
<a name="ln444">				    statp-&gt;sort_list[nsort].mask = a.s_addr;</a>
<a name="ln445">				} else {</a>
<a name="ln446">				    statp-&gt;sort_list[nsort].mask =</a>
<a name="ln447">					net_mask(statp-&gt;sort_list[nsort].addr);</a>
<a name="ln448">				}</a>
<a name="ln449">			    } else {</a>
<a name="ln450">				statp-&gt;sort_list[nsort].mask =</a>
<a name="ln451">				    net_mask(statp-&gt;sort_list[nsort].addr);</a>
<a name="ln452">			    }</a>
<a name="ln453">			    nsort++;</a>
<a name="ln454">			}</a>
<a name="ln455">			*cp = n;</a>
<a name="ln456">		    }</a>
<a name="ln457">		    continue;</a>
<a name="ln458">		}</a>
<a name="ln459">#endif</a>
<a name="ln460">		if (MATCH(buf, &quot;options&quot;)) {</a>
<a name="ln461">		    res_setoptions(statp, buf + sizeof(&quot;options&quot;) - 1, &quot;conf&quot;);</a>
<a name="ln462">		    continue;</a>
<a name="ln463">		}</a>
<a name="ln464">	    }</a>
<a name="ln465">	    if (nserv &gt; 0)</a>
<a name="ln466">		statp-&gt;nscount = nserv;</a>
<a name="ln467">#ifdef RESOLVSORT</a>
<a name="ln468">	    statp-&gt;nsort = nsort;</a>
<a name="ln469">#endif</a>
<a name="ln470">	    (void) fclose(fp);</a>
<a name="ln471">	}</a>
<a name="ln472">/*</a>
<a name="ln473"> * Last chance to get a nameserver.  This should not normally</a>
<a name="ln474"> * be necessary</a>
<a name="ln475"> */</a>
<a name="ln476">#ifdef NO_RESOLV_CONF</a>
<a name="ln477">	if(nserv == 0)</a>
<a name="ln478">		nserv = get_nameservers(statp);</a>
<a name="ln479">#endif</a>
<a name="ln480"> </a>
<a name="ln481">	if (statp-&gt;defdname[0] == 0 &amp;&amp;</a>
<a name="ln482">	    gethostname(buf, sizeof(statp-&gt;defdname) - 1) == 0 &amp;&amp;</a>
<a name="ln483">	    (cp = strchr(buf, '.')) != NULL)</a>
<a name="ln484">		strcpy(statp-&gt;defdname, cp + 1);</a>
<a name="ln485"> </a>
<a name="ln486">	/* find components of local domain that might be searched */</a>
<a name="ln487">	if (havesearch == 0) {</a>
<a name="ln488">		pp = statp-&gt;dnsrch;</a>
<a name="ln489">		*pp++ = statp-&gt;defdname;</a>
<a name="ln490">		*pp = NULL;</a>
<a name="ln491"> </a>
<a name="ln492">		dots = 0;</a>
<a name="ln493">		for (cp = statp-&gt;defdname; *cp; cp++)</a>
<a name="ln494">			dots += (*cp == '.');</a>
<a name="ln495"> </a>
<a name="ln496">		cp = statp-&gt;defdname;</a>
<a name="ln497">		while (pp &lt; statp-&gt;dnsrch + MAXDFLSRCH) {</a>
<a name="ln498">			if (dots &lt; LOCALDOMAINPARTS)</a>
<a name="ln499">				break;</a>
<a name="ln500">			cp = strchr(cp, '.') + 1;    /*%&lt; we know there is one */</a>
<a name="ln501">			*pp++ = cp;</a>
<a name="ln502">			dots--;</a>
<a name="ln503">		}</a>
<a name="ln504">		*pp = NULL;</a>
<a name="ln505">#ifdef DEBUG</a>
<a name="ln506">		if (statp-&gt;options &amp; RES_DEBUG) {</a>
<a name="ln507">			printf(&quot;;; res_init()... default dnsrch list:\n&quot;);</a>
<a name="ln508">			for (pp = statp-&gt;dnsrch; *pp; pp++)</a>
<a name="ln509">				printf(&quot;;;\t%s\n&quot;, *pp);</a>
<a name="ln510">			printf(&quot;;;\t..END..\n&quot;);</a>
<a name="ln511">		}</a>
<a name="ln512">#endif</a>
<a name="ln513">	}</a>
<a name="ln514"> </a>
<a name="ln515">	if ((cp = getenv(&quot;RES_OPTIONS&quot;)) != NULL)</a>
<a name="ln516">		res_setoptions(statp, cp, &quot;env&quot;);</a>
<a name="ln517">	statp-&gt;options |= RES_INIT;</a>
<a name="ln518">	return (statp-&gt;res_h_errno);</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">static void</a>
<a name="ln522">res_setoptions(res_state statp, const char *options, const char *source)</a>
<a name="ln523">{</a>
<a name="ln524">	const char *cp = options;</a>
<a name="ln525">	int i;</a>
<a name="ln526">	size_t j;</a>
<a name="ln527">	struct __res_state_ext *ext = statp-&gt;_u._ext.ext;</a>
<a name="ln528"> </a>
<a name="ln529">#ifdef DEBUG</a>
<a name="ln530">	if (statp-&gt;options &amp; RES_DEBUG)</a>
<a name="ln531">		printf(&quot;;; res_setoptions(\&quot;%s\&quot;, \&quot;%s\&quot;)...\n&quot;,</a>
<a name="ln532">		       options, source);</a>
<a name="ln533">#endif</a>
<a name="ln534">	while (*cp) {</a>
<a name="ln535">		/* skip leading and inner runs of spaces */</a>
<a name="ln536">		while (*cp == ' ' || *cp == '\t')</a>
<a name="ln537">			cp++;</a>
<a name="ln538">		/* search for and process individual options */</a>
<a name="ln539">		if (!strncmp(cp, &quot;ndots:&quot;, sizeof(&quot;ndots:&quot;) - 1)) {</a>
<a name="ln540">			i = atoi(cp + sizeof(&quot;ndots:&quot;) - 1);</a>
<a name="ln541">			if (i &lt;= RES_MAXNDOTS)</a>
<a name="ln542">				statp-&gt;ndots = i;</a>
<a name="ln543">			else</a>
<a name="ln544">				statp-&gt;ndots = RES_MAXNDOTS;</a>
<a name="ln545">#ifdef DEBUG</a>
<a name="ln546">			if (statp-&gt;options &amp; RES_DEBUG)</a>
<a name="ln547">				printf(&quot;;;\tndots=%d\n&quot;, statp-&gt;ndots);</a>
<a name="ln548">#endif</a>
<a name="ln549">		} else if (!strncmp(cp, &quot;timeout:&quot;, sizeof(&quot;timeout:&quot;) - 1)) {</a>
<a name="ln550">			i = atoi(cp + sizeof(&quot;timeout:&quot;) - 1);</a>
<a name="ln551">			if (i &lt;= RES_MAXRETRANS)</a>
<a name="ln552">				statp-&gt;retrans = i;</a>
<a name="ln553">			else</a>
<a name="ln554">				statp-&gt;retrans = RES_MAXRETRANS;</a>
<a name="ln555">#ifdef DEBUG</a>
<a name="ln556">			if (statp-&gt;options &amp; RES_DEBUG)</a>
<a name="ln557">				printf(&quot;;;\ttimeout=%d\n&quot;, statp-&gt;retrans);</a>
<a name="ln558">#endif</a>
<a name="ln559">#ifdef	SOLARIS2</a>
<a name="ln560">		} else if (!strncmp(cp, &quot;retrans:&quot;, sizeof(&quot;retrans:&quot;) - 1)) {</a>
<a name="ln561">			/*</a>
<a name="ln562">		 	 * For backward compatibility, 'retrans' is</a>
<a name="ln563">		 	 * supported as an alias for 'timeout', though</a>
<a name="ln564">		 	 * without an imposed maximum.</a>
<a name="ln565">		 	 */</a>
<a name="ln566">			statp-&gt;retrans = atoi(cp + sizeof(&quot;retrans:&quot;) - 1);</a>
<a name="ln567">		} else if (!strncmp(cp, &quot;retry:&quot;, sizeof(&quot;retry:&quot;) - 1)){</a>
<a name="ln568">			/*</a>
<a name="ln569">			 * For backward compatibility, 'retry' is</a>
<a name="ln570">			 * supported as an alias for 'attempts', though</a>
<a name="ln571">			 * without an imposed maximum.</a>
<a name="ln572">			 */</a>
<a name="ln573">			statp-&gt;retry = atoi(cp + sizeof(&quot;retry:&quot;) - 1);</a>
<a name="ln574">#endif	/* SOLARIS2 */</a>
<a name="ln575">		} else if (!strncmp(cp, &quot;attempts:&quot;, sizeof(&quot;attempts:&quot;) - 1)){</a>
<a name="ln576">			i = atoi(cp + sizeof(&quot;attempts:&quot;) - 1);</a>
<a name="ln577">			if (i &lt;= RES_MAXRETRY)</a>
<a name="ln578">				statp-&gt;retry = i;</a>
<a name="ln579">			else</a>
<a name="ln580">				statp-&gt;retry = RES_MAXRETRY;</a>
<a name="ln581">#ifdef DEBUG</a>
<a name="ln582">			if (statp-&gt;options &amp; RES_DEBUG)</a>
<a name="ln583">				printf(&quot;;;\tattempts=%d\n&quot;, statp-&gt;retry);</a>
<a name="ln584">#endif</a>
<a name="ln585">		} else if (!strncmp(cp, &quot;debug&quot;, sizeof(&quot;debug&quot;) - 1)) {</a>
<a name="ln586">#ifdef DEBUG</a>
<a name="ln587">			if (!(statp-&gt;options &amp; RES_DEBUG)) {</a>
<a name="ln588">				printf(&quot;;; res_setoptions(\&quot;%s\&quot;, \&quot;%s\&quot;)..\n&quot;,</a>
<a name="ln589">				       options, source);</a>
<a name="ln590">				statp-&gt;options |= RES_DEBUG;</a>
<a name="ln591">			}</a>
<a name="ln592">			printf(&quot;;;\tdebug\n&quot;);</a>
<a name="ln593">#endif</a>
<a name="ln594">		} else if (!strncmp(cp, &quot;no_tld_query&quot;,</a>
<a name="ln595">				    sizeof(&quot;no_tld_query&quot;) - 1) ||</a>
<a name="ln596">			   !strncmp(cp, &quot;no-tld-query&quot;,</a>
<a name="ln597">				    sizeof(&quot;no-tld-query&quot;) - 1)) {</a>
<a name="ln598">			statp-&gt;options |= RES_NOTLDQUERY;</a>
<a name="ln599">		} else if (!strncmp(cp, &quot;inet6&quot;, sizeof(&quot;inet6&quot;) - 1)) {</a>
<a name="ln600">			statp-&gt;options |= RES_USE_INET6;</a>
<a name="ln601">		} else if (!strncmp(cp, &quot;inet4&quot;, sizeof(&quot;inet4&quot;) - 1)) {</a>
<a name="ln602">			statp-&gt;options |= RES_USE_INET4;</a>
<a name="ln603">		} else if (!strncmp(cp, &quot;rotate&quot;, sizeof(&quot;rotate&quot;) - 1)) {</a>
<a name="ln604">			statp-&gt;options |= RES_ROTATE;</a>
<a name="ln605">		} else if (!strncmp(cp, &quot;no-check-names&quot;,</a>
<a name="ln606">				    sizeof(&quot;no-check-names&quot;) - 1)) {</a>
<a name="ln607">			statp-&gt;options |= RES_NOCHECKNAME;</a>
<a name="ln608">		}</a>
<a name="ln609">#ifdef RES_USE_EDNS0</a>
<a name="ln610">		else if (!strncmp(cp, &quot;edns0&quot;, sizeof(&quot;edns0&quot;) - 1)) {</a>
<a name="ln611">			statp-&gt;options |= RES_USE_EDNS0;</a>
<a name="ln612">		}</a>
<a name="ln613">#endif</a>
<a name="ln614">		else if (!strncmp(cp, &quot;dname&quot;, sizeof(&quot;dname&quot;) - 1)) {</a>
<a name="ln615">			statp-&gt;options |= RES_USE_DNAME;</a>
<a name="ln616">		}</a>
<a name="ln617">		else if (!strncmp(cp, &quot;nibble:&quot;, sizeof(&quot;nibble:&quot;) - 1)) {</a>
<a name="ln618">			if (ext == NULL)</a>
<a name="ln619">				goto skip;</a>
<a name="ln620">			cp += sizeof(&quot;nibble:&quot;) - 1;</a>
<a name="ln621">			j = MIN(strcspn(cp, &quot; \t&quot;), sizeof(ext-&gt;nsuffix) - 1);</a>
<a name="ln622">			strncpy(ext-&gt;nsuffix, cp, j);</a>
<a name="ln623">			ext-&gt;nsuffix[j] = '\0';</a>
<a name="ln624">		}</a>
<a name="ln625">		else if (!strncmp(cp, &quot;nibble2:&quot;, sizeof(&quot;nibble2:&quot;) - 1)) {</a>
<a name="ln626">			if (ext == NULL)</a>
<a name="ln627">				goto skip;</a>
<a name="ln628">			cp += sizeof(&quot;nibble2:&quot;) - 1;</a>
<a name="ln629">			j = MIN(strcspn(cp, &quot; \t&quot;), sizeof(ext-&gt;nsuffix2) - 1);</a>
<a name="ln630">			strncpy(ext-&gt;nsuffix2, cp, j);</a>
<a name="ln631">			ext-&gt;nsuffix2[j] = '\0';</a>
<a name="ln632">		}</a>
<a name="ln633">		else if (!strncmp(cp, &quot;v6revmode:&quot;, sizeof(&quot;v6revmode:&quot;) - 1)) {</a>
<a name="ln634">			cp += sizeof(&quot;v6revmode:&quot;) - 1;</a>
<a name="ln635">			/* &quot;nibble&quot; and &quot;bitstring&quot; used to be valid */</a>
<a name="ln636">			if (!strncmp(cp, &quot;single&quot;, sizeof(&quot;single&quot;) - 1)) {</a>
<a name="ln637">				statp-&gt;options |= RES_NO_NIBBLE2;</a>
<a name="ln638">			} else if (!strncmp(cp, &quot;both&quot;, sizeof(&quot;both&quot;) - 1)) {</a>
<a name="ln639">				statp-&gt;options &amp;=</a>
<a name="ln640">					 ~RES_NO_NIBBLE2;</a>
<a name="ln641">			}</a>
<a name="ln642">		}</a>
<a name="ln643">		else {</a>
<a name="ln644">			/* XXX - print a warning here? */</a>
<a name="ln645">		}</a>
<a name="ln646">   skip:</a>
<a name="ln647">		/* skip to next run of spaces */</a>
<a name="ln648">		while (*cp &amp;&amp; *cp != ' ' &amp;&amp; *cp != '\t')</a>
<a name="ln649">			cp++;</a>
<a name="ln650">	}</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">#ifdef RESOLVSORT</a>
<a name="ln654">/* XXX - should really support CIDR which means explicit masks always. */</a>
<a name="ln655">static uint32_t</a>
<a name="ln656">net_mask(struct in_addr in) /*!&lt; XXX - should really use system's version of this  */</a>
<a name="ln657">{</a>
<a name="ln658">	register uint32_t i = ntohl(in.s_addr);</a>
<a name="ln659"> </a>
<a name="ln660">	if (IN_CLASSA(i))</a>
<a name="ln661">		return (htonl(IN_CLASSA_NET));</a>
<a name="ln662">	else if (IN_CLASSB(i))</a>
<a name="ln663">		return (htonl(IN_CLASSB_NET));</a>
<a name="ln664">	return (htonl(IN_CLASSC_NET));</a>
<a name="ln665">}</a>
<a name="ln666">#endif</a>
<a name="ln667"> </a>
<a name="ln668">void</a>
<a name="ln669">res_rndinit(res_state statp)</a>
<a name="ln670">{</a>
<a name="ln671">	struct timeval now;</a>
<a name="ln672">	uint32_t u32;</a>
<a name="ln673">	uint16_t u16;</a>
<a name="ln674">	u_char *rnd = statp-&gt;_rnd;</a>
<a name="ln675"> </a>
<a name="ln676">	gettimeofday(&amp;now, NULL);</a>
<a name="ln677">	u32 = (uint32_t)now.tv_sec;</a>
<a name="ln678">	memcpy(rnd, &amp;u32, 4);</a>
<a name="ln679">	u32 = now.tv_usec;</a>
<a name="ln680">	memcpy(rnd + 4, &amp;u32, 4);</a>
<a name="ln681">	u32 += (uint32_t)now.tv_sec;</a>
<a name="ln682">	memcpy(rnd + 8, &amp;u32, 4);</a>
<a name="ln683">	u16 = getpid();</a>
<a name="ln684">	memcpy(rnd + 12, &amp;u16, 2);</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">u_int</a>
<a name="ln688">res_nrandomid(res_state statp)</a>
<a name="ln689">{</a>
<a name="ln690">	struct timeval now;</a>
<a name="ln691">	uint16_t u16;</a>
<a name="ln692">	MD5_CTX ctx;</a>
<a name="ln693">	u_char *rnd = statp-&gt;_rnd;</a>
<a name="ln694"> </a>
<a name="ln695">	gettimeofday(&amp;now, NULL);</a>
<a name="ln696">	u16 = (uint16_t) (now.tv_sec ^ now.tv_usec);</a>
<a name="ln697">	memcpy(rnd + 14, &amp;u16, 2);</a>
<a name="ln698">#ifndef HAVE_MD5</a>
<a name="ln699">	MD5_Init(&amp;ctx);</a>
<a name="ln700">	MD5_Update(&amp;ctx, rnd, 16);</a>
<a name="ln701">	MD5_Final(rnd, &amp;ctx);</a>
<a name="ln702">#else</a>
<a name="ln703">	MD5Init(&amp;ctx);</a>
<a name="ln704">	MD5Update(&amp;ctx, rnd, 16);</a>
<a name="ln705">	MD5Final(rnd, &amp;ctx);</a>
<a name="ln706">#endif</a>
<a name="ln707">	memcpy(&amp;u16, rnd + 14, 2);</a>
<a name="ln708">	return ((u_int) u16);</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">/*%</a>
<a name="ln712"> * This routine is for closing the socket if a virtual circuit is used and</a>
<a name="ln713"> * the program wants to close it.  This provides support for endhostent()</a>
<a name="ln714"> * which expects to close the socket.</a>
<a name="ln715"> *</a>
<a name="ln716"> * This routine is not expected to be user visible.</a>
<a name="ln717"> */</a>
<a name="ln718">void</a>
<a name="ln719">res_nclose(res_state statp)</a>
<a name="ln720">{</a>
<a name="ln721">	int ns;</a>
<a name="ln722"> </a>
<a name="ln723">	if (statp-&gt;_vcsock &gt;= 0) {</a>
<a name="ln724">		(void) close(statp-&gt;_vcsock);</a>
<a name="ln725">		statp-&gt;_vcsock = -1;</a>
<a name="ln726">		statp-&gt;_flags &amp;= ~(RES_F_VC | RES_F_CONN);</a>
<a name="ln727">	}</a>
<a name="ln728">	for (ns = 0; ns &lt; statp-&gt;_u._ext.nscount; ns++) {</a>
<a name="ln729">		if (statp-&gt;_u._ext.nssocks[ns] != -1) {</a>
<a name="ln730">			(void) close(statp-&gt;_u._ext.nssocks[ns]);</a>
<a name="ln731">			statp-&gt;_u._ext.nssocks[ns] = -1;</a>
<a name="ln732">		}</a>
<a name="ln733">	}</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">void</a>
<a name="ln737">res_ndestroy(res_state statp)</a>
<a name="ln738">{</a>
<a name="ln739">	res_nclose(statp);</a>
<a name="ln740">	if (statp-&gt;_u._ext.ext != NULL) {</a>
<a name="ln741">		if (statp-&gt;_u._ext.ext-&gt;kq != -1)</a>
<a name="ln742">			(void)close(statp-&gt;_u._ext.ext-&gt;kq);</a>
<a name="ln743">		if (statp-&gt;_u._ext.ext-&gt;resfd != -1)</a>
<a name="ln744">			(void)close(statp-&gt;_u._ext.ext-&gt;resfd);</a>
<a name="ln745">		free(statp-&gt;_u._ext.ext);</a>
<a name="ln746">		statp-&gt;_u._ext.ext = NULL;</a>
<a name="ln747">	}</a>
<a name="ln748">	statp-&gt;options &amp;= ~RES_INIT;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">const char *</a>
<a name="ln752">res_get_nibblesuffix(res_state statp)</a>
<a name="ln753">{</a>
<a name="ln754">	if (statp-&gt;_u._ext.ext)</a>
<a name="ln755">		return (statp-&gt;_u._ext.ext-&gt;nsuffix);</a>
<a name="ln756">	return (&quot;ip6.arpa&quot;);</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">const char *</a>
<a name="ln760">res_get_nibblesuffix2(res_state statp)</a>
<a name="ln761">{</a>
<a name="ln762">	if (statp-&gt;_u._ext.ext)</a>
<a name="ln763">		return (statp-&gt;_u._ext.ext-&gt;nsuffix2);</a>
<a name="ln764">	return (&quot;ip6.int&quot;);</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767">void</a>
<a name="ln768">res_setservers(res_state statp, const union res_sockaddr_union *set, int cnt)</a>
<a name="ln769">{</a>
<a name="ln770">	int i, nserv;</a>
<a name="ln771">	size_t size;</a>
<a name="ln772"> </a>
<a name="ln773">	/* close open servers */</a>
<a name="ln774">	res_nclose(statp);</a>
<a name="ln775"> </a>
<a name="ln776">	/* cause rtt times to be forgotten */</a>
<a name="ln777">	statp-&gt;_u._ext.nscount = 0;</a>
<a name="ln778"> </a>
<a name="ln779">	nserv = 0;</a>
<a name="ln780">	for (i = 0; i &lt; cnt &amp;&amp; nserv &lt; MAXNS; i++) {</a>
<a name="ln781">		switch (set-&gt;sin.sin_family) {</a>
<a name="ln782">		case AF_INET:</a>
<a name="ln783">			size = sizeof(set-&gt;sin);</a>
<a name="ln784">			if (statp-&gt;_u._ext.ext)</a>
<a name="ln785">				memcpy(&amp;statp-&gt;_u._ext.ext-&gt;nsaddrs[nserv],</a>
<a name="ln786">					&amp;set-&gt;sin, size);</a>
<a name="ln787">			if (size &lt;= sizeof(statp-&gt;nsaddr_list[nserv]))</a>
<a name="ln788">				memcpy(&amp;statp-&gt;nsaddr_list[nserv],</a>
<a name="ln789">					&amp;set-&gt;sin, size);</a>
<a name="ln790">			else</a>
<a name="ln791">				statp-&gt;nsaddr_list[nserv].sin_family = 0;</a>
<a name="ln792">			nserv++;</a>
<a name="ln793">			break;</a>
<a name="ln794"> </a>
<a name="ln795">#ifdef HAS_INET6_STRUCTS</a>
<a name="ln796">		case AF_INET6:</a>
<a name="ln797">			size = sizeof(set-&gt;sin6);</a>
<a name="ln798">			if (statp-&gt;_u._ext.ext)</a>
<a name="ln799">				memcpy(&amp;statp-&gt;_u._ext.ext-&gt;nsaddrs[nserv],</a>
<a name="ln800">					&amp;set-&gt;sin6, size);</a>
<a name="ln801">			if (size &lt;= sizeof(statp-&gt;nsaddr_list[nserv]))</a>
<a name="ln802">				memcpy(&amp;statp-&gt;nsaddr_list[nserv],</a>
<a name="ln803">					&amp;set-&gt;sin6, size);</a>
<a name="ln804">			else</a>
<a name="ln805">				statp-&gt;nsaddr_list[nserv].sin_family = 0;</a>
<a name="ln806">			nserv++;</a>
<a name="ln807">			break;</a>
<a name="ln808">#endif</a>
<a name="ln809"> </a>
<a name="ln810">		default:</a>
<a name="ln811">			break;</a>
<a name="ln812">		}</a>
<a name="ln813">		set++;</a>
<a name="ln814">	}</a>
<a name="ln815">	statp-&gt;nscount = nserv;</a>
<a name="ln816"> </a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">int</a>
<a name="ln820">res_getservers(res_state statp, union res_sockaddr_union *set, int cnt)</a>
<a name="ln821">{</a>
<a name="ln822">	int i;</a>
<a name="ln823">	size_t size;</a>
<a name="ln824">	uint16_t family;</a>
<a name="ln825"> </a>
<a name="ln826">	for (i = 0; i &lt; statp-&gt;nscount &amp;&amp; i &lt; cnt; i++) {</a>
<a name="ln827">		if (statp-&gt;_u._ext.ext)</a>
<a name="ln828">			family = statp-&gt;_u._ext.ext-&gt;nsaddrs[i].sin.sin_family;</a>
<a name="ln829">		else</a>
<a name="ln830">			family = statp-&gt;nsaddr_list[i].sin_family;</a>
<a name="ln831"> </a>
<a name="ln832">		switch (family) {</a>
<a name="ln833">		case AF_INET:</a>
<a name="ln834">			size = sizeof(set-&gt;sin);</a>
<a name="ln835">			if (statp-&gt;_u._ext.ext)</a>
<a name="ln836">				memcpy(&amp;set-&gt;sin,</a>
<a name="ln837">				       &amp;statp-&gt;_u._ext.ext-&gt;nsaddrs[i],</a>
<a name="ln838">				       size);</a>
<a name="ln839">			else</a>
<a name="ln840">				memcpy(&amp;set-&gt;sin, &amp;statp-&gt;nsaddr_list[i],</a>
<a name="ln841">				       size);</a>
<a name="ln842">			break;</a>
<a name="ln843"> </a>
<a name="ln844">#ifdef HAS_INET6_STRUCTS</a>
<a name="ln845">		case AF_INET6:</a>
<a name="ln846">			size = sizeof(set-&gt;sin6);</a>
<a name="ln847">			if (statp-&gt;_u._ext.ext)</a>
<a name="ln848">				memcpy(&amp;set-&gt;sin6,</a>
<a name="ln849">				       &amp;statp-&gt;_u._ext.ext-&gt;nsaddrs[i],</a>
<a name="ln850">				       size);</a>
<a name="ln851">			else</a>
<a name="ln852">				memcpy(&amp;set-&gt;sin6, &amp;statp-&gt;nsaddr_list[i],</a>
<a name="ln853">				       size);</a>
<a name="ln854">			break;</a>
<a name="ln855">#endif</a>
<a name="ln856"> </a>
<a name="ln857">		default:</a>
<a name="ln858">			set-&gt;sin.sin_family = 0;</a>
<a name="ln859">			break;</a>
<a name="ln860">		}</a>
<a name="ln861">		set++;</a>
<a name="ln862">	}</a>
<a name="ln863">	return (statp-&gt;nscount);</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">/*! \file */</a>

</code></pre>
<div class="balloon" rel="801"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>
<div class="balloon" rel="678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'rnd'.</p></div>
<div class="balloon" rel="787"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
