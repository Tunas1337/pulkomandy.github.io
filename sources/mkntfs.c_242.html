
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mkntfs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * mkntfs - Part of the Linux-NTFS project.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2000-2011 Anton Altaparmakov</a>
<a name="ln5"> * Copyright (c) 2001-2005 Richard Russon</a>
<a name="ln6"> * Copyright (c) 2002-2006 Szabolcs Szakacsits</a>
<a name="ln7"> * Copyright (c) 2005      Erik Sornes</a>
<a name="ln8"> * Copyright (c) 2007      Yura Pakhuchiy</a>
<a name="ln9"> * Copyright (c) 2010      Jean-Pierre Andre</a>
<a name="ln10"> *</a>
<a name="ln11"> * This utility will create an NTFS 1.2 or 3.1 volume on a user</a>
<a name="ln12"> * specified (block) device.</a>
<a name="ln13"> *</a>
<a name="ln14"> * Some things (option handling and determination of mount status) have been</a>
<a name="ln15"> * adapted from e2fsprogs-1.19 and lib/ext2fs/ismounted.c and misc/mke2fs.c in</a>
<a name="ln16"> * particular.</a>
<a name="ln17"> *</a>
<a name="ln18"> * This program is free software; you can redistribute it and/or modify</a>
<a name="ln19"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln20"> * the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln21"> * (at your option) any later version.</a>
<a name="ln22"> *</a>
<a name="ln23"> * This program is distributed in the hope that it will be useful,</a>
<a name="ln24"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln25"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln26"> * GNU General Public License for more details.</a>
<a name="ln27"> *</a>
<a name="ln28"> * You should have received a copy of the GNU General Public License</a>
<a name="ln29"> * along with this program (in the main directory of the Linux-NTFS source</a>
<a name="ln30"> * in the file COPYING); if not, write to the Free Software Foundation,</a>
<a name="ln31"> * Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln32"> */</a>
<a name="ln33"> </a>
<a name="ln34">#ifdef HAVE_CONFIG_H</a>
<a name="ln35">#include &quot;config.h&quot;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38">#ifdef  HAVE_UNISTD_H</a>
<a name="ln39">#include &lt;unistd.h&gt;</a>
<a name="ln40">#endif</a>
<a name="ln41">#ifdef HAVE_STDLIB_H</a>
<a name="ln42">#include &lt;stdlib.h&gt;</a>
<a name="ln43">#endif</a>
<a name="ln44">#ifdef HAVE_STDIO_H</a>
<a name="ln45">#include &lt;stdio.h&gt;</a>
<a name="ln46">#endif</a>
<a name="ln47">#ifdef HAVE_STDARG_H</a>
<a name="ln48">#include &lt;stdarg.h&gt;</a>
<a name="ln49">#endif</a>
<a name="ln50">#ifdef HAVE_STRING_H</a>
<a name="ln51">#include &lt;string.h&gt;</a>
<a name="ln52">#endif</a>
<a name="ln53">#ifdef HAVE_ERRNO_H</a>
<a name="ln54">#include &lt;errno.h&gt;</a>
<a name="ln55">#endif</a>
<a name="ln56">#ifdef HAVE_TIME_H</a>
<a name="ln57">#include &lt;time.h&gt;</a>
<a name="ln58">#endif</a>
<a name="ln59">#ifdef HAVE_SYS_STAT_H</a>
<a name="ln60">#include &lt;sys/stat.h&gt;</a>
<a name="ln61">#endif</a>
<a name="ln62">#ifdef HAVE_FCNTL_H</a>
<a name="ln63">#include &lt;fcntl.h&gt;</a>
<a name="ln64">#endif</a>
<a name="ln65">#ifdef HAVE_LIMITS_H</a>
<a name="ln66">#include &lt;limits.h&gt;</a>
<a name="ln67">#endif</a>
<a name="ln68">#ifdef HAVE_LIBGEN_H</a>
<a name="ln69">#include &lt;libgen.h&gt;</a>
<a name="ln70">#endif</a>
<a name="ln71">#ifdef ENABLE_UUID</a>
<a name="ln72">#include &lt;uuid/uuid.h&gt;</a>
<a name="ln73">#endif</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">#ifdef HAVE_GETOPT_H</a>
<a name="ln77">#include &lt;getopt.h&gt;</a>
<a name="ln78">#else</a>
<a name="ln79">	extern char *optarg;</a>
<a name="ln80">	extern int optind;</a>
<a name="ln81">#endif</a>
<a name="ln82"> </a>
<a name="ln83">#ifdef HAVE_LINUX_MAJOR_H</a>
<a name="ln84">#	include &lt;linux/major.h&gt;</a>
<a name="ln85">#	ifndef MAJOR</a>
<a name="ln86">#		define MAJOR(dev)	((dev) &gt;&gt; 8)</a>
<a name="ln87">#		define MINOR(dev)	((dev) &amp; 0xff)</a>
<a name="ln88">#	endif</a>
<a name="ln89">#	ifndef IDE_DISK_MAJOR</a>
<a name="ln90">#		ifndef IDE0_MAJOR</a>
<a name="ln91">#			define IDE0_MAJOR	3</a>
<a name="ln92">#			define IDE1_MAJOR	22</a>
<a name="ln93">#			define IDE2_MAJOR	33</a>
<a name="ln94">#			define IDE3_MAJOR	34</a>
<a name="ln95">#			define IDE4_MAJOR	56</a>
<a name="ln96">#			define IDE5_MAJOR	57</a>
<a name="ln97">#			define IDE6_MAJOR	88</a>
<a name="ln98">#			define IDE7_MAJOR	89</a>
<a name="ln99">#			define IDE8_MAJOR	90</a>
<a name="ln100">#			define IDE9_MAJOR	91</a>
<a name="ln101">#		endif</a>
<a name="ln102">#		define IDE_DISK_MAJOR(M) \</a>
<a name="ln103">				((M) == IDE0_MAJOR || (M) == IDE1_MAJOR || \</a>
<a name="ln104">				(M) == IDE2_MAJOR || (M) == IDE3_MAJOR || \</a>
<a name="ln105">				(M) == IDE4_MAJOR || (M) == IDE5_MAJOR || \</a>
<a name="ln106">				(M) == IDE6_MAJOR || (M) == IDE7_MAJOR || \</a>
<a name="ln107">				(M) == IDE8_MAJOR || (M) == IDE9_MAJOR)</a>
<a name="ln108">#	endif</a>
<a name="ln109">#	ifndef SCSI_DISK_MAJOR</a>
<a name="ln110">#		ifndef SCSI_DISK0_MAJOR</a>
<a name="ln111">#			define SCSI_DISK0_MAJOR	8</a>
<a name="ln112">#			define SCSI_DISK1_MAJOR	65</a>
<a name="ln113">#			define SCSI_DISK7_MAJOR	71</a>
<a name="ln114">#		endif</a>
<a name="ln115">#		define SCSI_DISK_MAJOR(M) \</a>
<a name="ln116">				((M) == SCSI_DISK0_MAJOR || \</a>
<a name="ln117">				((M) &gt;= SCSI_DISK1_MAJOR &amp;&amp; \</a>
<a name="ln118">				(M) &lt;= SCSI_DISK7_MAJOR))</a>
<a name="ln119">#	endif</a>
<a name="ln120">#endif</a>
<a name="ln121"> </a>
<a name="ln122">#include &quot;security.h&quot;</a>
<a name="ln123">#include &quot;types.h&quot;</a>
<a name="ln124">#include &quot;attrib.h&quot;</a>
<a name="ln125">#include &quot;bitmap.h&quot;</a>
<a name="ln126">#include &quot;bootsect.h&quot;</a>
<a name="ln127">#include &quot;device.h&quot;</a>
<a name="ln128">#include &quot;dir.h&quot;</a>
<a name="ln129">#include &quot;mft.h&quot;</a>
<a name="ln130">#include &quot;mst.h&quot;</a>
<a name="ln131">#include &quot;runlist.h&quot;</a>
<a name="ln132">#include &quot;utils.h&quot;</a>
<a name="ln133">#include &quot;ntfstime.h&quot;</a>
<a name="ln134">#include &quot;sd.h&quot;</a>
<a name="ln135">#include &quot;boot.h&quot;</a>
<a name="ln136">#include &quot;attrdef.h&quot;</a>
<a name="ln137">/* #include &quot;version.h&quot; */</a>
<a name="ln138">#include &quot;logging.h&quot;</a>
<a name="ln139">#include &quot;support.h&quot;</a>
<a name="ln140">#include &quot;unistr.h&quot;</a>
<a name="ln141">#include &quot;misc.h&quot;</a>
<a name="ln142"> </a>
<a name="ln143">int	mkntfs_main(const char *devpath, const char *label);</a>
<a name="ln144"> </a>
<a name="ln145">typedef enum { WRITE_STANDARD, WRITE_BITMAP, WRITE_LOGFILE } WRITE_TYPE;</a>
<a name="ln146"> </a>
<a name="ln147">#ifdef NO_NTFS_DEVICE_DEFAULT_IO_OPS</a>
<a name="ln148">#error &quot;No default device io operations!  Cannot build mkntfs.  \</a>
<a name="ln149">You need to run ./configure without the --disable-default-device-io-ops \</a>
<a name="ln150">switch if you want to be able to build the NTFS utilities.&quot;</a>
<a name="ln151">#endif</a>
<a name="ln152"> </a>
<a name="ln153">/* Page size on ia32. Can change to 8192 on Alpha. */</a>
<a name="ln154">#define NTFS_PAGE_SIZE	4096</a>
<a name="ln155"> </a>
<a name="ln156">//static char EXEC_NAME[] = &quot;mkntfs&quot;;</a>
<a name="ln157"> </a>
<a name="ln158">struct BITMAP_ALLOCATION {</a>
<a name="ln159">	struct BITMAP_ALLOCATION *next;</a>
<a name="ln160">	LCN	lcn;		/* first allocated cluster */</a>
<a name="ln161">	s64	length;		/* count of consecutive clusters */</a>
<a name="ln162">} ;</a>
<a name="ln163"> </a>
<a name="ln164">/**</a>
<a name="ln165"> * global variables</a>
<a name="ln166"> */</a>
<a name="ln167">static u8		  *g_buf		  = NULL;</a>
<a name="ln168">static int		   g_mft_bitmap_byte_size = 0;</a>
<a name="ln169">static u8		  *g_mft_bitmap		  = NULL;</a>
<a name="ln170">static int		   g_lcn_bitmap_byte_size = 0;</a>
<a name="ln171">static int		   g_dynamic_buf_size	  = 0;</a>
<a name="ln172">static u8		  *g_dynamic_buf	  = NULL;</a>
<a name="ln173">static runlist		  *g_rl_mft		  = NULL;</a>
<a name="ln174">static runlist		  *g_rl_mft_bmp		  = NULL;</a>
<a name="ln175">static runlist		  *g_rl_mftmirr		  = NULL;</a>
<a name="ln176">static runlist		  *g_rl_logfile		  = NULL;</a>
<a name="ln177">static runlist		  *g_rl_boot		  = NULL;</a>
<a name="ln178">static runlist		  *g_rl_bad		  = NULL;</a>
<a name="ln179">static INDEX_ALLOCATION  *g_index_block	  = NULL;</a>
<a name="ln180">static ntfs_volume	  *g_vol		  = NULL;</a>
<a name="ln181">static int		   g_mft_size		  = 0;</a>
<a name="ln182">static long long	   g_mft_lcn		  = 0;		/* lcn of $MFT, $DATA attribute */</a>
<a name="ln183">static long long	   g_mftmirr_lcn	  = 0;		/* lcn of $MFTMirr, $DATA */</a>
<a name="ln184">static long long	   g_logfile_lcn	  = 0;		/* lcn of $LogFile, $DATA */</a>
<a name="ln185">static int		   g_logfile_size	  = 0;		/* in bytes, determined from volume_size */</a>
<a name="ln186">static long long	   g_mft_zone_end	  = 0;		/* Determined from volume_size and mft_zone_multiplier, in clusters */</a>
<a name="ln187">static long long	   g_num_bad_blocks	  = 0;		/* Number of bad clusters */</a>
<a name="ln188">static long long	  *g_bad_blocks		  = NULL;	/* Array of bad clusters */</a>
<a name="ln189"> </a>
<a name="ln190">static struct BITMAP_ALLOCATION *g_allocation	  = NULL;	/* Head of cluster allocations */</a>
<a name="ln191"> </a>
<a name="ln192">/**</a>
<a name="ln193"> * struct mkntfs_options</a>
<a name="ln194"> */</a>
<a name="ln195">static struct mkntfs_options {</a>
<a name="ln196">	char *dev_name;			/* Name of the device, or file, to use */</a>
<a name="ln197">	BOOL enable_compression;	/* -C, enables compression of all files on the volume by default. */</a>
<a name="ln198">	BOOL quick_format;		/* -f or -Q, fast format, don't zero the volume first. */</a>
<a name="ln199">	BOOL force;			/* -F, force fs creation. */</a>
<a name="ln200">	long heads;			/* -H, number of heads on device */</a>
<a name="ln201">	BOOL disable_indexing;		/* -I, disables indexing of file contents on the volume by default. */</a>
<a name="ln202">	BOOL no_action;			/* -n, do not write to device, only display what would be done. */</a>
<a name="ln203">	long long part_start_sect;	/* -p, start sector of partition on parent device */</a>
<a name="ln204">	long sector_size;		/* -s, in bytes, power of 2, default is 512 bytes. */</a>
<a name="ln205">	long sectors_per_track;		/* -S, number of sectors per track on device */</a>
<a name="ln206">	BOOL use_epoch_time;		/* -T, fake the time to be 00:00:00 UTC, Jan 1, 1970. */</a>
<a name="ln207">	long mft_zone_multiplier;	/* -z, value from 1 to 4. Default is 1. */</a>
<a name="ln208">	long long num_sectors;		/* size of device in sectors */</a>
<a name="ln209">	long cluster_size;		/* -c, format with this cluster-size */</a>
<a name="ln210">	BOOL with_uuid;			/* -U, request setting an uuid */</a>
<a name="ln211">	char *label;			/* -L, volume label */</a>
<a name="ln212">} opts;</a>
<a name="ln213"> </a>
<a name="ln214">/*</a>
<a name="ln215"> *		Mark a run of clusters as allocated</a>
<a name="ln216"> *</a>
<a name="ln217"> *	Returns FALSE if unsuccessful</a>
<a name="ln218"> */</a>
<a name="ln219"> </a>
<a name="ln220">static BOOL bitmap_allocate(LCN lcn, s64 length)</a>
<a name="ln221">{</a>
<a name="ln222">	BOOL done;</a>
<a name="ln223">	struct BITMAP_ALLOCATION *p;</a>
<a name="ln224">	struct BITMAP_ALLOCATION *q;</a>
<a name="ln225">	struct BITMAP_ALLOCATION *newall;</a>
<a name="ln226"> </a>
<a name="ln227">	done = TRUE;</a>
<a name="ln228">	if (length) {</a>
<a name="ln229">		p = g_allocation;</a>
<a name="ln230">		q = (struct BITMAP_ALLOCATION*)NULL;</a>
<a name="ln231">		/* locate the first run which starts beyond the requested lcn */</a>
<a name="ln232">		while (p &amp;&amp; (p-&gt;lcn &lt;= lcn)) {</a>
<a name="ln233">			q = p;</a>
<a name="ln234">			p = p-&gt;next;</a>
<a name="ln235">		}</a>
<a name="ln236">		/* make sure the requested lcns were not allocated */</a>
<a name="ln237">		if ((q &amp;&amp; ((q-&gt;lcn + q-&gt;length) &gt; lcn))</a>
<a name="ln238">		   || (p &amp;&amp; ((lcn + length) &gt; p-&gt;lcn))) {</a>
<a name="ln239">			ntfs_log_error(&quot;Bitmap allocation error\n&quot;);</a>
<a name="ln240">			done = FALSE;</a>
<a name="ln241">		}</a>
<a name="ln242">		if (q &amp;&amp; ((q-&gt;lcn + q-&gt;length) == lcn)) {</a>
<a name="ln243">			/* extend current run, no overlapping possible */</a>
<a name="ln244">			q-&gt;length += length;</a>
<a name="ln245">		} else {</a>
<a name="ln246">			newall = (struct BITMAP_ALLOCATION*)</a>
<a name="ln247">				    ntfs_malloc(sizeof(struct BITMAP_ALLOCATION));</a>
<a name="ln248">			if (newall) {</a>
<a name="ln249">				newall-&gt;lcn = lcn;</a>
<a name="ln250">				newall-&gt;length = length;</a>
<a name="ln251">				newall-&gt;next = p;</a>
<a name="ln252">				if (q) q-&gt;next = newall;</a>
<a name="ln253">				else g_allocation = newall;</a>
<a name="ln254">			} else {</a>
<a name="ln255">				done = FALSE;</a>
<a name="ln256">				ntfs_log_perror(&quot;Not enough memory&quot;);</a>
<a name="ln257">			}</a>
<a name="ln258">		}</a>
<a name="ln259">	}</a>
<a name="ln260">	return (done);</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">/*</a>
<a name="ln264"> *		Mark a run of cluster as not allocated</a>
<a name="ln265"> *</a>
<a name="ln266"> *	Returns FALSE if unsuccessful</a>
<a name="ln267"> *		(freeing free clusters is not considered as an error)</a>
<a name="ln268"> */</a>
<a name="ln269"> </a>
<a name="ln270">static BOOL bitmap_deallocate(LCN lcn, s64 length)</a>
<a name="ln271">{</a>
<a name="ln272">	BOOL done;</a>
<a name="ln273">	struct BITMAP_ALLOCATION *p;</a>
<a name="ln274">	struct BITMAP_ALLOCATION *q;</a>
<a name="ln275">	LCN first, last;</a>
<a name="ln276">	s64 begin_length, end_length;</a>
<a name="ln277"> </a>
<a name="ln278">	done = TRUE;</a>
<a name="ln279">	if (length) {</a>
<a name="ln280">		p = g_allocation;</a>
<a name="ln281">		q = (struct BITMAP_ALLOCATION*)NULL;</a>
<a name="ln282">			/* locate a run which has a common portion */</a>
<a name="ln283">		while (p) {</a>
<a name="ln284">			first = (p-&gt;lcn &gt; lcn ? p-&gt;lcn : lcn);</a>
<a name="ln285">			last = ((p-&gt;lcn + p-&gt;length) &lt; (lcn + length)</a>
<a name="ln286">				? p-&gt;lcn + p-&gt;length : lcn + length);</a>
<a name="ln287">			if (first &lt; last) {</a>
<a name="ln288">					/* get the parts which must be kept */</a>
<a name="ln289">				begin_length = first - p-&gt;lcn;</a>
<a name="ln290">				end_length = p-&gt;lcn + p-&gt;length - last;</a>
<a name="ln291">					/* delete the entry */</a>
<a name="ln292">				if (q)</a>
<a name="ln293">					q-&gt;next = p-&gt;next;</a>
<a name="ln294">				else</a>
<a name="ln295">					g_allocation = p-&gt;next;</a>
<a name="ln296">				free(p);</a>
<a name="ln297">				/* reallocate the beginning and the end */</a>
<a name="ln298">				if (begin_length</a>
<a name="ln299">				    &amp;&amp; !bitmap_allocate(first - begin_length,</a>
<a name="ln300">							begin_length))</a>
<a name="ln301">					done = FALSE;</a>
<a name="ln302">				if (end_length</a>
<a name="ln303">				    &amp;&amp; !bitmap_allocate(last, end_length))</a>
<a name="ln304">					done = FALSE;</a>
<a name="ln305">					/* restart a full search */</a>
<a name="ln306">				p = g_allocation;</a>
<a name="ln307">				q = (struct BITMAP_ALLOCATION*)NULL;</a>
<a name="ln308">			} else {</a>
<a name="ln309">				q = p;</a>
<a name="ln310">				p = p-&gt;next;</a>
<a name="ln311">			}</a>
<a name="ln312">		}</a>
<a name="ln313">	}</a>
<a name="ln314">	return (done);</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">/*</a>
<a name="ln318"> *		Get the allocation status of a single cluster</a>
<a name="ln319"> *	and mark as allocated</a>
<a name="ln320"> *</a>
<a name="ln321"> *	Returns 1 if the cluster was previously allocated</a>
<a name="ln322"> */</a>
<a name="ln323"> </a>
<a name="ln324">static int bitmap_get_and_set(LCN lcn, unsigned long length)</a>
<a name="ln325">{</a>
<a name="ln326">	struct BITMAP_ALLOCATION *p;</a>
<a name="ln327">	struct BITMAP_ALLOCATION *q;</a>
<a name="ln328">	int bit;</a>
<a name="ln329"> </a>
<a name="ln330">	if (length == 1) {</a>
<a name="ln331">		p = g_allocation;</a>
<a name="ln332">		q = (struct BITMAP_ALLOCATION*)NULL;</a>
<a name="ln333">		/* locate the first run which starts beyond the requested lcn */</a>
<a name="ln334">		while (p &amp;&amp; (p-&gt;lcn &lt;= lcn)) {</a>
<a name="ln335">			q = p;</a>
<a name="ln336">			p = p-&gt;next;</a>
<a name="ln337">		}</a>
<a name="ln338">		if (q &amp;&amp; (q-&gt;lcn &lt;= lcn) &amp;&amp; ((q-&gt;lcn + q-&gt;length) &gt; lcn))</a>
<a name="ln339">			bit = 1; /* was allocated */</a>
<a name="ln340">		else {</a>
<a name="ln341">			bitmap_allocate(lcn, length);</a>
<a name="ln342">			bit = 0;</a>
<a name="ln343">		}</a>
<a name="ln344">	} else {</a>
<a name="ln345">		ntfs_log_error(&quot;Can only allocate a single cluster at a time\n&quot;);</a>
<a name="ln346">		bit = 0;</a>
<a name="ln347">	}</a>
<a name="ln348">	return (bit);</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">/*</a>
<a name="ln352"> *		Build a section of the bitmap according to allocation</a>
<a name="ln353"> */</a>
<a name="ln354"> </a>
<a name="ln355">static void bitmap_build(u8 *buf, LCN lcn, s64 length)</a>
<a name="ln356">{</a>
<a name="ln357">	struct BITMAP_ALLOCATION *p;</a>
<a name="ln358">	LCN first, last;</a>
<a name="ln359">	int j; /* byte number */</a>
<a name="ln360">	int bn; /* bit number */</a>
<a name="ln361"> </a>
<a name="ln362">	for (j=0; (8*j)&lt;length; j++)</a>
<a name="ln363">		buf[j] = 0;</a>
<a name="ln364">	for (p=g_allocation; p; p=p-&gt;next) {</a>
<a name="ln365">		first = (p-&gt;lcn &gt; lcn ? p-&gt;lcn : lcn);</a>
<a name="ln366">		last = ((p-&gt;lcn + p-&gt;length) &lt; (lcn + length)</a>
<a name="ln367">			? p-&gt;lcn + p-&gt;length : lcn + length);</a>
<a name="ln368">		if (first &lt; last) {</a>
<a name="ln369">			bn = first - lcn;</a>
<a name="ln370">				/* initial partial byte, if any */</a>
<a name="ln371">			while ((bn &lt; (last - lcn)) &amp;&amp; (bn &amp; 7)) {</a>
<a name="ln372">				buf[bn &gt;&gt; 3] |= 1 &lt;&lt; (bn &amp; 7);</a>
<a name="ln373">				bn++;</a>
<a name="ln374">			}</a>
<a name="ln375">				/* full bytes */</a>
<a name="ln376">			while (bn &lt; (last - lcn - 7)) {</a>
<a name="ln377">				buf[bn &gt;&gt; 3] = 255;</a>
<a name="ln378">				bn += 8;</a>
<a name="ln379">			}</a>
<a name="ln380">				/* final partial byte, if any */</a>
<a name="ln381">			while (bn &lt; (last - lcn)) {</a>
<a name="ln382">				buf[bn &gt;&gt; 3] |= 1 &lt;&lt; (bn &amp; 7);</a>
<a name="ln383">				bn++;</a>
<a name="ln384">			}</a>
<a name="ln385">		}</a>
<a name="ln386">	}</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">/**</a>
<a name="ln390"> * mkntfs_init_options</a>
<a name="ln391"> */</a>
<a name="ln392">static void mkntfs_init_options(struct mkntfs_options *opts2)</a>
<a name="ln393">{</a>
<a name="ln394">	if (!opts2)</a>
<a name="ln395">		return;</a>
<a name="ln396"> </a>
<a name="ln397">	memset(opts2, 0, sizeof(*opts2));</a>
<a name="ln398"> </a>
<a name="ln399">	/* Mark all the numeric options as &quot;unset&quot;. */</a>
<a name="ln400">	opts2-&gt;cluster_size		= -1;</a>
<a name="ln401">	opts2-&gt;heads			= -1;</a>
<a name="ln402">	opts2-&gt;mft_zone_multiplier	= -1;</a>
<a name="ln403">	opts2-&gt;num_sectors		= -1;</a>
<a name="ln404">	opts2-&gt;part_start_sect		= -1;</a>
<a name="ln405">	opts2-&gt;sector_size		= -1;</a>
<a name="ln406">	opts2-&gt;sectors_per_track	= -1;</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">/**</a>
<a name="ln410"> * mkntfs_time</a>
<a name="ln411"> */</a>
<a name="ln412">static ntfs_time mkntfs_time(void)</a>
<a name="ln413">{</a>
<a name="ln414">	struct timespec ts;</a>
<a name="ln415"> </a>
<a name="ln416">	ts.tv_sec = 0;</a>
<a name="ln417">	ts.tv_nsec = 0;</a>
<a name="ln418">	if (!opts.use_epoch_time)</a>
<a name="ln419">		ts.tv_sec = time(NULL);</a>
<a name="ln420">	return timespec2ntfs(ts);</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423">/**</a>
<a name="ln424"> * append_to_bad_blocks</a>
<a name="ln425"> */</a>
<a name="ln426">static BOOL append_to_bad_blocks(unsigned long long block)</a>
<a name="ln427">{</a>
<a name="ln428">	long long *new_buf;</a>
<a name="ln429"> </a>
<a name="ln430">	if (!(g_num_bad_blocks &amp; 15)) {</a>
<a name="ln431">		new_buf = realloc(g_bad_blocks, (g_num_bad_blocks + 16) *</a>
<a name="ln432">							sizeof(long long));</a>
<a name="ln433">		if (!new_buf) {</a>
<a name="ln434">			ntfs_log_perror(&quot;Reallocating memory for bad blocks &quot;</a>
<a name="ln435">				&quot;list failed&quot;);</a>
<a name="ln436">			return FALSE;</a>
<a name="ln437">		}</a>
<a name="ln438">		g_bad_blocks = new_buf;</a>
<a name="ln439">	}</a>
<a name="ln440">	g_bad_blocks[g_num_bad_blocks++] = block;</a>
<a name="ln441">	return TRUE;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">/**</a>
<a name="ln445"> * mkntfs_write</a>
<a name="ln446"> */</a>
<a name="ln447">static long long mkntfs_write(struct ntfs_device *dev,</a>
<a name="ln448">		const void *b, long long count)</a>
<a name="ln449">{</a>
<a name="ln450">	long long bytes_written, total;</a>
<a name="ln451">	int retry;</a>
<a name="ln452"> </a>
<a name="ln453">	if (opts.no_action)</a>
<a name="ln454">		return count;</a>
<a name="ln455">	total = 0LL;</a>
<a name="ln456">	retry = 0;</a>
<a name="ln457">	do {</a>
<a name="ln458">		bytes_written = dev-&gt;d_ops-&gt;write(dev, b, count);</a>
<a name="ln459">		if (bytes_written == -1LL) {</a>
<a name="ln460">			retry = errno;</a>
<a name="ln461">			ntfs_log_perror(&quot;Error writing to %s&quot;, dev-&gt;d_name);</a>
<a name="ln462">			errno = retry;</a>
<a name="ln463">			return bytes_written;</a>
<a name="ln464">		} else if (!bytes_written) {</a>
<a name="ln465">			retry++;</a>
<a name="ln466">		} else {</a>
<a name="ln467">			count -= bytes_written;</a>
<a name="ln468">			total += bytes_written;</a>
<a name="ln469">		}</a>
<a name="ln470">	} while (count &amp;&amp; retry &lt; 3);</a>
<a name="ln471">	if (count)</a>
<a name="ln472">		ntfs_log_error(&quot;Failed to complete writing to %s after three retries.&quot;</a>
<a name="ln473">			&quot;\n&quot;, dev-&gt;d_name);</a>
<a name="ln474">	return total;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">/**</a>
<a name="ln478"> *		Build and write a part of the global bitmap</a>
<a name="ln479"> *	without overflowing from the allocated buffer</a>
<a name="ln480"> *</a>
<a name="ln481"> * mkntfs_bitmap_write</a>
<a name="ln482"> */</a>
<a name="ln483">static s64 mkntfs_bitmap_write(struct ntfs_device *dev,</a>
<a name="ln484">			s64 offset, s64 length)</a>
<a name="ln485">{</a>
<a name="ln486">	s64 partial_length;</a>
<a name="ln487">	s64 written;</a>
<a name="ln488"> </a>
<a name="ln489">	partial_length = length;</a>
<a name="ln490">	if (partial_length &gt; g_dynamic_buf_size)</a>
<a name="ln491">		partial_length = g_dynamic_buf_size;</a>
<a name="ln492">		/* create a partial bitmap section, and write it */</a>
<a name="ln493">	bitmap_build(g_dynamic_buf,offset &lt;&lt; 3,partial_length &lt;&lt; 3);</a>
<a name="ln494">	written = dev-&gt;d_ops-&gt;write(dev, g_dynamic_buf, partial_length);</a>
<a name="ln495">	return (written);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">/**</a>
<a name="ln499"> *		Build and write a part of the log file</a>
<a name="ln500"> *	without overflowing from the allocated buffer</a>
<a name="ln501"> *</a>
<a name="ln502"> * mkntfs_logfile_write</a>
<a name="ln503"> */</a>
<a name="ln504">static s64 mkntfs_logfile_write(struct ntfs_device *dev,</a>
<a name="ln505">			s64 offset __attribute__((unused)), s64 length)</a>
<a name="ln506">{</a>
<a name="ln507">	s64 partial_length;</a>
<a name="ln508">	s64 written;</a>
<a name="ln509"> </a>
<a name="ln510">	partial_length = length;</a>
<a name="ln511">	if (partial_length &gt; g_dynamic_buf_size)</a>
<a name="ln512">		partial_length = g_dynamic_buf_size;</a>
<a name="ln513">		/* create a partial bad cluster section, and write it */</a>
<a name="ln514">	memset(g_dynamic_buf, -1, partial_length);</a>
<a name="ln515">	written = dev-&gt;d_ops-&gt;write(dev, g_dynamic_buf, partial_length);</a>
<a name="ln516">	return (written);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">/**</a>
<a name="ln520"> * ntfs_rlwrite - Write to disk the clusters contained in the runlist @rl</a>
<a name="ln521"> * taking the data from @val.  Take @val_len bytes from @val and pad the</a>
<a name="ln522"> * rest with zeroes.</a>
<a name="ln523"> *</a>
<a name="ln524"> * If the @rl specifies a completely sparse file, @val is allowed to be NULL.</a>
<a name="ln525"> *</a>
<a name="ln526"> * @inited_size if not NULL points to an output variable which will contain</a>
<a name="ln527"> * the actual number of bytes written to disk. I.e. this will not include</a>
<a name="ln528"> * sparse bytes for example.</a>
<a name="ln529"> *</a>
<a name="ln530"> * Return the number of bytes written (minus padding) or -1 on error. Errno</a>
<a name="ln531"> * will be set to the error code.</a>
<a name="ln532"> */</a>
<a name="ln533">static s64 ntfs_rlwrite(struct ntfs_device *dev, const runlist *rl,</a>
<a name="ln534">		const u8 *val, const s64 val_len, s64 *inited_size,</a>
<a name="ln535">		WRITE_TYPE write_type)</a>
<a name="ln536">{</a>
<a name="ln537">	s64 bytes_written, total, length, delta;</a>
<a name="ln538">	int retry, i;</a>
<a name="ln539"> </a>
<a name="ln540">	if (inited_size)</a>
<a name="ln541">		*inited_size = 0LL;</a>
<a name="ln542">	if (opts.no_action)</a>
<a name="ln543">		return val_len;</a>
<a name="ln544">	total = 0LL;</a>
<a name="ln545">	delta = 0LL;</a>
<a name="ln546">	for (i = 0; rl[i].length; i++) {</a>
<a name="ln547">		length = rl[i].length * g_vol-&gt;cluster_size;</a>
<a name="ln548">		/* Don't write sparse runs. */</a>
<a name="ln549">		if (rl[i].lcn == -1) {</a>
<a name="ln550">			total += length;</a>
<a name="ln551">			if (!val)</a>
<a name="ln552">				continue;</a>
<a name="ln553">			/* TODO: Check that *val is really zero at pos and len. */</a>
<a name="ln554">			continue;</a>
<a name="ln555">		}</a>
<a name="ln556">		/*</a>
<a name="ln557">		 * Break up the write into the real data write and then a write</a>
<a name="ln558">		 * of zeroes between the end of the real data and the end of</a>
<a name="ln559">		 * the (last) run.</a>
<a name="ln560">		 */</a>
<a name="ln561">		if (total + length &gt; val_len) {</a>
<a name="ln562">			delta = length;</a>
<a name="ln563">			length = val_len - total;</a>
<a name="ln564">			delta -= length;</a>
<a name="ln565">		}</a>
<a name="ln566">		if (dev-&gt;d_ops-&gt;seek(dev, rl[i].lcn * g_vol-&gt;cluster_size,</a>
<a name="ln567">				SEEK_SET) == (off_t)-1)</a>
<a name="ln568">			return -1LL;</a>
<a name="ln569">		retry = 0;</a>
<a name="ln570">		do {</a>
<a name="ln571">			/* use specific functions if buffer is not prefilled */</a>
<a name="ln572">			switch (write_type) {</a>
<a name="ln573">			case WRITE_BITMAP :</a>
<a name="ln574">				bytes_written = mkntfs_bitmap_write(dev,</a>
<a name="ln575">					total, length);</a>
<a name="ln576">				break;</a>
<a name="ln577">			case WRITE_LOGFILE :</a>
<a name="ln578">				bytes_written = mkntfs_logfile_write(dev,</a>
<a name="ln579">					total, length);</a>
<a name="ln580">				break;</a>
<a name="ln581">			default :</a>
<a name="ln582">				bytes_written = dev-&gt;d_ops-&gt;write(dev,</a>
<a name="ln583">					val + total, length);</a>
<a name="ln584">				break;</a>
<a name="ln585">			}</a>
<a name="ln586">			if (bytes_written == -1LL) {</a>
<a name="ln587">				retry = errno;</a>
<a name="ln588">				ntfs_log_perror(&quot;Error writing to %s&quot;,</a>
<a name="ln589">					dev-&gt;d_name);</a>
<a name="ln590">				errno = retry;</a>
<a name="ln591">				return bytes_written;</a>
<a name="ln592">			}</a>
<a name="ln593">			if (bytes_written) {</a>
<a name="ln594">				length -= bytes_written;</a>
<a name="ln595">				total += bytes_written;</a>
<a name="ln596">				if (inited_size)</a>
<a name="ln597">					*inited_size += bytes_written;</a>
<a name="ln598">			} else {</a>
<a name="ln599">				retry++;</a>
<a name="ln600">			}</a>
<a name="ln601">		} while (length &amp;&amp; retry &lt; 3);</a>
<a name="ln602">		if (length) {</a>
<a name="ln603">			ntfs_log_error(&quot;Failed to complete writing to %s after three &quot;</a>
<a name="ln604">					&quot;retries.\n&quot;, dev-&gt;d_name);</a>
<a name="ln605">			return total;</a>
<a name="ln606">		}</a>
<a name="ln607">	}</a>
<a name="ln608">	if (delta) {</a>
<a name="ln609">		int eo;</a>
<a name="ln610">		char *b = ntfs_calloc(delta);</a>
<a name="ln611">		if (!b)</a>
<a name="ln612">			return -1;</a>
<a name="ln613">		bytes_written = mkntfs_write(dev, b, delta);</a>
<a name="ln614">		eo = errno;</a>
<a name="ln615">		free(b);</a>
<a name="ln616">		errno = eo;</a>
<a name="ln617">		if (bytes_written == -1LL)</a>
<a name="ln618">			return bytes_written;</a>
<a name="ln619">	}</a>
<a name="ln620">	return total;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">/**</a>
<a name="ln624"> * make_room_for_attribute - make room for an attribute inside an mft record</a>
<a name="ln625"> * @m:		mft record</a>
<a name="ln626"> * @pos:	position at which to make space</a>
<a name="ln627"> * @size:	byte size to make available at this position</a>
<a name="ln628"> *</a>
<a name="ln629"> * @pos points to the attribute in front of which we want to make space.</a>
<a name="ln630"> *</a>
<a name="ln631"> * Return 0 on success or -errno on error. Possible error codes are:</a>
<a name="ln632"> *</a>
<a name="ln633"> *	-ENOSPC		There is not enough space available to complete</a>
<a name="ln634"> *			operation. The caller has to make space before calling</a>
<a name="ln635"> *			this.</a>
<a name="ln636"> *	-EINVAL		Can only occur if mkntfs was compiled with -DDEBUG. Means</a>
<a name="ln637"> *			the input parameters were faulty.</a>
<a name="ln638"> */</a>
<a name="ln639">static int make_room_for_attribute(MFT_RECORD *m, char *pos, const u32 size)</a>
<a name="ln640">{</a>
<a name="ln641">	u32 biu;</a>
<a name="ln642"> </a>
<a name="ln643">	if (!size)</a>
<a name="ln644">		return 0;</a>
<a name="ln645">#ifdef DEBUG</a>
<a name="ln646">	/*</a>
<a name="ln647">	 * Rigorous consistency checks. Always return -EINVAL even if more</a>
<a name="ln648">	 * appropriate codes exist for simplicity of parsing the return value.</a>
<a name="ln649">	 */</a>
<a name="ln650">	if (size != ((size + 7) &amp; ~7)) {</a>
<a name="ln651">		ntfs_log_error(&quot;make_room_for_attribute() received non 8-byte aligned &quot;</a>
<a name="ln652">				&quot;size.\n&quot;);</a>
<a name="ln653">		return -EINVAL;</a>
<a name="ln654">	}</a>
<a name="ln655">	if (!m || !pos)</a>
<a name="ln656">		return -EINVAL;</a>
<a name="ln657">	if (pos &lt; (char*)m || pos + size &lt; (char*)m ||</a>
<a name="ln658">			pos &gt; (char*)m + le32_to_cpu(m-&gt;bytes_allocated) ||</a>
<a name="ln659">			pos + size &gt; (char*)m + le32_to_cpu(m-&gt;bytes_allocated))</a>
<a name="ln660">		return -EINVAL;</a>
<a name="ln661">	/* The -8 is for the attribute terminator. */</a>
<a name="ln662">	if (pos - (char*)m &gt; (int)le32_to_cpu(m-&gt;bytes_in_use) - 8)</a>
<a name="ln663">		return -EINVAL;</a>
<a name="ln664">#endif</a>
<a name="ln665">	biu = le32_to_cpu(m-&gt;bytes_in_use);</a>
<a name="ln666">	/* Do we have enough space? */</a>
<a name="ln667">	if (biu + size &gt; le32_to_cpu(m-&gt;bytes_allocated))</a>
<a name="ln668">		return -ENOSPC;</a>
<a name="ln669">	/* Move everything after pos to pos + size. */</a>
<a name="ln670">	memmove(pos + size, pos, biu - (pos - (char*)m));</a>
<a name="ln671">	/* Update mft record. */</a>
<a name="ln672">	m-&gt;bytes_in_use = cpu_to_le32(biu + size);</a>
<a name="ln673">	return 0;</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">/**</a>
<a name="ln677"> * deallocate_scattered_clusters</a>
<a name="ln678"> */</a>
<a name="ln679">static void deallocate_scattered_clusters(const runlist *rl)</a>
<a name="ln680">{</a>
<a name="ln681">	int i;</a>
<a name="ln682"> </a>
<a name="ln683">	if (!rl)</a>
<a name="ln684">		return;</a>
<a name="ln685">	/* Iterate over all runs in the runlist @rl. */</a>
<a name="ln686">	for (i = 0; rl[i].length; i++) {</a>
<a name="ln687">		/* Skip sparse runs. */</a>
<a name="ln688">		if (rl[i].lcn == -1LL)</a>
<a name="ln689">			continue;</a>
<a name="ln690">		/* Deallocate the current run. */</a>
<a name="ln691">		bitmap_deallocate(rl[i].lcn, rl[i].length);</a>
<a name="ln692">	}</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">/**</a>
<a name="ln696"> * allocate_scattered_clusters</a>
<a name="ln697"> * @clusters: Amount of clusters to allocate.</a>
<a name="ln698"> *</a>
<a name="ln699"> * Allocate @clusters and create a runlist of the allocated clusters.</a>
<a name="ln700"> *</a>
<a name="ln701"> * Return the allocated runlist. Caller has to free the runlist when finished</a>
<a name="ln702"> * with it.</a>
<a name="ln703"> *</a>
<a name="ln704"> * On error return NULL and errno is set to the error code.</a>
<a name="ln705"> *</a>
<a name="ln706"> * TODO: We should be returning the size as well, but for mkntfs this is not</a>
<a name="ln707"> * necessary.</a>
<a name="ln708"> */</a>
<a name="ln709">static runlist * allocate_scattered_clusters(s64 clusters)</a>
<a name="ln710">{</a>
<a name="ln711">	runlist *rl = NULL, *rlt;</a>
<a name="ln712">	VCN vcn = 0LL;</a>
<a name="ln713">	LCN lcn, end, prev_lcn = 0LL;</a>
<a name="ln714">	int rlpos = 0;</a>
<a name="ln715">	int rlsize = 0;</a>
<a name="ln716">	s64 prev_run_len = 0LL;</a>
<a name="ln717">	char bit;</a>
<a name="ln718"> </a>
<a name="ln719">	end = g_vol-&gt;nr_clusters;</a>
<a name="ln720">	/* Loop until all clusters are allocated. */</a>
<a name="ln721">	while (clusters) {</a>
<a name="ln722">		/* Loop in current zone until we run out of free clusters. */</a>
<a name="ln723">		for (lcn = g_mft_zone_end; lcn &lt; end; lcn++) {</a>
<a name="ln724">			bit = bitmap_get_and_set(lcn,1);</a>
<a name="ln725">			if (bit)</a>
<a name="ln726">				continue;</a>
<a name="ln727">			/*</a>
<a name="ln728">			 * Reallocate memory if necessary. Make sure we have</a>
<a name="ln729">			 * enough for the terminator entry as well.</a>
<a name="ln730">			 */</a>
<a name="ln731">			if ((rlpos + 2) * (int)sizeof(runlist) &gt;= rlsize) {</a>
<a name="ln732">				rlsize += 4096; /* PAGE_SIZE */</a>
<a name="ln733">				rlt = realloc(rl, rlsize);</a>
<a name="ln734">				if (!rlt)</a>
<a name="ln735">					goto err_end;</a>
<a name="ln736">				rl = rlt;</a>
<a name="ln737">			}</a>
<a name="ln738">			/* Coalesce with previous run if adjacent LCNs. */</a>
<a name="ln739">			if (prev_lcn == lcn - prev_run_len) {</a>
<a name="ln740">				rl[rlpos - 1].length = ++prev_run_len;</a>
<a name="ln741">				vcn++;</a>
<a name="ln742">			} else {</a>
<a name="ln743">				rl[rlpos].vcn = vcn++;</a>
<a name="ln744">				rl[rlpos].lcn = lcn;</a>
<a name="ln745">				prev_lcn = lcn;</a>
<a name="ln746">				rl[rlpos].length = 1LL;</a>
<a name="ln747">				prev_run_len = 1LL;</a>
<a name="ln748">				rlpos++;</a>
<a name="ln749">			}</a>
<a name="ln750">			/* Done? */</a>
<a name="ln751">			if (!--clusters) {</a>
<a name="ln752">				/* Add terminator element and return. */</a>
<a name="ln753">				rl[rlpos].vcn = vcn;</a>
<a name="ln754">				rl[rlpos].lcn = 0LL;</a>
<a name="ln755">				rl[rlpos].length = 0LL;</a>
<a name="ln756">				return rl;</a>
<a name="ln757">			}</a>
<a name="ln758"> </a>
<a name="ln759">		}</a>
<a name="ln760">		/* Switch to next zone, decreasing mft zone by factor 2. */</a>
<a name="ln761">		end = g_mft_zone_end;</a>
<a name="ln762">		g_mft_zone_end &gt;&gt;= 1;</a>
<a name="ln763">		/* Have we run out of space on the volume? */</a>
<a name="ln764">		if (g_mft_zone_end &lt;= 0)</a>
<a name="ln765">			goto err_end;</a>
<a name="ln766">	}</a>
<a name="ln767">	return rl;</a>
<a name="ln768">err_end:</a>
<a name="ln769">	if (rl) {</a>
<a name="ln770">		/* Add terminator element. */</a>
<a name="ln771">		rl[rlpos].vcn = vcn;</a>
<a name="ln772">		rl[rlpos].lcn = -1LL;</a>
<a name="ln773">		rl[rlpos].length = 0LL;</a>
<a name="ln774">		/* Deallocate all allocated clusters. */</a>
<a name="ln775">		deallocate_scattered_clusters(rl);</a>
<a name="ln776">		/* Free the runlist. */</a>
<a name="ln777">		free(rl);</a>
<a name="ln778">	}</a>
<a name="ln779">	return NULL;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">/**</a>
<a name="ln783"> * ntfs_attr_find - find (next) attribute in mft record</a>
<a name="ln784"> * @type:	attribute type to find</a>
<a name="ln785"> * @name:	attribute name to find (optional, i.e. NULL means don't care)</a>
<a name="ln786"> * @name_len:	attribute name length (only needed if @name present)</a>
<a name="ln787"> * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)</a>
<a name="ln788"> * @val:	attribute value to find (optional, resident attributes only)</a>
<a name="ln789"> * @val_len:	attribute value length</a>
<a name="ln790"> * @ctx:	search context with mft record and attribute to search from</a>
<a name="ln791"> *</a>
<a name="ln792"> * You shouldn't need to call this function directly. Use lookup_attr() instead.</a>
<a name="ln793"> *</a>
<a name="ln794"> * ntfs_attr_find() takes a search context @ctx as parameter and searches the</a>
<a name="ln795"> * mft record specified by @ctx-&gt;mrec, beginning at @ctx-&gt;attr, for an</a>
<a name="ln796"> * attribute of @type, optionally @name and @val. If found, ntfs_attr_find()</a>
<a name="ln797"> * returns 0 and @ctx-&gt;attr will point to the found attribute.</a>
<a name="ln798"> *</a>
<a name="ln799"> * If not found, ntfs_attr_find() returns -1, with errno set to ENOENT and</a>
<a name="ln800"> * @ctx-&gt;attr will point to the attribute before which the attribute being</a>
<a name="ln801"> * searched for would need to be inserted if such an action were to be desired.</a>
<a name="ln802"> *</a>
<a name="ln803"> * On actual error, ntfs_attr_find() returns -1 with errno set to the error</a>
<a name="ln804"> * code but not to ENOENT.  In this case @ctx-&gt;attr is undefined and in</a>
<a name="ln805"> * particular do not rely on it not changing.</a>
<a name="ln806"> *</a>
<a name="ln807"> * If @ctx-&gt;is_first is TRUE, the search begins with @ctx-&gt;attr itself. If it</a>
<a name="ln808"> * is FALSE, the search begins after @ctx-&gt;attr.</a>
<a name="ln809"> *</a>
<a name="ln810"> * If @type is AT_UNUSED, return the first found attribute, i.e. one can</a>
<a name="ln811"> * enumerate all attributes by setting @type to AT_UNUSED and then calling</a>
<a name="ln812"> * ntfs_attr_find() repeatedly until it returns -1 with errno set to ENOENT to</a>
<a name="ln813"> * indicate that there are no more entries. During the enumeration, each</a>
<a name="ln814"> * successful call of ntfs_attr_find() will return the next attribute in the</a>
<a name="ln815"> * mft record @ctx-&gt;mrec.</a>
<a name="ln816"> *</a>
<a name="ln817"> * If @type is AT_END, seek to the end and return -1 with errno set to ENOENT.</a>
<a name="ln818"> * AT_END is not a valid attribute, its length is zero for example, thus it is</a>
<a name="ln819"> * safer to return error instead of success in this case. This also allows us</a>
<a name="ln820"> * to interoperate cleanly with ntfs_external_attr_find().</a>
<a name="ln821"> *</a>
<a name="ln822"> * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present</a>
<a name="ln823"> * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,</a>
<a name="ln824"> * match both named and unnamed attributes.</a>
<a name="ln825"> *</a>
<a name="ln826"> * If @ic is IGNORE_CASE, the @name comparison is not case sensitive and</a>
<a name="ln827"> * @ctx-&gt;ntfs_ino must be set to the ntfs inode to which the mft record</a>
<a name="ln828"> * @ctx-&gt;mrec belongs. This is so we can get at the ntfs volume and hence at</a>
<a name="ln829"> * the upcase table. If @ic is CASE_SENSITIVE, the comparison is case</a>
<a name="ln830"> * sensitive. When @name is present, @name_len is the @name length in Unicode</a>
<a name="ln831"> * characters.</a>
<a name="ln832"> *</a>
<a name="ln833"> * If @name is not present (NULL), we assume that the unnamed attribute is</a>
<a name="ln834"> * being searched for.</a>
<a name="ln835"> *</a>
<a name="ln836"> * Finally, the resident attribute value @val is looked for, if present.</a>
<a name="ln837"> * If @val is not present (NULL), @val_len is ignored.</a>
<a name="ln838"> *</a>
<a name="ln839"> * ntfs_attr_find() only searches the specified mft record and it ignores the</a>
<a name="ln840"> * presence of an attribute list attribute (unless it is the one being searched</a>
<a name="ln841"> * for, obviously). If you need to take attribute lists into consideration, use</a>
<a name="ln842"> * ntfs_attr_lookup() instead (see below). This also means that you cannot use</a>
<a name="ln843"> * ntfs_attr_find() to search for extent records of non-resident attributes, as</a>
<a name="ln844"> * extents with lowest_vcn != 0 are usually described by the attribute list</a>
<a name="ln845"> * attribute only. - Note that it is possible that the first extent is only in</a>
<a name="ln846"> * the attribute list while the last extent is in the base mft record, so don't</a>
<a name="ln847"> * rely on being able to find the first extent in the base mft record.</a>
<a name="ln848"> *</a>
<a name="ln849"> * Warning: Never use @val when looking for attribute types which can be</a>
<a name="ln850"> *	    non-resident as this most likely will result in a crash!</a>
<a name="ln851"> */</a>
<a name="ln852">static int mkntfs_attr_find(const ATTR_TYPES type, const ntfschar *name,</a>
<a name="ln853">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln854">		const u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx)</a>
<a name="ln855">{</a>
<a name="ln856">	ATTR_RECORD *a;</a>
<a name="ln857">	ntfschar *upcase = g_vol-&gt;upcase;</a>
<a name="ln858">	u32 upcase_len = g_vol-&gt;upcase_len;</a>
<a name="ln859"> </a>
<a name="ln860">	/*</a>
<a name="ln861">	 * Iterate over attributes in mft record starting at @ctx-&gt;attr, or the</a>
<a name="ln862">	 * attribute following that, if @ctx-&gt;is_first is TRUE.</a>
<a name="ln863">	 */</a>
<a name="ln864">	if (ctx-&gt;is_first) {</a>
<a name="ln865">		a = ctx-&gt;attr;</a>
<a name="ln866">		ctx-&gt;is_first = FALSE;</a>
<a name="ln867">	} else {</a>
<a name="ln868">		a = (ATTR_RECORD*)((char*)ctx-&gt;attr +</a>
<a name="ln869">				le32_to_cpu(ctx-&gt;attr-&gt;length));</a>
<a name="ln870">	}</a>
<a name="ln871">	for (;;	a = (ATTR_RECORD*)((char*)a + le32_to_cpu(a-&gt;length))) {</a>
<a name="ln872">		if (p2n(a) &lt; p2n(ctx-&gt;mrec) || (char*)a &gt; (char*)ctx-&gt;mrec +</a>
<a name="ln873">				le32_to_cpu(ctx-&gt;mrec-&gt;bytes_allocated))</a>
<a name="ln874">			break;</a>
<a name="ln875">		ctx-&gt;attr = a;</a>
<a name="ln876">		if (((type != AT_UNUSED) &amp;&amp; (le32_to_cpu(a-&gt;type) &gt;</a>
<a name="ln877">				le32_to_cpu(type))) ||</a>
<a name="ln878">				(a-&gt;type == AT_END)) {</a>
<a name="ln879">			errno = ENOENT;</a>
<a name="ln880">			return -1;</a>
<a name="ln881">		}</a>
<a name="ln882">		if (!a-&gt;length)</a>
<a name="ln883">			break;</a>
<a name="ln884">		/* If this is an enumeration return this attribute. */</a>
<a name="ln885">		if (type == AT_UNUSED)</a>
<a name="ln886">			return 0;</a>
<a name="ln887">		if (a-&gt;type != type)</a>
<a name="ln888">			continue;</a>
<a name="ln889">		/*</a>
<a name="ln890">		 * If @name is AT_UNNAMED we want an unnamed attribute.</a>
<a name="ln891">		 * If @name is present, compare the two names.</a>
<a name="ln892">		 * Otherwise, match any attribute.</a>
<a name="ln893">		 */</a>
<a name="ln894">		if (name == AT_UNNAMED) {</a>
<a name="ln895">			/* The search failed if the found attribute is named. */</a>
<a name="ln896">			if (a-&gt;name_length) {</a>
<a name="ln897">				errno = ENOENT;</a>
<a name="ln898">				return -1;</a>
<a name="ln899">			}</a>
<a name="ln900">		} else if (name &amp;&amp; !ntfs_names_are_equal(name, name_len,</a>
<a name="ln901">				(ntfschar*)((char*)a + le16_to_cpu(a-&gt;name_offset)),</a>
<a name="ln902">				a-&gt;name_length, ic, upcase, upcase_len)) {</a>
<a name="ln903">			int rc;</a>
<a name="ln904"> </a>
<a name="ln905">			rc = ntfs_names_full_collate(name, name_len,</a>
<a name="ln906">					(ntfschar*)((char*)a +</a>
<a name="ln907">					le16_to_cpu(a-&gt;name_offset)),</a>
<a name="ln908">					a-&gt;name_length, IGNORE_CASE,</a>
<a name="ln909">					upcase, upcase_len);</a>
<a name="ln910">			/*</a>
<a name="ln911">			 * If @name collates before a-&gt;name, there is no</a>
<a name="ln912">			 * matching attribute.</a>
<a name="ln913">			 */</a>
<a name="ln914">			if (rc == -1) {</a>
<a name="ln915">				errno = ENOENT;</a>
<a name="ln916">				return -1;</a>
<a name="ln917">			}</a>
<a name="ln918">			/* If the strings are not equal, continue search. */</a>
<a name="ln919">			if (rc)</a>
<a name="ln920">				continue;</a>
<a name="ln921">			rc = ntfs_names_full_collate(name, name_len,</a>
<a name="ln922">					(ntfschar*)((char*)a +</a>
<a name="ln923">					le16_to_cpu(a-&gt;name_offset)),</a>
<a name="ln924">					a-&gt;name_length, CASE_SENSITIVE,</a>
<a name="ln925">					upcase, upcase_len);</a>
<a name="ln926">			if (rc == -1) {</a>
<a name="ln927">				errno = ENOENT;</a>
<a name="ln928">				return -1;</a>
<a name="ln929">			}</a>
<a name="ln930">			if (rc)</a>
<a name="ln931">				continue;</a>
<a name="ln932">		}</a>
<a name="ln933">		/*</a>
<a name="ln934">		 * The names match or @name not present and attribute is</a>
<a name="ln935">		 * unnamed. If no @val specified, we have found the attribute</a>
<a name="ln936">		 * and are done.</a>
<a name="ln937">		 */</a>
<a name="ln938">		if (!val) {</a>
<a name="ln939">			return 0;</a>
<a name="ln940">		/* @val is present; compare values. */</a>
<a name="ln941">		} else {</a>
<a name="ln942">			int rc;</a>
<a name="ln943"> </a>
<a name="ln944">			rc = memcmp(val, (char*)a +le16_to_cpu(a-&gt;value_offset),</a>
<a name="ln945">					min(val_len,</a>
<a name="ln946">					le32_to_cpu(a-&gt;value_length)));</a>
<a name="ln947">			/*</a>
<a name="ln948">			 * If @val collates before the current attribute's</a>
<a name="ln949">			 * value, there is no matching attribute.</a>
<a name="ln950">			 */</a>
<a name="ln951">			if (!rc) {</a>
<a name="ln952">				u32 avl;</a>
<a name="ln953">				avl = le32_to_cpu(a-&gt;value_length);</a>
<a name="ln954">				if (val_len == avl)</a>
<a name="ln955">					return 0;</a>
<a name="ln956">				if (val_len &lt; avl) {</a>
<a name="ln957">					errno = ENOENT;</a>
<a name="ln958">					return -1;</a>
<a name="ln959">				}</a>
<a name="ln960">			} else if (rc &lt; 0) {</a>
<a name="ln961">				errno = ENOENT;</a>
<a name="ln962">				return -1;</a>
<a name="ln963">			}</a>
<a name="ln964">		}</a>
<a name="ln965">	}</a>
<a name="ln966">	ntfs_log_trace(&quot;File is corrupt. Run chkdsk.\n&quot;);</a>
<a name="ln967">	errno = EIO;</a>
<a name="ln968">	return -1;</a>
<a name="ln969">}</a>
<a name="ln970"> </a>
<a name="ln971">/**</a>
<a name="ln972"> * ntfs_attr_lookup - find an attribute in an ntfs inode</a>
<a name="ln973"> * @type:	attribute type to find</a>
<a name="ln974"> * @name:	attribute name to find (optional, i.e. NULL means don't care)</a>
<a name="ln975"> * @name_len:	attribute name length (only needed if @name present)</a>
<a name="ln976"> * @ic:		IGNORE_CASE or CASE_SENSITIVE (ignored if @name not present)</a>
<a name="ln977"> * @lowest_vcn:	lowest vcn to find (optional, non-resident attributes only)</a>
<a name="ln978"> * @val:	attribute value to find (optional, resident attributes only)</a>
<a name="ln979"> * @val_len:	attribute value length</a>
<a name="ln980"> * @ctx:	search context with mft record and attribute to search from</a>
<a name="ln981"> *</a>
<a name="ln982"> * Find an attribute in an ntfs inode. On first search @ctx-&gt;ntfs_ino must</a>
<a name="ln983"> * be the base mft record and @ctx must have been obtained from a call to</a>
<a name="ln984"> * ntfs_attr_get_search_ctx().</a>
<a name="ln985"> *</a>
<a name="ln986"> * This function transparently handles attribute lists and @ctx is used to</a>
<a name="ln987"> * continue searches where they were left off at.</a>
<a name="ln988"> *</a>
<a name="ln989"> * If @type is AT_UNUSED, return the first found attribute, i.e. one can</a>
<a name="ln990"> * enumerate all attributes by setting @type to AT_UNUSED and then calling</a>
<a name="ln991"> * ntfs_attr_lookup() repeatedly until it returns -1 with errno set to ENOENT</a>
<a name="ln992"> * to indicate that there are no more entries. During the enumeration, each</a>
<a name="ln993"> * successful call of ntfs_attr_lookup() will return the next attribute, with</a>
<a name="ln994"> * the current attribute being described by the search context @ctx.</a>
<a name="ln995"> *</a>
<a name="ln996"> * If @type is AT_END, seek to the end of the base mft record ignoring the</a>
<a name="ln997"> * attribute list completely and return -1 with errno set to ENOENT.  AT_END is</a>
<a name="ln998"> * not a valid attribute, its length is zero for example, thus it is safer to</a>
<a name="ln999"> * return error instead of success in this case.  It should never be needed to</a>
<a name="ln1000"> * do this, but we implement the functionality because it allows for simpler</a>
<a name="ln1001"> * code inside ntfs_external_attr_find().</a>
<a name="ln1002"> *</a>
<a name="ln1003"> * If @name is AT_UNNAMED search for an unnamed attribute. If @name is present</a>
<a name="ln1004"> * but not AT_UNNAMED search for a named attribute matching @name. Otherwise,</a>
<a name="ln1005"> * match both named and unnamed attributes.</a>
<a name="ln1006"> *</a>
<a name="ln1007"> * After finishing with the attribute/mft record you need to call</a>
<a name="ln1008"> * ntfs_attr_put_search_ctx() to cleanup the search context (unmapping any</a>
<a name="ln1009"> * mapped extent inodes, etc).</a>
<a name="ln1010"> *</a>
<a name="ln1011"> * Return 0 if the search was successful and -1 if not, with errno set to the</a>
<a name="ln1012"> * error code.</a>
<a name="ln1013"> *</a>
<a name="ln1014"> * On success, @ctx-&gt;attr is the found attribute, it is in mft record</a>
<a name="ln1015"> * @ctx-&gt;mrec, and @ctx-&gt;al_entry is the attribute list entry for this</a>
<a name="ln1016"> * attribute with @ctx-&gt;base_* being the base mft record to which @ctx-&gt;attr</a>
<a name="ln1017"> * belongs.  If no attribute list attribute is present @ctx-&gt;al_entry and</a>
<a name="ln1018"> * @ctx-&gt;base_* are NULL.</a>
<a name="ln1019"> *</a>
<a name="ln1020"> * On error ENOENT, i.e. attribute not found, @ctx-&gt;attr is set to the</a>
<a name="ln1021"> * attribute which collates just after the attribute being searched for in the</a>
<a name="ln1022"> * base ntfs inode, i.e. if one wants to add the attribute to the mft record</a>
<a name="ln1023"> * this is the correct place to insert it into, and if there is not enough</a>
<a name="ln1024"> * space, the attribute should be placed in an extent mft record.</a>
<a name="ln1025"> * @ctx-&gt;al_entry points to the position within @ctx-&gt;base_ntfs_ino-&gt;attr_list</a>
<a name="ln1026"> * at which the new attribute's attribute list entry should be inserted.  The</a>
<a name="ln1027"> * other @ctx fields, base_ntfs_ino, base_mrec, and base_attr are set to NULL.</a>
<a name="ln1028"> * The only exception to this is when @type is AT_END, in which case</a>
<a name="ln1029"> * @ctx-&gt;al_entry is set to NULL also (see above).</a>
<a name="ln1030"> *</a>
<a name="ln1031"> * The following error codes are defined:</a>
<a name="ln1032"> *	ENOENT	Attribute not found, not an error as such.</a>
<a name="ln1033"> *	EINVAL	Invalid arguments.</a>
<a name="ln1034"> *	EIO	I/O error or corrupt data structures found.</a>
<a name="ln1035"> *	ENOMEM	Not enough memory to allocate necessary buffers.</a>
<a name="ln1036"> */</a>
<a name="ln1037">static int mkntfs_attr_lookup(const ATTR_TYPES type, const ntfschar *name,</a>
<a name="ln1038">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln1039">		const VCN lowest_vcn __attribute__((unused)), const u8 *val,</a>
<a name="ln1040">		const u32 val_len, ntfs_attr_search_ctx *ctx)</a>
<a name="ln1041">{</a>
<a name="ln1042">	ntfs_inode *base_ni;</a>
<a name="ln1043"> </a>
<a name="ln1044">	if (!ctx || !ctx-&gt;mrec || !ctx-&gt;attr) {</a>
<a name="ln1045">		errno = EINVAL;</a>
<a name="ln1046">		return -1;</a>
<a name="ln1047">	}</a>
<a name="ln1048">	if (ctx-&gt;base_ntfs_ino)</a>
<a name="ln1049">		base_ni = ctx-&gt;base_ntfs_ino;</a>
<a name="ln1050">	else</a>
<a name="ln1051">		base_ni = ctx-&gt;ntfs_ino;</a>
<a name="ln1052">	if (!base_ni || !NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)</a>
<a name="ln1053">		return mkntfs_attr_find(type, name, name_len, ic, val, val_len,</a>
<a name="ln1054">				ctx);</a>
<a name="ln1055">	errno = EOPNOTSUPP;</a>
<a name="ln1056">	return -1;</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">/**</a>
<a name="ln1060"> * insert_positioned_attr_in_mft_record</a>
<a name="ln1061"> *</a>
<a name="ln1062"> * Create a non-resident attribute with a predefined on disk location</a>
<a name="ln1063"> * specified by the runlist @rl. The clusters specified by @rl are assumed to</a>
<a name="ln1064"> * be allocated already.</a>
<a name="ln1065"> *</a>
<a name="ln1066"> * Return 0 on success and -errno on error.</a>
<a name="ln1067"> */</a>
<a name="ln1068">static int insert_positioned_attr_in_mft_record(MFT_RECORD *m,</a>
<a name="ln1069">		const ATTR_TYPES type, const char *name, u32 name_len,</a>
<a name="ln1070">		const IGNORE_CASE_BOOL ic, const ATTR_FLAGS flags,</a>
<a name="ln1071">		const runlist *rl, const u8 *val, const s64 val_len)</a>
<a name="ln1072">{</a>
<a name="ln1073">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1074">	ATTR_RECORD *a;</a>
<a name="ln1075">	u16 hdr_size;</a>
<a name="ln1076">	int asize, mpa_size, err, i;</a>
<a name="ln1077">	s64 bw = 0, inited_size;</a>
<a name="ln1078">	VCN highest_vcn;</a>
<a name="ln1079">	ntfschar *uname = NULL;</a>
<a name="ln1080">	int uname_len = 0;</a>
<a name="ln1081">	/*</a>
<a name="ln1082">	if (base record)</a>
<a name="ln1083">		attr_lookup();</a>
<a name="ln1084">	else</a>
<a name="ln1085">	*/</a>
<a name="ln1086"> </a>
<a name="ln1087">	uname = ntfs_str2ucs(name, &amp;uname_len);</a>
<a name="ln1088">	if (!uname)</a>
<a name="ln1089">		return -errno;</a>
<a name="ln1090"> </a>
<a name="ln1091">	/* Check if the attribute is already there. */</a>
<a name="ln1092">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln1093">	if (!ctx) {</a>
<a name="ln1094">		ntfs_log_error(&quot;Failed to allocate attribute search context.\n&quot;);</a>
<a name="ln1095">		err = -ENOMEM;</a>
<a name="ln1096">		goto err_out;</a>
<a name="ln1097">	}</a>
<a name="ln1098">	if (ic == IGNORE_CASE) {</a>
<a name="ln1099">		ntfs_log_error(&quot;FIXME: Hit unimplemented code path #1.\n&quot;);</a>
<a name="ln1100">		err = -EOPNOTSUPP;</a>
<a name="ln1101">		goto err_out;</a>
<a name="ln1102">	}</a>
<a name="ln1103">	if (!mkntfs_attr_lookup(type, uname, uname_len, ic, 0, NULL, 0, ctx)) {</a>
<a name="ln1104">		err = -EEXIST;</a>
<a name="ln1105">		goto err_out;</a>
<a name="ln1106">	}</a>
<a name="ln1107">	if (errno != ENOENT) {</a>
<a name="ln1108">		ntfs_log_error(&quot;Corrupt inode.\n&quot;);</a>
<a name="ln1109">		err = -errno;</a>
<a name="ln1110">		goto err_out;</a>
<a name="ln1111">	}</a>
<a name="ln1112">	a = ctx-&gt;attr;</a>
<a name="ln1113">	if (flags &amp; ATTR_COMPRESSION_MASK) {</a>
<a name="ln1114">		ntfs_log_error(&quot;Compressed attributes not supported yet.\n&quot;);</a>
<a name="ln1115">		/* FIXME: Compress attribute into a temporary buffer, set */</a>
<a name="ln1116">		/* val accordingly and save the compressed size. */</a>
<a name="ln1117">		err = -EOPNOTSUPP;</a>
<a name="ln1118">		goto err_out;</a>
<a name="ln1119">	}</a>
<a name="ln1120">	if (flags &amp; (ATTR_IS_ENCRYPTED | ATTR_IS_SPARSE)) {</a>
<a name="ln1121">		ntfs_log_error(&quot;Encrypted/sparse attributes not supported.\n&quot;);</a>
<a name="ln1122">		err = -EOPNOTSUPP;</a>
<a name="ln1123">		goto err_out;</a>
<a name="ln1124">	}</a>
<a name="ln1125">	if (flags &amp; ATTR_COMPRESSION_MASK) {</a>
<a name="ln1126">		hdr_size = 72;</a>
<a name="ln1127">		/* FIXME: This compression stuff is all wrong. Never mind for */</a>
<a name="ln1128">		/* now. (AIA) */</a>
<a name="ln1129">		if (val_len)</a>
<a name="ln1130">			mpa_size = 0; /* get_size_for_compressed_mapping_pairs(rl); */</a>
<a name="ln1131">		else</a>
<a name="ln1132">			mpa_size = 0;</a>
<a name="ln1133">	} else {</a>
<a name="ln1134">		hdr_size = 64;</a>
<a name="ln1135">		if (val_len) {</a>
<a name="ln1136">			mpa_size = ntfs_get_size_for_mapping_pairs(g_vol, rl, 0, INT_MAX);</a>
<a name="ln1137">			if (mpa_size &lt; 0) {</a>
<a name="ln1138">				err = -errno;</a>
<a name="ln1139">				ntfs_log_error(&quot;Failed to get size for mapping &quot;</a>
<a name="ln1140">						&quot;pairs.\n&quot;);</a>
<a name="ln1141">				goto err_out;</a>
<a name="ln1142">			}</a>
<a name="ln1143">		} else {</a>
<a name="ln1144">			mpa_size = 0;</a>
<a name="ln1145">		}</a>
<a name="ln1146">	}</a>
<a name="ln1147">	/* Mapping pairs array and next attribute must be 8-byte aligned. */</a>
<a name="ln1148">	asize = (((int)hdr_size + ((name_len + 7) &amp; ~7) + mpa_size) + 7) &amp; ~7;</a>
<a name="ln1149">	/* Get the highest vcn. */</a>
<a name="ln1150">	for (i = 0, highest_vcn = 0LL; rl[i].length; i++)</a>
<a name="ln1151">		highest_vcn += rl[i].length;</a>
<a name="ln1152">	/* Does the value fit inside the allocated size? */</a>
<a name="ln1153">	if (highest_vcn * g_vol-&gt;cluster_size &lt; val_len) {</a>
<a name="ln1154">		ntfs_log_error(&quot;BUG: Allocated size is smaller than data size!\n&quot;);</a>
<a name="ln1155">		err = -EINVAL;</a>
<a name="ln1156">		goto err_out;</a>
<a name="ln1157">	}</a>
<a name="ln1158">	err = make_room_for_attribute(m, (char*)a, asize);</a>
<a name="ln1159">	if (err == -ENOSPC) {</a>
<a name="ln1160">		/*</a>
<a name="ln1161">		 * FIXME: Make space! (AIA)</a>
<a name="ln1162">		 * can we make it non-resident? if yes, do that.</a>
<a name="ln1163">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1164">		 * m's $DATA or $BITMAP+$INDEX_ALLOCATION resident?</a>
<a name="ln1165">		 * yes -&gt; make non-resident</a>
<a name="ln1166">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1167">		 * make all attributes non-resident</a>
<a name="ln1168">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1169">		 * m is a base record? yes -&gt; allocate extension record</a>
<a name="ln1170">		 *	does the new attribute fit in there? yes -&gt; do it.</a>
<a name="ln1171">		 * split up runlist into extents and place each in an extension</a>
<a name="ln1172">		 * record.</a>
<a name="ln1173">		 * FIXME: the check for needing extension records should be</a>
<a name="ln1174">		 * earlier on as it is very quick: asize &gt; m-&gt;bytes_allocated?</a>
<a name="ln1175">		 */</a>
<a name="ln1176">		err = -EOPNOTSUPP;</a>
<a name="ln1177">		goto err_out;</a>
<a name="ln1178">#ifdef DEBUG</a>
<a name="ln1179">	} else if (err == -EINVAL) {</a>
<a name="ln1180">		ntfs_log_error(&quot;BUG(): in insert_positioned_attribute_in_mft_&quot;</a>
<a name="ln1181">				&quot;record(): make_room_for_attribute() returned &quot;</a>
<a name="ln1182">				&quot;error: EINVAL!\n&quot;);</a>
<a name="ln1183">		goto err_out;</a>
<a name="ln1184">#endif</a>
<a name="ln1185">	}</a>
<a name="ln1186">	a-&gt;type = type;</a>
<a name="ln1187">	a-&gt;length = cpu_to_le32(asize);</a>
<a name="ln1188">	a-&gt;non_resident = 1;</a>
<a name="ln1189">	a-&gt;name_length = name_len;</a>
<a name="ln1190">	a-&gt;name_offset = cpu_to_le16(hdr_size);</a>
<a name="ln1191">	a-&gt;flags = flags;</a>
<a name="ln1192">	a-&gt;instance = m-&gt;next_attr_instance;</a>
<a name="ln1193">	m-&gt;next_attr_instance = cpu_to_le16((le16_to_cpu(m-&gt;next_attr_instance)</a>
<a name="ln1194">			+ 1) &amp; 0xffff);</a>
<a name="ln1195">	a-&gt;lowest_vcn = cpu_to_le64(0);</a>
<a name="ln1196">	a-&gt;highest_vcn = cpu_to_sle64(highest_vcn - 1LL);</a>
<a name="ln1197">	a-&gt;mapping_pairs_offset = cpu_to_le16(hdr_size + ((name_len + 7) &amp; ~7));</a>
<a name="ln1198">	memset(a-&gt;reserved1, 0, sizeof(a-&gt;reserved1));</a>
<a name="ln1199">	/* FIXME: Allocated size depends on compression. */</a>
<a name="ln1200">	a-&gt;allocated_size = cpu_to_sle64(highest_vcn * g_vol-&gt;cluster_size);</a>
<a name="ln1201">	a-&gt;data_size = cpu_to_sle64(val_len);</a>
<a name="ln1202">	if (name_len)</a>
<a name="ln1203">		memcpy((char*)a + hdr_size, uname, name_len &lt;&lt; 1);</a>
<a name="ln1204">	if (flags &amp; ATTR_COMPRESSION_MASK) {</a>
<a name="ln1205">		if (flags &amp; ATTR_COMPRESSION_MASK &amp; ~ATTR_IS_COMPRESSED) {</a>
<a name="ln1206">			ntfs_log_error(&quot;Unknown compression format. Reverting &quot;</a>
<a name="ln1207">					&quot;to standard compression.\n&quot;);</a>
<a name="ln1208">			a-&gt;flags &amp;= ~ATTR_COMPRESSION_MASK;</a>
<a name="ln1209">			a-&gt;flags |= ATTR_IS_COMPRESSED;</a>
<a name="ln1210">		}</a>
<a name="ln1211">		a-&gt;compression_unit = 4;</a>
<a name="ln1212">		inited_size = val_len;</a>
<a name="ln1213">		/* FIXME: Set the compressed size. */</a>
<a name="ln1214">		a-&gt;compressed_size = cpu_to_le64(0);</a>
<a name="ln1215">		/* FIXME: Write out the compressed data. */</a>
<a name="ln1216">		/* FIXME: err = build_mapping_pairs_compressed(); */</a>
<a name="ln1217">		err = -EOPNOTSUPP;</a>
<a name="ln1218">	} else {</a>
<a name="ln1219">		a-&gt;compression_unit = 0;</a>
<a name="ln1220">		if ((type == AT_DATA)</a>
<a name="ln1221">		    &amp;&amp; (m-&gt;mft_record_number</a>
<a name="ln1222">				 == const_cpu_to_le32(FILE_LogFile)))</a>
<a name="ln1223">			bw = ntfs_rlwrite(g_vol-&gt;dev, rl, val, val_len,</a>
<a name="ln1224">					&amp;inited_size, WRITE_LOGFILE);</a>
<a name="ln1225">		else</a>
<a name="ln1226">			bw = ntfs_rlwrite(g_vol-&gt;dev, rl, val, val_len,</a>
<a name="ln1227">					&amp;inited_size, WRITE_STANDARD);</a>
<a name="ln1228">		if (bw != val_len) {</a>
<a name="ln1229">			ntfs_log_error(&quot;Error writing non-resident attribute &quot;</a>
<a name="ln1230">					&quot;value.\n&quot;);</a>
<a name="ln1231">			return -errno;</a>
<a name="ln1232">		}</a>
<a name="ln1233">		err = ntfs_mapping_pairs_build(g_vol, (u8*)a + hdr_size +</a>
<a name="ln1234">				((name_len + 7) &amp; ~7), mpa_size, rl, 0, NULL);</a>
<a name="ln1235">	}</a>
<a name="ln1236">	a-&gt;initialized_size = cpu_to_sle64(inited_size);</a>
<a name="ln1237">	if (err &lt; 0 || bw != val_len) {</a>
<a name="ln1238">		/* FIXME: Handle error. */</a>
<a name="ln1239">		/* deallocate clusters */</a>
<a name="ln1240">		/* remove attribute */</a>
<a name="ln1241">		if (err &gt;= 0)</a>
<a name="ln1242">			err = -EIO;</a>
<a name="ln1243">		ntfs_log_error(&quot;insert_positioned_attr_in_mft_record failed &quot;</a>
<a name="ln1244">				&quot;with error %i.\n&quot;, err &lt; 0 ? err : (int)bw);</a>
<a name="ln1245">	}</a>
<a name="ln1246">err_out:</a>
<a name="ln1247">	if (ctx)</a>
<a name="ln1248">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1249">	ntfs_ucsfree(uname);</a>
<a name="ln1250">	return err;</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253">/**</a>
<a name="ln1254"> * insert_non_resident_attr_in_mft_record</a>
<a name="ln1255"> *</a>
<a name="ln1256"> * Return 0 on success and -errno on error.</a>
<a name="ln1257"> */</a>
<a name="ln1258">static int insert_non_resident_attr_in_mft_record(MFT_RECORD *m,</a>
<a name="ln1259">		const ATTR_TYPES type, const char *name, u32 name_len,</a>
<a name="ln1260">		const IGNORE_CASE_BOOL ic, const ATTR_FLAGS flags,</a>
<a name="ln1261">		const u8 *val, const s64 val_len,</a>
<a name="ln1262">		WRITE_TYPE write_type)</a>
<a name="ln1263">{</a>
<a name="ln1264">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1265">	ATTR_RECORD *a;</a>
<a name="ln1266">	u16 hdr_size;</a>
<a name="ln1267">	int asize, mpa_size, err, i;</a>
<a name="ln1268">	runlist *rl = NULL;</a>
<a name="ln1269">	s64 bw = 0;</a>
<a name="ln1270">	ntfschar *uname = NULL;</a>
<a name="ln1271">	int uname_len = 0;</a>
<a name="ln1272">	/*</a>
<a name="ln1273">	if (base record)</a>
<a name="ln1274">		attr_lookup();</a>
<a name="ln1275">	else</a>
<a name="ln1276">	*/</a>
<a name="ln1277"> </a>
<a name="ln1278">	uname = ntfs_str2ucs(name, &amp;uname_len);</a>
<a name="ln1279">	if (!uname)</a>
<a name="ln1280">		return -errno;</a>
<a name="ln1281"> </a>
<a name="ln1282">	/* Check if the attribute is already there. */</a>
<a name="ln1283">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln1284">	if (!ctx) {</a>
<a name="ln1285">		ntfs_log_error(&quot;Failed to allocate attribute search context.\n&quot;);</a>
<a name="ln1286">		err = -ENOMEM;</a>
<a name="ln1287">		goto err_out;</a>
<a name="ln1288">	}</a>
<a name="ln1289">	if (ic == IGNORE_CASE) {</a>
<a name="ln1290">		ntfs_log_error(&quot;FIXME: Hit unimplemented code path #2.\n&quot;);</a>
<a name="ln1291">		err = -EOPNOTSUPP;</a>
<a name="ln1292">		goto err_out;</a>
<a name="ln1293">	}</a>
<a name="ln1294">	if (!mkntfs_attr_lookup(type, uname, uname_len, ic, 0, NULL, 0, ctx)) {</a>
<a name="ln1295">		err = -EEXIST;</a>
<a name="ln1296">		goto err_out;</a>
<a name="ln1297">	}</a>
<a name="ln1298">	if (errno != ENOENT) {</a>
<a name="ln1299">		ntfs_log_error(&quot;Corrupt inode.\n&quot;);</a>
<a name="ln1300">		err = -errno;</a>
<a name="ln1301">		goto err_out;</a>
<a name="ln1302">	}</a>
<a name="ln1303">	a = ctx-&gt;attr;</a>
<a name="ln1304">	if (flags &amp; ATTR_COMPRESSION_MASK) {</a>
<a name="ln1305">		ntfs_log_error(&quot;Compressed attributes not supported yet.\n&quot;);</a>
<a name="ln1306">		/* FIXME: Compress attribute into a temporary buffer, set */</a>
<a name="ln1307">		/* val accordingly and save the compressed size. */</a>
<a name="ln1308">		err = -EOPNOTSUPP;</a>
<a name="ln1309">		goto err_out;</a>
<a name="ln1310">	}</a>
<a name="ln1311">	if (flags &amp; (ATTR_IS_ENCRYPTED | ATTR_IS_SPARSE)) {</a>
<a name="ln1312">		ntfs_log_error(&quot;Encrypted/sparse attributes not supported.\n&quot;);</a>
<a name="ln1313">		err = -EOPNOTSUPP;</a>
<a name="ln1314">		goto err_out;</a>
<a name="ln1315">	}</a>
<a name="ln1316">	if (val_len) {</a>
<a name="ln1317">		rl = allocate_scattered_clusters((val_len +</a>
<a name="ln1318">				g_vol-&gt;cluster_size - 1) / g_vol-&gt;cluster_size);</a>
<a name="ln1319">		if (!rl) {</a>
<a name="ln1320">			err = -errno;</a>
<a name="ln1321">			ntfs_log_perror(&quot;Failed to allocate scattered clusters&quot;);</a>
<a name="ln1322">			goto err_out;</a>
<a name="ln1323">		}</a>
<a name="ln1324">	} else {</a>
<a name="ln1325">		rl = NULL;</a>
<a name="ln1326">	}</a>
<a name="ln1327">	if (flags &amp; ATTR_COMPRESSION_MASK) {</a>
<a name="ln1328">		hdr_size = 72;</a>
<a name="ln1329">		/* FIXME: This compression stuff is all wrong. Never mind for */</a>
<a name="ln1330">		/* now. (AIA) */</a>
<a name="ln1331">		if (val_len)</a>
<a name="ln1332">			mpa_size = 0; /* get_size_for_compressed_mapping_pairs(rl); */</a>
<a name="ln1333">		else</a>
<a name="ln1334">			mpa_size = 0;</a>
<a name="ln1335">	} else {</a>
<a name="ln1336">		hdr_size = 64;</a>
<a name="ln1337">		if (val_len) {</a>
<a name="ln1338">			mpa_size = ntfs_get_size_for_mapping_pairs(g_vol, rl, 0, INT_MAX);</a>
<a name="ln1339">			if (mpa_size &lt; 0) {</a>
<a name="ln1340">				err = -errno;</a>
<a name="ln1341">				ntfs_log_error(&quot;Failed to get size for mapping &quot;</a>
<a name="ln1342">						&quot;pairs.\n&quot;);</a>
<a name="ln1343">				goto err_out;</a>
<a name="ln1344">			}</a>
<a name="ln1345">		} else {</a>
<a name="ln1346">			mpa_size = 0;</a>
<a name="ln1347">		}</a>
<a name="ln1348">	}</a>
<a name="ln1349">	/* Mapping pairs array and next attribute must be 8-byte aligned. */</a>
<a name="ln1350">	asize = (((int)hdr_size + ((name_len + 7) &amp; ~7) + mpa_size) + 7) &amp; ~7;</a>
<a name="ln1351">	err = make_room_for_attribute(m, (char*)a, asize);</a>
<a name="ln1352">	if (err == -ENOSPC) {</a>
<a name="ln1353">		/*</a>
<a name="ln1354">		 * FIXME: Make space! (AIA)</a>
<a name="ln1355">		 * can we make it non-resident? if yes, do that.</a>
<a name="ln1356">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1357">		 * m's $DATA or $BITMAP+$INDEX_ALLOCATION resident?</a>
<a name="ln1358">		 * yes -&gt; make non-resident</a>
<a name="ln1359">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1360">		 * make all attributes non-resident</a>
<a name="ln1361">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1362">		 * m is a base record? yes -&gt; allocate extension record</a>
<a name="ln1363">		 *	does the new attribute fit in there? yes -&gt; do it.</a>
<a name="ln1364">		 * split up runlist into extents and place each in an extension</a>
<a name="ln1365">		 * record.</a>
<a name="ln1366">		 * FIXME: the check for needing extension records should be</a>
<a name="ln1367">		 * earlier on as it is very quick: asize &gt; m-&gt;bytes_allocated?</a>
<a name="ln1368">		 */</a>
<a name="ln1369">		err = -EOPNOTSUPP;</a>
<a name="ln1370">		goto err_out;</a>
<a name="ln1371">#ifdef DEBUG</a>
<a name="ln1372">	} else if (err == -EINVAL) {</a>
<a name="ln1373">		ntfs_log_error(&quot;BUG(): in insert_non_resident_attribute_in_&quot;</a>
<a name="ln1374">				&quot;mft_record(): make_room_for_attribute() &quot;</a>
<a name="ln1375">				&quot;returned error: EINVAL!\n&quot;);</a>
<a name="ln1376">		goto err_out;</a>
<a name="ln1377">#endif</a>
<a name="ln1378">	}</a>
<a name="ln1379">	a-&gt;type = type;</a>
<a name="ln1380">	a-&gt;length = cpu_to_le32(asize);</a>
<a name="ln1381">	a-&gt;non_resident = 1;</a>
<a name="ln1382">	a-&gt;name_length = name_len;</a>
<a name="ln1383">	a-&gt;name_offset = cpu_to_le16(hdr_size);</a>
<a name="ln1384">	a-&gt;flags = flags;</a>
<a name="ln1385">	a-&gt;instance = m-&gt;next_attr_instance;</a>
<a name="ln1386">	m-&gt;next_attr_instance = cpu_to_le16((le16_to_cpu(m-&gt;next_attr_instance)</a>
<a name="ln1387">			+ 1) &amp; 0xffff);</a>
<a name="ln1388">	a-&gt;lowest_vcn = cpu_to_le64(0);</a>
<a name="ln1389">	for (i = 0; rl[i].length; i++)</a>
<a name="ln1390">		;</a>
<a name="ln1391">	a-&gt;highest_vcn = cpu_to_sle64(rl[i].vcn - 1);</a>
<a name="ln1392">	a-&gt;mapping_pairs_offset = cpu_to_le16(hdr_size + ((name_len + 7) &amp; ~7));</a>
<a name="ln1393">	memset(a-&gt;reserved1, 0, sizeof(a-&gt;reserved1));</a>
<a name="ln1394">	/* FIXME: Allocated size depends on compression. */</a>
<a name="ln1395">	a-&gt;allocated_size = cpu_to_sle64((val_len + (g_vol-&gt;cluster_size - 1)) &amp;</a>
<a name="ln1396">			~(g_vol-&gt;cluster_size - 1));</a>
<a name="ln1397">	a-&gt;data_size = cpu_to_sle64(val_len);</a>
<a name="ln1398">	a-&gt;initialized_size = cpu_to_sle64(val_len);</a>
<a name="ln1399">	if (name_len)</a>
<a name="ln1400">		memcpy((char*)a + hdr_size, uname, name_len &lt;&lt; 1);</a>
<a name="ln1401">	if (flags &amp; ATTR_COMPRESSION_MASK) {</a>
<a name="ln1402">		if (flags &amp; ATTR_COMPRESSION_MASK &amp; ~ATTR_IS_COMPRESSED) {</a>
<a name="ln1403">			ntfs_log_error(&quot;Unknown compression format. Reverting &quot;</a>
<a name="ln1404">					&quot;to standard compression.\n&quot;);</a>
<a name="ln1405">			a-&gt;flags &amp;= ~ATTR_COMPRESSION_MASK;</a>
<a name="ln1406">			a-&gt;flags |= ATTR_IS_COMPRESSED;</a>
<a name="ln1407">		}</a>
<a name="ln1408">		a-&gt;compression_unit = 4;</a>
<a name="ln1409">		/* FIXME: Set the compressed size. */</a>
<a name="ln1410">		a-&gt;compressed_size = cpu_to_le64(0);</a>
<a name="ln1411">		/* FIXME: Write out the compressed data. */</a>
<a name="ln1412">		/* FIXME: err = build_mapping_pairs_compressed(); */</a>
<a name="ln1413">		err = -EOPNOTSUPP;</a>
<a name="ln1414">	} else {</a>
<a name="ln1415">		a-&gt;compression_unit = 0;</a>
<a name="ln1416">		bw = ntfs_rlwrite(g_vol-&gt;dev, rl, val, val_len, NULL,</a>
<a name="ln1417">					write_type);</a>
<a name="ln1418">		if (bw != val_len) {</a>
<a name="ln1419">			ntfs_log_error(&quot;Error writing non-resident attribute &quot;</a>
<a name="ln1420">					&quot;value.\n&quot;);</a>
<a name="ln1421">			return -errno;</a>
<a name="ln1422">		}</a>
<a name="ln1423">		err = ntfs_mapping_pairs_build(g_vol, (u8*)a + hdr_size +</a>
<a name="ln1424">				((name_len + 7) &amp; ~7), mpa_size, rl, 0, NULL);</a>
<a name="ln1425">	}</a>
<a name="ln1426">	if (err &lt; 0 || bw != val_len) {</a>
<a name="ln1427">		/* FIXME: Handle error. */</a>
<a name="ln1428">		/* deallocate clusters */</a>
<a name="ln1429">		/* remove attribute */</a>
<a name="ln1430">		if (err &gt;= 0)</a>
<a name="ln1431">			err = -EIO;</a>
<a name="ln1432">		ntfs_log_error(&quot;insert_non_resident_attr_in_mft_record failed with &quot;</a>
<a name="ln1433">			&quot;error %lld.\n&quot;, (long long) (err &lt; 0 ? err : bw));</a>
<a name="ln1434">	}</a>
<a name="ln1435">err_out:</a>
<a name="ln1436">	if (ctx)</a>
<a name="ln1437">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1438">	ntfs_ucsfree(uname);</a>
<a name="ln1439">	free(rl);</a>
<a name="ln1440">	return err;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">/**</a>
<a name="ln1444"> * insert_resident_attr_in_mft_record</a>
<a name="ln1445"> *</a>
<a name="ln1446"> * Return 0 on success and -errno on error.</a>
<a name="ln1447"> */</a>
<a name="ln1448">static int insert_resident_attr_in_mft_record(MFT_RECORD *m,</a>
<a name="ln1449">		const ATTR_TYPES type, const char *name, u32 name_len,</a>
<a name="ln1450">		const IGNORE_CASE_BOOL ic, const ATTR_FLAGS flags,</a>
<a name="ln1451">		const RESIDENT_ATTR_FLAGS res_flags,</a>
<a name="ln1452">		const u8 *val, const u32 val_len)</a>
<a name="ln1453">{</a>
<a name="ln1454">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1455">	ATTR_RECORD *a;</a>
<a name="ln1456">	int asize, err;</a>
<a name="ln1457">	ntfschar *uname = NULL;</a>
<a name="ln1458">	int uname_len = 0;</a>
<a name="ln1459">	/*</a>
<a name="ln1460">	if (base record)</a>
<a name="ln1461">		mkntfs_attr_lookup();</a>
<a name="ln1462">	else</a>
<a name="ln1463">	*/</a>
<a name="ln1464"> </a>
<a name="ln1465">	uname = ntfs_str2ucs(name, &amp;uname_len);</a>
<a name="ln1466">	if (!uname)</a>
<a name="ln1467">		return -errno;</a>
<a name="ln1468"> </a>
<a name="ln1469">	/* Check if the attribute is already there. */</a>
<a name="ln1470">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln1471">	if (!ctx) {</a>
<a name="ln1472">		ntfs_log_error(&quot;Failed to allocate attribute search context.\n&quot;);</a>
<a name="ln1473">		err = -ENOMEM;</a>
<a name="ln1474">		goto err_out;</a>
<a name="ln1475">	}</a>
<a name="ln1476">	if (ic == IGNORE_CASE) {</a>
<a name="ln1477">		ntfs_log_error(&quot;FIXME: Hit unimplemented code path #3.\n&quot;);</a>
<a name="ln1478">		err = -EOPNOTSUPP;</a>
<a name="ln1479">		goto err_out;</a>
<a name="ln1480">	}</a>
<a name="ln1481">	if (!mkntfs_attr_lookup(type, uname, uname_len, ic, 0, val, val_len,</a>
<a name="ln1482">			ctx)) {</a>
<a name="ln1483">		err = -EEXIST;</a>
<a name="ln1484">		goto err_out;</a>
<a name="ln1485">	}</a>
<a name="ln1486">	if (errno != ENOENT) {</a>
<a name="ln1487">		ntfs_log_error(&quot;Corrupt inode.\n&quot;);</a>
<a name="ln1488">		err = -errno;</a>
<a name="ln1489">		goto err_out;</a>
<a name="ln1490">	}</a>
<a name="ln1491">	a = ctx-&gt;attr;</a>
<a name="ln1492">	/* sizeof(resident attribute record header) == 24 */</a>
<a name="ln1493">	asize = ((24 + ((name_len + 7) &amp; ~7) + val_len) + 7) &amp; ~7;</a>
<a name="ln1494">	err = make_room_for_attribute(m, (char*)a, asize);</a>
<a name="ln1495">	if (err == -ENOSPC) {</a>
<a name="ln1496">		/*</a>
<a name="ln1497">		 * FIXME: Make space! (AIA)</a>
<a name="ln1498">		 * can we make it non-resident? if yes, do that.</a>
<a name="ln1499">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1500">		 * m's $DATA or $BITMAP+$INDEX_ALLOCATION resident?</a>
<a name="ln1501">		 * yes -&gt; make non-resident</a>
<a name="ln1502">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1503">		 * make all attributes non-resident</a>
<a name="ln1504">		 *	does it fit now? yes -&gt; do it.</a>
<a name="ln1505">		 * m is a base record? yes -&gt; allocate extension record</a>
<a name="ln1506">		 *	does the new attribute fit in there? yes -&gt; do it.</a>
<a name="ln1507">		 * split up runlist into extents and place each in an extension</a>
<a name="ln1508">		 * record.</a>
<a name="ln1509">		 * FIXME: the check for needing extension records should be</a>
<a name="ln1510">		 * earlier on as it is very quick: asize &gt; m-&gt;bytes_allocated?</a>
<a name="ln1511">		 */</a>
<a name="ln1512">		err = -EOPNOTSUPP;</a>
<a name="ln1513">		goto err_out;</a>
<a name="ln1514">	}</a>
<a name="ln1515">#ifdef DEBUG</a>
<a name="ln1516">	if (err == -EINVAL) {</a>
<a name="ln1517">		ntfs_log_error(&quot;BUG(): in insert_resident_attribute_in_mft_&quot;</a>
<a name="ln1518">				&quot;record(): make_room_for_attribute() returned &quot;</a>
<a name="ln1519">				&quot;error: EINVAL!\n&quot;);</a>
<a name="ln1520">		goto err_out;</a>
<a name="ln1521">	}</a>
<a name="ln1522">#endif</a>
<a name="ln1523">	a-&gt;type = type;</a>
<a name="ln1524">	a-&gt;length = cpu_to_le32(asize);</a>
<a name="ln1525">	a-&gt;non_resident = 0;</a>
<a name="ln1526">	a-&gt;name_length = name_len;</a>
<a name="ln1527">	if (type == AT_OBJECT_ID)</a>
<a name="ln1528">		a-&gt;name_offset = const_cpu_to_le16(0);</a>
<a name="ln1529">	else</a>
<a name="ln1530">		a-&gt;name_offset = const_cpu_to_le16(24);</a>
<a name="ln1531">	a-&gt;flags = flags;</a>
<a name="ln1532">	a-&gt;instance = m-&gt;next_attr_instance;</a>
<a name="ln1533">	m-&gt;next_attr_instance = cpu_to_le16((le16_to_cpu(m-&gt;next_attr_instance)</a>
<a name="ln1534">			+ 1) &amp; 0xffff);</a>
<a name="ln1535">	a-&gt;value_length = cpu_to_le32(val_len);</a>
<a name="ln1536">	a-&gt;value_offset = cpu_to_le16(24 + ((name_len + 7) &amp; ~7));</a>
<a name="ln1537">	a-&gt;resident_flags = res_flags;</a>
<a name="ln1538">	a-&gt;reservedR = 0;</a>
<a name="ln1539">	if (name_len)</a>
<a name="ln1540">		memcpy((char*)a + 24, uname, name_len &lt;&lt; 1);</a>
<a name="ln1541">	if (val_len)</a>
<a name="ln1542">		memcpy((char*)a + le16_to_cpu(a-&gt;value_offset), val, val_len);</a>
<a name="ln1543">err_out:</a>
<a name="ln1544">	if (ctx)</a>
<a name="ln1545">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1546">	ntfs_ucsfree(uname);</a>
<a name="ln1547">	return err;</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>
<a name="ln1550"> </a>
<a name="ln1551">/**</a>
<a name="ln1552"> * add_attr_std_info</a>
<a name="ln1553"> *</a>
<a name="ln1554"> * Return 0 on success or -errno on error.</a>
<a name="ln1555"> */</a>
<a name="ln1556">static int add_attr_std_info(MFT_RECORD *m, const FILE_ATTR_FLAGS flags,</a>
<a name="ln1557">		le32 security_id)</a>
<a name="ln1558">{</a>
<a name="ln1559">	STANDARD_INFORMATION si;</a>
<a name="ln1560">	int err, sd_size;</a>
<a name="ln1561"> </a>
<a name="ln1562">	sd_size = 48;</a>
<a name="ln1563"> </a>
<a name="ln1564">	si.creation_time = mkntfs_time();</a>
<a name="ln1565">	si.last_data_change_time = si.creation_time;</a>
<a name="ln1566">	si.last_mft_change_time = si.creation_time;</a>
<a name="ln1567">	si.last_access_time = si.creation_time;</a>
<a name="ln1568">	si.file_attributes = flags; /* already LE */</a>
<a name="ln1569">	si.maximum_versions = cpu_to_le32(0);</a>
<a name="ln1570">	si.version_number = cpu_to_le32(0);</a>
<a name="ln1571">	si.class_id = cpu_to_le32(0);</a>
<a name="ln1572">	si.security_id = security_id;</a>
<a name="ln1573">	if (si.security_id != const_cpu_to_le32(0))</a>
<a name="ln1574">		sd_size = 72;</a>
<a name="ln1575">	/* FIXME: $Quota support... */</a>
<a name="ln1576">	si.owner_id = cpu_to_le32(0);</a>
<a name="ln1577">	si.quota_charged = cpu_to_le64(0ULL);</a>
<a name="ln1578">	/* FIXME: $UsnJrnl support... Not needed on fresh w2k3-volume */</a>
<a name="ln1579">	si.usn = cpu_to_le64(0ULL);</a>
<a name="ln1580">	/* NTFS 1.2: size of si = 48, NTFS 3.[01]: size of si = 72 */</a>
<a name="ln1581">	err = insert_resident_attr_in_mft_record(m, AT_STANDARD_INFORMATION,</a>
<a name="ln1582">			NULL, 0, CASE_SENSITIVE, const_cpu_to_le16(0),</a>
<a name="ln1583">			0, (u8*)&amp;si, sd_size);</a>
<a name="ln1584">	if (err &lt; 0)</a>
<a name="ln1585">		ntfs_log_perror(&quot;add_attr_std_info failed&quot;);</a>
<a name="ln1586">	return err;</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589">/*</a>
<a name="ln1590"> *		Tell whether the unnamed data is non resident</a>
<a name="ln1591"> */</a>
<a name="ln1592"> </a>
<a name="ln1593">static BOOL non_resident_unnamed_data(MFT_RECORD *m)</a>
<a name="ln1594">{</a>
<a name="ln1595">	ATTR_RECORD *a;</a>
<a name="ln1596">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1597">	BOOL nonres;</a>
<a name="ln1598"> </a>
<a name="ln1599">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln1600">	if (ctx &amp;&amp; !mkntfs_attr_find(AT_DATA,</a>
<a name="ln1601">				(const ntfschar*)NULL, 0, CASE_SENSITIVE,</a>
<a name="ln1602">				(u8*)NULL, 0, ctx)) {</a>
<a name="ln1603">		a = ctx-&gt;attr;</a>
<a name="ln1604">		nonres = a-&gt;non_resident != 0;</a>
<a name="ln1605">	} else {</a>
<a name="ln1606">		ntfs_log_error(&quot;BUG: Unnamed data not found\n&quot;);</a>
<a name="ln1607">		nonres = TRUE;</a>
<a name="ln1608">	}</a>
<a name="ln1609">	if (ctx)</a>
<a name="ln1610">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1611">	return (nonres);</a>
<a name="ln1612">}</a>
<a name="ln1613"> </a>
<a name="ln1614">/*</a>
<a name="ln1615"> *		Get the time stored in the standard information attribute</a>
<a name="ln1616"> */</a>
<a name="ln1617"> </a>
<a name="ln1618">static ntfs_time stdinfo_time(MFT_RECORD *m)</a>
<a name="ln1619">{</a>
<a name="ln1620">	STANDARD_INFORMATION *si;</a>
<a name="ln1621">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1622">	ntfs_time info_time;</a>
<a name="ln1623"> </a>
<a name="ln1624">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln1625">	if (ctx &amp;&amp; !mkntfs_attr_find(AT_STANDARD_INFORMATION,</a>
<a name="ln1626">				(const ntfschar*)NULL, 0, CASE_SENSITIVE,</a>
<a name="ln1627">				(u8*)NULL, 0, ctx)) {</a>
<a name="ln1628">		si = (STANDARD_INFORMATION*)((char*)ctx-&gt;attr +</a>
<a name="ln1629">				le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln1630">		info_time = si-&gt;creation_time;</a>
<a name="ln1631">	} else {</a>
<a name="ln1632">		ntfs_log_error(&quot;BUG: Standard information not found\n&quot;);</a>
<a name="ln1633">		info_time = mkntfs_time();</a>
<a name="ln1634">	}</a>
<a name="ln1635">	if (ctx)</a>
<a name="ln1636">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1637">	return (info_time);</a>
<a name="ln1638">}</a>
<a name="ln1639"> </a>
<a name="ln1640">/**</a>
<a name="ln1641"> * add_attr_file_name</a>
<a name="ln1642"> *</a>
<a name="ln1643"> * Return 0 on success or -errno on error.</a>
<a name="ln1644"> */</a>
<a name="ln1645">static int add_attr_file_name(MFT_RECORD *m, const leMFT_REF parent_dir,</a>
<a name="ln1646">		const s64 allocated_size, const s64 data_size,</a>
<a name="ln1647">		const FILE_ATTR_FLAGS flags, const u16 packed_ea_size,</a>
<a name="ln1648">		const u32 reparse_point_tag, const char *file_name,</a>
<a name="ln1649">		const FILE_NAME_TYPE_FLAGS file_name_type)</a>
<a name="ln1650">{</a>
<a name="ln1651">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1652">	STANDARD_INFORMATION *si;</a>
<a name="ln1653">	FILE_NAME_ATTR *fn;</a>
<a name="ln1654">	int i, fn_size;</a>
<a name="ln1655">	ntfschar *uname;</a>
<a name="ln1656"> </a>
<a name="ln1657">	/* Check if the attribute is already there. */</a>
<a name="ln1658">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln1659">	if (!ctx) {</a>
<a name="ln1660">		ntfs_log_error(&quot;Failed to get attribute search context.\n&quot;);</a>
<a name="ln1661">		return -ENOMEM;</a>
<a name="ln1662">	}</a>
<a name="ln1663">	if (mkntfs_attr_lookup(AT_STANDARD_INFORMATION, AT_UNNAMED, 0,</a>
<a name="ln1664">				CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln1665">		int eo = errno;</a>
<a name="ln1666">		ntfs_log_error(&quot;BUG: Standard information attribute not &quot;</a>
<a name="ln1667">				&quot;present in file record.\n&quot;);</a>
<a name="ln1668">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1669">		return -eo;</a>
<a name="ln1670">	}</a>
<a name="ln1671">	si = (STANDARD_INFORMATION*)((char*)ctx-&gt;attr +</a>
<a name="ln1672">			le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln1673">	i = (strlen(file_name) + 1) * sizeof(ntfschar);</a>
<a name="ln1674">	fn_size = sizeof(FILE_NAME_ATTR) + i;</a>
<a name="ln1675">	fn = ntfs_malloc(fn_size);</a>
<a name="ln1676">	if (!fn) {</a>
<a name="ln1677">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1678">		return -errno;</a>
<a name="ln1679">	}</a>
<a name="ln1680">	fn-&gt;parent_directory = parent_dir;</a>
<a name="ln1681"> </a>
<a name="ln1682">	fn-&gt;creation_time = si-&gt;creation_time;</a>
<a name="ln1683">	fn-&gt;last_data_change_time = si-&gt;last_data_change_time;</a>
<a name="ln1684">	fn-&gt;last_mft_change_time = si-&gt;last_mft_change_time;</a>
<a name="ln1685">	fn-&gt;last_access_time = si-&gt;last_access_time;</a>
<a name="ln1686">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1687"> </a>
<a name="ln1688">	fn-&gt;allocated_size = cpu_to_sle64(allocated_size);</a>
<a name="ln1689">	fn-&gt;data_size = cpu_to_sle64(data_size);</a>
<a name="ln1690">	fn-&gt;file_attributes = flags;</a>
<a name="ln1691">	/* These are in a union so can't have both. */</a>
<a name="ln1692">	if (packed_ea_size &amp;&amp; reparse_point_tag) {</a>
<a name="ln1693">		free(fn);</a>
<a name="ln1694">		return -EINVAL;</a>
<a name="ln1695">	}</a>
<a name="ln1696">	if (packed_ea_size) {</a>
<a name="ln1697">		fn-&gt;packed_ea_size = cpu_to_le16(packed_ea_size);</a>
<a name="ln1698">		fn-&gt;reserved = cpu_to_le16(0);</a>
<a name="ln1699">	} else {</a>
<a name="ln1700">		fn-&gt;reparse_point_tag = cpu_to_le32(reparse_point_tag);</a>
<a name="ln1701">	}</a>
<a name="ln1702">	fn-&gt;file_name_type = file_name_type;</a>
<a name="ln1703">	uname = fn-&gt;file_name;</a>
<a name="ln1704">	i = ntfs_mbstoucs_libntfscompat(file_name, &amp;uname, i);</a>
<a name="ln1705">	if (i &lt; 1) {</a>
<a name="ln1706">		free(fn);</a>
<a name="ln1707">		return -EINVAL;</a>
<a name="ln1708">	}</a>
<a name="ln1709">	if (i &gt; 0xff) {</a>
<a name="ln1710">		free(fn);</a>
<a name="ln1711">		return -ENAMETOOLONG;</a>
<a name="ln1712">	}</a>
<a name="ln1713">	/* No terminating null in file names. */</a>
<a name="ln1714">	fn-&gt;file_name_length = i;</a>
<a name="ln1715">	fn_size = sizeof(FILE_NAME_ATTR) + i * sizeof(ntfschar);</a>
<a name="ln1716">	i = insert_resident_attr_in_mft_record(m, AT_FILE_NAME, NULL, 0,</a>
<a name="ln1717">			CASE_SENSITIVE, const_cpu_to_le16(0),</a>
<a name="ln1718">			RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);</a>
<a name="ln1719">	free(fn);</a>
<a name="ln1720">	if (i &lt; 0)</a>
<a name="ln1721">		ntfs_log_error(&quot;add_attr_file_name failed: %s\n&quot;, strerror(-i));</a>
<a name="ln1722">	return i;</a>
<a name="ln1723">}</a>
<a name="ln1724"> </a>
<a name="ln1725">/**</a>
<a name="ln1726"> * add_attr_object_id -</a>
<a name="ln1727"> *</a>
<a name="ln1728"> * Note we insert only a basic object id which only has the GUID and none of</a>
<a name="ln1729"> * the extended fields.  This is because we currently only use this function</a>
<a name="ln1730"> * when creating the object id for the volume.</a>
<a name="ln1731"> *</a>
<a name="ln1732"> * Return 0 on success or -errno on error.</a>
<a name="ln1733"> */</a>
<a name="ln1734">static int add_attr_object_id(MFT_RECORD *m, const GUID *object_id)</a>
<a name="ln1735">{</a>
<a name="ln1736">	OBJECT_ID_ATTR oi;</a>
<a name="ln1737">	int err;</a>
<a name="ln1738"> </a>
<a name="ln1739">	oi = (OBJECT_ID_ATTR) {</a>
<a name="ln1740">		.object_id = *object_id,</a>
<a name="ln1741">	};</a>
<a name="ln1742">	err = insert_resident_attr_in_mft_record(m, AT_OBJECT_ID, NULL,</a>
<a name="ln1743">			0, CASE_SENSITIVE, const_cpu_to_le16(0),</a>
<a name="ln1744">			0, (u8*)&amp;oi, sizeof(oi.object_id));</a>
<a name="ln1745">	if (err &lt; 0)</a>
<a name="ln1746">		ntfs_log_error(&quot;add_attr_vol_info failed: %s\n&quot;, strerror(-err));</a>
<a name="ln1747">	return err;</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">/**</a>
<a name="ln1751"> * add_attr_sd</a>
<a name="ln1752"> *</a>
<a name="ln1753"> * Create the security descriptor attribute adding the security descriptor @sd</a>
<a name="ln1754"> * of length @sd_len to the mft record @m.</a>
<a name="ln1755"> *</a>
<a name="ln1756"> * Return 0 on success or -errno on error.</a>
<a name="ln1757"> */</a>
<a name="ln1758">static int add_attr_sd(MFT_RECORD *m, const u8 *sd, const s64 sd_len)</a>
<a name="ln1759">{</a>
<a name="ln1760">	int err;</a>
<a name="ln1761"> </a>
<a name="ln1762">	/* Does it fit? NO: create non-resident. YES: create resident. */</a>
<a name="ln1763">	if (le32_to_cpu(m-&gt;bytes_in_use) + 24 + sd_len &gt;</a>
<a name="ln1764">						le32_to_cpu(m-&gt;bytes_allocated))</a>
<a name="ln1765">		err = insert_non_resident_attr_in_mft_record(m,</a>
<a name="ln1766">				AT_SECURITY_DESCRIPTOR, NULL, 0,</a>
<a name="ln1767">				CASE_SENSITIVE, const_cpu_to_le16(0), sd,</a>
<a name="ln1768">				sd_len, WRITE_STANDARD);</a>
<a name="ln1769">	else</a>
<a name="ln1770">		err = insert_resident_attr_in_mft_record(m,</a>
<a name="ln1771">				AT_SECURITY_DESCRIPTOR, NULL, 0,</a>
<a name="ln1772">				CASE_SENSITIVE, const_cpu_to_le16(0), 0, sd,</a>
<a name="ln1773">				sd_len);</a>
<a name="ln1774">	if (err &lt; 0)</a>
<a name="ln1775">		ntfs_log_error(&quot;add_attr_sd failed: %s\n&quot;, strerror(-err));</a>
<a name="ln1776">	return err;</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779">/**</a>
<a name="ln1780"> * add_attr_data</a>
<a name="ln1781"> *</a>
<a name="ln1782"> * Return 0 on success or -errno on error.</a>
<a name="ln1783"> */</a>
<a name="ln1784">static int add_attr_data(MFT_RECORD *m, const char *name, const u32 name_len,</a>
<a name="ln1785">		const IGNORE_CASE_BOOL ic, const ATTR_FLAGS flags,</a>
<a name="ln1786">		const u8 *val, const s64 val_len)</a>
<a name="ln1787">{</a>
<a name="ln1788">	int err;</a>
<a name="ln1789"> </a>
<a name="ln1790">	/*</a>
<a name="ln1791">	 * Does it fit? NO: create non-resident. YES: create resident.</a>
<a name="ln1792">	 *</a>
<a name="ln1793">	 * FIXME: Introduced arbitrary limit of mft record allocated size - 512.</a>
<a name="ln1794">	 * This is to get around the problem that if $Bitmap/$DATA becomes too</a>
<a name="ln1795">	 * big, but is just small enough to be resident, we would make it</a>
<a name="ln1796">	 * resident, and later run out of space when creating the other</a>
<a name="ln1797">	 * attributes and this would cause us to abort as making resident</a>
<a name="ln1798">	 * attributes non-resident is not supported yet.</a>
<a name="ln1799">	 * The proper fix is to support making resident attribute non-resident.</a>
<a name="ln1800">	 */</a>
<a name="ln1801">	if (le32_to_cpu(m-&gt;bytes_in_use) + 24 + val_len &gt;</a>
<a name="ln1802">			min(le32_to_cpu(m-&gt;bytes_allocated),</a>
<a name="ln1803">			le32_to_cpu(m-&gt;bytes_allocated) - 512))</a>
<a name="ln1804">		err = insert_non_resident_attr_in_mft_record(m, AT_DATA, name,</a>
<a name="ln1805">				name_len, ic, flags, val, val_len,</a>
<a name="ln1806">				WRITE_STANDARD);</a>
<a name="ln1807">	else</a>
<a name="ln1808">		err = insert_resident_attr_in_mft_record(m, AT_DATA, name,</a>
<a name="ln1809">				name_len, ic, flags, 0, val, val_len);</a>
<a name="ln1810"> </a>
<a name="ln1811">	if (err &lt; 0)</a>
<a name="ln1812">		ntfs_log_error(&quot;add_attr_data failed: %s\n&quot;, strerror(-err));</a>
<a name="ln1813">	return err;</a>
<a name="ln1814">}</a>
<a name="ln1815"> </a>
<a name="ln1816">/**</a>
<a name="ln1817"> * add_attr_data_positioned</a>
<a name="ln1818"> *</a>
<a name="ln1819"> * Create a non-resident data attribute with a predefined on disk location</a>
<a name="ln1820"> * specified by the runlist @rl. The clusters specified by @rl are assumed to</a>
<a name="ln1821"> * be allocated already.</a>
<a name="ln1822"> *</a>
<a name="ln1823"> * Return 0 on success or -errno on error.</a>
<a name="ln1824"> */</a>
<a name="ln1825">static int add_attr_data_positioned(MFT_RECORD *m, const char *name,</a>
<a name="ln1826">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln1827">		const ATTR_FLAGS flags, const runlist *rl,</a>
<a name="ln1828">		const u8 *val, const s64 val_len)</a>
<a name="ln1829">{</a>
<a name="ln1830">	int err;</a>
<a name="ln1831"> </a>
<a name="ln1832">	err = insert_positioned_attr_in_mft_record(m, AT_DATA, name, name_len,</a>
<a name="ln1833">			ic, flags, rl, val, val_len);</a>
<a name="ln1834">	if (err &lt; 0)</a>
<a name="ln1835">		ntfs_log_error(&quot;add_attr_data_positioned failed: %s\n&quot;,</a>
<a name="ln1836">				strerror(-err));</a>
<a name="ln1837">	return err;</a>
<a name="ln1838">}</a>
<a name="ln1839"> </a>
<a name="ln1840">/**</a>
<a name="ln1841"> * add_attr_vol_name</a>
<a name="ln1842"> *</a>
<a name="ln1843"> * Create volume name attribute specifying the volume name @vol_name as a null</a>
<a name="ln1844"> * terminated char string of length @vol_name_len (number of characters not</a>
<a name="ln1845"> * including the terminating null), which is converted internally to a little</a>
<a name="ln1846"> * endian ntfschar string. The name is at least 1 character long (though</a>
<a name="ln1847"> * Windows accepts zero characters), and at most 128 characters long (not</a>
<a name="ln1848"> * counting the terminating null).</a>
<a name="ln1849"> *</a>
<a name="ln1850"> * Return 0 on success or -errno on error.</a>
<a name="ln1851"> */</a>
<a name="ln1852">static int add_attr_vol_name(MFT_RECORD *m, const char *vol_name,</a>
<a name="ln1853">		const int vol_name_len __attribute__((unused)))</a>
<a name="ln1854">{</a>
<a name="ln1855">	ntfschar *uname = NULL;</a>
<a name="ln1856">	int uname_len = 0;</a>
<a name="ln1857">	int i;</a>
<a name="ln1858"> </a>
<a name="ln1859">	if (vol_name) {</a>
<a name="ln1860">		uname_len = ntfs_mbstoucs(vol_name, &amp;uname);</a>
<a name="ln1861">		if (uname_len &lt; 0)</a>
<a name="ln1862">			return -errno;</a>
<a name="ln1863">		if (uname_len &gt; 128) {</a>
<a name="ln1864">			free(uname);</a>
<a name="ln1865">			return -ENAMETOOLONG;</a>
<a name="ln1866">		}</a>
<a name="ln1867">	}</a>
<a name="ln1868">	i = insert_resident_attr_in_mft_record(m, AT_VOLUME_NAME, NULL, 0,</a>
<a name="ln1869">			CASE_SENSITIVE, const_cpu_to_le16(0),</a>
<a name="ln1870">			0, (u8*)uname, uname_len*sizeof(ntfschar));</a>
<a name="ln1871">	free(uname);</a>
<a name="ln1872">	if (i &lt; 0)</a>
<a name="ln1873">		ntfs_log_error(&quot;add_attr_vol_name failed: %s\n&quot;, strerror(-i));</a>
<a name="ln1874">	return i;</a>
<a name="ln1875">}</a>
<a name="ln1876"> </a>
<a name="ln1877">/**</a>
<a name="ln1878"> * add_attr_vol_info</a>
<a name="ln1879"> *</a>
<a name="ln1880"> * Return 0 on success or -errno on error.</a>
<a name="ln1881"> */</a>
<a name="ln1882">static int add_attr_vol_info(MFT_RECORD *m, const VOLUME_FLAGS flags,</a>
<a name="ln1883">		const u8 major_ver, const u8 minor_ver)</a>
<a name="ln1884">{</a>
<a name="ln1885">	VOLUME_INFORMATION vi;</a>
<a name="ln1886">	int err;</a>
<a name="ln1887"> </a>
<a name="ln1888">	memset(&amp;vi, 0, sizeof(vi));</a>
<a name="ln1889">	vi.major_ver = major_ver;</a>
<a name="ln1890">	vi.minor_ver = minor_ver;</a>
<a name="ln1891">	vi.flags = flags &amp; VOLUME_FLAGS_MASK;</a>
<a name="ln1892">	err = insert_resident_attr_in_mft_record(m, AT_VOLUME_INFORMATION, NULL,</a>
<a name="ln1893">			0, CASE_SENSITIVE, const_cpu_to_le16(0),</a>
<a name="ln1894">			0, (u8*)&amp;vi, sizeof(vi));</a>
<a name="ln1895">	if (err &lt; 0)</a>
<a name="ln1896">		ntfs_log_error(&quot;add_attr_vol_info failed: %s\n&quot;, strerror(-err));</a>
<a name="ln1897">	return err;</a>
<a name="ln1898">}</a>
<a name="ln1899"> </a>
<a name="ln1900">/**</a>
<a name="ln1901"> * add_attr_index_root</a>
<a name="ln1902"> *</a>
<a name="ln1903"> * Return 0 on success or -errno on error.</a>
<a name="ln1904"> */</a>
<a name="ln1905">static int add_attr_index_root(MFT_RECORD *m, const char *name,</a>
<a name="ln1906">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln1907">		const ATTR_TYPES indexed_attr_type,</a>
<a name="ln1908">		const COLLATION_RULES collation_rule,</a>
<a name="ln1909">		const u32 index_block_size)</a>
<a name="ln1910">{</a>
<a name="ln1911">	INDEX_ROOT *r;</a>
<a name="ln1912">	INDEX_ENTRY_HEADER *e;</a>
<a name="ln1913">	int err, val_len;</a>
<a name="ln1914"> </a>
<a name="ln1915">	val_len = sizeof(INDEX_ROOT) + sizeof(INDEX_ENTRY_HEADER);</a>
<a name="ln1916">	r = ntfs_malloc(val_len);</a>
<a name="ln1917">	if (!r)</a>
<a name="ln1918">		return -errno;</a>
<a name="ln1919">	r-&gt;type = (indexed_attr_type == AT_FILE_NAME)</a>
<a name="ln1920">				? AT_FILE_NAME : const_cpu_to_le32(0);</a>
<a name="ln1921">	if (indexed_attr_type == AT_FILE_NAME &amp;&amp;</a>
<a name="ln1922">			collation_rule != COLLATION_FILE_NAME) {</a>
<a name="ln1923">		free(r);</a>
<a name="ln1924">		ntfs_log_error(&quot;add_attr_index_root: indexed attribute is $FILE_NAME &quot;</a>
<a name="ln1925">			&quot;but collation rule is not COLLATION_FILE_NAME.\n&quot;);</a>
<a name="ln1926">		return -EINVAL;</a>
<a name="ln1927">	}</a>
<a name="ln1928">	r-&gt;collation_rule = collation_rule;</a>
<a name="ln1929">	r-&gt;index_block_size = cpu_to_le32(index_block_size);</a>
<a name="ln1930">	if (index_block_size &gt;= g_vol-&gt;cluster_size) {</a>
<a name="ln1931">		if (index_block_size % g_vol-&gt;cluster_size) {</a>
<a name="ln1932">			ntfs_log_error(&quot;add_attr_index_root: index block size is not &quot;</a>
<a name="ln1933">					&quot;a multiple of the cluster size.\n&quot;);</a>
<a name="ln1934">			free(r);</a>
<a name="ln1935">			return -EINVAL;</a>
<a name="ln1936">		}</a>
<a name="ln1937">		r-&gt;clusters_per_index_block = index_block_size /</a>
<a name="ln1938">				g_vol-&gt;cluster_size;</a>
<a name="ln1939">	} else { /* if (g_vol-&gt;cluster_size &gt; index_block_size) */</a>
<a name="ln1940">		if (index_block_size &amp; (index_block_size - 1)) {</a>
<a name="ln1941">			ntfs_log_error(&quot;add_attr_index_root: index block size is not &quot;</a>
<a name="ln1942">					&quot;a power of 2.\n&quot;);</a>
<a name="ln1943">			free(r);</a>
<a name="ln1944">			return -EINVAL;</a>
<a name="ln1945">		}</a>
<a name="ln1946">		if (index_block_size &lt; (u32)opts.sector_size) {</a>
<a name="ln1947">			 ntfs_log_error(&quot;add_attr_index_root: index block size &quot;</a>
<a name="ln1948">					 &quot;is smaller than the sector size.\n&quot;);</a>
<a name="ln1949">			 free(r);</a>
<a name="ln1950">			 return -EINVAL;</a>
<a name="ln1951">		}</a>
<a name="ln1952">		r-&gt;clusters_per_index_block = index_block_size</a>
<a name="ln1953">				&gt;&gt; NTFS_BLOCK_SIZE_BITS;</a>
<a name="ln1954">	}</a>
<a name="ln1955">	memset(&amp;r-&gt;reserved, 0, sizeof(r-&gt;reserved));</a>
<a name="ln1956">	r-&gt;index.entries_offset = const_cpu_to_le32(sizeof(INDEX_HEADER));</a>
<a name="ln1957">	r-&gt;index.index_length = const_cpu_to_le32(sizeof(INDEX_HEADER) +</a>
<a name="ln1958">			sizeof(INDEX_ENTRY_HEADER));</a>
<a name="ln1959">	r-&gt;index.allocated_size = r-&gt;index.index_length;</a>
<a name="ln1960">	r-&gt;index.ih_flags = SMALL_INDEX;</a>
<a name="ln1961">	memset(&amp;r-&gt;index.reserved, 0, sizeof(r-&gt;index.reserved));</a>
<a name="ln1962">	e = (INDEX_ENTRY_HEADER*)((u8*)&amp;r-&gt;index +</a>
<a name="ln1963">			le32_to_cpu(r-&gt;index.entries_offset));</a>
<a name="ln1964">	/*</a>
<a name="ln1965">	 * No matter whether this is a file index or a view as this is a</a>
<a name="ln1966">	 * termination entry, hence no key value / data is associated with it</a>
<a name="ln1967">	 * at all. Thus, we just need the union to be all zero.</a>
<a name="ln1968">	 */</a>
<a name="ln1969">	e-&gt;indexed_file = const_cpu_to_le64(0LL);</a>
<a name="ln1970">	e-&gt;length = const_cpu_to_le16(sizeof(INDEX_ENTRY_HEADER));</a>
<a name="ln1971">	e-&gt;key_length = const_cpu_to_le16(0);</a>
<a name="ln1972">	e-&gt;flags = INDEX_ENTRY_END;</a>
<a name="ln1973">	e-&gt;reserved = const_cpu_to_le16(0);</a>
<a name="ln1974">	err = insert_resident_attr_in_mft_record(m, AT_INDEX_ROOT, name,</a>
<a name="ln1975">				name_len, ic, const_cpu_to_le16(0), 0,</a>
<a name="ln1976">				(u8*)r, val_len);</a>
<a name="ln1977">	free(r);</a>
<a name="ln1978">	if (err &lt; 0)</a>
<a name="ln1979">		ntfs_log_error(&quot;add_attr_index_root failed: %s\n&quot;, strerror(-err));</a>
<a name="ln1980">	return err;</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983">/**</a>
<a name="ln1984"> * add_attr_index_alloc</a>
<a name="ln1985"> *</a>
<a name="ln1986"> * Return 0 on success or -errno on error.</a>
<a name="ln1987"> */</a>
<a name="ln1988">static int add_attr_index_alloc(MFT_RECORD *m, const char *name,</a>
<a name="ln1989">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln1990">		const u8 *index_alloc_val, const u32 index_alloc_val_len)</a>
<a name="ln1991">{</a>
<a name="ln1992">	int err;</a>
<a name="ln1993"> </a>
<a name="ln1994">	err = insert_non_resident_attr_in_mft_record(m, AT_INDEX_ALLOCATION,</a>
<a name="ln1995">			name, name_len, ic, const_cpu_to_le16(0),</a>
<a name="ln1996">			index_alloc_val, index_alloc_val_len, WRITE_STANDARD);</a>
<a name="ln1997">	if (err &lt; 0)</a>
<a name="ln1998">		ntfs_log_error(&quot;add_attr_index_alloc failed: %s\n&quot;, strerror(-err));</a>
<a name="ln1999">	return err;</a>
<a name="ln2000">}</a>
<a name="ln2001"> </a>
<a name="ln2002">/**</a>
<a name="ln2003"> * add_attr_bitmap</a>
<a name="ln2004"> *</a>
<a name="ln2005"> * Return 0 on success or -errno on error.</a>
<a name="ln2006"> */</a>
<a name="ln2007">static int add_attr_bitmap(MFT_RECORD *m, const char *name, const u32 name_len,</a>
<a name="ln2008">		const IGNORE_CASE_BOOL ic, const u8 *bitmap,</a>
<a name="ln2009">		const u32 bitmap_len)</a>
<a name="ln2010">{</a>
<a name="ln2011">	int err;</a>
<a name="ln2012"> </a>
<a name="ln2013">	/* Does it fit? NO: create non-resident. YES: create resident. */</a>
<a name="ln2014">	if (le32_to_cpu(m-&gt;bytes_in_use) + 24 + bitmap_len &gt;</a>
<a name="ln2015">						le32_to_cpu(m-&gt;bytes_allocated))</a>
<a name="ln2016">		err = insert_non_resident_attr_in_mft_record(m, AT_BITMAP, name,</a>
<a name="ln2017">				name_len, ic, const_cpu_to_le16(0), bitmap,</a>
<a name="ln2018">				bitmap_len, WRITE_STANDARD);</a>
<a name="ln2019">	else</a>
<a name="ln2020">		err = insert_resident_attr_in_mft_record(m, AT_BITMAP, name,</a>
<a name="ln2021">				name_len, ic, const_cpu_to_le16(0), 0,</a>
<a name="ln2022">				bitmap, bitmap_len);</a>
<a name="ln2023"> </a>
<a name="ln2024">	if (err &lt; 0)</a>
<a name="ln2025">		ntfs_log_error(&quot;add_attr_bitmap failed: %s\n&quot;, strerror(-err));</a>
<a name="ln2026">	return err;</a>
<a name="ln2027">}</a>
<a name="ln2028"> </a>
<a name="ln2029">/**</a>
<a name="ln2030"> * add_attr_bitmap_positioned</a>
<a name="ln2031"> *</a>
<a name="ln2032"> * Create a non-resident bitmap attribute with a predefined on disk location</a>
<a name="ln2033"> * specified by the runlist @rl. The clusters specified by @rl are assumed to</a>
<a name="ln2034"> * be allocated already.</a>
<a name="ln2035"> *</a>
<a name="ln2036"> * Return 0 on success or -errno on error.</a>
<a name="ln2037"> */</a>
<a name="ln2038">static int add_attr_bitmap_positioned(MFT_RECORD *m, const char *name,</a>
<a name="ln2039">		const u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln2040">		const runlist *rl, const u8 *bitmap, const u32 bitmap_len)</a>
<a name="ln2041">{</a>
<a name="ln2042">	int err;</a>
<a name="ln2043"> </a>
<a name="ln2044">	err = insert_positioned_attr_in_mft_record(m, AT_BITMAP, name, name_len,</a>
<a name="ln2045">			ic, const_cpu_to_le16(0), rl, bitmap, bitmap_len);</a>
<a name="ln2046">	if (err &lt; 0)</a>
<a name="ln2047">		ntfs_log_error(&quot;add_attr_bitmap_positioned failed: %s\n&quot;,</a>
<a name="ln2048">				strerror(-err));</a>
<a name="ln2049">	return err;</a>
<a name="ln2050">}</a>
<a name="ln2051"> </a>
<a name="ln2052"> </a>
<a name="ln2053">/**</a>
<a name="ln2054"> * upgrade_to_large_index</a>
<a name="ln2055"> *</a>
<a name="ln2056"> * Create bitmap and index allocation attributes, modify index root</a>
<a name="ln2057"> * attribute accordingly and move all of the index entries from the index root</a>
<a name="ln2058"> * into the index allocation.</a>
<a name="ln2059"> *</a>
<a name="ln2060"> * Return 0 on success or -errno on error.</a>
<a name="ln2061"> */</a>
<a name="ln2062">static int upgrade_to_large_index(MFT_RECORD *m, const char *name,</a>
<a name="ln2063">		u32 name_len, const IGNORE_CASE_BOOL ic,</a>
<a name="ln2064">		INDEX_ALLOCATION **idx)</a>
<a name="ln2065">{</a>
<a name="ln2066">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln2067">	ATTR_RECORD *a;</a>
<a name="ln2068">	INDEX_ROOT *r;</a>
<a name="ln2069">	INDEX_ENTRY *re;</a>
<a name="ln2070">	INDEX_ALLOCATION *ia_val = NULL;</a>
<a name="ln2071">	ntfschar *uname = NULL;</a>
<a name="ln2072">	int uname_len = 0;</a>
<a name="ln2073">	u8 bmp[8];</a>
<a name="ln2074">	char *re_start, *re_end;</a>
<a name="ln2075">	int i, err, index_block_size;</a>
<a name="ln2076"> </a>
<a name="ln2077">	uname = ntfs_str2ucs(name, &amp;uname_len);</a>
<a name="ln2078">	if (!uname)</a>
<a name="ln2079">		return -errno;</a>
<a name="ln2080"> </a>
<a name="ln2081">	/* Find the index root attribute. */</a>
<a name="ln2082">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln2083">	if (!ctx) {</a>
<a name="ln2084">		ntfs_log_error(&quot;Failed to allocate attribute search context.\n&quot;);</a>
<a name="ln2085">		ntfs_ucsfree(uname);</a>
<a name="ln2086">		return -ENOMEM;</a>
<a name="ln2087">	}</a>
<a name="ln2088">	if (ic == IGNORE_CASE) {</a>
<a name="ln2089">		ntfs_log_error(&quot;FIXME: Hit unimplemented code path #4.\n&quot;);</a>
<a name="ln2090">		err = -EOPNOTSUPP;</a>
<a name="ln2091">		ntfs_ucsfree(uname);</a>
<a name="ln2092">		goto err_out;</a>
<a name="ln2093">	}</a>
<a name="ln2094">	err = mkntfs_attr_lookup(AT_INDEX_ROOT, uname, uname_len, ic, 0, NULL, 0,</a>
<a name="ln2095">			ctx);</a>
<a name="ln2096">	ntfs_ucsfree(uname);</a>
<a name="ln2097">	if (err) {</a>
<a name="ln2098">		err = -ENOTDIR;</a>
<a name="ln2099">		goto err_out;</a>
<a name="ln2100">	}</a>
<a name="ln2101">	a = ctx-&gt;attr;</a>
<a name="ln2102">	if (a-&gt;non_resident || a-&gt;flags) {</a>
<a name="ln2103">		err = -EINVAL;</a>
<a name="ln2104">		goto err_out;</a>
<a name="ln2105">	}</a>
<a name="ln2106">	r = (INDEX_ROOT*)((char*)a + le16_to_cpu(a-&gt;value_offset));</a>
<a name="ln2107">	re_end = (char*)r + le32_to_cpu(a-&gt;value_length);</a>
<a name="ln2108">	re_start = (char*)&amp;r-&gt;index + le32_to_cpu(r-&gt;index.entries_offset);</a>
<a name="ln2109">	re = (INDEX_ENTRY*)re_start;</a>
<a name="ln2110">	index_block_size = le32_to_cpu(r-&gt;index_block_size);</a>
<a name="ln2111">	memset(bmp, 0, sizeof(bmp));</a>
<a name="ln2112">	ntfs_bit_set(bmp, 0ULL, 1);</a>
<a name="ln2113">	/* Bitmap has to be at least 8 bytes in size. */</a>
<a name="ln2114">	err = add_attr_bitmap(m, name, name_len, ic, bmp, sizeof(bmp));</a>
<a name="ln2115">	if (err)</a>
<a name="ln2116">		goto err_out;</a>
<a name="ln2117">	ia_val = ntfs_calloc(index_block_size);</a>
<a name="ln2118">	if (!ia_val) {</a>
<a name="ln2119">		err = -errno;</a>
<a name="ln2120">		goto err_out;</a>
<a name="ln2121">	}</a>
<a name="ln2122">	/* Setup header. */</a>
<a name="ln2123">	ia_val-&gt;magic = magic_INDX;</a>
<a name="ln2124">	ia_val-&gt;usa_ofs = cpu_to_le16(sizeof(INDEX_ALLOCATION));</a>
<a name="ln2125">	if (index_block_size &gt;= NTFS_BLOCK_SIZE) {</a>
<a name="ln2126">		ia_val-&gt;usa_count = cpu_to_le16(index_block_size /</a>
<a name="ln2127">				NTFS_BLOCK_SIZE + 1);</a>
<a name="ln2128">	} else {</a>
<a name="ln2129">		ia_val-&gt;usa_count = cpu_to_le16(1);</a>
<a name="ln2130">		ntfs_log_error(&quot;Sector size is bigger than index block size. &quot;</a>
<a name="ln2131">				&quot;Setting usa_count to 1. If Windows chkdsk &quot;</a>
<a name="ln2132">				&quot;reports this as corruption, please email %s &quot;</a>
<a name="ln2133">				&quot;stating that you saw this message and that &quot;</a>
<a name="ln2134">				&quot;the filesystem created was corrupt.  &quot;</a>
<a name="ln2135">				&quot;Thank you.&quot;, NTFS_DEV_LIST);</a>
<a name="ln2136">	}</a>
<a name="ln2137">	/* Set USN to 1. */</a>
<a name="ln2138">	*(le16*)((char*)ia_val + le16_to_cpu(ia_val-&gt;usa_ofs)) =</a>
<a name="ln2139">			cpu_to_le16(1);</a>
<a name="ln2140">	ia_val-&gt;lsn = cpu_to_le64(0);</a>
<a name="ln2141">	ia_val-&gt;index_block_vcn = cpu_to_le64(0);</a>
<a name="ln2142">	ia_val-&gt;index.ih_flags = LEAF_NODE;</a>
<a name="ln2143">	/* Align to 8-byte boundary. */</a>
<a name="ln2144">	ia_val-&gt;index.entries_offset = cpu_to_le32((sizeof(INDEX_HEADER) +</a>
<a name="ln2145">			le16_to_cpu(ia_val-&gt;usa_count) * 2 + 7) &amp; ~7);</a>
<a name="ln2146">	ia_val-&gt;index.allocated_size = cpu_to_le32(index_block_size -</a>
<a name="ln2147">			(sizeof(INDEX_ALLOCATION) - sizeof(INDEX_HEADER)));</a>
<a name="ln2148">	/* Find the last entry in the index root and save it in re. */</a>
<a name="ln2149">	while ((char*)re &lt; re_end &amp;&amp; !(re-&gt;ie_flags &amp; INDEX_ENTRY_END)) {</a>
<a name="ln2150">		/* Next entry in index root. */</a>
<a name="ln2151">		re = (INDEX_ENTRY*)((char*)re + le16_to_cpu(re-&gt;length));</a>
<a name="ln2152">	}</a>
<a name="ln2153">	/* Copy all the entries including the termination entry. */</a>
<a name="ln2154">	i = (char*)re - re_start + le16_to_cpu(re-&gt;length);</a>
<a name="ln2155">	memcpy((char*)&amp;ia_val-&gt;index +</a>
<a name="ln2156">			le32_to_cpu(ia_val-&gt;index.entries_offset), re_start, i);</a>
<a name="ln2157">	/* Finish setting up index allocation. */</a>
<a name="ln2158">	ia_val-&gt;index.index_length = cpu_to_le32(i +</a>
<a name="ln2159">			le32_to_cpu(ia_val-&gt;index.entries_offset));</a>
<a name="ln2160">	/* Move the termination entry forward to the beginning if necessary. */</a>
<a name="ln2161">	if ((char*)re &gt; re_start) {</a>
<a name="ln2162">		memmove(re_start, (char*)re, le16_to_cpu(re-&gt;length));</a>
<a name="ln2163">		re = (INDEX_ENTRY*)re_start;</a>
<a name="ln2164">	}</a>
<a name="ln2165">	/* Now fixup empty index root with pointer to index allocation VCN 0. */</a>
<a name="ln2166">	r-&gt;index.ih_flags = LARGE_INDEX;</a>
<a name="ln2167">	re-&gt;ie_flags |= INDEX_ENTRY_NODE;</a>
<a name="ln2168">	if (le16_to_cpu(re-&gt;length) &lt; sizeof(INDEX_ENTRY_HEADER) + sizeof(VCN))</a>
<a name="ln2169">		re-&gt;length = cpu_to_le16(le16_to_cpu(re-&gt;length) + sizeof(VCN));</a>
<a name="ln2170">	r-&gt;index.index_length = cpu_to_le32(le32_to_cpu(r-&gt;index.entries_offset)</a>
<a name="ln2171">			+ le16_to_cpu(re-&gt;length));</a>
<a name="ln2172">	r-&gt;index.allocated_size = r-&gt;index.index_length;</a>
<a name="ln2173">	/* Resize index root attribute. */</a>
<a name="ln2174">	if (ntfs_resident_attr_value_resize(m, a, sizeof(INDEX_ROOT) -</a>
<a name="ln2175">			sizeof(INDEX_HEADER) +</a>
<a name="ln2176">			le32_to_cpu(r-&gt;index.allocated_size))) {</a>
<a name="ln2177">		/* TODO: Remove the added bitmap! */</a>
<a name="ln2178">		/* Revert index root from index allocation. */</a>
<a name="ln2179">		err = -errno;</a>
<a name="ln2180">		goto err_out;</a>
<a name="ln2181">	}</a>
<a name="ln2182">	/* Set VCN pointer to 0LL. */</a>
<a name="ln2183">	*(leVCN*)((char*)re + cpu_to_le16(re-&gt;length) - sizeof(VCN)) =</a>
<a name="ln2184">			cpu_to_le64(0);</a>
<a name="ln2185">	err = ntfs_mst_pre_write_fixup((NTFS_RECORD*)ia_val, index_block_size);</a>
<a name="ln2186">	if (err) {</a>
<a name="ln2187">		err = -errno;</a>
<a name="ln2188">		ntfs_log_error(&quot;ntfs_mst_pre_write_fixup() failed in &quot;</a>
<a name="ln2189">				&quot;upgrade_to_large_index.\n&quot;);</a>
<a name="ln2190">		goto err_out;</a>
<a name="ln2191">	}</a>
<a name="ln2192">	err = add_attr_index_alloc(m, name, name_len, ic, (u8*)ia_val,</a>
<a name="ln2193">			index_block_size);</a>
<a name="ln2194">	ntfs_mst_post_write_fixup((NTFS_RECORD*)ia_val);</a>
<a name="ln2195">	if (err) {</a>
<a name="ln2196">		/* TODO: Remove the added bitmap! */</a>
<a name="ln2197">		/* Revert index root from index allocation. */</a>
<a name="ln2198">		goto err_out;</a>
<a name="ln2199">	}</a>
<a name="ln2200">	*idx = ia_val;</a>
<a name="ln2201">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2202">	return 0;</a>
<a name="ln2203">err_out:</a>
<a name="ln2204">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2205">	free(ia_val);</a>
<a name="ln2206">	return err;</a>
<a name="ln2207">}</a>
<a name="ln2208"> </a>
<a name="ln2209">/**</a>
<a name="ln2210"> * make_room_for_index_entry_in_index_block</a>
<a name="ln2211"> *</a>
<a name="ln2212"> * Create space of @size bytes at position @pos inside the index block @idx.</a>
<a name="ln2213"> *</a>
<a name="ln2214"> * Return 0 on success or -errno on error.</a>
<a name="ln2215"> */</a>
<a name="ln2216">static int make_room_for_index_entry_in_index_block(INDEX_BLOCK *idx,</a>
<a name="ln2217">		INDEX_ENTRY *pos, u32 size)</a>
<a name="ln2218">{</a>
<a name="ln2219">	u32 biu;</a>
<a name="ln2220"> </a>
<a name="ln2221">	if (!size)</a>
<a name="ln2222">		return 0;</a>
<a name="ln2223">#ifdef DEBUG</a>
<a name="ln2224">	/*</a>
<a name="ln2225">	 * Rigorous consistency checks. Always return -EINVAL even if more</a>
<a name="ln2226">	 * appropriate codes exist for simplicity of parsing the return value.</a>
<a name="ln2227">	 */</a>
<a name="ln2228">	if (size != ((size + 7) &amp; ~7)) {</a>
<a name="ln2229">		ntfs_log_error(&quot;make_room_for_index_entry_in_index_block() received &quot;</a>
<a name="ln2230">				&quot;non 8-byte aligned size.\n&quot;);</a>
<a name="ln2231">		return -EINVAL;</a>
<a name="ln2232">	}</a>
<a name="ln2233">	if (!idx || !pos)</a>
<a name="ln2234">		return -EINVAL;</a>
<a name="ln2235">	if ((char*)pos &lt; (char*)idx || (char*)pos + size &lt; (char*)idx ||</a>
<a name="ln2236">			(char*)pos &gt; (char*)idx + sizeof(INDEX_BLOCK) -</a>
<a name="ln2237">				sizeof(INDEX_HEADER) +</a>
<a name="ln2238">				le32_to_cpu(idx-&gt;index.allocated_size) ||</a>
<a name="ln2239">			(char*)pos + size &gt; (char*)idx + sizeof(INDEX_BLOCK) -</a>
<a name="ln2240">				sizeof(INDEX_HEADER) +</a>
<a name="ln2241">				le32_to_cpu(idx-&gt;index.allocated_size))</a>
<a name="ln2242">		return -EINVAL;</a>
<a name="ln2243">	/* The - sizeof(INDEX_ENTRY_HEADER) is for the index terminator. */</a>
<a name="ln2244">	if ((char*)pos - (char*)&amp;idx-&gt;index &gt;</a>
<a name="ln2245">			(int)le32_to_cpu(idx-&gt;index.index_length)</a>
<a name="ln2246">			- (int)sizeof(INDEX_ENTRY_HEADER))</a>
<a name="ln2247">		return -EINVAL;</a>
<a name="ln2248">#endif</a>
<a name="ln2249">	biu = le32_to_cpu(idx-&gt;index.index_length);</a>
<a name="ln2250">	/* Do we have enough space? */</a>
<a name="ln2251">	if (biu + size &gt; le32_to_cpu(idx-&gt;index.allocated_size))</a>
<a name="ln2252">		return -ENOSPC;</a>
<a name="ln2253">	/* Move everything after pos to pos + size. */</a>
<a name="ln2254">	memmove((char*)pos + size, (char*)pos, biu - ((char*)pos -</a>
<a name="ln2255">			(char*)&amp;idx-&gt;index));</a>
<a name="ln2256">	/* Update index block. */</a>
<a name="ln2257">	idx-&gt;index.index_length = cpu_to_le32(biu + size);</a>
<a name="ln2258">	return 0;</a>
<a name="ln2259">}</a>
<a name="ln2260"> </a>
<a name="ln2261">/**</a>
<a name="ln2262"> * ntfs_index_keys_compare</a>
<a name="ln2263"> *</a>
<a name="ln2264"> * not all types of COLLATION_RULES supported yet...</a>
<a name="ln2265"> * added as needed.. (remove this comment when all are added)</a>
<a name="ln2266"> */</a>
<a name="ln2267">static int ntfs_index_keys_compare(u8 *key1, u8 *key2, int key1_length,</a>
<a name="ln2268">		int key2_length, COLLATION_RULES collation_rule)</a>
<a name="ln2269">{</a>
<a name="ln2270">	u32 u1, u2;</a>
<a name="ln2271">	int i;</a>
<a name="ln2272"> </a>
<a name="ln2273">	if (collation_rule == COLLATION_NTOFS_ULONG) {</a>
<a name="ln2274">		/* i.e. $SII or $QUOTA-$Q */</a>
<a name="ln2275">		u1 = le32_to_cpup((const le32*)key1);</a>
<a name="ln2276">		u2 = le32_to_cpup((const le32*)key2);</a>
<a name="ln2277">		if (u1 &lt; u2)</a>
<a name="ln2278">			return -1;</a>
<a name="ln2279">		if (u1 &gt; u2)</a>
<a name="ln2280">			return 1;</a>
<a name="ln2281">		/* u1 == u2 */</a>
<a name="ln2282">		return 0;</a>
<a name="ln2283">	}</a>
<a name="ln2284">	if (collation_rule == COLLATION_NTOFS_ULONGS) {</a>
<a name="ln2285">		/* i.e $OBJID-$O */</a>
<a name="ln2286">		i = 0;</a>
<a name="ln2287">		while (i &lt; min(key1_length, key2_length)) {</a>
<a name="ln2288">			u1 = le32_to_cpup((const le32*)(key1 + i));</a>
<a name="ln2289">			u2 = le32_to_cpup((const le32*)(key2 + i));</a>
<a name="ln2290">			if (u1 &lt; u2)</a>
<a name="ln2291">				return -1;</a>
<a name="ln2292">			if (u1 &gt; u2)</a>
<a name="ln2293">				return 1;</a>
<a name="ln2294">			/* u1 == u2 */</a>
<a name="ln2295">			i += sizeof(u32);</a>
<a name="ln2296">		}</a>
<a name="ln2297">		if (key1_length &lt; key2_length)</a>
<a name="ln2298">			return -1;</a>
<a name="ln2299">		if (key1_length &gt; key2_length)</a>
<a name="ln2300">			return 1;</a>
<a name="ln2301">		return 0;</a>
<a name="ln2302">	}</a>
<a name="ln2303">	if (collation_rule == COLLATION_NTOFS_SECURITY_HASH) {</a>
<a name="ln2304">		/* i.e. $SDH */</a>
<a name="ln2305">		u1 = le32_to_cpu(((SDH_INDEX_KEY*)key1)-&gt;hash);</a>
<a name="ln2306">		u2 = le32_to_cpu(((SDH_INDEX_KEY*)key2)-&gt;hash);</a>
<a name="ln2307">		if (u1 &lt; u2)</a>
<a name="ln2308">			return -1;</a>
<a name="ln2309">		if (u1 &gt; u2)</a>
<a name="ln2310">			return 1;</a>
<a name="ln2311">		/* u1 == u2 */</a>
<a name="ln2312">		u1 = le32_to_cpu(((SDH_INDEX_KEY*)key1)-&gt;security_id);</a>
<a name="ln2313">		u2 = le32_to_cpu(((SDH_INDEX_KEY*)key2)-&gt;security_id);</a>
<a name="ln2314">		if (u1 &lt; u2)</a>
<a name="ln2315">			return -1;</a>
<a name="ln2316">		if (u1 &gt; u2)</a>
<a name="ln2317">			return 1;</a>
<a name="ln2318">		return 0;</a>
<a name="ln2319">	}</a>
<a name="ln2320">	if (collation_rule == COLLATION_NTOFS_SID) {</a>
<a name="ln2321">		/* i.e. $QUOTA-O */</a>
<a name="ln2322">		i = memcmp(key1, key2, min(key1_length, key2_length));</a>
<a name="ln2323">		if (!i) {</a>
<a name="ln2324">			if (key1_length &lt; key2_length)</a>
<a name="ln2325">				return -1;</a>
<a name="ln2326">			if (key1_length &gt; key2_length)</a>
<a name="ln2327">				return 1;</a>
<a name="ln2328">		}</a>
<a name="ln2329">		return i;</a>
<a name="ln2330">	}</a>
<a name="ln2331">	ntfs_log_critical(&quot;ntfs_index_keys_compare called without supported &quot;</a>
<a name="ln2332">			&quot;collation rule.\n&quot;);</a>
<a name="ln2333">	return 0;	/* Claim they're equal.  What else can we do? */</a>
<a name="ln2334">}</a>
<a name="ln2335"> </a>
<a name="ln2336">/**</a>
<a name="ln2337"> * insert_index_entry_in_res_dir_index</a>
<a name="ln2338"> *</a>
<a name="ln2339"> * i.e. insert an index_entry in some named index_root</a>
<a name="ln2340"> * simplified search method, works for mkntfs</a>
<a name="ln2341"> */</a>
<a name="ln2342">static int insert_index_entry_in_res_dir_index(INDEX_ENTRY *idx, u32 idx_size,</a>
<a name="ln2343">		MFT_RECORD *m, ntfschar *name, u32 name_size, ATTR_TYPES type)</a>
<a name="ln2344">{</a>
<a name="ln2345">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln2346">	INDEX_HEADER *idx_header;</a>
<a name="ln2347">	INDEX_ENTRY *idx_entry, *idx_end;</a>
<a name="ln2348">	ATTR_RECORD *a;</a>
<a name="ln2349">	COLLATION_RULES collation_rule;</a>
<a name="ln2350">	int err, i;</a>
<a name="ln2351"> </a>
<a name="ln2352">	err = 0;</a>
<a name="ln2353">	/* does it fit ?*/</a>
<a name="ln2354">	if (g_vol-&gt;mft_record_size &gt; idx_size + le32_to_cpu(m-&gt;bytes_allocated))</a>
<a name="ln2355">		return -ENOSPC;</a>
<a name="ln2356">	/* find the INDEX_ROOT attribute:*/</a>
<a name="ln2357">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln2358">	if (!ctx) {</a>
<a name="ln2359">		ntfs_log_error(&quot;Failed to allocate attribute search &quot;</a>
<a name="ln2360">				&quot;context.\n&quot;);</a>
<a name="ln2361">		err = -ENOMEM;</a>
<a name="ln2362">		goto err_out;</a>
<a name="ln2363">	}</a>
<a name="ln2364">	if (mkntfs_attr_lookup(AT_INDEX_ROOT, name, name_size,</a>
<a name="ln2365">			CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln2366">		err = -EEXIST;</a>
<a name="ln2367">		goto err_out;</a>
<a name="ln2368">	}</a>
<a name="ln2369">	/* found attribute */</a>
<a name="ln2370">	a = (ATTR_RECORD*)ctx-&gt;attr;</a>
<a name="ln2371">	collation_rule = ((INDEX_ROOT*)((u8*)a +</a>
<a name="ln2372">			le16_to_cpu(a-&gt;value_offset)))-&gt;collation_rule;</a>
<a name="ln2373">	idx_header = (INDEX_HEADER*)((u8*)a + le16_to_cpu(a-&gt;value_offset)</a>
<a name="ln2374">			+ 0x10);</a>
<a name="ln2375">	idx_entry = (INDEX_ENTRY*)((u8*)idx_header +</a>
<a name="ln2376">			le32_to_cpu(idx_header-&gt;entries_offset));</a>
<a name="ln2377">	idx_end = (INDEX_ENTRY*)((u8*)idx_entry +</a>
<a name="ln2378">			le32_to_cpu(idx_header-&gt;index_length));</a>
<a name="ln2379">	/*</a>
<a name="ln2380">	 * Loop until we exceed valid memory (corruption case) or until we</a>
<a name="ln2381">	 * reach the last entry.</a>
<a name="ln2382">	 */</a>
<a name="ln2383">	if (type == AT_FILE_NAME) {</a>
<a name="ln2384">		while (((u8*)idx_entry &lt; (u8*)idx_end) &amp;&amp;</a>
<a name="ln2385">				!(idx_entry-&gt;ie_flags &amp; INDEX_ENTRY_END)) {</a>
<a name="ln2386">			/*</a>
<a name="ln2387">			i = ntfs_file_values_compare(&amp;idx-&gt;key.file_name,</a>
<a name="ln2388">					&amp;idx_entry-&gt;key.file_name, 1,</a>
<a name="ln2389">					IGNORE_CASE, g_vol-&gt;upcase,</a>
<a name="ln2390">					g_vol-&gt;upcase_len);</a>
<a name="ln2391">			*/</a>
<a name="ln2392">			i = ntfs_names_full_collate(idx-&gt;key.file_name.file_name, idx-&gt;key.file_name.file_name_length,</a>
<a name="ln2393">					idx_entry-&gt;key.file_name.file_name, idx_entry-&gt;key.file_name.file_name_length,</a>
<a name="ln2394">					IGNORE_CASE, g_vol-&gt;upcase,</a>
<a name="ln2395">					g_vol-&gt;upcase_len);</a>
<a name="ln2396">			/*</a>
<a name="ln2397">			 * If @file_name collates before ie-&gt;key.file_name,</a>
<a name="ln2398">			 * there is no matching index entry.</a>
<a name="ln2399">			 */</a>
<a name="ln2400">			if (i == -1)</a>
<a name="ln2401">				break;</a>
<a name="ln2402">			/* If file names are not equal, continue search. */</a>
<a name="ln2403">			if (i)</a>
<a name="ln2404">				goto do_next;</a>
<a name="ln2405">			if (idx-&gt;key.file_name.file_name_type !=</a>
<a name="ln2406">					FILE_NAME_POSIX ||</a>
<a name="ln2407">					idx_entry-&gt;key.file_name.file_name_type</a>
<a name="ln2408">					!= FILE_NAME_POSIX)</a>
<a name="ln2409">				return -EEXIST;</a>
<a name="ln2410">			/*</a>
<a name="ln2411">			i = ntfs_file_values_compare(&amp;idx-&gt;key.file_name,</a>
<a name="ln2412">					&amp;idx_entry-&gt;key.file_name, 1,</a>
<a name="ln2413">					CASE_SENSITIVE, g_vol-&gt;upcase,</a>
<a name="ln2414">					g_vol-&gt;upcase_len);</a>
<a name="ln2415">			*/</a>
<a name="ln2416">			i = ntfs_names_full_collate(idx-&gt;key.file_name.file_name, idx-&gt;key.file_name.file_name_length,</a>
<a name="ln2417">					idx_entry-&gt;key.file_name.file_name, idx_entry-&gt;key.file_name.file_name_length,</a>
<a name="ln2418">					CASE_SENSITIVE, g_vol-&gt;upcase,</a>
<a name="ln2419">					g_vol-&gt;upcase_len);</a>
<a name="ln2420">			if (!i)</a>
<a name="ln2421">				return -EEXIST;</a>
<a name="ln2422">			if (i == -1)</a>
<a name="ln2423">				break;</a>
<a name="ln2424">do_next:</a>
<a name="ln2425">			idx_entry = (INDEX_ENTRY*)((u8*)idx_entry +</a>
<a name="ln2426">					le16_to_cpu(idx_entry-&gt;length));</a>
<a name="ln2427">		}</a>
<a name="ln2428">	} else if (type == AT_UNUSED) {  /* case view */</a>
<a name="ln2429">		while (((u8*)idx_entry &lt; (u8*)idx_end) &amp;&amp;</a>
<a name="ln2430">				!(idx_entry-&gt;ie_flags &amp; INDEX_ENTRY_END)) {</a>
<a name="ln2431">			i = ntfs_index_keys_compare((u8*)idx + 0x10,</a>
<a name="ln2432">					(u8*)idx_entry + 0x10,</a>
<a name="ln2433">					le16_to_cpu(idx-&gt;key_length),</a>
<a name="ln2434">					le16_to_cpu(idx_entry-&gt;key_length),</a>
<a name="ln2435">					collation_rule);</a>
<a name="ln2436">			if (!i)</a>
<a name="ln2437">				return -EEXIST;</a>
<a name="ln2438">			if (i == -1)</a>
<a name="ln2439">				break;</a>
<a name="ln2440">			idx_entry = (INDEX_ENTRY*)((u8*)idx_entry +</a>
<a name="ln2441">					le16_to_cpu(idx_entry-&gt;length));</a>
<a name="ln2442">		}</a>
<a name="ln2443">	} else</a>
<a name="ln2444">		return -EINVAL;</a>
<a name="ln2445">	memmove((u8*)idx_entry + idx_size, (u8*)idx_entry,</a>
<a name="ln2446">			le32_to_cpu(m-&gt;bytes_in_use) -</a>
<a name="ln2447">			((u8*)idx_entry - (u8*)m));</a>
<a name="ln2448">	memcpy((u8*)idx_entry, (u8*)idx, idx_size);</a>
<a name="ln2449">	/* Adjust various offsets, etc... */</a>
<a name="ln2450">	m-&gt;bytes_in_use = cpu_to_le32(le32_to_cpu(m-&gt;bytes_in_use) + idx_size);</a>
<a name="ln2451">	a-&gt;length = cpu_to_le32(le32_to_cpu(a-&gt;length) + idx_size);</a>
<a name="ln2452">	a-&gt;value_length = cpu_to_le32(le32_to_cpu(a-&gt;value_length) + idx_size);</a>
<a name="ln2453">	idx_header-&gt;index_length = cpu_to_le32(</a>
<a name="ln2454">			le32_to_cpu(idx_header-&gt;index_length) + idx_size);</a>
<a name="ln2455">	idx_header-&gt;allocated_size = cpu_to_le32(</a>
<a name="ln2456">			le32_to_cpu(idx_header-&gt;allocated_size) + idx_size);</a>
<a name="ln2457">err_out:</a>
<a name="ln2458">	if (ctx)</a>
<a name="ln2459">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2460">	return err;</a>
<a name="ln2461">}</a>
<a name="ln2462"> </a>
<a name="ln2463">/**</a>
<a name="ln2464"> * initialize_secure</a>
<a name="ln2465"> *</a>
<a name="ln2466"> * initializes $Secure's $SDH and $SII indexes from $SDS datastream</a>
<a name="ln2467"> */</a>
<a name="ln2468">static int initialize_secure(char *sds, u32 sds_size, MFT_RECORD *m)</a>
<a name="ln2469">{</a>
<a name="ln2470">	int err, sdh_size, sii_size;</a>
<a name="ln2471">	SECURITY_DESCRIPTOR_HEADER *sds_header;</a>
<a name="ln2472">	INDEX_ENTRY *idx_entry_sdh, *idx_entry_sii;</a>
<a name="ln2473">	SDH_INDEX_DATA *sdh_data;</a>
<a name="ln2474">	SII_INDEX_DATA *sii_data;</a>
<a name="ln2475"> </a>
<a name="ln2476">	sds_header = (SECURITY_DESCRIPTOR_HEADER*)sds;</a>
<a name="ln2477">	sdh_size  = sizeof(INDEX_ENTRY_HEADER);</a>
<a name="ln2478">	sdh_size += sizeof(SDH_INDEX_KEY) + sizeof(SDH_INDEX_DATA);</a>
<a name="ln2479">	sii_size  = sizeof(INDEX_ENTRY_HEADER);</a>
<a name="ln2480">	sii_size += sizeof(SII_INDEX_KEY) + sizeof(SII_INDEX_DATA);</a>
<a name="ln2481">	idx_entry_sdh = ntfs_calloc(sizeof(INDEX_ENTRY));</a>
<a name="ln2482">	if (!idx_entry_sdh)</a>
<a name="ln2483">		return -errno;</a>
<a name="ln2484">	idx_entry_sii = ntfs_calloc(sizeof(INDEX_ENTRY));</a>
<a name="ln2485">	if (!idx_entry_sii) {</a>
<a name="ln2486">		free(idx_entry_sdh);</a>
<a name="ln2487">		return -errno;</a>
<a name="ln2488">	}</a>
<a name="ln2489">	err = 0;</a>
<a name="ln2490"> </a>
<a name="ln2491">	while ((char*)sds_header &lt; (char*)sds + sds_size) {</a>
<a name="ln2492">		if (!sds_header-&gt;length)</a>
<a name="ln2493">			break;</a>
<a name="ln2494">		/* SDH index entry */</a>
<a name="ln2495">		idx_entry_sdh-&gt;data_offset = const_cpu_to_le16(0x18);</a>
<a name="ln2496">		idx_entry_sdh-&gt;data_length = const_cpu_to_le16(0x14);</a>
<a name="ln2497">		idx_entry_sdh-&gt;reservedV = const_cpu_to_le32(0x00);</a>
<a name="ln2498">		idx_entry_sdh-&gt;length = const_cpu_to_le16(0x30);</a>
<a name="ln2499">		idx_entry_sdh-&gt;key_length = const_cpu_to_le16(0x08);</a>
<a name="ln2500">		idx_entry_sdh-&gt;ie_flags = const_cpu_to_le16(0x00);</a>
<a name="ln2501">		idx_entry_sdh-&gt;reserved = const_cpu_to_le16(0x00);</a>
<a name="ln2502">		idx_entry_sdh-&gt;key.sdh.hash = sds_header-&gt;hash;</a>
<a name="ln2503">		idx_entry_sdh-&gt;key.sdh.security_id = sds_header-&gt;security_id;</a>
<a name="ln2504">		sdh_data = (SDH_INDEX_DATA*)((u8*)idx_entry_sdh +</a>
<a name="ln2505">				le16_to_cpu(idx_entry_sdh-&gt;data_offset));</a>
<a name="ln2506">		sdh_data-&gt;hash = sds_header-&gt;hash;</a>
<a name="ln2507">		sdh_data-&gt;security_id = sds_header-&gt;security_id;</a>
<a name="ln2508">		sdh_data-&gt;offset = sds_header-&gt;offset;</a>
<a name="ln2509">		sdh_data-&gt;length = sds_header-&gt;length;</a>
<a name="ln2510">		sdh_data-&gt;reserved_II = const_cpu_to_le32(0x00490049);</a>
<a name="ln2511"> </a>
<a name="ln2512">		/* SII index entry */</a>
<a name="ln2513">		idx_entry_sii-&gt;data_offset = const_cpu_to_le16(0x14);</a>
<a name="ln2514">		idx_entry_sii-&gt;data_length = const_cpu_to_le16(0x14);</a>
<a name="ln2515">		idx_entry_sii-&gt;reservedV = const_cpu_to_le32(0x00);</a>
<a name="ln2516">		idx_entry_sii-&gt;length = const_cpu_to_le16(0x28);</a>
<a name="ln2517">		idx_entry_sii-&gt;key_length = const_cpu_to_le16(0x04);</a>
<a name="ln2518">		idx_entry_sii-&gt;ie_flags = const_cpu_to_le16(0x00);</a>
<a name="ln2519">		idx_entry_sii-&gt;reserved = const_cpu_to_le16(0x00);</a>
<a name="ln2520">		idx_entry_sii-&gt;key.sii.security_id = sds_header-&gt;security_id;</a>
<a name="ln2521">		sii_data = (SII_INDEX_DATA*)((u8*)idx_entry_sii +</a>
<a name="ln2522">				le16_to_cpu(idx_entry_sii-&gt;data_offset));</a>
<a name="ln2523">		sii_data-&gt;hash = sds_header-&gt;hash;</a>
<a name="ln2524">		sii_data-&gt;security_id = sds_header-&gt;security_id;</a>
<a name="ln2525">		sii_data-&gt;offset = sds_header-&gt;offset;</a>
<a name="ln2526">		sii_data-&gt;length = sds_header-&gt;length;</a>
<a name="ln2527">		if ((err = insert_index_entry_in_res_dir_index(idx_entry_sdh,</a>
<a name="ln2528">				sdh_size, m, NTFS_INDEX_SDH, 4, AT_UNUSED)))</a>
<a name="ln2529">			break;</a>
<a name="ln2530">		if ((err = insert_index_entry_in_res_dir_index(idx_entry_sii,</a>
<a name="ln2531">				sii_size, m, NTFS_INDEX_SII, 4, AT_UNUSED)))</a>
<a name="ln2532">			break;</a>
<a name="ln2533">		sds_header = (SECURITY_DESCRIPTOR_HEADER*)((u8*)sds_header +</a>
<a name="ln2534">				((le32_to_cpu(sds_header-&gt;length) + 15) &amp; ~15));</a>
<a name="ln2535">	}</a>
<a name="ln2536">	free(idx_entry_sdh);</a>
<a name="ln2537">	free(idx_entry_sii);</a>
<a name="ln2538">	return err;</a>
<a name="ln2539">}</a>
<a name="ln2540"> </a>
<a name="ln2541">/**</a>
<a name="ln2542"> * initialize_quota</a>
<a name="ln2543"> *</a>
<a name="ln2544"> * initialize $Quota with the default quota index-entries.</a>
<a name="ln2545"> */</a>
<a name="ln2546">static int initialize_quota(MFT_RECORD *m)</a>
<a name="ln2547">{</a>
<a name="ln2548">	int o_size, q1_size, q2_size, err, i;</a>
<a name="ln2549">	INDEX_ENTRY *idx_entry_o, *idx_entry_q1, *idx_entry_q2;</a>
<a name="ln2550">	QUOTA_O_INDEX_DATA *idx_entry_o_data;</a>
<a name="ln2551">	QUOTA_CONTROL_ENTRY *idx_entry_q1_data, *idx_entry_q2_data;</a>
<a name="ln2552"> </a>
<a name="ln2553">	err = 0;</a>
<a name="ln2554">	/* q index entry num 1 */</a>
<a name="ln2555">	q1_size = 0x48;</a>
<a name="ln2556">	idx_entry_q1 = ntfs_calloc(q1_size);</a>
<a name="ln2557">	if (!idx_entry_q1)</a>
<a name="ln2558">		return errno;</a>
<a name="ln2559">	idx_entry_q1-&gt;data_offset = const_cpu_to_le16(0x14);</a>
<a name="ln2560">	idx_entry_q1-&gt;data_length = const_cpu_to_le16(0x30);</a>
<a name="ln2561">	idx_entry_q1-&gt;reservedV = const_cpu_to_le32(0x00);</a>
<a name="ln2562">	idx_entry_q1-&gt;length = const_cpu_to_le16(0x48);</a>
<a name="ln2563">	idx_entry_q1-&gt;key_length = const_cpu_to_le16(0x04);</a>
<a name="ln2564">	idx_entry_q1-&gt;ie_flags = const_cpu_to_le16(0x00);</a>
<a name="ln2565">	idx_entry_q1-&gt;reserved = const_cpu_to_le16(0x00);</a>
<a name="ln2566">	idx_entry_q1-&gt;key.owner_id = const_cpu_to_le32(0x01);</a>
<a name="ln2567">	idx_entry_q1_data = (QUOTA_CONTROL_ENTRY*)((char*)idx_entry_q1</a>
<a name="ln2568">			+ le16_to_cpu(idx_entry_q1-&gt;data_offset));</a>
<a name="ln2569">	idx_entry_q1_data-&gt;version = const_cpu_to_le32(0x02);</a>
<a name="ln2570">	idx_entry_q1_data-&gt;flags = QUOTA_FLAG_DEFAULT_LIMITS;</a>
<a name="ln2571">	idx_entry_q1_data-&gt;bytes_used = const_cpu_to_le64(0x00);</a>
<a name="ln2572">	idx_entry_q1_data-&gt;change_time = mkntfs_time();</a>
<a name="ln2573">	idx_entry_q1_data-&gt;threshold = cpu_to_sle64(-1);</a>
<a name="ln2574">	idx_entry_q1_data-&gt;limit = cpu_to_sle64(-1);</a>
<a name="ln2575">	idx_entry_q1_data-&gt;exceeded_time = const_cpu_to_le64(0);</a>
<a name="ln2576">	err = insert_index_entry_in_res_dir_index(idx_entry_q1, q1_size, m,</a>
<a name="ln2577">			NTFS_INDEX_Q, 2, AT_UNUSED);</a>
<a name="ln2578">	free(idx_entry_q1);</a>
<a name="ln2579">	if (err)</a>
<a name="ln2580">		return err;</a>
<a name="ln2581">	/* q index entry num 2 */</a>
<a name="ln2582">	q2_size = 0x58;</a>
<a name="ln2583">	idx_entry_q2 = ntfs_calloc(q2_size);</a>
<a name="ln2584">	if (!idx_entry_q2)</a>
<a name="ln2585">		return errno;</a>
<a name="ln2586">	idx_entry_q2-&gt;data_offset = const_cpu_to_le16(0x14);</a>
<a name="ln2587">	idx_entry_q2-&gt;data_length = const_cpu_to_le16(0x40);</a>
<a name="ln2588">	idx_entry_q2-&gt;reservedV = const_cpu_to_le32(0x00);</a>
<a name="ln2589">	idx_entry_q2-&gt;length = const_cpu_to_le16(0x58);</a>
<a name="ln2590">	idx_entry_q2-&gt;key_length = const_cpu_to_le16(0x04);</a>
<a name="ln2591">	idx_entry_q2-&gt;ie_flags = const_cpu_to_le16(0x00);</a>
<a name="ln2592">	idx_entry_q2-&gt;reserved = const_cpu_to_le16(0x00);</a>
<a name="ln2593">	idx_entry_q2-&gt;key.owner_id = QUOTA_FIRST_USER_ID;</a>
<a name="ln2594">	idx_entry_q2_data = (QUOTA_CONTROL_ENTRY*)((char*)idx_entry_q2</a>
<a name="ln2595">			+ le16_to_cpu(idx_entry_q2-&gt;data_offset));</a>
<a name="ln2596">	idx_entry_q2_data-&gt;version = const_cpu_to_le32(0x02);</a>
<a name="ln2597">	idx_entry_q2_data-&gt;flags = QUOTA_FLAG_DEFAULT_LIMITS;</a>
<a name="ln2598">	idx_entry_q2_data-&gt;bytes_used = const_cpu_to_le64(0x00);</a>
<a name="ln2599">	idx_entry_q2_data-&gt;change_time = mkntfs_time();</a>
<a name="ln2600">	idx_entry_q2_data-&gt;threshold = cpu_to_sle64(-1);</a>
<a name="ln2601">	idx_entry_q2_data-&gt;limit = cpu_to_sle64(-1);</a>
<a name="ln2602">	idx_entry_q2_data-&gt;exceeded_time = const_cpu_to_le64(0);</a>
<a name="ln2603">	idx_entry_q2_data-&gt;sid.revision = 1;</a>
<a name="ln2604">	idx_entry_q2_data-&gt;sid.sub_authority_count = 2;</a>
<a name="ln2605">	for (i = 0; i &lt; 5; i++)</a>
<a name="ln2606">		idx_entry_q2_data-&gt;sid.identifier_authority.value[i] = 0;</a>
<a name="ln2607">	idx_entry_q2_data-&gt;sid.identifier_authority.value[5] = 0x05;</a>
<a name="ln2608">	idx_entry_q2_data-&gt;sid.sub_authority[0] =</a>
<a name="ln2609">			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);</a>
<a name="ln2610">	idx_entry_q2_data-&gt;sid.sub_authority[1] =</a>
<a name="ln2611">			const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);</a>
<a name="ln2612">	err = insert_index_entry_in_res_dir_index(idx_entry_q2, q2_size, m,</a>
<a name="ln2613">			NTFS_INDEX_Q, 2, AT_UNUSED);</a>
<a name="ln2614">	free(idx_entry_q2);</a>
<a name="ln2615">	if (err)</a>
<a name="ln2616">		return err;</a>
<a name="ln2617">	o_size = 0x28;</a>
<a name="ln2618">	idx_entry_o = ntfs_calloc(o_size);</a>
<a name="ln2619">	if (!idx_entry_o)</a>
<a name="ln2620">		return errno;</a>
<a name="ln2621">	idx_entry_o-&gt;data_offset = const_cpu_to_le16(0x20);</a>
<a name="ln2622">	idx_entry_o-&gt;data_length = const_cpu_to_le16(0x04);</a>
<a name="ln2623">	idx_entry_o-&gt;reservedV = const_cpu_to_le32(0x00);</a>
<a name="ln2624">	idx_entry_o-&gt;length = const_cpu_to_le16(0x28);</a>
<a name="ln2625">	idx_entry_o-&gt;key_length = const_cpu_to_le16(0x10);</a>
<a name="ln2626">	idx_entry_o-&gt;ie_flags = const_cpu_to_le16(0x00);</a>
<a name="ln2627">	idx_entry_o-&gt;reserved = const_cpu_to_le16(0x00);</a>
<a name="ln2628">	idx_entry_o-&gt;key.sid.revision = 0x01;</a>
<a name="ln2629">	idx_entry_o-&gt;key.sid.sub_authority_count = 0x02;</a>
<a name="ln2630">	for (i = 0; i &lt; 5; i++)</a>
<a name="ln2631">		idx_entry_o-&gt;key.sid.identifier_authority.value[i] = 0;</a>
<a name="ln2632">	idx_entry_o-&gt;key.sid.identifier_authority.value[5] = 0x05;</a>
<a name="ln2633">	idx_entry_o-&gt;key.sid.sub_authority[0] =</a>
<a name="ln2634">			const_cpu_to_le32(SECURITY_BUILTIN_DOMAIN_RID);</a>
<a name="ln2635">	idx_entry_o-&gt;key.sid.sub_authority[1] =</a>
<a name="ln2636">			const_cpu_to_le32(DOMAIN_ALIAS_RID_ADMINS);</a>
<a name="ln2637">	idx_entry_o_data = (QUOTA_O_INDEX_DATA*)((char*)idx_entry_o</a>
<a name="ln2638">			+ le16_to_cpu(idx_entry_o-&gt;data_offset));</a>
<a name="ln2639">	idx_entry_o_data-&gt;owner_id  = QUOTA_FIRST_USER_ID;</a>
<a name="ln2640">	/* 20 00 00 00 padding after here on ntfs 3.1. 3.0 is unchecked. */</a>
<a name="ln2641">	idx_entry_o_data-&gt;unknown = const_cpu_to_le32(32);</a>
<a name="ln2642">	err = insert_index_entry_in_res_dir_index(idx_entry_o, o_size, m,</a>
<a name="ln2643">			NTFS_INDEX_O, 2, AT_UNUSED);</a>
<a name="ln2644">	free(idx_entry_o);</a>
<a name="ln2645"> </a>
<a name="ln2646">	return err;</a>
<a name="ln2647">}</a>
<a name="ln2648"> </a>
<a name="ln2649">/**</a>
<a name="ln2650"> * insert_file_link_in_dir_index</a>
<a name="ln2651"> *</a>
<a name="ln2652"> * Insert the fully completed FILE_NAME_ATTR @file_name which is inside</a>
<a name="ln2653"> * the file with mft reference @file_ref into the index (allocation) block</a>
<a name="ln2654"> * @idx (which belongs to @file_ref's parent directory).</a>
<a name="ln2655"> *</a>
<a name="ln2656"> * Return 0 on success or -errno on error.</a>
<a name="ln2657"> */</a>
<a name="ln2658">static int insert_file_link_in_dir_index(INDEX_BLOCK *idx, leMFT_REF file_ref,</a>
<a name="ln2659">		FILE_NAME_ATTR *file_name, u32 file_name_size)</a>
<a name="ln2660">{</a>
<a name="ln2661">	int err, i;</a>
<a name="ln2662">	INDEX_ENTRY *ie;</a>
<a name="ln2663">	char *index_end;</a>
<a name="ln2664"> </a>
<a name="ln2665">	/*</a>
<a name="ln2666">	 * Lookup dir entry @file_name in dir @idx to determine correct</a>
<a name="ln2667">	 * insertion location. FIXME: Using a very oversimplified lookup</a>
<a name="ln2668">	 * method which is sufficient for mkntfs but no good whatsoever in</a>
<a name="ln2669">	 * real world scenario. (AIA)</a>
<a name="ln2670">	 */</a>
<a name="ln2671"> </a>
<a name="ln2672">	index_end = (char*)&amp;idx-&gt;index + le32_to_cpu(idx-&gt;index.index_length);</a>
<a name="ln2673">	ie = (INDEX_ENTRY*)((char*)&amp;idx-&gt;index +</a>
<a name="ln2674">			le32_to_cpu(idx-&gt;index.entries_offset));</a>
<a name="ln2675">	/*</a>
<a name="ln2676">	 * Loop until we exceed valid memory (corruption case) or until we</a>
<a name="ln2677">	 * reach the last entry.</a>
<a name="ln2678">	 */</a>
<a name="ln2679">	while ((char*)ie &lt; index_end &amp;&amp; !(ie-&gt;ie_flags &amp; INDEX_ENTRY_END)) {</a>
<a name="ln2680">#if 0</a>
<a name="ln2681">#ifdef DEBUG</a>
<a name="ln2682">		ntfs_log_debug(&quot;file_name_attr1-&gt;file_name_length = %i\n&quot;,</a>
<a name="ln2683">				file_name-&gt;file_name_length);</a>
<a name="ln2684">		if (file_name-&gt;file_name_length) {</a>
<a name="ln2685">			char *__buf = NULL;</a>
<a name="ln2686">			i = ntfs_ucstombs((ntfschar*)&amp;file_name-&gt;file_name,</a>
<a name="ln2687">				file_name-&gt;file_name_length, &amp;__buf, 0);</a>
<a name="ln2688">			if (i &lt; 0)</a>
<a name="ln2689">				ntfs_log_debug(&quot;Name contains non-displayable &quot;</a>
<a name="ln2690">						&quot;Unicode characters.\n&quot;);</a>
<a name="ln2691">			ntfs_log_debug(&quot;file_name_attr1-&gt;file_name = %s\n&quot;,</a>
<a name="ln2692">					__buf);</a>
<a name="ln2693">			free(__buf);</a>
<a name="ln2694">		}</a>
<a name="ln2695">		ntfs_log_debug(&quot;file_name_attr2-&gt;file_name_length = %i\n&quot;,</a>
<a name="ln2696">				ie-&gt;key.file_name.file_name_length);</a>
<a name="ln2697">		if (ie-&gt;key.file_name.file_name_length) {</a>
<a name="ln2698">			char *__buf = NULL;</a>
<a name="ln2699">			i = ntfs_ucstombs(ie-&gt;key.file_name.file_name,</a>
<a name="ln2700">				ie-&gt;key.file_name.file_name_length + 1, &amp;__buf,</a>
<a name="ln2701">				0);</a>
<a name="ln2702">			if (i &lt; 0)</a>
<a name="ln2703">				ntfs_log_debug(&quot;Name contains non-displayable &quot;</a>
<a name="ln2704">						&quot;Unicode characters.\n&quot;);</a>
<a name="ln2705">			ntfs_log_debug(&quot;file_name_attr2-&gt;file_name = %s\n&quot;,</a>
<a name="ln2706">					__buf);</a>
<a name="ln2707">			free(__buf);</a>
<a name="ln2708">		}</a>
<a name="ln2709">#endif</a>
<a name="ln2710">#endif</a>
<a name="ln2711">		/*</a>
<a name="ln2712">		i = ntfs_file_values_compare(file_name,</a>
<a name="ln2713">				(FILE_NAME_ATTR*)&amp;ie-&gt;key.file_name, 1,</a>
<a name="ln2714">				IGNORE_CASE, g_vol-&gt;upcase, g_vol-&gt;upcase_len);</a>
<a name="ln2715">		*/</a>
<a name="ln2716">		i = ntfs_names_full_collate(file_name-&gt;file_name, file_name-&gt;file_name_length,</a>
<a name="ln2717">				((FILE_NAME_ATTR*)&amp;ie-&gt;key.file_name)-&gt;file_name, ((FILE_NAME_ATTR*)&amp;ie-&gt;key.file_name)-&gt;file_name_length,</a>
<a name="ln2718">				IGNORE_CASE, g_vol-&gt;upcase, g_vol-&gt;upcase_len);</a>
<a name="ln2719">		/*</a>
<a name="ln2720">		 * If @file_name collates before ie-&gt;key.file_name, there is no</a>
<a name="ln2721">		 * matching index entry.</a>
<a name="ln2722">		 */</a>
<a name="ln2723">		if (i == -1)</a>
<a name="ln2724">			break;</a>
<a name="ln2725">		/* If file names are not equal, continue search. */</a>
<a name="ln2726">		if (i)</a>
<a name="ln2727">			goto do_next;</a>
<a name="ln2728">		/* File names are equal when compared ignoring case. */</a>
<a name="ln2729">		/*</a>
<a name="ln2730">		 * If BOTH file names are in the POSIX namespace, do a case</a>
<a name="ln2731">		 * sensitive comparison as well. Otherwise the names match so</a>
<a name="ln2732">		 * we return -EEXIST. FIXME: There are problems with this in a</a>
<a name="ln2733">		 * real world scenario, when one is POSIX and one isn't, but</a>
<a name="ln2734">		 * fine for mkntfs where we don't use POSIX namespace at all</a>
<a name="ln2735">		 * and hence this following code is luxury. (AIA)</a>
<a name="ln2736">		 */</a>
<a name="ln2737">		if (file_name-&gt;file_name_type != FILE_NAME_POSIX ||</a>
<a name="ln2738">		    ie-&gt;key.file_name.file_name_type != FILE_NAME_POSIX)</a>
<a name="ln2739">			return -EEXIST;</a>
<a name="ln2740">		/*</a>
<a name="ln2741">		i = ntfs_file_values_compare(file_name,</a>
<a name="ln2742">				(FILE_NAME_ATTR*)&amp;ie-&gt;key.file_name, 1,</a>
<a name="ln2743">				CASE_SENSITIVE, g_vol-&gt;upcase,</a>
<a name="ln2744">				g_vol-&gt;upcase_len);</a>
<a name="ln2745">		*/</a>
<a name="ln2746">		i = ntfs_names_full_collate(file_name-&gt;file_name, file_name-&gt;file_name_length,</a>
<a name="ln2747">				((FILE_NAME_ATTR*)&amp;ie-&gt;key.file_name)-&gt;file_name, ((FILE_NAME_ATTR*)&amp;ie-&gt;key.file_name)-&gt;file_name_length,</a>
<a name="ln2748">				CASE_SENSITIVE, g_vol-&gt;upcase, g_vol-&gt;upcase_len);</a>
<a name="ln2749">		if (i == -1)</a>
<a name="ln2750">			break;</a>
<a name="ln2751">		/* Complete match. Bugger. Can't insert. */</a>
<a name="ln2752">		if (!i)</a>
<a name="ln2753">			return -EEXIST;</a>
<a name="ln2754">do_next:</a>
<a name="ln2755">#ifdef DEBUG</a>
<a name="ln2756">		/* Next entry. */</a>
<a name="ln2757">		if (!ie-&gt;length) {</a>
<a name="ln2758">			ntfs_log_debug(&quot;BUG: ie-&gt;length is zero, breaking out &quot;</a>
<a name="ln2759">					&quot;of loop.\n&quot;);</a>
<a name="ln2760">			break;</a>
<a name="ln2761">		}</a>
<a name="ln2762">#endif</a>
<a name="ln2763">		ie = (INDEX_ENTRY*)((char*)ie + le16_to_cpu(ie-&gt;length));</a>
<a name="ln2764">	};</a>
<a name="ln2765">	i = (sizeof(INDEX_ENTRY_HEADER) + file_name_size + 7) &amp; ~7;</a>
<a name="ln2766">	err = make_room_for_index_entry_in_index_block(idx, ie, i);</a>
<a name="ln2767">	if (err) {</a>
<a name="ln2768">		ntfs_log_error(&quot;make_room_for_index_entry_in_index_block &quot;</a>
<a name="ln2769">				&quot;failed: %s\n&quot;, strerror(-err));</a>
<a name="ln2770">		return err;</a>
<a name="ln2771">	}</a>
<a name="ln2772">	/* Create entry in place and copy file name attribute value. */</a>
<a name="ln2773">	ie-&gt;indexed_file = file_ref;</a>
<a name="ln2774">	ie-&gt;length = cpu_to_le16(i);</a>
<a name="ln2775">	ie-&gt;key_length = cpu_to_le16(file_name_size);</a>
<a name="ln2776">	ie-&gt;ie_flags = cpu_to_le16(0);</a>
<a name="ln2777">	ie-&gt;reserved = cpu_to_le16(0);</a>
<a name="ln2778">	memcpy((char*)&amp;ie-&gt;key.file_name, (char*)file_name, file_name_size);</a>
<a name="ln2779">	return 0;</a>
<a name="ln2780">}</a>
<a name="ln2781"> </a>
<a name="ln2782">/**</a>
<a name="ln2783"> * create_hardlink_res</a>
<a name="ln2784"> *</a>
<a name="ln2785"> * Create a file_name_attribute in the mft record @m_file which points to the</a>
<a name="ln2786"> * parent directory with mft reference @ref_parent.</a>
<a name="ln2787"> *</a>
<a name="ln2788"> * Then, insert an index entry with this file_name_attribute in the index</a>
<a name="ln2789"> * root @idx of the index_root attribute of the parent directory.</a>
<a name="ln2790"> *</a>
<a name="ln2791"> * @ref_file is the mft reference of @m_file.</a>
<a name="ln2792"> *</a>
<a name="ln2793"> * Return 0 on success or -errno on error.</a>
<a name="ln2794"> */</a>
<a name="ln2795">static int create_hardlink_res(MFT_RECORD *m_parent, const leMFT_REF ref_parent,</a>
<a name="ln2796">		MFT_RECORD *m_file, const leMFT_REF ref_file,</a>
<a name="ln2797">		const s64 allocated_size, const s64 data_size,</a>
<a name="ln2798">		const FILE_ATTR_FLAGS flags, const u16 packed_ea_size,</a>
<a name="ln2799">		const u32 reparse_point_tag, const char *file_name,</a>
<a name="ln2800">		const FILE_NAME_TYPE_FLAGS file_name_type)</a>
<a name="ln2801">{</a>
<a name="ln2802">	FILE_NAME_ATTR *fn;</a>
<a name="ln2803">	int i, fn_size, idx_size;</a>
<a name="ln2804">	INDEX_ENTRY *idx_entry_new;</a>
<a name="ln2805">	ntfschar *uname;</a>
<a name="ln2806"> </a>
<a name="ln2807">	/* Create the file_name attribute. */</a>
<a name="ln2808">	i = (strlen(file_name) + 1) * sizeof(ntfschar);</a>
<a name="ln2809">	fn_size = sizeof(FILE_NAME_ATTR) + i;</a>
<a name="ln2810">	fn = ntfs_malloc(fn_size);</a>
<a name="ln2811">	if (!fn)</a>
<a name="ln2812">		return -errno;</a>
<a name="ln2813">	fn-&gt;parent_directory = ref_parent;</a>
<a name="ln2814">	fn-&gt;creation_time = stdinfo_time(m_file);</a>
<a name="ln2815">	fn-&gt;last_data_change_time = fn-&gt;creation_time;</a>
<a name="ln2816">	fn-&gt;last_mft_change_time = fn-&gt;creation_time;</a>
<a name="ln2817">	fn-&gt;last_access_time = fn-&gt;creation_time;</a>
<a name="ln2818">	fn-&gt;allocated_size = cpu_to_sle64(allocated_size);</a>
<a name="ln2819">	fn-&gt;data_size = cpu_to_sle64(data_size);</a>
<a name="ln2820">	fn-&gt;file_attributes = flags;</a>
<a name="ln2821">	/* These are in a union so can't have both. */</a>
<a name="ln2822">	if (packed_ea_size &amp;&amp; reparse_point_tag) {</a>
<a name="ln2823">		free(fn);</a>
<a name="ln2824">		return -EINVAL;</a>
<a name="ln2825">	}</a>
<a name="ln2826">	if (packed_ea_size) {</a>
<a name="ln2827">		free(fn);</a>
<a name="ln2828">		return -EINVAL;</a>
<a name="ln2829">	}</a>
<a name="ln2830">	if (packed_ea_size) {</a>
<a name="ln2831">		fn-&gt;packed_ea_size = cpu_to_le16(packed_ea_size);</a>
<a name="ln2832">		fn-&gt;reserved = cpu_to_le16(0);</a>
<a name="ln2833">	} else {</a>
<a name="ln2834">		fn-&gt;reparse_point_tag = cpu_to_le32(reparse_point_tag);</a>
<a name="ln2835">	}</a>
<a name="ln2836">	fn-&gt;file_name_type = file_name_type;</a>
<a name="ln2837">	uname = fn-&gt;file_name;</a>
<a name="ln2838">	i = ntfs_mbstoucs_libntfscompat(file_name, &amp;uname, i);</a>
<a name="ln2839">	if (i &lt; 1) {</a>
<a name="ln2840">		free(fn);</a>
<a name="ln2841">		return -EINVAL;</a>
<a name="ln2842">	}</a>
<a name="ln2843">	if (i &gt; 0xff) {</a>
<a name="ln2844">		free(fn);</a>
<a name="ln2845">		return -ENAMETOOLONG;</a>
<a name="ln2846">	}</a>
<a name="ln2847">	/* No terminating null in file names. */</a>
<a name="ln2848">	fn-&gt;file_name_length = i;</a>
<a name="ln2849">	fn_size = sizeof(FILE_NAME_ATTR) + i * sizeof(ntfschar);</a>
<a name="ln2850">	/* Increment the link count of @m_file. */</a>
<a name="ln2851">	i = le16_to_cpu(m_file-&gt;link_count);</a>
<a name="ln2852">	if (i == 0xffff) {</a>
<a name="ln2853">		ntfs_log_error(&quot;Too many hardlinks present already.\n&quot;);</a>
<a name="ln2854">		free(fn);</a>
<a name="ln2855">		return -EINVAL;</a>
<a name="ln2856">	}</a>
<a name="ln2857">	m_file-&gt;link_count = cpu_to_le16(i + 1);</a>
<a name="ln2858">	/* Add the file_name to @m_file. */</a>
<a name="ln2859">	i = insert_resident_attr_in_mft_record(m_file, AT_FILE_NAME, NULL, 0,</a>
<a name="ln2860">			CASE_SENSITIVE, const_cpu_to_le16(0),</a>
<a name="ln2861">			RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);</a>
<a name="ln2862">	if (i &lt; 0) {</a>
<a name="ln2863">		ntfs_log_error(&quot;create_hardlink failed adding file name &quot;</a>
<a name="ln2864">				&quot;attribute: %s\n&quot;, strerror(-i));</a>
<a name="ln2865">		free(fn);</a>
<a name="ln2866">		/* Undo link count increment. */</a>
<a name="ln2867">		m_file-&gt;link_count = cpu_to_le16(</a>
<a name="ln2868">				le16_to_cpu(m_file-&gt;link_count) - 1);</a>
<a name="ln2869">		return i;</a>
<a name="ln2870">	}</a>
<a name="ln2871">	/* Insert the index entry for file_name in @idx. */</a>
<a name="ln2872">	idx_size = (fn_size + 7)  &amp; ~7;</a>
<a name="ln2873">	idx_entry_new = ntfs_calloc(idx_size + 0x10);</a>
<a name="ln2874">	if (!idx_entry_new)</a>
<a name="ln2875">		return -errno;</a>
<a name="ln2876">	idx_entry_new-&gt;indexed_file = ref_file;</a>
<a name="ln2877">	idx_entry_new-&gt;length = cpu_to_le16(idx_size + 0x10);</a>
<a name="ln2878">	idx_entry_new-&gt;key_length = cpu_to_le16(fn_size);</a>
<a name="ln2879">	memcpy((u8*)idx_entry_new + 0x10, (u8*)fn, fn_size);</a>
<a name="ln2880">	i = insert_index_entry_in_res_dir_index(idx_entry_new, idx_size + 0x10,</a>
<a name="ln2881">			m_parent, NTFS_INDEX_I30, 4, AT_FILE_NAME);</a>
<a name="ln2882">	if (i &lt; 0) {</a>
<a name="ln2883">		ntfs_log_error(&quot;create_hardlink failed inserting index entry: &quot;</a>
<a name="ln2884">				&quot;%s\n&quot;, strerror(-i));</a>
<a name="ln2885">		/* FIXME: Remove the file name attribute from @m_file. */</a>
<a name="ln2886">		free(idx_entry_new);</a>
<a name="ln2887">		free(fn);</a>
<a name="ln2888">		/* Undo link count increment. */</a>
<a name="ln2889">		m_file-&gt;link_count = cpu_to_le16(</a>
<a name="ln2890">				le16_to_cpu(m_file-&gt;link_count) - 1);</a>
<a name="ln2891">		return i;</a>
<a name="ln2892">	}</a>
<a name="ln2893">	free(idx_entry_new);</a>
<a name="ln2894">	free(fn);</a>
<a name="ln2895">	return 0;</a>
<a name="ln2896">}</a>
<a name="ln2897"> </a>
<a name="ln2898">/**</a>
<a name="ln2899"> * create_hardlink</a>
<a name="ln2900"> *</a>
<a name="ln2901"> * Create a file_name_attribute in the mft record @m_file which points to the</a>
<a name="ln2902"> * parent directory with mft reference @ref_parent.</a>
<a name="ln2903"> *</a>
<a name="ln2904"> * Then, insert an index entry with this file_name_attribute in the index</a>
<a name="ln2905"> * block @idx of the index allocation attribute of the parent directory.</a>
<a name="ln2906"> *</a>
<a name="ln2907"> * @ref_file is the mft reference of @m_file.</a>
<a name="ln2908"> *</a>
<a name="ln2909"> * Return 0 on success or -errno on error.</a>
<a name="ln2910"> */</a>
<a name="ln2911">static int create_hardlink(INDEX_BLOCK *idx, const leMFT_REF ref_parent,</a>
<a name="ln2912">		MFT_RECORD *m_file, const leMFT_REF ref_file,</a>
<a name="ln2913">		const s64 allocated_size, const s64 data_size,</a>
<a name="ln2914">		const FILE_ATTR_FLAGS flags, const u16 packed_ea_size,</a>
<a name="ln2915">		const u32 reparse_point_tag, const char *file_name,</a>
<a name="ln2916">		const FILE_NAME_TYPE_FLAGS file_name_type)</a>
<a name="ln2917">{</a>
<a name="ln2918">	FILE_NAME_ATTR *fn;</a>
<a name="ln2919">	int i, fn_size;</a>
<a name="ln2920">	ntfschar *uname;</a>
<a name="ln2921"> </a>
<a name="ln2922">	/* Create the file_name attribute. */</a>
<a name="ln2923">	i = (strlen(file_name) + 1) * sizeof(ntfschar);</a>
<a name="ln2924">	fn_size = sizeof(FILE_NAME_ATTR) + i;</a>
<a name="ln2925">	fn = ntfs_malloc(fn_size);</a>
<a name="ln2926">	if (!fn)</a>
<a name="ln2927">		return -errno;</a>
<a name="ln2928">	fn-&gt;parent_directory = ref_parent;</a>
<a name="ln2929">	fn-&gt;creation_time = stdinfo_time(m_file);</a>
<a name="ln2930">	fn-&gt;last_data_change_time = fn-&gt;creation_time;</a>
<a name="ln2931">	fn-&gt;last_mft_change_time = fn-&gt;creation_time;</a>
<a name="ln2932">	fn-&gt;last_access_time = fn-&gt;creation_time;</a>
<a name="ln2933">		/* allocated size depends on unnamed data being resident */</a>
<a name="ln2934">	if (allocated_size &amp;&amp; non_resident_unnamed_data(m_file))</a>
<a name="ln2935">		fn-&gt;allocated_size = cpu_to_sle64(allocated_size);</a>
<a name="ln2936">	else</a>
<a name="ln2937">		fn-&gt;allocated_size = cpu_to_sle64((data_size + 7) &amp; -8);</a>
<a name="ln2938">	fn-&gt;data_size = cpu_to_sle64(data_size);</a>
<a name="ln2939">	fn-&gt;file_attributes = flags;</a>
<a name="ln2940">	/* These are in a union so can't have both. */</a>
<a name="ln2941">	if (packed_ea_size &amp;&amp; reparse_point_tag) {</a>
<a name="ln2942">		free(fn);</a>
<a name="ln2943">		return -EINVAL;</a>
<a name="ln2944">	}</a>
<a name="ln2945">	if (packed_ea_size) {</a>
<a name="ln2946">		fn-&gt;packed_ea_size = cpu_to_le16(packed_ea_size);</a>
<a name="ln2947">		fn-&gt;reserved = cpu_to_le16(0);</a>
<a name="ln2948">	} else {</a>
<a name="ln2949">		fn-&gt;reparse_point_tag = cpu_to_le32(reparse_point_tag);</a>
<a name="ln2950">	}</a>
<a name="ln2951">	fn-&gt;file_name_type = file_name_type;</a>
<a name="ln2952">	uname = fn-&gt;file_name;</a>
<a name="ln2953">	i = ntfs_mbstoucs_libntfscompat(file_name, &amp;uname, i);</a>
<a name="ln2954">	if (i &lt; 1) {</a>
<a name="ln2955">		free(fn);</a>
<a name="ln2956">		return -EINVAL;</a>
<a name="ln2957">	}</a>
<a name="ln2958">	if (i &gt; 0xff) {</a>
<a name="ln2959">		free(fn);</a>
<a name="ln2960">		return -ENAMETOOLONG;</a>
<a name="ln2961">	}</a>
<a name="ln2962">	/* No terminating null in file names. */</a>
<a name="ln2963">	fn-&gt;file_name_length = i;</a>
<a name="ln2964">	fn_size = sizeof(FILE_NAME_ATTR) + i * sizeof(ntfschar);</a>
<a name="ln2965">	/* Increment the link count of @m_file. */</a>
<a name="ln2966">	i = le16_to_cpu(m_file-&gt;link_count);</a>
<a name="ln2967">	if (i == 0xffff) {</a>
<a name="ln2968">		ntfs_log_error(&quot;Too many hardlinks present already.\n&quot;);</a>
<a name="ln2969">		free(fn);</a>
<a name="ln2970">		return -EINVAL;</a>
<a name="ln2971">	}</a>
<a name="ln2972">	m_file-&gt;link_count = cpu_to_le16(i + 1);</a>
<a name="ln2973">	/* Add the file_name to @m_file. */</a>
<a name="ln2974">	i = insert_resident_attr_in_mft_record(m_file, AT_FILE_NAME, NULL, 0,</a>
<a name="ln2975">			CASE_SENSITIVE, cpu_to_le16(0),</a>
<a name="ln2976">			RESIDENT_ATTR_IS_INDEXED, (u8*)fn, fn_size);</a>
<a name="ln2977">	if (i &lt; 0) {</a>
<a name="ln2978">		ntfs_log_error(&quot;create_hardlink failed adding file name attribute: &quot;</a>
<a name="ln2979">				&quot;%s\n&quot;, strerror(-i));</a>
<a name="ln2980">		free(fn);</a>
<a name="ln2981">		/* Undo link count increment. */</a>
<a name="ln2982">		m_file-&gt;link_count = cpu_to_le16(</a>
<a name="ln2983">				le16_to_cpu(m_file-&gt;link_count) - 1);</a>
<a name="ln2984">		return i;</a>
<a name="ln2985">	}</a>
<a name="ln2986">	/* Insert the index entry for file_name in @idx. */</a>
<a name="ln2987">	i = insert_file_link_in_dir_index(idx, ref_file, fn, fn_size);</a>
<a name="ln2988">	if (i &lt; 0) {</a>
<a name="ln2989">		ntfs_log_error(&quot;create_hardlink failed inserting index entry: %s\n&quot;,</a>
<a name="ln2990">				strerror(-i));</a>
<a name="ln2991">		/* FIXME: Remove the file name attribute from @m_file. */</a>
<a name="ln2992">		free(fn);</a>
<a name="ln2993">		/* Undo link count increment. */</a>
<a name="ln2994">		m_file-&gt;link_count = cpu_to_le16(</a>
<a name="ln2995">				le16_to_cpu(m_file-&gt;link_count) - 1);</a>
<a name="ln2996">		return i;</a>
<a name="ln2997">	}</a>
<a name="ln2998">	free(fn);</a>
<a name="ln2999">	return 0;</a>
<a name="ln3000">}</a>
<a name="ln3001"> </a>
<a name="ln3002">/**</a>
<a name="ln3003"> * index_obj_id_insert</a>
<a name="ln3004"> *</a>
<a name="ln3005"> * Insert an index entry with the key @guid and data pointing to the mft record</a>
<a name="ln3006"> * @ref in the $O index root of the mft record @m (which must be the mft record</a>
<a name="ln3007"> * for $ObjId).</a>
<a name="ln3008"> *</a>
<a name="ln3009"> * Return 0 on success or -errno on error.</a>
<a name="ln3010"> */</a>
<a name="ln3011">static int index_obj_id_insert(MFT_RECORD *m, const GUID *guid,</a>
<a name="ln3012">		const leMFT_REF ref)</a>
<a name="ln3013">{</a>
<a name="ln3014">	INDEX_ENTRY *idx_entry_new;</a>
<a name="ln3015">	int data_ofs, idx_size, err;</a>
<a name="ln3016">	OBJ_ID_INDEX_DATA *oi;</a>
<a name="ln3017"> </a>
<a name="ln3018">	/*</a>
<a name="ln3019">	 * Insert the index entry for the object id in the index.</a>
<a name="ln3020">	 *</a>
<a name="ln3021">	 * First determine the size of the index entry to be inserted.  This</a>
<a name="ln3022">	 * consists of the index entry header, followed by the index key, i.e.</a>
<a name="ln3023">	 * the GUID, followed by the index data, i.e. OBJ_ID_INDEX_DATA.</a>
<a name="ln3024">	 */</a>
<a name="ln3025">	data_ofs = (sizeof(INDEX_ENTRY_HEADER) + sizeof(GUID) + 7) &amp; ~7;</a>
<a name="ln3026">	idx_size = (data_ofs + sizeof(OBJ_ID_INDEX_DATA) + 7) &amp; ~7;</a>
<a name="ln3027">	idx_entry_new = ntfs_calloc(idx_size);</a>
<a name="ln3028">	if (!idx_entry_new)</a>
<a name="ln3029">		return -errno;</a>
<a name="ln3030">	idx_entry_new-&gt;data_offset = cpu_to_le16(data_ofs);</a>
<a name="ln3031">	idx_entry_new-&gt;data_length = cpu_to_le16(sizeof(OBJ_ID_INDEX_DATA));</a>
<a name="ln3032">	idx_entry_new-&gt;length = cpu_to_le16(idx_size);</a>
<a name="ln3033">	idx_entry_new-&gt;key_length = cpu_to_le16(sizeof(GUID));</a>
<a name="ln3034">	idx_entry_new-&gt;key.object_id = *guid;</a>
<a name="ln3035">	oi = (OBJ_ID_INDEX_DATA*)((u8*)idx_entry_new + data_ofs);</a>
<a name="ln3036">	oi-&gt;mft_reference = ref;</a>
<a name="ln3037">	err = insert_index_entry_in_res_dir_index(idx_entry_new, idx_size, m,</a>
<a name="ln3038">			NTFS_INDEX_O, 2, AT_UNUSED);</a>
<a name="ln3039">	free(idx_entry_new);</a>
<a name="ln3040">	if (err &lt; 0) {</a>
<a name="ln3041">		ntfs_log_error(&quot;index_obj_id_insert failed inserting index &quot;</a>
<a name="ln3042">				&quot;entry: %s\n&quot;, strerror(-err));</a>
<a name="ln3043">		return err;</a>
<a name="ln3044">	}</a>
<a name="ln3045">	return 0;</a>
<a name="ln3046">}</a>
<a name="ln3047"> </a>
<a name="ln3048">/**</a>
<a name="ln3049"> * mkntfs_cleanup</a>
<a name="ln3050"> */</a>
<a name="ln3051">static void mkntfs_cleanup(void)</a>
<a name="ln3052">{</a>
<a name="ln3053">	struct BITMAP_ALLOCATION *p, *q;</a>
<a name="ln3054"> </a>
<a name="ln3055">	/* Close the volume */</a>
<a name="ln3056">	if (g_vol) {</a>
<a name="ln3057">		if (g_vol-&gt;dev) {</a>
<a name="ln3058">			if (NDevOpen(g_vol-&gt;dev) &amp;&amp; g_vol-&gt;dev-&gt;d_ops-&gt;close(g_vol-&gt;dev))</a>
<a name="ln3059">				ntfs_log_perror(&quot;Warning: Could not close %s&quot;, g_vol-&gt;dev-&gt;d_name);</a>
<a name="ln3060">			ntfs_device_free(g_vol-&gt;dev);</a>
<a name="ln3061">		}</a>
<a name="ln3062">		free(g_vol-&gt;vol_name);</a>
<a name="ln3063">		free(g_vol-&gt;attrdef);</a>
<a name="ln3064">		free(g_vol-&gt;upcase);</a>
<a name="ln3065">		free(g_vol);</a>
<a name="ln3066">		g_vol = NULL;</a>
<a name="ln3067">	}</a>
<a name="ln3068"> </a>
<a name="ln3069">	/* Free any memory we've used */</a>
<a name="ln3070">	free(g_bad_blocks);	g_bad_blocks	= NULL;</a>
<a name="ln3071">	free(g_buf);		g_buf		= NULL;</a>
<a name="ln3072">	free(g_index_block);	g_index_block	= NULL;</a>
<a name="ln3073">	free(g_dynamic_buf);	g_dynamic_buf	= NULL;</a>
<a name="ln3074">	free(g_mft_bitmap);	g_mft_bitmap	= NULL;</a>
<a name="ln3075">	free(g_rl_bad);		g_rl_bad	= NULL;</a>
<a name="ln3076">	free(g_rl_boot);	g_rl_boot	= NULL;</a>
<a name="ln3077">	free(g_rl_logfile);	g_rl_logfile	= NULL;</a>
<a name="ln3078">	free(g_rl_mft);		g_rl_mft	= NULL;</a>
<a name="ln3079">	free(g_rl_mft_bmp);	g_rl_mft_bmp	= NULL;</a>
<a name="ln3080">	free(g_rl_mftmirr);	g_rl_mftmirr	= NULL;</a>
<a name="ln3081"> </a>
<a name="ln3082">	p = g_allocation;</a>
<a name="ln3083">	while (p) {</a>
<a name="ln3084">		q = p-&gt;next;</a>
<a name="ln3085">		free(p);</a>
<a name="ln3086">		p = q;</a>
<a name="ln3087">	}</a>
<a name="ln3088">}</a>
<a name="ln3089"> </a>
<a name="ln3090"> </a>
<a name="ln3091">/**</a>
<a name="ln3092"> * mkntfs_open_partition -</a>
<a name="ln3093"> */</a>
<a name="ln3094">static BOOL mkntfs_open_partition(ntfs_volume *vol)</a>
<a name="ln3095">{</a>
<a name="ln3096">	BOOL result = FALSE;</a>
<a name="ln3097">	int i;</a>
<a name="ln3098">	struct stat sbuf;</a>
<a name="ln3099">	unsigned long mnt_flags;</a>
<a name="ln3100"> </a>
<a name="ln3101">	/*</a>
<a name="ln3102">	 * Allocate and initialize an ntfs device structure and attach it to</a>
<a name="ln3103">	 * the volume.</a>
<a name="ln3104">	 */</a>
<a name="ln3105">	vol-&gt;dev = ntfs_device_alloc(opts.dev_name, 0, &amp;ntfs_device_default_io_ops, NULL);</a>
<a name="ln3106">	if (!vol-&gt;dev) {</a>
<a name="ln3107">		ntfs_log_perror(&quot;Could not create device&quot;);</a>
<a name="ln3108">		goto done;</a>
<a name="ln3109">	}</a>
<a name="ln3110"> </a>
<a name="ln3111">	/* Open the device for reading or reading and writing. */</a>
<a name="ln3112">	if (opts.no_action) {</a>
<a name="ln3113">		ntfs_log_quiet(&quot;Running in READ-ONLY mode!\n&quot;);</a>
<a name="ln3114">		i = O_RDONLY;</a>
<a name="ln3115">	} else {</a>
<a name="ln3116">		i = O_RDWR;</a>
<a name="ln3117">	}</a>
<a name="ln3118">	if (vol-&gt;dev-&gt;d_ops-&gt;open(vol-&gt;dev, i)) {</a>
<a name="ln3119">		if (errno == ENOENT)</a>
<a name="ln3120">			ntfs_log_error(&quot;The device doesn't exist; did you specify it correctly?\n&quot;);</a>
<a name="ln3121">		else</a>
<a name="ln3122">			ntfs_log_perror(&quot;Could not open %s&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3123">		goto done;</a>
<a name="ln3124">	}</a>
<a name="ln3125">	/* Verify we are dealing with a block device. */</a>
<a name="ln3126">	if (vol-&gt;dev-&gt;d_ops-&gt;stat(vol-&gt;dev, &amp;sbuf)) {</a>
<a name="ln3127">		ntfs_log_perror(&quot;Error getting information about %s&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3128">		goto done;</a>
<a name="ln3129">	}</a>
<a name="ln3130"> </a>
<a name="ln3131">	if (!S_ISBLK(sbuf.st_mode)) {</a>
<a name="ln3132">		ntfs_log_error(&quot;%s is not a block device.\n&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3133">		if (!opts.force) {</a>
<a name="ln3134">			ntfs_log_error(&quot;Refusing to make a filesystem here!\n&quot;);</a>
<a name="ln3135">			goto done;</a>
<a name="ln3136">		}</a>
<a name="ln3137">		if (!opts.num_sectors) {</a>
<a name="ln3138">			if (!sbuf.st_size &amp;&amp; !sbuf.st_blocks) {</a>
<a name="ln3139">				ntfs_log_error(&quot;You must specify the number of sectors.\n&quot;);</a>
<a name="ln3140">				goto done;</a>
<a name="ln3141">			}</a>
<a name="ln3142">			if (opts.sector_size) {</a>
<a name="ln3143">				if (sbuf.st_size)</a>
<a name="ln3144">					opts.num_sectors = sbuf.st_size / opts.sector_size;</a>
<a name="ln3145">				else</a>
<a name="ln3146">					opts.num_sectors = ((s64)sbuf.st_blocks &lt;&lt; 9) / opts.sector_size;</a>
<a name="ln3147">			} else {</a>
<a name="ln3148">				if (sbuf.st_size)</a>
<a name="ln3149">					opts.num_sectors = sbuf.st_size / 512;</a>
<a name="ln3150">				else</a>
<a name="ln3151">					opts.num_sectors = sbuf.st_blocks;</a>
<a name="ln3152">				opts.sector_size = 512;</a>
<a name="ln3153">			}</a>
<a name="ln3154">		}</a>
<a name="ln3155">		ntfs_log_warning(&quot;mkntfs forced anyway.\n&quot;);</a>
<a name="ln3156">#ifdef HAVE_LINUX_MAJOR_H</a>
<a name="ln3157">	} else if ((IDE_DISK_MAJOR(MAJOR(sbuf.st_rdev)) &amp;&amp;</a>
<a name="ln3158">			MINOR(sbuf.st_rdev) % 64 == 0) ||</a>
<a name="ln3159">			(SCSI_DISK_MAJOR(MAJOR(sbuf.st_rdev)) &amp;&amp;</a>
<a name="ln3160">			MINOR(sbuf.st_rdev) % 16 == 0)) {</a>
<a name="ln3161">		ntfs_log_error(&quot;%s is entire device, not just one partition.\n&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3162">		if (!opts.force) {</a>
<a name="ln3163">			ntfs_log_error(&quot;Refusing to make a filesystem here!\n&quot;);</a>
<a name="ln3164">			goto done;</a>
<a name="ln3165">		}</a>
<a name="ln3166">		ntfs_log_warning(&quot;mkntfs forced anyway.\n&quot;);</a>
<a name="ln3167">#endif</a>
<a name="ln3168">	}</a>
<a name="ln3169">	/* Make sure the file system is not mounted. */</a>
<a name="ln3170">	if (ntfs_check_if_mounted(vol-&gt;dev-&gt;d_name, &amp;mnt_flags)) {</a>
<a name="ln3171">		ntfs_log_perror(&quot;Failed to determine whether %s is mounted&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3172">	} else if (mnt_flags &amp; NTFS_MF_MOUNTED) {</a>
<a name="ln3173">		ntfs_log_error(&quot;%s is mounted.\n&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3174">		if (!opts.force) {</a>
<a name="ln3175">			ntfs_log_error(&quot;Refusing to make a filesystem here!\n&quot;);</a>
<a name="ln3176">			goto done;</a>
<a name="ln3177">		}</a>
<a name="ln3178">		ntfs_log_warning(&quot;mkntfs forced anyway. Hope /etc/mtab is incorrect.\n&quot;);</a>
<a name="ln3179">	}</a>
<a name="ln3180">	result = TRUE;</a>
<a name="ln3181">done:</a>
<a name="ln3182">	return result;</a>
<a name="ln3183">}</a>
<a name="ln3184"> </a>
<a name="ln3185">/**</a>
<a name="ln3186"> * mkntfs_get_page_size - detect the system's memory page size.</a>
<a name="ln3187"> */</a>
<a name="ln3188">static long mkntfs_get_page_size(void)</a>
<a name="ln3189">{</a>
<a name="ln3190">	return NTFS_PAGE_SIZE;</a>
<a name="ln3191">}</a>
<a name="ln3192"> </a>
<a name="ln3193">/**</a>
<a name="ln3194"> * mkntfs_override_vol_params -</a>
<a name="ln3195"> */</a>
<a name="ln3196">static BOOL mkntfs_override_vol_params(ntfs_volume *vol)</a>
<a name="ln3197">{</a>
<a name="ln3198">	s64 volume_size;</a>
<a name="ln3199">	long page_size;</a>
<a name="ln3200">	int i;</a>
<a name="ln3201">	BOOL winboot = TRUE;</a>
<a name="ln3202"> </a>
<a name="ln3203">	/* If user didn't specify the sector size, determine it now. */</a>
<a name="ln3204">	if (opts.sector_size &lt; 0) {</a>
<a name="ln3205">		opts.sector_size = ntfs_device_sector_size_get(vol-&gt;dev);</a>
<a name="ln3206">		if (opts.sector_size &lt; 0) {</a>
<a name="ln3207">			ntfs_log_warning(&quot;The sector size was not specified &quot;</a>
<a name="ln3208">				&quot;for %s and it could not be obtained &quot;</a>
<a name="ln3209">				&quot;automatically.  It has been set to 512 &quot;</a>
<a name="ln3210">				&quot;bytes.\n&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3211">			opts.sector_size = 512;</a>
<a name="ln3212">		}</a>
<a name="ln3213">	}</a>
<a name="ln3214">	/* Validate sector size. */</a>
<a name="ln3215">	if ((opts.sector_size - 1) &amp; opts.sector_size) {</a>
<a name="ln3216">		ntfs_log_error(&quot;The sector size is invalid.  It must be a &quot;</a>
<a name="ln3217">			&quot;power of two, e.g. 512, 1024.\n&quot;);</a>
<a name="ln3218">		return FALSE;</a>
<a name="ln3219">	}</a>
<a name="ln3220">	if (opts.sector_size &lt; 256 || opts.sector_size &gt; 4096) {</a>
<a name="ln3221">		ntfs_log_error(&quot;The sector size is invalid.  The minimum size &quot;</a>
<a name="ln3222">			&quot;is 256 bytes and the maximum is 4096 bytes.\n&quot;);</a>
<a name="ln3223">		return FALSE;</a>
<a name="ln3224">	}</a>
<a name="ln3225">	ntfs_log_debug(&quot;sector size = %ld bytes\n&quot;, opts.sector_size);</a>
<a name="ln3226">	/* Now set the device block size to the sector size. */</a>
<a name="ln3227">	if (ntfs_device_block_size_set(vol-&gt;dev, opts.sector_size))</a>
<a name="ln3228">		ntfs_log_debug(&quot;Failed to set the device block size to the &quot;</a>
<a name="ln3229">				&quot;sector size.  This may cause problems when &quot;</a>
<a name="ln3230">				&quot;creating the backup boot sector and also may &quot;</a>
<a name="ln3231">				&quot;affect performance but should be harmless &quot;</a>
<a name="ln3232">				&quot;otherwise.  Error: %s\n&quot;, strerror(errno));</a>
<a name="ln3233">	/* If user didn't specify the number of sectors, determine it now. */</a>
<a name="ln3234">	if (opts.num_sectors &lt; 0) {</a>
<a name="ln3235">		opts.num_sectors = ntfs_device_size_get(vol-&gt;dev,</a>
<a name="ln3236">				opts.sector_size);</a>
<a name="ln3237">		if (opts.num_sectors &lt;= 0) {</a>
<a name="ln3238">			ntfs_log_error(&quot;Couldn't determine the size of %s.  &quot;</a>
<a name="ln3239">				&quot;Please specify the number of sectors &quot;</a>
<a name="ln3240">				&quot;manually.\n&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3241">			return FALSE;</a>
<a name="ln3242">		}</a>
<a name="ln3243">	}</a>
<a name="ln3244">	ntfs_log_debug(&quot;number of sectors = %lld (0x%llx)\n&quot;, opts.num_sectors,</a>
<a name="ln3245">			opts.num_sectors);</a>
<a name="ln3246">	/*</a>
<a name="ln3247">	 * Reserve the last sector for the backup boot sector unless the</a>
<a name="ln3248">	 * sector size is less than 512 bytes in which case reserve 512 bytes</a>
<a name="ln3249">	 * worth of sectors.</a>
<a name="ln3250">	 */</a>
<a name="ln3251">	i = 1;</a>
<a name="ln3252">	if (opts.sector_size &lt; 512)</a>
<a name="ln3253">		i = 512 / opts.sector_size;</a>
<a name="ln3254">	opts.num_sectors -= i;</a>
<a name="ln3255">	/* If user didn't specify the partition start sector, determine it. */</a>
<a name="ln3256">	if (opts.part_start_sect &lt; 0) {</a>
<a name="ln3257">		opts.part_start_sect = ntfs_device_partition_start_sector_get(</a>
<a name="ln3258">				vol-&gt;dev);</a>
<a name="ln3259">		if (opts.part_start_sect &lt; 0) {</a>
<a name="ln3260">			ntfs_log_warning(&quot;The partition start sector was not &quot;</a>
<a name="ln3261">				&quot;specified for %s and it could not be obtained &quot;</a>
<a name="ln3262">				&quot;automatically.  It has been set to 0.\n&quot;,</a>
<a name="ln3263">				vol-&gt;dev-&gt;d_name);</a>
<a name="ln3264">			opts.part_start_sect = 0;</a>
<a name="ln3265">			winboot = FALSE;</a>
<a name="ln3266">		} else if (opts.part_start_sect &gt;&gt; 32) {</a>
<a name="ln3267">			ntfs_log_warning(&quot;The partition start sector specified &quot;</a>
<a name="ln3268">				&quot;for %s and the automatically determined value &quot;</a>
<a name="ln3269">				&quot;is too large.  It has been set to 0.\n&quot;,</a>
<a name="ln3270">				vol-&gt;dev-&gt;d_name);</a>
<a name="ln3271">			opts.part_start_sect = 0;</a>
<a name="ln3272">			winboot = FALSE;</a>
<a name="ln3273">		}</a>
<a name="ln3274">	} else if (opts.part_start_sect &gt;&gt; 32) {</a>
<a name="ln3275">		ntfs_log_error(&quot;Invalid partition start sector.  Maximum is &quot;</a>
<a name="ln3276">			&quot;4294967295 (2^32-1).\n&quot;);</a>
<a name="ln3277">		return FALSE;</a>
<a name="ln3278">	}</a>
<a name="ln3279">	/* If user didn't specify the sectors per track, determine it now. */</a>
<a name="ln3280">	if (opts.sectors_per_track &lt; 0) {</a>
<a name="ln3281">		opts.sectors_per_track = ntfs_device_sectors_per_track_get(</a>
<a name="ln3282">				vol-&gt;dev);</a>
<a name="ln3283">		if (opts.sectors_per_track &lt; 0) {</a>
<a name="ln3284">			ntfs_log_warning(&quot;The number of sectors per track was &quot;</a>
<a name="ln3285">				&quot;not specified for %s and it could not be &quot;</a>
<a name="ln3286">				&quot;obtained automatically.  It has been set to &quot;</a>
<a name="ln3287">				&quot;0.\n&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3288">			opts.sectors_per_track = 0;</a>
<a name="ln3289">			winboot = FALSE;</a>
<a name="ln3290">		} else if (opts.sectors_per_track &gt; 65535) {</a>
<a name="ln3291">			ntfs_log_warning(&quot;The number of sectors per track was &quot;</a>
<a name="ln3292">				&quot;not specified for %s and the automatically &quot;</a>
<a name="ln3293">				&quot;determined value is too large.  It has been &quot;</a>
<a name="ln3294">				&quot;set to 0.\n&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3295">			opts.sectors_per_track = 0;</a>
<a name="ln3296">			winboot = FALSE;</a>
<a name="ln3297">		}</a>
<a name="ln3298">	} else if (opts.sectors_per_track &gt; 65535) {</a>
<a name="ln3299">		ntfs_log_error(&quot;Invalid number of sectors per track.  Maximum &quot;</a>
<a name="ln3300">			&quot;is 65535.\n&quot;);</a>
<a name="ln3301">		return FALSE;</a>
<a name="ln3302">	}</a>
<a name="ln3303">	/* If user didn't specify the number of heads, determine it now. */</a>
<a name="ln3304">	if (opts.heads &lt; 0) {</a>
<a name="ln3305">		opts.heads = ntfs_device_heads_get(vol-&gt;dev);</a>
<a name="ln3306">		if (opts.heads &lt; 0) {</a>
<a name="ln3307">			ntfs_log_warning(&quot;The number of heads was not &quot;</a>
<a name="ln3308">				&quot;specified for %s and it could not be obtained &quot;</a>
<a name="ln3309">				&quot;automatically.  It has been set to 0.\n&quot;,</a>
<a name="ln3310">				vol-&gt;dev-&gt;d_name);</a>
<a name="ln3311">			opts.heads = 0;</a>
<a name="ln3312">			winboot = FALSE;</a>
<a name="ln3313">		} else if (opts.heads &gt; 65535) {</a>
<a name="ln3314">			ntfs_log_warning(&quot;The number of heads was not &quot;</a>
<a name="ln3315">				&quot;specified for %s and the automatically &quot;</a>
<a name="ln3316">				&quot;determined value is too large.  It has been &quot;</a>
<a name="ln3317">				&quot;set to 0.\n&quot;, vol-&gt;dev-&gt;d_name);</a>
<a name="ln3318">			opts.heads = 0;</a>
<a name="ln3319">			winboot = FALSE;</a>
<a name="ln3320">		}</a>
<a name="ln3321">	} else if (opts.heads &gt; 65535) {</a>
<a name="ln3322">		ntfs_log_error(&quot;Invalid number of heads.  Maximum is 65535.\n&quot;);</a>
<a name="ln3323">		return FALSE;</a>
<a name="ln3324">	}</a>
<a name="ln3325">	volume_size = opts.num_sectors * opts.sector_size;</a>
<a name="ln3326">	/* Validate volume size. */</a>
<a name="ln3327">	if (volume_size &lt; (1 &lt;&lt; 20)) {			/* 1MiB */</a>
<a name="ln3328">		ntfs_log_error(&quot;Device is too small (%llikiB).  Minimum NTFS &quot;</a>
<a name="ln3329">				&quot;volume size is 1MiB.\n&quot;,</a>
<a name="ln3330">				(long long)(volume_size / 1024));</a>
<a name="ln3331">		return FALSE;</a>
<a name="ln3332">	}</a>
<a name="ln3333">	ntfs_log_debug(&quot;volume size = %llikiB\n&quot;, volume_size / 1024);</a>
<a name="ln3334">	/* If user didn't specify the cluster size, determine it now. */</a>
<a name="ln3335">	if (!vol-&gt;cluster_size) {</a>
<a name="ln3336">		/*</a>
<a name="ln3337">		 * Windows Vista always uses 4096 bytes as the default cluster</a>
<a name="ln3338">		 * size regardless of the volume size so we do it, too.</a>
<a name="ln3339">		 */</a>
<a name="ln3340">		vol-&gt;cluster_size = 4096;</a>
<a name="ln3341">		/* For small volumes on devices with large sector sizes. */</a>
<a name="ln3342">		if (vol-&gt;cluster_size &lt; (u32)opts.sector_size)</a>
<a name="ln3343">			vol-&gt;cluster_size = opts.sector_size;</a>
<a name="ln3344">		/*</a>
<a name="ln3345">		 * For huge volumes, grow the cluster size until the number of</a>
<a name="ln3346">		 * clusters fits into 32 bits or the cluster size exceeds the</a>
<a name="ln3347">		 * maximum limit of 64kiB.</a>
<a name="ln3348">		 */</a>
<a name="ln3349">		while (volume_size &gt;&gt; (ffs(vol-&gt;cluster_size) - 1 + 32)) {</a>
<a name="ln3350">			vol-&gt;cluster_size &lt;&lt;= 1;</a>
<a name="ln3351">			if (vol-&gt;cluster_size &gt; 65535) {</a>
<a name="ln3352">				ntfs_log_error(&quot;Device is too large to hold an &quot;</a>
<a name="ln3353">						&quot;NTFS volume (maximum size is &quot;</a>
<a name="ln3354">						&quot;256TiB).\n&quot;);</a>
<a name="ln3355">				return FALSE;</a>
<a name="ln3356">			}</a>
<a name="ln3357">		}</a>
<a name="ln3358">		ntfs_log_quiet(&quot;Cluster size has been automatically set to %u &quot;</a>
<a name="ln3359">				&quot;bytes.\n&quot;, (unsigned)vol-&gt;cluster_size);</a>
<a name="ln3360">	}</a>
<a name="ln3361">	/* Validate cluster size. */</a>
<a name="ln3362">	if (vol-&gt;cluster_size &amp; (vol-&gt;cluster_size - 1)) {</a>
<a name="ln3363">		ntfs_log_error(&quot;The cluster size is invalid.  It must be a &quot;</a>
<a name="ln3364">				&quot;power of two, e.g. 1024, 4096.\n&quot;);</a>
<a name="ln3365">		return FALSE;</a>
<a name="ln3366">	}</a>
<a name="ln3367">	if (vol-&gt;cluster_size &lt; (u32)opts.sector_size) {</a>
<a name="ln3368">		ntfs_log_error(&quot;The cluster size is invalid.  It must be equal &quot;</a>
<a name="ln3369">				&quot;to, or larger than, the sector size.\n&quot;);</a>
<a name="ln3370">		return FALSE;</a>
<a name="ln3371">	}</a>
<a name="ln3372">	if (vol-&gt;cluster_size &gt; 128 * (u32)opts.sector_size) {</a>
<a name="ln3373">		ntfs_log_error(&quot;The cluster size is invalid.  It cannot be &quot;</a>
<a name="ln3374">				&quot;more that 128 times the size of the sector &quot;</a>
<a name="ln3375">				&quot;size.\n&quot;);</a>
<a name="ln3376">		return FALSE;</a>
<a name="ln3377">	}</a>
<a name="ln3378">	if (vol-&gt;cluster_size &gt; 65536) {</a>
<a name="ln3379">		ntfs_log_error(&quot;The cluster size is invalid.  The maximum &quot;</a>
<a name="ln3380">			&quot;cluster size is 65536 bytes (64kiB).\n&quot;);</a>
<a name="ln3381">		return FALSE;</a>
<a name="ln3382">	}</a>
<a name="ln3383">	vol-&gt;cluster_size_bits = ffs(vol-&gt;cluster_size) - 1;</a>
<a name="ln3384">	ntfs_log_debug(&quot;cluster size = %u bytes\n&quot;,</a>
<a name="ln3385">			(unsigned int)vol-&gt;cluster_size);</a>
<a name="ln3386">	if (vol-&gt;cluster_size &gt; 4096) {</a>
<a name="ln3387">		if (opts.enable_compression) {</a>
<a name="ln3388">			if (!opts.force) {</a>
<a name="ln3389">				ntfs_log_error(&quot;Windows cannot use compression &quot;</a>
<a name="ln3390">						&quot;when the cluster size is &quot;</a>
<a name="ln3391">						&quot;larger than 4096 bytes.\n&quot;);</a>
<a name="ln3392">				return FALSE;</a>
<a name="ln3393">			}</a>
<a name="ln3394">			opts.enable_compression = 0;</a>
<a name="ln3395">		}</a>
<a name="ln3396">		ntfs_log_warning(&quot;Windows cannot use compression when the &quot;</a>
<a name="ln3397">				&quot;cluster size is larger than 4096 bytes.  &quot;</a>
<a name="ln3398">				&quot;Compression has been disabled for this &quot;</a>
<a name="ln3399">				&quot;volume.\n&quot;);</a>
<a name="ln3400">	}</a>
<a name="ln3401">	vol-&gt;nr_clusters = volume_size / vol-&gt;cluster_size;</a>
<a name="ln3402">	/*</a>
<a name="ln3403">	 * Check the cluster_size and num_sectors for consistency with</a>
<a name="ln3404">	 * sector_size and num_sectors. And check both of these for consistency</a>
<a name="ln3405">	 * with volume_size.</a>
<a name="ln3406">	 */</a>
<a name="ln3407">	if ((vol-&gt;nr_clusters != ((opts.num_sectors * opts.sector_size) /</a>
<a name="ln3408">			vol-&gt;cluster_size) ||</a>
<a name="ln3409">			(volume_size / opts.sector_size) != opts.num_sectors ||</a>
<a name="ln3410">			(volume_size / vol-&gt;cluster_size) !=</a>
<a name="ln3411">			vol-&gt;nr_clusters)) {</a>
<a name="ln3412">		/* XXX is this code reachable? */</a>
<a name="ln3413">		ntfs_log_error(&quot;Illegal combination of volume/cluster/sector &quot;</a>
<a name="ln3414">				&quot;size and/or cluster/sector number.\n&quot;);</a>
<a name="ln3415">		return FALSE;</a>
<a name="ln3416">	}</a>
<a name="ln3417">	ntfs_log_debug(&quot;number of clusters = %llu (0x%llx)\n&quot;,</a>
<a name="ln3418">			vol-&gt;nr_clusters, vol-&gt;nr_clusters);</a>
<a name="ln3419">	/* Number of clusters must fit within 32 bits (Win2k limitation). */</a>
<a name="ln3420">	if (vol-&gt;nr_clusters &gt;&gt; 32) {</a>
<a name="ln3421">		if (vol-&gt;cluster_size &gt;= 65536) {</a>
<a name="ln3422">			ntfs_log_error(&quot;Device is too large to hold an NTFS &quot;</a>
<a name="ln3423">					&quot;volume (maximum size is 256TiB).\n&quot;);</a>
<a name="ln3424">			return FALSE;</a>
<a name="ln3425">		}</a>
<a name="ln3426">		ntfs_log_error(&quot;Number of clusters exceeds 32 bits.  Please &quot;</a>
<a name="ln3427">				&quot;try again with a larger\ncluster size or &quot;</a>
<a name="ln3428">				&quot;leave the cluster size unspecified and the &quot;</a>
<a name="ln3429">				&quot;smallest possible cluster size for the size &quot;</a>
<a name="ln3430">				&quot;of the device will be used.\n&quot;);</a>
<a name="ln3431">		return FALSE;</a>
<a name="ln3432">	}</a>
<a name="ln3433">	page_size = mkntfs_get_page_size();</a>
<a name="ln3434">	/*</a>
<a name="ln3435">	 * Set the mft record size.  By default this is 1024 but it has to be</a>
<a name="ln3436">	 * at least as big as a sector and not bigger than a page on the system</a>
<a name="ln3437">	 * or the NTFS kernel driver will not be able to mount the volume.</a>
<a name="ln3438">	 * TODO: The mft record size should be user specifiable just like the</a>
<a name="ln3439">	 * &quot;inode size&quot; can be specified on other Linux/Unix file systems.</a>
<a name="ln3440">	 */</a>
<a name="ln3441">	vol-&gt;mft_record_size = 1024;</a>
<a name="ln3442">	if (vol-&gt;mft_record_size &lt; (u32)opts.sector_size)</a>
<a name="ln3443">		vol-&gt;mft_record_size = opts.sector_size;</a>
<a name="ln3444">	if (vol-&gt;mft_record_size &gt; (unsigned long)page_size)</a>
<a name="ln3445">		ntfs_log_warning(&quot;Mft record size (%u bytes) exceeds system &quot;</a>
<a name="ln3446">				&quot;page size (%li bytes).  You will not be able &quot;</a>
<a name="ln3447">				&quot;to mount this volume using the NTFS kernel &quot;</a>
<a name="ln3448">				&quot;driver.\n&quot;, (unsigned)vol-&gt;mft_record_size,</a>
<a name="ln3449">				page_size);</a>
<a name="ln3450">	vol-&gt;mft_record_size_bits = ffs(vol-&gt;mft_record_size) - 1;</a>
<a name="ln3451">	ntfs_log_debug(&quot;mft record size = %u bytes\n&quot;,</a>
<a name="ln3452">			(unsigned)vol-&gt;mft_record_size);</a>
<a name="ln3453">	/*</a>
<a name="ln3454">	 * Set the index record size.  By default this is 4096 but it has to be</a>
<a name="ln3455">	 * at least as big as a sector and not bigger than a page on the system</a>
<a name="ln3456">	 * or the NTFS kernel driver will not be able to mount the volume.</a>
<a name="ln3457">	 * FIXME: Should we make the index record size to be user specifiable?</a>
<a name="ln3458">	 */</a>
<a name="ln3459">	vol-&gt;indx_record_size = 4096;</a>
<a name="ln3460">	if (vol-&gt;indx_record_size &lt; (u32)opts.sector_size)</a>
<a name="ln3461">		vol-&gt;indx_record_size = opts.sector_size;</a>
<a name="ln3462">	if (vol-&gt;indx_record_size &gt; (unsigned long)page_size)</a>
<a name="ln3463">		ntfs_log_warning(&quot;Index record size (%u bytes) exceeds system &quot;</a>
<a name="ln3464">				&quot;page size (%li bytes).  You will not be able &quot;</a>
<a name="ln3465">				&quot;to mount this volume using the NTFS kernel &quot;</a>
<a name="ln3466">				&quot;driver.\n&quot;, (unsigned)vol-&gt;indx_record_size,</a>
<a name="ln3467">				page_size);</a>
<a name="ln3468">	vol-&gt;indx_record_size_bits = ffs(vol-&gt;indx_record_size) - 1;</a>
<a name="ln3469">	ntfs_log_debug(&quot;index record size = %u bytes\n&quot;,</a>
<a name="ln3470">			(unsigned)vol-&gt;indx_record_size);</a>
<a name="ln3471">	if (!winboot) {</a>
<a name="ln3472">		ntfs_log_warning(&quot;To boot from a device, Windows needs the &quot;</a>
<a name="ln3473">				&quot;'partition start sector', the 'sectors per &quot;</a>
<a name="ln3474">				&quot;track' and the 'number of heads' to be &quot;</a>
<a name="ln3475">				&quot;set.\n&quot;);</a>
<a name="ln3476">		ntfs_log_warning(&quot;Windows will not be able to boot from this &quot;</a>
<a name="ln3477">				&quot;device.\n&quot;);</a>
<a name="ln3478">	}</a>
<a name="ln3479">	return TRUE;</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482">/**</a>
<a name="ln3483"> * mkntfs_initialize_bitmaps -</a>
<a name="ln3484"> */</a>
<a name="ln3485">static BOOL mkntfs_initialize_bitmaps(void)</a>
<a name="ln3486">{</a>
<a name="ln3487">	u64 i;</a>
<a name="ln3488">	int mft_bitmap_size;</a>
<a name="ln3489"> </a>
<a name="ln3490">	/* Determine lcn bitmap byte size and allocate it. */</a>
<a name="ln3491">	g_lcn_bitmap_byte_size = (g_vol-&gt;nr_clusters + 7) &gt;&gt; 3;</a>
<a name="ln3492">	/* Needs to be multiple of 8 bytes. */</a>
<a name="ln3493">	g_lcn_bitmap_byte_size = (g_lcn_bitmap_byte_size + 7) &amp; ~7;</a>
<a name="ln3494">	i = (g_lcn_bitmap_byte_size + g_vol-&gt;cluster_size - 1) &amp;</a>
<a name="ln3495">			~(g_vol-&gt;cluster_size - 1);</a>
<a name="ln3496">	ntfs_log_debug(&quot;g_lcn_bitmap_byte_size = %i, allocated = %llu\n&quot;,</a>
<a name="ln3497">			g_lcn_bitmap_byte_size, i);</a>
<a name="ln3498">	g_dynamic_buf_size = mkntfs_get_page_size();</a>
<a name="ln3499">	g_dynamic_buf = (u8*)ntfs_calloc(g_dynamic_buf_size);</a>
<a name="ln3500">	if (!g_dynamic_buf)</a>
<a name="ln3501">		return FALSE;</a>
<a name="ln3502">	/*</a>
<a name="ln3503">	 * $Bitmap can overlap the end of the volume. Any bits in this region</a>
<a name="ln3504">	 * must be set. This region also encompasses the backup boot sector.</a>
<a name="ln3505">	 */</a>
<a name="ln3506">	if (!bitmap_allocate(g_vol-&gt;nr_clusters,</a>
<a name="ln3507">		    ((s64)g_lcn_bitmap_byte_size &lt;&lt; 3) - g_vol-&gt;nr_clusters))</a>
<a name="ln3508">		return (FALSE);</a>
<a name="ln3509">	/*</a>
<a name="ln3510">	 * Mft size is 27 (NTFS 3.0+) mft records or one cluster, whichever is</a>
<a name="ln3511">	 * bigger.</a>
<a name="ln3512">	 */</a>
<a name="ln3513">	g_mft_size = 27;</a>
<a name="ln3514">	g_mft_size *= g_vol-&gt;mft_record_size;</a>
<a name="ln3515">	if (g_mft_size &lt; (s32)g_vol-&gt;cluster_size)</a>
<a name="ln3516">		g_mft_size = g_vol-&gt;cluster_size;</a>
<a name="ln3517">	ntfs_log_debug(&quot;MFT size = %i (0x%x) bytes\n&quot;, g_mft_size, g_mft_size);</a>
<a name="ln3518">	/* Determine mft bitmap size and allocate it. */</a>
<a name="ln3519">	mft_bitmap_size = g_mft_size / g_vol-&gt;mft_record_size;</a>
<a name="ln3520">	/* Convert to bytes, at least one. */</a>
<a name="ln3521">	g_mft_bitmap_byte_size = (mft_bitmap_size + 7) &gt;&gt; 3;</a>
<a name="ln3522">	/* Mft bitmap is allocated in multiples of 8 bytes. */</a>
<a name="ln3523">	g_mft_bitmap_byte_size = (g_mft_bitmap_byte_size + 7) &amp; ~7;</a>
<a name="ln3524">	ntfs_log_debug(&quot;mft_bitmap_size = %i, g_mft_bitmap_byte_size = %i\n&quot;,</a>
<a name="ln3525">			mft_bitmap_size, g_mft_bitmap_byte_size);</a>
<a name="ln3526">	g_mft_bitmap = ntfs_calloc(g_mft_bitmap_byte_size);</a>
<a name="ln3527">	if (!g_mft_bitmap)</a>
<a name="ln3528">		return FALSE;</a>
<a name="ln3529">	/* Create runlist for mft bitmap. */</a>
<a name="ln3530">	g_rl_mft_bmp = ntfs_malloc(2 * sizeof(runlist));</a>
<a name="ln3531">	if (!g_rl_mft_bmp)</a>
<a name="ln3532">		return FALSE;</a>
<a name="ln3533"> </a>
<a name="ln3534">	g_rl_mft_bmp[0].vcn = 0LL;</a>
<a name="ln3535">	/* Mft bitmap is right after $Boot's data. */</a>
<a name="ln3536">	i = (8192 + g_vol-&gt;cluster_size - 1) / g_vol-&gt;cluster_size;</a>
<a name="ln3537">	g_rl_mft_bmp[0].lcn = i;</a>
<a name="ln3538">	/*</a>
<a name="ln3539">	 * Size is always one cluster, even though valid data size and</a>
<a name="ln3540">	 * initialized data size are only 8 bytes.</a>
<a name="ln3541">	 */</a>
<a name="ln3542">	g_rl_mft_bmp[1].vcn = 1LL;</a>
<a name="ln3543">	g_rl_mft_bmp[0].length = 1LL;</a>
<a name="ln3544">	g_rl_mft_bmp[1].lcn = -1LL;</a>
<a name="ln3545">	g_rl_mft_bmp[1].length = 0LL;</a>
<a name="ln3546">	/* Allocate cluster for mft bitmap. */</a>
<a name="ln3547">	return (bitmap_allocate(i,1));</a>
<a name="ln3548">}</a>
<a name="ln3549"> </a>
<a name="ln3550">/**</a>
<a name="ln3551"> * mkntfs_initialize_rl_mft -</a>
<a name="ln3552"> */</a>
<a name="ln3553">static BOOL mkntfs_initialize_rl_mft(void)</a>
<a name="ln3554">{</a>
<a name="ln3555">	int j;</a>
<a name="ln3556">	BOOL done;</a>
<a name="ln3557"> </a>
<a name="ln3558">	/* If user didn't specify the mft lcn, determine it now. */</a>
<a name="ln3559">	if (!g_mft_lcn) {</a>
<a name="ln3560">		/*</a>
<a name="ln3561">		 * We start at the higher value out of 16kiB and just after the</a>
<a name="ln3562">		 * mft bitmap.</a>
<a name="ln3563">		 */</a>
<a name="ln3564">		g_mft_lcn = g_rl_mft_bmp[0].lcn + g_rl_mft_bmp[0].length;</a>
<a name="ln3565">		if (g_mft_lcn * g_vol-&gt;cluster_size &lt; 16 * 1024)</a>
<a name="ln3566">			g_mft_lcn = (16 * 1024 + g_vol-&gt;cluster_size - 1) /</a>
<a name="ln3567">					g_vol-&gt;cluster_size;</a>
<a name="ln3568">	}</a>
<a name="ln3569">	ntfs_log_debug(&quot;$MFT logical cluster number = 0x%llx\n&quot;, g_mft_lcn);</a>
<a name="ln3570">	/* Determine MFT zone size. */</a>
<a name="ln3571">	g_mft_zone_end = g_vol-&gt;nr_clusters;</a>
<a name="ln3572">	switch (opts.mft_zone_multiplier) {  /* % of volume size in clusters */</a>
<a name="ln3573">	case 4:</a>
<a name="ln3574">		g_mft_zone_end = g_mft_zone_end &gt;&gt; 1;	/* 50%   */</a>
<a name="ln3575">		break;</a>
<a name="ln3576">	case 3:</a>
<a name="ln3577">		g_mft_zone_end = g_mft_zone_end * 3 &gt;&gt; 3;/* 37.5% */</a>
<a name="ln3578">		break;</a>
<a name="ln3579">	case 2:</a>
<a name="ln3580">		g_mft_zone_end = g_mft_zone_end &gt;&gt; 2;	/* 25%   */</a>
<a name="ln3581">		break;</a>
<a name="ln3582">	case 1:</a>
<a name="ln3583">	default:</a>
<a name="ln3584">		g_mft_zone_end = g_mft_zone_end &gt;&gt; 3;	/* 12.5% */</a>
<a name="ln3585">		break;</a>
<a name="ln3586">	}</a>
<a name="ln3587">	ntfs_log_debug(&quot;MFT zone size = %lldkiB\n&quot;, g_mft_zone_end &lt;&lt;</a>
<a name="ln3588">			g_vol-&gt;cluster_size_bits &gt;&gt; 10 /* &gt;&gt; 10 == / 1024 */);</a>
<a name="ln3589">	/*</a>
<a name="ln3590">	 * The mft zone begins with the mft data attribute, not at the beginning</a>
<a name="ln3591">	 * of the device.</a>
<a name="ln3592">	 */</a>
<a name="ln3593">	g_mft_zone_end += g_mft_lcn;</a>
<a name="ln3594">	/* Create runlist for mft. */</a>
<a name="ln3595">	g_rl_mft = ntfs_malloc(2 * sizeof(runlist));</a>
<a name="ln3596">	if (!g_rl_mft)</a>
<a name="ln3597">		return FALSE;</a>
<a name="ln3598"> </a>
<a name="ln3599">	g_rl_mft[0].vcn = 0LL;</a>
<a name="ln3600">	g_rl_mft[0].lcn = g_mft_lcn;</a>
<a name="ln3601">	/* rounded up division by cluster size */</a>
<a name="ln3602">	j = (g_mft_size + g_vol-&gt;cluster_size - 1) / g_vol-&gt;cluster_size;</a>
<a name="ln3603">	g_rl_mft[1].vcn = j;</a>
<a name="ln3604">	g_rl_mft[0].length = j;</a>
<a name="ln3605">	g_rl_mft[1].lcn = -1LL;</a>
<a name="ln3606">	g_rl_mft[1].length = 0LL;</a>
<a name="ln3607">	/* Allocate clusters for mft. */</a>
<a name="ln3608">	bitmap_allocate(g_mft_lcn,j);</a>
<a name="ln3609">	/* Determine mftmirr_lcn (middle of volume). */</a>
<a name="ln3610">	g_mftmirr_lcn = (opts.num_sectors * opts.sector_size &gt;&gt; 1)</a>
<a name="ln3611">			/ g_vol-&gt;cluster_size;</a>
<a name="ln3612">	ntfs_log_debug(&quot;$MFTMirr logical cluster number = 0x%llx\n&quot;,</a>
<a name="ln3613">			g_mftmirr_lcn);</a>
<a name="ln3614">	/* Create runlist for mft mirror. */</a>
<a name="ln3615">	g_rl_mftmirr = ntfs_malloc(2 * sizeof(runlist));</a>
<a name="ln3616">	if (!g_rl_mftmirr)</a>
<a name="ln3617">		return FALSE;</a>
<a name="ln3618"> </a>
<a name="ln3619">	g_rl_mftmirr[0].vcn = 0LL;</a>
<a name="ln3620">	g_rl_mftmirr[0].lcn = g_mftmirr_lcn;</a>
<a name="ln3621">	/*</a>
<a name="ln3622">	 * The mft mirror is either 4kb (the first four records) or one cluster</a>
<a name="ln3623">	 * in size, which ever is bigger. In either case, it contains a</a>
<a name="ln3624">	 * byte-for-byte identical copy of the beginning of the mft (i.e. either</a>
<a name="ln3625">	 * the first four records (4kb) or the first cluster worth of records,</a>
<a name="ln3626">	 * whichever is bigger).</a>
<a name="ln3627">	 */</a>
<a name="ln3628">	j = (4 * g_vol-&gt;mft_record_size + g_vol-&gt;cluster_size - 1) / g_vol-&gt;cluster_size;</a>
<a name="ln3629">	g_rl_mftmirr[1].vcn = j;</a>
<a name="ln3630">	g_rl_mftmirr[0].length = j;</a>
<a name="ln3631">	g_rl_mftmirr[1].lcn = -1LL;</a>
<a name="ln3632">	g_rl_mftmirr[1].length = 0LL;</a>
<a name="ln3633">	/* Allocate clusters for mft mirror. */</a>
<a name="ln3634">	done = bitmap_allocate(g_mftmirr_lcn,j);</a>
<a name="ln3635">	g_logfile_lcn = g_mftmirr_lcn + j;</a>
<a name="ln3636">	ntfs_log_debug(&quot;$LogFile logical cluster number = 0x%llx\n&quot;,</a>
<a name="ln3637">			g_logfile_lcn);</a>
<a name="ln3638">	return (done);</a>
<a name="ln3639">}</a>
<a name="ln3640"> </a>
<a name="ln3641">/**</a>
<a name="ln3642"> * mkntfs_initialize_rl_logfile -</a>
<a name="ln3643"> */</a>
<a name="ln3644">static BOOL mkntfs_initialize_rl_logfile(void)</a>
<a name="ln3645">{</a>
<a name="ln3646">	int j;</a>
<a name="ln3647">	u64 volume_size;</a>
<a name="ln3648"> </a>
<a name="ln3649">	/* Create runlist for log file. */</a>
<a name="ln3650">	g_rl_logfile = ntfs_malloc(2 * sizeof(runlist));</a>
<a name="ln3651">	if (!g_rl_logfile)</a>
<a name="ln3652">		return FALSE;</a>
<a name="ln3653"> </a>
<a name="ln3654"> </a>
<a name="ln3655">	volume_size = g_vol-&gt;nr_clusters &lt;&lt; g_vol-&gt;cluster_size_bits;</a>
<a name="ln3656"> </a>
<a name="ln3657">	g_rl_logfile[0].vcn = 0LL;</a>
<a name="ln3658">	g_rl_logfile[0].lcn = g_logfile_lcn;</a>
<a name="ln3659">	/*</a>
<a name="ln3660">	 * Determine logfile_size from volume_size (rounded up to a cluster),</a>
<a name="ln3661">	 * making sure it does not overflow the end of the volume.</a>
<a name="ln3662">	 */</a>
<a name="ln3663">	if (volume_size &lt; 2048LL * 1024)		/* &lt; 2MiB	*/</a>
<a name="ln3664">		g_logfile_size = 256LL * 1024;		/*   -&gt; 256kiB	*/</a>
<a name="ln3665">	else if (volume_size &lt; 4000000LL)		/* &lt; 4MB	*/</a>
<a name="ln3666">		g_logfile_size = 512LL * 1024;		/*   -&gt; 512kiB	*/</a>
<a name="ln3667">	else if (volume_size &lt;= 200LL * 1024 * 1024)	/* &lt; 200MiB	*/</a>
<a name="ln3668">		g_logfile_size = 2048LL * 1024;		/*   -&gt; 2MiB	*/</a>
<a name="ln3669">	else	{</a>
<a name="ln3670">		/*</a>
<a name="ln3671">		 * FIXME: The $LogFile size is 64 MiB upwards from 12GiB but</a>
<a name="ln3672">		 * the &quot;200&quot; divider below apparently approximates &quot;100&quot; or</a>
<a name="ln3673">		 * some other value as the volume size decreases. For example:</a>
<a name="ln3674">		 *      Volume size   LogFile size    Ratio</a>
<a name="ln3675">		 *	  8799808        46048       191.100</a>
<a name="ln3676">		 *	  8603248        45072       190.877</a>
<a name="ln3677">		 *	  7341704        38768       189.375</a>
<a name="ln3678">		 *	  6144828        32784       187.433</a>
<a name="ln3679">		 *	  4192932        23024       182.111</a>
<a name="ln3680">		 */</a>
<a name="ln3681">		if (volume_size &gt;= 12LL &lt;&lt; 30)		/* &gt; 12GiB	*/</a>
<a name="ln3682">			g_logfile_size = 64 &lt;&lt; 20;	/*   -&gt; 64MiB	*/</a>
<a name="ln3683">		else</a>
<a name="ln3684">			g_logfile_size = (volume_size / 200) &amp;</a>
<a name="ln3685">					~(g_vol-&gt;cluster_size - 1);</a>
<a name="ln3686">	}</a>
<a name="ln3687">	j = g_logfile_size / g_vol-&gt;cluster_size;</a>
<a name="ln3688">	while (g_rl_logfile[0].lcn + j &gt;= g_vol-&gt;nr_clusters) {</a>
<a name="ln3689">		/*</a>
<a name="ln3690">		 * $Logfile would overflow volume. Need to make it smaller than</a>
<a name="ln3691">		 * the standard size. It's ok as we are creating a non-standard</a>
<a name="ln3692">		 * volume anyway if it is that small.</a>
<a name="ln3693">		 */</a>
<a name="ln3694">		g_logfile_size &gt;&gt;= 1;</a>
<a name="ln3695">		j = g_logfile_size / g_vol-&gt;cluster_size;</a>
<a name="ln3696">	}</a>
<a name="ln3697">	g_logfile_size = (g_logfile_size + g_vol-&gt;cluster_size - 1) &amp;</a>
<a name="ln3698">			~(g_vol-&gt;cluster_size - 1);</a>
<a name="ln3699">	ntfs_log_debug(&quot;$LogFile (journal) size = %ikiB\n&quot;,</a>
<a name="ln3700">			g_logfile_size / 1024);</a>
<a name="ln3701">	/*</a>
<a name="ln3702">	 * FIXME: The 256kiB limit is arbitrary. Should find out what the real</a>
<a name="ln3703">	 * minimum requirement for Windows is so it doesn't blue screen.</a>
<a name="ln3704">	 */</a>
<a name="ln3705">	if (g_logfile_size &lt; 256 &lt;&lt; 10) {</a>
<a name="ln3706">		ntfs_log_error(&quot;$LogFile would be created with invalid size. &quot;</a>
<a name="ln3707">				&quot;This is not allowed as it would cause Windows &quot;</a>
<a name="ln3708">				&quot;to blue screen and during boot.\n&quot;);</a>
<a name="ln3709">		return FALSE;</a>
<a name="ln3710">	}</a>
<a name="ln3711">	g_rl_logfile[1].vcn = j;</a>
<a name="ln3712">	g_rl_logfile[0].length = j;</a>
<a name="ln3713">	g_rl_logfile[1].lcn = -1LL;</a>
<a name="ln3714">	g_rl_logfile[1].length = 0LL;</a>
<a name="ln3715">	/* Allocate clusters for log file. */</a>
<a name="ln3716">	return (bitmap_allocate(g_logfile_lcn,j));</a>
<a name="ln3717">}</a>
<a name="ln3718"> </a>
<a name="ln3719">/**</a>
<a name="ln3720"> * mkntfs_initialize_rl_boot -</a>
<a name="ln3721"> */</a>
<a name="ln3722">static BOOL mkntfs_initialize_rl_boot(void)</a>
<a name="ln3723">{</a>
<a name="ln3724">	int j;</a>
<a name="ln3725">	/* Create runlist for $Boot. */</a>
<a name="ln3726">	g_rl_boot = ntfs_malloc(2 * sizeof(runlist));</a>
<a name="ln3727">	if (!g_rl_boot)</a>
<a name="ln3728">		return FALSE;</a>
<a name="ln3729"> </a>
<a name="ln3730">	g_rl_boot[0].vcn = 0LL;</a>
<a name="ln3731">	g_rl_boot[0].lcn = 0LL;</a>
<a name="ln3732">	/*</a>
<a name="ln3733">	 * $Boot is always 8192 (0x2000) bytes or 1 cluster, whichever is</a>
<a name="ln3734">	 * bigger.</a>
<a name="ln3735">	 */</a>
<a name="ln3736">	j = (8192 + g_vol-&gt;cluster_size - 1) / g_vol-&gt;cluster_size;</a>
<a name="ln3737">	g_rl_boot[1].vcn = j;</a>
<a name="ln3738">	g_rl_boot[0].length = j;</a>
<a name="ln3739">	g_rl_boot[1].lcn = -1LL;</a>
<a name="ln3740">	g_rl_boot[1].length = 0LL;</a>
<a name="ln3741">	/* Allocate clusters for $Boot. */</a>
<a name="ln3742">	return (bitmap_allocate(0,j));</a>
<a name="ln3743">}</a>
<a name="ln3744"> </a>
<a name="ln3745">/**</a>
<a name="ln3746"> * mkntfs_initialize_rl_bad -</a>
<a name="ln3747"> */</a>
<a name="ln3748">static BOOL mkntfs_initialize_rl_bad(void)</a>
<a name="ln3749">{</a>
<a name="ln3750">	/* Create runlist for $BadClus, $DATA named stream $Bad. */</a>
<a name="ln3751">	g_rl_bad = ntfs_malloc(2 * sizeof(runlist));</a>
<a name="ln3752">	if (!g_rl_bad)</a>
<a name="ln3753">		return FALSE;</a>
<a name="ln3754"> </a>
<a name="ln3755">	g_rl_bad[0].vcn = 0LL;</a>
<a name="ln3756">	g_rl_bad[0].lcn = -1LL;</a>
<a name="ln3757">	/*</a>
<a name="ln3758">	 * $BadClus named stream $Bad contains the whole volume as a single</a>
<a name="ln3759">	 * sparse runlist entry.</a>
<a name="ln3760">	 */</a>
<a name="ln3761">	g_rl_bad[1].vcn = g_vol-&gt;nr_clusters;</a>
<a name="ln3762">	g_rl_bad[0].length = g_vol-&gt;nr_clusters;</a>
<a name="ln3763">	g_rl_bad[1].lcn = -1LL;</a>
<a name="ln3764">	g_rl_bad[1].length = 0LL;</a>
<a name="ln3765"> </a>
<a name="ln3766">	/* TODO: Mark bad blocks as such. */</a>
<a name="ln3767">	return TRUE;</a>
<a name="ln3768">}</a>
<a name="ln3769"> </a>
<a name="ln3770">/**</a>
<a name="ln3771"> * mkntfs_fill_device_with_zeroes -</a>
<a name="ln3772"> */</a>
<a name="ln3773">static BOOL mkntfs_fill_device_with_zeroes(void)</a>
<a name="ln3774">{</a>
<a name="ln3775">	/*</a>
<a name="ln3776">	 * If not quick format, fill the device with 0s.</a>
<a name="ln3777">	 * FIXME: Except bad blocks! (AIA)</a>
<a name="ln3778">	 */</a>
<a name="ln3779">	int i;</a>
<a name="ln3780">	ssize_t bw;</a>
<a name="ln3781">	unsigned long long position;</a>
<a name="ln3782">	float progress_inc = (float)g_vol-&gt;nr_clusters / 100;</a>
<a name="ln3783">	u64 volume_size;</a>
<a name="ln3784"> </a>
<a name="ln3785">	volume_size = g_vol-&gt;nr_clusters &lt;&lt; g_vol-&gt;cluster_size_bits;</a>
<a name="ln3786"> </a>
<a name="ln3787">	ntfs_log_progress(&quot;Initializing device with zeroes:   0%%&quot;);</a>
<a name="ln3788">	for (position = 0; position &lt; (unsigned long long)g_vol-&gt;nr_clusters;</a>
<a name="ln3789">			position++) {</a>
<a name="ln3790">		if (!(position % (int)(progress_inc+1))) {</a>
<a name="ln3791">			ntfs_log_progress(&quot;\b\b\b\b%3.0f%%&quot;, position /</a>
<a name="ln3792">					progress_inc);</a>
<a name="ln3793">		}</a>
<a name="ln3794">		bw = mkntfs_write(g_vol-&gt;dev, g_buf, g_vol-&gt;cluster_size);</a>
<a name="ln3795">		if (bw != (ssize_t)g_vol-&gt;cluster_size) {</a>
<a name="ln3796">			if (bw != -1 || errno != EIO) {</a>
<a name="ln3797">				ntfs_log_error(&quot;This should not happen.\n&quot;);</a>
<a name="ln3798">				return FALSE;</a>
<a name="ln3799">			}</a>
<a name="ln3800">			if (!position) {</a>
<a name="ln3801">				ntfs_log_error(&quot;Error: Cluster zero is bad. &quot;</a>
<a name="ln3802">					&quot;Cannot create NTFS file &quot;</a>
<a name="ln3803">					&quot;system.\n&quot;);</a>
<a name="ln3804">				return FALSE;</a>
<a name="ln3805">			}</a>
<a name="ln3806">			/* Add the baddie to our bad blocks list. */</a>
<a name="ln3807">			if (!append_to_bad_blocks(position))</a>
<a name="ln3808">				return FALSE;</a>
<a name="ln3809">			ntfs_log_quiet(&quot;\nFound bad cluster (%lld). Adding to &quot;</a>
<a name="ln3810">				&quot;list of bad blocks.\nInitializing &quot;</a>
<a name="ln3811">				&quot;device with zeroes: %3.0f%%&quot;, position,</a>
<a name="ln3812">				position / progress_inc);</a>
<a name="ln3813">			/* Seek to next cluster. */</a>
<a name="ln3814">			g_vol-&gt;dev-&gt;d_ops-&gt;seek(g_vol-&gt;dev,</a>
<a name="ln3815">					((off_t)position + 1) *</a>
<a name="ln3816">					g_vol-&gt;cluster_size, SEEK_SET);</a>
<a name="ln3817">		}</a>
<a name="ln3818">	}</a>
<a name="ln3819">	ntfs_log_progress(&quot;\b\b\b\b100%%&quot;);</a>
<a name="ln3820">	position = (volume_size &amp; (g_vol-&gt;cluster_size - 1)) /</a>
<a name="ln3821">			opts.sector_size;</a>
<a name="ln3822">	for (i = 0; (unsigned long)i &lt; position; i++) {</a>
<a name="ln3823">		bw = mkntfs_write(g_vol-&gt;dev, g_buf, opts.sector_size);</a>
<a name="ln3824">		if (bw != opts.sector_size) {</a>
<a name="ln3825">			if (bw != -1 || errno != EIO) {</a>
<a name="ln3826">				ntfs_log_error(&quot;This should not happen.\n&quot;);</a>
<a name="ln3827">				return FALSE;</a>
<a name="ln3828">			} else if (i + 1ull == position) {</a>
<a name="ln3829">				ntfs_log_error(&quot;Error: Bad cluster found in &quot;</a>
<a name="ln3830">					&quot;location reserved for system &quot;</a>
<a name="ln3831">					&quot;file $Boot.\n&quot;);</a>
<a name="ln3832">				return FALSE;</a>
<a name="ln3833">			}</a>
<a name="ln3834">			/* Seek to next sector. */</a>
<a name="ln3835">			g_vol-&gt;dev-&gt;d_ops-&gt;seek(g_vol-&gt;dev,</a>
<a name="ln3836">					opts.sector_size, SEEK_CUR);</a>
<a name="ln3837">		}</a>
<a name="ln3838">	}</a>
<a name="ln3839">	ntfs_log_progress(&quot; - Done.\n&quot;);</a>
<a name="ln3840">	return TRUE;</a>
<a name="ln3841">}</a>
<a name="ln3842"> </a>
<a name="ln3843">/**</a>
<a name="ln3844"> * mkntfs_sync_index_record</a>
<a name="ln3845"> *</a>
<a name="ln3846"> * (ERSO) made a function out of this, but the reason for doing that</a>
<a name="ln3847"> * disappeared during coding....</a>
<a name="ln3848"> */</a>
<a name="ln3849">static BOOL mkntfs_sync_index_record(INDEX_ALLOCATION* idx, MFT_RECORD* m,</a>
<a name="ln3850">		ntfschar* name, u32 name_len)</a>
<a name="ln3851">{</a>
<a name="ln3852">	int i, err;</a>
<a name="ln3853">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln3854">	ATTR_RECORD *a;</a>
<a name="ln3855">	long long lw;</a>
<a name="ln3856">	runlist	*rl_index = NULL;</a>
<a name="ln3857"> </a>
<a name="ln3858">	i = 5 * sizeof(ntfschar);</a>
<a name="ln3859">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln3860">	if (!ctx) {</a>
<a name="ln3861">		ntfs_log_perror(&quot;Failed to allocate attribute search context&quot;);</a>
<a name="ln3862">		return FALSE;</a>
<a name="ln3863">	}</a>
<a name="ln3864">	/* FIXME: This should be IGNORE_CASE! */</a>
<a name="ln3865">	if (mkntfs_attr_lookup(AT_INDEX_ALLOCATION, name, name_len,</a>
<a name="ln3866">			CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln3867">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln3868">		ntfs_log_error(&quot;BUG: $INDEX_ALLOCATION attribute not found.\n&quot;);</a>
<a name="ln3869">		return FALSE;</a>
<a name="ln3870">	}</a>
<a name="ln3871">	a = ctx-&gt;attr;</a>
<a name="ln3872">	rl_index = ntfs_mapping_pairs_decompress(g_vol, a, NULL);</a>
<a name="ln3873">	if (!rl_index) {</a>
<a name="ln3874">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln3875">		ntfs_log_error(&quot;Failed to decompress runlist of $INDEX_ALLOCATION &quot;</a>
<a name="ln3876">				&quot;attribute.\n&quot;);</a>
<a name="ln3877">		return FALSE;</a>
<a name="ln3878">	}</a>
<a name="ln3879">	if (sle64_to_cpu(a-&gt;initialized_size) &lt; i) {</a>
<a name="ln3880">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln3881">		free(rl_index);</a>
<a name="ln3882">		ntfs_log_error(&quot;BUG: $INDEX_ALLOCATION attribute too short.\n&quot;);</a>
<a name="ln3883">		return FALSE;</a>
<a name="ln3884">	}</a>
<a name="ln3885">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln3886">	i = sizeof(INDEX_BLOCK) - sizeof(INDEX_HEADER) +</a>
<a name="ln3887">			le32_to_cpu(idx-&gt;index.allocated_size);</a>
<a name="ln3888">	err = ntfs_mst_pre_write_fixup((NTFS_RECORD*)idx, i);</a>
<a name="ln3889">	if (err) {</a>
<a name="ln3890">		free(rl_index);</a>
<a name="ln3891">		ntfs_log_error(&quot;ntfs_mst_pre_write_fixup() failed while &quot;</a>
<a name="ln3892">			&quot;syncing index block.\n&quot;);</a>
<a name="ln3893">		return FALSE;</a>
<a name="ln3894">	}</a>
<a name="ln3895">	lw = ntfs_rlwrite(g_vol-&gt;dev, rl_index, (u8*)idx, i, NULL,</a>
<a name="ln3896">				WRITE_STANDARD);</a>
<a name="ln3897">	free(rl_index);</a>
<a name="ln3898">	if (lw != i) {</a>
<a name="ln3899">		ntfs_log_error(&quot;Error writing $INDEX_ALLOCATION.\n&quot;);</a>
<a name="ln3900">		return FALSE;</a>
<a name="ln3901">	}</a>
<a name="ln3902">	/* No more changes to @idx below here so no need for fixup: */</a>
<a name="ln3903">	/* ntfs_mst_post_write_fixup((NTFS_RECORD*)idx); */</a>
<a name="ln3904">	return TRUE;</a>
<a name="ln3905">}</a>
<a name="ln3906"> </a>
<a name="ln3907">/**</a>
<a name="ln3908"> * create_file_volume -</a>
<a name="ln3909"> */</a>
<a name="ln3910">static BOOL create_file_volume(MFT_RECORD *m, leMFT_REF root_ref,</a>
<a name="ln3911">		VOLUME_FLAGS fl, const GUID *volume_guid)</a>
<a name="ln3912">{</a>
<a name="ln3913">	int i, err;</a>
<a name="ln3914">	u8 *sd;</a>
<a name="ln3915"> </a>
<a name="ln3916">	ntfs_log_verbose(&quot;Creating $Volume (mft record 3)\n&quot;);</a>
<a name="ln3917">	m = (MFT_RECORD*)(g_buf + 3 * g_vol-&gt;mft_record_size);</a>
<a name="ln3918">	err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln3919">			MK_LE_MREF(FILE_Volume, FILE_Volume), 0LL, 0LL,</a>
<a name="ln3920">			FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,</a>
<a name="ln3921">			&quot;$Volume&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln3922">	if (!err) {</a>
<a name="ln3923">		init_system_file_sd(FILE_Volume, &amp;sd, &amp;i);</a>
<a name="ln3924">		err = add_attr_sd(m, sd, i);</a>
<a name="ln3925">	}</a>
<a name="ln3926">	if (!err)</a>
<a name="ln3927">		err = add_attr_data(m, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln3928">				const_cpu_to_le16(0), NULL, 0);</a>
<a name="ln3929">	if (!err)</a>
<a name="ln3930">		err = add_attr_vol_name(m, g_vol-&gt;vol_name, g_vol-&gt;vol_name ?</a>
<a name="ln3931">				strlen(g_vol-&gt;vol_name) : 0);</a>
<a name="ln3932">	if (!err) {</a>
<a name="ln3933">		if (fl &amp; VOLUME_IS_DIRTY)</a>
<a name="ln3934">			ntfs_log_quiet(&quot;Setting the volume dirty so check &quot;</a>
<a name="ln3935">					&quot;disk runs on next reboot into &quot;</a>
<a name="ln3936">					&quot;Windows.\n&quot;);</a>
<a name="ln3937">		err = add_attr_vol_info(m, fl, g_vol-&gt;major_ver,</a>
<a name="ln3938">				g_vol-&gt;minor_ver);</a>
<a name="ln3939">	}</a>
<a name="ln3940">	if (!err &amp;&amp; opts.with_uuid)</a>
<a name="ln3941">		err = add_attr_object_id(m, volume_guid);</a>
<a name="ln3942">	if (err &lt; 0) {</a>
<a name="ln3943">		ntfs_log_error(&quot;Couldn't create $Volume: %s\n&quot;,</a>
<a name="ln3944">				strerror(-err));</a>
<a name="ln3945">		return FALSE;</a>
<a name="ln3946">	}</a>
<a name="ln3947">	return TRUE;</a>
<a name="ln3948">}</a>
<a name="ln3949"> </a>
<a name="ln3950">/**</a>
<a name="ln3951"> * create_backup_boot_sector</a>
<a name="ln3952"> *</a>
<a name="ln3953"> * Return 0 on success or -1 if it couldn't be created.</a>
<a name="ln3954"> */</a>
<a name="ln3955">static int create_backup_boot_sector(u8 *buff)</a>
<a name="ln3956">{</a>
<a name="ln3957">	const char *s;</a>
<a name="ln3958">	ssize_t bw;</a>
<a name="ln3959">	int size, e;</a>
<a name="ln3960"> </a>
<a name="ln3961">	ntfs_log_verbose(&quot;Creating backup boot sector.\n&quot;);</a>
<a name="ln3962">	/*</a>
<a name="ln3963">	 * Write the first max(512, opts.sector_size) bytes from buf to the</a>
<a name="ln3964">	 * last sector, but limit that to 8192 bytes of written data since that</a>
<a name="ln3965">	 * is how big $Boot is (and how big our buffer is)..</a>
<a name="ln3966">	 */</a>
<a name="ln3967">	size = 512;</a>
<a name="ln3968">	if (size &lt; opts.sector_size)</a>
<a name="ln3969">		size = opts.sector_size;</a>
<a name="ln3970">	if (g_vol-&gt;dev-&gt;d_ops-&gt;seek(g_vol-&gt;dev, (opts.num_sectors + 1) *</a>
<a name="ln3971">			opts.sector_size - size, SEEK_SET) == (off_t)-1) {</a>
<a name="ln3972">		ntfs_log_perror(&quot;Seek failed&quot;);</a>
<a name="ln3973">		goto bb_err;</a>
<a name="ln3974">	}</a>
<a name="ln3975">	if (size &gt; 8192)</a>
<a name="ln3976">		size = 8192;</a>
<a name="ln3977">	bw = mkntfs_write(g_vol-&gt;dev, buff, size);</a>
<a name="ln3978">	if (bw == size)</a>
<a name="ln3979">		return 0;</a>
<a name="ln3980">	e = errno;</a>
<a name="ln3981">	if (bw == -1LL)</a>
<a name="ln3982">		s = strerror(e);</a>
<a name="ln3983">	else</a>
<a name="ln3984">		s = &quot;unknown error&quot;;</a>
<a name="ln3985">	/* At least some 2.4 kernels return EIO instead of ENOSPC. */</a>
<a name="ln3986">	if (bw != -1LL || (bw == -1LL &amp;&amp; e != ENOSPC &amp;&amp; e != EIO)) {</a>
<a name="ln3987">		ntfs_log_critical(&quot;Couldn't write backup boot sector: %s\n&quot;, s);</a>
<a name="ln3988">		return -1;</a>
<a name="ln3989">	}</a>
<a name="ln3990">bb_err:</a>
<a name="ln3991">	ntfs_log_error(&quot;Couldn't write backup boot sector. This is due to a &quot;</a>
<a name="ln3992">			&quot;limitation in the\nLinux kernel. This is not a major &quot;</a>
<a name="ln3993">			&quot;problem as Windows check disk will create the\n&quot;</a>
<a name="ln3994">			&quot;backup boot sector when it is run on your next boot &quot;</a>
<a name="ln3995">			&quot;into Windows.\n&quot;);</a>
<a name="ln3996">	return -1;</a>
<a name="ln3997">}</a>
<a name="ln3998"> </a>
<a name="ln3999">/**</a>
<a name="ln4000"> * mkntfs_create_root_structures -</a>
<a name="ln4001"> */</a>
<a name="ln4002">static BOOL mkntfs_create_root_structures(void)</a>
<a name="ln4003">{</a>
<a name="ln4004">	NTFS_BOOT_SECTOR *bs;</a>
<a name="ln4005">	MFT_RECORD *m;</a>
<a name="ln4006">	leMFT_REF root_ref;</a>
<a name="ln4007">	leMFT_REF extend_ref;</a>
<a name="ln4008">	int i;</a>
<a name="ln4009">	int j;</a>
<a name="ln4010">	int err;</a>
<a name="ln4011">	u8 *sd;</a>
<a name="ln4012">	FILE_ATTR_FLAGS extend_flags;</a>
<a name="ln4013">	VOLUME_FLAGS volume_flags = const_cpu_to_le16(0);</a>
<a name="ln4014">	int nr_sysfiles;</a>
<a name="ln4015">	int buf_sds_first_size;</a>
<a name="ln4016">	char *buf_sds;</a>
<a name="ln4017">	GUID vol_guid;</a>
<a name="ln4018"> </a>
<a name="ln4019">	ntfs_log_quiet(&quot;Creating NTFS volume structures.\n&quot;);</a>
<a name="ln4020">	nr_sysfiles = 27;</a>
<a name="ln4021">	/*</a>
<a name="ln4022">	 * Setup an empty mft record.  Note, we can just give 0 as the mft</a>
<a name="ln4023">	 * reference as we are creating an NTFS 1.2 volume for which the mft</a>
<a name="ln4024">	 * reference is ignored by ntfs_mft_record_layout().</a>
<a name="ln4025">	 *</a>
<a name="ln4026">	 * Copy the mft record onto all 16 records in the buffer and setup the</a>
<a name="ln4027">	 * sequence numbers of each system file to equal the mft record number</a>
<a name="ln4028">	 * of that file (only for $MFT is the sequence number 1 rather than 0).</a>
<a name="ln4029">	 */</a>
<a name="ln4030">	for (i = 0; i &lt; nr_sysfiles; i++) {</a>
<a name="ln4031">		if (ntfs_mft_record_layout(g_vol, 0, m = (MFT_RECORD *)(g_buf +</a>
<a name="ln4032">				i * g_vol-&gt;mft_record_size))) {</a>
<a name="ln4033">			ntfs_log_error(&quot;Failed to layout system mft records.&quot;</a>
<a name="ln4034">					&quot;\n&quot;);</a>
<a name="ln4035">			return FALSE;</a>
<a name="ln4036">		}</a>
<a name="ln4037">		if (i == 0 || i &gt; 23)</a>
<a name="ln4038">			m-&gt;sequence_number = cpu_to_le16(1);</a>
<a name="ln4039">		else</a>
<a name="ln4040">			m-&gt;sequence_number = cpu_to_le16(i);</a>
<a name="ln4041">	}</a>
<a name="ln4042">	/*</a>
<a name="ln4043">	 * If only one cluster contains all system files then</a>
<a name="ln4044">	 * fill the rest of it with empty, formatted records.</a>
<a name="ln4045">	 */</a>
<a name="ln4046">	if (nr_sysfiles * (s32)g_vol-&gt;mft_record_size &lt; g_mft_size) {</a>
<a name="ln4047">		for (i = nr_sysfiles;</a>
<a name="ln4048">		      i * (s32)g_vol-&gt;mft_record_size &lt; g_mft_size; i++) {</a>
<a name="ln4049">			m = (MFT_RECORD *)(g_buf + i * g_vol-&gt;mft_record_size);</a>
<a name="ln4050">			if (ntfs_mft_record_layout(g_vol, 0, m)) {</a>
<a name="ln4051">				ntfs_log_error(&quot;Failed to layout mft record.&quot;</a>
<a name="ln4052">						&quot;\n&quot;);</a>
<a name="ln4053">				return FALSE;</a>
<a name="ln4054">			}</a>
<a name="ln4055">			m-&gt;flags = cpu_to_le16(0);</a>
<a name="ln4056">			m-&gt;sequence_number = cpu_to_le16(i);</a>
<a name="ln4057">		}</a>
<a name="ln4058">	}</a>
<a name="ln4059">	/*</a>
<a name="ln4060">	 * Create the 16 system files, adding the system information attribute</a>
<a name="ln4061">	 * to each as well as marking them in use in the mft bitmap.</a>
<a name="ln4062">	 */</a>
<a name="ln4063">	for (i = 0; i &lt; nr_sysfiles; i++) {</a>
<a name="ln4064">		le32 file_attrs;</a>
<a name="ln4065"> </a>
<a name="ln4066">		m = (MFT_RECORD*)(g_buf + i * g_vol-&gt;mft_record_size);</a>
<a name="ln4067">		if (i &lt; 16 || i &gt; 23) {</a>
<a name="ln4068">			m-&gt;mft_record_number = cpu_to_le32(i);</a>
<a name="ln4069">			m-&gt;flags |= MFT_RECORD_IN_USE;</a>
<a name="ln4070">			ntfs_bit_set(g_mft_bitmap, 0LL + i, 1);</a>
<a name="ln4071">		}</a>
<a name="ln4072">		file_attrs = FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM;</a>
<a name="ln4073">		if (i == FILE_root) {</a>
<a name="ln4074">			file_attrs |= FILE_ATTR_ARCHIVE;</a>
<a name="ln4075">			if (opts.disable_indexing)</a>
<a name="ln4076">				file_attrs |= FILE_ATTR_NOT_CONTENT_INDEXED;</a>
<a name="ln4077">			if (opts.enable_compression)</a>
<a name="ln4078">				file_attrs |= FILE_ATTR_COMPRESSED;</a>
<a name="ln4079">		}</a>
<a name="ln4080">		/* setting specific security_id flag and */</a>
<a name="ln4081">		/* file permissions for ntfs 3.x */</a>
<a name="ln4082">		if (i == 0 || i == 1 || i == 2 || i == 6 || i == 8 ||</a>
<a name="ln4083">				i == 10) {</a>
<a name="ln4084">			add_attr_std_info(m, file_attrs,</a>
<a name="ln4085">				cpu_to_le32(0x0100));</a>
<a name="ln4086">		} else if (i == 9) {</a>
<a name="ln4087">			file_attrs |= FILE_ATTR_VIEW_INDEX_PRESENT;</a>
<a name="ln4088">			add_attr_std_info(m, file_attrs,</a>
<a name="ln4089">				cpu_to_le32(0x0101));</a>
<a name="ln4090">		} else if (i == 11) {</a>
<a name="ln4091">			add_attr_std_info(m, file_attrs,</a>
<a name="ln4092">				cpu_to_le32(0x0101));</a>
<a name="ln4093">		} else if (i == 24 || i == 25 || i == 26) {</a>
<a name="ln4094">			file_attrs |= FILE_ATTR_ARCHIVE;</a>
<a name="ln4095">			file_attrs |= FILE_ATTR_VIEW_INDEX_PRESENT;</a>
<a name="ln4096">			add_attr_std_info(m, file_attrs,</a>
<a name="ln4097">				cpu_to_le32(0x0101));</a>
<a name="ln4098">		} else {</a>
<a name="ln4099">			add_attr_std_info(m, file_attrs,</a>
<a name="ln4100">				cpu_to_le32(0x00));</a>
<a name="ln4101">		}</a>
<a name="ln4102">	}</a>
<a name="ln4103">	/* The root directory mft reference. */</a>
<a name="ln4104">	root_ref = MK_LE_MREF(FILE_root, FILE_root);</a>
<a name="ln4105">	extend_ref = MK_LE_MREF(11,11);</a>
<a name="ln4106">	ntfs_log_verbose(&quot;Creating root directory (mft record 5)\n&quot;);</a>
<a name="ln4107">	m = (MFT_RECORD*)(g_buf + 5 * g_vol-&gt;mft_record_size);</a>
<a name="ln4108">	m-&gt;flags |= MFT_RECORD_IS_DIRECTORY;</a>
<a name="ln4109">	m-&gt;link_count = cpu_to_le16(le16_to_cpu(m-&gt;link_count) + 1);</a>
<a name="ln4110">	err = add_attr_file_name(m, root_ref, 0LL, 0LL,</a>
<a name="ln4111">			FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM |</a>
<a name="ln4112">			FILE_ATTR_I30_INDEX_PRESENT, 0, 0, &quot;.&quot;,</a>
<a name="ln4113">			FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4114">	if (!err) {</a>
<a name="ln4115">		init_root_sd(&amp;sd, &amp;i);</a>
<a name="ln4116">		err = add_attr_sd(m, sd, i);</a>
<a name="ln4117">	}</a>
<a name="ln4118">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4119">	if (!err)</a>
<a name="ln4120">		err = add_attr_index_root(m, &quot;$I30&quot;, 4, CASE_SENSITIVE,</a>
<a name="ln4121">				AT_FILE_NAME, COLLATION_FILE_NAME,</a>
<a name="ln4122">				g_vol-&gt;indx_record_size);</a>
<a name="ln4123">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4124">	if (!err)</a>
<a name="ln4125">		err = upgrade_to_large_index(m, &quot;$I30&quot;, 4, CASE_SENSITIVE,</a>
<a name="ln4126">				&amp;g_index_block);</a>
<a name="ln4127">	if (!err) {</a>
<a name="ln4128">		ntfs_attr_search_ctx *ctx;</a>
<a name="ln4129">		ATTR_RECORD *a;</a>
<a name="ln4130">		ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln4131">		if (!ctx) {</a>
<a name="ln4132">			ntfs_log_perror(&quot;Failed to allocate attribute search &quot;</a>
<a name="ln4133">					&quot;context&quot;);</a>
<a name="ln4134">			return FALSE;</a>
<a name="ln4135">		}</a>
<a name="ln4136">		/* There is exactly one file name so this is ok. */</a>
<a name="ln4137">		if (mkntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0,</a>
<a name="ln4138">				CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln4139">			ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln4140">			ntfs_log_error(&quot;BUG: $FILE_NAME attribute not found.&quot;</a>
<a name="ln4141">					&quot;\n&quot;);</a>
<a name="ln4142">			return FALSE;</a>
<a name="ln4143">		}</a>
<a name="ln4144">		a = ctx-&gt;attr;</a>
<a name="ln4145">		err = insert_file_link_in_dir_index(g_index_block, root_ref,</a>
<a name="ln4146">				(FILE_NAME_ATTR*)((char*)a +</a>
<a name="ln4147">				le16_to_cpu(a-&gt;value_offset)),</a>
<a name="ln4148">				le32_to_cpu(a-&gt;value_length));</a>
<a name="ln4149">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln4150">	}</a>
<a name="ln4151">	if (err) {</a>
<a name="ln4152">		ntfs_log_error(&quot;Couldn't create root directory: %s\n&quot;,</a>
<a name="ln4153">			strerror(-err));</a>
<a name="ln4154">		return FALSE;</a>
<a name="ln4155">	}</a>
<a name="ln4156">	/* Add all other attributes, on a per-file basis for clarity. */</a>
<a name="ln4157">	ntfs_log_verbose(&quot;Creating $MFT (mft record 0)\n&quot;);</a>
<a name="ln4158">	m = (MFT_RECORD*)g_buf;</a>
<a name="ln4159">	err = add_attr_data_positioned(m, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4160">			const_cpu_to_le16(0), g_rl_mft, g_buf, g_mft_size);</a>
<a name="ln4161">	if (!err)</a>
<a name="ln4162">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4163">				MK_LE_MREF(FILE_MFT, 1),</a>
<a name="ln4164">				((g_mft_size - 1)</a>
<a name="ln4165">					| (g_vol-&gt;cluster_size - 1)) + 1,</a>
<a name="ln4166">				g_mft_size, FILE_ATTR_HIDDEN |</a>
<a name="ln4167">				FILE_ATTR_SYSTEM, 0, 0, &quot;$MFT&quot;,</a>
<a name="ln4168">				FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4169">	/* mft_bitmap is not modified in mkntfs; no need to sync it later. */</a>
<a name="ln4170">	if (!err)</a>
<a name="ln4171">		err = add_attr_bitmap_positioned(m, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4172">				g_rl_mft_bmp,</a>
<a name="ln4173">				g_mft_bitmap, g_mft_bitmap_byte_size);</a>
<a name="ln4174">	if (err &lt; 0) {</a>
<a name="ln4175">		ntfs_log_error(&quot;Couldn't create $MFT: %s\n&quot;, strerror(-err));</a>
<a name="ln4176">		return FALSE;</a>
<a name="ln4177">	}</a>
<a name="ln4178">	ntfs_log_verbose(&quot;Creating $MFTMirr (mft record 1)\n&quot;);</a>
<a name="ln4179">	m = (MFT_RECORD*)(g_buf + 1 * g_vol-&gt;mft_record_size);</a>
<a name="ln4180">	err = add_attr_data_positioned(m, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4181">			const_cpu_to_le16(0), g_rl_mftmirr, g_buf,</a>
<a name="ln4182">			g_rl_mftmirr[0].length * g_vol-&gt;cluster_size);</a>
<a name="ln4183">	if (!err)</a>
<a name="ln4184">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4185">				MK_LE_MREF(FILE_MFTMirr, FILE_MFTMirr),</a>
<a name="ln4186">				g_rl_mftmirr[0].length * g_vol-&gt;cluster_size,</a>
<a name="ln4187">				g_rl_mftmirr[0].length * g_vol-&gt;cluster_size,</a>
<a name="ln4188">				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,</a>
<a name="ln4189">				&quot;$MFTMirr&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4190">	if (err &lt; 0) {</a>
<a name="ln4191">		ntfs_log_error(&quot;Couldn't create $MFTMirr: %s\n&quot;,</a>
<a name="ln4192">				strerror(-err));</a>
<a name="ln4193">		return FALSE;</a>
<a name="ln4194">	}</a>
<a name="ln4195">	ntfs_log_verbose(&quot;Creating $LogFile (mft record 2)\n&quot;);</a>
<a name="ln4196">	m = (MFT_RECORD*)(g_buf + 2 * g_vol-&gt;mft_record_size);</a>
<a name="ln4197">	err = add_attr_data_positioned(m, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4198">			const_cpu_to_le16(0), g_rl_logfile,</a>
<a name="ln4199">			(const u8*)NULL, g_logfile_size);</a>
<a name="ln4200">	if (!err)</a>
<a name="ln4201">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4202">				MK_LE_MREF(FILE_LogFile, FILE_LogFile),</a>
<a name="ln4203">				g_logfile_size, g_logfile_size,</a>
<a name="ln4204">				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,</a>
<a name="ln4205">				&quot;$LogFile&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4206">	if (err &lt; 0) {</a>
<a name="ln4207">		ntfs_log_error(&quot;Couldn't create $LogFile: %s\n&quot;,</a>
<a name="ln4208">				strerror(-err));</a>
<a name="ln4209">		return FALSE;</a>
<a name="ln4210">	}</a>
<a name="ln4211">	ntfs_log_verbose(&quot;Creating $AttrDef (mft record 4)\n&quot;);</a>
<a name="ln4212">	m = (MFT_RECORD*)(g_buf + 4 * g_vol-&gt;mft_record_size);</a>
<a name="ln4213">	err = add_attr_data(m, NULL, 0, CASE_SENSITIVE, const_cpu_to_le16(0),</a>
<a name="ln4214">			(u8*)g_vol-&gt;attrdef, g_vol-&gt;attrdef_len);</a>
<a name="ln4215">	if (!err)</a>
<a name="ln4216">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4217">				MK_LE_MREF(FILE_AttrDef, FILE_AttrDef),</a>
<a name="ln4218">				(g_vol-&gt;attrdef_len + g_vol-&gt;cluster_size - 1) &amp;</a>
<a name="ln4219">				~(g_vol-&gt;cluster_size - 1), g_vol-&gt;attrdef_len,</a>
<a name="ln4220">				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,</a>
<a name="ln4221">				&quot;$AttrDef&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4222">	if (!err) {</a>
<a name="ln4223">		init_system_file_sd(FILE_AttrDef, &amp;sd, &amp;i);</a>
<a name="ln4224">		err = add_attr_sd(m, sd, i);</a>
<a name="ln4225">	}</a>
<a name="ln4226">	if (err &lt; 0) {</a>
<a name="ln4227">		ntfs_log_error(&quot;Couldn't create $AttrDef: %s\n&quot;,</a>
<a name="ln4228">				strerror(-err));</a>
<a name="ln4229">		return FALSE;</a>
<a name="ln4230">	}</a>
<a name="ln4231">	ntfs_log_verbose(&quot;Creating $Bitmap (mft record 6)\n&quot;);</a>
<a name="ln4232">	m = (MFT_RECORD*)(g_buf + 6 * g_vol-&gt;mft_record_size);</a>
<a name="ln4233">	/* the data attribute of $Bitmap must be non-resident or otherwise */</a>
<a name="ln4234">	/* windows 2003 will regard the volume as corrupt (ERSO) */</a>
<a name="ln4235">	if (!err)</a>
<a name="ln4236">		err = insert_non_resident_attr_in_mft_record(m,</a>
<a name="ln4237">			AT_DATA,  NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4238">			const_cpu_to_le16(0), (const u8*)NULL,</a>
<a name="ln4239">			g_lcn_bitmap_byte_size, WRITE_BITMAP);</a>
<a name="ln4240"> </a>
<a name="ln4241"> </a>
<a name="ln4242">	if (!err)</a>
<a name="ln4243">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4244">				MK_LE_MREF(FILE_Bitmap, FILE_Bitmap),</a>
<a name="ln4245">				(g_lcn_bitmap_byte_size + g_vol-&gt;cluster_size -</a>
<a name="ln4246">				1) &amp; ~(g_vol-&gt;cluster_size - 1),</a>
<a name="ln4247">				g_lcn_bitmap_byte_size,</a>
<a name="ln4248">				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,</a>
<a name="ln4249">				&quot;$Bitmap&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4250">	if (err &lt; 0) {</a>
<a name="ln4251">		ntfs_log_error(&quot;Couldn't create $Bitmap: %s\n&quot;, strerror(-err));</a>
<a name="ln4252">		return FALSE;</a>
<a name="ln4253">	}</a>
<a name="ln4254">	ntfs_log_verbose(&quot;Creating $Boot (mft record 7)\n&quot;);</a>
<a name="ln4255">	m = (MFT_RECORD*)(g_buf + 7 * g_vol-&gt;mft_record_size);</a>
<a name="ln4256">	bs = ntfs_calloc(8192);</a>
<a name="ln4257">	if (!bs)</a>
<a name="ln4258">		return FALSE;</a>
<a name="ln4259">	memcpy(bs, boot_array, sizeof(boot_array));</a>
<a name="ln4260">	/*</a>
<a name="ln4261">	 * Create the boot sector in bs. Note, that bs is already zeroed</a>
<a name="ln4262">	 * in the boot sector section and that it has the NTFS OEM id/magic</a>
<a name="ln4263">	 * already inserted, so no need to worry about these things.</a>
<a name="ln4264">	 */</a>
<a name="ln4265">	bs-&gt;bpb.bytes_per_sector = cpu_to_le16(opts.sector_size);</a>
<a name="ln4266">	bs-&gt;bpb.sectors_per_cluster = (u8)(g_vol-&gt;cluster_size /</a>
<a name="ln4267">			opts.sector_size);</a>
<a name="ln4268">	bs-&gt;bpb.media_type = 0xf8; /* hard disk */</a>
<a name="ln4269">	bs-&gt;bpb.sectors_per_track = cpu_to_le16(opts.sectors_per_track);</a>
<a name="ln4270">	ntfs_log_debug(&quot;sectors per track = %ld (0x%lx)\n&quot;,</a>
<a name="ln4271">			opts.sectors_per_track, opts.sectors_per_track);</a>
<a name="ln4272">	bs-&gt;bpb.heads = cpu_to_le16(opts.heads);</a>
<a name="ln4273">	ntfs_log_debug(&quot;heads = %ld (0x%lx)\n&quot;, opts.heads, opts.heads);</a>
<a name="ln4274">	bs-&gt;bpb.hidden_sectors = cpu_to_le32(opts.part_start_sect);</a>
<a name="ln4275">	ntfs_log_debug(&quot;hidden sectors = %llu (0x%llx)\n&quot;, opts.part_start_sect,</a>
<a name="ln4276">			opts.part_start_sect);</a>
<a name="ln4277">	bs-&gt;physical_drive = 0x80;  	    /* boot from hard disk */</a>
<a name="ln4278">	bs-&gt;extended_boot_signature = 0x80; /* everybody sets this, so we do */</a>
<a name="ln4279">	bs-&gt;number_of_sectors = cpu_to_sle64(opts.num_sectors);</a>
<a name="ln4280">	bs-&gt;mft_lcn = cpu_to_sle64(g_mft_lcn);</a>
<a name="ln4281">	bs-&gt;mftmirr_lcn = cpu_to_sle64(g_mftmirr_lcn);</a>
<a name="ln4282">	if (g_vol-&gt;mft_record_size &gt;= g_vol-&gt;cluster_size) {</a>
<a name="ln4283">		bs-&gt;clusters_per_mft_record = g_vol-&gt;mft_record_size /</a>
<a name="ln4284">			g_vol-&gt;cluster_size;</a>
<a name="ln4285">	} else {</a>
<a name="ln4286">		bs-&gt;clusters_per_mft_record = -(ffs(g_vol-&gt;mft_record_size) -</a>
<a name="ln4287">				1);</a>
<a name="ln4288">		if ((u32)(1 &lt;&lt; -bs-&gt;clusters_per_mft_record) !=</a>
<a name="ln4289">				g_vol-&gt;mft_record_size) {</a>
<a name="ln4290">			free(bs);</a>
<a name="ln4291">			ntfs_log_error(&quot;BUG: calculated clusters_per_mft_record&quot;</a>
<a name="ln4292">					&quot; is wrong (= 0x%x)\n&quot;,</a>
<a name="ln4293">					bs-&gt;clusters_per_mft_record);</a>
<a name="ln4294">			return FALSE;</a>
<a name="ln4295">		}</a>
<a name="ln4296">	}</a>
<a name="ln4297">	ntfs_log_debug(&quot;clusters per mft record = %i (0x%x)\n&quot;,</a>
<a name="ln4298">			bs-&gt;clusters_per_mft_record,</a>
<a name="ln4299">			bs-&gt;clusters_per_mft_record);</a>
<a name="ln4300">	if (g_vol-&gt;indx_record_size &gt;= g_vol-&gt;cluster_size) {</a>
<a name="ln4301">		bs-&gt;clusters_per_index_record = g_vol-&gt;indx_record_size /</a>
<a name="ln4302">			g_vol-&gt;cluster_size;</a>
<a name="ln4303">	} else {</a>
<a name="ln4304">		bs-&gt;clusters_per_index_record = -g_vol-&gt;indx_record_size_bits;</a>
<a name="ln4305">		if ((1 &lt;&lt; -bs-&gt;clusters_per_index_record) !=</a>
<a name="ln4306">				(s32)g_vol-&gt;indx_record_size) {</a>
<a name="ln4307">			free(bs);</a>
<a name="ln4308">			ntfs_log_error(&quot;BUG: calculated &quot;</a>
<a name="ln4309">					&quot;clusters_per_index_record is wrong &quot;</a>
<a name="ln4310">					&quot;(= 0x%x)\n&quot;,</a>
<a name="ln4311">					bs-&gt;clusters_per_index_record);</a>
<a name="ln4312">			return FALSE;</a>
<a name="ln4313">		}</a>
<a name="ln4314">	}</a>
<a name="ln4315">	ntfs_log_debug(&quot;clusters per index block = %i (0x%x)\n&quot;,</a>
<a name="ln4316">			bs-&gt;clusters_per_index_record,</a>
<a name="ln4317">			bs-&gt;clusters_per_index_record);</a>
<a name="ln4318">	/* Generate a 64-bit random number for the serial number. */</a>
<a name="ln4319">	bs-&gt;volume_serial_number = cpu_to_le64(((u64)random() &lt;&lt; 32) |</a>
<a name="ln4320">			((u64)random() &amp; 0xffffffff));</a>
<a name="ln4321">	/*</a>
<a name="ln4322">	 * Leave zero for now as NT4 leaves it zero, too. If want it later, see</a>
<a name="ln4323">	 * ../libntfs/bootsect.c for how to calculate it.</a>
<a name="ln4324">	 */</a>
<a name="ln4325">	bs-&gt;checksum = cpu_to_le32(0);</a>
<a name="ln4326">	/* Make sure the bootsector is ok. */</a>
<a name="ln4327">	if (!ntfs_boot_sector_is_ntfs(bs)) {</a>
<a name="ln4328">		free(bs);</a>
<a name="ln4329">		ntfs_log_error(&quot;FATAL: Generated boot sector is invalid!\n&quot;);</a>
<a name="ln4330">		return FALSE;</a>
<a name="ln4331">	}</a>
<a name="ln4332">	err = add_attr_data_positioned(m, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4333">			const_cpu_to_le16(0), g_rl_boot, (u8*)bs, 8192);</a>
<a name="ln4334">	if (!err)</a>
<a name="ln4335">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4336">				MK_LE_MREF(FILE_Boot, FILE_Boot),</a>
<a name="ln4337">				(8192 + g_vol-&gt;cluster_size - 1) &amp;</a>
<a name="ln4338">				~(g_vol-&gt;cluster_size - 1), 8192,</a>
<a name="ln4339">				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,</a>
<a name="ln4340">				&quot;$Boot&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4341">	if (!err) {</a>
<a name="ln4342">		init_system_file_sd(FILE_Boot, &amp;sd, &amp;i);</a>
<a name="ln4343">		err = add_attr_sd(m, sd, i);</a>
<a name="ln4344">	}</a>
<a name="ln4345">	if (err &lt; 0) {</a>
<a name="ln4346">		free(bs);</a>
<a name="ln4347">		ntfs_log_error(&quot;Couldn't create $Boot: %s\n&quot;, strerror(-err));</a>
<a name="ln4348">		return FALSE;</a>
<a name="ln4349">	}</a>
<a name="ln4350">	if (create_backup_boot_sector((u8*)bs)) {</a>
<a name="ln4351">		/*</a>
<a name="ln4352">		 * Pre-2.6 kernels couldn't access the last sector if it was</a>
<a name="ln4353">		 * odd and we failed to set the device block size to the sector</a>
<a name="ln4354">		 * size, hence we schedule chkdsk to create it.</a>
<a name="ln4355">		 */</a>
<a name="ln4356">		volume_flags |= VOLUME_IS_DIRTY;</a>
<a name="ln4357">	}</a>
<a name="ln4358">	free(bs);</a>
<a name="ln4359">	/*</a>
<a name="ln4360">	 * We cheat a little here and if the user has requested all times to be</a>
<a name="ln4361">	 * set to zero then we set the GUID to zero as well.  This options is</a>
<a name="ln4362">	 * only used for development purposes so that should be fine.</a>
<a name="ln4363">	 */</a>
<a name="ln4364">	if (!opts.use_epoch_time) {</a>
<a name="ln4365">		/* Generate a GUID for the volume. */</a>
<a name="ln4366">#ifdef ENABLE_UUID</a>
<a name="ln4367">		uuid_generate((void*)&amp;vol_guid);</a>
<a name="ln4368">#else</a>
<a name="ln4369">		ntfs_generate_guid(&amp;vol_guid);</a>
<a name="ln4370">#endif</a>
<a name="ln4371">	} else</a>
<a name="ln4372">		memset(&amp;vol_guid, 0, sizeof(vol_guid));</a>
<a name="ln4373">	if (!create_file_volume(m, root_ref, volume_flags, &amp;vol_guid))</a>
<a name="ln4374">		return FALSE;</a>
<a name="ln4375">	ntfs_log_verbose(&quot;Creating $BadClus (mft record 8)\n&quot;);</a>
<a name="ln4376">	m = (MFT_RECORD*)(g_buf + 8 * g_vol-&gt;mft_record_size);</a>
<a name="ln4377">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4378">	/* Create a sparse named stream of size equal to the volume size. */</a>
<a name="ln4379">	err = add_attr_data_positioned(m, &quot;$Bad&quot;, 4, CASE_SENSITIVE,</a>
<a name="ln4380">			const_cpu_to_le16(0), g_rl_bad, NULL,</a>
<a name="ln4381">			g_vol-&gt;nr_clusters * g_vol-&gt;cluster_size);</a>
<a name="ln4382">	if (!err) {</a>
<a name="ln4383">		err = add_attr_data(m, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4384">				const_cpu_to_le16(0), NULL, 0);</a>
<a name="ln4385">	}</a>
<a name="ln4386">	if (!err) {</a>
<a name="ln4387">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4388">				MK_LE_MREF(FILE_BadClus, FILE_BadClus),</a>
<a name="ln4389">				0LL, 0LL, FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM,</a>
<a name="ln4390">				0, 0, &quot;$BadClus&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4391">	}</a>
<a name="ln4392">	if (err &lt; 0) {</a>
<a name="ln4393">		ntfs_log_error(&quot;Couldn't create $BadClus: %s\n&quot;,</a>
<a name="ln4394">				strerror(-err));</a>
<a name="ln4395">		return FALSE;</a>
<a name="ln4396">	}</a>
<a name="ln4397">	/* create $Secure (NTFS 3.0+) */</a>
<a name="ln4398">	ntfs_log_verbose(&quot;Creating $Secure (mft record 9)\n&quot;);</a>
<a name="ln4399">	m = (MFT_RECORD*)(g_buf + 9 * g_vol-&gt;mft_record_size);</a>
<a name="ln4400">	m-&gt;flags |= MFT_RECORD_IS_VIEW_INDEX;</a>
<a name="ln4401">	if (!err)</a>
<a name="ln4402">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4403">				MK_LE_MREF(9, 9), 0LL, 0LL,</a>
<a name="ln4404">				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM |</a>
<a name="ln4405">				FILE_ATTR_VIEW_INDEX_PRESENT, 0, 0,</a>
<a name="ln4406">				&quot;$Secure&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4407">	buf_sds = NULL;</a>
<a name="ln4408">	buf_sds_first_size = 0;</a>
<a name="ln4409">	if (!err) {</a>
<a name="ln4410">		int buf_sds_size;</a>
<a name="ln4411"> </a>
<a name="ln4412">		buf_sds_first_size = 0xfc;</a>
<a name="ln4413">		buf_sds_size = 0x40000 + buf_sds_first_size;</a>
<a name="ln4414">		buf_sds = ntfs_calloc(buf_sds_size);</a>
<a name="ln4415">		if (!buf_sds)</a>
<a name="ln4416">			return FALSE;</a>
<a name="ln4417">		init_secure_sds(buf_sds);</a>
<a name="ln4418">		memcpy(buf_sds + 0x40000, buf_sds, buf_sds_first_size);</a>
<a name="ln4419">		err = add_attr_data(m, &quot;$SDS&quot;, 4, CASE_SENSITIVE,</a>
<a name="ln4420">				const_cpu_to_le16(0), (u8*)buf_sds,</a>
<a name="ln4421">				buf_sds_size);</a>
<a name="ln4422">	}</a>
<a name="ln4423">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4424">	if (!err)</a>
<a name="ln4425">		err = add_attr_index_root(m, &quot;$SDH&quot;, 4, CASE_SENSITIVE,</a>
<a name="ln4426">			AT_UNUSED, COLLATION_NTOFS_SECURITY_HASH,</a>
<a name="ln4427">			g_vol-&gt;indx_record_size);</a>
<a name="ln4428">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4429">	if (!err)</a>
<a name="ln4430">		err = add_attr_index_root(m, &quot;$SII&quot;, 4, CASE_SENSITIVE,</a>
<a name="ln4431">			AT_UNUSED, COLLATION_NTOFS_ULONG,</a>
<a name="ln4432">			g_vol-&gt;indx_record_size);</a>
<a name="ln4433">	if (!err)</a>
<a name="ln4434">		err = initialize_secure(buf_sds, buf_sds_first_size, m);</a>
<a name="ln4435">	free(buf_sds);</a>
<a name="ln4436">	if (err &lt; 0) {</a>
<a name="ln4437">		ntfs_log_error(&quot;Couldn't create $Secure: %s\n&quot;,</a>
<a name="ln4438">			strerror(-err));</a>
<a name="ln4439">		return FALSE;</a>
<a name="ln4440">	}</a>
<a name="ln4441">	ntfs_log_verbose(&quot;Creating $UpCase (mft record 0xa)\n&quot;);</a>
<a name="ln4442">	m = (MFT_RECORD*)(g_buf + 0xa * g_vol-&gt;mft_record_size);</a>
<a name="ln4443">	err = add_attr_data(m, NULL, 0, CASE_SENSITIVE, const_cpu_to_le16(0),</a>
<a name="ln4444">			(u8*)g_vol-&gt;upcase, g_vol-&gt;upcase_len &lt;&lt; 1);</a>
<a name="ln4445">	if (!err)</a>
<a name="ln4446">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4447">				MK_LE_MREF(FILE_UpCase, FILE_UpCase),</a>
<a name="ln4448">				((g_vol-&gt;upcase_len &lt;&lt; 1) +</a>
<a name="ln4449">				g_vol-&gt;cluster_size - 1) &amp;</a>
<a name="ln4450">				~(g_vol-&gt;cluster_size - 1),</a>
<a name="ln4451">				g_vol-&gt;upcase_len &lt;&lt; 1,</a>
<a name="ln4452">				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM, 0, 0,</a>
<a name="ln4453">				&quot;$UpCase&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4454">	if (err &lt; 0) {</a>
<a name="ln4455">		ntfs_log_error(&quot;Couldn't create $UpCase: %s\n&quot;, strerror(-err));</a>
<a name="ln4456">		return FALSE;</a>
<a name="ln4457">	}</a>
<a name="ln4458">	ntfs_log_verbose(&quot;Creating $Extend (mft record 11)\n&quot;);</a>
<a name="ln4459">	/*</a>
<a name="ln4460">	 * $Extend index must be resident.  Otherwise, w2k3 will regard the</a>
<a name="ln4461">	 * volume as corrupt. (ERSO)</a>
<a name="ln4462">	 */</a>
<a name="ln4463">	m = (MFT_RECORD*)(g_buf + 11 * g_vol-&gt;mft_record_size);</a>
<a name="ln4464">	m-&gt;flags |= MFT_RECORD_IS_DIRECTORY;</a>
<a name="ln4465">	if (!err)</a>
<a name="ln4466">		err = create_hardlink(g_index_block, root_ref, m,</a>
<a name="ln4467">				MK_LE_MREF(11, 11), 0LL, 0LL,</a>
<a name="ln4468">				FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM |</a>
<a name="ln4469">				FILE_ATTR_I30_INDEX_PRESENT, 0, 0,</a>
<a name="ln4470">				&quot;$Extend&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4471">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4472">	if (!err)</a>
<a name="ln4473">		err = add_attr_index_root(m, &quot;$I30&quot;, 4, CASE_SENSITIVE,</a>
<a name="ln4474">			AT_FILE_NAME, COLLATION_FILE_NAME,</a>
<a name="ln4475">			g_vol-&gt;indx_record_size);</a>
<a name="ln4476">	if (err &lt; 0) {</a>
<a name="ln4477">		ntfs_log_error(&quot;Couldn't create $Extend: %s\n&quot;,</a>
<a name="ln4478">			strerror(-err));</a>
<a name="ln4479">		return FALSE;</a>
<a name="ln4480">	}</a>
<a name="ln4481">	/* NTFS reserved system files (mft records 0xc-0xf) */</a>
<a name="ln4482">	for (i = 0xc; i &lt; 0x10; i++) {</a>
<a name="ln4483">		ntfs_log_verbose(&quot;Creating system file (mft record 0x%x)\n&quot;, i);</a>
<a name="ln4484">		m = (MFT_RECORD*)(g_buf + i * g_vol-&gt;mft_record_size);</a>
<a name="ln4485">		err = add_attr_data(m, NULL, 0, CASE_SENSITIVE,</a>
<a name="ln4486">				const_cpu_to_le16(0), NULL, 0);</a>
<a name="ln4487">		if (!err) {</a>
<a name="ln4488">			init_system_file_sd(i, &amp;sd, &amp;j);</a>
<a name="ln4489">			err = add_attr_sd(m, sd, j);</a>
<a name="ln4490">		}</a>
<a name="ln4491">		if (err &lt; 0) {</a>
<a name="ln4492">			ntfs_log_error(&quot;Couldn't create system file %i (0x%x): &quot;</a>
<a name="ln4493">					&quot;%s\n&quot;, i, i, strerror(-err));</a>
<a name="ln4494">			return FALSE;</a>
<a name="ln4495">		}</a>
<a name="ln4496">	}</a>
<a name="ln4497">	/* create systemfiles for ntfs volumes (3.1) */</a>
<a name="ln4498">	/* starting with file 24 (ignoring file 16-23) */</a>
<a name="ln4499">	extend_flags = FILE_ATTR_HIDDEN | FILE_ATTR_SYSTEM |</a>
<a name="ln4500">		FILE_ATTR_ARCHIVE | FILE_ATTR_VIEW_INDEX_PRESENT;</a>
<a name="ln4501">	ntfs_log_verbose(&quot;Creating $Quota (mft record 24)\n&quot;);</a>
<a name="ln4502">	m = (MFT_RECORD*)(g_buf + 24 * g_vol-&gt;mft_record_size);</a>
<a name="ln4503">	m-&gt;flags |= MFT_RECORD_IS_4;</a>
<a name="ln4504">	m-&gt;flags |= MFT_RECORD_IS_VIEW_INDEX;</a>
<a name="ln4505">	if (!err)</a>
<a name="ln4506">		err = create_hardlink_res((MFT_RECORD*)(g_buf +</a>
<a name="ln4507">			11 * g_vol-&gt;mft_record_size), extend_ref, m,</a>
<a name="ln4508">			MK_LE_MREF(24, 1), 0LL, 0LL, extend_flags,</a>
<a name="ln4509">			0, 0, &quot;$Quota&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4510">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4511">	if (!err)</a>
<a name="ln4512">		err = add_attr_index_root(m, &quot;$Q&quot;, 2, CASE_SENSITIVE, AT_UNUSED,</a>
<a name="ln4513">			COLLATION_NTOFS_ULONG, g_vol-&gt;indx_record_size);</a>
<a name="ln4514">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4515">	if (!err)</a>
<a name="ln4516">		err = add_attr_index_root(m, &quot;$O&quot;, 2, CASE_SENSITIVE, AT_UNUSED,</a>
<a name="ln4517">			COLLATION_NTOFS_SID, g_vol-&gt;indx_record_size);</a>
<a name="ln4518">	if (!err)</a>
<a name="ln4519">		err = initialize_quota(m);</a>
<a name="ln4520">	if (err &lt; 0) {</a>
<a name="ln4521">		ntfs_log_error(&quot;Couldn't create $Quota: %s\n&quot;, strerror(-err));</a>
<a name="ln4522">		return FALSE;</a>
<a name="ln4523">	}</a>
<a name="ln4524">	ntfs_log_verbose(&quot;Creating $ObjId (mft record 25)\n&quot;);</a>
<a name="ln4525">	m = (MFT_RECORD*)(g_buf + 25 * g_vol-&gt;mft_record_size);</a>
<a name="ln4526">	m-&gt;flags |= MFT_RECORD_IS_4;</a>
<a name="ln4527">	m-&gt;flags |= MFT_RECORD_IS_VIEW_INDEX;</a>
<a name="ln4528">	if (!err)</a>
<a name="ln4529">		err = create_hardlink_res((MFT_RECORD*)(g_buf +</a>
<a name="ln4530">				11 * g_vol-&gt;mft_record_size), extend_ref,</a>
<a name="ln4531">				m, MK_LE_MREF(25, 1), 0LL, 0LL,</a>
<a name="ln4532">				extend_flags, 0, 0, &quot;$ObjId&quot;,</a>
<a name="ln4533">				FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4534"> </a>
<a name="ln4535">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4536">	if (!err)</a>
<a name="ln4537">		err = add_attr_index_root(m, &quot;$O&quot;, 2, CASE_SENSITIVE, AT_UNUSED,</a>
<a name="ln4538">			COLLATION_NTOFS_ULONGS,</a>
<a name="ln4539">			g_vol-&gt;indx_record_size);</a>
<a name="ln4540">	if (!err &amp;&amp; opts.with_uuid)</a>
<a name="ln4541">		err = index_obj_id_insert(m, &amp;vol_guid,</a>
<a name="ln4542">				MK_LE_MREF(FILE_Volume, FILE_Volume));</a>
<a name="ln4543">	if (err &lt; 0) {</a>
<a name="ln4544">		ntfs_log_error(&quot;Couldn't create $ObjId: %s\n&quot;,</a>
<a name="ln4545">				strerror(-err));</a>
<a name="ln4546">		return FALSE;</a>
<a name="ln4547">	}</a>
<a name="ln4548">	ntfs_log_verbose(&quot;Creating $Reparse (mft record 26)\n&quot;);</a>
<a name="ln4549">	m = (MFT_RECORD*)(g_buf + 26 * g_vol-&gt;mft_record_size);</a>
<a name="ln4550">	m-&gt;flags |= MFT_RECORD_IS_4;</a>
<a name="ln4551">	m-&gt;flags |= MFT_RECORD_IS_VIEW_INDEX;</a>
<a name="ln4552">	if (!err)</a>
<a name="ln4553">		err = create_hardlink_res((MFT_RECORD*)(g_buf +</a>
<a name="ln4554">				11 * g_vol-&gt;mft_record_size),</a>
<a name="ln4555">				extend_ref, m, MK_LE_MREF(26, 1),</a>
<a name="ln4556">				0LL, 0LL, extend_flags, 0, 0,</a>
<a name="ln4557">				&quot;$Reparse&quot;, FILE_NAME_WIN32_AND_DOS);</a>
<a name="ln4558">	/* FIXME: This should be IGNORE_CASE */</a>
<a name="ln4559">	if (!err)</a>
<a name="ln4560">		err = add_attr_index_root(m, &quot;$R&quot;, 2, CASE_SENSITIVE, AT_UNUSED,</a>
<a name="ln4561">			COLLATION_NTOFS_ULONGS, g_vol-&gt;indx_record_size);</a>
<a name="ln4562">	if (err &lt; 0) {</a>
<a name="ln4563">		ntfs_log_error(&quot;Couldn't create $Reparse: %s\n&quot;,</a>
<a name="ln4564">			strerror(-err));</a>
<a name="ln4565">		return FALSE;</a>
<a name="ln4566">	}</a>
<a name="ln4567">	return TRUE;</a>
<a name="ln4568">}</a>
<a name="ln4569"> </a>
<a name="ln4570">/**</a>
<a name="ln4571"> * mkntfs_redirect</a>
<a name="ln4572"> */</a>
<a name="ln4573">static int mkntfs_redirect(struct mkntfs_options *opts2)</a>
<a name="ln4574">{</a>
<a name="ln4575">	int result = 1;</a>
<a name="ln4576">	ntfs_attr_search_ctx *ctx = NULL;</a>
<a name="ln4577">	long long lw, pos;</a>
<a name="ln4578">	ATTR_RECORD *a;</a>
<a name="ln4579">	MFT_RECORD *m;</a>
<a name="ln4580">	int i, err;</a>
<a name="ln4581"> </a>
<a name="ln4582">	if (!opts2) {</a>
<a name="ln4583">		ntfs_log_error(&quot;Internal error: invalid parameters to mkntfs_options.\n&quot;);</a>
<a name="ln4584">		goto done;</a>
<a name="ln4585">	}</a>
<a name="ln4586">	/* Initialize the random number generator with the current time. */</a>
<a name="ln4587">	srandom(le64_to_cpu(mkntfs_time())/10000000);</a>
<a name="ln4588">	/* Allocate and initialize ntfs_volume structure g_vol. */</a>
<a name="ln4589">	g_vol = ntfs_volume_alloc();</a>
<a name="ln4590">	if (!g_vol) {</a>
<a name="ln4591">		ntfs_log_perror(&quot;Could not create volume&quot;);</a>
<a name="ln4592">		goto done;</a>
<a name="ln4593">	}</a>
<a name="ln4594">	/* Create NTFS 3.1 (Windows XP/Vista) volumes. */</a>
<a name="ln4595">	g_vol-&gt;major_ver = 3;</a>
<a name="ln4596">	g_vol-&gt;minor_ver = 1;</a>
<a name="ln4597">	/* Transfer some options to the volume. */</a>
<a name="ln4598">	if (opts.label) {</a>
<a name="ln4599">		g_vol-&gt;vol_name = strdup(opts.label);</a>
<a name="ln4600">		if (!g_vol-&gt;vol_name) {</a>
<a name="ln4601">			ntfs_log_perror(&quot;Could not copy volume name&quot;);</a>
<a name="ln4602">			goto done;</a>
<a name="ln4603">		}</a>
<a name="ln4604">	}</a>
<a name="ln4605">	if (opts.cluster_size &gt;= 0)</a>
<a name="ln4606">		g_vol-&gt;cluster_size = opts.cluster_size;</a>
<a name="ln4607">	/* Length is in unicode characters. */</a>
<a name="ln4608">	g_vol-&gt;upcase_len = 65536;</a>
<a name="ln4609">	g_vol-&gt;upcase = ntfs_malloc(g_vol-&gt;upcase_len * sizeof(ntfschar));</a>
<a name="ln4610">	if (!g_vol-&gt;upcase)</a>
<a name="ln4611">		goto done;</a>
<a name="ln4612">	ntfs_upcase_table_build(g_vol-&gt;upcase,</a>
<a name="ln4613">			g_vol-&gt;upcase_len * sizeof(ntfschar));</a>
<a name="ln4614">	g_vol-&gt;attrdef = ntfs_malloc(sizeof(attrdef_ntfs3x_array));</a>
<a name="ln4615">	if (!g_vol-&gt;attrdef) {</a>
<a name="ln4616">		ntfs_log_perror(&quot;Could not create attrdef structure&quot;);</a>
<a name="ln4617">		goto done;</a>
<a name="ln4618">	}</a>
<a name="ln4619">	memcpy(g_vol-&gt;attrdef, attrdef_ntfs3x_array,</a>
<a name="ln4620">			sizeof(attrdef_ntfs3x_array));</a>
<a name="ln4621">	g_vol-&gt;attrdef_len = sizeof(attrdef_ntfs3x_array);</a>
<a name="ln4622">	/* Open the partition. */</a>
<a name="ln4623">	if (!mkntfs_open_partition(g_vol))</a>
<a name="ln4624">		goto done;</a>
<a name="ln4625">	/*</a>
<a name="ln4626">	 * Decide on the sector size, cluster size, mft record and index record</a>
<a name="ln4627">	 * sizes as well as the number of sectors/tracks/heads/size, etc.</a>
<a name="ln4628">	 */</a>
<a name="ln4629">	if (!mkntfs_override_vol_params(g_vol))</a>
<a name="ln4630">		goto done;</a>
<a name="ln4631">	/* Initialize $Bitmap and $MFT/$BITMAP related stuff. */</a>
<a name="ln4632">	if (!mkntfs_initialize_bitmaps())</a>
<a name="ln4633">		goto done;</a>
<a name="ln4634">	/* Initialize MFT &amp; set g_logfile_lcn. */</a>
<a name="ln4635">	if (!mkntfs_initialize_rl_mft())</a>
<a name="ln4636">		goto done;</a>
<a name="ln4637">	/* Initialize $LogFile. */</a>
<a name="ln4638">	if (!mkntfs_initialize_rl_logfile())</a>
<a name="ln4639">		goto done;</a>
<a name="ln4640">	/* Initialize $Boot. */</a>
<a name="ln4641">	if (!mkntfs_initialize_rl_boot())</a>
<a name="ln4642">		goto done;</a>
<a name="ln4643">	/* Allocate a buffer large enough to hold the mft. */</a>
<a name="ln4644">	g_buf = ntfs_calloc(g_mft_size);</a>
<a name="ln4645">	if (!g_buf)</a>
<a name="ln4646">		goto done;</a>
<a name="ln4647">	/* Create runlist for $BadClus, $DATA named stream $Bad. */</a>
<a name="ln4648">	if (!mkntfs_initialize_rl_bad())</a>
<a name="ln4649">		goto done;</a>
<a name="ln4650">	/* If not quick format, fill the device with 0s. */</a>
<a name="ln4651">	if (!opts.quick_format) {</a>
<a name="ln4652">		if (!mkntfs_fill_device_with_zeroes())</a>
<a name="ln4653">			goto done;</a>
<a name="ln4654">	}</a>
<a name="ln4655">	/* Create NTFS volume structures. */</a>
<a name="ln4656">	if (!mkntfs_create_root_structures())</a>
<a name="ln4657">		goto done;</a>
<a name="ln4658">	/*</a>
<a name="ln4659">	 * - Do not step onto bad blocks!!!</a>
<a name="ln4660">	 * - If any bad blocks were specified or found, modify $BadClus,</a>
<a name="ln4661">	 *   allocating the bad clusters in $Bitmap.</a>
<a name="ln4662">	 * - C&amp;w bootsector backup bootsector (backup in last sector of the</a>
<a name="ln4663">	 *   partition).</a>
<a name="ln4664">	 * - If NTFS 3.0+, c&amp;w $Secure file and $Extend directory with the</a>
<a name="ln4665">	 *   corresponding special files in it, i.e. $ObjId, $Quota, $Reparse,</a>
<a name="ln4666">	 *   and $UsnJrnl. And others? Or not all necessary?</a>
<a name="ln4667">	 * - RE: Populate $root with the system files (and $Extend directory if</a>
<a name="ln4668">	 *   applicable). Possibly should move this as far to the top as</a>
<a name="ln4669">	 *   possible and update during each subsequent c&amp;w of each system file.</a>
<a name="ln4670">	 */</a>
<a name="ln4671">	ntfs_log_verbose(&quot;Syncing root directory index record.\n&quot;);</a>
<a name="ln4672">	if (!mkntfs_sync_index_record(g_index_block, (MFT_RECORD*)(g_buf + 5 *</a>
<a name="ln4673">			g_vol-&gt;mft_record_size), NTFS_INDEX_I30, 4))</a>
<a name="ln4674">		goto done;</a>
<a name="ln4675"> </a>
<a name="ln4676">	ntfs_log_verbose(&quot;Syncing $Bitmap.\n&quot;);</a>
<a name="ln4677">	m = (MFT_RECORD*)(g_buf + 6 * g_vol-&gt;mft_record_size);</a>
<a name="ln4678"> </a>
<a name="ln4679">	ctx = ntfs_attr_get_search_ctx(NULL, m);</a>
<a name="ln4680">	if (!ctx) {</a>
<a name="ln4681">		ntfs_log_perror(&quot;Could not create an attribute search context&quot;);</a>
<a name="ln4682">		goto done;</a>
<a name="ln4683">	}</a>
<a name="ln4684"> </a>
<a name="ln4685">	if (mkntfs_attr_lookup(AT_DATA, AT_UNNAMED, 0, CASE_SENSITIVE,</a>
<a name="ln4686">				0, NULL, 0, ctx)) {</a>
<a name="ln4687">		ntfs_log_error(&quot;BUG: $DATA attribute not found.\n&quot;);</a>
<a name="ln4688">		goto done;</a>
<a name="ln4689">	}</a>
<a name="ln4690"> </a>
<a name="ln4691">	a = ctx-&gt;attr;</a>
<a name="ln4692">	if (a-&gt;non_resident) {</a>
<a name="ln4693">		runlist *rl = ntfs_mapping_pairs_decompress(g_vol, a, NULL);</a>
<a name="ln4694">		if (!rl) {</a>
<a name="ln4695">			ntfs_log_error(&quot;ntfs_mapping_pairs_decompress() failed\n&quot;);</a>
<a name="ln4696">			goto done;</a>
<a name="ln4697">		}</a>
<a name="ln4698">		lw = ntfs_rlwrite(g_vol-&gt;dev, rl, (const u8*)NULL,</a>
<a name="ln4699">			 g_lcn_bitmap_byte_size, NULL, WRITE_BITMAP);</a>
<a name="ln4700">		err = errno;</a>
<a name="ln4701">		free(rl);</a>
<a name="ln4702">		if (lw != g_lcn_bitmap_byte_size) {</a>
<a name="ln4703">			ntfs_log_error(&quot;ntfs_rlwrite: %s\n&quot;, lw == -1 ?</a>
<a name="ln4704">				       strerror(err) : &quot;unknown error&quot;);</a>
<a name="ln4705">			goto done;</a>
<a name="ln4706">		}</a>
<a name="ln4707">	} else {</a>
<a name="ln4708">		/* Error : the bitmap must be created non resident */</a>
<a name="ln4709">		ntfs_log_error(&quot;Error : the global bitmap is resident\n&quot;);</a>
<a name="ln4710">		goto done;</a>
<a name="ln4711">	}</a>
<a name="ln4712"> </a>
<a name="ln4713">	/*</a>
<a name="ln4714">	 * No need to sync $MFT/$BITMAP as that has never been modified since</a>
<a name="ln4715">	 * its creation.</a>
<a name="ln4716">	 */</a>
<a name="ln4717">	ntfs_log_verbose(&quot;Syncing $MFT.\n&quot;);</a>
<a name="ln4718">	pos = g_mft_lcn * g_vol-&gt;cluster_size;</a>
<a name="ln4719">	lw = 1;</a>
<a name="ln4720">	for (i = 0; i &lt; g_mft_size / (s32)g_vol-&gt;mft_record_size; i++) {</a>
<a name="ln4721">		if (!opts.no_action)</a>
<a name="ln4722">			lw = ntfs_mst_pwrite(g_vol-&gt;dev, pos, 1, g_vol-&gt;mft_record_size, g_buf + i * g_vol-&gt;mft_record_size);</a>
<a name="ln4723">		if (lw != 1) {</a>
<a name="ln4724">			ntfs_log_error(&quot;ntfs_mst_pwrite: %s\n&quot;, lw == -1 ?</a>
<a name="ln4725">				       strerror(errno) : &quot;unknown error&quot;);</a>
<a name="ln4726">			goto done;</a>
<a name="ln4727">		}</a>
<a name="ln4728">		pos += g_vol-&gt;mft_record_size;</a>
<a name="ln4729">	}</a>
<a name="ln4730">	ntfs_log_verbose(&quot;Updating $MFTMirr.\n&quot;);</a>
<a name="ln4731">	pos = g_mftmirr_lcn * g_vol-&gt;cluster_size;</a>
<a name="ln4732">	lw = 1;</a>
<a name="ln4733">	for (i = 0; i &lt; g_rl_mftmirr[0].length * g_vol-&gt;cluster_size / g_vol-&gt;mft_record_size; i++) {</a>
<a name="ln4734">		m = (MFT_RECORD*)(g_buf + i * g_vol-&gt;mft_record_size);</a>
<a name="ln4735">		/*</a>
<a name="ln4736">		 * Decrement the usn by one, so it becomes the same as the one</a>
<a name="ln4737">		 * in $MFT once it is mst protected. - This is as we need the</a>
<a name="ln4738">		 * $MFTMirr to have the exact same byte by byte content as</a>
<a name="ln4739">		 * $MFT, rather than just equivalent meaning content.</a>
<a name="ln4740">		 */</a>
<a name="ln4741">		if (ntfs_mft_usn_dec(m)) {</a>
<a name="ln4742">			ntfs_log_error(&quot;ntfs_mft_usn_dec&quot;);</a>
<a name="ln4743">			goto done;</a>
<a name="ln4744">		}</a>
<a name="ln4745">		if (!opts.no_action)</a>
<a name="ln4746">			lw = ntfs_mst_pwrite(g_vol-&gt;dev, pos, 1, g_vol-&gt;mft_record_size, g_buf + i * g_vol-&gt;mft_record_size);</a>
<a name="ln4747">		if (lw != 1) {</a>
<a name="ln4748">			ntfs_log_error(&quot;ntfs_mst_pwrite: %s\n&quot;, lw == -1 ?</a>
<a name="ln4749">				       strerror(errno) : &quot;unknown error&quot;);</a>
<a name="ln4750">			goto done;</a>
<a name="ln4751">		}</a>
<a name="ln4752">		pos += g_vol-&gt;mft_record_size;</a>
<a name="ln4753">	}</a>
<a name="ln4754">	ntfs_log_verbose(&quot;Syncing device.\n&quot;);</a>
<a name="ln4755">	if (g_vol-&gt;dev-&gt;d_ops-&gt;sync(g_vol-&gt;dev)) {</a>
<a name="ln4756">		ntfs_log_error(&quot;Syncing device. FAILED&quot;);</a>
<a name="ln4757">		goto done;</a>
<a name="ln4758">	}</a>
<a name="ln4759">	ntfs_log_quiet(&quot;mkntfs completed successfully. Have a nice day.\n&quot;);</a>
<a name="ln4760">	result = 0;</a>
<a name="ln4761">done:</a>
<a name="ln4762">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln4763">	mkntfs_cleanup();	/* Device is unlocked and closed here */</a>
<a name="ln4764">	return result;</a>
<a name="ln4765">}</a>
<a name="ln4766"> </a>
<a name="ln4767">/**</a>
<a name="ln4768"> * mkntfs_main</a>
<a name="ln4769"> */</a>
<a name="ln4770">int	mkntfs_main(const char *devpath, const char *label)</a>
<a name="ln4771">{	</a>
<a name="ln4772">	//reset global variables</a>
<a name="ln4773">	g_buf = NULL;</a>
<a name="ln4774">	g_mft_bitmap_byte_size = 0;</a>
<a name="ln4775">	g_mft_bitmap = NULL;</a>
<a name="ln4776">	g_lcn_bitmap_byte_size = 0;</a>
<a name="ln4777">	g_dynamic_buf_size = 0;</a>
<a name="ln4778">	g_dynamic_buf = NULL;</a>
<a name="ln4779">	g_rl_mft = NULL;</a>
<a name="ln4780">	g_rl_mft_bmp = NULL;</a>
<a name="ln4781">	g_rl_mftmirr = NULL;</a>
<a name="ln4782">	g_rl_logfile = NULL;</a>
<a name="ln4783">	g_rl_boot = NULL;</a>
<a name="ln4784">	g_rl_bad = NULL;</a>
<a name="ln4785">	g_index_block = NULL;</a>
<a name="ln4786">	g_vol = NULL;</a>
<a name="ln4787">	g_mft_size = 0;</a>
<a name="ln4788">	g_mft_lcn = 0;</a>
<a name="ln4789">	g_mftmirr_lcn = 0;</a>
<a name="ln4790">	g_logfile_lcn = 0;</a>
<a name="ln4791">	g_logfile_size = 0;</a>
<a name="ln4792">	g_mft_zone_end = 0;	</a>
<a name="ln4793">	g_num_bad_blocks = 0;</a>
<a name="ln4794">	g_bad_blocks = NULL;</a>
<a name="ln4795">	g_allocation = NULL;</a>
<a name="ln4796">	</a>
<a name="ln4797">	//init default options</a>
<a name="ln4798">	mkntfs_init_options(&amp;opts);	</a>
<a name="ln4799"> </a>
<a name="ln4800">	opts.dev_name = devpath;</a>
<a name="ln4801">	opts.label = label;</a>
<a name="ln4802"> </a>
<a name="ln4803">	opts.force = TRUE;</a>
<a name="ln4804">	opts.quick_format = TRUE;</a>
<a name="ln4805"> </a>
<a name="ln4806">	return mkntfs_redirect(&amp;opts);</a>
<a name="ln4807">}</a>
<a name="ln4808"> </a>

</code></pre>
<div class="balloon" rel="2988"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'i < 0' is always false.</p></div>
<div class="balloon" rel="4291"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v774/" target="_blank">V774</a> The 'bs' pointer was used after the memory was released.</p></div>
<div class="balloon" rel="3917"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'm' is always rewritten in function body before being used.</p></div>
<div class="balloon" rel="4259"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to overflow of the buffer 'bs'.</p></div>
<div class="balloon" rel="4308"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v774/" target="_blank">V774</a> The 'bs' pointer was used after the memory was released.</p></div>
<div class="balloon" rel="1334"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="1132"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
