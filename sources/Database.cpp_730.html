
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Database.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2014, Haiku.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Tyler Dauwalder</a>
<a name="ln7"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln8"> *		Rene Gollent, rene@gollent.com.</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;mime/Database.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;stdio.h&gt;</a>
<a name="ln15">#include &lt;string&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;iostream&gt;</a>
<a name="ln18">#include &lt;new&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;Application.h&gt;</a>
<a name="ln21">#include &lt;Bitmap.h&gt;</a>
<a name="ln22">#include &lt;DataIO.h&gt;</a>
<a name="ln23">#include &lt;Directory.h&gt;</a>
<a name="ln24">#include &lt;Entry.h&gt;</a>
<a name="ln25">#include &lt;fs_attr.h&gt;</a>
<a name="ln26">#include &lt;Message.h&gt;</a>
<a name="ln27">#include &lt;MimeType.h&gt;</a>
<a name="ln28">#include &lt;Node.h&gt;</a>
<a name="ln29">#include &lt;Path.h&gt;</a>
<a name="ln30">#include &lt;String.h&gt;</a>
<a name="ln31">#include &lt;TypeConstants.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;AutoLocker.h&gt;</a>
<a name="ln34">#include &lt;mime/database_support.h&gt;</a>
<a name="ln35">#include &lt;mime/DatabaseLocation.h&gt;</a>
<a name="ln36">#include &lt;storage_support.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">//#define DBG(x) x</a>
<a name="ln40">#define DBG(x)</a>
<a name="ln41">#define OUT printf</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">namespace BPrivate {</a>
<a name="ln45">namespace Storage {</a>
<a name="ln46">namespace Mime {</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">Database::NotificationListener::~NotificationListener()</a>
<a name="ln50">{</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">/*!</a>
<a name="ln55">	\class Database</a>
<a name="ln56">	\brief Mime::Database is the master of the MIME data base.</a>
<a name="ln57"> </a>
<a name="ln58">	All write and non-atomic read accesses are carried out by this class.</a>
<a name="ln59"> </a>
<a name="ln60">	\note No error checking (other than checks for NULL pointers) is performed</a>
<a name="ln61">	      by this class on the mime type strings passed to it. It's assumed</a>
<a name="ln62">	      that this sort of checking has been done beforehand.</a>
<a name="ln63">*/</a>
<a name="ln64"> </a>
<a name="ln65">// constructor</a>
<a name="ln66">/*!	\brief Creates and initializes a Mime::Database object.</a>
<a name="ln67">*/</a>
<a name="ln68">Database::Database(DatabaseLocation* databaseLocation, MimeSniffer* mimeSniffer,</a>
<a name="ln69">	NotificationListener* notificationListener)</a>
<a name="ln70">	:</a>
<a name="ln71">	fStatus(B_NO_INIT),</a>
<a name="ln72">	fLocation(databaseLocation),</a>
<a name="ln73">	fNotificationListener(notificationListener),</a>
<a name="ln74">	fAssociatedTypes(databaseLocation, mimeSniffer),</a>
<a name="ln75">	fInstalledTypes(databaseLocation),</a>
<a name="ln76">	fSnifferRules(databaseLocation, mimeSniffer),</a>
<a name="ln77">	fSupportingApps(databaseLocation),</a>
<a name="ln78">	fDeferredInstallNotificationsLocker(&quot;deferred install notifications&quot;),</a>
<a name="ln79">	fDeferredInstallNotifications()</a>
<a name="ln80">{</a>
<a name="ln81">	// make sure the user's MIME DB directory exists</a>
<a name="ln82">	fStatus = create_directory(fLocation-&gt;WritableDirectory(),</a>
<a name="ln83">		S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">// destructor</a>
<a name="ln87">/*!	\brief Frees all resources associated with this object.</a>
<a name="ln88">*/</a>
<a name="ln89">Database::~Database()</a>
<a name="ln90">{</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">// InitCheck</a>
<a name="ln94">/*! \brief Returns the initialization status of the object.</a>
<a name="ln95">	\return</a>
<a name="ln96">	- B_OK: success</a>
<a name="ln97">	- &quot;error code&quot;: failure</a>
<a name="ln98">*/</a>
<a name="ln99">status_t</a>
<a name="ln100">Database::InitCheck() const</a>
<a name="ln101">{</a>
<a name="ln102">	return fStatus;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">// Install</a>
<a name="ln106">/*!	\brief Installs the given type in the database</a>
<a name="ln107">	\note The R5 version of this call returned an unreliable result if the</a>
<a name="ln108">	      MIME type was already installed. Ours simply returns B_OK.</a>
<a name="ln109">	\param type Pointer to a NULL-terminated string containing the MIME type of interest</a>
<a name="ln110">	\param decsription Pointer to a NULL-terminated string containing the new long description</a>
<a name="ln111">	\return</a>
<a name="ln112">	- B_OK: success</a>
<a name="ln113">	- B_FILE_EXISTS: the type is already installed</a>
<a name="ln114">	- &quot;error code&quot;: failure</a>
<a name="ln115">*/</a>
<a name="ln116">status_t</a>
<a name="ln117">Database::Install(const char *type)</a>
<a name="ln118">{</a>
<a name="ln119">	if (type == NULL)</a>
<a name="ln120">		return B_BAD_VALUE;</a>
<a name="ln121"> </a>
<a name="ln122">	BEntry entry;</a>
<a name="ln123">	status_t err = entry.SetTo(fLocation-&gt;WritablePathForType(type));</a>
<a name="ln124">	if (err == B_OK || err == B_ENTRY_NOT_FOUND) {</a>
<a name="ln125">		if (entry.Exists())</a>
<a name="ln126">			err = B_FILE_EXISTS;</a>
<a name="ln127">		else {</a>
<a name="ln128">			bool didCreate = false;</a>
<a name="ln129">			BNode node;</a>
<a name="ln130">			err = fLocation-&gt;OpenWritableType(type, node, true, &amp;didCreate);</a>
<a name="ln131">			if (!err &amp;&amp; didCreate) {</a>
<a name="ln132">				fInstalledTypes.AddType(type);</a>
<a name="ln133">				_SendInstallNotification(type);</a>
<a name="ln134">			}</a>
<a name="ln135">		}</a>
<a name="ln136">	}</a>
<a name="ln137">	return err;</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">// Delete</a>
<a name="ln141">/*!	\brief Removes the given type from the database</a>
<a name="ln142">	\param type Pointer to a NULL-terminated string containing the MIME type of interest</a>
<a name="ln143">	\return</a>
<a name="ln144">	- B_OK: success</a>
<a name="ln145">	- &quot;error code&quot;: failure</a>
<a name="ln146">*/</a>
<a name="ln147">status_t</a>
<a name="ln148">Database::Delete(const char *type)</a>
<a name="ln149">{</a>
<a name="ln150">	if (type == NULL)</a>
<a name="ln151">		return B_BAD_VALUE;</a>
<a name="ln152"> </a>
<a name="ln153">	// Open the type</a>
<a name="ln154">	BEntry entry;</a>
<a name="ln155">	status_t status = entry.SetTo(fLocation-&gt;WritablePathForType(type));</a>
<a name="ln156">	if (status != B_OK)</a>
<a name="ln157">		return status;</a>
<a name="ln158"> </a>
<a name="ln159">	// Remove it</a>
<a name="ln160">	if (entry.IsDirectory()) {</a>
<a name="ln161">		// We need to remove all files in this directory</a>
<a name="ln162">		BDirectory directory(&amp;entry);</a>
<a name="ln163">		if (directory.InitCheck() == B_OK) {</a>
<a name="ln164">			size_t length = strlen(type);</a>
<a name="ln165">			char subType[B_PATH_NAME_LENGTH];</a>
<a name="ln166">			memcpy(subType, type, length);</a>
<a name="ln167">			subType[length++] = '/';</a>
<a name="ln168"> </a>
<a name="ln169">			BEntry subEntry;</a>
<a name="ln170">			while (directory.GetNextEntry(&amp;subEntry) == B_OK) {</a>
<a name="ln171">				// Construct MIME type and remove it</a>
<a name="ln172">				if (subEntry.GetName(subType + length) == B_OK) {</a>
<a name="ln173">					status = Delete(subType);</a>
<a name="ln174">					if (status != B_OK)</a>
<a name="ln175">						return status;</a>
<a name="ln176">				}</a>
<a name="ln177">			}</a>
<a name="ln178">		}</a>
<a name="ln179">	}</a>
<a name="ln180"> </a>
<a name="ln181">	status = entry.Remove();</a>
<a name="ln182"> </a>
<a name="ln183">	if (status == B_OK) {</a>
<a name="ln184">		// Notify the installed types database</a>
<a name="ln185">		fInstalledTypes.RemoveType(type);</a>
<a name="ln186">		// Notify the supporting apps database</a>
<a name="ln187">		fSupportingApps.DeleteSupportedTypes(type, true);</a>
<a name="ln188">		// Notify the monitor service</a>
<a name="ln189">		_SendDeleteNotification(type);</a>
<a name="ln190">	}</a>
<a name="ln191"> </a>
<a name="ln192">	return status;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196">status_t</a>
<a name="ln197">Database::_SetStringValue(const char *type, int32 what, const char* attribute,</a>
<a name="ln198">	type_code attributeType, size_t maxLength, const char *value)</a>
<a name="ln199">{</a>
<a name="ln200">	size_t length = value != NULL ? strlen(value) : 0;</a>
<a name="ln201">	if (type == NULL || value == NULL || length &gt;= maxLength)</a>
<a name="ln202">		return B_BAD_VALUE;</a>
<a name="ln203"> </a>
<a name="ln204">	char oldValue[maxLength];</a>
<a name="ln205">	status_t status = fLocation-&gt;ReadAttribute(type, attribute, oldValue,</a>
<a name="ln206">		maxLength, attributeType);</a>
<a name="ln207">	if (status &gt;= B_OK &amp;&amp; !strcmp(value, oldValue)) {</a>
<a name="ln208">		// nothing has changed, no need to write back the data</a>
<a name="ln209">		return B_OK;</a>
<a name="ln210">	}</a>
<a name="ln211"> </a>
<a name="ln212">	bool didCreate = false;</a>
<a name="ln213">	status = fLocation-&gt;WriteAttribute(type, attribute, value, length + 1,</a>
<a name="ln214">		attributeType, &amp;didCreate);</a>
<a name="ln215"> </a>
<a name="ln216">	if (status == B_OK) {</a>
<a name="ln217">		if (didCreate)</a>
<a name="ln218">			_SendInstallNotification(type);</a>
<a name="ln219">		else</a>
<a name="ln220">			_SendMonitorUpdate(what, type, B_META_MIME_MODIFIED);</a>
<a name="ln221">	}</a>
<a name="ln222"> </a>
<a name="ln223">	return status;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226"> </a>
<a name="ln227">// SetAppHint</a>
<a name="ln228">/*!	\brief Sets the application hint for the given MIME type</a>
<a name="ln229">	\param type Pointer to a NULL-terminated string containing the MIME type of interest</a>
<a name="ln230">	\param decsription Pointer to an entry_ref containing the location of an application</a>
<a name="ln231">	       that should be used when launching an application with this signature.</a>
<a name="ln232">*/</a>
<a name="ln233">status_t</a>
<a name="ln234">Database::SetAppHint(const char *type, const entry_ref *ref)</a>
<a name="ln235">{</a>
<a name="ln236">	DBG(OUT(&quot;Database::SetAppHint()\n&quot;));</a>
<a name="ln237"> </a>
<a name="ln238">	if (type == NULL || ref == NULL)</a>
<a name="ln239">		return B_BAD_VALUE;</a>
<a name="ln240"> </a>
<a name="ln241">	BPath path;</a>
<a name="ln242">	status_t status = path.SetTo(ref);</a>
<a name="ln243">	if (status &lt; B_OK)</a>
<a name="ln244">		return status;</a>
<a name="ln245"> </a>
<a name="ln246">	return _SetStringValue(type, B_APP_HINT_CHANGED, kAppHintAttr,</a>
<a name="ln247">		kAppHintType, B_PATH_NAME_LENGTH, path.Path());</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">// SetAttrInfo</a>
<a name="ln251">/*! \brief Stores a BMessage describing the format of attributes typically associated with</a>
<a name="ln252">	files of the given MIME type</a>
<a name="ln253"> </a>
<a name="ln254">	See BMimeType::SetAttrInfo() for description of the expected message format.</a>
<a name="ln255"> </a>
<a name="ln256">	The \c BMessage::what value is ignored.</a>
<a name="ln257"> </a>
<a name="ln258">	\param info Pointer to a pre-allocated and properly formatted BMessage containing</a>
<a name="ln259">	            information about the file attributes typically associated with the</a>
<a name="ln260">	            MIME type.</a>
<a name="ln261">	\return</a>
<a name="ln262">	- \c B_OK: Success</a>
<a name="ln263">	- &quot;error code&quot;: Failure</a>
<a name="ln264">*/</a>
<a name="ln265">status_t</a>
<a name="ln266">Database::SetAttrInfo(const char *type, const BMessage *info)</a>
<a name="ln267">{</a>
<a name="ln268">	DBG(OUT(&quot;Database::SetAttrInfo()\n&quot;));</a>
<a name="ln269"> </a>
<a name="ln270">	if (type == NULL || info == NULL)</a>
<a name="ln271">		return B_BAD_VALUE;</a>
<a name="ln272"> </a>
<a name="ln273">	bool didCreate = false;</a>
<a name="ln274">	status_t status = fLocation-&gt;WriteMessageAttribute(type, kAttrInfoAttr,</a>
<a name="ln275">		*info, &amp;didCreate);</a>
<a name="ln276">	if (status == B_OK) {</a>
<a name="ln277">		if (didCreate)</a>
<a name="ln278">			_SendInstallNotification(type);</a>
<a name="ln279">		else</a>
<a name="ln280">			_SendMonitorUpdate(B_ATTR_INFO_CHANGED, type, B_META_MIME_MODIFIED);</a>
<a name="ln281">	}</a>
<a name="ln282"> </a>
<a name="ln283">	return status;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">// SetShortDescription</a>
<a name="ln288">/*!	\brief Sets the short description for the given MIME type</a>
<a name="ln289">	\param type Pointer to a NULL-terminated string containing the MIME type of interest</a>
<a name="ln290">	\param decsription Pointer to a NULL-terminated string containing the new short description</a>
<a name="ln291">*/</a>
<a name="ln292">status_t</a>
<a name="ln293">Database::SetShortDescription(const char *type, const char *description)</a>
<a name="ln294">{</a>
<a name="ln295">	DBG(OUT(&quot;Database::SetShortDescription()\n&quot;));</a>
<a name="ln296"> </a>
<a name="ln297">	return _SetStringValue(type, B_SHORT_DESCRIPTION_CHANGED, kShortDescriptionAttr,</a>
<a name="ln298">		kShortDescriptionType, B_MIME_TYPE_LENGTH, description);</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">// SetLongDescription</a>
<a name="ln302">/*!	\brief Sets the long description for the given MIME type</a>
<a name="ln303">	\param type Pointer to a NULL-terminated string containing the MIME type of interest</a>
<a name="ln304">	\param decsription Pointer to a NULL-terminated string containing the new long description</a>
<a name="ln305">*/</a>
<a name="ln306">status_t</a>
<a name="ln307">Database::SetLongDescription(const char *type, const char *description)</a>
<a name="ln308">{</a>
<a name="ln309">	DBG(OUT(&quot;Database::SetLongDescription()\n&quot;));</a>
<a name="ln310"> </a>
<a name="ln311">	size_t length = description != NULL ? strlen(description) : 0;</a>
<a name="ln312">	if (type == NULL || description == NULL || length &gt;= B_MIME_TYPE_LENGTH)</a>
<a name="ln313">		return B_BAD_VALUE;</a>
<a name="ln314"> </a>
<a name="ln315">	return _SetStringValue(type, B_LONG_DESCRIPTION_CHANGED, kLongDescriptionAttr,</a>
<a name="ln316">		kLongDescriptionType, B_MIME_TYPE_LENGTH, description);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">/*!</a>
<a name="ln321">	\brief Sets the list of filename extensions associated with the MIME type</a>
<a name="ln322"> </a>
<a name="ln323">	The list of extensions is given in a pre-allocated BMessage pointed to by</a>
<a name="ln324">	the \c extensions parameter. Please see BMimeType::SetFileExtensions()</a>
<a name="ln325">	for a description of the expected message format.</a>
<a name="ln326"> </a>
<a name="ln327">	\param extensions Pointer to a pre-allocated, properly formatted BMessage containing</a>
<a name="ln328">	                  the new list of file extensions to associate with this MIME type.</a>
<a name="ln329">	\return</a>
<a name="ln330">	- \c B_OK: Success</a>
<a name="ln331">	- &quot;error code&quot;: Failure</a>
<a name="ln332">*/</a>
<a name="ln333">status_t</a>
<a name="ln334">Database::SetFileExtensions(const char *type, const BMessage *extensions)</a>
<a name="ln335">{</a>
<a name="ln336">	DBG(OUT(&quot;Database::SetFileExtensions()\n&quot;));</a>
<a name="ln337"> </a>
<a name="ln338">	if (type == NULL || extensions == NULL)</a>
<a name="ln339">		return B_BAD_VALUE;</a>
<a name="ln340"> </a>
<a name="ln341">	bool didCreate = false;</a>
<a name="ln342">	status_t status = fLocation-&gt;WriteMessageAttribute(type,</a>
<a name="ln343">		kFileExtensionsAttr, *extensions, &amp;didCreate);</a>
<a name="ln344"> </a>
<a name="ln345">	if (status == B_OK) {</a>
<a name="ln346">		if (didCreate) {</a>
<a name="ln347">			_SendInstallNotification(type);</a>
<a name="ln348">		} else {</a>
<a name="ln349">			_SendMonitorUpdate(B_FILE_EXTENSIONS_CHANGED, type,</a>
<a name="ln350">				B_META_MIME_MODIFIED);</a>
<a name="ln351">		}</a>
<a name="ln352">	}</a>
<a name="ln353"> </a>
<a name="ln354">	return status;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358">/*!</a>
<a name="ln359">	\brief Sets a bitmap icon for the given mime type</a>
<a name="ln360">*/</a>
<a name="ln361">status_t</a>
<a name="ln362">Database::SetIcon(const char* type, const BBitmap* icon, icon_size which)</a>
<a name="ln363">{</a>
<a name="ln364">	if (icon != NULL)</a>
<a name="ln365">		return SetIcon(type, icon-&gt;Bits(), icon-&gt;BitsLength(), which);</a>
<a name="ln366">	return SetIcon(type, NULL, 0, which);</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369"> </a>
<a name="ln370">/*!</a>
<a name="ln371">	\brief Sets a bitmap icon for the given mime type</a>
<a name="ln372">*/</a>
<a name="ln373">status_t</a>
<a name="ln374">Database::SetIcon(const char *type, const void *data, size_t dataSize,</a>
<a name="ln375">	icon_size which)</a>
<a name="ln376">{</a>
<a name="ln377">	return SetIconForType(type, NULL, data, dataSize, which);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">/*!</a>
<a name="ln382">	\brief Sets the vector icon for the given mime type</a>
<a name="ln383">*/</a>
<a name="ln384">status_t</a>
<a name="ln385">Database::SetIcon(const char *type, const void *data, size_t dataSize)</a>
<a name="ln386">{</a>
<a name="ln387">	return SetIconForType(type, NULL, data, dataSize);</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">status_t</a>
<a name="ln392">Database::SetIconForType(const char* type, const char* fileType,</a>
<a name="ln393">	const BBitmap* icon, icon_size which)</a>
<a name="ln394">{</a>
<a name="ln395">	if (icon != NULL) {</a>
<a name="ln396">		return SetIconForType(type, fileType, icon-&gt;Bits(),</a>
<a name="ln397">			(size_t)icon-&gt;BitsLength(), which);</a>
<a name="ln398">	}</a>
<a name="ln399">	return SetIconForType(type, fileType, NULL, 0, which);</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402"> </a>
<a name="ln403">// SetIconForType</a>
<a name="ln404">/*! \brief Sets the large or mini icon used by an application of this type for</a>
<a name="ln405">	files of the given type.</a>
<a name="ln406"> </a>
<a name="ln407">	The type of the \c BMimeType object is not required to actually be a subtype of</a>
<a name="ln408">	\c &quot;application/&quot;; that is the intended use however, and application-specific</a>
<a name="ln409">	icons are not expected to be present for non-application types.</a>
<a name="ln410"> </a>
<a name="ln411">	The bitmap data pointed to by \c data must be of the proper size (\c 32x32</a>
<a name="ln412">	for \c B_LARGE_ICON, \c 16x16 for \c B_MINI_ICON) and the proper color</a>
<a name="ln413">	space (B_CMAP8).</a>
<a name="ln414"> </a>
<a name="ln415">	\param type The MIME type</a>
<a name="ln416">	\param fileType The MIME type whose custom icon you wish to set.</a>
<a name="ln417">	\param data Pointer to an array of bitmap data of proper dimensions and color depth</a>
<a name="ln418">	\param dataSize The length of the array pointed to by \c data</a>
<a name="ln419">	\param size The size icon you're expecting (\c B_LARGE_ICON or \c B_MINI_ICON)</a>
<a name="ln420">	\return</a>
<a name="ln421">	- \c B_OK: Success</a>
<a name="ln422">	- &quot;error code&quot;: Failure</a>
<a name="ln423"> </a>
<a name="ln424">*/</a>
<a name="ln425">status_t</a>
<a name="ln426">Database::SetIconForType(const char *type, const char *fileType,</a>
<a name="ln427">	const void *data, size_t dataSize, icon_size which)</a>
<a name="ln428">{</a>
<a name="ln429">	DBG(OUT(&quot;Database::SetIconForType()\n&quot;));</a>
<a name="ln430"> </a>
<a name="ln431">	if (type == NULL || data == NULL)</a>
<a name="ln432">		return B_BAD_VALUE;</a>
<a name="ln433"> </a>
<a name="ln434">	int32 attrType = 0;</a>
<a name="ln435"> </a>
<a name="ln436">	// Figure out what kind of data we *should* have</a>
<a name="ln437">	switch (which) {</a>
<a name="ln438">		case B_MINI_ICON:</a>
<a name="ln439">			attrType = kMiniIconType;</a>
<a name="ln440">			break;</a>
<a name="ln441">		case B_LARGE_ICON:</a>
<a name="ln442">			attrType = kLargeIconType;</a>
<a name="ln443">			break;</a>
<a name="ln444"> </a>
<a name="ln445">		default:</a>
<a name="ln446">			return B_BAD_VALUE;</a>
<a name="ln447">	}</a>
<a name="ln448"> </a>
<a name="ln449">	size_t attrSize = (size_t)which * (size_t)which;</a>
<a name="ln450">	// Double check the data we've been given</a>
<a name="ln451">	if (dataSize != attrSize)</a>
<a name="ln452">		return B_BAD_VALUE;</a>
<a name="ln453"> </a>
<a name="ln454">	// Construct our attribute name</a>
<a name="ln455">	std::string attr;</a>
<a name="ln456">	if (fileType) {</a>
<a name="ln457">		attr = (which == B_MINI_ICON</a>
<a name="ln458">			? kMiniIconAttrPrefix : kLargeIconAttrPrefix)</a>
<a name="ln459">			+ BPrivate::Storage::to_lower(fileType);</a>
<a name="ln460">	} else</a>
<a name="ln461">		attr = which == B_MINI_ICON ? kMiniIconAttr : kLargeIconAttr;</a>
<a name="ln462"> </a>
<a name="ln463">	// Write the icon data</a>
<a name="ln464">	BNode node;</a>
<a name="ln465">	bool didCreate = false;</a>
<a name="ln466"> </a>
<a name="ln467">	status_t err = fLocation-&gt;OpenWritableType(type, node, true, &amp;didCreate);</a>
<a name="ln468">	if (err != B_OK)</a>
<a name="ln469">		return err;</a>
<a name="ln470"> </a>
<a name="ln471">	if (!err)</a>
<a name="ln472">		err = node.WriteAttr(attr.c_str(), attrType, 0, data, attrSize);</a>
<a name="ln473">	if (err &gt;= 0)</a>
<a name="ln474">		err = err == (ssize_t)attrSize ? (status_t)B_OK : (status_t)B_FILE_ERROR;</a>
<a name="ln475">	if (didCreate) {</a>
<a name="ln476">		_SendInstallNotification(type);</a>
<a name="ln477">	} else if (!err) {</a>
<a name="ln478">		if (fileType) {</a>
<a name="ln479">			_SendMonitorUpdate(B_ICON_FOR_TYPE_CHANGED, type, fileType,</a>
<a name="ln480">				which == B_LARGE_ICON, B_META_MIME_MODIFIED);</a>
<a name="ln481">		} else {</a>
<a name="ln482">			_SendMonitorUpdate(B_ICON_CHANGED, type,</a>
<a name="ln483">				which == B_LARGE_ICON, B_META_MIME_MODIFIED);</a>
<a name="ln484">		}</a>
<a name="ln485">	}</a>
<a name="ln486">	return err;</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">// SetIconForType</a>
<a name="ln490">/*! \brief Sets the vector icon used by an application of this type for</a>
<a name="ln491">	files of the given type.</a>
<a name="ln492"> </a>
<a name="ln493">	The type of the \c BMimeType object is not required to actually be a subtype of</a>
<a name="ln494">	\c &quot;application/&quot;; that is the intended use however, and application-specific</a>
<a name="ln495">	icons are not expected to be present for non-application types.</a>
<a name="ln496"> </a>
<a name="ln497">	\param type The MIME type</a>
<a name="ln498">	\param fileType The MIME type whose custom icon you wish to set.</a>
<a name="ln499">	\param data Pointer to an array of vector data</a>
<a name="ln500">	\param dataSize The length of the array pointed to by \c data</a>
<a name="ln501">	\return</a>
<a name="ln502">	- \c B_OK: Success</a>
<a name="ln503">	- &quot;error code&quot;: Failure</a>
<a name="ln504"> </a>
<a name="ln505">*/</a>
<a name="ln506">status_t</a>
<a name="ln507">Database::SetIconForType(const char *type, const char *fileType,</a>
<a name="ln508">	const void *data, size_t dataSize)</a>
<a name="ln509">{</a>
<a name="ln510">	DBG(OUT(&quot;Database::SetIconForType()\n&quot;));</a>
<a name="ln511"> </a>
<a name="ln512">	if (type == NULL || data == NULL)</a>
<a name="ln513">		return B_BAD_VALUE;</a>
<a name="ln514"> </a>
<a name="ln515">	int32 attrType = B_VECTOR_ICON_TYPE;</a>
<a name="ln516"> </a>
<a name="ln517">	// Construct our attribute name</a>
<a name="ln518">	std::string attr;</a>
<a name="ln519">	if (fileType) {</a>
<a name="ln520">		attr = kIconAttrPrefix + BPrivate::Storage::to_lower(fileType);</a>
<a name="ln521">	} else</a>
<a name="ln522">		attr = kIconAttr;</a>
<a name="ln523"> </a>
<a name="ln524">	// Write the icon data</a>
<a name="ln525">	BNode node;</a>
<a name="ln526">	bool didCreate = false;</a>
<a name="ln527"> </a>
<a name="ln528">	status_t err = fLocation-&gt;OpenWritableType(type, node, true, &amp;didCreate);</a>
<a name="ln529">	if (err != B_OK)</a>
<a name="ln530">		return err;</a>
<a name="ln531"> </a>
<a name="ln532">	if (!err)</a>
<a name="ln533">		err = node.WriteAttr(attr.c_str(), attrType, 0, data, dataSize);</a>
<a name="ln534">	if (err &gt;= 0)</a>
<a name="ln535">		err = err == (ssize_t)dataSize ? (status_t)B_OK : (status_t)B_FILE_ERROR;</a>
<a name="ln536">	if (didCreate) {</a>
<a name="ln537">		_SendInstallNotification(type);</a>
<a name="ln538">	} else if (!err) {</a>
<a name="ln539">		// TODO: extra notification for vector icons (currently</a>
<a name="ln540">		// passing &quot;true&quot; for B_LARGE_ICON)?</a>
<a name="ln541">		if (fileType) {</a>
<a name="ln542">			_SendMonitorUpdate(B_ICON_FOR_TYPE_CHANGED, type, fileType,</a>
<a name="ln543">				true, B_META_MIME_MODIFIED);</a>
<a name="ln544">		} else {</a>
<a name="ln545">			_SendMonitorUpdate(B_ICON_CHANGED, type, true,</a>
<a name="ln546">				B_META_MIME_MODIFIED);</a>
<a name="ln547">		}</a>
<a name="ln548">	}</a>
<a name="ln549">	return err;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">// SetPreferredApp</a>
<a name="ln553">/*!	\brief Sets the signature of the preferred application for the given app verb</a>
<a name="ln554"> </a>
<a name="ln555">	Currently, the only supported app verb is \c B_OPEN</a>
<a name="ln556">	\param type Pointer to a NULL-terminated string containing the MIME type of interest</a>
<a name="ln557">	\param signature Pointer to a NULL-terminated string containing the MIME signature</a>
<a name="ln558">	                 of the new preferred application</a>
<a name="ln559">	\param verb \c app_verb action for which the new preferred application is applicable</a>
<a name="ln560">*/</a>
<a name="ln561">status_t</a>
<a name="ln562">Database::SetPreferredApp(const char *type, const char *signature, app_verb verb)</a>
<a name="ln563">{</a>
<a name="ln564">	DBG(OUT(&quot;Database::SetPreferredApp()\n&quot;));</a>
<a name="ln565"> </a>
<a name="ln566">	// TODO: use &quot;verb&quot; some day!</a>
<a name="ln567"> </a>
<a name="ln568">	return _SetStringValue(type, B_PREFERRED_APP_CHANGED, kPreferredAppAttr,</a>
<a name="ln569">		kPreferredAppType, B_MIME_TYPE_LENGTH, signature);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">// SetSnifferRule</a>
<a name="ln573">/*! \brief Sets the mime sniffer rule for the given mime type</a>
<a name="ln574">*/</a>
<a name="ln575">status_t</a>
<a name="ln576">Database::SetSnifferRule(const char *type, const char *rule)</a>
<a name="ln577">{</a>
<a name="ln578">	DBG(OUT(&quot;Database::SetSnifferRule()\n&quot;));</a>
<a name="ln579"> </a>
<a name="ln580">	if (type == NULL || rule == NULL)</a>
<a name="ln581">		return B_BAD_VALUE;</a>
<a name="ln582"> </a>
<a name="ln583">	bool didCreate = false;</a>
<a name="ln584">	status_t status = fLocation-&gt;WriteAttribute(type, kSnifferRuleAttr, rule,</a>
<a name="ln585">		strlen(rule) + 1, kSnifferRuleType, &amp;didCreate);</a>
<a name="ln586"> </a>
<a name="ln587">	if (status == B_OK)</a>
<a name="ln588">		status = fSnifferRules.SetSnifferRule(type, rule);</a>
<a name="ln589"> </a>
<a name="ln590">	if (didCreate) {</a>
<a name="ln591">		_SendInstallNotification(type);</a>
<a name="ln592">	} else if (status == B_OK) {</a>
<a name="ln593">		_SendMonitorUpdate(B_SNIFFER_RULE_CHANGED, type,</a>
<a name="ln594">			B_META_MIME_MODIFIED);</a>
<a name="ln595">	}</a>
<a name="ln596"> </a>
<a name="ln597">	return status;</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">// SetSupportedTypes</a>
<a name="ln601">/*!	\brief Sets the list of MIME types supported by the MIME type and</a>
<a name="ln602">	syncs the internal supporting apps database either partially or</a>
<a name="ln603">	completely.</a>
<a name="ln604"> </a>
<a name="ln605">	Please see BMimeType::SetSupportedTypes() for details.</a>
<a name="ln606">	\param type The mime type of interest</a>
<a name="ln607">	\param types The supported types to be assigned to the file.</a>
<a name="ln608">	\param syncAll \c true to also synchronize the previously supported</a>
<a name="ln609">		   types, \c false otherwise.</a>
<a name="ln610">	\return</a>
<a name="ln611">	- \c B_OK: success</a>
<a name="ln612">	- other error codes: failure</a>
<a name="ln613">*/</a>
<a name="ln614">status_t</a>
<a name="ln615">Database::SetSupportedTypes(const char *type, const BMessage *types, bool fullSync)</a>
<a name="ln616">{</a>
<a name="ln617">	DBG(OUT(&quot;Database::SetSupportedTypes()\n&quot;));</a>
<a name="ln618"> </a>
<a name="ln619">	if (type == NULL || types == NULL)</a>
<a name="ln620">		return B_BAD_VALUE;</a>
<a name="ln621"> </a>
<a name="ln622">	// Install the types</a>
<a name="ln623">	const char *supportedType;</a>
<a name="ln624">	for (int32 i = 0; types-&gt;FindString(&quot;types&quot;, i, &amp;supportedType) == B_OK; i++) {</a>
<a name="ln625">		if (!fLocation-&gt;IsInstalled(supportedType)) {</a>
<a name="ln626">			if (Install(supportedType) != B_OK)</a>
<a name="ln627">				break;</a>
<a name="ln628"> </a>
<a name="ln629">			// Since the type has been introduced by this application</a>
<a name="ln630">			// we take the liberty and make it the preferred handler</a>
<a name="ln631">			// for them, too.</a>
<a name="ln632">			SetPreferredApp(supportedType, type, B_OPEN);</a>
<a name="ln633">		}</a>
<a name="ln634">	}</a>
<a name="ln635"> </a>
<a name="ln636">	// Write the attr</a>
<a name="ln637">	bool didCreate = false;</a>
<a name="ln638">	status_t status = fLocation-&gt;WriteMessageAttribute(type,</a>
<a name="ln639">		kSupportedTypesAttr, *types, &amp;didCreate);</a>
<a name="ln640"> </a>
<a name="ln641">	// Notify the monitor if we created the type when we opened it</a>
<a name="ln642">	if (status != B_OK)</a>
<a name="ln643">		return status;</a>
<a name="ln644"> </a>
<a name="ln645">	// Update the supporting apps map</a>
<a name="ln646">	if (status == B_OK)</a>
<a name="ln647">		status = fSupportingApps.SetSupportedTypes(type, types, fullSync);</a>
<a name="ln648"> </a>
<a name="ln649">	// Notify the monitor</a>
<a name="ln650">	if (didCreate) {</a>
<a name="ln651">		_SendInstallNotification(type);</a>
<a name="ln652">	} else if (status == B_OK) {</a>
<a name="ln653">		_SendMonitorUpdate(B_SUPPORTED_TYPES_CHANGED, type,</a>
<a name="ln654">			B_META_MIME_MODIFIED);</a>
<a name="ln655">	}</a>
<a name="ln656"> </a>
<a name="ln657">	return status;</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660"> </a>
<a name="ln661">// GetInstalledSupertypes</a>
<a name="ln662">/*! \brief Fetches a BMessage listing all the MIME supertypes currently</a>
<a name="ln663">	installed in the MIME database.</a>
<a name="ln664"> </a>
<a name="ln665">	The types are copied into the \c &quot;super_types&quot; field of the passed-in \c BMessage.</a>
<a name="ln666">	The \c BMessage must be pre-allocated.</a>
<a name="ln667"> </a>
<a name="ln668">	\param super_types Pointer to a pre-allocated \c BMessage into which the</a>
<a name="ln669">	                   MIME supertypes will be copied.</a>
<a name="ln670">	\return</a>
<a name="ln671">	- \c B_OK: Success</a>
<a name="ln672">	- &quot;error code&quot;: Failure</a>
<a name="ln673">*/</a>
<a name="ln674">status_t</a>
<a name="ln675">Database::GetInstalledSupertypes(BMessage *supertypes)</a>
<a name="ln676">{</a>
<a name="ln677">	return fInstalledTypes.GetInstalledSupertypes(supertypes);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">// GetInstalledTypes</a>
<a name="ln681">/*! \brief Fetches a BMessage listing all the MIME types currently installed</a>
<a name="ln682">	in the MIME database.</a>
<a name="ln683"> </a>
<a name="ln684">	The types are copied into the \c &quot;types&quot; field of the passed-in \c BMessage.</a>
<a name="ln685">	The \c BMessage must be pre-allocated.</a>
<a name="ln686"> </a>
<a name="ln687">	\param types Pointer to a pre-allocated \c BMessage into which the</a>
<a name="ln688">	             MIME types will be copied.</a>
<a name="ln689">	\return</a>
<a name="ln690">	- \c B_OK: Success</a>
<a name="ln691">	- &quot;error code&quot;: Failure</a>
<a name="ln692">*/</a>
<a name="ln693">status_t</a>
<a name="ln694">Database::GetInstalledTypes(BMessage *types)</a>
<a name="ln695">{</a>
<a name="ln696">	return fInstalledTypes.GetInstalledTypes(types);</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">// GetInstalledTypes</a>
<a name="ln700">/*! \brief Fetches a BMessage listing all the MIME subtypes of the given</a>
<a name="ln701">	supertype currently installed in the MIME database.</a>
<a name="ln702"> </a>
<a name="ln703">	The types are copied into the \c &quot;types&quot; field of the passed-in \c BMessage.</a>
<a name="ln704">	The \c BMessage must be pre-allocated.</a>
<a name="ln705"> </a>
<a name="ln706">	\param super_type Pointer to a string containing the MIME supertype whose</a>
<a name="ln707">	                  subtypes you wish to retrieve.</a>
<a name="ln708">	\param subtypes Pointer to a pre-allocated \c BMessage into which the appropriate</a>
<a name="ln709">	                MIME subtypes will be copied.</a>
<a name="ln710">	\return</a>
<a name="ln711">	- \c B_OK: Success</a>
<a name="ln712">	- &quot;error code&quot;: Failure</a>
<a name="ln713">*/</a>
<a name="ln714">status_t</a>
<a name="ln715">Database::GetInstalledTypes(const char *supertype, BMessage *subtypes)</a>
<a name="ln716">{</a>
<a name="ln717">	return fInstalledTypes.GetInstalledTypes(supertype, subtypes);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">// GetSupportingApps</a>
<a name="ln721">/*! \brief Fetches a \c BMessage containing a list of MIME signatures of</a>
<a name="ln722">	applications that are able to handle files of this MIME type.</a>
<a name="ln723"> </a>
<a name="ln724">	Please see BMimeType::GetSupportingApps() for more details.</a>
<a name="ln725">*/</a>
<a name="ln726">status_t</a>
<a name="ln727">Database::GetSupportingApps(const char *type, BMessage *signatures)</a>
<a name="ln728">{</a>
<a name="ln729">	return fSupportingApps.GetSupportingApps(type, signatures);</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">// GetAssociatedTypes</a>
<a name="ln733">/*! \brief Returns a list of mime types associated with the given file extension</a>
<a name="ln734"> </a>
<a name="ln735">	Please see BMimeType::GetAssociatedTypes() for more details.</a>
<a name="ln736">*/</a>
<a name="ln737">status_t</a>
<a name="ln738">Database::GetAssociatedTypes(const char *extension, BMessage *types)</a>
<a name="ln739">{</a>
<a name="ln740">	return B_ERROR;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">// GuessMimeType</a>
<a name="ln744">/*!	\brief Guesses a MIME type for the entry referred to by the given</a>
<a name="ln745">	\c entry_ref.</a>
<a name="ln746"> </a>
<a name="ln747">	This version of GuessMimeType() combines the features of the other</a>
<a name="ln748">	versions, plus adds a few tricks of its own:</a>
<a name="ln749">	- If the entry is a meta mime entry (i.e. has a \c &quot;META:TYPE&quot; attribute),</a>
<a name="ln750">	  the type returned is \c &quot;application/x-vnd.be-meta-mime&quot;.</a>
<a name="ln751">	- If the entry is a directory, the type returned is</a>
<a name="ln752">	  \c &quot;application/x-vnd.be-directory&quot;.</a>
<a name="ln753">	- If the entry is a symlink, the type returned is</a>
<a name="ln754">	  \c &quot;application/x-vnd.be-symlink&quot;.</a>
<a name="ln755">	- If the entry is a regular file, the file data is sniffed and, the</a>
<a name="ln756">	  type returned is the mime type with the matching rule of highest</a>
<a name="ln757">	  priority.</a>
<a name="ln758">	- If sniffing fails, the filename is checked for known extensions.</a>
<a name="ln759">	- If the extension check fails, the type returned is</a>
<a name="ln760">	  \c &quot;application/octet-stream&quot;.</a>
<a name="ln761"> </a>
<a name="ln762">	\param ref Pointer to the entry_ref referring to the entry.</a>
<a name="ln763">	\param type Pointer to a pre-allocated BString which is set to the</a>
<a name="ln764">		   resulting MIME type.</a>
<a name="ln765">	\return</a>
<a name="ln766">	- \c B_OK: success (even if the guess returned is &quot;application/octet-stream&quot;)</a>
<a name="ln767">	- other error code: failure</a>
<a name="ln768">*/</a>
<a name="ln769">status_t</a>
<a name="ln770">Database::GuessMimeType(const entry_ref *ref, BString *result)</a>
<a name="ln771">{</a>
<a name="ln772">	if (ref == NULL || result == NULL)</a>
<a name="ln773">		return B_BAD_VALUE;</a>
<a name="ln774"> </a>
<a name="ln775">	BNode node;</a>
<a name="ln776">	struct stat statData;</a>
<a name="ln777">	status_t status = node.SetTo(ref);</a>
<a name="ln778">	if (status &lt; B_OK)</a>
<a name="ln779">		return status;</a>
<a name="ln780"> </a>
<a name="ln781">	attr_info info;</a>
<a name="ln782">	if (node.GetAttrInfo(kTypeAttr, &amp;info) == B_OK) {</a>
<a name="ln783">		// Check for a META:TYPE attribute</a>
<a name="ln784">		result-&gt;SetTo(kMetaMimeType);</a>
<a name="ln785">		return B_OK;</a>
<a name="ln786">	}</a>
<a name="ln787"> </a>
<a name="ln788">	// See if we have a directory, a symlink, or a vanilla file</a>
<a name="ln789">	status = node.GetStat(&amp;statData);</a>
<a name="ln790">	if (status &lt; B_OK)</a>
<a name="ln791">		return status;</a>
<a name="ln792"> </a>
<a name="ln793">	if (S_ISDIR(statData.st_mode)) {</a>
<a name="ln794">		// Directory</a>
<a name="ln795">		result-&gt;SetTo(kDirectoryType);</a>
<a name="ln796">	} else if (S_ISLNK(statData.st_mode)) {</a>
<a name="ln797">		// Symlink</a>
<a name="ln798">		result-&gt;SetTo(kSymlinkType);</a>
<a name="ln799">	} else if (S_ISREG(statData.st_mode)) {</a>
<a name="ln800">		// Vanilla file: sniff first</a>
<a name="ln801">		status = fSnifferRules.GuessMimeType(ref, result);</a>
<a name="ln802"> </a>
<a name="ln803">		// If that fails, check extensions</a>
<a name="ln804">		if (status == kMimeGuessFailureError)</a>
<a name="ln805">			status = fAssociatedTypes.GuessMimeType(ref, result);</a>
<a name="ln806"> </a>
<a name="ln807">		// If that fails, return the generic file type</a>
<a name="ln808">		if (status == kMimeGuessFailureError) {</a>
<a name="ln809">			result-&gt;SetTo(kGenericFileType);</a>
<a name="ln810">			status = B_OK;</a>
<a name="ln811">		}</a>
<a name="ln812">	} else {</a>
<a name="ln813">		// TODO: we could filter out devices, ...</a>
<a name="ln814">		return B_BAD_TYPE;</a>
<a name="ln815">	}</a>
<a name="ln816"> </a>
<a name="ln817">	return status;</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820">// GuessMimeType</a>
<a name="ln821">/*!	\brief Guesses a MIME type for the supplied chunk of data.</a>
<a name="ln822"> </a>
<a name="ln823">	See \c SnifferRules::GuessMimeType(BPositionIO*, BString*)</a>
<a name="ln824">	for more details.</a>
<a name="ln825"> </a>
<a name="ln826">	\param buffer Pointer to the data buffer.</a>
<a name="ln827">	\param length Size of the buffer in bytes.</a>
<a name="ln828">	\param type Pointer to a pre-allocated BString which is set to the</a>
<a name="ln829">		   resulting MIME type.</a>
<a name="ln830">	\return</a>
<a name="ln831">	- \c B_OK: success</a>
<a name="ln832">	- error code: failure</a>
<a name="ln833">*/</a>
<a name="ln834">status_t</a>
<a name="ln835">Database::GuessMimeType(const void *buffer, int32 length, BString *result)</a>
<a name="ln836">{</a>
<a name="ln837">	if (buffer == NULL || result == NULL)</a>
<a name="ln838">		return B_BAD_VALUE;</a>
<a name="ln839"> </a>
<a name="ln840">	status_t status = fSnifferRules.GuessMimeType(buffer, length, result);</a>
<a name="ln841">	if (status == kMimeGuessFailureError) {</a>
<a name="ln842">		result-&gt;SetTo(kGenericFileType);</a>
<a name="ln843">		return B_OK;</a>
<a name="ln844">	}</a>
<a name="ln845"> </a>
<a name="ln846">	return status;</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849">// GuessMimeType</a>
<a name="ln850">/*!	\brief Guesses a MIME type for the given filename.</a>
<a name="ln851"> </a>
<a name="ln852">	Only the filename itself is taken into consideration (in particular its</a>
<a name="ln853">	name extension), not the entry or corresponding data it refers to (in fact,</a>
<a name="ln854">	an entry with that name need not exist at all.</a>
<a name="ln855"> </a>
<a name="ln856">	\param filename The filename.</a>
<a name="ln857">	\param type Pointer to a pre-allocated BString which is set to the</a>
<a name="ln858">		   resulting MIME type.</a>
<a name="ln859">	\return</a>
<a name="ln860">	- \c B_OK: success</a>
<a name="ln861">	- error code: failure</a>
<a name="ln862">*/</a>
<a name="ln863">status_t</a>
<a name="ln864">Database::GuessMimeType(const char *filename, BString *result)</a>
<a name="ln865">{</a>
<a name="ln866">	if (filename == NULL || result == NULL)</a>
<a name="ln867">		return B_BAD_VALUE;</a>
<a name="ln868"> </a>
<a name="ln869">	status_t status = fAssociatedTypes.GuessMimeType(filename, result);</a>
<a name="ln870">	if (status == kMimeGuessFailureError) {</a>
<a name="ln871">		result-&gt;SetTo(kGenericFileType);</a>
<a name="ln872">		return B_OK;</a>
<a name="ln873">	}</a>
<a name="ln874"> </a>
<a name="ln875">	return status;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878"> </a>
<a name="ln879">/*!	\brief Subscribes the given BMessenger to the MIME monitor service</a>
<a name="ln880"> </a>
<a name="ln881">	Notification messages will be sent with a \c BMessage::what value</a>
<a name="ln882">	of \c B_META_MIME_CHANGED. Notification messages have the following</a>
<a name="ln883">	fields:</a>
<a name="ln884"> </a>
<a name="ln885">	&lt;table&gt;</a>
<a name="ln886">		&lt;tr&gt;</a>
<a name="ln887">			&lt;td&gt; Name &lt;/td&gt;</a>
<a name="ln888">			&lt;td&gt; Type &lt;/td&gt;</a>
<a name="ln889">			&lt;td&gt; Description &lt;/td&gt;</a>
<a name="ln890">		&lt;/tr&gt;</a>
<a name="ln891">		&lt;tr&gt;</a>
<a name="ln892">			&lt;td&gt; \c be:type &lt;/td&gt;</a>
<a name="ln893">			&lt;td&gt; \c B_STRING_TYPE &lt;/td&gt;</a>
<a name="ln894">			&lt;td&gt; The MIME type that was changed &lt;/td&gt;</a>
<a name="ln895">		&lt;/tr&gt;</a>
<a name="ln896">		&lt;tr&gt;</a>
<a name="ln897">			&lt;td&gt; \c be:which &lt;/td&gt;</a>
<a name="ln898">			&lt;td&gt; \c B_INT32_TYPE &lt;/td&gt;</a>
<a name="ln899">			&lt;td&gt; Bitmask describing which attributes were changed (see below) &lt;/td&gt;</a>
<a name="ln900">		&lt;/tr&gt;</a>
<a name="ln901">		&lt;tr&gt;</a>
<a name="ln902">			&lt;td&gt; \c be:extra_type &lt;/td&gt;</a>
<a name="ln903">			&lt;td&gt; \c B_STRING_TYPE &lt;/td&gt;</a>
<a name="ln904">			&lt;td&gt; Additional MIME type string (applicable to B_ICON_FOR_TYPE_CHANGED notifications only)&lt;/td&gt;</a>
<a name="ln905">		&lt;/tr&gt;</a>
<a name="ln906">		&lt;tr&gt;</a>
<a name="ln907">			&lt;td&gt; \c be:large_icon &lt;/td&gt;</a>
<a name="ln908">			&lt;td&gt; \c B_BOOL_TYPE &lt;/td&gt;</a>
<a name="ln909">			&lt;td&gt; \c true if the large icon was changed, \c false if the small icon</a>
<a name="ln910">			     was changed (applicable to B_ICON_[FOR_TYPE_]CHANGED updates only) &lt;/td&gt;</a>
<a name="ln911">		&lt;/tr&gt;</a>
<a name="ln912">	&lt;/table&gt;</a>
<a name="ln913"> </a>
<a name="ln914">	The \c be:which field of the message describes which attributes were updated, and</a>
<a name="ln915">	may be the bitwise \c OR of any of the following values:</a>
<a name="ln916"> </a>
<a name="ln917">	&lt;table&gt;</a>
<a name="ln918">		&lt;tr&gt;</a>
<a name="ln919">			&lt;td&gt; Value &lt;/td&gt;</a>
<a name="ln920">			&lt;td&gt; Triggered By &lt;/td&gt;</a>
<a name="ln921">		&lt;/tr&gt;</a>
<a name="ln922">		&lt;tr&gt;</a>
<a name="ln923">			&lt;td&gt; \c B_ICON_CHANGED &lt;/td&gt;</a>
<a name="ln924">			&lt;td&gt; \c BMimeType::SetIcon() &lt;/td&gt;</a>
<a name="ln925">		&lt;/tr&gt;</a>
<a name="ln926">		&lt;tr&gt;</a>
<a name="ln927">			&lt;td&gt; \c B_PREFERRED_APP_CHANGED &lt;/td&gt;</a>
<a name="ln928">			&lt;td&gt; \c BMimeType::SetPreferredApp() &lt;/td&gt;</a>
<a name="ln929">		&lt;/tr&gt;</a>
<a name="ln930">		&lt;tr&gt;</a>
<a name="ln931">			&lt;td&gt; \c B_ATTR_INFO_CHANGED &lt;/td&gt;</a>
<a name="ln932">			&lt;td&gt; \c BMimeType::SetAttrInfo() &lt;/td&gt;</a>
<a name="ln933">		&lt;/tr&gt;</a>
<a name="ln934">		&lt;tr&gt;</a>
<a name="ln935">			&lt;td&gt; \c B_FILE_EXTENSIONS_CHANGED &lt;/td&gt;</a>
<a name="ln936">			&lt;td&gt; \c BMimeType::SetFileExtensions() &lt;/td&gt;</a>
<a name="ln937">		&lt;/tr&gt;</a>
<a name="ln938">		&lt;tr&gt;</a>
<a name="ln939">			&lt;td&gt; \c B_SHORT_DESCRIPTION_CHANGED &lt;/td&gt;</a>
<a name="ln940">			&lt;td&gt; \c BMimeType::SetShortDescription() &lt;/td&gt;</a>
<a name="ln941">		&lt;/tr&gt;</a>
<a name="ln942">		&lt;tr&gt;</a>
<a name="ln943">			&lt;td&gt; \c B_LONG_DESCRIPTION_CHANGED &lt;/td&gt;</a>
<a name="ln944">			&lt;td&gt; \c BMimeType::SetLongDescription() &lt;/td&gt;</a>
<a name="ln945">		&lt;/tr&gt;</a>
<a name="ln946">		&lt;tr&gt;</a>
<a name="ln947">			&lt;td&gt; \c B_ICON_FOR_TYPE_CHANGED &lt;/td&gt;</a>
<a name="ln948">			&lt;td&gt; \c BMimeType::SetIconForType() &lt;/td&gt;</a>
<a name="ln949">		&lt;/tr&gt;</a>
<a name="ln950">		&lt;tr&gt;</a>
<a name="ln951">			&lt;td&gt; \c B_APP_HINT_CHANGED &lt;/td&gt;</a>
<a name="ln952">			&lt;td&gt; \c BMimeType::SetAppHint() &lt;/td&gt;</a>
<a name="ln953">		&lt;/tr&gt;</a>
<a name="ln954">	&lt;/table&gt;</a>
<a name="ln955"> </a>
<a name="ln956">	\param target The \c BMessenger to subscribe to the MIME monitor service</a>
<a name="ln957">*/</a>
<a name="ln958">status_t</a>
<a name="ln959">Database::StartWatching(BMessenger target)</a>
<a name="ln960">{</a>
<a name="ln961">	DBG(OUT(&quot;Database::StartWatching()\n&quot;));</a>
<a name="ln962"> </a>
<a name="ln963">	if (!target.IsValid())</a>
<a name="ln964">		return B_BAD_VALUE;</a>
<a name="ln965"> </a>
<a name="ln966">	fMonitorMessengers.insert(target);</a>
<a name="ln967">	return B_OK;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">/*!</a>
<a name="ln972">	Unsubscribes the given BMessenger from the MIME monitor service</a>
<a name="ln973">	\param target The \c BMessenger to unsubscribe</a>
<a name="ln974">*/</a>
<a name="ln975">status_t</a>
<a name="ln976">Database::StopWatching(BMessenger target)</a>
<a name="ln977">{</a>
<a name="ln978">	DBG(OUT(&quot;Database::StopWatching()\n&quot;));</a>
<a name="ln979"> </a>
<a name="ln980">	if (!target.IsValid())</a>
<a name="ln981">		return B_BAD_VALUE;</a>
<a name="ln982"> </a>
<a name="ln983">	status_t status = fMonitorMessengers.find(target) != fMonitorMessengers.end()</a>
<a name="ln984">		? (status_t)B_OK : (status_t)B_ENTRY_NOT_FOUND;</a>
<a name="ln985">	if (status == B_OK)</a>
<a name="ln986">		fMonitorMessengers.erase(target);</a>
<a name="ln987"> </a>
<a name="ln988">	return status;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991"> </a>
<a name="ln992">/*!	\brief Deletes the app hint attribute for the given type</a>
<a name="ln993"> </a>
<a name="ln994">	A \c B_APP_HINT_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln995">	\param type The mime type of interest</a>
<a name="ln996">	\return</a>
<a name="ln997">	- B_OK: success</a>
<a name="ln998">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln999">	- &quot;error code&quot;: failure</a>
<a name="ln1000">*/</a>
<a name="ln1001">status_t</a>
<a name="ln1002">Database::DeleteAppHint(const char *type)</a>
<a name="ln1003">{</a>
<a name="ln1004">	status_t status = fLocation-&gt;DeleteAttribute(type, kAppHintAttr);</a>
<a name="ln1005">	if (status == B_OK)</a>
<a name="ln1006">		_SendMonitorUpdate(B_APP_HINT_CHANGED, type, B_META_MIME_DELETED);</a>
<a name="ln1007">	else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1008">		status = B_OK;</a>
<a name="ln1009"> </a>
<a name="ln1010">	return status;</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013"> </a>
<a name="ln1014">/*!	\brief Deletes the attribute info attribute for the given type</a>
<a name="ln1015"> </a>
<a name="ln1016">	A \c B_ATTR_INFO_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1017">	\param type The mime type of interest</a>
<a name="ln1018">	\return</a>
<a name="ln1019">	- B_OK: success</a>
<a name="ln1020">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1021">	- &quot;error code&quot;: failure</a>
<a name="ln1022">*/</a>
<a name="ln1023">status_t</a>
<a name="ln1024">Database::DeleteAttrInfo(const char *type)</a>
<a name="ln1025">{</a>
<a name="ln1026">	status_t status = fLocation-&gt;DeleteAttribute(type, kAttrInfoAttr);</a>
<a name="ln1027">	if (status == B_OK)</a>
<a name="ln1028">		_SendMonitorUpdate(B_ATTR_INFO_CHANGED, type, B_META_MIME_DELETED);</a>
<a name="ln1029">	else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1030">		status = B_OK;</a>
<a name="ln1031"> </a>
<a name="ln1032">	return status;</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035"> </a>
<a name="ln1036">/*!	\brief Deletes the short description attribute for the given type</a>
<a name="ln1037"> </a>
<a name="ln1038">	A \c B_SHORT_DESCRIPTION_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1039">	\param type The mime type of interest</a>
<a name="ln1040">	\return</a>
<a name="ln1041">	- B_OK: success</a>
<a name="ln1042">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1043">	- &quot;error code&quot;: failure</a>
<a name="ln1044">*/</a>
<a name="ln1045">status_t</a>
<a name="ln1046">Database::DeleteShortDescription(const char *type)</a>
<a name="ln1047">{</a>
<a name="ln1048">	status_t status = fLocation-&gt;DeleteAttribute(type, kShortDescriptionAttr);</a>
<a name="ln1049">	if (status == B_OK)</a>
<a name="ln1050">		_SendMonitorUpdate(B_SHORT_DESCRIPTION_CHANGED, type, B_META_MIME_DELETED);</a>
<a name="ln1051">	else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1052">		status = B_OK;</a>
<a name="ln1053"> </a>
<a name="ln1054">	return status;</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057"> </a>
<a name="ln1058">/*!	\brief Deletes the long description attribute for the given type</a>
<a name="ln1059"> </a>
<a name="ln1060">	A \c B_LONG_DESCRIPTION_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1061">	\param type The mime type of interest</a>
<a name="ln1062">	\return</a>
<a name="ln1063">	- B_OK: success</a>
<a name="ln1064">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1065">	- &quot;error code&quot;: failure</a>
<a name="ln1066">*/</a>
<a name="ln1067">status_t</a>
<a name="ln1068">Database::DeleteLongDescription(const char *type)</a>
<a name="ln1069">{</a>
<a name="ln1070">	status_t status = fLocation-&gt;DeleteAttribute(type, kLongDescriptionAttr);</a>
<a name="ln1071">	if (status == B_OK)</a>
<a name="ln1072">		_SendMonitorUpdate(B_LONG_DESCRIPTION_CHANGED, type, B_META_MIME_DELETED);</a>
<a name="ln1073">	else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1074">		status = B_OK;</a>
<a name="ln1075"> </a>
<a name="ln1076">	return status;</a>
<a name="ln1077">}</a>
<a name="ln1078"> </a>
<a name="ln1079"> </a>
<a name="ln1080">/*!	\brief Deletes the associated file extensions attribute for the given type</a>
<a name="ln1081"> </a>
<a name="ln1082">	A \c B_FILE_EXTENSIONS_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1083">	\param type The mime type of interest</a>
<a name="ln1084">	\return</a>
<a name="ln1085">	- B_OK: success</a>
<a name="ln1086">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1087">	- &quot;error code&quot;: failure</a>
<a name="ln1088">*/</a>
<a name="ln1089">status_t</a>
<a name="ln1090">Database::DeleteFileExtensions(const char *type)</a>
<a name="ln1091">{</a>
<a name="ln1092">	status_t status = fLocation-&gt;DeleteAttribute(type, kFileExtensionsAttr);</a>
<a name="ln1093">	if (status == B_OK)</a>
<a name="ln1094">		_SendMonitorUpdate(B_FILE_EXTENSIONS_CHANGED, type, B_META_MIME_DELETED);</a>
<a name="ln1095">	else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1096">		status = B_OK;</a>
<a name="ln1097"> </a>
<a name="ln1098">	return status;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101"> </a>
<a name="ln1102">/*!	\brief Deletes the icon of the given size for the given type</a>
<a name="ln1103"> </a>
<a name="ln1104">	A \c B_ICON_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1105">	\param type The mime type of interest</a>
<a name="ln1106">	\param which The icon size of interest</a>
<a name="ln1107">	\return</a>
<a name="ln1108">	- B_OK: success</a>
<a name="ln1109">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1110">	- &quot;error code&quot;: failure</a>
<a name="ln1111">*/</a>
<a name="ln1112">status_t</a>
<a name="ln1113">Database::DeleteIcon(const char *type, icon_size which)</a>
<a name="ln1114">{</a>
<a name="ln1115">	const char *attr = which == B_MINI_ICON ? kMiniIconAttr : kLargeIconAttr;</a>
<a name="ln1116">	status_t status = fLocation-&gt;DeleteAttribute(type, attr);</a>
<a name="ln1117">	if (status == B_OK) {</a>
<a name="ln1118">		_SendMonitorUpdate(B_ICON_CHANGED, type, which == B_LARGE_ICON,</a>
<a name="ln1119">			B_META_MIME_DELETED);</a>
<a name="ln1120">	} else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1121">		status = B_OK;</a>
<a name="ln1122"> </a>
<a name="ln1123">	return status;</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126"> </a>
<a name="ln1127">/*!	\brief Deletes the vector icon for the given type</a>
<a name="ln1128"> </a>
<a name="ln1129">	A \c B_ICON_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1130">	\param type The mime type of interest</a>
<a name="ln1131">	\return</a>
<a name="ln1132">	- B_OK: success</a>
<a name="ln1133">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1134">	- &quot;error code&quot;: failure</a>
<a name="ln1135">*/</a>
<a name="ln1136">status_t</a>
<a name="ln1137">Database::DeleteIcon(const char *type)</a>
<a name="ln1138">{</a>
<a name="ln1139">	// TODO: extra notification for vector icon (for now we notify a &quot;large&quot;</a>
<a name="ln1140">	// icon)</a>
<a name="ln1141">	status_t status = fLocation-&gt;DeleteAttribute(type, kIconAttr);</a>
<a name="ln1142">	if (status == B_OK) {</a>
<a name="ln1143">		_SendMonitorUpdate(B_ICON_CHANGED, type, true,</a>
<a name="ln1144">						   B_META_MIME_DELETED);</a>
<a name="ln1145">	} else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1146">		status = B_OK;</a>
<a name="ln1147"> </a>
<a name="ln1148">	return status;</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151"> </a>
<a name="ln1152">/*!	\brief Deletes the icon of the given size associated with the given file</a>
<a name="ln1153">		type for the given application signature.</a>
<a name="ln1154"> </a>
<a name="ln1155">    (If this function seems confusing, please see BMimeType::GetIconForType() for a</a>
<a name="ln1156">    better description of what the *IconForType() functions are used for.)</a>
<a name="ln1157"> </a>
<a name="ln1158">	A \c B_ICON_FOR_TYPE_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1159">	\param type The mime type of the application whose custom icon you are deleting.</a>
<a name="ln1160">	\param fileType The mime type for which you no longer wish \c type to have a custom icon.</a>
<a name="ln1161">	\param which The icon size of interest</a>
<a name="ln1162">	\return</a>
<a name="ln1163">	- B_OK: success</a>
<a name="ln1164">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1165">	- &quot;error code&quot;: failure</a>
<a name="ln1166">*/</a>
<a name="ln1167">status_t</a>
<a name="ln1168">Database::DeleteIconForType(const char *type, const char *fileType, icon_size which)</a>
<a name="ln1169">{</a>
<a name="ln1170">	if (fileType == NULL)</a>
<a name="ln1171">		return B_BAD_VALUE;</a>
<a name="ln1172"> </a>
<a name="ln1173">	std::string attr = (which == B_MINI_ICON</a>
<a name="ln1174">		? kMiniIconAttrPrefix : kLargeIconAttrPrefix) + BPrivate::Storage::to_lower(fileType);</a>
<a name="ln1175"> </a>
<a name="ln1176">	status_t status = fLocation-&gt;DeleteAttribute(type, attr.c_str());</a>
<a name="ln1177">	if (status == B_OK) {</a>
<a name="ln1178">		_SendMonitorUpdate(B_ICON_FOR_TYPE_CHANGED, type, fileType,</a>
<a name="ln1179">			which == B_LARGE_ICON, B_META_MIME_DELETED);</a>
<a name="ln1180">	} else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1181">		status = B_OK;</a>
<a name="ln1182"> </a>
<a name="ln1183">	return status;</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186"> </a>
<a name="ln1187">/*!	\brief Deletes the vector icon associated with the given file</a>
<a name="ln1188">		type for the given application signature.</a>
<a name="ln1189"> </a>
<a name="ln1190">    (If this function seems confusing, please see BMimeType::GetIconForType() for a</a>
<a name="ln1191">    better description of what the *IconForType() functions are used for.)</a>
<a name="ln1192"> </a>
<a name="ln1193">	A \c B_ICON_FOR_TYPE_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1194">	\param type The mime type of the application whose custom icon you are deleting.</a>
<a name="ln1195">	\param fileType The mime type for which you no longer wish \c type to have a custom icon.</a>
<a name="ln1196">	\return</a>
<a name="ln1197">	- B_OK: success</a>
<a name="ln1198">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1199">	- &quot;error code&quot;: failure</a>
<a name="ln1200">*/</a>
<a name="ln1201">status_t</a>
<a name="ln1202">Database::DeleteIconForType(const char *type, const char *fileType)</a>
<a name="ln1203">{</a>
<a name="ln1204">	if (fileType == NULL)</a>
<a name="ln1205">		return B_BAD_VALUE;</a>
<a name="ln1206"> </a>
<a name="ln1207">	std::string attr = kIconAttrPrefix + BPrivate::Storage::to_lower(fileType);</a>
<a name="ln1208"> </a>
<a name="ln1209">	// TODO: introduce extra notification for vector icons?</a>
<a name="ln1210">	// (uses B_LARGE_ICON now)</a>
<a name="ln1211">	status_t status = fLocation-&gt;DeleteAttribute(type, attr.c_str());</a>
<a name="ln1212">	if (status == B_OK) {</a>
<a name="ln1213">		_SendMonitorUpdate(B_ICON_FOR_TYPE_CHANGED, type, fileType,</a>
<a name="ln1214">			true, B_META_MIME_DELETED);</a>
<a name="ln1215">	} else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1216">		status = B_OK;</a>
<a name="ln1217"> </a>
<a name="ln1218">	return status;</a>
<a name="ln1219">}</a>
<a name="ln1220"> </a>
<a name="ln1221"> </a>
<a name="ln1222">// DeletePreferredApp</a>
<a name="ln1223">//! Deletes the preferred app for the given app verb for the given type</a>
<a name="ln1224">/*! A \c B_PREFERRED_APP_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1225">	\param type The mime type of interest</a>
<a name="ln1226">	\param which The app verb of interest</a>
<a name="ln1227">	\return</a>
<a name="ln1228">	- B_OK: success</a>
<a name="ln1229">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1230">	- &quot;error code&quot;: failure</a>
<a name="ln1231">*/</a>
<a name="ln1232">status_t</a>
<a name="ln1233">Database::DeletePreferredApp(const char *type, app_verb verb)</a>
<a name="ln1234">{</a>
<a name="ln1235">	status_t status;</a>
<a name="ln1236"> </a>
<a name="ln1237">	switch (verb) {</a>
<a name="ln1238">		case B_OPEN:</a>
<a name="ln1239">			status = fLocation-&gt;DeleteAttribute(type, kPreferredAppAttr);</a>
<a name="ln1240">			break;</a>
<a name="ln1241"> </a>
<a name="ln1242">		default:</a>
<a name="ln1243">			return B_BAD_VALUE;</a>
<a name="ln1244">	}</a>
<a name="ln1245"> </a>
<a name="ln1246">	/*! \todo The R5 monitor makes no note of which app_verb value was updated. If</a>
<a name="ln1247">		additional app_verb values besides \c B_OPEN are someday added, the format</a>
<a name="ln1248">		of the MIME monitor messages will need to be augmented.</a>
<a name="ln1249">	*/</a>
<a name="ln1250">	if (status == B_OK)</a>
<a name="ln1251">		_SendMonitorUpdate(B_PREFERRED_APP_CHANGED, type, B_META_MIME_DELETED);</a>
<a name="ln1252">	else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1253">		status = B_OK;</a>
<a name="ln1254"> </a>
<a name="ln1255">	return status;</a>
<a name="ln1256">}</a>
<a name="ln1257"> </a>
<a name="ln1258">// DeleteSnifferRule</a>
<a name="ln1259">//! Deletes the sniffer rule for the given type</a>
<a name="ln1260">/*! A \c B_SNIFFER_RULE_CHANGED notification is sent to the mime monitor service,</a>
<a name="ln1261">	and the corresponding rule is removed from the internal database of sniffer</a>
<a name="ln1262">	rules.</a>
<a name="ln1263">	\param type The mime type of interest</a>
<a name="ln1264">	\return</a>
<a name="ln1265">	- B_OK: success</a>
<a name="ln1266">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1267">	- &quot;error code&quot;: failure</a>
<a name="ln1268">*/</a>
<a name="ln1269">status_t</a>
<a name="ln1270">Database::DeleteSnifferRule(const char *type)</a>
<a name="ln1271">{</a>
<a name="ln1272">	status_t status = fLocation-&gt;DeleteAttribute(type, kSnifferRuleAttr);</a>
<a name="ln1273">	if (status == B_OK) {</a>
<a name="ln1274">		status = fSnifferRules.DeleteSnifferRule(type);</a>
<a name="ln1275">		if (status == B_OK) {</a>
<a name="ln1276">			_SendMonitorUpdate(B_SNIFFER_RULE_CHANGED, type,</a>
<a name="ln1277">				B_META_MIME_DELETED);</a>
<a name="ln1278">		}</a>
<a name="ln1279">	} else if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln1280">		status = B_OK;</a>
<a name="ln1281"> </a>
<a name="ln1282">	return status;</a>
<a name="ln1283">}</a>
<a name="ln1284"> </a>
<a name="ln1285">// DeleteSupportedTypes</a>
<a name="ln1286">//! Deletes the supported types list for the given type</a>
<a name="ln1287">/*! A \c B_SUPPORTED_TYPES_CHANGED notification is sent to the mime monitor service.</a>
<a name="ln1288">	If \c fullSync is \c true, the given type is removed from the internal list</a>
<a name="ln1289">	of supporting applictions for each previously supported type. If \c fullSync</a>
<a name="ln1290">	is \c false, the said removal will occur the next time SetSupportedTypes() or</a>
<a name="ln1291">	DeleteSupportedTypes() is called with a \c true \c fullSync paramter, or</a>
<a name="ln1292">	\c Delete() is called for the given type.</a>
<a name="ln1293">	\param type The mime type of interest</a>
<a name="ln1294">	\param fullSync Whether or not to remove the type as a supporting app for</a>
<a name="ln1295">	                all previously supported types</a>
<a name="ln1296">	\return</a>
<a name="ln1297">	- B_OK: success</a>
<a name="ln1298">	- B_ENTRY_NOT_FOUND: no such attribute existed</a>
<a name="ln1299">	- &quot;error code&quot;: failure</a>
<a name="ln1300">*/</a>
<a name="ln1301">status_t</a>
<a name="ln1302">Database::DeleteSupportedTypes(const char *type, bool fullSync)</a>
<a name="ln1303">{</a>
<a name="ln1304">	status_t status = fLocation-&gt;DeleteAttribute(type, kSupportedTypesAttr);</a>
<a name="ln1305"> </a>
<a name="ln1306">	// Update the supporting apps database. If fullSync is specified,</a>
<a name="ln1307">	// do so even if the supported types attribute didn't exist, as</a>
<a name="ln1308">	// stranded types *may* exist in the database due to previous</a>
<a name="ln1309">	// calls to {Set,Delete}SupportedTypes() with fullSync == false.</a>
<a name="ln1310">	bool sendUpdate = true;</a>
<a name="ln1311">	if (status == B_OK)</a>
<a name="ln1312">		status = fSupportingApps.DeleteSupportedTypes(type, fullSync);</a>
<a name="ln1313">	else if (status == B_ENTRY_NOT_FOUND) {</a>
<a name="ln1314">		status = B_OK;</a>
<a name="ln1315">		if (fullSync)</a>
<a name="ln1316">			fSupportingApps.DeleteSupportedTypes(type, fullSync);</a>
<a name="ln1317">		else</a>
<a name="ln1318">			sendUpdate = false;</a>
<a name="ln1319">	}</a>
<a name="ln1320"> </a>
<a name="ln1321">	// Send a monitor notification</a>
<a name="ln1322">	if (status == B_OK &amp;&amp; sendUpdate)</a>
<a name="ln1323">		_SendMonitorUpdate(B_SUPPORTED_TYPES_CHANGED, type, B_META_MIME_DELETED);</a>
<a name="ln1324"> </a>
<a name="ln1325">	return status;</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328"> </a>
<a name="ln1329">void</a>
<a name="ln1330">Database::DeferInstallNotification(const char* type)</a>
<a name="ln1331">{</a>
<a name="ln1332">	AutoLocker&lt;BLocker&gt; _(fDeferredInstallNotificationsLocker);</a>
<a name="ln1333"> </a>
<a name="ln1334">	// check, if already deferred</a>
<a name="ln1335">	if (_FindDeferredInstallNotification(type))</a>
<a name="ln1336">		return;</a>
<a name="ln1337"> </a>
<a name="ln1338">	// add new</a>
<a name="ln1339">	DeferredInstallNotification* notification</a>
<a name="ln1340">		= new(std::nothrow) DeferredInstallNotification;</a>
<a name="ln1341">	if (notification == NULL)</a>
<a name="ln1342">		return;</a>
<a name="ln1343"> </a>
<a name="ln1344">	strlcpy(notification-&gt;type, type, sizeof(notification-&gt;type));</a>
<a name="ln1345">	notification-&gt;notify = false;</a>
<a name="ln1346"> </a>
<a name="ln1347">	if (!fDeferredInstallNotifications.AddItem(notification))</a>
<a name="ln1348">		delete notification;</a>
<a name="ln1349">}</a>
<a name="ln1350"> </a>
<a name="ln1351"> </a>
<a name="ln1352">void</a>
<a name="ln1353">Database::UndeferInstallNotification(const char* type)</a>
<a name="ln1354">{</a>
<a name="ln1355">	AutoLocker&lt;BLocker&gt; locker(fDeferredInstallNotificationsLocker);</a>
<a name="ln1356"> </a>
<a name="ln1357">	// check, if deferred at all</a>
<a name="ln1358">	DeferredInstallNotification* notification</a>
<a name="ln1359">		= _FindDeferredInstallNotification(type, true);</a>
<a name="ln1360"> </a>
<a name="ln1361">	locker.Unlock();</a>
<a name="ln1362"> </a>
<a name="ln1363">	if (notification == NULL)</a>
<a name="ln1364">		return;</a>
<a name="ln1365"> </a>
<a name="ln1366">	// notify, if requested</a>
<a name="ln1367">	if (notification-&gt;notify)</a>
<a name="ln1368">		_SendInstallNotification(notification-&gt;type);</a>
<a name="ln1369"> </a>
<a name="ln1370">	delete notification;</a>
<a name="ln1371">}</a>
<a name="ln1372"> </a>
<a name="ln1373"> </a>
<a name="ln1374">//! \brief Sends a \c B_MIME_TYPE_CREATED notification to the mime monitor service</a>
<a name="ln1375">status_t</a>
<a name="ln1376">Database::_SendInstallNotification(const char *type)</a>
<a name="ln1377">{</a>
<a name="ln1378">	return _SendMonitorUpdate(B_MIME_TYPE_CREATED, type, B_META_MIME_MODIFIED);</a>
<a name="ln1379">}</a>
<a name="ln1380"> </a>
<a name="ln1381"> </a>
<a name="ln1382">//! \brief Sends a \c B_MIME_TYPE_DELETED notification to the mime monitor service</a>
<a name="ln1383">status_t</a>
<a name="ln1384">Database::_SendDeleteNotification(const char *type)</a>
<a name="ln1385">{</a>
<a name="ln1386">	// Tell the backend first</a>
<a name="ln1387">	return _SendMonitorUpdate(B_MIME_TYPE_DELETED, type, B_META_MIME_MODIFIED);</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390">// _SendMonitorUpdate</a>
<a name="ln1391">/*! \brief Sends an update notification to all BMessengers that have</a>
<a name="ln1392">	subscribed to the MIME Monitor service</a>
<a name="ln1393">	\param type The MIME type that was updated</a>
<a name="ln1394">	\param which Bitmask describing which attribute was updated</a>
<a name="ln1395">	\param extraType The MIME type to which the change is applies</a>
<a name="ln1396">	\param largeIcon \true if the the large icon was updated, \false if the</a>
<a name="ln1397">		   small icon was updated</a>
<a name="ln1398">*/</a>
<a name="ln1399">status_t</a>
<a name="ln1400">Database::_SendMonitorUpdate(int32 which, const char *type, const char *extraType,</a>
<a name="ln1401">	bool largeIcon, int32 action)</a>
<a name="ln1402">{</a>
<a name="ln1403">	BMessage msg(B_META_MIME_CHANGED);</a>
<a name="ln1404">	status_t err;</a>
<a name="ln1405"> </a>
<a name="ln1406">	if (_CheckDeferredInstallNotification(which, type))</a>
<a name="ln1407">		return B_OK;</a>
<a name="ln1408"> </a>
<a name="ln1409">	err = msg.AddInt32(&quot;be:which&quot;, which);</a>
<a name="ln1410">	if (!err)</a>
<a name="ln1411">		err = msg.AddString(&quot;be:type&quot;, type);</a>
<a name="ln1412">	if (!err)</a>
<a name="ln1413">		err = msg.AddString(&quot;be:extra_type&quot;, extraType);</a>
<a name="ln1414">	if (!err)</a>
<a name="ln1415">		err = msg.AddBool(&quot;be:large_icon&quot;, largeIcon);</a>
<a name="ln1416">	if (!err)</a>
<a name="ln1417">		err = msg.AddInt32(&quot;be:action&quot;, action);</a>
<a name="ln1418">	if (!err)</a>
<a name="ln1419">		err = _SendMonitorUpdate(msg);</a>
<a name="ln1420">	return err;</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423">// _SendMonitorUpdate</a>
<a name="ln1424">/*! \brief Sends an update notification to all BMessengers that have</a>
<a name="ln1425">	subscribed to the MIME Monitor service</a>
<a name="ln1426">	\param type The MIME type that was updated</a>
<a name="ln1427">	\param which Bitmask describing which attribute was updated</a>
<a name="ln1428">	\param extraType The MIME type to which the change is applies</a>
<a name="ln1429">*/</a>
<a name="ln1430">status_t</a>
<a name="ln1431">Database::_SendMonitorUpdate(int32 which, const char *type, const char *extraType,</a>
<a name="ln1432">	int32 action)</a>
<a name="ln1433">{</a>
<a name="ln1434">	if (_CheckDeferredInstallNotification(which, type))</a>
<a name="ln1435">		return B_OK;</a>
<a name="ln1436"> </a>
<a name="ln1437">	BMessage msg(B_META_MIME_CHANGED);</a>
<a name="ln1438"> </a>
<a name="ln1439">	status_t err = msg.AddInt32(&quot;be:which&quot;, which);</a>
<a name="ln1440">	if (!err)</a>
<a name="ln1441">		err = msg.AddString(&quot;be:type&quot;, type);</a>
<a name="ln1442">	if (!err)</a>
<a name="ln1443">		err = msg.AddString(&quot;be:extra_type&quot;, extraType);</a>
<a name="ln1444">	if (!err)</a>
<a name="ln1445">		err = msg.AddInt32(&quot;be:action&quot;, action);</a>
<a name="ln1446">	if (!err)</a>
<a name="ln1447">		err = _SendMonitorUpdate(msg);</a>
<a name="ln1448">	return err;</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451">// _SendMonitorUpdate</a>
<a name="ln1452">/*! \brief Sends an update notification to all BMessengers that have</a>
<a name="ln1453">	subscribed to the MIME Monitor service</a>
<a name="ln1454">	\param type The MIME type that was updated</a>
<a name="ln1455">	\param which Bitmask describing which attribute was updated</a>
<a name="ln1456">	\param largeIcon \true if the the large icon was updated, \false if the</a>
<a name="ln1457">		   small icon was updated</a>
<a name="ln1458">*/</a>
<a name="ln1459">status_t</a>
<a name="ln1460">Database::_SendMonitorUpdate(int32 which, const char *type, bool largeIcon, int32 action)</a>
<a name="ln1461">{</a>
<a name="ln1462">	if (_CheckDeferredInstallNotification(which, type))</a>
<a name="ln1463">		return B_OK;</a>
<a name="ln1464"> </a>
<a name="ln1465">	BMessage msg(B_META_MIME_CHANGED);</a>
<a name="ln1466"> </a>
<a name="ln1467">	status_t err = msg.AddInt32(&quot;be:which&quot;, which);</a>
<a name="ln1468">	if (!err)</a>
<a name="ln1469">		err = msg.AddString(&quot;be:type&quot;, type);</a>
<a name="ln1470">	if (!err)</a>
<a name="ln1471">		err = msg.AddBool(&quot;be:large_icon&quot;, largeIcon);</a>
<a name="ln1472">	if (!err)</a>
<a name="ln1473">		err = msg.AddInt32(&quot;be:action&quot;, action);</a>
<a name="ln1474">	if (!err)</a>
<a name="ln1475">		err = _SendMonitorUpdate(msg);</a>
<a name="ln1476">	return err;</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479">// _SendMonitorUpdate</a>
<a name="ln1480">/*! \brief Sends an update notification to all BMessengers that have</a>
<a name="ln1481">	subscribed to the MIME Monitor service</a>
<a name="ln1482">	\param type The MIME type that was updated</a>
<a name="ln1483">	\param which Bitmask describing which attribute was updated</a>
<a name="ln1484">*/</a>
<a name="ln1485">status_t</a>
<a name="ln1486">Database::_SendMonitorUpdate(int32 which, const char *type, int32 action)</a>
<a name="ln1487">{</a>
<a name="ln1488">	if (_CheckDeferredInstallNotification(which, type))</a>
<a name="ln1489">		return B_OK;</a>
<a name="ln1490"> </a>
<a name="ln1491">	BMessage msg(B_META_MIME_CHANGED);</a>
<a name="ln1492"> </a>
<a name="ln1493">	status_t err = msg.AddInt32(&quot;be:which&quot;, which);</a>
<a name="ln1494">	if (!err)</a>
<a name="ln1495">		err = msg.AddString(&quot;be:type&quot;, type);</a>
<a name="ln1496">	if (!err)</a>
<a name="ln1497">		err = msg.AddInt32(&quot;be:action&quot;, action);</a>
<a name="ln1498">	if (!err)</a>
<a name="ln1499">		err = _SendMonitorUpdate(msg);</a>
<a name="ln1500">	return err;</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503">// _SendMonitorUpdate</a>
<a name="ln1504">/*! \brief Sends an update notification to all BMessengers that have subscribed to</a>
<a name="ln1505">	the MIME Monitor service</a>
<a name="ln1506">	\param BMessage A preformatted MIME monitor message to be sent to all subscribers</a>
<a name="ln1507">*/</a>
<a name="ln1508">status_t</a>
<a name="ln1509">Database::_SendMonitorUpdate(BMessage &amp;msg)</a>
<a name="ln1510">{</a>
<a name="ln1511">	if (fNotificationListener == NULL)</a>
<a name="ln1512">		return B_OK;</a>
<a name="ln1513"> </a>
<a name="ln1514">	status_t err;</a>
<a name="ln1515">	std::set&lt;BMessenger&gt;::const_iterator i;</a>
<a name="ln1516">	for (i = fMonitorMessengers.begin(); i != fMonitorMessengers.end(); i++) {</a>
<a name="ln1517">		status_t err = fNotificationListener-&gt;Notify(&amp;msg, *i);</a>
<a name="ln1518">		if (err) {</a>
<a name="ln1519">			DBG(OUT(&quot;Database::_SendMonitorUpdate(BMessage&amp;): DeliverMessage failed, 0x%lx\n&quot;, err));</a>
<a name="ln1520">		}</a>
<a name="ln1521">	}</a>
<a name="ln1522">	err = B_OK;</a>
<a name="ln1523">	return err;</a>
<a name="ln1524">}</a>
<a name="ln1525"> </a>
<a name="ln1526"> </a>
<a name="ln1527">Database::DeferredInstallNotification*</a>
<a name="ln1528">Database::_FindDeferredInstallNotification(const char* type, bool remove)</a>
<a name="ln1529">{</a>
<a name="ln1530">	for (int32 i = 0;</a>
<a name="ln1531">		DeferredInstallNotification* notification</a>
<a name="ln1532">			= (DeferredInstallNotification*)fDeferredInstallNotifications</a>
<a name="ln1533">				.ItemAt(i); i++) {</a>
<a name="ln1534">		if (strcmp(type, notification-&gt;type) == 0) {</a>
<a name="ln1535">			if (remove)</a>
<a name="ln1536">				fDeferredInstallNotifications.RemoveItem(i);</a>
<a name="ln1537">			return notification;</a>
<a name="ln1538">		}</a>
<a name="ln1539">	}</a>
<a name="ln1540"> </a>
<a name="ln1541">	return NULL;</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544"> </a>
<a name="ln1545">bool</a>
<a name="ln1546">Database::_CheckDeferredInstallNotification(int32 which, const char* type)</a>
<a name="ln1547">{</a>
<a name="ln1548">	AutoLocker&lt;BLocker&gt; locker(fDeferredInstallNotificationsLocker);</a>
<a name="ln1549"> </a>
<a name="ln1550">	// check, if deferred at all</a>
<a name="ln1551">	DeferredInstallNotification* notification</a>
<a name="ln1552">		= _FindDeferredInstallNotification(type);</a>
<a name="ln1553">	if (notification == NULL)</a>
<a name="ln1554">		return false;</a>
<a name="ln1555"> </a>
<a name="ln1556">	if (which == B_MIME_TYPE_DELETED) {</a>
<a name="ln1557">		// MIME type deleted -- if the install notification had been</a>
<a name="ln1558">		// deferred, we don't send anything</a>
<a name="ln1559">		if (notification-&gt;notify) {</a>
<a name="ln1560">			fDeferredInstallNotifications.RemoveItem(notification);</a>
<a name="ln1561">			delete notification;</a>
<a name="ln1562">			return true;</a>
<a name="ln1563">		}</a>
<a name="ln1564">	} else if (which == B_MIME_TYPE_CREATED) {</a>
<a name="ln1565">		// MIME type created -- defer notification</a>
<a name="ln1566">		notification-&gt;notify = true;</a>
<a name="ln1567">		return true;</a>
<a name="ln1568">	} else {</a>
<a name="ln1569">		// MIME type update -- don't send update, if deferred</a>
<a name="ln1570">		if (notification-&gt;notify)</a>
<a name="ln1571">			return true;</a>
<a name="ln1572">	}</a>
<a name="ln1573"> </a>
<a name="ln1574">	return false;</a>
<a name="ln1575">}</a>
<a name="ln1576"> </a>
<a name="ln1577"> </a>
<a name="ln1578">} // namespace Mime</a>
<a name="ln1579">} // namespace Storage</a>
<a name="ln1580">} // namespace BPrivate</a>

</code></pre>
<div class="balloon" rel="646"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'status == ((int) 0)' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
