
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>dst_api.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#ifndef LINT</a>
<a name="ln2">static const char rcsid[] = &quot;$Header: /proj/cvs/prod/libbind/dst/dst_api.c,v 1.17 2007/09/24 17:18:25 each Exp $&quot;;</a>
<a name="ln3">#endif</a>
<a name="ln4"> </a>
<a name="ln5">/*</a>
<a name="ln6"> * Portions Copyright (c) 1995-1998 by Trusted Information Systems, Inc.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Permission to use, copy modify, and distribute this software for any</a>
<a name="ln9"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln10"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln11"> *</a>
<a name="ln12"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND TRUSTED INFORMATION SYSTEMS</a>
<a name="ln13"> * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL</a>
<a name="ln14"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL</a>
<a name="ln15"> * TRUSTED INFORMATION SYSTEMS BE LIABLE FOR ANY SPECIAL, DIRECT,</a>
<a name="ln16"> * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING</a>
<a name="ln17"> * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,</a>
<a name="ln18"> * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION</a>
<a name="ln19"> * WITH THE USE OR PERFORMANCE OF THE SOFTWARE.</a>
<a name="ln20"> */</a>
<a name="ln21">/*</a>
<a name="ln22"> * This file contains the interface between the DST API and the crypto API.</a>
<a name="ln23"> * This is the only file that needs to be changed if the crypto system is</a>
<a name="ln24"> * changed.  Exported functions are:</a>
<a name="ln25"> * void dst_init()	 Initialize the toolkit</a>
<a name="ln26"> * int  dst_check_algorithm()   Function to determines if alg is suppored.</a>
<a name="ln27"> * int  dst_compare_keys()      Function to compare two keys for equality.</a>
<a name="ln28"> * int  dst_sign_data()         Incremental signing routine.</a>
<a name="ln29"> * int  dst_verify_data()       Incremental verify routine.</a>
<a name="ln30"> * int  dst_generate_key()      Function to generate new KEY</a>
<a name="ln31"> * DST_KEY *dst_read_key()      Function to retrieve private/public KEY.</a>
<a name="ln32"> * void dst_write_key()         Function to write out a key.</a>
<a name="ln33"> * DST_KEY *dst_dnskey_to_key() Function to convert DNS KEY RR to a DST</a>
<a name="ln34"> *				KEY structure.</a>
<a name="ln35"> * int dst_key_to_dnskey() 	Function to return a public key in DNS </a>
<a name="ln36"> *				format binary</a>
<a name="ln37"> * DST_KEY *dst_buffer_to_key() Converst a data in buffer to KEY</a>
<a name="ln38"> * int *dst_key_to_buffer()	Writes out DST_KEY key matterial in buffer</a>
<a name="ln39"> * void dst_free_key()       	Releases all memory referenced by key structure</a>
<a name="ln40"> */</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;port_before.h&quot;</a>
<a name="ln43">#include &lt;stdio.h&gt;</a>
<a name="ln44">#include &lt;errno.h&gt;</a>
<a name="ln45">#include &lt;fcntl.h&gt;</a>
<a name="ln46">#include &lt;stdlib.h&gt;</a>
<a name="ln47">#include &lt;unistd.h&gt;</a>
<a name="ln48">#include &lt;string.h&gt;</a>
<a name="ln49">#include &lt;memory.h&gt;</a>
<a name="ln50">#include &lt;ctype.h&gt;</a>
<a name="ln51">#include &lt;time.h&gt;</a>
<a name="ln52">#include &lt;sys/param.h&gt;</a>
<a name="ln53">#include &lt;sys/stat.h&gt;</a>
<a name="ln54">#include &lt;sys/socket.h&gt;</a>
<a name="ln55">#include &lt;netinet/in.h&gt;</a>
<a name="ln56">#include &lt;arpa/nameser.h&gt;</a>
<a name="ln57">#include &lt;resolv.h&gt;</a>
<a name="ln58"> </a>
<a name="ln59">#include &quot;dst_internal.h&quot;</a>
<a name="ln60">#include &quot;port_after.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">/* static variables */</a>
<a name="ln63">static int done_init = 0;</a>
<a name="ln64">dst_func *dst_t_func[DST_MAX_ALGS];</a>
<a name="ln65">const char *key_file_fmt_str = &quot;Private-key-format: v%s\nAlgorithm: %d (%s)\n&quot;;</a>
<a name="ln66">const char *dst_path = &quot;&quot;;</a>
<a name="ln67"> </a>
<a name="ln68">/* internal I/O functions */</a>
<a name="ln69">static DST_KEY *dst_s_read_public_key(const char *in_name, </a>
<a name="ln70">				      const u_int16_t in_id, int in_alg);</a>
<a name="ln71">static int dst_s_read_private_key_file(char *name, DST_KEY *pk_key,</a>
<a name="ln72">				       u_int16_t in_id, int in_alg);</a>
<a name="ln73">static int dst_s_write_public_key(const DST_KEY *key);</a>
<a name="ln74">static int dst_s_write_private_key(const DST_KEY *key);</a>
<a name="ln75"> </a>
<a name="ln76">/* internal function to set up data structure */</a>
<a name="ln77">static DST_KEY *dst_s_get_key_struct(const char *name, const int alg,</a>
<a name="ln78">				     const int flags, const int protocol,</a>
<a name="ln79">				     const int bits);</a>
<a name="ln80"> </a>
<a name="ln81">/*%</a>
<a name="ln82"> *  dst_init</a>
<a name="ln83"> *	This function initializes the Digital Signature Toolkit.</a>
<a name="ln84"> *	Right now, it just checks the DSTKEYPATH environment variable.</a>
<a name="ln85"> *  Parameters</a>
<a name="ln86"> *	none</a>
<a name="ln87"> *  Returns</a>
<a name="ln88"> *	none</a>
<a name="ln89"> */</a>
<a name="ln90">void</a>
<a name="ln91">dst_init()</a>
<a name="ln92">{</a>
<a name="ln93">	char *s;</a>
<a name="ln94">	int len;</a>
<a name="ln95"> </a>
<a name="ln96">	if (done_init != 0)</a>
<a name="ln97">		return;</a>
<a name="ln98">	done_init = 1;</a>
<a name="ln99"> </a>
<a name="ln100">	s = getenv(&quot;DSTKEYPATH&quot;);</a>
<a name="ln101">	len = 0;</a>
<a name="ln102">	if (s) {</a>
<a name="ln103">		struct stat statbuf;</a>
<a name="ln104"> </a>
<a name="ln105">		len = strlen(s);</a>
<a name="ln106">		if (len &gt; PATH_MAX) {</a>
<a name="ln107">			EREPORT((&quot;%s is longer than %d characters, ignoring\n&quot;,</a>
<a name="ln108">				 s, PATH_MAX));</a>
<a name="ln109">		} else if (stat(s, &amp;statbuf) != 0 || !S_ISDIR(statbuf.st_mode)) {</a>
<a name="ln110">			EREPORT((&quot;%s is not a valid directory\n&quot;, s));</a>
<a name="ln111">		} else {</a>
<a name="ln112">			char *tmp;</a>
<a name="ln113">			tmp = (char *) malloc(len + 2);</a>
<a name="ln114">			memcpy(tmp, s, len + 1);</a>
<a name="ln115">			if (tmp[strlen(tmp) - 1] != '/') {</a>
<a name="ln116">				tmp[strlen(tmp) + 1] = 0;</a>
<a name="ln117">				tmp[strlen(tmp)] = '/';</a>
<a name="ln118">			}</a>
<a name="ln119">			dst_path = tmp;</a>
<a name="ln120">		}</a>
<a name="ln121">	}</a>
<a name="ln122">	memset(dst_t_func, 0, sizeof(dst_t_func));</a>
<a name="ln123">	/* first one is selected */</a>
<a name="ln124">	dst_hmac_md5_init();</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">/*%</a>
<a name="ln128"> *  dst_check_algorithm</a>
<a name="ln129"> *	This function determines if the crypto system for the specified</a>
<a name="ln130"> *	algorithm is present.</a>
<a name="ln131"> *  Parameters</a>
<a name="ln132"> *	alg     1       KEY_RSA</a>
<a name="ln133"> *		3       KEY_DSA</a>
<a name="ln134"> *	      157     KEY_HMAC_MD5</a>
<a name="ln135"> *		      future algorithms TBD and registered with IANA.</a>
<a name="ln136"> *  Returns</a>
<a name="ln137"> *	1 - The algorithm is available.</a>
<a name="ln138"> *	0 - The algorithm is not available.</a>
<a name="ln139"> */</a>
<a name="ln140">int</a>
<a name="ln141">dst_check_algorithm(const int alg)</a>
<a name="ln142">{</a>
<a name="ln143">	return (dst_t_func[alg] != NULL);</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">/*%</a>
<a name="ln147"> * dst_s_get_key_struct </a>
<a name="ln148"> *	This function allocates key structure and fills in some of the </a>
<a name="ln149"> *	fields of the structure. </a>
<a name="ln150"> * Parameters: </a>
<a name="ln151"> *	name:     the name of the key </a>
<a name="ln152"> *	alg:      the algorithm number </a>
<a name="ln153"> *	flags:    the dns flags of the key</a>
<a name="ln154"> *	protocol: the dns protocol of the key</a>
<a name="ln155"> *	bits:     the size of the key</a>
<a name="ln156"> * Returns:</a>
<a name="ln157"> *       NULL if error</a>
<a name="ln158"> *       valid pointer otherwise</a>
<a name="ln159"> */</a>
<a name="ln160">static DST_KEY *</a>
<a name="ln161">dst_s_get_key_struct(const char *name, const int alg, const int flags,</a>
<a name="ln162">		     const int protocol, const int bits)</a>
<a name="ln163">{</a>
<a name="ln164">	DST_KEY *new_key = NULL; </a>
<a name="ln165"> </a>
<a name="ln166">	if (dst_check_algorithm(alg)) /*%&lt; make sure alg is available */</a>
<a name="ln167">		new_key = (DST_KEY *) malloc(sizeof(*new_key));</a>
<a name="ln168">	if (new_key == NULL)</a>
<a name="ln169">		return (NULL);</a>
<a name="ln170"> </a>
<a name="ln171">	memset(new_key, 0, sizeof(*new_key));</a>
<a name="ln172">	new_key-&gt;dk_key_name = strdup(name);</a>
<a name="ln173">	if (new_key-&gt;dk_key_name == NULL) {</a>
<a name="ln174">		free(new_key);</a>
<a name="ln175">		return (NULL);</a>
<a name="ln176">	}</a>
<a name="ln177">	new_key-&gt;dk_alg = alg;</a>
<a name="ln178">	new_key-&gt;dk_flags = flags;</a>
<a name="ln179">	new_key-&gt;dk_proto = protocol;</a>
<a name="ln180">	new_key-&gt;dk_KEY_struct = NULL;</a>
<a name="ln181">	new_key-&gt;dk_key_size = bits;</a>
<a name="ln182">	new_key-&gt;dk_func = dst_t_func[alg];</a>
<a name="ln183">	return (new_key);</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">/*%</a>
<a name="ln187"> *  dst_compare_keys</a>
<a name="ln188"> *	Compares two keys for equality.</a>
<a name="ln189"> *  Parameters</a>
<a name="ln190"> *	key1, key2      Two keys to be compared.</a>
<a name="ln191"> *  Returns</a>
<a name="ln192"> *	0	       The keys are equal.</a>
<a name="ln193"> *	non-zero	The keys are not equal.</a>
<a name="ln194"> */</a>
<a name="ln195"> </a>
<a name="ln196">int</a>
<a name="ln197">dst_compare_keys(const DST_KEY *key1, const DST_KEY *key2)</a>
<a name="ln198">{</a>
<a name="ln199">	if (key1 == key2)</a>
<a name="ln200">		return (0);</a>
<a name="ln201">	if (key1 == NULL || key2 == NULL)</a>
<a name="ln202">		return (4);</a>
<a name="ln203">	if (key1-&gt;dk_alg != key2-&gt;dk_alg)</a>
<a name="ln204">		return (1);</a>
<a name="ln205">	if (key1-&gt;dk_key_size != key2-&gt;dk_key_size)</a>
<a name="ln206">		return (2);</a>
<a name="ln207">	if (key1-&gt;dk_id != key2-&gt;dk_id)</a>
<a name="ln208">		return (3);</a>
<a name="ln209">	return (key1-&gt;dk_func-&gt;compare(key1, key2));</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">/*%</a>
<a name="ln213"> * dst_sign_data</a>
<a name="ln214"> *	An incremental signing function.  Data is signed in steps.</a>
<a name="ln215"> *	First the context must be initialized (SIG_MODE_INIT).</a>
<a name="ln216"> *	Then data is hashed (SIG_MODE_UPDATE).  Finally the signature</a>
<a name="ln217"> *	itself is created (SIG_MODE_FINAL).  This function can be called</a>
<a name="ln218"> *	once with INIT, UPDATE and FINAL modes all set, or it can be</a>
<a name="ln219"> *	called separately with a different mode set for each step.  The</a>
<a name="ln220"> *	UPDATE step can be repeated.</a>
<a name="ln221"> * Parameters</a>
<a name="ln222"> *	mode    A bit mask used to specify operation(s) to be performed.</a>
<a name="ln223"> *		  SIG_MODE_INIT	   1   Initialize digest</a>
<a name="ln224"> *		  SIG_MODE_UPDATE	 2   Add data to digest</a>
<a name="ln225"> *		  SIG_MODE_FINAL	  4   Generate signature</a>
<a name="ln226"> *					      from signature</a>
<a name="ln227"> *		  SIG_MODE_ALL (SIG_MODE_INIT,SIG_MODE_UPDATE,SIG_MODE_FINAL</a>
<a name="ln228"> *	data    Data to be signed.</a>
<a name="ln229"> *	len     The length in bytes of data to be signed.</a>
<a name="ln230"> *	in_key  Contains a private key to sign with.</a>
<a name="ln231"> *		  KEY structures should be handled (created, converted,</a>
<a name="ln232"> *		  compared, stored, freed) by the DST.</a>
<a name="ln233"> *	signature</a>
<a name="ln234"> *	      The location to which the signature will be written.</a>
<a name="ln235"> *	sig_len Length of the signature field in bytes.</a>
<a name="ln236"> * Return</a>
<a name="ln237"> *	 0      Successfull INIT or Update operation</a>
<a name="ln238"> *	&amp;gt;0      success FINAL (sign) operation</a>
<a name="ln239"> *	&amp;lt;0      failure</a>
<a name="ln240"> */</a>
<a name="ln241"> </a>
<a name="ln242">int</a>
<a name="ln243">dst_sign_data(const int mode, DST_KEY *in_key, void **context, </a>
<a name="ln244">	      const u_char *data, const int len,</a>
<a name="ln245">	      u_char *signature, const int sig_len)</a>
<a name="ln246">{</a>
<a name="ln247">	DUMP(data, mode, len, &quot;dst_sign_data()&quot;);</a>
<a name="ln248"> </a>
<a name="ln249">	if (mode &amp; SIG_MODE_FINAL &amp;&amp;</a>
<a name="ln250">	    (in_key-&gt;dk_KEY_struct == NULL || signature == NULL))</a>
<a name="ln251">		return (MISSING_KEY_OR_SIGNATURE);</a>
<a name="ln252"> </a>
<a name="ln253">	if (in_key-&gt;dk_func &amp;&amp; in_key-&gt;dk_func-&gt;sign)</a>
<a name="ln254">		return (in_key-&gt;dk_func-&gt;sign(mode, in_key, context, data, len,</a>
<a name="ln255">					      signature, sig_len));</a>
<a name="ln256">	return (UNKNOWN_KEYALG);</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">/*%</a>
<a name="ln260"> *  dst_verify_data</a>
<a name="ln261"> *	An incremental verify function.  Data is verified in steps.</a>
<a name="ln262"> *	First the context must be initialized (SIG_MODE_INIT).</a>
<a name="ln263"> *	Then data is hashed (SIG_MODE_UPDATE).  Finally the signature</a>
<a name="ln264"> *	is verified (SIG_MODE_FINAL).  This function can be called</a>
<a name="ln265"> *	once with INIT, UPDATE and FINAL modes all set, or it can be</a>
<a name="ln266"> *	called separately with a different mode set for each step.  The</a>
<a name="ln267"> *	UPDATE step can be repeated.</a>
<a name="ln268"> *  Parameters</a>
<a name="ln269"> *	mode	Operations to perform this time.</a>
<a name="ln270"> *		      SIG_MODE_INIT       1   Initialize digest</a>
<a name="ln271"> *		      SIG_MODE_UPDATE     2   add data to digest</a>
<a name="ln272"> *		      SIG_MODE_FINAL      4   verify signature</a>
<a name="ln273"> *		      SIG_MODE_ALL</a>
<a name="ln274"> *			  (SIG_MODE_INIT,SIG_MODE_UPDATE,SIG_MODE_FINAL)</a>
<a name="ln275"> *	data	Data to pass through the hash function.</a>
<a name="ln276"> *	len	 Length of the data in bytes.</a>
<a name="ln277"> *	in_key      Key for verification.</a>
<a name="ln278"> *	signature   Location of signature.</a>
<a name="ln279"> *	sig_len     Length of the signature in bytes.</a>
<a name="ln280"> *  Returns</a>
<a name="ln281"> *	0	   Verify success</a>
<a name="ln282"> *	Non-Zero    Verify Failure</a>
<a name="ln283"> */</a>
<a name="ln284"> </a>
<a name="ln285">int</a>
<a name="ln286">dst_verify_data(const int mode, DST_KEY *in_key, void **context, </a>
<a name="ln287">		const u_char *data, const int len,</a>
<a name="ln288">		const u_char *signature, const int sig_len)</a>
<a name="ln289">{</a>
<a name="ln290">	DUMP(data, mode, len, &quot;dst_verify_data()&quot;);</a>
<a name="ln291">	if (mode &amp; SIG_MODE_FINAL &amp;&amp;</a>
<a name="ln292">	    (in_key-&gt;dk_KEY_struct == NULL || signature == NULL))</a>
<a name="ln293">		return (MISSING_KEY_OR_SIGNATURE);</a>
<a name="ln294"> </a>
<a name="ln295">	if (in_key-&gt;dk_func == NULL || in_key-&gt;dk_func-&gt;verify == NULL)</a>
<a name="ln296">		return (UNSUPPORTED_KEYALG);</a>
<a name="ln297">	return (in_key-&gt;dk_func-&gt;verify(mode, in_key, context, data, len,</a>
<a name="ln298">					signature, sig_len));</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">/*%</a>
<a name="ln302"> *  dst_read_private_key</a>
<a name="ln303"> *	Access a private key.  First the list of private keys that have</a>
<a name="ln304"> *	already been read in is searched, then the key accessed on disk.</a>
<a name="ln305"> *	If the private key can be found, it is returned.  If the key cannot</a>
<a name="ln306"> *	be found, a null pointer is returned.  The options specify required</a>
<a name="ln307"> *	key characteristics.  If the private key requested does not have</a>
<a name="ln308"> *	these characteristics, it will not be read.</a>
<a name="ln309"> *  Parameters</a>
<a name="ln310"> *	in_keyname  The private key name.</a>
<a name="ln311"> *	in_id	    The id of the private key.</a>
<a name="ln312"> *	options     DST_FORCE_READ  Read from disk - don't use a previously</a>
<a name="ln313"> *				      read key.</a>
<a name="ln314"> *		  DST_CAN_SIGN    The key must be useable for signing.</a>
<a name="ln315"> *		  DST_NO_AUTHEN   The key must be useable for authentication.</a>
<a name="ln316"> *		  DST_STANDARD    Return any key </a>
<a name="ln317"> *  Returns</a>
<a name="ln318"> *	NULL	If there is no key found in the current directory or</a>
<a name="ln319"> *		      this key has not been loaded before.</a>
<a name="ln320"> *	!NULL       Success - KEY structure returned.</a>
<a name="ln321"> */</a>
<a name="ln322"> </a>
<a name="ln323">DST_KEY *</a>
<a name="ln324">dst_read_key(const char *in_keyname, const u_int16_t in_id, </a>
<a name="ln325">	     const int in_alg, const int type)</a>
<a name="ln326">{</a>
<a name="ln327">	char keyname[PATH_MAX];</a>
<a name="ln328">	DST_KEY *dg_key = NULL, *pubkey = NULL;</a>
<a name="ln329"> </a>
<a name="ln330">	if (!dst_check_algorithm(in_alg)) { /*%&lt; make sure alg is available */</a>
<a name="ln331">		EREPORT((&quot;dst_read_private_key(): Algorithm %d not suppored\n&quot;,</a>
<a name="ln332">			 in_alg));</a>
<a name="ln333">		return (NULL);</a>
<a name="ln334">	}</a>
<a name="ln335">	if ((type &amp; (DST_PUBLIC | DST_PRIVATE)) == 0) </a>
<a name="ln336">		return (NULL);</a>
<a name="ln337">	if (in_keyname == NULL) {</a>
<a name="ln338">		EREPORT((&quot;dst_read_private_key(): Null key name passed in\n&quot;));</a>
<a name="ln339">		return (NULL);</a>
<a name="ln340">	} else if (strlen(in_keyname) &gt;= sizeof(keyname)) {</a>
<a name="ln341">		EREPORT((&quot;dst_read_private_key(): keyname too big\n&quot;));</a>
<a name="ln342">		return (NULL);</a>
<a name="ln343">	} else </a>
<a name="ln344">		strcpy(keyname, in_keyname);</a>
<a name="ln345"> </a>
<a name="ln346">	/* before I read in the public key, check if it is allowed to sign */</a>
<a name="ln347">	if ((pubkey = dst_s_read_public_key(keyname, in_id, in_alg)) == NULL)</a>
<a name="ln348">		return (NULL);</a>
<a name="ln349"> </a>
<a name="ln350">	if (type == DST_PUBLIC) </a>
<a name="ln351">		return pubkey; </a>
<a name="ln352"> </a>
<a name="ln353">	if (!(dg_key = dst_s_get_key_struct(keyname, pubkey-&gt;dk_alg,</a>
<a name="ln354">					    pubkey-&gt;dk_flags, pubkey-&gt;dk_proto,</a>
<a name="ln355">					    0)))</a>
<a name="ln356">		return (dg_key);</a>
<a name="ln357">	/* Fill in private key and some fields in the general key structure */</a>
<a name="ln358">	if (dst_s_read_private_key_file(keyname, dg_key, pubkey-&gt;dk_id,</a>
<a name="ln359">					pubkey-&gt;dk_alg) == 0)</a>
<a name="ln360">		dg_key = dst_free_key(dg_key);</a>
<a name="ln361"> </a>
<a name="ln362">	(void)dst_free_key(pubkey);</a>
<a name="ln363">	return (dg_key);</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">int </a>
<a name="ln367">dst_write_key(const DST_KEY *key, const int type)</a>
<a name="ln368">{</a>
<a name="ln369">	int pub = 0, priv = 0;</a>
<a name="ln370"> </a>
<a name="ln371">	if (key == NULL) </a>
<a name="ln372">		return (0);</a>
<a name="ln373">	if (!dst_check_algorithm(key-&gt;dk_alg)) { /*%&lt; make sure alg is available */</a>
<a name="ln374">		EREPORT((&quot;dst_write_key(): Algorithm %d not suppored\n&quot;, </a>
<a name="ln375">			 key-&gt;dk_alg));</a>
<a name="ln376">		return (UNSUPPORTED_KEYALG);</a>
<a name="ln377">	}</a>
<a name="ln378">	if ((type &amp; (DST_PRIVATE|DST_PUBLIC)) == 0)</a>
<a name="ln379">		return (0);</a>
<a name="ln380"> </a>
<a name="ln381">	if (type &amp; DST_PUBLIC) </a>
<a name="ln382">		if ((pub = dst_s_write_public_key(key)) &lt; 0)</a>
<a name="ln383">			return (pub);</a>
<a name="ln384">	if (type &amp; DST_PRIVATE)</a>
<a name="ln385">		if ((priv = dst_s_write_private_key(key)) &lt; 0)</a>
<a name="ln386">			return (priv);</a>
<a name="ln387">	return (priv+pub);</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">/*%</a>
<a name="ln391"> *  dst_write_private_key</a>
<a name="ln392"> *	Write a private key to disk.  The filename will be of the form:</a>
<a name="ln393"> *	K&amp;lt;key-&amp;gt;dk_name&amp;gt;+&amp;lt;key-&amp;gt;dk_alg+&amp;gt;&amp;lt;key-d&amp;gt;k_id.&amp;gt;&amp;lt;private key suffix&amp;gt;.</a>
<a name="ln394"> *	If there is already a file with this name, an error is returned.</a>
<a name="ln395"> *</a>
<a name="ln396"> *  Parameters</a>
<a name="ln397"> *	key     A DST managed key structure that contains</a>
<a name="ln398"> *	      all information needed about a key.</a>
<a name="ln399"> *  Return</a>
<a name="ln400"> *	&amp;gt;= 0    Correct behavior.  Returns length of encoded key value</a>
<a name="ln401"> *		  written to disk.</a>
<a name="ln402"> *	&amp;lt;  0    error.</a>
<a name="ln403"> */</a>
<a name="ln404"> </a>
<a name="ln405">static int</a>
<a name="ln406">dst_s_write_private_key(const DST_KEY *key)</a>
<a name="ln407">{</a>
<a name="ln408">	u_char encoded_block[RAW_KEY_SIZE];</a>
<a name="ln409">	char file[PATH_MAX];</a>
<a name="ln410">	int len;</a>
<a name="ln411">	FILE *fp;</a>
<a name="ln412"> </a>
<a name="ln413">	/* First encode the key into the portable key format */</a>
<a name="ln414">	if (key == NULL)</a>
<a name="ln415">		return (-1);</a>
<a name="ln416">	if (key-&gt;dk_KEY_struct == NULL)</a>
<a name="ln417">		return (0);	/*%&lt; null key has no private key */</a>
<a name="ln418">	if (key-&gt;dk_func == NULL || key-&gt;dk_func-&gt;to_file_fmt == NULL) {</a>
<a name="ln419">		EREPORT((&quot;dst_write_private_key(): Unsupported operation %d\n&quot;,</a>
<a name="ln420">			 key-&gt;dk_alg));</a>
<a name="ln421">		return (-5);</a>
<a name="ln422">	} else if ((len = key-&gt;dk_func-&gt;to_file_fmt(key, (char *)encoded_block,</a>
<a name="ln423">					     sizeof(encoded_block))) &lt;= 0) {</a>
<a name="ln424">		EREPORT((&quot;dst_write_private_key(): Failed encoding private RSA bsafe key %d\n&quot;, len));</a>
<a name="ln425">		return (-8);</a>
<a name="ln426">	}</a>
<a name="ln427">	/* Now I can create the file I want to use */</a>
<a name="ln428">	dst_s_build_filename(file, key-&gt;dk_key_name, key-&gt;dk_id, key-&gt;dk_alg,</a>
<a name="ln429">			     PRIVATE_KEY, PATH_MAX);</a>
<a name="ln430"> </a>
<a name="ln431">	/* Do not overwrite an existing file */</a>
<a name="ln432">	if ((fp = dst_s_fopen(file, &quot;w&quot;, 0600)) != NULL) {</a>
<a name="ln433">		int nn;</a>
<a name="ln434">		if ((nn = fwrite(encoded_block, 1, len, fp)) != len) {</a>
<a name="ln435">			EREPORT((&quot;dst_write_private_key(): Write failure on %s %d != %d errno=%d\n&quot;,</a>
<a name="ln436">				 file, len, nn, errno));</a>
<a name="ln437">			fclose(fp);</a>
<a name="ln438">			return (-5);</a>
<a name="ln439">		}</a>
<a name="ln440">		fclose(fp);</a>
<a name="ln441">	} else {</a>
<a name="ln442">		EREPORT((&quot;dst_write_private_key(): Can not create file %s\n&quot;</a>
<a name="ln443">			 ,file));</a>
<a name="ln444">		return (-6);</a>
<a name="ln445">	}</a>
<a name="ln446">	memset(encoded_block, 0, len);</a>
<a name="ln447">	return (len);</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">/*%</a>
<a name="ln451">*</a>
<a name="ln452"> *  dst_read_public_key</a>
<a name="ln453"> *	Read a public key from disk and store in a DST key structure.</a>
<a name="ln454"> *  Parameters</a>
<a name="ln455"> *	in_name	 K&amp;lt;in_name&amp;gt;&amp;lt;in_id&amp;gt;.&amp;lt;public key suffix&amp;gt; is the</a>
<a name="ln456"> *		      filename of the key file to be read.</a>
<a name="ln457"> *  Returns</a>
<a name="ln458"> *	NULL	    If the key does not exist or no name is supplied.</a>
<a name="ln459"> *	NON-NULL	Initialized key structure if the key exists.</a>
<a name="ln460"> */</a>
<a name="ln461"> </a>
<a name="ln462">static DST_KEY *</a>
<a name="ln463">dst_s_read_public_key(const char *in_name, const u_int16_t in_id, int in_alg)</a>
<a name="ln464">{</a>
<a name="ln465">	int flags, proto, alg, len, dlen;</a>
<a name="ln466">	int c;</a>
<a name="ln467">	char name[PATH_MAX], enckey[RAW_KEY_SIZE], *notspace;</a>
<a name="ln468">	u_char deckey[RAW_KEY_SIZE];</a>
<a name="ln469">	FILE *fp;</a>
<a name="ln470"> </a>
<a name="ln471">	if (in_name == NULL) {</a>
<a name="ln472">		EREPORT((&quot;dst_read_public_key(): No key name given\n&quot;));</a>
<a name="ln473">		return (NULL);</a>
<a name="ln474">	}</a>
<a name="ln475">	if (dst_s_build_filename(name, in_name, in_id, in_alg, PUBLIC_KEY,</a>
<a name="ln476">				 PATH_MAX) == -1) {</a>
<a name="ln477">		EREPORT((&quot;dst_read_public_key(): Cannot make filename from %s, %d, and %s\n&quot;,</a>
<a name="ln478">			 in_name, in_id, PUBLIC_KEY));</a>
<a name="ln479">		return (NULL);</a>
<a name="ln480">	}</a>
<a name="ln481">	/*</a>
<a name="ln482">	 * Open the file and read it's formatted contents up to key</a>
<a name="ln483">	 * File format:</a>
<a name="ln484">	 *    domain.name [ttl] [IN] KEY  &amp;lt;flags&amp;gt; &amp;lt;protocol&amp;gt; &amp;lt;algorithm&amp;gt; &amp;lt;key&amp;gt;</a>
<a name="ln485">	 * flags, proto, alg stored as decimal (or hex numbers FIXME).</a>
<a name="ln486">	 * (FIXME: handle parentheses for line continuation.)</a>
<a name="ln487">	 */</a>
<a name="ln488">	if ((fp = dst_s_fopen(name, &quot;r&quot;, 0)) == NULL) {</a>
<a name="ln489">		EREPORT((&quot;dst_read_public_key(): Public Key not found %s\n&quot;,</a>
<a name="ln490">			 name));</a>
<a name="ln491">		return (NULL);</a>
<a name="ln492">	}</a>
<a name="ln493">	/* Skip domain name, which ends at first blank */</a>
<a name="ln494">	while ((c = getc(fp)) != EOF)</a>
<a name="ln495">		if (isspace(c))</a>
<a name="ln496">			break;</a>
<a name="ln497">	/* Skip blank to get to next field */</a>
<a name="ln498">	while ((c = getc(fp)) != EOF)</a>
<a name="ln499">		if (!isspace(c))</a>
<a name="ln500">			break;</a>
<a name="ln501"> </a>
<a name="ln502">	/* Skip optional TTL -- if initial digit, skip whole word. */</a>
<a name="ln503">	if (isdigit(c)) {</a>
<a name="ln504">		while ((c = getc(fp)) != EOF)</a>
<a name="ln505">			if (isspace(c))</a>
<a name="ln506">				break;</a>
<a name="ln507">		while ((c = getc(fp)) != EOF)</a>
<a name="ln508">			if (!isspace(c))</a>
<a name="ln509">				break;</a>
<a name="ln510">	}</a>
<a name="ln511">	/* Skip optional &quot;IN&quot; */</a>
<a name="ln512">	if (c == 'I' || c == 'i') {</a>
<a name="ln513">		while ((c = getc(fp)) != EOF)</a>
<a name="ln514">			if (isspace(c))</a>
<a name="ln515">				break;</a>
<a name="ln516">		while ((c = getc(fp)) != EOF)</a>
<a name="ln517">			if (!isspace(c))</a>
<a name="ln518">				break;</a>
<a name="ln519">	}</a>
<a name="ln520">	/* Locate and skip &quot;KEY&quot; */</a>
<a name="ln521">	if (c != 'K' &amp;&amp; c != 'k') {</a>
<a name="ln522">		EREPORT((&quot;\&quot;KEY\&quot; doesn't appear in file: %s&quot;, name));</a>
<a name="ln523">		return NULL;</a>
<a name="ln524">	}</a>
<a name="ln525">	while ((c = getc(fp)) != EOF)</a>
<a name="ln526">		if (isspace(c))</a>
<a name="ln527">			break;</a>
<a name="ln528">	while ((c = getc(fp)) != EOF)</a>
<a name="ln529">		if (!isspace(c))</a>
<a name="ln530">			break;</a>
<a name="ln531">	ungetc(c, fp);		/*%&lt; return the charcter to the input field */</a>
<a name="ln532">	/* Handle hex!! FIXME.  */</a>
<a name="ln533"> </a>
<a name="ln534">	if (fscanf(fp, &quot;%d %d %d&quot;, &amp;flags, &amp;proto, &amp;alg) != 3) {</a>
<a name="ln535">		EREPORT((&quot;dst_read_public_key(): Can not read flag/proto/alg field from %s\n&quot;</a>
<a name="ln536">			 ,name));</a>
<a name="ln537">		return (NULL);</a>
<a name="ln538">	}</a>
<a name="ln539">	/* read in the key string */</a>
<a name="ln540">	fgets(enckey, sizeof(enckey), fp);</a>
<a name="ln541"> </a>
<a name="ln542">	/* If we aren't at end-of-file, something is wrong.  */</a>
<a name="ln543">	while ((c = getc(fp)) != EOF)</a>
<a name="ln544">		if (!isspace(c))</a>
<a name="ln545">			break;</a>
<a name="ln546">	if (!feof(fp)) {</a>
<a name="ln547">		EREPORT((&quot;Key too long in file: %s&quot;, name));</a>
<a name="ln548">		return NULL;</a>
<a name="ln549">	}</a>
<a name="ln550">	fclose(fp);</a>
<a name="ln551"> </a>
<a name="ln552">	if ((len = strlen(enckey)) &lt;= 0)</a>
<a name="ln553">		return (NULL);</a>
<a name="ln554"> </a>
<a name="ln555">	/* discard \n */</a>
<a name="ln556">	enckey[--len] = '\0';</a>
<a name="ln557"> </a>
<a name="ln558">	/* remove leading spaces */</a>
<a name="ln559">	for (notspace = (char *) enckey; isspace((*notspace)&amp;0xff); len--)</a>
<a name="ln560">		notspace++;</a>
<a name="ln561"> </a>
<a name="ln562">	dlen = b64_pton(notspace, deckey, sizeof(deckey));</a>
<a name="ln563">	if (dlen &lt; 0) {</a>
<a name="ln564">		EREPORT((&quot;dst_read_public_key: bad return from b64_pton = %d&quot;,</a>
<a name="ln565">			 dlen));</a>
<a name="ln566">		return (NULL);</a>
<a name="ln567">	}</a>
<a name="ln568">	/* store key and info in a key structure that is returned */</a>
<a name="ln569">/*	return dst_store_public_key(in_name, alg, proto, 666, flags, deckey,</a>
<a name="ln570">				    dlen);*/</a>
<a name="ln571">	return dst_buffer_to_key(in_name, alg, flags, proto, deckey, dlen);</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">/*%</a>
<a name="ln575"> *  dst_write_public_key</a>
<a name="ln576"> *	Write a key to disk in DNS format.</a>
<a name="ln577"> *  Parameters</a>
<a name="ln578"> *	key     Pointer to a DST key structure.</a>
<a name="ln579"> *  Returns</a>
<a name="ln580"> *	0       Failure</a>
<a name="ln581"> *	1       Success</a>
<a name="ln582"> */</a>
<a name="ln583"> </a>
<a name="ln584">static int</a>
<a name="ln585">dst_s_write_public_key(const DST_KEY *key)</a>
<a name="ln586">{</a>
<a name="ln587">	FILE *fp;</a>
<a name="ln588">	char filename[PATH_MAX];</a>
<a name="ln589">	u_char out_key[RAW_KEY_SIZE];</a>
<a name="ln590">	char enc_key[RAW_KEY_SIZE];</a>
<a name="ln591">	int len = 0;</a>
<a name="ln592">	int mode;</a>
<a name="ln593"> </a>
<a name="ln594">	memset(out_key, 0, sizeof(out_key));</a>
<a name="ln595">	if (key == NULL) {</a>
<a name="ln596">		EREPORT((&quot;dst_write_public_key(): No key specified \n&quot;));</a>
<a name="ln597">		return (0);</a>
<a name="ln598">	} else if ((len = dst_key_to_dnskey(key, out_key, sizeof(out_key)))&lt; 0)</a>
<a name="ln599">		return (0);</a>
<a name="ln600"> </a>
<a name="ln601">	/* Make the filename */</a>
<a name="ln602">	if (dst_s_build_filename(filename, key-&gt;dk_key_name, key-&gt;dk_id,</a>
<a name="ln603">				 key-&gt;dk_alg, PUBLIC_KEY, PATH_MAX) == -1) {</a>
<a name="ln604">		EREPORT((&quot;dst_write_public_key(): Cannot make filename from %s, %d, and %s\n&quot;,</a>
<a name="ln605">			 key-&gt;dk_key_name, key-&gt;dk_id, PUBLIC_KEY));</a>
<a name="ln606">		return (0);</a>
<a name="ln607">	}</a>
<a name="ln608">	/* XXX in general this should be a check for symmetric keys */</a>
<a name="ln609">	mode = (key-&gt;dk_alg == KEY_HMAC_MD5) ? 0600 : 0644;</a>
<a name="ln610">	/* create public key file */</a>
<a name="ln611">	if ((fp = dst_s_fopen(filename, &quot;w+&quot;, mode)) == NULL) {</a>
<a name="ln612">		EREPORT((&quot;DST_write_public_key: open of file:%s failed (errno=%d)\n&quot;,</a>
<a name="ln613">			 filename, errno));</a>
<a name="ln614">		return (0);</a>
<a name="ln615">	}</a>
<a name="ln616">	/*write out key first base64 the key data */</a>
<a name="ln617">	if (key-&gt;dk_flags &amp; DST_EXTEND_FLAG)</a>
<a name="ln618">		b64_ntop(&amp;out_key[6], len - 6, enc_key, sizeof(enc_key));</a>
<a name="ln619">	else</a>
<a name="ln620">		b64_ntop(&amp;out_key[4], len - 4, enc_key, sizeof(enc_key));</a>
<a name="ln621">	fprintf(fp, &quot;%s IN KEY %d %d %d %s\n&quot;,</a>
<a name="ln622">		key-&gt;dk_key_name,</a>
<a name="ln623">		key-&gt;dk_flags, key-&gt;dk_proto, key-&gt;dk_alg, enc_key);</a>
<a name="ln624">	fclose(fp);</a>
<a name="ln625">	return (1);</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">/*%</a>
<a name="ln629"> *  dst_dnskey_to_public_key</a>
<a name="ln630"> *	This function converts the contents of a DNS KEY RR into a DST</a>
<a name="ln631"> *	key structure.</a>
<a name="ln632"> *  Paramters</a>
<a name="ln633"> *	len	 Length of the RDATA of the KEY RR RDATA</a>
<a name="ln634"> *	rdata	 A pointer to the the KEY RR RDATA.</a>
<a name="ln635"> *	in_name     Key name to be stored in key structure.</a>
<a name="ln636"> *  Returns</a>
<a name="ln637"> *	NULL	    Failure</a>
<a name="ln638"> *	NON-NULL	Success.  Pointer to key structure.</a>
<a name="ln639"> *			Caller's responsibility to free() it.</a>
<a name="ln640"> */</a>
<a name="ln641"> </a>
<a name="ln642">DST_KEY *</a>
<a name="ln643">dst_dnskey_to_key(const char *in_name, const u_char *rdata, const int len)</a>
<a name="ln644">{</a>
<a name="ln645">	DST_KEY *key_st;</a>
<a name="ln646">	int alg ;</a>
<a name="ln647">	int start = DST_KEY_START;</a>
<a name="ln648"> </a>
<a name="ln649">	if (rdata == NULL || len &lt;= DST_KEY_ALG) /*%&lt; no data */</a>
<a name="ln650">		return (NULL);</a>
<a name="ln651">	alg = (u_int8_t) rdata[DST_KEY_ALG];</a>
<a name="ln652">	if (!dst_check_algorithm(alg)) { /*%&lt; make sure alg is available */</a>
<a name="ln653">		EREPORT((&quot;dst_dnskey_to_key(): Algorithm %d not suppored\n&quot;,</a>
<a name="ln654">			 alg));</a>
<a name="ln655">		return (NULL);</a>
<a name="ln656">	}</a>
<a name="ln657"> </a>
<a name="ln658">	if (in_name == NULL)</a>
<a name="ln659">		return (NULL);</a>
<a name="ln660"> </a>
<a name="ln661">	if ((key_st = dst_s_get_key_struct(in_name, alg, 0, 0, 0)) == NULL)</a>
<a name="ln662">		return (NULL);</a>
<a name="ln663"> </a>
<a name="ln664">	key_st-&gt;dk_id = dst_s_dns_key_id(rdata, len);</a>
<a name="ln665">	key_st-&gt;dk_flags = dst_s_get_int16(rdata);</a>
<a name="ln666">	key_st-&gt;dk_proto = (u_int16_t) rdata[DST_KEY_PROT];</a>
<a name="ln667">	if (key_st-&gt;dk_flags &amp; DST_EXTEND_FLAG) {</a>
<a name="ln668">		u_int32_t ext_flags;</a>
<a name="ln669">		ext_flags = (u_int32_t) dst_s_get_int16(&amp;rdata[DST_EXT_FLAG]);</a>
<a name="ln670">		key_st-&gt;dk_flags = key_st-&gt;dk_flags | (ext_flags &lt;&lt; 16);</a>
<a name="ln671">		start += 2;</a>
<a name="ln672">	}</a>
<a name="ln673">	/*</a>
<a name="ln674">	 * now point to the begining of the data representing the encoding</a>
<a name="ln675">	 * of the key</a>
<a name="ln676">	 */</a>
<a name="ln677">	if (key_st-&gt;dk_func &amp;&amp; key_st-&gt;dk_func-&gt;from_dns_key) {</a>
<a name="ln678">		if (key_st-&gt;dk_func-&gt;from_dns_key(key_st, &amp;rdata[start],</a>
<a name="ln679">						  len - start) &gt; 0)</a>
<a name="ln680">			return (key_st);</a>
<a name="ln681">	} else</a>
<a name="ln682">		EREPORT((&quot;dst_dnskey_to_public_key(): unsuppored alg %d\n&quot;,</a>
<a name="ln683">			 alg));</a>
<a name="ln684"> </a>
<a name="ln685">	SAFE_FREE(key_st);</a>
<a name="ln686">	return (key_st);</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">/*%</a>
<a name="ln690"> *  dst_public_key_to_dnskey</a>
<a name="ln691"> *	Function to encode a public key into DNS KEY wire format </a>
<a name="ln692"> *  Parameters</a>
<a name="ln693"> *	key	     Key structure to encode.</a>
<a name="ln694"> *	out_storage     Location to write the encoded key to.</a>
<a name="ln695"> *	out_len	 Size of the output array.</a>
<a name="ln696"> *  Returns</a>
<a name="ln697"> *	&lt;0      Failure</a>
<a name="ln698"> *	&gt;=0     Number of bytes written to out_storage</a>
<a name="ln699"> */</a>
<a name="ln700"> </a>
<a name="ln701">int</a>
<a name="ln702">dst_key_to_dnskey(const DST_KEY *key, u_char *out_storage,</a>
<a name="ln703">			 const int out_len)</a>
<a name="ln704">{</a>
<a name="ln705">	u_int16_t val;</a>
<a name="ln706">	int loc = 0;</a>
<a name="ln707">	int enc_len = 0;</a>
<a name="ln708">	if (key == NULL)</a>
<a name="ln709">		return (-1);</a>
<a name="ln710"> </a>
<a name="ln711">	if (!dst_check_algorithm(key-&gt;dk_alg)) { /*%&lt; make sure alg is available */</a>
<a name="ln712">		EREPORT((&quot;dst_key_to_dnskey(): Algorithm %d not suppored\n&quot;,</a>
<a name="ln713">			 key-&gt;dk_alg));</a>
<a name="ln714">		return (UNSUPPORTED_KEYALG);</a>
<a name="ln715">	}</a>
<a name="ln716">	memset(out_storage, 0, out_len);</a>
<a name="ln717">	val = (u_int16_t)(key-&gt;dk_flags &amp; 0xffff);</a>
<a name="ln718">	dst_s_put_int16(out_storage, val);</a>
<a name="ln719">	loc += 2;</a>
<a name="ln720"> </a>
<a name="ln721">	out_storage[loc++] = (u_char) key-&gt;dk_proto;</a>
<a name="ln722">	out_storage[loc++] = (u_char) key-&gt;dk_alg;</a>
<a name="ln723"> </a>
<a name="ln724">	if (key-&gt;dk_flags &gt; 0xffff) {	/*%&lt; Extended flags */</a>
<a name="ln725">		val = (u_int16_t)((key-&gt;dk_flags &gt;&gt; 16) &amp; 0xffff);</a>
<a name="ln726">		dst_s_put_int16(&amp;out_storage[loc], val);</a>
<a name="ln727">		loc += 2;</a>
<a name="ln728">	}</a>
<a name="ln729">	if (key-&gt;dk_KEY_struct == NULL)</a>
<a name="ln730">		return (loc);</a>
<a name="ln731">	if (key-&gt;dk_func &amp;&amp; key-&gt;dk_func-&gt;to_dns_key) {</a>
<a name="ln732">		enc_len = key-&gt;dk_func-&gt;to_dns_key(key,</a>
<a name="ln733">						 (u_char *) &amp;out_storage[loc],</a>
<a name="ln734">						   out_len - loc);</a>
<a name="ln735">		if (enc_len &gt; 0)</a>
<a name="ln736">			return (enc_len + loc);</a>
<a name="ln737">		else</a>
<a name="ln738">			return (-1);</a>
<a name="ln739">	} else</a>
<a name="ln740">		EREPORT((&quot;dst_key_to_dnskey(): Unsupported ALG %d\n&quot;,</a>
<a name="ln741">			 key-&gt;dk_alg));</a>
<a name="ln742">	return (-1);</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">/*%</a>
<a name="ln746"> *  dst_buffer_to_key</a>
<a name="ln747"> *	Function to encode a string of raw data into a DST key</a>
<a name="ln748"> *  Parameters</a>
<a name="ln749"> *	alg		The algorithm (HMAC only)</a>
<a name="ln750"> *	key		A pointer to the data</a>
<a name="ln751"> *	keylen		The length of the data</a>
<a name="ln752"> *  Returns</a>
<a name="ln753"> *	NULL	    an error occurred</a>
<a name="ln754"> *	NON-NULL	the DST key</a>
<a name="ln755"> */</a>
<a name="ln756">DST_KEY *</a>
<a name="ln757">dst_buffer_to_key(const char *key_name,		/*!&lt; name of the key  */</a>
<a name="ln758">		  const int alg,		/*!&lt; algorithm  */</a>
<a name="ln759">		  const int flags,		/*!&lt; dns flags  */</a>
<a name="ln760">		  const int protocol,		/*!&lt; dns protocol  */</a>
<a name="ln761">		  const u_char *key_buf,	/*!&lt; key in dns wire fmt  */</a>
<a name="ln762">		  const int key_len)		/*!&lt; size of key  */</a>
<a name="ln763">{</a>
<a name="ln764">	</a>
<a name="ln765">	DST_KEY *dkey = NULL; </a>
<a name="ln766">	int dnslen;</a>
<a name="ln767">	u_char dns[2048];</a>
<a name="ln768"> </a>
<a name="ln769">	if (!dst_check_algorithm(alg)) { /*%&lt; make sure alg is available */</a>
<a name="ln770">		EREPORT((&quot;dst_buffer_to_key(): Algorithm %d not suppored\n&quot;, alg));</a>
<a name="ln771">		return (NULL);</a>
<a name="ln772">	}</a>
<a name="ln773"> </a>
<a name="ln774">	dkey = dst_s_get_key_struct(key_name, alg, flags, protocol, -1);</a>
<a name="ln775"> </a>
<a name="ln776">	if (dkey == NULL || dkey-&gt;dk_func == NULL ||</a>
<a name="ln777">	    dkey-&gt;dk_func-&gt;from_dns_key == NULL) </a>
<a name="ln778">		return (dst_free_key(dkey));</a>
<a name="ln779"> </a>
<a name="ln780">	if (dkey-&gt;dk_func-&gt;from_dns_key(dkey, key_buf, key_len) &lt; 0) {</a>
<a name="ln781">		EREPORT((&quot;dst_buffer_to_key(): dst_buffer_to_hmac failed\n&quot;));</a>
<a name="ln782">		return (dst_free_key(dkey));</a>
<a name="ln783">	}</a>
<a name="ln784"> </a>
<a name="ln785">	dnslen = dst_key_to_dnskey(dkey, dns, sizeof(dns));</a>
<a name="ln786">	dkey-&gt;dk_id = dst_s_dns_key_id(dns, dnslen);</a>
<a name="ln787">	return (dkey);</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">int </a>
<a name="ln791">dst_key_to_buffer(DST_KEY *key, u_char *out_buff, int buf_len)</a>
<a name="ln792">{</a>
<a name="ln793">	int len;</a>
<a name="ln794">  /* this function will extrac the secret of HMAC into a buffer */</a>
<a name="ln795">	if (key == NULL) </a>
<a name="ln796">		return (0);</a>
<a name="ln797">	if (key-&gt;dk_func != NULL &amp;&amp; key-&gt;dk_func-&gt;to_dns_key != NULL) {</a>
<a name="ln798">		len = key-&gt;dk_func-&gt;to_dns_key(key, out_buff, buf_len);</a>
<a name="ln799">		if (len &lt; 0)</a>
<a name="ln800">			return (0);</a>
<a name="ln801">		return (len);</a>
<a name="ln802">	}</a>
<a name="ln803">	return (0);</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806">/*%</a>
<a name="ln807"> * dst_s_read_private_key_file</a>
<a name="ln808"> *     Function reads in private key from a file.</a>
<a name="ln809"> *     Fills out the KEY structure.</a>
<a name="ln810"> * Parameters</a>
<a name="ln811"> *     name    Name of the key to be read.</a>
<a name="ln812"> *     pk_key  Structure that the key is returned in.</a>
<a name="ln813"> *     in_id   Key identifier (tag)</a>
<a name="ln814"> * Return</a>
<a name="ln815"> *     1 if everthing works</a>
<a name="ln816"> *     0 if there is any problem</a>
<a name="ln817"> */</a>
<a name="ln818"> </a>
<a name="ln819">static int</a>
<a name="ln820">dst_s_read_private_key_file(char *name, DST_KEY *pk_key, u_int16_t in_id,</a>
<a name="ln821">			    int in_alg)</a>
<a name="ln822">{</a>
<a name="ln823">	int cnt, alg, len, major, minor, file_major, file_minor;</a>
<a name="ln824">	int ret, id;</a>
<a name="ln825">	char filename[PATH_MAX];</a>
<a name="ln826">	u_char in_buff[RAW_KEY_SIZE], *p;</a>
<a name="ln827">	FILE *fp;</a>
<a name="ln828">	int dnslen;</a>
<a name="ln829">	u_char dns[2048];</a>
<a name="ln830"> </a>
<a name="ln831">	if (name == NULL || pk_key == NULL) {</a>
<a name="ln832">		EREPORT((&quot;dst_read_private_key_file(): No key name given\n&quot;));</a>
<a name="ln833">		return (0);</a>
<a name="ln834">	}</a>
<a name="ln835">	/* Make the filename */</a>
<a name="ln836">	if (dst_s_build_filename(filename, name, in_id, in_alg, PRIVATE_KEY,</a>
<a name="ln837">				 PATH_MAX) == -1) {</a>
<a name="ln838">		EREPORT((&quot;dst_read_private_key(): Cannot make filename from %s, %d, and %s\n&quot;,</a>
<a name="ln839">			 name, in_id, PRIVATE_KEY));</a>
<a name="ln840">		return (0);</a>
<a name="ln841">	}</a>
<a name="ln842">	/* first check if we can find the key file */</a>
<a name="ln843">	if ((fp = dst_s_fopen(filename, &quot;r&quot;, 0)) == NULL) {</a>
<a name="ln844">		EREPORT((&quot;dst_s_read_private_key_file: Could not open file %s in directory %s\n&quot;,</a>
<a name="ln845">			 filename, dst_path[0] ? dst_path :</a>
<a name="ln846">			 (char *) getcwd(NULL, PATH_MAX - 1)));</a>
<a name="ln847">		return (0);</a>
<a name="ln848">	}</a>
<a name="ln849">	/* now read the header info from the file */</a>
<a name="ln850">	if ((cnt = fread(in_buff, 1, sizeof(in_buff), fp)) &lt; 5) {</a>
<a name="ln851">		fclose(fp);</a>
<a name="ln852">		EREPORT((&quot;dst_s_read_private_key_file: error reading file %s (empty file)\n&quot;,</a>
<a name="ln853">			 filename));</a>
<a name="ln854">		return (0);</a>
<a name="ln855">	}</a>
<a name="ln856">	/* decrypt key */</a>
<a name="ln857">	fclose(fp);</a>
<a name="ln858">	if (memcmp(in_buff, &quot;Private-key-format: v&quot;, 20) != 0)</a>
<a name="ln859">		goto fail;</a>
<a name="ln860">	len = cnt;</a>
<a name="ln861">	p = in_buff;</a>
<a name="ln862"> </a>
<a name="ln863">	if (!dst_s_verify_str((const char **) (void *)&amp;p,</a>
<a name="ln864">			       &quot;Private-key-format: v&quot;)) {</a>
<a name="ln865">		EREPORT((&quot;dst_s_read_private_key_file(): Not a Key file/Decrypt failed %s\n&quot;, name));</a>
<a name="ln866">		goto fail;</a>
<a name="ln867">	}</a>
<a name="ln868">	/* read in file format */</a>
<a name="ln869">	sscanf((char *)p, &quot;%d.%d&quot;, &amp;file_major, &amp;file_minor);</a>
<a name="ln870">	sscanf(KEY_FILE_FORMAT, &quot;%d.%d&quot;, &amp;major, &amp;minor);</a>
<a name="ln871">	if (file_major &lt; 1) {</a>
<a name="ln872">		EREPORT((&quot;dst_s_read_private_key_file(): Unknown keyfile %d.%d version for %s\n&quot;,</a>
<a name="ln873">			 file_major, file_minor, name));</a>
<a name="ln874">		goto fail;</a>
<a name="ln875">	} else if (file_major &gt; major || file_minor &gt; minor)</a>
<a name="ln876">		EREPORT((</a>
<a name="ln877">				&quot;dst_s_read_private_key_file(): Keyfile %s version higher than mine %d.%d MAY FAIL\n&quot;,</a>
<a name="ln878">				name, file_major, file_minor));</a>
<a name="ln879"> </a>
<a name="ln880">	while (*p++ != '\n') ;	/*%&lt; skip to end of line */</a>
<a name="ln881"> </a>
<a name="ln882">	if (!dst_s_verify_str((const char **) (void *)&amp;p, &quot;Algorithm: &quot;))</a>
<a name="ln883">		goto fail;</a>
<a name="ln884"> </a>
<a name="ln885">	if (sscanf((char *)p, &quot;%d&quot;, &amp;alg) != 1)</a>
<a name="ln886">		goto fail;</a>
<a name="ln887">	while (*p++ != '\n') ;	/*%&lt; skip to end of line */</a>
<a name="ln888"> </a>
<a name="ln889">	if (pk_key-&gt;dk_key_name &amp;&amp; !strcmp(pk_key-&gt;dk_key_name, name))</a>
<a name="ln890">		SAFE_FREE2(pk_key-&gt;dk_key_name, strlen(pk_key-&gt;dk_key_name));</a>
<a name="ln891">	pk_key-&gt;dk_key_name = (char *) strdup(name);</a>
<a name="ln892"> </a>
<a name="ln893">	/* allocate and fill in key structure */</a>
<a name="ln894">	if (pk_key-&gt;dk_func == NULL || pk_key-&gt;dk_func-&gt;from_file_fmt == NULL)</a>
<a name="ln895">		goto fail;</a>
<a name="ln896"> </a>
<a name="ln897">	ret = pk_key-&gt;dk_func-&gt;from_file_fmt(pk_key, (char *)p, &amp;in_buff[len] - p);</a>
<a name="ln898">	if (ret &lt; 0)</a>
<a name="ln899">		goto fail;</a>
<a name="ln900"> </a>
<a name="ln901">	dnslen = dst_key_to_dnskey(pk_key, dns, sizeof(dns));</a>
<a name="ln902">	id = dst_s_dns_key_id(dns, dnslen);</a>
<a name="ln903"> </a>
<a name="ln904">	/* Make sure the actual key tag matches the input tag used in the filename</a>
<a name="ln905">	 */</a>
<a name="ln906">	if (id != in_id) {</a>
<a name="ln907">		EREPORT((&quot;dst_s_read_private_key_file(): actual tag of key read %d != input tag used to build filename %d.\n&quot;, id, in_id));</a>
<a name="ln908">		goto fail;</a>
<a name="ln909">	}</a>
<a name="ln910">	pk_key-&gt;dk_id = (u_int16_t) id;</a>
<a name="ln911">	pk_key-&gt;dk_alg = alg;</a>
<a name="ln912">	memset(in_buff, 0, cnt);</a>
<a name="ln913">	return (1);</a>
<a name="ln914"> </a>
<a name="ln915"> fail:</a>
<a name="ln916">	memset(in_buff, 0, cnt);</a>
<a name="ln917">	return (0);</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">/*%</a>
<a name="ln921"> *	Generate and store a public/private keypair.</a>
<a name="ln922"> *	Keys will be stored in formatted files.</a>
<a name="ln923"> *</a>
<a name="ln924"> *  Parameters</a>
<a name="ln925"> &amp;</a>
<a name="ln926"> *\par	name    Name of the new key.  Used to create key files</a>
<a name="ln927"> *\li		  K&amp;lt;name&amp;gt;+&amp;lt;alg&amp;gt;+&amp;lt;id&amp;gt;.public and K&amp;lt;name&amp;gt;+&amp;lt;alg&amp;gt;+&amp;lt;id&amp;gt;.private.</a>
<a name="ln928"> *\par	bits    Size of the new key in bits.</a>
<a name="ln929"> *\par	exp     What exponent to use:</a>
<a name="ln930"> *\li		  0	   use exponent 3</a>
<a name="ln931"> *\li		  non-zero    use Fermant4</a>
<a name="ln932"> *\par	flags   The default value of the DNS Key flags.</a>
<a name="ln933"> *\li		  The DNS Key RR Flag field is defined in RFC2065,</a>
<a name="ln934"> *		  section 3.3.  The field has 16 bits.</a>
<a name="ln935"> *\par	protocol</a>
<a name="ln936"> *\li	      Default value of the DNS Key protocol field.</a>
<a name="ln937"> *\li		  The DNS Key protocol field is defined in RFC2065,</a>
<a name="ln938"> *		  section 3.4.  The field has 8 bits.</a>
<a name="ln939"> *\par	alg     What algorithm to use.  Currently defined:</a>
<a name="ln940"> *\li		  KEY_RSA       1</a>
<a name="ln941"> *\li		  KEY_DSA       3</a>
<a name="ln942"> *\li		  KEY_HMAC    157</a>
<a name="ln943"> *\par	out_id The key tag is returned.</a>
<a name="ln944"> *</a>
<a name="ln945"> *  Return</a>
<a name="ln946"> *\li	NULL		Failure</a>
<a name="ln947"> *\li	non-NULL 	the generated key pair</a>
<a name="ln948"> *			Caller frees the result, and its dk_name pointer.</a>
<a name="ln949"> */</a>
<a name="ln950">DST_KEY *</a>
<a name="ln951">dst_generate_key(const char *name, const int bits, const int exp,</a>
<a name="ln952">		 const int flags, const int protocol, const int alg)</a>
<a name="ln953">{</a>
<a name="ln954">	DST_KEY *new_key = NULL;</a>
<a name="ln955">	int dnslen;</a>
<a name="ln956">	u_char dns[2048];</a>
<a name="ln957"> </a>
<a name="ln958">	if (name == NULL)</a>
<a name="ln959">		return (NULL);</a>
<a name="ln960"> </a>
<a name="ln961">	if (!dst_check_algorithm(alg)) { /*%&lt; make sure alg is available */</a>
<a name="ln962">		EREPORT((&quot;dst_generate_key(): Algorithm %d not suppored\n&quot;, alg));</a>
<a name="ln963">		return (NULL);</a>
<a name="ln964">	}</a>
<a name="ln965"> </a>
<a name="ln966">	new_key = dst_s_get_key_struct(name, alg, flags, protocol, bits);</a>
<a name="ln967">	if (new_key == NULL)</a>
<a name="ln968">		return (NULL);</a>
<a name="ln969">	if (bits == 0) /*%&lt; null key we are done */</a>
<a name="ln970">		return (new_key);</a>
<a name="ln971">	if (new_key-&gt;dk_func == NULL || new_key-&gt;dk_func-&gt;generate == NULL) {</a>
<a name="ln972">		EREPORT((&quot;dst_generate_key_pair():Unsupported algorithm %d\n&quot;,</a>
<a name="ln973">			 alg));</a>
<a name="ln974">		return (dst_free_key(new_key));</a>
<a name="ln975">	}</a>
<a name="ln976">	if (new_key-&gt;dk_func-&gt;generate(new_key, exp) &lt;= 0) {</a>
<a name="ln977">		EREPORT((&quot;dst_generate_key_pair(): Key generation failure %s %d %d %d\n&quot;,</a>
<a name="ln978">			 new_key-&gt;dk_key_name, new_key-&gt;dk_alg,</a>
<a name="ln979">			 new_key-&gt;dk_key_size, exp));</a>
<a name="ln980">		return (dst_free_key(new_key));</a>
<a name="ln981">	}</a>
<a name="ln982"> </a>
<a name="ln983">	dnslen = dst_key_to_dnskey(new_key, dns, sizeof(dns));</a>
<a name="ln984">	if (dnslen != UNSUPPORTED_KEYALG)</a>
<a name="ln985">		new_key-&gt;dk_id = dst_s_dns_key_id(dns, dnslen);</a>
<a name="ln986">	else</a>
<a name="ln987">		new_key-&gt;dk_id = 0;</a>
<a name="ln988"> </a>
<a name="ln989">	return (new_key);</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992">/*%</a>
<a name="ln993"> *	Release all data structures pointed to by a key structure.</a>
<a name="ln994"> *</a>
<a name="ln995"> *  Parameters</a>
<a name="ln996"> *\li	f_key   Key structure to be freed.</a>
<a name="ln997"> */</a>
<a name="ln998"> </a>
<a name="ln999">DST_KEY *</a>
<a name="ln1000">dst_free_key(DST_KEY *f_key)</a>
<a name="ln1001">{</a>
<a name="ln1002"> </a>
<a name="ln1003">	if (f_key == NULL)</a>
<a name="ln1004">		return (f_key);</a>
<a name="ln1005">	if (f_key-&gt;dk_func &amp;&amp; f_key-&gt;dk_func-&gt;destroy)</a>
<a name="ln1006">		f_key-&gt;dk_KEY_struct =</a>
<a name="ln1007">			f_key-&gt;dk_func-&gt;destroy(f_key-&gt;dk_KEY_struct);</a>
<a name="ln1008">	else {</a>
<a name="ln1009">		EREPORT((&quot;dst_free_key(): Unknown key alg %d\n&quot;,</a>
<a name="ln1010">			 f_key-&gt;dk_alg));</a>
<a name="ln1011">	}</a>
<a name="ln1012">	if (f_key-&gt;dk_KEY_struct) {</a>
<a name="ln1013">		free(f_key-&gt;dk_KEY_struct);</a>
<a name="ln1014">		f_key-&gt;dk_KEY_struct = NULL;</a>
<a name="ln1015">	}</a>
<a name="ln1016">	if (f_key-&gt;dk_key_name)</a>
<a name="ln1017">		SAFE_FREE(f_key-&gt;dk_key_name);</a>
<a name="ln1018">	SAFE_FREE(f_key);</a>
<a name="ln1019">	return (NULL);</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">/*%</a>
<a name="ln1023"> *	Return the maximim size of signature from the key specified in bytes</a>
<a name="ln1024"> *</a>
<a name="ln1025"> * Parameters</a>
<a name="ln1026"> *\li      key </a>
<a name="ln1027"> *</a>
<a name="ln1028"> * Returns</a>
<a name="ln1029"> *  \li   bytes</a>
<a name="ln1030"> */</a>
<a name="ln1031">int</a>
<a name="ln1032">dst_sig_size(DST_KEY *key) {</a>
<a name="ln1033">	switch (key-&gt;dk_alg) {</a>
<a name="ln1034">	    case KEY_HMAC_MD5:</a>
<a name="ln1035">		return (16);</a>
<a name="ln1036">	    case KEY_HMAC_SHA1:</a>
<a name="ln1037">		return (20);</a>
<a name="ln1038">	    case KEY_RSA:</a>
<a name="ln1039">		return (key-&gt;dk_key_size + 7) / 8;</a>
<a name="ln1040">	    case KEY_DSA:</a>
<a name="ln1041">		return (40);</a>
<a name="ln1042">	    default:</a>
<a name="ln1043">		EREPORT((&quot;dst_sig_size(): Unknown key alg %d\n&quot;, key-&gt;dk_alg));</a>
<a name="ln1044">		return -1;</a>
<a name="ln1045">	}</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">/*! \file */</a>

</code></pre>
<div class="balloon" rel="916"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v597/" target="_blank">V597</a> The compiler could delete the 'memset' function call, which is used to flush 'in_buff' buffer. The memset_s() function should be used to erase the private data.</p></div>
<div class="balloon" rel="685"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v597/" target="_blank">V597</a> The compiler could delete the 'memset' function call, which is used to flush 'key_st' object. The memset_s() function should be used to erase the private data.</p></div>
<div class="balloon" rel="446"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v597/" target="_blank">V597</a> The compiler could delete the 'memset' function call, which is used to flush 'encoded_block' buffer. The memset_s() function should be used to erase the private data.</p></div>
<div class="balloon" rel="1018"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v597/" target="_blank">V597</a> The compiler could delete the 'memset' function call, which is used to flush 'f_key' object. The memset_s() function should be used to erase the private data.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
