
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>virtio_net.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2013, 2018, Jérôme Duval, jerome.duval@gmail.com.</a>
<a name="ln3"> * Copyright 2017, Philippe Houdoin, philippe.houdoin@gmail.com.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;net/if_media.h&gt;</a>
<a name="ln9">#include &lt;new&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;ethernet.h&gt;</a>
<a name="ln12">#include &lt;lock.h&gt;</a>
<a name="ln13">#include &lt;util/DoublyLinkedList.h&gt;</a>
<a name="ln14">#include &lt;virtio.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;ether_driver.h&quot;</a>
<a name="ln17">#define ETHER_ADDR_LEN	ETHER_ADDRESS_LENGTH</a>
<a name="ln18">#include &quot;virtio_net.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20"> </a>
<a name="ln21">#define VIRTIO_NET_DRIVER_MODULE_NAME &quot;drivers/network/virtio_net/driver_v1&quot;</a>
<a name="ln22">#define VIRTIO_NET_DEVICE_MODULE_NAME &quot;drivers/network/virtio_net/device_v1&quot;</a>
<a name="ln23">#define VIRTIO_NET_DEVICE_ID_GENERATOR	&quot;virtio_net/device_id&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#define BUFFER_SIZE	2048</a>
<a name="ln26">#define MAX_FRAME_SIZE 1536</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">struct virtio_net_rx_hdr {</a>
<a name="ln30">	struct virtio_net_hdr	hdr;</a>
<a name="ln31">	uint8					pad[4];</a>
<a name="ln32">} _PACKED;</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">struct virtio_net_tx_hdr {</a>
<a name="ln36">	union {</a>
<a name="ln37">		struct virtio_net_hdr			hdr;</a>
<a name="ln38">		struct virtio_net_hdr_mrg_rxbuf mhdr;</a>
<a name="ln39">	};</a>
<a name="ln40">} _PACKED;</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">struct BufInfo : DoublyLinkedListLinkImpl&lt;BufInfo&gt; {</a>
<a name="ln44">	char*					buffer;</a>
<a name="ln45">	struct virtio_net_hdr*	hdr;</a>
<a name="ln46">	physical_entry			entry;</a>
<a name="ln47">	physical_entry			hdrEntry;</a>
<a name="ln48">	uint32					rxUsedLength;</a>
<a name="ln49">};</a>
<a name="ln50"> </a>
<a name="ln51"> </a>
<a name="ln52">typedef DoublyLinkedList&lt;BufInfo&gt; BufInfoList;</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">typedef struct {</a>
<a name="ln56">	device_node*			node;</a>
<a name="ln57">	::virtio_device			virtio_device;</a>
<a name="ln58">	virtio_device_interface*	virtio;</a>
<a name="ln59"> </a>
<a name="ln60">	uint32 					features;</a>
<a name="ln61"> </a>
<a name="ln62">	uint32					pairsCount;</a>
<a name="ln63"> </a>
<a name="ln64">	::virtio_queue*			rxQueues;</a>
<a name="ln65">	uint16*					rxSizes;</a>
<a name="ln66"> </a>
<a name="ln67">	BufInfo**				rxBufInfos;</a>
<a name="ln68">	sem_id					rxDone;</a>
<a name="ln69">	area_id					rxArea;</a>
<a name="ln70">	BufInfoList				rxFullList;</a>
<a name="ln71">	mutex					rxLock;</a>
<a name="ln72"> </a>
<a name="ln73">	::virtio_queue*			txQueues;</a>
<a name="ln74">	uint16*					txSizes;</a>
<a name="ln75"> </a>
<a name="ln76">	BufInfo**				txBufInfos;</a>
<a name="ln77">	sem_id					txDone;</a>
<a name="ln78">	area_id					txArea;</a>
<a name="ln79">	BufInfoList				txFreeList;</a>
<a name="ln80">	mutex					txLock;</a>
<a name="ln81"> </a>
<a name="ln82">	::virtio_queue			ctrlQueue;</a>
<a name="ln83"> </a>
<a name="ln84">	bool					nonblocking;</a>
<a name="ln85">	uint32					maxframesize;</a>
<a name="ln86">	uint8					macaddr[6];</a>
<a name="ln87"> </a>
<a name="ln88">} virtio_net_driver_info;</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">typedef struct {</a>
<a name="ln92">	virtio_net_driver_info*		info;</a>
<a name="ln93">} virtio_net_handle;</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">#include &lt;stdio.h&gt;</a>
<a name="ln97">#include &lt;string.h&gt;</a>
<a name="ln98">#include &lt;stdlib.h&gt;</a>
<a name="ln99"> </a>
<a name="ln100">#include &lt;fs/devfs.h&gt;</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">//#define TRACE_VIRTIO_NET</a>
<a name="ln104">#ifdef TRACE_VIRTIO_NET</a>
<a name="ln105">#	define TRACE(x...) dprintf(&quot;virtio_net: &quot; x)</a>
<a name="ln106">#else</a>
<a name="ln107">#	define TRACE(x...) ;</a>
<a name="ln108">#endif</a>
<a name="ln109">#define ERROR(x...)			dprintf(&quot;\33[33mvirtio_net:\33[0m &quot; x)</a>
<a name="ln110">#define CALLED() 			TRACE(&quot;CALLED %s\n&quot;, __PRETTY_FUNCTION__)</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">static device_manager_info* sDeviceManager;</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116">static void virtio_net_rxDone(void* driverCookie, void* cookie);</a>
<a name="ln117">static void virtio_net_txDone(void* driverCookie, void* cookie);</a>
<a name="ln118"> </a>
<a name="ln119"> </a>
<a name="ln120">const char*</a>
<a name="ln121">get_feature_name(uint32 feature)</a>
<a name="ln122">{</a>
<a name="ln123">	switch (feature) {</a>
<a name="ln124">		case VIRTIO_NET_F_CSUM:</a>
<a name="ln125">			return &quot;host checksum&quot;;</a>
<a name="ln126">		case VIRTIO_NET_F_GUEST_CSUM:</a>
<a name="ln127">			return &quot;guest checksum&quot;;</a>
<a name="ln128">		case VIRTIO_NET_F_MAC:</a>
<a name="ln129">			return &quot;macaddress&quot;;</a>
<a name="ln130">		case VIRTIO_NET_F_GSO:</a>
<a name="ln131">			return &quot;host allgso&quot;;</a>
<a name="ln132">		case VIRTIO_NET_F_GUEST_TSO4:</a>
<a name="ln133">			return &quot;guest tso4&quot;;</a>
<a name="ln134">		case VIRTIO_NET_F_GUEST_TSO6:</a>
<a name="ln135">			return &quot;guest tso6&quot;;</a>
<a name="ln136">		case VIRTIO_NET_F_GUEST_ECN:</a>
<a name="ln137">			return &quot;guest tso6+ecn&quot;;</a>
<a name="ln138">		case VIRTIO_NET_F_GUEST_UFO:</a>
<a name="ln139">			return &quot;guest ufo&quot;;</a>
<a name="ln140">		case VIRTIO_NET_F_HOST_TSO4:</a>
<a name="ln141">			return &quot;host tso4&quot;;</a>
<a name="ln142">		case VIRTIO_NET_F_HOST_TSO6:</a>
<a name="ln143">			return &quot;host tso6&quot;;</a>
<a name="ln144">		case VIRTIO_NET_F_HOST_ECN:</a>
<a name="ln145">			return &quot;host tso6+ecn&quot;;</a>
<a name="ln146">		case VIRTIO_NET_F_HOST_UFO:</a>
<a name="ln147">			return &quot;host UFO&quot;;</a>
<a name="ln148">		case VIRTIO_NET_F_MRG_RXBUF:</a>
<a name="ln149">			return &quot;host mergerxbuffers&quot;;</a>
<a name="ln150">		case VIRTIO_NET_F_STATUS:</a>
<a name="ln151">			return &quot;status&quot;;</a>
<a name="ln152">		case VIRTIO_NET_F_CTRL_VQ:</a>
<a name="ln153">			return &quot;control vq&quot;;</a>
<a name="ln154">		case VIRTIO_NET_F_CTRL_RX:</a>
<a name="ln155">			return &quot;rx mode&quot;;</a>
<a name="ln156">		case VIRTIO_NET_F_CTRL_VLAN:</a>
<a name="ln157">			return &quot;vlan filter&quot;;</a>
<a name="ln158">		case VIRTIO_NET_F_CTRL_RX_EXTRA:</a>
<a name="ln159">			return &quot;rx mode extra&quot;;</a>
<a name="ln160">		case VIRTIO_NET_F_GUEST_ANNOUNCE:</a>
<a name="ln161">			return &quot;guest announce&quot;;</a>
<a name="ln162">		case VIRTIO_NET_F_MQ:</a>
<a name="ln163">			return &quot;multiqueue&quot;;</a>
<a name="ln164">		case VIRTIO_NET_F_CTRL_MAC_ADDR:</a>
<a name="ln165">			return &quot;set macaddress&quot;;</a>
<a name="ln166">	}</a>
<a name="ln167">	return NULL;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">static status_t</a>
<a name="ln172">virtio_net_drain_queues(virtio_net_driver_info* info)</a>
<a name="ln173">{</a>
<a name="ln174">	while (true) {</a>
<a name="ln175">		BufInfo* buf = (BufInfo*)info-&gt;virtio-&gt;queue_dequeue(</a>
<a name="ln176">			info-&gt;txQueues[0], NULL);</a>
<a name="ln177">		if (buf == NULL)</a>
<a name="ln178">			break;</a>
<a name="ln179">		info-&gt;txFreeList.Add(buf);</a>
<a name="ln180">	}</a>
<a name="ln181"> </a>
<a name="ln182">	while (true) {</a>
<a name="ln183">		BufInfo* buf = (BufInfo*)info-&gt;virtio-&gt;queue_dequeue(</a>
<a name="ln184">			info-&gt;rxQueues[0], NULL);</a>
<a name="ln185">		if (buf == NULL)</a>
<a name="ln186">			break;</a>
<a name="ln187">	}</a>
<a name="ln188"> </a>
<a name="ln189">	while (true) {</a>
<a name="ln190">		BufInfo* buf = info-&gt;rxFullList.RemoveHead();</a>
<a name="ln191">		if (buf == NULL)</a>
<a name="ln192">			break;</a>
<a name="ln193">	}</a>
<a name="ln194"> </a>
<a name="ln195">	return B_OK;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198"> </a>
<a name="ln199">static status_t</a>
<a name="ln200">virtio_net_rx_enqueue_buf(virtio_net_driver_info* info, BufInfo* buf)</a>
<a name="ln201">{</a>
<a name="ln202">	physical_entry entries[2];</a>
<a name="ln203">	entries[0] = buf-&gt;hdrEntry;</a>
<a name="ln204">	entries[1] = buf-&gt;entry;</a>
<a name="ln205"> </a>
<a name="ln206">	memset(buf-&gt;hdr, 0, sizeof(struct virtio_net_hdr));</a>
<a name="ln207"> </a>
<a name="ln208">	// queue the rx buffer</a>
<a name="ln209">	status_t status = info-&gt;virtio-&gt;queue_request_v(info-&gt;rxQueues[0],</a>
<a name="ln210">		entries, 0, 2, buf);</a>
<a name="ln211">	if (status != B_OK) {</a>
<a name="ln212">		ERROR(&quot;rx queueing on queue %d failed (%s)\n&quot;, 0, strerror(status));</a>
<a name="ln213">		return status;</a>
<a name="ln214">	}</a>
<a name="ln215"> </a>
<a name="ln216">	return B_OK;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">#define ROUND_TO_PAGE_SIZE(x) (((x) + (B_PAGE_SIZE) - 1) &amp; ~((B_PAGE_SIZE) - 1))</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">//	#pragma mark - device module API</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">static status_t</a>
<a name="ln227">virtio_net_init_device(void* _info, void** _cookie)</a>
<a name="ln228">{</a>
<a name="ln229">	CALLED();</a>
<a name="ln230">	virtio_net_driver_info* info = (virtio_net_driver_info*)_info;</a>
<a name="ln231"> </a>
<a name="ln232">	device_node* parent = sDeviceManager-&gt;get_parent_node(info-&gt;node);</a>
<a name="ln233">	sDeviceManager-&gt;get_driver(parent, (driver_module_info**)&amp;info-&gt;virtio,</a>
<a name="ln234">		(void**)&amp;info-&gt;virtio_device);</a>
<a name="ln235">	sDeviceManager-&gt;put_node(parent);</a>
<a name="ln236"> </a>
<a name="ln237">	info-&gt;virtio-&gt;negotiate_features(info-&gt;virtio_device,</a>
<a name="ln238">		VIRTIO_NET_F_STATUS | VIRTIO_NET_F_MAC</a>
<a name="ln239">		/* VIRTIO_NET_F_CTRL_VQ | VIRTIO_NET_F_MQ */,</a>
<a name="ln240">		 &amp;info-&gt;features, &amp;get_feature_name);</a>
<a name="ln241"> </a>
<a name="ln242">	if ((info-&gt;features &amp; VIRTIO_NET_F_MQ) != 0</a>
<a name="ln243">			&amp;&amp; (info-&gt;features &amp; VIRTIO_NET_F_CTRL_VQ) != 0</a>
<a name="ln244">			&amp;&amp; info-&gt;virtio-&gt;read_device_config(info-&gt;virtio_device,</a>
<a name="ln245">				offsetof(struct virtio_net_config, max_virtqueue_pairs),</a>
<a name="ln246">				&amp;info-&gt;pairsCount, sizeof(info-&gt;pairsCount)) == B_OK) {</a>
<a name="ln247">		system_info sysinfo;</a>
<a name="ln248">		if (get_system_info(&amp;sysinfo) == B_OK</a>
<a name="ln249">			&amp;&amp; info-&gt;pairsCount &gt; sysinfo.cpu_count) {</a>
<a name="ln250">			info-&gt;pairsCount = sysinfo.cpu_count;</a>
<a name="ln251">		}</a>
<a name="ln252">	} else</a>
<a name="ln253">		info-&gt;pairsCount = 1;</a>
<a name="ln254"> </a>
<a name="ln255">	// TODO read config</a>
<a name="ln256"> </a>
<a name="ln257">	// Setup queues</a>
<a name="ln258">	uint32 queueCount = info-&gt;pairsCount * 2;</a>
<a name="ln259">	if ((info-&gt;features &amp; VIRTIO_NET_F_CTRL_VQ) != 0)</a>
<a name="ln260">		queueCount++;</a>
<a name="ln261">	::virtio_queue virtioQueues[queueCount];</a>
<a name="ln262">	status_t status = info-&gt;virtio-&gt;alloc_queues(info-&gt;virtio_device, queueCount,</a>
<a name="ln263">		virtioQueues);</a>
<a name="ln264">	if (status != B_OK) {</a>
<a name="ln265">		ERROR(&quot;queue allocation failed (%s)\n&quot;, strerror(status));</a>
<a name="ln266">		return status;</a>
<a name="ln267">	}</a>
<a name="ln268"> </a>
<a name="ln269">	char* rxBuffer;</a>
<a name="ln270">	char* txBuffer;</a>
<a name="ln271"> </a>
<a name="ln272">	info-&gt;rxQueues = new(std::nothrow) virtio_queue[info-&gt;pairsCount];</a>
<a name="ln273">	info-&gt;txQueues = new(std::nothrow) virtio_queue[info-&gt;pairsCount];</a>
<a name="ln274">	info-&gt;rxSizes = new(std::nothrow) uint16[info-&gt;pairsCount];</a>
<a name="ln275">	info-&gt;txSizes = new(std::nothrow) uint16[info-&gt;pairsCount];</a>
<a name="ln276">	if (info-&gt;rxQueues == NULL || info-&gt;txQueues == NULL</a>
<a name="ln277">		|| info-&gt;rxSizes == NULL || info-&gt;txSizes == NULL) {</a>
<a name="ln278">		status = B_NO_MEMORY;</a>
<a name="ln279">		goto err1;</a>
<a name="ln280">	}</a>
<a name="ln281">	for (uint32 i = 0; i &lt; info-&gt;pairsCount; i++) {</a>
<a name="ln282">		info-&gt;rxQueues[i] = virtioQueues[i * 2];</a>
<a name="ln283">		info-&gt;txQueues[i] = virtioQueues[i * 2 + 1];</a>
<a name="ln284">		info-&gt;rxSizes[i] = info-&gt;virtio-&gt;queue_size(info-&gt;rxQueues[i]) / 2;</a>
<a name="ln285">		info-&gt;txSizes[i] = info-&gt;virtio-&gt;queue_size(info-&gt;txQueues[i]) / 2;</a>
<a name="ln286">	}</a>
<a name="ln287">	if ((info-&gt;features &amp; VIRTIO_NET_F_CTRL_VQ) != 0)</a>
<a name="ln288">		info-&gt;ctrlQueue = virtioQueues[info-&gt;pairsCount * 2];</a>
<a name="ln289"> </a>
<a name="ln290">	info-&gt;rxBufInfos = new(std::nothrow) BufInfo*[info-&gt;rxSizes[0]];</a>
<a name="ln291">	info-&gt;txBufInfos = new(std::nothrow) BufInfo*[info-&gt;txSizes[0]];</a>
<a name="ln292">	if (info-&gt;rxBufInfos == NULL || info-&gt;txBufInfos == NULL) {</a>
<a name="ln293">		status = B_NO_MEMORY;</a>
<a name="ln294">		goto err2;</a>
<a name="ln295">	}</a>
<a name="ln296">	memset(info-&gt;rxBufInfos, 0, sizeof(info-&gt;rxBufInfos));</a>
<a name="ln297">	memset(info-&gt;txBufInfos, 0, sizeof(info-&gt;txBufInfos));</a>
<a name="ln298"> </a>
<a name="ln299">	// create receive buffer area</a>
<a name="ln300">	info-&gt;rxArea = create_area(&quot;virtionet rx buffer&quot;, (void**)&amp;rxBuffer,</a>
<a name="ln301">		B_ANY_KERNEL_BLOCK_ADDRESS, ROUND_TO_PAGE_SIZE(</a>
<a name="ln302">			BUFFER_SIZE * info-&gt;rxSizes[0]),</a>
<a name="ln303">		B_FULL_LOCK, B_KERNEL_READ_AREA | B_KERNEL_WRITE_AREA);</a>
<a name="ln304">	if (info-&gt;rxArea &lt; B_OK) {</a>
<a name="ln305">		status = info-&gt;rxArea;</a>
<a name="ln306">		goto err3;</a>
<a name="ln307">	}</a>
<a name="ln308"> </a>
<a name="ln309">	// initialize receive buffer descriptors</a>
<a name="ln310">	for (int i = 0; i &lt; info-&gt;rxSizes[0]; i++) {</a>
<a name="ln311">		BufInfo* buf = new(std::nothrow) BufInfo;</a>
<a name="ln312">		if (buf == NULL) {</a>
<a name="ln313">			status = B_NO_MEMORY;</a>
<a name="ln314">			goto err4;</a>
<a name="ln315">		}</a>
<a name="ln316"> </a>
<a name="ln317">		info-&gt;rxBufInfos[i] = buf;</a>
<a name="ln318">		buf-&gt;hdr = (struct virtio_net_hdr*)((addr_t)rxBuffer</a>
<a name="ln319">			+ i * BUFFER_SIZE);</a>
<a name="ln320">		buf-&gt;buffer = (char*)((addr_t)buf-&gt;hdr + sizeof(virtio_net_rx_hdr));</a>
<a name="ln321"> </a>
<a name="ln322">		status = get_memory_map(buf-&gt;buffer,</a>
<a name="ln323">			BUFFER_SIZE - sizeof(virtio_net_rx_hdr), &amp;buf-&gt;entry, 1);</a>
<a name="ln324">		if (status != B_OK)</a>
<a name="ln325">			goto err4;</a>
<a name="ln326"> </a>
<a name="ln327">		status = get_memory_map(buf-&gt;hdr, sizeof(struct virtio_net_hdr),</a>
<a name="ln328">			&amp;buf-&gt;hdrEntry, 1);</a>
<a name="ln329">		if (status != B_OK)</a>
<a name="ln330">			goto err4;</a>
<a name="ln331">	}</a>
<a name="ln332"> </a>
<a name="ln333">	// create transmit buffer area</a>
<a name="ln334">	info-&gt;txArea = create_area(&quot;virtionet tx buffer&quot;, (void**)&amp;txBuffer,</a>
<a name="ln335">		B_ANY_KERNEL_BLOCK_ADDRESS, ROUND_TO_PAGE_SIZE(</a>
<a name="ln336">			BUFFER_SIZE * info-&gt;txSizes[0]),</a>
<a name="ln337">		B_FULL_LOCK, B_KERNEL_READ_AREA | B_KERNEL_WRITE_AREA);</a>
<a name="ln338">	if (info-&gt;txArea &lt; B_OK) {</a>
<a name="ln339">		status = info-&gt;txArea;</a>
<a name="ln340">		goto err5;</a>
<a name="ln341">	}</a>
<a name="ln342"> </a>
<a name="ln343">	// initialize transmit buffer descriptors</a>
<a name="ln344">	for (int i = 0; i &lt; info-&gt;txSizes[0]; i++) {</a>
<a name="ln345">		BufInfo* buf = new(std::nothrow) BufInfo;</a>
<a name="ln346">		if (buf == NULL) {</a>
<a name="ln347">			status = B_NO_MEMORY;</a>
<a name="ln348">			goto err6;</a>
<a name="ln349">		}</a>
<a name="ln350"> </a>
<a name="ln351">		info-&gt;txBufInfos[i] = buf;</a>
<a name="ln352">		buf-&gt;hdr = (struct virtio_net_hdr*)((addr_t)txBuffer</a>
<a name="ln353">			+ i * BUFFER_SIZE);</a>
<a name="ln354">		buf-&gt;buffer = (char*)((addr_t)buf-&gt;hdr + sizeof(virtio_net_tx_hdr));</a>
<a name="ln355"> </a>
<a name="ln356">		status = get_memory_map(buf-&gt;buffer,</a>
<a name="ln357">			BUFFER_SIZE - sizeof(virtio_net_tx_hdr), &amp;buf-&gt;entry, 1);</a>
<a name="ln358">		if (status != B_OK)</a>
<a name="ln359">			goto err6;</a>
<a name="ln360"> </a>
<a name="ln361">		status = get_memory_map(buf-&gt;hdr, sizeof(struct virtio_net_hdr),</a>
<a name="ln362">			&amp;buf-&gt;hdrEntry, 1);</a>
<a name="ln363">		if (status != B_OK)</a>
<a name="ln364">			goto err6;</a>
<a name="ln365"> </a>
<a name="ln366">		info-&gt;txFreeList.Add(buf);</a>
<a name="ln367">	}</a>
<a name="ln368"> </a>
<a name="ln369">	mutex_init(&amp;info-&gt;rxLock, &quot;virtionet rx lock&quot;);</a>
<a name="ln370">	mutex_init(&amp;info-&gt;txLock, &quot;virtionet tx lock&quot;);</a>
<a name="ln371"> </a>
<a name="ln372">	// Setup interrupt</a>
<a name="ln373">	status = info-&gt;virtio-&gt;setup_interrupt(info-&gt;virtio_device, NULL, info);</a>
<a name="ln374">	if (status != B_OK) {</a>
<a name="ln375">		ERROR(&quot;interrupt setup failed (%s)\n&quot;, strerror(status));</a>
<a name="ln376">		goto err6;</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	status = info-&gt;virtio-&gt;queue_setup_interrupt(info-&gt;rxQueues[0],</a>
<a name="ln380">		virtio_net_rxDone, info);</a>
<a name="ln381">	if (status != B_OK) {</a>
<a name="ln382">		ERROR(&quot;queue interrupt setup failed (%s)\n&quot;, strerror(status));</a>
<a name="ln383">		goto err6;</a>
<a name="ln384">	}</a>
<a name="ln385"> </a>
<a name="ln386">	status = info-&gt;virtio-&gt;queue_setup_interrupt(info-&gt;txQueues[0],</a>
<a name="ln387">		virtio_net_txDone, info);</a>
<a name="ln388">	if (status != B_OK) {</a>
<a name="ln389">		ERROR(&quot;queue interrupt setup failed (%s)\n&quot;, strerror(status));</a>
<a name="ln390">		goto err6;</a>
<a name="ln391">	}</a>
<a name="ln392"> </a>
<a name="ln393">	if ((info-&gt;features &amp; VIRTIO_NET_F_CTRL_VQ) != 0) {</a>
<a name="ln394">		status = info-&gt;virtio-&gt;queue_setup_interrupt(info-&gt;ctrlQueue,</a>
<a name="ln395">			NULL, info);</a>
<a name="ln396">		if (status != B_OK) {</a>
<a name="ln397">			ERROR(&quot;queue interrupt setup failed (%s)\n&quot;, strerror(status));</a>
<a name="ln398">			goto err6;</a>
<a name="ln399">		}</a>
<a name="ln400">	}</a>
<a name="ln401"> </a>
<a name="ln402">	*_cookie = info;</a>
<a name="ln403">	return B_OK;</a>
<a name="ln404"> </a>
<a name="ln405">err6:</a>
<a name="ln406">	for (int i = 0; i &lt; info-&gt;txSizes[0]; i++)</a>
<a name="ln407">		delete info-&gt;txBufInfos[i];</a>
<a name="ln408">err5:</a>
<a name="ln409">	delete_area(info-&gt;txArea);</a>
<a name="ln410">err4:</a>
<a name="ln411">	for (int i = 0; i &lt; info-&gt;rxSizes[0]; i++)</a>
<a name="ln412">		delete info-&gt;rxBufInfos[i];</a>
<a name="ln413">err3:</a>
<a name="ln414">	delete_area(info-&gt;rxArea);</a>
<a name="ln415">err2:</a>
<a name="ln416">	delete[] info-&gt;rxBufInfos;</a>
<a name="ln417">	delete[] info-&gt;txBufInfos;</a>
<a name="ln418">err1:</a>
<a name="ln419">	delete[] info-&gt;rxQueues;</a>
<a name="ln420">	delete[] info-&gt;txQueues;</a>
<a name="ln421">	delete[] info-&gt;rxSizes;</a>
<a name="ln422">	delete[] info-&gt;txSizes;</a>
<a name="ln423">	return status;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426"> </a>
<a name="ln427">static void</a>
<a name="ln428">virtio_net_uninit_device(void* _cookie)</a>
<a name="ln429">{</a>
<a name="ln430">	CALLED();</a>
<a name="ln431">	virtio_net_driver_info* info = (virtio_net_driver_info*)_cookie;</a>
<a name="ln432"> </a>
<a name="ln433">	info-&gt;virtio-&gt;free_interrupts(info-&gt;virtio_device);</a>
<a name="ln434"> </a>
<a name="ln435">	mutex_destroy(&amp;info-&gt;rxLock);</a>
<a name="ln436">	mutex_destroy(&amp;info-&gt;txLock);</a>
<a name="ln437"> </a>
<a name="ln438">	while (true) {</a>
<a name="ln439">		BufInfo* buf = info-&gt;txFreeList.RemoveHead();</a>
<a name="ln440">		if (buf == NULL)</a>
<a name="ln441">			break;</a>
<a name="ln442">	}</a>
<a name="ln443"> </a>
<a name="ln444">	for (int i = 0; i &lt; info-&gt;rxSizes[0]; i++) {</a>
<a name="ln445">		delete info-&gt;rxBufInfos[i];</a>
<a name="ln446">	}</a>
<a name="ln447">	for (int i = 0; i &lt; info-&gt;txSizes[0]; i++) {</a>
<a name="ln448">		delete info-&gt;txBufInfos[i];</a>
<a name="ln449">	}</a>
<a name="ln450">	delete_area(info-&gt;rxArea);</a>
<a name="ln451">	delete_area(info-&gt;txArea);</a>
<a name="ln452">	delete[] info-&gt;rxBufInfos;</a>
<a name="ln453">	delete[] info-&gt;txBufInfos;</a>
<a name="ln454">	delete[] info-&gt;rxSizes;</a>
<a name="ln455">	delete[] info-&gt;txSizes;</a>
<a name="ln456">	delete[] info-&gt;rxQueues;</a>
<a name="ln457">	delete[] info-&gt;txQueues;</a>
<a name="ln458"> </a>
<a name="ln459">	info-&gt;virtio-&gt;free_queues(info-&gt;virtio_device);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462"> </a>
<a name="ln463">static status_t</a>
<a name="ln464">virtio_net_open(void* _info, const char* path, int openMode, void** _cookie)</a>
<a name="ln465">{</a>
<a name="ln466">	CALLED();</a>
<a name="ln467">	virtio_net_driver_info* info = (virtio_net_driver_info*)_info;</a>
<a name="ln468"> </a>
<a name="ln469">	virtio_net_handle* handle = (virtio_net_handle*)malloc(</a>
<a name="ln470">		sizeof(virtio_net_handle));</a>
<a name="ln471">	if (handle == NULL)</a>
<a name="ln472">		return B_NO_MEMORY;</a>
<a name="ln473"> </a>
<a name="ln474">	info-&gt;nonblocking = (openMode &amp; O_NONBLOCK) != 0;</a>
<a name="ln475">	info-&gt;maxframesize = MAX_FRAME_SIZE;</a>
<a name="ln476">	info-&gt;rxDone = create_sem(0, &quot;virtio_net_rx&quot;);</a>
<a name="ln477">	info-&gt;txDone = create_sem(1, &quot;virtio_net_tx&quot;);</a>
<a name="ln478">	if (info-&gt;rxDone &lt; B_OK || info-&gt;txDone &lt; B_OK)</a>
<a name="ln479">		goto error;</a>
<a name="ln480">	handle-&gt;info = info;</a>
<a name="ln481"> </a>
<a name="ln482">	if ((info-&gt;features &amp; VIRTIO_NET_F_MAC) != 0) {</a>
<a name="ln483">		info-&gt;virtio-&gt;read_device_config(info-&gt;virtio_device,</a>
<a name="ln484">			offsetof(struct virtio_net_config, mac),</a>
<a name="ln485">			&amp;info-&gt;macaddr, sizeof(info-&gt;macaddr));</a>
<a name="ln486">	}</a>
<a name="ln487"> </a>
<a name="ln488">	for (int i = 0; i &lt; info-&gt;rxSizes[0]; i++)</a>
<a name="ln489">		virtio_net_rx_enqueue_buf(info, info-&gt;rxBufInfos[i]);</a>
<a name="ln490"> </a>
<a name="ln491">	*_cookie = handle;</a>
<a name="ln492">	return B_OK;</a>
<a name="ln493"> </a>
<a name="ln494">error:</a>
<a name="ln495">	delete_sem(info-&gt;rxDone);</a>
<a name="ln496">	delete_sem(info-&gt;txDone);</a>
<a name="ln497">	info-&gt;rxDone = info-&gt;txDone = -1;</a>
<a name="ln498">	free(handle);</a>
<a name="ln499">	return B_ERROR;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">static status_t</a>
<a name="ln504">virtio_net_close(void* cookie)</a>
<a name="ln505">{</a>
<a name="ln506">	virtio_net_handle* handle = (virtio_net_handle*)cookie;</a>
<a name="ln507">	CALLED();</a>
<a name="ln508"> </a>
<a name="ln509">	virtio_net_driver_info* info = handle-&gt;info;</a>
<a name="ln510">	delete_sem(info-&gt;rxDone);</a>
<a name="ln511">	delete_sem(info-&gt;txDone);</a>
<a name="ln512">	info-&gt;rxDone = info-&gt;txDone = -1;</a>
<a name="ln513"> </a>
<a name="ln514">	return B_OK;</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517"> </a>
<a name="ln518">static status_t</a>
<a name="ln519">virtio_net_free(void* cookie)</a>
<a name="ln520">{</a>
<a name="ln521">	CALLED();</a>
<a name="ln522">	virtio_net_handle* handle = (virtio_net_handle*)cookie;</a>
<a name="ln523"> </a>
<a name="ln524">	virtio_net_driver_info* info = handle-&gt;info;</a>
<a name="ln525">	virtio_net_drain_queues(info);</a>
<a name="ln526">	free(handle);</a>
<a name="ln527">	return B_OK;</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530"> </a>
<a name="ln531">static void</a>
<a name="ln532">virtio_net_rxDone(void* driverCookie, void* cookie)</a>
<a name="ln533">{</a>
<a name="ln534">	CALLED();</a>
<a name="ln535">	virtio_net_driver_info* info = (virtio_net_driver_info*)cookie;</a>
<a name="ln536"> </a>
<a name="ln537">	release_sem_etc(info-&gt;rxDone, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540"> </a>
<a name="ln541">static status_t</a>
<a name="ln542">virtio_net_read(void* cookie, off_t pos, void* buffer, size_t* _length)</a>
<a name="ln543">{</a>
<a name="ln544">	CALLED();</a>
<a name="ln545">	virtio_net_handle* handle = (virtio_net_handle*)cookie;</a>
<a name="ln546">	virtio_net_driver_info* info = handle-&gt;info;</a>
<a name="ln547"> </a>
<a name="ln548">	mutex_lock(&amp;info-&gt;rxLock);</a>
<a name="ln549">	while (info-&gt;rxFullList.Head() == NULL) {</a>
<a name="ln550">		mutex_unlock(&amp;info-&gt;rxLock);</a>
<a name="ln551"> </a>
<a name="ln552">		if (info-&gt;nonblocking)</a>
<a name="ln553">			return B_WOULD_BLOCK;</a>
<a name="ln554">		TRACE(&quot;virtio_net_read: waiting\n&quot;);</a>
<a name="ln555">		status_t status = acquire_sem(info-&gt;rxDone);</a>
<a name="ln556">		if (status != B_OK) {</a>
<a name="ln557">			ERROR(&quot;acquire_sem(rxDone) failed (%s)\n&quot;, strerror(status));</a>
<a name="ln558">			return status;</a>
<a name="ln559">		}</a>
<a name="ln560">		int32 semCount = 0;</a>
<a name="ln561">		get_sem_count(info-&gt;rxDone, &amp;semCount);</a>
<a name="ln562">		if (semCount &gt; 0)</a>
<a name="ln563">			acquire_sem_etc(info-&gt;rxDone, semCount, B_RELATIVE_TIMEOUT, 0);</a>
<a name="ln564"> </a>
<a name="ln565">		mutex_lock(&amp;info-&gt;rxLock);</a>
<a name="ln566">		while (info-&gt;rxDone != -1) {</a>
<a name="ln567">			uint32 usedLength = 0;</a>
<a name="ln568">			BufInfo* buf = (BufInfo*)info-&gt;virtio-&gt;queue_dequeue(</a>
<a name="ln569">				info-&gt;rxQueues[0], &amp;usedLength);</a>
<a name="ln570">			if (buf == NULL)</a>
<a name="ln571">				break;</a>
<a name="ln572"> </a>
<a name="ln573">			buf-&gt;rxUsedLength = usedLength;</a>
<a name="ln574">			info-&gt;rxFullList.Add(buf);</a>
<a name="ln575">		}</a>
<a name="ln576">		TRACE(&quot;virtio_net_read: finished waiting\n&quot;);</a>
<a name="ln577">	}</a>
<a name="ln578"> </a>
<a name="ln579">	BufInfo* buf = info-&gt;rxFullList.RemoveHead();</a>
<a name="ln580">	*_length = MIN(buf-&gt;rxUsedLength, *_length);</a>
<a name="ln581">	memcpy(buffer, buf-&gt;buffer, *_length);</a>
<a name="ln582">	virtio_net_rx_enqueue_buf(info, buf);</a>
<a name="ln583">	mutex_unlock(&amp;info-&gt;rxLock);</a>
<a name="ln584">	return B_OK;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">static void</a>
<a name="ln589">virtio_net_txDone(void* driverCookie, void* cookie)</a>
<a name="ln590">{</a>
<a name="ln591">	CALLED();</a>
<a name="ln592">	virtio_net_driver_info* info = (virtio_net_driver_info*)cookie;</a>
<a name="ln593"> </a>
<a name="ln594">	release_sem_etc(info-&gt;txDone, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597"> </a>
<a name="ln598">static status_t</a>
<a name="ln599">virtio_net_write(void* cookie, off_t pos, const void* buffer,</a>
<a name="ln600">	size_t* _length)</a>
<a name="ln601">{</a>
<a name="ln602">	CALLED();</a>
<a name="ln603">	virtio_net_handle* handle = (virtio_net_handle*)cookie;</a>
<a name="ln604">	virtio_net_driver_info* info = handle-&gt;info;</a>
<a name="ln605"> </a>
<a name="ln606">	mutex_lock(&amp;info-&gt;txLock);</a>
<a name="ln607">	while (info-&gt;txFreeList.Head() == NULL) {</a>
<a name="ln608">		mutex_unlock(&amp;info-&gt;txLock);</a>
<a name="ln609">		if (info-&gt;nonblocking)</a>
<a name="ln610">			return B_WOULD_BLOCK;</a>
<a name="ln611"> </a>
<a name="ln612">		status_t status = acquire_sem(info-&gt;txDone);</a>
<a name="ln613">		if (status != B_OK) {</a>
<a name="ln614">			ERROR(&quot;acquire_sem(txDone) failed (%s)\n&quot;, strerror(status));</a>
<a name="ln615">			return status;</a>
<a name="ln616">		}</a>
<a name="ln617"> </a>
<a name="ln618">		int32 semCount = 0;</a>
<a name="ln619">		get_sem_count(info-&gt;txDone, &amp;semCount);</a>
<a name="ln620">		if (semCount &gt; 0)</a>
<a name="ln621">			acquire_sem_etc(info-&gt;txDone, semCount, B_RELATIVE_TIMEOUT, 0);</a>
<a name="ln622"> </a>
<a name="ln623">		mutex_lock(&amp;info-&gt;txLock);</a>
<a name="ln624">		while (info-&gt;txDone != -1) {</a>
<a name="ln625">			BufInfo* buf = (BufInfo*)info-&gt;virtio-&gt;queue_dequeue(</a>
<a name="ln626">				info-&gt;txQueues[0], NULL);</a>
<a name="ln627">			if (buf == NULL)</a>
<a name="ln628">				break;</a>
<a name="ln629">			info-&gt;txFreeList.Add(buf);</a>
<a name="ln630">		}</a>
<a name="ln631">	}</a>
<a name="ln632">	BufInfo* buf = info-&gt;txFreeList.RemoveHead();</a>
<a name="ln633"> </a>
<a name="ln634">	TRACE(&quot;virtio_net_write: copying %lu\n&quot;, MIN(MAX_FRAME_SIZE, *_length));</a>
<a name="ln635">	memcpy(buf-&gt;buffer, buffer, MIN(MAX_FRAME_SIZE, *_length));</a>
<a name="ln636">	memset(buf-&gt;hdr, 0, sizeof(virtio_net_hdr));</a>
<a name="ln637"> </a>
<a name="ln638">	physical_entry entries[2];</a>
<a name="ln639">	entries[0] = buf-&gt;hdrEntry;</a>
<a name="ln640">	entries[0].size = sizeof(virtio_net_hdr);</a>
<a name="ln641">	entries[1] = buf-&gt;entry;</a>
<a name="ln642">	entries[1].size = MIN(MAX_FRAME_SIZE, *_length);</a>
<a name="ln643"> </a>
<a name="ln644">	// queue the virtio_net_hdr + buffer data</a>
<a name="ln645">	status_t status = info-&gt;virtio-&gt;queue_request_v(info-&gt;txQueues[0],</a>
<a name="ln646">		entries, 2, 0, buf);</a>
<a name="ln647">	mutex_unlock(&amp;info-&gt;txLock);</a>
<a name="ln648">	if (status != B_OK) {</a>
<a name="ln649">		ERROR(&quot;tx queueing on queue %d failed (%s)\n&quot;, 0, strerror(status));</a>
<a name="ln650">		return status;</a>
<a name="ln651">	}</a>
<a name="ln652"> </a>
<a name="ln653">	return B_OK;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656"> </a>
<a name="ln657">static status_t</a>
<a name="ln658">virtio_net_ioctl(void* cookie, uint32 op, void* buffer, size_t length)</a>
<a name="ln659">{</a>
<a name="ln660">	// CALLED();</a>
<a name="ln661">	virtio_net_handle* handle = (virtio_net_handle*)cookie;</a>
<a name="ln662">	virtio_net_driver_info* info = handle-&gt;info;</a>
<a name="ln663"> </a>
<a name="ln664">	// TRACE(&quot;ioctl(op = %lx)\n&quot;, op);</a>
<a name="ln665"> </a>
<a name="ln666">	switch (op) {</a>
<a name="ln667">		case ETHER_GETADDR:</a>
<a name="ln668">			TRACE(&quot;ioctl: get macaddr\n&quot;);</a>
<a name="ln669">			memcpy(buffer, &amp;info-&gt;macaddr, sizeof(info-&gt;macaddr));</a>
<a name="ln670">			return B_OK;</a>
<a name="ln671"> </a>
<a name="ln672">		case ETHER_INIT:</a>
<a name="ln673">			TRACE(&quot;ioctl: init\n&quot;);</a>
<a name="ln674">			return B_OK;</a>
<a name="ln675"> </a>
<a name="ln676">		case ETHER_GETFRAMESIZE:</a>
<a name="ln677">			TRACE(&quot;ioctl: get frame size\n&quot;);</a>
<a name="ln678">			*(uint32*)buffer = info-&gt;maxframesize;</a>
<a name="ln679">			return B_OK;</a>
<a name="ln680"> </a>
<a name="ln681">		case ETHER_SETPROMISC:</a>
<a name="ln682">			TRACE(&quot;ioctl: set promisc\n&quot;);</a>
<a name="ln683">			break;</a>
<a name="ln684"> </a>
<a name="ln685">		case ETHER_NONBLOCK:</a>
<a name="ln686">			info-&gt;nonblocking = *(int32*)buffer == 0;</a>
<a name="ln687">			TRACE(&quot;ioctl: non blocking ? %s\n&quot;, info-&gt;nonblocking ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln688">			return B_OK;</a>
<a name="ln689"> </a>
<a name="ln690">		case ETHER_ADDMULTI:</a>
<a name="ln691">			TRACE(&quot;ioctl: add multicast\n&quot;);</a>
<a name="ln692">			break;</a>
<a name="ln693"> </a>
<a name="ln694">		case ETHER_REMMULTI:</a>
<a name="ln695">			TRACE(&quot;ioctl: remove multicast\n&quot;);</a>
<a name="ln696">			break;</a>
<a name="ln697"> </a>
<a name="ln698">		case ETHER_GET_LINK_STATE:</a>
<a name="ln699">		{</a>
<a name="ln700">			TRACE(&quot;ioctl: get link state\n&quot;);</a>
<a name="ln701">			ether_link_state_t state;</a>
<a name="ln702">			uint16 status = VIRTIO_NET_S_LINK_UP;</a>
<a name="ln703">			if ((info-&gt;features &amp; VIRTIO_NET_F_STATUS) != 0) {</a>
<a name="ln704">				info-&gt;virtio-&gt;read_device_config(info-&gt;virtio_device,</a>
<a name="ln705">					offsetof(struct virtio_net_config, status),</a>
<a name="ln706">					&amp;status, sizeof(status));</a>
<a name="ln707">			}</a>
<a name="ln708">			state.media = ((status &amp; VIRTIO_NET_S_LINK_UP) != 0 ? IFM_ACTIVE : 0)</a>
<a name="ln709">				| IFM_ETHER | IFM_FULL_DUPLEX | IFM_10G_T;</a>
<a name="ln710">			state.speed = 10000000000ULL;</a>
<a name="ln711">			state.quality = 1000;</a>
<a name="ln712"> </a>
<a name="ln713">			return user_memcpy(buffer, &amp;state, sizeof(ether_link_state_t));</a>
<a name="ln714">		}</a>
<a name="ln715"> </a>
<a name="ln716">		default:</a>
<a name="ln717">			ERROR(&quot;ioctl: unknown message %&quot; B_PRIx32 &quot;\n&quot;, op);</a>
<a name="ln718">			break;</a>
<a name="ln719">	}</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">	return B_DEV_INVALID_IOCTL;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725"> </a>
<a name="ln726">//	#pragma mark - driver module API</a>
<a name="ln727"> </a>
<a name="ln728"> </a>
<a name="ln729">static float</a>
<a name="ln730">virtio_net_supports_device(device_node* parent)</a>
<a name="ln731">{</a>
<a name="ln732">	CALLED();</a>
<a name="ln733">	const char* bus;</a>
<a name="ln734">	uint16 deviceType;</a>
<a name="ln735"> </a>
<a name="ln736">	// make sure parent is really the Virtio bus manager</a>
<a name="ln737">	if (sDeviceManager-&gt;get_attr_string(parent, B_DEVICE_BUS, &amp;bus, false))</a>
<a name="ln738">		return -1;</a>
<a name="ln739"> </a>
<a name="ln740">	if (strcmp(bus, &quot;virtio&quot;))</a>
<a name="ln741">		return 0.0;</a>
<a name="ln742"> </a>
<a name="ln743">	// check whether it's really a Direct Access Device</a>
<a name="ln744">	if (sDeviceManager-&gt;get_attr_uint16(parent, VIRTIO_DEVICE_TYPE_ITEM,</a>
<a name="ln745">			&amp;deviceType, true) != B_OK || deviceType != VIRTIO_DEVICE_ID_NETWORK)</a>
<a name="ln746">		return 0.0;</a>
<a name="ln747"> </a>
<a name="ln748">	TRACE(&quot;Virtio network device found!\n&quot;);</a>
<a name="ln749"> </a>
<a name="ln750">	return 0.6;</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753"> </a>
<a name="ln754">static status_t</a>
<a name="ln755">virtio_net_register_device(device_node* node)</a>
<a name="ln756">{</a>
<a name="ln757">	CALLED();</a>
<a name="ln758"> </a>
<a name="ln759">	// ready to register</a>
<a name="ln760">	device_attr attrs[] = {</a>
<a name="ln761">		{ NULL }</a>
<a name="ln762">	};</a>
<a name="ln763"> </a>
<a name="ln764">	return sDeviceManager-&gt;register_node(node, VIRTIO_NET_DRIVER_MODULE_NAME,</a>
<a name="ln765">		attrs, NULL, NULL);</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">static status_t</a>
<a name="ln770">virtio_net_init_driver(device_node* node, void** cookie)</a>
<a name="ln771">{</a>
<a name="ln772">	CALLED();</a>
<a name="ln773"> </a>
<a name="ln774">	virtio_net_driver_info* info = (virtio_net_driver_info*)malloc(</a>
<a name="ln775">		sizeof(virtio_net_driver_info));</a>
<a name="ln776">	if (info == NULL)</a>
<a name="ln777">		return B_NO_MEMORY;</a>
<a name="ln778"> </a>
<a name="ln779">	memset(info, 0, sizeof(*info));</a>
<a name="ln780"> </a>
<a name="ln781">	info-&gt;node = node;</a>
<a name="ln782"> </a>
<a name="ln783">	*cookie = info;</a>
<a name="ln784">	return B_OK;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787"> </a>
<a name="ln788">static void</a>
<a name="ln789">virtio_net_uninit_driver(void* _cookie)</a>
<a name="ln790">{</a>
<a name="ln791">	CALLED();</a>
<a name="ln792">	virtio_net_driver_info* info = (virtio_net_driver_info*)_cookie;</a>
<a name="ln793">	free(info);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796"> </a>
<a name="ln797">static status_t</a>
<a name="ln798">virtio_net_register_child_devices(void* _cookie)</a>
<a name="ln799">{</a>
<a name="ln800">	CALLED();</a>
<a name="ln801">	virtio_net_driver_info* info = (virtio_net_driver_info*)_cookie;</a>
<a name="ln802">	status_t status;</a>
<a name="ln803"> </a>
<a name="ln804">	int32 id = sDeviceManager-&gt;create_id(VIRTIO_NET_DEVICE_ID_GENERATOR);</a>
<a name="ln805">	if (id &lt; 0)</a>
<a name="ln806">		return id;</a>
<a name="ln807"> </a>
<a name="ln808">	char name[64];</a>
<a name="ln809">	snprintf(name, sizeof(name), &quot;net/virtio/%&quot; B_PRId32,</a>
<a name="ln810">		id);</a>
<a name="ln811"> </a>
<a name="ln812">	status = sDeviceManager-&gt;publish_device(info-&gt;node, name,</a>
<a name="ln813">		VIRTIO_NET_DEVICE_MODULE_NAME);</a>
<a name="ln814"> </a>
<a name="ln815">	return status;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818"> </a>
<a name="ln819">//	#pragma mark -</a>
<a name="ln820"> </a>
<a name="ln821"> </a>
<a name="ln822">module_dependency module_dependencies[] = {</a>
<a name="ln823">	{B_DEVICE_MANAGER_MODULE_NAME, (module_info**)&amp;sDeviceManager},</a>
<a name="ln824">	{}</a>
<a name="ln825">};</a>
<a name="ln826"> </a>
<a name="ln827">struct device_module_info sVirtioNetDevice = {</a>
<a name="ln828">	{</a>
<a name="ln829">		VIRTIO_NET_DEVICE_MODULE_NAME,</a>
<a name="ln830">		0,</a>
<a name="ln831">		NULL</a>
<a name="ln832">	},</a>
<a name="ln833"> </a>
<a name="ln834">	virtio_net_init_device,</a>
<a name="ln835">	virtio_net_uninit_device,</a>
<a name="ln836">	NULL, // remove,</a>
<a name="ln837"> </a>
<a name="ln838">	virtio_net_open,</a>
<a name="ln839">	virtio_net_close,</a>
<a name="ln840">	virtio_net_free,</a>
<a name="ln841">	virtio_net_read,</a>
<a name="ln842">	virtio_net_write,</a>
<a name="ln843">	NULL,	// io</a>
<a name="ln844">	virtio_net_ioctl,</a>
<a name="ln845"> </a>
<a name="ln846">	NULL,	// select</a>
<a name="ln847">	NULL,	// deselect</a>
<a name="ln848">};</a>
<a name="ln849"> </a>
<a name="ln850">struct driver_module_info sVirtioNetDriver = {</a>
<a name="ln851">	{</a>
<a name="ln852">		VIRTIO_NET_DRIVER_MODULE_NAME,</a>
<a name="ln853">		0,</a>
<a name="ln854">		NULL</a>
<a name="ln855">	},</a>
<a name="ln856"> </a>
<a name="ln857">	virtio_net_supports_device,</a>
<a name="ln858">	virtio_net_register_device,</a>
<a name="ln859">	virtio_net_init_driver,</a>
<a name="ln860">	virtio_net_uninit_driver,</a>
<a name="ln861">	virtio_net_register_child_devices,</a>
<a name="ln862">	NULL,	// rescan</a>
<a name="ln863">	NULL,	// removed</a>
<a name="ln864">};</a>
<a name="ln865"> </a>
<a name="ln866">module_info* modules[] = {</a>
<a name="ln867">	(module_info*)&amp;sVirtioNetDriver,</a>
<a name="ln868">	(module_info*)&amp;sVirtioNetDevice,</a>
<a name="ln869">	NULL</a>
<a name="ln870">};</a>

</code></pre>
<div class="balloon" rel="774"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors and destructors.</p></div>
<div class="balloon" rel="297"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v579/" target="_blank">V579</a> The memset function receives the pointer and its size as arguments. It is possibly a mistake. Inspect the third argument.</p></div>
<div class="balloon" rel="296"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v579/" target="_blank">V579</a> The memset function receives the pointer and its size as arguments. It is possibly a mistake. Inspect the third argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
