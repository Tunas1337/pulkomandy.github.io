
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>FindPanel.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;FindPanel.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;utility&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;errno.h&gt;</a>
<a name="ln41">#include &lt;fs_attr.h&gt;</a>
<a name="ln42">#include &lt;parsedate.h&gt;</a>
<a name="ln43">#include &lt;stdlib.h&gt;</a>
<a name="ln44">#include &lt;string.h&gt;</a>
<a name="ln45">#include &lt;strings.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;Application.h&gt;</a>
<a name="ln48">#include &lt;Box.h&gt;</a>
<a name="ln49">#include &lt;Button.h&gt;</a>
<a name="ln50">#include &lt;Catalog.h&gt;</a>
<a name="ln51">#include &lt;CheckBox.h&gt;</a>
<a name="ln52">#include &lt;ControlLook.h&gt;</a>
<a name="ln53">#include &lt;Debug.h&gt;</a>
<a name="ln54">#include &lt;Directory.h&gt;</a>
<a name="ln55">#include &lt;FindDirectory.h&gt;</a>
<a name="ln56">#include &lt;File.h&gt;</a>
<a name="ln57">#include &lt;FilePanel.h&gt;</a>
<a name="ln58">#include &lt;GroupLayout.h&gt;</a>
<a name="ln59">#include &lt;InterfaceDefs.h&gt;</a>
<a name="ln60">#include &lt;LayoutBuilder.h&gt;</a>
<a name="ln61">#include &lt;Locale.h&gt;</a>
<a name="ln62">#include &lt;MenuField.h&gt;</a>
<a name="ln63">#include &lt;MenuItem.h&gt;</a>
<a name="ln64">#include &lt;Mime.h&gt;</a>
<a name="ln65">#include &lt;NodeInfo.h&gt;</a>
<a name="ln66">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln67">#include &lt;Path.h&gt;</a>
<a name="ln68">#include &lt;Query.h&gt;</a>
<a name="ln69">#include &lt;SeparatorView.h&gt;</a>
<a name="ln70">#include &lt;Size.h&gt;</a>
<a name="ln71">#include &lt;SpaceLayoutItem.h&gt;</a>
<a name="ln72">#include &lt;TextControl.h&gt;</a>
<a name="ln73">#include &lt;TextView.h&gt;</a>
<a name="ln74">#include &lt;View.h&gt;</a>
<a name="ln75">#include &lt;Volume.h&gt;</a>
<a name="ln76">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln77"> </a>
<a name="ln78">#include &quot;Attributes.h&quot;</a>
<a name="ln79">#include &quot;AutoLock.h&quot;</a>
<a name="ln80">#include &quot;Commands.h&quot;</a>
<a name="ln81">#include &quot;ContainerWindow.h&quot;</a>
<a name="ln82">#include &quot;FSUtils.h&quot;</a>
<a name="ln83">#include &quot;FunctionObject.h&quot;</a>
<a name="ln84">#include &quot;IconMenuItem.h&quot;</a>
<a name="ln85">#include &quot;MimeTypes.h&quot;</a>
<a name="ln86">#include &quot;Tracker.h&quot;</a>
<a name="ln87"> </a>
<a name="ln88"> </a>
<a name="ln89">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln90">#define B_TRANSLATION_CONTEXT &quot;FindPanel&quot;</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">const char* kAllMimeTypes = &quot;mime/ALLTYPES&quot;;</a>
<a name="ln94"> </a>
<a name="ln95">const uint32 kNameModifiedMessage = 'nmmd';</a>
<a name="ln96">const uint32 kSwitchToQueryTemplate = 'swqt';</a>
<a name="ln97">const uint32 kRunSaveAsTemplatePanel = 'svtm';</a>
<a name="ln98">const uint32 kLatchChanged = 'ltch';</a>
<a name="ln99"> </a>
<a name="ln100">const char* kDragNDropTypes[] = {</a>
<a name="ln101">	B_QUERY_MIMETYPE,</a>
<a name="ln102">	B_QUERY_TEMPLATE_MIMETYPE</a>
<a name="ln103">};</a>
<a name="ln104">static const char* kDragNDropActionSpecifiers[] = {</a>
<a name="ln105">	B_TRANSLATE_MARK(&quot;Create a Query&quot;),</a>
<a name="ln106">	B_TRANSLATE_MARK(&quot;Create a Query template&quot;)</a>
<a name="ln107">};</a>
<a name="ln108"> </a>
<a name="ln109">const uint32 kAttachFile = 'attf';</a>
<a name="ln110"> </a>
<a name="ln111">const int32 operators[] = {</a>
<a name="ln112">	B_CONTAINS,</a>
<a name="ln113">	B_EQ,</a>
<a name="ln114">	B_NE,</a>
<a name="ln115">	B_BEGINS_WITH,</a>
<a name="ln116">	B_ENDS_WITH,</a>
<a name="ln117">	B_GE,</a>
<a name="ln118">	B_LE</a>
<a name="ln119">};</a>
<a name="ln120"> </a>
<a name="ln121">static const char* operatorLabels[] = {</a>
<a name="ln122">	B_TRANSLATE_MARK(&quot;contains&quot;),</a>
<a name="ln123">	B_TRANSLATE_MARK(&quot;is&quot;),</a>
<a name="ln124">	B_TRANSLATE_MARK(&quot;is not&quot;),</a>
<a name="ln125">	B_TRANSLATE_MARK(&quot;starts with&quot;),</a>
<a name="ln126">	B_TRANSLATE_MARK(&quot;ends with&quot;),</a>
<a name="ln127">	B_TRANSLATE_MARK(&quot;greater than&quot;),</a>
<a name="ln128">	B_TRANSLATE_MARK(&quot;less than&quot;),</a>
<a name="ln129">	B_TRANSLATE_MARK(&quot;before&quot;),</a>
<a name="ln130">	B_TRANSLATE_MARK(&quot;after&quot;)</a>
<a name="ln131">};</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">namespace BPrivate {</a>
<a name="ln135"> </a>
<a name="ln136">class MostUsedNames {</a>
<a name="ln137">	public:</a>
<a name="ln138">		MostUsedNames(const char* fileName, const char* directory,</a>
<a name="ln139">			int32 maxCount = 5);</a>
<a name="ln140">		~MostUsedNames();</a>
<a name="ln141"> </a>
<a name="ln142">		bool ObtainList(BList* list);</a>
<a name="ln143">		void ReleaseList();</a>
<a name="ln144"> </a>
<a name="ln145">		void AddName(const char*);</a>
<a name="ln146"> </a>
<a name="ln147">	protected:</a>
<a name="ln148">		struct list_entry {</a>
<a name="ln149">			char* name;</a>
<a name="ln150">			int32 count;</a>
<a name="ln151">		};</a>
<a name="ln152"> </a>
<a name="ln153">		static int CompareNames(const void* a, const void* b);</a>
<a name="ln154">		void LoadList();</a>
<a name="ln155">		void UpdateList();</a>
<a name="ln156"> </a>
<a name="ln157">		const char*	fFileName;</a>
<a name="ln158">		const char*	fDirectory;</a>
<a name="ln159">		bool		fLoaded;</a>
<a name="ln160">		mutable Benaphore fLock;</a>
<a name="ln161">		BList		fList;</a>
<a name="ln162">		int32		fCount;</a>
<a name="ln163">};</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">MostUsedNames gMostUsedMimeTypes(&quot;MostUsedMimeTypes&quot;, &quot;Tracker&quot;);</a>
<a name="ln167"> </a>
<a name="ln168"> </a>
<a name="ln169">//	#pragma mark - MoreOptionsStruct</a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172">void</a>
<a name="ln173">MoreOptionsStruct::EndianSwap(void*)</a>
<a name="ln174">{</a>
<a name="ln175">	// noop for now</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">void</a>
<a name="ln180">MoreOptionsStruct::SetQueryTemporary(BNode* node, bool on)</a>
<a name="ln181">{</a>
<a name="ln182">	MoreOptionsStruct saveMoreOptions;</a>
<a name="ln183"> </a>
<a name="ln184">	if (ReadAttr(node, kAttrQueryMoreOptions, kAttrQueryMoreOptionsForeign,</a>
<a name="ln185">			B_RAW_TYPE, 0, &amp;saveMoreOptions, sizeof(MoreOptionsStruct),</a>
<a name="ln186">			&amp;MoreOptionsStruct::EndianSwap) == B_OK) {</a>
<a name="ln187">		saveMoreOptions.temporary = on;</a>
<a name="ln188">		node-&gt;WriteAttr(kAttrQueryMoreOptions, B_RAW_TYPE, 0, &amp;saveMoreOptions,</a>
<a name="ln189">			sizeof(saveMoreOptions));</a>
<a name="ln190">	}</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">bool</a>
<a name="ln195">MoreOptionsStruct::QueryTemporary(const BNode* node)</a>
<a name="ln196">{</a>
<a name="ln197">	MoreOptionsStruct saveMoreOptions;</a>
<a name="ln198"> </a>
<a name="ln199">	if (ReadAttr(node, kAttrQueryMoreOptions, kAttrQueryMoreOptionsForeign,</a>
<a name="ln200">		B_RAW_TYPE, 0, &amp;saveMoreOptions, sizeof(MoreOptionsStruct),</a>
<a name="ln201">		&amp;MoreOptionsStruct::EndianSwap) == kReadAttrFailed) {</a>
<a name="ln202">		return false;</a>
<a name="ln203">	}</a>
<a name="ln204"> </a>
<a name="ln205">	return saveMoreOptions.temporary;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208"> </a>
<a name="ln209">//	#pragma mark - FindWindow</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">FindWindow::FindWindow(const entry_ref* newRef, bool editIfTemplateOnly)</a>
<a name="ln213">	:</a>
<a name="ln214">	BWindow(BRect(), B_TRANSLATE(&quot;Find&quot;), B_TITLED_WINDOW,</a>
<a name="ln215">		B_NOT_RESIZABLE | B_NOT_ZOOMABLE | B_CLOSE_ON_ESCAPE</a>
<a name="ln216">			| B_AUTO_UPDATE_SIZE_LIMITS),</a>
<a name="ln217">	fFile(TryOpening(newRef)),</a>
<a name="ln218">	fFromTemplate(false),</a>
<a name="ln219">	fEditTemplateOnly(false),</a>
<a name="ln220">	fSaveAsTemplatePanel(NULL)</a>
<a name="ln221">{</a>
<a name="ln222">	if (fFile != NULL) {</a>
<a name="ln223">		fRef = *newRef;</a>
<a name="ln224">		if (editIfTemplateOnly) {</a>
<a name="ln225">			char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln226">			if (BNodeInfo(fFile).GetType(type) == B_OK</a>
<a name="ln227">				&amp;&amp; strcasecmp(type, B_QUERY_TEMPLATE_MIMETYPE) == 0) {</a>
<a name="ln228">				fEditTemplateOnly = true;</a>
<a name="ln229">				SetTitle(B_TRANSLATE(&quot;Edit Query template&quot;));</a>
<a name="ln230">			}</a>
<a name="ln231">		}</a>
<a name="ln232">	} else {</a>
<a name="ln233">		// no initial query, fall back on the default query template</a>
<a name="ln234">		BEntry entry;</a>
<a name="ln235">		GetDefaultQuery(entry);</a>
<a name="ln236">		entry.GetRef(&amp;fRef);</a>
<a name="ln237"> </a>
<a name="ln238">		if (entry.Exists())</a>
<a name="ln239">			fFile = TryOpening(&amp;fRef);</a>
<a name="ln240">		else {</a>
<a name="ln241">			// no default query template yet</a>
<a name="ln242">			fFile = new BFile(&amp;entry, O_RDWR | O_CREAT);</a>
<a name="ln243">			if (fFile-&gt;InitCheck() &lt; B_OK) {</a>
<a name="ln244">				delete fFile;</a>
<a name="ln245">				fFile = NULL;</a>
<a name="ln246">			} else</a>
<a name="ln247">				SaveQueryAttributes(fFile, true);</a>
<a name="ln248">		}</a>
<a name="ln249">	}</a>
<a name="ln250"> </a>
<a name="ln251">	fFromTemplate = IsQueryTemplate(fFile);</a>
<a name="ln252"> </a>
<a name="ln253">	fBackground = new FindPanel(fFile, this, fFromTemplate,</a>
<a name="ln254">		fEditTemplateOnly);</a>
<a name="ln255">	SetLayout(new BGroupLayout(B_VERTICAL));</a>
<a name="ln256">	GetLayout()-&gt;AddView(fBackground);</a>
<a name="ln257">	CenterOnScreen();</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260"> </a>
<a name="ln261">FindWindow::~FindWindow()</a>
<a name="ln262">{</a>
<a name="ln263">	delete fFile;</a>
<a name="ln264">	delete fSaveAsTemplatePanel;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267"> </a>
<a name="ln268">BFile*</a>
<a name="ln269">FindWindow::TryOpening(const entry_ref* ref)</a>
<a name="ln270">{</a>
<a name="ln271">	if (!ref)</a>
<a name="ln272">		return NULL;</a>
<a name="ln273"> </a>
<a name="ln274">	BFile* result = new BFile(ref, O_RDWR);</a>
<a name="ln275">	if (result-&gt;InitCheck() != B_OK) {</a>
<a name="ln276">		delete result;</a>
<a name="ln277">		result = NULL;</a>
<a name="ln278">	}</a>
<a name="ln279">	return result;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282"> </a>
<a name="ln283">void</a>
<a name="ln284">FindWindow::GetDefaultQuery(BEntry&amp; entry)</a>
<a name="ln285">{</a>
<a name="ln286">	BPath path;</a>
<a name="ln287">	if (find_directory(B_USER_DIRECTORY, &amp;path, true) == B_OK</a>
<a name="ln288">		&amp;&amp; path.Append(&quot;queries&quot;) == B_OK</a>
<a name="ln289">		&amp;&amp; (mkdir(path.Path(), 0777) == 0 || errno == EEXIST)) {</a>
<a name="ln290">		BDirectory directory(path.Path());</a>
<a name="ln291">		entry.SetTo(&amp;directory, &quot;default&quot;);</a>
<a name="ln292">	}</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">bool</a>
<a name="ln297">FindWindow::IsQueryTemplate(BNode* file)</a>
<a name="ln298">{</a>
<a name="ln299">	char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln300">	if (BNodeInfo(file).GetType(type) != B_OK)</a>
<a name="ln301">		return false;</a>
<a name="ln302"> </a>
<a name="ln303">	return strcasecmp(type, B_QUERY_TEMPLATE_MIMETYPE) == 0;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">void</a>
<a name="ln308">FindWindow::SwitchToTemplate(const entry_ref* ref)</a>
<a name="ln309">{</a>
<a name="ln310">	try {</a>
<a name="ln311">		BEntry entry(ref, true);</a>
<a name="ln312">		BFile templateFile(&amp;entry, O_RDONLY);</a>
<a name="ln313"> </a>
<a name="ln314">		ThrowOnInitCheckError(&amp;templateFile);</a>
<a name="ln315">		fBackground-&gt;SwitchToTemplate(&amp;templateFile);</a>
<a name="ln316">	} catch (...) {</a>
<a name="ln317">		;</a>
<a name="ln318">	}</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321"> </a>
<a name="ln322">const char*</a>
<a name="ln323">FindWindow::QueryName() const</a>
<a name="ln324">{</a>
<a name="ln325">	if (fFromTemplate) {</a>
<a name="ln326">		if (!fQueryNameFromTemplate.Length()) {</a>
<a name="ln327">			fFile-&gt;ReadAttrString(kAttrQueryTemplateName,</a>
<a name="ln328">				&amp;fQueryNameFromTemplate);</a>
<a name="ln329">		}</a>
<a name="ln330"> </a>
<a name="ln331">		return fQueryNameFromTemplate.String();</a>
<a name="ln332">	}</a>
<a name="ln333">	if (!fFile)</a>
<a name="ln334">		return &quot;&quot;;</a>
<a name="ln335"> </a>
<a name="ln336">	return fRef.name;</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339"> </a>
<a name="ln340">static const char*</a>
<a name="ln341">MakeValidFilename(BString&amp; string)</a>
<a name="ln342">{</a>
<a name="ln343">	// make a file name that is legal under bfs and hfs - possibly could</a>
<a name="ln344">	// add code here to accomodate FAT32 etc. too</a>
<a name="ln345">	if (string.Length() &gt; B_FILE_NAME_LENGTH - 1) {</a>
<a name="ln346">		string.Truncate(B_FILE_NAME_LENGTH - 4);</a>
<a name="ln347">		string += B_UTF8_ELLIPSIS;</a>
<a name="ln348">	}</a>
<a name="ln349"> </a>
<a name="ln350">	// replace slashes</a>
<a name="ln351">	int32 length = string.Length();</a>
<a name="ln352">	char* buf = string.LockBuffer(length);</a>
<a name="ln353">	for (int32 index = length; index-- &gt; 0;) {</a>
<a name="ln354">		if (buf[index] == '/' /*|| buf[index] == ':'*/)</a>
<a name="ln355">			buf[index] = '_';</a>
<a name="ln356">	}</a>
<a name="ln357">	string.UnlockBuffer(length);</a>
<a name="ln358"> </a>
<a name="ln359">	return string.String();</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">void</a>
<a name="ln364">FindWindow::GetPredicateString(BString&amp; predicate, bool&amp; dynamicDate)</a>
<a name="ln365">{</a>
<a name="ln366">	BQuery query;</a>
<a name="ln367">	switch (fBackground-&gt;Mode()) {</a>
<a name="ln368">		case kByNameItem:</a>
<a name="ln369">			fBackground-&gt;GetByNamePredicate(&amp;query);</a>
<a name="ln370">			query.GetPredicate(&amp;predicate);</a>
<a name="ln371">			break;</a>
<a name="ln372"> </a>
<a name="ln373">		case kByFormulaItem:</a>
<a name="ln374">		{</a>
<a name="ln375">			BTextControl* textControl</a>
<a name="ln376">				= dynamic_cast&lt;BTextControl*&gt;(FindView(&quot;TextControl&quot;));</a>
<a name="ln377">			if (textControl != NULL)</a>
<a name="ln378">				predicate.SetTo(textControl-&gt;Text(), 1023);</a>
<a name="ln379">			break;</a>
<a name="ln380">		}</a>
<a name="ln381"> </a>
<a name="ln382">		case kByAttributeItem:</a>
<a name="ln383">			fBackground-&gt;GetByAttrPredicate(&amp;query, dynamicDate);</a>
<a name="ln384">			query.GetPredicate(&amp;predicate);</a>
<a name="ln385">			break;</a>
<a name="ln386">	}</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">void</a>
<a name="ln391">FindWindow::GetDefaultName(BString&amp; name)</a>
<a name="ln392">{</a>
<a name="ln393">	fBackground-&gt;GetDefaultName(name);</a>
<a name="ln394"> </a>
<a name="ln395">	time_t timeValue = time(0);</a>
<a name="ln396">	char namebuf[B_FILE_NAME_LENGTH];</a>
<a name="ln397"> </a>
<a name="ln398">	tm timeData;</a>
<a name="ln399">	localtime_r(&amp;timeValue, &amp;timeData);</a>
<a name="ln400"> </a>
<a name="ln401">	strftime(namebuf, 32, &quot; - %b %d, %I:%M:%S %p&quot;, &amp;timeData);</a>
<a name="ln402">	name &lt;&lt; namebuf;</a>
<a name="ln403"> </a>
<a name="ln404">	MakeValidFilename(name);</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">void</a>
<a name="ln409">FindWindow::SaveQueryAttributes(BNode* file, bool queryTemplate)</a>
<a name="ln410">{</a>
<a name="ln411">	ThrowOnError(BNodeInfo(file).SetType(</a>
<a name="ln412">		queryTemplate ? B_QUERY_TEMPLATE_MIMETYPE : B_QUERY_MIMETYPE));</a>
<a name="ln413"> </a>
<a name="ln414">	// save date/time info for recent query support and transient query killer</a>
<a name="ln415">	int32 currentTime = (int32)time(0);</a>
<a name="ln416">	file-&gt;WriteAttr(kAttrQueryLastChange, B_INT32_TYPE, 0, &amp;currentTime,</a>
<a name="ln417">		sizeof(int32));</a>
<a name="ln418">	int32 tmp = 1;</a>
<a name="ln419">	file-&gt;WriteAttr(&quot;_trk/recentQuery&quot;, B_INT32_TYPE, 0, &amp;tmp, sizeof(int32));</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">status_t</a>
<a name="ln424">FindWindow::SaveQueryAsAttributes(BNode* file, BEntry* entry,</a>
<a name="ln425">	bool queryTemplate, const BMessage* oldAttributes,</a>
<a name="ln426">	const BPoint* oldLocation)</a>
<a name="ln427">{</a>
<a name="ln428">	if (oldAttributes != NULL) {</a>
<a name="ln429">		// revive old window settings</a>
<a name="ln430">		BContainerWindow::SetLayoutState(file, oldAttributes);</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433">	if (oldLocation != NULL) {</a>
<a name="ln434">		// and the file's location</a>
<a name="ln435">		FSSetPoseLocation(entry, *oldLocation);</a>
<a name="ln436">	}</a>
<a name="ln437"> </a>
<a name="ln438">	BNodeInfo(file).SetType(queryTemplate</a>
<a name="ln439">		? B_QUERY_TEMPLATE_MIMETYPE : B_QUERY_MIMETYPE);</a>
<a name="ln440"> </a>
<a name="ln441">	BString predicate;</a>
<a name="ln442">	bool dynamicDate;</a>
<a name="ln443">	GetPredicateString(predicate, dynamicDate);</a>
<a name="ln444">	file-&gt;WriteAttrString(kAttrQueryString, &amp;predicate);</a>
<a name="ln445"> </a>
<a name="ln446">	if (dynamicDate) {</a>
<a name="ln447">		file-&gt;WriteAttr(kAttrDynamicDateQuery, B_BOOL_TYPE, 0, &amp;dynamicDate,</a>
<a name="ln448">			sizeof(dynamicDate));</a>
<a name="ln449">	}</a>
<a name="ln450"> </a>
<a name="ln451">	int32 tmp = 1;</a>
<a name="ln452">	file-&gt;WriteAttr(&quot;_trk/recentQuery&quot;, B_INT32_TYPE, 0, &amp;tmp, sizeof(int32));</a>
<a name="ln453"> </a>
<a name="ln454">	// write some useful info to help locate the volume to query</a>
<a name="ln455">	BMenuItem* item = fBackground-&gt;VolMenu()-&gt;FindMarked();</a>
<a name="ln456">	if (item != NULL) {</a>
<a name="ln457">		dev_t dev;</a>
<a name="ln458">		BMessage message;</a>
<a name="ln459">		uint32 count = 0;</a>
<a name="ln460"> </a>
<a name="ln461">		int32 itemCount = fBackground-&gt;VolMenu()-&gt;CountItems();</a>
<a name="ln462">		for (int32 index = 2; index &lt; itemCount; index++) {</a>
<a name="ln463">			BMenuItem* item = fBackground-&gt;VolMenu()-&gt;ItemAt(index);</a>
<a name="ln464"> </a>
<a name="ln465">			if (!item-&gt;IsMarked())</a>
<a name="ln466">				continue;</a>
<a name="ln467"> </a>
<a name="ln468">			if (item-&gt;Message()-&gt;FindInt32(&quot;device&quot;, &amp;dev) != B_OK)</a>
<a name="ln469">				continue;</a>
<a name="ln470"> </a>
<a name="ln471">			count++;</a>
<a name="ln472">			BVolume volume(dev);</a>
<a name="ln473">			EmbedUniqueVolumeInfo(&amp;message, &amp;volume);</a>
<a name="ln474">		}</a>
<a name="ln475"> </a>
<a name="ln476">		if (count &gt; 0) {</a>
<a name="ln477">			// do we need to embed any volumes</a>
<a name="ln478">			ssize_t size = message.FlattenedSize();</a>
<a name="ln479">			BString buffer;</a>
<a name="ln480">			status_t result = message.Flatten(buffer.LockBuffer(size), size);</a>
<a name="ln481">			if (result == B_OK) {</a>
<a name="ln482">				if (file-&gt;WriteAttr(kAttrQueryVolume, B_MESSAGE_TYPE, 0,</a>
<a name="ln483">					buffer.String(), (size_t)size) != size) {</a>
<a name="ln484">					return B_IO_ERROR;</a>
<a name="ln485">				}</a>
<a name="ln486">			}</a>
<a name="ln487">			buffer.UnlockBuffer();</a>
<a name="ln488">		}</a>
<a name="ln489">		// default to query for everything</a>
<a name="ln490">	}</a>
<a name="ln491"> </a>
<a name="ln492">	fBackground-&gt;SaveWindowState(file, fEditTemplateOnly);</a>
<a name="ln493">		// write out all the dialog items as attributes so that the query can</a>
<a name="ln494">		// be reopened and edited later</a>
<a name="ln495"> </a>
<a name="ln496">	BView* focusedItem = CurrentFocus();</a>
<a name="ln497">	if (focusedItem != NULL) {</a>
<a name="ln498">		// text controls never get the focus, their internal text views do</a>
<a name="ln499">		BView* parent = focusedItem-&gt;Parent();</a>
<a name="ln500">		if (dynamic_cast&lt;BTextControl*&gt;(parent) != NULL)</a>
<a name="ln501">			focusedItem = parent;</a>
<a name="ln502"> </a>
<a name="ln503">		// write out the current focus and, if text control, selection</a>
<a name="ln504">		BString name(focusedItem-&gt;Name());</a>
<a name="ln505">		file-&gt;WriteAttrString(&quot;_trk/focusedView&quot;, &amp;name);</a>
<a name="ln506">		BTextControl* textControl = dynamic_cast&lt;BTextControl*&gt;(focusedItem);</a>
<a name="ln507">		if (textControl != NULL &amp;&amp; textControl-&gt;TextView() != NULL) {</a>
<a name="ln508">			int32 selStart;</a>
<a name="ln509">			int32 selEnd;</a>
<a name="ln510">			textControl-&gt;TextView()-&gt;GetSelection(&amp;selStart, &amp;selEnd);</a>
<a name="ln511">			file-&gt;WriteAttr(&quot;_trk/focusedSelStart&quot;, B_INT32_TYPE, 0,</a>
<a name="ln512">				&amp;selStart, sizeof(selStart));</a>
<a name="ln513">			file-&gt;WriteAttr(&quot;_trk/focusedSelEnd&quot;, B_INT32_TYPE, 0,</a>
<a name="ln514">				&amp;selEnd, sizeof(selEnd));</a>
<a name="ln515">		}</a>
<a name="ln516">	}</a>
<a name="ln517"> </a>
<a name="ln518">	return B_OK;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">void</a>
<a name="ln523">FindWindow::Save()</a>
<a name="ln524">{</a>
<a name="ln525">	FindSaveCommon(false);</a>
<a name="ln526"> </a>
<a name="ln527">	// close the find panel</a>
<a name="ln528">	PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531"> </a>
<a name="ln532">void</a>
<a name="ln533">FindWindow::Find()</a>
<a name="ln534">{</a>
<a name="ln535">	if (!FindSaveCommon(true)) {</a>
<a name="ln536">		// have to wait for the node monitor to force old query to close</a>
<a name="ln537">		// to avoid a race condition</a>
<a name="ln538">		TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln539">		ASSERT(tracker != NULL);</a>
<a name="ln540"> </a>
<a name="ln541">		for (int32 timeOut = 0; ; timeOut++) {</a>
<a name="ln542">			if (tracker != NULL &amp;&amp; !tracker-&gt;EntryHasWindowOpen(&amp;fRef)) {</a>
<a name="ln543">				// window quit, we can post refs received to open a</a>
<a name="ln544">				// new copy</a>
<a name="ln545">				break;</a>
<a name="ln546">			}</a>
<a name="ln547"> </a>
<a name="ln548">			// PRINT((&quot;waiting for query window to quit, %d\n&quot;, timeOut));</a>
<a name="ln549">			if (timeOut == 5000) {</a>
<a name="ln550">				// the old query window would not quit for some reason</a>
<a name="ln551">				TRESPASS();</a>
<a name="ln552">				PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln553">				return;</a>
<a name="ln554">			}</a>
<a name="ln555">			snooze(1000);</a>
<a name="ln556">		}</a>
<a name="ln557">	}</a>
<a name="ln558"> </a>
<a name="ln559">	int32 currentTime = (int32)time(0);</a>
<a name="ln560">	fFile-&gt;WriteAttr(kAttrQueryLastChange, B_INT32_TYPE, 0, &amp;currentTime,</a>
<a name="ln561">		sizeof(int32));</a>
<a name="ln562"> </a>
<a name="ln563">	// tell the tracker about it</a>
<a name="ln564">	BMessage message(B_REFS_RECEIVED);</a>
<a name="ln565">	message.AddRef(&quot;refs&quot;, &amp;fRef);</a>
<a name="ln566">	be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln567"> </a>
<a name="ln568">	// close the find panel</a>
<a name="ln569">	PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">bool</a>
<a name="ln574">FindWindow::FindSaveCommon(bool find)</a>
<a name="ln575">{</a>
<a name="ln576">	// figure out what we need to do</a>
<a name="ln577">	bool readFromOldFile = fFile != NULL;</a>
<a name="ln578">	bool replaceOriginal = fFile &amp;&amp; (!fFromTemplate || fEditTemplateOnly);</a>
<a name="ln579">	bool keepPoseLocation = replaceOriginal;</a>
<a name="ln580">	bool newFile = !fFile || (fFromTemplate &amp;&amp; !fEditTemplateOnly);</a>
<a name="ln581"> </a>
<a name="ln582">	BEntry entry;</a>
<a name="ln583">	BMessage oldAttributes;</a>
<a name="ln584">	BPoint location;</a>
<a name="ln585">	bool hadLocation = false;</a>
<a name="ln586">	const char* userSpecifiedName = fBackground-&gt;UserSpecifiedName();</a>
<a name="ln587"> </a>
<a name="ln588">	if (readFromOldFile) {</a>
<a name="ln589">		entry.SetTo(&amp;fRef);</a>
<a name="ln590">		BContainerWindow::GetLayoutState(fFile, &amp;oldAttributes);</a>
<a name="ln591">		hadLocation = FSGetPoseLocation(fFile, &amp;location);</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">	if (replaceOriginal) {</a>
<a name="ln595">		fFile-&gt;Unset();</a>
<a name="ln596">		entry.Remove();</a>
<a name="ln597">			// remove the current entry - need to do this to quit the</a>
<a name="ln598">			// running query and to close the corresponding window</a>
<a name="ln599"> </a>
<a name="ln600">		if (userSpecifiedName != NULL &amp;&amp; !fEditTemplateOnly) {</a>
<a name="ln601">			// change the name of the old query per users request</a>
<a name="ln602">			fRef.set_name(userSpecifiedName);</a>
<a name="ln603">			entry.SetTo(&amp;fRef);</a>
<a name="ln604">		}</a>
<a name="ln605">	}</a>
<a name="ln606"> </a>
<a name="ln607">	if (newFile) {</a>
<a name="ln608">		// create query file in the user's directory</a>
<a name="ln609">		BPath path;</a>
<a name="ln610">		// there might be no queries folder yet, create one</a>
<a name="ln611">		if (find_directory(B_USER_DIRECTORY, &amp;path, true) == B_OK</a>
<a name="ln612">			&amp;&amp; path.Append(&quot;queries&quot;) == B_OK</a>
<a name="ln613">			&amp;&amp; (mkdir(path.Path(), 0777) == 0 || errno == EEXIST)) {</a>
<a name="ln614">			// either use the user specified name, or go with the name</a>
<a name="ln615">			// generated from the predicate, etc.</a>
<a name="ln616">			BString name;</a>
<a name="ln617">			if (userSpecifiedName == NULL)</a>
<a name="ln618">				GetDefaultName(name);</a>
<a name="ln619">			else</a>
<a name="ln620">				name &lt;&lt; userSpecifiedName;</a>
<a name="ln621"> </a>
<a name="ln622">			if (path.Append(name.String()) == B_OK) {</a>
<a name="ln623">				entry.SetTo(path.Path());</a>
<a name="ln624">				entry.Remove();</a>
<a name="ln625">				entry.GetRef(&amp;fRef);</a>
<a name="ln626">			}</a>
<a name="ln627">		}</a>
<a name="ln628">	}</a>
<a name="ln629"> </a>
<a name="ln630">	fFile = new BFile(&amp;entry, O_RDWR | O_CREAT);</a>
<a name="ln631">	ASSERT(fFile-&gt;InitCheck() == B_OK);</a>
<a name="ln632"> </a>
<a name="ln633">	SaveQueryAsAttributes(fFile, &amp;entry, !find, newFile ? 0 : &amp;oldAttributes,</a>
<a name="ln634">		(hadLocation &amp;&amp; keepPoseLocation) ? &amp;location : 0);</a>
<a name="ln635"> </a>
<a name="ln636">	return newFile;</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639"> </a>
<a name="ln640">void</a>
<a name="ln641">FindWindow::MessageReceived(BMessage* message)</a>
<a name="ln642">{</a>
<a name="ln643">	switch (message-&gt;what) {</a>
<a name="ln644">		case kFindButton:</a>
<a name="ln645">			Find();</a>
<a name="ln646">			break;</a>
<a name="ln647"> </a>
<a name="ln648">		case kSaveButton:</a>
<a name="ln649">			Save();</a>
<a name="ln650">			break;</a>
<a name="ln651"> </a>
<a name="ln652">		case kAttachFile:</a>
<a name="ln653">			{</a>
<a name="ln654">				entry_ref dir;</a>
<a name="ln655">				const char* name;</a>
<a name="ln656">				bool queryTemplate;</a>
<a name="ln657">				if (message-&gt;FindString(&quot;name&quot;, &amp;name) == B_OK</a>
<a name="ln658">					&amp;&amp; message-&gt;FindRef(&quot;directory&quot;, &amp;dir) == B_OK</a>
<a name="ln659">					&amp;&amp; message-&gt;FindBool(&quot;template&quot;, &amp;queryTemplate)</a>
<a name="ln660">						== B_OK) {</a>
<a name="ln661">					delete fFile;</a>
<a name="ln662">					fFile = NULL;</a>
<a name="ln663">					BDirectory directory(&amp;dir);</a>
<a name="ln664">					BEntry entry(&amp;directory, name);</a>
<a name="ln665">					entry_ref tmpRef;</a>
<a name="ln666">					entry.GetRef(&amp;tmpRef);</a>
<a name="ln667">					fFile = TryOpening(&amp;tmpRef);</a>
<a name="ln668">					if (fFile != NULL) {</a>
<a name="ln669">						fRef = tmpRef;</a>
<a name="ln670">						SaveQueryAsAttributes(fFile, &amp;entry, queryTemplate,</a>
<a name="ln671">							0, 0);</a>
<a name="ln672">							// try to save whatever state we aleady have</a>
<a name="ln673">							// to the new query so that if the user</a>
<a name="ln674">							// opens it before runing it from the find panel,</a>
<a name="ln675">							// something reasonable happens</a>
<a name="ln676">					}</a>
<a name="ln677">				}</a>
<a name="ln678">			}</a>
<a name="ln679">			break;</a>
<a name="ln680"> </a>
<a name="ln681">		case kSwitchToQueryTemplate:</a>
<a name="ln682">		{</a>
<a name="ln683">			entry_ref ref;</a>
<a name="ln684">			if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) == B_OK)</a>
<a name="ln685">				SwitchToTemplate(&amp;ref);</a>
<a name="ln686"> </a>
<a name="ln687">			break;</a>
<a name="ln688">		}</a>
<a name="ln689"> </a>
<a name="ln690">		case kRunSaveAsTemplatePanel:</a>
<a name="ln691">			if (fSaveAsTemplatePanel != NULL)</a>
<a name="ln692">				fSaveAsTemplatePanel-&gt;Show();</a>
<a name="ln693">			else {</a>
<a name="ln694">				BMessenger panel(BackgroundView());</a>
<a name="ln695">				fSaveAsTemplatePanel = new BFilePanel(B_SAVE_PANEL, &amp;panel);</a>
<a name="ln696">				fSaveAsTemplatePanel-&gt;SetSaveText(</a>
<a name="ln697">					B_TRANSLATE(&quot;Query template&quot;));</a>
<a name="ln698">				fSaveAsTemplatePanel-&gt;Window()-&gt;SetTitle(</a>
<a name="ln699">					B_TRANSLATE(&quot;Save as Query template:&quot;));</a>
<a name="ln700">				fSaveAsTemplatePanel-&gt;Show();</a>
<a name="ln701">			}</a>
<a name="ln702">			break;</a>
<a name="ln703"> </a>
<a name="ln704">		default:</a>
<a name="ln705">			_inherited::MessageReceived(message);</a>
<a name="ln706">			break;</a>
<a name="ln707">	}</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710"> </a>
<a name="ln711">//	#pragma mark - FindPanel</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">FindPanel::FindPanel(BFile* node, FindWindow* parent, bool fromTemplate,</a>
<a name="ln715">	bool editTemplateOnly)</a>
<a name="ln716">	:</a>
<a name="ln717">	BView(&quot;MainView&quot;, B_WILL_DRAW),</a>
<a name="ln718">	fMode(kByNameItem),</a>
<a name="ln719">	fAttrGrid(NULL),</a>
<a name="ln720">	fDraggableIcon(NULL)</a>
<a name="ln721">{</a>
<a name="ln722">	SetViewUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln723">	SetLowUIColor(ViewUIColor());</a>
<a name="ln724"> </a>
<a name="ln725">	uint32 initialMode = InitialMode(node);</a>
<a name="ln726"> </a>
<a name="ln727">	BMessenger self(this);</a>
<a name="ln728">	fRecentQueries = new BPopUpMenu(B_TRANSLATE(&quot;Recent queries&quot;), false,</a>
<a name="ln729">		false);</a>
<a name="ln730">	AddRecentQueries(fRecentQueries, true, &amp;self, kSwitchToQueryTemplate);</a>
<a name="ln731"> </a>
<a name="ln732">	// add popup for mime types</a>
<a name="ln733">	fMimeTypeMenu = new BPopUpMenu(&quot;MimeTypeMenu&quot;);</a>
<a name="ln734">	fMimeTypeMenu-&gt;SetRadioMode(false);</a>
<a name="ln735">	AddMimeTypesToMenu();</a>
<a name="ln736"> </a>
<a name="ln737">	fMimeTypeField = new BMenuField(&quot;MimeTypeMenu&quot;, &quot;&quot;, fMimeTypeMenu);</a>
<a name="ln738">	fMimeTypeField-&gt;SetDivider(0.0f);</a>
<a name="ln739">	fMimeTypeField-&gt;MenuItem()-&gt;SetLabel(B_TRANSLATE(&quot;All files and folders&quot;));</a>
<a name="ln740">	// add popup for search criteria</a>
<a name="ln741">	fSearchModeMenu = new BPopUpMenu(&quot;searchMode&quot;);</a>
<a name="ln742">	fSearchModeMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;by name&quot;),</a>
<a name="ln743">		new BMessage(kByNameItem)));</a>
<a name="ln744">	fSearchModeMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;by attribute&quot;),</a>
<a name="ln745">		new BMessage(kByAttributeItem)));</a>
<a name="ln746">	fSearchModeMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;by formula&quot;),</a>
<a name="ln747">		new BMessage(kByFormulaItem)));</a>
<a name="ln748"> </a>
<a name="ln749">	fSearchModeMenu-&gt;ItemAt(initialMode == kByNameItem ? 0 :</a>
<a name="ln750">		(initialMode == kByAttributeItem ? 1 : 2))-&gt;SetMarked(true);</a>
<a name="ln751">		// mark the appropriate mode</a>
<a name="ln752">	BMenuField* searchModeField = new BMenuField(&quot;&quot;, &quot;&quot;, fSearchModeMenu);</a>
<a name="ln753">	searchModeField-&gt;SetDivider(0.0f);</a>
<a name="ln754"> </a>
<a name="ln755">	// add popup for volume list</a>
<a name="ln756">	fVolMenu = new BPopUpMenu(&quot;&quot;, false, false);</a>
<a name="ln757">	BMenuField* volumeField = new BMenuField(&quot;&quot;, B_TRANSLATE(&quot;On&quot;), fVolMenu);</a>
<a name="ln758">	volumeField-&gt;SetDivider(volumeField-&gt;StringWidth(volumeField-&gt;Label()) + 8);</a>
<a name="ln759">	AddVolumes(fVolMenu);</a>
<a name="ln760"> </a>
<a name="ln761">	if (!editTemplateOnly) {</a>
<a name="ln762">		BPoint draggableIconOrigin(0, 0);</a>
<a name="ln763">		BMessage dragNDropMessage(B_SIMPLE_DATA);</a>
<a name="ln764">		dragNDropMessage.AddInt32(&quot;be:actions&quot;, B_COPY_TARGET);</a>
<a name="ln765">		dragNDropMessage.AddString(&quot;be:types&quot;, B_FILE_MIME_TYPE);</a>
<a name="ln766">		dragNDropMessage.AddString(&quot;be:filetypes&quot;, kDragNDropTypes[0]);</a>
<a name="ln767">		dragNDropMessage.AddString(&quot;be:filetypes&quot;, kDragNDropTypes[1]);</a>
<a name="ln768">		dragNDropMessage.AddString(&quot;be:actionspecifier&quot;,</a>
<a name="ln769">			B_TRANSLATE_NOCOLLECT(kDragNDropActionSpecifiers[0]));</a>
<a name="ln770">		dragNDropMessage.AddString(&quot;be:actionspecifier&quot;,</a>
<a name="ln771">			B_TRANSLATE_NOCOLLECT(kDragNDropActionSpecifiers[1]));</a>
<a name="ln772"> </a>
<a name="ln773">		BMessenger self(this);</a>
<a name="ln774">		BRect draggableRect = DraggableIcon::PreferredRect(draggableIconOrigin,</a>
<a name="ln775">			B_LARGE_ICON);</a>
<a name="ln776">		fDraggableIcon = new DraggableQueryIcon(draggableRect,</a>
<a name="ln777">			&quot;saveHere&quot;, &amp;dragNDropMessage, self,</a>
<a name="ln778">			B_FOLLOW_LEFT | B_FOLLOW_BOTTOM);</a>
<a name="ln779">		fDraggableIcon-&gt;SetExplicitMaxSize(</a>
<a name="ln780">			BSize(draggableRect.right - draggableRect.left,</a>
<a name="ln781">				draggableRect.bottom - draggableRect.top));</a>
<a name="ln782">	}</a>
<a name="ln783"> </a>
<a name="ln784">	fQueryName = new BTextControl(&quot;query name&quot;, B_TRANSLATE(&quot;Query name:&quot;),</a>
<a name="ln785">		&quot;&quot;, NULL, B_WILL_DRAW | B_NAVIGABLE | B_NAVIGABLE_JUMP);</a>
<a name="ln786">	FillCurrentQueryName(fQueryName, parent);</a>
<a name="ln787">	fSearchTrashCheck = new BCheckBox(&quot;searchTrash&quot;,</a>
<a name="ln788">		B_TRANSLATE(&quot;Include trash&quot;), NULL);</a>
<a name="ln789">	fTemporaryCheck = new BCheckBox(&quot;temporary&quot;,</a>
<a name="ln790">		B_TRANSLATE(&quot;Temporary&quot;), NULL);</a>
<a name="ln791">	fTemporaryCheck-&gt;SetValue(B_CONTROL_ON);</a>
<a name="ln792"> </a>
<a name="ln793">	BView* checkboxGroup = BLayoutBuilder::Group&lt;&gt;(B_HORIZONTAL)</a>
<a name="ln794">		.Add(fSearchTrashCheck)</a>
<a name="ln795">		.Add(fTemporaryCheck)</a>
<a name="ln796">		.View();</a>
<a name="ln797"> </a>
<a name="ln798">	// add the more options collapsible pane</a>
<a name="ln799">	fMoreOptions = new BBox(B_NO_BORDER, BLayoutBuilder::Group&lt;&gt;()</a>
<a name="ln800">		.AddGrid(B_USE_SMALL_SPACING, B_USE_SMALL_SPACING)</a>
<a name="ln801">			.Add(fQueryName-&gt;CreateLabelLayoutItem(), 0, 0)</a>
<a name="ln802">			.Add(fQueryName-&gt;CreateTextViewLayoutItem(), 1, 0)</a>
<a name="ln803">			.Add(BSpaceLayoutItem::CreateHorizontalStrut(0), 0, 1)</a>
<a name="ln804">			.Add(checkboxGroup, 1, 1)</a>
<a name="ln805">			.End()</a>
<a name="ln806">		.View());</a>
<a name="ln807"> </a>
<a name="ln808">	fLatch = new PaneSwitch(&quot;optionsLatch&quot;, true, B_WILL_DRAW);</a>
<a name="ln809">	fLatch-&gt;SetLabels(B_TRANSLATE(&quot;Fewer options&quot;), B_TRANSLATE(&quot;More options&quot;));</a>
<a name="ln810">	fLatch-&gt;SetValue(0);</a>
<a name="ln811">	fLatch-&gt;SetMessage(new BMessage(kLatchChanged));</a>
<a name="ln812">	fLatch-&gt;SetExplicitAlignment(BAlignment(B_ALIGN_LEFT,</a>
<a name="ln813">		B_ALIGN_VERTICAL_CENTER));</a>
<a name="ln814">	fMoreOptions-&gt;Hide();</a>
<a name="ln815"> </a>
<a name="ln816">	// add Search button</a>
<a name="ln817">	BButton* button;</a>
<a name="ln818">	if (editTemplateOnly) {</a>
<a name="ln819">		button = new BButton(&quot;save&quot;, B_TRANSLATE(&quot;Save&quot;),</a>
<a name="ln820">			new BMessage(kSaveButton), B_FOLLOW_RIGHT + B_FOLLOW_BOTTOM);</a>
<a name="ln821">	} else {</a>
<a name="ln822">		button = new BButton(&quot;find&quot;, B_TRANSLATE(&quot;Search&quot;),</a>
<a name="ln823">			new BMessage(kFindButton), B_FOLLOW_RIGHT + B_FOLLOW_BOTTOM);</a>
<a name="ln824">	}</a>
<a name="ln825">	button-&gt;MakeDefault(true);</a>
<a name="ln826"> </a>
<a name="ln827">	BView* icon = fDraggableIcon;</a>
<a name="ln828">	if (icon == NULL) {</a>
<a name="ln829">		icon = new BBox(&quot;no draggable icon&quot;, B_WILL_DRAW, B_NO_BORDER);</a>
<a name="ln830">		icon-&gt;SetExplicitMaxSize(BSize(0, 0));</a>
<a name="ln831">	}</a>
<a name="ln832"> </a>
<a name="ln833">	BView* mimeTypeFieldSpacer = new BBox(&quot;MimeTypeMenuSpacer&quot;, B_WILL_DRAW,</a>
<a name="ln834">		B_NO_BORDER);</a>
<a name="ln835">	mimeTypeFieldSpacer-&gt;SetExplicitMaxSize(BSize(0, 0));</a>
<a name="ln836"> </a>
<a name="ln837">	BBox* queryControls = new BBox(&quot;Box&quot;);</a>
<a name="ln838">	queryControls-&gt;SetBorder(B_NO_BORDER);</a>
<a name="ln839"> </a>
<a name="ln840">	BBox* queryBox = new BBox(&quot;Outer Controls&quot;);</a>
<a name="ln841">	queryBox-&gt;SetLabel(new BMenuField(&quot;RecentQueries&quot;, NULL, fRecentQueries));</a>
<a name="ln842"> </a>
<a name="ln843">	BGroupView* queryBoxView = new BGroupView(B_VERTICAL,</a>
<a name="ln844">		B_USE_DEFAULT_SPACING);</a>
<a name="ln845">	queryBoxView-&gt;GroupLayout()-&gt;SetInsets(B_USE_DEFAULT_SPACING);</a>
<a name="ln846">	queryBox-&gt;AddChild(queryBoxView);</a>
<a name="ln847"> </a>
<a name="ln848">	icon-&gt;SetExplicitAlignment(BAlignment(B_ALIGN_LEFT, B_ALIGN_BOTTOM));</a>
<a name="ln849">	button-&gt;SetExplicitAlignment(BAlignment(B_ALIGN_RIGHT, B_ALIGN_BOTTOM));</a>
<a name="ln850"> </a>
<a name="ln851">	BLayoutBuilder::Group&lt;&gt;(queryBoxView, B_VERTICAL, B_USE_DEFAULT_SPACING)</a>
<a name="ln852">		.SetInsets(B_USE_DEFAULT_SPACING)</a>
<a name="ln853">		.AddGroup(B_HORIZONTAL, B_USE_SMALL_SPACING)</a>
<a name="ln854">			.Add(fMimeTypeField)</a>
<a name="ln855">			.Add(mimeTypeFieldSpacer)</a>
<a name="ln856">			.Add(searchModeField)</a>
<a name="ln857">			.AddStrut(B_USE_DEFAULT_SPACING)</a>
<a name="ln858">			.Add(volumeField)</a>
<a name="ln859">			.End()</a>
<a name="ln860">		.Add(new BSeparatorView(B_HORIZONTAL, B_PLAIN_BORDER))</a>
<a name="ln861">		.Add(queryControls);</a>
<a name="ln862">	BLayoutBuilder::Group&lt;&gt;(this, B_VERTICAL, B_USE_DEFAULT_SPACING)</a>
<a name="ln863">		.SetInsets(B_USE_WINDOW_SPACING)</a>
<a name="ln864">		.Add(queryBox)</a>
<a name="ln865">		.AddGroup(B_HORIZONTAL, B_USE_DEFAULT_SPACING)</a>
<a name="ln866">			.Add(icon)</a>
<a name="ln867">			.AddGroup(B_VERTICAL)</a>
<a name="ln868">				.AddGroup(B_HORIZONTAL)</a>
<a name="ln869">					.Add(fLatch)</a>
<a name="ln870">					.Add(new BSeparatorView(B_HORIZONTAL, B_PLAIN_BORDER))</a>
<a name="ln871">					.End()</a>
<a name="ln872">				.Add(fMoreOptions)</a>
<a name="ln873">				.End()</a>
<a name="ln874">			.Add(button)</a>
<a name="ln875">			.End();</a>
<a name="ln876"> </a>
<a name="ln877">	if (initialMode != kByAttributeItem)</a>
<a name="ln878">		AddByNameOrFormulaItems();</a>
<a name="ln879">	else</a>
<a name="ln880">		AddByAttributeItems(node);</a>
<a name="ln881"> </a>
<a name="ln882">	ResizeMenuField(fMimeTypeField);</a>
<a name="ln883">	ResizeMenuField(searchModeField);</a>
<a name="ln884">	ResizeMenuField(volumeField);</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887"> </a>
<a name="ln888">FindPanel::~FindPanel()</a>
<a name="ln889">{</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892"> </a>
<a name="ln893">void</a>
<a name="ln894">FindPanel::AttachedToWindow()</a>
<a name="ln895">{</a>
<a name="ln896">	FindWindow* findWindow = dynamic_cast&lt;FindWindow*&gt;(Window());</a>
<a name="ln897">	ASSERT(findWindow != NULL);</a>
<a name="ln898"> </a>
<a name="ln899">	if (findWindow == NULL)</a>
<a name="ln900">		return;</a>
<a name="ln901"> </a>
<a name="ln902">	BNode* node = findWindow-&gt;QueryNode();</a>
<a name="ln903">	fSearchModeMenu-&gt;SetTargetForItems(this);</a>
<a name="ln904">	fQueryName-&gt;SetTarget(this);</a>
<a name="ln905">	fLatch-&gt;SetTarget(this);</a>
<a name="ln906">	RestoreMimeTypeMenuSelection(node);</a>
<a name="ln907">		// preselect the mime we used the last time have to do it here</a>
<a name="ln908">		// because AddByAttributeItems will build different menus based</a>
<a name="ln909">		// on which mime type is preselected</a>
<a name="ln910">	RestoreWindowState(node);</a>
<a name="ln911"> </a>
<a name="ln912">	if (!findWindow-&gt;CurrentFocus()) {</a>
<a name="ln913">		// try to pick a good focus if we restore to one already</a>
<a name="ln914">		BTextControl* textControl</a>
<a name="ln915">			= dynamic_cast&lt;BTextControl*&gt;(FindView(&quot;TextControl&quot;));</a>
<a name="ln916">		if (textControl == NULL) {</a>
<a name="ln917">			// pick the last text control in the attribute view</a>
<a name="ln918">			BString title(&quot;TextEntry&quot;);</a>
<a name="ln919">			title &lt;&lt; (fAttrGrid-&gt;CountRows() - 1);</a>
<a name="ln920">			textControl = dynamic_cast&lt;BTextControl*&gt;(FindView(title.String()));</a>
<a name="ln921">		}</a>
<a name="ln922">		if (textControl != NULL)</a>
<a name="ln923">			textControl-&gt;MakeFocus();</a>
<a name="ln924">	}</a>
<a name="ln925"> </a>
<a name="ln926">	BButton* button = dynamic_cast&lt;BButton*&gt;(FindView(&quot;remove button&quot;));</a>
<a name="ln927">	if (button != NULL)</a>
<a name="ln928">		button-&gt;SetTarget(this);</a>
<a name="ln929"> </a>
<a name="ln930">	button = dynamic_cast&lt;BButton*&gt;(FindView(&quot;add button&quot;));</a>
<a name="ln931">	if (button != NULL)</a>
<a name="ln932">		button-&gt;SetTarget(this);</a>
<a name="ln933"> </a>
<a name="ln934">	fVolMenu-&gt;SetTargetForItems(this);</a>
<a name="ln935"> </a>
<a name="ln936">	// set target for MIME type items</a>
<a name="ln937">	for (int32 index = MimeTypeMenu()-&gt;CountItems(); index-- &gt; 2;) {</a>
<a name="ln938">		BMenu* submenu = MimeTypeMenu()-&gt;ItemAt(index)-&gt;Submenu();</a>
<a name="ln939">		if (submenu != NULL)</a>
<a name="ln940">			submenu-&gt;SetTargetForItems(this);</a>
<a name="ln941">	}</a>
<a name="ln942">	fMimeTypeMenu-&gt;SetTargetForItems(this);</a>
<a name="ln943"> </a>
<a name="ln944">	BMenuItem* firstItem = fMimeTypeMenu-&gt;ItemAt(0);</a>
<a name="ln945">	if (firstItem != NULL)</a>
<a name="ln946">		firstItem-&gt;SetMarked(true);</a>
<a name="ln947"> </a>
<a name="ln948">	if (fDraggableIcon != NULL)</a>
<a name="ln949">		fDraggableIcon-&gt;SetTarget(BMessenger(this));</a>
<a name="ln950"> </a>
<a name="ln951">	fRecentQueries-&gt;SetTargetForItems(findWindow);</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954"> </a>
<a name="ln955">void</a>
<a name="ln956">FindPanel::ResizeMenuField(BMenuField* menuField)</a>
<a name="ln957">{</a>
<a name="ln958">	BSize size;</a>
<a name="ln959">	menuField-&gt;GetPreferredSize(&amp;size.width, &amp;size.height);</a>
<a name="ln960"> </a>
<a name="ln961">	BMenu* menu = menuField-&gt;Menu();</a>
<a name="ln962"> </a>
<a name="ln963">	float padding = 0.0f;</a>
<a name="ln964">	float width = 0.0f;</a>
<a name="ln965"> </a>
<a name="ln966">	BMenuItem* markedItem = menu-&gt;FindMarked();</a>
<a name="ln967">	if (markedItem != NULL) {</a>
<a name="ln968">		if (markedItem-&gt;Submenu() != NULL) {</a>
<a name="ln969">			BMenuItem* markedSubItem = markedItem-&gt;Submenu()-&gt;FindMarked();</a>
<a name="ln970">			if (markedSubItem != NULL &amp;&amp; markedSubItem-&gt;Label() != NULL) {</a>
<a name="ln971">				float labelWidth</a>
<a name="ln972">					= menuField-&gt;StringWidth(markedSubItem-&gt;Label());</a>
<a name="ln973">				padding = size.width - labelWidth;</a>
<a name="ln974">			}</a>
<a name="ln975">		} else if (markedItem-&gt;Label() != NULL) {</a>
<a name="ln976">			float labelWidth = menuField-&gt;StringWidth(markedItem-&gt;Label());</a>
<a name="ln977">			padding = size.width - labelWidth;</a>
<a name="ln978">		}</a>
<a name="ln979">	}</a>
<a name="ln980"> </a>
<a name="ln981">	for (int32 index = menu-&gt;CountItems(); index-- &gt; 0; ) {</a>
<a name="ln982">		BMenuItem* item = menu-&gt;ItemAt(index);</a>
<a name="ln983">		if (item-&gt;Label() != NULL)</a>
<a name="ln984">			width = std::max(width, menuField-&gt;StringWidth(item-&gt;Label()));</a>
<a name="ln985"> </a>
<a name="ln986">		BMenu* submenu = item-&gt;Submenu();</a>
<a name="ln987">		if (submenu != NULL) {</a>
<a name="ln988">			for (int32 subIndex = submenu-&gt;CountItems(); subIndex-- &gt; 0; ) {</a>
<a name="ln989">				BMenuItem* subItem = submenu-&gt;ItemAt(subIndex);</a>
<a name="ln990">				if (subItem-&gt;Label() == NULL)</a>
<a name="ln991">					continue;</a>
<a name="ln992"> </a>
<a name="ln993">				width = std::max(width,</a>
<a name="ln994">					menuField-&gt;StringWidth(subItem-&gt;Label()));</a>
<a name="ln995">			}</a>
<a name="ln996">		}</a>
<a name="ln997">	}</a>
<a name="ln998"> </a>
<a name="ln999">	float maxWidth = be_control_look-&gt;DefaultItemSpacing() * 20;</a>
<a name="ln1000">	size.width = std::min(width + padding, maxWidth);</a>
<a name="ln1001">	menuField-&gt;SetExplicitSize(size);</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">static void</a>
<a name="ln1005">PopUpMenuSetTitle(BMenu* menu, const char* title)</a>
<a name="ln1006">{</a>
<a name="ln1007">	// This should really be in BMenuField</a>
<a name="ln1008">	BMenu* bar = menu-&gt;Supermenu();</a>
<a name="ln1009"> </a>
<a name="ln1010">	ASSERT(bar);</a>
<a name="ln1011">	ASSERT(bar-&gt;ItemAt(0));</a>
<a name="ln1012">	if (bar == NULL || !bar-&gt;ItemAt(0))</a>
<a name="ln1013">		return;</a>
<a name="ln1014"> </a>
<a name="ln1015">	bar-&gt;ItemAt(0)-&gt;SetLabel(title);</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018"> </a>
<a name="ln1019">void</a>
<a name="ln1020">FindPanel::ShowVolumeMenuLabel()</a>
<a name="ln1021">{</a>
<a name="ln1022">	if (fVolMenu-&gt;ItemAt(0)-&gt;IsMarked()) {</a>
<a name="ln1023">		// &quot;all disks&quot; selected</a>
<a name="ln1024">		PopUpMenuSetTitle(fVolMenu, fVolMenu-&gt;ItemAt(0)-&gt;Label());</a>
<a name="ln1025">		return;</a>
<a name="ln1026">	}</a>
<a name="ln1027"> </a>
<a name="ln1028">	// find out if more than one items are marked</a>
<a name="ln1029">	int32 count = fVolMenu-&gt;CountItems();</a>
<a name="ln1030">	int32 countSelected = 0;</a>
<a name="ln1031">	BMenuItem* tmpItem = NULL;</a>
<a name="ln1032">	for (int32 index = 2; index &lt; count; index++) {</a>
<a name="ln1033">		BMenuItem* item = fVolMenu-&gt;ItemAt(index);</a>
<a name="ln1034">		if (item-&gt;IsMarked()) {</a>
<a name="ln1035">			countSelected++;</a>
<a name="ln1036">			tmpItem = item;</a>
<a name="ln1037">		}</a>
<a name="ln1038">	}</a>
<a name="ln1039"> </a>
<a name="ln1040">	if (countSelected == 0) {</a>
<a name="ln1041">		// no disk selected, for now revert to search all disks</a>
<a name="ln1042">		// ToDo:</a>
<a name="ln1043">		// show no disks here and add a check that will not let the</a>
<a name="ln1044">		// query go if the user doesn't pick at least one</a>
<a name="ln1045">		fVolMenu-&gt;ItemAt(0)-&gt;SetMarked(true);</a>
<a name="ln1046">		PopUpMenuSetTitle(fVolMenu, fVolMenu-&gt;ItemAt(0)-&gt;Label());</a>
<a name="ln1047">	} else if (countSelected &gt; 1)</a>
<a name="ln1048">		// if more than two disks selected, don't use the disk name</a>
<a name="ln1049">		// as a label</a>
<a name="ln1050">		PopUpMenuSetTitle(fVolMenu,	B_TRANSLATE(&quot;multiple disks&quot;));</a>
<a name="ln1051">	else {</a>
<a name="ln1052">		ASSERT(tmpItem);</a>
<a name="ln1053">		PopUpMenuSetTitle(fVolMenu, tmpItem-&gt;Label());</a>
<a name="ln1054">	}</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057"> </a>
<a name="ln1058">void</a>
<a name="ln1059">FindPanel::Draw(BRect)</a>
<a name="ln1060">{</a>
<a name="ln1061">	if (fAttrGrid == NULL)</a>
<a name="ln1062">		return;</a>
<a name="ln1063"> </a>
<a name="ln1064">	for (int32 index = 0; index &lt; fAttrGrid-&gt;CountRows(); index++) {</a>
<a name="ln1065">		BMenuField* menuField</a>
<a name="ln1066">			= dynamic_cast&lt;BMenuField*&gt;(FindAttrView(&quot;MenuField&quot;, index));</a>
<a name="ln1067">		if (menuField == NULL)</a>
<a name="ln1068">			continue;</a>
<a name="ln1069"> </a>
<a name="ln1070">		BLayoutItem* stringViewLayoutItem = fAttrGrid-&gt;ItemAt(1, index);</a>
<a name="ln1071">		if (stringViewLayoutItem == NULL)</a>
<a name="ln1072">			continue;</a>
<a name="ln1073"> </a>
<a name="ln1074">		BMenu* menuFieldMenu = menuField-&gt;Menu();</a>
<a name="ln1075">		if (menuFieldMenu == NULL)</a>
<a name="ln1076">			continue;</a>
<a name="ln1077"> </a>
<a name="ln1078">		BMenuItem* item = menuFieldMenu-&gt;FindMarked();</a>
<a name="ln1079">		if (item == NULL || item-&gt;Submenu() == NULL</a>
<a name="ln1080">			|| item-&gt;Submenu()-&gt;FindMarked() == NULL) {</a>
<a name="ln1081">			continue;</a>
<a name="ln1082">		}</a>
<a name="ln1083"> </a>
<a name="ln1084">		if (stringViewLayoutItem == NULL) {</a>
<a name="ln1085">			stringViewLayoutItem = fAttrGrid-&gt;AddView(new BStringView(&quot;&quot;,</a>
<a name="ln1086">				item-&gt;Submenu()-&gt;FindMarked()-&gt;Label()), 1, index);</a>
<a name="ln1087">			stringViewLayoutItem-&gt;SetExplicitAlignment(BAlignment(B_ALIGN_RIGHT,</a>
<a name="ln1088">				B_ALIGN_VERTICAL_UNSET));</a>
<a name="ln1089">		}</a>
<a name="ln1090"> </a>
<a name="ln1091">		if (stringViewLayoutItem != NULL) {</a>
<a name="ln1092">			BStringView* stringView</a>
<a name="ln1093">				= dynamic_cast&lt;BStringView*&gt;(stringViewLayoutItem-&gt;View());</a>
<a name="ln1094">			if (stringView != NULL) {</a>
<a name="ln1095">				BMenu* submenu = item-&gt;Submenu();</a>
<a name="ln1096">				if (submenu != NULL) {</a>
<a name="ln1097">					BMenuItem* selected = submenu-&gt;FindMarked();</a>
<a name="ln1098">					if (selected != NULL)</a>
<a name="ln1099">						stringView-&gt;SetText(selected-&gt;Label());</a>
<a name="ln1100">				}</a>
<a name="ln1101">			}</a>
<a name="ln1102">		}</a>
<a name="ln1103">	}</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106"> </a>
<a name="ln1107">void</a>
<a name="ln1108">FindPanel::MessageReceived(BMessage* message)</a>
<a name="ln1109">{</a>
<a name="ln1110">	entry_ref dir;</a>
<a name="ln1111">	const char* name;</a>
<a name="ln1112">	BMenuItem* item;</a>
<a name="ln1113"> </a>
<a name="ln1114">	switch (message-&gt;what) {</a>
<a name="ln1115">		case kVolumeItem:</a>
<a name="ln1116">		{</a>
<a name="ln1117">			// volume changed</a>
<a name="ln1118">			BMenuItem* invokedItem;</a>
<a name="ln1119">			dev_t dev;</a>
<a name="ln1120">			if (message-&gt;FindPointer(&quot;source&quot;, (void**)&amp;invokedItem) != B_OK)</a>
<a name="ln1121">				return;</a>
<a name="ln1122"> </a>
<a name="ln1123">			if (message-&gt;FindInt32(&quot;device&quot;, &amp;dev) != B_OK)</a>
<a name="ln1124">				break;</a>
<a name="ln1125"> </a>
<a name="ln1126">			BMenu* menu = invokedItem-&gt;Menu();</a>
<a name="ln1127">			ASSERT(menu);</a>
<a name="ln1128"> </a>
<a name="ln1129">			if (dev == -1) {</a>
<a name="ln1130">				// all disks selected, uncheck everything else</a>
<a name="ln1131">				int32 count = menu-&gt;CountItems();</a>
<a name="ln1132">				for (int32 index = 2; index &lt; count; index++)</a>
<a name="ln1133">					menu-&gt;ItemAt(index)-&gt;SetMarked(false);</a>
<a name="ln1134"> </a>
<a name="ln1135">				// make all disks the title and check it</a>
<a name="ln1136">				PopUpMenuSetTitle(menu, menu-&gt;ItemAt(0)-&gt;Label());</a>
<a name="ln1137">				menu-&gt;ItemAt(0)-&gt;SetMarked(true);</a>
<a name="ln1138">			} else {</a>
<a name="ln1139">				// a specific volume selected, unmark &quot;all disks&quot;</a>
<a name="ln1140">				menu-&gt;ItemAt(0)-&gt;SetMarked(false);</a>
<a name="ln1141"> </a>
<a name="ln1142">				// toggle mark on invoked item</a>
<a name="ln1143">				int32 count = menu-&gt;CountItems();</a>
<a name="ln1144">				for (int32 index = 2; index &lt; count; index++) {</a>
<a name="ln1145">					BMenuItem* item = menu-&gt;ItemAt(index);</a>
<a name="ln1146"> </a>
<a name="ln1147">					if (invokedItem == item) {</a>
<a name="ln1148">						// we just selected this</a>
<a name="ln1149">						bool wasMarked = item-&gt;IsMarked();</a>
<a name="ln1150">						item-&gt;SetMarked(!wasMarked);</a>
<a name="ln1151">					}</a>
<a name="ln1152">				}</a>
<a name="ln1153">			}</a>
<a name="ln1154">			// make sure the right label is showing</a>
<a name="ln1155">			ShowVolumeMenuLabel();</a>
<a name="ln1156"> </a>
<a name="ln1157">			break;</a>
<a name="ln1158">		}</a>
<a name="ln1159"> </a>
<a name="ln1160">		case kByAttributeItem:</a>
<a name="ln1161">		case kByNameItem:</a>
<a name="ln1162">		case kByFormulaItem:</a>
<a name="ln1163">			SwitchMode(message-&gt;what);</a>
<a name="ln1164">			break;</a>
<a name="ln1165"> </a>
<a name="ln1166">		case kAddItem:</a>
<a name="ln1167">			AddAttrRow();</a>
<a name="ln1168">			break;</a>
<a name="ln1169"> </a>
<a name="ln1170">		case kRemoveItem:</a>
<a name="ln1171">			RemoveAttrRow();</a>
<a name="ln1172">			break;</a>
<a name="ln1173"> </a>
<a name="ln1174">		case kMIMETypeItem:</a>
<a name="ln1175">		{</a>
<a name="ln1176">			if (fMode == kByAttributeItem) {</a>
<a name="ln1177">				// the attributes for this type may be different</a>
<a name="ln1178">				RemoveAttrViewItems(false);</a>
<a name="ln1179">				AddAttrRow();</a>
<a name="ln1180">			}</a>
<a name="ln1181"> </a>
<a name="ln1182">			BMenuItem* item;</a>
<a name="ln1183">			if (message-&gt;FindPointer(&quot;source&quot;, (void**)&amp;item) == B_OK) {</a>
<a name="ln1184">				// don't add the &quot;All files and folders&quot; to the list</a>
<a name="ln1185">				if (fMimeTypeMenu-&gt;IndexOf(item) != 0)</a>
<a name="ln1186">					gMostUsedMimeTypes.AddName(item-&gt;Label());</a>
<a name="ln1187"> </a>
<a name="ln1188">				SetCurrentMimeType(item);</a>
<a name="ln1189">			}</a>
<a name="ln1190"> </a>
<a name="ln1191">			break;</a>
<a name="ln1192">		}</a>
<a name="ln1193"> </a>
<a name="ln1194">		case kNameModifiedMessage:</a>
<a name="ln1195">			// the query name was edited, make the query permanent</a>
<a name="ln1196">			fTemporaryCheck-&gt;SetValue(0);</a>
<a name="ln1197">			break;</a>
<a name="ln1198"> </a>
<a name="ln1199">		case kAttributeItem:</a>
<a name="ln1200">			if (message-&gt;FindPointer(&quot;source&quot;, (void**)&amp;item) != B_OK)</a>
<a name="ln1201">				return;</a>
<a name="ln1202"> </a>
<a name="ln1203">			item-&gt;Menu()-&gt;Superitem()-&gt;SetMarked(true);</a>
<a name="ln1204">			Invalidate();</a>
<a name="ln1205">			break;</a>
<a name="ln1206"> </a>
<a name="ln1207">		case kAttributeItemMain:</a>
<a name="ln1208">			// in case someone selected just an attribute without the</a>
<a name="ln1209">			// comparator</a>
<a name="ln1210">			if (message-&gt;FindPointer(&quot;source&quot;, (void**)&amp;item) != B_OK)</a>
<a name="ln1211">				return;</a>
<a name="ln1212"> </a>
<a name="ln1213">			if (item-&gt;Submenu()-&gt;ItemAt(0) != NULL)</a>
<a name="ln1214">				item-&gt;Submenu()-&gt;ItemAt(0)-&gt;SetMarked(true);</a>
<a name="ln1215"> </a>
<a name="ln1216">			Invalidate();</a>
<a name="ln1217">			break;</a>
<a name="ln1218"> </a>
<a name="ln1219">		case kLatchChanged:</a>
<a name="ln1220">		{</a>
<a name="ln1221">			int32 value;</a>
<a name="ln1222">			if (message-&gt;FindInt32(&quot;be:value&quot;, &amp;value) != B_OK)</a>
<a name="ln1223">				break;</a>
<a name="ln1224"> </a>
<a name="ln1225">			if (value == 0 &amp;&amp; !fMoreOptions-&gt;IsHidden(this))</a>
<a name="ln1226">				fMoreOptions-&gt;Hide();</a>
<a name="ln1227">			else if (value == 1 &amp;&amp; fMoreOptions-&gt;IsHidden(this))</a>
<a name="ln1228">				fMoreOptions-&gt;Show();</a>
<a name="ln1229"> </a>
<a name="ln1230">			break;</a>
<a name="ln1231">		}</a>
<a name="ln1232"> </a>
<a name="ln1233">		case B_SAVE_REQUESTED:</a>
<a name="ln1234">		{</a>
<a name="ln1235">			// finish saving query template from a SaveAs panel</a>
<a name="ln1236">			entry_ref ref;</a>
<a name="ln1237">			status_t error = message-&gt;FindRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln1238"> </a>
<a name="ln1239">			if (error == B_OK) {</a>
<a name="ln1240">				// direct entry selected, convert to parent dir and name</a>
<a name="ln1241">				BEntry entry(&amp;ref);</a>
<a name="ln1242">				error = entry.GetParent(&amp;entry);</a>
<a name="ln1243">				if (error == B_OK) {</a>
<a name="ln1244">					entry.GetRef(&amp;dir);</a>
<a name="ln1245">					name = ref.name;</a>
<a name="ln1246">				}</a>
<a name="ln1247">			} else {</a>
<a name="ln1248">				// parent dir and name selected</a>
<a name="ln1249">				error = message-&gt;FindRef(&quot;directory&quot;, &amp;dir);</a>
<a name="ln1250">				if (error == B_OK)</a>
<a name="ln1251">					error = message-&gt;FindString(&quot;name&quot;, &amp;name);</a>
<a name="ln1252">			}</a>
<a name="ln1253"> </a>
<a name="ln1254">			if (error == B_OK)</a>
<a name="ln1255">				SaveAsQueryOrTemplate(&amp;dir, name, true);</a>
<a name="ln1256"> </a>
<a name="ln1257">			break;</a>
<a name="ln1258">		}</a>
<a name="ln1259"> </a>
<a name="ln1260">		case B_COPY_TARGET:</a>
<a name="ln1261">		{</a>
<a name="ln1262">			// finish drag&amp;drop</a>
<a name="ln1263">			const char* str;</a>
<a name="ln1264">			const char* mimeType = NULL;</a>
<a name="ln1265">			const char* actionSpecifier = NULL;</a>
<a name="ln1266"> </a>
<a name="ln1267">			if (message-&gt;FindString(&quot;be:types&quot;, &amp;str) == B_OK</a>
<a name="ln1268">				&amp;&amp; strcasecmp(str, B_FILE_MIME_TYPE) == 0</a>
<a name="ln1269">				&amp;&amp; (message-&gt;FindString(&quot;be:actionspecifier&quot;,</a>
<a name="ln1270">						&amp;actionSpecifier) == B_OK</a>
<a name="ln1271">					|| message-&gt;FindString(&quot;be:filetypes&quot;, &amp;mimeType) == B_OK)</a>
<a name="ln1272">				&amp;&amp; message-&gt;FindString(&quot;name&quot;, &amp;name) == B_OK</a>
<a name="ln1273">				&amp;&amp; message-&gt;FindRef(&quot;directory&quot;, &amp;dir) == B_OK) {</a>
<a name="ln1274"> </a>
<a name="ln1275">				bool query = false;</a>
<a name="ln1276">				bool queryTemplate = false;</a>
<a name="ln1277"> </a>
<a name="ln1278">				if (actionSpecifier</a>
<a name="ln1279">					&amp;&amp; strcasecmp(actionSpecifier,</a>
<a name="ln1280">						B_TRANSLATE_NOCOLLECT(</a>
<a name="ln1281">							kDragNDropActionSpecifiers[0])) == 0) {</a>
<a name="ln1282">					query = true;</a>
<a name="ln1283">				} else if (actionSpecifier</a>
<a name="ln1284">					&amp;&amp; strcasecmp(actionSpecifier,</a>
<a name="ln1285">						B_TRANSLATE_NOCOLLECT(</a>
<a name="ln1286">							kDragNDropActionSpecifiers[1])) == 0) {</a>
<a name="ln1287">					queryTemplate = true;</a>
<a name="ln1288">				} else if (mimeType &amp;&amp; strcasecmp(mimeType,</a>
<a name="ln1289">						kDragNDropTypes[0]) == 0) {</a>
<a name="ln1290">					query = true;</a>
<a name="ln1291">				} else if (mimeType &amp;&amp; strcasecmp(mimeType,</a>
<a name="ln1292">					kDragNDropTypes[1]) == 0) {</a>
<a name="ln1293">					queryTemplate = true;</a>
<a name="ln1294">				}</a>
<a name="ln1295"> </a>
<a name="ln1296">				if (query || queryTemplate)</a>
<a name="ln1297">					SaveAsQueryOrTemplate(&amp;dir, name, queryTemplate);</a>
<a name="ln1298">			}</a>
<a name="ln1299"> </a>
<a name="ln1300">			break;</a>
<a name="ln1301">		}</a>
<a name="ln1302"> </a>
<a name="ln1303">		default:</a>
<a name="ln1304">			_inherited::MessageReceived(message);</a>
<a name="ln1305">			break;</a>
<a name="ln1306">	}</a>
<a name="ln1307">}</a>
<a name="ln1308"> </a>
<a name="ln1309"> </a>
<a name="ln1310">void</a>
<a name="ln1311">FindPanel::SaveAsQueryOrTemplate(const entry_ref* dir, const char* name,</a>
<a name="ln1312">	bool queryTemplate)</a>
<a name="ln1313">{</a>
<a name="ln1314">	BDirectory directory(dir);</a>
<a name="ln1315">	BFile file(&amp;directory, name, O_RDWR | O_CREAT | O_TRUNC);</a>
<a name="ln1316">	BNodeInfo(&amp;file).SetType(queryTemplate</a>
<a name="ln1317">		? B_QUERY_TEMPLATE_MIMETYPE : B_QUERY_MIMETYPE);</a>
<a name="ln1318"> </a>
<a name="ln1319">	BMessage attach(kAttachFile);</a>
<a name="ln1320">	attach.AddRef(&quot;directory&quot;, dir);</a>
<a name="ln1321">	attach.AddString(&quot;name&quot;, name);</a>
<a name="ln1322">	attach.AddBool(&quot;template&quot;, queryTemplate);</a>
<a name="ln1323">	Window()-&gt;PostMessage(&amp;attach, 0);</a>
<a name="ln1324">}</a>
<a name="ln1325"> </a>
<a name="ln1326"> </a>
<a name="ln1327">BView*</a>
<a name="ln1328">FindPanel::FindAttrView(const char* name, int row) const</a>
<a name="ln1329">{</a>
<a name="ln1330">	for (int32 index = 0; index &lt; fAttrGrid-&gt;CountColumns(); index++) {</a>
<a name="ln1331"> </a>
<a name="ln1332">		BLayoutItem* item = fAttrGrid-&gt;ItemAt(index, row);</a>
<a name="ln1333">		if (item == NULL)</a>
<a name="ln1334">			continue;</a>
<a name="ln1335"> </a>
<a name="ln1336">		BView* view = item-&gt;View();</a>
<a name="ln1337">		if (view == NULL)</a>
<a name="ln1338">			continue;</a>
<a name="ln1339"> </a>
<a name="ln1340">		view = view-&gt;FindView(name);</a>
<a name="ln1341">		if (view != NULL)</a>
<a name="ln1342">			return view;</a>
<a name="ln1343"> </a>
<a name="ln1344">	}</a>
<a name="ln1345"> </a>
<a name="ln1346">	return NULL;</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349">void</a>
<a name="ln1350">FindPanel::BuildAttrQuery(BQuery* query, bool &amp;dynamicDate) const</a>
<a name="ln1351">{</a>
<a name="ln1352">	dynamicDate = false;</a>
<a name="ln1353"> </a>
<a name="ln1354">	// go through each attrview and add the attr and comparison info</a>
<a name="ln1355">	for (int32 index = 0; index &lt; fAttrGrid-&gt;CountRows(); index++) {</a>
<a name="ln1356"> </a>
<a name="ln1357">		BString title;</a>
<a name="ln1358">		title &lt;&lt; &quot;TextEntry&quot; &lt;&lt; index;</a>
<a name="ln1359"> </a>
<a name="ln1360">		BTextControl* textControl = dynamic_cast&lt;BTextControl*&gt;(</a>
<a name="ln1361">			FindAttrView(title, index));</a>
<a name="ln1362">		if (textControl == NULL)</a>
<a name="ln1363">			return;</a>
<a name="ln1364"> </a>
<a name="ln1365">		BMenuField* menuField = dynamic_cast&lt;BMenuField*&gt;(</a>
<a name="ln1366">			FindAttrView(&quot;MenuField&quot;, index));</a>
<a name="ln1367">		if (menuField == NULL)</a>
<a name="ln1368">			return;</a>
<a name="ln1369"> </a>
<a name="ln1370">		BMenuItem* item = menuField-&gt;Menu()-&gt;FindMarked();</a>
<a name="ln1371">		if (item == NULL)</a>
<a name="ln1372">			continue;</a>
<a name="ln1373"> </a>
<a name="ln1374">		BMessage* message = item-&gt;Message();</a>
<a name="ln1375">		int32 type;</a>
<a name="ln1376">		if (message-&gt;FindInt32(&quot;type&quot;, &amp;type) == B_OK) {</a>
<a name="ln1377"> </a>
<a name="ln1378">			const char* str;</a>
<a name="ln1379">			if (message-&gt;FindString(&quot;name&quot;, &amp;str) == B_OK)</a>
<a name="ln1380">				query-&gt;PushAttr(str);</a>
<a name="ln1381">			else</a>
<a name="ln1382">				query-&gt;PushAttr(item-&gt;Label());</a>
<a name="ln1383"> </a>
<a name="ln1384">			switch (type) {</a>
<a name="ln1385">				case B_STRING_TYPE:</a>
<a name="ln1386">					query-&gt;PushString(textControl-&gt;Text(), true);</a>
<a name="ln1387">					break;</a>
<a name="ln1388"> </a>
<a name="ln1389">				case B_TIME_TYPE:</a>
<a name="ln1390">				{</a>
<a name="ln1391">					int flags = 0;</a>
<a name="ln1392">					DEBUG_ONLY(time_t result =)</a>
<a name="ln1393">					parsedate_etc(textControl-&gt;Text(), -1,</a>
<a name="ln1394">						&amp;flags);</a>
<a name="ln1395">					dynamicDate = (flags &amp; PARSEDATE_RELATIVE_TIME) != 0;</a>
<a name="ln1396">					PRINT((&quot;parsedate_etc - date is %srelative, %&quot;</a>
<a name="ln1397">						B_PRIdTIME &quot;\n&quot;,</a>
<a name="ln1398">						dynamicDate ? &quot;&quot; : &quot;not &quot;, result));</a>
<a name="ln1399"> </a>
<a name="ln1400">					query-&gt;PushDate(textControl-&gt;Text());</a>
<a name="ln1401">					break;</a>
<a name="ln1402">				}</a>
<a name="ln1403"> </a>
<a name="ln1404">				case B_BOOL_TYPE:</a>
<a name="ln1405">				{</a>
<a name="ln1406">					uint32 value;</a>
<a name="ln1407">					if (strcasecmp(textControl-&gt;Text(),</a>
<a name="ln1408">							&quot;true&quot;) == 0) {</a>
<a name="ln1409">						value = 1;</a>
<a name="ln1410">					} else if (strcasecmp(textControl-&gt;Text(),</a>
<a name="ln1411">							&quot;true&quot;) == 0) {</a>
<a name="ln1412">						value = 1;</a>
<a name="ln1413">					} else</a>
<a name="ln1414">						value = (uint32)atoi(textControl-&gt;Text());</a>
<a name="ln1415"> </a>
<a name="ln1416">					value %= 2;</a>
<a name="ln1417">					query-&gt;PushUInt32(value);</a>
<a name="ln1418">					break;</a>
<a name="ln1419">				}</a>
<a name="ln1420"> </a>
<a name="ln1421">				case B_UINT8_TYPE:</a>
<a name="ln1422">				case B_UINT16_TYPE:</a>
<a name="ln1423">				case B_UINT32_TYPE:</a>
<a name="ln1424">					query-&gt;PushUInt32((uint32)StringToScalar(</a>
<a name="ln1425">						textControl-&gt;Text()));</a>
<a name="ln1426">					break;</a>
<a name="ln1427"> </a>
<a name="ln1428">				case B_INT8_TYPE:</a>
<a name="ln1429">				case B_INT16_TYPE:</a>
<a name="ln1430">				case B_INT32_TYPE:</a>
<a name="ln1431">					query-&gt;PushInt32((int32)StringToScalar(</a>
<a name="ln1432">						textControl-&gt;Text()));</a>
<a name="ln1433">					break;</a>
<a name="ln1434"> </a>
<a name="ln1435">				case B_UINT64_TYPE:</a>
<a name="ln1436">					query-&gt;PushUInt64((uint64)StringToScalar(</a>
<a name="ln1437">						textControl-&gt;Text()));</a>
<a name="ln1438">					break;</a>
<a name="ln1439"> </a>
<a name="ln1440">				case B_OFF_T_TYPE:</a>
<a name="ln1441">				case B_INT64_TYPE:</a>
<a name="ln1442">					query-&gt;PushInt64(StringToScalar(</a>
<a name="ln1443">						textControl-&gt;Text()));</a>
<a name="ln1444">					break;</a>
<a name="ln1445"> </a>
<a name="ln1446">				case B_FLOAT_TYPE:</a>
<a name="ln1447">				{</a>
<a name="ln1448">					float floatVal;</a>
<a name="ln1449">					sscanf(textControl-&gt;Text(), &quot;%f&quot;,</a>
<a name="ln1450">						&amp;floatVal);</a>
<a name="ln1451">					query-&gt;PushFloat(floatVal);</a>
<a name="ln1452">					break;</a>
<a name="ln1453">				}</a>
<a name="ln1454"> </a>
<a name="ln1455">				case B_DOUBLE_TYPE:</a>
<a name="ln1456">				{</a>
<a name="ln1457">					double doubleVal;</a>
<a name="ln1458">					sscanf(textControl-&gt;Text(), &quot;%lf&quot;,</a>
<a name="ln1459">						&amp;doubleVal);</a>
<a name="ln1460">					query-&gt;PushDouble(doubleVal);</a>
<a name="ln1461">					break;</a>
<a name="ln1462">				}</a>
<a name="ln1463">			}</a>
<a name="ln1464">		}</a>
<a name="ln1465"> </a>
<a name="ln1466">		query_op theOperator;</a>
<a name="ln1467">		BMenuItem* operatorItem = item-&gt;Submenu()-&gt;FindMarked();</a>
<a name="ln1468">		if (operatorItem &amp;&amp; operatorItem-&gt;Message() != NULL) {</a>
<a name="ln1469">			operatorItem-&gt;Message()-&gt;FindInt32(&quot;operator&quot;,</a>
<a name="ln1470">				(int32*)&amp;theOperator);</a>
<a name="ln1471">			query-&gt;PushOp(theOperator);</a>
<a name="ln1472">		} else</a>
<a name="ln1473">			query-&gt;PushOp(B_EQ);</a>
<a name="ln1474"> </a>
<a name="ln1475">		// add logic based on selection in Logic menufield</a>
<a name="ln1476">		if (index &gt; 0) {</a>
<a name="ln1477">			menuField = dynamic_cast&lt;BMenuField*&gt;(</a>
<a name="ln1478">				FindAttrView(&quot;Logic&quot;, index - 1));</a>
<a name="ln1479">			if (menuField) {</a>
<a name="ln1480">				item = menuField-&gt;Menu()-&gt;FindMarked();</a>
<a name="ln1481">				if (item) {</a>
<a name="ln1482">					message = item-&gt;Message();</a>
<a name="ln1483">					message-&gt;FindInt32(&quot;combine&quot;, (int32*)&amp;theOperator);</a>
<a name="ln1484">					query-&gt;PushOp(theOperator);</a>
<a name="ln1485">				}</a>
<a name="ln1486">			} else</a>
<a name="ln1487">				query-&gt;PushOp(B_AND);</a>
<a name="ln1488">		}</a>
<a name="ln1489">	}</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492"> </a>
<a name="ln1493">void</a>
<a name="ln1494">FindPanel::PushMimeType(BQuery* query) const</a>
<a name="ln1495">{</a>
<a name="ln1496">	const char* type;</a>
<a name="ln1497">	if (CurrentMimeType(&amp;type) == NULL)</a>
<a name="ln1498">		return;</a>
<a name="ln1499"> </a>
<a name="ln1500">	if (strcmp(kAllMimeTypes, type)) {</a>
<a name="ln1501">		// add an asterisk if we are searching for a supertype</a>
<a name="ln1502">		char buffer[B_FILE_NAME_LENGTH];</a>
<a name="ln1503">		if (strchr(type, '/') == NULL) {</a>
<a name="ln1504">			strlcpy(buffer, type, sizeof(buffer));</a>
<a name="ln1505">			strlcat(buffer, &quot;/*&quot;, sizeof(buffer));</a>
<a name="ln1506">			type = buffer;</a>
<a name="ln1507">		}</a>
<a name="ln1508"> </a>
<a name="ln1509">		query-&gt;PushAttr(kAttrMIMEType);</a>
<a name="ln1510">		query-&gt;PushString(type);</a>
<a name="ln1511">		query-&gt;PushOp(B_EQ);</a>
<a name="ln1512">		query-&gt;PushOp(B_AND);</a>
<a name="ln1513">	}</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516"> </a>
<a name="ln1517">void</a>
<a name="ln1518">FindPanel::GetByAttrPredicate(BQuery* query, bool &amp;dynamicDate) const</a>
<a name="ln1519">{</a>
<a name="ln1520">	ASSERT(Mode() == (int32)kByAttributeItem);</a>
<a name="ln1521">	BuildAttrQuery(query, dynamicDate);</a>
<a name="ln1522">	PushMimeType(query);</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525"> </a>
<a name="ln1526">void</a>
<a name="ln1527">FindPanel::GetDefaultName(BString&amp; name) const</a>
<a name="ln1528">{</a>
<a name="ln1529">	BTextControl* textControl = dynamic_cast&lt;BTextControl*&gt;(</a>
<a name="ln1530">		FindView(&quot;TextControl&quot;));</a>
<a name="ln1531"> </a>
<a name="ln1532">	switch (Mode()) {</a>
<a name="ln1533">		case kByNameItem:</a>
<a name="ln1534">			if (textControl != NULL) {</a>
<a name="ln1535">				name.SetTo(B_TRANSLATE_COMMENT(&quot;Name = %name&quot;,</a>
<a name="ln1536">					&quot;FindResultTitle&quot;));</a>
<a name="ln1537">				name.ReplaceFirst(&quot;%name&quot;, textControl-&gt;Text());</a>
<a name="ln1538">			}</a>
<a name="ln1539">			break;</a>
<a name="ln1540"> </a>
<a name="ln1541">		case kByFormulaItem:</a>
<a name="ln1542">			if (textControl != NULL) {</a>
<a name="ln1543">				name.SetTo(B_TRANSLATE_COMMENT(&quot;Formula %formula&quot;,</a>
<a name="ln1544">					&quot;FindResultTitle&quot;));</a>
<a name="ln1545">				name.ReplaceFirst(&quot;%formula&quot;, textControl-&gt;Text());</a>
<a name="ln1546">			}</a>
<a name="ln1547">			break;</a>
<a name="ln1548"> </a>
<a name="ln1549">		case kByAttributeItem:</a>
<a name="ln1550">		{</a>
<a name="ln1551">			BMenuItem* item = fMimeTypeMenu-&gt;FindMarked();</a>
<a name="ln1552">			if (item != NULL)</a>
<a name="ln1553">				name &lt;&lt; item-&gt;Label() &lt;&lt; &quot;: &quot;;</a>
<a name="ln1554"> </a>
<a name="ln1555">			for (int32 i = 0; i &lt; fAttrGrid-&gt;CountRows(); i++) {</a>
<a name="ln1556">				GetDefaultAttrName(name, i);</a>
<a name="ln1557">				if (i + 1 &lt; fAttrGrid-&gt;CountRows())</a>
<a name="ln1558">					name &lt;&lt; &quot;, &quot;;</a>
<a name="ln1559">			}</a>
<a name="ln1560">			break;</a>
<a name="ln1561">		}</a>
<a name="ln1562">	}</a>
<a name="ln1563">}</a>
<a name="ln1564"> </a>
<a name="ln1565"> </a>
<a name="ln1566">const char*</a>
<a name="ln1567">FindPanel::UserSpecifiedName() const</a>
<a name="ln1568">{</a>
<a name="ln1569">	if (fQueryName-&gt;Text()[0] == '\0')</a>
<a name="ln1570">		return NULL;</a>
<a name="ln1571"> </a>
<a name="ln1572">	return fQueryName-&gt;Text();</a>
<a name="ln1573">}</a>
<a name="ln1574"> </a>
<a name="ln1575"> </a>
<a name="ln1576">void</a>
<a name="ln1577">FindPanel::GetByNamePredicate(BQuery* query) const</a>
<a name="ln1578">{</a>
<a name="ln1579">	ASSERT(Mode() == (int32)kByNameItem);</a>
<a name="ln1580"> </a>
<a name="ln1581">	BTextControl* textControl</a>
<a name="ln1582">		= dynamic_cast&lt;BTextControl*&gt;(FindView(&quot;TextControl&quot;));</a>
<a name="ln1583"> </a>
<a name="ln1584">	ASSERT(textControl != NULL);</a>
<a name="ln1585"> </a>
<a name="ln1586">	if (textControl == NULL)</a>
<a name="ln1587">		return;</a>
<a name="ln1588"> </a>
<a name="ln1589">	query-&gt;PushAttr(&quot;name&quot;);</a>
<a name="ln1590">	query-&gt;PushString(textControl-&gt;Text(), true);</a>
<a name="ln1591"> </a>
<a name="ln1592">	if (strstr(textControl-&gt;Text(), &quot;*&quot;) != NULL) {</a>
<a name="ln1593">		// assume pattern is a regular expression, try doing an exact match</a>
<a name="ln1594">		query-&gt;PushOp(B_EQ);</a>
<a name="ln1595">	} else</a>
<a name="ln1596">		query-&gt;PushOp(B_CONTAINS);</a>
<a name="ln1597"> </a>
<a name="ln1598">	PushMimeType(query);</a>
<a name="ln1599">}</a>
<a name="ln1600"> </a>
<a name="ln1601"> </a>
<a name="ln1602">void</a>
<a name="ln1603">FindPanel::SwitchMode(uint32 mode)</a>
<a name="ln1604">{</a>
<a name="ln1605">	if (fMode == mode)</a>
<a name="ln1606">		// no work, bail</a>
<a name="ln1607">		return;</a>
<a name="ln1608"> </a>
<a name="ln1609">	uint32 oldMode = fMode;</a>
<a name="ln1610">	BString buffer;</a>
<a name="ln1611"> </a>
<a name="ln1612">	switch (mode) {</a>
<a name="ln1613">		case kByFormulaItem:</a>
<a name="ln1614">		{</a>
<a name="ln1615">			if (oldMode == kByAttributeItem || oldMode == kByNameItem) {</a>
<a name="ln1616">				BQuery query;</a>
<a name="ln1617">				if (oldMode == kByAttributeItem) {</a>
<a name="ln1618">					bool dummy;</a>
<a name="ln1619">					GetByAttrPredicate(&amp;query, dummy);</a>
<a name="ln1620">				} else</a>
<a name="ln1621">					GetByNamePredicate(&amp;query);</a>
<a name="ln1622"> </a>
<a name="ln1623">				query.GetPredicate(&amp;buffer);</a>
<a name="ln1624">			}</a>
<a name="ln1625">		}</a>
<a name="ln1626">		// fall-through</a>
<a name="ln1627">		case kByNameItem:</a>
<a name="ln1628">		{</a>
<a name="ln1629">			fMode = mode;</a>
<a name="ln1630">			RemoveByAttributeItems();</a>
<a name="ln1631">			ShowOrHideMimeTypeMenu();</a>
<a name="ln1632">			AddByNameOrFormulaItems();</a>
<a name="ln1633"> </a>
<a name="ln1634">			if (buffer.Length() &gt; 0) {</a>
<a name="ln1635">				ASSERT(mode == kByFormulaItem</a>
<a name="ln1636">					|| oldMode == kByAttributeItem);</a>
<a name="ln1637">				BTextControl* textControl</a>
<a name="ln1638">					= dynamic_cast&lt;BTextControl*&gt;(FindView(&quot;TextControl&quot;));</a>
<a name="ln1639">				if (textControl != NULL)</a>
<a name="ln1640">					textControl-&gt;SetText(buffer.String());</a>
<a name="ln1641">			}</a>
<a name="ln1642">			break;</a>
<a name="ln1643">		}</a>
<a name="ln1644"> </a>
<a name="ln1645">		case kByAttributeItem:</a>
<a name="ln1646">		{</a>
<a name="ln1647">			fMode = mode;</a>
<a name="ln1648">			BTextControl* textControl</a>
<a name="ln1649">				= dynamic_cast&lt;BTextControl*&gt;(FindView(&quot;TextControl&quot;));</a>
<a name="ln1650">			if (textControl != NULL) {</a>
<a name="ln1651">				textControl-&gt;RemoveSelf();</a>
<a name="ln1652">				delete textControl;</a>
<a name="ln1653">			}</a>
<a name="ln1654"> </a>
<a name="ln1655">			ShowOrHideMimeTypeMenu();</a>
<a name="ln1656">			AddAttrRow();</a>
<a name="ln1657">			break;</a>
<a name="ln1658">		}</a>
<a name="ln1659">	}</a>
<a name="ln1660">}</a>
<a name="ln1661"> </a>
<a name="ln1662"> </a>
<a name="ln1663">BMenuItem*</a>
<a name="ln1664">FindPanel::CurrentMimeType(const char** type) const</a>
<a name="ln1665">{</a>
<a name="ln1666">	// search for marked item in the list</a>
<a name="ln1667">	BMenuItem* item = MimeTypeMenu()-&gt;FindMarked();</a>
<a name="ln1668"> </a>
<a name="ln1669">	if (item != NULL &amp;&amp; MimeTypeMenu()-&gt;IndexOf(item) != 0</a>
<a name="ln1670">		&amp;&amp; item-&gt;Submenu() == NULL) {</a>
<a name="ln1671">		// if it's one of the most used items, ignore it</a>
<a name="ln1672">		item = NULL;</a>
<a name="ln1673">	}</a>
<a name="ln1674"> </a>
<a name="ln1675">	if (item == NULL) {</a>
<a name="ln1676">		for (int32 index = MimeTypeMenu()-&gt;CountItems(); index-- &gt; 0;) {</a>
<a name="ln1677">			BMenu* submenu = MimeTypeMenu()-&gt;ItemAt(index)-&gt;Submenu();</a>
<a name="ln1678">			if (submenu != NULL &amp;&amp; (item = submenu-&gt;FindMarked()) != NULL)</a>
<a name="ln1679">				break;</a>
<a name="ln1680">		}</a>
<a name="ln1681">	}</a>
<a name="ln1682"> </a>
<a name="ln1683">	if (type != NULL &amp;&amp; item != NULL) {</a>
<a name="ln1684">		BMessage* message = item-&gt;Message();</a>
<a name="ln1685">		if (message == NULL)</a>
<a name="ln1686">			return NULL;</a>
<a name="ln1687"> </a>
<a name="ln1688">		if (message-&gt;FindString(&quot;mimetype&quot;, type) != B_OK)</a>
<a name="ln1689">			return NULL;</a>
<a name="ln1690">	}</a>
<a name="ln1691">	return item;</a>
<a name="ln1692">}</a>
<a name="ln1693"> </a>
<a name="ln1694"> </a>
<a name="ln1695">status_t</a>
<a name="ln1696">FindPanel::SetCurrentMimeType(BMenuItem* item)</a>
<a name="ln1697">{</a>
<a name="ln1698">	// unmark old MIME type (in most used list, and the tree)</a>
<a name="ln1699"> </a>
<a name="ln1700">	BMenuItem* marked = CurrentMimeType();</a>
<a name="ln1701">	if (marked != NULL) {</a>
<a name="ln1702">		marked-&gt;SetMarked(false);</a>
<a name="ln1703"> </a>
<a name="ln1704">		if ((marked = MimeTypeMenu()-&gt;FindMarked()) != NULL)</a>
<a name="ln1705">			marked-&gt;SetMarked(false);</a>
<a name="ln1706">	}</a>
<a name="ln1707"> </a>
<a name="ln1708">	// mark new MIME type (in most used list, and the tree)</a>
<a name="ln1709"> </a>
<a name="ln1710">	if (item != NULL) {</a>
<a name="ln1711">		item-&gt;SetMarked(true);</a>
<a name="ln1712">		fMimeTypeField-&gt;MenuItem()-&gt;SetLabel(item-&gt;Label());</a>
<a name="ln1713"> </a>
<a name="ln1714">		BMenuItem* search;</a>
<a name="ln1715">		for (int32 i = 2; (search = MimeTypeMenu()-&gt;ItemAt(i)) != NULL; i++) {</a>
<a name="ln1716">			if (item == search || search-&gt;Label() == NULL)</a>
<a name="ln1717">				continue;</a>
<a name="ln1718"> </a>
<a name="ln1719">			if (strcmp(item-&gt;Label(), search-&gt;Label()) == 0) {</a>
<a name="ln1720">				search-&gt;SetMarked(true);</a>
<a name="ln1721">				break;</a>
<a name="ln1722">			}</a>
<a name="ln1723"> </a>
<a name="ln1724">			BMenu* submenu = search-&gt;Submenu();</a>
<a name="ln1725">			if (submenu == NULL)</a>
<a name="ln1726">				continue;</a>
<a name="ln1727"> </a>
<a name="ln1728">			for (int32 j = submenu-&gt;CountItems(); j-- &gt; 0;) {</a>
<a name="ln1729">				BMenuItem* sub = submenu-&gt;ItemAt(j);</a>
<a name="ln1730">				if (strcmp(item-&gt;Label(), sub-&gt;Label()) == 0) {</a>
<a name="ln1731">					sub-&gt;SetMarked(true);</a>
<a name="ln1732">					break;</a>
<a name="ln1733">				}</a>
<a name="ln1734">			}</a>
<a name="ln1735">		}</a>
<a name="ln1736">	}</a>
<a name="ln1737"> </a>
<a name="ln1738">	return B_OK;</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741"> </a>
<a name="ln1742">status_t</a>
<a name="ln1743">FindPanel::SetCurrentMimeType(const char* label)</a>
<a name="ln1744">{</a>
<a name="ln1745">	// unmark old MIME type (in most used list, and the tree)</a>
<a name="ln1746"> </a>
<a name="ln1747">	BMenuItem* marked = CurrentMimeType();</a>
<a name="ln1748">	if (marked != NULL) {</a>
<a name="ln1749">		marked-&gt;SetMarked(false);</a>
<a name="ln1750"> </a>
<a name="ln1751">		if ((marked = MimeTypeMenu()-&gt;FindMarked()) != NULL)</a>
<a name="ln1752">			marked-&gt;SetMarked(false);</a>
<a name="ln1753">	}</a>
<a name="ln1754"> </a>
<a name="ln1755">	// mark new MIME type (in most used list, and the tree)</a>
<a name="ln1756"> </a>
<a name="ln1757">	fMimeTypeField-&gt;MenuItem()-&gt;SetLabel(label);</a>
<a name="ln1758">	bool found = false;</a>
<a name="ln1759"> </a>
<a name="ln1760">	for (int32 index = MimeTypeMenu()-&gt;CountItems(); index-- &gt; 0;) {</a>
<a name="ln1761">		BMenuItem* item = MimeTypeMenu()-&gt;ItemAt(index);</a>
<a name="ln1762">		BMenu* submenu = item-&gt;Submenu();</a>
<a name="ln1763">		if (submenu != NULL &amp;&amp; !found) {</a>
<a name="ln1764">			for (int32 subIndex = submenu-&gt;CountItems(); subIndex-- &gt; 0;) {</a>
<a name="ln1765">				BMenuItem* subItem = submenu-&gt;ItemAt(subIndex);</a>
<a name="ln1766">				if (subItem-&gt;Label() != NULL</a>
<a name="ln1767">					&amp;&amp; strcmp(label, subItem-&gt;Label()) == 0) {</a>
<a name="ln1768">					subItem-&gt;SetMarked(true);</a>
<a name="ln1769">					found = true;</a>
<a name="ln1770">				}</a>
<a name="ln1771">			}</a>
<a name="ln1772">		}</a>
<a name="ln1773"> </a>
<a name="ln1774">		if (item-&gt;Label() != NULL &amp;&amp; strcmp(label, item-&gt;Label()) == 0) {</a>
<a name="ln1775">			item-&gt;SetMarked(true);</a>
<a name="ln1776">			return B_OK;</a>
<a name="ln1777">		}</a>
<a name="ln1778">	}</a>
<a name="ln1779"> </a>
<a name="ln1780">	return found ? B_OK : B_ENTRY_NOT_FOUND;</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783"> </a>
<a name="ln1784">static</a>
<a name="ln1785">void AddSubtype(BString&amp; text, const BMimeType&amp; type)</a>
<a name="ln1786">{</a>
<a name="ln1787">	text.Append(&quot; (&quot;);</a>
<a name="ln1788">	text.Append(strchr(type.Type(), '/') + 1);</a>
<a name="ln1789">		// omit the slash</a>
<a name="ln1790">	text.Append(&quot;)&quot;);</a>
<a name="ln1791">}</a>
<a name="ln1792"> </a>
<a name="ln1793"> </a>
<a name="ln1794">bool</a>
<a name="ln1795">FindPanel::AddOneMimeTypeToMenu(const ShortMimeInfo* info, void* castToMenu)</a>
<a name="ln1796">{</a>
<a name="ln1797">	BPopUpMenu* menu = static_cast&lt;BPopUpMenu*&gt;(castToMenu);</a>
<a name="ln1798"> </a>
<a name="ln1799">	BMimeType type(info-&gt;InternalName());</a>
<a name="ln1800">	BMimeType super;</a>
<a name="ln1801">	type.GetSupertype(&amp;super);</a>
<a name="ln1802">	if (super.InitCheck() &lt; B_OK)</a>
<a name="ln1803">		return false;</a>
<a name="ln1804"> </a>
<a name="ln1805">	BMenuItem* superItem = menu-&gt;FindItem(super.Type());</a>
<a name="ln1806">	if (superItem != NULL) {</a>
<a name="ln1807">		BMessage* message = new BMessage(kMIMETypeItem);</a>
<a name="ln1808">		message-&gt;AddString(&quot;mimetype&quot;, info-&gt;InternalName());</a>
<a name="ln1809"> </a>
<a name="ln1810">		// check to ensure previous item's name differs</a>
<a name="ln1811">		BMenu* menu = superItem-&gt;Submenu();</a>
<a name="ln1812">		BMenuItem* previous = menu-&gt;ItemAt(menu-&gt;CountItems() - 1);</a>
<a name="ln1813">		BString text = info-&gt;ShortDescription();</a>
<a name="ln1814">		if (previous != NULL</a>
<a name="ln1815">			&amp;&amp; strcasecmp(previous-&gt;Label(), info-&gt;ShortDescription()) == 0) {</a>
<a name="ln1816">			AddSubtype(text, type);</a>
<a name="ln1817"> </a>
<a name="ln1818">			// update the previous item as well</a>
<a name="ln1819">			BMimeType type(previous-&gt;Message()-&gt;GetString(&quot;mimetype&quot;, NULL));</a>
<a name="ln1820">			BString label = ShortMimeInfo(type).ShortDescription();</a>
<a name="ln1821">			AddSubtype(label, type);</a>
<a name="ln1822">			previous-&gt;SetLabel(label.String());</a>
<a name="ln1823">		}</a>
<a name="ln1824"> </a>
<a name="ln1825">		menu-&gt;AddItem(new IconMenuItem(text.String(), message,</a>
<a name="ln1826">			info-&gt;InternalName()));</a>
<a name="ln1827">	}</a>
<a name="ln1828"> </a>
<a name="ln1829">	return false;</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832"> </a>
<a name="ln1833">void</a>
<a name="ln1834">FindPanel::AddMimeTypesToMenu()</a>
<a name="ln1835">{</a>
<a name="ln1836">	BMessage* itemMessage = new BMessage(kMIMETypeItem);</a>
<a name="ln1837">	itemMessage-&gt;AddString(&quot;mimetype&quot;, kAllMimeTypes);</a>
<a name="ln1838"> </a>
<a name="ln1839">	IconMenuItem* firstItem = new IconMenuItem(</a>
<a name="ln1840">		B_TRANSLATE(&quot;All files and folders&quot;), itemMessage,</a>
<a name="ln1841">		static_cast&lt;BBitmap*&gt;(NULL));</a>
<a name="ln1842">	MimeTypeMenu()-&gt;AddItem(firstItem);</a>
<a name="ln1843">	MimeTypeMenu()-&gt;AddSeparatorItem();</a>
<a name="ln1844"> </a>
<a name="ln1845">	// add recent MIME types</a>
<a name="ln1846"> </a>
<a name="ln1847">	TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln1848">	ASSERT(tracker != NULL);</a>
<a name="ln1849"> </a>
<a name="ln1850">	BList list;</a>
<a name="ln1851">	if (tracker != NULL &amp;&amp; gMostUsedMimeTypes.ObtainList(&amp;list)) {</a>
<a name="ln1852">		int32 count = 0;</a>
<a name="ln1853">		for (int32 index = 0; index &lt; list.CountItems(); index++) {</a>
<a name="ln1854">			const char* name = (const char*)list.ItemAt(index);</a>
<a name="ln1855"> </a>
<a name="ln1856">			MimeTypeList* mimeTypes = tracker-&gt;MimeTypes();</a>
<a name="ln1857">			if (mimeTypes != NULL) {</a>
<a name="ln1858">				const ShortMimeInfo* info = mimeTypes-&gt;FindMimeType(name);</a>
<a name="ln1859">				if (info == NULL)</a>
<a name="ln1860">					continue;</a>
<a name="ln1861"> </a>
<a name="ln1862">				BMessage* message = new BMessage(kMIMETypeItem);</a>
<a name="ln1863">				message-&gt;AddString(&quot;mimetype&quot;, info-&gt;InternalName());</a>
<a name="ln1864"> </a>
<a name="ln1865">				MimeTypeMenu()-&gt;AddItem(new BMenuItem(name, message));</a>
<a name="ln1866">				count++;</a>
<a name="ln1867">			}</a>
<a name="ln1868">		}</a>
<a name="ln1869">		if (count != 0)</a>
<a name="ln1870">			MimeTypeMenu()-&gt;AddSeparatorItem();</a>
<a name="ln1871"> </a>
<a name="ln1872">		gMostUsedMimeTypes.ReleaseList();</a>
<a name="ln1873">	}</a>
<a name="ln1874"> </a>
<a name="ln1875">	// add MIME type tree list</a>
<a name="ln1876"> </a>
<a name="ln1877">	BMessage types;</a>
<a name="ln1878">	if (BMimeType::GetInstalledSupertypes(&amp;types) == B_OK) {</a>
<a name="ln1879">		const char* superType;</a>
<a name="ln1880">		int32 index = 0;</a>
<a name="ln1881"> </a>
<a name="ln1882">		while (types.FindString(&quot;super_types&quot;, index++, &amp;superType) == B_OK) {</a>
<a name="ln1883">			BMenu* superMenu = new BMenu(superType);</a>
<a name="ln1884"> </a>
<a name="ln1885">			BMessage* message = new BMessage(kMIMETypeItem);</a>
<a name="ln1886">			message-&gt;AddString(&quot;mimetype&quot;, superType);</a>
<a name="ln1887"> </a>
<a name="ln1888">			MimeTypeMenu()-&gt;AddItem(new IconMenuItem(superMenu, message,</a>
<a name="ln1889">				superType));</a>
<a name="ln1890"> </a>
<a name="ln1891">			// the MimeTypeMenu's font is not correct at this time</a>
<a name="ln1892">			superMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln1893">		}</a>
<a name="ln1894">	}</a>
<a name="ln1895"> </a>
<a name="ln1896">	if (tracker != NULL) {</a>
<a name="ln1897">		tracker-&gt;MimeTypes()-&gt;EachCommonType(</a>
<a name="ln1898">			&amp;FindPanel::AddOneMimeTypeToMenu, MimeTypeMenu());</a>
<a name="ln1899">	}</a>
<a name="ln1900"> </a>
<a name="ln1901">	// remove empty super type menus (and set target)</a>
<a name="ln1902"> </a>
<a name="ln1903">	for (int32 index = MimeTypeMenu()-&gt;CountItems(); index-- &gt; 2;) {</a>
<a name="ln1904">		BMenuItem* item = MimeTypeMenu()-&gt;ItemAt(index);</a>
<a name="ln1905">		BMenu* submenu = item-&gt;Submenu();</a>
<a name="ln1906">		if (submenu == NULL)</a>
<a name="ln1907">			continue;</a>
<a name="ln1908"> </a>
<a name="ln1909">		if (submenu-&gt;CountItems() == 0) {</a>
<a name="ln1910">			MimeTypeMenu()-&gt;RemoveItem(item);</a>
<a name="ln1911">			delete item;</a>
<a name="ln1912">		} else</a>
<a name="ln1913">			submenu-&gt;SetTargetForItems(this);</a>
<a name="ln1914">	}</a>
<a name="ln1915">}</a>
<a name="ln1916"> </a>
<a name="ln1917"> </a>
<a name="ln1918">void</a>
<a name="ln1919">FindPanel::AddVolumes(BMenu* menu)</a>
<a name="ln1920">{</a>
<a name="ln1921">	// ToDo: add calls to this to rebuild the menu when a volume gets mounted</a>
<a name="ln1922"> </a>
<a name="ln1923">	BMessage* message = new BMessage(kVolumeItem);</a>
<a name="ln1924">	message-&gt;AddInt32(&quot;device&quot;, -1);</a>
<a name="ln1925">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;All disks&quot;), message));</a>
<a name="ln1926">	menu-&gt;AddSeparatorItem();</a>
<a name="ln1927">	PopUpMenuSetTitle(menu, B_TRANSLATE(&quot;All disks&quot;));</a>
<a name="ln1928"> </a>
<a name="ln1929">	BVolumeRoster roster;</a>
<a name="ln1930">	BVolume volume;</a>
<a name="ln1931">	roster.Rewind();</a>
<a name="ln1932">	while (roster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln1933">		if (volume.IsPersistent() &amp;&amp; volume.KnowsQuery()) {</a>
<a name="ln1934">			BDirectory root;</a>
<a name="ln1935">			if (volume.GetRootDirectory(&amp;root) != B_OK)</a>
<a name="ln1936">				continue;</a>
<a name="ln1937"> </a>
<a name="ln1938">			BEntry entry;</a>
<a name="ln1939">			root.GetEntry(&amp;entry);</a>
<a name="ln1940"> </a>
<a name="ln1941">			Model model(&amp;entry, true);</a>
<a name="ln1942">			if (model.InitCheck() != B_OK)</a>
<a name="ln1943">				continue;</a>
<a name="ln1944"> </a>
<a name="ln1945">			message = new BMessage(kVolumeItem);</a>
<a name="ln1946">			message-&gt;AddInt32(&quot;device&quot;, volume.Device());</a>
<a name="ln1947">			menu-&gt;AddItem(new ModelMenuItem(&amp;model, model.Name(), message));</a>
<a name="ln1948">		}</a>
<a name="ln1949">	}</a>
<a name="ln1950"> </a>
<a name="ln1951">	if (menu-&gt;ItemAt(0))</a>
<a name="ln1952">		menu-&gt;ItemAt(0)-&gt;SetMarked(true);</a>
<a name="ln1953"> </a>
<a name="ln1954">	menu-&gt;SetTargetForItems(this);</a>
<a name="ln1955">}</a>
<a name="ln1956"> </a>
<a name="ln1957"> </a>
<a name="ln1958">typedef std::pair&lt;entry_ref, uint32&gt; EntryWithDate;</a>
<a name="ln1959"> </a>
<a name="ln1960">static int</a>
<a name="ln1961">SortByDatePredicate(const EntryWithDate* entry1, const EntryWithDate* entry2)</a>
<a name="ln1962">{</a>
<a name="ln1963">	return entry1-&gt;second &gt; entry2-&gt;second ?</a>
<a name="ln1964">		-1 : (entry1-&gt;second == entry2-&gt;second ? 0 : 1);</a>
<a name="ln1965">}</a>
<a name="ln1966"> </a>
<a name="ln1967">struct AddOneRecentParams {</a>
<a name="ln1968">	BMenu* menu;</a>
<a name="ln1969">	const BMessenger* target;</a>
<a name="ln1970">	uint32 what;</a>
<a name="ln1971">};</a>
<a name="ln1972"> </a>
<a name="ln1973">static const entry_ref*</a>
<a name="ln1974">AddOneRecentItem(const entry_ref* ref, void* castToParams)</a>
<a name="ln1975">{</a>
<a name="ln1976">	AddOneRecentParams* params = (AddOneRecentParams*)castToParams;</a>
<a name="ln1977"> </a>
<a name="ln1978">	BMessage* message = new BMessage(params-&gt;what);</a>
<a name="ln1979">	message-&gt;AddRef(&quot;refs&quot;, ref);</a>
<a name="ln1980"> </a>
<a name="ln1981">	char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln1982">	BNode node(ref);</a>
<a name="ln1983">	BNodeInfo(&amp;node).GetType(type);</a>
<a name="ln1984">	BMenuItem* item = new IconMenuItem(ref-&gt;name, message, type);</a>
<a name="ln1985">	item-&gt;SetTarget(*params-&gt;target);</a>
<a name="ln1986">	params-&gt;menu-&gt;AddItem(item);</a>
<a name="ln1987"> </a>
<a name="ln1988">	return NULL;</a>
<a name="ln1989">}</a>
<a name="ln1990"> </a>
<a name="ln1991"> </a>
<a name="ln1992">void</a>
<a name="ln1993">FindPanel::AddRecentQueries(BMenu* menu, bool addSaveAsItem,</a>
<a name="ln1994">	const BMessenger* target, uint32 what)</a>
<a name="ln1995">{</a>
<a name="ln1996">	BObjectList&lt;entry_ref&gt; templates(10, true);</a>
<a name="ln1997">	BObjectList&lt;EntryWithDate&gt; recentQueries(10, true);</a>
<a name="ln1998"> </a>
<a name="ln1999">	// find all the queries on all volumes</a>
<a name="ln2000">	BVolumeRoster roster;</a>
<a name="ln2001">	BVolume volume;</a>
<a name="ln2002">	roster.Rewind();</a>
<a name="ln2003">	while (roster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln2004">		if (volume.IsPersistent() &amp;&amp; volume.KnowsQuery()</a>
<a name="ln2005">			&amp;&amp; volume.KnowsAttr()) {</a>
<a name="ln2006">			BQuery query;</a>
<a name="ln2007">			query.SetVolume(&amp;volume);</a>
<a name="ln2008">			query.SetPredicate(&quot;_trk/recentQuery == 1&quot;);</a>
<a name="ln2009">			if (query.Fetch() != B_OK)</a>
<a name="ln2010">				continue;</a>
<a name="ln2011"> </a>
<a name="ln2012">			entry_ref ref;</a>
<a name="ln2013">			while (query.GetNextRef(&amp;ref) == B_OK) {</a>
<a name="ln2014">				// ignore queries in the Trash</a>
<a name="ln2015">				if (FSInTrashDir(&amp;ref))</a>
<a name="ln2016">					continue;</a>
<a name="ln2017"> </a>
<a name="ln2018">				char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln2019">				BNode node(&amp;ref);</a>
<a name="ln2020">				BNodeInfo(&amp;node).GetType(type);</a>
<a name="ln2021"> </a>
<a name="ln2022">				if (strcasecmp(type, B_QUERY_TEMPLATE_MIMETYPE) == 0)</a>
<a name="ln2023">					templates.AddItem(new entry_ref(ref));</a>
<a name="ln2024">				else {</a>
<a name="ln2025">					uint32 changeTime;</a>
<a name="ln2026">					if (node.ReadAttr(kAttrQueryLastChange, B_INT32_TYPE, 0,</a>
<a name="ln2027">						&amp;changeTime, sizeof(uint32)) != sizeof(uint32))</a>
<a name="ln2028">						continue;</a>
<a name="ln2029"> </a>
<a name="ln2030">					recentQueries.AddItem(new EntryWithDate(ref, changeTime));</a>
<a name="ln2031">				}</a>
<a name="ln2032">			}</a>
<a name="ln2033">		}</a>
<a name="ln2034">	}</a>
<a name="ln2035"> </a>
<a name="ln2036">	// we are only adding last ten queries</a>
<a name="ln2037">	recentQueries.SortItems(SortByDatePredicate);</a>
<a name="ln2038"> </a>
<a name="ln2039">	// but all templates</a>
<a name="ln2040">	AddOneRecentParams params;</a>
<a name="ln2041">	params.menu = menu;</a>
<a name="ln2042">	params.target = target;</a>
<a name="ln2043">	params.what = what;</a>
<a name="ln2044">	templates.EachElement(AddOneRecentItem, &amp;params);</a>
<a name="ln2045"> </a>
<a name="ln2046">	int32 count = recentQueries.CountItems();</a>
<a name="ln2047">	if (count &gt; 10) {</a>
<a name="ln2048">		// show only up to 10 recent queries</a>
<a name="ln2049">		count = 10;</a>
<a name="ln2050">	} else if (count &lt; 0)</a>
<a name="ln2051">		count = 0;</a>
<a name="ln2052"> </a>
<a name="ln2053">	if (templates.CountItems() &gt; 0 &amp;&amp; count &gt; 0)</a>
<a name="ln2054">		menu-&gt;AddSeparatorItem();</a>
<a name="ln2055"> </a>
<a name="ln2056">	for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln2057">		AddOneRecentItem(&amp;recentQueries.ItemAt(index)-&gt;first, &amp;params);</a>
<a name="ln2058"> </a>
<a name="ln2059">	if (addSaveAsItem) {</a>
<a name="ln2060">		// add a Save as template item</a>
<a name="ln2061">		if (count &gt; 0 || templates.CountItems() &gt; 0)</a>
<a name="ln2062">			menu-&gt;AddSeparatorItem();</a>
<a name="ln2063"> </a>
<a name="ln2064">		BMessage* message = new BMessage(kRunSaveAsTemplatePanel);</a>
<a name="ln2065">		BMenuItem* item = new BMenuItem(</a>
<a name="ln2066">			B_TRANSLATE(&quot;Save query as template&quot; B_UTF8_ELLIPSIS), message);</a>
<a name="ln2067">		menu-&gt;AddItem(item);</a>
<a name="ln2068">	}</a>
<a name="ln2069">}</a>
<a name="ln2070"> </a>
<a name="ln2071"> </a>
<a name="ln2072">void</a>
<a name="ln2073">FindPanel::SetUpAddRemoveButtons()</a>
<a name="ln2074">{</a>
<a name="ln2075">	BBox* box = dynamic_cast&lt;BBox*&gt;(FindView(&quot;Box&quot;));</a>
<a name="ln2076"> </a>
<a name="ln2077">	ASSERT(box != NULL);</a>
<a name="ln2078"> </a>
<a name="ln2079">	if (box == NULL)</a>
<a name="ln2080">		return;</a>
<a name="ln2081"> </a>
<a name="ln2082">	BButton* removeButton = new BButton(&quot;remove button&quot;, B_TRANSLATE(&quot;Remove&quot;),</a>
<a name="ln2083">		new BMessage(kRemoveItem));</a>
<a name="ln2084">	removeButton-&gt;SetEnabled(false);</a>
<a name="ln2085">	removeButton-&gt;SetTarget(this);</a>
<a name="ln2086"> </a>
<a name="ln2087">	BButton* addButton = new BButton(&quot;add button&quot;, B_TRANSLATE(&quot;Add&quot;),</a>
<a name="ln2088">		new BMessage(kAddItem));</a>
<a name="ln2089">	addButton-&gt;SetTarget(this);</a>
<a name="ln2090"> </a>
<a name="ln2091">	BGroupLayout* layout = dynamic_cast&lt;BGroupLayout*&gt;(box-&gt;GetLayout());</a>
<a name="ln2092"> </a>
<a name="ln2093">	ASSERT(layout != NULL);</a>
<a name="ln2094"> </a>
<a name="ln2095">	if (layout == NULL)</a>
<a name="ln2096">		return;</a>
<a name="ln2097"> </a>
<a name="ln2098">	BLayoutBuilder::Group&lt;&gt;(layout)</a>
<a name="ln2099">		.AddGroup(B_HORIZONTAL)</a>
<a name="ln2100">			.AddGlue()</a>
<a name="ln2101">			.Add(removeButton)</a>
<a name="ln2102">			.Add(addButton)</a>
<a name="ln2103">			.End()</a>
<a name="ln2104">		.End();</a>
<a name="ln2105">}</a>
<a name="ln2106"> </a>
<a name="ln2107"> </a>
<a name="ln2108">void</a>
<a name="ln2109">FindPanel::FillCurrentQueryName(BTextControl* queryName, FindWindow* window)</a>
<a name="ln2110">{</a>
<a name="ln2111">	ASSERT(window);</a>
<a name="ln2112">	queryName-&gt;SetText(window-&gt;QueryName());</a>
<a name="ln2113">}</a>
<a name="ln2114"> </a>
<a name="ln2115"> </a>
<a name="ln2116">void</a>
<a name="ln2117">FindPanel::AddAttrRow()</a>
<a name="ln2118">{</a>
<a name="ln2119">	BBox* box = dynamic_cast&lt;BBox*&gt;(FindView(&quot;Box&quot;));</a>
<a name="ln2120"> </a>
<a name="ln2121">	ASSERT(box != NULL);</a>
<a name="ln2122"> </a>
<a name="ln2123">	if (box == NULL)</a>
<a name="ln2124">		return;</a>
<a name="ln2125"> </a>
<a name="ln2126">	BGridView* grid = dynamic_cast&lt;BGridView*&gt;(box-&gt;FindView(&quot;AttrFields&quot;));</a>
<a name="ln2127">	if (grid == NULL) {</a>
<a name="ln2128">		// reset layout</a>
<a name="ln2129">		BLayoutBuilder::Group&lt;&gt;(box, B_VERTICAL);</a>
<a name="ln2130"> </a>
<a name="ln2131">		grid = new BGridView(&quot;AttrFields&quot;);</a>
<a name="ln2132">		box-&gt;AddChild(grid);</a>
<a name="ln2133">	}</a>
<a name="ln2134"> </a>
<a name="ln2135">	fAttrGrid = grid-&gt;GridLayout();</a>
<a name="ln2136"> </a>
<a name="ln2137">	AddAttributeControls(fAttrGrid-&gt;CountRows());</a>
<a name="ln2138"> </a>
<a name="ln2139">	// add logic to previous attrview</a>
<a name="ln2140">	if (fAttrGrid-&gt;CountRows() &gt; 1)</a>
<a name="ln2141">		AddLogicMenu(fAttrGrid-&gt;CountRows() - 2);</a>
<a name="ln2142"> </a>
<a name="ln2143">	BButton* removeButton = dynamic_cast&lt;BButton*&gt;(</a>
<a name="ln2144">		box-&gt;FindView(&quot;remove button&quot;));</a>
<a name="ln2145">	if (removeButton != NULL)</a>
<a name="ln2146">		removeButton-&gt;SetEnabled(fAttrGrid-&gt;CountRows() &gt; 1);</a>
<a name="ln2147">	else</a>
<a name="ln2148">		SetUpAddRemoveButtons();</a>
<a name="ln2149">}</a>
<a name="ln2150"> </a>
<a name="ln2151"> </a>
<a name="ln2152">void</a>
<a name="ln2153">FindPanel::RemoveAttrRow()</a>
<a name="ln2154">{</a>
<a name="ln2155">	if (fAttrGrid-&gt;CountRows() &lt; 2)</a>
<a name="ln2156">		return;</a>
<a name="ln2157"> </a>
<a name="ln2158">	BView* view;</a>
<a name="ln2159"> </a>
<a name="ln2160">	int32 row = fAttrGrid-&gt;CountRows() - 1;</a>
<a name="ln2161">	for (int32 col = fAttrGrid-&gt;CountColumns(); col &gt; 0; col--) {</a>
<a name="ln2162">		BLayoutItem* item = fAttrGrid-&gt;ItemAt(col - 1, row);</a>
<a name="ln2163">		if (item == NULL)</a>
<a name="ln2164">			continue;</a>
<a name="ln2165"> </a>
<a name="ln2166">		view = item-&gt;View();</a>
<a name="ln2167">		if (view == NULL)</a>
<a name="ln2168">			continue;</a>
<a name="ln2169"> </a>
<a name="ln2170">		view-&gt;RemoveSelf();</a>
<a name="ln2171">		delete view;</a>
<a name="ln2172">	}</a>
<a name="ln2173"> </a>
<a name="ln2174">	BString string = &quot;TextEntry&quot;;</a>
<a name="ln2175">	string &lt;&lt; (row - 1);</a>
<a name="ln2176">	view = FindAttrView(string.String(), row - 1);</a>
<a name="ln2177">	if (view != NULL)</a>
<a name="ln2178">		view-&gt;MakeFocus();</a>
<a name="ln2179"> </a>
<a name="ln2180">	if (fAttrGrid-&gt;CountRows() &gt; 1) {</a>
<a name="ln2181">		// remove the And/Or menu field of the previous row</a>
<a name="ln2182">		BLayoutItem* item = fAttrGrid-&gt;ItemAt(3, row - 1);</a>
<a name="ln2183">		if (item == NULL)</a>
<a name="ln2184">			return;</a>
<a name="ln2185"> </a>
<a name="ln2186">		view = item-&gt;View();</a>
<a name="ln2187">		if (view == NULL)</a>
<a name="ln2188">			return;</a>
<a name="ln2189"> </a>
<a name="ln2190">		view-&gt;RemoveSelf();</a>
<a name="ln2191">		delete view;</a>
<a name="ln2192">		return;</a>
<a name="ln2193">	}</a>
<a name="ln2194"> </a>
<a name="ln2195">	// only one row remains</a>
<a name="ln2196"> </a>
<a name="ln2197">	// disable the remove button</a>
<a name="ln2198">	BButton* button = dynamic_cast&lt;BButton*&gt;(FindView(&quot;remove button&quot;));</a>
<a name="ln2199">	if (button != NULL)</a>
<a name="ln2200">		button-&gt;SetEnabled(false);</a>
<a name="ln2201"> </a>
<a name="ln2202">	// remove the And/Or menu field</a>
<a name="ln2203">	BLayoutItem* item = fAttrGrid-&gt;RemoveItem(3);</a>
<a name="ln2204">	if (item == NULL)</a>
<a name="ln2205">		return;</a>
<a name="ln2206"> </a>
<a name="ln2207">	view = item-&gt;View();</a>
<a name="ln2208">	if (view == NULL)</a>
<a name="ln2209">		return;</a>
<a name="ln2210"> </a>
<a name="ln2211">	view-&gt;RemoveSelf();</a>
<a name="ln2212">	delete view;</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215"> </a>
<a name="ln2216">uint32</a>
<a name="ln2217">FindPanel::InitialMode(const BNode* node)</a>
<a name="ln2218">{</a>
<a name="ln2219">	if (node == NULL || node-&gt;InitCheck() != B_OK)</a>
<a name="ln2220">		return kByNameItem;</a>
<a name="ln2221"> </a>
<a name="ln2222">	uint32 result;</a>
<a name="ln2223">	if (node-&gt;ReadAttr(kAttrQueryInitialMode, B_INT32_TYPE, 0,</a>
<a name="ln2224">		(int32*)&amp;result, sizeof(int32)) &lt;= 0)</a>
<a name="ln2225">		return kByNameItem;</a>
<a name="ln2226"> </a>
<a name="ln2227">	return result;</a>
<a name="ln2228">}</a>
<a name="ln2229"> </a>
<a name="ln2230"> </a>
<a name="ln2231">int32</a>
<a name="ln2232">FindPanel::InitialAttrCount(const BNode* node)</a>
<a name="ln2233">{</a>
<a name="ln2234">	if (node == NULL || node-&gt;InitCheck() != B_OK)</a>
<a name="ln2235">		return 1;</a>
<a name="ln2236"> </a>
<a name="ln2237">	int32 result;</a>
<a name="ln2238">	if (node-&gt;ReadAttr(kAttrQueryInitialNumAttrs, B_INT32_TYPE, 0,</a>
<a name="ln2239">		&amp;result, sizeof(int32)) &lt;= 0)</a>
<a name="ln2240">		return 1;</a>
<a name="ln2241"> </a>
<a name="ln2242">	return result;</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245"> </a>
<a name="ln2246">static int32</a>
<a name="ln2247">SelectItemWithLabel(BMenu* menu, const char* label)</a>
<a name="ln2248">{</a>
<a name="ln2249">	for (int32 index = menu-&gt;CountItems(); index-- &gt; 0;)  {</a>
<a name="ln2250">		BMenuItem* item = menu-&gt;ItemAt(index);</a>
<a name="ln2251"> </a>
<a name="ln2252">		if (strcmp(label, item-&gt;Label()) == 0) {</a>
<a name="ln2253">			item-&gt;SetMarked(true);</a>
<a name="ln2254">			return index;</a>
<a name="ln2255">		}</a>
<a name="ln2256">	}</a>
<a name="ln2257">	return -1;</a>
<a name="ln2258">}</a>
<a name="ln2259"> </a>
<a name="ln2260"> </a>
<a name="ln2261">void</a>
<a name="ln2262">FindPanel::SaveWindowState(BNode* node, bool editTemplate)</a>
<a name="ln2263">{</a>
<a name="ln2264">	ASSERT(node-&gt;InitCheck() == B_OK);</a>
<a name="ln2265"> </a>
<a name="ln2266">	BMenuItem* item = CurrentMimeType();</a>
<a name="ln2267">	if (item) {</a>
<a name="ln2268">		BString label(item-&gt;Label());</a>
<a name="ln2269">		node-&gt;WriteAttrString(kAttrQueryInitialMime, &amp;label);</a>
<a name="ln2270">	}</a>
<a name="ln2271"> </a>
<a name="ln2272">	uint32 mode = Mode();</a>
<a name="ln2273">	node-&gt;WriteAttr(kAttrQueryInitialMode, B_INT32_TYPE, 0,</a>
<a name="ln2274">		(int32*)&amp;mode, sizeof(int32));</a>
<a name="ln2275"> </a>
<a name="ln2276">	MoreOptionsStruct saveMoreOptions;</a>
<a name="ln2277">	saveMoreOptions.showMoreOptions = fLatch-&gt;Value() != 0;</a>
<a name="ln2278"> </a>
<a name="ln2279">	saveMoreOptions.searchTrash = fSearchTrashCheck-&gt;Value() != 0;</a>
<a name="ln2280">	saveMoreOptions.temporary = fTemporaryCheck-&gt;Value() != 0;</a>
<a name="ln2281"> </a>
<a name="ln2282">	if (node-&gt;WriteAttr(kAttrQueryMoreOptions, B_RAW_TYPE, 0,</a>
<a name="ln2283">		&amp;saveMoreOptions,</a>
<a name="ln2284">		sizeof(saveMoreOptions)) == sizeof(saveMoreOptions)) {</a>
<a name="ln2285">		node-&gt;RemoveAttr(kAttrQueryMoreOptionsForeign);</a>
<a name="ln2286">	}</a>
<a name="ln2287"> </a>
<a name="ln2288">	if (editTemplate) {</a>
<a name="ln2289">		if (UserSpecifiedName()) {</a>
<a name="ln2290">			BString name(UserSpecifiedName());</a>
<a name="ln2291">			node-&gt;WriteAttrString(kAttrQueryTemplateName, &amp;name);</a>
<a name="ln2292">		}</a>
<a name="ln2293">	}</a>
<a name="ln2294"> </a>
<a name="ln2295">	switch (Mode()) {</a>
<a name="ln2296">		case kByAttributeItem:</a>
<a name="ln2297">		{</a>
<a name="ln2298">			BMessage message;</a>
<a name="ln2299">			int32 count = fAttrGrid-&gt;CountRows();</a>
<a name="ln2300">			node-&gt;WriteAttr(kAttrQueryInitialNumAttrs, B_INT32_TYPE, 0,</a>
<a name="ln2301">				&amp;count, sizeof(int32));</a>
<a name="ln2302"> </a>
<a name="ln2303">			for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln2304">				SaveAttrState(&amp;message, index);</a>
<a name="ln2305"> </a>
<a name="ln2306">			ssize_t size = message.FlattenedSize();</a>
<a name="ln2307">			if (size &gt; 0) {</a>
<a name="ln2308">				char* buffer = new char[(size_t)size];</a>
<a name="ln2309">				status_t result = message.Flatten(buffer, size);</a>
<a name="ln2310">				if (result == B_OK) {</a>
<a name="ln2311">					node-&gt;WriteAttr(kAttrQueryInitialAttrs, B_MESSAGE_TYPE, 0,</a>
<a name="ln2312">						buffer, (size_t)size);</a>
<a name="ln2313">				}</a>
<a name="ln2314">				delete[] buffer;</a>
<a name="ln2315">			}</a>
<a name="ln2316">			break;</a>
<a name="ln2317">		}</a>
<a name="ln2318"> </a>
<a name="ln2319">		case kByNameItem:</a>
<a name="ln2320">		case kByFormulaItem:</a>
<a name="ln2321">		{</a>
<a name="ln2322">			BTextControl* textControl = dynamic_cast&lt;BTextControl*&gt;(</a>
<a name="ln2323">				FindView(&quot;TextControl&quot;));</a>
<a name="ln2324"> </a>
<a name="ln2325">			ASSERT(textControl != NULL);</a>
<a name="ln2326"> </a>
<a name="ln2327">			if (textControl != NULL) {</a>
<a name="ln2328">				BString formula(textControl-&gt;Text());</a>
<a name="ln2329">				node-&gt;WriteAttrString(kAttrQueryInitialString, &amp;formula);</a>
<a name="ln2330">			}</a>
<a name="ln2331">			break;</a>
<a name="ln2332">		}</a>
<a name="ln2333">	}</a>
<a name="ln2334">}</a>
<a name="ln2335"> </a>
<a name="ln2336"> </a>
<a name="ln2337">void</a>
<a name="ln2338">FindPanel::SwitchToTemplate(const BNode* node)</a>
<a name="ln2339">{</a>
<a name="ln2340">	SwitchMode(InitialMode(node));</a>
<a name="ln2341">		// update the menu to correspond to the mode</a>
<a name="ln2342">	MarkNamedMenuItem(fSearchModeMenu, InitialMode(node), true);</a>
<a name="ln2343"> </a>
<a name="ln2344">	if (Mode() == (int32)kByAttributeItem) {</a>
<a name="ln2345">		RemoveByAttributeItems();</a>
<a name="ln2346">		AddByAttributeItems(node);</a>
<a name="ln2347">	}</a>
<a name="ln2348"> </a>
<a name="ln2349">	RestoreWindowState(node);</a>
<a name="ln2350">}</a>
<a name="ln2351"> </a>
<a name="ln2352"> </a>
<a name="ln2353">void</a>
<a name="ln2354">FindPanel::RestoreMimeTypeMenuSelection(const BNode* node)</a>
<a name="ln2355">{</a>
<a name="ln2356">	if (Mode() == (int32)kByFormulaItem || node == NULL</a>
<a name="ln2357">		|| node-&gt;InitCheck() != B_OK) {</a>
<a name="ln2358">		return;</a>
<a name="ln2359">	}</a>
<a name="ln2360"> </a>
<a name="ln2361">	BString buffer;</a>
<a name="ln2362">	if (node-&gt;ReadAttrString(kAttrQueryInitialMime, &amp;buffer) == B_OK)</a>
<a name="ln2363">		SetCurrentMimeType(buffer.String());</a>
<a name="ln2364">}</a>
<a name="ln2365"> </a>
<a name="ln2366"> </a>
<a name="ln2367">void</a>
<a name="ln2368">FindPanel::RestoreWindowState(const BNode* node)</a>
<a name="ln2369">{</a>
<a name="ln2370">	fMode = InitialMode(node);</a>
<a name="ln2371">	if (node == NULL || node-&gt;InitCheck() != B_OK)</a>
<a name="ln2372">		return;</a>
<a name="ln2373"> </a>
<a name="ln2374">	ShowOrHideMimeTypeMenu();</a>
<a name="ln2375">	RestoreMimeTypeMenuSelection(node);</a>
<a name="ln2376">	MoreOptionsStruct saveMoreOptions;</a>
<a name="ln2377"> </a>
<a name="ln2378">	bool storesMoreOptions = ReadAttr(node, kAttrQueryMoreOptions,</a>
<a name="ln2379">		kAttrQueryMoreOptionsForeign, B_RAW_TYPE, 0, &amp;saveMoreOptions,</a>
<a name="ln2380">		sizeof(saveMoreOptions), &amp;MoreOptionsStruct::EndianSwap)</a>
<a name="ln2381">			!= kReadAttrFailed;</a>
<a name="ln2382"> </a>
<a name="ln2383">	if (storesMoreOptions) {</a>
<a name="ln2384">		// need to sanitize to true or false here, could have picked</a>
<a name="ln2385">		// up garbage from attributes</a>
<a name="ln2386"> </a>
<a name="ln2387">		saveMoreOptions.showMoreOptions =</a>
<a name="ln2388">			(saveMoreOptions.showMoreOptions != 0);</a>
<a name="ln2389"> </a>
<a name="ln2390">		fLatch-&gt;SetValue(saveMoreOptions.showMoreOptions);</a>
<a name="ln2391">		if (saveMoreOptions.showMoreOptions == 1 &amp;&amp; fMoreOptions-&gt;IsHidden())</a>
<a name="ln2392">			fMoreOptions-&gt;Show();</a>
<a name="ln2393">		else if (saveMoreOptions.showMoreOptions == 0 &amp;&amp; !fMoreOptions-&gt;IsHidden())</a>
<a name="ln2394">			fMoreOptions-&gt;Hide();</a>
<a name="ln2395"> </a>
<a name="ln2396">		fSearchTrashCheck-&gt;SetValue(saveMoreOptions.searchTrash);</a>
<a name="ln2397">		fTemporaryCheck-&gt;SetValue(saveMoreOptions.temporary);</a>
<a name="ln2398"> </a>
<a name="ln2399">		fQueryName-&gt;SetModificationMessage(NULL);</a>
<a name="ln2400">		FindWindow* findWindow = dynamic_cast&lt;FindWindow*&gt;(Window());</a>
<a name="ln2401">		if (findWindow != NULL)</a>
<a name="ln2402">			FillCurrentQueryName(fQueryName, findWindow);</a>
<a name="ln2403"> </a>
<a name="ln2404">		// set modification message after checking the temporary check box,</a>
<a name="ln2405">		// and filling out the text control so that we do not always trigger</a>
<a name="ln2406">		// clearing of the temporary check box.</a>
<a name="ln2407">		fQueryName-&gt;SetModificationMessage(</a>
<a name="ln2408">			new BMessage(kNameModifiedMessage));</a>
<a name="ln2409">	}</a>
<a name="ln2410"> </a>
<a name="ln2411">	// get volumes to perform query on</a>
<a name="ln2412">	bool searchAllVolumes = true;</a>
<a name="ln2413"> </a>
<a name="ln2414">	attr_info info;</a>
<a name="ln2415">	if (node-&gt;GetAttrInfo(kAttrQueryVolume, &amp;info) == B_OK) {</a>
<a name="ln2416">		char* buffer = new char[info.size];</a>
<a name="ln2417">		if (node-&gt;ReadAttr(kAttrQueryVolume, B_MESSAGE_TYPE, 0, buffer,</a>
<a name="ln2418">				(size_t)info.size) == info.size) {</a>
<a name="ln2419">			BMessage message;</a>
<a name="ln2420">			if (message.Unflatten(buffer) == B_OK) {</a>
<a name="ln2421">				for (int32 index = 0; ;index++) {</a>
<a name="ln2422">					ASSERT(index &lt; 100);</a>
<a name="ln2423">					BVolume volume;</a>
<a name="ln2424">						// match a volume with the info embedded in</a>
<a name="ln2425">						// the message</a>
<a name="ln2426">					status_t result</a>
<a name="ln2427">						= MatchArchivedVolume(&amp;volume, &amp;message, index);</a>
<a name="ln2428">					if (result == B_OK) {</a>
<a name="ln2429">						char name[256];</a>
<a name="ln2430">						volume.GetName(name);</a>
<a name="ln2431">						SelectItemWithLabel(fVolMenu, name);</a>
<a name="ln2432">						searchAllVolumes = false;</a>
<a name="ln2433">					} else if (result != B_DEV_BAD_DRIVE_NUM)</a>
<a name="ln2434">						// if B_DEV_BAD_DRIVE_NUM, the volume just isn't</a>
<a name="ln2435">						// mounted this time around, keep looking for more</a>
<a name="ln2436">						// if other error, bail</a>
<a name="ln2437">						break;</a>
<a name="ln2438">				}</a>
<a name="ln2439">			}</a>
<a name="ln2440">		}</a>
<a name="ln2441">		delete[] buffer;</a>
<a name="ln2442">	}</a>
<a name="ln2443">	// mark or unmark &quot;All disks&quot;</a>
<a name="ln2444">	fVolMenu-&gt;ItemAt(0)-&gt;SetMarked(searchAllVolumes);</a>
<a name="ln2445">	ShowVolumeMenuLabel();</a>
<a name="ln2446"> </a>
<a name="ln2447">	switch (Mode()) {</a>
<a name="ln2448">		case kByAttributeItem:</a>
<a name="ln2449">		{</a>
<a name="ln2450">			int32 count = InitialAttrCount(node);</a>
<a name="ln2451"> </a>
<a name="ln2452">			attr_info info;</a>
<a name="ln2453">			if (node-&gt;GetAttrInfo(kAttrQueryInitialAttrs, &amp;info) != B_OK)</a>
<a name="ln2454">				break;</a>
<a name="ln2455">			char* buffer = new char[info.size];</a>
<a name="ln2456">			if (node-&gt;ReadAttr(kAttrQueryInitialAttrs, B_MESSAGE_TYPE, 0,</a>
<a name="ln2457">					buffer, (size_t)info.size) == info.size) {</a>
<a name="ln2458">				BMessage message;</a>
<a name="ln2459">				if (message.Unflatten(buffer) == B_OK) {</a>
<a name="ln2460">					for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln2461">						RestoreAttrState(message, index);</a>
<a name="ln2462">				}</a>
<a name="ln2463">			}</a>
<a name="ln2464">			delete[] buffer;</a>
<a name="ln2465">			break;</a>
<a name="ln2466">		}</a>
<a name="ln2467"> </a>
<a name="ln2468">		case kByNameItem:</a>
<a name="ln2469">		case kByFormulaItem:</a>
<a name="ln2470">		{</a>
<a name="ln2471">			BString buffer;</a>
<a name="ln2472">			if (node-&gt;ReadAttrString(kAttrQueryInitialString, &amp;buffer)</a>
<a name="ln2473">					== B_OK) {</a>
<a name="ln2474">				BTextControl* textControl = dynamic_cast&lt;BTextControl*&gt;(</a>
<a name="ln2475">					FindView(&quot;TextControl&quot;));</a>
<a name="ln2476"> </a>
<a name="ln2477">				ASSERT(textControl != NULL);</a>
<a name="ln2478"> </a>
<a name="ln2479">				if (textControl != NULL)</a>
<a name="ln2480">					textControl-&gt;SetText(buffer.String());</a>
<a name="ln2481">			}</a>
<a name="ln2482">			break;</a>
<a name="ln2483">		}</a>
<a name="ln2484">	}</a>
<a name="ln2485"> </a>
<a name="ln2486">	// try to restore focus and possibly text selection</a>
<a name="ln2487">	BString focusedView;</a>
<a name="ln2488">	if (node-&gt;ReadAttrString(&quot;_trk/focusedView&quot;, &amp;focusedView) == B_OK) {</a>
<a name="ln2489">		BView* view = FindView(focusedView.String());</a>
<a name="ln2490">		if (view != NULL) {</a>
<a name="ln2491">			view-&gt;MakeFocus();</a>
<a name="ln2492">			BTextControl* textControl = dynamic_cast&lt;BTextControl*&gt;(view);</a>
<a name="ln2493">			if (textControl != NULL &amp;&amp; Mode() == kByFormulaItem) {</a>
<a name="ln2494">				int32 selStart = 0;</a>
<a name="ln2495">				int32 selEnd = INT32_MAX;</a>
<a name="ln2496">				node-&gt;ReadAttr(&quot;_trk/focusedSelStart&quot;, B_INT32_TYPE, 0,</a>
<a name="ln2497">					&amp;selStart, sizeof(selStart));</a>
<a name="ln2498">				node-&gt;ReadAttr(&quot;_trk/focusedSelEnd&quot;, B_INT32_TYPE, 0,</a>
<a name="ln2499">					&amp;selEnd, sizeof(selEnd));</a>
<a name="ln2500">				textControl-&gt;TextView()-&gt;Select(selStart, selEnd);</a>
<a name="ln2501">			}</a>
<a name="ln2502">		}</a>
<a name="ln2503">	}</a>
<a name="ln2504">}</a>
<a name="ln2505"> </a>
<a name="ln2506"> </a>
<a name="ln2507">void</a>
<a name="ln2508">FindPanel::AddByAttributeItems(const BNode* node)</a>
<a name="ln2509">{</a>
<a name="ln2510">	int32 numAttributes = InitialAttrCount(node);</a>
<a name="ln2511">	if (numAttributes &lt; 1)</a>
<a name="ln2512">		numAttributes = 1;</a>
<a name="ln2513"> </a>
<a name="ln2514">	for (int32 index = 0; index &lt; numAttributes; index ++)</a>
<a name="ln2515">		AddAttrRow();</a>
<a name="ln2516">}</a>
<a name="ln2517"> </a>
<a name="ln2518"> </a>
<a name="ln2519">void</a>
<a name="ln2520">FindPanel::AddByNameOrFormulaItems()</a>
<a name="ln2521">{</a>
<a name="ln2522">	BBox* box = dynamic_cast&lt;BBox*&gt;(FindView(&quot;Box&quot;));</a>
<a name="ln2523"> </a>
<a name="ln2524">	ASSERT(box != NULL);</a>
<a name="ln2525"> </a>
<a name="ln2526">	if (box == NULL)</a>
<a name="ln2527">		return;</a>
<a name="ln2528"> </a>
<a name="ln2529">	// reset layout</a>
<a name="ln2530">	BLayoutBuilder::Group&lt;&gt;(box, B_VERTICAL);</a>
<a name="ln2531"> </a>
<a name="ln2532">	BTextControl* textControl = new BTextControl(&quot;TextControl&quot;,</a>
<a name="ln2533">		&quot;&quot;, &quot;&quot;, NULL);</a>
<a name="ln2534">	textControl-&gt;SetDivider(0.0f);</a>
<a name="ln2535">	box-&gt;SetBorder(B_NO_BORDER);</a>
<a name="ln2536">	box-&gt;AddChild(textControl);</a>
<a name="ln2537">	textControl-&gt;MakeFocus();</a>
<a name="ln2538">}</a>
<a name="ln2539"> </a>
<a name="ln2540"> </a>
<a name="ln2541">void</a>
<a name="ln2542">FindPanel::RemoveAttrViewItems(bool removeGrid)</a>
<a name="ln2543">{</a>
<a name="ln2544">	if (fAttrGrid == NULL)</a>
<a name="ln2545">		return;</a>
<a name="ln2546"> </a>
<a name="ln2547">	BView* view = fAttrGrid-&gt;View();</a>
<a name="ln2548">	for (int32 index = view-&gt;CountChildren(); index &gt; 0; index--) {</a>
<a name="ln2549">		BView* child = view-&gt;ChildAt(index - 1);</a>
<a name="ln2550">		child-&gt;RemoveSelf();</a>
<a name="ln2551">		delete child;</a>
<a name="ln2552">	}</a>
<a name="ln2553"> </a>
<a name="ln2554">	if (removeGrid) {</a>
<a name="ln2555">		view-&gt;RemoveSelf();</a>
<a name="ln2556">		delete view;</a>
<a name="ln2557">		fAttrGrid = NULL;</a>
<a name="ln2558">	}</a>
<a name="ln2559">}</a>
<a name="ln2560"> </a>
<a name="ln2561"> </a>
<a name="ln2562">void</a>
<a name="ln2563">FindPanel::RemoveByAttributeItems()</a>
<a name="ln2564">{</a>
<a name="ln2565">	RemoveAttrViewItems();</a>
<a name="ln2566">	BView* view = FindView(&quot;add button&quot;);</a>
<a name="ln2567">	if (view) {</a>
<a name="ln2568">		view-&gt;RemoveSelf();</a>
<a name="ln2569">		delete view;</a>
<a name="ln2570">	}</a>
<a name="ln2571"> </a>
<a name="ln2572">	view = FindView(&quot;remove button&quot;);</a>
<a name="ln2573">	if (view) {</a>
<a name="ln2574">		view-&gt;RemoveSelf();</a>
<a name="ln2575">		delete view;</a>
<a name="ln2576">	}</a>
<a name="ln2577"> </a>
<a name="ln2578">	view = FindView(&quot;TextControl&quot;);</a>
<a name="ln2579">	if (view) {</a>
<a name="ln2580">		view-&gt;RemoveSelf();</a>
<a name="ln2581">		delete view;</a>
<a name="ln2582">	}</a>
<a name="ln2583">}</a>
<a name="ln2584"> </a>
<a name="ln2585"> </a>
<a name="ln2586">void</a>
<a name="ln2587">FindPanel::ShowOrHideMimeTypeMenu()</a>
<a name="ln2588">{</a>
<a name="ln2589">	BView* menuFieldSpacer = FindView(&quot;MimeTypeMenuSpacer&quot;);</a>
<a name="ln2590">	BMenuField* menuField</a>
<a name="ln2591">		= dynamic_cast&lt;BMenuField*&gt;(FindView(&quot;MimeTypeMenu&quot;));</a>
<a name="ln2592">	if (menuFieldSpacer == NULL || menuField == NULL)</a>
<a name="ln2593">		return;</a>
<a name="ln2594"> </a>
<a name="ln2595">	if (Mode() == (int32)kByFormulaItem &amp;&amp; !menuField-&gt;IsHidden(this)) {</a>
<a name="ln2596">		BSize size = menuField-&gt;ExplicitMinSize();</a>
<a name="ln2597">		menuField-&gt;Hide();</a>
<a name="ln2598">		menuFieldSpacer-&gt;SetExplicitMinSize(size);</a>
<a name="ln2599">		menuFieldSpacer-&gt;SetExplicitMaxSize(size);</a>
<a name="ln2600">		if (menuFieldSpacer-&gt;IsHidden(this))</a>
<a name="ln2601">			menuFieldSpacer-&gt;Show();</a>
<a name="ln2602">	} else if (menuField-&gt;IsHidden(this)) {</a>
<a name="ln2603">		menuFieldSpacer-&gt;Hide();</a>
<a name="ln2604">		menuField-&gt;Show();</a>
<a name="ln2605">	}</a>
<a name="ln2606">}</a>
<a name="ln2607"> </a>
<a name="ln2608"> </a>
<a name="ln2609">void</a>
<a name="ln2610">FindPanel::AddAttributeControls(int32 gridRow)</a>
<a name="ln2611">{</a>
<a name="ln2612">	BPopUpMenu* menu = new BPopUpMenu(&quot;PopUp&quot;);</a>
<a name="ln2613"> </a>
<a name="ln2614">	// add NAME attribute to popup</a>
<a name="ln2615">	BMenu* submenu = new BMenu(B_TRANSLATE(&quot;Name&quot;));</a>
<a name="ln2616">	submenu-&gt;SetRadioMode(true);</a>
<a name="ln2617">	submenu-&gt;SetFont(be_plain_font);</a>
<a name="ln2618">	BMessage* message = new BMessage(kAttributeItemMain);</a>
<a name="ln2619">	message-&gt;AddString(&quot;name&quot;, &quot;name&quot;);</a>
<a name="ln2620">	message-&gt;AddInt32(&quot;type&quot;, B_STRING_TYPE);</a>
<a name="ln2621">	BMenuItem* item = new BMenuItem(submenu, message);</a>
<a name="ln2622">	menu-&gt;AddItem(item);</a>
<a name="ln2623"> </a>
<a name="ln2624">	for (int32 i = 0; i &lt; 5; i++) {</a>
<a name="ln2625">		message = new BMessage(kAttributeItem);</a>
<a name="ln2626">		message-&gt;AddInt32(&quot;operator&quot;, operators[i]);</a>
<a name="ln2627">		submenu-&gt;AddItem(new BMenuItem(</a>
<a name="ln2628">			B_TRANSLATE_NOCOLLECT(operatorLabels[i]), message));</a>
<a name="ln2629">	}</a>
<a name="ln2630"> </a>
<a name="ln2631">	// mark first items initially</a>
<a name="ln2632">	menu-&gt;ItemAt(0)-&gt;SetMarked(true);</a>
<a name="ln2633">	submenu-&gt;ItemAt(0)-&gt;SetMarked(true);</a>
<a name="ln2634"> </a>
<a name="ln2635">	// add SIZE attribute</a>
<a name="ln2636">	submenu = new BMenu(B_TRANSLATE(&quot;Size&quot;));</a>
<a name="ln2637">	submenu-&gt;SetRadioMode(true);</a>
<a name="ln2638">	submenu-&gt;SetFont(be_plain_font);</a>
<a name="ln2639">	message = new BMessage(kAttributeItemMain);</a>
<a name="ln2640">	message-&gt;AddString(&quot;name&quot;, &quot;size&quot;);</a>
<a name="ln2641">	message-&gt;AddInt32(&quot;type&quot;, B_OFF_T_TYPE);</a>
<a name="ln2642">	item = new BMenuItem(submenu, message);</a>
<a name="ln2643">	menu-&gt;AddItem(item);</a>
<a name="ln2644"> </a>
<a name="ln2645">	message = new BMessage(kAttributeItem);</a>
<a name="ln2646">	message-&gt;AddInt32(&quot;operator&quot;, B_GE);</a>
<a name="ln2647">	submenu-&gt;AddItem(new BMenuItem(B_TRANSLATE_NOCOLLECT(operatorLabels[5]),</a>
<a name="ln2648">		message));</a>
<a name="ln2649"> </a>
<a name="ln2650">	message = new BMessage(kAttributeItem);</a>
<a name="ln2651">	message-&gt;AddInt32(&quot;operator&quot;, B_LE);</a>
<a name="ln2652">	submenu-&gt;AddItem(new BMenuItem(B_TRANSLATE_NOCOLLECT(operatorLabels[6]),</a>
<a name="ln2653">		message));</a>
<a name="ln2654"> </a>
<a name="ln2655">	message = new BMessage(kAttributeItem);</a>
<a name="ln2656">	message-&gt;AddInt32(&quot;operator&quot;, B_EQ);</a>
<a name="ln2657">	submenu-&gt;AddItem(new BMenuItem(B_TRANSLATE_NOCOLLECT(operatorLabels[1]),</a>
<a name="ln2658">		message));</a>
<a name="ln2659"> </a>
<a name="ln2660">	// add &quot;modified&quot; field</a>
<a name="ln2661">	submenu = new BMenu(B_TRANSLATE(&quot;Modified&quot;));</a>
<a name="ln2662">	submenu-&gt;SetRadioMode(true);</a>
<a name="ln2663">	submenu-&gt;SetFont(be_plain_font);</a>
<a name="ln2664">	message = new BMessage(kAttributeItemMain);</a>
<a name="ln2665">	message-&gt;AddString(&quot;name&quot;, &quot;last_modified&quot;);</a>
<a name="ln2666">	message-&gt;AddInt32(&quot;type&quot;, B_TIME_TYPE);</a>
<a name="ln2667">	item = new BMenuItem(submenu, message);</a>
<a name="ln2668">	menu-&gt;AddItem(item);</a>
<a name="ln2669"> </a>
<a name="ln2670">	message = new BMessage(kAttributeItem);</a>
<a name="ln2671">	message-&gt;AddInt32(&quot;operator&quot;, B_LE);</a>
<a name="ln2672">	submenu-&gt;AddItem(new BMenuItem(B_TRANSLATE_NOCOLLECT(operatorLabels[7]),</a>
<a name="ln2673">		message));</a>
<a name="ln2674"> </a>
<a name="ln2675">	message = new BMessage(kAttributeItem);</a>
<a name="ln2676">	message-&gt;AddInt32(&quot;operator&quot;, B_GE);</a>
<a name="ln2677">	submenu-&gt;AddItem(new BMenuItem(B_TRANSLATE_NOCOLLECT(operatorLabels[8]),</a>
<a name="ln2678">		message));</a>
<a name="ln2679"> </a>
<a name="ln2680">	BMenuField* menuField = new BMenuField(&quot;MenuField&quot;, &quot;&quot;, menu);</a>
<a name="ln2681">	menuField-&gt;SetDivider(0.0f);</a>
<a name="ln2682">	fAttrGrid-&gt;AddView(menuField, 0, gridRow);</a>
<a name="ln2683"> </a>
<a name="ln2684">	BStringView* stringView = new BStringView(&quot;&quot;,</a>
<a name="ln2685">		menu-&gt;FindMarked()-&gt;Submenu()-&gt;FindMarked()-&gt;Label());</a>
<a name="ln2686">	BLayoutItem* layoutItem = fAttrGrid-&gt;AddView(stringView, 1, gridRow);</a>
<a name="ln2687">	layoutItem-&gt;SetExplicitAlignment(BAlignment(B_ALIGN_RIGHT,</a>
<a name="ln2688">		B_ALIGN_VERTICAL_UNSET));</a>
<a name="ln2689"> </a>
<a name="ln2690">	BString title(&quot;TextEntry&quot;);</a>
<a name="ln2691">	title &lt;&lt; gridRow;</a>
<a name="ln2692">	BTextControl* textControl = new BTextControl(title.String(), &quot;&quot;, &quot;&quot;, NULL);</a>
<a name="ln2693">	textControl-&gt;SetDivider(0.0f);</a>
<a name="ln2694">	fAttrGrid-&gt;AddView(textControl, 2, gridRow);</a>
<a name="ln2695">	textControl-&gt;MakeFocus();</a>
<a name="ln2696"> </a>
<a name="ln2697">	// target everything</a>
<a name="ln2698">	menu-&gt;SetTargetForItems(this);</a>
<a name="ln2699">	for (int32 index = menu-&gt;CountItems() - 1; index &gt;= 0; index--) {</a>
<a name="ln2700">		BMenu* submenuAtIndex = menu-&gt;SubmenuAt(index);</a>
<a name="ln2701">		if (submenuAtIndex != NULL)</a>
<a name="ln2702">			submenuAtIndex-&gt;SetTargetForItems(this);</a>
<a name="ln2703">	}</a>
<a name="ln2704"> </a>
<a name="ln2705">	// populate mime popup</a>
<a name="ln2706">	AddMimeTypeAttrs(menu);</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709"> </a>
<a name="ln2710">void</a>
<a name="ln2711">FindPanel::RestoreAttrState(const BMessage &amp;message, int32 index)</a>
<a name="ln2712">{</a>
<a name="ln2713">	BMenuField* menuField</a>
<a name="ln2714">		= dynamic_cast&lt;BMenuField*&gt;(FindAttrView(&quot;MenuField&quot;, index));</a>
<a name="ln2715">	if (menuField != NULL) {</a>
<a name="ln2716">		// decode menu selections</a>
<a name="ln2717">		BMenu* menu = menuField-&gt;Menu();</a>
<a name="ln2718"> </a>
<a name="ln2719">		ASSERT(menu != NULL);</a>
<a name="ln2720"> </a>
<a name="ln2721">		AddMimeTypeAttrs(menu);</a>
<a name="ln2722">		const char* label;</a>
<a name="ln2723">		if (message.FindString(&quot;menuSelection&quot;, index, &amp;label) == B_OK) {</a>
<a name="ln2724">			int32 itemIndex = SelectItemWithLabel(menu, label);</a>
<a name="ln2725">			if (itemIndex &gt;= 0) {</a>
<a name="ln2726">				menu = menu-&gt;SubmenuAt(itemIndex);</a>
<a name="ln2727">				if (menu != NULL &amp;&amp; message.FindString(&quot;subMenuSelection&quot;,</a>
<a name="ln2728">						index, &amp;label) == B_OK) {</a>
<a name="ln2729">					SelectItemWithLabel(menu, label);</a>
<a name="ln2730">				}</a>
<a name="ln2731">			}</a>
<a name="ln2732">		}</a>
<a name="ln2733">	}</a>
<a name="ln2734"> </a>
<a name="ln2735">	// decode attribute text</a>
<a name="ln2736">	BString textEntryString = &quot;TextEntry&quot;;</a>
<a name="ln2737">	textEntryString &lt;&lt; index;</a>
<a name="ln2738">	BTextControl* textControl = dynamic_cast&lt;BTextControl*&gt;(</a>
<a name="ln2739">		FindAttrView(textEntryString.String(), index));</a>
<a name="ln2740"> </a>
<a name="ln2741">	ASSERT(textControl != NULL);</a>
<a name="ln2742"> </a>
<a name="ln2743">	const char* string;</a>
<a name="ln2744">	if (textControl != NULL</a>
<a name="ln2745">		&amp;&amp; message.FindString(&quot;attrViewText&quot;, index, &amp;string) == B_OK) {</a>
<a name="ln2746">		textControl-&gt;SetText(string);</a>
<a name="ln2747">	}</a>
<a name="ln2748"> </a>
<a name="ln2749">	int32 logicMenuSelectedIndex;</a>
<a name="ln2750">	if (message.FindInt32(&quot;logicalRelation&quot;, index,</a>
<a name="ln2751">			&amp;logicMenuSelectedIndex) == B_OK) {</a>
<a name="ln2752">		BMenuField* field = dynamic_cast&lt;BMenuField*&gt;(</a>
<a name="ln2753">			FindAttrView(&quot;Logic&quot;, index));</a>
<a name="ln2754">		if (field != NULL) {</a>
<a name="ln2755">			BMenu* fieldMenu = field-&gt;Menu();</a>
<a name="ln2756">			if (fieldMenu != NULL) {</a>
<a name="ln2757">				BMenuItem* logicItem</a>
<a name="ln2758">					= fieldMenu-&gt;ItemAt(logicMenuSelectedIndex);</a>
<a name="ln2759">				if (logicItem != NULL) {</a>
<a name="ln2760">					logicItem-&gt;SetMarked(true);</a>
<a name="ln2761">					return;</a>
<a name="ln2762">				}</a>
<a name="ln2763">			}</a>
<a name="ln2764">		}</a>
<a name="ln2765"> </a>
<a name="ln2766">		AddLogicMenu(index, logicMenuSelectedIndex == 0);</a>
<a name="ln2767">	}</a>
<a name="ln2768">}</a>
<a name="ln2769"> </a>
<a name="ln2770"> </a>
<a name="ln2771">void</a>
<a name="ln2772">FindPanel::SaveAttrState(BMessage* message, int32 index)</a>
<a name="ln2773">{</a>
<a name="ln2774">	BMenu* menu = dynamic_cast&lt;BMenuField*&gt;(FindAttrView(&quot;MenuField&quot;, index))</a>
<a name="ln2775">		-&gt;Menu();</a>
<a name="ln2776"> </a>
<a name="ln2777">	// encode main attribute menu selection</a>
<a name="ln2778">	BMenuItem* item = menu-&gt;FindMarked();</a>
<a name="ln2779">	message-&gt;AddString(&quot;menuSelection&quot;, item ? item-&gt;Label() : &quot;&quot;);</a>
<a name="ln2780"> </a>
<a name="ln2781">	// encode submenu selection</a>
<a name="ln2782">	const char* label = &quot;&quot;;</a>
<a name="ln2783">	if (item) {</a>
<a name="ln2784">		BMenu* submenu = menu-&gt;SubmenuAt(menu-&gt;IndexOf(item));</a>
<a name="ln2785">		if (submenu) {</a>
<a name="ln2786">			item = submenu-&gt;FindMarked();</a>
<a name="ln2787">			if (item)</a>
<a name="ln2788">				label = item-&gt;Label();</a>
<a name="ln2789">		}</a>
<a name="ln2790">	}</a>
<a name="ln2791">	message-&gt;AddString(&quot;subMenuSelection&quot;, label);</a>
<a name="ln2792"> </a>
<a name="ln2793">	// encode attribute text</a>
<a name="ln2794">	BString textEntryString = &quot;TextEntry&quot;;</a>
<a name="ln2795">	textEntryString &lt;&lt; index;</a>
<a name="ln2796">	BTextControl* textControl = dynamic_cast&lt;BTextControl*&gt;(FindAttrView(</a>
<a name="ln2797">		textEntryString.String(), index));</a>
<a name="ln2798"> </a>
<a name="ln2799">	ASSERT(textControl != NULL);</a>
<a name="ln2800"> </a>
<a name="ln2801">	if (textControl != NULL)</a>
<a name="ln2802">		message-&gt;AddString(&quot;attrViewText&quot;, textControl-&gt;Text());</a>
<a name="ln2803"> </a>
<a name="ln2804">	BMenuField* field = dynamic_cast&lt;BMenuField*&gt;(FindAttrView(&quot;Logic&quot;, index));</a>
<a name="ln2805">	if (field != NULL) {</a>
<a name="ln2806">		BMenu* fieldMenu = field-&gt;Menu();</a>
<a name="ln2807">		if (fieldMenu != NULL) {</a>
<a name="ln2808">			BMenuItem* item = fieldMenu-&gt;FindMarked();</a>
<a name="ln2809">			ASSERT(item != NULL);</a>
<a name="ln2810">			message-&gt;AddInt32(&quot;logicalRelation&quot;,</a>
<a name="ln2811">				item != NULL ? field-&gt;Menu()-&gt;IndexOf(item) : 0);</a>
<a name="ln2812">		}</a>
<a name="ln2813">	}</a>
<a name="ln2814">}</a>
<a name="ln2815"> </a>
<a name="ln2816"> </a>
<a name="ln2817">void</a>
<a name="ln2818">FindPanel::AddLogicMenu(int32 index, bool selectAnd)</a>
<a name="ln2819">{</a>
<a name="ln2820">	// add &quot;AND/OR&quot; menu</a>
<a name="ln2821">	BPopUpMenu* menu = new BPopUpMenu(&quot;&quot;);</a>
<a name="ln2822">	BMessage* message = new BMessage();</a>
<a name="ln2823">	message-&gt;AddInt32(&quot;combine&quot;, B_AND);</a>
<a name="ln2824">	BMenuItem* item = new BMenuItem(B_TRANSLATE(&quot;And&quot;), message);</a>
<a name="ln2825">	menu-&gt;AddItem(item);</a>
<a name="ln2826">	if (selectAnd)</a>
<a name="ln2827">		item-&gt;SetMarked(true);</a>
<a name="ln2828"> </a>
<a name="ln2829">	message = new BMessage();</a>
<a name="ln2830">	message-&gt;AddInt32(&quot;combine&quot;, B_OR);</a>
<a name="ln2831">	item = new BMenuItem(B_TRANSLATE(&quot;Or&quot;), message);</a>
<a name="ln2832">	menu-&gt;AddItem(item);</a>
<a name="ln2833">	if (!selectAnd)</a>
<a name="ln2834">		item-&gt;SetMarked(true);</a>
<a name="ln2835"> </a>
<a name="ln2836">	menu-&gt;SetTargetForItems(this);</a>
<a name="ln2837"> </a>
<a name="ln2838">	BMenuField* menufield = new BMenuField(&quot;Logic&quot;, &quot;&quot;, menu, B_WILL_DRAW);</a>
<a name="ln2839">	menufield-&gt;SetDivider(0.0f);</a>
<a name="ln2840"> </a>
<a name="ln2841">	ResizeMenuField(menufield);</a>
<a name="ln2842"> </a>
<a name="ln2843">	fAttrGrid-&gt;AddView(menufield, 3, index);</a>
<a name="ln2844">}</a>
<a name="ln2845"> </a>
<a name="ln2846"> </a>
<a name="ln2847">void</a>
<a name="ln2848">FindPanel::RemoveLogicMenu(int32 index)</a>
<a name="ln2849">{</a>
<a name="ln2850">	BMenuField* menufield = dynamic_cast&lt;BMenuField*&gt;(FindAttrView(&quot;Logic&quot;, index));</a>
<a name="ln2851">	if (menufield) {</a>
<a name="ln2852">		menufield-&gt;RemoveSelf();</a>
<a name="ln2853">		delete menufield;</a>
<a name="ln2854">	}</a>
<a name="ln2855">}</a>
<a name="ln2856"> </a>
<a name="ln2857"> </a>
<a name="ln2858">void</a>
<a name="ln2859">FindPanel::AddAttributes(BMenu* menu, const BMimeType &amp;mimeType)</a>
<a name="ln2860">{</a>
<a name="ln2861">	// only add things to menu which have &quot;user-visible&quot; data</a>
<a name="ln2862">	BMessage attributeMessage;</a>
<a name="ln2863">	if (mimeType.GetAttrInfo(&amp;attributeMessage) != B_OK)</a>
<a name="ln2864">		return;</a>
<a name="ln2865"> </a>
<a name="ln2866">	char desc[B_MIME_TYPE_LENGTH];</a>
<a name="ln2867">	mimeType.GetShortDescription(desc);</a>
<a name="ln2868"> </a>
<a name="ln2869">	// go through each field in meta mime and add it to a menu</a>
<a name="ln2870">	for (int32 index = 0; ; index++) {</a>
<a name="ln2871">		const char* publicName;</a>
<a name="ln2872">		if (attributeMessage.FindString(&quot;attr:public_name&quot;, index,</a>
<a name="ln2873">				&amp;publicName) != B_OK) {</a>
<a name="ln2874">			break;</a>
<a name="ln2875">		}</a>
<a name="ln2876"> </a>
<a name="ln2877">		if (!attributeMessage.FindBool(&quot;attr:viewable&quot;))</a>
<a name="ln2878">			continue;</a>
<a name="ln2879"> </a>
<a name="ln2880">		const char* attributeName;</a>
<a name="ln2881">		if (attributeMessage.FindString(&quot;attr:name&quot;, index, &amp;attributeName)</a>
<a name="ln2882">				!= B_OK) {</a>
<a name="ln2883">			continue;</a>
<a name="ln2884">		}</a>
<a name="ln2885"> </a>
<a name="ln2886">		int32 type;</a>
<a name="ln2887">		if (attributeMessage.FindInt32(&quot;attr:type&quot;, index, &amp;type) != B_OK)</a>
<a name="ln2888">			continue;</a>
<a name="ln2889"> </a>
<a name="ln2890">		BMenu* submenu = new BMenu(publicName);</a>
<a name="ln2891">		submenu-&gt;SetRadioMode(true);</a>
<a name="ln2892">		submenu-&gt;SetFont(be_plain_font);</a>
<a name="ln2893">		BMessage* message = new BMessage(kAttributeItemMain);</a>
<a name="ln2894">		message-&gt;AddString(&quot;name&quot;, attributeName);</a>
<a name="ln2895">		message-&gt;AddInt32(&quot;type&quot;, type);</a>
<a name="ln2896">		BMenuItem* item = new BMenuItem(submenu, message);</a>
<a name="ln2897">		menu-&gt;AddItem(item);</a>
<a name="ln2898">		menu-&gt;SetTargetForItems(this);</a>
<a name="ln2899"> </a>
<a name="ln2900">		switch (type) {</a>
<a name="ln2901">			case B_STRING_TYPE:</a>
<a name="ln2902">				message = new BMessage(kAttributeItem);</a>
<a name="ln2903">				message-&gt;AddInt32(&quot;operator&quot;, B_CONTAINS);</a>
<a name="ln2904">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[0], message));</a>
<a name="ln2905"> </a>
<a name="ln2906">				message = new BMessage(kAttributeItem);</a>
<a name="ln2907">				message-&gt;AddInt32(&quot;operator&quot;, B_EQ);</a>
<a name="ln2908">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[1], message));</a>
<a name="ln2909"> </a>
<a name="ln2910">				message = new BMessage(kAttributeItem);</a>
<a name="ln2911">				message-&gt;AddInt32(&quot;operator&quot;, B_NE);</a>
<a name="ln2912">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[2], message));</a>
<a name="ln2913">				submenu-&gt;SetTargetForItems(this);</a>
<a name="ln2914"> </a>
<a name="ln2915">				message = new BMessage(kAttributeItem);</a>
<a name="ln2916">				message-&gt;AddInt32(&quot;operator&quot;, B_BEGINS_WITH);</a>
<a name="ln2917">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[3], message));</a>
<a name="ln2918">				submenu-&gt;SetTargetForItems(this);</a>
<a name="ln2919"> </a>
<a name="ln2920">				message = new BMessage(kAttributeItem);</a>
<a name="ln2921">				message-&gt;AddInt32(&quot;operator&quot;, B_ENDS_WITH);</a>
<a name="ln2922">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[4], message));</a>
<a name="ln2923">				break;</a>
<a name="ln2924"> </a>
<a name="ln2925">			case B_BOOL_TYPE:</a>
<a name="ln2926">			case B_INT16_TYPE:</a>
<a name="ln2927">			case B_UINT8_TYPE:</a>
<a name="ln2928">			case B_INT8_TYPE:</a>
<a name="ln2929">			case B_UINT16_TYPE:</a>
<a name="ln2930">			case B_INT32_TYPE:</a>
<a name="ln2931">			case B_UINT32_TYPE:</a>
<a name="ln2932">			case B_INT64_TYPE:</a>
<a name="ln2933">			case B_UINT64_TYPE:</a>
<a name="ln2934">			case B_OFF_T_TYPE:</a>
<a name="ln2935">			case B_FLOAT_TYPE:</a>
<a name="ln2936">			case B_DOUBLE_TYPE:</a>
<a name="ln2937">				message = new BMessage(kAttributeItem);</a>
<a name="ln2938">				message-&gt;AddInt32(&quot;operator&quot;, B_EQ);</a>
<a name="ln2939">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[1], message));</a>
<a name="ln2940"> </a>
<a name="ln2941">				message = new BMessage(kAttributeItem);</a>
<a name="ln2942">				message-&gt;AddInt32(&quot;operator&quot;, B_GE);</a>
<a name="ln2943">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[5], message));</a>
<a name="ln2944"> </a>
<a name="ln2945">				message = new BMessage(kAttributeItem);</a>
<a name="ln2946">				message-&gt;AddInt32(&quot;operator&quot;, B_LE);</a>
<a name="ln2947">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[6], message));</a>
<a name="ln2948">				break;</a>
<a name="ln2949"> </a>
<a name="ln2950">			case B_TIME_TYPE:</a>
<a name="ln2951">				message = new BMessage(kAttributeItem);</a>
<a name="ln2952">				message-&gt;AddInt32(&quot;operator&quot;, B_LE);</a>
<a name="ln2953">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[7], message));</a>
<a name="ln2954"> </a>
<a name="ln2955">				message = new BMessage(kAttributeItem);</a>
<a name="ln2956">				message-&gt;AddInt32(&quot;operator&quot;, B_GE);</a>
<a name="ln2957">				submenu-&gt;AddItem(new BMenuItem(operatorLabels[8], message));</a>
<a name="ln2958">				break;</a>
<a name="ln2959">		}</a>
<a name="ln2960">		submenu-&gt;SetTargetForItems(this);</a>
<a name="ln2961">	}</a>
<a name="ln2962">}</a>
<a name="ln2963"> </a>
<a name="ln2964"> </a>
<a name="ln2965">void</a>
<a name="ln2966">FindPanel::AddMimeTypeAttrs(BMenu* menu)</a>
<a name="ln2967">{</a>
<a name="ln2968">	const char* typeName;</a>
<a name="ln2969">	if (CurrentMimeType(&amp;typeName) == NULL)</a>
<a name="ln2970">		return;</a>
<a name="ln2971"> </a>
<a name="ln2972">	BMimeType mimeType(typeName);</a>
<a name="ln2973">	if (!mimeType.IsInstalled())</a>
<a name="ln2974">		return;</a>
<a name="ln2975"> </a>
<a name="ln2976">	if (!mimeType.IsSupertypeOnly()) {</a>
<a name="ln2977">		// add supertype attributes</a>
<a name="ln2978">		BMimeType supertype;</a>
<a name="ln2979">		mimeType.GetSupertype(&amp;supertype);</a>
<a name="ln2980">		AddAttributes(menu, supertype);</a>
<a name="ln2981">	}</a>
<a name="ln2982"> </a>
<a name="ln2983">	AddAttributes(menu, mimeType);</a>
<a name="ln2984">}</a>
<a name="ln2985"> </a>
<a name="ln2986"> </a>
<a name="ln2987">void</a>
<a name="ln2988">FindPanel::GetDefaultAttrName(BString&amp; attrName, int32 row) const</a>
<a name="ln2989">{</a>
<a name="ln2990">	BMenuItem* item = NULL;</a>
<a name="ln2991">	BMenuField* menuField</a>
<a name="ln2992">		= dynamic_cast&lt;BMenuField*&gt;(fAttrGrid-&gt;ItemAt(0, row)-&gt;View());</a>
<a name="ln2993">	if (menuField != NULL &amp;&amp; menuField-&gt;Menu() != NULL)</a>
<a name="ln2994">		item = menuField-&gt;Menu()-&gt;FindMarked();</a>
<a name="ln2995"> </a>
<a name="ln2996">	if (item != NULL)</a>
<a name="ln2997">		attrName &lt;&lt; item-&gt;Label();</a>
<a name="ln2998">	else</a>
<a name="ln2999">		attrName &lt;&lt; B_TRANSLATE(&quot;Name&quot;);</a>
<a name="ln3000"> </a>
<a name="ln3001">	if (item != NULL &amp;&amp; item-&gt;Submenu() != NULL)</a>
<a name="ln3002">		item = item-&gt;Submenu()-&gt;FindMarked();</a>
<a name="ln3003">	else</a>
<a name="ln3004">		item = NULL;</a>
<a name="ln3005"> </a>
<a name="ln3006">	if (item != NULL)</a>
<a name="ln3007">		attrName &lt;&lt; &quot; &quot; &lt;&lt; item-&gt;Label() &lt;&lt; &quot; &quot;;</a>
<a name="ln3008">	else</a>
<a name="ln3009">		attrName &lt;&lt; &quot; = &quot;;</a>
<a name="ln3010"> </a>
<a name="ln3011">	BTextControl* textControl</a>
<a name="ln3012">		= dynamic_cast&lt;BTextControl*&gt;(fAttrGrid-&gt;ItemAt(2, row)-&gt;View());</a>
<a name="ln3013">	if (textControl != NULL)</a>
<a name="ln3014">		attrName &lt;&lt; textControl-&gt;Text();</a>
<a name="ln3015">}</a>
<a name="ln3016"> </a>
<a name="ln3017"> </a>
<a name="ln3018">// #pragma mark -</a>
<a name="ln3019"> </a>
<a name="ln3020"> </a>
<a name="ln3021">DeleteTransientQueriesTask::DeleteTransientQueriesTask()</a>
<a name="ln3022">	:</a>
<a name="ln3023">	state(kInitial),</a>
<a name="ln3024">	fWalker(NULL)</a>
<a name="ln3025">{</a>
<a name="ln3026">}</a>
<a name="ln3027"> </a>
<a name="ln3028"> </a>
<a name="ln3029">DeleteTransientQueriesTask::~DeleteTransientQueriesTask()</a>
<a name="ln3030">{</a>
<a name="ln3031">	delete fWalker;</a>
<a name="ln3032">}</a>
<a name="ln3033"> </a>
<a name="ln3034"> </a>
<a name="ln3035">bool</a>
<a name="ln3036">DeleteTransientQueriesTask::DoSomeWork()</a>
<a name="ln3037">{</a>
<a name="ln3038">	switch (state) {</a>
<a name="ln3039">		case kInitial:</a>
<a name="ln3040">			Initialize();</a>
<a name="ln3041">			break;</a>
<a name="ln3042"> </a>
<a name="ln3043">		case kAllocatedWalker:</a>
<a name="ln3044">		case kTraversing:</a>
<a name="ln3045">			if (GetSome()) {</a>
<a name="ln3046">				PRINT((&quot;transient query killer done\n&quot;));</a>
<a name="ln3047">				return true;</a>
<a name="ln3048">			}</a>
<a name="ln3049">			break;</a>
<a name="ln3050"> </a>
<a name="ln3051">		case kError:</a>
<a name="ln3052">			return true;</a>
<a name="ln3053"> </a>
<a name="ln3054">	}</a>
<a name="ln3055">	return false;</a>
<a name="ln3056">}</a>
<a name="ln3057"> </a>
<a name="ln3058"> </a>
<a name="ln3059">void</a>
<a name="ln3060">DeleteTransientQueriesTask::Initialize()</a>
<a name="ln3061">{</a>
<a name="ln3062">	PRINT((&quot;starting up transient query killer\n&quot;));</a>
<a name="ln3063">	BPath path;</a>
<a name="ln3064">	status_t result = find_directory(B_USER_DIRECTORY, &amp;path, false);</a>
<a name="ln3065">	if (result != B_OK) {</a>
<a name="ln3066">		state = kError;</a>
<a name="ln3067">		return;</a>
<a name="ln3068">	}</a>
<a name="ln3069">	fWalker = new BTrackerPrivate::TNodeWalker(path.Path());</a>
<a name="ln3070">	state = kAllocatedWalker;</a>
<a name="ln3071">}</a>
<a name="ln3072"> </a>
<a name="ln3073"> </a>
<a name="ln3074">const int32 kBatchCount = 100;</a>
<a name="ln3075"> </a>
<a name="ln3076">bool</a>
<a name="ln3077">DeleteTransientQueriesTask::GetSome()</a>
<a name="ln3078">{</a>
<a name="ln3079">	state = kTraversing;</a>
<a name="ln3080">	for (int32 count = kBatchCount; count &gt; 0; count--) {</a>
<a name="ln3081">		entry_ref ref;</a>
<a name="ln3082">		if (fWalker-&gt;GetNextRef(&amp;ref) != B_OK) {</a>
<a name="ln3083">			state = kError;</a>
<a name="ln3084">			return true;</a>
<a name="ln3085">		}</a>
<a name="ln3086">		Model model(&amp;ref);</a>
<a name="ln3087">		if (model.IsQuery())</a>
<a name="ln3088">			ProcessOneRef(&amp;model);</a>
<a name="ln3089">#if xDEBUG</a>
<a name="ln3090">		else</a>
<a name="ln3091">			PRINT((&quot;transient query killer: %s not a query\n&quot;, model.Name()));</a>
<a name="ln3092">#endif</a>
<a name="ln3093">	}</a>
<a name="ln3094">	return false;</a>
<a name="ln3095">}</a>
<a name="ln3096"> </a>
<a name="ln3097"> </a>
<a name="ln3098">const int32 kDaysToExpire = 7;</a>
<a name="ln3099"> </a>
<a name="ln3100">static bool</a>
<a name="ln3101">QueryOldEnough(Model* model)</a>
<a name="ln3102">{</a>
<a name="ln3103">	// check if it is old and ready to be deleted</a>
<a name="ln3104">	time_t now = time(0);</a>
<a name="ln3105"> </a>
<a name="ln3106">	tm nowTimeData;</a>
<a name="ln3107">	tm fileModData;</a>
<a name="ln3108"> </a>
<a name="ln3109">	localtime_r(&amp;now, &amp;nowTimeData);</a>
<a name="ln3110">	localtime_r(&amp;model-&gt;StatBuf()-&gt;st_ctime, &amp;fileModData);</a>
<a name="ln3111"> </a>
<a name="ln3112">	if ((nowTimeData.tm_mday - fileModData.tm_mday) &lt; kDaysToExpire</a>
<a name="ln3113">		&amp;&amp; (nowTimeData.tm_mday - fileModData.tm_mday) &gt; -kDaysToExpire) {</a>
<a name="ln3114">		PRINT((&quot;query %s, not old enough\n&quot;, model-&gt;Name()));</a>
<a name="ln3115">		return false;</a>
<a name="ln3116">	}</a>
<a name="ln3117">	return true;</a>
<a name="ln3118">}</a>
<a name="ln3119"> </a>
<a name="ln3120"> </a>
<a name="ln3121">bool</a>
<a name="ln3122">DeleteTransientQueriesTask::ProcessOneRef(Model* model)</a>
<a name="ln3123">{</a>
<a name="ln3124">	BModelOpener opener(model);</a>
<a name="ln3125"> </a>
<a name="ln3126">	// is this a temporary query</a>
<a name="ln3127">	if (!MoreOptionsStruct::QueryTemporary(model-&gt;Node())) {</a>
<a name="ln3128">		PRINT((&quot;query %s, not temporary\n&quot;, model-&gt;Name()));</a>
<a name="ln3129">		return false;</a>
<a name="ln3130">	}</a>
<a name="ln3131"> </a>
<a name="ln3132">	if (!QueryOldEnough(model))</a>
<a name="ln3133">		return false;</a>
<a name="ln3134"> </a>
<a name="ln3135">	TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln3136">	ASSERT(tracker != NULL);</a>
<a name="ln3137"> </a>
<a name="ln3138">	// check that it is not showing</a>
<a name="ln3139">	if (tracker != NULL &amp;&amp; tracker-&gt;EntryHasWindowOpen(model-&gt;EntryRef())) {</a>
<a name="ln3140">		PRINT((&quot;query %s, showing, can't delete\n&quot;, model-&gt;Name()));</a>
<a name="ln3141">		return false;</a>
<a name="ln3142">	}</a>
<a name="ln3143"> </a>
<a name="ln3144">	PRINT((&quot;query %s, old, temporary, not shownig - deleting\n&quot;,</a>
<a name="ln3145">		model-&gt;Name()));</a>
<a name="ln3146"> </a>
<a name="ln3147">	BEntry entry(model-&gt;EntryRef());</a>
<a name="ln3148">	entry.Remove();</a>
<a name="ln3149"> </a>
<a name="ln3150">	return true;</a>
<a name="ln3151">}</a>
<a name="ln3152"> </a>
<a name="ln3153"> </a>
<a name="ln3154">class DeleteTransientQueriesFunctor : public FunctionObjectWithResult&lt;bool&gt; {</a>
<a name="ln3155">public:</a>
<a name="ln3156">	DeleteTransientQueriesFunctor(DeleteTransientQueriesTask* task)</a>
<a name="ln3157">		:	task(task)</a>
<a name="ln3158">		{}</a>
<a name="ln3159"> </a>
<a name="ln3160">	virtual ~DeleteTransientQueriesFunctor()</a>
<a name="ln3161">		{</a>
<a name="ln3162">			delete task;</a>
<a name="ln3163">		}</a>
<a name="ln3164"> </a>
<a name="ln3165">	virtual void operator()()</a>
<a name="ln3166">		{ result = task-&gt;DoSomeWork(); }</a>
<a name="ln3167"> </a>
<a name="ln3168">private:</a>
<a name="ln3169">	DeleteTransientQueriesTask* task;</a>
<a name="ln3170">};</a>
<a name="ln3171"> </a>
<a name="ln3172"> </a>
<a name="ln3173">void</a>
<a name="ln3174">DeleteTransientQueriesTask::StartUpTransientQueryCleaner()</a>
<a name="ln3175">{</a>
<a name="ln3176">	TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln3177">	ASSERT(tracker != NULL);</a>
<a name="ln3178"> </a>
<a name="ln3179">	if (tracker == NULL)</a>
<a name="ln3180">		return;</a>
<a name="ln3181">	// set up a task that wakes up when the machine is idle and starts</a>
<a name="ln3182">	// killing off old transient queries</a>
<a name="ln3183">	DeleteTransientQueriesFunctor* worker</a>
<a name="ln3184">		= new DeleteTransientQueriesFunctor(new DeleteTransientQueriesTask());</a>
<a name="ln3185"> </a>
<a name="ln3186">	tracker-&gt;MainTaskLoop()-&gt;RunWhenIdle(worker,</a>
<a name="ln3187">		30 * 60 * 1000000,	// half an hour initial delay</a>
<a name="ln3188">		5 * 60 * 1000000,	// idle for five minutes</a>
<a name="ln3189">		10 * 1000000);</a>
<a name="ln3190">}</a>
<a name="ln3191"> </a>
<a name="ln3192"> </a>
<a name="ln3193">//	#pragma mark -</a>
<a name="ln3194"> </a>
<a name="ln3195"> </a>
<a name="ln3196">RecentFindItemsMenu::RecentFindItemsMenu(const char* title,</a>
<a name="ln3197">	const BMessenger* target, uint32 what)</a>
<a name="ln3198">	:</a>
<a name="ln3199">	BMenu(title, B_ITEMS_IN_COLUMN),</a>
<a name="ln3200">	fTarget(*target),</a>
<a name="ln3201">	fWhat(what)</a>
<a name="ln3202">{</a>
<a name="ln3203">}</a>
<a name="ln3204"> </a>
<a name="ln3205"> </a>
<a name="ln3206">void</a>
<a name="ln3207">RecentFindItemsMenu::AttachedToWindow()</a>
<a name="ln3208">{</a>
<a name="ln3209">	// re-populate the menu with fresh items</a>
<a name="ln3210">	for (int32 index = CountItems() - 1; index &gt;= 0; index--)</a>
<a name="ln3211">		delete RemoveItem(index);</a>
<a name="ln3212"> </a>
<a name="ln3213">	FindPanel::AddRecentQueries(this, false, &amp;fTarget, fWhat);</a>
<a name="ln3214">	BMenu::AttachedToWindow();</a>
<a name="ln3215">}</a>
<a name="ln3216"> </a>
<a name="ln3217"> </a>
<a name="ln3218">#if !B_BEOS_VERSION_DANO</a>
<a name="ln3219">_IMPEXP_TRACKER</a>
<a name="ln3220">#endif</a>
<a name="ln3221">BMenu*</a>
<a name="ln3222">TrackerBuildRecentFindItemsMenu(const char* title)</a>
<a name="ln3223">{</a>
<a name="ln3224">	BMessenger trackerMessenger(kTrackerSignature);</a>
<a name="ln3225">	return new RecentFindItemsMenu(title, &amp;trackerMessenger, B_REFS_RECEIVED);</a>
<a name="ln3226">}</a>
<a name="ln3227"> </a>
<a name="ln3228"> </a>
<a name="ln3229">//	#pragma mark -</a>
<a name="ln3230"> </a>
<a name="ln3231"> </a>
<a name="ln3232">DraggableQueryIcon::DraggableQueryIcon(BRect frame, const char* name,</a>
<a name="ln3233">	const BMessage* message, BMessenger messenger, uint32 resizeFlags,</a>
<a name="ln3234">		uint32 flags)</a>
<a name="ln3235">	:</a>
<a name="ln3236">	DraggableIcon(frame, name, B_QUERY_MIMETYPE, B_LARGE_ICON,</a>
<a name="ln3237">		message, messenger, resizeFlags, flags)</a>
<a name="ln3238">{</a>
<a name="ln3239">}</a>
<a name="ln3240"> </a>
<a name="ln3241"> </a>
<a name="ln3242">bool</a>
<a name="ln3243">DraggableQueryIcon::DragStarted(BMessage* dragMessage)</a>
<a name="ln3244">{</a>
<a name="ln3245">	// override to substitute the user-specified query name</a>
<a name="ln3246">	dragMessage-&gt;RemoveData(&quot;be:clip_name&quot;);</a>
<a name="ln3247"> </a>
<a name="ln3248">	FindWindow* window = dynamic_cast&lt;FindWindow*&gt;(Window());</a>
<a name="ln3249"> </a>
<a name="ln3250">	ASSERT(window != NULL);</a>
<a name="ln3251"> </a>
<a name="ln3252">	return window != NULL &amp;&amp; dragMessage-&gt;AddString(&quot;be:clip_name&quot;,</a>
<a name="ln3253">		window-&gt;BackgroundView()-&gt;UserSpecifiedName() != NULL</a>
<a name="ln3254">			? window-&gt;BackgroundView()-&gt;UserSpecifiedName()</a>
<a name="ln3255">			: B_TRANSLATE(&quot;New Query&quot;)) == B_OK;</a>
<a name="ln3256">}</a>
<a name="ln3257"> </a>
<a name="ln3258"> </a>
<a name="ln3259">//	#pragma mark -</a>
<a name="ln3260"> </a>
<a name="ln3261"> </a>
<a name="ln3262">MostUsedNames::MostUsedNames(const char* fileName, const char* directory,</a>
<a name="ln3263">	int32 maxCount)</a>
<a name="ln3264">	:</a>
<a name="ln3265">	fFileName(fileName),</a>
<a name="ln3266">	fDirectory(directory),</a>
<a name="ln3267">	fLoaded(false),</a>
<a name="ln3268">	fCount(maxCount)</a>
<a name="ln3269">{</a>
<a name="ln3270">}</a>
<a name="ln3271"> </a>
<a name="ln3272"> </a>
<a name="ln3273">MostUsedNames::~MostUsedNames()</a>
<a name="ln3274">{</a>
<a name="ln3275">	// only write back settings when we've been used</a>
<a name="ln3276">	if (!fLoaded)</a>
<a name="ln3277">		return;</a>
<a name="ln3278"> </a>
<a name="ln3279">	// write most used list to file</a>
<a name="ln3280"> </a>
<a name="ln3281">	BPath path;</a>
<a name="ln3282">	if (find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path, true) != B_OK</a>
<a name="ln3283">		|| path.Append(fDirectory) != B_OK || path.Append(fFileName) != B_OK) {</a>
<a name="ln3284">		return;</a>
<a name="ln3285">	}</a>
<a name="ln3286"> </a>
<a name="ln3287">	BFile file(path.Path(), B_WRITE_ONLY | B_CREATE_FILE | B_ERASE_FILE);</a>
<a name="ln3288">	if (file.InitCheck() == B_OK) {</a>
<a name="ln3289">		for (int32 i = 0; i &lt; fList.CountItems(); i++) {</a>
<a name="ln3290">			list_entry* entry = static_cast&lt;list_entry*&gt;(fList.ItemAt(i));</a>
<a name="ln3291"> </a>
<a name="ln3292">			char line[B_FILE_NAME_LENGTH + 5];</a>
<a name="ln3293"> </a>
<a name="ln3294">			// limit upper bound to react more dynamically to changes</a>
<a name="ln3295">			if (--entry-&gt;count &gt; 20)</a>
<a name="ln3296">				entry-&gt;count = 20;</a>
<a name="ln3297"> </a>
<a name="ln3298">			// if the item hasn't been chosen in a while, remove it</a>
<a name="ln3299">			// (but leave at least one item in the list)</a>
<a name="ln3300">			if (entry-&gt;count &lt; -10 &amp;&amp; i &gt; 0)</a>
<a name="ln3301">				continue;</a>
<a name="ln3302"> </a>
<a name="ln3303">			sprintf(line, &quot;%&quot; B_PRId32 &quot; %s\n&quot;, entry-&gt;count, entry-&gt;name);</a>
<a name="ln3304">			if (file.Write(line, strlen(line)) &lt; B_OK)</a>
<a name="ln3305">				break;</a>
<a name="ln3306">		}</a>
<a name="ln3307">	}</a>
<a name="ln3308">	file.Unset();</a>
<a name="ln3309"> </a>
<a name="ln3310">	// free data</a>
<a name="ln3311"> </a>
<a name="ln3312">	for (int32 i = fList.CountItems(); i-- &gt; 0;) {</a>
<a name="ln3313">		list_entry* entry = static_cast&lt;list_entry*&gt;(fList.ItemAt(i));</a>
<a name="ln3314">		free(entry-&gt;name);</a>
<a name="ln3315">		delete entry;</a>
<a name="ln3316">	}</a>
<a name="ln3317">}</a>
<a name="ln3318"> </a>
<a name="ln3319"> </a>
<a name="ln3320">bool</a>
<a name="ln3321">MostUsedNames::ObtainList(BList* list)</a>
<a name="ln3322">{</a>
<a name="ln3323">	if (list == NULL)</a>
<a name="ln3324">		return false;</a>
<a name="ln3325"> </a>
<a name="ln3326">	if (!fLoaded)</a>
<a name="ln3327">		UpdateList();</a>
<a name="ln3328"> </a>
<a name="ln3329">	fLock.Lock();</a>
<a name="ln3330"> </a>
<a name="ln3331">	list-&gt;MakeEmpty();</a>
<a name="ln3332">	for (int32 i = 0; i &lt; fCount; i++) {</a>
<a name="ln3333">		list_entry* entry = static_cast&lt;list_entry*&gt;(fList.ItemAt(i));</a>
<a name="ln3334">		if (entry == NULL)</a>
<a name="ln3335">			return true;</a>
<a name="ln3336"> </a>
<a name="ln3337">		list-&gt;AddItem(entry-&gt;name);</a>
<a name="ln3338">	}</a>
<a name="ln3339">	return true;</a>
<a name="ln3340">}</a>
<a name="ln3341"> </a>
<a name="ln3342"> </a>
<a name="ln3343">void</a>
<a name="ln3344">MostUsedNames::ReleaseList()</a>
<a name="ln3345">{</a>
<a name="ln3346">	fLock.Unlock();</a>
<a name="ln3347">}</a>
<a name="ln3348"> </a>
<a name="ln3349"> </a>
<a name="ln3350">void</a>
<a name="ln3351">MostUsedNames::AddName(const char* name)</a>
<a name="ln3352">{</a>
<a name="ln3353">	fLock.Lock();</a>
<a name="ln3354"> </a>
<a name="ln3355">	if (!fLoaded)</a>
<a name="ln3356">		LoadList();</a>
<a name="ln3357"> </a>
<a name="ln3358">	// remove last entry if there are more than</a>
<a name="ln3359">	// 2*fCount entries in the list</a>
<a name="ln3360"> </a>
<a name="ln3361">	list_entry* entry = NULL;</a>
<a name="ln3362"> </a>
<a name="ln3363">	if (fList.CountItems() &gt; fCount * 2) {</a>
<a name="ln3364">		entry = static_cast&lt;list_entry*&gt;(</a>
<a name="ln3365">			fList.RemoveItem(fList.CountItems() - 1));</a>
<a name="ln3366"> </a>
<a name="ln3367">		// is this the name we want to add here?</a>
<a name="ln3368">		if (strcmp(name, entry-&gt;name)) {</a>
<a name="ln3369">			free(entry-&gt;name);</a>
<a name="ln3370">			delete entry;</a>
<a name="ln3371">			entry = NULL;</a>
<a name="ln3372">		} else</a>
<a name="ln3373">			fList.AddItem(entry);</a>
<a name="ln3374">	}</a>
<a name="ln3375"> </a>
<a name="ln3376">	if (entry == NULL) {</a>
<a name="ln3377">		for (int32 i = 0;</a>
<a name="ln3378">				(entry = static_cast&lt;list_entry*&gt;(fList.ItemAt(i))) != NULL; i++) {</a>
<a name="ln3379">			if (strcmp(entry-&gt;name, name) == 0)</a>
<a name="ln3380">				break;</a>
<a name="ln3381">		}</a>
<a name="ln3382">	}</a>
<a name="ln3383"> </a>
<a name="ln3384">	if (entry == NULL) {</a>
<a name="ln3385">		entry = new list_entry;</a>
<a name="ln3386">		entry-&gt;name = strdup(name);</a>
<a name="ln3387">		entry-&gt;count = 1;</a>
<a name="ln3388"> </a>
<a name="ln3389">		fList.AddItem(entry);</a>
<a name="ln3390">	} else if (entry-&gt;count &lt; 0)</a>
<a name="ln3391">		entry-&gt;count = 1;</a>
<a name="ln3392">	else</a>
<a name="ln3393">		entry-&gt;count++;</a>
<a name="ln3394"> </a>
<a name="ln3395">	fLock.Unlock();</a>
<a name="ln3396">	UpdateList();</a>
<a name="ln3397">}</a>
<a name="ln3398"> </a>
<a name="ln3399"> </a>
<a name="ln3400">int</a>
<a name="ln3401">MostUsedNames::CompareNames(const void* a,const void* b)</a>
<a name="ln3402">{</a>
<a name="ln3403">	list_entry* entryA = *(list_entry**)a;</a>
<a name="ln3404">	list_entry* entryB = *(list_entry**)b;</a>
<a name="ln3405"> </a>
<a name="ln3406">	if (entryA-&gt;count == entryB-&gt;count)</a>
<a name="ln3407">		return strcasecmp(entryA-&gt;name,entryB-&gt;name);</a>
<a name="ln3408"> </a>
<a name="ln3409">	return entryB-&gt;count - entryA-&gt;count;</a>
<a name="ln3410">}</a>
<a name="ln3411"> </a>
<a name="ln3412"> </a>
<a name="ln3413">void</a>
<a name="ln3414">MostUsedNames::LoadList()</a>
<a name="ln3415">{</a>
<a name="ln3416">	if (fLoaded)</a>
<a name="ln3417">		return;</a>
<a name="ln3418">	fLoaded = true;</a>
<a name="ln3419"> </a>
<a name="ln3420">	// load the most used names list</a>
<a name="ln3421"> </a>
<a name="ln3422">	BPath path;</a>
<a name="ln3423">	if (find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path, true) != B_OK</a>
<a name="ln3424">		|| path.Append(fDirectory) != B_OK || path.Append(fFileName) != B_OK) {</a>
<a name="ln3425">		return;</a>
<a name="ln3426">	}</a>
<a name="ln3427"> </a>
<a name="ln3428">	FILE* file = fopen(path.Path(), &quot;r&quot;);</a>
<a name="ln3429">	if (file == NULL)</a>
<a name="ln3430">		return;</a>
<a name="ln3431"> </a>
<a name="ln3432">	char line[B_FILE_NAME_LENGTH + 5];</a>
<a name="ln3433">	while (fgets(line, sizeof(line), file) != NULL) {</a>
<a name="ln3434">		int32 length = (int32)strlen(line) - 1;</a>
<a name="ln3435">		if (length &gt;= 0 &amp;&amp; line[length] == '\n')</a>
<a name="ln3436">			line[length] = '\0';</a>
<a name="ln3437"> </a>
<a name="ln3438">		int32 count = atoi(line);</a>
<a name="ln3439"> </a>
<a name="ln3440">		char* name = strchr(line, ' ');</a>
<a name="ln3441">		if (name == NULL || *(++name) == '\0')</a>
<a name="ln3442">			continue;</a>
<a name="ln3443"> </a>
<a name="ln3444">		list_entry* entry = new list_entry;</a>
<a name="ln3445">		entry-&gt;name = strdup(name);</a>
<a name="ln3446">		entry-&gt;count = count;</a>
<a name="ln3447"> </a>
<a name="ln3448">		fList.AddItem(entry);</a>
<a name="ln3449">	}</a>
<a name="ln3450">	fclose(file);</a>
<a name="ln3451">}</a>
<a name="ln3452"> </a>
<a name="ln3453"> </a>
<a name="ln3454">void</a>
<a name="ln3455">MostUsedNames::UpdateList()</a>
<a name="ln3456">{</a>
<a name="ln3457">	AutoLock&lt;Benaphore&gt; locker(fLock);</a>
<a name="ln3458"> </a>
<a name="ln3459">	if (!fLoaded)</a>
<a name="ln3460">		LoadList();</a>
<a name="ln3461"> </a>
<a name="ln3462">	// sort list items</a>
<a name="ln3463"> </a>
<a name="ln3464">	fList.SortItems(MostUsedNames::CompareNames);</a>
<a name="ln3465">}</a>
<a name="ln3466"> </a>
<a name="ln3467">}	// namespace BPrivate</a>

</code></pre>
<div class="balloon" rel="327"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'fFile' pointer was utilized before it was verified against nullptr. Check lines: 327, 333.</p></div>
<div class="balloon" rel="2096"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'removeButton' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="2096"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'addButton' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v517/" target="_blank">V517</a> The use of 'if (A) {...} else if (A) {...}' pattern was detected. There is a probability of logical error presence. Check lines: 1407, 1410.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
