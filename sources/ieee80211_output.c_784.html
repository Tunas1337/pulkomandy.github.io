
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ieee80211_output.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2001 Atsushi Onoe</a>
<a name="ln5"> * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting</a>
<a name="ln6"> * All rights reserved.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln9"> * modification, are permitted provided that the following conditions</a>
<a name="ln10"> * are met:</a>
<a name="ln11"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln12"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln15"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln16"> *</a>
<a name="ln17"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</a>
<a name="ln18"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</a>
<a name="ln19"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</a>
<a name="ln20"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</a>
<a name="ln21"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</a>
<a name="ln22"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln23"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln24"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln25"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</a>
<a name="ln26"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln27"> */</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln30">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/net80211/ieee80211_output.c 330688 2018-03-09 11:33:56Z avos $&quot;);</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;opt_inet.h&quot;</a>
<a name="ln33">#include &quot;opt_inet6.h&quot;</a>
<a name="ln34">#include &quot;opt_wlan.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;sys/param.h&gt;</a>
<a name="ln37">#include &lt;sys/systm.h&gt;</a>
<a name="ln38">#include &lt;sys/kernel.h&gt;</a>
<a name="ln39">#include &lt;sys/malloc.h&gt;</a>
<a name="ln40">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln41">#include &lt;sys/endian.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;sys/socket.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;net/bpf.h&gt;</a>
<a name="ln46">#include &lt;net/ethernet.h&gt;</a>
<a name="ln47">#include &lt;net/if.h&gt;</a>
<a name="ln48">#include &lt;net/if_var.h&gt;</a>
<a name="ln49">#include &lt;net/if_llc.h&gt;</a>
<a name="ln50">#include &lt;net/if_media.h&gt;</a>
<a name="ln51">#include &lt;net/if_vlan_var.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln54">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln55">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln56">#include &lt;net80211/ieee80211_superg.h&gt;</a>
<a name="ln57">#endif</a>
<a name="ln58">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln59">#include &lt;net80211/ieee80211_tdma.h&gt;</a>
<a name="ln60">#endif</a>
<a name="ln61">#include &lt;net80211/ieee80211_wds.h&gt;</a>
<a name="ln62">#include &lt;net80211/ieee80211_mesh.h&gt;</a>
<a name="ln63">#include &lt;net80211/ieee80211_vht.h&gt;</a>
<a name="ln64"> </a>
<a name="ln65">#if defined(INET) || defined(INET6)</a>
<a name="ln66">#include &lt;netinet/in.h&gt;</a>
<a name="ln67">#endif</a>
<a name="ln68"> </a>
<a name="ln69">#ifdef INET</a>
<a name="ln70">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln71">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln72">#include &lt;netinet/ip.h&gt;</a>
<a name="ln73">#endif</a>
<a name="ln74">#ifdef INET6</a>
<a name="ln75">#include &lt;netinet/ip6.h&gt;</a>
<a name="ln76">#endif</a>
<a name="ln77"> </a>
<a name="ln78">#include &lt;security/mac/mac_framework.h&gt;</a>
<a name="ln79"> </a>
<a name="ln80">#define	ETHER_HEADER_COPY(dst, src) \</a>
<a name="ln81">	memcpy(dst, src, sizeof(struct ether_header))</a>
<a name="ln82"> </a>
<a name="ln83">static int ieee80211_fragment(struct ieee80211vap *, struct mbuf *,</a>
<a name="ln84">	u_int hdrsize, u_int ciphdrsize, u_int mtu);</a>
<a name="ln85">static	void ieee80211_tx_mgt_cb(struct ieee80211_node *, void *, int);</a>
<a name="ln86"> </a>
<a name="ln87">#ifdef IEEE80211_DEBUG</a>
<a name="ln88">/*</a>
<a name="ln89"> * Decide if an outbound management frame should be</a>
<a name="ln90"> * printed when debugging is enabled.  This filters some</a>
<a name="ln91"> * of the less interesting frames that come frequently</a>
<a name="ln92"> * (e.g. beacons).</a>
<a name="ln93"> */</a>
<a name="ln94">static __inline int</a>
<a name="ln95">doprint(struct ieee80211vap *vap, int subtype)</a>
<a name="ln96">{</a>
<a name="ln97">	switch (subtype) {</a>
<a name="ln98">	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:</a>
<a name="ln99">		return (vap-&gt;iv_opmode == IEEE80211_M_IBSS);</a>
<a name="ln100">	}</a>
<a name="ln101">	return 1;</a>
<a name="ln102">}</a>
<a name="ln103">#endif</a>
<a name="ln104"> </a>
<a name="ln105">/*</a>
<a name="ln106"> * Transmit a frame to the given destination on the given VAP.</a>
<a name="ln107"> *</a>
<a name="ln108"> * It's up to the caller to figure out the details of who this</a>
<a name="ln109"> * is going to and resolving the node.</a>
<a name="ln110"> *</a>
<a name="ln111"> * This routine takes care of queuing it for power save,</a>
<a name="ln112"> * A-MPDU state stuff, fast-frames state stuff, encapsulation</a>
<a name="ln113"> * if required, then passing it up to the driver layer.</a>
<a name="ln114"> *</a>
<a name="ln115"> * This routine (for now) consumes the mbuf and frees the node</a>
<a name="ln116"> * reference; it ideally will return a TX status which reflects</a>
<a name="ln117"> * whether the mbuf was consumed or not, so the caller can</a>
<a name="ln118"> * free the mbuf (if appropriate) and the node reference (again,</a>
<a name="ln119"> * if appropriate.)</a>
<a name="ln120"> */</a>
<a name="ln121">int</a>
<a name="ln122">ieee80211_vap_pkt_send_dest(struct ieee80211vap *vap, struct mbuf *m,</a>
<a name="ln123">    struct ieee80211_node *ni)</a>
<a name="ln124">{</a>
<a name="ln125">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln126">	struct ifnet *ifp = vap-&gt;iv_ifp;</a>
<a name="ln127">	int mcast;</a>
<a name="ln128"> </a>
<a name="ln129">	if ((ni-&gt;ni_flags &amp; IEEE80211_NODE_PWR_MGT) &amp;&amp;</a>
<a name="ln130">	    (m-&gt;m_flags &amp; M_PWR_SAV) == 0) {</a>
<a name="ln131">		/*</a>
<a name="ln132">		 * Station in power save mode; pass the frame</a>
<a name="ln133">		 * to the 802.11 layer and continue.  We'll get</a>
<a name="ln134">		 * the frame back when the time is right.</a>
<a name="ln135">		 * XXX lose WDS vap linkage?</a>
<a name="ln136">		 */</a>
<a name="ln137">		if (ieee80211_pwrsave(ni, m) != 0)</a>
<a name="ln138">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln139">		ieee80211_free_node(ni);</a>
<a name="ln140"> </a>
<a name="ln141">		/*</a>
<a name="ln142">		 * We queued it fine, so tell the upper layer</a>
<a name="ln143">		 * that we consumed it.</a>
<a name="ln144">		 */</a>
<a name="ln145">		return (0);</a>
<a name="ln146">	}</a>
<a name="ln147">	/* calculate priority so drivers can find the tx queue */</a>
<a name="ln148">	if (ieee80211_classify(ni, m)) {</a>
<a name="ln149">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_OUTPUT,</a>
<a name="ln150">		    ni-&gt;ni_macaddr, NULL,</a>
<a name="ln151">		    &quot;%s&quot;, &quot;classification failure&quot;);</a>
<a name="ln152">		vap-&gt;iv_stats.is_tx_classify++;</a>
<a name="ln153">		if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln154">		m_freem(m);</a>
<a name="ln155">		ieee80211_free_node(ni);</a>
<a name="ln156"> </a>
<a name="ln157">		/* XXX better status? */</a>
<a name="ln158">		return (0);</a>
<a name="ln159">	}</a>
<a name="ln160">	/*</a>
<a name="ln161">	 * Stash the node pointer.  Note that we do this after</a>
<a name="ln162">	 * any call to ieee80211_dwds_mcast because that code</a>
<a name="ln163">	 * uses any existing value for rcvif to identify the</a>
<a name="ln164">	 * interface it (might have been) received on.</a>
<a name="ln165">	 */</a>
<a name="ln166">	m-&gt;m_pkthdr.rcvif = (void *)ni;</a>
<a name="ln167">	mcast = (m-&gt;m_flags &amp; (M_MCAST | M_BCAST)) ? 1: 0;</a>
<a name="ln168"> </a>
<a name="ln169">	BPF_MTAP(ifp, m);		/* 802.3 tx */</a>
<a name="ln170"> </a>
<a name="ln171">	/*</a>
<a name="ln172">	 * Check if A-MPDU tx aggregation is setup or if we</a>
<a name="ln173">	 * should try to enable it.  The sta must be associated</a>
<a name="ln174">	 * with HT and A-MPDU enabled for use.  When the policy</a>
<a name="ln175">	 * routine decides we should enable A-MPDU we issue an</a>
<a name="ln176">	 * ADDBA request and wait for a reply.  The frame being</a>
<a name="ln177">	 * encapsulated will go out w/o using A-MPDU, or possibly</a>
<a name="ln178">	 * it might be collected by the driver and held/retransmit.</a>
<a name="ln179">	 * The default ic_ampdu_enable routine handles staggering</a>
<a name="ln180">	 * ADDBA requests in case the receiver NAK's us or we are</a>
<a name="ln181">	 * otherwise unable to establish a BA stream.</a>
<a name="ln182">	 *</a>
<a name="ln183">	 * Don't treat group-addressed frames as candidates for aggregation;</a>
<a name="ln184">	 * net80211 doesn't support 802.11aa-2012 and so group addressed</a>
<a name="ln185">	 * frames will always have sequence numbers allocated from the NON_QOS</a>
<a name="ln186">	 * TID.</a>
<a name="ln187">	 */</a>
<a name="ln188">	if ((ni-&gt;ni_flags &amp; IEEE80211_NODE_AMPDU_TX) &amp;&amp;</a>
<a name="ln189">	    (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_AMPDU_TX)) {</a>
<a name="ln190">		if ((m-&gt;m_flags &amp; M_EAPOL) == 0 &amp;&amp; (! mcast)) {</a>
<a name="ln191">			int tid = WME_AC_TO_TID(M_WME_GETAC(m));</a>
<a name="ln192">			struct ieee80211_tx_ampdu *tap = &amp;ni-&gt;ni_tx_ampdu[tid];</a>
<a name="ln193"> </a>
<a name="ln194">			ieee80211_txampdu_count_packet(tap);</a>
<a name="ln195">			if (IEEE80211_AMPDU_RUNNING(tap)) {</a>
<a name="ln196">				/*</a>
<a name="ln197">				 * Operational, mark frame for aggregation.</a>
<a name="ln198">				 *</a>
<a name="ln199">				 * XXX do tx aggregation here</a>
<a name="ln200">				 */</a>
<a name="ln201">				m-&gt;m_flags |= M_AMPDU_MPDU;</a>
<a name="ln202">			} else if (!IEEE80211_AMPDU_REQUESTED(tap) &amp;&amp;</a>
<a name="ln203">			    ic-&gt;ic_ampdu_enable(ni, tap)) {</a>
<a name="ln204">				/*</a>
<a name="ln205">				 * Not negotiated yet, request service.</a>
<a name="ln206">				 */</a>
<a name="ln207">				ieee80211_ampdu_request(ni, tap);</a>
<a name="ln208">				/* XXX hold frame for reply? */</a>
<a name="ln209">			}</a>
<a name="ln210">		}</a>
<a name="ln211">	}</a>
<a name="ln212"> </a>
<a name="ln213">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln214">	/*</a>
<a name="ln215">	 * Check for AMSDU/FF; queue for aggregation</a>
<a name="ln216">	 *</a>
<a name="ln217">	 * Note: we don't bother trying to do fast frames or</a>
<a name="ln218">	 * A-MSDU encapsulation for 802.3 drivers.  Now, we</a>
<a name="ln219">	 * likely could do it for FF (because it's a magic</a>
<a name="ln220">	 * atheros tunnel LLC type) but I don't think we're going</a>
<a name="ln221">	 * to really need to.  For A-MSDU we'd have to set the</a>
<a name="ln222">	 * A-MSDU QoS bit in the wifi header, so we just plain</a>
<a name="ln223">	 * can't do it.</a>
<a name="ln224">	 *</a>
<a name="ln225">	 * Strictly speaking, we could actually /do/ A-MSDU / FF</a>
<a name="ln226">	 * with A-MPDU together which for certain circumstances</a>
<a name="ln227">	 * is beneficial (eg A-MSDU of TCK ACKs.)  However,</a>
<a name="ln228">	 * I'll ignore that for now so existing behaviour is maintained.</a>
<a name="ln229">	 * Later on it would be good to make &quot;amsdu + ampdu&quot; configurable.</a>
<a name="ln230">	 */</a>
<a name="ln231">	else if (__predict_true((vap-&gt;iv_caps &amp; IEEE80211_C_8023ENCAP) == 0)) {</a>
<a name="ln232">		if ((! mcast) &amp;&amp; ieee80211_amsdu_tx_ok(ni)) {</a>
<a name="ln233">			m = ieee80211_amsdu_check(ni, m);</a>
<a name="ln234">			if (m == NULL) {</a>
<a name="ln235">				/* NB: any ni ref held on stageq */</a>
<a name="ln236">				IEEE80211_DPRINTF(vap, IEEE80211_MSG_SUPERG,</a>
<a name="ln237">				    &quot;%s: amsdu_check queued frame\n&quot;,</a>
<a name="ln238">				    __func__);</a>
<a name="ln239">				return (0);</a>
<a name="ln240">			}</a>
<a name="ln241">		} else if ((! mcast) &amp;&amp; IEEE80211_ATH_CAP(vap, ni,</a>
<a name="ln242">		    IEEE80211_NODE_FF)) {</a>
<a name="ln243">			m = ieee80211_ff_check(ni, m);</a>
<a name="ln244">			if (m == NULL) {</a>
<a name="ln245">				/* NB: any ni ref held on stageq */</a>
<a name="ln246">				IEEE80211_DPRINTF(vap, IEEE80211_MSG_SUPERG,</a>
<a name="ln247">				    &quot;%s: ff_check queued frame\n&quot;,</a>
<a name="ln248">				    __func__);</a>
<a name="ln249">				return (0);</a>
<a name="ln250">			}</a>
<a name="ln251">		}</a>
<a name="ln252">	}</a>
<a name="ln253">#endif /* IEEE80211_SUPPORT_SUPERG */</a>
<a name="ln254"> </a>
<a name="ln255">	/*</a>
<a name="ln256">	 * Grab the TX lock - serialise the TX process from this</a>
<a name="ln257">	 * point (where TX state is being checked/modified)</a>
<a name="ln258">	 * through to driver queue.</a>
<a name="ln259">	 */</a>
<a name="ln260">	IEEE80211_TX_LOCK(ic);</a>
<a name="ln261"> </a>
<a name="ln262">	/*</a>
<a name="ln263">	 * XXX make the encap and transmit code a separate function</a>
<a name="ln264">	 * so things like the FF (and later A-MSDU) path can just call</a>
<a name="ln265">	 * it for flushed frames.</a>
<a name="ln266">	 */</a>
<a name="ln267">	if (__predict_true((vap-&gt;iv_caps &amp; IEEE80211_C_8023ENCAP) == 0)) {</a>
<a name="ln268">		/*</a>
<a name="ln269">		 * Encapsulate the packet in prep for transmission.</a>
<a name="ln270">		 */</a>
<a name="ln271">		m = ieee80211_encap(vap, ni, m);</a>
<a name="ln272">		if (m == NULL) {</a>
<a name="ln273">			/* NB: stat+msg handled in ieee80211_encap */</a>
<a name="ln274">			IEEE80211_TX_UNLOCK(ic);</a>
<a name="ln275">			ieee80211_free_node(ni);</a>
<a name="ln276">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln277">			return (ENOBUFS);</a>
<a name="ln278">		}</a>
<a name="ln279">	}</a>
<a name="ln280">	(void) ieee80211_parent_xmitpkt(ic, m);</a>
<a name="ln281"> </a>
<a name="ln282">	/*</a>
<a name="ln283">	 * Unlock at this point - no need to hold it across</a>
<a name="ln284">	 * ieee80211_free_node() (ie, the comlock)</a>
<a name="ln285">	 */</a>
<a name="ln286">	IEEE80211_TX_UNLOCK(ic);</a>
<a name="ln287">	ic-&gt;ic_lastdata = ticks;</a>
<a name="ln288"> </a>
<a name="ln289">	return (0);</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292"> </a>
<a name="ln293"> </a>
<a name="ln294">/*</a>
<a name="ln295"> * Send the given mbuf through the given vap.</a>
<a name="ln296"> *</a>
<a name="ln297"> * This consumes the mbuf regardless of whether the transmit</a>
<a name="ln298"> * was successful or not.</a>
<a name="ln299"> *</a>
<a name="ln300"> * This does none of the initial checks that ieee80211_start()</a>
<a name="ln301"> * does (eg CAC timeout, interface wakeup) - the caller must</a>
<a name="ln302"> * do this first.</a>
<a name="ln303"> */</a>
<a name="ln304">static int</a>
<a name="ln305">ieee80211_start_pkt(struct ieee80211vap *vap, struct mbuf *m)</a>
<a name="ln306">{</a>
<a name="ln307">#define	IS_DWDS(vap) \</a>
<a name="ln308">	(vap-&gt;iv_opmode == IEEE80211_M_WDS &amp;&amp; \</a>
<a name="ln309">	 (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_WDSLEGACY) == 0)</a>
<a name="ln310">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln311">	struct ifnet *ifp = vap-&gt;iv_ifp;</a>
<a name="ln312">	struct ieee80211_node *ni;</a>
<a name="ln313">	struct ether_header *eh;</a>
<a name="ln314"> </a>
<a name="ln315">	/*</a>
<a name="ln316">	 * Cancel any background scan.</a>
<a name="ln317">	 */</a>
<a name="ln318">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN)</a>
<a name="ln319">		ieee80211_cancel_anyscan(vap);</a>
<a name="ln320">	/*</a>
<a name="ln321">	 * Find the node for the destination so we can do</a>
<a name="ln322">	 * things like power save and fast frames aggregation.</a>
<a name="ln323">	 *</a>
<a name="ln324">	 * NB: past this point various code assumes the first</a>
<a name="ln325">	 *     mbuf has the 802.3 header present (and contiguous).</a>
<a name="ln326">	 */</a>
<a name="ln327">	ni = NULL;</a>
<a name="ln328">	if (m-&gt;m_len &lt; sizeof(struct ether_header) &amp;&amp;</a>
<a name="ln329">	   (m = m_pullup(m, sizeof(struct ether_header))) == NULL) {</a>
<a name="ln330">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_OUTPUT,</a>
<a name="ln331">		    &quot;discard frame, %s\n&quot;, &quot;m_pullup failed&quot;);</a>
<a name="ln332">		vap-&gt;iv_stats.is_tx_nobuf++;	/* XXX */</a>
<a name="ln333">		if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln334">		return (ENOBUFS);</a>
<a name="ln335">	}</a>
<a name="ln336">	eh = mtod(m, struct ether_header *);</a>
<a name="ln337">	if (ETHER_IS_MULTICAST(eh-&gt;ether_dhost)) {</a>
<a name="ln338">		if (IS_DWDS(vap)) {</a>
<a name="ln339">			/*</a>
<a name="ln340">			 * Only unicast frames from the above go out</a>
<a name="ln341">			 * DWDS vaps; multicast frames are handled by</a>
<a name="ln342">			 * dispatching the frame as it comes through</a>
<a name="ln343">			 * the AP vap (see below).</a>
<a name="ln344">			 */</a>
<a name="ln345">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_WDS,</a>
<a name="ln346">			    eh-&gt;ether_dhost, &quot;mcast&quot;, &quot;%s&quot;, &quot;on DWDS&quot;);</a>
<a name="ln347">			vap-&gt;iv_stats.is_dwds_mcast++;</a>
<a name="ln348">			m_freem(m);</a>
<a name="ln349">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln350">			/* XXX better status? */</a>
<a name="ln351">			return (ENOBUFS);</a>
<a name="ln352">		}</a>
<a name="ln353">		if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP) {</a>
<a name="ln354">			/*</a>
<a name="ln355">			 * Spam DWDS vap's w/ multicast traffic.</a>
<a name="ln356">			 */</a>
<a name="ln357">			/* XXX only if dwds in use? */</a>
<a name="ln358">			ieee80211_dwds_mcast(vap, m);</a>
<a name="ln359">		}</a>
<a name="ln360">	}</a>
<a name="ln361">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln362">	if (vap-&gt;iv_opmode != IEEE80211_M_MBSS) {</a>
<a name="ln363">#endif</a>
<a name="ln364">		ni = ieee80211_find_txnode(vap, eh-&gt;ether_dhost);</a>
<a name="ln365">		if (ni == NULL) {</a>
<a name="ln366">			/* NB: ieee80211_find_txnode does stat+msg */</a>
<a name="ln367">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln368">			m_freem(m);</a>
<a name="ln369">			/* XXX better status? */</a>
<a name="ln370">			return (ENOBUFS);</a>
<a name="ln371">		}</a>
<a name="ln372">		if (ni-&gt;ni_associd == 0 &amp;&amp;</a>
<a name="ln373">		    (ni-&gt;ni_flags &amp; IEEE80211_NODE_ASSOCID)) {</a>
<a name="ln374">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_OUTPUT,</a>
<a name="ln375">			    eh-&gt;ether_dhost, NULL,</a>
<a name="ln376">			    &quot;sta not associated (type 0x%04x)&quot;,</a>
<a name="ln377">			    htons(eh-&gt;ether_type));</a>
<a name="ln378">			vap-&gt;iv_stats.is_tx_notassoc++;</a>
<a name="ln379">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln380">			m_freem(m);</a>
<a name="ln381">			ieee80211_free_node(ni);</a>
<a name="ln382">			/* XXX better status? */</a>
<a name="ln383">			return (ENOBUFS);</a>
<a name="ln384">		}</a>
<a name="ln385">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln386">	} else {</a>
<a name="ln387">		if (!IEEE80211_ADDR_EQ(eh-&gt;ether_shost, vap-&gt;iv_myaddr)) {</a>
<a name="ln388">			/*</a>
<a name="ln389">			 * Proxy station only if configured.</a>
<a name="ln390">			 */</a>
<a name="ln391">			if (!ieee80211_mesh_isproxyena(vap)) {</a>
<a name="ln392">				IEEE80211_DISCARD_MAC(vap,</a>
<a name="ln393">				    IEEE80211_MSG_OUTPUT |</a>
<a name="ln394">				    IEEE80211_MSG_MESH,</a>
<a name="ln395">				    eh-&gt;ether_dhost, NULL,</a>
<a name="ln396">				    &quot;%s&quot;, &quot;proxy not enabled&quot;);</a>
<a name="ln397">				vap-&gt;iv_stats.is_mesh_notproxy++;</a>
<a name="ln398">				if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln399">				m_freem(m);</a>
<a name="ln400">				/* XXX better status? */</a>
<a name="ln401">				return (ENOBUFS);</a>
<a name="ln402">			}</a>
<a name="ln403">			IEEE80211_DPRINTF(vap, IEEE80211_MSG_OUTPUT,</a>
<a name="ln404">			    &quot;forward frame from DS SA(%6D), DA(%6D)\n&quot;,</a>
<a name="ln405">			    eh-&gt;ether_shost, &quot;:&quot;,</a>
<a name="ln406">			    eh-&gt;ether_dhost, &quot;:&quot;);</a>
<a name="ln407">			ieee80211_mesh_proxy_check(vap, eh-&gt;ether_shost);</a>
<a name="ln408">		}</a>
<a name="ln409">		ni = ieee80211_mesh_discover(vap, eh-&gt;ether_dhost, m);</a>
<a name="ln410">		if (ni == NULL) {</a>
<a name="ln411">			/*</a>
<a name="ln412">			 * NB: ieee80211_mesh_discover holds/disposes</a>
<a name="ln413">			 * frame (e.g. queueing on path discovery).</a>
<a name="ln414">			 */</a>
<a name="ln415">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln416">			/* XXX better status? */</a>
<a name="ln417">			return (ENOBUFS);</a>
<a name="ln418">		}</a>
<a name="ln419">	}</a>
<a name="ln420">#endif</a>
<a name="ln421"> </a>
<a name="ln422">	/*</a>
<a name="ln423">	 * We've resolved the sender, so attempt to transmit it.</a>
<a name="ln424">	 */</a>
<a name="ln425"> </a>
<a name="ln426">	if (vap-&gt;iv_state == IEEE80211_S_SLEEP) {</a>
<a name="ln427">		/*</a>
<a name="ln428">		 * In power save; queue frame and then  wakeup device</a>
<a name="ln429">		 * for transmit.</a>
<a name="ln430">		 */</a>
<a name="ln431">		ic-&gt;ic_lastdata = ticks;</a>
<a name="ln432">		if (ieee80211_pwrsave(ni, m) != 0)</a>
<a name="ln433">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln434">		ieee80211_free_node(ni);</a>
<a name="ln435">		ieee80211_new_state(vap, IEEE80211_S_RUN, 0);</a>
<a name="ln436">		return (0);</a>
<a name="ln437">	}</a>
<a name="ln438"> </a>
<a name="ln439">	if (ieee80211_vap_pkt_send_dest(vap, m, ni) != 0)</a>
<a name="ln440">		return (ENOBUFS);</a>
<a name="ln441">	return (0);</a>
<a name="ln442">#undef	IS_DWDS</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">/*</a>
<a name="ln446"> * Start method for vap's.  All packets from the stack come</a>
<a name="ln447"> * through here.  We handle common processing of the packets</a>
<a name="ln448"> * before dispatching them to the underlying device.</a>
<a name="ln449"> *</a>
<a name="ln450"> * if_transmit() requires that the mbuf be consumed by this call</a>
<a name="ln451"> * regardless of the return condition.</a>
<a name="ln452"> */</a>
<a name="ln453">int</a>
<a name="ln454">ieee80211_vap_transmit(struct ifnet *ifp, struct mbuf *m)</a>
<a name="ln455">{</a>
<a name="ln456">	struct ieee80211vap *vap = ifp-&gt;if_softc;</a>
<a name="ln457">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln458"> </a>
<a name="ln459">	/*</a>
<a name="ln460">	 * No data frames go out unless we're running.</a>
<a name="ln461">	 * Note in particular this covers CAC and CSA</a>
<a name="ln462">	 * states (though maybe we should check muting</a>
<a name="ln463">	 * for CSA).</a>
<a name="ln464">	 */</a>
<a name="ln465">	if (vap-&gt;iv_state != IEEE80211_S_RUN &amp;&amp;</a>
<a name="ln466">	    vap-&gt;iv_state != IEEE80211_S_SLEEP) {</a>
<a name="ln467">		IEEE80211_LOCK(ic);</a>
<a name="ln468">		/* re-check under the com lock to avoid races */</a>
<a name="ln469">		if (vap-&gt;iv_state != IEEE80211_S_RUN &amp;&amp;</a>
<a name="ln470">		    vap-&gt;iv_state != IEEE80211_S_SLEEP) {</a>
<a name="ln471">			IEEE80211_DPRINTF(vap, IEEE80211_MSG_OUTPUT,</a>
<a name="ln472">			    &quot;%s: ignore queue, in %s state\n&quot;,</a>
<a name="ln473">			    __func__, ieee80211_state_name[vap-&gt;iv_state]);</a>
<a name="ln474">			vap-&gt;iv_stats.is_tx_badstate++;</a>
<a name="ln475">			IEEE80211_UNLOCK(ic);</a>
<a name="ln476">			ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln477">			m_freem(m);</a>
<a name="ln478">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln479">			return (ENETDOWN);</a>
<a name="ln480">		}</a>
<a name="ln481">		IEEE80211_UNLOCK(ic);</a>
<a name="ln482">	}</a>
<a name="ln483"> </a>
<a name="ln484">	/*</a>
<a name="ln485">	 * Sanitize mbuf flags for net80211 use.  We cannot</a>
<a name="ln486">	 * clear M_PWR_SAV or M_MORE_DATA because these may</a>
<a name="ln487">	 * be set for frames that are re-submitted from the</a>
<a name="ln488">	 * power save queue.</a>
<a name="ln489">	 *</a>
<a name="ln490">	 * NB: This must be done before ieee80211_classify as</a>
<a name="ln491">	 *     it marks EAPOL in frames with M_EAPOL.</a>
<a name="ln492">	 */</a>
<a name="ln493">	m-&gt;m_flags &amp;= ~(M_80211_TX - M_PWR_SAV - M_MORE_DATA);</a>
<a name="ln494"> </a>
<a name="ln495">	/*</a>
<a name="ln496">	 * Bump to the packet transmission path.</a>
<a name="ln497">	 * The mbuf will be consumed here.</a>
<a name="ln498">	 */</a>
<a name="ln499">	return (ieee80211_start_pkt(vap, m));</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">void</a>
<a name="ln503">ieee80211_vap_qflush(struct ifnet *ifp)</a>
<a name="ln504">{</a>
<a name="ln505"> </a>
<a name="ln506">	/* Empty for now */</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">/*</a>
<a name="ln510"> * 802.11 raw output routine.</a>
<a name="ln511"> *</a>
<a name="ln512"> * XXX TODO: this (and other send routines) should correctly</a>
<a name="ln513"> * XXX keep the pwr mgmt bit set if it decides to call into the</a>
<a name="ln514"> * XXX driver to send a frame whilst the state is SLEEP.</a>
<a name="ln515"> *</a>
<a name="ln516"> * Otherwise the peer may decide that we're awake and flood us</a>
<a name="ln517"> * with traffic we are still too asleep to receive!</a>
<a name="ln518"> */</a>
<a name="ln519">int</a>
<a name="ln520">ieee80211_raw_output(struct ieee80211vap *vap, struct ieee80211_node *ni,</a>
<a name="ln521">    struct mbuf *m, const struct ieee80211_bpf_params *params)</a>
<a name="ln522">{</a>
<a name="ln523">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln524">	int error;</a>
<a name="ln525"> </a>
<a name="ln526">	/*</a>
<a name="ln527">	 * Set node - the caller has taken a reference, so ensure</a>
<a name="ln528">	 * that the mbuf has the same node value that</a>
<a name="ln529">	 * it would if it were going via the normal path.</a>
<a name="ln530">	 */</a>
<a name="ln531">	m-&gt;m_pkthdr.rcvif = (void *)ni;</a>
<a name="ln532"> </a>
<a name="ln533">	/*</a>
<a name="ln534">	 * Attempt to add bpf transmit parameters.</a>
<a name="ln535">	 *</a>
<a name="ln536">	 * For now it's ok to fail; the raw_xmit api still takes</a>
<a name="ln537">	 * them as an option.</a>
<a name="ln538">	 *</a>
<a name="ln539">	 * Later on when ic_raw_xmit() has params removed,</a>
<a name="ln540">	 * they'll have to be added - so fail the transmit if</a>
<a name="ln541">	 * they can't be.</a>
<a name="ln542">	 */</a>
<a name="ln543">	if (params)</a>
<a name="ln544">		(void) ieee80211_add_xmit_params(m, params);</a>
<a name="ln545"> </a>
<a name="ln546">	error = ic-&gt;ic_raw_xmit(ni, m, params);</a>
<a name="ln547">	if (error) {</a>
<a name="ln548">		if_inc_counter(vap-&gt;iv_ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln549">		ieee80211_free_node(ni);</a>
<a name="ln550">	}</a>
<a name="ln551">	return (error);</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">static int</a>
<a name="ln555">ieee80211_validate_frame(struct mbuf *m,</a>
<a name="ln556">    const struct ieee80211_bpf_params *params)</a>
<a name="ln557">{</a>
<a name="ln558">	struct ieee80211_frame *wh;</a>
<a name="ln559">	int type;</a>
<a name="ln560"> </a>
<a name="ln561">	if (m-&gt;m_pkthdr.len &lt; sizeof(struct ieee80211_frame_ack))</a>
<a name="ln562">		return (EINVAL);</a>
<a name="ln563"> </a>
<a name="ln564">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln565">	if ((wh-&gt;i_fc[0] &amp; IEEE80211_FC0_VERSION_MASK) !=</a>
<a name="ln566">	    IEEE80211_FC0_VERSION_0)</a>
<a name="ln567">		return (EINVAL);</a>
<a name="ln568"> </a>
<a name="ln569">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln570">	if (type != IEEE80211_FC0_TYPE_DATA) {</a>
<a name="ln571">		if ((wh-&gt;i_fc[1] &amp; IEEE80211_FC1_DIR_MASK) !=</a>
<a name="ln572">		    IEEE80211_FC1_DIR_NODS)</a>
<a name="ln573">			return (EINVAL);</a>
<a name="ln574"> </a>
<a name="ln575">		if (type != IEEE80211_FC0_TYPE_MGT &amp;&amp;</a>
<a name="ln576">		    (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_MORE_FRAG) != 0)</a>
<a name="ln577">			return (EINVAL);</a>
<a name="ln578"> </a>
<a name="ln579">		/* XXX skip other field checks? */</a>
<a name="ln580">	}</a>
<a name="ln581"> </a>
<a name="ln582">	if ((params &amp;&amp; (params-&gt;ibp_flags &amp; IEEE80211_BPF_CRYPTO) != 0) ||</a>
<a name="ln583">	    (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) != 0) {</a>
<a name="ln584">		int subtype;</a>
<a name="ln585"> </a>
<a name="ln586">		subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln587"> </a>
<a name="ln588">		/*</a>
<a name="ln589">		 * See IEEE Std 802.11-2012,</a>
<a name="ln590">		 * 8.2.4.1.9 'Protected Frame field'</a>
<a name="ln591">		 */</a>
<a name="ln592">		/* XXX no support for robust management frames yet. */</a>
<a name="ln593">		if (!(type == IEEE80211_FC0_TYPE_DATA ||</a>
<a name="ln594">		    (type == IEEE80211_FC0_TYPE_MGT &amp;&amp;</a>
<a name="ln595">		     subtype == IEEE80211_FC0_SUBTYPE_AUTH)))</a>
<a name="ln596">			return (EINVAL);</a>
<a name="ln597"> </a>
<a name="ln598">		wh-&gt;i_fc[1] |= IEEE80211_FC1_PROTECTED;</a>
<a name="ln599">	}</a>
<a name="ln600"> </a>
<a name="ln601">	if (m-&gt;m_pkthdr.len &lt; ieee80211_anyhdrsize(wh))</a>
<a name="ln602">		return (EINVAL);</a>
<a name="ln603"> </a>
<a name="ln604">	return (0);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">/*</a>
<a name="ln608"> * 802.11 output routine. This is (currently) used only to</a>
<a name="ln609"> * connect bpf write calls to the 802.11 layer for injecting</a>
<a name="ln610"> * raw 802.11 frames.</a>
<a name="ln611"> */</a>
<a name="ln612">int</a>
<a name="ln613">ieee80211_output(struct ifnet *ifp, struct mbuf *m,</a>
<a name="ln614">	const struct sockaddr *dst, struct route *ro)</a>
<a name="ln615">{</a>
<a name="ln616">#define senderr(e) do { error = (e); goto bad;} while (0)</a>
<a name="ln617">	const struct ieee80211_bpf_params *params = NULL;</a>
<a name="ln618">	struct ieee80211_node *ni = NULL;</a>
<a name="ln619">	struct ieee80211vap *vap;</a>
<a name="ln620">	struct ieee80211_frame *wh;</a>
<a name="ln621">	struct ieee80211com *ic = NULL;</a>
<a name="ln622">	int error;</a>
<a name="ln623">	int ret;</a>
<a name="ln624"> </a>
<a name="ln625">	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_OACTIVE) {</a>
<a name="ln626">		/*</a>
<a name="ln627">		 * Short-circuit requests if the vap is marked OACTIVE</a>
<a name="ln628">		 * as this can happen because a packet came down through</a>
<a name="ln629">		 * ieee80211_start before the vap entered RUN state in</a>
<a name="ln630">		 * which case it's ok to just drop the frame.  This</a>
<a name="ln631">		 * should not be necessary but callers of if_output don't</a>
<a name="ln632">		 * check OACTIVE.</a>
<a name="ln633">		 */</a>
<a name="ln634">		senderr(ENETDOWN);</a>
<a name="ln635">	}</a>
<a name="ln636">	vap = ifp-&gt;if_softc;</a>
<a name="ln637">	ic = vap-&gt;iv_ic;</a>
<a name="ln638">	/*</a>
<a name="ln639">	 * Hand to the 802.3 code if not tagged as</a>
<a name="ln640">	 * a raw 802.11 frame.</a>
<a name="ln641">	 */</a>
<a name="ln642">#ifdef __HAIKU__</a>
<a name="ln643">	if (!dst || dst-&gt;sa_family != AF_IEEE80211)</a>
<a name="ln644">		return ieee80211_vap_xmitpkt(vap, m);</a>
<a name="ln645">#else</a>
<a name="ln646">	if (dst-&gt;sa_family != AF_IEEE80211)</a>
<a name="ln647">		return vap-&gt;iv_output(ifp, m, dst, ro);</a>
<a name="ln648">#endif</a>
<a name="ln649">#ifdef MAC</a>
<a name="ln650">	error = mac_ifnet_check_transmit(ifp, m);</a>
<a name="ln651">	if (error)</a>
<a name="ln652">		senderr(error);</a>
<a name="ln653">#endif</a>
<a name="ln654">	if (ifp-&gt;if_flags &amp; IFF_MONITOR)</a>
<a name="ln655">		senderr(ENETDOWN);</a>
<a name="ln656">	if (!IFNET_IS_UP_RUNNING(ifp))</a>
<a name="ln657">		senderr(ENETDOWN);</a>
<a name="ln658">	if (vap-&gt;iv_state == IEEE80211_S_CAC) {</a>
<a name="ln659">		IEEE80211_DPRINTF(vap,</a>
<a name="ln660">		    IEEE80211_MSG_OUTPUT | IEEE80211_MSG_DOTH,</a>
<a name="ln661">		    &quot;block %s frame in CAC state\n&quot;, &quot;raw data&quot;);</a>
<a name="ln662">		vap-&gt;iv_stats.is_tx_badstate++;</a>
<a name="ln663">		senderr(EIO);		/* XXX */</a>
<a name="ln664">	} else if (vap-&gt;iv_state == IEEE80211_S_SCAN)</a>
<a name="ln665">		senderr(EIO);</a>
<a name="ln666">	/* XXX bypass bridge, pfil, carp, etc. */</a>
<a name="ln667"> </a>
<a name="ln668">	/*</a>
<a name="ln669">	 * NB: DLT_IEEE802_11_RADIO identifies the parameters are</a>
<a name="ln670">	 * present by setting the sa_len field of the sockaddr (yes,</a>
<a name="ln671">	 * this is a hack).</a>
<a name="ln672">	 * NB: we assume sa_data is suitably aligned to cast.</a>
<a name="ln673">	 */</a>
<a name="ln674">	if (dst-&gt;sa_len != 0)</a>
<a name="ln675">		params = (const struct ieee80211_bpf_params *)dst-&gt;sa_data;</a>
<a name="ln676"> </a>
<a name="ln677">	error = ieee80211_validate_frame(m, params);</a>
<a name="ln678">	if (error != 0)</a>
<a name="ln679">		senderr(error);</a>
<a name="ln680"> </a>
<a name="ln681">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln682"> </a>
<a name="ln683">	/* locate destination node */</a>
<a name="ln684">	switch (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_DIR_MASK) {</a>
<a name="ln685">	case IEEE80211_FC1_DIR_NODS:</a>
<a name="ln686">	case IEEE80211_FC1_DIR_FROMDS:</a>
<a name="ln687">		ni = ieee80211_find_txnode(vap, wh-&gt;i_addr1);</a>
<a name="ln688">		break;</a>
<a name="ln689">	case IEEE80211_FC1_DIR_TODS:</a>
<a name="ln690">	case IEEE80211_FC1_DIR_DSTODS:</a>
<a name="ln691">		ni = ieee80211_find_txnode(vap, wh-&gt;i_addr3);</a>
<a name="ln692">		break;</a>
<a name="ln693">	default:</a>
<a name="ln694">		senderr(EDOOFUS);</a>
<a name="ln695">	}</a>
<a name="ln696">	if (ni == NULL) {</a>
<a name="ln697">		/*</a>
<a name="ln698">		 * Permit packets w/ bpf params through regardless</a>
<a name="ln699">		 * (see below about sa_len).</a>
<a name="ln700">		 */</a>
<a name="ln701">		if (dst-&gt;sa_len == 0)</a>
<a name="ln702">			senderr(EHOSTUNREACH);</a>
<a name="ln703">		ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">	/*</a>
<a name="ln707">	 * Sanitize mbuf for net80211 flags leaked from above.</a>
<a name="ln708">	 *</a>
<a name="ln709">	 * NB: This must be done before ieee80211_classify as</a>
<a name="ln710">	 *     it marks EAPOL in frames with M_EAPOL.</a>
<a name="ln711">	 */</a>
<a name="ln712">	m-&gt;m_flags &amp;= ~M_80211_TX;</a>
<a name="ln713">	m-&gt;m_flags |= M_ENCAP;		/* mark encapsulated */</a>
<a name="ln714"> </a>
<a name="ln715">	if (IEEE80211_IS_DATA(wh)) {</a>
<a name="ln716">		/* calculate priority so drivers can find the tx queue */</a>
<a name="ln717">		if (ieee80211_classify(ni, m))</a>
<a name="ln718">			senderr(EIO);		/* XXX */</a>
<a name="ln719"> </a>
<a name="ln720">		/* NB: ieee80211_encap does not include 802.11 header */</a>
<a name="ln721">		IEEE80211_NODE_STAT_ADD(ni, tx_bytes,</a>
<a name="ln722">		    m-&gt;m_pkthdr.len - ieee80211_hdrsize(wh));</a>
<a name="ln723">	} else</a>
<a name="ln724">		M_WME_SETAC(m, WME_AC_BE);</a>
<a name="ln725"> </a>
<a name="ln726">	IEEE80211_NODE_STAT(ni, tx_data);</a>
<a name="ln727">	if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln728">		IEEE80211_NODE_STAT(ni, tx_mcast);</a>
<a name="ln729">		m-&gt;m_flags |= M_MCAST;</a>
<a name="ln730">	} else</a>
<a name="ln731">		IEEE80211_NODE_STAT(ni, tx_ucast);</a>
<a name="ln732"> </a>
<a name="ln733">	IEEE80211_TX_LOCK(ic);</a>
<a name="ln734">	ret = ieee80211_raw_output(vap, ni, m, params);</a>
<a name="ln735">	IEEE80211_TX_UNLOCK(ic);</a>
<a name="ln736">	return (ret);</a>
<a name="ln737">bad:</a>
<a name="ln738">	if (m != NULL)</a>
<a name="ln739">		m_freem(m);</a>
<a name="ln740">	if (ni != NULL)</a>
<a name="ln741">		ieee80211_free_node(ni);</a>
<a name="ln742">	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln743">	return error;</a>
<a name="ln744">#undef senderr</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">/*</a>
<a name="ln748"> * Set the direction field and address fields of an outgoing</a>
<a name="ln749"> * frame.  Note this should be called early on in constructing</a>
<a name="ln750"> * a frame as it sets i_fc[1]; other bits can then be or'd in.</a>
<a name="ln751"> */</a>
<a name="ln752">void</a>
<a name="ln753">ieee80211_send_setup(</a>
<a name="ln754">	struct ieee80211_node *ni,</a>
<a name="ln755">	struct mbuf *m,</a>
<a name="ln756">	int type, int tid,</a>
<a name="ln757">	const uint8_t sa[IEEE80211_ADDR_LEN],</a>
<a name="ln758">	const uint8_t da[IEEE80211_ADDR_LEN],</a>
<a name="ln759">	const uint8_t bssid[IEEE80211_ADDR_LEN])</a>
<a name="ln760">{</a>
<a name="ln761">#define	WH4(wh)	((struct ieee80211_frame_addr4 *)wh)</a>
<a name="ln762">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln763">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln764">	struct ieee80211_frame *wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln765">	ieee80211_seq seqno;</a>
<a name="ln766"> </a>
<a name="ln767">	IEEE80211_TX_LOCK_ASSERT(ni-&gt;ni_ic);</a>
<a name="ln768"> </a>
<a name="ln769">	wh-&gt;i_fc[0] = IEEE80211_FC0_VERSION_0 | type;</a>
<a name="ln770">	if ((type &amp; IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_DATA) {</a>
<a name="ln771">		switch (vap-&gt;iv_opmode) {</a>
<a name="ln772">		case IEEE80211_M_STA:</a>
<a name="ln773">			wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_TODS;</a>
<a name="ln774">			IEEE80211_ADDR_COPY(wh-&gt;i_addr1, bssid);</a>
<a name="ln775">			IEEE80211_ADDR_COPY(wh-&gt;i_addr2, sa);</a>
<a name="ln776">			IEEE80211_ADDR_COPY(wh-&gt;i_addr3, da);</a>
<a name="ln777">			break;</a>
<a name="ln778">		case IEEE80211_M_IBSS:</a>
<a name="ln779">		case IEEE80211_M_AHDEMO:</a>
<a name="ln780">			wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_NODS;</a>
<a name="ln781">			IEEE80211_ADDR_COPY(wh-&gt;i_addr1, da);</a>
<a name="ln782">			IEEE80211_ADDR_COPY(wh-&gt;i_addr2, sa);</a>
<a name="ln783">			IEEE80211_ADDR_COPY(wh-&gt;i_addr3, bssid);</a>
<a name="ln784">			break;</a>
<a name="ln785">		case IEEE80211_M_HOSTAP:</a>
<a name="ln786">			wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_FROMDS;</a>
<a name="ln787">			IEEE80211_ADDR_COPY(wh-&gt;i_addr1, da);</a>
<a name="ln788">			IEEE80211_ADDR_COPY(wh-&gt;i_addr2, bssid);</a>
<a name="ln789">			IEEE80211_ADDR_COPY(wh-&gt;i_addr3, sa);</a>
<a name="ln790">			break;</a>
<a name="ln791">		case IEEE80211_M_WDS:</a>
<a name="ln792">			wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_DSTODS;</a>
<a name="ln793">			IEEE80211_ADDR_COPY(wh-&gt;i_addr1, da);</a>
<a name="ln794">			IEEE80211_ADDR_COPY(wh-&gt;i_addr2, vap-&gt;iv_myaddr);</a>
<a name="ln795">			IEEE80211_ADDR_COPY(wh-&gt;i_addr3, da);</a>
<a name="ln796">			IEEE80211_ADDR_COPY(WH4(wh)-&gt;i_addr4, sa);</a>
<a name="ln797">			break;</a>
<a name="ln798">		case IEEE80211_M_MBSS:</a>
<a name="ln799">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln800">			if (IEEE80211_IS_MULTICAST(da)) {</a>
<a name="ln801">				wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_FROMDS;</a>
<a name="ln802">				/* XXX next hop */</a>
<a name="ln803">				IEEE80211_ADDR_COPY(wh-&gt;i_addr1, da);</a>
<a name="ln804">				IEEE80211_ADDR_COPY(wh-&gt;i_addr2,</a>
<a name="ln805">				    vap-&gt;iv_myaddr);</a>
<a name="ln806">			} else {</a>
<a name="ln807">				wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_DSTODS;</a>
<a name="ln808">				IEEE80211_ADDR_COPY(wh-&gt;i_addr1, da);</a>
<a name="ln809">				IEEE80211_ADDR_COPY(wh-&gt;i_addr2,</a>
<a name="ln810">				    vap-&gt;iv_myaddr);</a>
<a name="ln811">				IEEE80211_ADDR_COPY(wh-&gt;i_addr3, da);</a>
<a name="ln812">				IEEE80211_ADDR_COPY(WH4(wh)-&gt;i_addr4, sa);</a>
<a name="ln813">			}</a>
<a name="ln814">#endif</a>
<a name="ln815">			break;</a>
<a name="ln816">		case IEEE80211_M_MONITOR:	/* NB: to quiet compiler */</a>
<a name="ln817">			break;</a>
<a name="ln818">		}</a>
<a name="ln819">	} else {</a>
<a name="ln820">		wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_NODS;</a>
<a name="ln821">		IEEE80211_ADDR_COPY(wh-&gt;i_addr1, da);</a>
<a name="ln822">		IEEE80211_ADDR_COPY(wh-&gt;i_addr2, sa);</a>
<a name="ln823">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln824">		if (vap-&gt;iv_opmode == IEEE80211_M_MBSS)</a>
<a name="ln825">			IEEE80211_ADDR_COPY(wh-&gt;i_addr3, sa);</a>
<a name="ln826">		else</a>
<a name="ln827">#endif</a>
<a name="ln828">			IEEE80211_ADDR_COPY(wh-&gt;i_addr3, bssid);</a>
<a name="ln829">	}</a>
<a name="ln830">	*(uint16_t *)&amp;wh-&gt;i_dur[0] = 0;</a>
<a name="ln831"> </a>
<a name="ln832">	/*</a>
<a name="ln833">	 * XXX TODO: this is what the TX lock is for.</a>
<a name="ln834">	 * Here we're incrementing sequence numbers, and they</a>
<a name="ln835">	 * need to be in lock-step with what the driver is doing</a>
<a name="ln836">	 * both in TX ordering and crypto encap (IV increment.)</a>
<a name="ln837">	 *</a>
<a name="ln838">	 * If the driver does seqno itself, then we can skip</a>
<a name="ln839">	 * assigning sequence numbers here, and we can avoid</a>
<a name="ln840">	 * requiring the TX lock.</a>
<a name="ln841">	 */</a>
<a name="ln842">	tap = &amp;ni-&gt;ni_tx_ampdu[tid];</a>
<a name="ln843">	if (tid != IEEE80211_NONQOS_TID &amp;&amp; IEEE80211_AMPDU_RUNNING(tap)) {</a>
<a name="ln844">		m-&gt;m_flags |= M_AMPDU_MPDU;</a>
<a name="ln845"> </a>
<a name="ln846">		/* NB: zero out i_seq field (for s/w encryption etc) */</a>
<a name="ln847">		*(uint16_t *)&amp;wh-&gt;i_seq[0] = 0;</a>
<a name="ln848">	} else {</a>
<a name="ln849">		if (IEEE80211_HAS_SEQ(type &amp; IEEE80211_FC0_TYPE_MASK,</a>
<a name="ln850">				      type &amp; IEEE80211_FC0_SUBTYPE_MASK))</a>
<a name="ln851">			/*</a>
<a name="ln852">			 * 802.11-2012 9.3.2.10 - QoS multicast frames</a>
<a name="ln853">			 * come out of a different seqno space.</a>
<a name="ln854">			 */</a>
<a name="ln855">			if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln856">				seqno = ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID]++;</a>
<a name="ln857">			} else {</a>
<a name="ln858">				seqno = ni-&gt;ni_txseqs[tid]++;</a>
<a name="ln859">			}</a>
<a name="ln860">		else</a>
<a name="ln861">			seqno = 0;</a>
<a name="ln862"> </a>
<a name="ln863">		*(uint16_t *)&amp;wh-&gt;i_seq[0] =</a>
<a name="ln864">		    htole16(seqno &lt;&lt; IEEE80211_SEQ_SEQ_SHIFT);</a>
<a name="ln865">		M_SEQNO_SET(m, seqno);</a>
<a name="ln866">	}</a>
<a name="ln867"> </a>
<a name="ln868">	if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1))</a>
<a name="ln869">		m-&gt;m_flags |= M_MCAST;</a>
<a name="ln870">#undef WH4</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/*</a>
<a name="ln874"> * Send a management frame to the specified node.  The node pointer</a>
<a name="ln875"> * must have a reference as the pointer will be passed to the driver</a>
<a name="ln876"> * and potentially held for a long time.  If the frame is successfully</a>
<a name="ln877"> * dispatched to the driver, then it is responsible for freeing the</a>
<a name="ln878"> * reference (and potentially free'ing up any associated storage);</a>
<a name="ln879"> * otherwise deal with reclaiming any reference (on error).</a>
<a name="ln880"> */</a>
<a name="ln881">int</a>
<a name="ln882">ieee80211_mgmt_output(struct ieee80211_node *ni, struct mbuf *m, int type,</a>
<a name="ln883">	struct ieee80211_bpf_params *params)</a>
<a name="ln884">{</a>
<a name="ln885">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln886">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln887">	struct ieee80211_frame *wh;</a>
<a name="ln888">	int ret;</a>
<a name="ln889"> </a>
<a name="ln890">	KASSERT(ni != NULL, (&quot;null node&quot;));</a>
<a name="ln891"> </a>
<a name="ln892">	if (vap-&gt;iv_state == IEEE80211_S_CAC) {</a>
<a name="ln893">		IEEE80211_NOTE(vap, IEEE80211_MSG_OUTPUT | IEEE80211_MSG_DOTH,</a>
<a name="ln894">		    ni, &quot;block %s frame in CAC state&quot;,</a>
<a name="ln895">			ieee80211_mgt_subtype_name(type));</a>
<a name="ln896">		vap-&gt;iv_stats.is_tx_badstate++;</a>
<a name="ln897">		ieee80211_free_node(ni);</a>
<a name="ln898">		m_freem(m);</a>
<a name="ln899">		return EIO;		/* XXX */</a>
<a name="ln900">	}</a>
<a name="ln901"> </a>
<a name="ln902">	M_PREPEND(m, sizeof(struct ieee80211_frame), M_NOWAIT);</a>
<a name="ln903">	if (m == NULL) {</a>
<a name="ln904">		ieee80211_free_node(ni);</a>
<a name="ln905">		return ENOMEM;</a>
<a name="ln906">	}</a>
<a name="ln907"> </a>
<a name="ln908">	IEEE80211_TX_LOCK(ic);</a>
<a name="ln909"> </a>
<a name="ln910">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln911">	ieee80211_send_setup(ni, m,</a>
<a name="ln912">	     IEEE80211_FC0_TYPE_MGT | type, IEEE80211_NONQOS_TID,</a>
<a name="ln913">	     vap-&gt;iv_myaddr, ni-&gt;ni_macaddr, ni-&gt;ni_bssid);</a>
<a name="ln914">	if (params-&gt;ibp_flags &amp; IEEE80211_BPF_CRYPTO) {</a>
<a name="ln915">		IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_AUTH, wh-&gt;i_addr1,</a>
<a name="ln916">		    &quot;encrypting frame (%s)&quot;, __func__);</a>
<a name="ln917">		wh-&gt;i_fc[1] |= IEEE80211_FC1_PROTECTED;</a>
<a name="ln918">	}</a>
<a name="ln919">	m-&gt;m_flags |= M_ENCAP;		/* mark encapsulated */</a>
<a name="ln920"> </a>
<a name="ln921">	KASSERT(type != IEEE80211_FC0_SUBTYPE_PROBE_RESP, (&quot;probe response?&quot;));</a>
<a name="ln922">	M_WME_SETAC(m, params-&gt;ibp_pri);</a>
<a name="ln923"> </a>
<a name="ln924">#ifdef IEEE80211_DEBUG</a>
<a name="ln925">	/* avoid printing too many frames */</a>
<a name="ln926">	if ((ieee80211_msg_debug(vap) &amp;&amp; doprint(vap, type)) ||</a>
<a name="ln927">	    ieee80211_msg_dumppkts(vap)) {</a>
<a name="ln928">		printf(&quot;[%s] send %s on channel %u\n&quot;,</a>
<a name="ln929">		    ether_sprintf(wh-&gt;i_addr1),</a>
<a name="ln930">		    ieee80211_mgt_subtype_name(type),</a>
<a name="ln931">		    ieee80211_chan2ieee(ic, ic-&gt;ic_curchan));</a>
<a name="ln932">	}</a>
<a name="ln933">#endif</a>
<a name="ln934">	IEEE80211_NODE_STAT(ni, tx_mgmt);</a>
<a name="ln935"> </a>
<a name="ln936">	ret = ieee80211_raw_output(vap, ni, m, params);</a>
<a name="ln937">	IEEE80211_TX_UNLOCK(ic);</a>
<a name="ln938">	return (ret);</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">static void</a>
<a name="ln942">ieee80211_nulldata_transmitted(struct ieee80211_node *ni, void *arg,</a>
<a name="ln943">    int status)</a>
<a name="ln944">{</a>
<a name="ln945">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln946"> </a>
<a name="ln947">	wakeup(vap);</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950">/*</a>
<a name="ln951"> * Send a null data frame to the specified node.  If the station</a>
<a name="ln952"> * is setup for QoS then a QoS Null Data frame is constructed.</a>
<a name="ln953"> * If this is a WDS station then a 4-address frame is constructed.</a>
<a name="ln954"> *</a>
<a name="ln955"> * NB: the caller is assumed to have setup a node reference</a>
<a name="ln956"> *     for use; this is necessary to deal with a race condition</a>
<a name="ln957"> *     when probing for inactive stations.  Like ieee80211_mgmt_output</a>
<a name="ln958"> *     we must cleanup any node reference on error;  however we</a>
<a name="ln959"> *     can safely just unref it as we know it will never be the</a>
<a name="ln960"> *     last reference to the node.</a>
<a name="ln961"> */</a>
<a name="ln962">int</a>
<a name="ln963">ieee80211_send_nulldata(struct ieee80211_node *ni)</a>
<a name="ln964">{</a>
<a name="ln965">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln966">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln967">	struct mbuf *m;</a>
<a name="ln968">	struct ieee80211_frame *wh;</a>
<a name="ln969">	int hdrlen;</a>
<a name="ln970">	uint8_t *frm;</a>
<a name="ln971">	int ret;</a>
<a name="ln972"> </a>
<a name="ln973">	if (vap-&gt;iv_state == IEEE80211_S_CAC) {</a>
<a name="ln974">		IEEE80211_NOTE(vap, IEEE80211_MSG_OUTPUT | IEEE80211_MSG_DOTH,</a>
<a name="ln975">		    ni, &quot;block %s frame in CAC state&quot;, &quot;null data&quot;);</a>
<a name="ln976">		ieee80211_unref_node(&amp;ni);</a>
<a name="ln977">		vap-&gt;iv_stats.is_tx_badstate++;</a>
<a name="ln978">		return EIO;		/* XXX */</a>
<a name="ln979">	}</a>
<a name="ln980"> </a>
<a name="ln981">	if (ni-&gt;ni_flags &amp; (IEEE80211_NODE_QOS|IEEE80211_NODE_HT))</a>
<a name="ln982">		hdrlen = sizeof(struct ieee80211_qosframe);</a>
<a name="ln983">	else</a>
<a name="ln984">		hdrlen = sizeof(struct ieee80211_frame);</a>
<a name="ln985">	/* NB: only WDS vap's get 4-address frames */</a>
<a name="ln986">	if (vap-&gt;iv_opmode == IEEE80211_M_WDS)</a>
<a name="ln987">		hdrlen += IEEE80211_ADDR_LEN;</a>
<a name="ln988">	if (ic-&gt;ic_flags &amp; IEEE80211_F_DATAPAD)</a>
<a name="ln989">		hdrlen = roundup(hdrlen, sizeof(uint32_t));</a>
<a name="ln990"> </a>
<a name="ln991">	m = ieee80211_getmgtframe(&amp;frm, ic-&gt;ic_headroom + hdrlen, 0);</a>
<a name="ln992">	if (m == NULL) {</a>
<a name="ln993">		/* XXX debug msg */</a>
<a name="ln994">		ieee80211_unref_node(&amp;ni);</a>
<a name="ln995">		vap-&gt;iv_stats.is_tx_nobuf++;</a>
<a name="ln996">		return ENOMEM;</a>
<a name="ln997">	}</a>
<a name="ln998">	KASSERT(M_LEADINGSPACE(m) &gt;= hdrlen,</a>
<a name="ln999">	    (&quot;leading space %zd&quot;, M_LEADINGSPACE(m)));</a>
<a name="ln1000">	M_PREPEND(m, hdrlen, M_NOWAIT);</a>
<a name="ln1001">	if (m == NULL) {</a>
<a name="ln1002">		/* NB: cannot happen */</a>
<a name="ln1003">		ieee80211_free_node(ni);</a>
<a name="ln1004">		return ENOMEM;</a>
<a name="ln1005">	}</a>
<a name="ln1006"> </a>
<a name="ln1007">	IEEE80211_TX_LOCK(ic);</a>
<a name="ln1008"> </a>
<a name="ln1009">	wh = mtod(m, struct ieee80211_frame *);		/* NB: a little lie */</a>
<a name="ln1010">	if (ni-&gt;ni_flags &amp; IEEE80211_NODE_QOS) {</a>
<a name="ln1011">		const int tid = WME_AC_TO_TID(WME_AC_BE);</a>
<a name="ln1012">		uint8_t *qos;</a>
<a name="ln1013"> </a>
<a name="ln1014">		ieee80211_send_setup(ni, m,</a>
<a name="ln1015">		    IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS_NULL,</a>
<a name="ln1016">		    tid, vap-&gt;iv_myaddr, ni-&gt;ni_macaddr, ni-&gt;ni_bssid);</a>
<a name="ln1017"> </a>
<a name="ln1018">		if (vap-&gt;iv_opmode == IEEE80211_M_WDS)</a>
<a name="ln1019">			qos = ((struct ieee80211_qosframe_addr4 *) wh)-&gt;i_qos;</a>
<a name="ln1020">		else</a>
<a name="ln1021">			qos = ((struct ieee80211_qosframe *) wh)-&gt;i_qos;</a>
<a name="ln1022">		qos[0] = tid &amp; IEEE80211_QOS_TID;</a>
<a name="ln1023">		if (ic-&gt;ic_wme.wme_wmeChanParams.cap_wmeParams[WME_AC_BE].wmep_noackPolicy)</a>
<a name="ln1024">			qos[0] |= IEEE80211_QOS_ACKPOLICY_NOACK;</a>
<a name="ln1025">		qos[1] = 0;</a>
<a name="ln1026">	} else {</a>
<a name="ln1027">		ieee80211_send_setup(ni, m,</a>
<a name="ln1028">		    IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_NODATA,</a>
<a name="ln1029">		    IEEE80211_NONQOS_TID,</a>
<a name="ln1030">		    vap-&gt;iv_myaddr, ni-&gt;ni_macaddr, ni-&gt;ni_bssid);</a>
<a name="ln1031">	}</a>
<a name="ln1032">	if (vap-&gt;iv_opmode != IEEE80211_M_WDS) {</a>
<a name="ln1033">		/* NB: power management bit is never sent by an AP */</a>
<a name="ln1034">		if ((ni-&gt;ni_flags &amp; IEEE80211_NODE_PWR_MGT) &amp;&amp;</a>
<a name="ln1035">		    vap-&gt;iv_opmode != IEEE80211_M_HOSTAP)</a>
<a name="ln1036">			wh-&gt;i_fc[1] |= IEEE80211_FC1_PWR_MGT;</a>
<a name="ln1037">	}</a>
<a name="ln1038">	if ((ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) &amp;&amp;</a>
<a name="ln1039">	    (ni-&gt;ni_flags &amp; IEEE80211_NODE_PWR_MGT)) {</a>
<a name="ln1040">		ieee80211_add_callback(m, ieee80211_nulldata_transmitted,</a>
<a name="ln1041">		    NULL);</a>
<a name="ln1042">	}</a>
<a name="ln1043">	m-&gt;m_len = m-&gt;m_pkthdr.len = hdrlen;</a>
<a name="ln1044">	m-&gt;m_flags |= M_ENCAP;		/* mark encapsulated */</a>
<a name="ln1045"> </a>
<a name="ln1046">	M_WME_SETAC(m, WME_AC_BE);</a>
<a name="ln1047"> </a>
<a name="ln1048">	IEEE80211_NODE_STAT(ni, tx_data);</a>
<a name="ln1049"> </a>
<a name="ln1050">	IEEE80211_NOTE(vap, IEEE80211_MSG_DEBUG | IEEE80211_MSG_DUMPPKTS, ni,</a>
<a name="ln1051">	    &quot;send %snull data frame on channel %u, pwr mgt %s&quot;,</a>
<a name="ln1052">	    ni-&gt;ni_flags &amp; IEEE80211_NODE_QOS ? &quot;QoS &quot; : &quot;&quot;,</a>
<a name="ln1053">	    ieee80211_chan2ieee(ic, ic-&gt;ic_curchan),</a>
<a name="ln1054">	    wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PWR_MGT ? &quot;ena&quot; : &quot;dis&quot;);</a>
<a name="ln1055"> </a>
<a name="ln1056">	ret = ieee80211_raw_output(vap, ni, m, NULL);</a>
<a name="ln1057">	IEEE80211_TX_UNLOCK(ic);</a>
<a name="ln1058">	return (ret);</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">/*</a>
<a name="ln1062"> * Assign priority to a frame based on any vlan tag assigned</a>
<a name="ln1063"> * to the station and/or any Diffserv setting in an IP header.</a>
<a name="ln1064"> * Finally, if an ACM policy is setup (in station mode) it's</a>
<a name="ln1065"> * applied.</a>
<a name="ln1066"> */</a>
<a name="ln1067">int</a>
<a name="ln1068">ieee80211_classify(struct ieee80211_node *ni, struct mbuf *m)</a>
<a name="ln1069">{</a>
<a name="ln1070">	const struct ether_header *eh = NULL;</a>
<a name="ln1071">	uint16_t ether_type;</a>
<a name="ln1072">	int v_wme_ac, d_wme_ac, ac;</a>
<a name="ln1073"> </a>
<a name="ln1074">	if (__predict_false(m-&gt;m_flags &amp; M_ENCAP)) {</a>
<a name="ln1075">		struct ieee80211_frame *wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1076">		struct llc *llc;</a>
<a name="ln1077">		int hdrlen, subtype;</a>
<a name="ln1078"> </a>
<a name="ln1079">		subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln1080">		if (subtype &amp; IEEE80211_FC0_SUBTYPE_NODATA) {</a>
<a name="ln1081">			ac = WME_AC_BE;</a>
<a name="ln1082">			goto done;</a>
<a name="ln1083">		}</a>
<a name="ln1084"> </a>
<a name="ln1085">		hdrlen = ieee80211_hdrsize(wh);</a>
<a name="ln1086">		if (m-&gt;m_pkthdr.len &lt; hdrlen + sizeof(*llc))</a>
<a name="ln1087">			return 1;</a>
<a name="ln1088"> </a>
<a name="ln1089">		llc = (struct llc *)mtodo(m, hdrlen);</a>
<a name="ln1090">		if (llc-&gt;llc_dsap != LLC_SNAP_LSAP ||</a>
<a name="ln1091">		    llc-&gt;llc_ssap != LLC_SNAP_LSAP ||</a>
<a name="ln1092">		    llc-&gt;llc_control != LLC_UI ||</a>
<a name="ln1093">		    llc-&gt;llc_snap.org_code[0] != 0 ||</a>
<a name="ln1094">		    llc-&gt;llc_snap.org_code[1] != 0 ||</a>
<a name="ln1095">		    llc-&gt;llc_snap.org_code[2] != 0)</a>
<a name="ln1096">			return 1;</a>
<a name="ln1097"> </a>
<a name="ln1098">		ether_type = llc-&gt;llc_snap.ether_type;</a>
<a name="ln1099">	} else {</a>
<a name="ln1100">		eh = mtod(m, struct ether_header *);</a>
<a name="ln1101">		ether_type = eh-&gt;ether_type;</a>
<a name="ln1102">	}</a>
<a name="ln1103"> </a>
<a name="ln1104">	/*</a>
<a name="ln1105">	 * Always promote PAE/EAPOL frames to high priority.</a>
<a name="ln1106">	 */</a>
<a name="ln1107">	if (ether_type == htons(ETHERTYPE_PAE)) {</a>
<a name="ln1108">		/* NB: mark so others don't need to check header */</a>
<a name="ln1109">		m-&gt;m_flags |= M_EAPOL;</a>
<a name="ln1110">		ac = WME_AC_VO;</a>
<a name="ln1111">		goto done;</a>
<a name="ln1112">	}</a>
<a name="ln1113">	/*</a>
<a name="ln1114">	 * Non-qos traffic goes to BE.</a>
<a name="ln1115">	 */</a>
<a name="ln1116">	if ((ni-&gt;ni_flags &amp; IEEE80211_NODE_QOS) == 0) {</a>
<a name="ln1117">		ac = WME_AC_BE;</a>
<a name="ln1118">		goto done;</a>
<a name="ln1119">	}</a>
<a name="ln1120"> </a>
<a name="ln1121">	/*</a>
<a name="ln1122">	 * If node has a vlan tag then all traffic</a>
<a name="ln1123">	 * to it must have a matching tag.</a>
<a name="ln1124">	 */</a>
<a name="ln1125">	v_wme_ac = 0;</a>
<a name="ln1126">	if (ni-&gt;ni_vlan != 0) {</a>
<a name="ln1127">		 if ((m-&gt;m_flags &amp; M_VLANTAG) == 0) {</a>
<a name="ln1128">			IEEE80211_NODE_STAT(ni, tx_novlantag);</a>
<a name="ln1129">			return 1;</a>
<a name="ln1130">		}</a>
<a name="ln1131">		if (EVL_VLANOFTAG(m-&gt;m_pkthdr.ether_vtag) !=</a>
<a name="ln1132">		    EVL_VLANOFTAG(ni-&gt;ni_vlan)) {</a>
<a name="ln1133">			IEEE80211_NODE_STAT(ni, tx_vlanmismatch);</a>
<a name="ln1134">			return 1;</a>
<a name="ln1135">		}</a>
<a name="ln1136">		/* map vlan priority to AC */</a>
<a name="ln1137">		v_wme_ac = TID_TO_WME_AC(EVL_PRIOFTAG(ni-&gt;ni_vlan));</a>
<a name="ln1138">	}</a>
<a name="ln1139"> </a>
<a name="ln1140">	/* XXX m_copydata may be too slow for fast path */</a>
<a name="ln1141">#ifdef INET</a>
<a name="ln1142">	if (eh &amp;&amp; eh-&gt;ether_type == htons(ETHERTYPE_IP)) {</a>
<a name="ln1143">		uint8_t tos;</a>
<a name="ln1144">		/*</a>
<a name="ln1145">		 * IP frame, map the DSCP bits from the TOS field.</a>
<a name="ln1146">		 */</a>
<a name="ln1147">		/* NB: ip header may not be in first mbuf */</a>
<a name="ln1148">		m_copydata(m, sizeof(struct ether_header) +</a>
<a name="ln1149">		    offsetof(struct ip, ip_tos), sizeof(tos), &amp;tos);</a>
<a name="ln1150">		tos &gt;&gt;= 5;		/* NB: ECN + low 3 bits of DSCP */</a>
<a name="ln1151">		d_wme_ac = TID_TO_WME_AC(tos);</a>
<a name="ln1152">	} else {</a>
<a name="ln1153">#endif /* INET */</a>
<a name="ln1154">#ifdef INET6</a>
<a name="ln1155">	if (eh &amp;&amp; eh-&gt;ether_type == htons(ETHERTYPE_IPV6)) {</a>
<a name="ln1156">		uint32_t flow;</a>
<a name="ln1157">		uint8_t tos;</a>
<a name="ln1158">		/*</a>
<a name="ln1159">		 * IPv6 frame, map the DSCP bits from the traffic class field.</a>
<a name="ln1160">		 */</a>
<a name="ln1161">		m_copydata(m, sizeof(struct ether_header) +</a>
<a name="ln1162">		    offsetof(struct ip6_hdr, ip6_flow), sizeof(flow),</a>
<a name="ln1163">		    (caddr_t) &amp;flow);</a>
<a name="ln1164">		tos = (uint8_t)(ntohl(flow) &gt;&gt; 20);</a>
<a name="ln1165">		tos &gt;&gt;= 5;		/* NB: ECN + low 3 bits of DSCP */</a>
<a name="ln1166">		d_wme_ac = TID_TO_WME_AC(tos);</a>
<a name="ln1167">	} else {</a>
<a name="ln1168">#endif /* INET6 */</a>
<a name="ln1169">		d_wme_ac = WME_AC_BE;</a>
<a name="ln1170">#ifdef INET6</a>
<a name="ln1171">	}</a>
<a name="ln1172">#endif</a>
<a name="ln1173">#ifdef INET</a>
<a name="ln1174">	}</a>
<a name="ln1175">#endif</a>
<a name="ln1176">	/*</a>
<a name="ln1177">	 * Use highest priority AC.</a>
<a name="ln1178">	 */</a>
<a name="ln1179">	if (v_wme_ac &gt; d_wme_ac)</a>
<a name="ln1180">		ac = v_wme_ac;</a>
<a name="ln1181">	else</a>
<a name="ln1182">		ac = d_wme_ac;</a>
<a name="ln1183"> </a>
<a name="ln1184">	/*</a>
<a name="ln1185">	 * Apply ACM policy.</a>
<a name="ln1186">	 */</a>
<a name="ln1187">	if (ni-&gt;ni_vap-&gt;iv_opmode == IEEE80211_M_STA) {</a>
<a name="ln1188">		static const int acmap[4] = {</a>
<a name="ln1189">			WME_AC_BK,	/* WME_AC_BE */</a>
<a name="ln1190">			WME_AC_BK,	/* WME_AC_BK */</a>
<a name="ln1191">			WME_AC_BE,	/* WME_AC_VI */</a>
<a name="ln1192">			WME_AC_VI,	/* WME_AC_VO */</a>
<a name="ln1193">		};</a>
<a name="ln1194">		struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln1195"> </a>
<a name="ln1196">		while (ac != WME_AC_BK &amp;&amp;</a>
<a name="ln1197">		    ic-&gt;ic_wme.wme_wmeBssChanParams.cap_wmeParams[ac].wmep_acm)</a>
<a name="ln1198">			ac = acmap[ac];</a>
<a name="ln1199">	}</a>
<a name="ln1200">done:</a>
<a name="ln1201">	M_WME_SETAC(m, ac);</a>
<a name="ln1202">	return 0;</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205">/*</a>
<a name="ln1206"> * Insure there is sufficient contiguous space to encapsulate the</a>
<a name="ln1207"> * 802.11 data frame.  If room isn't already there, arrange for it.</a>
<a name="ln1208"> * Drivers and cipher modules assume we have done the necessary work</a>
<a name="ln1209"> * and fail rudely if they don't find the space they need.</a>
<a name="ln1210"> */</a>
<a name="ln1211">struct mbuf *</a>
<a name="ln1212">ieee80211_mbuf_adjust(struct ieee80211vap *vap, int hdrsize,</a>
<a name="ln1213">	struct ieee80211_key *key, struct mbuf *m)</a>
<a name="ln1214">{</a>
<a name="ln1215">#define	TO_BE_RECLAIMED	(sizeof(struct ether_header) - sizeof(struct llc))</a>
<a name="ln1216">	int needed_space = vap-&gt;iv_ic-&gt;ic_headroom + hdrsize;</a>
<a name="ln1217"> </a>
<a name="ln1218">	if (key != NULL) {</a>
<a name="ln1219">		/* XXX belongs in crypto code? */</a>
<a name="ln1220">		needed_space += key-&gt;wk_cipher-&gt;ic_header;</a>
<a name="ln1221">		/* XXX frags */</a>
<a name="ln1222">		/*</a>
<a name="ln1223">		 * When crypto is being done in the host we must insure</a>
<a name="ln1224">		 * the data are writable for the cipher routines; clone</a>
<a name="ln1225">		 * a writable mbuf chain.</a>
<a name="ln1226">		 * XXX handle SWMIC specially</a>
<a name="ln1227">		 */</a>
<a name="ln1228">		if (key-&gt;wk_flags &amp; (IEEE80211_KEY_SWENCRYPT|IEEE80211_KEY_SWENMIC)) {</a>
<a name="ln1229">			m = m_unshare(m, M_NOWAIT);</a>
<a name="ln1230">			if (m == NULL) {</a>
<a name="ln1231">				IEEE80211_DPRINTF(vap, IEEE80211_MSG_OUTPUT,</a>
<a name="ln1232">				    &quot;%s: cannot get writable mbuf\n&quot;, __func__);</a>
<a name="ln1233">				vap-&gt;iv_stats.is_tx_nobuf++; /* XXX new stat */</a>
<a name="ln1234">				return NULL;</a>
<a name="ln1235">			}</a>
<a name="ln1236">		}</a>
<a name="ln1237">	}</a>
<a name="ln1238">	/*</a>
<a name="ln1239">	 * We know we are called just before stripping an Ethernet</a>
<a name="ln1240">	 * header and prepending an LLC header.  This means we know</a>
<a name="ln1241">	 * there will be</a>
<a name="ln1242">	 *	sizeof(struct ether_header) - sizeof(struct llc)</a>
<a name="ln1243">	 * bytes recovered to which we need additional space for the</a>
<a name="ln1244">	 * 802.11 header and any crypto header.</a>
<a name="ln1245">	 */</a>
<a name="ln1246">	/* XXX check trailing space and copy instead? */</a>
<a name="ln1247">	if (M_LEADINGSPACE(m) &lt; needed_space - TO_BE_RECLAIMED) {</a>
<a name="ln1248">		struct mbuf *n = m_gethdr(M_NOWAIT, m-&gt;m_type);</a>
<a name="ln1249">		if (n == NULL) {</a>
<a name="ln1250">			IEEE80211_DPRINTF(vap, IEEE80211_MSG_OUTPUT,</a>
<a name="ln1251">			    &quot;%s: cannot expand storage\n&quot;, __func__);</a>
<a name="ln1252">			vap-&gt;iv_stats.is_tx_nobuf++;</a>
<a name="ln1253">			m_freem(m);</a>
<a name="ln1254">			return NULL;</a>
<a name="ln1255">		}</a>
<a name="ln1256">		KASSERT(needed_space &lt;= MHLEN,</a>
<a name="ln1257">		    (&quot;not enough room, need %u got %d\n&quot;, needed_space, MHLEN));</a>
<a name="ln1258">		/*</a>
<a name="ln1259">		 * Setup new mbuf to have leading space to prepend the</a>
<a name="ln1260">		 * 802.11 header and any crypto header bits that are</a>
<a name="ln1261">		 * required (the latter are added when the driver calls</a>
<a name="ln1262">		 * back to ieee80211_crypto_encap to do crypto encapsulation).</a>
<a name="ln1263">		 */</a>
<a name="ln1264">		/* NB: must be first 'cuz it clobbers m_data */</a>
<a name="ln1265">		m_move_pkthdr(n, m);</a>
<a name="ln1266">		n-&gt;m_len = 0;			/* NB: m_gethdr does not set */</a>
<a name="ln1267">		n-&gt;m_data += needed_space;</a>
<a name="ln1268">		/*</a>
<a name="ln1269">		 * Pull up Ethernet header to create the expected layout.</a>
<a name="ln1270">		 * We could use m_pullup but that's overkill (i.e. we don't</a>
<a name="ln1271">		 * need the actual data) and it cannot fail so do it inline</a>
<a name="ln1272">		 * for speed.</a>
<a name="ln1273">		 */</a>
<a name="ln1274">		/* NB: struct ether_header is known to be contiguous */</a>
<a name="ln1275">		n-&gt;m_len += sizeof(struct ether_header);</a>
<a name="ln1276">		m-&gt;m_len -= sizeof(struct ether_header);</a>
<a name="ln1277">		m-&gt;m_data += sizeof(struct ether_header);</a>
<a name="ln1278">		/*</a>
<a name="ln1279">		 * Replace the head of the chain.</a>
<a name="ln1280">		 */</a>
<a name="ln1281">		n-&gt;m_next = m;</a>
<a name="ln1282">		m = n;</a>
<a name="ln1283">	}</a>
<a name="ln1284">	return m;</a>
<a name="ln1285">#undef TO_BE_RECLAIMED</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">/*</a>
<a name="ln1289"> * Return the transmit key to use in sending a unicast frame.</a>
<a name="ln1290"> * If a unicast key is set we use that.  When no unicast key is set</a>
<a name="ln1291"> * we fall back to the default transmit key.</a>
<a name="ln1292"> */</a>
<a name="ln1293">static __inline struct ieee80211_key *</a>
<a name="ln1294">ieee80211_crypto_getucastkey(struct ieee80211vap *vap,</a>
<a name="ln1295">	struct ieee80211_node *ni)</a>
<a name="ln1296">{</a>
<a name="ln1297">	if (IEEE80211_KEY_UNDEFINED(&amp;ni-&gt;ni_ucastkey)) {</a>
<a name="ln1298">		if (vap-&gt;iv_def_txkey == IEEE80211_KEYIX_NONE ||</a>
<a name="ln1299">		    IEEE80211_KEY_UNDEFINED(&amp;vap-&gt;iv_nw_keys[vap-&gt;iv_def_txkey]))</a>
<a name="ln1300">			return NULL;</a>
<a name="ln1301">		return &amp;vap-&gt;iv_nw_keys[vap-&gt;iv_def_txkey];</a>
<a name="ln1302">	} else {</a>
<a name="ln1303">		return &amp;ni-&gt;ni_ucastkey;</a>
<a name="ln1304">	}</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307">/*</a>
<a name="ln1308"> * Return the transmit key to use in sending a multicast frame.</a>
<a name="ln1309"> * Multicast traffic always uses the group key which is installed as</a>
<a name="ln1310"> * the default tx key.</a>
<a name="ln1311"> */</a>
<a name="ln1312">static __inline struct ieee80211_key *</a>
<a name="ln1313">ieee80211_crypto_getmcastkey(struct ieee80211vap *vap,</a>
<a name="ln1314">	struct ieee80211_node *ni)</a>
<a name="ln1315">{</a>
<a name="ln1316">	if (vap-&gt;iv_def_txkey == IEEE80211_KEYIX_NONE ||</a>
<a name="ln1317">	    IEEE80211_KEY_UNDEFINED(&amp;vap-&gt;iv_nw_keys[vap-&gt;iv_def_txkey]))</a>
<a name="ln1318">		return NULL;</a>
<a name="ln1319">	return &amp;vap-&gt;iv_nw_keys[vap-&gt;iv_def_txkey];</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">/*</a>
<a name="ln1323"> * Encapsulate an outbound data frame.  The mbuf chain is updated.</a>
<a name="ln1324"> * If an error is encountered NULL is returned.  The caller is required</a>
<a name="ln1325"> * to provide a node reference and pullup the ethernet header in the</a>
<a name="ln1326"> * first mbuf.</a>
<a name="ln1327"> *</a>
<a name="ln1328"> * NB: Packet is assumed to be processed by ieee80211_classify which</a>
<a name="ln1329"> *     marked EAPOL frames w/ M_EAPOL.</a>
<a name="ln1330"> */</a>
<a name="ln1331">struct mbuf *</a>
<a name="ln1332">ieee80211_encap(struct ieee80211vap *vap, struct ieee80211_node *ni,</a>
<a name="ln1333">    struct mbuf *m)</a>
<a name="ln1334">{</a>
<a name="ln1335">#define	WH4(wh)	((struct ieee80211_frame_addr4 *)(wh))</a>
<a name="ln1336">#define MC01(mc)	((struct ieee80211_meshcntl_ae01 *)mc)</a>
<a name="ln1337">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln1338">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln1339">	struct ieee80211_mesh_state *ms = vap-&gt;iv_mesh;</a>
<a name="ln1340">	struct ieee80211_meshcntl_ae10 *mc;</a>
<a name="ln1341">	struct ieee80211_mesh_route *rt = NULL;</a>
<a name="ln1342">	int dir = -1;</a>
<a name="ln1343">#endif</a>
<a name="ln1344">	struct ether_header eh;</a>
<a name="ln1345">	struct ieee80211_frame *wh;</a>
<a name="ln1346">	struct ieee80211_key *key;</a>
<a name="ln1347">	struct llc *llc;</a>
<a name="ln1348">	int hdrsize, hdrspace, datalen, addqos, txfrag, is4addr, is_mcast;</a>
<a name="ln1349">	ieee80211_seq seqno;</a>
<a name="ln1350">	int meshhdrsize, meshae;</a>
<a name="ln1351">	uint8_t *qos;</a>
<a name="ln1352">	int is_amsdu = 0;</a>
<a name="ln1353"> </a>
<a name="ln1354">	IEEE80211_TX_LOCK_ASSERT(ic);</a>
<a name="ln1355"> </a>
<a name="ln1356">	is_mcast = !! (m-&gt;m_flags &amp; (M_MCAST | M_BCAST));</a>
<a name="ln1357"> </a>
<a name="ln1358">	/*</a>
<a name="ln1359">	 * Copy existing Ethernet header to a safe place.  The</a>
<a name="ln1360">	 * rest of the code assumes it's ok to strip it when</a>
<a name="ln1361">	 * reorganizing state for the final encapsulation.</a>
<a name="ln1362">	 */</a>
<a name="ln1363">	KASSERT(m-&gt;m_len &gt;= sizeof(eh), (&quot;no ethernet header!&quot;));</a>
<a name="ln1364">	ETHER_HEADER_COPY(&amp;eh, mtod(m, caddr_t));</a>
<a name="ln1365"> </a>
<a name="ln1366">	/*</a>
<a name="ln1367">	 * Insure space for additional headers.  First identify</a>
<a name="ln1368">	 * transmit key to use in calculating any buffer adjustments</a>
<a name="ln1369">	 * required.  This is also used below to do privacy</a>
<a name="ln1370">	 * encapsulation work.  Then calculate the 802.11 header</a>
<a name="ln1371">	 * size and any padding required by the driver.</a>
<a name="ln1372">	 *</a>
<a name="ln1373">	 * Note key may be NULL if we fall back to the default</a>
<a name="ln1374">	 * transmit key and that is not set.  In that case the</a>
<a name="ln1375">	 * buffer may not be expanded as needed by the cipher</a>
<a name="ln1376">	 * routines, but they will/should discard it.</a>
<a name="ln1377">	 */</a>
<a name="ln1378">	if (vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) {</a>
<a name="ln1379">		if (vap-&gt;iv_opmode == IEEE80211_M_STA ||</a>
<a name="ln1380">		    !IEEE80211_IS_MULTICAST(eh.ether_dhost) ||</a>
<a name="ln1381">		    (vap-&gt;iv_opmode == IEEE80211_M_WDS &amp;&amp;</a>
<a name="ln1382">		     (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_WDSLEGACY)))</a>
<a name="ln1383">			key = ieee80211_crypto_getucastkey(vap, ni);</a>
<a name="ln1384">		else</a>
<a name="ln1385">			key = ieee80211_crypto_getmcastkey(vap, ni);</a>
<a name="ln1386">		if (key == NULL &amp;&amp; (m-&gt;m_flags &amp; M_EAPOL) == 0) {</a>
<a name="ln1387">			IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_CRYPTO,</a>
<a name="ln1388">			    eh.ether_dhost,</a>
<a name="ln1389">			    &quot;no default transmit key (%s) deftxkey %u&quot;,</a>
<a name="ln1390">			    __func__, vap-&gt;iv_def_txkey);</a>
<a name="ln1391">			vap-&gt;iv_stats.is_tx_nodefkey++;</a>
<a name="ln1392">			goto bad;</a>
<a name="ln1393">		}</a>
<a name="ln1394">	} else</a>
<a name="ln1395">		key = NULL;</a>
<a name="ln1396">	/*</a>
<a name="ln1397">	 * XXX Some ap's don't handle QoS-encapsulated EAPOL</a>
<a name="ln1398">	 * frames so suppress use.  This may be an issue if other</a>
<a name="ln1399">	 * ap's require all data frames to be QoS-encapsulated</a>
<a name="ln1400">	 * once negotiated in which case we'll need to make this</a>
<a name="ln1401">	 * configurable.</a>
<a name="ln1402">	 *</a>
<a name="ln1403">	 * Don't send multicast QoS frames.</a>
<a name="ln1404">	 * Technically multicast frames can be QoS if all stations in the</a>
<a name="ln1405">	 * BSS are also QoS.</a>
<a name="ln1406">	 *</a>
<a name="ln1407">	 * NB: mesh data frames are QoS, including multicast frames.</a>
<a name="ln1408">	 */</a>
<a name="ln1409">	addqos =</a>
<a name="ln1410">	    (((is_mcast == 0) &amp;&amp; (ni-&gt;ni_flags &amp;</a>
<a name="ln1411">	     (IEEE80211_NODE_QOS|IEEE80211_NODE_HT))) ||</a>
<a name="ln1412">	    (vap-&gt;iv_opmode == IEEE80211_M_MBSS)) &amp;&amp;</a>
<a name="ln1413">	    (m-&gt;m_flags &amp; M_EAPOL) == 0;</a>
<a name="ln1414"> </a>
<a name="ln1415">	if (addqos)</a>
<a name="ln1416">		hdrsize = sizeof(struct ieee80211_qosframe);</a>
<a name="ln1417">	else</a>
<a name="ln1418">		hdrsize = sizeof(struct ieee80211_frame);</a>
<a name="ln1419">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln1420">	if (vap-&gt;iv_opmode == IEEE80211_M_MBSS) {</a>
<a name="ln1421">		/*</a>
<a name="ln1422">		 * Mesh data frames are encapsulated according to the</a>
<a name="ln1423">		 * rules of Section 11B.8.5 (p.139 of D3.0 spec).</a>
<a name="ln1424">		 * o Group Addressed data (aka multicast) originating</a>
<a name="ln1425">		 *   at the local sta are sent w/ 3-address format and</a>
<a name="ln1426">		 *   address extension mode 00</a>
<a name="ln1427">		 * o Individually Addressed data (aka unicast) originating</a>
<a name="ln1428">		 *   at the local sta are sent w/ 4-address format and</a>
<a name="ln1429">		 *   address extension mode 00</a>
<a name="ln1430">		 * o Group Addressed data forwarded from a non-mesh sta are</a>
<a name="ln1431">		 *   sent w/ 3-address format and address extension mode 01</a>
<a name="ln1432">		 * o Individually Address data from another sta are sent</a>
<a name="ln1433">		 *   w/ 4-address format and address extension mode 10</a>
<a name="ln1434">		 */</a>
<a name="ln1435">		is4addr = 0;		/* NB: don't use, disable */</a>
<a name="ln1436">		if (!IEEE80211_IS_MULTICAST(eh.ether_dhost)) {</a>
<a name="ln1437">			rt = ieee80211_mesh_rt_find(vap, eh.ether_dhost);</a>
<a name="ln1438">			KASSERT(rt != NULL, (&quot;route is NULL&quot;));</a>
<a name="ln1439">			dir = IEEE80211_FC1_DIR_DSTODS;</a>
<a name="ln1440">			hdrsize += IEEE80211_ADDR_LEN;</a>
<a name="ln1441">			if (rt-&gt;rt_flags &amp; IEEE80211_MESHRT_FLAGS_PROXY) {</a>
<a name="ln1442">				if (IEEE80211_ADDR_EQ(rt-&gt;rt_mesh_gate,</a>
<a name="ln1443">				    vap-&gt;iv_myaddr)) {</a>
<a name="ln1444">					IEEE80211_NOTE_MAC(vap,</a>
<a name="ln1445">					    IEEE80211_MSG_MESH,</a>
<a name="ln1446">					    eh.ether_dhost,</a>
<a name="ln1447">					    &quot;%s&quot;, &quot;trying to send to ourself&quot;);</a>
<a name="ln1448">					goto bad;</a>
<a name="ln1449">				}</a>
<a name="ln1450">				meshae = IEEE80211_MESH_AE_10;</a>
<a name="ln1451">				meshhdrsize =</a>
<a name="ln1452">				    sizeof(struct ieee80211_meshcntl_ae10);</a>
<a name="ln1453">			} else {</a>
<a name="ln1454">				meshae = IEEE80211_MESH_AE_00;</a>
<a name="ln1455">				meshhdrsize =</a>
<a name="ln1456">				    sizeof(struct ieee80211_meshcntl);</a>
<a name="ln1457">			}</a>
<a name="ln1458">		} else {</a>
<a name="ln1459">			dir = IEEE80211_FC1_DIR_FROMDS;</a>
<a name="ln1460">			if (!IEEE80211_ADDR_EQ(eh.ether_shost, vap-&gt;iv_myaddr)) {</a>
<a name="ln1461">				/* proxy group */</a>
<a name="ln1462">				meshae = IEEE80211_MESH_AE_01;</a>
<a name="ln1463">				meshhdrsize =</a>
<a name="ln1464">				    sizeof(struct ieee80211_meshcntl_ae01);</a>
<a name="ln1465">			} else {</a>
<a name="ln1466">				/* group */</a>
<a name="ln1467">				meshae = IEEE80211_MESH_AE_00;</a>
<a name="ln1468">				meshhdrsize = sizeof(struct ieee80211_meshcntl);</a>
<a name="ln1469">			}</a>
<a name="ln1470">		}</a>
<a name="ln1471">	} else {</a>
<a name="ln1472">#endif</a>
<a name="ln1473">		/*</a>
<a name="ln1474">		 * 4-address frames need to be generated for:</a>
<a name="ln1475">		 * o packets sent through a WDS vap (IEEE80211_M_WDS)</a>
<a name="ln1476">		 * o packets sent through a vap marked for relaying</a>
<a name="ln1477">		 *   (e.g. a station operating with dynamic WDS)</a>
<a name="ln1478">		 */</a>
<a name="ln1479">		is4addr = vap-&gt;iv_opmode == IEEE80211_M_WDS ||</a>
<a name="ln1480">		    ((vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_4ADDR) &amp;&amp;</a>
<a name="ln1481">		     !IEEE80211_ADDR_EQ(eh.ether_shost, vap-&gt;iv_myaddr));</a>
<a name="ln1482">		if (is4addr)</a>
<a name="ln1483">			hdrsize += IEEE80211_ADDR_LEN;</a>
<a name="ln1484">		meshhdrsize = meshae = 0;</a>
<a name="ln1485">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln1486">	}</a>
<a name="ln1487">#endif</a>
<a name="ln1488">	/*</a>
<a name="ln1489">	 * Honor driver DATAPAD requirement.</a>
<a name="ln1490">	 */</a>
<a name="ln1491">	if (ic-&gt;ic_flags &amp; IEEE80211_F_DATAPAD)</a>
<a name="ln1492">		hdrspace = roundup(hdrsize, sizeof(uint32_t));</a>
<a name="ln1493">	else</a>
<a name="ln1494">		hdrspace = hdrsize;</a>
<a name="ln1495"> </a>
<a name="ln1496">	if (__predict_true((m-&gt;m_flags &amp; M_FF) == 0)) {</a>
<a name="ln1497">		/*</a>
<a name="ln1498">		 * Normal frame.</a>
<a name="ln1499">		 */</a>
<a name="ln1500">		m = ieee80211_mbuf_adjust(vap, hdrspace + meshhdrsize, key, m);</a>
<a name="ln1501">		if (m == NULL) {</a>
<a name="ln1502">			/* NB: ieee80211_mbuf_adjust handles msgs+statistics */</a>
<a name="ln1503">			goto bad;</a>
<a name="ln1504">		}</a>
<a name="ln1505">		/* NB: this could be optimized 'cuz of ieee80211_mbuf_adjust */</a>
<a name="ln1506">		m_adj(m, sizeof(struct ether_header) - sizeof(struct llc));</a>
<a name="ln1507">		llc = mtod(m, struct llc *);</a>
<a name="ln1508">		llc-&gt;llc_dsap = llc-&gt;llc_ssap = LLC_SNAP_LSAP;</a>
<a name="ln1509">		llc-&gt;llc_control = LLC_UI;</a>
<a name="ln1510">		llc-&gt;llc_snap.org_code[0] = 0;</a>
<a name="ln1511">		llc-&gt;llc_snap.org_code[1] = 0;</a>
<a name="ln1512">		llc-&gt;llc_snap.org_code[2] = 0;</a>
<a name="ln1513">		llc-&gt;llc_snap.ether_type = eh.ether_type;</a>
<a name="ln1514">	} else {</a>
<a name="ln1515">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln1516">		/*</a>
<a name="ln1517">		 * Aggregated frame.  Check if it's for AMSDU or FF.</a>
<a name="ln1518">		 *</a>
<a name="ln1519">		 * XXX TODO: IEEE80211_NODE_AMSDU* isn't implemented</a>
<a name="ln1520">		 * anywhere for some reason.  But, since 11n requires</a>
<a name="ln1521">		 * AMSDU RX, we can just assume &quot;11n&quot; == &quot;AMSDU&quot;.</a>
<a name="ln1522">		 */</a>
<a name="ln1523">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_SUPERG, &quot;%s: called; M_FF\n&quot;, __func__);</a>
<a name="ln1524">		if (ieee80211_amsdu_tx_ok(ni)) {</a>
<a name="ln1525">			m = ieee80211_amsdu_encap(vap, m, hdrspace + meshhdrsize, key);</a>
<a name="ln1526">			is_amsdu = 1;</a>
<a name="ln1527">		} else {</a>
<a name="ln1528">			m = ieee80211_ff_encap(vap, m, hdrspace + meshhdrsize, key);</a>
<a name="ln1529">		}</a>
<a name="ln1530">		if (m == NULL)</a>
<a name="ln1531">#endif</a>
<a name="ln1532">			goto bad;</a>
<a name="ln1533">	}</a>
<a name="ln1534">	datalen = m-&gt;m_pkthdr.len;		/* NB: w/o 802.11 header */</a>
<a name="ln1535"> </a>
<a name="ln1536">	M_PREPEND(m, hdrspace + meshhdrsize, M_NOWAIT);</a>
<a name="ln1537">	if (m == NULL) {</a>
<a name="ln1538">		vap-&gt;iv_stats.is_tx_nobuf++;</a>
<a name="ln1539">		goto bad;</a>
<a name="ln1540">	}</a>
<a name="ln1541">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1542">	wh-&gt;i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln1543">	*(uint16_t *)wh-&gt;i_dur = 0;</a>
<a name="ln1544">	qos = NULL;	/* NB: quiet compiler */</a>
<a name="ln1545">	if (is4addr) {</a>
<a name="ln1546">		wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_DSTODS;</a>
<a name="ln1547">		IEEE80211_ADDR_COPY(wh-&gt;i_addr1, ni-&gt;ni_macaddr);</a>
<a name="ln1548">		IEEE80211_ADDR_COPY(wh-&gt;i_addr2, vap-&gt;iv_myaddr);</a>
<a name="ln1549">		IEEE80211_ADDR_COPY(wh-&gt;i_addr3, eh.ether_dhost);</a>
<a name="ln1550">		IEEE80211_ADDR_COPY(WH4(wh)-&gt;i_addr4, eh.ether_shost);</a>
<a name="ln1551">	} else switch (vap-&gt;iv_opmode) {</a>
<a name="ln1552">	case IEEE80211_M_STA:</a>
<a name="ln1553">		wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_TODS;</a>
<a name="ln1554">		IEEE80211_ADDR_COPY(wh-&gt;i_addr1, ni-&gt;ni_bssid);</a>
<a name="ln1555">		IEEE80211_ADDR_COPY(wh-&gt;i_addr2, eh.ether_shost);</a>
<a name="ln1556">		IEEE80211_ADDR_COPY(wh-&gt;i_addr3, eh.ether_dhost);</a>
<a name="ln1557">		break;</a>
<a name="ln1558">	case IEEE80211_M_IBSS:</a>
<a name="ln1559">	case IEEE80211_M_AHDEMO:</a>
<a name="ln1560">		wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_NODS;</a>
<a name="ln1561">		IEEE80211_ADDR_COPY(wh-&gt;i_addr1, eh.ether_dhost);</a>
<a name="ln1562">		IEEE80211_ADDR_COPY(wh-&gt;i_addr2, eh.ether_shost);</a>
<a name="ln1563">		/*</a>
<a name="ln1564">		 * NB: always use the bssid from iv_bss as the</a>
<a name="ln1565">		 *     neighbor's may be stale after an ibss merge</a>
<a name="ln1566">		 */</a>
<a name="ln1567">		IEEE80211_ADDR_COPY(wh-&gt;i_addr3, vap-&gt;iv_bss-&gt;ni_bssid);</a>
<a name="ln1568">		break;</a>
<a name="ln1569">	case IEEE80211_M_HOSTAP:</a>
<a name="ln1570">		wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_FROMDS;</a>
<a name="ln1571">		IEEE80211_ADDR_COPY(wh-&gt;i_addr1, eh.ether_dhost);</a>
<a name="ln1572">		IEEE80211_ADDR_COPY(wh-&gt;i_addr2, ni-&gt;ni_bssid);</a>
<a name="ln1573">		IEEE80211_ADDR_COPY(wh-&gt;i_addr3, eh.ether_shost);</a>
<a name="ln1574">		break;</a>
<a name="ln1575">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln1576">	case IEEE80211_M_MBSS:</a>
<a name="ln1577">		/* NB: offset by hdrspace to deal with DATAPAD */</a>
<a name="ln1578">		mc = (struct ieee80211_meshcntl_ae10 *)</a>
<a name="ln1579">		     (mtod(m, uint8_t *) + hdrspace);</a>
<a name="ln1580">		wh-&gt;i_fc[1] = dir;</a>
<a name="ln1581">		switch (meshae) {</a>
<a name="ln1582">		case IEEE80211_MESH_AE_00:	/* no proxy */</a>
<a name="ln1583">			mc-&gt;mc_flags = 0;</a>
<a name="ln1584">			if (dir == IEEE80211_FC1_DIR_DSTODS) { /* ucast */</a>
<a name="ln1585">				IEEE80211_ADDR_COPY(wh-&gt;i_addr1,</a>
<a name="ln1586">				    ni-&gt;ni_macaddr);</a>
<a name="ln1587">				IEEE80211_ADDR_COPY(wh-&gt;i_addr2,</a>
<a name="ln1588">				    vap-&gt;iv_myaddr);</a>
<a name="ln1589">				IEEE80211_ADDR_COPY(wh-&gt;i_addr3,</a>
<a name="ln1590">				    eh.ether_dhost);</a>
<a name="ln1591">				IEEE80211_ADDR_COPY(WH4(wh)-&gt;i_addr4,</a>
<a name="ln1592">				    eh.ether_shost);</a>
<a name="ln1593">				qos =((struct ieee80211_qosframe_addr4 *)</a>
<a name="ln1594">				    wh)-&gt;i_qos;</a>
<a name="ln1595">			} else if (dir == IEEE80211_FC1_DIR_FROMDS) {</a>
<a name="ln1596">				 /* mcast */</a>
<a name="ln1597">				IEEE80211_ADDR_COPY(wh-&gt;i_addr1,</a>
<a name="ln1598">				    eh.ether_dhost);</a>
<a name="ln1599">				IEEE80211_ADDR_COPY(wh-&gt;i_addr2,</a>
<a name="ln1600">				    vap-&gt;iv_myaddr);</a>
<a name="ln1601">				IEEE80211_ADDR_COPY(wh-&gt;i_addr3,</a>
<a name="ln1602">				    eh.ether_shost);</a>
<a name="ln1603">				qos = ((struct ieee80211_qosframe *)</a>
<a name="ln1604">				    wh)-&gt;i_qos;</a>
<a name="ln1605">			}</a>
<a name="ln1606">			break;</a>
<a name="ln1607">		case IEEE80211_MESH_AE_01:	/* mcast, proxy */</a>
<a name="ln1608">			wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_FROMDS;</a>
<a name="ln1609">			IEEE80211_ADDR_COPY(wh-&gt;i_addr1, eh.ether_dhost);</a>
<a name="ln1610">			IEEE80211_ADDR_COPY(wh-&gt;i_addr2, vap-&gt;iv_myaddr);</a>
<a name="ln1611">			IEEE80211_ADDR_COPY(wh-&gt;i_addr3, vap-&gt;iv_myaddr);</a>
<a name="ln1612">			mc-&gt;mc_flags = 1;</a>
<a name="ln1613">			IEEE80211_ADDR_COPY(MC01(mc)-&gt;mc_addr4,</a>
<a name="ln1614">			    eh.ether_shost);</a>
<a name="ln1615">			qos = ((struct ieee80211_qosframe *) wh)-&gt;i_qos;</a>
<a name="ln1616">			break;</a>
<a name="ln1617">		case IEEE80211_MESH_AE_10:	/* ucast, proxy */</a>
<a name="ln1618">			KASSERT(rt != NULL, (&quot;route is NULL&quot;));</a>
<a name="ln1619">			IEEE80211_ADDR_COPY(wh-&gt;i_addr1, rt-&gt;rt_nexthop);</a>
<a name="ln1620">			IEEE80211_ADDR_COPY(wh-&gt;i_addr2, vap-&gt;iv_myaddr);</a>
<a name="ln1621">			IEEE80211_ADDR_COPY(wh-&gt;i_addr3, rt-&gt;rt_mesh_gate);</a>
<a name="ln1622">			IEEE80211_ADDR_COPY(WH4(wh)-&gt;i_addr4, vap-&gt;iv_myaddr);</a>
<a name="ln1623">			mc-&gt;mc_flags = IEEE80211_MESH_AE_10;</a>
<a name="ln1624">			IEEE80211_ADDR_COPY(mc-&gt;mc_addr5, eh.ether_dhost);</a>
<a name="ln1625">			IEEE80211_ADDR_COPY(mc-&gt;mc_addr6, eh.ether_shost);</a>
<a name="ln1626">			qos = ((struct ieee80211_qosframe_addr4 *) wh)-&gt;i_qos;</a>
<a name="ln1627">			break;</a>
<a name="ln1628">		default:</a>
<a name="ln1629">			KASSERT(0, (&quot;meshae %d&quot;, meshae));</a>
<a name="ln1630">			break;</a>
<a name="ln1631">		}</a>
<a name="ln1632">		mc-&gt;mc_ttl = ms-&gt;ms_ttl;</a>
<a name="ln1633">		ms-&gt;ms_seq++;</a>
<a name="ln1634">		le32enc(mc-&gt;mc_seq, ms-&gt;ms_seq);</a>
<a name="ln1635">		break;</a>
<a name="ln1636">#endif</a>
<a name="ln1637">	case IEEE80211_M_WDS:		/* NB: is4addr should always be true */</a>
<a name="ln1638">	default:</a>
<a name="ln1639">		goto bad;</a>
<a name="ln1640">	}</a>
<a name="ln1641">	if (m-&gt;m_flags &amp; M_MORE_DATA)</a>
<a name="ln1642">		wh-&gt;i_fc[1] |= IEEE80211_FC1_MORE_DATA;</a>
<a name="ln1643">	if (addqos) {</a>
<a name="ln1644">		int ac, tid;</a>
<a name="ln1645"> </a>
<a name="ln1646">		if (is4addr) {</a>
<a name="ln1647">			qos = ((struct ieee80211_qosframe_addr4 *) wh)-&gt;i_qos;</a>
<a name="ln1648">		/* NB: mesh case handled earlier */</a>
<a name="ln1649">		} else if (vap-&gt;iv_opmode != IEEE80211_M_MBSS)</a>
<a name="ln1650">			qos = ((struct ieee80211_qosframe *) wh)-&gt;i_qos;</a>
<a name="ln1651">		ac = M_WME_GETAC(m);</a>
<a name="ln1652">		/* map from access class/queue to 11e header priorty value */</a>
<a name="ln1653">		tid = WME_AC_TO_TID(ac);</a>
<a name="ln1654">		qos[0] = tid &amp; IEEE80211_QOS_TID;</a>
<a name="ln1655">		if (ic-&gt;ic_wme.wme_wmeChanParams.cap_wmeParams[ac].wmep_noackPolicy)</a>
<a name="ln1656">			qos[0] |= IEEE80211_QOS_ACKPOLICY_NOACK;</a>
<a name="ln1657">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln1658">		if (vap-&gt;iv_opmode == IEEE80211_M_MBSS)</a>
<a name="ln1659">			qos[1] = IEEE80211_QOS_MC;</a>
<a name="ln1660">		else</a>
<a name="ln1661">#endif</a>
<a name="ln1662">			qos[1] = 0;</a>
<a name="ln1663">		wh-&gt;i_fc[0] |= IEEE80211_FC0_SUBTYPE_QOS;</a>
<a name="ln1664"> </a>
<a name="ln1665">		/*</a>
<a name="ln1666">		 * If this is an A-MSDU then ensure we set the</a>
<a name="ln1667">		 * relevant field.</a>
<a name="ln1668">		 */</a>
<a name="ln1669">		if (is_amsdu)</a>
<a name="ln1670">			qos[0] |= IEEE80211_QOS_AMSDU;</a>
<a name="ln1671"> </a>
<a name="ln1672">		/*</a>
<a name="ln1673">		 * XXX TODO TX lock is needed for atomic updates of sequence</a>
<a name="ln1674">		 * numbers.  If the driver does it, then don't do it here;</a>
<a name="ln1675">		 * and we don't need the TX lock held.</a>
<a name="ln1676">		 */</a>
<a name="ln1677">		if ((m-&gt;m_flags &amp; M_AMPDU_MPDU) == 0) {</a>
<a name="ln1678">			/*</a>
<a name="ln1679">			 * 802.11-2012 9.3.2.10 -</a>
<a name="ln1680">			 *</a>
<a name="ln1681">			 * If this is a multicast frame then we need</a>
<a name="ln1682">			 * to ensure that the sequence number comes from</a>
<a name="ln1683">			 * a separate seqno space and not the TID space.</a>
<a name="ln1684">			 *</a>
<a name="ln1685">			 * Otherwise multicast frames may actually cause</a>
<a name="ln1686">			 * holes in the TX blockack window space and</a>
<a name="ln1687">			 * upset various things.</a>
<a name="ln1688">			 */</a>
<a name="ln1689">			if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1))</a>
<a name="ln1690">				seqno = ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID]++;</a>
<a name="ln1691">			else</a>
<a name="ln1692">				seqno = ni-&gt;ni_txseqs[tid]++;</a>
<a name="ln1693"> </a>
<a name="ln1694">			/*</a>
<a name="ln1695">			 * NB: don't assign a sequence # to potential</a>
<a name="ln1696">			 * aggregates; we expect this happens at the</a>
<a name="ln1697">			 * point the frame comes off any aggregation q</a>
<a name="ln1698">			 * as otherwise we may introduce holes in the</a>
<a name="ln1699">			 * BA sequence space and/or make window accouting</a>
<a name="ln1700">			 * more difficult.</a>
<a name="ln1701">			 *</a>
<a name="ln1702">			 * XXX may want to control this with a driver</a>
<a name="ln1703">			 * capability; this may also change when we pull</a>
<a name="ln1704">			 * aggregation up into net80211</a>
<a name="ln1705">			 */</a>
<a name="ln1706">			seqno = ni-&gt;ni_txseqs[tid]++;</a>
<a name="ln1707">			*(uint16_t *)wh-&gt;i_seq =</a>
<a name="ln1708">			    htole16(seqno &lt;&lt; IEEE80211_SEQ_SEQ_SHIFT);</a>
<a name="ln1709">			M_SEQNO_SET(m, seqno);</a>
<a name="ln1710">		} else {</a>
<a name="ln1711">			/* NB: zero out i_seq field (for s/w encryption etc) */</a>
<a name="ln1712">			*(uint16_t *)wh-&gt;i_seq = 0;</a>
<a name="ln1713">		}</a>
<a name="ln1714">	} else {</a>
<a name="ln1715">		/*</a>
<a name="ln1716">		 * XXX TODO TX lock is needed for atomic updates of sequence</a>
<a name="ln1717">		 * numbers.  If the driver does it, then don't do it here;</a>
<a name="ln1718">		 * and we don't need the TX lock held.</a>
<a name="ln1719">		 */</a>
<a name="ln1720">		seqno = ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID]++;</a>
<a name="ln1721">		*(uint16_t *)wh-&gt;i_seq =</a>
<a name="ln1722">		    htole16(seqno &lt;&lt; IEEE80211_SEQ_SEQ_SHIFT);</a>
<a name="ln1723">		M_SEQNO_SET(m, seqno);</a>
<a name="ln1724"> </a>
<a name="ln1725">		/*</a>
<a name="ln1726">		 * XXX TODO: we shouldn't allow EAPOL, etc that would</a>
<a name="ln1727">		 * be forced to be non-QoS traffic to be A-MSDU encapsulated.</a>
<a name="ln1728">		 */</a>
<a name="ln1729">		if (is_amsdu)</a>
<a name="ln1730">			printf(&quot;%s: XXX ERROR: is_amsdu set; not QoS!\n&quot;,</a>
<a name="ln1731">			    __func__);</a>
<a name="ln1732">	}</a>
<a name="ln1733"> </a>
<a name="ln1734">	/*</a>
<a name="ln1735">	 * Check if xmit fragmentation is required.</a>
<a name="ln1736">	 *</a>
<a name="ln1737">	 * If the hardware does fragmentation offload, then don't bother</a>
<a name="ln1738">	 * doing it here.</a>
<a name="ln1739">	 */</a>
<a name="ln1740">	if (IEEE80211_CONF_FRAG_OFFLOAD(ic))</a>
<a name="ln1741">		txfrag = 0;</a>
<a name="ln1742">	else</a>
<a name="ln1743">		txfrag = (m-&gt;m_pkthdr.len &gt; vap-&gt;iv_fragthreshold &amp;&amp;</a>
<a name="ln1744">		    !IEEE80211_IS_MULTICAST(wh-&gt;i_addr1) &amp;&amp;</a>
<a name="ln1745">		    (vap-&gt;iv_caps &amp; IEEE80211_C_TXFRAG) &amp;&amp;</a>
<a name="ln1746">		    (m-&gt;m_flags &amp; (M_FF | M_AMPDU_MPDU)) == 0);</a>
<a name="ln1747"> </a>
<a name="ln1748">	if (key != NULL) {</a>
<a name="ln1749">		/*</a>
<a name="ln1750">		 * IEEE 802.1X: send EAPOL frames always in the clear.</a>
<a name="ln1751">		 * WPA/WPA2: encrypt EAPOL keys when pairwise keys are set.</a>
<a name="ln1752">		 */</a>
<a name="ln1753">		if ((m-&gt;m_flags &amp; M_EAPOL) == 0 ||</a>
<a name="ln1754">		    ((vap-&gt;iv_flags &amp; IEEE80211_F_WPA) &amp;&amp;</a>
<a name="ln1755">		     (vap-&gt;iv_opmode == IEEE80211_M_STA ?</a>
<a name="ln1756">		      !IEEE80211_KEY_UNDEFINED(key) :</a>
<a name="ln1757">		      !IEEE80211_KEY_UNDEFINED(&amp;ni-&gt;ni_ucastkey)))) {</a>
<a name="ln1758">			wh-&gt;i_fc[1] |= IEEE80211_FC1_PROTECTED;</a>
<a name="ln1759">			if (!ieee80211_crypto_enmic(vap, key, m, txfrag)) {</a>
<a name="ln1760">				IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_OUTPUT,</a>
<a name="ln1761">				    eh.ether_dhost,</a>
<a name="ln1762">				    &quot;%s&quot;, &quot;enmic failed, discard frame&quot;);</a>
<a name="ln1763">				vap-&gt;iv_stats.is_crypto_enmicfail++;</a>
<a name="ln1764">				goto bad;</a>
<a name="ln1765">			}</a>
<a name="ln1766">		}</a>
<a name="ln1767">	}</a>
<a name="ln1768">	if (txfrag &amp;&amp; !ieee80211_fragment(vap, m, hdrsize,</a>
<a name="ln1769">	    key != NULL ? key-&gt;wk_cipher-&gt;ic_header : 0, vap-&gt;iv_fragthreshold))</a>
<a name="ln1770">		goto bad;</a>
<a name="ln1771"> </a>
<a name="ln1772">	m-&gt;m_flags |= M_ENCAP;		/* mark encapsulated */</a>
<a name="ln1773"> </a>
<a name="ln1774">	IEEE80211_NODE_STAT(ni, tx_data);</a>
<a name="ln1775">	if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln1776">		IEEE80211_NODE_STAT(ni, tx_mcast);</a>
<a name="ln1777">		m-&gt;m_flags |= M_MCAST;</a>
<a name="ln1778">	} else</a>
<a name="ln1779">		IEEE80211_NODE_STAT(ni, tx_ucast);</a>
<a name="ln1780">	IEEE80211_NODE_STAT_ADD(ni, tx_bytes, datalen);</a>
<a name="ln1781"> </a>
<a name="ln1782">	return m;</a>
<a name="ln1783">bad:</a>
<a name="ln1784">	if (m != NULL)</a>
<a name="ln1785">		m_freem(m);</a>
<a name="ln1786">	return NULL;</a>
<a name="ln1787">#undef WH4</a>
<a name="ln1788">#undef MC01</a>
<a name="ln1789">}</a>
<a name="ln1790"> </a>
<a name="ln1791">void</a>
<a name="ln1792">ieee80211_free_mbuf(struct mbuf *m)</a>
<a name="ln1793">{</a>
<a name="ln1794">	struct mbuf *next;</a>
<a name="ln1795"> </a>
<a name="ln1796">	if (m == NULL)</a>
<a name="ln1797">		return;</a>
<a name="ln1798"> </a>
<a name="ln1799">	do {</a>
<a name="ln1800">		next = m-&gt;m_nextpkt;</a>
<a name="ln1801">		m-&gt;m_nextpkt = NULL;</a>
<a name="ln1802">		m_freem(m);</a>
<a name="ln1803">	} while ((m = next) != NULL);</a>
<a name="ln1804">}</a>
<a name="ln1805"> </a>
<a name="ln1806">/*</a>
<a name="ln1807"> * Fragment the frame according to the specified mtu.</a>
<a name="ln1808"> * The size of the 802.11 header (w/o padding) is provided</a>
<a name="ln1809"> * so we don't need to recalculate it.  We create a new</a>
<a name="ln1810"> * mbuf for each fragment and chain it through m_nextpkt;</a>
<a name="ln1811"> * we might be able to optimize this by reusing the original</a>
<a name="ln1812"> * packet's mbufs but that is significantly more complicated.</a>
<a name="ln1813"> */</a>
<a name="ln1814">static int</a>
<a name="ln1815">ieee80211_fragment(struct ieee80211vap *vap, struct mbuf *m0,</a>
<a name="ln1816">	u_int hdrsize, u_int ciphdrsize, u_int mtu)</a>
<a name="ln1817">{</a>
<a name="ln1818">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1819">	struct ieee80211_frame *wh, *whf;</a>
<a name="ln1820">	struct mbuf *m, *prev;</a>
<a name="ln1821">	u_int totalhdrsize, fragno, fragsize, off, remainder, payload;</a>
<a name="ln1822">	u_int hdrspace;</a>
<a name="ln1823"> </a>
<a name="ln1824">	KASSERT(m0-&gt;m_nextpkt == NULL, (&quot;mbuf already chained?&quot;));</a>
<a name="ln1825">	KASSERT(m0-&gt;m_pkthdr.len &gt; mtu,</a>
<a name="ln1826">		(&quot;pktlen %u mtu %u&quot;, m0-&gt;m_pkthdr.len, mtu));</a>
<a name="ln1827"> </a>
<a name="ln1828">	/*</a>
<a name="ln1829">	 * Honor driver DATAPAD requirement.</a>
<a name="ln1830">	 */</a>
<a name="ln1831">	if (ic-&gt;ic_flags &amp; IEEE80211_F_DATAPAD)</a>
<a name="ln1832">		hdrspace = roundup(hdrsize, sizeof(uint32_t));</a>
<a name="ln1833">	else</a>
<a name="ln1834">		hdrspace = hdrsize;</a>
<a name="ln1835"> </a>
<a name="ln1836">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1837">	/* NB: mark the first frag; it will be propagated below */</a>
<a name="ln1838">	wh-&gt;i_fc[1] |= IEEE80211_FC1_MORE_FRAG;</a>
<a name="ln1839">	totalhdrsize = hdrspace + ciphdrsize;</a>
<a name="ln1840">	fragno = 1;</a>
<a name="ln1841">	off = mtu - ciphdrsize;</a>
<a name="ln1842">	remainder = m0-&gt;m_pkthdr.len - off;</a>
<a name="ln1843">	prev = m0;</a>
<a name="ln1844">	do {</a>
<a name="ln1845">		fragsize = MIN(totalhdrsize + remainder, mtu);</a>
<a name="ln1846">		m = m_get2(fragsize, M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln1847">		if (m == NULL)</a>
<a name="ln1848">			goto bad;</a>
<a name="ln1849">		/* leave room to prepend any cipher header */</a>
<a name="ln1850">		m_align(m, fragsize - ciphdrsize);</a>
<a name="ln1851"> </a>
<a name="ln1852">		/*</a>
<a name="ln1853">		 * Form the header in the fragment.  Note that since</a>
<a name="ln1854">		 * we mark the first fragment with the MORE_FRAG bit</a>
<a name="ln1855">		 * it automatically is propagated to each fragment; we</a>
<a name="ln1856">		 * need only clear it on the last fragment (done below).</a>
<a name="ln1857">		 * NB: frag 1+ dont have Mesh Control field present.</a>
<a name="ln1858">		 */</a>
<a name="ln1859">		whf = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1860">		memcpy(whf, wh, hdrsize);</a>
<a name="ln1861">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln1862">		if (vap-&gt;iv_opmode == IEEE80211_M_MBSS) {</a>
<a name="ln1863">			if (IEEE80211_IS_DSTODS(wh))</a>
<a name="ln1864">				((struct ieee80211_qosframe_addr4 *)</a>
<a name="ln1865">				    whf)-&gt;i_qos[1] &amp;= ~IEEE80211_QOS_MC;</a>
<a name="ln1866">			else</a>
<a name="ln1867">				((struct ieee80211_qosframe *)</a>
<a name="ln1868">				    whf)-&gt;i_qos[1] &amp;= ~IEEE80211_QOS_MC;</a>
<a name="ln1869">		}</a>
<a name="ln1870">#endif</a>
<a name="ln1871">		*(uint16_t *)&amp;whf-&gt;i_seq[0] |= htole16(</a>
<a name="ln1872">			(fragno &amp; IEEE80211_SEQ_FRAG_MASK) &lt;&lt;</a>
<a name="ln1873">				IEEE80211_SEQ_FRAG_SHIFT);</a>
<a name="ln1874">		fragno++;</a>
<a name="ln1875"> </a>
<a name="ln1876">		payload = fragsize - totalhdrsize;</a>
<a name="ln1877">		/* NB: destination is known to be contiguous */</a>
<a name="ln1878"> </a>
<a name="ln1879">		m_copydata(m0, off, payload, mtod(m, uint8_t *) + hdrspace);</a>
<a name="ln1880">		m-&gt;m_len = hdrspace + payload;</a>
<a name="ln1881">		m-&gt;m_pkthdr.len = hdrspace + payload;</a>
<a name="ln1882">		m-&gt;m_flags |= M_FRAG;</a>
<a name="ln1883"> </a>
<a name="ln1884">		/* chain up the fragment */</a>
<a name="ln1885">		prev-&gt;m_nextpkt = m;</a>
<a name="ln1886">		prev = m;</a>
<a name="ln1887"> </a>
<a name="ln1888">		/* deduct fragment just formed */</a>
<a name="ln1889">		remainder -= payload;</a>
<a name="ln1890">		off += payload;</a>
<a name="ln1891">	} while (remainder != 0);</a>
<a name="ln1892"> </a>
<a name="ln1893">	/* set the last fragment */</a>
<a name="ln1894">	m-&gt;m_flags |= M_LASTFRAG;</a>
<a name="ln1895">	whf-&gt;i_fc[1] &amp;= ~IEEE80211_FC1_MORE_FRAG;</a>
<a name="ln1896"> </a>
<a name="ln1897">	/* strip first mbuf now that everything has been copied */</a>
<a name="ln1898">	m_adj(m0, -(m0-&gt;m_pkthdr.len - (mtu - ciphdrsize)));</a>
<a name="ln1899">	m0-&gt;m_flags |= M_FIRSTFRAG | M_FRAG;</a>
<a name="ln1900"> </a>
<a name="ln1901">	vap-&gt;iv_stats.is_tx_fragframes++;</a>
<a name="ln1902">	vap-&gt;iv_stats.is_tx_frags += fragno-1;</a>
<a name="ln1903"> </a>
<a name="ln1904">	return 1;</a>
<a name="ln1905">bad:</a>
<a name="ln1906">	/* reclaim fragments but leave original frame for caller to free */</a>
<a name="ln1907">	ieee80211_free_mbuf(m0-&gt;m_nextpkt);</a>
<a name="ln1908">	m0-&gt;m_nextpkt = NULL;</a>
<a name="ln1909">	return 0;</a>
<a name="ln1910">}</a>
<a name="ln1911"> </a>
<a name="ln1912">/*</a>
<a name="ln1913"> * Add a supported rates element id to a frame.</a>
<a name="ln1914"> */</a>
<a name="ln1915">uint8_t *</a>
<a name="ln1916">ieee80211_add_rates(uint8_t *frm, const struct ieee80211_rateset *rs)</a>
<a name="ln1917">{</a>
<a name="ln1918">	int nrates;</a>
<a name="ln1919"> </a>
<a name="ln1920">	*frm++ = IEEE80211_ELEMID_RATES;</a>
<a name="ln1921">	nrates = rs-&gt;rs_nrates;</a>
<a name="ln1922">	if (nrates &gt; IEEE80211_RATE_SIZE)</a>
<a name="ln1923">		nrates = IEEE80211_RATE_SIZE;</a>
<a name="ln1924">	*frm++ = nrates;</a>
<a name="ln1925">	memcpy(frm, rs-&gt;rs_rates, nrates);</a>
<a name="ln1926">	return frm + nrates;</a>
<a name="ln1927">}</a>
<a name="ln1928"> </a>
<a name="ln1929">/*</a>
<a name="ln1930"> * Add an extended supported rates element id to a frame.</a>
<a name="ln1931"> */</a>
<a name="ln1932">uint8_t *</a>
<a name="ln1933">ieee80211_add_xrates(uint8_t *frm, const struct ieee80211_rateset *rs)</a>
<a name="ln1934">{</a>
<a name="ln1935">	/*</a>
<a name="ln1936">	 * Add an extended supported rates element if operating in 11g mode.</a>
<a name="ln1937">	 */</a>
<a name="ln1938">	if (rs-&gt;rs_nrates &gt; IEEE80211_RATE_SIZE) {</a>
<a name="ln1939">		int nrates = rs-&gt;rs_nrates - IEEE80211_RATE_SIZE;</a>
<a name="ln1940">		*frm++ = IEEE80211_ELEMID_XRATES;</a>
<a name="ln1941">		*frm++ = nrates;</a>
<a name="ln1942">		memcpy(frm, rs-&gt;rs_rates + IEEE80211_RATE_SIZE, nrates);</a>
<a name="ln1943">		frm += nrates;</a>
<a name="ln1944">	}</a>
<a name="ln1945">	return frm;</a>
<a name="ln1946">}</a>
<a name="ln1947"> </a>
<a name="ln1948">/*</a>
<a name="ln1949"> * Add an ssid element to a frame.</a>
<a name="ln1950"> */</a>
<a name="ln1951">uint8_t *</a>
<a name="ln1952">ieee80211_add_ssid(uint8_t *frm, const uint8_t *ssid, u_int len)</a>
<a name="ln1953">{</a>
<a name="ln1954">	*frm++ = IEEE80211_ELEMID_SSID;</a>
<a name="ln1955">	*frm++ = len;</a>
<a name="ln1956">	memcpy(frm, ssid, len);</a>
<a name="ln1957">	return frm + len;</a>
<a name="ln1958">}</a>
<a name="ln1959"> </a>
<a name="ln1960">/*</a>
<a name="ln1961"> * Add an erp element to a frame.</a>
<a name="ln1962"> */</a>
<a name="ln1963">static uint8_t *</a>
<a name="ln1964">ieee80211_add_erp(uint8_t *frm, struct ieee80211com *ic)</a>
<a name="ln1965">{</a>
<a name="ln1966">	uint8_t erp;</a>
<a name="ln1967"> </a>
<a name="ln1968">	*frm++ = IEEE80211_ELEMID_ERP;</a>
<a name="ln1969">	*frm++ = 1;</a>
<a name="ln1970">	erp = 0;</a>
<a name="ln1971">	if (ic-&gt;ic_nonerpsta != 0)</a>
<a name="ln1972">		erp |= IEEE80211_ERP_NON_ERP_PRESENT;</a>
<a name="ln1973">	if (ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT)</a>
<a name="ln1974">		erp |= IEEE80211_ERP_USE_PROTECTION;</a>
<a name="ln1975">	if (ic-&gt;ic_flags &amp; IEEE80211_F_USEBARKER)</a>
<a name="ln1976">		erp |= IEEE80211_ERP_LONG_PREAMBLE;</a>
<a name="ln1977">	*frm++ = erp;</a>
<a name="ln1978">	return frm;</a>
<a name="ln1979">}</a>
<a name="ln1980"> </a>
<a name="ln1981">/*</a>
<a name="ln1982"> * Add a CFParams element to a frame.</a>
<a name="ln1983"> */</a>
<a name="ln1984">static uint8_t *</a>
<a name="ln1985">ieee80211_add_cfparms(uint8_t *frm, struct ieee80211com *ic)</a>
<a name="ln1986">{</a>
<a name="ln1987">#define	ADDSHORT(frm, v) do {	\</a>
<a name="ln1988">	le16enc(frm, v);	\</a>
<a name="ln1989">	frm += 2;		\</a>
<a name="ln1990">} while (0)</a>
<a name="ln1991">	*frm++ = IEEE80211_ELEMID_CFPARMS;</a>
<a name="ln1992">	*frm++ = 6;</a>
<a name="ln1993">	*frm++ = 0;		/* CFP count */</a>
<a name="ln1994">	*frm++ = 2;		/* CFP period */</a>
<a name="ln1995">	ADDSHORT(frm, 0);	/* CFP MaxDuration (TU) */</a>
<a name="ln1996">	ADDSHORT(frm, 0);	/* CFP CurRemaining (TU) */</a>
<a name="ln1997">	return frm;</a>
<a name="ln1998">#undef ADDSHORT</a>
<a name="ln1999">}</a>
<a name="ln2000"> </a>
<a name="ln2001">static __inline uint8_t *</a>
<a name="ln2002">add_appie(uint8_t *frm, const struct ieee80211_appie *ie)</a>
<a name="ln2003">{</a>
<a name="ln2004">	memcpy(frm, ie-&gt;ie_data, ie-&gt;ie_len);</a>
<a name="ln2005">	return frm + ie-&gt;ie_len;</a>
<a name="ln2006">}</a>
<a name="ln2007"> </a>
<a name="ln2008">static __inline uint8_t *</a>
<a name="ln2009">add_ie(uint8_t *frm, const uint8_t *ie)</a>
<a name="ln2010">{</a>
<a name="ln2011">	memcpy(frm, ie, 2 + ie[1]);</a>
<a name="ln2012">	return frm + 2 + ie[1];</a>
<a name="ln2013">}</a>
<a name="ln2014"> </a>
<a name="ln2015">#define	WME_OUI_BYTES		0x00, 0x50, 0xf2</a>
<a name="ln2016">/*</a>
<a name="ln2017"> * Add a WME information element to a frame.</a>
<a name="ln2018"> */</a>
<a name="ln2019">uint8_t *</a>
<a name="ln2020">ieee80211_add_wme_info(uint8_t *frm, struct ieee80211_wme_state *wme)</a>
<a name="ln2021">{</a>
<a name="ln2022">	static const struct ieee80211_wme_info info = {</a>
<a name="ln2023">		.wme_id		= IEEE80211_ELEMID_VENDOR,</a>
<a name="ln2024">		.wme_len	= sizeof(struct ieee80211_wme_info) - 2,</a>
<a name="ln2025">		.wme_oui	= { WME_OUI_BYTES },</a>
<a name="ln2026">		.wme_type	= WME_OUI_TYPE,</a>
<a name="ln2027">		.wme_subtype	= WME_INFO_OUI_SUBTYPE,</a>
<a name="ln2028">		.wme_version	= WME_VERSION,</a>
<a name="ln2029">		.wme_info	= 0,</a>
<a name="ln2030">	};</a>
<a name="ln2031">	memcpy(frm, &amp;info, sizeof(info));</a>
<a name="ln2032">	return frm + sizeof(info);</a>
<a name="ln2033">}</a>
<a name="ln2034"> </a>
<a name="ln2035">/*</a>
<a name="ln2036"> * Add a WME parameters element to a frame.</a>
<a name="ln2037"> */</a>
<a name="ln2038">static uint8_t *</a>
<a name="ln2039">ieee80211_add_wme_param(uint8_t *frm, struct ieee80211_wme_state *wme)</a>
<a name="ln2040">{</a>
<a name="ln2041">#define	SM(_v, _f)	(((_v) &lt;&lt; _f##_S) &amp; _f)</a>
<a name="ln2042">#define	ADDSHORT(frm, v) do {	\</a>
<a name="ln2043">	le16enc(frm, v);	\</a>
<a name="ln2044">	frm += 2;		\</a>
<a name="ln2045">} while (0)</a>
<a name="ln2046">	/* NB: this works 'cuz a param has an info at the front */</a>
<a name="ln2047">	static const struct ieee80211_wme_info param = {</a>
<a name="ln2048">		.wme_id		= IEEE80211_ELEMID_VENDOR,</a>
<a name="ln2049">		.wme_len	= sizeof(struct ieee80211_wme_param) - 2,</a>
<a name="ln2050">		.wme_oui	= { WME_OUI_BYTES },</a>
<a name="ln2051">		.wme_type	= WME_OUI_TYPE,</a>
<a name="ln2052">		.wme_subtype	= WME_PARAM_OUI_SUBTYPE,</a>
<a name="ln2053">		.wme_version	= WME_VERSION,</a>
<a name="ln2054">	};</a>
<a name="ln2055">	int i;</a>
<a name="ln2056"> </a>
<a name="ln2057">	memcpy(frm, &amp;param, sizeof(param));</a>
<a name="ln2058">	frm += __offsetof(struct ieee80211_wme_info, wme_info);</a>
<a name="ln2059">	*frm++ = wme-&gt;wme_bssChanParams.cap_info;	/* AC info */</a>
<a name="ln2060">	*frm++ = 0;					/* reserved field */</a>
<a name="ln2061">	for (i = 0; i &lt; WME_NUM_AC; i++) {</a>
<a name="ln2062">		const struct wmeParams *ac =</a>
<a name="ln2063">		       &amp;wme-&gt;wme_bssChanParams.cap_wmeParams[i];</a>
<a name="ln2064">		*frm++ = SM(i, WME_PARAM_ACI)</a>
<a name="ln2065">		       | SM(ac-&gt;wmep_acm, WME_PARAM_ACM)</a>
<a name="ln2066">		       | SM(ac-&gt;wmep_aifsn, WME_PARAM_AIFSN)</a>
<a name="ln2067">		       ;</a>
<a name="ln2068">		*frm++ = SM(ac-&gt;wmep_logcwmax, WME_PARAM_LOGCWMAX)</a>
<a name="ln2069">		       | SM(ac-&gt;wmep_logcwmin, WME_PARAM_LOGCWMIN)</a>
<a name="ln2070">		       ;</a>
<a name="ln2071">		ADDSHORT(frm, ac-&gt;wmep_txopLimit);</a>
<a name="ln2072">	}</a>
<a name="ln2073">	return frm;</a>
<a name="ln2074">#undef SM</a>
<a name="ln2075">#undef ADDSHORT</a>
<a name="ln2076">}</a>
<a name="ln2077">#undef WME_OUI_BYTES</a>
<a name="ln2078"> </a>
<a name="ln2079">/*</a>
<a name="ln2080"> * Add an 11h Power Constraint element to a frame.</a>
<a name="ln2081"> */</a>
<a name="ln2082">static uint8_t *</a>
<a name="ln2083">ieee80211_add_powerconstraint(uint8_t *frm, struct ieee80211vap *vap)</a>
<a name="ln2084">{</a>
<a name="ln2085">	const struct ieee80211_channel *c = vap-&gt;iv_bss-&gt;ni_chan;</a>
<a name="ln2086">	/* XXX per-vap tx power limit? */</a>
<a name="ln2087">	int8_t limit = vap-&gt;iv_ic-&gt;ic_txpowlimit / 2;</a>
<a name="ln2088"> </a>
<a name="ln2089">	frm[0] = IEEE80211_ELEMID_PWRCNSTR;</a>
<a name="ln2090">	frm[1] = 1;</a>
<a name="ln2091">	frm[2] = c-&gt;ic_maxregpower &gt; limit ?  c-&gt;ic_maxregpower - limit : 0;</a>
<a name="ln2092">	return frm + 3;</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095">/*</a>
<a name="ln2096"> * Add an 11h Power Capability element to a frame.</a>
<a name="ln2097"> */</a>
<a name="ln2098">static uint8_t *</a>
<a name="ln2099">ieee80211_add_powercapability(uint8_t *frm, const struct ieee80211_channel *c)</a>
<a name="ln2100">{</a>
<a name="ln2101">	frm[0] = IEEE80211_ELEMID_PWRCAP;</a>
<a name="ln2102">	frm[1] = 2;</a>
<a name="ln2103">	frm[2] = c-&gt;ic_minpower;</a>
<a name="ln2104">	frm[3] = c-&gt;ic_maxpower;</a>
<a name="ln2105">	return frm + 4;</a>
<a name="ln2106">}</a>
<a name="ln2107"> </a>
<a name="ln2108">/*</a>
<a name="ln2109"> * Add an 11h Supported Channels element to a frame.</a>
<a name="ln2110"> */</a>
<a name="ln2111">static uint8_t *</a>
<a name="ln2112">ieee80211_add_supportedchannels(uint8_t *frm, struct ieee80211com *ic)</a>
<a name="ln2113">{</a>
<a name="ln2114">	static const int ielen = 26;</a>
<a name="ln2115"> </a>
<a name="ln2116">	frm[0] = IEEE80211_ELEMID_SUPPCHAN;</a>
<a name="ln2117">	frm[1] = ielen;</a>
<a name="ln2118">	/* XXX not correct */</a>
<a name="ln2119">	memcpy(frm+2, ic-&gt;ic_chan_avail, ielen);</a>
<a name="ln2120">	return frm + 2 + ielen;</a>
<a name="ln2121">}</a>
<a name="ln2122"> </a>
<a name="ln2123">/*</a>
<a name="ln2124"> * Add an 11h Quiet time element to a frame.</a>
<a name="ln2125"> */</a>
<a name="ln2126">static uint8_t *</a>
<a name="ln2127">ieee80211_add_quiet(uint8_t *frm, struct ieee80211vap *vap, int update)</a>
<a name="ln2128">{</a>
<a name="ln2129">	struct ieee80211_quiet_ie *quiet = (struct ieee80211_quiet_ie *) frm;</a>
<a name="ln2130"> </a>
<a name="ln2131">	quiet-&gt;quiet_ie = IEEE80211_ELEMID_QUIET;</a>
<a name="ln2132">	quiet-&gt;len = 6;</a>
<a name="ln2133"> </a>
<a name="ln2134">	/*</a>
<a name="ln2135">	 * Only update every beacon interval - otherwise probe responses</a>
<a name="ln2136">	 * would update the quiet count value.</a>
<a name="ln2137">	 */</a>
<a name="ln2138">	if (update) {</a>
<a name="ln2139">		if (vap-&gt;iv_quiet_count_value == 1)</a>
<a name="ln2140">			vap-&gt;iv_quiet_count_value = vap-&gt;iv_quiet_count;</a>
<a name="ln2141">		else if (vap-&gt;iv_quiet_count_value &gt; 1)</a>
<a name="ln2142">			vap-&gt;iv_quiet_count_value--;</a>
<a name="ln2143">	}</a>
<a name="ln2144"> </a>
<a name="ln2145">	if (vap-&gt;iv_quiet_count_value == 0) {</a>
<a name="ln2146">		/* value 0 is reserved as per 802.11h standerd */</a>
<a name="ln2147">		vap-&gt;iv_quiet_count_value = 1;</a>
<a name="ln2148">	}</a>
<a name="ln2149"> </a>
<a name="ln2150">	quiet-&gt;tbttcount = vap-&gt;iv_quiet_count_value;</a>
<a name="ln2151">	quiet-&gt;period = vap-&gt;iv_quiet_period;</a>
<a name="ln2152">	quiet-&gt;duration = htole16(vap-&gt;iv_quiet_duration);</a>
<a name="ln2153">	quiet-&gt;offset = htole16(vap-&gt;iv_quiet_offset);</a>
<a name="ln2154">	return frm + sizeof(*quiet);</a>
<a name="ln2155">}</a>
<a name="ln2156"> </a>
<a name="ln2157">/*</a>
<a name="ln2158"> * Add an 11h Channel Switch Announcement element to a frame.</a>
<a name="ln2159"> * Note that we use the per-vap CSA count to adjust the global</a>
<a name="ln2160"> * counter so we can use this routine to form probe response</a>
<a name="ln2161"> * frames and get the current count.</a>
<a name="ln2162"> */</a>
<a name="ln2163">static uint8_t *</a>
<a name="ln2164">ieee80211_add_csa(uint8_t *frm, struct ieee80211vap *vap)</a>
<a name="ln2165">{</a>
<a name="ln2166">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2167">	struct ieee80211_csa_ie *csa = (struct ieee80211_csa_ie *) frm;</a>
<a name="ln2168"> </a>
<a name="ln2169">	csa-&gt;csa_ie = IEEE80211_ELEMID_CSA;</a>
<a name="ln2170">	csa-&gt;csa_len = 3;</a>
<a name="ln2171">	csa-&gt;csa_mode = 1;		/* XXX force quiet on channel */</a>
<a name="ln2172">	csa-&gt;csa_newchan = ieee80211_chan2ieee(ic, ic-&gt;ic_csa_newchan);</a>
<a name="ln2173">	csa-&gt;csa_count = ic-&gt;ic_csa_count - vap-&gt;iv_csa_count;</a>
<a name="ln2174">	return frm + sizeof(*csa);</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">/*</a>
<a name="ln2178"> * Add an 11h country information element to a frame.</a>
<a name="ln2179"> */</a>
<a name="ln2180">static uint8_t *</a>
<a name="ln2181">ieee80211_add_countryie(uint8_t *frm, struct ieee80211com *ic)</a>
<a name="ln2182">{</a>
<a name="ln2183"> </a>
<a name="ln2184">	if (ic-&gt;ic_countryie == NULL ||</a>
<a name="ln2185">	    ic-&gt;ic_countryie_chan != ic-&gt;ic_bsschan) {</a>
<a name="ln2186">		/*</a>
<a name="ln2187">		 * Handle lazy construction of ie.  This is done on</a>
<a name="ln2188">		 * first use and after a channel change that requires</a>
<a name="ln2189">		 * re-calculation.</a>
<a name="ln2190">		 */</a>
<a name="ln2191">		if (ic-&gt;ic_countryie != NULL)</a>
<a name="ln2192">			IEEE80211_FREE(ic-&gt;ic_countryie, M_80211_NODE_IE);</a>
<a name="ln2193">		ic-&gt;ic_countryie = ieee80211_alloc_countryie(ic);</a>
<a name="ln2194">		if (ic-&gt;ic_countryie == NULL)</a>
<a name="ln2195">			return frm;</a>
<a name="ln2196">		ic-&gt;ic_countryie_chan = ic-&gt;ic_bsschan;</a>
<a name="ln2197">	}</a>
<a name="ln2198">	return add_appie(frm, ic-&gt;ic_countryie);</a>
<a name="ln2199">}</a>
<a name="ln2200"> </a>
<a name="ln2201">uint8_t *</a>
<a name="ln2202">ieee80211_add_wpa(uint8_t *frm, const struct ieee80211vap *vap)</a>
<a name="ln2203">{</a>
<a name="ln2204">	if (vap-&gt;iv_flags &amp; IEEE80211_F_WPA1 &amp;&amp; vap-&gt;iv_wpa_ie != NULL)</a>
<a name="ln2205">		return (add_ie(frm, vap-&gt;iv_wpa_ie));</a>
<a name="ln2206">	else {</a>
<a name="ln2207">		/* XXX else complain? */</a>
<a name="ln2208">		return (frm);</a>
<a name="ln2209">	}</a>
<a name="ln2210">}</a>
<a name="ln2211"> </a>
<a name="ln2212">uint8_t *</a>
<a name="ln2213">ieee80211_add_rsn(uint8_t *frm, const struct ieee80211vap *vap)</a>
<a name="ln2214">{</a>
<a name="ln2215">	if (vap-&gt;iv_flags &amp; IEEE80211_F_WPA2 &amp;&amp; vap-&gt;iv_rsn_ie != NULL)</a>
<a name="ln2216">		return (add_ie(frm, vap-&gt;iv_rsn_ie));</a>
<a name="ln2217">	else {</a>
<a name="ln2218">		/* XXX else complain? */</a>
<a name="ln2219">		return (frm);</a>
<a name="ln2220">	}</a>
<a name="ln2221">}</a>
<a name="ln2222"> </a>
<a name="ln2223">uint8_t *</a>
<a name="ln2224">ieee80211_add_qos(uint8_t *frm, const struct ieee80211_node *ni)</a>
<a name="ln2225">{</a>
<a name="ln2226">	if (ni-&gt;ni_flags &amp; IEEE80211_NODE_QOS) {</a>
<a name="ln2227">		*frm++ = IEEE80211_ELEMID_QOS;</a>
<a name="ln2228">		*frm++ = 1;</a>
<a name="ln2229">		*frm++ = 0;</a>
<a name="ln2230">	}</a>
<a name="ln2231"> </a>
<a name="ln2232">	return (frm);</a>
<a name="ln2233">}</a>
<a name="ln2234"> </a>
<a name="ln2235">/*</a>
<a name="ln2236"> * Send a probe request frame with the specified ssid</a>
<a name="ln2237"> * and any optional information element data.</a>
<a name="ln2238"> */</a>
<a name="ln2239">int</a>
<a name="ln2240">ieee80211_send_probereq(struct ieee80211_node *ni,</a>
<a name="ln2241">	const uint8_t sa[IEEE80211_ADDR_LEN],</a>
<a name="ln2242">	const uint8_t da[IEEE80211_ADDR_LEN],</a>
<a name="ln2243">	const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln2244">	const uint8_t *ssid, size_t ssidlen)</a>
<a name="ln2245">{</a>
<a name="ln2246">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln2247">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln2248">	struct ieee80211_node *bss;</a>
<a name="ln2249">	const struct ieee80211_txparam *tp;</a>
<a name="ln2250">	struct ieee80211_bpf_params params;</a>
<a name="ln2251">	const struct ieee80211_rateset *rs;</a>
<a name="ln2252">	struct mbuf *m;</a>
<a name="ln2253">	uint8_t *frm;</a>
<a name="ln2254">	int ret;</a>
<a name="ln2255"> </a>
<a name="ln2256">	bss = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln2257"> </a>
<a name="ln2258">	if (vap-&gt;iv_state == IEEE80211_S_CAC) {</a>
<a name="ln2259">		IEEE80211_NOTE(vap, IEEE80211_MSG_OUTPUT, ni,</a>
<a name="ln2260">		    &quot;block %s frame in CAC state&quot;, &quot;probe request&quot;);</a>
<a name="ln2261">		vap-&gt;iv_stats.is_tx_badstate++;</a>
<a name="ln2262">		ieee80211_free_node(bss);</a>
<a name="ln2263">		return EIO;		/* XXX */</a>
<a name="ln2264">	}</a>
<a name="ln2265"> </a>
<a name="ln2266">	/*</a>
<a name="ln2267">	 * Hold a reference on the node so it doesn't go away until after</a>
<a name="ln2268">	 * the xmit is complete all the way in the driver.  On error we</a>
<a name="ln2269">	 * will remove our reference.</a>
<a name="ln2270">	 */</a>
<a name="ln2271">#ifndef __HAIKU__</a>
<a name="ln2272">	IEEE80211_DPRINTF(vap, IEEE80211_MSG_NODE,</a>
<a name="ln2273">		&quot;ieee80211_ref_node (%s:%u) %p&lt;%s&gt; refcnt %d\n&quot;,</a>
<a name="ln2274">		__func__, __LINE__,</a>
<a name="ln2275">		ni, ether_sprintf(ni-&gt;ni_macaddr),</a>
<a name="ln2276">		ieee80211_node_refcnt(ni)+1);</a>
<a name="ln2277">#endif</a>
<a name="ln2278">	ieee80211_ref_node(ni);</a>
<a name="ln2279"> </a>
<a name="ln2280">	/*</a>
<a name="ln2281">	 * prreq frame format</a>
<a name="ln2282">	 *	[tlv] ssid</a>
<a name="ln2283">	 *	[tlv] supported rates</a>
<a name="ln2284">	 *	[tlv] RSN (optional)</a>
<a name="ln2285">	 *	[tlv] extended supported rates</a>
<a name="ln2286">	 *	[tlv] HT cap (optional)</a>
<a name="ln2287">	 *	[tlv] VHT cap (optional)</a>
<a name="ln2288">	 *	[tlv] WPA (optional)</a>
<a name="ln2289">	 *	[tlv] user-specified ie's</a>
<a name="ln2290">	 */</a>
<a name="ln2291">	m = ieee80211_getmgtframe(&amp;frm,</a>
<a name="ln2292">		 ic-&gt;ic_headroom + sizeof(struct ieee80211_frame),</a>
<a name="ln2293">	       	 2 + IEEE80211_NWID_LEN</a>
<a name="ln2294">	       + 2 + IEEE80211_RATE_SIZE</a>
<a name="ln2295">	       + sizeof(struct ieee80211_ie_htcap)</a>
<a name="ln2296">	       + sizeof(struct ieee80211_ie_vhtcap)</a>
<a name="ln2297">	       + sizeof(struct ieee80211_ie_htinfo)	/* XXX not needed? */</a>
<a name="ln2298">	       + sizeof(struct ieee80211_ie_wpa)</a>
<a name="ln2299">	       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE)</a>
<a name="ln2300">	       + sizeof(struct ieee80211_ie_wpa)</a>
<a name="ln2301">	       + (vap-&gt;iv_appie_probereq != NULL ?</a>
<a name="ln2302">		   vap-&gt;iv_appie_probereq-&gt;ie_len : 0)</a>
<a name="ln2303">	);</a>
<a name="ln2304">	if (m == NULL) {</a>
<a name="ln2305">		vap-&gt;iv_stats.is_tx_nobuf++;</a>
<a name="ln2306">		ieee80211_free_node(ni);</a>
<a name="ln2307">		ieee80211_free_node(bss);</a>
<a name="ln2308">		return ENOMEM;</a>
<a name="ln2309">	}</a>
<a name="ln2310"> </a>
<a name="ln2311">	frm = ieee80211_add_ssid(frm, ssid, ssidlen);</a>
<a name="ln2312">	rs = ieee80211_get_suprates(ic, ic-&gt;ic_curchan);</a>
<a name="ln2313">	frm = ieee80211_add_rates(frm, rs);</a>
<a name="ln2314">	frm = ieee80211_add_rsn(frm, vap);</a>
<a name="ln2315">	frm = ieee80211_add_xrates(frm, rs);</a>
<a name="ln2316"> </a>
<a name="ln2317">	/*</a>
<a name="ln2318">	 * Note: we can't use bss; we don't have one yet.</a>
<a name="ln2319">	 *</a>
<a name="ln2320">	 * So, we should announce our capabilities</a>
<a name="ln2321">	 * in this channel mode (2g/5g), not the</a>
<a name="ln2322">	 * channel details itself.</a>
<a name="ln2323">	 */</a>
<a name="ln2324">	if ((vap-&gt;iv_opmode == IEEE80211_M_IBSS) &amp;&amp;</a>
<a name="ln2325">	    (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HT)) {</a>
<a name="ln2326">		struct ieee80211_channel *c;</a>
<a name="ln2327"> </a>
<a name="ln2328">		/*</a>
<a name="ln2329">		 * Get the HT channel that we should try upgrading to.</a>
<a name="ln2330">		 * If we can do 40MHz then this'll upgrade it appropriately.</a>
<a name="ln2331">		 */</a>
<a name="ln2332">		c = ieee80211_ht_adjust_channel(ic, ic-&gt;ic_curchan,</a>
<a name="ln2333">		    vap-&gt;iv_flags_ht);</a>
<a name="ln2334">		frm = ieee80211_add_htcap_ch(frm, vap, c);</a>
<a name="ln2335">	}</a>
<a name="ln2336"> </a>
<a name="ln2337">	/*</a>
<a name="ln2338">	 * XXX TODO: need to figure out what/how to update the</a>
<a name="ln2339">	 * VHT channel.</a>
<a name="ln2340">	 */</a>
<a name="ln2341">#if 0</a>
<a name="ln2342">	(vap-&gt;iv_flags_vht &amp; IEEE80211_FVHT_VHT) {</a>
<a name="ln2343">		struct ieee80211_channel *c;</a>
<a name="ln2344"> </a>
<a name="ln2345">		c = ieee80211_ht_adjust_channel(ic, ic-&gt;ic_curchan,</a>
<a name="ln2346">		    vap-&gt;iv_flags_ht);</a>
<a name="ln2347">		c = ieee80211_vht_adjust_channel(ic, c, vap-&gt;iv_flags_vht);</a>
<a name="ln2348">		frm = ieee80211_add_vhtcap_ch(frm, vap, c);</a>
<a name="ln2349">	}</a>
<a name="ln2350">#endif</a>
<a name="ln2351"> </a>
<a name="ln2352">	frm = ieee80211_add_wpa(frm, vap);</a>
<a name="ln2353">	if (vap-&gt;iv_appie_probereq != NULL)</a>
<a name="ln2354">		frm = add_appie(frm, vap-&gt;iv_appie_probereq);</a>
<a name="ln2355">	m-&gt;m_pkthdr.len = m-&gt;m_len = frm - mtod(m, uint8_t *);</a>
<a name="ln2356"> </a>
<a name="ln2357">	KASSERT(M_LEADINGSPACE(m) &gt;= sizeof(struct ieee80211_frame),</a>
<a name="ln2358">	    (&quot;leading space %zd&quot;, M_LEADINGSPACE(m)));</a>
<a name="ln2359">	M_PREPEND(m, sizeof(struct ieee80211_frame), M_NOWAIT);</a>
<a name="ln2360">	if (m == NULL) {</a>
<a name="ln2361">		/* NB: cannot happen */</a>
<a name="ln2362">		ieee80211_free_node(ni);</a>
<a name="ln2363">		ieee80211_free_node(bss);</a>
<a name="ln2364">		return ENOMEM;</a>
<a name="ln2365">	}</a>
<a name="ln2366"> </a>
<a name="ln2367">	IEEE80211_TX_LOCK(ic);</a>
<a name="ln2368">	ieee80211_send_setup(ni, m,</a>
<a name="ln2369">	     IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_REQ,</a>
<a name="ln2370">	     IEEE80211_NONQOS_TID, sa, da, bssid);</a>
<a name="ln2371">	/* XXX power management? */</a>
<a name="ln2372">	m-&gt;m_flags |= M_ENCAP;		/* mark encapsulated */</a>
<a name="ln2373"> </a>
<a name="ln2374">	M_WME_SETAC(m, WME_AC_BE);</a>
<a name="ln2375"> </a>
<a name="ln2376">	IEEE80211_NODE_STAT(ni, tx_probereq);</a>
<a name="ln2377">	IEEE80211_NODE_STAT(ni, tx_mgmt);</a>
<a name="ln2378"> </a>
<a name="ln2379">	IEEE80211_DPRINTF(vap, IEEE80211_MSG_DEBUG | IEEE80211_MSG_DUMPPKTS,</a>
<a name="ln2380">	    &quot;send probe req on channel %u bssid %s sa %6D da %6D ssid \&quot;%.*s\&quot;\n&quot;,</a>
<a name="ln2381">	    ieee80211_chan2ieee(ic, ic-&gt;ic_curchan),</a>
<a name="ln2382">	    ether_sprintf(bssid),</a>
<a name="ln2383">	    sa, &quot;:&quot;,</a>
<a name="ln2384">	    da, &quot;:&quot;,</a>
<a name="ln2385">	    ssidlen, ssid);</a>
<a name="ln2386"> </a>
<a name="ln2387">	memset(&amp;params, 0, sizeof(params));</a>
<a name="ln2388">	params.ibp_pri = M_WME_GETAC(m);</a>
<a name="ln2389">	tp = &amp;vap-&gt;iv_txparms[ieee80211_chan2mode(ic-&gt;ic_curchan)];</a>
<a name="ln2390">	params.ibp_rate0 = tp-&gt;mgmtrate;</a>
<a name="ln2391">	if (IEEE80211_IS_MULTICAST(da)) {</a>
<a name="ln2392">		params.ibp_flags |= IEEE80211_BPF_NOACK;</a>
<a name="ln2393">		params.ibp_try0 = 1;</a>
<a name="ln2394">	} else</a>
<a name="ln2395">		params.ibp_try0 = tp-&gt;maxretry;</a>
<a name="ln2396">	params.ibp_power = ni-&gt;ni_txpower;</a>
<a name="ln2397">	ret = ieee80211_raw_output(vap, ni, m, &amp;params);</a>
<a name="ln2398">	IEEE80211_TX_UNLOCK(ic);</a>
<a name="ln2399">	ieee80211_free_node(bss);</a>
<a name="ln2400">	return (ret);</a>
<a name="ln2401">}</a>
<a name="ln2402"> </a>
<a name="ln2403">/*</a>
<a name="ln2404"> * Calculate capability information for mgt frames.</a>
<a name="ln2405"> */</a>
<a name="ln2406">uint16_t</a>
<a name="ln2407">ieee80211_getcapinfo(struct ieee80211vap *vap, struct ieee80211_channel *chan)</a>
<a name="ln2408">{</a>
<a name="ln2409">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2410">	uint16_t capinfo;</a>
<a name="ln2411"> </a>
<a name="ln2412">	KASSERT(vap-&gt;iv_opmode != IEEE80211_M_STA, (&quot;station mode&quot;));</a>
<a name="ln2413"> </a>
<a name="ln2414">	if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP)</a>
<a name="ln2415">		capinfo = IEEE80211_CAPINFO_ESS;</a>
<a name="ln2416">	else if (vap-&gt;iv_opmode == IEEE80211_M_IBSS)</a>
<a name="ln2417">		capinfo = IEEE80211_CAPINFO_IBSS;</a>
<a name="ln2418">	else</a>
<a name="ln2419">		capinfo = 0;</a>
<a name="ln2420">	if (vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY)</a>
<a name="ln2421">		capinfo |= IEEE80211_CAPINFO_PRIVACY;</a>
<a name="ln2422">	if ((ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE) &amp;&amp;</a>
<a name="ln2423">	    IEEE80211_IS_CHAN_2GHZ(chan))</a>
<a name="ln2424">		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;</a>
<a name="ln2425">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT)</a>
<a name="ln2426">		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;</a>
<a name="ln2427">	if (IEEE80211_IS_CHAN_5GHZ(chan) &amp;&amp; (vap-&gt;iv_flags &amp; IEEE80211_F_DOTH))</a>
<a name="ln2428">		capinfo |= IEEE80211_CAPINFO_SPECTRUM_MGMT;</a>
<a name="ln2429">	return capinfo;</a>
<a name="ln2430">}</a>
<a name="ln2431"> </a>
<a name="ln2432">/*</a>
<a name="ln2433"> * Send a management frame.  The node is for the destination (or ic_bss</a>
<a name="ln2434"> * when in station mode).  Nodes other than ic_bss have their reference</a>
<a name="ln2435"> * count bumped to reflect our use for an indeterminant time.</a>
<a name="ln2436"> */</a>
<a name="ln2437">int</a>
<a name="ln2438">ieee80211_send_mgmt(struct ieee80211_node *ni, int type, int arg)</a>
<a name="ln2439">{</a>
<a name="ln2440">#define	HTFLAGS (IEEE80211_NODE_HT | IEEE80211_NODE_HTCOMPAT)</a>
<a name="ln2441">#define	senderr(_x, _v)	do { vap-&gt;iv_stats._v++; ret = _x; goto bad; } while (0)</a>
<a name="ln2442">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln2443">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln2444">	struct ieee80211_node *bss = vap-&gt;iv_bss;</a>
<a name="ln2445">	struct ieee80211_bpf_params params;</a>
<a name="ln2446">	struct mbuf *m;</a>
<a name="ln2447">	uint8_t *frm;</a>
<a name="ln2448">	uint16_t capinfo;</a>
<a name="ln2449">	int has_challenge, is_shared_key, ret, status;</a>
<a name="ln2450"> </a>
<a name="ln2451">	KASSERT(ni != NULL, (&quot;null node&quot;));</a>
<a name="ln2452"> </a>
<a name="ln2453">	/*</a>
<a name="ln2454">	 * Hold a reference on the node so it doesn't go away until after</a>
<a name="ln2455">	 * the xmit is complete all the way in the driver.  On error we</a>
<a name="ln2456">	 * will remove our reference.</a>
<a name="ln2457">	 */</a>
<a name="ln2458">	IEEE80211_DPRINTF(vap, IEEE80211_MSG_NODE,</a>
<a name="ln2459">		&quot;ieee80211_ref_node (%s:%u) %p&lt;%s&gt; refcnt %d\n&quot;,</a>
<a name="ln2460">		__func__, __LINE__,</a>
<a name="ln2461">		ni, ether_sprintf(ni-&gt;ni_macaddr),</a>
<a name="ln2462">		ieee80211_node_refcnt(ni)+1);</a>
<a name="ln2463">	ieee80211_ref_node(ni);</a>
<a name="ln2464"> </a>
<a name="ln2465">	memset(&amp;params, 0, sizeof(params));</a>
<a name="ln2466">	switch (type) {</a>
<a name="ln2467"> </a>
<a name="ln2468">	case IEEE80211_FC0_SUBTYPE_AUTH:</a>
<a name="ln2469">		status = arg &gt;&gt; 16;</a>
<a name="ln2470">		arg &amp;= 0xffff;</a>
<a name="ln2471">		has_challenge = ((arg == IEEE80211_AUTH_SHARED_CHALLENGE ||</a>
<a name="ln2472">		    arg == IEEE80211_AUTH_SHARED_RESPONSE) &amp;&amp;</a>
<a name="ln2473">		    ni-&gt;ni_challenge != NULL);</a>
<a name="ln2474"> </a>
<a name="ln2475">		/*</a>
<a name="ln2476">		 * Deduce whether we're doing open authentication or</a>
<a name="ln2477">		 * shared key authentication.  We do the latter if</a>
<a name="ln2478">		 * we're in the middle of a shared key authentication</a>
<a name="ln2479">		 * handshake or if we're initiating an authentication</a>
<a name="ln2480">		 * request and configured to use shared key.</a>
<a name="ln2481">		 */</a>
<a name="ln2482">		is_shared_key = has_challenge ||</a>
<a name="ln2483">		     arg &gt;= IEEE80211_AUTH_SHARED_RESPONSE ||</a>
<a name="ln2484">		     (arg == IEEE80211_AUTH_SHARED_REQUEST &amp;&amp;</a>
<a name="ln2485">		      bss-&gt;ni_authmode == IEEE80211_AUTH_SHARED);</a>
<a name="ln2486"> </a>
<a name="ln2487">		m = ieee80211_getmgtframe(&amp;frm,</a>
<a name="ln2488">			  ic-&gt;ic_headroom + sizeof(struct ieee80211_frame),</a>
<a name="ln2489">			  3 * sizeof(uint16_t)</a>
<a name="ln2490">			+ (has_challenge &amp;&amp; status == IEEE80211_STATUS_SUCCESS ?</a>
<a name="ln2491">				sizeof(uint16_t)+IEEE80211_CHALLENGE_LEN : 0)</a>
<a name="ln2492">		);</a>
<a name="ln2493">		if (m == NULL)</a>
<a name="ln2494">			senderr(ENOMEM, is_tx_nobuf);</a>
<a name="ln2495"> </a>
<a name="ln2496">		((uint16_t *)frm)[0] =</a>
<a name="ln2497">		    (is_shared_key) ? htole16(IEEE80211_AUTH_ALG_SHARED)</a>
<a name="ln2498">		                    : htole16(IEEE80211_AUTH_ALG_OPEN);</a>
<a name="ln2499">		((uint16_t *)frm)[1] = htole16(arg);	/* sequence number */</a>
<a name="ln2500">		((uint16_t *)frm)[2] = htole16(status);/* status */</a>
<a name="ln2501"> </a>
<a name="ln2502">		if (has_challenge &amp;&amp; status == IEEE80211_STATUS_SUCCESS) {</a>
<a name="ln2503">			((uint16_t *)frm)[3] =</a>
<a name="ln2504">			    htole16((IEEE80211_CHALLENGE_LEN &lt;&lt; 8) |</a>
<a name="ln2505">			    IEEE80211_ELEMID_CHALLENGE);</a>
<a name="ln2506">			memcpy(&amp;((uint16_t *)frm)[4], ni-&gt;ni_challenge,</a>
<a name="ln2507">			    IEEE80211_CHALLENGE_LEN);</a>
<a name="ln2508">			m-&gt;m_pkthdr.len = m-&gt;m_len =</a>
<a name="ln2509">				4 * sizeof(uint16_t) + IEEE80211_CHALLENGE_LEN;</a>
<a name="ln2510">			if (arg == IEEE80211_AUTH_SHARED_RESPONSE) {</a>
<a name="ln2511">				IEEE80211_NOTE(vap, IEEE80211_MSG_AUTH, ni,</a>
<a name="ln2512">				    &quot;request encrypt frame (%s)&quot;, __func__);</a>
<a name="ln2513">				/* mark frame for encryption */</a>
<a name="ln2514">				params.ibp_flags |= IEEE80211_BPF_CRYPTO;</a>
<a name="ln2515">			}</a>
<a name="ln2516">		} else</a>
<a name="ln2517">			m-&gt;m_pkthdr.len = m-&gt;m_len = 3 * sizeof(uint16_t);</a>
<a name="ln2518"> </a>
<a name="ln2519">		/* XXX not right for shared key */</a>
<a name="ln2520">		if (status == IEEE80211_STATUS_SUCCESS)</a>
<a name="ln2521">			IEEE80211_NODE_STAT(ni, tx_auth);</a>
<a name="ln2522">		else</a>
<a name="ln2523">			IEEE80211_NODE_STAT(ni, tx_auth_fail);</a>
<a name="ln2524"> </a>
<a name="ln2525">		if (vap-&gt;iv_opmode == IEEE80211_M_STA)</a>
<a name="ln2526">			ieee80211_add_callback(m, ieee80211_tx_mgt_cb,</a>
<a name="ln2527">				(void *) vap-&gt;iv_state);</a>
<a name="ln2528">		break;</a>
<a name="ln2529"> </a>
<a name="ln2530">	case IEEE80211_FC0_SUBTYPE_DEAUTH:</a>
<a name="ln2531">		IEEE80211_NOTE(vap, IEEE80211_MSG_AUTH, ni,</a>
<a name="ln2532">		    &quot;send station deauthenticate (reason: %d (%s))&quot;, arg,</a>
<a name="ln2533">		    ieee80211_reason_to_string(arg));</a>
<a name="ln2534">		m = ieee80211_getmgtframe(&amp;frm,</a>
<a name="ln2535">			ic-&gt;ic_headroom + sizeof(struct ieee80211_frame),</a>
<a name="ln2536">			sizeof(uint16_t));</a>
<a name="ln2537">		if (m == NULL)</a>
<a name="ln2538">			senderr(ENOMEM, is_tx_nobuf);</a>
<a name="ln2539">		*(uint16_t *)frm = htole16(arg);	/* reason */</a>
<a name="ln2540">		m-&gt;m_pkthdr.len = m-&gt;m_len = sizeof(uint16_t);</a>
<a name="ln2541"> </a>
<a name="ln2542">		IEEE80211_NODE_STAT(ni, tx_deauth);</a>
<a name="ln2543">		IEEE80211_NODE_STAT_SET(ni, tx_deauth_code, arg);</a>
<a name="ln2544"> </a>
<a name="ln2545">		ieee80211_node_unauthorize(ni);		/* port closed */</a>
<a name="ln2546">		break;</a>
<a name="ln2547"> </a>
<a name="ln2548">	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:</a>
<a name="ln2549">	case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:</a>
<a name="ln2550">		/*</a>
<a name="ln2551">		 * asreq frame format</a>
<a name="ln2552">		 *	[2] capability information</a>
<a name="ln2553">		 *	[2] listen interval</a>
<a name="ln2554">		 *	[6*] current AP address (reassoc only)</a>
<a name="ln2555">		 *	[tlv] ssid</a>
<a name="ln2556">		 *	[tlv] supported rates</a>
<a name="ln2557">		 *	[tlv] extended supported rates</a>
<a name="ln2558">		 *	[4] power capability (optional)</a>
<a name="ln2559">		 *	[28] supported channels (optional)</a>
<a name="ln2560">		 *	[tlv] HT capabilities</a>
<a name="ln2561">		 *	[tlv] VHT capabilities</a>
<a name="ln2562">		 *	[tlv] WME (optional)</a>
<a name="ln2563">		 *	[tlv] Vendor OUI HT capabilities (optional)</a>
<a name="ln2564">		 *	[tlv] Atheros capabilities (if negotiated)</a>
<a name="ln2565">		 *	[tlv] AppIE's (optional)</a>
<a name="ln2566">		 */</a>
<a name="ln2567">		m = ieee80211_getmgtframe(&amp;frm,</a>
<a name="ln2568">			 ic-&gt;ic_headroom + sizeof(struct ieee80211_frame),</a>
<a name="ln2569">			 sizeof(uint16_t)</a>
<a name="ln2570">		       + sizeof(uint16_t)</a>
<a name="ln2571">		       + IEEE80211_ADDR_LEN</a>
<a name="ln2572">		       + 2 + IEEE80211_NWID_LEN</a>
<a name="ln2573">		       + 2 + IEEE80211_RATE_SIZE</a>
<a name="ln2574">		       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE)</a>
<a name="ln2575">		       + 4</a>
<a name="ln2576">		       + 2 + 26</a>
<a name="ln2577">		       + sizeof(struct ieee80211_wme_info)</a>
<a name="ln2578">		       + sizeof(struct ieee80211_ie_htcap)</a>
<a name="ln2579">		       + sizeof(struct ieee80211_ie_vhtcap)</a>
<a name="ln2580">		       + 4 + sizeof(struct ieee80211_ie_htcap)</a>
<a name="ln2581">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2582">		       + sizeof(struct ieee80211_ath_ie)</a>
<a name="ln2583">#endif</a>
<a name="ln2584">		       + (vap-&gt;iv_appie_wpa != NULL ?</a>
<a name="ln2585">				vap-&gt;iv_appie_wpa-&gt;ie_len : 0)</a>
<a name="ln2586">		       + (vap-&gt;iv_appie_assocreq != NULL ?</a>
<a name="ln2587">				vap-&gt;iv_appie_assocreq-&gt;ie_len : 0)</a>
<a name="ln2588">		);</a>
<a name="ln2589">		if (m == NULL)</a>
<a name="ln2590">			senderr(ENOMEM, is_tx_nobuf);</a>
<a name="ln2591"> </a>
<a name="ln2592">		KASSERT(vap-&gt;iv_opmode == IEEE80211_M_STA,</a>
<a name="ln2593">		    (&quot;wrong mode %u&quot;, vap-&gt;iv_opmode));</a>
<a name="ln2594">		capinfo = IEEE80211_CAPINFO_ESS;</a>
<a name="ln2595">		if (vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY)</a>
<a name="ln2596">			capinfo |= IEEE80211_CAPINFO_PRIVACY;</a>
<a name="ln2597">		/*</a>
<a name="ln2598">		 * NB: Some 11a AP's reject the request when</a>
<a name="ln2599">		 *     short preamble is set.</a>
<a name="ln2600">		 */</a>
<a name="ln2601">		if ((ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE) &amp;&amp;</a>
<a name="ln2602">		    IEEE80211_IS_CHAN_2GHZ(ic-&gt;ic_curchan))</a>
<a name="ln2603">			capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;</a>
<a name="ln2604">		if (IEEE80211_IS_CHAN_ANYG(ic-&gt;ic_curchan) &amp;&amp;</a>
<a name="ln2605">		    (ic-&gt;ic_caps &amp; IEEE80211_C_SHSLOT))</a>
<a name="ln2606">			capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;</a>
<a name="ln2607">		if ((ni-&gt;ni_capinfo &amp; IEEE80211_CAPINFO_SPECTRUM_MGMT) &amp;&amp;</a>
<a name="ln2608">		    (vap-&gt;iv_flags &amp; IEEE80211_F_DOTH))</a>
<a name="ln2609">			capinfo |= IEEE80211_CAPINFO_SPECTRUM_MGMT;</a>
<a name="ln2610">		*(uint16_t *)frm = htole16(capinfo);</a>
<a name="ln2611">		frm += 2;</a>
<a name="ln2612"> </a>
<a name="ln2613">		KASSERT(bss-&gt;ni_intval != 0, (&quot;beacon interval is zero!&quot;));</a>
<a name="ln2614">		*(uint16_t *)frm = htole16(howmany(ic-&gt;ic_lintval,</a>
<a name="ln2615">						    bss-&gt;ni_intval));</a>
<a name="ln2616">		frm += 2;</a>
<a name="ln2617"> </a>
<a name="ln2618">		if (type == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) {</a>
<a name="ln2619">			IEEE80211_ADDR_COPY(frm, bss-&gt;ni_bssid);</a>
<a name="ln2620">			frm += IEEE80211_ADDR_LEN;</a>
<a name="ln2621">		}</a>
<a name="ln2622"> </a>
<a name="ln2623">		frm = ieee80211_add_ssid(frm, ni-&gt;ni_essid, ni-&gt;ni_esslen);</a>
<a name="ln2624">		frm = ieee80211_add_rates(frm, &amp;ni-&gt;ni_rates);</a>
<a name="ln2625">		frm = ieee80211_add_rsn(frm, vap);</a>
<a name="ln2626">		frm = ieee80211_add_xrates(frm, &amp;ni-&gt;ni_rates);</a>
<a name="ln2627">		if (capinfo &amp; IEEE80211_CAPINFO_SPECTRUM_MGMT) {</a>
<a name="ln2628">			frm = ieee80211_add_powercapability(frm,</a>
<a name="ln2629">			    ic-&gt;ic_curchan);</a>
<a name="ln2630">			frm = ieee80211_add_supportedchannels(frm, ic);</a>
<a name="ln2631">		}</a>
<a name="ln2632"> </a>
<a name="ln2633">		/*</a>
<a name="ln2634">		 * Check the channel - we may be using an 11n NIC with an</a>
<a name="ln2635">		 * 11n capable station, but we're configured to be an 11b</a>
<a name="ln2636">		 * channel.</a>
<a name="ln2637">		 */</a>
<a name="ln2638">		if ((vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HT) &amp;&amp;</a>
<a name="ln2639">		    IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan) &amp;&amp;</a>
<a name="ln2640">		    ni-&gt;ni_ies.htcap_ie != NULL &amp;&amp;</a>
<a name="ln2641">		    ni-&gt;ni_ies.htcap_ie[0] == IEEE80211_ELEMID_HTCAP) {</a>
<a name="ln2642">			frm = ieee80211_add_htcap(frm, ni);</a>
<a name="ln2643">		}</a>
<a name="ln2644"> </a>
<a name="ln2645">		if ((vap-&gt;iv_flags_vht &amp; IEEE80211_FVHT_VHT) &amp;&amp;</a>
<a name="ln2646">		    IEEE80211_IS_CHAN_VHT(ni-&gt;ni_chan) &amp;&amp;</a>
<a name="ln2647">		    ni-&gt;ni_ies.vhtcap_ie != NULL &amp;&amp;</a>
<a name="ln2648">		    ni-&gt;ni_ies.vhtcap_ie[0] == IEEE80211_ELEMID_VHT_CAP) {</a>
<a name="ln2649">			frm = ieee80211_add_vhtcap(frm, ni);</a>
<a name="ln2650">		}</a>
<a name="ln2651"> </a>
<a name="ln2652">		frm = ieee80211_add_wpa(frm, vap);</a>
<a name="ln2653">		if ((ic-&gt;ic_flags &amp; IEEE80211_F_WME) &amp;&amp;</a>
<a name="ln2654">		    ni-&gt;ni_ies.wme_ie != NULL)</a>
<a name="ln2655">			frm = ieee80211_add_wme_info(frm, &amp;ic-&gt;ic_wme);</a>
<a name="ln2656"> </a>
<a name="ln2657">		/*</a>
<a name="ln2658">		 * Same deal - only send HT info if we're on an 11n</a>
<a name="ln2659">		 * capable channel.</a>
<a name="ln2660">		 */</a>
<a name="ln2661">		if ((vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HT) &amp;&amp;</a>
<a name="ln2662">		    IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan) &amp;&amp;</a>
<a name="ln2663">		    ni-&gt;ni_ies.htcap_ie != NULL &amp;&amp;</a>
<a name="ln2664">		    ni-&gt;ni_ies.htcap_ie[0] == IEEE80211_ELEMID_VENDOR) {</a>
<a name="ln2665">			frm = ieee80211_add_htcap_vendor(frm, ni);</a>
<a name="ln2666">		}</a>
<a name="ln2667">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2668">		if (IEEE80211_ATH_CAP(vap, ni, IEEE80211_F_ATHEROS)) {</a>
<a name="ln2669">			frm = ieee80211_add_ath(frm,</a>
<a name="ln2670">				IEEE80211_ATH_CAP(vap, ni, IEEE80211_F_ATHEROS),</a>
<a name="ln2671">				((vap-&gt;iv_flags &amp; IEEE80211_F_WPA) == 0 &amp;&amp;</a>
<a name="ln2672">				 ni-&gt;ni_authmode != IEEE80211_AUTH_8021X) ?</a>
<a name="ln2673">				vap-&gt;iv_def_txkey : IEEE80211_KEYIX_NONE);</a>
<a name="ln2674">		}</a>
<a name="ln2675">#endif /* IEEE80211_SUPPORT_SUPERG */</a>
<a name="ln2676">		if (vap-&gt;iv_appie_assocreq != NULL)</a>
<a name="ln2677">			frm = add_appie(frm, vap-&gt;iv_appie_assocreq);</a>
<a name="ln2678">		m-&gt;m_pkthdr.len = m-&gt;m_len = frm - mtod(m, uint8_t *);</a>
<a name="ln2679"> </a>
<a name="ln2680">		ieee80211_add_callback(m, ieee80211_tx_mgt_cb,</a>
<a name="ln2681">			(void *) vap-&gt;iv_state);</a>
<a name="ln2682">		break;</a>
<a name="ln2683"> </a>
<a name="ln2684">	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:</a>
<a name="ln2685">	case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:</a>
<a name="ln2686">		/*</a>
<a name="ln2687">		 * asresp frame format</a>
<a name="ln2688">		 *	[2] capability information</a>
<a name="ln2689">		 *	[2] status</a>
<a name="ln2690">		 *	[2] association ID</a>
<a name="ln2691">		 *	[tlv] supported rates</a>
<a name="ln2692">		 *	[tlv] extended supported rates</a>
<a name="ln2693">		 *	[tlv] HT capabilities (standard, if STA enabled)</a>
<a name="ln2694">		 *	[tlv] HT information (standard, if STA enabled)</a>
<a name="ln2695">		 *	[tlv] VHT capabilities (standard, if STA enabled)</a>
<a name="ln2696">		 *	[tlv] VHT information (standard, if STA enabled)</a>
<a name="ln2697">		 *	[tlv] WME (if configured and STA enabled)</a>
<a name="ln2698">		 *	[tlv] HT capabilities (vendor OUI, if STA enabled)</a>
<a name="ln2699">		 *	[tlv] HT information (vendor OUI, if STA enabled)</a>
<a name="ln2700">		 *	[tlv] Atheros capabilities (if STA enabled)</a>
<a name="ln2701">		 *	[tlv] AppIE's (optional)</a>
<a name="ln2702">		 */</a>
<a name="ln2703">		m = ieee80211_getmgtframe(&amp;frm,</a>
<a name="ln2704">			 ic-&gt;ic_headroom + sizeof(struct ieee80211_frame),</a>
<a name="ln2705">			 sizeof(uint16_t)</a>
<a name="ln2706">		       + sizeof(uint16_t)</a>
<a name="ln2707">		       + sizeof(uint16_t)</a>
<a name="ln2708">		       + 2 + IEEE80211_RATE_SIZE</a>
<a name="ln2709">		       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE)</a>
<a name="ln2710">		       + sizeof(struct ieee80211_ie_htcap) + 4</a>
<a name="ln2711">		       + sizeof(struct ieee80211_ie_htinfo) + 4</a>
<a name="ln2712">		       + sizeof(struct ieee80211_ie_vhtcap)</a>
<a name="ln2713">		       + sizeof(struct ieee80211_ie_vht_operation)</a>
<a name="ln2714">		       + sizeof(struct ieee80211_wme_param)</a>
<a name="ln2715">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2716">		       + sizeof(struct ieee80211_ath_ie)</a>
<a name="ln2717">#endif</a>
<a name="ln2718">		       + (vap-&gt;iv_appie_assocresp != NULL ?</a>
<a name="ln2719">				vap-&gt;iv_appie_assocresp-&gt;ie_len : 0)</a>
<a name="ln2720">		);</a>
<a name="ln2721">		if (m == NULL)</a>
<a name="ln2722">			senderr(ENOMEM, is_tx_nobuf);</a>
<a name="ln2723"> </a>
<a name="ln2724">		capinfo = ieee80211_getcapinfo(vap, bss-&gt;ni_chan);</a>
<a name="ln2725">		*(uint16_t *)frm = htole16(capinfo);</a>
<a name="ln2726">		frm += 2;</a>
<a name="ln2727"> </a>
<a name="ln2728">		*(uint16_t *)frm = htole16(arg);	/* status */</a>
<a name="ln2729">		frm += 2;</a>
<a name="ln2730"> </a>
<a name="ln2731">		if (arg == IEEE80211_STATUS_SUCCESS) {</a>
<a name="ln2732">			*(uint16_t *)frm = htole16(ni-&gt;ni_associd);</a>
<a name="ln2733">			IEEE80211_NODE_STAT(ni, tx_assoc);</a>
<a name="ln2734">		} else</a>
<a name="ln2735">			IEEE80211_NODE_STAT(ni, tx_assoc_fail);</a>
<a name="ln2736">		frm += 2;</a>
<a name="ln2737"> </a>
<a name="ln2738">		frm = ieee80211_add_rates(frm, &amp;ni-&gt;ni_rates);</a>
<a name="ln2739">		frm = ieee80211_add_xrates(frm, &amp;ni-&gt;ni_rates);</a>
<a name="ln2740">		/* NB: respond according to what we received */</a>
<a name="ln2741">		if ((ni-&gt;ni_flags &amp; HTFLAGS) == IEEE80211_NODE_HT) {</a>
<a name="ln2742">			frm = ieee80211_add_htcap(frm, ni);</a>
<a name="ln2743">			frm = ieee80211_add_htinfo(frm, ni);</a>
<a name="ln2744">		}</a>
<a name="ln2745">		if ((vap-&gt;iv_flags &amp; IEEE80211_F_WME) &amp;&amp;</a>
<a name="ln2746">		    ni-&gt;ni_ies.wme_ie != NULL)</a>
<a name="ln2747">			frm = ieee80211_add_wme_param(frm, &amp;ic-&gt;ic_wme);</a>
<a name="ln2748">		if ((ni-&gt;ni_flags &amp; HTFLAGS) == HTFLAGS) {</a>
<a name="ln2749">			frm = ieee80211_add_htcap_vendor(frm, ni);</a>
<a name="ln2750">			frm = ieee80211_add_htinfo_vendor(frm, ni);</a>
<a name="ln2751">		}</a>
<a name="ln2752">		if (ni-&gt;ni_flags &amp; IEEE80211_NODE_VHT) {</a>
<a name="ln2753">			frm = ieee80211_add_vhtcap(frm, ni);</a>
<a name="ln2754">			frm = ieee80211_add_vhtinfo(frm, ni);</a>
<a name="ln2755">		}</a>
<a name="ln2756">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2757">		if (IEEE80211_ATH_CAP(vap, ni, IEEE80211_F_ATHEROS))</a>
<a name="ln2758">			frm = ieee80211_add_ath(frm,</a>
<a name="ln2759">				IEEE80211_ATH_CAP(vap, ni, IEEE80211_F_ATHEROS),</a>
<a name="ln2760">				((vap-&gt;iv_flags &amp; IEEE80211_F_WPA) == 0 &amp;&amp;</a>
<a name="ln2761">				 ni-&gt;ni_authmode != IEEE80211_AUTH_8021X) ?</a>
<a name="ln2762">				vap-&gt;iv_def_txkey : IEEE80211_KEYIX_NONE);</a>
<a name="ln2763">#endif /* IEEE80211_SUPPORT_SUPERG */</a>
<a name="ln2764">		if (vap-&gt;iv_appie_assocresp != NULL)</a>
<a name="ln2765">			frm = add_appie(frm, vap-&gt;iv_appie_assocresp);</a>
<a name="ln2766">		m-&gt;m_pkthdr.len = m-&gt;m_len = frm - mtod(m, uint8_t *);</a>
<a name="ln2767">		break;</a>
<a name="ln2768"> </a>
<a name="ln2769">	case IEEE80211_FC0_SUBTYPE_DISASSOC:</a>
<a name="ln2770">		IEEE80211_NOTE(vap, IEEE80211_MSG_ASSOC, ni,</a>
<a name="ln2771">		    &quot;send station disassociate (reason: %d (%s))&quot;, arg,</a>
<a name="ln2772">		    ieee80211_reason_to_string(arg));</a>
<a name="ln2773">		m = ieee80211_getmgtframe(&amp;frm,</a>
<a name="ln2774">			ic-&gt;ic_headroom + sizeof(struct ieee80211_frame),</a>
<a name="ln2775">			sizeof(uint16_t));</a>
<a name="ln2776">		if (m == NULL)</a>
<a name="ln2777">			senderr(ENOMEM, is_tx_nobuf);</a>
<a name="ln2778">		*(uint16_t *)frm = htole16(arg);	/* reason */</a>
<a name="ln2779">		m-&gt;m_pkthdr.len = m-&gt;m_len = sizeof(uint16_t);</a>
<a name="ln2780"> </a>
<a name="ln2781">		IEEE80211_NODE_STAT(ni, tx_disassoc);</a>
<a name="ln2782">		IEEE80211_NODE_STAT_SET(ni, tx_disassoc_code, arg);</a>
<a name="ln2783">		break;</a>
<a name="ln2784"> </a>
<a name="ln2785">	default:</a>
<a name="ln2786">		IEEE80211_NOTE(vap, IEEE80211_MSG_ANY, ni,</a>
<a name="ln2787">		    &quot;invalid mgmt frame type %u&quot;, type);</a>
<a name="ln2788">		senderr(EINVAL, is_tx_unknownmgt);</a>
<a name="ln2789">		/* NOTREACHED */</a>
<a name="ln2790">	}</a>
<a name="ln2791"> </a>
<a name="ln2792">	/* NB: force non-ProbeResp frames to the highest queue */</a>
<a name="ln2793">	params.ibp_pri = WME_AC_VO;</a>
<a name="ln2794">	params.ibp_rate0 = bss-&gt;ni_txparms-&gt;mgmtrate;</a>
<a name="ln2795">	/* NB: we know all frames are unicast */</a>
<a name="ln2796">	params.ibp_try0 = bss-&gt;ni_txparms-&gt;maxretry;</a>
<a name="ln2797">	params.ibp_power = bss-&gt;ni_txpower;</a>
<a name="ln2798">	return ieee80211_mgmt_output(ni, m, type, &amp;params);</a>
<a name="ln2799">bad:</a>
<a name="ln2800">	ieee80211_free_node(ni);</a>
<a name="ln2801">	return ret;</a>
<a name="ln2802">#undef senderr</a>
<a name="ln2803">#undef HTFLAGS</a>
<a name="ln2804">}</a>
<a name="ln2805"> </a>
<a name="ln2806">/*</a>
<a name="ln2807"> * Return an mbuf with a probe response frame in it.</a>
<a name="ln2808"> * Space is left to prepend and 802.11 header at the</a>
<a name="ln2809"> * front but it's left to the caller to fill in.</a>
<a name="ln2810"> */</a>
<a name="ln2811">struct mbuf *</a>
<a name="ln2812">ieee80211_alloc_proberesp(struct ieee80211_node *bss, int legacy)</a>
<a name="ln2813">{</a>
<a name="ln2814">	struct ieee80211vap *vap = bss-&gt;ni_vap;</a>
<a name="ln2815">	struct ieee80211com *ic = bss-&gt;ni_ic;</a>
<a name="ln2816">	const struct ieee80211_rateset *rs;</a>
<a name="ln2817">	struct mbuf *m;</a>
<a name="ln2818">	uint16_t capinfo;</a>
<a name="ln2819">	uint8_t *frm;</a>
<a name="ln2820"> </a>
<a name="ln2821">	/*</a>
<a name="ln2822">	 * probe response frame format</a>
<a name="ln2823">	 *	[8] time stamp</a>
<a name="ln2824">	 *	[2] beacon interval</a>
<a name="ln2825">	 *	[2] cabability information</a>
<a name="ln2826">	 *	[tlv] ssid</a>
<a name="ln2827">	 *	[tlv] supported rates</a>
<a name="ln2828">	 *	[tlv] parameter set (FH/DS)</a>
<a name="ln2829">	 *	[tlv] parameter set (IBSS)</a>
<a name="ln2830">	 *	[tlv] country (optional)</a>
<a name="ln2831">	 *	[3] power control (optional)</a>
<a name="ln2832">	 *	[5] channel switch announcement (CSA) (optional)</a>
<a name="ln2833">	 *	[tlv] extended rate phy (ERP)</a>
<a name="ln2834">	 *	[tlv] extended supported rates</a>
<a name="ln2835">	 *	[tlv] RSN (optional)</a>
<a name="ln2836">	 *	[tlv] HT capabilities</a>
<a name="ln2837">	 *	[tlv] HT information</a>
<a name="ln2838">	 *	[tlv] VHT capabilities</a>
<a name="ln2839">	 *	[tlv] VHT information</a>
<a name="ln2840">	 *	[tlv] WPA (optional)</a>
<a name="ln2841">	 *	[tlv] WME (optional)</a>
<a name="ln2842">	 *	[tlv] Vendor OUI HT capabilities (optional)</a>
<a name="ln2843">	 *	[tlv] Vendor OUI HT information (optional)</a>
<a name="ln2844">	 *	[tlv] Atheros capabilities</a>
<a name="ln2845">	 *	[tlv] AppIE's (optional)</a>
<a name="ln2846">	 *	[tlv] Mesh ID (MBSS)</a>
<a name="ln2847">	 *	[tlv] Mesh Conf (MBSS)</a>
<a name="ln2848">	 */</a>
<a name="ln2849">	m = ieee80211_getmgtframe(&amp;frm,</a>
<a name="ln2850">		 ic-&gt;ic_headroom + sizeof(struct ieee80211_frame),</a>
<a name="ln2851">		 8</a>
<a name="ln2852">	       + sizeof(uint16_t)</a>
<a name="ln2853">	       + sizeof(uint16_t)</a>
<a name="ln2854">	       + 2 + IEEE80211_NWID_LEN</a>
<a name="ln2855">	       + 2 + IEEE80211_RATE_SIZE</a>
<a name="ln2856">	       + 7	/* max(7,3) */</a>
<a name="ln2857">	       + IEEE80211_COUNTRY_MAX_SIZE</a>
<a name="ln2858">	       + 3</a>
<a name="ln2859">	       + sizeof(struct ieee80211_csa_ie)</a>
<a name="ln2860">	       + sizeof(struct ieee80211_quiet_ie)</a>
<a name="ln2861">	       + 3</a>
<a name="ln2862">	       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE)</a>
<a name="ln2863">	       + sizeof(struct ieee80211_ie_wpa)</a>
<a name="ln2864">	       + sizeof(struct ieee80211_ie_htcap)</a>
<a name="ln2865">	       + sizeof(struct ieee80211_ie_htinfo)</a>
<a name="ln2866">	       + sizeof(struct ieee80211_ie_wpa)</a>
<a name="ln2867">	       + sizeof(struct ieee80211_wme_param)</a>
<a name="ln2868">	       + 4 + sizeof(struct ieee80211_ie_htcap)</a>
<a name="ln2869">	       + 4 + sizeof(struct ieee80211_ie_htinfo)</a>
<a name="ln2870">	       +  sizeof(struct ieee80211_ie_vhtcap)</a>
<a name="ln2871">	       +  sizeof(struct ieee80211_ie_vht_operation)</a>
<a name="ln2872">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2873">	       + sizeof(struct ieee80211_ath_ie)</a>
<a name="ln2874">#endif</a>
<a name="ln2875">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln2876">	       + 2 + IEEE80211_MESHID_LEN</a>
<a name="ln2877">	       + sizeof(struct ieee80211_meshconf_ie)</a>
<a name="ln2878">#endif</a>
<a name="ln2879">	       + (vap-&gt;iv_appie_proberesp != NULL ?</a>
<a name="ln2880">			vap-&gt;iv_appie_proberesp-&gt;ie_len : 0)</a>
<a name="ln2881">	);</a>
<a name="ln2882">	if (m == NULL) {</a>
<a name="ln2883">		vap-&gt;iv_stats.is_tx_nobuf++;</a>
<a name="ln2884">		return NULL;</a>
<a name="ln2885">	}</a>
<a name="ln2886"> </a>
<a name="ln2887">	memset(frm, 0, 8);	/* timestamp should be filled later */</a>
<a name="ln2888">	frm += 8;</a>
<a name="ln2889">	*(uint16_t *)frm = htole16(bss-&gt;ni_intval);</a>
<a name="ln2890">	frm += 2;</a>
<a name="ln2891">	capinfo = ieee80211_getcapinfo(vap, bss-&gt;ni_chan);</a>
<a name="ln2892">	*(uint16_t *)frm = htole16(capinfo);</a>
<a name="ln2893">	frm += 2;</a>
<a name="ln2894"> </a>
<a name="ln2895">	frm = ieee80211_add_ssid(frm, bss-&gt;ni_essid, bss-&gt;ni_esslen);</a>
<a name="ln2896">	rs = ieee80211_get_suprates(ic, bss-&gt;ni_chan);</a>
<a name="ln2897">	frm = ieee80211_add_rates(frm, rs);</a>
<a name="ln2898"> </a>
<a name="ln2899">	if (IEEE80211_IS_CHAN_FHSS(bss-&gt;ni_chan)) {</a>
<a name="ln2900">		*frm++ = IEEE80211_ELEMID_FHPARMS;</a>
<a name="ln2901">		*frm++ = 5;</a>
<a name="ln2902">		*frm++ = bss-&gt;ni_fhdwell &amp; 0x00ff;</a>
<a name="ln2903">		*frm++ = (bss-&gt;ni_fhdwell &gt;&gt; 8) &amp; 0x00ff;</a>
<a name="ln2904">		*frm++ = IEEE80211_FH_CHANSET(</a>
<a name="ln2905">		    ieee80211_chan2ieee(ic, bss-&gt;ni_chan));</a>
<a name="ln2906">		*frm++ = IEEE80211_FH_CHANPAT(</a>
<a name="ln2907">		    ieee80211_chan2ieee(ic, bss-&gt;ni_chan));</a>
<a name="ln2908">		*frm++ = bss-&gt;ni_fhindex;</a>
<a name="ln2909">	} else {</a>
<a name="ln2910">		*frm++ = IEEE80211_ELEMID_DSPARMS;</a>
<a name="ln2911">		*frm++ = 1;</a>
<a name="ln2912">		*frm++ = ieee80211_chan2ieee(ic, bss-&gt;ni_chan);</a>
<a name="ln2913">	}</a>
<a name="ln2914"> </a>
<a name="ln2915">	if (vap-&gt;iv_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln2916">		*frm++ = IEEE80211_ELEMID_IBSSPARMS;</a>
<a name="ln2917">		*frm++ = 2;</a>
<a name="ln2918">		*frm++ = 0; *frm++ = 0;		/* TODO: ATIM window */</a>
<a name="ln2919">	}</a>
<a name="ln2920">	if ((vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) ||</a>
<a name="ln2921">	    (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_DOTD))</a>
<a name="ln2922">		frm = ieee80211_add_countryie(frm, ic);</a>
<a name="ln2923">	if (vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) {</a>
<a name="ln2924">		if (IEEE80211_IS_CHAN_5GHZ(bss-&gt;ni_chan))</a>
<a name="ln2925">			frm = ieee80211_add_powerconstraint(frm, vap);</a>
<a name="ln2926">		if (ic-&gt;ic_flags &amp; IEEE80211_F_CSAPENDING)</a>
<a name="ln2927">			frm = ieee80211_add_csa(frm, vap);</a>
<a name="ln2928">	}</a>
<a name="ln2929">	if (vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) {</a>
<a name="ln2930">		if (IEEE80211_IS_CHAN_DFS(ic-&gt;ic_bsschan) &amp;&amp;</a>
<a name="ln2931">		    (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_DFS)) {</a>
<a name="ln2932">			if (vap-&gt;iv_quiet)</a>
<a name="ln2933">				frm = ieee80211_add_quiet(frm, vap, 0);</a>
<a name="ln2934">		}</a>
<a name="ln2935">	}</a>
<a name="ln2936">	if (IEEE80211_IS_CHAN_ANYG(bss-&gt;ni_chan))</a>
<a name="ln2937">		frm = ieee80211_add_erp(frm, ic);</a>
<a name="ln2938">	frm = ieee80211_add_xrates(frm, rs);</a>
<a name="ln2939">	frm = ieee80211_add_rsn(frm, vap);</a>
<a name="ln2940">	/*</a>
<a name="ln2941">	 * NB: legacy 11b clients do not get certain ie's.</a>
<a name="ln2942">	 *     The caller identifies such clients by passing</a>
<a name="ln2943">	 *     a token in legacy to us.  Could expand this to be</a>
<a name="ln2944">	 *     any legacy client for stuff like HT ie's.</a>
<a name="ln2945">	 */</a>
<a name="ln2946">	if (IEEE80211_IS_CHAN_HT(bss-&gt;ni_chan) &amp;&amp;</a>
<a name="ln2947">	    legacy != IEEE80211_SEND_LEGACY_11B) {</a>
<a name="ln2948">		frm = ieee80211_add_htcap(frm, bss);</a>
<a name="ln2949">		frm = ieee80211_add_htinfo(frm, bss);</a>
<a name="ln2950">	}</a>
<a name="ln2951">	if (IEEE80211_IS_CHAN_VHT(bss-&gt;ni_chan) &amp;&amp;</a>
<a name="ln2952">	    legacy != IEEE80211_SEND_LEGACY_11B) {</a>
<a name="ln2953">		frm = ieee80211_add_vhtcap(frm, bss);</a>
<a name="ln2954">		frm = ieee80211_add_vhtinfo(frm, bss);</a>
<a name="ln2955">	}</a>
<a name="ln2956">	frm = ieee80211_add_wpa(frm, vap);</a>
<a name="ln2957">	if (vap-&gt;iv_flags &amp; IEEE80211_F_WME)</a>
<a name="ln2958">		frm = ieee80211_add_wme_param(frm, &amp;ic-&gt;ic_wme);</a>
<a name="ln2959">	if (IEEE80211_IS_CHAN_HT(bss-&gt;ni_chan) &amp;&amp;</a>
<a name="ln2960">	    (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HTCOMPAT) &amp;&amp;</a>
<a name="ln2961">	    legacy != IEEE80211_SEND_LEGACY_11B) {</a>
<a name="ln2962">		frm = ieee80211_add_htcap_vendor(frm, bss);</a>
<a name="ln2963">		frm = ieee80211_add_htinfo_vendor(frm, bss);</a>
<a name="ln2964">	}</a>
<a name="ln2965">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2966">	if ((vap-&gt;iv_flags &amp; IEEE80211_F_ATHEROS) &amp;&amp;</a>
<a name="ln2967">	    legacy != IEEE80211_SEND_LEGACY_11B)</a>
<a name="ln2968">		frm = ieee80211_add_athcaps(frm, bss);</a>
<a name="ln2969">#endif</a>
<a name="ln2970">	if (vap-&gt;iv_appie_proberesp != NULL)</a>
<a name="ln2971">		frm = add_appie(frm, vap-&gt;iv_appie_proberesp);</a>
<a name="ln2972">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln2973">	if (vap-&gt;iv_opmode == IEEE80211_M_MBSS) {</a>
<a name="ln2974">		frm = ieee80211_add_meshid(frm, vap);</a>
<a name="ln2975">		frm = ieee80211_add_meshconf(frm, vap);</a>
<a name="ln2976">	}</a>
<a name="ln2977">#endif</a>
<a name="ln2978">	m-&gt;m_pkthdr.len = m-&gt;m_len = frm - mtod(m, uint8_t *);</a>
<a name="ln2979"> </a>
<a name="ln2980">	return m;</a>
<a name="ln2981">}</a>
<a name="ln2982"> </a>
<a name="ln2983">/*</a>
<a name="ln2984"> * Send a probe response frame to the specified mac address.</a>
<a name="ln2985"> * This does not go through the normal mgt frame api so we</a>
<a name="ln2986"> * can specify the destination address and re-use the bss node</a>
<a name="ln2987"> * for the sta reference.</a>
<a name="ln2988"> */</a>
<a name="ln2989">int</a>
<a name="ln2990">ieee80211_send_proberesp(struct ieee80211vap *vap,</a>
<a name="ln2991">	const uint8_t da[IEEE80211_ADDR_LEN], int legacy)</a>
<a name="ln2992">{</a>
<a name="ln2993">	struct ieee80211_node *bss = vap-&gt;iv_bss;</a>
<a name="ln2994">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2995">	struct mbuf *m;</a>
<a name="ln2996">	int ret;</a>
<a name="ln2997"> </a>
<a name="ln2998">	if (vap-&gt;iv_state == IEEE80211_S_CAC) {</a>
<a name="ln2999">		IEEE80211_NOTE(vap, IEEE80211_MSG_OUTPUT, bss,</a>
<a name="ln3000">		    &quot;block %s frame in CAC state&quot;, &quot;probe response&quot;);</a>
<a name="ln3001">		vap-&gt;iv_stats.is_tx_badstate++;</a>
<a name="ln3002">		return EIO;		/* XXX */</a>
<a name="ln3003">	}</a>
<a name="ln3004"> </a>
<a name="ln3005">	/*</a>
<a name="ln3006">	 * Hold a reference on the node so it doesn't go away until after</a>
<a name="ln3007">	 * the xmit is complete all the way in the driver.  On error we</a>
<a name="ln3008">	 * will remove our reference.</a>
<a name="ln3009">	 */</a>
<a name="ln3010">	IEEE80211_DPRINTF(vap, IEEE80211_MSG_NODE,</a>
<a name="ln3011">	    &quot;ieee80211_ref_node (%s:%u) %p&lt;%s&gt; refcnt %d\n&quot;,</a>
<a name="ln3012">	    __func__, __LINE__, bss, ether_sprintf(bss-&gt;ni_macaddr),</a>
<a name="ln3013">	    ieee80211_node_refcnt(bss)+1);</a>
<a name="ln3014">	ieee80211_ref_node(bss);</a>
<a name="ln3015"> </a>
<a name="ln3016">	m = ieee80211_alloc_proberesp(bss, legacy);</a>
<a name="ln3017">	if (m == NULL) {</a>
<a name="ln3018">		ieee80211_free_node(bss);</a>
<a name="ln3019">		return ENOMEM;</a>
<a name="ln3020">	}</a>
<a name="ln3021"> </a>
<a name="ln3022">	M_PREPEND(m, sizeof(struct ieee80211_frame), M_NOWAIT);</a>
<a name="ln3023">	KASSERT(m != NULL, (&quot;no room for header&quot;));</a>
<a name="ln3024"> </a>
<a name="ln3025">	IEEE80211_TX_LOCK(ic);</a>
<a name="ln3026">	ieee80211_send_setup(bss, m,</a>
<a name="ln3027">	     IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP,</a>
<a name="ln3028">	     IEEE80211_NONQOS_TID, vap-&gt;iv_myaddr, da, bss-&gt;ni_bssid);</a>
<a name="ln3029">	/* XXX power management? */</a>
<a name="ln3030">	m-&gt;m_flags |= M_ENCAP;		/* mark encapsulated */</a>
<a name="ln3031"> </a>
<a name="ln3032">	M_WME_SETAC(m, WME_AC_BE);</a>
<a name="ln3033"> </a>
<a name="ln3034">	IEEE80211_DPRINTF(vap, IEEE80211_MSG_DEBUG | IEEE80211_MSG_DUMPPKTS,</a>
<a name="ln3035">	    &quot;send probe resp on channel %u to %s%s\n&quot;,</a>
<a name="ln3036">	    ieee80211_chan2ieee(ic, ic-&gt;ic_curchan), ether_sprintf(da),</a>
<a name="ln3037">	    legacy ? &quot; &lt;legacy&gt;&quot; : &quot;&quot;);</a>
<a name="ln3038">	IEEE80211_NODE_STAT(bss, tx_mgmt);</a>
<a name="ln3039"> </a>
<a name="ln3040">	ret = ieee80211_raw_output(vap, bss, m, NULL);</a>
<a name="ln3041">	IEEE80211_TX_UNLOCK(ic);</a>
<a name="ln3042">	return (ret);</a>
<a name="ln3043">}</a>
<a name="ln3044"> </a>
<a name="ln3045">/*</a>
<a name="ln3046"> * Allocate and build a RTS (Request To Send) control frame.</a>
<a name="ln3047"> */</a>
<a name="ln3048">struct mbuf *</a>
<a name="ln3049">ieee80211_alloc_rts(struct ieee80211com *ic,</a>
<a name="ln3050">	const uint8_t ra[IEEE80211_ADDR_LEN],</a>
<a name="ln3051">	const uint8_t ta[IEEE80211_ADDR_LEN],</a>
<a name="ln3052">	uint16_t dur)</a>
<a name="ln3053">{</a>
<a name="ln3054">	struct ieee80211_frame_rts *rts;</a>
<a name="ln3055">	struct mbuf *m;</a>
<a name="ln3056"> </a>
<a name="ln3057">	/* XXX honor ic_headroom */</a>
<a name="ln3058">	m = m_gethdr(M_NOWAIT, MT_DATA);</a>
<a name="ln3059">	if (m != NULL) {</a>
<a name="ln3060">		rts = mtod(m, struct ieee80211_frame_rts *);</a>
<a name="ln3061">		rts-&gt;i_fc[0] = IEEE80211_FC0_VERSION_0 |</a>
<a name="ln3062">			IEEE80211_FC0_TYPE_CTL | IEEE80211_FC0_SUBTYPE_RTS;</a>
<a name="ln3063">		rts-&gt;i_fc[1] = IEEE80211_FC1_DIR_NODS;</a>
<a name="ln3064">		*(u_int16_t *)rts-&gt;i_dur = htole16(dur);</a>
<a name="ln3065">		IEEE80211_ADDR_COPY(rts-&gt;i_ra, ra);</a>
<a name="ln3066">		IEEE80211_ADDR_COPY(rts-&gt;i_ta, ta);</a>
<a name="ln3067"> </a>
<a name="ln3068">		m-&gt;m_pkthdr.len = m-&gt;m_len = sizeof(struct ieee80211_frame_rts);</a>
<a name="ln3069">	}</a>
<a name="ln3070">	return m;</a>
<a name="ln3071">}</a>
<a name="ln3072"> </a>
<a name="ln3073">/*</a>
<a name="ln3074"> * Allocate and build a CTS (Clear To Send) control frame.</a>
<a name="ln3075"> */</a>
<a name="ln3076">struct mbuf *</a>
<a name="ln3077">ieee80211_alloc_cts(struct ieee80211com *ic,</a>
<a name="ln3078">	const uint8_t ra[IEEE80211_ADDR_LEN], uint16_t dur)</a>
<a name="ln3079">{</a>
<a name="ln3080">	struct ieee80211_frame_cts *cts;</a>
<a name="ln3081">	struct mbuf *m;</a>
<a name="ln3082"> </a>
<a name="ln3083">	/* XXX honor ic_headroom */</a>
<a name="ln3084">	m = m_gethdr(M_NOWAIT, MT_DATA);</a>
<a name="ln3085">	if (m != NULL) {</a>
<a name="ln3086">		cts = mtod(m, struct ieee80211_frame_cts *);</a>
<a name="ln3087">		cts-&gt;i_fc[0] = IEEE80211_FC0_VERSION_0 |</a>
<a name="ln3088">			IEEE80211_FC0_TYPE_CTL | IEEE80211_FC0_SUBTYPE_CTS;</a>
<a name="ln3089">		cts-&gt;i_fc[1] = IEEE80211_FC1_DIR_NODS;</a>
<a name="ln3090">		*(u_int16_t *)cts-&gt;i_dur = htole16(dur);</a>
<a name="ln3091">		IEEE80211_ADDR_COPY(cts-&gt;i_ra, ra);</a>
<a name="ln3092"> </a>
<a name="ln3093">		m-&gt;m_pkthdr.len = m-&gt;m_len = sizeof(struct ieee80211_frame_cts);</a>
<a name="ln3094">	}</a>
<a name="ln3095">	return m;</a>
<a name="ln3096">}</a>
<a name="ln3097"> </a>
<a name="ln3098">/*</a>
<a name="ln3099"> * Wrapper for CTS/RTS frame allocation.</a>
<a name="ln3100"> */</a>
<a name="ln3101">struct mbuf *</a>
<a name="ln3102">ieee80211_alloc_prot(struct ieee80211_node *ni, const struct mbuf *m,</a>
<a name="ln3103">    uint8_t rate, int prot)</a>
<a name="ln3104">{</a>
<a name="ln3105">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3106">	const struct ieee80211_frame *wh;</a>
<a name="ln3107">	struct mbuf *mprot;</a>
<a name="ln3108">	uint16_t dur;</a>
<a name="ln3109">	int pktlen, isshort;</a>
<a name="ln3110"> </a>
<a name="ln3111">	KASSERT(prot == IEEE80211_PROT_RTSCTS ||</a>
<a name="ln3112">	    prot == IEEE80211_PROT_CTSONLY,</a>
<a name="ln3113">	    (&quot;wrong protection type %d&quot;, prot));</a>
<a name="ln3114"> </a>
<a name="ln3115">	wh = mtod(m, const struct ieee80211_frame *);</a>
<a name="ln3116">	pktlen = m-&gt;m_pkthdr.len + IEEE80211_CRC_LEN;</a>
<a name="ln3117">	isshort = (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE) != 0;</a>
<a name="ln3118">	dur = ieee80211_compute_duration(ic-&gt;ic_rt, pktlen, rate, isshort)</a>
<a name="ln3119">	    + ieee80211_ack_duration(ic-&gt;ic_rt, rate, isshort);</a>
<a name="ln3120"> </a>
<a name="ln3121">	if (prot == IEEE80211_PROT_RTSCTS) {</a>
<a name="ln3122">		/* NB: CTS is the same size as an ACK */</a>
<a name="ln3123">		dur += ieee80211_ack_duration(ic-&gt;ic_rt, rate, isshort);</a>
<a name="ln3124">		mprot = ieee80211_alloc_rts(ic, wh-&gt;i_addr1, wh-&gt;i_addr2, dur);</a>
<a name="ln3125">	} else</a>
<a name="ln3126">		mprot = ieee80211_alloc_cts(ic, ni-&gt;ni_vap-&gt;iv_myaddr, dur);</a>
<a name="ln3127"> </a>
<a name="ln3128">	return (mprot);</a>
<a name="ln3129">}</a>
<a name="ln3130"> </a>
<a name="ln3131">static void</a>
<a name="ln3132">ieee80211_tx_mgt_timeout(void *arg)</a>
<a name="ln3133">{</a>
<a name="ln3134">	struct ieee80211vap *vap = arg;</a>
<a name="ln3135"> </a>
<a name="ln3136">	IEEE80211_LOCK(vap-&gt;iv_ic);</a>
<a name="ln3137">	if (vap-&gt;iv_state != IEEE80211_S_INIT &amp;&amp;</a>
<a name="ln3138">	    (vap-&gt;iv_ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) == 0) {</a>
<a name="ln3139">		/*</a>
<a name="ln3140">		 * NB: it's safe to specify a timeout as the reason here;</a>
<a name="ln3141">		 *     it'll only be used in the right state.</a>
<a name="ln3142">		 */</a>
<a name="ln3143">		ieee80211_new_state_locked(vap, IEEE80211_S_SCAN,</a>
<a name="ln3144">			IEEE80211_SCAN_FAIL_TIMEOUT);</a>
<a name="ln3145">	}</a>
<a name="ln3146">	IEEE80211_UNLOCK(vap-&gt;iv_ic);</a>
<a name="ln3147">}</a>
<a name="ln3148"> </a>
<a name="ln3149">/*</a>
<a name="ln3150"> * This is the callback set on net80211-sourced transmitted</a>
<a name="ln3151"> * authentication request frames.</a>
<a name="ln3152"> *</a>
<a name="ln3153"> * This does a couple of things:</a>
<a name="ln3154"> *</a>
<a name="ln3155"> * + If the frame transmitted was a success, it schedules a future</a>
<a name="ln3156"> *   event which will transition the interface to scan.</a>
<a name="ln3157"> *   If a state transition _then_ occurs before that event occurs,</a>
<a name="ln3158"> *   said state transition will cancel this callout.</a>
<a name="ln3159"> *</a>
<a name="ln3160"> * + If the frame transmit was a failure, it immediately schedules</a>
<a name="ln3161"> *   the transition back to scan.</a>
<a name="ln3162"> */</a>
<a name="ln3163">static void</a>
<a name="ln3164">ieee80211_tx_mgt_cb(struct ieee80211_node *ni, void *arg, int status)</a>
<a name="ln3165">{</a>
<a name="ln3166">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3167">	enum ieee80211_state ostate = (enum ieee80211_state) arg;</a>
<a name="ln3168"> </a>
<a name="ln3169">	/*</a>
<a name="ln3170">	 * Frame transmit completed; arrange timer callback.  If</a>
<a name="ln3171">	 * transmit was successfully we wait for response.  Otherwise</a>
<a name="ln3172">	 * we arrange an immediate callback instead of doing the</a>
<a name="ln3173">	 * callback directly since we don't know what state the driver</a>
<a name="ln3174">	 * is in (e.g. what locks it is holding).  This work should</a>
<a name="ln3175">	 * not be too time-critical and not happen too often so the</a>
<a name="ln3176">	 * added overhead is acceptable.</a>
<a name="ln3177">	 *</a>
<a name="ln3178">	 * XXX what happens if !acked but response shows up before callback?</a>
<a name="ln3179">	 */</a>
<a name="ln3180">	if (vap-&gt;iv_state == ostate) {</a>
<a name="ln3181">		callout_reset(&amp;vap-&gt;iv_mgtsend,</a>
<a name="ln3182">			status == 0 ? IEEE80211_TRANS_WAIT*hz : 0,</a>
<a name="ln3183">			ieee80211_tx_mgt_timeout, vap);</a>
<a name="ln3184">	}</a>
<a name="ln3185">}</a>
<a name="ln3186"> </a>
<a name="ln3187">static void</a>
<a name="ln3188">ieee80211_beacon_construct(struct mbuf *m, uint8_t *frm,</a>
<a name="ln3189">	struct ieee80211_node *ni)</a>
<a name="ln3190">{</a>
<a name="ln3191">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3192">	struct ieee80211_beacon_offsets *bo = &amp;vap-&gt;iv_bcn_off;</a>
<a name="ln3193">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3194">	struct ieee80211_rateset *rs = &amp;ni-&gt;ni_rates;</a>
<a name="ln3195">	uint16_t capinfo;</a>
<a name="ln3196"> </a>
<a name="ln3197">	/*</a>
<a name="ln3198">	 * beacon frame format</a>
<a name="ln3199">	 *</a>
<a name="ln3200">	 * TODO: update to 802.11-2012; a lot of stuff has changed;</a>
<a name="ln3201">	 * vendor extensions should be at the end, etc.</a>
<a name="ln3202">	 *</a>
<a name="ln3203">	 *	[8] time stamp</a>
<a name="ln3204">	 *	[2] beacon interval</a>
<a name="ln3205">	 *	[2] cabability information</a>
<a name="ln3206">	 *	[tlv] ssid</a>
<a name="ln3207">	 *	[tlv] supported rates</a>
<a name="ln3208">	 *	[3] parameter set (DS)</a>
<a name="ln3209">	 *	[8] CF parameter set (optional)</a>
<a name="ln3210">	 *	[tlv] parameter set (IBSS/TIM)</a>
<a name="ln3211">	 *	[tlv] country (optional)</a>
<a name="ln3212">	 *	[3] power control (optional)</a>
<a name="ln3213">	 *	[5] channel switch announcement (CSA) (optional)</a>
<a name="ln3214">	 * XXX TODO: Quiet</a>
<a name="ln3215">	 * XXX TODO: IBSS DFS</a>
<a name="ln3216">	 * XXX TODO: TPC report</a>
<a name="ln3217">	 *	[tlv] extended rate phy (ERP)</a>
<a name="ln3218">	 *	[tlv] extended supported rates</a>
<a name="ln3219">	 *	[tlv] RSN parameters</a>
<a name="ln3220">	 * XXX TODO: BSSLOAD</a>
<a name="ln3221">	 * (XXX EDCA parameter set, QoS capability?)</a>
<a name="ln3222">	 * XXX TODO: AP channel report</a>
<a name="ln3223">	 *</a>
<a name="ln3224">	 *	[tlv] HT capabilities</a>
<a name="ln3225">	 *	[tlv] HT information</a>
<a name="ln3226">	 *	XXX TODO: 20/40 BSS coexistence</a>
<a name="ln3227">	 * Mesh:</a>
<a name="ln3228">	 * XXX TODO: Meshid</a>
<a name="ln3229">	 * XXX TODO: mesh config</a>
<a name="ln3230">	 * XXX TODO: mesh awake window</a>
<a name="ln3231">	 * XXX TODO: beacon timing (mesh, etc)</a>
<a name="ln3232">	 * XXX TODO: MCCAOP Advertisement Overview</a>
<a name="ln3233">	 * XXX TODO: MCCAOP Advertisement</a>
<a name="ln3234">	 * XXX TODO: Mesh channel switch parameters</a>
<a name="ln3235">	 * VHT:</a>
<a name="ln3236">	 * XXX TODO: VHT capabilities</a>
<a name="ln3237">	 * XXX TODO: VHT operation</a>
<a name="ln3238">	 * XXX TODO: VHT transmit power envelope</a>
<a name="ln3239">	 * XXX TODO: channel switch wrapper element</a>
<a name="ln3240">	 * XXX TODO: extended BSS load element</a>
<a name="ln3241">	 *</a>
<a name="ln3242">	 * XXX Vendor-specific OIDs (e.g. Atheros)</a>
<a name="ln3243">	 *	[tlv] WPA parameters</a>
<a name="ln3244">	 *	[tlv] WME parameters</a>
<a name="ln3245">	 *	[tlv] Vendor OUI HT capabilities (optional)</a>
<a name="ln3246">	 *	[tlv] Vendor OUI HT information (optional)</a>
<a name="ln3247">	 *	[tlv] Atheros capabilities (optional)</a>
<a name="ln3248">	 *	[tlv] TDMA parameters (optional)</a>
<a name="ln3249">	 *	[tlv] Mesh ID (MBSS)</a>
<a name="ln3250">	 *	[tlv] Mesh Conf (MBSS)</a>
<a name="ln3251">	 *	[tlv] application data (optional)</a>
<a name="ln3252">	 */</a>
<a name="ln3253"> </a>
<a name="ln3254">	memset(bo, 0, sizeof(*bo));</a>
<a name="ln3255"> </a>
<a name="ln3256">	memset(frm, 0, 8);	/* XXX timestamp is set by hardware/driver */</a>
<a name="ln3257">	frm += 8;</a>
<a name="ln3258">	*(uint16_t *)frm = htole16(ni-&gt;ni_intval);</a>
<a name="ln3259">	frm += 2;</a>
<a name="ln3260">	capinfo = ieee80211_getcapinfo(vap, ni-&gt;ni_chan);</a>
<a name="ln3261">	bo-&gt;bo_caps = (uint16_t *)frm;</a>
<a name="ln3262">	*(uint16_t *)frm = htole16(capinfo);</a>
<a name="ln3263">	frm += 2;</a>
<a name="ln3264">	*frm++ = IEEE80211_ELEMID_SSID;</a>
<a name="ln3265">	if ((vap-&gt;iv_flags &amp; IEEE80211_F_HIDESSID) == 0) {</a>
<a name="ln3266">		*frm++ = ni-&gt;ni_esslen;</a>
<a name="ln3267">		memcpy(frm, ni-&gt;ni_essid, ni-&gt;ni_esslen);</a>
<a name="ln3268">		frm += ni-&gt;ni_esslen;</a>
<a name="ln3269">	} else</a>
<a name="ln3270">		*frm++ = 0;</a>
<a name="ln3271">	frm = ieee80211_add_rates(frm, rs);</a>
<a name="ln3272">	if (!IEEE80211_IS_CHAN_FHSS(ni-&gt;ni_chan)) {</a>
<a name="ln3273">		*frm++ = IEEE80211_ELEMID_DSPARMS;</a>
<a name="ln3274">		*frm++ = 1;</a>
<a name="ln3275">		*frm++ = ieee80211_chan2ieee(ic, ni-&gt;ni_chan);</a>
<a name="ln3276">	}</a>
<a name="ln3277">	if (ic-&gt;ic_flags &amp; IEEE80211_F_PCF) {</a>
<a name="ln3278">		bo-&gt;bo_cfp = frm;</a>
<a name="ln3279">		frm = ieee80211_add_cfparms(frm, ic);</a>
<a name="ln3280">	}</a>
<a name="ln3281">	bo-&gt;bo_tim = frm;</a>
<a name="ln3282">	if (vap-&gt;iv_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln3283">		*frm++ = IEEE80211_ELEMID_IBSSPARMS;</a>
<a name="ln3284">		*frm++ = 2;</a>
<a name="ln3285">		*frm++ = 0; *frm++ = 0;		/* TODO: ATIM window */</a>
<a name="ln3286">		bo-&gt;bo_tim_len = 0;</a>
<a name="ln3287">	} else if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln3288">	    vap-&gt;iv_opmode == IEEE80211_M_MBSS) {</a>
<a name="ln3289">		/* TIM IE is the same for Mesh and Hostap */</a>
<a name="ln3290">		struct ieee80211_tim_ie *tie = (struct ieee80211_tim_ie *) frm;</a>
<a name="ln3291"> </a>
<a name="ln3292">		tie-&gt;tim_ie = IEEE80211_ELEMID_TIM;</a>
<a name="ln3293">		tie-&gt;tim_len = 4;	/* length */</a>
<a name="ln3294">		tie-&gt;tim_count = 0;	/* DTIM count */</a>
<a name="ln3295">		tie-&gt;tim_period = vap-&gt;iv_dtim_period;	/* DTIM period */</a>
<a name="ln3296">		tie-&gt;tim_bitctl = 0;	/* bitmap control */</a>
<a name="ln3297">		tie-&gt;tim_bitmap[0] = 0;	/* Partial Virtual Bitmap */</a>
<a name="ln3298">		frm += sizeof(struct ieee80211_tim_ie);</a>
<a name="ln3299">		bo-&gt;bo_tim_len = 1;</a>
<a name="ln3300">	}</a>
<a name="ln3301">	bo-&gt;bo_tim_trailer = frm;</a>
<a name="ln3302">	if ((vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) ||</a>
<a name="ln3303">	    (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_DOTD))</a>
<a name="ln3304">		frm = ieee80211_add_countryie(frm, ic);</a>
<a name="ln3305">	if (vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) {</a>
<a name="ln3306">		if (IEEE80211_IS_CHAN_5GHZ(ni-&gt;ni_chan))</a>
<a name="ln3307">			frm = ieee80211_add_powerconstraint(frm, vap);</a>
<a name="ln3308">		bo-&gt;bo_csa = frm;</a>
<a name="ln3309">		if (ic-&gt;ic_flags &amp; IEEE80211_F_CSAPENDING)</a>
<a name="ln3310">			frm = ieee80211_add_csa(frm, vap);</a>
<a name="ln3311">	} else</a>
<a name="ln3312">		bo-&gt;bo_csa = frm;</a>
<a name="ln3313"> </a>
<a name="ln3314">	bo-&gt;bo_quiet = NULL;</a>
<a name="ln3315">	if (vap-&gt;iv_flags &amp; IEEE80211_F_DOTH) {</a>
<a name="ln3316">		if (IEEE80211_IS_CHAN_DFS(ic-&gt;ic_bsschan) &amp;&amp;</a>
<a name="ln3317">		    (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_DFS) &amp;&amp;</a>
<a name="ln3318">		    (vap-&gt;iv_quiet == 1)) {</a>
<a name="ln3319">			/*</a>
<a name="ln3320">			 * We only insert the quiet IE offset if</a>
<a name="ln3321">			 * the quiet IE is enabled.  Otherwise don't</a>
<a name="ln3322">			 * put it here or we'll just overwrite</a>
<a name="ln3323">			 * some other beacon contents.</a>
<a name="ln3324">			 */</a>
<a name="ln3325">			if (vap-&gt;iv_quiet) {</a>
<a name="ln3326">				bo-&gt;bo_quiet = frm;</a>
<a name="ln3327">				frm = ieee80211_add_quiet(frm,vap, 0);</a>
<a name="ln3328">			}</a>
<a name="ln3329">		}</a>
<a name="ln3330">	}</a>
<a name="ln3331"> </a>
<a name="ln3332">	if (IEEE80211_IS_CHAN_ANYG(ni-&gt;ni_chan)) {</a>
<a name="ln3333">		bo-&gt;bo_erp = frm;</a>
<a name="ln3334">		frm = ieee80211_add_erp(frm, ic);</a>
<a name="ln3335">	}</a>
<a name="ln3336">	frm = ieee80211_add_xrates(frm, rs);</a>
<a name="ln3337">	frm = ieee80211_add_rsn(frm, vap);</a>
<a name="ln3338">	if (IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan)) {</a>
<a name="ln3339">		frm = ieee80211_add_htcap(frm, ni);</a>
<a name="ln3340">		bo-&gt;bo_htinfo = frm;</a>
<a name="ln3341">		frm = ieee80211_add_htinfo(frm, ni);</a>
<a name="ln3342">	}</a>
<a name="ln3343"> </a>
<a name="ln3344">	if (IEEE80211_IS_CHAN_VHT(ni-&gt;ni_chan)) {</a>
<a name="ln3345">		frm = ieee80211_add_vhtcap(frm, ni);</a>
<a name="ln3346">		bo-&gt;bo_vhtinfo = frm;</a>
<a name="ln3347">		frm = ieee80211_add_vhtinfo(frm, ni);</a>
<a name="ln3348">		/* Transmit power envelope */</a>
<a name="ln3349">		/* Channel switch wrapper element */</a>
<a name="ln3350">		/* Extended bss load element */</a>
<a name="ln3351">	}</a>
<a name="ln3352"> </a>
<a name="ln3353">	frm = ieee80211_add_wpa(frm, vap);</a>
<a name="ln3354">	if (vap-&gt;iv_flags &amp; IEEE80211_F_WME) {</a>
<a name="ln3355">		bo-&gt;bo_wme = frm;</a>
<a name="ln3356">		frm = ieee80211_add_wme_param(frm, &amp;ic-&gt;ic_wme);</a>
<a name="ln3357">	}</a>
<a name="ln3358">	if (IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan) &amp;&amp;</a>
<a name="ln3359">	    (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HTCOMPAT)) {</a>
<a name="ln3360">		frm = ieee80211_add_htcap_vendor(frm, ni);</a>
<a name="ln3361">		frm = ieee80211_add_htinfo_vendor(frm, ni);</a>
<a name="ln3362">	}</a>
<a name="ln3363"> </a>
<a name="ln3364">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln3365">	if (vap-&gt;iv_flags &amp; IEEE80211_F_ATHEROS) {</a>
<a name="ln3366">		bo-&gt;bo_ath = frm;</a>
<a name="ln3367">		frm = ieee80211_add_athcaps(frm, ni);</a>
<a name="ln3368">	}</a>
<a name="ln3369">#endif</a>
<a name="ln3370">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln3371">	if (vap-&gt;iv_caps &amp; IEEE80211_C_TDMA) {</a>
<a name="ln3372">		bo-&gt;bo_tdma = frm;</a>
<a name="ln3373">		frm = ieee80211_add_tdma(frm, vap);</a>
<a name="ln3374">	}</a>
<a name="ln3375">#endif</a>
<a name="ln3376">	if (vap-&gt;iv_appie_beacon != NULL) {</a>
<a name="ln3377">		bo-&gt;bo_appie = frm;</a>
<a name="ln3378">		bo-&gt;bo_appie_len = vap-&gt;iv_appie_beacon-&gt;ie_len;</a>
<a name="ln3379">		frm = add_appie(frm, vap-&gt;iv_appie_beacon);</a>
<a name="ln3380">	}</a>
<a name="ln3381"> </a>
<a name="ln3382">	/* XXX TODO: move meshid/meshconf up to before vendor extensions? */</a>
<a name="ln3383">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln3384">	if (vap-&gt;iv_opmode == IEEE80211_M_MBSS) {</a>
<a name="ln3385">		frm = ieee80211_add_meshid(frm, vap);</a>
<a name="ln3386">		bo-&gt;bo_meshconf = frm;</a>
<a name="ln3387">		frm = ieee80211_add_meshconf(frm, vap);</a>
<a name="ln3388">	}</a>
<a name="ln3389">#endif</a>
<a name="ln3390">	bo-&gt;bo_tim_trailer_len = frm - bo-&gt;bo_tim_trailer;</a>
<a name="ln3391">	bo-&gt;bo_csa_trailer_len = frm - bo-&gt;bo_csa;</a>
<a name="ln3392">	m-&gt;m_pkthdr.len = m-&gt;m_len = frm - mtod(m, uint8_t *);</a>
<a name="ln3393">}</a>
<a name="ln3394"> </a>
<a name="ln3395">/*</a>
<a name="ln3396"> * Allocate a beacon frame and fillin the appropriate bits.</a>
<a name="ln3397"> */</a>
<a name="ln3398">struct mbuf *</a>
<a name="ln3399">ieee80211_beacon_alloc(struct ieee80211_node *ni)</a>
<a name="ln3400">{</a>
<a name="ln3401">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3402">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3403">	struct ifnet *ifp = vap-&gt;iv_ifp;</a>
<a name="ln3404">	struct ieee80211_frame *wh;</a>
<a name="ln3405">	struct mbuf *m;</a>
<a name="ln3406">	int pktlen;</a>
<a name="ln3407">	uint8_t *frm;</a>
<a name="ln3408"> </a>
<a name="ln3409">	/*</a>
<a name="ln3410">	 * Update the &quot;We're putting the quiet IE in the beacon&quot; state.</a>
<a name="ln3411">	 */</a>
<a name="ln3412">	if (vap-&gt;iv_quiet == 1)</a>
<a name="ln3413">		vap-&gt;iv_flags_ext |= IEEE80211_FEXT_QUIET_IE;</a>
<a name="ln3414">	else if (vap-&gt;iv_quiet == 0)</a>
<a name="ln3415">		vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_QUIET_IE;</a>
<a name="ln3416"> </a>
<a name="ln3417">	/*</a>
<a name="ln3418">	 * beacon frame format</a>
<a name="ln3419">	 *</a>
<a name="ln3420">	 * Note: This needs updating for 802.11-2012.</a>
<a name="ln3421">	 *</a>
<a name="ln3422">	 *	[8] time stamp</a>
<a name="ln3423">	 *	[2] beacon interval</a>
<a name="ln3424">	 *	[2] cabability information</a>
<a name="ln3425">	 *	[tlv] ssid</a>
<a name="ln3426">	 *	[tlv] supported rates</a>
<a name="ln3427">	 *	[3] parameter set (DS)</a>
<a name="ln3428">	 *	[8] CF parameter set (optional)</a>
<a name="ln3429">	 *	[tlv] parameter set (IBSS/TIM)</a>
<a name="ln3430">	 *	[tlv] country (optional)</a>
<a name="ln3431">	 *	[3] power control (optional)</a>
<a name="ln3432">	 *	[5] channel switch announcement (CSA) (optional)</a>
<a name="ln3433">	 *	[tlv] extended rate phy (ERP)</a>
<a name="ln3434">	 *	[tlv] extended supported rates</a>
<a name="ln3435">	 *	[tlv] RSN parameters</a>
<a name="ln3436">	 *	[tlv] HT capabilities</a>
<a name="ln3437">	 *	[tlv] HT information</a>
<a name="ln3438">	 *	[tlv] VHT capabilities</a>
<a name="ln3439">	 *	[tlv] VHT operation</a>
<a name="ln3440">	 *	[tlv] Vendor OUI HT capabilities (optional)</a>
<a name="ln3441">	 *	[tlv] Vendor OUI HT information (optional)</a>
<a name="ln3442">	 * XXX Vendor-specific OIDs (e.g. Atheros)</a>
<a name="ln3443">	 *	[tlv] WPA parameters</a>
<a name="ln3444">	 *	[tlv] WME parameters</a>
<a name="ln3445">	 *	[tlv] TDMA parameters (optional)</a>
<a name="ln3446">	 *	[tlv] Mesh ID (MBSS)</a>
<a name="ln3447">	 *	[tlv] Mesh Conf (MBSS)</a>
<a name="ln3448">	 *	[tlv] application data (optional)</a>
<a name="ln3449">	 * NB: we allocate the max space required for the TIM bitmap.</a>
<a name="ln3450">	 * XXX how big is this?</a>
<a name="ln3451">	 */</a>
<a name="ln3452">	pktlen =   8					/* time stamp */</a>
<a name="ln3453">		 + sizeof(uint16_t)			/* beacon interval */</a>
<a name="ln3454">		 + sizeof(uint16_t)			/* capabilities */</a>
<a name="ln3455">		 + 2 + ni-&gt;ni_esslen			/* ssid */</a>
<a name="ln3456">	         + 2 + IEEE80211_RATE_SIZE		/* supported rates */</a>
<a name="ln3457">	         + 2 + 1				/* DS parameters */</a>
<a name="ln3458">		 + 2 + 6				/* CF parameters */</a>
<a name="ln3459">		 + 2 + 4 + vap-&gt;iv_tim_len		/* DTIM/IBSSPARMS */</a>
<a name="ln3460">		 + IEEE80211_COUNTRY_MAX_SIZE		/* country */</a>
<a name="ln3461">		 + 2 + 1				/* power control */</a>
<a name="ln3462">		 + sizeof(struct ieee80211_csa_ie)	/* CSA */</a>
<a name="ln3463">		 + sizeof(struct ieee80211_quiet_ie)	/* Quiet */</a>
<a name="ln3464">		 + 2 + 1				/* ERP */</a>
<a name="ln3465">	         + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE)</a>
<a name="ln3466">		 + (vap-&gt;iv_caps &amp; IEEE80211_C_WPA ?	/* WPA 1+2 */</a>
<a name="ln3467">			2*sizeof(struct ieee80211_ie_wpa) : 0)</a>
<a name="ln3468">		 /* XXX conditional? */</a>
<a name="ln3469">		 + 4+2*sizeof(struct ieee80211_ie_htcap)/* HT caps */</a>
<a name="ln3470">		 + 4+2*sizeof(struct ieee80211_ie_htinfo)/* HT info */</a>
<a name="ln3471">		 + sizeof(struct ieee80211_ie_vhtcap)/* VHT caps */</a>
<a name="ln3472">		 + sizeof(struct ieee80211_ie_vht_operation)/* VHT info */</a>
<a name="ln3473">		 + (vap-&gt;iv_caps &amp; IEEE80211_C_WME ?	/* WME */</a>
<a name="ln3474">			sizeof(struct ieee80211_wme_param) : 0)</a>
<a name="ln3475">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln3476">		 + sizeof(struct ieee80211_ath_ie)	/* ATH */</a>
<a name="ln3477">#endif</a>
<a name="ln3478">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln3479">		 + (vap-&gt;iv_caps &amp; IEEE80211_C_TDMA ?	/* TDMA */</a>
<a name="ln3480">			sizeof(struct ieee80211_tdma_param) : 0)</a>
<a name="ln3481">#endif</a>
<a name="ln3482">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln3483">		 + 2 + ni-&gt;ni_meshidlen</a>
<a name="ln3484">		 + sizeof(struct ieee80211_meshconf_ie)</a>
<a name="ln3485">#endif</a>
<a name="ln3486">		 + IEEE80211_MAX_APPIE</a>
<a name="ln3487">		 ;</a>
<a name="ln3488">	m = ieee80211_getmgtframe(&amp;frm,</a>
<a name="ln3489">		ic-&gt;ic_headroom + sizeof(struct ieee80211_frame), pktlen);</a>
<a name="ln3490">	if (m == NULL) {</a>
<a name="ln3491">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_ANY,</a>
<a name="ln3492">			&quot;%s: cannot get buf; size %u\n&quot;, __func__, pktlen);</a>
<a name="ln3493">		vap-&gt;iv_stats.is_tx_nobuf++;</a>
<a name="ln3494">		return NULL;</a>
<a name="ln3495">	}</a>
<a name="ln3496">	ieee80211_beacon_construct(m, frm, ni);</a>
<a name="ln3497"> </a>
<a name="ln3498">	M_PREPEND(m, sizeof(struct ieee80211_frame), M_NOWAIT);</a>
<a name="ln3499">	KASSERT(m != NULL, (&quot;no space for 802.11 header?&quot;));</a>
<a name="ln3500">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln3501">	wh-&gt;i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |</a>
<a name="ln3502">	    IEEE80211_FC0_SUBTYPE_BEACON;</a>
<a name="ln3503">	wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_NODS;</a>
<a name="ln3504">	*(uint16_t *)wh-&gt;i_dur = 0;</a>
<a name="ln3505">	IEEE80211_ADDR_COPY(wh-&gt;i_addr1, ifp-&gt;if_broadcastaddr);</a>
<a name="ln3506">	IEEE80211_ADDR_COPY(wh-&gt;i_addr2, vap-&gt;iv_myaddr);</a>
<a name="ln3507">	IEEE80211_ADDR_COPY(wh-&gt;i_addr3, ni-&gt;ni_bssid);</a>
<a name="ln3508">	*(uint16_t *)wh-&gt;i_seq = 0;</a>
<a name="ln3509"> </a>
<a name="ln3510">	return m;</a>
<a name="ln3511">}</a>
<a name="ln3512"> </a>
<a name="ln3513">/*</a>
<a name="ln3514"> * Update the dynamic parts of a beacon frame based on the current state.</a>
<a name="ln3515"> */</a>
<a name="ln3516">int</a>
<a name="ln3517">ieee80211_beacon_update(struct ieee80211_node *ni, struct mbuf *m, int mcast)</a>
<a name="ln3518">{</a>
<a name="ln3519">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3520">	struct ieee80211_beacon_offsets *bo = &amp;vap-&gt;iv_bcn_off;</a>
<a name="ln3521">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3522">	int len_changed = 0;</a>
<a name="ln3523">	uint16_t capinfo;</a>
<a name="ln3524">	struct ieee80211_frame *wh;</a>
<a name="ln3525">	ieee80211_seq seqno;</a>
<a name="ln3526"> </a>
<a name="ln3527">	IEEE80211_LOCK(ic);</a>
<a name="ln3528">	/*</a>
<a name="ln3529">	 * Handle 11h channel change when we've reached the count.</a>
<a name="ln3530">	 * We must recalculate the beacon frame contents to account</a>
<a name="ln3531">	 * for the new channel.  Note we do this only for the first</a>
<a name="ln3532">	 * vap that reaches this point; subsequent vaps just update</a>
<a name="ln3533">	 * their beacon state to reflect the recalculated channel.</a>
<a name="ln3534">	 */</a>
<a name="ln3535">	if (isset(bo-&gt;bo_flags, IEEE80211_BEACON_CSA) &amp;&amp;</a>
<a name="ln3536">	    vap-&gt;iv_csa_count == ic-&gt;ic_csa_count) {</a>
<a name="ln3537">		vap-&gt;iv_csa_count = 0;</a>
<a name="ln3538">		/*</a>
<a name="ln3539">		 * Effect channel change before reconstructing the beacon</a>
<a name="ln3540">		 * frame contents as many places reference ni_chan.</a>
<a name="ln3541">		 */</a>
<a name="ln3542">		if (ic-&gt;ic_csa_newchan != NULL)</a>
<a name="ln3543">			ieee80211_csa_completeswitch(ic);</a>
<a name="ln3544">		/*</a>
<a name="ln3545">		 * NB: ieee80211_beacon_construct clears all pending</a>
<a name="ln3546">		 * updates in bo_flags so we don't need to explicitly</a>
<a name="ln3547">		 * clear IEEE80211_BEACON_CSA.</a>
<a name="ln3548">		 */</a>
<a name="ln3549">		ieee80211_beacon_construct(m,</a>
<a name="ln3550">		    mtod(m, uint8_t*) + sizeof(struct ieee80211_frame), ni);</a>
<a name="ln3551"> </a>
<a name="ln3552">		/* XXX do WME aggressive mode processing? */</a>
<a name="ln3553">		IEEE80211_UNLOCK(ic);</a>
<a name="ln3554">		return 1;		/* just assume length changed */</a>
<a name="ln3555">	}</a>
<a name="ln3556"> </a>
<a name="ln3557">	/*</a>
<a name="ln3558">	 * Handle the quiet time element being added and removed.</a>
<a name="ln3559">	 * Again, for now we just cheat and reconstruct the whole</a>
<a name="ln3560">	 * beacon - that way the gap is provided as appropriate.</a>
<a name="ln3561">	 *</a>
<a name="ln3562">	 * So, track whether we have already added the IE versus</a>
<a name="ln3563">	 * whether we want to be adding the IE.</a>
<a name="ln3564">	 */</a>
<a name="ln3565">	if ((vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_QUIET_IE) &amp;&amp;</a>
<a name="ln3566">	    (vap-&gt;iv_quiet == 0)) {</a>
<a name="ln3567">		/*</a>
<a name="ln3568">		 * Quiet time beacon IE enabled, but it's disabled;</a>
<a name="ln3569">		 * recalc</a>
<a name="ln3570">		 */</a>
<a name="ln3571">		vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_QUIET_IE;</a>
<a name="ln3572">		ieee80211_beacon_construct(m,</a>
<a name="ln3573">		    mtod(m, uint8_t*) + sizeof(struct ieee80211_frame), ni);</a>
<a name="ln3574">		/* XXX do WME aggressive mode processing? */</a>
<a name="ln3575">		IEEE80211_UNLOCK(ic);</a>
<a name="ln3576">		return 1;		/* just assume length changed */</a>
<a name="ln3577">	}</a>
<a name="ln3578"> </a>
<a name="ln3579">	if (((vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_QUIET_IE) == 0) &amp;&amp;</a>
<a name="ln3580">	    (vap-&gt;iv_quiet == 1)) {</a>
<a name="ln3581">		/*</a>
<a name="ln3582">		 * Quiet time beacon IE disabled, but it's now enabled;</a>
<a name="ln3583">		 * recalc</a>
<a name="ln3584">		 */</a>
<a name="ln3585">		vap-&gt;iv_flags_ext |= IEEE80211_FEXT_QUIET_IE;</a>
<a name="ln3586">		ieee80211_beacon_construct(m,</a>
<a name="ln3587">		    mtod(m, uint8_t*) + sizeof(struct ieee80211_frame), ni);</a>
<a name="ln3588">		/* XXX do WME aggressive mode processing? */</a>
<a name="ln3589">		IEEE80211_UNLOCK(ic);</a>
<a name="ln3590">		return 1;		/* just assume length changed */</a>
<a name="ln3591">	}</a>
<a name="ln3592"> </a>
<a name="ln3593">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln3594"> </a>
<a name="ln3595">	/*</a>
<a name="ln3596">	 * XXX TODO Strictly speaking this should be incremented with the TX</a>
<a name="ln3597">	 * lock held so as to serialise access to the non-qos TID sequence</a>
<a name="ln3598">	 * number space.</a>
<a name="ln3599">	 *</a>
<a name="ln3600">	 * If the driver identifies it does its own TX seqno management then</a>
<a name="ln3601">	 * we can skip this (and still not do the TX seqno.)</a>
<a name="ln3602">	 */</a>
<a name="ln3603">	seqno = ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID]++;</a>
<a name="ln3604">	*(uint16_t *)&amp;wh-&gt;i_seq[0] =</a>
<a name="ln3605">		htole16(seqno &lt;&lt; IEEE80211_SEQ_SEQ_SHIFT);</a>
<a name="ln3606">	M_SEQNO_SET(m, seqno);</a>
<a name="ln3607"> </a>
<a name="ln3608">	/* XXX faster to recalculate entirely or just changes? */</a>
<a name="ln3609">	capinfo = ieee80211_getcapinfo(vap, ni-&gt;ni_chan);</a>
<a name="ln3610">	*bo-&gt;bo_caps = htole16(capinfo);</a>
<a name="ln3611"> </a>
<a name="ln3612">	if (vap-&gt;iv_flags &amp; IEEE80211_F_WME) {</a>
<a name="ln3613">		struct ieee80211_wme_state *wme = &amp;ic-&gt;ic_wme;</a>
<a name="ln3614"> </a>
<a name="ln3615">		/*</a>
<a name="ln3616">		 * Check for aggressive mode change.  When there is</a>
<a name="ln3617">		 * significant high priority traffic in the BSS</a>
<a name="ln3618">		 * throttle back BE traffic by using conservative</a>
<a name="ln3619">		 * parameters.  Otherwise BE uses aggressive params</a>
<a name="ln3620">		 * to optimize performance of legacy/non-QoS traffic.</a>
<a name="ln3621">		 */</a>
<a name="ln3622">		if (wme-&gt;wme_flags &amp; WME_F_AGGRMODE) {</a>
<a name="ln3623">			if (wme-&gt;wme_hipri_traffic &gt;</a>
<a name="ln3624">			    wme-&gt;wme_hipri_switch_thresh) {</a>
<a name="ln3625">				IEEE80211_DPRINTF(vap, IEEE80211_MSG_WME,</a>
<a name="ln3626">				    &quot;%s: traffic %u, disable aggressive mode\n&quot;,</a>
<a name="ln3627">				    __func__, wme-&gt;wme_hipri_traffic);</a>
<a name="ln3628">				wme-&gt;wme_flags &amp;= ~WME_F_AGGRMODE;</a>
<a name="ln3629">				ieee80211_wme_updateparams_locked(vap);</a>
<a name="ln3630">				wme-&gt;wme_hipri_traffic =</a>
<a name="ln3631">					wme-&gt;wme_hipri_switch_hysteresis;</a>
<a name="ln3632">			} else</a>
<a name="ln3633">				wme-&gt;wme_hipri_traffic = 0;</a>
<a name="ln3634">		} else {</a>
<a name="ln3635">			if (wme-&gt;wme_hipri_traffic &lt;=</a>
<a name="ln3636">			    wme-&gt;wme_hipri_switch_thresh) {</a>
<a name="ln3637">				IEEE80211_DPRINTF(vap, IEEE80211_MSG_WME,</a>
<a name="ln3638">				    &quot;%s: traffic %u, enable aggressive mode\n&quot;,</a>
<a name="ln3639">				    __func__, wme-&gt;wme_hipri_traffic);</a>
<a name="ln3640">				wme-&gt;wme_flags |= WME_F_AGGRMODE;</a>
<a name="ln3641">				ieee80211_wme_updateparams_locked(vap);</a>
<a name="ln3642">				wme-&gt;wme_hipri_traffic = 0;</a>
<a name="ln3643">			} else</a>
<a name="ln3644">				wme-&gt;wme_hipri_traffic =</a>
<a name="ln3645">					wme-&gt;wme_hipri_switch_hysteresis;</a>
<a name="ln3646">		}</a>
<a name="ln3647">		if (isset(bo-&gt;bo_flags, IEEE80211_BEACON_WME)) {</a>
<a name="ln3648">			(void) ieee80211_add_wme_param(bo-&gt;bo_wme, wme);</a>
<a name="ln3649">			clrbit(bo-&gt;bo_flags, IEEE80211_BEACON_WME);</a>
<a name="ln3650">		}</a>
<a name="ln3651">	}</a>
<a name="ln3652"> </a>
<a name="ln3653">	if (isset(bo-&gt;bo_flags,  IEEE80211_BEACON_HTINFO)) {</a>
<a name="ln3654">		ieee80211_ht_update_beacon(vap, bo);</a>
<a name="ln3655">		clrbit(bo-&gt;bo_flags, IEEE80211_BEACON_HTINFO);</a>
<a name="ln3656">	}</a>
<a name="ln3657">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln3658">	if (vap-&gt;iv_caps &amp; IEEE80211_C_TDMA) {</a>
<a name="ln3659">		/*</a>
<a name="ln3660">		 * NB: the beacon is potentially updated every TBTT.</a>
<a name="ln3661">		 */</a>
<a name="ln3662">		ieee80211_tdma_update_beacon(vap, bo);</a>
<a name="ln3663">	}</a>
<a name="ln3664">#endif</a>
<a name="ln3665">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln3666">	if (vap-&gt;iv_opmode == IEEE80211_M_MBSS)</a>
<a name="ln3667">		ieee80211_mesh_update_beacon(vap, bo);</a>
<a name="ln3668">#endif</a>
<a name="ln3669"> </a>
<a name="ln3670">	if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln3671">	    vap-&gt;iv_opmode == IEEE80211_M_MBSS) {	/* NB: no IBSS support*/</a>
<a name="ln3672">		struct ieee80211_tim_ie *tie =</a>
<a name="ln3673">			(struct ieee80211_tim_ie *) bo-&gt;bo_tim;</a>
<a name="ln3674">		if (isset(bo-&gt;bo_flags, IEEE80211_BEACON_TIM)) {</a>
<a name="ln3675">			u_int timlen, timoff, i;</a>
<a name="ln3676">			/*</a>
<a name="ln3677">			 * ATIM/DTIM needs updating.  If it fits in the</a>
<a name="ln3678">			 * current space allocated then just copy in the</a>
<a name="ln3679">			 * new bits.  Otherwise we need to move any trailing</a>
<a name="ln3680">			 * data to make room.  Note that we know there is</a>
<a name="ln3681">			 * contiguous space because ieee80211_beacon_allocate</a>
<a name="ln3682">			 * insures there is space in the mbuf to write a</a>
<a name="ln3683">			 * maximal-size virtual bitmap (based on iv_max_aid).</a>
<a name="ln3684">			 */</a>
<a name="ln3685">			/*</a>
<a name="ln3686">			 * Calculate the bitmap size and offset, copy any</a>
<a name="ln3687">			 * trailer out of the way, and then copy in the</a>
<a name="ln3688">			 * new bitmap and update the information element.</a>
<a name="ln3689">			 * Note that the tim bitmap must contain at least</a>
<a name="ln3690">			 * one byte and any offset must be even.</a>
<a name="ln3691">			 */</a>
<a name="ln3692">			if (vap-&gt;iv_ps_pending != 0) {</a>
<a name="ln3693">				timoff = 128;		/* impossibly large */</a>
<a name="ln3694">				for (i = 0; i &lt; vap-&gt;iv_tim_len; i++)</a>
<a name="ln3695">					if (vap-&gt;iv_tim_bitmap[i]) {</a>
<a name="ln3696">						timoff = i &amp;~ 1;</a>
<a name="ln3697">						break;</a>
<a name="ln3698">					}</a>
<a name="ln3699">				KASSERT(timoff != 128, (&quot;tim bitmap empty!&quot;));</a>
<a name="ln3700">				for (i = vap-&gt;iv_tim_len-1; i &gt;= timoff; i--)</a>
<a name="ln3701">					if (vap-&gt;iv_tim_bitmap[i])</a>
<a name="ln3702">						break;</a>
<a name="ln3703">				timlen = 1 + (i - timoff);</a>
<a name="ln3704">			} else {</a>
<a name="ln3705">				timoff = 0;</a>
<a name="ln3706">				timlen = 1;</a>
<a name="ln3707">			}</a>
<a name="ln3708"> </a>
<a name="ln3709">			/*</a>
<a name="ln3710">			 * TODO: validate this!</a>
<a name="ln3711">			 */</a>
<a name="ln3712">			if (timlen != bo-&gt;bo_tim_len) {</a>
<a name="ln3713">				/* copy up/down trailer */</a>
<a name="ln3714">				int adjust = tie-&gt;tim_bitmap+timlen</a>
<a name="ln3715">					   - bo-&gt;bo_tim_trailer;</a>
<a name="ln3716">				ovbcopy(bo-&gt;bo_tim_trailer,</a>
<a name="ln3717">				    bo-&gt;bo_tim_trailer+adjust,</a>
<a name="ln3718">				    bo-&gt;bo_tim_trailer_len);</a>
<a name="ln3719">				bo-&gt;bo_tim_trailer += adjust;</a>
<a name="ln3720">				bo-&gt;bo_erp += adjust;</a>
<a name="ln3721">				bo-&gt;bo_htinfo += adjust;</a>
<a name="ln3722">				bo-&gt;bo_vhtinfo += adjust;</a>
<a name="ln3723">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln3724">				bo-&gt;bo_ath += adjust;</a>
<a name="ln3725">#endif</a>
<a name="ln3726">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln3727">				bo-&gt;bo_tdma += adjust;</a>
<a name="ln3728">#endif</a>
<a name="ln3729">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln3730">				bo-&gt;bo_meshconf += adjust;</a>
<a name="ln3731">#endif</a>
<a name="ln3732">				bo-&gt;bo_appie += adjust;</a>
<a name="ln3733">				bo-&gt;bo_wme += adjust;</a>
<a name="ln3734">				bo-&gt;bo_csa += adjust;</a>
<a name="ln3735">				bo-&gt;bo_quiet += adjust;</a>
<a name="ln3736">				bo-&gt;bo_tim_len = timlen;</a>
<a name="ln3737"> </a>
<a name="ln3738">				/* update information element */</a>
<a name="ln3739">				tie-&gt;tim_len = 3 + timlen;</a>
<a name="ln3740">				tie-&gt;tim_bitctl = timoff;</a>
<a name="ln3741">				len_changed = 1;</a>
<a name="ln3742">			}</a>
<a name="ln3743">			memcpy(tie-&gt;tim_bitmap, vap-&gt;iv_tim_bitmap + timoff,</a>
<a name="ln3744">				bo-&gt;bo_tim_len);</a>
<a name="ln3745"> </a>
<a name="ln3746">			clrbit(bo-&gt;bo_flags, IEEE80211_BEACON_TIM);</a>
<a name="ln3747"> </a>
<a name="ln3748">			IEEE80211_DPRINTF(vap, IEEE80211_MSG_POWER,</a>
<a name="ln3749">				&quot;%s: TIM updated, pending %u, off %u, len %u\n&quot;,</a>
<a name="ln3750">				__func__, vap-&gt;iv_ps_pending, timoff, timlen);</a>
<a name="ln3751">		}</a>
<a name="ln3752">		/* count down DTIM period */</a>
<a name="ln3753">		if (tie-&gt;tim_count == 0)</a>
<a name="ln3754">			tie-&gt;tim_count = tie-&gt;tim_period - 1;</a>
<a name="ln3755">		else</a>
<a name="ln3756">			tie-&gt;tim_count--;</a>
<a name="ln3757">		/* update state for buffered multicast frames on DTIM */</a>
<a name="ln3758">		if (mcast &amp;&amp; tie-&gt;tim_count == 0)</a>
<a name="ln3759">			tie-&gt;tim_bitctl |= 1;</a>
<a name="ln3760">		else</a>
<a name="ln3761">			tie-&gt;tim_bitctl &amp;= ~1;</a>
<a name="ln3762">		if (isset(bo-&gt;bo_flags, IEEE80211_BEACON_CSA)) {</a>
<a name="ln3763">			struct ieee80211_csa_ie *csa =</a>
<a name="ln3764">			    (struct ieee80211_csa_ie *) bo-&gt;bo_csa;</a>
<a name="ln3765"> </a>
<a name="ln3766">			/*</a>
<a name="ln3767">			 * Insert or update CSA ie.  If we're just starting</a>
<a name="ln3768">			 * to count down to the channel switch then we need</a>
<a name="ln3769">			 * to insert the CSA ie.  Otherwise we just need to</a>
<a name="ln3770">			 * drop the count.  The actual change happens above</a>
<a name="ln3771">			 * when the vap's count reaches the target count.</a>
<a name="ln3772">			 */</a>
<a name="ln3773">			if (vap-&gt;iv_csa_count == 0) {</a>
<a name="ln3774">				memmove(&amp;csa[1], csa, bo-&gt;bo_csa_trailer_len);</a>
<a name="ln3775">				bo-&gt;bo_erp += sizeof(*csa);</a>
<a name="ln3776">				bo-&gt;bo_htinfo += sizeof(*csa);</a>
<a name="ln3777">				bo-&gt;bo_vhtinfo += sizeof(*csa);</a>
<a name="ln3778">				bo-&gt;bo_wme += sizeof(*csa);</a>
<a name="ln3779">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln3780">				bo-&gt;bo_ath += sizeof(*csa);</a>
<a name="ln3781">#endif</a>
<a name="ln3782">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln3783">				bo-&gt;bo_tdma += sizeof(*csa);</a>
<a name="ln3784">#endif</a>
<a name="ln3785">#ifdef IEEE80211_SUPPORT_MESH</a>
<a name="ln3786">				bo-&gt;bo_meshconf += sizeof(*csa);</a>
<a name="ln3787">#endif</a>
<a name="ln3788">				bo-&gt;bo_appie += sizeof(*csa);</a>
<a name="ln3789">				bo-&gt;bo_csa_trailer_len += sizeof(*csa);</a>
<a name="ln3790">				bo-&gt;bo_quiet += sizeof(*csa);</a>
<a name="ln3791">				bo-&gt;bo_tim_trailer_len += sizeof(*csa);</a>
<a name="ln3792">				m-&gt;m_len += sizeof(*csa);</a>
<a name="ln3793">				m-&gt;m_pkthdr.len += sizeof(*csa);</a>
<a name="ln3794"> </a>
<a name="ln3795">				ieee80211_add_csa(bo-&gt;bo_csa, vap);</a>
<a name="ln3796">			} else</a>
<a name="ln3797">				csa-&gt;csa_count--;</a>
<a name="ln3798">			vap-&gt;iv_csa_count++;</a>
<a name="ln3799">			/* NB: don't clear IEEE80211_BEACON_CSA */</a>
<a name="ln3800">		}</a>
<a name="ln3801"> </a>
<a name="ln3802">		/*</a>
<a name="ln3803">		 * Only add the quiet time IE if we've enabled it</a>
<a name="ln3804">		 * as appropriate.</a>
<a name="ln3805">		 */</a>
<a name="ln3806">		if (IEEE80211_IS_CHAN_DFS(ic-&gt;ic_bsschan) &amp;&amp;</a>
<a name="ln3807">		    (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_DFS)) {</a>
<a name="ln3808">			if (vap-&gt;iv_quiet &amp;&amp;</a>
<a name="ln3809">			    (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_QUIET_IE)) {</a>
<a name="ln3810">				ieee80211_add_quiet(bo-&gt;bo_quiet, vap, 1);</a>
<a name="ln3811">			}</a>
<a name="ln3812">		}</a>
<a name="ln3813">		if (isset(bo-&gt;bo_flags, IEEE80211_BEACON_ERP)) {</a>
<a name="ln3814">			/*</a>
<a name="ln3815">			 * ERP element needs updating.</a>
<a name="ln3816">			 */</a>
<a name="ln3817">			(void) ieee80211_add_erp(bo-&gt;bo_erp, ic);</a>
<a name="ln3818">			clrbit(bo-&gt;bo_flags, IEEE80211_BEACON_ERP);</a>
<a name="ln3819">		}</a>
<a name="ln3820">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln3821">		if (isset(bo-&gt;bo_flags,  IEEE80211_BEACON_ATH)) {</a>
<a name="ln3822">			ieee80211_add_athcaps(bo-&gt;bo_ath, ni);</a>
<a name="ln3823">			clrbit(bo-&gt;bo_flags, IEEE80211_BEACON_ATH);</a>
<a name="ln3824">		}</a>
<a name="ln3825">#endif</a>
<a name="ln3826">	}</a>
<a name="ln3827">	if (isset(bo-&gt;bo_flags, IEEE80211_BEACON_APPIE)) {</a>
<a name="ln3828">		const struct ieee80211_appie *aie = vap-&gt;iv_appie_beacon;</a>
<a name="ln3829">		int aielen;</a>
<a name="ln3830">		uint8_t *frm;</a>
<a name="ln3831"> </a>
<a name="ln3832">		aielen = 0;</a>
<a name="ln3833">		if (aie != NULL)</a>
<a name="ln3834">			aielen += aie-&gt;ie_len;</a>
<a name="ln3835">		if (aielen != bo-&gt;bo_appie_len) {</a>
<a name="ln3836">			/* copy up/down trailer */</a>
<a name="ln3837">			int adjust = aielen - bo-&gt;bo_appie_len;</a>
<a name="ln3838">			ovbcopy(bo-&gt;bo_tim_trailer, bo-&gt;bo_tim_trailer+adjust,</a>
<a name="ln3839">				bo-&gt;bo_tim_trailer_len);</a>
<a name="ln3840">			bo-&gt;bo_tim_trailer += adjust;</a>
<a name="ln3841">			bo-&gt;bo_appie += adjust;</a>
<a name="ln3842">			bo-&gt;bo_appie_len = aielen;</a>
<a name="ln3843"> </a>
<a name="ln3844">			len_changed = 1;</a>
<a name="ln3845">		}</a>
<a name="ln3846">		frm = bo-&gt;bo_appie;</a>
<a name="ln3847">		if (aie != NULL)</a>
<a name="ln3848">			frm  = add_appie(frm, aie);</a>
<a name="ln3849">		clrbit(bo-&gt;bo_flags, IEEE80211_BEACON_APPIE);</a>
<a name="ln3850">	}</a>
<a name="ln3851">	IEEE80211_UNLOCK(ic);</a>
<a name="ln3852"> </a>
<a name="ln3853">	return len_changed;</a>
<a name="ln3854">}</a>
<a name="ln3855"> </a>
<a name="ln3856">/*</a>
<a name="ln3857"> * Do Ethernet-LLC encapsulation for each payload in a fast frame</a>
<a name="ln3858"> * tunnel encapsulation.  The frame is assumed to have an Ethernet</a>
<a name="ln3859"> * header at the front that must be stripped before prepending the</a>
<a name="ln3860"> * LLC followed by the Ethernet header passed in (with an Ethernet</a>
<a name="ln3861"> * type that specifies the payload size).</a>
<a name="ln3862"> */</a>
<a name="ln3863">struct mbuf *</a>
<a name="ln3864">ieee80211_ff_encap1(struct ieee80211vap *vap, struct mbuf *m,</a>
<a name="ln3865">	const struct ether_header *eh)</a>
<a name="ln3866">{</a>
<a name="ln3867">	struct llc *llc;</a>
<a name="ln3868">	uint16_t payload;</a>
<a name="ln3869"> </a>
<a name="ln3870">	/* XXX optimize by combining m_adj+M_PREPEND */</a>
<a name="ln3871">	m_adj(m, sizeof(struct ether_header) - sizeof(struct llc));</a>
<a name="ln3872">	llc = mtod(m, struct llc *);</a>
<a name="ln3873">	llc-&gt;llc_dsap = llc-&gt;llc_ssap = LLC_SNAP_LSAP;</a>
<a name="ln3874">	llc-&gt;llc_control = LLC_UI;</a>
<a name="ln3875">	llc-&gt;llc_snap.org_code[0] = 0;</a>
<a name="ln3876">	llc-&gt;llc_snap.org_code[1] = 0;</a>
<a name="ln3877">	llc-&gt;llc_snap.org_code[2] = 0;</a>
<a name="ln3878">	llc-&gt;llc_snap.ether_type = eh-&gt;ether_type;</a>
<a name="ln3879">	payload = m-&gt;m_pkthdr.len;		/* NB: w/o Ethernet header */</a>
<a name="ln3880"> </a>
<a name="ln3881">	M_PREPEND(m, sizeof(struct ether_header), M_NOWAIT);</a>
<a name="ln3882">	if (m == NULL) {		/* XXX cannot happen */</a>
<a name="ln3883">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_SUPERG,</a>
<a name="ln3884">			&quot;%s: no space for ether_header\n&quot;, __func__);</a>
<a name="ln3885">		vap-&gt;iv_stats.is_tx_nobuf++;</a>
<a name="ln3886">		return NULL;</a>
<a name="ln3887">	}</a>
<a name="ln3888">	ETHER_HEADER_COPY(mtod(m, void *), eh);</a>
<a name="ln3889">	mtod(m, struct ether_header *)-&gt;ether_type = htons(payload);</a>
<a name="ln3890">	return m;</a>
<a name="ln3891">}</a>
<a name="ln3892"> </a>
<a name="ln3893">/*</a>
<a name="ln3894"> * Complete an mbuf transmission.</a>
<a name="ln3895"> *</a>
<a name="ln3896"> * For now, this simply processes a completed frame after the</a>
<a name="ln3897"> * driver has completed it's transmission and/or retransmission.</a>
<a name="ln3898"> * It assumes the frame is an 802.11 encapsulated frame.</a>
<a name="ln3899"> *</a>
<a name="ln3900"> * Later on it will grow to become the exit path for a given frame</a>
<a name="ln3901"> * from the driver and, depending upon how it's been encapsulated</a>
<a name="ln3902"> * and already transmitted, it may end up doing A-MPDU retransmission,</a>
<a name="ln3903"> * power save requeuing, etc.</a>
<a name="ln3904"> *</a>
<a name="ln3905"> * In order for the above to work, the driver entry point to this</a>
<a name="ln3906"> * must not hold any driver locks.  Thus, the driver needs to delay</a>
<a name="ln3907"> * any actual mbuf completion until it can release said locks.</a>
<a name="ln3908"> *</a>
<a name="ln3909"> * This frees the mbuf and if the mbuf has a node reference,</a>
<a name="ln3910"> * the node reference will be freed.</a>
<a name="ln3911"> */</a>
<a name="ln3912">void</a>
<a name="ln3913">ieee80211_tx_complete(struct ieee80211_node *ni, struct mbuf *m, int status)</a>
<a name="ln3914">{</a>
<a name="ln3915"> </a>
<a name="ln3916">	if (ni != NULL) {</a>
<a name="ln3917">		struct ifnet *ifp = ni-&gt;ni_vap-&gt;iv_ifp;</a>
<a name="ln3918"> </a>
<a name="ln3919">		if (status == 0) {</a>
<a name="ln3920">			if_inc_counter(ifp, IFCOUNTER_OBYTES, m-&gt;m_pkthdr.len);</a>
<a name="ln3921">			if_inc_counter(ifp, IFCOUNTER_OPACKETS, 1);</a>
<a name="ln3922">			if (m-&gt;m_flags &amp; M_MCAST)</a>
<a name="ln3923">				if_inc_counter(ifp, IFCOUNTER_OMCASTS, 1);</a>
<a name="ln3924">		} else</a>
<a name="ln3925">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln3926">		if (m-&gt;m_flags &amp; M_TXCB)</a>
<a name="ln3927">			ieee80211_process_callback(ni, m, status);</a>
<a name="ln3928">		ieee80211_free_node(ni);</a>
<a name="ln3929">	}</a>
<a name="ln3930">	m_freem(m);</a>
<a name="ln3931">}</a>

</code></pre>
<div class="balloon" rel="842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The 'ieee80211_send_setup' function processes value '16'. Inspect the fourth argument. Check lines: 842, 3026.</p></div>
<div class="balloon" rel="842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The 'ieee80211_send_setup' function processes value '16'. Inspect the fourth argument. Check lines: 842, 1027.</p></div>
<div class="balloon" rel="842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The 'ieee80211_send_setup' function processes value '16'. Inspect the fourth argument. Check lines: 842, 911.</p></div>
<div class="balloon" rel="842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The 'ieee80211_send_setup' function processes value '16'. Inspect the fourth argument. Check lines: 842, 2368.</p></div>
<div class="balloon" rel="1022"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'tid' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'tid' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 842, 843.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
