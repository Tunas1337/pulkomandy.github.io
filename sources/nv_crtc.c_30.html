
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>nv_crtc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* CTRC functionality */</a>
<a name="ln2">/* Author:</a>
<a name="ln3">   Rudolf Cornelissen 11/2002-9/2009</a>
<a name="ln4">*/</a>
<a name="ln5"> </a>
<a name="ln6">#define MODULE_BIT 0x00040000</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;nv_std.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">/*</a>
<a name="ln11">	Enable/Disable interrupts.  Just a wrapper around the</a>
<a name="ln12">	ioctl() to the kernel driver.</a>
<a name="ln13">*/</a>
<a name="ln14">status_t nv_crtc_interrupt_enable(bool flag)</a>
<a name="ln15">{</a>
<a name="ln16">	status_t result = B_OK;</a>
<a name="ln17">	nv_set_vblank_int svi;</a>
<a name="ln18"> </a>
<a name="ln19">	if (si-&gt;ps.int_assigned)</a>
<a name="ln20">	{</a>
<a name="ln21">		/* set the magic number so the driver knows we're for real */</a>
<a name="ln22">		svi.magic = NV_PRIVATE_DATA_MAGIC;</a>
<a name="ln23">		svi.crtc = 0;</a>
<a name="ln24">		svi.do_it = flag;</a>
<a name="ln25">		/* contact driver and get a pointer to the registers and shared data */</a>
<a name="ln26">		result = ioctl(fd, NV_RUN_INTERRUPTS, &amp;svi, sizeof(svi));</a>
<a name="ln27">	}</a>
<a name="ln28"> </a>
<a name="ln29">	return result;</a>
<a name="ln30">}</a>
<a name="ln31"> </a>
<a name="ln32">/* doing general fail-safe default setup here */</a>
<a name="ln33">//fixme: this is a _very_ basic setup, and it's preliminary...</a>
<a name="ln34">status_t nv_crtc_update_fifo()</a>
<a name="ln35">{</a>
<a name="ln36">	uint8 bytes_per_pixel = 1;</a>
<a name="ln37">	uint32 drain;</a>
<a name="ln38"> </a>
<a name="ln39">	/* we are only using this on &gt;&gt;coldstarted&lt;&lt; cards which really need this */</a>
<a name="ln40">	//fixme: re-enable or remove after general user confirmation of behaviour...</a>
<a name="ln41">	if (/*(si-&gt;settings.usebios) ||*/ (si-&gt;ps.card_type != NV05M64)) return B_OK;</a>
<a name="ln42"> </a>
<a name="ln43">	/* enable access to primary head */</a>
<a name="ln44">	set_crtc_owner(0);</a>
<a name="ln45"> </a>
<a name="ln46">	/* set CRTC FIFO low watermark according to memory drain */</a>
<a name="ln47">	switch(si-&gt;dm.space)</a>
<a name="ln48">	{</a>
<a name="ln49">	case B_CMAP8:</a>
<a name="ln50">		bytes_per_pixel = 1;</a>
<a name="ln51">		break;</a>
<a name="ln52">	case B_RGB15_LITTLE:</a>
<a name="ln53">	case B_RGB16_LITTLE:</a>
<a name="ln54">		bytes_per_pixel = 2;</a>
<a name="ln55">		break;</a>
<a name="ln56">	case B_RGB24_LITTLE:</a>
<a name="ln57">		bytes_per_pixel = 3;</a>
<a name="ln58">		break;</a>
<a name="ln59">	case B_RGB32_LITTLE:</a>
<a name="ln60">		bytes_per_pixel = 4;</a>
<a name="ln61">		break;</a>
<a name="ln62">	}</a>
<a name="ln63">	/* fixme:</a>
<a name="ln64">	 * - I should probably include the refreshrate as well;</a>
<a name="ln65">	 * - and the memory clocking speed, core clocking speed, RAM buswidth.. */</a>
<a name="ln66">	drain = si-&gt;dm.timing.h_display * si-&gt;dm.timing.v_display * bytes_per_pixel;</a>
<a name="ln67"> </a>
<a name="ln68">	/* Doesn't work for other than 32bit space (yet?) */</a>
<a name="ln69">	if (si-&gt;dm.space != B_RGB32_LITTLE)</a>
<a name="ln70">	{</a>
<a name="ln71">		/* BIOS defaults */</a>
<a name="ln72">		CRTCW(FIFO, 0x03);</a>
<a name="ln73">		CRTCW(FIFO_LWM, 0x20);</a>
<a name="ln74">		LOG(4,(&quot;CRTC: FIFO low-watermark set to $20, burst size 256 (BIOS defaults)\n&quot;));</a>
<a name="ln75">		return B_OK;</a>
<a name="ln76">	}</a>
<a name="ln77"> </a>
<a name="ln78">	if (drain &gt; (((uint32)1280) * 1024 * 4))</a>
<a name="ln79">	{</a>
<a name="ln80">		/* set CRTC FIFO burst size for 'smaller' bursts */</a>
<a name="ln81">		CRTCW(FIFO, 0x01);</a>
<a name="ln82">		/* Instruct CRTC to fetch new data 'earlier' */</a>
<a name="ln83">		CRTCW(FIFO_LWM, 0x40);</a>
<a name="ln84">		LOG(4,(&quot;CRTC: FIFO low-watermark set to $40, burst size 64\n&quot;));</a>
<a name="ln85">	}</a>
<a name="ln86">	else</a>
<a name="ln87">	{</a>
<a name="ln88">		if (drain &gt; (((uint32)1024) * 768 * 4))</a>
<a name="ln89">		{</a>
<a name="ln90">			/* BIOS default */</a>
<a name="ln91">			CRTCW(FIFO, 0x02);</a>
<a name="ln92">			/* Instruct CRTC to fetch new data 'earlier' */</a>
<a name="ln93">			CRTCW(FIFO_LWM, 0x40);</a>
<a name="ln94">			LOG(4,(&quot;CRTC: FIFO low-watermark set to $40, burst size 128\n&quot;));</a>
<a name="ln95">		}</a>
<a name="ln96">		else</a>
<a name="ln97">		{</a>
<a name="ln98">			/* BIOS defaults */</a>
<a name="ln99">			CRTCW(FIFO, 0x03);</a>
<a name="ln100">			CRTCW(FIFO_LWM, 0x20);</a>
<a name="ln101">			LOG(4,(&quot;CRTC: FIFO low-watermark set to $20, burst size 256 (BIOS defaults)\n&quot;));</a>
<a name="ln102">		}</a>
<a name="ln103">	}</a>
<a name="ln104"> </a>
<a name="ln105">	return B_OK;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">/* Adjust passed parameters to a valid mode line */</a>
<a name="ln109">status_t nv_crtc_validate_timing(</a>
<a name="ln110">	uint16 *hd_e,uint16 *hs_s,uint16 *hs_e,uint16 *ht,</a>
<a name="ln111">	uint16 *vd_e,uint16 *vs_s,uint16 *vs_e,uint16 *vt</a>
<a name="ln112">)</a>
<a name="ln113">{</a>
<a name="ln114">/* horizontal */</a>
<a name="ln115">	/* make all parameters multiples of 8 */</a>
<a name="ln116">	*hd_e &amp;= 0xfff8;</a>
<a name="ln117">	*hs_s &amp;= 0xfff8;</a>
<a name="ln118">	*hs_e &amp;= 0xfff8;</a>
<a name="ln119">	*ht   &amp;= 0xfff8;</a>
<a name="ln120"> </a>
<a name="ln121">	/* confine to required number of bits, taking logic into account */</a>
<a name="ln122">	if (*hd_e &gt; ((0x01ff - 2) &lt;&lt; 3)) *hd_e = ((0x01ff - 2) &lt;&lt; 3);</a>
<a name="ln123">	if (*hs_s &gt; ((0x01ff - 1) &lt;&lt; 3)) *hs_s = ((0x01ff - 1) &lt;&lt; 3);</a>
<a name="ln124">	if (*hs_e &gt; ( 0x01ff      &lt;&lt; 3)) *hs_e = ( 0x01ff      &lt;&lt; 3);</a>
<a name="ln125">	if (*ht   &gt; ((0x01ff + 5) &lt;&lt; 3)) *ht   = ((0x01ff + 5) &lt;&lt; 3);</a>
<a name="ln126"> </a>
<a name="ln127">	/* NOTE: keep horizontal timing at multiples of 8! */</a>
<a name="ln128">	/* confine to a reasonable width */</a>
<a name="ln129">	if (*hd_e &lt; 640) *hd_e = 640;</a>
<a name="ln130">	if (si-&gt;ps.card_type &gt; NV04)</a>
<a name="ln131">	{</a>
<a name="ln132">		if (*hd_e &gt; 2048) *hd_e = 2048;</a>
<a name="ln133">	}</a>
<a name="ln134">	else</a>
<a name="ln135">	{</a>
<a name="ln136">		if (*hd_e &gt; 1920) *hd_e = 1920;</a>
<a name="ln137">	}</a>
<a name="ln138"> </a>
<a name="ln139">	/* if hor. total does not leave room for a sensible sync pulse, increase it! */</a>
<a name="ln140">	if (*ht &lt; (*hd_e + 80)) *ht = (*hd_e + 80);</a>
<a name="ln141"> </a>
<a name="ln142">	/* if hor. total does not adhere to max. blanking pulse width, decrease it! */</a>
<a name="ln143">	if (*ht &gt; (*hd_e + 0x3f8)) *ht = (*hd_e + 0x3f8);</a>
<a name="ln144"> </a>
<a name="ln145">	/* make sure sync pulse is not during display */</a>
<a name="ln146">	if (*hs_e &gt; (*ht - 8)) *hs_e = (*ht - 8);</a>
<a name="ln147">	if (*hs_s &lt; (*hd_e + 8)) *hs_s = (*hd_e + 8);</a>
<a name="ln148"> </a>
<a name="ln149">	/* correct sync pulse if it is too long:</a>
<a name="ln150">	 * there are only 5 bits available to save this in the card registers! */</a>
<a name="ln151">	if (*hs_e &gt; (*hs_s + 0xf8)) *hs_e = (*hs_s + 0xf8);</a>
<a name="ln152"> </a>
<a name="ln153">/*vertical*/</a>
<a name="ln154">	/* confine to required number of bits, taking logic into account */</a>
<a name="ln155">	//fixme if needed: on GeForce cards there are 12 instead of 11 bits...</a>
<a name="ln156">	if (*vd_e &gt; (0x7ff - 2)) *vd_e = (0x7ff - 2);</a>
<a name="ln157">	if (*vs_s &gt; (0x7ff - 1)) *vs_s = (0x7ff - 1);</a>
<a name="ln158">	if (*vs_e &gt;  0x7ff     ) *vs_e =  0x7ff     ;</a>
<a name="ln159">	if (*vt   &gt; (0x7ff + 2)) *vt   = (0x7ff + 2);</a>
<a name="ln160"> </a>
<a name="ln161">	/* confine to a reasonable height */</a>
<a name="ln162">	if (*vd_e &lt; 480) *vd_e = 480;</a>
<a name="ln163">	if (si-&gt;ps.card_type &gt; NV04)</a>
<a name="ln164">	{</a>
<a name="ln165">		if (*vd_e &gt; 1536) *vd_e = 1536;</a>
<a name="ln166">	}</a>
<a name="ln167">	else</a>
<a name="ln168">	{</a>
<a name="ln169">		if (*vd_e &gt; 1440) *vd_e = 1440;</a>
<a name="ln170">	}</a>
<a name="ln171"> </a>
<a name="ln172">	/*if vertical total does not leave room for a sync pulse, increase it!*/</a>
<a name="ln173">	if (*vt &lt; (*vd_e + 3)) *vt = (*vd_e + 3);</a>
<a name="ln174"> </a>
<a name="ln175">	/* if vert. total does not adhere to max. blanking pulse width, decrease it! */</a>
<a name="ln176">	if (*vt &gt; (*vd_e + 0xff)) *vt = (*vd_e + 0xff);</a>
<a name="ln177"> </a>
<a name="ln178">	/* make sure sync pulse is not during display */</a>
<a name="ln179">	if (*vs_e &gt; (*vt - 1)) *vs_e = (*vt - 1);</a>
<a name="ln180">	if (*vs_s &lt; (*vd_e + 1)) *vs_s = (*vd_e + 1);</a>
<a name="ln181"> </a>
<a name="ln182">	/* correct sync pulse if it is too long:</a>
<a name="ln183">	 * there are only 4 bits available to save this in the card registers! */</a>
<a name="ln184">	if (*vs_e &gt; (*vs_s + 0x0f)) *vs_e = (*vs_s + 0x0f);</a>
<a name="ln185"> </a>
<a name="ln186">	return B_OK;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">/*set a mode line - inputs are in pixels*/</a>
<a name="ln190">status_t nv_crtc_set_timing(display_mode target)</a>
<a name="ln191">{</a>
<a name="ln192">	uint8 temp;</a>
<a name="ln193"> </a>
<a name="ln194">	uint32 htotal;		/*total horizontal total VCLKs*/</a>
<a name="ln195">	uint32 hdisp_e;            /*end of horizontal display (begins at 0)*/</a>
<a name="ln196">	uint32 hsync_s;            /*begin of horizontal sync pulse*/</a>
<a name="ln197">	uint32 hsync_e;            /*end of horizontal sync pulse*/</a>
<a name="ln198">	uint32 hblnk_s;            /*begin horizontal blanking*/</a>
<a name="ln199">	uint32 hblnk_e;            /*end horizontal blanking*/</a>
<a name="ln200"> </a>
<a name="ln201">	uint32 vtotal;		/*total vertical total scanlines*/</a>
<a name="ln202">	uint32 vdisp_e;            /*end of vertical display*/</a>
<a name="ln203">	uint32 vsync_s;            /*begin of vertical sync pulse*/</a>
<a name="ln204">	uint32 vsync_e;            /*end of vertical sync pulse*/</a>
<a name="ln205">	uint32 vblnk_s;            /*begin vertical blanking*/</a>
<a name="ln206">	uint32 vblnk_e;            /*end vertical blanking*/</a>
<a name="ln207"> </a>
<a name="ln208">	uint32 linecomp;	/*split screen and vdisp_e interrupt*/</a>
<a name="ln209"> </a>
<a name="ln210">	LOG(4,(&quot;CRTC: setting timing\n&quot;));</a>
<a name="ln211"> </a>
<a name="ln212">	/* setup tuned internal modeline for flatpanel if connected and active */</a>
<a name="ln213">	/* notes:</a>
<a name="ln214">	 * - the CRTC modeline must end earlier than the panel modeline to keep correct</a>
<a name="ln215">	 *   sync going;</a>
<a name="ln216">	 * - if the CRTC modeline ends too soon, pixelnoise will occur in 8 (or so) pixel</a>
<a name="ln217">	 *   wide horizontal stripes. This can be observed earliest on fullscreen overlay,</a>
<a name="ln218">	 *   and if it gets worse, also normal desktop output will suffer. The stripes</a>
<a name="ln219">	 *   are mainly visible at the left of the screen, over the entire screen height. */</a>
<a name="ln220">	if (si-&gt;ps.monitors &amp; CRTC1_TMDS)</a>
<a name="ln221">	{</a>
<a name="ln222">		LOG(2,(&quot;CRTC: DFP active: tuning modeline\n&quot;));</a>
<a name="ln223"> </a>
<a name="ln224">		/* horizontal timing */</a>
<a name="ln225">		target.timing.h_sync_start =</a>
<a name="ln226">			((uint16)((si-&gt;ps.p1_timing.h_sync_start / ((float)si-&gt;ps.p1_timing.h_display)) *</a>
<a name="ln227">			target.timing.h_display)) &amp; 0xfff8;</a>
<a name="ln228"> </a>
<a name="ln229">		target.timing.h_sync_end =</a>
<a name="ln230">			((uint16)((si-&gt;ps.p1_timing.h_sync_end / ((float)si-&gt;ps.p1_timing.h_display)) *</a>
<a name="ln231">			target.timing.h_display)) &amp; 0xfff8;</a>
<a name="ln232"> </a>
<a name="ln233">		target.timing.h_total =</a>
<a name="ln234">			(((uint16)((si-&gt;ps.p1_timing.h_total / ((float)si-&gt;ps.p1_timing.h_display)) *</a>
<a name="ln235">			target.timing.h_display)) &amp; 0xfff8) - 8;</a>
<a name="ln236"> </a>
<a name="ln237">		/* in native mode the CRTC needs some extra time to keep synced correctly;</a>
<a name="ln238">		 * OTOH the overlay unit distorts if we reserve too much time! */</a>
<a name="ln239">		if (target.timing.h_display == si-&gt;ps.p1_timing.h_display)</a>
<a name="ln240">		{</a>
<a name="ln241">			/* NV11 timing has different constraints than later cards */</a>
<a name="ln242">			if (si-&gt;ps.card_type == NV11)</a>
<a name="ln243">				target.timing.h_total -= 56;</a>
<a name="ln244">			else</a>
<a name="ln245">				/* confirmed NV34 with 1680x1050 panel */</a>
<a name="ln246">				target.timing.h_total -= 32;</a>
<a name="ln247">		}</a>
<a name="ln248"> </a>
<a name="ln249">		/* assure sync pulse is at the correct timing position */</a>
<a name="ln250">		if (target.timing.h_sync_start == target.timing.h_display)</a>
<a name="ln251">			target.timing.h_sync_start += 8;</a>
<a name="ln252">		if (target.timing.h_sync_end == target.timing.h_total)</a>
<a name="ln253">			target.timing.h_sync_end -= 8;</a>
<a name="ln254">		/* assure we (still) have a sync pulse */</a>
<a name="ln255">		if (target.timing.h_sync_start == target.timing.h_sync_end) {</a>
<a name="ln256">			if (target.timing.h_sync_end &lt; (target.timing.h_total - 8)) {</a>
<a name="ln257">				target.timing.h_sync_end += 8;</a>
<a name="ln258">			} else {</a>
<a name="ln259">				if (target.timing.h_sync_start &gt; (target.timing.h_display + 8)) {</a>
<a name="ln260">					target.timing.h_sync_start -= 8;</a>
<a name="ln261">				} else {</a>
<a name="ln262">					LOG(2,(&quot;CRTC: tuning modeline, not enough room for Hsync pulse, forcing it anyway..\n&quot;));</a>
<a name="ln263">					target.timing.h_sync_start -= 8;</a>
<a name="ln264">				}</a>
<a name="ln265">			}</a>
<a name="ln266">		}</a>
<a name="ln267"> </a>
<a name="ln268">		/* vertical timing */</a>
<a name="ln269">		target.timing.v_sync_start =</a>
<a name="ln270">			((uint16)((si-&gt;ps.p1_timing.v_sync_start / ((float)si-&gt;ps.p1_timing.v_display)) *</a>
<a name="ln271">			target.timing.v_display));</a>
<a name="ln272"> </a>
<a name="ln273">		target.timing.v_sync_end =</a>
<a name="ln274">			((uint16)((si-&gt;ps.p1_timing.v_sync_end / ((float)si-&gt;ps.p1_timing.v_display)) *</a>
<a name="ln275">			target.timing.v_display));</a>
<a name="ln276"> </a>
<a name="ln277">		target.timing.v_total =</a>
<a name="ln278">			((uint16)((si-&gt;ps.p1_timing.v_total / ((float)si-&gt;ps.p1_timing.v_display)) *</a>
<a name="ln279">			target.timing.v_display)) - 1;</a>
<a name="ln280"> </a>
<a name="ln281">		/* assure sync pulse is at the correct timing position */</a>
<a name="ln282">		if (target.timing.v_sync_start == target.timing.v_display)</a>
<a name="ln283">			target.timing.v_sync_start += 1;</a>
<a name="ln284">		if (target.timing.v_sync_end == target.timing.v_total)</a>
<a name="ln285">			target.timing.v_sync_end -= 1;</a>
<a name="ln286">		/* assure we (still) have a sync pulse */</a>
<a name="ln287">		if (target.timing.v_sync_start == target.timing.v_sync_end) {</a>
<a name="ln288">			if (target.timing.v_sync_end &lt; (target.timing.v_total - 1)) {</a>
<a name="ln289">				target.timing.v_sync_end += 1;</a>
<a name="ln290">			} else {</a>
<a name="ln291">				if (target.timing.v_sync_start &gt; (target.timing.v_display + 1)) {</a>
<a name="ln292">					target.timing.v_sync_start -= 1;</a>
<a name="ln293">				} else {</a>
<a name="ln294">					LOG(2,(&quot;CRTC: tuning modeline, not enough room for Vsync pulse, forcing it anyway..\n&quot;));</a>
<a name="ln295">					target.timing.v_sync_start -= 1;</a>
<a name="ln296">				}</a>
<a name="ln297">			}</a>
<a name="ln298">		}</a>
<a name="ln299"> </a>
<a name="ln300">		/* disable GPU scaling testmode so automatic scaling will be done */</a>
<a name="ln301">		DACW(FP_DEBUG1, 0);</a>
<a name="ln302">	}</a>
<a name="ln303"> </a>
<a name="ln304">	/* Modify parameters as required by standard VGA */</a>
<a name="ln305">	htotal = ((target.timing.h_total &gt;&gt; 3) - 5);</a>
<a name="ln306">	hdisp_e = ((target.timing.h_display &gt;&gt; 3) - 1);</a>
<a name="ln307">	hblnk_s = hdisp_e;</a>
<a name="ln308">	hblnk_e = (htotal + 4);</a>
<a name="ln309">	hsync_s = (target.timing.h_sync_start &gt;&gt; 3);</a>
<a name="ln310">	hsync_e = (target.timing.h_sync_end &gt;&gt; 3);</a>
<a name="ln311"> </a>
<a name="ln312">	vtotal = target.timing.v_total - 2;</a>
<a name="ln313">	vdisp_e = target.timing.v_display - 1;</a>
<a name="ln314">	vblnk_s = vdisp_e;</a>
<a name="ln315">	vblnk_e = (vtotal + 1);</a>
<a name="ln316">	vsync_s = target.timing.v_sync_start;</a>
<a name="ln317">	vsync_e = target.timing.v_sync_end;</a>
<a name="ln318"> </a>
<a name="ln319">	/* prevent memory adress counter from being reset (linecomp may not occur) */</a>
<a name="ln320">	linecomp = target.timing.v_display;</a>
<a name="ln321"> </a>
<a name="ln322">	/* enable access to primary head */</a>
<a name="ln323">	set_crtc_owner(0);</a>
<a name="ln324"> </a>
<a name="ln325">	/* Note for laptop and DVI flatpanels:</a>
<a name="ln326">	 * CRTC timing has a seperate set of registers from flatpanel timing.</a>
<a name="ln327">	 * The flatpanel timing registers have scaling registers that are used to match</a>
<a name="ln328">	 * these two modelines. */</a>
<a name="ln329">	{</a>
<a name="ln330">		LOG(4,(&quot;CRTC: Setting full timing...\n&quot;));</a>
<a name="ln331"> </a>
<a name="ln332">		/* log the mode that will be set */</a>
<a name="ln333">		LOG(2,(&quot;CRTC:\n\tHTOT:%x\n\tHDISPEND:%x\n\tHBLNKS:%x\n\tHBLNKE:%x\n\tHSYNCS:%x\n\tHSYNCE:%x\n\t&quot;,htotal,hdisp_e,hblnk_s,hblnk_e,hsync_s,hsync_e));</a>
<a name="ln334">		LOG(2,(&quot;VTOT:%x\n\tVDISPEND:%x\n\tVBLNKS:%x\n\tVBLNKE:%x\n\tVSYNCS:%x\n\tVSYNCE:%x\n&quot;,vtotal,vdisp_e,vblnk_s,vblnk_e,vsync_s,vsync_e));</a>
<a name="ln335"> </a>
<a name="ln336">		/* actually program the card! */</a>
<a name="ln337">		/* unlock CRTC registers at index 0-7 */</a>
<a name="ln338">		CRTCW(VSYNCE, (CRTCR(VSYNCE) &amp; 0x7f));</a>
<a name="ln339">		/* horizontal standard VGA regs */</a>
<a name="ln340">		CRTCW(HTOTAL, (htotal &amp; 0xff));</a>
<a name="ln341">		CRTCW(HDISPE, (hdisp_e &amp; 0xff));</a>
<a name="ln342">		CRTCW(HBLANKS, (hblnk_s &amp; 0xff));</a>
<a name="ln343">		/* also unlock vertical retrace registers in advance */</a>
<a name="ln344">		CRTCW(HBLANKE, ((hblnk_e &amp; 0x1f) | 0x80));</a>
<a name="ln345">		CRTCW(HSYNCS, (hsync_s &amp; 0xff));</a>
<a name="ln346">		CRTCW(HSYNCE, ((hsync_e &amp; 0x1f) | ((hblnk_e &amp; 0x20) &lt;&lt; 2)));</a>
<a name="ln347"> </a>
<a name="ln348">		/* vertical standard VGA regs */</a>
<a name="ln349">		CRTCW(VTOTAL, (vtotal &amp; 0xff));</a>
<a name="ln350">		CRTCW(OVERFLOW,</a>
<a name="ln351">		(</a>
<a name="ln352">			((vtotal &amp; 0x100) &gt;&gt; (8 - 0)) | ((vtotal &amp; 0x200) &gt;&gt; (9 - 5)) |</a>
<a name="ln353">			((vdisp_e &amp; 0x100) &gt;&gt; (8 - 1)) | ((vdisp_e &amp; 0x200) &gt;&gt; (9 - 6)) |</a>
<a name="ln354">			((vsync_s &amp; 0x100) &gt;&gt; (8 - 2)) | ((vsync_s &amp; 0x200) &gt;&gt; (9 - 7)) |</a>
<a name="ln355">			((vblnk_s &amp; 0x100) &gt;&gt; (8 - 3)) | ((linecomp &amp; 0x100) &gt;&gt; (8 - 4))</a>
<a name="ln356">		));</a>
<a name="ln357">		CRTCW(PRROWSCN, 0x00); /* not used */</a>
<a name="ln358">		CRTCW(MAXSCLIN, (((vblnk_s &amp; 0x200) &gt;&gt; (9 - 5)) | ((linecomp &amp; 0x200) &gt;&gt; (9 - 6))));</a>
<a name="ln359">		CRTCW(VSYNCS, (vsync_s &amp; 0xff));</a>
<a name="ln360">		CRTCW(VSYNCE, ((CRTCR(VSYNCE) &amp; 0xf0) | (vsync_e &amp; 0x0f)));</a>
<a name="ln361">		CRTCW(VDISPE, (vdisp_e &amp; 0xff));</a>
<a name="ln362">		CRTCW(VBLANKS, (vblnk_s &amp; 0xff));</a>
<a name="ln363">		CRTCW(VBLANKE, (vblnk_e &amp; 0xff));</a>
<a name="ln364">		CRTCW(LINECOMP, (linecomp &amp; 0xff));</a>
<a name="ln365"> </a>
<a name="ln366">		/* horizontal extended regs */</a>
<a name="ln367">		//fixme: we reset bit4. is this correct??</a>
<a name="ln368">		CRTCW(HEB, (CRTCR(HEB) &amp; 0xe0) |</a>
<a name="ln369">			(</a>
<a name="ln370">		 	((htotal &amp; 0x100) &gt;&gt; (8 - 0)) |</a>
<a name="ln371">			((hdisp_e &amp; 0x100) &gt;&gt; (8 - 1)) |</a>
<a name="ln372">			((hblnk_s &amp; 0x100) &gt;&gt; (8 - 2)) |</a>
<a name="ln373">			((hsync_s &amp; 0x100) &gt;&gt; (8 - 3))</a>
<a name="ln374">			));</a>
<a name="ln375"> </a>
<a name="ln376">		/* (mostly) vertical extended regs */</a>
<a name="ln377">		CRTCW(LSR,</a>
<a name="ln378">			(</a>
<a name="ln379">		 	((vtotal &amp; 0x400) &gt;&gt; (10 - 0)) |</a>
<a name="ln380">			((vdisp_e &amp; 0x400) &gt;&gt; (10 - 1)) |</a>
<a name="ln381">			((vsync_s &amp; 0x400) &gt;&gt; (10 - 2)) |</a>
<a name="ln382">			((vblnk_s &amp; 0x400) &gt;&gt; (10 - 3)) |</a>
<a name="ln383">			((hblnk_e &amp; 0x040) &gt;&gt; (6 - 4))</a>
<a name="ln384">			//fixme: we still miss one linecomp bit!?! is this it??</a>
<a name="ln385">			//| ((linecomp &amp; 0x400) &gt;&gt; 3)	</a>
<a name="ln386">			));</a>
<a name="ln387"> </a>
<a name="ln388">		/* more vertical extended regs (on GeForce cards only) */</a>
<a name="ln389">		if (si-&gt;ps.card_arch &gt;= NV10A)</a>
<a name="ln390">		{ </a>
<a name="ln391">			CRTCW(EXTRA,</a>
<a name="ln392">				(</a>
<a name="ln393">			 	((vtotal &amp; 0x800) &gt;&gt; (11 - 0)) |</a>
<a name="ln394">				((vdisp_e &amp; 0x800) &gt;&gt; (11 - 2)) |</a>
<a name="ln395">				((vsync_s &amp; 0x800) &gt;&gt; (11 - 4)) |</a>
<a name="ln396">				((vblnk_s &amp; 0x800) &gt;&gt; (11 - 6))</a>
<a name="ln397">				//fixme: do we miss another linecomp bit!?!</a>
<a name="ln398">				));</a>
<a name="ln399">		}</a>
<a name="ln400"> </a>
<a name="ln401">		/* setup 'large screen' mode */</a>
<a name="ln402">		if (target.timing.h_display &gt;= 1280)</a>
<a name="ln403">			CRTCW(REPAINT1, (CRTCR(REPAINT1) &amp; 0xfb));</a>
<a name="ln404">		else</a>
<a name="ln405">			CRTCW(REPAINT1, (CRTCR(REPAINT1) | 0x04));</a>
<a name="ln406"> </a>
<a name="ln407">		/* setup HSYNC &amp; VSYNC polarity */</a>
<a name="ln408">		LOG(2,(&quot;CRTC: sync polarity: &quot;));</a>
<a name="ln409">		temp = NV_REG8(NV8_MISCR);</a>
<a name="ln410">		if (target.timing.flags &amp; B_POSITIVE_HSYNC)</a>
<a name="ln411">		{</a>
<a name="ln412">			LOG(2,(&quot;H:pos &quot;));</a>
<a name="ln413">			temp &amp;= ~0x40;</a>
<a name="ln414">		}</a>
<a name="ln415">		else</a>
<a name="ln416">		{</a>
<a name="ln417">			LOG(2,(&quot;H:neg &quot;));</a>
<a name="ln418">			temp |= 0x40;</a>
<a name="ln419">		}</a>
<a name="ln420">		if (target.timing.flags &amp; B_POSITIVE_VSYNC)</a>
<a name="ln421">		{</a>
<a name="ln422">			LOG(2,(&quot;V:pos &quot;));</a>
<a name="ln423">			temp &amp;= ~0x80;</a>
<a name="ln424">		}</a>
<a name="ln425">		else</a>
<a name="ln426">		{</a>
<a name="ln427">			LOG(2,(&quot;V:neg &quot;));</a>
<a name="ln428">			temp |= 0x80;</a>
<a name="ln429">		}</a>
<a name="ln430">		NV_REG8(NV8_MISCW) = temp;</a>
<a name="ln431"> </a>
<a name="ln432">		LOG(2,(&quot;, MISC reg readback: $%02x\n&quot;, NV_REG8(NV8_MISCR)));</a>
<a name="ln433">	}</a>
<a name="ln434"> </a>
<a name="ln435">	/* always disable interlaced operation */</a>
<a name="ln436">	/* (interlace is supported on upto and including NV10, NV15, and NV30 and up) */</a>
<a name="ln437">	CRTCW(INTERLACE, 0xff);</a>
<a name="ln438"> </a>
<a name="ln439">	/* disable CRTC slaved mode unless a panel is in use */</a>
<a name="ln440">	// fixme: this kills TVout when it was in use...</a>
<a name="ln441">	if (!(si-&gt;ps.monitors &amp; CRTC1_TMDS)) CRTCW(PIXEL, (CRTCR(PIXEL) &amp; 0x7f));</a>
<a name="ln442"> </a>
<a name="ln443">	/* setup flatpanel if connected and active */</a>
<a name="ln444">	if (si-&gt;ps.monitors &amp; CRTC1_TMDS)</a>
<a name="ln445">	{</a>
<a name="ln446">		uint32 iscale_x, iscale_y;</a>
<a name="ln447"> </a>
<a name="ln448">		/* calculate inverse scaling factors used by hardware in 20.12 format */</a>
<a name="ln449">		iscale_x = (((1 &lt;&lt; 12) * target.timing.h_display) / si-&gt;ps.p1_timing.h_display);</a>
<a name="ln450">		iscale_y = (((1 &lt;&lt; 12) * target.timing.v_display) / si-&gt;ps.p1_timing.v_display);</a>
<a name="ln451"> </a>
<a name="ln452">		/* unblock flatpanel timing programming (or something like that..) */</a>
<a name="ln453">		CRTCW(FP_HTIMING, 0);</a>
<a name="ln454">		CRTCW(FP_VTIMING, 0);</a>
<a name="ln455">		LOG(2,(&quot;CRTC: FP_HTIMING reg readback: $%02x\n&quot;, CRTCR(FP_HTIMING)));</a>
<a name="ln456">		LOG(2,(&quot;CRTC: FP_VTIMING reg readback: $%02x\n&quot;, CRTCR(FP_VTIMING)));</a>
<a name="ln457"> </a>
<a name="ln458">		/* enable full width visibility on flatpanel */</a>
<a name="ln459">		DACW(FP_HVALID_S, 0);</a>
<a name="ln460">		DACW(FP_HVALID_E, (si-&gt;ps.p1_timing.h_display - 1));</a>
<a name="ln461">		/* enable full height visibility on flatpanel */</a>
<a name="ln462">		DACW(FP_VVALID_S, 0);</a>
<a name="ln463">		DACW(FP_VVALID_E, (si-&gt;ps.p1_timing.v_display - 1));</a>
<a name="ln464"> </a>
<a name="ln465">		/* nVidia cards support upscaling except on ??? */</a>
<a name="ln466">		/* NV11 cards can upscale after all! */</a>
<a name="ln467">		if (0)//si-&gt;ps.card_type == NV11)</a>
<a name="ln468">		{</a>
<a name="ln469">			/* disable last fetched line limiting */</a>
<a name="ln470">			DACW(FP_DEBUG2, 0x00000000);</a>
<a name="ln471">			/* inform panel to scale if needed */</a>
<a name="ln472">			if ((iscale_x != (1 &lt;&lt; 12)) || (iscale_y != (1 &lt;&lt; 12)))</a>
<a name="ln473">			{</a>
<a name="ln474">				LOG(2,(&quot;CRTC: DFP needs to do scaling\n&quot;));</a>
<a name="ln475">				DACW(FP_TG_CTRL, (DACR(FP_TG_CTRL) | 0x00000100));</a>
<a name="ln476">			}</a>
<a name="ln477">			else</a>
<a name="ln478">			{</a>
<a name="ln479">				LOG(2,(&quot;CRTC: no scaling for DFP needed\n&quot;));</a>
<a name="ln480">				DACW(FP_TG_CTRL, (DACR(FP_TG_CTRL) &amp; 0xfffffeff));</a>
<a name="ln481">			}</a>
<a name="ln482">		}</a>
<a name="ln483">		else</a>
<a name="ln484">		{</a>
<a name="ln485">			float dm_aspect;</a>
<a name="ln486"> </a>
<a name="ln487">			LOG(2,(&quot;CRTC: GPU scales for DFP if needed\n&quot;));</a>
<a name="ln488"> </a>
<a name="ln489">			/* calculate display mode aspect */</a>
<a name="ln490">			dm_aspect = (target.timing.h_display / ((float)target.timing.v_display));</a>
<a name="ln491"> </a>
<a name="ln492">			/* limit last fetched line if vertical scaling is done */</a>
<a name="ln493">			if (iscale_y != (1 &lt;&lt; 12))</a>
<a name="ln494">				DACW(FP_DEBUG2, ((1 &lt;&lt; 28) | ((target.timing.v_display - 1) &lt;&lt; 16)));</a>
<a name="ln495">			else</a>
<a name="ln496">				DACW(FP_DEBUG2, 0x00000000);</a>
<a name="ln497"> </a>
<a name="ln498">			/* inform panel not to scale */</a>
<a name="ln499">			DACW(FP_TG_CTRL, (DACR(FP_TG_CTRL) &amp; 0xfffffeff));</a>
<a name="ln500"> </a>
<a name="ln501">			/* GPU scaling is automatically setup by hardware, so only modify this</a>
<a name="ln502">			 * scalingfactor for non 4:3 (1.33) aspect panels;</a>
<a name="ln503">			 * let's consider 1280x1024 1:33 aspect (it's 1.25 aspect actually!) */</a>
<a name="ln504"> </a>
<a name="ln505">			/* correct for widescreen panels relative to mode...</a>
<a name="ln506">			 * (so if panel is more widescreen than mode being set) */</a>
<a name="ln507">			/* BTW: known widescreen panels:</a>
<a name="ln508">			 * 1280 x  800 (1.60),</a>
<a name="ln509">			 * 1440 x  900 (1.60),</a>
<a name="ln510">			 * 1680 x 1050 (1.60),</a>
<a name="ln511">			 * 1920 x 1200 (1.60). */</a>
<a name="ln512">			/* known 4:3 aspect non-standard resolution panels:</a>
<a name="ln513">			 * 1400 x 1050 (1.33). */</a>
<a name="ln514">			/* NOTE:</a>
<a name="ln515">			 * allow 0.10 difference so 1280x1024 panels will be used fullscreen! */</a>
<a name="ln516">			if ((iscale_x != (1 &lt;&lt; 12)) &amp;&amp; (si-&gt;ps.crtc1_screen.aspect &gt; (dm_aspect + 0.10)))</a>
<a name="ln517">			{</a>
<a name="ln518">				uint16 diff;</a>
<a name="ln519"> </a>
<a name="ln520">				LOG(2,(&quot;CRTC: (relative) widescreen panel: tuning horizontal scaling\n&quot;));</a>
<a name="ln521"> </a>
<a name="ln522">				/* X-scaling should be the same as Y-scaling */</a>
<a name="ln523">				iscale_x = iscale_y;</a>
<a name="ln524">				/* enable testmode (b12) and program modified X-scaling factor */</a>
<a name="ln525">				DACW(FP_DEBUG1, (((iscale_x &gt;&gt; 1) &amp; 0x00000fff) | (1 &lt;&lt; 12)));</a>
<a name="ln526">				/* center/cut-off left and right side of screen */</a>
<a name="ln527">				diff = ((si-&gt;ps.p1_timing.h_display -</a>
<a name="ln528">						((target.timing.h_display * (1 &lt;&lt; 12)) / iscale_x))</a>
<a name="ln529">						/ 2);</a>
<a name="ln530">				DACW(FP_HVALID_S, diff);</a>
<a name="ln531">				DACW(FP_HVALID_E, ((si-&gt;ps.p1_timing.h_display - diff) - 1));</a>
<a name="ln532">			}</a>
<a name="ln533">			/* correct for portrait panels... */</a>
<a name="ln534">			/* NOTE:</a>
<a name="ln535">			 * allow 0.10 difference so 1280x1024 panels will be used fullscreen! */</a>
<a name="ln536">			if ((iscale_y != (1 &lt;&lt; 12)) &amp;&amp; (si-&gt;ps.crtc1_screen.aspect &lt; (dm_aspect - 0.10)))</a>
<a name="ln537">			{</a>
<a name="ln538">				LOG(2,(&quot;CRTC: (relative) portrait panel: should tune vertical scaling\n&quot;));</a>
<a name="ln539">				/* fixme: implement if this kind of portrait panels exist on nVidia... */</a>
<a name="ln540">			}</a>
<a name="ln541">		}</a>
<a name="ln542"> </a>
<a name="ln543">		/* do some logging.. */</a>
<a name="ln544">		LOG(2,(&quot;CRTC: FP_HVALID_S reg readback: $%08x\n&quot;, DACR(FP_HVALID_S)));</a>
<a name="ln545">		LOG(2,(&quot;CRTC: FP_HVALID_E reg readback: $%08x\n&quot;, DACR(FP_HVALID_E)));</a>
<a name="ln546">		LOG(2,(&quot;CRTC: FP_VVALID_S reg readback: $%08x\n&quot;, DACR(FP_VVALID_S)));</a>
<a name="ln547">		LOG(2,(&quot;CRTC: FP_VVALID_E reg readback: $%08x\n&quot;, DACR(FP_VVALID_E)));</a>
<a name="ln548">		LOG(2,(&quot;CRTC: FP_DEBUG0 reg readback: $%08x\n&quot;, DACR(FP_DEBUG0)));</a>
<a name="ln549">		LOG(2,(&quot;CRTC: FP_DEBUG1 reg readback: $%08x\n&quot;, DACR(FP_DEBUG1)));</a>
<a name="ln550">		LOG(2,(&quot;CRTC: FP_DEBUG2 reg readback: $%08x\n&quot;, DACR(FP_DEBUG2)));</a>
<a name="ln551">		LOG(2,(&quot;CRTC: FP_DEBUG3 reg readback: $%08x\n&quot;, DACR(FP_DEBUG3)));</a>
<a name="ln552">		LOG(2,(&quot;CRTC: FP_TG_CTRL reg readback: $%08x\n&quot;, DACR(FP_TG_CTRL)));</a>
<a name="ln553">	}</a>
<a name="ln554"> </a>
<a name="ln555">	return B_OK;</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">status_t nv_crtc_depth(int mode)</a>
<a name="ln559">{</a>
<a name="ln560">	uint8 viddelay = 0;</a>
<a name="ln561">	uint32 genctrl = 0;</a>
<a name="ln562"> </a>
<a name="ln563">	/* set VCLK scaling */</a>
<a name="ln564">	switch(mode)</a>
<a name="ln565">	{</a>
<a name="ln566">	case BPP8:</a>
<a name="ln567">		viddelay = 0x01;</a>
<a name="ln568">		/* genctrl b4 &amp; b5 reset: 'direct mode' */</a>
<a name="ln569">		genctrl = 0x00101100;</a>
<a name="ln570">		break;</a>
<a name="ln571">	case BPP15:</a>
<a name="ln572">		viddelay = 0x02;</a>
<a name="ln573">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln574">		genctrl = 0x00100130;</a>
<a name="ln575">		break;</a>
<a name="ln576">	case BPP16:</a>
<a name="ln577">		viddelay = 0x02;</a>
<a name="ln578">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln579">		genctrl = 0x00101130;</a>
<a name="ln580">		break;</a>
<a name="ln581">	case BPP24:</a>
<a name="ln582">		viddelay = 0x03;</a>
<a name="ln583">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln584">		genctrl = 0x00100130;</a>
<a name="ln585">		break;</a>
<a name="ln586">	case BPP32:</a>
<a name="ln587">		viddelay = 0x03;</a>
<a name="ln588">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln589">		genctrl = 0x00101130;</a>
<a name="ln590">		break;</a>
<a name="ln591">	}</a>
<a name="ln592">	/* enable access to primary head */</a>
<a name="ln593">	set_crtc_owner(0);</a>
<a name="ln594"> </a>
<a name="ln595">	CRTCW(PIXEL, ((CRTCR(PIXEL) &amp; 0xfc) | viddelay));</a>
<a name="ln596">	DACW(GENCTRL, genctrl);</a>
<a name="ln597"> </a>
<a name="ln598">	return B_OK;</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">status_t nv_crtc_dpms(bool display, bool h, bool v, bool do_panel)</a>
<a name="ln602">{</a>
<a name="ln603">	uint8 temp;</a>
<a name="ln604">	char msg[100];</a>
<a name="ln605"> </a>
<a name="ln606">	strlcpy(msg, &quot;CRTC: setting DPMS: &quot;, sizeof(msg));</a>
<a name="ln607"> </a>
<a name="ln608">	/* enable access to primary head */</a>
<a name="ln609">	set_crtc_owner(0);</a>
<a name="ln610"> </a>
<a name="ln611">	/* start synchronous reset: required before turning screen off! */</a>
<a name="ln612">	SEQW(RESET, 0x01);</a>
<a name="ln613"> </a>
<a name="ln614">	temp = SEQR(CLKMODE);</a>
<a name="ln615">	if (display)</a>
<a name="ln616">	{</a>
<a name="ln617">		/* turn screen on */</a>
<a name="ln618">		SEQW(CLKMODE, (temp &amp; ~0x20));</a>
<a name="ln619"> </a>
<a name="ln620">		/* end synchronous reset because display should be enabled */</a>
<a name="ln621">		SEQW(RESET, 0x03);</a>
<a name="ln622"> </a>
<a name="ln623">		if (do_panel &amp;&amp; (si-&gt;ps.monitors &amp; CRTC1_TMDS))</a>
<a name="ln624">		{</a>
<a name="ln625">			if (!si-&gt;ps.laptop)</a>
<a name="ln626">			{</a>
<a name="ln627">				/* restore original panelsync and panel-enable */</a>
<a name="ln628">				uint32 panelsync = 0x00000000;</a>
<a name="ln629">				if(si-&gt;ps.p1_timing.flags &amp; B_POSITIVE_VSYNC) panelsync |= 0x00000001;</a>
<a name="ln630">				if(si-&gt;ps.p1_timing.flags &amp; B_POSITIVE_HSYNC) panelsync |= 0x00000010;</a>
<a name="ln631">				/* display enable polarity (not an official flag) */</a>
<a name="ln632">				if(si-&gt;ps.p1_timing.flags &amp; B_BLANK_PEDESTAL) panelsync |= 0x10000000;</a>
<a name="ln633">				DACW(FP_TG_CTRL, ((DACR(FP_TG_CTRL) &amp; 0xcfffffcc) | panelsync));</a>
<a name="ln634"> </a>
<a name="ln635">				//fixme?: looks like we don't need this after all:</a>
<a name="ln636">				/* powerup both LVDS (laptop panellink) and TMDS (DVI panellink)</a>
<a name="ln637">				 * internal transmitters... */</a>
<a name="ln638">				/* note:</a>
<a name="ln639">				 * the powerbits in this register are hardwired to the DVI connectors,</a>
<a name="ln640">				 * instead of to the DACs! (confirmed NV34) */</a>
<a name="ln641">				//fixme...</a>
<a name="ln642">				//DACW(FP_DEBUG0, (DACR(FP_DEBUG0) &amp; 0xcfffffff));</a>
<a name="ln643">				/* ... and powerup external TMDS transmitter if it exists */</a>
<a name="ln644">				/* (confirmed OK on NV28 and NV34) */</a>
<a name="ln645">				//CRTCW(0x59, (CRTCR(0x59) | 0x01));</a>
<a name="ln646"> </a>
<a name="ln647">				strlcat(msg, &quot;(panel-)&quot;, sizeof(msg));</a>
<a name="ln648">			}</a>
<a name="ln649">			else</a>
<a name="ln650">			{</a>
<a name="ln651">				//fixme? linux only does this on dualhead cards...</a>
<a name="ln652">				//fixme: see if LVDS head can be determined with two panels there...</a>
<a name="ln653">				if (!(si-&gt;ps.monitors &amp; CRTC2_TMDS) &amp;&amp; (si-&gt;ps.card_type != NV11))</a>
<a name="ln654">				{</a>
<a name="ln655">					/* b2 = 0 = enable laptop panel backlight */</a>
<a name="ln656">					/* note: this seems to be a write-only register. */</a>
<a name="ln657">					NV_REG32(NV32_LVDS_PWR) = 0x00000003;</a>
<a name="ln658"> </a>
<a name="ln659">					strlcat(msg, &quot;(panel-)&quot;, sizeof(msg));</a>
<a name="ln660">				}</a>
<a name="ln661">			}</a>
<a name="ln662">		}</a>
<a name="ln663"> </a>
<a name="ln664">		strlcat(msg, &quot;display on, &quot;, sizeof(msg));</a>
<a name="ln665">	}</a>
<a name="ln666">	else</a>
<a name="ln667">	{</a>
<a name="ln668">		/* turn screen off */</a>
<a name="ln669">		SEQW(CLKMODE, (temp | 0x20));</a>
<a name="ln670"> </a>
<a name="ln671">		if (do_panel &amp;&amp; (si-&gt;ps.monitors &amp; CRTC1_TMDS))</a>
<a name="ln672">		{</a>
<a name="ln673">			if (!si-&gt;ps.laptop)</a>
<a name="ln674">			{</a>
<a name="ln675">				/* shutoff panelsync and disable panel */</a>
<a name="ln676">				DACW(FP_TG_CTRL, ((DACR(FP_TG_CTRL) &amp; 0xcfffffcc) | 0x20000022));</a>
<a name="ln677"> </a>
<a name="ln678">				//fixme?: looks like we don't need this after all:</a>
<a name="ln679">				/* powerdown both LVDS (laptop panellink) and TMDS (DVI panellink)</a>
<a name="ln680">				 * internal transmitters... */</a>
<a name="ln681">				/* note:</a>
<a name="ln682">				 * the powerbits in this register are hardwired to the DVI connectors,</a>
<a name="ln683">				 * instead of to the DACs! (confirmed NV34) */</a>
<a name="ln684">				//fixme...</a>
<a name="ln685">				//DACW(FP_DEBUG0, (DACR(FP_DEBUG0) | 0x30000000));</a>
<a name="ln686">				/* ... and powerdown external TMDS transmitter if it exists */</a>
<a name="ln687">				/* (confirmed OK on NV28 and NV34) */</a>
<a name="ln688">				//CRTCW(0x59, (CRTCR(0x59) &amp; 0xfe));</a>
<a name="ln689"> </a>
<a name="ln690">				strlcat(msg, &quot;(panel-)&quot;, sizeof(msg));</a>
<a name="ln691">			}</a>
<a name="ln692">			else</a>
<a name="ln693">			{</a>
<a name="ln694">				//fixme? linux only does this on dualhead cards...</a>
<a name="ln695">				//fixme: see if LVDS head can be determined with two panels there...</a>
<a name="ln696">				if (!(si-&gt;ps.monitors &amp; CRTC2_TMDS) &amp;&amp; (si-&gt;ps.card_type != NV11))</a>
<a name="ln697">				{</a>
<a name="ln698">					/* b2 = 1 = disable laptop panel backlight */</a>
<a name="ln699">					/* note: this seems to be a write-only register. */</a>
<a name="ln700">					NV_REG32(NV32_LVDS_PWR) = 0x00000007;</a>
<a name="ln701"> </a>
<a name="ln702">					strlcat(msg, &quot;(panel-)&quot;, sizeof(msg));</a>
<a name="ln703">				}</a>
<a name="ln704">			}</a>
<a name="ln705">		}</a>
<a name="ln706"> </a>
<a name="ln707">		strlcat(msg, &quot;display off, &quot;, sizeof(msg));</a>
<a name="ln708">	}</a>
<a name="ln709"> </a>
<a name="ln710">	if (h)</a>
<a name="ln711">	{</a>
<a name="ln712">		CRTCW(REPAINT1, (CRTCR(REPAINT1) &amp; 0x7f));</a>
<a name="ln713">		strlcat(msg, &quot;hsync enabled, &quot;, sizeof(msg));</a>
<a name="ln714">	}</a>
<a name="ln715">	else</a>
<a name="ln716">	{</a>
<a name="ln717">		CRTCW(REPAINT1, (CRTCR(REPAINT1) | 0x80));</a>
<a name="ln718">		strlcat(msg, &quot;hsync disabled, &quot;, sizeof(msg));</a>
<a name="ln719">	}</a>
<a name="ln720">	if (v)</a>
<a name="ln721">	{</a>
<a name="ln722">		CRTCW(REPAINT1, (CRTCR(REPAINT1) &amp; 0xbf));</a>
<a name="ln723">		strlcat(msg, &quot;vsync enabled\n&quot;, sizeof(msg));</a>
<a name="ln724">	}</a>
<a name="ln725">	else</a>
<a name="ln726">	{</a>
<a name="ln727">		CRTCW(REPAINT1, (CRTCR(REPAINT1) | 0x40));</a>
<a name="ln728">		strlcat(msg, &quot;vsync disabled\n&quot;, sizeof(msg));</a>
<a name="ln729">	}</a>
<a name="ln730"> </a>
<a name="ln731">	LOG(4, (msg));</a>
<a name="ln732"> </a>
<a name="ln733">	return B_OK;</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">status_t nv_crtc_set_display_pitch() </a>
<a name="ln737">{</a>
<a name="ln738">	uint32 offset;</a>
<a name="ln739"> </a>
<a name="ln740">	LOG(4,(&quot;CRTC: setting card pitch (offset between lines)\n&quot;));</a>
<a name="ln741"> </a>
<a name="ln742">	/* figure out offset value hardware needs */</a>
<a name="ln743">	offset = si-&gt;fbc.bytes_per_row / 8;</a>
<a name="ln744"> </a>
<a name="ln745">	LOG(2,(&quot;CRTC: offset register set to: $%04x\n&quot;, offset));</a>
<a name="ln746"> </a>
<a name="ln747">	/* enable access to primary head */</a>
<a name="ln748">	set_crtc_owner(0);</a>
<a name="ln749"> </a>
<a name="ln750">	/* program the card */</a>
<a name="ln751">	CRTCW(PITCHL, (offset &amp; 0x00ff));</a>
<a name="ln752">	CRTCW(REPAINT0, ((CRTCR(REPAINT0) &amp; 0x1f) | ((offset &amp; 0x0700) &gt;&gt; 3)));</a>
<a name="ln753"> </a>
<a name="ln754">	return B_OK;</a>
<a name="ln755">}</a>
<a name="ln756"> </a>
<a name="ln757">status_t nv_crtc_set_display_start(uint32 startadd,uint8 bpp) </a>
<a name="ln758">{</a>
<a name="ln759">	uint8 temp;</a>
<a name="ln760">	uint32 timeout = 0;</a>
<a name="ln761"> </a>
<a name="ln762">	LOG(4,(&quot;CRTC: setting card RAM to be displayed bpp %d\n&quot;, bpp));</a>
<a name="ln763"> </a>
<a name="ln764">	LOG(2,(&quot;CRTC: startadd: $%08x\n&quot;, startadd));</a>
<a name="ln765">	LOG(2,(&quot;CRTC: frameRAM: $%08x\n&quot;, si-&gt;framebuffer));</a>
<a name="ln766">	LOG(2,(&quot;CRTC: framebuffer: $%08x\n&quot;, si-&gt;fbc.frame_buffer));</a>
<a name="ln767"> </a>
<a name="ln768">	/* we might have no retraces during setmode! */</a>
<a name="ln769">	/* wait 25mS max. for retrace to occur (refresh &gt; 40Hz) */</a>
<a name="ln770">	while (((NV_REG32(NV32_RASTER) &amp; 0x000007ff) &lt; si-&gt;dm.timing.v_display) &amp;&amp;</a>
<a name="ln771">			(timeout &lt; (25000/10)))</a>
<a name="ln772">	{</a>
<a name="ln773">		/* don't snooze much longer or retrace might get missed! */</a>
<a name="ln774">		snooze(10);</a>
<a name="ln775">		timeout++;</a>
<a name="ln776">	}</a>
<a name="ln777"> </a>
<a name="ln778">	/* enable access to primary head */</a>
<a name="ln779">	set_crtc_owner(0);</a>
<a name="ln780"> </a>
<a name="ln781">	if (si-&gt;ps.card_arch == NV04A)</a>
<a name="ln782">	{</a>
<a name="ln783">		/* upto 32Mb RAM adressing: must be used this way on pre-NV10! */</a>
<a name="ln784"> </a>
<a name="ln785">		/* set standard registers */</a>
<a name="ln786">		/* (NVidia: startadress in 32bit words (b2 - b17) */</a>
<a name="ln787">		CRTCW(FBSTADDL, ((startadd &amp; 0x000003fc) &gt;&gt; 2));</a>
<a name="ln788">		CRTCW(FBSTADDH, ((startadd &amp; 0x0003fc00) &gt;&gt; 10));</a>
<a name="ln789"> </a>
<a name="ln790">		/* set extended registers */</a>
<a name="ln791">		/* NV4 extended bits: (b18-22) */</a>
<a name="ln792">		temp = (CRTCR(REPAINT0) &amp; 0xe0);</a>
<a name="ln793">		CRTCW(REPAINT0, (temp | ((startadd &amp; 0x007c0000) &gt;&gt; 18)));</a>
<a name="ln794">		/* NV4 extended bits: (b23-24) */</a>
<a name="ln795">		temp = (CRTCR(HEB) &amp; 0x9f);</a>
<a name="ln796">		CRTCW(HEB, (temp | ((startadd &amp; 0x01800000) &gt;&gt; 18)));</a>
<a name="ln797">	}</a>
<a name="ln798">	else</a>
<a name="ln799">	{</a>
<a name="ln800">		/* upto 4Gb RAM adressing: must be used on NV10 and later! */</a>
<a name="ln801">		/* NOTE:</a>
<a name="ln802">		 * While this register also exists on pre-NV10 cards, it will</a>
<a name="ln803">		 * wrap-around at 16Mb boundaries!! */</a>
<a name="ln804"> </a>
<a name="ln805">		/* 30bit adress in 32bit words */</a>
<a name="ln806">		NV_REG32(NV32_NV10FBSTADD32) = (startadd &amp; 0xfffffffc);</a>
<a name="ln807">	}</a>
<a name="ln808"> </a>
<a name="ln809">	/* set NV4/NV10 byte adress: (b0 - 1) */</a>
<a name="ln810">	ATBW(HORPIXPAN, ((startadd &amp; 0x00000003) &lt;&lt; 1));</a>
<a name="ln811"> </a>
<a name="ln812">	return B_OK;</a>
<a name="ln813">}</a>
<a name="ln814"> </a>
<a name="ln815">status_t nv_crtc_cursor_init()</a>
<a name="ln816">{</a>
<a name="ln817">	int i;</a>
<a name="ln818">	vuint32 * fb;</a>
<a name="ln819">	/* cursor bitmap will be stored at the start of the framebuffer */</a>
<a name="ln820">	const uint32 curadd = 0;</a>
<a name="ln821"> </a>
<a name="ln822">	/* enable access to primary head */</a>
<a name="ln823">	set_crtc_owner(0);</a>
<a name="ln824"> </a>
<a name="ln825">	/* set cursor bitmap adress ... */</a>
<a name="ln826">	if ((si-&gt;ps.card_arch == NV04A) || (si-&gt;ps.laptop))</a>
<a name="ln827">	{</a>
<a name="ln828">		/* must be used this way on pre-NV10 and on all 'Go' cards! */</a>
<a name="ln829"> </a>
<a name="ln830">		/* cursorbitmap must start on 2Kbyte boundary: */</a>
<a name="ln831">		/* set adress bit11-16, and set 'no doublescan' (registerbit 1 = 0) */</a>
<a name="ln832">		CRTCW(CURCTL0, ((curadd &amp; 0x0001f800) &gt;&gt; 9));</a>
<a name="ln833">		/* set adress bit17-23, and set graphics mode cursor(?) (registerbit 7 = 1) */</a>
<a name="ln834">		CRTCW(CURCTL1, (((curadd &amp; 0x00fe0000) &gt;&gt; 17) | 0x80));</a>
<a name="ln835">		/* set adress bit24-31 */</a>
<a name="ln836">		CRTCW(CURCTL2, ((curadd &amp; 0xff000000) &gt;&gt; 24));</a>
<a name="ln837">	}</a>
<a name="ln838">	else</a>
<a name="ln839">	{</a>
<a name="ln840">		/* upto 4Gb RAM adressing:</a>
<a name="ln841">		 * can be used on NV10 and later (except for 'Go' cards)! */</a>
<a name="ln842">		/* NOTE:</a>
<a name="ln843">		 * This register does not exist on pre-NV10 and 'Go' cards. */</a>
<a name="ln844"> </a>
<a name="ln845">		/* cursorbitmap must still start on 2Kbyte boundary: */</a>
<a name="ln846">		NV_REG32(NV32_NV10CURADD32) = (curadd &amp; 0xfffff800);</a>
<a name="ln847">	}</a>
<a name="ln848"> </a>
<a name="ln849">	/* set cursor colour: not needed because of direct nature of cursor bitmap. */</a>
<a name="ln850"> </a>
<a name="ln851">	/*clear cursor*/</a>
<a name="ln852">	fb = (vuint32 *) si-&gt;framebuffer + curadd;</a>
<a name="ln853">	for (i=0;i&lt;(2048/4);i++)</a>
<a name="ln854">	{</a>
<a name="ln855">		fb[i]=0;</a>
<a name="ln856">	}</a>
<a name="ln857"> </a>
<a name="ln858">	/* select 32x32 pixel, 16bit color cursorbitmap, no doublescan */</a>
<a name="ln859">	NV_REG32(NV32_CURCONF) = 0x02000100;</a>
<a name="ln860"> </a>
<a name="ln861">	/* activate hardware-sync between cursor updates and vertical retrace where</a>
<a name="ln862">	 * available */</a>
<a name="ln863">	if (si-&gt;ps.card_arch &gt;= NV10A)</a>
<a name="ln864">		DACW(NV10_CURSYNC, (DACR(NV10_CURSYNC) | 0x02000000));</a>
<a name="ln865"> </a>
<a name="ln866">	/* activate hardware cursor */</a>
<a name="ln867">	nv_crtc_cursor_show();</a>
<a name="ln868"> </a>
<a name="ln869">	return B_OK;</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">status_t nv_crtc_cursor_show()</a>
<a name="ln873">{</a>
<a name="ln874">	LOG(4,(&quot;CRTC: enabling cursor\n&quot;));</a>
<a name="ln875"> </a>
<a name="ln876">	/* enable access to CRTC1 on dualhead cards */</a>
<a name="ln877">	set_crtc_owner(0);</a>
<a name="ln878"> </a>
<a name="ln879">	/* b0 = 1 enables cursor */</a>
<a name="ln880">	CRTCW(CURCTL0, (CRTCR(CURCTL0) | 0x01));</a>
<a name="ln881"> </a>
<a name="ln882">	/* workaround for hardware bug confirmed existing on NV43:</a>
<a name="ln883">	 * Cursor visibility is not updated without a position update if its hardware</a>
<a name="ln884">	 * retrace sync is enabled. */</a>
<a name="ln885">	if (si-&gt;ps.card_arch == NV40A) DACW(CURPOS, (DACR(CURPOS)));</a>
<a name="ln886"> </a>
<a name="ln887">	return B_OK;</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">status_t nv_crtc_cursor_hide()</a>
<a name="ln891">{</a>
<a name="ln892">	LOG(4,(&quot;CRTC: disabling cursor\n&quot;));</a>
<a name="ln893"> </a>
<a name="ln894">	/* enable access to primary head */</a>
<a name="ln895">	set_crtc_owner(0);</a>
<a name="ln896"> </a>
<a name="ln897">	/* b0 = 0 disables cursor */</a>
<a name="ln898">	CRTCW(CURCTL0, (CRTCR(CURCTL0) &amp; 0xfe));</a>
<a name="ln899"> </a>
<a name="ln900">	/* workaround for hardware bug confirmed existing on NV43:</a>
<a name="ln901">	 * Cursor visibility is not updated without a position update if its hardware</a>
<a name="ln902">	 * retrace sync is enabled. */</a>
<a name="ln903">	if (si-&gt;ps.card_arch == NV40A) DACW(CURPOS, (DACR(CURPOS)));</a>
<a name="ln904"> </a>
<a name="ln905">	return B_OK;</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908">/*set up cursor shape*/</a>
<a name="ln909">status_t nv_crtc_cursor_define(uint8* andMask,uint8* xorMask)</a>
<a name="ln910">{</a>
<a name="ln911">	int x, y;</a>
<a name="ln912">	uint8 b;</a>
<a name="ln913">	vuint16 *cursor;</a>
<a name="ln914">	uint16 pixel;</a>
<a name="ln915"> </a>
<a name="ln916">	/* get a pointer to the cursor */</a>
<a name="ln917">	cursor = (vuint16*) si-&gt;framebuffer;</a>
<a name="ln918"> </a>
<a name="ln919">	/* draw the cursor */</a>
<a name="ln920">	/* (Nvidia cards have a RGB15 direct color cursor bitmap, bit #16 is transparancy) */</a>
<a name="ln921">	for (y = 0; y &lt; 16; y++)</a>
<a name="ln922">	{</a>
<a name="ln923">		b = 0x80;</a>
<a name="ln924">		for (x = 0; x &lt; 8; x++)</a>
<a name="ln925">		{</a>
<a name="ln926">			/* preset transparant */</a>
<a name="ln927">			pixel = 0x0000;</a>
<a name="ln928">			/* set white if requested */</a>
<a name="ln929">			if ((!(*andMask &amp; b)) &amp;&amp; (!(*xorMask &amp; b))) pixel = 0xffff;</a>
<a name="ln930">			/* set black if requested */</a>
<a name="ln931">			if ((!(*andMask &amp; b)) &amp;&amp;   (*xorMask &amp; b))  pixel = 0x8000;</a>
<a name="ln932">			/* set invert if requested */</a>
<a name="ln933">			if (  (*andMask &amp; b)  &amp;&amp;   (*xorMask &amp; b))  pixel = 0x7fff;</a>
<a name="ln934">			/* place the pixel in the bitmap */</a>
<a name="ln935">			cursor[x + (y * 32)] = pixel;</a>
<a name="ln936">			b &gt;&gt;= 1;</a>
<a name="ln937">		}</a>
<a name="ln938">		xorMask++;</a>
<a name="ln939">		andMask++;</a>
<a name="ln940">		b = 0x80;</a>
<a name="ln941">		for (; x &lt; 16; x++)</a>
<a name="ln942">		{</a>
<a name="ln943">			/* preset transparant */</a>
<a name="ln944">			pixel = 0x0000;</a>
<a name="ln945">			/* set white if requested */</a>
<a name="ln946">			if ((!(*andMask &amp; b)) &amp;&amp; (!(*xorMask &amp; b))) pixel = 0xffff;</a>
<a name="ln947">			/* set black if requested */</a>
<a name="ln948">			if ((!(*andMask &amp; b)) &amp;&amp;   (*xorMask &amp; b))  pixel = 0x8000;</a>
<a name="ln949">			/* set invert if requested */</a>
<a name="ln950">			if (  (*andMask &amp; b)  &amp;&amp;   (*xorMask &amp; b))  pixel = 0x7fff;</a>
<a name="ln951">			/* place the pixel in the bitmap */</a>
<a name="ln952">			cursor[x + (y * 32)] = pixel;</a>
<a name="ln953">			b &gt;&gt;= 1;</a>
<a name="ln954">		}</a>
<a name="ln955">		xorMask++;</a>
<a name="ln956">		andMask++;</a>
<a name="ln957">	}</a>
<a name="ln958"> </a>
<a name="ln959">	return B_OK;</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">/* position the cursor */</a>
<a name="ln963">status_t nv_crtc_cursor_position(uint16 x, uint16 y)</a>
<a name="ln964">{</a>
<a name="ln965">	/* the cursor position is updated during retrace by card hardware except for</a>
<a name="ln966">	 * pre-GeForce cards */</a>
<a name="ln967">	if (si-&gt;ps.card_arch &lt; NV10A)</a>
<a name="ln968">	{</a>
<a name="ln969">		uint16 yhigh;</a>
<a name="ln970">		uint32 timeout = 0;</a>
<a name="ln971"> </a>
<a name="ln972">		/* make sure we are beyond the first line of the cursorbitmap being drawn during</a>
<a name="ln973">		 * updating the position to prevent distortions: no double buffering feature */</a>
<a name="ln974">		/* Note:</a>
<a name="ln975">		 * we need to return as quick as possible or some apps will exhibit lagging.. */</a>
<a name="ln976"> </a>
<a name="ln977">		/* read the old cursor Y position */</a>
<a name="ln978">		yhigh = ((DACR(CURPOS) &amp; 0x0fff0000) &gt;&gt; 16);</a>
<a name="ln979">		/* make sure we will wait until we are below both the old and new Y position:</a>
<a name="ln980">		 * visible cursorbitmap drawing needs to be done at least... */</a>
<a name="ln981">		if (y &gt; yhigh) yhigh = y;</a>
<a name="ln982"> </a>
<a name="ln983">		if (yhigh &lt; (si-&gt;dm.timing.v_display - 16))</a>
<a name="ln984">		{</a>
<a name="ln985">			/* we have vertical lines below old and new cursorposition to spare. So we</a>
<a name="ln986">			 * update the cursor postion 'mid-screen', but below that area. */</a>
<a name="ln987">			/* wait 25mS max. (refresh &gt; 40Hz) */</a>
<a name="ln988">			while ((((uint16)(NV_REG32(NV32_RASTER) &amp; 0x000007ff)) &lt; (yhigh + 16)) &amp;&amp;</a>
<a name="ln989">			(timeout &lt; (25000/10)))</a>
<a name="ln990">			{</a>
<a name="ln991">				snooze(10);</a>
<a name="ln992">				timeout++;</a>
<a name="ln993">			}</a>
<a name="ln994">		}</a>
<a name="ln995">		else</a>
<a name="ln996">		{</a>
<a name="ln997">			timeout = 0;</a>
<a name="ln998">			/* no room to spare, just wait for retrace (is relatively slow) */</a>
<a name="ln999">			/* wait 25mS max. (refresh &gt; 40Hz) */</a>
<a name="ln1000">			while (((NV_REG32(NV32_RASTER) &amp; 0x000007ff) &lt; si-&gt;dm.timing.v_display) &amp;&amp;</a>
<a name="ln1001">			(timeout &lt; (25000/10)))</a>
<a name="ln1002">			{</a>
<a name="ln1003">				/* don't snooze much longer or retrace might get missed! */</a>
<a name="ln1004">				snooze(10);</a>
<a name="ln1005">				timeout++;</a>
<a name="ln1006">			}</a>
<a name="ln1007">		}</a>
<a name="ln1008">	}</a>
<a name="ln1009"> </a>
<a name="ln1010">	/* update cursorposition */</a>
<a name="ln1011">	DACW(CURPOS, ((x &amp; 0x0fff) | ((y &amp; 0x0fff) &lt;&lt; 16)));</a>
<a name="ln1012"> </a>
<a name="ln1013">	return B_OK;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">status_t nv_crtc_stop_tvout(void)</a>
<a name="ln1017">{</a>
<a name="ln1018">	uint16 cnt;</a>
<a name="ln1019"> </a>
<a name="ln1020">	LOG(4,(&quot;CRTC: stopping TV output\n&quot;));</a>
<a name="ln1021"> </a>
<a name="ln1022">	/* enable access to primary head */</a>
<a name="ln1023">	set_crtc_owner(0);</a>
<a name="ln1024"> </a>
<a name="ln1025">	/* just to be sure Vsync is _really_ enabled */</a>
<a name="ln1026">	CRTCW(REPAINT1, (CRTCR(REPAINT1) &amp; 0xbf));</a>
<a name="ln1027"> </a>
<a name="ln1028">	/* wait for one image to be generated to make sure VGA has kicked in and is</a>
<a name="ln1029">	 * running OK before continuing...</a>
<a name="ln1030">	 * (Kicking in will fail often if we do not wait here) */</a>
<a name="ln1031">	/* Note:</a>
<a name="ln1032">	 * The used CRTC's Vsync is required to be enabled here. The DPMS state</a>
<a name="ln1033">	 * programming in the driver makes sure this is the case.</a>
<a name="ln1034">	 * (except for driver startup: see nv_general.c.) */</a>
<a name="ln1035"> </a>
<a name="ln1036">	/* make sure we are 'in' active VGA picture: wait with timeout! */</a>
<a name="ln1037">	cnt = 1;</a>
<a name="ln1038">	while ((NV_REG8(NV8_INSTAT1) &amp; 0x08) &amp;&amp; cnt)</a>
<a name="ln1039">	{</a>
<a name="ln1040">		snooze(1);</a>
<a name="ln1041">		cnt++;</a>
<a name="ln1042">	}</a>
<a name="ln1043">	/* wait for next vertical retrace start on VGA: wait with timeout! */</a>
<a name="ln1044">	cnt = 1;</a>
<a name="ln1045">	while ((!(NV_REG8(NV8_INSTAT1) &amp; 0x08)) &amp;&amp; cnt)</a>
<a name="ln1046">	{</a>
<a name="ln1047">		snooze(1);</a>
<a name="ln1048">		cnt++;</a>
<a name="ln1049">	}</a>
<a name="ln1050">	/* now wait until we are 'in' active VGA picture again: wait with timeout! */</a>
<a name="ln1051">	cnt = 1;</a>
<a name="ln1052">	while ((NV_REG8(NV8_INSTAT1) &amp; 0x08) &amp;&amp; cnt)</a>
<a name="ln1053">	{</a>
<a name="ln1054">		snooze(1);</a>
<a name="ln1055">		cnt++;</a>
<a name="ln1056">	}</a>
<a name="ln1057"> </a>
<a name="ln1058">	/* set CRTC to master mode (b7 = 0) if it wasn't slaved for a panel before */</a>
<a name="ln1059">	if (!(si-&gt;ps.slaved_tmds1))	CRTCW(PIXEL, (CRTCR(PIXEL) &amp; 0x03));</a>
<a name="ln1060"> </a>
<a name="ln1061">	/* CAUTION:</a>
<a name="ln1062">	 * On old cards, PLLSEL (and TV_SETUP?) cannot be read (sometimes?), but</a>
<a name="ln1063">	 * write actions do succeed ...</a>
<a name="ln1064">	 * This is confirmed for both ISA and PCI access, on NV04 and NV11. */</a>
<a name="ln1065"> </a>
<a name="ln1066">	/* setup TVencoder connection */</a>
<a name="ln1067">	/* b1-0 = %00: encoder type is SLAVE;</a>
<a name="ln1068">	 * b24 = 1: VIP datapos is b0-7 */</a>
<a name="ln1069">	//fixme if needed: setup completely instead of relying on pre-init by BIOS..</a>
<a name="ln1070">	//(it seems to work OK on NV04 and NV11 although read reg. doesn't seem to work)</a>
<a name="ln1071">	DACW(TV_SETUP, ((DACR(TV_SETUP) &amp; ~0x00000003) | 0x01000000));</a>
<a name="ln1072"> </a>
<a name="ln1073">	/* tell GPU to use pixelclock from internal source instead of using TVencoder */</a>
<a name="ln1074">	if (si-&gt;ps.secondary_head)</a>
<a name="ln1075">		DACW(PLLSEL, 0x30000f00);</a>
<a name="ln1076">	else</a>
<a name="ln1077">		DACW(PLLSEL, 0x10000700);</a>
<a name="ln1078"> </a>
<a name="ln1079">	/* HTOTAL, VTOTAL and OVERFLOW return their default CRTC use, instead of</a>
<a name="ln1080">	 * H, V-low and V-high 'shadow' counters(?)(b0, 4 and 6 = 0) (b7 use = unknown) */</a>
<a name="ln1081">	CRTCW(TREG, 0x00);</a>
<a name="ln1082"> </a>
<a name="ln1083">	/* select panel encoder, not TV encoder if needed (b0 = 1).</a>
<a name="ln1084">	 * Note:</a>
<a name="ln1085">	 * Both are devices (often) using the CRTC in slaved mode. */</a>
<a name="ln1086">	if (si-&gt;ps.slaved_tmds1) CRTCW(LCD, (CRTCR(LCD) | 0x01));</a>
<a name="ln1087"> </a>
<a name="ln1088">	return B_OK;</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">status_t nv_crtc_start_tvout(void)</a>
<a name="ln1092">{</a>
<a name="ln1093">	LOG(4,(&quot;CRTC: starting TV output\n&quot;));</a>
<a name="ln1094"> </a>
<a name="ln1095">	if (si-&gt;ps.secondary_head)</a>
<a name="ln1096">	{</a>
<a name="ln1097">		/* switch TV encoder to CRTC1 */</a>
<a name="ln1098">		NV_REG32(NV32_2FUNCSEL) &amp;= ~0x00000100;</a>
<a name="ln1099">		NV_REG32(NV32_FUNCSEL) |= 0x00000100;</a>
<a name="ln1100">	}</a>
<a name="ln1101"> </a>
<a name="ln1102">	/* enable access to primary head */</a>
<a name="ln1103">	set_crtc_owner(0);</a>
<a name="ln1104"> </a>
<a name="ln1105">	/* CAUTION:</a>
<a name="ln1106">	 * On old cards, PLLSEL (and TV_SETUP?) cannot be read (sometimes?), but</a>
<a name="ln1107">	 * write actions do succeed ...</a>
<a name="ln1108">	 * This is confirmed for both ISA and PCI access, on NV04 and NV11. */</a>
<a name="ln1109"> </a>
<a name="ln1110">	/* setup TVencoder connection */</a>
<a name="ln1111">	/* b1-0 = %01: encoder type is MASTER;</a>
<a name="ln1112">	 * b24 = 1: VIP datapos is b0-7 */</a>
<a name="ln1113">	//fixme if needed: setup completely instead of relying on pre-init by BIOS..</a>
<a name="ln1114">	//(it seems to work OK on NV04 and NV11 although read reg. doesn't seem to work)</a>
<a name="ln1115">	DACW(TV_SETUP, ((DACR(TV_SETUP) &amp; ~0x00000002) | 0x01000001));</a>
<a name="ln1116"> </a>
<a name="ln1117">	/* tell GPU to use pixelclock from TVencoder instead of using internal source */</a>
<a name="ln1118">	/* (nessecary or display will 'shiver' on both TV and VGA.) */</a>
<a name="ln1119">	if (si-&gt;ps.secondary_head)</a>
<a name="ln1120">		DACW(PLLSEL, 0x20030f00);</a>
<a name="ln1121">	else</a>
<a name="ln1122">		DACW(PLLSEL, 0x00030700);</a>
<a name="ln1123"> </a>
<a name="ln1124">	/* Set overscan color to 'black' */</a>
<a name="ln1125">	/* note:</a>
<a name="ln1126">	 * Change this instruction for a visible overscan color if you're trying to</a>
<a name="ln1127">	 * center the output on TV. Use it as a guide-'line' then ;-) */</a>
<a name="ln1128">	ATBW(OSCANCOLOR, 0x00);</a>
<a name="ln1129"> </a>
<a name="ln1130">	/* set CRTC to slaved mode (b7 = 1) and clear TVadjust (b3-5 = %000) */</a>
<a name="ln1131">	CRTCW(PIXEL, ((CRTCR(PIXEL) &amp; 0xc7) | 0x80));</a>
<a name="ln1132">	/* select TV encoder, not panel encoder (b0 = 0).</a>
<a name="ln1133">	 * Note:</a>
<a name="ln1134">	 * Both are devices (often) using the CRTC in slaved mode. */</a>
<a name="ln1135">	CRTCW(LCD, (CRTCR(LCD) &amp; 0xfe));</a>
<a name="ln1136"> </a>
<a name="ln1137">	/* HTOTAL, VTOTAL and OVERFLOW return their default CRTC use, instead of</a>
<a name="ln1138">	 * H, V-low and V-high 'shadow' counters(?)(b0, 4 and 6 = 0) (b7 use = unknown) */</a>
<a name="ln1139">	CRTCW(TREG, 0x80);</a>
<a name="ln1140"> </a>
<a name="ln1141">	return B_OK;</a>
<a name="ln1142">}</a>

</code></pre>
<div class="balloon" rel="836"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="834"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="846"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="832"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
