
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>oce_if.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-3-Clause</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2013 Emulex</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions are met:</a>
<a name="ln9"> *</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright notice,</a>
<a name="ln11"> *    this list of conditions and the following disclaimer.</a>
<a name="ln12"> *</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln15"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln16"> *</a>
<a name="ln17"> * 3. Neither the name of the Emulex Corporation nor the names of its</a>
<a name="ln18"> *    contributors may be used to endorse or promote products derived from</a>
<a name="ln19"> *    this software without specific prior written permission.</a>
<a name="ln20"> *</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</a>
<a name="ln22"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln23"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln24"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</a>
<a name="ln25"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln26"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln27"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln28"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln29"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln30"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln31"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln32"> *</a>
<a name="ln33"> * Contact Information:</a>
<a name="ln34"> * freebsd-drivers@emulex.com</a>
<a name="ln35"> *</a>
<a name="ln36"> * Emulex</a>
<a name="ln37"> * 3333 Susan Street</a>
<a name="ln38"> * Costa Mesa, CA 92626</a>
<a name="ln39"> */</a>
<a name="ln40"> </a>
<a name="ln41">/* $FreeBSD: releng/12.0/sys/dev/oce/oce_if.c 338949 2018-09-26 17:12:30Z imp $ */</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;oce_if.h&quot;</a>
<a name="ln44">#include &quot;oce_user.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#define is_tso_pkt(m) (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO)</a>
<a name="ln47"> </a>
<a name="ln48">/* UE Status Low CSR */</a>
<a name="ln49">static char *ue_status_low_desc[] = {</a>
<a name="ln50">        &quot;CEV&quot;,</a>
<a name="ln51">        &quot;CTX&quot;,</a>
<a name="ln52">        &quot;DBUF&quot;,</a>
<a name="ln53">        &quot;ERX&quot;,</a>
<a name="ln54">        &quot;Host&quot;,</a>
<a name="ln55">        &quot;MPU&quot;,</a>
<a name="ln56">        &quot;NDMA&quot;,</a>
<a name="ln57">        &quot;PTC &quot;,</a>
<a name="ln58">        &quot;RDMA &quot;,</a>
<a name="ln59">        &quot;RXF &quot;,</a>
<a name="ln60">        &quot;RXIPS &quot;,</a>
<a name="ln61">        &quot;RXULP0 &quot;,</a>
<a name="ln62">        &quot;RXULP1 &quot;,</a>
<a name="ln63">        &quot;RXULP2 &quot;,</a>
<a name="ln64">        &quot;TIM &quot;,</a>
<a name="ln65">        &quot;TPOST &quot;,</a>
<a name="ln66">        &quot;TPRE &quot;,</a>
<a name="ln67">        &quot;TXIPS &quot;,</a>
<a name="ln68">        &quot;TXULP0 &quot;,</a>
<a name="ln69">        &quot;TXULP1 &quot;,</a>
<a name="ln70">        &quot;UC &quot;,</a>
<a name="ln71">        &quot;WDMA &quot;,</a>
<a name="ln72">        &quot;TXULP2 &quot;,</a>
<a name="ln73">        &quot;HOST1 &quot;,</a>
<a name="ln74">        &quot;P0_OB_LINK &quot;,</a>
<a name="ln75">        &quot;P1_OB_LINK &quot;,</a>
<a name="ln76">        &quot;HOST_GPIO &quot;,</a>
<a name="ln77">        &quot;MBOX &quot;,</a>
<a name="ln78">        &quot;AXGMAC0&quot;,</a>
<a name="ln79">        &quot;AXGMAC1&quot;,</a>
<a name="ln80">        &quot;JTAG&quot;,</a>
<a name="ln81">        &quot;MPU_INTPEND&quot;</a>
<a name="ln82">};</a>
<a name="ln83"> </a>
<a name="ln84">/* UE Status High CSR */</a>
<a name="ln85">static char *ue_status_hi_desc[] = {</a>
<a name="ln86">        &quot;LPCMEMHOST&quot;,</a>
<a name="ln87">        &quot;MGMT_MAC&quot;,</a>
<a name="ln88">        &quot;PCS0ONLINE&quot;,</a>
<a name="ln89">        &quot;MPU_IRAM&quot;,</a>
<a name="ln90">        &quot;PCS1ONLINE&quot;,</a>
<a name="ln91">        &quot;PCTL0&quot;,</a>
<a name="ln92">        &quot;PCTL1&quot;,</a>
<a name="ln93">        &quot;PMEM&quot;,</a>
<a name="ln94">        &quot;RR&quot;,</a>
<a name="ln95">        &quot;TXPB&quot;,</a>
<a name="ln96">        &quot;RXPP&quot;,</a>
<a name="ln97">        &quot;XAUI&quot;,</a>
<a name="ln98">        &quot;TXP&quot;,</a>
<a name="ln99">        &quot;ARM&quot;,</a>
<a name="ln100">        &quot;IPC&quot;,</a>
<a name="ln101">        &quot;HOST2&quot;,</a>
<a name="ln102">        &quot;HOST3&quot;,</a>
<a name="ln103">        &quot;HOST4&quot;,</a>
<a name="ln104">        &quot;HOST5&quot;,</a>
<a name="ln105">        &quot;HOST6&quot;,</a>
<a name="ln106">        &quot;HOST7&quot;,</a>
<a name="ln107">        &quot;HOST8&quot;,</a>
<a name="ln108">        &quot;HOST9&quot;,</a>
<a name="ln109">        &quot;NETC&quot;,</a>
<a name="ln110">        &quot;Unknown&quot;,</a>
<a name="ln111">        &quot;Unknown&quot;,</a>
<a name="ln112">        &quot;Unknown&quot;,</a>
<a name="ln113">        &quot;Unknown&quot;,</a>
<a name="ln114">        &quot;Unknown&quot;,</a>
<a name="ln115">        &quot;Unknown&quot;,</a>
<a name="ln116">        &quot;Unknown&quot;,</a>
<a name="ln117">        &quot;Unknown&quot;</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120">struct oce_common_cqe_info{</a>
<a name="ln121">        uint8_t vtp:1;</a>
<a name="ln122">        uint8_t l4_cksum_pass:1;</a>
<a name="ln123">        uint8_t ip_cksum_pass:1;</a>
<a name="ln124">        uint8_t ipv6_frame:1;</a>
<a name="ln125">        uint8_t qnq:1;</a>
<a name="ln126">        uint8_t rsvd:3;</a>
<a name="ln127">        uint8_t num_frags;</a>
<a name="ln128">        uint16_t pkt_size;</a>
<a name="ln129">        uint16_t vtag;</a>
<a name="ln130">};</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">/* Driver entry points prototypes */</a>
<a name="ln134">static int  oce_probe(device_t dev);</a>
<a name="ln135">static int  oce_attach(device_t dev);</a>
<a name="ln136">static int  oce_detach(device_t dev);</a>
<a name="ln137">static int  oce_shutdown(device_t dev);</a>
<a name="ln138">static int  oce_ioctl(struct ifnet *ifp, u_long command, caddr_t data);</a>
<a name="ln139">static void oce_init(void *xsc);</a>
<a name="ln140">static int  oce_multiq_start(struct ifnet *ifp, struct mbuf *m);</a>
<a name="ln141">static void oce_multiq_flush(struct ifnet *ifp);</a>
<a name="ln142"> </a>
<a name="ln143">/* Driver interrupt routines protypes */</a>
<a name="ln144">static void oce_intr(void *arg, int pending);</a>
<a name="ln145">static int  oce_setup_intr(POCE_SOFTC sc);</a>
<a name="ln146">static int  oce_fast_isr(void *arg);</a>
<a name="ln147">static int  oce_alloc_intr(POCE_SOFTC sc, int vector,</a>
<a name="ln148">			  void (*isr) (void *arg, int pending));</a>
<a name="ln149"> </a>
<a name="ln150">/* Media callbacks prototypes */</a>
<a name="ln151">static void oce_media_status(struct ifnet *ifp, struct ifmediareq *req);</a>
<a name="ln152">static int  oce_media_change(struct ifnet *ifp);</a>
<a name="ln153"> </a>
<a name="ln154">/* Transmit routines prototypes */</a>
<a name="ln155">static int  oce_tx(POCE_SOFTC sc, struct mbuf **mpp, int wq_index);</a>
<a name="ln156">static void oce_tx_restart(POCE_SOFTC sc, struct oce_wq *wq);</a>
<a name="ln157">static void oce_process_tx_completion(struct oce_wq *wq);</a>
<a name="ln158">static int  oce_multiq_transmit(struct ifnet *ifp, struct mbuf *m,</a>
<a name="ln159">				 struct oce_wq *wq);</a>
<a name="ln160"> </a>
<a name="ln161">/* Receive routines prototypes */</a>
<a name="ln162">static int  oce_cqe_vtp_valid(POCE_SOFTC sc, struct oce_nic_rx_cqe *cqe);</a>
<a name="ln163">static int  oce_cqe_portid_valid(POCE_SOFTC sc, struct oce_nic_rx_cqe *cqe);</a>
<a name="ln164">static void oce_rx(struct oce_rq *rq, struct oce_nic_rx_cqe *cqe);</a>
<a name="ln165">static void oce_check_rx_bufs(POCE_SOFTC sc, uint32_t num_cqes, struct oce_rq *rq);</a>
<a name="ln166">static uint16_t oce_rq_handler_lro(void *arg);</a>
<a name="ln167">static void oce_correct_header(struct mbuf *m, struct nic_hwlro_cqe_part1 *cqe1, struct nic_hwlro_cqe_part2 *cqe2);</a>
<a name="ln168">static void oce_rx_lro(struct oce_rq *rq, struct nic_hwlro_singleton_cqe *cqe, struct nic_hwlro_cqe_part2 *cqe2);</a>
<a name="ln169">static void oce_rx_mbuf_chain(struct oce_rq *rq, struct oce_common_cqe_info *cqe_info, struct mbuf **m);</a>
<a name="ln170"> </a>
<a name="ln171">/* Helper function prototypes in this file */</a>
<a name="ln172">static int  oce_attach_ifp(POCE_SOFTC sc);</a>
<a name="ln173">static void oce_add_vlan(void *arg, struct ifnet *ifp, uint16_t vtag);</a>
<a name="ln174">static void oce_del_vlan(void *arg, struct ifnet *ifp, uint16_t vtag);</a>
<a name="ln175">static int  oce_vid_config(POCE_SOFTC sc);</a>
<a name="ln176">static void oce_mac_addr_set(POCE_SOFTC sc);</a>
<a name="ln177">static int  oce_handle_passthrough(struct ifnet *ifp, caddr_t data);</a>
<a name="ln178">static void oce_local_timer(void *arg);</a>
<a name="ln179">static void oce_if_deactivate(POCE_SOFTC sc);</a>
<a name="ln180">static void oce_if_activate(POCE_SOFTC sc);</a>
<a name="ln181">static void setup_max_queues_want(POCE_SOFTC sc);</a>
<a name="ln182">static void update_queues_got(POCE_SOFTC sc);</a>
<a name="ln183">static void process_link_state(POCE_SOFTC sc,</a>
<a name="ln184">		 struct oce_async_cqe_link_state *acqe);</a>
<a name="ln185">static int oce_tx_asic_stall_verify(POCE_SOFTC sc, struct mbuf *m);</a>
<a name="ln186">static void oce_get_config(POCE_SOFTC sc);</a>
<a name="ln187">static struct mbuf *oce_insert_vlan_tag(POCE_SOFTC sc, struct mbuf *m, boolean_t *complete);</a>
<a name="ln188">static void oce_read_env_variables(POCE_SOFTC sc);</a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191">/* IP specific */</a>
<a name="ln192">#if defined(INET6) || defined(INET)</a>
<a name="ln193">static int  oce_init_lro(POCE_SOFTC sc);</a>
<a name="ln194">static struct mbuf * oce_tso_setup(POCE_SOFTC sc, struct mbuf **mpp);</a>
<a name="ln195">#endif</a>
<a name="ln196"> </a>
<a name="ln197">static device_method_t oce_dispatch[] = {</a>
<a name="ln198">	DEVMETHOD(device_probe, oce_probe),</a>
<a name="ln199">	DEVMETHOD(device_attach, oce_attach),</a>
<a name="ln200">	DEVMETHOD(device_detach, oce_detach),</a>
<a name="ln201">	DEVMETHOD(device_shutdown, oce_shutdown),</a>
<a name="ln202"> </a>
<a name="ln203">	DEVMETHOD_END</a>
<a name="ln204">};</a>
<a name="ln205"> </a>
<a name="ln206">static driver_t oce_driver = {</a>
<a name="ln207">	&quot;oce&quot;,</a>
<a name="ln208">	oce_dispatch,</a>
<a name="ln209">	sizeof(OCE_SOFTC)</a>
<a name="ln210">};</a>
<a name="ln211">static devclass_t oce_devclass;</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">/* global vars */</a>
<a name="ln215">const char component_revision[32] = {&quot;///&quot; COMPONENT_REVISION &quot;///&quot;};</a>
<a name="ln216"> </a>
<a name="ln217">/* Module capabilites and parameters */</a>
<a name="ln218">uint32_t oce_max_rsp_handled = OCE_MAX_RSP_HANDLED;</a>
<a name="ln219">uint32_t oce_enable_rss = OCE_MODCAP_RSS;</a>
<a name="ln220">uint32_t oce_rq_buf_size = 2048;</a>
<a name="ln221"> </a>
<a name="ln222">TUNABLE_INT(&quot;hw.oce.max_rsp_handled&quot;, &amp;oce_max_rsp_handled);</a>
<a name="ln223">TUNABLE_INT(&quot;hw.oce.enable_rss&quot;, &amp;oce_enable_rss);</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">/* Supported devices table */</a>
<a name="ln227">static uint32_t supportedDevices[] =  {</a>
<a name="ln228">	(PCI_VENDOR_SERVERENGINES &lt;&lt; 16) | PCI_PRODUCT_BE2,</a>
<a name="ln229">	(PCI_VENDOR_SERVERENGINES &lt;&lt; 16) | PCI_PRODUCT_BE3,</a>
<a name="ln230">	(PCI_VENDOR_EMULEX &lt;&lt; 16) | PCI_PRODUCT_BE3,</a>
<a name="ln231">	(PCI_VENDOR_EMULEX &lt;&lt; 16) | PCI_PRODUCT_XE201,</a>
<a name="ln232">	(PCI_VENDOR_EMULEX &lt;&lt; 16) | PCI_PRODUCT_XE201_VF,</a>
<a name="ln233">	(PCI_VENDOR_EMULEX &lt;&lt; 16) | PCI_PRODUCT_SH</a>
<a name="ln234">};</a>
<a name="ln235"> </a>
<a name="ln236"> </a>
<a name="ln237">DRIVER_MODULE(oce, pci, oce_driver, oce_devclass, 0, 0);</a>
<a name="ln238">MODULE_PNP_INFO(&quot;W32:vendor/device&quot;, pci, oce, supportedDevices,</a>
<a name="ln239">    nitems(supportedDevices));</a>
<a name="ln240">MODULE_DEPEND(oce, pci, 1, 1, 1);</a>
<a name="ln241">MODULE_DEPEND(oce, ether, 1, 1, 1);</a>
<a name="ln242">MODULE_VERSION(oce, 1);</a>
<a name="ln243"> </a>
<a name="ln244"> </a>
<a name="ln245">POCE_SOFTC softc_head = NULL;</a>
<a name="ln246">POCE_SOFTC softc_tail = NULL;</a>
<a name="ln247"> </a>
<a name="ln248">struct oce_rdma_if *oce_rdma_if = NULL;</a>
<a name="ln249"> </a>
<a name="ln250">/*****************************************************************************</a>
<a name="ln251"> *			Driver entry points functions                        *</a>
<a name="ln252"> *****************************************************************************/</a>
<a name="ln253"> </a>
<a name="ln254">static int</a>
<a name="ln255">oce_probe(device_t dev)</a>
<a name="ln256">{</a>
<a name="ln257">	uint16_t vendor = 0;</a>
<a name="ln258">	uint16_t device = 0;</a>
<a name="ln259">	int i = 0;</a>
<a name="ln260">	char str[256] = {0};</a>
<a name="ln261">	POCE_SOFTC sc;</a>
<a name="ln262"> </a>
<a name="ln263">	sc = device_get_softc(dev);</a>
<a name="ln264">	bzero(sc, sizeof(OCE_SOFTC));</a>
<a name="ln265">	sc-&gt;dev = dev;</a>
<a name="ln266"> </a>
<a name="ln267">	vendor = pci_get_vendor(dev);</a>
<a name="ln268">	device = pci_get_device(dev);</a>
<a name="ln269"> </a>
<a name="ln270">	for (i = 0; i &lt; (sizeof(supportedDevices) / sizeof(uint32_t)); i++) {</a>
<a name="ln271">		if (vendor == ((supportedDevices[i] &gt;&gt; 16) &amp; 0xffff)) {</a>
<a name="ln272">			if (device == (supportedDevices[i] &amp; 0xffff)) {</a>
<a name="ln273">				sprintf(str, &quot;%s:%s&quot;, &quot;Emulex CNA NIC function&quot;,</a>
<a name="ln274">					component_revision);</a>
<a name="ln275">				device_set_desc_copy(dev, str);</a>
<a name="ln276"> </a>
<a name="ln277">				switch (device) {</a>
<a name="ln278">				case PCI_PRODUCT_BE2:</a>
<a name="ln279">					sc-&gt;flags |= OCE_FLAGS_BE2;</a>
<a name="ln280">					break;</a>
<a name="ln281">				case PCI_PRODUCT_BE3:</a>
<a name="ln282">					sc-&gt;flags |= OCE_FLAGS_BE3;</a>
<a name="ln283">					break;</a>
<a name="ln284">				case PCI_PRODUCT_XE201:</a>
<a name="ln285">				case PCI_PRODUCT_XE201_VF:</a>
<a name="ln286">					sc-&gt;flags |= OCE_FLAGS_XE201;</a>
<a name="ln287">					break;</a>
<a name="ln288">				case PCI_PRODUCT_SH:</a>
<a name="ln289">					sc-&gt;flags |= OCE_FLAGS_SH;</a>
<a name="ln290">					break;</a>
<a name="ln291">				default:</a>
<a name="ln292">					return ENXIO;</a>
<a name="ln293">				}</a>
<a name="ln294">				return BUS_PROBE_DEFAULT;</a>
<a name="ln295">			}</a>
<a name="ln296">		}</a>
<a name="ln297">	}</a>
<a name="ln298"> </a>
<a name="ln299">	return ENXIO;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302"> </a>
<a name="ln303">static int</a>
<a name="ln304">oce_attach(device_t dev)</a>
<a name="ln305">{</a>
<a name="ln306">	POCE_SOFTC sc;</a>
<a name="ln307">	int rc = 0;</a>
<a name="ln308"> </a>
<a name="ln309">	sc = device_get_softc(dev);</a>
<a name="ln310"> </a>
<a name="ln311">	rc = oce_hw_pci_alloc(sc);</a>
<a name="ln312">	if (rc)</a>
<a name="ln313">		return rc;</a>
<a name="ln314"> </a>
<a name="ln315">	sc-&gt;tx_ring_size = OCE_TX_RING_SIZE;</a>
<a name="ln316">	sc-&gt;rx_ring_size = OCE_RX_RING_SIZE;</a>
<a name="ln317">	/* receive fragment size should be multiple of 2K */</a>
<a name="ln318">	sc-&gt;rq_frag_size = ((oce_rq_buf_size / 2048) * 2048);</a>
<a name="ln319">	sc-&gt;flow_control = OCE_DEFAULT_FLOW_CONTROL;</a>
<a name="ln320">	sc-&gt;promisc	 = OCE_DEFAULT_PROMISCUOUS;</a>
<a name="ln321"> </a>
<a name="ln322">	LOCK_CREATE(&amp;sc-&gt;bmbx_lock, &quot;Mailbox_lock&quot;);</a>
<a name="ln323">	LOCK_CREATE(&amp;sc-&gt;dev_lock,  &quot;Device_lock&quot;);</a>
<a name="ln324"> </a>
<a name="ln325">	/* initialise the hardware */</a>
<a name="ln326">	rc = oce_hw_init(sc);</a>
<a name="ln327">	if (rc)</a>
<a name="ln328">		goto pci_res_free;</a>
<a name="ln329"> </a>
<a name="ln330">	oce_read_env_variables(sc);</a>
<a name="ln331"> </a>
<a name="ln332">	oce_get_config(sc);</a>
<a name="ln333"> </a>
<a name="ln334">	setup_max_queues_want(sc);</a>
<a name="ln335"> </a>
<a name="ln336">	rc = oce_setup_intr(sc);</a>
<a name="ln337">	if (rc)</a>
<a name="ln338">		goto mbox_free;</a>
<a name="ln339"> </a>
<a name="ln340">	rc = oce_queue_init_all(sc);</a>
<a name="ln341">	if (rc)</a>
<a name="ln342">		goto intr_free;</a>
<a name="ln343"> </a>
<a name="ln344">	rc = oce_attach_ifp(sc);</a>
<a name="ln345">	if (rc)</a>
<a name="ln346">		goto queues_free;</a>
<a name="ln347"> </a>
<a name="ln348">#if defined(INET6) || defined(INET)</a>
<a name="ln349">	rc = oce_init_lro(sc);</a>
<a name="ln350">	if (rc)</a>
<a name="ln351">		goto ifp_free;</a>
<a name="ln352">#endif</a>
<a name="ln353"> </a>
<a name="ln354">	rc = oce_hw_start(sc);</a>
<a name="ln355">	if (rc)</a>
<a name="ln356">		goto lro_free;</a>
<a name="ln357"> </a>
<a name="ln358">	sc-&gt;vlan_attach = EVENTHANDLER_REGISTER(vlan_config,</a>
<a name="ln359">				oce_add_vlan, sc, EVENTHANDLER_PRI_FIRST);</a>
<a name="ln360">	sc-&gt;vlan_detach = EVENTHANDLER_REGISTER(vlan_unconfig,</a>
<a name="ln361">				oce_del_vlan, sc, EVENTHANDLER_PRI_FIRST);</a>
<a name="ln362"> </a>
<a name="ln363">	rc = oce_stats_init(sc);</a>
<a name="ln364">	if (rc)</a>
<a name="ln365">		goto vlan_free;</a>
<a name="ln366"> </a>
<a name="ln367">	oce_add_sysctls(sc);</a>
<a name="ln368"> </a>
<a name="ln369">	callout_init(&amp;sc-&gt;timer, CALLOUT_MPSAFE);</a>
<a name="ln370">	rc = callout_reset(&amp;sc-&gt;timer, 2 * hz, oce_local_timer, sc);</a>
<a name="ln371">	if (rc)</a>
<a name="ln372">		goto stats_free;</a>
<a name="ln373"> </a>
<a name="ln374">	sc-&gt;next =NULL;</a>
<a name="ln375">	if (softc_tail != NULL) {</a>
<a name="ln376">	  softc_tail-&gt;next = sc;</a>
<a name="ln377">	} else {</a>
<a name="ln378">	  softc_head = sc;</a>
<a name="ln379">	}</a>
<a name="ln380">	softc_tail = sc;</a>
<a name="ln381"> </a>
<a name="ln382">	return 0;</a>
<a name="ln383"> </a>
<a name="ln384">stats_free:</a>
<a name="ln385">	callout_drain(&amp;sc-&gt;timer);</a>
<a name="ln386">	oce_stats_free(sc);</a>
<a name="ln387">vlan_free:</a>
<a name="ln388">	if (sc-&gt;vlan_attach)</a>
<a name="ln389">		EVENTHANDLER_DEREGISTER(vlan_config, sc-&gt;vlan_attach);</a>
<a name="ln390">	if (sc-&gt;vlan_detach)</a>
<a name="ln391">		EVENTHANDLER_DEREGISTER(vlan_unconfig, sc-&gt;vlan_detach);</a>
<a name="ln392">	oce_hw_intr_disable(sc);</a>
<a name="ln393">lro_free:</a>
<a name="ln394">#if defined(INET6) || defined(INET)</a>
<a name="ln395">	oce_free_lro(sc);</a>
<a name="ln396">ifp_free:</a>
<a name="ln397">#endif</a>
<a name="ln398">	ether_ifdetach(sc-&gt;ifp);</a>
<a name="ln399">	if_free(sc-&gt;ifp);</a>
<a name="ln400">queues_free:</a>
<a name="ln401">	oce_queue_release_all(sc);</a>
<a name="ln402">intr_free:</a>
<a name="ln403">	oce_intr_free(sc);</a>
<a name="ln404">mbox_free:</a>
<a name="ln405">	oce_dma_free(sc, &amp;sc-&gt;bsmbx);</a>
<a name="ln406">pci_res_free:</a>
<a name="ln407">	oce_hw_pci_free(sc);</a>
<a name="ln408">	LOCK_DESTROY(&amp;sc-&gt;dev_lock);</a>
<a name="ln409">	LOCK_DESTROY(&amp;sc-&gt;bmbx_lock);</a>
<a name="ln410">	return rc;</a>
<a name="ln411"> </a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">static int</a>
<a name="ln416">oce_detach(device_t dev)</a>
<a name="ln417">{</a>
<a name="ln418">	POCE_SOFTC sc = device_get_softc(dev);</a>
<a name="ln419">	POCE_SOFTC poce_sc_tmp, *ppoce_sc_tmp1, poce_sc_tmp2 = NULL;</a>
<a name="ln420"> </a>
<a name="ln421">        poce_sc_tmp = softc_head;</a>
<a name="ln422">        ppoce_sc_tmp1 = &amp;softc_head;</a>
<a name="ln423">        while (poce_sc_tmp != NULL) {</a>
<a name="ln424">          if (poce_sc_tmp == sc) {</a>
<a name="ln425">            *ppoce_sc_tmp1 = sc-&gt;next;</a>
<a name="ln426">            if (sc-&gt;next == NULL) {</a>
<a name="ln427">              softc_tail = poce_sc_tmp2;</a>
<a name="ln428">            }</a>
<a name="ln429">            break;</a>
<a name="ln430">          }</a>
<a name="ln431">          poce_sc_tmp2 = poce_sc_tmp;</a>
<a name="ln432">          ppoce_sc_tmp1 = &amp;poce_sc_tmp-&gt;next;</a>
<a name="ln433">          poce_sc_tmp = poce_sc_tmp-&gt;next;</a>
<a name="ln434">        }</a>
<a name="ln435"> </a>
<a name="ln436">	LOCK(&amp;sc-&gt;dev_lock);</a>
<a name="ln437">	oce_if_deactivate(sc);</a>
<a name="ln438">	UNLOCK(&amp;sc-&gt;dev_lock);</a>
<a name="ln439"> </a>
<a name="ln440">	callout_drain(&amp;sc-&gt;timer);</a>
<a name="ln441"> </a>
<a name="ln442">	if (sc-&gt;vlan_attach != NULL)</a>
<a name="ln443">		EVENTHANDLER_DEREGISTER(vlan_config, sc-&gt;vlan_attach);</a>
<a name="ln444">	if (sc-&gt;vlan_detach != NULL)</a>
<a name="ln445">		EVENTHANDLER_DEREGISTER(vlan_unconfig, sc-&gt;vlan_detach);</a>
<a name="ln446"> </a>
<a name="ln447">	ether_ifdetach(sc-&gt;ifp);</a>
<a name="ln448"> </a>
<a name="ln449">	if_free(sc-&gt;ifp);</a>
<a name="ln450"> </a>
<a name="ln451">	oce_hw_shutdown(sc);</a>
<a name="ln452"> </a>
<a name="ln453">	bus_generic_detach(dev);</a>
<a name="ln454"> </a>
<a name="ln455">	return 0;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459">static int</a>
<a name="ln460">oce_shutdown(device_t dev)</a>
<a name="ln461">{</a>
<a name="ln462">	int rc;</a>
<a name="ln463"> </a>
<a name="ln464">	rc = oce_detach(dev);</a>
<a name="ln465"> </a>
<a name="ln466">	return rc;</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469"> </a>
<a name="ln470">static int</a>
<a name="ln471">oce_ioctl(struct ifnet *ifp, u_long command, caddr_t data)</a>
<a name="ln472">{</a>
<a name="ln473">	struct ifreq *ifr = (struct ifreq *)data;</a>
<a name="ln474">	POCE_SOFTC sc = ifp-&gt;if_softc;</a>
<a name="ln475">	int rc = 0;</a>
<a name="ln476">	uint32_t u;</a>
<a name="ln477"> </a>
<a name="ln478">	switch (command) {</a>
<a name="ln479"> </a>
<a name="ln480">	case SIOCGIFMEDIA:</a>
<a name="ln481">		rc = ifmedia_ioctl(ifp, ifr, &amp;sc-&gt;media, command);</a>
<a name="ln482">		break;</a>
<a name="ln483"> </a>
<a name="ln484">	case SIOCSIFMTU:</a>
<a name="ln485">		if (ifr-&gt;ifr_mtu &gt; OCE_MAX_MTU)</a>
<a name="ln486">			rc = EINVAL;</a>
<a name="ln487">		else</a>
<a name="ln488">			ifp-&gt;if_mtu = ifr-&gt;ifr_mtu;</a>
<a name="ln489">		break;</a>
<a name="ln490"> </a>
<a name="ln491">	case SIOCSIFFLAGS:</a>
<a name="ln492">		if (ifp-&gt;if_flags &amp; IFF_UP) {</a>
<a name="ln493">			if (!(ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)) {</a>
<a name="ln494">				sc-&gt;ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</a>
<a name="ln495">				oce_init(sc);</a>
<a name="ln496">			}</a>
<a name="ln497">			device_printf(sc-&gt;dev, &quot;Interface Up\n&quot;);</a>
<a name="ln498">		} else {</a>
<a name="ln499">			LOCK(&amp;sc-&gt;dev_lock);</a>
<a name="ln500"> </a>
<a name="ln501">			sc-&gt;ifp-&gt;if_drv_flags &amp;=</a>
<a name="ln502">			    ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);</a>
<a name="ln503">			oce_if_deactivate(sc);</a>
<a name="ln504"> </a>
<a name="ln505">			UNLOCK(&amp;sc-&gt;dev_lock);</a>
<a name="ln506"> </a>
<a name="ln507">			device_printf(sc-&gt;dev, &quot;Interface Down\n&quot;);</a>
<a name="ln508">		}</a>
<a name="ln509"> </a>
<a name="ln510">		if ((ifp-&gt;if_flags &amp; IFF_PROMISC) &amp;&amp; !sc-&gt;promisc) {</a>
<a name="ln511">			if (!oce_rxf_set_promiscuous(sc, (1 | (1 &lt;&lt; 1))))</a>
<a name="ln512">				sc-&gt;promisc = TRUE;</a>
<a name="ln513">		} else if (!(ifp-&gt;if_flags &amp; IFF_PROMISC) &amp;&amp; sc-&gt;promisc) {</a>
<a name="ln514">			if (!oce_rxf_set_promiscuous(sc, 0))</a>
<a name="ln515">				sc-&gt;promisc = FALSE;</a>
<a name="ln516">		}</a>
<a name="ln517"> </a>
<a name="ln518">		break;</a>
<a name="ln519"> </a>
<a name="ln520">	case SIOCADDMULTI:</a>
<a name="ln521">	case SIOCDELMULTI:</a>
<a name="ln522">		rc = oce_hw_update_multicast(sc);</a>
<a name="ln523">		if (rc)</a>
<a name="ln524">			device_printf(sc-&gt;dev,</a>
<a name="ln525">				&quot;Update multicast address failed\n&quot;);</a>
<a name="ln526">		break;</a>
<a name="ln527"> </a>
<a name="ln528">	case SIOCSIFCAP:</a>
<a name="ln529">		u = ifr-&gt;ifr_reqcap ^ ifp-&gt;if_capenable;</a>
<a name="ln530"> </a>
<a name="ln531">		if (u &amp; IFCAP_TXCSUM) {</a>
<a name="ln532">			ifp-&gt;if_capenable ^= IFCAP_TXCSUM;</a>
<a name="ln533">			ifp-&gt;if_hwassist ^= (CSUM_TCP | CSUM_UDP | CSUM_IP);</a>
<a name="ln534"> </a>
<a name="ln535">			if (IFCAP_TSO &amp; ifp-&gt;if_capenable &amp;&amp;</a>
<a name="ln536">			    !(IFCAP_TXCSUM &amp; ifp-&gt;if_capenable)) {</a>
<a name="ln537">				ifp-&gt;if_capenable &amp;= ~IFCAP_TSO;</a>
<a name="ln538">				ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln539">				if_printf(ifp,</a>
<a name="ln540">					 &quot;TSO disabled due to -txcsum.\n&quot;);</a>
<a name="ln541">			}</a>
<a name="ln542">		}</a>
<a name="ln543"> </a>
<a name="ln544">		if (u &amp; IFCAP_RXCSUM)</a>
<a name="ln545">			ifp-&gt;if_capenable ^= IFCAP_RXCSUM;</a>
<a name="ln546"> </a>
<a name="ln547">		if (u &amp; IFCAP_TSO4) {</a>
<a name="ln548">			ifp-&gt;if_capenable ^= IFCAP_TSO4;</a>
<a name="ln549"> </a>
<a name="ln550">			if (IFCAP_TSO &amp; ifp-&gt;if_capenable) {</a>
<a name="ln551">				if (IFCAP_TXCSUM &amp; ifp-&gt;if_capenable)</a>
<a name="ln552">					ifp-&gt;if_hwassist |= CSUM_TSO;</a>
<a name="ln553">				else {</a>
<a name="ln554">					ifp-&gt;if_capenable &amp;= ~IFCAP_TSO;</a>
<a name="ln555">					ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln556">					if_printf(ifp,</a>
<a name="ln557">					    &quot;Enable txcsum first.\n&quot;);</a>
<a name="ln558">					rc = EAGAIN;</a>
<a name="ln559">				}</a>
<a name="ln560">			} else</a>
<a name="ln561">				ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln562">		}</a>
<a name="ln563"> </a>
<a name="ln564">		if (u &amp; IFCAP_VLAN_HWTAGGING)</a>
<a name="ln565">			ifp-&gt;if_capenable ^= IFCAP_VLAN_HWTAGGING;</a>
<a name="ln566"> </a>
<a name="ln567">		if (u &amp; IFCAP_VLAN_HWFILTER) {</a>
<a name="ln568">			ifp-&gt;if_capenable ^= IFCAP_VLAN_HWFILTER;</a>
<a name="ln569">			oce_vid_config(sc);</a>
<a name="ln570">		}</a>
<a name="ln571">#if defined(INET6) || defined(INET)</a>
<a name="ln572">		if (u &amp; IFCAP_LRO) {</a>
<a name="ln573">			ifp-&gt;if_capenable ^= IFCAP_LRO;</a>
<a name="ln574">			if(sc-&gt;enable_hwlro) {</a>
<a name="ln575">				if(ifp-&gt;if_capenable &amp; IFCAP_LRO) {</a>
<a name="ln576">					rc = oce_mbox_nic_set_iface_lro_config(sc, 1);</a>
<a name="ln577">				}else {</a>
<a name="ln578">					rc = oce_mbox_nic_set_iface_lro_config(sc, 0);</a>
<a name="ln579">				}</a>
<a name="ln580">			}</a>
<a name="ln581">		}</a>
<a name="ln582">#endif</a>
<a name="ln583"> </a>
<a name="ln584">		break;</a>
<a name="ln585"> </a>
<a name="ln586">	case SIOCGPRIVATE_0:</a>
<a name="ln587">		rc = oce_handle_passthrough(ifp, data);</a>
<a name="ln588">		break;</a>
<a name="ln589">	default:</a>
<a name="ln590">		rc = ether_ioctl(ifp, command, data);</a>
<a name="ln591">		break;</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">	return rc;</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597"> </a>
<a name="ln598">static void</a>
<a name="ln599">oce_init(void *arg)</a>
<a name="ln600">{</a>
<a name="ln601">	POCE_SOFTC sc = arg;</a>
<a name="ln602"> </a>
<a name="ln603">	LOCK(&amp;sc-&gt;dev_lock);</a>
<a name="ln604"> </a>
<a name="ln605">	if (sc-&gt;ifp-&gt;if_flags &amp; IFF_UP) {</a>
<a name="ln606">		oce_if_deactivate(sc);</a>
<a name="ln607">		oce_if_activate(sc);</a>
<a name="ln608">	}</a>
<a name="ln609"> </a>
<a name="ln610">	UNLOCK(&amp;sc-&gt;dev_lock);</a>
<a name="ln611"> </a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614"> </a>
<a name="ln615">static int</a>
<a name="ln616">oce_multiq_start(struct ifnet *ifp, struct mbuf *m)</a>
<a name="ln617">{</a>
<a name="ln618">	POCE_SOFTC sc = ifp-&gt;if_softc;</a>
<a name="ln619">	struct oce_wq *wq = NULL;</a>
<a name="ln620">	int queue_index = 0;</a>
<a name="ln621">	int status = 0;</a>
<a name="ln622"> </a>
<a name="ln623">	if (!sc-&gt;link_status)</a>
<a name="ln624">		return ENXIO;</a>
<a name="ln625"> </a>
<a name="ln626">	if (M_HASHTYPE_GET(m) != M_HASHTYPE_NONE)</a>
<a name="ln627">		queue_index = m-&gt;m_pkthdr.flowid % sc-&gt;nwqs;</a>
<a name="ln628"> </a>
<a name="ln629">	wq = sc-&gt;wq[queue_index];</a>
<a name="ln630"> </a>
<a name="ln631">	LOCK(&amp;wq-&gt;tx_lock);</a>
<a name="ln632">	status = oce_multiq_transmit(ifp, m, wq);</a>
<a name="ln633">	UNLOCK(&amp;wq-&gt;tx_lock);</a>
<a name="ln634"> </a>
<a name="ln635">	return status;</a>
<a name="ln636"> </a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639"> </a>
<a name="ln640">static void</a>
<a name="ln641">oce_multiq_flush(struct ifnet *ifp)</a>
<a name="ln642">{</a>
<a name="ln643">	POCE_SOFTC sc = ifp-&gt;if_softc;</a>
<a name="ln644">	struct mbuf     *m;</a>
<a name="ln645">	int i = 0;</a>
<a name="ln646"> </a>
<a name="ln647">	for (i = 0; i &lt; sc-&gt;nwqs; i++) {</a>
<a name="ln648">		while ((m = buf_ring_dequeue_sc(sc-&gt;wq[i]-&gt;br)) != NULL)</a>
<a name="ln649">			m_freem(m);</a>
<a name="ln650">	}</a>
<a name="ln651">	if_qflush(ifp);</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654"> </a>
<a name="ln655"> </a>
<a name="ln656">/*****************************************************************************</a>
<a name="ln657"> *                   Driver interrupt routines functions                     *</a>
<a name="ln658"> *****************************************************************************/</a>
<a name="ln659"> </a>
<a name="ln660">static void</a>
<a name="ln661">oce_intr(void *arg, int pending)</a>
<a name="ln662">{</a>
<a name="ln663"> </a>
<a name="ln664">	POCE_INTR_INFO ii = (POCE_INTR_INFO) arg;</a>
<a name="ln665">	POCE_SOFTC sc = ii-&gt;sc;</a>
<a name="ln666">	struct oce_eq *eq = ii-&gt;eq;</a>
<a name="ln667">	struct oce_eqe *eqe;</a>
<a name="ln668">	struct oce_cq *cq = NULL;</a>
<a name="ln669">	int i, num_eqes = 0;</a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">	bus_dmamap_sync(eq-&gt;ring-&gt;dma.tag, eq-&gt;ring-&gt;dma.map,</a>
<a name="ln673">				 BUS_DMASYNC_POSTWRITE);</a>
<a name="ln674">	do {</a>
<a name="ln675">		eqe = RING_GET_CONSUMER_ITEM_VA(eq-&gt;ring, struct oce_eqe);</a>
<a name="ln676">		if (eqe-&gt;evnt == 0)</a>
<a name="ln677">			break;</a>
<a name="ln678">		eqe-&gt;evnt = 0;</a>
<a name="ln679">		bus_dmamap_sync(eq-&gt;ring-&gt;dma.tag, eq-&gt;ring-&gt;dma.map,</a>
<a name="ln680">					BUS_DMASYNC_POSTWRITE);</a>
<a name="ln681">		RING_GET(eq-&gt;ring, 1);</a>
<a name="ln682">		num_eqes++;</a>
<a name="ln683"> </a>
<a name="ln684">	} while (TRUE);</a>
<a name="ln685"> </a>
<a name="ln686">	if (!num_eqes)</a>
<a name="ln687">		goto eq_arm; /* Spurious */</a>
<a name="ln688"> </a>
<a name="ln689"> 	/* Clear EQ entries, but dont arm */</a>
<a name="ln690">	oce_arm_eq(sc, eq-&gt;eq_id, num_eqes, FALSE, FALSE);</a>
<a name="ln691"> </a>
<a name="ln692">	/* Process TX, RX and MCC. But dont arm CQ*/</a>
<a name="ln693">	for (i = 0; i &lt; eq-&gt;cq_valid; i++) {</a>
<a name="ln694">		cq = eq-&gt;cq[i];</a>
<a name="ln695">		(*cq-&gt;cq_handler)(cq-&gt;cb_arg);</a>
<a name="ln696">	}</a>
<a name="ln697"> </a>
<a name="ln698">	/* Arm all cqs connected to this EQ */</a>
<a name="ln699">	for (i = 0; i &lt; eq-&gt;cq_valid; i++) {</a>
<a name="ln700">		cq = eq-&gt;cq[i];</a>
<a name="ln701">		oce_arm_cq(sc, cq-&gt;cq_id, 0, TRUE);</a>
<a name="ln702">	}</a>
<a name="ln703"> </a>
<a name="ln704">eq_arm:</a>
<a name="ln705">	oce_arm_eq(sc, eq-&gt;eq_id, 0, TRUE, FALSE);</a>
<a name="ln706"> </a>
<a name="ln707">	return;</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710"> </a>
<a name="ln711">static int</a>
<a name="ln712">oce_setup_intr(POCE_SOFTC sc)</a>
<a name="ln713">{</a>
<a name="ln714">	int rc = 0, use_intx = 0;</a>
<a name="ln715">	int vector = 0, req_vectors = 0;</a>
<a name="ln716">	int tot_req_vectors, tot_vectors;</a>
<a name="ln717"> </a>
<a name="ln718">	if (is_rss_enabled(sc))</a>
<a name="ln719">		req_vectors = MAX((sc-&gt;nrqs - 1), sc-&gt;nwqs);</a>
<a name="ln720">	else</a>
<a name="ln721">		req_vectors = 1;</a>
<a name="ln722"> </a>
<a name="ln723">	tot_req_vectors = req_vectors;</a>
<a name="ln724">	if (sc-&gt;rdma_flags &amp; OCE_RDMA_FLAG_SUPPORTED) {</a>
<a name="ln725">	  if (req_vectors &gt; 1) {</a>
<a name="ln726">	    tot_req_vectors += OCE_RDMA_VECTORS;</a>
<a name="ln727">	    sc-&gt;roce_intr_count = OCE_RDMA_VECTORS;</a>
<a name="ln728">	  }</a>
<a name="ln729">	}</a>
<a name="ln730"> </a>
<a name="ln731">        if (sc-&gt;flags &amp; OCE_FLAGS_MSIX_CAPABLE) {</a>
<a name="ln732">		sc-&gt;intr_count = req_vectors;</a>
<a name="ln733">                tot_vectors = tot_req_vectors;</a>
<a name="ln734">		rc = pci_alloc_msix(sc-&gt;dev, &amp;tot_vectors);</a>
<a name="ln735">		if (rc != 0) {</a>
<a name="ln736">			use_intx = 1;</a>
<a name="ln737">			pci_release_msi(sc-&gt;dev);</a>
<a name="ln738">		} else {</a>
<a name="ln739">		  if (sc-&gt;rdma_flags &amp; OCE_RDMA_FLAG_SUPPORTED) {</a>
<a name="ln740">		    if (tot_vectors &lt; tot_req_vectors) {</a>
<a name="ln741">		      if (sc-&gt;intr_count &lt; (2 * OCE_RDMA_VECTORS)) {</a>
<a name="ln742">			sc-&gt;roce_intr_count = (tot_vectors / 2);</a>
<a name="ln743">		      }</a>
<a name="ln744">		      sc-&gt;intr_count = tot_vectors - sc-&gt;roce_intr_count;</a>
<a name="ln745">		    }</a>
<a name="ln746">		  } else {</a>
<a name="ln747">		    sc-&gt;intr_count = tot_vectors;</a>
<a name="ln748">		  }</a>
<a name="ln749">    		  sc-&gt;flags |= OCE_FLAGS_USING_MSIX;</a>
<a name="ln750">		}</a>
<a name="ln751">	} else</a>
<a name="ln752">		use_intx = 1;</a>
<a name="ln753"> </a>
<a name="ln754">	if (use_intx)</a>
<a name="ln755">		sc-&gt;intr_count = 1;</a>
<a name="ln756"> </a>
<a name="ln757">	/* Scale number of queues based on intr we got */</a>
<a name="ln758">	update_queues_got(sc);</a>
<a name="ln759"> </a>
<a name="ln760">	if (use_intx) {</a>
<a name="ln761">		device_printf(sc-&gt;dev, &quot;Using legacy interrupt\n&quot;);</a>
<a name="ln762">		rc = oce_alloc_intr(sc, vector, oce_intr);</a>
<a name="ln763">		if (rc)</a>
<a name="ln764">			goto error;</a>
<a name="ln765">	} else {</a>
<a name="ln766">		for (; vector &lt; sc-&gt;intr_count; vector++) {</a>
<a name="ln767">			rc = oce_alloc_intr(sc, vector, oce_intr);</a>
<a name="ln768">			if (rc)</a>
<a name="ln769">				goto error;</a>
<a name="ln770">		}</a>
<a name="ln771">	}</a>
<a name="ln772"> </a>
<a name="ln773">	return 0;</a>
<a name="ln774">error:</a>
<a name="ln775">	oce_intr_free(sc);</a>
<a name="ln776">	return rc;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779"> </a>
<a name="ln780">static int</a>
<a name="ln781">oce_fast_isr(void *arg)</a>
<a name="ln782">{</a>
<a name="ln783">	POCE_INTR_INFO ii = (POCE_INTR_INFO) arg;</a>
<a name="ln784">	POCE_SOFTC sc = ii-&gt;sc;</a>
<a name="ln785"> </a>
<a name="ln786">	if (ii-&gt;eq == NULL)</a>
<a name="ln787">		return FILTER_STRAY;</a>
<a name="ln788"> </a>
<a name="ln789">	oce_arm_eq(sc, ii-&gt;eq-&gt;eq_id, 0, FALSE, TRUE);</a>
<a name="ln790"> </a>
<a name="ln791">	taskqueue_enqueue(ii-&gt;tq, &amp;ii-&gt;task);</a>
<a name="ln792"> </a>
<a name="ln793"> 	ii-&gt;eq-&gt;intr++;</a>
<a name="ln794"> </a>
<a name="ln795">	return FILTER_HANDLED;</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798"> </a>
<a name="ln799">static int</a>
<a name="ln800">oce_alloc_intr(POCE_SOFTC sc, int vector, void (*isr) (void *arg, int pending))</a>
<a name="ln801">{</a>
<a name="ln802">	POCE_INTR_INFO ii = &amp;sc-&gt;intrs[vector];</a>
<a name="ln803">	int rc = 0, rr;</a>
<a name="ln804"> </a>
<a name="ln805">	if (vector &gt;= OCE_MAX_EQ)</a>
<a name="ln806">		return (EINVAL);</a>
<a name="ln807"> </a>
<a name="ln808">	/* Set the resource id for the interrupt.</a>
<a name="ln809">	 * MSIx is vector + 1 for the resource id,</a>
<a name="ln810">	 * INTx is 0 for the resource id.</a>
<a name="ln811">	 */</a>
<a name="ln812">	if (sc-&gt;flags &amp; OCE_FLAGS_USING_MSIX)</a>
<a name="ln813">		rr = vector + 1;</a>
<a name="ln814">	else</a>
<a name="ln815">		rr = 0;</a>
<a name="ln816">	ii-&gt;intr_res = bus_alloc_resource_any(sc-&gt;dev,</a>
<a name="ln817">					      SYS_RES_IRQ,</a>
<a name="ln818">					      &amp;rr, RF_ACTIVE|RF_SHAREABLE);</a>
<a name="ln819">	ii-&gt;irq_rr = rr;</a>
<a name="ln820">	if (ii-&gt;intr_res == NULL) {</a>
<a name="ln821">		device_printf(sc-&gt;dev,</a>
<a name="ln822">			  &quot;Could not allocate interrupt\n&quot;);</a>
<a name="ln823">		rc = ENXIO;</a>
<a name="ln824">		return rc;</a>
<a name="ln825">	}</a>
<a name="ln826"> </a>
<a name="ln827">	TASK_INIT(&amp;ii-&gt;task, 0, isr, ii);</a>
<a name="ln828">	ii-&gt;vector = vector;</a>
<a name="ln829">	sprintf(ii-&gt;task_name, &quot;oce_task[%d]&quot;, ii-&gt;vector);</a>
<a name="ln830">	ii-&gt;tq = taskqueue_create_fast(ii-&gt;task_name,</a>
<a name="ln831">			M_NOWAIT,</a>
<a name="ln832">			taskqueue_thread_enqueue,</a>
<a name="ln833">			&amp;ii-&gt;tq);</a>
<a name="ln834">	taskqueue_start_threads(&amp;ii-&gt;tq, 1, PI_NET, &quot;%s taskq&quot;,</a>
<a name="ln835">			device_get_nameunit(sc-&gt;dev));</a>
<a name="ln836"> </a>
<a name="ln837">	ii-&gt;sc = sc;</a>
<a name="ln838">	rc = bus_setup_intr(sc-&gt;dev,</a>
<a name="ln839">			ii-&gt;intr_res,</a>
<a name="ln840">			INTR_TYPE_NET,</a>
<a name="ln841">			oce_fast_isr, NULL, ii, &amp;ii-&gt;tag);</a>
<a name="ln842">	return rc;</a>
<a name="ln843"> </a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846"> </a>
<a name="ln847">void</a>
<a name="ln848">oce_intr_free(POCE_SOFTC sc)</a>
<a name="ln849">{</a>
<a name="ln850">	int i = 0;</a>
<a name="ln851"> </a>
<a name="ln852">	for (i = 0; i &lt; sc-&gt;intr_count; i++) {</a>
<a name="ln853"> </a>
<a name="ln854">		if (sc-&gt;intrs[i].tag != NULL)</a>
<a name="ln855">			bus_teardown_intr(sc-&gt;dev, sc-&gt;intrs[i].intr_res,</a>
<a name="ln856">						sc-&gt;intrs[i].tag);</a>
<a name="ln857">		if (sc-&gt;intrs[i].tq != NULL)</a>
<a name="ln858">			taskqueue_free(sc-&gt;intrs[i].tq);</a>
<a name="ln859"> </a>
<a name="ln860">		if (sc-&gt;intrs[i].intr_res != NULL)</a>
<a name="ln861">			bus_release_resource(sc-&gt;dev, SYS_RES_IRQ,</a>
<a name="ln862">						sc-&gt;intrs[i].irq_rr,</a>
<a name="ln863">						sc-&gt;intrs[i].intr_res);</a>
<a name="ln864">		sc-&gt;intrs[i].tag = NULL;</a>
<a name="ln865">		sc-&gt;intrs[i].intr_res = NULL;</a>
<a name="ln866">	}</a>
<a name="ln867"> </a>
<a name="ln868">	if (sc-&gt;flags &amp; OCE_FLAGS_USING_MSIX)</a>
<a name="ln869">		pci_release_msi(sc-&gt;dev);</a>
<a name="ln870"> </a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873"> </a>
<a name="ln874"> </a>
<a name="ln875">/******************************************************************************</a>
<a name="ln876">*			  Media callbacks functions 			      *</a>
<a name="ln877">******************************************************************************/</a>
<a name="ln878"> </a>
<a name="ln879">static void</a>
<a name="ln880">oce_media_status(struct ifnet *ifp, struct ifmediareq *req)</a>
<a name="ln881">{</a>
<a name="ln882">	POCE_SOFTC sc = (POCE_SOFTC) ifp-&gt;if_softc;</a>
<a name="ln883"> </a>
<a name="ln884"> </a>
<a name="ln885">	req-&gt;ifm_status = IFM_AVALID;</a>
<a name="ln886">	req-&gt;ifm_active = IFM_ETHER;</a>
<a name="ln887"> </a>
<a name="ln888">	if (sc-&gt;link_status == 1)</a>
<a name="ln889">		req-&gt;ifm_status |= IFM_ACTIVE;</a>
<a name="ln890">	else</a>
<a name="ln891">		return;</a>
<a name="ln892"> </a>
<a name="ln893">	switch (sc-&gt;link_speed) {</a>
<a name="ln894">	case 1: /* 10 Mbps */</a>
<a name="ln895">		req-&gt;ifm_active |= IFM_10_T | IFM_FDX;</a>
<a name="ln896">		sc-&gt;speed = 10;</a>
<a name="ln897">		break;</a>
<a name="ln898">	case 2: /* 100 Mbps */</a>
<a name="ln899">		req-&gt;ifm_active |= IFM_100_TX | IFM_FDX;</a>
<a name="ln900">		sc-&gt;speed = 100;</a>
<a name="ln901">		break;</a>
<a name="ln902">	case 3: /* 1 Gbps */</a>
<a name="ln903">		req-&gt;ifm_active |= IFM_1000_T | IFM_FDX;</a>
<a name="ln904">		sc-&gt;speed = 1000;</a>
<a name="ln905">		break;</a>
<a name="ln906">	case 4: /* 10 Gbps */</a>
<a name="ln907">		req-&gt;ifm_active |= IFM_10G_SR | IFM_FDX;</a>
<a name="ln908">		sc-&gt;speed = 10000;</a>
<a name="ln909">		break;</a>
<a name="ln910">	case 5: /* 20 Gbps */</a>
<a name="ln911">		req-&gt;ifm_active |= IFM_10G_SR | IFM_FDX;</a>
<a name="ln912">		sc-&gt;speed = 20000;</a>
<a name="ln913">		break;</a>
<a name="ln914">	case 6: /* 25 Gbps */</a>
<a name="ln915">		req-&gt;ifm_active |= IFM_10G_SR | IFM_FDX;</a>
<a name="ln916">		sc-&gt;speed = 25000;</a>
<a name="ln917">		break;</a>
<a name="ln918">	case 7: /* 40 Gbps */</a>
<a name="ln919">		req-&gt;ifm_active |= IFM_40G_SR4 | IFM_FDX;</a>
<a name="ln920">		sc-&gt;speed = 40000;</a>
<a name="ln921">		break;</a>
<a name="ln922">	default:</a>
<a name="ln923">		sc-&gt;speed = 0;</a>
<a name="ln924">		break;</a>
<a name="ln925">	}</a>
<a name="ln926"> </a>
<a name="ln927">	return;</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930"> </a>
<a name="ln931">int</a>
<a name="ln932">oce_media_change(struct ifnet *ifp)</a>
<a name="ln933">{</a>
<a name="ln934">	return 0;</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937"> </a>
<a name="ln938">static void oce_is_pkt_dest_bmc(POCE_SOFTC sc,</a>
<a name="ln939">				struct mbuf *m, boolean_t *os2bmc,</a>
<a name="ln940">				struct mbuf **m_new)</a>
<a name="ln941">{</a>
<a name="ln942">	struct ether_header *eh = NULL;</a>
<a name="ln943"> </a>
<a name="ln944">	eh = mtod(m, struct ether_header *);</a>
<a name="ln945"> </a>
<a name="ln946">	if (!is_os2bmc_enabled(sc) || *os2bmc) {</a>
<a name="ln947">		*os2bmc = FALSE;</a>
<a name="ln948">		goto done;</a>
<a name="ln949">	}</a>
<a name="ln950">	if (!ETHER_IS_MULTICAST(eh-&gt;ether_dhost))</a>
<a name="ln951">		goto done;</a>
<a name="ln952"> </a>
<a name="ln953">	if (is_mc_allowed_on_bmc(sc, eh) ||</a>
<a name="ln954">	    is_bc_allowed_on_bmc(sc, eh) ||</a>
<a name="ln955">	    is_arp_allowed_on_bmc(sc, ntohs(eh-&gt;ether_type))) {</a>
<a name="ln956">		*os2bmc = TRUE;</a>
<a name="ln957">		goto done;</a>
<a name="ln958">	}</a>
<a name="ln959"> </a>
<a name="ln960">	if (mtod(m, struct ip *)-&gt;ip_p == IPPROTO_IPV6) {</a>
<a name="ln961">		struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);</a>
<a name="ln962">		uint8_t nexthdr = ip6-&gt;ip6_nxt;</a>
<a name="ln963">		if (nexthdr == IPPROTO_ICMPV6) {</a>
<a name="ln964">			struct icmp6_hdr *icmp6 = (struct icmp6_hdr *)(ip6 + 1);</a>
<a name="ln965">			switch (icmp6-&gt;icmp6_type) {</a>
<a name="ln966">			case ND_ROUTER_ADVERT:</a>
<a name="ln967">				*os2bmc = is_ipv6_ra_filt_enabled(sc);</a>
<a name="ln968">				goto done;</a>
<a name="ln969">			case ND_NEIGHBOR_ADVERT:</a>
<a name="ln970">				*os2bmc = is_ipv6_na_filt_enabled(sc);</a>
<a name="ln971">				goto done;</a>
<a name="ln972">			default:</a>
<a name="ln973">				break;</a>
<a name="ln974">			}</a>
<a name="ln975">		}</a>
<a name="ln976">	}</a>
<a name="ln977"> </a>
<a name="ln978">	if (mtod(m, struct ip *)-&gt;ip_p == IPPROTO_UDP) {</a>
<a name="ln979">		struct ip *ip = mtod(m, struct ip *);</a>
<a name="ln980">		int iphlen = ip-&gt;ip_hl &lt;&lt; 2;</a>
<a name="ln981">		struct udphdr *uh = (struct udphdr *)((caddr_t)ip + iphlen);</a>
<a name="ln982">		switch (uh-&gt;uh_dport) {</a>
<a name="ln983">		case DHCP_CLIENT_PORT:</a>
<a name="ln984">			*os2bmc = is_dhcp_client_filt_enabled(sc);</a>
<a name="ln985">			goto done;</a>
<a name="ln986">		case DHCP_SERVER_PORT:</a>
<a name="ln987">			*os2bmc = is_dhcp_srvr_filt_enabled(sc);</a>
<a name="ln988">			goto done;</a>
<a name="ln989">		case NET_BIOS_PORT1:</a>
<a name="ln990">		case NET_BIOS_PORT2:</a>
<a name="ln991">			*os2bmc = is_nbios_filt_enabled(sc);</a>
<a name="ln992">			goto done;</a>
<a name="ln993">		case DHCPV6_RAS_PORT:</a>
<a name="ln994">			*os2bmc = is_ipv6_ras_filt_enabled(sc);</a>
<a name="ln995">			goto done;</a>
<a name="ln996">		default:</a>
<a name="ln997">			break;</a>
<a name="ln998">		}</a>
<a name="ln999">	}</a>
<a name="ln1000">done:</a>
<a name="ln1001">	if (*os2bmc) {</a>
<a name="ln1002">		*m_new = m_dup(m, M_NOWAIT);</a>
<a name="ln1003">		if (!*m_new) {</a>
<a name="ln1004">			*os2bmc = FALSE;</a>
<a name="ln1005">			return;</a>
<a name="ln1006">		}</a>
<a name="ln1007">		*m_new = oce_insert_vlan_tag(sc, *m_new, NULL);</a>
<a name="ln1008">	}</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011"> </a>
<a name="ln1012"> </a>
<a name="ln1013">/*****************************************************************************</a>
<a name="ln1014"> *			  Transmit routines functions			     *</a>
<a name="ln1015"> *****************************************************************************/</a>
<a name="ln1016"> </a>
<a name="ln1017">static int</a>
<a name="ln1018">oce_tx(POCE_SOFTC sc, struct mbuf **mpp, int wq_index)</a>
<a name="ln1019">{</a>
<a name="ln1020">	int rc = 0, i, retry_cnt = 0;</a>
<a name="ln1021">	bus_dma_segment_t segs[OCE_MAX_TX_ELEMENTS];</a>
<a name="ln1022">	struct mbuf *m, *m_temp, *m_new = NULL;</a>
<a name="ln1023">	struct oce_wq *wq = sc-&gt;wq[wq_index];</a>
<a name="ln1024">	struct oce_packet_desc *pd;</a>
<a name="ln1025">	struct oce_nic_hdr_wqe *nichdr;</a>
<a name="ln1026">	struct oce_nic_frag_wqe *nicfrag;</a>
<a name="ln1027">	struct ether_header *eh = NULL;</a>
<a name="ln1028">	int num_wqes;</a>
<a name="ln1029">	uint32_t reg_value;</a>
<a name="ln1030">	boolean_t complete = TRUE;</a>
<a name="ln1031">	boolean_t os2bmc = FALSE;</a>
<a name="ln1032"> </a>
<a name="ln1033">	m = *mpp;</a>
<a name="ln1034">	if (!m)</a>
<a name="ln1035">		return EINVAL;</a>
<a name="ln1036"> </a>
<a name="ln1037">	if (!(m-&gt;m_flags &amp; M_PKTHDR)) {</a>
<a name="ln1038">		rc = ENXIO;</a>
<a name="ln1039">		goto free_ret;</a>
<a name="ln1040">	}</a>
<a name="ln1041"> </a>
<a name="ln1042">	/* Don't allow non-TSO packets longer than MTU */</a>
<a name="ln1043">	if (!is_tso_pkt(m)) {</a>
<a name="ln1044">		eh = mtod(m, struct ether_header *);</a>
<a name="ln1045">		if(m-&gt;m_pkthdr.len &gt; ETHER_MAX_FRAME(sc-&gt;ifp, eh-&gt;ether_type, FALSE))</a>
<a name="ln1046">			 goto free_ret;</a>
<a name="ln1047">	}</a>
<a name="ln1048"> </a>
<a name="ln1049">	if(oce_tx_asic_stall_verify(sc, m)) {</a>
<a name="ln1050">		m = oce_insert_vlan_tag(sc, m, &amp;complete);</a>
<a name="ln1051">		if(!m) {</a>
<a name="ln1052">			device_printf(sc-&gt;dev, &quot;Insertion unsuccessful\n&quot;);</a>
<a name="ln1053">			return 0;</a>
<a name="ln1054">		}</a>
<a name="ln1055"> </a>
<a name="ln1056">	}</a>
<a name="ln1057"> </a>
<a name="ln1058">	/* Lancer, SH ASIC has a bug wherein Packets that are 32 bytes or less</a>
<a name="ln1059">	 * may cause a transmit stall on that port. So the work-around is to</a>
<a name="ln1060">	 * pad short packets (&lt;= 32 bytes) to a 36-byte length.</a>
<a name="ln1061">	*/</a>
<a name="ln1062">	if(IS_SH(sc) || IS_XE201(sc) ) {</a>
<a name="ln1063">		if(m-&gt;m_pkthdr.len &lt;= 32) {</a>
<a name="ln1064">			char buf[36];</a>
<a name="ln1065">			bzero((void *)buf, 36);</a>
<a name="ln1066">			m_append(m, (36 - m-&gt;m_pkthdr.len), buf);</a>
<a name="ln1067">		}</a>
<a name="ln1068">	}</a>
<a name="ln1069"> </a>
<a name="ln1070">tx_start:</a>
<a name="ln1071">	if (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) {</a>
<a name="ln1072">		/* consolidate packet buffers for TSO/LSO segment offload */</a>
<a name="ln1073">#if defined(INET6) || defined(INET)</a>
<a name="ln1074">		m = oce_tso_setup(sc, mpp);</a>
<a name="ln1075">#else</a>
<a name="ln1076">		m = NULL;</a>
<a name="ln1077">#endif</a>
<a name="ln1078">		if (m == NULL) {</a>
<a name="ln1079">			rc = ENXIO;</a>
<a name="ln1080">			goto free_ret;</a>
<a name="ln1081">		}</a>
<a name="ln1082">	}</a>
<a name="ln1083"> </a>
<a name="ln1084"> </a>
<a name="ln1085">	pd = &amp;wq-&gt;pckts[wq-&gt;pkt_desc_head];</a>
<a name="ln1086"> </a>
<a name="ln1087">retry:</a>
<a name="ln1088">	rc = bus_dmamap_load_mbuf_sg(wq-&gt;tag,</a>
<a name="ln1089">				     pd-&gt;map,</a>
<a name="ln1090">				     m, segs, &amp;pd-&gt;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln1091">	if (rc == 0) {</a>
<a name="ln1092">		num_wqes = pd-&gt;nsegs + 1;</a>
<a name="ln1093">		if (IS_BE(sc) || IS_SH(sc)) {</a>
<a name="ln1094">			/*Dummy required only for BE3.*/</a>
<a name="ln1095">			if (num_wqes &amp; 1)</a>
<a name="ln1096">				num_wqes++;</a>
<a name="ln1097">		}</a>
<a name="ln1098">		if (num_wqes &gt;= RING_NUM_FREE(wq-&gt;ring)) {</a>
<a name="ln1099">			bus_dmamap_unload(wq-&gt;tag, pd-&gt;map);</a>
<a name="ln1100">			return EBUSY;</a>
<a name="ln1101">		}</a>
<a name="ln1102">		atomic_store_rel_int(&amp;wq-&gt;pkt_desc_head,</a>
<a name="ln1103">				     (wq-&gt;pkt_desc_head + 1) % \</a>
<a name="ln1104">				      OCE_WQ_PACKET_ARRAY_SIZE);</a>
<a name="ln1105">		bus_dmamap_sync(wq-&gt;tag, pd-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1106">		pd-&gt;mbuf = m;</a>
<a name="ln1107"> </a>
<a name="ln1108">		nichdr =</a>
<a name="ln1109">		    RING_GET_PRODUCER_ITEM_VA(wq-&gt;ring, struct oce_nic_hdr_wqe);</a>
<a name="ln1110">		nichdr-&gt;u0.dw[0] = 0;</a>
<a name="ln1111">		nichdr-&gt;u0.dw[1] = 0;</a>
<a name="ln1112">		nichdr-&gt;u0.dw[2] = 0;</a>
<a name="ln1113">		nichdr-&gt;u0.dw[3] = 0;</a>
<a name="ln1114"> </a>
<a name="ln1115">		nichdr-&gt;u0.s.complete = complete;</a>
<a name="ln1116">		nichdr-&gt;u0.s.mgmt = os2bmc;</a>
<a name="ln1117">		nichdr-&gt;u0.s.event = 1;</a>
<a name="ln1118">		nichdr-&gt;u0.s.crc = 1;</a>
<a name="ln1119">		nichdr-&gt;u0.s.forward = 0;</a>
<a name="ln1120">		nichdr-&gt;u0.s.ipcs = (m-&gt;m_pkthdr.csum_flags &amp; CSUM_IP) ? 1 : 0;</a>
<a name="ln1121">		nichdr-&gt;u0.s.udpcs =</a>
<a name="ln1122">			(m-&gt;m_pkthdr.csum_flags &amp; CSUM_UDP) ? 1 : 0;</a>
<a name="ln1123">		nichdr-&gt;u0.s.tcpcs =</a>
<a name="ln1124">			(m-&gt;m_pkthdr.csum_flags &amp; CSUM_TCP) ? 1 : 0;</a>
<a name="ln1125">		nichdr-&gt;u0.s.num_wqe = num_wqes;</a>
<a name="ln1126">		nichdr-&gt;u0.s.total_length = m-&gt;m_pkthdr.len;</a>
<a name="ln1127"> </a>
<a name="ln1128">		if (m-&gt;m_flags &amp; M_VLANTAG) {</a>
<a name="ln1129">			nichdr-&gt;u0.s.vlan = 1; /*Vlan present*/</a>
<a name="ln1130">			nichdr-&gt;u0.s.vlan_tag = m-&gt;m_pkthdr.ether_vtag;</a>
<a name="ln1131">		}</a>
<a name="ln1132"> </a>
<a name="ln1133">		if (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) {</a>
<a name="ln1134">			if (m-&gt;m_pkthdr.tso_segsz) {</a>
<a name="ln1135">				nichdr-&gt;u0.s.lso = 1;</a>
<a name="ln1136">				nichdr-&gt;u0.s.lso_mss  = m-&gt;m_pkthdr.tso_segsz;</a>
<a name="ln1137">			}</a>
<a name="ln1138">			if (!IS_BE(sc) || !IS_SH(sc))</a>
<a name="ln1139">				nichdr-&gt;u0.s.ipcs = 1;</a>
<a name="ln1140">		}</a>
<a name="ln1141"> </a>
<a name="ln1142">		RING_PUT(wq-&gt;ring, 1);</a>
<a name="ln1143">		atomic_add_int(&amp;wq-&gt;ring-&gt;num_used, 1);</a>
<a name="ln1144"> </a>
<a name="ln1145">		for (i = 0; i &lt; pd-&gt;nsegs; i++) {</a>
<a name="ln1146">			nicfrag =</a>
<a name="ln1147">			    RING_GET_PRODUCER_ITEM_VA(wq-&gt;ring,</a>
<a name="ln1148">						      struct oce_nic_frag_wqe);</a>
<a name="ln1149">			nicfrag-&gt;u0.s.rsvd0 = 0;</a>
<a name="ln1150">			nicfrag-&gt;u0.s.frag_pa_hi = ADDR_HI(segs[i].ds_addr);</a>
<a name="ln1151">			nicfrag-&gt;u0.s.frag_pa_lo = ADDR_LO(segs[i].ds_addr);</a>
<a name="ln1152">			nicfrag-&gt;u0.s.frag_len = segs[i].ds_len;</a>
<a name="ln1153">			pd-&gt;wqe_idx = wq-&gt;ring-&gt;pidx;</a>
<a name="ln1154">			RING_PUT(wq-&gt;ring, 1);</a>
<a name="ln1155">			atomic_add_int(&amp;wq-&gt;ring-&gt;num_used, 1);</a>
<a name="ln1156">		}</a>
<a name="ln1157">		if (num_wqes &gt; (pd-&gt;nsegs + 1)) {</a>
<a name="ln1158">			nicfrag =</a>
<a name="ln1159">			    RING_GET_PRODUCER_ITEM_VA(wq-&gt;ring,</a>
<a name="ln1160">						      struct oce_nic_frag_wqe);</a>
<a name="ln1161">			nicfrag-&gt;u0.dw[0] = 0;</a>
<a name="ln1162">			nicfrag-&gt;u0.dw[1] = 0;</a>
<a name="ln1163">			nicfrag-&gt;u0.dw[2] = 0;</a>
<a name="ln1164">			nicfrag-&gt;u0.dw[3] = 0;</a>
<a name="ln1165">			pd-&gt;wqe_idx = wq-&gt;ring-&gt;pidx;</a>
<a name="ln1166">			RING_PUT(wq-&gt;ring, 1);</a>
<a name="ln1167">			atomic_add_int(&amp;wq-&gt;ring-&gt;num_used, 1);</a>
<a name="ln1168">			pd-&gt;nsegs++;</a>
<a name="ln1169">		}</a>
<a name="ln1170"> </a>
<a name="ln1171">		if_inc_counter(sc-&gt;ifp, IFCOUNTER_OPACKETS, 1);</a>
<a name="ln1172">		wq-&gt;tx_stats.tx_reqs++;</a>
<a name="ln1173">		wq-&gt;tx_stats.tx_wrbs += num_wqes;</a>
<a name="ln1174">		wq-&gt;tx_stats.tx_bytes += m-&gt;m_pkthdr.len;</a>
<a name="ln1175">		wq-&gt;tx_stats.tx_pkts++;</a>
<a name="ln1176"> </a>
<a name="ln1177">		bus_dmamap_sync(wq-&gt;ring-&gt;dma.tag, wq-&gt;ring-&gt;dma.map,</a>
<a name="ln1178">				BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln1179">		reg_value = (num_wqes &lt;&lt; 16) | wq-&gt;wq_id;</a>
<a name="ln1180"> </a>
<a name="ln1181">		/* if os2bmc is not enabled or if the pkt is already tagged as</a>
<a name="ln1182">		   bmc, do nothing</a>
<a name="ln1183">		 */</a>
<a name="ln1184">		oce_is_pkt_dest_bmc(sc, m, &amp;os2bmc, &amp;m_new);</a>
<a name="ln1185"> </a>
<a name="ln1186">		OCE_WRITE_REG32(sc, db, wq-&gt;db_offset, reg_value);</a>
<a name="ln1187"> </a>
<a name="ln1188">	} else if (rc == EFBIG)	{</a>
<a name="ln1189">		if (retry_cnt == 0) {</a>
<a name="ln1190">			m_temp = m_defrag(m, M_NOWAIT);</a>
<a name="ln1191">			if (m_temp == NULL)</a>
<a name="ln1192">				goto free_ret;</a>
<a name="ln1193">			m = m_temp;</a>
<a name="ln1194">			*mpp = m_temp;</a>
<a name="ln1195">			retry_cnt = retry_cnt + 1;</a>
<a name="ln1196">			goto retry;</a>
<a name="ln1197">		} else</a>
<a name="ln1198">			goto free_ret;</a>
<a name="ln1199">	} else if (rc == ENOMEM)</a>
<a name="ln1200">		return rc;</a>
<a name="ln1201">	else</a>
<a name="ln1202">		goto free_ret;</a>
<a name="ln1203"> </a>
<a name="ln1204">	if (os2bmc) {</a>
<a name="ln1205">		m = m_new;</a>
<a name="ln1206">		goto tx_start;</a>
<a name="ln1207">	}</a>
<a name="ln1208"> </a>
<a name="ln1209">	return 0;</a>
<a name="ln1210"> </a>
<a name="ln1211">free_ret:</a>
<a name="ln1212">	m_freem(*mpp);</a>
<a name="ln1213">	*mpp = NULL;</a>
<a name="ln1214">	return rc;</a>
<a name="ln1215">}</a>
<a name="ln1216"> </a>
<a name="ln1217"> </a>
<a name="ln1218">static void</a>
<a name="ln1219">oce_process_tx_completion(struct oce_wq *wq)</a>
<a name="ln1220">{</a>
<a name="ln1221">	struct oce_packet_desc *pd;</a>
<a name="ln1222">	POCE_SOFTC sc = (POCE_SOFTC) wq-&gt;parent;</a>
<a name="ln1223">	struct mbuf *m;</a>
<a name="ln1224"> </a>
<a name="ln1225">	pd = &amp;wq-&gt;pckts[wq-&gt;pkt_desc_tail];</a>
<a name="ln1226">	atomic_store_rel_int(&amp;wq-&gt;pkt_desc_tail,</a>
<a name="ln1227">			     (wq-&gt;pkt_desc_tail + 1) % OCE_WQ_PACKET_ARRAY_SIZE);</a>
<a name="ln1228">	atomic_subtract_int(&amp;wq-&gt;ring-&gt;num_used, pd-&gt;nsegs + 1);</a>
<a name="ln1229">	bus_dmamap_sync(wq-&gt;tag, pd-&gt;map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1230">	bus_dmamap_unload(wq-&gt;tag, pd-&gt;map);</a>
<a name="ln1231"> </a>
<a name="ln1232">	m = pd-&gt;mbuf;</a>
<a name="ln1233">	m_freem(m);</a>
<a name="ln1234">	pd-&gt;mbuf = NULL;</a>
<a name="ln1235"> </a>
<a name="ln1236"> </a>
<a name="ln1237">	if (sc-&gt;ifp-&gt;if_drv_flags &amp; IFF_DRV_OACTIVE) {</a>
<a name="ln1238">		if (wq-&gt;ring-&gt;num_used &lt; (wq-&gt;ring-&gt;num_items / 2)) {</a>
<a name="ln1239">			sc-&gt;ifp-&gt;if_drv_flags &amp;= ~(IFF_DRV_OACTIVE);</a>
<a name="ln1240">			oce_tx_restart(sc, wq);</a>
<a name="ln1241">		}</a>
<a name="ln1242">	}</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245"> </a>
<a name="ln1246">static void</a>
<a name="ln1247">oce_tx_restart(POCE_SOFTC sc, struct oce_wq *wq)</a>
<a name="ln1248">{</a>
<a name="ln1249"> </a>
<a name="ln1250">	if ((sc-&gt;ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != IFF_DRV_RUNNING)</a>
<a name="ln1251">		return;</a>
<a name="ln1252"> </a>
<a name="ln1253">#if __FreeBSD_version &gt;= 800000</a>
<a name="ln1254">	if (!drbr_empty(sc-&gt;ifp, wq-&gt;br))</a>
<a name="ln1255">#else</a>
<a name="ln1256">	if (!IFQ_DRV_IS_EMPTY(&amp;sc-&gt;ifp-&gt;if_snd))</a>
<a name="ln1257">#endif</a>
<a name="ln1258">		taskqueue_enqueue(taskqueue_swi, &amp;wq-&gt;txtask);</a>
<a name="ln1259"> </a>
<a name="ln1260">}</a>
<a name="ln1261"> </a>
<a name="ln1262"> </a>
<a name="ln1263">#if defined(INET6) || defined(INET)</a>
<a name="ln1264">static struct mbuf *</a>
<a name="ln1265">oce_tso_setup(POCE_SOFTC sc, struct mbuf **mpp)</a>
<a name="ln1266">{</a>
<a name="ln1267">	struct mbuf *m;</a>
<a name="ln1268">#ifdef INET</a>
<a name="ln1269">	struct ip *ip;</a>
<a name="ln1270">#endif</a>
<a name="ln1271">#ifdef INET6</a>
<a name="ln1272">	struct ip6_hdr *ip6;</a>
<a name="ln1273">#endif</a>
<a name="ln1274">	struct ether_vlan_header *eh;</a>
<a name="ln1275">	struct tcphdr *th;</a>
<a name="ln1276">	uint16_t etype;</a>
<a name="ln1277">	int total_len = 0, ehdrlen = 0;</a>
<a name="ln1278"> </a>
<a name="ln1279">	m = *mpp;</a>
<a name="ln1280"> </a>
<a name="ln1281">	if (M_WRITABLE(m) == 0) {</a>
<a name="ln1282">		m = m_dup(*mpp, M_NOWAIT);</a>
<a name="ln1283">		if (!m)</a>
<a name="ln1284">			return NULL;</a>
<a name="ln1285">		m_freem(*mpp);</a>
<a name="ln1286">		*mpp = m;</a>
<a name="ln1287">	}</a>
<a name="ln1288"> </a>
<a name="ln1289">	eh = mtod(m, struct ether_vlan_header *);</a>
<a name="ln1290">	if (eh-&gt;evl_encap_proto == htons(ETHERTYPE_VLAN)) {</a>
<a name="ln1291">		etype = ntohs(eh-&gt;evl_proto);</a>
<a name="ln1292">		ehdrlen = ETHER_HDR_LEN + ETHER_VLAN_ENCAP_LEN;</a>
<a name="ln1293">	} else {</a>
<a name="ln1294">		etype = ntohs(eh-&gt;evl_encap_proto);</a>
<a name="ln1295">		ehdrlen = ETHER_HDR_LEN;</a>
<a name="ln1296">	}</a>
<a name="ln1297"> </a>
<a name="ln1298">	switch (etype) {</a>
<a name="ln1299">#ifdef INET</a>
<a name="ln1300">	case ETHERTYPE_IP:</a>
<a name="ln1301">		ip = (struct ip *)(m-&gt;m_data + ehdrlen);</a>
<a name="ln1302">		if (ip-&gt;ip_p != IPPROTO_TCP)</a>
<a name="ln1303">			return NULL;</a>
<a name="ln1304">		th = (struct tcphdr *)((caddr_t)ip + (ip-&gt;ip_hl &lt;&lt; 2));</a>
<a name="ln1305"> </a>
<a name="ln1306">		total_len = ehdrlen + (ip-&gt;ip_hl &lt;&lt; 2) + (th-&gt;th_off &lt;&lt; 2);</a>
<a name="ln1307">		break;</a>
<a name="ln1308">#endif</a>
<a name="ln1309">#ifdef INET6</a>
<a name="ln1310">	case ETHERTYPE_IPV6:</a>
<a name="ln1311">		ip6 = (struct ip6_hdr *)(m-&gt;m_data + ehdrlen);</a>
<a name="ln1312">		if (ip6-&gt;ip6_nxt != IPPROTO_TCP)</a>
<a name="ln1313">			return NULL;</a>
<a name="ln1314">		th = (struct tcphdr *)((caddr_t)ip6 + sizeof(struct ip6_hdr));</a>
<a name="ln1315"> </a>
<a name="ln1316">		total_len = ehdrlen + sizeof(struct ip6_hdr) + (th-&gt;th_off &lt;&lt; 2);</a>
<a name="ln1317">		break;</a>
<a name="ln1318">#endif</a>
<a name="ln1319">	default:</a>
<a name="ln1320">		return NULL;</a>
<a name="ln1321">	}</a>
<a name="ln1322"> </a>
<a name="ln1323">	m = m_pullup(m, total_len);</a>
<a name="ln1324">	if (!m)</a>
<a name="ln1325">		return NULL;</a>
<a name="ln1326">	*mpp = m;</a>
<a name="ln1327">	return m;</a>
<a name="ln1328"> </a>
<a name="ln1329">}</a>
<a name="ln1330">#endif /* INET6 || INET */</a>
<a name="ln1331"> </a>
<a name="ln1332">void</a>
<a name="ln1333">oce_tx_task(void *arg, int npending)</a>
<a name="ln1334">{</a>
<a name="ln1335">	struct oce_wq *wq = arg;</a>
<a name="ln1336">	POCE_SOFTC sc = wq-&gt;parent;</a>
<a name="ln1337">	struct ifnet *ifp = sc-&gt;ifp;</a>
<a name="ln1338">	int rc = 0;</a>
<a name="ln1339"> </a>
<a name="ln1340">#if __FreeBSD_version &gt;= 800000</a>
<a name="ln1341">	LOCK(&amp;wq-&gt;tx_lock);</a>
<a name="ln1342">	rc = oce_multiq_transmit(ifp, NULL, wq);</a>
<a name="ln1343">	if (rc) {</a>
<a name="ln1344">		device_printf(sc-&gt;dev,</a>
<a name="ln1345">				&quot;TX[%d] restart failed\n&quot;, wq-&gt;queue_index);</a>
<a name="ln1346">	}</a>
<a name="ln1347">	UNLOCK(&amp;wq-&gt;tx_lock);</a>
<a name="ln1348">#else</a>
<a name="ln1349">	oce_start(ifp);</a>
<a name="ln1350">#endif</a>
<a name="ln1351"> </a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354"> </a>
<a name="ln1355">void</a>
<a name="ln1356">oce_start(struct ifnet *ifp)</a>
<a name="ln1357">{</a>
<a name="ln1358">	POCE_SOFTC sc = ifp-&gt;if_softc;</a>
<a name="ln1359">	struct mbuf *m;</a>
<a name="ln1360">	int rc = 0;</a>
<a name="ln1361">	int def_q = 0; /* Defualt tx queue is 0*/</a>
<a name="ln1362"> </a>
<a name="ln1363">	if ((ifp-&gt;if_drv_flags &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln1364">			IFF_DRV_RUNNING)</a>
<a name="ln1365">		return;</a>
<a name="ln1366"> </a>
<a name="ln1367">	if (!sc-&gt;link_status)</a>
<a name="ln1368">		return;</a>
<a name="ln1369"> </a>
<a name="ln1370">	do {</a>
<a name="ln1371">		IF_DEQUEUE(&amp;sc-&gt;ifp-&gt;if_snd, m);</a>
<a name="ln1372">		if (m == NULL)</a>
<a name="ln1373">			break;</a>
<a name="ln1374"> </a>
<a name="ln1375">		LOCK(&amp;sc-&gt;wq[def_q]-&gt;tx_lock);</a>
<a name="ln1376">		rc = oce_tx(sc, &amp;m, def_q);</a>
<a name="ln1377">		UNLOCK(&amp;sc-&gt;wq[def_q]-&gt;tx_lock);</a>
<a name="ln1378">		if (rc) {</a>
<a name="ln1379">			if (m != NULL) {</a>
<a name="ln1380">				sc-&gt;wq[def_q]-&gt;tx_stats.tx_stops ++;</a>
<a name="ln1381">				ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln1382">				IFQ_DRV_PREPEND(&amp;ifp-&gt;if_snd, m);</a>
<a name="ln1383">				m = NULL;</a>
<a name="ln1384">			}</a>
<a name="ln1385">			break;</a>
<a name="ln1386">		}</a>
<a name="ln1387">		if (m != NULL)</a>
<a name="ln1388">			ETHER_BPF_MTAP(ifp, m);</a>
<a name="ln1389"> </a>
<a name="ln1390">	} while (TRUE);</a>
<a name="ln1391"> </a>
<a name="ln1392">	return;</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395"> </a>
<a name="ln1396">/* Handle the Completion Queue for transmit */</a>
<a name="ln1397">uint16_t</a>
<a name="ln1398">oce_wq_handler(void *arg)</a>
<a name="ln1399">{</a>
<a name="ln1400">	struct oce_wq *wq = (struct oce_wq *)arg;</a>
<a name="ln1401">	POCE_SOFTC sc = wq-&gt;parent;</a>
<a name="ln1402">	struct oce_cq *cq = wq-&gt;cq;</a>
<a name="ln1403">	struct oce_nic_tx_cqe *cqe;</a>
<a name="ln1404">	int num_cqes = 0;</a>
<a name="ln1405"> </a>
<a name="ln1406">	LOCK(&amp;wq-&gt;tx_compl_lock);</a>
<a name="ln1407">	bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,</a>
<a name="ln1408">			cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1409">	cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_nic_tx_cqe);</a>
<a name="ln1410">	while (cqe-&gt;u0.dw[3]) {</a>
<a name="ln1411">		DW_SWAP((uint32_t *) cqe, sizeof(oce_wq_cqe));</a>
<a name="ln1412"> </a>
<a name="ln1413">		wq-&gt;ring-&gt;cidx = cqe-&gt;u0.s.wqe_index + 1;</a>
<a name="ln1414">		if (wq-&gt;ring-&gt;cidx &gt;= wq-&gt;ring-&gt;num_items)</a>
<a name="ln1415">			wq-&gt;ring-&gt;cidx -= wq-&gt;ring-&gt;num_items;</a>
<a name="ln1416"> </a>
<a name="ln1417">		oce_process_tx_completion(wq);</a>
<a name="ln1418">		wq-&gt;tx_stats.tx_compl++;</a>
<a name="ln1419">		cqe-&gt;u0.dw[3] = 0;</a>
<a name="ln1420">		RING_GET(cq-&gt;ring, 1);</a>
<a name="ln1421">		bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,</a>
<a name="ln1422">				cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1423">		cqe =</a>
<a name="ln1424">		    RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_nic_tx_cqe);</a>
<a name="ln1425">		num_cqes++;</a>
<a name="ln1426">	}</a>
<a name="ln1427"> </a>
<a name="ln1428">	if (num_cqes)</a>
<a name="ln1429">		oce_arm_cq(sc, cq-&gt;cq_id, num_cqes, FALSE);</a>
<a name="ln1430"> </a>
<a name="ln1431">	UNLOCK(&amp;wq-&gt;tx_compl_lock);</a>
<a name="ln1432">	return num_cqes;</a>
<a name="ln1433">}</a>
<a name="ln1434"> </a>
<a name="ln1435"> </a>
<a name="ln1436">static int</a>
<a name="ln1437">oce_multiq_transmit(struct ifnet *ifp, struct mbuf *m, struct oce_wq *wq)</a>
<a name="ln1438">{</a>
<a name="ln1439">	POCE_SOFTC sc = ifp-&gt;if_softc;</a>
<a name="ln1440">	int status = 0, queue_index = 0;</a>
<a name="ln1441">	struct mbuf *next = NULL;</a>
<a name="ln1442">	struct buf_ring *br = NULL;</a>
<a name="ln1443"> </a>
<a name="ln1444">	br  = wq-&gt;br;</a>
<a name="ln1445">	queue_index = wq-&gt;queue_index;</a>
<a name="ln1446"> </a>
<a name="ln1447">	if ((ifp-&gt;if_drv_flags &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln1448">		IFF_DRV_RUNNING) {</a>
<a name="ln1449">		if (m != NULL)</a>
<a name="ln1450">			status = drbr_enqueue(ifp, br, m);</a>
<a name="ln1451">		return status;</a>
<a name="ln1452">	}</a>
<a name="ln1453"> </a>
<a name="ln1454">	if (m != NULL) {</a>
<a name="ln1455">		if ((status = drbr_enqueue(ifp, br, m)) != 0)</a>
<a name="ln1456">			return status;</a>
<a name="ln1457">	}</a>
<a name="ln1458">	while ((next = drbr_peek(ifp, br)) != NULL) {</a>
<a name="ln1459">		if (oce_tx(sc, &amp;next, queue_index)) {</a>
<a name="ln1460">			if (next == NULL) {</a>
<a name="ln1461">				drbr_advance(ifp, br);</a>
<a name="ln1462">			} else {</a>
<a name="ln1463">				drbr_putback(ifp, br, next);</a>
<a name="ln1464">				wq-&gt;tx_stats.tx_stops ++;</a>
<a name="ln1465">				ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln1466">			}</a>
<a name="ln1467">			break;</a>
<a name="ln1468">		}</a>
<a name="ln1469">		drbr_advance(ifp, br);</a>
<a name="ln1470">		if_inc_counter(ifp, IFCOUNTER_OBYTES, next-&gt;m_pkthdr.len);</a>
<a name="ln1471">		if (next-&gt;m_flags &amp; M_MCAST)</a>
<a name="ln1472">			if_inc_counter(ifp, IFCOUNTER_OMCASTS, 1);</a>
<a name="ln1473">		ETHER_BPF_MTAP(ifp, next);</a>
<a name="ln1474">	}</a>
<a name="ln1475"> </a>
<a name="ln1476">	return 0;</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479"> </a>
<a name="ln1480"> </a>
<a name="ln1481"> </a>
<a name="ln1482">/*****************************************************************************</a>
<a name="ln1483"> *			    Receive  routines functions 		     *</a>
<a name="ln1484"> *****************************************************************************/</a>
<a name="ln1485"> </a>
<a name="ln1486">static void</a>
<a name="ln1487">oce_correct_header(struct mbuf *m, struct nic_hwlro_cqe_part1 *cqe1, struct nic_hwlro_cqe_part2 *cqe2)</a>
<a name="ln1488">{</a>
<a name="ln1489">	uint32_t *p;</a>
<a name="ln1490">        struct ether_header *eh = NULL;</a>
<a name="ln1491">        struct tcphdr *tcp_hdr = NULL;</a>
<a name="ln1492">        struct ip *ip4_hdr = NULL;</a>
<a name="ln1493">        struct ip6_hdr *ip6 = NULL;</a>
<a name="ln1494">        uint32_t payload_len = 0;</a>
<a name="ln1495"> </a>
<a name="ln1496">        eh = mtod(m, struct ether_header *);</a>
<a name="ln1497">        /* correct IP header */</a>
<a name="ln1498">        if(!cqe2-&gt;ipv6_frame) {</a>
<a name="ln1499">		ip4_hdr = (struct ip *)((char*)eh + sizeof(struct ether_header));</a>
<a name="ln1500">                ip4_hdr-&gt;ip_ttl = cqe2-&gt;frame_lifespan;</a>
<a name="ln1501">                ip4_hdr-&gt;ip_len = htons(cqe2-&gt;coalesced_size - sizeof(struct ether_header));</a>
<a name="ln1502">                tcp_hdr = (struct tcphdr *)((char*)ip4_hdr + sizeof(struct ip));</a>
<a name="ln1503">        }else {</a>
<a name="ln1504">        	ip6 = (struct ip6_hdr *)((char*)eh + sizeof(struct ether_header));</a>
<a name="ln1505">                ip6-&gt;ip6_ctlun.ip6_un1.ip6_un1_hlim = cqe2-&gt;frame_lifespan;</a>
<a name="ln1506">                payload_len = cqe2-&gt;coalesced_size - sizeof(struct ether_header)</a>
<a name="ln1507">                                                - sizeof(struct ip6_hdr);</a>
<a name="ln1508">                ip6-&gt;ip6_ctlun.ip6_un1.ip6_un1_plen = htons(payload_len);</a>
<a name="ln1509">                tcp_hdr = (struct tcphdr *)((char*)ip6 + sizeof(struct ip6_hdr));</a>
<a name="ln1510">        }</a>
<a name="ln1511"> </a>
<a name="ln1512">        /* correct tcp header */</a>
<a name="ln1513">        tcp_hdr-&gt;th_ack = htonl(cqe2-&gt;tcp_ack_num);</a>
<a name="ln1514">#ifndef __HAIKU__</a>
<a name="ln1515">        if(cqe2-&gt;push) {</a>
<a name="ln1516">        	tcp_hdr-&gt;th_flags |= TH_PUSH;</a>
<a name="ln1517">        }</a>
<a name="ln1518">#endif</a>
<a name="ln1519">        tcp_hdr-&gt;th_win = htons(cqe2-&gt;tcp_window);</a>
<a name="ln1520">        tcp_hdr-&gt;th_sum = 0xffff;</a>
<a name="ln1521">        if(cqe2-&gt;ts_opt) {</a>
<a name="ln1522">                p = (uint32_t *)((char*)tcp_hdr + sizeof(struct tcphdr) + 2);</a>
<a name="ln1523">                *p = cqe1-&gt;tcp_timestamp_val;</a>
<a name="ln1524">                *(p+1) = cqe1-&gt;tcp_timestamp_ecr;</a>
<a name="ln1525">        }</a>
<a name="ln1526"> </a>
<a name="ln1527">	return;</a>
<a name="ln1528">}</a>
<a name="ln1529"> </a>
<a name="ln1530">static void</a>
<a name="ln1531">oce_rx_mbuf_chain(struct oce_rq *rq, struct oce_common_cqe_info *cqe_info, struct mbuf **m)</a>
<a name="ln1532">{</a>
<a name="ln1533">	POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln1534">        uint32_t i = 0, frag_len = 0;</a>
<a name="ln1535">	uint32_t len = cqe_info-&gt;pkt_size;</a>
<a name="ln1536">        struct oce_packet_desc *pd;</a>
<a name="ln1537">        struct mbuf *tail = NULL;</a>
<a name="ln1538"> </a>
<a name="ln1539">        for (i = 0; i &lt; cqe_info-&gt;num_frags; i++) {</a>
<a name="ln1540">                if (rq-&gt;ring-&gt;cidx == rq-&gt;ring-&gt;pidx) {</a>
<a name="ln1541">                        device_printf(sc-&gt;dev,</a>
<a name="ln1542">                                  &quot;oce_rx_mbuf_chain: Invalid RX completion - Queue is empty\n&quot;);</a>
<a name="ln1543">                        return;</a>
<a name="ln1544">                }</a>
<a name="ln1545">                pd = &amp;rq-&gt;pckts[rq-&gt;ring-&gt;cidx];</a>
<a name="ln1546"> </a>
<a name="ln1547">                bus_dmamap_sync(rq-&gt;tag, pd-&gt;map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1548">                bus_dmamap_unload(rq-&gt;tag, pd-&gt;map);</a>
<a name="ln1549">		RING_GET(rq-&gt;ring, 1);</a>
<a name="ln1550">                rq-&gt;pending--;</a>
<a name="ln1551"> </a>
<a name="ln1552">                frag_len = (len &gt; rq-&gt;cfg.frag_size) ? rq-&gt;cfg.frag_size : len;</a>
<a name="ln1553">                pd-&gt;mbuf-&gt;m_len = frag_len;</a>
<a name="ln1554"> </a>
<a name="ln1555">                if (tail != NULL) {</a>
<a name="ln1556">                        /* additional fragments */</a>
<a name="ln1557">                        pd-&gt;mbuf-&gt;m_flags &amp;= ~M_PKTHDR;</a>
<a name="ln1558">                        tail-&gt;m_next = pd-&gt;mbuf;</a>
<a name="ln1559">			if(rq-&gt;islro)</a>
<a name="ln1560">                        	tail-&gt;m_nextpkt = NULL;</a>
<a name="ln1561">                        tail = pd-&gt;mbuf;</a>
<a name="ln1562">                } else {</a>
<a name="ln1563">                        /* first fragment, fill out much of the packet header */</a>
<a name="ln1564">                        pd-&gt;mbuf-&gt;m_pkthdr.len = len;</a>
<a name="ln1565">			if(rq-&gt;islro)</a>
<a name="ln1566">                        	pd-&gt;mbuf-&gt;m_nextpkt = NULL;</a>
<a name="ln1567">                        pd-&gt;mbuf-&gt;m_pkthdr.csum_flags = 0;</a>
<a name="ln1568">                        if (IF_CSUM_ENABLED(sc)) {</a>
<a name="ln1569">                                if (cqe_info-&gt;l4_cksum_pass) {</a>
<a name="ln1570">                                        if(!cqe_info-&gt;ipv6_frame) { /* IPV4 */</a>
<a name="ln1571">                                                pd-&gt;mbuf-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln1572">                                                        (CSUM_DATA_VALID | CSUM_PSEUDO_HDR);</a>
<a name="ln1573">                                        }else { /* IPV6 frame */</a>
<a name="ln1574">						if(rq-&gt;islro) {</a>
<a name="ln1575">                                                	pd-&gt;mbuf-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln1576">                                                        (CSUM_DATA_VALID | CSUM_PSEUDO_HDR);</a>
<a name="ln1577">						}</a>
<a name="ln1578">                                        }</a>
<a name="ln1579">                                        pd-&gt;mbuf-&gt;m_pkthdr.csum_data = 0xffff;</a>
<a name="ln1580">                                }</a>
<a name="ln1581">                                if (cqe_info-&gt;ip_cksum_pass) {</a>
<a name="ln1582">                                        pd-&gt;mbuf-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln1583">                                               (CSUM_IP_CHECKED|CSUM_IP_VALID);</a>
<a name="ln1584">                                }</a>
<a name="ln1585">                        }</a>
<a name="ln1586">                        *m = tail = pd-&gt;mbuf;</a>
<a name="ln1587">               }</a>
<a name="ln1588">                pd-&gt;mbuf = NULL;</a>
<a name="ln1589">                len -= frag_len;</a>
<a name="ln1590">        }</a>
<a name="ln1591"> </a>
<a name="ln1592">        return;</a>
<a name="ln1593">}</a>
<a name="ln1594"> </a>
<a name="ln1595">static void</a>
<a name="ln1596">oce_rx_lro(struct oce_rq *rq, struct nic_hwlro_singleton_cqe *cqe, struct nic_hwlro_cqe_part2 *cqe2)</a>
<a name="ln1597">{</a>
<a name="ln1598">        POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln1599">        struct nic_hwlro_cqe_part1 *cqe1 = NULL;</a>
<a name="ln1600">        struct mbuf *m = NULL;</a>
<a name="ln1601">	struct oce_common_cqe_info cq_info;</a>
<a name="ln1602"> </a>
<a name="ln1603">	/* parse cqe */</a>
<a name="ln1604">        if(cqe2 == NULL) {</a>
<a name="ln1605">                cq_info.pkt_size =  cqe-&gt;pkt_size;</a>
<a name="ln1606">                cq_info.vtag = cqe-&gt;vlan_tag;</a>
<a name="ln1607">                cq_info.l4_cksum_pass = cqe-&gt;l4_cksum_pass;</a>
<a name="ln1608">                cq_info.ip_cksum_pass = cqe-&gt;ip_cksum_pass;</a>
<a name="ln1609">                cq_info.ipv6_frame = cqe-&gt;ipv6_frame;</a>
<a name="ln1610">                cq_info.vtp = cqe-&gt;vtp;</a>
<a name="ln1611">                cq_info.qnq = cqe-&gt;qnq;</a>
<a name="ln1612">        }else {</a>
<a name="ln1613">                cqe1 = (struct nic_hwlro_cqe_part1 *)cqe;</a>
<a name="ln1614">                cq_info.pkt_size =  cqe2-&gt;coalesced_size;</a>
<a name="ln1615">                cq_info.vtag = cqe2-&gt;vlan_tag;</a>
<a name="ln1616">                cq_info.l4_cksum_pass = cqe2-&gt;l4_cksum_pass;</a>
<a name="ln1617">                cq_info.ip_cksum_pass = cqe2-&gt;ip_cksum_pass;</a>
<a name="ln1618">                cq_info.ipv6_frame = cqe2-&gt;ipv6_frame;</a>
<a name="ln1619">                cq_info.vtp = cqe2-&gt;vtp;</a>
<a name="ln1620">                cq_info.qnq = cqe1-&gt;qnq;</a>
<a name="ln1621">        }</a>
<a name="ln1622"> </a>
<a name="ln1623">	cq_info.vtag = BSWAP_16(cq_info.vtag);</a>
<a name="ln1624"> </a>
<a name="ln1625">        cq_info.num_frags = cq_info.pkt_size / rq-&gt;cfg.frag_size;</a>
<a name="ln1626">        if(cq_info.pkt_size % rq-&gt;cfg.frag_size)</a>
<a name="ln1627">                cq_info.num_frags++;</a>
<a name="ln1628"> </a>
<a name="ln1629">	oce_rx_mbuf_chain(rq, &amp;cq_info, &amp;m);</a>
<a name="ln1630"> </a>
<a name="ln1631">	if (m) {</a>
<a name="ln1632">		if(cqe2) {</a>
<a name="ln1633">			//assert(cqe2-&gt;valid != 0);</a>
<a name="ln1634"> </a>
<a name="ln1635">			//assert(cqe2-&gt;cqe_type != 2);</a>
<a name="ln1636">			oce_correct_header(m, cqe1, cqe2);</a>
<a name="ln1637">		}</a>
<a name="ln1638"> </a>
<a name="ln1639">		m-&gt;m_pkthdr.rcvif = sc-&gt;ifp;</a>
<a name="ln1640">#if __FreeBSD_version &gt;= 800000</a>
<a name="ln1641">		if (rq-&gt;queue_index)</a>
<a name="ln1642">			m-&gt;m_pkthdr.flowid = (rq-&gt;queue_index - 1);</a>
<a name="ln1643">		else</a>
<a name="ln1644">			m-&gt;m_pkthdr.flowid = rq-&gt;queue_index;</a>
<a name="ln1645">		M_HASHTYPE_SET(m, M_HASHTYPE_OPAQUE);</a>
<a name="ln1646">#endif</a>
<a name="ln1647">		/* This deternies if vlan tag is Valid */</a>
<a name="ln1648">		if (cq_info.vtp) {</a>
<a name="ln1649">			if (sc-&gt;function_mode &amp; FNM_FLEX10_MODE) {</a>
<a name="ln1650">				/* FLEX10. If QnQ is not set, neglect VLAN */</a>
<a name="ln1651">				if (cq_info.qnq) {</a>
<a name="ln1652">					m-&gt;m_pkthdr.ether_vtag = cq_info.vtag;</a>
<a name="ln1653">					m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln1654">				}</a>
<a name="ln1655">			} else if (sc-&gt;pvid != (cq_info.vtag &amp; VLAN_VID_MASK))  {</a>
<a name="ln1656">				/* In UMC mode generally pvid will be striped by</a>
<a name="ln1657">				   hw. But in some cases we have seen it comes</a>
<a name="ln1658">				   with pvid. So if pvid == vlan, neglect vlan.</a>
<a name="ln1659">				 */</a>
<a name="ln1660">				m-&gt;m_pkthdr.ether_vtag = cq_info.vtag;</a>
<a name="ln1661">				m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln1662">			}</a>
<a name="ln1663">		}</a>
<a name="ln1664">		if_inc_counter(sc-&gt;ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln1665"> </a>
<a name="ln1666">		(*sc-&gt;ifp-&gt;if_input) (sc-&gt;ifp, m);</a>
<a name="ln1667"> </a>
<a name="ln1668">		/* Update rx stats per queue */</a>
<a name="ln1669">		rq-&gt;rx_stats.rx_pkts++;</a>
<a name="ln1670">		rq-&gt;rx_stats.rx_bytes += cq_info.pkt_size;</a>
<a name="ln1671">		rq-&gt;rx_stats.rx_frags += cq_info.num_frags;</a>
<a name="ln1672">		rq-&gt;rx_stats.rx_ucast_pkts++;</a>
<a name="ln1673">	}</a>
<a name="ln1674">        return;</a>
<a name="ln1675">}</a>
<a name="ln1676"> </a>
<a name="ln1677">static void</a>
<a name="ln1678">oce_rx(struct oce_rq *rq, struct oce_nic_rx_cqe *cqe)</a>
<a name="ln1679">{</a>
<a name="ln1680">	POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln1681">	int len;</a>
<a name="ln1682">	struct mbuf *m = NULL;</a>
<a name="ln1683">	struct oce_common_cqe_info cq_info;</a>
<a name="ln1684">	uint16_t vtag = 0;</a>
<a name="ln1685"> </a>
<a name="ln1686">	/* Is it a flush compl that has no data */</a>
<a name="ln1687">	if(!cqe-&gt;u0.s.num_fragments)</a>
<a name="ln1688">		goto exit;</a>
<a name="ln1689"> </a>
<a name="ln1690">	len = cqe-&gt;u0.s.pkt_size;</a>
<a name="ln1691">	if (!len) {</a>
<a name="ln1692">		/*partial DMA workaround for Lancer*/</a>
<a name="ln1693">		oce_discard_rx_comp(rq, cqe-&gt;u0.s.num_fragments);</a>
<a name="ln1694">		goto exit;</a>
<a name="ln1695">	}</a>
<a name="ln1696"> </a>
<a name="ln1697">	if (!oce_cqe_portid_valid(sc, cqe)) {</a>
<a name="ln1698">		oce_discard_rx_comp(rq, cqe-&gt;u0.s.num_fragments);</a>
<a name="ln1699">		goto exit;</a>
<a name="ln1700">	}</a>
<a name="ln1701"> </a>
<a name="ln1702">	 /* Get vlan_tag value */</a>
<a name="ln1703">	if(IS_BE(sc) || IS_SH(sc))</a>
<a name="ln1704">		vtag = BSWAP_16(cqe-&gt;u0.s.vlan_tag);</a>
<a name="ln1705">	else</a>
<a name="ln1706">		vtag = cqe-&gt;u0.s.vlan_tag;</a>
<a name="ln1707"> </a>
<a name="ln1708">	cq_info.l4_cksum_pass = cqe-&gt;u0.s.l4_cksum_pass;</a>
<a name="ln1709">	cq_info.ip_cksum_pass = cqe-&gt;u0.s.ip_cksum_pass;</a>
<a name="ln1710">	cq_info.ipv6_frame = cqe-&gt;u0.s.ip_ver;</a>
<a name="ln1711">	cq_info.num_frags = cqe-&gt;u0.s.num_fragments;</a>
<a name="ln1712">	cq_info.pkt_size = cqe-&gt;u0.s.pkt_size;</a>
<a name="ln1713"> </a>
<a name="ln1714">	oce_rx_mbuf_chain(rq, &amp;cq_info, &amp;m);</a>
<a name="ln1715"> </a>
<a name="ln1716">	if (m) {</a>
<a name="ln1717">		m-&gt;m_pkthdr.rcvif = sc-&gt;ifp;</a>
<a name="ln1718">#if __FreeBSD_version &gt;= 800000</a>
<a name="ln1719">		if (rq-&gt;queue_index)</a>
<a name="ln1720">			m-&gt;m_pkthdr.flowid = (rq-&gt;queue_index - 1);</a>
<a name="ln1721">		else</a>
<a name="ln1722">			m-&gt;m_pkthdr.flowid = rq-&gt;queue_index;</a>
<a name="ln1723">		M_HASHTYPE_SET(m, M_HASHTYPE_OPAQUE);</a>
<a name="ln1724">#endif</a>
<a name="ln1725">		/* This deternies if vlan tag is Valid */</a>
<a name="ln1726">		if (oce_cqe_vtp_valid(sc, cqe)) {</a>
<a name="ln1727">			if (sc-&gt;function_mode &amp; FNM_FLEX10_MODE) {</a>
<a name="ln1728">				/* FLEX10. If QnQ is not set, neglect VLAN */</a>
<a name="ln1729">				if (cqe-&gt;u0.s.qnq) {</a>
<a name="ln1730">					m-&gt;m_pkthdr.ether_vtag = vtag;</a>
<a name="ln1731">					m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln1732">				}</a>
<a name="ln1733">			} else if (sc-&gt;pvid != (vtag &amp; VLAN_VID_MASK))  {</a>
<a name="ln1734">				/* In UMC mode generally pvid will be striped by</a>
<a name="ln1735">				   hw. But in some cases we have seen it comes</a>
<a name="ln1736">				   with pvid. So if pvid == vlan, neglect vlan.</a>
<a name="ln1737">				*/</a>
<a name="ln1738">				m-&gt;m_pkthdr.ether_vtag = vtag;</a>
<a name="ln1739">				m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln1740">			}</a>
<a name="ln1741">		}</a>
<a name="ln1742"> </a>
<a name="ln1743">		if_inc_counter(sc-&gt;ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln1744">#if defined(INET6) || defined(INET)</a>
<a name="ln1745">		/* Try to queue to LRO */</a>
<a name="ln1746">		if (IF_LRO_ENABLED(sc) &amp;&amp;</a>
<a name="ln1747">		    (cqe-&gt;u0.s.ip_cksum_pass) &amp;&amp;</a>
<a name="ln1748">		    (cqe-&gt;u0.s.l4_cksum_pass) &amp;&amp;</a>
<a name="ln1749">		    (!cqe-&gt;u0.s.ip_ver)       &amp;&amp;</a>
<a name="ln1750">		    (rq-&gt;lro.lro_cnt != 0)) {</a>
<a name="ln1751"> </a>
<a name="ln1752">			if (tcp_lro_rx(&amp;rq-&gt;lro, m, 0) == 0) {</a>
<a name="ln1753">				rq-&gt;lro_pkts_queued ++;</a>
<a name="ln1754">				goto post_done;</a>
<a name="ln1755">			}</a>
<a name="ln1756">			/* If LRO posting fails then try to post to STACK */</a>
<a name="ln1757">		}</a>
<a name="ln1758">#endif</a>
<a name="ln1759"> </a>
<a name="ln1760">		(*sc-&gt;ifp-&gt;if_input) (sc-&gt;ifp, m);</a>
<a name="ln1761">#if defined(INET6) || defined(INET)</a>
<a name="ln1762">post_done:</a>
<a name="ln1763">#endif</a>
<a name="ln1764">		/* Update rx stats per queue */</a>
<a name="ln1765">		rq-&gt;rx_stats.rx_pkts++;</a>
<a name="ln1766">		rq-&gt;rx_stats.rx_bytes += cqe-&gt;u0.s.pkt_size;</a>
<a name="ln1767">		rq-&gt;rx_stats.rx_frags += cqe-&gt;u0.s.num_fragments;</a>
<a name="ln1768">		if (cqe-&gt;u0.s.pkt_type == OCE_MULTICAST_PACKET)</a>
<a name="ln1769">			rq-&gt;rx_stats.rx_mcast_pkts++;</a>
<a name="ln1770">		if (cqe-&gt;u0.s.pkt_type == OCE_UNICAST_PACKET)</a>
<a name="ln1771">			rq-&gt;rx_stats.rx_ucast_pkts++;</a>
<a name="ln1772">	}</a>
<a name="ln1773">exit:</a>
<a name="ln1774">	return;</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777"> </a>
<a name="ln1778">void</a>
<a name="ln1779">oce_discard_rx_comp(struct oce_rq *rq, int num_frags)</a>
<a name="ln1780">{</a>
<a name="ln1781">	uint32_t i = 0;</a>
<a name="ln1782">	struct oce_packet_desc *pd;</a>
<a name="ln1783">	POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln1784"> </a>
<a name="ln1785">	for (i = 0; i &lt; num_frags; i++) {</a>
<a name="ln1786">                if (rq-&gt;ring-&gt;cidx == rq-&gt;ring-&gt;pidx) {</a>
<a name="ln1787">                        device_printf(sc-&gt;dev,</a>
<a name="ln1788">                                &quot;oce_discard_rx_comp: Invalid RX completion - Queue is empty\n&quot;);</a>
<a name="ln1789">                        return;</a>
<a name="ln1790">                }</a>
<a name="ln1791">                pd = &amp;rq-&gt;pckts[rq-&gt;ring-&gt;cidx];</a>
<a name="ln1792">                bus_dmamap_sync(rq-&gt;tag, pd-&gt;map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1793">                bus_dmamap_unload(rq-&gt;tag, pd-&gt;map);</a>
<a name="ln1794">                if (pd-&gt;mbuf != NULL) {</a>
<a name="ln1795">                        m_freem(pd-&gt;mbuf);</a>
<a name="ln1796">                        pd-&gt;mbuf = NULL;</a>
<a name="ln1797">                }</a>
<a name="ln1798"> </a>
<a name="ln1799">		RING_GET(rq-&gt;ring, 1);</a>
<a name="ln1800">                rq-&gt;pending--;</a>
<a name="ln1801">	}</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804"> </a>
<a name="ln1805">static int</a>
<a name="ln1806">oce_cqe_vtp_valid(POCE_SOFTC sc, struct oce_nic_rx_cqe *cqe)</a>
<a name="ln1807">{</a>
<a name="ln1808">	struct oce_nic_rx_cqe_v1 *cqe_v1;</a>
<a name="ln1809">	int vtp = 0;</a>
<a name="ln1810"> </a>
<a name="ln1811">	if (sc-&gt;be3_native) {</a>
<a name="ln1812">		cqe_v1 = (struct oce_nic_rx_cqe_v1 *)cqe;</a>
<a name="ln1813">		vtp =  cqe_v1-&gt;u0.s.vlan_tag_present;</a>
<a name="ln1814">	} else</a>
<a name="ln1815">		vtp = cqe-&gt;u0.s.vlan_tag_present;</a>
<a name="ln1816"> </a>
<a name="ln1817">	return vtp;</a>
<a name="ln1818"> </a>
<a name="ln1819">}</a>
<a name="ln1820"> </a>
<a name="ln1821"> </a>
<a name="ln1822">static int</a>
<a name="ln1823">oce_cqe_portid_valid(POCE_SOFTC sc, struct oce_nic_rx_cqe *cqe)</a>
<a name="ln1824">{</a>
<a name="ln1825">	struct oce_nic_rx_cqe_v1 *cqe_v1;</a>
<a name="ln1826">	int port_id = 0;</a>
<a name="ln1827"> </a>
<a name="ln1828">	if (sc-&gt;be3_native &amp;&amp; (IS_BE(sc) || IS_SH(sc))) {</a>
<a name="ln1829">		cqe_v1 = (struct oce_nic_rx_cqe_v1 *)cqe;</a>
<a name="ln1830">		port_id =  cqe_v1-&gt;u0.s.port;</a>
<a name="ln1831">		if (sc-&gt;port_id != port_id)</a>
<a name="ln1832">			return 0;</a>
<a name="ln1833">	} else</a>
<a name="ln1834">		;/* For BE3 legacy and Lancer this is dummy */</a>
<a name="ln1835"> </a>
<a name="ln1836">	return 1;</a>
<a name="ln1837"> </a>
<a name="ln1838">}</a>
<a name="ln1839"> </a>
<a name="ln1840">#if defined(INET6) || defined(INET)</a>
<a name="ln1841">void</a>
<a name="ln1842">oce_rx_flush_lro(struct oce_rq *rq)</a>
<a name="ln1843">{</a>
<a name="ln1844">	struct lro_ctrl	*lro = &amp;rq-&gt;lro;</a>
<a name="ln1845">	POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln1846"> </a>
<a name="ln1847">	if (!IF_LRO_ENABLED(sc))</a>
<a name="ln1848">		return;</a>
<a name="ln1849"> </a>
<a name="ln1850">	tcp_lro_flush_all(lro);</a>
<a name="ln1851">	rq-&gt;lro_pkts_queued = 0;</a>
<a name="ln1852"> </a>
<a name="ln1853">	return;</a>
<a name="ln1854">}</a>
<a name="ln1855"> </a>
<a name="ln1856"> </a>
<a name="ln1857">static int</a>
<a name="ln1858">oce_init_lro(POCE_SOFTC sc)</a>
<a name="ln1859">{</a>
<a name="ln1860">	struct lro_ctrl *lro = NULL;</a>
<a name="ln1861">	int i = 0, rc = 0;</a>
<a name="ln1862"> </a>
<a name="ln1863">	for (i = 0; i &lt; sc-&gt;nrqs; i++) {</a>
<a name="ln1864">		lro = &amp;sc-&gt;rq[i]-&gt;lro;</a>
<a name="ln1865">		rc = tcp_lro_init(lro);</a>
<a name="ln1866">		if (rc != 0) {</a>
<a name="ln1867">			device_printf(sc-&gt;dev, &quot;LRO init failed\n&quot;);</a>
<a name="ln1868">			return rc;</a>
<a name="ln1869">		}</a>
<a name="ln1870">		lro-&gt;ifp = sc-&gt;ifp;</a>
<a name="ln1871">	}</a>
<a name="ln1872"> </a>
<a name="ln1873">	return rc;</a>
<a name="ln1874">}</a>
<a name="ln1875"> </a>
<a name="ln1876"> </a>
<a name="ln1877">void</a>
<a name="ln1878">oce_free_lro(POCE_SOFTC sc)</a>
<a name="ln1879">{</a>
<a name="ln1880">	struct lro_ctrl *lro = NULL;</a>
<a name="ln1881">	int i = 0;</a>
<a name="ln1882"> </a>
<a name="ln1883">	for (i = 0; i &lt; sc-&gt;nrqs; i++) {</a>
<a name="ln1884">		lro = &amp;sc-&gt;rq[i]-&gt;lro;</a>
<a name="ln1885">		if (lro)</a>
<a name="ln1886">			tcp_lro_free(lro);</a>
<a name="ln1887">	}</a>
<a name="ln1888">}</a>
<a name="ln1889">#endif</a>
<a name="ln1890"> </a>
<a name="ln1891">int</a>
<a name="ln1892">oce_alloc_rx_bufs(struct oce_rq *rq, int count)</a>
<a name="ln1893">{</a>
<a name="ln1894">	POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln1895">	int i, in, rc;</a>
<a name="ln1896">	struct oce_packet_desc *pd;</a>
<a name="ln1897">	bus_dma_segment_t segs[6];</a>
<a name="ln1898">	int nsegs, added = 0;</a>
<a name="ln1899">	struct oce_nic_rqe *rqe;</a>
<a name="ln1900">	pd_rxulp_db_t rxdb_reg;</a>
<a name="ln1901">	uint32_t val = 0;</a>
<a name="ln1902">	uint32_t oce_max_rq_posts = 64;</a>
<a name="ln1903"> </a>
<a name="ln1904">	bzero(&amp;rxdb_reg, sizeof(pd_rxulp_db_t));</a>
<a name="ln1905">	for (i = 0; i &lt; count; i++) {</a>
<a name="ln1906">		in = (rq-&gt;ring-&gt;pidx + 1) % OCE_RQ_PACKET_ARRAY_SIZE;</a>
<a name="ln1907"> </a>
<a name="ln1908">		pd = &amp;rq-&gt;pckts[rq-&gt;ring-&gt;pidx];</a>
<a name="ln1909">		pd-&gt;mbuf = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR, oce_rq_buf_size);</a>
<a name="ln1910">		if (pd-&gt;mbuf == NULL) {</a>
<a name="ln1911">			device_printf(sc-&gt;dev, &quot;mbuf allocation failed, size = %d\n&quot;,oce_rq_buf_size);</a>
<a name="ln1912">			break;</a>
<a name="ln1913">		}</a>
<a name="ln1914">		pd-&gt;mbuf-&gt;m_nextpkt = NULL;</a>
<a name="ln1915"> </a>
<a name="ln1916">		pd-&gt;mbuf-&gt;m_len = pd-&gt;mbuf-&gt;m_pkthdr.len = rq-&gt;cfg.frag_size;</a>
<a name="ln1917"> </a>
<a name="ln1918">		rc = bus_dmamap_load_mbuf_sg(rq-&gt;tag,</a>
<a name="ln1919">					     pd-&gt;map,</a>
<a name="ln1920">					     pd-&gt;mbuf,</a>
<a name="ln1921">					     segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln1922">		if (rc) {</a>
<a name="ln1923">			m_free(pd-&gt;mbuf);</a>
<a name="ln1924">			device_printf(sc-&gt;dev, &quot;bus_dmamap_load_mbuf_sg failed rc = %d\n&quot;, rc);</a>
<a name="ln1925">			break;</a>
<a name="ln1926">		}</a>
<a name="ln1927"> </a>
<a name="ln1928">		if (nsegs != 1) {</a>
<a name="ln1929">			i--;</a>
<a name="ln1930">			continue;</a>
<a name="ln1931">		}</a>
<a name="ln1932"> </a>
<a name="ln1933">		bus_dmamap_sync(rq-&gt;tag, pd-&gt;map, BUS_DMASYNC_PREREAD);</a>
<a name="ln1934"> </a>
<a name="ln1935">		rqe = RING_GET_PRODUCER_ITEM_VA(rq-&gt;ring, struct oce_nic_rqe);</a>
<a name="ln1936">		rqe-&gt;u0.s.frag_pa_hi = ADDR_HI(segs[0].ds_addr);</a>
<a name="ln1937">		rqe-&gt;u0.s.frag_pa_lo = ADDR_LO(segs[0].ds_addr);</a>
<a name="ln1938">		DW_SWAP(u32ptr(rqe), sizeof(struct oce_nic_rqe));</a>
<a name="ln1939">		RING_PUT(rq-&gt;ring, 1);</a>
<a name="ln1940">		added++;</a>
<a name="ln1941">		rq-&gt;pending++;</a>
<a name="ln1942">	}</a>
<a name="ln1943">	oce_max_rq_posts = sc-&gt;enable_hwlro ? OCE_HWLRO_MAX_RQ_POSTS : OCE_MAX_RQ_POSTS;</a>
<a name="ln1944">	if (added != 0) {</a>
<a name="ln1945">		for (i = added / oce_max_rq_posts; i &gt; 0; i--) {</a>
<a name="ln1946">			rxdb_reg.bits.num_posted = oce_max_rq_posts;</a>
<a name="ln1947">			rxdb_reg.bits.qid = rq-&gt;rq_id;</a>
<a name="ln1948">			if(rq-&gt;islro) {</a>
<a name="ln1949">                                val |= rq-&gt;rq_id &amp; DB_LRO_RQ_ID_MASK;</a>
<a name="ln1950">                                val |= oce_max_rq_posts &lt;&lt; 16;</a>
<a name="ln1951">                                OCE_WRITE_REG32(sc, db, DB_OFFSET, val);</a>
<a name="ln1952">			}else {</a>
<a name="ln1953">				OCE_WRITE_REG32(sc, db, PD_RXULP_DB, rxdb_reg.dw0);</a>
<a name="ln1954">			}</a>
<a name="ln1955">			added -= oce_max_rq_posts;</a>
<a name="ln1956">		}</a>
<a name="ln1957">		if (added &gt; 0) {</a>
<a name="ln1958">			rxdb_reg.bits.qid = rq-&gt;rq_id;</a>
<a name="ln1959">			rxdb_reg.bits.num_posted = added;</a>
<a name="ln1960">			if(rq-&gt;islro) {</a>
<a name="ln1961">                                val |= rq-&gt;rq_id &amp; DB_LRO_RQ_ID_MASK;</a>
<a name="ln1962">                                val |= added &lt;&lt; 16;</a>
<a name="ln1963">                                OCE_WRITE_REG32(sc, db, DB_OFFSET, val);</a>
<a name="ln1964">			}else {</a>
<a name="ln1965">				OCE_WRITE_REG32(sc, db, PD_RXULP_DB, rxdb_reg.dw0);</a>
<a name="ln1966">			}</a>
<a name="ln1967">		}</a>
<a name="ln1968">	}</a>
<a name="ln1969"> </a>
<a name="ln1970">	return 0;</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">static void</a>
<a name="ln1974">oce_check_rx_bufs(POCE_SOFTC sc, uint32_t num_cqes, struct oce_rq *rq)</a>
<a name="ln1975">{</a>
<a name="ln1976">        if (num_cqes) {</a>
<a name="ln1977">                oce_arm_cq(sc, rq-&gt;cq-&gt;cq_id, num_cqes, FALSE);</a>
<a name="ln1978">		if(!sc-&gt;enable_hwlro) {</a>
<a name="ln1979">			if((OCE_RQ_PACKET_ARRAY_SIZE - rq-&gt;pending) &gt; 1)</a>
<a name="ln1980">				oce_alloc_rx_bufs(rq, ((OCE_RQ_PACKET_ARRAY_SIZE - rq-&gt;pending) - 1));</a>
<a name="ln1981">		}else {</a>
<a name="ln1982">                	if ((OCE_RQ_PACKET_ARRAY_SIZE -1 - rq-&gt;pending) &gt; 64)</a>
<a name="ln1983">                        	oce_alloc_rx_bufs(rq, 64);</a>
<a name="ln1984">        	}</a>
<a name="ln1985">	}</a>
<a name="ln1986"> </a>
<a name="ln1987">        return;</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990">uint16_t</a>
<a name="ln1991">oce_rq_handler_lro(void *arg)</a>
<a name="ln1992">{</a>
<a name="ln1993">        struct oce_rq *rq = (struct oce_rq *)arg;</a>
<a name="ln1994">        struct oce_cq *cq = rq-&gt;cq;</a>
<a name="ln1995">        POCE_SOFTC sc = rq-&gt;parent;</a>
<a name="ln1996">        struct nic_hwlro_singleton_cqe *cqe;</a>
<a name="ln1997">        struct nic_hwlro_cqe_part2 *cqe2;</a>
<a name="ln1998">        int num_cqes = 0;</a>
<a name="ln1999"> </a>
<a name="ln2000">	LOCK(&amp;rq-&gt;rx_lock);</a>
<a name="ln2001">        bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2002">        cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct nic_hwlro_singleton_cqe);</a>
<a name="ln2003">        while (cqe-&gt;valid) {</a>
<a name="ln2004">                if(cqe-&gt;cqe_type == 0) { /* singleton cqe */</a>
<a name="ln2005">			/* we should not get singleton cqe after cqe1 on same rq */</a>
<a name="ln2006">			if(rq-&gt;cqe_firstpart != NULL) {</a>
<a name="ln2007">				device_printf(sc-&gt;dev, &quot;Got singleton cqe after cqe1 \n&quot;);</a>
<a name="ln2008">				goto exit_rq_handler_lro;</a>
<a name="ln2009">			}</a>
<a name="ln2010">                        if(cqe-&gt;error != 0) {</a>
<a name="ln2011">                                rq-&gt;rx_stats.rxcp_err++;</a>
<a name="ln2012">				if_inc_counter(sc-&gt;ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln2013">                        }</a>
<a name="ln2014">                        oce_rx_lro(rq, cqe, NULL);</a>
<a name="ln2015">                        rq-&gt;rx_stats.rx_compl++;</a>
<a name="ln2016">                        cqe-&gt;valid = 0;</a>
<a name="ln2017">                        RING_GET(cq-&gt;ring, 1);</a>
<a name="ln2018">                        num_cqes++;</a>
<a name="ln2019">                        if (num_cqes &gt;= (IS_XE201(sc) ? 8 : oce_max_rsp_handled))</a>
<a name="ln2020">                                break;</a>
<a name="ln2021">                }else if(cqe-&gt;cqe_type == 0x1) { /* first part */</a>
<a name="ln2022">			/* we should not get cqe1 after cqe1 on same rq */</a>
<a name="ln2023">			if(rq-&gt;cqe_firstpart != NULL) {</a>
<a name="ln2024">				device_printf(sc-&gt;dev, &quot;Got cqe1 after cqe1 \n&quot;);</a>
<a name="ln2025">				goto exit_rq_handler_lro;</a>
<a name="ln2026">			}</a>
<a name="ln2027">			rq-&gt;cqe_firstpart = (struct nic_hwlro_cqe_part1 *)cqe;</a>
<a name="ln2028">                        RING_GET(cq-&gt;ring, 1);</a>
<a name="ln2029">                }else if(cqe-&gt;cqe_type == 0x2) { /* second part */</a>
<a name="ln2030">			cqe2 = (struct nic_hwlro_cqe_part2 *)cqe;</a>
<a name="ln2031">                        if(cqe2-&gt;error != 0) {</a>
<a name="ln2032">                                rq-&gt;rx_stats.rxcp_err++;</a>
<a name="ln2033">				if_inc_counter(sc-&gt;ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln2034">                        }</a>
<a name="ln2035">			/* We should not get cqe2 without cqe1 */</a>
<a name="ln2036">			if(rq-&gt;cqe_firstpart == NULL) {</a>
<a name="ln2037">				device_printf(sc-&gt;dev, &quot;Got cqe2 without cqe1 \n&quot;);</a>
<a name="ln2038">				goto exit_rq_handler_lro;</a>
<a name="ln2039">			}</a>
<a name="ln2040">                        oce_rx_lro(rq, (struct nic_hwlro_singleton_cqe *)rq-&gt;cqe_firstpart, cqe2);</a>
<a name="ln2041"> </a>
<a name="ln2042">                        rq-&gt;rx_stats.rx_compl++;</a>
<a name="ln2043">                        rq-&gt;cqe_firstpart-&gt;valid = 0;</a>
<a name="ln2044">                        cqe2-&gt;valid = 0;</a>
<a name="ln2045">			rq-&gt;cqe_firstpart = NULL;</a>
<a name="ln2046"> </a>
<a name="ln2047">                        RING_GET(cq-&gt;ring, 1);</a>
<a name="ln2048">                        num_cqes += 2;</a>
<a name="ln2049">                        if (num_cqes &gt;= (IS_XE201(sc) ? 8 : oce_max_rsp_handled))</a>
<a name="ln2050">                                break;</a>
<a name="ln2051">		}</a>
<a name="ln2052"> </a>
<a name="ln2053">                bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2054">                cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct nic_hwlro_singleton_cqe);</a>
<a name="ln2055">        }</a>
<a name="ln2056">	oce_check_rx_bufs(sc, num_cqes, rq);</a>
<a name="ln2057">exit_rq_handler_lro:</a>
<a name="ln2058">	UNLOCK(&amp;rq-&gt;rx_lock);</a>
<a name="ln2059">	return 0;</a>
<a name="ln2060">}</a>
<a name="ln2061"> </a>
<a name="ln2062">/* Handle the Completion Queue for receive */</a>
<a name="ln2063">uint16_t</a>
<a name="ln2064">oce_rq_handler(void *arg)</a>
<a name="ln2065">{</a>
<a name="ln2066">	struct oce_rq *rq = (struct oce_rq *)arg;</a>
<a name="ln2067">	struct oce_cq *cq = rq-&gt;cq;</a>
<a name="ln2068">	POCE_SOFTC sc = rq-&gt;parent;</a>
<a name="ln2069">	struct oce_nic_rx_cqe *cqe;</a>
<a name="ln2070">	int num_cqes = 0;</a>
<a name="ln2071"> </a>
<a name="ln2072">	if(rq-&gt;islro) {</a>
<a name="ln2073">		oce_rq_handler_lro(arg);</a>
<a name="ln2074">		return 0;</a>
<a name="ln2075">	}</a>
<a name="ln2076">	LOCK(&amp;rq-&gt;rx_lock);</a>
<a name="ln2077">	bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,</a>
<a name="ln2078">			cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2079">	cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_nic_rx_cqe);</a>
<a name="ln2080">	while (cqe-&gt;u0.dw[2]) {</a>
<a name="ln2081">		DW_SWAP((uint32_t *) cqe, sizeof(oce_rq_cqe));</a>
<a name="ln2082"> </a>
<a name="ln2083">		if (cqe-&gt;u0.s.error == 0) {</a>
<a name="ln2084">			oce_rx(rq, cqe);</a>
<a name="ln2085">		} else {</a>
<a name="ln2086">			rq-&gt;rx_stats.rxcp_err++;</a>
<a name="ln2087">			if_inc_counter(sc-&gt;ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln2088">			/* Post L3/L4 errors to stack.*/</a>
<a name="ln2089">			oce_rx(rq, cqe);</a>
<a name="ln2090">		}</a>
<a name="ln2091">		rq-&gt;rx_stats.rx_compl++;</a>
<a name="ln2092">		cqe-&gt;u0.dw[2] = 0;</a>
<a name="ln2093"> </a>
<a name="ln2094">#if defined(INET6) || defined(INET)</a>
<a name="ln2095">		if (IF_LRO_ENABLED(sc) &amp;&amp; rq-&gt;lro_pkts_queued &gt;= 16) {</a>
<a name="ln2096">			oce_rx_flush_lro(rq);</a>
<a name="ln2097">		}</a>
<a name="ln2098">#endif</a>
<a name="ln2099"> </a>
<a name="ln2100">		RING_GET(cq-&gt;ring, 1);</a>
<a name="ln2101">		bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,</a>
<a name="ln2102">				cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2103">		cqe =</a>
<a name="ln2104">		    RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_nic_rx_cqe);</a>
<a name="ln2105">		num_cqes++;</a>
<a name="ln2106">		if (num_cqes &gt;= (IS_XE201(sc) ? 8 : oce_max_rsp_handled))</a>
<a name="ln2107">			break;</a>
<a name="ln2108">	}</a>
<a name="ln2109"> </a>
<a name="ln2110">#if defined(INET6) || defined(INET)</a>
<a name="ln2111">        if (IF_LRO_ENABLED(sc))</a>
<a name="ln2112">                oce_rx_flush_lro(rq);</a>
<a name="ln2113">#endif</a>
<a name="ln2114"> </a>
<a name="ln2115">	oce_check_rx_bufs(sc, num_cqes, rq);</a>
<a name="ln2116">	UNLOCK(&amp;rq-&gt;rx_lock);</a>
<a name="ln2117">	return 0;</a>
<a name="ln2118"> </a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121"> </a>
<a name="ln2122"> </a>
<a name="ln2123"> </a>
<a name="ln2124">/*****************************************************************************</a>
<a name="ln2125"> *		   Helper function prototypes in this file 		     *</a>
<a name="ln2126"> *****************************************************************************/</a>
<a name="ln2127"> </a>
<a name="ln2128">static int</a>
<a name="ln2129">oce_attach_ifp(POCE_SOFTC sc)</a>
<a name="ln2130">{</a>
<a name="ln2131"> </a>
<a name="ln2132">	sc-&gt;ifp = if_alloc(IFT_ETHER);</a>
<a name="ln2133">	if (!sc-&gt;ifp)</a>
<a name="ln2134">		return ENOMEM;</a>
<a name="ln2135"> </a>
<a name="ln2136">	ifmedia_init(&amp;sc-&gt;media, IFM_IMASK, oce_media_change, oce_media_status);</a>
<a name="ln2137">	ifmedia_add(&amp;sc-&gt;media, IFM_ETHER | IFM_AUTO, 0, NULL);</a>
<a name="ln2138">	ifmedia_set(&amp;sc-&gt;media, IFM_ETHER | IFM_AUTO);</a>
<a name="ln2139"> </a>
<a name="ln2140">	sc-&gt;ifp-&gt;if_flags = IFF_BROADCAST | IFF_MULTICAST;</a>
<a name="ln2141">	sc-&gt;ifp-&gt;if_ioctl = oce_ioctl;</a>
<a name="ln2142">	sc-&gt;ifp-&gt;if_start = oce_start;</a>
<a name="ln2143">	sc-&gt;ifp-&gt;if_init = oce_init;</a>
<a name="ln2144">	sc-&gt;ifp-&gt;if_mtu = ETHERMTU;</a>
<a name="ln2145">	sc-&gt;ifp-&gt;if_softc = sc;</a>
<a name="ln2146">#if __FreeBSD_version &gt;= 800000</a>
<a name="ln2147">	sc-&gt;ifp-&gt;if_transmit = oce_multiq_start;</a>
<a name="ln2148">	sc-&gt;ifp-&gt;if_qflush = oce_multiq_flush;</a>
<a name="ln2149">#endif</a>
<a name="ln2150"> </a>
<a name="ln2151">	if_initname(sc-&gt;ifp,</a>
<a name="ln2152">		    device_get_name(sc-&gt;dev), device_get_unit(sc-&gt;dev));</a>
<a name="ln2153"> </a>
<a name="ln2154">	sc-&gt;ifp-&gt;if_snd.ifq_drv_maxlen = OCE_MAX_TX_DESC - 1;</a>
<a name="ln2155">	IFQ_SET_MAXLEN(&amp;sc-&gt;ifp-&gt;if_snd, sc-&gt;ifp-&gt;if_snd.ifq_drv_maxlen);</a>
<a name="ln2156">	IFQ_SET_READY(&amp;sc-&gt;ifp-&gt;if_snd);</a>
<a name="ln2157"> </a>
<a name="ln2158">	sc-&gt;ifp-&gt;if_hwassist = OCE_IF_HWASSIST;</a>
<a name="ln2159">	sc-&gt;ifp-&gt;if_hwassist |= CSUM_TSO;</a>
<a name="ln2160">	sc-&gt;ifp-&gt;if_hwassist |= (CSUM_IP | CSUM_TCP | CSUM_UDP);</a>
<a name="ln2161"> </a>
<a name="ln2162">	sc-&gt;ifp-&gt;if_capabilities = OCE_IF_CAPABILITIES;</a>
<a name="ln2163">	sc-&gt;ifp-&gt;if_capabilities |= IFCAP_HWCSUM;</a>
<a name="ln2164">	sc-&gt;ifp-&gt;if_capabilities |= IFCAP_VLAN_HWFILTER;</a>
<a name="ln2165"> </a>
<a name="ln2166">#if defined(INET6) || defined(INET)</a>
<a name="ln2167">	sc-&gt;ifp-&gt;if_capabilities |= IFCAP_TSO;</a>
<a name="ln2168">	sc-&gt;ifp-&gt;if_capabilities |= IFCAP_LRO;</a>
<a name="ln2169">	sc-&gt;ifp-&gt;if_capabilities |= IFCAP_VLAN_HWTSO;</a>
<a name="ln2170">#endif</a>
<a name="ln2171"> </a>
<a name="ln2172">	sc-&gt;ifp-&gt;if_capenable = sc-&gt;ifp-&gt;if_capabilities;</a>
<a name="ln2173">	sc-&gt;ifp-&gt;if_baudrate = IF_Gbps(10);</a>
<a name="ln2174"> </a>
<a name="ln2175">#if __FreeBSD_version &gt;= 1000000</a>
<a name="ln2176">	sc-&gt;ifp-&gt;if_hw_tsomax = 65536 - (ETHER_HDR_LEN + ETHER_VLAN_ENCAP_LEN);</a>
<a name="ln2177">	sc-&gt;ifp-&gt;if_hw_tsomaxsegcount = OCE_MAX_TX_ELEMENTS;</a>
<a name="ln2178">	sc-&gt;ifp-&gt;if_hw_tsomaxsegsize = 4096;</a>
<a name="ln2179">#endif</a>
<a name="ln2180"> </a>
<a name="ln2181">	ether_ifattach(sc-&gt;ifp, sc-&gt;macaddr.mac_addr);</a>
<a name="ln2182"> </a>
<a name="ln2183">	return 0;</a>
<a name="ln2184">}</a>
<a name="ln2185"> </a>
<a name="ln2186"> </a>
<a name="ln2187">static void</a>
<a name="ln2188">oce_add_vlan(void *arg, struct ifnet *ifp, uint16_t vtag)</a>
<a name="ln2189">{</a>
<a name="ln2190">	POCE_SOFTC sc = ifp-&gt;if_softc;</a>
<a name="ln2191"> </a>
<a name="ln2192">	if (ifp-&gt;if_softc !=  arg)</a>
<a name="ln2193">		return;</a>
<a name="ln2194">	if ((vtag == 0) || (vtag &gt; 4095))</a>
<a name="ln2195">		return;</a>
<a name="ln2196"> </a>
<a name="ln2197">	sc-&gt;vlan_tag[vtag] = 1;</a>
<a name="ln2198">	sc-&gt;vlans_added++;</a>
<a name="ln2199">	if (sc-&gt;vlans_added &lt;= (sc-&gt;max_vlans + 1))</a>
<a name="ln2200">		oce_vid_config(sc);</a>
<a name="ln2201">}</a>
<a name="ln2202"> </a>
<a name="ln2203"> </a>
<a name="ln2204">static void</a>
<a name="ln2205">oce_del_vlan(void *arg, struct ifnet *ifp, uint16_t vtag)</a>
<a name="ln2206">{</a>
<a name="ln2207">	POCE_SOFTC sc = ifp-&gt;if_softc;</a>
<a name="ln2208"> </a>
<a name="ln2209">	if (ifp-&gt;if_softc !=  arg)</a>
<a name="ln2210">		return;</a>
<a name="ln2211">	if ((vtag == 0) || (vtag &gt; 4095))</a>
<a name="ln2212">		return;</a>
<a name="ln2213"> </a>
<a name="ln2214">	sc-&gt;vlan_tag[vtag] = 0;</a>
<a name="ln2215">	sc-&gt;vlans_added--;</a>
<a name="ln2216">	oce_vid_config(sc);</a>
<a name="ln2217">}</a>
<a name="ln2218"> </a>
<a name="ln2219"> </a>
<a name="ln2220">/*</a>
<a name="ln2221"> * A max of 64 vlans can be configured in BE. If the user configures</a>
<a name="ln2222"> * more, place the card in vlan promiscuous mode.</a>
<a name="ln2223"> */</a>
<a name="ln2224">static int</a>
<a name="ln2225">oce_vid_config(POCE_SOFTC sc)</a>
<a name="ln2226">{</a>
<a name="ln2227">	struct normal_vlan vtags[MAX_VLANFILTER_SIZE];</a>
<a name="ln2228">	uint16_t ntags = 0, i;</a>
<a name="ln2229">	int status = 0;</a>
<a name="ln2230"> </a>
<a name="ln2231">	if ((sc-&gt;vlans_added &lt;= MAX_VLANFILTER_SIZE) &amp;&amp;</a>
<a name="ln2232">			(sc-&gt;ifp-&gt;if_capenable &amp; IFCAP_VLAN_HWFILTER)) {</a>
<a name="ln2233">		for (i = 0; i &lt; MAX_VLANS; i++) {</a>
<a name="ln2234">			if (sc-&gt;vlan_tag[i]) {</a>
<a name="ln2235">				vtags[ntags].vtag = i;</a>
<a name="ln2236">				ntags++;</a>
<a name="ln2237">			}</a>
<a name="ln2238">		}</a>
<a name="ln2239">		if (ntags)</a>
<a name="ln2240">			status = oce_config_vlan(sc, (uint8_t) sc-&gt;if_id,</a>
<a name="ln2241">						vtags, ntags, 1, 0);</a>
<a name="ln2242">	} else</a>
<a name="ln2243">		status = oce_config_vlan(sc, (uint8_t) sc-&gt;if_id,</a>
<a name="ln2244">					 	NULL, 0, 1, 1);</a>
<a name="ln2245">	return status;</a>
<a name="ln2246">}</a>
<a name="ln2247"> </a>
<a name="ln2248"> </a>
<a name="ln2249">static void</a>
<a name="ln2250">oce_mac_addr_set(POCE_SOFTC sc)</a>
<a name="ln2251">{</a>
<a name="ln2252">	uint32_t old_pmac_id = sc-&gt;pmac_id;</a>
<a name="ln2253">	int status = 0;</a>
<a name="ln2254"> </a>
<a name="ln2255"> </a>
<a name="ln2256">	status = bcmp((IF_LLADDR(sc-&gt;ifp)), sc-&gt;macaddr.mac_addr,</a>
<a name="ln2257">			 sc-&gt;macaddr.size_of_struct);</a>
<a name="ln2258">	if (!status)</a>
<a name="ln2259">		return;</a>
<a name="ln2260"> </a>
<a name="ln2261">	status = oce_mbox_macaddr_add(sc, (uint8_t *)(IF_LLADDR(sc-&gt;ifp)),</a>
<a name="ln2262">					sc-&gt;if_id, &amp;sc-&gt;pmac_id);</a>
<a name="ln2263">	if (!status) {</a>
<a name="ln2264">		status = oce_mbox_macaddr_del(sc, sc-&gt;if_id, old_pmac_id);</a>
<a name="ln2265">		bcopy((IF_LLADDR(sc-&gt;ifp)), sc-&gt;macaddr.mac_addr,</a>
<a name="ln2266">				 sc-&gt;macaddr.size_of_struct);</a>
<a name="ln2267">	}</a>
<a name="ln2268">	if (status)</a>
<a name="ln2269">		device_printf(sc-&gt;dev, &quot;Failed update macaddress\n&quot;);</a>
<a name="ln2270"> </a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273"> </a>
<a name="ln2274">static int</a>
<a name="ln2275">oce_handle_passthrough(struct ifnet *ifp, caddr_t data)</a>
<a name="ln2276">{</a>
<a name="ln2277">	POCE_SOFTC sc = ifp-&gt;if_softc;</a>
<a name="ln2278">	struct ifreq *ifr = (struct ifreq *)data;</a>
<a name="ln2279">	int rc = ENXIO;</a>
<a name="ln2280">#ifndef __HAIKU__ /* TODO: ifr_data_get_ptr */</a>
<a name="ln2281">	char cookie[32] = {0};</a>
<a name="ln2282">	void *priv_data = ifr_data_get_ptr(ifr);</a>
<a name="ln2283">	void *ioctl_ptr;</a>
<a name="ln2284">	uint32_t req_size;</a>
<a name="ln2285">	struct mbx_hdr req;</a>
<a name="ln2286">	OCE_DMA_MEM dma_mem;</a>
<a name="ln2287">	struct mbx_common_get_cntl_attr *fw_cmd;</a>
<a name="ln2288"> </a>
<a name="ln2289">	if (copyin(priv_data, cookie, strlen(IOCTL_COOKIE)))</a>
<a name="ln2290">		return EFAULT;</a>
<a name="ln2291"> </a>
<a name="ln2292">	if (memcmp(cookie, IOCTL_COOKIE, strlen(IOCTL_COOKIE)))</a>
<a name="ln2293">		return EINVAL;</a>
<a name="ln2294"> </a>
<a name="ln2295">	ioctl_ptr = (char *)priv_data + strlen(IOCTL_COOKIE);</a>
<a name="ln2296">	if (copyin(ioctl_ptr, &amp;req, sizeof(struct mbx_hdr)))</a>
<a name="ln2297">		return EFAULT;</a>
<a name="ln2298"> </a>
<a name="ln2299">	req_size = le32toh(req.u0.req.request_length);</a>
<a name="ln2300">	if (req_size &gt; 65536)</a>
<a name="ln2301">		return EINVAL;</a>
<a name="ln2302"> </a>
<a name="ln2303">	req_size += sizeof(struct mbx_hdr);</a>
<a name="ln2304">	rc = oce_dma_alloc(sc, req_size, &amp;dma_mem, 0);</a>
<a name="ln2305">	if (rc)</a>
<a name="ln2306">		return ENOMEM;</a>
<a name="ln2307"> </a>
<a name="ln2308">	if (copyin(ioctl_ptr, OCE_DMAPTR(&amp;dma_mem,char), req_size)) {</a>
<a name="ln2309">		rc = EFAULT;</a>
<a name="ln2310">		goto dma_free;</a>
<a name="ln2311">	}</a>
<a name="ln2312"> </a>
<a name="ln2313">	rc = oce_pass_through_mbox(sc, &amp;dma_mem, req_size);</a>
<a name="ln2314">	if (rc) {</a>
<a name="ln2315">		rc = EIO;</a>
<a name="ln2316">		goto dma_free;</a>
<a name="ln2317">	}</a>
<a name="ln2318"> </a>
<a name="ln2319">	if (copyout(OCE_DMAPTR(&amp;dma_mem,char), ioctl_ptr, req_size))</a>
<a name="ln2320">		rc =  EFAULT;</a>
<a name="ln2321"> </a>
<a name="ln2322">	/*</a>
<a name="ln2323">	   firmware is filling all the attributes for this ioctl except</a>
<a name="ln2324">	   the driver version..so fill it</a>
<a name="ln2325">	 */</a>
<a name="ln2326">	if(req.u0.rsp.opcode == OPCODE_COMMON_GET_CNTL_ATTRIBUTES) {</a>
<a name="ln2327">		fw_cmd = (struct mbx_common_get_cntl_attr *) ioctl_ptr;</a>
<a name="ln2328">		strncpy(fw_cmd-&gt;params.rsp.cntl_attr_info.hba_attr.drv_ver_str,</a>
<a name="ln2329">			COMPONENT_REVISION, strlen(COMPONENT_REVISION));</a>
<a name="ln2330">	}</a>
<a name="ln2331"> </a>
<a name="ln2332">dma_free:</a>
<a name="ln2333">	oce_dma_free(sc, &amp;dma_mem);</a>
<a name="ln2334">#endif</a>
<a name="ln2335">	return rc;</a>
<a name="ln2336"> </a>
<a name="ln2337">}</a>
<a name="ln2338"> </a>
<a name="ln2339">static void</a>
<a name="ln2340">oce_eqd_set_periodic(POCE_SOFTC sc)</a>
<a name="ln2341">{</a>
<a name="ln2342">	struct oce_set_eqd set_eqd[OCE_MAX_EQ];</a>
<a name="ln2343">	struct oce_aic_obj *aic;</a>
<a name="ln2344">	struct oce_eq *eqo;</a>
<a name="ln2345">	uint64_t now = 0, delta;</a>
<a name="ln2346">	int eqd, i, num = 0;</a>
<a name="ln2347">	uint32_t tx_reqs = 0, rxpkts = 0, pps;</a>
<a name="ln2348">	struct oce_wq *wq;</a>
<a name="ln2349">	struct oce_rq *rq;</a>
<a name="ln2350"> </a>
<a name="ln2351">	#define ticks_to_msecs(t)       (1000 * (t) / hz)</a>
<a name="ln2352"> </a>
<a name="ln2353">	for (i = 0 ; i &lt; sc-&gt;neqs; i++) {</a>
<a name="ln2354">		eqo = sc-&gt;eq[i];</a>
<a name="ln2355">		aic = &amp;sc-&gt;aic_obj[i];</a>
<a name="ln2356">		/* When setting the static eq delay from the user space */</a>
<a name="ln2357">		if (!aic-&gt;enable) {</a>
<a name="ln2358">			if (aic-&gt;_ticks)</a>
<a name="ln2359">				aic-&gt;_ticks = 0;</a>
<a name="ln2360">			eqd = aic-&gt;et_eqd;</a>
<a name="ln2361">			goto modify_eqd;</a>
<a name="ln2362">		}</a>
<a name="ln2363"> </a>
<a name="ln2364">		rq = sc-&gt;rq[i];</a>
<a name="ln2365">		rxpkts = rq-&gt;rx_stats.rx_pkts;</a>
<a name="ln2366">		wq = sc-&gt;wq[i];</a>
<a name="ln2367">		tx_reqs = wq-&gt;tx_stats.tx_reqs;</a>
<a name="ln2368">		now = ticks;</a>
<a name="ln2369"> </a>
<a name="ln2370">		if (!aic-&gt;_ticks || now &lt; aic-&gt;_ticks ||</a>
<a name="ln2371">		    rxpkts &lt; aic-&gt;prev_rxpkts || tx_reqs &lt; aic-&gt;prev_txreqs) {</a>
<a name="ln2372">			aic-&gt;prev_rxpkts = rxpkts;</a>
<a name="ln2373">			aic-&gt;prev_txreqs = tx_reqs;</a>
<a name="ln2374">			aic-&gt;_ticks = now;</a>
<a name="ln2375">			continue;</a>
<a name="ln2376">		}</a>
<a name="ln2377"> </a>
<a name="ln2378">		delta = ticks_to_msecs(now - aic-&gt;_ticks);</a>
<a name="ln2379"> </a>
<a name="ln2380">		pps = (((uint32_t)(rxpkts - aic-&gt;prev_rxpkts) * 1000) / delta) +</a>
<a name="ln2381">		      (((uint32_t)(tx_reqs - aic-&gt;prev_txreqs) * 1000) / delta);</a>
<a name="ln2382">		eqd = (pps / 15000) &lt;&lt; 2;</a>
<a name="ln2383">		if (eqd &lt; 8)</a>
<a name="ln2384">			eqd = 0;</a>
<a name="ln2385"> </a>
<a name="ln2386">		/* Make sure that the eq delay is in the known range */</a>
<a name="ln2387">		eqd = min(eqd, aic-&gt;max_eqd);</a>
<a name="ln2388">		eqd = max(eqd, aic-&gt;min_eqd);</a>
<a name="ln2389"> </a>
<a name="ln2390">		aic-&gt;prev_rxpkts = rxpkts;</a>
<a name="ln2391">		aic-&gt;prev_txreqs = tx_reqs;</a>
<a name="ln2392">		aic-&gt;_ticks = now;</a>
<a name="ln2393"> </a>
<a name="ln2394">modify_eqd:</a>
<a name="ln2395">		if (eqd != aic-&gt;cur_eqd) {</a>
<a name="ln2396">			set_eqd[num].delay_multiplier = (eqd * 65)/100;</a>
<a name="ln2397">			set_eqd[num].eq_id = eqo-&gt;eq_id;</a>
<a name="ln2398">			aic-&gt;cur_eqd = eqd;</a>
<a name="ln2399">			num++;</a>
<a name="ln2400">		}</a>
<a name="ln2401">	}</a>
<a name="ln2402"> </a>
<a name="ln2403">	/* Is there atleast one eq that needs to be modified? */</a>
<a name="ln2404">        for(i = 0; i &lt; num; i += 8) {</a>
<a name="ln2405">                if((num - i) &gt;=8 )</a>
<a name="ln2406">                        oce_mbox_eqd_modify_periodic(sc, &amp;set_eqd[i], 8);</a>
<a name="ln2407">                else</a>
<a name="ln2408">                        oce_mbox_eqd_modify_periodic(sc, &amp;set_eqd[i], (num - i));</a>
<a name="ln2409">        }</a>
<a name="ln2410"> </a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413">static void oce_detect_hw_error(POCE_SOFTC sc)</a>
<a name="ln2414">{</a>
<a name="ln2415"> </a>
<a name="ln2416">	uint32_t ue_low = 0, ue_high = 0, ue_low_mask = 0, ue_high_mask = 0;</a>
<a name="ln2417">	uint32_t sliport_status = 0, sliport_err1 = 0, sliport_err2 = 0;</a>
<a name="ln2418">	uint32_t i;</a>
<a name="ln2419"> </a>
<a name="ln2420">	if (sc-&gt;hw_error)</a>
<a name="ln2421">		return;</a>
<a name="ln2422"> </a>
<a name="ln2423">	if (IS_XE201(sc)) {</a>
<a name="ln2424">		sliport_status = OCE_READ_REG32(sc, db, SLIPORT_STATUS_OFFSET);</a>
<a name="ln2425">		if (sliport_status &amp; SLIPORT_STATUS_ERR_MASK) {</a>
<a name="ln2426">			sliport_err1 = OCE_READ_REG32(sc, db, SLIPORT_ERROR1_OFFSET);</a>
<a name="ln2427">			sliport_err2 = OCE_READ_REG32(sc, db, SLIPORT_ERROR2_OFFSET);</a>
<a name="ln2428">		}</a>
<a name="ln2429">	} else {</a>
<a name="ln2430">		ue_low = OCE_READ_REG32(sc, devcfg, PCICFG_UE_STATUS_LOW);</a>
<a name="ln2431">		ue_high = OCE_READ_REG32(sc, devcfg, PCICFG_UE_STATUS_HIGH);</a>
<a name="ln2432">		ue_low_mask = OCE_READ_REG32(sc, devcfg, PCICFG_UE_STATUS_LOW_MASK);</a>
<a name="ln2433">		ue_high_mask = OCE_READ_REG32(sc, devcfg, PCICFG_UE_STATUS_HI_MASK);</a>
<a name="ln2434"> </a>
<a name="ln2435">		ue_low = (ue_low &amp; ~ue_low_mask);</a>
<a name="ln2436">		ue_high = (ue_high &amp; ~ue_high_mask);</a>
<a name="ln2437">	}</a>
<a name="ln2438"> </a>
<a name="ln2439">	/* On certain platforms BE hardware can indicate spurious UEs.</a>
<a name="ln2440">	 * Allow the h/w to stop working completely in case of a real UE.</a>
<a name="ln2441">	 * Hence not setting the hw_error for UE detection.</a>
<a name="ln2442">	 */</a>
<a name="ln2443">	if (sliport_status &amp; SLIPORT_STATUS_ERR_MASK) {</a>
<a name="ln2444">		sc-&gt;hw_error = TRUE;</a>
<a name="ln2445">		device_printf(sc-&gt;dev, &quot;Error detected in the card\n&quot;);</a>
<a name="ln2446">	}</a>
<a name="ln2447"> </a>
<a name="ln2448">	if (sliport_status &amp; SLIPORT_STATUS_ERR_MASK) {</a>
<a name="ln2449">		device_printf(sc-&gt;dev,</a>
<a name="ln2450">				&quot;ERR: sliport status 0x%x\n&quot;, sliport_status);</a>
<a name="ln2451">		device_printf(sc-&gt;dev,</a>
<a name="ln2452">				&quot;ERR: sliport error1 0x%x\n&quot;, sliport_err1);</a>
<a name="ln2453">		device_printf(sc-&gt;dev,</a>
<a name="ln2454">				&quot;ERR: sliport error2 0x%x\n&quot;, sliport_err2);</a>
<a name="ln2455">	}</a>
<a name="ln2456"> </a>
<a name="ln2457">	if (ue_low) {</a>
<a name="ln2458">		for (i = 0; ue_low; ue_low &gt;&gt;= 1, i++) {</a>
<a name="ln2459">			if (ue_low &amp; 1)</a>
<a name="ln2460">				device_printf(sc-&gt;dev, &quot;UE: %s bit set\n&quot;,</a>
<a name="ln2461">							ue_status_low_desc[i]);</a>
<a name="ln2462">		}</a>
<a name="ln2463">	}</a>
<a name="ln2464"> </a>
<a name="ln2465">	if (ue_high) {</a>
<a name="ln2466">		for (i = 0; ue_high; ue_high &gt;&gt;= 1, i++) {</a>
<a name="ln2467">			if (ue_high &amp; 1)</a>
<a name="ln2468">				device_printf(sc-&gt;dev, &quot;UE: %s bit set\n&quot;,</a>
<a name="ln2469">							ue_status_hi_desc[i]);</a>
<a name="ln2470">		}</a>
<a name="ln2471">	}</a>
<a name="ln2472"> </a>
<a name="ln2473">}</a>
<a name="ln2474"> </a>
<a name="ln2475"> </a>
<a name="ln2476">static void</a>
<a name="ln2477">oce_local_timer(void *arg)</a>
<a name="ln2478">{</a>
<a name="ln2479">	POCE_SOFTC sc = arg;</a>
<a name="ln2480">	int i = 0;</a>
<a name="ln2481"> </a>
<a name="ln2482">	oce_detect_hw_error(sc);</a>
<a name="ln2483">	oce_refresh_nic_stats(sc);</a>
<a name="ln2484">	oce_refresh_queue_stats(sc);</a>
<a name="ln2485">	oce_mac_addr_set(sc);</a>
<a name="ln2486"> </a>
<a name="ln2487">	/* TX Watch Dog*/</a>
<a name="ln2488">	for (i = 0; i &lt; sc-&gt;nwqs; i++)</a>
<a name="ln2489">		oce_tx_restart(sc, sc-&gt;wq[i]);</a>
<a name="ln2490"> </a>
<a name="ln2491">	/* calculate and set the eq delay for optimal interrupt rate */</a>
<a name="ln2492">	if (IS_BE(sc) || IS_SH(sc))</a>
<a name="ln2493">		oce_eqd_set_periodic(sc);</a>
<a name="ln2494"> </a>
<a name="ln2495">	callout_reset(&amp;sc-&gt;timer, hz, oce_local_timer, sc);</a>
<a name="ln2496">}</a>
<a name="ln2497"> </a>
<a name="ln2498">static void</a>
<a name="ln2499">oce_tx_compl_clean(POCE_SOFTC sc)</a>
<a name="ln2500">{</a>
<a name="ln2501">	struct oce_wq *wq;</a>
<a name="ln2502">	int i = 0, timeo = 0, num_wqes = 0;</a>
<a name="ln2503">	int pending_txqs = sc-&gt;nwqs;</a>
<a name="ln2504"> </a>
<a name="ln2505">	/* Stop polling for compls when HW has been silent for 10ms or</a>
<a name="ln2506">	 * hw_error or no outstanding completions expected</a>
<a name="ln2507">	 */</a>
<a name="ln2508">	do {</a>
<a name="ln2509">		pending_txqs = sc-&gt;nwqs;</a>
<a name="ln2510"> </a>
<a name="ln2511">		for_all_wq_queues(sc, wq, i) {</a>
<a name="ln2512">			num_wqes = oce_wq_handler(wq);</a>
<a name="ln2513"> </a>
<a name="ln2514">			if(num_wqes)</a>
<a name="ln2515">				timeo = 0;</a>
<a name="ln2516"> </a>
<a name="ln2517">			if(!wq-&gt;ring-&gt;num_used)</a>
<a name="ln2518">				pending_txqs--;</a>
<a name="ln2519">		}</a>
<a name="ln2520"> </a>
<a name="ln2521">		if (pending_txqs == 0 || ++timeo &gt; 10 || sc-&gt;hw_error)</a>
<a name="ln2522">			break;</a>
<a name="ln2523"> </a>
<a name="ln2524">		DELAY(1000);</a>
<a name="ln2525">	} while (TRUE);</a>
<a name="ln2526"> </a>
<a name="ln2527">	for_all_wq_queues(sc, wq, i) {</a>
<a name="ln2528">		while(wq-&gt;ring-&gt;num_used) {</a>
<a name="ln2529">			LOCK(&amp;wq-&gt;tx_compl_lock);</a>
<a name="ln2530">			oce_process_tx_completion(wq);</a>
<a name="ln2531">			UNLOCK(&amp;wq-&gt;tx_compl_lock);</a>
<a name="ln2532">		}</a>
<a name="ln2533">	}</a>
<a name="ln2534"> </a>
<a name="ln2535">}</a>
<a name="ln2536"> </a>
<a name="ln2537">/* NOTE : This should only be called holding</a>
<a name="ln2538"> *        DEVICE_LOCK.</a>
<a name="ln2539"> */</a>
<a name="ln2540">static void</a>
<a name="ln2541">oce_if_deactivate(POCE_SOFTC sc)</a>
<a name="ln2542">{</a>
<a name="ln2543">	int i;</a>
<a name="ln2544">	struct oce_rq *rq;</a>
<a name="ln2545">	struct oce_wq *wq;</a>
<a name="ln2546">	struct oce_eq *eq;</a>
<a name="ln2547"> </a>
<a name="ln2548">	sc-&gt;ifp-&gt;if_drv_flags &amp;= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);</a>
<a name="ln2549"> </a>
<a name="ln2550">	oce_tx_compl_clean(sc);</a>
<a name="ln2551"> </a>
<a name="ln2552">	/* Stop intrs and finish any bottom halves pending */</a>
<a name="ln2553">	oce_hw_intr_disable(sc);</a>
<a name="ln2554"> </a>
<a name="ln2555">	/* Since taskqueue_drain takes a Gaint Lock, We should not acquire</a>
<a name="ln2556">	   any other lock. So unlock device lock and require after</a>
<a name="ln2557">	   completing taskqueue_drain.</a>
<a name="ln2558">	*/</a>
<a name="ln2559">	UNLOCK(&amp;sc-&gt;dev_lock);</a>
<a name="ln2560">	for (i = 0; i &lt; sc-&gt;intr_count; i++) {</a>
<a name="ln2561">		if (sc-&gt;intrs[i].tq != NULL) {</a>
<a name="ln2562">			taskqueue_drain(sc-&gt;intrs[i].tq, &amp;sc-&gt;intrs[i].task);</a>
<a name="ln2563">		}</a>
<a name="ln2564">	}</a>
<a name="ln2565">	LOCK(&amp;sc-&gt;dev_lock);</a>
<a name="ln2566"> </a>
<a name="ln2567">	/* Delete RX queue in card with flush param */</a>
<a name="ln2568">	oce_stop_rx(sc);</a>
<a name="ln2569"> </a>
<a name="ln2570">	/* Invalidate any pending cq and eq entries*/</a>
<a name="ln2571">	for_all_evnt_queues(sc, eq, i)</a>
<a name="ln2572">		oce_drain_eq(eq);</a>
<a name="ln2573">	for_all_rq_queues(sc, rq, i)</a>
<a name="ln2574">		oce_drain_rq_cq(rq);</a>
<a name="ln2575">	for_all_wq_queues(sc, wq, i)</a>
<a name="ln2576">		oce_drain_wq_cq(wq);</a>
<a name="ln2577"> </a>
<a name="ln2578">	/* But still we need to get MCC aync events.</a>
<a name="ln2579">	   So enable intrs and also arm first EQ</a>
<a name="ln2580">	*/</a>
<a name="ln2581">	oce_hw_intr_enable(sc);</a>
<a name="ln2582">	oce_arm_eq(sc, sc-&gt;eq[0]-&gt;eq_id, 0, TRUE, FALSE);</a>
<a name="ln2583"> </a>
<a name="ln2584">	DELAY(10);</a>
<a name="ln2585">}</a>
<a name="ln2586"> </a>
<a name="ln2587"> </a>
<a name="ln2588">static void</a>
<a name="ln2589">oce_if_activate(POCE_SOFTC sc)</a>
<a name="ln2590">{</a>
<a name="ln2591">	struct oce_eq *eq;</a>
<a name="ln2592">	struct oce_rq *rq;</a>
<a name="ln2593">	struct oce_wq *wq;</a>
<a name="ln2594">	int i, rc = 0;</a>
<a name="ln2595"> </a>
<a name="ln2596">	sc-&gt;ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</a>
<a name="ln2597"> </a>
<a name="ln2598">	oce_hw_intr_disable(sc);</a>
<a name="ln2599"> </a>
<a name="ln2600">	oce_start_rx(sc);</a>
<a name="ln2601"> </a>
<a name="ln2602">	for_all_rq_queues(sc, rq, i) {</a>
<a name="ln2603">		rc = oce_start_rq(rq);</a>
<a name="ln2604">		if (rc)</a>
<a name="ln2605">			device_printf(sc-&gt;dev, &quot;Unable to start RX\n&quot;);</a>
<a name="ln2606">	}</a>
<a name="ln2607"> </a>
<a name="ln2608">	for_all_wq_queues(sc, wq, i) {</a>
<a name="ln2609">		rc = oce_start_wq(wq);</a>
<a name="ln2610">		if (rc)</a>
<a name="ln2611">			device_printf(sc-&gt;dev, &quot;Unable to start TX\n&quot;);</a>
<a name="ln2612">	}</a>
<a name="ln2613"> </a>
<a name="ln2614"> </a>
<a name="ln2615">	for_all_evnt_queues(sc, eq, i)</a>
<a name="ln2616">		oce_arm_eq(sc, eq-&gt;eq_id, 0, TRUE, FALSE);</a>
<a name="ln2617"> </a>
<a name="ln2618">	oce_hw_intr_enable(sc);</a>
<a name="ln2619"> </a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622">static void</a>
<a name="ln2623">process_link_state(POCE_SOFTC sc, struct oce_async_cqe_link_state *acqe)</a>
<a name="ln2624">{</a>
<a name="ln2625">	/* Update Link status */</a>
<a name="ln2626">	if ((acqe-&gt;u0.s.link_status &amp; ~ASYNC_EVENT_LOGICAL) ==</a>
<a name="ln2627">	     ASYNC_EVENT_LINK_UP) {</a>
<a name="ln2628">		sc-&gt;link_status = ASYNC_EVENT_LINK_UP;</a>
<a name="ln2629">		if_link_state_change(sc-&gt;ifp, LINK_STATE_UP);</a>
<a name="ln2630">	} else {</a>
<a name="ln2631">		sc-&gt;link_status = ASYNC_EVENT_LINK_DOWN;</a>
<a name="ln2632">		if_link_state_change(sc-&gt;ifp, LINK_STATE_DOWN);</a>
<a name="ln2633">	}</a>
<a name="ln2634">}</a>
<a name="ln2635"> </a>
<a name="ln2636"> </a>
<a name="ln2637">static void oce_async_grp5_osbmc_process(POCE_SOFTC sc,</a>
<a name="ln2638">					 struct oce_async_evt_grp5_os2bmc *evt)</a>
<a name="ln2639">{</a>
<a name="ln2640">	DW_SWAP(evt, sizeof(struct oce_async_evt_grp5_os2bmc));</a>
<a name="ln2641">	if (evt-&gt;u.s.mgmt_enable)</a>
<a name="ln2642">		sc-&gt;flags |= OCE_FLAGS_OS2BMC;</a>
<a name="ln2643">	else</a>
<a name="ln2644">		return;</a>
<a name="ln2645"> </a>
<a name="ln2646">	sc-&gt;bmc_filt_mask = evt-&gt;u.s.arp_filter;</a>
<a name="ln2647">	sc-&gt;bmc_filt_mask |= (evt-&gt;u.s.dhcp_client_filt &lt;&lt; 1);</a>
<a name="ln2648">	sc-&gt;bmc_filt_mask |= (evt-&gt;u.s.dhcp_server_filt &lt;&lt; 2);</a>
<a name="ln2649">	sc-&gt;bmc_filt_mask |= (evt-&gt;u.s.net_bios_filt &lt;&lt; 3);</a>
<a name="ln2650">	sc-&gt;bmc_filt_mask |= (evt-&gt;u.s.bcast_filt &lt;&lt; 4);</a>
<a name="ln2651">	sc-&gt;bmc_filt_mask |= (evt-&gt;u.s.ipv6_nbr_filt &lt;&lt; 5);</a>
<a name="ln2652">	sc-&gt;bmc_filt_mask |= (evt-&gt;u.s.ipv6_ra_filt &lt;&lt; 6);</a>
<a name="ln2653">	sc-&gt;bmc_filt_mask |= (evt-&gt;u.s.ipv6_ras_filt &lt;&lt; 7);</a>
<a name="ln2654">	sc-&gt;bmc_filt_mask |= (evt-&gt;u.s.mcast_filt &lt;&lt; 8);</a>
<a name="ln2655">}</a>
<a name="ln2656"> </a>
<a name="ln2657"> </a>
<a name="ln2658">static void oce_process_grp5_events(POCE_SOFTC sc, struct oce_mq_cqe *cqe)</a>
<a name="ln2659">{</a>
<a name="ln2660">	struct oce_async_event_grp5_pvid_state *gcqe;</a>
<a name="ln2661">	struct oce_async_evt_grp5_os2bmc *bmccqe;</a>
<a name="ln2662"> </a>
<a name="ln2663">	switch (cqe-&gt;u0.s.async_type) {</a>
<a name="ln2664">	case ASYNC_EVENT_PVID_STATE:</a>
<a name="ln2665">		/* GRP5 PVID */</a>
<a name="ln2666">		gcqe = (struct oce_async_event_grp5_pvid_state *)cqe;</a>
<a name="ln2667">		if (gcqe-&gt;enabled)</a>
<a name="ln2668">			sc-&gt;pvid = gcqe-&gt;tag &amp; VLAN_VID_MASK;</a>
<a name="ln2669">		else</a>
<a name="ln2670">			sc-&gt;pvid = 0;</a>
<a name="ln2671">		break;</a>
<a name="ln2672">	case ASYNC_EVENT_OS2BMC:</a>
<a name="ln2673">		bmccqe = (struct oce_async_evt_grp5_os2bmc *)cqe;</a>
<a name="ln2674">		oce_async_grp5_osbmc_process(sc, bmccqe);</a>
<a name="ln2675">		break;</a>
<a name="ln2676">	default:</a>
<a name="ln2677">		break;</a>
<a name="ln2678">	}</a>
<a name="ln2679">}</a>
<a name="ln2680"> </a>
<a name="ln2681">/* Handle the Completion Queue for the Mailbox/Async notifications */</a>
<a name="ln2682">uint16_t</a>
<a name="ln2683">oce_mq_handler(void *arg)</a>
<a name="ln2684">{</a>
<a name="ln2685">	struct oce_mq *mq = (struct oce_mq *)arg;</a>
<a name="ln2686">	POCE_SOFTC sc = mq-&gt;parent;</a>
<a name="ln2687">	struct oce_cq *cq = mq-&gt;cq;</a>
<a name="ln2688">	int num_cqes = 0, evt_type = 0, optype = 0;</a>
<a name="ln2689">	struct oce_mq_cqe *cqe;</a>
<a name="ln2690">	struct oce_async_cqe_link_state *acqe;</a>
<a name="ln2691">	struct oce_async_event_qnq *dbgcqe;</a>
<a name="ln2692"> </a>
<a name="ln2693"> </a>
<a name="ln2694">	bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,</a>
<a name="ln2695">			cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2696">	cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_mq_cqe);</a>
<a name="ln2697"> </a>
<a name="ln2698">	while (cqe-&gt;u0.dw[3]) {</a>
<a name="ln2699">		DW_SWAP((uint32_t *) cqe, sizeof(oce_mq_cqe));</a>
<a name="ln2700">		if (cqe-&gt;u0.s.async_event) {</a>
<a name="ln2701">			evt_type = cqe-&gt;u0.s.event_type;</a>
<a name="ln2702">			optype = cqe-&gt;u0.s.async_type;</a>
<a name="ln2703">			if (evt_type  == ASYNC_EVENT_CODE_LINK_STATE) {</a>
<a name="ln2704">				/* Link status evt */</a>
<a name="ln2705">				acqe = (struct oce_async_cqe_link_state *)cqe;</a>
<a name="ln2706">				process_link_state(sc, acqe);</a>
<a name="ln2707">			} else if (evt_type == ASYNC_EVENT_GRP5) {</a>
<a name="ln2708">				oce_process_grp5_events(sc, cqe);</a>
<a name="ln2709">			} else if (evt_type == ASYNC_EVENT_CODE_DEBUG &amp;&amp;</a>
<a name="ln2710">					optype == ASYNC_EVENT_DEBUG_QNQ) {</a>
<a name="ln2711">				dbgcqe =  (struct oce_async_event_qnq *)cqe;</a>
<a name="ln2712">				if(dbgcqe-&gt;valid)</a>
<a name="ln2713">					sc-&gt;qnqid = dbgcqe-&gt;vlan_tag;</a>
<a name="ln2714">				sc-&gt;qnq_debug_event = TRUE;</a>
<a name="ln2715">			}</a>
<a name="ln2716">		}</a>
<a name="ln2717">		cqe-&gt;u0.dw[3] = 0;</a>
<a name="ln2718">		RING_GET(cq-&gt;ring, 1);</a>
<a name="ln2719">		bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,</a>
<a name="ln2720">				cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2721">		cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_mq_cqe);</a>
<a name="ln2722">		num_cqes++;</a>
<a name="ln2723">	}</a>
<a name="ln2724"> </a>
<a name="ln2725">	if (num_cqes)</a>
<a name="ln2726">		oce_arm_cq(sc, cq-&gt;cq_id, num_cqes, FALSE);</a>
<a name="ln2727"> </a>
<a name="ln2728">	return 0;</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731"> </a>
<a name="ln2732">static void</a>
<a name="ln2733">setup_max_queues_want(POCE_SOFTC sc)</a>
<a name="ln2734">{</a>
<a name="ln2735">	/* Check if it is FLEX machine. Is so dont use RSS */</a>
<a name="ln2736">	if ((sc-&gt;function_mode &amp; FNM_FLEX10_MODE) ||</a>
<a name="ln2737">	    (sc-&gt;function_mode &amp; FNM_UMC_MODE)    ||</a>
<a name="ln2738">	    (sc-&gt;function_mode &amp; FNM_VNIC_MODE)	  ||</a>
<a name="ln2739">	    (!is_rss_enabled(sc))		  ||</a>
<a name="ln2740">	    IS_BE2(sc)) {</a>
<a name="ln2741">		sc-&gt;nrqs = 1;</a>
<a name="ln2742">		sc-&gt;nwqs = 1;</a>
<a name="ln2743">	} else {</a>
<a name="ln2744">		sc-&gt;nrqs = MIN(OCE_NCPUS, sc-&gt;nrssqs) + 1;</a>
<a name="ln2745">		sc-&gt;nwqs = MIN(OCE_NCPUS, sc-&gt;nrssqs);</a>
<a name="ln2746">	}</a>
<a name="ln2747"> </a>
<a name="ln2748">	if (IS_BE2(sc) &amp;&amp; is_rss_enabled(sc))</a>
<a name="ln2749">		sc-&gt;nrqs = MIN(OCE_NCPUS, sc-&gt;nrssqs) + 1;</a>
<a name="ln2750">}</a>
<a name="ln2751"> </a>
<a name="ln2752"> </a>
<a name="ln2753">static void</a>
<a name="ln2754">update_queues_got(POCE_SOFTC sc)</a>
<a name="ln2755">{</a>
<a name="ln2756">	if (is_rss_enabled(sc)) {</a>
<a name="ln2757">		sc-&gt;nrqs = sc-&gt;intr_count + 1;</a>
<a name="ln2758">		sc-&gt;nwqs = sc-&gt;intr_count;</a>
<a name="ln2759">	} else {</a>
<a name="ln2760">		sc-&gt;nrqs = 1;</a>
<a name="ln2761">		sc-&gt;nwqs = 1;</a>
<a name="ln2762">	}</a>
<a name="ln2763"> </a>
<a name="ln2764">	if (IS_BE2(sc))</a>
<a name="ln2765">		sc-&gt;nwqs = 1;</a>
<a name="ln2766">}</a>
<a name="ln2767"> </a>
<a name="ln2768">static int</a>
<a name="ln2769">oce_check_ipv6_ext_hdr(struct mbuf *m)</a>
<a name="ln2770">{</a>
<a name="ln2771">	struct ether_header *eh = mtod(m, struct ether_header *);</a>
<a name="ln2772">	caddr_t m_datatemp = m-&gt;m_data;</a>
<a name="ln2773"> </a>
<a name="ln2774">	if (eh-&gt;ether_type == htons(ETHERTYPE_IPV6)) {</a>
<a name="ln2775">		struct ip6_hdr *ip6;</a>
<a name="ln2776">		m-&gt;m_data += sizeof(struct ether_header);</a>
<a name="ln2777">		ip6 = mtod(m, struct ip6_hdr *);</a>
<a name="ln2778"> </a>
<a name="ln2779">		if((ip6-&gt;ip6_nxt != IPPROTO_TCP) &amp;&amp; \</a>
<a name="ln2780">				(ip6-&gt;ip6_nxt != IPPROTO_UDP)){</a>
<a name="ln2781">			struct ip6_ext *ip6e = NULL;</a>
<a name="ln2782">			m-&gt;m_data += sizeof(struct ip6_hdr);</a>
<a name="ln2783"> </a>
<a name="ln2784">			ip6e = (struct ip6_ext *) mtod(m, struct ip6_ext *);</a>
<a name="ln2785">			if(ip6e-&gt;ip6e_len == 0xff) {</a>
<a name="ln2786">				m-&gt;m_data = m_datatemp;</a>
<a name="ln2787">				return TRUE;</a>
<a name="ln2788">			}</a>
<a name="ln2789">		}</a>
<a name="ln2790">		m-&gt;m_data = m_datatemp;</a>
<a name="ln2791">	}</a>
<a name="ln2792">	return FALSE;</a>
<a name="ln2793">}</a>
<a name="ln2794"> </a>
<a name="ln2795">static int</a>
<a name="ln2796">is_be3_a1(POCE_SOFTC sc)</a>
<a name="ln2797">{</a>
<a name="ln2798">	if((sc-&gt;flags &amp; OCE_FLAGS_BE3)  &amp;&amp; ((sc-&gt;asic_revision &amp; 0xFF) &lt; 2)) {</a>
<a name="ln2799">		return TRUE;</a>
<a name="ln2800">	}</a>
<a name="ln2801">	return FALSE;</a>
<a name="ln2802">}</a>
<a name="ln2803"> </a>
<a name="ln2804">static struct mbuf *</a>
<a name="ln2805">oce_insert_vlan_tag(POCE_SOFTC sc, struct mbuf *m, boolean_t *complete)</a>
<a name="ln2806">{</a>
<a name="ln2807">	uint16_t vlan_tag = 0;</a>
<a name="ln2808"> </a>
<a name="ln2809">	if(!M_WRITABLE(m))</a>
<a name="ln2810">		return NULL;</a>
<a name="ln2811"> </a>
<a name="ln2812">	/* Embed vlan tag in the packet if it is not part of it */</a>
<a name="ln2813">	if(m-&gt;m_flags &amp; M_VLANTAG) {</a>
<a name="ln2814">		vlan_tag = EVL_VLANOFTAG(m-&gt;m_pkthdr.ether_vtag);</a>
<a name="ln2815">		m-&gt;m_flags &amp;= ~M_VLANTAG;</a>
<a name="ln2816">	}</a>
<a name="ln2817"> </a>
<a name="ln2818">	/* if UMC, ignore vlan tag insertion and instead insert pvid */</a>
<a name="ln2819">	if(sc-&gt;pvid) {</a>
<a name="ln2820">		if(!vlan_tag)</a>
<a name="ln2821">			vlan_tag = sc-&gt;pvid;</a>
<a name="ln2822">		if (complete)</a>
<a name="ln2823">			*complete = FALSE;</a>
<a name="ln2824">	}</a>
<a name="ln2825"> </a>
<a name="ln2826">	if(vlan_tag) {</a>
<a name="ln2827">		m = ether_vlanencap(m, vlan_tag);</a>
<a name="ln2828">	}</a>
<a name="ln2829"> </a>
<a name="ln2830">	if(sc-&gt;qnqid) {</a>
<a name="ln2831">		m = ether_vlanencap(m, sc-&gt;qnqid);</a>
<a name="ln2832"> </a>
<a name="ln2833">		if (complete)</a>
<a name="ln2834">			*complete = FALSE;</a>
<a name="ln2835">	}</a>
<a name="ln2836">	return m;</a>
<a name="ln2837">}</a>
<a name="ln2838"> </a>
<a name="ln2839">static int</a>
<a name="ln2840">oce_tx_asic_stall_verify(POCE_SOFTC sc, struct mbuf *m)</a>
<a name="ln2841">{</a>
<a name="ln2842">	if(is_be3_a1(sc) &amp;&amp; IS_QNQ_OR_UMC(sc) &amp;&amp; \</a>
<a name="ln2843">			oce_check_ipv6_ext_hdr(m)) {</a>
<a name="ln2844">		return TRUE;</a>
<a name="ln2845">	}</a>
<a name="ln2846">	return FALSE;</a>
<a name="ln2847">}</a>
<a name="ln2848"> </a>
<a name="ln2849">static void</a>
<a name="ln2850">oce_get_config(POCE_SOFTC sc)</a>
<a name="ln2851">{</a>
<a name="ln2852">	int rc = 0;</a>
<a name="ln2853">	uint32_t max_rss = 0;</a>
<a name="ln2854"> </a>
<a name="ln2855">	if ((IS_BE(sc) || IS_SH(sc)) &amp;&amp; (!sc-&gt;be3_native))</a>
<a name="ln2856">		max_rss = OCE_LEGACY_MODE_RSS;</a>
<a name="ln2857">	else</a>
<a name="ln2858">		max_rss = OCE_MAX_RSS;</a>
<a name="ln2859"> </a>
<a name="ln2860">	if (!IS_BE(sc)) {</a>
<a name="ln2861">		rc = oce_get_profile_config(sc, max_rss);</a>
<a name="ln2862">		if (rc) {</a>
<a name="ln2863">			sc-&gt;nwqs = OCE_MAX_WQ;</a>
<a name="ln2864">			sc-&gt;nrssqs = max_rss;</a>
<a name="ln2865">			sc-&gt;nrqs = sc-&gt;nrssqs + 1;</a>
<a name="ln2866">		}</a>
<a name="ln2867">	}</a>
<a name="ln2868">	else { /* For BE3 don't rely on fw for determining the resources */</a>
<a name="ln2869">		sc-&gt;nrssqs = max_rss;</a>
<a name="ln2870">		sc-&gt;nrqs = sc-&gt;nrssqs + 1;</a>
<a name="ln2871">		sc-&gt;nwqs = OCE_MAX_WQ;</a>
<a name="ln2872">		sc-&gt;max_vlans = MAX_VLANFILTER_SIZE;</a>
<a name="ln2873">	}</a>
<a name="ln2874">}</a>
<a name="ln2875"> </a>
<a name="ln2876">static void</a>
<a name="ln2877">oce_rdma_close(void)</a>
<a name="ln2878">{</a>
<a name="ln2879">  if (oce_rdma_if != NULL) {</a>
<a name="ln2880">    oce_rdma_if = NULL;</a>
<a name="ln2881">  }</a>
<a name="ln2882">}</a>
<a name="ln2883"> </a>
<a name="ln2884">static void</a>
<a name="ln2885">oce_get_mac_addr(POCE_SOFTC sc, uint8_t *macaddr)</a>
<a name="ln2886">{</a>
<a name="ln2887">  memcpy(macaddr, sc-&gt;macaddr.mac_addr, 6);</a>
<a name="ln2888">}</a>
<a name="ln2889"> </a>
<a name="ln2890">int</a>
<a name="ln2891">oce_register_rdma(POCE_RDMA_INFO rdma_info, POCE_RDMA_IF rdma_if)</a>
<a name="ln2892">{</a>
<a name="ln2893">  POCE_SOFTC sc;</a>
<a name="ln2894">  struct oce_dev_info di;</a>
<a name="ln2895">  int i;</a>
<a name="ln2896"> </a>
<a name="ln2897">  if ((rdma_info == NULL) || (rdma_if == NULL)) {</a>
<a name="ln2898">    return -EINVAL;</a>
<a name="ln2899">  }</a>
<a name="ln2900"> </a>
<a name="ln2901">  if ((rdma_info-&gt;size != OCE_RDMA_INFO_SIZE) ||</a>
<a name="ln2902">      (rdma_if-&gt;size != OCE_RDMA_IF_SIZE)) {</a>
<a name="ln2903">    return -ENXIO;</a>
<a name="ln2904">  }</a>
<a name="ln2905"> </a>
<a name="ln2906">  rdma_info-&gt;close = oce_rdma_close;</a>
<a name="ln2907">  rdma_info-&gt;mbox_post = oce_mbox_post;</a>
<a name="ln2908">  rdma_info-&gt;common_req_hdr_init = mbx_common_req_hdr_init;</a>
<a name="ln2909">  rdma_info-&gt;get_mac_addr = oce_get_mac_addr;</a>
<a name="ln2910"> </a>
<a name="ln2911">  oce_rdma_if = rdma_if;</a>
<a name="ln2912"> </a>
<a name="ln2913">  sc = softc_head;</a>
<a name="ln2914">  while (sc != NULL) {</a>
<a name="ln2915">    if (oce_rdma_if-&gt;announce != NULL) {</a>
<a name="ln2916">      memset(&amp;di, 0, sizeof(di));</a>
<a name="ln2917">      di.dev = sc-&gt;dev;</a>
<a name="ln2918">      di.softc = sc;</a>
<a name="ln2919">      di.ifp = sc-&gt;ifp;</a>
<a name="ln2920">      di.db_bhandle = sc-&gt;db_bhandle;</a>
<a name="ln2921">      di.db_btag = sc-&gt;db_btag;</a>
<a name="ln2922">      di.db_page_size = 4096;</a>
<a name="ln2923">      if (sc-&gt;flags &amp; OCE_FLAGS_USING_MSIX) {</a>
<a name="ln2924">        di.intr_mode = OCE_INTERRUPT_MODE_MSIX;</a>
<a name="ln2925">      } else if (sc-&gt;flags &amp; OCE_FLAGS_USING_MSI) {</a>
<a name="ln2926">        di.intr_mode = OCE_INTERRUPT_MODE_MSI;</a>
<a name="ln2927">      } else {</a>
<a name="ln2928">        di.intr_mode = OCE_INTERRUPT_MODE_INTX;</a>
<a name="ln2929">      }</a>
<a name="ln2930">      di.dev_family = OCE_GEN2_FAMILY; // fixme: must detect skyhawk</a>
<a name="ln2931">      if (di.intr_mode != OCE_INTERRUPT_MODE_INTX) {</a>
<a name="ln2932">        di.msix.num_vectors = sc-&gt;intr_count + sc-&gt;roce_intr_count;</a>
<a name="ln2933">        di.msix.start_vector = sc-&gt;intr_count;</a>
<a name="ln2934">        for (i=0; i&lt;di.msix.num_vectors; i++) {</a>
<a name="ln2935">          di.msix.vector_list[i] = sc-&gt;intrs[i].vector;</a>
<a name="ln2936">        }</a>
<a name="ln2937">      } else {</a>
<a name="ln2938">      }</a>
<a name="ln2939">      memcpy(di.mac_addr, sc-&gt;macaddr.mac_addr, 6);</a>
<a name="ln2940">      di.vendor_id = pci_get_vendor(sc-&gt;dev);</a>
<a name="ln2941">      di.dev_id = pci_get_device(sc-&gt;dev);</a>
<a name="ln2942"> </a>
<a name="ln2943">      if (sc-&gt;rdma_flags &amp; OCE_RDMA_FLAG_SUPPORTED) {</a>
<a name="ln2944">          di.flags  |= OCE_RDMA_INFO_RDMA_SUPPORTED;</a>
<a name="ln2945">      }</a>
<a name="ln2946"> </a>
<a name="ln2947">      rdma_if-&gt;announce(&amp;di);</a>
<a name="ln2948">      sc = sc-&gt;next;</a>
<a name="ln2949">    }</a>
<a name="ln2950">  }</a>
<a name="ln2951"> </a>
<a name="ln2952">  return 0;</a>
<a name="ln2953">}</a>
<a name="ln2954"> </a>
<a name="ln2955">static void</a>
<a name="ln2956">oce_read_env_variables( POCE_SOFTC sc )</a>
<a name="ln2957">{</a>
<a name="ln2958">	char *value = NULL;</a>
<a name="ln2959">	int rc = 0;</a>
<a name="ln2960"> </a>
<a name="ln2961">        /* read if user wants to enable hwlro or swlro */</a>
<a name="ln2962">        //value = getenv(&quot;oce_enable_hwlro&quot;);</a>
<a name="ln2963">        if(value &amp;&amp; IS_SH(sc)) {</a>
<a name="ln2964">                sc-&gt;enable_hwlro = strtol(value, NULL, 10);</a>
<a name="ln2965">                if(sc-&gt;enable_hwlro) {</a>
<a name="ln2966">                        rc = oce_mbox_nic_query_lro_capabilities(sc, NULL, NULL);</a>
<a name="ln2967">                        if(rc) {</a>
<a name="ln2968">                                device_printf(sc-&gt;dev, &quot;no hardware lro support\n&quot;);</a>
<a name="ln2969">                		device_printf(sc-&gt;dev, &quot;software lro enabled\n&quot;);</a>
<a name="ln2970">                                sc-&gt;enable_hwlro = 0;</a>
<a name="ln2971">                        }else {</a>
<a name="ln2972">                                device_printf(sc-&gt;dev, &quot;hardware lro enabled\n&quot;);</a>
<a name="ln2973">				oce_max_rsp_handled = 32;</a>
<a name="ln2974">                        }</a>
<a name="ln2975">                }else {</a>
<a name="ln2976">                        device_printf(sc-&gt;dev, &quot;software lro enabled\n&quot;);</a>
<a name="ln2977">                }</a>
<a name="ln2978">        }else {</a>
<a name="ln2979">                sc-&gt;enable_hwlro = 0;</a>
<a name="ln2980">        }</a>
<a name="ln2981"> </a>
<a name="ln2982">        /* read mbuf size */</a>
<a name="ln2983">        //value = getenv(&quot;oce_rq_buf_size&quot;);</a>
<a name="ln2984">        if(value &amp;&amp; IS_SH(sc)) {</a>
<a name="ln2985">                oce_rq_buf_size = strtol(value, NULL, 10);</a>
<a name="ln2986">                switch(oce_rq_buf_size) {</a>
<a name="ln2987">                case 2048:</a>
<a name="ln2988">                case 4096:</a>
<a name="ln2989">                case 9216:</a>
<a name="ln2990">                case 16384:</a>
<a name="ln2991">                        break;</a>
<a name="ln2992"> </a>
<a name="ln2993">                default:</a>
<a name="ln2994">                        device_printf(sc-&gt;dev, &quot; Supported oce_rq_buf_size values are 2K, 4K, 9K, 16K \n&quot;);</a>
<a name="ln2995">                        oce_rq_buf_size = 2048;</a>
<a name="ln2996">                }</a>
<a name="ln2997">        }</a>
<a name="ln2998"> </a>
<a name="ln2999">	return;</a>
<a name="ln3000">}</a>

</code></pre>
<div class="balloon" rel="802"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'vector' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 802, 805.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
