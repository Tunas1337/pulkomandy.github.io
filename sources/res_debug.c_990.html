
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>res_debug.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: res_debug.c,v 1.14 2015/02/24 17:56:20 christos Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*</a>
<a name="ln4"> * Portions Copyright (C) 2004, 2005, 2008, 2009  Internet Systems Consortium, Inc. (&quot;ISC&quot;)</a>
<a name="ln5"> * Portions Copyright (C) 1996-2003  Internet Software Consortium.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ISC DISCLAIMS ALL WARRANTIES WITH</a>
<a name="ln12"> * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</a>
<a name="ln13"> * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,</a>
<a name="ln14"> * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM</a>
<a name="ln15"> * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE</a>
<a name="ln16"> * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</a>
<a name="ln17"> * PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> */</a>
<a name="ln19"> </a>
<a name="ln20">/*</a>
<a name="ln21"> * Copyright (c) 1985</a>
<a name="ln22"> *    The Regents of the University of California.  All rights reserved.</a>
<a name="ln23"> *</a>
<a name="ln24"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln25"> * modification, are permitted provided that the following conditions</a>
<a name="ln26"> * are met:</a>
<a name="ln27"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln28"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln29"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln30"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln31"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln32"> * 3. Neither the name of the University nor the names of its contributors</a>
<a name="ln33"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln34"> *    without specific prior written permission.</a>
<a name="ln35"> *</a>
<a name="ln36"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln37"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln38"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln39"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln40"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln41"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln42"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln43"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln44"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln45"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln46"> * SUCH DAMAGE.</a>
<a name="ln47"> */</a>
<a name="ln48"> </a>
<a name="ln49">/*</a>
<a name="ln50"> * Portions Copyright (c) 1993 by Digital Equipment Corporation.</a>
<a name="ln51"> *</a>
<a name="ln52"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln53"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln54"> * copyright notice and this permission notice appear in all copies, and that</a>
<a name="ln55"> * the name of Digital Equipment Corporation not be used in advertising or</a>
<a name="ln56"> * publicity pertaining to distribution of the document or software without</a>
<a name="ln57"> * specific, written prior permission.</a>
<a name="ln58"> *</a>
<a name="ln59"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL</a>
<a name="ln60"> * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES</a>
<a name="ln61"> * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT</a>
<a name="ln62"> * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL</a>
<a name="ln63"> * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR</a>
<a name="ln64"> * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS</a>
<a name="ln65"> * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS</a>
<a name="ln66"> * SOFTWARE.</a>
<a name="ln67"> */</a>
<a name="ln68"> </a>
<a name="ln69">/*</a>
<a name="ln70"> * Portions Copyright (c) 1995 by International Business Machines, Inc.</a>
<a name="ln71"> *</a>
<a name="ln72"> * International Business Machines, Inc. (hereinafter called IBM) grants</a>
<a name="ln73"> * permission under its copyrights to use, copy, modify, and distribute this</a>
<a name="ln74"> * Software with or without fee, provided that the above copyright notice and</a>
<a name="ln75"> * all paragraphs of this notice appear in all copies, and that the name of IBM</a>
<a name="ln76"> * not be used in connection with the marketing of any product incorporating</a>
<a name="ln77"> * the Software or modifications thereof, without specific, written prior</a>
<a name="ln78"> * permission.</a>
<a name="ln79"> *</a>
<a name="ln80"> * To the extent it has a right to do so, IBM grants an immunity from suit</a>
<a name="ln81"> * under its patents, if any, for the use, sale or manufacture of products to</a>
<a name="ln82"> * the extent that such products are used for performing Domain Name System</a>
<a name="ln83"> * dynamic updates in TCP/IP networks by means of the Software.  No immunity is</a>
<a name="ln84"> * granted for any product per se or for any other function of any product.</a>
<a name="ln85"> *</a>
<a name="ln86"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, AND IBM DISCLAIMS ALL WARRANTIES,</a>
<a name="ln87"> * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A</a>
<a name="ln88"> * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,</a>
<a name="ln89"> * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING</a>
<a name="ln90"> * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN</a>
<a name="ln91"> * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.</a>
<a name="ln92"> */</a>
<a name="ln93"> </a>
<a name="ln94">#if defined(LIBC_SCCS) &amp;&amp; !defined(lint)</a>
<a name="ln95">static const char sccsid[] = &quot;@(#)res_debug.c	8.1 (Berkeley) 6/4/93&quot;;</a>
<a name="ln96">static const char rcsid[] = &quot;$Id: res_debug.c,v 1.19 2009/02/26 11:20:20 tbox Exp $&quot;;</a>
<a name="ln97">#endif /* LIBC_SCCS and not lint */</a>
<a name="ln98"> </a>
<a name="ln99">#include &quot;port_before.h&quot;</a>
<a name="ln100"> </a>
<a name="ln101">#include &lt;sys/types.h&gt;</a>
<a name="ln102">#include &lt;sys/param.h&gt;</a>
<a name="ln103">#include &lt;sys/socket.h&gt;</a>
<a name="ln104"> </a>
<a name="ln105">#include &lt;netinet/in.h&gt;</a>
<a name="ln106">#include &lt;arpa/inet.h&gt;</a>
<a name="ln107">#include &lt;arpa/nameser.h&gt;</a>
<a name="ln108"> </a>
<a name="ln109">#include &lt;assert.h&gt;</a>
<a name="ln110">#include &lt;ctype.h&gt;</a>
<a name="ln111">#include &lt;errno.h&gt;</a>
<a name="ln112">#include &lt;math.h&gt;</a>
<a name="ln113">#include &lt;netdb.h&gt;</a>
<a name="ln114">#include &lt;resolv.h&gt;</a>
<a name="ln115">#include &lt;resolv_mt.h&gt;</a>
<a name="ln116">#include &lt;stdio.h&gt;</a>
<a name="ln117">#include &lt;stdlib.h&gt;</a>
<a name="ln118">#include &lt;string.h&gt;</a>
<a name="ln119">#include &lt;time.h&gt;</a>
<a name="ln120"> </a>
<a name="ln121">#include &quot;port_after.h&quot;</a>
<a name="ln122"> </a>
<a name="ln123">#ifdef SPRINTF_CHAR</a>
<a name="ln124"># define SPRINTF(x) strlen(sprintf/**/x)</a>
<a name="ln125">#else</a>
<a name="ln126"># define SPRINTF(x) sprintf x</a>
<a name="ln127">#endif</a>
<a name="ln128"> </a>
<a name="ln129">extern const char *_res_opcodes[];</a>
<a name="ln130">extern const char *_res_sectioncodes[];</a>
<a name="ln131"> </a>
<a name="ln132">#if 0</a>
<a name="ln133">#ifdef __weak_alias</a>
<a name="ln134">__weak_alias(res_pquery,__res_pquery)</a>
<a name="ln135">__weak_alias(res_nametoclass,__res_nametoclass)</a>
<a name="ln136">__weak_alias(res_nametotype,__res_nametotype)</a>
<a name="ln137">#endif</a>
<a name="ln138">#endif</a>
<a name="ln139"> </a>
<a name="ln140">#ifndef _LIBC</a>
<a name="ln141">/*%</a>
<a name="ln142"> * Print the current options.</a>
<a name="ln143"> */</a>
<a name="ln144">void</a>
<a name="ln145">fp_resstat(const res_state statp, FILE *file) {</a>
<a name="ln146">	u_long mask;</a>
<a name="ln147"> </a>
<a name="ln148">	fprintf(file, &quot;;; res options:&quot;);</a>
<a name="ln149">	for (mask = 1;  mask != 0U;  mask &lt;&lt;= 1)</a>
<a name="ln150">		if (statp-&gt;options &amp; mask)</a>
<a name="ln151">			fprintf(file, &quot; %s&quot;, p_option(mask));</a>
<a name="ln152">	putc('\n', file);</a>
<a name="ln153">}</a>
<a name="ln154">#endif</a>
<a name="ln155"> </a>
<a name="ln156">static void</a>
<a name="ln157">do_section(const res_state statp,</a>
<a name="ln158">	   ns_msg *handle, ns_sect section,</a>
<a name="ln159">	   int pflag, FILE *file)</a>
<a name="ln160">{</a>
<a name="ln161">	int n, sflag, rrnum;</a>
<a name="ln162">	static int buflen = 2048;</a>
<a name="ln163">	char *buf;</a>
<a name="ln164">	ns_opcode opcode;</a>
<a name="ln165">	ns_rr rr;</a>
<a name="ln166"> </a>
<a name="ln167">	/*</a>
<a name="ln168">	 * Print answer records.</a>
<a name="ln169">	 */</a>
<a name="ln170">	sflag = (int)(statp-&gt;pfcode &amp; pflag);</a>
<a name="ln171">	if (statp-&gt;pfcode &amp;&amp; !sflag)</a>
<a name="ln172">		return;</a>
<a name="ln173"> </a>
<a name="ln174">	buf = malloc((size_t)buflen);</a>
<a name="ln175">	if (buf == NULL) {</a>
<a name="ln176">		fprintf(file, &quot;;; memory allocation failure\n&quot;);</a>
<a name="ln177">		return;</a>
<a name="ln178">	}</a>
<a name="ln179"> </a>
<a name="ln180">	opcode = (ns_opcode) ns_msg_getflag(*handle, ns_f_opcode);</a>
<a name="ln181">	rrnum = 0;</a>
<a name="ln182">	for (;;) {</a>
<a name="ln183">		if (ns_parserr(handle, section, rrnum, &amp;rr)) {</a>
<a name="ln184">			if (errno != ENODEV)</a>
<a name="ln185">				fprintf(file, &quot;;; ns_parserr: %s\n&quot;,</a>
<a name="ln186">					strerror(errno));</a>
<a name="ln187">			else if (rrnum &gt; 0 &amp;&amp; sflag != 0 &amp;&amp;</a>
<a name="ln188">				 (statp-&gt;pfcode &amp; RES_PRF_HEAD1))</a>
<a name="ln189">				putc('\n', file);</a>
<a name="ln190">			goto cleanup;</a>
<a name="ln191">		}</a>
<a name="ln192">		if (rrnum == 0 &amp;&amp; sflag != 0 &amp;&amp; (statp-&gt;pfcode &amp; RES_PRF_HEAD1))</a>
<a name="ln193">			fprintf(file, &quot;;; %s SECTION:\n&quot;,</a>
<a name="ln194">				p_section(section, opcode));</a>
<a name="ln195">		if (section == ns_s_qd)</a>
<a name="ln196">			fprintf(file, &quot;;;\t%s, type = %s, class = %s\n&quot;,</a>
<a name="ln197">				ns_rr_name(rr),</a>
<a name="ln198">				p_type(ns_rr_type(rr)),</a>
<a name="ln199">				p_class(ns_rr_class(rr)));</a>
<a name="ln200">		else if (section == ns_s_ar &amp;&amp; ns_rr_type(rr) == ns_t_opt) {</a>
<a name="ln201">			size_t rdatalen, ttl;</a>
<a name="ln202">			uint16_t optcode, optlen;</a>
<a name="ln203"> </a>
<a name="ln204">			rdatalen = ns_rr_rdlen(rr);</a>
<a name="ln205">			ttl = ns_rr_ttl(rr);</a>
<a name="ln206"> </a>
<a name="ln207">			fprintf(file,</a>
<a name="ln208">				&quot;; EDNS: version: %zu, udp=%u, flags=%04zx\n&quot;,</a>
<a name="ln209">				(ttl&gt;&gt;16)&amp;0xff, ns_rr_class(rr), ttl&amp;0xffff);</a>
<a name="ln210"> </a>
<a name="ln211">			while (rdatalen &gt;= 4) {</a>
<a name="ln212">				const u_char *cp = ns_rr_rdata(rr);</a>
<a name="ln213">				int i;</a>
<a name="ln214"> </a>
<a name="ln215">				GETSHORT(optcode, cp);</a>
<a name="ln216">				GETSHORT(optlen, cp);</a>
<a name="ln217"> </a>
<a name="ln218">				if (optcode == NS_OPT_NSID) {</a>
<a name="ln219">					fputs(&quot;; NSID: &quot;, file);</a>
<a name="ln220">					if (optlen == 0) {</a>
<a name="ln221">						fputs(&quot;; NSID\n&quot;, file);</a>
<a name="ln222">					} else {</a>
<a name="ln223">						fputs(&quot;; NSID: &quot;, file);</a>
<a name="ln224">						for (i = 0; i &lt; optlen; i++)</a>
<a name="ln225">							fprintf(file, &quot;%02x &quot;,</a>
<a name="ln226">								cp[i]);</a>
<a name="ln227">						fputs(&quot; (&quot;,file);</a>
<a name="ln228">						for (i = 0; i &lt; optlen; i++)</a>
<a name="ln229">							fprintf(file, &quot;%c&quot;,</a>
<a name="ln230">								isprint(cp[i])?</a>
<a name="ln231">								cp[i] : '.');</a>
<a name="ln232">						fputs(&quot;)\n&quot;, file);</a>
<a name="ln233">					}</a>
<a name="ln234">				} else {</a>
<a name="ln235">					if (optlen == 0) {</a>
<a name="ln236">						fprintf(file, &quot;; OPT=%u\n&quot;,</a>
<a name="ln237">							optcode);</a>
<a name="ln238">					} else {</a>
<a name="ln239">						fprintf(file, &quot;; OPT=%u: &quot;,</a>
<a name="ln240">							optcode);</a>
<a name="ln241">						for (i = 0; i &lt; optlen; i++)</a>
<a name="ln242">							fprintf(file, &quot;%02x &quot;,</a>
<a name="ln243">								cp[i]);</a>
<a name="ln244">						fputs(&quot; (&quot;,file);</a>
<a name="ln245">						for (i = 0; i &lt; optlen; i++)</a>
<a name="ln246">							fprintf(file, &quot;%c&quot;,</a>
<a name="ln247">								isprint(cp[i]) ?</a>
<a name="ln248">									cp[i] : '.');</a>
<a name="ln249">						fputs(&quot;)\n&quot;, file);</a>
<a name="ln250">					}</a>
<a name="ln251">				}</a>
<a name="ln252">				rdatalen -= 4 + optlen;</a>
<a name="ln253">			}</a>
<a name="ln254">		} else {</a>
<a name="ln255">			n = ns_sprintrr(handle, &amp;rr, NULL, NULL,</a>
<a name="ln256">					buf, (u_int)buflen);</a>
<a name="ln257">			if (n &lt; 0) {</a>
<a name="ln258">				if (errno == ENOSPC) {</a>
<a name="ln259">					free(buf);</a>
<a name="ln260">					buf = NULL;</a>
<a name="ln261">					if (buflen &lt; 131072)</a>
<a name="ln262">						buf = malloc((size_t)(buflen += 1024));</a>
<a name="ln263">					if (buf == NULL) {</a>
<a name="ln264">						fprintf(file,</a>
<a name="ln265">					      &quot;;; memory allocation failure\n&quot;);</a>
<a name="ln266">					      return;</a>
<a name="ln267">					}</a>
<a name="ln268">					continue;</a>
<a name="ln269">				}</a>
<a name="ln270">				fprintf(file, &quot;;; ns_sprintrr: %s\n&quot;,</a>
<a name="ln271">					strerror(errno));</a>
<a name="ln272">				goto cleanup;</a>
<a name="ln273">			}</a>
<a name="ln274">			fputs(buf, file);</a>
<a name="ln275">			fputc('\n', file);</a>
<a name="ln276">		}</a>
<a name="ln277">		rrnum++;</a>
<a name="ln278">	}</a>
<a name="ln279"> cleanup:</a>
<a name="ln280">	if (buf != NULL)</a>
<a name="ln281">		free(buf);</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">/*%</a>
<a name="ln285"> * Print the contents of a query.</a>
<a name="ln286"> * This is intended to be primarily a debugging routine.</a>
<a name="ln287"> */</a>
<a name="ln288">void</a>
<a name="ln289">res_pquery(const res_state statp, const u_char *msg, int len, FILE *file) {</a>
<a name="ln290">	ns_msg handle;</a>
<a name="ln291">	int qdcount, ancount, nscount, arcount;</a>
<a name="ln292">	u_int opcode, rcode, id;</a>
<a name="ln293"> </a>
<a name="ln294">	if (ns_initparse(msg, len, &amp;handle) &lt; 0) {</a>
<a name="ln295">		fprintf(file, &quot;;; ns_initparse: %s\n&quot;, strerror(errno));</a>
<a name="ln296">		return;</a>
<a name="ln297">	}</a>
<a name="ln298">	opcode = ns_msg_getflag(handle, ns_f_opcode);</a>
<a name="ln299">	rcode = ns_msg_getflag(handle, ns_f_rcode);</a>
<a name="ln300">	id = ns_msg_id(handle);</a>
<a name="ln301">	qdcount = ns_msg_count(handle, ns_s_qd);</a>
<a name="ln302">	ancount = ns_msg_count(handle, ns_s_an);</a>
<a name="ln303">	nscount = ns_msg_count(handle, ns_s_ns);</a>
<a name="ln304">	arcount = ns_msg_count(handle, ns_s_ar);</a>
<a name="ln305"> </a>
<a name="ln306">	/*</a>
<a name="ln307">	 * Print header fields.</a>
<a name="ln308">	 */</a>
<a name="ln309">	if ((!statp-&gt;pfcode) || (statp-&gt;pfcode &amp; RES_PRF_HEADX) || rcode)</a>
<a name="ln310">		fprintf(file,</a>
<a name="ln311">			&quot;;; -&gt;&gt;HEADER&lt;&lt;- opcode: %s, status: %s, id: %d\n&quot;,</a>
<a name="ln312">			_res_opcodes[opcode], p_rcode((int)rcode), id);</a>
<a name="ln313">	if ((!statp-&gt;pfcode) || (statp-&gt;pfcode &amp; RES_PRF_HEADX))</a>
<a name="ln314">		putc(';', file);</a>
<a name="ln315">	if ((!statp-&gt;pfcode) || (statp-&gt;pfcode &amp; RES_PRF_HEAD2)) {</a>
<a name="ln316">		fprintf(file, &quot;; flags:&quot;);</a>
<a name="ln317">		if (ns_msg_getflag(handle, ns_f_qr))</a>
<a name="ln318">			fprintf(file, &quot; qr&quot;);</a>
<a name="ln319">		if (ns_msg_getflag(handle, ns_f_aa))</a>
<a name="ln320">			fprintf(file, &quot; aa&quot;);</a>
<a name="ln321">		if (ns_msg_getflag(handle, ns_f_tc))</a>
<a name="ln322">			fprintf(file, &quot; tc&quot;);</a>
<a name="ln323">		if (ns_msg_getflag(handle, ns_f_rd))</a>
<a name="ln324">			fprintf(file, &quot; rd&quot;);</a>
<a name="ln325">		if (ns_msg_getflag(handle, ns_f_ra))</a>
<a name="ln326">			fprintf(file, &quot; ra&quot;);</a>
<a name="ln327">		if (ns_msg_getflag(handle, ns_f_z))</a>
<a name="ln328">			fprintf(file, &quot; ??&quot;);</a>
<a name="ln329">		if (ns_msg_getflag(handle, ns_f_ad))</a>
<a name="ln330">			fprintf(file, &quot; ad&quot;);</a>
<a name="ln331">		if (ns_msg_getflag(handle, ns_f_cd))</a>
<a name="ln332">			fprintf(file, &quot; cd&quot;);</a>
<a name="ln333">	}</a>
<a name="ln334">	if ((!statp-&gt;pfcode) || (statp-&gt;pfcode &amp; RES_PRF_HEAD1)) {</a>
<a name="ln335">		fprintf(file, &quot;; %s: %d&quot;,</a>
<a name="ln336">			p_section(ns_s_qd, (int)opcode), qdcount);</a>
<a name="ln337">		fprintf(file, &quot;, %s: %d&quot;,</a>
<a name="ln338">			p_section(ns_s_an, (int)opcode), ancount);</a>
<a name="ln339">		fprintf(file, &quot;, %s: %d&quot;,</a>
<a name="ln340">			p_section(ns_s_ns, (int)opcode), nscount);</a>
<a name="ln341">		fprintf(file, &quot;, %s: %d&quot;,</a>
<a name="ln342">			p_section(ns_s_ar, (int)opcode), arcount);</a>
<a name="ln343">	}</a>
<a name="ln344">	if ((!statp-&gt;pfcode) || (statp-&gt;pfcode &amp;</a>
<a name="ln345">		(RES_PRF_HEADX | RES_PRF_HEAD2 | RES_PRF_HEAD1))) {</a>
<a name="ln346">		putc('\n',file);</a>
<a name="ln347">	}</a>
<a name="ln348">	/*</a>
<a name="ln349">	 * Print the various sections.</a>
<a name="ln350">	 */</a>
<a name="ln351">	do_section(statp, &amp;handle, ns_s_qd, RES_PRF_QUES, file);</a>
<a name="ln352">	do_section(statp, &amp;handle, ns_s_an, RES_PRF_ANS, file);</a>
<a name="ln353">	do_section(statp, &amp;handle, ns_s_ns, RES_PRF_AUTH, file);</a>
<a name="ln354">	do_section(statp, &amp;handle, ns_s_ar, RES_PRF_ADD, file);</a>
<a name="ln355">	if (qdcount == 0 &amp;&amp; ancount == 0 &amp;&amp;</a>
<a name="ln356">	    nscount == 0 &amp;&amp; arcount == 0)</a>
<a name="ln357">		putc('\n', file);</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">const u_char *</a>
<a name="ln361">p_cdnname(const u_char *cp, const u_char *msg, int len, FILE *file) {</a>
<a name="ln362">	char name[MAXDNAME];</a>
<a name="ln363">	int n;</a>
<a name="ln364"> </a>
<a name="ln365">	if ((n = dn_expand(msg, msg + len, cp, name, (int)sizeof name)) &lt; 0)</a>
<a name="ln366">		return (NULL);</a>
<a name="ln367">	if (name[0] == '\0')</a>
<a name="ln368">		putc('.', file);</a>
<a name="ln369">	else</a>
<a name="ln370">		fputs(name, file);</a>
<a name="ln371">	return (cp + n);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">const u_char *</a>
<a name="ln375">p_cdname(const u_char *cp, const u_char *msg, FILE *file) {</a>
<a name="ln376">	return (p_cdnname(cp, msg, PACKETSZ, file));</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">/*%</a>
<a name="ln380"> * Return a fully-qualified domain name from a compressed name (with</a>
<a name="ln381">   length supplied).  */</a>
<a name="ln382"> </a>
<a name="ln383">const u_char *</a>
<a name="ln384">p_fqnname(const u_char *cp, const u_char *msg, int msglen, char *name,</a>
<a name="ln385">    int namelen)</a>
<a name="ln386">{</a>
<a name="ln387">	int n;</a>
<a name="ln388">	size_t newlen;</a>
<a name="ln389"> </a>
<a name="ln390">	if ((n = dn_expand(msg, cp + msglen, cp, name, namelen)) &lt; 0)</a>
<a name="ln391">		return (NULL);</a>
<a name="ln392">	newlen = strlen(name);</a>
<a name="ln393">	if (newlen == 0 || name[newlen - 1] != '.') {</a>
<a name="ln394">		if ((int)newlen + 1 &gt;= namelen)	/*%&lt; Lack space for final dot */</a>
<a name="ln395">			return (NULL);</a>
<a name="ln396">		else</a>
<a name="ln397">			strcpy(name + newlen, &quot;.&quot;);</a>
<a name="ln398">	}</a>
<a name="ln399">	return (cp + n);</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">/* XXX:	the rest of these functions need to become length-limited, too. */</a>
<a name="ln403"> </a>
<a name="ln404">const u_char *</a>
<a name="ln405">p_fqname(const u_char *cp, const u_char *msg, FILE *file) {</a>
<a name="ln406">	char name[MAXDNAME];</a>
<a name="ln407">	const u_char *n;</a>
<a name="ln408"> </a>
<a name="ln409">	n = p_fqnname(cp, msg, MAXCDNAME, name, (int)sizeof name);</a>
<a name="ln410">	if (n == NULL)</a>
<a name="ln411">		return (NULL);</a>
<a name="ln412">	fputs(name, file);</a>
<a name="ln413">	return (n);</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">/*%</a>
<a name="ln417"> * Names of RR classes and qclasses.  Classes and qclasses are the same, except</a>
<a name="ln418"> * that C_ANY is a qclass but not a class.  (You can ask for records of class</a>
<a name="ln419"> * C_ANY, but you can't have any records of that class in the database.)</a>
<a name="ln420"> */</a>
<a name="ln421">const struct res_sym __p_class_syms[] = {</a>
<a name="ln422">	{C_IN,		&quot;IN&quot;,		(char *)0},</a>
<a name="ln423">	{C_CHAOS,	&quot;CH&quot;,		(char *)0},</a>
<a name="ln424">	{C_CHAOS,	&quot;CHAOS&quot;,	(char *)0},</a>
<a name="ln425">	{C_HS,		&quot;HS&quot;,		(char *)0},</a>
<a name="ln426">	{C_HS,		&quot;HESIOD&quot;,	(char *)0},</a>
<a name="ln427">	{C_ANY,		&quot;ANY&quot;,		(char *)0},</a>
<a name="ln428">	{C_NONE,	&quot;NONE&quot;,		(char *)0},</a>
<a name="ln429">	{C_IN, 		(char *)0,	(char *)0}</a>
<a name="ln430">};</a>
<a name="ln431"> </a>
<a name="ln432">/*%</a>
<a name="ln433"> * Names of message sections.</a>
<a name="ln434"> */</a>
<a name="ln435">const struct res_sym __p_default_section_syms[] = {</a>
<a name="ln436">	{ns_s_qd,	&quot;QUERY&quot;,	(char *)0},</a>
<a name="ln437">	{ns_s_an,	&quot;ANSWER&quot;,	(char *)0},</a>
<a name="ln438">	{ns_s_ns,	&quot;AUTHORITY&quot;,	(char *)0},</a>
<a name="ln439">	{ns_s_ar,	&quot;ADDITIONAL&quot;,	(char *)0},</a>
<a name="ln440">	{0,		(char *)0,	(char *)0}</a>
<a name="ln441">};</a>
<a name="ln442"> </a>
<a name="ln443">const struct res_sym __p_update_section_syms[] = {</a>
<a name="ln444">	{S_ZONE,	&quot;ZONE&quot;,		(char *)0},</a>
<a name="ln445">	{S_PREREQ,	&quot;PREREQUISITE&quot;,	(char *)0},</a>
<a name="ln446">	{S_UPDATE,	&quot;UPDATE&quot;,	(char *)0},</a>
<a name="ln447">	{S_ADDT,	&quot;ADDITIONAL&quot;,	(char *)0},</a>
<a name="ln448">	{0,		(char *)0,	(char *)0}</a>
<a name="ln449">};</a>
<a name="ln450"> </a>
<a name="ln451">const struct res_sym __p_key_syms[] = {</a>
<a name="ln452">	{NS_ALG_MD5RSA,		&quot;RSA&quot;,		&quot;RSA KEY with MD5 hash&quot;},</a>
<a name="ln453">	{NS_ALG_DH,		&quot;DH&quot;,		&quot;Diffie Hellman&quot;},</a>
<a name="ln454">	{NS_ALG_DSA,		&quot;DSA&quot;,		&quot;Digital Signature Algorithm&quot;},</a>
<a name="ln455">	{NS_ALG_EXPIRE_ONLY,	&quot;EXPIREONLY&quot;,	&quot;No algorithm&quot;},</a>
<a name="ln456">	{NS_ALG_PRIVATE_OID,	&quot;PRIVATE&quot;,	&quot;Algorithm obtained from OID&quot;},</a>
<a name="ln457">	{0,			NULL,		NULL}</a>
<a name="ln458">};</a>
<a name="ln459"> </a>
<a name="ln460">const struct res_sym __p_cert_syms[] = {</a>
<a name="ln461">	{cert_t_pkix,	&quot;PKIX&quot;,		&quot;PKIX (X.509v3) Certificate&quot;},</a>
<a name="ln462">	{cert_t_spki,	&quot;SPKI&quot;,		&quot;SPKI certificate&quot;},</a>
<a name="ln463">	{cert_t_pgp,	&quot;PGP&quot;,		&quot;PGP certificate&quot;},</a>
<a name="ln464">	{cert_t_url,	&quot;URL&quot;,		&quot;URL Private&quot;},</a>
<a name="ln465">	{cert_t_oid,	&quot;OID&quot;,		&quot;OID Private&quot;},</a>
<a name="ln466">	{0,		NULL,		NULL}</a>
<a name="ln467">};</a>
<a name="ln468"> </a>
<a name="ln469">/*%</a>
<a name="ln470"> * Names of RR types and qtypes.  Types and qtypes are the same, except</a>
<a name="ln471"> * that T_ANY is a qtype but not a type.  (You can ask for records of type</a>
<a name="ln472"> * T_ANY, but you can't have any records of that type in the database.)</a>
<a name="ln473"> */</a>
<a name="ln474">const struct res_sym __p_type_syms[] = {</a>
<a name="ln475">	{ns_t_a,	&quot;A&quot;,		&quot;address&quot;},</a>
<a name="ln476">	{ns_t_ns,	&quot;NS&quot;,		&quot;name server&quot;},</a>
<a name="ln477">	{ns_t_md,	&quot;MD&quot;,		&quot;mail destination (deprecated)&quot;},</a>
<a name="ln478">	{ns_t_mf,	&quot;MF&quot;,		&quot;mail forwarder (deprecated)&quot;},</a>
<a name="ln479">	{ns_t_cname,	&quot;CNAME&quot;,	&quot;canonical name&quot;},</a>
<a name="ln480">	{ns_t_soa,	&quot;SOA&quot;,		&quot;start of authority&quot;},</a>
<a name="ln481">	{ns_t_mb,	&quot;MB&quot;,		&quot;mailbox&quot;},</a>
<a name="ln482">	{ns_t_mg,	&quot;MG&quot;,		&quot;mail group member&quot;},</a>
<a name="ln483">	{ns_t_mr,	&quot;MR&quot;,		&quot;mail rename&quot;},</a>
<a name="ln484">	{ns_t_null,	&quot;NULL&quot;,		&quot;null&quot;},</a>
<a name="ln485">	{ns_t_wks,	&quot;WKS&quot;,		&quot;well-known service (deprecated)&quot;},</a>
<a name="ln486">	{ns_t_ptr,	&quot;PTR&quot;,		&quot;domain name pointer&quot;},</a>
<a name="ln487">	{ns_t_hinfo,	&quot;HINFO&quot;,	&quot;host information&quot;},</a>
<a name="ln488">	{ns_t_minfo,	&quot;MINFO&quot;,	&quot;mailbox information&quot;},</a>
<a name="ln489">	{ns_t_mx,	&quot;MX&quot;,		&quot;mail exchanger&quot;},</a>
<a name="ln490">	{ns_t_txt,	&quot;TXT&quot;,		&quot;text&quot;},</a>
<a name="ln491">	{ns_t_rp,	&quot;RP&quot;,		&quot;responsible person&quot;},</a>
<a name="ln492">	{ns_t_afsdb,	&quot;AFSDB&quot;,	&quot;DCE or AFS server&quot;},</a>
<a name="ln493">	{ns_t_x25,	&quot;X25&quot;,		&quot;X25 address&quot;},</a>
<a name="ln494">	{ns_t_isdn,	&quot;ISDN&quot;,		&quot;ISDN address&quot;},</a>
<a name="ln495">	{ns_t_rt,	&quot;RT&quot;,		&quot;router&quot;},</a>
<a name="ln496">	{ns_t_nsap,	&quot;NSAP&quot;,		&quot;nsap address&quot;},</a>
<a name="ln497">	{ns_t_nsap_ptr,	&quot;NSAP_PTR&quot;,	&quot;domain name pointer&quot;},</a>
<a name="ln498">	{ns_t_sig,	&quot;SIG&quot;,		&quot;signature&quot;},</a>
<a name="ln499">	{ns_t_key,	&quot;KEY&quot;,		&quot;key&quot;},</a>
<a name="ln500">	{ns_t_px,	&quot;PX&quot;,		&quot;mapping information&quot;},</a>
<a name="ln501">	{ns_t_gpos,	&quot;GPOS&quot;,		&quot;geographical position (withdrawn)&quot;},</a>
<a name="ln502">	{ns_t_aaaa,	&quot;AAAA&quot;,		&quot;IPv6 address&quot;},</a>
<a name="ln503">	{ns_t_loc,	&quot;LOC&quot;,		&quot;location&quot;},</a>
<a name="ln504">	{ns_t_nxt,	&quot;NXT&quot;,		&quot;next valid name (unimplemented)&quot;},</a>
<a name="ln505">	{ns_t_eid,	&quot;EID&quot;,		&quot;endpoint identifier (unimplemented)&quot;},</a>
<a name="ln506">	{ns_t_nimloc,	&quot;NIMLOC&quot;,	&quot;NIMROD locator (unimplemented)&quot;},</a>
<a name="ln507">	{ns_t_srv,	&quot;SRV&quot;,		&quot;server selection&quot;},</a>
<a name="ln508">	{ns_t_atma,	&quot;ATMA&quot;,		&quot;ATM address (unimplemented)&quot;},</a>
<a name="ln509">	{ns_t_naptr,	&quot;NAPTR&quot;,	&quot;naptr&quot;},</a>
<a name="ln510">	{ns_t_kx,	&quot;KX&quot;,		&quot;key exchange&quot;},</a>
<a name="ln511">	{ns_t_cert,	&quot;CERT&quot;,		&quot;certificate&quot;},</a>
<a name="ln512">	{ns_t_a6,	&quot;A&quot;,		&quot;IPv6 address (experminental)&quot;},</a>
<a name="ln513">	{ns_t_dname,	&quot;DNAME&quot;,	&quot;non-terminal redirection&quot;},</a>
<a name="ln514">	{ns_t_opt,	&quot;OPT&quot;,		&quot;opt&quot;},</a>
<a name="ln515">	{ns_t_apl,	&quot;apl&quot;,		&quot;apl&quot;},</a>
<a name="ln516">	{ns_t_ds,	&quot;DS&quot;,		&quot;delegation signer&quot;},</a>
<a name="ln517">	{ns_t_sshfp,	&quot;SSFP&quot;,		&quot;SSH fingerprint&quot;},</a>
<a name="ln518">	{ns_t_ipseckey,	&quot;IPSECKEY&quot;,	&quot;IPSEC key&quot;},</a>
<a name="ln519">	{ns_t_rrsig,	&quot;RRSIG&quot;,	&quot;rrsig&quot;},</a>
<a name="ln520">	{ns_t_nsec,	&quot;NSEC&quot;,		&quot;nsec&quot;},</a>
<a name="ln521">	{ns_t_dnskey,	&quot;DNSKEY&quot;,	&quot;DNS key&quot;},</a>
<a name="ln522">	{ns_t_dhcid,	&quot;DHCID&quot;,       &quot;dynamic host configuration identifier&quot;},</a>
<a name="ln523">	{ns_t_nsec3,	&quot;NSEC3&quot;,	&quot;nsec3&quot;},</a>
<a name="ln524">	{ns_t_nsec3param, &quot;NSEC3PARAM&quot;, &quot;NSEC3 parameters&quot;},</a>
<a name="ln525">	{ns_t_hip,	&quot;HIP&quot;,		&quot;host identity protocol&quot;},</a>
<a name="ln526">	{ns_t_spf,	&quot;SPF&quot;,		&quot;sender policy framework&quot;},</a>
<a name="ln527">	{ns_t_tkey,	&quot;TKEY&quot;,		&quot;tkey&quot;},</a>
<a name="ln528">	{ns_t_tsig,	&quot;TSIG&quot;,		&quot;transaction signature&quot;},</a>
<a name="ln529">	{ns_t_ixfr,	&quot;IXFR&quot;,		&quot;incremental zone transfer&quot;},</a>
<a name="ln530">	{ns_t_axfr,	&quot;AXFR&quot;,		&quot;zone transfer&quot;},</a>
<a name="ln531">	{ns_t_zxfr,	&quot;ZXFR&quot;,		&quot;compressed zone transfer&quot;},</a>
<a name="ln532">	{ns_t_mailb,	&quot;MAILB&quot;,	&quot;mailbox-related data (deprecated)&quot;},</a>
<a name="ln533">	{ns_t_maila,	&quot;MAILA&quot;,	&quot;mail agent (deprecated)&quot;},</a>
<a name="ln534">	{ns_t_naptr,	&quot;NAPTR&quot;,	&quot;URN Naming Authority&quot;},</a>
<a name="ln535">	{ns_t_kx,	&quot;KX&quot;,		&quot;Key Exchange&quot;},</a>
<a name="ln536">	{ns_t_cert,	&quot;CERT&quot;,		&quot;Certificate&quot;},</a>
<a name="ln537">	{ns_t_a6,	&quot;A6&quot;,		&quot;IPv6 Address&quot;},</a>
<a name="ln538">	{ns_t_dname,	&quot;DNAME&quot;,	&quot;dname&quot;},</a>
<a name="ln539">	{ns_t_sink,	&quot;SINK&quot;,		&quot;Kitchen Sink (experimental)&quot;},</a>
<a name="ln540">	{ns_t_opt,	&quot;OPT&quot;,		&quot;EDNS Options&quot;},</a>
<a name="ln541">	{ns_t_any,	&quot;ANY&quot;,		&quot;\&quot;any\&quot;&quot;},</a>
<a name="ln542">	{ns_t_dlv,	&quot;DLV&quot;,		&quot;DNSSEC look-aside validation&quot;},</a>
<a name="ln543">	{0, 		NULL,		NULL}</a>
<a name="ln544">};</a>
<a name="ln545"> </a>
<a name="ln546">/*%</a>
<a name="ln547"> * Names of DNS rcodes.</a>
<a name="ln548"> */</a>
<a name="ln549">const struct res_sym __p_rcode_syms[] = {</a>
<a name="ln550">	{ns_r_noerror,	&quot;NOERROR&quot;,		&quot;no error&quot;},</a>
<a name="ln551">	{ns_r_formerr,	&quot;FORMERR&quot;,		&quot;format error&quot;},</a>
<a name="ln552">	{ns_r_servfail,	&quot;SERVFAIL&quot;,		&quot;server failed&quot;},</a>
<a name="ln553">	{ns_r_nxdomain,	&quot;NXDOMAIN&quot;,		&quot;no such domain name&quot;},</a>
<a name="ln554">	{ns_r_notimpl,	&quot;NOTIMP&quot;,		&quot;not implemented&quot;},</a>
<a name="ln555">	{ns_r_refused,	&quot;REFUSED&quot;,		&quot;refused&quot;},</a>
<a name="ln556">	{ns_r_yxdomain,	&quot;YXDOMAIN&quot;,		&quot;domain name exists&quot;},</a>
<a name="ln557">	{ns_r_yxrrset,	&quot;YXRRSET&quot;,		&quot;rrset exists&quot;},</a>
<a name="ln558">	{ns_r_nxrrset,	&quot;NXRRSET&quot;,		&quot;rrset doesn't exist&quot;},</a>
<a name="ln559">	{ns_r_notauth,	&quot;NOTAUTH&quot;,		&quot;not authoritative&quot;},</a>
<a name="ln560">	{ns_r_notzone,	&quot;NOTZONE&quot;,		&quot;Not in zone&quot;},</a>
<a name="ln561">	{ns_r_max,	&quot;&quot;,			&quot;&quot;},</a>
<a name="ln562">	{ns_r_badsig,	&quot;BADSIG&quot;,		&quot;bad signature&quot;},</a>
<a name="ln563">	{ns_r_badkey,	&quot;BADKEY&quot;,		&quot;bad key&quot;},</a>
<a name="ln564">	{ns_r_badtime,	&quot;BADTIME&quot;,		&quot;bad time&quot;},</a>
<a name="ln565">	{0, 		NULL,			NULL}</a>
<a name="ln566">};</a>
<a name="ln567"> </a>
<a name="ln568">int</a>
<a name="ln569">sym_ston(const struct res_sym *syms, const char *name, int *success) {</a>
<a name="ln570">	for (; syms-&gt;name != 0; syms++) {</a>
<a name="ln571">		if (strcasecmp (name, syms-&gt;name) == 0) {</a>
<a name="ln572">			if (success)</a>
<a name="ln573">				*success = 1;</a>
<a name="ln574">			return (syms-&gt;number);</a>
<a name="ln575">		}</a>
<a name="ln576">	}</a>
<a name="ln577">	if (success)</a>
<a name="ln578">		*success = 0;</a>
<a name="ln579">	return (syms-&gt;number);		/*%&lt; The default value. */</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">const char *</a>
<a name="ln583">sym_ntos(const struct res_sym *syms, int number, int *success) {</a>
<a name="ln584">	char *unname = sym_ntos_unname;</a>
<a name="ln585"> </a>
<a name="ln586">	for (; syms-&gt;name != 0; syms++) {</a>
<a name="ln587">		if (number == syms-&gt;number) {</a>
<a name="ln588">			if (success)</a>
<a name="ln589">				*success = 1;</a>
<a name="ln590">			return (syms-&gt;name);</a>
<a name="ln591">		}</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">	sprintf(unname, &quot;%d&quot;, number);		/*%&lt; XXX nonreentrant */</a>
<a name="ln595">	if (success)</a>
<a name="ln596">		*success = 0;</a>
<a name="ln597">	return (unname);</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">const char *</a>
<a name="ln601">sym_ntop(const struct res_sym *syms, int number, int *success) {</a>
<a name="ln602">	char *unname = sym_ntop_unname;</a>
<a name="ln603"> </a>
<a name="ln604">	for (; syms-&gt;name != 0; syms++) {</a>
<a name="ln605">		if (number == syms-&gt;number) {</a>
<a name="ln606">			if (success)</a>
<a name="ln607">				*success = 1;</a>
<a name="ln608">			return (syms-&gt;humanname);</a>
<a name="ln609">		}</a>
<a name="ln610">	}</a>
<a name="ln611">	sprintf(unname, &quot;%d&quot;, number);		/*%&lt; XXX nonreentrant */</a>
<a name="ln612">	if (success)</a>
<a name="ln613">		*success = 0;</a>
<a name="ln614">	return (unname);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">/*%</a>
<a name="ln618"> * Return a string for the type.</a>
<a name="ln619"> */</a>
<a name="ln620">const char *</a>
<a name="ln621">p_type(int type) {</a>
<a name="ln622">	int success;</a>
<a name="ln623">	const char *result;</a>
<a name="ln624">	static char typebuf[20];</a>
<a name="ln625"> </a>
<a name="ln626">	result = sym_ntos(__p_type_syms, type, &amp;success);</a>
<a name="ln627">	if (success)</a>
<a name="ln628">		return (result);</a>
<a name="ln629">	if (type &lt; 0 || type &gt; 0xffff)</a>
<a name="ln630">		return (&quot;BADTYPE&quot;);</a>
<a name="ln631">	sprintf(typebuf, &quot;TYPE%d&quot;, type);</a>
<a name="ln632">	return (typebuf);</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">/*%</a>
<a name="ln636"> * Return a string for the type.</a>
<a name="ln637"> */</a>
<a name="ln638">const char *</a>
<a name="ln639">p_section(int section, int opcode) {</a>
<a name="ln640">	const struct res_sym *symbols;</a>
<a name="ln641"> </a>
<a name="ln642">	switch (opcode) {</a>
<a name="ln643">	case ns_o_update:</a>
<a name="ln644">		symbols = __p_update_section_syms;</a>
<a name="ln645">		break;</a>
<a name="ln646">	default:</a>
<a name="ln647">		symbols = __p_default_section_syms;</a>
<a name="ln648">		break;</a>
<a name="ln649">	}</a>
<a name="ln650">	return (sym_ntos(symbols, section, (int *)0));</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">/*%</a>
<a name="ln654"> * Return a mnemonic for class.</a>
<a name="ln655"> */</a>
<a name="ln656">const char *</a>
<a name="ln657">p_class(int class) {</a>
<a name="ln658">	int success;</a>
<a name="ln659">	const char *result;</a>
<a name="ln660">	static char classbuf[20];</a>
<a name="ln661"> </a>
<a name="ln662">	result = sym_ntos(__p_class_syms, class, &amp;success);</a>
<a name="ln663">	if (success)</a>
<a name="ln664">		return (result);</a>
<a name="ln665">	if (class &lt; 0 || class &gt; 0xffff)</a>
<a name="ln666">		return (&quot;BADCLASS&quot;);</a>
<a name="ln667">	sprintf(classbuf, &quot;CLASS%d&quot;, class);</a>
<a name="ln668">	return (classbuf);</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">/*%</a>
<a name="ln672"> * Return a mnemonic for an option</a>
<a name="ln673"> */</a>
<a name="ln674">const char *</a>
<a name="ln675">p_option(u_long option) {</a>
<a name="ln676">	char *nbuf = p_option_nbuf;</a>
<a name="ln677"> </a>
<a name="ln678">	switch (option) {</a>
<a name="ln679">	case RES_INIT:		return &quot;init&quot;;</a>
<a name="ln680">	case RES_DEBUG:		return &quot;debug&quot;;</a>
<a name="ln681">	case RES_AAONLY:	return &quot;aaonly(unimpl)&quot;;</a>
<a name="ln682">	case RES_USEVC:		return &quot;usevc&quot;;</a>
<a name="ln683">	case RES_PRIMARY:	return &quot;primry(unimpl)&quot;;</a>
<a name="ln684">	case RES_IGNTC:		return &quot;igntc&quot;;</a>
<a name="ln685">	case RES_RECURSE:	return &quot;recurs&quot;;</a>
<a name="ln686">	case RES_DEFNAMES:	return &quot;defnam&quot;;</a>
<a name="ln687">	case RES_STAYOPEN:	return &quot;styopn&quot;;</a>
<a name="ln688">	case RES_DNSRCH:	return &quot;dnsrch&quot;;</a>
<a name="ln689">	case RES_INSECURE1:	return &quot;insecure1&quot;;</a>
<a name="ln690">	case RES_INSECURE2:	return &quot;insecure2&quot;;</a>
<a name="ln691">	case RES_NOALIASES:	return &quot;noaliases&quot;;</a>
<a name="ln692">	case RES_USE_INET6:	return &quot;inet6&quot;;</a>
<a name="ln693">	case RES_USE_INET4:	return &quot;inet4&quot;;</a>
<a name="ln694">#ifdef RES_USE_EDNS0	/*%&lt; KAME extension */</a>
<a name="ln695">	case RES_USE_EDNS0:	return &quot;edns0&quot;;</a>
<a name="ln696">	case RES_NSID:		return &quot;nsid&quot;;</a>
<a name="ln697">#endif</a>
<a name="ln698">#ifdef RES_USE_DNAME</a>
<a name="ln699">	case RES_USE_DNAME:	return &quot;dname&quot;;</a>
<a name="ln700">#endif</a>
<a name="ln701">#ifdef RES_USE_DNSSEC</a>
<a name="ln702">	case RES_USE_DNSSEC:	return &quot;dnssec&quot;;</a>
<a name="ln703">#endif</a>
<a name="ln704">#ifdef RES_NOTLDQUERY</a>
<a name="ln705">	case RES_NOTLDQUERY:	return &quot;no-tld-query&quot;;</a>
<a name="ln706">#endif</a>
<a name="ln707">#ifdef RES_NO_NIBBLE2</a>
<a name="ln708">	case RES_NO_NIBBLE2:	return &quot;no-nibble2&quot;;</a>
<a name="ln709">#endif</a>
<a name="ln710">				/* XXX nonreentrant */</a>
<a name="ln711">	default:		sprintf(nbuf, &quot;?0x%lx?&quot;, (u_long)option);</a>
<a name="ln712">				return (nbuf);</a>
<a name="ln713">	}</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">/*%</a>
<a name="ln717"> * Return a mnemonic for a time to live.</a>
<a name="ln718"> */</a>
<a name="ln719">const char *</a>
<a name="ln720">p_time(u_int32_t value) {</a>
<a name="ln721">	char *nbuf = p_time_nbuf;</a>
<a name="ln722"> </a>
<a name="ln723">	if (ns_format_ttl((u_long)value, nbuf, sizeof nbuf) &lt; 0)</a>
<a name="ln724">		sprintf(nbuf, &quot;%u&quot;, value);</a>
<a name="ln725">	return (nbuf);</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">/*%</a>
<a name="ln729"> * Return a string for the rcode.</a>
<a name="ln730"> */</a>
<a name="ln731">const char *</a>
<a name="ln732">p_rcode(int rcode) {</a>
<a name="ln733">	return (sym_ntos(__p_rcode_syms, rcode, (int *)0));</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">/*%</a>
<a name="ln737"> * Return a string for a res_sockaddr_union.</a>
<a name="ln738"> */</a>
<a name="ln739">const char *</a>
<a name="ln740">p_sockun(union res_sockaddr_union u, char *buf, size_t size) {</a>
<a name="ln741">	char ret[sizeof &quot;ffff:ffff:ffff:ffff:ffff:ffff:123.123.123.123&quot;];</a>
<a name="ln742"> </a>
<a name="ln743">	switch (u.sin.sin_family) {</a>
<a name="ln744">	case AF_INET:</a>
<a name="ln745">		inet_ntop(AF_INET, &amp;u.sin.sin_addr, ret, (socklen_t)sizeof ret);</a>
<a name="ln746">		break;</a>
<a name="ln747">#ifdef HAS_INET6_STRUCTS</a>
<a name="ln748">	case AF_INET6:</a>
<a name="ln749">		inet_ntop(AF_INET6, &amp;u.sin6.sin6_addr, ret, sizeof ret);</a>
<a name="ln750">		break;</a>
<a name="ln751">#endif</a>
<a name="ln752">	default:</a>
<a name="ln753">		sprintf(ret, &quot;[af%d]&quot;, u.sin.sin_family);</a>
<a name="ln754">		break;</a>
<a name="ln755">	}</a>
<a name="ln756">	if (size &gt; 0U) {</a>
<a name="ln757">		strncpy(buf, ret, size - 1);</a>
<a name="ln758">		buf[size - 1] = '0';</a>
<a name="ln759">	}</a>
<a name="ln760">	return (buf);</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">/*%</a>
<a name="ln764"> * routines to convert between on-the-wire RR format and zone file format.</a>
<a name="ln765"> * Does not contain conversion to/from decimal degrees; divide or multiply</a>
<a name="ln766"> * by 60*60*1000 for that.</a>
<a name="ln767"> */</a>
<a name="ln768"> </a>
<a name="ln769">static unsigned int poweroften[10] = {1, 10, 100, 1000, 10000, 100000,</a>
<a name="ln770">				      1000000,10000000,100000000,1000000000};</a>
<a name="ln771"> </a>
<a name="ln772">/*% takes an XeY precision/size value, returns a string representation. */</a>
<a name="ln773">static const char *</a>
<a name="ln774">precsize_ntoa(u_int32_t prec)</a>
<a name="ln775">{</a>
<a name="ln776">	char *retbuf = precsize_ntoa_retbuf;</a>
<a name="ln777">	unsigned long val;</a>
<a name="ln778">	int mantissa, exponent;</a>
<a name="ln779"> </a>
<a name="ln780">	mantissa = (int)((prec &gt;&gt; 4) &amp; 0x0f) % 10;</a>
<a name="ln781">	exponent = (int)((prec &gt;&gt; 0) &amp; 0x0f) % 10;</a>
<a name="ln782"> </a>
<a name="ln783">	val = mantissa * poweroften[exponent];</a>
<a name="ln784"> </a>
<a name="ln785">	(void) sprintf(retbuf, &quot;%lu.%.2lu&quot;, val/100, val%100);</a>
<a name="ln786">	return (retbuf);</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">/*% converts ascii size/precision X * 10**Y(cm) to 0xXY.  moves pointer.  */</a>
<a name="ln790">static u_int8_t</a>
<a name="ln791">precsize_aton(const char **strptr) {</a>
<a name="ln792">	unsigned int mval = 0, cmval = 0;</a>
<a name="ln793">	u_int8_t retval = 0;</a>
<a name="ln794">	const char *cp;</a>
<a name="ln795">	int exponent;</a>
<a name="ln796">	int mantissa;</a>
<a name="ln797"> </a>
<a name="ln798">	cp = *strptr;</a>
<a name="ln799"> </a>
<a name="ln800">	while (isdigit((unsigned char)*cp))</a>
<a name="ln801">		mval = mval * 10 + (*cp++ - '0');</a>
<a name="ln802"> </a>
<a name="ln803">	if (*cp == '.') {		/*%&lt; centimeters */</a>
<a name="ln804">		cp++;</a>
<a name="ln805">		if (isdigit((unsigned char)*cp)) {</a>
<a name="ln806">			cmval = (*cp++ - '0') * 10;</a>
<a name="ln807">			if (isdigit((unsigned char)*cp)) {</a>
<a name="ln808">				cmval += (*cp++ - '0');</a>
<a name="ln809">			}</a>
<a name="ln810">		}</a>
<a name="ln811">	}</a>
<a name="ln812">	cmval = (mval * 100) + cmval;</a>
<a name="ln813"> </a>
<a name="ln814">	for (exponent = 0; exponent &lt; 9; exponent++)</a>
<a name="ln815">		if (cmval &lt; poweroften[exponent+1])</a>
<a name="ln816">			break;</a>
<a name="ln817"> </a>
<a name="ln818">	mantissa = cmval / poweroften[exponent];</a>
<a name="ln819">	if (mantissa &gt; 9)</a>
<a name="ln820">		mantissa = 9;</a>
<a name="ln821"> </a>
<a name="ln822">	retval = (mantissa &lt;&lt; 4) | exponent;</a>
<a name="ln823"> </a>
<a name="ln824">	*strptr = cp;</a>
<a name="ln825"> </a>
<a name="ln826">	return (retval);</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">/*% converts ascii lat/lon to unsigned encoded 32-bit number.  moves pointer. */</a>
<a name="ln830">static u_int32_t</a>
<a name="ln831">latlon2ul(const char **latlonstrptr, int *which) {</a>
<a name="ln832">	const char *cp;</a>
<a name="ln833">	u_int32_t retval;</a>
<a name="ln834">	int deg = 0, min = 0, secs = 0, secsfrac = 0;</a>
<a name="ln835"> </a>
<a name="ln836">	cp = *latlonstrptr;</a>
<a name="ln837"> </a>
<a name="ln838">	while (isdigit((unsigned char)*cp))</a>
<a name="ln839">		deg = deg * 10 + (*cp++ - '0');</a>
<a name="ln840"> </a>
<a name="ln841">	while (isspace((unsigned char)*cp))</a>
<a name="ln842">		cp++;</a>
<a name="ln843"> </a>
<a name="ln844">	if (!(isdigit((unsigned char)*cp)))</a>
<a name="ln845">		goto fndhemi;</a>
<a name="ln846"> </a>
<a name="ln847">	while (isdigit((unsigned char)*cp))</a>
<a name="ln848">		min = min * 10 + (*cp++ - '0');</a>
<a name="ln849"> </a>
<a name="ln850">	while (isspace((unsigned char)*cp))</a>
<a name="ln851">		cp++;</a>
<a name="ln852"> </a>
<a name="ln853">	if (!(isdigit((unsigned char)*cp)))</a>
<a name="ln854">		goto fndhemi;</a>
<a name="ln855"> </a>
<a name="ln856">	while (isdigit((unsigned char)*cp))</a>
<a name="ln857">		secs = secs * 10 + (*cp++ - '0');</a>
<a name="ln858"> </a>
<a name="ln859">	if (*cp == '.') {		/*%&lt; decimal seconds */</a>
<a name="ln860">		cp++;</a>
<a name="ln861">		if (isdigit((unsigned char)*cp)) {</a>
<a name="ln862">			secsfrac = (*cp++ - '0') * 100;</a>
<a name="ln863">			if (isdigit((unsigned char)*cp)) {</a>
<a name="ln864">				secsfrac += (*cp++ - '0') * 10;</a>
<a name="ln865">				if (isdigit((unsigned char)*cp)) {</a>
<a name="ln866">					secsfrac += (*cp++ - '0');</a>
<a name="ln867">				}</a>
<a name="ln868">			}</a>
<a name="ln869">		}</a>
<a name="ln870">	}</a>
<a name="ln871"> </a>
<a name="ln872">	while (!isspace((unsigned char)*cp))	/*%&lt; if any trailing garbage */</a>
<a name="ln873">		cp++;</a>
<a name="ln874"> </a>
<a name="ln875">	while (isspace((unsigned char)*cp))</a>
<a name="ln876">		cp++;</a>
<a name="ln877"> </a>
<a name="ln878"> fndhemi:</a>
<a name="ln879">	switch (*cp) {</a>
<a name="ln880">	case 'N': case 'n':</a>
<a name="ln881">	case 'E': case 'e':</a>
<a name="ln882">		retval = ((unsigned)1&lt;&lt;31)</a>
<a name="ln883">			+ (((((deg * 60) + min) * 60) + secs) * 1000)</a>
<a name="ln884">			+ secsfrac;</a>
<a name="ln885">		break;</a>
<a name="ln886">	case 'S': case 's':</a>
<a name="ln887">	case 'W': case 'w':</a>
<a name="ln888">		retval = ((unsigned)1&lt;&lt;31)</a>
<a name="ln889">			- (((((deg * 60) + min) * 60) + secs) * 1000)</a>
<a name="ln890">			- secsfrac;</a>
<a name="ln891">		break;</a>
<a name="ln892">	default:</a>
<a name="ln893">		retval = 0;	/*%&lt; invalid value -- indicates error */</a>
<a name="ln894">		break;</a>
<a name="ln895">	}</a>
<a name="ln896"> </a>
<a name="ln897">	switch (*cp) {</a>
<a name="ln898">	case 'N': case 'n':</a>
<a name="ln899">	case 'S': case 's':</a>
<a name="ln900">		*which = 1;	/*%&lt; latitude */</a>
<a name="ln901">		break;</a>
<a name="ln902">	case 'E': case 'e':</a>
<a name="ln903">	case 'W': case 'w':</a>
<a name="ln904">		*which = 2;	/*%&lt; longitude */</a>
<a name="ln905">		break;</a>
<a name="ln906">	default:</a>
<a name="ln907">		*which = 0;	/*%&lt; error */</a>
<a name="ln908">		break;</a>
<a name="ln909">	}</a>
<a name="ln910"> </a>
<a name="ln911">	cp++;			/*%&lt; skip the hemisphere */</a>
<a name="ln912">	while (!isspace((unsigned char)*cp))	/*%&lt; if any trailing garbage */</a>
<a name="ln913">		cp++;</a>
<a name="ln914"> </a>
<a name="ln915">	while (isspace((unsigned char)*cp))	/*%&lt; move to next field */</a>
<a name="ln916">		cp++;</a>
<a name="ln917"> </a>
<a name="ln918">	*latlonstrptr = cp;</a>
<a name="ln919"> </a>
<a name="ln920">	return (retval);</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923">/*%</a>
<a name="ln924"> * converts a zone file representation in a string to an RDATA on-the-wire</a>
<a name="ln925"> * representation. */</a>
<a name="ln926">int</a>
<a name="ln927">loc_aton(const char *ascii, u_char *binary)</a>
<a name="ln928">{</a>
<a name="ln929">	const char *cp, *maxcp;</a>
<a name="ln930">	u_char *bcp;</a>
<a name="ln931"> </a>
<a name="ln932">	u_int32_t latit = 0, longit = 0, alt = 0;</a>
<a name="ln933">	u_int32_t lltemp1 = 0, lltemp2 = 0;</a>
<a name="ln934">	int altmeters = 0, altfrac = 0, altsign = 1;</a>
<a name="ln935">	u_int8_t hp = 0x16;	/*%&lt; default = 1e6 cm = 10000.00m = 10km */</a>
<a name="ln936">	u_int8_t vp = 0x13;	/*%&lt; default = 1e3 cm = 10.00m */</a>
<a name="ln937">	u_int8_t siz = 0x12;	/*%&lt; default = 1e2 cm = 1.00m */</a>
<a name="ln938">	int which1 = 0, which2 = 0;</a>
<a name="ln939"> </a>
<a name="ln940">	cp = ascii;</a>
<a name="ln941">	maxcp = cp + strlen(ascii);</a>
<a name="ln942"> </a>
<a name="ln943">	lltemp1 = latlon2ul(&amp;cp, &amp;which1);</a>
<a name="ln944"> </a>
<a name="ln945">	lltemp2 = latlon2ul(&amp;cp, &amp;which2);</a>
<a name="ln946"> </a>
<a name="ln947">	switch (which1 + which2) {</a>
<a name="ln948">	case 3:			/*%&lt; 1 + 2, the only valid combination */</a>
<a name="ln949">		if ((which1 == 1) &amp;&amp; (which2 == 2)) { /*%&lt; normal case */</a>
<a name="ln950">			latit = lltemp1;</a>
<a name="ln951">			longit = lltemp2;</a>
<a name="ln952">		} else if ((which1 == 2) &amp;&amp; (which2 == 1)) { /*%&lt; reversed */</a>
<a name="ln953">			longit = lltemp1;</a>
<a name="ln954">			latit = lltemp2;</a>
<a name="ln955">		} else {	/*%&lt; some kind of brokenness */</a>
<a name="ln956">			return (0);</a>
<a name="ln957">		}</a>
<a name="ln958">		break;</a>
<a name="ln959">	default:		/*%&lt; we didn't get one of each */</a>
<a name="ln960">		return (0);</a>
<a name="ln961">	}</a>
<a name="ln962"> </a>
<a name="ln963">	/* altitude */</a>
<a name="ln964">	if (*cp == '-') {</a>
<a name="ln965">		altsign = -1;</a>
<a name="ln966">		cp++;</a>
<a name="ln967">	}</a>
<a name="ln968"> </a>
<a name="ln969">	if (*cp == '+')</a>
<a name="ln970">		cp++;</a>
<a name="ln971"> </a>
<a name="ln972">	while (isdigit((unsigned char)*cp))</a>
<a name="ln973">		altmeters = altmeters * 10 + (*cp++ - '0');</a>
<a name="ln974"> </a>
<a name="ln975">	if (*cp == '.') {		/*%&lt; decimal meters */</a>
<a name="ln976">		cp++;</a>
<a name="ln977">		if (isdigit((unsigned char)*cp)) {</a>
<a name="ln978">			altfrac = (*cp++ - '0') * 10;</a>
<a name="ln979">			if (isdigit((unsigned char)*cp)) {</a>
<a name="ln980">				altfrac += (*cp++ - '0');</a>
<a name="ln981">			}</a>
<a name="ln982">		}</a>
<a name="ln983">	}</a>
<a name="ln984"> </a>
<a name="ln985">	alt = (10000000 + (altsign * (altmeters * 100 + altfrac)));</a>
<a name="ln986"> </a>
<a name="ln987">	while (!isspace((unsigned char)*cp) &amp;&amp; (cp &lt; maxcp)) /*%&lt; if trailing garbage or m */</a>
<a name="ln988">		cp++;</a>
<a name="ln989"> </a>
<a name="ln990">	while (isspace((unsigned char)*cp) &amp;&amp; (cp &lt; maxcp))</a>
<a name="ln991">		cp++;</a>
<a name="ln992"> </a>
<a name="ln993">	if (cp &gt;= maxcp)</a>
<a name="ln994">		goto defaults;</a>
<a name="ln995"> </a>
<a name="ln996">	siz = precsize_aton(&amp;cp);</a>
<a name="ln997"> </a>
<a name="ln998">	while (!isspace((unsigned char)*cp) &amp;&amp; (cp &lt; maxcp))	/*%&lt; if trailing garbage or m */</a>
<a name="ln999">		cp++;</a>
<a name="ln1000"> </a>
<a name="ln1001">	while (isspace((unsigned char)*cp) &amp;&amp; (cp &lt; maxcp))</a>
<a name="ln1002">		cp++;</a>
<a name="ln1003"> </a>
<a name="ln1004">	if (cp &gt;= maxcp)</a>
<a name="ln1005">		goto defaults;</a>
<a name="ln1006"> </a>
<a name="ln1007">	hp = precsize_aton(&amp;cp);</a>
<a name="ln1008"> </a>
<a name="ln1009">	while (!isspace((unsigned char)*cp) &amp;&amp; (cp &lt; maxcp))	/*%&lt; if trailing garbage or m */</a>
<a name="ln1010">		cp++;</a>
<a name="ln1011"> </a>
<a name="ln1012">	while (isspace((unsigned char)*cp) &amp;&amp; (cp &lt; maxcp))</a>
<a name="ln1013">		cp++;</a>
<a name="ln1014"> </a>
<a name="ln1015">	if (cp &gt;= maxcp)</a>
<a name="ln1016">		goto defaults;</a>
<a name="ln1017"> </a>
<a name="ln1018">	vp = precsize_aton(&amp;cp);</a>
<a name="ln1019"> </a>
<a name="ln1020"> defaults:</a>
<a name="ln1021"> </a>
<a name="ln1022">	bcp = binary;</a>
<a name="ln1023">	*bcp++ = (u_int8_t) 0;	/*%&lt; version byte */</a>
<a name="ln1024">	*bcp++ = siz;</a>
<a name="ln1025">	*bcp++ = hp;</a>
<a name="ln1026">	*bcp++ = vp;</a>
<a name="ln1027">	PUTLONG(latit,bcp);</a>
<a name="ln1028">	PUTLONG(longit,bcp);</a>
<a name="ln1029">	PUTLONG(alt,bcp);</a>
<a name="ln1030"> </a>
<a name="ln1031">	return (16);		/*%&lt; size of RR in octets */</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">/*% takes an on-the-wire LOC RR and formats it in a human readable format. */</a>
<a name="ln1035">const char *</a>
<a name="ln1036">loc_ntoa(const u_char *binary, char *ascii)</a>
<a name="ln1037">{</a>
<a name="ln1038">	static const char *error = &quot;?&quot;;</a>
<a name="ln1039">	static char tmpbuf[sizeof</a>
<a name="ln1040">&quot;1000 60 60.000 N 1000 60 60.000 W -12345678.00m 90000000.00m 90000000.00m 90000000.00m&quot;];</a>
<a name="ln1041">	const u_char *cp = binary;</a>
<a name="ln1042"> </a>
<a name="ln1043">	int latdeg, latmin, latsec, latsecfrac;</a>
<a name="ln1044">	int longdeg, longmin, longsec, longsecfrac;</a>
<a name="ln1045">	char northsouth, eastwest;</a>
<a name="ln1046">	const char *altsign;</a>
<a name="ln1047">	int altmeters, altfrac;</a>
<a name="ln1048"> </a>
<a name="ln1049">	const u_int32_t referencealt = 100000 * 100;</a>
<a name="ln1050"> </a>
<a name="ln1051">	int32_t latval, longval, altval;</a>
<a name="ln1052">	u_int32_t templ;</a>
<a name="ln1053">	u_int8_t sizeval, hpval, vpval, versionval;</a>
<a name="ln1054"> </a>
<a name="ln1055">	char *sizestr, *hpstr, *vpstr;</a>
<a name="ln1056"> </a>
<a name="ln1057">	versionval = *cp++;</a>
<a name="ln1058"> </a>
<a name="ln1059">	if (ascii == NULL)</a>
<a name="ln1060">		ascii = tmpbuf;</a>
<a name="ln1061"> </a>
<a name="ln1062">	if (versionval) {</a>
<a name="ln1063">		(void) sprintf(ascii, &quot;; error: unknown LOC RR version&quot;);</a>
<a name="ln1064">		return (ascii);</a>
<a name="ln1065">	}</a>
<a name="ln1066"> </a>
<a name="ln1067">	sizeval = *cp++;</a>
<a name="ln1068"> </a>
<a name="ln1069">	hpval = *cp++;</a>
<a name="ln1070">	vpval = *cp++;</a>
<a name="ln1071"> </a>
<a name="ln1072">	GETLONG(templ, cp);</a>
<a name="ln1073">	latval = (templ - ((unsigned)1&lt;&lt;31));</a>
<a name="ln1074"> </a>
<a name="ln1075">	GETLONG(templ, cp);</a>
<a name="ln1076">	longval = (templ - ((unsigned)1&lt;&lt;31));</a>
<a name="ln1077"> </a>
<a name="ln1078">	GETLONG(templ, cp);</a>
<a name="ln1079">	if (templ &lt; referencealt) { /*%&lt; below WGS 84 spheroid */</a>
<a name="ln1080">		altval = referencealt - templ;</a>
<a name="ln1081">		altsign = &quot;-&quot;;</a>
<a name="ln1082">	} else {</a>
<a name="ln1083">		altval = templ - referencealt;</a>
<a name="ln1084">		altsign = &quot;&quot;;</a>
<a name="ln1085">	}</a>
<a name="ln1086"> </a>
<a name="ln1087">	if (latval &lt; 0) {</a>
<a name="ln1088">		northsouth = 'S';</a>
<a name="ln1089">		latval = -latval;</a>
<a name="ln1090">	} else</a>
<a name="ln1091">		northsouth = 'N';</a>
<a name="ln1092"> </a>
<a name="ln1093">	latsecfrac = latval % 1000;</a>
<a name="ln1094">	latval = latval / 1000;</a>
<a name="ln1095">	latsec = latval % 60;</a>
<a name="ln1096">	latval = latval / 60;</a>
<a name="ln1097">	latmin = latval % 60;</a>
<a name="ln1098">	latval = latval / 60;</a>
<a name="ln1099">	latdeg = latval;</a>
<a name="ln1100"> </a>
<a name="ln1101">	if (longval &lt; 0) {</a>
<a name="ln1102">		eastwest = 'W';</a>
<a name="ln1103">		longval = -longval;</a>
<a name="ln1104">	} else</a>
<a name="ln1105">		eastwest = 'E';</a>
<a name="ln1106"> </a>
<a name="ln1107">	longsecfrac = longval % 1000;</a>
<a name="ln1108">	longval = longval / 1000;</a>
<a name="ln1109">	longsec = longval % 60;</a>
<a name="ln1110">	longval = longval / 60;</a>
<a name="ln1111">	longmin = longval % 60;</a>
<a name="ln1112">	longval = longval / 60;</a>
<a name="ln1113">	longdeg = longval;</a>
<a name="ln1114"> </a>
<a name="ln1115">	altfrac = altval % 100;</a>
<a name="ln1116">	altmeters = (altval / 100);</a>
<a name="ln1117"> </a>
<a name="ln1118">	sizestr = strdup(precsize_ntoa((u_int32_t)sizeval));</a>
<a name="ln1119">	hpstr = strdup(precsize_ntoa((u_int32_t)hpval));</a>
<a name="ln1120">	vpstr = strdup(precsize_ntoa((u_int32_t)vpval));</a>
<a name="ln1121"> </a>
<a name="ln1122">	sprintf(ascii,</a>
<a name="ln1123">	    &quot;%d %.2d %.2d.%.3d %c %d %.2d %.2d.%.3d %c %s%d.%.2dm %sm %sm %sm&quot;,</a>
<a name="ln1124">		latdeg, latmin, latsec, latsecfrac, northsouth,</a>
<a name="ln1125">		longdeg, longmin, longsec, longsecfrac, eastwest,</a>
<a name="ln1126">		altsign, altmeters, altfrac,</a>
<a name="ln1127">		(sizestr != NULL) ? sizestr : error,</a>
<a name="ln1128">		(hpstr != NULL) ? hpstr : error,</a>
<a name="ln1129">		(vpstr != NULL) ? vpstr : error);</a>
<a name="ln1130"> </a>
<a name="ln1131">	if (sizestr != NULL)</a>
<a name="ln1132">		free(sizestr);</a>
<a name="ln1133">	if (hpstr != NULL)</a>
<a name="ln1134">		free(hpstr);</a>
<a name="ln1135">	if (vpstr != NULL)</a>
<a name="ln1136">		free(vpstr);</a>
<a name="ln1137"> </a>
<a name="ln1138">	return (ascii);</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141"> </a>
<a name="ln1142">/*% Return the number of DNS hierarchy levels in the name. */</a>
<a name="ln1143">int</a>
<a name="ln1144">dn_count_labels(const char *name) {</a>
<a name="ln1145">	size_t len, i, count;</a>
<a name="ln1146"> </a>
<a name="ln1147">	len = strlen(name);</a>
<a name="ln1148">	for (i = 0, count = 0; i &lt; len; i++) {</a>
<a name="ln1149">		/* XXX need to check for \. or use named's nlabels(). */</a>
<a name="ln1150">		if (name[i] == '.')</a>
<a name="ln1151">			count++;</a>
<a name="ln1152">	}</a>
<a name="ln1153"> </a>
<a name="ln1154">	/* don't count initial wildcard */</a>
<a name="ln1155">	if (name[0] == '*')</a>
<a name="ln1156">		if (count)</a>
<a name="ln1157">			count--;</a>
<a name="ln1158"> </a>
<a name="ln1159">	/* don't count the null label for root. */</a>
<a name="ln1160">	/* if terminating '.' not found, must adjust */</a>
<a name="ln1161">	/* count to include last label */</a>
<a name="ln1162">	if (len &gt; 0 &amp;&amp; name[len-1] != '.')</a>
<a name="ln1163">		count++;</a>
<a name="ln1164">	assert(count &lt;= (size_t)INT_MAX);</a>
<a name="ln1165">	return (int)count;</a>
<a name="ln1166">}</a>
<a name="ln1167"> </a>
<a name="ln1168">/*%</a>
<a name="ln1169"> * Make dates expressed in seconds-since-Jan-1-1970 easy to read.</a>
<a name="ln1170"> * SIG records are required to be printed like this, by the Secure DNS RFC.</a>
<a name="ln1171"> */</a>
<a name="ln1172">char *</a>
<a name="ln1173">p_secstodate (u_long secs) {</a>
<a name="ln1174">	/* XXX nonreentrant */</a>
<a name="ln1175">	char *output = p_secstodate_output;</a>
<a name="ln1176">	time_t myclock = secs;</a>
<a name="ln1177">	struct tm *mytime;</a>
<a name="ln1178">#ifdef HAVE_TIME_R</a>
<a name="ln1179">	struct tm res;</a>
<a name="ln1180">	</a>
<a name="ln1181">	mytime = gmtime_r(&amp;myclock, &amp;res);</a>
<a name="ln1182">#else</a>
<a name="ln1183">	mytime = gmtime(&amp;myclock);</a>
<a name="ln1184">#endif</a>
<a name="ln1185">	mytime-&gt;tm_year += 1900;</a>
<a name="ln1186">	mytime-&gt;tm_mon += 1;</a>
<a name="ln1187">	sprintf(output, &quot;%04d%02d%02d%02d%02d%02d&quot;,</a>
<a name="ln1188">		mytime-&gt;tm_year, mytime-&gt;tm_mon, mytime-&gt;tm_mday,</a>
<a name="ln1189">		mytime-&gt;tm_hour, mytime-&gt;tm_min, mytime-&gt;tm_sec);</a>
<a name="ln1190">	return (output);</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">u_int16_t</a>
<a name="ln1194">res_nametoclass(const char *buf, int *successp) {</a>
<a name="ln1195">	unsigned long result;</a>
<a name="ln1196">	char *endptr;</a>
<a name="ln1197">	int success;</a>
<a name="ln1198"> </a>
<a name="ln1199">	result = sym_ston(__p_class_syms, buf, &amp;success);</a>
<a name="ln1200">	if (success)</a>
<a name="ln1201">		goto done;</a>
<a name="ln1202"> </a>
<a name="ln1203">	if (strncasecmp(buf, &quot;CLASS&quot;, 5) != 0 ||</a>
<a name="ln1204">	    !isdigit((unsigned char)buf[5]))</a>
<a name="ln1205">		goto done;</a>
<a name="ln1206">	errno = 0;</a>
<a name="ln1207">	result = strtoul(buf + 5, &amp;endptr, 10);</a>
<a name="ln1208">	if (errno == 0 &amp;&amp; *endptr == '\0' &amp;&amp; result &lt;= 0xffffU)</a>
<a name="ln1209">		success = 1;</a>
<a name="ln1210"> done:</a>
<a name="ln1211">	if (successp)</a>
<a name="ln1212">		*successp = success;</a>
<a name="ln1213">	return (u_int16_t)(result);</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">u_int16_t</a>
<a name="ln1217">res_nametotype(const char *buf, int *successp) {</a>
<a name="ln1218">	unsigned long result;</a>
<a name="ln1219">	char *endptr;</a>
<a name="ln1220">	int success;</a>
<a name="ln1221"> </a>
<a name="ln1222">	result = sym_ston(__p_type_syms, buf, &amp;success);</a>
<a name="ln1223">	if (success)</a>
<a name="ln1224">		goto done;</a>
<a name="ln1225"> </a>
<a name="ln1226">	if (strncasecmp(buf, &quot;type&quot;, 4) != 0 ||</a>
<a name="ln1227">	    !isdigit((unsigned char)buf[4]))</a>
<a name="ln1228">		goto done;</a>
<a name="ln1229">	errno = 0;</a>
<a name="ln1230">	result = strtoul(buf + 4, &amp;endptr, 10);</a>
<a name="ln1231">	if (errno == 0 &amp;&amp; *endptr == '\0' &amp;&amp; result &lt;= 0xffffU)</a>
<a name="ln1232">		success = 1;</a>
<a name="ln1233"> done:</a>
<a name="ln1234">	if (successp)</a>
<a name="ln1235">		*successp = success;</a>
<a name="ln1236">	return (u_int16_t)(result);</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239">/*! \file */</a>

</code></pre>
<div class="balloon" rel="723"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v579/" target="_blank">V579</a> The __ns_format_ttl function receives the pointer and its size as arguments. It is possibly a mistake. Inspect the third argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
