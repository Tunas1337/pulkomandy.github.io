
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Journal.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2017, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * This file may be used under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">//! Transaction and logging</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;Journal.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;Debug.h&quot;</a>
<a name="ln13">#include &quot;Inode.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15"> </a>
<a name="ln16">struct run_array {</a>
<a name="ln17">	int32		count;</a>
<a name="ln18">	int32		max_runs;</a>
<a name="ln19">	block_run	runs[0];</a>
<a name="ln20"> </a>
<a name="ln21">	void Init(int32 blockSize);</a>
<a name="ln22">	void Insert(block_run&amp; run);</a>
<a name="ln23"> </a>
<a name="ln24">	int32 CountRuns() const { return BFS_ENDIAN_TO_HOST_INT32(count); }</a>
<a name="ln25">	int32 MaxRuns() const { return BFS_ENDIAN_TO_HOST_INT32(max_runs) - 1; }</a>
<a name="ln26">		// that -1 accounts for an off-by-one error in Be's BFS implementation</a>
<a name="ln27">	const block_run&amp; RunAt(int32 i) const { return runs[i]; }</a>
<a name="ln28"> </a>
<a name="ln29">	static int32 MaxRuns(int32 blockSize);</a>
<a name="ln30"> </a>
<a name="ln31">private:</a>
<a name="ln32">	static int _Compare(block_run&amp; a, block_run&amp; b);</a>
<a name="ln33">	int32 _FindInsertionIndex(block_run&amp; run);</a>
<a name="ln34">};</a>
<a name="ln35"> </a>
<a name="ln36">class RunArrays {</a>
<a name="ln37">public:</a>
<a name="ln38">							RunArrays(Journal* journal);</a>
<a name="ln39">							~RunArrays();</a>
<a name="ln40"> </a>
<a name="ln41">			status_t		Insert(off_t blockNumber);</a>
<a name="ln42"> </a>
<a name="ln43">			run_array*		ArrayAt(int32 i) { return fArrays.Array()[i]; }</a>
<a name="ln44">			int32			CountArrays() const { return fArrays.CountItems(); }</a>
<a name="ln45"> </a>
<a name="ln46">			uint32			CountBlocks() const { return fBlockCount; }</a>
<a name="ln47">			uint32			LogEntryLength() const</a>
<a name="ln48">								{ return CountBlocks() + CountArrays(); }</a>
<a name="ln49"> </a>
<a name="ln50">			int32			MaxArrayLength();</a>
<a name="ln51"> </a>
<a name="ln52">private:</a>
<a name="ln53">			status_t		_AddArray();</a>
<a name="ln54">			bool			_ContainsRun(block_run&amp; run);</a>
<a name="ln55">			bool			_AddRun(block_run&amp; run);</a>
<a name="ln56"> </a>
<a name="ln57">			Journal*		fJournal;</a>
<a name="ln58">			uint32			fBlockCount;</a>
<a name="ln59">			Stack&lt;run_array*&gt; fArrays;</a>
<a name="ln60">			run_array*		fLastArray;</a>
<a name="ln61">};</a>
<a name="ln62"> </a>
<a name="ln63">class LogEntry : public DoublyLinkedListLinkImpl&lt;LogEntry&gt; {</a>
<a name="ln64">public:</a>
<a name="ln65">							LogEntry(Journal* journal, uint32 logStart,</a>
<a name="ln66">								uint32 length);</a>
<a name="ln67">							~LogEntry();</a>
<a name="ln68"> </a>
<a name="ln69">			uint32			Start() const { return fStart; }</a>
<a name="ln70">			uint32			Length() const { return fLength; }</a>
<a name="ln71"> </a>
<a name="ln72">#ifdef BFS_DEBUGGER_COMMANDS</a>
<a name="ln73">			void			SetTransactionID(int32 id) { fTransactionID = id; }</a>
<a name="ln74">			int32			TransactionID() const { return fTransactionID; }</a>
<a name="ln75">#endif</a>
<a name="ln76"> </a>
<a name="ln77">			Journal*		GetJournal() { return fJournal; }</a>
<a name="ln78"> </a>
<a name="ln79">private:</a>
<a name="ln80">			Journal*		fJournal;</a>
<a name="ln81">			uint32			fStart;</a>
<a name="ln82">			uint32			fLength;</a>
<a name="ln83">#ifdef BFS_DEBUGGER_COMMANDS</a>
<a name="ln84">			int32			fTransactionID;</a>
<a name="ln85">#endif</a>
<a name="ln86">};</a>
<a name="ln87"> </a>
<a name="ln88"> </a>
<a name="ln89">#if BFS_TRACING &amp;&amp; !defined(FS_SHELL) &amp;&amp; !defined(_BOOT_MODE)</a>
<a name="ln90">namespace BFSJournalTracing {</a>
<a name="ln91"> </a>
<a name="ln92">class LogEntry : public AbstractTraceEntry {</a>
<a name="ln93">public:</a>
<a name="ln94">	LogEntry(::LogEntry* entry, off_t logPosition, bool started)</a>
<a name="ln95">		:</a>
<a name="ln96">		fEntry(entry),</a>
<a name="ln97">#ifdef BFS_DEBUGGER_COMMANDS</a>
<a name="ln98">		fTransactionID(entry-&gt;TransactionID()),</a>
<a name="ln99">#endif</a>
<a name="ln100">		fStart(entry-&gt;Start()),</a>
<a name="ln101">		fLength(entry-&gt;Length()),</a>
<a name="ln102">		fLogPosition(logPosition),</a>
<a name="ln103">		fStarted(started)</a>
<a name="ln104">	{</a>
<a name="ln105">		Initialized();</a>
<a name="ln106">	}</a>
<a name="ln107"> </a>
<a name="ln108">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln109">	{</a>
<a name="ln110">#ifdef BFS_DEBUGGER_COMMANDS</a>
<a name="ln111">		out.Print(&quot;bfs:j:%s entry %p id %ld, start %lu, length %lu, log %s &quot;</a>
<a name="ln112">			&quot;%lu\n&quot;, fStarted ? &quot;Started&quot; : &quot;Written&quot;, fEntry,</a>
<a name="ln113">			fTransactionID, fStart, fLength,</a>
<a name="ln114">			fStarted ? &quot;end&quot; : &quot;start&quot;, fLogPosition);</a>
<a name="ln115">#else</a>
<a name="ln116">		out.Print(&quot;bfs:j:%s entry %p start %lu, length %lu, log %s %lu\n&quot;,</a>
<a name="ln117">			fStarted ? &quot;Started&quot; : &quot;Written&quot;, fEntry, fStart, fLength,</a>
<a name="ln118">			fStarted ? &quot;end&quot; : &quot;start&quot;, fLogPosition);</a>
<a name="ln119">#endif</a>
<a name="ln120">	}</a>
<a name="ln121"> </a>
<a name="ln122">private:</a>
<a name="ln123">	::LogEntry*	fEntry;</a>
<a name="ln124">#ifdef BFS_DEBUGGER_COMMANDS</a>
<a name="ln125">	int32		fTransactionID;</a>
<a name="ln126">#endif</a>
<a name="ln127">	uint32		fStart;</a>
<a name="ln128">	uint32		fLength;</a>
<a name="ln129">	uint32		fLogPosition;</a>
<a name="ln130">	bool		fStarted;</a>
<a name="ln131">};</a>
<a name="ln132"> </a>
<a name="ln133">}	// namespace BFSJournalTracing</a>
<a name="ln134"> </a>
<a name="ln135">#	define T(x) new(std::nothrow) BFSJournalTracing::x;</a>
<a name="ln136">#else</a>
<a name="ln137">#	define T(x) ;</a>
<a name="ln138">#endif</a>
<a name="ln139"> </a>
<a name="ln140"> </a>
<a name="ln141">//	#pragma mark -</a>
<a name="ln142"> </a>
<a name="ln143"> </a>
<a name="ln144">static void</a>
<a name="ln145">add_to_iovec(iovec* vecs, int32&amp; index, int32 max, const void* address,</a>
<a name="ln146">	size_t size)</a>
<a name="ln147">{</a>
<a name="ln148">	if (index &gt; 0 &amp;&amp; (addr_t)vecs[index - 1].iov_base</a>
<a name="ln149">			+ vecs[index - 1].iov_len == (addr_t)address) {</a>
<a name="ln150">		// the iovec can be combined with the previous one</a>
<a name="ln151">		vecs[index - 1].iov_len += size;</a>
<a name="ln152">		return;</a>
<a name="ln153">	}</a>
<a name="ln154"> </a>
<a name="ln155">	if (index == max)</a>
<a name="ln156">		panic(&quot;no more space for iovecs!&quot;);</a>
<a name="ln157"> </a>
<a name="ln158">	// we need to start a new iovec</a>
<a name="ln159">	vecs[index].iov_base = const_cast&lt;void*&gt;(address);</a>
<a name="ln160">	vecs[index].iov_len = size;</a>
<a name="ln161">	index++;</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164"> </a>
<a name="ln165">//	#pragma mark - LogEntry</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">LogEntry::LogEntry(Journal* journal, uint32 start, uint32 length)</a>
<a name="ln169">	:</a>
<a name="ln170">	fJournal(journal),</a>
<a name="ln171">	fStart(start),</a>
<a name="ln172">	fLength(length)</a>
<a name="ln173">{</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">LogEntry::~LogEntry()</a>
<a name="ln178">{</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182">//	#pragma mark - run_array</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">/*!	The run_array's size equals the block size of the BFS volume, so we</a>
<a name="ln186">	cannot use a (non-overridden) new.</a>
<a name="ln187">	This makes a freshly allocated run_array ready to run.</a>
<a name="ln188">*/</a>
<a name="ln189">void</a>
<a name="ln190">run_array::Init(int32 blockSize)</a>
<a name="ln191">{</a>
<a name="ln192">	memset(this, 0, blockSize);</a>
<a name="ln193">	count = 0;</a>
<a name="ln194">	max_runs = HOST_ENDIAN_TO_BFS_INT32(MaxRuns(blockSize));</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197"> </a>
<a name="ln198">/*!	Inserts the block_run into the array. You will have to make sure the</a>
<a name="ln199">	array is large enough to contain the entry before calling this function.</a>
<a name="ln200">*/</a>
<a name="ln201">void</a>
<a name="ln202">run_array::Insert(block_run&amp; run)</a>
<a name="ln203">{</a>
<a name="ln204">	int32 index = _FindInsertionIndex(run);</a>
<a name="ln205">	if (index == -1) {</a>
<a name="ln206">		// add to the end</a>
<a name="ln207">		runs[CountRuns()] = run;</a>
<a name="ln208">	} else {</a>
<a name="ln209">		// insert at index</a>
<a name="ln210">		memmove(&amp;runs[index + 1], &amp;runs[index],</a>
<a name="ln211">			(CountRuns() - index) * sizeof(off_t));</a>
<a name="ln212">		runs[index] = run;</a>
<a name="ln213">	}</a>
<a name="ln214"> </a>
<a name="ln215">	count = HOST_ENDIAN_TO_BFS_INT32(CountRuns() + 1);</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">/*static*/ int32</a>
<a name="ln220">run_array::MaxRuns(int32 blockSize)</a>
<a name="ln221">{</a>
<a name="ln222">	// For whatever reason, BFS restricts the maximum array size</a>
<a name="ln223">	uint32 maxCount = (blockSize - sizeof(run_array)) / sizeof(block_run);</a>
<a name="ln224">	if (maxCount &lt; 128)</a>
<a name="ln225">		return maxCount;</a>
<a name="ln226"> </a>
<a name="ln227">	return 127;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">/*static*/ int</a>
<a name="ln232">run_array::_Compare(block_run&amp; a, block_run&amp; b)</a>
<a name="ln233">{</a>
<a name="ln234">	int cmp = a.AllocationGroup() - b.AllocationGroup();</a>
<a name="ln235">	if (cmp == 0)</a>
<a name="ln236">		return a.Start() - b.Start();</a>
<a name="ln237"> </a>
<a name="ln238">	return cmp;</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241"> </a>
<a name="ln242">int32</a>
<a name="ln243">run_array::_FindInsertionIndex(block_run&amp; run)</a>
<a name="ln244">{</a>
<a name="ln245">	int32 min = 0, max = CountRuns() - 1;</a>
<a name="ln246">	int32 i = 0;</a>
<a name="ln247">	if (max &gt;= 8) {</a>
<a name="ln248">		while (min &lt;= max) {</a>
<a name="ln249">			i = (min + max) / 2;</a>
<a name="ln250"> </a>
<a name="ln251">			int cmp = _Compare(runs[i], run);</a>
<a name="ln252">			if (cmp &lt; 0)</a>
<a name="ln253">				min = i + 1;</a>
<a name="ln254">			else if (cmp &gt; 0)</a>
<a name="ln255">				max = i - 1;</a>
<a name="ln256">			else</a>
<a name="ln257">				return -1;</a>
<a name="ln258">		}</a>
<a name="ln259"> </a>
<a name="ln260">		if (_Compare(runs[i], run) &lt; 0)</a>
<a name="ln261">			i++;</a>
<a name="ln262">	} else {</a>
<a name="ln263">		for (; i &lt;= max; i++) {</a>
<a name="ln264">			if (_Compare(runs[i], run) &gt; 0)</a>
<a name="ln265">				break;</a>
<a name="ln266">		}</a>
<a name="ln267">		if (i == count)</a>
<a name="ln268">			return -1;</a>
<a name="ln269">	}</a>
<a name="ln270"> </a>
<a name="ln271">	return i;</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274"> </a>
<a name="ln275">//	#pragma mark - RunArrays</a>
<a name="ln276"> </a>
<a name="ln277"> </a>
<a name="ln278">RunArrays::RunArrays(Journal* journal)</a>
<a name="ln279">	:</a>
<a name="ln280">	fJournal(journal),</a>
<a name="ln281">	fBlockCount(0),</a>
<a name="ln282">	fArrays(),</a>
<a name="ln283">	fLastArray(NULL)</a>
<a name="ln284">{</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287"> </a>
<a name="ln288">RunArrays::~RunArrays()</a>
<a name="ln289">{</a>
<a name="ln290">	run_array* array;</a>
<a name="ln291">	while (fArrays.Pop(&amp;array))</a>
<a name="ln292">		free(array);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">bool</a>
<a name="ln297">RunArrays::_ContainsRun(block_run&amp; run)</a>
<a name="ln298">{</a>
<a name="ln299">	for (int32 i = 0; i &lt; CountArrays(); i++) {</a>
<a name="ln300">		run_array* array = ArrayAt(i);</a>
<a name="ln301"> </a>
<a name="ln302">		for (int32 j = 0; j &lt; array-&gt;CountRuns(); j++) {</a>
<a name="ln303">			block_run&amp; arrayRun = array-&gt;runs[j];</a>
<a name="ln304">			if (run.AllocationGroup() != arrayRun.AllocationGroup())</a>
<a name="ln305">				continue;</a>
<a name="ln306"> </a>
<a name="ln307">			if (run.Start() &gt;= arrayRun.Start()</a>
<a name="ln308">				&amp;&amp; run.Start() + run.Length()</a>
<a name="ln309">					&lt;= arrayRun.Start() + arrayRun.Length())</a>
<a name="ln310">				return true;</a>
<a name="ln311">		}</a>
<a name="ln312">	}</a>
<a name="ln313"> </a>
<a name="ln314">	return false;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">/*!	Adds the specified block_run into the array.</a>
<a name="ln319">	Note: it doesn't support overlapping - it must only be used</a>
<a name="ln320">	with block_runs of length 1!</a>
<a name="ln321">*/</a>
<a name="ln322">bool</a>
<a name="ln323">RunArrays::_AddRun(block_run&amp; run)</a>
<a name="ln324">{</a>
<a name="ln325">	ASSERT(run.length == 1);</a>
<a name="ln326"> </a>
<a name="ln327">	// Be's BFS log replay routine can only deal with block_runs of size 1</a>
<a name="ln328">	// A pity, isn't it? Too sad we have to be compatible.</a>
<a name="ln329"> </a>
<a name="ln330">	if (fLastArray == NULL || fLastArray-&gt;CountRuns() == fLastArray-&gt;MaxRuns())</a>
<a name="ln331">		return false;</a>
<a name="ln332"> </a>
<a name="ln333">	fLastArray-&gt;Insert(run);</a>
<a name="ln334">	fBlockCount++;</a>
<a name="ln335">	return true;</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338"> </a>
<a name="ln339">status_t</a>
<a name="ln340">RunArrays::_AddArray()</a>
<a name="ln341">{</a>
<a name="ln342">	int32 blockSize = fJournal-&gt;GetVolume()-&gt;BlockSize();</a>
<a name="ln343"> </a>
<a name="ln344">	run_array* array = (run_array*)malloc(blockSize);</a>
<a name="ln345">	if (array == NULL)</a>
<a name="ln346">		return B_NO_MEMORY;</a>
<a name="ln347"> </a>
<a name="ln348">	if (fArrays.Push(array) != B_OK) {</a>
<a name="ln349">		free(array);</a>
<a name="ln350">		return B_NO_MEMORY;</a>
<a name="ln351">	}</a>
<a name="ln352"> </a>
<a name="ln353">	array-&gt;Init(blockSize);</a>
<a name="ln354">	fLastArray = array;</a>
<a name="ln355">	return B_OK;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358"> </a>
<a name="ln359">status_t</a>
<a name="ln360">RunArrays::Insert(off_t blockNumber)</a>
<a name="ln361">{</a>
<a name="ln362">	Volume* volume = fJournal-&gt;GetVolume();</a>
<a name="ln363">	block_run run = volume-&gt;ToBlockRun(blockNumber);</a>
<a name="ln364"> </a>
<a name="ln365">	if (fLastArray != NULL) {</a>
<a name="ln366">		// check if the block is already in the array</a>
<a name="ln367">		if (_ContainsRun(run))</a>
<a name="ln368">			return B_OK;</a>
<a name="ln369">	}</a>
<a name="ln370"> </a>
<a name="ln371">	// insert block into array</a>
<a name="ln372"> </a>
<a name="ln373">	if (!_AddRun(run)) {</a>
<a name="ln374">		// array is full</a>
<a name="ln375">		if (_AddArray() != B_OK || !_AddRun(run))</a>
<a name="ln376">			return B_NO_MEMORY;</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	return B_OK;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382"> </a>
<a name="ln383">int32</a>
<a name="ln384">RunArrays::MaxArrayLength()</a>
<a name="ln385">{</a>
<a name="ln386">	int32 max = 0;</a>
<a name="ln387">	for (int32 i = 0; i &lt; CountArrays(); i++) {</a>
<a name="ln388">		if (ArrayAt(i)-&gt;CountRuns() &gt; max)</a>
<a name="ln389">			max = ArrayAt(i)-&gt;CountRuns();</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	return max;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395"> </a>
<a name="ln396">//	#pragma mark - Journal</a>
<a name="ln397"> </a>
<a name="ln398"> </a>
<a name="ln399">Journal::Journal(Volume* volume)</a>
<a name="ln400">	:</a>
<a name="ln401">	fVolume(volume),</a>
<a name="ln402">	fOwner(NULL),</a>
<a name="ln403">	fLogSize(volume-&gt;Log().Length()),</a>
<a name="ln404">	fMaxTransactionSize(fLogSize / 2 - 5),</a>
<a name="ln405">	fUsed(0),</a>
<a name="ln406">	fUnwrittenTransactions(0),</a>
<a name="ln407">	fHasSubtransaction(false),</a>
<a name="ln408">	fSeparateSubTransactions(false)</a>
<a name="ln409">{</a>
<a name="ln410">	recursive_lock_init(&amp;fLock, &quot;bfs journal&quot;);</a>
<a name="ln411">	mutex_init(&amp;fEntriesLock, &quot;bfs journal entries&quot;);</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">Journal::~Journal()</a>
<a name="ln416">{</a>
<a name="ln417">	FlushLogAndBlocks();</a>
<a name="ln418"> </a>
<a name="ln419">	recursive_lock_destroy(&amp;fLock);</a>
<a name="ln420">	mutex_destroy(&amp;fEntriesLock);</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423"> </a>
<a name="ln424">status_t</a>
<a name="ln425">Journal::InitCheck()</a>
<a name="ln426">{</a>
<a name="ln427">	return B_OK;</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430"> </a>
<a name="ln431">/*!	\brief Does a very basic consistency check of the run array.</a>
<a name="ln432">	It will check the maximum run count as well as if all of the runs fall</a>
<a name="ln433">	within a the volume.</a>
<a name="ln434">*/</a>
<a name="ln435">status_t</a>
<a name="ln436">Journal::_CheckRunArray(const run_array* array)</a>
<a name="ln437">{</a>
<a name="ln438">	int32 maxRuns = run_array::MaxRuns(fVolume-&gt;BlockSize()) - 1;</a>
<a name="ln439">		// the -1 works around an off-by-one bug in Be's BFS implementation,</a>
<a name="ln440">		// same as in run_array::MaxRuns()</a>
<a name="ln441">	if (array-&gt;MaxRuns() != maxRuns</a>
<a name="ln442">		|| array-&gt;CountRuns() &gt; maxRuns</a>
<a name="ln443">		|| array-&gt;CountRuns() &lt;= 0) {</a>
<a name="ln444">		dprintf(&quot;run count: %d, array max: %d, max runs: %d\n&quot;,</a>
<a name="ln445">			(int)array-&gt;CountRuns(), (int)array-&gt;MaxRuns(), (int)maxRuns);</a>
<a name="ln446">		FATAL((&quot;Log entry has broken header!\n&quot;));</a>
<a name="ln447">		return B_ERROR;</a>
<a name="ln448">	}</a>
<a name="ln449"> </a>
<a name="ln450">	for (int32 i = 0; i &lt; array-&gt;CountRuns(); i++) {</a>
<a name="ln451">		if (fVolume-&gt;ValidateBlockRun(array-&gt;RunAt(i)) != B_OK)</a>
<a name="ln452">			return B_ERROR;</a>
<a name="ln453">	}</a>
<a name="ln454"> </a>
<a name="ln455">	PRINT((&quot;Log entry has %ld entries\n&quot;, array-&gt;CountRuns()));</a>
<a name="ln456">	return B_OK;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">/*!	Replays an entry in the log.</a>
<a name="ln461">	\a _start points to the entry in the log, and will be bumped to the next</a>
<a name="ln462">	one if replaying succeeded.</a>
<a name="ln463">*/</a>
<a name="ln464">status_t</a>
<a name="ln465">Journal::_ReplayRunArray(int32* _start)</a>
<a name="ln466">{</a>
<a name="ln467">	PRINT((&quot;ReplayRunArray(start = %ld)\n&quot;, *_start));</a>
<a name="ln468"> </a>
<a name="ln469">	off_t logOffset = fVolume-&gt;ToBlock(fVolume-&gt;Log());</a>
<a name="ln470">	off_t firstBlockNumber = *_start % fLogSize;</a>
<a name="ln471"> </a>
<a name="ln472">	CachedBlock cachedArray(fVolume);</a>
<a name="ln473"> </a>
<a name="ln474">	const run_array* array = (const run_array*)cachedArray.SetTo(logOffset</a>
<a name="ln475">		+ firstBlockNumber);</a>
<a name="ln476">	if (array == NULL)</a>
<a name="ln477">		return B_IO_ERROR;</a>
<a name="ln478"> </a>
<a name="ln479">	if (_CheckRunArray(array) &lt; B_OK)</a>
<a name="ln480">		return B_BAD_DATA;</a>
<a name="ln481"> </a>
<a name="ln482">	// First pass: check integrity of the blocks in the run array</a>
<a name="ln483"> </a>
<a name="ln484">	CachedBlock cached(fVolume);</a>
<a name="ln485"> </a>
<a name="ln486">	firstBlockNumber = (firstBlockNumber + 1) % fLogSize;</a>
<a name="ln487">	off_t blockNumber = firstBlockNumber;</a>
<a name="ln488">	int32 blockSize = fVolume-&gt;BlockSize();</a>
<a name="ln489"> </a>
<a name="ln490">	for (int32 index = 0; index &lt; array-&gt;CountRuns(); index++) {</a>
<a name="ln491">		const block_run&amp; run = array-&gt;RunAt(index);</a>
<a name="ln492"> </a>
<a name="ln493">		off_t offset = fVolume-&gt;ToOffset(run);</a>
<a name="ln494">		for (int32 i = 0; i &lt; run.Length(); i++) {</a>
<a name="ln495">			const uint8* data = cached.SetTo(logOffset + blockNumber);</a>
<a name="ln496">			if (data == NULL)</a>
<a name="ln497">				RETURN_ERROR(B_IO_ERROR);</a>
<a name="ln498"> </a>
<a name="ln499">			// TODO: eventually check other well known offsets, like the</a>
<a name="ln500">			// root and index dirs</a>
<a name="ln501">			if (offset == 0) {</a>
<a name="ln502">				// This log entry writes over the superblock - check if</a>
<a name="ln503">				// it's valid!</a>
<a name="ln504">				if (Volume::CheckSuperBlock(data) != B_OK) {</a>
<a name="ln505">					FATAL((&quot;Log contains invalid superblock!\n&quot;));</a>
<a name="ln506">					RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln507">				}</a>
<a name="ln508">			}</a>
<a name="ln509"> </a>
<a name="ln510">			blockNumber = (blockNumber + 1) % fLogSize;</a>
<a name="ln511">			offset += blockSize;</a>
<a name="ln512">		}</a>
<a name="ln513">	}</a>
<a name="ln514"> </a>
<a name="ln515">	// Second pass: write back its blocks</a>
<a name="ln516"> </a>
<a name="ln517">	blockNumber = firstBlockNumber;</a>
<a name="ln518">	int32 count = 1;</a>
<a name="ln519"> </a>
<a name="ln520">	for (int32 index = 0; index &lt; array-&gt;CountRuns(); index++) {</a>
<a name="ln521">		const block_run&amp; run = array-&gt;RunAt(index);</a>
<a name="ln522">		INFORM((&quot;replay block run %u:%u:%u in log at %&quot; B_PRIdOFF &quot;!\n&quot;,</a>
<a name="ln523">			(int)run.AllocationGroup(), run.Start(), run.Length(), blockNumber));</a>
<a name="ln524"> </a>
<a name="ln525">		off_t offset = fVolume-&gt;ToOffset(run);</a>
<a name="ln526">		for (int32 i = 0; i &lt; run.Length(); i++) {</a>
<a name="ln527">			const uint8* data = cached.SetTo(logOffset + blockNumber);</a>
<a name="ln528">			if (data == NULL)</a>
<a name="ln529">				RETURN_ERROR(B_IO_ERROR);</a>
<a name="ln530"> </a>
<a name="ln531">			ssize_t written = write_pos(fVolume-&gt;Device(), offset, data,</a>
<a name="ln532">				blockSize);</a>
<a name="ln533">			if (written != blockSize)</a>
<a name="ln534">				RETURN_ERROR(B_IO_ERROR);</a>
<a name="ln535"> </a>
<a name="ln536">			blockNumber = (blockNumber + 1) % fLogSize;</a>
<a name="ln537">			offset += blockSize;</a>
<a name="ln538">			count++;</a>
<a name="ln539">		}</a>
<a name="ln540">	}</a>
<a name="ln541"> </a>
<a name="ln542">	*_start += count;</a>
<a name="ln543">	return B_OK;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546"> </a>
<a name="ln547">/*!	Replays all log entries - this will put the disk into a</a>
<a name="ln548">	consistent and clean state, if it was not correctly unmounted</a>
<a name="ln549">	before.</a>
<a name="ln550">	This method is called by Journal::InitCheck() if the log start</a>
<a name="ln551">	and end pointer don't match.</a>
<a name="ln552">*/</a>
<a name="ln553">status_t</a>
<a name="ln554">Journal::ReplayLog()</a>
<a name="ln555">{</a>
<a name="ln556">	// TODO: this logic won't work whenever the size of the pending transaction</a>
<a name="ln557">	//	equals the size of the log (happens with the original BFS only)</a>
<a name="ln558">	if (fVolume-&gt;LogStart() == fVolume-&gt;LogEnd())</a>
<a name="ln559">		return B_OK;</a>
<a name="ln560"> </a>
<a name="ln561">	INFORM((&quot;Replay log, disk was not correctly unmounted...\n&quot;));</a>
<a name="ln562"> </a>
<a name="ln563">	if (fVolume-&gt;SuperBlock().flags != SUPER_BLOCK_DISK_DIRTY) {</a>
<a name="ln564">		INFORM((&quot;log_start and log_end differ, but disk is marked clean - &quot;</a>
<a name="ln565">			&quot;trying to replay log...\n&quot;));</a>
<a name="ln566">	}</a>
<a name="ln567"> </a>
<a name="ln568">	if (fVolume-&gt;IsReadOnly())</a>
<a name="ln569">		return B_READ_ONLY_DEVICE;</a>
<a name="ln570"> </a>
<a name="ln571">	int32 start = fVolume-&gt;LogStart();</a>
<a name="ln572">	int32 lastStart = -1;</a>
<a name="ln573">	while (true) {</a>
<a name="ln574">		// stop if the log is completely flushed</a>
<a name="ln575">		if (start == fVolume-&gt;LogEnd())</a>
<a name="ln576">			break;</a>
<a name="ln577"> </a>
<a name="ln578">		if (start == lastStart) {</a>
<a name="ln579">			// strange, flushing the log hasn't changed the log_start pointer</a>
<a name="ln580">			return B_ERROR;</a>
<a name="ln581">		}</a>
<a name="ln582">		lastStart = start;</a>
<a name="ln583"> </a>
<a name="ln584">		status_t status = _ReplayRunArray(&amp;start);</a>
<a name="ln585">		if (status != B_OK) {</a>
<a name="ln586">			FATAL((&quot;replaying log entry from %d failed: %s\n&quot;, (int)start,</a>
<a name="ln587">				strerror(status)));</a>
<a name="ln588">			return B_ERROR;</a>
<a name="ln589">		}</a>
<a name="ln590">		start = start % fLogSize;</a>
<a name="ln591">	}</a>
<a name="ln592"> </a>
<a name="ln593">	PRINT((&quot;replaying worked fine!\n&quot;));</a>
<a name="ln594">	fVolume-&gt;SuperBlock().log_start = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln595">		fVolume-&gt;LogEnd());</a>
<a name="ln596">	fVolume-&gt;LogStart() = HOST_ENDIAN_TO_BFS_INT64(fVolume-&gt;LogEnd());</a>
<a name="ln597">	fVolume-&gt;SuperBlock().flags = HOST_ENDIAN_TO_BFS_INT32(</a>
<a name="ln598">		SUPER_BLOCK_DISK_CLEAN);</a>
<a name="ln599"> </a>
<a name="ln600">	return fVolume-&gt;WriteSuperBlock();</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603"> </a>
<a name="ln604">size_t</a>
<a name="ln605">Journal::CurrentTransactionSize() const</a>
<a name="ln606">{</a>
<a name="ln607">	if (_HasSubTransaction()) {</a>
<a name="ln608">		return cache_blocks_in_sub_transaction(fVolume-&gt;BlockCache(),</a>
<a name="ln609">			fTransactionID);</a>
<a name="ln610">	}</a>
<a name="ln611"> </a>
<a name="ln612">	return cache_blocks_in_main_transaction(fVolume-&gt;BlockCache(),</a>
<a name="ln613">		fTransactionID);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616"> </a>
<a name="ln617">bool</a>
<a name="ln618">Journal::CurrentTransactionTooLarge() const</a>
<a name="ln619">{</a>
<a name="ln620">	return CurrentTransactionSize() &gt; fLogSize;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623"> </a>
<a name="ln624">/*!	This is a callback function that is called by the cache, whenever</a>
<a name="ln625">	all blocks of a transaction have been flushed to disk.</a>
<a name="ln626">	This lets us keep track of completed transactions, and update</a>
<a name="ln627">	the log start pointer as needed. Note, the transactions may not be</a>
<a name="ln628">	completed in the order they were written.</a>
<a name="ln629">*/</a>
<a name="ln630">/*static*/ void</a>
<a name="ln631">Journal::_TransactionWritten(int32 transactionID, int32 event, void* _logEntry)</a>
<a name="ln632">{</a>
<a name="ln633">	LogEntry* logEntry = (LogEntry*)_logEntry;</a>
<a name="ln634"> </a>
<a name="ln635">	PRINT((&quot;Log entry %p has been finished, transaction ID = %ld\n&quot;, logEntry,</a>
<a name="ln636">		transactionID));</a>
<a name="ln637"> </a>
<a name="ln638">	Journal* journal = logEntry-&gt;GetJournal();</a>
<a name="ln639">	disk_super_block&amp; superBlock = journal-&gt;fVolume-&gt;SuperBlock();</a>
<a name="ln640">	bool update = false;</a>
<a name="ln641"> </a>
<a name="ln642">	// Set log_start pointer if possible...</a>
<a name="ln643"> </a>
<a name="ln644">	mutex_lock(&amp;journal-&gt;fEntriesLock);</a>
<a name="ln645"> </a>
<a name="ln646">	if (logEntry == journal-&gt;fEntries.First()) {</a>
<a name="ln647">		LogEntry* next = journal-&gt;fEntries.GetNext(logEntry);</a>
<a name="ln648">		if (next != NULL) {</a>
<a name="ln649">			superBlock.log_start = HOST_ENDIAN_TO_BFS_INT64(next-&gt;Start()</a>
<a name="ln650">				% journal-&gt;fLogSize);</a>
<a name="ln651">		} else {</a>
<a name="ln652">			superBlock.log_start = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln653">				journal-&gt;fVolume-&gt;LogEnd());</a>
<a name="ln654">		}</a>
<a name="ln655"> </a>
<a name="ln656">		update = true;</a>
<a name="ln657">	}</a>
<a name="ln658"> </a>
<a name="ln659">	T(LogEntry(logEntry, superBlock.LogStart(), false));</a>
<a name="ln660"> </a>
<a name="ln661">	journal-&gt;fUsed -= logEntry-&gt;Length();</a>
<a name="ln662">	journal-&gt;fEntries.Remove(logEntry);</a>
<a name="ln663">	mutex_unlock(&amp;journal-&gt;fEntriesLock);</a>
<a name="ln664"> </a>
<a name="ln665">	delete logEntry;</a>
<a name="ln666"> </a>
<a name="ln667">	// update the superblock, and change the disk's state, if necessary</a>
<a name="ln668"> </a>
<a name="ln669">	if (update) {</a>
<a name="ln670">		if (superBlock.log_start == superBlock.log_end)</a>
<a name="ln671">			superBlock.flags = HOST_ENDIAN_TO_BFS_INT32(SUPER_BLOCK_DISK_CLEAN);</a>
<a name="ln672"> </a>
<a name="ln673">		status_t status = journal-&gt;fVolume-&gt;WriteSuperBlock();</a>
<a name="ln674">		if (status != B_OK) {</a>
<a name="ln675">			FATAL((&quot;_TransactionWritten: could not write back superblock: %s\n&quot;,</a>
<a name="ln676">				strerror(status)));</a>
<a name="ln677">		}</a>
<a name="ln678"> </a>
<a name="ln679">		journal-&gt;fVolume-&gt;LogStart() = superBlock.LogStart();</a>
<a name="ln680">	}</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683"> </a>
<a name="ln684">/*!	Listens to TRANSACTION_IDLE events, and flushes the log when that happens */</a>
<a name="ln685">/*static*/ void</a>
<a name="ln686">Journal::_TransactionIdle(int32 transactionID, int32 event, void* _journal)</a>
<a name="ln687">{</a>
<a name="ln688">	// The current transaction seems to be idle - flush it. We can't do this</a>
<a name="ln689">	// in this thread, as flushing the log can produce new transaction events.</a>
<a name="ln690">	thread_id id = spawn_kernel_thread(&amp;Journal::_FlushLog, &quot;bfs log flusher&quot;,</a>
<a name="ln691">		B_NORMAL_PRIORITY, _journal);</a>
<a name="ln692">	if (id &gt; 0)</a>
<a name="ln693">		resume_thread(id);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696"> </a>
<a name="ln697">/*static*/ status_t</a>
<a name="ln698">Journal::_FlushLog(void* _journal)</a>
<a name="ln699">{</a>
<a name="ln700">	Journal* journal = (Journal*)_journal;</a>
<a name="ln701">	return journal-&gt;_FlushLog(false, false);</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">/*!	Writes the blocks that are part of current transaction into the log,</a>
<a name="ln706">	and ends the current transaction.</a>
<a name="ln707">	If the current transaction is too large to fit into the log, it will</a>
<a name="ln708">	try to detach an existing sub-transaction.</a>
<a name="ln709">*/</a>
<a name="ln710">status_t</a>
<a name="ln711">Journal::_WriteTransactionToLog()</a>
<a name="ln712">{</a>
<a name="ln713">	// TODO: in case of a failure, we need a backup plan like writing all</a>
<a name="ln714">	//	changed blocks back to disk immediately (hello disk corruption!)</a>
<a name="ln715"> </a>
<a name="ln716">	bool detached = false;</a>
<a name="ln717"> </a>
<a name="ln718">	if (_TransactionSize() &gt; fLogSize) {</a>
<a name="ln719">		// The current transaction won't fit into the log anymore, try to</a>
<a name="ln720">		// detach the current sub-transaction</a>
<a name="ln721">		if (_HasSubTransaction() &amp;&amp; cache_blocks_in_main_transaction(</a>
<a name="ln722">				fVolume-&gt;BlockCache(), fTransactionID) &lt; (int32)fLogSize) {</a>
<a name="ln723">			detached = true;</a>
<a name="ln724">		} else {</a>
<a name="ln725">			// We created a transaction larger than one we can write back to</a>
<a name="ln726">			// disk - the only option we have (besides risking disk corruption</a>
<a name="ln727">			// by writing it back anyway), is to let it fail.</a>
<a name="ln728">			dprintf(&quot;transaction too large (%d blocks, log size %d)!\n&quot;,</a>
<a name="ln729">				(int)_TransactionSize(), (int)fLogSize);</a>
<a name="ln730">			return B_BUFFER_OVERFLOW;</a>
<a name="ln731">		}</a>
<a name="ln732">	}</a>
<a name="ln733"> </a>
<a name="ln734">	fHasSubtransaction = false;</a>
<a name="ln735"> </a>
<a name="ln736">	int32 blockShift = fVolume-&gt;BlockShift();</a>
<a name="ln737">	off_t logOffset = fVolume-&gt;ToBlock(fVolume-&gt;Log()) &lt;&lt; blockShift;</a>
<a name="ln738">	off_t logStart = fVolume-&gt;LogEnd() % fLogSize;</a>
<a name="ln739">	off_t logPosition = logStart;</a>
<a name="ln740">	status_t status;</a>
<a name="ln741"> </a>
<a name="ln742">	// create run_array structures for all changed blocks</a>
<a name="ln743"> </a>
<a name="ln744">	RunArrays runArrays(this);</a>
<a name="ln745"> </a>
<a name="ln746">	off_t blockNumber;</a>
<a name="ln747">	long cookie = 0;</a>
<a name="ln748">	while (cache_next_block_in_transaction(fVolume-&gt;BlockCache(),</a>
<a name="ln749">			fTransactionID, detached, &amp;cookie, &amp;blockNumber, NULL,</a>
<a name="ln750">			NULL) == B_OK) {</a>
<a name="ln751">		status = runArrays.Insert(blockNumber);</a>
<a name="ln752">		if (status &lt; B_OK) {</a>
<a name="ln753">			FATAL((&quot;filling log entry failed!&quot;));</a>
<a name="ln754">			return status;</a>
<a name="ln755">		}</a>
<a name="ln756">	}</a>
<a name="ln757"> </a>
<a name="ln758">	if (runArrays.CountBlocks() == 0) {</a>
<a name="ln759">		// nothing has changed during this transaction</a>
<a name="ln760">		if (detached) {</a>
<a name="ln761">			fTransactionID = cache_detach_sub_transaction(fVolume-&gt;BlockCache(),</a>
<a name="ln762">				fTransactionID, NULL, NULL);</a>
<a name="ln763">			fUnwrittenTransactions = 1;</a>
<a name="ln764">		} else {</a>
<a name="ln765">			cache_end_transaction(fVolume-&gt;BlockCache(), fTransactionID, NULL,</a>
<a name="ln766">				NULL);</a>
<a name="ln767">			fUnwrittenTransactions = 0;</a>
<a name="ln768">		}</a>
<a name="ln769">		return B_OK;</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	// If necessary, flush the log, so that we have enough space for this</a>
<a name="ln773">	// transaction</a>
<a name="ln774">	if (runArrays.LogEntryLength() &gt; FreeLogBlocks()) {</a>
<a name="ln775">		cache_sync_transaction(fVolume-&gt;BlockCache(), fTransactionID);</a>
<a name="ln776">		if (runArrays.LogEntryLength() &gt; FreeLogBlocks()) {</a>
<a name="ln777">			panic(&quot;no space in log after sync (%ld for %ld blocks)!&quot;,</a>
<a name="ln778">				(long)FreeLogBlocks(), (long)runArrays.LogEntryLength());</a>
<a name="ln779">		}</a>
<a name="ln780">	}</a>
<a name="ln781"> </a>
<a name="ln782">	// Write log entries to disk</a>
<a name="ln783"> </a>
<a name="ln784">	int32 maxVecs = runArrays.MaxArrayLength() + 1;</a>
<a name="ln785">		// one extra for the index block</a>
<a name="ln786"> </a>
<a name="ln787">	iovec* vecs = (iovec*)malloc(sizeof(iovec) * maxVecs);</a>
<a name="ln788">	if (vecs == NULL) {</a>
<a name="ln789">		// TODO: write back log entries directly?</a>
<a name="ln790">		return B_NO_MEMORY;</a>
<a name="ln791">	}</a>
<a name="ln792"> </a>
<a name="ln793">	for (int32 k = 0; k &lt; runArrays.CountArrays(); k++) {</a>
<a name="ln794">		run_array* array = runArrays.ArrayAt(k);</a>
<a name="ln795">		int32 index = 0, count = 1;</a>
<a name="ln796">		int32 wrap = fLogSize - logStart;</a>
<a name="ln797"> </a>
<a name="ln798">		add_to_iovec(vecs, index, maxVecs, (void*)array, fVolume-&gt;BlockSize());</a>
<a name="ln799"> </a>
<a name="ln800">		// add block runs</a>
<a name="ln801"> </a>
<a name="ln802">		for (int32 i = 0; i &lt; array-&gt;CountRuns(); i++) {</a>
<a name="ln803">			const block_run&amp; run = array-&gt;RunAt(i);</a>
<a name="ln804">			off_t blockNumber = fVolume-&gt;ToBlock(run);</a>
<a name="ln805"> </a>
<a name="ln806">			for (int32 j = 0; j &lt; run.Length(); j++) {</a>
<a name="ln807">				if (count &gt;= wrap) {</a>
<a name="ln808">					// We need to write back the first half of the entry</a>
<a name="ln809">					// directly as the log wraps around</a>
<a name="ln810">					if (writev_pos(fVolume-&gt;Device(), logOffset</a>
<a name="ln811">						+ (logStart &lt;&lt; blockShift), vecs, index) &lt; 0)</a>
<a name="ln812">						FATAL((&quot;could not write log area!\n&quot;));</a>
<a name="ln813"> </a>
<a name="ln814">					logPosition = logStart + count;</a>
<a name="ln815">					logStart = 0;</a>
<a name="ln816">					wrap = fLogSize;</a>
<a name="ln817">					count = 0;</a>
<a name="ln818">					index = 0;</a>
<a name="ln819">				}</a>
<a name="ln820"> </a>
<a name="ln821">				// make blocks available in the cache</a>
<a name="ln822">				const void* data = block_cache_get(fVolume-&gt;BlockCache(),</a>
<a name="ln823">					blockNumber + j);</a>
<a name="ln824">				if (data == NULL) {</a>
<a name="ln825">					free(vecs);</a>
<a name="ln826">					return B_IO_ERROR;</a>
<a name="ln827">				}</a>
<a name="ln828"> </a>
<a name="ln829">				add_to_iovec(vecs, index, maxVecs, data, fVolume-&gt;BlockSize());</a>
<a name="ln830">				count++;</a>
<a name="ln831">			}</a>
<a name="ln832">		}</a>
<a name="ln833"> </a>
<a name="ln834">		// write back the rest of the log entry</a>
<a name="ln835">		if (count &gt; 0) {</a>
<a name="ln836">			logPosition = logStart + count;</a>
<a name="ln837">			if (writev_pos(fVolume-&gt;Device(), logOffset</a>
<a name="ln838">					+ (logStart &lt;&lt; blockShift), vecs, index) &lt; 0)</a>
<a name="ln839">				FATAL((&quot;could not write log area: %s!\n&quot;, strerror(errno)));</a>
<a name="ln840">		}</a>
<a name="ln841"> </a>
<a name="ln842">		// release blocks again</a>
<a name="ln843">		for (int32 i = 0; i &lt; array-&gt;CountRuns(); i++) {</a>
<a name="ln844">			const block_run&amp; run = array-&gt;RunAt(i);</a>
<a name="ln845">			off_t blockNumber = fVolume-&gt;ToBlock(run);</a>
<a name="ln846"> </a>
<a name="ln847">			for (int32 j = 0; j &lt; run.Length(); j++) {</a>
<a name="ln848">				block_cache_put(fVolume-&gt;BlockCache(), blockNumber + j);</a>
<a name="ln849">			}</a>
<a name="ln850">		}</a>
<a name="ln851"> </a>
<a name="ln852">		logStart = logPosition % fLogSize;</a>
<a name="ln853">	}</a>
<a name="ln854"> </a>
<a name="ln855">	free(vecs);</a>
<a name="ln856"> </a>
<a name="ln857">	LogEntry* logEntry = new(std::nothrow) LogEntry(this, fVolume-&gt;LogEnd(),</a>
<a name="ln858">		runArrays.LogEntryLength());</a>
<a name="ln859">	if (logEntry == NULL) {</a>
<a name="ln860">		FATAL((&quot;no memory to allocate log entries!&quot;));</a>
<a name="ln861">		return B_NO_MEMORY;</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">#ifdef BFS_DEBUGGER_COMMANDS</a>
<a name="ln865">	logEntry-&gt;SetTransactionID(fTransactionID);</a>
<a name="ln866">#endif</a>
<a name="ln867"> </a>
<a name="ln868">	// Update the log end pointer in the superblock</a>
<a name="ln869"> </a>
<a name="ln870">	fVolume-&gt;SuperBlock().flags = SUPER_BLOCK_DISK_DIRTY;</a>
<a name="ln871">	fVolume-&gt;SuperBlock().log_end = HOST_ENDIAN_TO_BFS_INT64(logPosition);</a>
<a name="ln872"> </a>
<a name="ln873">	status = fVolume-&gt;WriteSuperBlock();</a>
<a name="ln874"> </a>
<a name="ln875">	fVolume-&gt;LogEnd() = logPosition;</a>
<a name="ln876">	T(LogEntry(logEntry, fVolume-&gt;LogEnd(), true));</a>
<a name="ln877"> </a>
<a name="ln878">	// We need to flush the drives own cache here to ensure</a>
<a name="ln879">	// disk consistency.</a>
<a name="ln880">	// If that call fails, we can't do anything about it anyway</a>
<a name="ln881">	ioctl(fVolume-&gt;Device(), B_FLUSH_DRIVE_CACHE);</a>
<a name="ln882"> </a>
<a name="ln883">	// at this point, we can finally end the transaction - we're in</a>
<a name="ln884">	// a guaranteed valid state</a>
<a name="ln885"> </a>
<a name="ln886">	mutex_lock(&amp;fEntriesLock);</a>
<a name="ln887">	fEntries.Add(logEntry);</a>
<a name="ln888">	fUsed += logEntry-&gt;Length();</a>
<a name="ln889">	mutex_unlock(&amp;fEntriesLock);</a>
<a name="ln890"> </a>
<a name="ln891">	if (detached) {</a>
<a name="ln892">		fTransactionID = cache_detach_sub_transaction(fVolume-&gt;BlockCache(),</a>
<a name="ln893">			fTransactionID, _TransactionWritten, logEntry);</a>
<a name="ln894">		fUnwrittenTransactions = 1;</a>
<a name="ln895"> </a>
<a name="ln896">		if (status == B_OK &amp;&amp; _TransactionSize() &gt; fLogSize) {</a>
<a name="ln897">			// If the transaction is too large after writing, there is no way to</a>
<a name="ln898">			// recover, so let this transaction fail.</a>
<a name="ln899">			dprintf(&quot;transaction too large (%d blocks, log size %d)!\n&quot;,</a>
<a name="ln900">				(int)_TransactionSize(), (int)fLogSize);</a>
<a name="ln901">			return B_BUFFER_OVERFLOW;</a>
<a name="ln902">		}</a>
<a name="ln903">	} else {</a>
<a name="ln904">		cache_end_transaction(fVolume-&gt;BlockCache(), fTransactionID,</a>
<a name="ln905">			_TransactionWritten, logEntry);</a>
<a name="ln906">		fUnwrittenTransactions = 0;</a>
<a name="ln907">	}</a>
<a name="ln908"> </a>
<a name="ln909">	return status;</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912"> </a>
<a name="ln913">/*!	Flushes the current log entry to disk. If \a flushBlocks is \c true it will</a>
<a name="ln914">	also write back all dirty blocks for this volume.</a>
<a name="ln915">*/</a>
<a name="ln916">status_t</a>
<a name="ln917">Journal::_FlushLog(bool canWait, bool flushBlocks)</a>
<a name="ln918">{</a>
<a name="ln919">	status_t status = canWait ? recursive_lock_lock(&amp;fLock)</a>
<a name="ln920">		: recursive_lock_trylock(&amp;fLock);</a>
<a name="ln921">	if (status != B_OK)</a>
<a name="ln922">		return status;</a>
<a name="ln923"> </a>
<a name="ln924">	if (recursive_lock_get_recursion(&amp;fLock) &gt; 1) {</a>
<a name="ln925">		// whoa, FlushLogAndBlocks() was called from inside a transaction</a>
<a name="ln926">		recursive_lock_unlock(&amp;fLock);</a>
<a name="ln927">		return B_OK;</a>
<a name="ln928">	}</a>
<a name="ln929"> </a>
<a name="ln930">	// write the current log entry to disk</a>
<a name="ln931"> </a>
<a name="ln932">	if (fUnwrittenTransactions != 0) {</a>
<a name="ln933">		status = _WriteTransactionToLog();</a>
<a name="ln934">		if (status &lt; B_OK)</a>
<a name="ln935">			FATAL((&quot;writing current log entry failed: %s\n&quot;, strerror(status)));</a>
<a name="ln936">	}</a>
<a name="ln937"> </a>
<a name="ln938">	if (flushBlocks)</a>
<a name="ln939">		status = fVolume-&gt;FlushDevice();</a>
<a name="ln940"> </a>
<a name="ln941">	recursive_lock_unlock(&amp;fLock);</a>
<a name="ln942">	return status;</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945"> </a>
<a name="ln946">/*!	Flushes the current log entry to disk, and also writes back all dirty</a>
<a name="ln947">	blocks for this volume (completing all open transactions).</a>
<a name="ln948">*/</a>
<a name="ln949">status_t</a>
<a name="ln950">Journal::FlushLogAndBlocks()</a>
<a name="ln951">{</a>
<a name="ln952">	return _FlushLog(true, true);</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955"> </a>
<a name="ln956">status_t</a>
<a name="ln957">Journal::Lock(Transaction* owner, bool separateSubTransactions)</a>
<a name="ln958">{</a>
<a name="ln959">	status_t status = recursive_lock_lock(&amp;fLock);</a>
<a name="ln960">	if (status != B_OK)</a>
<a name="ln961">		return status;</a>
<a name="ln962"> </a>
<a name="ln963">	if (!fSeparateSubTransactions &amp;&amp; recursive_lock_get_recursion(&amp;fLock) &gt; 1) {</a>
<a name="ln964">		// we'll just use the current transaction again</a>
<a name="ln965">		return B_OK;</a>
<a name="ln966">	}</a>
<a name="ln967"> </a>
<a name="ln968">	if (separateSubTransactions)</a>
<a name="ln969">		fSeparateSubTransactions = true;</a>
<a name="ln970"> </a>
<a name="ln971">	if (owner != NULL)</a>
<a name="ln972">		owner-&gt;SetParent(fOwner);</a>
<a name="ln973"> </a>
<a name="ln974">	fOwner = owner;</a>
<a name="ln975"> </a>
<a name="ln976">	// TODO: we need a way to find out how big the current transaction is;</a>
<a name="ln977">	//	we need to be able to either detach the latest sub transaction on</a>
<a name="ln978">	//	demand, as well as having some kind of fall back plan in case the</a>
<a name="ln979">	//	sub transaction itself grows bigger than the log.</a>
<a name="ln980">	//	For that, it would be nice to have some call-back interface in the</a>
<a name="ln981">	//	cache transaction API...</a>
<a name="ln982"> </a>
<a name="ln983">	if (fOwner != NULL) {</a>
<a name="ln984">		if (fUnwrittenTransactions &gt; 0) {</a>
<a name="ln985">			// start a sub transaction</a>
<a name="ln986">			cache_start_sub_transaction(fVolume-&gt;BlockCache(), fTransactionID);</a>
<a name="ln987">			fHasSubtransaction = true;</a>
<a name="ln988">		} else</a>
<a name="ln989">			fTransactionID = cache_start_transaction(fVolume-&gt;BlockCache());</a>
<a name="ln990"> </a>
<a name="ln991">		if (fTransactionID &lt; B_OK) {</a>
<a name="ln992">			recursive_lock_unlock(&amp;fLock);</a>
<a name="ln993">			return fTransactionID;</a>
<a name="ln994">		}</a>
<a name="ln995"> </a>
<a name="ln996">		cache_add_transaction_listener(fVolume-&gt;BlockCache(), fTransactionID,</a>
<a name="ln997">			TRANSACTION_IDLE, _TransactionIdle, this);</a>
<a name="ln998">	}</a>
<a name="ln999">	return B_OK;</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002"> </a>
<a name="ln1003">status_t</a>
<a name="ln1004">Journal::Unlock(Transaction* owner, bool success)</a>
<a name="ln1005">{</a>
<a name="ln1006">	if (fSeparateSubTransactions || recursive_lock_get_recursion(&amp;fLock) == 1) {</a>
<a name="ln1007">		// we only end the transaction if we would really unlock it</a>
<a name="ln1008">		// TODO: what about failing transactions that do not unlock?</a>
<a name="ln1009">		// (they must make the parent fail, too)</a>
<a name="ln1010">		if (owner != NULL) {</a>
<a name="ln1011">			status_t status = _TransactionDone(success);</a>
<a name="ln1012">			if (status != B_OK)</a>
<a name="ln1013">				return status;</a>
<a name="ln1014"> </a>
<a name="ln1015">			// Unlocking the inodes might trigger new transactions, but we</a>
<a name="ln1016">			// cannot reuse the current one anymore, as this one is already</a>
<a name="ln1017">			// closed.</a>
<a name="ln1018">			bool separateSubTransactions = fSeparateSubTransactions;</a>
<a name="ln1019">			fSeparateSubTransactions = true;</a>
<a name="ln1020">			owner-&gt;NotifyListeners(success);</a>
<a name="ln1021">			fSeparateSubTransactions = separateSubTransactions;</a>
<a name="ln1022"> </a>
<a name="ln1023">			fOwner = owner-&gt;Parent();</a>
<a name="ln1024">		} else</a>
<a name="ln1025">			fOwner = NULL;</a>
<a name="ln1026"> </a>
<a name="ln1027">		fTimestamp = system_time();</a>
<a name="ln1028"> </a>
<a name="ln1029">		if (fSeparateSubTransactions</a>
<a name="ln1030">			&amp;&amp; recursive_lock_get_recursion(&amp;fLock) == 1)</a>
<a name="ln1031">			fSeparateSubTransactions = false;</a>
<a name="ln1032">	} else</a>
<a name="ln1033">		owner-&gt;MoveListenersTo(fOwner);</a>
<a name="ln1034"> </a>
<a name="ln1035">	recursive_lock_unlock(&amp;fLock);</a>
<a name="ln1036">	return B_OK;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">uint32</a>
<a name="ln1041">Journal::_TransactionSize() const</a>
<a name="ln1042">{</a>
<a name="ln1043">	int32 count = cache_blocks_in_transaction(fVolume-&gt;BlockCache(),</a>
<a name="ln1044">		fTransactionID);</a>
<a name="ln1045">	if (count &lt;= 0)</a>
<a name="ln1046">		return 0;</a>
<a name="ln1047"> </a>
<a name="ln1048">	// take the number of array blocks in this transaction into account</a>
<a name="ln1049">	uint32 maxRuns = run_array::MaxRuns(fVolume-&gt;BlockSize());</a>
<a name="ln1050">	uint32 arrayBlocks = (count + maxRuns - 1) / maxRuns;</a>
<a name="ln1051">	return count + arrayBlocks;</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055">status_t</a>
<a name="ln1056">Journal::_TransactionDone(bool success)</a>
<a name="ln1057">{</a>
<a name="ln1058">	if (!success) {</a>
<a name="ln1059">		if (_HasSubTransaction()) {</a>
<a name="ln1060">			cache_abort_sub_transaction(fVolume-&gt;BlockCache(), fTransactionID);</a>
<a name="ln1061">			// We can continue to use the parent transaction afterwards</a>
<a name="ln1062">		} else {</a>
<a name="ln1063">			cache_abort_transaction(fVolume-&gt;BlockCache(), fTransactionID);</a>
<a name="ln1064">			fUnwrittenTransactions = 0;</a>
<a name="ln1065">		}</a>
<a name="ln1066"> </a>
<a name="ln1067">		return B_OK;</a>
<a name="ln1068">	}</a>
<a name="ln1069"> </a>
<a name="ln1070">	// Up to a maximum size, we will just batch several</a>
<a name="ln1071">	// transactions together to improve speed</a>
<a name="ln1072">	uint32 size = _TransactionSize();</a>
<a name="ln1073">	if (size &lt; fMaxTransactionSize) {</a>
<a name="ln1074">		// Flush the log from time to time, so that we have enough space</a>
<a name="ln1075">		// for this transaction</a>
<a name="ln1076">		if (size &gt; FreeLogBlocks())</a>
<a name="ln1077">			cache_sync_transaction(fVolume-&gt;BlockCache(), fTransactionID);</a>
<a name="ln1078"> </a>
<a name="ln1079">		fUnwrittenTransactions++;</a>
<a name="ln1080">		return B_OK;</a>
<a name="ln1081">	}</a>
<a name="ln1082"> </a>
<a name="ln1083">	return _WriteTransactionToLog();</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086"> </a>
<a name="ln1087">//	#pragma mark - debugger commands</a>
<a name="ln1088"> </a>
<a name="ln1089"> </a>
<a name="ln1090">#ifdef BFS_DEBUGGER_COMMANDS</a>
<a name="ln1091"> </a>
<a name="ln1092"> </a>
<a name="ln1093">void</a>
<a name="ln1094">Journal::Dump()</a>
<a name="ln1095">{</a>
<a name="ln1096">	kprintf(&quot;Journal %p\n&quot;, this);</a>
<a name="ln1097">	kprintf(&quot;  log start:            %&quot; B_PRId32 &quot;\n&quot;, fVolume-&gt;LogStart());</a>
<a name="ln1098">	kprintf(&quot;  log end:              %&quot; B_PRId32 &quot;\n&quot;, fVolume-&gt;LogEnd());</a>
<a name="ln1099">	kprintf(&quot;  owner:                %p\n&quot;, fOwner);</a>
<a name="ln1100">	kprintf(&quot;  log size:             %&quot; B_PRIu32 &quot;\n&quot;, fLogSize);</a>
<a name="ln1101">	kprintf(&quot;  max transaction size: %&quot; B_PRIu32 &quot;\n&quot;, fMaxTransactionSize);</a>
<a name="ln1102">	kprintf(&quot;  used:                 %&quot; B_PRIu32 &quot;\n&quot;, fUsed);</a>
<a name="ln1103">	kprintf(&quot;  unwritten:            %&quot; B_PRId32 &quot;\n&quot;, fUnwrittenTransactions);</a>
<a name="ln1104">	kprintf(&quot;  timestamp:            %&quot; B_PRId64 &quot;\n&quot;, fTimestamp);</a>
<a name="ln1105">	kprintf(&quot;  transaction ID:       %&quot; B_PRId32 &quot;\n&quot;, fTransactionID);</a>
<a name="ln1106">	kprintf(&quot;  has subtransaction:   %d\n&quot;, fHasSubtransaction);</a>
<a name="ln1107">	kprintf(&quot;  separate sub-trans.:  %d\n&quot;, fSeparateSubTransactions);</a>
<a name="ln1108">	kprintf(&quot;entries:\n&quot;);</a>
<a name="ln1109">	kprintf(&quot;  address        id  start length\n&quot;);</a>
<a name="ln1110"> </a>
<a name="ln1111">	LogEntryList::Iterator iterator = fEntries.GetIterator();</a>
<a name="ln1112"> </a>
<a name="ln1113">	while (iterator.HasNext()) {</a>
<a name="ln1114">		LogEntry* entry = iterator.Next();</a>
<a name="ln1115"> </a>
<a name="ln1116">		kprintf(&quot;  %p %6&quot; B_PRId32 &quot; %6&quot; B_PRIu32 &quot; %6&quot; B_PRIu32 &quot;\n&quot;, entry,</a>
<a name="ln1117">			entry-&gt;TransactionID(), entry-&gt;Start(), entry-&gt;Length());</a>
<a name="ln1118">	}</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121"> </a>
<a name="ln1122">int</a>
<a name="ln1123">dump_journal(int argc, char** argv)</a>
<a name="ln1124">{</a>
<a name="ln1125">	if (argc != 2 || !strcmp(argv[1], &quot;--help&quot;)) {</a>
<a name="ln1126">		kprintf(&quot;usage: %s &lt;ptr-to-volume&gt;\n&quot;, argv[0]);</a>
<a name="ln1127">		return 0;</a>
<a name="ln1128">	}</a>
<a name="ln1129"> </a>
<a name="ln1130">	Volume* volume = (Volume*)parse_expression(argv[1]);</a>
<a name="ln1131">	Journal* journal = volume-&gt;GetJournal(0);</a>
<a name="ln1132"> </a>
<a name="ln1133">	journal-&gt;Dump();</a>
<a name="ln1134">	return 0;</a>
<a name="ln1135">}</a>
<a name="ln1136"> </a>
<a name="ln1137"> </a>
<a name="ln1138">#endif	// BFS_DEBUGGER_COMMANDS</a>
<a name="ln1139"> </a>
<a name="ln1140"> </a>
<a name="ln1141">//	#pragma mark - TransactionListener</a>
<a name="ln1142"> </a>
<a name="ln1143"> </a>
<a name="ln1144">TransactionListener::TransactionListener()</a>
<a name="ln1145">{</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148"> </a>
<a name="ln1149">TransactionListener::~TransactionListener()</a>
<a name="ln1150">{</a>
<a name="ln1151">}</a>
<a name="ln1152"> </a>
<a name="ln1153"> </a>
<a name="ln1154">//	#pragma mark - Transaction</a>
<a name="ln1155"> </a>
<a name="ln1156"> </a>
<a name="ln1157">status_t</a>
<a name="ln1158">Transaction::Start(Volume* volume, off_t refBlock)</a>
<a name="ln1159">{</a>
<a name="ln1160">	// has it already been started?</a>
<a name="ln1161">	if (fJournal != NULL)</a>
<a name="ln1162">		return B_OK;</a>
<a name="ln1163"> </a>
<a name="ln1164">	fJournal = volume-&gt;GetJournal(refBlock);</a>
<a name="ln1165">	if (fJournal != NULL &amp;&amp; fJournal-&gt;Lock(this, false) == B_OK)</a>
<a name="ln1166">		return B_OK;</a>
<a name="ln1167"> </a>
<a name="ln1168">	fJournal = NULL;</a>
<a name="ln1169">	return B_ERROR;</a>
<a name="ln1170">}</a>
<a name="ln1171"> </a>
<a name="ln1172"> </a>
<a name="ln1173">void</a>
<a name="ln1174">Transaction::AddListener(TransactionListener* listener)</a>
<a name="ln1175">{</a>
<a name="ln1176">	if (fJournal == NULL)</a>
<a name="ln1177">		panic(&quot;Transaction is not running!&quot;);</a>
<a name="ln1178"> </a>
<a name="ln1179">	fListeners.Add(listener);</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182"> </a>
<a name="ln1183">void</a>
<a name="ln1184">Transaction::RemoveListener(TransactionListener* listener)</a>
<a name="ln1185">{</a>
<a name="ln1186">	if (fJournal == NULL)</a>
<a name="ln1187">		panic(&quot;Transaction is not running!&quot;);</a>
<a name="ln1188"> </a>
<a name="ln1189">	fListeners.Remove(listener);</a>
<a name="ln1190">	listener-&gt;RemovedFromTransaction();</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193"> </a>
<a name="ln1194">void</a>
<a name="ln1195">Transaction::NotifyListeners(bool success)</a>
<a name="ln1196">{</a>
<a name="ln1197">	while (TransactionListener* listener = fListeners.RemoveHead()) {</a>
<a name="ln1198">		listener-&gt;TransactionDone(success);</a>
<a name="ln1199">		listener-&gt;RemovedFromTransaction();</a>
<a name="ln1200">	}</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203"> </a>
<a name="ln1204">/*!	Move the inodes into the parent transaction. This is needed only to make</a>
<a name="ln1205">	sure they will still be reverted in case the transaction is aborted.</a>
<a name="ln1206">*/</a>
<a name="ln1207">void</a>
<a name="ln1208">Transaction::MoveListenersTo(Transaction* transaction)</a>
<a name="ln1209">{</a>
<a name="ln1210">	while (TransactionListener* listener = fListeners.RemoveHead()) {</a>
<a name="ln1211">		transaction-&gt;fListeners.Add(listener);</a>
<a name="ln1212">	}</a>
<a name="ln1213">}</a>

</code></pre>
<div class="balloon" rel="168"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fTransactionID.</p></div>
<div class="balloon" rel="399"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fTimestamp, fTransactionID.</p></div>
<div class="balloon" rel="522"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'fssh_dprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
