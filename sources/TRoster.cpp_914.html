
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>TRoster.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2008, Ingo Weinhold, bonefish@users.sf.net.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">/*!	TRoster is the incarnation of The Roster. It manages the running</a>
<a name="ln8">	applications.</a>
<a name="ln9">*/</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;TRoster.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;new&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;errno.h&gt;</a>
<a name="ln17">#include &lt;stdio.h&gt;</a>
<a name="ln18">#include &lt;string.h&gt;</a>
<a name="ln19">#include &lt;strings.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;Application.h&gt;</a>
<a name="ln22">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln23">#include &lt;Autolock.h&gt;</a>
<a name="ln24">#include &lt;Directory.h&gt;</a>
<a name="ln25">#include &lt;File.h&gt;</a>
<a name="ln26">#include &lt;FindDirectory.h&gt;</a>
<a name="ln27">#include &lt;Path.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;AppMisc.h&gt;</a>
<a name="ln30">#include &lt;MessagePrivate.h&gt;</a>
<a name="ln31">#include &lt;MessengerPrivate.h&gt;</a>
<a name="ln32">#include &lt;RosterPrivate.h&gt;</a>
<a name="ln33">#include &lt;ServerProtocol.h&gt;</a>
<a name="ln34">#include &lt;storage_support.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;AppInfoListMessagingTargetSet.h&quot;</a>
<a name="ln37">#include &quot;Debug.h&quot;</a>
<a name="ln38">#include &quot;EventMaskWatcher.h&quot;</a>
<a name="ln39">#include &quot;MessageDeliverer.h&quot;</a>
<a name="ln40">#include &quot;RegistrarDefs.h&quot;</a>
<a name="ln41">#include &quot;RosterAppInfo.h&quot;</a>
<a name="ln42">#include &quot;RosterSettingsCharStream.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">using std::nothrow;</a>
<a name="ln45">using namespace BPrivate;</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">/*!	\class TRoster</a>
<a name="ln49">	\brief Implements the application roster.</a>
<a name="ln50"> </a>
<a name="ln51">	This class handles the BRoster requests. For each kind a hook method is</a>
<a name="ln52">	implemented to which the registrar looper dispatches the request messages.</a>
<a name="ln53"> </a>
<a name="ln54">	Registered and pre-registered are managed via AppInfoLists.</a>
<a name="ln55">	\a fEarlyPreRegisteredApps contains the infos for those application that</a>
<a name="ln56">	are pre-registered and currently have no team ID assigned to them yet,</a>
<a name="ln57">	whereas the infos of registered and pre-registered applications with a</a>
<a name="ln58">	team ID are to be found in \a fRegisteredApps.</a>
<a name="ln59"> </a>
<a name="ln60">	When an application asks whether it is pre-registered or not and there</a>
<a name="ln61">	are one or more instances of the application that are pre-registered, but</a>
<a name="ln62">	have no team ID assigned yet, the reply to the request has to be</a>
<a name="ln63">	postponed until the status of the requesting team is clear. The request</a>
<a name="ln64">	message is dequeued from the registrar's message queue and added to</a>
<a name="ln65">	\a fIARRequestsByID for a later reply.</a>
<a name="ln66"> </a>
<a name="ln67">	The field \a fActiveApp identifies the currently active application</a>
<a name="ln68">	and \a fLastToken is a counter used to generate unique tokens for</a>
<a name="ln69">	pre-registered applications.</a>
<a name="ln70">*/</a>
<a name="ln71"> </a>
<a name="ln72">//! The maximal period of time an app may be early pre-registered (60 s).</a>
<a name="ln73">const bigtime_t kMaximalEarlyPreRegistrationPeriod = 60000000LL;</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">//	#pragma mark - Private local functions</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">/*!	\brief Returns the path to the default roster settings.</a>
<a name="ln80"> </a>
<a name="ln81">	\param path BPath to be set to the roster settings path.</a>
<a name="ln82">	\param createDirectory makes sure the target directory exists if \c true.</a>
<a name="ln83"> </a>
<a name="ln84">	\return the settings path as C string (\code path.Path() \endcode).</a>
<a name="ln85">*/</a>
<a name="ln86">static const char*</a>
<a name="ln87">get_default_roster_settings_path(BPath&amp; path, bool createDirectory)</a>
<a name="ln88">{</a>
<a name="ln89">	// get the path of the settings dir and append the subpath of our file</a>
<a name="ln90">	status_t error = find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path);</a>
<a name="ln91">	if (error == B_OK)</a>
<a name="ln92">		error = path.Append(&quot;system/registrar&quot;);</a>
<a name="ln93">	if (error == B_OK &amp;&amp; createDirectory)</a>
<a name="ln94">		error = create_directory(path.Path(), 0777);</a>
<a name="ln95">	if (error == B_OK)</a>
<a name="ln96">		error = path.Append(&quot;RosterSettings&quot;);</a>
<a name="ln97"> </a>
<a name="ln98">	return path.Path();</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">/*! \brief Returns true if entry1's index is larger than entry2's index.</a>
<a name="ln103"> </a>
<a name="ln104">	Also returns true if either entry is \c NULL.</a>
<a name="ln105"> </a>
<a name="ln106">	Used for sorting the recent entry lists loaded from disk into the</a>
<a name="ln107">	proper order.</a>
<a name="ln108">*/</a>
<a name="ln109">bool</a>
<a name="ln110">larger_index(const recent_entry* entry1, const recent_entry* entry2)</a>
<a name="ln111">{</a>
<a name="ln112">	if (entry1 &amp;&amp; entry2)</a>
<a name="ln113">		return entry1-&gt;index &gt; entry2-&gt;index;</a>
<a name="ln114"> </a>
<a name="ln115">	return true;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">//	#pragma mark -</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">/*!	\brief Creates a new roster.</a>
<a name="ln123"> </a>
<a name="ln124">	The object is completely initialized and ready to handle requests.</a>
<a name="ln125">*/</a>
<a name="ln126">TRoster::TRoster()</a>
<a name="ln127">	:</a>
<a name="ln128">	fLock(&quot;roster&quot;),</a>
<a name="ln129">	fRegisteredApps(),</a>
<a name="ln130">	fEarlyPreRegisteredApps(),</a>
<a name="ln131">	fIARRequestsByID(),</a>
<a name="ln132">	fIARRequestsByToken(),</a>
<a name="ln133">	fActiveApp(NULL),</a>
<a name="ln134">	fWatchingService(),</a>
<a name="ln135">	fRecentApps(),</a>
<a name="ln136">	fRecentDocuments(),</a>
<a name="ln137">	fRecentFolders(),</a>
<a name="ln138">	fLastToken(0),</a>
<a name="ln139">	fShuttingDown(false)</a>
<a name="ln140">{</a>
<a name="ln141">	find_directory(B_SYSTEM_DIRECTORY, &amp;fSystemAppPath);</a>
<a name="ln142">	find_directory(B_SYSTEM_SERVERS_DIRECTORY, &amp;fSystemServerPath);</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145"> </a>
<a name="ln146">/*!	\brief Frees all resources associated with this object.</a>
<a name="ln147">*/</a>
<a name="ln148">TRoster::~TRoster()</a>
<a name="ln149">{</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152"> </a>
<a name="ln153">/*!	\brief Handles an AddApplication() request.</a>
<a name="ln154">	\param request The request message</a>
<a name="ln155">*/</a>
<a name="ln156">void</a>
<a name="ln157">TRoster::HandleAddApplication(BMessage* request)</a>
<a name="ln158">{</a>
<a name="ln159">	FUNCTION_START();</a>
<a name="ln160"> </a>
<a name="ln161">	BAutolock _(fLock);</a>
<a name="ln162"> </a>
<a name="ln163">	status_t error = B_OK;</a>
<a name="ln164">	// get the parameters</a>
<a name="ln165">	const char* signature;</a>
<a name="ln166">	entry_ref ref;</a>
<a name="ln167">	uint32 flags;</a>
<a name="ln168">	team_id team;</a>
<a name="ln169">	thread_id thread;</a>
<a name="ln170">	port_id port;</a>
<a name="ln171">	bool fullReg;</a>
<a name="ln172">	if (request-&gt;FindString(&quot;signature&quot;, &amp;signature) != B_OK)</a>
<a name="ln173">		signature = NULL;</a>
<a name="ln174">	if (request-&gt;FindRef(&quot;ref&quot;, &amp;ref) != B_OK)</a>
<a name="ln175">		SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln176">	if (request-&gt;FindInt32(&quot;flags&quot;, (int32*)&amp;flags) != B_OK)</a>
<a name="ln177">		flags = B_REG_DEFAULT_APP_FLAGS;</a>
<a name="ln178">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln179">		team = -1;</a>
<a name="ln180">	if (request-&gt;FindInt32(&quot;thread&quot;, &amp;thread) != B_OK)</a>
<a name="ln181">		thread = -1;</a>
<a name="ln182">	if (request-&gt;FindInt32(&quot;port&quot;, &amp;port) != B_OK)</a>
<a name="ln183">		port = -1;</a>
<a name="ln184">	if (request-&gt;FindBool(&quot;full_registration&quot;, &amp;fullReg) != B_OK)</a>
<a name="ln185">		fullReg = false;</a>
<a name="ln186"> </a>
<a name="ln187">	PRINT(&quot;team: %&quot; B_PRId32 &quot;, signature: %s\n&quot;, team, signature);</a>
<a name="ln188">	PRINT(&quot;full registration: %d\n&quot;, fullReg);</a>
<a name="ln189"> </a>
<a name="ln190">	if (fShuttingDown)</a>
<a name="ln191">		error = B_SHUTTING_DOWN;</a>
<a name="ln192"> </a>
<a name="ln193">	// check the parameters</a>
<a name="ln194">	team_id otherTeam = -1;</a>
<a name="ln195">	uint32 token = 0;</a>
<a name="ln196"> </a>
<a name="ln197">	uint32 launchFlags = flags &amp; B_LAUNCH_MASK;</a>
<a name="ln198">	BEntry entry(&amp;ref);</a>
<a name="ln199">	if (!entry.Exists())</a>
<a name="ln200">		SET_ERROR(error, B_ENTRY_NOT_FOUND);</a>
<a name="ln201"> </a>
<a name="ln202">	if (error == B_OK)</a>
<a name="ln203">		_ValidateRunning(ref, signature);</a>
<a name="ln204"> </a>
<a name="ln205">	// entry_ref</a>
<a name="ln206">	if (error == B_OK) {</a>
<a name="ln207">		PRINT(&quot;flags: %&quot; B_PRIx32 &quot;\n&quot;, flags);</a>
<a name="ln208">		PRINT(&quot;ref: %&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;, %s\n&quot;, ref.device,</a>
<a name="ln209">			ref.directory, ref.name);</a>
<a name="ln210">		// check single/exclusive launchers</a>
<a name="ln211">		RosterAppInfo* info = NULL;</a>
<a name="ln212">		if ((launchFlags == B_SINGLE_LAUNCH</a>
<a name="ln213">			 || launchFlags ==  B_EXCLUSIVE_LAUNCH)</a>
<a name="ln214">			&amp;&amp; ((info = fRegisteredApps.InfoFor(&amp;ref)) != NULL</a>
<a name="ln215">				|| (info = fEarlyPreRegisteredApps.InfoFor(&amp;ref)) != NULL)) {</a>
<a name="ln216">			SET_ERROR(error, B_ALREADY_RUNNING);</a>
<a name="ln217">			otherTeam = info-&gt;team;</a>
<a name="ln218">			token = info-&gt;token;</a>
<a name="ln219">		}</a>
<a name="ln220">	}</a>
<a name="ln221"> </a>
<a name="ln222">	// signature</a>
<a name="ln223">	if (error == B_OK &amp;&amp; signature) {</a>
<a name="ln224">		// check exclusive launchers</a>
<a name="ln225">		RosterAppInfo* info = NULL;</a>
<a name="ln226">		if (launchFlags == B_EXCLUSIVE_LAUNCH</a>
<a name="ln227">			&amp;&amp; (((info = fRegisteredApps.InfoFor(signature)))</a>
<a name="ln228">				|| ((info = fEarlyPreRegisteredApps.InfoFor(signature))))) {</a>
<a name="ln229">			SET_ERROR(error, B_ALREADY_RUNNING);</a>
<a name="ln230">			otherTeam = info-&gt;team;</a>
<a name="ln231">			token = info-&gt;token;</a>
<a name="ln232">		}</a>
<a name="ln233">	}</a>
<a name="ln234"> </a>
<a name="ln235">	// If no team ID is given, full registration isn't possible.</a>
<a name="ln236">	if (error == B_OK) {</a>
<a name="ln237">		if (team &lt; 0) {</a>
<a name="ln238">			if (fullReg)</a>
<a name="ln239">				SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln240">		} else if (fRegisteredApps.InfoFor(team))</a>
<a name="ln241">			SET_ERROR(error, B_REG_ALREADY_REGISTERED);</a>
<a name="ln242">	}</a>
<a name="ln243"> </a>
<a name="ln244">	// Add the application info.</a>
<a name="ln245">	if (error == B_OK) {</a>
<a name="ln246">		// alloc and init the info</a>
<a name="ln247">		RosterAppInfo* info = new(nothrow) RosterAppInfo;</a>
<a name="ln248">		if (info) {</a>
<a name="ln249">			info-&gt;Init(thread, team, port, flags, &amp;ref, signature);</a>
<a name="ln250">			if (fullReg)</a>
<a name="ln251">				info-&gt;state = APP_STATE_REGISTERED;</a>
<a name="ln252">			else</a>
<a name="ln253">				info-&gt;state = APP_STATE_PRE_REGISTERED;</a>
<a name="ln254">			info-&gt;registration_time = system_time();</a>
<a name="ln255">			// add it to the right list</a>
<a name="ln256">			bool addingSuccess = false;</a>
<a name="ln257">			if (team &gt;= 0) {</a>
<a name="ln258">				PRINT(&quot;added ref: %&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;, %s\n&quot;,</a>
<a name="ln259">					info-&gt;ref.device, info-&gt;ref.directory, info-&gt;ref.name);</a>
<a name="ln260">				addingSuccess = (AddApp(info) == B_OK);</a>
<a name="ln261">				if (addingSuccess &amp;&amp; fullReg)</a>
<a name="ln262">					_AppAdded(info);</a>
<a name="ln263">			} else {</a>
<a name="ln264">				token = info-&gt;token = _NextToken();</a>
<a name="ln265">				addingSuccess = fEarlyPreRegisteredApps.AddInfo(info);</a>
<a name="ln266">				PRINT(&quot;added to early pre-regs, token: %&quot; B_PRIu32 &quot;\n&quot;, token);</a>
<a name="ln267">			}</a>
<a name="ln268">			if (!addingSuccess)</a>
<a name="ln269">				SET_ERROR(error, B_NO_MEMORY);</a>
<a name="ln270">		} else</a>
<a name="ln271">			SET_ERROR(error, B_NO_MEMORY);</a>
<a name="ln272">		// delete the info on failure</a>
<a name="ln273">		if (error != B_OK &amp;&amp; info)</a>
<a name="ln274">			delete info;</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	// reply to the request</a>
<a name="ln278">	if (error == B_OK) {</a>
<a name="ln279">		// add to recent apps if successful</a>
<a name="ln280">		if (signature &amp;&amp; signature[0] != '\0')</a>
<a name="ln281">			fRecentApps.Add(signature, flags);</a>
<a name="ln282">		else</a>
<a name="ln283">			fRecentApps.Add(&amp;ref, flags);</a>
<a name="ln284"> </a>
<a name="ln285">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln286">		// The token is valid only when no team ID has been supplied.</a>
<a name="ln287">		if (team &lt; 0)</a>
<a name="ln288">			reply.AddInt32(&quot;token&quot;, (int32)token);</a>
<a name="ln289">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln290">	} else {</a>
<a name="ln291">		BMessage reply(B_REG_ERROR);</a>
<a name="ln292">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln293">		if (otherTeam &gt;= 0)</a>
<a name="ln294">			reply.AddInt32(&quot;other_team&quot;, otherTeam);</a>
<a name="ln295">		if (token &gt; 0)</a>
<a name="ln296">			reply.AddInt32(&quot;token&quot;, (int32)token);</a>
<a name="ln297">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln298">	}</a>
<a name="ln299"> </a>
<a name="ln300">	FUNCTION_END();</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">/*!	\brief Handles a CompleteRegistration() request.</a>
<a name="ln305">	\param request The request message</a>
<a name="ln306">*/</a>
<a name="ln307">void</a>
<a name="ln308">TRoster::HandleCompleteRegistration(BMessage* request)</a>
<a name="ln309">{</a>
<a name="ln310">	FUNCTION_START();</a>
<a name="ln311"> </a>
<a name="ln312">	BAutolock _(fLock);</a>
<a name="ln313"> </a>
<a name="ln314">	status_t error = B_OK;</a>
<a name="ln315">	// get the parameters</a>
<a name="ln316">	team_id team;</a>
<a name="ln317">	thread_id thread;</a>
<a name="ln318">	port_id port;</a>
<a name="ln319">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln320">		team = -1;</a>
<a name="ln321">	if (request-&gt;FindInt32(&quot;thread&quot;, &amp;thread) != B_OK)</a>
<a name="ln322">		thread = -1;</a>
<a name="ln323">	if (request-&gt;FindInt32(&quot;port&quot;, &amp;port) != B_OK)</a>
<a name="ln324">		port = -1;</a>
<a name="ln325"> </a>
<a name="ln326">	if (fShuttingDown)</a>
<a name="ln327">		error = B_SHUTTING_DOWN;</a>
<a name="ln328"> </a>
<a name="ln329">	// check the parameters</a>
<a name="ln330">	// port</a>
<a name="ln331">	if (error == B_OK &amp;&amp; port &lt; 0)</a>
<a name="ln332">		SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln333"> </a>
<a name="ln334">	// thread</a>
<a name="ln335">	if (error == B_OK &amp;&amp; thread &lt; 0)</a>
<a name="ln336">		SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln337"> </a>
<a name="ln338">	// team</a>
<a name="ln339">	if (error == B_OK) {</a>
<a name="ln340">		if (team &gt;= 0) {</a>
<a name="ln341">			// everything is fine -- set the values</a>
<a name="ln342">			RosterAppInfo* info = fRegisteredApps.InfoFor(team);</a>
<a name="ln343">			if (info &amp;&amp; info-&gt;state == APP_STATE_PRE_REGISTERED) {</a>
<a name="ln344">				info-&gt;thread = thread;</a>
<a name="ln345">				info-&gt;port = port;</a>
<a name="ln346">				info-&gt;state = APP_STATE_REGISTERED;</a>
<a name="ln347">				_AppAdded(info);</a>
<a name="ln348">			} else</a>
<a name="ln349">				SET_ERROR(error, B_REG_APP_NOT_PRE_REGISTERED);</a>
<a name="ln350">		} else</a>
<a name="ln351">			SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln352">	}</a>
<a name="ln353"> </a>
<a name="ln354">	// reply to the request</a>
<a name="ln355">	if (error == B_OK) {</a>
<a name="ln356">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln357">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln358">	} else {</a>
<a name="ln359">		BMessage reply(B_REG_ERROR);</a>
<a name="ln360">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln361">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln362">	}</a>
<a name="ln363"> </a>
<a name="ln364">	FUNCTION_END();</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368">/*!	\brief Handles an IsAppRegistered() request.</a>
<a name="ln369">	\param request The request message</a>
<a name="ln370">*/</a>
<a name="ln371">void</a>
<a name="ln372">TRoster::HandleIsAppRegistered(BMessage* request)</a>
<a name="ln373">{</a>
<a name="ln374">	FUNCTION_START();</a>
<a name="ln375"> </a>
<a name="ln376">	BAutolock _(fLock);</a>
<a name="ln377"> </a>
<a name="ln378">	status_t error = B_OK;</a>
<a name="ln379">	// get the parameters</a>
<a name="ln380">	entry_ref ref;</a>
<a name="ln381">	team_id team;</a>
<a name="ln382">	uint32 token;</a>
<a name="ln383">	if (request-&gt;FindRef(&quot;ref&quot;, &amp;ref) != B_OK)</a>
<a name="ln384">		SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln385">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln386">		team = -1;</a>
<a name="ln387">	if (request-&gt;FindInt32(&quot;token&quot;, (int32*)&amp;token) != B_OK)</a>
<a name="ln388">		token = 0;</a>
<a name="ln389"> </a>
<a name="ln390">	PRINT(&quot;team: %&quot; B_PRId32 &quot;, token: %&quot; B_PRIu32 &quot;\n&quot;, team, token);</a>
<a name="ln391">	PRINT(&quot;ref: %&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;, %s\n&quot;, ref.device, ref.directory,</a>
<a name="ln392">		ref.name);</a>
<a name="ln393"> </a>
<a name="ln394">	// check the parameters</a>
<a name="ln395">	// entry_ref</a>
<a name="ln396">	if (error == B_OK &amp;&amp; !BEntry(&amp;ref).Exists())</a>
<a name="ln397">		SET_ERROR(error, B_ENTRY_NOT_FOUND);</a>
<a name="ln398">	// team/token</a>
<a name="ln399">	if (error == B_OK &amp;&amp; team &lt; 0 &amp;&amp; token == 0)</a>
<a name="ln400">		SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln401"> </a>
<a name="ln402">	// look up the information</a>
<a name="ln403">	RosterAppInfo* info = NULL;</a>
<a name="ln404">	if (error == B_OK) {</a>
<a name="ln405">		if ((info = fRegisteredApps.InfoFor(team)) != NULL) {</a>
<a name="ln406">			PRINT(&quot;found team in fRegisteredApps\n&quot;);</a>
<a name="ln407">			_ReplyToIARRequest(request, info);</a>
<a name="ln408">		} else if (token &gt; 0</a>
<a name="ln409">			&amp;&amp; (info = fEarlyPreRegisteredApps.InfoForToken(token)) != NULL) {</a>
<a name="ln410">			PRINT(&quot;found ref in fEarlyRegisteredApps (by token)\n&quot;);</a>
<a name="ln411">			// pre-registered and has no team ID assigned yet -- queue the</a>
<a name="ln412">			// request</a>
<a name="ln413">			be_app-&gt;DetachCurrentMessage();</a>
<a name="ln414">			_AddIARRequest(fIARRequestsByToken, token, request);</a>
<a name="ln415">		} else if (team &gt;= 0</a>
<a name="ln416">			&amp;&amp; (info = fEarlyPreRegisteredApps.InfoFor(&amp;ref)) != NULL) {</a>
<a name="ln417">			PRINT(&quot;found ref in fEarlyRegisteredApps (by ref)\n&quot;);</a>
<a name="ln418">			// pre-registered and has no team ID assigned yet -- queue the</a>
<a name="ln419">			// request</a>
<a name="ln420">			be_app-&gt;DetachCurrentMessage();</a>
<a name="ln421">			_AddIARRequest(fIARRequestsByID, team, request);</a>
<a name="ln422">		} else {</a>
<a name="ln423">			PRINT(&quot;didn't find team or ref\n&quot;);</a>
<a name="ln424">			// team not registered, ref/token not early pre-registered</a>
<a name="ln425">			_ReplyToIARRequest(request, NULL);</a>
<a name="ln426">		}</a>
<a name="ln427">	} else {</a>
<a name="ln428">		// reply to the request on error</a>
<a name="ln429">		BMessage reply(B_REG_ERROR);</a>
<a name="ln430">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln431">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln432">	}</a>
<a name="ln433"> </a>
<a name="ln434">	FUNCTION_END();</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">/*!	\brief Handles a RemovePreRegApp() request.</a>
<a name="ln439">	\param request The request message</a>
<a name="ln440">*/</a>
<a name="ln441">void</a>
<a name="ln442">TRoster::HandleRemovePreRegApp(BMessage* request)</a>
<a name="ln443">{</a>
<a name="ln444">	FUNCTION_START();</a>
<a name="ln445"> </a>
<a name="ln446">	BAutolock _(fLock);</a>
<a name="ln447"> </a>
<a name="ln448">	status_t error = B_OK;</a>
<a name="ln449">	// get the parameters</a>
<a name="ln450">	uint32 token;</a>
<a name="ln451">	if (request-&gt;FindInt32(&quot;token&quot;, (int32*)&amp;token) != B_OK)</a>
<a name="ln452">		SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln453">	// remove the app</a>
<a name="ln454">	if (error == B_OK) {</a>
<a name="ln455">		RosterAppInfo* info = fEarlyPreRegisteredApps.InfoForToken(token);</a>
<a name="ln456">		if (info) {</a>
<a name="ln457">			fEarlyPreRegisteredApps.RemoveInfo(info);</a>
<a name="ln458">			delete info;</a>
<a name="ln459">		} else</a>
<a name="ln460">			SET_ERROR(error, B_REG_APP_NOT_PRE_REGISTERED);</a>
<a name="ln461">	}</a>
<a name="ln462">	// reply to the request</a>
<a name="ln463">	if (error == B_OK) {</a>
<a name="ln464">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln465">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln466">	} else {</a>
<a name="ln467">		BMessage reply(B_REG_ERROR);</a>
<a name="ln468">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln469">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln470">	}</a>
<a name="ln471"> </a>
<a name="ln472">	FUNCTION_END();</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">/*!	\brief Handles a RemoveApp() request.</a>
<a name="ln477">	\param request The request message</a>
<a name="ln478">*/</a>
<a name="ln479">void</a>
<a name="ln480">TRoster::HandleRemoveApp(BMessage* request)</a>
<a name="ln481">{</a>
<a name="ln482">	FUNCTION_START();</a>
<a name="ln483"> </a>
<a name="ln484">	BAutolock _(fLock);</a>
<a name="ln485"> </a>
<a name="ln486">	status_t error = B_OK;</a>
<a name="ln487">	// get the parameters</a>
<a name="ln488">	team_id team;</a>
<a name="ln489">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln490">		team = -1;</a>
<a name="ln491"> </a>
<a name="ln492">	PRINT(&quot;team: %&quot; B_PRId32 &quot;\n&quot;, team);</a>
<a name="ln493"> </a>
<a name="ln494">	// remove the app</a>
<a name="ln495">	if (error == B_OK) {</a>
<a name="ln496">		if (RosterAppInfo* info = fRegisteredApps.InfoFor(team)) {</a>
<a name="ln497">			RemoveApp(info);</a>
<a name="ln498">			delete info;</a>
<a name="ln499">		} else</a>
<a name="ln500">			SET_ERROR(error, B_REG_APP_NOT_REGISTERED);</a>
<a name="ln501">	}</a>
<a name="ln502">	// reply to the request</a>
<a name="ln503">	if (error == B_OK) {</a>
<a name="ln504">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln505">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln506">	} else {</a>
<a name="ln507">		BMessage reply(B_REG_ERROR);</a>
<a name="ln508">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln509">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln510">	}</a>
<a name="ln511"> </a>
<a name="ln512">	FUNCTION_END();</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">/*!	\brief Handles a SetThreadAndTeam() request.</a>
<a name="ln517">	\param request The request message</a>
<a name="ln518">*/</a>
<a name="ln519">void</a>
<a name="ln520">TRoster::HandleSetThreadAndTeam(BMessage* request)</a>
<a name="ln521">{</a>
<a name="ln522">	FUNCTION_START();</a>
<a name="ln523"> </a>
<a name="ln524">	BAutolock _(fLock);</a>
<a name="ln525"> </a>
<a name="ln526">	status_t error = B_OK;</a>
<a name="ln527"> </a>
<a name="ln528">	// get the parameters</a>
<a name="ln529">	team_id team;</a>
<a name="ln530">	thread_id thread;</a>
<a name="ln531">	uint32 token;</a>
<a name="ln532">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln533">		team = -1;</a>
<a name="ln534">	if (request-&gt;FindInt32(&quot;thread&quot;, &amp;thread) != B_OK)</a>
<a name="ln535">		thread = -1;</a>
<a name="ln536">	if (request-&gt;FindInt32(&quot;token&quot;, (int32*)&amp;token) != B_OK)</a>
<a name="ln537">		SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln538"> </a>
<a name="ln539">	// check the parameters</a>
<a name="ln540">	// team</a>
<a name="ln541">	if (error == B_OK &amp;&amp; team &lt; 0)</a>
<a name="ln542">		SET_ERROR(error, B_BAD_VALUE);</a>
<a name="ln543"> </a>
<a name="ln544">	PRINT(&quot;team: %&quot; B_PRId32 &quot;, thread: %&quot; B_PRId32 &quot;, token: %&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln545">		team, thread, token);</a>
<a name="ln546"> </a>
<a name="ln547">	port_id port = -1;</a>
<a name="ln548"> </a>
<a name="ln549">	// update the app_info</a>
<a name="ln550">	if (error == B_OK) {</a>
<a name="ln551">		RosterAppInfo* info = fEarlyPreRegisteredApps.InfoForToken(token);</a>
<a name="ln552">		if (info != NULL) {</a>
<a name="ln553">			// Set thread and team, create a port for the application and</a>
<a name="ln554">			// move the app_info from the list of the early pre-registered</a>
<a name="ln555">			// apps to the list of the (pre-)registered apps.</a>
<a name="ln556">			fEarlyPreRegisteredApps.RemoveInfo(info);</a>
<a name="ln557">			info-&gt;team = team;</a>
<a name="ln558">			info-&gt;thread = thread;</a>
<a name="ln559">			// create and transfer the port</a>
<a name="ln560">			info-&gt;port = port = create_port(B_REG_APP_LOOPER_PORT_CAPACITY,</a>
<a name="ln561">				kRAppLooperPortName);</a>
<a name="ln562">			if (info-&gt;port &lt; 0)</a>
<a name="ln563">				SET_ERROR(error, info-&gt;port);</a>
<a name="ln564">			if (error == B_OK)</a>
<a name="ln565">				SET_ERROR(error, set_port_owner(info-&gt;port, team));</a>
<a name="ln566">			// add the info to the registered apps list</a>
<a name="ln567">			if (error == B_OK)</a>
<a name="ln568">				SET_ERROR(error, AddApp(info));</a>
<a name="ln569">			// cleanup on failure</a>
<a name="ln570">			if (error != B_OK) {</a>
<a name="ln571">				if (info-&gt;port &gt;= 0)</a>
<a name="ln572">					delete_port(info-&gt;port);</a>
<a name="ln573">				delete info;</a>
<a name="ln574">				info = NULL;</a>
<a name="ln575">			}</a>
<a name="ln576">			// handle pending IsAppRegistered() requests</a>
<a name="ln577">			IARRequestMap::iterator it = fIARRequestsByID.find(team);</a>
<a name="ln578">			if (it != fIARRequestsByID.end()) {</a>
<a name="ln579">				BMessageQueue* requests = it-&gt;second;</a>
<a name="ln580">				if (error == B_OK)</a>
<a name="ln581">					_ReplyToIARRequests(requests, info);</a>
<a name="ln582">				delete requests;</a>
<a name="ln583">				fIARRequestsByID.erase(it);</a>
<a name="ln584">			}</a>
<a name="ln585"> </a>
<a name="ln586">			it = fIARRequestsByToken.find((int32)token);</a>
<a name="ln587">			if (it != fIARRequestsByToken.end()) {</a>
<a name="ln588">				BMessageQueue* requests = it-&gt;second;</a>
<a name="ln589">				if (error == B_OK)</a>
<a name="ln590">					_ReplyToIARRequests(requests, info);</a>
<a name="ln591">				delete requests;</a>
<a name="ln592">				fIARRequestsByToken.erase(it);</a>
<a name="ln593">			}</a>
<a name="ln594">		} else</a>
<a name="ln595">			SET_ERROR(error, B_REG_APP_NOT_PRE_REGISTERED);</a>
<a name="ln596">	}</a>
<a name="ln597">	// reply to the request</a>
<a name="ln598">	if (error == B_OK) {</a>
<a name="ln599">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln600">		reply.AddInt32(&quot;port&quot;, port);</a>
<a name="ln601">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln602">	} else {</a>
<a name="ln603">		BMessage reply(B_REG_ERROR);</a>
<a name="ln604">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln605">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln606">	}</a>
<a name="ln607"> </a>
<a name="ln608">	FUNCTION_END();</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611"> </a>
<a name="ln612">/*!	\brief Handles a SetSignature() request.</a>
<a name="ln613">	\param request The request message</a>
<a name="ln614">*/</a>
<a name="ln615">void</a>
<a name="ln616">TRoster::HandleSetSignature(BMessage* request)</a>
<a name="ln617">{</a>
<a name="ln618">	FUNCTION_START();</a>
<a name="ln619"> </a>
<a name="ln620">	BAutolock _(fLock);</a>
<a name="ln621"> </a>
<a name="ln622">	status_t error = B_OK;</a>
<a name="ln623">	// get the parameters</a>
<a name="ln624">	team_id team;</a>
<a name="ln625">	const char* signature;</a>
<a name="ln626">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln627">		error = B_BAD_VALUE;</a>
<a name="ln628">	if (request-&gt;FindString(&quot;signature&quot;, &amp;signature) != B_OK)</a>
<a name="ln629">		error = B_BAD_VALUE;</a>
<a name="ln630">	// find the app and set the signature</a>
<a name="ln631">	if (error == B_OK) {</a>
<a name="ln632">		if (RosterAppInfo* info = fRegisteredApps.InfoFor(team))</a>
<a name="ln633">			strcpy(info-&gt;signature, signature);</a>
<a name="ln634">		else</a>
<a name="ln635">			SET_ERROR(error, B_REG_APP_NOT_REGISTERED);</a>
<a name="ln636">	}</a>
<a name="ln637">	// reply to the request</a>
<a name="ln638">	if (error == B_OK) {</a>
<a name="ln639">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln640">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln641">	} else {</a>
<a name="ln642">		BMessage reply(B_REG_ERROR);</a>
<a name="ln643">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln644">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln645">	}</a>
<a name="ln646"> </a>
<a name="ln647">	FUNCTION_END();</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650"> </a>
<a name="ln651">/*!	\brief Handles a Get{Running,Active,}AppInfo() request.</a>
<a name="ln652">	\param request The request message</a>
<a name="ln653">*/</a>
<a name="ln654">void</a>
<a name="ln655">TRoster::HandleGetAppInfo(BMessage* request)</a>
<a name="ln656">{</a>
<a name="ln657">	FUNCTION_START();</a>
<a name="ln658"> </a>
<a name="ln659">	BAutolock _(fLock);</a>
<a name="ln660"> </a>
<a name="ln661">	status_t error = B_OK;</a>
<a name="ln662">	// get the parameters</a>
<a name="ln663">	team_id team;</a>
<a name="ln664">	entry_ref ref;</a>
<a name="ln665">	const char* signature;</a>
<a name="ln666">	bool hasTeam = true;</a>
<a name="ln667">	bool hasRef = true;</a>
<a name="ln668">	bool hasSignature = true;</a>
<a name="ln669">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln670">		hasTeam = false;</a>
<a name="ln671">	if (request-&gt;FindRef(&quot;ref&quot;, &amp;ref) != B_OK)</a>
<a name="ln672">		hasRef = false;</a>
<a name="ln673">	if (request-&gt;FindString(&quot;signature&quot;, &amp;signature) != B_OK)</a>
<a name="ln674">		hasSignature = false;</a>
<a name="ln675"> </a>
<a name="ln676">if (hasTeam)</a>
<a name="ln677">PRINT(&quot;team: %&quot; B_PRId32 &quot;\n&quot;, team);</a>
<a name="ln678">if (hasRef)</a>
<a name="ln679">PRINT(&quot;ref: %&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;, %s\n&quot;, ref.device, ref.directory,</a>
<a name="ln680">	ref.name);</a>
<a name="ln681">if (hasSignature)</a>
<a name="ln682">PRINT(&quot;signature: %s\n&quot;, signature);</a>
<a name="ln683"> </a>
<a name="ln684">	// get the info</a>
<a name="ln685">	RosterAppInfo* info = NULL;</a>
<a name="ln686">	if (error == B_OK) {</a>
<a name="ln687">		if (hasTeam) {</a>
<a name="ln688">			info = fRegisteredApps.InfoFor(team);</a>
<a name="ln689">			if (info == NULL)</a>
<a name="ln690">				SET_ERROR(error, B_BAD_TEAM_ID);</a>
<a name="ln691">		} else if (hasRef) {</a>
<a name="ln692">			info = fRegisteredApps.InfoFor(&amp;ref);</a>
<a name="ln693">			if (info == NULL)</a>
<a name="ln694">				SET_ERROR(error, B_ERROR);</a>
<a name="ln695">		} else if (hasSignature) {</a>
<a name="ln696">			info = fRegisteredApps.InfoFor(signature);</a>
<a name="ln697">			if (info == NULL)</a>
<a name="ln698">				SET_ERROR(error, B_ERROR);</a>
<a name="ln699">		} else {</a>
<a name="ln700">			// If neither of those has been supplied, the active application</a>
<a name="ln701">			// info is requested.</a>
<a name="ln702">			if (fActiveApp)</a>
<a name="ln703">				info = fActiveApp;</a>
<a name="ln704">			else</a>
<a name="ln705">				SET_ERROR(error, B_ERROR);</a>
<a name="ln706">		}</a>
<a name="ln707">	}</a>
<a name="ln708">	// reply to the request</a>
<a name="ln709">	if (error == B_OK) {</a>
<a name="ln710">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln711">		_AddMessageAppInfo(&amp;reply, info);</a>
<a name="ln712">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln713">	} else {</a>
<a name="ln714">		BMessage reply(B_REG_ERROR);</a>
<a name="ln715">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln716">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln717">	}</a>
<a name="ln718"> </a>
<a name="ln719">	FUNCTION_END();</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">/*!	\brief Handles a GetAppList() request.</a>
<a name="ln724">	\param request The request message</a>
<a name="ln725">*/</a>
<a name="ln726">void</a>
<a name="ln727">TRoster::HandleGetAppList(BMessage* request)</a>
<a name="ln728">{</a>
<a name="ln729">	FUNCTION_START();</a>
<a name="ln730"> </a>
<a name="ln731">	BAutolock _(fLock);</a>
<a name="ln732"> </a>
<a name="ln733">	status_t error = B_OK;</a>
<a name="ln734">	// get the parameters</a>
<a name="ln735">	const char* signature;</a>
<a name="ln736">	if (request-&gt;FindString(&quot;signature&quot;, &amp;signature) != B_OK)</a>
<a name="ln737">		signature = NULL;</a>
<a name="ln738">	// reply to the request</a>
<a name="ln739">	if (error == B_OK) {</a>
<a name="ln740">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln741">		// get the list</a>
<a name="ln742">		for (AppInfoList::Iterator it(fRegisteredApps.It());</a>
<a name="ln743">			 RosterAppInfo* info = *it;</a>
<a name="ln744">			 ++it) {</a>
<a name="ln745">			if (info-&gt;state != APP_STATE_REGISTERED)</a>
<a name="ln746">				continue;</a>
<a name="ln747">			if (!signature || !strcasecmp(signature, info-&gt;signature))</a>
<a name="ln748">				reply.AddInt32(&quot;teams&quot;, info-&gt;team);</a>
<a name="ln749">		}</a>
<a name="ln750">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln751">	} else {</a>
<a name="ln752">		BMessage reply(B_REG_ERROR);</a>
<a name="ln753">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln754">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln755">	}</a>
<a name="ln756"> </a>
<a name="ln757">	FUNCTION_END();</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760"> </a>
<a name="ln761">/*!	\brief Handles a _UpdateActiveApp() request.</a>
<a name="ln762"> </a>
<a name="ln763">	This is sent from the app_server when the current active application</a>
<a name="ln764">	is changed.</a>
<a name="ln765"> </a>
<a name="ln766">	\param request The request message</a>
<a name="ln767">*/</a>
<a name="ln768">void</a>
<a name="ln769">TRoster::HandleUpdateActiveApp(BMessage* request)</a>
<a name="ln770">{</a>
<a name="ln771">	FUNCTION_START();</a>
<a name="ln772"> </a>
<a name="ln773">	BAutolock _(fLock);</a>
<a name="ln774"> </a>
<a name="ln775">	// get the parameters</a>
<a name="ln776">	status_t error = B_OK;</a>
<a name="ln777">	team_id team;</a>
<a name="ln778">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln779">		error = B_BAD_VALUE;</a>
<a name="ln780"> </a>
<a name="ln781">	// activate the app</a>
<a name="ln782">	if (error == B_OK) {</a>
<a name="ln783">		if (RosterAppInfo* info = fRegisteredApps.InfoFor(team))</a>
<a name="ln784">			UpdateActiveApp(info);</a>
<a name="ln785">		else</a>
<a name="ln786">			error = B_BAD_TEAM_ID;</a>
<a name="ln787">	}</a>
<a name="ln788"> </a>
<a name="ln789">	// reply to the request</a>
<a name="ln790">	if (request-&gt;IsSourceWaiting()) {</a>
<a name="ln791">		if (error == B_OK) {</a>
<a name="ln792">			BMessage reply(B_REG_SUCCESS);</a>
<a name="ln793">			request-&gt;SendReply(&amp;reply);</a>
<a name="ln794">		} else {</a>
<a name="ln795">			BMessage reply(B_REG_ERROR);</a>
<a name="ln796">			reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln797">			request-&gt;SendReply(&amp;reply);</a>
<a name="ln798">		}</a>
<a name="ln799">	}</a>
<a name="ln800"> </a>
<a name="ln801">	FUNCTION_END();</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804"> </a>
<a name="ln805">/*!	\brief Handles a Broadcast() request.</a>
<a name="ln806">	\param request The request message</a>
<a name="ln807">*/</a>
<a name="ln808">void</a>
<a name="ln809">TRoster::HandleBroadcast(BMessage* request)</a>
<a name="ln810">{</a>
<a name="ln811">	FUNCTION_START();</a>
<a name="ln812"> </a>
<a name="ln813">	BAutolock _(fLock);</a>
<a name="ln814"> </a>
<a name="ln815">	status_t error = B_OK;</a>
<a name="ln816">	// get the parameters</a>
<a name="ln817">	team_id team;</a>
<a name="ln818">	BMessage message;</a>
<a name="ln819">	BMessenger replyTarget;</a>
<a name="ln820">	if (request-&gt;FindInt32(&quot;team&quot;, &amp;team) != B_OK)</a>
<a name="ln821">		team = -1;</a>
<a name="ln822">	if (error == B_OK &amp;&amp; request-&gt;FindMessage(&quot;message&quot;, &amp;message) != B_OK)</a>
<a name="ln823">		error = B_BAD_VALUE;</a>
<a name="ln824">	if (error == B_OK</a>
<a name="ln825">		&amp;&amp; request-&gt;FindMessenger(&quot;reply_target&quot;, &amp;replyTarget) != B_OK) {</a>
<a name="ln826">		error = B_BAD_VALUE;</a>
<a name="ln827">	}</a>
<a name="ln828"> </a>
<a name="ln829">	// reply to the request -- do this first, don't let the inquirer wait</a>
<a name="ln830">	if (error == B_OK) {</a>
<a name="ln831">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln832">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln833">	} else {</a>
<a name="ln834">		BMessage reply(B_REG_ERROR);</a>
<a name="ln835">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln836">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln837">	}</a>
<a name="ln838"> </a>
<a name="ln839">	// broadcast the message</a>
<a name="ln840">	if (error == B_OK) {</a>
<a name="ln841">		// the target set (excludes the registrar and the requesting team)</a>
<a name="ln842">		class BroadcastMessagingTargetSet</a>
<a name="ln843">			: public AppInfoListMessagingTargetSet {</a>
<a name="ln844">			public:</a>
<a name="ln845">				BroadcastMessagingTargetSet(AppInfoList&amp; list, team_id team)</a>
<a name="ln846">					: AppInfoListMessagingTargetSet(list, true),</a>
<a name="ln847">					  fTeam(team)</a>
<a name="ln848">				{</a>
<a name="ln849">				}</a>
<a name="ln850"> </a>
<a name="ln851">				virtual bool Filter(const RosterAppInfo* info)</a>
<a name="ln852">				{</a>
<a name="ln853">					return AppInfoListMessagingTargetSet::Filter(info)</a>
<a name="ln854">						&amp;&amp; (info-&gt;team != fTeam);</a>
<a name="ln855">				}</a>
<a name="ln856"> </a>
<a name="ln857">			private:</a>
<a name="ln858">				team_id	fTeam;</a>
<a name="ln859">		} targetSet(fRegisteredApps, team);</a>
<a name="ln860"> </a>
<a name="ln861">		if (targetSet.HasNext()) {</a>
<a name="ln862">			// set the reply target</a>
<a name="ln863">			BMessage::Private(message).SetReply(replyTarget);</a>
<a name="ln864"> </a>
<a name="ln865">			// send the messages</a>
<a name="ln866">			MessageDeliverer::Default()-&gt;DeliverMessage(&amp;message, targetSet);</a>
<a name="ln867">		}</a>
<a name="ln868">	}</a>
<a name="ln869"> </a>
<a name="ln870">	FUNCTION_END();</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873"> </a>
<a name="ln874">/*!	\brief Handles a StartWatching() request.</a>
<a name="ln875">	\param request The request message</a>
<a name="ln876">*/</a>
<a name="ln877">void</a>
<a name="ln878">TRoster::HandleStartWatching(BMessage* request)</a>
<a name="ln879">{</a>
<a name="ln880">	FUNCTION_START();</a>
<a name="ln881"> </a>
<a name="ln882">	BAutolock _(fLock);</a>
<a name="ln883"> </a>
<a name="ln884">	status_t error = B_OK;</a>
<a name="ln885">	// get the parameters</a>
<a name="ln886">	BMessenger target;</a>
<a name="ln887">	uint32 events;</a>
<a name="ln888">	if (error == B_OK &amp;&amp; request-&gt;FindMessenger(&quot;target&quot;, &amp;target) != B_OK)</a>
<a name="ln889">		error = B_BAD_VALUE;</a>
<a name="ln890">	if (request-&gt;FindInt32(&quot;events&quot;, (int32*)&amp;events) != B_OK)</a>
<a name="ln891">		error = B_BAD_VALUE;</a>
<a name="ln892">	// add the new watcher</a>
<a name="ln893">	if (error == B_OK) {</a>
<a name="ln894">		Watcher* watcher = new(nothrow) EventMaskWatcher(target, events);</a>
<a name="ln895">		if (watcher) {</a>
<a name="ln896">			if (!fWatchingService.AddWatcher(watcher)) {</a>
<a name="ln897">				error = B_NO_MEMORY;</a>
<a name="ln898">				delete watcher;</a>
<a name="ln899">			}</a>
<a name="ln900">		} else</a>
<a name="ln901">			error = B_NO_MEMORY;</a>
<a name="ln902">	}</a>
<a name="ln903">	// reply to the request</a>
<a name="ln904">	if (error == B_OK) {</a>
<a name="ln905">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln906">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln907">	} else {</a>
<a name="ln908">		BMessage reply(B_REG_ERROR);</a>
<a name="ln909">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln910">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln911">	}</a>
<a name="ln912"> </a>
<a name="ln913">	FUNCTION_END();</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">/*!	\brief Handles a StopWatching() request.</a>
<a name="ln918">	\param request The request message</a>
<a name="ln919">*/</a>
<a name="ln920">void</a>
<a name="ln921">TRoster::HandleStopWatching(BMessage* request)</a>
<a name="ln922">{</a>
<a name="ln923">	FUNCTION_START();</a>
<a name="ln924"> </a>
<a name="ln925">	BAutolock _(fLock);</a>
<a name="ln926"> </a>
<a name="ln927">	status_t error = B_OK;</a>
<a name="ln928">	// get the parameters</a>
<a name="ln929">	BMessenger target;</a>
<a name="ln930">	if (error == B_OK &amp;&amp; request-&gt;FindMessenger(&quot;target&quot;, &amp;target) != B_OK)</a>
<a name="ln931">		error = B_BAD_VALUE;</a>
<a name="ln932">	// remove the watcher</a>
<a name="ln933">	if (error == B_OK) {</a>
<a name="ln934">		if (!fWatchingService.RemoveWatcher(target))</a>
<a name="ln935">			error = B_BAD_VALUE;</a>
<a name="ln936">	}</a>
<a name="ln937">	// reply to the request</a>
<a name="ln938">	if (error == B_OK) {</a>
<a name="ln939">		BMessage reply(B_REG_SUCCESS);</a>
<a name="ln940">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln941">	} else {</a>
<a name="ln942">		BMessage reply(B_REG_ERROR);</a>
<a name="ln943">		reply.AddInt32(&quot;error&quot;, error);</a>
<a name="ln944">		request-&gt;SendReply(&amp;reply);</a>
<a name="ln945">	}</a>
<a name="ln946"> </a>
<a name="ln947">	FUNCTION_END();</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950"> </a>
<a name="ln951">/*!	\brief Handles a GetRecentDocuments() request.</a>
<a name="ln952">	\param request The request message</a>
<a name="ln953">*/</a>
<a name="ln954">void</a>
<a name="ln955">TRoster::HandleGetRecentDocuments(BMessage* request)</a>
<a name="ln956">{</a>
<a name="ln957">	FUNCTION_START();</a>
<a name="ln958"> </a>
<a name="ln959">	BAutolock _(fLock);</a>
<a name="ln960"> </a>
<a name="ln961">	_HandleGetRecentEntries(request);</a>
<a name="ln962"> </a>
<a name="ln963">	FUNCTION_END();</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966"> </a>
<a name="ln967">/*!	\brief Handles a GetRecentFolders() request.</a>
<a name="ln968">	\param request The request message</a>
<a name="ln969">*/</a>
<a name="ln970">void</a>
<a name="ln971">TRoster::HandleGetRecentFolders(BMessage* request)</a>
<a name="ln972">{</a>
<a name="ln973">	FUNCTION_START();</a>
<a name="ln974"> </a>
<a name="ln975">	BAutolock _(fLock);</a>
<a name="ln976"> </a>
<a name="ln977">	_HandleGetRecentEntries(request);</a>
<a name="ln978"> </a>
<a name="ln979">	FUNCTION_END();</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982"> </a>
<a name="ln983">/*!	\brief Handles a GetRecentApps() request.</a>
<a name="ln984">	\param request The request message</a>
<a name="ln985">*/</a>
<a name="ln986">void</a>
<a name="ln987">TRoster::HandleGetRecentApps(BMessage* request)</a>
<a name="ln988">{</a>
<a name="ln989">	FUNCTION_START();</a>
<a name="ln990"> </a>
<a name="ln991">	BAutolock _(fLock);</a>
<a name="ln992"> </a>
<a name="ln993">	if (!request) {</a>
<a name="ln994">		D(PRINT(&quot;WARNING: TRoster::HandleGetRecentApps(NULL) called\n&quot;));</a>
<a name="ln995">		return;</a>
<a name="ln996">	}</a>
<a name="ln997"> </a>
<a name="ln998">	int32 maxCount;</a>
<a name="ln999">	BMessage reply(B_REG_RESULT);</a>
<a name="ln1000"> </a>
<a name="ln1001">	status_t error = request-&gt;FindInt32(&quot;max count&quot;, &amp;maxCount);</a>
<a name="ln1002">	if (!error)</a>
<a name="ln1003">		error = fRecentApps.Get(maxCount, &amp;reply);</a>
<a name="ln1004">	reply.AddInt32(&quot;result&quot;, error);</a>
<a name="ln1005">	request-&gt;SendReply(&amp;reply);</a>
<a name="ln1006"> </a>
<a name="ln1007">	FUNCTION_END();</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010"> </a>
<a name="ln1011">/*!	\brief Handles an AddToRecentDocuments() request.</a>
<a name="ln1012">	\param request The request message</a>
<a name="ln1013">*/</a>
<a name="ln1014">void</a>
<a name="ln1015">TRoster::HandleAddToRecentDocuments(BMessage* request)</a>
<a name="ln1016">{</a>
<a name="ln1017">	FUNCTION_START();</a>
<a name="ln1018"> </a>
<a name="ln1019">	BAutolock _(fLock);</a>
<a name="ln1020"> </a>
<a name="ln1021">	if (!request) {</a>
<a name="ln1022">		D(PRINT(&quot;WARNING: TRoster::HandleAddToRecentDocuments(NULL) called\n&quot;));</a>
<a name="ln1023">		return;</a>
<a name="ln1024">	}</a>
<a name="ln1025"> </a>
<a name="ln1026">	entry_ref ref;</a>
<a name="ln1027">	const char* appSig;</a>
<a name="ln1028">	BMessage reply(B_REG_RESULT);</a>
<a name="ln1029"> </a>
<a name="ln1030">	status_t error = request-&gt;FindRef(&quot;ref&quot;, &amp;ref);</a>
<a name="ln1031">	if (!error)</a>
<a name="ln1032">		error = request-&gt;FindString(&quot;app sig&quot;, &amp;appSig);</a>
<a name="ln1033">	if (!error)</a>
<a name="ln1034">		error = fRecentDocuments.Add(&amp;ref, appSig);</a>
<a name="ln1035">	reply.AddInt32(&quot;result&quot;, error);</a>
<a name="ln1036">	request-&gt;SendReply(&amp;reply);</a>
<a name="ln1037"> </a>
<a name="ln1038">	FUNCTION_END();</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041"> </a>
<a name="ln1042">/*!	\brief Handles an AddToRecentFolders() request.</a>
<a name="ln1043">	\param request The request message</a>
<a name="ln1044">*/</a>
<a name="ln1045">void</a>
<a name="ln1046">TRoster::HandleAddToRecentFolders(BMessage* request)</a>
<a name="ln1047">{</a>
<a name="ln1048">	FUNCTION_START();</a>
<a name="ln1049"> </a>
<a name="ln1050">	BAutolock _(fLock);</a>
<a name="ln1051"> </a>
<a name="ln1052">	if (!request) {</a>
<a name="ln1053">		D(PRINT(&quot;WARNING: TRoster::HandleAddToRecentFolders(NULL) called\n&quot;));</a>
<a name="ln1054">		return;</a>
<a name="ln1055">	}</a>
<a name="ln1056"> </a>
<a name="ln1057">	entry_ref ref;</a>
<a name="ln1058">	const char* appSig;</a>
<a name="ln1059">	BMessage reply(B_REG_RESULT);</a>
<a name="ln1060"> </a>
<a name="ln1061">	status_t error = request-&gt;FindRef(&quot;ref&quot;, &amp;ref);</a>
<a name="ln1062">	if (!error)</a>
<a name="ln1063">		error = request-&gt;FindString(&quot;app sig&quot;, &amp;appSig);</a>
<a name="ln1064">	if (!error)</a>
<a name="ln1065">		error = fRecentFolders.Add(&amp;ref, appSig);</a>
<a name="ln1066">	reply.AddInt32(&quot;result&quot;, error);</a>
<a name="ln1067">	request-&gt;SendReply(&amp;reply);</a>
<a name="ln1068"> </a>
<a name="ln1069">	FUNCTION_END();</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072"> </a>
<a name="ln1073">/*!	\brief Handles an AddToRecentApps() request.</a>
<a name="ln1074">	\param request The request message</a>
<a name="ln1075">*/</a>
<a name="ln1076">void</a>
<a name="ln1077">TRoster::HandleAddToRecentApps(BMessage* request)</a>
<a name="ln1078">{</a>
<a name="ln1079">	FUNCTION_START();</a>
<a name="ln1080"> </a>
<a name="ln1081">	BAutolock _(fLock);</a>
<a name="ln1082"> </a>
<a name="ln1083">	if (!request) {</a>
<a name="ln1084">		D(PRINT(&quot;WARNING: TRoster::HandleAddToRecentApps(NULL) called\n&quot;));</a>
<a name="ln1085">		return;</a>
<a name="ln1086">	}</a>
<a name="ln1087"> </a>
<a name="ln1088">	const char* appSig;</a>
<a name="ln1089">	BMessage reply(B_REG_RESULT);</a>
<a name="ln1090"> </a>
<a name="ln1091">	status_t error = request-&gt;FindString(&quot;app sig&quot;, &amp;appSig);</a>
<a name="ln1092">	if (!error)</a>
<a name="ln1093">		error = fRecentApps.Add(appSig);</a>
<a name="ln1094">	reply.AddInt32(&quot;result&quot;, error);</a>
<a name="ln1095">	request-&gt;SendReply(&amp;reply);</a>
<a name="ln1096"> </a>
<a name="ln1097">	FUNCTION_END();</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100"> </a>
<a name="ln1101">void</a>
<a name="ln1102">TRoster::HandleLoadRecentLists(BMessage* request)</a>
<a name="ln1103">{</a>
<a name="ln1104">	FUNCTION_START();</a>
<a name="ln1105"> </a>
<a name="ln1106">	BAutolock _(fLock);</a>
<a name="ln1107"> </a>
<a name="ln1108">	if (!request) {</a>
<a name="ln1109">		D(PRINT(&quot;WARNING: TRoster::HandleLoadRecentLists(NULL) called\n&quot;));</a>
<a name="ln1110">		return;</a>
<a name="ln1111">	}</a>
<a name="ln1112"> </a>
<a name="ln1113">	const char* filename;</a>
<a name="ln1114">	BMessage reply(B_REG_RESULT);</a>
<a name="ln1115"> </a>
<a name="ln1116">	status_t error = request-&gt;FindString(&quot;filename&quot;, &amp;filename);</a>
<a name="ln1117">	if (!error)</a>
<a name="ln1118">		error = _LoadRosterSettings(filename);</a>
<a name="ln1119">	reply.AddInt32(&quot;result&quot;, error);</a>
<a name="ln1120">	request-&gt;SendReply(&amp;reply);</a>
<a name="ln1121"> </a>
<a name="ln1122">	FUNCTION_END();</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">void</a>
<a name="ln1127">TRoster::HandleSaveRecentLists(BMessage* request)</a>
<a name="ln1128">{</a>
<a name="ln1129">	FUNCTION_START();</a>
<a name="ln1130"> </a>
<a name="ln1131">	BAutolock _(fLock);</a>
<a name="ln1132"> </a>
<a name="ln1133">	if (!request) {</a>
<a name="ln1134">		D(PRINT(&quot;WARNING: TRoster::HandleSaveRecentLists(NULL) called\n&quot;));</a>
<a name="ln1135">		return;</a>
<a name="ln1136">	}</a>
<a name="ln1137"> </a>
<a name="ln1138">	const char* filename;</a>
<a name="ln1139">	BMessage reply(B_REG_RESULT);</a>
<a name="ln1140"> </a>
<a name="ln1141">	status_t error = request-&gt;FindString(&quot;filename&quot;, &amp;filename);</a>
<a name="ln1142">	if (!error)</a>
<a name="ln1143">		error = _SaveRosterSettings(filename);</a>
<a name="ln1144">	reply.AddInt32(&quot;result&quot;, error);</a>
<a name="ln1145">	request-&gt;SendReply(&amp;reply);</a>
<a name="ln1146"> </a>
<a name="ln1147">	FUNCTION_END();</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150"> </a>
<a name="ln1151">void</a>
<a name="ln1152">TRoster::HandleRestartAppServer(BMessage* request)</a>
<a name="ln1153">{</a>
<a name="ln1154">	BAutolock _(fLock);</a>
<a name="ln1155"> </a>
<a name="ln1156">	// TODO: if an app_server is still running, stop it first</a>
<a name="ln1157"> </a>
<a name="ln1158">	const char* pathString;</a>
<a name="ln1159">	if (request-&gt;FindString(&quot;path&quot;, &amp;pathString) != B_OK)</a>
<a name="ln1160">		pathString = &quot;/boot/system/servers&quot;;</a>
<a name="ln1161">	BPath path(pathString);</a>
<a name="ln1162">	path.Append(&quot;app_server&quot;);</a>
<a name="ln1163">	// NOTE: its required at some point that the binary name is &quot;app_server&quot;</a>
<a name="ln1164"> </a>
<a name="ln1165">	const char **argv = new const char * [2];</a>
<a name="ln1166">	argv[0] = strdup(path.Path());</a>
<a name="ln1167">	argv[1] = NULL;</a>
<a name="ln1168"> </a>
<a name="ln1169">	thread_id threadId = load_image(1, argv, (const char**)environ);</a>
<a name="ln1170">	int i;</a>
<a name="ln1171">	for (i = 0; i &lt; 1; i++)</a>
<a name="ln1172">		delete argv[i];</a>
<a name="ln1173">	delete [] argv;</a>
<a name="ln1174"> </a>
<a name="ln1175">	resume_thread(threadId);</a>
<a name="ln1176">	// give the server some time to create the server port</a>
<a name="ln1177">	snooze(100000);</a>
<a name="ln1178"> </a>
<a name="ln1179">	// notify all apps</a>
<a name="ln1180">	// TODO: whats about ourself?</a>
<a name="ln1181">	AppInfoListMessagingTargetSet targetSet(fRegisteredApps);</a>
<a name="ln1182">	if (targetSet.HasNext()) {</a>
<a name="ln1183">		// send the messages</a>
<a name="ln1184">		BMessage message(kMsgAppServerRestarted);</a>
<a name="ln1185">		MessageDeliverer::Default()-&gt;DeliverMessage(&amp;message, targetSet);</a>
<a name="ln1186">	}</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189"> </a>
<a name="ln1190">/*!	\brief Clears the current list of recent documents</a>
<a name="ln1191">*/</a>
<a name="ln1192">void</a>
<a name="ln1193">TRoster::ClearRecentDocuments()</a>
<a name="ln1194">{</a>
<a name="ln1195">	BAutolock _(fLock);</a>
<a name="ln1196"> </a>
<a name="ln1197">	fRecentDocuments.Clear();</a>
<a name="ln1198">}</a>
<a name="ln1199"> </a>
<a name="ln1200"> </a>
<a name="ln1201">/*!	\brief Clears the current list of recent folders</a>
<a name="ln1202">*/</a>
<a name="ln1203">void</a>
<a name="ln1204">TRoster::ClearRecentFolders()</a>
<a name="ln1205">{</a>
<a name="ln1206">	BAutolock _(fLock);</a>
<a name="ln1207"> </a>
<a name="ln1208">	fRecentFolders.Clear();</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211"> </a>
<a name="ln1212">/*!	\brief Clears the current list of recent apps</a>
<a name="ln1213">*/</a>
<a name="ln1214">void</a>
<a name="ln1215">TRoster::ClearRecentApps()</a>
<a name="ln1216">{</a>
<a name="ln1217">	BAutolock _(fLock);</a>
<a name="ln1218"> </a>
<a name="ln1219">	fRecentApps.Clear();</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222"> </a>
<a name="ln1223">/*!	\brief Initializes the roster.</a>
<a name="ln1224"> </a>
<a name="ln1225">	Currently only adds the registrar to the roster.</a>
<a name="ln1226">	The application must already be running, more precisly Run() must have</a>
<a name="ln1227">	been called.</a>
<a name="ln1228"> </a>
<a name="ln1229">	\return</a>
<a name="ln1230">	- \c B_OK: Everything went fine.</a>
<a name="ln1231">	- an error code</a>
<a name="ln1232">*/</a>
<a name="ln1233">status_t</a>
<a name="ln1234">TRoster::Init()</a>
<a name="ln1235">{</a>
<a name="ln1236">	// check lock initialization</a>
<a name="ln1237">	if (fLock.Sem() &lt; 0)</a>
<a name="ln1238">		return fLock.Sem();</a>
<a name="ln1239"> </a>
<a name="ln1240">	// create the info</a>
<a name="ln1241">	RosterAppInfo* info = new(nothrow) RosterAppInfo;</a>
<a name="ln1242">	if (info == NULL)</a>
<a name="ln1243">		return B_NO_MEMORY;</a>
<a name="ln1244"> </a>
<a name="ln1245">	// get the app's ref</a>
<a name="ln1246">	entry_ref ref;</a>
<a name="ln1247">	status_t error = get_app_ref(&amp;ref);</a>
<a name="ln1248"> </a>
<a name="ln1249">	// init and add the info</a>
<a name="ln1250">	if (error == B_OK) {</a>
<a name="ln1251">		info-&gt;Init(be_app-&gt;Thread(), be_app-&gt;Team(),</a>
<a name="ln1252">			BMessenger::Private(be_app_messenger).Port(),</a>
<a name="ln1253">			B_EXCLUSIVE_LAUNCH | B_BACKGROUND_APP, &amp;ref, B_REGISTRAR_SIGNATURE);</a>
<a name="ln1254">		info-&gt;state = APP_STATE_REGISTERED;</a>
<a name="ln1255">		info-&gt;registration_time = system_time();</a>
<a name="ln1256">		error = AddApp(info);</a>
<a name="ln1257">	}</a>
<a name="ln1258"> </a>
<a name="ln1259">	if (error == B_OK)</a>
<a name="ln1260">		_LoadRosterSettings();</a>
<a name="ln1261"> </a>
<a name="ln1262">	// cleanup on error</a>
<a name="ln1263">	if (error != B_OK)</a>
<a name="ln1264">		delete info;</a>
<a name="ln1265"> </a>
<a name="ln1266">	return error;</a>
<a name="ln1267">}</a>
<a name="ln1268"> </a>
<a name="ln1269"> </a>
<a name="ln1270">/*!	\brief Add the supplied app info to the list of (pre-)registered apps.</a>
<a name="ln1271"> </a>
<a name="ln1272">	\param info The app info to be added</a>
<a name="ln1273">*/</a>
<a name="ln1274">status_t</a>
<a name="ln1275">TRoster::AddApp(RosterAppInfo* info)</a>
<a name="ln1276">{</a>
<a name="ln1277">	BAutolock _(fLock);</a>
<a name="ln1278"> </a>
<a name="ln1279">	status_t error = (info ? B_OK : B_BAD_VALUE);</a>
<a name="ln1280">	if (info) {</a>
<a name="ln1281">		if (!fRegisteredApps.AddInfo(info))</a>
<a name="ln1282">			error = B_NO_MEMORY;</a>
<a name="ln1283">	}</a>
<a name="ln1284">	return error;</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287"> </a>
<a name="ln1288">/*!	\brief Removes the supplied app info from the list of (pre-)registered</a>
<a name="ln1289">	apps.</a>
<a name="ln1290"> </a>
<a name="ln1291">	\param info The app info to be removed</a>
<a name="ln1292">*/</a>
<a name="ln1293">void</a>
<a name="ln1294">TRoster::RemoveApp(RosterAppInfo* info)</a>
<a name="ln1295">{</a>
<a name="ln1296">	BAutolock _(fLock);</a>
<a name="ln1297"> </a>
<a name="ln1298">	if (info) {</a>
<a name="ln1299">		if (fRegisteredApps.RemoveInfo(info)) {</a>
<a name="ln1300">			if (info-&gt;state == APP_STATE_REGISTERED) {</a>
<a name="ln1301">				info-&gt;state = APP_STATE_UNREGISTERED;</a>
<a name="ln1302">				_AppRemoved(info);</a>
<a name="ln1303">			}</a>
<a name="ln1304">		}</a>
<a name="ln1305">	}</a>
<a name="ln1306">}</a>
<a name="ln1307"> </a>
<a name="ln1308"> </a>
<a name="ln1309">/*!	\brief Activates the application identified by \a info.</a>
<a name="ln1310"> </a>
<a name="ln1311">	The currently active application is deactivated and the one whose</a>
<a name="ln1312">	info is supplied is activated. \a info may be \c NULL, which only</a>
<a name="ln1313">	deactivates the currently active application.</a>
<a name="ln1314"> </a>
<a name="ln1315">	\param info The info of the app to be activated</a>
<a name="ln1316">*/</a>
<a name="ln1317">void</a>
<a name="ln1318">TRoster::UpdateActiveApp(RosterAppInfo* info)</a>
<a name="ln1319">{</a>
<a name="ln1320">	BAutolock _(fLock);</a>
<a name="ln1321"> </a>
<a name="ln1322">	if (info != fActiveApp) {</a>
<a name="ln1323">		// deactivate the currently active app</a>
<a name="ln1324">		RosterAppInfo* oldActiveApp = fActiveApp;</a>
<a name="ln1325">		fActiveApp = NULL;</a>
<a name="ln1326">		if (oldActiveApp)</a>
<a name="ln1327">			_AppDeactivated(oldActiveApp);</a>
<a name="ln1328"> </a>
<a name="ln1329">		// activate the new app</a>
<a name="ln1330">		if (info) {</a>
<a name="ln1331">			fActiveApp = info;</a>
<a name="ln1332">			_AppActivated(info);</a>
<a name="ln1333">		}</a>
<a name="ln1334">	}</a>
<a name="ln1335">}</a>
<a name="ln1336"> </a>
<a name="ln1337"> </a>
<a name="ln1338">/*!	\brief Checks whether the (pre-)registered applications are still running.</a>
<a name="ln1339"> </a>
<a name="ln1340">	This is necessary, since killed applications don't unregister properly.</a>
<a name="ln1341">*/</a>
<a name="ln1342">void</a>
<a name="ln1343">TRoster::CheckSanity()</a>
<a name="ln1344">{</a>
<a name="ln1345">	BAutolock _(fLock);</a>
<a name="ln1346"> </a>
<a name="ln1347">	// not early (pre-)registered applications</a>
<a name="ln1348">	AppInfoList obsoleteApps;</a>
<a name="ln1349">	for (AppInfoList::Iterator it = fRegisteredApps.It(); it.IsValid(); ++it) {</a>
<a name="ln1350">		if (!(*it)-&gt;IsRunning())</a>
<a name="ln1351">			obsoleteApps.AddInfo(*it);</a>
<a name="ln1352">	}</a>
<a name="ln1353"> </a>
<a name="ln1354">	// remove the apps</a>
<a name="ln1355">	for (AppInfoList::Iterator it = obsoleteApps.It(); it.IsValid(); ++it) {</a>
<a name="ln1356">		RemoveApp(*it);</a>
<a name="ln1357">		delete *it;</a>
<a name="ln1358">	}</a>
<a name="ln1359">	obsoleteApps.MakeEmpty(false);</a>
<a name="ln1360">		// don't delete infos a second time</a>
<a name="ln1361"> </a>
<a name="ln1362">	// early pre-registered applications</a>
<a name="ln1363">	bigtime_t timeLimit = system_time() - kMaximalEarlyPreRegistrationPeriod;</a>
<a name="ln1364">	for (AppInfoList::Iterator it = fEarlyPreRegisteredApps.It();</a>
<a name="ln1365">		 it.IsValid();</a>
<a name="ln1366">		 ++it) {</a>
<a name="ln1367">		if ((*it)-&gt;registration_time &lt; timeLimit)</a>
<a name="ln1368">			obsoleteApps.AddInfo(*it);</a>
<a name="ln1369">	}</a>
<a name="ln1370"> </a>
<a name="ln1371">	// remove the apps</a>
<a name="ln1372">	for (AppInfoList::Iterator it = obsoleteApps.It(); it.IsValid(); ++it) {</a>
<a name="ln1373">		fEarlyPreRegisteredApps.RemoveInfo(*it);</a>
<a name="ln1374">		delete *it;</a>
<a name="ln1375">	}</a>
<a name="ln1376">	obsoleteApps.MakeEmpty(false);</a>
<a name="ln1377">		// don't delete infos a second time</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380"> </a>
<a name="ln1381">/*!	\brief Tells the roster whether a shutdown process is in progess at the</a>
<a name="ln1382">		   moment.</a>
<a name="ln1383"> </a>
<a name="ln1384">	After this method is called with \a shuttingDown == \c true, no more</a>
<a name="ln1385">	applications can be created.</a>
<a name="ln1386"> </a>
<a name="ln1387">	\param shuttingDown \c true, to indicate the start of the shutdown process,</a>
<a name="ln1388">		   \c false to signalling its end.</a>
<a name="ln1389">*/</a>
<a name="ln1390">void</a>
<a name="ln1391">TRoster::SetShuttingDown(bool shuttingDown)</a>
<a name="ln1392">{</a>
<a name="ln1393">	BAutolock _(fLock);</a>
<a name="ln1394"> </a>
<a name="ln1395">	fShuttingDown = shuttingDown;</a>
<a name="ln1396"> </a>
<a name="ln1397">	if (shuttingDown)</a>
<a name="ln1398">		_SaveRosterSettings();</a>
<a name="ln1399">}</a>
<a name="ln1400"> </a>
<a name="ln1401"> </a>
<a name="ln1402">/*!	\brief Returns lists of applications to be asked to quit on shutdown.</a>
<a name="ln1403"> </a>
<a name="ln1404">	\param userApps List of RosterAppInfos identifying the user applications.</a>
<a name="ln1405">		   Those will be ask to quit first.</a>
<a name="ln1406">	\param systemApps List of RosterAppInfos identifying the system applications</a>
<a name="ln1407">		   (like Tracker and Deskbar), which will be asked to quit after the</a>
<a name="ln1408">		   user applications are gone.</a>
<a name="ln1409">	\param vitalSystemApps A set of team_ids identifying teams that must not</a>
<a name="ln1410">		   be terminated (app server and registrar).</a>
<a name="ln1411">	\return \c B_OK, if everything went fine, another error code otherwise.</a>
<a name="ln1412">*/</a>
<a name="ln1413">status_t</a>
<a name="ln1414">TRoster::GetShutdownApps(AppInfoList&amp; userApps, AppInfoList&amp; systemApps,</a>
<a name="ln1415">	AppInfoList&amp; backgroundApps, hash_set&lt;team_id&gt;&amp; vitalSystemApps)</a>
<a name="ln1416">{</a>
<a name="ln1417">	BAutolock _(fLock);</a>
<a name="ln1418"> </a>
<a name="ln1419">	status_t error = B_OK;</a>
<a name="ln1420"> </a>
<a name="ln1421">	// get the vital system apps:</a>
<a name="ln1422">	// * ourself</a>
<a name="ln1423">	// * kernel team</a>
<a name="ln1424">	// * app server</a>
<a name="ln1425">	// * debug server</a>
<a name="ln1426"> </a>
<a name="ln1427">	// ourself</a>
<a name="ln1428">	vitalSystemApps.insert(be_app-&gt;Team());</a>
<a name="ln1429"> </a>
<a name="ln1430">	// kernel team</a>
<a name="ln1431">	team_info teamInfo;</a>
<a name="ln1432">	if (get_team_info(B_SYSTEM_TEAM, &amp;teamInfo) == B_OK)</a>
<a name="ln1433">		vitalSystemApps.insert(teamInfo.team);</a>
<a name="ln1434"> </a>
<a name="ln1435">	// app server</a>
<a name="ln1436">	RosterAppInfo* info</a>
<a name="ln1437">		= fRegisteredApps.InfoFor(&quot;application/x-vnd.haiku-app_server&quot;);</a>
<a name="ln1438">	if (info != NULL)</a>
<a name="ln1439">		vitalSystemApps.insert(info-&gt;team);</a>
<a name="ln1440"> </a>
<a name="ln1441">	// debug server</a>
<a name="ln1442">	info = fRegisteredApps.InfoFor(&quot;application/x-vnd.haiku-debug_server&quot;);</a>
<a name="ln1443">	if (info != NULL)</a>
<a name="ln1444">		vitalSystemApps.insert(info-&gt;team);</a>
<a name="ln1445"> </a>
<a name="ln1446">	// populate the other groups</a>
<a name="ln1447">	for (AppInfoList::Iterator it(fRegisteredApps.It());</a>
<a name="ln1448">			RosterAppInfo* info = *it; ++it) {</a>
<a name="ln1449">		if (vitalSystemApps.find(info-&gt;team) == vitalSystemApps.end()) {</a>
<a name="ln1450">			RosterAppInfo* clonedInfo = info-&gt;Clone();</a>
<a name="ln1451">			if (clonedInfo) {</a>
<a name="ln1452">				if (_IsSystemApp(info)) {</a>
<a name="ln1453">					if (!systemApps.AddInfo(clonedInfo))</a>
<a name="ln1454">						error = B_NO_MEMORY;</a>
<a name="ln1455">				} else if (info-&gt;flags &amp; B_BACKGROUND_APP) {</a>
<a name="ln1456">					if (!backgroundApps.AddInfo(clonedInfo))</a>
<a name="ln1457">						error = B_NO_MEMORY;</a>
<a name="ln1458">				} else {</a>
<a name="ln1459">					if (!userApps.AddInfo(clonedInfo))</a>
<a name="ln1460">						error = B_NO_MEMORY;</a>
<a name="ln1461">				}</a>
<a name="ln1462"> </a>
<a name="ln1463">				if (error != B_OK)</a>
<a name="ln1464">					delete clonedInfo;</a>
<a name="ln1465">			} else</a>
<a name="ln1466">				error = B_NO_MEMORY;</a>
<a name="ln1467">		}</a>
<a name="ln1468"> </a>
<a name="ln1469">		if (error != B_OK)</a>
<a name="ln1470">			break;</a>
<a name="ln1471">	}</a>
<a name="ln1472"> </a>
<a name="ln1473">	// Special case, we add the input server to vital apps here so it is</a>
<a name="ln1474">	// not excluded in the lists above</a>
<a name="ln1475">	info = fRegisteredApps.InfoFor(&quot;application/x-vnd.Be-input_server&quot;);</a>
<a name="ln1476">	if (info != NULL)</a>
<a name="ln1477">		vitalSystemApps.insert(info-&gt;team);</a>
<a name="ln1478"> </a>
<a name="ln1479">	// clean up on error</a>
<a name="ln1480">	if (error != B_OK) {</a>
<a name="ln1481">		userApps.MakeEmpty(true);</a>
<a name="ln1482">		systemApps.MakeEmpty(true);</a>
<a name="ln1483">	}</a>
<a name="ln1484"> </a>
<a name="ln1485">	return error;</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488"> </a>
<a name="ln1489">status_t</a>
<a name="ln1490">TRoster::AddAppInfo(AppInfoList&amp; apps, team_id team)</a>
<a name="ln1491">{</a>
<a name="ln1492">	BAutolock _(fLock);</a>
<a name="ln1493"> </a>
<a name="ln1494">	for (AppInfoList::Iterator it(fRegisteredApps.It());</a>
<a name="ln1495">			RosterAppInfo* info = *it; ++it) {</a>
<a name="ln1496">		if (info-&gt;team == team) {</a>
<a name="ln1497">			RosterAppInfo* clonedInfo = info-&gt;Clone();</a>
<a name="ln1498">			status_t error = B_NO_MEMORY;</a>
<a name="ln1499">			if (clonedInfo != NULL) {</a>
<a name="ln1500">				if (!apps.AddInfo(clonedInfo))</a>
<a name="ln1501">					delete clonedInfo;</a>
<a name="ln1502">				else</a>
<a name="ln1503">					error = B_OK;</a>
<a name="ln1504">			}</a>
<a name="ln1505">			return error;</a>
<a name="ln1506">		}</a>
<a name="ln1507">	}</a>
<a name="ln1508"> </a>
<a name="ln1509">	return B_BAD_TEAM_ID;</a>
<a name="ln1510">}</a>
<a name="ln1511"> </a>
<a name="ln1512"> </a>
<a name="ln1513">status_t</a>
<a name="ln1514">TRoster::AddWatcher(Watcher* watcher)</a>
<a name="ln1515">{</a>
<a name="ln1516">	BAutolock _(fLock);</a>
<a name="ln1517"> </a>
<a name="ln1518">	if (!watcher)</a>
<a name="ln1519">		return B_BAD_VALUE;</a>
<a name="ln1520"> </a>
<a name="ln1521">	if (!fWatchingService.AddWatcher(watcher))</a>
<a name="ln1522">		return B_NO_MEMORY;</a>
<a name="ln1523"> </a>
<a name="ln1524">	return B_OK;</a>
<a name="ln1525">}</a>
<a name="ln1526"> </a>
<a name="ln1527"> </a>
<a name="ln1528">void</a>
<a name="ln1529">TRoster::RemoveWatcher(Watcher* watcher)</a>
<a name="ln1530">{</a>
<a name="ln1531">	BAutolock _(fLock);</a>
<a name="ln1532"> </a>
<a name="ln1533">	if (watcher)</a>
<a name="ln1534">		fWatchingService.RemoveWatcher(watcher, false);</a>
<a name="ln1535">}</a>
<a name="ln1536"> </a>
<a name="ln1537"> </a>
<a name="ln1538">/*!	\brief Hook method invoked, when an application has been fully registered.</a>
<a name="ln1539">	\param info The RosterAppInfo of the added application.</a>
<a name="ln1540">*/</a>
<a name="ln1541">void</a>
<a name="ln1542">TRoster::_AppAdded(RosterAppInfo* info)</a>
<a name="ln1543">{</a>
<a name="ln1544">	// notify the watchers</a>
<a name="ln1545">	BMessage message(B_SOME_APP_LAUNCHED);</a>
<a name="ln1546">	_AddMessageWatchingInfo(&amp;message, info);</a>
<a name="ln1547">	EventMaskWatcherFilter filter(B_REQUEST_LAUNCHED);</a>
<a name="ln1548">	fWatchingService.NotifyWatchers(&amp;message, &amp;filter);</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551"> </a>
<a name="ln1552">/*!	\brief Hook method invoked, when a fully registered application has been</a>
<a name="ln1553">		removed.</a>
<a name="ln1554">	\param info The RosterAppInfo of the removed application.</a>
<a name="ln1555">*/</a>
<a name="ln1556">void</a>
<a name="ln1557">TRoster::_AppRemoved(RosterAppInfo* info)</a>
<a name="ln1558">{</a>
<a name="ln1559">	if (info) {</a>
<a name="ln1560">		// deactivate the app, if it was the active one</a>
<a name="ln1561">		if (info == fActiveApp)</a>
<a name="ln1562">			UpdateActiveApp(NULL);</a>
<a name="ln1563"> </a>
<a name="ln1564">		// notify the watchers</a>
<a name="ln1565">		BMessage message(B_SOME_APP_QUIT);</a>
<a name="ln1566">		_AddMessageWatchingInfo(&amp;message, info);</a>
<a name="ln1567">		EventMaskWatcherFilter filter(B_REQUEST_QUIT);</a>
<a name="ln1568">		fWatchingService.NotifyWatchers(&amp;message, &amp;filter);</a>
<a name="ln1569">	}</a>
<a name="ln1570">}</a>
<a name="ln1571"> </a>
<a name="ln1572"> </a>
<a name="ln1573">/*!	\brief Hook method invoked, when an application has been activated.</a>
<a name="ln1574">	\param info The RosterAppInfo of the activated application.</a>
<a name="ln1575">*/</a>
<a name="ln1576">void</a>
<a name="ln1577">TRoster::_AppActivated(RosterAppInfo* info)</a>
<a name="ln1578">{</a>
<a name="ln1579">	if (info != NULL &amp;&amp; info-&gt;state == APP_STATE_REGISTERED) {</a>
<a name="ln1580">		// send B_APP_ACTIVATED to the app</a>
<a name="ln1581">		BMessenger messenger;</a>
<a name="ln1582">		BMessenger::Private messengerPrivate(messenger);</a>
<a name="ln1583">		messengerPrivate.SetTo(info-&gt;team, info-&gt;port, B_NULL_TOKEN);</a>
<a name="ln1584">		BMessage message(B_APP_ACTIVATED);</a>
<a name="ln1585">		message.AddBool(&quot;active&quot;, true);</a>
<a name="ln1586">		// not sure, if it makes sense to use the MessageDeliverer here</a>
<a name="ln1587">		MessageDeliverer::Default()-&gt;DeliverMessage(&amp;message, messenger);</a>
<a name="ln1588"> </a>
<a name="ln1589">		// notify the watchers</a>
<a name="ln1590">		BMessage watcherMessage(B_SOME_APP_ACTIVATED);</a>
<a name="ln1591">		_AddMessageWatchingInfo(&amp;watcherMessage, info);</a>
<a name="ln1592">		EventMaskWatcherFilter filter(B_REQUEST_ACTIVATED);</a>
<a name="ln1593">		fWatchingService.NotifyWatchers(&amp;watcherMessage, &amp;filter);</a>
<a name="ln1594">	}</a>
<a name="ln1595">}</a>
<a name="ln1596"> </a>
<a name="ln1597"> </a>
<a name="ln1598">/*!	\brief Hook method invoked, when an application has been deactivated.</a>
<a name="ln1599">	\param info The RosterAppInfo of the deactivated application.</a>
<a name="ln1600">*/</a>
<a name="ln1601">void</a>
<a name="ln1602">TRoster::_AppDeactivated(RosterAppInfo* info)</a>
<a name="ln1603">{</a>
<a name="ln1604">	if (info != NULL &amp;&amp; info-&gt;state == APP_STATE_REGISTERED) {</a>
<a name="ln1605">		// send B_APP_ACTIVATED to the app</a>
<a name="ln1606">		BMessenger messenger;</a>
<a name="ln1607">		BMessenger::Private messengerPrivate(messenger);</a>
<a name="ln1608">		messengerPrivate.SetTo(info-&gt;team, info-&gt;port, B_NULL_TOKEN);</a>
<a name="ln1609">		BMessage message(B_APP_ACTIVATED);</a>
<a name="ln1610">		message.AddBool(&quot;active&quot;, false);</a>
<a name="ln1611">		// not sure, if it makes sense to use the MessageDeliverer here</a>
<a name="ln1612">		MessageDeliverer::Default()-&gt;DeliverMessage(&amp;message, messenger);</a>
<a name="ln1613">	}</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616"> </a>
<a name="ln1617">/*!	\brief Adds an app_info to a message.</a>
<a name="ln1618"> </a>
<a name="ln1619">	The info is added as a flat_app_info to a field &quot;app_info&quot; with the type</a>
<a name="ln1620">	\c B_REG_APP_INFO_TYPE.</a>
<a name="ln1621"> </a>
<a name="ln1622">	\param message The message</a>
<a name="ln1623">	\param info The app_info.</a>
<a name="ln1624">	\return \c B_OK if everything went fine, an error code otherwise.</a>
<a name="ln1625">*/</a>
<a name="ln1626">status_t</a>
<a name="ln1627">TRoster::_AddMessageAppInfo(BMessage* message, const app_info* info)</a>
<a name="ln1628">{</a>
<a name="ln1629">	// An app_info is not completely flat. The entry_ref contains a string</a>
<a name="ln1630">	// pointer. Therefore we flatten the info.</a>
<a name="ln1631">	flat_app_info flatInfo;</a>
<a name="ln1632">	flatInfo.thread = info-&gt;thread;</a>
<a name="ln1633">	flatInfo.team = info-&gt;team;</a>
<a name="ln1634">	flatInfo.port = info-&gt;port;</a>
<a name="ln1635">	flatInfo.flags = info-&gt;flags;</a>
<a name="ln1636">	flatInfo.ref_device = info-&gt;ref.device;</a>
<a name="ln1637">	flatInfo.ref_directory = info-&gt;ref.directory;</a>
<a name="ln1638">	memcpy(flatInfo.signature, info-&gt;signature, B_MIME_TYPE_LENGTH);</a>
<a name="ln1639"> </a>
<a name="ln1640">	// set the ref name to NULL and copy it into the flat structure</a>
<a name="ln1641">	flatInfo.ref_name[0] = '\0';</a>
<a name="ln1642">	if (info-&gt;ref.name)</a>
<a name="ln1643">		strcpy(flatInfo.ref_name, info-&gt;ref.name);</a>
<a name="ln1644"> </a>
<a name="ln1645">	// add the flat info</a>
<a name="ln1646">	return message-&gt;AddData(&quot;app_info&quot;, B_REG_APP_INFO_TYPE, &amp;flatInfo,</a>
<a name="ln1647">		sizeof(flat_app_info));</a>
<a name="ln1648">}</a>
<a name="ln1649"> </a>
<a name="ln1650"> </a>
<a name="ln1651">/*!	\brief Adds application monitoring related fields to a message.</a>
<a name="ln1652">	\param message The message.</a>
<a name="ln1653">	\param info The app_info of the concerned application.</a>
<a name="ln1654">	\return \c B_OK if everything went fine, an error code otherwise.</a>
<a name="ln1655">*/</a>
<a name="ln1656">status_t</a>
<a name="ln1657">TRoster::_AddMessageWatchingInfo(BMessage* message, const app_info* info)</a>
<a name="ln1658">{</a>
<a name="ln1659">	status_t error = B_OK;</a>
<a name="ln1660">	if (error == B_OK)</a>
<a name="ln1661">		error = message-&gt;AddString(&quot;be:signature&quot;, info-&gt;signature);</a>
<a name="ln1662">	if (error == B_OK)</a>
<a name="ln1663">		error = message-&gt;AddInt32(&quot;be:team&quot;, info-&gt;team);</a>
<a name="ln1664">	if (error == B_OK)</a>
<a name="ln1665">		error = message-&gt;AddInt32(&quot;be:thread&quot;, info-&gt;thread);</a>
<a name="ln1666">	if (error == B_OK)</a>
<a name="ln1667">		error = message-&gt;AddInt32(&quot;be:flags&quot;, (int32)info-&gt;flags);</a>
<a name="ln1668">	if (error == B_OK)</a>
<a name="ln1669">		error = message-&gt;AddRef(&quot;be:ref&quot;, &amp;info-&gt;ref);</a>
<a name="ln1670">	return error;</a>
<a name="ln1671">}</a>
<a name="ln1672"> </a>
<a name="ln1673"> </a>
<a name="ln1674">/*!	\brief Returns the next available token.</a>
<a name="ln1675">	\return The token.</a>
<a name="ln1676">*/</a>
<a name="ln1677">uint32</a>
<a name="ln1678">TRoster::_NextToken()</a>
<a name="ln1679">{</a>
<a name="ln1680">	return ++fLastToken;</a>
<a name="ln1681">}</a>
<a name="ln1682"> </a>
<a name="ln1683"> </a>
<a name="ln1684">/*!	\brief Adds an IsAppRegistered() request to the given map.</a>
<a name="ln1685"> </a>
<a name="ln1686">	If something goes wrong, the method deletes the request.</a>
<a name="ln1687"> </a>
<a name="ln1688">	\param map The map the request shall be added to.</a>
<a name="ln1689">	\param key The key under which to add the request.</a>
<a name="ln1690">	\param request The request message to be added.</a>
<a name="ln1691">*/</a>
<a name="ln1692">void</a>
<a name="ln1693">TRoster::_AddIARRequest(IARRequestMap&amp; map, int32 key, BMessage* request)</a>
<a name="ln1694">{</a>
<a name="ln1695">	IARRequestMap::iterator it = map.find(key);</a>
<a name="ln1696">	BMessageQueue* requests = NULL;</a>
<a name="ln1697">	if (it == map.end()) {</a>
<a name="ln1698">		requests = new(nothrow) BMessageQueue();</a>
<a name="ln1699">		if (!requests) {</a>
<a name="ln1700">			delete request;</a>
<a name="ln1701">			return;</a>
<a name="ln1702">		}</a>
<a name="ln1703"> </a>
<a name="ln1704">		map[key] = requests;</a>
<a name="ln1705">	} else</a>
<a name="ln1706">		requests = it-&gt;second;</a>
<a name="ln1707"> </a>
<a name="ln1708">	requests-&gt;AddMessage(request);</a>
<a name="ln1709">}</a>
<a name="ln1710"> </a>
<a name="ln1711"> </a>
<a name="ln1712">/*!	\brief Invokes _ReplyToIARRequest() for all messages in the given</a>
<a name="ln1713">		   message queue.</a>
<a name="ln1714"> </a>
<a name="ln1715">	\param requests The request messages to be replied to</a>
<a name="ln1716">	\param info The RosterAppInfo of the application in question</a>
<a name="ln1717">		   (may be \c NULL)</a>
<a name="ln1718">*/</a>
<a name="ln1719">void</a>
<a name="ln1720">TRoster::_ReplyToIARRequests(BMessageQueue* requests, const RosterAppInfo* info)</a>
<a name="ln1721">{</a>
<a name="ln1722">	while (BMessage* request = requests-&gt;NextMessage()) {</a>
<a name="ln1723">		_ReplyToIARRequest(request, info);</a>
<a name="ln1724">		delete request;</a>
<a name="ln1725">	}</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728"> </a>
<a name="ln1729">/*!	\brief Sends a reply message to an IsAppRegistered() request.</a>
<a name="ln1730"> </a>
<a name="ln1731">	The message to be sent is a simple \c B_REG_SUCCESS message containing</a>
<a name="ln1732">	a &quot;pre-registered&quot; field, that says whether or not the application is</a>
<a name="ln1733">	pre-registered. It will be set to \c false, unless an \a info is supplied</a>
<a name="ln1734">	and the application this info refers to is pre-registered.</a>
<a name="ln1735"> </a>
<a name="ln1736">	\param request The request message to be replied to</a>
<a name="ln1737">	\param info The RosterAppInfo of the application in question</a>
<a name="ln1738">		   (may be \c NULL)</a>
<a name="ln1739">*/</a>
<a name="ln1740">void</a>
<a name="ln1741">TRoster::_ReplyToIARRequest(BMessage* request, const RosterAppInfo* info)</a>
<a name="ln1742">{</a>
<a name="ln1743">	// pre-registered or registered?</a>
<a name="ln1744">	bool preRegistered = false;</a>
<a name="ln1745">	if (info) {</a>
<a name="ln1746">		switch (info-&gt;state) {</a>
<a name="ln1747">			case APP_STATE_PRE_REGISTERED:</a>
<a name="ln1748">				preRegistered = true;</a>
<a name="ln1749">				break;</a>
<a name="ln1750">			case APP_STATE_UNREGISTERED:</a>
<a name="ln1751">			case APP_STATE_REGISTERED:</a>
<a name="ln1752">				preRegistered = false;</a>
<a name="ln1753">				break;</a>
<a name="ln1754">		}</a>
<a name="ln1755">	}</a>
<a name="ln1756">	// send reply</a>
<a name="ln1757">	BMessage reply(B_REG_SUCCESS);</a>
<a name="ln1758">	reply.AddBool(&quot;registered&quot;, (bool)info);</a>
<a name="ln1759">	reply.AddBool(&quot;pre-registered&quot;, preRegistered);</a>
<a name="ln1760">	PRINT(&quot;_ReplyToIARRequest(): pre-registered: %d\n&quot;, preRegistered);</a>
<a name="ln1761">	if (info)</a>
<a name="ln1762">		_AddMessageAppInfo(&amp;reply, info);</a>
<a name="ln1763">	request-&gt;SendReply(&amp;reply);</a>
<a name="ln1764">}</a>
<a name="ln1765"> </a>
<a name="ln1766"> </a>
<a name="ln1767">/*! \brief Handles requests for both GetRecentDocuments() and</a>
<a name="ln1768">	GetRecentFolders().</a>
<a name="ln1769">*/</a>
<a name="ln1770">void</a>
<a name="ln1771">TRoster::_HandleGetRecentEntries(BMessage* request)</a>
<a name="ln1772">{</a>
<a name="ln1773">	FUNCTION_START();</a>
<a name="ln1774">	if (!request) {</a>
<a name="ln1775">		D(PRINT(&quot;WARNING: TRoster::HandleGetRecentFolders(NULL) called\n&quot;));</a>
<a name="ln1776">		return;</a>
<a name="ln1777">	}</a>
<a name="ln1778"> </a>
<a name="ln1779">	int32 maxCount;</a>
<a name="ln1780">	BMessage reply(B_REG_RESULT);</a>
<a name="ln1781">	char** fileTypes = NULL;</a>
<a name="ln1782">	int32 fileTypesCount = 0;</a>
<a name="ln1783">	char* appSig = NULL;</a>
<a name="ln1784"> </a>
<a name="ln1785">	status_t error = request-&gt;FindInt32(&quot;max count&quot;, &amp;maxCount);</a>
<a name="ln1786">	// Look for optional file type(s)</a>
<a name="ln1787">	if (!error) {</a>
<a name="ln1788">		type_code typeFound;</a>
<a name="ln1789">		status_t typeError = request-&gt;GetInfo(&quot;file type&quot;, &amp;typeFound,</a>
<a name="ln1790">			&amp;fileTypesCount);</a>
<a name="ln1791">		if (!typeError)</a>
<a name="ln1792">			typeError = typeFound == B_STRING_TYPE ? B_OK : B_BAD_TYPE;</a>
<a name="ln1793">		if (!typeError) {</a>
<a name="ln1794">			fileTypes = new(nothrow) char*[fileTypesCount];</a>
<a name="ln1795">			typeError = fileTypes ? B_OK : B_NO_MEMORY;</a>
<a name="ln1796">		}</a>
<a name="ln1797">		if (!typeError) {</a>
<a name="ln1798">			for (int i = 0; !error &amp;&amp; i &lt; fileTypesCount; i++) {</a>
<a name="ln1799">				const char* type;</a>
<a name="ln1800">				if (request-&gt;FindString(&quot;file type&quot;, i, &amp;type) == B_OK) {</a>
<a name="ln1801">					fileTypes[i] = new(nothrow) char[B_MIME_TYPE_LENGTH];</a>
<a name="ln1802">					error = fileTypes[i] ? B_OK : B_NO_MEMORY;</a>
<a name="ln1803">						// Yes, I do mean to use &quot;error&quot; here, not &quot;typeError&quot;</a>
<a name="ln1804">					BPrivate::Storage::to_lower(type, fileTypes[i]);</a>
<a name="ln1805">						// Types are expected to be lowercase</a>
<a name="ln1806">				}</a>
<a name="ln1807">			}</a>
<a name="ln1808">		}</a>
<a name="ln1809">	}</a>
<a name="ln1810">	// Look for optional app sig</a>
<a name="ln1811">	if (!error) {</a>
<a name="ln1812">		const char* sig;</a>
<a name="ln1813">		error = request-&gt;FindString(&quot;app sig&quot;, &amp;sig);</a>
<a name="ln1814">		if (!error) {</a>
<a name="ln1815">			appSig = new(nothrow) char[B_MIME_TYPE_LENGTH];</a>
<a name="ln1816">			error = appSig ? B_OK : B_NO_MEMORY;</a>
<a name="ln1817">			BPrivate::Storage::to_lower(sig, appSig);</a>
<a name="ln1818">		} else if (error == B_NAME_NOT_FOUND)</a>
<a name="ln1819">			error = B_OK;</a>
<a name="ln1820">	}</a>
<a name="ln1821">	if (!error) {</a>
<a name="ln1822">		switch (request-&gt;what) {</a>
<a name="ln1823">			case B_REG_GET_RECENT_DOCUMENTS:</a>
<a name="ln1824">				error = fRecentDocuments.Get(maxCount, (const char**)fileTypes,</a>
<a name="ln1825">					fileTypesCount, appSig, &amp;reply);</a>
<a name="ln1826">				D(fRecentDocuments.Print());</a>
<a name="ln1827">		   	    break;</a>
<a name="ln1828"> </a>
<a name="ln1829">			case B_REG_GET_RECENT_FOLDERS:</a>
<a name="ln1830">				error = fRecentFolders.Get(maxCount, (const char**)fileTypes,</a>
<a name="ln1831">					fileTypesCount, appSig, &amp;reply);</a>
<a name="ln1832">				D(fRecentFolders.Print());</a>
<a name="ln1833">			    break;</a>
<a name="ln1834"> </a>
<a name="ln1835">			default:</a>
<a name="ln1836">				D(PRINT(&quot;WARNING: TRoster::_HandleGetRecentEntries(): &quot;</a>
<a name="ln1837">					&quot;unexpected request-&gt;what value of 0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln1838">					request-&gt;what));</a>
<a name="ln1839">				error = B_BAD_VALUE;</a>
<a name="ln1840">				break;</a>
<a name="ln1841">		}</a>
<a name="ln1842">	}</a>
<a name="ln1843">	reply.AddInt32(&quot;result&quot;, error);</a>
<a name="ln1844">	// Clean up before sending a reply</a>
<a name="ln1845">	delete [] appSig;</a>
<a name="ln1846">	if (fileTypes) {</a>
<a name="ln1847">		for (int i = 0; i &lt; fileTypesCount; i++)</a>
<a name="ln1848">			delete [] fileTypes[i];</a>
<a name="ln1849">		delete[] fileTypes;</a>
<a name="ln1850">		fileTypes = NULL;</a>
<a name="ln1851">	}</a>
<a name="ln1852">	request-&gt;SendReply(&amp;reply);</a>
<a name="ln1853"> </a>
<a name="ln1854">	FUNCTION_END();</a>
<a name="ln1855">}</a>
<a name="ln1856"> </a>
<a name="ln1857"> </a>
<a name="ln1858">/*!</a>
<a name="ln1859">	\brief Checks all registered apps for \a ref and \a signature if</a>
<a name="ln1860">		they are still alive, and removes those that aren't.</a>
<a name="ln1861">*/</a>
<a name="ln1862">void</a>
<a name="ln1863">TRoster::_ValidateRunning(const entry_ref&amp; ref, const char* signature)</a>
<a name="ln1864">{</a>
<a name="ln1865">	while (true) {</a>
<a name="ln1866">		// get info via ref or signature</a>
<a name="ln1867">		RosterAppInfo* info = fRegisteredApps.InfoFor(&amp;ref);</a>
<a name="ln1868">		if (info == NULL &amp;&amp; signature != NULL)</a>
<a name="ln1869">			info = fRegisteredApps.InfoFor(signature);</a>
<a name="ln1870"> </a>
<a name="ln1871">		// if app is alive or does not exist, we can exit</a>
<a name="ln1872">		if (info == NULL || info-&gt;IsRunning())</a>
<a name="ln1873">			return;</a>
<a name="ln1874"> </a>
<a name="ln1875">		RemoveApp(info);</a>
<a name="ln1876">		delete info;</a>
<a name="ln1877">	}</a>
<a name="ln1878">}</a>
<a name="ln1879"> </a>
<a name="ln1880"> </a>
<a name="ln1881">bool</a>
<a name="ln1882">TRoster::_IsSystemApp(RosterAppInfo* info) const</a>
<a name="ln1883">{</a>
<a name="ln1884">	BPath path;</a>
<a name="ln1885">	if (path.SetTo(&amp;info-&gt;ref) != B_OK || path.GetParent(&amp;path) != B_OK)</a>
<a name="ln1886">		return false;</a>
<a name="ln1887"> </a>
<a name="ln1888">	return !strcmp(path.Path(), fSystemAppPath.Path())</a>
<a name="ln1889">		|| !strcmp(path.Path(), fSystemServerPath.Path());</a>
<a name="ln1890">}</a>
<a name="ln1891"> </a>
<a name="ln1892"> </a>
<a name="ln1893">status_t</a>
<a name="ln1894">TRoster::_LoadRosterSettings(const char* path)</a>
<a name="ln1895">{</a>
<a name="ln1896">	BPath _path;</a>
<a name="ln1897">	const char* settingsPath</a>
<a name="ln1898">		= path ? path : get_default_roster_settings_path(_path, false);</a>
<a name="ln1899"> </a>
<a name="ln1900">	RosterSettingsCharStream stream;</a>
<a name="ln1901">	status_t error;</a>
<a name="ln1902">	BFile file;</a>
<a name="ln1903"> </a>
<a name="ln1904">	error = file.SetTo(settingsPath, B_READ_ONLY);</a>
<a name="ln1905">	off_t size;</a>
<a name="ln1906">	if (!error)</a>
<a name="ln1907">		error = file.GetSize(&amp;size);</a>
<a name="ln1908"> </a>
<a name="ln1909">	char* data = NULL;</a>
<a name="ln1910"> </a>
<a name="ln1911">	if (!error) {</a>
<a name="ln1912">		data = new(nothrow) char[size + 1];</a>
<a name="ln1913">		error = data ? B_OK : B_NO_MEMORY;</a>
<a name="ln1914">	}</a>
<a name="ln1915">	if (!error) {</a>
<a name="ln1916">		ssize_t bytes = file.Read(data, size);</a>
<a name="ln1917">		error = bytes &lt; 0 ? bytes : (bytes == size ? B_OK : B_FILE_ERROR);</a>
<a name="ln1918">	}</a>
<a name="ln1919">	if (!error) {</a>
<a name="ln1920">		data[size] = 0;</a>
<a name="ln1921">		error = stream.SetTo(std::string(data));</a>
<a name="ln1922">	}</a>
<a name="ln1923"> </a>
<a name="ln1924">	delete[] data;</a>
<a name="ln1925"> </a>
<a name="ln1926">	if (!error) {</a>
<a name="ln1927">		// Clear the current lists as</a>
<a name="ln1928">		// we'll be manually building them up</a>
<a name="ln1929">		fRecentDocuments.Clear();</a>
<a name="ln1930">		fRecentFolders.Clear();</a>
<a name="ln1931">		fRecentApps.Clear();</a>
<a name="ln1932"> </a>
<a name="ln1933">		// Now we just walk through the file and read in the info</a>
<a name="ln1934">		while (true) {</a>
<a name="ln1935">			status_t streamError;</a>
<a name="ln1936">			char str[B_PATH_NAME_LENGTH];</a>
<a name="ln1937"> </a>
<a name="ln1938">			// (RecentDoc | RecentFolder | RecentApp)</a>
<a name="ln1939">			streamError = stream.GetString(str);</a>
<a name="ln1940">			if (!streamError) {</a>
<a name="ln1941">				enum EntryType {</a>
<a name="ln1942">					etDoc,</a>
<a name="ln1943">					etFolder,</a>
<a name="ln1944">					etApp,</a>
<a name="ln1945">					etSomethingIsAmiss,</a>
<a name="ln1946">				} type;</a>
<a name="ln1947"> </a>
<a name="ln1948">				if (strcmp(str, &quot;RecentDoc&quot;) == 0)</a>
<a name="ln1949">					type = etDoc;</a>
<a name="ln1950">				else if (strcmp(str, &quot;RecentFolder&quot;) == 0)</a>
<a name="ln1951">					type = etFolder;</a>
<a name="ln1952">				else if (strcmp(str, &quot;RecentApp&quot;) == 0)</a>
<a name="ln1953">					type = etApp;</a>
<a name="ln1954">				else</a>
<a name="ln1955">					type = etSomethingIsAmiss;</a>
<a name="ln1956"> </a>
<a name="ln1957">				switch (type) {</a>
<a name="ln1958">					case etDoc:</a>
<a name="ln1959">					case etFolder:</a>
<a name="ln1960">					{</a>
<a name="ln1961">						// For curing laziness</a>
<a name="ln1962">						std::list&lt;recent_entry*&gt;* list = type == etDoc</a>
<a name="ln1963">							? &amp;fRecentDocuments.fEntryList</a>
<a name="ln1964">							: &amp;fRecentFolders.fEntryList;</a>
<a name="ln1965"> </a>
<a name="ln1966">						char path[B_PATH_NAME_LENGTH];</a>
<a name="ln1967">						char app[B_PATH_NAME_LENGTH];</a>
<a name="ln1968">						char rank[B_PATH_NAME_LENGTH];</a>
<a name="ln1969">						entry_ref ref;</a>
<a name="ln1970">						ulong index = 0;</a>
<a name="ln1971"> </a>
<a name="ln1972">						// Convert the given path to an entry ref</a>
<a name="ln1973">						streamError = stream.GetString(path);</a>
<a name="ln1974">						if (!streamError)</a>
<a name="ln1975">							streamError = get_ref_for_path(path, &amp;ref);</a>
<a name="ln1976"> </a>
<a name="ln1977">						// Add a new entry to the list for each application</a>
<a name="ln1978">						// signature and rank we find</a>
<a name="ln1979">						while (!streamError) {</a>
<a name="ln1980">							if (!streamError)</a>
<a name="ln1981">								streamError = stream.GetString(app);</a>
<a name="ln1982">							if (!streamError) {</a>
<a name="ln1983">								BPrivate::Storage::to_lower(app);</a>
<a name="ln1984">								streamError = stream.GetString(rank);</a>
<a name="ln1985">							}</a>
<a name="ln1986">							if (!streamError) {</a>
<a name="ln1987">								index = strtoul(rank, NULL, 10);</a>
<a name="ln1988">								if (index == ULONG_MAX)</a>
<a name="ln1989">									streamError = errno;</a>
<a name="ln1990">							}</a>
<a name="ln1991">							recent_entry* entry = NULL;</a>
<a name="ln1992">							if (!streamError) {</a>
<a name="ln1993">								entry = new(nothrow) recent_entry(&amp;ref, app,</a>
<a name="ln1994">									index);</a>
<a name="ln1995">								streamError = entry ? B_OK : B_NO_MEMORY;</a>
<a name="ln1996">							}</a>
<a name="ln1997">							if (!streamError) {</a>
<a name="ln1998">								D(printf(&quot;pushing entry, leaf == '%s', app == &quot;</a>
<a name="ln1999">									&quot;'%s', index == %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln2000">									entry-&gt;ref.name, entry-&gt;sig.c_str(),</a>
<a name="ln2001">									entry-&gt;index));</a>
<a name="ln2002"> </a>
<a name="ln2003">								list-&gt;push_back(entry);</a>
<a name="ln2004">							}</a>
<a name="ln2005">						}</a>
<a name="ln2006"> </a>
<a name="ln2007">						if (streamError) {</a>
<a name="ln2008">							D(printf(&quot;entry error 0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln2009">								streamError));</a>
<a name="ln2010">							if (streamError</a>
<a name="ln2011">									!= RosterSettingsCharStream::kEndOfLine</a>
<a name="ln2012">							    &amp;&amp; streamError</a>
<a name="ln2013">							    	!= RosterSettingsCharStream::kEndOfStream)</a>
<a name="ln2014">							stream.SkipLine();</a>
<a name="ln2015">						}</a>
<a name="ln2016"> </a>
<a name="ln2017">						break;</a>
<a name="ln2018">					}</a>
<a name="ln2019"> </a>
<a name="ln2020"> </a>
<a name="ln2021">					case etApp:</a>
<a name="ln2022">					{</a>
<a name="ln2023">						char app[B_PATH_NAME_LENGTH];</a>
<a name="ln2024">						streamError = stream.GetString(app);</a>
<a name="ln2025">						if (!streamError) {</a>
<a name="ln2026">							BPrivate::Storage::to_lower(app);</a>
<a name="ln2027">							fRecentApps.fAppList.push_back(app);</a>
<a name="ln2028">						} else</a>
<a name="ln2029">							stream.SkipLine();</a>
<a name="ln2030">						break;</a>
<a name="ln2031">					}</a>
<a name="ln2032"> </a>
<a name="ln2033">					default:</a>
<a name="ln2034">						// Something was amiss; skip to the next line</a>
<a name="ln2035">						stream.SkipLine();</a>
<a name="ln2036">						break;</a>
<a name="ln2037">				}</a>
<a name="ln2038"> </a>
<a name="ln2039">			}</a>
<a name="ln2040"> </a>
<a name="ln2041">			if (streamError == RosterSettingsCharStream::kEndOfStream)</a>
<a name="ln2042">				break;</a>
<a name="ln2043">		}</a>
<a name="ln2044"> </a>
<a name="ln2045">		// Now we must sort our lists of documents and folders by the</a>
<a name="ln2046">		// indicies we read for each entry (largest index first)</a>
<a name="ln2047">		fRecentDocuments.fEntryList.sort(larger_index);</a>
<a name="ln2048">		fRecentFolders.fEntryList.sort(larger_index);</a>
<a name="ln2049"> </a>
<a name="ln2050">		D(</a>
<a name="ln2051">			printf(&quot;----------------------------------------------------------------------\n&quot;);</a>
<a name="ln2052">			fRecentDocuments.Print();</a>
<a name="ln2053">			printf(&quot;----------------------------------------------------------------------\n&quot;);</a>
<a name="ln2054">			fRecentFolders.Print();</a>
<a name="ln2055">			printf(&quot;----------------------------------------------------------------------\n&quot;);</a>
<a name="ln2056">			fRecentApps.Print();</a>
<a name="ln2057">			printf(&quot;----------------------------------------------------------------------\n&quot;);</a>
<a name="ln2058">		);</a>
<a name="ln2059">	}</a>
<a name="ln2060">	if (error) {</a>
<a name="ln2061">		D(PRINT(&quot;WARNING: TRoster::_LoadRosterSettings(): error loading roster &quot;</a>
<a name="ln2062">			&quot;settings from '%s', 0x%&quot; B_PRIx32 &quot;\n&quot;, settingsPath, error));</a>
<a name="ln2063">	}</a>
<a name="ln2064">	return error;</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067"> </a>
<a name="ln2068">status_t</a>
<a name="ln2069">TRoster::_SaveRosterSettings(const char* path)</a>
<a name="ln2070">{</a>
<a name="ln2071">	BPath _path;</a>
<a name="ln2072">	const char* settingsPath</a>
<a name="ln2073">		= path != NULL ? path : get_default_roster_settings_path(_path, true);</a>
<a name="ln2074"> </a>
<a name="ln2075">	status_t error;</a>
<a name="ln2076">	FILE* file;</a>
<a name="ln2077"> </a>
<a name="ln2078">	file = fopen(settingsPath, &quot;w+&quot;);</a>
<a name="ln2079">	error = file ? B_OK : errno;</a>
<a name="ln2080">	if (!error) {</a>
<a name="ln2081">		status_t saveError;</a>
<a name="ln2082">		saveError = fRecentDocuments.Save(file, &quot;Recent documents&quot;, &quot;RecentDoc&quot;);</a>
<a name="ln2083">		if (saveError) {</a>
<a name="ln2084">			D(PRINT(&quot;TRoster::_SaveRosterSettings(): recent documents save &quot;</a>
<a name="ln2085">				&quot;failed with error 0x%&quot; B_PRIx32 &quot;\n&quot;, saveError));</a>
<a name="ln2086">		}</a>
<a name="ln2087">		saveError = fRecentFolders.Save(file, &quot;Recent folders&quot;, &quot;RecentFolder&quot;);</a>
<a name="ln2088">		if (saveError) {</a>
<a name="ln2089">			D(PRINT(&quot;TRoster::_SaveRosterSettings(): recent folders save &quot;</a>
<a name="ln2090">				&quot;failed with error 0x%&quot; B_PRIx32 &quot;\n&quot;, saveError));</a>
<a name="ln2091">		}</a>
<a name="ln2092">		saveError = fRecentApps.Save(file);</a>
<a name="ln2093">		if (saveError) {</a>
<a name="ln2094">			D(PRINT(&quot;TRoster::_SaveRosterSettings(): recent folders save &quot;</a>
<a name="ln2095">				&quot;failed with error 0x%&quot; B_PRIx32 &quot;\n&quot;, saveError));</a>
<a name="ln2096">		}</a>
<a name="ln2097">		fclose(file);</a>
<a name="ln2098">	}</a>
<a name="ln2099"> </a>
<a name="ln2100">	return error;</a>
<a name="ln2101">}</a>

</code></pre>
<div class="balloon" rel="495"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="686"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="739"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="1660"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
