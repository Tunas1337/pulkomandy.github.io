
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>kernel_emu.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// kernel_emu.cpp</a>
<a name="ln2"> </a>
<a name="ln3">#include &quot;kernel_emu.h&quot;</a>
<a name="ln4"> </a>
<a name="ln5">#include &lt;stdarg.h&gt;</a>
<a name="ln6">#include &lt;stdio.h&gt;</a>
<a name="ln7">#include &lt;stdlib.h&gt;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;algorithm&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;FileSystem.h&quot;</a>
<a name="ln12">#include &quot;RequestPort.h&quot;</a>
<a name="ln13">#include &quot;Requests.h&quot;</a>
<a name="ln14">#include &quot;RequestThread.h&quot;</a>
<a name="ln15">#include &quot;UserlandFSServer.h&quot;</a>
<a name="ln16">#include &quot;UserlandRequestHandler.h&quot;</a>
<a name="ln17">#include &quot;Volume.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19"> </a>
<a name="ln20">// Taken from the Haiku Storage Kit (storage_support.cpp)</a>
<a name="ln21">/*! The length of the first component is returned as well as the index at</a>
<a name="ln22">	which the next one starts. These values are only valid, if the function</a>
<a name="ln23">	returns \c B_OK.</a>
<a name="ln24">	\param path the path to be parsed</a>
<a name="ln25">	\param length the variable the length of the first component is written</a>
<a name="ln26">		   into</a>
<a name="ln27">	\param nextComponent the variable the index of the next component is</a>
<a name="ln28">		   written into. \c 0 is returned, if there is no next component.</a>
<a name="ln29">	\return \c B_OK, if \a path is not \c NULL, \c B_BAD_VALUE otherwise</a>
<a name="ln30">*/</a>
<a name="ln31">static status_t</a>
<a name="ln32">parse_first_path_component(const char *path, int32&amp; length,</a>
<a name="ln33">						   int32&amp; nextComponent)</a>
<a name="ln34">{</a>
<a name="ln35">	status_t error = (path ? B_OK : B_BAD_VALUE);</a>
<a name="ln36">	if (error == B_OK) {</a>
<a name="ln37">		int32 i = 0;</a>
<a name="ln38">		// find first '/' or end of name</a>
<a name="ln39">		for (; path[i] != '/' &amp;&amp; path[i] != '\0'; i++);</a>
<a name="ln40">		// handle special case &quot;/...&quot; (absolute path)</a>
<a name="ln41">		if (i == 0 &amp;&amp; path[i] != '\0')</a>
<a name="ln42">			i = 1;</a>
<a name="ln43">		length = i;</a>
<a name="ln44">		// find last '/' or end of name</a>
<a name="ln45">		for (; path[i] == '/' &amp;&amp; path[i] != '\0'; i++);</a>
<a name="ln46">		if (path[i] == '\0')	// this covers &quot;&quot; as well</a>
<a name="ln47">			nextComponent = 0;</a>
<a name="ln48">		else</a>
<a name="ln49">			nextComponent = i;</a>
<a name="ln50">	}</a>
<a name="ln51">	return error;</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">// new_path</a>
<a name="ln55">int</a>
<a name="ln56">UserlandFS::KernelEmu::new_path(const char *path, char **copy)</a>
<a name="ln57">{</a>
<a name="ln58">	// check errors and special cases</a>
<a name="ln59">	if (!copy)</a>
<a name="ln60">		return B_BAD_VALUE;</a>
<a name="ln61">	if (!path) {</a>
<a name="ln62">		*copy = NULL;</a>
<a name="ln63">		return B_OK;</a>
<a name="ln64">	}</a>
<a name="ln65">	int32 len = strlen(path);</a>
<a name="ln66">	if (len &lt; 1)</a>
<a name="ln67">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln68">	bool appendDot = (path[len - 1] == '/');</a>
<a name="ln69">	if (appendDot)</a>
<a name="ln70">		len++;</a>
<a name="ln71">	if (len &gt;= B_PATH_NAME_LENGTH)</a>
<a name="ln72">		return B_NAME_TOO_LONG;</a>
<a name="ln73">	// check the path components</a>
<a name="ln74">	const char *remainder = path;</a>
<a name="ln75">	int32 length, nextComponent;</a>
<a name="ln76">	do {</a>
<a name="ln77">		status_t error</a>
<a name="ln78">			= parse_first_path_component(remainder, length, nextComponent);</a>
<a name="ln79">		if (error != B_OK)</a>
<a name="ln80">			return error;</a>
<a name="ln81">		if (length &gt;= B_FILE_NAME_LENGTH)</a>
<a name="ln82">			error = B_NAME_TOO_LONG;</a>
<a name="ln83">		remainder += nextComponent;</a>
<a name="ln84">	} while (nextComponent != 0);</a>
<a name="ln85">	// clone the path</a>
<a name="ln86">	char *copiedPath = (char*)malloc(len + 1);</a>
<a name="ln87">	if (!copiedPath)</a>
<a name="ln88">		return B_NO_MEMORY;</a>
<a name="ln89">	strcpy(copiedPath, path);</a>
<a name="ln90">	// append a dot, if desired</a>
<a name="ln91">	if (appendDot) {</a>
<a name="ln92">		copiedPath[len] = '.';</a>
<a name="ln93">		copiedPath[len] = '\0';</a>
<a name="ln94">	}</a>
<a name="ln95">	*copy = copiedPath;</a>
<a name="ln96">	return B_OK;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">// free_path</a>
<a name="ln100">void</a>
<a name="ln101">UserlandFS::KernelEmu::free_path(char *p)</a>
<a name="ln102">{</a>
<a name="ln103">	free(p);</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">// #pragma mark -</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">// get_port_and_fs</a>
<a name="ln111">static status_t</a>
<a name="ln112">get_port_and_fs(RequestPort** port, FileSystem** fileSystem)</a>
<a name="ln113">{</a>
<a name="ln114">	// get the request thread</a>
<a name="ln115">	RequestThread* thread = RequestThread::GetCurrentThread();</a>
<a name="ln116">	if (thread) {</a>
<a name="ln117">		*port = thread-&gt;GetPort();</a>
<a name="ln118">		*fileSystem = thread-&gt;GetFileSystem();</a>
<a name="ln119">	} else {</a>
<a name="ln120">		*port = UserlandFSServer::GetNotificationRequestPort();</a>
<a name="ln121">		*fileSystem = UserlandFSServer::GetFileSystem();</a>
<a name="ln122">		if (!*port || !*fileSystem)</a>
<a name="ln123">			return B_BAD_VALUE;</a>
<a name="ln124">	}</a>
<a name="ln125">	return B_OK;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">// notify_listener</a>
<a name="ln129">status_t</a>
<a name="ln130">UserlandFS::KernelEmu::notify_listener(int32 operation, uint32 details,</a>
<a name="ln131">	dev_t device, ino_t oldDirectory, ino_t directory,</a>
<a name="ln132">	ino_t node, const char* oldName, const char* name)</a>
<a name="ln133">{</a>
<a name="ln134">	// get the request port and the file system</a>
<a name="ln135">	RequestPort* port;</a>
<a name="ln136">	FileSystem* fileSystem;</a>
<a name="ln137">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln138">	if (error != B_OK)</a>
<a name="ln139">		return error;</a>
<a name="ln140"> </a>
<a name="ln141">	// prepare the request</a>
<a name="ln142">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln143">	NotifyListenerRequest* request;</a>
<a name="ln144">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln145">	if (error != B_OK)</a>
<a name="ln146">		return error;</a>
<a name="ln147"> </a>
<a name="ln148">	request-&gt;operation = operation;</a>
<a name="ln149">	request-&gt;details = details;</a>
<a name="ln150">	request-&gt;device = device;</a>
<a name="ln151">	request-&gt;oldDirectory = oldDirectory;</a>
<a name="ln152">	request-&gt;directory = directory;</a>
<a name="ln153">	request-&gt;node = node;</a>
<a name="ln154">	error = allocator.AllocateString(request-&gt;oldName, oldName);</a>
<a name="ln155">	if (error != B_OK)</a>
<a name="ln156">		return error;</a>
<a name="ln157">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln158">	if (error != B_OK)</a>
<a name="ln159">		return error;</a>
<a name="ln160"> </a>
<a name="ln161">	// send the request</a>
<a name="ln162">	UserlandRequestHandler handler(fileSystem, NOTIFY_LISTENER_REPLY);</a>
<a name="ln163">	NotifyListenerReply* reply;</a>
<a name="ln164">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln165">	if (error != B_OK)</a>
<a name="ln166">		return error;</a>
<a name="ln167">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln168"> </a>
<a name="ln169">	// process the reply</a>
<a name="ln170">	if (reply-&gt;error != B_OK)</a>
<a name="ln171">		return reply-&gt;error;</a>
<a name="ln172">	return error;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">// notify_select_event</a>
<a name="ln176">status_t</a>
<a name="ln177">UserlandFS::KernelEmu::notify_select_event(selectsync *sync, uint8 event,</a>
<a name="ln178">	bool unspecifiedEvent)</a>
<a name="ln179">{</a>
<a name="ln180">	// get the request port and the file system</a>
<a name="ln181">	RequestPort* port;</a>
<a name="ln182">	FileSystem* fileSystem;</a>
<a name="ln183">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln184">	if (error != B_OK)</a>
<a name="ln185">		return error;</a>
<a name="ln186"> </a>
<a name="ln187">	// prepare the request</a>
<a name="ln188">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln189">	NotifySelectEventRequest* request;</a>
<a name="ln190">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln191">	if (error != B_OK)</a>
<a name="ln192">		return error;</a>
<a name="ln193"> </a>
<a name="ln194">	request-&gt;sync = sync;</a>
<a name="ln195">	request-&gt;event = event;</a>
<a name="ln196">	request-&gt;unspecifiedEvent = unspecifiedEvent;</a>
<a name="ln197"> </a>
<a name="ln198">	// send the request</a>
<a name="ln199">	UserlandRequestHandler handler(fileSystem, NOTIFY_SELECT_EVENT_REPLY);</a>
<a name="ln200">	NotifySelectEventReply* reply;</a>
<a name="ln201">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln202">	if (error != B_OK)</a>
<a name="ln203">		return error;</a>
<a name="ln204">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln205"> </a>
<a name="ln206">	// process the reply</a>
<a name="ln207">	if (reply-&gt;error != B_OK)</a>
<a name="ln208">		return reply-&gt;error;</a>
<a name="ln209">	return error;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">// send_notification</a>
<a name="ln213">status_t</a>
<a name="ln214">UserlandFS::KernelEmu::notify_query(port_id targetPort, int32 token,</a>
<a name="ln215">	int32 operation, dev_t device, ino_t directory, const char* name,</a>
<a name="ln216">	ino_t node)</a>
<a name="ln217">{</a>
<a name="ln218">	// get the request port and the file system</a>
<a name="ln219">	RequestPort* port;</a>
<a name="ln220">	FileSystem* fileSystem;</a>
<a name="ln221">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln222">	if (error != B_OK)</a>
<a name="ln223">		return error;</a>
<a name="ln224"> </a>
<a name="ln225">	// prepare the request</a>
<a name="ln226">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln227">	NotifyQueryRequest* request;</a>
<a name="ln228">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln229">	if (error != B_OK)</a>
<a name="ln230">		return error;</a>
<a name="ln231"> </a>
<a name="ln232">	request-&gt;port = targetPort;</a>
<a name="ln233">	request-&gt;token = token;</a>
<a name="ln234">	request-&gt;operation = operation;</a>
<a name="ln235">	request-&gt;device = device;</a>
<a name="ln236">	request-&gt;directory = directory;</a>
<a name="ln237">	request-&gt;node = node;</a>
<a name="ln238">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln239">	if (error != B_OK)</a>
<a name="ln240">		return error;</a>
<a name="ln241"> </a>
<a name="ln242">	// send the request</a>
<a name="ln243">	UserlandRequestHandler handler(fileSystem, NOTIFY_QUERY_REPLY);</a>
<a name="ln244">	NotifyQueryReply* reply;</a>
<a name="ln245">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln246">	if (error != B_OK)</a>
<a name="ln247">		return error;</a>
<a name="ln248">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln249"> </a>
<a name="ln250">	// process the reply</a>
<a name="ln251">	if (reply-&gt;error != B_OK)</a>
<a name="ln252">		return reply-&gt;error;</a>
<a name="ln253">	return error;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">// #pragma mark -</a>
<a name="ln258"> </a>
<a name="ln259"> </a>
<a name="ln260">// get_vnode</a>
<a name="ln261">status_t</a>
<a name="ln262">UserlandFS::KernelEmu::get_vnode(dev_t nsid, ino_t vnid, void** node)</a>
<a name="ln263">{</a>
<a name="ln264">	// get the request port and the file system</a>
<a name="ln265">	RequestPort* port;</a>
<a name="ln266">	FileSystem* fileSystem;</a>
<a name="ln267">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln268">	if (error != B_OK)</a>
<a name="ln269">		return error;</a>
<a name="ln270"> </a>
<a name="ln271">	// prepare the request</a>
<a name="ln272">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln273">	GetVNodeRequest* request;</a>
<a name="ln274">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln275">	if (error != B_OK)</a>
<a name="ln276">		return error;</a>
<a name="ln277"> </a>
<a name="ln278">	request-&gt;nsid = nsid;</a>
<a name="ln279">	request-&gt;vnid = vnid;</a>
<a name="ln280"> </a>
<a name="ln281">	// send the request</a>
<a name="ln282">	UserlandRequestHandler handler(fileSystem, GET_VNODE_REPLY);</a>
<a name="ln283">	GetVNodeReply* reply;</a>
<a name="ln284">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln285">	if (error != B_OK)</a>
<a name="ln286">		return error;</a>
<a name="ln287">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln288"> </a>
<a name="ln289">	// process the reply</a>
<a name="ln290">	if (reply-&gt;error != B_OK)</a>
<a name="ln291">		return reply-&gt;error;</a>
<a name="ln292">	*node = reply-&gt;node;</a>
<a name="ln293">	return error;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">// put_vnode</a>
<a name="ln297">status_t</a>
<a name="ln298">UserlandFS::KernelEmu::put_vnode(dev_t nsid, ino_t vnid)</a>
<a name="ln299">{</a>
<a name="ln300">	// get the request port and the file system</a>
<a name="ln301">	RequestPort* port;</a>
<a name="ln302">	FileSystem* fileSystem;</a>
<a name="ln303">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln304">	if (error != B_OK)</a>
<a name="ln305">		return error;</a>
<a name="ln306"> </a>
<a name="ln307">	// prepare the request</a>
<a name="ln308">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln309">	PutVNodeRequest* request;</a>
<a name="ln310">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln311">	if (error != B_OK)</a>
<a name="ln312">		return error;</a>
<a name="ln313"> </a>
<a name="ln314">	request-&gt;nsid = nsid;</a>
<a name="ln315">	request-&gt;vnid = vnid;</a>
<a name="ln316"> </a>
<a name="ln317">	// send the request</a>
<a name="ln318">	UserlandRequestHandler handler(fileSystem, PUT_VNODE_REPLY);</a>
<a name="ln319">	PutVNodeReply* reply;</a>
<a name="ln320">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln321">	if (error != B_OK)</a>
<a name="ln322">		return error;</a>
<a name="ln323">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln324"> </a>
<a name="ln325">	// process the reply</a>
<a name="ln326">	if (reply-&gt;error != B_OK)</a>
<a name="ln327">		return reply-&gt;error;</a>
<a name="ln328">	return error;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">// acquire_vnode</a>
<a name="ln332">status_t</a>
<a name="ln333">UserlandFS::KernelEmu::acquire_vnode(dev_t nsid, ino_t vnid)</a>
<a name="ln334">{</a>
<a name="ln335">	// get the request port and the file system</a>
<a name="ln336">	RequestPort* port;</a>
<a name="ln337">	FileSystem* fileSystem;</a>
<a name="ln338">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln339">	if (error != B_OK)</a>
<a name="ln340">		return error;</a>
<a name="ln341"> </a>
<a name="ln342">	// prepare the request</a>
<a name="ln343">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln344">	AcquireVNodeRequest* request;</a>
<a name="ln345">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln346">	if (error != B_OK)</a>
<a name="ln347">		return error;</a>
<a name="ln348"> </a>
<a name="ln349">	request-&gt;nsid = nsid;</a>
<a name="ln350">	request-&gt;vnid = vnid;</a>
<a name="ln351"> </a>
<a name="ln352">	// send the request</a>
<a name="ln353">	UserlandRequestHandler handler(fileSystem, ACQUIRE_VNODE_REPLY);</a>
<a name="ln354">	AcquireVNodeReply* reply;</a>
<a name="ln355">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln356">	if (error != B_OK)</a>
<a name="ln357">		return error;</a>
<a name="ln358">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln359"> </a>
<a name="ln360">	// process the reply</a>
<a name="ln361">	if (reply-&gt;error != B_OK)</a>
<a name="ln362">		return reply-&gt;error;</a>
<a name="ln363">	return error;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">// new_vnode</a>
<a name="ln367">status_t</a>
<a name="ln368">UserlandFS::KernelEmu::new_vnode(dev_t nsid, ino_t vnid, void* data,</a>
<a name="ln369">	const FSVNodeCapabilities&amp; capabilities)</a>
<a name="ln370">{</a>
<a name="ln371">	// get the request port and the file system</a>
<a name="ln372">	RequestPort* port;</a>
<a name="ln373">	FileSystem* fileSystem;</a>
<a name="ln374">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln375">	if (error != B_OK)</a>
<a name="ln376">		return error;</a>
<a name="ln377"> </a>
<a name="ln378">	// prepare the request</a>
<a name="ln379">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln380">	NewVNodeRequest* request;</a>
<a name="ln381">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln382">	if (error != B_OK)</a>
<a name="ln383">		return error;</a>
<a name="ln384"> </a>
<a name="ln385">	request-&gt;nsid = nsid;</a>
<a name="ln386">	request-&gt;vnid = vnid;</a>
<a name="ln387">	request-&gt;node = data;</a>
<a name="ln388">	request-&gt;capabilities = capabilities;</a>
<a name="ln389"> </a>
<a name="ln390">	// send the request</a>
<a name="ln391">	UserlandRequestHandler handler(fileSystem, NEW_VNODE_REPLY);</a>
<a name="ln392">	NewVNodeReply* reply;</a>
<a name="ln393">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln394">	if (error != B_OK)</a>
<a name="ln395">		return error;</a>
<a name="ln396">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln397"> </a>
<a name="ln398">	// process the reply</a>
<a name="ln399">	if (reply-&gt;error != B_OK)</a>
<a name="ln400">		return reply-&gt;error;</a>
<a name="ln401">	return error;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">// publish_vnode</a>
<a name="ln405">status_t</a>
<a name="ln406">UserlandFS::KernelEmu::publish_vnode(dev_t nsid, ino_t vnid, void* data,</a>
<a name="ln407">	int type, uint32 flags, const FSVNodeCapabilities&amp; capabilities)</a>
<a name="ln408">{</a>
<a name="ln409">	// get the request port and the file system</a>
<a name="ln410">	RequestPort* port;</a>
<a name="ln411">	FileSystem* fileSystem;</a>
<a name="ln412">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln413">	if (error != B_OK)</a>
<a name="ln414">		return error;</a>
<a name="ln415"> </a>
<a name="ln416">	// prepare the request</a>
<a name="ln417">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln418">	PublishVNodeRequest* request;</a>
<a name="ln419">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln420">	if (error != B_OK)</a>
<a name="ln421">		return error;</a>
<a name="ln422"> </a>
<a name="ln423">	request-&gt;nsid = nsid;</a>
<a name="ln424">	request-&gt;vnid = vnid;</a>
<a name="ln425">	request-&gt;node = data;</a>
<a name="ln426">	request-&gt;type = type;</a>
<a name="ln427">	request-&gt;flags = flags;</a>
<a name="ln428">	request-&gt;capabilities = capabilities;</a>
<a name="ln429"> </a>
<a name="ln430">	// send the request</a>
<a name="ln431">	UserlandRequestHandler handler(fileSystem, PUBLISH_VNODE_REPLY);</a>
<a name="ln432">	PublishVNodeReply* reply;</a>
<a name="ln433">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln434">	if (error != B_OK)</a>
<a name="ln435">		return error;</a>
<a name="ln436">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln437"> </a>
<a name="ln438">	// process the reply</a>
<a name="ln439">	if (reply-&gt;error != B_OK)</a>
<a name="ln440">		return reply-&gt;error;</a>
<a name="ln441">	return error;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">// publish_vnode</a>
<a name="ln446">status_t</a>
<a name="ln447">UserlandFS::KernelEmu::publish_vnode(dev_t nsid, ino_t vnid, void* data,</a>
<a name="ln448">	const FSVNodeCapabilities&amp; capabilities)</a>
<a name="ln449">{</a>
<a name="ln450">	// get the volume</a>
<a name="ln451">	Volume* volume = FileSystem::GetInstance()-&gt;VolumeWithID(nsid);</a>
<a name="ln452">	if (volume == NULL)</a>
<a name="ln453">		return B_BAD_VALUE;</a>
<a name="ln454"> </a>
<a name="ln455">	// stat() the node to get its type</a>
<a name="ln456">	int type;</a>
<a name="ln457">	status_t error = volume-&gt;GetVNodeType(data, &amp;type);</a>
<a name="ln458">	if (error != B_OK)</a>
<a name="ln459">		return error;</a>
<a name="ln460"> </a>
<a name="ln461">	// publish the node</a>
<a name="ln462">	return UserlandFS::KernelEmu::publish_vnode(nsid, vnid, data, type, 0,</a>
<a name="ln463">		capabilities);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">// remove_vnode</a>
<a name="ln468">status_t</a>
<a name="ln469">UserlandFS::KernelEmu::remove_vnode(dev_t nsid, ino_t vnid)</a>
<a name="ln470">{</a>
<a name="ln471">	// get the request port and the file system</a>
<a name="ln472">	RequestPort* port;</a>
<a name="ln473">	FileSystem* fileSystem;</a>
<a name="ln474">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln475">	if (error != B_OK)</a>
<a name="ln476">		return error;</a>
<a name="ln477"> </a>
<a name="ln478">	// prepare the request</a>
<a name="ln479">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln480">	RemoveVNodeRequest* request;</a>
<a name="ln481">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln482">	if (error != B_OK)</a>
<a name="ln483">		return error;</a>
<a name="ln484"> </a>
<a name="ln485">	request-&gt;nsid = nsid;</a>
<a name="ln486">	request-&gt;vnid = vnid;</a>
<a name="ln487"> </a>
<a name="ln488">	// send the request</a>
<a name="ln489">	UserlandRequestHandler handler(fileSystem, REMOVE_VNODE_REPLY);</a>
<a name="ln490">	RemoveVNodeReply* reply;</a>
<a name="ln491">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln492">	if (error != B_OK)</a>
<a name="ln493">		return error;</a>
<a name="ln494">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln495"> </a>
<a name="ln496">	// process the reply</a>
<a name="ln497">	if (reply-&gt;error != B_OK)</a>
<a name="ln498">		return reply-&gt;error;</a>
<a name="ln499">	return error;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">// unremove_vnode</a>
<a name="ln503">status_t</a>
<a name="ln504">UserlandFS::KernelEmu::unremove_vnode(dev_t nsid, ino_t vnid)</a>
<a name="ln505">{</a>
<a name="ln506">	// get the request port and the file system</a>
<a name="ln507">	RequestPort* port;</a>
<a name="ln508">	FileSystem* fileSystem;</a>
<a name="ln509">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln510">	if (error != B_OK)</a>
<a name="ln511">		return error;</a>
<a name="ln512"> </a>
<a name="ln513">	// prepare the request</a>
<a name="ln514">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln515">	UnremoveVNodeRequest* request;</a>
<a name="ln516">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln517">	if (error != B_OK)</a>
<a name="ln518">		return error;</a>
<a name="ln519"> </a>
<a name="ln520">	request-&gt;nsid = nsid;</a>
<a name="ln521">	request-&gt;vnid = vnid;</a>
<a name="ln522"> </a>
<a name="ln523">	// send the request</a>
<a name="ln524">	UserlandRequestHandler handler(fileSystem, UNREMOVE_VNODE_REPLY);</a>
<a name="ln525">	UnremoveVNodeReply* reply;</a>
<a name="ln526">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln527">	if (error != B_OK)</a>
<a name="ln528">		return error;</a>
<a name="ln529">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln530"> </a>
<a name="ln531">	// process the reply</a>
<a name="ln532">	if (reply-&gt;error != B_OK)</a>
<a name="ln533">		return reply-&gt;error;</a>
<a name="ln534">	return error;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">// get_vnode_removed</a>
<a name="ln538">status_t</a>
<a name="ln539">UserlandFS::KernelEmu::get_vnode_removed(dev_t nsid, ino_t vnid,</a>
<a name="ln540">	bool* removed)</a>
<a name="ln541">{</a>
<a name="ln542">	// get the request port and the file system</a>
<a name="ln543">	RequestPort* port;</a>
<a name="ln544">	FileSystem* fileSystem;</a>
<a name="ln545">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln546">	if (error != B_OK)</a>
<a name="ln547">		return error;</a>
<a name="ln548"> </a>
<a name="ln549">	// prepare the request</a>
<a name="ln550">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln551">	GetVNodeRemovedRequest* request;</a>
<a name="ln552">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln553">	if (error != B_OK)</a>
<a name="ln554">		return error;</a>
<a name="ln555"> </a>
<a name="ln556">	request-&gt;nsid = nsid;</a>
<a name="ln557">	request-&gt;vnid = vnid;</a>
<a name="ln558"> </a>
<a name="ln559">	// send the request</a>
<a name="ln560">	UserlandRequestHandler handler(fileSystem, GET_VNODE_REMOVED_REPLY);</a>
<a name="ln561">	GetVNodeRemovedReply* reply;</a>
<a name="ln562">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln563">	if (error != B_OK)</a>
<a name="ln564">		return error;</a>
<a name="ln565">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln566"> </a>
<a name="ln567">	// process the reply</a>
<a name="ln568">	*removed = reply-&gt;removed;</a>
<a name="ln569">	return reply-&gt;error;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">// #pragma mark - file cache</a>
<a name="ln574"> </a>
<a name="ln575"> </a>
<a name="ln576">// file_cache_create</a>
<a name="ln577">status_t</a>
<a name="ln578">UserlandFS::KernelEmu::file_cache_create(dev_t mountID, ino_t vnodeID,</a>
<a name="ln579">	off_t size)</a>
<a name="ln580">{</a>
<a name="ln581">	// get the request port and the file system</a>
<a name="ln582">	RequestPort* port;</a>
<a name="ln583">	FileSystem* fileSystem;</a>
<a name="ln584">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln585">	if (error != B_OK)</a>
<a name="ln586">		RETURN_ERROR(error);</a>
<a name="ln587"> </a>
<a name="ln588">	// prepare the request</a>
<a name="ln589">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln590">	FileCacheCreateRequest* request;</a>
<a name="ln591">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln592">	if (error != B_OK)</a>
<a name="ln593">		RETURN_ERROR(error);</a>
<a name="ln594"> </a>
<a name="ln595">	request-&gt;nsid = mountID;</a>
<a name="ln596">	request-&gt;vnid = vnodeID;</a>
<a name="ln597">	request-&gt;size = size;</a>
<a name="ln598"> </a>
<a name="ln599">	// send the request</a>
<a name="ln600">	UserlandRequestHandler handler(fileSystem, FILE_CACHE_CREATE_REPLY);</a>
<a name="ln601">	FileCacheCreateReply* reply;</a>
<a name="ln602">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln603">	if (error != B_OK)</a>
<a name="ln604">		RETURN_ERROR(error);</a>
<a name="ln605">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln606"> </a>
<a name="ln607">	// process the reply</a>
<a name="ln608">	RETURN_ERROR(reply-&gt;error);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611"> </a>
<a name="ln612">// file_cache_delete</a>
<a name="ln613">status_t</a>
<a name="ln614">UserlandFS::KernelEmu::file_cache_delete(dev_t mountID, ino_t vnodeID)</a>
<a name="ln615">{</a>
<a name="ln616">	// get the request port and the file system</a>
<a name="ln617">	RequestPort* port;</a>
<a name="ln618">	FileSystem* fileSystem;</a>
<a name="ln619">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln620">	if (error != B_OK)</a>
<a name="ln621">		return error;</a>
<a name="ln622"> </a>
<a name="ln623">	// prepare the request</a>
<a name="ln624">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln625">	FileCacheDeleteRequest* request;</a>
<a name="ln626">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln627">	if (error != B_OK)</a>
<a name="ln628">		return error;</a>
<a name="ln629"> </a>
<a name="ln630">	request-&gt;nsid = mountID;</a>
<a name="ln631">	request-&gt;vnid = vnodeID;</a>
<a name="ln632"> </a>
<a name="ln633">	// send the request</a>
<a name="ln634">	UserlandRequestHandler handler(fileSystem, FILE_CACHE_DELETE_REPLY);</a>
<a name="ln635">	FileCacheDeleteReply* reply;</a>
<a name="ln636">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln637">	if (error != B_OK)</a>
<a name="ln638">		return error;</a>
<a name="ln639">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln640"> </a>
<a name="ln641">	// process the reply</a>
<a name="ln642">	return reply-&gt;error;</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645"> </a>
<a name="ln646">// file_cache_set_enable</a>
<a name="ln647">status_t</a>
<a name="ln648">UserlandFS::KernelEmu::file_cache_set_enabled(dev_t mountID, ino_t vnodeID,</a>
<a name="ln649">	bool enabled)</a>
<a name="ln650">{</a>
<a name="ln651">	// get the request port and the file system</a>
<a name="ln652">	RequestPort* port;</a>
<a name="ln653">	FileSystem* fileSystem;</a>
<a name="ln654">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln655">	if (error != B_OK)</a>
<a name="ln656">		return error;</a>
<a name="ln657"> </a>
<a name="ln658">	// prepare the request</a>
<a name="ln659">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln660">	FileCacheSetEnabledRequest* request;</a>
<a name="ln661">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln662">	if (error != B_OK)</a>
<a name="ln663">		return error;</a>
<a name="ln664"> </a>
<a name="ln665">	request-&gt;nsid = mountID;</a>
<a name="ln666">	request-&gt;vnid = vnodeID;</a>
<a name="ln667">	request-&gt;enabled = enabled;</a>
<a name="ln668"> </a>
<a name="ln669">	// send the request</a>
<a name="ln670">	UserlandRequestHandler handler(fileSystem, FILE_CACHE_SET_ENABLED_REPLY);</a>
<a name="ln671">	FileCacheSetEnabledReply* reply;</a>
<a name="ln672">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln673">	if (error != B_OK)</a>
<a name="ln674">		return error;</a>
<a name="ln675">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln676"> </a>
<a name="ln677">	// process the reply</a>
<a name="ln678">	return reply-&gt;error;</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681"> </a>
<a name="ln682">// file_cache_set_size</a>
<a name="ln683">status_t</a>
<a name="ln684">UserlandFS::KernelEmu::file_cache_set_size(dev_t mountID, ino_t vnodeID,</a>
<a name="ln685">	off_t size)</a>
<a name="ln686">{</a>
<a name="ln687">	// get the request port and the file system</a>
<a name="ln688">	RequestPort* port;</a>
<a name="ln689">	FileSystem* fileSystem;</a>
<a name="ln690">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln691">	if (error != B_OK)</a>
<a name="ln692">		return error;</a>
<a name="ln693"> </a>
<a name="ln694">	// prepare the request</a>
<a name="ln695">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln696">	FileCacheSetSizeRequest* request;</a>
<a name="ln697">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln698">	if (error != B_OK)</a>
<a name="ln699">		return error;</a>
<a name="ln700"> </a>
<a name="ln701">	request-&gt;nsid = mountID;</a>
<a name="ln702">	request-&gt;vnid = vnodeID;</a>
<a name="ln703">	request-&gt;size = size;</a>
<a name="ln704"> </a>
<a name="ln705">	// send the request</a>
<a name="ln706">	UserlandRequestHandler handler(fileSystem, FILE_CACHE_SET_SIZE_REPLY);</a>
<a name="ln707">	FileCacheSetSizeReply* reply;</a>
<a name="ln708">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln709">	if (error != B_OK)</a>
<a name="ln710">		return error;</a>
<a name="ln711">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln712"> </a>
<a name="ln713">	// process the reply</a>
<a name="ln714">	return reply-&gt;error;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717"> </a>
<a name="ln718">// file_cache_sync</a>
<a name="ln719">status_t</a>
<a name="ln720">UserlandFS::KernelEmu::file_cache_sync(dev_t mountID, ino_t vnodeID)</a>
<a name="ln721">{</a>
<a name="ln722">	// get the request port and the file system</a>
<a name="ln723">	RequestPort* port;</a>
<a name="ln724">	FileSystem* fileSystem;</a>
<a name="ln725">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln726">	if (error != B_OK)</a>
<a name="ln727">		return error;</a>
<a name="ln728"> </a>
<a name="ln729">	// prepare the request</a>
<a name="ln730">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln731">	FileCacheSyncRequest* request;</a>
<a name="ln732">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln733">	if (error != B_OK)</a>
<a name="ln734">		return error;</a>
<a name="ln735"> </a>
<a name="ln736">	request-&gt;nsid = mountID;</a>
<a name="ln737">	request-&gt;vnid = vnodeID;</a>
<a name="ln738"> </a>
<a name="ln739">	// send the request</a>
<a name="ln740">	UserlandRequestHandler handler(fileSystem, FILE_CACHE_SYNC_REPLY);</a>
<a name="ln741">	FileCacheSyncReply* reply;</a>
<a name="ln742">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln743">	if (error != B_OK)</a>
<a name="ln744">		return error;</a>
<a name="ln745">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln746"> </a>
<a name="ln747">	// process the reply</a>
<a name="ln748">	return reply-&gt;error;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751"> </a>
<a name="ln752">// file_cache_read</a>
<a name="ln753">status_t</a>
<a name="ln754">UserlandFS::KernelEmu::file_cache_read(dev_t mountID, ino_t vnodeID,</a>
<a name="ln755">	void *cookie, off_t offset, void *bufferBase, size_t *_size)</a>
<a name="ln756">{</a>
<a name="ln757">	// get the request port and the file system</a>
<a name="ln758">	RequestPort* port;</a>
<a name="ln759">	FileSystem* fileSystem;</a>
<a name="ln760">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln761">	if (error != B_OK)</a>
<a name="ln762">		return error;</a>
<a name="ln763"> </a>
<a name="ln764">	// prepare the request</a>
<a name="ln765">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln766">	FileCacheReadRequest* request;</a>
<a name="ln767">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln768">	if (error != B_OK)</a>
<a name="ln769">		return error;</a>
<a name="ln770"> </a>
<a name="ln771">	request-&gt;nsid = mountID;</a>
<a name="ln772">	request-&gt;vnid = vnodeID;</a>
<a name="ln773">	request-&gt;cookie = cookie;</a>
<a name="ln774">	request-&gt;pos = offset;</a>
<a name="ln775">	request-&gt;size = *_size;</a>
<a name="ln776"> </a>
<a name="ln777">	// send the request</a>
<a name="ln778">	UserlandRequestHandler handler(fileSystem, FILE_CACHE_READ_REPLY);</a>
<a name="ln779">	FileCacheReadReply* reply;</a>
<a name="ln780">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln781">	if (error != B_OK)</a>
<a name="ln782">		return error;</a>
<a name="ln783">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln784"> </a>
<a name="ln785">	// process the reply</a>
<a name="ln786">	if (reply-&gt;error != B_OK)</a>
<a name="ln787">		return reply-&gt;error;</a>
<a name="ln788"> </a>
<a name="ln789">	if (reply-&gt;bytesRead &gt; 0) {</a>
<a name="ln790">		memcpy(bufferBase, reply-&gt;buffer.GetData(), reply-&gt;buffer.GetSize());</a>
<a name="ln791"> </a>
<a name="ln792">		// send receipt-ack</a>
<a name="ln793">		RequestAllocator receiptAckAllocator(port-&gt;GetPort());</a>
<a name="ln794">		ReceiptAckReply* receiptAck;</a>
<a name="ln795">		if (AllocateRequest(receiptAckAllocator, &amp;receiptAck) == B_OK)</a>
<a name="ln796">			port-&gt;SendRequest(&amp;receiptAckAllocator);</a>
<a name="ln797">	}</a>
<a name="ln798"> </a>
<a name="ln799">	*_size = reply-&gt;bytesRead;</a>
<a name="ln800"> </a>
<a name="ln801">	return B_OK;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804"> </a>
<a name="ln805">// file_cache_write</a>
<a name="ln806">status_t</a>
<a name="ln807">UserlandFS::KernelEmu::file_cache_write(dev_t mountID, ino_t vnodeID,</a>
<a name="ln808">	void *cookie, off_t offset, const void *buffer, size_t *_size)</a>
<a name="ln809">{</a>
<a name="ln810">	// get the request port and the file system</a>
<a name="ln811">	RequestPort* port;</a>
<a name="ln812">	FileSystem* fileSystem;</a>
<a name="ln813">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln814">	if (error != B_OK)</a>
<a name="ln815">		return error;</a>
<a name="ln816"> </a>
<a name="ln817">	// prepare the request</a>
<a name="ln818">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln819">	FileCacheWriteRequest* request;</a>
<a name="ln820">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln821">	if (error != B_OK)</a>
<a name="ln822">		return error;</a>
<a name="ln823"> </a>
<a name="ln824">	request-&gt;nsid = mountID;</a>
<a name="ln825">	request-&gt;vnid = vnodeID;</a>
<a name="ln826">	request-&gt;cookie = cookie;</a>
<a name="ln827">	request-&gt;size = *_size;</a>
<a name="ln828">	request-&gt;pos = offset;</a>
<a name="ln829"> </a>
<a name="ln830">	if (buffer != NULL) {</a>
<a name="ln831">		error = allocator.AllocateData(request-&gt;buffer, buffer, *_size, 1,</a>
<a name="ln832">			false);</a>
<a name="ln833">		if (error != B_OK)</a>
<a name="ln834">			return error;</a>
<a name="ln835">	}</a>
<a name="ln836"> </a>
<a name="ln837">	// send the request</a>
<a name="ln838">	UserlandRequestHandler handler(fileSystem, FILE_CACHE_WRITE_REPLY);</a>
<a name="ln839">	FileCacheWriteReply* reply;</a>
<a name="ln840">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln841">	if (error != B_OK)</a>
<a name="ln842">		return error;</a>
<a name="ln843">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln844"> </a>
<a name="ln845">	// process the reply</a>
<a name="ln846">	*_size = reply-&gt;bytesWritten;</a>
<a name="ln847">	return reply-&gt;error;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850"> </a>
<a name="ln851">// #pragma mark - I/O</a>
<a name="ln852"> </a>
<a name="ln853"> </a>
<a name="ln854">status_t</a>
<a name="ln855">UserlandFS::KernelEmu::do_iterative_fd_io(dev_t volumeID, int fd,</a>
<a name="ln856">	int32 requestID, void* cookie, const file_io_vec* vecs, uint32 vecCount)</a>
<a name="ln857">{</a>
<a name="ln858">	// get the request port and the file system</a>
<a name="ln859">	RequestPort* port;</a>
<a name="ln860">	FileSystem* fileSystem;</a>
<a name="ln861">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln862">	if (error != B_OK)</a>
<a name="ln863">		return error;</a>
<a name="ln864"> </a>
<a name="ln865">	// prepare the request</a>
<a name="ln866">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln867">	DoIterativeFDIORequest* request;</a>
<a name="ln868">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln869">	if (error != B_OK)</a>
<a name="ln870">		return error;</a>
<a name="ln871"> </a>
<a name="ln872">	request-&gt;nsid = volumeID;</a>
<a name="ln873">	request-&gt;fd = fd;</a>
<a name="ln874">	request-&gt;request = requestID;</a>
<a name="ln875">	request-&gt;cookie = cookie;</a>
<a name="ln876"> </a>
<a name="ln877">	if (vecCount &gt; 0) {</a>
<a name="ln878">		vecCount = std::min(vecCount, (uint32)DoIterativeFDIORequest::MAX_VECS);</a>
<a name="ln879">		memcpy(request-&gt;vecs, vecs, sizeof(file_io_vec) * vecCount);</a>
<a name="ln880">	}</a>
<a name="ln881">	request-&gt;vecCount = vecCount;</a>
<a name="ln882"> </a>
<a name="ln883">	// send the request</a>
<a name="ln884">	UserlandRequestHandler handler(fileSystem, DO_ITERATIVE_FD_IO_REPLY);</a>
<a name="ln885">	DoIterativeFDIOReply* reply;</a>
<a name="ln886">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln887">	if (error != B_OK)</a>
<a name="ln888">		return error;</a>
<a name="ln889">// TODO: Up to this point we should call the finished hook on error!</a>
<a name="ln890">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln891"> </a>
<a name="ln892">	// process the reply</a>
<a name="ln893">	return reply-&gt;error;</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896"> </a>
<a name="ln897">status_t</a>
<a name="ln898">UserlandFS::KernelEmu::read_from_io_request(dev_t volumeID, int32 requestID,</a>
<a name="ln899">	void* buffer, size_t size)</a>
<a name="ln900">{</a>
<a name="ln901">	// get the request port and the file system</a>
<a name="ln902">	RequestPort* port;</a>
<a name="ln903">	FileSystem* fileSystem;</a>
<a name="ln904">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln905">	if (error != B_OK)</a>
<a name="ln906">		return error;</a>
<a name="ln907"> </a>
<a name="ln908">	// prepare the request</a>
<a name="ln909">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln910">	ReadFromIORequestRequest* request;</a>
<a name="ln911">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln912">	if (error != B_OK)</a>
<a name="ln913">		return error;</a>
<a name="ln914"> </a>
<a name="ln915">	request-&gt;nsid = volumeID;</a>
<a name="ln916">	request-&gt;request = requestID;</a>
<a name="ln917">	request-&gt;size = size;</a>
<a name="ln918"> </a>
<a name="ln919">	// send the request</a>
<a name="ln920">	UserlandRequestHandler handler(fileSystem, READ_FROM_IO_REQUEST_REPLY);</a>
<a name="ln921">	ReadFromIORequestReply* reply;</a>
<a name="ln922">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln923">	if (error != B_OK)</a>
<a name="ln924">		return error;</a>
<a name="ln925">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln926"> </a>
<a name="ln927">	// process the reply</a>
<a name="ln928">	if (reply-&gt;error != B_OK)</a>
<a name="ln929">		return reply-&gt;error;</a>
<a name="ln930"> </a>
<a name="ln931">	memcpy(buffer, reply-&gt;buffer.GetData(), reply-&gt;buffer.GetSize());</a>
<a name="ln932"> </a>
<a name="ln933">	// send receipt-ack</a>
<a name="ln934">	RequestAllocator receiptAckAllocator(port-&gt;GetPort());</a>
<a name="ln935">	ReceiptAckReply* receiptAck;</a>
<a name="ln936">	if (AllocateRequest(receiptAckAllocator, &amp;receiptAck) == B_OK)</a>
<a name="ln937">		port-&gt;SendRequest(&amp;receiptAckAllocator);</a>
<a name="ln938"> </a>
<a name="ln939">	return B_OK;</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942"> </a>
<a name="ln943">status_t</a>
<a name="ln944">UserlandFS::KernelEmu::write_to_io_request(dev_t volumeID, int32 requestID,</a>
<a name="ln945">	const void* buffer, size_t size)</a>
<a name="ln946">{</a>
<a name="ln947">	// get the request port and the file system</a>
<a name="ln948">	RequestPort* port;</a>
<a name="ln949">	FileSystem* fileSystem;</a>
<a name="ln950">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln951">	if (error != B_OK)</a>
<a name="ln952">		return error;</a>
<a name="ln953"> </a>
<a name="ln954">	// prepare the request</a>
<a name="ln955">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln956">	WriteToIORequestRequest* request;</a>
<a name="ln957">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln958">	if (error != B_OK)</a>
<a name="ln959">		return error;</a>
<a name="ln960"> </a>
<a name="ln961">	request-&gt;nsid = volumeID;</a>
<a name="ln962">	request-&gt;request = requestID;</a>
<a name="ln963"> </a>
<a name="ln964">	error = allocator.AllocateData(request-&gt;buffer, buffer, size, 1, false);</a>
<a name="ln965">	if (error != B_OK)</a>
<a name="ln966">		return error;</a>
<a name="ln967"> </a>
<a name="ln968">	// send the request</a>
<a name="ln969">	UserlandRequestHandler handler(fileSystem, WRITE_TO_IO_REQUEST_REPLY);</a>
<a name="ln970">	FileCacheWriteReply* reply;</a>
<a name="ln971">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln972">	if (error != B_OK)</a>
<a name="ln973">		return error;</a>
<a name="ln974">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln975"> </a>
<a name="ln976">	// process the reply</a>
<a name="ln977">	return reply-&gt;error;</a>
<a name="ln978">}</a>
<a name="ln979"> </a>
<a name="ln980"> </a>
<a name="ln981">status_t</a>
<a name="ln982">UserlandFS::KernelEmu::notify_io_request(dev_t volumeID, int32 requestID,</a>
<a name="ln983">	status_t status)</a>
<a name="ln984">{</a>
<a name="ln985">	// get the request port and the file system</a>
<a name="ln986">	RequestPort* port;</a>
<a name="ln987">	FileSystem* fileSystem;</a>
<a name="ln988">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln989">	if (error != B_OK)</a>
<a name="ln990">		return error;</a>
<a name="ln991"> </a>
<a name="ln992">	// prepare the request</a>
<a name="ln993">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln994">	NotifyIORequestRequest* request;</a>
<a name="ln995">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln996">	if (error != B_OK)</a>
<a name="ln997">		return error;</a>
<a name="ln998"> </a>
<a name="ln999">	request-&gt;nsid = volumeID;</a>
<a name="ln1000">	request-&gt;request = requestID;</a>
<a name="ln1001">	request-&gt;status = status;</a>
<a name="ln1002"> </a>
<a name="ln1003">	// send the request</a>
<a name="ln1004">	UserlandRequestHandler handler(fileSystem, NOTIFY_IO_REQUEST_REPLY);</a>
<a name="ln1005">	NotifyIORequestReply* reply;</a>
<a name="ln1006">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1007">	if (error != B_OK)</a>
<a name="ln1008">		return error;</a>
<a name="ln1009">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1010"> </a>
<a name="ln1011">	// process the reply</a>
<a name="ln1012">	return reply-&gt;error;</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015"> </a>
<a name="ln1016">// #pragma mark - node monitoring</a>
<a name="ln1017"> </a>
<a name="ln1018"> </a>
<a name="ln1019">status_t</a>
<a name="ln1020">UserlandFS::KernelEmu::add_node_listener(dev_t device, ino_t node, uint32 flags,</a>
<a name="ln1021">	void* listener)</a>
<a name="ln1022">{</a>
<a name="ln1023">	// get the request port and the file system</a>
<a name="ln1024">	RequestPort* port;</a>
<a name="ln1025">	FileSystem* fileSystem;</a>
<a name="ln1026">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln1027">	if (error != B_OK)</a>
<a name="ln1028">		return error;</a>
<a name="ln1029"> </a>
<a name="ln1030">	// prepare the request</a>
<a name="ln1031">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1032">	AddNodeListenerRequest* request;</a>
<a name="ln1033">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1034">	if (error != B_OK)</a>
<a name="ln1035">		return error;</a>
<a name="ln1036"> </a>
<a name="ln1037">	request-&gt;device = device;</a>
<a name="ln1038">	request-&gt;node = node;</a>
<a name="ln1039">	request-&gt;flags = flags;</a>
<a name="ln1040">	request-&gt;listener = listener;</a>
<a name="ln1041"> </a>
<a name="ln1042">	// send the request</a>
<a name="ln1043">	UserlandRequestHandler handler(fileSystem, ADD_NODE_LISTENER_REPLY);</a>
<a name="ln1044">	AddNodeListenerReply* reply;</a>
<a name="ln1045">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1046">	if (error != B_OK)</a>
<a name="ln1047">		return error;</a>
<a name="ln1048">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1049"> </a>
<a name="ln1050">	// process the reply</a>
<a name="ln1051">	return reply-&gt;error;</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055">status_t</a>
<a name="ln1056">UserlandFS::KernelEmu::remove_node_listener(dev_t device, ino_t node,</a>
<a name="ln1057">	void* listener)</a>
<a name="ln1058">{</a>
<a name="ln1059">	// get the request port and the file system</a>
<a name="ln1060">	RequestPort* port;</a>
<a name="ln1061">	FileSystem* fileSystem;</a>
<a name="ln1062">	status_t error = get_port_and_fs(&amp;port, &amp;fileSystem);</a>
<a name="ln1063">	if (error != B_OK)</a>
<a name="ln1064">		return error;</a>
<a name="ln1065"> </a>
<a name="ln1066">	// prepare the request</a>
<a name="ln1067">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1068">	RemoveNodeListenerRequest* request;</a>
<a name="ln1069">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1070">	if (error != B_OK)</a>
<a name="ln1071">		return error;</a>
<a name="ln1072"> </a>
<a name="ln1073">	request-&gt;device = device;</a>
<a name="ln1074">	request-&gt;node = node;</a>
<a name="ln1075">	request-&gt;listener = listener;</a>
<a name="ln1076"> </a>
<a name="ln1077">	// send the request</a>
<a name="ln1078">	UserlandRequestHandler handler(fileSystem, REMOVE_NODE_LISTENER_REPLY);</a>
<a name="ln1079">	RemoveNodeListenerReply* reply;</a>
<a name="ln1080">	error = port-&gt;SendRequest(&amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1081">	if (error != B_OK)</a>
<a name="ln1082">		return error;</a>
<a name="ln1083">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1084"> </a>
<a name="ln1085">	// process the reply</a>
<a name="ln1086">	return reply-&gt;error;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089"> </a>
<a name="ln1090">// #pragma mark -</a>
<a name="ln1091"> </a>
<a name="ln1092"> </a>
<a name="ln1093">// kernel_debugger</a>
<a name="ln1094">void</a>
<a name="ln1095">UserlandFS::KernelEmu::kernel_debugger(const char *message)</a>
<a name="ln1096">{</a>
<a name="ln1097">	debugger(message);</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">// vdprintf</a>
<a name="ln1101">void</a>
<a name="ln1102">UserlandFS::KernelEmu::vdprintf(const char *format, va_list args)</a>
<a name="ln1103">{</a>
<a name="ln1104">	vprintf(format, args);</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107">// dprintf</a>
<a name="ln1108">void</a>
<a name="ln1109">UserlandFS::KernelEmu::dprintf(const char *format, ...)</a>
<a name="ln1110">{</a>
<a name="ln1111">	va_list args;</a>
<a name="ln1112">	va_start(args, format);</a>
<a name="ln1113">	vdprintf(format, args);</a>
<a name="ln1114">	va_end(args);</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">void</a>
<a name="ln1118">UserlandFS::KernelEmu::dump_block(const char *buffer, int size,</a>
<a name="ln1119">	const char *prefix)</a>
<a name="ln1120">{</a>
<a name="ln1121">	// TODO: Implement!</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">// parse_expression</a>
<a name="ln1125">//ulong</a>
<a name="ln1126">//parse_expression(char *str)</a>
<a name="ln1127">//{</a>
<a name="ln1128">//	return 0;</a>
<a name="ln1129">//}</a>
<a name="ln1130"> </a>
<a name="ln1131">// add_debugger_command</a>
<a name="ln1132">int</a>
<a name="ln1133">UserlandFS::KernelEmu::add_debugger_command(char *name,</a>
<a name="ln1134">	int (*func)(int argc, char **argv), char *help)</a>
<a name="ln1135">{</a>
<a name="ln1136">	return B_OK;</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139">// remove_debugger_command</a>
<a name="ln1140">int</a>
<a name="ln1141">UserlandFS::KernelEmu::remove_debugger_command(char *name,</a>
<a name="ln1142">	int (*func)(int argc, char **argv))</a>
<a name="ln1143">{</a>
<a name="ln1144">	return B_OK;</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147">// parse_expression</a>
<a name="ln1148">uint32</a>
<a name="ln1149">UserlandFS::KernelEmu::parse_expression(const char *string)</a>
<a name="ln1150">{</a>
<a name="ln1151">	return 0;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154"> </a>
<a name="ln1155">// kprintf</a>
<a name="ln1156">//void</a>
<a name="ln1157">//kprintf(const char *format, ...)</a>
<a name="ln1158">//{</a>
<a name="ln1159">//}</a>
<a name="ln1160"> </a>
<a name="ln1161">// spawn_kernel_thread</a>
<a name="ln1162">thread_id</a>
<a name="ln1163">UserlandFS::KernelEmu::spawn_kernel_thread(thread_entry function,</a>
<a name="ln1164">	const char *threadName, long priority, void *arg)</a>
<a name="ln1165">{</a>
<a name="ln1166">	return spawn_thread(function, threadName, priority, arg);</a>
<a name="ln1167">}</a>

</code></pre>
<div class="balloon" rel="93"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The 'copiedPath[len]' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 92, 93.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
