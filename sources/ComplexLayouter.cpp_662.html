
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ComplexLayouter.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007, Ingo Weinhold &lt;bonefish@cs.tu-berlin.de&gt;.</a>
<a name="ln3"> * All rights reserved. Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;ComplexLayouter.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;math.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;new&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;OS.h&gt;</a>
<a name="ln15">#include &lt;Size.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;LayoutOptimizer.h&quot;</a>
<a name="ln20">#include &quot;SimpleLayouter.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22"> </a>
<a name="ln23">//#define TRACE_COMPLEX_LAYOUTER	1</a>
<a name="ln24">#if TRACE_COMPLEX_LAYOUTER</a>
<a name="ln25">#	define TRACE(format...)	printf(format);</a>
<a name="ln26">#	define TRACE_ONLY(x)	x</a>
<a name="ln27">#else</a>
<a name="ln28">#	define TRACE(format...)</a>
<a name="ln29">#	define TRACE_ONLY(x)</a>
<a name="ln30">#endif</a>
<a name="ln31"> </a>
<a name="ln32">using std::nothrow;</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">// MyLayoutInfo</a>
<a name="ln36">class ComplexLayouter::MyLayoutInfo : public LayoutInfo {</a>
<a name="ln37">public:</a>
<a name="ln38">	MyLayoutInfo(int32 elementCount, int32 spacing)</a>
<a name="ln39">		: fCount(elementCount),</a>
<a name="ln40">		  fSpacing(spacing)</a>
<a name="ln41">	{</a>
<a name="ln42">		// We also store the location of the virtual elementCountth element.</a>
<a name="ln43">		// Thus fLocation[i + 1] - fLocation[i] is the size of the ith element</a>
<a name="ln44">		// (not considering spacing).</a>
<a name="ln45">		fLocations = new(nothrow) int32[elementCount + 1];</a>
<a name="ln46">	}</a>
<a name="ln47"> </a>
<a name="ln48">	~MyLayoutInfo()</a>
<a name="ln49">	{</a>
<a name="ln50">		delete[] fLocations;</a>
<a name="ln51">	}</a>
<a name="ln52"> </a>
<a name="ln53">	void InitFromSizes(int32* sizes)</a>
<a name="ln54">	{</a>
<a name="ln55">		fLocations[0] = 0;</a>
<a name="ln56">		for (int32 i = 0; i &lt; fCount; i++) </a>
<a name="ln57">			fLocations[i + 1] = fLocations[i] + sizes[i] + fSpacing;</a>
<a name="ln58">	}</a>
<a name="ln59"> </a>
<a name="ln60">	virtual float ElementLocation(int32 element)</a>
<a name="ln61">	{</a>
<a name="ln62">		if (element &lt; 0 || element &gt;= fCount)</a>
<a name="ln63">			return 0;</a>
<a name="ln64"> </a>
<a name="ln65">		return fLocations[element];</a>
<a name="ln66">	}</a>
<a name="ln67"> </a>
<a name="ln68">	virtual float ElementSize(int32 element)</a>
<a name="ln69">	{</a>
<a name="ln70">		if (element &lt; 0 || element &gt;= fCount)</a>
<a name="ln71">			return -1;</a>
<a name="ln72"> </a>
<a name="ln73">		return fLocations[element + 1] - fLocations[element] - 1</a>
<a name="ln74">			- fSpacing;</a>
<a name="ln75">	}</a>
<a name="ln76"> </a>
<a name="ln77">	virtual float ElementRangeSize(int32 position, int32 length)</a>
<a name="ln78">	{</a>
<a name="ln79">		if (position &lt; 0 || length &lt; 0 || position + length &gt; fCount)</a>
<a name="ln80">			return -1;</a>
<a name="ln81"> </a>
<a name="ln82">		return fLocations[position + length] - fLocations[position] - 1</a>
<a name="ln83">			- fSpacing;</a>
<a name="ln84">	}</a>
<a name="ln85"> </a>
<a name="ln86">	void Dump()</a>
<a name="ln87">	{</a>
<a name="ln88">		printf(&quot;ComplexLayouter::MyLayoutInfo(): %&quot; B_PRId32 &quot; elements:\n&quot;,</a>
<a name="ln89">			fCount);</a>
<a name="ln90">		for (int32 i = 0; i &lt; fCount + 1; i++) {</a>
<a name="ln91">			printf(&quot;  %2&quot; B_PRId32 &quot;: location: %4&quot; B_PRId32 &quot;\n&quot;, i,</a>
<a name="ln92">				fLocations[i]);</a>
<a name="ln93">		}</a>
<a name="ln94">	}</a>
<a name="ln95"> </a>
<a name="ln96">public:</a>
<a name="ln97">	int32	fCount;</a>
<a name="ln98">	int32	fSpacing;</a>
<a name="ln99">	int32*	fLocations;</a>
<a name="ln100">};</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">// Constraint</a>
<a name="ln104">struct ComplexLayouter::Constraint {</a>
<a name="ln105">	Constraint(int32 start, int32 end, int32 min, int32 max)</a>
<a name="ln106">		: start(start),</a>
<a name="ln107">		  end(end),</a>
<a name="ln108">		  min(min),</a>
<a name="ln109">		  max(max),</a>
<a name="ln110">		  next(NULL)</a>
<a name="ln111">	{</a>
<a name="ln112">		if (min &gt; max)</a>
<a name="ln113">			max = min;</a>
<a name="ln114">		effectiveMax = max;</a>
<a name="ln115">	}</a>
<a name="ln116"> </a>
<a name="ln117">	void Restrict(int32 newMin, int32 newMax)</a>
<a name="ln118">	{</a>
<a name="ln119">		if (newMin &gt; min)</a>
<a name="ln120">			min = newMin;</a>
<a name="ln121">		if (newMax &lt; max)</a>
<a name="ln122">			max = newMax;</a>
<a name="ln123">		if (min &gt; max)</a>
<a name="ln124">			max = min;</a>
<a name="ln125">		effectiveMax = max;</a>
<a name="ln126">	}</a>
<a name="ln127"> </a>
<a name="ln128">	bool IsSatisfied(int32* sumValues) const</a>
<a name="ln129">	{</a>
<a name="ln130">		int32 value = sumValues[end] - sumValues[start - 1];</a>
<a name="ln131">		return (value &gt;= min &amp;&amp; value &lt;= max);</a>
<a name="ln132">	}</a>
<a name="ln133"> </a>
<a name="ln134">	int32		start;</a>
<a name="ln135">	int32		end;</a>
<a name="ln136">	int32		min;</a>
<a name="ln137">	int32		max;</a>
<a name="ln138">	int32		effectiveMax;</a>
<a name="ln139">	Constraint*	next;</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">// SumItem</a>
<a name="ln144">struct ComplexLayouter::SumItem {</a>
<a name="ln145">	int32	min;</a>
<a name="ln146">	int32	max;</a>
<a name="ln147">	bool	minDirty;</a>
<a name="ln148">	bool	maxDirty;</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">// SumItemBackup</a>
<a name="ln153">struct ComplexLayouter::SumItemBackup {</a>
<a name="ln154">	int32	min;</a>
<a name="ln155">	int32	max;</a>
<a name="ln156">};</a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159">// #pragma mark - ComplexLayouter</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">// constructor</a>
<a name="ln163">ComplexLayouter::ComplexLayouter(int32 elementCount, float spacing)</a>
<a name="ln164">	: fElementCount(elementCount),</a>
<a name="ln165">	  fSpacing((int32)spacing),</a>
<a name="ln166">	  fConstraints(new(nothrow) Constraint*[elementCount]),</a>
<a name="ln167">	  fWeights(new(nothrow) float[elementCount]),</a>
<a name="ln168">	  fSums(new(nothrow) SumItem[elementCount + 1]),</a>
<a name="ln169">	  fSumBackups(new(nothrow) SumItemBackup[elementCount + 1]),</a>
<a name="ln170">	  fOptimizer(new(nothrow) LayoutOptimizer(elementCount)),</a>
<a name="ln171">	  fUnlimited(B_SIZE_UNLIMITED / (elementCount == 0 ? 1 : elementCount)),</a>
<a name="ln172">	  fMinMaxValid(false),</a>
<a name="ln173">	  fOptimizerConstraintsAdded(false)</a>
<a name="ln174">{</a>
<a name="ln175">	if (fConstraints)</a>
<a name="ln176">		memset(fConstraints, 0, sizeof(Constraint*) * fElementCount);</a>
<a name="ln177"> </a>
<a name="ln178">	if (fWeights) {</a>
<a name="ln179">		for (int32 i = 0; i &lt; fElementCount; i++)</a>
<a name="ln180">			fWeights[i] = 1.0f;</a>
<a name="ln181">	}</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">// destructor</a>
<a name="ln186">ComplexLayouter::~ComplexLayouter()</a>
<a name="ln187">{</a>
<a name="ln188">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln189">		Constraint* constraint = fConstraints[i];</a>
<a name="ln190">		fConstraints[i] = NULL;</a>
<a name="ln191">		while (constraint != NULL) {</a>
<a name="ln192">			Constraint* next = constraint-&gt;next;</a>
<a name="ln193">			delete constraint;</a>
<a name="ln194">			constraint = next;</a>
<a name="ln195">		}</a>
<a name="ln196">	}</a>
<a name="ln197"> </a>
<a name="ln198">	delete[] fConstraints;</a>
<a name="ln199">	delete[] fWeights;</a>
<a name="ln200">	delete[] fSums;</a>
<a name="ln201">	delete[] fSumBackups;</a>
<a name="ln202">  	delete fOptimizer;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">// InitCheck</a>
<a name="ln207">status_t</a>
<a name="ln208">ComplexLayouter::InitCheck() const</a>
<a name="ln209">{</a>
<a name="ln210">	if (!fConstraints || !fWeights || !fSums || !fSumBackups || !fOptimizer)</a>
<a name="ln211">		return B_NO_MEMORY;</a>
<a name="ln212">	return fOptimizer-&gt;InitCheck();</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215"> </a>
<a name="ln216">// AddConstraints</a>
<a name="ln217">void</a>
<a name="ln218">ComplexLayouter::AddConstraints(int32 element, int32 length,</a>
<a name="ln219">	float _min, float _max, float _preferred)</a>
<a name="ln220">{</a>
<a name="ln221">	if (element &lt; 0 || length &lt;= 0 || element + length &gt; fElementCount)</a>
<a name="ln222">		return;</a>
<a name="ln223"> </a>
<a name="ln224">	TRACE(&quot;%p-&gt;ComplexLayouter::AddConstraints(%ld, %ld, %ld, %ld, %ld)\n&quot;,</a>
<a name="ln225">		this, element, length, (int32)_min, (int32)_max, (int32)_preferred);</a>
<a name="ln226"> </a>
<a name="ln227">	int32 spacing = fSpacing * (length - 1);</a>
<a name="ln228">	int32 min = (int32)_min + 1 - spacing;</a>
<a name="ln229">	int32 max = (int32)_max + 1 - spacing;</a>
<a name="ln230"> </a>
<a name="ln231">	if (min &lt; 0)</a>
<a name="ln232">		min = 0;</a>
<a name="ln233">	if (max &gt; fUnlimited)</a>
<a name="ln234">		max = fUnlimited;</a>
<a name="ln235"> </a>
<a name="ln236">	int32 end = element + length - 1;</a>
<a name="ln237">	Constraint** slot = fConstraints + end;</a>
<a name="ln238">	while (*slot != NULL &amp;&amp; (*slot)-&gt;start &gt; element)</a>
<a name="ln239">		slot = &amp;(*slot)-&gt;next;</a>
<a name="ln240"> </a>
<a name="ln241">	if (*slot != NULL &amp;&amp; (*slot)-&gt;start == element) {</a>
<a name="ln242">		// previous constraint exists -- use stricter values</a>
<a name="ln243">		(*slot)-&gt;Restrict(min, max);</a>
<a name="ln244">	} else {</a>
<a name="ln245">		// no previous constraint -- create new one</a>
<a name="ln246">		Constraint* constraint = new(nothrow) Constraint(element, end, min,</a>
<a name="ln247">			max);</a>
<a name="ln248">		if (!constraint)</a>
<a name="ln249">			return;</a>
<a name="ln250">		constraint-&gt;next = *slot;</a>
<a name="ln251">		*slot = constraint;</a>
<a name="ln252">	}</a>
<a name="ln253"> </a>
<a name="ln254">	fMinMaxValid = false;</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257"> </a>
<a name="ln258">// SetWeight</a>
<a name="ln259">void</a>
<a name="ln260">ComplexLayouter::SetWeight(int32 element, float weight)</a>
<a name="ln261">{</a>
<a name="ln262">	if (element &lt; 0 || element &gt;= fElementCount)</a>
<a name="ln263">		return;</a>
<a name="ln264"> </a>
<a name="ln265">	fWeights[element] = max_c(weight, 0);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">// MinSize</a>
<a name="ln270">float</a>
<a name="ln271">ComplexLayouter::MinSize()</a>
<a name="ln272">{</a>
<a name="ln273">	_ValidateLayout();</a>
<a name="ln274">	return fMin;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277"> </a>
<a name="ln278">// MaxSize</a>
<a name="ln279">float</a>
<a name="ln280">ComplexLayouter::MaxSize()</a>
<a name="ln281">{</a>
<a name="ln282">	_ValidateLayout();</a>
<a name="ln283">	return fMax;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">// PreferredSize</a>
<a name="ln288">float</a>
<a name="ln289">ComplexLayouter::PreferredSize()</a>
<a name="ln290">{</a>
<a name="ln291">	return fMin;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294"> </a>
<a name="ln295">// CreateLayoutInfo</a>
<a name="ln296">LayoutInfo*</a>
<a name="ln297">ComplexLayouter::CreateLayoutInfo()</a>
<a name="ln298">{</a>
<a name="ln299">	MyLayoutInfo* layoutInfo = new(nothrow) MyLayoutInfo(fElementCount,</a>
<a name="ln300">		fSpacing);</a>
<a name="ln301">	if (layoutInfo &amp;&amp; !layoutInfo-&gt;fLocations) {</a>
<a name="ln302">		delete layoutInfo;</a>
<a name="ln303">		return NULL;</a>
<a name="ln304">	}</a>
<a name="ln305"> </a>
<a name="ln306">	return layoutInfo;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309"> </a>
<a name="ln310">// Layout</a>
<a name="ln311">void</a>
<a name="ln312">ComplexLayouter::Layout(LayoutInfo* _layoutInfo, float _size)</a>
<a name="ln313">{</a>
<a name="ln314">	TRACE(&quot;%p-&gt;ComplexLayouter::Layout(%ld)\n&quot;, this, (int32)_size);</a>
<a name="ln315"> </a>
<a name="ln316">	if (fElementCount == 0)</a>
<a name="ln317">		return;</a>
<a name="ln318"> </a>
<a name="ln319">	_ValidateLayout();</a>
<a name="ln320"> </a>
<a name="ln321">	MyLayoutInfo* layoutInfo = (MyLayoutInfo*)_layoutInfo;</a>
<a name="ln322"> </a>
<a name="ln323">	int32 min = fSums[fElementCount].min;</a>
<a name="ln324">	int32 max = fSums[fElementCount].max;</a>
<a name="ln325"> </a>
<a name="ln326">	int32 size = (int32)_size + 1 - (fElementCount - 1) * fSpacing;</a>
<a name="ln327">	if (size &lt; min)</a>
<a name="ln328">		size = min;</a>
<a name="ln329">	if (size &gt; max)</a>
<a name="ln330">		size = max;</a>
<a name="ln331"> </a>
<a name="ln332">	SumItem sums[fElementCount + 1];</a>
<a name="ln333">	memcpy(sums, fSums, (fElementCount + 1) * sizeof(SumItem));</a>
<a name="ln334"> </a>
<a name="ln335">	sums[fElementCount].min = size;</a>
<a name="ln336">	sums[fElementCount].max = size;</a>
<a name="ln337">	sums[fElementCount].minDirty = (size != min);</a>
<a name="ln338">	sums[fElementCount].maxDirty = (size != max);</a>
<a name="ln339"> </a>
<a name="ln340">	// propagate the size</a>
<a name="ln341">	_PropagateChangesBack(sums, fElementCount - 1, NULL);</a>
<a name="ln342">	_PropagateChanges(sums, fElementCount - 1, NULL);</a>
<a name="ln343"> </a>
<a name="ln344">#if TRACE_COMPLEX_LAYOUTER</a>
<a name="ln345">	TRACE(&quot;Layout(%ld)\n&quot;, size);</a>
<a name="ln346">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln347">		SumItem&amp; sum = sums[i + 1];</a>
<a name="ln348">		TRACE(&quot;[%ld] minc = %4ld,  maxc = %4ld\n&quot;, i + 1, sum.min, sum.max);</a>
<a name="ln349">	}</a>
<a name="ln350">#endif</a>
<a name="ln351"> </a>
<a name="ln352">	int32 sizes[fElementCount];</a>
<a name="ln353">	if (!_Layout(size, sums, sizes)) {</a>
<a name="ln354">	}</a>
<a name="ln355"> </a>
<a name="ln356">	layoutInfo-&gt;InitFromSizes(sizes);</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359"> </a>
<a name="ln360">// CloneLayouter</a>
<a name="ln361">Layouter*</a>
<a name="ln362">ComplexLayouter::CloneLayouter()</a>
<a name="ln363">{</a>
<a name="ln364">	ComplexLayouter* layouter</a>
<a name="ln365">		= new(nothrow) ComplexLayouter(fElementCount, fSpacing);</a>
<a name="ln366">	ObjectDeleter&lt;ComplexLayouter&gt; layouterDeleter(layouter);</a>
<a name="ln367">	if (!layouter || layouter-&gt;InitCheck() != B_OK</a>
<a name="ln368">		|| !layouter-&gt;fOptimizer-&gt;AddConstraintsFrom(fOptimizer)) {</a>
<a name="ln369">		return NULL;</a>
<a name="ln370">	}</a>
<a name="ln371"> </a>
<a name="ln372">	// clone the constraints</a>
<a name="ln373">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln374">		Constraint* constraint = fConstraints[i];</a>
<a name="ln375">		Constraint** end = layouter-&gt;fConstraints + i;</a>
<a name="ln376">		while (constraint) {</a>
<a name="ln377">			*end = new(nothrow) Constraint(constraint-&gt;start, constraint-&gt;end,</a>
<a name="ln378">				constraint-&gt;min, constraint-&gt;max);</a>
<a name="ln379">			if (!*end)</a>
<a name="ln380">				return NULL;</a>
<a name="ln381"> </a>
<a name="ln382">			end = &amp;(*end)-&gt;next;</a>
<a name="ln383">			constraint = constraint-&gt;next;</a>
<a name="ln384">		}</a>
<a name="ln385">	}</a>
<a name="ln386"> </a>
<a name="ln387">	// copy the other stuff</a>
<a name="ln388">	memcpy(layouter-&gt;fWeights, fWeights, fElementCount * sizeof(float));</a>
<a name="ln389">	memcpy(layouter-&gt;fSums, fSums, (fElementCount + 1) * sizeof(SumItem));</a>
<a name="ln390">	memcpy(layouter-&gt;fSumBackups, fSumBackups,</a>
<a name="ln391">		(fElementCount + 1) * sizeof(SumItemBackup));</a>
<a name="ln392">	layouter-&gt;fMin = fMin;</a>
<a name="ln393">	layouter-&gt;fMax = fMax;</a>
<a name="ln394">	layouter-&gt;fMinMaxValid = fMinMaxValid;</a>
<a name="ln395"> </a>
<a name="ln396">	return layouterDeleter.Detach();</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">// _Layout</a>
<a name="ln401">bool</a>
<a name="ln402">ComplexLayouter::_Layout(int32 size, SumItem* sums, int32* sizes)</a>
<a name="ln403">{</a>
<a name="ln404">	// prepare the desired solution</a>
<a name="ln405">	SimpleLayouter::DistributeSize(size, fWeights, sizes, fElementCount);</a>
<a name="ln406">	if (_SatisfiesConstraints(sizes)) {</a>
<a name="ln407">		// The desired solution already satisfies all constraints.</a>
<a name="ln408">		return true;</a>
<a name="ln409">	}</a>
<a name="ln410"> </a>
<a name="ln411">	double realSizes[fElementCount];</a>
<a name="ln412">	for (int32 i = 0; i &lt; fElementCount; i++)</a>
<a name="ln413">		realSizes[i] = sizes[i];</a>
<a name="ln414"> </a>
<a name="ln415">	if (!_AddOptimizerConstraints())</a>
<a name="ln416">		return false;</a>
<a name="ln417"> </a>
<a name="ln418"> </a>
<a name="ln419">	// prepare a feasible solution (the minimum)</a>
<a name="ln420">	double values[fElementCount];</a>
<a name="ln421">	for (int32 i = 0; i &lt; fElementCount; i++)</a>
<a name="ln422">		values[i] = sums[i + 1].min - sums[i].min;</a>
<a name="ln423"> </a>
<a name="ln424">#if TRACE_COMPLEX_LAYOUTER</a>
<a name="ln425">	TRACE(&quot;feasible solution vs. desired solution:\n&quot;);</a>
<a name="ln426">	for (int32 i = 0; i &lt; fElementCount; i++)</a>
<a name="ln427">		TRACE(&quot;%8.4f   %8.4f\n&quot;, values[i], realSizes[i]);</a>
<a name="ln428">#endif</a>
<a name="ln429"> </a>
<a name="ln430">	// solve</a>
<a name="ln431">	TRACE_ONLY(bigtime_t time = system_time();)</a>
<a name="ln432">	if (!fOptimizer-&gt;Solve(realSizes, size, values))</a>
<a name="ln433">		return false;</a>
<a name="ln434">	TRACE_ONLY(time = system_time() - time;)</a>
<a name="ln435"> </a>
<a name="ln436">	// compute integer solution</a>
<a name="ln437">	// The basic strategy is to floor() the sums. This guarantees that the</a>
<a name="ln438">	// difference between two rounded sums remains in the range of floor()</a>
<a name="ln439">	// and ceil() of their real value difference. Since the constraints have</a>
<a name="ln440">	// integer values, the integer solution will therefore satisfy all</a>
<a name="ln441">	// constraints the real solution satisfied.</a>
<a name="ln442">	TRACE(&quot;computed solution in %lld us:\n&quot;, time);</a>
<a name="ln443"> </a>
<a name="ln444">	double realSum = 0;</a>
<a name="ln445">	double previousSum = 0;</a>
<a name="ln446">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln447">		realSum += values[i];</a>
<a name="ln448">		double roundedRealSum = floor(realSum);</a>
<a name="ln449">		if (fuzzy_equals(realSum, roundedRealSum + 1))</a>
<a name="ln450">			realSum = roundedRealSum + 1;</a>
<a name="ln451">		sizes[i] = int32(roundedRealSum - previousSum);</a>
<a name="ln452">		previousSum = roundedRealSum;</a>
<a name="ln453"> </a>
<a name="ln454">		TRACE(&quot;x[%ld] = %8.4f   %4ld\n&quot;, i, values[i], sizes[i]);</a>
<a name="ln455">	}</a>
<a name="ln456"> </a>
<a name="ln457">	return _SatisfiesConstraints(sizes);</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460"> </a>
<a name="ln461">// _AddOptimizerConstraints</a>
<a name="ln462">bool</a>
<a name="ln463">ComplexLayouter::_AddOptimizerConstraints()</a>
<a name="ln464">{</a>
<a name="ln465">	if (fOptimizerConstraintsAdded)</a>
<a name="ln466">		return true;</a>
<a name="ln467"> </a>
<a name="ln468">	fOptimizer-&gt;RemoveAllConstraints();</a>
<a name="ln469"> </a>
<a name="ln470">	// add constraints</a>
<a name="ln471">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln472">		SumItem&amp; sum = fSums[i + 1];</a>
<a name="ln473"> </a>
<a name="ln474">		Constraint* constraint = fConstraints[i];</a>
<a name="ln475">		while (constraint != NULL) {</a>
<a name="ln476">			SumItem&amp; base = fSums[constraint-&gt;start];</a>
<a name="ln477">			int32 sumMin = base.min + constraint-&gt;min;</a>
<a name="ln478">			int32 baseMax = sum.max - constraint-&gt;min;</a>
<a name="ln479">			bool minRedundant = (sumMin &lt; sum.min &amp;&amp; baseMax &gt; base.max);</a>
<a name="ln480"> </a>
<a name="ln481">			int32 sumMax = base.max + constraint-&gt;effectiveMax;</a>
<a name="ln482">			int32 baseMin = sum.min - constraint-&gt;effectiveMax;</a>
<a name="ln483">			bool maxRedundant = (sumMax &gt; sum.max &amp;&amp; baseMin &lt; base.min);</a>
<a name="ln484"> </a>
<a name="ln485">			if (!minRedundant || !maxRedundant) {</a>
<a name="ln486">				bool success = true;</a>
<a name="ln487">				if (constraint-&gt;min == constraint-&gt;effectiveMax) {</a>
<a name="ln488">					// min and max equal -- add an equality constraint</a>
<a name="ln489">					success = fOptimizer-&gt;AddConstraint(constraint-&gt;start - 1,</a>
<a name="ln490">						constraint-&gt;end, constraint-&gt;min, true);</a>
<a name="ln491">				} else {</a>
<a name="ln492">					// min and max not equal -- add them individually,</a>
<a name="ln493">					// unless redundant</a>
<a name="ln494">					if (!minRedundant) {</a>
<a name="ln495">						success |= fOptimizer-&gt;AddConstraint(</a>
<a name="ln496">							constraint-&gt;start - 1, constraint-&gt;end,</a>
<a name="ln497">							constraint-&gt;min, false);</a>
<a name="ln498">					}</a>
<a name="ln499">					if (!maxRedundant) {</a>
<a name="ln500">						success |= fOptimizer-&gt;AddConstraint(constraint-&gt;end,</a>
<a name="ln501">							constraint-&gt;start - 1,</a>
<a name="ln502">							-constraint-&gt;effectiveMax, false);</a>
<a name="ln503">					}</a>
<a name="ln504">				}</a>
<a name="ln505"> </a>
<a name="ln506">				if (!success)</a>
<a name="ln507">					return false;</a>
<a name="ln508">			}</a>
<a name="ln509"> </a>
<a name="ln510">			constraint = constraint-&gt;next;</a>
<a name="ln511">		}</a>
<a name="ln512">	}</a>
<a name="ln513"> </a>
<a name="ln514">	fOptimizerConstraintsAdded = true;</a>
<a name="ln515">	return true;</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518"> </a>
<a name="ln519">// _SatisfiesConstraints</a>
<a name="ln520">bool</a>
<a name="ln521">ComplexLayouter::_SatisfiesConstraints(int32* sizes) const</a>
<a name="ln522">{</a>
<a name="ln523">	int32 sumValues[fElementCount + 1];</a>
<a name="ln524">	sumValues[0] = 0;</a>
<a name="ln525">	for (int32 i = 0; i &lt; fElementCount; i++)</a>
<a name="ln526">		sumValues[i + 1] = sumValues[i] + sizes[i];</a>
<a name="ln527"> </a>
<a name="ln528">	return _SatisfiesConstraintsSums(sumValues);</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531"> </a>
<a name="ln532">// _SatisfiesConstraintsSums</a>
<a name="ln533">bool</a>
<a name="ln534">ComplexLayouter::_SatisfiesConstraintsSums(int32* sumValues) const</a>
<a name="ln535">{</a>
<a name="ln536">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln537">		Constraint* constraint = fConstraints[i];</a>
<a name="ln538">		while (constraint) {</a>
<a name="ln539">			if (!constraint-&gt;IsSatisfied(sumValues))</a>
<a name="ln540">				return false;</a>
<a name="ln541"> </a>
<a name="ln542">			constraint = constraint-&gt;next;</a>
<a name="ln543">		}</a>
<a name="ln544">	}</a>
<a name="ln545"> </a>
<a name="ln546">	return true;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">// _ValidateLayout</a>
<a name="ln551">void</a>
<a name="ln552">ComplexLayouter::_ValidateLayout()</a>
<a name="ln553">{</a>
<a name="ln554">	// The general idea for computing the min and max for the given constraints</a>
<a name="ln555">	// is that we rewrite the problem a little. Instead of considering the</a>
<a name="ln556">	// x_1, ... x_n (n = fElementCount) and the constraints of the form</a>
<a name="ln557">	//   x_i + ... + x_{i+j} &gt;= min[i,j] and</a>
<a name="ln558">	//   x_i + ... + x_{i+j} &gt;= max[i,j], with i &gt;= 1, j &gt;= 0, i + j &lt;= n</a>
<a name="ln559">	//   and min[i,j], max[i,j] &gt;= 0</a>
<a name="ln560">	// we define</a>
<a name="ln561">	//   c[0] = 0</a>
<a name="ln562">	//   c[i] = \sum_{k=1}^i x_k, for all i, 1 &lt;= i &lt;= n</a>
<a name="ln563">	// and thus the constraints read:</a>
<a name="ln564">	//   c[i+j] - c[i-1] &gt;= min[i,j]</a>
<a name="ln565">	//   c[i+j] - c[i-1] &lt;= max[i,j]</a>
<a name="ln566">	//</a>
<a name="ln567">	// Let minc[i] and maxc[i] the limits imposed by the given constraints, i.e.</a>
<a name="ln568">	//   minc[i] &lt;= c[i] &lt;= maxc[i] for any tuple of (c[i])_i satisfying the</a>
<a name="ln569">	// constraints (minc[i] and maxc[i] are unique), then we gain:</a>
<a name="ln570">	//   minc[i+j] &gt;= c[i-1] + min[i,j]</a>
<a name="ln571">	//   maxc[i+j] &lt;= c[i-1] + min[i,j]</a>
<a name="ln572">	//   minc[i-1] &gt;= minc[i+j] - max[i,j]</a>
<a name="ln573">	//   maxc[i-1] &gt;= maxc[i+j] - min[i,j]</a>
<a name="ln574">	// We can compute the minc[i] and maxc[i] in an iterative process,</a>
<a name="ln575">	// propagating the first to kinds of constraints forward and the other two</a>
<a name="ln576">	// backwards. First we start considering all min constraints only. They</a>
<a name="ln577">	// can't contradict each other and are usually to be enforced over max</a>
<a name="ln578">	// constraints. Afterwards we add the max constraints one by one. For each</a>
<a name="ln579">	// one of them we propagate resulting changes back and forth. In case of</a>
<a name="ln580">	// a conflict, we relax the max constraint as much as necessary to yield</a>
<a name="ln581">	// a consistent set of constraints. After all constraints have been</a>
<a name="ln582">	// incorporated, the resulting minc[n] and maxc[n] are the min and max</a>
<a name="ln583">	// limits we wanted to compute.</a>
<a name="ln584"> </a>
<a name="ln585">	if (fMinMaxValid)</a>
<a name="ln586">		return;</a>
<a name="ln587"> </a>
<a name="ln588">	fSums[0].min = 0;</a>
<a name="ln589">	fSums[0].max = 0;</a>
<a name="ln590"> </a>
<a name="ln591">	int32 maxSum = 0;</a>
<a name="ln592">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln593">		SumItem&amp; sum = fSums[i + 1];</a>
<a name="ln594">		sum.min = 0;</a>
<a name="ln595">		sum.max = maxSum += fUnlimited;</a>
<a name="ln596">		sum.minDirty = false;</a>
<a name="ln597">		sum.maxDirty = false;</a>
<a name="ln598">	}</a>
<a name="ln599"> </a>
<a name="ln600">	// apply min constraints forward:</a>
<a name="ln601">	//   minc[i+j] &gt;= minc[i-1] + min[i,j]</a>
<a name="ln602">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln603">		SumItem&amp; sum = fSums[i + 1];</a>
<a name="ln604"> </a>
<a name="ln605">		Constraint* constraint = fConstraints[i];</a>
<a name="ln606">		while (constraint != NULL) {</a>
<a name="ln607">			int32 minSum = fSums[constraint-&gt;start].min + constraint-&gt;min;</a>
<a name="ln608">			if (minSum &gt; sum.min) {</a>
<a name="ln609">				sum.min = minSum;</a>
<a name="ln610">			} else {</a>
<a name="ln611">				TRACE(&quot;min constraint is redundant: x%ld + ... + x%ld &gt;= %ld\n&quot;,</a>
<a name="ln612">					constraint-&gt;start, constraint-&gt;end, constraint-&gt;min);</a>
<a name="ln613">			}</a>
<a name="ln614"> </a>
<a name="ln615">			constraint = constraint-&gt;next;</a>
<a name="ln616">		}</a>
<a name="ln617">	}</a>
<a name="ln618"> </a>
<a name="ln619">	// apply min constraints backwards:</a>
<a name="ln620">	//   maxc[i-1] &lt;= maxc[i+j] - min[i,j]</a>
<a name="ln621">	for (int32 i = fElementCount - 1; i &gt;= 0; i--) {</a>
<a name="ln622">		SumItem&amp; sum = fSums[i + 1];</a>
<a name="ln623"> </a>
<a name="ln624">		Constraint* constraint = fConstraints[i];</a>
<a name="ln625">		while (constraint != NULL) {</a>
<a name="ln626">			SumItem&amp; base = fSums[constraint-&gt;start];</a>
<a name="ln627">			int32 baseMax = sum.max - constraint-&gt;min;</a>
<a name="ln628">			if (baseMax &lt; base.max)</a>
<a name="ln629">				base.max = baseMax;</a>
<a name="ln630"> </a>
<a name="ln631">			constraint = constraint-&gt;next;</a>
<a name="ln632">		}</a>
<a name="ln633">	}</a>
<a name="ln634"> </a>
<a name="ln635">	// apply max constraints</a>
<a name="ln636">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln637">		Constraint* constraint = fConstraints[i];</a>
<a name="ln638">		while (constraint != NULL) {</a>
<a name="ln639">			_ApplyMaxConstraint(constraint, i);</a>
<a name="ln640"> </a>
<a name="ln641">			constraint = constraint-&gt;next;</a>
<a name="ln642">		}</a>
<a name="ln643">	}</a>
<a name="ln644"> </a>
<a name="ln645">#if TRACE_COMPLEX_LAYOUTER</a>
<a name="ln646">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln647">		SumItem&amp; sum = fSums[i + 1];</a>
<a name="ln648">		TRACE(&quot;[%ld] minc = %4ld,  maxc = %4ld\n&quot;, i + 1, sum.min, sum.max);</a>
<a name="ln649">	}</a>
<a name="ln650">#endif</a>
<a name="ln651"> </a>
<a name="ln652">	if (fElementCount == 0) {</a>
<a name="ln653">		fMin = -1;</a>
<a name="ln654">		fMax = B_SIZE_UNLIMITED;</a>
<a name="ln655">	} else {</a>
<a name="ln656">		int32 spacing = (fElementCount - 1) * fSpacing;</a>
<a name="ln657">		fMin = fSums[fElementCount].min + spacing - 1;</a>
<a name="ln658">		fMax = fSums[fElementCount].max + spacing - 1;</a>
<a name="ln659">		if (fMax &gt;= fUnlimited)</a>
<a name="ln660">			fMax = B_SIZE_UNLIMITED;</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	fOptimizerConstraintsAdded = false;</a>
<a name="ln664">	fMinMaxValid = true;</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667"> </a>
<a name="ln668">// _ApplyMaxConstraint</a>
<a name="ln669">void</a>
<a name="ln670">ComplexLayouter::_ApplyMaxConstraint(Constraint* currentConstraint, int32 index)</a>
<a name="ln671">{</a>
<a name="ln672">	SumItem&amp; sum = fSums[index + 1];</a>
<a name="ln673">	SumItem&amp; base = fSums[currentConstraint-&gt;start];</a>
<a name="ln674"> </a>
<a name="ln675">	// We want to apply:</a>
<a name="ln676">	//   c[i+j] &lt;= c[i-1] + max[i,j]</a>
<a name="ln677">	//</a>
<a name="ln678">	// This has the following direct consequences (let k = i + j):</a>
<a name="ln679">	// (1) maxc[k] &lt;= maxc[i-1] + max[i,j]</a>
<a name="ln680">	// (2) minc[i-1] &gt;= minc[k] - max[i,j]</a>
<a name="ln681">	//</a>
<a name="ln682">	// If maxc[k] or minc[i-i] changed, those changes have to be propagated</a>
<a name="ln683">	// back.</a>
<a name="ln684"> </a>
<a name="ln685">	// apply (1) maxc[k] &lt;= maxc[i-1] + max[i,j]</a>
<a name="ln686">	int32 max = currentConstraint-&gt;effectiveMax;</a>
<a name="ln687">	int32 sumMax = base.max + max;</a>
<a name="ln688"> </a>
<a name="ln689">	// enforce maxc[i+j] &gt;= minc[i+j]</a>
<a name="ln690">	if (sumMax &lt; sum.min) {</a>
<a name="ln691">		sumMax = sum.min;</a>
<a name="ln692">		max = sumMax - base.max;</a>
<a name="ln693">	}</a>
<a name="ln694"> </a>
<a name="ln695">	// apply (2) minc[i-1] &gt;= minc[k] - max[i,j]</a>
<a name="ln696">	// and check minc[i-1] &lt;= maxc[i-1]</a>
<a name="ln697">	int32 baseMin = sum.min - max;</a>
<a name="ln698">	if (baseMin &gt; base.max) {</a>
<a name="ln699">		baseMin = base.max;</a>
<a name="ln700">		max = sum.min - baseMin;</a>
<a name="ln701">		sumMax = base.max + max;</a>
<a name="ln702">	}</a>
<a name="ln703"> </a>
<a name="ln704">	if (currentConstraint-&gt;effectiveMax != max) {</a>
<a name="ln705">		TRACE(&quot;relaxing conflicting max constraint (1): &quot;</a>
<a name="ln706">			&quot;x%ld + ... + x%ld &lt;= %ld -&gt; %ld\n&quot;, currentConstraint-&gt;start,</a>
<a name="ln707">			currentConstraint-&gt;end, currentConstraint-&gt;effectiveMax, max);</a>
<a name="ln708">	}</a>
<a name="ln709">	currentConstraint-&gt;effectiveMax = max;</a>
<a name="ln710"> </a>
<a name="ln711">	if (baseMin &lt;= base.min &amp;&amp; sumMax &gt;= sum.max) {</a>
<a name="ln712">		TRACE(&quot;max constraint is redundant: x%ld + ... + x%ld &lt;= %ld\n&quot;,</a>
<a name="ln713">			currentConstraint-&gt;start, currentConstraint-&gt;end,</a>
<a name="ln714">			currentConstraint-&gt;effectiveMax);</a>
<a name="ln715">		return;</a>
<a name="ln716">	}</a>
<a name="ln717"> </a>
<a name="ln718">	// backup old values, in case we detect a conflict later</a>
<a name="ln719">	_BackupValues(index);</a>
<a name="ln720"> </a>
<a name="ln721">	int32 diff;</a>
<a name="ln722">	do {</a>
<a name="ln723">		// apply the changes</a>
<a name="ln724">		int32 changedIndex = currentConstraint-&gt;start;</a>
<a name="ln725"> </a>
<a name="ln726">		if (baseMin &gt; base.min) {</a>
<a name="ln727">			base.min = baseMin;</a>
<a name="ln728">			base.minDirty = true;</a>
<a name="ln729">		}</a>
<a name="ln730"> </a>
<a name="ln731">		if (sumMax &lt; sum.max) {</a>
<a name="ln732">			changedIndex = index;</a>
<a name="ln733">			sum.max = sumMax;</a>
<a name="ln734">			sum.maxDirty = true;</a>
<a name="ln735">		}</a>
<a name="ln736"> </a>
<a name="ln737">		// propagate the changes</a>
<a name="ln738">		_PropagateChangesBack(fSums, changedIndex, currentConstraint);</a>
<a name="ln739">		_PropagateChanges(fSums, index, currentConstraint);</a>
<a name="ln740"> </a>
<a name="ln741">		// check the new constraint again -- if it doesn't hold, it</a>
<a name="ln742">		// conflicts with the other constraints</a>
<a name="ln743">		diff = 0;</a>
<a name="ln744"> </a>
<a name="ln745">		// check (1) maxc[k] &lt;= maxc[i-1] + max[i,j]</a>
<a name="ln746">		max = currentConstraint-&gt;effectiveMax;</a>
<a name="ln747">		sumMax = base.max + max;</a>
<a name="ln748">		if (sumMax &lt; sum.max)</a>
<a name="ln749">			diff = sum.max - sumMax;</a>
<a name="ln750"> </a>
<a name="ln751">		// check (2) minc[i-1] &gt;= minc[k] - max[i,j]</a>
<a name="ln752">		baseMin = sum.min - max;</a>
<a name="ln753">		if (baseMin &gt; base.min)</a>
<a name="ln754">			diff = max_c(diff, baseMin - base.min);</a>
<a name="ln755"> </a>
<a name="ln756">		// clear the dirty flags</a>
<a name="ln757">		for (int32 i = 0; i &lt;= changedIndex; i++) {</a>
<a name="ln758">			SumItem&amp; sum = fSums[i + 1];</a>
<a name="ln759">			sum.minDirty = false;</a>
<a name="ln760">			sum.maxDirty = false;</a>
<a name="ln761">		}</a>
<a name="ln762"> </a>
<a name="ln763">		// if we've got a conflict, we relax the constraint and try again</a>
<a name="ln764">		if (diff &gt; 0) {</a>
<a name="ln765">			max += diff;</a>
<a name="ln766">			TRACE(&quot;relaxing conflicting max constraint (2): &quot;</a>
<a name="ln767">				&quot;x%ld + ... + x%ld &lt;= %ld -&gt; %ld\n&quot;, currentConstraint-&gt;start,</a>
<a name="ln768">				currentConstraint-&gt;end, currentConstraint-&gt;effectiveMax, max);</a>
<a name="ln769">			currentConstraint-&gt;effectiveMax = max;</a>
<a name="ln770"> </a>
<a name="ln771">			_RestoreValues(index);</a>
<a name="ln772"> </a>
<a name="ln773">			sumMax = base.max + max;</a>
<a name="ln774">			baseMin = sum.min - max;</a>
<a name="ln775"> </a>
<a name="ln776">			if (baseMin &lt;= base.min &amp;&amp; sumMax &gt;= sum.max)</a>
<a name="ln777">				return;</a>
<a name="ln778">		}</a>
<a name="ln779">	} while (diff &gt; 0);</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782"> </a>
<a name="ln783">// _PropagateChanges</a>
<a name="ln784">/*!	Propagate changes forward using min and max constraints. Max constraints</a>
<a name="ln785">	Beyond \a toIndex or at \a to toIndex after (and including)</a>
<a name="ln786">	\a lastMaxConstraint will be ignored. To have all constraints be</a>
<a name="ln787">	considered pass \c fElementCount and \c NULL.</a>
<a name="ln788">*/</a>
<a name="ln789">void</a>
<a name="ln790">ComplexLayouter::_PropagateChanges(SumItem* sums, int32 toIndex,</a>
<a name="ln791">	Constraint* lastMaxConstraint)</a>
<a name="ln792">{</a>
<a name="ln793">	for (int32 i = 0; i &lt; fElementCount; i++) {</a>
<a name="ln794">		SumItem&amp; sum = sums[i + 1];</a>
<a name="ln795"> </a>
<a name="ln796">		bool ignoreMaxConstraints = (i &gt; toIndex);</a>
<a name="ln797"> </a>
<a name="ln798">		Constraint* constraint = fConstraints[i];</a>
<a name="ln799">		while (constraint != NULL) {</a>
<a name="ln800">			SumItem&amp; base = sums[constraint-&gt;start];</a>
<a name="ln801"> </a>
<a name="ln802">			if (constraint == lastMaxConstraint)</a>
<a name="ln803">				ignoreMaxConstraints = true;</a>
<a name="ln804"> </a>
<a name="ln805">			// minc[k] &gt;= minc[i-1] + min[i,j]</a>
<a name="ln806">			if (base.minDirty) {</a>
<a name="ln807">				int32 sumMin = base.min + constraint-&gt;min;</a>
<a name="ln808">				if (sumMin &gt; sum.min) {</a>
<a name="ln809">					sum.min = sumMin;</a>
<a name="ln810">					sum.minDirty = true;</a>
<a name="ln811">				}</a>
<a name="ln812">			}</a>
<a name="ln813"> </a>
<a name="ln814">			// maxc[k] &lt;= maxc[i-1] + max[i,j]</a>
<a name="ln815">			if (base.maxDirty &amp;&amp; !ignoreMaxConstraints) {</a>
<a name="ln816">				int32 sumMax = base.max + constraint-&gt;effectiveMax;</a>
<a name="ln817">				if (sumMax &lt; sum.max) {</a>
<a name="ln818">					sum.max = sumMax;</a>
<a name="ln819">					sum.maxDirty = true;</a>
<a name="ln820">				}</a>
<a name="ln821">			}</a>
<a name="ln822"> </a>
<a name="ln823">			constraint = constraint-&gt;next;</a>
<a name="ln824">		}</a>
<a name="ln825"> </a>
<a name="ln826">		if (sum.minDirty || sum.maxDirty) {</a>
<a name="ln827">			if (sum.min &gt; sum.max) {</a>
<a name="ln828">				// TODO: Can this actually happen?</a>
<a name="ln829">				TRACE(&quot;adjusted max in propagation phase: index: &quot;</a>
<a name="ln830">					&quot;%ld: %ld -&gt; %ld\n&quot;, i, sum.max, sum.min);</a>
<a name="ln831">				sum.max = sum.min;</a>
<a name="ln832">				sum.maxDirty = true;</a>
<a name="ln833">			}</a>
<a name="ln834">		}</a>
<a name="ln835">	}</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">// _PropagateChangesBack</a>
<a name="ln840">void</a>
<a name="ln841">ComplexLayouter::_PropagateChangesBack(SumItem* sums, int32 changedIndex,</a>
<a name="ln842">	Constraint* lastMaxConstraint)</a>
<a name="ln843">{</a>
<a name="ln844">	for (int32 i = changedIndex; i &gt;= 0; i--) {</a>
<a name="ln845">		SumItem&amp; sum = sums[i + 1];</a>
<a name="ln846"> </a>
<a name="ln847">		bool ignoreMaxConstraints = false;</a>
<a name="ln848"> </a>
<a name="ln849">		Constraint* constraint = fConstraints[i];</a>
<a name="ln850">		while (constraint != NULL) {</a>
<a name="ln851">			SumItem&amp; base = sums[constraint-&gt;start];</a>
<a name="ln852"> </a>
<a name="ln853">			if (constraint == lastMaxConstraint)</a>
<a name="ln854">				ignoreMaxConstraints = true;</a>
<a name="ln855"> </a>
<a name="ln856">			// minc[i-1] &gt;= minc[k] - max[i,j]</a>
<a name="ln857">			if (sum.minDirty &amp;&amp; !ignoreMaxConstraints) {</a>
<a name="ln858">				int32 baseMin = sum.min - constraint-&gt;effectiveMax;</a>
<a name="ln859">				if (baseMin &gt; base.min) {</a>
<a name="ln860">					if (baseMin &gt; base.max) {</a>
<a name="ln861">						TRACE(&quot;min above max in back propagation phase: index: &quot;</a>
<a name="ln862">							&quot;(%ld -&gt; %ld), min: %ld, max: %ld\n&quot;, i,</a>
<a name="ln863">							constraint-&gt;start, baseMin, base.max);</a>
<a name="ln864">					}</a>
<a name="ln865">					base.min = baseMin;</a>
<a name="ln866">					base.minDirty = true;</a>
<a name="ln867">				}</a>
<a name="ln868">			}</a>
<a name="ln869"> </a>
<a name="ln870">			// maxc[i-1] &lt;= maxc[k] - min[i,j]</a>
<a name="ln871">			if (sum.maxDirty) {</a>
<a name="ln872">				int32 baseMax = sum.max - constraint-&gt;min;</a>
<a name="ln873">				if (baseMax &lt; base.max) {</a>
<a name="ln874">					if (baseMax &lt; base.min) {</a>
<a name="ln875">						TRACE(&quot;max below min in back propagation phase: index: &quot;</a>
<a name="ln876">							&quot;(%ld -&gt; %ld), max: %ld, min: %ld\n&quot;, i,</a>
<a name="ln877">							constraint-&gt;start, baseMax, base.min);</a>
<a name="ln878">					}</a>
<a name="ln879">					base.max = baseMax;</a>
<a name="ln880">					base.maxDirty = true;</a>
<a name="ln881">				}</a>
<a name="ln882">			}</a>
<a name="ln883"> </a>
<a name="ln884">			constraint = constraint-&gt;next;</a>
<a name="ln885">		}</a>
<a name="ln886">	}</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889"> </a>
<a name="ln890">// _BackupValues</a>
<a name="ln891">void</a>
<a name="ln892">ComplexLayouter::_BackupValues(int32 maxIndex)</a>
<a name="ln893">{</a>
<a name="ln894">	for (int32 i = 0; i &lt;= maxIndex; i++) {</a>
<a name="ln895">		SumItem&amp; sum = fSums[i + 1];</a>
<a name="ln896">		fSumBackups[i + 1].min = sum.min;</a>
<a name="ln897">		fSumBackups[i + 1].max = sum.max;</a>
<a name="ln898">	}</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901"> </a>
<a name="ln902">// _RestoreValues</a>
<a name="ln903">void</a>
<a name="ln904">ComplexLayouter::_RestoreValues(int32 maxIndex)</a>
<a name="ln905">{</a>
<a name="ln906">	for (int32 i = 0; i &lt;= maxIndex; i++) {</a>
<a name="ln907">		SumItem&amp; sum = fSums[i + 1];</a>
<a name="ln908">		sum.min = fSumBackups[i + 1].min;</a>
<a name="ln909">		sum.max = fSumBackups[i + 1].max;</a>
<a name="ln910">	}</a>
<a name="ln911">}</a>
<a name="ln912"> </a>

</code></pre>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fMin, fMax.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
