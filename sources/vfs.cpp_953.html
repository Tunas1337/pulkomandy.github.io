
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>vfs.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2005-2013, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2002-2018, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Copyright 2001-2002, Travis Geiselbrecht. All rights reserved.</a>
<a name="ln7"> * Distributed under the terms of the NewOS License.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">/*! Virtual File System and File System Interface Layer */</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;ctype.h&gt;</a>
<a name="ln15">#include &lt;fcntl.h&gt;</a>
<a name="ln16">#include &lt;limits.h&gt;</a>
<a name="ln17">#include &lt;stddef.h&gt;</a>
<a name="ln18">#include &lt;stdio.h&gt;</a>
<a name="ln19">#include &lt;string.h&gt;</a>
<a name="ln20">#include &lt;sys/file.h&gt;</a>
<a name="ln21">#include &lt;sys/resource.h&gt;</a>
<a name="ln22">#include &lt;sys/stat.h&gt;</a>
<a name="ln23">#include &lt;unistd.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;fs_attr.h&gt;</a>
<a name="ln26">#include &lt;fs_info.h&gt;</a>
<a name="ln27">#include &lt;fs_interface.h&gt;</a>
<a name="ln28">#include &lt;fs_volume.h&gt;</a>
<a name="ln29">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln30">#include &lt;OS.h&gt;</a>
<a name="ln31">#include &lt;StorageDefs.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln34">#include &lt;block_cache.h&gt;</a>
<a name="ln35">#include &lt;boot/kernel_args.h&gt;</a>
<a name="ln36">#include &lt;debug_heap.h&gt;</a>
<a name="ln37">#include &lt;disk_device_manager/KDiskDevice.h&gt;</a>
<a name="ln38">#include &lt;disk_device_manager/KDiskDeviceManager.h&gt;</a>
<a name="ln39">#include &lt;disk_device_manager/KDiskDeviceUtils.h&gt;</a>
<a name="ln40">#include &lt;disk_device_manager/KDiskSystem.h&gt;</a>
<a name="ln41">#include &lt;fd.h&gt;</a>
<a name="ln42">#include &lt;file_cache.h&gt;</a>
<a name="ln43">#include &lt;fs/node_monitor.h&gt;</a>
<a name="ln44">#include &lt;KPath.h&gt;</a>
<a name="ln45">#include &lt;lock.h&gt;</a>
<a name="ln46">#include &lt;low_resource_manager.h&gt;</a>
<a name="ln47">#include &lt;syscalls.h&gt;</a>
<a name="ln48">#include &lt;syscall_restart.h&gt;</a>
<a name="ln49">#include &lt;tracing.h&gt;</a>
<a name="ln50">#include &lt;util/atomic.h&gt;</a>
<a name="ln51">#include &lt;util/AutoLock.h&gt;</a>
<a name="ln52">#include &lt;util/DoublyLinkedList.h&gt;</a>
<a name="ln53">#include &lt;vfs.h&gt;</a>
<a name="ln54">#include &lt;vm/vm.h&gt;</a>
<a name="ln55">#include &lt;vm/VMCache.h&gt;</a>
<a name="ln56">#include &lt;wait_for_objects.h&gt;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;EntryCache.h&quot;</a>
<a name="ln59">#include &quot;fifo.h&quot;</a>
<a name="ln60">#include &quot;IORequest.h&quot;</a>
<a name="ln61">#include &quot;unused_vnodes.h&quot;</a>
<a name="ln62">#include &quot;vfs_tracing.h&quot;</a>
<a name="ln63">#include &quot;Vnode.h&quot;</a>
<a name="ln64">#include &quot;../cache/vnode_store.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">//#define TRACE_VFS</a>
<a name="ln68">#ifdef TRACE_VFS</a>
<a name="ln69">#	define TRACE(x) dprintf x</a>
<a name="ln70">#	define FUNCTION(x) dprintf x</a>
<a name="ln71">#else</a>
<a name="ln72">#	define TRACE(x) ;</a>
<a name="ln73">#	define FUNCTION(x) ;</a>
<a name="ln74">#endif</a>
<a name="ln75"> </a>
<a name="ln76">#define ADD_DEBUGGER_COMMANDS</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">#define HAS_FS_CALL(vnode, op)			(vnode-&gt;ops-&gt;op != NULL)</a>
<a name="ln80">#define HAS_FS_MOUNT_CALL(mount, op)	(mount-&gt;volume-&gt;ops-&gt;op != NULL)</a>
<a name="ln81"> </a>
<a name="ln82">#if KDEBUG</a>
<a name="ln83">#	define FS_CALL(vnode, op, params...) \</a>
<a name="ln84">		( HAS_FS_CALL(vnode, op) ? \</a>
<a name="ln85">			vnode-&gt;ops-&gt;op(vnode-&gt;mount-&gt;volume, vnode, params) \</a>
<a name="ln86">			: (panic(&quot;FS_CALL op &quot; #op &quot; is NULL&quot;), 0))</a>
<a name="ln87">#	define FS_CALL_NO_PARAMS(vnode, op) \</a>
<a name="ln88">		( HAS_FS_CALL(vnode, op) ? \</a>
<a name="ln89">			vnode-&gt;ops-&gt;op(vnode-&gt;mount-&gt;volume, vnode) \</a>
<a name="ln90">			: (panic(&quot;FS_CALL_NO_PARAMS op &quot; #op &quot; is NULL&quot;), 0))</a>
<a name="ln91">#	define FS_MOUNT_CALL(mount, op, params...) \</a>
<a name="ln92">		( HAS_FS_MOUNT_CALL(mount, op) ? \</a>
<a name="ln93">			mount-&gt;volume-&gt;ops-&gt;op(mount-&gt;volume, params) \</a>
<a name="ln94">			: (panic(&quot;FS_MOUNT_CALL op &quot; #op &quot; is NULL&quot;), 0))</a>
<a name="ln95">#	define FS_MOUNT_CALL_NO_PARAMS(mount, op) \</a>
<a name="ln96">		( HAS_FS_MOUNT_CALL(mount, op) ? \</a>
<a name="ln97">			mount-&gt;volume-&gt;ops-&gt;op(mount-&gt;volume) \</a>
<a name="ln98">			: (panic(&quot;FS_MOUNT_CALL_NO_PARAMS op &quot; #op &quot; is NULL&quot;), 0))</a>
<a name="ln99">#else</a>
<a name="ln100">#	define FS_CALL(vnode, op, params...) \</a>
<a name="ln101">			vnode-&gt;ops-&gt;op(vnode-&gt;mount-&gt;volume, vnode, params)</a>
<a name="ln102">#	define FS_CALL_NO_PARAMS(vnode, op) \</a>
<a name="ln103">			vnode-&gt;ops-&gt;op(vnode-&gt;mount-&gt;volume, vnode)</a>
<a name="ln104">#	define FS_MOUNT_CALL(mount, op, params...) \</a>
<a name="ln105">			mount-&gt;volume-&gt;ops-&gt;op(mount-&gt;volume, params)</a>
<a name="ln106">#	define FS_MOUNT_CALL_NO_PARAMS(mount, op) \</a>
<a name="ln107">			mount-&gt;volume-&gt;ops-&gt;op(mount-&gt;volume)</a>
<a name="ln108">#endif</a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">const static size_t kMaxPathLength = 65536;</a>
<a name="ln112">	// The absolute maximum path length (for getcwd() - this is not depending</a>
<a name="ln113">	// on PATH_MAX</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116">typedef DoublyLinkedList&lt;vnode&gt; VnodeList;</a>
<a name="ln117"> </a>
<a name="ln118">/*!	\brief Structure to manage a mounted file system</a>
<a name="ln119"> </a>
<a name="ln120">	Note: The root_vnode and root_vnode-&gt;covers fields (what others?) are</a>
<a name="ln121">	initialized in fs_mount() and not changed afterwards. That is as soon</a>
<a name="ln122">	as the mount is mounted and it is made sure it won't be unmounted</a>
<a name="ln123">	(e.g. by holding a reference to a vnode of that mount) (read) access</a>
<a name="ln124">	to those fields is always safe, even without additional locking. Morever</a>
<a name="ln125">	while mounted the mount holds a reference to the root_vnode-&gt;covers vnode,</a>
<a name="ln126">	and thus making the access path vnode-&gt;mount-&gt;root_vnode-&gt;covers-&gt;mount-&gt;...</a>
<a name="ln127">	safe if a reference to vnode is held (note that for the root mount</a>
<a name="ln128">	root_vnode-&gt;covers is NULL, though).</a>
<a name="ln129">*/</a>
<a name="ln130">struct fs_mount {</a>
<a name="ln131">	fs_mount()</a>
<a name="ln132">		:</a>
<a name="ln133">		volume(NULL),</a>
<a name="ln134">		device_name(NULL)</a>
<a name="ln135">	{</a>
<a name="ln136">		mutex_init(&amp;lock, &quot;mount lock&quot;);</a>
<a name="ln137">	}</a>
<a name="ln138"> </a>
<a name="ln139">	~fs_mount()</a>
<a name="ln140">	{</a>
<a name="ln141">		mutex_destroy(&amp;lock);</a>
<a name="ln142">		free(device_name);</a>
<a name="ln143"> </a>
<a name="ln144">		while (volume) {</a>
<a name="ln145">			fs_volume* superVolume = volume-&gt;super_volume;</a>
<a name="ln146"> </a>
<a name="ln147">			if (volume-&gt;file_system != NULL)</a>
<a name="ln148">				put_module(volume-&gt;file_system-&gt;info.name);</a>
<a name="ln149"> </a>
<a name="ln150">			free(volume-&gt;file_system_name);</a>
<a name="ln151">			free(volume);</a>
<a name="ln152">			volume = superVolume;</a>
<a name="ln153">		}</a>
<a name="ln154">	}</a>
<a name="ln155"> </a>
<a name="ln156">	struct fs_mount* next;</a>
<a name="ln157">	dev_t			id;</a>
<a name="ln158">	fs_volume*		volume;</a>
<a name="ln159">	char*			device_name;</a>
<a name="ln160">	mutex			lock;	// guards the vnodes list</a>
<a name="ln161">	struct vnode*	root_vnode;</a>
<a name="ln162">	struct vnode*	covers_vnode;	// immutable</a>
<a name="ln163">	KPartition*		partition;</a>
<a name="ln164">	VnodeList		vnodes;</a>
<a name="ln165">	EntryCache		entry_cache;</a>
<a name="ln166">	bool			unmounting;</a>
<a name="ln167">	bool			owns_file_device;</a>
<a name="ln168">};</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">namespace {</a>
<a name="ln172"> </a>
<a name="ln173">struct advisory_lock : public DoublyLinkedListLinkImpl&lt;advisory_lock&gt; {</a>
<a name="ln174">	list_link		link;</a>
<a name="ln175">	void*			bound_to;</a>
<a name="ln176">	team_id			team;</a>
<a name="ln177">	pid_t			session;</a>
<a name="ln178">	off_t			start;</a>
<a name="ln179">	off_t			end;</a>
<a name="ln180">	bool			shared;</a>
<a name="ln181">};</a>
<a name="ln182"> </a>
<a name="ln183">typedef DoublyLinkedList&lt;advisory_lock&gt; LockList;</a>
<a name="ln184"> </a>
<a name="ln185">} // namespace</a>
<a name="ln186"> </a>
<a name="ln187"> </a>
<a name="ln188">struct advisory_locking {</a>
<a name="ln189">	sem_id			lock;</a>
<a name="ln190">	sem_id			wait_sem;</a>
<a name="ln191">	LockList		locks;</a>
<a name="ln192"> </a>
<a name="ln193">	advisory_locking()</a>
<a name="ln194">		:</a>
<a name="ln195">		lock(-1),</a>
<a name="ln196">		wait_sem(-1)</a>
<a name="ln197">	{</a>
<a name="ln198">	}</a>
<a name="ln199"> </a>
<a name="ln200">	~advisory_locking()</a>
<a name="ln201">	{</a>
<a name="ln202">		if (lock &gt;= 0)</a>
<a name="ln203">			delete_sem(lock);</a>
<a name="ln204">		if (wait_sem &gt;= 0)</a>
<a name="ln205">			delete_sem(wait_sem);</a>
<a name="ln206">	}</a>
<a name="ln207">};</a>
<a name="ln208"> </a>
<a name="ln209">/*!	\brief Guards sMountsTable.</a>
<a name="ln210"> </a>
<a name="ln211">	The holder is allowed to read/write access the sMountsTable.</a>
<a name="ln212">	Manipulation of the fs_mount structures themselves</a>
<a name="ln213">	(and their destruction) requires different locks though.</a>
<a name="ln214">*/</a>
<a name="ln215">static mutex sMountMutex = MUTEX_INITIALIZER(&quot;vfs_mount_lock&quot;);</a>
<a name="ln216"> </a>
<a name="ln217">/*!	\brief Guards mount/unmount operations.</a>
<a name="ln218"> </a>
<a name="ln219">	The fs_mount() and fs_unmount() hold the lock during their whole operation.</a>
<a name="ln220">	That is locking the lock ensures that no FS is mounted/unmounted. In</a>
<a name="ln221">	particular this means that</a>
<a name="ln222">	- sMountsTable will not be modified,</a>
<a name="ln223">	- the fields immutable after initialization of the fs_mount structures in</a>
<a name="ln224">	  sMountsTable will not be modified,</a>
<a name="ln225"> </a>
<a name="ln226">	The thread trying to lock the lock must not hold sVnodeLock or</a>
<a name="ln227">	sMountMutex.</a>
<a name="ln228">*/</a>
<a name="ln229">static recursive_lock sMountOpLock;</a>
<a name="ln230"> </a>
<a name="ln231">/*!	\brief Guards sVnodeTable.</a>
<a name="ln232"> </a>
<a name="ln233">	The holder is allowed read/write access to sVnodeTable and to</a>
<a name="ln234">	any unbusy vnode in that table, save to the immutable fields (device, id,</a>
<a name="ln235">	private_node, mount) to which only read-only access is allowed.</a>
<a name="ln236">	The mutable fields advisory_locking, mandatory_locked_by, and ref_count, as</a>
<a name="ln237">	well as the busy, removed, unused flags, and the vnode's type can also be</a>
<a name="ln238">	write accessed when holding a read lock to sVnodeLock *and* having the vnode</a>
<a name="ln239">	locked. Write access to covered_by and covers requires to write lock</a>
<a name="ln240">	sVnodeLock.</a>
<a name="ln241"> </a>
<a name="ln242">	The thread trying to acquire the lock must not hold sMountMutex.</a>
<a name="ln243">	You must not hold this lock when calling create_sem(), as this might call</a>
<a name="ln244">	vfs_free_unused_vnodes() and thus cause a deadlock.</a>
<a name="ln245">*/</a>
<a name="ln246">static rw_lock sVnodeLock = RW_LOCK_INITIALIZER(&quot;vfs_vnode_lock&quot;);</a>
<a name="ln247"> </a>
<a name="ln248">/*!	\brief Guards io_context::root.</a>
<a name="ln249"> </a>
<a name="ln250">	Must be held when setting or getting the io_context::root field.</a>
<a name="ln251">	The only operation allowed while holding this lock besides getting or</a>
<a name="ln252">	setting the field is inc_vnode_ref_count() on io_context::root.</a>
<a name="ln253">*/</a>
<a name="ln254">static mutex sIOContextRootLock = MUTEX_INITIALIZER(&quot;io_context::root lock&quot;);</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">namespace {</a>
<a name="ln258"> </a>
<a name="ln259">struct vnode_hash_key {</a>
<a name="ln260">	dev_t	device;</a>
<a name="ln261">	ino_t	vnode;</a>
<a name="ln262">};</a>
<a name="ln263"> </a>
<a name="ln264">struct VnodeHash {</a>
<a name="ln265">	typedef vnode_hash_key	KeyType;</a>
<a name="ln266">	typedef	struct vnode	ValueType;</a>
<a name="ln267"> </a>
<a name="ln268">#define VHASH(mountid, vnodeid) \</a>
<a name="ln269">	(((uint32)((vnodeid) &gt;&gt; 32) + (uint32)(vnodeid)) ^ (uint32)(mountid))</a>
<a name="ln270"> </a>
<a name="ln271">	size_t HashKey(KeyType key) const</a>
<a name="ln272">	{</a>
<a name="ln273">		return VHASH(key.device, key.vnode);</a>
<a name="ln274">	}</a>
<a name="ln275"> </a>
<a name="ln276">	size_t Hash(ValueType* vnode) const</a>
<a name="ln277">	{</a>
<a name="ln278">		return VHASH(vnode-&gt;device, vnode-&gt;id);</a>
<a name="ln279">	}</a>
<a name="ln280"> </a>
<a name="ln281">#undef VHASH</a>
<a name="ln282"> </a>
<a name="ln283">	bool Compare(KeyType key, ValueType* vnode) const</a>
<a name="ln284">	{</a>
<a name="ln285">		return vnode-&gt;device == key.device &amp;&amp; vnode-&gt;id == key.vnode;</a>
<a name="ln286">	}</a>
<a name="ln287"> </a>
<a name="ln288">	ValueType*&amp; GetLink(ValueType* value) const</a>
<a name="ln289">	{</a>
<a name="ln290">		return value-&gt;next;</a>
<a name="ln291">	}</a>
<a name="ln292">};</a>
<a name="ln293"> </a>
<a name="ln294">typedef BOpenHashTable&lt;VnodeHash&gt; VnodeTable;</a>
<a name="ln295"> </a>
<a name="ln296"> </a>
<a name="ln297">struct MountHash {</a>
<a name="ln298">	typedef dev_t			KeyType;</a>
<a name="ln299">	typedef	struct fs_mount	ValueType;</a>
<a name="ln300"> </a>
<a name="ln301">	size_t HashKey(KeyType key) const</a>
<a name="ln302">	{</a>
<a name="ln303">		return key;</a>
<a name="ln304">	}</a>
<a name="ln305"> </a>
<a name="ln306">	size_t Hash(ValueType* mount) const</a>
<a name="ln307">	{</a>
<a name="ln308">		return mount-&gt;id;</a>
<a name="ln309">	}</a>
<a name="ln310"> </a>
<a name="ln311">	bool Compare(KeyType key, ValueType* mount) const</a>
<a name="ln312">	{</a>
<a name="ln313">		return mount-&gt;id == key;</a>
<a name="ln314">	}</a>
<a name="ln315"> </a>
<a name="ln316">	ValueType*&amp; GetLink(ValueType* value) const</a>
<a name="ln317">	{</a>
<a name="ln318">		return value-&gt;next;</a>
<a name="ln319">	}</a>
<a name="ln320">};</a>
<a name="ln321"> </a>
<a name="ln322">typedef BOpenHashTable&lt;MountHash&gt; MountTable;</a>
<a name="ln323"> </a>
<a name="ln324">} // namespace</a>
<a name="ln325"> </a>
<a name="ln326"> </a>
<a name="ln327">#define VNODE_HASH_TABLE_SIZE 1024</a>
<a name="ln328">static VnodeTable* sVnodeTable;</a>
<a name="ln329">static struct vnode* sRoot;</a>
<a name="ln330"> </a>
<a name="ln331">#define MOUNTS_HASH_TABLE_SIZE 16</a>
<a name="ln332">static MountTable* sMountsTable;</a>
<a name="ln333">static dev_t sNextMountID = 1;</a>
<a name="ln334"> </a>
<a name="ln335">#define MAX_TEMP_IO_VECS 8</a>
<a name="ln336"> </a>
<a name="ln337">// How long to wait for busy vnodes (10s)</a>
<a name="ln338">#define BUSY_VNODE_RETRIES 2000</a>
<a name="ln339">#define BUSY_VNODE_DELAY 5000</a>
<a name="ln340"> </a>
<a name="ln341">mode_t __gUmask = 022;</a>
<a name="ln342"> </a>
<a name="ln343">/* function declarations */</a>
<a name="ln344"> </a>
<a name="ln345">static void free_unused_vnodes();</a>
<a name="ln346"> </a>
<a name="ln347">// file descriptor operation prototypes</a>
<a name="ln348">static status_t file_read(struct file_descriptor* descriptor, off_t pos,</a>
<a name="ln349">	void* buffer, size_t* _bytes);</a>
<a name="ln350">static status_t file_write(struct file_descriptor* descriptor, off_t pos,</a>
<a name="ln351">	const void* buffer, size_t* _bytes);</a>
<a name="ln352">static off_t file_seek(struct file_descriptor* descriptor, off_t pos,</a>
<a name="ln353">	int seekType);</a>
<a name="ln354">static void file_free_fd(struct file_descriptor* descriptor);</a>
<a name="ln355">static status_t file_close(struct file_descriptor* descriptor);</a>
<a name="ln356">static status_t file_select(struct file_descriptor* descriptor, uint8 event,</a>
<a name="ln357">	struct selectsync* sync);</a>
<a name="ln358">static status_t file_deselect(struct file_descriptor* descriptor, uint8 event,</a>
<a name="ln359">	struct selectsync* sync);</a>
<a name="ln360">static status_t dir_read(struct io_context* context,</a>
<a name="ln361">	struct file_descriptor* descriptor, struct dirent* buffer,</a>
<a name="ln362">	size_t bufferSize, uint32* _count);</a>
<a name="ln363">static status_t dir_read(struct io_context* ioContext, struct vnode* vnode,</a>
<a name="ln364">	void* cookie, struct dirent* buffer, size_t bufferSize, uint32* _count);</a>
<a name="ln365">static status_t dir_rewind(struct file_descriptor* descriptor);</a>
<a name="ln366">static void dir_free_fd(struct file_descriptor* descriptor);</a>
<a name="ln367">static status_t dir_close(struct file_descriptor* descriptor);</a>
<a name="ln368">static status_t attr_dir_read(struct io_context* context,</a>
<a name="ln369">	struct file_descriptor* descriptor, struct dirent* buffer,</a>
<a name="ln370">	size_t bufferSize, uint32* _count);</a>
<a name="ln371">static status_t attr_dir_rewind(struct file_descriptor* descriptor);</a>
<a name="ln372">static void attr_dir_free_fd(struct file_descriptor* descriptor);</a>
<a name="ln373">static status_t attr_dir_close(struct file_descriptor* descriptor);</a>
<a name="ln374">static status_t attr_read(struct file_descriptor* descriptor, off_t pos,</a>
<a name="ln375">	void* buffer, size_t* _bytes);</a>
<a name="ln376">static status_t attr_write(struct file_descriptor* descriptor, off_t pos,</a>
<a name="ln377">	const void* buffer, size_t* _bytes);</a>
<a name="ln378">static off_t attr_seek(struct file_descriptor* descriptor, off_t pos,</a>
<a name="ln379">	int seekType);</a>
<a name="ln380">static void attr_free_fd(struct file_descriptor* descriptor);</a>
<a name="ln381">static status_t attr_close(struct file_descriptor* descriptor);</a>
<a name="ln382">static status_t attr_read_stat(struct file_descriptor* descriptor,</a>
<a name="ln383">	struct stat* statData);</a>
<a name="ln384">static status_t attr_write_stat(struct file_descriptor* descriptor,</a>
<a name="ln385">	const struct stat* stat, int statMask);</a>
<a name="ln386">static status_t index_dir_read(struct io_context* context,</a>
<a name="ln387">	struct file_descriptor* descriptor, struct dirent* buffer,</a>
<a name="ln388">	size_t bufferSize, uint32* _count);</a>
<a name="ln389">static status_t index_dir_rewind(struct file_descriptor* descriptor);</a>
<a name="ln390">static void index_dir_free_fd(struct file_descriptor* descriptor);</a>
<a name="ln391">static status_t index_dir_close(struct file_descriptor* descriptor);</a>
<a name="ln392">static status_t query_read(struct io_context* context,</a>
<a name="ln393">	struct file_descriptor* descriptor, struct dirent* buffer,</a>
<a name="ln394">	size_t bufferSize, uint32* _count);</a>
<a name="ln395">static status_t query_rewind(struct file_descriptor* descriptor);</a>
<a name="ln396">static void query_free_fd(struct file_descriptor* descriptor);</a>
<a name="ln397">static status_t query_close(struct file_descriptor* descriptor);</a>
<a name="ln398"> </a>
<a name="ln399">static status_t common_ioctl(struct file_descriptor* descriptor, ulong op,</a>
<a name="ln400">	void* buffer, size_t length);</a>
<a name="ln401">static status_t common_read_stat(struct file_descriptor* descriptor,</a>
<a name="ln402">	struct stat* statData);</a>
<a name="ln403">static status_t common_write_stat(struct file_descriptor* descriptor,</a>
<a name="ln404">	const struct stat* statData, int statMask);</a>
<a name="ln405">static status_t common_path_read_stat(int fd, char* path, bool traverseLeafLink,</a>
<a name="ln406">	struct stat* stat, bool kernel);</a>
<a name="ln407"> </a>
<a name="ln408">static status_t vnode_path_to_vnode(struct vnode* vnode, char* path,</a>
<a name="ln409">	bool traverseLeafLink, int count, bool kernel,</a>
<a name="ln410">	struct vnode** _vnode, ino_t* _parentID);</a>
<a name="ln411">static status_t dir_vnode_to_path(struct vnode* vnode, char* buffer,</a>
<a name="ln412">	size_t bufferSize, bool kernel);</a>
<a name="ln413">static status_t fd_and_path_to_vnode(int fd, char* path, bool traverseLeafLink,</a>
<a name="ln414">	struct vnode** _vnode, ino_t* _parentID, bool kernel);</a>
<a name="ln415">static void inc_vnode_ref_count(struct vnode* vnode);</a>
<a name="ln416">static status_t dec_vnode_ref_count(struct vnode* vnode, bool alwaysFree,</a>
<a name="ln417">	bool reenter);</a>
<a name="ln418">static inline void put_vnode(struct vnode* vnode);</a>
<a name="ln419">static status_t fs_unmount(char* path, dev_t mountID, uint32 flags,</a>
<a name="ln420">	bool kernel);</a>
<a name="ln421">static int open_vnode(struct vnode* vnode, int openMode, bool kernel);</a>
<a name="ln422"> </a>
<a name="ln423"> </a>
<a name="ln424">static struct fd_ops sFileOps = {</a>
<a name="ln425">	file_read,</a>
<a name="ln426">	file_write,</a>
<a name="ln427">	file_seek,</a>
<a name="ln428">	common_ioctl,</a>
<a name="ln429">	NULL,		// set_flags</a>
<a name="ln430">	file_select,</a>
<a name="ln431">	file_deselect,</a>
<a name="ln432">	NULL,		// read_dir()</a>
<a name="ln433">	NULL,		// rewind_dir()</a>
<a name="ln434">	common_read_stat,</a>
<a name="ln435">	common_write_stat,</a>
<a name="ln436">	file_close,</a>
<a name="ln437">	file_free_fd</a>
<a name="ln438">};</a>
<a name="ln439"> </a>
<a name="ln440">static struct fd_ops sDirectoryOps = {</a>
<a name="ln441">	NULL,		// read()</a>
<a name="ln442">	NULL,		// write()</a>
<a name="ln443">	NULL,		// seek()</a>
<a name="ln444">	common_ioctl,</a>
<a name="ln445">	NULL,		// set_flags</a>
<a name="ln446">	NULL,		// select()</a>
<a name="ln447">	NULL,		// deselect()</a>
<a name="ln448">	dir_read,</a>
<a name="ln449">	dir_rewind,</a>
<a name="ln450">	common_read_stat,</a>
<a name="ln451">	common_write_stat,</a>
<a name="ln452">	dir_close,</a>
<a name="ln453">	dir_free_fd</a>
<a name="ln454">};</a>
<a name="ln455"> </a>
<a name="ln456">static struct fd_ops sAttributeDirectoryOps = {</a>
<a name="ln457">	NULL,		// read()</a>
<a name="ln458">	NULL,		// write()</a>
<a name="ln459">	NULL,		// seek()</a>
<a name="ln460">	common_ioctl,</a>
<a name="ln461">	NULL,		// set_flags</a>
<a name="ln462">	NULL,		// select()</a>
<a name="ln463">	NULL,		// deselect()</a>
<a name="ln464">	attr_dir_read,</a>
<a name="ln465">	attr_dir_rewind,</a>
<a name="ln466">	common_read_stat,</a>
<a name="ln467">	common_write_stat,</a>
<a name="ln468">	attr_dir_close,</a>
<a name="ln469">	attr_dir_free_fd</a>
<a name="ln470">};</a>
<a name="ln471"> </a>
<a name="ln472">static struct fd_ops sAttributeOps = {</a>
<a name="ln473">	attr_read,</a>
<a name="ln474">	attr_write,</a>
<a name="ln475">	attr_seek,</a>
<a name="ln476">	common_ioctl,</a>
<a name="ln477">	NULL,		// set_flags</a>
<a name="ln478">	NULL,		// select()</a>
<a name="ln479">	NULL,		// deselect()</a>
<a name="ln480">	NULL,		// read_dir()</a>
<a name="ln481">	NULL,		// rewind_dir()</a>
<a name="ln482">	attr_read_stat,</a>
<a name="ln483">	attr_write_stat,</a>
<a name="ln484">	attr_close,</a>
<a name="ln485">	attr_free_fd</a>
<a name="ln486">};</a>
<a name="ln487"> </a>
<a name="ln488">static struct fd_ops sIndexDirectoryOps = {</a>
<a name="ln489">	NULL,		// read()</a>
<a name="ln490">	NULL,		// write()</a>
<a name="ln491">	NULL,		// seek()</a>
<a name="ln492">	NULL,		// ioctl()</a>
<a name="ln493">	NULL,		// set_flags</a>
<a name="ln494">	NULL,		// select()</a>
<a name="ln495">	NULL,		// deselect()</a>
<a name="ln496">	index_dir_read,</a>
<a name="ln497">	index_dir_rewind,</a>
<a name="ln498">	NULL,		// read_stat()</a>
<a name="ln499">	NULL,		// write_stat()</a>
<a name="ln500">	index_dir_close,</a>
<a name="ln501">	index_dir_free_fd</a>
<a name="ln502">};</a>
<a name="ln503"> </a>
<a name="ln504">#if 0</a>
<a name="ln505">static struct fd_ops sIndexOps = {</a>
<a name="ln506">	NULL,		// read()</a>
<a name="ln507">	NULL,		// write()</a>
<a name="ln508">	NULL,		// seek()</a>
<a name="ln509">	NULL,		// ioctl()</a>
<a name="ln510">	NULL,		// set_flags</a>
<a name="ln511">	NULL,		// select()</a>
<a name="ln512">	NULL,		// deselect()</a>
<a name="ln513">	NULL,		// dir_read()</a>
<a name="ln514">	NULL,		// dir_rewind()</a>
<a name="ln515">	index_read_stat,	// read_stat()</a>
<a name="ln516">	NULL,		// write_stat()</a>
<a name="ln517">	NULL,		// dir_close()</a>
<a name="ln518">	NULL		// free_fd()</a>
<a name="ln519">};</a>
<a name="ln520">#endif</a>
<a name="ln521"> </a>
<a name="ln522">static struct fd_ops sQueryOps = {</a>
<a name="ln523">	NULL,		// read()</a>
<a name="ln524">	NULL,		// write()</a>
<a name="ln525">	NULL,		// seek()</a>
<a name="ln526">	NULL,		// ioctl()</a>
<a name="ln527">	NULL,		// set_flags</a>
<a name="ln528">	NULL,		// select()</a>
<a name="ln529">	NULL,		// deselect()</a>
<a name="ln530">	query_read,</a>
<a name="ln531">	query_rewind,</a>
<a name="ln532">	NULL,		// read_stat()</a>
<a name="ln533">	NULL,		// write_stat()</a>
<a name="ln534">	query_close,</a>
<a name="ln535">	query_free_fd</a>
<a name="ln536">};</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">namespace {</a>
<a name="ln540"> </a>
<a name="ln541">class VNodePutter {</a>
<a name="ln542">public:</a>
<a name="ln543">	VNodePutter(struct vnode* vnode = NULL) : fVNode(vnode) {}</a>
<a name="ln544"> </a>
<a name="ln545">	~VNodePutter()</a>
<a name="ln546">	{</a>
<a name="ln547">		Put();</a>
<a name="ln548">	}</a>
<a name="ln549"> </a>
<a name="ln550">	void SetTo(struct vnode* vnode)</a>
<a name="ln551">	{</a>
<a name="ln552">		Put();</a>
<a name="ln553">		fVNode = vnode;</a>
<a name="ln554">	}</a>
<a name="ln555"> </a>
<a name="ln556">	void Put()</a>
<a name="ln557">	{</a>
<a name="ln558">		if (fVNode) {</a>
<a name="ln559">			put_vnode(fVNode);</a>
<a name="ln560">			fVNode = NULL;</a>
<a name="ln561">		}</a>
<a name="ln562">	}</a>
<a name="ln563"> </a>
<a name="ln564">	struct vnode* Detach()</a>
<a name="ln565">	{</a>
<a name="ln566">		struct vnode* vnode = fVNode;</a>
<a name="ln567">		fVNode = NULL;</a>
<a name="ln568">		return vnode;</a>
<a name="ln569">	}</a>
<a name="ln570"> </a>
<a name="ln571">private:</a>
<a name="ln572">	struct vnode* fVNode;</a>
<a name="ln573">};</a>
<a name="ln574"> </a>
<a name="ln575"> </a>
<a name="ln576">class FDCloser {</a>
<a name="ln577">public:</a>
<a name="ln578">	FDCloser() : fFD(-1), fKernel(true) {}</a>
<a name="ln579"> </a>
<a name="ln580">	FDCloser(int fd, bool kernel) : fFD(fd), fKernel(kernel) {}</a>
<a name="ln581"> </a>
<a name="ln582">	~FDCloser()</a>
<a name="ln583">	{</a>
<a name="ln584">		Close();</a>
<a name="ln585">	}</a>
<a name="ln586"> </a>
<a name="ln587">	void SetTo(int fd, bool kernel)</a>
<a name="ln588">	{</a>
<a name="ln589">		Close();</a>
<a name="ln590">		fFD = fd;</a>
<a name="ln591">		fKernel = kernel;</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">	void Close()</a>
<a name="ln595">	{</a>
<a name="ln596">		if (fFD &gt;= 0) {</a>
<a name="ln597">			if (fKernel)</a>
<a name="ln598">				_kern_close(fFD);</a>
<a name="ln599">			else</a>
<a name="ln600">				_user_close(fFD);</a>
<a name="ln601">			fFD = -1;</a>
<a name="ln602">		}</a>
<a name="ln603">	}</a>
<a name="ln604"> </a>
<a name="ln605">	int Detach()</a>
<a name="ln606">	{</a>
<a name="ln607">		int fd = fFD;</a>
<a name="ln608">		fFD = -1;</a>
<a name="ln609">		return fd;</a>
<a name="ln610">	}</a>
<a name="ln611"> </a>
<a name="ln612">private:</a>
<a name="ln613">	int		fFD;</a>
<a name="ln614">	bool	fKernel;</a>
<a name="ln615">};</a>
<a name="ln616"> </a>
<a name="ln617">} // namespace</a>
<a name="ln618"> </a>
<a name="ln619"> </a>
<a name="ln620">#if VFS_PAGES_IO_TRACING</a>
<a name="ln621"> </a>
<a name="ln622">namespace VFSPagesIOTracing {</a>
<a name="ln623"> </a>
<a name="ln624">class PagesIOTraceEntry : public AbstractTraceEntry {</a>
<a name="ln625">protected:</a>
<a name="ln626">	PagesIOTraceEntry(struct vnode* vnode, void* cookie, off_t pos,</a>
<a name="ln627">		const generic_io_vec* vecs, uint32 count, uint32 flags,</a>
<a name="ln628">		generic_size_t bytesRequested, status_t status,</a>
<a name="ln629">		generic_size_t bytesTransferred)</a>
<a name="ln630">		:</a>
<a name="ln631">		fVnode(vnode),</a>
<a name="ln632">		fMountID(vnode-&gt;mount-&gt;id),</a>
<a name="ln633">		fNodeID(vnode-&gt;id),</a>
<a name="ln634">		fCookie(cookie),</a>
<a name="ln635">		fPos(pos),</a>
<a name="ln636">		fCount(count),</a>
<a name="ln637">		fFlags(flags),</a>
<a name="ln638">		fBytesRequested(bytesRequested),</a>
<a name="ln639">		fStatus(status),</a>
<a name="ln640">		fBytesTransferred(bytesTransferred)</a>
<a name="ln641">	{</a>
<a name="ln642">		fVecs = (generic_io_vec*)alloc_tracing_buffer_memcpy(vecs,</a>
<a name="ln643">			sizeof(generic_io_vec) * count, false);</a>
<a name="ln644">	}</a>
<a name="ln645"> </a>
<a name="ln646">	void AddDump(TraceOutput&amp; out, const char* mode)</a>
<a name="ln647">	{</a>
<a name="ln648">		out.Print(&quot;vfs pages io %5s: vnode: %p (%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;), &quot;</a>
<a name="ln649">			&quot;cookie: %p, pos: %&quot; B_PRIdOFF &quot;, size: %&quot; B_PRIu64 &quot;, vecs: {&quot;,</a>
<a name="ln650">			mode, fVnode, fMountID, fNodeID, fCookie, fPos,</a>
<a name="ln651">			(uint64)fBytesRequested);</a>
<a name="ln652"> </a>
<a name="ln653">		if (fVecs != NULL) {</a>
<a name="ln654">			for (uint32 i = 0; i &lt; fCount; i++) {</a>
<a name="ln655">				if (i &gt; 0)</a>
<a name="ln656">					out.Print(&quot;, &quot;);</a>
<a name="ln657">				out.Print(&quot;(%&quot; B_PRIx64 &quot;, %&quot; B_PRIu64 &quot;)&quot;, (uint64)fVecs[i].base,</a>
<a name="ln658">					(uint64)fVecs[i].length);</a>
<a name="ln659">			}</a>
<a name="ln660">		}</a>
<a name="ln661"> </a>
<a name="ln662">		out.Print(&quot;}, flags: %#&quot; B_PRIx32 &quot; -&gt; status: %#&quot; B_PRIx32 &quot;, &quot;</a>
<a name="ln663">			&quot;transferred: %&quot; B_PRIu64, fFlags, fStatus,</a>
<a name="ln664">			(uint64)fBytesTransferred);</a>
<a name="ln665">	}</a>
<a name="ln666"> </a>
<a name="ln667">protected:</a>
<a name="ln668">	struct vnode*	fVnode;</a>
<a name="ln669">	dev_t			fMountID;</a>
<a name="ln670">	ino_t			fNodeID;</a>
<a name="ln671">	void*			fCookie;</a>
<a name="ln672">	off_t			fPos;</a>
<a name="ln673">	generic_io_vec*	fVecs;</a>
<a name="ln674">	uint32			fCount;</a>
<a name="ln675">	uint32			fFlags;</a>
<a name="ln676">	generic_size_t	fBytesRequested;</a>
<a name="ln677">	status_t		fStatus;</a>
<a name="ln678">	generic_size_t	fBytesTransferred;</a>
<a name="ln679">};</a>
<a name="ln680"> </a>
<a name="ln681"> </a>
<a name="ln682">class ReadPages : public PagesIOTraceEntry {</a>
<a name="ln683">public:</a>
<a name="ln684">	ReadPages(struct vnode* vnode, void* cookie, off_t pos,</a>
<a name="ln685">		const generic_io_vec* vecs, uint32 count, uint32 flags,</a>
<a name="ln686">		generic_size_t bytesRequested, status_t status,</a>
<a name="ln687">		generic_size_t bytesTransferred)</a>
<a name="ln688">		:</a>
<a name="ln689">		PagesIOTraceEntry(vnode, cookie, pos, vecs, count, flags,</a>
<a name="ln690">			bytesRequested, status, bytesTransferred)</a>
<a name="ln691">	{</a>
<a name="ln692">		Initialized();</a>
<a name="ln693">	}</a>
<a name="ln694"> </a>
<a name="ln695">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln696">	{</a>
<a name="ln697">		PagesIOTraceEntry::AddDump(out, &quot;read&quot;);</a>
<a name="ln698">	}</a>
<a name="ln699">};</a>
<a name="ln700"> </a>
<a name="ln701"> </a>
<a name="ln702">class WritePages : public PagesIOTraceEntry {</a>
<a name="ln703">public:</a>
<a name="ln704">	WritePages(struct vnode* vnode, void* cookie, off_t pos,</a>
<a name="ln705">		const generic_io_vec* vecs, uint32 count, uint32 flags,</a>
<a name="ln706">		generic_size_t bytesRequested, status_t status,</a>
<a name="ln707">		generic_size_t bytesTransferred)</a>
<a name="ln708">		:</a>
<a name="ln709">		PagesIOTraceEntry(vnode, cookie, pos, vecs, count, flags,</a>
<a name="ln710">			bytesRequested, status, bytesTransferred)</a>
<a name="ln711">	{</a>
<a name="ln712">		Initialized();</a>
<a name="ln713">	}</a>
<a name="ln714"> </a>
<a name="ln715">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln716">	{</a>
<a name="ln717">		PagesIOTraceEntry::AddDump(out, &quot;write&quot;);</a>
<a name="ln718">	}</a>
<a name="ln719">};</a>
<a name="ln720"> </a>
<a name="ln721">}	// namespace VFSPagesIOTracing</a>
<a name="ln722"> </a>
<a name="ln723">#	define TPIO(x) new(std::nothrow) VFSPagesIOTracing::x;</a>
<a name="ln724">#else</a>
<a name="ln725">#	define TPIO(x) ;</a>
<a name="ln726">#endif	// VFS_PAGES_IO_TRACING</a>
<a name="ln727"> </a>
<a name="ln728"> </a>
<a name="ln729">/*! Finds the mounted device (the fs_mount structure) with the given ID.</a>
<a name="ln730">	Note, you must hold the gMountMutex lock when you call this function.</a>
<a name="ln731">*/</a>
<a name="ln732">static struct fs_mount*</a>
<a name="ln733">find_mount(dev_t id)</a>
<a name="ln734">{</a>
<a name="ln735">	ASSERT_LOCKED_MUTEX(&amp;sMountMutex);</a>
<a name="ln736"> </a>
<a name="ln737">	return sMountsTable-&gt;Lookup(id);</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">static status_t</a>
<a name="ln742">get_mount(dev_t id, struct fs_mount** _mount)</a>
<a name="ln743">{</a>
<a name="ln744">	struct fs_mount* mount;</a>
<a name="ln745"> </a>
<a name="ln746">	ReadLocker nodeLocker(sVnodeLock);</a>
<a name="ln747">	MutexLocker mountLocker(sMountMutex);</a>
<a name="ln748"> </a>
<a name="ln749">	mount = find_mount(id);</a>
<a name="ln750">	if (mount == NULL)</a>
<a name="ln751">		return B_BAD_VALUE;</a>
<a name="ln752"> </a>
<a name="ln753">	struct vnode* rootNode = mount-&gt;root_vnode;</a>
<a name="ln754">	if (mount-&gt;unmounting || rootNode == NULL || rootNode-&gt;IsBusy()</a>
<a name="ln755">		|| rootNode-&gt;ref_count == 0) {</a>
<a name="ln756">		// might have been called during a mount/unmount operation</a>
<a name="ln757">		return B_BUSY;</a>
<a name="ln758">	}</a>
<a name="ln759"> </a>
<a name="ln760">	inc_vnode_ref_count(rootNode);</a>
<a name="ln761">	*_mount = mount;</a>
<a name="ln762">	return B_OK;</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765"> </a>
<a name="ln766">static void</a>
<a name="ln767">put_mount(struct fs_mount* mount)</a>
<a name="ln768">{</a>
<a name="ln769">	if (mount)</a>
<a name="ln770">		put_vnode(mount-&gt;root_vnode);</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773"> </a>
<a name="ln774">/*!	Tries to open the specified file system module.</a>
<a name="ln775">	Accepts a file system name of the form &quot;bfs&quot; or &quot;file_systems/bfs/v1&quot;.</a>
<a name="ln776">	Returns a pointer to file system module interface, or NULL if it</a>
<a name="ln777">	could not open the module.</a>
<a name="ln778">*/</a>
<a name="ln779">static file_system_module_info*</a>
<a name="ln780">get_file_system(const char* fsName)</a>
<a name="ln781">{</a>
<a name="ln782">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln783">	if (strncmp(fsName, &quot;file_systems/&quot;, strlen(&quot;file_systems/&quot;))) {</a>
<a name="ln784">		// construct module name if we didn't get one</a>
<a name="ln785">		// (we currently support only one API)</a>
<a name="ln786">		snprintf(name, sizeof(name), &quot;file_systems/%s/v1&quot;, fsName);</a>
<a name="ln787">		fsName = NULL;</a>
<a name="ln788">	}</a>
<a name="ln789"> </a>
<a name="ln790">	file_system_module_info* info;</a>
<a name="ln791">	if (get_module(fsName ? fsName : name, (module_info**)&amp;info) != B_OK)</a>
<a name="ln792">		return NULL;</a>
<a name="ln793"> </a>
<a name="ln794">	return info;</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797"> </a>
<a name="ln798">/*!	Accepts a file system name of the form &quot;bfs&quot; or &quot;file_systems/bfs/v1&quot;</a>
<a name="ln799">	and returns a compatible fs_info.fsh_name name (&quot;bfs&quot; in both cases).</a>
<a name="ln800">	The name is allocated for you, and you have to free() it when you're</a>
<a name="ln801">	done with it.</a>
<a name="ln802">	Returns NULL if the required memory is not available.</a>
<a name="ln803">*/</a>
<a name="ln804">static char*</a>
<a name="ln805">get_file_system_name(const char* fsName)</a>
<a name="ln806">{</a>
<a name="ln807">	const size_t length = strlen(&quot;file_systems/&quot;);</a>
<a name="ln808"> </a>
<a name="ln809">	if (strncmp(fsName, &quot;file_systems/&quot;, length)) {</a>
<a name="ln810">		// the name already seems to be the module's file name</a>
<a name="ln811">		return strdup(fsName);</a>
<a name="ln812">	}</a>
<a name="ln813"> </a>
<a name="ln814">	fsName += length;</a>
<a name="ln815">	const char* end = strchr(fsName, '/');</a>
<a name="ln816">	if (end == NULL) {</a>
<a name="ln817">		// this doesn't seem to be a valid name, but well...</a>
<a name="ln818">		return strdup(fsName);</a>
<a name="ln819">	}</a>
<a name="ln820"> </a>
<a name="ln821">	// cut off the trailing /v1</a>
<a name="ln822"> </a>
<a name="ln823">	char* name = (char*)malloc(end + 1 - fsName);</a>
<a name="ln824">	if (name == NULL)</a>
<a name="ln825">		return NULL;</a>
<a name="ln826"> </a>
<a name="ln827">	strlcpy(name, fsName, end + 1 - fsName);</a>
<a name="ln828">	return name;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831"> </a>
<a name="ln832">/*!	Accepts a list of file system names separated by a colon, one for each</a>
<a name="ln833">	layer and returns the file system name for the specified layer.</a>
<a name="ln834">	The name is allocated for you, and you have to free() it when you're</a>
<a name="ln835">	done with it.</a>
<a name="ln836">	Returns NULL if the required memory is not available or if there is no</a>
<a name="ln837">	name for the specified layer.</a>
<a name="ln838">*/</a>
<a name="ln839">static char*</a>
<a name="ln840">get_file_system_name_for_layer(const char* fsNames, int32 layer)</a>
<a name="ln841">{</a>
<a name="ln842">	while (layer &gt;= 0) {</a>
<a name="ln843">		const char* end = strchr(fsNames, ':');</a>
<a name="ln844">		if (end == NULL) {</a>
<a name="ln845">			if (layer == 0)</a>
<a name="ln846">				return strdup(fsNames);</a>
<a name="ln847">			return NULL;</a>
<a name="ln848">		}</a>
<a name="ln849"> </a>
<a name="ln850">		if (layer == 0) {</a>
<a name="ln851">			size_t length = end - fsNames + 1;</a>
<a name="ln852">			char* result = (char*)malloc(length);</a>
<a name="ln853">			strlcpy(result, fsNames, length);</a>
<a name="ln854">			return result;</a>
<a name="ln855">		}</a>
<a name="ln856"> </a>
<a name="ln857">		fsNames = end + 1;</a>
<a name="ln858">		layer--;</a>
<a name="ln859">	}</a>
<a name="ln860"> </a>
<a name="ln861">	return NULL;</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864"> </a>
<a name="ln865">static void</a>
<a name="ln866">add_vnode_to_mount_list(struct vnode* vnode, struct fs_mount* mount)</a>
<a name="ln867">{</a>
<a name="ln868">	MutexLocker _(mount-&gt;lock);</a>
<a name="ln869">	mount-&gt;vnodes.Add(vnode);</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872"> </a>
<a name="ln873">static void</a>
<a name="ln874">remove_vnode_from_mount_list(struct vnode* vnode, struct fs_mount* mount)</a>
<a name="ln875">{</a>
<a name="ln876">	MutexLocker _(mount-&gt;lock);</a>
<a name="ln877">	mount-&gt;vnodes.Remove(vnode);</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880"> </a>
<a name="ln881">/*!	\brief Looks up a vnode by mount and node ID in the sVnodeTable.</a>
<a name="ln882"> </a>
<a name="ln883">	The caller must hold the sVnodeLock (read lock at least).</a>
<a name="ln884"> </a>
<a name="ln885">	\param mountID the mount ID.</a>
<a name="ln886">	\param vnodeID the node ID.</a>
<a name="ln887"> </a>
<a name="ln888">	\return The vnode structure, if it was found in the hash table, \c NULL</a>
<a name="ln889">			otherwise.</a>
<a name="ln890">*/</a>
<a name="ln891">static struct vnode*</a>
<a name="ln892">lookup_vnode(dev_t mountID, ino_t vnodeID)</a>
<a name="ln893">{</a>
<a name="ln894">	struct vnode_hash_key key;</a>
<a name="ln895"> </a>
<a name="ln896">	key.device = mountID;</a>
<a name="ln897">	key.vnode = vnodeID;</a>
<a name="ln898"> </a>
<a name="ln899">	return sVnodeTable-&gt;Lookup(key);</a>
<a name="ln900">}</a>
<a name="ln901"> </a>
<a name="ln902"> </a>
<a name="ln903">/*!	\brief Checks whether or not a busy vnode should be waited for (again).</a>
<a name="ln904"> </a>
<a name="ln905">	This will also wait for BUSY_VNODE_DELAY before returning if one should</a>
<a name="ln906">	still wait for the vnode becoming unbusy.</a>
<a name="ln907"> </a>
<a name="ln908">	\return \c true if one should retry, \c false if not.</a>
<a name="ln909">*/</a>
<a name="ln910">static bool</a>
<a name="ln911">retry_busy_vnode(int32&amp; tries, dev_t mountID, ino_t vnodeID)</a>
<a name="ln912">{</a>
<a name="ln913">	if (--tries &lt; 0) {</a>
<a name="ln914">		// vnode doesn't seem to become unbusy</a>
<a name="ln915">		dprintf(&quot;vnode %&quot; B_PRIdDEV &quot;:%&quot; B_PRIdINO</a>
<a name="ln916">			&quot; is not becoming unbusy!\n&quot;, mountID, vnodeID);</a>
<a name="ln917">		return false;</a>
<a name="ln918">	}</a>
<a name="ln919">	snooze(BUSY_VNODE_DELAY);</a>
<a name="ln920">	return true;</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923"> </a>
<a name="ln924">/*!	Creates a new vnode with the given mount and node ID.</a>
<a name="ln925">	If the node already exists, it is returned instead and no new node is</a>
<a name="ln926">	created. In either case -- but not, if an error occurs -- the function write</a>
<a name="ln927">	locks \c sVnodeLock and keeps it locked for the caller when returning. On</a>
<a name="ln928">	error the lock is not held on return.</a>
<a name="ln929"> </a>
<a name="ln930">	\param mountID The mount ID.</a>
<a name="ln931">	\param vnodeID The vnode ID.</a>
<a name="ln932">	\param _vnode Will be set to the new vnode on success.</a>
<a name="ln933">	\param _nodeCreated Will be set to \c true when the returned vnode has</a>
<a name="ln934">		been newly created, \c false when it already existed. Will not be</a>
<a name="ln935">		changed on error.</a>
<a name="ln936">	\return \c B_OK, when the vnode was successfully created and inserted or</a>
<a name="ln937">		a node with the given ID was found, \c B_NO_MEMORY or</a>
<a name="ln938">		\c B_ENTRY_NOT_FOUND on error.</a>
<a name="ln939">*/</a>
<a name="ln940">static status_t</a>
<a name="ln941">create_new_vnode_and_lock(dev_t mountID, ino_t vnodeID, struct vnode*&amp; _vnode,</a>
<a name="ln942">	bool&amp; _nodeCreated)</a>
<a name="ln943">{</a>
<a name="ln944">	FUNCTION((&quot;create_new_vnode_and_lock()\n&quot;));</a>
<a name="ln945"> </a>
<a name="ln946">	struct vnode* vnode = (struct vnode*)malloc(sizeof(struct vnode));</a>
<a name="ln947">	if (vnode == NULL)</a>
<a name="ln948">		return B_NO_MEMORY;</a>
<a name="ln949"> </a>
<a name="ln950">	// initialize basic values</a>
<a name="ln951">	memset(vnode, 0, sizeof(struct vnode));</a>
<a name="ln952">	vnode-&gt;device = mountID;</a>
<a name="ln953">	vnode-&gt;id = vnodeID;</a>
<a name="ln954">	vnode-&gt;ref_count = 1;</a>
<a name="ln955">	vnode-&gt;SetBusy(true);</a>
<a name="ln956"> </a>
<a name="ln957">	// look up the node -- it might have been added by someone else in the</a>
<a name="ln958">	// meantime</a>
<a name="ln959">	rw_lock_write_lock(&amp;sVnodeLock);</a>
<a name="ln960">	struct vnode* existingVnode = lookup_vnode(mountID, vnodeID);</a>
<a name="ln961">	if (existingVnode != NULL) {</a>
<a name="ln962">		free(vnode);</a>
<a name="ln963">		_vnode = existingVnode;</a>
<a name="ln964">		_nodeCreated = false;</a>
<a name="ln965">		return B_OK;</a>
<a name="ln966">	}</a>
<a name="ln967"> </a>
<a name="ln968">	// get the mount structure</a>
<a name="ln969">	mutex_lock(&amp;sMountMutex);</a>
<a name="ln970">	vnode-&gt;mount = find_mount(mountID);</a>
<a name="ln971">	if (!vnode-&gt;mount || vnode-&gt;mount-&gt;unmounting) {</a>
<a name="ln972">		mutex_unlock(&amp;sMountMutex);</a>
<a name="ln973">		rw_lock_write_unlock(&amp;sVnodeLock);</a>
<a name="ln974">		free(vnode);</a>
<a name="ln975">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln976">	}</a>
<a name="ln977"> </a>
<a name="ln978">	// add the vnode to the mount's node list and the hash table</a>
<a name="ln979">	sVnodeTable-&gt;Insert(vnode);</a>
<a name="ln980">	add_vnode_to_mount_list(vnode, vnode-&gt;mount);</a>
<a name="ln981"> </a>
<a name="ln982">	mutex_unlock(&amp;sMountMutex);</a>
<a name="ln983"> </a>
<a name="ln984">	_vnode = vnode;</a>
<a name="ln985">	_nodeCreated = true;</a>
<a name="ln986"> </a>
<a name="ln987">	// keep the vnode lock locked</a>
<a name="ln988">	return B_OK;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991"> </a>
<a name="ln992">/*!	Frees the vnode and all resources it has acquired, and removes</a>
<a name="ln993">	it from the vnode hash as well as from its mount structure.</a>
<a name="ln994">	Will also make sure that any cache modifications are written back.</a>
<a name="ln995">*/</a>
<a name="ln996">static void</a>
<a name="ln997">free_vnode(struct vnode* vnode, bool reenter)</a>
<a name="ln998">{</a>
<a name="ln999">	ASSERT_PRINT(vnode-&gt;ref_count == 0 &amp;&amp; vnode-&gt;IsBusy(), &quot;vnode: %p\n&quot;,</a>
<a name="ln1000">		vnode);</a>
<a name="ln1001">	ASSERT_PRINT(vnode-&gt;advisory_locking == NULL, &quot;vnode: %p\n&quot;, vnode);</a>
<a name="ln1002"> </a>
<a name="ln1003">	// write back any changes in this vnode's cache -- but only</a>
<a name="ln1004">	// if the vnode won't be deleted, in which case the changes</a>
<a name="ln1005">	// will be discarded</a>
<a name="ln1006"> </a>
<a name="ln1007">	if (!vnode-&gt;IsRemoved() &amp;&amp; HAS_FS_CALL(vnode, fsync))</a>
<a name="ln1008">		FS_CALL_NO_PARAMS(vnode, fsync);</a>
<a name="ln1009"> </a>
<a name="ln1010">	// Note: If this vnode has a cache attached, there will still be two</a>
<a name="ln1011">	// references to that cache at this point. The last one belongs to the vnode</a>
<a name="ln1012">	// itself (cf. vfs_get_vnode_cache()) and one belongs to the node's file</a>
<a name="ln1013">	// cache. Each but the last reference to a cache also includes a reference</a>
<a name="ln1014">	// to the vnode. The file cache, however, released its reference (cf.</a>
<a name="ln1015">	// file_cache_create()), so that this vnode's ref count has the chance to</a>
<a name="ln1016">	// ever drop to 0. Deleting the file cache now, will cause the next to last</a>
<a name="ln1017">	// cache reference to be released, which will also release a (no longer</a>
<a name="ln1018">	// existing) vnode reference. To avoid problems, we set the vnode's ref</a>
<a name="ln1019">	// count, so that it will neither become negative nor 0.</a>
<a name="ln1020">	vnode-&gt;ref_count = 2;</a>
<a name="ln1021"> </a>
<a name="ln1022">	if (!vnode-&gt;IsUnpublished()) {</a>
<a name="ln1023">		if (vnode-&gt;IsRemoved())</a>
<a name="ln1024">			FS_CALL(vnode, remove_vnode, reenter);</a>
<a name="ln1025">		else</a>
<a name="ln1026">			FS_CALL(vnode, put_vnode, reenter);</a>
<a name="ln1027">	}</a>
<a name="ln1028"> </a>
<a name="ln1029">	// If the vnode has a VMCache attached, make sure that it won't try to get</a>
<a name="ln1030">	// another reference via VMVnodeCache::AcquireUnreferencedStoreRef(). As</a>
<a name="ln1031">	// long as the vnode is busy and in the hash, that won't happen, but as</a>
<a name="ln1032">	// soon as we've removed it from the hash, it could reload the vnode -- with</a>
<a name="ln1033">	// a new cache attached!</a>
<a name="ln1034">	if (vnode-&gt;cache != NULL)</a>
<a name="ln1035">		((VMVnodeCache*)vnode-&gt;cache)-&gt;VnodeDeleted();</a>
<a name="ln1036"> </a>
<a name="ln1037">	// The file system has removed the resources of the vnode now, so we can</a>
<a name="ln1038">	// make it available again (by removing the busy vnode from the hash).</a>
<a name="ln1039">	rw_lock_write_lock(&amp;sVnodeLock);</a>
<a name="ln1040">	sVnodeTable-&gt;Remove(vnode);</a>
<a name="ln1041">	rw_lock_write_unlock(&amp;sVnodeLock);</a>
<a name="ln1042"> </a>
<a name="ln1043">	// if we have a VMCache attached, remove it</a>
<a name="ln1044">	if (vnode-&gt;cache)</a>
<a name="ln1045">		vnode-&gt;cache-&gt;ReleaseRef();</a>
<a name="ln1046"> </a>
<a name="ln1047">	vnode-&gt;cache = NULL;</a>
<a name="ln1048"> </a>
<a name="ln1049">	remove_vnode_from_mount_list(vnode, vnode-&gt;mount);</a>
<a name="ln1050"> </a>
<a name="ln1051">	free(vnode);</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055">/*!	\brief Decrements the reference counter of the given vnode and deletes it,</a>
<a name="ln1056">	if the counter dropped to 0.</a>
<a name="ln1057"> </a>
<a name="ln1058">	The caller must, of course, own a reference to the vnode to call this</a>
<a name="ln1059">	function.</a>
<a name="ln1060">	The caller must not hold the sVnodeLock or the sMountMutex.</a>
<a name="ln1061"> </a>
<a name="ln1062">	\param vnode the vnode.</a>
<a name="ln1063">	\param alwaysFree don't move this vnode into the unused list, but really</a>
<a name="ln1064">		   delete it if possible.</a>
<a name="ln1065">	\param reenter \c true, if this function is called (indirectly) from within</a>
<a name="ln1066">		   a file system. This will be passed to file system hooks only.</a>
<a name="ln1067">	\return \c B_OK, if everything went fine, an error code otherwise.</a>
<a name="ln1068">*/</a>
<a name="ln1069">static status_t</a>
<a name="ln1070">dec_vnode_ref_count(struct vnode* vnode, bool alwaysFree, bool reenter)</a>
<a name="ln1071">{</a>
<a name="ln1072">	ReadLocker locker(sVnodeLock);</a>
<a name="ln1073">	AutoLocker&lt;Vnode&gt; nodeLocker(vnode);</a>
<a name="ln1074"> </a>
<a name="ln1075">	int32 oldRefCount = atomic_add(&amp;vnode-&gt;ref_count, -1);</a>
<a name="ln1076"> </a>
<a name="ln1077">	ASSERT_PRINT(oldRefCount &gt; 0, &quot;vnode %p\n&quot;, vnode);</a>
<a name="ln1078"> </a>
<a name="ln1079">	TRACE((&quot;dec_vnode_ref_count: vnode %p, ref now %&quot; B_PRId32 &quot;\n&quot;, vnode,</a>
<a name="ln1080">		vnode-&gt;ref_count));</a>
<a name="ln1081"> </a>
<a name="ln1082">	if (oldRefCount != 1)</a>
<a name="ln1083">		return B_OK;</a>
<a name="ln1084"> </a>
<a name="ln1085">	if (vnode-&gt;IsBusy())</a>
<a name="ln1086">		panic(&quot;dec_vnode_ref_count: called on busy vnode %p\n&quot;, vnode);</a>
<a name="ln1087"> </a>
<a name="ln1088">	bool freeNode = false;</a>
<a name="ln1089">	bool freeUnusedNodes = false;</a>
<a name="ln1090"> </a>
<a name="ln1091">	// Just insert the vnode into an unused list if we don't need</a>
<a name="ln1092">	// to delete it</a>
<a name="ln1093">	if (vnode-&gt;IsRemoved() || alwaysFree) {</a>
<a name="ln1094">		vnode_to_be_freed(vnode);</a>
<a name="ln1095">		vnode-&gt;SetBusy(true);</a>
<a name="ln1096">		freeNode = true;</a>
<a name="ln1097">	} else</a>
<a name="ln1098">		freeUnusedNodes = vnode_unused(vnode);</a>
<a name="ln1099"> </a>
<a name="ln1100">	nodeLocker.Unlock();</a>
<a name="ln1101">	locker.Unlock();</a>
<a name="ln1102"> </a>
<a name="ln1103">	if (freeNode)</a>
<a name="ln1104">		free_vnode(vnode, reenter);</a>
<a name="ln1105">	else if (freeUnusedNodes)</a>
<a name="ln1106">		free_unused_vnodes();</a>
<a name="ln1107"> </a>
<a name="ln1108">	return B_OK;</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111"> </a>
<a name="ln1112">/*!	\brief Increments the reference counter of the given vnode.</a>
<a name="ln1113"> </a>
<a name="ln1114">	The caller must make sure that the node isn't deleted while this function</a>
<a name="ln1115">	is called. This can be done either:</a>
<a name="ln1116">	- by ensuring that a reference to the node exists and remains in existence,</a>
<a name="ln1117">	  or</a>
<a name="ln1118">	- by holding the vnode's lock (which also requires read locking sVnodeLock)</a>
<a name="ln1119">	  or by holding sVnodeLock write locked.</a>
<a name="ln1120"> </a>
<a name="ln1121">	In the second case the caller is responsible for dealing with the ref count</a>
<a name="ln1122">	0 -&gt; 1 transition. That is 1. this function must not be invoked when the</a>
<a name="ln1123">	node is busy in the first place and 2. vnode_used() must be called for the</a>
<a name="ln1124">	node.</a>
<a name="ln1125"> </a>
<a name="ln1126">	\param vnode the vnode.</a>
<a name="ln1127">*/</a>
<a name="ln1128">static void</a>
<a name="ln1129">inc_vnode_ref_count(struct vnode* vnode)</a>
<a name="ln1130">{</a>
<a name="ln1131">	atomic_add(&amp;vnode-&gt;ref_count, 1);</a>
<a name="ln1132">	TRACE((&quot;inc_vnode_ref_count: vnode %p, ref now %&quot; B_PRId32 &quot;\n&quot;, vnode,</a>
<a name="ln1133">		vnode-&gt;ref_count));</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136"> </a>
<a name="ln1137">static bool</a>
<a name="ln1138">is_special_node_type(int type)</a>
<a name="ln1139">{</a>
<a name="ln1140">	// at the moment only FIFOs are supported</a>
<a name="ln1141">	return S_ISFIFO(type);</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144"> </a>
<a name="ln1145">static status_t</a>
<a name="ln1146">create_special_sub_node(struct vnode* vnode, uint32 flags)</a>
<a name="ln1147">{</a>
<a name="ln1148">	if (S_ISFIFO(vnode-&gt;Type()))</a>
<a name="ln1149">		return create_fifo_vnode(vnode-&gt;mount-&gt;volume, vnode);</a>
<a name="ln1150"> </a>
<a name="ln1151">	return B_BAD_VALUE;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154"> </a>
<a name="ln1155">/*!	\brief Retrieves a vnode for a given mount ID, node ID pair.</a>
<a name="ln1156"> </a>
<a name="ln1157">	If the node is not yet in memory, it will be loaded.</a>
<a name="ln1158"> </a>
<a name="ln1159">	The caller must not hold the sVnodeLock or the sMountMutex.</a>
<a name="ln1160"> </a>
<a name="ln1161">	\param mountID the mount ID.</a>
<a name="ln1162">	\param vnodeID the node ID.</a>
<a name="ln1163">	\param _vnode Pointer to a vnode* variable into which the pointer to the</a>
<a name="ln1164">		   retrieved vnode structure shall be written.</a>
<a name="ln1165">	\param reenter \c true, if this function is called (indirectly) from within</a>
<a name="ln1166">		   a file system.</a>
<a name="ln1167">	\return \c B_OK, if everything when fine, an error code otherwise.</a>
<a name="ln1168">*/</a>
<a name="ln1169">static status_t</a>
<a name="ln1170">get_vnode(dev_t mountID, ino_t vnodeID, struct vnode** _vnode, bool canWait,</a>
<a name="ln1171">	int reenter)</a>
<a name="ln1172">{</a>
<a name="ln1173">	FUNCTION((&quot;get_vnode: mountid %&quot; B_PRId32 &quot; vnid 0x%&quot; B_PRIx64 &quot; %p\n&quot;,</a>
<a name="ln1174">		mountID, vnodeID, _vnode));</a>
<a name="ln1175"> </a>
<a name="ln1176">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln1177"> </a>
<a name="ln1178">	int32 tries = BUSY_VNODE_RETRIES;</a>
<a name="ln1179">restart:</a>
<a name="ln1180">	struct vnode* vnode = lookup_vnode(mountID, vnodeID);</a>
<a name="ln1181">	AutoLocker&lt;Vnode&gt; nodeLocker(vnode);</a>
<a name="ln1182"> </a>
<a name="ln1183">	if (vnode &amp;&amp; vnode-&gt;IsBusy()) {</a>
<a name="ln1184">		nodeLocker.Unlock();</a>
<a name="ln1185">		rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln1186">		if (!canWait) {</a>
<a name="ln1187">			dprintf(&quot;vnode %&quot; B_PRIdDEV &quot;:%&quot; B_PRIdINO &quot; is busy!\n&quot;,</a>
<a name="ln1188">				mountID, vnodeID);</a>
<a name="ln1189">			return B_BUSY;</a>
<a name="ln1190">		}</a>
<a name="ln1191">		if (!retry_busy_vnode(tries, mountID, vnodeID))</a>
<a name="ln1192">			return B_BUSY;</a>
<a name="ln1193"> </a>
<a name="ln1194">		rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln1195">		goto restart;</a>
<a name="ln1196">	}</a>
<a name="ln1197"> </a>
<a name="ln1198">	TRACE((&quot;get_vnode: tried to lookup vnode, got %p\n&quot;, vnode));</a>
<a name="ln1199"> </a>
<a name="ln1200">	status_t status;</a>
<a name="ln1201"> </a>
<a name="ln1202">	if (vnode) {</a>
<a name="ln1203">		if (vnode-&gt;ref_count == 0) {</a>
<a name="ln1204">			// this vnode has been unused before</a>
<a name="ln1205">			vnode_used(vnode);</a>
<a name="ln1206">		}</a>
<a name="ln1207">		inc_vnode_ref_count(vnode);</a>
<a name="ln1208"> </a>
<a name="ln1209">		nodeLocker.Unlock();</a>
<a name="ln1210">		rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln1211">	} else {</a>
<a name="ln1212">		// we need to create a new vnode and read it in</a>
<a name="ln1213">		rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln1214">			// unlock -- create_new_vnode_and_lock() write-locks on success</a>
<a name="ln1215">		bool nodeCreated;</a>
<a name="ln1216">		status = create_new_vnode_and_lock(mountID, vnodeID, vnode,</a>
<a name="ln1217">			nodeCreated);</a>
<a name="ln1218">		if (status != B_OK)</a>
<a name="ln1219">			return status;</a>
<a name="ln1220"> </a>
<a name="ln1221">		if (!nodeCreated) {</a>
<a name="ln1222">			rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln1223">			rw_lock_write_unlock(&amp;sVnodeLock);</a>
<a name="ln1224">			goto restart;</a>
<a name="ln1225">		}</a>
<a name="ln1226"> </a>
<a name="ln1227">		rw_lock_write_unlock(&amp;sVnodeLock);</a>
<a name="ln1228"> </a>
<a name="ln1229">		int type;</a>
<a name="ln1230">		uint32 flags;</a>
<a name="ln1231">		status = FS_MOUNT_CALL(vnode-&gt;mount, get_vnode, vnodeID, vnode, &amp;type,</a>
<a name="ln1232">			&amp;flags, reenter);</a>
<a name="ln1233">		if (status == B_OK &amp;&amp; vnode-&gt;private_node == NULL)</a>
<a name="ln1234">			status = B_BAD_VALUE;</a>
<a name="ln1235"> </a>
<a name="ln1236">		bool gotNode = status == B_OK;</a>
<a name="ln1237">		bool publishSpecialSubNode = false;</a>
<a name="ln1238">		if (gotNode) {</a>
<a name="ln1239">			vnode-&gt;SetType(type);</a>
<a name="ln1240">			publishSpecialSubNode = is_special_node_type(type)</a>
<a name="ln1241">				&amp;&amp; (flags &amp; B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE) == 0;</a>
<a name="ln1242">		}</a>
<a name="ln1243"> </a>
<a name="ln1244">		if (gotNode &amp;&amp; publishSpecialSubNode)</a>
<a name="ln1245">			status = create_special_sub_node(vnode, flags);</a>
<a name="ln1246"> </a>
<a name="ln1247">		if (status != B_OK) {</a>
<a name="ln1248">			if (gotNode)</a>
<a name="ln1249">				FS_CALL(vnode, put_vnode, reenter);</a>
<a name="ln1250"> </a>
<a name="ln1251">			rw_lock_write_lock(&amp;sVnodeLock);</a>
<a name="ln1252">			sVnodeTable-&gt;Remove(vnode);</a>
<a name="ln1253">			remove_vnode_from_mount_list(vnode, vnode-&gt;mount);</a>
<a name="ln1254">			rw_lock_write_unlock(&amp;sVnodeLock);</a>
<a name="ln1255"> </a>
<a name="ln1256">			free(vnode);</a>
<a name="ln1257">			return status;</a>
<a name="ln1258">		}</a>
<a name="ln1259"> </a>
<a name="ln1260">		rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln1261">		vnode-&gt;Lock();</a>
<a name="ln1262"> </a>
<a name="ln1263">		vnode-&gt;SetRemoved((flags &amp; B_VNODE_PUBLISH_REMOVED) != 0);</a>
<a name="ln1264">		vnode-&gt;SetBusy(false);</a>
<a name="ln1265"> </a>
<a name="ln1266">		vnode-&gt;Unlock();</a>
<a name="ln1267">		rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln1268">	}</a>
<a name="ln1269"> </a>
<a name="ln1270">	TRACE((&quot;get_vnode: returning %p\n&quot;, vnode));</a>
<a name="ln1271"> </a>
<a name="ln1272">	*_vnode = vnode;</a>
<a name="ln1273">	return B_OK;</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276"> </a>
<a name="ln1277">/*!	\brief Decrements the reference counter of the given vnode and deletes it,</a>
<a name="ln1278">	if the counter dropped to 0.</a>
<a name="ln1279"> </a>
<a name="ln1280">	The caller must, of course, own a reference to the vnode to call this</a>
<a name="ln1281">	function.</a>
<a name="ln1282">	The caller must not hold the sVnodeLock or the sMountMutex.</a>
<a name="ln1283"> </a>
<a name="ln1284">	\param vnode the vnode.</a>
<a name="ln1285">*/</a>
<a name="ln1286">static inline void</a>
<a name="ln1287">put_vnode(struct vnode* vnode)</a>
<a name="ln1288">{</a>
<a name="ln1289">	dec_vnode_ref_count(vnode, false, false);</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292"> </a>
<a name="ln1293">static void</a>
<a name="ln1294">free_unused_vnodes(int32 level)</a>
<a name="ln1295">{</a>
<a name="ln1296">	unused_vnodes_check_started();</a>
<a name="ln1297"> </a>
<a name="ln1298">	if (level == B_NO_LOW_RESOURCE) {</a>
<a name="ln1299">		unused_vnodes_check_done();</a>
<a name="ln1300">		return;</a>
<a name="ln1301">	}</a>
<a name="ln1302"> </a>
<a name="ln1303">	flush_hot_vnodes();</a>
<a name="ln1304"> </a>
<a name="ln1305">	// determine how many nodes to free</a>
<a name="ln1306">	uint32 count = 1;</a>
<a name="ln1307">	{</a>
<a name="ln1308">		MutexLocker unusedVnodesLocker(sUnusedVnodesLock);</a>
<a name="ln1309"> </a>
<a name="ln1310">		switch (level) {</a>
<a name="ln1311">			case B_LOW_RESOURCE_NOTE:</a>
<a name="ln1312">				count = sUnusedVnodes / 100;</a>
<a name="ln1313">				break;</a>
<a name="ln1314">			case B_LOW_RESOURCE_WARNING:</a>
<a name="ln1315">				count = sUnusedVnodes / 10;</a>
<a name="ln1316">				break;</a>
<a name="ln1317">			case B_LOW_RESOURCE_CRITICAL:</a>
<a name="ln1318">				count = sUnusedVnodes;</a>
<a name="ln1319">				break;</a>
<a name="ln1320">		}</a>
<a name="ln1321"> </a>
<a name="ln1322">		if (count &gt; sUnusedVnodes)</a>
<a name="ln1323">			count = sUnusedVnodes;</a>
<a name="ln1324">	}</a>
<a name="ln1325"> </a>
<a name="ln1326">	// Write back the modified pages of some unused vnodes and free them.</a>
<a name="ln1327"> </a>
<a name="ln1328">	for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln1329">		ReadLocker vnodesReadLocker(sVnodeLock);</a>
<a name="ln1330"> </a>
<a name="ln1331">		// get the first node</a>
<a name="ln1332">		MutexLocker unusedVnodesLocker(sUnusedVnodesLock);</a>
<a name="ln1333">		struct vnode* vnode = (struct vnode*)list_get_first_item(</a>
<a name="ln1334">			&amp;sUnusedVnodeList);</a>
<a name="ln1335">		unusedVnodesLocker.Unlock();</a>
<a name="ln1336"> </a>
<a name="ln1337">		if (vnode == NULL)</a>
<a name="ln1338">			break;</a>
<a name="ln1339"> </a>
<a name="ln1340">		// lock the node</a>
<a name="ln1341">		AutoLocker&lt;Vnode&gt; nodeLocker(vnode);</a>
<a name="ln1342"> </a>
<a name="ln1343">		// Check whether the node is still unused -- since we only append to the</a>
<a name="ln1344">		// tail of the unused queue, the vnode should still be at its head.</a>
<a name="ln1345">		// Alternatively we could check its ref count for 0 and its busy flag,</a>
<a name="ln1346">		// but if the node is no longer at the head of the queue, it means it</a>
<a name="ln1347">		// has been touched in the meantime, i.e. it is no longer the least</a>
<a name="ln1348">		// recently used unused vnode and we rather don't free it.</a>
<a name="ln1349">		unusedVnodesLocker.Lock();</a>
<a name="ln1350">		if (vnode != list_get_first_item(&amp;sUnusedVnodeList))</a>
<a name="ln1351">			continue;</a>
<a name="ln1352">		unusedVnodesLocker.Unlock();</a>
<a name="ln1353"> </a>
<a name="ln1354">		ASSERT(!vnode-&gt;IsBusy());</a>
<a name="ln1355"> </a>
<a name="ln1356">		// grab a reference</a>
<a name="ln1357">		inc_vnode_ref_count(vnode);</a>
<a name="ln1358">		vnode_used(vnode);</a>
<a name="ln1359"> </a>
<a name="ln1360">		// write back changes and free the node</a>
<a name="ln1361">		nodeLocker.Unlock();</a>
<a name="ln1362">		vnodesReadLocker.Unlock();</a>
<a name="ln1363"> </a>
<a name="ln1364">		if (vnode-&gt;cache != NULL)</a>
<a name="ln1365">			vnode-&gt;cache-&gt;WriteModified();</a>
<a name="ln1366"> </a>
<a name="ln1367">		dec_vnode_ref_count(vnode, true, false);</a>
<a name="ln1368">			// this should free the vnode when it's still unused</a>
<a name="ln1369">	}</a>
<a name="ln1370"> </a>
<a name="ln1371">	unused_vnodes_check_done();</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374"> </a>
<a name="ln1375">/*!	Gets the vnode the given vnode is covering.</a>
<a name="ln1376"> </a>
<a name="ln1377">	The caller must have \c sVnodeLock read-locked at least.</a>
<a name="ln1378"> </a>
<a name="ln1379">	The function returns a reference to the retrieved vnode (if any), the caller</a>
<a name="ln1380">	is responsible to free.</a>
<a name="ln1381"> </a>
<a name="ln1382">	\param vnode The vnode whose covered node shall be returned.</a>
<a name="ln1383">	\return The covered vnode, or \c NULL if the given vnode doesn't cover any</a>
<a name="ln1384">		vnode.</a>
<a name="ln1385">*/</a>
<a name="ln1386">static inline Vnode*</a>
<a name="ln1387">get_covered_vnode_locked(Vnode* vnode)</a>
<a name="ln1388">{</a>
<a name="ln1389">	if (Vnode* coveredNode = vnode-&gt;covers) {</a>
<a name="ln1390">		while (coveredNode-&gt;covers != NULL)</a>
<a name="ln1391">			coveredNode = coveredNode-&gt;covers;</a>
<a name="ln1392"> </a>
<a name="ln1393">		inc_vnode_ref_count(coveredNode);</a>
<a name="ln1394">		return coveredNode;</a>
<a name="ln1395">	}</a>
<a name="ln1396"> </a>
<a name="ln1397">	return NULL;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">/*!	Gets the vnode the given vnode is covering.</a>
<a name="ln1402"> </a>
<a name="ln1403">	The caller must not hold \c sVnodeLock. Note that this implies a race</a>
<a name="ln1404">	condition, since the situation can change at any time.</a>
<a name="ln1405"> </a>
<a name="ln1406">	The function returns a reference to the retrieved vnode (if any), the caller</a>
<a name="ln1407">	is responsible to free.</a>
<a name="ln1408"> </a>
<a name="ln1409">	\param vnode The vnode whose covered node shall be returned.</a>
<a name="ln1410">	\return The covered vnode, or \c NULL if the given vnode doesn't cover any</a>
<a name="ln1411">		vnode.</a>
<a name="ln1412">*/</a>
<a name="ln1413">static inline Vnode*</a>
<a name="ln1414">get_covered_vnode(Vnode* vnode)</a>
<a name="ln1415">{</a>
<a name="ln1416">	if (!vnode-&gt;IsCovering())</a>
<a name="ln1417">		return NULL;</a>
<a name="ln1418"> </a>
<a name="ln1419">	ReadLocker vnodeReadLocker(sVnodeLock);</a>
<a name="ln1420">	return get_covered_vnode_locked(vnode);</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423"> </a>
<a name="ln1424">/*!	Gets the vnode the given vnode is covered by.</a>
<a name="ln1425"> </a>
<a name="ln1426">	The caller must have \c sVnodeLock read-locked at least.</a>
<a name="ln1427"> </a>
<a name="ln1428">	The function returns a reference to the retrieved vnode (if any), the caller</a>
<a name="ln1429">	is responsible to free.</a>
<a name="ln1430"> </a>
<a name="ln1431">	\param vnode The vnode whose covering node shall be returned.</a>
<a name="ln1432">	\return The covering vnode, or \c NULL if the given vnode isn't covered by</a>
<a name="ln1433">		any vnode.</a>
<a name="ln1434">*/</a>
<a name="ln1435">static Vnode*</a>
<a name="ln1436">get_covering_vnode_locked(Vnode* vnode)</a>
<a name="ln1437">{</a>
<a name="ln1438">	if (Vnode* coveringNode = vnode-&gt;covered_by) {</a>
<a name="ln1439">		while (coveringNode-&gt;covered_by != NULL)</a>
<a name="ln1440">			coveringNode = coveringNode-&gt;covered_by;</a>
<a name="ln1441"> </a>
<a name="ln1442">		inc_vnode_ref_count(coveringNode);</a>
<a name="ln1443">		return coveringNode;</a>
<a name="ln1444">	}</a>
<a name="ln1445"> </a>
<a name="ln1446">	return NULL;</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449"> </a>
<a name="ln1450">/*!	Gets the vnode the given vnode is covered by.</a>
<a name="ln1451"> </a>
<a name="ln1452">	The caller must not hold \c sVnodeLock. Note that this implies a race</a>
<a name="ln1453">	condition, since the situation can change at any time.</a>
<a name="ln1454"> </a>
<a name="ln1455">	The function returns a reference to the retrieved vnode (if any), the caller</a>
<a name="ln1456">	is responsible to free.</a>
<a name="ln1457"> </a>
<a name="ln1458">	\param vnode The vnode whose covering node shall be returned.</a>
<a name="ln1459">	\return The covering vnode, or \c NULL if the given vnode isn't covered by</a>
<a name="ln1460">		any vnode.</a>
<a name="ln1461">*/</a>
<a name="ln1462">static inline Vnode*</a>
<a name="ln1463">get_covering_vnode(Vnode* vnode)</a>
<a name="ln1464">{</a>
<a name="ln1465">	if (!vnode-&gt;IsCovered())</a>
<a name="ln1466">		return NULL;</a>
<a name="ln1467"> </a>
<a name="ln1468">	ReadLocker vnodeReadLocker(sVnodeLock);</a>
<a name="ln1469">	return get_covering_vnode_locked(vnode);</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472"> </a>
<a name="ln1473">static void</a>
<a name="ln1474">free_unused_vnodes()</a>
<a name="ln1475">{</a>
<a name="ln1476">	free_unused_vnodes(</a>
<a name="ln1477">		low_resource_state(B_KERNEL_RESOURCE_PAGES | B_KERNEL_RESOURCE_MEMORY</a>
<a name="ln1478">			| B_KERNEL_RESOURCE_ADDRESS_SPACE));</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481"> </a>
<a name="ln1482">static void</a>
<a name="ln1483">vnode_low_resource_handler(void* /*data*/, uint32 resources, int32 level)</a>
<a name="ln1484">{</a>
<a name="ln1485">	TRACE((&quot;vnode_low_resource_handler(level = %&quot; B_PRId32 &quot;)\n&quot;, level));</a>
<a name="ln1486"> </a>
<a name="ln1487">	free_unused_vnodes(level);</a>
<a name="ln1488">}</a>
<a name="ln1489"> </a>
<a name="ln1490"> </a>
<a name="ln1491">static inline void</a>
<a name="ln1492">put_advisory_locking(struct advisory_locking* locking)</a>
<a name="ln1493">{</a>
<a name="ln1494">	release_sem(locking-&gt;lock);</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497"> </a>
<a name="ln1498">/*!	Returns the advisory_locking object of the \a vnode in case it</a>
<a name="ln1499">	has one, and locks it.</a>
<a name="ln1500">	You have to call put_advisory_locking() when you're done with</a>
<a name="ln1501">	it.</a>
<a name="ln1502">	Note, you must not have the vnode mutex locked when calling</a>
<a name="ln1503">	this function.</a>
<a name="ln1504">*/</a>
<a name="ln1505">static struct advisory_locking*</a>
<a name="ln1506">get_advisory_locking(struct vnode* vnode)</a>
<a name="ln1507">{</a>
<a name="ln1508">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln1509">	vnode-&gt;Lock();</a>
<a name="ln1510"> </a>
<a name="ln1511">	struct advisory_locking* locking = vnode-&gt;advisory_locking;</a>
<a name="ln1512">	sem_id lock = locking != NULL ? locking-&gt;lock : B_ERROR;</a>
<a name="ln1513"> </a>
<a name="ln1514">	vnode-&gt;Unlock();</a>
<a name="ln1515">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln1516"> </a>
<a name="ln1517">	if (lock &gt;= 0)</a>
<a name="ln1518">		lock = acquire_sem(lock);</a>
<a name="ln1519">	if (lock &lt; 0) {</a>
<a name="ln1520">		// This means the locking has been deleted in the mean time</a>
<a name="ln1521">		// or had never existed in the first place - otherwise, we</a>
<a name="ln1522">		// would get the lock at some point.</a>
<a name="ln1523">		return NULL;</a>
<a name="ln1524">	}</a>
<a name="ln1525"> </a>
<a name="ln1526">	return locking;</a>
<a name="ln1527">}</a>
<a name="ln1528"> </a>
<a name="ln1529"> </a>
<a name="ln1530">/*!	Creates a locked advisory_locking object, and attaches it to the</a>
<a name="ln1531">	given \a vnode.</a>
<a name="ln1532">	Returns B_OK in case of success - also if the vnode got such an</a>
<a name="ln1533">	object from someone else in the mean time, you'll still get this</a>
<a name="ln1534">	one locked then.</a>
<a name="ln1535">*/</a>
<a name="ln1536">static status_t</a>
<a name="ln1537">create_advisory_locking(struct vnode* vnode)</a>
<a name="ln1538">{</a>
<a name="ln1539">	if (vnode == NULL)</a>
<a name="ln1540">		return B_FILE_ERROR;</a>
<a name="ln1541"> </a>
<a name="ln1542">	ObjectDeleter&lt;advisory_locking&gt; lockingDeleter;</a>
<a name="ln1543">	struct advisory_locking* locking = NULL;</a>
<a name="ln1544"> </a>
<a name="ln1545">	while (get_advisory_locking(vnode) == NULL) {</a>
<a name="ln1546">		// no locking object set on the vnode yet, create one</a>
<a name="ln1547">		if (locking == NULL) {</a>
<a name="ln1548">			locking = new(std::nothrow) advisory_locking;</a>
<a name="ln1549">			if (locking == NULL)</a>
<a name="ln1550">				return B_NO_MEMORY;</a>
<a name="ln1551">			lockingDeleter.SetTo(locking);</a>
<a name="ln1552"> </a>
<a name="ln1553">			locking-&gt;wait_sem = create_sem(0, &quot;advisory lock&quot;);</a>
<a name="ln1554">			if (locking-&gt;wait_sem &lt; 0)</a>
<a name="ln1555">				return locking-&gt;wait_sem;</a>
<a name="ln1556"> </a>
<a name="ln1557">			locking-&gt;lock = create_sem(0, &quot;advisory locking&quot;);</a>
<a name="ln1558">			if (locking-&gt;lock &lt; 0)</a>
<a name="ln1559">				return locking-&gt;lock;</a>
<a name="ln1560">		}</a>
<a name="ln1561"> </a>
<a name="ln1562">		// set our newly created locking object</a>
<a name="ln1563">		ReadLocker _(sVnodeLock);</a>
<a name="ln1564">		AutoLocker&lt;Vnode&gt; nodeLocker(vnode);</a>
<a name="ln1565">		if (vnode-&gt;advisory_locking == NULL) {</a>
<a name="ln1566">			vnode-&gt;advisory_locking = locking;</a>
<a name="ln1567">			lockingDeleter.Detach();</a>
<a name="ln1568">			return B_OK;</a>
<a name="ln1569">		}</a>
<a name="ln1570">	}</a>
<a name="ln1571"> </a>
<a name="ln1572">	// The vnode already had a locking object. That's just as well.</a>
<a name="ln1573"> </a>
<a name="ln1574">	return B_OK;</a>
<a name="ln1575">}</a>
<a name="ln1576"> </a>
<a name="ln1577"> </a>
<a name="ln1578">/*! Returns \c true when either \a flock is \c NULL or the \a flock intersects</a>
<a name="ln1579">	with the advisory_lock \a lock.</a>
<a name="ln1580">*/</a>
<a name="ln1581">static bool</a>
<a name="ln1582">advisory_lock_intersects(struct advisory_lock* lock, struct flock* flock)</a>
<a name="ln1583">{</a>
<a name="ln1584">	if (flock == NULL)</a>
<a name="ln1585">		return true;</a>
<a name="ln1586"> </a>
<a name="ln1587">	return lock-&gt;start &lt;= flock-&gt;l_start - 1 + flock-&gt;l_len</a>
<a name="ln1588">		&amp;&amp; lock-&gt;end &gt;= flock-&gt;l_start;</a>
<a name="ln1589">}</a>
<a name="ln1590"> </a>
<a name="ln1591"> </a>
<a name="ln1592">/*!	Tests whether acquiring a lock would block.</a>
<a name="ln1593">*/</a>
<a name="ln1594">static status_t</a>
<a name="ln1595">test_advisory_lock(struct vnode* vnode, struct flock* flock)</a>
<a name="ln1596">{</a>
<a name="ln1597">	flock-&gt;l_type = F_UNLCK;</a>
<a name="ln1598"> </a>
<a name="ln1599">	struct advisory_locking* locking = get_advisory_locking(vnode);</a>
<a name="ln1600">	if (locking == NULL)</a>
<a name="ln1601">		return B_OK;</a>
<a name="ln1602"> </a>
<a name="ln1603">	team_id team = team_get_current_team_id();</a>
<a name="ln1604"> </a>
<a name="ln1605">	LockList::Iterator iterator = locking-&gt;locks.GetIterator();</a>
<a name="ln1606">	while (iterator.HasNext()) {</a>
<a name="ln1607">		struct advisory_lock* lock = iterator.Next();</a>
<a name="ln1608"> </a>
<a name="ln1609">		 if (lock-&gt;team != team &amp;&amp; advisory_lock_intersects(lock, flock)) {</a>
<a name="ln1610">			// locks do overlap</a>
<a name="ln1611">			if (flock-&gt;l_type != F_RDLCK || !lock-&gt;shared) {</a>
<a name="ln1612">				// collision</a>
<a name="ln1613">				flock-&gt;l_type = lock-&gt;shared ? F_RDLCK : F_WRLCK;</a>
<a name="ln1614">				flock-&gt;l_whence = SEEK_SET;</a>
<a name="ln1615">				flock-&gt;l_start = lock-&gt;start;</a>
<a name="ln1616">				flock-&gt;l_len = lock-&gt;end - lock-&gt;start + 1;</a>
<a name="ln1617">				flock-&gt;l_pid = lock-&gt;team;</a>
<a name="ln1618">				break;</a>
<a name="ln1619">			}</a>
<a name="ln1620">		}</a>
<a name="ln1621">	}</a>
<a name="ln1622"> </a>
<a name="ln1623">	put_advisory_locking(locking);</a>
<a name="ln1624">	return B_OK;</a>
<a name="ln1625">}</a>
<a name="ln1626"> </a>
<a name="ln1627"> </a>
<a name="ln1628">/*!	Removes the specified lock, or all locks of the calling team</a>
<a name="ln1629">	if \a flock is NULL.</a>
<a name="ln1630">*/</a>
<a name="ln1631">static status_t</a>
<a name="ln1632">release_advisory_lock(struct vnode* vnode, struct io_context* context,</a>
<a name="ln1633">	struct file_descriptor* descriptor, struct flock* flock)</a>
<a name="ln1634">{</a>
<a name="ln1635">	FUNCTION((&quot;release_advisory_lock(vnode = %p, flock = %p)\n&quot;, vnode, flock));</a>
<a name="ln1636"> </a>
<a name="ln1637">	struct advisory_locking* locking = get_advisory_locking(vnode);</a>
<a name="ln1638">	if (locking == NULL)</a>
<a name="ln1639">		return B_OK;</a>
<a name="ln1640"> </a>
<a name="ln1641">	// find matching lock entries</a>
<a name="ln1642"> </a>
<a name="ln1643">	LockList::Iterator iterator = locking-&gt;locks.GetIterator();</a>
<a name="ln1644">	while (iterator.HasNext()) {</a>
<a name="ln1645">		struct advisory_lock* lock = iterator.Next();</a>
<a name="ln1646">		bool removeLock = false;</a>
<a name="ln1647"> </a>
<a name="ln1648">		if (descriptor != NULL &amp;&amp; lock-&gt;bound_to == descriptor) {</a>
<a name="ln1649">			// Remove flock() locks</a>
<a name="ln1650">			removeLock = true;</a>
<a name="ln1651">		} else if (lock-&gt;bound_to == context</a>
<a name="ln1652">				&amp;&amp; advisory_lock_intersects(lock, flock)) {</a>
<a name="ln1653">			// Remove POSIX locks</a>
<a name="ln1654">			bool endsBeyond = false;</a>
<a name="ln1655">			bool startsBefore = false;</a>
<a name="ln1656">			if (flock != NULL) {</a>
<a name="ln1657">				startsBefore = lock-&gt;start &lt; flock-&gt;l_start;</a>
<a name="ln1658">				endsBeyond = lock-&gt;end &gt; flock-&gt;l_start - 1 + flock-&gt;l_len;</a>
<a name="ln1659">			}</a>
<a name="ln1660"> </a>
<a name="ln1661">			if (!startsBefore &amp;&amp; !endsBeyond) {</a>
<a name="ln1662">				// lock is completely contained in flock</a>
<a name="ln1663">				removeLock = true;</a>
<a name="ln1664">			} else if (startsBefore &amp;&amp; !endsBeyond) {</a>
<a name="ln1665">				// cut the end of the lock</a>
<a name="ln1666">				lock-&gt;end = flock-&gt;l_start - 1;</a>
<a name="ln1667">			} else if (!startsBefore &amp;&amp; endsBeyond) {</a>
<a name="ln1668">				// cut the start of the lock</a>
<a name="ln1669">				lock-&gt;start = flock-&gt;l_start + flock-&gt;l_len;</a>
<a name="ln1670">			} else {</a>
<a name="ln1671">				// divide the lock into two locks</a>
<a name="ln1672">				struct advisory_lock* secondLock = new advisory_lock;</a>
<a name="ln1673">				if (secondLock == NULL) {</a>
<a name="ln1674">					// TODO: we should probably revert the locks we already</a>
<a name="ln1675">					// changed... (ie. allocate upfront)</a>
<a name="ln1676">					put_advisory_locking(locking);</a>
<a name="ln1677">					return B_NO_MEMORY;</a>
<a name="ln1678">				}</a>
<a name="ln1679"> </a>
<a name="ln1680">				lock-&gt;end = flock-&gt;l_start - 1;</a>
<a name="ln1681"> </a>
<a name="ln1682">				secondLock-&gt;bound_to = context;</a>
<a name="ln1683">				secondLock-&gt;team = lock-&gt;team;</a>
<a name="ln1684">				secondLock-&gt;session = lock-&gt;session;</a>
<a name="ln1685">				// values must already be normalized when getting here</a>
<a name="ln1686">				secondLock-&gt;start = flock-&gt;l_start + flock-&gt;l_len;</a>
<a name="ln1687">				secondLock-&gt;end = lock-&gt;end;</a>
<a name="ln1688">				secondLock-&gt;shared = lock-&gt;shared;</a>
<a name="ln1689"> </a>
<a name="ln1690">				locking-&gt;locks.Add(secondLock);</a>
<a name="ln1691">			}</a>
<a name="ln1692">		}</a>
<a name="ln1693"> </a>
<a name="ln1694">		if (removeLock) {</a>
<a name="ln1695">			// this lock is no longer used</a>
<a name="ln1696">			iterator.Remove();</a>
<a name="ln1697">			free(lock);</a>
<a name="ln1698">		}</a>
<a name="ln1699">	}</a>
<a name="ln1700"> </a>
<a name="ln1701">	bool removeLocking = locking-&gt;locks.IsEmpty();</a>
<a name="ln1702">	release_sem_etc(locking-&gt;wait_sem, 1, B_RELEASE_ALL);</a>
<a name="ln1703"> </a>
<a name="ln1704">	put_advisory_locking(locking);</a>
<a name="ln1705"> </a>
<a name="ln1706">	if (removeLocking) {</a>
<a name="ln1707">		// We can remove the whole advisory locking structure; it's no</a>
<a name="ln1708">		// longer used</a>
<a name="ln1709">		locking = get_advisory_locking(vnode);</a>
<a name="ln1710">		if (locking != NULL) {</a>
<a name="ln1711">			ReadLocker locker(sVnodeLock);</a>
<a name="ln1712">			AutoLocker&lt;Vnode&gt; nodeLocker(vnode);</a>
<a name="ln1713"> </a>
<a name="ln1714">			// the locking could have been changed in the mean time</a>
<a name="ln1715">			if (locking-&gt;locks.IsEmpty()) {</a>
<a name="ln1716">				vnode-&gt;advisory_locking = NULL;</a>
<a name="ln1717">				nodeLocker.Unlock();</a>
<a name="ln1718">				locker.Unlock();</a>
<a name="ln1719"> </a>
<a name="ln1720">				// we've detached the locking from the vnode, so we can</a>
<a name="ln1721">				// safely delete it</a>
<a name="ln1722">				delete locking;</a>
<a name="ln1723">			} else {</a>
<a name="ln1724">				// the locking is in use again</a>
<a name="ln1725">				nodeLocker.Unlock();</a>
<a name="ln1726">				locker.Unlock();</a>
<a name="ln1727">				release_sem_etc(locking-&gt;lock, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln1728">			}</a>
<a name="ln1729">		}</a>
<a name="ln1730">	}</a>
<a name="ln1731"> </a>
<a name="ln1732">	return B_OK;</a>
<a name="ln1733">}</a>
<a name="ln1734"> </a>
<a name="ln1735"> </a>
<a name="ln1736">/*!	Acquires an advisory lock for the \a vnode. If \a wait is \c true, it</a>
<a name="ln1737">	will wait for the lock to become available, if there are any collisions</a>
<a name="ln1738">	(it will return B_PERMISSION_DENIED in this case if \a wait is \c false).</a>
<a name="ln1739"> </a>
<a name="ln1740">	If \a descriptor is NULL, POSIX semantics are used for this lock. Otherwise,</a>
<a name="ln1741">	BSD flock() semantics are used, that is, all children can unlock the file</a>
<a name="ln1742">	in question (we even allow parents to remove the lock, though, but that</a>
<a name="ln1743">	seems to be in line to what the BSD's are doing).</a>
<a name="ln1744">*/</a>
<a name="ln1745">static status_t</a>
<a name="ln1746">acquire_advisory_lock(struct vnode* vnode, io_context* context,</a>
<a name="ln1747">	struct file_descriptor* descriptor, struct flock* flock, bool wait)</a>
<a name="ln1748">{</a>
<a name="ln1749">	FUNCTION((&quot;acquire_advisory_lock(vnode = %p, flock = %p, wait = %s)\n&quot;,</a>
<a name="ln1750">		vnode, flock, wait ? &quot;yes&quot; : &quot;no&quot;));</a>
<a name="ln1751">	dprintf(&quot;acquire_advisory_lock(vnode = %p, flock = %p, wait = %s)\n&quot;,</a>
<a name="ln1752">		vnode, flock, wait ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln1753"> </a>
<a name="ln1754">	bool shared = flock-&gt;l_type == F_RDLCK;</a>
<a name="ln1755">	void* boundTo = descriptor != NULL ? (void*)descriptor : (void*)context;</a>
<a name="ln1756">	status_t status = B_OK;</a>
<a name="ln1757"> </a>
<a name="ln1758">	// TODO: do deadlock detection!</a>
<a name="ln1759"> </a>
<a name="ln1760">	struct advisory_locking* locking;</a>
<a name="ln1761"> </a>
<a name="ln1762">	while (true) {</a>
<a name="ln1763">		// if this vnode has an advisory_locking structure attached,</a>
<a name="ln1764">		// lock that one and search for any colliding file lock</a>
<a name="ln1765">		status = create_advisory_locking(vnode);</a>
<a name="ln1766">		if (status != B_OK)</a>
<a name="ln1767">			return status;</a>
<a name="ln1768"> </a>
<a name="ln1769">		locking = vnode-&gt;advisory_locking;</a>
<a name="ln1770">		team_id team = team_get_current_team_id();</a>
<a name="ln1771">		sem_id waitForLock = -1;</a>
<a name="ln1772"> </a>
<a name="ln1773">		// test for collisions</a>
<a name="ln1774">		LockList::Iterator iterator = locking-&gt;locks.GetIterator();</a>
<a name="ln1775">		while (iterator.HasNext()) {</a>
<a name="ln1776">			struct advisory_lock* lock = iterator.Next();</a>
<a name="ln1777"> </a>
<a name="ln1778">			// TODO: locks from the same team might be joinable!</a>
<a name="ln1779">			if ((lock-&gt;team != team || lock-&gt;bound_to != boundTo)</a>
<a name="ln1780">					&amp;&amp; advisory_lock_intersects(lock, flock)) {</a>
<a name="ln1781">				// locks do overlap</a>
<a name="ln1782">				if (!shared || !lock-&gt;shared) {</a>
<a name="ln1783">					// we need to wait</a>
<a name="ln1784">					waitForLock = locking-&gt;wait_sem;</a>
<a name="ln1785">					break;</a>
<a name="ln1786">				}</a>
<a name="ln1787">			}</a>
<a name="ln1788">		}</a>
<a name="ln1789"> </a>
<a name="ln1790">		if (waitForLock &lt; 0)</a>
<a name="ln1791">			break;</a>
<a name="ln1792"> </a>
<a name="ln1793">		// We need to wait. Do that or fail now, if we've been asked not to.</a>
<a name="ln1794"> </a>
<a name="ln1795">		if (!wait) {</a>
<a name="ln1796">			put_advisory_locking(locking);</a>
<a name="ln1797">			return descriptor != NULL ? B_WOULD_BLOCK : B_PERMISSION_DENIED;</a>
<a name="ln1798">		}</a>
<a name="ln1799"> </a>
<a name="ln1800">		status = switch_sem_etc(locking-&gt;lock, waitForLock, 1,</a>
<a name="ln1801">			B_CAN_INTERRUPT, 0);</a>
<a name="ln1802">		if (status != B_OK &amp;&amp; status != B_BAD_SEM_ID)</a>
<a name="ln1803">			return status;</a>
<a name="ln1804"> </a>
<a name="ln1805">		// We have been notified, but we need to re-lock the locking object. So</a>
<a name="ln1806">		// go another round...</a>
<a name="ln1807">	}</a>
<a name="ln1808"> </a>
<a name="ln1809">	// install new lock</a>
<a name="ln1810"> </a>
<a name="ln1811">	struct advisory_lock* lock = (struct advisory_lock*)malloc(</a>
<a name="ln1812">		sizeof(struct advisory_lock));</a>
<a name="ln1813">	if (lock == NULL) {</a>
<a name="ln1814">		put_advisory_locking(locking);</a>
<a name="ln1815">		return B_NO_MEMORY;</a>
<a name="ln1816">	}</a>
<a name="ln1817"> </a>
<a name="ln1818">	lock-&gt;bound_to = boundTo;</a>
<a name="ln1819">	lock-&gt;team = team_get_current_team_id();</a>
<a name="ln1820">	lock-&gt;session = thread_get_current_thread()-&gt;team-&gt;session_id;</a>
<a name="ln1821">	// values must already be normalized when getting here</a>
<a name="ln1822">	lock-&gt;start = flock-&gt;l_start;</a>
<a name="ln1823">	lock-&gt;end = flock-&gt;l_start - 1 + flock-&gt;l_len;</a>
<a name="ln1824">	lock-&gt;shared = shared;</a>
<a name="ln1825"> </a>
<a name="ln1826">	locking-&gt;locks.Add(lock);</a>
<a name="ln1827">	put_advisory_locking(locking);</a>
<a name="ln1828"> </a>
<a name="ln1829">	return status;</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832"> </a>
<a name="ln1833">/*!	Normalizes the \a flock structure to make it easier to compare the</a>
<a name="ln1834">	structure with others. The l_start and l_len fields are set to absolute</a>
<a name="ln1835">	values according to the l_whence field.</a>
<a name="ln1836">*/</a>
<a name="ln1837">static status_t</a>
<a name="ln1838">normalize_flock(struct file_descriptor* descriptor, struct flock* flock)</a>
<a name="ln1839">{</a>
<a name="ln1840">	switch (flock-&gt;l_whence) {</a>
<a name="ln1841">		case SEEK_SET:</a>
<a name="ln1842">			break;</a>
<a name="ln1843">		case SEEK_CUR:</a>
<a name="ln1844">			flock-&gt;l_start += descriptor-&gt;pos;</a>
<a name="ln1845">			break;</a>
<a name="ln1846">		case SEEK_END:</a>
<a name="ln1847">		{</a>
<a name="ln1848">			struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln1849">			struct stat stat;</a>
<a name="ln1850">			status_t status;</a>
<a name="ln1851"> </a>
<a name="ln1852">			if (!HAS_FS_CALL(vnode, read_stat))</a>
<a name="ln1853">				return B_UNSUPPORTED;</a>
<a name="ln1854"> </a>
<a name="ln1855">			status = FS_CALL(vnode, read_stat, &amp;stat);</a>
<a name="ln1856">			if (status != B_OK)</a>
<a name="ln1857">				return status;</a>
<a name="ln1858"> </a>
<a name="ln1859">			flock-&gt;l_start += stat.st_size;</a>
<a name="ln1860">			break;</a>
<a name="ln1861">		}</a>
<a name="ln1862">		default:</a>
<a name="ln1863">			return B_BAD_VALUE;</a>
<a name="ln1864">	}</a>
<a name="ln1865"> </a>
<a name="ln1866">	if (flock-&gt;l_start &lt; 0)</a>
<a name="ln1867">		flock-&gt;l_start = 0;</a>
<a name="ln1868">	if (flock-&gt;l_len == 0)</a>
<a name="ln1869">		flock-&gt;l_len = OFF_MAX;</a>
<a name="ln1870"> </a>
<a name="ln1871">	// don't let the offset and length overflow</a>
<a name="ln1872">	if (flock-&gt;l_start &gt; 0 &amp;&amp; OFF_MAX - flock-&gt;l_start &lt; flock-&gt;l_len)</a>
<a name="ln1873">		flock-&gt;l_len = OFF_MAX - flock-&gt;l_start;</a>
<a name="ln1874"> </a>
<a name="ln1875">	if (flock-&gt;l_len &lt; 0) {</a>
<a name="ln1876">		// a negative length reverses the region</a>
<a name="ln1877">		flock-&gt;l_start += flock-&gt;l_len;</a>
<a name="ln1878">		flock-&gt;l_len = -flock-&gt;l_len;</a>
<a name="ln1879">	}</a>
<a name="ln1880"> </a>
<a name="ln1881">	return B_OK;</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884"> </a>
<a name="ln1885">static void</a>
<a name="ln1886">replace_vnode_if_disconnected(struct fs_mount* mount,</a>
<a name="ln1887">	struct vnode* vnodeToDisconnect, struct vnode*&amp; vnode,</a>
<a name="ln1888">	struct vnode* fallBack, bool lockRootLock)</a>
<a name="ln1889">{</a>
<a name="ln1890">	struct vnode* givenVnode = vnode;</a>
<a name="ln1891">	bool vnodeReplaced = false;</a>
<a name="ln1892"> </a>
<a name="ln1893">	ReadLocker vnodeReadLocker(sVnodeLock);</a>
<a name="ln1894"> </a>
<a name="ln1895">	if (lockRootLock)</a>
<a name="ln1896">		mutex_lock(&amp;sIOContextRootLock);</a>
<a name="ln1897"> </a>
<a name="ln1898">	while (vnode != NULL &amp;&amp; vnode-&gt;mount == mount</a>
<a name="ln1899">		&amp;&amp; (vnodeToDisconnect == NULL || vnodeToDisconnect == vnode)) {</a>
<a name="ln1900">		if (vnode-&gt;covers != NULL) {</a>
<a name="ln1901">			// redirect the vnode to the covered vnode</a>
<a name="ln1902">			vnode = vnode-&gt;covers;</a>
<a name="ln1903">		} else</a>
<a name="ln1904">			vnode = fallBack;</a>
<a name="ln1905"> </a>
<a name="ln1906">		vnodeReplaced = true;</a>
<a name="ln1907">	}</a>
<a name="ln1908"> </a>
<a name="ln1909">	// If we've replaced the node, grab a reference for the new one.</a>
<a name="ln1910">	if (vnodeReplaced &amp;&amp; vnode != NULL)</a>
<a name="ln1911">		inc_vnode_ref_count(vnode);</a>
<a name="ln1912"> </a>
<a name="ln1913">	if (lockRootLock)</a>
<a name="ln1914">		mutex_unlock(&amp;sIOContextRootLock);</a>
<a name="ln1915"> </a>
<a name="ln1916">	vnodeReadLocker.Unlock();</a>
<a name="ln1917"> </a>
<a name="ln1918">	if (vnodeReplaced)</a>
<a name="ln1919">		put_vnode(givenVnode);</a>
<a name="ln1920">}</a>
<a name="ln1921"> </a>
<a name="ln1922"> </a>
<a name="ln1923">/*!	Disconnects all file descriptors that are associated with the</a>
<a name="ln1924">	\a vnodeToDisconnect, or if this is NULL, all vnodes of the specified</a>
<a name="ln1925">	\a mount object.</a>
<a name="ln1926"> </a>
<a name="ln1927">	Note, after you've called this function, there might still be ongoing</a>
<a name="ln1928">	accesses - they won't be interrupted if they already happened before.</a>
<a name="ln1929">	However, any subsequent access will fail.</a>
<a name="ln1930"> </a>
<a name="ln1931">	This is not a cheap function and should be used with care and rarely.</a>
<a name="ln1932">	TODO: there is currently no means to stop a blocking read/write!</a>
<a name="ln1933">*/</a>
<a name="ln1934">static void</a>
<a name="ln1935">disconnect_mount_or_vnode_fds(struct fs_mount* mount,</a>
<a name="ln1936">	struct vnode* vnodeToDisconnect)</a>
<a name="ln1937">{</a>
<a name="ln1938">	// iterate over all teams and peek into their file descriptors</a>
<a name="ln1939">	TeamListIterator teamIterator;</a>
<a name="ln1940">	while (Team* team = teamIterator.Next()) {</a>
<a name="ln1941">		BReference&lt;Team&gt; teamReference(team, true);</a>
<a name="ln1942">		TeamLocker teamLocker(team);</a>
<a name="ln1943"> </a>
<a name="ln1944">		// lock the I/O context</a>
<a name="ln1945">		io_context* context = team-&gt;io_context;</a>
<a name="ln1946">		if (context == NULL)</a>
<a name="ln1947">			continue;</a>
<a name="ln1948">		MutexLocker contextLocker(context-&gt;io_mutex);</a>
<a name="ln1949"> </a>
<a name="ln1950">		teamLocker.Unlock();</a>
<a name="ln1951"> </a>
<a name="ln1952">		replace_vnode_if_disconnected(mount, vnodeToDisconnect, context-&gt;root,</a>
<a name="ln1953">			sRoot, true);</a>
<a name="ln1954">		replace_vnode_if_disconnected(mount, vnodeToDisconnect, context-&gt;cwd,</a>
<a name="ln1955">			sRoot, false);</a>
<a name="ln1956"> </a>
<a name="ln1957">		for (uint32 i = 0; i &lt; context-&gt;table_size; i++) {</a>
<a name="ln1958">			struct file_descriptor* descriptor = context-&gt;fds[i];</a>
<a name="ln1959">			if (descriptor == NULL || (descriptor-&gt;open_mode &amp; O_DISCONNECTED) != 0)</a>
<a name="ln1960">				continue;</a>
<a name="ln1961"> </a>
<a name="ln1962">			inc_fd_ref_count(descriptor);</a>
<a name="ln1963"> </a>
<a name="ln1964">			// if this descriptor points at this mount, we</a>
<a name="ln1965">			// need to disconnect it to be able to unmount</a>
<a name="ln1966">			struct vnode* vnode = fd_vnode(descriptor);</a>
<a name="ln1967">			if (vnodeToDisconnect != NULL) {</a>
<a name="ln1968">				if (vnode == vnodeToDisconnect)</a>
<a name="ln1969">					disconnect_fd(descriptor);</a>
<a name="ln1970">			} else if ((vnode != NULL &amp;&amp; vnode-&gt;mount == mount)</a>
<a name="ln1971">				|| (vnode == NULL &amp;&amp; descriptor-&gt;u.mount == mount))</a>
<a name="ln1972">				disconnect_fd(descriptor);</a>
<a name="ln1973"> </a>
<a name="ln1974">			put_fd(descriptor);</a>
<a name="ln1975">		}</a>
<a name="ln1976">	}</a>
<a name="ln1977">}</a>
<a name="ln1978"> </a>
<a name="ln1979"> </a>
<a name="ln1980">/*!	\brief Gets the root node of the current IO context.</a>
<a name="ln1981">	If \a kernel is \c true, the kernel IO context will be used.</a>
<a name="ln1982">	The caller obtains a reference to the returned node.</a>
<a name="ln1983">*/</a>
<a name="ln1984">struct vnode*</a>
<a name="ln1985">get_root_vnode(bool kernel)</a>
<a name="ln1986">{</a>
<a name="ln1987">	if (!kernel) {</a>
<a name="ln1988">		// Get current working directory from io context</a>
<a name="ln1989">		struct io_context* context = get_current_io_context(kernel);</a>
<a name="ln1990"> </a>
<a name="ln1991">		mutex_lock(&amp;sIOContextRootLock);</a>
<a name="ln1992"> </a>
<a name="ln1993">		struct vnode* root = context-&gt;root;</a>
<a name="ln1994">		if (root != NULL)</a>
<a name="ln1995">			inc_vnode_ref_count(root);</a>
<a name="ln1996"> </a>
<a name="ln1997">		mutex_unlock(&amp;sIOContextRootLock);</a>
<a name="ln1998"> </a>
<a name="ln1999">		if (root != NULL)</a>
<a name="ln2000">			return root;</a>
<a name="ln2001"> </a>
<a name="ln2002">		// That should never happen.</a>
<a name="ln2003">		dprintf(&quot;get_root_vnode(): IO context for team %&quot; B_PRId32 &quot; doesn't &quot;</a>
<a name="ln2004">			&quot;have a root\n&quot;, team_get_current_team_id());</a>
<a name="ln2005">	}</a>
<a name="ln2006"> </a>
<a name="ln2007">	inc_vnode_ref_count(sRoot);</a>
<a name="ln2008">	return sRoot;</a>
<a name="ln2009">}</a>
<a name="ln2010"> </a>
<a name="ln2011"> </a>
<a name="ln2012">/*!	\brief Gets the directory path and leaf name for a given path.</a>
<a name="ln2013"> </a>
<a name="ln2014">	The supplied \a path is transformed to refer to the directory part of</a>
<a name="ln2015">	the entry identified by the original path, and into the buffer \a filename</a>
<a name="ln2016">	the leaf name of the original entry is written.</a>
<a name="ln2017">	Neither the returned path nor the leaf name can be expected to be</a>
<a name="ln2018">	canonical.</a>
<a name="ln2019"> </a>
<a name="ln2020">	\param path The path to be analyzed. Must be able to store at least one</a>
<a name="ln2021">		   additional character.</a>
<a name="ln2022">	\param filename The buffer into which the leaf name will be written.</a>
<a name="ln2023">		   Must be of size B_FILE_NAME_LENGTH at least.</a>
<a name="ln2024">	\return \c B_OK, if everything went fine, \c B_NAME_TOO_LONG, if the leaf</a>
<a name="ln2025">		   name is longer than \c B_FILE_NAME_LENGTH, or \c B_ENTRY_NOT_FOUND,</a>
<a name="ln2026">		   if the given path name is empty.</a>
<a name="ln2027">*/</a>
<a name="ln2028">static status_t</a>
<a name="ln2029">get_dir_path_and_leaf(char* path, char* filename)</a>
<a name="ln2030">{</a>
<a name="ln2031">	if (*path == '\0')</a>
<a name="ln2032">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2033"> </a>
<a name="ln2034">	char* last = strrchr(path, '/');</a>
<a name="ln2035">		// '/' are not allowed in file names!</a>
<a name="ln2036"> </a>
<a name="ln2037">	FUNCTION((&quot;get_dir_path_and_leaf(path = %s)\n&quot;, path));</a>
<a name="ln2038"> </a>
<a name="ln2039">	if (last == NULL) {</a>
<a name="ln2040">		// this path is single segment with no '/' in it</a>
<a name="ln2041">		// ex. &quot;foo&quot;</a>
<a name="ln2042">		if (strlcpy(filename, path, B_FILE_NAME_LENGTH) &gt;= B_FILE_NAME_LENGTH)</a>
<a name="ln2043">			return B_NAME_TOO_LONG;</a>
<a name="ln2044"> </a>
<a name="ln2045">		strcpy(path, &quot;.&quot;);</a>
<a name="ln2046">	} else {</a>
<a name="ln2047">		last++;</a>
<a name="ln2048">		if (last[0] == '\0') {</a>
<a name="ln2049">			// special case: the path ends in one or more '/' - remove them</a>
<a name="ln2050">			while (*--last == '/' &amp;&amp; last != path);</a>
<a name="ln2051">			last[1] = '\0';</a>
<a name="ln2052"> </a>
<a name="ln2053">			if (last == path &amp;&amp; last[0] == '/') {</a>
<a name="ln2054">				// This path points to the root of the file system</a>
<a name="ln2055">				strcpy(filename, &quot;.&quot;);</a>
<a name="ln2056">				return B_OK;</a>
<a name="ln2057">			}</a>
<a name="ln2058">			for (; last != path &amp;&amp; *(last - 1) != '/'; last--);</a>
<a name="ln2059">				// rewind to the start of the leaf before the '/'</a>
<a name="ln2060">		}</a>
<a name="ln2061"> </a>
<a name="ln2062">		// normal leaf: replace the leaf portion of the path with a '.'</a>
<a name="ln2063">		if (strlcpy(filename, last, B_FILE_NAME_LENGTH) &gt;= B_FILE_NAME_LENGTH)</a>
<a name="ln2064">			return B_NAME_TOO_LONG;</a>
<a name="ln2065"> </a>
<a name="ln2066">		last[0] = '.';</a>
<a name="ln2067">		last[1] = '\0';</a>
<a name="ln2068">	}</a>
<a name="ln2069">	return B_OK;</a>
<a name="ln2070">}</a>
<a name="ln2071"> </a>
<a name="ln2072"> </a>
<a name="ln2073">static status_t</a>
<a name="ln2074">entry_ref_to_vnode(dev_t mountID, ino_t directoryID, const char* name,</a>
<a name="ln2075">	bool traverse, bool kernel, struct vnode** _vnode)</a>
<a name="ln2076">{</a>
<a name="ln2077">	char clonedName[B_FILE_NAME_LENGTH + 1];</a>
<a name="ln2078">	if (strlcpy(clonedName, name, B_FILE_NAME_LENGTH) &gt;= B_FILE_NAME_LENGTH)</a>
<a name="ln2079">		return B_NAME_TOO_LONG;</a>
<a name="ln2080"> </a>
<a name="ln2081">	// get the directory vnode and let vnode_path_to_vnode() do the rest</a>
<a name="ln2082">	struct vnode* directory;</a>
<a name="ln2083"> </a>
<a name="ln2084">	status_t status = get_vnode(mountID, directoryID, &amp;directory, true, false);</a>
<a name="ln2085">	if (status &lt; 0)</a>
<a name="ln2086">		return status;</a>
<a name="ln2087"> </a>
<a name="ln2088">	return vnode_path_to_vnode(directory, clonedName, traverse, 0, kernel,</a>
<a name="ln2089">		_vnode, NULL);</a>
<a name="ln2090">}</a>
<a name="ln2091"> </a>
<a name="ln2092"> </a>
<a name="ln2093">/*!	Looks up the entry with name \a name in the directory represented by \a dir</a>
<a name="ln2094">	and returns the respective vnode.</a>
<a name="ln2095">	On success a reference to the vnode is acquired for the caller.</a>
<a name="ln2096">*/</a>
<a name="ln2097">static status_t</a>
<a name="ln2098">lookup_dir_entry(struct vnode* dir, const char* name, struct vnode** _vnode)</a>
<a name="ln2099">{</a>
<a name="ln2100">	ino_t id;</a>
<a name="ln2101">	bool missing;</a>
<a name="ln2102"> </a>
<a name="ln2103">	if (dir-&gt;mount-&gt;entry_cache.Lookup(dir-&gt;id, name, id, missing)) {</a>
<a name="ln2104">		return missing ? B_ENTRY_NOT_FOUND</a>
<a name="ln2105">			: get_vnode(dir-&gt;device, id, _vnode, true, false);</a>
<a name="ln2106">	}</a>
<a name="ln2107"> </a>
<a name="ln2108">	status_t status = FS_CALL(dir, lookup, name, &amp;id);</a>
<a name="ln2109">	if (status != B_OK)</a>
<a name="ln2110">		return status;</a>
<a name="ln2111"> </a>
<a name="ln2112">	// The lookup() hook calls get_vnode() or publish_vnode(), so we do already</a>
<a name="ln2113">	// have a reference and just need to look the node up.</a>
<a name="ln2114">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln2115">	*_vnode = lookup_vnode(dir-&gt;device, id);</a>
<a name="ln2116">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln2117"> </a>
<a name="ln2118">	if (*_vnode == NULL) {</a>
<a name="ln2119">		panic(&quot;lookup_dir_entry(): could not lookup vnode (mountid 0x%&quot; B_PRIx32</a>
<a name="ln2120">			&quot; vnid 0x%&quot; B_PRIx64 &quot;)\n&quot;, dir-&gt;device, id);</a>
<a name="ln2121">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2122">	}</a>
<a name="ln2123"> </a>
<a name="ln2124">//	ktrace_printf(&quot;lookup_dir_entry(): dir: %p (%ld, %lld), name: \&quot;%s\&quot; -&gt; &quot;</a>
<a name="ln2125">//		&quot;%p (%ld, %lld)&quot;, dir, dir-&gt;mount-&gt;id, dir-&gt;id, name, *_vnode,</a>
<a name="ln2126">//		(*_vnode)-&gt;mount-&gt;id, (*_vnode)-&gt;id);</a>
<a name="ln2127"> </a>
<a name="ln2128">	return B_OK;</a>
<a name="ln2129">}</a>
<a name="ln2130"> </a>
<a name="ln2131"> </a>
<a name="ln2132">/*!	Returns the vnode for the relative path starting at the specified \a vnode.</a>
<a name="ln2133">	\a path must not be NULL.</a>
<a name="ln2134">	If it returns successfully, \a path contains the name of the last path</a>
<a name="ln2135">	component. This function clobbers the buffer pointed to by \a path only</a>
<a name="ln2136">	if it does contain more than one component.</a>
<a name="ln2137">	Note, this reduces the ref_count of the starting \a vnode, no matter if</a>
<a name="ln2138">	it is successful or not!</a>
<a name="ln2139">*/</a>
<a name="ln2140">static status_t</a>
<a name="ln2141">vnode_path_to_vnode(struct vnode* vnode, char* path, bool traverseLeafLink,</a>
<a name="ln2142">	int count, struct io_context* ioContext, struct vnode** _vnode,</a>
<a name="ln2143">	ino_t* _parentID)</a>
<a name="ln2144">{</a>
<a name="ln2145">	status_t status = B_OK;</a>
<a name="ln2146">	ino_t lastParentID = vnode-&gt;id;</a>
<a name="ln2147"> </a>
<a name="ln2148">	FUNCTION((&quot;vnode_path_to_vnode(vnode = %p, path = %s)\n&quot;, vnode, path));</a>
<a name="ln2149"> </a>
<a name="ln2150">	if (path == NULL) {</a>
<a name="ln2151">		put_vnode(vnode);</a>
<a name="ln2152">		return B_BAD_VALUE;</a>
<a name="ln2153">	}</a>
<a name="ln2154"> </a>
<a name="ln2155">	if (*path == '\0') {</a>
<a name="ln2156">		put_vnode(vnode);</a>
<a name="ln2157">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2158">	}</a>
<a name="ln2159"> </a>
<a name="ln2160">	while (true) {</a>
<a name="ln2161">		struct vnode* nextVnode;</a>
<a name="ln2162">		char* nextPath;</a>
<a name="ln2163"> </a>
<a name="ln2164">		TRACE((&quot;vnode_path_to_vnode: top of loop. p = %p, p = '%s'\n&quot;, path,</a>
<a name="ln2165">			path));</a>
<a name="ln2166"> </a>
<a name="ln2167">		// done?</a>
<a name="ln2168">		if (path[0] == '\0')</a>
<a name="ln2169">			break;</a>
<a name="ln2170"> </a>
<a name="ln2171">		// walk to find the next path component (&quot;path&quot; will point to a single</a>
<a name="ln2172">		// path component), and filter out multiple slashes</a>
<a name="ln2173">		for (nextPath = path + 1; *nextPath != '\0' &amp;&amp; *nextPath != '/';</a>
<a name="ln2174">				nextPath++);</a>
<a name="ln2175"> </a>
<a name="ln2176">		if (*nextPath == '/') {</a>
<a name="ln2177">			*nextPath = '\0';</a>
<a name="ln2178">			do</a>
<a name="ln2179">				nextPath++;</a>
<a name="ln2180">			while (*nextPath == '/');</a>
<a name="ln2181">		}</a>
<a name="ln2182"> </a>
<a name="ln2183">		// See if the '..' is at a covering vnode move to the covered</a>
<a name="ln2184">		// vnode so we pass the '..' path to the underlying filesystem.</a>
<a name="ln2185">		// Also prevent breaking the root of the IO context.</a>
<a name="ln2186">		if (strcmp(&quot;..&quot;, path) == 0) {</a>
<a name="ln2187">			if (vnode == ioContext-&gt;root) {</a>
<a name="ln2188">				// Attempted prison break! Keep it contained.</a>
<a name="ln2189">				path = nextPath;</a>
<a name="ln2190">				continue;</a>
<a name="ln2191">			}</a>
<a name="ln2192"> </a>
<a name="ln2193">			if (Vnode* coveredVnode = get_covered_vnode(vnode)) {</a>
<a name="ln2194">				nextVnode = coveredVnode;</a>
<a name="ln2195">				put_vnode(vnode);</a>
<a name="ln2196">				vnode = nextVnode;</a>
<a name="ln2197">			}</a>
<a name="ln2198">		}</a>
<a name="ln2199"> </a>
<a name="ln2200">		// check if vnode is really a directory</a>
<a name="ln2201">		if (status == B_OK &amp;&amp; !S_ISDIR(vnode-&gt;Type()))</a>
<a name="ln2202">			status = B_NOT_A_DIRECTORY;</a>
<a name="ln2203"> </a>
<a name="ln2204">		// Check if we have the right to search the current directory vnode.</a>
<a name="ln2205">		// If a file system doesn't have the access() function, we assume that</a>
<a name="ln2206">		// searching a directory is always allowed</a>
<a name="ln2207">		if (status == B_OK &amp;&amp; HAS_FS_CALL(vnode, access))</a>
<a name="ln2208">			status = FS_CALL(vnode, access, X_OK);</a>
<a name="ln2209"> </a>
<a name="ln2210">		// Tell the filesystem to get the vnode of this path component (if we</a>
<a name="ln2211">		// got the permission from the call above)</a>
<a name="ln2212">		if (status == B_OK)</a>
<a name="ln2213">			status = lookup_dir_entry(vnode, path, &amp;nextVnode);</a>
<a name="ln2214"> </a>
<a name="ln2215">		if (status != B_OK) {</a>
<a name="ln2216">			put_vnode(vnode);</a>
<a name="ln2217">			return status;</a>
<a name="ln2218">		}</a>
<a name="ln2219"> </a>
<a name="ln2220">		// If the new node is a symbolic link, resolve it (if we've been told</a>
<a name="ln2221">		// to do it)</a>
<a name="ln2222">		if (S_ISLNK(nextVnode-&gt;Type())</a>
<a name="ln2223">			&amp;&amp; (traverseLeafLink || nextPath[0] != '\0')) {</a>
<a name="ln2224">			size_t bufferSize;</a>
<a name="ln2225">			char* buffer;</a>
<a name="ln2226"> </a>
<a name="ln2227">			TRACE((&quot;traverse link\n&quot;));</a>
<a name="ln2228"> </a>
<a name="ln2229">			// it's not exactly nice style using goto in this way, but hey,</a>
<a name="ln2230">			// it works :-/</a>
<a name="ln2231">			if (count + 1 &gt; B_MAX_SYMLINKS) {</a>
<a name="ln2232">				status = B_LINK_LIMIT;</a>
<a name="ln2233">				goto resolve_link_error;</a>
<a name="ln2234">			}</a>
<a name="ln2235"> </a>
<a name="ln2236">			buffer = (char*)malloc(bufferSize = B_PATH_NAME_LENGTH);</a>
<a name="ln2237">			if (buffer == NULL) {</a>
<a name="ln2238">				status = B_NO_MEMORY;</a>
<a name="ln2239">				goto resolve_link_error;</a>
<a name="ln2240">			}</a>
<a name="ln2241"> </a>
<a name="ln2242">			if (HAS_FS_CALL(nextVnode, read_symlink)) {</a>
<a name="ln2243">				bufferSize--;</a>
<a name="ln2244">				status = FS_CALL(nextVnode, read_symlink, buffer, &amp;bufferSize);</a>
<a name="ln2245">				// null-terminate</a>
<a name="ln2246">				if (status &gt;= 0)</a>
<a name="ln2247">					buffer[bufferSize] = '\0';</a>
<a name="ln2248">			} else</a>
<a name="ln2249">				status = B_BAD_VALUE;</a>
<a name="ln2250"> </a>
<a name="ln2251">			if (status != B_OK) {</a>
<a name="ln2252">				free(buffer);</a>
<a name="ln2253"> </a>
<a name="ln2254">		resolve_link_error:</a>
<a name="ln2255">				put_vnode(vnode);</a>
<a name="ln2256">				put_vnode(nextVnode);</a>
<a name="ln2257"> </a>
<a name="ln2258">				return status;</a>
<a name="ln2259">			}</a>
<a name="ln2260">			put_vnode(nextVnode);</a>
<a name="ln2261"> </a>
<a name="ln2262">			// Check if we start from the root directory or the current</a>
<a name="ln2263">			// directory (&quot;vnode&quot; still points to that one).</a>
<a name="ln2264">			// Cut off all leading slashes if it's the root directory</a>
<a name="ln2265">			path = buffer;</a>
<a name="ln2266">			bool absoluteSymlink = false;</a>
<a name="ln2267">			if (path[0] == '/') {</a>
<a name="ln2268">				// we don't need the old directory anymore</a>
<a name="ln2269">				put_vnode(vnode);</a>
<a name="ln2270"> </a>
<a name="ln2271">				while (*++path == '/')</a>
<a name="ln2272">					;</a>
<a name="ln2273"> </a>
<a name="ln2274">				mutex_lock(&amp;sIOContextRootLock);</a>
<a name="ln2275">				vnode = ioContext-&gt;root;</a>
<a name="ln2276">				inc_vnode_ref_count(vnode);</a>
<a name="ln2277">				mutex_unlock(&amp;sIOContextRootLock);</a>
<a name="ln2278"> </a>
<a name="ln2279">				absoluteSymlink = true;</a>
<a name="ln2280">			}</a>
<a name="ln2281"> </a>
<a name="ln2282">			inc_vnode_ref_count(vnode);</a>
<a name="ln2283">				// balance the next recursion - we will decrement the</a>
<a name="ln2284">				// ref_count of the vnode, no matter if we succeeded or not</a>
<a name="ln2285"> </a>
<a name="ln2286">			if (absoluteSymlink &amp;&amp; *path == '\0') {</a>
<a name="ln2287">				// symlink was just &quot;/&quot;</a>
<a name="ln2288">				nextVnode = vnode;</a>
<a name="ln2289">			} else {</a>
<a name="ln2290">				status = vnode_path_to_vnode(vnode, path, true, count + 1,</a>
<a name="ln2291">					ioContext, &amp;nextVnode, &amp;lastParentID);</a>
<a name="ln2292">			}</a>
<a name="ln2293"> </a>
<a name="ln2294">			free(buffer);</a>
<a name="ln2295"> </a>
<a name="ln2296">			if (status != B_OK) {</a>
<a name="ln2297">				put_vnode(vnode);</a>
<a name="ln2298">				return status;</a>
<a name="ln2299">			}</a>
<a name="ln2300">		} else</a>
<a name="ln2301">			lastParentID = vnode-&gt;id;</a>
<a name="ln2302"> </a>
<a name="ln2303">		// decrease the ref count on the old dir we just looked up into</a>
<a name="ln2304">		put_vnode(vnode);</a>
<a name="ln2305"> </a>
<a name="ln2306">		path = nextPath;</a>
<a name="ln2307">		vnode = nextVnode;</a>
<a name="ln2308"> </a>
<a name="ln2309">		// see if we hit a covered node</a>
<a name="ln2310">		if (Vnode* coveringNode = get_covering_vnode(vnode)) {</a>
<a name="ln2311">			put_vnode(vnode);</a>
<a name="ln2312">			vnode = coveringNode;</a>
<a name="ln2313">		}</a>
<a name="ln2314">	}</a>
<a name="ln2315"> </a>
<a name="ln2316">	*_vnode = vnode;</a>
<a name="ln2317">	if (_parentID)</a>
<a name="ln2318">		*_parentID = lastParentID;</a>
<a name="ln2319"> </a>
<a name="ln2320">	return B_OK;</a>
<a name="ln2321">}</a>
<a name="ln2322"> </a>
<a name="ln2323"> </a>
<a name="ln2324">static status_t</a>
<a name="ln2325">vnode_path_to_vnode(struct vnode* vnode, char* path, bool traverseLeafLink,</a>
<a name="ln2326">	int count, bool kernel, struct vnode** _vnode, ino_t* _parentID)</a>
<a name="ln2327">{</a>
<a name="ln2328">	return vnode_path_to_vnode(vnode, path, traverseLeafLink, count,</a>
<a name="ln2329">		get_current_io_context(kernel), _vnode, _parentID);</a>
<a name="ln2330">}</a>
<a name="ln2331"> </a>
<a name="ln2332"> </a>
<a name="ln2333">static status_t</a>
<a name="ln2334">path_to_vnode(char* path, bool traverseLink, struct vnode** _vnode,</a>
<a name="ln2335">	ino_t* _parentID, bool kernel)</a>
<a name="ln2336">{</a>
<a name="ln2337">	struct vnode* start = NULL;</a>
<a name="ln2338"> </a>
<a name="ln2339">	FUNCTION((&quot;path_to_vnode(path = \&quot;%s\&quot;)\n&quot;, path));</a>
<a name="ln2340"> </a>
<a name="ln2341">	if (!path)</a>
<a name="ln2342">		return B_BAD_VALUE;</a>
<a name="ln2343"> </a>
<a name="ln2344">	if (*path == '\0')</a>
<a name="ln2345">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2346"> </a>
<a name="ln2347">	// figure out if we need to start at root or at cwd</a>
<a name="ln2348">	if (*path == '/') {</a>
<a name="ln2349">		if (sRoot == NULL) {</a>
<a name="ln2350">			// we're a bit early, aren't we?</a>
<a name="ln2351">			return B_ERROR;</a>
<a name="ln2352">		}</a>
<a name="ln2353"> </a>
<a name="ln2354">		while (*++path == '/')</a>
<a name="ln2355">			;</a>
<a name="ln2356">		start = get_root_vnode(kernel);</a>
<a name="ln2357"> </a>
<a name="ln2358">		if (*path == '\0') {</a>
<a name="ln2359">			*_vnode = start;</a>
<a name="ln2360">			return B_OK;</a>
<a name="ln2361">		}</a>
<a name="ln2362"> </a>
<a name="ln2363">	} else {</a>
<a name="ln2364">		struct io_context* context = get_current_io_context(kernel);</a>
<a name="ln2365"> </a>
<a name="ln2366">		mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln2367">		start = context-&gt;cwd;</a>
<a name="ln2368">		if (start != NULL)</a>
<a name="ln2369">			inc_vnode_ref_count(start);</a>
<a name="ln2370">		mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln2371"> </a>
<a name="ln2372">		if (start == NULL)</a>
<a name="ln2373">			return B_ERROR;</a>
<a name="ln2374">	}</a>
<a name="ln2375"> </a>
<a name="ln2376">	return vnode_path_to_vnode(start, path, traverseLink, 0, kernel, _vnode,</a>
<a name="ln2377">		_parentID);</a>
<a name="ln2378">}</a>
<a name="ln2379"> </a>
<a name="ln2380"> </a>
<a name="ln2381">/*! Returns the vnode in the next to last segment of the path, and returns</a>
<a name="ln2382">	the last portion in filename.</a>
<a name="ln2383">	The path buffer must be able to store at least one additional character.</a>
<a name="ln2384">*/</a>
<a name="ln2385">static status_t</a>
<a name="ln2386">path_to_dir_vnode(char* path, struct vnode** _vnode, char* filename,</a>
<a name="ln2387">	bool kernel)</a>
<a name="ln2388">{</a>
<a name="ln2389">	status_t status = get_dir_path_and_leaf(path, filename);</a>
<a name="ln2390">	if (status != B_OK)</a>
<a name="ln2391">		return status;</a>
<a name="ln2392"> </a>
<a name="ln2393">	return path_to_vnode(path, true, _vnode, NULL, kernel);</a>
<a name="ln2394">}</a>
<a name="ln2395"> </a>
<a name="ln2396"> </a>
<a name="ln2397">/*!	\brief Retrieves the directory vnode and the leaf name of an entry referred</a>
<a name="ln2398">		   to by a FD + path pair.</a>
<a name="ln2399"> </a>
<a name="ln2400">	\a path must be given in either case. \a fd might be omitted, in which</a>
<a name="ln2401">	case \a path is either an absolute path or one relative to the current</a>
<a name="ln2402">	directory. If both a supplied and \a path is relative it is reckoned off</a>
<a name="ln2403">	of the directory referred to by \a fd. If \a path is absolute \a fd is</a>
<a name="ln2404">	ignored.</a>
<a name="ln2405"> </a>
<a name="ln2406">	The caller has the responsibility to call put_vnode() on the returned</a>
<a name="ln2407">	directory vnode.</a>
<a name="ln2408"> </a>
<a name="ln2409">	\param fd The FD. May be &lt; 0.</a>
<a name="ln2410">	\param path The absolute or relative path. Must not be \c NULL. The buffer</a>
<a name="ln2411">	       is modified by this function. It must have at least room for a</a>
<a name="ln2412">	       string one character longer than the path it contains.</a>
<a name="ln2413">	\param _vnode A pointer to a variable the directory vnode shall be written</a>
<a name="ln2414">		   into.</a>
<a name="ln2415">	\param filename A buffer of size B_FILE_NAME_LENGTH or larger into which</a>
<a name="ln2416">		   the leaf name of the specified entry will be written.</a>
<a name="ln2417">	\param kernel \c true, if invoked from inside the kernel, \c false if</a>
<a name="ln2418">		   invoked from userland.</a>
<a name="ln2419">	\return \c B_OK, if everything went fine, another error code otherwise.</a>
<a name="ln2420">*/</a>
<a name="ln2421">static status_t</a>
<a name="ln2422">fd_and_path_to_dir_vnode(int fd, char* path, struct vnode** _vnode,</a>
<a name="ln2423">	char* filename, bool kernel)</a>
<a name="ln2424">{</a>
<a name="ln2425">	if (!path)</a>
<a name="ln2426">		return B_BAD_VALUE;</a>
<a name="ln2427">	if (*path == '\0')</a>
<a name="ln2428">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2429">	if (fd &lt; 0)</a>
<a name="ln2430">		return path_to_dir_vnode(path, _vnode, filename, kernel);</a>
<a name="ln2431"> </a>
<a name="ln2432">	status_t status = get_dir_path_and_leaf(path, filename);</a>
<a name="ln2433">	if (status != B_OK)</a>
<a name="ln2434">		return status;</a>
<a name="ln2435"> </a>
<a name="ln2436">	return fd_and_path_to_vnode(fd, path, true, _vnode, NULL, kernel);</a>
<a name="ln2437">}</a>
<a name="ln2438"> </a>
<a name="ln2439"> </a>
<a name="ln2440">/*!	\brief Retrieves the directory vnode and the leaf name of an entry referred</a>
<a name="ln2441">		   to by a vnode + path pair.</a>
<a name="ln2442"> </a>
<a name="ln2443">	\a path must be given in either case. \a vnode might be omitted, in which</a>
<a name="ln2444">	case \a path is either an absolute path or one relative to the current</a>
<a name="ln2445">	directory. If both a supplied and \a path is relative it is reckoned off</a>
<a name="ln2446">	of the directory referred to by \a vnode. If \a path is absolute \a vnode is</a>
<a name="ln2447">	ignored.</a>
<a name="ln2448"> </a>
<a name="ln2449">	The caller has the responsibility to call put_vnode() on the returned</a>
<a name="ln2450">	directory vnode.</a>
<a name="ln2451"> </a>
<a name="ln2452">	\param vnode The vnode. May be \c NULL.</a>
<a name="ln2453">	\param path The absolute or relative path. Must not be \c NULL. The buffer</a>
<a name="ln2454">	       is modified by this function. It must have at least room for a</a>
<a name="ln2455">	       string one character longer than the path it contains.</a>
<a name="ln2456">	\param _vnode A pointer to a variable the directory vnode shall be written</a>
<a name="ln2457">		   into.</a>
<a name="ln2458">	\param filename A buffer of size B_FILE_NAME_LENGTH or larger into which</a>
<a name="ln2459">		   the leaf name of the specified entry will be written.</a>
<a name="ln2460">	\param kernel \c true, if invoked from inside the kernel, \c false if</a>
<a name="ln2461">		   invoked from userland.</a>
<a name="ln2462">	\return \c B_OK, if everything went fine, another error code otherwise.</a>
<a name="ln2463">*/</a>
<a name="ln2464">static status_t</a>
<a name="ln2465">vnode_and_path_to_dir_vnode(struct vnode* vnode, char* path,</a>
<a name="ln2466">	struct vnode** _vnode, char* filename, bool kernel)</a>
<a name="ln2467">{</a>
<a name="ln2468">	if (!path)</a>
<a name="ln2469">		return B_BAD_VALUE;</a>
<a name="ln2470">	if (*path == '\0')</a>
<a name="ln2471">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2472">	if (vnode == NULL || path[0] == '/')</a>
<a name="ln2473">		return path_to_dir_vnode(path, _vnode, filename, kernel);</a>
<a name="ln2474"> </a>
<a name="ln2475">	status_t status = get_dir_path_and_leaf(path, filename);</a>
<a name="ln2476">	if (status != B_OK)</a>
<a name="ln2477">		return status;</a>
<a name="ln2478"> </a>
<a name="ln2479">	inc_vnode_ref_count(vnode);</a>
<a name="ln2480">		// vnode_path_to_vnode() always decrements the ref count</a>
<a name="ln2481"> </a>
<a name="ln2482">	return vnode_path_to_vnode(vnode, path, true, 0, kernel, _vnode, NULL);</a>
<a name="ln2483">}</a>
<a name="ln2484"> </a>
<a name="ln2485"> </a>
<a name="ln2486">/*! Returns a vnode's name in the d_name field of a supplied dirent buffer.</a>
<a name="ln2487">*/</a>
<a name="ln2488">static status_t</a>
<a name="ln2489">get_vnode_name(struct vnode* vnode, struct vnode* parent, struct dirent* buffer,</a>
<a name="ln2490">	size_t bufferSize, struct io_context* ioContext)</a>
<a name="ln2491">{</a>
<a name="ln2492">	if (bufferSize &lt; sizeof(struct dirent))</a>
<a name="ln2493">		return B_BAD_VALUE;</a>
<a name="ln2494"> </a>
<a name="ln2495">	// See if the vnode is covering another vnode and move to the covered</a>
<a name="ln2496">	// vnode so we get the underlying file system</a>
<a name="ln2497">	VNodePutter vnodePutter;</a>
<a name="ln2498">	if (Vnode* coveredVnode = get_covered_vnode(vnode)) {</a>
<a name="ln2499">		vnode = coveredVnode;</a>
<a name="ln2500">		vnodePutter.SetTo(vnode);</a>
<a name="ln2501">	}</a>
<a name="ln2502"> </a>
<a name="ln2503">	if (HAS_FS_CALL(vnode, get_vnode_name)) {</a>
<a name="ln2504">		// The FS supports getting the name of a vnode.</a>
<a name="ln2505">		if (FS_CALL(vnode, get_vnode_name, buffer-&gt;d_name,</a>
<a name="ln2506">			(char*)buffer + bufferSize - buffer-&gt;d_name) == B_OK)</a>
<a name="ln2507">			return B_OK;</a>
<a name="ln2508">	}</a>
<a name="ln2509"> </a>
<a name="ln2510">	// The FS doesn't support getting the name of a vnode. So we search the</a>
<a name="ln2511">	// parent directory for the vnode, if the caller let us.</a>
<a name="ln2512"> </a>
<a name="ln2513">	if (parent == NULL || !HAS_FS_CALL(parent, read_dir))</a>
<a name="ln2514">		return B_UNSUPPORTED;</a>
<a name="ln2515"> </a>
<a name="ln2516">	void* cookie;</a>
<a name="ln2517"> </a>
<a name="ln2518">	status_t status = FS_CALL(parent, open_dir, &amp;cookie);</a>
<a name="ln2519">	if (status &gt;= B_OK) {</a>
<a name="ln2520">		while (true) {</a>
<a name="ln2521">			uint32 num = 1;</a>
<a name="ln2522">			// We use the FS hook directly instead of dir_read(), since we don't</a>
<a name="ln2523">			// want the entries to be fixed. We have already resolved vnode to</a>
<a name="ln2524">			// the covered node.</a>
<a name="ln2525">			status = FS_CALL(parent, read_dir, cookie, buffer, bufferSize,</a>
<a name="ln2526">				&amp;num);</a>
<a name="ln2527">			if (status != B_OK)</a>
<a name="ln2528">				break;</a>
<a name="ln2529">			if (num == 0) {</a>
<a name="ln2530">				status = B_ENTRY_NOT_FOUND;</a>
<a name="ln2531">				break;</a>
<a name="ln2532">			}</a>
<a name="ln2533"> </a>
<a name="ln2534">			if (vnode-&gt;id == buffer-&gt;d_ino) {</a>
<a name="ln2535">				// found correct entry!</a>
<a name="ln2536">				break;</a>
<a name="ln2537">			}</a>
<a name="ln2538">		}</a>
<a name="ln2539"> </a>
<a name="ln2540">		FS_CALL(parent, close_dir, cookie);</a>
<a name="ln2541">		FS_CALL(parent, free_dir_cookie, cookie);</a>
<a name="ln2542">	}</a>
<a name="ln2543">	return status;</a>
<a name="ln2544">}</a>
<a name="ln2545"> </a>
<a name="ln2546"> </a>
<a name="ln2547">static status_t</a>
<a name="ln2548">get_vnode_name(struct vnode* vnode, struct vnode* parent, char* name,</a>
<a name="ln2549">	size_t nameSize, bool kernel)</a>
<a name="ln2550">{</a>
<a name="ln2551">	char buffer[sizeof(struct dirent) + B_FILE_NAME_LENGTH];</a>
<a name="ln2552">	struct dirent* dirent = (struct dirent*)buffer;</a>
<a name="ln2553"> </a>
<a name="ln2554">	status_t status = get_vnode_name(vnode, parent, dirent, sizeof(buffer),</a>
<a name="ln2555">		get_current_io_context(kernel));</a>
<a name="ln2556">	if (status != B_OK)</a>
<a name="ln2557">		return status;</a>
<a name="ln2558"> </a>
<a name="ln2559">	if (strlcpy(name, dirent-&gt;d_name, nameSize) &gt;= nameSize)</a>
<a name="ln2560">		return B_BUFFER_OVERFLOW;</a>
<a name="ln2561"> </a>
<a name="ln2562">	return B_OK;</a>
<a name="ln2563">}</a>
<a name="ln2564"> </a>
<a name="ln2565"> </a>
<a name="ln2566">/*!	Gets the full path to a given directory vnode.</a>
<a name="ln2567">	It uses the fs_get_vnode_name() call to get the name of a vnode; if a</a>
<a name="ln2568">	file system doesn't support this call, it will fall back to iterating</a>
<a name="ln2569">	through the parent directory to get the name of the child.</a>
<a name="ln2570"> </a>
<a name="ln2571">	To protect against circular loops, it supports a maximum tree depth</a>
<a name="ln2572">	of 256 levels.</a>
<a name="ln2573"> </a>
<a name="ln2574">	Note that the path may not be correct the time this function returns!</a>
<a name="ln2575">	It doesn't use any locking to prevent returning the correct path, as</a>
<a name="ln2576">	paths aren't safe anyway: the path to a file can change at any time.</a>
<a name="ln2577"> </a>
<a name="ln2578">	It might be a good idea, though, to check if the returned path exists</a>
<a name="ln2579">	in the calling function (it's not done here because of efficiency)</a>
<a name="ln2580">*/</a>
<a name="ln2581">static status_t</a>
<a name="ln2582">dir_vnode_to_path(struct vnode* vnode, char* buffer, size_t bufferSize,</a>
<a name="ln2583">	bool kernel)</a>
<a name="ln2584">{</a>
<a name="ln2585">	FUNCTION((&quot;dir_vnode_to_path(%p, %p, %lu)\n&quot;, vnode, buffer, bufferSize));</a>
<a name="ln2586"> </a>
<a name="ln2587">	if (vnode == NULL || buffer == NULL || bufferSize == 0)</a>
<a name="ln2588">		return B_BAD_VALUE;</a>
<a name="ln2589"> </a>
<a name="ln2590">	if (!S_ISDIR(vnode-&gt;Type()))</a>
<a name="ln2591">		return B_NOT_A_DIRECTORY;</a>
<a name="ln2592"> </a>
<a name="ln2593">	char* path = buffer;</a>
<a name="ln2594">	int32 insert = bufferSize;</a>
<a name="ln2595">	int32 maxLevel = 256;</a>
<a name="ln2596">	int32 length;</a>
<a name="ln2597">	status_t status = B_OK;</a>
<a name="ln2598">	struct io_context* ioContext = get_current_io_context(kernel);</a>
<a name="ln2599"> </a>
<a name="ln2600">	// we don't use get_vnode() here because this call is more</a>
<a name="ln2601">	// efficient and does all we need from get_vnode()</a>
<a name="ln2602">	inc_vnode_ref_count(vnode);</a>
<a name="ln2603"> </a>
<a name="ln2604">	path[--insert] = '\0';</a>
<a name="ln2605">		// the path is filled right to left</a>
<a name="ln2606"> </a>
<a name="ln2607">	while (true) {</a>
<a name="ln2608">		// If the node is the context's root, bail out. Otherwise resolve mount</a>
<a name="ln2609">		// points.</a>
<a name="ln2610">		if (vnode == ioContext-&gt;root)</a>
<a name="ln2611">			break;</a>
<a name="ln2612"> </a>
<a name="ln2613">		if (Vnode* coveredVnode = get_covered_vnode(vnode)) {</a>
<a name="ln2614">			put_vnode(vnode);</a>
<a name="ln2615">			vnode = coveredVnode;</a>
<a name="ln2616">		}</a>
<a name="ln2617"> </a>
<a name="ln2618">		// lookup the parent vnode</a>
<a name="ln2619">		struct vnode* parentVnode;</a>
<a name="ln2620">		status = lookup_dir_entry(vnode, &quot;..&quot;, &amp;parentVnode);</a>
<a name="ln2621">		if (status != B_OK)</a>
<a name="ln2622">			goto out;</a>
<a name="ln2623"> </a>
<a name="ln2624">		if (parentVnode == vnode) {</a>
<a name="ln2625">			// The caller apparently got their hands on a node outside of their</a>
<a name="ln2626">			// context's root. Now we've hit the global root.</a>
<a name="ln2627">			put_vnode(parentVnode);</a>
<a name="ln2628">			break;</a>
<a name="ln2629">		}</a>
<a name="ln2630"> </a>
<a name="ln2631">		// get the node's name</a>
<a name="ln2632">		char nameBuffer[sizeof(struct dirent) + B_FILE_NAME_LENGTH];</a>
<a name="ln2633">			// also used for fs_read_dir()</a>
<a name="ln2634">		char* name = &amp;((struct dirent*)nameBuffer)-&gt;d_name[0];</a>
<a name="ln2635">		status = get_vnode_name(vnode, parentVnode, (struct dirent*)nameBuffer,</a>
<a name="ln2636">			sizeof(nameBuffer), ioContext);</a>
<a name="ln2637"> </a>
<a name="ln2638">		// release the current vnode, we only need its parent from now on</a>
<a name="ln2639">		put_vnode(vnode);</a>
<a name="ln2640">		vnode = parentVnode;</a>
<a name="ln2641"> </a>
<a name="ln2642">		if (status != B_OK)</a>
<a name="ln2643">			goto out;</a>
<a name="ln2644"> </a>
<a name="ln2645">		// TODO: add an explicit check for loops in about 10 levels to do</a>
<a name="ln2646">		// real loop detection</a>
<a name="ln2647"> </a>
<a name="ln2648">		// don't go deeper as 'maxLevel' to prevent circular loops</a>
<a name="ln2649">		if (maxLevel-- &lt; 0) {</a>
<a name="ln2650">			status = B_LINK_LIMIT;</a>
<a name="ln2651">			goto out;</a>
<a name="ln2652">		}</a>
<a name="ln2653"> </a>
<a name="ln2654">		// add the name in front of the current path</a>
<a name="ln2655">		name[B_FILE_NAME_LENGTH - 1] = '\0';</a>
<a name="ln2656">		length = strlen(name);</a>
<a name="ln2657">		insert -= length;</a>
<a name="ln2658">		if (insert &lt;= 0) {</a>
<a name="ln2659">			status = B_RESULT_NOT_REPRESENTABLE;</a>
<a name="ln2660">			goto out;</a>
<a name="ln2661">		}</a>
<a name="ln2662">		memcpy(path + insert, name, length);</a>
<a name="ln2663">		path[--insert] = '/';</a>
<a name="ln2664">	}</a>
<a name="ln2665"> </a>
<a name="ln2666">	// the root dir will result in an empty path: fix it</a>
<a name="ln2667">	if (path[insert] == '\0')</a>
<a name="ln2668">		path[--insert] = '/';</a>
<a name="ln2669"> </a>
<a name="ln2670">	TRACE((&quot;  path is: %s\n&quot;, path + insert));</a>
<a name="ln2671"> </a>
<a name="ln2672">	// move the path to the start of the buffer</a>
<a name="ln2673">	length = bufferSize - insert;</a>
<a name="ln2674">	memmove(buffer, path + insert, length);</a>
<a name="ln2675"> </a>
<a name="ln2676">out:</a>
<a name="ln2677">	put_vnode(vnode);</a>
<a name="ln2678">	return status;</a>
<a name="ln2679">}</a>
<a name="ln2680"> </a>
<a name="ln2681"> </a>
<a name="ln2682">/*!	Checks the length of every path component, and adds a '.'</a>
<a name="ln2683">	if the path ends in a slash.</a>
<a name="ln2684">	The given path buffer must be able to store at least one</a>
<a name="ln2685">	additional character.</a>
<a name="ln2686">*/</a>
<a name="ln2687">static status_t</a>
<a name="ln2688">check_path(char* to)</a>
<a name="ln2689">{</a>
<a name="ln2690">	int32 length = 0;</a>
<a name="ln2691"> </a>
<a name="ln2692">	// check length of every path component</a>
<a name="ln2693"> </a>
<a name="ln2694">	while (*to) {</a>
<a name="ln2695">		char* begin;</a>
<a name="ln2696">		if (*to == '/')</a>
<a name="ln2697">			to++, length++;</a>
<a name="ln2698"> </a>
<a name="ln2699">		begin = to;</a>
<a name="ln2700">		while (*to != '/' &amp;&amp; *to)</a>
<a name="ln2701">			to++, length++;</a>
<a name="ln2702"> </a>
<a name="ln2703">		if (to - begin &gt; B_FILE_NAME_LENGTH)</a>
<a name="ln2704">			return B_NAME_TOO_LONG;</a>
<a name="ln2705">	}</a>
<a name="ln2706"> </a>
<a name="ln2707">	if (length == 0)</a>
<a name="ln2708">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2709"> </a>
<a name="ln2710">	// complete path if there is a slash at the end</a>
<a name="ln2711"> </a>
<a name="ln2712">	if (*(to - 1) == '/') {</a>
<a name="ln2713">		if (length &gt; B_PATH_NAME_LENGTH - 2)</a>
<a name="ln2714">			return B_NAME_TOO_LONG;</a>
<a name="ln2715"> </a>
<a name="ln2716">		to[0] = '.';</a>
<a name="ln2717">		to[1] = '\0';</a>
<a name="ln2718">	}</a>
<a name="ln2719"> </a>
<a name="ln2720">	return B_OK;</a>
<a name="ln2721">}</a>
<a name="ln2722"> </a>
<a name="ln2723"> </a>
<a name="ln2724">static struct file_descriptor*</a>
<a name="ln2725">get_fd_and_vnode(int fd, struct vnode** _vnode, bool kernel)</a>
<a name="ln2726">{</a>
<a name="ln2727">	struct file_descriptor* descriptor</a>
<a name="ln2728">		= get_fd(get_current_io_context(kernel), fd);</a>
<a name="ln2729">	if (descriptor == NULL)</a>
<a name="ln2730">		return NULL;</a>
<a name="ln2731"> </a>
<a name="ln2732">	struct vnode* vnode = fd_vnode(descriptor);</a>
<a name="ln2733">	if (vnode == NULL) {</a>
<a name="ln2734">		put_fd(descriptor);</a>
<a name="ln2735">		return NULL;</a>
<a name="ln2736">	}</a>
<a name="ln2737"> </a>
<a name="ln2738">	// ToDo: when we can close a file descriptor at any point, investigate</a>
<a name="ln2739">	//	if this is still valid to do (accessing the vnode without ref_count</a>
<a name="ln2740">	//	or locking)</a>
<a name="ln2741">	*_vnode = vnode;</a>
<a name="ln2742">	return descriptor;</a>
<a name="ln2743">}</a>
<a name="ln2744"> </a>
<a name="ln2745"> </a>
<a name="ln2746">static struct vnode*</a>
<a name="ln2747">get_vnode_from_fd(int fd, bool kernel)</a>
<a name="ln2748">{</a>
<a name="ln2749">	struct file_descriptor* descriptor;</a>
<a name="ln2750">	struct vnode* vnode;</a>
<a name="ln2751"> </a>
<a name="ln2752">	descriptor = get_fd(get_current_io_context(kernel), fd);</a>
<a name="ln2753">	if (descriptor == NULL)</a>
<a name="ln2754">		return NULL;</a>
<a name="ln2755"> </a>
<a name="ln2756">	vnode = fd_vnode(descriptor);</a>
<a name="ln2757">	if (vnode != NULL)</a>
<a name="ln2758">		inc_vnode_ref_count(vnode);</a>
<a name="ln2759"> </a>
<a name="ln2760">	put_fd(descriptor);</a>
<a name="ln2761">	return vnode;</a>
<a name="ln2762">}</a>
<a name="ln2763"> </a>
<a name="ln2764"> </a>
<a name="ln2765">/*!	Gets the vnode from an FD + path combination. If \a fd is lower than zero,</a>
<a name="ln2766">	only the path will be considered. In this case, the \a path must not be</a>
<a name="ln2767">	NULL.</a>
<a name="ln2768">	If \a fd is a valid file descriptor, \a path may be NULL for directories,</a>
<a name="ln2769">	and should be NULL for files.</a>
<a name="ln2770">*/</a>
<a name="ln2771">static status_t</a>
<a name="ln2772">fd_and_path_to_vnode(int fd, char* path, bool traverseLeafLink,</a>
<a name="ln2773">	struct vnode** _vnode, ino_t* _parentID, bool kernel)</a>
<a name="ln2774">{</a>
<a name="ln2775">	if (fd &lt; 0 &amp;&amp; !path)</a>
<a name="ln2776">		return B_BAD_VALUE;</a>
<a name="ln2777"> </a>
<a name="ln2778">	if (path != NULL &amp;&amp; *path == '\0')</a>
<a name="ln2779">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2780"> </a>
<a name="ln2781">	if (fd &lt; 0 || (path != NULL &amp;&amp; path[0] == '/')) {</a>
<a name="ln2782">		// no FD or absolute path</a>
<a name="ln2783">		return path_to_vnode(path, traverseLeafLink, _vnode, _parentID, kernel);</a>
<a name="ln2784">	}</a>
<a name="ln2785"> </a>
<a name="ln2786">	// FD only, or FD + relative path</a>
<a name="ln2787">	struct vnode* vnode = get_vnode_from_fd(fd, kernel);</a>
<a name="ln2788">	if (vnode == NULL)</a>
<a name="ln2789">		return B_FILE_ERROR;</a>
<a name="ln2790"> </a>
<a name="ln2791">	if (path != NULL) {</a>
<a name="ln2792">		return vnode_path_to_vnode(vnode, path, traverseLeafLink, 0, kernel,</a>
<a name="ln2793">			_vnode, _parentID);</a>
<a name="ln2794">	}</a>
<a name="ln2795"> </a>
<a name="ln2796">	// there is no relative path to take into account</a>
<a name="ln2797"> </a>
<a name="ln2798">	*_vnode = vnode;</a>
<a name="ln2799">	if (_parentID)</a>
<a name="ln2800">		*_parentID = -1;</a>
<a name="ln2801"> </a>
<a name="ln2802">	return B_OK;</a>
<a name="ln2803">}</a>
<a name="ln2804"> </a>
<a name="ln2805"> </a>
<a name="ln2806">static int</a>
<a name="ln2807">get_new_fd(int type, struct fs_mount* mount, struct vnode* vnode,</a>
<a name="ln2808">	void* cookie, int openMode, bool kernel)</a>
<a name="ln2809">{</a>
<a name="ln2810">	struct file_descriptor* descriptor;</a>
<a name="ln2811">	int fd;</a>
<a name="ln2812"> </a>
<a name="ln2813">	// If the vnode is locked, we don't allow creating a new file/directory</a>
<a name="ln2814">	// file_descriptor for it</a>
<a name="ln2815">	if (vnode &amp;&amp; vnode-&gt;mandatory_locked_by != NULL</a>
<a name="ln2816">		&amp;&amp; (type == FDTYPE_FILE || type == FDTYPE_DIR))</a>
<a name="ln2817">		return B_BUSY;</a>
<a name="ln2818"> </a>
<a name="ln2819">	descriptor = alloc_fd();</a>
<a name="ln2820">	if (!descriptor)</a>
<a name="ln2821">		return B_NO_MEMORY;</a>
<a name="ln2822"> </a>
<a name="ln2823">	if (vnode)</a>
<a name="ln2824">		descriptor-&gt;u.vnode = vnode;</a>
<a name="ln2825">	else</a>
<a name="ln2826">		descriptor-&gt;u.mount = mount;</a>
<a name="ln2827">	descriptor-&gt;cookie = cookie;</a>
<a name="ln2828"> </a>
<a name="ln2829">	switch (type) {</a>
<a name="ln2830">		// vnode types</a>
<a name="ln2831">		case FDTYPE_FILE:</a>
<a name="ln2832">			descriptor-&gt;ops = &amp;sFileOps;</a>
<a name="ln2833">			break;</a>
<a name="ln2834">		case FDTYPE_DIR:</a>
<a name="ln2835">			descriptor-&gt;ops = &amp;sDirectoryOps;</a>
<a name="ln2836">			break;</a>
<a name="ln2837">		case FDTYPE_ATTR:</a>
<a name="ln2838">			descriptor-&gt;ops = &amp;sAttributeOps;</a>
<a name="ln2839">			break;</a>
<a name="ln2840">		case FDTYPE_ATTR_DIR:</a>
<a name="ln2841">			descriptor-&gt;ops = &amp;sAttributeDirectoryOps;</a>
<a name="ln2842">			break;</a>
<a name="ln2843"> </a>
<a name="ln2844">		// mount types</a>
<a name="ln2845">		case FDTYPE_INDEX_DIR:</a>
<a name="ln2846">			descriptor-&gt;ops = &amp;sIndexDirectoryOps;</a>
<a name="ln2847">			break;</a>
<a name="ln2848">		case FDTYPE_QUERY:</a>
<a name="ln2849">			descriptor-&gt;ops = &amp;sQueryOps;</a>
<a name="ln2850">			break;</a>
<a name="ln2851"> </a>
<a name="ln2852">		default:</a>
<a name="ln2853">			panic(&quot;get_new_fd() called with unknown type %d\n&quot;, type);</a>
<a name="ln2854">			break;</a>
<a name="ln2855">	}</a>
<a name="ln2856">	descriptor-&gt;type = type;</a>
<a name="ln2857">	descriptor-&gt;open_mode = openMode;</a>
<a name="ln2858"> </a>
<a name="ln2859">	io_context* context = get_current_io_context(kernel);</a>
<a name="ln2860">	fd = new_fd(context, descriptor);</a>
<a name="ln2861">	if (fd &lt; 0) {</a>
<a name="ln2862">		free(descriptor);</a>
<a name="ln2863">		return B_NO_MORE_FDS;</a>
<a name="ln2864">	}</a>
<a name="ln2865"> </a>
<a name="ln2866">	mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln2867">	fd_set_close_on_exec(context, fd, (openMode &amp; O_CLOEXEC) != 0);</a>
<a name="ln2868">	mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln2869"> </a>
<a name="ln2870">	return fd;</a>
<a name="ln2871">}</a>
<a name="ln2872"> </a>
<a name="ln2873"> </a>
<a name="ln2874">/*!	In-place normalizes \a path. It's otherwise semantically equivalent to</a>
<a name="ln2875">	vfs_normalize_path(). See there for more documentation.</a>
<a name="ln2876">*/</a>
<a name="ln2877">static status_t</a>
<a name="ln2878">normalize_path(char* path, size_t pathSize, bool traverseLink, bool kernel)</a>
<a name="ln2879">{</a>
<a name="ln2880">	VNodePutter dirPutter;</a>
<a name="ln2881">	struct vnode* dir = NULL;</a>
<a name="ln2882">	status_t error;</a>
<a name="ln2883"> </a>
<a name="ln2884">	for (int i = 0; i &lt; B_MAX_SYMLINKS; i++) {</a>
<a name="ln2885">		// get dir vnode + leaf name</a>
<a name="ln2886">		struct vnode* nextDir;</a>
<a name="ln2887">		char leaf[B_FILE_NAME_LENGTH];</a>
<a name="ln2888">		error = vnode_and_path_to_dir_vnode(dir, path, &amp;nextDir, leaf, kernel);</a>
<a name="ln2889">		if (error != B_OK)</a>
<a name="ln2890">			return error;</a>
<a name="ln2891"> </a>
<a name="ln2892">		dir = nextDir;</a>
<a name="ln2893">		strcpy(path, leaf);</a>
<a name="ln2894">		dirPutter.SetTo(dir);</a>
<a name="ln2895"> </a>
<a name="ln2896">		// get file vnode, if we shall resolve links</a>
<a name="ln2897">		bool fileExists = false;</a>
<a name="ln2898">		struct vnode* fileVnode;</a>
<a name="ln2899">		VNodePutter fileVnodePutter;</a>
<a name="ln2900">		if (traverseLink) {</a>
<a name="ln2901">			inc_vnode_ref_count(dir);</a>
<a name="ln2902">			if (vnode_path_to_vnode(dir, path, false, 0, kernel, &amp;fileVnode,</a>
<a name="ln2903">					NULL) == B_OK) {</a>
<a name="ln2904">				fileVnodePutter.SetTo(fileVnode);</a>
<a name="ln2905">				fileExists = true;</a>
<a name="ln2906">			}</a>
<a name="ln2907">		}</a>
<a name="ln2908"> </a>
<a name="ln2909">		if (!fileExists || !traverseLink || !S_ISLNK(fileVnode-&gt;Type())) {</a>
<a name="ln2910">			// we're done -- construct the path</a>
<a name="ln2911">			bool hasLeaf = true;</a>
<a name="ln2912">			if (strcmp(leaf, &quot;.&quot;) == 0 || strcmp(leaf, &quot;..&quot;) == 0) {</a>
<a name="ln2913">				// special cases &quot;.&quot; and &quot;..&quot; -- get the dir, forget the leaf</a>
<a name="ln2914">				inc_vnode_ref_count(dir);</a>
<a name="ln2915">				error = vnode_path_to_vnode(dir, leaf, false, 0, kernel,</a>
<a name="ln2916">					&amp;nextDir, NULL);</a>
<a name="ln2917">				if (error != B_OK)</a>
<a name="ln2918">					return error;</a>
<a name="ln2919">				dir = nextDir;</a>
<a name="ln2920">				dirPutter.SetTo(dir);</a>
<a name="ln2921">				hasLeaf = false;</a>
<a name="ln2922">			}</a>
<a name="ln2923"> </a>
<a name="ln2924">			// get the directory path</a>
<a name="ln2925">			error = dir_vnode_to_path(dir, path, B_PATH_NAME_LENGTH, kernel);</a>
<a name="ln2926">			if (error != B_OK)</a>
<a name="ln2927">				return error;</a>
<a name="ln2928"> </a>
<a name="ln2929">			// append the leaf name</a>
<a name="ln2930">			if (hasLeaf) {</a>
<a name="ln2931">				// insert a directory separator if this is not the file system</a>
<a name="ln2932">				// root</a>
<a name="ln2933">				if ((strcmp(path, &quot;/&quot;) != 0</a>
<a name="ln2934">					&amp;&amp; strlcat(path, &quot;/&quot;, pathSize) &gt;= pathSize)</a>
<a name="ln2935">					|| strlcat(path, leaf, pathSize) &gt;= pathSize) {</a>
<a name="ln2936">					return B_NAME_TOO_LONG;</a>
<a name="ln2937">				}</a>
<a name="ln2938">			}</a>
<a name="ln2939"> </a>
<a name="ln2940">			return B_OK;</a>
<a name="ln2941">		}</a>
<a name="ln2942"> </a>
<a name="ln2943">		// read link</a>
<a name="ln2944">		if (HAS_FS_CALL(fileVnode, read_symlink)) {</a>
<a name="ln2945">			size_t bufferSize = B_PATH_NAME_LENGTH - 1;</a>
<a name="ln2946">			error = FS_CALL(fileVnode, read_symlink, path, &amp;bufferSize);</a>
<a name="ln2947">			if (error != B_OK)</a>
<a name="ln2948">				return error;</a>
<a name="ln2949">			path[bufferSize] = '\0';</a>
<a name="ln2950">		} else</a>
<a name="ln2951">			return B_BAD_VALUE;</a>
<a name="ln2952">	}</a>
<a name="ln2953"> </a>
<a name="ln2954">	return B_LINK_LIMIT;</a>
<a name="ln2955">}</a>
<a name="ln2956"> </a>
<a name="ln2957"> </a>
<a name="ln2958">static status_t</a>
<a name="ln2959">resolve_covered_parent(struct vnode* parent, dev_t* _device, ino_t* _node,</a>
<a name="ln2960">	struct io_context* ioContext)</a>
<a name="ln2961">{</a>
<a name="ln2962">	// Make sure the IO context root is not bypassed.</a>
<a name="ln2963">	if (parent == ioContext-&gt;root) {</a>
<a name="ln2964">		*_device = parent-&gt;device;</a>
<a name="ln2965">		*_node = parent-&gt;id;</a>
<a name="ln2966">		return B_OK;</a>
<a name="ln2967">	}</a>
<a name="ln2968"> </a>
<a name="ln2969">	inc_vnode_ref_count(parent);</a>
<a name="ln2970">		// vnode_path_to_vnode() puts the node</a>
<a name="ln2971"> </a>
<a name="ln2972">	// &quot;..&quot; is guaranteed not to be clobbered by this call</a>
<a name="ln2973">	struct vnode* vnode;</a>
<a name="ln2974">	status_t status = vnode_path_to_vnode(parent, (char*)&quot;..&quot;, false, 0,</a>
<a name="ln2975">		ioContext, &amp;vnode, NULL);</a>
<a name="ln2976">	if (status == B_OK) {</a>
<a name="ln2977">		*_device = vnode-&gt;device;</a>
<a name="ln2978">		*_node = vnode-&gt;id;</a>
<a name="ln2979">		put_vnode(vnode);</a>
<a name="ln2980">	}</a>
<a name="ln2981"> </a>
<a name="ln2982">	return status;</a>
<a name="ln2983">}</a>
<a name="ln2984"> </a>
<a name="ln2985"> </a>
<a name="ln2986">#ifdef ADD_DEBUGGER_COMMANDS</a>
<a name="ln2987"> </a>
<a name="ln2988"> </a>
<a name="ln2989">static void</a>
<a name="ln2990">_dump_advisory_locking(advisory_locking* locking)</a>
<a name="ln2991">{</a>
<a name="ln2992">	if (locking == NULL)</a>
<a name="ln2993">		return;</a>
<a name="ln2994"> </a>
<a name="ln2995">	kprintf(&quot;   lock:        %&quot; B_PRId32, locking-&gt;lock);</a>
<a name="ln2996">	kprintf(&quot;   wait_sem:    %&quot; B_PRId32, locking-&gt;wait_sem);</a>
<a name="ln2997"> </a>
<a name="ln2998">	int32 index = 0;</a>
<a name="ln2999">	LockList::Iterator iterator = locking-&gt;locks.GetIterator();</a>
<a name="ln3000">	while (iterator.HasNext()) {</a>
<a name="ln3001">		struct advisory_lock* lock = iterator.Next();</a>
<a name="ln3002"> </a>
<a name="ln3003">		kprintf(&quot;   [%2&quot; B_PRId32 &quot;] team:   %&quot; B_PRId32 &quot;\n&quot;, index++, lock-&gt;team);</a>
<a name="ln3004">		kprintf(&quot;        start:  %&quot; B_PRIdOFF &quot;\n&quot;, lock-&gt;start);</a>
<a name="ln3005">		kprintf(&quot;        end:    %&quot; B_PRIdOFF &quot;\n&quot;, lock-&gt;end);</a>
<a name="ln3006">		kprintf(&quot;        shared? %s\n&quot;, lock-&gt;shared ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln3007">	}</a>
<a name="ln3008">}</a>
<a name="ln3009"> </a>
<a name="ln3010"> </a>
<a name="ln3011">static void</a>
<a name="ln3012">_dump_mount(struct fs_mount* mount)</a>
<a name="ln3013">{</a>
<a name="ln3014">	kprintf(&quot;MOUNT: %p\n&quot;, mount);</a>
<a name="ln3015">	kprintf(&quot; id:            %&quot; B_PRIdDEV &quot;\n&quot;, mount-&gt;id);</a>
<a name="ln3016">	kprintf(&quot; device_name:   %s\n&quot;, mount-&gt;device_name);</a>
<a name="ln3017">	kprintf(&quot; root_vnode:    %p\n&quot;, mount-&gt;root_vnode);</a>
<a name="ln3018">	kprintf(&quot; covers:        %p\n&quot;, mount-&gt;root_vnode-&gt;covers);</a>
<a name="ln3019">	kprintf(&quot; partition:     %p\n&quot;, mount-&gt;partition);</a>
<a name="ln3020">	kprintf(&quot; lock:          %p\n&quot;, &amp;mount-&gt;lock);</a>
<a name="ln3021">	kprintf(&quot; flags:        %s%s\n&quot;, mount-&gt;unmounting ? &quot; unmounting&quot; : &quot;&quot;,</a>
<a name="ln3022">		mount-&gt;owns_file_device ? &quot; owns_file_device&quot; : &quot;&quot;);</a>
<a name="ln3023"> </a>
<a name="ln3024">	fs_volume* volume = mount-&gt;volume;</a>
<a name="ln3025">	while (volume != NULL) {</a>
<a name="ln3026">		kprintf(&quot; volume %p:\n&quot;, volume);</a>
<a name="ln3027">		kprintf(&quot;  layer:            %&quot; B_PRId32 &quot;\n&quot;, volume-&gt;layer);</a>
<a name="ln3028">		kprintf(&quot;  private_volume:   %p\n&quot;, volume-&gt;private_volume);</a>
<a name="ln3029">		kprintf(&quot;  ops:              %p\n&quot;, volume-&gt;ops);</a>
<a name="ln3030">		kprintf(&quot;  file_system:      %p\n&quot;, volume-&gt;file_system);</a>
<a name="ln3031">		kprintf(&quot;  file_system_name: %s\n&quot;, volume-&gt;file_system_name);</a>
<a name="ln3032">		volume = volume-&gt;super_volume;</a>
<a name="ln3033">	}</a>
<a name="ln3034"> </a>
<a name="ln3035">	set_debug_variable(&quot;_volume&quot;, (addr_t)mount-&gt;volume-&gt;private_volume);</a>
<a name="ln3036">	set_debug_variable(&quot;_root&quot;, (addr_t)mount-&gt;root_vnode);</a>
<a name="ln3037">	set_debug_variable(&quot;_covers&quot;, (addr_t)mount-&gt;root_vnode-&gt;covers);</a>
<a name="ln3038">	set_debug_variable(&quot;_partition&quot;, (addr_t)mount-&gt;partition);</a>
<a name="ln3039">}</a>
<a name="ln3040"> </a>
<a name="ln3041"> </a>
<a name="ln3042">static bool</a>
<a name="ln3043">debug_prepend_vnode_name_to_path(char* buffer, size_t&amp; bufferSize,</a>
<a name="ln3044">	const char* name)</a>
<a name="ln3045">{</a>
<a name="ln3046">	bool insertSlash = buffer[bufferSize] != '\0';</a>
<a name="ln3047">	size_t nameLength = strlen(name);</a>
<a name="ln3048"> </a>
<a name="ln3049">	if (bufferSize &lt; nameLength + (insertSlash ? 1 : 0))</a>
<a name="ln3050">		return false;</a>
<a name="ln3051"> </a>
<a name="ln3052">	if (insertSlash)</a>
<a name="ln3053">		buffer[--bufferSize] = '/';</a>
<a name="ln3054"> </a>
<a name="ln3055">	bufferSize -= nameLength;</a>
<a name="ln3056">	memcpy(buffer + bufferSize, name, nameLength);</a>
<a name="ln3057"> </a>
<a name="ln3058">	return true;</a>
<a name="ln3059">}</a>
<a name="ln3060"> </a>
<a name="ln3061"> </a>
<a name="ln3062">static bool</a>
<a name="ln3063">debug_prepend_vnode_id_to_path(char* buffer, size_t&amp; bufferSize, dev_t devID,</a>
<a name="ln3064">	ino_t nodeID)</a>
<a name="ln3065">{</a>
<a name="ln3066">	if (bufferSize == 0)</a>
<a name="ln3067">		return false;</a>
<a name="ln3068"> </a>
<a name="ln3069">	bool insertSlash = buffer[bufferSize] != '\0';</a>
<a name="ln3070">	if (insertSlash)</a>
<a name="ln3071">		buffer[--bufferSize] = '/';</a>
<a name="ln3072"> </a>
<a name="ln3073">	size_t size = snprintf(buffer, bufferSize,</a>
<a name="ln3074">		&quot;&lt;%&quot; B_PRIdDEV &quot;,%&quot; B_PRIdINO &quot;&gt;&quot;, devID, nodeID);</a>
<a name="ln3075">	if (size &gt; bufferSize) {</a>
<a name="ln3076">		if (insertSlash)</a>
<a name="ln3077">			bufferSize++;</a>
<a name="ln3078">		return false;</a>
<a name="ln3079">	}</a>
<a name="ln3080"> </a>
<a name="ln3081">	if (size &lt; bufferSize)</a>
<a name="ln3082">		memmove(buffer + bufferSize - size, buffer, size);</a>
<a name="ln3083"> </a>
<a name="ln3084">	bufferSize -= size;</a>
<a name="ln3085">	return true;</a>
<a name="ln3086">}</a>
<a name="ln3087"> </a>
<a name="ln3088"> </a>
<a name="ln3089">static char*</a>
<a name="ln3090">debug_resolve_vnode_path(struct vnode* vnode, char* buffer, size_t bufferSize,</a>
<a name="ln3091">	bool&amp; _truncated)</a>
<a name="ln3092">{</a>
<a name="ln3093">	// null-terminate the path</a>
<a name="ln3094">	buffer[--bufferSize] = '\0';</a>
<a name="ln3095"> </a>
<a name="ln3096">	while (true) {</a>
<a name="ln3097">		while (vnode-&gt;covers != NULL)</a>
<a name="ln3098">			vnode = vnode-&gt;covers;</a>
<a name="ln3099"> </a>
<a name="ln3100">		if (vnode == sRoot) {</a>
<a name="ln3101">			_truncated = bufferSize == 0;</a>
<a name="ln3102">			if (!_truncated)</a>
<a name="ln3103">				buffer[--bufferSize] = '/';</a>
<a name="ln3104">			return buffer + bufferSize;</a>
<a name="ln3105">		}</a>
<a name="ln3106"> </a>
<a name="ln3107">		// resolve the name</a>
<a name="ln3108">		ino_t dirID;</a>
<a name="ln3109">		const char* name = vnode-&gt;mount-&gt;entry_cache.DebugReverseLookup(</a>
<a name="ln3110">			vnode-&gt;id, dirID);</a>
<a name="ln3111">		if (name == NULL) {</a>
<a name="ln3112">			// Failed to resolve the name -- prepend &quot;&lt;dev,node&gt;/&quot;.</a>
<a name="ln3113">			_truncated = !debug_prepend_vnode_id_to_path(buffer, bufferSize,</a>
<a name="ln3114">				vnode-&gt;mount-&gt;id, vnode-&gt;id);</a>
<a name="ln3115">			return buffer + bufferSize;</a>
<a name="ln3116">		}</a>
<a name="ln3117"> </a>
<a name="ln3118">		// prepend the name</a>
<a name="ln3119">		if (!debug_prepend_vnode_name_to_path(buffer, bufferSize, name)) {</a>
<a name="ln3120">			_truncated = true;</a>
<a name="ln3121">			return buffer + bufferSize;</a>
<a name="ln3122">		}</a>
<a name="ln3123"> </a>
<a name="ln3124">		// resolve the directory node</a>
<a name="ln3125">		struct vnode* nextVnode = lookup_vnode(vnode-&gt;mount-&gt;id, dirID);</a>
<a name="ln3126">		if (nextVnode == NULL) {</a>
<a name="ln3127">			_truncated = !debug_prepend_vnode_id_to_path(buffer, bufferSize,</a>
<a name="ln3128">				vnode-&gt;mount-&gt;id, dirID);</a>
<a name="ln3129">			return buffer + bufferSize;</a>
<a name="ln3130">		}</a>
<a name="ln3131"> </a>
<a name="ln3132">		vnode = nextVnode;</a>
<a name="ln3133">	}</a>
<a name="ln3134">}</a>
<a name="ln3135"> </a>
<a name="ln3136"> </a>
<a name="ln3137">static void</a>
<a name="ln3138">_dump_vnode(struct vnode* vnode, bool printPath)</a>
<a name="ln3139">{</a>
<a name="ln3140">	kprintf(&quot;VNODE: %p\n&quot;, vnode);</a>
<a name="ln3141">	kprintf(&quot; device:        %&quot; B_PRIdDEV &quot;\n&quot;, vnode-&gt;device);</a>
<a name="ln3142">	kprintf(&quot; id:            %&quot; B_PRIdINO &quot;\n&quot;, vnode-&gt;id);</a>
<a name="ln3143">	kprintf(&quot; ref_count:     %&quot; B_PRId32 &quot;\n&quot;, vnode-&gt;ref_count);</a>
<a name="ln3144">	kprintf(&quot; private_node:  %p\n&quot;, vnode-&gt;private_node);</a>
<a name="ln3145">	kprintf(&quot; mount:         %p\n&quot;, vnode-&gt;mount);</a>
<a name="ln3146">	kprintf(&quot; covered_by:    %p\n&quot;, vnode-&gt;covered_by);</a>
<a name="ln3147">	kprintf(&quot; covers:        %p\n&quot;, vnode-&gt;covers);</a>
<a name="ln3148">	kprintf(&quot; cache:         %p\n&quot;, vnode-&gt;cache);</a>
<a name="ln3149">	kprintf(&quot; type:          %#&quot; B_PRIx32 &quot;\n&quot;, vnode-&gt;Type());</a>
<a name="ln3150">	kprintf(&quot; flags:         %s%s%s\n&quot;, vnode-&gt;IsRemoved() ? &quot;r&quot; : &quot;-&quot;,</a>
<a name="ln3151">		vnode-&gt;IsBusy() ? &quot;b&quot; : &quot;-&quot;, vnode-&gt;IsUnpublished() ? &quot;u&quot; : &quot;-&quot;);</a>
<a name="ln3152">	kprintf(&quot; advisory_lock: %p\n&quot;, vnode-&gt;advisory_locking);</a>
<a name="ln3153"> </a>
<a name="ln3154">	_dump_advisory_locking(vnode-&gt;advisory_locking);</a>
<a name="ln3155"> </a>
<a name="ln3156">	if (printPath) {</a>
<a name="ln3157">		void* buffer = debug_malloc(B_PATH_NAME_LENGTH);</a>
<a name="ln3158">		if (buffer != NULL) {</a>
<a name="ln3159">			bool truncated;</a>
<a name="ln3160">			char* path = debug_resolve_vnode_path(vnode, (char*)buffer,</a>
<a name="ln3161">				B_PATH_NAME_LENGTH, truncated);</a>
<a name="ln3162">			if (path != NULL) {</a>
<a name="ln3163">				kprintf(&quot; path:          &quot;);</a>
<a name="ln3164">				if (truncated)</a>
<a name="ln3165">					kputs(&quot;&lt;truncated&gt;/&quot;);</a>
<a name="ln3166">				kputs(path);</a>
<a name="ln3167">				kputs(&quot;\n&quot;);</a>
<a name="ln3168">			} else</a>
<a name="ln3169">				kprintf(&quot;Failed to resolve vnode path.\n&quot;);</a>
<a name="ln3170"> </a>
<a name="ln3171">			debug_free(buffer);</a>
<a name="ln3172">		} else</a>
<a name="ln3173">			kprintf(&quot;Failed to allocate memory for constructing the path.\n&quot;);</a>
<a name="ln3174">	}</a>
<a name="ln3175"> </a>
<a name="ln3176">	set_debug_variable(&quot;_node&quot;, (addr_t)vnode-&gt;private_node);</a>
<a name="ln3177">	set_debug_variable(&quot;_mount&quot;, (addr_t)vnode-&gt;mount);</a>
<a name="ln3178">	set_debug_variable(&quot;_covered_by&quot;, (addr_t)vnode-&gt;covered_by);</a>
<a name="ln3179">	set_debug_variable(&quot;_covers&quot;, (addr_t)vnode-&gt;covers);</a>
<a name="ln3180">	set_debug_variable(&quot;_adv_lock&quot;, (addr_t)vnode-&gt;advisory_locking);</a>
<a name="ln3181">}</a>
<a name="ln3182"> </a>
<a name="ln3183"> </a>
<a name="ln3184">static int</a>
<a name="ln3185">dump_mount(int argc, char** argv)</a>
<a name="ln3186">{</a>
<a name="ln3187">	if (argc != 2 || !strcmp(argv[1], &quot;--help&quot;)) {</a>
<a name="ln3188">		kprintf(&quot;usage: %s [id|address]\n&quot;, argv[0]);</a>
<a name="ln3189">		return 0;</a>
<a name="ln3190">	}</a>
<a name="ln3191"> </a>
<a name="ln3192">	ulong val = parse_expression(argv[1]);</a>
<a name="ln3193">	uint32 id = val;</a>
<a name="ln3194"> </a>
<a name="ln3195">	struct fs_mount* mount = sMountsTable-&gt;Lookup(id);</a>
<a name="ln3196">	if (mount == NULL) {</a>
<a name="ln3197">		if (IS_USER_ADDRESS(id)) {</a>
<a name="ln3198">			kprintf(&quot;fs_mount not found\n&quot;);</a>
<a name="ln3199">			return 0;</a>
<a name="ln3200">		}</a>
<a name="ln3201">		mount = (fs_mount*)val;</a>
<a name="ln3202">	}</a>
<a name="ln3203"> </a>
<a name="ln3204">	_dump_mount(mount);</a>
<a name="ln3205">	return 0;</a>
<a name="ln3206">}</a>
<a name="ln3207"> </a>
<a name="ln3208"> </a>
<a name="ln3209">static int</a>
<a name="ln3210">dump_mounts(int argc, char** argv)</a>
<a name="ln3211">{</a>
<a name="ln3212">	if (argc != 1) {</a>
<a name="ln3213">		kprintf(&quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln3214">		return 0;</a>
<a name="ln3215">	}</a>
<a name="ln3216"> </a>
<a name="ln3217">	kprintf(&quot;%-*s    id %-*s   %-*s   %-*s   fs_name\n&quot;,</a>
<a name="ln3218">		B_PRINTF_POINTER_WIDTH, &quot;address&quot;, B_PRINTF_POINTER_WIDTH, &quot;root&quot;,</a>
<a name="ln3219">		B_PRINTF_POINTER_WIDTH, &quot;covers&quot;, B_PRINTF_POINTER_WIDTH, &quot;cookie&quot;);</a>
<a name="ln3220"> </a>
<a name="ln3221">	struct fs_mount* mount;</a>
<a name="ln3222"> </a>
<a name="ln3223">	MountTable::Iterator iterator(sMountsTable);</a>
<a name="ln3224">	while (iterator.HasNext()) {</a>
<a name="ln3225">		mount = iterator.Next();</a>
<a name="ln3226">		kprintf(&quot;%p%4&quot; B_PRIdDEV &quot; %p %p %p %s\n&quot;, mount, mount-&gt;id, mount-&gt;root_vnode,</a>
<a name="ln3227">			mount-&gt;root_vnode-&gt;covers, mount-&gt;volume-&gt;private_volume,</a>
<a name="ln3228">			mount-&gt;volume-&gt;file_system_name);</a>
<a name="ln3229"> </a>
<a name="ln3230">		fs_volume* volume = mount-&gt;volume;</a>
<a name="ln3231">		while (volume-&gt;super_volume != NULL) {</a>
<a name="ln3232">			volume = volume-&gt;super_volume;</a>
<a name="ln3233">			kprintf(&quot;                                     %p %s\n&quot;,</a>
<a name="ln3234">				volume-&gt;private_volume, volume-&gt;file_system_name);</a>
<a name="ln3235">		}</a>
<a name="ln3236">	}</a>
<a name="ln3237"> </a>
<a name="ln3238">	return 0;</a>
<a name="ln3239">}</a>
<a name="ln3240"> </a>
<a name="ln3241"> </a>
<a name="ln3242">static int</a>
<a name="ln3243">dump_vnode(int argc, char** argv)</a>
<a name="ln3244">{</a>
<a name="ln3245">	bool printPath = false;</a>
<a name="ln3246">	int argi = 1;</a>
<a name="ln3247">	if (argc &gt;= 2 &amp;&amp; strcmp(argv[argi], &quot;-p&quot;) == 0) {</a>
<a name="ln3248">		printPath = true;</a>
<a name="ln3249">		argi++;</a>
<a name="ln3250">	}</a>
<a name="ln3251"> </a>
<a name="ln3252">	if (argi &gt;= argc || argi + 2 &lt; argc) {</a>
<a name="ln3253">		print_debugger_command_usage(argv[0]);</a>
<a name="ln3254">		return 0;</a>
<a name="ln3255">	}</a>
<a name="ln3256"> </a>
<a name="ln3257">	struct vnode* vnode = NULL;</a>
<a name="ln3258"> </a>
<a name="ln3259">	if (argi + 1 == argc) {</a>
<a name="ln3260">		vnode = (struct vnode*)parse_expression(argv[argi]);</a>
<a name="ln3261">		if (IS_USER_ADDRESS(vnode)) {</a>
<a name="ln3262">			kprintf(&quot;invalid vnode address\n&quot;);</a>
<a name="ln3263">			return 0;</a>
<a name="ln3264">		}</a>
<a name="ln3265">		_dump_vnode(vnode, printPath);</a>
<a name="ln3266">		return 0;</a>
<a name="ln3267">	}</a>
<a name="ln3268"> </a>
<a name="ln3269">	dev_t device = parse_expression(argv[argi]);</a>
<a name="ln3270">	ino_t id = parse_expression(argv[argi + 1]);</a>
<a name="ln3271"> </a>
<a name="ln3272">	VnodeTable::Iterator iterator(sVnodeTable);</a>
<a name="ln3273">	while (iterator.HasNext()) {</a>
<a name="ln3274">		vnode = iterator.Next();</a>
<a name="ln3275">		if (vnode-&gt;id != id || vnode-&gt;device != device)</a>
<a name="ln3276">			continue;</a>
<a name="ln3277"> </a>
<a name="ln3278">		_dump_vnode(vnode, printPath);</a>
<a name="ln3279">	}</a>
<a name="ln3280"> </a>
<a name="ln3281">	return 0;</a>
<a name="ln3282">}</a>
<a name="ln3283"> </a>
<a name="ln3284"> </a>
<a name="ln3285">static int</a>
<a name="ln3286">dump_vnodes(int argc, char** argv)</a>
<a name="ln3287">{</a>
<a name="ln3288">	if (argc != 2 || !strcmp(argv[1], &quot;--help&quot;)) {</a>
<a name="ln3289">		kprintf(&quot;usage: %s [device]\n&quot;, argv[0]);</a>
<a name="ln3290">		return 0;</a>
<a name="ln3291">	}</a>
<a name="ln3292"> </a>
<a name="ln3293">	// restrict dumped nodes to a certain device if requested</a>
<a name="ln3294">	dev_t device = parse_expression(argv[1]);</a>
<a name="ln3295"> </a>
<a name="ln3296">	struct vnode* vnode;</a>
<a name="ln3297"> </a>
<a name="ln3298">	kprintf(&quot;%-*s   dev     inode  ref %-*s   %-*s   %-*s   flags\n&quot;,</a>
<a name="ln3299">		B_PRINTF_POINTER_WIDTH, &quot;address&quot;, B_PRINTF_POINTER_WIDTH, &quot;cache&quot;,</a>
<a name="ln3300">		B_PRINTF_POINTER_WIDTH, &quot;fs-node&quot;, B_PRINTF_POINTER_WIDTH, &quot;locking&quot;);</a>
<a name="ln3301"> </a>
<a name="ln3302">	VnodeTable::Iterator iterator(sVnodeTable);</a>
<a name="ln3303">	while (iterator.HasNext()) {</a>
<a name="ln3304">		vnode = iterator.Next();</a>
<a name="ln3305">		if (vnode-&gt;device != device)</a>
<a name="ln3306">			continue;</a>
<a name="ln3307"> </a>
<a name="ln3308">		kprintf(&quot;%p%4&quot; B_PRIdDEV &quot;%10&quot; B_PRIdINO &quot;%5&quot; B_PRId32 &quot; %p %p %p %s%s%s\n&quot;,</a>
<a name="ln3309">			vnode, vnode-&gt;device, vnode-&gt;id, vnode-&gt;ref_count, vnode-&gt;cache,</a>
<a name="ln3310">			vnode-&gt;private_node, vnode-&gt;advisory_locking,</a>
<a name="ln3311">			vnode-&gt;IsRemoved() ? &quot;r&quot; : &quot;-&quot;, vnode-&gt;IsBusy() ? &quot;b&quot; : &quot;-&quot;,</a>
<a name="ln3312">			vnode-&gt;IsUnpublished() ? &quot;u&quot; : &quot;-&quot;);</a>
<a name="ln3313">	}</a>
<a name="ln3314"> </a>
<a name="ln3315">	return 0;</a>
<a name="ln3316">}</a>
<a name="ln3317"> </a>
<a name="ln3318"> </a>
<a name="ln3319">static int</a>
<a name="ln3320">dump_vnode_caches(int argc, char** argv)</a>
<a name="ln3321">{</a>
<a name="ln3322">	struct vnode* vnode;</a>
<a name="ln3323"> </a>
<a name="ln3324">	if (argc &gt; 2 || !strcmp(argv[1], &quot;--help&quot;)) {</a>
<a name="ln3325">		kprintf(&quot;usage: %s [device]\n&quot;, argv[0]);</a>
<a name="ln3326">		return 0;</a>
<a name="ln3327">	}</a>
<a name="ln3328"> </a>
<a name="ln3329">	// restrict dumped nodes to a certain device if requested</a>
<a name="ln3330">	dev_t device = -1;</a>
<a name="ln3331">	if (argc &gt; 1)</a>
<a name="ln3332">		device = parse_expression(argv[1]);</a>
<a name="ln3333"> </a>
<a name="ln3334">	kprintf(&quot;%-*s   dev     inode %-*s       size   pages\n&quot;,</a>
<a name="ln3335">		B_PRINTF_POINTER_WIDTH, &quot;address&quot;, B_PRINTF_POINTER_WIDTH, &quot;cache&quot;);</a>
<a name="ln3336"> </a>
<a name="ln3337">	VnodeTable::Iterator iterator(sVnodeTable);</a>
<a name="ln3338">	while (iterator.HasNext()) {</a>
<a name="ln3339">		vnode = iterator.Next();</a>
<a name="ln3340">		if (vnode-&gt;cache == NULL)</a>
<a name="ln3341">			continue;</a>
<a name="ln3342">		if (device != -1 &amp;&amp; vnode-&gt;device != device)</a>
<a name="ln3343">			continue;</a>
<a name="ln3344"> </a>
<a name="ln3345">		kprintf(&quot;%p%4&quot; B_PRIdDEV &quot;%10&quot; B_PRIdINO &quot; %p %8&quot; B_PRIdOFF &quot;%8&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln3346">			vnode, vnode-&gt;device, vnode-&gt;id, vnode-&gt;cache,</a>
<a name="ln3347">			(vnode-&gt;cache-&gt;virtual_end + B_PAGE_SIZE - 1) / B_PAGE_SIZE,</a>
<a name="ln3348">			vnode-&gt;cache-&gt;page_count);</a>
<a name="ln3349">	}</a>
<a name="ln3350"> </a>
<a name="ln3351">	return 0;</a>
<a name="ln3352">}</a>
<a name="ln3353"> </a>
<a name="ln3354"> </a>
<a name="ln3355">int</a>
<a name="ln3356">dump_io_context(int argc, char** argv)</a>
<a name="ln3357">{</a>
<a name="ln3358">	if (argc &gt; 2 || !strcmp(argv[1], &quot;--help&quot;)) {</a>
<a name="ln3359">		kprintf(&quot;usage: %s [team-id|address]\n&quot;, argv[0]);</a>
<a name="ln3360">		return 0;</a>
<a name="ln3361">	}</a>
<a name="ln3362"> </a>
<a name="ln3363">	struct io_context* context = NULL;</a>
<a name="ln3364"> </a>
<a name="ln3365">	if (argc &gt; 1) {</a>
<a name="ln3366">		ulong num = parse_expression(argv[1]);</a>
<a name="ln3367">		if (IS_KERNEL_ADDRESS(num))</a>
<a name="ln3368">			context = (struct io_context*)num;</a>
<a name="ln3369">		else {</a>
<a name="ln3370">			Team* team = team_get_team_struct_locked(num);</a>
<a name="ln3371">			if (team == NULL) {</a>
<a name="ln3372">				kprintf(&quot;could not find team with ID %lu\n&quot;, num);</a>
<a name="ln3373">				return 0;</a>
<a name="ln3374">			}</a>
<a name="ln3375">			context = (struct io_context*)team-&gt;io_context;</a>
<a name="ln3376">		}</a>
<a name="ln3377">	} else</a>
<a name="ln3378">		context = get_current_io_context(true);</a>
<a name="ln3379"> </a>
<a name="ln3380">	kprintf(&quot;I/O CONTEXT: %p\n&quot;, context);</a>
<a name="ln3381">	kprintf(&quot; root vnode:\t%p\n&quot;, context-&gt;root);</a>
<a name="ln3382">	kprintf(&quot; cwd vnode:\t%p\n&quot;, context-&gt;cwd);</a>
<a name="ln3383">	kprintf(&quot; used fds:\t%&quot; B_PRIu32 &quot;\n&quot;, context-&gt;num_used_fds);</a>
<a name="ln3384">	kprintf(&quot; max fds:\t%&quot; B_PRIu32 &quot;\n&quot;, context-&gt;table_size);</a>
<a name="ln3385"> </a>
<a name="ln3386">	if (context-&gt;num_used_fds) {</a>
<a name="ln3387">		kprintf(&quot;   no.  type    %*s  ref  open  mode         pos    %*s\n&quot;,</a>
<a name="ln3388">			B_PRINTF_POINTER_WIDTH, &quot;ops&quot;, B_PRINTF_POINTER_WIDTH, &quot;cookie&quot;);</a>
<a name="ln3389">	}</a>
<a name="ln3390"> </a>
<a name="ln3391">	for (uint32 i = 0; i &lt; context-&gt;table_size; i++) {</a>
<a name="ln3392">		struct file_descriptor* fd = context-&gt;fds[i];</a>
<a name="ln3393">		if (fd == NULL)</a>
<a name="ln3394">			continue;</a>
<a name="ln3395"> </a>
<a name="ln3396">		kprintf(&quot;  %3&quot; B_PRIu32 &quot;:  %4&quot; B_PRId32 &quot;  %p  %3&quot; B_PRId32 &quot;  %4&quot;</a>
<a name="ln3397">			B_PRIu32 &quot;  %4&quot; B_PRIx32 &quot;  %10&quot; B_PRIdOFF &quot;  %p  %s %p\n&quot;, i,</a>
<a name="ln3398">			fd-&gt;type, fd-&gt;ops, fd-&gt;ref_count, fd-&gt;open_count, fd-&gt;open_mode,</a>
<a name="ln3399">			fd-&gt;pos, fd-&gt;cookie,</a>
<a name="ln3400">			fd-&gt;type &gt;= FDTYPE_INDEX &amp;&amp; fd-&gt;type &lt;= FDTYPE_QUERY</a>
<a name="ln3401">				? &quot;mount&quot; : &quot;vnode&quot;,</a>
<a name="ln3402">			fd-&gt;u.vnode);</a>
<a name="ln3403">	}</a>
<a name="ln3404"> </a>
<a name="ln3405">	kprintf(&quot; used monitors:\t%&quot; B_PRIu32 &quot;\n&quot;, context-&gt;num_monitors);</a>
<a name="ln3406">	kprintf(&quot; max monitors:\t%&quot; B_PRIu32 &quot;\n&quot;, context-&gt;max_monitors);</a>
<a name="ln3407"> </a>
<a name="ln3408">	set_debug_variable(&quot;_cwd&quot;, (addr_t)context-&gt;cwd);</a>
<a name="ln3409"> </a>
<a name="ln3410">	return 0;</a>
<a name="ln3411">}</a>
<a name="ln3412"> </a>
<a name="ln3413"> </a>
<a name="ln3414">int</a>
<a name="ln3415">dump_vnode_usage(int argc, char** argv)</a>
<a name="ln3416">{</a>
<a name="ln3417">	if (argc != 1) {</a>
<a name="ln3418">		kprintf(&quot;usage: %s\n&quot;, argv[0]);</a>
<a name="ln3419">		return 0;</a>
<a name="ln3420">	}</a>
<a name="ln3421"> </a>
<a name="ln3422">	kprintf(&quot;Unused vnodes: %&quot; B_PRIu32 &quot; (max unused %&quot; B_PRIu32 &quot;)\n&quot;,</a>
<a name="ln3423">		sUnusedVnodes, kMaxUnusedVnodes);</a>
<a name="ln3424"> </a>
<a name="ln3425">	uint32 count = sVnodeTable-&gt;CountElements();</a>
<a name="ln3426"> </a>
<a name="ln3427">	kprintf(&quot;%&quot; B_PRIu32 &quot; vnodes total (%&quot; B_PRIu32 &quot; in use).\n&quot;, count,</a>
<a name="ln3428">		count - sUnusedVnodes);</a>
<a name="ln3429">	return 0;</a>
<a name="ln3430">}</a>
<a name="ln3431"> </a>
<a name="ln3432">#endif	// ADD_DEBUGGER_COMMANDS</a>
<a name="ln3433"> </a>
<a name="ln3434"> </a>
<a name="ln3435">/*!	Clears memory specified by an iovec array.</a>
<a name="ln3436">*/</a>
<a name="ln3437">static void</a>
<a name="ln3438">zero_iovecs(const iovec* vecs, size_t vecCount, size_t bytes)</a>
<a name="ln3439">{</a>
<a name="ln3440">	for (size_t i = 0; i &lt; vecCount &amp;&amp; bytes &gt; 0; i++) {</a>
<a name="ln3441">		size_t length = std::min(vecs[i].iov_len, bytes);</a>
<a name="ln3442">		memset(vecs[i].iov_base, 0, length);</a>
<a name="ln3443">		bytes -= length;</a>
<a name="ln3444">	}</a>
<a name="ln3445">}</a>
<a name="ln3446"> </a>
<a name="ln3447"> </a>
<a name="ln3448">/*!	Does the dirty work of combining the file_io_vecs with the iovecs</a>
<a name="ln3449">	and calls the file system hooks to read/write the request to disk.</a>
<a name="ln3450">*/</a>
<a name="ln3451">static status_t</a>
<a name="ln3452">common_file_io_vec_pages(struct vnode* vnode, void* cookie,</a>
<a name="ln3453">	const file_io_vec* fileVecs, size_t fileVecCount, const iovec* vecs,</a>
<a name="ln3454">	size_t vecCount, uint32* _vecIndex, size_t* _vecOffset, size_t* _numBytes,</a>
<a name="ln3455">	bool doWrite)</a>
<a name="ln3456">{</a>
<a name="ln3457">	if (fileVecCount == 0) {</a>
<a name="ln3458">		// There are no file vecs at this offset, so we're obviously trying</a>
<a name="ln3459">		// to access the file outside of its bounds</a>
<a name="ln3460">		return B_BAD_VALUE;</a>
<a name="ln3461">	}</a>
<a name="ln3462"> </a>
<a name="ln3463">	size_t numBytes = *_numBytes;</a>
<a name="ln3464">	uint32 fileVecIndex;</a>
<a name="ln3465">	size_t vecOffset = *_vecOffset;</a>
<a name="ln3466">	uint32 vecIndex = *_vecIndex;</a>
<a name="ln3467">	status_t status;</a>
<a name="ln3468">	size_t size;</a>
<a name="ln3469"> </a>
<a name="ln3470">	if (!doWrite &amp;&amp; vecOffset == 0) {</a>
<a name="ln3471">		// now directly read the data from the device</a>
<a name="ln3472">		// the first file_io_vec can be read directly</a>
<a name="ln3473"> </a>
<a name="ln3474">		if (fileVecs[0].length &lt; (off_t)numBytes)</a>
<a name="ln3475">			size = fileVecs[0].length;</a>
<a name="ln3476">		else</a>
<a name="ln3477">			size = numBytes;</a>
<a name="ln3478"> </a>
<a name="ln3479">		if (fileVecs[0].offset &gt;= 0) {</a>
<a name="ln3480">			status = FS_CALL(vnode, read_pages, cookie, fileVecs[0].offset,</a>
<a name="ln3481">				&amp;vecs[vecIndex], vecCount - vecIndex, &amp;size);</a>
<a name="ln3482">		} else {</a>
<a name="ln3483">			// sparse read</a>
<a name="ln3484">			zero_iovecs(&amp;vecs[vecIndex], vecCount - vecIndex, size);</a>
<a name="ln3485">			status = B_OK;</a>
<a name="ln3486">		}</a>
<a name="ln3487">		if (status != B_OK)</a>
<a name="ln3488">			return status;</a>
<a name="ln3489"> </a>
<a name="ln3490">		// TODO: this is a work-around for buggy device drivers!</a>
<a name="ln3491">		//	When our own drivers honour the length, we can:</a>
<a name="ln3492">		//	a) also use this direct I/O for writes (otherwise, it would</a>
<a name="ln3493">		//	   overwrite precious data)</a>
<a name="ln3494">		//	b) panic if the term below is true (at least for writes)</a>
<a name="ln3495">		if ((off_t)size &gt; fileVecs[0].length) {</a>
<a name="ln3496">			//dprintf(&quot;warning: device driver %p doesn't respect total length &quot;</a>
<a name="ln3497">			//	&quot;in read_pages() call!\n&quot;, ref-&gt;device);</a>
<a name="ln3498">			size = fileVecs[0].length;</a>
<a name="ln3499">		}</a>
<a name="ln3500"> </a>
<a name="ln3501">		ASSERT((off_t)size &lt;= fileVecs[0].length);</a>
<a name="ln3502"> </a>
<a name="ln3503">		// If the file portion was contiguous, we're already done now</a>
<a name="ln3504">		if (size == numBytes)</a>
<a name="ln3505">			return B_OK;</a>
<a name="ln3506"> </a>
<a name="ln3507">		// if we reached the end of the file, we can return as well</a>
<a name="ln3508">		if ((off_t)size != fileVecs[0].length) {</a>
<a name="ln3509">			*_numBytes = size;</a>
<a name="ln3510">			return B_OK;</a>
<a name="ln3511">		}</a>
<a name="ln3512"> </a>
<a name="ln3513">		fileVecIndex = 1;</a>
<a name="ln3514"> </a>
<a name="ln3515">		// first, find out where we have to continue in our iovecs</a>
<a name="ln3516">		for (; vecIndex &lt; vecCount; vecIndex++) {</a>
<a name="ln3517">			if (size &lt; vecs[vecIndex].iov_len)</a>
<a name="ln3518">				break;</a>
<a name="ln3519"> </a>
<a name="ln3520">			size -= vecs[vecIndex].iov_len;</a>
<a name="ln3521">		}</a>
<a name="ln3522"> </a>
<a name="ln3523">		vecOffset = size;</a>
<a name="ln3524">	} else {</a>
<a name="ln3525">		fileVecIndex = 0;</a>
<a name="ln3526">		size = 0;</a>
<a name="ln3527">	}</a>
<a name="ln3528"> </a>
<a name="ln3529">	// Too bad, let's process the rest of the file_io_vecs</a>
<a name="ln3530"> </a>
<a name="ln3531">	size_t totalSize = size;</a>
<a name="ln3532">	size_t bytesLeft = numBytes - size;</a>
<a name="ln3533"> </a>
<a name="ln3534">	for (; fileVecIndex &lt; fileVecCount; fileVecIndex++) {</a>
<a name="ln3535">		const file_io_vec &amp;fileVec = fileVecs[fileVecIndex];</a>
<a name="ln3536">		off_t fileOffset = fileVec.offset;</a>
<a name="ln3537">		off_t fileLeft = min_c(fileVec.length, (off_t)bytesLeft);</a>
<a name="ln3538"> </a>
<a name="ln3539">		TRACE((&quot;FILE VEC [%&quot; B_PRIu32 &quot;] length %&quot; B_PRIdOFF &quot;\n&quot;, fileVecIndex,</a>
<a name="ln3540">			fileLeft));</a>
<a name="ln3541"> </a>
<a name="ln3542">		// process the complete fileVec</a>
<a name="ln3543">		while (fileLeft &gt; 0) {</a>
<a name="ln3544">			iovec tempVecs[MAX_TEMP_IO_VECS];</a>
<a name="ln3545">			uint32 tempCount = 0;</a>
<a name="ln3546"> </a>
<a name="ln3547">			// size tracks how much of what is left of the current fileVec</a>
<a name="ln3548">			// (fileLeft) has been assigned to tempVecs</a>
<a name="ln3549">			size = 0;</a>
<a name="ln3550"> </a>
<a name="ln3551">			// assign what is left of the current fileVec to the tempVecs</a>
<a name="ln3552">			for (size = 0; (off_t)size &lt; fileLeft &amp;&amp; vecIndex &lt; vecCount</a>
<a name="ln3553">					&amp;&amp; tempCount &lt; MAX_TEMP_IO_VECS;) {</a>
<a name="ln3554">				// try to satisfy one iovec per iteration (or as much as</a>
<a name="ln3555">				// possible)</a>
<a name="ln3556"> </a>
<a name="ln3557">				// bytes left of the current iovec</a>
<a name="ln3558">				size_t vecLeft = vecs[vecIndex].iov_len - vecOffset;</a>
<a name="ln3559">				if (vecLeft == 0) {</a>
<a name="ln3560">					vecOffset = 0;</a>
<a name="ln3561">					vecIndex++;</a>
<a name="ln3562">					continue;</a>
<a name="ln3563">				}</a>
<a name="ln3564"> </a>
<a name="ln3565">				TRACE((&quot;fill vec %&quot; B_PRIu32 &quot;, offset = %lu, size = %lu\n&quot;,</a>
<a name="ln3566">					vecIndex, vecOffset, size));</a>
<a name="ln3567"> </a>
<a name="ln3568">				// actually available bytes</a>
<a name="ln3569">				size_t tempVecSize = min_c(vecLeft, fileLeft - size);</a>
<a name="ln3570"> </a>
<a name="ln3571">				tempVecs[tempCount].iov_base</a>
<a name="ln3572">					= (void*)((addr_t)vecs[vecIndex].iov_base + vecOffset);</a>
<a name="ln3573">				tempVecs[tempCount].iov_len = tempVecSize;</a>
<a name="ln3574">				tempCount++;</a>
<a name="ln3575"> </a>
<a name="ln3576">				size += tempVecSize;</a>
<a name="ln3577">				vecOffset += tempVecSize;</a>
<a name="ln3578">			}</a>
<a name="ln3579"> </a>
<a name="ln3580">			size_t bytes = size;</a>
<a name="ln3581"> </a>
<a name="ln3582">			if (fileOffset == -1) {</a>
<a name="ln3583">				if (doWrite) {</a>
<a name="ln3584">					panic(&quot;sparse write attempt: vnode %p&quot;, vnode);</a>
<a name="ln3585">					status = B_IO_ERROR;</a>
<a name="ln3586">				} else {</a>
<a name="ln3587">					// sparse read</a>
<a name="ln3588">					zero_iovecs(tempVecs, tempCount, bytes);</a>
<a name="ln3589">					status = B_OK;</a>
<a name="ln3590">				}</a>
<a name="ln3591">			} else if (doWrite) {</a>
<a name="ln3592">				status = FS_CALL(vnode, write_pages, cookie, fileOffset,</a>
<a name="ln3593">					tempVecs, tempCount, &amp;bytes);</a>
<a name="ln3594">			} else {</a>
<a name="ln3595">				status = FS_CALL(vnode, read_pages, cookie, fileOffset,</a>
<a name="ln3596">					tempVecs, tempCount, &amp;bytes);</a>
<a name="ln3597">			}</a>
<a name="ln3598">			if (status != B_OK)</a>
<a name="ln3599">				return status;</a>
<a name="ln3600"> </a>
<a name="ln3601">			totalSize += bytes;</a>
<a name="ln3602">			bytesLeft -= size;</a>
<a name="ln3603">			if (fileOffset &gt;= 0)</a>
<a name="ln3604">				fileOffset += size;</a>
<a name="ln3605">			fileLeft -= size;</a>
<a name="ln3606">			//dprintf(&quot;-&gt; file left = %Lu\n&quot;, fileLeft);</a>
<a name="ln3607"> </a>
<a name="ln3608">			if (size != bytes || vecIndex &gt;= vecCount) {</a>
<a name="ln3609">				// there are no more bytes or iovecs, let's bail out</a>
<a name="ln3610">				*_numBytes = totalSize;</a>
<a name="ln3611">				return B_OK;</a>
<a name="ln3612">			}</a>
<a name="ln3613">		}</a>
<a name="ln3614">	}</a>
<a name="ln3615"> </a>
<a name="ln3616">	*_vecIndex = vecIndex;</a>
<a name="ln3617">	*_vecOffset = vecOffset;</a>
<a name="ln3618">	*_numBytes = totalSize;</a>
<a name="ln3619">	return B_OK;</a>
<a name="ln3620">}</a>
<a name="ln3621"> </a>
<a name="ln3622"> </a>
<a name="ln3623">static bool</a>
<a name="ln3624">is_user_in_group(gid_t gid)</a>
<a name="ln3625">{</a>
<a name="ln3626">	if (gid == getegid())</a>
<a name="ln3627">		return true;</a>
<a name="ln3628"> </a>
<a name="ln3629">	gid_t groups[NGROUPS_MAX];</a>
<a name="ln3630">	int groupCount = getgroups(NGROUPS_MAX, groups);</a>
<a name="ln3631">	for (int i = 0; i &lt; groupCount; i++) {</a>
<a name="ln3632">		if (gid == groups[i])</a>
<a name="ln3633">			return true;</a>
<a name="ln3634">	}</a>
<a name="ln3635"> </a>
<a name="ln3636">	return false;</a>
<a name="ln3637">}</a>
<a name="ln3638"> </a>
<a name="ln3639"> </a>
<a name="ln3640">static status_t</a>
<a name="ln3641">free_io_context(io_context* context)</a>
<a name="ln3642">{</a>
<a name="ln3643">	uint32 i;</a>
<a name="ln3644"> </a>
<a name="ln3645">	TIOC(FreeIOContext(context));</a>
<a name="ln3646"> </a>
<a name="ln3647">	if (context-&gt;root)</a>
<a name="ln3648">		put_vnode(context-&gt;root);</a>
<a name="ln3649"> </a>
<a name="ln3650">	if (context-&gt;cwd)</a>
<a name="ln3651">		put_vnode(context-&gt;cwd);</a>
<a name="ln3652"> </a>
<a name="ln3653">	mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln3654"> </a>
<a name="ln3655">	for (i = 0; i &lt; context-&gt;table_size; i++) {</a>
<a name="ln3656">		if (struct file_descriptor* descriptor = context-&gt;fds[i]) {</a>
<a name="ln3657">			close_fd(context, descriptor);</a>
<a name="ln3658">			put_fd(descriptor);</a>
<a name="ln3659">		}</a>
<a name="ln3660">	}</a>
<a name="ln3661"> </a>
<a name="ln3662">	mutex_destroy(&amp;context-&gt;io_mutex);</a>
<a name="ln3663"> </a>
<a name="ln3664">	remove_node_monitors(context);</a>
<a name="ln3665">	free(context-&gt;fds);</a>
<a name="ln3666">	free(context);</a>
<a name="ln3667"> </a>
<a name="ln3668">	return B_OK;</a>
<a name="ln3669">}</a>
<a name="ln3670"> </a>
<a name="ln3671"> </a>
<a name="ln3672">static status_t</a>
<a name="ln3673">resize_monitor_table(struct io_context* context, const int newSize)</a>
<a name="ln3674">{</a>
<a name="ln3675">	int	status = B_OK;</a>
<a name="ln3676"> </a>
<a name="ln3677">	if (newSize &lt;= 0 || newSize &gt; MAX_NODE_MONITORS)</a>
<a name="ln3678">		return B_BAD_VALUE;</a>
<a name="ln3679"> </a>
<a name="ln3680">	mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln3681"> </a>
<a name="ln3682">	if ((size_t)newSize &lt; context-&gt;num_monitors) {</a>
<a name="ln3683">		status = B_BUSY;</a>
<a name="ln3684">		goto out;</a>
<a name="ln3685">	}</a>
<a name="ln3686">	context-&gt;max_monitors = newSize;</a>
<a name="ln3687"> </a>
<a name="ln3688">out:</a>
<a name="ln3689">	mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln3690">	return status;</a>
<a name="ln3691">}</a>
<a name="ln3692"> </a>
<a name="ln3693"> </a>
<a name="ln3694">//	#pragma mark - public API for file systems</a>
<a name="ln3695"> </a>
<a name="ln3696"> </a>
<a name="ln3697">extern &quot;C&quot; status_t</a>
<a name="ln3698">new_vnode(fs_volume* volume, ino_t vnodeID, void* privateNode,</a>
<a name="ln3699">	fs_vnode_ops* ops)</a>
<a name="ln3700">{</a>
<a name="ln3701">	FUNCTION((&quot;new_vnode(volume = %p (%&quot; B_PRId32 &quot;), vnodeID = %&quot; B_PRId64</a>
<a name="ln3702">		&quot;, node = %p)\n&quot;, volume, volume-&gt;id, vnodeID, privateNode));</a>
<a name="ln3703"> </a>
<a name="ln3704">	if (privateNode == NULL)</a>
<a name="ln3705">		return B_BAD_VALUE;</a>
<a name="ln3706"> </a>
<a name="ln3707">	int32 tries = BUSY_VNODE_RETRIES;</a>
<a name="ln3708">restart:</a>
<a name="ln3709">	// create the node</a>
<a name="ln3710">	bool nodeCreated;</a>
<a name="ln3711">	struct vnode* vnode;</a>
<a name="ln3712">	status_t status = create_new_vnode_and_lock(volume-&gt;id, vnodeID, vnode,</a>
<a name="ln3713">		nodeCreated);</a>
<a name="ln3714">	if (status != B_OK)</a>
<a name="ln3715">		return status;</a>
<a name="ln3716"> </a>
<a name="ln3717">	WriteLocker nodeLocker(sVnodeLock, true);</a>
<a name="ln3718">		// create_new_vnode_and_lock() has locked for us</a>
<a name="ln3719"> </a>
<a name="ln3720">	if (!nodeCreated &amp;&amp; vnode-&gt;IsBusy()) {</a>
<a name="ln3721">		nodeLocker.Unlock();</a>
<a name="ln3722">		if (!retry_busy_vnode(tries, volume-&gt;id, vnodeID))</a>
<a name="ln3723">			return B_BUSY;</a>
<a name="ln3724">		goto restart;</a>
<a name="ln3725">	}</a>
<a name="ln3726"> </a>
<a name="ln3727">	// file system integrity check:</a>
<a name="ln3728">	// test if the vnode already exists and bail out if this is the case!</a>
<a name="ln3729">	if (!nodeCreated) {</a>
<a name="ln3730">		panic(&quot;vnode %&quot; B_PRIdDEV &quot;:%&quot; B_PRIdINO &quot; already exists (node = %p, &quot;</a>
<a name="ln3731">			&quot;vnode-&gt;node = %p)!&quot;, volume-&gt;id, vnodeID, privateNode,</a>
<a name="ln3732">			vnode-&gt;private_node);</a>
<a name="ln3733">		return B_ERROR;</a>
<a name="ln3734">	}</a>
<a name="ln3735"> </a>
<a name="ln3736">	vnode-&gt;private_node = privateNode;</a>
<a name="ln3737">	vnode-&gt;ops = ops;</a>
<a name="ln3738">	vnode-&gt;SetUnpublished(true);</a>
<a name="ln3739"> </a>
<a name="ln3740">	TRACE((&quot;returns: %s\n&quot;, strerror(status)));</a>
<a name="ln3741"> </a>
<a name="ln3742">	return status;</a>
<a name="ln3743">}</a>
<a name="ln3744"> </a>
<a name="ln3745"> </a>
<a name="ln3746">extern &quot;C&quot; status_t</a>
<a name="ln3747">publish_vnode(fs_volume* volume, ino_t vnodeID, void* privateNode,</a>
<a name="ln3748">	fs_vnode_ops* ops, int type, uint32 flags)</a>
<a name="ln3749">{</a>
<a name="ln3750">	FUNCTION((&quot;publish_vnode()\n&quot;));</a>
<a name="ln3751"> </a>
<a name="ln3752">	int32 tries = BUSY_VNODE_RETRIES;</a>
<a name="ln3753">restart:</a>
<a name="ln3754">	WriteLocker locker(sVnodeLock);</a>
<a name="ln3755"> </a>
<a name="ln3756">	struct vnode* vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln3757"> </a>
<a name="ln3758">	bool nodeCreated = false;</a>
<a name="ln3759">	if (vnode == NULL) {</a>
<a name="ln3760">		if (privateNode == NULL)</a>
<a name="ln3761">			return B_BAD_VALUE;</a>
<a name="ln3762"> </a>
<a name="ln3763">		// create the node</a>
<a name="ln3764">		locker.Unlock();</a>
<a name="ln3765">			// create_new_vnode_and_lock() will re-lock for us on success</a>
<a name="ln3766">		status_t status = create_new_vnode_and_lock(volume-&gt;id, vnodeID, vnode,</a>
<a name="ln3767">			nodeCreated);</a>
<a name="ln3768">		if (status != B_OK)</a>
<a name="ln3769">			return status;</a>
<a name="ln3770"> </a>
<a name="ln3771">		locker.SetTo(sVnodeLock, true);</a>
<a name="ln3772">	}</a>
<a name="ln3773"> </a>
<a name="ln3774">	if (nodeCreated) {</a>
<a name="ln3775">		vnode-&gt;private_node = privateNode;</a>
<a name="ln3776">		vnode-&gt;ops = ops;</a>
<a name="ln3777">		vnode-&gt;SetUnpublished(true);</a>
<a name="ln3778">	} else if (vnode-&gt;IsBusy() &amp;&amp; vnode-&gt;IsUnpublished()</a>
<a name="ln3779">		&amp;&amp; vnode-&gt;private_node == privateNode &amp;&amp; vnode-&gt;ops == ops) {</a>
<a name="ln3780">		// already known, but not published</a>
<a name="ln3781">	} else if (vnode-&gt;IsBusy()) {</a>
<a name="ln3782">		locker.Unlock();</a>
<a name="ln3783">		if (!retry_busy_vnode(tries, volume-&gt;id, vnodeID))</a>
<a name="ln3784">			return B_BUSY;</a>
<a name="ln3785">		goto restart;</a>
<a name="ln3786">	} else</a>
<a name="ln3787">		return B_BAD_VALUE;</a>
<a name="ln3788"> </a>
<a name="ln3789">	bool publishSpecialSubNode = false;</a>
<a name="ln3790"> </a>
<a name="ln3791">	vnode-&gt;SetType(type);</a>
<a name="ln3792">	vnode-&gt;SetRemoved((flags &amp; B_VNODE_PUBLISH_REMOVED) != 0);</a>
<a name="ln3793">	publishSpecialSubNode = is_special_node_type(type)</a>
<a name="ln3794">		&amp;&amp; (flags &amp; B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE) == 0;</a>
<a name="ln3795"> </a>
<a name="ln3796">	status_t status = B_OK;</a>
<a name="ln3797"> </a>
<a name="ln3798">	// create sub vnodes, if necessary</a>
<a name="ln3799">	if (volume-&gt;sub_volume != NULL || publishSpecialSubNode) {</a>
<a name="ln3800">		locker.Unlock();</a>
<a name="ln3801"> </a>
<a name="ln3802">		fs_volume* subVolume = volume;</a>
<a name="ln3803">		if (volume-&gt;sub_volume != NULL) {</a>
<a name="ln3804">			while (status == B_OK &amp;&amp; subVolume-&gt;sub_volume != NULL) {</a>
<a name="ln3805">				subVolume = subVolume-&gt;sub_volume;</a>
<a name="ln3806">				status = subVolume-&gt;ops-&gt;create_sub_vnode(subVolume, vnodeID,</a>
<a name="ln3807">					vnode);</a>
<a name="ln3808">			}</a>
<a name="ln3809">		}</a>
<a name="ln3810"> </a>
<a name="ln3811">		if (status == B_OK &amp;&amp; publishSpecialSubNode)</a>
<a name="ln3812">			status = create_special_sub_node(vnode, flags);</a>
<a name="ln3813"> </a>
<a name="ln3814">		if (status != B_OK) {</a>
<a name="ln3815">			// error -- clean up the created sub vnodes</a>
<a name="ln3816">			while (subVolume-&gt;super_volume != volume) {</a>
<a name="ln3817">				subVolume = subVolume-&gt;super_volume;</a>
<a name="ln3818">				subVolume-&gt;ops-&gt;delete_sub_vnode(subVolume, vnode);</a>
<a name="ln3819">			}</a>
<a name="ln3820">		}</a>
<a name="ln3821"> </a>
<a name="ln3822">		if (status == B_OK) {</a>
<a name="ln3823">			ReadLocker vnodesReadLocker(sVnodeLock);</a>
<a name="ln3824">			AutoLocker&lt;Vnode&gt; nodeLocker(vnode);</a>
<a name="ln3825">			vnode-&gt;SetBusy(false);</a>
<a name="ln3826">			vnode-&gt;SetUnpublished(false);</a>
<a name="ln3827">		} else {</a>
<a name="ln3828">			locker.Lock();</a>
<a name="ln3829">			sVnodeTable-&gt;Remove(vnode);</a>
<a name="ln3830">			remove_vnode_from_mount_list(vnode, vnode-&gt;mount);</a>
<a name="ln3831">			free(vnode);</a>
<a name="ln3832">		}</a>
<a name="ln3833">	} else {</a>
<a name="ln3834">		// we still hold the write lock -- mark the node unbusy and published</a>
<a name="ln3835">		vnode-&gt;SetBusy(false);</a>
<a name="ln3836">		vnode-&gt;SetUnpublished(false);</a>
<a name="ln3837">	}</a>
<a name="ln3838"> </a>
<a name="ln3839">	TRACE((&quot;returns: %s\n&quot;, strerror(status)));</a>
<a name="ln3840"> </a>
<a name="ln3841">	return status;</a>
<a name="ln3842">}</a>
<a name="ln3843"> </a>
<a name="ln3844"> </a>
<a name="ln3845">extern &quot;C&quot; status_t</a>
<a name="ln3846">get_vnode(fs_volume* volume, ino_t vnodeID, void** _privateNode)</a>
<a name="ln3847">{</a>
<a name="ln3848">	struct vnode* vnode;</a>
<a name="ln3849"> </a>
<a name="ln3850">	if (volume == NULL)</a>
<a name="ln3851">		return B_BAD_VALUE;</a>
<a name="ln3852"> </a>
<a name="ln3853">	status_t status = get_vnode(volume-&gt;id, vnodeID, &amp;vnode, true, true);</a>
<a name="ln3854">	if (status != B_OK)</a>
<a name="ln3855">		return status;</a>
<a name="ln3856"> </a>
<a name="ln3857">	// If this is a layered FS, we need to get the node cookie for the requested</a>
<a name="ln3858">	// layer.</a>
<a name="ln3859">	if (HAS_FS_CALL(vnode, get_super_vnode)) {</a>
<a name="ln3860">		fs_vnode resolvedNode;</a>
<a name="ln3861">		status_t status = FS_CALL(vnode, get_super_vnode, volume,</a>
<a name="ln3862">			&amp;resolvedNode);</a>
<a name="ln3863">		if (status != B_OK) {</a>
<a name="ln3864">			panic(&quot;get_vnode(): Failed to get super node for vnode %p, &quot;</a>
<a name="ln3865">				&quot;volume: %p&quot;, vnode, volume);</a>
<a name="ln3866">			put_vnode(vnode);</a>
<a name="ln3867">			return status;</a>
<a name="ln3868">		}</a>
<a name="ln3869"> </a>
<a name="ln3870">		if (_privateNode != NULL)</a>
<a name="ln3871">			*_privateNode = resolvedNode.private_node;</a>
<a name="ln3872">	} else if (_privateNode != NULL)</a>
<a name="ln3873">		*_privateNode = vnode-&gt;private_node;</a>
<a name="ln3874"> </a>
<a name="ln3875">	return B_OK;</a>
<a name="ln3876">}</a>
<a name="ln3877"> </a>
<a name="ln3878"> </a>
<a name="ln3879">extern &quot;C&quot; status_t</a>
<a name="ln3880">acquire_vnode(fs_volume* volume, ino_t vnodeID)</a>
<a name="ln3881">{</a>
<a name="ln3882">	struct vnode* vnode;</a>
<a name="ln3883"> </a>
<a name="ln3884">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln3885">	vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln3886">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln3887"> </a>
<a name="ln3888">	if (vnode == NULL)</a>
<a name="ln3889">		return B_BAD_VALUE;</a>
<a name="ln3890"> </a>
<a name="ln3891">	inc_vnode_ref_count(vnode);</a>
<a name="ln3892">	return B_OK;</a>
<a name="ln3893">}</a>
<a name="ln3894"> </a>
<a name="ln3895"> </a>
<a name="ln3896">extern &quot;C&quot; status_t</a>
<a name="ln3897">put_vnode(fs_volume* volume, ino_t vnodeID)</a>
<a name="ln3898">{</a>
<a name="ln3899">	struct vnode* vnode;</a>
<a name="ln3900"> </a>
<a name="ln3901">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln3902">	vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln3903">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln3904"> </a>
<a name="ln3905">	if (vnode == NULL)</a>
<a name="ln3906">		return B_BAD_VALUE;</a>
<a name="ln3907"> </a>
<a name="ln3908">	dec_vnode_ref_count(vnode, false, true);</a>
<a name="ln3909">	return B_OK;</a>
<a name="ln3910">}</a>
<a name="ln3911"> </a>
<a name="ln3912"> </a>
<a name="ln3913">extern &quot;C&quot; status_t</a>
<a name="ln3914">remove_vnode(fs_volume* volume, ino_t vnodeID)</a>
<a name="ln3915">{</a>
<a name="ln3916">	ReadLocker locker(sVnodeLock);</a>
<a name="ln3917"> </a>
<a name="ln3918">	struct vnode* vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln3919">	if (vnode == NULL)</a>
<a name="ln3920">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln3921"> </a>
<a name="ln3922">	if (vnode-&gt;covered_by != NULL || vnode-&gt;covers != NULL) {</a>
<a name="ln3923">		// this vnode is in use</a>
<a name="ln3924">		return B_BUSY;</a>
<a name="ln3925">	}</a>
<a name="ln3926"> </a>
<a name="ln3927">	vnode-&gt;Lock();</a>
<a name="ln3928"> </a>
<a name="ln3929">	vnode-&gt;SetRemoved(true);</a>
<a name="ln3930">	bool removeUnpublished = false;</a>
<a name="ln3931"> </a>
<a name="ln3932">	if (vnode-&gt;IsUnpublished()) {</a>
<a name="ln3933">		// prepare the vnode for deletion</a>
<a name="ln3934">		removeUnpublished = true;</a>
<a name="ln3935">		vnode-&gt;SetBusy(true);</a>
<a name="ln3936">	}</a>
<a name="ln3937"> </a>
<a name="ln3938">	vnode-&gt;Unlock();</a>
<a name="ln3939">	locker.Unlock();</a>
<a name="ln3940"> </a>
<a name="ln3941">	if (removeUnpublished) {</a>
<a name="ln3942">		// If the vnode hasn't been published yet, we delete it here</a>
<a name="ln3943">		atomic_add(&amp;vnode-&gt;ref_count, -1);</a>
<a name="ln3944">		free_vnode(vnode, true);</a>
<a name="ln3945">	}</a>
<a name="ln3946"> </a>
<a name="ln3947">	return B_OK;</a>
<a name="ln3948">}</a>
<a name="ln3949"> </a>
<a name="ln3950"> </a>
<a name="ln3951">extern &quot;C&quot; status_t</a>
<a name="ln3952">unremove_vnode(fs_volume* volume, ino_t vnodeID)</a>
<a name="ln3953">{</a>
<a name="ln3954">	struct vnode* vnode;</a>
<a name="ln3955"> </a>
<a name="ln3956">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln3957"> </a>
<a name="ln3958">	vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln3959">	if (vnode) {</a>
<a name="ln3960">		AutoLocker&lt;Vnode&gt; nodeLocker(vnode);</a>
<a name="ln3961">		vnode-&gt;SetRemoved(false);</a>
<a name="ln3962">	}</a>
<a name="ln3963"> </a>
<a name="ln3964">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln3965">	return B_OK;</a>
<a name="ln3966">}</a>
<a name="ln3967"> </a>
<a name="ln3968"> </a>
<a name="ln3969">extern &quot;C&quot; status_t</a>
<a name="ln3970">get_vnode_removed(fs_volume* volume, ino_t vnodeID, bool* _removed)</a>
<a name="ln3971">{</a>
<a name="ln3972">	ReadLocker _(sVnodeLock);</a>
<a name="ln3973"> </a>
<a name="ln3974">	if (struct vnode* vnode = lookup_vnode(volume-&gt;id, vnodeID)) {</a>
<a name="ln3975">		if (_removed != NULL)</a>
<a name="ln3976">			*_removed = vnode-&gt;IsRemoved();</a>
<a name="ln3977">		return B_OK;</a>
<a name="ln3978">	}</a>
<a name="ln3979"> </a>
<a name="ln3980">	return B_BAD_VALUE;</a>
<a name="ln3981">}</a>
<a name="ln3982"> </a>
<a name="ln3983"> </a>
<a name="ln3984">extern &quot;C&quot; status_t</a>
<a name="ln3985">mark_vnode_busy(fs_volume* volume, ino_t vnodeID, bool busy)</a>
<a name="ln3986">{</a>
<a name="ln3987">	ReadLocker locker(sVnodeLock);</a>
<a name="ln3988"> </a>
<a name="ln3989">	struct vnode* vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln3990">	if (vnode == NULL)</a>
<a name="ln3991">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln3992"> </a>
<a name="ln3993">	// are we trying to mark an already busy node busy again?</a>
<a name="ln3994">	if (busy &amp;&amp; vnode-&gt;IsBusy())</a>
<a name="ln3995">		return B_BUSY;</a>
<a name="ln3996"> </a>
<a name="ln3997">	vnode-&gt;Lock();</a>
<a name="ln3998">	vnode-&gt;SetBusy(busy);</a>
<a name="ln3999">	vnode-&gt;Unlock();</a>
<a name="ln4000"> </a>
<a name="ln4001">	return B_OK;</a>
<a name="ln4002">}</a>
<a name="ln4003"> </a>
<a name="ln4004"> </a>
<a name="ln4005">extern &quot;C&quot; status_t</a>
<a name="ln4006">change_vnode_id(fs_volume* volume, ino_t vnodeID, ino_t newID)</a>
<a name="ln4007">{</a>
<a name="ln4008">	WriteLocker locker(sVnodeLock);</a>
<a name="ln4009"> </a>
<a name="ln4010">	struct vnode* vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln4011">	if (vnode == NULL)</a>
<a name="ln4012">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln4013"> </a>
<a name="ln4014">	sVnodeTable-&gt;Remove(vnode);</a>
<a name="ln4015">	vnode-&gt;id = newID;</a>
<a name="ln4016">	sVnodeTable-&gt;Insert(vnode);</a>
<a name="ln4017"> </a>
<a name="ln4018">	if (vnode-&gt;cache != NULL)</a>
<a name="ln4019">		((VMVnodeCache*)vnode-&gt;cache)-&gt;SetVnodeID(newID);</a>
<a name="ln4020"> </a>
<a name="ln4021">	return B_OK;</a>
<a name="ln4022">}</a>
<a name="ln4023"> </a>
<a name="ln4024"> </a>
<a name="ln4025">extern &quot;C&quot; fs_volume*</a>
<a name="ln4026">volume_for_vnode(fs_vnode* _vnode)</a>
<a name="ln4027">{</a>
<a name="ln4028">	if (_vnode == NULL)</a>
<a name="ln4029">		return NULL;</a>
<a name="ln4030"> </a>
<a name="ln4031">	struct vnode* vnode = static_cast&lt;struct vnode*&gt;(_vnode);</a>
<a name="ln4032">	return vnode-&gt;mount-&gt;volume;</a>
<a name="ln4033">}</a>
<a name="ln4034"> </a>
<a name="ln4035"> </a>
<a name="ln4036">extern &quot;C&quot; status_t</a>
<a name="ln4037">check_access_permissions(int accessMode, mode_t mode, gid_t nodeGroupID,</a>
<a name="ln4038">	uid_t nodeUserID)</a>
<a name="ln4039">{</a>
<a name="ln4040">	// get node permissions</a>
<a name="ln4041">	int userPermissions = (mode &amp; S_IRWXU) &gt;&gt; 6;</a>
<a name="ln4042">	int groupPermissions = (mode &amp; S_IRWXG) &gt;&gt; 3;</a>
<a name="ln4043">	int otherPermissions = mode &amp; S_IRWXO;</a>
<a name="ln4044"> </a>
<a name="ln4045">	// get the node permissions for this uid/gid</a>
<a name="ln4046">	int permissions = 0;</a>
<a name="ln4047">	uid_t uid = geteuid();</a>
<a name="ln4048"> </a>
<a name="ln4049">	if (uid == 0) {</a>
<a name="ln4050">		// user is root</a>
<a name="ln4051">		// root has always read/write permission, but at least one of the</a>
<a name="ln4052">		// X bits must be set for execute permission</a>
<a name="ln4053">		permissions = userPermissions | groupPermissions | otherPermissions</a>
<a name="ln4054">			| S_IROTH | S_IWOTH;</a>
<a name="ln4055">		if (S_ISDIR(mode))</a>
<a name="ln4056">			permissions |= S_IXOTH;</a>
<a name="ln4057">	} else if (uid == nodeUserID) {</a>
<a name="ln4058">		// user is node owner</a>
<a name="ln4059">		permissions = userPermissions;</a>
<a name="ln4060">	} else if (is_user_in_group(nodeGroupID)) {</a>
<a name="ln4061">		// user is in owning group</a>
<a name="ln4062">		permissions = groupPermissions;</a>
<a name="ln4063">	} else {</a>
<a name="ln4064">		// user is one of the others</a>
<a name="ln4065">		permissions = otherPermissions;</a>
<a name="ln4066">	}</a>
<a name="ln4067"> </a>
<a name="ln4068">	return (accessMode &amp; ~permissions) == 0 ? B_OK : B_PERMISSION_DENIED;</a>
<a name="ln4069">}</a>
<a name="ln4070"> </a>
<a name="ln4071"> </a>
<a name="ln4072">#if 0</a>
<a name="ln4073">extern &quot;C&quot; status_t</a>
<a name="ln4074">read_pages(int fd, off_t pos, const iovec* vecs, size_t count,</a>
<a name="ln4075">	size_t* _numBytes)</a>
<a name="ln4076">{</a>
<a name="ln4077">	struct file_descriptor* descriptor;</a>
<a name="ln4078">	struct vnode* vnode;</a>
<a name="ln4079"> </a>
<a name="ln4080">	descriptor = get_fd_and_vnode(fd, &amp;vnode, true);</a>
<a name="ln4081">	if (descriptor == NULL)</a>
<a name="ln4082">		return B_FILE_ERROR;</a>
<a name="ln4083"> </a>
<a name="ln4084">	status_t status = vfs_read_pages(vnode, descriptor-&gt;cookie, pos, vecs,</a>
<a name="ln4085">		count, 0, _numBytes);</a>
<a name="ln4086"> </a>
<a name="ln4087">	put_fd(descriptor);</a>
<a name="ln4088">	return status;</a>
<a name="ln4089">}</a>
<a name="ln4090"> </a>
<a name="ln4091"> </a>
<a name="ln4092">extern &quot;C&quot; status_t</a>
<a name="ln4093">write_pages(int fd, off_t pos, const iovec* vecs, size_t count,</a>
<a name="ln4094">	size_t* _numBytes)</a>
<a name="ln4095">{</a>
<a name="ln4096">	struct file_descriptor* descriptor;</a>
<a name="ln4097">	struct vnode* vnode;</a>
<a name="ln4098"> </a>
<a name="ln4099">	descriptor = get_fd_and_vnode(fd, &amp;vnode, true);</a>
<a name="ln4100">	if (descriptor == NULL)</a>
<a name="ln4101">		return B_FILE_ERROR;</a>
<a name="ln4102"> </a>
<a name="ln4103">	status_t status = vfs_write_pages(vnode, descriptor-&gt;cookie, pos, vecs,</a>
<a name="ln4104">		count, 0, _numBytes);</a>
<a name="ln4105"> </a>
<a name="ln4106">	put_fd(descriptor);</a>
<a name="ln4107">	return status;</a>
<a name="ln4108">}</a>
<a name="ln4109">#endif</a>
<a name="ln4110"> </a>
<a name="ln4111"> </a>
<a name="ln4112">extern &quot;C&quot; status_t</a>
<a name="ln4113">read_file_io_vec_pages(int fd, const file_io_vec* fileVecs, size_t fileVecCount,</a>
<a name="ln4114">	const iovec* vecs, size_t vecCount, uint32* _vecIndex, size_t* _vecOffset,</a>
<a name="ln4115">	size_t* _bytes)</a>
<a name="ln4116">{</a>
<a name="ln4117">	struct file_descriptor* descriptor;</a>
<a name="ln4118">	struct vnode* vnode;</a>
<a name="ln4119"> </a>
<a name="ln4120">	descriptor = get_fd_and_vnode(fd, &amp;vnode, true);</a>
<a name="ln4121">	if (descriptor == NULL)</a>
<a name="ln4122">		return B_FILE_ERROR;</a>
<a name="ln4123"> </a>
<a name="ln4124">	status_t status = common_file_io_vec_pages(vnode, descriptor-&gt;cookie,</a>
<a name="ln4125">		fileVecs, fileVecCount, vecs, vecCount, _vecIndex, _vecOffset, _bytes,</a>
<a name="ln4126">		false);</a>
<a name="ln4127"> </a>
<a name="ln4128">	put_fd(descriptor);</a>
<a name="ln4129">	return status;</a>
<a name="ln4130">}</a>
<a name="ln4131"> </a>
<a name="ln4132"> </a>
<a name="ln4133">extern &quot;C&quot; status_t</a>
<a name="ln4134">write_file_io_vec_pages(int fd, const file_io_vec* fileVecs, size_t fileVecCount,</a>
<a name="ln4135">	const iovec* vecs, size_t vecCount, uint32* _vecIndex, size_t* _vecOffset,</a>
<a name="ln4136">	size_t* _bytes)</a>
<a name="ln4137">{</a>
<a name="ln4138">	struct file_descriptor* descriptor;</a>
<a name="ln4139">	struct vnode* vnode;</a>
<a name="ln4140"> </a>
<a name="ln4141">	descriptor = get_fd_and_vnode(fd, &amp;vnode, true);</a>
<a name="ln4142">	if (descriptor == NULL)</a>
<a name="ln4143">		return B_FILE_ERROR;</a>
<a name="ln4144"> </a>
<a name="ln4145">	status_t status = common_file_io_vec_pages(vnode, descriptor-&gt;cookie,</a>
<a name="ln4146">		fileVecs, fileVecCount, vecs, vecCount, _vecIndex, _vecOffset, _bytes,</a>
<a name="ln4147">		true);</a>
<a name="ln4148"> </a>
<a name="ln4149">	put_fd(descriptor);</a>
<a name="ln4150">	return status;</a>
<a name="ln4151">}</a>
<a name="ln4152"> </a>
<a name="ln4153"> </a>
<a name="ln4154">extern &quot;C&quot; status_t</a>
<a name="ln4155">entry_cache_add(dev_t mountID, ino_t dirID, const char* name, ino_t nodeID)</a>
<a name="ln4156">{</a>
<a name="ln4157">	// lookup mount -- the caller is required to make sure that the mount</a>
<a name="ln4158">	// won't go away</a>
<a name="ln4159">	MutexLocker locker(sMountMutex);</a>
<a name="ln4160">	struct fs_mount* mount = find_mount(mountID);</a>
<a name="ln4161">	if (mount == NULL)</a>
<a name="ln4162">		return B_BAD_VALUE;</a>
<a name="ln4163">	locker.Unlock();</a>
<a name="ln4164"> </a>
<a name="ln4165">	return mount-&gt;entry_cache.Add(dirID, name, nodeID, false);</a>
<a name="ln4166">}</a>
<a name="ln4167"> </a>
<a name="ln4168"> </a>
<a name="ln4169">extern &quot;C&quot; status_t</a>
<a name="ln4170">entry_cache_add_missing(dev_t mountID, ino_t dirID, const char* name)</a>
<a name="ln4171">{</a>
<a name="ln4172">	// lookup mount -- the caller is required to make sure that the mount</a>
<a name="ln4173">	// won't go away</a>
<a name="ln4174">	MutexLocker locker(sMountMutex);</a>
<a name="ln4175">	struct fs_mount* mount = find_mount(mountID);</a>
<a name="ln4176">	if (mount == NULL)</a>
<a name="ln4177">		return B_BAD_VALUE;</a>
<a name="ln4178">	locker.Unlock();</a>
<a name="ln4179"> </a>
<a name="ln4180">	return mount-&gt;entry_cache.Add(dirID, name, -1, true);</a>
<a name="ln4181">}</a>
<a name="ln4182"> </a>
<a name="ln4183"> </a>
<a name="ln4184">extern &quot;C&quot; status_t</a>
<a name="ln4185">entry_cache_remove(dev_t mountID, ino_t dirID, const char* name)</a>
<a name="ln4186">{</a>
<a name="ln4187">	// lookup mount -- the caller is required to make sure that the mount</a>
<a name="ln4188">	// won't go away</a>
<a name="ln4189">	MutexLocker locker(sMountMutex);</a>
<a name="ln4190">	struct fs_mount* mount = find_mount(mountID);</a>
<a name="ln4191">	if (mount == NULL)</a>
<a name="ln4192">		return B_BAD_VALUE;</a>
<a name="ln4193">	locker.Unlock();</a>
<a name="ln4194"> </a>
<a name="ln4195">	return mount-&gt;entry_cache.Remove(dirID, name);</a>
<a name="ln4196">}</a>
<a name="ln4197"> </a>
<a name="ln4198"> </a>
<a name="ln4199">//	#pragma mark - private VFS API</a>
<a name="ln4200">//	Functions the VFS exports for other parts of the kernel</a>
<a name="ln4201"> </a>
<a name="ln4202"> </a>
<a name="ln4203">/*! Acquires another reference to the vnode that has to be released</a>
<a name="ln4204">	by calling vfs_put_vnode().</a>
<a name="ln4205">*/</a>
<a name="ln4206">void</a>
<a name="ln4207">vfs_acquire_vnode(struct vnode* vnode)</a>
<a name="ln4208">{</a>
<a name="ln4209">	inc_vnode_ref_count(vnode);</a>
<a name="ln4210">}</a>
<a name="ln4211"> </a>
<a name="ln4212"> </a>
<a name="ln4213">/*! This is currently called from file_cache_create() only.</a>
<a name="ln4214">	It's probably a temporary solution as long as devfs requires that</a>
<a name="ln4215">	fs_read_pages()/fs_write_pages() are called with the standard</a>
<a name="ln4216">	open cookie and not with a device cookie.</a>
<a name="ln4217">	If that's done differently, remove this call; it has no other</a>
<a name="ln4218">	purpose.</a>
<a name="ln4219">*/</a>
<a name="ln4220">extern &quot;C&quot; status_t</a>
<a name="ln4221">vfs_get_cookie_from_fd(int fd, void** _cookie)</a>
<a name="ln4222">{</a>
<a name="ln4223">	struct file_descriptor* descriptor;</a>
<a name="ln4224"> </a>
<a name="ln4225">	descriptor = get_fd(get_current_io_context(true), fd);</a>
<a name="ln4226">	if (descriptor == NULL)</a>
<a name="ln4227">		return B_FILE_ERROR;</a>
<a name="ln4228"> </a>
<a name="ln4229">	*_cookie = descriptor-&gt;cookie;</a>
<a name="ln4230">	return B_OK;</a>
<a name="ln4231">}</a>
<a name="ln4232"> </a>
<a name="ln4233"> </a>
<a name="ln4234">extern &quot;C&quot; status_t</a>
<a name="ln4235">vfs_get_vnode_from_fd(int fd, bool kernel, struct vnode** vnode)</a>
<a name="ln4236">{</a>
<a name="ln4237">	*vnode = get_vnode_from_fd(fd, kernel);</a>
<a name="ln4238"> </a>
<a name="ln4239">	if (*vnode == NULL)</a>
<a name="ln4240">		return B_FILE_ERROR;</a>
<a name="ln4241"> </a>
<a name="ln4242">	return B_NO_ERROR;</a>
<a name="ln4243">}</a>
<a name="ln4244"> </a>
<a name="ln4245"> </a>
<a name="ln4246">extern &quot;C&quot; status_t</a>
<a name="ln4247">vfs_get_vnode_from_path(const char* path, bool kernel, struct vnode** _vnode)</a>
<a name="ln4248">{</a>
<a name="ln4249">	TRACE((&quot;vfs_get_vnode_from_path: entry. path = '%s', kernel %d\n&quot;,</a>
<a name="ln4250">		path, kernel));</a>
<a name="ln4251"> </a>
<a name="ln4252">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln4253">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln4254">		return B_NO_MEMORY;</a>
<a name="ln4255"> </a>
<a name="ln4256">	char* buffer = pathBuffer.LockBuffer();</a>
<a name="ln4257">	strlcpy(buffer, path, pathBuffer.BufferSize());</a>
<a name="ln4258"> </a>
<a name="ln4259">	struct vnode* vnode;</a>
<a name="ln4260">	status_t status = path_to_vnode(buffer, true, &amp;vnode, NULL, kernel);</a>
<a name="ln4261">	if (status != B_OK)</a>
<a name="ln4262">		return status;</a>
<a name="ln4263"> </a>
<a name="ln4264">	*_vnode = vnode;</a>
<a name="ln4265">	return B_OK;</a>
<a name="ln4266">}</a>
<a name="ln4267"> </a>
<a name="ln4268"> </a>
<a name="ln4269">extern &quot;C&quot; status_t</a>
<a name="ln4270">vfs_get_vnode(dev_t mountID, ino_t vnodeID, bool canWait, struct vnode** _vnode)</a>
<a name="ln4271">{</a>
<a name="ln4272">	struct vnode* vnode = NULL;</a>
<a name="ln4273"> </a>
<a name="ln4274">	status_t status = get_vnode(mountID, vnodeID, &amp;vnode, canWait, false);</a>
<a name="ln4275">	if (status != B_OK)</a>
<a name="ln4276">		return status;</a>
<a name="ln4277"> </a>
<a name="ln4278">	*_vnode = vnode;</a>
<a name="ln4279">	return B_OK;</a>
<a name="ln4280">}</a>
<a name="ln4281"> </a>
<a name="ln4282"> </a>
<a name="ln4283">extern &quot;C&quot; status_t</a>
<a name="ln4284">vfs_entry_ref_to_vnode(dev_t mountID, ino_t directoryID,</a>
<a name="ln4285">	const char* name, struct vnode** _vnode)</a>
<a name="ln4286">{</a>
<a name="ln4287">	return entry_ref_to_vnode(mountID, directoryID, name, false, true, _vnode);</a>
<a name="ln4288">}</a>
<a name="ln4289"> </a>
<a name="ln4290"> </a>
<a name="ln4291">extern &quot;C&quot; void</a>
<a name="ln4292">vfs_vnode_to_node_ref(struct vnode* vnode, dev_t* _mountID, ino_t* _vnodeID)</a>
<a name="ln4293">{</a>
<a name="ln4294">	*_mountID = vnode-&gt;device;</a>
<a name="ln4295">	*_vnodeID = vnode-&gt;id;</a>
<a name="ln4296">}</a>
<a name="ln4297"> </a>
<a name="ln4298"> </a>
<a name="ln4299">/*!</a>
<a name="ln4300">	Helper function abstracting the process of &quot;converting&quot; a given</a>
<a name="ln4301">	vnode-pointer to a fs_vnode-pointer.</a>
<a name="ln4302">	Currently only used in bindfs.</a>
<a name="ln4303">*/</a>
<a name="ln4304">extern &quot;C&quot; fs_vnode*</a>
<a name="ln4305">vfs_fsnode_for_vnode(struct vnode* vnode)</a>
<a name="ln4306">{</a>
<a name="ln4307">	return vnode;</a>
<a name="ln4308">}</a>
<a name="ln4309"> </a>
<a name="ln4310"> </a>
<a name="ln4311">/*!</a>
<a name="ln4312">	Calls fs_open() on the given vnode and returns a new</a>
<a name="ln4313">	file descriptor for it</a>
<a name="ln4314">*/</a>
<a name="ln4315">int</a>
<a name="ln4316">vfs_open_vnode(struct vnode* vnode, int openMode, bool kernel)</a>
<a name="ln4317">{</a>
<a name="ln4318">	return open_vnode(vnode, openMode, kernel);</a>
<a name="ln4319">}</a>
<a name="ln4320"> </a>
<a name="ln4321"> </a>
<a name="ln4322">/*!	Looks up a vnode with the given mount and vnode ID.</a>
<a name="ln4323">	Must only be used with &quot;in-use&quot; vnodes as it doesn't grab a reference</a>
<a name="ln4324">	to the node.</a>
<a name="ln4325">	It's currently only be used by file_cache_create().</a>
<a name="ln4326">*/</a>
<a name="ln4327">extern &quot;C&quot; status_t</a>
<a name="ln4328">vfs_lookup_vnode(dev_t mountID, ino_t vnodeID, struct vnode** _vnode)</a>
<a name="ln4329">{</a>
<a name="ln4330">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln4331">	struct vnode* vnode = lookup_vnode(mountID, vnodeID);</a>
<a name="ln4332">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln4333"> </a>
<a name="ln4334">	if (vnode == NULL)</a>
<a name="ln4335">		return B_ERROR;</a>
<a name="ln4336"> </a>
<a name="ln4337">	*_vnode = vnode;</a>
<a name="ln4338">	return B_OK;</a>
<a name="ln4339">}</a>
<a name="ln4340"> </a>
<a name="ln4341"> </a>
<a name="ln4342">extern &quot;C&quot; status_t</a>
<a name="ln4343">vfs_get_fs_node_from_path(fs_volume* volume, const char* path,</a>
<a name="ln4344">	bool traverseLeafLink, bool kernel, void** _node)</a>
<a name="ln4345">{</a>
<a name="ln4346">	TRACE((&quot;vfs_get_fs_node_from_path(volume = %p, path = \&quot;%s\&quot;, kernel %d)\n&quot;,</a>
<a name="ln4347">		volume, path, kernel));</a>
<a name="ln4348"> </a>
<a name="ln4349">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln4350">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln4351">		return B_NO_MEMORY;</a>
<a name="ln4352"> </a>
<a name="ln4353">	fs_mount* mount;</a>
<a name="ln4354">	status_t status = get_mount(volume-&gt;id, &amp;mount);</a>
<a name="ln4355">	if (status != B_OK)</a>
<a name="ln4356">		return status;</a>
<a name="ln4357"> </a>
<a name="ln4358">	char* buffer = pathBuffer.LockBuffer();</a>
<a name="ln4359">	strlcpy(buffer, path, pathBuffer.BufferSize());</a>
<a name="ln4360"> </a>
<a name="ln4361">	struct vnode* vnode = mount-&gt;root_vnode;</a>
<a name="ln4362"> </a>
<a name="ln4363">	if (buffer[0] == '/')</a>
<a name="ln4364">		status = path_to_vnode(buffer, traverseLeafLink, &amp;vnode, NULL, kernel);</a>
<a name="ln4365">	else {</a>
<a name="ln4366">		inc_vnode_ref_count(vnode);</a>
<a name="ln4367">			// vnode_path_to_vnode() releases a reference to the starting vnode</a>
<a name="ln4368">		status = vnode_path_to_vnode(vnode, buffer, traverseLeafLink, 0,</a>
<a name="ln4369">			kernel, &amp;vnode, NULL);</a>
<a name="ln4370">	}</a>
<a name="ln4371"> </a>
<a name="ln4372">	put_mount(mount);</a>
<a name="ln4373"> </a>
<a name="ln4374">	if (status != B_OK)</a>
<a name="ln4375">		return status;</a>
<a name="ln4376"> </a>
<a name="ln4377">	if (vnode-&gt;device != volume-&gt;id) {</a>
<a name="ln4378">		// wrong mount ID - must not gain access on foreign file system nodes</a>
<a name="ln4379">		put_vnode(vnode);</a>
<a name="ln4380">		return B_BAD_VALUE;</a>
<a name="ln4381">	}</a>
<a name="ln4382"> </a>
<a name="ln4383">	// Use get_vnode() to resolve the cookie for the right layer.</a>
<a name="ln4384">	status = get_vnode(volume, vnode-&gt;id, _node);</a>
<a name="ln4385">	put_vnode(vnode);</a>
<a name="ln4386"> </a>
<a name="ln4387">	return status;</a>
<a name="ln4388">}</a>
<a name="ln4389"> </a>
<a name="ln4390"> </a>
<a name="ln4391">status_t</a>
<a name="ln4392">vfs_read_stat(int fd, const char* path, bool traverseLeafLink,</a>
<a name="ln4393">	struct stat* stat, bool kernel)</a>
<a name="ln4394">{</a>
<a name="ln4395">	status_t status;</a>
<a name="ln4396"> </a>
<a name="ln4397">	if (path != NULL) {</a>
<a name="ln4398">		// path given: get the stat of the node referred to by (fd, path)</a>
<a name="ln4399">		KPath pathBuffer(path, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln4400">		if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln4401">			return B_NO_MEMORY;</a>
<a name="ln4402"> </a>
<a name="ln4403">		status = common_path_read_stat(fd, pathBuffer.LockBuffer(),</a>
<a name="ln4404">			traverseLeafLink, stat, kernel);</a>
<a name="ln4405">	} else {</a>
<a name="ln4406">		// no path given: get the FD and use the FD operation</a>
<a name="ln4407">		struct file_descriptor* descriptor</a>
<a name="ln4408">			= get_fd(get_current_io_context(kernel), fd);</a>
<a name="ln4409">		if (descriptor == NULL)</a>
<a name="ln4410">			return B_FILE_ERROR;</a>
<a name="ln4411"> </a>
<a name="ln4412">		if (descriptor-&gt;ops-&gt;fd_read_stat)</a>
<a name="ln4413">			status = descriptor-&gt;ops-&gt;fd_read_stat(descriptor, stat);</a>
<a name="ln4414">		else</a>
<a name="ln4415">			status = B_UNSUPPORTED;</a>
<a name="ln4416"> </a>
<a name="ln4417">		put_fd(descriptor);</a>
<a name="ln4418">	}</a>
<a name="ln4419"> </a>
<a name="ln4420">	return status;</a>
<a name="ln4421">}</a>
<a name="ln4422"> </a>
<a name="ln4423"> </a>
<a name="ln4424">/*!	Finds the full path to the file that contains the module \a moduleName,</a>
<a name="ln4425">	puts it into \a pathBuffer, and returns B_OK for success.</a>
<a name="ln4426">	If \a pathBuffer was too small, it returns \c B_BUFFER_OVERFLOW,</a>
<a name="ln4427">	\c B_ENTRY_NOT_FOUNT if no file could be found.</a>
<a name="ln4428">	\a pathBuffer is clobbered in any case and must not be relied on if this</a>
<a name="ln4429">	functions returns unsuccessfully.</a>
<a name="ln4430">	\a basePath and \a pathBuffer must not point to the same space.</a>
<a name="ln4431">*/</a>
<a name="ln4432">status_t</a>
<a name="ln4433">vfs_get_module_path(const char* basePath, const char* moduleName,</a>
<a name="ln4434">	char* pathBuffer, size_t bufferSize)</a>
<a name="ln4435">{</a>
<a name="ln4436">	struct vnode* dir;</a>
<a name="ln4437">	struct vnode* file;</a>
<a name="ln4438">	status_t status;</a>
<a name="ln4439">	size_t length;</a>
<a name="ln4440">	char* path;</a>
<a name="ln4441"> </a>
<a name="ln4442">	if (bufferSize == 0</a>
<a name="ln4443">		|| strlcpy(pathBuffer, basePath, bufferSize) &gt;= bufferSize)</a>
<a name="ln4444">		return B_BUFFER_OVERFLOW;</a>
<a name="ln4445"> </a>
<a name="ln4446">	status = path_to_vnode(pathBuffer, true, &amp;dir, NULL, true);</a>
<a name="ln4447">	if (status != B_OK)</a>
<a name="ln4448">		return status;</a>
<a name="ln4449"> </a>
<a name="ln4450">	// the path buffer had been clobbered by the above call</a>
<a name="ln4451">	length = strlcpy(pathBuffer, basePath, bufferSize);</a>
<a name="ln4452">	if (pathBuffer[length - 1] != '/')</a>
<a name="ln4453">		pathBuffer[length++] = '/';</a>
<a name="ln4454"> </a>
<a name="ln4455">	path = pathBuffer + length;</a>
<a name="ln4456">	bufferSize -= length;</a>
<a name="ln4457"> </a>
<a name="ln4458">	while (moduleName) {</a>
<a name="ln4459">		char* nextPath = strchr(moduleName, '/');</a>
<a name="ln4460">		if (nextPath == NULL)</a>
<a name="ln4461">			length = strlen(moduleName);</a>
<a name="ln4462">		else {</a>
<a name="ln4463">			length = nextPath - moduleName;</a>
<a name="ln4464">			nextPath++;</a>
<a name="ln4465">		}</a>
<a name="ln4466"> </a>
<a name="ln4467">		if (length + 1 &gt;= bufferSize) {</a>
<a name="ln4468">			status = B_BUFFER_OVERFLOW;</a>
<a name="ln4469">			goto err;</a>
<a name="ln4470">		}</a>
<a name="ln4471"> </a>
<a name="ln4472">		memcpy(path, moduleName, length);</a>
<a name="ln4473">		path[length] = '\0';</a>
<a name="ln4474">		moduleName = nextPath;</a>
<a name="ln4475"> </a>
<a name="ln4476">		status = vnode_path_to_vnode(dir, path, true, 0, true, &amp;file, NULL);</a>
<a name="ln4477">		if (status != B_OK) {</a>
<a name="ln4478">			// vnode_path_to_vnode() has already released the reference to dir</a>
<a name="ln4479">			return status;</a>
<a name="ln4480">		}</a>
<a name="ln4481"> </a>
<a name="ln4482">		if (S_ISDIR(file-&gt;Type())) {</a>
<a name="ln4483">			// goto the next directory</a>
<a name="ln4484">			path[length] = '/';</a>
<a name="ln4485">			path[length + 1] = '\0';</a>
<a name="ln4486">			path += length + 1;</a>
<a name="ln4487">			bufferSize -= length + 1;</a>
<a name="ln4488"> </a>
<a name="ln4489">			dir = file;</a>
<a name="ln4490">		} else if (S_ISREG(file-&gt;Type())) {</a>
<a name="ln4491">			// it's a file so it should be what we've searched for</a>
<a name="ln4492">			put_vnode(file);</a>
<a name="ln4493"> </a>
<a name="ln4494">			return B_OK;</a>
<a name="ln4495">		} else {</a>
<a name="ln4496">			TRACE((&quot;vfs_get_module_path(): something is strange here: &quot;</a>
<a name="ln4497">				&quot;0x%08&quot; B_PRIx32 &quot;...\n&quot;, file-&gt;Type()));</a>
<a name="ln4498">			status = B_ERROR;</a>
<a name="ln4499">			dir = file;</a>
<a name="ln4500">			goto err;</a>
<a name="ln4501">		}</a>
<a name="ln4502">	}</a>
<a name="ln4503"> </a>
<a name="ln4504">	// if we got here, the moduleName just pointed to a directory, not to</a>
<a name="ln4505">	// a real module - what should we do in this case?</a>
<a name="ln4506">	status = B_ENTRY_NOT_FOUND;</a>
<a name="ln4507"> </a>
<a name="ln4508">err:</a>
<a name="ln4509">	put_vnode(dir);</a>
<a name="ln4510">	return status;</a>
<a name="ln4511">}</a>
<a name="ln4512"> </a>
<a name="ln4513"> </a>
<a name="ln4514">/*!	\brief Normalizes a given path.</a>
<a name="ln4515"> </a>
<a name="ln4516">	The path must refer to an existing or non-existing entry in an existing</a>
<a name="ln4517">	directory, that is chopping off the leaf component the remaining path must</a>
<a name="ln4518">	refer to an existing directory.</a>
<a name="ln4519"> </a>
<a name="ln4520">	The returned will be canonical in that it will be absolute, will not</a>
<a name="ln4521">	contain any &quot;.&quot; or &quot;..&quot; components or duplicate occurrences of '/'s,</a>
<a name="ln4522">	and none of the directory components will by symbolic links.</a>
<a name="ln4523"> </a>
<a name="ln4524">	Any two paths referring to the same entry, will result in the same</a>
<a name="ln4525">	normalized path (well, that is pretty much the definition of `normalized',</a>
<a name="ln4526">	isn't it :-).</a>
<a name="ln4527"> </a>
<a name="ln4528">	\param path The path to be normalized.</a>
<a name="ln4529">	\param buffer The buffer into which the normalized path will be written.</a>
<a name="ln4530">		   May be the same one as \a path.</a>
<a name="ln4531">	\param bufferSize The size of \a buffer.</a>
<a name="ln4532">	\param traverseLink If \c true, the function also resolves leaf symlinks.</a>
<a name="ln4533">	\param kernel \c true, if the IO context of the kernel shall be used,</a>
<a name="ln4534">		   otherwise that of the team this thread belongs to. Only relevant,</a>
<a name="ln4535">		   if the path is relative (to get the CWD).</a>
<a name="ln4536">	\return \c B_OK if everything went fine, another error code otherwise.</a>
<a name="ln4537">*/</a>
<a name="ln4538">status_t</a>
<a name="ln4539">vfs_normalize_path(const char* path, char* buffer, size_t bufferSize,</a>
<a name="ln4540">	bool traverseLink, bool kernel)</a>
<a name="ln4541">{</a>
<a name="ln4542">	if (!path || !buffer || bufferSize &lt; 1)</a>
<a name="ln4543">		return B_BAD_VALUE;</a>
<a name="ln4544"> </a>
<a name="ln4545">	if (path != buffer) {</a>
<a name="ln4546">		if (strlcpy(buffer, path, bufferSize) &gt;= bufferSize)</a>
<a name="ln4547">			return B_BUFFER_OVERFLOW;</a>
<a name="ln4548">	}</a>
<a name="ln4549"> </a>
<a name="ln4550">	return normalize_path(buffer, bufferSize, traverseLink, kernel);</a>
<a name="ln4551">}</a>
<a name="ln4552"> </a>
<a name="ln4553"> </a>
<a name="ln4554">/*!	\brief Gets the parent of the passed in node.</a>
<a name="ln4555"> </a>
<a name="ln4556">	Gets the parent of the passed in node, and correctly resolves covered</a>
<a name="ln4557">	nodes.</a>
<a name="ln4558">*/</a>
<a name="ln4559">extern &quot;C&quot; status_t</a>
<a name="ln4560">vfs_resolve_parent(struct vnode* parent, dev_t* device, ino_t* node)</a>
<a name="ln4561">{</a>
<a name="ln4562">	return resolve_covered_parent(parent, device, node,</a>
<a name="ln4563">		get_current_io_context(true));</a>
<a name="ln4564">}</a>
<a name="ln4565"> </a>
<a name="ln4566"> </a>
<a name="ln4567">/*!	\brief Creates a special node in the file system.</a>
<a name="ln4568"> </a>
<a name="ln4569">	The caller gets a reference to the newly created node (which is passed</a>
<a name="ln4570">	back through \a _createdVnode) and is responsible for releasing it.</a>
<a name="ln4571"> </a>
<a name="ln4572">	\param path The path where to create the entry for the node. Can be \c NULL,</a>
<a name="ln4573">		in which case the node is created without an entry in the root FS -- it</a>
<a name="ln4574">		will automatically be deleted when the last reference has been released.</a>
<a name="ln4575">	\param subVnode The definition of the subnode. Can be \c NULL, in which case</a>
<a name="ln4576">		the target file system will just create the node with its standard</a>
<a name="ln4577">		operations. Depending on the type of the node a subnode might be created</a>
<a name="ln4578">		automatically, though.</a>
<a name="ln4579">	\param mode The type and permissions for the node to be created.</a>
<a name="ln4580">	\param flags Flags to be passed to the creating FS.</a>
<a name="ln4581">	\param kernel \c true, if called in the kernel context (relevant only if</a>
<a name="ln4582">		\a path is not \c NULL and not absolute).</a>
<a name="ln4583">	\param _superVnode Pointer to a pre-allocated structure to be filled by the</a>
<a name="ln4584">		file system creating the node, with the private data pointer and</a>
<a name="ln4585">		operations for the super node. Can be \c NULL.</a>
<a name="ln4586">	\param _createVnode Pointer to pre-allocated storage where to store the</a>
<a name="ln4587">		pointer to the newly created node.</a>
<a name="ln4588">	\return \c B_OK, if everything went fine, another error code otherwise.</a>
<a name="ln4589">*/</a>
<a name="ln4590">status_t</a>
<a name="ln4591">vfs_create_special_node(const char* path, fs_vnode* subVnode, mode_t mode,</a>
<a name="ln4592">	uint32 flags, bool kernel, fs_vnode* _superVnode,</a>
<a name="ln4593">	struct vnode** _createdVnode)</a>
<a name="ln4594">{</a>
<a name="ln4595">	struct vnode* dirNode;</a>
<a name="ln4596">	char _leaf[B_FILE_NAME_LENGTH];</a>
<a name="ln4597">	char* leaf = NULL;</a>
<a name="ln4598"> </a>
<a name="ln4599">	if (path) {</a>
<a name="ln4600">		// We've got a path. Get the dir vnode and the leaf name.</a>
<a name="ln4601">		KPath tmpPathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln4602">		if (tmpPathBuffer.InitCheck() != B_OK)</a>
<a name="ln4603">			return B_NO_MEMORY;</a>
<a name="ln4604"> </a>
<a name="ln4605">		char* tmpPath = tmpPathBuffer.LockBuffer();</a>
<a name="ln4606">		if (strlcpy(tmpPath, path, B_PATH_NAME_LENGTH) &gt;= B_PATH_NAME_LENGTH)</a>
<a name="ln4607">			return B_NAME_TOO_LONG;</a>
<a name="ln4608"> </a>
<a name="ln4609">		// get the dir vnode and the leaf name</a>
<a name="ln4610">		leaf = _leaf;</a>
<a name="ln4611">		status_t error = path_to_dir_vnode(tmpPath, &amp;dirNode, leaf, kernel);</a>
<a name="ln4612">		if (error != B_OK)</a>
<a name="ln4613">			return error;</a>
<a name="ln4614">	} else {</a>
<a name="ln4615">		// No path. Create the node in the root FS.</a>
<a name="ln4616">		dirNode = sRoot;</a>
<a name="ln4617">		inc_vnode_ref_count(dirNode);</a>
<a name="ln4618">	}</a>
<a name="ln4619"> </a>
<a name="ln4620">	VNodePutter _(dirNode);</a>
<a name="ln4621"> </a>
<a name="ln4622">	// check support for creating special nodes</a>
<a name="ln4623">	if (!HAS_FS_CALL(dirNode, create_special_node))</a>
<a name="ln4624">		return B_UNSUPPORTED;</a>
<a name="ln4625"> </a>
<a name="ln4626">	// create the node</a>
<a name="ln4627">	fs_vnode superVnode;</a>
<a name="ln4628">	ino_t nodeID;</a>
<a name="ln4629">	status_t status = FS_CALL(dirNode, create_special_node, leaf, subVnode,</a>
<a name="ln4630">		mode, flags, _superVnode != NULL ? _superVnode : &amp;superVnode, &amp;nodeID);</a>
<a name="ln4631">	if (status != B_OK)</a>
<a name="ln4632">		return status;</a>
<a name="ln4633"> </a>
<a name="ln4634">	// lookup the node</a>
<a name="ln4635">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln4636">	*_createdVnode = lookup_vnode(dirNode-&gt;mount-&gt;id, nodeID);</a>
<a name="ln4637">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln4638"> </a>
<a name="ln4639">	if (*_createdVnode == NULL) {</a>
<a name="ln4640">		panic(&quot;vfs_create_special_node(): lookup of node failed&quot;);</a>
<a name="ln4641">		return B_ERROR;</a>
<a name="ln4642">	}</a>
<a name="ln4643"> </a>
<a name="ln4644">	return B_OK;</a>
<a name="ln4645">}</a>
<a name="ln4646"> </a>
<a name="ln4647"> </a>
<a name="ln4648">extern &quot;C&quot; void</a>
<a name="ln4649">vfs_put_vnode(struct vnode* vnode)</a>
<a name="ln4650">{</a>
<a name="ln4651">	put_vnode(vnode);</a>
<a name="ln4652">}</a>
<a name="ln4653"> </a>
<a name="ln4654"> </a>
<a name="ln4655">extern &quot;C&quot; status_t</a>
<a name="ln4656">vfs_get_cwd(dev_t* _mountID, ino_t* _vnodeID)</a>
<a name="ln4657">{</a>
<a name="ln4658">	// Get current working directory from io context</a>
<a name="ln4659">	struct io_context* context = get_current_io_context(false);</a>
<a name="ln4660">	status_t status = B_OK;</a>
<a name="ln4661"> </a>
<a name="ln4662">	mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln4663"> </a>
<a name="ln4664">	if (context-&gt;cwd != NULL) {</a>
<a name="ln4665">		*_mountID = context-&gt;cwd-&gt;device;</a>
<a name="ln4666">		*_vnodeID = context-&gt;cwd-&gt;id;</a>
<a name="ln4667">	} else</a>
<a name="ln4668">		status = B_ERROR;</a>
<a name="ln4669"> </a>
<a name="ln4670">	mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln4671">	return status;</a>
<a name="ln4672">}</a>
<a name="ln4673"> </a>
<a name="ln4674"> </a>
<a name="ln4675">status_t</a>
<a name="ln4676">vfs_unmount(dev_t mountID, uint32 flags)</a>
<a name="ln4677">{</a>
<a name="ln4678">	return fs_unmount(NULL, mountID, flags, true);</a>
<a name="ln4679">}</a>
<a name="ln4680"> </a>
<a name="ln4681"> </a>
<a name="ln4682">extern &quot;C&quot; status_t</a>
<a name="ln4683">vfs_disconnect_vnode(dev_t mountID, ino_t vnodeID)</a>
<a name="ln4684">{</a>
<a name="ln4685">	struct vnode* vnode;</a>
<a name="ln4686"> </a>
<a name="ln4687">	status_t status = get_vnode(mountID, vnodeID, &amp;vnode, true, true);</a>
<a name="ln4688">	if (status != B_OK)</a>
<a name="ln4689">		return status;</a>
<a name="ln4690"> </a>
<a name="ln4691">	disconnect_mount_or_vnode_fds(vnode-&gt;mount, vnode);</a>
<a name="ln4692">	put_vnode(vnode);</a>
<a name="ln4693">	return B_OK;</a>
<a name="ln4694">}</a>
<a name="ln4695"> </a>
<a name="ln4696"> </a>
<a name="ln4697">extern &quot;C&quot; void</a>
<a name="ln4698">vfs_free_unused_vnodes(int32 level)</a>
<a name="ln4699">{</a>
<a name="ln4700">	vnode_low_resource_handler(NULL,</a>
<a name="ln4701">		B_KERNEL_RESOURCE_PAGES | B_KERNEL_RESOURCE_MEMORY</a>
<a name="ln4702">			| B_KERNEL_RESOURCE_ADDRESS_SPACE,</a>
<a name="ln4703">		level);</a>
<a name="ln4704">}</a>
<a name="ln4705"> </a>
<a name="ln4706"> </a>
<a name="ln4707">extern &quot;C&quot; bool</a>
<a name="ln4708">vfs_can_page(struct vnode* vnode, void* cookie)</a>
<a name="ln4709">{</a>
<a name="ln4710">	FUNCTION((&quot;vfs_canpage: vnode %p\n&quot;, vnode));</a>
<a name="ln4711"> </a>
<a name="ln4712">	if (HAS_FS_CALL(vnode, can_page))</a>
<a name="ln4713">		return FS_CALL(vnode, can_page, cookie);</a>
<a name="ln4714">	return false;</a>
<a name="ln4715">}</a>
<a name="ln4716"> </a>
<a name="ln4717"> </a>
<a name="ln4718">extern &quot;C&quot; status_t</a>
<a name="ln4719">vfs_read_pages(struct vnode* vnode, void* cookie, off_t pos,</a>
<a name="ln4720">	const generic_io_vec* vecs, size_t count, uint32 flags,</a>
<a name="ln4721">	generic_size_t* _numBytes)</a>
<a name="ln4722">{</a>
<a name="ln4723">	FUNCTION((&quot;vfs_read_pages: vnode %p, vecs %p, pos %&quot; B_PRIdOFF &quot;\n&quot;, vnode,</a>
<a name="ln4724">		vecs, pos));</a>
<a name="ln4725"> </a>
<a name="ln4726">#if VFS_PAGES_IO_TRACING</a>
<a name="ln4727">	generic_size_t bytesRequested = *_numBytes;</a>
<a name="ln4728">#endif</a>
<a name="ln4729"> </a>
<a name="ln4730">	IORequest request;</a>
<a name="ln4731">	status_t status = request.Init(pos, vecs, count, *_numBytes, false, flags);</a>
<a name="ln4732">	if (status == B_OK) {</a>
<a name="ln4733">		status = vfs_vnode_io(vnode, cookie, &amp;request);</a>
<a name="ln4734">		if (status == B_OK)</a>
<a name="ln4735">			status = request.Wait();</a>
<a name="ln4736">		*_numBytes = request.TransferredBytes();</a>
<a name="ln4737">	}</a>
<a name="ln4738"> </a>
<a name="ln4739">	TPIO(ReadPages(vnode, cookie, pos, vecs, count, flags, bytesRequested,</a>
<a name="ln4740">		status, *_numBytes));</a>
<a name="ln4741"> </a>
<a name="ln4742">	return status;</a>
<a name="ln4743">}</a>
<a name="ln4744"> </a>
<a name="ln4745"> </a>
<a name="ln4746">extern &quot;C&quot; status_t</a>
<a name="ln4747">vfs_write_pages(struct vnode* vnode, void* cookie, off_t pos,</a>
<a name="ln4748">	const generic_io_vec* vecs, size_t count, uint32 flags,</a>
<a name="ln4749">	generic_size_t* _numBytes)</a>
<a name="ln4750">{</a>
<a name="ln4751">	FUNCTION((&quot;vfs_write_pages: vnode %p, vecs %p, pos %&quot; B_PRIdOFF &quot;\n&quot;, vnode,</a>
<a name="ln4752">		vecs, pos));</a>
<a name="ln4753"> </a>
<a name="ln4754">#if VFS_PAGES_IO_TRACING</a>
<a name="ln4755">	generic_size_t bytesRequested = *_numBytes;</a>
<a name="ln4756">#endif</a>
<a name="ln4757"> </a>
<a name="ln4758">	IORequest request;</a>
<a name="ln4759">	status_t status = request.Init(pos, vecs, count, *_numBytes, true, flags);</a>
<a name="ln4760">	if (status == B_OK) {</a>
<a name="ln4761">		status = vfs_vnode_io(vnode, cookie, &amp;request);</a>
<a name="ln4762">		if (status == B_OK)</a>
<a name="ln4763">			status = request.Wait();</a>
<a name="ln4764">		*_numBytes = request.TransferredBytes();</a>
<a name="ln4765">	}</a>
<a name="ln4766"> </a>
<a name="ln4767">	TPIO(WritePages(vnode, cookie, pos, vecs, count, flags, bytesRequested,</a>
<a name="ln4768">		status, *_numBytes));</a>
<a name="ln4769"> </a>
<a name="ln4770">	return status;</a>
<a name="ln4771">}</a>
<a name="ln4772"> </a>
<a name="ln4773"> </a>
<a name="ln4774">/*!	Gets the vnode's VMCache object. If it didn't have one, it will be</a>
<a name="ln4775">	created if \a allocate is \c true.</a>
<a name="ln4776">	In case it's successful, it will also grab a reference to the cache</a>
<a name="ln4777">	it returns.</a>
<a name="ln4778">*/</a>
<a name="ln4779">extern &quot;C&quot; status_t</a>
<a name="ln4780">vfs_get_vnode_cache(struct vnode* vnode, VMCache** _cache, bool allocate)</a>
<a name="ln4781">{</a>
<a name="ln4782">	if (vnode-&gt;cache != NULL) {</a>
<a name="ln4783">		vnode-&gt;cache-&gt;AcquireRef();</a>
<a name="ln4784">		*_cache = vnode-&gt;cache;</a>
<a name="ln4785">		return B_OK;</a>
<a name="ln4786">	}</a>
<a name="ln4787"> </a>
<a name="ln4788">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln4789">	vnode-&gt;Lock();</a>
<a name="ln4790"> </a>
<a name="ln4791">	status_t status = B_OK;</a>
<a name="ln4792"> </a>
<a name="ln4793">	// The cache could have been created in the meantime</a>
<a name="ln4794">	if (vnode-&gt;cache == NULL) {</a>
<a name="ln4795">		if (allocate) {</a>
<a name="ln4796">			// TODO: actually the vnode needs to be busy already here, or</a>
<a name="ln4797">			//	else this won't work...</a>
<a name="ln4798">			bool wasBusy = vnode-&gt;IsBusy();</a>
<a name="ln4799">			vnode-&gt;SetBusy(true);</a>
<a name="ln4800"> </a>
<a name="ln4801">			vnode-&gt;Unlock();</a>
<a name="ln4802">			rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln4803"> </a>
<a name="ln4804">			status = vm_create_vnode_cache(vnode, &amp;vnode-&gt;cache);</a>
<a name="ln4805"> </a>
<a name="ln4806">			rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln4807">			vnode-&gt;Lock();</a>
<a name="ln4808">			vnode-&gt;SetBusy(wasBusy);</a>
<a name="ln4809">		} else</a>
<a name="ln4810">			status = B_BAD_VALUE;</a>
<a name="ln4811">	}</a>
<a name="ln4812"> </a>
<a name="ln4813">	vnode-&gt;Unlock();</a>
<a name="ln4814">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln4815"> </a>
<a name="ln4816">	if (status == B_OK) {</a>
<a name="ln4817">		vnode-&gt;cache-&gt;AcquireRef();</a>
<a name="ln4818">		*_cache = vnode-&gt;cache;</a>
<a name="ln4819">	}</a>
<a name="ln4820"> </a>
<a name="ln4821">	return status;</a>
<a name="ln4822">}</a>
<a name="ln4823"> </a>
<a name="ln4824"> </a>
<a name="ln4825">status_t</a>
<a name="ln4826">vfs_get_file_map(struct vnode* vnode, off_t offset, size_t size,</a>
<a name="ln4827">	file_io_vec* vecs, size_t* _count)</a>
<a name="ln4828">{</a>
<a name="ln4829">	FUNCTION((&quot;vfs_get_file_map: vnode %p, vecs %p, offset %&quot; B_PRIdOFF</a>
<a name="ln4830">		&quot;, size = %&quot; B_PRIuSIZE &quot;\n&quot;, vnode, vecs, offset, size));</a>
<a name="ln4831"> </a>
<a name="ln4832">	return FS_CALL(vnode, get_file_map, offset, size, vecs, _count);</a>
<a name="ln4833">}</a>
<a name="ln4834"> </a>
<a name="ln4835"> </a>
<a name="ln4836">status_t</a>
<a name="ln4837">vfs_stat_vnode(struct vnode* vnode, struct stat* stat)</a>
<a name="ln4838">{</a>
<a name="ln4839">	status_t status = FS_CALL(vnode, read_stat, stat);</a>
<a name="ln4840"> </a>
<a name="ln4841">	// fill in the st_dev and st_ino fields</a>
<a name="ln4842">	if (status == B_OK) {</a>
<a name="ln4843">		stat-&gt;st_dev = vnode-&gt;device;</a>
<a name="ln4844">		stat-&gt;st_ino = vnode-&gt;id;</a>
<a name="ln4845">		// the rdev field must stay unset for non-special files</a>
<a name="ln4846">		if (!S_ISBLK(stat-&gt;st_mode) &amp;&amp; !S_ISCHR(stat-&gt;st_mode))</a>
<a name="ln4847">			stat-&gt;st_rdev = -1;</a>
<a name="ln4848">	}</a>
<a name="ln4849"> </a>
<a name="ln4850">	return status;</a>
<a name="ln4851">}</a>
<a name="ln4852"> </a>
<a name="ln4853"> </a>
<a name="ln4854">status_t</a>
<a name="ln4855">vfs_stat_node_ref(dev_t device, ino_t inode, struct stat* stat)</a>
<a name="ln4856">{</a>
<a name="ln4857">	struct vnode* vnode;</a>
<a name="ln4858">	status_t status = get_vnode(device, inode, &amp;vnode, true, false);</a>
<a name="ln4859">	if (status != B_OK)</a>
<a name="ln4860">		return status;</a>
<a name="ln4861"> </a>
<a name="ln4862">	status = vfs_stat_vnode(vnode, stat);</a>
<a name="ln4863"> </a>
<a name="ln4864">	put_vnode(vnode);</a>
<a name="ln4865">	return status;</a>
<a name="ln4866">}</a>
<a name="ln4867"> </a>
<a name="ln4868"> </a>
<a name="ln4869">status_t</a>
<a name="ln4870">vfs_get_vnode_name(struct vnode* vnode, char* name, size_t nameSize)</a>
<a name="ln4871">{</a>
<a name="ln4872">	return get_vnode_name(vnode, NULL, name, nameSize, true);</a>
<a name="ln4873">}</a>
<a name="ln4874"> </a>
<a name="ln4875"> </a>
<a name="ln4876">status_t</a>
<a name="ln4877">vfs_entry_ref_to_path(dev_t device, ino_t inode, const char* leaf,</a>
<a name="ln4878">	bool kernel, char* path, size_t pathLength)</a>
<a name="ln4879">{</a>
<a name="ln4880">	struct vnode* vnode;</a>
<a name="ln4881">	status_t status;</a>
<a name="ln4882"> </a>
<a name="ln4883">	// filter invalid leaf names</a>
<a name="ln4884">	if (leaf != NULL &amp;&amp; (leaf[0] == '\0' || strchr(leaf, '/')))</a>
<a name="ln4885">		return B_BAD_VALUE;</a>
<a name="ln4886"> </a>
<a name="ln4887">	// get the vnode matching the dir's node_ref</a>
<a name="ln4888">	if (leaf &amp;&amp; (strcmp(leaf, &quot;.&quot;) == 0 || strcmp(leaf, &quot;..&quot;) == 0)) {</a>
<a name="ln4889">		// special cases &quot;.&quot; and &quot;..&quot;: we can directly get the vnode of the</a>
<a name="ln4890">		// referenced directory</a>
<a name="ln4891">		status = entry_ref_to_vnode(device, inode, leaf, false, kernel, &amp;vnode);</a>
<a name="ln4892">		leaf = NULL;</a>
<a name="ln4893">	} else</a>
<a name="ln4894">		status = get_vnode(device, inode, &amp;vnode, true, false);</a>
<a name="ln4895">	if (status != B_OK)</a>
<a name="ln4896">		return status;</a>
<a name="ln4897"> </a>
<a name="ln4898">	// get the directory path</a>
<a name="ln4899">	status = dir_vnode_to_path(vnode, path, pathLength, kernel);</a>
<a name="ln4900">	put_vnode(vnode);</a>
<a name="ln4901">		// we don't need the vnode anymore</a>
<a name="ln4902">	if (status != B_OK)</a>
<a name="ln4903">		return status;</a>
<a name="ln4904"> </a>
<a name="ln4905">	// append the leaf name</a>
<a name="ln4906">	if (leaf) {</a>
<a name="ln4907">		// insert a directory separator if this is not the file system root</a>
<a name="ln4908">		if ((strcmp(path, &quot;/&quot;) &amp;&amp; strlcat(path, &quot;/&quot;, pathLength)</a>
<a name="ln4909">				&gt;= pathLength)</a>
<a name="ln4910">			|| strlcat(path, leaf, pathLength) &gt;= pathLength) {</a>
<a name="ln4911">			return B_NAME_TOO_LONG;</a>
<a name="ln4912">		}</a>
<a name="ln4913">	}</a>
<a name="ln4914"> </a>
<a name="ln4915">	return B_OK;</a>
<a name="ln4916">}</a>
<a name="ln4917"> </a>
<a name="ln4918"> </a>
<a name="ln4919">/*!	If the given descriptor locked its vnode, that lock will be released. */</a>
<a name="ln4920">void</a>
<a name="ln4921">vfs_unlock_vnode_if_locked(struct file_descriptor* descriptor)</a>
<a name="ln4922">{</a>
<a name="ln4923">	struct vnode* vnode = fd_vnode(descriptor);</a>
<a name="ln4924"> </a>
<a name="ln4925">	if (vnode != NULL &amp;&amp; vnode-&gt;mandatory_locked_by == descriptor)</a>
<a name="ln4926">		vnode-&gt;mandatory_locked_by = NULL;</a>
<a name="ln4927">}</a>
<a name="ln4928"> </a>
<a name="ln4929"> </a>
<a name="ln4930">/*!	Releases any POSIX locks on the file descriptor. */</a>
<a name="ln4931">status_t</a>
<a name="ln4932">vfs_release_posix_lock(io_context* context, struct file_descriptor* descriptor)</a>
<a name="ln4933">{</a>
<a name="ln4934">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4935">	if (vnode == NULL)</a>
<a name="ln4936">		return B_OK;</a>
<a name="ln4937"> </a>
<a name="ln4938">	if (HAS_FS_CALL(vnode, release_lock))</a>
<a name="ln4939">		return FS_CALL(vnode, release_lock, descriptor-&gt;cookie, NULL);</a>
<a name="ln4940"> </a>
<a name="ln4941">	return release_advisory_lock(vnode, context, NULL, NULL);</a>
<a name="ln4942">}</a>
<a name="ln4943"> </a>
<a name="ln4944"> </a>
<a name="ln4945">/*!	Closes all file descriptors of the specified I/O context that</a>
<a name="ln4946">	have the O_CLOEXEC flag set.</a>
<a name="ln4947">*/</a>
<a name="ln4948">void</a>
<a name="ln4949">vfs_exec_io_context(io_context* context)</a>
<a name="ln4950">{</a>
<a name="ln4951">	uint32 i;</a>
<a name="ln4952"> </a>
<a name="ln4953">	for (i = 0; i &lt; context-&gt;table_size; i++) {</a>
<a name="ln4954">		mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln4955"> </a>
<a name="ln4956">		struct file_descriptor* descriptor = context-&gt;fds[i];</a>
<a name="ln4957">		bool remove = false;</a>
<a name="ln4958"> </a>
<a name="ln4959">		if (descriptor != NULL &amp;&amp; fd_close_on_exec(context, i)) {</a>
<a name="ln4960">			context-&gt;fds[i] = NULL;</a>
<a name="ln4961">			context-&gt;num_used_fds--;</a>
<a name="ln4962"> </a>
<a name="ln4963">			remove = true;</a>
<a name="ln4964">		}</a>
<a name="ln4965"> </a>
<a name="ln4966">		mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln4967"> </a>
<a name="ln4968">		if (remove) {</a>
<a name="ln4969">			close_fd(context, descriptor);</a>
<a name="ln4970">			put_fd(descriptor);</a>
<a name="ln4971">		}</a>
<a name="ln4972">	}</a>
<a name="ln4973">}</a>
<a name="ln4974"> </a>
<a name="ln4975"> </a>
<a name="ln4976">/*! Sets up a new io_control structure, and inherits the properties</a>
<a name="ln4977">	of the parent io_control if it is given.</a>
<a name="ln4978">*/</a>
<a name="ln4979">io_context*</a>
<a name="ln4980">vfs_new_io_context(io_context* parentContext, bool purgeCloseOnExec)</a>
<a name="ln4981">{</a>
<a name="ln4982">	io_context* context = (io_context*)malloc(sizeof(io_context));</a>
<a name="ln4983">	if (context == NULL)</a>
<a name="ln4984">		return NULL;</a>
<a name="ln4985"> </a>
<a name="ln4986">	TIOC(NewIOContext(context, parentContext));</a>
<a name="ln4987"> </a>
<a name="ln4988">	memset(context, 0, sizeof(io_context));</a>
<a name="ln4989">	context-&gt;ref_count = 1;</a>
<a name="ln4990"> </a>
<a name="ln4991">	MutexLocker parentLocker;</a>
<a name="ln4992"> </a>
<a name="ln4993">	size_t tableSize;</a>
<a name="ln4994">	if (parentContext != NULL) {</a>
<a name="ln4995">		parentLocker.SetTo(parentContext-&gt;io_mutex, false);</a>
<a name="ln4996">		tableSize = parentContext-&gt;table_size;</a>
<a name="ln4997">	} else</a>
<a name="ln4998">		tableSize = DEFAULT_FD_TABLE_SIZE;</a>
<a name="ln4999"> </a>
<a name="ln5000">	// allocate space for FDs and their close-on-exec flag</a>
<a name="ln5001">	context-&gt;fds = (file_descriptor**)malloc(</a>
<a name="ln5002">		sizeof(struct file_descriptor*) * tableSize</a>
<a name="ln5003">		+ sizeof(struct select_sync*) * tableSize</a>
<a name="ln5004">		+ (tableSize + 7) / 8);</a>
<a name="ln5005">	if (context-&gt;fds == NULL) {</a>
<a name="ln5006">		free(context);</a>
<a name="ln5007">		return NULL;</a>
<a name="ln5008">	}</a>
<a name="ln5009"> </a>
<a name="ln5010">	context-&gt;select_infos = (select_info**)(context-&gt;fds + tableSize);</a>
<a name="ln5011">	context-&gt;fds_close_on_exec = (uint8*)(context-&gt;select_infos + tableSize);</a>
<a name="ln5012"> </a>
<a name="ln5013">	memset(context-&gt;fds, 0, sizeof(struct file_descriptor*) * tableSize</a>
<a name="ln5014">		+ sizeof(struct select_sync*) * tableSize</a>
<a name="ln5015">		+ (tableSize + 7) / 8);</a>
<a name="ln5016"> </a>
<a name="ln5017">	mutex_init(&amp;context-&gt;io_mutex, &quot;I/O context&quot;);</a>
<a name="ln5018"> </a>
<a name="ln5019">	// Copy all parent file descriptors</a>
<a name="ln5020"> </a>
<a name="ln5021">	if (parentContext != NULL) {</a>
<a name="ln5022">		size_t i;</a>
<a name="ln5023"> </a>
<a name="ln5024">		mutex_lock(&amp;sIOContextRootLock);</a>
<a name="ln5025">		context-&gt;root = parentContext-&gt;root;</a>
<a name="ln5026">		if (context-&gt;root)</a>
<a name="ln5027">			inc_vnode_ref_count(context-&gt;root);</a>
<a name="ln5028">		mutex_unlock(&amp;sIOContextRootLock);</a>
<a name="ln5029"> </a>
<a name="ln5030">		context-&gt;cwd = parentContext-&gt;cwd;</a>
<a name="ln5031">		if (context-&gt;cwd)</a>
<a name="ln5032">			inc_vnode_ref_count(context-&gt;cwd);</a>
<a name="ln5033"> </a>
<a name="ln5034">		if (parentContext-&gt;inherit_fds) {</a>
<a name="ln5035">			for (i = 0; i &lt; tableSize; i++) {</a>
<a name="ln5036">				struct file_descriptor* descriptor = parentContext-&gt;fds[i];</a>
<a name="ln5037"> </a>
<a name="ln5038">				if (descriptor != NULL</a>
<a name="ln5039">					&amp;&amp; (descriptor-&gt;open_mode &amp; O_DISCONNECTED) == 0) {</a>
<a name="ln5040">					bool closeOnExec = fd_close_on_exec(parentContext, i);</a>
<a name="ln5041">					if (closeOnExec &amp;&amp; purgeCloseOnExec)</a>
<a name="ln5042">						continue;</a>
<a name="ln5043"> </a>
<a name="ln5044">					TFD(InheritFD(context, i, descriptor, parentContext));</a>
<a name="ln5045"> </a>
<a name="ln5046">					context-&gt;fds[i] = descriptor;</a>
<a name="ln5047">					context-&gt;num_used_fds++;</a>
<a name="ln5048">					atomic_add(&amp;descriptor-&gt;ref_count, 1);</a>
<a name="ln5049">					atomic_add(&amp;descriptor-&gt;open_count, 1);</a>
<a name="ln5050"> </a>
<a name="ln5051">					if (closeOnExec)</a>
<a name="ln5052">						fd_set_close_on_exec(context, i, true);</a>
<a name="ln5053">				}</a>
<a name="ln5054">			}</a>
<a name="ln5055">		}</a>
<a name="ln5056"> </a>
<a name="ln5057">		parentLocker.Unlock();</a>
<a name="ln5058">	} else {</a>
<a name="ln5059">		context-&gt;root = sRoot;</a>
<a name="ln5060">		context-&gt;cwd = sRoot;</a>
<a name="ln5061"> </a>
<a name="ln5062">		if (context-&gt;root)</a>
<a name="ln5063">			inc_vnode_ref_count(context-&gt;root);</a>
<a name="ln5064"> </a>
<a name="ln5065">		if (context-&gt;cwd)</a>
<a name="ln5066">			inc_vnode_ref_count(context-&gt;cwd);</a>
<a name="ln5067">	}</a>
<a name="ln5068"> </a>
<a name="ln5069">	context-&gt;table_size = tableSize;</a>
<a name="ln5070">	context-&gt;inherit_fds = parentContext != NULL;</a>
<a name="ln5071"> </a>
<a name="ln5072">	list_init(&amp;context-&gt;node_monitors);</a>
<a name="ln5073">	context-&gt;max_monitors = DEFAULT_NODE_MONITORS;</a>
<a name="ln5074"> </a>
<a name="ln5075">	return context;</a>
<a name="ln5076">}</a>
<a name="ln5077"> </a>
<a name="ln5078"> </a>
<a name="ln5079">void</a>
<a name="ln5080">vfs_get_io_context(io_context* context)</a>
<a name="ln5081">{</a>
<a name="ln5082">	atomic_add(&amp;context-&gt;ref_count, 1);</a>
<a name="ln5083">}</a>
<a name="ln5084"> </a>
<a name="ln5085"> </a>
<a name="ln5086">void</a>
<a name="ln5087">vfs_put_io_context(io_context* context)</a>
<a name="ln5088">{</a>
<a name="ln5089">	if (atomic_add(&amp;context-&gt;ref_count, -1) == 1)</a>
<a name="ln5090">		free_io_context(context);</a>
<a name="ln5091">}</a>
<a name="ln5092"> </a>
<a name="ln5093"> </a>
<a name="ln5094">status_t</a>
<a name="ln5095">vfs_resize_fd_table(struct io_context* context, uint32 newSize)</a>
<a name="ln5096">{</a>
<a name="ln5097">	if (newSize == 0 || newSize &gt; MAX_FD_TABLE_SIZE)</a>
<a name="ln5098">		return B_BAD_VALUE;</a>
<a name="ln5099"> </a>
<a name="ln5100">	TIOC(ResizeIOContext(context, newSize));</a>
<a name="ln5101"> </a>
<a name="ln5102">	MutexLocker _(context-&gt;io_mutex);</a>
<a name="ln5103"> </a>
<a name="ln5104">	uint32 oldSize = context-&gt;table_size;</a>
<a name="ln5105">	int oldCloseOnExitBitmapSize = (oldSize + 7) / 8;</a>
<a name="ln5106">	int newCloseOnExitBitmapSize = (newSize + 7) / 8;</a>
<a name="ln5107"> </a>
<a name="ln5108">	// If the tables shrink, make sure none of the fds being dropped are in use.</a>
<a name="ln5109">	if (newSize &lt; oldSize) {</a>
<a name="ln5110">		for (uint32 i = oldSize; i-- &gt; newSize;) {</a>
<a name="ln5111">			if (context-&gt;fds[i])</a>
<a name="ln5112">				return B_BUSY;</a>
<a name="ln5113">		}</a>
<a name="ln5114">	}</a>
<a name="ln5115"> </a>
<a name="ln5116">	// store pointers to the old tables</a>
<a name="ln5117">	file_descriptor** oldFDs = context-&gt;fds;</a>
<a name="ln5118">	select_info** oldSelectInfos = context-&gt;select_infos;</a>
<a name="ln5119">	uint8* oldCloseOnExecTable = context-&gt;fds_close_on_exec;</a>
<a name="ln5120"> </a>
<a name="ln5121">	// allocate new tables</a>
<a name="ln5122">	file_descriptor** newFDs = (file_descriptor**)malloc(</a>
<a name="ln5123">		sizeof(struct file_descriptor*) * newSize</a>
<a name="ln5124">		+ sizeof(struct select_sync*) * newSize</a>
<a name="ln5125">		+ newCloseOnExitBitmapSize);</a>
<a name="ln5126">	if (newFDs == NULL)</a>
<a name="ln5127">		return B_NO_MEMORY;</a>
<a name="ln5128"> </a>
<a name="ln5129">	context-&gt;fds = newFDs;</a>
<a name="ln5130">	context-&gt;select_infos = (select_info**)(context-&gt;fds + newSize);</a>
<a name="ln5131">	context-&gt;fds_close_on_exec = (uint8*)(context-&gt;select_infos + newSize);</a>
<a name="ln5132">	context-&gt;table_size = newSize;</a>
<a name="ln5133"> </a>
<a name="ln5134">	// copy entries from old tables</a>
<a name="ln5135">	uint32 toCopy = min_c(oldSize, newSize);</a>
<a name="ln5136"> </a>
<a name="ln5137">	memcpy(context-&gt;fds, oldFDs, sizeof(void*) * toCopy);</a>
<a name="ln5138">	memcpy(context-&gt;select_infos, oldSelectInfos, sizeof(void*) * toCopy);</a>
<a name="ln5139">	memcpy(context-&gt;fds_close_on_exec, oldCloseOnExecTable,</a>
<a name="ln5140">		min_c(oldCloseOnExitBitmapSize, newCloseOnExitBitmapSize));</a>
<a name="ln5141"> </a>
<a name="ln5142">	// clear additional entries, if the tables grow</a>
<a name="ln5143">	if (newSize &gt; oldSize) {</a>
<a name="ln5144">		memset(context-&gt;fds + oldSize, 0, sizeof(void*) * (newSize - oldSize));</a>
<a name="ln5145">		memset(context-&gt;select_infos + oldSize, 0,</a>
<a name="ln5146">			sizeof(void*) * (newSize - oldSize));</a>
<a name="ln5147">		memset(context-&gt;fds_close_on_exec + oldCloseOnExitBitmapSize, 0,</a>
<a name="ln5148">			newCloseOnExitBitmapSize - oldCloseOnExitBitmapSize);</a>
<a name="ln5149">	}</a>
<a name="ln5150"> </a>
<a name="ln5151">	free(oldFDs);</a>
<a name="ln5152"> </a>
<a name="ln5153">	return B_OK;</a>
<a name="ln5154">}</a>
<a name="ln5155"> </a>
<a name="ln5156"> </a>
<a name="ln5157">/*!	\brief Resolves a vnode to the vnode it is covered by, if any.</a>
<a name="ln5158"> </a>
<a name="ln5159">	Given an arbitrary vnode (identified by mount and node ID), the function</a>
<a name="ln5160">	checks, whether the vnode is covered by another vnode. If it is, the</a>
<a name="ln5161">	function returns the mount and node ID of the covering vnode. Otherwise</a>
<a name="ln5162">	it simply returns the supplied mount and node ID.</a>
<a name="ln5163"> </a>
<a name="ln5164">	In case of error (e.g. the supplied node could not be found) the variables</a>
<a name="ln5165">	for storing the resolved mount and node ID remain untouched and an error</a>
<a name="ln5166">	code is returned.</a>
<a name="ln5167"> </a>
<a name="ln5168">	\param mountID The mount ID of the vnode in question.</a>
<a name="ln5169">	\param nodeID The node ID of the vnode in question.</a>
<a name="ln5170">	\param resolvedMountID Pointer to storage for the resolved mount ID.</a>
<a name="ln5171">	\param resolvedNodeID Pointer to storage for the resolved node ID.</a>
<a name="ln5172">	\return</a>
<a name="ln5173">	- \c B_OK, if everything went fine,</a>
<a name="ln5174">	- another error code, if something went wrong.</a>
<a name="ln5175">*/</a>
<a name="ln5176">status_t</a>
<a name="ln5177">vfs_resolve_vnode_to_covering_vnode(dev_t mountID, ino_t nodeID,</a>
<a name="ln5178">	dev_t* resolvedMountID, ino_t* resolvedNodeID)</a>
<a name="ln5179">{</a>
<a name="ln5180">	// get the node</a>
<a name="ln5181">	struct vnode* node;</a>
<a name="ln5182">	status_t error = get_vnode(mountID, nodeID, &amp;node, true, false);</a>
<a name="ln5183">	if (error != B_OK)</a>
<a name="ln5184">		return error;</a>
<a name="ln5185"> </a>
<a name="ln5186">	// resolve the node</a>
<a name="ln5187">	if (Vnode* coveringNode = get_covering_vnode(node)) {</a>
<a name="ln5188">		put_vnode(node);</a>
<a name="ln5189">		node = coveringNode;</a>
<a name="ln5190">	}</a>
<a name="ln5191"> </a>
<a name="ln5192">	// set the return values</a>
<a name="ln5193">	*resolvedMountID = node-&gt;device;</a>
<a name="ln5194">	*resolvedNodeID = node-&gt;id;</a>
<a name="ln5195"> </a>
<a name="ln5196">	put_vnode(node);</a>
<a name="ln5197"> </a>
<a name="ln5198">	return B_OK;</a>
<a name="ln5199">}</a>
<a name="ln5200"> </a>
<a name="ln5201"> </a>
<a name="ln5202">status_t</a>
<a name="ln5203">vfs_get_mount_point(dev_t mountID, dev_t* _mountPointMountID,</a>
<a name="ln5204">	ino_t* _mountPointNodeID)</a>
<a name="ln5205">{</a>
<a name="ln5206">	ReadLocker nodeLocker(sVnodeLock);</a>
<a name="ln5207">	MutexLocker mountLocker(sMountMutex);</a>
<a name="ln5208"> </a>
<a name="ln5209">	struct fs_mount* mount = find_mount(mountID);</a>
<a name="ln5210">	if (mount == NULL)</a>
<a name="ln5211">		return B_BAD_VALUE;</a>
<a name="ln5212"> </a>
<a name="ln5213">	Vnode* mountPoint = mount-&gt;covers_vnode;</a>
<a name="ln5214"> </a>
<a name="ln5215">	*_mountPointMountID = mountPoint-&gt;device;</a>
<a name="ln5216">	*_mountPointNodeID = mountPoint-&gt;id;</a>
<a name="ln5217"> </a>
<a name="ln5218">	return B_OK;</a>
<a name="ln5219">}</a>
<a name="ln5220"> </a>
<a name="ln5221"> </a>
<a name="ln5222">status_t</a>
<a name="ln5223">vfs_bind_mount_directory(dev_t mountID, ino_t nodeID, dev_t coveredMountID,</a>
<a name="ln5224">	ino_t coveredNodeID)</a>
<a name="ln5225">{</a>
<a name="ln5226">	// get the vnodes</a>
<a name="ln5227">	Vnode* vnode;</a>
<a name="ln5228">	status_t error = get_vnode(mountID, nodeID, &amp;vnode, true, false);</a>
<a name="ln5229">	if (error != B_OK)</a>
<a name="ln5230">		return B_BAD_VALUE;</a>
<a name="ln5231">	VNodePutter vnodePutter(vnode);</a>
<a name="ln5232"> </a>
<a name="ln5233">	Vnode* coveredVnode;</a>
<a name="ln5234">	error = get_vnode(coveredMountID, coveredNodeID, &amp;coveredVnode, true,</a>
<a name="ln5235">		false);</a>
<a name="ln5236">	if (error != B_OK)</a>
<a name="ln5237">		return B_BAD_VALUE;</a>
<a name="ln5238">	VNodePutter coveredVnodePutter(coveredVnode);</a>
<a name="ln5239"> </a>
<a name="ln5240">	// establish the covered/covering links</a>
<a name="ln5241">	WriteLocker locker(sVnodeLock);</a>
<a name="ln5242"> </a>
<a name="ln5243">	if (vnode-&gt;covers != NULL || coveredVnode-&gt;covered_by != NULL</a>
<a name="ln5244">		|| vnode-&gt;mount-&gt;unmounting || coveredVnode-&gt;mount-&gt;unmounting) {</a>
<a name="ln5245">		return B_BUSY;</a>
<a name="ln5246">	}</a>
<a name="ln5247"> </a>
<a name="ln5248">	vnode-&gt;covers = coveredVnode;</a>
<a name="ln5249">	vnode-&gt;SetCovering(true);</a>
<a name="ln5250"> </a>
<a name="ln5251">	coveredVnode-&gt;covered_by = vnode;</a>
<a name="ln5252">	coveredVnode-&gt;SetCovered(true);</a>
<a name="ln5253"> </a>
<a name="ln5254">	// the vnodes do now reference each other</a>
<a name="ln5255">	inc_vnode_ref_count(vnode);</a>
<a name="ln5256">	inc_vnode_ref_count(coveredVnode);</a>
<a name="ln5257"> </a>
<a name="ln5258">	return B_OK;</a>
<a name="ln5259">}</a>
<a name="ln5260"> </a>
<a name="ln5261"> </a>
<a name="ln5262">int</a>
<a name="ln5263">vfs_getrlimit(int resource, struct rlimit* rlp)</a>
<a name="ln5264">{</a>
<a name="ln5265">	if (!rlp)</a>
<a name="ln5266">		return B_BAD_ADDRESS;</a>
<a name="ln5267"> </a>
<a name="ln5268">	switch (resource) {</a>
<a name="ln5269">		case RLIMIT_NOFILE:</a>
<a name="ln5270">		{</a>
<a name="ln5271">			struct io_context* context = get_current_io_context(false);</a>
<a name="ln5272">			MutexLocker _(context-&gt;io_mutex);</a>
<a name="ln5273"> </a>
<a name="ln5274">			rlp-&gt;rlim_cur = context-&gt;table_size;</a>
<a name="ln5275">			rlp-&gt;rlim_max = MAX_FD_TABLE_SIZE;</a>
<a name="ln5276">			return 0;</a>
<a name="ln5277">		}</a>
<a name="ln5278"> </a>
<a name="ln5279">		case RLIMIT_NOVMON:</a>
<a name="ln5280">		{</a>
<a name="ln5281">			struct io_context* context = get_current_io_context(false);</a>
<a name="ln5282">			MutexLocker _(context-&gt;io_mutex);</a>
<a name="ln5283"> </a>
<a name="ln5284">			rlp-&gt;rlim_cur = context-&gt;max_monitors;</a>
<a name="ln5285">			rlp-&gt;rlim_max = MAX_NODE_MONITORS;</a>
<a name="ln5286">			return 0;</a>
<a name="ln5287">		}</a>
<a name="ln5288"> </a>
<a name="ln5289">		default:</a>
<a name="ln5290">			return B_BAD_VALUE;</a>
<a name="ln5291">	}</a>
<a name="ln5292">}</a>
<a name="ln5293"> </a>
<a name="ln5294"> </a>
<a name="ln5295">int</a>
<a name="ln5296">vfs_setrlimit(int resource, const struct rlimit* rlp)</a>
<a name="ln5297">{</a>
<a name="ln5298">	if (!rlp)</a>
<a name="ln5299">		return B_BAD_ADDRESS;</a>
<a name="ln5300"> </a>
<a name="ln5301">	switch (resource) {</a>
<a name="ln5302">		case RLIMIT_NOFILE:</a>
<a name="ln5303">			/* TODO: check getuid() */</a>
<a name="ln5304">			if (rlp-&gt;rlim_max != RLIM_SAVED_MAX</a>
<a name="ln5305">				&amp;&amp; rlp-&gt;rlim_max != MAX_FD_TABLE_SIZE)</a>
<a name="ln5306">				return B_NOT_ALLOWED;</a>
<a name="ln5307"> </a>
<a name="ln5308">			return vfs_resize_fd_table(get_current_io_context(false),</a>
<a name="ln5309">				rlp-&gt;rlim_cur);</a>
<a name="ln5310"> </a>
<a name="ln5311">		case RLIMIT_NOVMON:</a>
<a name="ln5312">			/* TODO: check getuid() */</a>
<a name="ln5313">			if (rlp-&gt;rlim_max != RLIM_SAVED_MAX</a>
<a name="ln5314">				&amp;&amp; rlp-&gt;rlim_max != MAX_NODE_MONITORS)</a>
<a name="ln5315">				return B_NOT_ALLOWED;</a>
<a name="ln5316"> </a>
<a name="ln5317">			return resize_monitor_table(get_current_io_context(false),</a>
<a name="ln5318">				rlp-&gt;rlim_cur);</a>
<a name="ln5319"> </a>
<a name="ln5320">		default:</a>
<a name="ln5321">			return B_BAD_VALUE;</a>
<a name="ln5322">	}</a>
<a name="ln5323">}</a>
<a name="ln5324"> </a>
<a name="ln5325"> </a>
<a name="ln5326">status_t</a>
<a name="ln5327">vfs_init(kernel_args* args)</a>
<a name="ln5328">{</a>
<a name="ln5329">	vnode::StaticInit();</a>
<a name="ln5330"> </a>
<a name="ln5331">	sVnodeTable = new(std::nothrow) VnodeTable();</a>
<a name="ln5332">	if (sVnodeTable == NULL || sVnodeTable-&gt;Init(VNODE_HASH_TABLE_SIZE) != B_OK)</a>
<a name="ln5333">		panic(&quot;vfs_init: error creating vnode hash table\n&quot;);</a>
<a name="ln5334"> </a>
<a name="ln5335">	struct vnode dummy_vnode;</a>
<a name="ln5336">	list_init_etc(&amp;sUnusedVnodeList, offset_of_member(dummy_vnode, unused_link));</a>
<a name="ln5337"> </a>
<a name="ln5338">	struct fs_mount dummyMount;</a>
<a name="ln5339">	sMountsTable = new(std::nothrow) MountTable();</a>
<a name="ln5340">	if (sMountsTable == NULL</a>
<a name="ln5341">			|| sMountsTable-&gt;Init(MOUNTS_HASH_TABLE_SIZE) != B_OK)</a>
<a name="ln5342">		panic(&quot;vfs_init: error creating mounts hash table\n&quot;);</a>
<a name="ln5343"> </a>
<a name="ln5344">	node_monitor_init();</a>
<a name="ln5345"> </a>
<a name="ln5346">	sRoot = NULL;</a>
<a name="ln5347"> </a>
<a name="ln5348">	recursive_lock_init(&amp;sMountOpLock, &quot;vfs_mount_op_lock&quot;);</a>
<a name="ln5349"> </a>
<a name="ln5350">	if (block_cache_init() != B_OK)</a>
<a name="ln5351">		return B_ERROR;</a>
<a name="ln5352"> </a>
<a name="ln5353">#ifdef ADD_DEBUGGER_COMMANDS</a>
<a name="ln5354">	// add some debugger commands</a>
<a name="ln5355">	add_debugger_command_etc(&quot;vnode&quot;, &amp;dump_vnode,</a>
<a name="ln5356">		&quot;Print info about the specified vnode&quot;,</a>
<a name="ln5357">		&quot;[ \&quot;-p\&quot; ] ( &lt;vnode&gt; | &lt;devID&gt; &lt;nodeID&gt; )\n&quot;</a>
<a name="ln5358">		&quot;Prints information about the vnode specified by address &lt;vnode&gt; or\n&quot;</a>
<a name="ln5359">		&quot;&lt;devID&gt;, &lt;vnodeID&gt; pair. If \&quot;-p\&quot; is given, a path of the vnode is\n&quot;</a>
<a name="ln5360">		&quot;constructed and printed. It might not be possible to construct a\n&quot;</a>
<a name="ln5361">		&quot;complete path, though.\n&quot;,</a>
<a name="ln5362">		0);</a>
<a name="ln5363">	add_debugger_command(&quot;vnodes&quot;, &amp;dump_vnodes,</a>
<a name="ln5364">		&quot;list all vnodes (from the specified device)&quot;);</a>
<a name="ln5365">	add_debugger_command(&quot;vnode_caches&quot;, &amp;dump_vnode_caches,</a>
<a name="ln5366">		&quot;list all vnode caches&quot;);</a>
<a name="ln5367">	add_debugger_command(&quot;mount&quot;, &amp;dump_mount,</a>
<a name="ln5368">		&quot;info about the specified fs_mount&quot;);</a>
<a name="ln5369">	add_debugger_command(&quot;mounts&quot;, &amp;dump_mounts, &quot;list all fs_mounts&quot;);</a>
<a name="ln5370">	add_debugger_command(&quot;io_context&quot;, &amp;dump_io_context,</a>
<a name="ln5371">		&quot;info about the I/O context&quot;);</a>
<a name="ln5372">	add_debugger_command(&quot;vnode_usage&quot;, &amp;dump_vnode_usage,</a>
<a name="ln5373">		&quot;info about vnode usage&quot;);</a>
<a name="ln5374">#endif</a>
<a name="ln5375"> </a>
<a name="ln5376">	register_low_resource_handler(&amp;vnode_low_resource_handler, NULL,</a>
<a name="ln5377">		B_KERNEL_RESOURCE_PAGES | B_KERNEL_RESOURCE_MEMORY</a>
<a name="ln5378">			| B_KERNEL_RESOURCE_ADDRESS_SPACE,</a>
<a name="ln5379">		0);</a>
<a name="ln5380"> </a>
<a name="ln5381">	fifo_init();</a>
<a name="ln5382">	file_map_init();</a>
<a name="ln5383"> </a>
<a name="ln5384">	return file_cache_init();</a>
<a name="ln5385">}</a>
<a name="ln5386"> </a>
<a name="ln5387"> </a>
<a name="ln5388">//	#pragma mark - fd_ops implementations</a>
<a name="ln5389"> </a>
<a name="ln5390"> </a>
<a name="ln5391">/*!</a>
<a name="ln5392">	Calls fs_open() on the given vnode and returns a new</a>
<a name="ln5393">	file descriptor for it</a>
<a name="ln5394">*/</a>
<a name="ln5395">static int</a>
<a name="ln5396">open_vnode(struct vnode* vnode, int openMode, bool kernel)</a>
<a name="ln5397">{</a>
<a name="ln5398">	void* cookie;</a>
<a name="ln5399">	status_t status = FS_CALL(vnode, open, openMode, &amp;cookie);</a>
<a name="ln5400">	if (status != B_OK)</a>
<a name="ln5401">		return status;</a>
<a name="ln5402"> </a>
<a name="ln5403">	int fd = get_new_fd(FDTYPE_FILE, NULL, vnode, cookie, openMode, kernel);</a>
<a name="ln5404">	if (fd &lt; 0) {</a>
<a name="ln5405">		FS_CALL(vnode, close, cookie);</a>
<a name="ln5406">		FS_CALL(vnode, free_cookie, cookie);</a>
<a name="ln5407">	}</a>
<a name="ln5408">	return fd;</a>
<a name="ln5409">}</a>
<a name="ln5410"> </a>
<a name="ln5411"> </a>
<a name="ln5412">/*!</a>
<a name="ln5413">	Calls fs_open() on the given vnode and returns a new</a>
<a name="ln5414">	file descriptor for it</a>
<a name="ln5415">*/</a>
<a name="ln5416">static int</a>
<a name="ln5417">create_vnode(struct vnode* directory, const char* name, int openMode,</a>
<a name="ln5418">	int perms, bool kernel)</a>
<a name="ln5419">{</a>
<a name="ln5420">	bool traverse = ((openMode &amp; (O_NOTRAVERSE | O_NOFOLLOW)) == 0);</a>
<a name="ln5421">	status_t status = B_ERROR;</a>
<a name="ln5422">	struct vnode* vnode;</a>
<a name="ln5423">	void* cookie;</a>
<a name="ln5424">	ino_t newID;</a>
<a name="ln5425"> </a>
<a name="ln5426">	// This is somewhat tricky: If the entry already exists, the FS responsible</a>
<a name="ln5427">	// for the directory might not necessarily also be the one responsible for</a>
<a name="ln5428">	// the node the entry refers to (e.g. in case of mount points or FIFOs). So</a>
<a name="ln5429">	// we can actually never call the create() hook without O_EXCL. Instead we</a>
<a name="ln5430">	// try to look the entry up first. If it already exists, we just open the</a>
<a name="ln5431">	// node (unless O_EXCL), otherwise we call create() with O_EXCL. This</a>
<a name="ln5432">	// introduces a race condition, since someone else might have created the</a>
<a name="ln5433">	// entry in the meantime. We hope the respective FS returns the correct</a>
<a name="ln5434">	// error code and retry (up to 3 times) again.</a>
<a name="ln5435"> </a>
<a name="ln5436">	for (int i = 0; i &lt; 3 &amp;&amp; status != B_OK; i++) {</a>
<a name="ln5437">		// look the node up</a>
<a name="ln5438">		status = lookup_dir_entry(directory, name, &amp;vnode);</a>
<a name="ln5439">		if (status == B_OK) {</a>
<a name="ln5440">			VNodePutter putter(vnode);</a>
<a name="ln5441"> </a>
<a name="ln5442">			if ((openMode &amp; O_EXCL) != 0)</a>
<a name="ln5443">				return B_FILE_EXISTS;</a>
<a name="ln5444"> </a>
<a name="ln5445">			// If the node is a symlink, we have to follow it, unless</a>
<a name="ln5446">			// O_NOTRAVERSE is set.</a>
<a name="ln5447">			if (S_ISLNK(vnode-&gt;Type()) &amp;&amp; traverse) {</a>
<a name="ln5448">				putter.Put();</a>
<a name="ln5449">				char clonedName[B_FILE_NAME_LENGTH + 1];</a>
<a name="ln5450">				if (strlcpy(clonedName, name, B_FILE_NAME_LENGTH)</a>
<a name="ln5451">						&gt;= B_FILE_NAME_LENGTH) {</a>
<a name="ln5452">					return B_NAME_TOO_LONG;</a>
<a name="ln5453">				}</a>
<a name="ln5454"> </a>
<a name="ln5455">				inc_vnode_ref_count(directory);</a>
<a name="ln5456">				status = vnode_path_to_vnode(directory, clonedName, true, 0,</a>
<a name="ln5457">					kernel, &amp;vnode, NULL);</a>
<a name="ln5458">				if (status != B_OK)</a>
<a name="ln5459">					return status;</a>
<a name="ln5460"> </a>
<a name="ln5461">				putter.SetTo(vnode);</a>
<a name="ln5462">			}</a>
<a name="ln5463"> </a>
<a name="ln5464">			if ((openMode &amp; O_NOFOLLOW) != 0 &amp;&amp; S_ISLNK(vnode-&gt;Type()))</a>
<a name="ln5465">				return B_LINK_LIMIT;</a>
<a name="ln5466"> </a>
<a name="ln5467">			int fd = open_vnode(vnode, openMode &amp; ~O_CREAT, kernel);</a>
<a name="ln5468">			// on success keep the vnode reference for the FD</a>
<a name="ln5469">			if (fd &gt;= 0)</a>
<a name="ln5470">				putter.Detach();</a>
<a name="ln5471"> </a>
<a name="ln5472">			return fd;</a>
<a name="ln5473">		}</a>
<a name="ln5474"> </a>
<a name="ln5475">		// it doesn't exist yet -- try to create it</a>
<a name="ln5476"> </a>
<a name="ln5477">		if (!HAS_FS_CALL(directory, create))</a>
<a name="ln5478">			return B_READ_ONLY_DEVICE;</a>
<a name="ln5479"> </a>
<a name="ln5480">		status = FS_CALL(directory, create, name, openMode | O_EXCL, perms,</a>
<a name="ln5481">			&amp;cookie, &amp;newID);</a>
<a name="ln5482">		if (status != B_OK</a>
<a name="ln5483">			&amp;&amp; ((openMode &amp; O_EXCL) != 0 || status != B_FILE_EXISTS)) {</a>
<a name="ln5484">			return status;</a>
<a name="ln5485">		}</a>
<a name="ln5486">	}</a>
<a name="ln5487"> </a>
<a name="ln5488">	if (status != B_OK)</a>
<a name="ln5489">		return status;</a>
<a name="ln5490"> </a>
<a name="ln5491">	// the node has been created successfully</a>
<a name="ln5492"> </a>
<a name="ln5493">	rw_lock_read_lock(&amp;sVnodeLock);</a>
<a name="ln5494">	vnode = lookup_vnode(directory-&gt;device, newID);</a>
<a name="ln5495">	rw_lock_read_unlock(&amp;sVnodeLock);</a>
<a name="ln5496"> </a>
<a name="ln5497">	if (vnode == NULL) {</a>
<a name="ln5498">		panic(&quot;vfs: fs_create() returned success but there is no vnode, &quot;</a>
<a name="ln5499">			&quot;mount ID %&quot; B_PRIdDEV &quot;!\n&quot;, directory-&gt;device);</a>
<a name="ln5500">		return B_BAD_VALUE;</a>
<a name="ln5501">	}</a>
<a name="ln5502"> </a>
<a name="ln5503">	int fd = get_new_fd(FDTYPE_FILE, NULL, vnode, cookie, openMode, kernel);</a>
<a name="ln5504">	if (fd &gt;= 0)</a>
<a name="ln5505">		return fd;</a>
<a name="ln5506"> </a>
<a name="ln5507">	status = fd;</a>
<a name="ln5508"> </a>
<a name="ln5509">	// something went wrong, clean up</a>
<a name="ln5510"> </a>
<a name="ln5511">	FS_CALL(vnode, close, cookie);</a>
<a name="ln5512">	FS_CALL(vnode, free_cookie, cookie);</a>
<a name="ln5513">	put_vnode(vnode);</a>
<a name="ln5514"> </a>
<a name="ln5515">	FS_CALL(directory, unlink, name);</a>
<a name="ln5516"> </a>
<a name="ln5517">	return status;</a>
<a name="ln5518">}</a>
<a name="ln5519"> </a>
<a name="ln5520"> </a>
<a name="ln5521">/*! Calls fs open_dir() on the given vnode and returns a new</a>
<a name="ln5522">	file descriptor for it</a>
<a name="ln5523">*/</a>
<a name="ln5524">static int</a>
<a name="ln5525">open_dir_vnode(struct vnode* vnode, bool kernel)</a>
<a name="ln5526">{</a>
<a name="ln5527">	void* cookie;</a>
<a name="ln5528">	status_t status = FS_CALL(vnode, open_dir, &amp;cookie);</a>
<a name="ln5529">	if (status != B_OK)</a>
<a name="ln5530">		return status;</a>
<a name="ln5531"> </a>
<a name="ln5532">	// directory is opened, create a fd</a>
<a name="ln5533">	status = get_new_fd(FDTYPE_DIR, NULL, vnode, cookie, O_CLOEXEC, kernel);</a>
<a name="ln5534">	if (status &gt;= 0)</a>
<a name="ln5535">		return status;</a>
<a name="ln5536"> </a>
<a name="ln5537">	FS_CALL(vnode, close_dir, cookie);</a>
<a name="ln5538">	FS_CALL(vnode, free_dir_cookie, cookie);</a>
<a name="ln5539"> </a>
<a name="ln5540">	return status;</a>
<a name="ln5541">}</a>
<a name="ln5542"> </a>
<a name="ln5543"> </a>
<a name="ln5544">/*! Calls fs open_attr_dir() on the given vnode and returns a new</a>
<a name="ln5545">	file descriptor for it.</a>
<a name="ln5546">	Used by attr_dir_open(), and attr_dir_open_fd().</a>
<a name="ln5547">*/</a>
<a name="ln5548">static int</a>
<a name="ln5549">open_attr_dir_vnode(struct vnode* vnode, bool kernel)</a>
<a name="ln5550">{</a>
<a name="ln5551">	if (!HAS_FS_CALL(vnode, open_attr_dir))</a>
<a name="ln5552">		return B_UNSUPPORTED;</a>
<a name="ln5553"> </a>
<a name="ln5554">	void* cookie;</a>
<a name="ln5555">	status_t status = FS_CALL(vnode, open_attr_dir, &amp;cookie);</a>
<a name="ln5556">	if (status != B_OK)</a>
<a name="ln5557">		return status;</a>
<a name="ln5558"> </a>
<a name="ln5559">	// directory is opened, create a fd</a>
<a name="ln5560">	status = get_new_fd(FDTYPE_ATTR_DIR, NULL, vnode, cookie, O_CLOEXEC,</a>
<a name="ln5561">		kernel);</a>
<a name="ln5562">	if (status &gt;= 0)</a>
<a name="ln5563">		return status;</a>
<a name="ln5564"> </a>
<a name="ln5565">	FS_CALL(vnode, close_attr_dir, cookie);</a>
<a name="ln5566">	FS_CALL(vnode, free_attr_dir_cookie, cookie);</a>
<a name="ln5567"> </a>
<a name="ln5568">	return status;</a>
<a name="ln5569">}</a>
<a name="ln5570"> </a>
<a name="ln5571"> </a>
<a name="ln5572">static int</a>
<a name="ln5573">file_create_entry_ref(dev_t mountID, ino_t directoryID, const char* name,</a>
<a name="ln5574">	int openMode, int perms, bool kernel)</a>
<a name="ln5575">{</a>
<a name="ln5576">	FUNCTION((&quot;file_create_entry_ref: name = '%s', omode %x, perms %d, &quot;</a>
<a name="ln5577">		&quot;kernel %d\n&quot;, name, openMode, perms, kernel));</a>
<a name="ln5578"> </a>
<a name="ln5579">	// get directory to put the new file in</a>
<a name="ln5580">	struct vnode* directory;</a>
<a name="ln5581">	status_t status = get_vnode(mountID, directoryID, &amp;directory, true, false);</a>
<a name="ln5582">	if (status != B_OK)</a>
<a name="ln5583">		return status;</a>
<a name="ln5584"> </a>
<a name="ln5585">	status = create_vnode(directory, name, openMode, perms, kernel);</a>
<a name="ln5586">	put_vnode(directory);</a>
<a name="ln5587"> </a>
<a name="ln5588">	return status;</a>
<a name="ln5589">}</a>
<a name="ln5590"> </a>
<a name="ln5591"> </a>
<a name="ln5592">static int</a>
<a name="ln5593">file_create(int fd, char* path, int openMode, int perms, bool kernel)</a>
<a name="ln5594">{</a>
<a name="ln5595">	FUNCTION((&quot;file_create: path '%s', omode %x, perms %d, kernel %d\n&quot;, path,</a>
<a name="ln5596">		openMode, perms, kernel));</a>
<a name="ln5597"> </a>
<a name="ln5598">	// get directory to put the new file in</a>
<a name="ln5599">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln5600">	struct vnode* directory;</a>
<a name="ln5601">	status_t status = fd_and_path_to_dir_vnode(fd, path, &amp;directory, name,</a>
<a name="ln5602">		kernel);</a>
<a name="ln5603">	if (status &lt; 0)</a>
<a name="ln5604">		return status;</a>
<a name="ln5605"> </a>
<a name="ln5606">	status = create_vnode(directory, name, openMode, perms, kernel);</a>
<a name="ln5607"> </a>
<a name="ln5608">	put_vnode(directory);</a>
<a name="ln5609">	return status;</a>
<a name="ln5610">}</a>
<a name="ln5611"> </a>
<a name="ln5612"> </a>
<a name="ln5613">static int</a>
<a name="ln5614">file_open_entry_ref(dev_t mountID, ino_t directoryID, const char* name,</a>
<a name="ln5615">	int openMode, bool kernel)</a>
<a name="ln5616">{</a>
<a name="ln5617">	if (name == NULL || *name == '\0')</a>
<a name="ln5618">		return B_BAD_VALUE;</a>
<a name="ln5619"> </a>
<a name="ln5620">	FUNCTION((&quot;file_open_entry_ref(ref = (%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;, %s), &quot;</a>
<a name="ln5621">		&quot;openMode = %d)\n&quot;, mountID, directoryID, name, openMode));</a>
<a name="ln5622"> </a>
<a name="ln5623">	bool traverse = (openMode &amp; (O_NOTRAVERSE | O_NOFOLLOW)) == 0;</a>
<a name="ln5624"> </a>
<a name="ln5625">	// get the vnode matching the entry_ref</a>
<a name="ln5626">	struct vnode* vnode;</a>
<a name="ln5627">	status_t status = entry_ref_to_vnode(mountID, directoryID, name, traverse,</a>
<a name="ln5628">		kernel, &amp;vnode);</a>
<a name="ln5629">	if (status != B_OK)</a>
<a name="ln5630">		return status;</a>
<a name="ln5631"> </a>
<a name="ln5632">	if ((openMode &amp; O_NOFOLLOW) != 0 &amp;&amp; S_ISLNK(vnode-&gt;Type())) {</a>
<a name="ln5633">		put_vnode(vnode);</a>
<a name="ln5634">		return B_LINK_LIMIT;</a>
<a name="ln5635">	}</a>
<a name="ln5636"> </a>
<a name="ln5637">	int newFD = open_vnode(vnode, openMode, kernel);</a>
<a name="ln5638">	if (newFD &gt;= 0) {</a>
<a name="ln5639">		// The vnode reference has been transferred to the FD</a>
<a name="ln5640">		cache_node_opened(vnode, FDTYPE_FILE, vnode-&gt;cache, mountID,</a>
<a name="ln5641">			directoryID, vnode-&gt;id, name);</a>
<a name="ln5642">	} else</a>
<a name="ln5643">		put_vnode(vnode);</a>
<a name="ln5644"> </a>
<a name="ln5645">	return newFD;</a>
<a name="ln5646">}</a>
<a name="ln5647"> </a>
<a name="ln5648"> </a>
<a name="ln5649">static int</a>
<a name="ln5650">file_open(int fd, char* path, int openMode, bool kernel)</a>
<a name="ln5651">{</a>
<a name="ln5652">	bool traverse = (openMode &amp; (O_NOTRAVERSE | O_NOFOLLOW)) == 0;</a>
<a name="ln5653"> </a>
<a name="ln5654">	FUNCTION((&quot;file_open: fd: %d, entry path = '%s', omode %d, kernel %d\n&quot;,</a>
<a name="ln5655">		fd, path, openMode, kernel));</a>
<a name="ln5656"> </a>
<a name="ln5657">	// get the vnode matching the vnode + path combination</a>
<a name="ln5658">	struct vnode* vnode;</a>
<a name="ln5659">	ino_t parentID;</a>
<a name="ln5660">	status_t status = fd_and_path_to_vnode(fd, path, traverse, &amp;vnode,</a>
<a name="ln5661">		&amp;parentID, kernel);</a>
<a name="ln5662">	if (status != B_OK)</a>
<a name="ln5663">		return status;</a>
<a name="ln5664"> </a>
<a name="ln5665">	if ((openMode &amp; O_NOFOLLOW) != 0 &amp;&amp; S_ISLNK(vnode-&gt;Type())) {</a>
<a name="ln5666">		put_vnode(vnode);</a>
<a name="ln5667">		return B_LINK_LIMIT;</a>
<a name="ln5668">	}</a>
<a name="ln5669"> </a>
<a name="ln5670">	// open the vnode</a>
<a name="ln5671">	int newFD = open_vnode(vnode, openMode, kernel);</a>
<a name="ln5672">	if (newFD &gt;= 0) {</a>
<a name="ln5673">		// The vnode reference has been transferred to the FD</a>
<a name="ln5674">		cache_node_opened(vnode, FDTYPE_FILE, vnode-&gt;cache,</a>
<a name="ln5675">			vnode-&gt;device, parentID, vnode-&gt;id, NULL);</a>
<a name="ln5676">	} else</a>
<a name="ln5677">		put_vnode(vnode);</a>
<a name="ln5678"> </a>
<a name="ln5679">	return newFD;</a>
<a name="ln5680">}</a>
<a name="ln5681"> </a>
<a name="ln5682"> </a>
<a name="ln5683">static status_t</a>
<a name="ln5684">file_close(struct file_descriptor* descriptor)</a>
<a name="ln5685">{</a>
<a name="ln5686">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5687">	status_t status = B_OK;</a>
<a name="ln5688"> </a>
<a name="ln5689">	FUNCTION((&quot;file_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln5690"> </a>
<a name="ln5691">	cache_node_closed(vnode, FDTYPE_FILE, vnode-&gt;cache, vnode-&gt;device,</a>
<a name="ln5692">		vnode-&gt;id);</a>
<a name="ln5693">	if (HAS_FS_CALL(vnode, close)) {</a>
<a name="ln5694">		status = FS_CALL(vnode, close, descriptor-&gt;cookie);</a>
<a name="ln5695">	}</a>
<a name="ln5696"> </a>
<a name="ln5697">	if (status == B_OK) {</a>
<a name="ln5698">		// remove all outstanding locks for this team</a>
<a name="ln5699">		if (HAS_FS_CALL(vnode, release_lock))</a>
<a name="ln5700">			status = FS_CALL(vnode, release_lock, descriptor-&gt;cookie, NULL);</a>
<a name="ln5701">		else</a>
<a name="ln5702">			status = release_advisory_lock(vnode, NULL, descriptor, NULL);</a>
<a name="ln5703">	}</a>
<a name="ln5704">	return status;</a>
<a name="ln5705">}</a>
<a name="ln5706"> </a>
<a name="ln5707"> </a>
<a name="ln5708">static void</a>
<a name="ln5709">file_free_fd(struct file_descriptor* descriptor)</a>
<a name="ln5710">{</a>
<a name="ln5711">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5712"> </a>
<a name="ln5713">	if (vnode != NULL) {</a>
<a name="ln5714">		FS_CALL(vnode, free_cookie, descriptor-&gt;cookie);</a>
<a name="ln5715">		put_vnode(vnode);</a>
<a name="ln5716">	}</a>
<a name="ln5717">}</a>
<a name="ln5718"> </a>
<a name="ln5719"> </a>
<a name="ln5720">static status_t</a>
<a name="ln5721">file_read(struct file_descriptor* descriptor, off_t pos, void* buffer,</a>
<a name="ln5722">	size_t* length)</a>
<a name="ln5723">{</a>
<a name="ln5724">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5725">	FUNCTION((&quot;file_read: buf %p, pos %&quot; B_PRIdOFF &quot;, len %p = %ld\n&quot;, buffer,</a>
<a name="ln5726">		pos, length, *length));</a>
<a name="ln5727"> </a>
<a name="ln5728">	if (S_ISDIR(vnode-&gt;Type()))</a>
<a name="ln5729">		return B_IS_A_DIRECTORY;</a>
<a name="ln5730"> </a>
<a name="ln5731">	return FS_CALL(vnode, read, descriptor-&gt;cookie, pos, buffer, length);</a>
<a name="ln5732">}</a>
<a name="ln5733"> </a>
<a name="ln5734"> </a>
<a name="ln5735">static status_t</a>
<a name="ln5736">file_write(struct file_descriptor* descriptor, off_t pos, const void* buffer,</a>
<a name="ln5737">	size_t* length)</a>
<a name="ln5738">{</a>
<a name="ln5739">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5740">	FUNCTION((&quot;file_write: buf %p, pos %&quot; B_PRIdOFF &quot;, len %p\n&quot;, buffer, pos,</a>
<a name="ln5741">		length));</a>
<a name="ln5742"> </a>
<a name="ln5743">	if (S_ISDIR(vnode-&gt;Type()))</a>
<a name="ln5744">		return B_IS_A_DIRECTORY;</a>
<a name="ln5745">	if (!HAS_FS_CALL(vnode, write))</a>
<a name="ln5746">		return B_READ_ONLY_DEVICE;</a>
<a name="ln5747"> </a>
<a name="ln5748">	return FS_CALL(vnode, write, descriptor-&gt;cookie, pos, buffer, length);</a>
<a name="ln5749">}</a>
<a name="ln5750"> </a>
<a name="ln5751"> </a>
<a name="ln5752">static off_t</a>
<a name="ln5753">file_seek(struct file_descriptor* descriptor, off_t pos, int seekType)</a>
<a name="ln5754">{</a>
<a name="ln5755">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5756">	off_t offset;</a>
<a name="ln5757">	bool isDevice = false;</a>
<a name="ln5758"> </a>
<a name="ln5759">	FUNCTION((&quot;file_seek(pos = %&quot; B_PRIdOFF &quot;, seekType = %d)\n&quot;, pos,</a>
<a name="ln5760">		seekType));</a>
<a name="ln5761"> </a>
<a name="ln5762">	// some kinds of files are not seekable</a>
<a name="ln5763">	switch (vnode-&gt;Type() &amp; S_IFMT) {</a>
<a name="ln5764">		case S_IFIFO:</a>
<a name="ln5765">		case S_IFSOCK:</a>
<a name="ln5766">			return ESPIPE;</a>
<a name="ln5767"> </a>
<a name="ln5768">		// drivers publish block devices as chr, so pick both</a>
<a name="ln5769">		case S_IFBLK:</a>
<a name="ln5770">		case S_IFCHR:</a>
<a name="ln5771">			isDevice = true;</a>
<a name="ln5772">			break;</a>
<a name="ln5773">		// The Open Group Base Specs don't mention any file types besides pipes,</a>
<a name="ln5774">		// fifos, and sockets specially, so we allow seeking them.</a>
<a name="ln5775">		case S_IFREG:</a>
<a name="ln5776">		case S_IFDIR:</a>
<a name="ln5777">		case S_IFLNK:</a>
<a name="ln5778">			break;</a>
<a name="ln5779">	}</a>
<a name="ln5780"> </a>
<a name="ln5781">	switch (seekType) {</a>
<a name="ln5782">		case SEEK_SET:</a>
<a name="ln5783">			offset = 0;</a>
<a name="ln5784">			break;</a>
<a name="ln5785">		case SEEK_CUR:</a>
<a name="ln5786">			offset = descriptor-&gt;pos;</a>
<a name="ln5787">			break;</a>
<a name="ln5788">		case SEEK_END:</a>
<a name="ln5789">		{</a>
<a name="ln5790">			// stat() the node</a>
<a name="ln5791">			if (!HAS_FS_CALL(vnode, read_stat))</a>
<a name="ln5792">				return B_UNSUPPORTED;</a>
<a name="ln5793"> </a>
<a name="ln5794">			struct stat stat;</a>
<a name="ln5795">			status_t status = FS_CALL(vnode, read_stat, &amp;stat);</a>
<a name="ln5796">			if (status != B_OK)</a>
<a name="ln5797">				return status;</a>
<a name="ln5798"> </a>
<a name="ln5799">			offset = stat.st_size;</a>
<a name="ln5800"> </a>
<a name="ln5801">			if (offset == 0 &amp;&amp; isDevice) {</a>
<a name="ln5802">				// stat() on regular drivers doesn't report size</a>
<a name="ln5803">				device_geometry geometry;</a>
<a name="ln5804"> </a>
<a name="ln5805">				if (HAS_FS_CALL(vnode, ioctl)) {</a>
<a name="ln5806">					status = FS_CALL(vnode, ioctl, descriptor-&gt;cookie,</a>
<a name="ln5807">						B_GET_GEOMETRY, &amp;geometry, sizeof(geometry));</a>
<a name="ln5808">					if (status == B_OK)</a>
<a name="ln5809">						offset = (off_t)geometry.bytes_per_sector</a>
<a name="ln5810">							* geometry.sectors_per_track</a>
<a name="ln5811">							* geometry.cylinder_count</a>
<a name="ln5812">							* geometry.head_count;</a>
<a name="ln5813">				}</a>
<a name="ln5814">			}</a>
<a name="ln5815"> </a>
<a name="ln5816">			break;</a>
<a name="ln5817">		}</a>
<a name="ln5818">		default:</a>
<a name="ln5819">			return B_BAD_VALUE;</a>
<a name="ln5820">	}</a>
<a name="ln5821"> </a>
<a name="ln5822">	// assumes off_t is 64 bits wide</a>
<a name="ln5823">	if (offset &gt; 0 &amp;&amp; LONGLONG_MAX - offset &lt; pos)</a>
<a name="ln5824">		return B_BUFFER_OVERFLOW;</a>
<a name="ln5825"> </a>
<a name="ln5826">	pos += offset;</a>
<a name="ln5827">	if (pos &lt; 0)</a>
<a name="ln5828">		return B_BAD_VALUE;</a>
<a name="ln5829"> </a>
<a name="ln5830">	return descriptor-&gt;pos = pos;</a>
<a name="ln5831">}</a>
<a name="ln5832"> </a>
<a name="ln5833"> </a>
<a name="ln5834">static status_t</a>
<a name="ln5835">file_select(struct file_descriptor* descriptor, uint8 event,</a>
<a name="ln5836">	struct selectsync* sync)</a>
<a name="ln5837">{</a>
<a name="ln5838">	FUNCTION((&quot;file_select(%p, %u, %p)\n&quot;, descriptor, event, sync));</a>
<a name="ln5839"> </a>
<a name="ln5840">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5841"> </a>
<a name="ln5842">	// If the FS has no select() hook, notify select() now.</a>
<a name="ln5843">	if (!HAS_FS_CALL(vnode, select)) {</a>
<a name="ln5844">		if (!SELECT_TYPE_IS_OUTPUT_ONLY(event))</a>
<a name="ln5845">			return notify_select_event(sync, event);</a>
<a name="ln5846">		else</a>
<a name="ln5847">			return B_OK;</a>
<a name="ln5848">	}</a>
<a name="ln5849"> </a>
<a name="ln5850">	return FS_CALL(vnode, select, descriptor-&gt;cookie, event, sync);</a>
<a name="ln5851">}</a>
<a name="ln5852"> </a>
<a name="ln5853"> </a>
<a name="ln5854">static status_t</a>
<a name="ln5855">file_deselect(struct file_descriptor* descriptor, uint8 event,</a>
<a name="ln5856">	struct selectsync* sync)</a>
<a name="ln5857">{</a>
<a name="ln5858">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5859"> </a>
<a name="ln5860">	if (!HAS_FS_CALL(vnode, deselect))</a>
<a name="ln5861">		return B_OK;</a>
<a name="ln5862"> </a>
<a name="ln5863">	return FS_CALL(vnode, deselect, descriptor-&gt;cookie, event, sync);</a>
<a name="ln5864">}</a>
<a name="ln5865"> </a>
<a name="ln5866"> </a>
<a name="ln5867">static status_t</a>
<a name="ln5868">dir_create_entry_ref(dev_t mountID, ino_t parentID, const char* name, int perms,</a>
<a name="ln5869">	bool kernel)</a>
<a name="ln5870">{</a>
<a name="ln5871">	struct vnode* vnode;</a>
<a name="ln5872">	status_t status;</a>
<a name="ln5873"> </a>
<a name="ln5874">	if (name == NULL || *name == '\0')</a>
<a name="ln5875">		return B_BAD_VALUE;</a>
<a name="ln5876"> </a>
<a name="ln5877">	FUNCTION((&quot;dir_create_entry_ref(dev = %&quot; B_PRId32 &quot;, ino = %&quot; B_PRId64 &quot;, &quot;</a>
<a name="ln5878">		&quot;name = '%s', perms = %d)\n&quot;, mountID, parentID, name, perms));</a>
<a name="ln5879"> </a>
<a name="ln5880">	status = get_vnode(mountID, parentID, &amp;vnode, true, false);</a>
<a name="ln5881">	if (status != B_OK)</a>
<a name="ln5882">		return status;</a>
<a name="ln5883"> </a>
<a name="ln5884">	if (HAS_FS_CALL(vnode, create_dir))</a>
<a name="ln5885">		status = FS_CALL(vnode, create_dir, name, perms);</a>
<a name="ln5886">	else</a>
<a name="ln5887">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln5888"> </a>
<a name="ln5889">	put_vnode(vnode);</a>
<a name="ln5890">	return status;</a>
<a name="ln5891">}</a>
<a name="ln5892"> </a>
<a name="ln5893"> </a>
<a name="ln5894">static status_t</a>
<a name="ln5895">dir_create(int fd, char* path, int perms, bool kernel)</a>
<a name="ln5896">{</a>
<a name="ln5897">	char filename[B_FILE_NAME_LENGTH];</a>
<a name="ln5898">	struct vnode* vnode;</a>
<a name="ln5899">	status_t status;</a>
<a name="ln5900"> </a>
<a name="ln5901">	FUNCTION((&quot;dir_create: path '%s', perms %d, kernel %d\n&quot;, path, perms,</a>
<a name="ln5902">		kernel));</a>
<a name="ln5903"> </a>
<a name="ln5904">	status = fd_and_path_to_dir_vnode(fd, path, &amp;vnode, filename, kernel);</a>
<a name="ln5905">	if (status &lt; 0)</a>
<a name="ln5906">		return status;</a>
<a name="ln5907"> </a>
<a name="ln5908">	if (HAS_FS_CALL(vnode, create_dir)) {</a>
<a name="ln5909">		status = FS_CALL(vnode, create_dir, filename, perms);</a>
<a name="ln5910">	} else</a>
<a name="ln5911">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln5912"> </a>
<a name="ln5913">	put_vnode(vnode);</a>
<a name="ln5914">	return status;</a>
<a name="ln5915">}</a>
<a name="ln5916"> </a>
<a name="ln5917"> </a>
<a name="ln5918">static int</a>
<a name="ln5919">dir_open_entry_ref(dev_t mountID, ino_t parentID, const char* name, bool kernel)</a>
<a name="ln5920">{</a>
<a name="ln5921">	FUNCTION((&quot;dir_open_entry_ref()\n&quot;));</a>
<a name="ln5922"> </a>
<a name="ln5923">	if (name &amp;&amp; name[0] == '\0')</a>
<a name="ln5924">		return B_BAD_VALUE;</a>
<a name="ln5925"> </a>
<a name="ln5926">	// get the vnode matching the entry_ref/node_ref</a>
<a name="ln5927">	struct vnode* vnode;</a>
<a name="ln5928">	status_t status;</a>
<a name="ln5929">	if (name) {</a>
<a name="ln5930">		status = entry_ref_to_vnode(mountID, parentID, name, true, kernel,</a>
<a name="ln5931">			&amp;vnode);</a>
<a name="ln5932">	} else</a>
<a name="ln5933">		status = get_vnode(mountID, parentID, &amp;vnode, true, false);</a>
<a name="ln5934">	if (status != B_OK)</a>
<a name="ln5935">		return status;</a>
<a name="ln5936"> </a>
<a name="ln5937">	int newFD = open_dir_vnode(vnode, kernel);</a>
<a name="ln5938">	if (newFD &gt;= 0) {</a>
<a name="ln5939">		// The vnode reference has been transferred to the FD</a>
<a name="ln5940">		cache_node_opened(vnode, FDTYPE_DIR, vnode-&gt;cache, mountID, parentID,</a>
<a name="ln5941">			vnode-&gt;id, name);</a>
<a name="ln5942">	} else</a>
<a name="ln5943">		put_vnode(vnode);</a>
<a name="ln5944"> </a>
<a name="ln5945">	return newFD;</a>
<a name="ln5946">}</a>
<a name="ln5947"> </a>
<a name="ln5948"> </a>
<a name="ln5949">static int</a>
<a name="ln5950">dir_open(int fd, char* path, bool kernel)</a>
<a name="ln5951">{</a>
<a name="ln5952">	FUNCTION((&quot;dir_open: fd: %d, entry path = '%s', kernel %d\n&quot;, fd, path,</a>
<a name="ln5953">		kernel));</a>
<a name="ln5954"> </a>
<a name="ln5955">	// get the vnode matching the vnode + path combination</a>
<a name="ln5956">	struct vnode* vnode = NULL;</a>
<a name="ln5957">	ino_t parentID;</a>
<a name="ln5958">	status_t status = fd_and_path_to_vnode(fd, path, true, &amp;vnode, &amp;parentID,</a>
<a name="ln5959">		kernel);</a>
<a name="ln5960">	if (status != B_OK)</a>
<a name="ln5961">		return status;</a>
<a name="ln5962"> </a>
<a name="ln5963">	// open the dir</a>
<a name="ln5964">	int newFD = open_dir_vnode(vnode, kernel);</a>
<a name="ln5965">	if (newFD &gt;= 0) {</a>
<a name="ln5966">		// The vnode reference has been transferred to the FD</a>
<a name="ln5967">		cache_node_opened(vnode, FDTYPE_DIR, vnode-&gt;cache, vnode-&gt;device,</a>
<a name="ln5968">			parentID, vnode-&gt;id, NULL);</a>
<a name="ln5969">	} else</a>
<a name="ln5970">		put_vnode(vnode);</a>
<a name="ln5971"> </a>
<a name="ln5972">	return newFD;</a>
<a name="ln5973">}</a>
<a name="ln5974"> </a>
<a name="ln5975"> </a>
<a name="ln5976">static status_t</a>
<a name="ln5977">dir_close(struct file_descriptor* descriptor)</a>
<a name="ln5978">{</a>
<a name="ln5979">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5980"> </a>
<a name="ln5981">	FUNCTION((&quot;dir_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln5982"> </a>
<a name="ln5983">	cache_node_closed(vnode, FDTYPE_DIR, vnode-&gt;cache, vnode-&gt;device,</a>
<a name="ln5984">		vnode-&gt;id);</a>
<a name="ln5985">	if (HAS_FS_CALL(vnode, close_dir))</a>
<a name="ln5986">		return FS_CALL(vnode, close_dir, descriptor-&gt;cookie);</a>
<a name="ln5987"> </a>
<a name="ln5988">	return B_OK;</a>
<a name="ln5989">}</a>
<a name="ln5990"> </a>
<a name="ln5991"> </a>
<a name="ln5992">static void</a>
<a name="ln5993">dir_free_fd(struct file_descriptor* descriptor)</a>
<a name="ln5994">{</a>
<a name="ln5995">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln5996"> </a>
<a name="ln5997">	if (vnode != NULL) {</a>
<a name="ln5998">		FS_CALL(vnode, free_dir_cookie, descriptor-&gt;cookie);</a>
<a name="ln5999">		put_vnode(vnode);</a>
<a name="ln6000">	}</a>
<a name="ln6001">}</a>
<a name="ln6002"> </a>
<a name="ln6003"> </a>
<a name="ln6004">static status_t</a>
<a name="ln6005">dir_read(struct io_context* ioContext, struct file_descriptor* descriptor,</a>
<a name="ln6006">	struct dirent* buffer, size_t bufferSize, uint32* _count)</a>
<a name="ln6007">{</a>
<a name="ln6008">	return dir_read(ioContext, descriptor-&gt;u.vnode, descriptor-&gt;cookie, buffer,</a>
<a name="ln6009">		bufferSize, _count);</a>
<a name="ln6010">}</a>
<a name="ln6011"> </a>
<a name="ln6012"> </a>
<a name="ln6013">static status_t</a>
<a name="ln6014">fix_dirent(struct vnode* parent, struct dirent* entry,</a>
<a name="ln6015">	struct io_context* ioContext)</a>
<a name="ln6016">{</a>
<a name="ln6017">	// set d_pdev and d_pino</a>
<a name="ln6018">	entry-&gt;d_pdev = parent-&gt;device;</a>
<a name="ln6019">	entry-&gt;d_pino = parent-&gt;id;</a>
<a name="ln6020"> </a>
<a name="ln6021">	// If this is the &quot;..&quot; entry and the directory covering another vnode,</a>
<a name="ln6022">	// we need to replace d_dev and d_ino with the actual values.</a>
<a name="ln6023">	if (strcmp(entry-&gt;d_name, &quot;..&quot;) == 0 &amp;&amp; parent-&gt;IsCovering()) {</a>
<a name="ln6024">		return resolve_covered_parent(parent, &amp;entry-&gt;d_dev, &amp;entry-&gt;d_ino,</a>
<a name="ln6025">			ioContext);</a>
<a name="ln6026">	}</a>
<a name="ln6027"> </a>
<a name="ln6028">	// resolve covered vnodes</a>
<a name="ln6029">	ReadLocker _(&amp;sVnodeLock);</a>
<a name="ln6030"> </a>
<a name="ln6031">	struct vnode* vnode = lookup_vnode(entry-&gt;d_dev, entry-&gt;d_ino);</a>
<a name="ln6032">	if (vnode != NULL &amp;&amp; vnode-&gt;covered_by != NULL) {</a>
<a name="ln6033">		do {</a>
<a name="ln6034">			vnode = vnode-&gt;covered_by;</a>
<a name="ln6035">		} while (vnode-&gt;covered_by != NULL);</a>
<a name="ln6036"> </a>
<a name="ln6037">		entry-&gt;d_dev = vnode-&gt;device;</a>
<a name="ln6038">		entry-&gt;d_ino = vnode-&gt;id;</a>
<a name="ln6039">	}</a>
<a name="ln6040"> </a>
<a name="ln6041">	return B_OK;</a>
<a name="ln6042">}</a>
<a name="ln6043"> </a>
<a name="ln6044"> </a>
<a name="ln6045">static status_t</a>
<a name="ln6046">dir_read(struct io_context* ioContext, struct vnode* vnode, void* cookie,</a>
<a name="ln6047">	struct dirent* buffer, size_t bufferSize, uint32* _count)</a>
<a name="ln6048">{</a>
<a name="ln6049">	if (!HAS_FS_CALL(vnode, read_dir))</a>
<a name="ln6050">		return B_UNSUPPORTED;</a>
<a name="ln6051"> </a>
<a name="ln6052">	status_t error = FS_CALL(vnode, read_dir, cookie, buffer, bufferSize,</a>
<a name="ln6053">		_count);</a>
<a name="ln6054">	if (error != B_OK)</a>
<a name="ln6055">		return error;</a>
<a name="ln6056"> </a>
<a name="ln6057">	// we need to adjust the read dirents</a>
<a name="ln6058">	uint32 count = *_count;</a>
<a name="ln6059">	for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln6060">		error = fix_dirent(vnode, buffer, ioContext);</a>
<a name="ln6061">		if (error != B_OK)</a>
<a name="ln6062">			return error;</a>
<a name="ln6063"> </a>
<a name="ln6064">		buffer = (struct dirent*)((uint8*)buffer + buffer-&gt;d_reclen);</a>
<a name="ln6065">	}</a>
<a name="ln6066"> </a>
<a name="ln6067">	return error;</a>
<a name="ln6068">}</a>
<a name="ln6069"> </a>
<a name="ln6070"> </a>
<a name="ln6071">static status_t</a>
<a name="ln6072">dir_rewind(struct file_descriptor* descriptor)</a>
<a name="ln6073">{</a>
<a name="ln6074">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6075"> </a>
<a name="ln6076">	if (HAS_FS_CALL(vnode, rewind_dir)) {</a>
<a name="ln6077">		return FS_CALL(vnode, rewind_dir, descriptor-&gt;cookie);</a>
<a name="ln6078">	}</a>
<a name="ln6079"> </a>
<a name="ln6080">	return B_UNSUPPORTED;</a>
<a name="ln6081">}</a>
<a name="ln6082"> </a>
<a name="ln6083"> </a>
<a name="ln6084">static status_t</a>
<a name="ln6085">dir_remove(int fd, char* path, bool kernel)</a>
<a name="ln6086">{</a>
<a name="ln6087">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln6088">	struct vnode* directory;</a>
<a name="ln6089">	status_t status;</a>
<a name="ln6090"> </a>
<a name="ln6091">	if (path != NULL) {</a>
<a name="ln6092">		// we need to make sure our path name doesn't stop with &quot;/&quot;, &quot;.&quot;,</a>
<a name="ln6093">		// or &quot;..&quot;</a>
<a name="ln6094">		char* lastSlash;</a>
<a name="ln6095">		while ((lastSlash = strrchr(path, '/')) != NULL) {</a>
<a name="ln6096">			char* leaf = lastSlash + 1;</a>
<a name="ln6097">			if (!strcmp(leaf, &quot;..&quot;))</a>
<a name="ln6098">				return B_NOT_ALLOWED;</a>
<a name="ln6099"> </a>
<a name="ln6100">			// omit multiple slashes</a>
<a name="ln6101">			while (lastSlash &gt; path &amp;&amp; lastSlash[-1] == '/')</a>
<a name="ln6102">				lastSlash--;</a>
<a name="ln6103"> </a>
<a name="ln6104">			if (leaf[0]</a>
<a name="ln6105">				&amp;&amp; strcmp(leaf, &quot;.&quot;)) {</a>
<a name="ln6106">				break;</a>
<a name="ln6107">			}</a>
<a name="ln6108">			// &quot;name/&quot; -&gt; &quot;name&quot;, or &quot;name/.&quot; -&gt; &quot;name&quot;</a>
<a name="ln6109">			lastSlash[0] = '\0';</a>
<a name="ln6110">		}</a>
<a name="ln6111"> </a>
<a name="ln6112">		if (!strcmp(path, &quot;.&quot;) || !strcmp(path, &quot;..&quot;))</a>
<a name="ln6113">			return B_NOT_ALLOWED;</a>
<a name="ln6114">	}</a>
<a name="ln6115"> </a>
<a name="ln6116">	status = fd_and_path_to_dir_vnode(fd, path, &amp;directory, name, kernel);</a>
<a name="ln6117">	if (status != B_OK)</a>
<a name="ln6118">		return status;</a>
<a name="ln6119"> </a>
<a name="ln6120">	if (HAS_FS_CALL(directory, remove_dir))</a>
<a name="ln6121">		status = FS_CALL(directory, remove_dir, name);</a>
<a name="ln6122">	else</a>
<a name="ln6123">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln6124"> </a>
<a name="ln6125">	put_vnode(directory);</a>
<a name="ln6126">	return status;</a>
<a name="ln6127">}</a>
<a name="ln6128"> </a>
<a name="ln6129"> </a>
<a name="ln6130">static status_t</a>
<a name="ln6131">common_ioctl(struct file_descriptor* descriptor, ulong op, void* buffer,</a>
<a name="ln6132">	size_t length)</a>
<a name="ln6133">{</a>
<a name="ln6134">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6135"> </a>
<a name="ln6136">	if (HAS_FS_CALL(vnode, ioctl))</a>
<a name="ln6137">		return FS_CALL(vnode, ioctl, descriptor-&gt;cookie, op, buffer, length);</a>
<a name="ln6138"> </a>
<a name="ln6139">	return B_DEV_INVALID_IOCTL;</a>
<a name="ln6140">}</a>
<a name="ln6141"> </a>
<a name="ln6142"> </a>
<a name="ln6143">static status_t</a>
<a name="ln6144">common_fcntl(int fd, int op, size_t argument, bool kernel)</a>
<a name="ln6145">{</a>
<a name="ln6146">	struct flock flock;</a>
<a name="ln6147"> </a>
<a name="ln6148">	FUNCTION((&quot;common_fcntl(fd = %d, op = %d, argument = %lx, %s)\n&quot;,</a>
<a name="ln6149">		fd, op, argument, kernel ? &quot;kernel&quot; : &quot;user&quot;));</a>
<a name="ln6150"> </a>
<a name="ln6151">	struct io_context* context = get_current_io_context(kernel);</a>
<a name="ln6152"> </a>
<a name="ln6153">	struct file_descriptor* descriptor = get_fd(context, fd);</a>
<a name="ln6154">	if (descriptor == NULL)</a>
<a name="ln6155">		return B_FILE_ERROR;</a>
<a name="ln6156"> </a>
<a name="ln6157">	struct vnode* vnode = fd_vnode(descriptor);</a>
<a name="ln6158"> </a>
<a name="ln6159">	status_t status = B_OK;</a>
<a name="ln6160"> </a>
<a name="ln6161">	if (op == F_SETLK || op == F_SETLKW || op == F_GETLK) {</a>
<a name="ln6162">		if (descriptor-&gt;type != FDTYPE_FILE)</a>
<a name="ln6163">			status = B_BAD_VALUE;</a>
<a name="ln6164">		else if (kernel)</a>
<a name="ln6165">			memcpy(&amp;flock, (struct flock*)argument, sizeof(struct flock));</a>
<a name="ln6166">		else if (user_memcpy(&amp;flock, (struct flock*)argument,</a>
<a name="ln6167">				sizeof(struct flock)) != B_OK)</a>
<a name="ln6168">			status = B_BAD_ADDRESS;</a>
<a name="ln6169">		if (status != B_OK) {</a>
<a name="ln6170">			put_fd(descriptor);</a>
<a name="ln6171">			return status;</a>
<a name="ln6172">		}</a>
<a name="ln6173">	}</a>
<a name="ln6174"> </a>
<a name="ln6175">	switch (op) {</a>
<a name="ln6176">		case F_SETFD:</a>
<a name="ln6177">		{</a>
<a name="ln6178">			// Set file descriptor flags</a>
<a name="ln6179"> </a>
<a name="ln6180">			// O_CLOEXEC is the only flag available at this time</a>
<a name="ln6181">			mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln6182">			fd_set_close_on_exec(context, fd, (argument &amp; FD_CLOEXEC) != 0);</a>
<a name="ln6183">			mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln6184"> </a>
<a name="ln6185">			status = B_OK;</a>
<a name="ln6186">			break;</a>
<a name="ln6187">		}</a>
<a name="ln6188"> </a>
<a name="ln6189">		case F_GETFD:</a>
<a name="ln6190">		{</a>
<a name="ln6191">			// Get file descriptor flags</a>
<a name="ln6192">			mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln6193">			status = fd_close_on_exec(context, fd) ? FD_CLOEXEC : 0;</a>
<a name="ln6194">			mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln6195">			break;</a>
<a name="ln6196">		}</a>
<a name="ln6197"> </a>
<a name="ln6198">		case F_SETFL:</a>
<a name="ln6199">			// Set file descriptor open mode</a>
<a name="ln6200"> </a>
<a name="ln6201">			// we only accept changes to O_APPEND and O_NONBLOCK</a>
<a name="ln6202">			argument &amp;= O_APPEND | O_NONBLOCK;</a>
<a name="ln6203">			if (descriptor-&gt;ops-&gt;fd_set_flags != NULL) {</a>
<a name="ln6204">				status = descriptor-&gt;ops-&gt;fd_set_flags(descriptor, argument);</a>
<a name="ln6205">			} else if (vnode != NULL &amp;&amp; HAS_FS_CALL(vnode, set_flags)) {</a>
<a name="ln6206">				status = FS_CALL(vnode, set_flags, descriptor-&gt;cookie,</a>
<a name="ln6207">					(int)argument);</a>
<a name="ln6208">			} else</a>
<a name="ln6209">				status = B_UNSUPPORTED;</a>
<a name="ln6210"> </a>
<a name="ln6211">			if (status == B_OK) {</a>
<a name="ln6212">				// update this descriptor's open_mode field</a>
<a name="ln6213">				descriptor-&gt;open_mode = (descriptor-&gt;open_mode</a>
<a name="ln6214">					&amp; ~(O_APPEND | O_NONBLOCK)) | argument;</a>
<a name="ln6215">			}</a>
<a name="ln6216"> </a>
<a name="ln6217">			break;</a>
<a name="ln6218"> </a>
<a name="ln6219">		case F_GETFL:</a>
<a name="ln6220">			// Get file descriptor open mode</a>
<a name="ln6221">			status = descriptor-&gt;open_mode;</a>
<a name="ln6222">			break;</a>
<a name="ln6223"> </a>
<a name="ln6224">		case F_DUPFD:</a>
<a name="ln6225">		case F_DUPFD_CLOEXEC:</a>
<a name="ln6226">		{</a>
<a name="ln6227">			status = new_fd_etc(context, descriptor, (int)argument);</a>
<a name="ln6228">			if (status &gt;= 0) {</a>
<a name="ln6229">				mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln6230">				fd_set_close_on_exec(context, status, op == F_DUPFD_CLOEXEC);</a>
<a name="ln6231">				mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln6232"> </a>
<a name="ln6233">				atomic_add(&amp;descriptor-&gt;ref_count, 1);</a>
<a name="ln6234">			}</a>
<a name="ln6235">			break;</a>
<a name="ln6236">		}</a>
<a name="ln6237"> </a>
<a name="ln6238">		case F_GETLK:</a>
<a name="ln6239">			if (vnode != NULL) {</a>
<a name="ln6240">				struct flock normalizedLock;</a>
<a name="ln6241"> </a>
<a name="ln6242">				memcpy(&amp;normalizedLock, &amp;flock, sizeof(struct flock));</a>
<a name="ln6243">				status = normalize_flock(descriptor, &amp;normalizedLock);</a>
<a name="ln6244">				if (status != B_OK)</a>
<a name="ln6245">					break;</a>
<a name="ln6246"> </a>
<a name="ln6247">				if (HAS_FS_CALL(vnode, test_lock)) {</a>
<a name="ln6248">					status = FS_CALL(vnode, test_lock, descriptor-&gt;cookie,</a>
<a name="ln6249">						&amp;normalizedLock);</a>
<a name="ln6250">				} else</a>
<a name="ln6251">					status = test_advisory_lock(vnode, &amp;normalizedLock);</a>
<a name="ln6252">				if (status == B_OK) {</a>
<a name="ln6253">					if (normalizedLock.l_type == F_UNLCK) {</a>
<a name="ln6254">						// no conflicting lock found, copy back the same struct</a>
<a name="ln6255">						// we were given except change type to F_UNLCK</a>
<a name="ln6256">						flock.l_type = F_UNLCK;</a>
<a name="ln6257">						if (kernel) {</a>
<a name="ln6258">							memcpy((struct flock*)argument, &amp;flock,</a>
<a name="ln6259">								sizeof(struct flock));</a>
<a name="ln6260">						} else {</a>
<a name="ln6261">							status = user_memcpy((struct flock*)argument,</a>
<a name="ln6262">								&amp;flock, sizeof(struct flock));</a>
<a name="ln6263">						}</a>
<a name="ln6264">					} else {</a>
<a name="ln6265">						// a conflicting lock was found, copy back its range and</a>
<a name="ln6266">						// type</a>
<a name="ln6267">						if (normalizedLock.l_len == OFF_MAX)</a>
<a name="ln6268">							normalizedLock.l_len = 0;</a>
<a name="ln6269"> </a>
<a name="ln6270">						if (kernel) {</a>
<a name="ln6271">							memcpy((struct flock*)argument,</a>
<a name="ln6272">								&amp;normalizedLock, sizeof(struct flock));</a>
<a name="ln6273">						} else {</a>
<a name="ln6274">							status = user_memcpy((struct flock*)argument,</a>
<a name="ln6275">								&amp;normalizedLock, sizeof(struct flock));</a>
<a name="ln6276">						}</a>
<a name="ln6277">					}</a>
<a name="ln6278">				}</a>
<a name="ln6279">			} else</a>
<a name="ln6280">				status = B_BAD_VALUE;</a>
<a name="ln6281">			break;</a>
<a name="ln6282"> </a>
<a name="ln6283">		case F_SETLK:</a>
<a name="ln6284">		case F_SETLKW:</a>
<a name="ln6285">			status = normalize_flock(descriptor, &amp;flock);</a>
<a name="ln6286">			if (status != B_OK)</a>
<a name="ln6287">				break;</a>
<a name="ln6288"> </a>
<a name="ln6289">			if (vnode == NULL) {</a>
<a name="ln6290">				status = B_BAD_VALUE;</a>
<a name="ln6291">			} else if (flock.l_type == F_UNLCK) {</a>
<a name="ln6292">				if (HAS_FS_CALL(vnode, release_lock)) {</a>
<a name="ln6293">					status = FS_CALL(vnode, release_lock, descriptor-&gt;cookie,</a>
<a name="ln6294">						&amp;flock);</a>
<a name="ln6295">				} else {</a>
<a name="ln6296">					status = release_advisory_lock(vnode, context, NULL,</a>
<a name="ln6297">						&amp;flock);</a>
<a name="ln6298">				}</a>
<a name="ln6299">			} else {</a>
<a name="ln6300">				// the open mode must match the lock type</a>
<a name="ln6301">				if (((descriptor-&gt;open_mode &amp; O_RWMASK) == O_RDONLY</a>
<a name="ln6302">						&amp;&amp; flock.l_type == F_WRLCK)</a>
<a name="ln6303">					|| ((descriptor-&gt;open_mode &amp; O_RWMASK) == O_WRONLY</a>
<a name="ln6304">						&amp;&amp; flock.l_type == F_RDLCK))</a>
<a name="ln6305">					status = B_FILE_ERROR;</a>
<a name="ln6306">				else {</a>
<a name="ln6307">					if (HAS_FS_CALL(vnode, acquire_lock)) {</a>
<a name="ln6308">						status = FS_CALL(vnode, acquire_lock,</a>
<a name="ln6309">							descriptor-&gt;cookie, &amp;flock, op == F_SETLKW);</a>
<a name="ln6310">					} else {</a>
<a name="ln6311">						status = acquire_advisory_lock(vnode, context, NULL,</a>
<a name="ln6312">							&amp;flock, op == F_SETLKW);</a>
<a name="ln6313">					}</a>
<a name="ln6314">				}</a>
<a name="ln6315">			}</a>
<a name="ln6316">			break;</a>
<a name="ln6317"> </a>
<a name="ln6318">		// ToDo: add support for more ops?</a>
<a name="ln6319"> </a>
<a name="ln6320">		default:</a>
<a name="ln6321">			status = B_BAD_VALUE;</a>
<a name="ln6322">	}</a>
<a name="ln6323"> </a>
<a name="ln6324">	put_fd(descriptor);</a>
<a name="ln6325">	return status;</a>
<a name="ln6326">}</a>
<a name="ln6327"> </a>
<a name="ln6328"> </a>
<a name="ln6329">static status_t</a>
<a name="ln6330">common_sync(int fd, bool kernel)</a>
<a name="ln6331">{</a>
<a name="ln6332">	struct file_descriptor* descriptor;</a>
<a name="ln6333">	struct vnode* vnode;</a>
<a name="ln6334">	status_t status;</a>
<a name="ln6335"> </a>
<a name="ln6336">	FUNCTION((&quot;common_fsync: entry. fd %d kernel %d\n&quot;, fd, kernel));</a>
<a name="ln6337"> </a>
<a name="ln6338">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln6339">	if (descriptor == NULL)</a>
<a name="ln6340">		return B_FILE_ERROR;</a>
<a name="ln6341"> </a>
<a name="ln6342">	if (HAS_FS_CALL(vnode, fsync))</a>
<a name="ln6343">		status = FS_CALL_NO_PARAMS(vnode, fsync);</a>
<a name="ln6344">	else</a>
<a name="ln6345">		status = B_UNSUPPORTED;</a>
<a name="ln6346"> </a>
<a name="ln6347">	put_fd(descriptor);</a>
<a name="ln6348">	return status;</a>
<a name="ln6349">}</a>
<a name="ln6350"> </a>
<a name="ln6351"> </a>
<a name="ln6352">static status_t</a>
<a name="ln6353">common_lock_node(int fd, bool kernel)</a>
<a name="ln6354">{</a>
<a name="ln6355">	struct file_descriptor* descriptor;</a>
<a name="ln6356">	struct vnode* vnode;</a>
<a name="ln6357"> </a>
<a name="ln6358">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln6359">	if (descriptor == NULL)</a>
<a name="ln6360">		return B_FILE_ERROR;</a>
<a name="ln6361"> </a>
<a name="ln6362">	status_t status = B_OK;</a>
<a name="ln6363"> </a>
<a name="ln6364">	// We need to set the locking atomically - someone</a>
<a name="ln6365">	// else might set one at the same time</a>
<a name="ln6366">	if (atomic_pointer_test_and_set(&amp;vnode-&gt;mandatory_locked_by, descriptor,</a>
<a name="ln6367">			(file_descriptor*)NULL) != NULL)</a>
<a name="ln6368">		status = B_BUSY;</a>
<a name="ln6369"> </a>
<a name="ln6370">	put_fd(descriptor);</a>
<a name="ln6371">	return status;</a>
<a name="ln6372">}</a>
<a name="ln6373"> </a>
<a name="ln6374"> </a>
<a name="ln6375">static status_t</a>
<a name="ln6376">common_unlock_node(int fd, bool kernel)</a>
<a name="ln6377">{</a>
<a name="ln6378">	struct file_descriptor* descriptor;</a>
<a name="ln6379">	struct vnode* vnode;</a>
<a name="ln6380"> </a>
<a name="ln6381">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln6382">	if (descriptor == NULL)</a>
<a name="ln6383">		return B_FILE_ERROR;</a>
<a name="ln6384"> </a>
<a name="ln6385">	status_t status = B_OK;</a>
<a name="ln6386"> </a>
<a name="ln6387">	// We need to set the locking atomically - someone</a>
<a name="ln6388">	// else might set one at the same time</a>
<a name="ln6389">	if (atomic_pointer_test_and_set(&amp;vnode-&gt;mandatory_locked_by,</a>
<a name="ln6390">			(file_descriptor*)NULL, descriptor) != descriptor)</a>
<a name="ln6391">		status = B_BAD_VALUE;</a>
<a name="ln6392"> </a>
<a name="ln6393">	put_fd(descriptor);</a>
<a name="ln6394">	return status;</a>
<a name="ln6395">}</a>
<a name="ln6396"> </a>
<a name="ln6397"> </a>
<a name="ln6398">static status_t</a>
<a name="ln6399">common_read_link(int fd, char* path, char* buffer, size_t* _bufferSize,</a>
<a name="ln6400">	bool kernel)</a>
<a name="ln6401">{</a>
<a name="ln6402">	struct vnode* vnode;</a>
<a name="ln6403">	status_t status;</a>
<a name="ln6404"> </a>
<a name="ln6405">	status = fd_and_path_to_vnode(fd, path, false, &amp;vnode, NULL, kernel);</a>
<a name="ln6406">	if (status != B_OK)</a>
<a name="ln6407">		return status;</a>
<a name="ln6408"> </a>
<a name="ln6409">	if (HAS_FS_CALL(vnode, read_symlink)) {</a>
<a name="ln6410">		status = FS_CALL(vnode, read_symlink, buffer, _bufferSize);</a>
<a name="ln6411">	} else</a>
<a name="ln6412">		status = B_BAD_VALUE;</a>
<a name="ln6413"> </a>
<a name="ln6414">	put_vnode(vnode);</a>
<a name="ln6415">	return status;</a>
<a name="ln6416">}</a>
<a name="ln6417"> </a>
<a name="ln6418"> </a>
<a name="ln6419">static status_t</a>
<a name="ln6420">common_create_symlink(int fd, char* path, const char* toPath, int mode,</a>
<a name="ln6421">	bool kernel)</a>
<a name="ln6422">{</a>
<a name="ln6423">	// path validity checks have to be in the calling function!</a>
<a name="ln6424">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln6425">	struct vnode* vnode;</a>
<a name="ln6426">	status_t status;</a>
<a name="ln6427"> </a>
<a name="ln6428">	FUNCTION((&quot;common_create_symlink(fd = %d, path = %s, toPath = %s, &quot;</a>
<a name="ln6429">		&quot;mode = %d, kernel = %d)\n&quot;, fd, path, toPath, mode, kernel));</a>
<a name="ln6430"> </a>
<a name="ln6431">	status = fd_and_path_to_dir_vnode(fd, path, &amp;vnode, name, kernel);</a>
<a name="ln6432">	if (status != B_OK)</a>
<a name="ln6433">		return status;</a>
<a name="ln6434"> </a>
<a name="ln6435">	if (HAS_FS_CALL(vnode, create_symlink))</a>
<a name="ln6436">		status = FS_CALL(vnode, create_symlink, name, toPath, mode);</a>
<a name="ln6437">	else {</a>
<a name="ln6438">		status = HAS_FS_CALL(vnode, write)</a>
<a name="ln6439">			? B_UNSUPPORTED : B_READ_ONLY_DEVICE;</a>
<a name="ln6440">	}</a>
<a name="ln6441"> </a>
<a name="ln6442">	put_vnode(vnode);</a>
<a name="ln6443"> </a>
<a name="ln6444">	return status;</a>
<a name="ln6445">}</a>
<a name="ln6446"> </a>
<a name="ln6447"> </a>
<a name="ln6448">static status_t</a>
<a name="ln6449">common_create_link(int pathFD, char* path, int toFD, char* toPath,</a>
<a name="ln6450">	bool traverseLeafLink, bool kernel)</a>
<a name="ln6451">{</a>
<a name="ln6452">	// path validity checks have to be in the calling function!</a>
<a name="ln6453"> </a>
<a name="ln6454">	FUNCTION((&quot;common_create_link(path = %s, toPath = %s, kernel = %d)\n&quot;, path,</a>
<a name="ln6455">		toPath, kernel));</a>
<a name="ln6456"> </a>
<a name="ln6457">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln6458">	struct vnode* directory;</a>
<a name="ln6459">	status_t status = fd_and_path_to_dir_vnode(pathFD, path, &amp;directory, name,</a>
<a name="ln6460">		kernel);</a>
<a name="ln6461">	if (status != B_OK)</a>
<a name="ln6462">		return status;</a>
<a name="ln6463"> </a>
<a name="ln6464">	struct vnode* vnode;</a>
<a name="ln6465">	status = fd_and_path_to_vnode(toFD, toPath, traverseLeafLink, &amp;vnode, NULL,</a>
<a name="ln6466">		kernel);</a>
<a name="ln6467">	if (status != B_OK)</a>
<a name="ln6468">		goto err;</a>
<a name="ln6469"> </a>
<a name="ln6470">	if (directory-&gt;mount != vnode-&gt;mount) {</a>
<a name="ln6471">		status = B_CROSS_DEVICE_LINK;</a>
<a name="ln6472">		goto err1;</a>
<a name="ln6473">	}</a>
<a name="ln6474"> </a>
<a name="ln6475">	if (HAS_FS_CALL(directory, link))</a>
<a name="ln6476">		status = FS_CALL(directory, link, name, vnode);</a>
<a name="ln6477">	else</a>
<a name="ln6478">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln6479"> </a>
<a name="ln6480">err1:</a>
<a name="ln6481">	put_vnode(vnode);</a>
<a name="ln6482">err:</a>
<a name="ln6483">	put_vnode(directory);</a>
<a name="ln6484"> </a>
<a name="ln6485">	return status;</a>
<a name="ln6486">}</a>
<a name="ln6487"> </a>
<a name="ln6488"> </a>
<a name="ln6489">static status_t</a>
<a name="ln6490">common_unlink(int fd, char* path, bool kernel)</a>
<a name="ln6491">{</a>
<a name="ln6492">	char filename[B_FILE_NAME_LENGTH];</a>
<a name="ln6493">	struct vnode* vnode;</a>
<a name="ln6494">	status_t status;</a>
<a name="ln6495"> </a>
<a name="ln6496">	FUNCTION((&quot;common_unlink: fd: %d, path '%s', kernel %d\n&quot;, fd, path,</a>
<a name="ln6497">		kernel));</a>
<a name="ln6498"> </a>
<a name="ln6499">	status = fd_and_path_to_dir_vnode(fd, path, &amp;vnode, filename, kernel);</a>
<a name="ln6500">	if (status &lt; 0)</a>
<a name="ln6501">		return status;</a>
<a name="ln6502"> </a>
<a name="ln6503">	if (HAS_FS_CALL(vnode, unlink))</a>
<a name="ln6504">		status = FS_CALL(vnode, unlink, filename);</a>
<a name="ln6505">	else</a>
<a name="ln6506">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln6507"> </a>
<a name="ln6508">	put_vnode(vnode);</a>
<a name="ln6509"> </a>
<a name="ln6510">	return status;</a>
<a name="ln6511">}</a>
<a name="ln6512"> </a>
<a name="ln6513"> </a>
<a name="ln6514">static status_t</a>
<a name="ln6515">common_access(int fd, char* path, int mode, bool effectiveUserGroup, bool kernel)</a>
<a name="ln6516">{</a>
<a name="ln6517">	struct vnode* vnode;</a>
<a name="ln6518">	status_t status;</a>
<a name="ln6519"> </a>
<a name="ln6520">	// TODO: honor effectiveUserGroup argument</a>
<a name="ln6521"> </a>
<a name="ln6522">	status = fd_and_path_to_vnode(fd, path, true, &amp;vnode, NULL, kernel);</a>
<a name="ln6523">	if (status != B_OK)</a>
<a name="ln6524">		return status;</a>
<a name="ln6525"> </a>
<a name="ln6526">	if (HAS_FS_CALL(vnode, access))</a>
<a name="ln6527">		status = FS_CALL(vnode, access, mode);</a>
<a name="ln6528">	else</a>
<a name="ln6529">		status = B_OK;</a>
<a name="ln6530"> </a>
<a name="ln6531">	put_vnode(vnode);</a>
<a name="ln6532"> </a>
<a name="ln6533">	return status;</a>
<a name="ln6534">}</a>
<a name="ln6535"> </a>
<a name="ln6536"> </a>
<a name="ln6537">static status_t</a>
<a name="ln6538">common_rename(int fd, char* path, int newFD, char* newPath, bool kernel)</a>
<a name="ln6539">{</a>
<a name="ln6540">	struct vnode* fromVnode;</a>
<a name="ln6541">	struct vnode* toVnode;</a>
<a name="ln6542">	char fromName[B_FILE_NAME_LENGTH];</a>
<a name="ln6543">	char toName[B_FILE_NAME_LENGTH];</a>
<a name="ln6544">	status_t status;</a>
<a name="ln6545"> </a>
<a name="ln6546">	FUNCTION((&quot;common_rename(fd = %d, path = %s, newFD = %d, newPath = %s, &quot;</a>
<a name="ln6547">		&quot;kernel = %d)\n&quot;, fd, path, newFD, newPath, kernel));</a>
<a name="ln6548"> </a>
<a name="ln6549">	status = fd_and_path_to_dir_vnode(fd, path, &amp;fromVnode, fromName, kernel);</a>
<a name="ln6550">	if (status != B_OK)</a>
<a name="ln6551">		return status;</a>
<a name="ln6552"> </a>
<a name="ln6553">	status = fd_and_path_to_dir_vnode(newFD, newPath, &amp;toVnode, toName, kernel);</a>
<a name="ln6554">	if (status != B_OK)</a>
<a name="ln6555">		goto err1;</a>
<a name="ln6556"> </a>
<a name="ln6557">	if (fromVnode-&gt;device != toVnode-&gt;device) {</a>
<a name="ln6558">		status = B_CROSS_DEVICE_LINK;</a>
<a name="ln6559">		goto err2;</a>
<a name="ln6560">	}</a>
<a name="ln6561"> </a>
<a name="ln6562">	if (fromName[0] == '\0' || toName[0] == '\0'</a>
<a name="ln6563">		|| !strcmp(fromName, &quot;.&quot;) || !strcmp(fromName, &quot;..&quot;)</a>
<a name="ln6564">		|| !strcmp(toName, &quot;.&quot;) || !strcmp(toName, &quot;..&quot;)</a>
<a name="ln6565">		|| (fromVnode == toVnode &amp;&amp; !strcmp(fromName, toName))) {</a>
<a name="ln6566">		status = B_BAD_VALUE;</a>
<a name="ln6567">		goto err2;</a>
<a name="ln6568">	}</a>
<a name="ln6569"> </a>
<a name="ln6570">	if (HAS_FS_CALL(fromVnode, rename))</a>
<a name="ln6571">		status = FS_CALL(fromVnode, rename, fromName, toVnode, toName);</a>
<a name="ln6572">	else</a>
<a name="ln6573">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln6574"> </a>
<a name="ln6575">err2:</a>
<a name="ln6576">	put_vnode(toVnode);</a>
<a name="ln6577">err1:</a>
<a name="ln6578">	put_vnode(fromVnode);</a>
<a name="ln6579"> </a>
<a name="ln6580">	return status;</a>
<a name="ln6581">}</a>
<a name="ln6582"> </a>
<a name="ln6583"> </a>
<a name="ln6584">static status_t</a>
<a name="ln6585">common_read_stat(struct file_descriptor* descriptor, struct stat* stat)</a>
<a name="ln6586">{</a>
<a name="ln6587">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6588"> </a>
<a name="ln6589">	FUNCTION((&quot;common_read_stat: stat %p\n&quot;, stat));</a>
<a name="ln6590"> </a>
<a name="ln6591">	// TODO: remove this once all file systems properly set them!</a>
<a name="ln6592">	stat-&gt;st_crtim.tv_nsec = 0;</a>
<a name="ln6593">	stat-&gt;st_ctim.tv_nsec = 0;</a>
<a name="ln6594">	stat-&gt;st_mtim.tv_nsec = 0;</a>
<a name="ln6595">	stat-&gt;st_atim.tv_nsec = 0;</a>
<a name="ln6596"> </a>
<a name="ln6597">	return vfs_stat_vnode(vnode, stat);</a>
<a name="ln6598">}</a>
<a name="ln6599"> </a>
<a name="ln6600"> </a>
<a name="ln6601">static status_t</a>
<a name="ln6602">common_write_stat(struct file_descriptor* descriptor, const struct stat* stat,</a>
<a name="ln6603">	int statMask)</a>
<a name="ln6604">{</a>
<a name="ln6605">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6606"> </a>
<a name="ln6607">	FUNCTION((&quot;common_write_stat(vnode = %p, stat = %p, statMask = %d)\n&quot;,</a>
<a name="ln6608">		vnode, stat, statMask));</a>
<a name="ln6609"> </a>
<a name="ln6610">	if ((descriptor-&gt;open_mode &amp; O_RWMASK) == O_RDONLY</a>
<a name="ln6611">		&amp;&amp; (statMask &amp; B_STAT_SIZE) != 0) {</a>
<a name="ln6612">		return B_BAD_VALUE;</a>
<a name="ln6613">	}</a>
<a name="ln6614"> </a>
<a name="ln6615">	if (!HAS_FS_CALL(vnode, write_stat))</a>
<a name="ln6616">		return B_READ_ONLY_DEVICE;</a>
<a name="ln6617"> </a>
<a name="ln6618">	return FS_CALL(vnode, write_stat, stat, statMask);</a>
<a name="ln6619">}</a>
<a name="ln6620"> </a>
<a name="ln6621"> </a>
<a name="ln6622">static status_t</a>
<a name="ln6623">common_path_read_stat(int fd, char* path, bool traverseLeafLink,</a>
<a name="ln6624">	struct stat* stat, bool kernel)</a>
<a name="ln6625">{</a>
<a name="ln6626">	FUNCTION((&quot;common_path_read_stat: fd: %d, path '%s', stat %p,\n&quot;, fd, path,</a>
<a name="ln6627">		stat));</a>
<a name="ln6628"> </a>
<a name="ln6629">	struct vnode* vnode;</a>
<a name="ln6630">	status_t status = fd_and_path_to_vnode(fd, path, traverseLeafLink, &amp;vnode,</a>
<a name="ln6631">		NULL, kernel);</a>
<a name="ln6632">	if (status != B_OK)</a>
<a name="ln6633">		return status;</a>
<a name="ln6634"> </a>
<a name="ln6635">	status = vfs_stat_vnode(vnode, stat);</a>
<a name="ln6636"> </a>
<a name="ln6637">	put_vnode(vnode);</a>
<a name="ln6638">	return status;</a>
<a name="ln6639">}</a>
<a name="ln6640"> </a>
<a name="ln6641"> </a>
<a name="ln6642">static status_t</a>
<a name="ln6643">common_path_write_stat(int fd, char* path, bool traverseLeafLink,</a>
<a name="ln6644">	const struct stat* stat, int statMask, bool kernel)</a>
<a name="ln6645">{</a>
<a name="ln6646">	FUNCTION((&quot;common_write_stat: fd: %d, path '%s', stat %p, stat_mask %d, &quot;</a>
<a name="ln6647">		&quot;kernel %d\n&quot;, fd, path, stat, statMask, kernel));</a>
<a name="ln6648"> </a>
<a name="ln6649">	struct vnode* vnode;</a>
<a name="ln6650">	status_t status = fd_and_path_to_vnode(fd, path, traverseLeafLink, &amp;vnode,</a>
<a name="ln6651">		NULL, kernel);</a>
<a name="ln6652">	if (status != B_OK)</a>
<a name="ln6653">		return status;</a>
<a name="ln6654"> </a>
<a name="ln6655">	if (HAS_FS_CALL(vnode, write_stat))</a>
<a name="ln6656">		status = FS_CALL(vnode, write_stat, stat, statMask);</a>
<a name="ln6657">	else</a>
<a name="ln6658">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln6659"> </a>
<a name="ln6660">	put_vnode(vnode);</a>
<a name="ln6661"> </a>
<a name="ln6662">	return status;</a>
<a name="ln6663">}</a>
<a name="ln6664"> </a>
<a name="ln6665"> </a>
<a name="ln6666">static int</a>
<a name="ln6667">attr_dir_open(int fd, char* path, bool traverseLeafLink, bool kernel)</a>
<a name="ln6668">{</a>
<a name="ln6669">	FUNCTION((&quot;attr_dir_open(fd = %d, path = '%s', kernel = %d)\n&quot;, fd, path,</a>
<a name="ln6670">		kernel));</a>
<a name="ln6671"> </a>
<a name="ln6672">	struct vnode* vnode;</a>
<a name="ln6673">	status_t status = fd_and_path_to_vnode(fd, path, traverseLeafLink, &amp;vnode,</a>
<a name="ln6674">		NULL, kernel);</a>
<a name="ln6675">	if (status != B_OK)</a>
<a name="ln6676">		return status;</a>
<a name="ln6677"> </a>
<a name="ln6678">	status = open_attr_dir_vnode(vnode, kernel);</a>
<a name="ln6679">	if (status &lt; 0)</a>
<a name="ln6680">		put_vnode(vnode);</a>
<a name="ln6681"> </a>
<a name="ln6682">	return status;</a>
<a name="ln6683">}</a>
<a name="ln6684"> </a>
<a name="ln6685"> </a>
<a name="ln6686">static status_t</a>
<a name="ln6687">attr_dir_close(struct file_descriptor* descriptor)</a>
<a name="ln6688">{</a>
<a name="ln6689">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6690"> </a>
<a name="ln6691">	FUNCTION((&quot;attr_dir_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln6692"> </a>
<a name="ln6693">	if (HAS_FS_CALL(vnode, close_attr_dir))</a>
<a name="ln6694">		return FS_CALL(vnode, close_attr_dir, descriptor-&gt;cookie);</a>
<a name="ln6695"> </a>
<a name="ln6696">	return B_OK;</a>
<a name="ln6697">}</a>
<a name="ln6698"> </a>
<a name="ln6699"> </a>
<a name="ln6700">static void</a>
<a name="ln6701">attr_dir_free_fd(struct file_descriptor* descriptor)</a>
<a name="ln6702">{</a>
<a name="ln6703">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6704"> </a>
<a name="ln6705">	if (vnode != NULL) {</a>
<a name="ln6706">		FS_CALL(vnode, free_attr_dir_cookie, descriptor-&gt;cookie);</a>
<a name="ln6707">		put_vnode(vnode);</a>
<a name="ln6708">	}</a>
<a name="ln6709">}</a>
<a name="ln6710"> </a>
<a name="ln6711"> </a>
<a name="ln6712">static status_t</a>
<a name="ln6713">attr_dir_read(struct io_context* ioContext, struct file_descriptor* descriptor,</a>
<a name="ln6714">	struct dirent* buffer, size_t bufferSize, uint32* _count)</a>
<a name="ln6715">{</a>
<a name="ln6716">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6717"> </a>
<a name="ln6718">	FUNCTION((&quot;attr_dir_read(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln6719"> </a>
<a name="ln6720">	if (HAS_FS_CALL(vnode, read_attr_dir))</a>
<a name="ln6721">		return FS_CALL(vnode, read_attr_dir, descriptor-&gt;cookie, buffer,</a>
<a name="ln6722">			bufferSize, _count);</a>
<a name="ln6723"> </a>
<a name="ln6724">	return B_UNSUPPORTED;</a>
<a name="ln6725">}</a>
<a name="ln6726"> </a>
<a name="ln6727"> </a>
<a name="ln6728">static status_t</a>
<a name="ln6729">attr_dir_rewind(struct file_descriptor* descriptor)</a>
<a name="ln6730">{</a>
<a name="ln6731">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6732"> </a>
<a name="ln6733">	FUNCTION((&quot;attr_dir_rewind(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln6734"> </a>
<a name="ln6735">	if (HAS_FS_CALL(vnode, rewind_attr_dir))</a>
<a name="ln6736">		return FS_CALL(vnode, rewind_attr_dir, descriptor-&gt;cookie);</a>
<a name="ln6737"> </a>
<a name="ln6738">	return B_UNSUPPORTED;</a>
<a name="ln6739">}</a>
<a name="ln6740"> </a>
<a name="ln6741"> </a>
<a name="ln6742">static int</a>
<a name="ln6743">attr_create(int fd, char* path, const char* name, uint32 type,</a>
<a name="ln6744">	int openMode, bool kernel)</a>
<a name="ln6745">{</a>
<a name="ln6746">	if (name == NULL || *name == '\0')</a>
<a name="ln6747">		return B_BAD_VALUE;</a>
<a name="ln6748"> </a>
<a name="ln6749">	bool traverse = (openMode &amp; (O_NOTRAVERSE | O_NOFOLLOW)) == 0;</a>
<a name="ln6750">	struct vnode* vnode;</a>
<a name="ln6751">	status_t status = fd_and_path_to_vnode(fd, path, traverse, &amp;vnode, NULL,</a>
<a name="ln6752">		kernel);</a>
<a name="ln6753">	if (status != B_OK)</a>
<a name="ln6754">		return status;</a>
<a name="ln6755"> </a>
<a name="ln6756">	if ((openMode &amp; O_NOFOLLOW) != 0 &amp;&amp; S_ISLNK(vnode-&gt;Type())) {</a>
<a name="ln6757">		status = B_LINK_LIMIT;</a>
<a name="ln6758">		goto err;</a>
<a name="ln6759">	}</a>
<a name="ln6760"> </a>
<a name="ln6761">	if (!HAS_FS_CALL(vnode, create_attr)) {</a>
<a name="ln6762">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln6763">		goto err;</a>
<a name="ln6764">	}</a>
<a name="ln6765"> </a>
<a name="ln6766">	void* cookie;</a>
<a name="ln6767">	status = FS_CALL(vnode, create_attr, name, type, openMode, &amp;cookie);</a>
<a name="ln6768">	if (status != B_OK)</a>
<a name="ln6769">		goto err;</a>
<a name="ln6770"> </a>
<a name="ln6771">	fd = get_new_fd(FDTYPE_ATTR, NULL, vnode, cookie, openMode, kernel);</a>
<a name="ln6772">	if (fd &gt;= 0)</a>
<a name="ln6773">		return fd;</a>
<a name="ln6774"> </a>
<a name="ln6775">	status = fd;</a>
<a name="ln6776"> </a>
<a name="ln6777">	FS_CALL(vnode, close_attr, cookie);</a>
<a name="ln6778">	FS_CALL(vnode, free_attr_cookie, cookie);</a>
<a name="ln6779"> </a>
<a name="ln6780">	FS_CALL(vnode, remove_attr, name);</a>
<a name="ln6781"> </a>
<a name="ln6782">err:</a>
<a name="ln6783">	put_vnode(vnode);</a>
<a name="ln6784"> </a>
<a name="ln6785">	return status;</a>
<a name="ln6786">}</a>
<a name="ln6787"> </a>
<a name="ln6788"> </a>
<a name="ln6789">static int</a>
<a name="ln6790">attr_open(int fd, char* path, const char* name, int openMode, bool kernel)</a>
<a name="ln6791">{</a>
<a name="ln6792">	if (name == NULL || *name == '\0')</a>
<a name="ln6793">		return B_BAD_VALUE;</a>
<a name="ln6794"> </a>
<a name="ln6795">	bool traverse = (openMode &amp; (O_NOTRAVERSE | O_NOFOLLOW)) == 0;</a>
<a name="ln6796">	struct vnode* vnode;</a>
<a name="ln6797">	status_t status = fd_and_path_to_vnode(fd, path, traverse, &amp;vnode, NULL,</a>
<a name="ln6798">		kernel);</a>
<a name="ln6799">	if (status != B_OK)</a>
<a name="ln6800">		return status;</a>
<a name="ln6801"> </a>
<a name="ln6802">	if ((openMode &amp; O_NOFOLLOW) != 0 &amp;&amp; S_ISLNK(vnode-&gt;Type())) {</a>
<a name="ln6803">		status = B_LINK_LIMIT;</a>
<a name="ln6804">		goto err;</a>
<a name="ln6805">	}</a>
<a name="ln6806"> </a>
<a name="ln6807">	if (!HAS_FS_CALL(vnode, open_attr)) {</a>
<a name="ln6808">		status = B_UNSUPPORTED;</a>
<a name="ln6809">		goto err;</a>
<a name="ln6810">	}</a>
<a name="ln6811"> </a>
<a name="ln6812">	void* cookie;</a>
<a name="ln6813">	status = FS_CALL(vnode, open_attr, name, openMode, &amp;cookie);</a>
<a name="ln6814">	if (status != B_OK)</a>
<a name="ln6815">		goto err;</a>
<a name="ln6816"> </a>
<a name="ln6817">	// now we only need a file descriptor for this attribute and we're done</a>
<a name="ln6818">	fd = get_new_fd(FDTYPE_ATTR, NULL, vnode, cookie, openMode, kernel);</a>
<a name="ln6819">	if (fd &gt;= 0)</a>
<a name="ln6820">		return fd;</a>
<a name="ln6821"> </a>
<a name="ln6822">	status = fd;</a>
<a name="ln6823"> </a>
<a name="ln6824">	FS_CALL(vnode, close_attr, cookie);</a>
<a name="ln6825">	FS_CALL(vnode, free_attr_cookie, cookie);</a>
<a name="ln6826"> </a>
<a name="ln6827">err:</a>
<a name="ln6828">	put_vnode(vnode);</a>
<a name="ln6829"> </a>
<a name="ln6830">	return status;</a>
<a name="ln6831">}</a>
<a name="ln6832"> </a>
<a name="ln6833"> </a>
<a name="ln6834">static status_t</a>
<a name="ln6835">attr_close(struct file_descriptor* descriptor)</a>
<a name="ln6836">{</a>
<a name="ln6837">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6838"> </a>
<a name="ln6839">	FUNCTION((&quot;attr_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln6840"> </a>
<a name="ln6841">	if (HAS_FS_CALL(vnode, close_attr))</a>
<a name="ln6842">		return FS_CALL(vnode, close_attr, descriptor-&gt;cookie);</a>
<a name="ln6843"> </a>
<a name="ln6844">	return B_OK;</a>
<a name="ln6845">}</a>
<a name="ln6846"> </a>
<a name="ln6847"> </a>
<a name="ln6848">static void</a>
<a name="ln6849">attr_free_fd(struct file_descriptor* descriptor)</a>
<a name="ln6850">{</a>
<a name="ln6851">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6852"> </a>
<a name="ln6853">	if (vnode != NULL) {</a>
<a name="ln6854">		FS_CALL(vnode, free_attr_cookie, descriptor-&gt;cookie);</a>
<a name="ln6855">		put_vnode(vnode);</a>
<a name="ln6856">	}</a>
<a name="ln6857">}</a>
<a name="ln6858"> </a>
<a name="ln6859"> </a>
<a name="ln6860">static status_t</a>
<a name="ln6861">attr_read(struct file_descriptor* descriptor, off_t pos, void* buffer,</a>
<a name="ln6862">	size_t* length)</a>
<a name="ln6863">{</a>
<a name="ln6864">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6865"> </a>
<a name="ln6866">	FUNCTION((&quot;attr_read: buf %p, pos %&quot; B_PRIdOFF &quot;, len %p = %ld\n&quot;, buffer,</a>
<a name="ln6867">		pos, length, *length));</a>
<a name="ln6868"> </a>
<a name="ln6869">	if (!HAS_FS_CALL(vnode, read_attr))</a>
<a name="ln6870">		return B_UNSUPPORTED;</a>
<a name="ln6871"> </a>
<a name="ln6872">	return FS_CALL(vnode, read_attr, descriptor-&gt;cookie, pos, buffer, length);</a>
<a name="ln6873">}</a>
<a name="ln6874"> </a>
<a name="ln6875"> </a>
<a name="ln6876">static status_t</a>
<a name="ln6877">attr_write(struct file_descriptor* descriptor, off_t pos, const void* buffer,</a>
<a name="ln6878">	size_t* length)</a>
<a name="ln6879">{</a>
<a name="ln6880">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6881"> </a>
<a name="ln6882">	FUNCTION((&quot;attr_write: buf %p, pos %&quot; B_PRIdOFF &quot;, len %p\n&quot;, buffer, pos,</a>
<a name="ln6883">		length));</a>
<a name="ln6884"> </a>
<a name="ln6885">	if (!HAS_FS_CALL(vnode, write_attr))</a>
<a name="ln6886">		return B_UNSUPPORTED;</a>
<a name="ln6887"> </a>
<a name="ln6888">	return FS_CALL(vnode, write_attr, descriptor-&gt;cookie, pos, buffer, length);</a>
<a name="ln6889">}</a>
<a name="ln6890"> </a>
<a name="ln6891"> </a>
<a name="ln6892">static off_t</a>
<a name="ln6893">attr_seek(struct file_descriptor* descriptor, off_t pos, int seekType)</a>
<a name="ln6894">{</a>
<a name="ln6895">	off_t offset;</a>
<a name="ln6896"> </a>
<a name="ln6897">	switch (seekType) {</a>
<a name="ln6898">		case SEEK_SET:</a>
<a name="ln6899">			offset = 0;</a>
<a name="ln6900">			break;</a>
<a name="ln6901">		case SEEK_CUR:</a>
<a name="ln6902">			offset = descriptor-&gt;pos;</a>
<a name="ln6903">			break;</a>
<a name="ln6904">		case SEEK_END:</a>
<a name="ln6905">		{</a>
<a name="ln6906">			struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6907">			if (!HAS_FS_CALL(vnode, read_stat))</a>
<a name="ln6908">				return B_UNSUPPORTED;</a>
<a name="ln6909"> </a>
<a name="ln6910">			struct stat stat;</a>
<a name="ln6911">			status_t status = FS_CALL(vnode, read_attr_stat, descriptor-&gt;cookie,</a>
<a name="ln6912">				&amp;stat);</a>
<a name="ln6913">			if (status != B_OK)</a>
<a name="ln6914">				return status;</a>
<a name="ln6915"> </a>
<a name="ln6916">			offset = stat.st_size;</a>
<a name="ln6917">			break;</a>
<a name="ln6918">		}</a>
<a name="ln6919">		default:</a>
<a name="ln6920">			return B_BAD_VALUE;</a>
<a name="ln6921">	}</a>
<a name="ln6922"> </a>
<a name="ln6923">	// assumes off_t is 64 bits wide</a>
<a name="ln6924">	if (offset &gt; 0 &amp;&amp; LONGLONG_MAX - offset &lt; pos)</a>
<a name="ln6925">		return B_BUFFER_OVERFLOW;</a>
<a name="ln6926"> </a>
<a name="ln6927">	pos += offset;</a>
<a name="ln6928">	if (pos &lt; 0)</a>
<a name="ln6929">		return B_BAD_VALUE;</a>
<a name="ln6930"> </a>
<a name="ln6931">	return descriptor-&gt;pos = pos;</a>
<a name="ln6932">}</a>
<a name="ln6933"> </a>
<a name="ln6934"> </a>
<a name="ln6935">static status_t</a>
<a name="ln6936">attr_read_stat(struct file_descriptor* descriptor, struct stat* stat)</a>
<a name="ln6937">{</a>
<a name="ln6938">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6939"> </a>
<a name="ln6940">	FUNCTION((&quot;attr_read_stat: stat 0x%p\n&quot;, stat));</a>
<a name="ln6941"> </a>
<a name="ln6942">	if (!HAS_FS_CALL(vnode, read_attr_stat))</a>
<a name="ln6943">		return B_UNSUPPORTED;</a>
<a name="ln6944"> </a>
<a name="ln6945">	return FS_CALL(vnode, read_attr_stat, descriptor-&gt;cookie, stat);</a>
<a name="ln6946">}</a>
<a name="ln6947"> </a>
<a name="ln6948"> </a>
<a name="ln6949">static status_t</a>
<a name="ln6950">attr_write_stat(struct file_descriptor* descriptor, const struct stat* stat,</a>
<a name="ln6951">	int statMask)</a>
<a name="ln6952">{</a>
<a name="ln6953">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln6954"> </a>
<a name="ln6955">	FUNCTION((&quot;attr_write_stat: stat = %p, statMask %d\n&quot;, stat, statMask));</a>
<a name="ln6956"> </a>
<a name="ln6957">	if (!HAS_FS_CALL(vnode, write_attr_stat))</a>
<a name="ln6958">		return B_READ_ONLY_DEVICE;</a>
<a name="ln6959"> </a>
<a name="ln6960">	return FS_CALL(vnode, write_attr_stat, descriptor-&gt;cookie, stat, statMask);</a>
<a name="ln6961">}</a>
<a name="ln6962"> </a>
<a name="ln6963"> </a>
<a name="ln6964">static status_t</a>
<a name="ln6965">attr_remove(int fd, const char* name, bool kernel)</a>
<a name="ln6966">{</a>
<a name="ln6967">	struct file_descriptor* descriptor;</a>
<a name="ln6968">	struct vnode* vnode;</a>
<a name="ln6969">	status_t status;</a>
<a name="ln6970"> </a>
<a name="ln6971">	if (name == NULL || *name == '\0')</a>
<a name="ln6972">		return B_BAD_VALUE;</a>
<a name="ln6973"> </a>
<a name="ln6974">	FUNCTION((&quot;attr_remove: fd = %d, name = \&quot;%s\&quot;, kernel %d\n&quot;, fd, name,</a>
<a name="ln6975">		kernel));</a>
<a name="ln6976"> </a>
<a name="ln6977">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln6978">	if (descriptor == NULL)</a>
<a name="ln6979">		return B_FILE_ERROR;</a>
<a name="ln6980"> </a>
<a name="ln6981">	if (HAS_FS_CALL(vnode, remove_attr))</a>
<a name="ln6982">		status = FS_CALL(vnode, remove_attr, name);</a>
<a name="ln6983">	else</a>
<a name="ln6984">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln6985"> </a>
<a name="ln6986">	put_fd(descriptor);</a>
<a name="ln6987"> </a>
<a name="ln6988">	return status;</a>
<a name="ln6989">}</a>
<a name="ln6990"> </a>
<a name="ln6991"> </a>
<a name="ln6992">static status_t</a>
<a name="ln6993">attr_rename(int fromFD, const char* fromName, int toFD, const char* toName,</a>
<a name="ln6994">	bool kernel)</a>
<a name="ln6995">{</a>
<a name="ln6996">	struct file_descriptor* fromDescriptor;</a>
<a name="ln6997">	struct file_descriptor* toDescriptor;</a>
<a name="ln6998">	struct vnode* fromVnode;</a>
<a name="ln6999">	struct vnode* toVnode;</a>
<a name="ln7000">	status_t status;</a>
<a name="ln7001"> </a>
<a name="ln7002">	if (fromName == NULL || *fromName == '\0' || toName == NULL</a>
<a name="ln7003">		|| *toName == '\0')</a>
<a name="ln7004">		return B_BAD_VALUE;</a>
<a name="ln7005"> </a>
<a name="ln7006">	FUNCTION((&quot;attr_rename: from fd = %d, from name = \&quot;%s\&quot;, to fd = %d, to &quot;</a>
<a name="ln7007">		&quot;name = \&quot;%s\&quot;, kernel %d\n&quot;, fromFD, fromName, toFD, toName, kernel));</a>
<a name="ln7008"> </a>
<a name="ln7009">	fromDescriptor = get_fd_and_vnode(fromFD, &amp;fromVnode, kernel);</a>
<a name="ln7010">	if (fromDescriptor == NULL)</a>
<a name="ln7011">		return B_FILE_ERROR;</a>
<a name="ln7012"> </a>
<a name="ln7013">	toDescriptor = get_fd_and_vnode(toFD, &amp;toVnode, kernel);</a>
<a name="ln7014">	if (toDescriptor == NULL) {</a>
<a name="ln7015">		status = B_FILE_ERROR;</a>
<a name="ln7016">		goto err;</a>
<a name="ln7017">	}</a>
<a name="ln7018"> </a>
<a name="ln7019">	// are the files on the same volume?</a>
<a name="ln7020">	if (fromVnode-&gt;device != toVnode-&gt;device) {</a>
<a name="ln7021">		status = B_CROSS_DEVICE_LINK;</a>
<a name="ln7022">		goto err1;</a>
<a name="ln7023">	}</a>
<a name="ln7024"> </a>
<a name="ln7025">	if (HAS_FS_CALL(fromVnode, rename_attr)) {</a>
<a name="ln7026">		status = FS_CALL(fromVnode, rename_attr, fromName, toVnode, toName);</a>
<a name="ln7027">	} else</a>
<a name="ln7028">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln7029"> </a>
<a name="ln7030">err1:</a>
<a name="ln7031">	put_fd(toDescriptor);</a>
<a name="ln7032">err:</a>
<a name="ln7033">	put_fd(fromDescriptor);</a>
<a name="ln7034"> </a>
<a name="ln7035">	return status;</a>
<a name="ln7036">}</a>
<a name="ln7037"> </a>
<a name="ln7038"> </a>
<a name="ln7039">static int</a>
<a name="ln7040">index_dir_open(dev_t mountID, bool kernel)</a>
<a name="ln7041">{</a>
<a name="ln7042">	struct fs_mount* mount;</a>
<a name="ln7043">	void* cookie;</a>
<a name="ln7044"> </a>
<a name="ln7045">	FUNCTION((&quot;index_dir_open(mountID = %&quot; B_PRId32 &quot;, kernel = %d)\n&quot;, mountID,</a>
<a name="ln7046">		kernel));</a>
<a name="ln7047"> </a>
<a name="ln7048">	status_t status = get_mount(mountID, &amp;mount);</a>
<a name="ln7049">	if (status != B_OK)</a>
<a name="ln7050">		return status;</a>
<a name="ln7051"> </a>
<a name="ln7052">	if (!HAS_FS_MOUNT_CALL(mount, open_index_dir)) {</a>
<a name="ln7053">		status = B_UNSUPPORTED;</a>
<a name="ln7054">		goto error;</a>
<a name="ln7055">	}</a>
<a name="ln7056"> </a>
<a name="ln7057">	status = FS_MOUNT_CALL(mount, open_index_dir, &amp;cookie);</a>
<a name="ln7058">	if (status != B_OK)</a>
<a name="ln7059">		goto error;</a>
<a name="ln7060"> </a>
<a name="ln7061">	// get fd for the index directory</a>
<a name="ln7062">	int fd;</a>
<a name="ln7063">	fd = get_new_fd(FDTYPE_INDEX_DIR, mount, NULL, cookie, O_CLOEXEC, kernel);</a>
<a name="ln7064">	if (fd &gt;= 0)</a>
<a name="ln7065">		return fd;</a>
<a name="ln7066"> </a>
<a name="ln7067">	// something went wrong</a>
<a name="ln7068">	FS_MOUNT_CALL(mount, close_index_dir, cookie);</a>
<a name="ln7069">	FS_MOUNT_CALL(mount, free_index_dir_cookie, cookie);</a>
<a name="ln7070"> </a>
<a name="ln7071">	status = fd;</a>
<a name="ln7072"> </a>
<a name="ln7073">error:</a>
<a name="ln7074">	put_mount(mount);</a>
<a name="ln7075">	return status;</a>
<a name="ln7076">}</a>
<a name="ln7077"> </a>
<a name="ln7078"> </a>
<a name="ln7079">static status_t</a>
<a name="ln7080">index_dir_close(struct file_descriptor* descriptor)</a>
<a name="ln7081">{</a>
<a name="ln7082">	struct fs_mount* mount = descriptor-&gt;u.mount;</a>
<a name="ln7083"> </a>
<a name="ln7084">	FUNCTION((&quot;index_dir_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln7085"> </a>
<a name="ln7086">	if (HAS_FS_MOUNT_CALL(mount, close_index_dir))</a>
<a name="ln7087">		return FS_MOUNT_CALL(mount, close_index_dir, descriptor-&gt;cookie);</a>
<a name="ln7088"> </a>
<a name="ln7089">	return B_OK;</a>
<a name="ln7090">}</a>
<a name="ln7091"> </a>
<a name="ln7092"> </a>
<a name="ln7093">static void</a>
<a name="ln7094">index_dir_free_fd(struct file_descriptor* descriptor)</a>
<a name="ln7095">{</a>
<a name="ln7096">	struct fs_mount* mount = descriptor-&gt;u.mount;</a>
<a name="ln7097"> </a>
<a name="ln7098">	if (mount != NULL) {</a>
<a name="ln7099">		FS_MOUNT_CALL(mount, free_index_dir_cookie, descriptor-&gt;cookie);</a>
<a name="ln7100">		put_mount(mount);</a>
<a name="ln7101">	}</a>
<a name="ln7102">}</a>
<a name="ln7103"> </a>
<a name="ln7104"> </a>
<a name="ln7105">static status_t</a>
<a name="ln7106">index_dir_read(struct io_context* ioContext, struct file_descriptor* descriptor,</a>
<a name="ln7107">	struct dirent* buffer, size_t bufferSize, uint32* _count)</a>
<a name="ln7108">{</a>
<a name="ln7109">	struct fs_mount* mount = descriptor-&gt;u.mount;</a>
<a name="ln7110"> </a>
<a name="ln7111">	if (HAS_FS_MOUNT_CALL(mount, read_index_dir)) {</a>
<a name="ln7112">		return FS_MOUNT_CALL(mount, read_index_dir, descriptor-&gt;cookie, buffer,</a>
<a name="ln7113">			bufferSize, _count);</a>
<a name="ln7114">	}</a>
<a name="ln7115"> </a>
<a name="ln7116">	return B_UNSUPPORTED;</a>
<a name="ln7117">}</a>
<a name="ln7118"> </a>
<a name="ln7119"> </a>
<a name="ln7120">static status_t</a>
<a name="ln7121">index_dir_rewind(struct file_descriptor* descriptor)</a>
<a name="ln7122">{</a>
<a name="ln7123">	struct fs_mount* mount = descriptor-&gt;u.mount;</a>
<a name="ln7124"> </a>
<a name="ln7125">	if (HAS_FS_MOUNT_CALL(mount, rewind_index_dir))</a>
<a name="ln7126">		return FS_MOUNT_CALL(mount, rewind_index_dir, descriptor-&gt;cookie);</a>
<a name="ln7127"> </a>
<a name="ln7128">	return B_UNSUPPORTED;</a>
<a name="ln7129">}</a>
<a name="ln7130"> </a>
<a name="ln7131"> </a>
<a name="ln7132">static status_t</a>
<a name="ln7133">index_create(dev_t mountID, const char* name, uint32 type, uint32 flags,</a>
<a name="ln7134">	bool kernel)</a>
<a name="ln7135">{</a>
<a name="ln7136">	FUNCTION((&quot;index_create(mountID = %&quot; B_PRId32 &quot;, name = %s, kernel = %d)\n&quot;,</a>
<a name="ln7137">		mountID, name, kernel));</a>
<a name="ln7138"> </a>
<a name="ln7139">	struct fs_mount* mount;</a>
<a name="ln7140">	status_t status = get_mount(mountID, &amp;mount);</a>
<a name="ln7141">	if (status != B_OK)</a>
<a name="ln7142">		return status;</a>
<a name="ln7143"> </a>
<a name="ln7144">	if (!HAS_FS_MOUNT_CALL(mount, create_index)) {</a>
<a name="ln7145">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln7146">		goto out;</a>
<a name="ln7147">	}</a>
<a name="ln7148"> </a>
<a name="ln7149">	status = FS_MOUNT_CALL(mount, create_index, name, type, flags);</a>
<a name="ln7150"> </a>
<a name="ln7151">out:</a>
<a name="ln7152">	put_mount(mount);</a>
<a name="ln7153">	return status;</a>
<a name="ln7154">}</a>
<a name="ln7155"> </a>
<a name="ln7156"> </a>
<a name="ln7157">#if 0</a>
<a name="ln7158">static status_t</a>
<a name="ln7159">index_read_stat(struct file_descriptor* descriptor, struct stat* stat)</a>
<a name="ln7160">{</a>
<a name="ln7161">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln7162"> </a>
<a name="ln7163">	// ToDo: currently unused!</a>
<a name="ln7164">	FUNCTION((&quot;index_read_stat: stat 0x%p\n&quot;, stat));</a>
<a name="ln7165">	if (!HAS_FS_CALL(vnode, read_index_stat))</a>
<a name="ln7166">		return B_UNSUPPORTED;</a>
<a name="ln7167"> </a>
<a name="ln7168">	return B_UNSUPPORTED;</a>
<a name="ln7169">	//return FS_CALL(vnode, read_index_stat, descriptor-&gt;cookie, stat);</a>
<a name="ln7170">}</a>
<a name="ln7171"> </a>
<a name="ln7172"> </a>
<a name="ln7173">static void</a>
<a name="ln7174">index_free_fd(struct file_descriptor* descriptor)</a>
<a name="ln7175">{</a>
<a name="ln7176">	struct vnode* vnode = descriptor-&gt;u.vnode;</a>
<a name="ln7177"> </a>
<a name="ln7178">	if (vnode != NULL) {</a>
<a name="ln7179">		FS_CALL(vnode, free_index_cookie, descriptor-&gt;cookie);</a>
<a name="ln7180">		put_vnode(vnode);</a>
<a name="ln7181">	}</a>
<a name="ln7182">}</a>
<a name="ln7183">#endif</a>
<a name="ln7184"> </a>
<a name="ln7185"> </a>
<a name="ln7186">static status_t</a>
<a name="ln7187">index_name_read_stat(dev_t mountID, const char* name, struct stat* stat,</a>
<a name="ln7188">	bool kernel)</a>
<a name="ln7189">{</a>
<a name="ln7190">	FUNCTION((&quot;index_remove(mountID = %&quot; B_PRId32 &quot;, name = %s, kernel = %d)\n&quot;,</a>
<a name="ln7191">		mountID, name, kernel));</a>
<a name="ln7192"> </a>
<a name="ln7193">	struct fs_mount* mount;</a>
<a name="ln7194">	status_t status = get_mount(mountID, &amp;mount);</a>
<a name="ln7195">	if (status != B_OK)</a>
<a name="ln7196">		return status;</a>
<a name="ln7197"> </a>
<a name="ln7198">	if (!HAS_FS_MOUNT_CALL(mount, read_index_stat)) {</a>
<a name="ln7199">		status = B_UNSUPPORTED;</a>
<a name="ln7200">		goto out;</a>
<a name="ln7201">	}</a>
<a name="ln7202"> </a>
<a name="ln7203">	status = FS_MOUNT_CALL(mount, read_index_stat, name, stat);</a>
<a name="ln7204"> </a>
<a name="ln7205">out:</a>
<a name="ln7206">	put_mount(mount);</a>
<a name="ln7207">	return status;</a>
<a name="ln7208">}</a>
<a name="ln7209"> </a>
<a name="ln7210"> </a>
<a name="ln7211">static status_t</a>
<a name="ln7212">index_remove(dev_t mountID, const char* name, bool kernel)</a>
<a name="ln7213">{</a>
<a name="ln7214">	FUNCTION((&quot;index_remove(mountID = %&quot; B_PRId32 &quot;, name = %s, kernel = %d)\n&quot;,</a>
<a name="ln7215">		mountID, name, kernel));</a>
<a name="ln7216"> </a>
<a name="ln7217">	struct fs_mount* mount;</a>
<a name="ln7218">	status_t status = get_mount(mountID, &amp;mount);</a>
<a name="ln7219">	if (status != B_OK)</a>
<a name="ln7220">		return status;</a>
<a name="ln7221"> </a>
<a name="ln7222">	if (!HAS_FS_MOUNT_CALL(mount, remove_index)) {</a>
<a name="ln7223">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln7224">		goto out;</a>
<a name="ln7225">	}</a>
<a name="ln7226"> </a>
<a name="ln7227">	status = FS_MOUNT_CALL(mount, remove_index, name);</a>
<a name="ln7228"> </a>
<a name="ln7229">out:</a>
<a name="ln7230">	put_mount(mount);</a>
<a name="ln7231">	return status;</a>
<a name="ln7232">}</a>
<a name="ln7233"> </a>
<a name="ln7234"> </a>
<a name="ln7235">/*!	TODO: the query FS API is still the pretty much the same as in R5.</a>
<a name="ln7236">		It would be nice if the FS would find some more kernel support</a>
<a name="ln7237">		for them.</a>
<a name="ln7238">		For example, query parsing should be moved into the kernel.</a>
<a name="ln7239">*/</a>
<a name="ln7240">static int</a>
<a name="ln7241">query_open(dev_t device, const char* query, uint32 flags, port_id port,</a>
<a name="ln7242">	int32 token, bool kernel)</a>
<a name="ln7243">{</a>
<a name="ln7244">	struct fs_mount* mount;</a>
<a name="ln7245">	void* cookie;</a>
<a name="ln7246"> </a>
<a name="ln7247">	FUNCTION((&quot;query_open(device = %&quot; B_PRId32 &quot;, query = \&quot;%s\&quot;, kernel = %d)\n&quot;,</a>
<a name="ln7248">		device, query, kernel));</a>
<a name="ln7249"> </a>
<a name="ln7250">	status_t status = get_mount(device, &amp;mount);</a>
<a name="ln7251">	if (status != B_OK)</a>
<a name="ln7252">		return status;</a>
<a name="ln7253"> </a>
<a name="ln7254">	if (!HAS_FS_MOUNT_CALL(mount, open_query)) {</a>
<a name="ln7255">		status = B_UNSUPPORTED;</a>
<a name="ln7256">		goto error;</a>
<a name="ln7257">	}</a>
<a name="ln7258"> </a>
<a name="ln7259">	status = FS_MOUNT_CALL(mount, open_query, query, flags, port, token,</a>
<a name="ln7260">		&amp;cookie);</a>
<a name="ln7261">	if (status != B_OK)</a>
<a name="ln7262">		goto error;</a>
<a name="ln7263"> </a>
<a name="ln7264">	// get fd for the index directory</a>
<a name="ln7265">	int fd;</a>
<a name="ln7266">	fd = get_new_fd(FDTYPE_QUERY, mount, NULL, cookie, O_CLOEXEC, kernel);</a>
<a name="ln7267">	if (fd &gt;= 0)</a>
<a name="ln7268">		return fd;</a>
<a name="ln7269"> </a>
<a name="ln7270">	status = fd;</a>
<a name="ln7271"> </a>
<a name="ln7272">	// something went wrong</a>
<a name="ln7273">	FS_MOUNT_CALL(mount, close_query, cookie);</a>
<a name="ln7274">	FS_MOUNT_CALL(mount, free_query_cookie, cookie);</a>
<a name="ln7275"> </a>
<a name="ln7276">error:</a>
<a name="ln7277">	put_mount(mount);</a>
<a name="ln7278">	return status;</a>
<a name="ln7279">}</a>
<a name="ln7280"> </a>
<a name="ln7281"> </a>
<a name="ln7282">static status_t</a>
<a name="ln7283">query_close(struct file_descriptor* descriptor)</a>
<a name="ln7284">{</a>
<a name="ln7285">	struct fs_mount* mount = descriptor-&gt;u.mount;</a>
<a name="ln7286"> </a>
<a name="ln7287">	FUNCTION((&quot;query_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln7288"> </a>
<a name="ln7289">	if (HAS_FS_MOUNT_CALL(mount, close_query))</a>
<a name="ln7290">		return FS_MOUNT_CALL(mount, close_query, descriptor-&gt;cookie);</a>
<a name="ln7291"> </a>
<a name="ln7292">	return B_OK;</a>
<a name="ln7293">}</a>
<a name="ln7294"> </a>
<a name="ln7295"> </a>
<a name="ln7296">static void</a>
<a name="ln7297">query_free_fd(struct file_descriptor* descriptor)</a>
<a name="ln7298">{</a>
<a name="ln7299">	struct fs_mount* mount = descriptor-&gt;u.mount;</a>
<a name="ln7300"> </a>
<a name="ln7301">	if (mount != NULL) {</a>
<a name="ln7302">		FS_MOUNT_CALL(mount, free_query_cookie, descriptor-&gt;cookie);</a>
<a name="ln7303">		put_mount(mount);</a>
<a name="ln7304">	}</a>
<a name="ln7305">}</a>
<a name="ln7306"> </a>
<a name="ln7307"> </a>
<a name="ln7308">static status_t</a>
<a name="ln7309">query_read(struct io_context* ioContext, struct file_descriptor* descriptor,</a>
<a name="ln7310">	struct dirent* buffer, size_t bufferSize, uint32* _count)</a>
<a name="ln7311">{</a>
<a name="ln7312">	struct fs_mount* mount = descriptor-&gt;u.mount;</a>
<a name="ln7313"> </a>
<a name="ln7314">	if (HAS_FS_MOUNT_CALL(mount, read_query)) {</a>
<a name="ln7315">		return FS_MOUNT_CALL(mount, read_query, descriptor-&gt;cookie, buffer,</a>
<a name="ln7316">			bufferSize, _count);</a>
<a name="ln7317">	}</a>
<a name="ln7318"> </a>
<a name="ln7319">	return B_UNSUPPORTED;</a>
<a name="ln7320">}</a>
<a name="ln7321"> </a>
<a name="ln7322"> </a>
<a name="ln7323">static status_t</a>
<a name="ln7324">query_rewind(struct file_descriptor* descriptor)</a>
<a name="ln7325">{</a>
<a name="ln7326">	struct fs_mount* mount = descriptor-&gt;u.mount;</a>
<a name="ln7327"> </a>
<a name="ln7328">	if (HAS_FS_MOUNT_CALL(mount, rewind_query))</a>
<a name="ln7329">		return FS_MOUNT_CALL(mount, rewind_query, descriptor-&gt;cookie);</a>
<a name="ln7330"> </a>
<a name="ln7331">	return B_UNSUPPORTED;</a>
<a name="ln7332">}</a>
<a name="ln7333"> </a>
<a name="ln7334"> </a>
<a name="ln7335">//	#pragma mark - General File System functions</a>
<a name="ln7336"> </a>
<a name="ln7337"> </a>
<a name="ln7338">static dev_t</a>
<a name="ln7339">fs_mount(char* path, const char* device, const char* fsName, uint32 flags,</a>
<a name="ln7340">	const char* args, bool kernel)</a>
<a name="ln7341">{</a>
<a name="ln7342">	struct ::fs_mount* mount;</a>
<a name="ln7343">	status_t status = B_OK;</a>
<a name="ln7344">	fs_volume* volume = NULL;</a>
<a name="ln7345">	int32 layer = 0;</a>
<a name="ln7346">	Vnode* coveredNode = NULL;</a>
<a name="ln7347"> </a>
<a name="ln7348">	FUNCTION((&quot;fs_mount: path = '%s', device = '%s', fs_name = '%s', flags = %#&quot;</a>
<a name="ln7349">		B_PRIx32 &quot;, args = '%s'\n&quot;, path, device, fsName, flags, args));</a>
<a name="ln7350"> </a>
<a name="ln7351">	// The path is always safe, we just have to make sure that fsName is</a>
<a name="ln7352">	// almost valid - we can't make any assumptions about args, though.</a>
<a name="ln7353">	// A NULL fsName is OK, if a device was given and the FS is not virtual.</a>
<a name="ln7354">	// We'll get it from the DDM later.</a>
<a name="ln7355">	if (fsName == NULL) {</a>
<a name="ln7356">		if (!device || flags &amp; B_MOUNT_VIRTUAL_DEVICE)</a>
<a name="ln7357">			return B_BAD_VALUE;</a>
<a name="ln7358">	} else if (fsName[0] == '\0')</a>
<a name="ln7359">		return B_BAD_VALUE;</a>
<a name="ln7360"> </a>
<a name="ln7361">	RecursiveLocker mountOpLocker(sMountOpLock);</a>
<a name="ln7362"> </a>
<a name="ln7363">	// Helper to delete a newly created file device on failure.</a>
<a name="ln7364">	// Not exactly beautiful, but helps to keep the code below cleaner.</a>
<a name="ln7365">	struct FileDeviceDeleter {</a>
<a name="ln7366">		FileDeviceDeleter() : id(-1) {}</a>
<a name="ln7367">		~FileDeviceDeleter()</a>
<a name="ln7368">		{</a>
<a name="ln7369">			KDiskDeviceManager::Default()-&gt;DeleteFileDevice(id);</a>
<a name="ln7370">		}</a>
<a name="ln7371"> </a>
<a name="ln7372">		partition_id id;</a>
<a name="ln7373">	} fileDeviceDeleter;</a>
<a name="ln7374"> </a>
<a name="ln7375">	// If the file system is not a &quot;virtual&quot; one, the device argument should</a>
<a name="ln7376">	// point to a real file/device (if given at all).</a>
<a name="ln7377">	// get the partition</a>
<a name="ln7378">	KDiskDeviceManager* ddm = KDiskDeviceManager::Default();</a>
<a name="ln7379">	KPartition* partition = NULL;</a>
<a name="ln7380">	KPath normalizedDevice;</a>
<a name="ln7381">	bool newlyCreatedFileDevice = false;</a>
<a name="ln7382"> </a>
<a name="ln7383">	if (!(flags &amp; B_MOUNT_VIRTUAL_DEVICE) &amp;&amp; device != NULL) {</a>
<a name="ln7384">		// normalize the device path</a>
<a name="ln7385">		status = normalizedDevice.SetTo(device, true);</a>
<a name="ln7386">		if (status != B_OK)</a>
<a name="ln7387">			return status;</a>
<a name="ln7388"> </a>
<a name="ln7389">		// get a corresponding partition from the DDM</a>
<a name="ln7390">		partition = ddm-&gt;RegisterPartition(normalizedDevice.Path());</a>
<a name="ln7391">		if (partition == NULL) {</a>
<a name="ln7392">			// Partition not found: This either means, the user supplied</a>
<a name="ln7393">			// an invalid path, or the path refers to an image file. We try</a>
<a name="ln7394">			// to let the DDM create a file device for the path.</a>
<a name="ln7395">			partition_id deviceID = ddm-&gt;CreateFileDevice(</a>
<a name="ln7396">				normalizedDevice.Path(), &amp;newlyCreatedFileDevice);</a>
<a name="ln7397">			if (deviceID &gt;= 0) {</a>
<a name="ln7398">				partition = ddm-&gt;RegisterPartition(deviceID);</a>
<a name="ln7399">				if (newlyCreatedFileDevice)</a>
<a name="ln7400">					fileDeviceDeleter.id = deviceID;</a>
<a name="ln7401">			}</a>
<a name="ln7402">		}</a>
<a name="ln7403"> </a>
<a name="ln7404">		if (!partition) {</a>
<a name="ln7405">			TRACE((&quot;fs_mount(): Partition `%s' not found.\n&quot;,</a>
<a name="ln7406">				normalizedDevice.Path()));</a>
<a name="ln7407">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln7408">		}</a>
<a name="ln7409"> </a>
<a name="ln7410">		device = normalizedDevice.Path();</a>
<a name="ln7411">			// correct path to file device</a>
<a name="ln7412">	}</a>
<a name="ln7413">	PartitionRegistrar partitionRegistrar(partition, true);</a>
<a name="ln7414"> </a>
<a name="ln7415">	// Write lock the partition's device. For the time being, we keep the lock</a>
<a name="ln7416">	// until we're done mounting -- not nice, but ensure, that no-one is</a>
<a name="ln7417">	// interfering.</a>
<a name="ln7418">	// TODO: Just mark the partition busy while mounting!</a>
<a name="ln7419">	KDiskDevice* diskDevice = NULL;</a>
<a name="ln7420">	if (partition) {</a>
<a name="ln7421">		diskDevice = ddm-&gt;WriteLockDevice(partition-&gt;Device()-&gt;ID());</a>
<a name="ln7422">		if (!diskDevice) {</a>
<a name="ln7423">			TRACE((&quot;fs_mount(): Failed to lock disk device!\n&quot;));</a>
<a name="ln7424">			return B_ERROR;</a>
<a name="ln7425">		}</a>
<a name="ln7426">	}</a>
<a name="ln7427"> </a>
<a name="ln7428">	DeviceWriteLocker writeLocker(diskDevice, true);</a>
<a name="ln7429">		// this takes over the write lock acquired before</a>
<a name="ln7430"> </a>
<a name="ln7431">	if (partition != NULL) {</a>
<a name="ln7432">		// make sure, that the partition is not busy</a>
<a name="ln7433">		if (partition-&gt;IsBusy()) {</a>
<a name="ln7434">			TRACE((&quot;fs_mount(): Partition is busy.\n&quot;));</a>
<a name="ln7435">			return B_BUSY;</a>
<a name="ln7436">		}</a>
<a name="ln7437"> </a>
<a name="ln7438">		// if no FS name had been supplied, we get it from the partition</a>
<a name="ln7439">		if (fsName == NULL) {</a>
<a name="ln7440">			KDiskSystem* diskSystem = partition-&gt;DiskSystem();</a>
<a name="ln7441">			if (!diskSystem) {</a>
<a name="ln7442">				TRACE((&quot;fs_mount(): No FS name was given, and the DDM didn't &quot;</a>
<a name="ln7443">					&quot;recognize it.\n&quot;));</a>
<a name="ln7444">				return B_BAD_VALUE;</a>
<a name="ln7445">			}</a>
<a name="ln7446"> </a>
<a name="ln7447">			if (!diskSystem-&gt;IsFileSystem()) {</a>
<a name="ln7448">				TRACE((&quot;fs_mount(): No FS name was given, and the DDM found a &quot;</a>
<a name="ln7449">					&quot;partitioning system.\n&quot;));</a>
<a name="ln7450">				return B_BAD_VALUE;</a>
<a name="ln7451">			}</a>
<a name="ln7452"> </a>
<a name="ln7453">			// The disk system name will not change, and the KDiskSystem</a>
<a name="ln7454">			// object will not go away while the disk device is locked (and</a>
<a name="ln7455">			// the partition has a reference to it), so this is safe.</a>
<a name="ln7456">			fsName = diskSystem-&gt;Name();</a>
<a name="ln7457">		}</a>
<a name="ln7458">	}</a>
<a name="ln7459"> </a>
<a name="ln7460">	mount = new(std::nothrow) (struct ::fs_mount);</a>
<a name="ln7461">	if (mount == NULL)</a>
<a name="ln7462">		return B_NO_MEMORY;</a>
<a name="ln7463"> </a>
<a name="ln7464">	mount-&gt;device_name = strdup(device);</a>
<a name="ln7465">		// &quot;device&quot; can be NULL</a>
<a name="ln7466"> </a>
<a name="ln7467">	status = mount-&gt;entry_cache.Init();</a>
<a name="ln7468">	if (status != B_OK)</a>
<a name="ln7469">		goto err1;</a>
<a name="ln7470"> </a>
<a name="ln7471">	// initialize structure</a>
<a name="ln7472">	mount-&gt;id = sNextMountID++;</a>
<a name="ln7473">	mount-&gt;partition = NULL;</a>
<a name="ln7474">	mount-&gt;root_vnode = NULL;</a>
<a name="ln7475">	mount-&gt;covers_vnode = NULL;</a>
<a name="ln7476">	mount-&gt;unmounting = false;</a>
<a name="ln7477">	mount-&gt;owns_file_device = false;</a>
<a name="ln7478">	mount-&gt;volume = NULL;</a>
<a name="ln7479"> </a>
<a name="ln7480">	// build up the volume(s)</a>
<a name="ln7481">	while (true) {</a>
<a name="ln7482">		char* layerFSName = get_file_system_name_for_layer(fsName, layer);</a>
<a name="ln7483">		if (layerFSName == NULL) {</a>
<a name="ln7484">			if (layer == 0) {</a>
<a name="ln7485">				status = B_NO_MEMORY;</a>
<a name="ln7486">				goto err1;</a>
<a name="ln7487">			}</a>
<a name="ln7488"> </a>
<a name="ln7489">			break;</a>
<a name="ln7490">		}</a>
<a name="ln7491">		MemoryDeleter layerFSNameDeleter(layerFSName);</a>
<a name="ln7492"> </a>
<a name="ln7493">		volume = (fs_volume*)malloc(sizeof(fs_volume));</a>
<a name="ln7494">		if (volume == NULL) {</a>
<a name="ln7495">			status = B_NO_MEMORY;</a>
<a name="ln7496">			goto err1;</a>
<a name="ln7497">		}</a>
<a name="ln7498"> </a>
<a name="ln7499">		volume-&gt;id = mount-&gt;id;</a>
<a name="ln7500">		volume-&gt;partition = partition != NULL ? partition-&gt;ID() : -1;</a>
<a name="ln7501">		volume-&gt;layer = layer++;</a>
<a name="ln7502">		volume-&gt;private_volume = NULL;</a>
<a name="ln7503">		volume-&gt;ops = NULL;</a>
<a name="ln7504">		volume-&gt;sub_volume = NULL;</a>
<a name="ln7505">		volume-&gt;super_volume = NULL;</a>
<a name="ln7506">		volume-&gt;file_system = NULL;</a>
<a name="ln7507">		volume-&gt;file_system_name = NULL;</a>
<a name="ln7508"> </a>
<a name="ln7509">		volume-&gt;file_system_name = get_file_system_name(layerFSName);</a>
<a name="ln7510">		if (volume-&gt;file_system_name == NULL) {</a>
<a name="ln7511">			status = B_NO_MEMORY;</a>
<a name="ln7512">			free(volume);</a>
<a name="ln7513">			goto err1;</a>
<a name="ln7514">		}</a>
<a name="ln7515"> </a>
<a name="ln7516">		volume-&gt;file_system = get_file_system(layerFSName);</a>
<a name="ln7517">		if (volume-&gt;file_system == NULL) {</a>
<a name="ln7518">			status = B_DEVICE_NOT_FOUND;</a>
<a name="ln7519">			free(volume-&gt;file_system_name);</a>
<a name="ln7520">			free(volume);</a>
<a name="ln7521">			goto err1;</a>
<a name="ln7522">		}</a>
<a name="ln7523"> </a>
<a name="ln7524">		if (mount-&gt;volume == NULL)</a>
<a name="ln7525">			mount-&gt;volume = volume;</a>
<a name="ln7526">		else {</a>
<a name="ln7527">			volume-&gt;super_volume = mount-&gt;volume;</a>
<a name="ln7528">			mount-&gt;volume-&gt;sub_volume = volume;</a>
<a name="ln7529">			mount-&gt;volume = volume;</a>
<a name="ln7530">		}</a>
<a name="ln7531">	}</a>
<a name="ln7532"> </a>
<a name="ln7533">	// insert mount struct into list before we call FS's mount() function</a>
<a name="ln7534">	// so that vnodes can be created for this mount</a>
<a name="ln7535">	mutex_lock(&amp;sMountMutex);</a>
<a name="ln7536">	sMountsTable-&gt;Insert(mount);</a>
<a name="ln7537">	mutex_unlock(&amp;sMountMutex);</a>
<a name="ln7538"> </a>
<a name="ln7539">	ino_t rootID;</a>
<a name="ln7540"> </a>
<a name="ln7541">	if (!sRoot) {</a>
<a name="ln7542">		// we haven't mounted anything yet</a>
<a name="ln7543">		if (strcmp(path, &quot;/&quot;) != 0) {</a>
<a name="ln7544">			status = B_ERROR;</a>
<a name="ln7545">			goto err2;</a>
<a name="ln7546">		}</a>
<a name="ln7547"> </a>
<a name="ln7548">		status = mount-&gt;volume-&gt;file_system-&gt;mount(mount-&gt;volume, device, flags,</a>
<a name="ln7549">			args, &amp;rootID);</a>
<a name="ln7550">		if (status != B_OK || mount-&gt;volume-&gt;ops == NULL)</a>
<a name="ln7551">			goto err2;</a>
<a name="ln7552">	} else {</a>
<a name="ln7553">		status = path_to_vnode(path, true, &amp;coveredNode, NULL, kernel);</a>
<a name="ln7554">		if (status != B_OK)</a>
<a name="ln7555">			goto err2;</a>
<a name="ln7556"> </a>
<a name="ln7557">		mount-&gt;covers_vnode = coveredNode;</a>
<a name="ln7558"> </a>
<a name="ln7559">		// make sure covered_vnode is a directory</a>
<a name="ln7560">		if (!S_ISDIR(coveredNode-&gt;Type())) {</a>
<a name="ln7561">			status = B_NOT_A_DIRECTORY;</a>
<a name="ln7562">			goto err3;</a>
<a name="ln7563">		}</a>
<a name="ln7564"> </a>
<a name="ln7565">		if (coveredNode-&gt;IsCovered()) {</a>
<a name="ln7566">			// this is already a covered vnode</a>
<a name="ln7567">			status = B_BUSY;</a>
<a name="ln7568">			goto err3;</a>
<a name="ln7569">		}</a>
<a name="ln7570"> </a>
<a name="ln7571">		// mount it/them</a>
<a name="ln7572">		fs_volume* volume = mount-&gt;volume;</a>
<a name="ln7573">		while (volume) {</a>
<a name="ln7574">			status = volume-&gt;file_system-&gt;mount(volume, device, flags, args,</a>
<a name="ln7575">				&amp;rootID);</a>
<a name="ln7576">			if (status != B_OK || volume-&gt;ops == NULL) {</a>
<a name="ln7577">				if (status == B_OK &amp;&amp; volume-&gt;ops == NULL)</a>
<a name="ln7578">					panic(&quot;fs_mount: mount() succeeded but ops is NULL!&quot;);</a>
<a name="ln7579">				if (volume-&gt;sub_volume)</a>
<a name="ln7580">					goto err4;</a>
<a name="ln7581">				goto err3;</a>
<a name="ln7582">			}</a>
<a name="ln7583"> </a>
<a name="ln7584">			volume = volume-&gt;super_volume;</a>
<a name="ln7585">		}</a>
<a name="ln7586"> </a>
<a name="ln7587">		volume = mount-&gt;volume;</a>
<a name="ln7588">		while (volume) {</a>
<a name="ln7589">			if (volume-&gt;ops-&gt;all_layers_mounted != NULL)</a>
<a name="ln7590">				volume-&gt;ops-&gt;all_layers_mounted(volume);</a>
<a name="ln7591">			volume = volume-&gt;super_volume;</a>
<a name="ln7592">		}</a>
<a name="ln7593">	}</a>
<a name="ln7594"> </a>
<a name="ln7595">	// the root node is supposed to be owned by the file system - it must</a>
<a name="ln7596">	// exist at this point</a>
<a name="ln7597">	mount-&gt;root_vnode = lookup_vnode(mount-&gt;id, rootID);</a>
<a name="ln7598">	if (mount-&gt;root_vnode == NULL || mount-&gt;root_vnode-&gt;ref_count != 1) {</a>
<a name="ln7599">		panic(&quot;fs_mount: file system does not own its root node!\n&quot;);</a>
<a name="ln7600">		status = B_ERROR;</a>
<a name="ln7601">		goto err4;</a>
<a name="ln7602">	}</a>
<a name="ln7603"> </a>
<a name="ln7604">	// set up the links between the root vnode and the vnode it covers</a>
<a name="ln7605">	rw_lock_write_lock(&amp;sVnodeLock);</a>
<a name="ln7606">	if (coveredNode != NULL) {</a>
<a name="ln7607">		if (coveredNode-&gt;IsCovered()) {</a>
<a name="ln7608">			// the vnode is covered now</a>
<a name="ln7609">			status = B_BUSY;</a>
<a name="ln7610">			rw_lock_write_unlock(&amp;sVnodeLock);</a>
<a name="ln7611">			goto err4;</a>
<a name="ln7612">		}</a>
<a name="ln7613"> </a>
<a name="ln7614">		mount-&gt;root_vnode-&gt;covers = coveredNode;</a>
<a name="ln7615">		mount-&gt;root_vnode-&gt;SetCovering(true);</a>
<a name="ln7616"> </a>
<a name="ln7617">		coveredNode-&gt;covered_by = mount-&gt;root_vnode;</a>
<a name="ln7618">		coveredNode-&gt;SetCovered(true);</a>
<a name="ln7619">	}</a>
<a name="ln7620">	rw_lock_write_unlock(&amp;sVnodeLock);</a>
<a name="ln7621"> </a>
<a name="ln7622">	if (!sRoot) {</a>
<a name="ln7623">		sRoot = mount-&gt;root_vnode;</a>
<a name="ln7624">		mutex_lock(&amp;sIOContextRootLock);</a>
<a name="ln7625">		get_current_io_context(true)-&gt;root = sRoot;</a>
<a name="ln7626">		mutex_unlock(&amp;sIOContextRootLock);</a>
<a name="ln7627">		inc_vnode_ref_count(sRoot);</a>
<a name="ln7628">	}</a>
<a name="ln7629"> </a>
<a name="ln7630">	// supply the partition (if any) with the mount cookie and mark it mounted</a>
<a name="ln7631">	if (partition) {</a>
<a name="ln7632">		partition-&gt;SetMountCookie(mount-&gt;volume-&gt;private_volume);</a>
<a name="ln7633">		partition-&gt;SetVolumeID(mount-&gt;id);</a>
<a name="ln7634"> </a>
<a name="ln7635">		// keep a partition reference as long as the partition is mounted</a>
<a name="ln7636">		partitionRegistrar.Detach();</a>
<a name="ln7637">		mount-&gt;partition = partition;</a>
<a name="ln7638">		mount-&gt;owns_file_device = newlyCreatedFileDevice;</a>
<a name="ln7639">		fileDeviceDeleter.id = -1;</a>
<a name="ln7640">	}</a>
<a name="ln7641"> </a>
<a name="ln7642">	notify_mount(mount-&gt;id,</a>
<a name="ln7643">		coveredNode != NULL ? coveredNode-&gt;device : -1,</a>
<a name="ln7644">		coveredNode ? coveredNode-&gt;id : -1);</a>
<a name="ln7645"> </a>
<a name="ln7646">	return mount-&gt;id;</a>
<a name="ln7647"> </a>
<a name="ln7648">err4:</a>
<a name="ln7649">	FS_MOUNT_CALL_NO_PARAMS(mount, unmount);</a>
<a name="ln7650">err3:</a>
<a name="ln7651">	if (coveredNode != NULL)</a>
<a name="ln7652">		put_vnode(coveredNode);</a>
<a name="ln7653">err2:</a>
<a name="ln7654">	mutex_lock(&amp;sMountMutex);</a>
<a name="ln7655">	sMountsTable-&gt;Remove(mount);</a>
<a name="ln7656">	mutex_unlock(&amp;sMountMutex);</a>
<a name="ln7657">err1:</a>
<a name="ln7658">	delete mount;</a>
<a name="ln7659"> </a>
<a name="ln7660">	return status;</a>
<a name="ln7661">}</a>
<a name="ln7662"> </a>
<a name="ln7663"> </a>
<a name="ln7664">static status_t</a>
<a name="ln7665">fs_unmount(char* path, dev_t mountID, uint32 flags, bool kernel)</a>
<a name="ln7666">{</a>
<a name="ln7667">	struct fs_mount* mount;</a>
<a name="ln7668">	status_t err;</a>
<a name="ln7669"> </a>
<a name="ln7670">	FUNCTION((&quot;fs_unmount(path '%s', dev %&quot; B_PRId32 &quot;, kernel %d\n&quot;, path,</a>
<a name="ln7671">		mountID, kernel));</a>
<a name="ln7672"> </a>
<a name="ln7673">	struct vnode* pathVnode = NULL;</a>
<a name="ln7674">	if (path != NULL) {</a>
<a name="ln7675">		err = path_to_vnode(path, true, &amp;pathVnode, NULL, kernel);</a>
<a name="ln7676">		if (err != B_OK)</a>
<a name="ln7677">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln7678">	}</a>
<a name="ln7679"> </a>
<a name="ln7680">	RecursiveLocker mountOpLocker(sMountOpLock);</a>
<a name="ln7681"> </a>
<a name="ln7682">	// this lock is not strictly necessary, but here in case of KDEBUG</a>
<a name="ln7683">	// to keep the ASSERT in find_mount() working.</a>
<a name="ln7684">	KDEBUG_ONLY(mutex_lock(&amp;sMountMutex));</a>
<a name="ln7685">	mount = find_mount(path != NULL ? pathVnode-&gt;device : mountID);</a>
<a name="ln7686">	KDEBUG_ONLY(mutex_unlock(&amp;sMountMutex));</a>
<a name="ln7687">	if (mount == NULL) {</a>
<a name="ln7688">		panic(&quot;fs_unmount: find_mount() failed on root vnode @%p of mount\n&quot;,</a>
<a name="ln7689">			pathVnode);</a>
<a name="ln7690">	}</a>
<a name="ln7691"> </a>
<a name="ln7692">	if (path != NULL) {</a>
<a name="ln7693">		put_vnode(pathVnode);</a>
<a name="ln7694"> </a>
<a name="ln7695">		if (mount-&gt;root_vnode != pathVnode) {</a>
<a name="ln7696">			// not mountpoint</a>
<a name="ln7697">			return B_BAD_VALUE;</a>
<a name="ln7698">		}</a>
<a name="ln7699">	}</a>
<a name="ln7700"> </a>
<a name="ln7701">	// if the volume is associated with a partition, lock the device of the</a>
<a name="ln7702">	// partition as long as we are unmounting</a>
<a name="ln7703">	KDiskDeviceManager* ddm = KDiskDeviceManager::Default();</a>
<a name="ln7704">	KPartition* partition = mount-&gt;partition;</a>
<a name="ln7705">	KDiskDevice* diskDevice = NULL;</a>
<a name="ln7706">	if (partition != NULL) {</a>
<a name="ln7707">		if (partition-&gt;Device() == NULL) {</a>
<a name="ln7708">			dprintf(&quot;fs_unmount(): There is no device!\n&quot;);</a>
<a name="ln7709">			return B_ERROR;</a>
<a name="ln7710">		}</a>
<a name="ln7711">		diskDevice = ddm-&gt;WriteLockDevice(partition-&gt;Device()-&gt;ID());</a>
<a name="ln7712">		if (!diskDevice) {</a>
<a name="ln7713">			TRACE((&quot;fs_unmount(): Failed to lock disk device!\n&quot;));</a>
<a name="ln7714">			return B_ERROR;</a>
<a name="ln7715">		}</a>
<a name="ln7716">	}</a>
<a name="ln7717">	DeviceWriteLocker writeLocker(diskDevice, true);</a>
<a name="ln7718"> </a>
<a name="ln7719">	// make sure, that the partition is not busy</a>
<a name="ln7720">	if (partition != NULL) {</a>
<a name="ln7721">		if ((flags &amp; B_UNMOUNT_BUSY_PARTITION) == 0 &amp;&amp; partition-&gt;IsBusy()) {</a>
<a name="ln7722">			TRACE((&quot;fs_unmount(): Partition is busy.\n&quot;));</a>
<a name="ln7723">			return B_BUSY;</a>
<a name="ln7724">		}</a>
<a name="ln7725">	}</a>
<a name="ln7726"> </a>
<a name="ln7727">	// grab the vnode master mutex to keep someone from creating</a>
<a name="ln7728">	// a vnode while we're figuring out if we can continue</a>
<a name="ln7729">	WriteLocker vnodesWriteLocker(&amp;sVnodeLock);</a>
<a name="ln7730"> </a>
<a name="ln7731">	bool disconnectedDescriptors = false;</a>
<a name="ln7732"> </a>
<a name="ln7733">	while (true) {</a>
<a name="ln7734">		bool busy = false;</a>
<a name="ln7735"> </a>
<a name="ln7736">		// cycle through the list of vnodes associated with this mount and</a>
<a name="ln7737">		// make sure all of them are not busy or have refs on them</a>
<a name="ln7738">		VnodeList::Iterator iterator = mount-&gt;vnodes.GetIterator();</a>
<a name="ln7739">		while (struct vnode* vnode = iterator.Next()) {</a>
<a name="ln7740">			if (vnode-&gt;IsBusy()) {</a>
<a name="ln7741">				busy = true;</a>
<a name="ln7742">				break;</a>
<a name="ln7743">			}</a>
<a name="ln7744"> </a>
<a name="ln7745">			// check the vnode's ref count -- subtract additional references for</a>
<a name="ln7746">			// covering</a>
<a name="ln7747">			int32 refCount = vnode-&gt;ref_count;</a>
<a name="ln7748">			if (vnode-&gt;covers != NULL)</a>
<a name="ln7749">				refCount--;</a>
<a name="ln7750">			if (vnode-&gt;covered_by != NULL)</a>
<a name="ln7751">				refCount--;</a>
<a name="ln7752"> </a>
<a name="ln7753">			if (refCount != 0) {</a>
<a name="ln7754">				// there are still vnodes in use on this mount, so we cannot</a>
<a name="ln7755">				// unmount yet</a>
<a name="ln7756">				busy = true;</a>
<a name="ln7757">				break;</a>
<a name="ln7758">			}</a>
<a name="ln7759">		}</a>
<a name="ln7760"> </a>
<a name="ln7761">		if (!busy)</a>
<a name="ln7762">			break;</a>
<a name="ln7763"> </a>
<a name="ln7764">		if ((flags &amp; B_FORCE_UNMOUNT) == 0)</a>
<a name="ln7765">			return B_BUSY;</a>
<a name="ln7766"> </a>
<a name="ln7767">		if (disconnectedDescriptors) {</a>
<a name="ln7768">			// wait a bit until the last access is finished, and then try again</a>
<a name="ln7769">			vnodesWriteLocker.Unlock();</a>
<a name="ln7770">			snooze(100000);</a>
<a name="ln7771">			// TODO: if there is some kind of bug that prevents the ref counts</a>
<a name="ln7772">			// from getting back to zero, this will fall into an endless loop...</a>
<a name="ln7773">			vnodesWriteLocker.Lock();</a>
<a name="ln7774">			continue;</a>
<a name="ln7775">		}</a>
<a name="ln7776"> </a>
<a name="ln7777">		// the file system is still busy - but we're forced to unmount it,</a>
<a name="ln7778">		// so let's disconnect all open file descriptors</a>
<a name="ln7779"> </a>
<a name="ln7780">		mount-&gt;unmounting = true;</a>
<a name="ln7781">			// prevent new vnodes from being created</a>
<a name="ln7782"> </a>
<a name="ln7783">		vnodesWriteLocker.Unlock();</a>
<a name="ln7784"> </a>
<a name="ln7785">		disconnect_mount_or_vnode_fds(mount, NULL);</a>
<a name="ln7786">		disconnectedDescriptors = true;</a>
<a name="ln7787"> </a>
<a name="ln7788">		vnodesWriteLocker.Lock();</a>
<a name="ln7789">	}</a>
<a name="ln7790"> </a>
<a name="ln7791">	// We can safely continue. Mark all of the vnodes busy and this mount</a>
<a name="ln7792">	// structure in unmounting state. Also undo the vnode covers/covered_by</a>
<a name="ln7793">	// links.</a>
<a name="ln7794">	mount-&gt;unmounting = true;</a>
<a name="ln7795"> </a>
<a name="ln7796">	VnodeList::Iterator iterator = mount-&gt;vnodes.GetIterator();</a>
<a name="ln7797">	while (struct vnode* vnode = iterator.Next()) {</a>
<a name="ln7798">		// Remove all covers/covered_by links from other mounts' nodes to this</a>
<a name="ln7799">		// vnode and adjust the node ref count accordingly. We will release the</a>
<a name="ln7800">		// references to the external vnodes below.</a>
<a name="ln7801">		if (Vnode* coveredNode = vnode-&gt;covers) {</a>
<a name="ln7802">			if (Vnode* coveringNode = vnode-&gt;covered_by) {</a>
<a name="ln7803">				// We have both covered and covering vnodes, so just remove us</a>
<a name="ln7804">				// from the chain.</a>
<a name="ln7805">				coveredNode-&gt;covered_by = coveringNode;</a>
<a name="ln7806">				coveringNode-&gt;covers = coveredNode;</a>
<a name="ln7807">				vnode-&gt;ref_count -= 2;</a>
<a name="ln7808"> </a>
<a name="ln7809">				vnode-&gt;covered_by = NULL;</a>
<a name="ln7810">				vnode-&gt;covers = NULL;</a>
<a name="ln7811">				vnode-&gt;SetCovering(false);</a>
<a name="ln7812">				vnode-&gt;SetCovered(false);</a>
<a name="ln7813">			} else {</a>
<a name="ln7814">				// We only have a covered vnode. Remove its link to us.</a>
<a name="ln7815">				coveredNode-&gt;covered_by = NULL;</a>
<a name="ln7816">				coveredNode-&gt;SetCovered(false);</a>
<a name="ln7817">				vnode-&gt;ref_count--;</a>
<a name="ln7818"> </a>
<a name="ln7819">				// If the other node is an external vnode, we keep its link</a>
<a name="ln7820">				// link around so we can put the reference later on. Otherwise</a>
<a name="ln7821">				// we get rid of it right now.</a>
<a name="ln7822">				if (coveredNode-&gt;mount == mount) {</a>
<a name="ln7823">					vnode-&gt;covers = NULL;</a>
<a name="ln7824">					coveredNode-&gt;ref_count--;</a>
<a name="ln7825">				}</a>
<a name="ln7826">			}</a>
<a name="ln7827">		} else if (Vnode* coveringNode = vnode-&gt;covered_by) {</a>
<a name="ln7828">			// We only have a covering vnode. Remove its link to us.</a>
<a name="ln7829">			coveringNode-&gt;covers = NULL;</a>
<a name="ln7830">			coveringNode-&gt;SetCovering(false);</a>
<a name="ln7831">			vnode-&gt;ref_count--;</a>
<a name="ln7832"> </a>
<a name="ln7833">			// If the other node is an external vnode, we keep its link</a>
<a name="ln7834">			// link around so we can put the reference later on. Otherwise</a>
<a name="ln7835">			// we get rid of it right now.</a>
<a name="ln7836">			if (coveringNode-&gt;mount == mount) {</a>
<a name="ln7837">				vnode-&gt;covered_by = NULL;</a>
<a name="ln7838">				coveringNode-&gt;ref_count--;</a>
<a name="ln7839">			}</a>
<a name="ln7840">		}</a>
<a name="ln7841"> </a>
<a name="ln7842">		vnode-&gt;SetBusy(true);</a>
<a name="ln7843">		vnode_to_be_freed(vnode);</a>
<a name="ln7844">	}</a>
<a name="ln7845"> </a>
<a name="ln7846">	vnodesWriteLocker.Unlock();</a>
<a name="ln7847"> </a>
<a name="ln7848">	// Free all vnodes associated with this mount.</a>
<a name="ln7849">	// They will be removed from the mount list by free_vnode(), so</a>
<a name="ln7850">	// we don't have to do this.</a>
<a name="ln7851">	while (struct vnode* vnode = mount-&gt;vnodes.Head()) {</a>
<a name="ln7852">		// Put the references to external covered/covering vnodes we kept above.</a>
<a name="ln7853">		if (Vnode* coveredNode = vnode-&gt;covers)</a>
<a name="ln7854">			put_vnode(coveredNode);</a>
<a name="ln7855">		if (Vnode* coveringNode = vnode-&gt;covered_by)</a>
<a name="ln7856">			put_vnode(coveringNode);</a>
<a name="ln7857"> </a>
<a name="ln7858">		free_vnode(vnode, false);</a>
<a name="ln7859">	}</a>
<a name="ln7860"> </a>
<a name="ln7861">	// remove the mount structure from the hash table</a>
<a name="ln7862">	mutex_lock(&amp;sMountMutex);</a>
<a name="ln7863">	sMountsTable-&gt;Remove(mount);</a>
<a name="ln7864">	mutex_unlock(&amp;sMountMutex);</a>
<a name="ln7865"> </a>
<a name="ln7866">	mountOpLocker.Unlock();</a>
<a name="ln7867"> </a>
<a name="ln7868">	FS_MOUNT_CALL_NO_PARAMS(mount, unmount);</a>
<a name="ln7869">	notify_unmount(mount-&gt;id);</a>
<a name="ln7870"> </a>
<a name="ln7871">	// dereference the partition and mark it unmounted</a>
<a name="ln7872">	if (partition) {</a>
<a name="ln7873">		partition-&gt;SetVolumeID(-1);</a>
<a name="ln7874">		partition-&gt;SetMountCookie(NULL);</a>
<a name="ln7875"> </a>
<a name="ln7876">		if (mount-&gt;owns_file_device)</a>
<a name="ln7877">			KDiskDeviceManager::Default()-&gt;DeleteFileDevice(partition-&gt;ID());</a>
<a name="ln7878">		partition-&gt;Unregister();</a>
<a name="ln7879">	}</a>
<a name="ln7880"> </a>
<a name="ln7881">	delete mount;</a>
<a name="ln7882">	return B_OK;</a>
<a name="ln7883">}</a>
<a name="ln7884"> </a>
<a name="ln7885"> </a>
<a name="ln7886">static status_t</a>
<a name="ln7887">fs_sync(dev_t device)</a>
<a name="ln7888">{</a>
<a name="ln7889">	struct fs_mount* mount;</a>
<a name="ln7890">	status_t status = get_mount(device, &amp;mount);</a>
<a name="ln7891">	if (status != B_OK)</a>
<a name="ln7892">		return status;</a>
<a name="ln7893"> </a>
<a name="ln7894">	struct vnode marker;</a>
<a name="ln7895">	memset(&amp;marker, 0, sizeof(marker));</a>
<a name="ln7896">	marker.SetBusy(true);</a>
<a name="ln7897">	marker.SetRemoved(true);</a>
<a name="ln7898"> </a>
<a name="ln7899">	// First, synchronize all file caches</a>
<a name="ln7900"> </a>
<a name="ln7901">	while (true) {</a>
<a name="ln7902">		WriteLocker locker(sVnodeLock);</a>
<a name="ln7903">			// Note: That's the easy way. Which is probably OK for sync(),</a>
<a name="ln7904">			// since it's a relatively rare call and doesn't need to allow for</a>
<a name="ln7905">			// a lot of concurrency. Using a read lock would be possible, but</a>
<a name="ln7906">			// also more involved, since we had to lock the individual nodes</a>
<a name="ln7907">			// and take care of the locking order, which we might not want to</a>
<a name="ln7908">			// do while holding fs_mount::lock.</a>
<a name="ln7909"> </a>
<a name="ln7910">		// synchronize access to vnode list</a>
<a name="ln7911">		mutex_lock(&amp;mount-&gt;lock);</a>
<a name="ln7912"> </a>
<a name="ln7913">		struct vnode* vnode;</a>
<a name="ln7914">		if (!marker.IsRemoved()) {</a>
<a name="ln7915">			vnode = mount-&gt;vnodes.GetNext(&amp;marker);</a>
<a name="ln7916">			mount-&gt;vnodes.Remove(&amp;marker);</a>
<a name="ln7917">			marker.SetRemoved(true);</a>
<a name="ln7918">		} else</a>
<a name="ln7919">			vnode = mount-&gt;vnodes.First();</a>
<a name="ln7920"> </a>
<a name="ln7921">		while (vnode != NULL &amp;&amp; (vnode-&gt;cache == NULL</a>
<a name="ln7922">			|| vnode-&gt;IsRemoved() || vnode-&gt;IsBusy())) {</a>
<a name="ln7923">			// TODO: we could track writes (and writable mapped vnodes)</a>
<a name="ln7924">			//	and have a simple flag that we could test for here</a>
<a name="ln7925">			vnode = mount-&gt;vnodes.GetNext(vnode);</a>
<a name="ln7926">		}</a>
<a name="ln7927"> </a>
<a name="ln7928">		if (vnode != NULL) {</a>
<a name="ln7929">			// insert marker vnode again</a>
<a name="ln7930">			mount-&gt;vnodes.Insert(mount-&gt;vnodes.GetNext(vnode), &amp;marker);</a>
<a name="ln7931">			marker.SetRemoved(false);</a>
<a name="ln7932">		}</a>
<a name="ln7933"> </a>
<a name="ln7934">		mutex_unlock(&amp;mount-&gt;lock);</a>
<a name="ln7935"> </a>
<a name="ln7936">		if (vnode == NULL)</a>
<a name="ln7937">			break;</a>
<a name="ln7938"> </a>
<a name="ln7939">		vnode = lookup_vnode(mount-&gt;id, vnode-&gt;id);</a>
<a name="ln7940">		if (vnode == NULL || vnode-&gt;IsBusy())</a>
<a name="ln7941">			continue;</a>
<a name="ln7942"> </a>
<a name="ln7943">		if (vnode-&gt;ref_count == 0) {</a>
<a name="ln7944">			// this vnode has been unused before</a>
<a name="ln7945">			vnode_used(vnode);</a>
<a name="ln7946">		}</a>
<a name="ln7947">		inc_vnode_ref_count(vnode);</a>
<a name="ln7948"> </a>
<a name="ln7949">		locker.Unlock();</a>
<a name="ln7950"> </a>
<a name="ln7951">		if (vnode-&gt;cache != NULL &amp;&amp; !vnode-&gt;IsRemoved())</a>
<a name="ln7952">			vnode-&gt;cache-&gt;WriteModified();</a>
<a name="ln7953"> </a>
<a name="ln7954">		put_vnode(vnode);</a>
<a name="ln7955">	}</a>
<a name="ln7956"> </a>
<a name="ln7957">	// Let the file systems do their synchronizing work</a>
<a name="ln7958">	if (HAS_FS_MOUNT_CALL(mount, sync))</a>
<a name="ln7959">		status = FS_MOUNT_CALL_NO_PARAMS(mount, sync);</a>
<a name="ln7960"> </a>
<a name="ln7961">	// Finally, flush the underlying device's write cache (if possible.)</a>
<a name="ln7962">	if (mount-&gt;partition != NULL &amp;&amp; mount-&gt;partition-&gt;Device() != NULL)</a>
<a name="ln7963">		ioctl(mount-&gt;partition-&gt;Device()-&gt;FD(), B_FLUSH_DRIVE_CACHE);</a>
<a name="ln7964"> </a>
<a name="ln7965">	put_mount(mount);</a>
<a name="ln7966">	return status;</a>
<a name="ln7967">}</a>
<a name="ln7968"> </a>
<a name="ln7969"> </a>
<a name="ln7970">static status_t</a>
<a name="ln7971">fs_read_info(dev_t device, struct fs_info* info)</a>
<a name="ln7972">{</a>
<a name="ln7973">	struct fs_mount* mount;</a>
<a name="ln7974">	status_t status = get_mount(device, &amp;mount);</a>
<a name="ln7975">	if (status != B_OK)</a>
<a name="ln7976">		return status;</a>
<a name="ln7977"> </a>
<a name="ln7978">	memset(info, 0, sizeof(struct fs_info));</a>
<a name="ln7979"> </a>
<a name="ln7980">	if (HAS_FS_MOUNT_CALL(mount, read_fs_info))</a>
<a name="ln7981">		status = FS_MOUNT_CALL(mount, read_fs_info, info);</a>
<a name="ln7982"> </a>
<a name="ln7983">	// fill in info the file system doesn't (have to) know about</a>
<a name="ln7984">	if (status == B_OK) {</a>
<a name="ln7985">		info-&gt;dev = mount-&gt;id;</a>
<a name="ln7986">		info-&gt;root = mount-&gt;root_vnode-&gt;id;</a>
<a name="ln7987"> </a>
<a name="ln7988">		fs_volume* volume = mount-&gt;volume;</a>
<a name="ln7989">		while (volume-&gt;super_volume != NULL)</a>
<a name="ln7990">			volume = volume-&gt;super_volume;</a>
<a name="ln7991"> </a>
<a name="ln7992">		strlcpy(info-&gt;fsh_name, volume-&gt;file_system_name,</a>
<a name="ln7993">			sizeof(info-&gt;fsh_name));</a>
<a name="ln7994">		if (mount-&gt;device_name != NULL) {</a>
<a name="ln7995">			strlcpy(info-&gt;device_name, mount-&gt;device_name,</a>
<a name="ln7996">				sizeof(info-&gt;device_name));</a>
<a name="ln7997">		}</a>
<a name="ln7998">	}</a>
<a name="ln7999"> </a>
<a name="ln8000">	// if the call is not supported by the file system, there are still</a>
<a name="ln8001">	// the parts that we filled out ourselves</a>
<a name="ln8002"> </a>
<a name="ln8003">	put_mount(mount);</a>
<a name="ln8004">	return status;</a>
<a name="ln8005">}</a>
<a name="ln8006"> </a>
<a name="ln8007"> </a>
<a name="ln8008">static status_t</a>
<a name="ln8009">fs_write_info(dev_t device, const struct fs_info* info, int mask)</a>
<a name="ln8010">{</a>
<a name="ln8011">	struct fs_mount* mount;</a>
<a name="ln8012">	status_t status = get_mount(device, &amp;mount);</a>
<a name="ln8013">	if (status != B_OK)</a>
<a name="ln8014">		return status;</a>
<a name="ln8015"> </a>
<a name="ln8016">	if (HAS_FS_MOUNT_CALL(mount, write_fs_info))</a>
<a name="ln8017">		status = FS_MOUNT_CALL(mount, write_fs_info, info, mask);</a>
<a name="ln8018">	else</a>
<a name="ln8019">		status = B_READ_ONLY_DEVICE;</a>
<a name="ln8020"> </a>
<a name="ln8021">	put_mount(mount);</a>
<a name="ln8022">	return status;</a>
<a name="ln8023">}</a>
<a name="ln8024"> </a>
<a name="ln8025"> </a>
<a name="ln8026">static dev_t</a>
<a name="ln8027">fs_next_device(int32* _cookie)</a>
<a name="ln8028">{</a>
<a name="ln8029">	struct fs_mount* mount = NULL;</a>
<a name="ln8030">	dev_t device = *_cookie;</a>
<a name="ln8031"> </a>
<a name="ln8032">	mutex_lock(&amp;sMountMutex);</a>
<a name="ln8033"> </a>
<a name="ln8034">	// Since device IDs are assigned sequentially, this algorithm</a>
<a name="ln8035">	// does work good enough. It makes sure that the device list</a>
<a name="ln8036">	// returned is sorted, and that no device is skipped when an</a>
<a name="ln8037">	// already visited device got unmounted.</a>
<a name="ln8038"> </a>
<a name="ln8039">	while (device &lt; sNextMountID) {</a>
<a name="ln8040">		mount = find_mount(device++);</a>
<a name="ln8041">		if (mount != NULL &amp;&amp; mount-&gt;volume-&gt;private_volume != NULL)</a>
<a name="ln8042">			break;</a>
<a name="ln8043">	}</a>
<a name="ln8044"> </a>
<a name="ln8045">	*_cookie = device;</a>
<a name="ln8046"> </a>
<a name="ln8047">	if (mount != NULL)</a>
<a name="ln8048">		device = mount-&gt;id;</a>
<a name="ln8049">	else</a>
<a name="ln8050">		device = B_BAD_VALUE;</a>
<a name="ln8051"> </a>
<a name="ln8052">	mutex_unlock(&amp;sMountMutex);</a>
<a name="ln8053"> </a>
<a name="ln8054">	return device;</a>
<a name="ln8055">}</a>
<a name="ln8056"> </a>
<a name="ln8057"> </a>
<a name="ln8058">ssize_t</a>
<a name="ln8059">fs_read_attr(int fd, const char *attribute, uint32 type, off_t pos,</a>
<a name="ln8060">	void *buffer, size_t readBytes)</a>
<a name="ln8061">{</a>
<a name="ln8062">	int attrFD = attr_open(fd, NULL, attribute, O_RDONLY, true);</a>
<a name="ln8063">	if (attrFD &lt; 0)</a>
<a name="ln8064">		return attrFD;</a>
<a name="ln8065"> </a>
<a name="ln8066">	ssize_t bytesRead = _kern_read(attrFD, pos, buffer, readBytes);</a>
<a name="ln8067"> </a>
<a name="ln8068">	_kern_close(attrFD);</a>
<a name="ln8069"> </a>
<a name="ln8070">	return bytesRead;</a>
<a name="ln8071">}</a>
<a name="ln8072"> </a>
<a name="ln8073"> </a>
<a name="ln8074">static status_t</a>
<a name="ln8075">get_cwd(char* buffer, size_t size, bool kernel)</a>
<a name="ln8076">{</a>
<a name="ln8077">	// Get current working directory from io context</a>
<a name="ln8078">	struct io_context* context = get_current_io_context(kernel);</a>
<a name="ln8079">	status_t status;</a>
<a name="ln8080"> </a>
<a name="ln8081">	FUNCTION((&quot;vfs_get_cwd: buf %p, size %ld\n&quot;, buffer, size));</a>
<a name="ln8082"> </a>
<a name="ln8083">	mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln8084"> </a>
<a name="ln8085">	struct vnode* vnode = context-&gt;cwd;</a>
<a name="ln8086">	if (vnode)</a>
<a name="ln8087">		inc_vnode_ref_count(vnode);</a>
<a name="ln8088"> </a>
<a name="ln8089">	mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln8090"> </a>
<a name="ln8091">	if (vnode) {</a>
<a name="ln8092">		status = dir_vnode_to_path(vnode, buffer, size, kernel);</a>
<a name="ln8093">		put_vnode(vnode);</a>
<a name="ln8094">	} else</a>
<a name="ln8095">		status = B_ERROR;</a>
<a name="ln8096"> </a>
<a name="ln8097">	return status;</a>
<a name="ln8098">}</a>
<a name="ln8099"> </a>
<a name="ln8100"> </a>
<a name="ln8101">static status_t</a>
<a name="ln8102">set_cwd(int fd, char* path, bool kernel)</a>
<a name="ln8103">{</a>
<a name="ln8104">	struct io_context* context;</a>
<a name="ln8105">	struct vnode* vnode = NULL;</a>
<a name="ln8106">	struct vnode* oldDirectory;</a>
<a name="ln8107">	status_t status;</a>
<a name="ln8108"> </a>
<a name="ln8109">	FUNCTION((&quot;set_cwd: path = \'%s\'\n&quot;, path));</a>
<a name="ln8110"> </a>
<a name="ln8111">	// Get vnode for passed path, and bail if it failed</a>
<a name="ln8112">	status = fd_and_path_to_vnode(fd, path, true, &amp;vnode, NULL, kernel);</a>
<a name="ln8113">	if (status &lt; 0)</a>
<a name="ln8114">		return status;</a>
<a name="ln8115"> </a>
<a name="ln8116">	if (!S_ISDIR(vnode-&gt;Type())) {</a>
<a name="ln8117">		// nope, can't cwd to here</a>
<a name="ln8118">		status = B_NOT_A_DIRECTORY;</a>
<a name="ln8119">		goto err;</a>
<a name="ln8120">	}</a>
<a name="ln8121"> </a>
<a name="ln8122">	// We need to have the permission to enter the directory, too</a>
<a name="ln8123">	if (HAS_FS_CALL(vnode, access)) {</a>
<a name="ln8124">		status = FS_CALL(vnode, access, X_OK);</a>
<a name="ln8125">		if (status != B_OK)</a>
<a name="ln8126">			goto err;</a>
<a name="ln8127">	}</a>
<a name="ln8128"> </a>
<a name="ln8129">	// Get current io context and lock</a>
<a name="ln8130">	context = get_current_io_context(kernel);</a>
<a name="ln8131">	mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln8132"> </a>
<a name="ln8133">	// save the old current working directory first</a>
<a name="ln8134">	oldDirectory = context-&gt;cwd;</a>
<a name="ln8135">	context-&gt;cwd = vnode;</a>
<a name="ln8136"> </a>
<a name="ln8137">	mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln8138"> </a>
<a name="ln8139">	if (oldDirectory)</a>
<a name="ln8140">		put_vnode(oldDirectory);</a>
<a name="ln8141"> </a>
<a name="ln8142">	return B_NO_ERROR;</a>
<a name="ln8143"> </a>
<a name="ln8144">err:</a>
<a name="ln8145">	put_vnode(vnode);</a>
<a name="ln8146">	return status;</a>
<a name="ln8147">}</a>
<a name="ln8148"> </a>
<a name="ln8149"> </a>
<a name="ln8150">static status_t</a>
<a name="ln8151">user_copy_name(char* to, const char* from, size_t length)</a>
<a name="ln8152">{</a>
<a name="ln8153">	ssize_t len = user_strlcpy(to, from, length);</a>
<a name="ln8154">	if (len &lt; 0)</a>
<a name="ln8155">		return len;</a>
<a name="ln8156">	if (len &gt;= (ssize_t)length)</a>
<a name="ln8157">		return B_NAME_TOO_LONG;</a>
<a name="ln8158">	return B_OK;</a>
<a name="ln8159">}</a>
<a name="ln8160"> </a>
<a name="ln8161"> </a>
<a name="ln8162">//	#pragma mark - kernel mirrored syscalls</a>
<a name="ln8163"> </a>
<a name="ln8164"> </a>
<a name="ln8165">dev_t</a>
<a name="ln8166">_kern_mount(const char* path, const char* device, const char* fsName,</a>
<a name="ln8167">	uint32 flags, const char* args, size_t argsLength)</a>
<a name="ln8168">{</a>
<a name="ln8169">	KPath pathBuffer(path, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8170">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8171">		return B_NO_MEMORY;</a>
<a name="ln8172"> </a>
<a name="ln8173">	return fs_mount(pathBuffer.LockBuffer(), device, fsName, flags, args, true);</a>
<a name="ln8174">}</a>
<a name="ln8175"> </a>
<a name="ln8176"> </a>
<a name="ln8177">status_t</a>
<a name="ln8178">_kern_unmount(const char* path, uint32 flags)</a>
<a name="ln8179">{</a>
<a name="ln8180">	KPath pathBuffer(path, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8181">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8182">		return B_NO_MEMORY;</a>
<a name="ln8183"> </a>
<a name="ln8184">	return fs_unmount(pathBuffer.LockBuffer(), -1, flags, true);</a>
<a name="ln8185">}</a>
<a name="ln8186"> </a>
<a name="ln8187"> </a>
<a name="ln8188">status_t</a>
<a name="ln8189">_kern_read_fs_info(dev_t device, struct fs_info* info)</a>
<a name="ln8190">{</a>
<a name="ln8191">	if (info == NULL)</a>
<a name="ln8192">		return B_BAD_VALUE;</a>
<a name="ln8193"> </a>
<a name="ln8194">	return fs_read_info(device, info);</a>
<a name="ln8195">}</a>
<a name="ln8196"> </a>
<a name="ln8197"> </a>
<a name="ln8198">status_t</a>
<a name="ln8199">_kern_write_fs_info(dev_t device, const struct fs_info* info, int mask)</a>
<a name="ln8200">{</a>
<a name="ln8201">	if (info == NULL)</a>
<a name="ln8202">		return B_BAD_VALUE;</a>
<a name="ln8203"> </a>
<a name="ln8204">	return fs_write_info(device, info, mask);</a>
<a name="ln8205">}</a>
<a name="ln8206"> </a>
<a name="ln8207"> </a>
<a name="ln8208">status_t</a>
<a name="ln8209">_kern_sync(void)</a>
<a name="ln8210">{</a>
<a name="ln8211">	// Note: _kern_sync() is also called from _user_sync()</a>
<a name="ln8212">	int32 cookie = 0;</a>
<a name="ln8213">	dev_t device;</a>
<a name="ln8214">	while ((device = next_dev(&amp;cookie)) &gt;= 0) {</a>
<a name="ln8215">		status_t status = fs_sync(device);</a>
<a name="ln8216">		if (status != B_OK &amp;&amp; status != B_BAD_VALUE) {</a>
<a name="ln8217">			dprintf(&quot;sync: device %&quot; B_PRIdDEV &quot; couldn't sync: %s\n&quot;, device,</a>
<a name="ln8218">				strerror(status));</a>
<a name="ln8219">		}</a>
<a name="ln8220">	}</a>
<a name="ln8221"> </a>
<a name="ln8222">	return B_OK;</a>
<a name="ln8223">}</a>
<a name="ln8224"> </a>
<a name="ln8225"> </a>
<a name="ln8226">dev_t</a>
<a name="ln8227">_kern_next_device(int32* _cookie)</a>
<a name="ln8228">{</a>
<a name="ln8229">	return fs_next_device(_cookie);</a>
<a name="ln8230">}</a>
<a name="ln8231"> </a>
<a name="ln8232"> </a>
<a name="ln8233">status_t</a>
<a name="ln8234">_kern_get_next_fd_info(team_id teamID, uint32* _cookie, fd_info* info,</a>
<a name="ln8235">	size_t infoSize)</a>
<a name="ln8236">{</a>
<a name="ln8237">	if (infoSize != sizeof(fd_info))</a>
<a name="ln8238">		return B_BAD_VALUE;</a>
<a name="ln8239"> </a>
<a name="ln8240">	// get the team</a>
<a name="ln8241">	Team* team = Team::Get(teamID);</a>
<a name="ln8242">	if (team == NULL)</a>
<a name="ln8243">		return B_BAD_TEAM_ID;</a>
<a name="ln8244">	BReference&lt;Team&gt; teamReference(team, true);</a>
<a name="ln8245"> </a>
<a name="ln8246">	// now that we have a team reference, its I/O context won't go away</a>
<a name="ln8247">	io_context* context = team-&gt;io_context;</a>
<a name="ln8248">	MutexLocker contextLocker(context-&gt;io_mutex);</a>
<a name="ln8249"> </a>
<a name="ln8250">	uint32 slot = *_cookie;</a>
<a name="ln8251"> </a>
<a name="ln8252">	struct file_descriptor* descriptor;</a>
<a name="ln8253">	while (slot &lt; context-&gt;table_size</a>
<a name="ln8254">		&amp;&amp; (descriptor = context-&gt;fds[slot]) == NULL) {</a>
<a name="ln8255">		slot++;</a>
<a name="ln8256">	}</a>
<a name="ln8257"> </a>
<a name="ln8258">	if (slot &gt;= context-&gt;table_size)</a>
<a name="ln8259">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln8260"> </a>
<a name="ln8261">	info-&gt;number = slot;</a>
<a name="ln8262">	info-&gt;open_mode = descriptor-&gt;open_mode;</a>
<a name="ln8263"> </a>
<a name="ln8264">	struct vnode* vnode = fd_vnode(descriptor);</a>
<a name="ln8265">	if (vnode != NULL) {</a>
<a name="ln8266">		info-&gt;device = vnode-&gt;device;</a>
<a name="ln8267">		info-&gt;node = vnode-&gt;id;</a>
<a name="ln8268">	} else if (descriptor-&gt;u.mount != NULL) {</a>
<a name="ln8269">		info-&gt;device = descriptor-&gt;u.mount-&gt;id;</a>
<a name="ln8270">		info-&gt;node = -1;</a>
<a name="ln8271">	}</a>
<a name="ln8272"> </a>
<a name="ln8273">	*_cookie = slot + 1;</a>
<a name="ln8274">	return B_OK;</a>
<a name="ln8275">}</a>
<a name="ln8276"> </a>
<a name="ln8277"> </a>
<a name="ln8278">int</a>
<a name="ln8279">_kern_open_entry_ref(dev_t device, ino_t inode, const char* name, int openMode,</a>
<a name="ln8280">	int perms)</a>
<a name="ln8281">{</a>
<a name="ln8282">	if ((openMode &amp; O_CREAT) != 0) {</a>
<a name="ln8283">		return file_create_entry_ref(device, inode, name, openMode, perms,</a>
<a name="ln8284">			true);</a>
<a name="ln8285">	}</a>
<a name="ln8286"> </a>
<a name="ln8287">	return file_open_entry_ref(device, inode, name, openMode, true);</a>
<a name="ln8288">}</a>
<a name="ln8289"> </a>
<a name="ln8290"> </a>
<a name="ln8291">/*!	\brief Opens a node specified by a FD + path pair.</a>
<a name="ln8292"> </a>
<a name="ln8293">	At least one of \a fd and \a path must be specified.</a>
<a name="ln8294">	If only \a fd is given, the function opens the node identified by this</a>
<a name="ln8295">	FD. If only a path is given, this path is opened. If both are given and</a>
<a name="ln8296">	the path is absolute, \a fd is ignored; a relative path is reckoned off</a>
<a name="ln8297">	of the directory (!) identified by \a fd.</a>
<a name="ln8298"> </a>
<a name="ln8299">	\param fd The FD. May be &lt; 0.</a>
<a name="ln8300">	\param path The absolute or relative path. May be \c NULL.</a>
<a name="ln8301">	\param openMode The open mode.</a>
<a name="ln8302">	\return A FD referring to the newly opened node, or an error code,</a>
<a name="ln8303">			if an error occurs.</a>
<a name="ln8304">*/</a>
<a name="ln8305">int</a>
<a name="ln8306">_kern_open(int fd, const char* path, int openMode, int perms)</a>
<a name="ln8307">{</a>
<a name="ln8308">	KPath pathBuffer(path, KPath::LAZY_ALLOC, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8309">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8310">		return B_NO_MEMORY;</a>
<a name="ln8311"> </a>
<a name="ln8312">	if ((openMode &amp; O_CREAT) != 0)</a>
<a name="ln8313">		return file_create(fd, pathBuffer.LockBuffer(), openMode, perms, true);</a>
<a name="ln8314"> </a>
<a name="ln8315">	return file_open(fd, pathBuffer.LockBuffer(), openMode, true);</a>
<a name="ln8316">}</a>
<a name="ln8317"> </a>
<a name="ln8318"> </a>
<a name="ln8319">/*!	\brief Opens a directory specified by entry_ref or node_ref.</a>
<a name="ln8320"> </a>
<a name="ln8321">	The supplied name may be \c NULL, in which case directory identified</a>
<a name="ln8322">	by \a device and \a inode will be opened. Otherwise \a device and</a>
<a name="ln8323">	\a inode identify the parent directory of the directory to be opened</a>
<a name="ln8324">	and \a name its entry name.</a>
<a name="ln8325"> </a>
<a name="ln8326">	\param device If \a name is specified the ID of the device the parent</a>
<a name="ln8327">		   directory of the directory to be opened resides on, otherwise</a>
<a name="ln8328">		   the device of the directory itself.</a>
<a name="ln8329">	\param inode If \a name is specified the node ID of the parent</a>
<a name="ln8330">		   directory of the directory to be opened, otherwise node ID of the</a>
<a name="ln8331">		   directory itself.</a>
<a name="ln8332">	\param name The entry name of the directory to be opened. If \c NULL,</a>
<a name="ln8333">		   the \a device + \a inode pair identify the node to be opened.</a>
<a name="ln8334">	\return The FD of the newly opened directory or an error code, if</a>
<a name="ln8335">			something went wrong.</a>
<a name="ln8336">*/</a>
<a name="ln8337">int</a>
<a name="ln8338">_kern_open_dir_entry_ref(dev_t device, ino_t inode, const char* name)</a>
<a name="ln8339">{</a>
<a name="ln8340">	return dir_open_entry_ref(device, inode, name, true);</a>
<a name="ln8341">}</a>
<a name="ln8342"> </a>
<a name="ln8343"> </a>
<a name="ln8344">/*!	\brief Opens a directory specified by a FD + path pair.</a>
<a name="ln8345"> </a>
<a name="ln8346">	At least one of \a fd and \a path must be specified.</a>
<a name="ln8347">	If only \a fd is given, the function opens the directory identified by this</a>
<a name="ln8348">	FD. If only a path is given, this path is opened. If both are given and</a>
<a name="ln8349">	the path is absolute, \a fd is ignored; a relative path is reckoned off</a>
<a name="ln8350">	of the directory (!) identified by \a fd.</a>
<a name="ln8351"> </a>
<a name="ln8352">	\param fd The FD. May be &lt; 0.</a>
<a name="ln8353">	\param path The absolute or relative path. May be \c NULL.</a>
<a name="ln8354">	\return A FD referring to the newly opened directory, or an error code,</a>
<a name="ln8355">			if an error occurs.</a>
<a name="ln8356">*/</a>
<a name="ln8357">int</a>
<a name="ln8358">_kern_open_dir(int fd, const char* path)</a>
<a name="ln8359">{</a>
<a name="ln8360">	KPath pathBuffer(path, KPath::LAZY_ALLOC, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8361">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8362">		return B_NO_MEMORY;</a>
<a name="ln8363"> </a>
<a name="ln8364">	return dir_open(fd, pathBuffer.LockBuffer(), true);</a>
<a name="ln8365">}</a>
<a name="ln8366"> </a>
<a name="ln8367"> </a>
<a name="ln8368">status_t</a>
<a name="ln8369">_kern_fcntl(int fd, int op, size_t argument)</a>
<a name="ln8370">{</a>
<a name="ln8371">	return common_fcntl(fd, op, argument, true);</a>
<a name="ln8372">}</a>
<a name="ln8373"> </a>
<a name="ln8374"> </a>
<a name="ln8375">status_t</a>
<a name="ln8376">_kern_fsync(int fd)</a>
<a name="ln8377">{</a>
<a name="ln8378">	return common_sync(fd, true);</a>
<a name="ln8379">}</a>
<a name="ln8380"> </a>
<a name="ln8381"> </a>
<a name="ln8382">status_t</a>
<a name="ln8383">_kern_lock_node(int fd)</a>
<a name="ln8384">{</a>
<a name="ln8385">	return common_lock_node(fd, true);</a>
<a name="ln8386">}</a>
<a name="ln8387"> </a>
<a name="ln8388"> </a>
<a name="ln8389">status_t</a>
<a name="ln8390">_kern_unlock_node(int fd)</a>
<a name="ln8391">{</a>
<a name="ln8392">	return common_unlock_node(fd, true);</a>
<a name="ln8393">}</a>
<a name="ln8394"> </a>
<a name="ln8395"> </a>
<a name="ln8396">status_t</a>
<a name="ln8397">_kern_create_dir_entry_ref(dev_t device, ino_t inode, const char* name,</a>
<a name="ln8398">	int perms)</a>
<a name="ln8399">{</a>
<a name="ln8400">	return dir_create_entry_ref(device, inode, name, perms, true);</a>
<a name="ln8401">}</a>
<a name="ln8402"> </a>
<a name="ln8403"> </a>
<a name="ln8404">/*!	\brief Creates a directory specified by a FD + path pair.</a>
<a name="ln8405"> </a>
<a name="ln8406">	\a path must always be specified (it contains the name of the new directory</a>
<a name="ln8407">	at least). If only a path is given, this path identifies the location at</a>
<a name="ln8408">	which the directory shall be created. If both \a fd and \a path are given</a>
<a name="ln8409">	and the path is absolute, \a fd is ignored; a relative path is reckoned off</a>
<a name="ln8410">	of the directory (!) identified by \a fd.</a>
<a name="ln8411"> </a>
<a name="ln8412">	\param fd The FD. May be &lt; 0.</a>
<a name="ln8413">	\param path The absolute or relative path. Must not be \c NULL.</a>
<a name="ln8414">	\param perms The access permissions the new directory shall have.</a>
<a name="ln8415">	\return \c B_OK, if the directory has been created successfully, another</a>
<a name="ln8416">			error code otherwise.</a>
<a name="ln8417">*/</a>
<a name="ln8418">status_t</a>
<a name="ln8419">_kern_create_dir(int fd, const char* path, int perms)</a>
<a name="ln8420">{</a>
<a name="ln8421">	KPath pathBuffer(path, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8422">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8423">		return B_NO_MEMORY;</a>
<a name="ln8424"> </a>
<a name="ln8425">	return dir_create(fd, pathBuffer.LockBuffer(), perms, true);</a>
<a name="ln8426">}</a>
<a name="ln8427"> </a>
<a name="ln8428"> </a>
<a name="ln8429">status_t</a>
<a name="ln8430">_kern_remove_dir(int fd, const char* path)</a>
<a name="ln8431">{</a>
<a name="ln8432">	KPath pathBuffer(path, KPath::LAZY_ALLOC, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8433">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8434">		return B_NO_MEMORY;</a>
<a name="ln8435"> </a>
<a name="ln8436">	return dir_remove(fd, pathBuffer.LockBuffer(), true);</a>
<a name="ln8437">}</a>
<a name="ln8438"> </a>
<a name="ln8439"> </a>
<a name="ln8440">/*!	\brief Reads the contents of a symlink referred to by a FD + path pair.</a>
<a name="ln8441"> </a>
<a name="ln8442">	At least one of \a fd and \a path must be specified.</a>
<a name="ln8443">	If only \a fd is given, the function the symlink to be read is the node</a>
<a name="ln8444">	identified by this FD. If only a path is given, this path identifies the</a>
<a name="ln8445">	symlink to be read. If both are given and the path is absolute, \a fd is</a>
<a name="ln8446">	ignored; a relative path is reckoned off of the directory (!) identified</a>
<a name="ln8447">	by \a fd.</a>
<a name="ln8448">	If this function fails with B_BUFFER_OVERFLOW, the \a _bufferSize pointer</a>
<a name="ln8449">	will still be updated to reflect the required buffer size.</a>
<a name="ln8450"> </a>
<a name="ln8451">	\param fd The FD. May be &lt; 0.</a>
<a name="ln8452">	\param path The absolute or relative path. May be \c NULL.</a>
<a name="ln8453">	\param buffer The buffer into which the contents of the symlink shall be</a>
<a name="ln8454">		   written.</a>
<a name="ln8455">	\param _bufferSize A pointer to the size of the supplied buffer.</a>
<a name="ln8456">	\return The length of the link on success or an appropriate error code</a>
<a name="ln8457">*/</a>
<a name="ln8458">status_t</a>
<a name="ln8459">_kern_read_link(int fd, const char* path, char* buffer, size_t* _bufferSize)</a>
<a name="ln8460">{</a>
<a name="ln8461">	KPath pathBuffer(path, KPath::LAZY_ALLOC, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8462">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8463">		return B_NO_MEMORY;</a>
<a name="ln8464"> </a>
<a name="ln8465">	return common_read_link(fd, pathBuffer.LockBuffer(),</a>
<a name="ln8466">		buffer, _bufferSize, true);</a>
<a name="ln8467">}</a>
<a name="ln8468"> </a>
<a name="ln8469"> </a>
<a name="ln8470">/*!	\brief Creates a symlink specified by a FD + path pair.</a>
<a name="ln8471"> </a>
<a name="ln8472">	\a path must always be specified (it contains the name of the new symlink</a>
<a name="ln8473">	at least). If only a path is given, this path identifies the location at</a>
<a name="ln8474">	which the symlink shall be created. If both \a fd and \a path are given and</a>
<a name="ln8475">	the path is absolute, \a fd is ignored; a relative path is reckoned off</a>
<a name="ln8476">	of the directory (!) identified by \a fd.</a>
<a name="ln8477"> </a>
<a name="ln8478">	\param fd The FD. May be &lt; 0.</a>
<a name="ln8479">	\param toPath The absolute or relative path. Must not be \c NULL.</a>
<a name="ln8480">	\param mode The access permissions the new symlink shall have.</a>
<a name="ln8481">	\return \c B_OK, if the symlink has been created successfully, another</a>
<a name="ln8482">			error code otherwise.</a>
<a name="ln8483">*/</a>
<a name="ln8484">status_t</a>
<a name="ln8485">_kern_create_symlink(int fd, const char* path, const char* toPath, int mode)</a>
<a name="ln8486">{</a>
<a name="ln8487">	KPath pathBuffer(path, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8488">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8489">		return B_NO_MEMORY;</a>
<a name="ln8490"> </a>
<a name="ln8491">	return common_create_symlink(fd, pathBuffer.LockBuffer(),</a>
<a name="ln8492">		toPath, mode, true);</a>
<a name="ln8493">}</a>
<a name="ln8494"> </a>
<a name="ln8495"> </a>
<a name="ln8496">status_t</a>
<a name="ln8497">_kern_create_link(int pathFD, const char* path, int toFD, const char* toPath,</a>
<a name="ln8498">	bool traverseLeafLink)</a>
<a name="ln8499">{</a>
<a name="ln8500">	KPath pathBuffer(path, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8501">	KPath toPathBuffer(toPath, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8502">	if (pathBuffer.InitCheck() != B_OK || toPathBuffer.InitCheck() != B_OK)</a>
<a name="ln8503">		return B_NO_MEMORY;</a>
<a name="ln8504"> </a>
<a name="ln8505">	return common_create_link(pathFD, pathBuffer.LockBuffer(), toFD,</a>
<a name="ln8506">		toPathBuffer.LockBuffer(), traverseLeafLink, true);</a>
<a name="ln8507">}</a>
<a name="ln8508"> </a>
<a name="ln8509"> </a>
<a name="ln8510">/*!	\brief Removes an entry specified by a FD + path pair from its directory.</a>
<a name="ln8511"> </a>
<a name="ln8512">	\a path must always be specified (it contains at least the name of the entry</a>
<a name="ln8513">	to be deleted). If only a path is given, this path identifies the entry</a>
<a name="ln8514">	directly. If both \a fd and \a path are given and the path is absolute,</a>
<a name="ln8515">	\a fd is ignored; a relative path is reckoned off of the directory (!)</a>
<a name="ln8516">	identified by \a fd.</a>
<a name="ln8517"> </a>
<a name="ln8518">	\param fd The FD. May be &lt; 0.</a>
<a name="ln8519">	\param path The absolute or relative path. Must not be \c NULL.</a>
<a name="ln8520">	\return \c B_OK, if the entry has been removed successfully, another</a>
<a name="ln8521">			error code otherwise.</a>
<a name="ln8522">*/</a>
<a name="ln8523">status_t</a>
<a name="ln8524">_kern_unlink(int fd, const char* path)</a>
<a name="ln8525">{</a>
<a name="ln8526">	KPath pathBuffer(path, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8527">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8528">		return B_NO_MEMORY;</a>
<a name="ln8529"> </a>
<a name="ln8530">	return common_unlink(fd, pathBuffer.LockBuffer(), true);</a>
<a name="ln8531">}</a>
<a name="ln8532"> </a>
<a name="ln8533"> </a>
<a name="ln8534">/*!	\brief Moves an entry specified by a FD + path pair to a an entry specified</a>
<a name="ln8535">		   by another FD + path pair.</a>
<a name="ln8536"> </a>
<a name="ln8537">	\a oldPath and \a newPath must always be specified (they contain at least</a>
<a name="ln8538">	the name of the entry). If only a path is given, this path identifies the</a>
<a name="ln8539">	entry directly. If both a FD and a path are given and the path is absolute,</a>
<a name="ln8540">	the FD is ignored; a relative path is reckoned off of the directory (!)</a>
<a name="ln8541">	identified by the respective FD.</a>
<a name="ln8542"> </a>
<a name="ln8543">	\param oldFD The FD of the old location. May be &lt; 0.</a>
<a name="ln8544">	\param oldPath The absolute or relative path of the old location. Must not</a>
<a name="ln8545">		   be \c NULL.</a>
<a name="ln8546">	\param newFD The FD of the new location. May be &lt; 0.</a>
<a name="ln8547">	\param newPath The absolute or relative path of the new location. Must not</a>
<a name="ln8548">		   be \c NULL.</a>
<a name="ln8549">	\return \c B_OK, if the entry has been moved successfully, another</a>
<a name="ln8550">			error code otherwise.</a>
<a name="ln8551">*/</a>
<a name="ln8552">status_t</a>
<a name="ln8553">_kern_rename(int oldFD, const char* oldPath, int newFD, const char* newPath)</a>
<a name="ln8554">{</a>
<a name="ln8555">	KPath oldPathBuffer(oldPath, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8556">	KPath newPathBuffer(newPath, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8557">	if (oldPathBuffer.InitCheck() != B_OK || newPathBuffer.InitCheck() != B_OK)</a>
<a name="ln8558">		return B_NO_MEMORY;</a>
<a name="ln8559"> </a>
<a name="ln8560">	return common_rename(oldFD, oldPathBuffer.LockBuffer(),</a>
<a name="ln8561">		newFD, newPathBuffer.LockBuffer(), true);</a>
<a name="ln8562">}</a>
<a name="ln8563"> </a>
<a name="ln8564"> </a>
<a name="ln8565">status_t</a>
<a name="ln8566">_kern_access(int fd, const char* path, int mode, bool effectiveUserGroup)</a>
<a name="ln8567">{</a>
<a name="ln8568">	KPath pathBuffer(path, KPath::LAZY_ALLOC, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8569">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8570">		return B_NO_MEMORY;</a>
<a name="ln8571"> </a>
<a name="ln8572">	return common_access(fd, pathBuffer.LockBuffer(), mode, effectiveUserGroup,</a>
<a name="ln8573">		true);</a>
<a name="ln8574">}</a>
<a name="ln8575"> </a>
<a name="ln8576"> </a>
<a name="ln8577">/*!	\brief Reads stat data of an entity specified by a FD + path pair.</a>
<a name="ln8578"> </a>
<a name="ln8579">	If only \a fd is given, the stat operation associated with the type</a>
<a name="ln8580">	of the FD (node, attr, attr dir etc.) is performed. If only \a path is</a>
<a name="ln8581">	given, this path identifies the entry for whose node to retrieve the</a>
<a name="ln8582">	stat data. If both \a fd and \a path are given and the path is absolute,</a>
<a name="ln8583">	\a fd is ignored; a relative path is reckoned off of the directory (!)</a>
<a name="ln8584">	identified by \a fd and specifies the entry whose stat data shall be</a>
<a name="ln8585">	retrieved.</a>
<a name="ln8586"> </a>
<a name="ln8587">	\param fd The FD. May be &lt; 0.</a>
<a name="ln8588">	\param path The absolute or relative path. Must not be \c NULL.</a>
<a name="ln8589">	\param traverseLeafLink If \a path is given, \c true specifies that the</a>
<a name="ln8590">		   function shall not stick to symlinks, but traverse them.</a>
<a name="ln8591">	\param stat The buffer the stat data shall be written into.</a>
<a name="ln8592">	\param statSize The size of the supplied stat buffer.</a>
<a name="ln8593">	\return \c B_OK, if the the stat data have been read successfully, another</a>
<a name="ln8594">			error code otherwise.</a>
<a name="ln8595">*/</a>
<a name="ln8596">status_t</a>
<a name="ln8597">_kern_read_stat(int fd, const char* path, bool traverseLeafLink,</a>
<a name="ln8598">	struct stat* stat, size_t statSize)</a>
<a name="ln8599">{</a>
<a name="ln8600">	struct stat completeStat;</a>
<a name="ln8601">	struct stat* originalStat = NULL;</a>
<a name="ln8602">	status_t status;</a>
<a name="ln8603"> </a>
<a name="ln8604">	if (statSize &gt; sizeof(struct stat))</a>
<a name="ln8605">		return B_BAD_VALUE;</a>
<a name="ln8606"> </a>
<a name="ln8607">	// this supports different stat extensions</a>
<a name="ln8608">	if (statSize &lt; sizeof(struct stat)) {</a>
<a name="ln8609">		originalStat = stat;</a>
<a name="ln8610">		stat = &amp;completeStat;</a>
<a name="ln8611">	}</a>
<a name="ln8612"> </a>
<a name="ln8613">	status = vfs_read_stat(fd, path, traverseLeafLink, stat, true);</a>
<a name="ln8614"> </a>
<a name="ln8615">	if (status == B_OK &amp;&amp; originalStat != NULL)</a>
<a name="ln8616">		memcpy(originalStat, stat, statSize);</a>
<a name="ln8617"> </a>
<a name="ln8618">	return status;</a>
<a name="ln8619">}</a>
<a name="ln8620"> </a>
<a name="ln8621"> </a>
<a name="ln8622">/*!	\brief Writes stat data of an entity specified by a FD + path pair.</a>
<a name="ln8623"> </a>
<a name="ln8624">	If only \a fd is given, the stat operation associated with the type</a>
<a name="ln8625">	of the FD (node, attr, attr dir etc.) is performed. If only \a path is</a>
<a name="ln8626">	given, this path identifies the entry for whose node to write the</a>
<a name="ln8627">	stat data. If both \a fd and \a path are given and the path is absolute,</a>
<a name="ln8628">	\a fd is ignored; a relative path is reckoned off of the directory (!)</a>
<a name="ln8629">	identified by \a fd and specifies the entry whose stat data shall be</a>
<a name="ln8630">	written.</a>
<a name="ln8631"> </a>
<a name="ln8632">	\param fd The FD. May be &lt; 0.</a>
<a name="ln8633">	\param path The absolute or relative path. May be \c NULL.</a>
<a name="ln8634">	\param traverseLeafLink If \a path is given, \c true specifies that the</a>
<a name="ln8635">		   function shall not stick to symlinks, but traverse them.</a>
<a name="ln8636">	\param stat The buffer containing the stat data to be written.</a>
<a name="ln8637">	\param statSize The size of the supplied stat buffer.</a>
<a name="ln8638">	\param statMask A mask specifying which parts of the stat data shall be</a>
<a name="ln8639">		   written.</a>
<a name="ln8640">	\return \c B_OK, if the the stat data have been written successfully,</a>
<a name="ln8641">			another error code otherwise.</a>
<a name="ln8642">*/</a>
<a name="ln8643">status_t</a>
<a name="ln8644">_kern_write_stat(int fd, const char* path, bool traverseLeafLink,</a>
<a name="ln8645">	const struct stat* stat, size_t statSize, int statMask)</a>
<a name="ln8646">{</a>
<a name="ln8647">	struct stat completeStat;</a>
<a name="ln8648"> </a>
<a name="ln8649">	if (statSize &gt; sizeof(struct stat))</a>
<a name="ln8650">		return B_BAD_VALUE;</a>
<a name="ln8651"> </a>
<a name="ln8652">	// this supports different stat extensions</a>
<a name="ln8653">	if (statSize &lt; sizeof(struct stat)) {</a>
<a name="ln8654">		memset((uint8*)&amp;completeStat + statSize, 0,</a>
<a name="ln8655">			sizeof(struct stat) - statSize);</a>
<a name="ln8656">		memcpy(&amp;completeStat, stat, statSize);</a>
<a name="ln8657">		stat = &amp;completeStat;</a>
<a name="ln8658">	}</a>
<a name="ln8659"> </a>
<a name="ln8660">	status_t status;</a>
<a name="ln8661"> </a>
<a name="ln8662">	if (path != NULL) {</a>
<a name="ln8663">		// path given: write the stat of the node referred to by (fd, path)</a>
<a name="ln8664">		KPath pathBuffer(path, KPath::DEFAULT, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8665">		if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8666">			return B_NO_MEMORY;</a>
<a name="ln8667"> </a>
<a name="ln8668">		status = common_path_write_stat(fd, pathBuffer.LockBuffer(),</a>
<a name="ln8669">			traverseLeafLink, stat, statMask, true);</a>
<a name="ln8670">	} else {</a>
<a name="ln8671">		// no path given: get the FD and use the FD operation</a>
<a name="ln8672">		struct file_descriptor* descriptor</a>
<a name="ln8673">			= get_fd(get_current_io_context(true), fd);</a>
<a name="ln8674">		if (descriptor == NULL)</a>
<a name="ln8675">			return B_FILE_ERROR;</a>
<a name="ln8676"> </a>
<a name="ln8677">		if (descriptor-&gt;ops-&gt;fd_write_stat)</a>
<a name="ln8678">			status = descriptor-&gt;ops-&gt;fd_write_stat(descriptor, stat, statMask);</a>
<a name="ln8679">		else</a>
<a name="ln8680">			status = B_UNSUPPORTED;</a>
<a name="ln8681"> </a>
<a name="ln8682">		put_fd(descriptor);</a>
<a name="ln8683">	}</a>
<a name="ln8684"> </a>
<a name="ln8685">	return status;</a>
<a name="ln8686">}</a>
<a name="ln8687"> </a>
<a name="ln8688"> </a>
<a name="ln8689">int</a>
<a name="ln8690">_kern_open_attr_dir(int fd, const char* path, bool traverseLeafLink)</a>
<a name="ln8691">{</a>
<a name="ln8692">	KPath pathBuffer(path, KPath::LAZY_ALLOC, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8693">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8694">		return B_NO_MEMORY;</a>
<a name="ln8695"> </a>
<a name="ln8696">	return attr_dir_open(fd, pathBuffer.LockBuffer(), traverseLeafLink, true);</a>
<a name="ln8697">}</a>
<a name="ln8698"> </a>
<a name="ln8699"> </a>
<a name="ln8700">int</a>
<a name="ln8701">_kern_open_attr(int fd, const char* path, const char* name, uint32 type,</a>
<a name="ln8702">	int openMode)</a>
<a name="ln8703">{</a>
<a name="ln8704">	KPath pathBuffer(path, KPath::LAZY_ALLOC, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8705">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8706">		return B_NO_MEMORY;</a>
<a name="ln8707"> </a>
<a name="ln8708">	if ((openMode &amp; O_CREAT) != 0) {</a>
<a name="ln8709">		return attr_create(fd, pathBuffer.LockBuffer(), name, type, openMode,</a>
<a name="ln8710">			true);</a>
<a name="ln8711">	}</a>
<a name="ln8712"> </a>
<a name="ln8713">	return attr_open(fd, pathBuffer.LockBuffer(), name, openMode, true);</a>
<a name="ln8714">}</a>
<a name="ln8715"> </a>
<a name="ln8716"> </a>
<a name="ln8717">status_t</a>
<a name="ln8718">_kern_remove_attr(int fd, const char* name)</a>
<a name="ln8719">{</a>
<a name="ln8720">	return attr_remove(fd, name, true);</a>
<a name="ln8721">}</a>
<a name="ln8722"> </a>
<a name="ln8723"> </a>
<a name="ln8724">status_t</a>
<a name="ln8725">_kern_rename_attr(int fromFile, const char* fromName, int toFile,</a>
<a name="ln8726">	const char* toName)</a>
<a name="ln8727">{</a>
<a name="ln8728">	return attr_rename(fromFile, fromName, toFile, toName, true);</a>
<a name="ln8729">}</a>
<a name="ln8730"> </a>
<a name="ln8731"> </a>
<a name="ln8732">int</a>
<a name="ln8733">_kern_open_index_dir(dev_t device)</a>
<a name="ln8734">{</a>
<a name="ln8735">	return index_dir_open(device, true);</a>
<a name="ln8736">}</a>
<a name="ln8737"> </a>
<a name="ln8738"> </a>
<a name="ln8739">status_t</a>
<a name="ln8740">_kern_create_index(dev_t device, const char* name, uint32 type, uint32 flags)</a>
<a name="ln8741">{</a>
<a name="ln8742">	return index_create(device, name, type, flags, true);</a>
<a name="ln8743">}</a>
<a name="ln8744"> </a>
<a name="ln8745"> </a>
<a name="ln8746">status_t</a>
<a name="ln8747">_kern_read_index_stat(dev_t device, const char* name, struct stat* stat)</a>
<a name="ln8748">{</a>
<a name="ln8749">	return index_name_read_stat(device, name, stat, true);</a>
<a name="ln8750">}</a>
<a name="ln8751"> </a>
<a name="ln8752"> </a>
<a name="ln8753">status_t</a>
<a name="ln8754">_kern_remove_index(dev_t device, const char* name)</a>
<a name="ln8755">{</a>
<a name="ln8756">	return index_remove(device, name, true);</a>
<a name="ln8757">}</a>
<a name="ln8758"> </a>
<a name="ln8759"> </a>
<a name="ln8760">status_t</a>
<a name="ln8761">_kern_getcwd(char* buffer, size_t size)</a>
<a name="ln8762">{</a>
<a name="ln8763">	TRACE((&quot;_kern_getcwd: buf %p, %ld\n&quot;, buffer, size));</a>
<a name="ln8764"> </a>
<a name="ln8765">	// Call vfs to get current working directory</a>
<a name="ln8766">	return get_cwd(buffer, size, true);</a>
<a name="ln8767">}</a>
<a name="ln8768"> </a>
<a name="ln8769"> </a>
<a name="ln8770">status_t</a>
<a name="ln8771">_kern_setcwd(int fd, const char* path)</a>
<a name="ln8772">{</a>
<a name="ln8773">	KPath pathBuffer(path, KPath::LAZY_ALLOC, B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8774">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8775">		return B_NO_MEMORY;</a>
<a name="ln8776"> </a>
<a name="ln8777">	return set_cwd(fd, pathBuffer.LockBuffer(), true);</a>
<a name="ln8778">}</a>
<a name="ln8779"> </a>
<a name="ln8780"> </a>
<a name="ln8781">//	#pragma mark - userland syscalls</a>
<a name="ln8782"> </a>
<a name="ln8783"> </a>
<a name="ln8784">dev_t</a>
<a name="ln8785">_user_mount(const char* userPath, const char* userDevice,</a>
<a name="ln8786">	const char* userFileSystem, uint32 flags, const char* userArgs,</a>
<a name="ln8787">	size_t argsLength)</a>
<a name="ln8788">{</a>
<a name="ln8789">	char fileSystem[B_FILE_NAME_LENGTH];</a>
<a name="ln8790">	KPath path, device;</a>
<a name="ln8791">	char* args = NULL;</a>
<a name="ln8792">	status_t status;</a>
<a name="ln8793"> </a>
<a name="ln8794">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln8795">		return B_BAD_ADDRESS;</a>
<a name="ln8796"> </a>
<a name="ln8797">	if (path.InitCheck() != B_OK || device.InitCheck() != B_OK)</a>
<a name="ln8798">		return B_NO_MEMORY;</a>
<a name="ln8799"> </a>
<a name="ln8800">	status = user_copy_name(path.LockBuffer(), userPath,</a>
<a name="ln8801">		B_PATH_NAME_LENGTH);</a>
<a name="ln8802">	if (status != B_OK)</a>
<a name="ln8803">		return status;</a>
<a name="ln8804"> </a>
<a name="ln8805">	if (userFileSystem != NULL) {</a>
<a name="ln8806">		if (!IS_USER_ADDRESS(userFileSystem))</a>
<a name="ln8807">			return B_BAD_ADDRESS;</a>
<a name="ln8808"> </a>
<a name="ln8809">		status = user_copy_name(fileSystem, userFileSystem, sizeof(fileSystem));</a>
<a name="ln8810">		if (status != B_OK)</a>
<a name="ln8811">			return status;</a>
<a name="ln8812">	}</a>
<a name="ln8813"> </a>
<a name="ln8814">	if (userDevice != NULL) {</a>
<a name="ln8815">		if (!IS_USER_ADDRESS(userDevice))</a>
<a name="ln8816">			return B_BAD_ADDRESS;</a>
<a name="ln8817"> </a>
<a name="ln8818">		status = user_copy_name(device.LockBuffer(), userDevice,</a>
<a name="ln8819">			B_PATH_NAME_LENGTH);</a>
<a name="ln8820">		if (status != B_OK)</a>
<a name="ln8821">			return status;</a>
<a name="ln8822">	}</a>
<a name="ln8823"> </a>
<a name="ln8824">	if (userArgs != NULL &amp;&amp; argsLength &gt; 0) {</a>
<a name="ln8825">		if (!IS_USER_ADDRESS(userArgs))</a>
<a name="ln8826">			return B_BAD_ADDRESS;</a>
<a name="ln8827"> </a>
<a name="ln8828">		// this is a safety restriction</a>
<a name="ln8829">		if (argsLength &gt;= 65536)</a>
<a name="ln8830">			return B_NAME_TOO_LONG;</a>
<a name="ln8831"> </a>
<a name="ln8832">		args = (char*)malloc(argsLength + 1);</a>
<a name="ln8833">		if (args == NULL)</a>
<a name="ln8834">			return B_NO_MEMORY;</a>
<a name="ln8835"> </a>
<a name="ln8836">		status = user_copy_name(args, userArgs, argsLength + 1);</a>
<a name="ln8837">		if (status != B_OK) {</a>
<a name="ln8838">			free(args);</a>
<a name="ln8839">			return status;</a>
<a name="ln8840">		}</a>
<a name="ln8841">	}</a>
<a name="ln8842">	path.UnlockBuffer();</a>
<a name="ln8843">	device.UnlockBuffer();</a>
<a name="ln8844"> </a>
<a name="ln8845">	status = fs_mount(path.LockBuffer(),</a>
<a name="ln8846">		userDevice != NULL ? device.Path() : NULL,</a>
<a name="ln8847">		userFileSystem ? fileSystem : NULL, flags, args, false);</a>
<a name="ln8848"> </a>
<a name="ln8849">	free(args);</a>
<a name="ln8850">	return status;</a>
<a name="ln8851">}</a>
<a name="ln8852"> </a>
<a name="ln8853"> </a>
<a name="ln8854">status_t</a>
<a name="ln8855">_user_unmount(const char* userPath, uint32 flags)</a>
<a name="ln8856">{</a>
<a name="ln8857">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8858"> </a>
<a name="ln8859">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln8860">		return B_BAD_ADDRESS;</a>
<a name="ln8861"> </a>
<a name="ln8862">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln8863">		return B_NO_MEMORY;</a>
<a name="ln8864"> </a>
<a name="ln8865">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln8866"> </a>
<a name="ln8867">	status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln8868">	if (status != B_OK)</a>
<a name="ln8869">		return status;</a>
<a name="ln8870"> </a>
<a name="ln8871">	return fs_unmount(path, -1, flags &amp; ~B_UNMOUNT_BUSY_PARTITION, false);</a>
<a name="ln8872">}</a>
<a name="ln8873"> </a>
<a name="ln8874"> </a>
<a name="ln8875">status_t</a>
<a name="ln8876">_user_read_fs_info(dev_t device, struct fs_info* userInfo)</a>
<a name="ln8877">{</a>
<a name="ln8878">	struct fs_info info;</a>
<a name="ln8879">	status_t status;</a>
<a name="ln8880"> </a>
<a name="ln8881">	if (userInfo == NULL)</a>
<a name="ln8882">		return B_BAD_VALUE;</a>
<a name="ln8883"> </a>
<a name="ln8884">	if (!IS_USER_ADDRESS(userInfo))</a>
<a name="ln8885">		return B_BAD_ADDRESS;</a>
<a name="ln8886"> </a>
<a name="ln8887">	status = fs_read_info(device, &amp;info);</a>
<a name="ln8888">	if (status != B_OK)</a>
<a name="ln8889">		return status;</a>
<a name="ln8890"> </a>
<a name="ln8891">	if (user_memcpy(userInfo, &amp;info, sizeof(struct fs_info)) != B_OK)</a>
<a name="ln8892">		return B_BAD_ADDRESS;</a>
<a name="ln8893"> </a>
<a name="ln8894">	return B_OK;</a>
<a name="ln8895">}</a>
<a name="ln8896"> </a>
<a name="ln8897"> </a>
<a name="ln8898">status_t</a>
<a name="ln8899">_user_write_fs_info(dev_t device, const struct fs_info* userInfo, int mask)</a>
<a name="ln8900">{</a>
<a name="ln8901">	struct fs_info info;</a>
<a name="ln8902"> </a>
<a name="ln8903">	if (userInfo == NULL)</a>
<a name="ln8904">		return B_BAD_VALUE;</a>
<a name="ln8905"> </a>
<a name="ln8906">	if (!IS_USER_ADDRESS(userInfo)</a>
<a name="ln8907">		|| user_memcpy(&amp;info, userInfo, sizeof(struct fs_info)) != B_OK)</a>
<a name="ln8908">		return B_BAD_ADDRESS;</a>
<a name="ln8909"> </a>
<a name="ln8910">	return fs_write_info(device, &amp;info, mask);</a>
<a name="ln8911">}</a>
<a name="ln8912"> </a>
<a name="ln8913"> </a>
<a name="ln8914">dev_t</a>
<a name="ln8915">_user_next_device(int32* _userCookie)</a>
<a name="ln8916">{</a>
<a name="ln8917">	int32 cookie;</a>
<a name="ln8918">	dev_t device;</a>
<a name="ln8919"> </a>
<a name="ln8920">	if (!IS_USER_ADDRESS(_userCookie)</a>
<a name="ln8921">		|| user_memcpy(&amp;cookie, _userCookie, sizeof(int32)) != B_OK)</a>
<a name="ln8922">		return B_BAD_ADDRESS;</a>
<a name="ln8923"> </a>
<a name="ln8924">	device = fs_next_device(&amp;cookie);</a>
<a name="ln8925"> </a>
<a name="ln8926">	if (device &gt;= B_OK) {</a>
<a name="ln8927">		// update user cookie</a>
<a name="ln8928">		if (user_memcpy(_userCookie, &amp;cookie, sizeof(int32)) != B_OK)</a>
<a name="ln8929">			return B_BAD_ADDRESS;</a>
<a name="ln8930">	}</a>
<a name="ln8931"> </a>
<a name="ln8932">	return device;</a>
<a name="ln8933">}</a>
<a name="ln8934"> </a>
<a name="ln8935"> </a>
<a name="ln8936">status_t</a>
<a name="ln8937">_user_sync(void)</a>
<a name="ln8938">{</a>
<a name="ln8939">	return _kern_sync();</a>
<a name="ln8940">}</a>
<a name="ln8941"> </a>
<a name="ln8942"> </a>
<a name="ln8943">status_t</a>
<a name="ln8944">_user_get_next_fd_info(team_id team, uint32* userCookie, fd_info* userInfo,</a>
<a name="ln8945">	size_t infoSize)</a>
<a name="ln8946">{</a>
<a name="ln8947">	struct fd_info info;</a>
<a name="ln8948">	uint32 cookie;</a>
<a name="ln8949"> </a>
<a name="ln8950">	// only root can do this (or should root's group be enough?)</a>
<a name="ln8951">	if (geteuid() != 0)</a>
<a name="ln8952">		return B_NOT_ALLOWED;</a>
<a name="ln8953"> </a>
<a name="ln8954">	if (infoSize != sizeof(fd_info))</a>
<a name="ln8955">		return B_BAD_VALUE;</a>
<a name="ln8956"> </a>
<a name="ln8957">	if (!IS_USER_ADDRESS(userCookie) || !IS_USER_ADDRESS(userInfo)</a>
<a name="ln8958">		|| user_memcpy(&amp;cookie, userCookie, sizeof(uint32)) != B_OK)</a>
<a name="ln8959">		return B_BAD_ADDRESS;</a>
<a name="ln8960"> </a>
<a name="ln8961">	status_t status = _kern_get_next_fd_info(team, &amp;cookie, &amp;info, infoSize);</a>
<a name="ln8962">	if (status != B_OK)</a>
<a name="ln8963">		return status;</a>
<a name="ln8964"> </a>
<a name="ln8965">	if (user_memcpy(userCookie, &amp;cookie, sizeof(uint32)) != B_OK</a>
<a name="ln8966">		|| user_memcpy(userInfo, &amp;info, infoSize) != B_OK)</a>
<a name="ln8967">		return B_BAD_ADDRESS;</a>
<a name="ln8968"> </a>
<a name="ln8969">	return status;</a>
<a name="ln8970">}</a>
<a name="ln8971"> </a>
<a name="ln8972"> </a>
<a name="ln8973">status_t</a>
<a name="ln8974">_user_entry_ref_to_path(dev_t device, ino_t inode, const char* leaf,</a>
<a name="ln8975">	char* userPath, size_t pathLength)</a>
<a name="ln8976">{</a>
<a name="ln8977">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln8978">		return B_BAD_ADDRESS;</a>
<a name="ln8979"> </a>
<a name="ln8980">	KPath path(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln8981">	if (path.InitCheck() != B_OK)</a>
<a name="ln8982">		return B_NO_MEMORY;</a>
<a name="ln8983"> </a>
<a name="ln8984">	// copy the leaf name onto the stack</a>
<a name="ln8985">	char stackLeaf[B_FILE_NAME_LENGTH];</a>
<a name="ln8986">	if (leaf != NULL) {</a>
<a name="ln8987">		if (!IS_USER_ADDRESS(leaf))</a>
<a name="ln8988">			return B_BAD_ADDRESS;</a>
<a name="ln8989"> </a>
<a name="ln8990">		int status = user_copy_name(stackLeaf, leaf, B_FILE_NAME_LENGTH);</a>
<a name="ln8991">		if (status != B_OK)</a>
<a name="ln8992">			return status;</a>
<a name="ln8993"> </a>
<a name="ln8994">		leaf = stackLeaf;</a>
<a name="ln8995">	}</a>
<a name="ln8996"> </a>
<a name="ln8997">	status_t status = vfs_entry_ref_to_path(device, inode, leaf,</a>
<a name="ln8998">		false, path.LockBuffer(), path.BufferSize());</a>
<a name="ln8999">	if (status != B_OK)</a>
<a name="ln9000">		return status;</a>
<a name="ln9001"> </a>
<a name="ln9002">	path.UnlockBuffer();</a>
<a name="ln9003"> </a>
<a name="ln9004">	int length = user_strlcpy(userPath, path.Path(), pathLength);</a>
<a name="ln9005">	if (length &lt; 0)</a>
<a name="ln9006">		return length;</a>
<a name="ln9007">	if (length &gt;= (int)pathLength)</a>
<a name="ln9008">		return B_BUFFER_OVERFLOW;</a>
<a name="ln9009"> </a>
<a name="ln9010">	return B_OK;</a>
<a name="ln9011">}</a>
<a name="ln9012"> </a>
<a name="ln9013"> </a>
<a name="ln9014">status_t</a>
<a name="ln9015">_user_normalize_path(const char* userPath, bool traverseLink, char* buffer)</a>
<a name="ln9016">{</a>
<a name="ln9017">	if (userPath == NULL || buffer == NULL)</a>
<a name="ln9018">		return B_BAD_VALUE;</a>
<a name="ln9019">	if (!IS_USER_ADDRESS(userPath) || !IS_USER_ADDRESS(buffer))</a>
<a name="ln9020">		return B_BAD_ADDRESS;</a>
<a name="ln9021"> </a>
<a name="ln9022">	// copy path from userland</a>
<a name="ln9023">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9024">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9025">		return B_NO_MEMORY;</a>
<a name="ln9026">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9027"> </a>
<a name="ln9028">	status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9029">	if (status != B_OK)</a>
<a name="ln9030">		return status;</a>
<a name="ln9031"> </a>
<a name="ln9032">	status_t error = normalize_path(path, pathBuffer.BufferSize(), traverseLink,</a>
<a name="ln9033">		false);</a>
<a name="ln9034">	if (error != B_OK)</a>
<a name="ln9035">		return error;</a>
<a name="ln9036"> </a>
<a name="ln9037">	// copy back to userland</a>
<a name="ln9038">	int len = user_strlcpy(buffer, path, B_PATH_NAME_LENGTH);</a>
<a name="ln9039">	if (len &lt; 0)</a>
<a name="ln9040">		return len;</a>
<a name="ln9041">	if (len &gt;= B_PATH_NAME_LENGTH)</a>
<a name="ln9042">		return B_BUFFER_OVERFLOW;</a>
<a name="ln9043"> </a>
<a name="ln9044">	return B_OK;</a>
<a name="ln9045">}</a>
<a name="ln9046"> </a>
<a name="ln9047"> </a>
<a name="ln9048">int</a>
<a name="ln9049">_user_open_entry_ref(dev_t device, ino_t inode, const char* userName,</a>
<a name="ln9050">	int openMode, int perms)</a>
<a name="ln9051">{</a>
<a name="ln9052">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln9053"> </a>
<a name="ln9054">	if (userName == NULL || device &lt; 0 || inode &lt; 0)</a>
<a name="ln9055">		return B_BAD_VALUE;</a>
<a name="ln9056">	if (!IS_USER_ADDRESS(userName))</a>
<a name="ln9057">		return B_BAD_ADDRESS;</a>
<a name="ln9058">	status_t status = user_copy_name(name, userName, sizeof(name));</a>
<a name="ln9059">	if (status != B_OK)</a>
<a name="ln9060">		return status;</a>
<a name="ln9061"> </a>
<a name="ln9062">	if ((openMode &amp; O_CREAT) != 0) {</a>
<a name="ln9063">		return file_create_entry_ref(device, inode, name, openMode, perms,</a>
<a name="ln9064">			false);</a>
<a name="ln9065">	}</a>
<a name="ln9066"> </a>
<a name="ln9067">	return file_open_entry_ref(device, inode, name, openMode, false);</a>
<a name="ln9068">}</a>
<a name="ln9069"> </a>
<a name="ln9070"> </a>
<a name="ln9071">int</a>
<a name="ln9072">_user_open(int fd, const char* userPath, int openMode, int perms)</a>
<a name="ln9073">{</a>
<a name="ln9074">	KPath path(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9075">	if (path.InitCheck() != B_OK)</a>
<a name="ln9076">		return B_NO_MEMORY;</a>
<a name="ln9077"> </a>
<a name="ln9078">	char* buffer = path.LockBuffer();</a>
<a name="ln9079"> </a>
<a name="ln9080">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9081">		return B_BAD_ADDRESS;</a>
<a name="ln9082">	status_t status = user_copy_name(buffer, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9083">	if (status != B_OK)</a>
<a name="ln9084">		return status;</a>
<a name="ln9085"> </a>
<a name="ln9086">	if ((openMode &amp; O_CREAT) != 0)</a>
<a name="ln9087">		return file_create(fd, buffer, openMode, perms, false);</a>
<a name="ln9088"> </a>
<a name="ln9089">	return file_open(fd, buffer, openMode, false);</a>
<a name="ln9090">}</a>
<a name="ln9091"> </a>
<a name="ln9092"> </a>
<a name="ln9093">int</a>
<a name="ln9094">_user_open_dir_entry_ref(dev_t device, ino_t inode, const char* userName)</a>
<a name="ln9095">{</a>
<a name="ln9096">	if (userName != NULL) {</a>
<a name="ln9097">		char name[B_FILE_NAME_LENGTH];</a>
<a name="ln9098"> </a>
<a name="ln9099">		if (!IS_USER_ADDRESS(userName))</a>
<a name="ln9100">			return B_BAD_ADDRESS;</a>
<a name="ln9101">		status_t status = user_copy_name(name, userName, sizeof(name));</a>
<a name="ln9102">		if (status != B_OK)</a>
<a name="ln9103">			return status;</a>
<a name="ln9104"> </a>
<a name="ln9105">		return dir_open_entry_ref(device, inode, name, false);</a>
<a name="ln9106">	}</a>
<a name="ln9107">	return dir_open_entry_ref(device, inode, NULL, false);</a>
<a name="ln9108">}</a>
<a name="ln9109"> </a>
<a name="ln9110"> </a>
<a name="ln9111">int</a>
<a name="ln9112">_user_open_dir(int fd, const char* userPath)</a>
<a name="ln9113">{</a>
<a name="ln9114">	if (userPath == NULL)</a>
<a name="ln9115">		return dir_open(fd, NULL, false);</a>
<a name="ln9116"> </a>
<a name="ln9117">	KPath path(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9118">	if (path.InitCheck() != B_OK)</a>
<a name="ln9119">		return B_NO_MEMORY;</a>
<a name="ln9120"> </a>
<a name="ln9121">	char* buffer = path.LockBuffer();</a>
<a name="ln9122"> </a>
<a name="ln9123">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9124">		return B_BAD_ADDRESS;</a>
<a name="ln9125">	status_t status = user_copy_name(buffer, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9126">	if (status != B_OK)</a>
<a name="ln9127">		return status;</a>
<a name="ln9128"> </a>
<a name="ln9129">	return dir_open(fd, buffer, false);</a>
<a name="ln9130">}</a>
<a name="ln9131"> </a>
<a name="ln9132"> </a>
<a name="ln9133">/*!	\brief Opens a directory's parent directory and returns the entry name</a>
<a name="ln9134">		   of the former.</a>
<a name="ln9135"> </a>
<a name="ln9136">	Aside from that it returns the directory's entry name, this method is</a>
<a name="ln9137">	equivalent to \code _user_open_dir(fd, &quot;..&quot;) \endcode. It really is</a>
<a name="ln9138">	equivalent, if \a userName is \c NULL.</a>
<a name="ln9139"> </a>
<a name="ln9140">	If a name buffer is supplied and the name does not fit the buffer, the</a>
<a name="ln9141">	function fails. A buffer of size \c B_FILE_NAME_LENGTH should be safe.</a>
<a name="ln9142"> </a>
<a name="ln9143">	\param fd A FD referring to a directory.</a>
<a name="ln9144">	\param userName Buffer the directory's entry name shall be written into.</a>
<a name="ln9145">		   May be \c NULL.</a>
<a name="ln9146">	\param nameLength Size of the name buffer.</a>
<a name="ln9147">	\return The file descriptor of the opened parent directory, if everything</a>
<a name="ln9148">			went fine, an error code otherwise.</a>
<a name="ln9149">*/</a>
<a name="ln9150">int</a>
<a name="ln9151">_user_open_parent_dir(int fd, char* userName, size_t nameLength)</a>
<a name="ln9152">{</a>
<a name="ln9153">	bool kernel = false;</a>
<a name="ln9154"> </a>
<a name="ln9155">	if (userName &amp;&amp; !IS_USER_ADDRESS(userName))</a>
<a name="ln9156">		return B_BAD_ADDRESS;</a>
<a name="ln9157"> </a>
<a name="ln9158">	// open the parent dir</a>
<a name="ln9159">	int parentFD = dir_open(fd, (char*)&quot;..&quot;, kernel);</a>
<a name="ln9160">	if (parentFD &lt; 0)</a>
<a name="ln9161">		return parentFD;</a>
<a name="ln9162">	FDCloser fdCloser(parentFD, kernel);</a>
<a name="ln9163"> </a>
<a name="ln9164">	if (userName) {</a>
<a name="ln9165">		// get the vnodes</a>
<a name="ln9166">		struct vnode* parentVNode = get_vnode_from_fd(parentFD, kernel);</a>
<a name="ln9167">		struct vnode* dirVNode = get_vnode_from_fd(fd, kernel);</a>
<a name="ln9168">		VNodePutter parentVNodePutter(parentVNode);</a>
<a name="ln9169">		VNodePutter dirVNodePutter(dirVNode);</a>
<a name="ln9170">		if (!parentVNode || !dirVNode)</a>
<a name="ln9171">			return B_FILE_ERROR;</a>
<a name="ln9172"> </a>
<a name="ln9173">		// get the vnode name</a>
<a name="ln9174">		char _buffer[sizeof(struct dirent) + B_FILE_NAME_LENGTH];</a>
<a name="ln9175">		struct dirent* buffer = (struct dirent*)_buffer;</a>
<a name="ln9176">		status_t status = get_vnode_name(dirVNode, parentVNode, buffer,</a>
<a name="ln9177">			sizeof(_buffer), get_current_io_context(false));</a>
<a name="ln9178">		if (status != B_OK)</a>
<a name="ln9179">			return status;</a>
<a name="ln9180"> </a>
<a name="ln9181">		// copy the name to the userland buffer</a>
<a name="ln9182">		int len = user_strlcpy(userName, buffer-&gt;d_name, nameLength);</a>
<a name="ln9183">		if (len &lt; 0)</a>
<a name="ln9184">			return len;</a>
<a name="ln9185">		if (len &gt;= (int)nameLength)</a>
<a name="ln9186">			return B_BUFFER_OVERFLOW;</a>
<a name="ln9187">	}</a>
<a name="ln9188"> </a>
<a name="ln9189">	return fdCloser.Detach();</a>
<a name="ln9190">}</a>
<a name="ln9191"> </a>
<a name="ln9192"> </a>
<a name="ln9193">status_t</a>
<a name="ln9194">_user_fcntl(int fd, int op, size_t argument)</a>
<a name="ln9195">{</a>
<a name="ln9196">	status_t status = common_fcntl(fd, op, argument, false);</a>
<a name="ln9197">	if (op == F_SETLKW)</a>
<a name="ln9198">		syscall_restart_handle_post(status);</a>
<a name="ln9199"> </a>
<a name="ln9200">	return status;</a>
<a name="ln9201">}</a>
<a name="ln9202"> </a>
<a name="ln9203"> </a>
<a name="ln9204">status_t</a>
<a name="ln9205">_user_fsync(int fd)</a>
<a name="ln9206">{</a>
<a name="ln9207">	return common_sync(fd, false);</a>
<a name="ln9208">}</a>
<a name="ln9209"> </a>
<a name="ln9210"> </a>
<a name="ln9211">status_t</a>
<a name="ln9212">_user_flock(int fd, int operation)</a>
<a name="ln9213">{</a>
<a name="ln9214">	FUNCTION((&quot;_user_fcntl(fd = %d, op = %d)\n&quot;, fd, operation));</a>
<a name="ln9215"> </a>
<a name="ln9216">	// Check if the operation is valid</a>
<a name="ln9217">	switch (operation &amp; ~LOCK_NB) {</a>
<a name="ln9218">		case LOCK_UN:</a>
<a name="ln9219">		case LOCK_SH:</a>
<a name="ln9220">		case LOCK_EX:</a>
<a name="ln9221">			break;</a>
<a name="ln9222"> </a>
<a name="ln9223">		default:</a>
<a name="ln9224">			return B_BAD_VALUE;</a>
<a name="ln9225">	}</a>
<a name="ln9226"> </a>
<a name="ln9227">	struct file_descriptor* descriptor;</a>
<a name="ln9228">	struct vnode* vnode;</a>
<a name="ln9229">	descriptor = get_fd_and_vnode(fd, &amp;vnode, false);</a>
<a name="ln9230">	if (descriptor == NULL)</a>
<a name="ln9231">		return B_FILE_ERROR;</a>
<a name="ln9232"> </a>
<a name="ln9233">	if (descriptor-&gt;type != FDTYPE_FILE) {</a>
<a name="ln9234">		put_fd(descriptor);</a>
<a name="ln9235">		return B_BAD_VALUE;</a>
<a name="ln9236">	}</a>
<a name="ln9237"> </a>
<a name="ln9238">	struct flock flock;</a>
<a name="ln9239">	flock.l_start = 0;</a>
<a name="ln9240">	flock.l_len = OFF_MAX;</a>
<a name="ln9241">	flock.l_whence = 0;</a>
<a name="ln9242">	flock.l_type = (operation &amp; LOCK_SH) != 0 ? F_RDLCK : F_WRLCK;</a>
<a name="ln9243"> </a>
<a name="ln9244">	status_t status;</a>
<a name="ln9245">	if ((operation &amp; LOCK_UN) != 0) {</a>
<a name="ln9246">		if (HAS_FS_CALL(vnode, release_lock))</a>
<a name="ln9247">			status = FS_CALL(vnode, release_lock, descriptor-&gt;cookie, &amp;flock);</a>
<a name="ln9248">		else</a>
<a name="ln9249">			status = release_advisory_lock(vnode, NULL, descriptor, &amp;flock);</a>
<a name="ln9250">	} else {</a>
<a name="ln9251">		if (HAS_FS_CALL(vnode, acquire_lock)) {</a>
<a name="ln9252">			status = FS_CALL(vnode, acquire_lock, descriptor-&gt;cookie, &amp;flock,</a>
<a name="ln9253">				(operation &amp; LOCK_NB) == 0);</a>
<a name="ln9254">		} else {</a>
<a name="ln9255">			status = acquire_advisory_lock(vnode, NULL, descriptor, &amp;flock,</a>
<a name="ln9256">				(operation &amp; LOCK_NB) == 0);</a>
<a name="ln9257">		}</a>
<a name="ln9258">	}</a>
<a name="ln9259"> </a>
<a name="ln9260">	syscall_restart_handle_post(status);</a>
<a name="ln9261"> </a>
<a name="ln9262">	put_fd(descriptor);</a>
<a name="ln9263">	return status;</a>
<a name="ln9264">}</a>
<a name="ln9265"> </a>
<a name="ln9266"> </a>
<a name="ln9267">status_t</a>
<a name="ln9268">_user_lock_node(int fd)</a>
<a name="ln9269">{</a>
<a name="ln9270">	return common_lock_node(fd, false);</a>
<a name="ln9271">}</a>
<a name="ln9272"> </a>
<a name="ln9273"> </a>
<a name="ln9274">status_t</a>
<a name="ln9275">_user_unlock_node(int fd)</a>
<a name="ln9276">{</a>
<a name="ln9277">	return common_unlock_node(fd, false);</a>
<a name="ln9278">}</a>
<a name="ln9279"> </a>
<a name="ln9280"> </a>
<a name="ln9281">status_t</a>
<a name="ln9282">_user_create_dir_entry_ref(dev_t device, ino_t inode, const char* userName,</a>
<a name="ln9283">	int perms)</a>
<a name="ln9284">{</a>
<a name="ln9285">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln9286">	status_t status;</a>
<a name="ln9287"> </a>
<a name="ln9288">	if (!IS_USER_ADDRESS(userName))</a>
<a name="ln9289">		return B_BAD_ADDRESS;</a>
<a name="ln9290"> </a>
<a name="ln9291">	status = user_copy_name(name, userName, sizeof(name));</a>
<a name="ln9292">	if (status != B_OK)</a>
<a name="ln9293">		return status;</a>
<a name="ln9294"> </a>
<a name="ln9295">	return dir_create_entry_ref(device, inode, name, perms, false);</a>
<a name="ln9296">}</a>
<a name="ln9297"> </a>
<a name="ln9298"> </a>
<a name="ln9299">status_t</a>
<a name="ln9300">_user_create_dir(int fd, const char* userPath, int perms)</a>
<a name="ln9301">{</a>
<a name="ln9302">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9303">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9304">		return B_NO_MEMORY;</a>
<a name="ln9305"> </a>
<a name="ln9306">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9307"> </a>
<a name="ln9308">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9309">		return B_BAD_ADDRESS;</a>
<a name="ln9310">	status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9311">	if (status != B_OK)</a>
<a name="ln9312">		return status;</a>
<a name="ln9313"> </a>
<a name="ln9314">	return dir_create(fd, path, perms, false);</a>
<a name="ln9315">}</a>
<a name="ln9316"> </a>
<a name="ln9317"> </a>
<a name="ln9318">status_t</a>
<a name="ln9319">_user_remove_dir(int fd, const char* userPath)</a>
<a name="ln9320">{</a>
<a name="ln9321">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9322">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9323">		return B_NO_MEMORY;</a>
<a name="ln9324"> </a>
<a name="ln9325">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9326"> </a>
<a name="ln9327">	if (userPath != NULL) {</a>
<a name="ln9328">		if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9329">			return B_BAD_ADDRESS;</a>
<a name="ln9330">		status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9331">		if (status != B_OK)</a>
<a name="ln9332">			return status;</a>
<a name="ln9333">	}</a>
<a name="ln9334"> </a>
<a name="ln9335">	return dir_remove(fd, userPath ? path : NULL, false);</a>
<a name="ln9336">}</a>
<a name="ln9337"> </a>
<a name="ln9338"> </a>
<a name="ln9339">status_t</a>
<a name="ln9340">_user_read_link(int fd, const char* userPath, char* userBuffer,</a>
<a name="ln9341">	size_t* userBufferSize)</a>
<a name="ln9342">{</a>
<a name="ln9343">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1), linkBuffer;</a>
<a name="ln9344">	if (pathBuffer.InitCheck() != B_OK || linkBuffer.InitCheck() != B_OK)</a>
<a name="ln9345">		return B_NO_MEMORY;</a>
<a name="ln9346"> </a>
<a name="ln9347">	size_t bufferSize;</a>
<a name="ln9348"> </a>
<a name="ln9349">	if (!IS_USER_ADDRESS(userBuffer) || !IS_USER_ADDRESS(userBufferSize)</a>
<a name="ln9350">		|| user_memcpy(&amp;bufferSize, userBufferSize, sizeof(size_t)) != B_OK)</a>
<a name="ln9351">		return B_BAD_ADDRESS;</a>
<a name="ln9352"> </a>
<a name="ln9353">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9354">	char* buffer = linkBuffer.LockBuffer();</a>
<a name="ln9355"> </a>
<a name="ln9356">	if (userPath) {</a>
<a name="ln9357">		if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9358">			return B_BAD_ADDRESS;</a>
<a name="ln9359">		status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9360">		if (status != B_OK)</a>
<a name="ln9361">			return status;</a>
<a name="ln9362"> </a>
<a name="ln9363">		if (bufferSize &gt; B_PATH_NAME_LENGTH)</a>
<a name="ln9364">			bufferSize = B_PATH_NAME_LENGTH;</a>
<a name="ln9365">	}</a>
<a name="ln9366"> </a>
<a name="ln9367">	status_t status = common_read_link(fd, userPath ? path : NULL, buffer,</a>
<a name="ln9368">		&amp;bufferSize, false);</a>
<a name="ln9369"> </a>
<a name="ln9370">	// we also update the bufferSize in case of errors</a>
<a name="ln9371">	// (the real length will be returned in case of B_BUFFER_OVERFLOW)</a>
<a name="ln9372">	if (user_memcpy(userBufferSize, &amp;bufferSize, sizeof(size_t)) != B_OK)</a>
<a name="ln9373">		return B_BAD_ADDRESS;</a>
<a name="ln9374"> </a>
<a name="ln9375">	if (status != B_OK)</a>
<a name="ln9376">		return status;</a>
<a name="ln9377"> </a>
<a name="ln9378">	if (user_memcpy(userBuffer, buffer, bufferSize) != B_OK)</a>
<a name="ln9379">		return B_BAD_ADDRESS;</a>
<a name="ln9380"> </a>
<a name="ln9381">	return B_OK;</a>
<a name="ln9382">}</a>
<a name="ln9383"> </a>
<a name="ln9384"> </a>
<a name="ln9385">status_t</a>
<a name="ln9386">_user_create_symlink(int fd, const char* userPath, const char* userToPath,</a>
<a name="ln9387">	int mode)</a>
<a name="ln9388">{</a>
<a name="ln9389">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9390">	KPath toPathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9391">	if (pathBuffer.InitCheck() != B_OK || toPathBuffer.InitCheck() != B_OK)</a>
<a name="ln9392">		return B_NO_MEMORY;</a>
<a name="ln9393"> </a>
<a name="ln9394">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9395">	char* toPath = toPathBuffer.LockBuffer();</a>
<a name="ln9396"> </a>
<a name="ln9397">	if (!IS_USER_ADDRESS(userPath) || !IS_USER_ADDRESS(userToPath))</a>
<a name="ln9398">		return B_BAD_ADDRESS;</a>
<a name="ln9399">	status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9400">	if (status != B_OK)</a>
<a name="ln9401">		return status;</a>
<a name="ln9402">	status = user_copy_name(toPath, userToPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9403">	if (status != B_OK)</a>
<a name="ln9404">		return status;</a>
<a name="ln9405"> </a>
<a name="ln9406">	return common_create_symlink(fd, path, toPath, mode, false);</a>
<a name="ln9407">}</a>
<a name="ln9408"> </a>
<a name="ln9409"> </a>
<a name="ln9410">status_t</a>
<a name="ln9411">_user_create_link(int pathFD, const char* userPath, int toFD,</a>
<a name="ln9412">	const char* userToPath, bool traverseLeafLink)</a>
<a name="ln9413">{</a>
<a name="ln9414">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9415">	KPath toPathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9416">	if (pathBuffer.InitCheck() != B_OK || toPathBuffer.InitCheck() != B_OK)</a>
<a name="ln9417">		return B_NO_MEMORY;</a>
<a name="ln9418"> </a>
<a name="ln9419">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9420">	char* toPath = toPathBuffer.LockBuffer();</a>
<a name="ln9421"> </a>
<a name="ln9422">	if (!IS_USER_ADDRESS(userPath) || !IS_USER_ADDRESS(userToPath))</a>
<a name="ln9423">		return B_BAD_ADDRESS;</a>
<a name="ln9424">	status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9425">	if (status != B_OK)</a>
<a name="ln9426">		return status;</a>
<a name="ln9427">	status = user_copy_name(toPath, userToPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9428">	if (status != B_OK)</a>
<a name="ln9429">		return status;</a>
<a name="ln9430"> </a>
<a name="ln9431">	status = check_path(toPath);</a>
<a name="ln9432">	if (status != B_OK)</a>
<a name="ln9433">		return status;</a>
<a name="ln9434"> </a>
<a name="ln9435">	return common_create_link(pathFD, path, toFD, toPath, traverseLeafLink,</a>
<a name="ln9436">		false);</a>
<a name="ln9437">}</a>
<a name="ln9438"> </a>
<a name="ln9439"> </a>
<a name="ln9440">status_t</a>
<a name="ln9441">_user_unlink(int fd, const char* userPath)</a>
<a name="ln9442">{</a>
<a name="ln9443">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9444">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9445">		return B_NO_MEMORY;</a>
<a name="ln9446"> </a>
<a name="ln9447">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9448"> </a>
<a name="ln9449">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9450">		return B_BAD_ADDRESS;</a>
<a name="ln9451">	status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9452">	if (status != B_OK)</a>
<a name="ln9453">		return status;</a>
<a name="ln9454"> </a>
<a name="ln9455">	return common_unlink(fd, path, false);</a>
<a name="ln9456">}</a>
<a name="ln9457"> </a>
<a name="ln9458"> </a>
<a name="ln9459">status_t</a>
<a name="ln9460">_user_rename(int oldFD, const char* userOldPath, int newFD,</a>
<a name="ln9461">	const char* userNewPath)</a>
<a name="ln9462">{</a>
<a name="ln9463">	KPath oldPathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9464">	KPath newPathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9465">	if (oldPathBuffer.InitCheck() != B_OK || newPathBuffer.InitCheck() != B_OK)</a>
<a name="ln9466">		return B_NO_MEMORY;</a>
<a name="ln9467"> </a>
<a name="ln9468">	char* oldPath = oldPathBuffer.LockBuffer();</a>
<a name="ln9469">	char* newPath = newPathBuffer.LockBuffer();</a>
<a name="ln9470"> </a>
<a name="ln9471">	if (!IS_USER_ADDRESS(userOldPath) || !IS_USER_ADDRESS(userNewPath))</a>
<a name="ln9472">		return B_BAD_ADDRESS;</a>
<a name="ln9473">	status_t status = user_copy_name(oldPath, userOldPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9474">	if (status != B_OK)</a>
<a name="ln9475">		return status;</a>
<a name="ln9476">	status = user_copy_name(newPath, userNewPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9477">	if (status != B_OK)</a>
<a name="ln9478">		return status;</a>
<a name="ln9479"> </a>
<a name="ln9480">	return common_rename(oldFD, oldPath, newFD, newPath, false);</a>
<a name="ln9481">}</a>
<a name="ln9482"> </a>
<a name="ln9483"> </a>
<a name="ln9484">status_t</a>
<a name="ln9485">_user_create_fifo(int fd, const char* userPath, mode_t perms)</a>
<a name="ln9486">{</a>
<a name="ln9487">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9488">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9489">		return B_NO_MEMORY;</a>
<a name="ln9490"> </a>
<a name="ln9491">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9492"> </a>
<a name="ln9493">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9494">		return B_BAD_ADDRESS;</a>
<a name="ln9495">	status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9496">	if (status != B_OK)</a>
<a name="ln9497">		return status;</a>
<a name="ln9498"> </a>
<a name="ln9499">	// split into directory vnode and filename path</a>
<a name="ln9500">	char filename[B_FILE_NAME_LENGTH];</a>
<a name="ln9501">	struct vnode* dir;</a>
<a name="ln9502">	status = fd_and_path_to_dir_vnode(fd, path, &amp;dir, filename, false);</a>
<a name="ln9503">	if (status != B_OK)</a>
<a name="ln9504">		return status;</a>
<a name="ln9505"> </a>
<a name="ln9506">	VNodePutter _(dir);</a>
<a name="ln9507"> </a>
<a name="ln9508">	// the underlying FS needs to support creating FIFOs</a>
<a name="ln9509">	if (!HAS_FS_CALL(dir, create_special_node))</a>
<a name="ln9510">		return B_UNSUPPORTED;</a>
<a name="ln9511"> </a>
<a name="ln9512">	// create the entry	-- the FIFO sub node is set up automatically</a>
<a name="ln9513">	fs_vnode superVnode;</a>
<a name="ln9514">	ino_t nodeID;</a>
<a name="ln9515">	status = FS_CALL(dir, create_special_node, filename, NULL,</a>
<a name="ln9516">		S_IFIFO | (perms &amp; S_IUMSK), 0, &amp;superVnode, &amp;nodeID);</a>
<a name="ln9517"> </a>
<a name="ln9518">	// create_special_node() acquired a reference for us that we don't need.</a>
<a name="ln9519">	if (status == B_OK)</a>
<a name="ln9520">		put_vnode(dir-&gt;mount-&gt;volume, nodeID);</a>
<a name="ln9521"> </a>
<a name="ln9522">	return status;</a>
<a name="ln9523">}</a>
<a name="ln9524"> </a>
<a name="ln9525"> </a>
<a name="ln9526">status_t</a>
<a name="ln9527">_user_create_pipe(int* userFDs)</a>
<a name="ln9528">{</a>
<a name="ln9529">	// rootfs should support creating FIFOs, but let's be sure</a>
<a name="ln9530">	if (!HAS_FS_CALL(sRoot, create_special_node))</a>
<a name="ln9531">		return B_UNSUPPORTED;</a>
<a name="ln9532"> </a>
<a name="ln9533">	// create the node	-- the FIFO sub node is set up automatically</a>
<a name="ln9534">	fs_vnode superVnode;</a>
<a name="ln9535">	ino_t nodeID;</a>
<a name="ln9536">	status_t status = FS_CALL(sRoot, create_special_node, NULL, NULL,</a>
<a name="ln9537">		S_IFIFO | S_IRUSR | S_IWUSR, 0, &amp;superVnode, &amp;nodeID);</a>
<a name="ln9538">	if (status != B_OK)</a>
<a name="ln9539">		return status;</a>
<a name="ln9540"> </a>
<a name="ln9541">	// We've got one reference to the node and need another one.</a>
<a name="ln9542">	struct vnode* vnode;</a>
<a name="ln9543">	status = get_vnode(sRoot-&gt;mount-&gt;id, nodeID, &amp;vnode, true, false);</a>
<a name="ln9544">	if (status != B_OK) {</a>
<a name="ln9545">		// that should not happen</a>
<a name="ln9546">		dprintf(&quot;_user_create_pipe(): Failed to lookup vnode (%&quot; B_PRIdDEV &quot;, &quot;</a>
<a name="ln9547">			&quot;%&quot; B_PRIdINO &quot;)\n&quot;, sRoot-&gt;mount-&gt;id, sRoot-&gt;id);</a>
<a name="ln9548">		return status;</a>
<a name="ln9549">	}</a>
<a name="ln9550"> </a>
<a name="ln9551">	// Everything looks good so far. Open two FDs for reading respectively</a>
<a name="ln9552">	// writing.</a>
<a name="ln9553">	int fds[2];</a>
<a name="ln9554">	fds[0] = open_vnode(vnode, O_RDONLY, false);</a>
<a name="ln9555">	fds[1] = open_vnode(vnode, O_WRONLY, false);</a>
<a name="ln9556"> </a>
<a name="ln9557">	FDCloser closer0(fds[0], false);</a>
<a name="ln9558">	FDCloser closer1(fds[1], false);</a>
<a name="ln9559"> </a>
<a name="ln9560">	status = (fds[0] &gt;= 0 ? (fds[1] &gt;= 0 ? B_OK : fds[1]) : fds[0]);</a>
<a name="ln9561"> </a>
<a name="ln9562">	// copy FDs to userland</a>
<a name="ln9563">	if (status == B_OK) {</a>
<a name="ln9564">		if (!IS_USER_ADDRESS(userFDs)</a>
<a name="ln9565">			|| user_memcpy(userFDs, fds, sizeof(fds)) != B_OK) {</a>
<a name="ln9566">			status = B_BAD_ADDRESS;</a>
<a name="ln9567">		}</a>
<a name="ln9568">	}</a>
<a name="ln9569"> </a>
<a name="ln9570">	// keep FDs, if everything went fine</a>
<a name="ln9571">	if (status == B_OK) {</a>
<a name="ln9572">		closer0.Detach();</a>
<a name="ln9573">		closer1.Detach();</a>
<a name="ln9574">	}</a>
<a name="ln9575"> </a>
<a name="ln9576">	return status;</a>
<a name="ln9577">}</a>
<a name="ln9578"> </a>
<a name="ln9579"> </a>
<a name="ln9580">status_t</a>
<a name="ln9581">_user_access(int fd, const char* userPath, int mode, bool effectiveUserGroup)</a>
<a name="ln9582">{</a>
<a name="ln9583">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9584">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9585">		return B_NO_MEMORY;</a>
<a name="ln9586"> </a>
<a name="ln9587">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9588"> </a>
<a name="ln9589">	if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9590">		return B_BAD_ADDRESS;</a>
<a name="ln9591">	status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9592">	if (status != B_OK)</a>
<a name="ln9593">		return status;</a>
<a name="ln9594"> </a>
<a name="ln9595">	return common_access(fd, path, mode, effectiveUserGroup, false);</a>
<a name="ln9596">}</a>
<a name="ln9597"> </a>
<a name="ln9598"> </a>
<a name="ln9599">status_t</a>
<a name="ln9600">_user_read_stat(int fd, const char* userPath, bool traverseLink,</a>
<a name="ln9601">	struct stat* userStat, size_t statSize)</a>
<a name="ln9602">{</a>
<a name="ln9603">	struct stat stat;</a>
<a name="ln9604">	status_t status;</a>
<a name="ln9605"> </a>
<a name="ln9606">	if (statSize &gt; sizeof(struct stat))</a>
<a name="ln9607">		return B_BAD_VALUE;</a>
<a name="ln9608"> </a>
<a name="ln9609">	if (!IS_USER_ADDRESS(userStat))</a>
<a name="ln9610">		return B_BAD_ADDRESS;</a>
<a name="ln9611"> </a>
<a name="ln9612">	if (userPath != NULL) {</a>
<a name="ln9613">		// path given: get the stat of the node referred to by (fd, path)</a>
<a name="ln9614">		if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9615">			return B_BAD_ADDRESS;</a>
<a name="ln9616"> </a>
<a name="ln9617">		KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9618">		if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9619">			return B_NO_MEMORY;</a>
<a name="ln9620"> </a>
<a name="ln9621">		char* path = pathBuffer.LockBuffer();</a>
<a name="ln9622"> </a>
<a name="ln9623">		status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9624">		if (status != B_OK)</a>
<a name="ln9625">			return status;</a>
<a name="ln9626"> </a>
<a name="ln9627">		status = common_path_read_stat(fd, path, traverseLink, &amp;stat, false);</a>
<a name="ln9628">	} else {</a>
<a name="ln9629">		// no path given: get the FD and use the FD operation</a>
<a name="ln9630">		struct file_descriptor* descriptor</a>
<a name="ln9631">			= get_fd(get_current_io_context(false), fd);</a>
<a name="ln9632">		if (descriptor == NULL)</a>
<a name="ln9633">			return B_FILE_ERROR;</a>
<a name="ln9634"> </a>
<a name="ln9635">		if (descriptor-&gt;ops-&gt;fd_read_stat)</a>
<a name="ln9636">			status = descriptor-&gt;ops-&gt;fd_read_stat(descriptor, &amp;stat);</a>
<a name="ln9637">		else</a>
<a name="ln9638">			status = B_UNSUPPORTED;</a>
<a name="ln9639"> </a>
<a name="ln9640">		put_fd(descriptor);</a>
<a name="ln9641">	}</a>
<a name="ln9642"> </a>
<a name="ln9643">	if (status != B_OK)</a>
<a name="ln9644">		return status;</a>
<a name="ln9645"> </a>
<a name="ln9646">	return user_memcpy(userStat, &amp;stat, statSize);</a>
<a name="ln9647">}</a>
<a name="ln9648"> </a>
<a name="ln9649"> </a>
<a name="ln9650">status_t</a>
<a name="ln9651">_user_write_stat(int fd, const char* userPath, bool traverseLeafLink,</a>
<a name="ln9652">	const struct stat* userStat, size_t statSize, int statMask)</a>
<a name="ln9653">{</a>
<a name="ln9654">	if (statSize &gt; sizeof(struct stat))</a>
<a name="ln9655">		return B_BAD_VALUE;</a>
<a name="ln9656"> </a>
<a name="ln9657">	struct stat stat;</a>
<a name="ln9658"> </a>
<a name="ln9659">	if (!IS_USER_ADDRESS(userStat)</a>
<a name="ln9660">		|| user_memcpy(&amp;stat, userStat, statSize) &lt; B_OK)</a>
<a name="ln9661">		return B_BAD_ADDRESS;</a>
<a name="ln9662"> </a>
<a name="ln9663">	// clear additional stat fields</a>
<a name="ln9664">	if (statSize &lt; sizeof(struct stat))</a>
<a name="ln9665">		memset((uint8*)&amp;stat + statSize, 0, sizeof(struct stat) - statSize);</a>
<a name="ln9666"> </a>
<a name="ln9667">	status_t status;</a>
<a name="ln9668"> </a>
<a name="ln9669">	if (userPath != NULL) {</a>
<a name="ln9670">		// path given: write the stat of the node referred to by (fd, path)</a>
<a name="ln9671">		if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9672">			return B_BAD_ADDRESS;</a>
<a name="ln9673"> </a>
<a name="ln9674">		KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9675">		if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9676">			return B_NO_MEMORY;</a>
<a name="ln9677"> </a>
<a name="ln9678">		char* path = pathBuffer.LockBuffer();</a>
<a name="ln9679"> </a>
<a name="ln9680">		status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9681">		if (status != B_OK)</a>
<a name="ln9682">			return status;</a>
<a name="ln9683"> </a>
<a name="ln9684">		status = common_path_write_stat(fd, path, traverseLeafLink, &amp;stat,</a>
<a name="ln9685">			statMask, false);</a>
<a name="ln9686">	} else {</a>
<a name="ln9687">		// no path given: get the FD and use the FD operation</a>
<a name="ln9688">		struct file_descriptor* descriptor</a>
<a name="ln9689">			= get_fd(get_current_io_context(false), fd);</a>
<a name="ln9690">		if (descriptor == NULL)</a>
<a name="ln9691">			return B_FILE_ERROR;</a>
<a name="ln9692"> </a>
<a name="ln9693">		if (descriptor-&gt;ops-&gt;fd_write_stat) {</a>
<a name="ln9694">			status = descriptor-&gt;ops-&gt;fd_write_stat(descriptor, &amp;stat,</a>
<a name="ln9695">				statMask);</a>
<a name="ln9696">		} else</a>
<a name="ln9697">			status = B_UNSUPPORTED;</a>
<a name="ln9698"> </a>
<a name="ln9699">		put_fd(descriptor);</a>
<a name="ln9700">	}</a>
<a name="ln9701"> </a>
<a name="ln9702">	return status;</a>
<a name="ln9703">}</a>
<a name="ln9704"> </a>
<a name="ln9705"> </a>
<a name="ln9706">int</a>
<a name="ln9707">_user_open_attr_dir(int fd, const char* userPath, bool traverseLeafLink)</a>
<a name="ln9708">{</a>
<a name="ln9709">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9710">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9711">		return B_NO_MEMORY;</a>
<a name="ln9712"> </a>
<a name="ln9713">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9714"> </a>
<a name="ln9715">	if (userPath != NULL) {</a>
<a name="ln9716">		if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9717">			return B_BAD_ADDRESS;</a>
<a name="ln9718">		status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9719">		if (status != B_OK)</a>
<a name="ln9720">			return status;</a>
<a name="ln9721">	}</a>
<a name="ln9722"> </a>
<a name="ln9723">	return attr_dir_open(fd, userPath ? path : NULL, traverseLeafLink, false);</a>
<a name="ln9724">}</a>
<a name="ln9725"> </a>
<a name="ln9726"> </a>
<a name="ln9727">ssize_t</a>
<a name="ln9728">_user_read_attr(int fd, const char* userAttribute, off_t pos, void* userBuffer,</a>
<a name="ln9729">	size_t readBytes)</a>
<a name="ln9730">{</a>
<a name="ln9731">	char attribute[B_FILE_NAME_LENGTH];</a>
<a name="ln9732"> </a>
<a name="ln9733">	if (userAttribute == NULL)</a>
<a name="ln9734">		return B_BAD_VALUE;</a>
<a name="ln9735">	if (!IS_USER_ADDRESS(userAttribute))</a>
<a name="ln9736">		return B_BAD_ADDRESS;</a>
<a name="ln9737">	status_t status = user_copy_name(attribute, userAttribute, sizeof(attribute));</a>
<a name="ln9738">	if (status != B_OK)</a>
<a name="ln9739">		return status;</a>
<a name="ln9740"> </a>
<a name="ln9741">	int attr = attr_open(fd, NULL, attribute, O_RDONLY, false);</a>
<a name="ln9742">	if (attr &lt; 0)</a>
<a name="ln9743">		return attr;</a>
<a name="ln9744"> </a>
<a name="ln9745">	ssize_t bytes = _user_read(attr, pos, userBuffer, readBytes);</a>
<a name="ln9746">	_user_close(attr);</a>
<a name="ln9747"> </a>
<a name="ln9748">	return bytes;</a>
<a name="ln9749">}</a>
<a name="ln9750"> </a>
<a name="ln9751"> </a>
<a name="ln9752">ssize_t</a>
<a name="ln9753">_user_write_attr(int fd, const char* userAttribute, uint32 type, off_t pos,</a>
<a name="ln9754">	const void* buffer, size_t writeBytes)</a>
<a name="ln9755">{</a>
<a name="ln9756">	char attribute[B_FILE_NAME_LENGTH];</a>
<a name="ln9757"> </a>
<a name="ln9758">	if (userAttribute == NULL)</a>
<a name="ln9759">		return B_BAD_VALUE;</a>
<a name="ln9760">	if (!IS_USER_ADDRESS(userAttribute))</a>
<a name="ln9761">		return B_BAD_ADDRESS;</a>
<a name="ln9762">	status_t status = user_copy_name(attribute, userAttribute, sizeof(attribute));</a>
<a name="ln9763">	if (status != B_OK)</a>
<a name="ln9764">		return status;</a>
<a name="ln9765"> </a>
<a name="ln9766">	// Try to support the BeOS typical truncation as well as the position</a>
<a name="ln9767">	// argument</a>
<a name="ln9768">	int attr = attr_create(fd, NULL, attribute, type,</a>
<a name="ln9769">		O_CREAT | O_WRONLY | (pos != 0 ? 0 : O_TRUNC), false);</a>
<a name="ln9770">	if (attr &lt; 0)</a>
<a name="ln9771">		return attr;</a>
<a name="ln9772"> </a>
<a name="ln9773">	ssize_t bytes = _user_write(attr, pos, buffer, writeBytes);</a>
<a name="ln9774">	_user_close(attr);</a>
<a name="ln9775"> </a>
<a name="ln9776">	return bytes;</a>
<a name="ln9777">}</a>
<a name="ln9778"> </a>
<a name="ln9779"> </a>
<a name="ln9780">status_t</a>
<a name="ln9781">_user_stat_attr(int fd, const char* userAttribute,</a>
<a name="ln9782">	struct attr_info* userAttrInfo)</a>
<a name="ln9783">{</a>
<a name="ln9784">	char attribute[B_FILE_NAME_LENGTH];</a>
<a name="ln9785"> </a>
<a name="ln9786">	if (userAttribute == NULL || userAttrInfo == NULL)</a>
<a name="ln9787">		return B_BAD_VALUE;</a>
<a name="ln9788">	if (!IS_USER_ADDRESS(userAttribute) || !IS_USER_ADDRESS(userAttrInfo))</a>
<a name="ln9789">		return B_BAD_ADDRESS;</a>
<a name="ln9790">	status_t status = user_copy_name(attribute, userAttribute,</a>
<a name="ln9791">		sizeof(attribute));</a>
<a name="ln9792">	if (status != B_OK)</a>
<a name="ln9793">		return status;</a>
<a name="ln9794"> </a>
<a name="ln9795">	int attr = attr_open(fd, NULL, attribute, O_RDONLY, false);</a>
<a name="ln9796">	if (attr &lt; 0)</a>
<a name="ln9797">		return attr;</a>
<a name="ln9798"> </a>
<a name="ln9799">	struct file_descriptor* descriptor</a>
<a name="ln9800">		= get_fd(get_current_io_context(false), attr);</a>
<a name="ln9801">	if (descriptor == NULL) {</a>
<a name="ln9802">		_user_close(attr);</a>
<a name="ln9803">		return B_FILE_ERROR;</a>
<a name="ln9804">	}</a>
<a name="ln9805"> </a>
<a name="ln9806">	struct stat stat;</a>
<a name="ln9807">	if (descriptor-&gt;ops-&gt;fd_read_stat)</a>
<a name="ln9808">		status = descriptor-&gt;ops-&gt;fd_read_stat(descriptor, &amp;stat);</a>
<a name="ln9809">	else</a>
<a name="ln9810">		status = B_UNSUPPORTED;</a>
<a name="ln9811"> </a>
<a name="ln9812">	put_fd(descriptor);</a>
<a name="ln9813">	_user_close(attr);</a>
<a name="ln9814"> </a>
<a name="ln9815">	if (status == B_OK) {</a>
<a name="ln9816">		attr_info info;</a>
<a name="ln9817">		info.type = stat.st_type;</a>
<a name="ln9818">		info.size = stat.st_size;</a>
<a name="ln9819"> </a>
<a name="ln9820">		if (user_memcpy(userAttrInfo, &amp;info, sizeof(struct attr_info)) != B_OK)</a>
<a name="ln9821">			return B_BAD_ADDRESS;</a>
<a name="ln9822">	}</a>
<a name="ln9823"> </a>
<a name="ln9824">	return status;</a>
<a name="ln9825">}</a>
<a name="ln9826"> </a>
<a name="ln9827"> </a>
<a name="ln9828">int</a>
<a name="ln9829">_user_open_attr(int fd, const char* userPath, const char* userName,</a>
<a name="ln9830">	uint32 type, int openMode)</a>
<a name="ln9831">{</a>
<a name="ln9832">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln9833"> </a>
<a name="ln9834">	if (!IS_USER_ADDRESS(userName))</a>
<a name="ln9835">		return B_BAD_ADDRESS;</a>
<a name="ln9836">	status_t status = user_copy_name(name, userName, B_FILE_NAME_LENGTH);</a>
<a name="ln9837">	if (status != B_OK)</a>
<a name="ln9838">		return status;</a>
<a name="ln9839"> </a>
<a name="ln9840">	KPath pathBuffer(B_PATH_NAME_LENGTH + 1);</a>
<a name="ln9841">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9842">		return B_NO_MEMORY;</a>
<a name="ln9843"> </a>
<a name="ln9844">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9845"> </a>
<a name="ln9846">	if (userPath != NULL) {</a>
<a name="ln9847">		if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln9848">			return B_BAD_ADDRESS;</a>
<a name="ln9849">		status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln9850">		if (status != B_OK)</a>
<a name="ln9851">			return status;</a>
<a name="ln9852">	}</a>
<a name="ln9853"> </a>
<a name="ln9854">	if ((openMode &amp; O_CREAT) != 0) {</a>
<a name="ln9855">		return attr_create(fd, userPath ? path : NULL, name, type, openMode,</a>
<a name="ln9856">			false);</a>
<a name="ln9857">	}</a>
<a name="ln9858"> </a>
<a name="ln9859">	return attr_open(fd, userPath ? path : NULL, name, openMode, false);</a>
<a name="ln9860">}</a>
<a name="ln9861"> </a>
<a name="ln9862"> </a>
<a name="ln9863">status_t</a>
<a name="ln9864">_user_remove_attr(int fd, const char* userName)</a>
<a name="ln9865">{</a>
<a name="ln9866">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln9867"> </a>
<a name="ln9868">	if (!IS_USER_ADDRESS(userName))</a>
<a name="ln9869">		return B_BAD_ADDRESS;</a>
<a name="ln9870">	status_t status = user_copy_name(name, userName, B_FILE_NAME_LENGTH);</a>
<a name="ln9871">	if (status != B_OK)</a>
<a name="ln9872">		return status;</a>
<a name="ln9873"> </a>
<a name="ln9874">	return attr_remove(fd, name, false);</a>
<a name="ln9875">}</a>
<a name="ln9876"> </a>
<a name="ln9877"> </a>
<a name="ln9878">status_t</a>
<a name="ln9879">_user_rename_attr(int fromFile, const char* userFromName, int toFile,</a>
<a name="ln9880">	const char* userToName)</a>
<a name="ln9881">{</a>
<a name="ln9882">	if (!IS_USER_ADDRESS(userFromName)</a>
<a name="ln9883">		|| !IS_USER_ADDRESS(userToName))</a>
<a name="ln9884">		return B_BAD_ADDRESS;</a>
<a name="ln9885"> </a>
<a name="ln9886">	KPath fromNameBuffer(B_FILE_NAME_LENGTH);</a>
<a name="ln9887">	KPath toNameBuffer(B_FILE_NAME_LENGTH);</a>
<a name="ln9888">	if (fromNameBuffer.InitCheck() != B_OK || toNameBuffer.InitCheck() != B_OK)</a>
<a name="ln9889">		return B_NO_MEMORY;</a>
<a name="ln9890"> </a>
<a name="ln9891">	char* fromName = fromNameBuffer.LockBuffer();</a>
<a name="ln9892">	char* toName = toNameBuffer.LockBuffer();</a>
<a name="ln9893"> </a>
<a name="ln9894">	status_t status = user_copy_name(fromName, userFromName, B_FILE_NAME_LENGTH);</a>
<a name="ln9895">	if (status != B_OK)</a>
<a name="ln9896">		return status;</a>
<a name="ln9897">	status = user_copy_name(toName, userToName, B_FILE_NAME_LENGTH);</a>
<a name="ln9898">	if (status != B_OK)</a>
<a name="ln9899">		return status;</a>
<a name="ln9900"> </a>
<a name="ln9901">	return attr_rename(fromFile, fromName, toFile, toName, false);</a>
<a name="ln9902">}</a>
<a name="ln9903"> </a>
<a name="ln9904"> </a>
<a name="ln9905">int</a>
<a name="ln9906">_user_open_index_dir(dev_t device)</a>
<a name="ln9907">{</a>
<a name="ln9908">	return index_dir_open(device, false);</a>
<a name="ln9909">}</a>
<a name="ln9910"> </a>
<a name="ln9911"> </a>
<a name="ln9912">status_t</a>
<a name="ln9913">_user_create_index(dev_t device, const char* userName, uint32 type,</a>
<a name="ln9914">	uint32 flags)</a>
<a name="ln9915">{</a>
<a name="ln9916">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln9917"> </a>
<a name="ln9918">	if (!IS_USER_ADDRESS(userName))</a>
<a name="ln9919">		return B_BAD_ADDRESS;</a>
<a name="ln9920">	status_t status = user_copy_name(name, userName, B_FILE_NAME_LENGTH);</a>
<a name="ln9921">	if (status != B_OK)</a>
<a name="ln9922">		return status;</a>
<a name="ln9923"> </a>
<a name="ln9924">	return index_create(device, name, type, flags, false);</a>
<a name="ln9925">}</a>
<a name="ln9926"> </a>
<a name="ln9927"> </a>
<a name="ln9928">status_t</a>
<a name="ln9929">_user_read_index_stat(dev_t device, const char* userName, struct stat* userStat)</a>
<a name="ln9930">{</a>
<a name="ln9931">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln9932">	struct stat stat;</a>
<a name="ln9933">	status_t status;</a>
<a name="ln9934"> </a>
<a name="ln9935">	if (!IS_USER_ADDRESS(userName) || !IS_USER_ADDRESS(userStat))</a>
<a name="ln9936">		return B_BAD_ADDRESS;</a>
<a name="ln9937">	status = user_copy_name(name, userName, B_FILE_NAME_LENGTH);</a>
<a name="ln9938">	if (status != B_OK)</a>
<a name="ln9939">		return status;</a>
<a name="ln9940"> </a>
<a name="ln9941">	status = index_name_read_stat(device, name, &amp;stat, false);</a>
<a name="ln9942">	if (status == B_OK) {</a>
<a name="ln9943">		if (user_memcpy(userStat, &amp;stat, sizeof(stat)) != B_OK)</a>
<a name="ln9944">			return B_BAD_ADDRESS;</a>
<a name="ln9945">	}</a>
<a name="ln9946"> </a>
<a name="ln9947">	return status;</a>
<a name="ln9948">}</a>
<a name="ln9949"> </a>
<a name="ln9950"> </a>
<a name="ln9951">status_t</a>
<a name="ln9952">_user_remove_index(dev_t device, const char* userName)</a>
<a name="ln9953">{</a>
<a name="ln9954">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln9955"> </a>
<a name="ln9956">	if (!IS_USER_ADDRESS(userName))</a>
<a name="ln9957">		return B_BAD_ADDRESS;</a>
<a name="ln9958">	status_t status = user_copy_name(name, userName, B_FILE_NAME_LENGTH);</a>
<a name="ln9959">	if (status != B_OK)</a>
<a name="ln9960">		return status;</a>
<a name="ln9961"> </a>
<a name="ln9962">	return index_remove(device, name, false);</a>
<a name="ln9963">}</a>
<a name="ln9964"> </a>
<a name="ln9965"> </a>
<a name="ln9966">status_t</a>
<a name="ln9967">_user_getcwd(char* userBuffer, size_t size)</a>
<a name="ln9968">{</a>
<a name="ln9969">	if (size == 0)</a>
<a name="ln9970">		return B_BAD_VALUE;</a>
<a name="ln9971">	if (!IS_USER_ADDRESS(userBuffer))</a>
<a name="ln9972">		return B_BAD_ADDRESS;</a>
<a name="ln9973"> </a>
<a name="ln9974">	if (size &gt; kMaxPathLength)</a>
<a name="ln9975">		size = kMaxPathLength;</a>
<a name="ln9976"> </a>
<a name="ln9977">	KPath pathBuffer(size);</a>
<a name="ln9978">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln9979">		return B_NO_MEMORY;</a>
<a name="ln9980"> </a>
<a name="ln9981">	TRACE((&quot;user_getcwd: buf %p, %ld\n&quot;, userBuffer, size));</a>
<a name="ln9982"> </a>
<a name="ln9983">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln9984"> </a>
<a name="ln9985">	status_t status = get_cwd(path, size, false);</a>
<a name="ln9986">	if (status != B_OK)</a>
<a name="ln9987">		return status;</a>
<a name="ln9988"> </a>
<a name="ln9989">	// Copy back the result</a>
<a name="ln9990">	if (user_strlcpy(userBuffer, path, size) &lt; B_OK)</a>
<a name="ln9991">		return B_BAD_ADDRESS;</a>
<a name="ln9992"> </a>
<a name="ln9993">	return status;</a>
<a name="ln9994">}</a>
<a name="ln9995"> </a>
<a name="ln9996"> </a>
<a name="ln9997">status_t</a>
<a name="ln9998">_user_setcwd(int fd, const char* userPath)</a>
<a name="ln9999">{</a>
<a name="ln10000">	TRACE((&quot;user_setcwd: path = %p\n&quot;, userPath));</a>
<a name="ln10001"> </a>
<a name="ln10002">	KPath pathBuffer(B_PATH_NAME_LENGTH);</a>
<a name="ln10003">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln10004">		return B_NO_MEMORY;</a>
<a name="ln10005"> </a>
<a name="ln10006">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln10007"> </a>
<a name="ln10008">	if (userPath != NULL) {</a>
<a name="ln10009">		if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln10010">			return B_BAD_ADDRESS;</a>
<a name="ln10011">		status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln10012">		if (status != B_OK)</a>
<a name="ln10013">			return status;</a>
<a name="ln10014">	}</a>
<a name="ln10015"> </a>
<a name="ln10016">	return set_cwd(fd, userPath != NULL ? path : NULL, false);</a>
<a name="ln10017">}</a>
<a name="ln10018"> </a>
<a name="ln10019"> </a>
<a name="ln10020">status_t</a>
<a name="ln10021">_user_change_root(const char* userPath)</a>
<a name="ln10022">{</a>
<a name="ln10023">	// only root is allowed to chroot()</a>
<a name="ln10024">	if (geteuid() != 0)</a>
<a name="ln10025">		return B_NOT_ALLOWED;</a>
<a name="ln10026"> </a>
<a name="ln10027">	// alloc path buffer</a>
<a name="ln10028">	KPath pathBuffer(B_PATH_NAME_LENGTH);</a>
<a name="ln10029">	if (pathBuffer.InitCheck() != B_OK)</a>
<a name="ln10030">		return B_NO_MEMORY;</a>
<a name="ln10031"> </a>
<a name="ln10032">	// copy userland path to kernel</a>
<a name="ln10033">	char* path = pathBuffer.LockBuffer();</a>
<a name="ln10034">	if (userPath != NULL) {</a>
<a name="ln10035">		if (!IS_USER_ADDRESS(userPath))</a>
<a name="ln10036">			return B_BAD_ADDRESS;</a>
<a name="ln10037">		status_t status = user_copy_name(path, userPath, B_PATH_NAME_LENGTH);</a>
<a name="ln10038">		if (status != B_OK)</a>
<a name="ln10039">			return status;</a>
<a name="ln10040">	}</a>
<a name="ln10041"> </a>
<a name="ln10042">	// get the vnode</a>
<a name="ln10043">	struct vnode* vnode;</a>
<a name="ln10044">	status_t status = path_to_vnode(path, true, &amp;vnode, NULL, false);</a>
<a name="ln10045">	if (status != B_OK)</a>
<a name="ln10046">		return status;</a>
<a name="ln10047"> </a>
<a name="ln10048">	// set the new root</a>
<a name="ln10049">	struct io_context* context = get_current_io_context(false);</a>
<a name="ln10050">	mutex_lock(&amp;sIOContextRootLock);</a>
<a name="ln10051">	struct vnode* oldRoot = context-&gt;root;</a>
<a name="ln10052">	context-&gt;root = vnode;</a>
<a name="ln10053">	mutex_unlock(&amp;sIOContextRootLock);</a>
<a name="ln10054"> </a>
<a name="ln10055">	put_vnode(oldRoot);</a>
<a name="ln10056"> </a>
<a name="ln10057">	return B_OK;</a>
<a name="ln10058">}</a>
<a name="ln10059"> </a>
<a name="ln10060"> </a>
<a name="ln10061">int</a>
<a name="ln10062">_user_open_query(dev_t device, const char* userQuery, size_t queryLength,</a>
<a name="ln10063">	uint32 flags, port_id port, int32 token)</a>
<a name="ln10064">{</a>
<a name="ln10065">	char* query;</a>
<a name="ln10066"> </a>
<a name="ln10067">	if (device &lt; 0 || userQuery == NULL || queryLength == 0)</a>
<a name="ln10068">		return B_BAD_VALUE;</a>
<a name="ln10069"> </a>
<a name="ln10070">	if (!IS_USER_ADDRESS(userQuery))</a>
<a name="ln10071">		return B_BAD_ADDRESS;</a>
<a name="ln10072"> </a>
<a name="ln10073">	// this is a safety restriction</a>
<a name="ln10074">	if (queryLength &gt;= 65536)</a>
<a name="ln10075">		return B_NAME_TOO_LONG;</a>
<a name="ln10076"> </a>
<a name="ln10077">	query = (char*)malloc(queryLength + 1);</a>
<a name="ln10078">	if (query == NULL)</a>
<a name="ln10079">		return B_NO_MEMORY;</a>
<a name="ln10080">	if (user_strlcpy(query, userQuery, queryLength + 1) &lt; B_OK) {</a>
<a name="ln10081">		free(query);</a>
<a name="ln10082">		return B_BAD_ADDRESS;</a>
<a name="ln10083">	}</a>
<a name="ln10084"> </a>
<a name="ln10085">	int fd = query_open(device, query, flags, port, token, false);</a>
<a name="ln10086"> </a>
<a name="ln10087">	free(query);</a>
<a name="ln10088">	return fd;</a>
<a name="ln10089">}</a>
<a name="ln10090"> </a>
<a name="ln10091"> </a>
<a name="ln10092">#include &quot;vfs_request_io.cpp&quot;</a>

</code></pre>
<div class="balloon" rel="2662"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The 'memcpy' function processes '0' elements. Inspect the third argument.</p></div>
<div class="balloon" rel="5533"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'cookie' used. Consider checking the fourth actual argument of the 'get_new_fd' function.</p></div>
<div class="balloon" rel="5403"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'cookie' used. Consider checking the fourth actual argument of the 'get_new_fd' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
