
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>nv_crtc2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* second CTRC functionality for GeForce cards */</a>
<a name="ln2">/* Author:</a>
<a name="ln3">   Rudolf Cornelissen 11/2002-9/2009</a>
<a name="ln4">*/</a>
<a name="ln5"> </a>
<a name="ln6">#define MODULE_BIT 0x00020000</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;nv_std.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">/*</a>
<a name="ln11">	Enable/Disable interrupts.  Just a wrapper around the</a>
<a name="ln12">	ioctl() to the kernel driver.</a>
<a name="ln13">*/</a>
<a name="ln14">status_t nv_crtc2_interrupt_enable(bool flag)</a>
<a name="ln15">{</a>
<a name="ln16">	status_t result = B_OK;</a>
<a name="ln17">	nv_set_vblank_int svi;</a>
<a name="ln18"> </a>
<a name="ln19">	if (si-&gt;ps.int_assigned)</a>
<a name="ln20">	{</a>
<a name="ln21">		/* set the magic number so the driver knows we're for real */</a>
<a name="ln22">		svi.magic = NV_PRIVATE_DATA_MAGIC;</a>
<a name="ln23">		svi.crtc = 1;</a>
<a name="ln24">		svi.do_it = flag;</a>
<a name="ln25">		/* contact driver and get a pointer to the registers and shared data */</a>
<a name="ln26">		result = ioctl(fd, NV_RUN_INTERRUPTS, &amp;svi, sizeof(svi));</a>
<a name="ln27">	}</a>
<a name="ln28"> </a>
<a name="ln29">	return result;</a>
<a name="ln30">}</a>
<a name="ln31"> </a>
<a name="ln32">/* doing general fail-safe default setup here */</a>
<a name="ln33">//fixme: this is a _very_ basic setup, and it's preliminary...</a>
<a name="ln34">status_t nv_crtc2_update_fifo()</a>
<a name="ln35">{</a>
<a name="ln36">	uint8 bytes_per_pixel = 1;</a>
<a name="ln37">	uint32 drain;</a>
<a name="ln38"> </a>
<a name="ln39">	/* we are only using this on &gt;&gt;coldstarted&lt;&lt; cards which really need this */</a>
<a name="ln40">	//fixme: re-enable or remove after general user confirmation of behaviour...</a>
<a name="ln41">	if (/*(si-&gt;settings.usebios) ||*/ (si-&gt;ps.card_type != NV11)) return B_OK;</a>
<a name="ln42"> </a>
<a name="ln43">	/* enable access to secondary head */</a>
<a name="ln44">	set_crtc_owner(1);</a>
<a name="ln45"> </a>
<a name="ln46">	/* set CRTC FIFO low watermark according to memory drain */</a>
<a name="ln47">	switch(si-&gt;dm.space)</a>
<a name="ln48">	{</a>
<a name="ln49">	case B_CMAP8:</a>
<a name="ln50">		bytes_per_pixel = 1;</a>
<a name="ln51">		break;</a>
<a name="ln52">	case B_RGB15_LITTLE:</a>
<a name="ln53">	case B_RGB16_LITTLE:</a>
<a name="ln54">		bytes_per_pixel = 2;</a>
<a name="ln55">		break;</a>
<a name="ln56">	case B_RGB24_LITTLE:</a>
<a name="ln57">		bytes_per_pixel = 3;</a>
<a name="ln58">		break;</a>
<a name="ln59">	case B_RGB32_LITTLE:</a>
<a name="ln60">		bytes_per_pixel = 4;</a>
<a name="ln61">		break;</a>
<a name="ln62">	}</a>
<a name="ln63">	/* fixme:</a>
<a name="ln64">	 * - I should probably include the refreshrate as well;</a>
<a name="ln65">	 * - and the memory clocking speed, core clocking speed, RAM buswidth.. */</a>
<a name="ln66">	drain = si-&gt;dm.timing.h_display * si-&gt;dm.timing.v_display * bytes_per_pixel;</a>
<a name="ln67"> </a>
<a name="ln68">	/* Doesn't work for other than 32bit space (yet?) */</a>
<a name="ln69">	if (si-&gt;dm.space != B_RGB32_LITTLE)</a>
<a name="ln70">	{</a>
<a name="ln71">		/* BIOS defaults */</a>
<a name="ln72">		CRTC2W(FIFO, 0x03);</a>
<a name="ln73">		CRTC2W(FIFO_LWM, 0x20);</a>
<a name="ln74">		LOG(4,(&quot;CRTC2: FIFO low-watermark set to $20, burst size 256 (BIOS defaults)\n&quot;));</a>
<a name="ln75">		return B_OK;</a>
<a name="ln76">	}</a>
<a name="ln77"> </a>
<a name="ln78">	if (drain &gt; (((uint32)1280) * 1024 * 4))</a>
<a name="ln79">	{</a>
<a name="ln80">		/* set CRTC FIFO burst size for 'smaller' bursts */</a>
<a name="ln81">		CRTC2W(FIFO, 0x01);</a>
<a name="ln82">		/* Instruct CRTC to fetch new data 'earlier' */</a>
<a name="ln83">		CRTC2W(FIFO_LWM, 0x40);</a>
<a name="ln84">		LOG(4,(&quot;CRTC2: FIFO low-watermark set to $40, burst size 64\n&quot;));</a>
<a name="ln85">	}</a>
<a name="ln86">	else</a>
<a name="ln87">	{</a>
<a name="ln88">		if (drain &gt; (((uint32)1024) * 768 * 4))</a>
<a name="ln89">		{</a>
<a name="ln90">			/* BIOS default */</a>
<a name="ln91">			CRTC2W(FIFO, 0x02);</a>
<a name="ln92">			/* Instruct CRTC to fetch new data 'earlier' */</a>
<a name="ln93">			CRTC2W(FIFO_LWM, 0x40);</a>
<a name="ln94">			LOG(4,(&quot;CRTC2: FIFO low-watermark set to $40, burst size 128\n&quot;));</a>
<a name="ln95">		}</a>
<a name="ln96">		else</a>
<a name="ln97">		{</a>
<a name="ln98">			/* BIOS defaults */</a>
<a name="ln99">			CRTC2W(FIFO, 0x03);</a>
<a name="ln100">			CRTC2W(FIFO_LWM, 0x20);</a>
<a name="ln101">			LOG(4,(&quot;CRTC2: FIFO low-watermark set to $20, burst size 256 (BIOS defaults)\n&quot;));</a>
<a name="ln102">		}</a>
<a name="ln103">	}</a>
<a name="ln104"> </a>
<a name="ln105">	return B_OK;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">/* Adjust passed parameters to a valid mode line */</a>
<a name="ln109">status_t nv_crtc2_validate_timing(</a>
<a name="ln110">	uint16 *hd_e,uint16 *hs_s,uint16 *hs_e,uint16 *ht,</a>
<a name="ln111">	uint16 *vd_e,uint16 *vs_s,uint16 *vs_e,uint16 *vt</a>
<a name="ln112">)</a>
<a name="ln113">{</a>
<a name="ln114">/* horizontal */</a>
<a name="ln115">	/* make all parameters multiples of 8 */</a>
<a name="ln116">	*hd_e &amp;= 0xfff8;</a>
<a name="ln117">	*hs_s &amp;= 0xfff8;</a>
<a name="ln118">	*hs_e &amp;= 0xfff8;</a>
<a name="ln119">	*ht   &amp;= 0xfff8;</a>
<a name="ln120"> </a>
<a name="ln121">	/* confine to required number of bits, taking logic into account */</a>
<a name="ln122">	if (*hd_e &gt; ((0x01ff - 2) &lt;&lt; 3)) *hd_e = ((0x01ff - 2) &lt;&lt; 3);</a>
<a name="ln123">	if (*hs_s &gt; ((0x01ff - 1) &lt;&lt; 3)) *hs_s = ((0x01ff - 1) &lt;&lt; 3);</a>
<a name="ln124">	if (*hs_e &gt; ( 0x01ff      &lt;&lt; 3)) *hs_e = ( 0x01ff      &lt;&lt; 3);</a>
<a name="ln125">	if (*ht   &gt; ((0x01ff + 5) &lt;&lt; 3)) *ht   = ((0x01ff + 5) &lt;&lt; 3);</a>
<a name="ln126"> </a>
<a name="ln127">	/* NOTE: keep horizontal timing at multiples of 8! */</a>
<a name="ln128">	/* confine to a reasonable width */</a>
<a name="ln129">	if (*hd_e &lt; 640) *hd_e = 640;</a>
<a name="ln130">	if (*hd_e &gt; 2048) *hd_e = 2048;</a>
<a name="ln131"> </a>
<a name="ln132">	/* if hor. total does not leave room for a sensible sync pulse, increase it! */</a>
<a name="ln133">	if (*ht &lt; (*hd_e + 80)) *ht = (*hd_e + 80);</a>
<a name="ln134"> </a>
<a name="ln135">	/* if hor. total does not adhere to max. blanking pulse width, decrease it! */</a>
<a name="ln136">	if (*ht &gt; (*hd_e + 0x3f8)) *ht = (*hd_e + 0x3f8);</a>
<a name="ln137"> </a>
<a name="ln138">	/* make sure sync pulse is not during display */</a>
<a name="ln139">	if (*hs_e &gt; (*ht - 8)) *hs_e = (*ht - 8);</a>
<a name="ln140">	if (*hs_s &lt; (*hd_e + 8)) *hs_s = (*hd_e + 8);</a>
<a name="ln141"> </a>
<a name="ln142">	/* correct sync pulse if it is too long:</a>
<a name="ln143">	 * there are only 5 bits available to save this in the card registers! */</a>
<a name="ln144">	if (*hs_e &gt; (*hs_s + 0xf8)) *hs_e = (*hs_s + 0xf8);</a>
<a name="ln145"> </a>
<a name="ln146">/*vertical*/</a>
<a name="ln147">	/* confine to required number of bits, taking logic into account */</a>
<a name="ln148">	//fixme if needed: on GeForce cards there are 12 instead of 11 bits...</a>
<a name="ln149">	if (*vd_e &gt; (0x7ff - 2)) *vd_e = (0x7ff - 2);</a>
<a name="ln150">	if (*vs_s &gt; (0x7ff - 1)) *vs_s = (0x7ff - 1);</a>
<a name="ln151">	if (*vs_e &gt;  0x7ff     ) *vs_e =  0x7ff     ;</a>
<a name="ln152">	if (*vt   &gt; (0x7ff + 2)) *vt   = (0x7ff + 2);</a>
<a name="ln153"> </a>
<a name="ln154">	/* confine to a reasonable height */</a>
<a name="ln155">	if (*vd_e &lt; 480) *vd_e = 480;</a>
<a name="ln156">	if (*vd_e &gt; 1536) *vd_e = 1536;</a>
<a name="ln157"> </a>
<a name="ln158">	/*if vertical total does not leave room for a sync pulse, increase it!*/</a>
<a name="ln159">	if (*vt &lt; (*vd_e + 3)) *vt = (*vd_e + 3);</a>
<a name="ln160"> </a>
<a name="ln161">	/* if vert. total does not adhere to max. blanking pulse width, decrease it! */</a>
<a name="ln162">	if (*vt &gt; (*vd_e + 0xff)) *vt = (*vd_e + 0xff);</a>
<a name="ln163"> </a>
<a name="ln164">	/* make sure sync pulse is not during display */</a>
<a name="ln165">	if (*vs_e &gt; (*vt - 1)) *vs_e = (*vt - 1);</a>
<a name="ln166">	if (*vs_s &lt; (*vd_e + 1)) *vs_s = (*vd_e + 1);</a>
<a name="ln167"> </a>
<a name="ln168">	/* correct sync pulse if it is too long:</a>
<a name="ln169">	 * there are only 4 bits available to save this in the card registers! */</a>
<a name="ln170">	if (*vs_e &gt; (*vs_s + 0x0f)) *vs_e = (*vs_s + 0x0f);</a>
<a name="ln171"> </a>
<a name="ln172">	return B_OK;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">/*set a mode line - inputs are in pixels*/</a>
<a name="ln176">status_t nv_crtc2_set_timing(display_mode target)</a>
<a name="ln177">{</a>
<a name="ln178">	uint8 temp;</a>
<a name="ln179"> </a>
<a name="ln180">	uint32 htotal;		/*total horizontal total VCLKs*/</a>
<a name="ln181">	uint32 hdisp_e;            /*end of horizontal display (begins at 0)*/</a>
<a name="ln182">	uint32 hsync_s;            /*begin of horizontal sync pulse*/</a>
<a name="ln183">	uint32 hsync_e;            /*end of horizontal sync pulse*/</a>
<a name="ln184">	uint32 hblnk_s;            /*begin horizontal blanking*/</a>
<a name="ln185">	uint32 hblnk_e;            /*end horizontal blanking*/</a>
<a name="ln186"> </a>
<a name="ln187">	uint32 vtotal;		/*total vertical total scanlines*/</a>
<a name="ln188">	uint32 vdisp_e;            /*end of vertical display*/</a>
<a name="ln189">	uint32 vsync_s;            /*begin of vertical sync pulse*/</a>
<a name="ln190">	uint32 vsync_e;            /*end of vertical sync pulse*/</a>
<a name="ln191">	uint32 vblnk_s;            /*begin vertical blanking*/</a>
<a name="ln192">	uint32 vblnk_e;            /*end vertical blanking*/</a>
<a name="ln193"> </a>
<a name="ln194">	uint32 linecomp;	/*split screen and vdisp_e interrupt*/</a>
<a name="ln195"> </a>
<a name="ln196">	LOG(4,(&quot;CRTC2: setting timing\n&quot;));</a>
<a name="ln197"> </a>
<a name="ln198">	/* setup tuned internal modeline for flatpanel if connected and active */</a>
<a name="ln199">	/* notes:</a>
<a name="ln200">	 * - the CRTC modeline must end earlier than the panel modeline to keep correct</a>
<a name="ln201">	 *   sync going;</a>
<a name="ln202">	 * - if the CRTC modeline ends too soon, pixelnoise will occur in 8 (or so) pixel</a>
<a name="ln203">	 *   wide horizontal stripes. This can be observed earliest on fullscreen overlay,</a>
<a name="ln204">	 *   and if it gets worse, also normal desktop output will suffer. The stripes</a>
<a name="ln205">	 *   are mainly visible at the left of the screen, over the entire screen height. */</a>
<a name="ln206">	if (si-&gt;ps.monitors &amp; CRTC2_TMDS)</a>
<a name="ln207">	{</a>
<a name="ln208">		LOG(2,(&quot;CRTC2: DFP active: tuning modeline\n&quot;));</a>
<a name="ln209"> </a>
<a name="ln210">		/* horizontal timing */</a>
<a name="ln211">		target.timing.h_sync_start =</a>
<a name="ln212">			((uint16)((si-&gt;ps.p2_timing.h_sync_start / ((float)si-&gt;ps.p2_timing.h_display)) *</a>
<a name="ln213">			target.timing.h_display)) &amp; 0xfff8;</a>
<a name="ln214"> </a>
<a name="ln215">		target.timing.h_sync_end =</a>
<a name="ln216">			((uint16)((si-&gt;ps.p2_timing.h_sync_end / ((float)si-&gt;ps.p2_timing.h_display)) *</a>
<a name="ln217">			target.timing.h_display)) &amp; 0xfff8;</a>
<a name="ln218"> </a>
<a name="ln219">		target.timing.h_total =</a>
<a name="ln220">			(((uint16)((si-&gt;ps.p2_timing.h_total / ((float)si-&gt;ps.p2_timing.h_display)) *</a>
<a name="ln221">			target.timing.h_display)) &amp; 0xfff8) - 8;</a>
<a name="ln222"> </a>
<a name="ln223">		/* in native mode the CRTC needs some extra time to keep synced correctly;</a>
<a name="ln224">		 * OTOH the overlay unit distorts if we reserve too much time! */</a>
<a name="ln225">		if (target.timing.h_display == si-&gt;ps.p2_timing.h_display)</a>
<a name="ln226">		{</a>
<a name="ln227">			/* NV11 timing has different constraints than later cards */</a>
<a name="ln228">			if (si-&gt;ps.card_type == NV11)</a>
<a name="ln229">				target.timing.h_total -= 56;</a>
<a name="ln230">			else</a>
<a name="ln231">				/* confirmed NV34 with 1680x1050 panel */</a>
<a name="ln232">				target.timing.h_total -= 32;</a>
<a name="ln233">		}</a>
<a name="ln234"> </a>
<a name="ln235">		/* assure sync pulse is at the correct timing position */</a>
<a name="ln236">		if (target.timing.h_sync_start == target.timing.h_display)</a>
<a name="ln237">			target.timing.h_sync_start += 8;</a>
<a name="ln238">		if (target.timing.h_sync_end == target.timing.h_total)</a>
<a name="ln239">			target.timing.h_sync_end -= 8;</a>
<a name="ln240">		/* assure we (still) have a sync pulse */</a>
<a name="ln241">		if (target.timing.h_sync_start == target.timing.h_sync_end) {</a>
<a name="ln242">			if (target.timing.h_sync_end &lt; (target.timing.h_total - 8)) {</a>
<a name="ln243">				target.timing.h_sync_end += 8;</a>
<a name="ln244">			} else {</a>
<a name="ln245">				if (target.timing.h_sync_start &gt; (target.timing.h_display + 8)) {</a>
<a name="ln246">					target.timing.h_sync_start -= 8;</a>
<a name="ln247">				} else {</a>
<a name="ln248">					LOG(2,(&quot;CRTC2: tuning modeline, not enough room for Hsync pulse, forcing it anyway..\n&quot;));</a>
<a name="ln249">					target.timing.h_sync_start -= 8;</a>
<a name="ln250">				}</a>
<a name="ln251">			}</a>
<a name="ln252">		}</a>
<a name="ln253"> </a>
<a name="ln254">		/* vertical timing */</a>
<a name="ln255">		target.timing.v_sync_start =</a>
<a name="ln256">			((uint16)((si-&gt;ps.p2_timing.v_sync_start / ((float)si-&gt;ps.p2_timing.v_display)) *</a>
<a name="ln257">			target.timing.v_display));</a>
<a name="ln258"> </a>
<a name="ln259">		target.timing.v_sync_end =</a>
<a name="ln260">			((uint16)((si-&gt;ps.p2_timing.v_sync_end / ((float)si-&gt;ps.p2_timing.v_display)) *</a>
<a name="ln261">			target.timing.v_display));</a>
<a name="ln262"> </a>
<a name="ln263">		target.timing.v_total =</a>
<a name="ln264">			((uint16)((si-&gt;ps.p2_timing.v_total / ((float)si-&gt;ps.p2_timing.v_display)) *</a>
<a name="ln265">			target.timing.v_display)) - 1;</a>
<a name="ln266"> </a>
<a name="ln267">		/* assure sync pulse is at the correct timing position */</a>
<a name="ln268">		if (target.timing.v_sync_start == target.timing.v_display)</a>
<a name="ln269">			target.timing.v_sync_start += 1;</a>
<a name="ln270">		if (target.timing.v_sync_end == target.timing.v_total)</a>
<a name="ln271">			target.timing.v_sync_end -= 1;</a>
<a name="ln272">		/* assure we (still) have a sync pulse */</a>
<a name="ln273">		if (target.timing.v_sync_start == target.timing.v_sync_end) {</a>
<a name="ln274">			if (target.timing.v_sync_end &lt; (target.timing.v_total - 1)) {</a>
<a name="ln275">				target.timing.v_sync_end += 1;</a>
<a name="ln276">			} else {</a>
<a name="ln277">				if (target.timing.v_sync_start &gt; (target.timing.v_display + 1)) {</a>
<a name="ln278">					target.timing.v_sync_start -= 1;</a>
<a name="ln279">				} else {</a>
<a name="ln280">					LOG(2,(&quot;CRTC2: tuning modeline, not enough room for Vsync pulse, forcing it anyway..\n&quot;));</a>
<a name="ln281">					target.timing.v_sync_start -= 1;</a>
<a name="ln282">				}</a>
<a name="ln283">			}</a>
<a name="ln284">		}</a>
<a name="ln285"> </a>
<a name="ln286">		/* disable GPU scaling testmode so automatic scaling will be done */</a>
<a name="ln287">		DAC2W(FP_DEBUG1, 0);</a>
<a name="ln288">	}</a>
<a name="ln289"> </a>
<a name="ln290">	/* Modify parameters as required by standard VGA */</a>
<a name="ln291">	htotal = ((target.timing.h_total &gt;&gt; 3) - 5);</a>
<a name="ln292">	hdisp_e = ((target.timing.h_display &gt;&gt; 3) - 1);</a>
<a name="ln293">	hblnk_s = hdisp_e;</a>
<a name="ln294">	hblnk_e = (htotal + 4);</a>
<a name="ln295">	hsync_s = (target.timing.h_sync_start &gt;&gt; 3);</a>
<a name="ln296">	hsync_e = (target.timing.h_sync_end &gt;&gt; 3);</a>
<a name="ln297"> </a>
<a name="ln298">	vtotal = target.timing.v_total - 2;</a>
<a name="ln299">	vdisp_e = target.timing.v_display - 1;</a>
<a name="ln300">	vblnk_s = vdisp_e;</a>
<a name="ln301">	vblnk_e = (vtotal + 1);</a>
<a name="ln302">	vsync_s = target.timing.v_sync_start;</a>
<a name="ln303">	vsync_e = target.timing.v_sync_end;</a>
<a name="ln304"> </a>
<a name="ln305">	/* prevent memory adress counter from being reset (linecomp may not occur) */</a>
<a name="ln306">	linecomp = target.timing.v_display;</a>
<a name="ln307"> </a>
<a name="ln308">	/* enable access to secondary head */</a>
<a name="ln309">	set_crtc_owner(1);</a>
<a name="ln310"> </a>
<a name="ln311">	/* Note for laptop and DVI flatpanels:</a>
<a name="ln312">	 * CRTC timing has a seperate set of registers from flatpanel timing.</a>
<a name="ln313">	 * The flatpanel timing registers have scaling registers that are used to match</a>
<a name="ln314">	 * these two modelines. */</a>
<a name="ln315">	{</a>
<a name="ln316">		LOG(4,(&quot;CRTC2: Setting full timing...\n&quot;));</a>
<a name="ln317"> </a>
<a name="ln318">		/* log the mode that will be set */</a>
<a name="ln319">		LOG(2,(&quot;CRTC2:\n\tHTOT:%x\n\tHDISPEND:%x\n\tHBLNKS:%x\n\tHBLNKE:%x\n\tHSYNCS:%x\n\tHSYNCE:%x\n\t&quot;,htotal,hdisp_e,hblnk_s,hblnk_e,hsync_s,hsync_e));</a>
<a name="ln320">		LOG(2,(&quot;VTOT:%x\n\tVDISPEND:%x\n\tVBLNKS:%x\n\tVBLNKE:%x\n\tVSYNCS:%x\n\tVSYNCE:%x\n&quot;,vtotal,vdisp_e,vblnk_s,vblnk_e,vsync_s,vsync_e));</a>
<a name="ln321"> </a>
<a name="ln322">		/* actually program the card! */</a>
<a name="ln323">		/* unlock CRTC registers at index 0-7 */</a>
<a name="ln324">		CRTC2W(VSYNCE, (CRTC2R(VSYNCE) &amp; 0x7f));</a>
<a name="ln325">		/* horizontal standard VGA regs */</a>
<a name="ln326">		CRTC2W(HTOTAL, (htotal &amp; 0xff));</a>
<a name="ln327">		CRTC2W(HDISPE, (hdisp_e &amp; 0xff));</a>
<a name="ln328">		CRTC2W(HBLANKS, (hblnk_s &amp; 0xff));</a>
<a name="ln329">		/* also unlock vertical retrace registers in advance */</a>
<a name="ln330">		CRTC2W(HBLANKE, ((hblnk_e &amp; 0x1f) | 0x80));</a>
<a name="ln331">		CRTC2W(HSYNCS, (hsync_s &amp; 0xff));</a>
<a name="ln332">		CRTC2W(HSYNCE, ((hsync_e &amp; 0x1f) | ((hblnk_e &amp; 0x20) &lt;&lt; 2)));</a>
<a name="ln333"> </a>
<a name="ln334">		/* vertical standard VGA regs */</a>
<a name="ln335">		CRTC2W(VTOTAL, (vtotal &amp; 0xff));</a>
<a name="ln336">		CRTC2W(OVERFLOW,</a>
<a name="ln337">		(</a>
<a name="ln338">			((vtotal &amp; 0x100) &gt;&gt; (8 - 0)) | ((vtotal &amp; 0x200) &gt;&gt; (9 - 5)) |</a>
<a name="ln339">			((vdisp_e &amp; 0x100) &gt;&gt; (8 - 1)) | ((vdisp_e &amp; 0x200) &gt;&gt; (9 - 6)) |</a>
<a name="ln340">			((vsync_s &amp; 0x100) &gt;&gt; (8 - 2)) | ((vsync_s &amp; 0x200) &gt;&gt; (9 - 7)) |</a>
<a name="ln341">			((vblnk_s &amp; 0x100) &gt;&gt; (8 - 3)) | ((linecomp &amp; 0x100) &gt;&gt; (8 - 4))</a>
<a name="ln342">		));</a>
<a name="ln343">		CRTC2W(PRROWSCN, 0x00); /* not used */</a>
<a name="ln344">		CRTC2W(MAXSCLIN, (((vblnk_s &amp; 0x200) &gt;&gt; (9 - 5)) | ((linecomp &amp; 0x200) &gt;&gt; (9 - 6))));</a>
<a name="ln345">		CRTC2W(VSYNCS, (vsync_s &amp; 0xff));</a>
<a name="ln346">		CRTC2W(VSYNCE, ((CRTC2R(VSYNCE) &amp; 0xf0) | (vsync_e &amp; 0x0f)));</a>
<a name="ln347">		CRTC2W(VDISPE, (vdisp_e &amp; 0xff));</a>
<a name="ln348">		CRTC2W(VBLANKS, (vblnk_s &amp; 0xff));</a>
<a name="ln349">		CRTC2W(VBLANKE, (vblnk_e &amp; 0xff));</a>
<a name="ln350">		CRTC2W(LINECOMP, (linecomp &amp; 0xff));</a>
<a name="ln351"> </a>
<a name="ln352">		/* horizontal extended regs */</a>
<a name="ln353">		//fixme: we reset bit4. is this correct??</a>
<a name="ln354">		CRTC2W(HEB, (CRTC2R(HEB) &amp; 0xe0) |</a>
<a name="ln355">			(</a>
<a name="ln356">		 	((htotal &amp; 0x100) &gt;&gt; (8 - 0)) |</a>
<a name="ln357">			((hdisp_e &amp; 0x100) &gt;&gt; (8 - 1)) |</a>
<a name="ln358">			((hblnk_s &amp; 0x100) &gt;&gt; (8 - 2)) |</a>
<a name="ln359">			((hsync_s &amp; 0x100) &gt;&gt; (8 - 3))</a>
<a name="ln360">			));</a>
<a name="ln361"> </a>
<a name="ln362">		/* (mostly) vertical extended regs */</a>
<a name="ln363">		CRTC2W(LSR,</a>
<a name="ln364">			(</a>
<a name="ln365">		 	((vtotal &amp; 0x400) &gt;&gt; (10 - 0)) |</a>
<a name="ln366">			((vdisp_e &amp; 0x400) &gt;&gt; (10 - 1)) |</a>
<a name="ln367">			((vsync_s &amp; 0x400) &gt;&gt; (10 - 2)) |</a>
<a name="ln368">			((vblnk_s &amp; 0x400) &gt;&gt; (10 - 3)) |</a>
<a name="ln369">			((hblnk_e &amp; 0x040) &gt;&gt; (6 - 4))</a>
<a name="ln370">			//fixme: we still miss one linecomp bit!?! is this it??</a>
<a name="ln371">			//| ((linecomp &amp; 0x400) &gt;&gt; 3)	</a>
<a name="ln372">			));</a>
<a name="ln373"> </a>
<a name="ln374">		/* more vertical extended regs */</a>
<a name="ln375">		CRTC2W(EXTRA,</a>
<a name="ln376">			(</a>
<a name="ln377">		 	((vtotal &amp; 0x800) &gt;&gt; (11 - 0)) |</a>
<a name="ln378">			((vdisp_e &amp; 0x800) &gt;&gt; (11 - 2)) |</a>
<a name="ln379">			((vsync_s &amp; 0x800) &gt;&gt; (11 - 4)) |</a>
<a name="ln380">			((vblnk_s &amp; 0x800) &gt;&gt; (11 - 6))</a>
<a name="ln381">			//fixme: do we miss another linecomp bit!?!</a>
<a name="ln382">			));</a>
<a name="ln383"> </a>
<a name="ln384">		/* setup 'large screen' mode */</a>
<a name="ln385">		if (target.timing.h_display &gt;= 1280)</a>
<a name="ln386">			CRTC2W(REPAINT1, (CRTC2R(REPAINT1) &amp; 0xfb));</a>
<a name="ln387">		else</a>
<a name="ln388">			CRTC2W(REPAINT1, (CRTC2R(REPAINT1) | 0x04));</a>
<a name="ln389"> </a>
<a name="ln390">		/* setup HSYNC &amp; VSYNC polarity */</a>
<a name="ln391">		LOG(2,(&quot;CRTC2: sync polarity: &quot;));</a>
<a name="ln392">		temp = NV_REG8(NV8_MISCR);</a>
<a name="ln393">		if (target.timing.flags &amp; B_POSITIVE_HSYNC)</a>
<a name="ln394">		{</a>
<a name="ln395">			LOG(2,(&quot;H:pos &quot;));</a>
<a name="ln396">			temp &amp;= ~0x40;</a>
<a name="ln397">		}</a>
<a name="ln398">		else</a>
<a name="ln399">		{</a>
<a name="ln400">			LOG(2,(&quot;H:neg &quot;));</a>
<a name="ln401">			temp |= 0x40;</a>
<a name="ln402">		}</a>
<a name="ln403">		if (target.timing.flags &amp; B_POSITIVE_VSYNC)</a>
<a name="ln404">		{</a>
<a name="ln405">			LOG(2,(&quot;V:pos &quot;));</a>
<a name="ln406">			temp &amp;= ~0x80;</a>
<a name="ln407">		}</a>
<a name="ln408">		else</a>
<a name="ln409">		{</a>
<a name="ln410">			LOG(2,(&quot;V:neg &quot;));</a>
<a name="ln411">			temp |= 0x80;</a>
<a name="ln412">		}</a>
<a name="ln413">		NV_REG8(NV8_MISCW) = temp;</a>
<a name="ln414"> </a>
<a name="ln415">		LOG(2,(&quot;, MISC reg readback: $%02x\n&quot;, NV_REG8(NV8_MISCR)));</a>
<a name="ln416">	}</a>
<a name="ln417"> </a>
<a name="ln418">	/* always disable interlaced operation */</a>
<a name="ln419">	/* (interlace is supported on upto and including NV10, NV15, and NV30 and up) */</a>
<a name="ln420">	CRTC2W(INTERLACE, 0xff);</a>
<a name="ln421"> </a>
<a name="ln422">	/* disable CRTC slaved mode unless a panel is in use */</a>
<a name="ln423">	// fixme: this kills TVout when it was in use...</a>
<a name="ln424">	if (!(si-&gt;ps.monitors &amp; CRTC2_TMDS)) CRTC2W(PIXEL, (CRTC2R(PIXEL) &amp; 0x7f));</a>
<a name="ln425"> </a>
<a name="ln426">	/* setup flatpanel if connected and active */</a>
<a name="ln427">	if (si-&gt;ps.monitors &amp; CRTC2_TMDS)</a>
<a name="ln428">	{</a>
<a name="ln429">		uint32 iscale_x, iscale_y;</a>
<a name="ln430"> </a>
<a name="ln431">		/* calculate inverse scaling factors used by hardware in 20.12 format */</a>
<a name="ln432">		iscale_x = (((1 &lt;&lt; 12) * target.timing.h_display) / si-&gt;ps.p2_timing.h_display);</a>
<a name="ln433">		iscale_y = (((1 &lt;&lt; 12) * target.timing.v_display) / si-&gt;ps.p2_timing.v_display);</a>
<a name="ln434"> </a>
<a name="ln435">		/* unblock flatpanel timing programming (or something like that..) */</a>
<a name="ln436">		CRTC2W(FP_HTIMING, 0);</a>
<a name="ln437">		CRTC2W(FP_VTIMING, 0);</a>
<a name="ln438">		LOG(2,(&quot;CRTC2: FP_HTIMING reg readback: $%02x\n&quot;, CRTC2R(FP_HTIMING)));</a>
<a name="ln439">		LOG(2,(&quot;CRTC2: FP_VTIMING reg readback: $%02x\n&quot;, CRTC2R(FP_VTIMING)));</a>
<a name="ln440"> </a>
<a name="ln441">		/* enable full width visibility on flatpanel */</a>
<a name="ln442">		DAC2W(FP_HVALID_S, 0);</a>
<a name="ln443">		DAC2W(FP_HVALID_E, (si-&gt;ps.p2_timing.h_display - 1));</a>
<a name="ln444">		/* enable full height visibility on flatpanel */</a>
<a name="ln445">		DAC2W(FP_VVALID_S, 0);</a>
<a name="ln446">		DAC2W(FP_VVALID_E, (si-&gt;ps.p2_timing.v_display - 1));</a>
<a name="ln447"> </a>
<a name="ln448">		/* nVidia cards support upscaling except on ??? */</a>
<a name="ln449">		/* NV11 cards can upscale after all! */</a>
<a name="ln450">		if (0)//si-&gt;ps.card_type == NV11)</a>
<a name="ln451">		{</a>
<a name="ln452">			/* disable last fetched line limiting */</a>
<a name="ln453">			DAC2W(FP_DEBUG2, 0x00000000);</a>
<a name="ln454">			/* inform panel to scale if needed */</a>
<a name="ln455">			if ((iscale_x != (1 &lt;&lt; 12)) || (iscale_y != (1 &lt;&lt; 12)))</a>
<a name="ln456">			{</a>
<a name="ln457">				LOG(2,(&quot;CRTC2: DFP needs to do scaling\n&quot;));</a>
<a name="ln458">				DAC2W(FP_TG_CTRL, (DAC2R(FP_TG_CTRL) | 0x00000100));</a>
<a name="ln459">			}</a>
<a name="ln460">			else</a>
<a name="ln461">			{</a>
<a name="ln462">				LOG(2,(&quot;CRTC2: no scaling for DFP needed\n&quot;));</a>
<a name="ln463">				DAC2W(FP_TG_CTRL, (DAC2R(FP_TG_CTRL) &amp; 0xfffffeff));</a>
<a name="ln464">			}</a>
<a name="ln465">		}</a>
<a name="ln466">		else</a>
<a name="ln467">		{</a>
<a name="ln468">			float dm_aspect;</a>
<a name="ln469"> </a>
<a name="ln470">			LOG(2,(&quot;CRTC2: GPU scales for DFP if needed\n&quot;));</a>
<a name="ln471"> </a>
<a name="ln472">			/* calculate display mode aspect */</a>
<a name="ln473">			dm_aspect = (target.timing.h_display / ((float)target.timing.v_display));</a>
<a name="ln474"> </a>
<a name="ln475">			/* limit last fetched line if vertical scaling is done */</a>
<a name="ln476">			if (iscale_y != (1 &lt;&lt; 12))</a>
<a name="ln477">				DAC2W(FP_DEBUG2, ((1 &lt;&lt; 28) | ((target.timing.v_display - 1) &lt;&lt; 16)));</a>
<a name="ln478">			else</a>
<a name="ln479">				DAC2W(FP_DEBUG2, 0x00000000);</a>
<a name="ln480"> </a>
<a name="ln481">			/* inform panel not to scale */</a>
<a name="ln482">			DAC2W(FP_TG_CTRL, (DAC2R(FP_TG_CTRL) &amp; 0xfffffeff));</a>
<a name="ln483"> </a>
<a name="ln484">			/* GPU scaling is automatically setup by hardware, so only modify this</a>
<a name="ln485">			 * scalingfactor for non 4:3 (1.33) aspect panels;</a>
<a name="ln486">			 * let's consider 1280x1024 1:33 aspect (it's 1.25 aspect actually!) */</a>
<a name="ln487"> </a>
<a name="ln488">			/* correct for widescreen panels relative to mode...</a>
<a name="ln489">			 * (so if panel is more widescreen than mode being set) */</a>
<a name="ln490">			/* BTW: known widescreen panels:</a>
<a name="ln491">			 * 1280 x  800 (1.60),</a>
<a name="ln492">			 * 1440 x  900 (1.60),</a>
<a name="ln493">			 * 1680 x 1050 (1.60),</a>
<a name="ln494">			 * 1920 x 1200 (1.60). */</a>
<a name="ln495">			/* known 4:3 aspect non-standard resolution panels:</a>
<a name="ln496">			 * 1400 x 1050 (1.33). */</a>
<a name="ln497">			/* NOTE:</a>
<a name="ln498">			 * allow 0.10 difference so 1280x1024 panels will be used fullscreen! */</a>
<a name="ln499">			if ((iscale_x != (1 &lt;&lt; 12)) &amp;&amp; (si-&gt;ps.crtc2_screen.aspect &gt; (dm_aspect + 0.10)))</a>
<a name="ln500">			{</a>
<a name="ln501">				uint16 diff;</a>
<a name="ln502"> </a>
<a name="ln503">				LOG(2,(&quot;CRTC2: (relative) widescreen panel: tuning horizontal scaling\n&quot;));</a>
<a name="ln504"> </a>
<a name="ln505">				/* X-scaling should be the same as Y-scaling */</a>
<a name="ln506">				iscale_x = iscale_y;</a>
<a name="ln507">				/* enable testmode (b12) and program new X-scaling factor */</a>
<a name="ln508">				DAC2W(FP_DEBUG1, (((iscale_x &gt;&gt; 1) &amp; 0x00000fff) | (1 &lt;&lt; 12)));</a>
<a name="ln509">				/* center/cut-off left and right side of screen */</a>
<a name="ln510">				diff = ((si-&gt;ps.p2_timing.h_display -</a>
<a name="ln511">						((target.timing.h_display * (1 &lt;&lt; 12)) / iscale_x))</a>
<a name="ln512">						/ 2);</a>
<a name="ln513">				DAC2W(FP_HVALID_S, diff);</a>
<a name="ln514">				DAC2W(FP_HVALID_E, ((si-&gt;ps.p2_timing.h_display - diff) - 1));</a>
<a name="ln515">			}</a>
<a name="ln516">			/* correct for portrait panels... */</a>
<a name="ln517">			/* NOTE:</a>
<a name="ln518">			 * allow 0.10 difference so 1280x1024 panels will be used fullscreen! */</a>
<a name="ln519">			if ((iscale_y != (1 &lt;&lt; 12)) &amp;&amp; (si-&gt;ps.crtc2_screen.aspect &lt; (dm_aspect - 0.10)))</a>
<a name="ln520">			{</a>
<a name="ln521">				LOG(2,(&quot;CRTC2: (relative) portrait panel: should tune vertical scaling\n&quot;));</a>
<a name="ln522">				/* fixme: implement if this kind of portrait panels exist on nVidia... */</a>
<a name="ln523">			}</a>
<a name="ln524">		}</a>
<a name="ln525"> </a>
<a name="ln526">		/* do some logging.. */</a>
<a name="ln527">		LOG(2,(&quot;CRTC2: FP_HVALID_S reg readback: $%08x\n&quot;, DAC2R(FP_HVALID_S)));</a>
<a name="ln528">		LOG(2,(&quot;CRTC2: FP_HVALID_E reg readback: $%08x\n&quot;, DAC2R(FP_HVALID_E)));</a>
<a name="ln529">		LOG(2,(&quot;CRTC2: FP_VVALID_S reg readback: $%08x\n&quot;, DAC2R(FP_VVALID_S)));</a>
<a name="ln530">		LOG(2,(&quot;CRTC2: FP_VVALID_E reg readback: $%08x\n&quot;, DAC2R(FP_VVALID_E)));</a>
<a name="ln531">		LOG(2,(&quot;CRTC2: FP_DEBUG0 reg readback: $%08x\n&quot;, DAC2R(FP_DEBUG0)));</a>
<a name="ln532">		LOG(2,(&quot;CRTC2: FP_DEBUG1 reg readback: $%08x\n&quot;, DAC2R(FP_DEBUG1)));</a>
<a name="ln533">		LOG(2,(&quot;CRTC2: FP_DEBUG2 reg readback: $%08x\n&quot;, DAC2R(FP_DEBUG2)));</a>
<a name="ln534">		LOG(2,(&quot;CRTC2: FP_DEBUG3 reg readback: $%08x\n&quot;, DAC2R(FP_DEBUG3)));</a>
<a name="ln535">		LOG(2,(&quot;CRTC2: FP_TG_CTRL reg readback: $%08x\n&quot;, DAC2R(FP_TG_CTRL)));</a>
<a name="ln536">	}</a>
<a name="ln537"> </a>
<a name="ln538">	return B_OK;</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">status_t nv_crtc2_depth(int mode)</a>
<a name="ln542">{</a>
<a name="ln543">	uint8 viddelay = 0;</a>
<a name="ln544">	uint32 genctrl = 0;</a>
<a name="ln545"> </a>
<a name="ln546">	/* set VCLK scaling */</a>
<a name="ln547">	switch(mode)</a>
<a name="ln548">	{</a>
<a name="ln549">	case BPP8:</a>
<a name="ln550">		viddelay = 0x01;</a>
<a name="ln551">		/* genctrl b4 &amp; b5 reset: 'direct mode' */</a>
<a name="ln552">		genctrl = 0x00101100;</a>
<a name="ln553">		break;</a>
<a name="ln554">	case BPP15:</a>
<a name="ln555">		viddelay = 0x02;</a>
<a name="ln556">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln557">		genctrl = 0x00100130;</a>
<a name="ln558">		break;</a>
<a name="ln559">	case BPP16:</a>
<a name="ln560">		viddelay = 0x02;</a>
<a name="ln561">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln562">		genctrl = 0x00101130;</a>
<a name="ln563">		break;</a>
<a name="ln564">	case BPP24:</a>
<a name="ln565">		viddelay = 0x03;</a>
<a name="ln566">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln567">		genctrl = 0x00100130;</a>
<a name="ln568">		break;</a>
<a name="ln569">	case BPP32:</a>
<a name="ln570">		viddelay = 0x03;</a>
<a name="ln571">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln572">		genctrl = 0x00101130;</a>
<a name="ln573">		break;</a>
<a name="ln574">	}</a>
<a name="ln575">	/* enable access to secondary head */</a>
<a name="ln576">	set_crtc_owner(1);</a>
<a name="ln577"> </a>
<a name="ln578">	CRTC2W(PIXEL, ((CRTC2R(PIXEL) &amp; 0xfc) | viddelay));</a>
<a name="ln579">	DAC2W(GENCTRL, genctrl);</a>
<a name="ln580"> </a>
<a name="ln581">	return B_OK;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">status_t nv_crtc2_dpms(bool display, bool h, bool v, bool do_panel)</a>
<a name="ln585">{</a>
<a name="ln586">	uint8 temp;</a>
<a name="ln587">	char msg[100];</a>
<a name="ln588"> </a>
<a name="ln589">	strlcpy(msg, &quot;CRTC2: setting DPMS: &quot;, sizeof(msg));</a>
<a name="ln590"> </a>
<a name="ln591">	/* enable access to secondary head */</a>
<a name="ln592">	set_crtc_owner(1);</a>
<a name="ln593"> </a>
<a name="ln594">	/* start synchronous reset: required before turning screen off! */</a>
<a name="ln595">	SEQW(RESET, 0x01);</a>
<a name="ln596"> </a>
<a name="ln597">	temp = SEQR(CLKMODE);</a>
<a name="ln598">	if (display)</a>
<a name="ln599">	{</a>
<a name="ln600">		/* turn screen on */</a>
<a name="ln601">		SEQW(CLKMODE, (temp &amp; ~0x20));</a>
<a name="ln602"> </a>
<a name="ln603">		/* end synchronous reset because display should be enabled */</a>
<a name="ln604">		SEQW(RESET, 0x03);</a>
<a name="ln605"> </a>
<a name="ln606">		if (do_panel &amp;&amp; (si-&gt;ps.monitors &amp; CRTC2_TMDS))</a>
<a name="ln607">		{</a>
<a name="ln608">			if (!si-&gt;ps.laptop)</a>
<a name="ln609">			{</a>
<a name="ln610">				/* restore original panelsync and panel-enable */</a>
<a name="ln611">				uint32 panelsync = 0x00000000;</a>
<a name="ln612">				if(si-&gt;ps.p2_timing.flags &amp; B_POSITIVE_VSYNC) panelsync |= 0x00000001;</a>
<a name="ln613">				if(si-&gt;ps.p2_timing.flags &amp; B_POSITIVE_HSYNC) panelsync |= 0x00000010;</a>
<a name="ln614">				/* display enable polarity (not an official flag) */</a>
<a name="ln615">				if(si-&gt;ps.p2_timing.flags &amp; B_BLANK_PEDESTAL) panelsync |= 0x10000000;</a>
<a name="ln616">				DAC2W(FP_TG_CTRL, ((DAC2R(FP_TG_CTRL) &amp; 0xcfffffcc) | panelsync));</a>
<a name="ln617"> </a>
<a name="ln618">				//fixme?: looks like we don't need this after all:</a>
<a name="ln619">				/* powerup both LVDS (laptop panellink) and TMDS (DVI panellink)</a>
<a name="ln620">				 * internal transmitters... */</a>
<a name="ln621">				/* note:</a>
<a name="ln622">				 * the powerbits in this register are hardwired to the DVI connectors,</a>
<a name="ln623">				 * instead of to the DACs! (confirmed NV34) */</a>
<a name="ln624">				//fixme...</a>
<a name="ln625">				//DAC2W(FP_DEBUG0, (DAC2R(FP_DEBUG0) &amp; 0xcfffffff));</a>
<a name="ln626">				/* ... and powerup external TMDS transmitter if it exists */</a>
<a name="ln627">				/* (confirmed OK on NV28 and NV34) */</a>
<a name="ln628">				//CRTC2W(0x59, (CRTC2R(0x59) | 0x01));</a>
<a name="ln629"> </a>
<a name="ln630">				strlcat(msg, &quot;(panel-)&quot;, sizeof(msg));</a>
<a name="ln631">			}</a>
<a name="ln632">			else</a>
<a name="ln633">			{</a>
<a name="ln634">				//fixme: see if LVDS head can be determined with two panels there...</a>
<a name="ln635">				if (!(si-&gt;ps.monitors &amp; CRTC1_TMDS) &amp;&amp; (si-&gt;ps.card_type != NV11))</a>
<a name="ln636">				{</a>
<a name="ln637">					/* b2 = 0 = enable laptop panel backlight */</a>
<a name="ln638">					/* note: this seems to be a write-only register. */</a>
<a name="ln639">					NV_REG32(NV32_LVDS_PWR) = 0x00000003;</a>
<a name="ln640"> </a>
<a name="ln641">					strlcat(msg, &quot;(panel-)&quot;, sizeof(msg));</a>
<a name="ln642">				}</a>
<a name="ln643">			}</a>
<a name="ln644">		}</a>
<a name="ln645"> </a>
<a name="ln646">		strlcat(msg, &quot;display on, &quot;, sizeof(msg));</a>
<a name="ln647">	}</a>
<a name="ln648">	else</a>
<a name="ln649">	{</a>
<a name="ln650">		/* turn screen off */</a>
<a name="ln651">		SEQW(CLKMODE, (temp | 0x20));</a>
<a name="ln652"> </a>
<a name="ln653">		if (do_panel &amp;&amp; (si-&gt;ps.monitors &amp; CRTC2_TMDS))</a>
<a name="ln654">		{</a>
<a name="ln655">			if (!si-&gt;ps.laptop)</a>
<a name="ln656">			{</a>
<a name="ln657">				/* shutoff panelsync and disable panel */</a>
<a name="ln658">				DAC2W(FP_TG_CTRL, ((DAC2R(FP_TG_CTRL) &amp; 0xcfffffcc) | 0x20000022));</a>
<a name="ln659"> </a>
<a name="ln660">				//fixme?: looks like we don't need this after all:</a>
<a name="ln661">				/* powerdown both LVDS (laptop panellink) and TMDS (DVI panellink)</a>
<a name="ln662">				 * internal transmitters... */</a>
<a name="ln663">				/* note:</a>
<a name="ln664">				 * the powerbits in this register are hardwired to the DVI connectors,</a>
<a name="ln665">				 * instead of to the DACs! (confirmed NV34) */</a>
<a name="ln666">				//fixme...</a>
<a name="ln667">				//DAC2W(FP_DEBUG0, (DAC2R(FP_DEBUG0) | 0x30000000));</a>
<a name="ln668">				/* ... and powerdown external TMDS transmitter if it exists */</a>
<a name="ln669">				/* (confirmed OK on NV28 and NV34) */</a>
<a name="ln670">				//CRTC2W(0x59, (CRTC2R(0x59) &amp; 0xfe));</a>
<a name="ln671"> </a>
<a name="ln672">				strlcat(msg, &quot;(panel-)&quot;, sizeof(msg));</a>
<a name="ln673">			}</a>
<a name="ln674">			else</a>
<a name="ln675">			{</a>
<a name="ln676">				//fixme: see if LVDS head can be determined with two panels there...</a>
<a name="ln677">				if (!(si-&gt;ps.monitors &amp; CRTC1_TMDS) &amp;&amp; (si-&gt;ps.card_type != NV11))</a>
<a name="ln678">				{</a>
<a name="ln679">					/* b2 = 1 = disable laptop panel backlight */</a>
<a name="ln680">					/* note: this seems to be a write-only register. */</a>
<a name="ln681">					NV_REG32(NV32_LVDS_PWR) = 0x00000007;</a>
<a name="ln682"> </a>
<a name="ln683">					strlcat(msg, &quot;(panel-)&quot;, sizeof(msg));</a>
<a name="ln684">				}</a>
<a name="ln685">			}</a>
<a name="ln686">		}</a>
<a name="ln687"> </a>
<a name="ln688">		strlcat(msg, &quot;display off, &quot;, sizeof(msg));</a>
<a name="ln689">	}</a>
<a name="ln690"> </a>
<a name="ln691">	if (h)</a>
<a name="ln692">	{</a>
<a name="ln693">		CRTC2W(REPAINT1, (CRTC2R(REPAINT1) &amp; 0x7f));</a>
<a name="ln694">		strlcat(msg, &quot;hsync enabled, &quot;, sizeof(msg));</a>
<a name="ln695">	}</a>
<a name="ln696">	else</a>
<a name="ln697">	{</a>
<a name="ln698">		CRTC2W(REPAINT1, (CRTC2R(REPAINT1) | 0x80));</a>
<a name="ln699">		strlcat(msg, &quot;hsync disabled, &quot;, sizeof(msg));</a>
<a name="ln700">	}</a>
<a name="ln701">	if (v)</a>
<a name="ln702">	{</a>
<a name="ln703">		CRTC2W(REPAINT1, (CRTC2R(REPAINT1) &amp; 0xbf));</a>
<a name="ln704">		strlcat(msg, &quot;vsync enabled\n&quot;, sizeof(msg));</a>
<a name="ln705">	}</a>
<a name="ln706">	else</a>
<a name="ln707">	{</a>
<a name="ln708">		CRTC2W(REPAINT1, (CRTC2R(REPAINT1) | 0x40));</a>
<a name="ln709">		strlcat(msg, &quot;vsync disabled\n&quot;, sizeof(msg));</a>
<a name="ln710">	}</a>
<a name="ln711"> </a>
<a name="ln712">	LOG(4, (msg));</a>
<a name="ln713"> </a>
<a name="ln714">	return B_OK;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">status_t nv_crtc2_set_display_pitch() </a>
<a name="ln718">{</a>
<a name="ln719">	uint32 offset;</a>
<a name="ln720"> </a>
<a name="ln721">	LOG(4,(&quot;CRTC2: setting card pitch (offset between lines)\n&quot;));</a>
<a name="ln722"> </a>
<a name="ln723">	/* figure out offset value hardware needs */</a>
<a name="ln724">	offset = si-&gt;fbc.bytes_per_row / 8;</a>
<a name="ln725"> </a>
<a name="ln726">	LOG(2,(&quot;CRTC2: offset register set to: $%04x\n&quot;, offset));</a>
<a name="ln727"> </a>
<a name="ln728">	/* enable access to secondary head */</a>
<a name="ln729">	set_crtc_owner(1);</a>
<a name="ln730"> </a>
<a name="ln731">	/* program the card */</a>
<a name="ln732">	CRTC2W(PITCHL, (offset &amp; 0x00ff));</a>
<a name="ln733">	CRTC2W(REPAINT0, ((CRTC2R(REPAINT0) &amp; 0x1f) | ((offset &amp; 0x0700) &gt;&gt; 3)));</a>
<a name="ln734"> </a>
<a name="ln735">	return B_OK;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">status_t nv_crtc2_set_display_start(uint32 startadd,uint8 bpp) </a>
<a name="ln739">{</a>
<a name="ln740">	uint32 timeout = 0;</a>
<a name="ln741"> </a>
<a name="ln742">	LOG(4,(&quot;CRTC2: setting card RAM to be displayed bpp %d\n&quot;, bpp));</a>
<a name="ln743"> </a>
<a name="ln744">	LOG(2,(&quot;CRTC2: startadd: $%08x\n&quot;, startadd));</a>
<a name="ln745">	LOG(2,(&quot;CRTC2: frameRAM: $%08x\n&quot;, si-&gt;framebuffer));</a>
<a name="ln746">	LOG(2,(&quot;CRTC2: framebuffer: $%08x\n&quot;, si-&gt;fbc.frame_buffer));</a>
<a name="ln747"> </a>
<a name="ln748">	/* we might have no retraces during setmode! */</a>
<a name="ln749">	/* wait 25mS max. for retrace to occur (refresh &gt; 40Hz) */</a>
<a name="ln750">	while (((NV_REG32(NV32_RASTER2) &amp; 0x000007ff) &lt; si-&gt;dm.timing.v_display) &amp;&amp;</a>
<a name="ln751">			(timeout &lt; (25000/10)))</a>
<a name="ln752">	{</a>
<a name="ln753">		/* don't snooze much longer or retrace might get missed! */</a>
<a name="ln754">		snooze(10);</a>
<a name="ln755">		timeout++;</a>
<a name="ln756">	}</a>
<a name="ln757"> </a>
<a name="ln758">	/* enable access to secondary head */</a>
<a name="ln759">	set_crtc_owner(1);</a>
<a name="ln760"> </a>
<a name="ln761">	/* upto 4Gb RAM adressing: must be used on NV10 and later! */</a>
<a name="ln762">	/* NOTE:</a>
<a name="ln763">	 * While this register also exists on pre-NV10 cards, it will</a>
<a name="ln764">	 * wrap-around at 16Mb boundaries!! */</a>
<a name="ln765"> </a>
<a name="ln766">	/* 30bit adress in 32bit words */</a>
<a name="ln767">	NV_REG32(NV32_NV10FB2STADD32) = (startadd &amp; 0xfffffffc);</a>
<a name="ln768"> </a>
<a name="ln769">	/* set byte adress: (b0 - 1) */</a>
<a name="ln770">	ATB2W(HORPIXPAN, ((startadd &amp; 0x00000003) &lt;&lt; 1));</a>
<a name="ln771"> </a>
<a name="ln772">	return B_OK;</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">status_t nv_crtc2_cursor_init()</a>
<a name="ln776">{</a>
<a name="ln777">	int i;</a>
<a name="ln778">	vuint32 * fb;</a>
<a name="ln779">	/* cursor bitmap will be stored at the start of the framebuffer */</a>
<a name="ln780">	const uint32 curadd = 0;</a>
<a name="ln781"> </a>
<a name="ln782">	/* enable access to secondary head */</a>
<a name="ln783">	set_crtc_owner(1);</a>
<a name="ln784"> </a>
<a name="ln785">	/* set cursor bitmap adress ... */</a>
<a name="ln786">	if (si-&gt;ps.laptop)</a>
<a name="ln787">	{</a>
<a name="ln788">		/* must be used this way on pre-NV10 and on all 'Go' cards! */</a>
<a name="ln789"> </a>
<a name="ln790">		/* cursorbitmap must start on 2Kbyte boundary: */</a>
<a name="ln791">		/* set adress bit11-16, and set 'no doublescan' (registerbit 1 = 0) */</a>
<a name="ln792">		CRTC2W(CURCTL0, ((curadd &amp; 0x0001f800) &gt;&gt; 9));</a>
<a name="ln793">		/* set adress bit17-23, and set graphics mode cursor(?) (registerbit 7 = 1) */</a>
<a name="ln794">		CRTC2W(CURCTL1, (((curadd &amp; 0x00fe0000) &gt;&gt; 17) | 0x80));</a>
<a name="ln795">		/* set adress bit24-31 */</a>
<a name="ln796">		CRTC2W(CURCTL2, ((curadd &amp; 0xff000000) &gt;&gt; 24));</a>
<a name="ln797">	}</a>
<a name="ln798">	else</a>
<a name="ln799">	{</a>
<a name="ln800">		/* upto 4Gb RAM adressing:</a>
<a name="ln801">		 * can be used on NV10 and later (except for 'Go' cards)! */</a>
<a name="ln802">		/* NOTE:</a>
<a name="ln803">		 * This register does not exist on pre-NV10 and 'Go' cards. */</a>
<a name="ln804"> </a>
<a name="ln805">		/* cursorbitmap must still start on 2Kbyte boundary: */</a>
<a name="ln806">		NV_REG32(NV32_NV10CUR2ADD32) = (curadd &amp; 0xfffff800);</a>
<a name="ln807">	}</a>
<a name="ln808"> </a>
<a name="ln809">	/* set cursor colour: not needed because of direct nature of cursor bitmap. */</a>
<a name="ln810"> </a>
<a name="ln811">	/*clear cursor*/</a>
<a name="ln812">	fb = (vuint32 *) si-&gt;framebuffer + curadd;</a>
<a name="ln813">	for (i=0;i&lt;(2048/4);i++)</a>
<a name="ln814">	{</a>
<a name="ln815">		fb[i]=0;</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	/* select 32x32 pixel, 16bit color cursorbitmap, no doublescan */</a>
<a name="ln819">	NV_REG32(NV32_2CURCONF) = 0x02000100;</a>
<a name="ln820"> </a>
<a name="ln821">	/* activate hardware-sync between cursor updates and vertical retrace */</a>
<a name="ln822">	DAC2W(NV10_CURSYNC, (DAC2R(NV10_CURSYNC) | 0x02000000));</a>
<a name="ln823"> </a>
<a name="ln824">	/* activate hardware cursor */</a>
<a name="ln825">	nv_crtc2_cursor_show();</a>
<a name="ln826"> </a>
<a name="ln827">	return B_OK;</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">status_t nv_crtc2_cursor_show()</a>
<a name="ln831">{</a>
<a name="ln832">	LOG(4,(&quot;CRTC2: enabling cursor\n&quot;));</a>
<a name="ln833"> </a>
<a name="ln834">	/* enable access to secondary head */</a>
<a name="ln835">	set_crtc_owner(1);</a>
<a name="ln836"> </a>
<a name="ln837">	/* b0 = 1 enables cursor */</a>
<a name="ln838">	CRTC2W(CURCTL0, (CRTC2R(CURCTL0) | 0x01));</a>
<a name="ln839"> </a>
<a name="ln840">	/* workaround for hardware bug confirmed existing on NV43:</a>
<a name="ln841">	 * Cursor visibility is not updated without a position update if its hardware</a>
<a name="ln842">	 * retrace sync is enabled. */</a>
<a name="ln843">	if (si-&gt;ps.card_arch == NV40A) DAC2W(CURPOS, (DAC2R(CURPOS)));</a>
<a name="ln844"> </a>
<a name="ln845">	return B_OK;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">status_t nv_crtc2_cursor_hide()</a>
<a name="ln849">{</a>
<a name="ln850">	LOG(4,(&quot;CRTC2: disabling cursor\n&quot;));</a>
<a name="ln851"> </a>
<a name="ln852">	/* enable access to secondary head */</a>
<a name="ln853">	set_crtc_owner(1);</a>
<a name="ln854"> </a>
<a name="ln855">	/* b0 = 0 disables cursor */</a>
<a name="ln856">	CRTC2W(CURCTL0, (CRTC2R(CURCTL0) &amp; 0xfe));</a>
<a name="ln857"> </a>
<a name="ln858">	/* workaround for hardware bug confirmed existing on NV43:</a>
<a name="ln859">	 * Cursor visibility is not updated without a position update if its hardware</a>
<a name="ln860">	 * retrace sync is enabled. */</a>
<a name="ln861">	if (si-&gt;ps.card_arch == NV40A) DAC2W(CURPOS, (DAC2R(CURPOS)));</a>
<a name="ln862"> </a>
<a name="ln863">	return B_OK;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">/*set up cursor shape*/</a>
<a name="ln867">status_t nv_crtc2_cursor_define(uint8* andMask,uint8* xorMask)</a>
<a name="ln868">{</a>
<a name="ln869">	int x, y;</a>
<a name="ln870">	uint8 b;</a>
<a name="ln871">	vuint16 *cursor;</a>
<a name="ln872">	uint16 pixel;</a>
<a name="ln873"> </a>
<a name="ln874">	/* get a pointer to the cursor */</a>
<a name="ln875">	cursor = (vuint16*) si-&gt;framebuffer;</a>
<a name="ln876"> </a>
<a name="ln877">	/* draw the cursor */</a>
<a name="ln878">	/* (Nvidia cards have a RGB15 direct color cursor bitmap, bit #16 is transparancy) */</a>
<a name="ln879">	for (y = 0; y &lt; 16; y++)</a>
<a name="ln880">	{</a>
<a name="ln881">		b = 0x80;</a>
<a name="ln882">		for (x = 0; x &lt; 8; x++)</a>
<a name="ln883">		{</a>
<a name="ln884">			/* preset transparant */</a>
<a name="ln885">			pixel = 0x0000;</a>
<a name="ln886">			/* set white if requested */</a>
<a name="ln887">			if ((!(*andMask &amp; b)) &amp;&amp; (!(*xorMask &amp; b))) pixel = 0xffff;</a>
<a name="ln888">			/* set black if requested */</a>
<a name="ln889">			if ((!(*andMask &amp; b)) &amp;&amp;   (*xorMask &amp; b))  pixel = 0x8000;</a>
<a name="ln890">			/* set invert if requested */</a>
<a name="ln891">			if (  (*andMask &amp; b)  &amp;&amp;   (*xorMask &amp; b))  pixel = 0x7fff;</a>
<a name="ln892">			/* place the pixel in the bitmap */</a>
<a name="ln893">			cursor[x + (y * 32)] = pixel;</a>
<a name="ln894">			b &gt;&gt;= 1;</a>
<a name="ln895">		}</a>
<a name="ln896">		xorMask++;</a>
<a name="ln897">		andMask++;</a>
<a name="ln898">		b = 0x80;</a>
<a name="ln899">		for (; x &lt; 16; x++)</a>
<a name="ln900">		{</a>
<a name="ln901">			/* preset transparant */</a>
<a name="ln902">			pixel = 0x0000;</a>
<a name="ln903">			/* set white if requested */</a>
<a name="ln904">			if ((!(*andMask &amp; b)) &amp;&amp; (!(*xorMask &amp; b))) pixel = 0xffff;</a>
<a name="ln905">			/* set black if requested */</a>
<a name="ln906">			if ((!(*andMask &amp; b)) &amp;&amp;   (*xorMask &amp; b))  pixel = 0x8000;</a>
<a name="ln907">			/* set invert if requested */</a>
<a name="ln908">			if (  (*andMask &amp; b)  &amp;&amp;   (*xorMask &amp; b))  pixel = 0x7fff;</a>
<a name="ln909">			/* place the pixel in the bitmap */</a>
<a name="ln910">			cursor[x + (y * 32)] = pixel;</a>
<a name="ln911">			b &gt;&gt;= 1;</a>
<a name="ln912">		}</a>
<a name="ln913">		xorMask++;</a>
<a name="ln914">		andMask++;</a>
<a name="ln915">	}</a>
<a name="ln916"> </a>
<a name="ln917">	return B_OK;</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">/* position the cursor */</a>
<a name="ln921">status_t nv_crtc2_cursor_position(uint16 x, uint16 y)</a>
<a name="ln922">{</a>
<a name="ln923">	/* the cursor position is updated during retrace by card hardware */</a>
<a name="ln924"> </a>
<a name="ln925">	/* update cursorposition */</a>
<a name="ln926">	DAC2W(CURPOS, ((x &amp; 0x0fff) | ((y &amp; 0x0fff) &lt;&lt; 16)));</a>
<a name="ln927"> </a>
<a name="ln928">	return B_OK;</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">status_t nv_crtc2_stop_tvout(void)</a>
<a name="ln932">{</a>
<a name="ln933">	uint16 cnt;</a>
<a name="ln934"> </a>
<a name="ln935">	LOG(4,(&quot;CRTC2: stopping TV output\n&quot;));</a>
<a name="ln936"> </a>
<a name="ln937">	/* enable access to secondary head */</a>
<a name="ln938">	set_crtc_owner(1);</a>
<a name="ln939"> </a>
<a name="ln940">	/* just to be sure Vsync is _really_ enabled */</a>
<a name="ln941">	CRTC2W(REPAINT1, (CRTC2R(REPAINT1) &amp; 0xbf));</a>
<a name="ln942"> </a>
<a name="ln943">	/* wait for one image to be generated to make sure VGA has kicked in and is</a>
<a name="ln944">	 * running OK before continuing...</a>
<a name="ln945">	 * (Kicking in will fail often if we do not wait here) */</a>
<a name="ln946">	/* Note:</a>
<a name="ln947">	 * The used CRTC's Vsync is required to be enabled here. The DPMS state</a>
<a name="ln948">	 * programming in the driver makes sure this is the case.</a>
<a name="ln949">	 * (except for driver startup: see nv_general.c.) */</a>
<a name="ln950"> </a>
<a name="ln951">	/* make sure we are 'in' active VGA picture: wait with timeout! */</a>
<a name="ln952">	cnt = 1;</a>
<a name="ln953">	while ((NV_REG8(NV8_INSTAT1) &amp; 0x08) &amp;&amp; cnt)</a>
<a name="ln954">	{</a>
<a name="ln955">		snooze(1);</a>
<a name="ln956">		cnt++;</a>
<a name="ln957">	}</a>
<a name="ln958">	/* wait for next vertical retrace start on VGA: wait with timeout! */</a>
<a name="ln959">	cnt = 1;</a>
<a name="ln960">	while ((!(NV_REG8(NV8_INSTAT1) &amp; 0x08)) &amp;&amp; cnt)</a>
<a name="ln961">	{</a>
<a name="ln962">		snooze(1);</a>
<a name="ln963">		cnt++;</a>
<a name="ln964">	}</a>
<a name="ln965">	/* now wait until we are 'in' active VGA picture again: wait with timeout! */</a>
<a name="ln966">	cnt = 1;</a>
<a name="ln967">	while ((NV_REG8(NV8_INSTAT1) &amp; 0x08) &amp;&amp; cnt)</a>
<a name="ln968">	{</a>
<a name="ln969">		snooze(1);</a>
<a name="ln970">		cnt++;</a>
<a name="ln971">	}</a>
<a name="ln972"> </a>
<a name="ln973">	/* set CRTC to master mode (b7 = 0) if it wasn't slaved for a panel before */</a>
<a name="ln974">	if (!(si-&gt;ps.slaved_tmds2))	CRTC2W(PIXEL, (CRTC2R(PIXEL) &amp; 0x03));</a>
<a name="ln975"> </a>
<a name="ln976">	/* CAUTION:</a>
<a name="ln977">	 * On old cards, PLLSEL (and TV_SETUP?) cannot be read (sometimes?), but</a>
<a name="ln978">	 * write actions do succeed ...</a>
<a name="ln979">	 * This is confirmed for both ISA and PCI access, on NV04 and NV11. */</a>
<a name="ln980"> </a>
<a name="ln981">	/* setup TVencoder connection */</a>
<a name="ln982">	/* b1-0 = %00: encoder type is SLAVE;</a>
<a name="ln983">	 * b24 = 1: VIP datapos is b0-7 */</a>
<a name="ln984">	//fixme if needed: setup completely instead of relying on pre-init by BIOS..</a>
<a name="ln985">	//(it seems to work OK on NV04 and NV11 although read reg. doesn't seem to work)</a>
<a name="ln986">	DAC2W(TV_SETUP, ((DAC2R(TV_SETUP) &amp; ~0x00000003) | 0x01000000));</a>
<a name="ln987"> </a>
<a name="ln988">	/* tell GPU to use pixelclock from internal source instead of using TVencoder */</a>
<a name="ln989">	DACW(PLLSEL, 0x30000f00);</a>
<a name="ln990"> </a>
<a name="ln991">	/* HTOTAL, VTOTAL and OVERFLOW return their default CRTC use, instead of</a>
<a name="ln992">	 * H, V-low and V-high 'shadow' counters(?)(b0, 4 and 6 = 0) (b7 use = unknown) */</a>
<a name="ln993">	CRTC2W(TREG, 0x00);</a>
<a name="ln994"> </a>
<a name="ln995">	/* select panel encoder, not TV encoder if needed (b0 = 1).</a>
<a name="ln996">	 * Note:</a>
<a name="ln997">	 * Both are devices (often) using the CRTC in slaved mode. */</a>
<a name="ln998">	if (si-&gt;ps.slaved_tmds2) CRTC2W(LCD, (CRTC2R(LCD) | 0x01));</a>
<a name="ln999"> </a>
<a name="ln1000">	return B_OK;</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">status_t nv_crtc2_start_tvout(void)</a>
<a name="ln1004">{</a>
<a name="ln1005">	LOG(4,(&quot;CRTC2: starting TV output\n&quot;));</a>
<a name="ln1006"> </a>
<a name="ln1007">	/* switch TV encoder to CRTC2 */</a>
<a name="ln1008">	NV_REG32(NV32_FUNCSEL) &amp;= ~0x00000100;</a>
<a name="ln1009">	NV_REG32(NV32_2FUNCSEL) |= 0x00000100;</a>
<a name="ln1010"> </a>
<a name="ln1011">	/* enable access to secondary head */</a>
<a name="ln1012">	set_crtc_owner(1);</a>
<a name="ln1013"> </a>
<a name="ln1014">	/* CAUTION:</a>
<a name="ln1015">	 * On old cards, PLLSEL (and TV_SETUP?) cannot be read (sometimes?), but</a>
<a name="ln1016">	 * write actions do succeed ...</a>
<a name="ln1017">	 * This is confirmed for both ISA and PCI access, on NV04 and NV11. */</a>
<a name="ln1018"> </a>
<a name="ln1019">	/* setup TVencoder connection */</a>
<a name="ln1020">	/* b1-0 = %01: encoder type is MASTER;</a>
<a name="ln1021">	 * b24 = 1: VIP datapos is b0-7 */</a>
<a name="ln1022">	//fixme if needed: setup completely instead of relying on pre-init by BIOS..</a>
<a name="ln1023">	//(it seems to work OK on NV04 and NV11 although read reg. doesn't seem to work)</a>
<a name="ln1024">	DAC2W(TV_SETUP, ((DAC2R(TV_SETUP) &amp; ~0x00000002) | 0x01000001));</a>
<a name="ln1025"> </a>
<a name="ln1026">	/* tell GPU to use pixelclock from TVencoder instead of using internal source */</a>
<a name="ln1027">	/* (nessecary or display will 'shiver' on both TV and VGA.) */</a>
<a name="ln1028">	DACW(PLLSEL, 0x100c0f00);</a>
<a name="ln1029"> </a>
<a name="ln1030">	/* Set overscan color to 'black' */</a>
<a name="ln1031">	/* note:</a>
<a name="ln1032">	 * Change this instruction for a visible overscan color if you're trying to</a>
<a name="ln1033">	 * center the output on TV. Use it as a guide-'line' then ;-) */</a>
<a name="ln1034">	ATB2W(OSCANCOLOR, 0x00);</a>
<a name="ln1035"> </a>
<a name="ln1036">	/* set CRTC to slaved mode (b7 = 1) and clear TVadjust (b3-5 = %000) */</a>
<a name="ln1037">	CRTC2W(PIXEL, ((CRTC2R(PIXEL) &amp; 0xc7) | 0x80));</a>
<a name="ln1038">	/* select TV encoder, not panel encoder (b0 = 0).</a>
<a name="ln1039">	 * Note:</a>
<a name="ln1040">	 * Both are devices (often) using the CRTC in slaved mode. */</a>
<a name="ln1041">	CRTC2W(LCD, (CRTC2R(LCD) &amp; 0xfe));</a>
<a name="ln1042"> </a>
<a name="ln1043">	/* HTOTAL, VTOTAL and OVERFLOW return their default CRTC use, instead of</a>
<a name="ln1044">	 * H, V-low and V-high 'shadow' counters(?)(b0, 4 and 6 = 0) (b7 use = unknown) */</a>
<a name="ln1045">	CRTC2W(TREG, 0x80);</a>
<a name="ln1046"> </a>
<a name="ln1047">	return B_OK;</a>
<a name="ln1048">}</a>

</code></pre>
<div class="balloon" rel="806"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="796"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="792"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
