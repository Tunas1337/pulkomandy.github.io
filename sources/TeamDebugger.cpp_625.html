
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>TeamDebugger.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2012, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2010-2017, Rene Gollent, rene@gollent.com.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;controllers/TeamDebugger.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;stdarg.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;new&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;Entry.h&gt;</a>
<a name="ln16">#include &lt;InterfaceDefs.h&gt;</a>
<a name="ln17">#include &lt;Message.h&gt;</a>
<a name="ln18">#include &lt;StringList.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln21">#include &lt;AutoLocker.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;debug_utils.h&quot;</a>
<a name="ln24">#include &quot;syscall_numbers.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;Architecture.h&quot;</a>
<a name="ln27">#include &quot;BreakpointManager.h&quot;</a>
<a name="ln28">#include &quot;BreakpointSetting.h&quot;</a>
<a name="ln29">#include &quot;CpuState.h&quot;</a>
<a name="ln30">#include &quot;DebugEvent.h&quot;</a>
<a name="ln31">#include &quot;DebuggerInterface.h&quot;</a>
<a name="ln32">#include &quot;DebugReportGenerator.h&quot;</a>
<a name="ln33">#include &quot;ExpressionInfo.h&quot;</a>
<a name="ln34">#include &quot;FileManager.h&quot;</a>
<a name="ln35">#include &quot;Function.h&quot;</a>
<a name="ln36">#include &quot;FunctionID.h&quot;</a>
<a name="ln37">#include &quot;ImageDebugInfo.h&quot;</a>
<a name="ln38">#include &quot;ImageDebugInfoLoadingState.h&quot;</a>
<a name="ln39">#include &quot;ImageDebugLoadingStateHandler.h&quot;</a>
<a name="ln40">#include &quot;ImageDebugLoadingStateHandlerRoster.h&quot;</a>
<a name="ln41">#include &quot;Jobs.h&quot;</a>
<a name="ln42">#include &quot;LocatableFile.h&quot;</a>
<a name="ln43">#include &quot;MessageCodes.h&quot;</a>
<a name="ln44">#include &quot;NoOpSettingsManager.h&quot;</a>
<a name="ln45">#include &quot;SettingsManager.h&quot;</a>
<a name="ln46">#include &quot;SourceCode.h&quot;</a>
<a name="ln47">#include &quot;SourceLanguage.h&quot;</a>
<a name="ln48">#include &quot;SpecificImageDebugInfo.h&quot;</a>
<a name="ln49">#include &quot;SpecificImageDebugInfoLoadingState.h&quot;</a>
<a name="ln50">#include &quot;StackFrame.h&quot;</a>
<a name="ln51">#include &quot;StackFrameValues.h&quot;</a>
<a name="ln52">#include &quot;Statement.h&quot;</a>
<a name="ln53">#include &quot;SymbolInfo.h&quot;</a>
<a name="ln54">#include &quot;TeamDebugInfo.h&quot;</a>
<a name="ln55">#include &quot;TeamInfo.h&quot;</a>
<a name="ln56">#include &quot;TeamMemoryBlock.h&quot;</a>
<a name="ln57">#include &quot;TeamMemoryBlockManager.h&quot;</a>
<a name="ln58">#include &quot;TeamSettings.h&quot;</a>
<a name="ln59">#include &quot;TeamSignalSettings.h&quot;</a>
<a name="ln60">#include &quot;TeamUiSettings.h&quot;</a>
<a name="ln61">#include &quot;Tracing.h&quot;</a>
<a name="ln62">#include &quot;ValueNode.h&quot;</a>
<a name="ln63">#include &quot;ValueNodeContainer.h&quot;</a>
<a name="ln64">#include &quot;Variable.h&quot;</a>
<a name="ln65">#include &quot;WatchpointManager.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">// #pragma mark - ImageHandler</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">struct TeamDebugger::ImageHandler : public BReferenceable,</a>
<a name="ln72">	private LocatableFile::Listener {</a>
<a name="ln73">public:</a>
<a name="ln74">	ImageHandler(TeamDebugger* teamDebugger, Image* image)</a>
<a name="ln75">		:</a>
<a name="ln76">		fTeamDebugger(teamDebugger),</a>
<a name="ln77">		fImage(image)</a>
<a name="ln78">	{</a>
<a name="ln79">		fImage-&gt;AcquireReference();</a>
<a name="ln80">		if (fImage-&gt;ImageFile() != NULL)</a>
<a name="ln81">			fImage-&gt;ImageFile()-&gt;AddListener(this);</a>
<a name="ln82">	}</a>
<a name="ln83"> </a>
<a name="ln84">	~ImageHandler()</a>
<a name="ln85">	{</a>
<a name="ln86">		if (fImage-&gt;ImageFile() != NULL)</a>
<a name="ln87">			fImage-&gt;ImageFile()-&gt;RemoveListener(this);</a>
<a name="ln88">		fImage-&gt;ReleaseReference();</a>
<a name="ln89">	}</a>
<a name="ln90"> </a>
<a name="ln91">	Image* GetImage() const</a>
<a name="ln92">	{</a>
<a name="ln93">		return fImage;</a>
<a name="ln94">	}</a>
<a name="ln95"> </a>
<a name="ln96">	image_id ImageID() const</a>
<a name="ln97">	{</a>
<a name="ln98">		return fImage-&gt;ID();</a>
<a name="ln99">	}</a>
<a name="ln100"> </a>
<a name="ln101">private:</a>
<a name="ln102">	// LocatableFile::Listener</a>
<a name="ln103">	virtual void LocatableFileChanged(LocatableFile* file)</a>
<a name="ln104">	{</a>
<a name="ln105">		BMessage message(MSG_IMAGE_FILE_CHANGED);</a>
<a name="ln106">		message.AddInt32(&quot;image&quot;, fImage-&gt;ID());</a>
<a name="ln107">		fTeamDebugger-&gt;PostMessage(&amp;message);</a>
<a name="ln108">	}</a>
<a name="ln109"> </a>
<a name="ln110">private:</a>
<a name="ln111">	TeamDebugger*	fTeamDebugger;</a>
<a name="ln112">	Image*			fImage;</a>
<a name="ln113"> </a>
<a name="ln114">public:</a>
<a name="ln115">	ImageHandler*	fNext;</a>
<a name="ln116">};</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">// #pragma mark - ImageHandlerHashDefinition</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">struct TeamDebugger::ImageHandlerHashDefinition {</a>
<a name="ln123">	typedef image_id		KeyType;</a>
<a name="ln124">	typedef	ImageHandler	ValueType;</a>
<a name="ln125"> </a>
<a name="ln126">	size_t HashKey(image_id key) const</a>
<a name="ln127">	{</a>
<a name="ln128">		return (size_t)key;</a>
<a name="ln129">	}</a>
<a name="ln130"> </a>
<a name="ln131">	size_t Hash(const ImageHandler* value) const</a>
<a name="ln132">	{</a>
<a name="ln133">		return HashKey(value-&gt;ImageID());</a>
<a name="ln134">	}</a>
<a name="ln135"> </a>
<a name="ln136">	bool Compare(image_id key, const ImageHandler* value) const</a>
<a name="ln137">	{</a>
<a name="ln138">		return value-&gt;ImageID() == key;</a>
<a name="ln139">	}</a>
<a name="ln140"> </a>
<a name="ln141">	ImageHandler*&amp; GetLink(ImageHandler* value) const</a>
<a name="ln142">	{</a>
<a name="ln143">		return value-&gt;fNext;</a>
<a name="ln144">	}</a>
<a name="ln145">};</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">// #pragma mark - ImageInfoPendingThread</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">struct TeamDebugger::ImageInfoPendingThread {</a>
<a name="ln152">public:</a>
<a name="ln153">	ImageInfoPendingThread(image_id image, thread_id thread)</a>
<a name="ln154">		:</a>
<a name="ln155">		fImage(image),</a>
<a name="ln156">		fThread(thread)</a>
<a name="ln157">	{</a>
<a name="ln158">	}</a>
<a name="ln159"> </a>
<a name="ln160">	~ImageInfoPendingThread()</a>
<a name="ln161">	{</a>
<a name="ln162">	}</a>
<a name="ln163"> </a>
<a name="ln164">	image_id ImageID() const</a>
<a name="ln165">	{</a>
<a name="ln166">		return fImage;</a>
<a name="ln167">	}</a>
<a name="ln168"> </a>
<a name="ln169">	thread_id ThreadID() const</a>
<a name="ln170">	{</a>
<a name="ln171">		return fThread;</a>
<a name="ln172">	}</a>
<a name="ln173"> </a>
<a name="ln174">private:</a>
<a name="ln175">	image_id				fImage;</a>
<a name="ln176">	thread_id				fThread;</a>
<a name="ln177"> </a>
<a name="ln178">public:</a>
<a name="ln179">	ImageInfoPendingThread*	fNext;</a>
<a name="ln180">};</a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">// #pragma mark - ImageHandlerHashDefinition</a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186">struct TeamDebugger::ImageInfoPendingThreadHashDefinition {</a>
<a name="ln187">	typedef image_id				KeyType;</a>
<a name="ln188">	typedef	ImageInfoPendingThread	ValueType;</a>
<a name="ln189"> </a>
<a name="ln190">	size_t HashKey(image_id key) const</a>
<a name="ln191">	{</a>
<a name="ln192">		return (size_t)key;</a>
<a name="ln193">	}</a>
<a name="ln194"> </a>
<a name="ln195">	size_t Hash(const ImageInfoPendingThread* value) const</a>
<a name="ln196">	{</a>
<a name="ln197">		return HashKey(value-&gt;ImageID());</a>
<a name="ln198">	}</a>
<a name="ln199"> </a>
<a name="ln200">	bool Compare(image_id key, const ImageInfoPendingThread* value) const</a>
<a name="ln201">	{</a>
<a name="ln202">		return value-&gt;ImageID() == key;</a>
<a name="ln203">	}</a>
<a name="ln204"> </a>
<a name="ln205">	ImageInfoPendingThread*&amp; GetLink(ImageInfoPendingThread* value) const</a>
<a name="ln206">	{</a>
<a name="ln207">		return value-&gt;fNext;</a>
<a name="ln208">	}</a>
<a name="ln209">};</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">// #pragma mark - TeamDebugger</a>
<a name="ln213"> </a>
<a name="ln214"> </a>
<a name="ln215">TeamDebugger::TeamDebugger(Listener* listener, UserInterface* userInterface,</a>
<a name="ln216">	SettingsManager* settingsManager)</a>
<a name="ln217">	:</a>
<a name="ln218">	BLooper(&quot;team debugger&quot;),</a>
<a name="ln219">	fListener(listener),</a>
<a name="ln220">	fSettingsManager(settingsManager),</a>
<a name="ln221">	fTeam(NULL),</a>
<a name="ln222">	fTeamID(-1),</a>
<a name="ln223">	fIsPostMortem(false),</a>
<a name="ln224">	fImageHandlers(NULL),</a>
<a name="ln225">	fImageInfoPendingThreads(NULL),</a>
<a name="ln226">	fDebuggerInterface(NULL),</a>
<a name="ln227">	fFileManager(NULL),</a>
<a name="ln228">	fWorker(NULL),</a>
<a name="ln229">	fBreakpointManager(NULL),</a>
<a name="ln230">	fWatchpointManager(NULL),</a>
<a name="ln231">	fMemoryBlockManager(NULL),</a>
<a name="ln232">	fReportGenerator(NULL),</a>
<a name="ln233">	fDebugEventListener(-1),</a>
<a name="ln234">	fUserInterface(userInterface),</a>
<a name="ln235">	fTerminating(false),</a>
<a name="ln236">	fKillTeamOnQuit(false),</a>
<a name="ln237">	fCommandLineArgc(0),</a>
<a name="ln238">	fCommandLineArgv(NULL),</a>
<a name="ln239">	fExecPending(false)</a>
<a name="ln240">{</a>
<a name="ln241">	fUserInterface-&gt;AcquireReference();</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244"> </a>
<a name="ln245">TeamDebugger::~TeamDebugger()</a>
<a name="ln246">{</a>
<a name="ln247">	if (fTeam != NULL)</a>
<a name="ln248">		_SaveSettings();</a>
<a name="ln249"> </a>
<a name="ln250">	AutoLocker&lt;BLooper&gt; locker(this);</a>
<a name="ln251"> </a>
<a name="ln252">	fTerminating = true;</a>
<a name="ln253"> </a>
<a name="ln254">	if (fDebuggerInterface != NULL) {</a>
<a name="ln255">		fDebuggerInterface-&gt;Close(fKillTeamOnQuit);</a>
<a name="ln256">		fDebuggerInterface-&gt;ReleaseReference();</a>
<a name="ln257">	}</a>
<a name="ln258"> </a>
<a name="ln259">	if (fWorker != NULL)</a>
<a name="ln260">		fWorker-&gt;ShutDown();</a>
<a name="ln261"> </a>
<a name="ln262">	locker.Unlock();</a>
<a name="ln263"> </a>
<a name="ln264">	if (fDebugEventListener &gt;= 0)</a>
<a name="ln265">		wait_for_thread(fDebugEventListener, NULL);</a>
<a name="ln266"> </a>
<a name="ln267">	// terminate UI</a>
<a name="ln268">	if (fUserInterface != NULL) {</a>
<a name="ln269">		fUserInterface-&gt;Terminate();</a>
<a name="ln270">		fUserInterface-&gt;ReleaseReference();</a>
<a name="ln271">	}</a>
<a name="ln272"> </a>
<a name="ln273">	ThreadHandler* threadHandler = fThreadHandlers.Clear(true);</a>
<a name="ln274">	while (threadHandler != NULL) {</a>
<a name="ln275">		ThreadHandler* next = threadHandler-&gt;fNext;</a>
<a name="ln276">		threadHandler-&gt;ReleaseReference();</a>
<a name="ln277">		threadHandler = next;</a>
<a name="ln278">	}</a>
<a name="ln279"> </a>
<a name="ln280">	if (fImageHandlers != NULL) {</a>
<a name="ln281">		ImageHandler* imageHandler = fImageHandlers-&gt;Clear(true);</a>
<a name="ln282">		while (imageHandler != NULL) {</a>
<a name="ln283">			ImageHandler* next = imageHandler-&gt;fNext;</a>
<a name="ln284">			imageHandler-&gt;ReleaseReference();</a>
<a name="ln285">			imageHandler = next;</a>
<a name="ln286">		}</a>
<a name="ln287">	}</a>
<a name="ln288"> </a>
<a name="ln289">	delete fImageHandlers;</a>
<a name="ln290"> </a>
<a name="ln291">	if (fImageInfoPendingThreads != NULL) {</a>
<a name="ln292">		ImageInfoPendingThread* thread = fImageInfoPendingThreads-&gt;Clear(true);</a>
<a name="ln293">		while (thread != NULL) {</a>
<a name="ln294">			ImageInfoPendingThread* next = thread-&gt;fNext;</a>
<a name="ln295">			delete thread;</a>
<a name="ln296">			thread = next;</a>
<a name="ln297">		}</a>
<a name="ln298">	}</a>
<a name="ln299"> </a>
<a name="ln300">	if (fReportGenerator != NULL) {</a>
<a name="ln301">		fReportGenerator-&gt;Lock();</a>
<a name="ln302">		fReportGenerator-&gt;Quit();</a>
<a name="ln303">	}</a>
<a name="ln304"> </a>
<a name="ln305">	delete fWorker;</a>
<a name="ln306"> </a>
<a name="ln307">	delete fImageInfoPendingThreads;</a>
<a name="ln308"> </a>
<a name="ln309">	delete fBreakpointManager;</a>
<a name="ln310">	delete fWatchpointManager;</a>
<a name="ln311">	delete fMemoryBlockManager;</a>
<a name="ln312">	delete fTeam;</a>
<a name="ln313">	delete fFileManager;</a>
<a name="ln314"> </a>
<a name="ln315">	for (int i = 0; i &lt; fCommandLineArgc; i++) {</a>
<a name="ln316">		if (fCommandLineArgv[i] != NULL)</a>
<a name="ln317">			free(const_cast&lt;char*&gt;(fCommandLineArgv[i]));</a>
<a name="ln318">	}</a>
<a name="ln319"> </a>
<a name="ln320">	delete [] fCommandLineArgv;</a>
<a name="ln321"> </a>
<a name="ln322">	fListener-&gt;TeamDebuggerQuit(this);</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">status_t</a>
<a name="ln327">TeamDebugger::Init(DebuggerInterface* interface, thread_id threadID, int argc,</a>
<a name="ln328">	const char* const* argv, bool stopInMain)</a>
<a name="ln329">{</a>
<a name="ln330">	bool targetIsLocal = true;</a>
<a name="ln331">		// TODO: Support non-local targets!</a>
<a name="ln332"> </a>
<a name="ln333">	// the first thing we want to do when running</a>
<a name="ln334">	PostMessage(MSG_LOAD_SETTINGS);</a>
<a name="ln335"> </a>
<a name="ln336">	status_t error = _HandleSetArguments(argc, argv);</a>
<a name="ln337">	if (error != B_OK)</a>
<a name="ln338">		return error;</a>
<a name="ln339"> </a>
<a name="ln340">	if (fSettingsManager == NULL) {</a>
<a name="ln341">		// if we have not been provided with a settings manager,</a>
<a name="ln342">		// simply use the no-op manager by default.</a>
<a name="ln343">		fSettingsManager = new(std::nothrow) NoOpSettingsManager;</a>
<a name="ln344">		if (fSettingsManager == NULL)</a>
<a name="ln345">			return B_NO_MEMORY;</a>
<a name="ln346">	}</a>
<a name="ln347"> </a>
<a name="ln348">	fDebuggerInterface = interface;</a>
<a name="ln349">	fDebuggerInterface-&gt;AcquireReference();</a>
<a name="ln350">	fTeamID = interface-&gt;TeamID();</a>
<a name="ln351">	fIsPostMortem = interface-&gt;IsPostMortem();</a>
<a name="ln352"> </a>
<a name="ln353"> </a>
<a name="ln354">	// create file manager</a>
<a name="ln355">	fFileManager = new(std::nothrow) FileManager;</a>
<a name="ln356">	if (fFileManager == NULL)</a>
<a name="ln357">		return B_NO_MEMORY;</a>
<a name="ln358"> </a>
<a name="ln359">	error = fFileManager-&gt;Init(targetIsLocal);</a>
<a name="ln360">	if (error != B_OK)</a>
<a name="ln361">		return error;</a>
<a name="ln362"> </a>
<a name="ln363">	// create team debug info</a>
<a name="ln364">	TeamDebugInfo* teamDebugInfo = new(std::nothrow) TeamDebugInfo(</a>
<a name="ln365">		fDebuggerInterface, fDebuggerInterface-&gt;GetArchitecture(),</a>
<a name="ln366">		fFileManager);</a>
<a name="ln367">	if (teamDebugInfo == NULL)</a>
<a name="ln368">		return B_NO_MEMORY;</a>
<a name="ln369">	BReference&lt;TeamDebugInfo&gt; teamDebugInfoReference(teamDebugInfo, true);</a>
<a name="ln370"> </a>
<a name="ln371">	error = teamDebugInfo-&gt;Init();</a>
<a name="ln372">	if (error != B_OK)</a>
<a name="ln373">		return error;</a>
<a name="ln374"> </a>
<a name="ln375">	// check whether the team exists at all</a>
<a name="ln376">	TeamInfo teamInfo;</a>
<a name="ln377">	error = fDebuggerInterface-&gt;GetTeamInfo(teamInfo);</a>
<a name="ln378">	if (error != B_OK)</a>
<a name="ln379">		return error;</a>
<a name="ln380"> </a>
<a name="ln381">	// create a team object</a>
<a name="ln382">	fTeam = new(std::nothrow) ::Team(fTeamID, fDebuggerInterface,</a>
<a name="ln383">		fDebuggerInterface-&gt;GetArchitecture(), teamDebugInfo,</a>
<a name="ln384">		teamDebugInfo);</a>
<a name="ln385">	if (fTeam == NULL)</a>
<a name="ln386">		return B_NO_MEMORY;</a>
<a name="ln387"> </a>
<a name="ln388">	error = fTeam-&gt;Init();</a>
<a name="ln389">	if (error != B_OK)</a>
<a name="ln390">		return error;</a>
<a name="ln391">	fTeam-&gt;SetName(teamInfo.Arguments());</a>
<a name="ln392">		// TODO: Set a better name!</a>
<a name="ln393"> </a>
<a name="ln394">	fTeam-&gt;AddListener(this);</a>
<a name="ln395"> </a>
<a name="ln396">	// init thread handler table</a>
<a name="ln397">	error = fThreadHandlers.Init();</a>
<a name="ln398">	if (error != B_OK)</a>
<a name="ln399">		return error;</a>
<a name="ln400"> </a>
<a name="ln401">	// create image handler table</a>
<a name="ln402">	fImageHandlers = new(std::nothrow) ImageHandlerTable;</a>
<a name="ln403">	if (fImageHandlers == NULL)</a>
<a name="ln404">		return B_NO_MEMORY;</a>
<a name="ln405"> </a>
<a name="ln406">	error = fImageHandlers-&gt;Init();</a>
<a name="ln407">	if (error != B_OK)</a>
<a name="ln408">		return error;</a>
<a name="ln409"> </a>
<a name="ln410">	fImageInfoPendingThreads = new(std::nothrow) ImageInfoPendingThreadTable;</a>
<a name="ln411">	if (fImageInfoPendingThreads == NULL)</a>
<a name="ln412">		return B_NO_MEMORY;</a>
<a name="ln413"> </a>
<a name="ln414">	// create our worker</a>
<a name="ln415">	fWorker = new(std::nothrow) Worker;</a>
<a name="ln416">	if (fWorker == NULL)</a>
<a name="ln417">		return B_NO_MEMORY;</a>
<a name="ln418"> </a>
<a name="ln419">	error = fWorker-&gt;Init();</a>
<a name="ln420">	if (error != B_OK)</a>
<a name="ln421">		return error;</a>
<a name="ln422"> </a>
<a name="ln423">	// create the breakpoint manager</a>
<a name="ln424">	fBreakpointManager = new(std::nothrow) BreakpointManager(fTeam,</a>
<a name="ln425">		fDebuggerInterface);</a>
<a name="ln426">	if (fBreakpointManager == NULL)</a>
<a name="ln427">		return B_NO_MEMORY;</a>
<a name="ln428"> </a>
<a name="ln429">	error = fBreakpointManager-&gt;Init();</a>
<a name="ln430">	if (error != B_OK)</a>
<a name="ln431">		return error;</a>
<a name="ln432"> </a>
<a name="ln433">	// create the watchpoint manager</a>
<a name="ln434">	fWatchpointManager = new(std::nothrow) WatchpointManager(fTeam,</a>
<a name="ln435">		fDebuggerInterface);</a>
<a name="ln436">	if (fWatchpointManager == NULL)</a>
<a name="ln437">		return B_NO_MEMORY;</a>
<a name="ln438"> </a>
<a name="ln439">	error = fWatchpointManager-&gt;Init();</a>
<a name="ln440">	if (error != B_OK)</a>
<a name="ln441">		return error;</a>
<a name="ln442"> </a>
<a name="ln443">	// create the memory block manager</a>
<a name="ln444">	fMemoryBlockManager = new(std::nothrow) TeamMemoryBlockManager();</a>
<a name="ln445">	if (fMemoryBlockManager == NULL)</a>
<a name="ln446">		return B_NO_MEMORY;</a>
<a name="ln447"> </a>
<a name="ln448">	error = fMemoryBlockManager-&gt;Init();</a>
<a name="ln449">	if (error != B_OK)</a>
<a name="ln450">		return error;</a>
<a name="ln451"> </a>
<a name="ln452">	// create the debug report generator</a>
<a name="ln453">	fReportGenerator = new(std::nothrow) DebugReportGenerator(fTeam, this,</a>
<a name="ln454">		fDebuggerInterface);</a>
<a name="ln455">	if (fReportGenerator == NULL)</a>
<a name="ln456">		return B_NO_MEMORY;</a>
<a name="ln457"> </a>
<a name="ln458">	error = fReportGenerator-&gt;Init();</a>
<a name="ln459">	if (error != B_OK)</a>
<a name="ln460">		return error;</a>
<a name="ln461"> </a>
<a name="ln462">	// set team debugging flags</a>
<a name="ln463">	fDebuggerInterface-&gt;SetTeamDebuggingFlags(</a>
<a name="ln464">		B_TEAM_DEBUG_THREADS | B_TEAM_DEBUG_IMAGES</a>
<a name="ln465">			| B_TEAM_DEBUG_POST_SYSCALL | B_TEAM_DEBUG_SIGNALS</a>
<a name="ln466">			| B_TEAM_DEBUG_TEAM_CREATION);</a>
<a name="ln467"> </a>
<a name="ln468">	// get the initial state of the team</a>
<a name="ln469">	AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln470"> </a>
<a name="ln471">	ThreadHandler* mainThreadHandler = NULL;</a>
<a name="ln472">	{</a>
<a name="ln473">		BObjectList&lt;ThreadInfo&gt; threadInfos(20, true);</a>
<a name="ln474">		status_t error = fDebuggerInterface-&gt;GetThreadInfos(threadInfos);</a>
<a name="ln475">		for (int32 i = 0; ThreadInfo* info = threadInfos.ItemAt(i); i++) {</a>
<a name="ln476">			::Thread* thread;</a>
<a name="ln477">			error = fTeam-&gt;AddThread(*info, &amp;thread);</a>
<a name="ln478">			if (error != B_OK)</a>
<a name="ln479">				return error;</a>
<a name="ln480"> </a>
<a name="ln481">			ThreadHandler* handler = new(std::nothrow) ThreadHandler(thread,</a>
<a name="ln482">				fWorker, fDebuggerInterface, this, fBreakpointManager);</a>
<a name="ln483">			if (handler == NULL)</a>
<a name="ln484">				return B_NO_MEMORY;</a>
<a name="ln485"> </a>
<a name="ln486">			fThreadHandlers.Insert(handler);</a>
<a name="ln487"> </a>
<a name="ln488">			if (thread-&gt;IsMainThread())</a>
<a name="ln489">				mainThreadHandler = handler;</a>
<a name="ln490"> </a>
<a name="ln491">			handler-&gt;Init();</a>
<a name="ln492">		}</a>
<a name="ln493">	}</a>
<a name="ln494"> </a>
<a name="ln495">	Image* appImage = NULL;</a>
<a name="ln496">	{</a>
<a name="ln497">		BObjectList&lt;ImageInfo&gt; imageInfos(20, true);</a>
<a name="ln498">		status_t error = fDebuggerInterface-&gt;GetImageInfos(imageInfos);</a>
<a name="ln499">		for (int32 i = 0; ImageInfo* info = imageInfos.ItemAt(i); i++) {</a>
<a name="ln500">			Image* image;</a>
<a name="ln501">			error = _AddImage(*info, &amp;image);</a>
<a name="ln502">			if (error != B_OK)</a>
<a name="ln503">				return error;</a>
<a name="ln504">			if (image-&gt;Type() == B_APP_IMAGE)</a>
<a name="ln505">				appImage = image;</a>
<a name="ln506"> </a>
<a name="ln507">			ImageDebugInfoRequested(image);</a>
<a name="ln508">		}</a>
<a name="ln509">	}</a>
<a name="ln510"> </a>
<a name="ln511">	// create the debug event listener (for live debugging only)</a>
<a name="ln512">	if (!fDebuggerInterface-&gt;IsPostMortem()) {</a>
<a name="ln513">		char buffer[128];</a>
<a name="ln514">		snprintf(buffer, sizeof(buffer), &quot;team %&quot; B_PRId32 &quot; debug listener&quot;,</a>
<a name="ln515">			fTeamID);</a>
<a name="ln516">		fDebugEventListener = spawn_thread(_DebugEventListenerEntry, buffer,</a>
<a name="ln517">			B_NORMAL_PRIORITY, this);</a>
<a name="ln518">		if (fDebugEventListener &lt; 0)</a>
<a name="ln519">			return fDebugEventListener;</a>
<a name="ln520"> </a>
<a name="ln521">		resume_thread(fDebugEventListener);</a>
<a name="ln522">	}</a>
<a name="ln523"> </a>
<a name="ln524">	// run looper</a>
<a name="ln525">	thread_id looperThread = Run();</a>
<a name="ln526">	if (looperThread &lt; 0)</a>
<a name="ln527">		return looperThread;</a>
<a name="ln528"> </a>
<a name="ln529">	// init the UI</a>
<a name="ln530">	error = fUserInterface-&gt;Init(fTeam, this);</a>
<a name="ln531">	if (error != B_OK) {</a>
<a name="ln532">		ERROR(&quot;Error: Failed to init the UI: %s\n&quot;, strerror(error));</a>
<a name="ln533">		return error;</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	// if requested, stop the given thread</a>
<a name="ln537">	if (threadID &gt;= 0 &amp;&amp; !fDebuggerInterface-&gt;IsPostMortem()) {</a>
<a name="ln538">		if (stopInMain) {</a>
<a name="ln539">			SymbolInfo symbolInfo;</a>
<a name="ln540">			if (appImage != NULL &amp;&amp; mainThreadHandler != NULL</a>
<a name="ln541">				&amp;&amp; fDebuggerInterface-&gt;GetSymbolInfo(</a>
<a name="ln542">					fTeam-&gt;ID(), appImage-&gt;ID(), &quot;main&quot;, B_SYMBOL_TYPE_TEXT,</a>
<a name="ln543">					symbolInfo) == B_OK) {</a>
<a name="ln544">				mainThreadHandler-&gt;SetBreakpointAndRun(symbolInfo.Address());</a>
<a name="ln545">			}</a>
<a name="ln546">		} else {</a>
<a name="ln547">			debug_thread(threadID);</a>
<a name="ln548">				// TODO: Superfluous, if the thread is already stopped.</a>
<a name="ln549">		}</a>
<a name="ln550">	}</a>
<a name="ln551"> </a>
<a name="ln552">	fListener-&gt;TeamDebuggerStarted(this);</a>
<a name="ln553"> </a>
<a name="ln554">	return B_OK;</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557"> </a>
<a name="ln558">void</a>
<a name="ln559">TeamDebugger::Activate()</a>
<a name="ln560">{</a>
<a name="ln561">	fUserInterface-&gt;Show();</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">void</a>
<a name="ln566">TeamDebugger::MessageReceived(BMessage* message)</a>
<a name="ln567">{</a>
<a name="ln568">	switch (message-&gt;what) {</a>
<a name="ln569">		case MSG_THREAD_RUN:</a>
<a name="ln570">		case MSG_THREAD_SET_ADDRESS:</a>
<a name="ln571">		case MSG_THREAD_STOP:</a>
<a name="ln572">		case MSG_THREAD_STEP_OVER:</a>
<a name="ln573">		case MSG_THREAD_STEP_INTO:</a>
<a name="ln574">		case MSG_THREAD_STEP_OUT:</a>
<a name="ln575">		{</a>
<a name="ln576">			int32 threadID;</a>
<a name="ln577">			target_addr_t address;</a>
<a name="ln578">			if (message-&gt;FindInt32(&quot;thread&quot;, &amp;threadID) != B_OK)</a>
<a name="ln579">				break;</a>
<a name="ln580"> </a>
<a name="ln581">			if (message-&gt;FindUInt64(&quot;address&quot;, &amp;address) != B_OK)</a>
<a name="ln582">				address = 0;</a>
<a name="ln583"> </a>
<a name="ln584">			if (ThreadHandler* handler = _GetThreadHandler(threadID)) {</a>
<a name="ln585">				handler-&gt;HandleThreadAction(message-&gt;what, address);</a>
<a name="ln586">				handler-&gt;ReleaseReference();</a>
<a name="ln587">			}</a>
<a name="ln588">			break;</a>
<a name="ln589">		}</a>
<a name="ln590"> </a>
<a name="ln591">		case MSG_SET_BREAKPOINT:</a>
<a name="ln592">		case MSG_CLEAR_BREAKPOINT:</a>
<a name="ln593">		{</a>
<a name="ln594">			UserBreakpoint* breakpoint = NULL;</a>
<a name="ln595">			BReference&lt;UserBreakpoint&gt; breakpointReference;</a>
<a name="ln596">			uint64 address = 0;</a>
<a name="ln597"> </a>
<a name="ln598">			if (message-&gt;FindPointer(&quot;breakpoint&quot;, (void**)&amp;breakpoint)</a>
<a name="ln599">				== B_OK) {</a>
<a name="ln600">				breakpointReference.SetTo(breakpoint, true);</a>
<a name="ln601">			} else if (message-&gt;FindUInt64(&quot;address&quot;, &amp;address) != B_OK)</a>
<a name="ln602">				break;</a>
<a name="ln603"> </a>
<a name="ln604">			if (message-&gt;what == MSG_SET_BREAKPOINT) {</a>
<a name="ln605">				bool enabled;</a>
<a name="ln606">				if (message-&gt;FindBool(&quot;enabled&quot;, &amp;enabled) != B_OK)</a>
<a name="ln607">					enabled = true;</a>
<a name="ln608"> </a>
<a name="ln609">				bool hidden;</a>
<a name="ln610">				if (message-&gt;FindBool(&quot;hidden&quot;, &amp;hidden) != B_OK)</a>
<a name="ln611">					hidden = false;</a>
<a name="ln612"> </a>
<a name="ln613">				if (breakpoint != NULL)</a>
<a name="ln614">					_HandleSetUserBreakpoint(breakpoint, enabled);</a>
<a name="ln615">				else</a>
<a name="ln616">					_HandleSetUserBreakpoint(address, enabled, hidden);</a>
<a name="ln617">			} else {</a>
<a name="ln618">				if (breakpoint != NULL)</a>
<a name="ln619">					_HandleClearUserBreakpoint(breakpoint);</a>
<a name="ln620">				else</a>
<a name="ln621">					_HandleClearUserBreakpoint(address);</a>
<a name="ln622">			}</a>
<a name="ln623"> </a>
<a name="ln624">			break;</a>
<a name="ln625">		}</a>
<a name="ln626"> </a>
<a name="ln627">		case MSG_SET_BREAKPOINT_CONDITION:</a>
<a name="ln628">		{</a>
<a name="ln629">			UserBreakpoint* breakpoint = NULL;</a>
<a name="ln630">			BReference&lt;UserBreakpoint&gt; breakpointReference;</a>
<a name="ln631">			if (message-&gt;FindPointer(&quot;breakpoint&quot;, (void**)&amp;breakpoint)</a>
<a name="ln632">				!= B_OK) {</a>
<a name="ln633">				break;</a>
<a name="ln634">			}</a>
<a name="ln635"> </a>
<a name="ln636">			breakpointReference.SetTo(breakpoint, true);</a>
<a name="ln637"> </a>
<a name="ln638">			const char* condition;</a>
<a name="ln639">			if (message-&gt;FindString(&quot;condition&quot;, &amp;condition) != B_OK)</a>
<a name="ln640">				break;</a>
<a name="ln641"> </a>
<a name="ln642">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln643">			breakpoint-&gt;SetCondition(condition);</a>
<a name="ln644">			fTeam-&gt;NotifyUserBreakpointChanged(breakpoint);</a>
<a name="ln645"> </a>
<a name="ln646">			break;</a>
<a name="ln647">		}</a>
<a name="ln648"> </a>
<a name="ln649">		case MSG_CLEAR_BREAKPOINT_CONDITION:</a>
<a name="ln650">		{</a>
<a name="ln651">			UserBreakpoint* breakpoint = NULL;</a>
<a name="ln652">			BReference&lt;UserBreakpoint&gt; breakpointReference;</a>
<a name="ln653">			if (message-&gt;FindPointer(&quot;breakpoint&quot;, (void**)&amp;breakpoint)</a>
<a name="ln654">				!= B_OK)</a>
<a name="ln655">				break;</a>
<a name="ln656"> </a>
<a name="ln657">			breakpointReference.SetTo(breakpoint, true);</a>
<a name="ln658"> </a>
<a name="ln659">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln660">			breakpoint-&gt;SetCondition(NULL);</a>
<a name="ln661">			fTeam-&gt;NotifyUserBreakpointChanged(breakpoint);</a>
<a name="ln662"> </a>
<a name="ln663">			break;</a>
<a name="ln664">		}</a>
<a name="ln665"> </a>
<a name="ln666">		case MSG_STOP_ON_IMAGE_LOAD:</a>
<a name="ln667">		{</a>
<a name="ln668">			bool enabled;</a>
<a name="ln669">			bool useNames;</a>
<a name="ln670">			if (message-&gt;FindBool(&quot;enabled&quot;, &amp;enabled) != B_OK)</a>
<a name="ln671">				break;</a>
<a name="ln672"> </a>
<a name="ln673">			if (message-&gt;FindBool(&quot;useNames&quot;, &amp;useNames) != B_OK)</a>
<a name="ln674">				break;</a>
<a name="ln675"> </a>
<a name="ln676">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln677">			fTeam-&gt;SetStopOnImageLoad(enabled, useNames);</a>
<a name="ln678">			break;</a>
<a name="ln679">		}</a>
<a name="ln680"> </a>
<a name="ln681">		case MSG_ADD_STOP_IMAGE_NAME:</a>
<a name="ln682">		{</a>
<a name="ln683">			BString imageName;</a>
<a name="ln684">			if (message-&gt;FindString(&quot;name&quot;, &amp;imageName) != B_OK)</a>
<a name="ln685">				break;</a>
<a name="ln686"> </a>
<a name="ln687">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln688">			fTeam-&gt;AddStopImageName(imageName);</a>
<a name="ln689">			break;</a>
<a name="ln690">		}</a>
<a name="ln691"> </a>
<a name="ln692">		case MSG_REMOVE_STOP_IMAGE_NAME:</a>
<a name="ln693">		{</a>
<a name="ln694">			BString imageName;</a>
<a name="ln695">			if (message-&gt;FindString(&quot;name&quot;, &amp;imageName) != B_OK)</a>
<a name="ln696">				break;</a>
<a name="ln697"> </a>
<a name="ln698">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln699">			fTeam-&gt;RemoveStopImageName(imageName);</a>
<a name="ln700">			break;</a>
<a name="ln701">		}</a>
<a name="ln702"> </a>
<a name="ln703">		case MSG_SET_DEFAULT_SIGNAL_DISPOSITION:</a>
<a name="ln704">		{</a>
<a name="ln705">			int32 disposition;</a>
<a name="ln706">			if (message-&gt;FindInt32(&quot;disposition&quot;, &amp;disposition) != B_OK)</a>
<a name="ln707">				break;</a>
<a name="ln708"> </a>
<a name="ln709">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln710">			fTeam-&gt;SetDefaultSignalDisposition(disposition);</a>
<a name="ln711">			break;</a>
<a name="ln712">		}</a>
<a name="ln713"> </a>
<a name="ln714">		case MSG_SET_CUSTOM_SIGNAL_DISPOSITION:</a>
<a name="ln715">		{</a>
<a name="ln716">			int32 signal;</a>
<a name="ln717">			int32 disposition;</a>
<a name="ln718">			if (message-&gt;FindInt32(&quot;signal&quot;, &amp;signal) != B_OK</a>
<a name="ln719">				|| message-&gt;FindInt32(&quot;disposition&quot;, &amp;disposition) != B_OK) {</a>
<a name="ln720">				break;</a>
<a name="ln721">			}</a>
<a name="ln722"> </a>
<a name="ln723">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln724">			fTeam-&gt;SetCustomSignalDisposition(signal, disposition);</a>
<a name="ln725">			break;</a>
<a name="ln726">		}</a>
<a name="ln727"> </a>
<a name="ln728">		case MSG_REMOVE_CUSTOM_SIGNAL_DISPOSITION:</a>
<a name="ln729">		{</a>
<a name="ln730">			int32 signal;</a>
<a name="ln731">			if (message-&gt;FindInt32(&quot;signal&quot;, &amp;signal) != B_OK)</a>
<a name="ln732">				break;</a>
<a name="ln733"> </a>
<a name="ln734">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln735">			fTeam-&gt;RemoveCustomSignalDisposition(signal);</a>
<a name="ln736">			break;</a>
<a name="ln737">		}</a>
<a name="ln738"> </a>
<a name="ln739">		case MSG_SET_WATCHPOINT:</a>
<a name="ln740">		case MSG_CLEAR_WATCHPOINT:</a>
<a name="ln741">		{</a>
<a name="ln742">			Watchpoint* watchpoint = NULL;</a>
<a name="ln743">			BReference&lt;Watchpoint&gt; watchpointReference;</a>
<a name="ln744">			uint64 address = 0;</a>
<a name="ln745">			uint32 type = 0;</a>
<a name="ln746">			int32 length = 0;</a>
<a name="ln747"> </a>
<a name="ln748">			if (message-&gt;FindPointer(&quot;watchpoint&quot;, (void**)&amp;watchpoint)</a>
<a name="ln749">					== B_OK) {</a>
<a name="ln750">				watchpointReference.SetTo(watchpoint, true);</a>
<a name="ln751">			} else if (message-&gt;FindUInt64(&quot;address&quot;, &amp;address) != B_OK)</a>
<a name="ln752">				break;</a>
<a name="ln753"> </a>
<a name="ln754">			if (message-&gt;what == MSG_SET_WATCHPOINT) {</a>
<a name="ln755">				if (watchpoint == NULL &amp;&amp; (message-&gt;FindUInt32(&quot;type&quot;, &amp;type)</a>
<a name="ln756">							!= B_OK</a>
<a name="ln757">						|| message-&gt;FindInt32(&quot;length&quot;, &amp;length) != B_OK)) {</a>
<a name="ln758">					break;</a>
<a name="ln759">				}</a>
<a name="ln760"> </a>
<a name="ln761">				bool enabled;</a>
<a name="ln762">				if (message-&gt;FindBool(&quot;enabled&quot;, &amp;enabled) != B_OK)</a>
<a name="ln763">					enabled = true;</a>
<a name="ln764"> </a>
<a name="ln765">				if (watchpoint != NULL)</a>
<a name="ln766">					_HandleSetWatchpoint(watchpoint, enabled);</a>
<a name="ln767">				else</a>
<a name="ln768">					_HandleSetWatchpoint(address, type, length, enabled);</a>
<a name="ln769">			} else {</a>
<a name="ln770">				if (watchpoint != NULL)</a>
<a name="ln771">					_HandleClearWatchpoint(watchpoint);</a>
<a name="ln772">				else</a>
<a name="ln773">					_HandleClearWatchpoint(address);</a>
<a name="ln774">			}</a>
<a name="ln775"> </a>
<a name="ln776">			break;</a>
<a name="ln777">		}</a>
<a name="ln778"> </a>
<a name="ln779">		case MSG_INSPECT_ADDRESS:</a>
<a name="ln780">		{</a>
<a name="ln781">			TeamMemoryBlock::Listener* listener;</a>
<a name="ln782">			if (message-&gt;FindPointer(&quot;listener&quot;,</a>
<a name="ln783">				reinterpret_cast&lt;void **&gt;(&amp;listener)) != B_OK) {</a>
<a name="ln784">				break;</a>
<a name="ln785">			}</a>
<a name="ln786"> </a>
<a name="ln787">			target_addr_t address;</a>
<a name="ln788">			if (message-&gt;FindUInt64(&quot;address&quot;,</a>
<a name="ln789">				&amp;address) == B_OK) {</a>
<a name="ln790">				_HandleInspectAddress(address, listener);</a>
<a name="ln791">			}</a>
<a name="ln792">			break;</a>
<a name="ln793">		}</a>
<a name="ln794"> </a>
<a name="ln795">		case MSG_WRITE_TARGET_MEMORY:</a>
<a name="ln796">		{</a>
<a name="ln797">			target_addr_t address;</a>
<a name="ln798">			if (message-&gt;FindUInt64(&quot;address&quot;, &amp;address) != B_OK)</a>
<a name="ln799">				break;</a>
<a name="ln800"> </a>
<a name="ln801">			void* data;</a>
<a name="ln802">			if (message-&gt;FindPointer(&quot;data&quot;, &amp;data) != B_OK)</a>
<a name="ln803">				break;</a>
<a name="ln804"> </a>
<a name="ln805">			target_size_t size;</a>
<a name="ln806">			if (message-&gt;FindUInt64(&quot;size&quot;, &amp;size) != B_OK)</a>
<a name="ln807">				break;</a>
<a name="ln808"> </a>
<a name="ln809">			_HandleWriteMemory(address, data, size);</a>
<a name="ln810">			break;</a>
<a name="ln811">		}</a>
<a name="ln812"> </a>
<a name="ln813">		case MSG_EVALUATE_EXPRESSION:</a>
<a name="ln814">		{</a>
<a name="ln815">			SourceLanguage* language;</a>
<a name="ln816">			if (message-&gt;FindPointer(&quot;language&quot;,</a>
<a name="ln817">				reinterpret_cast&lt;void**&gt;(&amp;language)) != B_OK) {</a>
<a name="ln818">				break;</a>
<a name="ln819">			}</a>
<a name="ln820"> </a>
<a name="ln821">			// ExpressionEvaluationRequested() acquires a reference</a>
<a name="ln822">			// to both the language and the expression info on our behalf.</a>
<a name="ln823">			BReference&lt;SourceLanguage&gt; reference(language, true);</a>
<a name="ln824"> </a>
<a name="ln825">			ExpressionInfo* info;</a>
<a name="ln826">			if (message-&gt;FindPointer(&quot;info&quot;,</a>
<a name="ln827">				reinterpret_cast&lt;void**&gt;(&amp;info)) != B_OK) {</a>
<a name="ln828">				break;</a>
<a name="ln829">			}</a>
<a name="ln830"> </a>
<a name="ln831">			BReference&lt;ExpressionInfo&gt; infoReference(info, true);</a>
<a name="ln832"> </a>
<a name="ln833">			StackFrame* frame;</a>
<a name="ln834">			if (message-&gt;FindPointer(&quot;frame&quot;,</a>
<a name="ln835">				reinterpret_cast&lt;void**&gt;(&amp;frame)) != B_OK) {</a>
<a name="ln836">				// the stack frame isn't needed, unless variable</a>
<a name="ln837">				// evaluation is desired.</a>
<a name="ln838">				frame = NULL;</a>
<a name="ln839">			}</a>
<a name="ln840"> </a>
<a name="ln841">			::Thread* thread;</a>
<a name="ln842">			if (message-&gt;FindPointer(&quot;thread&quot;,</a>
<a name="ln843">				reinterpret_cast&lt;void**&gt;(&amp;thread)) != B_OK) {</a>
<a name="ln844">				// the thread isn't needed, unless variable</a>
<a name="ln845">				// evaluation is desired.</a>
<a name="ln846">				thread = NULL;</a>
<a name="ln847">			}</a>
<a name="ln848"> </a>
<a name="ln849">			_HandleEvaluateExpression(language, info, frame, thread);</a>
<a name="ln850">			break;</a>
<a name="ln851">		}</a>
<a name="ln852"> </a>
<a name="ln853">		case MSG_GENERATE_DEBUG_REPORT:</a>
<a name="ln854">		{</a>
<a name="ln855">			fReportGenerator-&gt;PostMessage(message);</a>
<a name="ln856">			break;</a>
<a name="ln857">		}</a>
<a name="ln858"> </a>
<a name="ln859">		case MSG_WRITE_CORE_FILE:</a>
<a name="ln860">		{</a>
<a name="ln861">			entry_ref ref;</a>
<a name="ln862">			if (message-&gt;FindRef(&quot;target&quot;, &amp;ref) != B_OK)</a>
<a name="ln863">				break;</a>
<a name="ln864"> </a>
<a name="ln865">			_HandleWriteCoreFile(ref);</a>
<a name="ln866">			break;</a>
<a name="ln867">		}</a>
<a name="ln868"> </a>
<a name="ln869">		case MSG_THREAD_STATE_CHANGED:</a>
<a name="ln870">		{</a>
<a name="ln871">			int32 threadID;</a>
<a name="ln872">			if (message-&gt;FindInt32(&quot;thread&quot;, &amp;threadID) != B_OK)</a>
<a name="ln873">				break;</a>
<a name="ln874"> </a>
<a name="ln875">			if (ThreadHandler* handler = _GetThreadHandler(threadID)) {</a>
<a name="ln876">				handler-&gt;HandleThreadStateChanged();</a>
<a name="ln877">				handler-&gt;ReleaseReference();</a>
<a name="ln878">			}</a>
<a name="ln879">			break;</a>
<a name="ln880">		}</a>
<a name="ln881">		case MSG_THREAD_CPU_STATE_CHANGED:</a>
<a name="ln882">		{</a>
<a name="ln883">			int32 threadID;</a>
<a name="ln884">			if (message-&gt;FindInt32(&quot;thread&quot;, &amp;threadID) != B_OK)</a>
<a name="ln885">				break;</a>
<a name="ln886"> </a>
<a name="ln887">			if (ThreadHandler* handler = _GetThreadHandler(threadID)) {</a>
<a name="ln888">				handler-&gt;HandleCpuStateChanged();</a>
<a name="ln889">				handler-&gt;ReleaseReference();</a>
<a name="ln890">			}</a>
<a name="ln891">			break;</a>
<a name="ln892">		}</a>
<a name="ln893">		case MSG_THREAD_STACK_TRACE_CHANGED:</a>
<a name="ln894">		{</a>
<a name="ln895">			int32 threadID;</a>
<a name="ln896">			if (message-&gt;FindInt32(&quot;thread&quot;, &amp;threadID) != B_OK)</a>
<a name="ln897">				break;</a>
<a name="ln898"> </a>
<a name="ln899">			if (ThreadHandler* handler = _GetThreadHandler(threadID)) {</a>
<a name="ln900">				handler-&gt;HandleStackTraceChanged();</a>
<a name="ln901">				handler-&gt;ReleaseReference();</a>
<a name="ln902">			}</a>
<a name="ln903">			break;</a>
<a name="ln904">		}</a>
<a name="ln905"> </a>
<a name="ln906">		case MSG_IMAGE_DEBUG_INFO_CHANGED:</a>
<a name="ln907">		{</a>
<a name="ln908">			int32 imageID;</a>
<a name="ln909">			if (message-&gt;FindInt32(&quot;image&quot;, &amp;imageID) != B_OK)</a>
<a name="ln910">				break;</a>
<a name="ln911"> </a>
<a name="ln912">			_HandleImageDebugInfoChanged(imageID);</a>
<a name="ln913">			break;</a>
<a name="ln914">		}</a>
<a name="ln915"> </a>
<a name="ln916">		case MSG_IMAGE_FILE_CHANGED:</a>
<a name="ln917">		{</a>
<a name="ln918">			int32 imageID;</a>
<a name="ln919">			if (message-&gt;FindInt32(&quot;image&quot;, &amp;imageID) != B_OK)</a>
<a name="ln920">				break;</a>
<a name="ln921"> </a>
<a name="ln922">			_HandleImageFileChanged(imageID);</a>
<a name="ln923">			break;</a>
<a name="ln924">		}</a>
<a name="ln925"> </a>
<a name="ln926">		case MSG_DEBUGGER_EVENT:</a>
<a name="ln927">		{</a>
<a name="ln928">			DebugEvent* event;</a>
<a name="ln929">			if (message-&gt;FindPointer(&quot;event&quot;, (void**)&amp;event) != B_OK)</a>
<a name="ln930">				break;</a>
<a name="ln931"> </a>
<a name="ln932">			_HandleDebuggerMessage(event);</a>
<a name="ln933">			delete event;</a>
<a name="ln934">			break;</a>
<a name="ln935">		}</a>
<a name="ln936"> </a>
<a name="ln937">		case MSG_LOAD_SETTINGS:</a>
<a name="ln938">			_LoadSettings();</a>
<a name="ln939">			Activate();</a>
<a name="ln940">			break;</a>
<a name="ln941"> </a>
<a name="ln942">		case MSG_TEAM_RESTART_REQUESTED:</a>
<a name="ln943">		{</a>
<a name="ln944">			if (fCommandLineArgc == 0)</a>
<a name="ln945">				break;</a>
<a name="ln946"> </a>
<a name="ln947">			_SaveSettings();</a>
<a name="ln948">			fListener-&gt;TeamDebuggerRestartRequested(this);</a>
<a name="ln949">			break;</a>
<a name="ln950">		}</a>
<a name="ln951"> </a>
<a name="ln952">		case MSG_DEBUG_INFO_NEEDS_USER_INPUT:</a>
<a name="ln953">		{</a>
<a name="ln954">			Job* job;</a>
<a name="ln955">			ImageDebugInfoLoadingState* state;</a>
<a name="ln956">			if (message-&gt;FindPointer(&quot;job&quot;, (void**)&amp;job) != B_OK)</a>
<a name="ln957">				break;</a>
<a name="ln958">			if (message-&gt;FindPointer(&quot;state&quot;, (void**)&amp;state) != B_OK)</a>
<a name="ln959">				break;</a>
<a name="ln960"> </a>
<a name="ln961">			_HandleDebugInfoJobUserInput(state);</a>
<a name="ln962">			fWorker-&gt;ResumeJob(job);</a>
<a name="ln963">			break;</a>
<a name="ln964">		}</a>
<a name="ln965"> </a>
<a name="ln966">		case MSG_RESET_USER_BACKGROUND_STATUS:</a>
<a name="ln967">		{</a>
<a name="ln968">			fUserInterface-&gt;NotifyBackgroundWorkStatus(&quot;Ready.&quot;);</a>
<a name="ln969">			break;</a>
<a name="ln970">		}</a>
<a name="ln971"> </a>
<a name="ln972">		default:</a>
<a name="ln973">			BLooper::MessageReceived(message);</a>
<a name="ln974">			break;</a>
<a name="ln975">	}</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978"> </a>
<a name="ln979">void</a>
<a name="ln980">TeamDebugger::SourceEntryLocateRequested(const char* sourcePath,</a>
<a name="ln981">	const char* locatedPath)</a>
<a name="ln982">{</a>
<a name="ln983">	AutoLocker&lt;FileManager&gt; locker(fFileManager);</a>
<a name="ln984">	fFileManager-&gt;SourceEntryLocated(sourcePath, locatedPath);</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987"> </a>
<a name="ln988">void</a>
<a name="ln989">TeamDebugger::SourceEntryInvalidateRequested(LocatableFile* sourceFile)</a>
<a name="ln990">{</a>
<a name="ln991">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln992"> </a>
<a name="ln993">	fTeam-&gt;DebugInfo()-&gt;ClearSourceCode(sourceFile);</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996"> </a>
<a name="ln997">void</a>
<a name="ln998">TeamDebugger::FunctionSourceCodeRequested(FunctionInstance* functionInstance,</a>
<a name="ln999">	bool forceDisassembly)</a>
<a name="ln1000">{</a>
<a name="ln1001">	Function* function = functionInstance-&gt;GetFunction();</a>
<a name="ln1002"> </a>
<a name="ln1003">	// mark loading</a>
<a name="ln1004">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln1005"> </a>
<a name="ln1006">	if (forceDisassembly &amp;&amp; functionInstance-&gt;SourceCodeState()</a>
<a name="ln1007">			!= FUNCTION_SOURCE_NOT_LOADED) {</a>
<a name="ln1008">		return;</a>
<a name="ln1009">	} else if (!forceDisassembly &amp;&amp; function-&gt;SourceCodeState()</a>
<a name="ln1010">			== FUNCTION_SOURCE_LOADED) {</a>
<a name="ln1011">		return;</a>
<a name="ln1012">	}</a>
<a name="ln1013"> </a>
<a name="ln1014">	functionInstance-&gt;SetSourceCode(NULL, FUNCTION_SOURCE_LOADING);</a>
<a name="ln1015"> </a>
<a name="ln1016">	bool loadForFunction = false;</a>
<a name="ln1017">	if (!forceDisassembly &amp;&amp; (function-&gt;SourceCodeState()</a>
<a name="ln1018">				== FUNCTION_SOURCE_NOT_LOADED</a>
<a name="ln1019">			|| function-&gt;SourceCodeState() == FUNCTION_SOURCE_SUPPRESSED)) {</a>
<a name="ln1020">		loadForFunction = true;</a>
<a name="ln1021">		function-&gt;SetSourceCode(NULL, FUNCTION_SOURCE_LOADING);</a>
<a name="ln1022">	}</a>
<a name="ln1023"> </a>
<a name="ln1024">	locker.Unlock();</a>
<a name="ln1025"> </a>
<a name="ln1026">	// schedule the job</a>
<a name="ln1027">	if (fWorker-&gt;ScheduleJob(</a>
<a name="ln1028">			new(std::nothrow) LoadSourceCodeJob(fDebuggerInterface,</a>
<a name="ln1029">				fDebuggerInterface-&gt;GetArchitecture(), fTeam, functionInstance,</a>
<a name="ln1030">					loadForFunction),</a>
<a name="ln1031">			this) != B_OK) {</a>
<a name="ln1032">		// scheduling failed -- mark unavailable</a>
<a name="ln1033">		locker.Lock();</a>
<a name="ln1034">		function-&gt;SetSourceCode(NULL, FUNCTION_SOURCE_UNAVAILABLE);</a>
<a name="ln1035">		locker.Unlock();</a>
<a name="ln1036">	}</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">void</a>
<a name="ln1041">TeamDebugger::ImageDebugInfoRequested(Image* image)</a>
<a name="ln1042">{</a>
<a name="ln1043">	LoadImageDebugInfoJob::ScheduleIfNecessary(fWorker, image, this);</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046"> </a>
<a name="ln1047">void</a>
<a name="ln1048">TeamDebugger::ValueNodeValueRequested(CpuState* cpuState,</a>
<a name="ln1049">	ValueNodeContainer* container, ValueNode* valueNode)</a>
<a name="ln1050">{</a>
<a name="ln1051">	AutoLocker&lt;ValueNodeContainer&gt; containerLocker(container);</a>
<a name="ln1052">	if (valueNode-&gt;Container() != container)</a>
<a name="ln1053">		return;</a>
<a name="ln1054"> </a>
<a name="ln1055">	// check whether a job is already in progress</a>
<a name="ln1056">	AutoLocker&lt;Worker&gt; workerLocker(fWorker);</a>
<a name="ln1057">	SimpleJobKey jobKey(valueNode, JOB_TYPE_RESOLVE_VALUE_NODE_VALUE);</a>
<a name="ln1058">	if (fWorker-&gt;GetJob(jobKey) != NULL)</a>
<a name="ln1059">		return;</a>
<a name="ln1060">	workerLocker.Unlock();</a>
<a name="ln1061"> </a>
<a name="ln1062">	// schedule the job</a>
<a name="ln1063">	status_t error = fWorker-&gt;ScheduleJob(</a>
<a name="ln1064">		new(std::nothrow) ResolveValueNodeValueJob(fDebuggerInterface,</a>
<a name="ln1065">			fDebuggerInterface-&gt;GetArchitecture(), cpuState,</a>
<a name="ln1066">			fTeam-&gt;GetTeamTypeInformation(), container,	valueNode), this);</a>
<a name="ln1067">	if (error != B_OK) {</a>
<a name="ln1068">		// scheduling failed -- set the value to invalid</a>
<a name="ln1069">		valueNode-&gt;SetLocationAndValue(NULL, NULL, error);</a>
<a name="ln1070">	}</a>
<a name="ln1071">}</a>
<a name="ln1072"> </a>
<a name="ln1073">void</a>
<a name="ln1074">TeamDebugger::ValueNodeWriteRequested(ValueNode* node, CpuState* state,</a>
<a name="ln1075">	Value* newValue)</a>
<a name="ln1076">{</a>
<a name="ln1077">	// schedule the job</a>
<a name="ln1078">	status_t error = fWorker-&gt;ScheduleJob(</a>
<a name="ln1079">		new(std::nothrow) WriteValueNodeValueJob(fDebuggerInterface,</a>
<a name="ln1080">			fDebuggerInterface-&gt;GetArchitecture(), state,</a>
<a name="ln1081">			fTeam-&gt;GetTeamTypeInformation(), node, newValue), this);</a>
<a name="ln1082">	if (error != B_OK) {</a>
<a name="ln1083">		BString message;</a>
<a name="ln1084">		message.SetToFormat(&quot;Request to write new value for variable %s &quot;</a>
<a name="ln1085">			&quot;failed: %s.\n&quot;, node-&gt;Name().String(), strerror(error));</a>
<a name="ln1086">		fUserInterface-&gt;NotifyUser(&quot;Error&quot;, message.String(),</a>
<a name="ln1087">			USER_NOTIFICATION_ERROR);</a>
<a name="ln1088">	}</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091"> </a>
<a name="ln1092">void</a>
<a name="ln1093">TeamDebugger::ThreadActionRequested(thread_id threadID,</a>
<a name="ln1094">	uint32 action, target_addr_t address)</a>
<a name="ln1095">{</a>
<a name="ln1096">	BMessage message(action);</a>
<a name="ln1097">	message.AddInt32(&quot;thread&quot;, threadID);</a>
<a name="ln1098">	message.AddUInt64(&quot;address&quot;, address);</a>
<a name="ln1099">	PostMessage(&amp;message);</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102"> </a>
<a name="ln1103">void</a>
<a name="ln1104">TeamDebugger::SetBreakpointRequested(target_addr_t address, bool enabled,</a>
<a name="ln1105">	bool hidden)</a>
<a name="ln1106">{</a>
<a name="ln1107">	BMessage message(MSG_SET_BREAKPOINT);</a>
<a name="ln1108">	message.AddUInt64(&quot;address&quot;, (uint64)address);</a>
<a name="ln1109">	message.AddBool(&quot;enabled&quot;, enabled);</a>
<a name="ln1110">	message.AddBool(&quot;hidden&quot;, hidden);</a>
<a name="ln1111">	PostMessage(&amp;message);</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114"> </a>
<a name="ln1115">void</a>
<a name="ln1116">TeamDebugger::SetBreakpointEnabledRequested(UserBreakpoint* breakpoint,</a>
<a name="ln1117">	bool enabled)</a>
<a name="ln1118">{</a>
<a name="ln1119">	BMessage message(MSG_SET_BREAKPOINT);</a>
<a name="ln1120">	BReference&lt;UserBreakpoint&gt; breakpointReference(breakpoint);</a>
<a name="ln1121">	if (message.AddPointer(&quot;breakpoint&quot;, breakpoint) == B_OK</a>
<a name="ln1122">		&amp;&amp; message.AddBool(&quot;enabled&quot;, enabled) == B_OK</a>
<a name="ln1123">		&amp;&amp; PostMessage(&amp;message) == B_OK) {</a>
<a name="ln1124">		breakpointReference.Detach();</a>
<a name="ln1125">	}</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128"> </a>
<a name="ln1129">void</a>
<a name="ln1130">TeamDebugger::SetBreakpointConditionRequested(UserBreakpoint* breakpoint,</a>
<a name="ln1131">	const char* condition)</a>
<a name="ln1132">{</a>
<a name="ln1133">	BMessage message(MSG_SET_BREAKPOINT_CONDITION);</a>
<a name="ln1134">	BReference&lt;UserBreakpoint&gt; breakpointReference(breakpoint);</a>
<a name="ln1135">	if (message.AddPointer(&quot;breakpoint&quot;, breakpoint) == B_OK</a>
<a name="ln1136">		&amp;&amp; message.AddString(&quot;condition&quot;, condition) == B_OK</a>
<a name="ln1137">		&amp;&amp; PostMessage(&amp;message) == B_OK) {</a>
<a name="ln1138">		breakpointReference.Detach();</a>
<a name="ln1139">	}</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142"> </a>
<a name="ln1143">void</a>
<a name="ln1144">TeamDebugger::ClearBreakpointConditionRequested(UserBreakpoint* breakpoint)</a>
<a name="ln1145">{</a>
<a name="ln1146">	BMessage message(MSG_CLEAR_BREAKPOINT_CONDITION);</a>
<a name="ln1147">	BReference&lt;UserBreakpoint&gt; breakpointReference(breakpoint);</a>
<a name="ln1148">	if (message.AddPointer(&quot;breakpoint&quot;, breakpoint) == B_OK</a>
<a name="ln1149">		&amp;&amp; PostMessage(&amp;message) == B_OK) {</a>
<a name="ln1150">		breakpointReference.Detach();</a>
<a name="ln1151">	}</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154"> </a>
<a name="ln1155">void</a>
<a name="ln1156">TeamDebugger::ClearBreakpointRequested(target_addr_t address)</a>
<a name="ln1157">{</a>
<a name="ln1158">	BMessage message(MSG_CLEAR_BREAKPOINT);</a>
<a name="ln1159">	message.AddUInt64(&quot;address&quot;, (uint64)address);</a>
<a name="ln1160">	PostMessage(&amp;message);</a>
<a name="ln1161">}</a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164">void</a>
<a name="ln1165">TeamDebugger::SetStopOnImageLoadRequested(bool enabled, bool useImageNames)</a>
<a name="ln1166">{</a>
<a name="ln1167">	BMessage message(MSG_STOP_ON_IMAGE_LOAD);</a>
<a name="ln1168">	message.AddBool(&quot;enabled&quot;, enabled);</a>
<a name="ln1169">	message.AddBool(&quot;useNames&quot;, useImageNames);</a>
<a name="ln1170">	PostMessage(&amp;message);</a>
<a name="ln1171">}</a>
<a name="ln1172"> </a>
<a name="ln1173"> </a>
<a name="ln1174">void</a>
<a name="ln1175">TeamDebugger::AddStopImageNameRequested(const char* name)</a>
<a name="ln1176">{</a>
<a name="ln1177">	BMessage message(MSG_ADD_STOP_IMAGE_NAME);</a>
<a name="ln1178">	message.AddString(&quot;name&quot;, name);</a>
<a name="ln1179">	PostMessage(&amp;message);</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182"> </a>
<a name="ln1183">void</a>
<a name="ln1184">TeamDebugger::RemoveStopImageNameRequested(const char* name)</a>
<a name="ln1185">{</a>
<a name="ln1186">	BMessage message(MSG_REMOVE_STOP_IMAGE_NAME);</a>
<a name="ln1187">	message.AddString(&quot;name&quot;, name);</a>
<a name="ln1188">	PostMessage(&amp;message);</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191"> </a>
<a name="ln1192">void</a>
<a name="ln1193">TeamDebugger::SetDefaultSignalDispositionRequested(int32 disposition)</a>
<a name="ln1194">{</a>
<a name="ln1195">	BMessage message(MSG_SET_DEFAULT_SIGNAL_DISPOSITION);</a>
<a name="ln1196">	message.AddInt32(&quot;disposition&quot;, disposition);</a>
<a name="ln1197">	PostMessage(&amp;message);</a>
<a name="ln1198">}</a>
<a name="ln1199"> </a>
<a name="ln1200"> </a>
<a name="ln1201">void</a>
<a name="ln1202">TeamDebugger::SetCustomSignalDispositionRequested(int32 signal,</a>
<a name="ln1203">	int32 disposition)</a>
<a name="ln1204">{</a>
<a name="ln1205">	BMessage message(MSG_SET_CUSTOM_SIGNAL_DISPOSITION);</a>
<a name="ln1206">	message.AddInt32(&quot;signal&quot;, signal);</a>
<a name="ln1207">	message.AddInt32(&quot;disposition&quot;, disposition);</a>
<a name="ln1208">	PostMessage(&amp;message);</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211"> </a>
<a name="ln1212">void</a>
<a name="ln1213">TeamDebugger::RemoveCustomSignalDispositionRequested(int32 signal)</a>
<a name="ln1214">{</a>
<a name="ln1215">	BMessage message(MSG_REMOVE_CUSTOM_SIGNAL_DISPOSITION);</a>
<a name="ln1216">	message.AddInt32(&quot;signal&quot;, signal);</a>
<a name="ln1217">	PostMessage(&amp;message);</a>
<a name="ln1218">}</a>
<a name="ln1219"> </a>
<a name="ln1220"> </a>
<a name="ln1221">void</a>
<a name="ln1222">TeamDebugger::ClearBreakpointRequested(UserBreakpoint* breakpoint)</a>
<a name="ln1223">{</a>
<a name="ln1224">	BMessage message(MSG_CLEAR_BREAKPOINT);</a>
<a name="ln1225">	BReference&lt;UserBreakpoint&gt; breakpointReference(breakpoint);</a>
<a name="ln1226">	if (message.AddPointer(&quot;breakpoint&quot;, breakpoint) == B_OK</a>
<a name="ln1227">		&amp;&amp; PostMessage(&amp;message) == B_OK) {</a>
<a name="ln1228">		breakpointReference.Detach();</a>
<a name="ln1229">	}</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232"> </a>
<a name="ln1233">void</a>
<a name="ln1234">TeamDebugger::SetWatchpointRequested(target_addr_t address, uint32 type,</a>
<a name="ln1235">	int32 length, bool enabled)</a>
<a name="ln1236">{</a>
<a name="ln1237">	BMessage message(MSG_SET_WATCHPOINT);</a>
<a name="ln1238">	message.AddUInt64(&quot;address&quot;, (uint64)address);</a>
<a name="ln1239">	message.AddUInt32(&quot;type&quot;, type);</a>
<a name="ln1240">	message.AddInt32(&quot;length&quot;, length);</a>
<a name="ln1241">	message.AddBool(&quot;enabled&quot;, enabled);</a>
<a name="ln1242">	PostMessage(&amp;message);</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245"> </a>
<a name="ln1246">void</a>
<a name="ln1247">TeamDebugger::SetWatchpointEnabledRequested(Watchpoint* watchpoint,</a>
<a name="ln1248">	bool enabled)</a>
<a name="ln1249">{</a>
<a name="ln1250">	BMessage message(MSG_SET_WATCHPOINT);</a>
<a name="ln1251">	BReference&lt;Watchpoint&gt; watchpointReference(watchpoint);</a>
<a name="ln1252">	if (message.AddPointer(&quot;watchpoint&quot;, watchpoint) == B_OK</a>
<a name="ln1253">		&amp;&amp; message.AddBool(&quot;enabled&quot;, enabled) == B_OK</a>
<a name="ln1254">		&amp;&amp; PostMessage(&amp;message) == B_OK) {</a>
<a name="ln1255">		watchpointReference.Detach();</a>
<a name="ln1256">	}</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259"> </a>
<a name="ln1260">void</a>
<a name="ln1261">TeamDebugger::ClearWatchpointRequested(target_addr_t address)</a>
<a name="ln1262">{</a>
<a name="ln1263">	BMessage message(MSG_CLEAR_WATCHPOINT);</a>
<a name="ln1264">	message.AddUInt64(&quot;address&quot;, (uint64)address);</a>
<a name="ln1265">	PostMessage(&amp;message);</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268"> </a>
<a name="ln1269">void</a>
<a name="ln1270">TeamDebugger::ClearWatchpointRequested(Watchpoint* watchpoint)</a>
<a name="ln1271">{</a>
<a name="ln1272">	BMessage message(MSG_CLEAR_WATCHPOINT);</a>
<a name="ln1273">	BReference&lt;Watchpoint&gt; watchpointReference(watchpoint);</a>
<a name="ln1274">	if (message.AddPointer(&quot;watchpoint&quot;, watchpoint) == B_OK</a>
<a name="ln1275">		&amp;&amp; PostMessage(&amp;message) == B_OK) {</a>
<a name="ln1276">		watchpointReference.Detach();</a>
<a name="ln1277">	}</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280"> </a>
<a name="ln1281">void</a>
<a name="ln1282">TeamDebugger::InspectRequested(target_addr_t address,</a>
<a name="ln1283">	TeamMemoryBlock::Listener *listener)</a>
<a name="ln1284">{</a>
<a name="ln1285">	BMessage message(MSG_INSPECT_ADDRESS);</a>
<a name="ln1286">	message.AddUInt64(&quot;address&quot;, address);</a>
<a name="ln1287">	message.AddPointer(&quot;listener&quot;, listener);</a>
<a name="ln1288">	PostMessage(&amp;message);</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291"> </a>
<a name="ln1292">void</a>
<a name="ln1293">TeamDebugger::MemoryWriteRequested(target_addr_t address, const void* data,</a>
<a name="ln1294">	target_size_t size)</a>
<a name="ln1295">{</a>
<a name="ln1296">	BMessage message(MSG_WRITE_TARGET_MEMORY);</a>
<a name="ln1297">	message.AddUInt64(&quot;address&quot;, address);</a>
<a name="ln1298">	message.AddPointer(&quot;data&quot;, data);</a>
<a name="ln1299">	message.AddUInt64(&quot;size&quot;, size);</a>
<a name="ln1300">	PostMessage(&amp;message);</a>
<a name="ln1301">}</a>
<a name="ln1302"> </a>
<a name="ln1303"> </a>
<a name="ln1304">void</a>
<a name="ln1305">TeamDebugger::ExpressionEvaluationRequested(SourceLanguage* language,</a>
<a name="ln1306">	ExpressionInfo* info, StackFrame* frame, ::Thread* thread)</a>
<a name="ln1307">{</a>
<a name="ln1308">	BMessage message(MSG_EVALUATE_EXPRESSION);</a>
<a name="ln1309">	message.AddPointer(&quot;language&quot;, language);</a>
<a name="ln1310">	message.AddPointer(&quot;info&quot;, info);</a>
<a name="ln1311">	if (frame != NULL)</a>
<a name="ln1312">		message.AddPointer(&quot;frame&quot;, frame);</a>
<a name="ln1313">	if (thread != NULL)</a>
<a name="ln1314">		message.AddPointer(&quot;thread&quot;, thread);</a>
<a name="ln1315"> </a>
<a name="ln1316">	BReference&lt;SourceLanguage&gt; languageReference(language);</a>
<a name="ln1317">	BReference&lt;ExpressionInfo&gt; infoReference(info);</a>
<a name="ln1318">	if (PostMessage(&amp;message) == B_OK) {</a>
<a name="ln1319">		languageReference.Detach();</a>
<a name="ln1320">		infoReference.Detach();</a>
<a name="ln1321">	}</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324"> </a>
<a name="ln1325">void</a>
<a name="ln1326">TeamDebugger::DebugReportRequested(entry_ref* targetPath)</a>
<a name="ln1327">{</a>
<a name="ln1328">	BMessage message(MSG_GENERATE_DEBUG_REPORT);</a>
<a name="ln1329">	message.AddRef(&quot;target&quot;, targetPath);</a>
<a name="ln1330">	PostMessage(&amp;message);</a>
<a name="ln1331">}</a>
<a name="ln1332"> </a>
<a name="ln1333"> </a>
<a name="ln1334">void</a>
<a name="ln1335">TeamDebugger::WriteCoreFileRequested(entry_ref* targetPath)</a>
<a name="ln1336">{</a>
<a name="ln1337">	BMessage message(MSG_WRITE_CORE_FILE);</a>
<a name="ln1338">	message.AddRef(&quot;target&quot;, targetPath);</a>
<a name="ln1339">	PostMessage(&amp;message);</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342"> </a>
<a name="ln1343">void</a>
<a name="ln1344">TeamDebugger::TeamRestartRequested()</a>
<a name="ln1345">{</a>
<a name="ln1346">	PostMessage(MSG_TEAM_RESTART_REQUESTED);</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349"> </a>
<a name="ln1350">bool</a>
<a name="ln1351">TeamDebugger::UserInterfaceQuitRequested(QuitOption quitOption)</a>
<a name="ln1352">{</a>
<a name="ln1353">	bool askUser = false;</a>
<a name="ln1354">	switch (quitOption) {</a>
<a name="ln1355">		case QUIT_OPTION_ASK_USER:</a>
<a name="ln1356">			askUser = true;</a>
<a name="ln1357">			break;</a>
<a name="ln1358"> </a>
<a name="ln1359">		case QUIT_OPTION_ASK_KILL_TEAM:</a>
<a name="ln1360">			fKillTeamOnQuit = true;</a>
<a name="ln1361">			break;</a>
<a name="ln1362"> </a>
<a name="ln1363">		case QUIT_OPTION_ASK_RESUME_TEAM:</a>
<a name="ln1364">			break;</a>
<a name="ln1365">	}</a>
<a name="ln1366"> </a>
<a name="ln1367">	if (askUser) {</a>
<a name="ln1368">		AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln1369">		BString name(fTeam-&gt;Name());</a>
<a name="ln1370">		locker.Unlock();</a>
<a name="ln1371"> </a>
<a name="ln1372">		BString message;</a>
<a name="ln1373">		message &lt;&lt; &quot;What shall be done about the debugged team '&quot;;</a>
<a name="ln1374">		message &lt;&lt; name;</a>
<a name="ln1375">		message &lt;&lt; &quot;'?&quot;;</a>
<a name="ln1376"> </a>
<a name="ln1377">		name.Remove(0, name.FindLast('/') + 1);</a>
<a name="ln1378"> </a>
<a name="ln1379">		BString killLabel(&quot;Kill &quot;);</a>
<a name="ln1380">		killLabel &lt;&lt; name;</a>
<a name="ln1381"> </a>
<a name="ln1382">		BString resumeLabel(&quot;Resume &quot;);</a>
<a name="ln1383">		resumeLabel &lt;&lt; name;</a>
<a name="ln1384"> </a>
<a name="ln1385">		int32 choice = fUserInterface-&gt;SynchronouslyAskUser(&quot;Quit Debugger&quot;,</a>
<a name="ln1386">			message, killLabel, &quot;Cancel&quot;, resumeLabel);</a>
<a name="ln1387"> </a>
<a name="ln1388">		switch (choice) {</a>
<a name="ln1389">			case 0:</a>
<a name="ln1390">				fKillTeamOnQuit = true;</a>
<a name="ln1391">				break;</a>
<a name="ln1392">			case 1:</a>
<a name="ln1393">			case -1:</a>
<a name="ln1394">				return false;</a>
<a name="ln1395">			case 2:</a>
<a name="ln1396">				// Detach from the team and resume and stopped threads.</a>
<a name="ln1397">				break;</a>
<a name="ln1398">		}</a>
<a name="ln1399">	}</a>
<a name="ln1400"> </a>
<a name="ln1401">	PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1402"> </a>
<a name="ln1403">	return true;</a>
<a name="ln1404">}</a>
<a name="ln1405"> </a>
<a name="ln1406"> </a>
<a name="ln1407">void</a>
<a name="ln1408">TeamDebugger::JobStarted(Job* job)</a>
<a name="ln1409">{</a>
<a name="ln1410">	BString description(job-&gt;GetDescription());</a>
<a name="ln1411">	if (!description.IsEmpty()) {</a>
<a name="ln1412">		description.Append(B_UTF8_ELLIPSIS);</a>
<a name="ln1413">		fUserInterface-&gt;NotifyBackgroundWorkStatus(description.String());</a>
<a name="ln1414">	}</a>
<a name="ln1415">}</a>
<a name="ln1416"> </a>
<a name="ln1417"> </a>
<a name="ln1418">void</a>
<a name="ln1419">TeamDebugger::JobDone(Job* job)</a>
<a name="ln1420">{</a>
<a name="ln1421">	TRACE_JOBS(&quot;TeamDebugger::JobDone(%p)\n&quot;, job);</a>
<a name="ln1422">	_ResetUserBackgroundStatusIfNeeded();</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425"> </a>
<a name="ln1426">void</a>
<a name="ln1427">TeamDebugger::JobWaitingForInput(Job* job)</a>
<a name="ln1428">{</a>
<a name="ln1429">	LoadImageDebugInfoJob* infoJob = dynamic_cast&lt;LoadImageDebugInfoJob*&gt;(job);</a>
<a name="ln1430"> </a>
<a name="ln1431">	if (infoJob == NULL)</a>
<a name="ln1432">		return;</a>
<a name="ln1433"> </a>
<a name="ln1434">	BMessage message(MSG_DEBUG_INFO_NEEDS_USER_INPUT);</a>
<a name="ln1435">	message.AddPointer(&quot;job&quot;, infoJob);</a>
<a name="ln1436">	message.AddPointer(&quot;state&quot;, infoJob-&gt;GetLoadingState());</a>
<a name="ln1437">	PostMessage(&amp;message);</a>
<a name="ln1438">}</a>
<a name="ln1439"> </a>
<a name="ln1440"> </a>
<a name="ln1441">void</a>
<a name="ln1442">TeamDebugger::JobFailed(Job* job)</a>
<a name="ln1443">{</a>
<a name="ln1444">	TRACE_JOBS(&quot;TeamDebugger::JobFailed(%p)\n&quot;, job);</a>
<a name="ln1445">	// TODO: notify user</a>
<a name="ln1446">	_ResetUserBackgroundStatusIfNeeded();</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449"> </a>
<a name="ln1450">void</a>
<a name="ln1451">TeamDebugger::JobAborted(Job* job)</a>
<a name="ln1452">{</a>
<a name="ln1453">	TRACE_JOBS(&quot;TeamDebugger::JobAborted(%p)\n&quot;, job);</a>
<a name="ln1454">	// TODO: For a stack frame source loader thread we should reset the</a>
<a name="ln1455">	// loading state! Asynchronously due to locking order.</a>
<a name="ln1456">	_ResetUserBackgroundStatusIfNeeded();</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459"> </a>
<a name="ln1460">void</a>
<a name="ln1461">TeamDebugger::ThreadStateChanged(const ::Team::ThreadEvent&amp; event)</a>
<a name="ln1462">{</a>
<a name="ln1463">	BMessage message(MSG_THREAD_STATE_CHANGED);</a>
<a name="ln1464">	message.AddInt32(&quot;thread&quot;, event.GetThread()-&gt;ID());</a>
<a name="ln1465">	PostMessage(&amp;message);</a>
<a name="ln1466">}</a>
<a name="ln1467"> </a>
<a name="ln1468"> </a>
<a name="ln1469">void</a>
<a name="ln1470">TeamDebugger::ThreadCpuStateChanged(const ::Team::ThreadEvent&amp; event)</a>
<a name="ln1471">{</a>
<a name="ln1472">	BMessage message(MSG_THREAD_CPU_STATE_CHANGED);</a>
<a name="ln1473">	message.AddInt32(&quot;thread&quot;, event.GetThread()-&gt;ID());</a>
<a name="ln1474">	PostMessage(&amp;message);</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477"> </a>
<a name="ln1478">void</a>
<a name="ln1479">TeamDebugger::ThreadStackTraceChanged(const ::Team::ThreadEvent&amp; event)</a>
<a name="ln1480">{</a>
<a name="ln1481">	BMessage message(MSG_THREAD_STACK_TRACE_CHANGED);</a>
<a name="ln1482">	message.AddInt32(&quot;thread&quot;, event.GetThread()-&gt;ID());</a>
<a name="ln1483">	PostMessage(&amp;message);</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486"> </a>
<a name="ln1487">void</a>
<a name="ln1488">TeamDebugger::ImageDebugInfoChanged(const ::Team::ImageEvent&amp; event)</a>
<a name="ln1489">{</a>
<a name="ln1490">	BMessage message(MSG_IMAGE_DEBUG_INFO_CHANGED);</a>
<a name="ln1491">	message.AddInt32(&quot;image&quot;, event.GetImage()-&gt;ID());</a>
<a name="ln1492">	PostMessage(&amp;message);</a>
<a name="ln1493">}</a>
<a name="ln1494"> </a>
<a name="ln1495"> </a>
<a name="ln1496">/*static*/ status_t</a>
<a name="ln1497">TeamDebugger::_DebugEventListenerEntry(void* data)</a>
<a name="ln1498">{</a>
<a name="ln1499">	return ((TeamDebugger*)data)-&gt;_DebugEventListener();</a>
<a name="ln1500">}</a>
<a name="ln1501"> </a>
<a name="ln1502"> </a>
<a name="ln1503">status_t</a>
<a name="ln1504">TeamDebugger::_DebugEventListener()</a>
<a name="ln1505">{</a>
<a name="ln1506">	while (!fTerminating) {</a>
<a name="ln1507">		// get the next event</a>
<a name="ln1508">		DebugEvent* event;</a>
<a name="ln1509">		status_t error = fDebuggerInterface-&gt;GetNextDebugEvent(event);</a>
<a name="ln1510">		if (error != B_OK)</a>
<a name="ln1511">			break;</a>
<a name="ln1512">				// TODO: Error handling!</a>
<a name="ln1513"> </a>
<a name="ln1514">		if (event-&gt;Team() != fTeamID) {</a>
<a name="ln1515">			TRACE_EVENTS(&quot;TeamDebugger for team %&quot; B_PRId32 &quot;: received event &quot;</a>
<a name="ln1516">				&quot;from team %&quot; B_PRId32 &quot;!\n&quot;, fTeamID, event-&gt;Team());</a>
<a name="ln1517">			continue;</a>
<a name="ln1518">		}</a>
<a name="ln1519"> </a>
<a name="ln1520">		BMessage message(MSG_DEBUGGER_EVENT);</a>
<a name="ln1521">		if (message.AddPointer(&quot;event&quot;, event) != B_OK</a>
<a name="ln1522">			|| PostMessage(&amp;message) != B_OK) {</a>
<a name="ln1523">			// TODO: Continue thread if necessary!</a>
<a name="ln1524">			delete event;</a>
<a name="ln1525">		}</a>
<a name="ln1526">	}</a>
<a name="ln1527"> </a>
<a name="ln1528">	return B_OK;</a>
<a name="ln1529">}</a>
<a name="ln1530"> </a>
<a name="ln1531"> </a>
<a name="ln1532">void</a>
<a name="ln1533">TeamDebugger::_HandleDebuggerMessage(DebugEvent* event)</a>
<a name="ln1534">{</a>
<a name="ln1535">	TRACE_EVENTS(&quot;TeamDebugger::_HandleDebuggerMessage(): %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln1536">		event-&gt;EventType());</a>
<a name="ln1537"> </a>
<a name="ln1538">	bool handled = false;</a>
<a name="ln1539"> </a>
<a name="ln1540">	ThreadHandler* handler = _GetThreadHandler(event-&gt;Thread());</a>
<a name="ln1541">	BReference&lt;ThreadHandler&gt; handlerReference(handler, true);</a>
<a name="ln1542"> </a>
<a name="ln1543">	switch (event-&gt;EventType()) {</a>
<a name="ln1544">		case B_DEBUGGER_MESSAGE_THREAD_DEBUGGED:</a>
<a name="ln1545">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_THREAD_DEBUGGED: thread: %&quot;</a>
<a name="ln1546">				B_PRId32 &quot;\n&quot;, event-&gt;Thread());</a>
<a name="ln1547"> </a>
<a name="ln1548">			if (handler != NULL) {</a>
<a name="ln1549">				handled = handler-&gt;HandleThreadDebugged(</a>
<a name="ln1550">					dynamic_cast&lt;ThreadDebuggedEvent*&gt;(event));</a>
<a name="ln1551">			}</a>
<a name="ln1552">			break;</a>
<a name="ln1553">		case B_DEBUGGER_MESSAGE_DEBUGGER_CALL:</a>
<a name="ln1554">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_DEBUGGER_CALL: thread: %&quot; B_PRId32</a>
<a name="ln1555">				&quot;\n&quot;, event-&gt;Thread());</a>
<a name="ln1556"> </a>
<a name="ln1557">			if (handler != NULL) {</a>
<a name="ln1558">				handled = handler-&gt;HandleDebuggerCall(</a>
<a name="ln1559">					dynamic_cast&lt;DebuggerCallEvent*&gt;(event));</a>
<a name="ln1560">			}</a>
<a name="ln1561">			break;</a>
<a name="ln1562">		case B_DEBUGGER_MESSAGE_BREAKPOINT_HIT:</a>
<a name="ln1563">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_BREAKPOINT_HIT: thread: %&quot; B_PRId32</a>
<a name="ln1564">				&quot;\n&quot;, event-&gt;Thread());</a>
<a name="ln1565"> </a>
<a name="ln1566">			if (handler != NULL) {</a>
<a name="ln1567">				handled = handler-&gt;HandleBreakpointHit(</a>
<a name="ln1568">					dynamic_cast&lt;BreakpointHitEvent*&gt;(event));</a>
<a name="ln1569">			}</a>
<a name="ln1570">			break;</a>
<a name="ln1571">		case B_DEBUGGER_MESSAGE_WATCHPOINT_HIT:</a>
<a name="ln1572">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_WATCHPOINT_HIT: thread: %&quot; B_PRId32</a>
<a name="ln1573">				&quot;\n&quot;, event-&gt;Thread());</a>
<a name="ln1574"> </a>
<a name="ln1575">			if (handler != NULL) {</a>
<a name="ln1576">				handled = handler-&gt;HandleWatchpointHit(</a>
<a name="ln1577">					dynamic_cast&lt;WatchpointHitEvent*&gt;(event));</a>
<a name="ln1578">			}</a>
<a name="ln1579">			break;</a>
<a name="ln1580">		case B_DEBUGGER_MESSAGE_SINGLE_STEP:</a>
<a name="ln1581">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_SINGLE_STEP: thread: %&quot; B_PRId32</a>
<a name="ln1582">				&quot;\n&quot;, event-&gt;Thread());</a>
<a name="ln1583"> </a>
<a name="ln1584">			if (handler != NULL) {</a>
<a name="ln1585">				handled = handler-&gt;HandleSingleStep(</a>
<a name="ln1586">					dynamic_cast&lt;SingleStepEvent*&gt;(event));</a>
<a name="ln1587">			}</a>
<a name="ln1588">			break;</a>
<a name="ln1589">		case B_DEBUGGER_MESSAGE_EXCEPTION_OCCURRED:</a>
<a name="ln1590">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_EXCEPTION_OCCURRED: thread: %&quot;</a>
<a name="ln1591">				B_PRId32 &quot;\n&quot;, event-&gt;Thread());</a>
<a name="ln1592"> </a>
<a name="ln1593">			if (handler != NULL) {</a>
<a name="ln1594">				handled = handler-&gt;HandleExceptionOccurred(</a>
<a name="ln1595">					dynamic_cast&lt;ExceptionOccurredEvent*&gt;(event));</a>
<a name="ln1596">			}</a>
<a name="ln1597">			break;</a>
<a name="ln1598">//		case B_DEBUGGER_MESSAGE_TEAM_CREATED:</a>
<a name="ln1599">//printf(&quot;B_DEBUGGER_MESSAGE_TEAM_CREATED: team: %ld\n&quot;, message.team_created.new_team);</a>
<a name="ln1600">//			break;</a>
<a name="ln1601">		case B_DEBUGGER_MESSAGE_TEAM_DELETED:</a>
<a name="ln1602">		{</a>
<a name="ln1603">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_TEAM_DELETED: team: %&quot; B_PRId32</a>
<a name="ln1604">				&quot;\n&quot;, event-&gt;Team());</a>
<a name="ln1605">			TeamDeletedEvent* teamEvent</a>
<a name="ln1606">				= dynamic_cast&lt;TeamDeletedEvent*&gt;(event);</a>
<a name="ln1607">			handled = _HandleTeamDeleted(teamEvent);</a>
<a name="ln1608">			break;</a>
<a name="ln1609">		}</a>
<a name="ln1610">		case B_DEBUGGER_MESSAGE_TEAM_EXEC:</a>
<a name="ln1611">		{</a>
<a name="ln1612">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_TEAM_EXEC: team: %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln1613">				event-&gt;Team());</a>
<a name="ln1614"> </a>
<a name="ln1615">			TeamExecEvent* teamEvent</a>
<a name="ln1616">				= dynamic_cast&lt;TeamExecEvent*&gt;(event);</a>
<a name="ln1617">			_PrepareForTeamExec(teamEvent);</a>
<a name="ln1618">			break;</a>
<a name="ln1619">		}</a>
<a name="ln1620">		case B_DEBUGGER_MESSAGE_THREAD_CREATED:</a>
<a name="ln1621">		{</a>
<a name="ln1622">			ThreadCreatedEvent* threadEvent</a>
<a name="ln1623">				= dynamic_cast&lt;ThreadCreatedEvent*&gt;(event);</a>
<a name="ln1624">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_THREAD_CREATED: thread: %&quot; B_PRId32</a>
<a name="ln1625">				&quot;\n&quot;, threadEvent-&gt;NewThread());</a>
<a name="ln1626">			handled = _HandleThreadCreated(threadEvent);</a>
<a name="ln1627">			break;</a>
<a name="ln1628">		}</a>
<a name="ln1629">		case DEBUGGER_MESSAGE_THREAD_RENAMED:</a>
<a name="ln1630">		{</a>
<a name="ln1631">			ThreadRenamedEvent* threadEvent</a>
<a name="ln1632">				= dynamic_cast&lt;ThreadRenamedEvent*&gt;(event);</a>
<a name="ln1633">			TRACE_EVENTS(&quot;DEBUGGER_MESSAGE_THREAD_RENAMED: thread: %&quot; B_PRId32</a>
<a name="ln1634">				&quot; (\&quot;%s\&quot;)\n&quot;,</a>
<a name="ln1635">				threadEvent-&gt;RenamedThread(), threadEvent-&gt;NewName());</a>
<a name="ln1636">			handled = _HandleThreadRenamed(threadEvent);</a>
<a name="ln1637">			break;</a>
<a name="ln1638">		}</a>
<a name="ln1639">		case DEBUGGER_MESSAGE_THREAD_PRIORITY_CHANGED:</a>
<a name="ln1640">		{</a>
<a name="ln1641">			ThreadPriorityChangedEvent* threadEvent</a>
<a name="ln1642">				= dynamic_cast&lt;ThreadPriorityChangedEvent*&gt;(event);</a>
<a name="ln1643">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_THREAD_PRIORITY_CHANGED: thread:&quot;</a>
<a name="ln1644">				&quot; %&quot; B_PRId32 &quot;\n&quot;, threadEvent-&gt;ChangedThread());</a>
<a name="ln1645">			handled = _HandleThreadPriorityChanged(threadEvent);</a>
<a name="ln1646">			break;</a>
<a name="ln1647">		}</a>
<a name="ln1648">		case B_DEBUGGER_MESSAGE_THREAD_DELETED:</a>
<a name="ln1649">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_THREAD_DELETED: thread: %&quot; B_PRId32</a>
<a name="ln1650">				&quot;\n&quot;, event-&gt;Thread());</a>
<a name="ln1651">			handled = _HandleThreadDeleted(</a>
<a name="ln1652">				dynamic_cast&lt;ThreadDeletedEvent*&gt;(event));</a>
<a name="ln1653">			break;</a>
<a name="ln1654">		case B_DEBUGGER_MESSAGE_IMAGE_CREATED:</a>
<a name="ln1655">		{</a>
<a name="ln1656">			ImageCreatedEvent* imageEvent</a>
<a name="ln1657">				= dynamic_cast&lt;ImageCreatedEvent*&gt;(event);</a>
<a name="ln1658">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_IMAGE_CREATED: image: \&quot;%s\&quot; &quot;</a>
<a name="ln1659">				&quot;(%&quot; B_PRId32 &quot;)\n&quot;, imageEvent-&gt;GetImageInfo().Name().String(),</a>
<a name="ln1660">				imageEvent-&gt;GetImageInfo().ImageID());</a>
<a name="ln1661">			handled = _HandleImageCreated(imageEvent);</a>
<a name="ln1662">			break;</a>
<a name="ln1663">		}</a>
<a name="ln1664">		case B_DEBUGGER_MESSAGE_IMAGE_DELETED:</a>
<a name="ln1665">		{</a>
<a name="ln1666">			ImageDeletedEvent* imageEvent</a>
<a name="ln1667">				= dynamic_cast&lt;ImageDeletedEvent*&gt;(event);</a>
<a name="ln1668">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_IMAGE_DELETED: image: \&quot;%s\&quot; &quot;</a>
<a name="ln1669">				&quot;(%&quot; B_PRId32 &quot;)\n&quot;, imageEvent-&gt;GetImageInfo().Name().String(),</a>
<a name="ln1670">				imageEvent-&gt;GetImageInfo().ImageID());</a>
<a name="ln1671">			handled = _HandleImageDeleted(imageEvent);</a>
<a name="ln1672">			break;</a>
<a name="ln1673">		}</a>
<a name="ln1674">		case B_DEBUGGER_MESSAGE_POST_SYSCALL:</a>
<a name="ln1675">		{</a>
<a name="ln1676">			PostSyscallEvent* postSyscallEvent</a>
<a name="ln1677">				= dynamic_cast&lt;PostSyscallEvent*&gt;(event);</a>
<a name="ln1678">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_POST_SYSCALL: syscall: %&quot;</a>
<a name="ln1679">				B_PRIu32 &quot;\n&quot;, postSyscallEvent-&gt;GetSyscallInfo().Syscall());</a>
<a name="ln1680">			handled = _HandlePostSyscall(postSyscallEvent);</a>
<a name="ln1681"> </a>
<a name="ln1682">			// if a thread was blocked in a syscall when we requested to</a>
<a name="ln1683">			// stop it for debugging, then that request will interrupt</a>
<a name="ln1684">			// said call, and the post syscall event will be all we get</a>
<a name="ln1685">			// in response. Consequently, we need to treat this case as</a>
<a name="ln1686">			// equivalent to having received a thread debugged event.</a>
<a name="ln1687">			AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln1688">			::Thread* thread = fTeam-&gt;ThreadByID(event-&gt;Thread());</a>
<a name="ln1689">			if (handler != NULL &amp;&amp; thread != NULL</a>
<a name="ln1690">				&amp;&amp; thread-&gt;StopRequestPending()) {</a>
<a name="ln1691">				handled = handler-&gt;HandleThreadDebugged(NULL);</a>
<a name="ln1692">			}</a>
<a name="ln1693">			break;</a>
<a name="ln1694">		}</a>
<a name="ln1695">		case B_DEBUGGER_MESSAGE_SIGNAL_RECEIVED:</a>
<a name="ln1696">		{</a>
<a name="ln1697">			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_SIGNAL_RECEIVED: thread: %&quot;</a>
<a name="ln1698">				B_PRId32 &quot;\n&quot;, event-&gt;Thread());</a>
<a name="ln1699"> </a>
<a name="ln1700">			if (handler != NULL) {</a>
<a name="ln1701">				handled = handler-&gt;HandleSignalReceived(</a>
<a name="ln1702">					dynamic_cast&lt;SignalReceivedEvent*&gt;(event));</a>
<a name="ln1703">			}</a>
<a name="ln1704">			break;</a>
<a name="ln1705">		}</a>
<a name="ln1706">		case B_DEBUGGER_MESSAGE_PRE_SYSCALL:</a>
<a name="ln1707">		case B_DEBUGGER_MESSAGE_PROFILER_UPDATE:</a>
<a name="ln1708">		case B_DEBUGGER_MESSAGE_HANDED_OVER:</a>
<a name="ln1709">			// not interested</a>
<a name="ln1710">			break;</a>
<a name="ln1711">		default:</a>
<a name="ln1712">			WARNING(&quot;TeamDebugger for team %&quot; B_PRId32 &quot;: unknown event type: &quot;</a>
<a name="ln1713">				&quot;%&quot; B_PRId32 &quot;\n&quot;, fTeamID, event-&gt;EventType());</a>
<a name="ln1714">			break;</a>
<a name="ln1715">	}</a>
<a name="ln1716"> </a>
<a name="ln1717">	if (!handled &amp;&amp; event-&gt;ThreadStopped())</a>
<a name="ln1718">		fDebuggerInterface-&gt;ContinueThread(event-&gt;Thread());</a>
<a name="ln1719">}</a>
<a name="ln1720"> </a>
<a name="ln1721"> </a>
<a name="ln1722">bool</a>
<a name="ln1723">TeamDebugger::_HandleTeamDeleted(TeamDeletedEvent* event)</a>
<a name="ln1724">{</a>
<a name="ln1725">	char message[64];</a>
<a name="ln1726">	fDebuggerInterface-&gt;Close(false);</a>
<a name="ln1727"> </a>
<a name="ln1728">	snprintf(message, sizeof(message), &quot;Team %&quot; B_PRId32 &quot; has terminated. &quot;,</a>
<a name="ln1729">		event-&gt;Team());</a>
<a name="ln1730"> </a>
<a name="ln1731">	int32 result = fUserInterface-&gt;SynchronouslyAskUser(&quot;Team terminated&quot;,</a>
<a name="ln1732">		message, &quot;Do nothing&quot;, &quot;Quit&quot;, fCommandLineArgc != 0</a>
<a name="ln1733">			? &quot;Restart team&quot; : NULL);</a>
<a name="ln1734"> </a>
<a name="ln1735">	switch (result) {</a>
<a name="ln1736">		case 1:</a>
<a name="ln1737">		case -1:</a>
<a name="ln1738">		{</a>
<a name="ln1739">			PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1740">			break;</a>
<a name="ln1741">		}</a>
<a name="ln1742">		case 2:</a>
<a name="ln1743">		{</a>
<a name="ln1744">			_SaveSettings();</a>
<a name="ln1745">			fListener-&gt;TeamDebuggerRestartRequested(this);</a>
<a name="ln1746">			break;</a>
<a name="ln1747">		}</a>
<a name="ln1748">		default:</a>
<a name="ln1749">			break;</a>
<a name="ln1750">	}</a>
<a name="ln1751"> </a>
<a name="ln1752">	return true;</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755"> </a>
<a name="ln1756">bool</a>
<a name="ln1757">TeamDebugger::_HandleThreadCreated(ThreadCreatedEvent* event)</a>
<a name="ln1758">{</a>
<a name="ln1759">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln1760"> </a>
<a name="ln1761">	ThreadInfo info;</a>
<a name="ln1762">	status_t error = fDebuggerInterface-&gt;GetThreadInfo(event-&gt;NewThread(),</a>
<a name="ln1763">		info);</a>
<a name="ln1764">	if (error == B_OK) {</a>
<a name="ln1765">		::Thread* thread;</a>
<a name="ln1766">		fTeam-&gt;AddThread(info, &amp;thread);</a>
<a name="ln1767"> </a>
<a name="ln1768">		ThreadHandler* handler = new(std::nothrow) ThreadHandler(thread,</a>
<a name="ln1769">			fWorker, fDebuggerInterface, this, fBreakpointManager);</a>
<a name="ln1770">		if (handler != NULL) {</a>
<a name="ln1771">			fThreadHandlers.Insert(handler);</a>
<a name="ln1772">			handler-&gt;Init();</a>
<a name="ln1773">		}</a>
<a name="ln1774">	}</a>
<a name="ln1775"> </a>
<a name="ln1776">	return false;</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779"> </a>
<a name="ln1780">bool</a>
<a name="ln1781">TeamDebugger::_HandleThreadRenamed(ThreadRenamedEvent* event)</a>
<a name="ln1782">{</a>
<a name="ln1783">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln1784"> </a>
<a name="ln1785">	::Thread* thread = fTeam-&gt;ThreadByID(event-&gt;RenamedThread());</a>
<a name="ln1786"> </a>
<a name="ln1787">	if (thread != NULL)</a>
<a name="ln1788">		thread-&gt;SetName(event-&gt;NewName());</a>
<a name="ln1789"> </a>
<a name="ln1790">	return false;</a>
<a name="ln1791">}</a>
<a name="ln1792"> </a>
<a name="ln1793"> </a>
<a name="ln1794">bool</a>
<a name="ln1795">TeamDebugger::_HandleThreadPriorityChanged(ThreadPriorityChangedEvent*)</a>
<a name="ln1796">{</a>
<a name="ln1797">	// TODO: implement once we actually track thread priorities</a>
<a name="ln1798"> </a>
<a name="ln1799">	return false;</a>
<a name="ln1800">}</a>
<a name="ln1801"> </a>
<a name="ln1802"> </a>
<a name="ln1803">bool</a>
<a name="ln1804">TeamDebugger::_HandleThreadDeleted(ThreadDeletedEvent* event)</a>
<a name="ln1805">{</a>
<a name="ln1806">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln1807">	if (ThreadHandler* handler = fThreadHandlers.Lookup(event-&gt;Thread())) {</a>
<a name="ln1808">		fThreadHandlers.Remove(handler);</a>
<a name="ln1809">		handler-&gt;ReleaseReference();</a>
<a name="ln1810">	}</a>
<a name="ln1811">	fTeam-&gt;RemoveThread(event-&gt;Thread());</a>
<a name="ln1812">	return false;</a>
<a name="ln1813">}</a>
<a name="ln1814"> </a>
<a name="ln1815"> </a>
<a name="ln1816">bool</a>
<a name="ln1817">TeamDebugger::_HandleImageCreated(ImageCreatedEvent* event)</a>
<a name="ln1818">{</a>
<a name="ln1819">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln1820">	_AddImage(event-&gt;GetImageInfo());</a>
<a name="ln1821"> </a>
<a name="ln1822">	ImageInfoPendingThread* info = new(std::nothrow) ImageInfoPendingThread(</a>
<a name="ln1823">		event-&gt;GetImageInfo().ImageID(), event-&gt;Thread());</a>
<a name="ln1824">	if (info == NULL)</a>
<a name="ln1825">		return false;</a>
<a name="ln1826"> </a>
<a name="ln1827">	fImageInfoPendingThreads-&gt;Insert(info);</a>
<a name="ln1828">	return true;</a>
<a name="ln1829">}</a>
<a name="ln1830"> </a>
<a name="ln1831"> </a>
<a name="ln1832">bool</a>
<a name="ln1833">TeamDebugger::_HandleImageDeleted(ImageDeletedEvent* event)</a>
<a name="ln1834">{</a>
<a name="ln1835">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln1836">	fTeam-&gt;RemoveImage(event-&gt;GetImageInfo().ImageID());</a>
<a name="ln1837"> </a>
<a name="ln1838">	ImageHandler* imageHandler = fImageHandlers-&gt;Lookup(</a>
<a name="ln1839">		event-&gt;GetImageInfo().ImageID());</a>
<a name="ln1840">	if (imageHandler == NULL)</a>
<a name="ln1841">		return false;</a>
<a name="ln1842"> </a>
<a name="ln1843">	fImageHandlers-&gt;Remove(imageHandler);</a>
<a name="ln1844">	BReference&lt;ImageHandler&gt; imageHandlerReference(imageHandler, true);</a>
<a name="ln1845">	locker.Unlock();</a>
<a name="ln1846"> </a>
<a name="ln1847">	// remove breakpoints in the image</a>
<a name="ln1848">	fBreakpointManager-&gt;RemoveImageBreakpoints(imageHandler-&gt;GetImage());</a>
<a name="ln1849"> </a>
<a name="ln1850">	return false;</a>
<a name="ln1851">}</a>
<a name="ln1852"> </a>
<a name="ln1853"> </a>
<a name="ln1854">bool</a>
<a name="ln1855">TeamDebugger::_HandlePostSyscall(PostSyscallEvent* event)</a>
<a name="ln1856">{</a>
<a name="ln1857">	const SyscallInfo&amp; info = event-&gt;GetSyscallInfo();</a>
<a name="ln1858"> </a>
<a name="ln1859">	switch (info.Syscall()) {</a>
<a name="ln1860">		case SYSCALL_WRITE:</a>
<a name="ln1861">		{</a>
<a name="ln1862">			if ((ssize_t)info.ReturnValue() &lt;= 0)</a>
<a name="ln1863">				break;</a>
<a name="ln1864"> </a>
<a name="ln1865">			int32 fd;</a>
<a name="ln1866">			target_addr_t address;</a>
<a name="ln1867">			size_t size;</a>
<a name="ln1868">			// TODO: decoding the syscall arguments should probably be</a>
<a name="ln1869">			// factored out into an Architecture method of its own, since</a>
<a name="ln1870">			// there's no guarantee the target architecture has the same</a>
<a name="ln1871">			// endianness as the host. This could re-use the syscall</a>
<a name="ln1872">			// argument parser that strace uses, though that would need to</a>
<a name="ln1873">			// be adapted to handle the aforementioned endian differences.</a>
<a name="ln1874">			// This works for x86{-64} for now though.</a>
<a name="ln1875">			if (fTeam-&gt;GetArchitecture()-&gt;AddressSize() == 4) {</a>
<a name="ln1876">				const uint32* args = (const uint32*)info.Arguments();</a>
<a name="ln1877">				fd = args[0];</a>
<a name="ln1878">				address = args[3];</a>
<a name="ln1879">				size = args[4];</a>
<a name="ln1880">			} else {</a>
<a name="ln1881">				const uint64* args = (const uint64*)info.Arguments();</a>
<a name="ln1882">				fd = args[0];</a>
<a name="ln1883">				address = args[2];</a>
<a name="ln1884">				size = args[3];</a>
<a name="ln1885">			}</a>
<a name="ln1886"> </a>
<a name="ln1887">			if (fd == 1 || fd == 2) {</a>
<a name="ln1888">				BString data;</a>
<a name="ln1889"> </a>
<a name="ln1890">				ssize_t result = fDebuggerInterface-&gt;ReadMemoryString(</a>
<a name="ln1891">					address, size, data);</a>
<a name="ln1892">				if (result &gt;= 0)</a>
<a name="ln1893">					fTeam-&gt;NotifyConsoleOutputReceived(fd, data);</a>
<a name="ln1894">			}</a>
<a name="ln1895">			break;</a>
<a name="ln1896">		}</a>
<a name="ln1897">		case SYSCALL_WRITEV:</a>
<a name="ln1898">		{</a>
<a name="ln1899">			// TODO: handle</a>
<a name="ln1900">		}</a>
<a name="ln1901">		default:</a>
<a name="ln1902">			break;</a>
<a name="ln1903">	}</a>
<a name="ln1904"> </a>
<a name="ln1905">	return false;</a>
<a name="ln1906">}</a>
<a name="ln1907"> </a>
<a name="ln1908"> </a>
<a name="ln1909">void</a>
<a name="ln1910">TeamDebugger::_PrepareForTeamExec(TeamExecEvent* event)</a>
<a name="ln1911">{</a>
<a name="ln1912">	// NB: must be called with team lock held.</a>
<a name="ln1913"> </a>
<a name="ln1914">	_SaveSettings();</a>
<a name="ln1915"> </a>
<a name="ln1916">	// when notified of exec, we need to clear out data related</a>
<a name="ln1917">	// to the old team.</a>
<a name="ln1918">	const ImageList&amp; images = fTeam-&gt;Images();</a>
<a name="ln1919"> </a>
<a name="ln1920">	for (ImageList::ConstIterator it = images.GetIterator();</a>
<a name="ln1921">			Image* image = it.Next();) {</a>
<a name="ln1922">		fBreakpointManager-&gt;RemoveImageBreakpoints(image);</a>
<a name="ln1923">	}</a>
<a name="ln1924"> </a>
<a name="ln1925">	BObjectList&lt;UserBreakpoint&gt; breakpointsToRemove(20, false);</a>
<a name="ln1926">	const UserBreakpointList&amp; breakpoints = fTeam-&gt;UserBreakpoints();</a>
<a name="ln1927">	for (UserBreakpointList::ConstIterator it = breakpoints.GetIterator();</a>
<a name="ln1928">			UserBreakpoint* breakpoint = it.Next();) {</a>
<a name="ln1929">		breakpointsToRemove.AddItem(breakpoint);</a>
<a name="ln1930">		breakpoint-&gt;AcquireReference();</a>
<a name="ln1931">	}</a>
<a name="ln1932"> </a>
<a name="ln1933">	for (int32 i = 0; i &lt; breakpointsToRemove.CountItems(); i++) {</a>
<a name="ln1934">		UserBreakpoint* breakpoint = breakpointsToRemove.ItemAt(i);</a>
<a name="ln1935">		fTeam-&gt;RemoveUserBreakpoint(breakpoint);</a>
<a name="ln1936">		fTeam-&gt;NotifyUserBreakpointChanged(breakpoint);</a>
<a name="ln1937">		breakpoint-&gt;ReleaseReference();</a>
<a name="ln1938">	}</a>
<a name="ln1939"> </a>
<a name="ln1940">	fTeam-&gt;ClearImages();</a>
<a name="ln1941">	fTeam-&gt;ClearSignalDispositionMappings();</a>
<a name="ln1942">	fExecPending = true;</a>
<a name="ln1943">}</a>
<a name="ln1944"> </a>
<a name="ln1945"> </a>
<a name="ln1946">void</a>
<a name="ln1947">TeamDebugger::_HandleImageDebugInfoChanged(image_id imageID)</a>
<a name="ln1948">{</a>
<a name="ln1949">	// get the image (via the image handler)</a>
<a name="ln1950">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln1951">	ImageHandler* imageHandler = fImageHandlers-&gt;Lookup(imageID);</a>
<a name="ln1952">	if (imageHandler == NULL)</a>
<a name="ln1953">		return;</a>
<a name="ln1954"> </a>
<a name="ln1955">	Image* image = imageHandler-&gt;GetImage();</a>
<a name="ln1956">	BReference&lt;Image&gt; imageReference(image);</a>
<a name="ln1957">	image_debug_info_state state = image-&gt;ImageDebugInfoState();</a>
<a name="ln1958"> </a>
<a name="ln1959">	bool handlePostExecSetup = fExecPending &amp;&amp; image-&gt;Type() == B_APP_IMAGE</a>
<a name="ln1960">		&amp;&amp; state != IMAGE_DEBUG_INFO_LOADING;</a>
<a name="ln1961">	// this needs to be done first so that breakpoints are loaded.</a>
<a name="ln1962">	// otherwise, UpdateImageBreakpoints() won't find the appropriate</a>
<a name="ln1963">	// UserBreakpoints to create/install instances for.</a>
<a name="ln1964">	if (handlePostExecSetup) {</a>
<a name="ln1965">		fTeam-&gt;SetName(image-&gt;Name());</a>
<a name="ln1966">		_LoadSettings();</a>
<a name="ln1967">		fExecPending = false;</a>
<a name="ln1968">	}</a>
<a name="ln1969"> </a>
<a name="ln1970">	locker.Unlock();</a>
<a name="ln1971"> </a>
<a name="ln1972">	if (state == IMAGE_DEBUG_INFO_LOADED</a>
<a name="ln1973">		|| state == IMAGE_DEBUG_INFO_UNAVAILABLE) {</a>
<a name="ln1974"> </a>
<a name="ln1975">		// update breakpoints in the image</a>
<a name="ln1976">		fBreakpointManager-&gt;UpdateImageBreakpoints(image);</a>
<a name="ln1977"> </a>
<a name="ln1978">		ImageInfoPendingThread* thread =  fImageInfoPendingThreads</a>
<a name="ln1979">			-&gt;Lookup(imageID);</a>
<a name="ln1980">		if (thread != NULL) {</a>
<a name="ln1981">			fImageInfoPendingThreads-&gt;Remove(thread);</a>
<a name="ln1982">			ObjectDeleter&lt;ImageInfoPendingThread&gt; threadDeleter(thread);</a>
<a name="ln1983">			locker.Lock();</a>
<a name="ln1984">			ThreadHandler* handler = _GetThreadHandler(thread-&gt;ThreadID());</a>
<a name="ln1985">			BReference&lt;ThreadHandler&gt; handlerReference(handler, true);</a>
<a name="ln1986">			if (fTeam-&gt;StopOnImageLoad()) {</a>
<a name="ln1987"> </a>
<a name="ln1988">				bool stop = true;</a>
<a name="ln1989">				const BString&amp; imageName = image-&gt;Name();</a>
<a name="ln1990">				// only match on the image filename itself</a>
<a name="ln1991">				const char* rawImageName = imageName.String()</a>
<a name="ln1992">					+ imageName.FindLast('/') + 1;</a>
<a name="ln1993">				if (fTeam-&gt;StopImageNameListEnabled()) {</a>
<a name="ln1994">					const BStringList&amp; nameList = fTeam-&gt;StopImageNames();</a>
<a name="ln1995">					stop = nameList.HasString(rawImageName);</a>
<a name="ln1996">				}</a>
<a name="ln1997"> </a>
<a name="ln1998">				if (stop &amp;&amp; handler != NULL) {</a>
<a name="ln1999">					BString stopReason;</a>
<a name="ln2000">					stopReason.SetToFormat(&quot;Image '%s' loaded.&quot;,</a>
<a name="ln2001">						rawImageName);</a>
<a name="ln2002">					locker.Unlock();</a>
<a name="ln2003"> </a>
<a name="ln2004">					if (handler-&gt;HandleThreadDebugged(NULL, stopReason))</a>
<a name="ln2005">						return;</a>
<a name="ln2006">				} else</a>
<a name="ln2007">					locker.Unlock();</a>
<a name="ln2008">			} else if (handlePostExecSetup) {</a>
<a name="ln2009">				// in the case of an exec(), we can't stop in main() until</a>
<a name="ln2010">				// the new app image has been loaded, so we know where to</a>
<a name="ln2011">				// set the main breakpoint at.</a>
<a name="ln2012">				SymbolInfo symbolInfo;</a>
<a name="ln2013">				if (fDebuggerInterface-&gt;GetSymbolInfo(fTeam-&gt;ID(), image-&gt;ID(),</a>
<a name="ln2014">						&quot;main&quot;, B_SYMBOL_TYPE_TEXT, symbolInfo) == B_OK) {</a>
<a name="ln2015">					handler-&gt;SetBreakpointAndRun(symbolInfo.Address());</a>
<a name="ln2016">				}</a>
<a name="ln2017">			} else {</a>
<a name="ln2018">				locker.Unlock();</a>
<a name="ln2019">				fDebuggerInterface-&gt;ContinueThread(thread-&gt;ThreadID());</a>
<a name="ln2020">			}</a>
<a name="ln2021">		}</a>
<a name="ln2022">	}</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025"> </a>
<a name="ln2026">void</a>
<a name="ln2027">TeamDebugger::_HandleImageFileChanged(image_id imageID)</a>
<a name="ln2028">{</a>
<a name="ln2029">	TRACE_IMAGES(&quot;TeamDebugger::_HandleImageFileChanged(%&quot; B_PRId32 &quot;)\n&quot;,</a>
<a name="ln2030">		imageID);</a>
<a name="ln2031">// TODO: Reload the debug info!</a>
<a name="ln2032">}</a>
<a name="ln2033"> </a>
<a name="ln2034"> </a>
<a name="ln2035">void</a>
<a name="ln2036">TeamDebugger::_HandleSetUserBreakpoint(target_addr_t address, bool enabled,</a>
<a name="ln2037">	bool hidden)</a>
<a name="ln2038">{</a>
<a name="ln2039">	TRACE_CONTROL(&quot;TeamDebugger::_HandleSetUserBreakpoint(%#&quot; B_PRIx64</a>
<a name="ln2040">		&quot;, %d, %d)\n&quot;, address, enabled, hidden);</a>
<a name="ln2041"> </a>
<a name="ln2042">	// check whether there already is a breakpoint</a>
<a name="ln2043">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln2044"> </a>
<a name="ln2045">	Breakpoint* breakpoint = fTeam-&gt;BreakpointAtAddress(address);</a>
<a name="ln2046">	UserBreakpoint* userBreakpoint = NULL;</a>
<a name="ln2047">	if (breakpoint != NULL &amp;&amp; breakpoint-&gt;FirstUserBreakpoint() != NULL)</a>
<a name="ln2048">		userBreakpoint = breakpoint-&gt;FirstUserBreakpoint()-&gt;GetUserBreakpoint();</a>
<a name="ln2049">	BReference&lt;UserBreakpoint&gt; userBreakpointReference(userBreakpoint);</a>
<a name="ln2050"> </a>
<a name="ln2051">	if (userBreakpoint == NULL) {</a>
<a name="ln2052">		TRACE_CONTROL(&quot;  no breakpoint yet\n&quot;);</a>
<a name="ln2053"> </a>
<a name="ln2054">		// get the function at the address</a>
<a name="ln2055">		Image* image = fTeam-&gt;ImageByAddress(address);</a>
<a name="ln2056"> </a>
<a name="ln2057">		TRACE_CONTROL(&quot;  image: %p\n&quot;, image);</a>
<a name="ln2058"> </a>
<a name="ln2059">		if (image == NULL)</a>
<a name="ln2060">			return;</a>
<a name="ln2061">		ImageDebugInfo* imageDebugInfo = image-&gt;GetImageDebugInfo();</a>
<a name="ln2062"> </a>
<a name="ln2063">		TRACE_CONTROL(&quot;  image debug info: %p\n&quot;, imageDebugInfo);</a>
<a name="ln2064"> </a>
<a name="ln2065">		if (imageDebugInfo == NULL)</a>
<a name="ln2066">			return;</a>
<a name="ln2067">			// TODO: Handle this case by loading the debug info, if possible!</a>
<a name="ln2068">		FunctionInstance* functionInstance</a>
<a name="ln2069">			= imageDebugInfo-&gt;FunctionAtAddress(address);</a>
<a name="ln2070"> </a>
<a name="ln2071">		TRACE_CONTROL(&quot;  function instance: %p\n&quot;, functionInstance);</a>
<a name="ln2072"> </a>
<a name="ln2073">		if (functionInstance == NULL)</a>
<a name="ln2074">			return;</a>
<a name="ln2075">		Function* function = functionInstance-&gt;GetFunction();</a>
<a name="ln2076"> </a>
<a name="ln2077">		TRACE_CONTROL(&quot;  function: %p\n&quot;, function);</a>
<a name="ln2078"> </a>
<a name="ln2079">		// get the source location for the address</a>
<a name="ln2080">		FunctionDebugInfo* functionDebugInfo</a>
<a name="ln2081">			= functionInstance-&gt;GetFunctionDebugInfo();</a>
<a name="ln2082">		SourceLocation sourceLocation;</a>
<a name="ln2083">		Statement* breakpointStatement = NULL;</a>
<a name="ln2084">		if (functionDebugInfo-&gt;GetSpecificImageDebugInfo()-&gt;GetStatement(</a>
<a name="ln2085">				functionDebugInfo, address, breakpointStatement) != B_OK) {</a>
<a name="ln2086">			return;</a>
<a name="ln2087">		}</a>
<a name="ln2088"> </a>
<a name="ln2089">		sourceLocation = breakpointStatement-&gt;StartSourceLocation();</a>
<a name="ln2090">		breakpointStatement-&gt;ReleaseReference();</a>
<a name="ln2091"> </a>
<a name="ln2092">		target_addr_t relativeAddress = address - functionInstance-&gt;Address();</a>
<a name="ln2093"> </a>
<a name="ln2094">		TRACE_CONTROL(&quot;  relative address: %#&quot; B_PRIx64 &quot;, source location: &quot;</a>
<a name="ln2095">			&quot;(%&quot; B_PRId32 &quot;, %&quot; B_PRId32 &quot;)\n&quot;, relativeAddress,</a>
<a name="ln2096">			sourceLocation.Line(), sourceLocation.Column());</a>
<a name="ln2097"> </a>
<a name="ln2098">		// get function id</a>
<a name="ln2099">		FunctionID* functionID = functionInstance-&gt;GetFunctionID();</a>
<a name="ln2100">		if (functionID == NULL)</a>
<a name="ln2101">			return;</a>
<a name="ln2102">		BReference&lt;FunctionID&gt; functionIDReference(functionID, true);</a>
<a name="ln2103"> </a>
<a name="ln2104">		// create the user breakpoint</a>
<a name="ln2105">		userBreakpoint = new(std::nothrow) UserBreakpoint(</a>
<a name="ln2106">			UserBreakpointLocation(functionID, function-&gt;SourceFile(),</a>
<a name="ln2107">				sourceLocation, relativeAddress));</a>
<a name="ln2108">		if (userBreakpoint == NULL)</a>
<a name="ln2109">			return;</a>
<a name="ln2110">		userBreakpointReference.SetTo(userBreakpoint, true);</a>
<a name="ln2111"> </a>
<a name="ln2112">		userBreakpoint-&gt;SetHidden(hidden);</a>
<a name="ln2113"> </a>
<a name="ln2114">		TRACE_CONTROL(&quot;  created user breakpoint: %p\n&quot;, userBreakpoint);</a>
<a name="ln2115"> </a>
<a name="ln2116">		// iterate through all function instances and create</a>
<a name="ln2117">		// UserBreakpointInstances</a>
<a name="ln2118">		for (FunctionInstanceList::ConstIterator it</a>
<a name="ln2119">					= function-&gt;Instances().GetIterator();</a>
<a name="ln2120">				FunctionInstance* instance = it.Next();) {</a>
<a name="ln2121">			TRACE_CONTROL(&quot;  function instance %p: range: %#&quot; B_PRIx64 &quot; - %#&quot;</a>
<a name="ln2122">				B_PRIx64 &quot;\n&quot;, instance, instance-&gt;Address(),</a>
<a name="ln2123">				instance-&gt;Address() + instance-&gt;Size());</a>
<a name="ln2124"> </a>
<a name="ln2125">			// get the breakpoint address for the instance</a>
<a name="ln2126">			target_addr_t instanceAddress = 0;</a>
<a name="ln2127">			if (instance == functionInstance) {</a>
<a name="ln2128">				instanceAddress = address;</a>
<a name="ln2129">			} else if (functionInstance-&gt;SourceFile() != NULL) {</a>
<a name="ln2130">				// We have a source file, so get the address for the source</a>
<a name="ln2131">				// location.</a>
<a name="ln2132">				Statement* statement = NULL;</a>
<a name="ln2133">				functionDebugInfo = instance-&gt;GetFunctionDebugInfo();</a>
<a name="ln2134">				functionDebugInfo-&gt;GetSpecificImageDebugInfo()</a>
<a name="ln2135">					-&gt;GetStatementAtSourceLocation(functionDebugInfo,</a>
<a name="ln2136">						sourceLocation, statement);</a>
<a name="ln2137">				if (statement != NULL) {</a>
<a name="ln2138">					instanceAddress = statement-&gt;CoveringAddressRange().Start();</a>
<a name="ln2139">						// TODO: What about BreakpointAllowed()?</a>
<a name="ln2140">					statement-&gt;ReleaseReference();</a>
<a name="ln2141">				}</a>
<a name="ln2142">			}</a>
<a name="ln2143"> </a>
<a name="ln2144">			TRACE_CONTROL(&quot;    breakpoint address using source info: %&quot; B_PRIx64</a>
<a name="ln2145">				&quot;\n&quot;, instanceAddress);</a>
<a name="ln2146"> </a>
<a name="ln2147">			if (instanceAddress == 0) {</a>
<a name="ln2148">				// No source file (or we failed getting the statement), so try</a>
<a name="ln2149">				// to use the same relative address.</a>
<a name="ln2150">				if (relativeAddress &gt; instance-&gt;Size())</a>
<a name="ln2151">					continue;</a>
<a name="ln2152">				instanceAddress = instance-&gt;Address() + relativeAddress;</a>
<a name="ln2153">			}</a>
<a name="ln2154"> </a>
<a name="ln2155">			TRACE_CONTROL(&quot;    final breakpoint address: %&quot; B_PRIx64 &quot;\n&quot;,</a>
<a name="ln2156">				instanceAddress);</a>
<a name="ln2157"> </a>
<a name="ln2158">			UserBreakpointInstance* breakpointInstance = new(std::nothrow)</a>
<a name="ln2159">				UserBreakpointInstance(userBreakpoint, instanceAddress);</a>
<a name="ln2160">			if (breakpointInstance == NULL</a>
<a name="ln2161">				|| !userBreakpoint-&gt;AddInstance(breakpointInstance)) {</a>
<a name="ln2162">				delete breakpointInstance;</a>
<a name="ln2163">				return;</a>
<a name="ln2164">			}</a>
<a name="ln2165"> </a>
<a name="ln2166">			TRACE_CONTROL(&quot;  breakpoint instance: %p\n&quot;, breakpointInstance);</a>
<a name="ln2167">		}</a>
<a name="ln2168">	}</a>
<a name="ln2169"> </a>
<a name="ln2170">	locker.Unlock();</a>
<a name="ln2171"> </a>
<a name="ln2172">	_HandleSetUserBreakpoint(userBreakpoint, enabled);</a>
<a name="ln2173">}</a>
<a name="ln2174"> </a>
<a name="ln2175"> </a>
<a name="ln2176">void</a>
<a name="ln2177">TeamDebugger::_HandleSetUserBreakpoint(UserBreakpoint* breakpoint, bool enabled)</a>
<a name="ln2178">{</a>
<a name="ln2179">	status_t error = fBreakpointManager-&gt;InstallUserBreakpoint(breakpoint,</a>
<a name="ln2180">		enabled);</a>
<a name="ln2181">	if (error != B_OK) {</a>
<a name="ln2182">		_NotifyUser(&quot;Install Breakpoint&quot;, &quot;Failed to install breakpoint: %s&quot;,</a>
<a name="ln2183">			strerror(error));</a>
<a name="ln2184">	}</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187"> </a>
<a name="ln2188">void</a>
<a name="ln2189">TeamDebugger::_HandleClearUserBreakpoint(target_addr_t address)</a>
<a name="ln2190">{</a>
<a name="ln2191">	TRACE_CONTROL(&quot;TeamDebugger::_HandleClearUserBreakpoint(%#&quot; B_PRIx64 &quot;)\n&quot;,</a>
<a name="ln2192">		address);</a>
<a name="ln2193"> </a>
<a name="ln2194">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln2195"> </a>
<a name="ln2196">	Breakpoint* breakpoint = fTeam-&gt;BreakpointAtAddress(address);</a>
<a name="ln2197">	if (breakpoint == NULL || breakpoint-&gt;FirstUserBreakpoint() == NULL)</a>
<a name="ln2198">		return;</a>
<a name="ln2199">	UserBreakpoint* userBreakpoint</a>
<a name="ln2200">		= breakpoint-&gt;FirstUserBreakpoint()-&gt;GetUserBreakpoint();</a>
<a name="ln2201">	BReference&lt;UserBreakpoint&gt; userBreakpointReference(userBreakpoint);</a>
<a name="ln2202"> </a>
<a name="ln2203">	locker.Unlock();</a>
<a name="ln2204"> </a>
<a name="ln2205">	_HandleClearUserBreakpoint(userBreakpoint);</a>
<a name="ln2206">}</a>
<a name="ln2207"> </a>
<a name="ln2208"> </a>
<a name="ln2209">void</a>
<a name="ln2210">TeamDebugger::_HandleClearUserBreakpoint(UserBreakpoint* breakpoint)</a>
<a name="ln2211">{</a>
<a name="ln2212">	fBreakpointManager-&gt;UninstallUserBreakpoint(breakpoint);</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215"> </a>
<a name="ln2216">void</a>
<a name="ln2217">TeamDebugger::_HandleSetWatchpoint(target_addr_t address, uint32 type,</a>
<a name="ln2218">	int32 length, bool enabled)</a>
<a name="ln2219">{</a>
<a name="ln2220">	Watchpoint* watchpoint = new(std::nothrow) Watchpoint(address, type,</a>
<a name="ln2221">		length);</a>
<a name="ln2222"> </a>
<a name="ln2223">	if (watchpoint == NULL)</a>
<a name="ln2224">		return;</a>
<a name="ln2225">	BReference&lt;Watchpoint&gt; watchpointRef(watchpoint, true);</a>
<a name="ln2226"> </a>
<a name="ln2227">	_HandleSetWatchpoint(watchpoint, enabled);</a>
<a name="ln2228">}</a>
<a name="ln2229"> </a>
<a name="ln2230"> </a>
<a name="ln2231">void</a>
<a name="ln2232">TeamDebugger::_HandleSetWatchpoint(Watchpoint* watchpoint, bool enabled)</a>
<a name="ln2233">{</a>
<a name="ln2234">	status_t error = fWatchpointManager-&gt;InstallWatchpoint(watchpoint,</a>
<a name="ln2235">		enabled);</a>
<a name="ln2236">	if (error != B_OK) {</a>
<a name="ln2237">		_NotifyUser(&quot;Install Watchpoint&quot;, &quot;Failed to install watchpoint: %s&quot;,</a>
<a name="ln2238">			strerror(error));</a>
<a name="ln2239">	}</a>
<a name="ln2240">}</a>
<a name="ln2241"> </a>
<a name="ln2242"> </a>
<a name="ln2243">void</a>
<a name="ln2244">TeamDebugger::_HandleClearWatchpoint(target_addr_t address)</a>
<a name="ln2245">{</a>
<a name="ln2246">	TRACE_CONTROL(&quot;TeamDebugger::_HandleClearWatchpoint(%#&quot; B_PRIx64 &quot;)\n&quot;,</a>
<a name="ln2247">		address);</a>
<a name="ln2248"> </a>
<a name="ln2249">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln2250"> </a>
<a name="ln2251">	Watchpoint* watchpoint = fTeam-&gt;WatchpointAtAddress(address);</a>
<a name="ln2252">	if (watchpoint == NULL)</a>
<a name="ln2253">		return;</a>
<a name="ln2254">	BReference&lt;Watchpoint&gt; watchpointReference(watchpoint);</a>
<a name="ln2255"> </a>
<a name="ln2256">	locker.Unlock();</a>
<a name="ln2257"> </a>
<a name="ln2258">	_HandleClearWatchpoint(watchpoint);</a>
<a name="ln2259">}</a>
<a name="ln2260"> </a>
<a name="ln2261"> </a>
<a name="ln2262">void</a>
<a name="ln2263">TeamDebugger::_HandleClearWatchpoint(Watchpoint* watchpoint)</a>
<a name="ln2264">{</a>
<a name="ln2265">	fWatchpointManager-&gt;UninstallWatchpoint(watchpoint);</a>
<a name="ln2266">}</a>
<a name="ln2267"> </a>
<a name="ln2268"> </a>
<a name="ln2269">void</a>
<a name="ln2270">TeamDebugger::_HandleInspectAddress(target_addr_t address,</a>
<a name="ln2271">	TeamMemoryBlock::Listener* listener)</a>
<a name="ln2272">{</a>
<a name="ln2273">	TRACE_CONTROL(&quot;TeamDebugger::_HandleInspectAddress(%&quot; B_PRIx64 &quot;, %p)\n&quot;,</a>
<a name="ln2274">		address, listener);</a>
<a name="ln2275"> </a>
<a name="ln2276">	TeamMemoryBlock* memoryBlock = fMemoryBlockManager</a>
<a name="ln2277">		-&gt;GetMemoryBlock(address);</a>
<a name="ln2278"> </a>
<a name="ln2279">	if (memoryBlock == NULL) {</a>
<a name="ln2280">		_NotifyUser(&quot;Inspect Address&quot;, &quot;Failed to allocate memory block&quot;);</a>
<a name="ln2281">		return;</a>
<a name="ln2282">	}</a>
<a name="ln2283"> </a>
<a name="ln2284">	if (!memoryBlock-&gt;IsValid()) {</a>
<a name="ln2285">		AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln2286"> </a>
<a name="ln2287">		if (!memoryBlock-&gt;HasListener(listener))</a>
<a name="ln2288">			memoryBlock-&gt;AddListener(listener);</a>
<a name="ln2289"> </a>
<a name="ln2290">		TeamMemory* memory = fTeam-&gt;GetTeamMemory();</a>
<a name="ln2291">		// schedule the job</a>
<a name="ln2292">		status_t result;</a>
<a name="ln2293">		if ((result = fWorker-&gt;ScheduleJob(</a>
<a name="ln2294">			new(std::nothrow) RetrieveMemoryBlockJob(fTeam, memory,</a>
<a name="ln2295">				memoryBlock),</a>
<a name="ln2296">			this)) != B_OK) {</a>
<a name="ln2297"> </a>
<a name="ln2298">			memoryBlock-&gt;NotifyDataRetrieved(result);</a>
<a name="ln2299">			memoryBlock-&gt;ReleaseReference();</a>
<a name="ln2300"> </a>
<a name="ln2301">			_NotifyUser(&quot;Inspect Address&quot;, &quot;Failed to retrieve memory data: %s&quot;,</a>
<a name="ln2302">				strerror(result));</a>
<a name="ln2303">		}</a>
<a name="ln2304">	} else</a>
<a name="ln2305">		memoryBlock-&gt;NotifyDataRetrieved();</a>
<a name="ln2306"> </a>
<a name="ln2307">}</a>
<a name="ln2308"> </a>
<a name="ln2309"> </a>
<a name="ln2310">void</a>
<a name="ln2311">TeamDebugger::_HandleWriteMemory(target_addr_t address, void* data,</a>
<a name="ln2312">	target_size_t size)</a>
<a name="ln2313">{</a>
<a name="ln2314">	TRACE_CONTROL(&quot;TeamDebugger::_HandleWriteTargetMemory(%&quot; B_PRIx64 &quot;, %p, &quot;</a>
<a name="ln2315">		&quot;%&quot; B_PRIu64 &quot;)\n&quot;, address, data, size);</a>
<a name="ln2316"> </a>
<a name="ln2317">	AutoLocker&lt; ::Team&gt; teamLocker(fTeam);</a>
<a name="ln2318">	TeamMemory* memory = fTeam-&gt;GetTeamMemory();</a>
<a name="ln2319">	// schedule the job</a>
<a name="ln2320">	status_t result;</a>
<a name="ln2321">	if ((result = fWorker-&gt;ScheduleJob(</a>
<a name="ln2322">		new(std::nothrow) WriteMemoryJob(fTeam, memory, address, data, size),</a>
<a name="ln2323">		this)) != B_OK) {</a>
<a name="ln2324">		_NotifyUser(&quot;Write Memory&quot;, &quot;Failed to write memory data: %s&quot;,</a>
<a name="ln2325">			strerror(result));</a>
<a name="ln2326">	}</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329"> </a>
<a name="ln2330">void</a>
<a name="ln2331">TeamDebugger::_HandleEvaluateExpression(SourceLanguage* language,</a>
<a name="ln2332">	ExpressionInfo* info, StackFrame* frame, ::Thread* thread)</a>
<a name="ln2333">{</a>
<a name="ln2334">	status_t result = fWorker-&gt;ScheduleJob(</a>
<a name="ln2335">		new(std::nothrow) ExpressionEvaluationJob(fTeam, fDebuggerInterface,</a>
<a name="ln2336">			language, info, frame, thread));</a>
<a name="ln2337">	if (result != B_OK) {</a>
<a name="ln2338">		_NotifyUser(&quot;Evaluate Expression&quot;, &quot;Failed to evaluate expression: %s&quot;,</a>
<a name="ln2339">			strerror(result));</a>
<a name="ln2340">	}</a>
<a name="ln2341">}</a>
<a name="ln2342"> </a>
<a name="ln2343"> </a>
<a name="ln2344">void</a>
<a name="ln2345">TeamDebugger::_HandleWriteCoreFile(const entry_ref&amp; targetPath)</a>
<a name="ln2346">{</a>
<a name="ln2347">	status_t result = fWorker-&gt;ScheduleJob(</a>
<a name="ln2348">		new(std::nothrow) WriteCoreFileJob(fTeam, fDebuggerInterface,</a>
<a name="ln2349">			targetPath));</a>
<a name="ln2350">	if (result != B_OK) {</a>
<a name="ln2351">		_NotifyUser(&quot;Write Core File&quot;, &quot;Failed to write core file: %s&quot;,</a>
<a name="ln2352">			strerror(result));</a>
<a name="ln2353">	}</a>
<a name="ln2354">}</a>
<a name="ln2355"> </a>
<a name="ln2356"> </a>
<a name="ln2357">status_t</a>
<a name="ln2358">TeamDebugger::_HandleSetArguments(int argc, const char* const* argv)</a>
<a name="ln2359">{</a>
<a name="ln2360">	fCommandLineArgc = argc;</a>
<a name="ln2361">	fCommandLineArgv = new(std::nothrow) const char*[argc];</a>
<a name="ln2362">	if (fCommandLineArgv == NULL)</a>
<a name="ln2363">		return B_NO_MEMORY;</a>
<a name="ln2364"> </a>
<a name="ln2365">	memset(const_cast&lt;char **&gt;(fCommandLineArgv), 0, sizeof(char*) * argc);</a>
<a name="ln2366"> </a>
<a name="ln2367">	for (int i = 0; i &lt; argc; i++) {</a>
<a name="ln2368">		fCommandLineArgv[i] = strdup(argv[i]);</a>
<a name="ln2369">		if (fCommandLineArgv[i] == NULL)</a>
<a name="ln2370">			return B_NO_MEMORY;</a>
<a name="ln2371">	}</a>
<a name="ln2372"> </a>
<a name="ln2373">	return B_OK;</a>
<a name="ln2374">}</a>
<a name="ln2375"> </a>
<a name="ln2376"> </a>
<a name="ln2377">void</a>
<a name="ln2378">TeamDebugger::_HandleDebugInfoJobUserInput(ImageDebugInfoLoadingState* state)</a>
<a name="ln2379">{</a>
<a name="ln2380">	SpecificImageDebugInfoLoadingState* specificState</a>
<a name="ln2381">		= state-&gt;GetSpecificDebugInfoLoadingState();</a>
<a name="ln2382"> </a>
<a name="ln2383">	ImageDebugLoadingStateHandler* handler;</a>
<a name="ln2384">	if (ImageDebugLoadingStateHandlerRoster::Default()</a>
<a name="ln2385">			-&gt;FindStateHandler(specificState, handler) != B_OK) {</a>
<a name="ln2386">		TRACE_JOBS(&quot;TeamDebugger::_HandleDebugInfoJobUserInput(): &quot;</a>
<a name="ln2387">			&quot;Failed to find appropriate information handler, aborting.&quot;);</a>
<a name="ln2388">		return;</a>
<a name="ln2389">	}</a>
<a name="ln2390"> </a>
<a name="ln2391">	handler-&gt;HandleState(specificState, fUserInterface);</a>
<a name="ln2392">}</a>
<a name="ln2393"> </a>
<a name="ln2394"> </a>
<a name="ln2395">ThreadHandler*</a>
<a name="ln2396">TeamDebugger::_GetThreadHandler(thread_id threadID)</a>
<a name="ln2397">{</a>
<a name="ln2398">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln2399"> </a>
<a name="ln2400">	ThreadHandler* handler = fThreadHandlers.Lookup(threadID);</a>
<a name="ln2401">	if (handler != NULL)</a>
<a name="ln2402">		handler-&gt;AcquireReference();</a>
<a name="ln2403">	return handler;</a>
<a name="ln2404">}</a>
<a name="ln2405"> </a>
<a name="ln2406"> </a>
<a name="ln2407">status_t</a>
<a name="ln2408">TeamDebugger::_AddImage(const ImageInfo&amp; imageInfo, Image** _image)</a>
<a name="ln2409">{</a>
<a name="ln2410">	LocatableFile* file = NULL;</a>
<a name="ln2411">	if (strchr(imageInfo.Name(), '/') != NULL)</a>
<a name="ln2412">		file = fFileManager-&gt;GetTargetFile(imageInfo.Name());</a>
<a name="ln2413">	BReference&lt;LocatableFile&gt; imageFileReference(file, true);</a>
<a name="ln2414"> </a>
<a name="ln2415">	Image* image;</a>
<a name="ln2416">	status_t error = fTeam-&gt;AddImage(imageInfo, file, &amp;image);</a>
<a name="ln2417">	if (error != B_OK)</a>
<a name="ln2418">		return error;</a>
<a name="ln2419"> </a>
<a name="ln2420">	ImageDebugInfoRequested(image);</a>
<a name="ln2421"> </a>
<a name="ln2422">	ImageHandler* imageHandler = new(std::nothrow) ImageHandler(this, image);</a>
<a name="ln2423">	if (imageHandler != NULL)</a>
<a name="ln2424">		fImageHandlers-&gt;Insert(imageHandler);</a>
<a name="ln2425"> </a>
<a name="ln2426">	if (_image != NULL)</a>
<a name="ln2427">		*_image = image;</a>
<a name="ln2428"> </a>
<a name="ln2429">	return B_OK;</a>
<a name="ln2430">}</a>
<a name="ln2431"> </a>
<a name="ln2432"> </a>
<a name="ln2433">void</a>
<a name="ln2434">TeamDebugger::_LoadSettings()</a>
<a name="ln2435">{</a>
<a name="ln2436">	// get the team name</a>
<a name="ln2437">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln2438">	BString teamName = fTeam-&gt;Name();</a>
<a name="ln2439">	locker.Unlock();</a>
<a name="ln2440"> </a>
<a name="ln2441">	// load the settings</a>
<a name="ln2442">	if (fSettingsManager-&gt;LoadTeamSettings(teamName, fTeamSettings) != B_OK)</a>
<a name="ln2443">		return;</a>
<a name="ln2444"> </a>
<a name="ln2445">	// create the saved breakpoints</a>
<a name="ln2446">	for (int32 i = 0; const BreakpointSetting* breakpointSetting</a>
<a name="ln2447">			= fTeamSettings.BreakpointAt(i); i++) {</a>
<a name="ln2448">		if (breakpointSetting-&gt;GetFunctionID() == NULL)</a>
<a name="ln2449">			continue;</a>
<a name="ln2450"> </a>
<a name="ln2451">		// get the source file, if any</a>
<a name="ln2452">		LocatableFile* sourceFile = NULL;</a>
<a name="ln2453">		if (breakpointSetting-&gt;SourceFile().Length() &gt; 0) {</a>
<a name="ln2454">			sourceFile = fFileManager-&gt;GetSourceFile(</a>
<a name="ln2455">				breakpointSetting-&gt;SourceFile());</a>
<a name="ln2456">			if (sourceFile == NULL)</a>
<a name="ln2457">				continue;</a>
<a name="ln2458">		}</a>
<a name="ln2459">		BReference&lt;LocatableFile&gt; sourceFileReference(sourceFile, true);</a>
<a name="ln2460"> </a>
<a name="ln2461">		// create the breakpoint</a>
<a name="ln2462">		UserBreakpointLocation location(breakpointSetting-&gt;GetFunctionID(),</a>
<a name="ln2463">			sourceFile, breakpointSetting-&gt;GetSourceLocation(),</a>
<a name="ln2464">			breakpointSetting-&gt;RelativeAddress());</a>
<a name="ln2465"> </a>
<a name="ln2466">		UserBreakpoint* breakpoint = new(std::nothrow) UserBreakpoint(location);</a>
<a name="ln2467">		if (breakpoint == NULL)</a>
<a name="ln2468">			return;</a>
<a name="ln2469">		BReference&lt;UserBreakpoint&gt; breakpointReference(breakpoint, true);</a>
<a name="ln2470"> </a>
<a name="ln2471">		breakpoint-&gt;SetHidden(breakpointSetting-&gt;IsHidden());</a>
<a name="ln2472">		breakpoint-&gt;SetCondition(breakpointSetting-&gt;Condition());</a>
<a name="ln2473"> </a>
<a name="ln2474">		// install it</a>
<a name="ln2475">		fBreakpointManager-&gt;InstallUserBreakpoint(breakpoint,</a>
<a name="ln2476">			breakpointSetting-&gt;IsEnabled());</a>
<a name="ln2477">	}</a>
<a name="ln2478"> </a>
<a name="ln2479">	fFileManager-&gt;LoadLocationMappings(fTeamSettings.FileManagerSettings());</a>
<a name="ln2480"> </a>
<a name="ln2481">	const TeamUiSettings* uiSettings = fTeamSettings.UiSettingFor(</a>
<a name="ln2482">		fUserInterface-&gt;ID());</a>
<a name="ln2483">	if (uiSettings != NULL)</a>
<a name="ln2484">			fUserInterface-&gt;LoadSettings(uiSettings);</a>
<a name="ln2485"> </a>
<a name="ln2486">	const TeamSignalSettings* signalSettings = fTeamSettings.SignalSettings();</a>
<a name="ln2487">	if (signalSettings != NULL) {</a>
<a name="ln2488">		fTeam-&gt;SetDefaultSignalDisposition(</a>
<a name="ln2489">			signalSettings-&gt;DefaultSignalDisposition());</a>
<a name="ln2490"> </a>
<a name="ln2491">		int32 signal;</a>
<a name="ln2492">		int32 disposition;</a>
<a name="ln2493">		for (int32 i = 0; i &lt; signalSettings-&gt;CountCustomSignalDispositions();</a>
<a name="ln2494">			i++) {</a>
<a name="ln2495">			if (signalSettings-&gt;GetCustomSignalDispositionAt(i, signal,</a>
<a name="ln2496">				disposition) == B_OK) {</a>
<a name="ln2497">				fTeam-&gt;SetCustomSignalDisposition(signal, disposition);</a>
<a name="ln2498">			}</a>
<a name="ln2499">		}</a>
<a name="ln2500">	}</a>
<a name="ln2501">}</a>
<a name="ln2502"> </a>
<a name="ln2503"> </a>
<a name="ln2504">void</a>
<a name="ln2505">TeamDebugger::_SaveSettings()</a>
<a name="ln2506">{</a>
<a name="ln2507">	// get the settings</a>
<a name="ln2508">	AutoLocker&lt; ::Team&gt; locker(fTeam);</a>
<a name="ln2509">	TeamSettings settings;</a>
<a name="ln2510">	if (settings.SetTo(fTeam) != B_OK)</a>
<a name="ln2511">		return;</a>
<a name="ln2512"> </a>
<a name="ln2513">	TeamUiSettings* uiSettings = NULL;</a>
<a name="ln2514">	if (fUserInterface-&gt;SaveSettings(uiSettings) != B_OK)</a>
<a name="ln2515">		return;</a>
<a name="ln2516">	if (uiSettings != NULL)</a>
<a name="ln2517">		settings.AddUiSettings(uiSettings);</a>
<a name="ln2518"> </a>
<a name="ln2519">	// preserve the UI settings from our cached copy.</a>
<a name="ln2520">	for (int32 i = 0; i &lt; fTeamSettings.CountUiSettings(); i++) {</a>
<a name="ln2521">		const TeamUiSettings* oldUiSettings = fTeamSettings.UiSettingAt(i);</a>
<a name="ln2522">		if (strcmp(oldUiSettings-&gt;ID(), fUserInterface-&gt;ID()) != 0) {</a>
<a name="ln2523">			TeamUiSettings* clonedSettings = oldUiSettings-&gt;Clone();</a>
<a name="ln2524">			if (clonedSettings != NULL)</a>
<a name="ln2525">				settings.AddUiSettings(clonedSettings);</a>
<a name="ln2526">		}</a>
<a name="ln2527">	}</a>
<a name="ln2528"> </a>
<a name="ln2529">	fFileManager-&gt;SaveLocationMappings(settings.FileManagerSettings());</a>
<a name="ln2530">	locker.Unlock();</a>
<a name="ln2531"> </a>
<a name="ln2532">	// save the settings</a>
<a name="ln2533">	fSettingsManager-&gt;SaveTeamSettings(settings);</a>
<a name="ln2534">}</a>
<a name="ln2535"> </a>
<a name="ln2536"> </a>
<a name="ln2537">void</a>
<a name="ln2538">TeamDebugger::_NotifyUser(const char* title, const char* text,...)</a>
<a name="ln2539">{</a>
<a name="ln2540">	// print the message</a>
<a name="ln2541">	char buffer[1024];</a>
<a name="ln2542">	va_list args;</a>
<a name="ln2543">	va_start(args, text);</a>
<a name="ln2544">	vsnprintf(buffer, sizeof(buffer), text, args);</a>
<a name="ln2545">	va_end(args);</a>
<a name="ln2546"> </a>
<a name="ln2547">	// notify the user</a>
<a name="ln2548">	fUserInterface-&gt;NotifyUser(title, buffer, USER_NOTIFICATION_WARNING);</a>
<a name="ln2549">}</a>
<a name="ln2550"> </a>
<a name="ln2551"> </a>
<a name="ln2552">void</a>
<a name="ln2553">TeamDebugger::_ResetUserBackgroundStatusIfNeeded()</a>
<a name="ln2554">{</a>
<a name="ln2555">	if (!fTerminating &amp;&amp; !fWorker-&gt;HasPendingJobs())</a>
<a name="ln2556">		PostMessage(MSG_RESET_USER_BACKGROUND_STATUS);</a>
<a name="ln2557">}</a>
<a name="ln2558"> </a>
<a name="ln2559"> </a>
<a name="ln2560">// #pragma mark - Listener</a>
<a name="ln2561"> </a>
<a name="ln2562"> </a>
<a name="ln2563">TeamDebugger::Listener::~Listener()</a>
<a name="ln2564">{</a>
<a name="ln2565">}</a>

</code></pre>
<div class="balloon" rel="153"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fNext.</p></div>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fTeamDebugInfo.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
