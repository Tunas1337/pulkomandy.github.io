
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>gcc3+.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2011, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;ctype.h&gt;</a>
<a name="ln7">#include &lt;stdarg.h&gt;</a>
<a name="ln8">#include &lt;stdio.h&gt;</a>
<a name="ln9">#include &lt;stdlib.h&gt;</a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;new&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;TypeConstants.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#ifdef _KERNEL_MODE</a>
<a name="ln17">#	include &lt;debug_heap.h&gt;</a>
<a name="ln18">#endif</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;demangle.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22"> </a>
<a name="ln23">// C++ ABI: http://www.codesourcery.com/public/cxx-abi/abi.html</a>
<a name="ln24"> </a>
<a name="ln25"> </a>
<a name="ln26">//#define TRACE_GCC3_DEMANGLER</a>
<a name="ln27">#ifdef TRACE_GCC3_DEMANGLER</a>
<a name="ln28">#	define TRACE(x...) PRINT(x)</a>
<a name="ln29">#	define DEBUG_SCOPE(name)	DebugScope debug(name, fInput.String())</a>
<a name="ln30">#else</a>
<a name="ln31">#	define TRACE(x...) ;</a>
<a name="ln32">#	define DEBUG_SCOPE(name)	do {} while (false)</a>
<a name="ln33">#endif</a>
<a name="ln34"> </a>
<a name="ln35">#ifdef _KERNEL_MODE</a>
<a name="ln36">#	define PRINT(format...)		kprintf(format)</a>
<a name="ln37">#	define VPRINT(format, args)	PRINT(&quot;%s&quot;, format)</a>
<a name="ln38">									// no vkprintf()</a>
<a name="ln39">#	define NEW(constructor) new(kdebug_alloc) constructor</a>
<a name="ln40">#	define DELETE(object)	DebugAlloc::destroy(object)</a>
<a name="ln41">#else</a>
<a name="ln42">#	define PRINT(format...)		printf(format)</a>
<a name="ln43">#	define VPRINT(format, args)	vprintf(format, args)</a>
<a name="ln44">#	define NEW(constructor) new(std::nothrow) constructor</a>
<a name="ln45">#	define DELETE(object)	delete object</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">typedef long number_type;</a>
<a name="ln50"> </a>
<a name="ln51">enum {</a>
<a name="ln52">	ERROR_OK = 0,</a>
<a name="ln53">	ERROR_NOT_MANGLED,</a>
<a name="ln54">	ERROR_UNSUPPORTED,</a>
<a name="ln55">	ERROR_INVALID,</a>
<a name="ln56">	ERROR_BUFFER_TOO_SMALL,</a>
<a name="ln57">	ERROR_NO_MEMORY,</a>
<a name="ln58">	ERROR_INTERNAL,</a>
<a name="ln59">	ERROR_INVALID_PARAMETER_INDEX</a>
<a name="ln60">};</a>
<a name="ln61"> </a>
<a name="ln62">// object classification</a>
<a name="ln63">enum object_type {</a>
<a name="ln64">	OBJECT_TYPE_UNKNOWN,</a>
<a name="ln65">	OBJECT_TYPE_DATA,</a>
<a name="ln66">	OBJECT_TYPE_FUNCTION,</a>
<a name="ln67">	OBJECT_TYPE_METHOD_CLASS,</a>
<a name="ln68">	OBJECT_TYPE_METHOD_OBJECT,</a>
<a name="ln69">	OBJECT_TYPE_METHOD_UNKNOWN</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72">// prefix classification</a>
<a name="ln73">enum prefix_type {</a>
<a name="ln74">	PREFIX_NONE,</a>
<a name="ln75">	PREFIX_NAMESPACE,</a>
<a name="ln76">	PREFIX_CLASS,</a>
<a name="ln77">	PREFIX_UNKNOWN</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80">// type classification</a>
<a name="ln81">enum type_type {</a>
<a name="ln82">	TYPE_ELLIPSIS,</a>
<a name="ln83">	TYPE_VOID,</a>
<a name="ln84">	TYPE_WCHAR_T,</a>
<a name="ln85">	TYPE_BOOL,</a>
<a name="ln86">	TYPE_CHAR,</a>
<a name="ln87">	TYPE_SIGNED_CHAR,</a>
<a name="ln88">	TYPE_UNSIGNED_CHAR,</a>
<a name="ln89">	TYPE_SHORT,</a>
<a name="ln90">	TYPE_UNSIGNED_SHORT,</a>
<a name="ln91">	TYPE_INT,</a>
<a name="ln92">	TYPE_UNSIGNED_INT,</a>
<a name="ln93">	TYPE_LONG,</a>
<a name="ln94">	TYPE_UNSIGNED_LONG,</a>
<a name="ln95">	TYPE_LONG_LONG,</a>
<a name="ln96">	TYPE_UNSIGNED_LONG_LONG,</a>
<a name="ln97">	TYPE_INT128,</a>
<a name="ln98">	TYPE_UNSIGNED_INT128,</a>
<a name="ln99">	TYPE_FLOAT,</a>
<a name="ln100">	TYPE_DOUBLE,</a>
<a name="ln101">	TYPE_LONG_DOUBLE,</a>
<a name="ln102">	TYPE_FLOAT128,</a>
<a name="ln103">	TYPE_DFLOAT16,</a>
<a name="ln104">	TYPE_DFLOAT32,</a>
<a name="ln105">	TYPE_DFLOAT64,</a>
<a name="ln106">	TYPE_DFLOAT128,</a>
<a name="ln107">	TYPE_CHAR16_T,</a>
<a name="ln108">	TYPE_CHAR32_T,</a>
<a name="ln109"> </a>
<a name="ln110">	TYPE_UNKNOWN,</a>
<a name="ln111">	TYPE_CONST_CHAR_POINTER,</a>
<a name="ln112">	TYPE_POINTER,</a>
<a name="ln113">	TYPE_REFERENCE</a>
<a name="ln114">};</a>
<a name="ln115"> </a>
<a name="ln116">const char* const kTypeNames[] = {</a>
<a name="ln117">	&quot;...&quot;,</a>
<a name="ln118">	&quot;void&quot;,</a>
<a name="ln119">	&quot;wchar_t&quot;,</a>
<a name="ln120">	&quot;bool&quot;,</a>
<a name="ln121">	&quot;char&quot;,</a>
<a name="ln122">	&quot;signed char&quot;,</a>
<a name="ln123">	&quot;unsigned char&quot;,</a>
<a name="ln124">	&quot;short&quot;,</a>
<a name="ln125">	&quot;unsigned short&quot;,</a>
<a name="ln126">	&quot;int&quot;,</a>
<a name="ln127">	&quot;unsigned int&quot;,</a>
<a name="ln128">	&quot;long&quot;,</a>
<a name="ln129">	&quot;unsigned long&quot;,</a>
<a name="ln130">	&quot;long long&quot;,</a>
<a name="ln131">	&quot;unsigned long long&quot;,</a>
<a name="ln132">	&quot;__int128&quot;,</a>
<a name="ln133">	&quot;unsigned __int128&quot;,</a>
<a name="ln134">	&quot;float&quot;,</a>
<a name="ln135">	&quot;double&quot;,</a>
<a name="ln136">	&quot;long double&quot;,</a>
<a name="ln137">	&quot;__float128&quot;,</a>
<a name="ln138">	&quot;__dfloat16&quot;,	// TODO: Official names for the __dfloat*!</a>
<a name="ln139">	&quot;__dfloat32&quot;,</a>
<a name="ln140">	&quot;__dfloat64&quot;,</a>
<a name="ln141">	&quot;__dfloat64&quot;,</a>
<a name="ln142">	&quot;char16_t&quot;,</a>
<a name="ln143">	&quot;char32_t&quot;,</a>
<a name="ln144"> </a>
<a name="ln145">	&quot;?&quot;,</a>
<a name="ln146">	&quot;char const*&quot;,</a>
<a name="ln147">	&quot;void*&quot;,</a>
<a name="ln148">	&quot;void&amp;&quot;</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">// CV qualifier flags</a>
<a name="ln153">enum {</a>
<a name="ln154">	CV_QUALIFIER_RESTRICT	= 0x1,</a>
<a name="ln155">	CV_QUALIFIER_VOLATILE	= 0x2,</a>
<a name="ln156">	CV_QUALIFIER_CONST		= 0x4</a>
<a name="ln157">};</a>
<a name="ln158"> </a>
<a name="ln159">enum type_modifier {</a>
<a name="ln160">	TYPE_QUALIFIER_POINTER = 0,</a>
<a name="ln161">	TYPE_QUALIFIER_REFERENCE,</a>
<a name="ln162">	TYPE_QUALIFIER_RVALUE_REFERENCE,</a>
<a name="ln163">	TYPE_QUALIFIER_COMPLEX,</a>
<a name="ln164">	TYPE_QUALIFIER_IMAGINARY</a>
<a name="ln165">};</a>
<a name="ln166"> </a>
<a name="ln167">static const char* const kTypeModifierSuffixes[] = {</a>
<a name="ln168">	&quot;*&quot;,</a>
<a name="ln169">	&quot;&amp;&quot;,</a>
<a name="ln170">	&quot;&amp;&amp;&quot;,</a>
<a name="ln171">	&quot; complex&quot;,</a>
<a name="ln172">	&quot; imaginary&quot;</a>
<a name="ln173">};</a>
<a name="ln174"> </a>
<a name="ln175">struct operator_info {</a>
<a name="ln176">	const char*	mangled_name;</a>
<a name="ln177">	const char*	name;</a>
<a name="ln178">	int			argument_count;</a>
<a name="ln179">	int			flags;</a>
<a name="ln180">};</a>
<a name="ln181"> </a>
<a name="ln182">// operator flags</a>
<a name="ln183">enum {</a>
<a name="ln184">	OPERATOR_TYPE_PARAM		= 0x01,</a>
<a name="ln185">	OPERATOR_IS_MEMBER		= 0x02</a>
<a name="ln186">};</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">static const operator_info kOperatorInfos[] = {</a>
<a name="ln190">	{ &quot;nw&quot;, &quot;new&quot;, -1, OPERATOR_IS_MEMBER },</a>
<a name="ln191">	{ &quot;na&quot;, &quot;new[]&quot;, -1, OPERATOR_IS_MEMBER },</a>
<a name="ln192">	{ &quot;dl&quot;, &quot;delete&quot;, -1, OPERATOR_IS_MEMBER },</a>
<a name="ln193">	{ &quot;da&quot;, &quot;delete[]&quot;, -1, OPERATOR_IS_MEMBER },</a>
<a name="ln194">	{ &quot;ps&quot;, &quot;+&quot;, 1, 0 },		// unary</a>
<a name="ln195">	{ &quot;ng&quot;, &quot;-&quot;, 1, 0 },		// unary</a>
<a name="ln196">	{ &quot;ad&quot;, &quot;&amp;&quot;, 1, 0 },		// unary</a>
<a name="ln197">	{ &quot;de&quot;, &quot;*&quot;, 1, 0 },		// unary</a>
<a name="ln198">	{ &quot;co&quot;, &quot;~&quot;, 1, 0 },</a>
<a name="ln199">	{ &quot;pl&quot;, &quot;+&quot;, 2, 0 },</a>
<a name="ln200">	{ &quot;mi&quot;, &quot;-&quot;, 2, 0 },</a>
<a name="ln201">	{ &quot;ml&quot;, &quot;*&quot;, 2, 0 },</a>
<a name="ln202">	{ &quot;dv&quot;, &quot;/&quot;, 2, 0 },</a>
<a name="ln203">	{ &quot;rm&quot;, &quot;%&quot;, 2, 0 },</a>
<a name="ln204">	{ &quot;an&quot;, &quot;&amp;&quot;, 2, 0 },</a>
<a name="ln205">	{ &quot;or&quot;, &quot;|&quot;, 2, 0 },</a>
<a name="ln206">	{ &quot;eo&quot;, &quot;^&quot;, 2, 0 },</a>
<a name="ln207">	{ &quot;aS&quot;, &quot;=&quot;, 2, 0 },</a>
<a name="ln208">	{ &quot;pL&quot;, &quot;+=&quot;, 2, 0 },</a>
<a name="ln209">	{ &quot;mI&quot;, &quot;-=&quot;, 2, 0 },</a>
<a name="ln210">	{ &quot;mL&quot;, &quot;*=&quot;, 2, 0 },</a>
<a name="ln211">	{ &quot;dV&quot;, &quot;/=&quot;, 2, 0 },</a>
<a name="ln212">	{ &quot;rM&quot;, &quot;%=&quot;, 2, 0 },</a>
<a name="ln213">	{ &quot;aN&quot;, &quot;&amp;=&quot;, 2, 0 },</a>
<a name="ln214">	{ &quot;oR&quot;, &quot;|=&quot;, 2, 0 },</a>
<a name="ln215">	{ &quot;eO&quot;, &quot;^=&quot;, 2, 0 },</a>
<a name="ln216">	{ &quot;ls&quot;, &quot;&lt;&lt;&quot;, 2, 0 },</a>
<a name="ln217">	{ &quot;rs&quot;, &quot;&gt;&gt;&quot;, 2, 0 },</a>
<a name="ln218">	{ &quot;lS&quot;, &quot;&lt;&lt;=&quot;, 2, 0 },</a>
<a name="ln219">	{ &quot;rS&quot;, &quot;&gt;&gt;=&quot;, 2, 0 },</a>
<a name="ln220">	{ &quot;eq&quot;, &quot;==&quot;, 2, 0 },</a>
<a name="ln221">	{ &quot;ne&quot;, &quot;!=&quot;, 2, 0 },</a>
<a name="ln222">	{ &quot;lt&quot;, &quot;&lt;&quot;, 2, 0 },</a>
<a name="ln223">	{ &quot;gt&quot;, &quot;&gt;&quot;, 2, 0 },</a>
<a name="ln224">	{ &quot;le&quot;, &quot;&lt;=&quot;, 2, 0 },</a>
<a name="ln225">	{ &quot;ge&quot;, &quot;&gt;=&quot;, 2, 0 },</a>
<a name="ln226">	{ &quot;nt&quot;, &quot;!&quot;, 1, 0 },</a>
<a name="ln227">	{ &quot;aa&quot;, &quot;&amp;&amp;&quot;, 2, 0 },</a>
<a name="ln228">	{ &quot;oo&quot;, &quot;||&quot;, 2, 0 },</a>
<a name="ln229">	{ &quot;pp&quot;, &quot;++&quot;, 1, 0 },</a>
<a name="ln230">	{ &quot;mm&quot;, &quot;--&quot;, 1, 0 },</a>
<a name="ln231">	{ &quot;cm&quot;, &quot;,&quot;, -1, 0 },</a>
<a name="ln232">	{ &quot;pm&quot;, &quot;-&gt;*&quot;, 2, 0 },</a>
<a name="ln233">	{ &quot;pt&quot;, &quot;-&gt;&quot;, 2, 0 },</a>
<a name="ln234">	{ &quot;cl&quot;, &quot;()&quot;, -1, 0 },</a>
<a name="ln235">	{ &quot;ix&quot;, &quot;[]&quot;, -1, 0 },</a>
<a name="ln236">	{ &quot;qu&quot;, &quot;?&quot;, 3, 0 },</a>
<a name="ln237">	{ &quot;st&quot;, &quot;sizeof&quot;, 1, OPERATOR_TYPE_PARAM },		// type</a>
<a name="ln238">	{ &quot;sz&quot;, &quot;sizeof&quot;, 1, 0 },						// expression</a>
<a name="ln239">	{ &quot;at&quot;, &quot;alignof&quot;, 1, OPERATOR_TYPE_PARAM },	// type</a>
<a name="ln240">	{ &quot;az&quot;, &quot;alignof&quot;, 1, 0 },						// expression</a>
<a name="ln241">	{}</a>
<a name="ln242">};</a>
<a name="ln243"> </a>
<a name="ln244"> </a>
<a name="ln245">#ifdef TRACE_GCC3_DEMANGLER</a>
<a name="ln246"> </a>
<a name="ln247">struct DebugScope {</a>
<a name="ln248">	DebugScope(const char* functionName, const char* remainingString = NULL)</a>
<a name="ln249">		:</a>
<a name="ln250">		fParent(sGlobalScope),</a>
<a name="ln251">		fFunctionName(functionName),</a>
<a name="ln252">		fLevel(fParent != NULL ? fParent-&gt;fLevel + 1 : 0)</a>
<a name="ln253">	{</a>
<a name="ln254">		sGlobalScope = this;</a>
<a name="ln255">		if (remainingString != NULL) {</a>
<a name="ln256">			PRINT(&quot;%*s%s(): \&quot;%s\&quot;\n&quot;, fLevel * 2, &quot;&quot;, fFunctionName,</a>
<a name="ln257">				remainingString);</a>
<a name="ln258">		} else</a>
<a name="ln259">			PRINT(&quot;%*s%s()\n&quot;, fLevel * 2, &quot;&quot;, fFunctionName);</a>
<a name="ln260">	}</a>
<a name="ln261"> </a>
<a name="ln262">	~DebugScope()</a>
<a name="ln263">	{</a>
<a name="ln264">		sGlobalScope = fParent;</a>
<a name="ln265">		PRINT(&quot;%*s%s() done\n&quot;, fLevel * 2, &quot;&quot;, fFunctionName);</a>
<a name="ln266">	}</a>
<a name="ln267"> </a>
<a name="ln268">	static void Print(const char* format,...)</a>
<a name="ln269">	{</a>
<a name="ln270">		int level = sGlobalScope != NULL ? sGlobalScope-&gt;fLevel : 0;</a>
<a name="ln271"> </a>
<a name="ln272">		va_list args;</a>
<a name="ln273">		va_start(args, format);</a>
<a name="ln274">		PRINT(&quot;%*s&quot;, (level + 1) * 2, &quot;&quot;);</a>
<a name="ln275">		VPRINT(format, args);</a>
<a name="ln276">		va_end(args);</a>
<a name="ln277">	}</a>
<a name="ln278"> </a>
<a name="ln279">private:</a>
<a name="ln280">	DebugScope*	fParent;</a>
<a name="ln281">	const char*	fFunctionName;</a>
<a name="ln282">	int			fLevel;</a>
<a name="ln283"> </a>
<a name="ln284">	static DebugScope* sGlobalScope;</a>
<a name="ln285">};</a>
<a name="ln286"> </a>
<a name="ln287">DebugScope* DebugScope::sGlobalScope = NULL;</a>
<a name="ln288"> </a>
<a name="ln289">#endif	// TRACE_GCC3_DEMANGLER</a>
<a name="ln290"> </a>
<a name="ln291"> </a>
<a name="ln292">class Input {</a>
<a name="ln293">public:</a>
<a name="ln294">	Input()</a>
<a name="ln295">		:</a>
<a name="ln296">		fString(NULL),</a>
<a name="ln297">		fLength(0)</a>
<a name="ln298">	{</a>
<a name="ln299">	}</a>
<a name="ln300"> </a>
<a name="ln301">	void SetTo(const char* string, size_t length)</a>
<a name="ln302">	{</a>
<a name="ln303">		fString = string;</a>
<a name="ln304">		fLength = length;</a>
<a name="ln305">	}</a>
<a name="ln306"> </a>
<a name="ln307">	const char* String() const</a>
<a name="ln308">	{</a>
<a name="ln309">		return fString;</a>
<a name="ln310">	}</a>
<a name="ln311"> </a>
<a name="ln312">	int CharsRemaining() const</a>
<a name="ln313">	{</a>
<a name="ln314">		return fLength;</a>
<a name="ln315">	}</a>
<a name="ln316"> </a>
<a name="ln317">	void Skip(size_t count)</a>
<a name="ln318">	{</a>
<a name="ln319">		if (count &gt; fLength) {</a>
<a name="ln320">			PRINT(&quot;Input::Skip(): fOffset &gt; fLength\n&quot;);</a>
<a name="ln321">			return;</a>
<a name="ln322">		}</a>
<a name="ln323"> </a>
<a name="ln324">		fString += count;</a>
<a name="ln325">		fLength -= count;</a>
<a name="ln326">	}</a>
<a name="ln327"> </a>
<a name="ln328">	bool HasPrefix(char prefix) const</a>
<a name="ln329">	{</a>
<a name="ln330">		return fLength &gt; 0 &amp;&amp; fString[0] == prefix;</a>
<a name="ln331">	}</a>
<a name="ln332"> </a>
<a name="ln333">	bool HasPrefix(const char* prefix) const</a>
<a name="ln334">	{</a>
<a name="ln335">		size_t prefixLen = strlen(prefix);</a>
<a name="ln336">		return prefixLen &lt;= fLength</a>
<a name="ln337">			&amp;&amp; strncmp(fString, prefix, strlen(prefix)) == 0;</a>
<a name="ln338">	}</a>
<a name="ln339"> </a>
<a name="ln340">	bool SkipPrefix(char prefix)</a>
<a name="ln341">	{</a>
<a name="ln342">		if (!HasPrefix(prefix))</a>
<a name="ln343">			return false;</a>
<a name="ln344"> </a>
<a name="ln345">		fString++;</a>
<a name="ln346">		fLength--;</a>
<a name="ln347">		return true;</a>
<a name="ln348">	}</a>
<a name="ln349"> </a>
<a name="ln350">	bool SkipPrefix(const char* prefix)</a>
<a name="ln351">	{</a>
<a name="ln352">		size_t prefixLen = strlen(prefix);</a>
<a name="ln353">		if (prefixLen &lt;= fLength &amp;&amp; strncmp(fString, prefix, prefixLen) != 0)</a>
<a name="ln354">			return false;</a>
<a name="ln355"> </a>
<a name="ln356">		fString += prefixLen;</a>
<a name="ln357">		fLength -= prefixLen;</a>
<a name="ln358">		return true;</a>
<a name="ln359">	}</a>
<a name="ln360"> </a>
<a name="ln361">	char operator[](size_t index) const</a>
<a name="ln362">	{</a>
<a name="ln363">		if (index &gt;= fLength) {</a>
<a name="ln364">			PRINT(&quot;Input::operator[](): fOffset + index &gt;= fLength\n&quot;);</a>
<a name="ln365">			return '\0';</a>
<a name="ln366">		}</a>
<a name="ln367"> </a>
<a name="ln368">		return fString[index];</a>
<a name="ln369">	}</a>
<a name="ln370"> </a>
<a name="ln371">private:</a>
<a name="ln372">	const char*	fString;</a>
<a name="ln373">	size_t		fLength;</a>
<a name="ln374">};</a>
<a name="ln375"> </a>
<a name="ln376"> </a>
<a name="ln377">class NameBuffer {</a>
<a name="ln378">public:</a>
<a name="ln379">	NameBuffer(char* buffer, size_t size)</a>
<a name="ln380">		:</a>
<a name="ln381">		fBuffer(buffer),</a>
<a name="ln382">		fSize(size),</a>
<a name="ln383">		fLength(0),</a>
<a name="ln384">		fOverflow(false)</a>
<a name="ln385">	{</a>
<a name="ln386">	}</a>
<a name="ln387"> </a>
<a name="ln388">	bool IsEmpty() const</a>
<a name="ln389">	{</a>
<a name="ln390">		return fLength == 0;</a>
<a name="ln391">	}</a>
<a name="ln392"> </a>
<a name="ln393">	char LastChar() const</a>
<a name="ln394">	{</a>
<a name="ln395">		return fLength &gt; 0 ? fBuffer[fLength - 1] : '\0';</a>
<a name="ln396">	}</a>
<a name="ln397"> </a>
<a name="ln398">	bool HadOverflow() const</a>
<a name="ln399">	{</a>
<a name="ln400">		return fOverflow;</a>
<a name="ln401">	}</a>
<a name="ln402"> </a>
<a name="ln403">	char* Terminate()</a>
<a name="ln404">	{</a>
<a name="ln405">		fBuffer[fLength] = '\0';</a>
<a name="ln406">		return fBuffer;</a>
<a name="ln407">	}</a>
<a name="ln408"> </a>
<a name="ln409">	bool Append(const char* string, size_t length)</a>
<a name="ln410">	{</a>
<a name="ln411">		if (fLength + length &gt;= fSize) {</a>
<a name="ln412">			fOverflow = true;</a>
<a name="ln413">			return false;</a>
<a name="ln414">		}</a>
<a name="ln415"> </a>
<a name="ln416">		memcpy(fBuffer + fLength, string, length);</a>
<a name="ln417">		fLength += length;</a>
<a name="ln418">		return true;</a>
<a name="ln419">	}</a>
<a name="ln420"> </a>
<a name="ln421">	bool Append(const char* string)</a>
<a name="ln422">	{</a>
<a name="ln423">		return Append(string, strlen(string));</a>
<a name="ln424">	}</a>
<a name="ln425"> </a>
<a name="ln426">private:</a>
<a name="ln427">	char*	fBuffer;</a>
<a name="ln428">	size_t	fSize;</a>
<a name="ln429">	size_t	fLength;</a>
<a name="ln430">	bool	fOverflow;</a>
<a name="ln431">};</a>
<a name="ln432"> </a>
<a name="ln433"> </a>
<a name="ln434">struct TypeInfo {</a>
<a name="ln435">	type_type	type;</a>
<a name="ln436">	int			cvQualifiers;</a>
<a name="ln437"> </a>
<a name="ln438">	TypeInfo()</a>
<a name="ln439">		:</a>
<a name="ln440">		type(TYPE_UNKNOWN),</a>
<a name="ln441">		cvQualifiers(0)</a>
<a name="ln442">	{</a>
<a name="ln443">	}</a>
<a name="ln444"> </a>
<a name="ln445">	TypeInfo(type_type type)</a>
<a name="ln446">		:</a>
<a name="ln447">		type(type),</a>
<a name="ln448">		cvQualifiers(0)</a>
<a name="ln449">	{</a>
<a name="ln450">	}</a>
<a name="ln451"> </a>
<a name="ln452">	TypeInfo(const TypeInfo&amp; other, int cvQualifiers = 0)</a>
<a name="ln453">		:</a>
<a name="ln454">		type(other.type),</a>
<a name="ln455">		cvQualifiers(other.cvQualifiers | cvQualifiers)</a>
<a name="ln456">	{</a>
<a name="ln457">	}</a>
<a name="ln458"> </a>
<a name="ln459">	TypeInfo&amp; operator=(const TypeInfo&amp; other)</a>
<a name="ln460">	{</a>
<a name="ln461">		type = other.type;</a>
<a name="ln462">		cvQualifiers = other.cvQualifiers;</a>
<a name="ln463">		return *this;</a>
<a name="ln464">	}</a>
<a name="ln465">};</a>
<a name="ln466"> </a>
<a name="ln467"> </a>
<a name="ln468">struct DemanglingParameters {</a>
<a name="ln469">	bool	objectNameOnly;</a>
<a name="ln470"> </a>
<a name="ln471">	DemanglingParameters(bool objectNameOnly)</a>
<a name="ln472">		:</a>
<a name="ln473">		objectNameOnly(objectNameOnly)</a>
<a name="ln474">	{</a>
<a name="ln475">	}</a>
<a name="ln476">};</a>
<a name="ln477"> </a>
<a name="ln478"> </a>
<a name="ln479">struct DemanglingInfo : DemanglingParameters {</a>
<a name="ln480">	object_type	objectType;</a>
<a name="ln481"> </a>
<a name="ln482">	DemanglingInfo(bool objectNameOnly)</a>
<a name="ln483">		:</a>
<a name="ln484">		DemanglingParameters(objectNameOnly),</a>
<a name="ln485">		objectType(OBJECT_TYPE_UNKNOWN)</a>
<a name="ln486">	{</a>
<a name="ln487">	}</a>
<a name="ln488">};</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">struct ParameterInfo {</a>
<a name="ln492">	TypeInfo	type;</a>
<a name="ln493"> </a>
<a name="ln494">	ParameterInfo()</a>
<a name="ln495">	{</a>
<a name="ln496">	}</a>
<a name="ln497">};</a>
<a name="ln498"> </a>
<a name="ln499"> </a>
<a name="ln500">class Node;</a>
<a name="ln501"> </a>
<a name="ln502">struct NameDecorationInfo {</a>
<a name="ln503">	const Node*	firstDecorator;</a>
<a name="ln504">	const Node*	closestCVDecoratorList;</a>
<a name="ln505"> </a>
<a name="ln506">	NameDecorationInfo(const Node* decorator)</a>
<a name="ln507">		:</a>
<a name="ln508">		firstDecorator(decorator),</a>
<a name="ln509">		closestCVDecoratorList(NULL)</a>
<a name="ln510">	{</a>
<a name="ln511">	}</a>
<a name="ln512">};</a>
<a name="ln513"> </a>
<a name="ln514">struct CVQualifierInfo {</a>
<a name="ln515">	const Node*	firstCVQualifier;</a>
<a name="ln516">	const Node*	firstNonCVQualifier;</a>
<a name="ln517"> </a>
<a name="ln518">	CVQualifierInfo()</a>
<a name="ln519">		:</a>
<a name="ln520">		firstCVQualifier(NULL),</a>
<a name="ln521">		firstNonCVQualifier(NULL)</a>
<a name="ln522">	{</a>
<a name="ln523">	}</a>
<a name="ln524">};</a>
<a name="ln525"> </a>
<a name="ln526"> </a>
<a name="ln527">class Node {</a>
<a name="ln528">public:</a>
<a name="ln529">	Node()</a>
<a name="ln530">		:</a>
<a name="ln531">		fNextAllocated(NULL),</a>
<a name="ln532">		fParent(NULL),</a>
<a name="ln533">		fNext(NULL),</a>
<a name="ln534">		fNextReferenceable(NULL),</a>
<a name="ln535">		fReferenceable(true)</a>
<a name="ln536">	{</a>
<a name="ln537">	}</a>
<a name="ln538"> </a>
<a name="ln539">	virtual ~Node()</a>
<a name="ln540">	{</a>
<a name="ln541">	}</a>
<a name="ln542"> </a>
<a name="ln543">	Node* NextAllocated() const			{ return fNextAllocated; }</a>
<a name="ln544">	void SetNextAllocated(Node* node)	{ fNextAllocated = node; }</a>
<a name="ln545"> </a>
<a name="ln546">	Node* Parent() const				{ return fParent; }</a>
<a name="ln547">	virtual void SetParent(Node* node)	{ fParent = node; }</a>
<a name="ln548"> </a>
<a name="ln549">	Node* Next() const			{ return fNext; }</a>
<a name="ln550">	void SetNext(Node* node)	{ fNext = node; }</a>
<a name="ln551"> </a>
<a name="ln552">	bool IsReferenceable() const		{ return fReferenceable; }</a>
<a name="ln553">	void SetReferenceable(bool flag)	{ fReferenceable = flag; }</a>
<a name="ln554"> </a>
<a name="ln555">	Node* NextReferenceable() const			{ return fNextReferenceable; }</a>
<a name="ln556">	void SetNextReferenceable(Node* node)	{ fNextReferenceable = node; }</a>
<a name="ln557"> </a>
<a name="ln558">	virtual bool GetName(NameBuffer&amp; buffer) const = 0;</a>
<a name="ln559"> </a>
<a name="ln560">	virtual bool GetDecoratedName(NameBuffer&amp; buffer,</a>
<a name="ln561">		NameDecorationInfo&amp; decorationInfo) const</a>
<a name="ln562">	{</a>
<a name="ln563">		if (!GetName(buffer))</a>
<a name="ln564">			return false;</a>
<a name="ln565"> </a>
<a name="ln566">		return decorationInfo.firstDecorator == NULL</a>
<a name="ln567">			|| decorationInfo.firstDecorator-&gt;AddDecoration(buffer, NULL);</a>
<a name="ln568">	}</a>
<a name="ln569"> </a>
<a name="ln570">	virtual bool AddDecoration(NameBuffer&amp; buffer,</a>
<a name="ln571">		const Node* stopDecorator) const</a>
<a name="ln572">	{</a>
<a name="ln573">		return true;</a>
<a name="ln574">	}</a>
<a name="ln575"> </a>
<a name="ln576">	virtual void GetCVQualifierInfo(CVQualifierInfo&amp; info) const</a>
<a name="ln577">	{</a>
<a name="ln578">		info.firstNonCVQualifier = this;</a>
<a name="ln579">	}</a>
<a name="ln580"> </a>
<a name="ln581">	virtual Node* GetUnqualifiedNode(Node* beforeNode)</a>
<a name="ln582">	{</a>
<a name="ln583">		return this;</a>
<a name="ln584">	}</a>
<a name="ln585"> </a>
<a name="ln586">	virtual bool IsTemplatized() const</a>
<a name="ln587">	{</a>
<a name="ln588">		return false;</a>
<a name="ln589">	}</a>
<a name="ln590"> </a>
<a name="ln591">	virtual Node* TemplateParameterAt(int index) const</a>
<a name="ln592">	{</a>
<a name="ln593">		return NULL;</a>
<a name="ln594">	}</a>
<a name="ln595"> </a>
<a name="ln596">	virtual bool IsNoReturnValueFunction() const</a>
<a name="ln597">	{</a>
<a name="ln598">		return false;</a>
<a name="ln599">	}</a>
<a name="ln600"> </a>
<a name="ln601">	virtual bool IsTypeName(const char* name, size_t length) const</a>
<a name="ln602">	{</a>
<a name="ln603">		return false;</a>
<a name="ln604">	}</a>
<a name="ln605"> </a>
<a name="ln606">	virtual object_type ObjectType() const</a>
<a name="ln607">	{</a>
<a name="ln608">		return OBJECT_TYPE_UNKNOWN;</a>
<a name="ln609">	}</a>
<a name="ln610"> </a>
<a name="ln611">	virtual prefix_type PrefixType() const</a>
<a name="ln612">	{</a>
<a name="ln613">		return PREFIX_NONE;</a>
<a name="ln614">	}</a>
<a name="ln615"> </a>
<a name="ln616">	virtual TypeInfo Type() const</a>
<a name="ln617">	{</a>
<a name="ln618">		return TypeInfo();</a>
<a name="ln619">	}</a>
<a name="ln620"> </a>
<a name="ln621">private:</a>
<a name="ln622">	Node*	fNextAllocated;</a>
<a name="ln623">	Node*	fParent;</a>
<a name="ln624">	Node*	fNext;</a>
<a name="ln625">	Node*	fNextReferenceable;</a>
<a name="ln626">	bool	fReferenceable;</a>
<a name="ln627">};</a>
<a name="ln628"> </a>
<a name="ln629"> </a>
<a name="ln630">class NamedTypeNode : public Node {</a>
<a name="ln631">public:</a>
<a name="ln632">	NamedTypeNode(Node* name)</a>
<a name="ln633">		:</a>
<a name="ln634">		fName(name)</a>
<a name="ln635">	{</a>
<a name="ln636">		if (fName != NULL)</a>
<a name="ln637">			fName-&gt;SetParent(this);</a>
<a name="ln638">	}</a>
<a name="ln639"> </a>
<a name="ln640">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln641">	{</a>
<a name="ln642">		return fName == NULL || fName-&gt;GetName(buffer);</a>
<a name="ln643">	}</a>
<a name="ln644"> </a>
<a name="ln645">	virtual bool IsNoReturnValueFunction() const</a>
<a name="ln646">	{</a>
<a name="ln647">		return fName != NULL &amp;&amp; fName-&gt;IsNoReturnValueFunction();</a>
<a name="ln648">	}</a>
<a name="ln649"> </a>
<a name="ln650">	virtual TypeInfo Type() const</a>
<a name="ln651">	{</a>
<a name="ln652">		return fName != NULL ? fName-&gt;Type() : TypeInfo();</a>
<a name="ln653">	}</a>
<a name="ln654"> </a>
<a name="ln655">protected:</a>
<a name="ln656">	Node*	fName;</a>
<a name="ln657">};</a>
<a name="ln658"> </a>
<a name="ln659"> </a>
<a name="ln660">class SubstitutionNode : public Node {</a>
<a name="ln661">public:</a>
<a name="ln662">	SubstitutionNode(Node* node)</a>
<a name="ln663">		:</a>
<a name="ln664">		fNode(node)</a>
<a name="ln665">	{</a>
<a name="ln666">	}</a>
<a name="ln667"> </a>
<a name="ln668">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln669">	{</a>
<a name="ln670">		return fNode-&gt;GetName(buffer);</a>
<a name="ln671">	}</a>
<a name="ln672"> </a>
<a name="ln673">	virtual bool GetDecoratedName(NameBuffer&amp; buffer,</a>
<a name="ln674">		NameDecorationInfo&amp; decorationInfo) const</a>
<a name="ln675">	{</a>
<a name="ln676">		return fNode-&gt;GetDecoratedName(buffer, decorationInfo);</a>
<a name="ln677">	}</a>
<a name="ln678"> </a>
<a name="ln679">	virtual bool AddDecoration(NameBuffer&amp; buffer,</a>
<a name="ln680">		const Node* stopDecorator) const</a>
<a name="ln681">	{</a>
<a name="ln682">		return fNode-&gt;AddDecoration(buffer, stopDecorator);</a>
<a name="ln683">	}</a>
<a name="ln684"> </a>
<a name="ln685">	virtual void GetCVQualifierInfo(CVQualifierInfo&amp; info) const</a>
<a name="ln686">	{</a>
<a name="ln687">		fNode-&gt;GetCVQualifierInfo(info);</a>
<a name="ln688">	}</a>
<a name="ln689"> </a>
<a name="ln690">	virtual bool IsTemplatized() const</a>
<a name="ln691">	{</a>
<a name="ln692">		return fNode-&gt;IsTemplatized();</a>
<a name="ln693">	}</a>
<a name="ln694"> </a>
<a name="ln695">	virtual Node* TemplateParameterAt(int index) const</a>
<a name="ln696">	{</a>
<a name="ln697">		return fNode-&gt;TemplateParameterAt(index);</a>
<a name="ln698">	}</a>
<a name="ln699"> </a>
<a name="ln700">	virtual bool IsNoReturnValueFunction() const</a>
<a name="ln701">	{</a>
<a name="ln702">		return fNode-&gt;IsNoReturnValueFunction();</a>
<a name="ln703">	}</a>
<a name="ln704"> </a>
<a name="ln705">	virtual bool IsTypeName(const char* name, size_t length) const</a>
<a name="ln706">	{</a>
<a name="ln707">		return fNode-&gt;IsTypeName(name, length);</a>
<a name="ln708">	}</a>
<a name="ln709"> </a>
<a name="ln710">	virtual object_type ObjectType() const</a>
<a name="ln711">	{</a>
<a name="ln712">		return fNode-&gt;ObjectType();</a>
<a name="ln713">	}</a>
<a name="ln714"> </a>
<a name="ln715">	virtual prefix_type PrefixType() const</a>
<a name="ln716">	{</a>
<a name="ln717">		return fNode-&gt;PrefixType();</a>
<a name="ln718">	}</a>
<a name="ln719"> </a>
<a name="ln720">	virtual TypeInfo Type() const</a>
<a name="ln721">	{</a>
<a name="ln722">		return fNode-&gt;Type();</a>
<a name="ln723">	}</a>
<a name="ln724"> </a>
<a name="ln725">private:</a>
<a name="ln726">	Node*	fNode;</a>
<a name="ln727">};</a>
<a name="ln728"> </a>
<a name="ln729"> </a>
<a name="ln730">class ArrayNode : public NamedTypeNode {</a>
<a name="ln731">public:</a>
<a name="ln732">	ArrayNode(Node* type, int dimension)</a>
<a name="ln733">		:</a>
<a name="ln734">		NamedTypeNode(type),</a>
<a name="ln735">		fDimensionExpression(NULL),</a>
<a name="ln736">		fDimensionNumber(dimension)</a>
<a name="ln737">	{</a>
<a name="ln738">	}</a>
<a name="ln739"> </a>
<a name="ln740">	ArrayNode(Node* type, Node* dimension)</a>
<a name="ln741">		:</a>
<a name="ln742">		NamedTypeNode(type),</a>
<a name="ln743">		fDimensionExpression(dimension),</a>
<a name="ln744">		fDimensionNumber(0)</a>
<a name="ln745">	{</a>
<a name="ln746">		fDimensionExpression-&gt;SetParent(this);</a>
<a name="ln747">	}</a>
<a name="ln748"> </a>
<a name="ln749">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln750">	{</a>
<a name="ln751">		if (!fName-&gt;GetName(buffer))</a>
<a name="ln752">			return false;</a>
<a name="ln753"> </a>
<a name="ln754">		buffer.Append(&quot;[&quot;, 1);</a>
<a name="ln755"> </a>
<a name="ln756">		if (fDimensionExpression != NULL) {</a>
<a name="ln757">			if (!fDimensionExpression-&gt;GetName(buffer))</a>
<a name="ln758">				return false;</a>
<a name="ln759">		} else {</a>
<a name="ln760">			char stringBuffer[16];</a>
<a name="ln761">			snprintf(stringBuffer, sizeof(stringBuffer), &quot;%d&quot;,</a>
<a name="ln762">				fDimensionNumber);</a>
<a name="ln763">			buffer.Append(stringBuffer);</a>
<a name="ln764">		}</a>
<a name="ln765"> </a>
<a name="ln766">		return buffer.Append(&quot;]&quot;, 1);</a>
<a name="ln767">	}</a>
<a name="ln768"> </a>
<a name="ln769">	virtual object_type ObjectType() const</a>
<a name="ln770">	{</a>
<a name="ln771">		return OBJECT_TYPE_DATA;</a>
<a name="ln772">	}</a>
<a name="ln773"> </a>
<a name="ln774">	virtual TypeInfo Type() const</a>
<a name="ln775">	{</a>
<a name="ln776">// TODO: Check!</a>
<a name="ln777">		return TypeInfo(TYPE_POINTER);</a>
<a name="ln778">	}</a>
<a name="ln779"> </a>
<a name="ln780"> </a>
<a name="ln781">private:</a>
<a name="ln782">	Node*	fDimensionExpression;</a>
<a name="ln783">	int		fDimensionNumber;</a>
<a name="ln784">};</a>
<a name="ln785"> </a>
<a name="ln786"> </a>
<a name="ln787">class ObjectNode : public NamedTypeNode {</a>
<a name="ln788">public:</a>
<a name="ln789">	ObjectNode(Node* name)</a>
<a name="ln790">		:</a>
<a name="ln791">		NamedTypeNode(name)</a>
<a name="ln792">	{</a>
<a name="ln793">	}</a>
<a name="ln794"> </a>
<a name="ln795">	virtual bool GetObjectName(NameBuffer&amp; buffer,</a>
<a name="ln796">		const DemanglingParameters&amp; parameters)</a>
<a name="ln797">	{</a>
<a name="ln798">		if (parameters.objectNameOnly)</a>
<a name="ln799">			return fName != NULL ? fName-&gt;GetName(buffer) : true;</a>
<a name="ln800"> </a>
<a name="ln801">		return GetName(buffer);</a>
<a name="ln802">	}</a>
<a name="ln803"> </a>
<a name="ln804">	virtual object_type ObjectType() const</a>
<a name="ln805">	{</a>
<a name="ln806">		return OBJECT_TYPE_DATA;</a>
<a name="ln807">	}</a>
<a name="ln808"> </a>
<a name="ln809">	virtual Node* ParameterAt(uint32 index) const</a>
<a name="ln810">	{</a>
<a name="ln811">		return NULL;</a>
<a name="ln812">	}</a>
<a name="ln813">};</a>
<a name="ln814"> </a>
<a name="ln815"> </a>
<a name="ln816">class SimpleNameNode : public Node {</a>
<a name="ln817">public:</a>
<a name="ln818">	SimpleNameNode(const char* name)</a>
<a name="ln819">		:</a>
<a name="ln820">		fName(name),</a>
<a name="ln821">		fLength(strlen(name))</a>
<a name="ln822">	{</a>
<a name="ln823">	}</a>
<a name="ln824"> </a>
<a name="ln825">	SimpleNameNode(const char* name, size_t length)</a>
<a name="ln826">		:</a>
<a name="ln827">		fName(name),</a>
<a name="ln828">		fLength(length)</a>
<a name="ln829">	{</a>
<a name="ln830">	}</a>
<a name="ln831"> </a>
<a name="ln832">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln833">	{</a>
<a name="ln834">		return buffer.Append(fName, fLength);</a>
<a name="ln835">	}</a>
<a name="ln836"> </a>
<a name="ln837">protected:</a>
<a name="ln838">	const char*	fName;</a>
<a name="ln839">	size_t		fLength;</a>
<a name="ln840">};</a>
<a name="ln841"> </a>
<a name="ln842"> </a>
<a name="ln843">class SimpleTypeNode : public SimpleNameNode {</a>
<a name="ln844">public:</a>
<a name="ln845">	SimpleTypeNode(const char* name)</a>
<a name="ln846">		:</a>
<a name="ln847">		SimpleNameNode(name),</a>
<a name="ln848">		fType(TYPE_UNKNOWN)</a>
<a name="ln849">	{</a>
<a name="ln850">	}</a>
<a name="ln851"> </a>
<a name="ln852">	SimpleTypeNode(type_type type)</a>
<a name="ln853">		:</a>
<a name="ln854">		SimpleNameNode(kTypeNames[type]),</a>
<a name="ln855">		fType(type)</a>
<a name="ln856">	{</a>
<a name="ln857">	}</a>
<a name="ln858"> </a>
<a name="ln859">	virtual bool IsTypeName(const char* name, size_t length) const</a>
<a name="ln860">	{</a>
<a name="ln861">		return fLength == length &amp;&amp; strcmp(fName, name) == 0;</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	virtual object_type ObjectType() const</a>
<a name="ln865">	{</a>
<a name="ln866">		return OBJECT_TYPE_DATA;</a>
<a name="ln867">	}</a>
<a name="ln868"> </a>
<a name="ln869">	virtual TypeInfo Type() const</a>
<a name="ln870">	{</a>
<a name="ln871">		return TypeInfo(fType);</a>
<a name="ln872">	}</a>
<a name="ln873"> </a>
<a name="ln874">private:</a>
<a name="ln875">	type_type	fType;</a>
<a name="ln876">};</a>
<a name="ln877"> </a>
<a name="ln878"> </a>
<a name="ln879">class TypedNumberLiteralNode : public Node {</a>
<a name="ln880">public:</a>
<a name="ln881">	TypedNumberLiteralNode(Node* type, const char* number, size_t length)</a>
<a name="ln882">		:</a>
<a name="ln883">		fType(type),</a>
<a name="ln884">		fNumber(number),</a>
<a name="ln885">		fLength(length)</a>
<a name="ln886">	{</a>
<a name="ln887">		fType-&gt;SetParent(this);</a>
<a name="ln888">	}</a>
<a name="ln889"> </a>
<a name="ln890">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln891">	{</a>
<a name="ln892">		// If the type is bool and the number is 0 or 1, we use &quot;false&quot; or</a>
<a name="ln893">		// &quot;true&quot; respectively.</a>
<a name="ln894">		if (fType-&gt;IsTypeName(&quot;bool&quot;, 4) &amp;&amp; fLength == 1</a>
<a name="ln895">			&amp;&amp; (fNumber[0] == '0' || fNumber[0] == '1')) {</a>
<a name="ln896">			return buffer.Append(fNumber[0] == '0' ? &quot;false&quot; : &quot;true&quot;);</a>
<a name="ln897">		}</a>
<a name="ln898"> </a>
<a name="ln899">		// Add the type in parentheses. The GNU demangler omits &quot;int&quot;, so do we.</a>
<a name="ln900">		if (!fType-&gt;IsTypeName(&quot;int&quot;, 3)) {</a>
<a name="ln901">			buffer.Append(&quot;(&quot;);</a>
<a name="ln902">			if (!fType-&gt;GetName(buffer))</a>
<a name="ln903">				return false;</a>
<a name="ln904">			buffer.Append(&quot;)&quot;);</a>
<a name="ln905">		}</a>
<a name="ln906"> </a>
<a name="ln907">		// add the number -- replace a leading 'n' by '-', if necessary</a>
<a name="ln908">		if (fLength &gt; 0 &amp;&amp; fNumber[0] == 'n') {</a>
<a name="ln909">			buffer.Append(&quot;-&quot;);</a>
<a name="ln910">			return buffer.Append(fNumber + 1, fLength - 1);</a>
<a name="ln911">		}</a>
<a name="ln912"> </a>
<a name="ln913">		return buffer.Append(fNumber, fLength);</a>
<a name="ln914">	}</a>
<a name="ln915"> </a>
<a name="ln916">	virtual object_type ObjectType() const</a>
<a name="ln917">	{</a>
<a name="ln918">		return OBJECT_TYPE_DATA;</a>
<a name="ln919">	}</a>
<a name="ln920"> </a>
<a name="ln921">private:</a>
<a name="ln922">	Node*		fType;</a>
<a name="ln923">	const char*	fNumber;</a>
<a name="ln924">	size_t		fLength;</a>
<a name="ln925">};</a>
<a name="ln926"> </a>
<a name="ln927"> </a>
<a name="ln928">class XtructorNode : public Node {</a>
<a name="ln929">public:</a>
<a name="ln930">	XtructorNode(bool constructor, char type)</a>
<a name="ln931">		:</a>
<a name="ln932">		fConstructor(constructor),</a>
<a name="ln933">		fType(type)</a>
<a name="ln934">	{</a>
<a name="ln935">	}</a>
<a name="ln936"> </a>
<a name="ln937">	virtual void SetParent(Node* node)</a>
<a name="ln938">	{</a>
<a name="ln939">		fUnqualifiedNode = node-&gt;GetUnqualifiedNode(this);</a>
<a name="ln940">		Node::SetParent(node);</a>
<a name="ln941">	}</a>
<a name="ln942"> </a>
<a name="ln943">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln944">	{</a>
<a name="ln945">		if (fUnqualifiedNode == NULL)</a>
<a name="ln946">			return false;</a>
<a name="ln947"> </a>
<a name="ln948">		if (!fConstructor)</a>
<a name="ln949">			buffer.Append(&quot;~&quot;);</a>
<a name="ln950"> </a>
<a name="ln951">		return fUnqualifiedNode-&gt;GetName(buffer);</a>
<a name="ln952">	}</a>
<a name="ln953"> </a>
<a name="ln954">	virtual bool IsNoReturnValueFunction() const</a>
<a name="ln955">	{</a>
<a name="ln956">		return true;</a>
<a name="ln957">	}</a>
<a name="ln958"> </a>
<a name="ln959">	virtual object_type ObjectType() const</a>
<a name="ln960">	{</a>
<a name="ln961">		return OBJECT_TYPE_METHOD_CLASS;</a>
<a name="ln962">	}</a>
<a name="ln963"> </a>
<a name="ln964">private:</a>
<a name="ln965">	bool		fConstructor;</a>
<a name="ln966">	char		fType;</a>
<a name="ln967">	Node*		fUnqualifiedNode;</a>
<a name="ln968">};</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">class SpecialNameNode : public Node {</a>
<a name="ln972">public:</a>
<a name="ln973">	SpecialNameNode(const char* name, Node* child)</a>
<a name="ln974">		:</a>
<a name="ln975">		fName(name),</a>
<a name="ln976">		fChild(child)</a>
<a name="ln977">	{</a>
<a name="ln978">		fChild-&gt;SetParent(this);</a>
<a name="ln979">	}</a>
<a name="ln980"> </a>
<a name="ln981">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln982">	{</a>
<a name="ln983">		return buffer.Append(fName) &amp;&amp; fChild-&gt;GetName(buffer);</a>
<a name="ln984">	}</a>
<a name="ln985"> </a>
<a name="ln986">protected:</a>
<a name="ln987">	const char*	fName;</a>
<a name="ln988">	Node*		fChild;</a>
<a name="ln989">};</a>
<a name="ln990"> </a>
<a name="ln991"> </a>
<a name="ln992">class DecoratingNode : public Node {</a>
<a name="ln993">public:</a>
<a name="ln994">	DecoratingNode(Node* child)</a>
<a name="ln995">		:</a>
<a name="ln996">		fChildNode(child)</a>
<a name="ln997">	{</a>
<a name="ln998">		fChildNode-&gt;SetParent(this);</a>
<a name="ln999">	}</a>
<a name="ln1000"> </a>
<a name="ln1001">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1002">	{</a>
<a name="ln1003">		NameDecorationInfo decorationInfo(this);</a>
<a name="ln1004">		return fChildNode-&gt;GetDecoratedName(buffer, decorationInfo);</a>
<a name="ln1005">	}</a>
<a name="ln1006"> </a>
<a name="ln1007">	virtual bool GetDecoratedName(NameBuffer&amp; buffer,</a>
<a name="ln1008">		NameDecorationInfo&amp; decorationInfo) const</a>
<a name="ln1009">	{</a>
<a name="ln1010">		decorationInfo.closestCVDecoratorList = NULL;</a>
<a name="ln1011">		return fChildNode-&gt;GetDecoratedName(buffer, decorationInfo);</a>
<a name="ln1012">	}</a>
<a name="ln1013"> </a>
<a name="ln1014">protected:</a>
<a name="ln1015">	Node*	fChildNode;</a>
<a name="ln1016">};</a>
<a name="ln1017"> </a>
<a name="ln1018"> </a>
<a name="ln1019">class CVQualifiersNode : public DecoratingNode {</a>
<a name="ln1020">public:</a>
<a name="ln1021">	CVQualifiersNode(int qualifiers, Node* child)</a>
<a name="ln1022">		:</a>
<a name="ln1023">		DecoratingNode(child),</a>
<a name="ln1024">		fCVQualifiers(qualifiers)</a>
<a name="ln1025">	{</a>
<a name="ln1026">	}</a>
<a name="ln1027"> </a>
<a name="ln1028">	virtual bool GetDecoratedName(NameBuffer&amp; buffer,</a>
<a name="ln1029">		NameDecorationInfo&amp; decorationInfo) const</a>
<a name="ln1030">	{</a>
<a name="ln1031">		if (decorationInfo.closestCVDecoratorList == NULL)</a>
<a name="ln1032">			decorationInfo.closestCVDecoratorList = this;</a>
<a name="ln1033">		return fChildNode-&gt;GetDecoratedName(buffer, decorationInfo);</a>
<a name="ln1034">	}</a>
<a name="ln1035"> </a>
<a name="ln1036">	virtual bool AddDecoration(NameBuffer&amp; buffer,</a>
<a name="ln1037">		const Node* stopDecorator) const</a>
<a name="ln1038">	{</a>
<a name="ln1039">		if (this == stopDecorator)</a>
<a name="ln1040">			return true;</a>
<a name="ln1041"> </a>
<a name="ln1042">		if (!fChildNode-&gt;AddDecoration(buffer, stopDecorator))</a>
<a name="ln1043">			return false;</a>
<a name="ln1044"> </a>
<a name="ln1045">		if ((fCVQualifiers &amp; CV_QUALIFIER_RESTRICT) != 0)</a>
<a name="ln1046">			buffer.Append(&quot; restrict&quot;);</a>
<a name="ln1047">		if ((fCVQualifiers &amp; CV_QUALIFIER_VOLATILE) != 0)</a>
<a name="ln1048">			buffer.Append(&quot; volatile&quot;);</a>
<a name="ln1049">		if ((fCVQualifiers &amp; CV_QUALIFIER_CONST) != 0)</a>
<a name="ln1050">			buffer.Append(&quot; const&quot;);</a>
<a name="ln1051"> </a>
<a name="ln1052">		return true;</a>
<a name="ln1053">	}</a>
<a name="ln1054"> </a>
<a name="ln1055">	virtual void GetCVQualifierInfo(CVQualifierInfo&amp; info) const</a>
<a name="ln1056">	{</a>
<a name="ln1057">		if (info.firstCVQualifier == NULL)</a>
<a name="ln1058">			info.firstCVQualifier = this;</a>
<a name="ln1059">		fChildNode-&gt;GetCVQualifierInfo(info);</a>
<a name="ln1060">	}</a>
<a name="ln1061"> </a>
<a name="ln1062">	virtual bool IsTemplatized() const</a>
<a name="ln1063">	{</a>
<a name="ln1064">		return fChildNode-&gt;IsTemplatized();</a>
<a name="ln1065">	}</a>
<a name="ln1066"> </a>
<a name="ln1067">	virtual Node* TemplateParameterAt(int index) const</a>
<a name="ln1068">	{</a>
<a name="ln1069">		return fChildNode-&gt;TemplateParameterAt(index);</a>
<a name="ln1070">	}</a>
<a name="ln1071"> </a>
<a name="ln1072">	virtual bool IsNoReturnValueFunction() const</a>
<a name="ln1073">	{</a>
<a name="ln1074">		return fChildNode-&gt;IsNoReturnValueFunction();</a>
<a name="ln1075">	}</a>
<a name="ln1076"> </a>
<a name="ln1077">	virtual object_type ObjectType() const</a>
<a name="ln1078">	{</a>
<a name="ln1079">		return fChildNode-&gt;ObjectType();</a>
<a name="ln1080">	}</a>
<a name="ln1081"> </a>
<a name="ln1082">	virtual prefix_type PrefixType() const</a>
<a name="ln1083">	{</a>
<a name="ln1084">		return fChildNode-&gt;PrefixType();</a>
<a name="ln1085">	}</a>
<a name="ln1086"> </a>
<a name="ln1087">	virtual TypeInfo Type() const</a>
<a name="ln1088">	{</a>
<a name="ln1089">		return TypeInfo(fChildNode-&gt;Type(), fCVQualifiers);</a>
<a name="ln1090">	}</a>
<a name="ln1091"> </a>
<a name="ln1092">private:</a>
<a name="ln1093">	int		fCVQualifiers;</a>
<a name="ln1094">};</a>
<a name="ln1095"> </a>
<a name="ln1096"> </a>
<a name="ln1097">class TypeModifierNode : public DecoratingNode {</a>
<a name="ln1098">public:</a>
<a name="ln1099">	TypeModifierNode(type_modifier modifier, Node* child)</a>
<a name="ln1100">		:</a>
<a name="ln1101">		DecoratingNode(child),</a>
<a name="ln1102">		fModifier(modifier)</a>
<a name="ln1103">	{</a>
<a name="ln1104">	}</a>
<a name="ln1105"> </a>
<a name="ln1106">	virtual bool AddDecoration(NameBuffer&amp; buffer,</a>
<a name="ln1107">		const Node* stopDecorator) const</a>
<a name="ln1108">	{</a>
<a name="ln1109">		if (this == stopDecorator)</a>
<a name="ln1110">			return true;</a>
<a name="ln1111"> </a>
<a name="ln1112">		return fChildNode-&gt;AddDecoration(buffer, stopDecorator)</a>
<a name="ln1113">			&amp;&amp; buffer.Append(kTypeModifierSuffixes[fModifier]);</a>
<a name="ln1114">	}</a>
<a name="ln1115"> </a>
<a name="ln1116">	virtual object_type ObjectType() const</a>
<a name="ln1117">	{</a>
<a name="ln1118">		return OBJECT_TYPE_DATA;</a>
<a name="ln1119">	}</a>
<a name="ln1120"> </a>
<a name="ln1121">	virtual TypeInfo Type() const</a>
<a name="ln1122">	{</a>
<a name="ln1123">		TypeInfo type = fChildNode-&gt;Type();</a>
<a name="ln1124">		if (type.type == TYPE_CHAR</a>
<a name="ln1125">			&amp;&amp; (type.cvQualifiers &amp; CV_QUALIFIER_CONST) != 0) {</a>
<a name="ln1126">			return TypeInfo(TYPE_CONST_CHAR_POINTER);</a>
<a name="ln1127">		}</a>
<a name="ln1128"> </a>
<a name="ln1129">		switch (fModifier) {</a>
<a name="ln1130">			case TYPE_QUALIFIER_POINTER:</a>
<a name="ln1131">				return TypeInfo(TYPE_POINTER);</a>
<a name="ln1132">			case TYPE_QUALIFIER_REFERENCE:</a>
<a name="ln1133">				return TypeInfo(TYPE_REFERENCE);</a>
<a name="ln1134">			default:</a>
<a name="ln1135">				return TypeInfo();</a>
<a name="ln1136">		}</a>
<a name="ln1137">	}</a>
<a name="ln1138"> </a>
<a name="ln1139">private:</a>
<a name="ln1140">	type_modifier	fModifier;</a>
<a name="ln1141">};</a>
<a name="ln1142"> </a>
<a name="ln1143"> </a>
<a name="ln1144">class VendorTypeModifierNode : public DecoratingNode {</a>
<a name="ln1145">public:</a>
<a name="ln1146">	VendorTypeModifierNode(Node* name, Node* child)</a>
<a name="ln1147">		:</a>
<a name="ln1148">		DecoratingNode(child),</a>
<a name="ln1149">		fName(name)</a>
<a name="ln1150">	{</a>
<a name="ln1151">		fName-&gt;SetParent(this);</a>
<a name="ln1152">	}</a>
<a name="ln1153"> </a>
<a name="ln1154">	virtual bool AddDecoration(NameBuffer&amp; buffer,</a>
<a name="ln1155">		const Node* stopDecorator) const</a>
<a name="ln1156">	{</a>
<a name="ln1157">		if (this == stopDecorator)</a>
<a name="ln1158">			return true;</a>
<a name="ln1159"> </a>
<a name="ln1160">		return fChildNode-&gt;AddDecoration(buffer, stopDecorator)</a>
<a name="ln1161">			&amp;&amp; buffer.Append(&quot; &quot;)</a>
<a name="ln1162">			&amp;&amp; fName-&gt;GetName(buffer);</a>
<a name="ln1163">	}</a>
<a name="ln1164"> </a>
<a name="ln1165">	virtual object_type ObjectType() const</a>
<a name="ln1166">	{</a>
<a name="ln1167">		return OBJECT_TYPE_DATA;</a>
<a name="ln1168">	}</a>
<a name="ln1169"> </a>
<a name="ln1170">private:</a>
<a name="ln1171">	Node*	fName;</a>
<a name="ln1172">};</a>
<a name="ln1173"> </a>
<a name="ln1174"> </a>
<a name="ln1175">class OperatorNode : public Node {</a>
<a name="ln1176">public:</a>
<a name="ln1177">	OperatorNode(const operator_info* info)</a>
<a name="ln1178">		:</a>
<a name="ln1179">		fInfo(info)</a>
<a name="ln1180">	{</a>
<a name="ln1181">		SetReferenceable(false);</a>
<a name="ln1182">	}</a>
<a name="ln1183"> </a>
<a name="ln1184">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1185">	{</a>
<a name="ln1186">		return buffer.Append(</a>
<a name="ln1187">				isalpha(fInfo-&gt;name[0]) ?  &quot;operator &quot; : &quot;operator&quot;)</a>
<a name="ln1188">			&amp;&amp; buffer.Append(fInfo-&gt;name);</a>
<a name="ln1189">	}</a>
<a name="ln1190"> </a>
<a name="ln1191">	virtual object_type ObjectType() const</a>
<a name="ln1192">	{</a>
<a name="ln1193">		return (fInfo-&gt;flags &amp; OPERATOR_IS_MEMBER) != 0</a>
<a name="ln1194">			? OBJECT_TYPE_METHOD_CLASS : OBJECT_TYPE_UNKNOWN;</a>
<a name="ln1195">	}</a>
<a name="ln1196"> </a>
<a name="ln1197">private:</a>
<a name="ln1198">	const operator_info*	fInfo;</a>
<a name="ln1199">};</a>
<a name="ln1200"> </a>
<a name="ln1201"> </a>
<a name="ln1202">class VendorOperatorNode : public Node {</a>
<a name="ln1203">public:</a>
<a name="ln1204">	VendorOperatorNode(Node* name)</a>
<a name="ln1205">		:</a>
<a name="ln1206">		fName(name)</a>
<a name="ln1207">	{</a>
<a name="ln1208">		fName-&gt;SetParent(this);</a>
<a name="ln1209">		SetReferenceable(false);</a>
<a name="ln1210">	}</a>
<a name="ln1211"> </a>
<a name="ln1212">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1213">	{</a>
<a name="ln1214">		return buffer.Append(&quot;operator &quot;)</a>
<a name="ln1215">			&amp;&amp; fName-&gt;GetName(buffer);</a>
<a name="ln1216">	}</a>
<a name="ln1217"> </a>
<a name="ln1218">private:</a>
<a name="ln1219">	Node*	fName;</a>
<a name="ln1220">};</a>
<a name="ln1221"> </a>
<a name="ln1222"> </a>
<a name="ln1223">class CastOperatorNode : public Node {</a>
<a name="ln1224">public:</a>
<a name="ln1225">	CastOperatorNode(Node* child)</a>
<a name="ln1226">		:</a>
<a name="ln1227">		fChildNode(child)</a>
<a name="ln1228">	{</a>
<a name="ln1229">		fChildNode-&gt;SetParent(this);</a>
<a name="ln1230">	}</a>
<a name="ln1231"> </a>
<a name="ln1232">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1233">	{</a>
<a name="ln1234">		return buffer.Append(&quot;operator &quot;) &amp;&amp; fChildNode-&gt;GetName(buffer);</a>
<a name="ln1235">	}</a>
<a name="ln1236"> </a>
<a name="ln1237">	virtual bool IsNoReturnValueFunction() const</a>
<a name="ln1238">	{</a>
<a name="ln1239">		return true;</a>
<a name="ln1240">	}</a>
<a name="ln1241"> </a>
<a name="ln1242">	virtual object_type ObjectType() const</a>
<a name="ln1243">	{</a>
<a name="ln1244">		return OBJECT_TYPE_METHOD_OBJECT;</a>
<a name="ln1245">	}</a>
<a name="ln1246"> </a>
<a name="ln1247">private:</a>
<a name="ln1248">	Node*	fChildNode;</a>
<a name="ln1249">};</a>
<a name="ln1250"> </a>
<a name="ln1251"> </a>
<a name="ln1252">class PrefixedNode : public Node {</a>
<a name="ln1253">public:</a>
<a name="ln1254">	PrefixedNode(Node* prefix, Node* node)</a>
<a name="ln1255">		:</a>
<a name="ln1256">		fPrefixNode(prefix),</a>
<a name="ln1257">		fNode(node)</a>
<a name="ln1258">	{</a>
<a name="ln1259">		fPrefixNode-&gt;SetParent(this);</a>
<a name="ln1260">		fNode-&gt;SetParent(this);</a>
<a name="ln1261">	}</a>
<a name="ln1262"> </a>
<a name="ln1263">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1264">	{</a>
<a name="ln1265">		if (!fPrefixNode-&gt;GetName(buffer))</a>
<a name="ln1266">			return false;</a>
<a name="ln1267"> </a>
<a name="ln1268">		buffer.Append(&quot;::&quot;);</a>
<a name="ln1269">		return fNode-&gt;GetName(buffer);</a>
<a name="ln1270">	}</a>
<a name="ln1271"> </a>
<a name="ln1272">	virtual Node* GetUnqualifiedNode(Node* beforeNode)</a>
<a name="ln1273">	{</a>
<a name="ln1274">		return beforeNode == fNode</a>
<a name="ln1275">			? fPrefixNode-&gt;GetUnqualifiedNode(beforeNode)</a>
<a name="ln1276">			: fNode-&gt;GetUnqualifiedNode(beforeNode);</a>
<a name="ln1277">	}</a>
<a name="ln1278"> </a>
<a name="ln1279">	virtual bool IsNoReturnValueFunction() const</a>
<a name="ln1280">	{</a>
<a name="ln1281">		return fNode-&gt;IsNoReturnValueFunction();</a>
<a name="ln1282">	}</a>
<a name="ln1283"> </a>
<a name="ln1284">	virtual object_type ObjectType() const</a>
<a name="ln1285">	{</a>
<a name="ln1286">		return fNode-&gt;ObjectType();</a>
<a name="ln1287">	}</a>
<a name="ln1288"> </a>
<a name="ln1289">	virtual prefix_type PrefixType() const</a>
<a name="ln1290">	{</a>
<a name="ln1291">		return PREFIX_UNKNOWN;</a>
<a name="ln1292">	}</a>
<a name="ln1293"> </a>
<a name="ln1294">private:</a>
<a name="ln1295">	Node*	fPrefixNode;</a>
<a name="ln1296">	Node*	fNode;</a>
<a name="ln1297">};</a>
<a name="ln1298"> </a>
<a name="ln1299"> </a>
<a name="ln1300">typedef PrefixedNode DependentNameNode;</a>
<a name="ln1301"> </a>
<a name="ln1302"> </a>
<a name="ln1303">class TemplateNode : public Node {</a>
<a name="ln1304">public:</a>
<a name="ln1305">	TemplateNode(Node* base)</a>
<a name="ln1306">		:</a>
<a name="ln1307">		fBase(base),</a>
<a name="ln1308">		fFirstArgument(NULL),</a>
<a name="ln1309">		fLastArgument(NULL)</a>
<a name="ln1310">	{</a>
<a name="ln1311">		fBase-&gt;SetParent(this);</a>
<a name="ln1312">	}</a>
<a name="ln1313"> </a>
<a name="ln1314">	void AddArgument(Node* child)</a>
<a name="ln1315">	{</a>
<a name="ln1316">		child-&gt;SetParent(this);</a>
<a name="ln1317"> </a>
<a name="ln1318">		if (fLastArgument != NULL) {</a>
<a name="ln1319">			fLastArgument-&gt;SetNext(child);</a>
<a name="ln1320">			fLastArgument = child;</a>
<a name="ln1321">		} else {</a>
<a name="ln1322">			fFirstArgument = child;</a>
<a name="ln1323">			fLastArgument = child;</a>
<a name="ln1324">		}</a>
<a name="ln1325">	}</a>
<a name="ln1326"> </a>
<a name="ln1327">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1328">	{</a>
<a name="ln1329">		if (!fBase-&gt;GetName(buffer))</a>
<a name="ln1330">			return false;</a>
<a name="ln1331"> </a>
<a name="ln1332">		buffer.Append(&quot;&lt;&quot;);</a>
<a name="ln1333"> </a>
<a name="ln1334">		Node* child = fFirstArgument;</a>
<a name="ln1335">		while (child != NULL) {</a>
<a name="ln1336">			if (child != fFirstArgument)</a>
<a name="ln1337">				buffer.Append(&quot;, &quot;);</a>
<a name="ln1338"> </a>
<a name="ln1339">			if (!child-&gt;GetName(buffer))</a>
<a name="ln1340">				return false;</a>
<a name="ln1341"> </a>
<a name="ln1342">			child = child-&gt;Next();</a>
<a name="ln1343">		}</a>
<a name="ln1344"> </a>
<a name="ln1345">		// add a space between consecutive '&gt;'</a>
<a name="ln1346">		if (buffer.LastChar() == '&gt;')</a>
<a name="ln1347">			buffer.Append(&quot; &quot;);</a>
<a name="ln1348"> </a>
<a name="ln1349">		return buffer.Append(&quot;&gt;&quot;);</a>
<a name="ln1350">	}</a>
<a name="ln1351"> </a>
<a name="ln1352">	virtual Node* GetUnqualifiedNode(Node* beforeNode)</a>
<a name="ln1353">	{</a>
<a name="ln1354">		return fBase != beforeNode</a>
<a name="ln1355">			? fBase-&gt;GetUnqualifiedNode(beforeNode) : this;</a>
<a name="ln1356">	}</a>
<a name="ln1357"> </a>
<a name="ln1358">	virtual bool IsTemplatized() const</a>
<a name="ln1359">	{</a>
<a name="ln1360">		return true;</a>
<a name="ln1361">	}</a>
<a name="ln1362"> </a>
<a name="ln1363">	virtual Node* TemplateParameterAt(int index) const</a>
<a name="ln1364">	{</a>
<a name="ln1365">		Node* child = fFirstArgument;</a>
<a name="ln1366">		while (child != NULL) {</a>
<a name="ln1367">			if (index == 0)</a>
<a name="ln1368">				return child;</a>
<a name="ln1369">			index--;</a>
<a name="ln1370">			child = child-&gt;Next();</a>
<a name="ln1371">		}</a>
<a name="ln1372"> </a>
<a name="ln1373">		return NULL;</a>
<a name="ln1374">	}</a>
<a name="ln1375"> </a>
<a name="ln1376">	virtual bool IsNoReturnValueFunction() const</a>
<a name="ln1377">	{</a>
<a name="ln1378">		return fBase-&gt;IsNoReturnValueFunction();</a>
<a name="ln1379">	}</a>
<a name="ln1380"> </a>
<a name="ln1381">	virtual object_type ObjectType() const</a>
<a name="ln1382">	{</a>
<a name="ln1383">		return fBase-&gt;ObjectType();</a>
<a name="ln1384">	}</a>
<a name="ln1385"> </a>
<a name="ln1386">	virtual prefix_type PrefixType() const</a>
<a name="ln1387">	{</a>
<a name="ln1388">		return fBase-&gt;PrefixType();</a>
<a name="ln1389">	}</a>
<a name="ln1390"> </a>
<a name="ln1391">protected:</a>
<a name="ln1392">	Node*	fBase;</a>
<a name="ln1393">	Node*	fFirstArgument;</a>
<a name="ln1394">	Node*	fLastArgument;</a>
<a name="ln1395">};</a>
<a name="ln1396"> </a>
<a name="ln1397"> </a>
<a name="ln1398">class MultiSubExpressionsNode : public Node {</a>
<a name="ln1399">public:</a>
<a name="ln1400">	MultiSubExpressionsNode()</a>
<a name="ln1401">		:</a>
<a name="ln1402">		fFirstSubExpression(NULL),</a>
<a name="ln1403">		fLastSubExpression(NULL)</a>
<a name="ln1404">	{</a>
<a name="ln1405">	}</a>
<a name="ln1406"> </a>
<a name="ln1407">	void AddSubExpression(Node* child)</a>
<a name="ln1408">	{</a>
<a name="ln1409">		child-&gt;SetParent(this);</a>
<a name="ln1410"> </a>
<a name="ln1411">		if (fLastSubExpression != NULL) {</a>
<a name="ln1412">			fLastSubExpression-&gt;SetNext(child);</a>
<a name="ln1413">			fLastSubExpression = child;</a>
<a name="ln1414">		} else {</a>
<a name="ln1415">			fFirstSubExpression = child;</a>
<a name="ln1416">			fLastSubExpression = child;</a>
<a name="ln1417">		}</a>
<a name="ln1418">	}</a>
<a name="ln1419"> </a>
<a name="ln1420">protected:</a>
<a name="ln1421">	Node*		fFirstSubExpression;</a>
<a name="ln1422">	Node*		fLastSubExpression;</a>
<a name="ln1423">};</a>
<a name="ln1424"> </a>
<a name="ln1425"> </a>
<a name="ln1426">class CallNode : public MultiSubExpressionsNode {</a>
<a name="ln1427">public:</a>
<a name="ln1428">	CallNode()</a>
<a name="ln1429">	{</a>
<a name="ln1430">	}</a>
<a name="ln1431"> </a>
<a name="ln1432">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1433">	{</a>
<a name="ln1434">		// TODO: Use the real syntax!</a>
<a name="ln1435">		buffer.Append(&quot;call(&quot;);</a>
<a name="ln1436"> </a>
<a name="ln1437">		Node* child = fFirstSubExpression;</a>
<a name="ln1438">		while (child != NULL) {</a>
<a name="ln1439">			if (child != fFirstSubExpression)</a>
<a name="ln1440">				buffer.Append(&quot;, &quot;);</a>
<a name="ln1441"> </a>
<a name="ln1442">			if (!child-&gt;GetName(buffer))</a>
<a name="ln1443">				return false;</a>
<a name="ln1444"> </a>
<a name="ln1445">			child = child-&gt;Next();</a>
<a name="ln1446">		}</a>
<a name="ln1447"> </a>
<a name="ln1448">		buffer.Append(&quot;)&quot;);</a>
<a name="ln1449"> </a>
<a name="ln1450">		return true;</a>
<a name="ln1451">	}</a>
<a name="ln1452">};</a>
<a name="ln1453"> </a>
<a name="ln1454"> </a>
<a name="ln1455">class OperatorExpressionNode : public MultiSubExpressionsNode {</a>
<a name="ln1456">public:</a>
<a name="ln1457">	OperatorExpressionNode(const operator_info* info)</a>
<a name="ln1458">		:</a>
<a name="ln1459">		fInfo(info)</a>
<a name="ln1460">	{</a>
<a name="ln1461">	}</a>
<a name="ln1462"> </a>
<a name="ln1463">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1464">	{</a>
<a name="ln1465">		bool isIdentifier = isalpha(fInfo-&gt;name[0]) || fInfo-&gt;name[0] == '_';</a>
<a name="ln1466"> </a>
<a name="ln1467">		if (fInfo-&gt;argument_count == 1 || isIdentifier</a>
<a name="ln1468">			|| fInfo-&gt;argument_count &gt; 3</a>
<a name="ln1469">			|| (fInfo-&gt;argument_count == 3 &amp;&amp; strcmp(fInfo-&gt;name, &quot;?&quot;) != 0)) {</a>
<a name="ln1470">			// prefix operator</a>
<a name="ln1471">			buffer.Append(fInfo-&gt;name);</a>
<a name="ln1472"> </a>
<a name="ln1473">			if (isIdentifier)</a>
<a name="ln1474">				buffer.Append(&quot;(&quot;);</a>
<a name="ln1475"> </a>
<a name="ln1476">			Node* child = fFirstSubExpression;</a>
<a name="ln1477">			while (child != NULL) {</a>
<a name="ln1478">				if (child != fFirstSubExpression)</a>
<a name="ln1479">					buffer.Append(&quot;, &quot;);</a>
<a name="ln1480"> </a>
<a name="ln1481">				if (!child-&gt;GetName(buffer))</a>
<a name="ln1482">					return false;</a>
<a name="ln1483"> </a>
<a name="ln1484">				child = child-&gt;Next();</a>
<a name="ln1485">			}</a>
<a name="ln1486"> </a>
<a name="ln1487">			if (isIdentifier)</a>
<a name="ln1488">				buffer.Append(&quot;)&quot;);</a>
<a name="ln1489"> </a>
<a name="ln1490">			return true;</a>
<a name="ln1491">		}</a>
<a name="ln1492"> </a>
<a name="ln1493">		Node* arg1 = fFirstSubExpression;</a>
<a name="ln1494">		Node* arg2 = arg1-&gt;Next();</a>
<a name="ln1495"> </a>
<a name="ln1496">		buffer.Append(&quot;(&quot;);</a>
<a name="ln1497"> </a>
<a name="ln1498">		if (fInfo-&gt;argument_count == 2) {</a>
<a name="ln1499">			// binary infix operator</a>
<a name="ln1500">			if (!arg1-&gt;GetName(buffer))</a>
<a name="ln1501">				return false;</a>
<a name="ln1502"> </a>
<a name="ln1503">			buffer.Append(&quot; &quot;);</a>
<a name="ln1504">			buffer.Append(fInfo-&gt;name);</a>
<a name="ln1505">			buffer.Append(&quot; &quot;);</a>
<a name="ln1506"> </a>
<a name="ln1507">			if (!arg2-&gt;GetName(buffer))</a>
<a name="ln1508">				return false;</a>
<a name="ln1509"> </a>
<a name="ln1510">			return buffer.Append(&quot;)&quot;);</a>
<a name="ln1511">		}</a>
<a name="ln1512"> </a>
<a name="ln1513">		Node* arg3 = arg2-&gt;Next();</a>
<a name="ln1514"> </a>
<a name="ln1515">		if (fInfo-&gt;argument_count == 2) {</a>
<a name="ln1516">			// trinary operator &quot;... ? ... : ...&quot;</a>
<a name="ln1517">			if (!arg1-&gt;GetName(buffer))</a>
<a name="ln1518">				return false;</a>
<a name="ln1519"> </a>
<a name="ln1520">			buffer.Append(&quot; ? &quot;);</a>
<a name="ln1521"> </a>
<a name="ln1522">			if (!arg2-&gt;GetName(buffer))</a>
<a name="ln1523">				return false;</a>
<a name="ln1524"> </a>
<a name="ln1525">			buffer.Append(&quot; : &quot;);</a>
<a name="ln1526"> </a>
<a name="ln1527">			if (!arg3-&gt;GetName(buffer))</a>
<a name="ln1528">				return false;</a>
<a name="ln1529"> </a>
<a name="ln1530">			return buffer.Append(&quot;)&quot;);</a>
<a name="ln1531">		}</a>
<a name="ln1532"> </a>
<a name="ln1533">		return false;</a>
<a name="ln1534">	}</a>
<a name="ln1535"> </a>
<a name="ln1536">private:</a>
<a name="ln1537">	const operator_info*	fInfo;</a>
<a name="ln1538">};</a>
<a name="ln1539"> </a>
<a name="ln1540"> </a>
<a name="ln1541">class ConversionExpressionNode : public MultiSubExpressionsNode {</a>
<a name="ln1542">public:</a>
<a name="ln1543">	ConversionExpressionNode(Node* type)</a>
<a name="ln1544">		:</a>
<a name="ln1545">		fType(type)</a>
<a name="ln1546">	{</a>
<a name="ln1547">		fType-&gt;SetParent(this);</a>
<a name="ln1548">	}</a>
<a name="ln1549"> </a>
<a name="ln1550">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1551">	{</a>
<a name="ln1552">		buffer.Append(&quot;(&quot;);</a>
<a name="ln1553"> </a>
<a name="ln1554">		if (!fType-&gt;GetName(buffer))</a>
<a name="ln1555">			return false;</a>
<a name="ln1556"> </a>
<a name="ln1557">		buffer.Append(&quot;)(&quot;);</a>
<a name="ln1558"> </a>
<a name="ln1559">		Node* child = fFirstSubExpression;</a>
<a name="ln1560">		while (child != NULL) {</a>
<a name="ln1561">			if (child != fFirstSubExpression)</a>
<a name="ln1562">				buffer.Append(&quot;, &quot;);</a>
<a name="ln1563"> </a>
<a name="ln1564">			if (!child-&gt;GetName(buffer))</a>
<a name="ln1565">				return false;</a>
<a name="ln1566"> </a>
<a name="ln1567">			child = child-&gt;Next();</a>
<a name="ln1568">		}</a>
<a name="ln1569"> </a>
<a name="ln1570">		return buffer.Append(&quot;)&quot;);</a>
<a name="ln1571">	}</a>
<a name="ln1572"> </a>
<a name="ln1573">private:</a>
<a name="ln1574">	Node*	fType;</a>
<a name="ln1575">};</a>
<a name="ln1576"> </a>
<a name="ln1577"> </a>
<a name="ln1578">class PointerToMemberNode : public DecoratingNode {</a>
<a name="ln1579">public:</a>
<a name="ln1580">	PointerToMemberNode(Node* classType, Node* memberType)</a>
<a name="ln1581">		:</a>
<a name="ln1582">		DecoratingNode(memberType),</a>
<a name="ln1583">		fClassType(classType)</a>
<a name="ln1584">	{</a>
<a name="ln1585">		fClassType-&gt;SetParent(this);</a>
<a name="ln1586">	}</a>
<a name="ln1587"> </a>
<a name="ln1588">	virtual bool AddDecoration(NameBuffer&amp; buffer,</a>
<a name="ln1589">		const Node* stopDecorator) const</a>
<a name="ln1590">	{</a>
<a name="ln1591">		if (this == stopDecorator)</a>
<a name="ln1592">			return true;</a>
<a name="ln1593"> </a>
<a name="ln1594">		if (!fChildNode-&gt;AddDecoration(buffer, stopDecorator))</a>
<a name="ln1595">			return false;</a>
<a name="ln1596"> </a>
<a name="ln1597">		// In most cases we need a space before the name. In some it is</a>
<a name="ln1598">		// superfluous, though.</a>
<a name="ln1599">		if (!buffer.IsEmpty() &amp;&amp; buffer.LastChar() != '(')</a>
<a name="ln1600">			buffer.Append(&quot; &quot;);</a>
<a name="ln1601"> </a>
<a name="ln1602">		if (!fClassType-&gt;GetName(buffer))</a>
<a name="ln1603">			return false;</a>
<a name="ln1604"> </a>
<a name="ln1605">		return buffer.Append(&quot;::*&quot;);</a>
<a name="ln1606">	}</a>
<a name="ln1607"> </a>
<a name="ln1608">	virtual object_type ObjectType() const</a>
<a name="ln1609">	{</a>
<a name="ln1610">		return OBJECT_TYPE_DATA;</a>
<a name="ln1611">	}</a>
<a name="ln1612"> </a>
<a name="ln1613">	virtual TypeInfo Type() const</a>
<a name="ln1614">	{</a>
<a name="ln1615">		// TODO: Method pointers aren't ordinary pointers. Though we might not</a>
<a name="ln1616">		// be able to determine the difference.</a>
<a name="ln1617">		return TypeInfo(TYPE_POINTER);</a>
<a name="ln1618">	}</a>
<a name="ln1619"> </a>
<a name="ln1620"> </a>
<a name="ln1621">private:</a>
<a name="ln1622">	Node*	fClassType;</a>
<a name="ln1623">};</a>
<a name="ln1624"> </a>
<a name="ln1625"> </a>
<a name="ln1626">class FunctionNode : public ObjectNode {</a>
<a name="ln1627">public:</a>
<a name="ln1628">	FunctionNode(Node* nameNode, bool hasReturnType, bool isExternC)</a>
<a name="ln1629">		:</a>
<a name="ln1630">		ObjectNode(nameNode),</a>
<a name="ln1631">		fFirstTypeNode(NULL),</a>
<a name="ln1632">		fLastTypeNode(NULL),</a>
<a name="ln1633">		fHasReturnType(hasReturnType),</a>
<a name="ln1634">		fIsExternC(isExternC)</a>
<a name="ln1635">	{</a>
<a name="ln1636">	}</a>
<a name="ln1637"> </a>
<a name="ln1638">	void AddType(Node* child)</a>
<a name="ln1639">	{</a>
<a name="ln1640">		child-&gt;SetParent(this);</a>
<a name="ln1641"> </a>
<a name="ln1642">		if (fLastTypeNode != NULL) {</a>
<a name="ln1643">			fLastTypeNode-&gt;SetNext(child);</a>
<a name="ln1644">			fLastTypeNode = child;</a>
<a name="ln1645">		} else {</a>
<a name="ln1646">			fFirstTypeNode = child;</a>
<a name="ln1647">			fLastTypeNode = child;</a>
<a name="ln1648">		}</a>
<a name="ln1649">	}</a>
<a name="ln1650"> </a>
<a name="ln1651">	virtual bool GetName(NameBuffer&amp; buffer) const</a>
<a name="ln1652">	{</a>
<a name="ln1653">		NameDecorationInfo decorationInfo(NULL);</a>
<a name="ln1654">		return GetDecoratedName(buffer, decorationInfo);</a>
<a name="ln1655">	}</a>
<a name="ln1656"> </a>
<a name="ln1657">	virtual bool GetDecoratedName(NameBuffer&amp; buffer,</a>
<a name="ln1658">		NameDecorationInfo&amp; decorationInfo) const</a>
<a name="ln1659">	{</a>
<a name="ln1660">		// write 'extern &quot;C&quot;'</a>
<a name="ln1661">//		if (fIsExternC)</a>
<a name="ln1662">//			buffer.Append(&quot;extern \&quot;C\&quot;&quot;);</a>
<a name="ln1663"> </a>
<a name="ln1664">		// write the return type</a>
<a name="ln1665">		Node* child = fFirstTypeNode;</a>
<a name="ln1666">		if (_HasReturnType() &amp;&amp; child != NULL) {</a>
<a name="ln1667">			if (!child-&gt;GetName(buffer))</a>
<a name="ln1668">				return false;</a>
<a name="ln1669">			child = child-&gt;Next();</a>
<a name="ln1670"> </a>
<a name="ln1671">			buffer.Append(&quot; &quot;, 1);</a>
<a name="ln1672">		}</a>
<a name="ln1673"> </a>
<a name="ln1674">		// write the function name</a>
<a name="ln1675">		if (fName == NULL)</a>
<a name="ln1676">			buffer.Append(&quot;(&quot;, 1);</a>
<a name="ln1677"> </a>
<a name="ln1678">		CVQualifierInfo info;</a>
<a name="ln1679">		if (fName != NULL) {</a>
<a name="ln1680">			// skip CV qualifiers on our name -- we'll add them later</a>
<a name="ln1681">			fName-&gt;GetCVQualifierInfo(info);</a>
<a name="ln1682">			if (info.firstNonCVQualifier != NULL</a>
<a name="ln1683">				&amp;&amp; !info.firstNonCVQualifier-&gt;GetName(buffer)) {</a>
<a name="ln1684">				return false;</a>
<a name="ln1685">			}</a>
<a name="ln1686">		}</a>
<a name="ln1687"> </a>
<a name="ln1688">		// add non-CV qualifier decorations</a>
<a name="ln1689">		if (decorationInfo.firstDecorator != NULL) {</a>
<a name="ln1690">			if (!decorationInfo.firstDecorator-&gt;AddDecoration(buffer,</a>
<a name="ln1691">				decorationInfo.closestCVDecoratorList)) {</a>
<a name="ln1692">				return false;</a>
<a name="ln1693">			}</a>
<a name="ln1694">		}</a>
<a name="ln1695"> </a>
<a name="ln1696">		if (fName == NULL)</a>
<a name="ln1697">			buffer.Append(&quot;)&quot;, 1);</a>
<a name="ln1698"> </a>
<a name="ln1699">		// add the parameter types</a>
<a name="ln1700">		buffer.Append(&quot;(&quot;);</a>
<a name="ln1701"> </a>
<a name="ln1702">		// don't add a single &quot;void&quot; parameter</a>
<a name="ln1703">		if (child != NULL &amp;&amp; child-&gt;Next() == NULL</a>
<a name="ln1704">			&amp;&amp; child-&gt;IsTypeName(&quot;void&quot;, 4)) {</a>
<a name="ln1705">			child = NULL;</a>
<a name="ln1706">		}</a>
<a name="ln1707"> </a>
<a name="ln1708">		Node* firstParam = child;</a>
<a name="ln1709">		while (child != NULL) {</a>
<a name="ln1710">			if (child != firstParam)</a>
<a name="ln1711">				buffer.Append(&quot;, &quot;);</a>
<a name="ln1712"> </a>
<a name="ln1713">			if (!child-&gt;GetName(buffer))</a>
<a name="ln1714">				return false;</a>
<a name="ln1715"> </a>
<a name="ln1716">			child = child-&gt;Next();</a>
<a name="ln1717">		}</a>
<a name="ln1718"> </a>
<a name="ln1719">		buffer.Append(&quot;)&quot;);</a>
<a name="ln1720"> </a>
<a name="ln1721">		// add CV qualifiers on our name</a>
<a name="ln1722">		if (info.firstCVQualifier != NULL) {</a>
<a name="ln1723">			if (!info.firstCVQualifier-&gt;AddDecoration(buffer,</a>
<a name="ln1724">					info.firstNonCVQualifier)) {</a>
<a name="ln1725">				return false;</a>
<a name="ln1726">			}</a>
<a name="ln1727">		}</a>
<a name="ln1728"> </a>
<a name="ln1729">		// add CV qualifiers on us</a>
<a name="ln1730">		if (decorationInfo.closestCVDecoratorList != NULL)</a>
<a name="ln1731">			decorationInfo.closestCVDecoratorList-&gt;AddDecoration(buffer, NULL);</a>
<a name="ln1732"> </a>
<a name="ln1733">		return true;</a>
<a name="ln1734">	}</a>
<a name="ln1735"> </a>
<a name="ln1736">	virtual object_type ObjectType() const</a>
<a name="ln1737">	{</a>
<a name="ln1738">		// no name, no fun</a>
<a name="ln1739">		if (fName == NULL)</a>
<a name="ln1740">			return OBJECT_TYPE_FUNCTION;</a>
<a name="ln1741"> </a>
<a name="ln1742">		// check our name's prefix</a>
<a name="ln1743">		switch (fName-&gt;PrefixType()) {</a>
<a name="ln1744">			case PREFIX_NONE:</a>
<a name="ln1745">			case PREFIX_NAMESPACE:</a>
<a name="ln1746">				return OBJECT_TYPE_FUNCTION;</a>
<a name="ln1747">			case PREFIX_CLASS:</a>
<a name="ln1748">			case PREFIX_UNKNOWN:</a>
<a name="ln1749">				break;</a>
<a name="ln1750">		}</a>
<a name="ln1751"> </a>
<a name="ln1752">		// Our name has a prefix, but we don't know, whether it is a class or</a>
<a name="ln1753">		// namespace. Let's ask our name what it thinks it is.</a>
<a name="ln1754">		object_type type = fName-&gt;ObjectType();</a>
<a name="ln1755">		switch (type) {</a>
<a name="ln1756">			case OBJECT_TYPE_FUNCTION:</a>
<a name="ln1757">			case OBJECT_TYPE_METHOD_CLASS:</a>
<a name="ln1758">			case OBJECT_TYPE_METHOD_OBJECT:</a>
<a name="ln1759">			case OBJECT_TYPE_METHOD_UNKNOWN:</a>
<a name="ln1760">				// That's as good as it gets.</a>
<a name="ln1761">				return type;</a>
<a name="ln1762">			case OBJECT_TYPE_UNKNOWN:</a>
<a name="ln1763">			case OBJECT_TYPE_DATA:</a>
<a name="ln1764">			default:</a>
<a name="ln1765">				// Obviously our name doesn't have a clue.</a>
<a name="ln1766">				return OBJECT_TYPE_METHOD_UNKNOWN;</a>
<a name="ln1767">		}</a>
<a name="ln1768">	}</a>
<a name="ln1769"> </a>
<a name="ln1770">	virtual Node* ParameterAt(uint32 index) const</a>
<a name="ln1771">	{</a>
<a name="ln1772">		// skip return type</a>
<a name="ln1773">		Node* child = fFirstTypeNode;</a>
<a name="ln1774">		if (_HasReturnType() &amp;&amp; child != NULL)</a>
<a name="ln1775">			child = child-&gt;Next();</a>
<a name="ln1776"> </a>
<a name="ln1777">		// ignore a single &quot;void&quot; parameter</a>
<a name="ln1778">		if (child != NULL &amp;&amp; child-&gt;Next() == NULL</a>
<a name="ln1779">			&amp;&amp; child-&gt;IsTypeName(&quot;void&quot;, 4)) {</a>
<a name="ln1780">			return NULL;</a>
<a name="ln1781">		}</a>
<a name="ln1782"> </a>
<a name="ln1783">		// get the type at the index</a>
<a name="ln1784">		while (child != NULL &amp;&amp; index &gt; 0) {</a>
<a name="ln1785">			child = child-&gt;Next();</a>
<a name="ln1786">			index--;</a>
<a name="ln1787">		}</a>
<a name="ln1788"> </a>
<a name="ln1789">		return child;</a>
<a name="ln1790">	}</a>
<a name="ln1791"> </a>
<a name="ln1792">private:</a>
<a name="ln1793">	bool _HasReturnType() const</a>
<a name="ln1794">	{</a>
<a name="ln1795">		return fHasReturnType</a>
<a name="ln1796">			|| fName == NULL</a>
<a name="ln1797">			|| (fName-&gt;IsTemplatized() &amp;&amp; !fName-&gt;IsNoReturnValueFunction());</a>
<a name="ln1798">	}</a>
<a name="ln1799"> </a>
<a name="ln1800">private:</a>
<a name="ln1801">	Node*		fFirstTypeNode;</a>
<a name="ln1802">	Node*		fLastTypeNode;</a>
<a name="ln1803">	bool		fHasReturnType;</a>
<a name="ln1804">	bool		fIsExternC;</a>
<a name="ln1805">};</a>
<a name="ln1806"> </a>
<a name="ln1807"> </a>
<a name="ln1808">// #pragma mark - Demangler</a>
<a name="ln1809"> </a>
<a name="ln1810"> </a>
<a name="ln1811">class Demangler {</a>
<a name="ln1812">public:</a>
<a name="ln1813">								Demangler();</a>
<a name="ln1814"> </a>
<a name="ln1815">			int					Demangle(const char* mangledName, char* buffer,</a>
<a name="ln1816">									size_t size,</a>
<a name="ln1817">									DemanglingInfo&amp; demanglingInfo);</a>
<a name="ln1818">			int					GetParameterInfo(const char* mangledName,</a>
<a name="ln1819">									uint32 index, char* buffer, size_t size,</a>
<a name="ln1820">									ParameterInfo&amp; info);</a>
<a name="ln1821"> </a>
<a name="ln1822">	// actually private, but public to make gcc 2 happy</a>
<a name="ln1823">	inline	bool				_SetError(int error);</a>
<a name="ln1824">	inline	void				_AddAllocatedNode(Node* node);</a>
<a name="ln1825"> </a>
<a name="ln1826">private:</a>
<a name="ln1827">	template&lt;typename NodeType&gt; struct NodeCreator;</a>
<a name="ln1828"> </a>
<a name="ln1829">	inline	bool				_SkipExpected(char c);</a>
<a name="ln1830">	inline	bool				_SkipExpected(const char* string);</a>
<a name="ln1831"> </a>
<a name="ln1832">			void				_Init();</a>
<a name="ln1833">			void				_Cleanup();</a>
<a name="ln1834"> </a>
<a name="ln1835">			int					_Demangle(const char* mangledName, char* buffer,</a>
<a name="ln1836">									size_t size,</a>
<a name="ln1837">									DemanglingInfo&amp; demanglingInfo);</a>
<a name="ln1838">			int					_GetParameterInfo(const char* mangledName,</a>
<a name="ln1839">									uint32 index, char* buffer, size_t size,</a>
<a name="ln1840">									ParameterInfo&amp; info);</a>
<a name="ln1841"> </a>
<a name="ln1842">			int					_Parse(const char* mangledName,</a>
<a name="ln1843">									const char*&amp; versionSuffix,</a>
<a name="ln1844">									ObjectNode*&amp; _node);</a>
<a name="ln1845"> </a>
<a name="ln1846">			bool				_ParseEncoding(ObjectNode*&amp; _node);</a>
<a name="ln1847">			bool				_ParseSpecialName(Node*&amp; _node);</a>
<a name="ln1848">			bool				_ParseCallOffset(bool&amp; nonVirtual,</a>
<a name="ln1849">									number_type&amp; offset1, number_type&amp; offset2);</a>
<a name="ln1850">			bool				_ParseName(Node*&amp; _node);</a>
<a name="ln1851">			bool				_ParseNestedName(Node*&amp; _node);</a>
<a name="ln1852">			bool				_ParseNestedNameInternal(Node*&amp; _node);</a>
<a name="ln1853">			bool				_ParseLocalName(Node*&amp; _node);</a>
<a name="ln1854">			bool				_ParseUnqualifiedName(Node*&amp; _node);</a>
<a name="ln1855">			bool				_ParseSourceName(Node*&amp; _node);</a>
<a name="ln1856">			bool				_ParseOperatorName(Node*&amp; _node);</a>
<a name="ln1857">			bool				_ParseType(Node*&amp; _node);</a>
<a name="ln1858">			bool				_ParseTypeInternal(Node*&amp; _node);</a>
<a name="ln1859">			void				_ParseCVQualifiers(int&amp; qualifiers);</a>
<a name="ln1860">			bool				_ParseTypeWithModifier(type_modifier modifier,</a>
<a name="ln1861">									int toSkip, Node*&amp; _node);</a>
<a name="ln1862">			bool				_TryParseBuiltinType(Node*&amp; _node);</a>
<a name="ln1863">			bool				_ParseFunctionType(FunctionNode*&amp; _node);;</a>
<a name="ln1864">			bool				_ParseArrayType(Node*&amp; _node);</a>
<a name="ln1865">			bool				_ParsePointerToMemberType(Node*&amp; _node);</a>
<a name="ln1866">			bool				_ParseTemplateParam(Node*&amp; _node);</a>
<a name="ln1867">			bool				_ParseSubstitution(Node*&amp; _node);</a>
<a name="ln1868">			bool				_ParseSubstitutionInternal(Node*&amp; _node);</a>
<a name="ln1869">			bool				_ParseBareFunctionType(FunctionNode* node);</a>
<a name="ln1870">			bool				_ParseTemplateArgs(Node* node, Node*&amp; _node);</a>
<a name="ln1871">			bool				_ParseTemplateArg(Node*&amp; _node);</a>
<a name="ln1872">			bool				_ParseExpression(Node*&amp; _node);</a>
<a name="ln1873">			bool				_ParseExpressionPrimary(Node*&amp; _node);</a>
<a name="ln1874">			bool				_ParseNumber(number_type&amp; number);</a>
<a name="ln1875"> </a>
<a name="ln1876">			bool				_CreateNodeAndSkip(const char* name,</a>
<a name="ln1877">									size_t length, int toSkip, Node*&amp; _node);</a>
<a name="ln1878">			bool				_CreateNodeAndSkip(const char* name, int toSkip,</a>
<a name="ln1879">									Node*&amp; _node);</a>
<a name="ln1880">			bool				_CreateTypeNodeAndSkip(type_type type,</a>
<a name="ln1881">									int toSkip, Node*&amp; _node);</a>
<a name="ln1882">			bool				_CreateTypeNodeAndSkip(const char* name,</a>
<a name="ln1883">									const char* prefix,</a>
<a name="ln1884">									const char* templateArgs, int toSkip,</a>
<a name="ln1885">									Node*&amp; _node);</a>
<a name="ln1886"> </a>
<a name="ln1887">			void				_RegisterReferenceableNode(Node* node);</a>
<a name="ln1888">			bool				_CreateSubstitutionNode(int index,</a>
<a name="ln1889">									Node*&amp; _node);</a>
<a name="ln1890"> </a>
<a name="ln1891">private:</a>
<a name="ln1892">			Input				fInput;</a>
<a name="ln1893">			int					fError;</a>
<a name="ln1894">			Node*				fAllocatedNodes;</a>
<a name="ln1895">			Node*				fFirstReferenceableNode;</a>
<a name="ln1896">			Node*				fLastReferenceableNode;</a>
<a name="ln1897">			Node*				fTemplatizedNode;</a>
<a name="ln1898">};</a>
<a name="ln1899"> </a>
<a name="ln1900"> </a>
<a name="ln1901">template&lt;typename NodeType&gt;</a>
<a name="ln1902">struct Demangler::NodeCreator {</a>
<a name="ln1903">	NodeCreator(Demangler* demangler)</a>
<a name="ln1904">		:</a>
<a name="ln1905">		fDemangler(demangler)</a>
<a name="ln1906">	{</a>
<a name="ln1907">	}</a>
<a name="ln1908"> </a>
<a name="ln1909">	template&lt;typename ReturnType&gt;</a>
<a name="ln1910">	inline bool operator()(ReturnType*&amp; _node) const</a>
<a name="ln1911">	{</a>
<a name="ln1912">		_node = NEW(NodeType);</a>
<a name="ln1913">		if (_node == NULL)</a>
<a name="ln1914">			return fDemangler-&gt;_SetError(ERROR_NO_MEMORY);</a>
<a name="ln1915"> </a>
<a name="ln1916">		fDemangler-&gt;_AddAllocatedNode(_node);</a>
<a name="ln1917">		return true;</a>
<a name="ln1918">	}</a>
<a name="ln1919"> </a>
<a name="ln1920">	template&lt;typename ParameterType1, typename ReturnType&gt;</a>
<a name="ln1921">	inline bool operator()(ParameterType1 arg1, ReturnType*&amp; _node) const</a>
<a name="ln1922">	{</a>
<a name="ln1923">		_node = NEW(NodeType(arg1));</a>
<a name="ln1924">		if (_node == NULL)</a>
<a name="ln1925">			return fDemangler-&gt;_SetError(ERROR_NO_MEMORY);</a>
<a name="ln1926"> </a>
<a name="ln1927">		fDemangler-&gt;_AddAllocatedNode(_node);</a>
<a name="ln1928">		return true;</a>
<a name="ln1929">	}</a>
<a name="ln1930"> </a>
<a name="ln1931">	template&lt;typename ParameterType1, typename ParameterType2,</a>
<a name="ln1932">		typename ReturnType&gt;</a>
<a name="ln1933">	inline bool operator()(ParameterType1 arg1, ParameterType2 arg2,</a>
<a name="ln1934">		ReturnType*&amp; _node) const</a>
<a name="ln1935">	{</a>
<a name="ln1936">		_node = NEW(NodeType(arg1, arg2));</a>
<a name="ln1937">		if (_node == NULL)</a>
<a name="ln1938">			return fDemangler-&gt;_SetError(ERROR_NO_MEMORY);</a>
<a name="ln1939"> </a>
<a name="ln1940">		fDemangler-&gt;_AddAllocatedNode(_node);</a>
<a name="ln1941">		return true;</a>
<a name="ln1942">	}</a>
<a name="ln1943"> </a>
<a name="ln1944">	template&lt;typename ParameterType1, typename ParameterType2,</a>
<a name="ln1945">		typename ParameterType3, typename ReturnType&gt;</a>
<a name="ln1946">	inline bool operator()(ParameterType1 arg1, ParameterType2 arg2,</a>
<a name="ln1947">		ParameterType3 arg3, ReturnType*&amp; _node) const</a>
<a name="ln1948">	{</a>
<a name="ln1949">		_node = NEW(NodeType(arg1, arg2, arg3));</a>
<a name="ln1950">		if (_node == NULL)</a>
<a name="ln1951">			return fDemangler-&gt;_SetError(ERROR_NO_MEMORY);</a>
<a name="ln1952"> </a>
<a name="ln1953">		fDemangler-&gt;_AddAllocatedNode(_node);</a>
<a name="ln1954">		return true;</a>
<a name="ln1955">	}</a>
<a name="ln1956"> </a>
<a name="ln1957">private:</a>
<a name="ln1958">		Demangler*	fDemangler;</a>
<a name="ln1959">};</a>
<a name="ln1960"> </a>
<a name="ln1961"> </a>
<a name="ln1962">inline bool</a>
<a name="ln1963">Demangler::_SetError(int error)</a>
<a name="ln1964">{</a>
<a name="ln1965">	if (fError == ERROR_OK) {</a>
<a name="ln1966">		fError = error;</a>
<a name="ln1967">#ifdef TRACE_GCC3_DEMANGLER</a>
<a name="ln1968">		DebugScope::Print(&quot;_SetError(): %d, remaining input: \&quot;%s\&quot;\n&quot;,</a>
<a name="ln1969">			error, fInput.String());</a>
<a name="ln1970">#endif</a>
<a name="ln1971">	}</a>
<a name="ln1972">	return false;</a>
<a name="ln1973">}</a>
<a name="ln1974"> </a>
<a name="ln1975"> </a>
<a name="ln1976">inline void</a>
<a name="ln1977">Demangler::_AddAllocatedNode(Node* node)</a>
<a name="ln1978">{</a>
<a name="ln1979">	node-&gt;SetNextAllocated(fAllocatedNodes);</a>
<a name="ln1980">	fAllocatedNodes = node;</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983"> </a>
<a name="ln1984">inline bool</a>
<a name="ln1985">Demangler::_SkipExpected(char c)</a>
<a name="ln1986">{</a>
<a name="ln1987">	return fInput.SkipPrefix(c) || _SetError(ERROR_INVALID);</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990"> </a>
<a name="ln1991">inline bool</a>
<a name="ln1992">Demangler::_SkipExpected(const char* string)</a>
<a name="ln1993">{</a>
<a name="ln1994">	return fInput.SkipPrefix(string) || _SetError(ERROR_INVALID);</a>
<a name="ln1995">}</a>
<a name="ln1996"> </a>
<a name="ln1997"> </a>
<a name="ln1998">Demangler::Demangler()</a>
<a name="ln1999">	:</a>
<a name="ln2000">	fInput(),</a>
<a name="ln2001">	fAllocatedNodes(NULL)</a>
<a name="ln2002">{</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005"> </a>
<a name="ln2006">int</a>
<a name="ln2007">Demangler::Demangle(const char* mangledName, char* buffer, size_t size,</a>
<a name="ln2008">	DemanglingInfo&amp; demanglingInfo)</a>
<a name="ln2009">{</a>
<a name="ln2010">	DEBUG_SCOPE(&quot;Demangle&quot;);</a>
<a name="ln2011"> </a>
<a name="ln2012">	_Init();</a>
<a name="ln2013"> </a>
<a name="ln2014">	int result = _Demangle(mangledName, buffer, size, demanglingInfo);</a>
<a name="ln2015"> </a>
<a name="ln2016">	_Cleanup();</a>
<a name="ln2017"> </a>
<a name="ln2018">	return result;</a>
<a name="ln2019">}</a>
<a name="ln2020"> </a>
<a name="ln2021"> </a>
<a name="ln2022">int</a>
<a name="ln2023">Demangler::GetParameterInfo(const char* mangledName, uint32 index, char* buffer,</a>
<a name="ln2024">	size_t size, ParameterInfo&amp; info)</a>
<a name="ln2025">{</a>
<a name="ln2026">	DEBUG_SCOPE(&quot;GetParameterInfo&quot;);</a>
<a name="ln2027"> </a>
<a name="ln2028">	_Init();</a>
<a name="ln2029"> </a>
<a name="ln2030">	int result = _GetParameterInfo(mangledName, index, buffer, size, info);</a>
<a name="ln2031"> </a>
<a name="ln2032">	_Cleanup();</a>
<a name="ln2033"> </a>
<a name="ln2034">	return result;</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037"> </a>
<a name="ln2038">void</a>
<a name="ln2039">Demangler::_Init()</a>
<a name="ln2040">{</a>
<a name="ln2041">	fError = ERROR_OK;</a>
<a name="ln2042"> </a>
<a name="ln2043">	fFirstReferenceableNode = NULL;</a>
<a name="ln2044">	fLastReferenceableNode = NULL;</a>
<a name="ln2045">	fAllocatedNodes = NULL;</a>
<a name="ln2046">	fTemplatizedNode = NULL;</a>
<a name="ln2047">}</a>
<a name="ln2048"> </a>
<a name="ln2049"> </a>
<a name="ln2050">void</a>
<a name="ln2051">Demangler::_Cleanup()</a>
<a name="ln2052">{</a>
<a name="ln2053">	while (fAllocatedNodes != NULL) {</a>
<a name="ln2054">		Node* node = fAllocatedNodes;</a>
<a name="ln2055">		fAllocatedNodes = node-&gt;NextAllocated();</a>
<a name="ln2056">		DELETE(node);</a>
<a name="ln2057">	}</a>
<a name="ln2058">}</a>
<a name="ln2059"> </a>
<a name="ln2060"> </a>
<a name="ln2061">int</a>
<a name="ln2062">Demangler::_Demangle(const char* mangledName, char* buffer, size_t size,</a>
<a name="ln2063">	DemanglingInfo&amp; demanglingInfo)</a>
<a name="ln2064">{</a>
<a name="ln2065">	// parse the name</a>
<a name="ln2066">	const char* versionSuffix;</a>
<a name="ln2067">	ObjectNode* node;</a>
<a name="ln2068">	int error = _Parse(mangledName, versionSuffix, node);</a>
<a name="ln2069">	if (error != ERROR_OK)</a>
<a name="ln2070">		return error;</a>
<a name="ln2071"> </a>
<a name="ln2072">	NameBuffer nameBuffer(buffer, size);</a>
<a name="ln2073">	bool success = node-&gt;GetObjectName(nameBuffer, demanglingInfo);</a>
<a name="ln2074"> </a>
<a name="ln2075">	// If versioned, append the unmodified version string</a>
<a name="ln2076">	if (success &amp;&amp; versionSuffix != NULL)</a>
<a name="ln2077">		nameBuffer.Append(versionSuffix);</a>
<a name="ln2078"> </a>
<a name="ln2079">	if (nameBuffer.HadOverflow())</a>
<a name="ln2080">		return ERROR_BUFFER_TOO_SMALL;</a>
<a name="ln2081"> </a>
<a name="ln2082">	if (!success)</a>
<a name="ln2083">		return ERROR_INTERNAL;</a>
<a name="ln2084"> </a>
<a name="ln2085">	demanglingInfo.objectType = node-&gt;ObjectType();</a>
<a name="ln2086"> </a>
<a name="ln2087">	nameBuffer.Terminate();</a>
<a name="ln2088">	return ERROR_OK;</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091"> </a>
<a name="ln2092">int</a>
<a name="ln2093">Demangler::_GetParameterInfo(const char* mangledName, uint32 index,</a>
<a name="ln2094">	char* buffer, size_t size, ParameterInfo&amp; info)</a>
<a name="ln2095">{</a>
<a name="ln2096">	// parse the name</a>
<a name="ln2097">	const char* versionSuffix;</a>
<a name="ln2098">	ObjectNode* node;</a>
<a name="ln2099">	int error = _Parse(mangledName, versionSuffix, node);</a>
<a name="ln2100">	if (error != ERROR_OK)</a>
<a name="ln2101">		return error;</a>
<a name="ln2102"> </a>
<a name="ln2103">	// get the parameter node</a>
<a name="ln2104">	Node* parameter = node-&gt;ParameterAt(index);</a>
<a name="ln2105">	if (parameter == NULL)</a>
<a name="ln2106">		return ERROR_INVALID_PARAMETER_INDEX;</a>
<a name="ln2107"> </a>
<a name="ln2108">	// get the parameter name</a>
<a name="ln2109">	NameBuffer nameBuffer(buffer, size);</a>
<a name="ln2110">	bool success = parameter-&gt;GetName(nameBuffer);</a>
<a name="ln2111"> </a>
<a name="ln2112">	if (nameBuffer.HadOverflow())</a>
<a name="ln2113">		return ERROR_BUFFER_TOO_SMALL;</a>
<a name="ln2114"> </a>
<a name="ln2115">	if (!success)</a>
<a name="ln2116">		return ERROR_INTERNAL;</a>
<a name="ln2117"> </a>
<a name="ln2118">	nameBuffer.Terminate();</a>
<a name="ln2119"> </a>
<a name="ln2120">	// get the type</a>
<a name="ln2121">	info.type = parameter-&gt;Type();</a>
<a name="ln2122"> </a>
<a name="ln2123">	return ERROR_OK;</a>
<a name="ln2124">}</a>
<a name="ln2125"> </a>
<a name="ln2126"> </a>
<a name="ln2127">int</a>
<a name="ln2128">Demangler::_Parse(const char* mangledName, const char*&amp; versionSuffix,</a>
<a name="ln2129">	ObjectNode*&amp; _node)</a>
<a name="ln2130">{</a>
<a name="ln2131">	// To support versioned symbols, we ignore the version suffix when</a>
<a name="ln2132">	// demangling.</a>
<a name="ln2133">	versionSuffix = strchr(mangledName, '@');</a>
<a name="ln2134">	fInput.SetTo(mangledName,</a>
<a name="ln2135">		versionSuffix != NULL</a>
<a name="ln2136">			? versionSuffix - mangledName : strlen(mangledName));</a>
<a name="ln2137"> </a>
<a name="ln2138">	// &lt;mangled-name&gt; ::= _Z &lt;encoding&gt;</a>
<a name="ln2139"> </a>
<a name="ln2140">	if (!fInput.SkipPrefix(&quot;_Z&quot;))</a>
<a name="ln2141">		return ERROR_NOT_MANGLED;</a>
<a name="ln2142"> </a>
<a name="ln2143">	if (!_ParseEncoding(_node))</a>
<a name="ln2144">		return fError;</a>
<a name="ln2145"> </a>
<a name="ln2146">	if (fInput.CharsRemaining() != 0) {</a>
<a name="ln2147">		// bogus at end of input</a>
<a name="ln2148">		return ERROR_INVALID;</a>
<a name="ln2149">	}</a>
<a name="ln2150"> </a>
<a name="ln2151">	return ERROR_OK;</a>
<a name="ln2152">}</a>
<a name="ln2153"> </a>
<a name="ln2154"> </a>
<a name="ln2155">bool</a>
<a name="ln2156">Demangler::_ParseEncoding(ObjectNode*&amp; _node)</a>
<a name="ln2157">{</a>
<a name="ln2158">	DEBUG_SCOPE(&quot;_ParseEncoding&quot;);</a>
<a name="ln2159"> </a>
<a name="ln2160">	// &lt;encoding&gt; ::= &lt;function name&gt; &lt;bare-function-type&gt;</a>
<a name="ln2161">	//	          ::= &lt;data name&gt;</a>
<a name="ln2162">	//	          ::= &lt;special-name&gt;</a>
<a name="ln2163"> </a>
<a name="ln2164">	// NOTE: This is not in the specs: Local entities seem to be prefixed</a>
<a name="ln2165">	// by an 'L'.</a>
<a name="ln2166">	fInput.SkipPrefix('L');</a>
<a name="ln2167"> </a>
<a name="ln2168">	// parse &lt;special-name&gt;, if it is one</a>
<a name="ln2169">	Node* name;</a>
<a name="ln2170">	if (fInput.HasPrefix('T') || fInput.HasPrefix(&quot;GV&quot;)) {</a>
<a name="ln2171">		return _ParseSpecialName(name)</a>
<a name="ln2172">			&amp;&amp; NodeCreator&lt;ObjectNode&gt;(this)(name, _node);</a>
<a name="ln2173">	}</a>
<a name="ln2174"> </a>
<a name="ln2175">	// either &lt;data name&gt; or &lt;function name&gt;</a>
<a name="ln2176">	if (!_ParseName(name))</a>
<a name="ln2177">		return false;</a>
<a name="ln2178"> </a>
<a name="ln2179">	if (fInput.CharsRemaining() == 0 || fInput.HasPrefix('E')) {</a>
<a name="ln2180">		// &lt;data name&gt;</a>
<a name="ln2181">		return NodeCreator&lt;ObjectNode&gt;(this)(name, _node);</a>
<a name="ln2182">	}</a>
<a name="ln2183"> </a>
<a name="ln2184">	// &lt;function name&gt; -- parse remaining &lt;bare-function-type&gt;</a>
<a name="ln2185">	FunctionNode* functionNode;</a>
<a name="ln2186">	if (!NodeCreator&lt;FunctionNode&gt;(this)(name, false, false, functionNode))</a>
<a name="ln2187">		return false;</a>
<a name="ln2188">	_node = functionNode;</a>
<a name="ln2189"> </a>
<a name="ln2190">	// If our name is templatized, we push it onto the templatized node</a>
<a name="ln2191">	// stack while parsing the function parameters.</a>
<a name="ln2192">	Node* previousTemplatizedNode = fTemplatizedNode;</a>
<a name="ln2193">	if (name-&gt;IsTemplatized())</a>
<a name="ln2194">		fTemplatizedNode = name;</a>
<a name="ln2195"> </a>
<a name="ln2196">	if (!_ParseBareFunctionType(functionNode))</a>
<a name="ln2197">		return false;</a>
<a name="ln2198"> </a>
<a name="ln2199">	fTemplatizedNode = previousTemplatizedNode;</a>
<a name="ln2200"> </a>
<a name="ln2201">	return true;</a>
<a name="ln2202">}</a>
<a name="ln2203"> </a>
<a name="ln2204"> </a>
<a name="ln2205">bool</a>
<a name="ln2206">Demangler::_ParseSpecialName(Node*&amp; _node)</a>
<a name="ln2207">{</a>
<a name="ln2208">	DEBUG_SCOPE(&quot;_ParseSpecialName&quot;);</a>
<a name="ln2209"> </a>
<a name="ln2210">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln2211">		return _SetError(ERROR_INVALID);</a>
<a name="ln2212"> </a>
<a name="ln2213">	// &lt;special-name&gt; ::= GV &lt;object name&gt;	# Guard variable for one-time</a>
<a name="ln2214">	//                                      # initialization</a>
<a name="ln2215">	//                    # No &lt;type&gt;</a>
<a name="ln2216">	if (!fInput.SkipPrefix('T')) {</a>
<a name="ln2217">		Node* name;</a>
<a name="ln2218">		return _SkipExpected(&quot;GV&quot;)</a>
<a name="ln2219">			&amp;&amp; _ParseName(name)</a>
<a name="ln2220">			&amp;&amp; NodeCreator&lt;SpecialNameNode&gt;(this)(&quot;guard variable for &quot;,</a>
<a name="ln2221">				name, _node);</a>
<a name="ln2222">	}</a>
<a name="ln2223"> </a>
<a name="ln2224">	// &lt;special-name&gt; ::= TV &lt;type&gt;	# virtual table</a>
<a name="ln2225">	//                ::= TT &lt;type&gt;	# VTT structure (construction vtable</a>
<a name="ln2226">	//                              # index)</a>
<a name="ln2227">	//                ::= TI &lt;type&gt;	# typeinfo structure</a>
<a name="ln2228">	//                ::= TS &lt;type&gt;	# typeinfo name (null-terminated byte</a>
<a name="ln2229">	//                              # string)</a>
<a name="ln2230">	const char* prefix = NULL;</a>
<a name="ln2231">	switch (fInput[0]) {</a>
<a name="ln2232">		case 'V':</a>
<a name="ln2233">			prefix = &quot;vtable for &quot;;</a>
<a name="ln2234">			break;</a>
<a name="ln2235">		case 'T':</a>
<a name="ln2236">			prefix = &quot;VTT for &quot;;</a>
<a name="ln2237">			break;</a>
<a name="ln2238">		case 'I':</a>
<a name="ln2239">			prefix = &quot;typeinfo for &quot;;</a>
<a name="ln2240">			break;</a>
<a name="ln2241">		case 'S':</a>
<a name="ln2242">			prefix = &quot;typeinfo name for &quot;;</a>
<a name="ln2243">			break;</a>
<a name="ln2244">	}</a>
<a name="ln2245"> </a>
<a name="ln2246">	if (prefix != NULL) {</a>
<a name="ln2247">		fInput.Skip(1);</a>
<a name="ln2248">		Node* type;</a>
<a name="ln2249">		return _ParseType(type)</a>
<a name="ln2250">			&amp;&amp; NodeCreator&lt;SpecialNameNode&gt;(this)(prefix, type, _node);</a>
<a name="ln2251">	}</a>
<a name="ln2252"> </a>
<a name="ln2253">	// &lt;special-name&gt; ::= Tc &lt;call-offset&gt; &lt;call-offset&gt; &lt;base encoding&gt;</a>
<a name="ln2254">	//                    # base is the nominal target function of thunk</a>
<a name="ln2255">	//                    # first call-offset is 'this' adjustment</a>
<a name="ln2256">	//                    # second call-offset is result adjustment</a>
<a name="ln2257">	if (fInput.SkipPrefix('c')) {</a>
<a name="ln2258">		bool nonVirtual;</a>
<a name="ln2259">		number_type offset1;</a>
<a name="ln2260">		number_type offset2;</a>
<a name="ln2261">		ObjectNode* name;</a>
<a name="ln2262">		return _ParseCallOffset(nonVirtual, offset1, offset2)</a>
<a name="ln2263">			&amp;&amp; _ParseCallOffset(nonVirtual, offset1, offset2)</a>
<a name="ln2264">			&amp;&amp; _ParseEncoding(name)</a>
<a name="ln2265">			&amp;&amp; NodeCreator&lt;SpecialNameNode&gt;(this)(</a>
<a name="ln2266">				&quot;covariant return thunk to &quot;, name, _node);</a>
<a name="ln2267">	}</a>
<a name="ln2268"> </a>
<a name="ln2269">	// &lt;special-name&gt; ::= T &lt;call-offset&gt; &lt;base encoding&gt;</a>
<a name="ln2270">	//                    # base is the nominal target function of thunk</a>
<a name="ln2271">	bool nonVirtual;</a>
<a name="ln2272">	number_type offset1;</a>
<a name="ln2273">	number_type offset2;</a>
<a name="ln2274">	ObjectNode* name;</a>
<a name="ln2275">	return _ParseCallOffset(nonVirtual, offset1, offset2)</a>
<a name="ln2276">		&amp;&amp; _ParseEncoding(name)</a>
<a name="ln2277">		&amp;&amp; NodeCreator&lt;SpecialNameNode&gt;(this)(</a>
<a name="ln2278">			nonVirtual ? &quot;non-virtual thunk to &quot; : &quot;virtual thunk to &quot;,</a>
<a name="ln2279">			name, _node);</a>
<a name="ln2280">}</a>
<a name="ln2281"> </a>
<a name="ln2282"> </a>
<a name="ln2283">bool</a>
<a name="ln2284">Demangler::_ParseCallOffset(bool&amp; nonVirtual, number_type&amp; offset1,</a>
<a name="ln2285">	number_type&amp; offset2)</a>
<a name="ln2286">{</a>
<a name="ln2287">	// &lt;call-offset&gt; ::= h &lt;nv-offset&gt; _</a>
<a name="ln2288">	//               ::= v &lt;v-offset&gt; _</a>
<a name="ln2289">	// &lt;nv-offset&gt; ::= &lt;offset number&gt;</a>
<a name="ln2290">	//                 # non-virtual base override</a>
<a name="ln2291">	// &lt;v-offset&gt;  ::= &lt;offset number&gt; _ &lt;virtual offset number&gt;</a>
<a name="ln2292">	//                 # virtual base override, with vcall offset</a>
<a name="ln2293"> </a>
<a name="ln2294">	// non-virtual</a>
<a name="ln2295">	if (fInput.SkipPrefix('h')) {</a>
<a name="ln2296">		nonVirtual = true;</a>
<a name="ln2297">		return _ParseNumber(offset1) &amp;&amp; _SkipExpected('_');</a>
<a name="ln2298">	}</a>
<a name="ln2299"> </a>
<a name="ln2300">	// virtual</a>
<a name="ln2301">	nonVirtual = false;</a>
<a name="ln2302">	return _SkipExpected('v')</a>
<a name="ln2303">		&amp;&amp; _ParseNumber(offset1)</a>
<a name="ln2304">		&amp;&amp; _SkipExpected('_')</a>
<a name="ln2305">		&amp;&amp; _ParseNumber(offset2)</a>
<a name="ln2306">		&amp;&amp; _SkipExpected('_');</a>
<a name="ln2307">}</a>
<a name="ln2308"> </a>
<a name="ln2309">bool</a>
<a name="ln2310">Demangler::_ParseName(Node*&amp; _node)</a>
<a name="ln2311">{</a>
<a name="ln2312">	DEBUG_SCOPE(&quot;_ParseName&quot;);</a>
<a name="ln2313"> </a>
<a name="ln2314">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln2315">		return _SetError(ERROR_INVALID);</a>
<a name="ln2316"> </a>
<a name="ln2317">	// &lt;name&gt; ::= &lt;nested-name&gt;</a>
<a name="ln2318">	//        ::= &lt;unscoped-name&gt;</a>
<a name="ln2319">	//        ::= &lt;unscoped-template-name&gt; &lt;template-args&gt;</a>
<a name="ln2320">	//        ::= &lt;local-name&gt;	# See Scope Encoding below</a>
<a name="ln2321">	//</a>
<a name="ln2322">	// &lt;unscoped-name&gt; ::= &lt;unqualified-name&gt;</a>
<a name="ln2323">	//                 ::= St &lt;unqualified-name&gt;   # ::std::</a>
<a name="ln2324">	//</a>
<a name="ln2325">	// &lt;unscoped-template-name&gt; ::= &lt;unscoped-name&gt;</a>
<a name="ln2326">	//                          ::= &lt;substitution&gt;</a>
<a name="ln2327"> </a>
<a name="ln2328">	switch (fInput[0]) {</a>
<a name="ln2329">		case 'N':</a>
<a name="ln2330">			// &lt;nested-name&gt;</a>
<a name="ln2331">			return _ParseNestedName(_node);</a>
<a name="ln2332">		case 'Z':</a>
<a name="ln2333">			// &lt;local-name&gt;</a>
<a name="ln2334">			return _ParseLocalName(_node);</a>
<a name="ln2335">		case 'S':</a>
<a name="ln2336">		{</a>
<a name="ln2337">			// &lt;substitution&gt;</a>
<a name="ln2338">			if (!fInput.HasPrefix(&quot;St&quot;)) {</a>
<a name="ln2339">				if (!_ParseSubstitution(_node))</a>
<a name="ln2340">					return false;</a>
<a name="ln2341">				break;</a>
<a name="ln2342">			}</a>
<a name="ln2343"> </a>
<a name="ln2344">			// std:: namespace</a>
<a name="ln2345">			fInput.Skip(2);</a>
<a name="ln2346"> </a>
<a name="ln2347">			Node* prefix;</a>
<a name="ln2348">			if (!NodeCreator&lt;SimpleNameNode&gt;(this)(&quot;std&quot;, prefix))</a>
<a name="ln2349">				return false;</a>
<a name="ln2350"> </a>
<a name="ln2351">			// &lt;unqualified-name&gt;</a>
<a name="ln2352">			Node* node;</a>
<a name="ln2353">			if (!_ParseUnqualifiedName(node)</a>
<a name="ln2354">				|| !NodeCreator&lt;PrefixedNode&gt;(this)(prefix, node, _node)) {</a>
<a name="ln2355">				return false;</a>
<a name="ln2356">			}</a>
<a name="ln2357"> </a>
<a name="ln2358">			break;</a>
<a name="ln2359">		}</a>
<a name="ln2360">		default:</a>
<a name="ln2361">			// &lt;unqualified-name&gt;</a>
<a name="ln2362">			if (!_ParseUnqualifiedName(_node))</a>
<a name="ln2363">				return false;</a>
<a name="ln2364">			break;</a>
<a name="ln2365">	}</a>
<a name="ln2366"> </a>
<a name="ln2367">	// We get here for the names that might be an &lt;unscoped-template-name&gt;.</a>
<a name="ln2368">	// Check whether &lt;template-args&gt; are following.</a>
<a name="ln2369">	if (!fInput.HasPrefix('I'))</a>
<a name="ln2370">		return true;</a>
<a name="ln2371"> </a>
<a name="ln2372">	// &lt;unscoped-template-name&gt; is referenceable</a>
<a name="ln2373">	_RegisterReferenceableNode(_node);</a>
<a name="ln2374"> </a>
<a name="ln2375">	return _ParseTemplateArgs(_node, _node);</a>
<a name="ln2376">}</a>
<a name="ln2377"> </a>
<a name="ln2378"> </a>
<a name="ln2379">bool</a>
<a name="ln2380">Demangler::_ParseNestedName(Node*&amp; _node)</a>
<a name="ln2381">{</a>
<a name="ln2382">	DEBUG_SCOPE(&quot;_ParseNestedName&quot;);</a>
<a name="ln2383"> </a>
<a name="ln2384">	// &lt;nested-name&gt; ::= N [&lt;CV-qualifiers&gt;] &lt;prefix&gt; &lt;unqualified-name&gt; E</a>
<a name="ln2385">	//               ::= N [&lt;CV-qualifiers&gt;] &lt;template-prefix&gt;</a>
<a name="ln2386">	//                   &lt;template-args&gt; E</a>
<a name="ln2387">	//</a>
<a name="ln2388">	// &lt;CV-qualifiers&gt; ::= [r] [V] [K] 	# restrict (C99), volatile, const</a>
<a name="ln2389">	//</a>
<a name="ln2390">	// &lt;prefix&gt; ::= &lt;prefix&gt; &lt;unqualified-name&gt;</a>
<a name="ln2391">	//          ::= &lt;template-prefix&gt; &lt;template-args&gt;</a>
<a name="ln2392">	//          ::= &lt;template-param&gt;</a>
<a name="ln2393">	//          ::= # empty</a>
<a name="ln2394">	//          ::= &lt;substitution&gt;</a>
<a name="ln2395">	//</a>
<a name="ln2396">	// &lt;template-prefix&gt; ::= &lt;prefix&gt; &lt;template unqualified-name&gt;</a>
<a name="ln2397">	//                   ::= &lt;template-param&gt;</a>
<a name="ln2398">	//                   ::= &lt;substitution&gt;</a>
<a name="ln2399"> </a>
<a name="ln2400">	if (!_SkipExpected('N'))</a>
<a name="ln2401">		return false;</a>
<a name="ln2402"> </a>
<a name="ln2403">	// parse CV qualifiers</a>
<a name="ln2404">	int qualifiers;</a>
<a name="ln2405">	_ParseCVQualifiers(qualifiers);</a>
<a name="ln2406"> </a>
<a name="ln2407">	// parse the main part</a>
<a name="ln2408">	if (!_ParseNestedNameInternal(_node))</a>
<a name="ln2409">		return false;</a>
<a name="ln2410"> </a>
<a name="ln2411">	// create a CV qualifiers wrapper node, if necessary</a>
<a name="ln2412">	if (qualifiers != 0) {</a>
<a name="ln2413">		return NodeCreator&lt;CVQualifiersNode&gt;(this)(qualifiers, _node,</a>
<a name="ln2414">			_node);</a>
<a name="ln2415">	}</a>
<a name="ln2416"> </a>
<a name="ln2417">	return true;</a>
<a name="ln2418">}</a>
<a name="ln2419"> </a>
<a name="ln2420"> </a>
<a name="ln2421">bool</a>
<a name="ln2422">Demangler::_ParseNestedNameInternal(Node*&amp; _node)</a>
<a name="ln2423">{</a>
<a name="ln2424">	DEBUG_SCOPE(&quot;_ParseNestedNameMain&quot;);</a>
<a name="ln2425"> </a>
<a name="ln2426">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln2427">		return _SetError(ERROR_INVALID);</a>
<a name="ln2428"> </a>
<a name="ln2429">	// the initial prefix might be a template param or a substitution</a>
<a name="ln2430">	Node* initialPrefixNode = NULL;</a>
<a name="ln2431">	Node* prefixNode = NULL;</a>
<a name="ln2432">	switch (fInput[0]) {</a>
<a name="ln2433">		case 'T':	// &lt;template-param&gt;</a>
<a name="ln2434">			if (!_ParseTemplateParam(initialPrefixNode))</a>
<a name="ln2435">				return false;</a>
<a name="ln2436"> </a>
<a name="ln2437">			// a &lt;prefix&gt; or &lt;template-prefix&gt; and as such referenceable</a>
<a name="ln2438">			_RegisterReferenceableNode(initialPrefixNode);</a>
<a name="ln2439">			break;</a>
<a name="ln2440"> </a>
<a name="ln2441">		case 'S':	// &lt;substitution&gt;</a>
<a name="ln2442">			if (!_ParseSubstitution(initialPrefixNode))</a>
<a name="ln2443">				return false;</a>
<a name="ln2444">			break;</a>
<a name="ln2445">	}</a>
<a name="ln2446"> </a>
<a name="ln2447">	while (true) {</a>
<a name="ln2448">		bool canTerminate = false;</a>
<a name="ln2449">		Node* node;</a>
<a name="ln2450"> </a>
<a name="ln2451">		if (initialPrefixNode != NULL) {</a>
<a name="ln2452">			node = initialPrefixNode;</a>
<a name="ln2453">			initialPrefixNode = NULL;</a>
<a name="ln2454">		} else {</a>
<a name="ln2455">			if (!_ParseUnqualifiedName(node))</a>
<a name="ln2456">				return false;</a>
<a name="ln2457">			canTerminate = true;</a>
<a name="ln2458">		}</a>
<a name="ln2459"> </a>
<a name="ln2460">		// join prefix and the new node</a>
<a name="ln2461">		if (prefixNode != NULL) {</a>
<a name="ln2462">			if (!NodeCreator&lt;PrefixedNode&gt;(this)(prefixNode, node, node))</a>
<a name="ln2463">				return false;</a>
<a name="ln2464">		}</a>
<a name="ln2465"> </a>
<a name="ln2466">		// template arguments?</a>
<a name="ln2467">		if (fInput.HasPrefix('I')) {</a>
<a name="ln2468">			// &lt;template-prefix&gt; is referenceable</a>
<a name="ln2469">			_RegisterReferenceableNode(node);</a>
<a name="ln2470"> </a>
<a name="ln2471">			// parse the template arguments</a>
<a name="ln2472">			if (!_ParseTemplateArgs(node, node))</a>
<a name="ln2473">				return false;</a>
<a name="ln2474">			canTerminate = true;</a>
<a name="ln2475">		}</a>
<a name="ln2476"> </a>
<a name="ln2477">		if (fInput.CharsRemaining() == 0)</a>
<a name="ln2478">			return _SetError(ERROR_INVALID);</a>
<a name="ln2479"> </a>
<a name="ln2480">		// end of nested name?</a>
<a name="ln2481">		if (fInput.SkipPrefix('E')) {</a>
<a name="ln2482">			// If it doesn't have template args, it must end in an</a>
<a name="ln2483">			// unqualified name.</a>
<a name="ln2484">			if (!canTerminate)</a>
<a name="ln2485">				return _SetError(ERROR_INVALID);</a>
<a name="ln2486"> </a>
<a name="ln2487">			_node = node;</a>
<a name="ln2488">			return true;</a>
<a name="ln2489">		}</a>
<a name="ln2490"> </a>
<a name="ln2491">		// The fun continues, so this is a &lt;prefix&gt; or &lt;template-prefix&gt;</a>
<a name="ln2492">		// and as such referenceable.</a>
<a name="ln2493">		prefixNode = node;</a>
<a name="ln2494">		_RegisterReferenceableNode(node);</a>
<a name="ln2495">	}</a>
<a name="ln2496">}</a>
<a name="ln2497"> </a>
<a name="ln2498"> </a>
<a name="ln2499">bool</a>
<a name="ln2500">Demangler::_ParseLocalName(Node*&amp; _node)</a>
<a name="ln2501">{</a>
<a name="ln2502">	DEBUG_SCOPE(&quot;_ParseLocalName&quot;);</a>
<a name="ln2503"> </a>
<a name="ln2504">	// &lt;local-name&gt; := Z &lt;function encoding&gt; E &lt;entity name&gt;</a>
<a name="ln2505">	//                 [&lt;discriminator&gt;]</a>
<a name="ln2506">	//              := Z &lt;function encoding&gt; E s [&lt;discriminator&gt;]</a>
<a name="ln2507">	// &lt;discriminator&gt; := _ &lt;non-negative number&gt;</a>
<a name="ln2508"> </a>
<a name="ln2509">	// parse the function name</a>
<a name="ln2510">	ObjectNode* functionName;</a>
<a name="ln2511">	if (!_SkipExpected('Z')</a>
<a name="ln2512">		|| !_ParseEncoding(functionName)</a>
<a name="ln2513">		|| !_SkipExpected('E')) {</a>
<a name="ln2514">		return false;</a>
<a name="ln2515">	}</a>
<a name="ln2516"> </a>
<a name="ln2517">	Node* entityName;</a>
<a name="ln2518">	if (fInput.SkipPrefix('s')) {</a>
<a name="ln2519">		// string literal</a>
<a name="ln2520">		if (!NodeCreator&lt;SimpleNameNode&gt;(this)(&quot;string literal&quot;,</a>
<a name="ln2521">				entityName)) {</a>
<a name="ln2522">			return false;</a>
<a name="ln2523">		}</a>
<a name="ln2524">	} else {</a>
<a name="ln2525">		// local type or object</a>
<a name="ln2526">		if (!_ParseName(entityName))</a>
<a name="ln2527">			return false;</a>
<a name="ln2528">	}</a>
<a name="ln2529"> </a>
<a name="ln2530">	// parse discriminator</a>
<a name="ln2531">	number_type discriminator = 0;</a>
<a name="ln2532">	if (fInput.SkipPrefix('_')) {</a>
<a name="ln2533">		if (!_ParseNumber(discriminator))</a>
<a name="ln2534">			return false;</a>
<a name="ln2535">		if (discriminator &lt; 0)</a>
<a name="ln2536">			return _SetError(ERROR_INVALID);</a>
<a name="ln2537">		discriminator++;</a>
<a name="ln2538">	}</a>
<a name="ln2539"> </a>
<a name="ln2540">	return NodeCreator&lt;PrefixedNode&gt;(this)(functionName, entityName, _node);</a>
<a name="ln2541">}</a>
<a name="ln2542"> </a>
<a name="ln2543"> </a>
<a name="ln2544">bool</a>
<a name="ln2545">Demangler::_ParseUnqualifiedName(Node*&amp; _node)</a>
<a name="ln2546">{</a>
<a name="ln2547">	DEBUG_SCOPE(&quot;_ParseUnqualifiedName&quot;);</a>
<a name="ln2548"> </a>
<a name="ln2549">	// &lt;unqualified-name&gt; ::= &lt;operator-name&gt;</a>
<a name="ln2550">	//                    ::= &lt;ctor-dtor-name&gt;</a>
<a name="ln2551">	//                    ::= &lt;source-name&gt;</a>
<a name="ln2552">	//</a>
<a name="ln2553">	// &lt;source-name&gt; ::= &lt;positive length number&gt; &lt;identifier&gt;</a>
<a name="ln2554">	// &lt;number&gt; ::= [n] &lt;non-negative decimal integer&gt;</a>
<a name="ln2555">	// &lt;identifier&gt; ::= &lt;unqualified source code identifier&gt;</a>
<a name="ln2556">	//</a>
<a name="ln2557">	// &lt;ctor-dtor-name&gt; ::= C1	# complete object constructor</a>
<a name="ln2558">	//                  ::= C2	# base object constructor</a>
<a name="ln2559">	//                  ::= C3	# complete object allocating constructor</a>
<a name="ln2560">	//                  ::= D0	# deleting destructor</a>
<a name="ln2561">	//                  ::= D1	# complete object destructor</a>
<a name="ln2562">	//                  ::= D2	# base object destructor</a>
<a name="ln2563"> </a>
<a name="ln2564">	// we need at least 2 chars</a>
<a name="ln2565">	if (fInput.CharsRemaining() &lt; 2)</a>
<a name="ln2566">		return _SetError(ERROR_INVALID);</a>
<a name="ln2567"> </a>
<a name="ln2568">	if (isdigit(fInput[0]) || (fInput[0] == 'n' &amp;&amp; isdigit(fInput[1]))) {</a>
<a name="ln2569">		// &lt;source-name&gt;</a>
<a name="ln2570">		return _ParseSourceName(_node);</a>
<a name="ln2571">	}</a>
<a name="ln2572"> </a>
<a name="ln2573">	if (fInput[0] == 'C') {</a>
<a name="ln2574">		// &lt;ctor-dtor-name&gt; -- constructors</a>
<a name="ln2575">		switch (fInput[1]) {</a>
<a name="ln2576">			case '1':</a>
<a name="ln2577">			case '2':</a>
<a name="ln2578">			case '3':</a>
<a name="ln2579">				if (!NodeCreator&lt;XtructorNode&gt;(this)(true, fInput[1] - '1',</a>
<a name="ln2580">						_node)) {</a>
<a name="ln2581">					return false;</a>
<a name="ln2582">				}</a>
<a name="ln2583"> </a>
<a name="ln2584">				fInput.Skip(2);</a>
<a name="ln2585">				return true;</a>
<a name="ln2586">			default:</a>
<a name="ln2587">				return _SetError(ERROR_INVALID);</a>
<a name="ln2588">		}</a>
<a name="ln2589">	}</a>
<a name="ln2590"> </a>
<a name="ln2591">	if (fInput[0] == 'D') {</a>
<a name="ln2592">		// &lt;ctor-dtor-name&gt; -- destructors</a>
<a name="ln2593">		switch (fInput[1]) {</a>
<a name="ln2594">			case '0':</a>
<a name="ln2595">			case '1':</a>
<a name="ln2596">			case '2':</a>
<a name="ln2597">				if (!NodeCreator&lt;XtructorNode&gt;(this)(false, fInput[1] - '0',</a>
<a name="ln2598">						_node)) {</a>
<a name="ln2599">					return false;</a>
<a name="ln2600">				}</a>
<a name="ln2601"> </a>
<a name="ln2602">				fInput.Skip(2);</a>
<a name="ln2603">				return true;</a>
<a name="ln2604">			default:</a>
<a name="ln2605">				return _SetError(ERROR_INVALID);</a>
<a name="ln2606">		}</a>
<a name="ln2607">	}</a>
<a name="ln2608"> </a>
<a name="ln2609">	// must be an &lt;operator-name&gt;</a>
<a name="ln2610">	return _ParseOperatorName(_node);</a>
<a name="ln2611">}</a>
<a name="ln2612"> </a>
<a name="ln2613"> </a>
<a name="ln2614">bool</a>
<a name="ln2615">Demangler::_ParseSourceName(Node*&amp; _node)</a>
<a name="ln2616">{</a>
<a name="ln2617">	DEBUG_SCOPE(&quot;_ParseSourceName&quot;);</a>
<a name="ln2618"> </a>
<a name="ln2619">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln2620">		return _SetError(ERROR_INVALID);</a>
<a name="ln2621"> </a>
<a name="ln2622">	number_type number;</a>
<a name="ln2623">	if (!_ParseNumber(number))</a>
<a name="ln2624">		return false;</a>
<a name="ln2625"> </a>
<a name="ln2626">	if (number &lt;= 0 || number &gt; fInput.CharsRemaining())</a>
<a name="ln2627">		return _SetError(ERROR_INVALID);</a>
<a name="ln2628"> </a>
<a name="ln2629">	return _CreateNodeAndSkip(fInput.String(), number, number, _node);</a>
<a name="ln2630">}</a>
<a name="ln2631"> </a>
<a name="ln2632"> </a>
<a name="ln2633">bool</a>
<a name="ln2634">Demangler::_ParseOperatorName(Node*&amp; _node)</a>
<a name="ln2635">{</a>
<a name="ln2636">	DEBUG_SCOPE(&quot;_ParseOperatorName&quot;);</a>
<a name="ln2637"> </a>
<a name="ln2638">	if (fInput.CharsRemaining() &lt; 2)</a>
<a name="ln2639">		return _SetError(ERROR_INVALID);</a>
<a name="ln2640"> </a>
<a name="ln2641">	const operator_info* info = NULL;</a>
<a name="ln2642">	for (int i = 0; kOperatorInfos[i].name != NULL; i++) {</a>
<a name="ln2643">		if (fInput.SkipPrefix(kOperatorInfos[i].mangled_name)) {</a>
<a name="ln2644">			info = &amp;kOperatorInfos[i];</a>
<a name="ln2645">			break;</a>
<a name="ln2646">		}</a>
<a name="ln2647">	}</a>
<a name="ln2648"> </a>
<a name="ln2649">	if (info != NULL)</a>
<a name="ln2650">		return NodeCreator&lt;OperatorNode&gt;(this)(info, _node);</a>
<a name="ln2651"> </a>
<a name="ln2652">	// &lt;operator-name&gt; ::= cv &lt;type&gt;	# (cast)</a>
<a name="ln2653">	if (fInput.SkipPrefix(&quot;cv&quot;)) {</a>
<a name="ln2654">		Node* typeNode;</a>
<a name="ln2655">		if (!_ParseType(typeNode))</a>
<a name="ln2656">			return false;</a>
<a name="ln2657"> </a>
<a name="ln2658">		return NodeCreator&lt;CastOperatorNode&gt;(this)(typeNode, _node);</a>
<a name="ln2659">	}</a>
<a name="ln2660"> </a>
<a name="ln2661">	//  &lt;operator-name&gt; ::= v &lt;digit&gt; &lt;source-name&gt;	# vendor extended</a>
<a name="ln2662">	//                                                operator</a>
<a name="ln2663">	if (fInput.SkipPrefix('v')) {</a>
<a name="ln2664">		if (fInput.CharsRemaining() == 0 || !isdigit(fInput[0]))</a>
<a name="ln2665">			return _SetError(ERROR_INVALID);</a>
<a name="ln2666">		fInput.Skip(1);</a>
<a name="ln2667"> </a>
<a name="ln2668">		Node* name;</a>
<a name="ln2669">		return _ParseSourceName(name)</a>
<a name="ln2670">			&amp;&amp; NodeCreator&lt;VendorOperatorNode&gt;(this)(name, _node);</a>
<a name="ln2671">	}</a>
<a name="ln2672"> </a>
<a name="ln2673">	return _SetError(ERROR_INVALID);</a>
<a name="ln2674">}</a>
<a name="ln2675"> </a>
<a name="ln2676"> </a>
<a name="ln2677">bool</a>
<a name="ln2678">Demangler::_ParseType(Node*&amp; _node)</a>
<a name="ln2679">{</a>
<a name="ln2680">	DEBUG_SCOPE(&quot;_ParseType&quot;);</a>
<a name="ln2681"> </a>
<a name="ln2682">	if (!_ParseTypeInternal(_node))</a>
<a name="ln2683">		return false;</a>
<a name="ln2684"> </a>
<a name="ln2685">	_RegisterReferenceableNode(_node);</a>
<a name="ln2686">	return true;</a>
<a name="ln2687">}</a>
<a name="ln2688"> </a>
<a name="ln2689"> </a>
<a name="ln2690">bool</a>
<a name="ln2691">Demangler::_ParseTypeInternal(Node*&amp; _node)</a>
<a name="ln2692">{</a>
<a name="ln2693">	DEBUG_SCOPE(&quot;_ParseTypeInternal&quot;);</a>
<a name="ln2694"> </a>
<a name="ln2695">	// &lt;type&gt; ::= &lt;builtin-type&gt;</a>
<a name="ln2696">	//        ::= &lt;function-type&gt;</a>
<a name="ln2697">	//        ::= &lt;class-enum-type&gt;</a>
<a name="ln2698">	//        ::= &lt;array-type&gt;</a>
<a name="ln2699">	//        ::= &lt;pointer-to-member-type&gt;</a>
<a name="ln2700">	//        ::= &lt;template-param&gt;</a>
<a name="ln2701">	//        ::= &lt;template-template-param&gt; &lt;template-args&gt;</a>
<a name="ln2702">	//        ::= &lt;substitution&gt; # See Compression below</a>
<a name="ln2703">	//</a>
<a name="ln2704">	// &lt;template-template-param&gt; ::= &lt;template-param&gt;</a>
<a name="ln2705">	//                           ::= &lt;substitution&gt;</a>
<a name="ln2706">	//</a>
<a name="ln2707">	// &lt;type&gt; ::= &lt;CV-qualifiers&gt; &lt;type&gt;</a>
<a name="ln2708">	//        ::= P &lt;type&gt;	# pointer-to</a>
<a name="ln2709">	//        ::= R &lt;type&gt;	# reference-to</a>
<a name="ln2710">	//        ::= O &lt;type&gt;	# rvalue reference-to (C++0x)</a>
<a name="ln2711">	//        ::= C &lt;type&gt;	# complex pair (C 2000)</a>
<a name="ln2712">	//        ::= G &lt;type&gt;	# imaginary (C 2000)</a>
<a name="ln2713">	//        ::= U &lt;source-name&gt; &lt;type&gt;	# vendor extended type qualifier</a>
<a name="ln2714">	//</a>
<a name="ln2715">	// &lt;CV-qualifiers&gt; ::= [r] [V] [K] 	# restrict (C99), volatile, const</a>
<a name="ln2716">	//</a>
<a name="ln2717">	// &lt;type&gt;  ::= Dp &lt;type&gt;          # pack expansion of (C++0x)</a>
<a name="ln2718">	//         ::= Dt &lt;expression&gt; E  # decltype of an id-expression or</a>
<a name="ln2719">	//                                # class member access (C++0x)</a>
<a name="ln2720">	//         ::= DT &lt;expression&gt; E  # decltype of an expression (C++0x)</a>
<a name="ln2721"> </a>
<a name="ln2722">	if (_TryParseBuiltinType(_node)) {</a>
<a name="ln2723">		_node-&gt;SetReferenceable(false);</a>
<a name="ln2724">		return true;</a>
<a name="ln2725">	}</a>
<a name="ln2726">	if (fError != ERROR_OK)</a>
<a name="ln2727">		return false;</a>
<a name="ln2728"> </a>
<a name="ln2729">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln2730">		return _SetError(ERROR_INVALID);</a>
<a name="ln2731"> </a>
<a name="ln2732">	switch (fInput[0]) {</a>
<a name="ln2733">		// function type</a>
<a name="ln2734">		case 'F':</a>
<a name="ln2735">		{</a>
<a name="ln2736">			FunctionNode* functionNode;</a>
<a name="ln2737">			if (!_ParseFunctionType(functionNode))</a>
<a name="ln2738">				return false;</a>
<a name="ln2739">			_node = functionNode;</a>
<a name="ln2740">			return true;</a>
<a name="ln2741">		}</a>
<a name="ln2742"> </a>
<a name="ln2743">		// array type</a>
<a name="ln2744">		case 'A':</a>
<a name="ln2745">			return _ParseArrayType(_node);</a>
<a name="ln2746"> </a>
<a name="ln2747">		// pointer to member type</a>
<a name="ln2748">		case 'M':</a>
<a name="ln2749">			return _ParsePointerToMemberType(_node);</a>
<a name="ln2750"> </a>
<a name="ln2751">		// template param</a>
<a name="ln2752">		case 'T':</a>
<a name="ln2753">			if (!_ParseTemplateParam(_node))</a>
<a name="ln2754">				return false;</a>
<a name="ln2755">			break;</a>
<a name="ln2756"> </a>
<a name="ln2757">		// CV qualifiers</a>
<a name="ln2758">		case 'r':</a>
<a name="ln2759">		case 'V':</a>
<a name="ln2760">		case 'K':</a>
<a name="ln2761">		{</a>
<a name="ln2762">			// parse CV qualifiers</a>
<a name="ln2763">			int qualifiers;</a>
<a name="ln2764">			_ParseCVQualifiers(qualifiers);</a>
<a name="ln2765"> </a>
<a name="ln2766">			// parse the type</a>
<a name="ln2767">			if (!_ParseType(_node))</a>
<a name="ln2768">				return false;</a>
<a name="ln2769"> </a>
<a name="ln2770">			// create the wrapper node</a>
<a name="ln2771">			return NodeCreator&lt;CVQualifiersNode&gt;(this)(qualifiers, _node,</a>
<a name="ln2772">				_node);</a>
<a name="ln2773">		}</a>
<a name="ln2774"> </a>
<a name="ln2775">		// pointer, reference, etc.</a>
<a name="ln2776">		case 'P':</a>
<a name="ln2777">			return _ParseTypeWithModifier(TYPE_QUALIFIER_POINTER, 1, _node);</a>
<a name="ln2778">		case 'R':</a>
<a name="ln2779">			return _ParseTypeWithModifier(TYPE_QUALIFIER_REFERENCE, 1,</a>
<a name="ln2780">				_node);</a>
<a name="ln2781">		case 'O':</a>
<a name="ln2782">			return _ParseTypeWithModifier(</a>
<a name="ln2783">				TYPE_QUALIFIER_RVALUE_REFERENCE, 1, _node);</a>
<a name="ln2784">		case 'C':</a>
<a name="ln2785">			return _ParseTypeWithModifier(TYPE_QUALIFIER_COMPLEX, 1, _node);</a>
<a name="ln2786">		case 'G':</a>
<a name="ln2787">			return _ParseTypeWithModifier(TYPE_QUALIFIER_IMAGINARY, 1,</a>
<a name="ln2788">				_node);</a>
<a name="ln2789"> </a>
<a name="ln2790">		// pack and decltype</a>
<a name="ln2791">		case 'D':</a>
<a name="ln2792">#if 0</a>
<a name="ln2793">			if (fInput.CharsRemaining() &lt; 2)</a>
<a name="ln2794">				return _SetError(ERROR_INVALID);</a>
<a name="ln2795"> </a>
<a name="ln2796">			switch(fInput[1]) {</a>
<a name="ln2797">				case 'p':</a>
<a name="ln2798">					fInput.Skip(2);</a>
<a name="ln2799">					return _ParseType(_node);</a>
<a name="ln2800">				case 't':</a>
<a name="ln2801">				case 'T':</a>
<a name="ln2802">				{</a>
<a name="ln2803">					fInput.Skip(2);</a>
<a name="ln2804">					Node* nameNode;</a>
<a name="ln2805">					if (!_ParseExpression(nameNode))</a>
<a name="ln2806">						return false;</a>
<a name="ln2807">					if (!fInput.SkipPrefix('E'))</a>
<a name="ln2808">						return ERROR_INVALID;</a>
<a name="ln2809">				}</a>
<a name="ln2810">			}</a>
<a name="ln2811">#endif</a>
<a name="ln2812">			// NOTE: Unsupported by the GNU demangler.</a>
<a name="ln2813">			return _SetError(ERROR_UNSUPPORTED);</a>
<a name="ln2814"> </a>
<a name="ln2815">		// vendor extended type qualifier</a>
<a name="ln2816">		case 'U':</a>
<a name="ln2817">			fInput.Skip(1);</a>
<a name="ln2818">			Node* name;</a>
<a name="ln2819">			Node* type;</a>
<a name="ln2820">			return _ParseSourceName(name) &amp;&amp; _ParseType(type)</a>
<a name="ln2821">				&amp;&amp; NodeCreator&lt;VendorTypeModifierNode&gt;(this)(name, type,</a>
<a name="ln2822">					_node);</a>
<a name="ln2823"> </a>
<a name="ln2824">		// substitution</a>
<a name="ln2825">		case 'S':</a>
<a name="ln2826">			if (!fInput.HasPrefix(&quot;St&quot;)) {</a>
<a name="ln2827">				if (!_ParseSubstitution(_node))</a>
<a name="ln2828">					return false;</a>
<a name="ln2829">				break;</a>
<a name="ln2830">			}</a>
<a name="ln2831"> </a>
<a name="ln2832">			// &quot;St&quot; -- the &quot;std&quot; namespace. The grammar is ambiguous here,</a>
<a name="ln2833">			// since we could parse that as &lt;substitution&gt; or as</a>
<a name="ln2834">			// &lt;class-enum-type&gt;. We assume the latter and fall through.</a>
<a name="ln2835"> </a>
<a name="ln2836">		default:</a>
<a name="ln2837">		{</a>
<a name="ln2838">			// &lt;class-enum-type&gt; ::= &lt;name&gt;</a>
<a name="ln2839">			Node* nameNode;</a>
<a name="ln2840">			return _ParseName(nameNode)</a>
<a name="ln2841">				&amp;&amp; NodeCreator&lt;NamedTypeNode&gt;(this)(nameNode, _node);</a>
<a name="ln2842">		}</a>
<a name="ln2843">	}</a>
<a name="ln2844"> </a>
<a name="ln2845">	// We get here for the types that might be a &lt;template-template-param&gt;.</a>
<a name="ln2846">	// Check whether &lt;template-args&gt; are following.</a>
<a name="ln2847">	if (!fInput.HasPrefix('I'))</a>
<a name="ln2848">		return true;</a>
<a name="ln2849"> </a>
<a name="ln2850">	// &lt;template-template-param&gt; is referenceable</a>
<a name="ln2851">	_RegisterReferenceableNode(_node);</a>
<a name="ln2852"> </a>
<a name="ln2853">	return _ParseTemplateArgs(_node, _node);</a>
<a name="ln2854">}</a>
<a name="ln2855"> </a>
<a name="ln2856"> </a>
<a name="ln2857">void</a>
<a name="ln2858">Demangler::_ParseCVQualifiers(int&amp; qualifiers)</a>
<a name="ln2859">{</a>
<a name="ln2860">	qualifiers = 0;</a>
<a name="ln2861"> </a>
<a name="ln2862">	if (fInput.SkipPrefix('r'))</a>
<a name="ln2863">		qualifiers |= CV_QUALIFIER_RESTRICT;</a>
<a name="ln2864">	if (fInput.SkipPrefix('V'))</a>
<a name="ln2865">		qualifiers |= CV_QUALIFIER_VOLATILE;</a>
<a name="ln2866">	if (fInput.SkipPrefix('K'))</a>
<a name="ln2867">		qualifiers |= CV_QUALIFIER_CONST;</a>
<a name="ln2868">}</a>
<a name="ln2869"> </a>
<a name="ln2870"> </a>
<a name="ln2871">bool</a>
<a name="ln2872">Demangler::_ParseTypeWithModifier(type_modifier modifier, int toSkip,</a>
<a name="ln2873">	Node*&amp; _node)</a>
<a name="ln2874">{</a>
<a name="ln2875">	if (toSkip &gt; 0)</a>
<a name="ln2876">		fInput.Skip(toSkip);</a>
<a name="ln2877"> </a>
<a name="ln2878">	Node* node;</a>
<a name="ln2879">	if (!_ParseType(node))</a>
<a name="ln2880">		return false;</a>
<a name="ln2881"> </a>
<a name="ln2882">	return NodeCreator&lt;TypeModifierNode&gt;(this)(modifier, node, _node);</a>
<a name="ln2883">}</a>
<a name="ln2884"> </a>
<a name="ln2885"> </a>
<a name="ln2886">bool</a>
<a name="ln2887">Demangler::_TryParseBuiltinType(Node*&amp; _node)</a>
<a name="ln2888">{</a>
<a name="ln2889">	DEBUG_SCOPE(&quot;_TryParseBuiltinType&quot;);</a>
<a name="ln2890"> </a>
<a name="ln2891">	// &lt;builtin-type&gt; ::= v	# void</a>
<a name="ln2892">	//                ::= w	# wchar_t</a>
<a name="ln2893">	//                ::= b	# bool</a>
<a name="ln2894">	//                ::= c	# char</a>
<a name="ln2895">	//                ::= a	# signed char</a>
<a name="ln2896">	//                ::= h	# unsigned char</a>
<a name="ln2897">	//                ::= s	# short</a>
<a name="ln2898">	//                ::= t	# unsigned short</a>
<a name="ln2899">	//                ::= i	# int</a>
<a name="ln2900">	//                ::= j	# unsigned int</a>
<a name="ln2901">	//                ::= l	# long</a>
<a name="ln2902">	//                ::= m	# unsigned long</a>
<a name="ln2903">	//                ::= x	# long long, __int64</a>
<a name="ln2904">	//                ::= y	# unsigned long long, __int64</a>
<a name="ln2905">	//                ::= n	# __int128</a>
<a name="ln2906">	//                ::= o	# unsigned __int128</a>
<a name="ln2907">	//                ::= f	# float</a>
<a name="ln2908">	//                ::= d	# double</a>
<a name="ln2909">	//                ::= e	# long double, __float80</a>
<a name="ln2910">	//                ::= g	# __float128</a>
<a name="ln2911">	//                ::= z	# ellipsis</a>
<a name="ln2912">	//                ::= Dd # IEEE 754r decimal floating point (64 bits)</a>
<a name="ln2913">	//                ::= De # IEEE 754r decimal floating point (128 bits)</a>
<a name="ln2914">	//                ::= Df # IEEE 754r decimal floating point (32 bits)</a>
<a name="ln2915">	//                ::= Dh # IEEE 754r half-precision floating point</a>
<a name="ln2916">	//                       # (16 bits)</a>
<a name="ln2917">	//                ::= Di # char32_t</a>
<a name="ln2918">	//                ::= Ds # char16_t</a>
<a name="ln2919">	//                ::= u &lt;source-name&gt;	# vendor extended type</a>
<a name="ln2920"> </a>
<a name="ln2921">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln2922">		return false;</a>
<a name="ln2923"> </a>
<a name="ln2924">	switch (fInput[0]) {</a>
<a name="ln2925">		case 'v':</a>
<a name="ln2926">			return _CreateTypeNodeAndSkip(TYPE_VOID, 1, _node);</a>
<a name="ln2927">		case 'w':</a>
<a name="ln2928">			return _CreateTypeNodeAndSkip(TYPE_WCHAR_T, 1, _node);</a>
<a name="ln2929">		case 'b':</a>
<a name="ln2930">			return _CreateTypeNodeAndSkip(TYPE_BOOL, 1, _node);</a>
<a name="ln2931">		case 'c':</a>
<a name="ln2932">			return _CreateTypeNodeAndSkip(TYPE_CHAR, 1, _node);</a>
<a name="ln2933">		case 'a':</a>
<a name="ln2934">			return _CreateTypeNodeAndSkip(TYPE_SIGNED_CHAR, 1, _node);</a>
<a name="ln2935">		case 'h':</a>
<a name="ln2936">			return _CreateTypeNodeAndSkip(TYPE_UNSIGNED_CHAR, 1, _node);</a>
<a name="ln2937">		case 's':</a>
<a name="ln2938">			return _CreateTypeNodeAndSkip(TYPE_SHORT, 1, _node);</a>
<a name="ln2939">		case 't':</a>
<a name="ln2940">			return _CreateTypeNodeAndSkip(TYPE_UNSIGNED_SHORT, 1,</a>
<a name="ln2941">				_node);</a>
<a name="ln2942">		case 'i':</a>
<a name="ln2943">			return _CreateTypeNodeAndSkip(TYPE_INT, 1, _node);</a>
<a name="ln2944">		case 'j':</a>
<a name="ln2945">			return _CreateTypeNodeAndSkip(TYPE_UNSIGNED_INT, 1, _node);</a>
<a name="ln2946">		case 'l':</a>
<a name="ln2947">			return _CreateTypeNodeAndSkip(TYPE_LONG, 1, _node);</a>
<a name="ln2948">		case 'm':</a>
<a name="ln2949">			return _CreateTypeNodeAndSkip(TYPE_UNSIGNED_LONG, 1, _node);</a>
<a name="ln2950">		case 'x':</a>
<a name="ln2951">			return _CreateTypeNodeAndSkip(TYPE_LONG_LONG, 1, _node);</a>
<a name="ln2952">		case 'y':</a>
<a name="ln2953">			return _CreateTypeNodeAndSkip(TYPE_UNSIGNED_LONG_LONG, 1, _node);</a>
<a name="ln2954">		case 'n':</a>
<a name="ln2955">			return _CreateTypeNodeAndSkip(TYPE_INT128, 1, _node);</a>
<a name="ln2956">		case 'o':</a>
<a name="ln2957">			return _CreateTypeNodeAndSkip(TYPE_UNSIGNED_INT128, 1, _node);</a>
<a name="ln2958">		case 'f':</a>
<a name="ln2959">			return _CreateTypeNodeAndSkip(TYPE_FLOAT, 1, _node);</a>
<a name="ln2960">		case 'd':</a>
<a name="ln2961">			return _CreateTypeNodeAndSkip(TYPE_DOUBLE, 1, _node);</a>
<a name="ln2962">		case 'e':</a>
<a name="ln2963">			return _CreateTypeNodeAndSkip(TYPE_LONG_DOUBLE, 1, _node);</a>
<a name="ln2964">		case 'g':</a>
<a name="ln2965">			return _CreateTypeNodeAndSkip(TYPE_FLOAT128, 1, _node);</a>
<a name="ln2966">		case 'z':</a>
<a name="ln2967">			return _CreateTypeNodeAndSkip(TYPE_ELLIPSIS, 1, _node);</a>
<a name="ln2968"> </a>
<a name="ln2969">		case 'D':</a>
<a name="ln2970">			if (fInput.CharsRemaining() &lt; 2)</a>
<a name="ln2971">				return false;</a>
<a name="ln2972"> </a>
<a name="ln2973">			// TODO: Official names for the __dfloat*!</a>
<a name="ln2974">			switch (fInput[1]) {</a>
<a name="ln2975">				case 'd':</a>
<a name="ln2976">					return _CreateTypeNodeAndSkip(TYPE_DFLOAT64, 2, _node);</a>
<a name="ln2977">				case 'e':</a>
<a name="ln2978">					return _CreateTypeNodeAndSkip(TYPE_DFLOAT128, 2, _node);</a>
<a name="ln2979">				case 'f':</a>
<a name="ln2980">					return _CreateTypeNodeAndSkip(TYPE_DFLOAT32, 2, _node);</a>
<a name="ln2981">				case 'h':</a>
<a name="ln2982">					return _CreateTypeNodeAndSkip(TYPE_DFLOAT16, 2, _node);</a>
<a name="ln2983">				case 'i':</a>
<a name="ln2984">					return _CreateTypeNodeAndSkip(TYPE_CHAR16_T, 2, _node);</a>
<a name="ln2985">				case 's':</a>
<a name="ln2986">					return _CreateTypeNodeAndSkip(TYPE_CHAR32_T, 2, _node);</a>
<a name="ln2987">				default:</a>
<a name="ln2988">					return false;</a>
<a name="ln2989">			}</a>
<a name="ln2990"> </a>
<a name="ln2991">		case 'u':</a>
<a name="ln2992">		{</a>
<a name="ln2993">			fInput.Skip(1);</a>
<a name="ln2994">			Node* nameNode;</a>
<a name="ln2995">			return _ParseSourceName(nameNode)</a>
<a name="ln2996">				&amp;&amp; NodeCreator&lt;NamedTypeNode&gt;(this)(nameNode, _node);</a>
<a name="ln2997">		}</a>
<a name="ln2998"> </a>
<a name="ln2999">		default:</a>
<a name="ln3000">			return false;</a>
<a name="ln3001">	}</a>
<a name="ln3002">}</a>
<a name="ln3003"> </a>
<a name="ln3004"> </a>
<a name="ln3005">bool</a>
<a name="ln3006">Demangler::_ParseFunctionType(FunctionNode*&amp; _node)</a>
<a name="ln3007">{</a>
<a name="ln3008">	DEBUG_SCOPE(&quot;_ParseFunctionType&quot;);</a>
<a name="ln3009"> </a>
<a name="ln3010">	// &lt;function-type&gt; ::= F [Y] &lt;bare-function-type&gt; E</a>
<a name="ln3011"> </a>
<a name="ln3012">	if (!_SkipExpected('F'))</a>
<a name="ln3013">		return false;</a>
<a name="ln3014"> </a>
<a name="ln3015">	// is 'extern &quot;C&quot;'?</a>
<a name="ln3016">	bool isExternC = fInput.SkipPrefix('Y');</a>
<a name="ln3017"> </a>
<a name="ln3018">	// create function and parse function type</a>
<a name="ln3019">	if (!NodeCreator&lt;FunctionNode&gt;(this)((Node*)NULL, true, isExternC,</a>
<a name="ln3020">			_node)</a>
<a name="ln3021">		|| !_ParseBareFunctionType(_node)) {</a>
<a name="ln3022">		return false;</a>
<a name="ln3023">	}</a>
<a name="ln3024"> </a>
<a name="ln3025">	// skip terminating 'E'</a>
<a name="ln3026">	return _SkipExpected('E');</a>
<a name="ln3027">}</a>
<a name="ln3028"> </a>
<a name="ln3029"> </a>
<a name="ln3030">bool</a>
<a name="ln3031">Demangler::_ParseArrayType(Node*&amp; _node)</a>
<a name="ln3032">{</a>
<a name="ln3033">	DEBUG_SCOPE(&quot;_ParseArrayType&quot;);</a>
<a name="ln3034"> </a>
<a name="ln3035">	// &lt;array-type&gt; ::= A &lt;positive dimension number&gt; _ &lt;element type&gt;</a>
<a name="ln3036">	//              ::= A [&lt;dimension expression&gt;] _ &lt;element type&gt;</a>
<a name="ln3037"> </a>
<a name="ln3038">	if (fInput.CharsRemaining() &lt; 2 || !fInput.SkipPrefix('A'))</a>
<a name="ln3039">		return _SetError(ERROR_INVALID);</a>
<a name="ln3040"> </a>
<a name="ln3041">	number_type dimensionNumber;</a>
<a name="ln3042">	Node* dimensionExpression = NULL;</a>
<a name="ln3043"> </a>
<a name="ln3044">	// If it looks like a number, it must be the first production, otherwise</a>
<a name="ln3045">	// the second one.</a>
<a name="ln3046">	if (isdigit(fInput[0])</a>
<a name="ln3047">		|| (fInput[0] == 'n' &amp;&amp; fInput.CharsRemaining() &gt;= 2</a>
<a name="ln3048">			&amp;&amp; isdigit(fInput[1]))) {</a>
<a name="ln3049">		if (!_ParseNumber(dimensionNumber))</a>
<a name="ln3050">			return false;</a>
<a name="ln3051">	} else {</a>
<a name="ln3052">		if (!_ParseExpression(dimensionExpression))</a>
<a name="ln3053">			return false;</a>
<a name="ln3054">	}</a>
<a name="ln3055"> </a>
<a name="ln3056">	// parse the type</a>
<a name="ln3057">	Node* type;</a>
<a name="ln3058">	if (!_SkipExpected('_') || !_ParseType(type))</a>
<a name="ln3059">		return false;</a>
<a name="ln3060"> </a>
<a name="ln3061">	// create the array node</a>
<a name="ln3062">	return dimensionExpression != NULL</a>
<a name="ln3063">		? NodeCreator&lt;ArrayNode&gt;(this)(type, dimensionExpression, _node)</a>
<a name="ln3064">		: NodeCreator&lt;ArrayNode&gt;(this)(type, dimensionNumber, _node);</a>
<a name="ln3065">}</a>
<a name="ln3066"> </a>
<a name="ln3067"> </a>
<a name="ln3068">bool</a>
<a name="ln3069">Demangler::_ParsePointerToMemberType(Node*&amp; _node)</a>
<a name="ln3070">{</a>
<a name="ln3071">	DEBUG_SCOPE(&quot;_ParsePointerToMemberType&quot;);</a>
<a name="ln3072"> </a>
<a name="ln3073">	// &lt;pointer-to-member-type&gt; ::= M &lt;class type&gt; &lt;member type&gt;</a>
<a name="ln3074">	Node* classType;</a>
<a name="ln3075">	Node* memberType;</a>
<a name="ln3076">	return _SkipExpected('M')</a>
<a name="ln3077">		&amp;&amp; _ParseType(classType)</a>
<a name="ln3078">		&amp;&amp; _ParseType(memberType)</a>
<a name="ln3079">		&amp;&amp; NodeCreator&lt;PointerToMemberNode&gt;(this)(classType, memberType,</a>
<a name="ln3080">			_node);</a>
<a name="ln3081">}</a>
<a name="ln3082"> </a>
<a name="ln3083"> </a>
<a name="ln3084">bool</a>
<a name="ln3085">Demangler::_ParseTemplateParam(Node*&amp; _node)</a>
<a name="ln3086">{</a>
<a name="ln3087">	DEBUG_SCOPE(&quot;_ParseTemplateParam&quot;);</a>
<a name="ln3088"> </a>
<a name="ln3089">	// &lt;template-param&gt; ::= T_	# first template parameter</a>
<a name="ln3090">	//                  ::= T &lt;parameter-2 non-negative number&gt; _</a>
<a name="ln3091"> </a>
<a name="ln3092">	if (!_SkipExpected('T'))</a>
<a name="ln3093">		return false;</a>
<a name="ln3094">	if (fTemplatizedNode == NULL)</a>
<a name="ln3095">		return _SetError(ERROR_INVALID);</a>
<a name="ln3096"> </a>
<a name="ln3097">	// get the index;</a>
<a name="ln3098">	number_type index = 0;</a>
<a name="ln3099">	if (!fInput.HasPrefix('_')) {</a>
<a name="ln3100">		if (!_ParseNumber(index))</a>
<a name="ln3101">			return false;</a>
<a name="ln3102"> </a>
<a name="ln3103">		if (index &lt; 0)</a>
<a name="ln3104">			return _SetError(ERROR_INVALID);</a>
<a name="ln3105">		index++;</a>
<a name="ln3106">	}</a>
<a name="ln3107"> </a>
<a name="ln3108">	if (!_SkipExpected('_'))</a>
<a name="ln3109">		return false;</a>
<a name="ln3110"> </a>
<a name="ln3111">	// get the parameter</a>
<a name="ln3112">	Node* parameter = fTemplatizedNode-&gt;TemplateParameterAt(index);</a>
<a name="ln3113">	if (parameter == NULL)</a>
<a name="ln3114">		return _SetError(ERROR_INVALID);</a>
<a name="ln3115"> </a>
<a name="ln3116">	// create a substitution node</a>
<a name="ln3117">	return NodeCreator&lt;SubstitutionNode&gt;(this)(parameter, _node);</a>
<a name="ln3118">}</a>
<a name="ln3119"> </a>
<a name="ln3120"> </a>
<a name="ln3121">bool</a>
<a name="ln3122">Demangler::_ParseSubstitution(Node*&amp; _node)</a>
<a name="ln3123">{</a>
<a name="ln3124">	DEBUG_SCOPE(&quot;_ParseSubstitution&quot;);</a>
<a name="ln3125"> </a>
<a name="ln3126">	if (!_ParseSubstitutionInternal(_node))</a>
<a name="ln3127">		return false;</a>
<a name="ln3128"> </a>
<a name="ln3129">	// substitutions are never referenceable</a>
<a name="ln3130">	_node-&gt;SetReferenceable(false);</a>
<a name="ln3131"> </a>
<a name="ln3132">	return true;</a>
<a name="ln3133">}</a>
<a name="ln3134"> </a>
<a name="ln3135"> </a>
<a name="ln3136">bool</a>
<a name="ln3137">Demangler::_ParseSubstitutionInternal(Node*&amp; _node)</a>
<a name="ln3138">{</a>
<a name="ln3139">	DEBUG_SCOPE(&quot;_ParseSubstitutionInternal&quot;);</a>
<a name="ln3140"> </a>
<a name="ln3141">	// &lt;substitution&gt; ::= S &lt;seq-id&gt; _</a>
<a name="ln3142">	//                ::= S_</a>
<a name="ln3143">	//</a>
<a name="ln3144">	// &lt;substitution&gt; ::= St # ::std::</a>
<a name="ln3145">	// &lt;substitution&gt; ::= Sa # ::std::allocator</a>
<a name="ln3146">	// &lt;substitution&gt; ::= Sb # ::std::basic_string</a>
<a name="ln3147">	// &lt;substitution&gt; ::= Ss # ::std::basic_string &lt; char,</a>
<a name="ln3148">	//                         ::std::char_traits&lt;char&gt;,</a>
<a name="ln3149">	//                         ::std::allocator&lt;char&gt; &gt;</a>
<a name="ln3150">	// &lt;substitution&gt; ::= Si # ::std::basic_istream&lt;char,</a>
<a name="ln3151">	//                             std::char_traits&lt;char&gt; &gt;</a>
<a name="ln3152">	// &lt;substitution&gt; ::= So # ::std::basic_ostream&lt;char,</a>
<a name="ln3153">	//                             std::char_traits&lt;char&gt; &gt;</a>
<a name="ln3154">	// &lt;substitution&gt; ::= Sd # ::std::basic_iostream&lt;char,</a>
<a name="ln3155">	//                             std::char_traits&lt;char&gt; &gt;</a>
<a name="ln3156"> </a>
<a name="ln3157">	if (fInput.CharsRemaining() &lt; 2 || !fInput.SkipPrefix('S'))</a>
<a name="ln3158">		return _SetError(ERROR_INVALID);</a>
<a name="ln3159"> </a>
<a name="ln3160">	switch (fInput[0]) {</a>
<a name="ln3161">		case 't':</a>
<a name="ln3162">			return _CreateNodeAndSkip(&quot;std&quot;, 1, _node);</a>
<a name="ln3163">		case 'a':</a>
<a name="ln3164">			return _CreateTypeNodeAndSkip(&quot;allocator&quot;, &quot;std&quot;, NULL, 1,</a>
<a name="ln3165">				_node);</a>
<a name="ln3166">		case 'b':</a>
<a name="ln3167">			return _CreateTypeNodeAndSkip(&quot;basic_string&quot;, &quot;std&quot;, NULL, 1,</a>
<a name="ln3168">				_node);</a>
<a name="ln3169">		case 's':</a>
<a name="ln3170">			return _CreateTypeNodeAndSkip(&quot;basic_string&quot;, &quot;std&quot;,</a>
<a name="ln3171">				&quot;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&quot;, 1,</a>
<a name="ln3172">				_node);</a>
<a name="ln3173">		case 'i':</a>
<a name="ln3174">			return _CreateTypeNodeAndSkip(&quot;basic_istream&quot;, &quot;std&quot;,</a>
<a name="ln3175">				&quot;char, std::char_traits&lt;char&gt;&quot;, 1, _node);</a>
<a name="ln3176">		case 'o':</a>
<a name="ln3177">			return _CreateTypeNodeAndSkip(&quot;basic_ostream&quot;, &quot;std&quot;,</a>
<a name="ln3178">				&quot;char, std::char_traits&lt;char&gt;&quot;, 1, _node);</a>
<a name="ln3179">		case 'd':</a>
<a name="ln3180">			return _CreateTypeNodeAndSkip(&quot;basic_iostream&quot;, &quot;std&quot;,</a>
<a name="ln3181">				&quot;char, std::char_traits&lt;char&gt;&quot;, 1, _node);</a>
<a name="ln3182">		case '_':</a>
<a name="ln3183">			fInput.Skip(1);</a>
<a name="ln3184">			return _CreateSubstitutionNode(0, _node);</a>
<a name="ln3185">	}</a>
<a name="ln3186"> </a>
<a name="ln3187">	// parse &lt;seq-id&gt;</a>
<a name="ln3188">	int seqID = 0;</a>
<a name="ln3189">	int count = fInput.CharsRemaining();</a>
<a name="ln3190">	int i = 0;</a>
<a name="ln3191">	for (; i &lt; count &amp;&amp; fInput[i] != '_'; i++) {</a>
<a name="ln3192">		char c = fInput[i];</a>
<a name="ln3193">		if (isdigit(c))</a>
<a name="ln3194">			seqID = seqID * 36 + (c - '0');</a>
<a name="ln3195">		else if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')</a>
<a name="ln3196">			seqID = seqID * 36 + 10 + (c - 'A');</a>
<a name="ln3197">		else</a>
<a name="ln3198">			return _SetError(ERROR_INVALID);</a>
<a name="ln3199">	}</a>
<a name="ln3200"> </a>
<a name="ln3201">	if (i == count)</a>
<a name="ln3202">		return _SetError(ERROR_INVALID);</a>
<a name="ln3203"> </a>
<a name="ln3204">	// skip digits and '_'</a>
<a name="ln3205">	fInput.Skip(i + 1);</a>
<a name="ln3206"> </a>
<a name="ln3207">	return _CreateSubstitutionNode(seqID + 1, _node);</a>
<a name="ln3208">}</a>
<a name="ln3209"> </a>
<a name="ln3210"> </a>
<a name="ln3211">bool</a>
<a name="ln3212">Demangler::_ParseBareFunctionType(FunctionNode* node)</a>
<a name="ln3213">{</a>
<a name="ln3214">	DEBUG_SCOPE(&quot;_ParseBareFunctionType&quot;);</a>
<a name="ln3215"> </a>
<a name="ln3216">	// &lt;bare-function-type&gt; ::= &lt;signature type&gt;+</a>
<a name="ln3217">	//     # types are possible return type, then parameter types</a>
<a name="ln3218"> </a>
<a name="ln3219">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln3220">		return _SetError(ERROR_INVALID);</a>
<a name="ln3221"> </a>
<a name="ln3222">	do {</a>
<a name="ln3223">		Node* typeNode;</a>
<a name="ln3224">		if (!_ParseType(typeNode))</a>
<a name="ln3225">			return false;</a>
<a name="ln3226"> </a>
<a name="ln3227">		node-&gt;AddType(typeNode);</a>
<a name="ln3228">	} while (fInput.CharsRemaining() &gt; 0 &amp;&amp; fInput[0] != 'E');</a>
<a name="ln3229">		// 'E' delimits &lt;function-type&gt;</a>
<a name="ln3230"> </a>
<a name="ln3231">	return true;</a>
<a name="ln3232">}</a>
<a name="ln3233"> </a>
<a name="ln3234"> </a>
<a name="ln3235">bool</a>
<a name="ln3236">Demangler::_ParseTemplateArgs(Node* node, Node*&amp; _node)</a>
<a name="ln3237">{</a>
<a name="ln3238">	DEBUG_SCOPE(&quot;_ParseTemplateArgs&quot;);</a>
<a name="ln3239"> </a>
<a name="ln3240">	// &lt;template-args&gt; ::= I &lt;template-arg&gt;+ E</a>
<a name="ln3241"> </a>
<a name="ln3242">	if (!_SkipExpected('I'))</a>
<a name="ln3243">		return false;</a>
<a name="ln3244"> </a>
<a name="ln3245">	// we need at least one &lt;template-arg&gt;</a>
<a name="ln3246">	if (fInput.CharsRemaining() == 0 || fInput[0] == 'E')</a>
<a name="ln3247">		return _SetError(ERROR_INVALID);</a>
<a name="ln3248"> </a>
<a name="ln3249">	// create the node</a>
<a name="ln3250">	TemplateNode* templateNode;</a>
<a name="ln3251">	if (!NodeCreator&lt;TemplateNode&gt;(this)(node, templateNode))</a>
<a name="ln3252">		return false;</a>
<a name="ln3253">	_node = templateNode;</a>
<a name="ln3254"> </a>
<a name="ln3255">	// parse the args</a>
<a name="ln3256">	while (fInput.CharsRemaining() &gt; 0 &amp;&amp; fInput[0] != 'E') {</a>
<a name="ln3257">		Node* arg;</a>
<a name="ln3258">		if (!_ParseTemplateArg(arg))</a>
<a name="ln3259">			return false;</a>
<a name="ln3260">		templateNode-&gt;AddArgument(arg);</a>
<a name="ln3261">	}</a>
<a name="ln3262"> </a>
<a name="ln3263">	// skip the trailing 'E'</a>
<a name="ln3264">	return _SkipExpected('E');</a>
<a name="ln3265">}</a>
<a name="ln3266"> </a>
<a name="ln3267"> </a>
<a name="ln3268">bool</a>
<a name="ln3269">Demangler::_ParseTemplateArg(Node*&amp; _node)</a>
<a name="ln3270">{</a>
<a name="ln3271">	DEBUG_SCOPE(&quot;_ParseTemplateArg&quot;);</a>
<a name="ln3272"> </a>
<a name="ln3273">	// &lt;template-arg&gt; ::= &lt;type&gt;			   # type or template</a>
<a name="ln3274">	//                ::= X &lt;expression&gt; E	   # expression</a>
<a name="ln3275">	//                ::= &lt;expr-primary&gt;       # simple expressions</a>
<a name="ln3276">	//                ::= I &lt;template-arg&gt;* E  # argument pack</a>
<a name="ln3277">	//                ::= sp &lt;expression&gt;      # pack expansion of (C++0x)</a>
<a name="ln3278"> </a>
<a name="ln3279">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln3280">		return _SetError(ERROR_INVALID);</a>
<a name="ln3281"> </a>
<a name="ln3282">	switch (fInput[0]) {</a>
<a name="ln3283">		case 'X':	// X &lt;expression&gt; E</a>
<a name="ln3284">			fInput.Skip(1);</a>
<a name="ln3285">			return _ParseExpression(_node) &amp;&amp; _SkipExpected('E');</a>
<a name="ln3286"> </a>
<a name="ln3287">		case 'L':	// &lt;expr-primary&gt;</a>
<a name="ln3288">			return _ParseExpressionPrimary(_node);</a>
<a name="ln3289"> </a>
<a name="ln3290">		case 'I':	// I &lt;template-arg&gt;* E</a>
<a name="ln3291">		{</a>
<a name="ln3292">#if 0</a>
<a name="ln3293">			fInput.Skip(1);</a>
<a name="ln3294"> </a>
<a name="ln3295">			while (fInput.CharsRemaining() &gt; 0 &amp;&amp; fInput[0] != 'E') {</a>
<a name="ln3296">				Node* arg;</a>
<a name="ln3297">				if (!_ParseTemplateArg(arg))</a>
<a name="ln3298">					return false;</a>
<a name="ln3299">			}</a>
<a name="ln3300"> </a>
<a name="ln3301">			if (!fInput.SkipPrefix('E'))</a>
<a name="ln3302">				return _SetError(ERROR_INVALID);</a>
<a name="ln3303">			return true;</a>
<a name="ln3304">#endif</a>
<a name="ln3305">			// NOTE: Unsupported by the GNU demangler.</a>
<a name="ln3306">			return _SetError(ERROR_UNSUPPORTED);</a>
<a name="ln3307">		}</a>
<a name="ln3308"> </a>
<a name="ln3309">		case 's':</a>
<a name="ln3310">			if (fInput.SkipPrefix(&quot;sp&quot;)) {</a>
<a name="ln3311">				// sp &lt;expression&gt;</a>
<a name="ln3312">#if 0</a>
<a name="ln3313">				return _ParseExpression(_node);</a>
<a name="ln3314">#endif</a>
<a name="ln3315">				// NOTE: Unsupported by the GNU demangler.</a>
<a name="ln3316">				return _SetError(ERROR_UNSUPPORTED);</a>
<a name="ln3317">			}</a>
<a name="ln3318"> </a>
<a name="ln3319">			// fall through...</a>
<a name="ln3320"> </a>
<a name="ln3321">		default:	// &lt;type&gt;</a>
<a name="ln3322">			return _ParseType(_node);</a>
<a name="ln3323">	}</a>
<a name="ln3324">}</a>
<a name="ln3325"> </a>
<a name="ln3326"> </a>
<a name="ln3327">bool</a>
<a name="ln3328">Demangler::_ParseExpression(Node*&amp; _node)</a>
<a name="ln3329">{</a>
<a name="ln3330">	DEBUG_SCOPE(&quot;_ParseExpression&quot;);</a>
<a name="ln3331"> </a>
<a name="ln3332">	// &lt;expression&gt; ::= &lt;unary operator-name&gt; &lt;expression&gt;</a>
<a name="ln3333">	//              ::= &lt;binary operator-name&gt; &lt;expression&gt; &lt;expression&gt;</a>
<a name="ln3334">	//              ::= &lt;trinary operator-name&gt; &lt;expression&gt; &lt;expression&gt;</a>
<a name="ln3335">	//                  &lt;expression&gt;</a>
<a name="ln3336">	//              ::= cl &lt;expression&gt;* E          # call</a>
<a name="ln3337">	//              ::= cv &lt;type&gt; expression        # conversion with one</a>
<a name="ln3338">	//                                                argument</a>
<a name="ln3339">	//              ::= cv &lt;type&gt; _ &lt;expression&gt;* E # conversion with a</a>
<a name="ln3340">	//                                                different number of</a>
<a name="ln3341">	//                                                arguments</a>
<a name="ln3342">	//              ::= st &lt;type&gt;		            # sizeof (a type)</a>
<a name="ln3343">	//              ::= at &lt;type&gt;                   # alignof (a type)</a>
<a name="ln3344">	//              ::= &lt;template-param&gt;</a>
<a name="ln3345">	//              ::= &lt;function-param&gt;</a>
<a name="ln3346">	//              ::= sr &lt;type&gt; &lt;unqualified-name&gt;</a>
<a name="ln3347">	//                    # dependent name</a>
<a name="ln3348">	//              ::= sr &lt;type&gt; &lt;unqualified-name&gt; &lt;template-args&gt;</a>
<a name="ln3349">	//                    # dependent template-id</a>
<a name="ln3350">	//              ::= sZ &lt;template-param&gt;</a>
<a name="ln3351">	//                    # size of a parameter pack</a>
<a name="ln3352">	//              ::= &lt;expr-primary&gt;</a>
<a name="ln3353">	//</a>
<a name="ln3354">	// &lt;expr-primary&gt; ::= L &lt;type&gt; &lt;value number&gt; E  # integer literal</a>
<a name="ln3355">	//                ::= L &lt;type &lt;value float&gt; E    # floating literal</a>
<a name="ln3356">	//                ::= L &lt;mangled-name&gt; E         # external name</a>
<a name="ln3357"> </a>
<a name="ln3358">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln3359">		return _SetError(ERROR_INVALID);</a>
<a name="ln3360"> </a>
<a name="ln3361">	switch (fInput[0]) {</a>
<a name="ln3362">		case 'L':</a>
<a name="ln3363">			return _ParseExpressionPrimary(_node);</a>
<a name="ln3364">		case 'T':</a>
<a name="ln3365">			return _ParseTemplateParam(_node);</a>
<a name="ln3366">		// NOTE: &lt;function-param&gt; is not defined in the specs!</a>
<a name="ln3367">	}</a>
<a name="ln3368"> </a>
<a name="ln3369">	// must be an operator</a>
<a name="ln3370">	if (fInput.CharsRemaining() &lt; 2)</a>
<a name="ln3371">		return _SetError(ERROR_INVALID);</a>
<a name="ln3372"> </a>
<a name="ln3373">	// some operators need special handling</a>
<a name="ln3374"> </a>
<a name="ln3375">	if (fInput.SkipPrefix(&quot;cl&quot;)) {</a>
<a name="ln3376">		// cl &lt;expression&gt;* E          # call</a>
<a name="ln3377">		CallNode* callNode;</a>
<a name="ln3378">		if (!NodeCreator&lt;CallNode&gt;(this)(callNode))</a>
<a name="ln3379">			return false;</a>
<a name="ln3380"> </a>
<a name="ln3381">		while (fInput.CharsRemaining() &gt; 0 &amp;&amp; fInput[0] != 'E') {</a>
<a name="ln3382">			Node* subExpression;</a>
<a name="ln3383">			if (!_ParseExpression(subExpression))</a>
<a name="ln3384">				return false;</a>
<a name="ln3385">			callNode-&gt;AddSubExpression(subExpression);</a>
<a name="ln3386">		}</a>
<a name="ln3387"> </a>
<a name="ln3388">		_node = callNode;</a>
<a name="ln3389">		return _SkipExpected('E');</a>
<a name="ln3390">	}</a>
<a name="ln3391"> </a>
<a name="ln3392">	if (fInput.SkipPrefix(&quot;cv&quot;)) {</a>
<a name="ln3393">		// cv &lt;type&gt; expression        # conversion with one argument</a>
<a name="ln3394">		// cv &lt;type&gt; _ &lt;expression&gt;* E # conversion with a different number</a>
<a name="ln3395">		//                               of arguments</a>
<a name="ln3396"> </a>
<a name="ln3397">		// parse the type</a>
<a name="ln3398">		Node* type;</a>
<a name="ln3399">		if (!_ParseType(type))</a>
<a name="ln3400">			return false;</a>
<a name="ln3401"> </a>
<a name="ln3402">		// create a conversion expression node</a>
<a name="ln3403">		ConversionExpressionNode* expression;</a>
<a name="ln3404">		if (!NodeCreator&lt;ConversionExpressionNode&gt;(this)(type, expression))</a>
<a name="ln3405">			return false;</a>
<a name="ln3406">		_node = expression;</a>
<a name="ln3407"> </a>
<a name="ln3408">		if (fInput.SkipPrefix('_')) {</a>
<a name="ln3409">			// multi argument conversion</a>
<a name="ln3410">			while (fInput.CharsRemaining() &gt; 0 &amp;&amp; fInput[0] != 'E') {</a>
<a name="ln3411">				Node* subExpression;</a>
<a name="ln3412">				if (!_ParseExpression(subExpression))</a>
<a name="ln3413">					return false;</a>
<a name="ln3414">				expression-&gt;AddSubExpression(subExpression);</a>
<a name="ln3415">			}</a>
<a name="ln3416"> </a>
<a name="ln3417">			return _SkipExpected('E');</a>
<a name="ln3418">		}</a>
<a name="ln3419"> </a>
<a name="ln3420">		// single argument conversion</a>
<a name="ln3421">		Node* subExpression;</a>
<a name="ln3422">		if (!_ParseExpression(subExpression))</a>
<a name="ln3423">			return false;</a>
<a name="ln3424">		expression-&gt;AddSubExpression(subExpression);</a>
<a name="ln3425"> </a>
<a name="ln3426">		return true;</a>
<a name="ln3427">	}</a>
<a name="ln3428"> </a>
<a name="ln3429">	if (fInput.SkipPrefix(&quot;sr&quot;)) {</a>
<a name="ln3430">		// sr &lt;type&gt; &lt;unqualified-name&gt;</a>
<a name="ln3431">		// sr &lt;type&gt; &lt;unqualified-name&gt; &lt;template-args&gt;</a>
<a name="ln3432"> </a>
<a name="ln3433">		// parse type and unqualified name and create the node</a>
<a name="ln3434">		Node* type;</a>
<a name="ln3435">		Node* name;</a>
<a name="ln3436">		if (!_ParseType(type) || !_ParseUnqualifiedName(name)</a>
<a name="ln3437">			|| !NodeCreator&lt;DependentNameNode&gt;(this)(type, name, _node)) {</a>
<a name="ln3438">			return false;</a>
<a name="ln3439">		}</a>
<a name="ln3440"> </a>
<a name="ln3441">		// If there are template arguments left, add them.</a>
<a name="ln3442">		if (!fInput.HasPrefix('I'))</a>
<a name="ln3443">			return true;</a>
<a name="ln3444"> </a>
<a name="ln3445">		return _ParseTemplateArgs(_node, _node);</a>
<a name="ln3446">	}</a>
<a name="ln3447"> </a>
<a name="ln3448">	if (fInput.SkipPrefix(&quot;sZ&quot;)) {</a>
<a name="ln3449">		// sZ &lt;template-param&gt;</a>
<a name="ln3450"> </a>
<a name="ln3451">		// NOTE: Unsupported by the GNU demangler.</a>
<a name="ln3452">		return _SetError(ERROR_UNSUPPORTED);</a>
<a name="ln3453">	}</a>
<a name="ln3454"> </a>
<a name="ln3455">	// no special operator, so have a look for the others</a>
<a name="ln3456"> </a>
<a name="ln3457">	const operator_info* info = NULL;</a>
<a name="ln3458">	for (int i = 0; kOperatorInfos[i].name != NULL; i++) {</a>
<a name="ln3459">		if (fInput.SkipPrefix(kOperatorInfos[i].mangled_name)) {</a>
<a name="ln3460">			info = &amp;kOperatorInfos[i];</a>
<a name="ln3461">			break;</a>
<a name="ln3462">		}</a>
<a name="ln3463">	}</a>
<a name="ln3464"> </a>
<a name="ln3465">	// We can only deal with operators with a fixed argument count at this</a>
<a name="ln3466">	// point.</a>
<a name="ln3467">	if (info == NULL || info-&gt;argument_count &lt; 0)</a>
<a name="ln3468">		return _SetError(ERROR_INVALID);</a>
<a name="ln3469"> </a>
<a name="ln3470">	// create an operator node</a>
<a name="ln3471">	OperatorExpressionNode* operatorNode;</a>
<a name="ln3472">	if (!NodeCreator&lt;OperatorExpressionNode&gt;(this)(info, operatorNode))</a>
<a name="ln3473">		return false;</a>
<a name="ln3474"> </a>
<a name="ln3475">	// parse the arguments</a>
<a name="ln3476">	int i = 0;</a>
<a name="ln3477"> </a>
<a name="ln3478">	// the first one might be a type</a>
<a name="ln3479">	if ((info-&gt;flags &amp; OPERATOR_TYPE_PARAM) != 0) {</a>
<a name="ln3480">		Node* type;</a>
<a name="ln3481">		if (!_ParseType(type))</a>
<a name="ln3482">			return false;</a>
<a name="ln3483"> </a>
<a name="ln3484">		operatorNode-&gt;AddSubExpression(type);</a>
<a name="ln3485">		i++;</a>
<a name="ln3486">	}</a>
<a name="ln3487"> </a>
<a name="ln3488">	// the others are expressions</a>
<a name="ln3489">	for (; i &lt; info-&gt;argument_count; i++) {</a>
<a name="ln3490">		Node* subExpression;</a>
<a name="ln3491">		if (!_ParseExpression(subExpression))</a>
<a name="ln3492">			return false;</a>
<a name="ln3493">		operatorNode-&gt;AddSubExpression(subExpression);</a>
<a name="ln3494">	}</a>
<a name="ln3495"> </a>
<a name="ln3496">	_node = operatorNode;</a>
<a name="ln3497">	return true;</a>
<a name="ln3498">}</a>
<a name="ln3499"> </a>
<a name="ln3500"> </a>
<a name="ln3501">bool</a>
<a name="ln3502">Demangler::_ParseExpressionPrimary(Node*&amp; _node)</a>
<a name="ln3503">{</a>
<a name="ln3504">	DEBUG_SCOPE(&quot;_ParseExpressionPrimary&quot;);</a>
<a name="ln3505"> </a>
<a name="ln3506">	// &lt;expr-primary&gt; ::= L &lt;type&gt; &lt;value number&gt; E  # integer literal</a>
<a name="ln3507">	//                ::= L &lt;type &lt;value float&gt; E    # floating literal</a>
<a name="ln3508">	//                ::= L &lt;mangled-name&gt; E         # external name</a>
<a name="ln3509"> </a>
<a name="ln3510">	if (!_SkipExpected('L'))</a>
<a name="ln3511">		return false;</a>
<a name="ln3512"> </a>
<a name="ln3513">	if (fInput.SkipPrefix(&quot;_Z&quot;)) {</a>
<a name="ln3514">		ObjectNode* node;</a>
<a name="ln3515">		if (!_ParseEncoding(node))</a>
<a name="ln3516">			return false;</a>
<a name="ln3517">		_node = node;</a>
<a name="ln3518">	} else {</a>
<a name="ln3519">		// number or float literal</a>
<a name="ln3520">		Node* type;</a>
<a name="ln3521">		if (!_ParseType(type))</a>
<a name="ln3522">			return false;</a>
<a name="ln3523"> </a>
<a name="ln3524">		// GNU's demangler doesn't really seem to parse the integer/float,</a>
<a name="ln3525">		// but only replaces a leading 'n' by '-'. Good enough for us, too.</a>
<a name="ln3526"> </a>
<a name="ln3527">		// determine the length</a>
<a name="ln3528">		int maxLength = fInput.CharsRemaining();</a>
<a name="ln3529">		int length = 0;</a>
<a name="ln3530">		while (length &lt; maxLength &amp;&amp; fInput[length] != 'E')</a>
<a name="ln3531">			length++;</a>
<a name="ln3532"> </a>
<a name="ln3533">		if (length == 0)</a>
<a name="ln3534">			return _SetError(ERROR_INVALID);</a>
<a name="ln3535"> </a>
<a name="ln3536">		if (!NodeCreator&lt;TypedNumberLiteralNode&gt;(this)(type,</a>
<a name="ln3537">				fInput.String(), length, _node)) {</a>
<a name="ln3538">			return false;</a>
<a name="ln3539">		}</a>
<a name="ln3540"> </a>
<a name="ln3541">		fInput.Skip(length);</a>
<a name="ln3542">	}</a>
<a name="ln3543"> </a>
<a name="ln3544">	return _SkipExpected('E');</a>
<a name="ln3545">}</a>
<a name="ln3546"> </a>
<a name="ln3547"> </a>
<a name="ln3548">bool</a>
<a name="ln3549">Demangler::_ParseNumber(number_type&amp; number)</a>
<a name="ln3550">{</a>
<a name="ln3551">	DEBUG_SCOPE(&quot;_ParseNumber&quot;);</a>
<a name="ln3552"> </a>
<a name="ln3553">	bool negative = fInput.SkipPrefix('n');</a>
<a name="ln3554"> </a>
<a name="ln3555">	if (fInput.CharsRemaining() == 0)</a>
<a name="ln3556">		return _SetError(ERROR_INVALID);</a>
<a name="ln3557"> </a>
<a name="ln3558">	number = 0;</a>
<a name="ln3559">	int count = fInput.CharsRemaining();</a>
<a name="ln3560">	int i = 0;</a>
<a name="ln3561">	for (; i &lt; count &amp;&amp; isdigit(fInput[i]); i++)</a>
<a name="ln3562">		number = number * 10 + (fInput[i] - '0');</a>
<a name="ln3563"> </a>
<a name="ln3564">	fInput.Skip(i);</a>
<a name="ln3565"> </a>
<a name="ln3566">	if (negative)</a>
<a name="ln3567">		number =-number;</a>
<a name="ln3568">	return true;</a>
<a name="ln3569">}</a>
<a name="ln3570"> </a>
<a name="ln3571"> </a>
<a name="ln3572">bool</a>
<a name="ln3573">Demangler::_CreateNodeAndSkip(const char* name, size_t length, int toSkip,</a>
<a name="ln3574">	Node*&amp; _node)</a>
<a name="ln3575">{</a>
<a name="ln3576">	if (toSkip &gt; 0)</a>
<a name="ln3577">		fInput.Skip(toSkip);</a>
<a name="ln3578"> </a>
<a name="ln3579">	return NodeCreator&lt;SimpleNameNode&gt;(this)(name, length, _node);</a>
<a name="ln3580">}</a>
<a name="ln3581"> </a>
<a name="ln3582"> </a>
<a name="ln3583">bool</a>
<a name="ln3584">Demangler::_CreateNodeAndSkip(const char* name, int toSkip, Node*&amp; _node)</a>
<a name="ln3585">{</a>
<a name="ln3586">	return _CreateNodeAndSkip(name, strlen(name), toSkip, _node);</a>
<a name="ln3587">}</a>
<a name="ln3588"> </a>
<a name="ln3589"> </a>
<a name="ln3590">bool</a>
<a name="ln3591">Demangler::_CreateTypeNodeAndSkip(type_type type, int toSkip, Node*&amp; _node)</a>
<a name="ln3592">{</a>
<a name="ln3593">	if (toSkip &gt; 0)</a>
<a name="ln3594">		fInput.Skip(toSkip);</a>
<a name="ln3595"> </a>
<a name="ln3596">	return NodeCreator&lt;SimpleTypeNode&gt;(this)(type, _node);</a>
<a name="ln3597">}</a>
<a name="ln3598"> </a>
<a name="ln3599"> </a>
<a name="ln3600">bool</a>
<a name="ln3601">Demangler::_CreateTypeNodeAndSkip(const char* name, const char* prefix,</a>
<a name="ln3602">	const char* templateArgs, int toSkip, Node*&amp; _node)</a>
<a name="ln3603">{</a>
<a name="ln3604">	if (toSkip &gt; 0)</a>
<a name="ln3605">		fInput.Skip(toSkip);</a>
<a name="ln3606"> </a>
<a name="ln3607">	// create the name node</a>
<a name="ln3608">	if (!NodeCreator&lt;SimpleTypeNode&gt;(this)(name, _node))</a>
<a name="ln3609">		return false;</a>
<a name="ln3610"> </a>
<a name="ln3611">	// add the prefix</a>
<a name="ln3612">	if (prefix != NULL) {</a>
<a name="ln3613">		Node* prefixNode;</a>
<a name="ln3614">		if (!NodeCreator&lt;SimpleTypeNode&gt;(this)(prefix, prefixNode)</a>
<a name="ln3615">			|| !NodeCreator&lt;PrefixedNode&gt;(this)(prefixNode, _node, _node)) {</a>
<a name="ln3616">			return false;</a>
<a name="ln3617">		}</a>
<a name="ln3618">	}</a>
<a name="ln3619"> </a>
<a name="ln3620">	// wrap the node to add the template args</a>
<a name="ln3621">	if (templateArgs != NULL) {</a>
<a name="ln3622">		TemplateNode* templateNode;</a>
<a name="ln3623">		Node* argsNode;</a>
<a name="ln3624">		if (!NodeCreator&lt;TemplateNode&gt;(this)(_node, templateNode)</a>
<a name="ln3625">			|| !NodeCreator&lt;SimpleTypeNode&gt;(this)(templateArgs, argsNode)) {</a>
<a name="ln3626">			return false;</a>
<a name="ln3627">		}</a>
<a name="ln3628">		templateNode-&gt;AddArgument(argsNode);</a>
<a name="ln3629">		_node = templateNode;</a>
<a name="ln3630">	}</a>
<a name="ln3631"> </a>
<a name="ln3632">	return true;</a>
<a name="ln3633">}</a>
<a name="ln3634"> </a>
<a name="ln3635"> </a>
<a name="ln3636">void</a>
<a name="ln3637">Demangler::_RegisterReferenceableNode(Node* node)</a>
<a name="ln3638">{</a>
<a name="ln3639">	// check, if not referenceable or already registered</a>
<a name="ln3640">	if (!node-&gt;IsReferenceable() || node == fLastReferenceableNode</a>
<a name="ln3641">		|| node-&gt;NextReferenceable() != NULL) {</a>
<a name="ln3642">		return;</a>
<a name="ln3643">	}</a>
<a name="ln3644"> </a>
<a name="ln3645">	if (fFirstReferenceableNode == NULL) {</a>
<a name="ln3646">		fFirstReferenceableNode = node;</a>
<a name="ln3647">		fLastReferenceableNode = node;</a>
<a name="ln3648">	} else {</a>
<a name="ln3649">		fLastReferenceableNode-&gt;SetNextReferenceable(node);</a>
<a name="ln3650">		fLastReferenceableNode = node;</a>
<a name="ln3651">	}</a>
<a name="ln3652">}</a>
<a name="ln3653"> </a>
<a name="ln3654"> </a>
<a name="ln3655">bool</a>
<a name="ln3656">Demangler::_CreateSubstitutionNode(int index, Node*&amp; _node)</a>
<a name="ln3657">{</a>
<a name="ln3658">	Node* node = fFirstReferenceableNode;</a>
<a name="ln3659">	while (node != NULL &amp;&amp; index &gt; 0) {</a>
<a name="ln3660">		node = node-&gt;NextReferenceable();</a>
<a name="ln3661">		index--;</a>
<a name="ln3662">	}</a>
<a name="ln3663"> </a>
<a name="ln3664">	if (node == NULL)</a>
<a name="ln3665">		return _SetError(ERROR_INVALID);</a>
<a name="ln3666"> </a>
<a name="ln3667">	// create a substitution node</a>
<a name="ln3668">	return NodeCreator&lt;SubstitutionNode&gt;(this)(node, _node);</a>
<a name="ln3669">}</a>
<a name="ln3670"> </a>
<a name="ln3671"> </a>
<a name="ln3672">// #pragma mark -</a>
<a name="ln3673"> </a>
<a name="ln3674"> </a>
<a name="ln3675">const char*</a>
<a name="ln3676">demangle_symbol_gcc3(const char* mangledName, char* buffer, size_t bufferSize,</a>
<a name="ln3677">	bool* _isObjectMethod)</a>
<a name="ln3678">{</a>
<a name="ln3679">	bool isObjectMethod;</a>
<a name="ln3680">	if (_isObjectMethod == NULL)</a>
<a name="ln3681">		_isObjectMethod = &amp;isObjectMethod;</a>
<a name="ln3682"> </a>
<a name="ln3683">	Demangler demangler;</a>
<a name="ln3684">	DemanglingInfo info(true);</a>
<a name="ln3685">	if (demangler.Demangle(mangledName, buffer, bufferSize, info) != ERROR_OK)</a>
<a name="ln3686">		return NULL;</a>
<a name="ln3687"> </a>
<a name="ln3688">	// Set the object method return value. Unless we know for sure that it isn't</a>
<a name="ln3689">	// an object method, we assume that it is.</a>
<a name="ln3690">	switch (info.objectType) {</a>
<a name="ln3691">		case OBJECT_TYPE_DATA:</a>
<a name="ln3692">		case OBJECT_TYPE_FUNCTION:</a>
<a name="ln3693">		case OBJECT_TYPE_METHOD_CLASS:</a>
<a name="ln3694">			*_isObjectMethod = false;</a>
<a name="ln3695">			break;</a>
<a name="ln3696">		case OBJECT_TYPE_METHOD_OBJECT:</a>
<a name="ln3697">			*_isObjectMethod = true;</a>
<a name="ln3698">			break;</a>
<a name="ln3699">		case OBJECT_TYPE_UNKNOWN:</a>
<a name="ln3700">		case OBJECT_TYPE_METHOD_UNKNOWN:</a>
<a name="ln3701">			*_isObjectMethod = strstr(buffer, &quot;::&quot;) != NULL;</a>
<a name="ln3702">			break;</a>
<a name="ln3703">	}</a>
<a name="ln3704"> </a>
<a name="ln3705">	return buffer;</a>
<a name="ln3706">}</a>
<a name="ln3707"> </a>
<a name="ln3708"> </a>
<a name="ln3709">status_t</a>
<a name="ln3710">get_next_argument_gcc3(uint32* _cookie, const char* mangledName, char* name,</a>
<a name="ln3711">	size_t nameSize, int32* _type, size_t* _argumentLength)</a>
<a name="ln3712">{</a>
<a name="ln3713">	Demangler demangler;</a>
<a name="ln3714">	ParameterInfo info;</a>
<a name="ln3715">	int result = demangler.GetParameterInfo(mangledName, *_cookie, name,</a>
<a name="ln3716">		nameSize, info);</a>
<a name="ln3717">	if (result != ERROR_OK) {</a>
<a name="ln3718">		switch (result) {</a>
<a name="ln3719">			case ERROR_NOT_MANGLED:</a>
<a name="ln3720">				return B_BAD_VALUE;</a>
<a name="ln3721">			case ERROR_UNSUPPORTED:</a>
<a name="ln3722">				return B_BAD_VALUE;</a>
<a name="ln3723">			case ERROR_INVALID:</a>
<a name="ln3724">				return B_BAD_VALUE;</a>
<a name="ln3725">			case ERROR_BUFFER_TOO_SMALL:</a>
<a name="ln3726">				return B_BUFFER_OVERFLOW;</a>
<a name="ln3727">			case ERROR_NO_MEMORY:</a>
<a name="ln3728">				return B_NO_MEMORY;</a>
<a name="ln3729">			case ERROR_INVALID_PARAMETER_INDEX:</a>
<a name="ln3730">				return B_BAD_INDEX;</a>
<a name="ln3731">			case ERROR_INTERNAL:</a>
<a name="ln3732">			default:</a>
<a name="ln3733">				return B_ERROR;</a>
<a name="ln3734">		}</a>
<a name="ln3735">	}</a>
<a name="ln3736"> </a>
<a name="ln3737">	// translate the type</a>
<a name="ln3738">	switch (info.type.type) {</a>
<a name="ln3739">		case TYPE_BOOL:</a>
<a name="ln3740">			*_type = B_BOOL_TYPE;</a>
<a name="ln3741">			*_argumentLength = 1;</a>
<a name="ln3742">			break;</a>
<a name="ln3743"> </a>
<a name="ln3744">		case TYPE_CHAR:</a>
<a name="ln3745">			*_type = B_CHAR_TYPE;</a>
<a name="ln3746">			*_argumentLength = 1;</a>
<a name="ln3747">			break;</a>
<a name="ln3748"> </a>
<a name="ln3749">		case TYPE_SIGNED_CHAR:</a>
<a name="ln3750">			*_type = B_INT8_TYPE;</a>
<a name="ln3751">			*_argumentLength = 1;</a>
<a name="ln3752">			break;</a>
<a name="ln3753">		case TYPE_UNSIGNED_CHAR:</a>
<a name="ln3754">			*_type = B_UINT8_TYPE;</a>
<a name="ln3755">			*_argumentLength = 1;</a>
<a name="ln3756">			break;</a>
<a name="ln3757"> </a>
<a name="ln3758">		case TYPE_SHORT:</a>
<a name="ln3759">			*_type = B_INT16_TYPE;</a>
<a name="ln3760">			*_argumentLength = 2;</a>
<a name="ln3761">			break;</a>
<a name="ln3762">		case TYPE_UNSIGNED_SHORT:</a>
<a name="ln3763">			*_type = B_UINT16_TYPE;</a>
<a name="ln3764">			*_argumentLength = 2;</a>
<a name="ln3765">			break;</a>
<a name="ln3766"> </a>
<a name="ln3767">		case TYPE_INT:</a>
<a name="ln3768">			*_type = B_INT32_TYPE;</a>
<a name="ln3769">			*_argumentLength = 4;</a>
<a name="ln3770">			break;</a>
<a name="ln3771">		case TYPE_UNSIGNED_INT:</a>
<a name="ln3772">			*_type = B_UINT32_TYPE;</a>
<a name="ln3773">			*_argumentLength = 4;</a>
<a name="ln3774">			break;</a>
<a name="ln3775"> </a>
<a name="ln3776">		case TYPE_LONG:</a>
<a name="ln3777">			*_type = sizeof(long) == 4 ? B_INT32_TYPE : B_INT64_TYPE;</a>
<a name="ln3778">			*_argumentLength = sizeof(long);</a>
<a name="ln3779">			break;</a>
<a name="ln3780">		case TYPE_UNSIGNED_LONG:</a>
<a name="ln3781">			*_type = sizeof(long) == 4 ? B_UINT32_TYPE : B_UINT64_TYPE;</a>
<a name="ln3782">			*_argumentLength = sizeof(long);</a>
<a name="ln3783">			break;</a>
<a name="ln3784"> </a>
<a name="ln3785">		case TYPE_LONG_LONG:</a>
<a name="ln3786">			*_type = B_INT64_TYPE;</a>
<a name="ln3787">			*_argumentLength = 8;</a>
<a name="ln3788">			break;</a>
<a name="ln3789">		case TYPE_UNSIGNED_LONG_LONG:</a>
<a name="ln3790">			*_type = B_INT64_TYPE;</a>
<a name="ln3791">			*_argumentLength = 8;</a>
<a name="ln3792">			break;</a>
<a name="ln3793"> </a>
<a name="ln3794">		case TYPE_INT128:</a>
<a name="ln3795">			*_type = 0;</a>
<a name="ln3796">			*_argumentLength = 16;</a>
<a name="ln3797">			break;</a>
<a name="ln3798">		case TYPE_UNSIGNED_INT128:</a>
<a name="ln3799">			*_type = 0;</a>
<a name="ln3800">			*_argumentLength = 16;</a>
<a name="ln3801">			break;</a>
<a name="ln3802"> </a>
<a name="ln3803">		case TYPE_FLOAT:</a>
<a name="ln3804">			*_type = B_FLOAT_TYPE;</a>
<a name="ln3805">			*_argumentLength = sizeof(float);</a>
<a name="ln3806">			break;</a>
<a name="ln3807">		case TYPE_DOUBLE:</a>
<a name="ln3808">			*_type = B_DOUBLE_TYPE;</a>
<a name="ln3809">			*_argumentLength = sizeof(double);</a>
<a name="ln3810">			break;</a>
<a name="ln3811"> </a>
<a name="ln3812">		case TYPE_LONG_DOUBLE:</a>
<a name="ln3813">			*_type = 0;</a>
<a name="ln3814">			*_argumentLength = sizeof(long double);</a>
<a name="ln3815">			break;</a>
<a name="ln3816"> </a>
<a name="ln3817">		case TYPE_FLOAT128:</a>
<a name="ln3818">			*_type = 0;</a>
<a name="ln3819">			*_argumentLength = 16;</a>
<a name="ln3820">			break;</a>
<a name="ln3821"> </a>
<a name="ln3822">		case TYPE_DFLOAT16:</a>
<a name="ln3823">			*_argumentLength = 2;</a>
<a name="ln3824">		case TYPE_DFLOAT32:</a>
<a name="ln3825">			*_argumentLength *= 2;</a>
<a name="ln3826">		case TYPE_DFLOAT64:</a>
<a name="ln3827">			*_argumentLength *= 2;</a>
<a name="ln3828">		case TYPE_DFLOAT128:</a>
<a name="ln3829">			*_argumentLength *= 2;</a>
<a name="ln3830">			*_type = 0;</a>
<a name="ln3831">			break;</a>
<a name="ln3832"> </a>
<a name="ln3833">		case TYPE_CHAR16_T:</a>
<a name="ln3834">			*_type = B_UINT16_TYPE;</a>
<a name="ln3835">			*_argumentLength = 2;</a>
<a name="ln3836">			break;</a>
<a name="ln3837"> </a>
<a name="ln3838">		case TYPE_CHAR32_T:</a>
<a name="ln3839">			*_type = B_UINT32_TYPE;</a>
<a name="ln3840">			*_argumentLength = 2;</a>
<a name="ln3841">			break;</a>
<a name="ln3842"> </a>
<a name="ln3843">		case TYPE_CONST_CHAR_POINTER:</a>
<a name="ln3844">			*_type = B_STRING_TYPE;</a>
<a name="ln3845">			*_argumentLength = sizeof(void*);</a>
<a name="ln3846">			break;</a>
<a name="ln3847"> </a>
<a name="ln3848">		case TYPE_POINTER:</a>
<a name="ln3849">			*_type = B_POINTER_TYPE;</a>
<a name="ln3850">			*_argumentLength = sizeof(void*);</a>
<a name="ln3851">			break;</a>
<a name="ln3852"> </a>
<a name="ln3853">		case TYPE_REFERENCE:</a>
<a name="ln3854">			*_type = B_REF_TYPE;</a>
<a name="ln3855">				// TODO: That's actually entry_ref!</a>
<a name="ln3856">			*_argumentLength = sizeof(void*);</a>
<a name="ln3857">			break;</a>
<a name="ln3858"> </a>
<a name="ln3859">		case TYPE_WCHAR_T:</a>
<a name="ln3860">			// TODO: Type/size might change!</a>
<a name="ln3861">			*_type = B_UINT16_TYPE;</a>
<a name="ln3862">			*_argumentLength = 2;</a>
<a name="ln3863">			break;</a>
<a name="ln3864"> </a>
<a name="ln3865">		case TYPE_UNKNOWN:</a>
<a name="ln3866">		case TYPE_ELLIPSIS:</a>
<a name="ln3867">		case TYPE_VOID:</a>
<a name="ln3868">		default:</a>
<a name="ln3869">			// Well, tell our caller *something*.</a>
<a name="ln3870">			*_type = 0;</a>
<a name="ln3871">			*_argumentLength = sizeof(int);</a>
<a name="ln3872">	}</a>
<a name="ln3873"> </a>
<a name="ln3874">	// assume sizeof(int) argument alignment</a>
<a name="ln3875">	if (*_argumentLength &lt; sizeof(int))</a>
<a name="ln3876">		*_argumentLength = sizeof(int);</a>
<a name="ln3877"> </a>
<a name="ln3878">	++*_cookie;</a>
<a name="ln3879">	return B_OK;</a>
<a name="ln3880">}</a>
<a name="ln3881"> </a>
<a name="ln3882"> </a>
<a name="ln3883">#ifndef _KERNEL_MODE</a>
<a name="ln3884"> </a>
<a name="ln3885">const char*</a>
<a name="ln3886">demangle_name_gcc3(const char* mangledName, char* buffer, size_t bufferSize)</a>
<a name="ln3887">{</a>
<a name="ln3888"> </a>
<a name="ln3889">	Demangler demangler;</a>
<a name="ln3890">	DemanglingInfo info(false);</a>
<a name="ln3891">	if (demangler.Demangle(mangledName, buffer, bufferSize, info) != ERROR_OK)</a>
<a name="ln3892">		return NULL;</a>
<a name="ln3893">	return buffer;</a>
<a name="ln3894">}</a>
<a name="ln3895"> </a>
<a name="ln3896">#endif</a>

</code></pre>
<div class="balloon" rel="930"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fUnqualifiedNode.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
