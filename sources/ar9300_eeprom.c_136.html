
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar9300_eeprom.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 2013 Qualcomm Atheros, Inc.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln5"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln6"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln7"> *</a>
<a name="ln8"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH</a>
<a name="ln9"> * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</a>
<a name="ln10"> * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,</a>
<a name="ln11"> * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM</a>
<a name="ln12"> * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR</a>
<a name="ln13"> * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</a>
<a name="ln14"> * PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln15"> */</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;opt_ah.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;ah.h&quot;</a>
<a name="ln20">#include &quot;ah_internal.h&quot;</a>
<a name="ln21">#include &quot;ah_devid.h&quot;</a>
<a name="ln22">#ifdef AH_DEBUG</a>
<a name="ln23">#include &quot;ah_desc.h&quot;                    /* NB: for HAL_PHYERR* */</a>
<a name="ln24">#endif</a>
<a name="ln25">#include &quot;ar9300/ar9300.h&quot;</a>
<a name="ln26">#include &quot;ar9300/ar9300eep.h&quot;</a>
<a name="ln27">#include &quot;ar9300/ar9300template_generic.h&quot;</a>
<a name="ln28">#include &quot;ar9300/ar9300template_xb112.h&quot;</a>
<a name="ln29">#include &quot;ar9300/ar9300template_hb116.h&quot;</a>
<a name="ln30">#include &quot;ar9300/ar9300template_xb113.h&quot;</a>
<a name="ln31">#include &quot;ar9300/ar9300template_hb112.h&quot;</a>
<a name="ln32">#include &quot;ar9300/ar9300template_ap121.h&quot;</a>
<a name="ln33">#include &quot;ar9300/ar9300template_osprey_k31.h&quot;</a>
<a name="ln34">#include &quot;ar9300/ar9300template_wasp_2.h&quot;</a>
<a name="ln35">#include &quot;ar9300/ar9300template_wasp_k31.h&quot;</a>
<a name="ln36">#include &quot;ar9300/ar9300template_aphrodite.h&quot;</a>
<a name="ln37">#include &quot;ar9300/ar9300reg.h&quot;</a>
<a name="ln38">#include &quot;ar9300/ar9300phy.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">#if AH_BYTE_ORDER == AH_BIG_ENDIAN</a>
<a name="ln43">void ar9300_swap_eeprom(ar9300_eeprom_t *eep);</a>
<a name="ln44">void ar9300_eeprom_template_swap(void);</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">static u_int16_t ar9300_eeprom_get_spur_chan(struct ath_hal *ah,</a>
<a name="ln48">    int spur_chan, HAL_BOOL is_2ghz);</a>
<a name="ln49">#ifdef UNUSED</a>
<a name="ln50">static inline HAL_BOOL ar9300_fill_eeprom(struct ath_hal *ah);</a>
<a name="ln51">static inline HAL_STATUS ar9300_check_eeprom(struct ath_hal *ah);</a>
<a name="ln52">#endif</a>
<a name="ln53"> </a>
<a name="ln54">static ar9300_eeprom_t *default9300[] =</a>
<a name="ln55">{</a>
<a name="ln56">    &amp;ar9300_template_generic,</a>
<a name="ln57">    &amp;ar9300_template_xb112,</a>
<a name="ln58">    &amp;ar9300_template_hb116,</a>
<a name="ln59">    &amp;ar9300_template_hb112,</a>
<a name="ln60">    &amp;ar9300_template_xb113,</a>
<a name="ln61">    &amp;ar9300_template_ap121,</a>
<a name="ln62">    &amp;ar9300_template_wasp_2,</a>
<a name="ln63">    &amp;ar9300_template_wasp_k31,</a>
<a name="ln64">    &amp;ar9300_template_osprey_k31,</a>
<a name="ln65">    &amp;ar9300_template_aphrodite,</a>
<a name="ln66">};</a>
<a name="ln67"> </a>
<a name="ln68">/*</a>
<a name="ln69"> * Different types of memory where the calibration data might be stored.</a>
<a name="ln70"> * All types are searched in ar9300_eeprom_restore()</a>
<a name="ln71"> * in the order flash, eeprom, otp.</a>
<a name="ln72"> * To disable searching a type, set its parameter to 0.</a>
<a name="ln73"> */</a>
<a name="ln74"> </a>
<a name="ln75">/*</a>
<a name="ln76"> * This is where we look for the calibration data.</a>
<a name="ln77"> * must be set before ath_attach() is called</a>
<a name="ln78"> */</a>
<a name="ln79">static int calibration_data_try = calibration_data_none;</a>
<a name="ln80">static int calibration_data_try_address = 0;</a>
<a name="ln81"> </a>
<a name="ln82">/*</a>
<a name="ln83"> * Set the type of memory used to store calibration data.</a>
<a name="ln84"> * Used by nart to force reading/writing of a specific type.</a>
<a name="ln85"> * The driver can normally allow autodetection</a>
<a name="ln86"> * by setting source to calibration_data_none=0.</a>
<a name="ln87"> */</a>
<a name="ln88">void ar9300_calibration_data_set(struct ath_hal *ah, int32_t source)</a>
<a name="ln89">{</a>
<a name="ln90">    if (ah != 0) {</a>
<a name="ln91">        AH9300(ah)-&gt;calibration_data_source = source;</a>
<a name="ln92">    } else {</a>
<a name="ln93">        calibration_data_try = source;</a>
<a name="ln94">    }</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">int32_t ar9300_calibration_data_get(struct ath_hal *ah)</a>
<a name="ln98">{</a>
<a name="ln99">    if (ah != 0) {</a>
<a name="ln100">        return AH9300(ah)-&gt;calibration_data_source;</a>
<a name="ln101">    } else {</a>
<a name="ln102">        return calibration_data_try;</a>
<a name="ln103">    }</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">/*</a>
<a name="ln107"> * Set the address of first byte used to store calibration data.</a>
<a name="ln108"> * Used by nart to force reading/writing at a specific address.</a>
<a name="ln109"> * The driver can normally allow autodetection by setting size=0.</a>
<a name="ln110"> */</a>
<a name="ln111">void ar9300_calibration_data_address_set(struct ath_hal *ah, int32_t size)</a>
<a name="ln112">{</a>
<a name="ln113">    if (ah != 0) {</a>
<a name="ln114">        AH9300(ah)-&gt;calibration_data_source_address = size;</a>
<a name="ln115">    } else {</a>
<a name="ln116">        calibration_data_try_address = size;</a>
<a name="ln117">    }</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">int32_t ar9300_calibration_data_address_get(struct ath_hal *ah)</a>
<a name="ln121">{</a>
<a name="ln122">    if (ah != 0) {</a>
<a name="ln123">        return AH9300(ah)-&gt;calibration_data_source_address;</a>
<a name="ln124">    } else {</a>
<a name="ln125">        return calibration_data_try_address;</a>
<a name="ln126">    }</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">/*</a>
<a name="ln130"> * This is the template that is loaded if ar9300_eeprom_restore()</a>
<a name="ln131"> * can't find valid data in the memory.</a>
<a name="ln132"> */</a>
<a name="ln133">static int Ar9300_eeprom_template_preference = ar9300_eeprom_template_generic;</a>
<a name="ln134"> </a>
<a name="ln135">void ar9300_eeprom_template_preference(int32_t value)</a>
<a name="ln136">{</a>
<a name="ln137">    Ar9300_eeprom_template_preference = value;</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">/*</a>
<a name="ln141"> * Install the specified default template.</a>
<a name="ln142"> * Overwrites any existing calibration and configuration information in memory.</a>
<a name="ln143"> */</a>
<a name="ln144">int32_t ar9300_eeprom_template_install(struct ath_hal *ah, int32_t value)</a>
<a name="ln145">{</a>
<a name="ln146">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln147">    ar9300_eeprom_t *mptr, *dptr;</a>
<a name="ln148">    int mdata_size;</a>
<a name="ln149"> </a>
<a name="ln150">    mptr = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln151">    mdata_size = ar9300_eeprom_struct_size();</a>
<a name="ln152">    if (mptr != 0) {</a>
<a name="ln153">#if 0</a>
<a name="ln154">        calibration_data_source = calibration_data_none;</a>
<a name="ln155">        calibration_data_source_address = 0;</a>
<a name="ln156">#endif</a>
<a name="ln157">        dptr = ar9300_eeprom_struct_default_find_by_id(value);</a>
<a name="ln158">        if (dptr != 0) {</a>
<a name="ln159">            OS_MEMCPY(mptr, dptr, mdata_size);</a>
<a name="ln160">            return 0;</a>
<a name="ln161">        }</a>
<a name="ln162">    }</a>
<a name="ln163">    return -1;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">static int</a>
<a name="ln167">ar9300_eeprom_restore_something(struct ath_hal *ah, ar9300_eeprom_t *mptr,</a>
<a name="ln168">    int mdata_size)</a>
<a name="ln169">{</a>
<a name="ln170">    int it;</a>
<a name="ln171">    ar9300_eeprom_t *dptr;</a>
<a name="ln172">    int nptr;</a>
<a name="ln173"> </a>
<a name="ln174">    nptr = -1; </a>
<a name="ln175">    /*</a>
<a name="ln176">     * if we didn't find any blocks in the memory,</a>
<a name="ln177">     * put the prefered template in place</a>
<a name="ln178">     */</a>
<a name="ln179">    if (nptr &lt; 0) {</a>
<a name="ln180">        AH9300(ah)-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln181">        AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln182">        dptr = ar9300_eeprom_struct_default_find_by_id(</a>
<a name="ln183">            Ar9300_eeprom_template_preference);</a>
<a name="ln184">        if (dptr != 0) {</a>
<a name="ln185">            OS_MEMCPY(mptr, dptr, mdata_size);    </a>
<a name="ln186">            nptr = 0;</a>
<a name="ln187">        }</a>
<a name="ln188">    }</a>
<a name="ln189">    /*</a>
<a name="ln190">     * if we didn't find the prefered one,</a>
<a name="ln191">     * put the normal default template in place</a>
<a name="ln192">     */</a>
<a name="ln193">    if (nptr &lt; 0) {</a>
<a name="ln194">        AH9300(ah)-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln195">        AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln196">        dptr = ar9300_eeprom_struct_default_find_by_id(</a>
<a name="ln197">            ar9300_eeprom_template_default);</a>
<a name="ln198">        if (dptr != 0) {</a>
<a name="ln199">            OS_MEMCPY(mptr, dptr, mdata_size);    </a>
<a name="ln200">            nptr = 0;</a>
<a name="ln201">        }</a>
<a name="ln202">    }</a>
<a name="ln203">    /*</a>
<a name="ln204">     * if we can't find the best template, put any old template in place</a>
<a name="ln205">     * presume that newer ones are better, so search backwards</a>
<a name="ln206">     */</a>
<a name="ln207">    if (nptr &lt; 0) {</a>
<a name="ln208">        AH9300(ah)-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln209">        AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln210">        for (it = ar9300_eeprom_struct_default_many() - 1; it &gt;= 0; it--) {</a>
<a name="ln211">            dptr = ar9300_eeprom_struct_default(it);</a>
<a name="ln212">            if (dptr != 0) {</a>
<a name="ln213">                OS_MEMCPY(mptr, dptr, mdata_size);    </a>
<a name="ln214">                nptr = 0;</a>
<a name="ln215">                break;</a>
<a name="ln216">            }</a>
<a name="ln217">        }</a>
<a name="ln218">    }</a>
<a name="ln219">    return nptr;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">/*</a>
<a name="ln223"> * Read 16 bits of data from offset into *data</a>
<a name="ln224"> */</a>
<a name="ln225">HAL_BOOL</a>
<a name="ln226">ar9300_eeprom_read_word(struct ath_hal *ah, u_int off, u_int16_t *data)</a>
<a name="ln227">{</a>
<a name="ln228">    if (AR_SREV_OSPREY(ah) || AR_SREV_POSEIDON(ah))</a>
<a name="ln229">    {</a>
<a name="ln230">        (void) OS_REG_READ(ah, AR9300_EEPROM_OFFSET + (off &lt;&lt; AR9300_EEPROM_S));</a>
<a name="ln231">        if (!ath_hal_wait(ah,</a>
<a name="ln232">			  AR_HOSTIF_REG(ah, AR_EEPROM_STATUS_DATA),</a>
<a name="ln233">			  AR_EEPROM_STATUS_DATA_BUSY | AR_EEPROM_STATUS_DATA_PROT_ACCESS,</a>
<a name="ln234">			  0))</a>
<a name="ln235">	{</a>
<a name="ln236">            return AH_FALSE;</a>
<a name="ln237">	}</a>
<a name="ln238">        *data = MS(OS_REG_READ(ah,</a>
<a name="ln239">			       AR_HOSTIF_REG(ah, AR_EEPROM_STATUS_DATA)), AR_EEPROM_STATUS_DATA_VAL);</a>
<a name="ln240">       return AH_TRUE;</a>
<a name="ln241">    }</a>
<a name="ln242">    else</a>
<a name="ln243">    {</a>
<a name="ln244">        *data = 0;</a>
<a name="ln245">        return AH_FALSE;</a>
<a name="ln246">    }</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249"> </a>
<a name="ln250">HAL_BOOL</a>
<a name="ln251">ar9300_otp_read(struct ath_hal *ah, u_int off, u_int32_t *data, HAL_BOOL is_wifi)</a>
<a name="ln252">{</a>
<a name="ln253">    int time_out = 1000;</a>
<a name="ln254">    int status = 0;</a>
<a name="ln255">    u_int32_t addr;</a>
<a name="ln256"> </a>
<a name="ln257">    if (AR_SREV_HONEYBEE(ah)){ /* no OTP for Honeybee */</a>
<a name="ln258">        return false;</a>
<a name="ln259">    }</a>
<a name="ln260">    addr = (AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah))?</a>
<a name="ln261">        OTP_MEM_START_ADDRESS_WASP : OTP_MEM_START_ADDRESS;</a>
<a name="ln262">	if (!is_wifi) {</a>
<a name="ln263">        addr = BTOTP_MEM_START_ADDRESS;</a>
<a name="ln264">    }</a>
<a name="ln265">    addr += off * 4; /* OTP is 32 bit addressable */</a>
<a name="ln266">    (void) OS_REG_READ(ah, addr);</a>
<a name="ln267"> </a>
<a name="ln268">    addr = (AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah)) ?</a>
<a name="ln269">        OTP_STATUS0_OTP_SM_BUSY_WASP : OTP_STATUS0_OTP_SM_BUSY;</a>
<a name="ln270">	if (!is_wifi) {</a>
<a name="ln271">        addr = BTOTP_STATUS0_OTP_SM_BUSY;</a>
<a name="ln272">    }</a>
<a name="ln273">    while ((time_out &gt; 0) &amp;&amp; (!status)) { /* wait for access complete */</a>
<a name="ln274">        /* Read data valid, access not busy, sm not busy */</a>
<a name="ln275">        status = ((OS_REG_READ(ah, addr) &amp; 0x7) == 0x4) ? 1 : 0;</a>
<a name="ln276">        time_out--;</a>
<a name="ln277">    }</a>
<a name="ln278">    if (time_out == 0) {</a>
<a name="ln279">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln280">            &quot;%s: Timed out during OTP Status0 validation\n&quot;, __func__);</a>
<a name="ln281">        return AH_FALSE;</a>
<a name="ln282">    }</a>
<a name="ln283"> </a>
<a name="ln284">    addr = (AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah)) ?</a>
<a name="ln285">        OTP_STATUS1_EFUSE_READ_DATA_WASP : OTP_STATUS1_EFUSE_READ_DATA;</a>
<a name="ln286">	if (!is_wifi) {</a>
<a name="ln287">        addr = BTOTP_STATUS1_EFUSE_READ_DATA;</a>
<a name="ln288">    }</a>
<a name="ln289">    *data = OS_REG_READ(ah, addr);</a>
<a name="ln290">    return AH_TRUE;</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293"> </a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">static HAL_STATUS</a>
<a name="ln297">ar9300_flash_map(struct ath_hal *ah)</a>
<a name="ln298">{</a>
<a name="ln299">    /* XXX disable flash remapping for now (ie, SoC support) */</a>
<a name="ln300">    ath_hal_printf(ah, &quot;%s: unimplemented for now\n&quot;, __func__);</a>
<a name="ln301">#if 0</a>
<a name="ln302">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln303">#if defined(AR9100) || defined(__NetBSD__)</a>
<a name="ln304">    ahp-&gt;ah_cal_mem = OS_REMAP(ah, AR9300_EEPROM_START_ADDR, AR9300_EEPROM_MAX);</a>
<a name="ln305">#else</a>
<a name="ln306">    ahp-&gt;ah_cal_mem = OS_REMAP((uintptr_t)(AH_PRIVATE(ah)-&gt;ah_st),</a>
<a name="ln307">        (AR9300_EEPROM_MAX + AR9300_FLASH_CAL_START_OFFSET));</a>
<a name="ln308">#endif</a>
<a name="ln309">    if (!ahp-&gt;ah_cal_mem) {</a>
<a name="ln310">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln311">            &quot;%s: cannot remap eeprom region \n&quot;, __func__);</a>
<a name="ln312">        return HAL_EIO;</a>
<a name="ln313">    }</a>
<a name="ln314">#endif</a>
<a name="ln315">    return HAL_OK;</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">HAL_BOOL</a>
<a name="ln319">ar9300_flash_read(struct ath_hal *ah, u_int off, u_int16_t *data)</a>
<a name="ln320">{</a>
<a name="ln321">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln322"> </a>
<a name="ln323">    *data = ((u_int16_t *)ahp-&gt;ah_cal_mem)[off];</a>
<a name="ln324">    return AH_TRUE;</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">HAL_BOOL</a>
<a name="ln328">ar9300_flash_write(struct ath_hal *ah, u_int off, u_int16_t data)</a>
<a name="ln329">{</a>
<a name="ln330">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln331"> </a>
<a name="ln332">    ((u_int16_t *)ahp-&gt;ah_cal_mem)[off] = data;</a>
<a name="ln333">    return AH_TRUE;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">HAL_STATUS</a>
<a name="ln337">ar9300_eeprom_attach(struct ath_hal *ah)</a>
<a name="ln338">{</a>
<a name="ln339">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln340">    ahp-&gt;try_dram = 1;</a>
<a name="ln341">    ahp-&gt;try_eeprom = 1;</a>
<a name="ln342">    ahp-&gt;try_otp = 1;</a>
<a name="ln343">#ifdef ATH_CAL_NAND_FLASH</a>
<a name="ln344">    ahp-&gt;try_nand = 1;</a>
<a name="ln345">#else</a>
<a name="ln346">    ahp-&gt;try_flash = 1;</a>
<a name="ln347">#endif</a>
<a name="ln348">    ahp-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln349">    ahp-&gt;calibration_data_source_address = 0;</a>
<a name="ln350">    ahp-&gt;calibration_data_try = calibration_data_try;</a>
<a name="ln351">    ahp-&gt;calibration_data_try_address = 0;</a>
<a name="ln352"> </a>
<a name="ln353">    /*</a>
<a name="ln354">     * In case flash will be used for EEPROM. Otherwise ahp-&gt;ah_cal_mem</a>
<a name="ln355">     * must be set to NULL or the real EEPROM address.</a>
<a name="ln356">     */</a>
<a name="ln357">    ar9300_flash_map(ah);</a>
<a name="ln358">    /*</a>
<a name="ln359">     * ###### This function always return NO SPUR.</a>
<a name="ln360">     * This is not true for many board designs.</a>
<a name="ln361">     * Does anyone use this?</a>
<a name="ln362">     */</a>
<a name="ln363">    AH_PRIVATE(ah)-&gt;ah_getSpurChan = ar9300_eeprom_get_spur_chan;</a>
<a name="ln364"> </a>
<a name="ln365">#ifdef OLDCODE</a>
<a name="ln366">    /* XXX Needs to be moved for dynamic selection */</a>
<a name="ln367">    ahp-&gt;ah_eeprom = *(default9300[ar9300_eeprom_template_default]);</a>
<a name="ln368"> </a>
<a name="ln369"> </a>
<a name="ln370">    if (AR_SREV_HORNET(ah)) {</a>
<a name="ln371">        /* Set default values for Hornet. */</a>
<a name="ln372">        ahp-&gt;ah_eeprom.base_eep_header.op_cap_flags.op_flags =</a>
<a name="ln373">            AR9300_OPFLAGS_11G;</a>
<a name="ln374">        ahp-&gt;ah_eeprom.base_eep_header.txrx_mask = 0x11;</a>
<a name="ln375">    } else if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln376">        /* Set default values for Poseidon. */</a>
<a name="ln377">        ahp-&gt;ah_eeprom.base_eep_header.op_cap_flags.op_flags =</a>
<a name="ln378">            AR9300_OPFLAGS_11G;</a>
<a name="ln379">        ahp-&gt;ah_eeprom.base_eep_header.txrx_mask = 0x11;</a>
<a name="ln380">    }</a>
<a name="ln381"> </a>
<a name="ln382">    if (AH_PRIVATE(ah)-&gt;ah_config.ath_hal_skip_eeprom_read) {</a>
<a name="ln383">        ahp-&gt;ah_emu_eeprom = 1;</a>
<a name="ln384">        return HAL_OK;</a>
<a name="ln385">    }</a>
<a name="ln386"> </a>
<a name="ln387">    ahp-&gt;ah_emu_eeprom = 1;</a>
<a name="ln388"> </a>
<a name="ln389">#ifdef UNUSED</a>
<a name="ln390">#endif</a>
<a name="ln391">    </a>
<a name="ln392">    if (!ar9300_fill_eeprom(ah)) {</a>
<a name="ln393">        return HAL_EIO;</a>
<a name="ln394">    }</a>
<a name="ln395"> </a>
<a name="ln396">    return HAL_OK;</a>
<a name="ln397">    /* return ar9300_check_eeprom(ah); */</a>
<a name="ln398">#else</a>
<a name="ln399">    ahp-&gt;ah_emu_eeprom = 1;</a>
<a name="ln400"> </a>
<a name="ln401">#if 0</a>
<a name="ln402">/*#ifdef MDK_AP*/ /* MDK_AP is defined only in NART AP build */</a>
<a name="ln403">    u_int8_t buffer[10];</a>
<a name="ln404">    int caldata_check = 0;</a>
<a name="ln405"> </a>
<a name="ln406">    ar9300_calibration_data_read_flash(</a>
<a name="ln407">        ah, FLASH_BASE_CALDATA_OFFSET, buffer, 4);</a>
<a name="ln408">    printf(&quot;flash caldata:: %x\n&quot;, buffer[0]);</a>
<a name="ln409">    if (buffer[0] != 0xff) {</a>
<a name="ln410">        caldata_check = 1;</a>
<a name="ln411">    }</a>
<a name="ln412">    if (!caldata_check) {</a>
<a name="ln413">        ar9300_eeprom_t *mptr;</a>
<a name="ln414">        int mdata_size;</a>
<a name="ln415">        if (AR_SREV_HORNET(ah)) {</a>
<a name="ln416">            /* XXX: For initial testing */</a>
<a name="ln417">            mptr = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln418">            mdata_size = ar9300_eeprom_struct_size();</a>
<a name="ln419">            ahp-&gt;ah_eeprom = ar9300_template_ap121;</a>
<a name="ln420">            ahp-&gt;ah_emu_eeprom = 1;</a>
<a name="ln421">            /* need it to let art save in to flash ????? */</a>
<a name="ln422">            calibration_data_source = calibration_data_flash;</a>
<a name="ln423">        } else if (AR_SREV_WASP(ah)) {</a>
<a name="ln424">            /* XXX: For initial testing */</a>
<a name="ln425">            ath_hal_printf(ah, &quot; wasp eep attach\n&quot;);</a>
<a name="ln426">            mptr = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln427">            mdata_size = ar9300_eeprom_struct_size();</a>
<a name="ln428">            ahp-&gt;ah_eeprom = ar9300_template_generic;</a>
<a name="ln429">            ahp-&gt;ah_eeprom.mac_addr[0] = 0x00;</a>
<a name="ln430">            ahp-&gt;ah_eeprom.mac_addr[1] = 0x03;</a>
<a name="ln431">            ahp-&gt;ah_eeprom.mac_addr[2] = 0x7F;</a>
<a name="ln432">            ahp-&gt;ah_eeprom.mac_addr[3] = 0xBA;</a>
<a name="ln433">            ahp-&gt;ah_eeprom.mac_addr[4] = 0xD0;</a>
<a name="ln434">            ahp-&gt;ah_eeprom.mac_addr[5] = 0x00;</a>
<a name="ln435">            ahp-&gt;ah_emu_eeprom = 1;</a>
<a name="ln436">            ahp-&gt;ah_eeprom.base_eep_header.txrx_mask = 0x33;</a>
<a name="ln437">            ahp-&gt;ah_eeprom.base_eep_header.txrxgain = 0x10;</a>
<a name="ln438">            /* need it to let art save in to flash ????? */</a>
<a name="ln439">            calibration_data_source = calibration_data_flash;</a>
<a name="ln440">        }</a>
<a name="ln441">        return HAL_OK;</a>
<a name="ln442">    }</a>
<a name="ln443">#endif</a>
<a name="ln444">    if (AR_SREV_HORNET(ah) || AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah)</a>
<a name="ln445">        || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln446">        ahp-&gt;try_eeprom = 0;</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">    if (AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln450">        ahp-&gt;try_otp = 0;</a>
<a name="ln451">    }</a>
<a name="ln452"> </a>
<a name="ln453">    if (!ar9300_eeprom_restore(ah)) {</a>
<a name="ln454">        return HAL_EIO;</a>
<a name="ln455">    }</a>
<a name="ln456">    return HAL_OK;</a>
<a name="ln457">#endif</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">u_int32_t</a>
<a name="ln461">ar9300_eeprom_get(struct ath_hal_9300 *ahp, EEPROM_PARAM param)</a>
<a name="ln462">{</a>
<a name="ln463">    ar9300_eeprom_t *eep = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln464">    OSPREY_BASE_EEP_HEADER *p_base = &amp;eep-&gt;base_eep_header;</a>
<a name="ln465">    OSPREY_BASE_EXTENSION_1 *base_ext1 = &amp;eep-&gt;base_ext1;</a>
<a name="ln466"> </a>
<a name="ln467">    switch (param) {</a>
<a name="ln468">#ifdef NOTYET</a>
<a name="ln469">    case EEP_NFTHRESH_5:</a>
<a name="ln470">        return p_modal[0].noise_floor_thresh_ch[0];</a>
<a name="ln471">    case EEP_NFTHRESH_2:</a>
<a name="ln472">        return p_modal[1].noise_floor_thresh_ch[0];</a>
<a name="ln473">#endif</a>
<a name="ln474">    case EEP_MAC_LSW:</a>
<a name="ln475">        return eep-&gt;mac_addr[0] &lt;&lt; 8 | eep-&gt;mac_addr[1];</a>
<a name="ln476">    case EEP_MAC_MID:</a>
<a name="ln477">        return eep-&gt;mac_addr[2] &lt;&lt; 8 | eep-&gt;mac_addr[3];</a>
<a name="ln478">    case EEP_MAC_MSW:</a>
<a name="ln479">        return eep-&gt;mac_addr[4] &lt;&lt; 8 | eep-&gt;mac_addr[5];</a>
<a name="ln480">    case EEP_REG_0:</a>
<a name="ln481">        return p_base-&gt;reg_dmn[0];</a>
<a name="ln482">    case EEP_REG_1:</a>
<a name="ln483">        return p_base-&gt;reg_dmn[1];</a>
<a name="ln484">    case EEP_OP_CAP:</a>
<a name="ln485">        return p_base-&gt;device_cap;</a>
<a name="ln486">    case EEP_OP_MODE:</a>
<a name="ln487">        return p_base-&gt;op_cap_flags.op_flags;</a>
<a name="ln488">    case EEP_RF_SILENT:</a>
<a name="ln489">        return p_base-&gt;rf_silent;</a>
<a name="ln490">#ifdef NOTYET</a>
<a name="ln491">    case EEP_OB_5:</a>
<a name="ln492">        return p_modal[0].ob;</a>
<a name="ln493">    case EEP_DB_5:</a>
<a name="ln494">        return p_modal[0].db;</a>
<a name="ln495">    case EEP_OB_2:</a>
<a name="ln496">        return p_modal[1].ob;</a>
<a name="ln497">    case EEP_DB_2:</a>
<a name="ln498">        return p_modal[1].db;</a>
<a name="ln499">    case EEP_MINOR_REV:</a>
<a name="ln500">        return p_base-&gt;eeprom_version &amp; AR9300_EEP_VER_MINOR_MASK;</a>
<a name="ln501">#endif</a>
<a name="ln502">    case EEP_TX_MASK:</a>
<a name="ln503">        return (p_base-&gt;txrx_mask &gt;&gt; 4) &amp; 0xf;</a>
<a name="ln504">    case EEP_RX_MASK:</a>
<a name="ln505">        return p_base-&gt;txrx_mask &amp; 0xf;</a>
<a name="ln506">#ifdef NOTYET</a>
<a name="ln507">    case EEP_FSTCLK_5G:</a>
<a name="ln508">        return p_base-&gt;fast_clk5g;</a>
<a name="ln509">    case EEP_RXGAIN_TYPE:</a>
<a name="ln510">        return p_base-&gt;rx_gain_type;</a>
<a name="ln511">#endif</a>
<a name="ln512">    case EEP_DRIVE_STRENGTH:</a>
<a name="ln513">#define AR9300_EEP_BASE_DRIVE_STRENGTH    0x1 </a>
<a name="ln514">        return p_base-&gt;misc_configuration &amp; AR9300_EEP_BASE_DRIVE_STRENGTH;</a>
<a name="ln515">    case EEP_INTERNAL_REGULATOR:</a>
<a name="ln516">        /* Bit 4 is internal regulator flag */</a>
<a name="ln517">        return ((p_base-&gt;feature_enable &amp; 0x10) &gt;&gt; 4);</a>
<a name="ln518">    case EEP_SWREG:</a>
<a name="ln519">        return (p_base-&gt;swreg);</a>
<a name="ln520">    case EEP_PAPRD_ENABLED:</a>
<a name="ln521">        /* Bit 5 is paprd flag */</a>
<a name="ln522">        return ((p_base-&gt;feature_enable &amp; 0x20) &gt;&gt; 5);</a>
<a name="ln523">    case EEP_ANTDIV_control:</a>
<a name="ln524">        return (u_int32_t)(base_ext1-&gt;ant_div_control);</a>
<a name="ln525">    case EEP_CHAIN_MASK_REDUCE:</a>
<a name="ln526">        return ((p_base-&gt;misc_configuration &gt;&gt; 3) &amp; 0x1);</a>
<a name="ln527">    case EEP_OL_PWRCTRL:</a>
<a name="ln528">        return 0;</a>
<a name="ln529">     case EEP_DEV_TYPE:</a>
<a name="ln530">        return p_base-&gt;device_type;</a>
<a name="ln531">    default:</a>
<a name="ln532">        HALASSERT(0);</a>
<a name="ln533">        return 0;</a>
<a name="ln534">    }</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">/******************************************************************************/</a>
<a name="ln540">/*!</a>
<a name="ln541">**  \brief EEPROM fixup code for INI values</a>
<a name="ln542">**</a>
<a name="ln543">** This routine provides a place to insert &quot;fixup&quot; code for specific devices</a>
<a name="ln544">** that need to modify INI values based on EEPROM values, BEFORE the INI values</a>
<a name="ln545">** are written.</a>
<a name="ln546">** Certain registers in the INI file can only be written once without</a>
<a name="ln547">** undesired side effects, and this provides a place for EEPROM overrides</a>
<a name="ln548">** in these cases.</a>
<a name="ln549">**</a>
<a name="ln550">** This is called at attach time once.  It should not affect run time</a>
<a name="ln551">** performance at all</a>
<a name="ln552">**</a>
<a name="ln553">**  \param ah       Pointer to HAL object (this)</a>
<a name="ln554">**  \param p_eep_data Pointer to (filled in) eeprom data structure</a>
<a name="ln555">**  \param reg      register being inspected on this call</a>
<a name="ln556">**  \param value    value in INI file</a>
<a name="ln557">**</a>
<a name="ln558">**  \return Updated value for INI file.</a>
<a name="ln559">*/</a>
<a name="ln560">u_int32_t</a>
<a name="ln561">ar9300_ini_fixup(struct ath_hal *ah, ar9300_eeprom_t *p_eep_data,</a>
<a name="ln562">    u_int32_t reg, u_int32_t value)</a>
<a name="ln563">{</a>
<a name="ln564">    HALDEBUG(AH_NULL, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln565">        &quot;ar9300_eeprom_def_ini_fixup: FIXME\n&quot;);</a>
<a name="ln566">#if 0</a>
<a name="ln567">    BASE_EEPDEF_HEADER  *p_base  = &amp;(p_eep_data-&gt;base_eep_header);</a>
<a name="ln568"> </a>
<a name="ln569">    switch (AH_PRIVATE(ah)-&gt;ah_devid)</a>
<a name="ln570">    {</a>
<a name="ln571">    case AR9300_DEVID_AR9300_PCI:</a>
<a name="ln572">        /*</a>
<a name="ln573">        ** Need to set the external/internal regulator bit to the proper value.</a>
<a name="ln574">        ** Can only write this ONCE.</a>
<a name="ln575">        */</a>
<a name="ln576"> </a>
<a name="ln577">        if ( reg == 0x7894 )</a>
<a name="ln578">        {</a>
<a name="ln579">            /*</a>
<a name="ln580">            ** Check for an EEPROM data structure of &quot;0x0b&quot; or better</a>
<a name="ln581">            */</a>
<a name="ln582"> </a>
<a name="ln583">            HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;ini VAL: %x  EEPROM: %x\n&quot;,</a>
<a name="ln584">                     value, (p_base-&gt;version &amp; 0xff));</a>
<a name="ln585"> </a>
<a name="ln586">            if ( (p_base-&gt;version &amp; 0xff) &gt; 0x0a) {</a>
<a name="ln587">                HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln588">                    &quot;PWDCLKIND: %d\n&quot;, p_base-&gt;pwdclkind);</a>
<a name="ln589">                value &amp;= ~AR_AN_TOP2_PWDCLKIND;</a>
<a name="ln590">                value |=</a>
<a name="ln591">                    AR_AN_TOP2_PWDCLKIND &amp;</a>
<a name="ln592">                    (p_base-&gt;pwdclkind &lt;&lt;  AR_AN_TOP2_PWDCLKIND_S);</a>
<a name="ln593">            } else {</a>
<a name="ln594">                HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;PWDCLKIND Earlier Rev\n&quot;);</a>
<a name="ln595">            }</a>
<a name="ln596"> </a>
<a name="ln597">            HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;final ini VAL: %x\n&quot;, value);</a>
<a name="ln598">        }</a>
<a name="ln599">        break;</a>
<a name="ln600"> </a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">    return (value);</a>
<a name="ln604">#else</a>
<a name="ln605">    return 0;</a>
<a name="ln606">#endif</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">/*</a>
<a name="ln610"> * Returns the interpolated y value corresponding to the specified x value</a>
<a name="ln611"> * from the np ordered pairs of data (px,py).</a>
<a name="ln612"> * The pairs do not have to be in any order.</a>
<a name="ln613"> * If the specified x value is less than any of the px,</a>
<a name="ln614"> * the returned y value is equal to the py for the lowest px.</a>
<a name="ln615"> * If the specified x value is greater than any of the px,</a>
<a name="ln616"> * the returned y value is equal to the py for the highest px.</a>
<a name="ln617"> */</a>
<a name="ln618">static int</a>
<a name="ln619">interpolate(int32_t x, int32_t *px, int32_t *py, u_int16_t np)</a>
<a name="ln620">{</a>
<a name="ln621">    int ip = 0;</a>
<a name="ln622">    int lx = 0, ly = 0, lhave = 0;</a>
<a name="ln623">    int hx = 0, hy = 0, hhave = 0;</a>
<a name="ln624">    int dx = 0;</a>
<a name="ln625">    int y = 0;</a>
<a name="ln626">    int bf, factor, plus;</a>
<a name="ln627"> </a>
<a name="ln628">    lhave = 0;</a>
<a name="ln629">    hhave = 0;</a>
<a name="ln630">    /*</a>
<a name="ln631">     * identify best lower and higher x calibration measurement</a>
<a name="ln632">     */</a>
<a name="ln633">    for (ip = 0; ip &lt; np; ip++) {</a>
<a name="ln634">        dx = x - px[ip];</a>
<a name="ln635">        /* this measurement is higher than our desired x */</a>
<a name="ln636">        if (dx &lt;= 0) {</a>
<a name="ln637">            if (!hhave || dx &gt; (x - hx)) {</a>
<a name="ln638">                /* new best higher x measurement */</a>
<a name="ln639">                hx = px[ip];</a>
<a name="ln640">                hy = py[ip];</a>
<a name="ln641">                hhave = 1;</a>
<a name="ln642">            }</a>
<a name="ln643">        }</a>
<a name="ln644">        /* this measurement is lower than our desired x */</a>
<a name="ln645">        if (dx &gt;= 0) {</a>
<a name="ln646">            if (!lhave || dx &lt; (x - lx)) {</a>
<a name="ln647">                /* new best lower x measurement */</a>
<a name="ln648">                lx = px[ip];</a>
<a name="ln649">                ly = py[ip];</a>
<a name="ln650">                lhave = 1;</a>
<a name="ln651">            }</a>
<a name="ln652">        }</a>
<a name="ln653">    }</a>
<a name="ln654">    /* the low x is good */</a>
<a name="ln655">    if (lhave) {</a>
<a name="ln656">        /* so is the high x */</a>
<a name="ln657">        if (hhave) {</a>
<a name="ln658">            /* they're the same, so just pick one */</a>
<a name="ln659">            if (hx == lx) {</a>
<a name="ln660">                y = ly;</a>
<a name="ln661">            } else {</a>
<a name="ln662">                /* interpolate with round off */</a>
<a name="ln663">                bf = (2 * (hy - ly) * (x - lx)) / (hx - lx);</a>
<a name="ln664">                plus = (bf % 2);</a>
<a name="ln665">                factor = bf / 2;</a>
<a name="ln666">                y = ly + factor + plus;</a>
<a name="ln667">            }</a>
<a name="ln668">        } else {</a>
<a name="ln669">            /* only low is good, use it */</a>
<a name="ln670">            y = ly;</a>
<a name="ln671">        }</a>
<a name="ln672">    } else if (hhave) {</a>
<a name="ln673">        /* only high is good, use it */</a>
<a name="ln674">        y = hy;</a>
<a name="ln675">    } else {</a>
<a name="ln676">        /* nothing is good,this should never happen unless np=0, ????  */</a>
<a name="ln677">        y = -(1 &lt;&lt; 30);</a>
<a name="ln678">    }</a>
<a name="ln679"> </a>
<a name="ln680">    return y;</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">u_int8_t</a>
<a name="ln684">ar9300_eeprom_get_legacy_trgt_pwr(struct ath_hal *ah, u_int16_t rate_index,</a>
<a name="ln685">    u_int16_t freq, HAL_BOOL is_2ghz)</a>
<a name="ln686">{</a>
<a name="ln687">    u_int16_t            num_piers, i;</a>
<a name="ln688">    int32_t              target_power_array[OSPREY_NUM_5G_20_TARGET_POWERS];</a>
<a name="ln689">    int32_t              freq_array[OSPREY_NUM_5G_20_TARGET_POWERS]; </a>
<a name="ln690">    u_int8_t             *p_freq_bin;</a>
<a name="ln691">    ar9300_eeprom_t      *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln692">    CAL_TARGET_POWER_LEG *p_eeprom_target_pwr;</a>
<a name="ln693"> </a>
<a name="ln694">    if (is_2ghz) {</a>
<a name="ln695">        num_piers = OSPREY_NUM_2G_20_TARGET_POWERS;    </a>
<a name="ln696">        p_eeprom_target_pwr = eep-&gt;cal_target_power_2g;</a>
<a name="ln697">        p_freq_bin = eep-&gt;cal_target_freqbin_2g;</a>
<a name="ln698">    } else {</a>
<a name="ln699">        num_piers = OSPREY_NUM_5G_20_TARGET_POWERS;</a>
<a name="ln700">        p_eeprom_target_pwr = eep-&gt;cal_target_power_5g;</a>
<a name="ln701">        p_freq_bin = eep-&gt;cal_target_freqbin_5g;</a>
<a name="ln702">   }</a>
<a name="ln703"> </a>
<a name="ln704">    /*</a>
<a name="ln705">     * create array of channels and targetpower from</a>
<a name="ln706">     * targetpower piers stored on eeprom</a>
<a name="ln707">     */</a>
<a name="ln708">    for (i = 0; i &lt; num_piers; i++) {</a>
<a name="ln709">        freq_array[i] = FBIN2FREQ(p_freq_bin[i], is_2ghz);</a>
<a name="ln710">        target_power_array[i] = p_eeprom_target_pwr[i].t_pow2x[rate_index];</a>
<a name="ln711">    }</a>
<a name="ln712"> </a>
<a name="ln713">    /* interpolate to get target power for given frequency */</a>
<a name="ln714">    return</a>
<a name="ln715">        ((u_int8_t)interpolate(</a>
<a name="ln716">            (int32_t)freq, freq_array, target_power_array, num_piers));</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719">u_int8_t</a>
<a name="ln720">ar9300_eeprom_get_ht20_trgt_pwr(struct ath_hal *ah, u_int16_t rate_index,</a>
<a name="ln721">    u_int16_t freq, HAL_BOOL is_2ghz)</a>
<a name="ln722">{</a>
<a name="ln723">    u_int16_t               num_piers, i;</a>
<a name="ln724">    int32_t                 target_power_array[OSPREY_NUM_5G_20_TARGET_POWERS];</a>
<a name="ln725">    int32_t                 freq_array[OSPREY_NUM_5G_20_TARGET_POWERS]; </a>
<a name="ln726">    u_int8_t                *p_freq_bin;</a>
<a name="ln727">    ar9300_eeprom_t         *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln728">    OSP_CAL_TARGET_POWER_HT *p_eeprom_target_pwr;</a>
<a name="ln729"> </a>
<a name="ln730">    if (is_2ghz) {</a>
<a name="ln731">        num_piers = OSPREY_NUM_2G_20_TARGET_POWERS;    </a>
<a name="ln732">        p_eeprom_target_pwr = eep-&gt;cal_target_power_2g_ht20;</a>
<a name="ln733">        p_freq_bin = eep-&gt;cal_target_freqbin_2g_ht20;</a>
<a name="ln734">    } else {</a>
<a name="ln735">        num_piers = OSPREY_NUM_5G_20_TARGET_POWERS;</a>
<a name="ln736">        p_eeprom_target_pwr = eep-&gt;cal_target_power_5g_ht20;</a>
<a name="ln737">        p_freq_bin = eep-&gt;cal_target_freqbin_5g_ht20;</a>
<a name="ln738">    }</a>
<a name="ln739"> </a>
<a name="ln740">    /*</a>
<a name="ln741">     * create array of channels and targetpower from</a>
<a name="ln742">     * targetpower piers stored on eeprom</a>
<a name="ln743">     */</a>
<a name="ln744">    for (i = 0; i &lt; num_piers; i++) {</a>
<a name="ln745">        freq_array[i] = FBIN2FREQ(p_freq_bin[i], is_2ghz);</a>
<a name="ln746">        target_power_array[i] = p_eeprom_target_pwr[i].t_pow2x[rate_index];</a>
<a name="ln747">    }</a>
<a name="ln748"> </a>
<a name="ln749">    /* interpolate to get target power for given frequency */</a>
<a name="ln750">    return</a>
<a name="ln751">        ((u_int8_t)interpolate(</a>
<a name="ln752">            (int32_t)freq, freq_array, target_power_array, num_piers));</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">u_int8_t</a>
<a name="ln756">ar9300_eeprom_get_ht40_trgt_pwr(struct ath_hal *ah, u_int16_t rate_index,</a>
<a name="ln757">    u_int16_t freq, HAL_BOOL is_2ghz)</a>
<a name="ln758">{</a>
<a name="ln759">    u_int16_t               num_piers, i;</a>
<a name="ln760">    int32_t                 target_power_array[OSPREY_NUM_5G_40_TARGET_POWERS];</a>
<a name="ln761">    int32_t                 freq_array[OSPREY_NUM_5G_40_TARGET_POWERS]; </a>
<a name="ln762">    u_int8_t                *p_freq_bin;</a>
<a name="ln763">    ar9300_eeprom_t         *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln764">    OSP_CAL_TARGET_POWER_HT *p_eeprom_target_pwr;</a>
<a name="ln765"> </a>
<a name="ln766">    if (is_2ghz) {</a>
<a name="ln767">        num_piers = OSPREY_NUM_2G_40_TARGET_POWERS;    </a>
<a name="ln768">        p_eeprom_target_pwr = eep-&gt;cal_target_power_2g_ht40;</a>
<a name="ln769">        p_freq_bin = eep-&gt;cal_target_freqbin_2g_ht40;</a>
<a name="ln770">    } else {</a>
<a name="ln771">        num_piers = OSPREY_NUM_5G_40_TARGET_POWERS;</a>
<a name="ln772">        p_eeprom_target_pwr = eep-&gt;cal_target_power_5g_ht40;</a>
<a name="ln773">        p_freq_bin = eep-&gt;cal_target_freqbin_5g_ht40;</a>
<a name="ln774">    }</a>
<a name="ln775"> </a>
<a name="ln776">    /*</a>
<a name="ln777">     * create array of channels and targetpower from</a>
<a name="ln778">     * targetpower piers stored on eeprom</a>
<a name="ln779">     */</a>
<a name="ln780">    for (i = 0; i &lt; num_piers; i++) {</a>
<a name="ln781">        freq_array[i] = FBIN2FREQ(p_freq_bin[i], is_2ghz);</a>
<a name="ln782">        target_power_array[i] = p_eeprom_target_pwr[i].t_pow2x[rate_index];</a>
<a name="ln783">    }</a>
<a name="ln784"> </a>
<a name="ln785">    /* interpolate to get target power for given frequency */</a>
<a name="ln786">    return</a>
<a name="ln787">        ((u_int8_t)interpolate(</a>
<a name="ln788">            (int32_t)freq, freq_array, target_power_array, num_piers));</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">u_int8_t</a>
<a name="ln792">ar9300_eeprom_get_cck_trgt_pwr(struct ath_hal *ah, u_int16_t rate_index,</a>
<a name="ln793">    u_int16_t freq)</a>
<a name="ln794">{</a>
<a name="ln795">    u_int16_t            num_piers = OSPREY_NUM_2G_CCK_TARGET_POWERS, i;</a>
<a name="ln796">    int32_t              target_power_array[OSPREY_NUM_2G_CCK_TARGET_POWERS];</a>
<a name="ln797">    int32_t              freq_array[OSPREY_NUM_2G_CCK_TARGET_POWERS]; </a>
<a name="ln798">    ar9300_eeprom_t      *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln799">    u_int8_t             *p_freq_bin = eep-&gt;cal_target_freqbin_cck;</a>
<a name="ln800">    CAL_TARGET_POWER_LEG *p_eeprom_target_pwr = eep-&gt;cal_target_power_cck;</a>
<a name="ln801"> </a>
<a name="ln802">    /*</a>
<a name="ln803">     * create array of channels and targetpower from</a>
<a name="ln804">     * targetpower piers stored on eeprom</a>
<a name="ln805">     */</a>
<a name="ln806">    for (i = 0; i &lt; num_piers; i++) {</a>
<a name="ln807">        freq_array[i] = FBIN2FREQ(p_freq_bin[i], 1);</a>
<a name="ln808">        target_power_array[i] = p_eeprom_target_pwr[i].t_pow2x[rate_index];</a>
<a name="ln809">    }</a>
<a name="ln810"> </a>
<a name="ln811">    /* interpolate to get target power for given frequency */</a>
<a name="ln812">    return</a>
<a name="ln813">        ((u_int8_t)interpolate(</a>
<a name="ln814">            (int32_t)freq, freq_array, target_power_array, num_piers));</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">/*</a>
<a name="ln818"> * Set tx power registers to array of values passed in</a>
<a name="ln819"> */</a>
<a name="ln820">int</a>
<a name="ln821">ar9300_transmit_power_reg_write(struct ath_hal *ah, u_int8_t *p_pwr_array) </a>
<a name="ln822">{   </a>
<a name="ln823">#define POW_SM(_r, _s)     (((_r) &amp; 0x3f) &lt;&lt; (_s))</a>
<a name="ln824">    /* make sure forced gain is not set */</a>
<a name="ln825">#if 0</a>
<a name="ln826">    field_write(&quot;force_dac_gain&quot;, 0);</a>
<a name="ln827">    OS_REG_WRITE(ah, 0xa3f8, 0);</a>
<a name="ln828">    field_write(&quot;force_tx_gain&quot;, 0);</a>
<a name="ln829">#endif</a>
<a name="ln830"> </a>
<a name="ln831">    OS_REG_WRITE(ah, 0xa458, 0);</a>
<a name="ln832"> </a>
<a name="ln833">    /* Write the OFDM power per rate set */</a>
<a name="ln834">    /* 6 (LSB), 9, 12, 18 (MSB) */</a>
<a name="ln835">    OS_REG_WRITE(ah, 0xa3c0,</a>
<a name="ln836">        POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24], 24)</a>
<a name="ln837">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24], 16)</a>
<a name="ln838">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24],  8)</a>
<a name="ln839">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24],  0)</a>
<a name="ln840">    );</a>
<a name="ln841">    /* 24 (LSB), 36, 48, 54 (MSB) */</a>
<a name="ln842">    OS_REG_WRITE(ah, 0xa3c4,</a>
<a name="ln843">        POW_SM(p_pwr_array[ALL_TARGET_LEGACY_54], 24)</a>
<a name="ln844">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_48], 16)</a>
<a name="ln845">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_36],  8)</a>
<a name="ln846">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24],  0)</a>
<a name="ln847">    );</a>
<a name="ln848"> </a>
<a name="ln849">    /* Write the CCK power per rate set */</a>
<a name="ln850">    /* 1L (LSB), reserved, 2L, 2S (MSB) */  </a>
<a name="ln851">    OS_REG_WRITE(ah, 0xa3c8,</a>
<a name="ln852">        POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L], 24)</a>
<a name="ln853">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],  16)</a>
<a name="ln854">/*          | POW_SM(tx_power_times2,  8)*/ /* this is reserved for Osprey */</a>
<a name="ln855">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],   0)</a>
<a name="ln856">    );</a>
<a name="ln857">    /* 5.5L (LSB), 5.5S, 11L, 11S (MSB) */</a>
<a name="ln858">    OS_REG_WRITE(ah, 0xa3cc,</a>
<a name="ln859">        POW_SM(p_pwr_array[ALL_TARGET_LEGACY_11S], 24)</a>
<a name="ln860">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_11L], 16)</a>
<a name="ln861">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_5S],  8)</a>
<a name="ln862">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],  0)</a>
<a name="ln863">    );</a>
<a name="ln864"> </a>
<a name="ln865">	/* write the power for duplicated frames - HT40 */</a>
<a name="ln866">	/* dup40_cck (LSB), dup40_ofdm, ext20_cck, ext20_ofdm  (MSB) */</a>
<a name="ln867">    OS_REG_WRITE(ah, 0xa3e0,</a>
<a name="ln868">        POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24], 24)</a>
<a name="ln869">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L], 16)</a>
<a name="ln870">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_6_24],  8)</a>
<a name="ln871">          | POW_SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],  0)</a>
<a name="ln872">    );</a>
<a name="ln873"> </a>
<a name="ln874">    /* Write the HT20 power per rate set */</a>
<a name="ln875">    /* 0/8/16 (LSB), 1-3/9-11/17-19, 4, 5 (MSB) */</a>
<a name="ln876">    OS_REG_WRITE(ah, 0xa3d0,</a>
<a name="ln877">        POW_SM(p_pwr_array[ALL_TARGET_HT20_5], 24)</a>
<a name="ln878">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_4],  16)</a>
<a name="ln879">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_1_3_9_11_17_19],  8)</a>
<a name="ln880">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_0_8_16],   0)</a>
<a name="ln881">    );</a>
<a name="ln882">    </a>
<a name="ln883">    /* 6 (LSB), 7, 12, 13 (MSB) */</a>
<a name="ln884">    OS_REG_WRITE(ah, 0xa3d4,</a>
<a name="ln885">        POW_SM(p_pwr_array[ALL_TARGET_HT20_13], 24)</a>
<a name="ln886">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_12],  16)</a>
<a name="ln887">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_7],  8)</a>
<a name="ln888">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_6],   0)</a>
<a name="ln889">    );</a>
<a name="ln890"> </a>
<a name="ln891">    /* 14 (LSB), 15, 20, 21 */</a>
<a name="ln892">    OS_REG_WRITE(ah, 0xa3e4,</a>
<a name="ln893">        POW_SM(p_pwr_array[ALL_TARGET_HT20_21], 24)</a>
<a name="ln894">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_20],  16)</a>
<a name="ln895">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_15],  8)</a>
<a name="ln896">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_14],   0)</a>
<a name="ln897">    );</a>
<a name="ln898"> </a>
<a name="ln899">    /* Mixed HT20 and HT40 rates */</a>
<a name="ln900">    /* HT20 22 (LSB), HT20 23, HT40 22, HT40 23 (MSB) */</a>
<a name="ln901">    OS_REG_WRITE(ah, 0xa3e8,</a>
<a name="ln902">        POW_SM(p_pwr_array[ALL_TARGET_HT40_23], 24)</a>
<a name="ln903">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_22],  16)</a>
<a name="ln904">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_23],  8)</a>
<a name="ln905">          | POW_SM(p_pwr_array[ALL_TARGET_HT20_22],   0)</a>
<a name="ln906">    );</a>
<a name="ln907">    </a>
<a name="ln908">    /* Write the HT40 power per rate set */</a>
<a name="ln909">    /* correct PAR difference between HT40 and HT20/LEGACY */</a>
<a name="ln910">    /* 0/8/16 (LSB), 1-3/9-11/17-19, 4, 5 (MSB) */</a>
<a name="ln911">    OS_REG_WRITE(ah, 0xa3d8,</a>
<a name="ln912">        POW_SM(p_pwr_array[ALL_TARGET_HT40_5], 24)</a>
<a name="ln913">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_4],  16)</a>
<a name="ln914">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_1_3_9_11_17_19],  8)</a>
<a name="ln915">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_0_8_16],   0)</a>
<a name="ln916">    );</a>
<a name="ln917"> </a>
<a name="ln918">    /* 6 (LSB), 7, 12, 13 (MSB) */</a>
<a name="ln919">    OS_REG_WRITE(ah, 0xa3dc,</a>
<a name="ln920">        POW_SM(p_pwr_array[ALL_TARGET_HT40_13], 24)</a>
<a name="ln921">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_12],  16)</a>
<a name="ln922">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_7], 8)</a>
<a name="ln923">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_6], 0)</a>
<a name="ln924">    );</a>
<a name="ln925"> </a>
<a name="ln926">    /* 14 (LSB), 15, 20, 21 */</a>
<a name="ln927">    OS_REG_WRITE(ah, 0xa3ec,</a>
<a name="ln928">        POW_SM(p_pwr_array[ALL_TARGET_HT40_21], 24)</a>
<a name="ln929">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_20],  16)</a>
<a name="ln930">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_15],  8)</a>
<a name="ln931">          | POW_SM(p_pwr_array[ALL_TARGET_HT40_14],   0)</a>
<a name="ln932">    );</a>
<a name="ln933"> </a>
<a name="ln934">    return 0;</a>
<a name="ln935">#undef POW_SM    </a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">static void</a>
<a name="ln939">ar9300_selfgen_tpc_reg_write(struct ath_hal *ah, const struct ieee80211_channel *chan,</a>
<a name="ln940">                             u_int8_t *p_pwr_array) </a>
<a name="ln941">{</a>
<a name="ln942">    u_int32_t tpc_reg_val;</a>
<a name="ln943"> </a>
<a name="ln944">    /* Set the target power values for self generated frames (ACK,RTS/CTS) to</a>
<a name="ln945">     * be within limits. This is just a safety measure.With per packet TPC mode</a>
<a name="ln946">     * enabled the target power value used with self generated frames will be</a>
<a name="ln947">     * MIN( TPC reg, BB_powertx_rate register)</a>
<a name="ln948">     */</a>
<a name="ln949">    </a>
<a name="ln950">    if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln951">        tpc_reg_val = (SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L], AR_TPC_ACK) |</a>
<a name="ln952">                       SM(p_pwr_array[ALL_TARGET_LEGACY_1L_5L], AR_TPC_CTS) |</a>
<a name="ln953">                       SM(0x3f, AR_TPC_CHIRP) |</a>
<a name="ln954">                       SM(0x3f, AR_TPC_RPT));</a>
<a name="ln955">    } else {</a>
<a name="ln956">        tpc_reg_val = (SM(p_pwr_array[ALL_TARGET_LEGACY_6_24], AR_TPC_ACK) |</a>
<a name="ln957">                       SM(p_pwr_array[ALL_TARGET_LEGACY_6_24], AR_TPC_CTS) |</a>
<a name="ln958">                       SM(0x3f, AR_TPC_CHIRP) |</a>
<a name="ln959">                       SM(0x3f, AR_TPC_RPT));</a>
<a name="ln960">    }</a>
<a name="ln961">    OS_REG_WRITE(ah, AR_TPC, tpc_reg_val);</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">void</a>
<a name="ln965">ar9300_set_target_power_from_eeprom(struct ath_hal *ah, u_int16_t freq,</a>
<a name="ln966">    u_int8_t *target_power_val_t2)</a>
<a name="ln967">{</a>
<a name="ln968">    /* hard code for now, need to get from eeprom struct */</a>
<a name="ln969">    u_int8_t ht40_power_inc_for_pdadc = 0;</a>
<a name="ln970">    HAL_BOOL  is_2ghz = 0;</a>
<a name="ln971">    </a>
<a name="ln972">    if (freq &lt; 4000) {</a>
<a name="ln973">        is_2ghz = 1;</a>
<a name="ln974">    }</a>
<a name="ln975"> </a>
<a name="ln976">    target_power_val_t2[ALL_TARGET_LEGACY_6_24] =</a>
<a name="ln977">        ar9300_eeprom_get_legacy_trgt_pwr(</a>
<a name="ln978">            ah, LEGACY_TARGET_RATE_6_24, freq, is_2ghz);</a>
<a name="ln979">    target_power_val_t2[ALL_TARGET_LEGACY_36] =</a>
<a name="ln980">        ar9300_eeprom_get_legacy_trgt_pwr(</a>
<a name="ln981">            ah, LEGACY_TARGET_RATE_36, freq, is_2ghz);</a>
<a name="ln982">    target_power_val_t2[ALL_TARGET_LEGACY_48] =</a>
<a name="ln983">        ar9300_eeprom_get_legacy_trgt_pwr(</a>
<a name="ln984">            ah, LEGACY_TARGET_RATE_48, freq, is_2ghz);</a>
<a name="ln985">    target_power_val_t2[ALL_TARGET_LEGACY_54] =</a>
<a name="ln986">        ar9300_eeprom_get_legacy_trgt_pwr(</a>
<a name="ln987">            ah, LEGACY_TARGET_RATE_54, freq, is_2ghz);</a>
<a name="ln988">    target_power_val_t2[ALL_TARGET_LEGACY_1L_5L] =</a>
<a name="ln989">        ar9300_eeprom_get_cck_trgt_pwr(</a>
<a name="ln990">            ah, LEGACY_TARGET_RATE_1L_5L, freq);</a>
<a name="ln991">    target_power_val_t2[ALL_TARGET_LEGACY_5S] =</a>
<a name="ln992">        ar9300_eeprom_get_cck_trgt_pwr(</a>
<a name="ln993">            ah, LEGACY_TARGET_RATE_5S, freq);</a>
<a name="ln994">    target_power_val_t2[ALL_TARGET_LEGACY_11L] =</a>
<a name="ln995">        ar9300_eeprom_get_cck_trgt_pwr(</a>
<a name="ln996">            ah, LEGACY_TARGET_RATE_11L, freq);</a>
<a name="ln997">    target_power_val_t2[ALL_TARGET_LEGACY_11S] =</a>
<a name="ln998">        ar9300_eeprom_get_cck_trgt_pwr(</a>
<a name="ln999">            ah, LEGACY_TARGET_RATE_11S, freq);</a>
<a name="ln1000">    target_power_val_t2[ALL_TARGET_HT20_0_8_16] =</a>
<a name="ln1001">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1002">            ah, HT_TARGET_RATE_0_8_16, freq, is_2ghz);</a>
<a name="ln1003">    target_power_val_t2[ALL_TARGET_HT20_1_3_9_11_17_19] =</a>
<a name="ln1004">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1005">            ah, HT_TARGET_RATE_1_3_9_11_17_19, freq, is_2ghz);</a>
<a name="ln1006">    target_power_val_t2[ALL_TARGET_HT20_4] =</a>
<a name="ln1007">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1008">            ah, HT_TARGET_RATE_4, freq, is_2ghz);</a>
<a name="ln1009">    target_power_val_t2[ALL_TARGET_HT20_5] =</a>
<a name="ln1010">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1011">            ah, HT_TARGET_RATE_5, freq, is_2ghz);</a>
<a name="ln1012">    target_power_val_t2[ALL_TARGET_HT20_6] =</a>
<a name="ln1013">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1014">            ah, HT_TARGET_RATE_6, freq, is_2ghz);</a>
<a name="ln1015">    target_power_val_t2[ALL_TARGET_HT20_7] =</a>
<a name="ln1016">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1017">            ah, HT_TARGET_RATE_7, freq, is_2ghz);</a>
<a name="ln1018">    target_power_val_t2[ALL_TARGET_HT20_12] =</a>
<a name="ln1019">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1020">            ah, HT_TARGET_RATE_12, freq, is_2ghz);</a>
<a name="ln1021">    target_power_val_t2[ALL_TARGET_HT20_13] =</a>
<a name="ln1022">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1023">            ah, HT_TARGET_RATE_13, freq, is_2ghz);</a>
<a name="ln1024">    target_power_val_t2[ALL_TARGET_HT20_14] =</a>
<a name="ln1025">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1026">            ah, HT_TARGET_RATE_14, freq, is_2ghz);</a>
<a name="ln1027">    target_power_val_t2[ALL_TARGET_HT20_15] =</a>
<a name="ln1028">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1029">            ah, HT_TARGET_RATE_15, freq, is_2ghz);</a>
<a name="ln1030">    target_power_val_t2[ALL_TARGET_HT20_20] =</a>
<a name="ln1031">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1032">            ah, HT_TARGET_RATE_20, freq, is_2ghz);</a>
<a name="ln1033">    target_power_val_t2[ALL_TARGET_HT20_21] =</a>
<a name="ln1034">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1035">            ah, HT_TARGET_RATE_21, freq, is_2ghz);</a>
<a name="ln1036">    target_power_val_t2[ALL_TARGET_HT20_22] =</a>
<a name="ln1037">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1038">            ah, HT_TARGET_RATE_22, freq, is_2ghz);</a>
<a name="ln1039">    target_power_val_t2[ALL_TARGET_HT20_23] =</a>
<a name="ln1040">        ar9300_eeprom_get_ht20_trgt_pwr(</a>
<a name="ln1041">            ah, HT_TARGET_RATE_23, freq, is_2ghz);</a>
<a name="ln1042">    target_power_val_t2[ALL_TARGET_HT40_0_8_16] =</a>
<a name="ln1043">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1044">            ah, HT_TARGET_RATE_0_8_16, freq, is_2ghz) +</a>
<a name="ln1045">        ht40_power_inc_for_pdadc;</a>
<a name="ln1046">    target_power_val_t2[ALL_TARGET_HT40_1_3_9_11_17_19] =</a>
<a name="ln1047">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1048">            ah, HT_TARGET_RATE_1_3_9_11_17_19, freq, is_2ghz) +</a>
<a name="ln1049">        ht40_power_inc_for_pdadc;</a>
<a name="ln1050">    target_power_val_t2[ALL_TARGET_HT40_4] =</a>
<a name="ln1051">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1052">            ah, HT_TARGET_RATE_4, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1053">    target_power_val_t2[ALL_TARGET_HT40_5] =</a>
<a name="ln1054">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1055">            ah, HT_TARGET_RATE_5, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1056">    target_power_val_t2[ALL_TARGET_HT40_6] =</a>
<a name="ln1057">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1058">            ah, HT_TARGET_RATE_6, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1059">    target_power_val_t2[ALL_TARGET_HT40_7] =</a>
<a name="ln1060">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1061">            ah, HT_TARGET_RATE_7, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1062">    target_power_val_t2[ALL_TARGET_HT40_12] =</a>
<a name="ln1063">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1064">            ah, HT_TARGET_RATE_12, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1065">    target_power_val_t2[ALL_TARGET_HT40_13] =</a>
<a name="ln1066">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1067">            ah, HT_TARGET_RATE_13, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1068">    target_power_val_t2[ALL_TARGET_HT40_14] =</a>
<a name="ln1069">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1070">            ah, HT_TARGET_RATE_14, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1071">    target_power_val_t2[ALL_TARGET_HT40_15] =</a>
<a name="ln1072">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1073">            ah, HT_TARGET_RATE_15, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1074">    target_power_val_t2[ALL_TARGET_HT40_20] =</a>
<a name="ln1075">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1076">            ah, HT_TARGET_RATE_20, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1077">    target_power_val_t2[ALL_TARGET_HT40_21] =</a>
<a name="ln1078">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1079">            ah, HT_TARGET_RATE_21, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1080">    target_power_val_t2[ALL_TARGET_HT40_22] =</a>
<a name="ln1081">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1082">            ah, HT_TARGET_RATE_22, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1083">    target_power_val_t2[ALL_TARGET_HT40_23] =</a>
<a name="ln1084">        ar9300_eeprom_get_ht40_trgt_pwr(</a>
<a name="ln1085">            ah, HT_TARGET_RATE_23, freq, is_2ghz) + ht40_power_inc_for_pdadc;</a>
<a name="ln1086"> </a>
<a name="ln1087">#ifdef AH_DEBUG</a>
<a name="ln1088">    {</a>
<a name="ln1089">        int  i = 0;</a>
<a name="ln1090"> </a>
<a name="ln1091">        HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;%s: APPLYING TARGET POWERS\n&quot;, __func__);</a>
<a name="ln1092">        while (i &lt; ar9300_rate_size) {</a>
<a name="ln1093">            HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;%s: TPC[%02d] 0x%08x &quot;,</a>
<a name="ln1094">                     __func__, i, target_power_val_t2[i]);</a>
<a name="ln1095">            i++;</a>
<a name="ln1096">			if (i == ar9300_rate_size) {</a>
<a name="ln1097">                break;</a>
<a name="ln1098">			}</a>
<a name="ln1099">            HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;%s: TPC[%02d] 0x%08x &quot;,</a>
<a name="ln1100">                     __func__, i, target_power_val_t2[i]);</a>
<a name="ln1101">            i++;</a>
<a name="ln1102">			if (i == ar9300_rate_size) {</a>
<a name="ln1103">                break;</a>
<a name="ln1104">			}</a>
<a name="ln1105">            HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;%s: TPC[%02d] 0x%08x &quot;,</a>
<a name="ln1106">                     __func__, i, target_power_val_t2[i]);</a>
<a name="ln1107">            i++;</a>
<a name="ln1108">			if (i == ar9300_rate_size) {</a>
<a name="ln1109">                break;</a>
<a name="ln1110">			}</a>
<a name="ln1111">            HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;%s: TPC[%02d] 0x%08x \n&quot;,</a>
<a name="ln1112">                     __func__, i, target_power_val_t2[i]);</a>
<a name="ln1113">            i++;</a>
<a name="ln1114">        }</a>
<a name="ln1115">    }</a>
<a name="ln1116">#endif</a>
<a name="ln1117">} </a>
<a name="ln1118"> </a>
<a name="ln1119">u_int16_t *ar9300_regulatory_domain_get(struct ath_hal *ah)</a>
<a name="ln1120">{</a>
<a name="ln1121">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1122">    return eep-&gt;base_eep_header.reg_dmn;</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">int32_t </a>
<a name="ln1127">ar9300_eeprom_write_enable_gpio_get(struct ath_hal *ah)</a>
<a name="ln1128">{</a>
<a name="ln1129">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1130">    return eep-&gt;base_eep_header.eeprom_write_enable_gpio;</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">int32_t </a>
<a name="ln1134">ar9300_wlan_disable_gpio_get(struct ath_hal *ah)</a>
<a name="ln1135">{</a>
<a name="ln1136">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1137">    return eep-&gt;base_eep_header.wlan_disable_gpio;</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">int32_t </a>
<a name="ln1141">ar9300_wlan_led_gpio_get(struct ath_hal *ah)</a>
<a name="ln1142">{</a>
<a name="ln1143">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1144">    return eep-&gt;base_eep_header.wlan_led_gpio;</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147">int32_t </a>
<a name="ln1148">ar9300_rx_band_select_gpio_get(struct ath_hal *ah)</a>
<a name="ln1149">{</a>
<a name="ln1150">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1151">    return eep-&gt;base_eep_header.rx_band_select_gpio;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">/*</a>
<a name="ln1155"> * since valid noise floor values are negative, returns 1 on error</a>
<a name="ln1156"> */</a>
<a name="ln1157">int32_t</a>
<a name="ln1158">ar9300_noise_floor_cal_or_power_get(struct ath_hal *ah, int32_t frequency,</a>
<a name="ln1159">    int32_t ichain, HAL_BOOL use_cal)</a>
<a name="ln1160">{</a>
<a name="ln1161">    int     nf_use = 1; /* start with an error return value */</a>
<a name="ln1162">    int32_t fx[OSPREY_NUM_5G_CAL_PIERS + OSPREY_NUM_2G_CAL_PIERS];</a>
<a name="ln1163">    int32_t nf[OSPREY_NUM_5G_CAL_PIERS + OSPREY_NUM_2G_CAL_PIERS];</a>
<a name="ln1164">    int     nnf;</a>
<a name="ln1165">    int     is_2ghz;</a>
<a name="ln1166">    int     ipier, npier;</a>
<a name="ln1167">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1168">    u_int8_t        *p_cal_pier;</a>
<a name="ln1169">    OSP_CAL_DATA_PER_FREQ_OP_LOOP *p_cal_pier_struct;</a>
<a name="ln1170"> </a>
<a name="ln1171">    /*</a>
<a name="ln1172">     * check chain value</a>
<a name="ln1173">     */</a>
<a name="ln1174">    if (ichain &lt; 0 || ichain &gt;= OSPREY_MAX_CHAINS) {</a>
<a name="ln1175">        return 1;</a>
<a name="ln1176">    }</a>
<a name="ln1177"> </a>
<a name="ln1178">    /* figure out which band we're using */</a>
<a name="ln1179">    is_2ghz = (frequency &lt; 4000);</a>
<a name="ln1180">    if (is_2ghz) {</a>
<a name="ln1181">        npier = OSPREY_NUM_2G_CAL_PIERS;</a>
<a name="ln1182">        p_cal_pier = eep-&gt;cal_freq_pier_2g;</a>
<a name="ln1183">        p_cal_pier_struct = eep-&gt;cal_pier_data_2g[ichain];</a>
<a name="ln1184">    } else {</a>
<a name="ln1185">        npier = OSPREY_NUM_5G_CAL_PIERS;</a>
<a name="ln1186">        p_cal_pier = eep-&gt;cal_freq_pier_5g;</a>
<a name="ln1187">        p_cal_pier_struct = eep-&gt;cal_pier_data_5g[ichain];</a>
<a name="ln1188">    }</a>
<a name="ln1189">    /* look for valid noise floor values */</a>
<a name="ln1190">    nnf = 0;</a>
<a name="ln1191">    for (ipier = 0; ipier &lt; npier; ipier++) {</a>
<a name="ln1192">        fx[nnf] = FBIN2FREQ(p_cal_pier[ipier], is_2ghz);</a>
<a name="ln1193">        nf[nnf] = use_cal ?</a>
<a name="ln1194">            p_cal_pier_struct[ipier].rx_noisefloor_cal :</a>
<a name="ln1195">            p_cal_pier_struct[ipier].rx_noisefloor_power;</a>
<a name="ln1196">        if (nf[nnf] &lt; 0) {</a>
<a name="ln1197">            nnf++;</a>
<a name="ln1198">        }</a>
<a name="ln1199">    }</a>
<a name="ln1200">    /*</a>
<a name="ln1201">     * If we have some valid values, interpolate to find the value</a>
<a name="ln1202">     * at the desired frequency.</a>
<a name="ln1203">     */</a>
<a name="ln1204">    if (nnf &gt; 0) {</a>
<a name="ln1205">        nf_use = interpolate(frequency, fx, nf, nnf);</a>
<a name="ln1206">    }</a>
<a name="ln1207"> </a>
<a name="ln1208">    return nf_use;</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211">/*</a>
<a name="ln1212"> * Return the Rx NF offset for specific channel.</a>
<a name="ln1213"> * The values saved in EEPROM/OTP/Flash is converted through the following way:</a>
<a name="ln1214"> *     ((_p) - NOISE_PWR_DATA_OFFSET) &lt;&lt; 2</a>
<a name="ln1215"> * So we need to convert back to the original values.</a>
<a name="ln1216"> */</a>
<a name="ln1217">int ar9300_get_rx_nf_offset(struct ath_hal *ah, struct ieee80211_channel *chan, int8_t *nf_pwr, int8_t *nf_cal) {</a>
<a name="ln1218">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln1219">    int8_t rx_nf_pwr, rx_nf_cal;</a>
<a name="ln1220">    int i; </a>
<a name="ln1221">    //HALASSERT(ichan);</a>
<a name="ln1222"> </a>
<a name="ln1223">    /* Fill 0 if valid internal channel is not found */</a>
<a name="ln1224">    if (ichan == AH_NULL) {</a>
<a name="ln1225">        OS_MEMZERO(nf_pwr, sizeof(nf_pwr[0])*OSPREY_MAX_CHAINS);</a>
<a name="ln1226">        OS_MEMZERO(nf_cal, sizeof(nf_cal[0])*OSPREY_MAX_CHAINS);</a>
<a name="ln1227">        return -1;</a>
<a name="ln1228">    }</a>
<a name="ln1229"> </a>
<a name="ln1230">    for (i = 0; i &lt; OSPREY_MAX_CHAINS; i++) {</a>
<a name="ln1231">	    if ((rx_nf_pwr = ar9300_noise_floor_cal_or_power_get(ah, ichan-&gt;channel, i, 0)) == 1) {</a>
<a name="ln1232">	        nf_pwr[i] = 0;</a>
<a name="ln1233">	    } else {</a>
<a name="ln1234">	        //printk(&quot;%s: raw nf_pwr[%d] = %d\n&quot;, __func__, i, rx_nf_pwr);</a>
<a name="ln1235">            nf_pwr[i] = NOISE_PWR_DBM_2_INT(rx_nf_pwr);</a>
<a name="ln1236">	    }</a>
<a name="ln1237"> </a>
<a name="ln1238">	    if ((rx_nf_cal = ar9300_noise_floor_cal_or_power_get(ah, ichan-&gt;channel, i, 1)) == 1) {</a>
<a name="ln1239">	        nf_cal[i] = 0;</a>
<a name="ln1240">	    } else {</a>
<a name="ln1241">	        //printk(&quot;%s: raw nf_cal[%d] = %d\n&quot;, __func__, i, rx_nf_cal);</a>
<a name="ln1242">            nf_cal[i] = NOISE_PWR_DBM_2_INT(rx_nf_cal);</a>
<a name="ln1243">	    }</a>
<a name="ln1244">    }</a>
<a name="ln1245"> </a>
<a name="ln1246">    return 0;</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">int32_t ar9300_rx_gain_index_get(struct ath_hal *ah)</a>
<a name="ln1250">{</a>
<a name="ln1251">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1252"> </a>
<a name="ln1253">    return (eep-&gt;base_eep_header.txrxgain) &amp; 0xf;        /* bits 3:0 */</a>
<a name="ln1254">}</a>
<a name="ln1255"> </a>
<a name="ln1256"> </a>
<a name="ln1257">int32_t ar9300_tx_gain_index_get(struct ath_hal *ah)</a>
<a name="ln1258">{</a>
<a name="ln1259">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1260"> </a>
<a name="ln1261">    return (eep-&gt;base_eep_header.txrxgain &gt;&gt; 4) &amp; 0xf;    /* bits 7:4 */</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">HAL_BOOL ar9300_internal_regulator_apply(struct ath_hal *ah)</a>
<a name="ln1265">{</a>
<a name="ln1266">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1267">    int internal_regulator = ar9300_eeprom_get(ahp, EEP_INTERNAL_REGULATOR);</a>
<a name="ln1268">    int reg_pmu1, reg_pmu2, reg_pmu1_set, reg_pmu2_set;</a>
<a name="ln1269">    u_int32_t reg_PMU1, reg_PMU2;</a>
<a name="ln1270">    unsigned long eep_addr;</a>
<a name="ln1271">    u_int32_t reg_val, reg_usb = 0, reg_pmu = 0;</a>
<a name="ln1272">    int usb_valid = 0, pmu_valid = 0;</a>
<a name="ln1273">    unsigned char pmu_refv; </a>
<a name="ln1274"> </a>
<a name="ln1275">    if (AR_SREV_JUPITER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1276">        reg_PMU1 = AR_PHY_PMU1_JUPITER;</a>
<a name="ln1277">        reg_PMU2 = AR_PHY_PMU2_JUPITER;</a>
<a name="ln1278">    }</a>
<a name="ln1279">    else {</a>
<a name="ln1280">        reg_PMU1 = AR_PHY_PMU1;</a>
<a name="ln1281">        reg_PMU2 = AR_PHY_PMU2;</a>
<a name="ln1282">    }</a>
<a name="ln1283"> </a>
<a name="ln1284">    if (internal_regulator) {</a>
<a name="ln1285">        if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah)) {</a>
<a name="ln1286">            if (AR_SREV_HORNET(ah)) {</a>
<a name="ln1287">                /* Read OTP first */</a>
<a name="ln1288">                for (eep_addr = 0x14; ; eep_addr -= 0x10) {</a>
<a name="ln1289"> </a>
<a name="ln1290">                    ar9300_otp_read(ah, eep_addr / 4, &amp;reg_val, 1);</a>
<a name="ln1291"> </a>
<a name="ln1292">                    if ((reg_val &amp; 0x80) == 0x80){</a>
<a name="ln1293">                        usb_valid = 1;</a>
<a name="ln1294">                        reg_usb = reg_val &amp; 0x000000ff;</a>
<a name="ln1295">                    }</a>
<a name="ln1296">                    </a>
<a name="ln1297">                    if ((reg_val &amp; 0x80000000) == 0x80000000){</a>
<a name="ln1298">                        pmu_valid = 1;</a>
<a name="ln1299">                        reg_pmu = (reg_val &amp; 0xff000000) &gt;&gt; 24;</a>
<a name="ln1300">                    }</a>
<a name="ln1301"> </a>
<a name="ln1302">                    if (eep_addr == 0x4) {</a>
<a name="ln1303">                        break;</a>
<a name="ln1304">                    }</a>
<a name="ln1305">                }</a>
<a name="ln1306"> </a>
<a name="ln1307">                if (pmu_valid) {</a>
<a name="ln1308">                    pmu_refv = reg_pmu &amp; 0xf;</a>
<a name="ln1309">                } else {</a>
<a name="ln1310">                    pmu_refv = 0x8;</a>
<a name="ln1311">                }</a>
<a name="ln1312"> </a>
<a name="ln1313">                /*</a>
<a name="ln1314">                 * If (valid) {</a>
<a name="ln1315">                 *   Usb_phy_ctrl2_tx_cal_en -&gt; 0</a>
<a name="ln1316">                 *   Usb_phy_ctrl2_tx_cal_sel -&gt; 0</a>
<a name="ln1317">                 *   Usb_phy_ctrl2_tx_man_cal -&gt; 0, 1, 3, 7 or 15 from OTP</a>
<a name="ln1318">                 * }</a>
<a name="ln1319">                 */</a>
<a name="ln1320">                if (usb_valid) {</a>
<a name="ln1321">                    OS_REG_RMW_FIELD(ah, 0x16c88, AR_PHY_CTRL2_TX_CAL_EN, 0x0);</a>
<a name="ln1322">                    OS_REG_RMW_FIELD(ah, 0x16c88, AR_PHY_CTRL2_TX_CAL_SEL, 0x0);</a>
<a name="ln1323">                    OS_REG_RMW_FIELD(ah, 0x16c88, </a>
<a name="ln1324">                        AR_PHY_CTRL2_TX_MAN_CAL, (reg_usb &amp; 0xf));</a>
<a name="ln1325">                }</a>
<a name="ln1326"> </a>
<a name="ln1327">            } else {</a>
<a name="ln1328">                pmu_refv = 0x8;</a>
<a name="ln1329">            }</a>
<a name="ln1330">            /*#ifndef USE_HIF*/</a>
<a name="ln1331">            /* Follow the MDK settings for Hornet PMU.</a>
<a name="ln1332">             * my $pwd               = 0x0;</a>
<a name="ln1333">             * my $Nfdiv             = 0x3;  # xtal_freq = 25MHz</a>
<a name="ln1334">             * my $Nfdiv             = 0x4;  # xtal_freq = 40MHz</a>
<a name="ln1335">             * my $Refv              = 0x7;  # 0x5:1.22V; 0x8:1.29V</a>
<a name="ln1336">             * my $Gm1               = 0x3;  #Poseidon $Gm1=1</a>
<a name="ln1337">             * my $classb            = 0x0;</a>
<a name="ln1338">             * my $Cc                = 0x1;  #Poseidon $Cc=7</a>
<a name="ln1339">             * my $Rc                = 0x6;</a>
<a name="ln1340">             * my $ramp_slope        = 0x1;</a>
<a name="ln1341">             * my $Segm              = 0x3;</a>
<a name="ln1342">             * my $use_local_osc     = 0x0;</a>
<a name="ln1343">             * my $force_xosc_stable = 0x0;</a>
<a name="ln1344">             * my $Selfb             = 0x0;  #Poseidon $Selfb=1</a>
<a name="ln1345">             * my $Filterfb          = 0x3;  #Poseidon $Filterfb=0</a>
<a name="ln1346">             * my $Filtervc          = 0x0;</a>
<a name="ln1347">             * my $disc              = 0x0;</a>
<a name="ln1348">             * my $discdel           = 0x4;</a>
<a name="ln1349">             * my $spare             = 0x0;</a>
<a name="ln1350">             * $reg_PMU1 =</a>
<a name="ln1351">             *     $pwd | ($Nfdiv&lt;&lt;1) | ($Refv&lt;&lt;4) | ($Gm1&lt;&lt;8) |</a>
<a name="ln1352">             *     ($classb&lt;&lt;11) | ($Cc&lt;&lt;14) | ($Rc&lt;&lt;17) | ($ramp_slope&lt;&lt;20) |</a>
<a name="ln1353">             *     ($Segm&lt;&lt;24) | ($use_local_osc&lt;&lt;26) |</a>
<a name="ln1354">             *     ($force_xosc_stable&lt;&lt;27) | ($Selfb&lt;&lt;28) | ($Filterfb&lt;&lt;29);</a>
<a name="ln1355">             * $reg_PMU2 = $handle-&gt;reg_rd(&quot;ch0_PMU2&quot;);</a>
<a name="ln1356">             * $reg_PMU2 = ($reg_PMU2 &amp; 0xfe3fffff) | ($Filtervc&lt;&lt;22);</a>
<a name="ln1357">             * $reg_PMU2 = ($reg_PMU2 &amp; 0xe3ffffff) | ($discdel&lt;&lt;26);</a>
<a name="ln1358">             * $reg_PMU2 = ($reg_PMU2 &amp; 0x1fffffff) | ($spare&lt;&lt;29); </a>
<a name="ln1359">             */</a>
<a name="ln1360">            if (ahp-&gt;clk_25mhz) {</a>
<a name="ln1361">                reg_pmu1_set = 0 |</a>
<a name="ln1362">                    (3 &lt;&lt;  1) | (pmu_refv &lt;&lt; 4) | (3 &lt;&lt;  8) | (0 &lt;&lt; 11) |</a>
<a name="ln1363">                    (1 &lt;&lt; 14) | (6 &lt;&lt; 17) | (1 &lt;&lt; 20) | (3 &lt;&lt; 24) |</a>
<a name="ln1364">                    (0 &lt;&lt; 26) | (0 &lt;&lt; 27) | (0 &lt;&lt; 28) | (0 &lt;&lt; 29);</a>
<a name="ln1365">            } else {</a>
<a name="ln1366">                if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln1367">                    reg_pmu1_set = 0 | </a>
<a name="ln1368">                        (5 &lt;&lt;  1) | (7 &lt;&lt;  4) | (2 &lt;&lt;  8) | (0 &lt;&lt; 11) |</a>
<a name="ln1369">                        (2 &lt;&lt; 14) | (6 &lt;&lt; 17) | (1 &lt;&lt; 20) | (3 &lt;&lt; 24) |</a>
<a name="ln1370">                        (0 &lt;&lt; 26) | (0 &lt;&lt; 27) | (1 &lt;&lt; 28) | (0 &lt;&lt; 29) ;</a>
<a name="ln1371">                } else {</a>
<a name="ln1372">                    reg_pmu1_set = 0 |</a>
<a name="ln1373">                        (4 &lt;&lt;  1) | (7 &lt;&lt;  4) | (3 &lt;&lt;  8) | (0 &lt;&lt; 11) |</a>
<a name="ln1374">                        (1 &lt;&lt; 14) | (6 &lt;&lt; 17) | (1 &lt;&lt; 20) | (3 &lt;&lt; 24) |</a>
<a name="ln1375">                        (0 &lt;&lt; 26) | (0 &lt;&lt; 27) | (0 &lt;&lt; 28) | (0 &lt;&lt; 29) ;</a>
<a name="ln1376">                } </a>
<a name="ln1377">            }</a>
<a name="ln1378">            OS_REG_RMW_FIELD(ah, reg_PMU2, AR_PHY_PMU2_PGM, 0x0);</a>
<a name="ln1379"> </a>
<a name="ln1380">            OS_REG_WRITE(ah, reg_PMU1, reg_pmu1_set);   /* 0x638c8376 */</a>
<a name="ln1381">            reg_pmu1 = OS_REG_READ(ah, reg_PMU1);</a>
<a name="ln1382">            while (reg_pmu1 != reg_pmu1_set) {</a>
<a name="ln1383">                OS_REG_WRITE(ah, reg_PMU1, reg_pmu1_set);  /* 0x638c8376 */</a>
<a name="ln1384">                OS_DELAY(10);</a>
<a name="ln1385">                reg_pmu1 = OS_REG_READ(ah, reg_PMU1);</a>
<a name="ln1386">            }</a>
<a name="ln1387">                                </a>
<a name="ln1388">            reg_pmu2_set =</a>
<a name="ln1389">                 (OS_REG_READ(ah, reg_PMU2) &amp; (~0xFFC00000)) | (4 &lt;&lt; 26);</a>
<a name="ln1390">            OS_REG_WRITE(ah, reg_PMU2, reg_pmu2_set);</a>
<a name="ln1391">            reg_pmu2 = OS_REG_READ(ah, reg_PMU2);</a>
<a name="ln1392">            while (reg_pmu2 != reg_pmu2_set) {</a>
<a name="ln1393">                OS_REG_WRITE(ah, reg_PMU2, reg_pmu2_set);</a>
<a name="ln1394">                OS_DELAY(10);</a>
<a name="ln1395">                reg_pmu2 = OS_REG_READ(ah, reg_PMU2);</a>
<a name="ln1396">            }</a>
<a name="ln1397">            reg_pmu2_set =</a>
<a name="ln1398">                 (OS_REG_READ(ah, reg_PMU2) &amp; (~0x00200000)) | (1 &lt;&lt; 21);</a>
<a name="ln1399">            OS_REG_WRITE(ah, reg_PMU2, reg_pmu2_set);</a>
<a name="ln1400">            reg_pmu2 = OS_REG_READ(ah, reg_PMU2);</a>
<a name="ln1401">            while (reg_pmu2 != reg_pmu2_set) {</a>
<a name="ln1402">                OS_REG_WRITE(ah, reg_PMU2, reg_pmu2_set);</a>
<a name="ln1403">                OS_DELAY(10);</a>
<a name="ln1404">                reg_pmu2 = OS_REG_READ(ah, reg_PMU2);</a>
<a name="ln1405">            }</a>
<a name="ln1406">            /*#endif*/</a>
<a name="ln1407">        } else if (AR_SREV_JUPITER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1408">            /* Internal regulator is ON. Write swreg register. */</a>
<a name="ln1409">            int swreg = ar9300_eeprom_get(ahp, EEP_SWREG);</a>
<a name="ln1410">            OS_REG_WRITE(ah, reg_PMU1, swreg);</a>
<a name="ln1411">        } else {</a>
<a name="ln1412">            /* Internal regulator is ON. Write swreg register. */</a>
<a name="ln1413">            int swreg = ar9300_eeprom_get(ahp, EEP_SWREG);</a>
<a name="ln1414">            OS_REG_WRITE(ah, AR_RTC_REG_CONTROL1,</a>
<a name="ln1415">                         OS_REG_READ(ah, AR_RTC_REG_CONTROL1) &amp;</a>
<a name="ln1416">                         (~AR_RTC_REG_CONTROL1_SWREG_PROGRAM));</a>
<a name="ln1417">            OS_REG_WRITE(ah, AR_RTC_REG_CONTROL0, swreg);</a>
<a name="ln1418">            /* Set REG_CONTROL1.SWREG_PROGRAM */</a>
<a name="ln1419">            OS_REG_WRITE(ah, AR_RTC_REG_CONTROL1,</a>
<a name="ln1420">                OS_REG_READ(ah, AR_RTC_REG_CONTROL1) |</a>
<a name="ln1421">                AR_RTC_REG_CONTROL1_SWREG_PROGRAM);</a>
<a name="ln1422">        }</a>
<a name="ln1423">    } else {</a>
<a name="ln1424">        if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah)) {</a>
<a name="ln1425">            OS_REG_RMW_FIELD(ah, reg_PMU2, AR_PHY_PMU2_PGM, 0x0);</a>
<a name="ln1426">            reg_pmu2 = OS_REG_READ_FIELD(ah, reg_PMU2, AR_PHY_PMU2_PGM);</a>
<a name="ln1427">            while (reg_pmu2) {</a>
<a name="ln1428">                OS_DELAY(10);</a>
<a name="ln1429">                reg_pmu2 = OS_REG_READ_FIELD(ah, reg_PMU2, AR_PHY_PMU2_PGM);</a>
<a name="ln1430">            }</a>
<a name="ln1431">            OS_REG_RMW_FIELD(ah, reg_PMU1, AR_PHY_PMU1_PWD, 0x1);</a>
<a name="ln1432">            reg_pmu1 = OS_REG_READ_FIELD(ah, reg_PMU1, AR_PHY_PMU1_PWD);</a>
<a name="ln1433">            while (!reg_pmu1) {</a>
<a name="ln1434">                OS_DELAY(10);</a>
<a name="ln1435">                reg_pmu1 = OS_REG_READ_FIELD(ah, reg_PMU1, AR_PHY_PMU1_PWD);</a>
<a name="ln1436">            }</a>
<a name="ln1437">            OS_REG_RMW_FIELD(ah, reg_PMU2, AR_PHY_PMU2_PGM, 0x1);</a>
<a name="ln1438">            reg_pmu2 = OS_REG_READ_FIELD(ah, reg_PMU2, AR_PHY_PMU2_PGM);</a>
<a name="ln1439">            while (!reg_pmu2) {</a>
<a name="ln1440">                OS_DELAY(10);</a>
<a name="ln1441">                reg_pmu2 = OS_REG_READ_FIELD(ah, reg_PMU2, AR_PHY_PMU2_PGM);</a>
<a name="ln1442">            }</a>
<a name="ln1443">        } else if (AR_SREV_JUPITER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1444">            OS_REG_RMW_FIELD(ah, reg_PMU1, AR_PHY_PMU1_PWD, 0x1);</a>
<a name="ln1445">        } else {</a>
<a name="ln1446">            OS_REG_WRITE(ah, AR_RTC_SLEEP_CLK,</a>
<a name="ln1447">                (OS_REG_READ(ah, AR_RTC_SLEEP_CLK) |</a>
<a name="ln1448">                AR_RTC_FORCE_SWREG_PRD | AR_RTC_PCIE_RST_PWDN_EN));</a>
<a name="ln1449">        }</a>
<a name="ln1450">    }</a>
<a name="ln1451"> </a>
<a name="ln1452">    return 0;  </a>
<a name="ln1453">}</a>
<a name="ln1454"> </a>
<a name="ln1455">HAL_BOOL ar9300_drive_strength_apply(struct ath_hal *ah)</a>
<a name="ln1456">{</a>
<a name="ln1457">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1458">    int drive_strength;</a>
<a name="ln1459">    unsigned long reg;</a>
<a name="ln1460"> </a>
<a name="ln1461">    drive_strength = ar9300_eeprom_get(ahp, EEP_DRIVE_STRENGTH);</a>
<a name="ln1462">    if (drive_strength) {</a>
<a name="ln1463">        reg = OS_REG_READ(ah, AR_PHY_65NM_CH0_BIAS1);</a>
<a name="ln1464">        reg &amp;= ~0x00ffffc0;</a>
<a name="ln1465">        reg |= 0x5 &lt;&lt; 21;</a>
<a name="ln1466">        reg |= 0x5 &lt;&lt; 18;</a>
<a name="ln1467">        reg |= 0x5 &lt;&lt; 15;</a>
<a name="ln1468">        reg |= 0x5 &lt;&lt; 12;</a>
<a name="ln1469">        reg |= 0x5 &lt;&lt; 9;</a>
<a name="ln1470">        reg |= 0x5 &lt;&lt; 6;</a>
<a name="ln1471">        OS_REG_WRITE(ah, AR_PHY_65NM_CH0_BIAS1, reg);</a>
<a name="ln1472"> </a>
<a name="ln1473">        reg = OS_REG_READ(ah, AR_PHY_65NM_CH0_BIAS2);</a>
<a name="ln1474">        reg &amp;= ~0xffffffe0;</a>
<a name="ln1475">        reg |= 0x5 &lt;&lt; 29;</a>
<a name="ln1476">        reg |= 0x5 &lt;&lt; 26;</a>
<a name="ln1477">        reg |= 0x5 &lt;&lt; 23;</a>
<a name="ln1478">        reg |= 0x5 &lt;&lt; 20;</a>
<a name="ln1479">        reg |= 0x5 &lt;&lt; 17;</a>
<a name="ln1480">        reg |= 0x5 &lt;&lt; 14;</a>
<a name="ln1481">        reg |= 0x5 &lt;&lt; 11;</a>
<a name="ln1482">        reg |= 0x5 &lt;&lt; 8;</a>
<a name="ln1483">        reg |= 0x5 &lt;&lt; 5;</a>
<a name="ln1484">        OS_REG_WRITE(ah, AR_PHY_65NM_CH0_BIAS2, reg);</a>
<a name="ln1485"> </a>
<a name="ln1486">        reg = OS_REG_READ(ah, AR_PHY_65NM_CH0_BIAS4);</a>
<a name="ln1487">        reg &amp;= ~0xff800000;</a>
<a name="ln1488">        reg |= 0x5 &lt;&lt; 29;</a>
<a name="ln1489">        reg |= 0x5 &lt;&lt; 26;</a>
<a name="ln1490">        reg |= 0x5 &lt;&lt; 23;</a>
<a name="ln1491">        OS_REG_WRITE(ah, AR_PHY_65NM_CH0_BIAS4, reg);</a>
<a name="ln1492">    }</a>
<a name="ln1493">    return 0;</a>
<a name="ln1494">}</a>
<a name="ln1495"> </a>
<a name="ln1496">int32_t ar9300_xpa_bias_level_get(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln1497">{</a>
<a name="ln1498">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1499">    if (is_2ghz) {</a>
<a name="ln1500">        return eep-&gt;modal_header_2g.xpa_bias_lvl;</a>
<a name="ln1501">    } else {</a>
<a name="ln1502">        return eep-&gt;modal_header_5g.xpa_bias_lvl;</a>
<a name="ln1503">    }</a>
<a name="ln1504">}</a>
<a name="ln1505"> </a>
<a name="ln1506">HAL_BOOL ar9300_xpa_bias_level_apply(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln1507">{</a>
<a name="ln1508">    /*</a>
<a name="ln1509">     * In ar9330 emu, we can't access radio registers, </a>
<a name="ln1510">     * merlin is used for radio part.</a>
<a name="ln1511">     */</a>
<a name="ln1512">    int bias;</a>
<a name="ln1513">    bias = ar9300_xpa_bias_level_get(ah, is_2ghz);</a>
<a name="ln1514"> </a>
<a name="ln1515">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln1516">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln1517">            AR_HORNET_CH0_TOP2, AR_HORNET_CH0_TOP2_XPABIASLVL, bias);</a>
<a name="ln1518">    } else if (AR_SREV_SCORPION(ah)) {</a>
<a name="ln1519">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln1520">            AR_SCORPION_CH0_TOP, AR_SCORPION_CH0_TOP_XPABIASLVL, bias);</a>
<a name="ln1521">    } else if (AR_SREV_JUPITER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1522">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln1523">            AR_PHY_65NM_CH0_TOP_JUPITER, AR_PHY_65NM_CH0_TOP_XPABIASLVL, bias);</a>
<a name="ln1524">    } else {</a>
<a name="ln1525">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln1526">            AR_PHY_65NM_CH0_TOP, AR_PHY_65NM_CH0_TOP_XPABIASLVL, bias);</a>
<a name="ln1527">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln1528">            AR_PHY_65NM_CH0_THERM, AR_PHY_65NM_CH0_THERM_XPABIASLVL_MSB,</a>
<a name="ln1529">            bias &gt;&gt; 2);</a>
<a name="ln1530">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln1531">            AR_PHY_65NM_CH0_THERM, AR_PHY_65NM_CH0_THERM_XPASHORT2GND, 1);</a>
<a name="ln1532">    }</a>
<a name="ln1533">    return 0;</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">u_int32_t ar9300_ant_ctrl_common_get(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln1537">{</a>
<a name="ln1538">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1539">    if (is_2ghz) {</a>
<a name="ln1540">        return eep-&gt;modal_header_2g.ant_ctrl_common;</a>
<a name="ln1541">    } else {</a>
<a name="ln1542">        return eep-&gt;modal_header_5g.ant_ctrl_common;</a>
<a name="ln1543">    }</a>
<a name="ln1544">}</a>
<a name="ln1545">static u_int16_t </a>
<a name="ln1546">ar9300_switch_com_spdt_get(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln1547">{</a>
<a name="ln1548">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1549">    if (is_2ghz) {</a>
<a name="ln1550">        return eep-&gt;modal_header_2g.switchcomspdt;</a>
<a name="ln1551">    } else {</a>
<a name="ln1552">        return eep-&gt;modal_header_5g.switchcomspdt;</a>
<a name="ln1553">    }</a>
<a name="ln1554">}</a>
<a name="ln1555">u_int32_t ar9300_ant_ctrl_common2_get(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln1556">{</a>
<a name="ln1557">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1558">    if (is_2ghz) {</a>
<a name="ln1559">        return eep-&gt;modal_header_2g.ant_ctrl_common2;</a>
<a name="ln1560">    } else {</a>
<a name="ln1561">        return eep-&gt;modal_header_5g.ant_ctrl_common2;</a>
<a name="ln1562">    }</a>
<a name="ln1563">}</a>
<a name="ln1564"> </a>
<a name="ln1565">u_int16_t ar9300_ant_ctrl_chain_get(struct ath_hal *ah, int chain,</a>
<a name="ln1566">    HAL_BOOL is_2ghz)</a>
<a name="ln1567">{</a>
<a name="ln1568">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1569">    if (chain &gt;= 0 &amp;&amp; chain &lt; OSPREY_MAX_CHAINS) {</a>
<a name="ln1570">        if (is_2ghz) {</a>
<a name="ln1571">            return eep-&gt;modal_header_2g.ant_ctrl_chain[chain];</a>
<a name="ln1572">        } else {</a>
<a name="ln1573">            return eep-&gt;modal_header_5g.ant_ctrl_chain[chain];</a>
<a name="ln1574">        }</a>
<a name="ln1575">    }</a>
<a name="ln1576">    return 0;</a>
<a name="ln1577">}</a>
<a name="ln1578"> </a>
<a name="ln1579">/*</a>
<a name="ln1580"> * Select the usage of antenna via the RF switch.</a>
<a name="ln1581"> * Default values are loaded from eeprom.</a>
<a name="ln1582"> */</a>
<a name="ln1583">HAL_BOOL ar9300_ant_swcom_sel(struct ath_hal *ah, u_int8_t ops,</a>
<a name="ln1584">                        u_int32_t *common_tbl1, u_int32_t *common_tbl2)</a>
<a name="ln1585">{</a>
<a name="ln1586">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1587">    struct ath_hal_private  *ap  = AH_PRIVATE(ah);</a>
<a name="ln1588">    const struct ieee80211_channel *curchan = ap-&gt;ah_curchan;</a>
<a name="ln1589">    enum {</a>
<a name="ln1590">        ANT_SELECT_OPS_GET,</a>
<a name="ln1591">        ANT_SELECT_OPS_SET,</a>
<a name="ln1592">    };</a>
<a name="ln1593"> </a>
<a name="ln1594">    if (AR_SREV_JUPITER(ah) || AR_SREV_SCORPION(ah))</a>
<a name="ln1595">        return AH_FALSE;</a>
<a name="ln1596"> </a>
<a name="ln1597">    if (!curchan)</a>
<a name="ln1598">        return AH_FALSE;</a>
<a name="ln1599"> </a>
<a name="ln1600">#define AR_SWITCH_TABLE_COM_ALL (0xffff)</a>
<a name="ln1601">#define AR_SWITCH_TABLE_COM_ALL_S (0)</a>
<a name="ln1602">#define AR_SWITCH_TABLE_COM2_ALL (0xffffff)</a>
<a name="ln1603">#define AR_SWITCH_TABLE_COM2_ALL_S (0)</a>
<a name="ln1604">    switch (ops) {</a>
<a name="ln1605">    case ANT_SELECT_OPS_GET:</a>
<a name="ln1606">        *common_tbl1 = OS_REG_READ_FIELD(ah, AR_PHY_SWITCH_COM,</a>
<a name="ln1607">                            AR_SWITCH_TABLE_COM_ALL);</a>
<a name="ln1608">        *common_tbl2 = OS_REG_READ_FIELD(ah, AR_PHY_SWITCH_COM_2,</a>
<a name="ln1609">                            AR_SWITCH_TABLE_COM2_ALL);</a>
<a name="ln1610">        break;</a>
<a name="ln1611">    case ANT_SELECT_OPS_SET:</a>
<a name="ln1612">        OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM,</a>
<a name="ln1613">            AR_SWITCH_TABLE_COM_ALL, *common_tbl1);</a>
<a name="ln1614">        OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2,</a>
<a name="ln1615">            AR_SWITCH_TABLE_COM2_ALL, *common_tbl2);</a>
<a name="ln1616"> </a>
<a name="ln1617">        /* write back to eeprom */</a>
<a name="ln1618">        if (IEEE80211_IS_CHAN_2GHZ(curchan)) {</a>
<a name="ln1619">            eep-&gt;modal_header_2g.ant_ctrl_common = *common_tbl1;</a>
<a name="ln1620">            eep-&gt;modal_header_2g.ant_ctrl_common2 = *common_tbl2;</a>
<a name="ln1621">        } else {</a>
<a name="ln1622">            eep-&gt;modal_header_5g.ant_ctrl_common = *common_tbl1;</a>
<a name="ln1623">            eep-&gt;modal_header_5g.ant_ctrl_common2 = *common_tbl2;</a>
<a name="ln1624">        }</a>
<a name="ln1625"> </a>
<a name="ln1626">        break;</a>
<a name="ln1627">    default:</a>
<a name="ln1628">        break;</a>
<a name="ln1629">    }</a>
<a name="ln1630"> </a>
<a name="ln1631">    return AH_TRUE;</a>
<a name="ln1632">}</a>
<a name="ln1633"> </a>
<a name="ln1634">HAL_BOOL ar9300_ant_ctrl_apply(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln1635">{</a>
<a name="ln1636">    u_int32_t value;</a>
<a name="ln1637">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1638">    u_int32_t regval;</a>
<a name="ln1639">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln1640">#if ATH_ANT_DIV_COMB</a>
<a name="ln1641">    HAL_CAPABILITIES *pcap = &amp;ahpriv-&gt;ah_caps;</a>
<a name="ln1642">#endif  /* ATH_ANT_DIV_COMB */</a>
<a name="ln1643">    u_int32_t xlan_gpio_cfg;</a>
<a name="ln1644">    u_int8_t  i;</a>
<a name="ln1645"> </a>
<a name="ln1646">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: use_bt_ant_enable=%d\n&quot;,</a>
<a name="ln1647">      __func__, ahp-&gt;ah_lna_div_use_bt_ant_enable);</a>
<a name="ln1648"> </a>
<a name="ln1649">    /* XXX TODO: only if rx_gain_idx == 0 */</a>
<a name="ln1650">    if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln1651">        xlan_gpio_cfg = ah-&gt;ah_config.ath_hal_ext_lna_ctl_gpio;</a>
<a name="ln1652">        if (xlan_gpio_cfg) {</a>
<a name="ln1653">            for (i = 0; i &lt; 32; i++) {</a>
<a name="ln1654">                if (xlan_gpio_cfg &amp; (1 &lt;&lt; i)) {</a>
<a name="ln1655">                    ath_hal_gpioCfgOutput(ah, i, </a>
<a name="ln1656">                        HAL_GPIO_OUTPUT_MUX_PCIE_ATTENTION_LED);</a>
<a name="ln1657">                }</a>
<a name="ln1658">            }</a>
<a name="ln1659">        }    </a>
<a name="ln1660">    }</a>
<a name="ln1661">#define AR_SWITCH_TABLE_COM_ALL (0xffff)</a>
<a name="ln1662">#define AR_SWITCH_TABLE_COM_ALL_S (0)</a>
<a name="ln1663">#define AR_SWITCH_TABLE_COM_JUPITER_ALL (0xffffff)</a>
<a name="ln1664">#define AR_SWITCH_TABLE_COM_JUPITER_ALL_S (0)</a>
<a name="ln1665">#define AR_SWITCH_TABLE_COM_SCORPION_ALL (0xffffff)</a>
<a name="ln1666">#define AR_SWITCH_TABLE_COM_SCORPION_ALL_S (0)</a>
<a name="ln1667">#define AR_SWITCH_TABLE_COM_HONEYBEE_ALL (0xffffff)</a>
<a name="ln1668">#define AR_SWITCH_TABLE_COM_HONEYBEE_ALL_S (0)</a>
<a name="ln1669">#define AR_SWITCH_TABLE_COM_SPDT (0x00f00000)</a>
<a name="ln1670">    value = ar9300_ant_ctrl_common_get(ah, is_2ghz);</a>
<a name="ln1671">    if (AR_SREV_JUPITER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1672">        if (AR_SREV_JUPITER_10(ah)) {</a>
<a name="ln1673">            /* Force SPDT setting for Jupiter 1.0 chips. */</a>
<a name="ln1674">            value &amp;= ~AR_SWITCH_TABLE_COM_SPDT;</a>
<a name="ln1675">            value |= 0x00100000;</a>
<a name="ln1676">        }</a>
<a name="ln1677">        OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM, </a>
<a name="ln1678">            AR_SWITCH_TABLE_COM_JUPITER_ALL, value);</a>
<a name="ln1679">    }</a>
<a name="ln1680">    else if (AR_SREV_SCORPION(ah)) {</a>
<a name="ln1681">        OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM, </a>
<a name="ln1682">            AR_SWITCH_TABLE_COM_SCORPION_ALL, value);</a>
<a name="ln1683">    }</a>
<a name="ln1684">    else if (AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln1685">        OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM, </a>
<a name="ln1686">            AR_SWITCH_TABLE_COM_HONEYBEE_ALL, value);</a>
<a name="ln1687">    }</a>
<a name="ln1688">    else {</a>
<a name="ln1689">        OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM, </a>
<a name="ln1690">            AR_SWITCH_TABLE_COM_ALL, value);</a>
<a name="ln1691">    }</a>
<a name="ln1692">/*</a>
<a name="ln1693">*   Jupiter2.0 defines new switch table for BT/WLAN, </a>
<a name="ln1694">*	here's new field name in WB222.ref for both 2G and 5G.</a>
<a name="ln1695">*   Register: [GLB_CONTROL] GLB_CONTROL (@0x20044)</a>
<a name="ln1696">*   15:12	R/W	SWITCH_TABLE_COM_SPDT_WLAN_RX	SWITCH_TABLE_COM_SPDT_WLAN_RX </a>
<a name="ln1697">*   11:8	R/W	SWITCH_TABLE_COM_SPDT_WLAN_TX	SWITCH_TABLE_COM_SPDT_WLAN_TX</a>
<a name="ln1698">*   7:4	R/W	SWITCH_TABLE_COM_SPDT_WLAN_IDLE	SWITCH_TABLE_COM_SPDT_WLAN_IDLE	</a>
<a name="ln1699">*/</a>
<a name="ln1700">#define AR_SWITCH_TABLE_COM_SPDT_ALL (0x0000fff0)</a>
<a name="ln1701">#define AR_SWITCH_TABLE_COM_SPDT_ALL_S (4)</a>
<a name="ln1702">    if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1703">        value = ar9300_switch_com_spdt_get(ah, is_2ghz);</a>
<a name="ln1704">        OS_REG_RMW_FIELD(ah, AR_GLB_CONTROL, </a>
<a name="ln1705">            AR_SWITCH_TABLE_COM_SPDT_ALL, value);</a>
<a name="ln1706"> </a>
<a name="ln1707">        OS_REG_SET_BIT(ah, AR_GLB_CONTROL,</a>
<a name="ln1708">            AR_BTCOEX_CTRL_SPDT_ENABLE);</a>
<a name="ln1709">        //OS_REG_SET_BIT(ah, AR_GLB_CONTROL,</a>
<a name="ln1710">        //    AR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);</a>
<a name="ln1711">    }</a>
<a name="ln1712"> </a>
<a name="ln1713">#define AR_SWITCH_TABLE_COM2_ALL (0xffffff)</a>
<a name="ln1714">#define AR_SWITCH_TABLE_COM2_ALL_S (0)</a>
<a name="ln1715">    value = ar9300_ant_ctrl_common2_get(ah, is_2ghz);</a>
<a name="ln1716">#if ATH_ANT_DIV_COMB</a>
<a name="ln1717">    if ( AR_SREV_POSEIDON(ah) &amp;&amp; (ahp-&gt;ah_lna_div_use_bt_ant_enable == TRUE) ) {</a>
<a name="ln1718">        value &amp;= ~AR_SWITCH_TABLE_COM2_ALL;</a>
<a name="ln1719">        value |= ah-&gt;ah_config.ath_hal_ant_ctrl_comm2g_switch_enable;</a>
<a name="ln1720">	HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: com2=0x%08x\n&quot;, __func__, value)</a>
<a name="ln1721">    }</a>
<a name="ln1722">#endif  /* ATH_ANT_DIV_COMB */</a>
<a name="ln1723">    OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2, AR_SWITCH_TABLE_COM2_ALL, value);</a>
<a name="ln1724"> </a>
<a name="ln1725">#define AR_SWITCH_TABLE_ALL (0xfff)</a>
<a name="ln1726">#define AR_SWITCH_TABLE_ALL_S (0)</a>
<a name="ln1727">    value = ar9300_ant_ctrl_chain_get(ah, 0, is_2ghz);</a>
<a name="ln1728">    OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_CHAIN_0, AR_SWITCH_TABLE_ALL, value);</a>
<a name="ln1729"> </a>
<a name="ln1730">    if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah) &amp;&amp; !AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1731">        value = ar9300_ant_ctrl_chain_get(ah, 1, is_2ghz);</a>
<a name="ln1732">        OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_CHAIN_1, AR_SWITCH_TABLE_ALL, value);</a>
<a name="ln1733"> </a>
<a name="ln1734">        if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln1735">            value = ar9300_ant_ctrl_chain_get(ah, 2, is_2ghz);</a>
<a name="ln1736">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1737">                AR_PHY_SWITCH_CHAIN_2, AR_SWITCH_TABLE_ALL, value);</a>
<a name="ln1738">        }</a>
<a name="ln1739">    }</a>
<a name="ln1740">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1741">        value = ar9300_eeprom_get(ahp, EEP_ANTDIV_control);</a>
<a name="ln1742">        /* main_lnaconf, alt_lnaconf, main_tb, alt_tb */</a>
<a name="ln1743">        regval = OS_REG_READ(ah, AR_PHY_MC_GAIN_CTRL);</a>
<a name="ln1744">        regval &amp;= (~ANT_DIV_CONTROL_ALL); /* clear bit 25~30 */     </a>
<a name="ln1745">        regval |= (value &amp; 0x3f) &lt;&lt; ANT_DIV_CONTROL_ALL_S; </a>
<a name="ln1746">        /* enable_lnadiv */</a>
<a name="ln1747">        regval &amp;= (~MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__MASK);</a>
<a name="ln1748">        regval |= ((value &gt;&gt; 6) &amp; 0x1) &lt;&lt; </a>
<a name="ln1749">                  MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__SHIFT; </a>
<a name="ln1750">#if ATH_ANT_DIV_COMB</a>
<a name="ln1751">        if ( AR_SREV_POSEIDON(ah) &amp;&amp; (ahp-&gt;ah_lna_div_use_bt_ant_enable == TRUE) ) {</a>
<a name="ln1752">            regval |= ANT_DIV_ENABLE;</a>
<a name="ln1753">        }</a>
<a name="ln1754">        if (AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1755">                if (ahp-&gt;ah_lna_div_use_bt_ant_enable) {</a>
<a name="ln1756">                        regval |= (1 &lt;&lt; MULTICHAIN_GAIN_CTRL__ENABLE_ANT_SW_RX_PROT__SHIFT);</a>
<a name="ln1757"> </a>
<a name="ln1758">                        OS_REG_SET_BIT(ah, AR_PHY_RESTART,</a>
<a name="ln1759">                                    RESTART__ENABLE_ANT_FAST_DIV_M2FLAG__MASK);</a>
<a name="ln1760"> </a>
<a name="ln1761">                        /* Force WLAN LNA diversity ON */</a>
<a name="ln1762">                        OS_REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV,</a>
<a name="ln1763">                                    AR_BTCOEX_WL_LNADIV_FORCE_ON);</a>
<a name="ln1764">                } else {</a>
<a name="ln1765">                        regval &amp;= ~(1 &lt;&lt; MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__SHIFT);</a>
<a name="ln1766">                        regval &amp;= ~(1 &lt;&lt; MULTICHAIN_GAIN_CTRL__ENABLE_ANT_SW_RX_PROT__SHIFT);</a>
<a name="ln1767"> </a>
<a name="ln1768">                        OS_REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL,</a>
<a name="ln1769">                                    (1 &lt;&lt; MULTICHAIN_GAIN_CTRL__ENABLE_ANT_SW_RX_PROT__SHIFT));</a>
<a name="ln1770"> </a>
<a name="ln1771">                        /* Force WLAN LNA diversity OFF */</a>
<a name="ln1772">                        OS_REG_CLR_BIT(ah, AR_BTCOEX_WL_LNADIV,</a>
<a name="ln1773">                                    AR_BTCOEX_WL_LNADIV_FORCE_ON);</a>
<a name="ln1774">                }</a>
<a name="ln1775">        }</a>
<a name="ln1776"> </a>
<a name="ln1777">#endif  /* ATH_ANT_DIV_COMB */</a>
<a name="ln1778">        OS_REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);</a>
<a name="ln1779">        </a>
<a name="ln1780">        /* enable fast_div */</a>
<a name="ln1781">        regval = OS_REG_READ(ah, AR_PHY_CCK_DETECT);</a>
<a name="ln1782">        regval &amp;= (~BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__MASK);</a>
<a name="ln1783">        regval |= ((value &gt;&gt; 7) &amp; 0x1) &lt;&lt; </a>
<a name="ln1784">                  BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__SHIFT;</a>
<a name="ln1785">#if ATH_ANT_DIV_COMB</a>
<a name="ln1786">        if ((AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah))</a>
<a name="ln1787">          &amp;&amp; (ahp-&gt;ah_lna_div_use_bt_ant_enable == TRUE) ) {</a>
<a name="ln1788">            regval |= FAST_DIV_ENABLE;</a>
<a name="ln1789">        }</a>
<a name="ln1790">#endif  /* ATH_ANT_DIV_COMB */</a>
<a name="ln1791">        OS_REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);        </a>
<a name="ln1792">    }</a>
<a name="ln1793"> </a>
<a name="ln1794">#if ATH_ANT_DIV_COMB    </a>
<a name="ln1795">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON_11_OR_LATER(ah)) {</a>
<a name="ln1796">        if (pcap-&gt;halAntDivCombSupport) {</a>
<a name="ln1797">            /* If support DivComb, set MAIN to LNA1, ALT to LNA2 at beginning */</a>
<a name="ln1798">            regval = OS_REG_READ(ah, AR_PHY_MC_GAIN_CTRL);</a>
<a name="ln1799">            /* clear bit 25~30 main_lnaconf, alt_lnaconf, main_tb, alt_tb */</a>
<a name="ln1800">            regval &amp;= (~(MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__MASK | </a>
<a name="ln1801">                         MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__MASK | </a>
<a name="ln1802">                         MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_GAINTB__MASK | </a>
<a name="ln1803">                         MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_GAINTB__MASK)); </a>
<a name="ln1804">            regval |= (HAL_ANT_DIV_COMB_LNA1 &lt;&lt; </a>
<a name="ln1805">                       MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT); </a>
<a name="ln1806">            regval |= (HAL_ANT_DIV_COMB_LNA2 &lt;&lt; </a>
<a name="ln1807">                       MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT); </a>
<a name="ln1808">            OS_REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);</a>
<a name="ln1809">        }</a>
<a name="ln1810"> </a>
<a name="ln1811">    }</a>
<a name="ln1812">#endif /* ATH_ANT_DIV_COMB */</a>
<a name="ln1813">    if (AR_SREV_POSEIDON(ah) &amp;&amp; ( ahp-&gt;ah_diversity_control == HAL_ANT_FIXED_A </a>
<a name="ln1814">	     || ahp-&gt;ah_diversity_control == HAL_ANT_FIXED_B))</a>
<a name="ln1815">    {</a>
<a name="ln1816">        u_int32_t reg_val = OS_REG_READ(ah, AR_PHY_MC_GAIN_CTRL);</a>
<a name="ln1817">        reg_val &amp;=  ~(MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__MASK | </a>
<a name="ln1818">                    MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__MASK |</a>
<a name="ln1819">                    MULTICHAIN_GAIN_CTRL__ANT_FAST_DIV_BIAS__MASK |</a>
<a name="ln1820">    		        MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_GAINTB__MASK |</a>
<a name="ln1821">    		        MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_GAINTB__MASK );</a>
<a name="ln1822"> </a>
<a name="ln1823">        switch (ahp-&gt;ah_diversity_control) {</a>
<a name="ln1824">        case HAL_ANT_FIXED_A:</a>
<a name="ln1825">            /* Enable first antenna only */</a>
<a name="ln1826">            reg_val |= (HAL_ANT_DIV_COMB_LNA1 &lt;&lt; </a>
<a name="ln1827">                       MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT); </a>
<a name="ln1828">            reg_val |= (HAL_ANT_DIV_COMB_LNA2 &lt;&lt; </a>
<a name="ln1829">                       MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT); </a>
<a name="ln1830">            /* main/alt gain table and Fast Div Bias all set to 0 */</a>
<a name="ln1831">            OS_REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, reg_val);</a>
<a name="ln1832">            regval = OS_REG_READ(ah, AR_PHY_CCK_DETECT);</a>
<a name="ln1833">            regval &amp;= (~BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__MASK);</a>
<a name="ln1834">            OS_REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);        </a>
<a name="ln1835">            break;</a>
<a name="ln1836">        case HAL_ANT_FIXED_B:</a>
<a name="ln1837">            /* Enable second antenna only, after checking capability */</a>
<a name="ln1838">            reg_val |= (HAL_ANT_DIV_COMB_LNA2 &lt;&lt; </a>
<a name="ln1839">                       MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT); </a>
<a name="ln1840">            reg_val |= (HAL_ANT_DIV_COMB_LNA1 &lt;&lt; </a>
<a name="ln1841">                       MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT); </a>
<a name="ln1842">            /* main/alt gain table and Fast Div all set to 0 */</a>
<a name="ln1843">            OS_REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, reg_val);</a>
<a name="ln1844">            regval = OS_REG_READ(ah, AR_PHY_CCK_DETECT);</a>
<a name="ln1845">            regval &amp;= (~BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__MASK);</a>
<a name="ln1846">            OS_REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);        </a>
<a name="ln1847">            /* For WB225, need to swith ANT2 from BT to Wifi</a>
<a name="ln1848">             * This will not affect HB125 LNA diversity feature.</a>
<a name="ln1849">             */</a>
<a name="ln1850">	     HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: com2=0x%08x\n&quot;, __func__,</a>
<a name="ln1851">	         ah-&gt;ah_config.ath_hal_ant_ctrl_comm2g_switch_enable)</a>
<a name="ln1852">            OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2, AR_SWITCH_TABLE_COM2_ALL, </a>
<a name="ln1853">                ah-&gt;ah_config.ath_hal_ant_ctrl_comm2g_switch_enable);</a>
<a name="ln1854">            break;</a>
<a name="ln1855">        default:</a>
<a name="ln1856">            break;</a>
<a name="ln1857">        }</a>
<a name="ln1858">    }    </a>
<a name="ln1859">    return 0;</a>
<a name="ln1860">}</a>
<a name="ln1861"> </a>
<a name="ln1862">static u_int16_t</a>
<a name="ln1863">ar9300_attenuation_chain_get(struct ath_hal *ah, int chain, u_int16_t channel)</a>
<a name="ln1864">{</a>
<a name="ln1865">    int32_t f[3], t[3];</a>
<a name="ln1866">    u_int16_t value;</a>
<a name="ln1867">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1868">    if (chain &gt;= 0 &amp;&amp; chain &lt; OSPREY_MAX_CHAINS) {</a>
<a name="ln1869">        if (channel &lt; 4000) {</a>
<a name="ln1870">            return eep-&gt;modal_header_2g.xatten1_db[chain];</a>
<a name="ln1871">        } else {</a>
<a name="ln1872">            if (eep-&gt;base_ext2.xatten1_db_low[chain] != 0) {        </a>
<a name="ln1873">                t[0] = eep-&gt;base_ext2.xatten1_db_low[chain];</a>
<a name="ln1874">                f[0] = 5180;</a>
<a name="ln1875">                t[1] = eep-&gt;modal_header_5g.xatten1_db[chain];</a>
<a name="ln1876">                f[1] = 5500;</a>
<a name="ln1877">                t[2] = eep-&gt;base_ext2.xatten1_db_high[chain];</a>
<a name="ln1878">                f[2] = 5785;</a>
<a name="ln1879">                value = interpolate(channel, f, t, 3);</a>
<a name="ln1880">                return value;</a>
<a name="ln1881">            } else {</a>
<a name="ln1882">                return eep-&gt;modal_header_5g.xatten1_db[chain];</a>
<a name="ln1883">            }</a>
<a name="ln1884">        }</a>
<a name="ln1885">    }</a>
<a name="ln1886">    return 0;</a>
<a name="ln1887">}</a>
<a name="ln1888"> </a>
<a name="ln1889">static u_int16_t</a>
<a name="ln1890">ar9300_attenuation_margin_chain_get(struct ath_hal *ah, int chain,</a>
<a name="ln1891">    u_int16_t channel)</a>
<a name="ln1892">{</a>
<a name="ln1893">    int32_t f[3], t[3];</a>
<a name="ln1894">    u_int16_t value;</a>
<a name="ln1895">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln1896">    if (chain &gt;= 0 &amp;&amp; chain &lt; OSPREY_MAX_CHAINS) {</a>
<a name="ln1897">        if (channel &lt; 4000) {</a>
<a name="ln1898">            return eep-&gt;modal_header_2g.xatten1_margin[chain];</a>
<a name="ln1899">        } else {</a>
<a name="ln1900">            if (eep-&gt;base_ext2.xatten1_margin_low[chain] != 0) {    </a>
<a name="ln1901">                t[0] = eep-&gt;base_ext2.xatten1_margin_low[chain];</a>
<a name="ln1902">                f[0] = 5180;</a>
<a name="ln1903">                t[1] = eep-&gt;modal_header_5g.xatten1_margin[chain];</a>
<a name="ln1904">                f[1] = 5500;</a>
<a name="ln1905">                t[2] = eep-&gt;base_ext2.xatten1_margin_high[chain];</a>
<a name="ln1906">                f[2] = 5785;</a>
<a name="ln1907">                value = interpolate(channel, f, t, 3);</a>
<a name="ln1908">                return value;</a>
<a name="ln1909">            } else {</a>
<a name="ln1910">                return eep-&gt;modal_header_5g.xatten1_margin[chain];</a>
<a name="ln1911">            }</a>
<a name="ln1912">        }</a>
<a name="ln1913">    }</a>
<a name="ln1914">    return 0;</a>
<a name="ln1915">}</a>
<a name="ln1916"> </a>
<a name="ln1917">#if 0</a>
<a name="ln1918">HAL_BOOL ar9300_attenuation_apply(struct ath_hal *ah, u_int16_t channel)</a>
<a name="ln1919">{</a>
<a name="ln1920">    u_int32_t value;</a>
<a name="ln1921">//    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln1922"> </a>
<a name="ln1923">    /* Test value. if 0 then attenuation is unused. Don't load anything. */</a>
<a name="ln1924">    value = ar9300_attenuation_chain_get(ah, 0, channel);</a>
<a name="ln1925">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1926">        AR_PHY_EXT_ATTEN_CTL_0, AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB, value);</a>
<a name="ln1927">    value = ar9300_attenuation_margin_chain_get(ah, 0, channel);</a>
<a name="ln1928">    if (ar9300_rx_gain_index_get(ah) == 0</a>
<a name="ln1929">        &amp;&amp; ah-&gt;ah_config.ath_hal_ext_atten_margin_cfg)</a>
<a name="ln1930">    {</a>
<a name="ln1931">        value = 5;</a>
<a name="ln1932">    }</a>
<a name="ln1933">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1934">        AR_PHY_EXT_ATTEN_CTL_0, AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN, value);</a>
<a name="ln1935"> </a>
<a name="ln1936">    if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah)) {</a>
<a name="ln1937">        value = ar9300_attenuation_chain_get(ah, 1, channel);</a>
<a name="ln1938">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln1939">            AR_PHY_EXT_ATTEN_CTL_1, AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB, value);</a>
<a name="ln1940">        value = ar9300_attenuation_margin_chain_get(ah, 1, channel);</a>
<a name="ln1941">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln1942">            AR_PHY_EXT_ATTEN_CTL_1, AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,</a>
<a name="ln1943">            value);</a>
<a name="ln1944">        if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah)&amp;&amp; !AR_SREV_HONEYBEE(ah) ) {</a>
<a name="ln1945">            value = ar9300_attenuation_chain_get(ah, 2, channel);</a>
<a name="ln1946">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1947">                AR_PHY_EXT_ATTEN_CTL_2, AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB, value);</a>
<a name="ln1948">            value = ar9300_attenuation_margin_chain_get(ah, 2, channel);</a>
<a name="ln1949">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1950">                AR_PHY_EXT_ATTEN_CTL_2, AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,</a>
<a name="ln1951">                value);</a>
<a name="ln1952">        }</a>
<a name="ln1953">    }</a>
<a name="ln1954">    return 0;</a>
<a name="ln1955">}</a>
<a name="ln1956">#endif</a>
<a name="ln1957">HAL_BOOL</a>
<a name="ln1958">ar9300_attenuation_apply(struct ath_hal *ah, u_int16_t channel)</a>
<a name="ln1959">{</a>
<a name="ln1960">	int i;</a>
<a name="ln1961">	uint32_t value;</a>
<a name="ln1962">	uint32_t ext_atten_reg[3] = {</a>
<a name="ln1963">	    AR_PHY_EXT_ATTEN_CTL_0,</a>
<a name="ln1964">	    AR_PHY_EXT_ATTEN_CTL_1,</a>
<a name="ln1965">	    AR_PHY_EXT_ATTEN_CTL_2</a>
<a name="ln1966">	};</a>
<a name="ln1967"> </a>
<a name="ln1968">	/*</a>
<a name="ln1969">	 * If it's an AR9462 and we're receiving on the second</a>
<a name="ln1970">	 * chain only, set the chain 0 details from chain 1</a>
<a name="ln1971">	 * calibration.</a>
<a name="ln1972">	 *</a>
<a name="ln1973">	 * This is from ath9k.</a>
<a name="ln1974">	 */</a>
<a name="ln1975">	if (AR_SREV_JUPITER(ah) &amp;&amp; (AH9300(ah)-&gt;ah_rx_chainmask == 0x2)) {</a>
<a name="ln1976">		value = ar9300_attenuation_chain_get(ah, 1, channel);</a>
<a name="ln1977">		OS_REG_RMW_FIELD(ah, ext_atten_reg[0],</a>
<a name="ln1978">		    AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB, value);</a>
<a name="ln1979">		value = ar9300_attenuation_margin_chain_get(ah, 1, channel);</a>
<a name="ln1980">		OS_REG_RMW_FIELD(ah, ext_atten_reg[0],</a>
<a name="ln1981">		    AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN, value);</a>
<a name="ln1982">	}</a>
<a name="ln1983"> </a>
<a name="ln1984">	/*</a>
<a name="ln1985">	 * Now, loop over the configured transmit chains and</a>
<a name="ln1986">	 * load in the attenuation/margin settings as appropriate.</a>
<a name="ln1987">	 */</a>
<a name="ln1988">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln1989">		if ((AH9300(ah)-&gt;ah_tx_chainmask &amp; (1 &lt;&lt; i)) == 0)</a>
<a name="ln1990">			continue;</a>
<a name="ln1991"> </a>
<a name="ln1992">		value = ar9300_attenuation_chain_get(ah, i, channel);</a>
<a name="ln1993">		OS_REG_RMW_FIELD(ah, ext_atten_reg[i],</a>
<a name="ln1994">		    AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB,</a>
<a name="ln1995">		    value);</a>
<a name="ln1996"> </a>
<a name="ln1997">		if (AR_SREV_POSEIDON(ah) &amp;&amp;</a>
<a name="ln1998">		    (ar9300_rx_gain_index_get(ah) == 0) &amp;&amp;</a>
<a name="ln1999">		    ah-&gt;ah_config.ath_hal_ext_atten_margin_cfg) {</a>
<a name="ln2000">			value = 5;</a>
<a name="ln2001">		} else {</a>
<a name="ln2002">			value = ar9300_attenuation_margin_chain_get(ah, 0,</a>
<a name="ln2003">			    channel);</a>
<a name="ln2004">		}</a>
<a name="ln2005"> </a>
<a name="ln2006">		/*</a>
<a name="ln2007">		 * I'm not sure why it's loading in this setting into</a>
<a name="ln2008">		 * the chain 0 margin regardless of the current chain.</a>
<a name="ln2009">		 */</a>
<a name="ln2010">		if (ah-&gt;ah_config.ath_hal_min_gainidx)</a>
<a name="ln2011">			OS_REG_RMW_FIELD(ah,</a>
<a name="ln2012">			    AR_PHY_EXT_ATTEN_CTL_0,</a>
<a name="ln2013">			    AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,</a>
<a name="ln2014">			    value);</a>
<a name="ln2015"> </a>
<a name="ln2016">		OS_REG_RMW_FIELD(ah,</a>
<a name="ln2017">		    ext_atten_reg[i],</a>
<a name="ln2018">		    AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN,</a>
<a name="ln2019">		    value);</a>
<a name="ln2020">	}</a>
<a name="ln2021"> </a>
<a name="ln2022">	return (0);</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025"> </a>
<a name="ln2026">static u_int16_t ar9300_quick_drop_get(struct ath_hal *ah, </a>
<a name="ln2027">								int chain, u_int16_t channel)</a>
<a name="ln2028">{</a>
<a name="ln2029">    int32_t f[3], t[3];</a>
<a name="ln2030">    u_int16_t value;</a>
<a name="ln2031">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln2032"> </a>
<a name="ln2033">    if (channel &lt; 4000) {</a>
<a name="ln2034">        return eep-&gt;modal_header_2g.quick_drop;</a>
<a name="ln2035">    } else {</a>
<a name="ln2036">        t[0] = eep-&gt;base_ext1.quick_drop_low;</a>
<a name="ln2037">        f[0] = 5180;</a>
<a name="ln2038">        t[1] = eep-&gt;modal_header_5g.quick_drop;</a>
<a name="ln2039">        f[1] = 5500;</a>
<a name="ln2040">        t[2] = eep-&gt;base_ext1.quick_drop_high;</a>
<a name="ln2041">        f[2] = 5785;</a>
<a name="ln2042">        value = interpolate(channel, f, t, 3);</a>
<a name="ln2043">        return value;</a>
<a name="ln2044">    }</a>
<a name="ln2045">}</a>
<a name="ln2046"> </a>
<a name="ln2047"> </a>
<a name="ln2048">static HAL_BOOL ar9300_quick_drop_apply(struct ath_hal *ah, u_int16_t channel)</a>
<a name="ln2049">{</a>
<a name="ln2050">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln2051">    u_int32_t value;</a>
<a name="ln2052">    //</a>
<a name="ln2053">    // Test value. if 0 then quickDrop is unused. Don't load anything.</a>
<a name="ln2054">    //</a>
<a name="ln2055">    if (eep-&gt;base_eep_header.misc_configuration &amp; 0x10)</a>
<a name="ln2056">	{</a>
<a name="ln2057">        if (AR_SREV_OSPREY(ah) || AR_SREV_AR9580(ah) || AR_SREV_WASP(ah)) </a>
<a name="ln2058">        {</a>
<a name="ln2059">            value = ar9300_quick_drop_get(ah, 0, channel);</a>
<a name="ln2060">            OS_REG_RMW_FIELD(ah, AR_PHY_AGC, AR_PHY_AGC_QUICK_DROP, value);</a>
<a name="ln2061">        }</a>
<a name="ln2062">    }</a>
<a name="ln2063">    return 0;</a>
<a name="ln2064">}</a>
<a name="ln2065"> </a>
<a name="ln2066">static u_int16_t ar9300_tx_end_to_xpa_off_get(struct ath_hal *ah, u_int16_t channel)</a>
<a name="ln2067">{</a>
<a name="ln2068">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln2069"> </a>
<a name="ln2070">    if (channel &lt; 4000) {</a>
<a name="ln2071">        return eep-&gt;modal_header_2g.tx_end_to_xpa_off;</a>
<a name="ln2072">    } else {</a>
<a name="ln2073">        return eep-&gt;modal_header_5g.tx_end_to_xpa_off;</a>
<a name="ln2074">    }</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077">static HAL_BOOL ar9300_tx_end_to_xpab_off_apply(struct ath_hal *ah, u_int16_t channel)</a>
<a name="ln2078">{</a>
<a name="ln2079">    u_int32_t value;</a>
<a name="ln2080"> </a>
<a name="ln2081">    value = ar9300_tx_end_to_xpa_off_get(ah, channel);</a>
<a name="ln2082">    /* Apply to both xpaa and xpab */</a>
<a name="ln2083">    if (AR_SREV_OSPREY(ah) || AR_SREV_AR9580(ah) || AR_SREV_WASP(ah)) </a>
<a name="ln2084">    {</a>
<a name="ln2085">        OS_REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL, </a>
<a name="ln2086">            AR_PHY_XPA_TIMING_CTL_TX_END_XPAB_OFF, value);</a>
<a name="ln2087">        OS_REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL, </a>
<a name="ln2088">            AR_PHY_XPA_TIMING_CTL_TX_END_XPAA_OFF, value);</a>
<a name="ln2089">    }</a>
<a name="ln2090">    return 0;</a>
<a name="ln2091">}</a>
<a name="ln2092"> </a>
<a name="ln2093">static int</a>
<a name="ln2094">ar9300_eeprom_cal_pier_get(struct ath_hal *ah, int mode, int ipier, int ichain, </a>
<a name="ln2095">    int *pfrequency, int *pcorrection, int *ptemperature, int *pvoltage)</a>
<a name="ln2096">{</a>
<a name="ln2097">    u_int8_t *p_cal_pier;</a>
<a name="ln2098">    OSP_CAL_DATA_PER_FREQ_OP_LOOP *p_cal_pier_struct;</a>
<a name="ln2099">    int is_2ghz;</a>
<a name="ln2100">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln2101"> </a>
<a name="ln2102">    if (ichain &gt;= OSPREY_MAX_CHAINS) {</a>
<a name="ln2103">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln2104">            &quot;%s: Invalid chain index, must be less than %d\n&quot;,</a>
<a name="ln2105">            __func__, OSPREY_MAX_CHAINS);</a>
<a name="ln2106">        return -1;</a>
<a name="ln2107">    }</a>
<a name="ln2108"> </a>
<a name="ln2109">    if (mode) {/* 5GHz */</a>
<a name="ln2110">        if (ipier &gt;= OSPREY_NUM_5G_CAL_PIERS){</a>
<a name="ln2111">            HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln2112">                &quot;%s: Invalid 5GHz cal pier index, must be less than %d\n&quot;,</a>
<a name="ln2113">                __func__, OSPREY_NUM_5G_CAL_PIERS);</a>
<a name="ln2114">            return -1;</a>
<a name="ln2115">        }</a>
<a name="ln2116">        p_cal_pier = &amp;(eep-&gt;cal_freq_pier_5g[ipier]);</a>
<a name="ln2117">        p_cal_pier_struct = &amp;(eep-&gt;cal_pier_data_5g[ichain][ipier]);</a>
<a name="ln2118">        is_2ghz = 0;</a>
<a name="ln2119">    } else {</a>
<a name="ln2120">        if (ipier &gt;= OSPREY_NUM_2G_CAL_PIERS){</a>
<a name="ln2121">            HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln2122">                &quot;%s: Invalid 2GHz cal pier index, must be less than %d\n&quot;,</a>
<a name="ln2123">                __func__, OSPREY_NUM_2G_CAL_PIERS);</a>
<a name="ln2124">            return -1;</a>
<a name="ln2125">        }</a>
<a name="ln2126"> </a>
<a name="ln2127">        p_cal_pier = &amp;(eep-&gt;cal_freq_pier_2g[ipier]);</a>
<a name="ln2128">        p_cal_pier_struct = &amp;(eep-&gt;cal_pier_data_2g[ichain][ipier]);</a>
<a name="ln2129">        is_2ghz = 1;</a>
<a name="ln2130">    }</a>
<a name="ln2131">    *pfrequency = FBIN2FREQ(*p_cal_pier, is_2ghz);</a>
<a name="ln2132">    *pcorrection = p_cal_pier_struct-&gt;ref_power;</a>
<a name="ln2133">    *ptemperature = p_cal_pier_struct-&gt;temp_meas;</a>
<a name="ln2134">    *pvoltage = p_cal_pier_struct-&gt;volt_meas;</a>
<a name="ln2135">    return 0;</a>
<a name="ln2136">}</a>
<a name="ln2137"> </a>
<a name="ln2138">/*</a>
<a name="ln2139"> * Apply the recorded correction values.</a>
<a name="ln2140"> */</a>
<a name="ln2141">static int</a>
<a name="ln2142">ar9300_calibration_apply(struct ath_hal *ah, int frequency)</a>
<a name="ln2143">{</a>
<a name="ln2144">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2145"> </a>
<a name="ln2146">    int ichain, ipier, npier;</a>
<a name="ln2147">    int mode;</a>
<a name="ln2148">    int fdiff;</a>
<a name="ln2149">    int pfrequency, pcorrection, ptemperature, pvoltage; </a>
<a name="ln2150">    int bf, factor, plus;</a>
<a name="ln2151"> </a>
<a name="ln2152">    int lfrequency[AR9300_MAX_CHAINS];</a>
<a name="ln2153">    int hfrequency[AR9300_MAX_CHAINS];</a>
<a name="ln2154"> </a>
<a name="ln2155">    int lcorrection[AR9300_MAX_CHAINS];</a>
<a name="ln2156">    int hcorrection[AR9300_MAX_CHAINS];</a>
<a name="ln2157">    int correction[AR9300_MAX_CHAINS];</a>
<a name="ln2158"> </a>
<a name="ln2159">    int ltemperature[AR9300_MAX_CHAINS];</a>
<a name="ln2160">    int htemperature[AR9300_MAX_CHAINS];</a>
<a name="ln2161">    int temperature[AR9300_MAX_CHAINS];</a>
<a name="ln2162"> </a>
<a name="ln2163">    int lvoltage[AR9300_MAX_CHAINS];</a>
<a name="ln2164">    int hvoltage[AR9300_MAX_CHAINS];</a>
<a name="ln2165">    int voltage[AR9300_MAX_CHAINS];</a>
<a name="ln2166"> </a>
<a name="ln2167">    mode = (frequency &gt;= 4000);</a>
<a name="ln2168">    npier = (mode) ?  OSPREY_NUM_5G_CAL_PIERS : OSPREY_NUM_2G_CAL_PIERS;</a>
<a name="ln2169"> </a>
<a name="ln2170">    for (ichain = 0; ichain &lt; AR9300_MAX_CHAINS; ichain++) {</a>
<a name="ln2171">        lfrequency[ichain] = 0;</a>
<a name="ln2172">        hfrequency[ichain] = 100000;</a>
<a name="ln2173">    }</a>
<a name="ln2174">    /*</a>
<a name="ln2175">     * identify best lower and higher frequency calibration measurement</a>
<a name="ln2176">     */</a>
<a name="ln2177">    for (ichain = 0; ichain &lt; AR9300_MAX_CHAINS; ichain++) {</a>
<a name="ln2178">        for (ipier = 0; ipier &lt; npier; ipier++) {</a>
<a name="ln2179">            if (ar9300_eeprom_cal_pier_get(</a>
<a name="ln2180">                    ah, mode, ipier, ichain,</a>
<a name="ln2181">                    &amp;pfrequency, &amp;pcorrection, &amp;ptemperature, &amp;pvoltage) == 0)</a>
<a name="ln2182">            {</a>
<a name="ln2183">                fdiff = frequency - pfrequency;</a>
<a name="ln2184">                /*</a>
<a name="ln2185">                 * this measurement is higher than our desired frequency</a>
<a name="ln2186">                 */</a>
<a name="ln2187">                if (fdiff &lt;= 0) {</a>
<a name="ln2188">                    if (hfrequency[ichain] &lt;= 0 ||</a>
<a name="ln2189">                        hfrequency[ichain] &gt;= 100000 ||</a>
<a name="ln2190">                        fdiff &gt; (frequency - hfrequency[ichain]))</a>
<a name="ln2191">                    {</a>
<a name="ln2192">                        /*</a>
<a name="ln2193">                         * new best higher frequency measurement</a>
<a name="ln2194">                         */</a>
<a name="ln2195">                        hfrequency[ichain] = pfrequency;</a>
<a name="ln2196">                        hcorrection[ichain] = pcorrection;</a>
<a name="ln2197">                        htemperature[ichain] = ptemperature;</a>
<a name="ln2198">                        hvoltage[ichain] = pvoltage;</a>
<a name="ln2199">                    }</a>
<a name="ln2200">                }</a>
<a name="ln2201">                if (fdiff &gt;= 0) {</a>
<a name="ln2202">                    if (lfrequency[ichain] &lt;= 0 ||</a>
<a name="ln2203">                        fdiff &lt; (frequency - lfrequency[ichain]))</a>
<a name="ln2204">                    {</a>
<a name="ln2205">                        /*</a>
<a name="ln2206">                         * new best lower frequency measurement</a>
<a name="ln2207">                         */</a>
<a name="ln2208">                        lfrequency[ichain] = pfrequency;</a>
<a name="ln2209">                        lcorrection[ichain] = pcorrection;</a>
<a name="ln2210">                        ltemperature[ichain] = ptemperature;</a>
<a name="ln2211">                        lvoltage[ichain] = pvoltage;</a>
<a name="ln2212">                    }</a>
<a name="ln2213">                }</a>
<a name="ln2214">            }</a>
<a name="ln2215">        }</a>
<a name="ln2216">    }</a>
<a name="ln2217">    /* interpolate */</a>
<a name="ln2218">    for (ichain = 0; ichain &lt; AR9300_MAX_CHAINS; ichain++) {</a>
<a name="ln2219">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln2220">            &quot;%s: ch=%d f=%d low=%d %d h=%d %d\n&quot;,</a>
<a name="ln2221">            __func__, ichain, frequency,</a>
<a name="ln2222">            lfrequency[ichain], lcorrection[ichain],</a>
<a name="ln2223">            hfrequency[ichain], hcorrection[ichain]);</a>
<a name="ln2224">        /*</a>
<a name="ln2225">         * they're the same, so just pick one</a>
<a name="ln2226">         */ </a>
<a name="ln2227">        if (hfrequency[ichain] == lfrequency[ichain]) {</a>
<a name="ln2228">            correction[ichain] = lcorrection[ichain];</a>
<a name="ln2229">            voltage[ichain] = lvoltage[ichain];</a>
<a name="ln2230">            temperature[ichain] = ltemperature[ichain];</a>
<a name="ln2231">        } else if (frequency - lfrequency[ichain] &lt; 1000) {</a>
<a name="ln2232">            /* the low frequency is good */</a>
<a name="ln2233">            if (hfrequency[ichain] - frequency &lt; 1000) {</a>
<a name="ln2234">                /*</a>
<a name="ln2235">                 * The high frequency is good too -</a>
<a name="ln2236">                 * interpolate with round off.</a>
<a name="ln2237">                 */</a>
<a name="ln2238">                int mult, div, diff;</a>
<a name="ln2239">                mult = frequency - lfrequency[ichain];</a>
<a name="ln2240">                div = hfrequency[ichain] - lfrequency[ichain];</a>
<a name="ln2241"> </a>
<a name="ln2242">                diff = hcorrection[ichain] - lcorrection[ichain];</a>
<a name="ln2243">                bf = 2 * diff * mult / div;</a>
<a name="ln2244">                plus = (bf % 2);</a>
<a name="ln2245">                factor = bf / 2;</a>
<a name="ln2246">                correction[ichain] = lcorrection[ichain] + factor + plus;</a>
<a name="ln2247"> </a>
<a name="ln2248">                diff = htemperature[ichain] - ltemperature[ichain];</a>
<a name="ln2249">                bf = 2 * diff * mult / div;</a>
<a name="ln2250">                plus = (bf % 2);</a>
<a name="ln2251">                factor = bf / 2;</a>
<a name="ln2252">                temperature[ichain] = ltemperature[ichain] + factor + plus;</a>
<a name="ln2253"> </a>
<a name="ln2254">                diff = hvoltage[ichain] - lvoltage[ichain];</a>
<a name="ln2255">                bf = 2 * diff * mult / div;</a>
<a name="ln2256">                plus = (bf % 2);</a>
<a name="ln2257">                factor = bf / 2;</a>
<a name="ln2258">                voltage[ichain] = lvoltage[ichain] + factor + plus;</a>
<a name="ln2259">            } else {</a>
<a name="ln2260">                /* only low is good, use it */</a>
<a name="ln2261">                correction[ichain] = lcorrection[ichain];</a>
<a name="ln2262">                temperature[ichain] = ltemperature[ichain];</a>
<a name="ln2263">                voltage[ichain] = lvoltage[ichain];</a>
<a name="ln2264">            }</a>
<a name="ln2265">        } else if (hfrequency[ichain] - frequency &lt; 1000) {</a>
<a name="ln2266">            /* only high is good, use it */</a>
<a name="ln2267">            correction[ichain] = hcorrection[ichain];</a>
<a name="ln2268">            temperature[ichain] = htemperature[ichain];</a>
<a name="ln2269">            voltage[ichain] = hvoltage[ichain];</a>
<a name="ln2270">        } else {</a>
<a name="ln2271">            /* nothing is good, presume 0???? */</a>
<a name="ln2272">            correction[ichain] = 0;</a>
<a name="ln2273">            temperature[ichain] = 0;</a>
<a name="ln2274">            voltage[ichain] = 0;</a>
<a name="ln2275">        }</a>
<a name="ln2276">    }</a>
<a name="ln2277"> </a>
<a name="ln2278">    /* GreenTx isn't currently supported */</a>
<a name="ln2279">    /* GreenTx */</a>
<a name="ln2280">    if (ah-&gt;ah_config.ath_hal_sta_update_tx_pwr_enable) {</a>
<a name="ln2281">        if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln2282">            /* Get calibrated OLPC gain delta value for GreenTx */</a>
<a name="ln2283">            ahp-&gt;ah_db2[POSEIDON_STORED_REG_G2_OLPC_OFFSET] = </a>
<a name="ln2284">                (u_int32_t) correction[0];</a>
<a name="ln2285">        }</a>
<a name="ln2286">    }</a>
<a name="ln2287"> </a>
<a name="ln2288">    ar9300_power_control_override(</a>
<a name="ln2289">        ah, frequency, correction, voltage, temperature);</a>
<a name="ln2290">    HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln2291">        &quot;%s: for frequency=%d, calibration correction = %d %d %d\n&quot;,</a>
<a name="ln2292">         __func__, frequency, correction[0], correction[1], correction[2]);</a>
<a name="ln2293"> </a>
<a name="ln2294">    return 0;</a>
<a name="ln2295">}</a>
<a name="ln2296"> </a>
<a name="ln2297">int</a>
<a name="ln2298">ar9300_power_control_override(struct ath_hal *ah, int frequency,</a>
<a name="ln2299">    int *correction, int *voltage, int *temperature)</a>
<a name="ln2300">{</a>
<a name="ln2301">    int temp_slope = 0;</a>
<a name="ln2302">    int temp_slope_1 = 0;</a>
<a name="ln2303">    int temp_slope_2 = 0;</a>
<a name="ln2304">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln2305">    int32_t f[8], t[8],t1[3], t2[3];</a>
<a name="ln2306">	int i;</a>
<a name="ln2307"> </a>
<a name="ln2308">    OS_REG_RMW(ah, AR_PHY_TPC_11_B0,</a>
<a name="ln2309">        (correction[0] &lt;&lt; AR_PHY_TPC_OLPC_GAIN_DELTA_S),</a>
<a name="ln2310">        AR_PHY_TPC_OLPC_GAIN_DELTA);</a>
<a name="ln2311">    if (!AR_SREV_POSEIDON(ah)) {</a>
<a name="ln2312">        OS_REG_RMW(ah, AR_PHY_TPC_11_B1,</a>
<a name="ln2313">            (correction[1] &lt;&lt; AR_PHY_TPC_OLPC_GAIN_DELTA_S),</a>
<a name="ln2314">            AR_PHY_TPC_OLPC_GAIN_DELTA);</a>
<a name="ln2315">        if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah) ) {</a>
<a name="ln2316">            OS_REG_RMW(ah, AR_PHY_TPC_11_B2, </a>
<a name="ln2317">                (correction[2] &lt;&lt; AR_PHY_TPC_OLPC_GAIN_DELTA_S),</a>
<a name="ln2318">                AR_PHY_TPC_OLPC_GAIN_DELTA);</a>
<a name="ln2319">        }</a>
<a name="ln2320">    }</a>
<a name="ln2321">    /*</a>
<a name="ln2322">     * enable open loop power control on chip</a>
<a name="ln2323">     */</a>
<a name="ln2324">    OS_REG_RMW(ah, AR_PHY_TPC_6_B0,</a>
<a name="ln2325">        (3 &lt;&lt; AR_PHY_TPC_6_ERROR_EST_MODE_S), AR_PHY_TPC_6_ERROR_EST_MODE);</a>
<a name="ln2326">    if (!AR_SREV_POSEIDON(ah)) {</a>
<a name="ln2327">        OS_REG_RMW(ah, AR_PHY_TPC_6_B1, </a>
<a name="ln2328">            (3 &lt;&lt; AR_PHY_TPC_6_ERROR_EST_MODE_S), AR_PHY_TPC_6_ERROR_EST_MODE);</a>
<a name="ln2329">        if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah)  ) {</a>
<a name="ln2330">            OS_REG_RMW(ah, AR_PHY_TPC_6_B2, </a>
<a name="ln2331">                (3 &lt;&lt; AR_PHY_TPC_6_ERROR_EST_MODE_S),</a>
<a name="ln2332">                AR_PHY_TPC_6_ERROR_EST_MODE);</a>
<a name="ln2333">        }</a>
<a name="ln2334">    }</a>
<a name="ln2335"> </a>
<a name="ln2336">    /*</a>
<a name="ln2337">     * Enable temperature compensation</a>
<a name="ln2338">     * Need to use register names</a>
<a name="ln2339">     */</a>
<a name="ln2340">    if (frequency &lt; 4000) {</a>
<a name="ln2341">        temp_slope = eep-&gt;modal_header_2g.temp_slope;</a>
<a name="ln2342">    } else {</a>
<a name="ln2343">		if ((eep-&gt;base_eep_header.misc_configuration &amp; 0x20) != 0)</a>
<a name="ln2344">		{</a>
<a name="ln2345">				for(i=0;i&lt;8;i++)</a>
<a name="ln2346">				{</a>
<a name="ln2347">					t[i]=eep-&gt;base_ext1.tempslopextension[i];</a>
<a name="ln2348">					f[i]=FBIN2FREQ(eep-&gt;cal_freq_pier_5g[i], 0);</a>
<a name="ln2349">				}</a>
<a name="ln2350">				temp_slope=interpolate(frequency,f,t,8);</a>
<a name="ln2351">		}</a>
<a name="ln2352">		else</a>
<a name="ln2353">		{</a>
<a name="ln2354">        if(!AR_SREV_SCORPION(ah)) {</a>
<a name="ln2355">          if (eep-&gt;base_ext2.temp_slope_low != 0) {</a>
<a name="ln2356">             t[0] = eep-&gt;base_ext2.temp_slope_low;</a>
<a name="ln2357">             f[0] = 5180;</a>
<a name="ln2358">             t[1] = eep-&gt;modal_header_5g.temp_slope;</a>
<a name="ln2359">             f[1] = 5500;</a>
<a name="ln2360">             t[2] = eep-&gt;base_ext2.temp_slope_high;</a>
<a name="ln2361">             f[2] = 5785;</a>
<a name="ln2362">             temp_slope = interpolate(frequency, f, t, 3);</a>
<a name="ln2363">           } else {</a>
<a name="ln2364">             temp_slope = eep-&gt;modal_header_5g.temp_slope;</a>
<a name="ln2365">           }</a>
<a name="ln2366">         } else {</a>
<a name="ln2367">            /*</a>
<a name="ln2368">             * Scorpion has individual chain tempslope values</a>
<a name="ln2369">             */</a>
<a name="ln2370">             t[0] = eep-&gt;base_ext1.tempslopextension[2];</a>
<a name="ln2371">             t1[0]= eep-&gt;base_ext1.tempslopextension[3];</a>
<a name="ln2372">             t2[0]= eep-&gt;base_ext1.tempslopextension[4];</a>
<a name="ln2373">             f[0] = 5180;</a>
<a name="ln2374">             t[1] = eep-&gt;modal_header_5g.temp_slope;</a>
<a name="ln2375">             t1[1]= eep-&gt;base_ext1.tempslopextension[0];</a>
<a name="ln2376">             t2[1]= eep-&gt;base_ext1.tempslopextension[1];</a>
<a name="ln2377">             f[1] = 5500;</a>
<a name="ln2378">             t[2] = eep-&gt;base_ext1.tempslopextension[5];</a>
<a name="ln2379">             t1[2]= eep-&gt;base_ext1.tempslopextension[6];</a>
<a name="ln2380">             t2[2]= eep-&gt;base_ext1.tempslopextension[7];</a>
<a name="ln2381">             f[2] = 5785;</a>
<a name="ln2382">             temp_slope = interpolate(frequency, f, t, 3);</a>
<a name="ln2383">             temp_slope_1=interpolate(frequency, f, t1,3);</a>
<a name="ln2384">             temp_slope_2=interpolate(frequency, f, t2,3);</a>
<a name="ln2385">       } </a>
<a name="ln2386">	 }</a>
<a name="ln2387">  }</a>
<a name="ln2388"> </a>
<a name="ln2389">    if (!AR_SREV_SCORPION(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln2390">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln2391">            AR_PHY_TPC_19, AR_PHY_TPC_19_ALPHA_THERM, temp_slope);</a>
<a name="ln2392">    } else {</a>
<a name="ln2393">        /*Scorpion and Honeybee has tempSlope register for each chain*/</a>
<a name="ln2394">        /*Check whether temp_compensation feature is enabled or not*/</a>
<a name="ln2395">        if (eep-&gt;base_eep_header.feature_enable &amp; 0x1){</a>
<a name="ln2396">	    if(frequency &lt; 4000) {</a>
<a name="ln2397">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x1) {</a>
<a name="ln2398">		    OS_REG_RMW_FIELD(ah,</a>
<a name="ln2399">				    AR_PHY_TPC_19, AR_PHY_TPC_19_ALPHA_THERM, </a>
<a name="ln2400">				    eep-&gt;base_ext2.temp_slope_low);</a>
<a name="ln2401">		    } </a>
<a name="ln2402">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x2) {</a>
<a name="ln2403">		    OS_REG_RMW_FIELD(ah,</a>
<a name="ln2404">				    AR_SCORPION_PHY_TPC_19_B1, AR_PHY_TPC_19_ALPHA_THERM, </a>
<a name="ln2405">				    temp_slope);</a>
<a name="ln2406">		    } </a>
<a name="ln2407">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x4) {</a>
<a name="ln2408">		    OS_REG_RMW_FIELD(ah,</a>
<a name="ln2409">				    AR_SCORPION_PHY_TPC_19_B2, AR_PHY_TPC_19_ALPHA_THERM, </a>
<a name="ln2410">				    eep-&gt;base_ext2.temp_slope_high);</a>
<a name="ln2411">		     } 	</a>
<a name="ln2412">	    } else {</a>
<a name="ln2413">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x1) {</a>
<a name="ln2414">		    OS_REG_RMW_FIELD(ah,</a>
<a name="ln2415">				    AR_PHY_TPC_19, AR_PHY_TPC_19_ALPHA_THERM, </a>
<a name="ln2416">				    temp_slope);</a>
<a name="ln2417">			}</a>
<a name="ln2418">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x2) {</a>
<a name="ln2419">		    OS_REG_RMW_FIELD(ah,</a>
<a name="ln2420">				    AR_SCORPION_PHY_TPC_19_B1, AR_PHY_TPC_19_ALPHA_THERM, </a>
<a name="ln2421">				    temp_slope_1);</a>
<a name="ln2422">		}</a>
<a name="ln2423">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x4) {</a>
<a name="ln2424">		    OS_REG_RMW_FIELD(ah,</a>
<a name="ln2425">				    AR_SCORPION_PHY_TPC_19_B2, AR_PHY_TPC_19_ALPHA_THERM, </a>
<a name="ln2426">				    temp_slope_2);</a>
<a name="ln2427">			} </a>
<a name="ln2428">	    }</a>
<a name="ln2429">        }else {</a>
<a name="ln2430">        	/* If temp compensation is not enabled, set all registers to 0*/</a>
<a name="ln2431">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x1) {</a>
<a name="ln2432">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2433">                AR_PHY_TPC_19, AR_PHY_TPC_19_ALPHA_THERM, 0);</a>
<a name="ln2434">		    }</a>
<a name="ln2435">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x2) {</a>
<a name="ln2436">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2437">                AR_SCORPION_PHY_TPC_19_B1, AR_PHY_TPC_19_ALPHA_THERM, 0);</a>
<a name="ln2438">		    }  </a>
<a name="ln2439">		if (((eep-&gt;base_eep_header.txrx_mask &amp; 0xf0) &gt;&gt; 4) &amp; 0x4) {</a>
<a name="ln2440">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2441">                AR_SCORPION_PHY_TPC_19_B2, AR_PHY_TPC_19_ALPHA_THERM, 0);</a>
<a name="ln2442">		} </a>
<a name="ln2443">        }</a>
<a name="ln2444">    }</a>
<a name="ln2445">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln2446">        AR_PHY_TPC_18, AR_PHY_TPC_18_THERM_CAL_VALUE, temperature[0]);</a>
<a name="ln2447"> </a>
<a name="ln2448">    return 0;</a>
<a name="ln2449">}</a>
<a name="ln2450"> </a>
<a name="ln2451">/**************************************************************</a>
<a name="ln2452"> * ar9300_eep_def_get_max_edge_power</a>
<a name="ln2453"> *</a>
<a name="ln2454"> * Find the maximum conformance test limit for the given channel and CTL info</a>
<a name="ln2455"> */</a>
<a name="ln2456">static inline u_int16_t</a>
<a name="ln2457">ar9300_eep_def_get_max_edge_power(ar9300_eeprom_t *p_eep_data, u_int16_t freq,</a>
<a name="ln2458">    int idx, HAL_BOOL is_2ghz)</a>
<a name="ln2459">{</a>
<a name="ln2460">    u_int16_t twice_max_edge_power = AR9300_MAX_RATE_POWER;</a>
<a name="ln2461">    u_int8_t *ctl_freqbin = is_2ghz ?</a>
<a name="ln2462">        &amp;p_eep_data-&gt;ctl_freqbin_2G[idx][0] :</a>
<a name="ln2463">        &amp;p_eep_data-&gt;ctl_freqbin_5G[idx][0];</a>
<a name="ln2464">    u_int16_t num_edges = is_2ghz ?</a>
<a name="ln2465">        OSPREY_NUM_BAND_EDGES_2G : OSPREY_NUM_BAND_EDGES_5G;</a>
<a name="ln2466">    int i;</a>
<a name="ln2467"> </a>
<a name="ln2468">    /* Get the edge power */</a>
<a name="ln2469">    for (i = 0; (i &lt; num_edges) &amp;&amp; (ctl_freqbin[i] != AR9300_BCHAN_UNUSED); i++)</a>
<a name="ln2470">    {</a>
<a name="ln2471">        /*</a>
<a name="ln2472">         * If there's an exact channel match or an inband flag set</a>
<a name="ln2473">         * on the lower channel use the given rd_edge_power</a>
<a name="ln2474">         */</a>
<a name="ln2475">        if (freq == fbin2freq(ctl_freqbin[i], is_2ghz)) {</a>
<a name="ln2476">            if (is_2ghz) {</a>
<a name="ln2477">                twice_max_edge_power =</a>
<a name="ln2478">                    p_eep_data-&gt;ctl_power_data_2g[idx].ctl_edges[i].t_power;</a>
<a name="ln2479">            } else {       </a>
<a name="ln2480">                twice_max_edge_power =</a>
<a name="ln2481">                    p_eep_data-&gt;ctl_power_data_5g[idx].ctl_edges[i].t_power;</a>
<a name="ln2482">            }</a>
<a name="ln2483">            break;</a>
<a name="ln2484">        } else if ((i &gt; 0) &amp;&amp; (freq &lt; fbin2freq(ctl_freqbin[i], is_2ghz))) {</a>
<a name="ln2485">            if (is_2ghz) {</a>
<a name="ln2486">                if (fbin2freq(ctl_freqbin[i - 1], 1) &lt; freq &amp;&amp;</a>
<a name="ln2487">                    p_eep_data-&gt;ctl_power_data_2g[idx].ctl_edges[i - 1].flag)</a>
<a name="ln2488">                {</a>
<a name="ln2489">                    twice_max_edge_power =</a>
<a name="ln2490">                        p_eep_data-&gt;ctl_power_data_2g[idx].</a>
<a name="ln2491">                            ctl_edges[i - 1].t_power;</a>
<a name="ln2492">                }</a>
<a name="ln2493">            } else {</a>
<a name="ln2494">                if (fbin2freq(ctl_freqbin[i - 1], 0) &lt; freq &amp;&amp;</a>
<a name="ln2495">                    p_eep_data-&gt;ctl_power_data_5g[idx].ctl_edges[i - 1].flag)</a>
<a name="ln2496">                {</a>
<a name="ln2497">                    twice_max_edge_power =</a>
<a name="ln2498">                        p_eep_data-&gt;ctl_power_data_5g[idx].</a>
<a name="ln2499">                            ctl_edges[i - 1].t_power;</a>
<a name="ln2500">                }</a>
<a name="ln2501">            }</a>
<a name="ln2502">            /*</a>
<a name="ln2503">             * Leave loop - no more affecting edges possible</a>
<a name="ln2504">             * in this monotonic increasing list</a>
<a name="ln2505">             */</a>
<a name="ln2506">            break;</a>
<a name="ln2507">        }</a>
<a name="ln2508">    }</a>
<a name="ln2509">    /*</a>
<a name="ln2510">     * EV89475: EEPROM might contain 0 txpower in CTL table for certain</a>
<a name="ln2511">     * 2.4GHz channels. We workaround it by overwriting 60 (30 dBm) here.</a>
<a name="ln2512">     */</a>
<a name="ln2513">    if (is_2ghz &amp;&amp; (twice_max_edge_power == 0)) {</a>
<a name="ln2514">        twice_max_edge_power = 60;</a>
<a name="ln2515">    }</a>
<a name="ln2516"> </a>
<a name="ln2517">    HALASSERT(twice_max_edge_power &gt; 0);</a>
<a name="ln2518">    return twice_max_edge_power;</a>
<a name="ln2519">}</a>
<a name="ln2520"> </a>
<a name="ln2521">HAL_BOOL</a>
<a name="ln2522">ar9300_eeprom_set_power_per_rate_table(</a>
<a name="ln2523">    struct ath_hal *ah,</a>
<a name="ln2524">    ar9300_eeprom_t *p_eep_data,</a>
<a name="ln2525">    const struct ieee80211_channel *chan,</a>
<a name="ln2526">    u_int8_t *p_pwr_array,</a>
<a name="ln2527">    u_int16_t cfg_ctl,</a>
<a name="ln2528">    u_int16_t antenna_reduction,</a>
<a name="ln2529">    u_int16_t twice_max_regulatory_power,</a>
<a name="ln2530">    u_int16_t power_limit,</a>
<a name="ln2531">    u_int8_t chainmask)</a>
<a name="ln2532">{</a>
<a name="ln2533">    /* Local defines to distinguish between extension and control CTL's */</a>
<a name="ln2534">#define EXT_ADDITIVE (0x8000)</a>
<a name="ln2535">#define CTL_11A_EXT (CTL_11A | EXT_ADDITIVE)</a>
<a name="ln2536">#define CTL_11G_EXT (CTL_11G | EXT_ADDITIVE)</a>
<a name="ln2537">#define CTL_11B_EXT (CTL_11B | EXT_ADDITIVE)</a>
<a name="ln2538">#define REDUCE_SCALED_POWER_BY_TWO_CHAIN     6  /* 10*log10(2)*2 */</a>
<a name="ln2539">#define REDUCE_SCALED_POWER_BY_THREE_CHAIN  10  /* 10*log10(3)*2 */</a>
<a name="ln2540">#define PWRINCR_3_TO_1_CHAIN      9             /* 10*log(3)*2 */</a>
<a name="ln2541">#define PWRINCR_3_TO_2_CHAIN      3             /* floor(10*log(3/2)*2) */</a>
<a name="ln2542">#define PWRINCR_2_TO_1_CHAIN      6             /* 10*log(2)*2 */</a>
<a name="ln2543"> </a>
<a name="ln2544">    static const u_int16_t tp_scale_reduction_table[5] =</a>
<a name="ln2545">        { 0, 3, 6, 9, AR9300_MAX_RATE_POWER };</a>
<a name="ln2546">    int i;</a>
<a name="ln2547">    int16_t twice_largest_antenna;</a>
<a name="ln2548">    u_int16_t twice_antenna_reduction = 2*antenna_reduction ;</a>
<a name="ln2549">    int16_t scaled_power = 0, min_ctl_power, max_reg_allowed_power;</a>
<a name="ln2550">#define SUB_NUM_CTL_MODES_AT_5G_40 2    /* excluding HT40, EXT-OFDM */</a>
<a name="ln2551">#define SUB_NUM_CTL_MODES_AT_2G_40 3    /* excluding HT40, EXT-OFDM, EXT-CCK */</a>
<a name="ln2552">    u_int16_t ctl_modes_for11a[] =</a>
<a name="ln2553">        {CTL_11A, CTL_5GHT20, CTL_11A_EXT, CTL_5GHT40};</a>
<a name="ln2554">    u_int16_t ctl_modes_for11g[] =</a>
<a name="ln2555">        {CTL_11B, CTL_11G, CTL_2GHT20, CTL_11B_EXT, CTL_11G_EXT, CTL_2GHT40};</a>
<a name="ln2556">    u_int16_t num_ctl_modes, *p_ctl_mode, ctl_mode, freq;</a>
<a name="ln2557">    CHAN_CENTERS centers;</a>
<a name="ln2558">    int tx_chainmask;</a>
<a name="ln2559">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2560">    u_int8_t *ctl_index;</a>
<a name="ln2561">    u_int8_t ctl_num;</a>
<a name="ln2562">    u_int16_t twice_min_edge_power;</a>
<a name="ln2563">    u_int16_t twice_max_edge_power = AR9300_MAX_RATE_POWER;</a>
<a name="ln2564">#ifdef	AH_DEBUG</a>
<a name="ln2565">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln2566">#endif</a>
<a name="ln2567"> </a>
<a name="ln2568">    if (chainmask)</a>
<a name="ln2569">        tx_chainmask = chainmask;</a>
<a name="ln2570">    else</a>
<a name="ln2571">        tx_chainmask = ahp-&gt;ah_tx_chainmaskopt ?</a>
<a name="ln2572">                            ahp-&gt;ah_tx_chainmaskopt :ahp-&gt;ah_tx_chainmask;</a>
<a name="ln2573"> </a>
<a name="ln2574">    ar9300_get_channel_centers(ah, chan, &amp;centers);</a>
<a name="ln2575"> </a>
<a name="ln2576">#if 1</a>
<a name="ln2577">    if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln2578">        ahp-&gt;twice_antenna_gain = p_eep_data-&gt;modal_header_2g.antenna_gain;</a>
<a name="ln2579">    } else {</a>
<a name="ln2580">        ahp-&gt;twice_antenna_gain = p_eep_data-&gt;modal_header_5g.antenna_gain;</a>
<a name="ln2581">    }</a>
<a name="ln2582"> </a>
<a name="ln2583">#else</a>
<a name="ln2584">    if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln2585">        ahp-&gt;twice_antenna_gain = AH_MAX(p_eep_data-&gt;modal_header_2g.antenna_gain,</a>
<a name="ln2586">                                         AH_PRIVATE(ah)-&gt;ah_antenna_gain_2g);</a>
<a name="ln2587">    } else {</a>
<a name="ln2588">        ahp-&gt;twice_antenna_gain = AH_MAX(p_eep_data-&gt;modal_header_5g.antenna_gain,</a>
<a name="ln2589">                                         AH_PRIVATE(ah)-&gt;ah_antenna_gain_5g);</a>
<a name="ln2590">    }</a>
<a name="ln2591">#endif</a>
<a name="ln2592"> </a>
<a name="ln2593">    /* Save max allowed antenna gain to ease future lookups */</a>
<a name="ln2594">    ahp-&gt;twice_antenna_reduction = twice_antenna_reduction; </a>
<a name="ln2595"> </a>
<a name="ln2596">    /*  Deduct antenna gain from  EIRP to get the upper limit */</a>
<a name="ln2597">    twice_largest_antenna = (int16_t)AH_MIN((twice_antenna_reduction -</a>
<a name="ln2598">                                       ahp-&gt;twice_antenna_gain), 0);</a>
<a name="ln2599">    max_reg_allowed_power = twice_max_regulatory_power + twice_largest_antenna;</a>
<a name="ln2600"> </a>
<a name="ln2601">    /* Use ah_tp_scale - see bug 30070. */</a>
<a name="ln2602">    if (AH_PRIVATE(ah)-&gt;ah_tpScale != HAL_TP_SCALE_MAX) { </a>
<a name="ln2603">        max_reg_allowed_power -=</a>
<a name="ln2604">            (tp_scale_reduction_table[(AH_PRIVATE(ah)-&gt;ah_tpScale)] * 2);</a>
<a name="ln2605">    }</a>
<a name="ln2606"> </a>
<a name="ln2607">    scaled_power = AH_MIN(power_limit, max_reg_allowed_power);</a>
<a name="ln2608"> </a>
<a name="ln2609">    /*</a>
<a name="ln2610">     * Reduce scaled Power by number of chains active to get to</a>
<a name="ln2611">     * per chain tx power level</a>
<a name="ln2612">     */</a>
<a name="ln2613">    /* TODO: better value than these? */</a>
<a name="ln2614">    switch (ar9300_get_ntxchains(tx_chainmask)) {</a>
<a name="ln2615">    case 1:</a>
<a name="ln2616">        ahp-&gt;upper_limit[0] = AH_MAX(0, scaled_power);</a>
<a name="ln2617">        break;</a>
<a name="ln2618">    case 2:</a>
<a name="ln2619">        scaled_power -= REDUCE_SCALED_POWER_BY_TWO_CHAIN;</a>
<a name="ln2620">        ahp-&gt;upper_limit[1] = AH_MAX(0, scaled_power);</a>
<a name="ln2621">        break;</a>
<a name="ln2622">    case 3:</a>
<a name="ln2623">        scaled_power -= REDUCE_SCALED_POWER_BY_THREE_CHAIN;</a>
<a name="ln2624">        ahp-&gt;upper_limit[2] = AH_MAX(0, scaled_power);</a>
<a name="ln2625">        break;</a>
<a name="ln2626">    default:</a>
<a name="ln2627">        HALASSERT(0); /* Unsupported number of chains */</a>
<a name="ln2628">    }</a>
<a name="ln2629"> </a>
<a name="ln2630">    scaled_power = AH_MAX(0, scaled_power);</a>
<a name="ln2631"> </a>
<a name="ln2632">    /* Get target powers from EEPROM - our baseline for TX Power */</a>
<a name="ln2633">    if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln2634">        /* Setup for CTL modes */</a>
<a name="ln2635">        /* CTL_11B, CTL_11G, CTL_2GHT20 */</a>
<a name="ln2636">        num_ctl_modes =</a>
<a name="ln2637">            ARRAY_LENGTH(ctl_modes_for11g) - SUB_NUM_CTL_MODES_AT_2G_40;</a>
<a name="ln2638">        p_ctl_mode = ctl_modes_for11g;</a>
<a name="ln2639"> </a>
<a name="ln2640">        if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln2641">            num_ctl_modes = ARRAY_LENGTH(ctl_modes_for11g); /* All 2G CTL's */</a>
<a name="ln2642">        }</a>
<a name="ln2643">    } else {</a>
<a name="ln2644">        /* Setup for CTL modes */</a>
<a name="ln2645">        /* CTL_11A, CTL_5GHT20 */</a>
<a name="ln2646">        num_ctl_modes =</a>
<a name="ln2647">            ARRAY_LENGTH(ctl_modes_for11a) - SUB_NUM_CTL_MODES_AT_5G_40;</a>
<a name="ln2648">        p_ctl_mode = ctl_modes_for11a;</a>
<a name="ln2649"> </a>
<a name="ln2650">        if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln2651">            num_ctl_modes = ARRAY_LENGTH(ctl_modes_for11a); /* All 5G CTL's */</a>
<a name="ln2652">        }</a>
<a name="ln2653">    }</a>
<a name="ln2654"> </a>
<a name="ln2655">    /*</a>
<a name="ln2656">     * For MIMO, need to apply regulatory caps individually across dynamically</a>
<a name="ln2657">     * running modes: CCK, OFDM, HT20, HT40</a>
<a name="ln2658">     *</a>
<a name="ln2659">     * The outer loop walks through each possible applicable runtime mode.</a>
<a name="ln2660">     * The inner loop walks through each ctl_index entry in EEPROM.</a>
<a name="ln2661">     * The ctl value is encoded as [7:4] == test group, [3:0] == test mode.</a>
<a name="ln2662">     *</a>
<a name="ln2663">     */</a>
<a name="ln2664">    for (ctl_mode = 0; ctl_mode &lt; num_ctl_modes; ctl_mode++) {</a>
<a name="ln2665">        HAL_BOOL is_ht40_ctl_mode =</a>
<a name="ln2666">            (p_ctl_mode[ctl_mode] == CTL_5GHT40) ||</a>
<a name="ln2667">            (p_ctl_mode[ctl_mode] == CTL_2GHT40);</a>
<a name="ln2668">        if (is_ht40_ctl_mode) {</a>
<a name="ln2669">            freq = centers.synth_center;</a>
<a name="ln2670">        } else if (p_ctl_mode[ctl_mode] &amp; EXT_ADDITIVE) {</a>
<a name="ln2671">            freq = centers.ext_center;</a>
<a name="ln2672">        } else {</a>
<a name="ln2673">            freq = centers.ctl_center;</a>
<a name="ln2674">        }</a>
<a name="ln2675"> </a>
<a name="ln2676">        HALDEBUG(ah, HAL_DEBUG_POWER_MGMT,</a>
<a name="ln2677">            &quot;LOOP-Mode ctl_mode %d &lt; %d, &quot;</a>
<a name="ln2678">            &quot;is_ht40_ctl_mode %d, EXT_ADDITIVE %d\n&quot;,</a>
<a name="ln2679">            ctl_mode, num_ctl_modes, is_ht40_ctl_mode,</a>
<a name="ln2680">            (p_ctl_mode[ctl_mode] &amp; EXT_ADDITIVE));</a>
<a name="ln2681">        /* walk through each CTL index stored in EEPROM */</a>
<a name="ln2682">        if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln2683">            ctl_index = p_eep_data-&gt;ctl_index_2g;</a>
<a name="ln2684">            ctl_num = OSPREY_NUM_CTLS_2G;</a>
<a name="ln2685">        } else {</a>
<a name="ln2686">            ctl_index = p_eep_data-&gt;ctl_index_5g;</a>
<a name="ln2687">            ctl_num = OSPREY_NUM_CTLS_5G;</a>
<a name="ln2688">        }</a>
<a name="ln2689"> </a>
<a name="ln2690">        for (i = 0; (i &lt; ctl_num) &amp;&amp; ctl_index[i]; i++) {</a>
<a name="ln2691">            HALDEBUG(ah, HAL_DEBUG_POWER_MGMT, </a>
<a name="ln2692">                &quot;  LOOP-Ctlidx %d: cfg_ctl 0x%2.2x p_ctl_mode 0x%2.2x &quot;</a>
<a name="ln2693">                &quot;ctl_index 0x%2.2x chan %d chanctl 0x%x\n&quot;,</a>
<a name="ln2694">                i, cfg_ctl, p_ctl_mode[ctl_mode], ctl_index[i], </a>
<a name="ln2695">                ichan-&gt;channel, ath_hal_getctl(ah, chan));</a>
<a name="ln2696"> </a>
<a name="ln2697"> </a>
<a name="ln2698">            /* </a>
<a name="ln2699">             * compare test group from regulatory channel list</a>
<a name="ln2700">             * with test mode from p_ctl_mode list</a>
<a name="ln2701">             */</a>
<a name="ln2702">            if ((((cfg_ctl &amp; ~CTL_MODE_M) |</a>
<a name="ln2703">                  (p_ctl_mode[ctl_mode] &amp; CTL_MODE_M)) == ctl_index[i]) ||</a>
<a name="ln2704">                (((cfg_ctl &amp; ~CTL_MODE_M) |</a>
<a name="ln2705">                  (p_ctl_mode[ctl_mode] &amp; CTL_MODE_M)) ==</a>
<a name="ln2706">                 ((ctl_index[i] &amp; CTL_MODE_M) | SD_NO_CTL)))</a>
<a name="ln2707">            {</a>
<a name="ln2708">                twice_min_edge_power =</a>
<a name="ln2709">                    ar9300_eep_def_get_max_edge_power(</a>
<a name="ln2710">                        p_eep_data, freq, i, IEEE80211_IS_CHAN_2GHZ(chan));</a>
<a name="ln2711"> </a>
<a name="ln2712">                HALDEBUG(ah, HAL_DEBUG_POWER_MGMT,</a>
<a name="ln2713">                    &quot;    MATCH-EE_IDX %d: ch %d is2 %d &quot;</a>
<a name="ln2714">                    &quot;2xMinEdge %d chainmask %d chains %d\n&quot;,</a>
<a name="ln2715">                    i, freq, IEEE80211_IS_CHAN_2GHZ(chan),</a>
<a name="ln2716">                    twice_min_edge_power, tx_chainmask,</a>
<a name="ln2717">                    ar9300_get_ntxchains(tx_chainmask));</a>
<a name="ln2718"> </a>
<a name="ln2719">                if ((cfg_ctl &amp; ~CTL_MODE_M) == SD_NO_CTL) {</a>
<a name="ln2720">                    /*</a>
<a name="ln2721">                     * Find the minimum of all CTL edge powers</a>
<a name="ln2722">                     * that apply to this channel</a>
<a name="ln2723">                     */</a>
<a name="ln2724">                    twice_max_edge_power =</a>
<a name="ln2725">                        AH_MIN(twice_max_edge_power, twice_min_edge_power);</a>
<a name="ln2726">                } else {</a>
<a name="ln2727">                    /* specific */</a>
<a name="ln2728">                    twice_max_edge_power = twice_min_edge_power;</a>
<a name="ln2729">                    break;</a>
<a name="ln2730">                }</a>
<a name="ln2731">            }</a>
<a name="ln2732">        }</a>
<a name="ln2733"> </a>
<a name="ln2734">        min_ctl_power = (u_int8_t)AH_MIN(twice_max_edge_power, scaled_power);</a>
<a name="ln2735"> </a>
<a name="ln2736">        HALDEBUG(ah, HAL_DEBUG_POWER_MGMT,</a>
<a name="ln2737">            &quot;    SEL-Min ctl_mode %d p_ctl_mode %d &quot;</a>
<a name="ln2738">            &quot;2xMaxEdge %d sP %d min_ctl_pwr %d\n&quot;,</a>
<a name="ln2739">            ctl_mode, p_ctl_mode[ctl_mode],</a>
<a name="ln2740">            twice_max_edge_power, scaled_power, min_ctl_power);</a>
<a name="ln2741"> </a>
<a name="ln2742">        /* Apply ctl mode to correct target power set */</a>
<a name="ln2743">        switch (p_ctl_mode[ctl_mode]) {</a>
<a name="ln2744">        case CTL_11B:</a>
<a name="ln2745">            for (i = ALL_TARGET_LEGACY_1L_5L; i &lt;= ALL_TARGET_LEGACY_11S; i++) {</a>
<a name="ln2746">                p_pwr_array[i] =</a>
<a name="ln2747">                    (u_int8_t)AH_MIN(p_pwr_array[i], min_ctl_power);</a>
<a name="ln2748">            }</a>
<a name="ln2749">            break;</a>
<a name="ln2750">        case CTL_11A:</a>
<a name="ln2751">        case CTL_11G:</a>
<a name="ln2752">            for (i = ALL_TARGET_LEGACY_6_24; i &lt;= ALL_TARGET_LEGACY_54; i++) {</a>
<a name="ln2753">                p_pwr_array[i] =</a>
<a name="ln2754">                    (u_int8_t)AH_MIN(p_pwr_array[i], min_ctl_power);</a>
<a name="ln2755">#ifdef ATH_BT_COEX</a>
<a name="ln2756">                if ((ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_3WIRE) ||</a>
<a name="ln2757">                    (ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_MCI))</a>
<a name="ln2758">                {</a>
<a name="ln2759">                    if ((ahp-&gt;ah_bt_coex_flag &amp; HAL_BT_COEX_FLAG_LOWER_TX_PWR)</a>
<a name="ln2760">                        &amp;&amp; (ahp-&gt;ah_bt_wlan_isolation </a>
<a name="ln2761">                         &lt; HAL_BT_COEX_ISOLATION_FOR_NO_COEX))</a>
<a name="ln2762">                    {</a>
<a name="ln2763"> </a>
<a name="ln2764">                        u_int8_t reduce_pow;</a>
<a name="ln2765">                        </a>
<a name="ln2766">                        reduce_pow = (HAL_BT_COEX_ISOLATION_FOR_NO_COEX </a>
<a name="ln2767">                                     - ahp-&gt;ah_bt_wlan_isolation) &lt;&lt; 1;</a>
<a name="ln2768"> </a>
<a name="ln2769">                        if (reduce_pow &lt;= p_pwr_array[i]) {</a>
<a name="ln2770">                            p_pwr_array[i] -= reduce_pow;</a>
<a name="ln2771">                        }</a>
<a name="ln2772">                    }</a>
<a name="ln2773">                    if ((ahp-&gt;ah_bt_coex_flag &amp; </a>
<a name="ln2774">                          HAL_BT_COEX_FLAG_LOW_ACK_PWR) &amp;&amp;</a>
<a name="ln2775">                          (i != ALL_TARGET_LEGACY_36) &amp;&amp;</a>
<a name="ln2776">                          (i != ALL_TARGET_LEGACY_48) &amp;&amp;</a>
<a name="ln2777">                          (i != ALL_TARGET_LEGACY_54) &amp;&amp;</a>
<a name="ln2778">                          (p_ctl_mode[ctl_mode] == CTL_11G))</a>
<a name="ln2779">                    {</a>
<a name="ln2780">                        p_pwr_array[i] = 0;</a>
<a name="ln2781">                    }</a>
<a name="ln2782">                }</a>
<a name="ln2783">#endif</a>
<a name="ln2784">            }</a>
<a name="ln2785">            break;</a>
<a name="ln2786">        case CTL_5GHT20:</a>
<a name="ln2787">        case CTL_2GHT20:</a>
<a name="ln2788">            for (i = ALL_TARGET_HT20_0_8_16; i &lt;= ALL_TARGET_HT20_23; i++) {</a>
<a name="ln2789">                p_pwr_array[i] =</a>
<a name="ln2790">                    (u_int8_t)AH_MIN(p_pwr_array[i], min_ctl_power);</a>
<a name="ln2791">#ifdef ATH_BT_COEX</a>
<a name="ln2792">                if (((ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_3WIRE) ||</a>
<a name="ln2793">                     (ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_MCI)) &amp;&amp;</a>
<a name="ln2794">                    (ahp-&gt;ah_bt_coex_flag &amp; HAL_BT_COEX_FLAG_LOWER_TX_PWR) &amp;&amp; </a>
<a name="ln2795">                    (ahp-&gt;ah_bt_wlan_isolation </a>
<a name="ln2796">                        &lt; HAL_BT_COEX_ISOLATION_FOR_NO_COEX)) {</a>
<a name="ln2797"> </a>
<a name="ln2798">                    u_int8_t reduce_pow = (HAL_BT_COEX_ISOLATION_FOR_NO_COEX </a>
<a name="ln2799">                                           - ahp-&gt;ah_bt_wlan_isolation) &lt;&lt; 1;</a>
<a name="ln2800"> </a>
<a name="ln2801">                    if (reduce_pow &lt;= p_pwr_array[i]) {</a>
<a name="ln2802">                        p_pwr_array[i] -= reduce_pow;</a>
<a name="ln2803">                    }</a>
<a name="ln2804">                }</a>
<a name="ln2805">#if ATH_SUPPORT_MCI</a>
<a name="ln2806">                else if ((ahp-&gt;ah_bt_coex_flag &amp; </a>
<a name="ln2807">                          HAL_BT_COEX_FLAG_MCI_MAX_TX_PWR) &amp;&amp;</a>
<a name="ln2808">                         (p_ctl_mode[ctl_mode] == CTL_2GHT20) &amp;&amp;</a>
<a name="ln2809">                         (ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_MCI))</a>
<a name="ln2810">                {</a>
<a name="ln2811">                    u_int8_t max_pwr;</a>
<a name="ln2812"> </a>
<a name="ln2813">                    max_pwr = MS(mci_concur_tx_max_pwr[2][1],</a>
<a name="ln2814">                                 ATH_MCI_CONCUR_TX_LOWEST_PWR_MASK);</a>
<a name="ln2815">                    if (p_pwr_array[i] &gt; max_pwr) {</a>
<a name="ln2816">                        p_pwr_array[i] = max_pwr;</a>
<a name="ln2817">                    }</a>
<a name="ln2818">                }</a>
<a name="ln2819">#endif</a>
<a name="ln2820">#endif</a>
<a name="ln2821">            }</a>
<a name="ln2822">            break;</a>
<a name="ln2823">        case CTL_11B_EXT:</a>
<a name="ln2824">#ifdef NOT_YET</a>
<a name="ln2825">            target_power_cck_ext.t_pow2x[0] = (u_int8_t)</a>
<a name="ln2826">                AH_MIN(target_power_cck_ext.t_pow2x[0], min_ctl_power);</a>
<a name="ln2827">#endif /* NOT_YET */</a>
<a name="ln2828">            break;</a>
<a name="ln2829">        case CTL_11A_EXT:</a>
<a name="ln2830">        case CTL_11G_EXT:</a>
<a name="ln2831">#ifdef NOT_YET</a>
<a name="ln2832">            target_power_ofdm_ext.t_pow2x[0] = (u_int8_t)</a>
<a name="ln2833">                AH_MIN(target_power_ofdm_ext.t_pow2x[0], min_ctl_power);</a>
<a name="ln2834">#endif /* NOT_YET */</a>
<a name="ln2835">            break;</a>
<a name="ln2836">        case CTL_5GHT40:</a>
<a name="ln2837">        case CTL_2GHT40:</a>
<a name="ln2838">            for (i = ALL_TARGET_HT40_0_8_16; i &lt;= ALL_TARGET_HT40_23; i++) {</a>
<a name="ln2839">                p_pwr_array[i] = (u_int8_t)</a>
<a name="ln2840">                    AH_MIN(p_pwr_array[i], min_ctl_power);</a>
<a name="ln2841">#ifdef ATH_BT_COEX</a>
<a name="ln2842">                if (((ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_3WIRE) ||</a>
<a name="ln2843">                     (ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_MCI)) &amp;&amp;</a>
<a name="ln2844">                    (ahp-&gt;ah_bt_coex_flag &amp; HAL_BT_COEX_FLAG_LOWER_TX_PWR) &amp;&amp; </a>
<a name="ln2845">                    (ahp-&gt;ah_bt_wlan_isolation </a>
<a name="ln2846">                        &lt; HAL_BT_COEX_ISOLATION_FOR_NO_COEX)) {</a>
<a name="ln2847"> </a>
<a name="ln2848">                    u_int8_t reduce_pow = (HAL_BT_COEX_ISOLATION_FOR_NO_COEX </a>
<a name="ln2849">                                              - ahp-&gt;ah_bt_wlan_isolation) &lt;&lt; 1;</a>
<a name="ln2850"> </a>
<a name="ln2851">                    if (reduce_pow &lt;= p_pwr_array[i]) {</a>
<a name="ln2852">                        p_pwr_array[i] -= reduce_pow;</a>
<a name="ln2853">                    }</a>
<a name="ln2854">                }</a>
<a name="ln2855">#if ATH_SUPPORT_MCI</a>
<a name="ln2856">                else if ((ahp-&gt;ah_bt_coex_flag &amp; </a>
<a name="ln2857">                          HAL_BT_COEX_FLAG_MCI_MAX_TX_PWR) &amp;&amp;</a>
<a name="ln2858">                         (p_ctl_mode[ctl_mode] == CTL_2GHT40) &amp;&amp;</a>
<a name="ln2859">                         (ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_MCI))</a>
<a name="ln2860">                {</a>
<a name="ln2861">                    u_int8_t max_pwr;</a>
<a name="ln2862"> </a>
<a name="ln2863">                    max_pwr = MS(mci_concur_tx_max_pwr[3][1],</a>
<a name="ln2864">                                 ATH_MCI_CONCUR_TX_LOWEST_PWR_MASK);</a>
<a name="ln2865">                    if (p_pwr_array[i] &gt; max_pwr) {</a>
<a name="ln2866">                        p_pwr_array[i] = max_pwr;</a>
<a name="ln2867">                    }</a>
<a name="ln2868">                }</a>
<a name="ln2869">#endif</a>
<a name="ln2870">#endif</a>
<a name="ln2871">            }</a>
<a name="ln2872">            break;</a>
<a name="ln2873">        default:</a>
<a name="ln2874">            HALASSERT(0);</a>
<a name="ln2875">            break;</a>
<a name="ln2876">        }</a>
<a name="ln2877">    } /* end ctl mode checking */</a>
<a name="ln2878"> </a>
<a name="ln2879">    return AH_TRUE;</a>
<a name="ln2880">#undef EXT_ADDITIVE</a>
<a name="ln2881">#undef CTL_11A_EXT</a>
<a name="ln2882">#undef CTL_11G_EXT</a>
<a name="ln2883">#undef CTL_11B_EXT</a>
<a name="ln2884">#undef REDUCE_SCALED_POWER_BY_TWO_CHAIN</a>
<a name="ln2885">#undef REDUCE_SCALED_POWER_BY_THREE_CHAIN</a>
<a name="ln2886">}</a>
<a name="ln2887"> </a>
<a name="ln2888">/**************************************************************</a>
<a name="ln2889"> * ar9300_eeprom_set_transmit_power</a>
<a name="ln2890"> *</a>
<a name="ln2891"> * Set the transmit power in the baseband for the given</a>
<a name="ln2892"> * operating channel and mode.</a>
<a name="ln2893"> */</a>
<a name="ln2894">HAL_STATUS</a>
<a name="ln2895">ar9300_eeprom_set_transmit_power(struct ath_hal *ah,</a>
<a name="ln2896">    ar9300_eeprom_t *p_eep_data, const struct ieee80211_channel *chan, u_int16_t cfg_ctl,</a>
<a name="ln2897">    u_int16_t antenna_reduction, u_int16_t twice_max_regulatory_power,</a>
<a name="ln2898">    u_int16_t power_limit)</a>
<a name="ln2899">{</a>
<a name="ln2900">#define ABS(_x, _y) ((int)_x &gt; (int)_y ? (int)_x - (int)_y : (int)_y - (int)_x)</a>
<a name="ln2901">#define INCREASE_MAXPOW_BY_TWO_CHAIN     6  /* 10*log10(2)*2 */</a>
<a name="ln2902">#define INCREASE_MAXPOW_BY_THREE_CHAIN   10 /* 10*log10(3)*2 */</a>
<a name="ln2903">    u_int8_t target_power_val_t2[ar9300_rate_size];</a>
<a name="ln2904">    u_int8_t target_power_val_t2_eep[ar9300_rate_size];</a>
<a name="ln2905">    int16_t twice_array_gain = 0, max_power_level = 0;</a>
<a name="ln2906">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2907">    int  i = 0;</a>
<a name="ln2908">    u_int32_t tmp_paprd_rate_mask = 0, *tmp_ptr = NULL;</a>
<a name="ln2909">    int      paprd_scale_factor = 5;</a>
<a name="ln2910">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln2911"> </a>
<a name="ln2912">    u_int8_t *ptr_mcs_rate2power_table_index;</a>
<a name="ln2913">    u_int8_t mcs_rate2power_table_index_ht20[24] =</a>
<a name="ln2914">    {</a>
<a name="ln2915">        ALL_TARGET_HT20_0_8_16,</a>
<a name="ln2916">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2917">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2918">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2919">        ALL_TARGET_HT20_4,</a>
<a name="ln2920">        ALL_TARGET_HT20_5,</a>
<a name="ln2921">        ALL_TARGET_HT20_6,</a>
<a name="ln2922">        ALL_TARGET_HT20_7,</a>
<a name="ln2923">        ALL_TARGET_HT20_0_8_16,</a>
<a name="ln2924">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2925">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2926">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2927">        ALL_TARGET_HT20_12,</a>
<a name="ln2928">        ALL_TARGET_HT20_13,</a>
<a name="ln2929">        ALL_TARGET_HT20_14,</a>
<a name="ln2930">        ALL_TARGET_HT20_15,</a>
<a name="ln2931">        ALL_TARGET_HT20_0_8_16,</a>
<a name="ln2932">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2933">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2934">        ALL_TARGET_HT20_1_3_9_11_17_19,</a>
<a name="ln2935">        ALL_TARGET_HT20_20,</a>
<a name="ln2936">        ALL_TARGET_HT20_21,</a>
<a name="ln2937">        ALL_TARGET_HT20_22,</a>
<a name="ln2938">        ALL_TARGET_HT20_23</a>
<a name="ln2939">    };</a>
<a name="ln2940"> </a>
<a name="ln2941">    u_int8_t mcs_rate2power_table_index_ht40[24] =</a>
<a name="ln2942">    {</a>
<a name="ln2943">        ALL_TARGET_HT40_0_8_16,</a>
<a name="ln2944">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2945">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2946">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2947">        ALL_TARGET_HT40_4,</a>
<a name="ln2948">        ALL_TARGET_HT40_5,</a>
<a name="ln2949">        ALL_TARGET_HT40_6,</a>
<a name="ln2950">        ALL_TARGET_HT40_7,</a>
<a name="ln2951">        ALL_TARGET_HT40_0_8_16,</a>
<a name="ln2952">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2953">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2954">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2955">        ALL_TARGET_HT40_12,</a>
<a name="ln2956">        ALL_TARGET_HT40_13,</a>
<a name="ln2957">        ALL_TARGET_HT40_14,</a>
<a name="ln2958">        ALL_TARGET_HT40_15,</a>
<a name="ln2959">        ALL_TARGET_HT40_0_8_16,</a>
<a name="ln2960">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2961">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2962">        ALL_TARGET_HT40_1_3_9_11_17_19,</a>
<a name="ln2963">        ALL_TARGET_HT40_20,</a>
<a name="ln2964">        ALL_TARGET_HT40_21,</a>
<a name="ln2965">        ALL_TARGET_HT40_22,</a>
<a name="ln2966">        ALL_TARGET_HT40_23,</a>
<a name="ln2967">    };</a>
<a name="ln2968"> </a>
<a name="ln2969">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2970">        &quot;%s[%d] +++chan %d,cfgctl 0x%04x  &quot;</a>
<a name="ln2971">        &quot;antenna_reduction 0x%04x, twice_max_regulatory_power 0x%04x &quot;</a>
<a name="ln2972">        &quot;power_limit 0x%04x\n&quot;,</a>
<a name="ln2973">        __func__, __LINE__, ichan-&gt;channel, cfg_ctl,</a>
<a name="ln2974">        antenna_reduction, twice_max_regulatory_power, power_limit);</a>
<a name="ln2975">    ar9300_set_target_power_from_eeprom(ah, ichan-&gt;channel, target_power_val_t2);</a>
<a name="ln2976"> </a>
<a name="ln2977">    if (ar9300_eeprom_get(ahp, EEP_PAPRD_ENABLED)) {</a>
<a name="ln2978">        if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln2979">            if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln2980">                tmp_paprd_rate_mask =</a>
<a name="ln2981">                    p_eep_data-&gt;modal_header_2g.paprd_rate_mask_ht40;</a>
<a name="ln2982">                tmp_ptr = &amp;AH9300(ah)-&gt;ah_2g_paprd_rate_mask_ht40;</a>
<a name="ln2983">            } else {</a>
<a name="ln2984">                tmp_paprd_rate_mask =</a>
<a name="ln2985">                    p_eep_data-&gt;modal_header_2g.paprd_rate_mask_ht20;</a>
<a name="ln2986">                tmp_ptr = &amp;AH9300(ah)-&gt;ah_2g_paprd_rate_mask_ht20;</a>
<a name="ln2987">            }</a>
<a name="ln2988">        } else {</a>
<a name="ln2989">            if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln2990">                tmp_paprd_rate_mask =</a>
<a name="ln2991">                    p_eep_data-&gt;modal_header_5g.paprd_rate_mask_ht40;</a>
<a name="ln2992">                tmp_ptr = &amp;AH9300(ah)-&gt;ah_5g_paprd_rate_mask_ht40;</a>
<a name="ln2993">            } else {</a>
<a name="ln2994">                tmp_paprd_rate_mask =</a>
<a name="ln2995">                    p_eep_data-&gt;modal_header_5g.paprd_rate_mask_ht20;</a>
<a name="ln2996">                tmp_ptr = &amp;AH9300(ah)-&gt;ah_5g_paprd_rate_mask_ht20;</a>
<a name="ln2997">            }</a>
<a name="ln2998">        }</a>
<a name="ln2999">        AH_PAPRD_GET_SCALE_FACTOR(</a>
<a name="ln3000">            paprd_scale_factor, p_eep_data, IEEE80211_IS_CHAN_2GHZ(chan), ichan-&gt;channel);</a>
<a name="ln3001">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE, &quot;%s[%d] paprd_scale_factor %d\n&quot;,</a>
<a name="ln3002">            __func__, __LINE__, paprd_scale_factor);</a>
<a name="ln3003">        /* PAPRD is not done yet, Scale down the EEP power */</a>
<a name="ln3004">        if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln3005">            ptr_mcs_rate2power_table_index =</a>
<a name="ln3006">                &amp;mcs_rate2power_table_index_ht40[0];</a>
<a name="ln3007">        } else {</a>
<a name="ln3008">            ptr_mcs_rate2power_table_index =</a>
<a name="ln3009">                &amp;mcs_rate2power_table_index_ht20[0];</a>
<a name="ln3010">        }</a>
<a name="ln3011">        if (! ichan-&gt;paprd_table_write_done) {</a>
<a name="ln3012">            for (i = 0;  i &lt; 24; i++) {</a>
<a name="ln3013">                /* PAPRD is done yet, so Scale down Power for PAPRD Rates*/</a>
<a name="ln3014">                if (tmp_paprd_rate_mask &amp; (1 &lt;&lt; i)) {</a>
<a name="ln3015">                    target_power_val_t2[ptr_mcs_rate2power_table_index[i]] -=</a>
<a name="ln3016">                        paprd_scale_factor;</a>
<a name="ln3017">                    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3018">                        &quot;%s[%d]: Chan %d &quot;</a>
<a name="ln3019">                        &quot;Scale down target_power_val_t2[%d] = 0x%04x\n&quot;,</a>
<a name="ln3020">                        __func__, __LINE__,</a>
<a name="ln3021">                        ichan-&gt;channel, i, target_power_val_t2[i]);</a>
<a name="ln3022">                }</a>
<a name="ln3023">            }</a>
<a name="ln3024">        } else {</a>
<a name="ln3025">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3026">                &quot;%s[%d]: PAPRD Done No TGT PWR Scaling\n&quot;, __func__, __LINE__);</a>
<a name="ln3027">        }</a>
<a name="ln3028">    }</a>
<a name="ln3029"> </a>
<a name="ln3030">    /* Save the Target power for future use */</a>
<a name="ln3031">    OS_MEMCPY(target_power_val_t2_eep, target_power_val_t2,</a>
<a name="ln3032">                                   sizeof(target_power_val_t2));</a>
<a name="ln3033">    ar9300_eeprom_set_power_per_rate_table(ah, p_eep_data, chan,</a>
<a name="ln3034">                                     target_power_val_t2, cfg_ctl,</a>
<a name="ln3035">                                     antenna_reduction,</a>
<a name="ln3036">                                     twice_max_regulatory_power,</a>
<a name="ln3037">                                     power_limit, 0);</a>
<a name="ln3038">    </a>
<a name="ln3039">    /* Save this for quick lookup */</a>
<a name="ln3040">    ahp-&gt;reg_dmn = ath_hal_getctl(ah, chan);</a>
<a name="ln3041"> </a>
<a name="ln3042">    /*</a>
<a name="ln3043">     * Always use CDD/direct per rate power table for register based approach.</a>
<a name="ln3044">     * For FCC, CDD calculations should factor in the array gain, hence </a>
<a name="ln3045">     * this adjust call. ETSI and MKK does not have this requirement.</a>
<a name="ln3046">     */</a>
<a name="ln3047">    if (is_reg_dmn_fcc(ahp-&gt;reg_dmn)) {</a>
<a name="ln3048">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3049">            &quot;%s: FCC regdomain, calling reg_txpower_cdd\n&quot;,</a>
<a name="ln3050">            __func__);</a>
<a name="ln3051">        ar9300_adjust_reg_txpower_cdd(ah, target_power_val_t2);</a>
<a name="ln3052">    }</a>
<a name="ln3053"> </a>
<a name="ln3054">    if (ar9300_eeprom_get(ahp, EEP_PAPRD_ENABLED)) {</a>
<a name="ln3055">        for (i = 0;  i &lt; ar9300_rate_size; i++) {</a>
<a name="ln3056">            /*</a>
<a name="ln3057">             * EEPROM TGT PWR is not same as current TGT PWR,</a>
<a name="ln3058">             * so Disable PAPRD for this rate.</a>
<a name="ln3059">             * Some of APs might ask to reduce Target Power,</a>
<a name="ln3060">             * if target power drops significantly,</a>
<a name="ln3061">             * disable PAPRD for that rate.</a>
<a name="ln3062">             */</a>
<a name="ln3063">            if (tmp_paprd_rate_mask &amp; (1 &lt;&lt; i)) {</a>
<a name="ln3064">                if (ABS(target_power_val_t2_eep[i], target_power_val_t2[i]) &gt;</a>
<a name="ln3065">                    paprd_scale_factor)</a>
<a name="ln3066">                {</a>
<a name="ln3067">                    tmp_paprd_rate_mask &amp;= ~(1 &lt;&lt; i);</a>
<a name="ln3068">                    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3069">                        &quot;%s: EEP TPC[%02d] 0x%08x &quot;</a>
<a name="ln3070">                        &quot;Curr TPC[%02d] 0x%08x mask = 0x%08x\n&quot;,</a>
<a name="ln3071">                        __func__, i, target_power_val_t2_eep[i], i,</a>
<a name="ln3072">                        target_power_val_t2[i], tmp_paprd_rate_mask);</a>
<a name="ln3073">                }</a>
<a name="ln3074">            }</a>
<a name="ln3075">            </a>
<a name="ln3076">        }</a>
<a name="ln3077">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3078">            &quot;%s: Chan %d After tmp_paprd_rate_mask = 0x%08x\n&quot;,</a>
<a name="ln3079">            __func__, ichan-&gt;channel, tmp_paprd_rate_mask);</a>
<a name="ln3080">        if (tmp_ptr) {</a>
<a name="ln3081">            *tmp_ptr = tmp_paprd_rate_mask;</a>
<a name="ln3082">        }</a>
<a name="ln3083">    }</a>
<a name="ln3084"> </a>
<a name="ln3085">    /* Write target power array to registers */</a>
<a name="ln3086">    ar9300_transmit_power_reg_write(ah, target_power_val_t2);</a>
<a name="ln3087">    </a>
<a name="ln3088">    /* Write target power for self generated frames to the TPC register */</a>
<a name="ln3089">    ar9300_selfgen_tpc_reg_write(ah, chan, target_power_val_t2);</a>
<a name="ln3090"> </a>
<a name="ln3091">    /* GreenTx or Paprd */</a>
<a name="ln3092">    if (ah-&gt;ah_config.ath_hal_sta_update_tx_pwr_enable || </a>
<a name="ln3093">        AH_PRIVATE(ah)-&gt;ah_caps.halPaprdEnabled) </a>
<a name="ln3094">    {</a>
<a name="ln3095">        if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln3096">            /*For HAL_RSSI_TX_POWER_NONE array*/</a>
<a name="ln3097">            OS_MEMCPY(ahp-&gt;ah_default_tx_power, </a>
<a name="ln3098">                target_power_val_t2, </a>
<a name="ln3099">                sizeof(target_power_val_t2));</a>
<a name="ln3100">            /* Get defautl tx related register setting for GreenTx */</a>
<a name="ln3101">            /* Record OB/DB */</a>
<a name="ln3102">            ahp-&gt;ah_ob_db1[POSEIDON_STORED_REG_OBDB] = </a>
<a name="ln3103">                OS_REG_READ(ah, AR_PHY_65NM_CH0_TXRF2);</a>
<a name="ln3104">            /* Record TPC settting */</a>
<a name="ln3105">            ahp-&gt;ah_ob_db1[POSEIDON_STORED_REG_TPC] =</a>
<a name="ln3106">                OS_REG_READ(ah, AR_TPC);</a>
<a name="ln3107">            /* Record BB_powertx_rate9 setting */ </a>
<a name="ln3108">            ahp-&gt;ah_ob_db1[POSEIDON_STORED_REG_BB_PWRTX_RATE9] = </a>
<a name="ln3109">                OS_REG_READ(ah, AR_PHY_BB_POWERTX_RATE9);</a>
<a name="ln3110">        }</a>
<a name="ln3111">    }</a>
<a name="ln3112"> </a>
<a name="ln3113">    /*</a>
<a name="ln3114">     * Return tx power used to iwconfig.</a>
<a name="ln3115">     * Since power is rate dependent, use one of the indices from the</a>
<a name="ln3116">     * AR9300_Rates enum to select an entry from target_power_val_t2[]</a>
<a name="ln3117">     * to report.</a>
<a name="ln3118">     * Currently returns the power for HT40 MCS 0, HT20 MCS 0, or OFDM 6 Mbps</a>
<a name="ln3119">     * as CCK power is less interesting (?).</a>
<a name="ln3120">     */</a>
<a name="ln3121">    i = ALL_TARGET_LEGACY_6_24;         /* legacy */</a>
<a name="ln3122">    if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln3123">        i = ALL_TARGET_HT40_0_8_16;     /* ht40 */</a>
<a name="ln3124">    } else if (IEEE80211_IS_CHAN_HT20(chan)) {</a>
<a name="ln3125">        i = ALL_TARGET_HT20_0_8_16;     /* ht20 */</a>
<a name="ln3126">    }</a>
<a name="ln3127">    max_power_level = target_power_val_t2[i];</a>
<a name="ln3128">    /* Adjusting the ah_max_power_level based on chains and antennaGain*/</a>
<a name="ln3129">    switch (ar9300_get_ntxchains(((ahp-&gt;ah_tx_chainmaskopt &gt; 0) ?</a>
<a name="ln3130">                                    ahp-&gt;ah_tx_chainmaskopt : ahp-&gt;ah_tx_chainmask)))</a>
<a name="ln3131">    {</a>
<a name="ln3132">        case 1:</a>
<a name="ln3133">            break;</a>
<a name="ln3134">        case 2:</a>
<a name="ln3135">            twice_array_gain = (ahp-&gt;twice_antenna_gain &gt;= ahp-&gt;twice_antenna_reduction)? 0: </a>
<a name="ln3136">                               ((int16_t)AH_MIN((ahp-&gt;twice_antenna_reduction -</a>
<a name="ln3137">                                   (ahp-&gt;twice_antenna_gain + INCREASE_MAXPOW_BY_TWO_CHAIN)), 0));</a>
<a name="ln3138">            /* Adjusting maxpower with antennaGain */</a>
<a name="ln3139">            max_power_level -= twice_array_gain;</a>
<a name="ln3140">            /* Adjusting maxpower based on chain */</a>
<a name="ln3141">            max_power_level += INCREASE_MAXPOW_BY_TWO_CHAIN;</a>
<a name="ln3142">            break;</a>
<a name="ln3143">        case 3:</a>
<a name="ln3144">            twice_array_gain = (ahp-&gt;twice_antenna_gain &gt;= ahp-&gt;twice_antenna_reduction)? 0:</a>
<a name="ln3145">                               ((int16_t)AH_MIN((ahp-&gt;twice_antenna_reduction -</a>
<a name="ln3146">                                   (ahp-&gt;twice_antenna_gain + INCREASE_MAXPOW_BY_THREE_CHAIN)), 0));</a>
<a name="ln3147"> </a>
<a name="ln3148">            /* Adjusting maxpower with antennaGain */</a>
<a name="ln3149">            max_power_level -= twice_array_gain;</a>
<a name="ln3150">            /* Adjusting maxpower based on chain */</a>
<a name="ln3151">            max_power_level += INCREASE_MAXPOW_BY_THREE_CHAIN;</a>
<a name="ln3152">            break;</a>
<a name="ln3153">        default:</a>
<a name="ln3154">            HALASSERT(0); /* Unsupported number of chains */</a>
<a name="ln3155">    }</a>
<a name="ln3156">    AH_PRIVATE(ah)-&gt;ah_maxPowerLevel = (int8_t)max_power_level;</a>
<a name="ln3157"> </a>
<a name="ln3158">    ar9300_calibration_apply(ah, ichan-&gt;channel);</a>
<a name="ln3159">#undef ABS</a>
<a name="ln3160"> </a>
<a name="ln3161">    /* Handle per packet TPC initializations */</a>
<a name="ln3162">    if (ah-&gt;ah_config.ath_hal_desc_tpc) {</a>
<a name="ln3163">        /* Transmit Power per-rate per-chain  are  computed here. A separate</a>
<a name="ln3164">         * power table is maintained for different MIMO modes (i.e. TXBF ON,</a>
<a name="ln3165">         * STBC) to enable easy lookup during packet transmit. </a>
<a name="ln3166">         * The reason for maintaing each of these tables per chain is that</a>
<a name="ln3167">         * the transmit power used for different number of chains is different</a>
<a name="ln3168">         * depending on whether the power has been limited by the target power,</a>
<a name="ln3169">         * the regulatory domain  or the CTL limits.</a>
<a name="ln3170">         */</a>
<a name="ln3171">        u_int mode = ath_hal_get_curmode(ah, chan);</a>
<a name="ln3172">        u_int32_t val = 0;</a>
<a name="ln3173">        u_int8_t chainmasks[AR9300_MAX_CHAINS] =</a>
<a name="ln3174">            {OSPREY_1_CHAINMASK, OSPREY_2LOHI_CHAINMASK, OSPREY_3_CHAINMASK};</a>
<a name="ln3175">        for (i = 0; i &lt; AR9300_MAX_CHAINS; i++) {</a>
<a name="ln3176">            OS_MEMCPY(target_power_val_t2, target_power_val_t2_eep,</a>
<a name="ln3177">                                   sizeof(target_power_val_t2_eep));</a>
<a name="ln3178">            ar9300_eeprom_set_power_per_rate_table(ah, p_eep_data, chan,</a>
<a name="ln3179">                                     target_power_val_t2, cfg_ctl,</a>
<a name="ln3180">                                     antenna_reduction,</a>
<a name="ln3181">                                     twice_max_regulatory_power,</a>
<a name="ln3182">                                     power_limit, chainmasks[i]);</a>
<a name="ln3183">            HALDEBUG(ah, HAL_DEBUG_POWER_MGMT,</a>
<a name="ln3184">                 &quot; Channel = %d Chainmask = %d, Upper Limit = [%2d.%1d dBm]\n&quot;,</a>
<a name="ln3185">                                       ichan-&gt;channel, i, ahp-&gt;upper_limit[i]/2,</a>
<a name="ln3186">                                       ahp-&gt;upper_limit[i]%2 * 5);</a>
<a name="ln3187">            ar9300_init_rate_txpower(ah, mode, chan, target_power_val_t2,</a>
<a name="ln3188">                                                           chainmasks[i]);</a>
<a name="ln3189">                                     </a>
<a name="ln3190">        }</a>
<a name="ln3191"> </a>
<a name="ln3192">        /* Enable TPC */</a>
<a name="ln3193">        OS_REG_WRITE(ah, AR_PHY_PWRTX_MAX, AR_PHY_PWRTX_MAX_TPC_ENABLE);</a>
<a name="ln3194">        /*</a>
<a name="ln3195">         * Disable per chain power reduction since we are already </a>
<a name="ln3196">         * accounting for this in our calculations </a>
<a name="ln3197">         */</a>
<a name="ln3198">        val = OS_REG_READ(ah, AR_PHY_POWER_TX_SUB);</a>
<a name="ln3199">        if (AR_SREV_WASP(ah)) {</a>
<a name="ln3200">            OS_REG_WRITE(ah, AR_PHY_POWER_TX_SUB,</a>
<a name="ln3201">                       val &amp; AR_PHY_POWER_TX_SUB_2_DISABLE);</a>
<a name="ln3202">        } else {</a>
<a name="ln3203">            OS_REG_WRITE(ah, AR_PHY_POWER_TX_SUB,</a>
<a name="ln3204">                       val &amp; AR_PHY_POWER_TX_SUB_3_DISABLE);</a>
<a name="ln3205">        }</a>
<a name="ln3206">    }</a>
<a name="ln3207"> </a>
<a name="ln3208">    return HAL_OK;</a>
<a name="ln3209">}</a>
<a name="ln3210"> </a>
<a name="ln3211">/**************************************************************</a>
<a name="ln3212"> * ar9300_eeprom_set_addac</a>
<a name="ln3213"> *</a>
<a name="ln3214"> * Set the ADDAC from eeprom.</a>
<a name="ln3215"> */</a>
<a name="ln3216">void</a>
<a name="ln3217">ar9300_eeprom_set_addac(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln3218">{</a>
<a name="ln3219"> </a>
<a name="ln3220">    HALDEBUG(AH_NULL, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln3221">                 &quot;FIXME: ar9300_eeprom_def_set_addac called\n&quot;);</a>
<a name="ln3222">#if 0</a>
<a name="ln3223">    MODAL_EEPDEF_HEADER *p_modal;</a>
<a name="ln3224">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3225">    ar9300_eeprom_t *eep = &amp;ahp-&gt;ah_eeprom.def;</a>
<a name="ln3226">    u_int8_t biaslevel;</a>
<a name="ln3227"> </a>
<a name="ln3228">    if (AH_PRIVATE(ah)-&gt;ah_macVersion != AR_SREV_VERSION_SOWL) {</a>
<a name="ln3229">        return;</a>
<a name="ln3230">    }</a>
<a name="ln3231"> </a>
<a name="ln3232">    HALASSERT(owl_get_eepdef_ver(ahp) == AR9300_EEP_VER);</a>
<a name="ln3233"> </a>
<a name="ln3234">    /* Xpa bias levels in eeprom are valid from rev 14.7 */</a>
<a name="ln3235">    if (owl_get_eepdef_rev(ahp) &lt; AR9300_EEP_MINOR_VER_7) {</a>
<a name="ln3236">        return;</a>
<a name="ln3237">    }</a>
<a name="ln3238"> </a>
<a name="ln3239">    if (ahp-&gt;ah_emu_eeprom) {</a>
<a name="ln3240">        return;</a>
<a name="ln3241">    }</a>
<a name="ln3242"> </a>
<a name="ln3243">    p_modal = &amp;(eep-&gt;modal_header[IEEE80211_IS_CHAN_2GHZ(chan)]);</a>
<a name="ln3244"> </a>
<a name="ln3245">    if (p_modal-&gt;xpa_bias_lvl != 0xff) {</a>
<a name="ln3246">        biaslevel = p_modal-&gt;xpa_bias_lvl;</a>
<a name="ln3247">    } else {</a>
<a name="ln3248">        /* Use freqeuncy specific xpa bias level */</a>
<a name="ln3249">        u_int16_t reset_freq_bin, freq_bin, freq_count = 0;</a>
<a name="ln3250">        CHAN_CENTERS centers;</a>
<a name="ln3251"> </a>
<a name="ln3252">        ar9300_get_channel_centers(ah, chan, &amp;centers);</a>
<a name="ln3253"> </a>
<a name="ln3254">        reset_freq_bin = FREQ2FBIN(centers.synth_center, IEEE80211_IS_CHAN_2GHZ(chan));</a>
<a name="ln3255">        freq_bin = p_modal-&gt;xpa_bias_lvl_freq[0] &amp; 0xff;</a>
<a name="ln3256">        biaslevel = (u_int8_t)(p_modal-&gt;xpa_bias_lvl_freq[0] &gt;&gt; 14);</a>
<a name="ln3257"> </a>
<a name="ln3258">        freq_count++;</a>
<a name="ln3259"> </a>
<a name="ln3260">        while (freq_count &lt; 3) {</a>
<a name="ln3261">            if (p_modal-&gt;xpa_bias_lvl_freq[freq_count] == 0x0) {</a>
<a name="ln3262">                break;</a>
<a name="ln3263">            }</a>
<a name="ln3264"> </a>
<a name="ln3265">            freq_bin = p_modal-&gt;xpa_bias_lvl_freq[freq_count] &amp; 0xff;</a>
<a name="ln3266">            if (reset_freq_bin &gt;= freq_bin) {</a>
<a name="ln3267">                biaslevel =</a>
<a name="ln3268">                    (u_int8_t)(p_modal-&gt;xpa_bias_lvl_freq[freq_count] &gt;&gt; 14);</a>
<a name="ln3269">            } else {</a>
<a name="ln3270">                break;</a>
<a name="ln3271">            }</a>
<a name="ln3272">            freq_count++;</a>
<a name="ln3273">        }</a>
<a name="ln3274">    }</a>
<a name="ln3275"> </a>
<a name="ln3276">    /* Apply bias level to the ADDAC values in the INI array */</a>
<a name="ln3277">    if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln3278">        INI_RA(&amp;ahp-&gt;ah_ini_addac, 7, 1) =</a>
<a name="ln3279">            (INI_RA(&amp;ahp-&gt;ah_ini_addac, 7, 1) &amp; (~0x18)) | biaslevel &lt;&lt; 3;</a>
<a name="ln3280">    } else {</a>
<a name="ln3281">        INI_RA(&amp;ahp-&gt;ah_ini_addac, 6, 1) =</a>
<a name="ln3282">            (INI_RA(&amp;ahp-&gt;ah_ini_addac, 6, 1) &amp; (~0xc0)) | biaslevel &lt;&lt; 6;</a>
<a name="ln3283">    }</a>
<a name="ln3284">#endif</a>
<a name="ln3285">}</a>
<a name="ln3286"> </a>
<a name="ln3287">u_int</a>
<a name="ln3288">ar9300_eeprom_dump_support(struct ath_hal *ah, void **pp_e)</a>
<a name="ln3289">{</a>
<a name="ln3290">    *pp_e = &amp;(AH9300(ah)-&gt;ah_eeprom);</a>
<a name="ln3291">    return sizeof(ar9300_eeprom_t);</a>
<a name="ln3292">}</a>
<a name="ln3293"> </a>
<a name="ln3294">u_int8_t</a>
<a name="ln3295">ar9300_eeprom_get_num_ant_config(struct ath_hal_9300 *ahp,</a>
<a name="ln3296">    HAL_FREQ_BAND freq_band)</a>
<a name="ln3297">{</a>
<a name="ln3298">#if 0</a>
<a name="ln3299">    ar9300_eeprom_t  *eep = &amp;ahp-&gt;ah_eeprom.def;</a>
<a name="ln3300">    MODAL_EEPDEF_HEADER *p_modal =</a>
<a name="ln3301">        &amp;(eep-&gt;modal_header[HAL_FREQ_BAND_2GHZ == freq_band]);</a>
<a name="ln3302">    BASE_EEPDEF_HEADER  *p_base  = &amp;eep-&gt;base_eep_header;</a>
<a name="ln3303">    u_int8_t         num_ant_config;</a>
<a name="ln3304"> </a>
<a name="ln3305">    num_ant_config = 1; /* default antenna configuration */</a>
<a name="ln3306"> </a>
<a name="ln3307">    if (p_base-&gt;version &gt;= 0x0E0D) {</a>
<a name="ln3308">        if (p_modal-&gt;use_ant1) {</a>
<a name="ln3309">            num_ant_config += 1;</a>
<a name="ln3310">        }</a>
<a name="ln3311">    }</a>
<a name="ln3312"> </a>
<a name="ln3313">    return num_ant_config;</a>
<a name="ln3314">#else</a>
<a name="ln3315">    return 1;</a>
<a name="ln3316">#endif</a>
<a name="ln3317">}</a>
<a name="ln3318"> </a>
<a name="ln3319">HAL_STATUS</a>
<a name="ln3320">ar9300_eeprom_get_ant_cfg(struct ath_hal_9300 *ahp,</a>
<a name="ln3321">  const struct ieee80211_channel *chan,</a>
<a name="ln3322">  u_int8_t index, u_int16_t *config)</a>
<a name="ln3323">{</a>
<a name="ln3324">#if 0</a>
<a name="ln3325">    ar9300_eeprom_t  *eep = &amp;ahp-&gt;ah_eeprom.def;</a>
<a name="ln3326">    MODAL_EEPDEF_HEADER *p_modal = &amp;(eep-&gt;modal_header[IEEE80211_IS_CHAN_2GHZ(chan)]);</a>
<a name="ln3327">    BASE_EEPDEF_HEADER  *p_base  = &amp;eep-&gt;base_eep_header;</a>
<a name="ln3328"> </a>
<a name="ln3329">    switch (index) {</a>
<a name="ln3330">    case 0:</a>
<a name="ln3331">        *config = p_modal-&gt;ant_ctrl_common &amp; 0xFFFF;</a>
<a name="ln3332">        return HAL_OK;</a>
<a name="ln3333">    case 1:</a>
<a name="ln3334">        if (p_base-&gt;version &gt;= 0x0E0D) {</a>
<a name="ln3335">            if (p_modal-&gt;use_ant1) {</a>
<a name="ln3336">                *config = ((p_modal-&gt;ant_ctrl_common &amp; 0xFFFF0000) &gt;&gt; 16);</a>
<a name="ln3337">                return HAL_OK;</a>
<a name="ln3338">            }</a>
<a name="ln3339">        }</a>
<a name="ln3340">        break;</a>
<a name="ln3341">    default:</a>
<a name="ln3342">        break;</a>
<a name="ln3343">    }</a>
<a name="ln3344">#endif</a>
<a name="ln3345">    return HAL_EINVAL;</a>
<a name="ln3346">}</a>
<a name="ln3347"> </a>
<a name="ln3348">u_int8_t*</a>
<a name="ln3349">ar9300_eeprom_get_cust_data(struct ath_hal_9300 *ahp)</a>
<a name="ln3350">{</a>
<a name="ln3351">    return (u_int8_t *)ahp;</a>
<a name="ln3352">}</a>
<a name="ln3353"> </a>
<a name="ln3354">#ifdef UNUSED</a>
<a name="ln3355">static inline HAL_STATUS</a>
<a name="ln3356">ar9300_check_eeprom(struct ath_hal *ah)</a>
<a name="ln3357">{</a>
<a name="ln3358">#if 0</a>
<a name="ln3359">    u_int32_t sum = 0, el;</a>
<a name="ln3360">    u_int16_t *eepdata;</a>
<a name="ln3361">    int i;</a>
<a name="ln3362">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3363">    HAL_BOOL need_swap = AH_FALSE;</a>
<a name="ln3364">    ar9300_eeprom_t *eep = (ar9300_eeprom_t *)&amp;ahp-&gt;ah_eeprom.def;</a>
<a name="ln3365">    u_int16_t magic, magic2;</a>
<a name="ln3366">    int addr;</a>
<a name="ln3367">    u_int16_t temp;</a>
<a name="ln3368"> </a>
<a name="ln3369">    /*</a>
<a name="ln3370">    ** We need to check the EEPROM data regardless of if it's in flash or</a>
<a name="ln3371">    ** in EEPROM.</a>
<a name="ln3372">    */</a>
<a name="ln3373"> </a>
<a name="ln3374">    if (!ahp-&gt;ah_priv.priv.ah_eeprom_read(</a>
<a name="ln3375">            ah, AR9300_EEPROM_MAGIC_OFFSET, &amp;magic))</a>
<a name="ln3376">    {</a>
<a name="ln3377">        HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;%s: Reading Magic # failed\n&quot;, __func__);</a>
<a name="ln3378">        return AH_FALSE;</a>
<a name="ln3379">    }</a>
<a name="ln3380"> </a>
<a name="ln3381">    HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;%s: Read Magic = 0x%04X\n&quot;, __func__, magic);</a>
<a name="ln3382"> </a>
<a name="ln3383">    if (!ar9300_eep_data_in_flash(ah)) {</a>
<a name="ln3384"> </a>
<a name="ln3385">        if (magic != AR9300_EEPROM_MAGIC) {</a>
<a name="ln3386">            magic2 = SWAP16(magic);</a>
<a name="ln3387"> </a>
<a name="ln3388">            if (magic2 == AR9300_EEPROM_MAGIC) {</a>
<a name="ln3389">                need_swap = AH_TRUE;</a>
<a name="ln3390">                eepdata = (u_int16_t *)(&amp;ahp-&gt;ah_eeprom);</a>
<a name="ln3391"> </a>
<a name="ln3392">                for (addr = 0;</a>
<a name="ln3393">                     addr &lt; sizeof(ar9300_eeprom_t) / sizeof(u_int16_t);</a>
<a name="ln3394">                     addr++)</a>
<a name="ln3395">                {</a>
<a name="ln3396">                    temp = SWAP16(*eepdata);</a>
<a name="ln3397">                    *eepdata = temp;</a>
<a name="ln3398">                    eepdata++;</a>
<a name="ln3399"> </a>
<a name="ln3400">                    HALDEBUG(ah, HAL_DEBUG_EEPROM_DUMP, &quot;0x%04X  &quot;, *eepdata);</a>
<a name="ln3401">                    if (((addr + 1) % 6) == 0) {</a>
<a name="ln3402">                        HALDEBUG(ah, HAL_DEBUG_EEPROM_DUMP, &quot;\n&quot;);</a>
<a name="ln3403">                    }</a>
<a name="ln3404">                }</a>
<a name="ln3405">            } else {</a>
<a name="ln3406">                HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3407">                    &quot;Invalid EEPROM Magic. endianness missmatch.\n&quot;);</a>
<a name="ln3408">                return HAL_EEBADSUM;</a>
<a name="ln3409">            }</a>
<a name="ln3410">        }</a>
<a name="ln3411">    } else {</a>
<a name="ln3412">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3413">                 &quot;EEPROM being read from flash @0x%p\n&quot;, AH_PRIVATE(ah)-&gt;ah_st);</a>
<a name="ln3414">    }</a>
<a name="ln3415"> </a>
<a name="ln3416">    HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;need_swap = %s.\n&quot;, need_swap?&quot;True&quot;:&quot;False&quot;);</a>
<a name="ln3417"> </a>
<a name="ln3418">    if (need_swap) {</a>
<a name="ln3419">        el = SWAP16(ahp-&gt;ah_eeprom.def.base_eep_header.length);</a>
<a name="ln3420">    } else {</a>
<a name="ln3421">        el = ahp-&gt;ah_eeprom.def.base_eep_header.length;</a>
<a name="ln3422">    }</a>
<a name="ln3423"> </a>
<a name="ln3424">    eepdata = (u_int16_t *)(&amp;ahp-&gt;ah_eeprom.def);</a>
<a name="ln3425">    for (i = 0;</a>
<a name="ln3426">         i &lt; AH_MIN(el, sizeof(ar9300_eeprom_t)) / sizeof(u_int16_t);</a>
<a name="ln3427">         i++) {</a>
<a name="ln3428">        sum ^= *eepdata++;</a>
<a name="ln3429">    }</a>
<a name="ln3430"> </a>
<a name="ln3431">    if (need_swap) {</a>
<a name="ln3432">        /*</a>
<a name="ln3433">        *  preddy: EEPROM endianness does not match. So change it</a>
<a name="ln3434">        *  8bit values in eeprom data structure does not need to be swapped</a>
<a name="ln3435">        *  Only &gt;8bits (16 &amp; 32) values need to be swapped</a>
<a name="ln3436">        *  If a new 16 or 32 bit field is added to the EEPROM contents,</a>
<a name="ln3437">        *  please make sure to swap the field here</a>
<a name="ln3438">        */</a>
<a name="ln3439">        u_int32_t integer, j;</a>
<a name="ln3440">        u_int16_t word;</a>
<a name="ln3441"> </a>
<a name="ln3442">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3443">            &quot;EEPROM Endianness is not native.. Changing \n&quot;);</a>
<a name="ln3444"> </a>
<a name="ln3445">        /* convert Base Eep header */</a>
<a name="ln3446">        word = SWAP16(eep-&gt;base_eep_header.length);</a>
<a name="ln3447">        eep-&gt;base_eep_header.length = word;</a>
<a name="ln3448"> </a>
<a name="ln3449">        word = SWAP16(eep-&gt;base_eep_header.checksum);</a>
<a name="ln3450">        eep-&gt;base_eep_header.checksum = word;</a>
<a name="ln3451"> </a>
<a name="ln3452">        word = SWAP16(eep-&gt;base_eep_header.version);</a>
<a name="ln3453">        eep-&gt;base_eep_header.version = word;</a>
<a name="ln3454"> </a>
<a name="ln3455">        word = SWAP16(eep-&gt;base_eep_header.reg_dmn[0]);</a>
<a name="ln3456">        eep-&gt;base_eep_header.reg_dmn[0] = word;</a>
<a name="ln3457"> </a>
<a name="ln3458">        word = SWAP16(eep-&gt;base_eep_header.reg_dmn[1]);</a>
<a name="ln3459">        eep-&gt;base_eep_header.reg_dmn[1] = word;</a>
<a name="ln3460"> </a>
<a name="ln3461">        word = SWAP16(eep-&gt;base_eep_header.rf_silent);</a>
<a name="ln3462">        eep-&gt;base_eep_header.rf_silent = word;</a>
<a name="ln3463"> </a>
<a name="ln3464">        word = SWAP16(eep-&gt;base_eep_header.blue_tooth_options);</a>
<a name="ln3465">        eep-&gt;base_eep_header.blue_tooth_options = word;</a>
<a name="ln3466"> </a>
<a name="ln3467">        word = SWAP16(eep-&gt;base_eep_header.device_cap);</a>
<a name="ln3468">        eep-&gt;base_eep_header.device_cap = word;</a>
<a name="ln3469"> </a>
<a name="ln3470">        /* convert Modal Eep header */</a>
<a name="ln3471">        for (j = 0; j &lt; ARRAY_LENGTH(eep-&gt;modal_header); j++) {</a>
<a name="ln3472">            MODAL_EEPDEF_HEADER *p_modal = &amp;eep-&gt;modal_header[j];</a>
<a name="ln3473">            integer = SWAP32(p_modal-&gt;ant_ctrl_common);</a>
<a name="ln3474">            p_modal-&gt;ant_ctrl_common = integer;</a>
<a name="ln3475"> </a>
<a name="ln3476">            for (i = 0; i &lt; AR9300_MAX_CHAINS; i++) {</a>
<a name="ln3477">                integer = SWAP32(p_modal-&gt;ant_ctrl_chain[i]);</a>
<a name="ln3478">                p_modal-&gt;ant_ctrl_chain[i] = integer;</a>
<a name="ln3479">            }</a>
<a name="ln3480"> </a>
<a name="ln3481">            for (i = 0; i &lt; AR9300_EEPROM_MODAL_SPURS; i++) {</a>
<a name="ln3482">                word = SWAP16(p_modal-&gt;spur_chans[i].spur_chan);</a>
<a name="ln3483">                p_modal-&gt;spur_chans[i].spur_chan = word;</a>
<a name="ln3484">            }</a>
<a name="ln3485">        }</a>
<a name="ln3486">    }</a>
<a name="ln3487"> </a>
<a name="ln3488">    /* Check CRC - Attach should fail on a bad checksum */</a>
<a name="ln3489">    if (sum != 0xffff || owl_get_eepdef_ver(ahp) != AR9300_EEP_VER ||</a>
<a name="ln3490">        owl_get_eepdef_rev(ahp) &lt; AR9300_EEP_NO_BACK_VER) {</a>
<a name="ln3491">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3492">            &quot;Bad EEPROM checksum 0x%x or revision 0x%04x\n&quot;,</a>
<a name="ln3493">            sum, owl_get_eepdef_ver(ahp));</a>
<a name="ln3494">        return HAL_EEBADSUM;</a>
<a name="ln3495">    }</a>
<a name="ln3496">#ifdef EEPROM_DUMP</a>
<a name="ln3497">    ar9300_eeprom_def_dump(ah, eep);</a>
<a name="ln3498">#endif</a>
<a name="ln3499"> </a>
<a name="ln3500">#if 0</a>
<a name="ln3501">#ifdef AH_AR9300_OVRD_TGT_PWR</a>
<a name="ln3502"> </a>
<a name="ln3503">    /*</a>
<a name="ln3504">     * 14.4 EEPROM contains low target powers.</a>
<a name="ln3505">     * Hardcode until EEPROM &gt; 14.4</a>
<a name="ln3506">     */</a>
<a name="ln3507">    if (owl_get_eepdef_ver(ahp) == 14 &amp;&amp; owl_get_eepdef_rev(ahp) &lt;= 4) {</a>
<a name="ln3508">        MODAL_EEPDEF_HEADER *p_modal;</a>
<a name="ln3509"> </a>
<a name="ln3510">#ifdef EEPROM_DUMP</a>
<a name="ln3511">        HALDEBUG(ah,  HAL_DEBUG_POWER_OVERRIDE, &quot;Original Target Powers\n&quot;);</a>
<a name="ln3512">        ar9300_eep_def_dump_tgt_power(ah, eep);</a>
<a name="ln3513">#endif</a>
<a name="ln3514">        HALDEBUG(ah,  HAL_DEBUG_POWER_OVERRIDE, </a>
<a name="ln3515">                &quot;Override Target Powers. EEPROM Version is %d.%d, &quot;</a>
<a name="ln3516">                &quot;Device Type %d\n&quot;,</a>
<a name="ln3517">                owl_get_eepdef_ver(ahp),</a>
<a name="ln3518">                owl_get_eepdef_rev(ahp),</a>
<a name="ln3519">                eep-&gt;base_eep_header.device_type);</a>
<a name="ln3520"> </a>
<a name="ln3521"> </a>
<a name="ln3522">        ar9300_eep_def_override_tgt_power(ah, eep);</a>
<a name="ln3523"> </a>
<a name="ln3524">        if (eep-&gt;base_eep_header.device_type == 5) {</a>
<a name="ln3525">            /* for xb72 only: improve transmit EVM for interop */</a>
<a name="ln3526">            p_modal = &amp;eep-&gt;modal_header[1];</a>
<a name="ln3527">            p_modal-&gt;tx_frame_to_data_start = 0x23;</a>
<a name="ln3528">            p_modal-&gt;tx_frame_to_xpa_on = 0x23;</a>
<a name="ln3529">            p_modal-&gt;tx_frame_to_pa_on = 0x23;</a>
<a name="ln3530">    }</a>
<a name="ln3531"> </a>
<a name="ln3532">#ifdef EEPROM_DUMP</a>
<a name="ln3533">        HALDEBUG(ah, HAL_DEBUG_POWER_OVERRIDE, &quot;Modified Target Powers\n&quot;);</a>
<a name="ln3534">        ar9300_eep_def_dump_tgt_power(ah, eep);</a>
<a name="ln3535">#endif</a>
<a name="ln3536">        }</a>
<a name="ln3537">#endif /* AH_AR9300_OVRD_TGT_PWR */</a>
<a name="ln3538">#endif</a>
<a name="ln3539">#endif</a>
<a name="ln3540">    return HAL_OK;</a>
<a name="ln3541">}</a>
<a name="ln3542">#endif</a>
<a name="ln3543"> </a>
<a name="ln3544">static u_int16_t</a>
<a name="ln3545">ar9300_eeprom_get_spur_chan(struct ath_hal *ah, int i, HAL_BOOL is_2ghz)</a>
<a name="ln3546">{</a>
<a name="ln3547">    u_int16_t   spur_val = AR_NO_SPUR;</a>
<a name="ln3548">#if 0</a>
<a name="ln3549">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3550">    ar9300_eeprom_t *eep = (ar9300_eeprom_t *)&amp;ahp-&gt;ah_eeprom;</a>
<a name="ln3551"> </a>
<a name="ln3552">    HALASSERT(i &lt;  AR_EEPROM_MODAL_SPURS );</a>
<a name="ln3553"> </a>
<a name="ln3554">    HALDEBUG(ah, HAL_DEBUG_ANI,</a>
<a name="ln3555">             &quot;Getting spur idx %d is2Ghz. %d val %x\n&quot;,</a>
<a name="ln3556">             i, is_2ghz,</a>
<a name="ln3557">             AH_PRIVATE(ah)-&gt;ah_config.ath_hal_spur_chans[i][is_2ghz]);</a>
<a name="ln3558"> </a>
<a name="ln3559">    switch (AH_PRIVATE(ah)-&gt;ah_config.ath_hal_spur_mode) {</a>
<a name="ln3560">    case SPUR_DISABLE:</a>
<a name="ln3561">        /* returns AR_NO_SPUR */</a>
<a name="ln3562">        break;</a>
<a name="ln3563">    case SPUR_ENABLE_IOCTL:</a>
<a name="ln3564">        spur_val = AH_PRIVATE(ah)-&gt;ah_config.ath_hal_spur_chans[i][is_2ghz];</a>
<a name="ln3565">        HALDEBUG(ah, HAL_DEBUG_ANI,</a>
<a name="ln3566">            &quot;Getting spur val from new loc. %d\n&quot;, spur_val);</a>
<a name="ln3567">        break;</a>
<a name="ln3568">    case SPUR_ENABLE_EEPROM:</a>
<a name="ln3569">        spur_val = eep-&gt;modal_header[is_2ghz].spur_chans[i].spur_chan;</a>
<a name="ln3570">        break;</a>
<a name="ln3571"> </a>
<a name="ln3572">    }</a>
<a name="ln3573">#endif</a>
<a name="ln3574">    return spur_val;</a>
<a name="ln3575">}</a>
<a name="ln3576"> </a>
<a name="ln3577">#ifdef UNUSED</a>
<a name="ln3578">static inline HAL_BOOL</a>
<a name="ln3579">ar9300_fill_eeprom(struct ath_hal *ah)</a>
<a name="ln3580">{</a>
<a name="ln3581">    return ar9300_eeprom_restore(ah);</a>
<a name="ln3582">}</a>
<a name="ln3583">#endif</a>
<a name="ln3584"> </a>
<a name="ln3585">u_int16_t</a>
<a name="ln3586">ar9300_eeprom_struct_size(void) </a>
<a name="ln3587">{</a>
<a name="ln3588">    return sizeof(ar9300_eeprom_t);</a>
<a name="ln3589">}</a>
<a name="ln3590"> </a>
<a name="ln3591">int ar9300_eeprom_struct_default_many(void)</a>
<a name="ln3592">{</a>
<a name="ln3593">    return ARRAY_LENGTH(default9300);</a>
<a name="ln3594">}</a>
<a name="ln3595"> </a>
<a name="ln3596"> </a>
<a name="ln3597">ar9300_eeprom_t *</a>
<a name="ln3598">ar9300_eeprom_struct_default(int default_index) </a>
<a name="ln3599">{</a>
<a name="ln3600">    if (default_index &gt;= 0 &amp;&amp;</a>
<a name="ln3601">        default_index &lt; ARRAY_LENGTH(default9300))</a>
<a name="ln3602">    {</a>
<a name="ln3603">        return default9300[default_index];</a>
<a name="ln3604">    } else {</a>
<a name="ln3605">        return 0;</a>
<a name="ln3606">    }</a>
<a name="ln3607">}</a>
<a name="ln3608"> </a>
<a name="ln3609">ar9300_eeprom_t *</a>
<a name="ln3610">ar9300_eeprom_struct_default_find_by_id(int id) </a>
<a name="ln3611">{</a>
<a name="ln3612">    int it;</a>
<a name="ln3613"> </a>
<a name="ln3614">    for (it = 0; it &lt; ARRAY_LENGTH(default9300); it++) {</a>
<a name="ln3615">        if (default9300[it] != 0 &amp;&amp; default9300[it]-&gt;template_version == id) {</a>
<a name="ln3616">            return default9300[it];</a>
<a name="ln3617">        }</a>
<a name="ln3618">    }</a>
<a name="ln3619">    return 0;</a>
<a name="ln3620">}</a>
<a name="ln3621"> </a>
<a name="ln3622"> </a>
<a name="ln3623">HAL_BOOL</a>
<a name="ln3624">ar9300_calibration_data_read_flash(struct ath_hal *ah, long address,</a>
<a name="ln3625">    u_int8_t *buffer, int many)</a>
<a name="ln3626">{</a>
<a name="ln3627"> </a>
<a name="ln3628">    if (((address) &lt; 0) || ((address + many) &gt; AR9300_EEPROM_SIZE - 1)) {</a>
<a name="ln3629">        return AH_FALSE;</a>
<a name="ln3630">    }</a>
<a name="ln3631">    return AH_FALSE;</a>
<a name="ln3632">}</a>
<a name="ln3633"> </a>
<a name="ln3634">HAL_BOOL</a>
<a name="ln3635">ar9300_calibration_data_read_eeprom(struct ath_hal *ah, long address,</a>
<a name="ln3636">    u_int8_t *buffer, int many)</a>
<a name="ln3637">{</a>
<a name="ln3638">    int i;</a>
<a name="ln3639">    u_int8_t value[2];</a>
<a name="ln3640">    unsigned long eep_addr;</a>
<a name="ln3641">    unsigned long byte_addr;</a>
<a name="ln3642">    u_int16_t *svalue;</a>
<a name="ln3643"> </a>
<a name="ln3644">    if (((address) &lt; 0) || ((address + many) &gt; AR9300_EEPROM_SIZE)) {</a>
<a name="ln3645">        return AH_FALSE;</a>
<a name="ln3646">    }</a>
<a name="ln3647"> </a>
<a name="ln3648">    for (i = 0; i &lt; many; i++) {</a>
<a name="ln3649">        eep_addr = (u_int16_t) (address + i) / 2;</a>
<a name="ln3650">        byte_addr = (u_int16_t) (address + i) % 2;</a>
<a name="ln3651">        svalue = (u_int16_t *) value;</a>
<a name="ln3652">        if (! ath_hal_eepromRead(ah, eep_addr, svalue)) {</a>
<a name="ln3653">            HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3654">                &quot;%s: Unable to read eeprom region \n&quot;, __func__);</a>
<a name="ln3655">            return AH_FALSE;</a>
<a name="ln3656">        }  </a>
<a name="ln3657">        buffer[i] = (*svalue &gt;&gt; (8 * byte_addr)) &amp; 0xff;</a>
<a name="ln3658">    }  </a>
<a name="ln3659">    return AH_TRUE;</a>
<a name="ln3660">}</a>
<a name="ln3661"> </a>
<a name="ln3662">HAL_BOOL</a>
<a name="ln3663">ar9300_calibration_data_read_otp(struct ath_hal *ah, long address,</a>
<a name="ln3664">    u_int8_t *buffer, int many, HAL_BOOL is_wifi)</a>
<a name="ln3665">{</a>
<a name="ln3666">    int i;</a>
<a name="ln3667">    unsigned long eep_addr;</a>
<a name="ln3668">    unsigned long byte_addr;</a>
<a name="ln3669">    u_int32_t svalue;</a>
<a name="ln3670"> </a>
<a name="ln3671">    if (((address) &lt; 0) || ((address + many) &gt; 0x400)) {</a>
<a name="ln3672">        return AH_FALSE;</a>
<a name="ln3673">    }</a>
<a name="ln3674"> </a>
<a name="ln3675">    for (i = 0; i &lt; many; i++) {</a>
<a name="ln3676">        eep_addr = (u_int16_t) (address + i) / 4; /* otp is 4 bytes long???? */</a>
<a name="ln3677">        byte_addr = (u_int16_t) (address + i) % 4;</a>
<a name="ln3678">        if (!ar9300_otp_read(ah, eep_addr, &amp;svalue, is_wifi)) {</a>
<a name="ln3679">            HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3680">                &quot;%s: Unable to read otp region \n&quot;, __func__);</a>
<a name="ln3681">            return AH_FALSE;</a>
<a name="ln3682">        }  </a>
<a name="ln3683">        buffer[i] = (svalue &gt;&gt; (8 * byte_addr)) &amp; 0xff;</a>
<a name="ln3684">    }  </a>
<a name="ln3685">    return AH_TRUE;</a>
<a name="ln3686">}</a>
<a name="ln3687"> </a>
<a name="ln3688">#ifdef ATH_CAL_NAND_FLASH</a>
<a name="ln3689">HAL_BOOL</a>
<a name="ln3690">ar9300_calibration_data_read_nand(struct ath_hal *ah, long address,</a>
<a name="ln3691">    u_int8_t *buffer, int many)</a>
<a name="ln3692">{</a>
<a name="ln3693">    int ret_len;</a>
<a name="ln3694">    int ret_val = 1;</a>
<a name="ln3695">    </a>
<a name="ln3696">      /* Calling OS based API to read NAND */</a>
<a name="ln3697">    ret_val = OS_NAND_FLASH_READ(ATH_CAL_NAND_PARTITION, address, many, &amp;ret_len, buffer);</a>
<a name="ln3698">    </a>
<a name="ln3699">    return (ret_val ? AH_FALSE: AH_TRUE);</a>
<a name="ln3700">}</a>
<a name="ln3701">#endif</a>
<a name="ln3702"> </a>
<a name="ln3703">HAL_BOOL</a>
<a name="ln3704">ar9300_calibration_data_read(struct ath_hal *ah, long address,</a>
<a name="ln3705">    u_int8_t *buffer, int many)</a>
<a name="ln3706">{</a>
<a name="ln3707">    switch (AH9300(ah)-&gt;calibration_data_source) {</a>
<a name="ln3708">    case calibration_data_flash:</a>
<a name="ln3709">        return ar9300_calibration_data_read_flash(ah, address, buffer, many);</a>
<a name="ln3710">    case calibration_data_eeprom:</a>
<a name="ln3711">        return ar9300_calibration_data_read_eeprom(ah, address, buffer, many);</a>
<a name="ln3712">    case calibration_data_otp:</a>
<a name="ln3713">        return ar9300_calibration_data_read_otp(ah, address, buffer, many, 1);</a>
<a name="ln3714">#ifdef ATH_CAL_NAND_FLASH</a>
<a name="ln3715">    case calibration_data_nand:</a>
<a name="ln3716">        return ar9300_calibration_data_read_nand(ah,address,buffer,many);</a>
<a name="ln3717">#endif</a>
<a name="ln3718"> </a>
<a name="ln3719">    }</a>
<a name="ln3720">    return AH_FALSE;</a>
<a name="ln3721">}</a>
<a name="ln3722"> </a>
<a name="ln3723"> </a>
<a name="ln3724">HAL_BOOL </a>
<a name="ln3725">ar9300_calibration_data_read_array(struct ath_hal *ah, int address,</a>
<a name="ln3726">    u_int8_t *buffer, int many)</a>
<a name="ln3727">{</a>
<a name="ln3728">    int it;</a>
<a name="ln3729"> </a>
<a name="ln3730">    for (it = 0; it &lt; many; it++) {</a>
<a name="ln3731">        (void)ar9300_calibration_data_read(ah, address - it, buffer + it, 1);</a>
<a name="ln3732">    }</a>
<a name="ln3733">    return AH_TRUE;</a>
<a name="ln3734">}</a>
<a name="ln3735"> </a>
<a name="ln3736"> </a>
<a name="ln3737">/*</a>
<a name="ln3738"> * the address where the first configuration block is written</a>
<a name="ln3739"> */</a>
<a name="ln3740">static const int base_address = 0x3ff;                /* 1KB */</a>
<a name="ln3741">static const int base_address_512 = 0x1ff;            /* 512Bytes */</a>
<a name="ln3742"> </a>
<a name="ln3743">/*</a>
<a name="ln3744"> * the address where the NAND first configuration block is written</a>
<a name="ln3745"> */</a>
<a name="ln3746">#ifdef ATH_CAL_NAND_FLASH</a>
<a name="ln3747">static const int base_address_nand = AR9300_FLASH_CAL_START_OFFSET;</a>
<a name="ln3748">#endif</a>
<a name="ln3749"> </a>
<a name="ln3750"> </a>
<a name="ln3751">/*</a>
<a name="ln3752"> * the lower limit on configuration data</a>
<a name="ln3753"> */</a>
<a name="ln3754">static const int low_limit = 0x040;</a>
<a name="ln3755"> </a>
<a name="ln3756">/*</a>
<a name="ln3757"> * returns size of the physical eeprom in bytes.</a>
<a name="ln3758"> * 1024 and 2048 are normal sizes. </a>
<a name="ln3759"> * 0 means there is no eeprom. </a>
<a name="ln3760"> */ </a>
<a name="ln3761">int32_t </a>
<a name="ln3762">ar9300_eeprom_size(struct ath_hal *ah)</a>
<a name="ln3763">{</a>
<a name="ln3764">    u_int16_t data;</a>
<a name="ln3765">    /*</a>
<a name="ln3766">     * first we'll try for 4096 bytes eeprom</a>
<a name="ln3767">     */</a>
<a name="ln3768">    if (ar9300_eeprom_read_word(ah, 2047, &amp;data)) {</a>
<a name="ln3769">        if (data != 0) {</a>
<a name="ln3770">            return 4096;</a>
<a name="ln3771">        }</a>
<a name="ln3772">    }</a>
<a name="ln3773">    /*</a>
<a name="ln3774">     * then we'll try for 2048 bytes eeprom</a>
<a name="ln3775">     */</a>
<a name="ln3776">    if (ar9300_eeprom_read_word(ah, 1023, &amp;data)) {</a>
<a name="ln3777">        if (data != 0) {</a>
<a name="ln3778">            return 2048;</a>
<a name="ln3779">        }</a>
<a name="ln3780">    }</a>
<a name="ln3781">    /*</a>
<a name="ln3782">     * then we'll try for 1024 bytes eeprom</a>
<a name="ln3783">     */</a>
<a name="ln3784">    if (ar9300_eeprom_read_word(ah, 511, &amp;data)) {</a>
<a name="ln3785">        if (data != 0) {</a>
<a name="ln3786">            return 1024;</a>
<a name="ln3787">        }</a>
<a name="ln3788">    }</a>
<a name="ln3789">    return 0;</a>
<a name="ln3790">}</a>
<a name="ln3791"> </a>
<a name="ln3792">/*</a>
<a name="ln3793"> * returns size of the physical otp in bytes.</a>
<a name="ln3794"> * 1024 and 2048 are normal sizes. </a>
<a name="ln3795"> * 0 means there is no eeprom. </a>
<a name="ln3796"> */ </a>
<a name="ln3797">int32_t </a>
<a name="ln3798">ar9300_otp_size(struct ath_hal *ah)</a>
<a name="ln3799">{</a>
<a name="ln3800">    if (AR_SREV_POSEIDON(ah) || AR_SREV_HORNET(ah)) {</a>
<a name="ln3801">        return base_address_512+1;</a>
<a name="ln3802">    } else {</a>
<a name="ln3803">        return base_address+1;</a>
<a name="ln3804">    }</a>
<a name="ln3805">}</a>
<a name="ln3806"> </a>
<a name="ln3807"> </a>
<a name="ln3808">/*</a>
<a name="ln3809"> * find top of memory</a>
<a name="ln3810"> */</a>
<a name="ln3811">int</a>
<a name="ln3812">ar9300_eeprom_base_address(struct ath_hal *ah)</a>
<a name="ln3813">{</a>
<a name="ln3814">    int size;</a>
<a name="ln3815"> </a>
<a name="ln3816">    if (AH9300(ah)-&gt;calibration_data_source == calibration_data_otp) {</a>
<a name="ln3817">		return ar9300_otp_size(ah)-1;</a>
<a name="ln3818">	}</a>
<a name="ln3819">	else</a>
<a name="ln3820">	{</a>
<a name="ln3821">		size = ar9300_eeprom_size(ah);</a>
<a name="ln3822">		if (size &gt; 0) {</a>
<a name="ln3823">			return size - 1;</a>
<a name="ln3824">		} else {</a>
<a name="ln3825">			return ar9300_otp_size(ah)-1;</a>
<a name="ln3826">		}</a>
<a name="ln3827">	}</a>
<a name="ln3828">}</a>
<a name="ln3829"> </a>
<a name="ln3830">int</a>
<a name="ln3831">ar9300_eeprom_volatile(struct ath_hal *ah)</a>
<a name="ln3832">{</a>
<a name="ln3833">    if (AH9300(ah)-&gt;calibration_data_source == calibration_data_otp) {</a>
<a name="ln3834">        return 0;        /* no eeprom, use otp */</a>
<a name="ln3835">    } else {</a>
<a name="ln3836">        return 1;        /* board has eeprom or flash */</a>
<a name="ln3837">    }</a>
<a name="ln3838">}</a>
<a name="ln3839"> </a>
<a name="ln3840">/*</a>
<a name="ln3841"> * need to change this to look for the pcie data in the low parts of memory</a>
<a name="ln3842"> * cal data needs to stop a few locations above </a>
<a name="ln3843"> */</a>
<a name="ln3844">int</a>
<a name="ln3845">ar9300_eeprom_low_limit(struct ath_hal *ah)</a>
<a name="ln3846">{</a>
<a name="ln3847">    return low_limit;</a>
<a name="ln3848">}</a>
<a name="ln3849"> </a>
<a name="ln3850">u_int16_t</a>
<a name="ln3851">ar9300_compression_checksum(u_int8_t *data, int dsize)</a>
<a name="ln3852">{</a>
<a name="ln3853">    int it;</a>
<a name="ln3854">    int checksum = 0;</a>
<a name="ln3855"> </a>
<a name="ln3856">    for (it = 0; it &lt; dsize; it++) {</a>
<a name="ln3857">        checksum += data[it];</a>
<a name="ln3858">        checksum &amp;= 0xffff;</a>
<a name="ln3859">    }</a>
<a name="ln3860"> </a>
<a name="ln3861">    return checksum;</a>
<a name="ln3862">}</a>
<a name="ln3863"> </a>
<a name="ln3864">int</a>
<a name="ln3865">ar9300_compression_header_unpack(u_int8_t *best, int *code, int *reference,</a>
<a name="ln3866">    int *length, int *major, int *minor)</a>
<a name="ln3867">{</a>
<a name="ln3868">    unsigned long value[4];</a>
<a name="ln3869"> </a>
<a name="ln3870">    value[0] = best[0];</a>
<a name="ln3871">    value[1] = best[1];</a>
<a name="ln3872">    value[2] = best[2];</a>
<a name="ln3873">    value[3] = best[3];</a>
<a name="ln3874">    *code = ((value[0] &gt;&gt; 5) &amp; 0x0007);</a>
<a name="ln3875">    *reference = (value[0] &amp; 0x001f) | ((value[1] &gt;&gt; 2) &amp; 0x0020);</a>
<a name="ln3876">    *length = ((value[1] &lt;&lt; 4) &amp; 0x07f0) | ((value[2] &gt;&gt; 4) &amp; 0x000f);</a>
<a name="ln3877">    *major = (value[2] &amp; 0x000f);</a>
<a name="ln3878">    *minor = (value[3] &amp; 0x00ff);</a>
<a name="ln3879"> </a>
<a name="ln3880">    return 4;</a>
<a name="ln3881">}</a>
<a name="ln3882"> </a>
<a name="ln3883"> </a>
<a name="ln3884">static HAL_BOOL</a>
<a name="ln3885">ar9300_uncompress_block(struct ath_hal *ah, u_int8_t *mptr, int mdata_size,</a>
<a name="ln3886">    u_int8_t *block, int size)</a>
<a name="ln3887">{</a>
<a name="ln3888">    int it;</a>
<a name="ln3889">    int spot;</a>
<a name="ln3890">    int offset;</a>
<a name="ln3891">    int length;</a>
<a name="ln3892"> </a>
<a name="ln3893">    spot = 0;</a>
<a name="ln3894">    for (it = 0; it &lt; size; it += (length + 2)) {</a>
<a name="ln3895">        offset = block[it];</a>
<a name="ln3896">        offset &amp;= 0xff;</a>
<a name="ln3897">        spot += offset;</a>
<a name="ln3898">        length = block[it + 1];</a>
<a name="ln3899">        length &amp;= 0xff;</a>
<a name="ln3900">        if (length &gt; 0 &amp;&amp; spot &gt;= 0 &amp;&amp; spot + length &lt;= mdata_size) {</a>
<a name="ln3901">            HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3902">                &quot;%s: Restore at %d: spot=%d offset=%d length=%d\n&quot;,</a>
<a name="ln3903">                __func__, it, spot, offset, length);</a>
<a name="ln3904">            OS_MEMCPY(&amp;mptr[spot], &amp;block[it + 2], length);</a>
<a name="ln3905">            spot += length;</a>
<a name="ln3906">        } else if (length &gt; 0) {</a>
<a name="ln3907">            HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3908">                &quot;%s: Bad restore at %d: spot=%d offset=%d length=%d\n&quot;,</a>
<a name="ln3909">                __func__, it, spot, offset, length);</a>
<a name="ln3910">            return AH_FALSE;</a>
<a name="ln3911">        }</a>
<a name="ln3912">    }</a>
<a name="ln3913">    return AH_TRUE;</a>
<a name="ln3914">}</a>
<a name="ln3915"> </a>
<a name="ln3916">static int</a>
<a name="ln3917">ar9300_eeprom_restore_internal_address(struct ath_hal *ah,</a>
<a name="ln3918">    ar9300_eeprom_t *mptr, int mdata_size, int cptr, u_int8_t blank)</a>
<a name="ln3919">{</a>
<a name="ln3920">    u_int8_t word[MOUTPUT]; </a>
<a name="ln3921">    ar9300_eeprom_t *dptr; /* was uint8 */</a>
<a name="ln3922">    int code;</a>
<a name="ln3923">    int reference, length, major, minor;</a>
<a name="ln3924">    int osize;</a>
<a name="ln3925">    int it;</a>
<a name="ln3926">    int restored;</a>
<a name="ln3927">    u_int16_t checksum, mchecksum;</a>
<a name="ln3928"> </a>
<a name="ln3929">    restored = 0;</a>
<a name="ln3930">    for (it = 0; it &lt; MSTATE; it++) {            </a>
<a name="ln3931">        (void) ar9300_calibration_data_read_array(</a>
<a name="ln3932">            ah, cptr, word, compression_header_length);</a>
<a name="ln3933">        if (word[0] == blank &amp;&amp; word[1] == blank &amp;&amp; word[2] == blank &amp;&amp; word[3] == blank)</a>
<a name="ln3934">        {</a>
<a name="ln3935">            break;</a>
<a name="ln3936">        }</a>
<a name="ln3937">        ar9300_compression_header_unpack(</a>
<a name="ln3938">            word, &amp;code, &amp;reference, &amp;length, &amp;major, &amp;minor);</a>
<a name="ln3939">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3940">            &quot;%s: Found block at %x: &quot;</a>
<a name="ln3941">            &quot;code=%d ref=%d length=%d major=%d minor=%d\n&quot;,</a>
<a name="ln3942">            __func__, cptr, code, reference, length, major, minor);</a>
<a name="ln3943">#ifdef DONTUSE</a>
<a name="ln3944">        if (length &gt;= 1024) {</a>
<a name="ln3945">            HALDEBUG(ah, HAL_DEBUG_EEPROM, &quot;%s: Skipping bad header\n&quot;, __func__);</a>
<a name="ln3946">            cptr -= compression_header_length;</a>
<a name="ln3947">            continue;</a>
<a name="ln3948">        }</a>
<a name="ln3949">#endif</a>
<a name="ln3950">        osize = length;                </a>
<a name="ln3951">        (void) ar9300_calibration_data_read_array(</a>
<a name="ln3952">            ah, cptr, word,</a>
<a name="ln3953">            compression_header_length + osize + compression_checksum_length);</a>
<a name="ln3954">        checksum = ar9300_compression_checksum(</a>
<a name="ln3955">            &amp;word[compression_header_length], length);</a>
<a name="ln3956">        mchecksum =</a>
<a name="ln3957">            word[compression_header_length + osize] |</a>
<a name="ln3958">            (word[compression_header_length + osize + 1] &lt;&lt; 8);</a>
<a name="ln3959">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3960">            &quot;%s: checksum %x %x\n&quot;, __func__, checksum, mchecksum);</a>
<a name="ln3961">        if (checksum == mchecksum) {</a>
<a name="ln3962">            switch (code) {</a>
<a name="ln3963">            case _compress_none:</a>
<a name="ln3964">                if (length != mdata_size) {</a>
<a name="ln3965">                    HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3966">                        &quot;%s: EEPROM structure size mismatch &quot;</a>
<a name="ln3967">                        &quot;memory=%d eeprom=%d\n&quot;, __func__, mdata_size, length);</a>
<a name="ln3968">                    return -1;</a>
<a name="ln3969">                }</a>
<a name="ln3970">                OS_MEMCPY((u_int8_t *)mptr,</a>
<a name="ln3971">                    (u_int8_t *)(word + compression_header_length), length);</a>
<a name="ln3972">                HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3973">                    &quot;%s: restored eeprom %d: uncompressed, length %d\n&quot;,</a>
<a name="ln3974">                    __func__, it, length);</a>
<a name="ln3975">                restored = 1;</a>
<a name="ln3976">                break;</a>
<a name="ln3977">#ifdef UNUSED</a>
<a name="ln3978">            case _compress_lzma:</a>
<a name="ln3979">                if (reference == reference_current) {</a>
<a name="ln3980">                    dptr = mptr;</a>
<a name="ln3981">                } else {</a>
<a name="ln3982">                    dptr = (u_int8_t *)ar9300_eeprom_struct_default_find_by_id(</a>
<a name="ln3983">                        reference);</a>
<a name="ln3984">                    if (dptr == 0) {</a>
<a name="ln3985">                        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3986">                            &quot;%s: Can't find reference eeprom struct %d\n&quot;,</a>
<a name="ln3987">                            __func__, reference);</a>
<a name="ln3988">                        goto done;</a>
<a name="ln3989">                    }</a>
<a name="ln3990">                }</a>
<a name="ln3991">                usize = -1;</a>
<a name="ln3992">                if (usize != mdata_size) {</a>
<a name="ln3993">                    HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln3994">                        &quot;%s: uncompressed data is wrong size %d %d\n&quot;,</a>
<a name="ln3995">                        __func__, usize, mdata_size);</a>
<a name="ln3996">                    goto done;</a>
<a name="ln3997">                }</a>
<a name="ln3998"> </a>
<a name="ln3999">                for (ib = 0; ib &lt; mdata_size; ib++) {</a>
<a name="ln4000">                    mptr[ib] = dptr[ib] ^ word[ib + overhead];</a>
<a name="ln4001">                }</a>
<a name="ln4002">                HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln4003">                    &quot;%s: restored eeprom %d: compressed, &quot;</a>
<a name="ln4004">                    &quot;reference %d, length %d\n&quot;,</a>
<a name="ln4005">                    __func__, it, reference, length);</a>
<a name="ln4006">                break;</a>
<a name="ln4007">            case _compress_pairs:</a>
<a name="ln4008">                if (reference == reference_current) {</a>
<a name="ln4009">                    dptr = mptr;</a>
<a name="ln4010">                } else {</a>
<a name="ln4011">                    dptr = (u_int8_t *)ar9300_eeprom_struct_default_find_by_id(</a>
<a name="ln4012">                        reference);</a>
<a name="ln4013">                    if (dptr == 0) {</a>
<a name="ln4014">                        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln4015">                            &quot;%s: Can't find the reference &quot;</a>
<a name="ln4016">                            &quot;eeprom structure %d\n&quot;,</a>
<a name="ln4017">                            __func__, reference);</a>
<a name="ln4018">                        goto done;</a>
<a name="ln4019">                    }</a>
<a name="ln4020">                }</a>
<a name="ln4021">                HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln4022">                    &quot;%s: restored eeprom %d: &quot;</a>
<a name="ln4023">                    &quot;pairs, reference %d, length %d,\n&quot;,</a>
<a name="ln4024">                    __func__, it, reference, length);</a>
<a name="ln4025">                break;</a>
<a name="ln4026">#endif</a>
<a name="ln4027">            case _compress_block:</a>
<a name="ln4028">                if (reference == reference_current) {</a>
<a name="ln4029">                    dptr = mptr;</a>
<a name="ln4030">                } else {</a>
<a name="ln4031">                    dptr = ar9300_eeprom_struct_default_find_by_id(reference);</a>
<a name="ln4032">                    if (dptr == 0) {</a>
<a name="ln4033">                        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln4034">                            &quot;%s: cant find reference eeprom struct %d\n&quot;,</a>
<a name="ln4035">                            __func__, reference);</a>
<a name="ln4036">                        break;</a>
<a name="ln4037">                    }</a>
<a name="ln4038">                    OS_MEMCPY(mptr, dptr, mdata_size);</a>
<a name="ln4039">                }</a>
<a name="ln4040"> </a>
<a name="ln4041">                HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln4042">                    &quot;%s: restore eeprom %d: block, reference %d, length %d\n&quot;,</a>
<a name="ln4043">                    __func__, it, reference, length);</a>
<a name="ln4044">                (void) ar9300_uncompress_block(ah,</a>
<a name="ln4045">                    (u_int8_t *) mptr, mdata_size,</a>
<a name="ln4046">                    (u_int8_t *) (word + compression_header_length), length);</a>
<a name="ln4047">                restored = 1;</a>
<a name="ln4048">                break;</a>
<a name="ln4049">            default:</a>
<a name="ln4050">                HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln4051">                    &quot;%s: unknown compression code %d\n&quot;, __func__, code);</a>
<a name="ln4052">                break;</a>
<a name="ln4053">            }</a>
<a name="ln4054">        } else {</a>
<a name="ln4055">            HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln4056">                &quot;%s: skipping block with bad checksum\n&quot;, __func__);</a>
<a name="ln4057">        }</a>
<a name="ln4058">        cptr -= compression_header_length + osize + compression_checksum_length;</a>
<a name="ln4059">    }</a>
<a name="ln4060"> </a>
<a name="ln4061">    if (!restored) {</a>
<a name="ln4062">        cptr = -1;</a>
<a name="ln4063">    }</a>
<a name="ln4064">    return cptr;</a>
<a name="ln4065">}</a>
<a name="ln4066"> </a>
<a name="ln4067">static int</a>
<a name="ln4068">ar9300_eeprom_restore_from_dram(struct ath_hal *ah, ar9300_eeprom_t *mptr,</a>
<a name="ln4069">    int mdata_size)</a>
<a name="ln4070">{</a>
<a name="ln4071">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4072">#if !defined(USE_PLATFORM_FRAMEWORK)</a>
<a name="ln4073">    char *cal_ptr;</a>
<a name="ln4074">#endif</a>
<a name="ln4075"> </a>
<a name="ln4076">    HALASSERT(mdata_size &gt; 0);</a>
<a name="ln4077"> </a>
<a name="ln4078">    /* if cal_in_flash is AH_TRUE, the address sent by LMAC to HAL</a>
<a name="ln4079">       (i.e. ah-&gt;ah_st) is corresponding to Flash. so return from </a>
<a name="ln4080">       here if ar9300_eep_data_in_flash(ah) returns AH_TRUE */</a>
<a name="ln4081">    if(ar9300_eep_data_in_flash(ah))</a>
<a name="ln4082">        return -1;</a>
<a name="ln4083"> </a>
<a name="ln4084">#if 0</a>
<a name="ln4085">    /* check if LMAC sent DRAM address is valid */</a>
<a name="ln4086">    if (!(uintptr_t)(AH_PRIVATE(ah)-&gt;ah_st)) {</a>
<a name="ln4087">        return -1;</a>
<a name="ln4088">    }</a>
<a name="ln4089">#endif</a>
<a name="ln4090"> </a>
<a name="ln4091">    /* When calibration data is from host, Host will copy the </a>
<a name="ln4092">       compressed data to the predefined DRAM location saved at ah-&gt;ah_st */</a>
<a name="ln4093">#if 0</a>
<a name="ln4094">    ath_hal_printf(ah, &quot;Restoring Cal data from DRAM\n&quot;);</a>
<a name="ln4095">    ahp-&gt;ah_cal_mem = OS_REMAP((uintptr_t)(AH_PRIVATE(ah)-&gt;ah_st), </a>
<a name="ln4096">							HOST_CALDATA_SIZE);</a>
<a name="ln4097">#endif</a>
<a name="ln4098">    if (!ahp-&gt;ah_cal_mem)</a>
<a name="ln4099">    {</a>
<a name="ln4100">       HALDEBUG(ah, HAL_DEBUG_EEPROM,&quot;%s: can't remap dram region\n&quot;, __func__);</a>
<a name="ln4101">       return -1;</a>
<a name="ln4102">    }</a>
<a name="ln4103">#if !defined(USE_PLATFORM_FRAMEWORK)</a>
<a name="ln4104">    cal_ptr = &amp;((char *)(ahp-&gt;ah_cal_mem))[AR9300_FLASH_CAL_START_OFFSET];</a>
<a name="ln4105">    OS_MEMCPY(mptr, cal_ptr, mdata_size);</a>
<a name="ln4106">#else</a>
<a name="ln4107">    OS_MEMCPY(mptr, ahp-&gt;ah_cal_mem, mdata_size);</a>
<a name="ln4108">#endif</a>
<a name="ln4109"> </a>
<a name="ln4110">    if (mptr-&gt;eeprom_version   == 0xff ||</a>
<a name="ln4111">        mptr-&gt;template_version == 0xff ||</a>
<a name="ln4112">        mptr-&gt;eeprom_version   == 0    ||</a>
<a name="ln4113">        mptr-&gt;template_version == 0)</a>
<a name="ln4114">    {</a>
<a name="ln4115">        /* The board is uncalibrated */</a>
<a name="ln4116">        return -1;</a>
<a name="ln4117">    }</a>
<a name="ln4118">    if (mptr-&gt;eeprom_version != 0x2)</a>
<a name="ln4119">    {</a>
<a name="ln4120">        return -1;</a>
<a name="ln4121">    }</a>
<a name="ln4122"> </a>
<a name="ln4123">    return mdata_size;</a>
<a name="ln4124"> </a>
<a name="ln4125">}</a>
<a name="ln4126"> </a>
<a name="ln4127">static int</a>
<a name="ln4128">ar9300_eeprom_restore_from_flash(struct ath_hal *ah, ar9300_eeprom_t *mptr,</a>
<a name="ln4129">    int mdata_size)</a>
<a name="ln4130">{</a>
<a name="ln4131">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4132">    char *cal_ptr;</a>
<a name="ln4133"> </a>
<a name="ln4134">    HALASSERT(mdata_size &gt; 0);</a>
<a name="ln4135"> </a>
<a name="ln4136">    if (!ahp-&gt;ah_cal_mem) {</a>
<a name="ln4137">        return -1;</a>
<a name="ln4138">    }</a>
<a name="ln4139"> </a>
<a name="ln4140">    ath_hal_printf(ah, &quot;Restoring Cal data from Flash\n&quot;);</a>
<a name="ln4141">    /*</a>
<a name="ln4142">     * When calibration data is saved in flash, read</a>
<a name="ln4143">     * uncompressed eeprom structure from flash and return</a>
<a name="ln4144">     */</a>
<a name="ln4145">    cal_ptr = &amp;((char *)(ahp-&gt;ah_cal_mem))[AR9300_FLASH_CAL_START_OFFSET];</a>
<a name="ln4146">    OS_MEMCPY(mptr, cal_ptr, mdata_size);</a>
<a name="ln4147">#if 0</a>
<a name="ln4148">    ar9300_swap_eeprom((ar9300_eeprom_t *)mptr); DONE IN ar9300_restore()</a>
<a name="ln4149">#endif</a>
<a name="ln4150">    if (mptr-&gt;eeprom_version   == 0xff ||</a>
<a name="ln4151">        mptr-&gt;template_version == 0xff ||</a>
<a name="ln4152">        mptr-&gt;eeprom_version   == 0    ||</a>
<a name="ln4153">        mptr-&gt;template_version == 0)</a>
<a name="ln4154">    {   </a>
<a name="ln4155">        /* The board is uncalibrated */</a>
<a name="ln4156">        return -1;</a>
<a name="ln4157">    } </a>
<a name="ln4158">    if (mptr-&gt;eeprom_version != 0x2)</a>
<a name="ln4159">    {</a>
<a name="ln4160">        return -1;</a>
<a name="ln4161">    }</a>
<a name="ln4162">    return mdata_size;</a>
<a name="ln4163">}</a>
<a name="ln4164"> </a>
<a name="ln4165">/*</a>
<a name="ln4166"> * Read the configuration data from the storage. We try the order with:</a>
<a name="ln4167"> * EEPROM, Flash, OTP. If all of above failed, use the default template.</a>
<a name="ln4168"> * The data can be put in any specified memory buffer.</a>
<a name="ln4169"> *</a>
<a name="ln4170"> * Returns -1 on error. </a>
<a name="ln4171"> * Returns address of next memory location on success.</a>
<a name="ln4172"> */</a>
<a name="ln4173">int</a>
<a name="ln4174">ar9300_eeprom_restore_internal(struct ath_hal *ah, ar9300_eeprom_t *mptr,</a>
<a name="ln4175">    int mdata_size)</a>
<a name="ln4176">{</a>
<a name="ln4177">    int nptr;</a>
<a name="ln4178"> </a>
<a name="ln4179">    nptr = -1;    </a>
<a name="ln4180"> </a>
<a name="ln4181">    if ((AH9300(ah)-&gt;calibration_data_try == calibration_data_none ||</a>
<a name="ln4182">         AH9300(ah)-&gt;calibration_data_try == calibration_data_dram) &amp;&amp;</a>
<a name="ln4183">         AH9300(ah)-&gt;try_dram &amp;&amp; nptr &lt; 0)</a>
<a name="ln4184">    {   </a>
<a name="ln4185">        ath_hal_printf(ah, &quot;Restoring Cal data from DRAM\n&quot;);</a>
<a name="ln4186">        AH9300(ah)-&gt;calibration_data_source = calibration_data_dram;</a>
<a name="ln4187">        AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln4188">        nptr = ar9300_eeprom_restore_from_dram(ah, mptr, mdata_size);</a>
<a name="ln4189">        if (nptr &lt; 0) {</a>
<a name="ln4190">            AH9300(ah)-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln4191">            AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln4192">        }</a>
<a name="ln4193">    }</a>
<a name="ln4194">    </a>
<a name="ln4195">    if ((AH9300(ah)-&gt;calibration_data_try == calibration_data_none ||</a>
<a name="ln4196">         AH9300(ah)-&gt;calibration_data_try == calibration_data_eeprom) &amp;&amp;</a>
<a name="ln4197">        AH9300(ah)-&gt;try_eeprom &amp;&amp; nptr &lt; 0)</a>
<a name="ln4198">    {</a>
<a name="ln4199">        /*</a>
<a name="ln4200">         * need to look at highest eeprom address as well as at</a>
<a name="ln4201">         * base_address=0x3ff where we used to write the data</a>
<a name="ln4202">         */</a>
<a name="ln4203">        ath_hal_printf(ah, &quot;Restoring Cal data from EEPROM\n&quot;);</a>
<a name="ln4204">        AH9300(ah)-&gt;calibration_data_source = calibration_data_eeprom;</a>
<a name="ln4205">        if (AH9300(ah)-&gt;calibration_data_try_address != 0) {</a>
<a name="ln4206">            AH9300(ah)-&gt;calibration_data_source_address =</a>
<a name="ln4207">                AH9300(ah)-&gt;calibration_data_try_address;</a>
<a name="ln4208">            nptr = ar9300_eeprom_restore_internal_address(</a>
<a name="ln4209">                ah, mptr, mdata_size,</a>
<a name="ln4210">                AH9300(ah)-&gt;calibration_data_source_address, 0xff);</a>
<a name="ln4211">        } else {</a>
<a name="ln4212">            AH9300(ah)-&gt;calibration_data_source_address =</a>
<a name="ln4213">                ar9300_eeprom_base_address(ah);</a>
<a name="ln4214">            nptr = ar9300_eeprom_restore_internal_address(</a>
<a name="ln4215">                ah, mptr, mdata_size,</a>
<a name="ln4216">                AH9300(ah)-&gt;calibration_data_source_address, 0xff);</a>
<a name="ln4217">            if (nptr &lt; 0 &amp;&amp;</a>
<a name="ln4218">                AH9300(ah)-&gt;calibration_data_source_address != base_address)</a>
<a name="ln4219">            {</a>
<a name="ln4220">                AH9300(ah)-&gt;calibration_data_source_address = base_address;</a>
<a name="ln4221">                nptr = ar9300_eeprom_restore_internal_address(</a>
<a name="ln4222">                    ah, mptr, mdata_size,</a>
<a name="ln4223">                    AH9300(ah)-&gt;calibration_data_source_address, 0xff);</a>
<a name="ln4224">            }</a>
<a name="ln4225">        }</a>
<a name="ln4226">        if (nptr &lt; 0) {</a>
<a name="ln4227">            AH9300(ah)-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln4228">            AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln4229">        }</a>
<a name="ln4230">    }</a>
<a name="ln4231"> </a>
<a name="ln4232">    /*</a>
<a name="ln4233">     * ##### should be an ifdef test for any AP usage,</a>
<a name="ln4234">     * either in driver or in nart</a>
<a name="ln4235">     */</a>
<a name="ln4236">    if ((AH9300(ah)-&gt;calibration_data_try == calibration_data_none ||</a>
<a name="ln4237">         AH9300(ah)-&gt;calibration_data_try == calibration_data_flash) &amp;&amp;</a>
<a name="ln4238">        AH9300(ah)-&gt;try_flash &amp;&amp; nptr &lt; 0)</a>
<a name="ln4239">    {</a>
<a name="ln4240">        ath_hal_printf(ah, &quot;Restoring Cal data from Flash\n&quot;);</a>
<a name="ln4241">        AH9300(ah)-&gt;calibration_data_source = calibration_data_flash;</a>
<a name="ln4242">        /* how are we supposed to set this for flash? */</a>
<a name="ln4243">        AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln4244">        nptr = ar9300_eeprom_restore_from_flash(ah, mptr, mdata_size);</a>
<a name="ln4245">        if (nptr &lt; 0) {</a>
<a name="ln4246">            AH9300(ah)-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln4247">            AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln4248">        }</a>
<a name="ln4249">    }</a>
<a name="ln4250"> </a>
<a name="ln4251">    if ((AH9300(ah)-&gt;calibration_data_try == calibration_data_none ||</a>
<a name="ln4252">         AH9300(ah)-&gt;calibration_data_try == calibration_data_otp) &amp;&amp;</a>
<a name="ln4253">        AH9300(ah)-&gt;try_otp &amp;&amp; nptr &lt; 0)</a>
<a name="ln4254">    {</a>
<a name="ln4255">        ath_hal_printf(ah, &quot;Restoring Cal data from OTP\n&quot;);</a>
<a name="ln4256">        AH9300(ah)-&gt;calibration_data_source = calibration_data_otp;</a>
<a name="ln4257">        if (AH9300(ah)-&gt;calibration_data_try_address != 0) {</a>
<a name="ln4258">            AH9300(ah)-&gt;calibration_data_source_address =</a>
<a name="ln4259">                AH9300(ah)-&gt;calibration_data_try_address;</a>
<a name="ln4260">		} else {</a>
<a name="ln4261">            AH9300(ah)-&gt;calibration_data_source_address =</a>
<a name="ln4262">                ar9300_eeprom_base_address(ah);</a>
<a name="ln4263">		}</a>
<a name="ln4264">        nptr = ar9300_eeprom_restore_internal_address(</a>
<a name="ln4265">            ah, mptr, mdata_size, AH9300(ah)-&gt;calibration_data_source_address, 0);</a>
<a name="ln4266">        if (nptr &lt; 0) {</a>
<a name="ln4267">            AH9300(ah)-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln4268">            AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln4269">        }</a>
<a name="ln4270">    }</a>
<a name="ln4271"> </a>
<a name="ln4272">#ifdef ATH_CAL_NAND_FLASH</a>
<a name="ln4273">    if ((AH9300(ah)-&gt;calibration_data_try == calibration_data_none ||</a>
<a name="ln4274">         AH9300(ah)-&gt;calibration_data_try == calibration_data_nand) &amp;&amp;</a>
<a name="ln4275">        AH9300(ah)-&gt;try_nand &amp;&amp; nptr &lt; 0)</a>
<a name="ln4276">    {</a>
<a name="ln4277">        AH9300(ah)-&gt;calibration_data_source = calibration_data_nand;</a>
<a name="ln4278">        AH9300(ah)-&gt;calibration_data_source_address = ((unsigned int)(AH_PRIVATE(ah)-&gt;ah_st)) + base_address_nand;</a>
<a name="ln4279">        if(ar9300_calibration_data_read(</a>
<a name="ln4280">            ah, AH9300(ah)-&gt;calibration_data_source_address, </a>
<a name="ln4281">            (u_int8_t *)mptr, mdata_size) == AH_TRUE)</a>
<a name="ln4282">        {</a>
<a name="ln4283">            nptr = mdata_size;</a>
<a name="ln4284">        }</a>
<a name="ln4285">        /*nptr=ar9300EepromRestoreInternalAddress(ah, mptr, mdataSize, CalibrationDataSourceAddress);*/</a>
<a name="ln4286">        if(nptr &lt; 0)</a>
<a name="ln4287">        {</a>
<a name="ln4288">            AH9300(ah)-&gt;calibration_data_source = calibration_data_none;</a>
<a name="ln4289">            AH9300(ah)-&gt;calibration_data_source_address = 0;</a>
<a name="ln4290">        }</a>
<a name="ln4291">    }</a>
<a name="ln4292">#endif</a>
<a name="ln4293">    if (nptr &lt; 0) {</a>
<a name="ln4294">        ath_hal_printf(ah, &quot;%s[%d] No vaid CAL, calling default template\n&quot;,</a>
<a name="ln4295">            __func__, __LINE__);</a>
<a name="ln4296">        nptr = ar9300_eeprom_restore_something(ah, mptr, mdata_size);</a>
<a name="ln4297">    }</a>
<a name="ln4298"> </a>
<a name="ln4299">    return nptr;</a>
<a name="ln4300">}</a>
<a name="ln4301"> </a>
<a name="ln4302">/******************************************************************************/</a>
<a name="ln4303">/*!</a>
<a name="ln4304">**  \brief Eeprom Swapping Function</a>
<a name="ln4305">**</a>
<a name="ln4306">**  This function will swap the contents of the &quot;longer&quot; EEPROM data items</a>
<a name="ln4307">**  to ensure they are consistent with the endian requirements for the platform</a>
<a name="ln4308">**  they are being compiled for</a>
<a name="ln4309">**</a>
<a name="ln4310">**  \param eh    Pointer to the EEPROM data structure</a>
<a name="ln4311">**  \return N/A</a>
<a name="ln4312">*/</a>
<a name="ln4313">#if AH_BYTE_ORDER == AH_BIG_ENDIAN</a>
<a name="ln4314">void</a>
<a name="ln4315">ar9300_swap_eeprom(ar9300_eeprom_t *eep)</a>
<a name="ln4316">{</a>
<a name="ln4317">    u_int32_t dword;</a>
<a name="ln4318">    u_int16_t word;</a>
<a name="ln4319">    int          i;</a>
<a name="ln4320"> </a>
<a name="ln4321">    word = __bswap16(eep-&gt;base_eep_header.reg_dmn[0]);</a>
<a name="ln4322">    eep-&gt;base_eep_header.reg_dmn[0] = word;</a>
<a name="ln4323"> </a>
<a name="ln4324">    word = __bswap16(eep-&gt;base_eep_header.reg_dmn[1]);</a>
<a name="ln4325">    eep-&gt;base_eep_header.reg_dmn[1] = word;</a>
<a name="ln4326"> </a>
<a name="ln4327">    dword = __bswap32(eep-&gt;base_eep_header.swreg);</a>
<a name="ln4328">    eep-&gt;base_eep_header.swreg = dword;</a>
<a name="ln4329"> </a>
<a name="ln4330">    dword = __bswap32(eep-&gt;modal_header_2g.ant_ctrl_common);</a>
<a name="ln4331">    eep-&gt;modal_header_2g.ant_ctrl_common = dword;</a>
<a name="ln4332"> </a>
<a name="ln4333">    dword = __bswap32(eep-&gt;modal_header_2g.ant_ctrl_common2);</a>
<a name="ln4334">    eep-&gt;modal_header_2g.ant_ctrl_common2 = dword;</a>
<a name="ln4335"> </a>
<a name="ln4336">    dword = __bswap32(eep-&gt;modal_header_2g.paprd_rate_mask_ht20);</a>
<a name="ln4337">    eep-&gt;modal_header_2g.paprd_rate_mask_ht20 = dword;</a>
<a name="ln4338"> </a>
<a name="ln4339">    dword = __bswap32(eep-&gt;modal_header_2g.paprd_rate_mask_ht40);</a>
<a name="ln4340">    eep-&gt;modal_header_2g.paprd_rate_mask_ht40 = dword;</a>
<a name="ln4341"> </a>
<a name="ln4342">    dword = __bswap32(eep-&gt;modal_header_5g.ant_ctrl_common);</a>
<a name="ln4343">    eep-&gt;modal_header_5g.ant_ctrl_common = dword;</a>
<a name="ln4344"> </a>
<a name="ln4345">    dword = __bswap32(eep-&gt;modal_header_5g.ant_ctrl_common2);</a>
<a name="ln4346">    eep-&gt;modal_header_5g.ant_ctrl_common2 = dword;</a>
<a name="ln4347"> </a>
<a name="ln4348">    dword = __bswap32(eep-&gt;modal_header_5g.paprd_rate_mask_ht20);</a>
<a name="ln4349">    eep-&gt;modal_header_5g.paprd_rate_mask_ht20 = dword;</a>
<a name="ln4350"> </a>
<a name="ln4351">    dword = __bswap32(eep-&gt;modal_header_5g.paprd_rate_mask_ht40);</a>
<a name="ln4352">    eep-&gt;modal_header_5g.paprd_rate_mask_ht40 = dword;</a>
<a name="ln4353"> </a>
<a name="ln4354">    for (i = 0; i &lt; OSPREY_MAX_CHAINS; i++) {</a>
<a name="ln4355">        word = __bswap16(eep-&gt;modal_header_2g.ant_ctrl_chain[i]);</a>
<a name="ln4356">        eep-&gt;modal_header_2g.ant_ctrl_chain[i] = word;</a>
<a name="ln4357"> </a>
<a name="ln4358">        word = __bswap16(eep-&gt;modal_header_5g.ant_ctrl_chain[i]);</a>
<a name="ln4359">        eep-&gt;modal_header_5g.ant_ctrl_chain[i] = word;</a>
<a name="ln4360">    }</a>
<a name="ln4361">}</a>
<a name="ln4362"> </a>
<a name="ln4363">void ar9300_eeprom_template_swap(void)</a>
<a name="ln4364">{</a>
<a name="ln4365">    int it;</a>
<a name="ln4366">    ar9300_eeprom_t *dptr;</a>
<a name="ln4367"> </a>
<a name="ln4368">    for (it = 0; it &lt; ARRAY_LENGTH(default9300); it++) {</a>
<a name="ln4369">        dptr = ar9300_eeprom_struct_default(it);</a>
<a name="ln4370">        if (dptr != 0) {</a>
<a name="ln4371">            ar9300_swap_eeprom(dptr);</a>
<a name="ln4372">        }</a>
<a name="ln4373">    }</a>
<a name="ln4374">}</a>
<a name="ln4375">#endif</a>
<a name="ln4376"> </a>
<a name="ln4377"> </a>
<a name="ln4378">/*</a>
<a name="ln4379"> * Restore the configuration structure by reading the eeprom.</a>
<a name="ln4380"> * This function destroys any existing in-memory structure content.</a>
<a name="ln4381"> */</a>
<a name="ln4382">HAL_BOOL</a>
<a name="ln4383">ar9300_eeprom_restore(struct ath_hal *ah)</a>
<a name="ln4384">{</a>
<a name="ln4385">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4386">    ar9300_eeprom_t *mptr;</a>
<a name="ln4387">    int mdata_size;</a>
<a name="ln4388">    HAL_BOOL status = AH_FALSE;</a>
<a name="ln4389"> </a>
<a name="ln4390">    mptr = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln4391">    mdata_size = ar9300_eeprom_struct_size();</a>
<a name="ln4392"> </a>
<a name="ln4393">    if (mptr != 0 &amp;&amp; mdata_size &gt; 0) {</a>
<a name="ln4394">#if AH_BYTE_ORDER == AH_BIG_ENDIAN</a>
<a name="ln4395">        ar9300_eeprom_template_swap();</a>
<a name="ln4396">        ar9300_swap_eeprom(mptr);</a>
<a name="ln4397">#endif</a>
<a name="ln4398">        /*</a>
<a name="ln4399">         * At this point, mptr points to the eeprom data structure</a>
<a name="ln4400">         * in its &quot;default&quot; state.  If this is big endian, swap the</a>
<a name="ln4401">         * data structures back to &quot;little endian&quot; form.</a>
<a name="ln4402">         */</a>
<a name="ln4403">        if (ar9300_eeprom_restore_internal(ah, mptr, mdata_size) &gt;= 0) {</a>
<a name="ln4404">            status = AH_TRUE;</a>
<a name="ln4405">        }</a>
<a name="ln4406"> </a>
<a name="ln4407">#if AH_BYTE_ORDER == AH_BIG_ENDIAN</a>
<a name="ln4408">        /* Second Swap, back to Big Endian */</a>
<a name="ln4409">        ar9300_eeprom_template_swap();</a>
<a name="ln4410">        ar9300_swap_eeprom(mptr);</a>
<a name="ln4411">#endif</a>
<a name="ln4412"> </a>
<a name="ln4413">    }</a>
<a name="ln4414">    ahp-&gt;ah_2g_paprd_rate_mask_ht40 =</a>
<a name="ln4415">        mptr-&gt;modal_header_2g.paprd_rate_mask_ht40;</a>
<a name="ln4416">    ahp-&gt;ah_2g_paprd_rate_mask_ht20 =</a>
<a name="ln4417">        mptr-&gt;modal_header_2g.paprd_rate_mask_ht20;</a>
<a name="ln4418">    ahp-&gt;ah_5g_paprd_rate_mask_ht40 =</a>
<a name="ln4419">        mptr-&gt;modal_header_5g.paprd_rate_mask_ht40;</a>
<a name="ln4420">    ahp-&gt;ah_5g_paprd_rate_mask_ht20 =</a>
<a name="ln4421">        mptr-&gt;modal_header_5g.paprd_rate_mask_ht20;</a>
<a name="ln4422">    return status;</a>
<a name="ln4423">}</a>
<a name="ln4424"> </a>
<a name="ln4425">int32_t ar9300_thermometer_get(struct ath_hal *ah)</a>
<a name="ln4426">{</a>
<a name="ln4427">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4428">    int thermometer;</a>
<a name="ln4429">    thermometer =</a>
<a name="ln4430">        (ahp-&gt;ah_eeprom.base_eep_header.misc_configuration &gt;&gt; 1) &amp; 0x3;</a>
<a name="ln4431">    thermometer--;</a>
<a name="ln4432">    return thermometer;</a>
<a name="ln4433">}</a>
<a name="ln4434"> </a>
<a name="ln4435">HAL_BOOL ar9300_thermometer_apply(struct ath_hal *ah)</a>
<a name="ln4436">{</a>
<a name="ln4437">    int thermometer = ar9300_thermometer_get(ah);</a>
<a name="ln4438"> </a>
<a name="ln4439">/* ch0_RXTX4 */</a>
<a name="ln4440">/*#define AR_PHY_65NM_CH0_RXTX4       AR_PHY_65NM(ch0_RXTX4)*/</a>
<a name="ln4441">#define AR_PHY_65NM_CH1_RXTX4       AR_PHY_65NM(ch1_RXTX4)</a>
<a name="ln4442">#define AR_PHY_65NM_CH2_RXTX4       AR_PHY_65NM(ch2_RXTX4)</a>
<a name="ln4443">/*#define AR_PHY_65NM_CH0_RXTX4_THERM_ON          0x10000000*/</a>
<a name="ln4444">/*#define AR_PHY_65NM_CH0_RXTX4_THERM_ON_S        28*/</a>
<a name="ln4445">#define AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR_S      29</a>
<a name="ln4446">#define AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR        \</a>
<a name="ln4447">    (0x1&lt;&lt;AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR_S)</a>
<a name="ln4448"> </a>
<a name="ln4449">    if (thermometer &lt; 0) {</a>
<a name="ln4450">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln4451">            AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, 0);</a>
<a name="ln4452">        if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah)) {</a>
<a name="ln4453">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4454">                AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, 0);</a>
<a name="ln4455">            if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah)  ) {</a>
<a name="ln4456">                OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4,</a>
<a name="ln4457">                    AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, 0);</a>
<a name="ln4458">            }</a>
<a name="ln4459">        }</a>
<a name="ln4460">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln4461">            AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4462">        if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah)) {</a>
<a name="ln4463">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4464">                AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4465">            if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah) ) {</a>
<a name="ln4466">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln4467">                    AR_PHY_65NM_CH2_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4468">            }</a>
<a name="ln4469">        }</a>
<a name="ln4470">    } else {</a>
<a name="ln4471">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln4472">            AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, 1);</a>
<a name="ln4473">        if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah)) {</a>
<a name="ln4474">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4475">                AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, 1);</a>
<a name="ln4476">            if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah)  ) {</a>
<a name="ln4477">                OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4,</a>
<a name="ln4478">                    AR_PHY_65NM_CH0_RXTX4_THERM_ON_OVR, 1);</a>
<a name="ln4479">            }</a>
<a name="ln4480">        }</a>
<a name="ln4481">        if (thermometer == 0) {</a>
<a name="ln4482">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4483">                AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 1);</a>
<a name="ln4484">            if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah)) {</a>
<a name="ln4485">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln4486">                    AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4487">                if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah) ) {</a>
<a name="ln4488">                    OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4,</a>
<a name="ln4489">                        AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4490">                }</a>
<a name="ln4491">            }</a>
<a name="ln4492">        } else if (thermometer == 1) {</a>
<a name="ln4493">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4494">                AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4495">            if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah)) {</a>
<a name="ln4496">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln4497">                    AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 1);</a>
<a name="ln4498">                if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah) ) {</a>
<a name="ln4499">                    OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4,</a>
<a name="ln4500">                        AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4501">                }</a>
<a name="ln4502">            }</a>
<a name="ln4503">        } else if (thermometer == 2) {</a>
<a name="ln4504">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4505">                AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4506">            if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah)) {</a>
<a name="ln4507">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln4508">                    AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_CH0_RXTX4_THERM_ON, 0);</a>
<a name="ln4509">                if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah) ) {</a>
<a name="ln4510">                    OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4,</a>
<a name="ln4511">                        AR_PHY_65NM_CH0_RXTX4_THERM_ON, 1);</a>
<a name="ln4512">                }</a>
<a name="ln4513">            }</a>
<a name="ln4514">        }</a>
<a name="ln4515">    }</a>
<a name="ln4516">    return AH_TRUE;</a>
<a name="ln4517">}</a>
<a name="ln4518"> </a>
<a name="ln4519">static int32_t ar9300_tuning_caps_params_get(struct ath_hal *ah)</a>
<a name="ln4520">{</a>
<a name="ln4521">    int tuning_caps_params;</a>
<a name="ln4522">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln4523">    tuning_caps_params = eep-&gt;base_eep_header.params_for_tuning_caps[0];</a>
<a name="ln4524">    return tuning_caps_params;</a>
<a name="ln4525">}</a>
<a name="ln4526"> </a>
<a name="ln4527">/*</a>
<a name="ln4528"> * Read the tuning caps params from eeprom and set to correct register.</a>
<a name="ln4529"> * To regulation the frequency accuracy.</a>
<a name="ln4530"> */</a>
<a name="ln4531">HAL_BOOL ar9300_tuning_caps_apply(struct ath_hal *ah)</a>
<a name="ln4532">{</a>
<a name="ln4533">    int tuning_caps_params;</a>
<a name="ln4534">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln4535">    tuning_caps_params = ar9300_tuning_caps_params_get(ah);</a>
<a name="ln4536">    if ((eep-&gt;base_eep_header.feature_enable &amp; 0x40) &gt;&gt; 6) {</a>
<a name="ln4537">        tuning_caps_params &amp;= 0x7f;</a>
<a name="ln4538"> </a>
<a name="ln4539">        if (AR_SREV_POSEIDON(ah) || AR_SREV_WASP(ah) || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln4540">            return true;</a>
<a name="ln4541">        } else if (AR_SREV_HORNET(ah)) {</a>
<a name="ln4542">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4543">                AR_HORNET_CH0_XTAL, AR_OSPREY_CHO_XTAL_CAPINDAC,</a>
<a name="ln4544">                tuning_caps_params);</a>
<a name="ln4545">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4546">                AR_HORNET_CH0_XTAL, AR_OSPREY_CHO_XTAL_CAPOUTDAC,</a>
<a name="ln4547">                tuning_caps_params);</a>
<a name="ln4548">        } else if (AR_SREV_SCORPION(ah)) {</a>
<a name="ln4549">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4550">                AR_SCORPION_CH0_XTAL, AR_OSPREY_CHO_XTAL_CAPINDAC,</a>
<a name="ln4551">                tuning_caps_params);</a>
<a name="ln4552">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4553">                AR_SCORPION_CH0_XTAL, AR_OSPREY_CHO_XTAL_CAPOUTDAC,</a>
<a name="ln4554">                tuning_caps_params);</a>
<a name="ln4555">        } else {</a>
<a name="ln4556">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4557">                AR_OSPREY_CH0_XTAL, AR_OSPREY_CHO_XTAL_CAPINDAC,</a>
<a name="ln4558">                tuning_caps_params);</a>
<a name="ln4559">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4560">                AR_OSPREY_CH0_XTAL, AR_OSPREY_CHO_XTAL_CAPOUTDAC,</a>
<a name="ln4561">                tuning_caps_params);</a>
<a name="ln4562">        }</a>
<a name="ln4563"> </a>
<a name="ln4564">    }</a>
<a name="ln4565">    return AH_TRUE;</a>
<a name="ln4566">}</a>
<a name="ln4567"> </a>
<a name="ln4568">/*</a>
<a name="ln4569"> * Read the tx_frame_to_xpa_on param from eeprom and apply the value to </a>
<a name="ln4570"> * correct register.</a>
<a name="ln4571"> */</a>
<a name="ln4572">HAL_BOOL ar9300_xpa_timing_control_apply(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln4573">{</a>
<a name="ln4574">    u_int8_t xpa_timing_control;</a>
<a name="ln4575">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln4576">    if ((eep-&gt;base_eep_header.feature_enable &amp; 0x80) &gt;&gt; 7) {</a>
<a name="ln4577">		if (AR_SREV_OSPREY(ah) || AR_SREV_AR9580(ah) || AR_SREV_WASP(ah) || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln4578">			if (is_2ghz) {</a>
<a name="ln4579">                xpa_timing_control = eep-&gt;modal_header_2g.tx_frame_to_xpa_on;</a>
<a name="ln4580">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln4581">						AR_PHY_XPA_TIMING_CTL, AR_PHY_XPA_TIMING_CTL_FRAME_XPAB_ON,</a>
<a name="ln4582">						xpa_timing_control);</a>
<a name="ln4583">			} else {</a>
<a name="ln4584">                xpa_timing_control = eep-&gt;modal_header_5g.tx_frame_to_xpa_on;</a>
<a name="ln4585">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln4586">						AR_PHY_XPA_TIMING_CTL, AR_PHY_XPA_TIMING_CTL_FRAME_XPAA_ON,</a>
<a name="ln4587">						xpa_timing_control);</a>
<a name="ln4588">			}</a>
<a name="ln4589">		}</a>
<a name="ln4590">	}</a>
<a name="ln4591">    return AH_TRUE;</a>
<a name="ln4592">}</a>
<a name="ln4593"> </a>
<a name="ln4594"> </a>
<a name="ln4595">/*</a>
<a name="ln4596"> * Read the xLNA_bias_strength param from eeprom and apply the value to </a>
<a name="ln4597"> * correct register.</a>
<a name="ln4598"> */ </a>
<a name="ln4599">HAL_BOOL ar9300_x_lNA_bias_strength_apply(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln4600">{</a>
<a name="ln4601">    u_int8_t x_lNABias;</a>
<a name="ln4602">    u_int32_t value = 0;</a>
<a name="ln4603">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln4604"> </a>
<a name="ln4605">    if ((eep-&gt;base_eep_header.misc_configuration &amp; 0x40) &gt;&gt; 6) {</a>
<a name="ln4606">        if (AR_SREV_OSPREY(ah)) {</a>
<a name="ln4607">            if (is_2ghz) {</a>
<a name="ln4608">                x_lNABias = eep-&gt;modal_header_2g.xLNA_bias_strength;</a>
<a name="ln4609">            } else {</a>
<a name="ln4610">                x_lNABias = eep-&gt;modal_header_5g.xLNA_bias_strength;</a>
<a name="ln4611">            }</a>
<a name="ln4612">            value = x_lNABias &amp; ( 0x03 );	// bit0,1 for chain0</a>
<a name="ln4613">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4614">					AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS, value);</a>
<a name="ln4615">            value = (x_lNABias &gt;&gt; 2) &amp; ( 0x03 );	// bit2,3 for chain1</a>
<a name="ln4616">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4617">					AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS, value);</a>
<a name="ln4618">            value = (x_lNABias &gt;&gt; 4) &amp; ( 0x03 );	// bit4,5 for chain2</a>
<a name="ln4619">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln4620">					AR_PHY_65NM_CH2_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS, value);</a>
<a name="ln4621">        }</a>
<a name="ln4622">    }</a>
<a name="ln4623">    return AH_TRUE;</a>
<a name="ln4624">}</a>
<a name="ln4625"> </a>
<a name="ln4626"> </a>
<a name="ln4627">/*</a>
<a name="ln4628"> * Read EEPROM header info and program the device for correct operation</a>
<a name="ln4629"> * given the channel value.</a>
<a name="ln4630"> */</a>
<a name="ln4631">HAL_BOOL</a>
<a name="ln4632">ar9300_eeprom_set_board_values(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln4633">{</a>
<a name="ln4634">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln4635"> </a>
<a name="ln4636">    ar9300_xpa_bias_level_apply(ah, IEEE80211_IS_CHAN_2GHZ(chan));</a>
<a name="ln4637"> </a>
<a name="ln4638">    ar9300_xpa_timing_control_apply(ah, IEEE80211_IS_CHAN_2GHZ(chan));</a>
<a name="ln4639"> </a>
<a name="ln4640">    ar9300_ant_ctrl_apply(ah, IEEE80211_IS_CHAN_2GHZ(chan));</a>
<a name="ln4641">    ar9300_drive_strength_apply(ah);</a>
<a name="ln4642"> </a>
<a name="ln4643">    ar9300_x_lNA_bias_strength_apply(ah, IEEE80211_IS_CHAN_2GHZ(chan));</a>
<a name="ln4644"> </a>
<a name="ln4645">	/* wait for Poseidon internal regular turnning */</a>
<a name="ln4646">    /* for Hornet we move it before initPLL to avoid an access issue */</a>
<a name="ln4647">    /* Function not used when EMULATION. */</a>
<a name="ln4648">    if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln4649">        ar9300_internal_regulator_apply(ah);</a>
<a name="ln4650">    }</a>
<a name="ln4651"> </a>
<a name="ln4652">    ar9300_attenuation_apply(ah, ichan-&gt;channel);</a>
<a name="ln4653">    ar9300_quick_drop_apply(ah, ichan-&gt;channel);</a>
<a name="ln4654">    ar9300_thermometer_apply(ah);</a>
<a name="ln4655">    if(!AR_SREV_WASP(ah))</a>
<a name="ln4656">    {</a>
<a name="ln4657">        ar9300_tuning_caps_apply(ah);</a>
<a name="ln4658">    }</a>
<a name="ln4659"> </a>
<a name="ln4660">    ar9300_tx_end_to_xpab_off_apply(ah, ichan-&gt;channel);</a>
<a name="ln4661"> </a>
<a name="ln4662">    return AH_TRUE;</a>
<a name="ln4663">}</a>
<a name="ln4664"> </a>
<a name="ln4665">u_int8_t *</a>
<a name="ln4666">ar9300_eeprom_get_spur_chans_ptr(struct ath_hal *ah, HAL_BOOL is_2ghz)</a>
<a name="ln4667">{</a>
<a name="ln4668">    ar9300_eeprom_t *eep = &amp;AH9300(ah)-&gt;ah_eeprom;</a>
<a name="ln4669"> </a>
<a name="ln4670">    if (is_2ghz) {</a>
<a name="ln4671">        return &amp;(eep-&gt;modal_header_2g.spur_chans[0]);</a>
<a name="ln4672">    } else {</a>
<a name="ln4673">        return &amp;(eep-&gt;modal_header_5g.spur_chans[0]);</a>
<a name="ln4674">    }</a>
<a name="ln4675">}</a>
<a name="ln4676"> </a>
<a name="ln4677">static u_int8_t ar9300_eeprom_get_tx_gain_table_number_max(struct ath_hal *ah)</a>
<a name="ln4678">{</a>
<a name="ln4679">    unsigned long tx_gain_table_max;</a>
<a name="ln4680">    tx_gain_table_max = OS_REG_READ_FIELD(ah,</a>
<a name="ln4681">        AR_PHY_TPC_7, AR_PHY_TPC_7_TX_GAIN_TABLE_MAX);</a>
<a name="ln4682">    return tx_gain_table_max;</a>
<a name="ln4683">}</a>
<a name="ln4684"> </a>
<a name="ln4685">u_int8_t ar9300_eeprom_tx_gain_table_index_max_apply(struct ath_hal *ah, u_int16_t channel)</a>
<a name="ln4686">{</a>
<a name="ln4687">    unsigned int index;</a>
<a name="ln4688">    ar9300_eeprom_t *ahp_Eeprom;</a>
<a name="ln4689">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4690"> </a>
<a name="ln4691">    ahp_Eeprom = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln4692"> </a>
<a name="ln4693">    if (ahp_Eeprom-&gt;base_ext1.misc_enable == 0)</a>
<a name="ln4694">        return AH_FALSE;</a>
<a name="ln4695"> </a>
<a name="ln4696">    if (channel &lt; 4000) </a>
<a name="ln4697">    {</a>
<a name="ln4698">        index = ahp_Eeprom-&gt;modal_header_2g.tx_gain_cap;</a>
<a name="ln4699">    }</a>
<a name="ln4700">    else</a>
<a name="ln4701">    {</a>
<a name="ln4702">        index = ahp_Eeprom-&gt;modal_header_5g.tx_gain_cap;</a>
<a name="ln4703">    }</a>
<a name="ln4704"> </a>
<a name="ln4705">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln4706">        AR_PHY_TPC_7, AR_PHY_TPC_7_TX_GAIN_TABLE_MAX, index);</a>
<a name="ln4707">    return AH_TRUE;</a>
<a name="ln4708">}</a>
<a name="ln4709"> </a>
<a name="ln4710">static u_int8_t ar9300_eeprom_get_pcdac_tx_gain_table_i(struct ath_hal *ah, </a>
<a name="ln4711">                                               int i, u_int8_t *pcdac)</a>
<a name="ln4712">{</a>
<a name="ln4713">    unsigned long tx_gain;</a>
<a name="ln4714">    u_int8_t tx_gain_table_max;</a>
<a name="ln4715">    tx_gain_table_max = ar9300_eeprom_get_tx_gain_table_number_max(ah);</a>
<a name="ln4716">    if (i &lt;= 0 || i &gt; tx_gain_table_max) {</a>
<a name="ln4717">        *pcdac = 0;</a>
<a name="ln4718">        return AH_FALSE;</a>
<a name="ln4719">    }</a>
<a name="ln4720"> </a>
<a name="ln4721">    tx_gain = OS_REG_READ(ah, AR_PHY_TXGAIN_TAB(1) + i * 4);</a>
<a name="ln4722">    *pcdac = ((tx_gain &gt;&gt; 24) &amp; 0xff);</a>
<a name="ln4723">    return AH_TRUE;</a>
<a name="ln4724">}</a>
<a name="ln4725"> </a>
<a name="ln4726">u_int8_t ar9300_eeprom_set_tx_gain_cap(struct ath_hal *ah, </a>
<a name="ln4727">                                               int *tx_gain_max)</a>
<a name="ln4728">// pcdac read back from reg, read back value depends on reset 2GHz/5GHz ini </a>
<a name="ln4729">// tx_gain_table, this function will be called twice after each </a>
<a name="ln4730">// band's calibration.</a>
<a name="ln4731">// after 2GHz cal, tx_gain_max[0] has 2GHz, calibration max txgain, </a>
<a name="ln4732">// tx_gain_max[1]=-100</a>
<a name="ln4733">// after 5GHz cal, tx_gain_max[0],tx_gain_max[1] have calibration </a>
<a name="ln4734">// value for both band</a>
<a name="ln4735">// reset is on 5GHz, reg reading from tx_gain_table is for 5GHz,</a>
<a name="ln4736">// so program can't recalculate 2g.tx_gain_cap at this point.</a>
<a name="ln4737">{</a>
<a name="ln4738">    int i = 0, ig, im = 0;</a>
<a name="ln4739">    u_int8_t pcdac = 0;</a>
<a name="ln4740">    u_int8_t tx_gain_table_max;</a>
<a name="ln4741">    ar9300_eeprom_t *ahp_Eeprom;</a>
<a name="ln4742">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4743"> </a>
<a name="ln4744">    ahp_Eeprom = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln4745"> </a>
<a name="ln4746">    if (ahp_Eeprom-&gt;base_ext1.misc_enable == 0)</a>
<a name="ln4747">        return AH_FALSE;</a>
<a name="ln4748"> </a>
<a name="ln4749">    tx_gain_table_max = ar9300_eeprom_get_tx_gain_table_number_max(ah);</a>
<a name="ln4750"> </a>
<a name="ln4751">    for (i = 0; i &lt; 2; i++) {</a>
<a name="ln4752">        if (tx_gain_max[i]&gt;-100) {	// -100 didn't cal that band.</a>
<a name="ln4753">            if ( i== 0) {</a>
<a name="ln4754">                if (tx_gain_max[1]&gt;-100) {</a>
<a name="ln4755">                    continue;</a>
<a name="ln4756">                    // both band are calibrated, skip 2GHz 2g.tx_gain_cap reset</a>
<a name="ln4757">                }</a>
<a name="ln4758">            }</a>
<a name="ln4759">            for (ig = 1; ig &lt;= tx_gain_table_max; ig++) {</a>
<a name="ln4760">                if (ah != 0 &amp;&amp; ah-&gt;ah_reset != 0)</a>
<a name="ln4761">                {</a>
<a name="ln4762">                    ar9300_eeprom_get_pcdac_tx_gain_table_i(ah, ig, &amp;pcdac);</a>
<a name="ln4763">                    if (pcdac &gt;= tx_gain_max[i])</a>
<a name="ln4764">                        break;</a>
<a name="ln4765">                }</a>
<a name="ln4766">            }</a>
<a name="ln4767">            if (ig+1 &lt;= tx_gain_table_max) {</a>
<a name="ln4768">                if (pcdac == tx_gain_max[i])</a>
<a name="ln4769">                    im = ig;</a>
<a name="ln4770">                else</a>
<a name="ln4771">                    im = ig + 1;</a>
<a name="ln4772">                if (i == 0) {</a>
<a name="ln4773">                    ahp_Eeprom-&gt;modal_header_2g.tx_gain_cap = im;</a>
<a name="ln4774">                } else {</a>
<a name="ln4775">                    ahp_Eeprom-&gt;modal_header_5g.tx_gain_cap = im;</a>
<a name="ln4776">                }</a>
<a name="ln4777">            } else {</a>
<a name="ln4778">                if (i == 0) {</a>
<a name="ln4779">                    ahp_Eeprom-&gt;modal_header_2g.tx_gain_cap = ig;</a>
<a name="ln4780">                } else {</a>
<a name="ln4781">                    ahp_Eeprom-&gt;modal_header_5g.tx_gain_cap = ig;</a>
<a name="ln4782">                }</a>
<a name="ln4783">            }</a>
<a name="ln4784">        }</a>
<a name="ln4785">    }</a>
<a name="ln4786">    return AH_TRUE;</a>
<a name="ln4787">}</a>

</code></pre>
<div class="balloon" rel="179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'nptr < 0' is always true.</p></div>
<div class="balloon" rel="3063"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The right operand ('i' = [0..35]) is greater than or equal to the length in bits of the promoted left operand.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
