
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>hda_codec.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2012, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Ithamar Adema, ithamar AT unet DOT nl</a>
<a name="ln7"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln8"> *		Jérôme Duval, korli@users.berlios.de</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;driver.h&quot;</a>
<a name="ln13">#include &quot;hda_codec_defs.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15"> </a>
<a name="ln16">#undef TRACE</a>
<a name="ln17">#define TRACE_CODEC</a>
<a name="ln18">#ifdef TRACE_CODEC</a>
<a name="ln19">#	define TRACE(a...) dprintf(&quot;hda: &quot; a)</a>
<a name="ln20">#else</a>
<a name="ln21">#	define TRACE(a...)</a>
<a name="ln22">#endif</a>
<a name="ln23">#define ERROR(a...) dprintf(&quot;hda: &quot; a)</a>
<a name="ln24"> </a>
<a name="ln25"> </a>
<a name="ln26">#define HDA_ALL 0xffffffff</a>
<a name="ln27">#define HDA_QUIRK_GPIO_COUNT	8</a>
<a name="ln28">#define HDA_QUIRK_GPIO0		(1 &lt;&lt; 0)</a>
<a name="ln29">#define HDA_QUIRK_GPIO1		(1 &lt;&lt; 1)</a>
<a name="ln30">#define HDA_QUIRK_GPIO2		(1 &lt;&lt; 2)</a>
<a name="ln31">#define HDA_QUIRK_GPIO3		(1 &lt;&lt; 3)</a>
<a name="ln32">#define HDA_QUIRK_GPIO4		(1 &lt;&lt; 4)</a>
<a name="ln33">#define HDA_QUIRK_GPIO5		(1 &lt;&lt; 5)</a>
<a name="ln34">#define HDA_QUIRK_GPIO6		(1 &lt;&lt; 6)</a>
<a name="ln35">#define HDA_QUIRK_GPIO7		(1 &lt;&lt; 7)</a>
<a name="ln36">#define HDA_QUIRK_IVREF50	(1 &lt;&lt; 8)</a>
<a name="ln37">#define HDA_QUIRK_IVREF80	(1 &lt;&lt; 9)</a>
<a name="ln38">#define HDA_QUIRK_IVREF100	(1 &lt;&lt; 10)</a>
<a name="ln39">#define HDA_QUIRK_OVREF50	(1 &lt;&lt; 11)</a>
<a name="ln40">#define HDA_QUIRK_OVREF80	(1 &lt;&lt; 12)</a>
<a name="ln41">#define HDA_QUIRK_OVREF100	(1 &lt;&lt; 13)</a>
<a name="ln42">#define HDA_QUIRK_IVREF (HDA_QUIRK_IVREF50 | HDA_QUIRK_IVREF80 \</a>
<a name="ln43">	| HDA_QUIRK_IVREF100)</a>
<a name="ln44">#define HDA_QUIRK_OVREF (HDA_QUIRK_OVREF50 | HDA_QUIRK_OVREF80 \</a>
<a name="ln45">	| HDA_QUIRK_OVREF100)</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">#define ANALOGDEVICES_VENDORID		0x11d4</a>
<a name="ln49">#define CIRRUSLOGIC_VENDORID		0x1013</a>
<a name="ln50">#define CONEXANT_VENDORID			0x14f1</a>
<a name="ln51">#define IDT_VENDORID				0x111d</a>
<a name="ln52">#define REALTEK_VENDORID			0x10ec</a>
<a name="ln53">#define SIGMATEL_VENDORID			0x8384</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">static const char* kPortConnector[] = {</a>
<a name="ln57">	&quot;Jack&quot;, &quot;None&quot;, &quot;Fixed&quot;, &quot;Dual&quot;</a>
<a name="ln58">};</a>
<a name="ln59"> </a>
<a name="ln60">static const char* kDefaultDevice[] = {</a>
<a name="ln61">	&quot;Line out&quot;, &quot;Speaker&quot;, &quot;HP out&quot;, &quot;CD&quot;, &quot;SPDIF out&quot;, &quot;Digital other out&quot;,</a>
<a name="ln62">	&quot;Modem line side&quot;, &quot;Modem hand side&quot;, &quot;Line in&quot;, &quot;AUX&quot;, &quot;Mic in&quot;,</a>
<a name="ln63">	&quot;Telephony&quot;, &quot;SPDIF in&quot;, &quot;Digital other in&quot;, &quot;Reserved&quot;, &quot;Other&quot;</a>
<a name="ln64">};</a>
<a name="ln65"> </a>
<a name="ln66">static const char* kConnectionType[] = {</a>
<a name="ln67">	&quot;N/A&quot;, &quot;1/8\&quot;&quot;, &quot;1/4\&quot;&quot;, &quot;ATAPI internal&quot;, &quot;RCA&quot;, &quot;Optical&quot;,</a>
<a name="ln68">	&quot;Other digital&quot;, &quot;Other analog&quot;, &quot;Multichannel analog (DIN)&quot;,</a>
<a name="ln69">	&quot;XLR/Professional&quot;, &quot;RJ-11 (modem)&quot;, &quot;Combination&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;Other&quot;</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72">static const char* kJackColor[] = {</a>
<a name="ln73">	&quot;N/A&quot;, &quot;Black&quot;, &quot;Grey&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Red&quot;, &quot;Orange&quot;, &quot;Yellow&quot;,</a>
<a name="ln74">	&quot;Purple&quot;, &quot;Pink&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;White&quot;, &quot;Other&quot;</a>
<a name="ln75">};</a>
<a name="ln76"> </a>
<a name="ln77">static const struct {</a>
<a name="ln78">	uint32 subsystem_vendor_id, subsystem_id;</a>
<a name="ln79">	uint32 codec_vendor_id, codec_id;</a>
<a name="ln80">	uint32 quirks, nonquirks;</a>
<a name="ln81">} kCodecQuirks[] = {</a>
<a name="ln82">	{ HDA_ALL, HDA_ALL, HDA_ALL, HDA_ALL, HDA_QUIRK_IVREF, 0 },</a>
<a name="ln83">	{ HDA_ALL, HDA_ALL, HDA_ALL, HDA_ALL, HDA_QUIRK_IVREF, 0 },</a>
<a name="ln84">	{ 0x10de, 0x0d94, CIRRUSLOGIC_VENDORID, HDA_ALL,</a>
<a name="ln85">		HDA_QUIRK_GPIO1 | HDA_QUIRK_GPIO3, 0 },		// MacBookAir 3,1(2)</a>
<a name="ln86">	{ 0x10de, 0xcb79, CIRRUSLOGIC_VENDORID, 0x4206,</a>
<a name="ln87">		HDA_QUIRK_GPIO1 | HDA_QUIRK_GPIO3, 0 },		// MacBook Pro 5,5</a>
<a name="ln88">	{ 0x10de, 0xcb89, CIRRUSLOGIC_VENDORID, 0x4206,</a>
<a name="ln89">		HDA_QUIRK_GPIO1 | HDA_QUIRK_GPIO3, 0 },		// MacBookPro 7,1</a>
<a name="ln90">	{ 0x8384, 0x7680, SIGMATEL_VENDORID, 0x7680,</a>
<a name="ln91">		HDA_QUIRK_GPIO0 | HDA_QUIRK_GPIO1, 0},		// Apple Intel Mac</a>
<a name="ln92">	{ 0x106b, 0x00a0, REALTEK_VENDORID, 0x0885,</a>
<a name="ln93">		HDA_QUIRK_GPIO0 | HDA_QUIRK_OVREF80, 0},	// iMac 8,1, Macbook Pro 3,1</a>
<a name="ln94">	{ 0x106b, 0x00a1, REALTEK_VENDORID, 0x0885,</a>
<a name="ln95">		HDA_QUIRK_GPIO0 | HDA_QUIRK_OVREF50, 0},	// MacBook</a>
<a name="ln96">	{ 0x106b, 0x00a3, REALTEK_VENDORID, 0x0885,</a>
<a name="ln97">		HDA_QUIRK_GPIO0, 0},						// MacBook</a>
<a name="ln98">	{ HDA_ALL, HDA_ALL, IDT_VENDORID, 0x76b2, HDA_QUIRK_GPIO0, 0},</a>
<a name="ln99">};</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">static const char*</a>
<a name="ln103">get_widget_type_name(hda_widget_type type)</a>
<a name="ln104">{</a>
<a name="ln105">	switch (type) {</a>
<a name="ln106">		case WT_AUDIO_OUTPUT:</a>
<a name="ln107">			return &quot;Audio output&quot;;</a>
<a name="ln108">		case WT_AUDIO_INPUT:</a>
<a name="ln109">			return &quot;Audio input&quot;;</a>
<a name="ln110">		case WT_AUDIO_MIXER:</a>
<a name="ln111">			return &quot;Audio mixer&quot;;</a>
<a name="ln112">		case WT_AUDIO_SELECTOR:</a>
<a name="ln113">			return &quot;Audio selector&quot;;</a>
<a name="ln114">		case WT_PIN_COMPLEX:</a>
<a name="ln115">			return &quot;Pin complex&quot;;</a>
<a name="ln116">		case WT_POWER:</a>
<a name="ln117">			return &quot;Power&quot;;</a>
<a name="ln118">		case WT_VOLUME_KNOB:</a>
<a name="ln119">			return &quot;Volume knob&quot;;</a>
<a name="ln120">		case WT_BEEP_GENERATOR:</a>
<a name="ln121">			return &quot;Beep generator&quot;;</a>
<a name="ln122">		case WT_VENDOR_DEFINED:</a>
<a name="ln123">			return &quot;Vendor defined&quot;;</a>
<a name="ln124">		default:</a>
<a name="ln125">			return &quot;Unknown&quot;;</a>
<a name="ln126">	}</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">const char*</a>
<a name="ln131">get_widget_location(uint32 location)</a>
<a name="ln132">{</a>
<a name="ln133">	switch (location &gt;&gt; 4) {</a>
<a name="ln134">		case 0:</a>
<a name="ln135">		case 2:</a>
<a name="ln136">			switch (location &amp; 0xf) {</a>
<a name="ln137">				case 2:</a>
<a name="ln138">					return &quot;Front&quot;;</a>
<a name="ln139">				case 3:</a>
<a name="ln140">					return &quot;Left&quot;;</a>
<a name="ln141">				case 4:</a>
<a name="ln142">					return &quot;Right&quot;;</a>
<a name="ln143">				case 5:</a>
<a name="ln144">					return &quot;Top&quot;;</a>
<a name="ln145">				case 6:</a>
<a name="ln146">					return &quot;Bottom&quot;;</a>
<a name="ln147">				case 7:</a>
<a name="ln148">					return &quot;Rear panel&quot;;</a>
<a name="ln149">				case 8:</a>
<a name="ln150">					return &quot;Drive bay&quot;;</a>
<a name="ln151">				case 0:</a>
<a name="ln152">				case 1:</a>
<a name="ln153">				default:</a>
<a name="ln154">					return NULL;</a>
<a name="ln155">			}</a>
<a name="ln156">		case 1:</a>
<a name="ln157">			switch (location &amp; 0xf) {</a>
<a name="ln158">				case 7:</a>
<a name="ln159">					return &quot;Riser&quot;;</a>
<a name="ln160">				case 8:</a>
<a name="ln161">					return &quot;HDMI&quot;;</a>
<a name="ln162">				default:</a>
<a name="ln163">					return NULL;</a>
<a name="ln164">			}</a>
<a name="ln165">		case 3:</a>
<a name="ln166">			switch (location &amp; 0xf) {</a>
<a name="ln167">				case 6:</a>
<a name="ln168">					return &quot;Bottom&quot;;</a>
<a name="ln169">				case 7:</a>
<a name="ln170">					return &quot;Inside lid&quot;;</a>
<a name="ln171">				case 8:</a>
<a name="ln172">					return &quot;Outside lid&quot;;</a>
<a name="ln173">				default:</a>
<a name="ln174">					return NULL;</a>
<a name="ln175">			}</a>
<a name="ln176">	}</a>
<a name="ln177">	return NULL;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">static void</a>
<a name="ln182">dump_widget_audio_capabilities(uint32 capabilities)</a>
<a name="ln183">{</a>
<a name="ln184">	static const struct {</a>
<a name="ln185">		uint32		flag;</a>
<a name="ln186">		const char*	name;</a>
<a name="ln187">	} kFlags[] = {</a>
<a name="ln188">		{AUDIO_CAP_CP_CAPS, &quot;CP caps&quot;},</a>
<a name="ln189">		{AUDIO_CAP_LEFT_RIGHT_SWAP, &quot;L-R swap&quot;},</a>
<a name="ln190">		{AUDIO_CAP_POWER_CONTROL, &quot;Power&quot;},</a>
<a name="ln191">		{AUDIO_CAP_DIGITAL, &quot;Digital&quot;},</a>
<a name="ln192">		{AUDIO_CAP_CONNECTION_LIST, &quot;Conn. list&quot;},</a>
<a name="ln193">		{AUDIO_CAP_UNSOLICITED_RESPONSES, &quot;Unsol. responses&quot;},</a>
<a name="ln194">		{AUDIO_CAP_PROCESSING_CONTROLS, &quot;Proc widget&quot;},</a>
<a name="ln195">		{AUDIO_CAP_STRIPE, &quot;Stripe&quot;},</a>
<a name="ln196">		{AUDIO_CAP_FORMAT_OVERRIDE, &quot;Format override&quot;},</a>
<a name="ln197">		{AUDIO_CAP_AMPLIFIER_OVERRIDE, &quot;Amplifier override&quot;},</a>
<a name="ln198">		{AUDIO_CAP_OUTPUT_AMPLIFIER, &quot;Out amplifier&quot;},</a>
<a name="ln199">		{AUDIO_CAP_INPUT_AMPLIFIER, &quot;In amplifier&quot;},</a>
<a name="ln200">		{AUDIO_CAP_STEREO, &quot;Stereo&quot;},</a>
<a name="ln201">	};</a>
<a name="ln202"> </a>
<a name="ln203">	char buffer[256];</a>
<a name="ln204">	int offset = 0;</a>
<a name="ln205"> </a>
<a name="ln206">	for (uint32 j = 0; j &lt; sizeof(kFlags) / sizeof(kFlags[0]); j++) {</a>
<a name="ln207">		if ((capabilities &amp; kFlags[j].flag) != 0)</a>
<a name="ln208">			offset += sprintf(buffer + offset, &quot;[%s] &quot;, kFlags[j].name);</a>
<a name="ln209">	}</a>
<a name="ln210"> </a>
<a name="ln211">	if (offset != 0)</a>
<a name="ln212">		TRACE(&quot;\t%s\n&quot;, buffer);</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215"> </a>
<a name="ln216">static void</a>
<a name="ln217">dump_widget_inputs(hda_widget&amp; widget)</a>
<a name="ln218">{</a>
<a name="ln219">	// dump connections</a>
<a name="ln220"> </a>
<a name="ln221">	char buffer[256];</a>
<a name="ln222">	int offset = 0;</a>
<a name="ln223"> </a>
<a name="ln224">	for (uint32 i = 0; i &lt; widget.num_inputs; i++) {</a>
<a name="ln225">		int32 input = widget.inputs[i];</a>
<a name="ln226"> </a>
<a name="ln227">		if ((int32)i != widget.active_input)</a>
<a name="ln228">			offset += sprintf(buffer + offset, &quot;%ld &quot;, input);</a>
<a name="ln229">		else</a>
<a name="ln230">			offset += sprintf(buffer + offset, &quot;&lt;%ld&gt; &quot;, input);</a>
<a name="ln231">	}</a>
<a name="ln232"> </a>
<a name="ln233">	if (offset != 0)</a>
<a name="ln234">		TRACE(&quot;\tInputs: %s\n&quot;, buffer);</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">static void</a>
<a name="ln239">dump_widget_amplifier_capabilities(hda_widget&amp; widget, bool input)</a>
<a name="ln240">{</a>
<a name="ln241">	uint32 capabilities;</a>
<a name="ln242">	if (input)</a>
<a name="ln243">		capabilities = widget.capabilities.input_amplifier;</a>
<a name="ln244">	else</a>
<a name="ln245">		capabilities = widget.capabilities.output_amplifier;</a>
<a name="ln246"> </a>
<a name="ln247">	if (capabilities == 0)</a>
<a name="ln248">		return;</a>
<a name="ln249"> </a>
<a name="ln250">	TRACE(&quot;\t%s Amp: %sstep size: %f dB, # steps: %ld, offset to 0 dB: &quot;</a>
<a name="ln251">		&quot;%ld\n&quot;, input ? &quot;In&quot; : &quot;Out&quot;,</a>
<a name="ln252">		(capabilities &amp; AMP_CAP_MUTE) != 0 ? &quot;supports mute, &quot; : &quot;&quot;,</a>
<a name="ln253">		AMP_CAP_STEP_SIZE(capabilities),</a>
<a name="ln254">		AMP_CAP_NUM_STEPS(capabilities),</a>
<a name="ln255">		AMP_CAP_OFFSET(capabilities));</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">static void</a>
<a name="ln260">dump_widget_pm_support(hda_widget&amp; widget)</a>
<a name="ln261">{</a>
<a name="ln262">	TRACE(&quot;\tSupported power states: %s%s%s%s%s%s%s%s\n&quot;,</a>
<a name="ln263">		widget.pm &amp; POWER_STATE_D0 ? &quot;D0 &quot; : &quot;&quot;,</a>
<a name="ln264">		widget.pm &amp; POWER_STATE_D1 ? &quot;D1 &quot; : &quot;&quot;,</a>
<a name="ln265">		widget.pm &amp; POWER_STATE_D2 ? &quot;D2 &quot; : &quot;&quot;,</a>
<a name="ln266">		widget.pm &amp; POWER_STATE_D3 ? &quot;D3 &quot; : &quot;&quot;,</a>
<a name="ln267">		widget.pm &amp; POWER_STATE_D3COLD ? &quot;D3COLD &quot; : &quot;&quot;,</a>
<a name="ln268">		widget.pm &amp; POWER_STATE_S3D3COLD ? &quot;S3D3COLD &quot; : &quot;&quot;,</a>
<a name="ln269">		widget.pm &amp; POWER_STATE_CLKSTOP ? &quot;CLKSTOP &quot; : &quot;&quot;,</a>
<a name="ln270">		widget.pm &amp; POWER_STATE_EPSS ? &quot;EPSS &quot; : &quot;&quot;);</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273"> </a>
<a name="ln274">static void</a>
<a name="ln275">dump_widget_stream_support(hda_widget&amp; widget)</a>
<a name="ln276">{</a>
<a name="ln277">	TRACE(&quot;\tSupported formats: %s%s%s%s%s%s%s%s%s\n&quot;,</a>
<a name="ln278">		widget.d.io.formats &amp; B_FMT_8BIT_S ? &quot;8bits &quot; : &quot;&quot;,</a>
<a name="ln279">		widget.d.io.formats &amp; B_FMT_16BIT ? &quot;16bits &quot; : &quot;&quot;,</a>
<a name="ln280">		widget.d.io.formats &amp; B_FMT_20BIT ? &quot;20bits &quot; : &quot;&quot;,</a>
<a name="ln281">		widget.d.io.formats &amp; B_FMT_24BIT ? &quot;24bits &quot; : &quot;&quot;,</a>
<a name="ln282">		widget.d.io.formats &amp; B_FMT_32BIT ? &quot;32bits &quot; : &quot;&quot;,</a>
<a name="ln283">		widget.d.io.formats &amp; B_FMT_FLOAT ? &quot;float &quot; : &quot;&quot;,</a>
<a name="ln284">		widget.d.io.formats &amp; B_FMT_DOUBLE ? &quot;double &quot; : &quot;&quot;,</a>
<a name="ln285">		widget.d.io.formats &amp; B_FMT_EXTENDED ? &quot;extended &quot; : &quot;&quot;,</a>
<a name="ln286">		widget.d.io.formats &amp; B_FMT_BITSTREAM ? &quot;bitstream &quot; : &quot;&quot;);</a>
<a name="ln287">	TRACE(&quot;\tSupported rates: %s%s%s%s%s%s%s%s%s%s%s%s\n&quot;,</a>
<a name="ln288">		widget.d.io.rates &amp; B_SR_8000 ? &quot;8khz &quot; : &quot;&quot;,</a>
<a name="ln289">		widget.d.io.rates &amp; B_SR_11025 ? &quot;11khz &quot; : &quot;&quot;,</a>
<a name="ln290">		widget.d.io.rates &amp; B_SR_16000 ? &quot;16khz &quot; : &quot;&quot;,</a>
<a name="ln291">		widget.d.io.rates &amp; B_SR_22050 ? &quot;22khz &quot; : &quot;&quot;,</a>
<a name="ln292">		widget.d.io.rates &amp; B_SR_32000 ? &quot;32khz &quot; : &quot;&quot;,</a>
<a name="ln293">		widget.d.io.rates &amp; B_SR_44100 ? &quot;44khz &quot; : &quot;&quot;,</a>
<a name="ln294">		widget.d.io.rates &amp; B_SR_48000 ? &quot;48khz &quot; : &quot;&quot;,</a>
<a name="ln295">		widget.d.io.rates &amp; B_SR_88200 ? &quot;88khz &quot; : &quot;&quot;,</a>
<a name="ln296">		widget.d.io.rates &amp; B_SR_96000 ? &quot;96khz &quot; : &quot;&quot;,</a>
<a name="ln297">		widget.d.io.rates &amp; B_SR_176400 ? &quot;176khz &quot; : &quot;&quot;,</a>
<a name="ln298">		widget.d.io.rates &amp; B_SR_192000 ? &quot;192khz &quot; : &quot;&quot;,</a>
<a name="ln299">		widget.d.io.rates &amp; B_SR_384000 ? &quot;384khz &quot; : &quot;&quot;);</a>
<a name="ln300"> </a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">static void</a>
<a name="ln305">dump_pin_complex_capabilities(hda_widget&amp; widget)</a>
<a name="ln306">{</a>
<a name="ln307">	TRACE(&quot;\t%s%s%s%s%s%s%s%s%s%s%s%s%s\n&quot;,</a>
<a name="ln308">		widget.d.pin.capabilities &amp; PIN_CAP_IMP_SENSE ? &quot;[Imp Sense] &quot; : &quot;&quot;,</a>
<a name="ln309">		widget.d.pin.capabilities &amp; PIN_CAP_TRIGGER_REQ ? &quot;[Trigger Req]&quot; : &quot;&quot;,</a>
<a name="ln310">		widget.d.pin.capabilities &amp; PIN_CAP_PRES_DETECT ? &quot;[Pres Detect]&quot; : &quot;&quot;,</a>
<a name="ln311">		widget.d.pin.capabilities &amp; PIN_CAP_HP_DRIVE ? &quot;[HP Drive]&quot; : &quot;&quot;,</a>
<a name="ln312">		widget.d.pin.capabilities &amp; PIN_CAP_OUTPUT ? &quot;[Output]&quot; : &quot;&quot;,</a>
<a name="ln313">		widget.d.pin.capabilities &amp; PIN_CAP_INPUT ? &quot;[Input]&quot; : &quot;&quot;,</a>
<a name="ln314">		widget.d.pin.capabilities &amp; PIN_CAP_BALANCE ? &quot;[Balance]&quot; : &quot;&quot;,</a>
<a name="ln315">		widget.d.pin.capabilities &amp; PIN_CAP_VREF_CTRL_HIZ ? &quot;[VRef HIZ]&quot; : &quot;&quot;,</a>
<a name="ln316">		widget.d.pin.capabilities &amp; PIN_CAP_VREF_CTRL_50 ? &quot;[VRef 50]&quot; : &quot;&quot;,</a>
<a name="ln317">		widget.d.pin.capabilities &amp; PIN_CAP_VREF_CTRL_GROUND ? &quot;[VRef Gr]&quot; : &quot;&quot;,</a>
<a name="ln318">		widget.d.pin.capabilities &amp; PIN_CAP_VREF_CTRL_80 ? &quot;[VRef 80]&quot; : &quot;&quot;,</a>
<a name="ln319">		widget.d.pin.capabilities &amp; PIN_CAP_VREF_CTRL_100 ? &quot;[VRef 100]&quot; : &quot;&quot;,</a>
<a name="ln320">		widget.d.pin.capabilities &amp; PIN_CAP_EAPD_CAP ? &quot;[EAPD]&quot; : &quot;&quot;);</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323"> </a>
<a name="ln324">static void</a>
<a name="ln325">dump_audiogroup_widgets(hda_audio_group* audioGroup)</a>
<a name="ln326">{</a>
<a name="ln327">	TRACE(&quot;\tAudiogroup:\n&quot;);</a>
<a name="ln328">	// Iterate over all widgets and collect info</a>
<a name="ln329">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count; i++) {</a>
<a name="ln330">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln331">		uint32 nodeID = audioGroup-&gt;widget_start + i;</a>
<a name="ln332"> </a>
<a name="ln333">		TRACE(&quot;%ld: %s\n&quot;, nodeID, get_widget_type_name(widget.type));</a>
<a name="ln334"> </a>
<a name="ln335">		switch (widget.type) {</a>
<a name="ln336">			case WT_AUDIO_OUTPUT:</a>
<a name="ln337">			case WT_AUDIO_INPUT:</a>
<a name="ln338">				break;</a>
<a name="ln339"> </a>
<a name="ln340">			case WT_PIN_COMPLEX:</a>
<a name="ln341">				dump_pin_complex_capabilities(widget);</a>
<a name="ln342">				break;</a>
<a name="ln343"> </a>
<a name="ln344">			default:</a>
<a name="ln345">				break;</a>
<a name="ln346">		}</a>
<a name="ln347"> </a>
<a name="ln348">		dump_widget_pm_support(widget);</a>
<a name="ln349">		dump_widget_audio_capabilities(widget.capabilities.audio);</a>
<a name="ln350">		dump_widget_amplifier_capabilities(widget, true);</a>
<a name="ln351">		dump_widget_amplifier_capabilities(widget, false);</a>
<a name="ln352">		dump_widget_inputs(widget);</a>
<a name="ln353">	}</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356"> </a>
<a name="ln357">//	#pragma mark -</a>
<a name="ln358"> </a>
<a name="ln359"> </a>
<a name="ln360">static void</a>
<a name="ln361">hda_codec_get_quirks(hda_codec* codec)</a>
<a name="ln362">{</a>
<a name="ln363">	codec-&gt;quirks = 0;</a>
<a name="ln364"> </a>
<a name="ln365">	uint32 subSystemID = codec-&gt;controller-&gt;pci_info.u.h0.subsystem_id;</a>
<a name="ln366">	uint32 subSystemVendorID</a>
<a name="ln367">		= codec-&gt;controller-&gt;pci_info.u.h0.subsystem_vendor_id;</a>
<a name="ln368"> </a>
<a name="ln369">	for (uint32 i = 0;</a>
<a name="ln370">			i &lt; (sizeof(kCodecQuirks) / sizeof(kCodecQuirks[0])); i++) {</a>
<a name="ln371">		if (kCodecQuirks[i].subsystem_id != HDA_ALL</a>
<a name="ln372">			&amp;&amp; kCodecQuirks[i].subsystem_id != subSystemID)</a>
<a name="ln373">			continue;</a>
<a name="ln374">		if (kCodecQuirks[i].subsystem_vendor_id != HDA_ALL</a>
<a name="ln375">			&amp;&amp; kCodecQuirks[i].subsystem_vendor_id != subSystemVendorID)</a>
<a name="ln376">			continue;</a>
<a name="ln377">		if (kCodecQuirks[i].codec_vendor_id != HDA_ALL</a>
<a name="ln378">			&amp;&amp; kCodecQuirks[i].codec_vendor_id != codec-&gt;vendor_id)</a>
<a name="ln379">			continue;</a>
<a name="ln380">		if (kCodecQuirks[i].codec_id != HDA_ALL</a>
<a name="ln381">			&amp;&amp; kCodecQuirks[i].codec_id != codec-&gt;product_id)</a>
<a name="ln382">			continue;</a>
<a name="ln383"> </a>
<a name="ln384">		codec-&gt;quirks |= kCodecQuirks[i].quirks;</a>
<a name="ln385">		codec-&gt;quirks &amp;= ~kCodecQuirks[i].nonquirks;</a>
<a name="ln386">	}</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">static status_t</a>
<a name="ln391">hda_get_pm_support(hda_codec* codec, uint32 nodeID, uint32* pm)</a>
<a name="ln392">{</a>
<a name="ln393">	corb_t verb = MAKE_VERB(codec-&gt;addr, nodeID, VID_GET_PARAMETER,</a>
<a name="ln394">		PID_POWERSTATE_SUPPORT);</a>
<a name="ln395"> </a>
<a name="ln396">	uint32 response;</a>
<a name="ln397">	status_t status = hda_send_verbs(codec, &amp;verb, &amp;response, 1);</a>
<a name="ln398">	if (status == B_OK)</a>
<a name="ln399">		*pm = response &amp; 0xf;</a>
<a name="ln400"> </a>
<a name="ln401">	return status;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">static status_t</a>
<a name="ln406">hda_get_stream_support(hda_codec* codec, uint32 nodeID, uint32* formats,</a>
<a name="ln407">	uint32* rates)</a>
<a name="ln408">{</a>
<a name="ln409">	corb_t verbs[2];</a>
<a name="ln410">	uint32 resp[2];</a>
<a name="ln411">	status_t status;</a>
<a name="ln412"> </a>
<a name="ln413">	verbs[0] = MAKE_VERB(codec-&gt;addr, nodeID, VID_GET_PARAMETER,</a>
<a name="ln414">		PID_STREAM_SUPPORT);</a>
<a name="ln415">	verbs[1] = MAKE_VERB(codec-&gt;addr, nodeID, VID_GET_PARAMETER,</a>
<a name="ln416">		PID_PCM_SUPPORT);</a>
<a name="ln417"> </a>
<a name="ln418">	status = hda_send_verbs(codec, verbs, resp, 2);</a>
<a name="ln419">	if (status != B_OK)</a>
<a name="ln420">		return status;</a>
<a name="ln421"> </a>
<a name="ln422">	*formats = 0;</a>
<a name="ln423">	*rates = 0;</a>
<a name="ln424"> </a>
<a name="ln425">	if ((resp[0] &amp; (STREAM_FLOAT | STREAM_PCM)) != 0) {</a>
<a name="ln426">		if (resp[1] &amp; (1 &lt;&lt; 0))</a>
<a name="ln427">			*rates |= B_SR_8000;</a>
<a name="ln428">		if (resp[1] &amp; (1 &lt;&lt; 1))</a>
<a name="ln429">			*rates |= B_SR_11025;</a>
<a name="ln430">		if (resp[1] &amp; (1 &lt;&lt; 2))</a>
<a name="ln431">			*rates |= B_SR_16000;</a>
<a name="ln432">		if (resp[1] &amp; (1 &lt;&lt; 3))</a>
<a name="ln433">			*rates |= B_SR_22050;</a>
<a name="ln434">		if (resp[1] &amp; (1 &lt;&lt; 4))</a>
<a name="ln435">			*rates |= B_SR_32000;</a>
<a name="ln436">		if (resp[1] &amp; (1 &lt;&lt; 5))</a>
<a name="ln437">			*rates |= B_SR_44100;</a>
<a name="ln438">		if (resp[1] &amp; (1 &lt;&lt; 6))</a>
<a name="ln439">			*rates |= B_SR_48000;</a>
<a name="ln440">		if (resp[1] &amp; (1 &lt;&lt; 7))</a>
<a name="ln441">			*rates |= B_SR_88200;</a>
<a name="ln442">		if (resp[1] &amp; (1 &lt;&lt; 8))</a>
<a name="ln443">			*rates |= B_SR_96000;</a>
<a name="ln444">		if (resp[1] &amp; (1 &lt;&lt; 9))</a>
<a name="ln445">			*rates |= B_SR_176400;</a>
<a name="ln446">		if (resp[1] &amp; (1 &lt;&lt; 10))</a>
<a name="ln447">			*rates |= B_SR_192000;</a>
<a name="ln448">		if (resp[1] &amp; (1 &lt;&lt; 11))</a>
<a name="ln449">			*rates |= B_SR_384000;</a>
<a name="ln450"> </a>
<a name="ln451">		if (resp[1] &amp; PCM_8_BIT)</a>
<a name="ln452">			*formats |= B_FMT_8BIT_S;</a>
<a name="ln453">		if (resp[1] &amp; PCM_16_BIT)</a>
<a name="ln454">			*formats |= B_FMT_16BIT;</a>
<a name="ln455">		if (resp[1] &amp; PCM_20_BIT)</a>
<a name="ln456">			*formats |= B_FMT_20BIT;</a>
<a name="ln457">		if (resp[1] &amp; PCM_24_BIT)</a>
<a name="ln458">			*formats |= B_FMT_24BIT;</a>
<a name="ln459">		if (resp[1] &amp; PCM_32_BIT)</a>
<a name="ln460">			*formats |= B_FMT_32BIT;</a>
<a name="ln461">	}</a>
<a name="ln462">	if ((resp[0] &amp; STREAM_FLOAT) != 0)</a>
<a name="ln463">		*formats |= B_FMT_FLOAT;</a>
<a name="ln464">	if ((resp[0] &amp; STREAM_AC3) != 0) {</a>
<a name="ln465">		*formats |= B_FMT_BITSTREAM;</a>
<a name="ln466">	}</a>
<a name="ln467"> </a>
<a name="ln468">	return B_OK;</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">//	#pragma mark - widget functions</a>
<a name="ln473"> </a>
<a name="ln474"> </a>
<a name="ln475">static status_t</a>
<a name="ln476">hda_widget_get_pm_support(hda_audio_group* audioGroup, hda_widget* widget)</a>
<a name="ln477">{</a>
<a name="ln478">	return hda_get_pm_support(audioGroup-&gt;codec, widget-&gt;node_id, &amp;widget-&gt;pm);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481"> </a>
<a name="ln482">static status_t</a>
<a name="ln483">hda_widget_get_stream_support(hda_audio_group* audioGroup, hda_widget* widget)</a>
<a name="ln484">{</a>
<a name="ln485">	if (audioGroup-&gt;widget.node_id != widget-&gt;node_id</a>
<a name="ln486">		&amp;&amp; (widget-&gt;capabilities.audio &amp; AUDIO_CAP_FORMAT_OVERRIDE) == 0) {</a>
<a name="ln487">		// adopt capabilities of the audio group</a>
<a name="ln488">		widget-&gt;d.io.formats = audioGroup-&gt;widget.d.io.formats;</a>
<a name="ln489">		widget-&gt;d.io.rates = audioGroup-&gt;widget.d.io.rates;</a>
<a name="ln490">		return B_OK;</a>
<a name="ln491">	}</a>
<a name="ln492"> </a>
<a name="ln493">	return hda_get_stream_support(audioGroup-&gt;codec, widget-&gt;node_id,</a>
<a name="ln494">		&amp;widget-&gt;d.io.formats, &amp;widget-&gt;d.io.rates);</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497"> </a>
<a name="ln498">static status_t</a>
<a name="ln499">hda_widget_get_amplifier_capabilities(hda_audio_group* audioGroup,</a>
<a name="ln500">	hda_widget* widget)</a>
<a name="ln501">{</a>
<a name="ln502">	uint32 response;</a>
<a name="ln503">	corb_t verb;</a>
<a name="ln504"> </a>
<a name="ln505">	if ((widget-&gt;capabilities.audio &amp; AUDIO_CAP_OUTPUT_AMPLIFIER) != 0</a>
<a name="ln506">		|| audioGroup-&gt;widget.node_id == widget-&gt;node_id) {</a>
<a name="ln507">		if ((widget-&gt;capabilities.audio &amp; AUDIO_CAP_AMPLIFIER_OVERRIDE) != 0</a>
<a name="ln508">			|| audioGroup-&gt;widget.node_id == widget-&gt;node_id) {</a>
<a name="ln509">			verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget-&gt;node_id,</a>
<a name="ln510">				VID_GET_PARAMETER, PID_OUTPUT_AMPLIFIER_CAP);</a>
<a name="ln511">			status_t status = hda_send_verbs(audioGroup-&gt;codec, &amp;verb,</a>
<a name="ln512">				&amp;response, 1);</a>
<a name="ln513">			if (status != B_OK)</a>
<a name="ln514">				return status;</a>
<a name="ln515"> </a>
<a name="ln516">			widget-&gt;capabilities.output_amplifier = response;</a>
<a name="ln517">		} else {</a>
<a name="ln518">			// adopt capabilities from the audio function group</a>
<a name="ln519">			widget-&gt;capabilities.output_amplifier</a>
<a name="ln520">				= audioGroup-&gt;widget.capabilities.output_amplifier;</a>
<a name="ln521">		}</a>
<a name="ln522">	}</a>
<a name="ln523"> </a>
<a name="ln524">	if ((widget-&gt;capabilities.audio &amp; AUDIO_CAP_INPUT_AMPLIFIER) != 0</a>
<a name="ln525">		|| audioGroup-&gt;widget.node_id == widget-&gt;node_id) {</a>
<a name="ln526">		if ((widget-&gt;capabilities.audio &amp; AUDIO_CAP_AMPLIFIER_OVERRIDE</a>
<a name="ln527">			|| audioGroup-&gt;widget.node_id == widget-&gt;node_id) != 0) {</a>
<a name="ln528">			verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget-&gt;node_id,</a>
<a name="ln529">				VID_GET_PARAMETER, PID_INPUT_AMPLIFIER_CAP);</a>
<a name="ln530">			status_t status = hda_send_verbs(audioGroup-&gt;codec, &amp;verb,</a>
<a name="ln531">				&amp;response, 1);</a>
<a name="ln532">			if (status != B_OK)</a>
<a name="ln533">				return status;</a>
<a name="ln534"> </a>
<a name="ln535">			widget-&gt;capabilities.input_amplifier = response;</a>
<a name="ln536">		} else {</a>
<a name="ln537">			// adopt capabilities from the audio function group</a>
<a name="ln538">			widget-&gt;capabilities.input_amplifier</a>
<a name="ln539">				= audioGroup-&gt;widget.capabilities.input_amplifier;</a>
<a name="ln540">		}</a>
<a name="ln541">	}</a>
<a name="ln542"> </a>
<a name="ln543">	return B_OK;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546"> </a>
<a name="ln547">hda_widget*</a>
<a name="ln548">hda_audio_group_get_widget(hda_audio_group* audioGroup, uint32 nodeID)</a>
<a name="ln549">{</a>
<a name="ln550">	if (audioGroup-&gt;widget_start &gt; nodeID</a>
<a name="ln551">		|| audioGroup-&gt;widget_start + audioGroup-&gt;widget_count &lt; nodeID)</a>
<a name="ln552">		return NULL;</a>
<a name="ln553"> </a>
<a name="ln554">	return &amp;audioGroup-&gt;widgets[nodeID - audioGroup-&gt;widget_start];</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557"> </a>
<a name="ln558">static status_t</a>
<a name="ln559">hda_widget_get_connections(hda_audio_group* audioGroup, hda_widget* widget)</a>
<a name="ln560">{</a>
<a name="ln561">	corb_t verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget-&gt;node_id,</a>
<a name="ln562">		VID_GET_PARAMETER, PID_CONNECTION_LIST_LENGTH);</a>
<a name="ln563">	uint32 response;</a>
<a name="ln564"> </a>
<a name="ln565">	if (hda_send_verbs(audioGroup-&gt;codec, &amp;verb, &amp;response, 1) != B_OK)</a>
<a name="ln566">		return B_ERROR;</a>
<a name="ln567"> </a>
<a name="ln568">	uint32 listEntries = response &amp; 0x7f;</a>
<a name="ln569">	bool longForm = (response &amp; 0xf0) != 0;</a>
<a name="ln570"> </a>
<a name="ln571">	if (listEntries == 0)</a>
<a name="ln572">		return B_OK;</a>
<a name="ln573"> </a>
<a name="ln574">#if 1</a>
<a name="ln575">	if (widget-&gt;num_inputs &gt; 1) {</a>
<a name="ln576">		// Get currently active connection</a>
<a name="ln577">		verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget-&gt;node_id,</a>
<a name="ln578">			VID_GET_CONNECTION_SELECT, 0);</a>
<a name="ln579">		if (hda_send_verbs(audioGroup-&gt;codec, &amp;verb, &amp;response, 1) == B_OK)</a>
<a name="ln580">			widget-&gt;active_input = response &amp; 0xff;</a>
<a name="ln581">	}</a>
<a name="ln582">#endif</a>
<a name="ln583"> </a>
<a name="ln584">	uint32 valuesPerEntry = longForm ? 2 : 4;</a>
<a name="ln585">	uint32 shift = 32 / valuesPerEntry;</a>
<a name="ln586">	uint32 rangeMask = (1 &lt;&lt; (shift - 1));</a>
<a name="ln587">	int32 previousInput = -1;</a>
<a name="ln588">	uint32 numInputs = 0;</a>
<a name="ln589"> </a>
<a name="ln590">	for (uint32 i = 0; i &lt; listEntries; i++) {</a>
<a name="ln591">		if ((i % valuesPerEntry) == 0) {</a>
<a name="ln592">			// We get 2 or 4 answers per call depending on if we're</a>
<a name="ln593">			// in short or long list mode</a>
<a name="ln594">			verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget-&gt;node_id,</a>
<a name="ln595">				VID_GET_CONNECTION_LIST_ENTRY, i);</a>
<a name="ln596">			if (hda_send_verbs(audioGroup-&gt;codec, &amp;verb, &amp;response, 1)</a>
<a name="ln597">					!= B_OK) {</a>
<a name="ln598">				ERROR(&quot;Error parsing inputs for widget %ld!\n&quot;,</a>
<a name="ln599">					widget-&gt;node_id);</a>
<a name="ln600">				break;</a>
<a name="ln601">			}</a>
<a name="ln602">		}</a>
<a name="ln603"> </a>
<a name="ln604">		int32 input = (response &gt;&gt; (shift * (i % valuesPerEntry)))</a>
<a name="ln605">			&amp; ((1 &lt;&lt; shift) - 1);</a>
<a name="ln606"> </a>
<a name="ln607">		if (input &amp; rangeMask) {</a>
<a name="ln608">			// found range</a>
<a name="ln609">			input &amp;= ~rangeMask;</a>
<a name="ln610"> </a>
<a name="ln611">			if (input &lt; previousInput || previousInput == -1) {</a>
<a name="ln612">				ERROR(&quot;invalid range from %ld to %ld\n&quot;, previousInput,</a>
<a name="ln613">					input);</a>
<a name="ln614">				continue;</a>
<a name="ln615">			}</a>
<a name="ln616"> </a>
<a name="ln617">			for (int32 rangeInput = previousInput + 1; rangeInput &lt;= input</a>
<a name="ln618">					&amp;&amp; numInputs &lt; MAX_INPUTS; rangeInput++) {</a>
<a name="ln619">				widget-&gt;inputs[numInputs++] = rangeInput;</a>
<a name="ln620">			}</a>
<a name="ln621"> </a>
<a name="ln622">			previousInput = -1;</a>
<a name="ln623">		} else if (numInputs &lt; MAX_INPUTS) {</a>
<a name="ln624">			// standard value</a>
<a name="ln625">			widget-&gt;inputs[numInputs++] = input;</a>
<a name="ln626">			previousInput = input;</a>
<a name="ln627">		}</a>
<a name="ln628">	}</a>
<a name="ln629"> </a>
<a name="ln630">	widget-&gt;num_inputs = numInputs;</a>
<a name="ln631"> </a>
<a name="ln632">	if (widget-&gt;num_inputs == 1)</a>
<a name="ln633">		widget-&gt;active_input = 0;</a>
<a name="ln634"> </a>
<a name="ln635">	return B_OK;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638"> </a>
<a name="ln639">static status_t</a>
<a name="ln640">hda_widget_get_associations(hda_audio_group* audioGroup)</a>
<a name="ln641">{</a>
<a name="ln642">	uint32 index = 0;</a>
<a name="ln643">	for (uint32 i = 0; i &lt; MAX_ASSOCIATIONS; i++) {</a>
<a name="ln644">		for (uint32 j = 0; j &lt; audioGroup-&gt;widget_count; j++) {</a>
<a name="ln645">			if (index &gt;= MAX_ASSOCIATIONS) {</a>
<a name="ln646">				TRACE(&quot;too many associations, bailing!\n&quot;);</a>
<a name="ln647">				return B_ERROR;</a>
<a name="ln648">			}</a>
<a name="ln649">			hda_widget&amp; widget = audioGroup-&gt;widgets[j];</a>
<a name="ln650"> </a>
<a name="ln651">			if (widget.type != WT_PIN_COMPLEX)</a>
<a name="ln652">				continue;</a>
<a name="ln653">			if (CONF_DEFAULT_ASSOCIATION(widget.d.pin.config) != i)</a>
<a name="ln654">				continue;</a>
<a name="ln655">			if (audioGroup-&gt;associations[index].pin_count == 0) {</a>
<a name="ln656">				audioGroup-&gt;associations[index].index = index;</a>
<a name="ln657">				audioGroup-&gt;associations[index].enabled = true;</a>
<a name="ln658">			}</a>
<a name="ln659">			uint32 sequence = CONF_DEFAULT_SEQUENCE(widget.d.pin.config);</a>
<a name="ln660">			if (audioGroup-&gt;associations[index].pins[sequence] != 0) {</a>
<a name="ln661">				audioGroup-&gt;associations[index].enabled = false;</a>
<a name="ln662">			}</a>
<a name="ln663">			audioGroup-&gt;associations[index].pins[sequence] = widget.node_id;</a>
<a name="ln664">			audioGroup-&gt;associations[index].pin_count++;</a>
<a name="ln665">			if (i == 15)</a>
<a name="ln666">				index++;</a>
<a name="ln667">		}</a>
<a name="ln668">		if (i != 15 &amp;&amp; audioGroup-&gt;associations[index].pin_count != 0)</a>
<a name="ln669">			index++;</a>
<a name="ln670">	}</a>
<a name="ln671">	audioGroup-&gt;association_count = index;</a>
<a name="ln672"> </a>
<a name="ln673">	return B_OK;</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676"> </a>
<a name="ln677">static uint32</a>
<a name="ln678">hda_widget_prepare_pin_ctrl(hda_audio_group* audioGroup, hda_widget* widget,</a>
<a name="ln679">	bool isOutput)</a>
<a name="ln680">{</a>
<a name="ln681">	uint32 ctrl = 0;</a>
<a name="ln682">	if (isOutput)</a>
<a name="ln683">		ctrl = PIN_ENABLE_HEAD_PHONE | PIN_ENABLE_OUTPUT;</a>
<a name="ln684">	else</a>
<a name="ln685">		ctrl = PIN_ENABLE_INPUT;</a>
<a name="ln686"> </a>
<a name="ln687">	if (PIN_CAP_IS_VREF_CTRL_50_CAP(widget-&gt;d.pin.capabilities)</a>
<a name="ln688">		&amp;&amp; (audioGroup-&gt;codec-&gt;quirks &amp; (isOutput ? HDA_QUIRK_OVREF50</a>
<a name="ln689">			: HDA_QUIRK_IVREF50))) {</a>
<a name="ln690">		ctrl |= PIN_ENABLE_VREF_50;</a>
<a name="ln691">		TRACE(&quot;%s vref 50 enabled\n&quot;, isOutput ? &quot;output&quot; : &quot;input&quot;);</a>
<a name="ln692">	}</a>
<a name="ln693">	if (PIN_CAP_IS_VREF_CTRL_80_CAP(widget-&gt;d.pin.capabilities)</a>
<a name="ln694">		&amp;&amp; (audioGroup-&gt;codec-&gt;quirks &amp; (isOutput ? HDA_QUIRK_OVREF80</a>
<a name="ln695">			: HDA_QUIRK_IVREF80))) {</a>
<a name="ln696">		ctrl |= PIN_ENABLE_VREF_80;</a>
<a name="ln697">		TRACE(&quot;%s vref 80 enabled\n&quot;, isOutput ? &quot;output&quot; : &quot;input&quot;);</a>
<a name="ln698">	}</a>
<a name="ln699">	if (PIN_CAP_IS_VREF_CTRL_100_CAP(widget-&gt;d.pin.capabilities)</a>
<a name="ln700">		&amp;&amp; (audioGroup-&gt;codec-&gt;quirks &amp; (isOutput ? HDA_QUIRK_OVREF100</a>
<a name="ln701">			: HDA_QUIRK_IVREF100))) {</a>
<a name="ln702">		ctrl |= PIN_ENABLE_VREF_100;</a>
<a name="ln703">		TRACE(&quot;%s vref 100 enabled\n&quot;, isOutput ? &quot;output&quot; : &quot;input&quot;);</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">	return ctrl;</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709"> </a>
<a name="ln710">//	#pragma mark - audio group functions</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">static status_t</a>
<a name="ln714">hda_codec_parse_audio_group(hda_audio_group* audioGroup)</a>
<a name="ln715">{</a>
<a name="ln716">	corb_t verbs[3];</a>
<a name="ln717">	uint32 resp[3];</a>
<a name="ln718"> </a>
<a name="ln719">	hda_codec* codec = audioGroup-&gt;codec;</a>
<a name="ln720">	uint32 codec_id = (codec-&gt;vendor_id &lt;&lt; 16) | codec-&gt;product_id;</a>
<a name="ln721">	hda_widget_get_stream_support(audioGroup, &amp;audioGroup-&gt;widget);</a>
<a name="ln722">	hda_widget_get_pm_support(audioGroup, &amp;audioGroup-&gt;widget);</a>
<a name="ln723">	hda_widget_get_amplifier_capabilities(audioGroup, &amp;audioGroup-&gt;widget);</a>
<a name="ln724"> </a>
<a name="ln725">	verbs[0] = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, audioGroup-&gt;widget.node_id,</a>
<a name="ln726">		VID_GET_PARAMETER, PID_AUDIO_GROUP_CAP);</a>
<a name="ln727">	verbs[1] = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, audioGroup-&gt;widget.node_id,</a>
<a name="ln728">		VID_GET_PARAMETER, PID_GPIO_COUNT);</a>
<a name="ln729">	verbs[2] = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, audioGroup-&gt;widget.node_id,</a>
<a name="ln730">		VID_GET_PARAMETER, PID_SUB_NODE_COUNT);</a>
<a name="ln731"> </a>
<a name="ln732">	if (hda_send_verbs(audioGroup-&gt;codec, verbs, resp, 3) != B_OK)</a>
<a name="ln733">		return B_ERROR;</a>
<a name="ln734"> </a>
<a name="ln735">	TRACE(&quot;Audio Group: Output delay: %ld samples, Input delay: %ld &quot;</a>
<a name="ln736">		&quot;samples, Beep Generator: %s\n&quot;, AUDIO_GROUP_CAP_OUTPUT_DELAY(resp[0]),</a>
<a name="ln737">		AUDIO_GROUP_CAP_INPUT_DELAY(resp[0]),</a>
<a name="ln738">		AUDIO_GROUP_CAP_BEEPGEN(resp[0]) ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln739"> </a>
<a name="ln740">	TRACE(&quot;  #GPIO: %ld, #GPO: %ld, #GPI: %ld, unsol: %s, wake: %s\n&quot;,</a>
<a name="ln741">		GPIO_COUNT_NUM_GPIO(resp[1]), GPIO_COUNT_NUM_GPO(resp[1]),</a>
<a name="ln742">		GPIO_COUNT_NUM_GPI(resp[1]), GPIO_COUNT_GPIUNSOL(resp[1]) ? &quot;yes&quot; : &quot;no&quot;,</a>
<a name="ln743">		GPIO_COUNT_GPIWAKE(resp[1]) ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln744">	dump_widget_stream_support(audioGroup-&gt;widget);</a>
<a name="ln745"> </a>
<a name="ln746">	audioGroup-&gt;gpio = resp[1];</a>
<a name="ln747">	audioGroup-&gt;widget_start = SUB_NODE_COUNT_START(resp[2]);</a>
<a name="ln748">	audioGroup-&gt;widget_count = SUB_NODE_COUNT_TOTAL(resp[2]);</a>
<a name="ln749"> </a>
<a name="ln750">	TRACE(&quot;  widget start %lu, count %lu\n&quot;, audioGroup-&gt;widget_start,</a>
<a name="ln751">		audioGroup-&gt;widget_count);</a>
<a name="ln752"> </a>
<a name="ln753">	audioGroup-&gt;widgets = (hda_widget*)calloc(audioGroup-&gt;widget_count,</a>
<a name="ln754">		sizeof(*audioGroup-&gt;widgets));</a>
<a name="ln755">	if (audioGroup-&gt;widgets == NULL) {</a>
<a name="ln756">		ERROR(&quot;ERROR: Not enough memory!\n&quot;);</a>
<a name="ln757">		return B_NO_MEMORY;</a>
<a name="ln758">	}</a>
<a name="ln759"> </a>
<a name="ln760">	// Iterate over all Widgets and collect info</a>
<a name="ln761">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count; i++) {</a>
<a name="ln762">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln763">		uint32 nodeID = audioGroup-&gt;widget_start + i;</a>
<a name="ln764">		uint32 capabilities;</a>
<a name="ln765"> </a>
<a name="ln766">		verbs[0] = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, nodeID, VID_GET_PARAMETER,</a>
<a name="ln767">			PID_AUDIO_WIDGET_CAP);</a>
<a name="ln768">		if (hda_send_verbs(audioGroup-&gt;codec, verbs, &amp;capabilities, 1) != B_OK)</a>
<a name="ln769">			return B_ERROR;</a>
<a name="ln770"> </a>
<a name="ln771">		widget.type = (hda_widget_type)((capabilities &amp; AUDIO_CAP_TYPE_MASK)</a>
<a name="ln772">			&gt;&gt; AUDIO_CAP_TYPE_SHIFT);</a>
<a name="ln773"> </a>
<a name="ln774">		// Check specific node ids declared as inputs as beepers</a>
<a name="ln775">		switch (codec_id) {</a>
<a name="ln776">			case 0x11d41882:</a>
<a name="ln777">			case 0x11d41883:</a>
<a name="ln778">			case 0x11d41884:</a>
<a name="ln779">			case 0x11d4194a:</a>
<a name="ln780">			case 0x11d4194b:</a>
<a name="ln781">			case 0x11d41987:</a>
<a name="ln782">			case 0x11d41988:</a>
<a name="ln783">			case 0x11d4198b:</a>
<a name="ln784">			case 0x11d4989b:</a>
<a name="ln785">				if (nodeID == 26)</a>
<a name="ln786">					widget.type = WT_BEEP_GENERATOR;</a>
<a name="ln787">				break;</a>
<a name="ln788">			case 0x10ec0260:</a>
<a name="ln789">				if (nodeID == 23)</a>
<a name="ln790">					widget.type = WT_BEEP_GENERATOR;</a>
<a name="ln791">				break;</a>
<a name="ln792">			case 0x10ec0262:</a>
<a name="ln793">			case 0x10ec0268:</a>
<a name="ln794">			case 0x10ec0880:</a>
<a name="ln795">			case 0x10ec0882:</a>
<a name="ln796">			case 0x10ec0883:</a>
<a name="ln797">			case 0x10ec0885:</a>
<a name="ln798">			case 0x10ec0888:</a>
<a name="ln799">			case 0x10ec0889:</a>
<a name="ln800">				if (nodeID == 29)</a>
<a name="ln801">					widget.type = WT_BEEP_GENERATOR;</a>
<a name="ln802">				break;</a>
<a name="ln803">		}</a>
<a name="ln804">		widget.active_input = -1;</a>
<a name="ln805">		widget.capabilities.audio = capabilities;</a>
<a name="ln806">		widget.node_id = nodeID;</a>
<a name="ln807"> </a>
<a name="ln808">		if ((capabilities &amp; AUDIO_CAP_POWER_CONTROL) != 0) {</a>
<a name="ln809">			// We support power; switch us on!</a>
<a name="ln810">			verbs[0] = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, nodeID,</a>
<a name="ln811">				VID_SET_POWER_STATE, 0);</a>
<a name="ln812">			hda_send_verbs(audioGroup-&gt;codec, verbs, NULL, 1);</a>
<a name="ln813"> </a>
<a name="ln814">			snooze(1000);</a>
<a name="ln815">		}</a>
<a name="ln816">		if ((capabilities &amp; (AUDIO_CAP_INPUT_AMPLIFIER</a>
<a name="ln817">				| AUDIO_CAP_OUTPUT_AMPLIFIER)) != 0) {</a>
<a name="ln818">			hda_widget_get_amplifier_capabilities(audioGroup, &amp;widget);</a>
<a name="ln819">		}</a>
<a name="ln820"> </a>
<a name="ln821">		TRACE(&quot;%ld: %s\n&quot;, nodeID, get_widget_type_name(widget.type));</a>
<a name="ln822"> </a>
<a name="ln823">		switch (widget.type) {</a>
<a name="ln824">			case WT_AUDIO_OUTPUT:</a>
<a name="ln825">			case WT_AUDIO_INPUT:</a>
<a name="ln826">				hda_widget_get_stream_support(audioGroup, &amp;widget);</a>
<a name="ln827">				dump_widget_stream_support(widget);</a>
<a name="ln828">				break;</a>
<a name="ln829"> </a>
<a name="ln830">			case WT_PIN_COMPLEX:</a>
<a name="ln831">				verbs[0] = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, nodeID,</a>
<a name="ln832">					VID_GET_PARAMETER, PID_PIN_CAP);</a>
<a name="ln833">				if (hda_send_verbs(audioGroup-&gt;codec, verbs, resp, 1) == B_OK) {</a>
<a name="ln834">					widget.d.pin.capabilities = resp[0];</a>
<a name="ln835"> </a>
<a name="ln836">					TRACE(&quot;\t%s%s\n&quot;, PIN_CAP_IS_INPUT(resp[0]) ? &quot;[Input] &quot; : &quot;&quot;,</a>
<a name="ln837">						PIN_CAP_IS_OUTPUT(resp[0]) ? &quot;[Output]&quot; : &quot;&quot;);</a>
<a name="ln838">				} else {</a>
<a name="ln839">					ERROR(&quot;%s: Error getting Pin Complex IO\n&quot;, __func__);</a>
<a name="ln840">				}</a>
<a name="ln841"> </a>
<a name="ln842">				verbs[0] = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, nodeID,</a>
<a name="ln843">					VID_GET_CONFIGURATION_DEFAULT, 0);</a>
<a name="ln844">				if (hda_send_verbs(audioGroup-&gt;codec, verbs, resp, 1) == B_OK) {</a>
<a name="ln845">					widget.d.pin.config = resp[0];</a>
<a name="ln846">					const char* location =</a>
<a name="ln847">						get_widget_location(CONF_DEFAULT_LOCATION(resp[0]));</a>
<a name="ln848">					TRACE(&quot;\t%s, %s%s%s, %s, %s, Association:%ld\n&quot;,</a>
<a name="ln849">						kPortConnector[CONF_DEFAULT_CONNECTIVITY(resp[0])],</a>
<a name="ln850">						location ? location : &quot;&quot;,</a>
<a name="ln851">						location ? &quot; &quot; : &quot;&quot;,</a>
<a name="ln852">						kDefaultDevice[CONF_DEFAULT_DEVICE(resp[0])],</a>
<a name="ln853">						kConnectionType[CONF_DEFAULT_CONNTYPE(resp[0])],</a>
<a name="ln854">						kJackColor[CONF_DEFAULT_COLOR(resp[0])],</a>
<a name="ln855">						CONF_DEFAULT_ASSOCIATION(resp[0]));</a>
<a name="ln856">				}</a>
<a name="ln857">				break;</a>
<a name="ln858"> </a>
<a name="ln859">			case WT_VOLUME_KNOB:</a>
<a name="ln860">				verbs[0] = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, nodeID,</a>
<a name="ln861">					VID_SET_VOLUME_KNOB_CONTROL, 0x0);</a>
<a name="ln862">				hda_send_verbs(audioGroup-&gt;codec, verbs, NULL, 1);</a>
<a name="ln863">				break;</a>
<a name="ln864">			default:</a>
<a name="ln865">				break;</a>
<a name="ln866">		}</a>
<a name="ln867"> </a>
<a name="ln868">		hda_widget_get_pm_support(audioGroup, &amp;widget);</a>
<a name="ln869">		hda_widget_get_connections(audioGroup, &amp;widget);</a>
<a name="ln870"> </a>
<a name="ln871">		dump_widget_pm_support(widget);</a>
<a name="ln872">		dump_widget_audio_capabilities(capabilities);</a>
<a name="ln873">		dump_widget_amplifier_capabilities(widget, true);</a>
<a name="ln874">		dump_widget_amplifier_capabilities(widget, false);</a>
<a name="ln875">		dump_widget_inputs(widget);</a>
<a name="ln876">	}</a>
<a name="ln877"> </a>
<a name="ln878">	hda_widget_get_associations(audioGroup);</a>
<a name="ln879"> </a>
<a name="ln880">	// init the codecs</a>
<a name="ln881">	switch (codec_id) {</a>
<a name="ln882">		case 0x10ec0888: {</a>
<a name="ln883">			hda_verb_write(codec, 0x20, VID_SET_COEFFICIENT_INDEX, 0x0);</a>
<a name="ln884">			uint32 tmp;</a>
<a name="ln885">			hda_verb_read(codec, 0x20, VID_GET_PROCESSING_COEFFICIENT, &amp;tmp);</a>
<a name="ln886">			hda_verb_write(codec, 0x20, VID_SET_COEFFICIENT_INDEX, 0x7);</a>
<a name="ln887">			hda_verb_write(codec, 0x20, VID_SET_PROCESSING_COEFFICIENT,</a>
<a name="ln888">				(tmp &amp; 0xf0) == 0x20 ? 0x830 : 0x3030);</a>
<a name="ln889">			break;</a>
<a name="ln890">		}</a>
<a name="ln891">	}</a>
<a name="ln892"> </a>
<a name="ln893">	return B_OK;</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896"> </a>
<a name="ln897">/*! Find output path for widget */</a>
<a name="ln898">static bool</a>
<a name="ln899">hda_widget_find_output_path(hda_audio_group* audioGroup, hda_widget* widget,</a>
<a name="ln900">	uint32 depth, bool &amp;alreadyUsed)</a>
<a name="ln901">{</a>
<a name="ln902">	alreadyUsed = false;</a>
<a name="ln903"> </a>
<a name="ln904">	if (widget == NULL || depth &gt; 16)</a>
<a name="ln905">		return false;</a>
<a name="ln906"> </a>
<a name="ln907">	switch (widget-&gt;type) {</a>
<a name="ln908">		case WT_AUDIO_OUTPUT:</a>
<a name="ln909">			widget-&gt;flags |= WIDGET_FLAG_OUTPUT_PATH;</a>
<a name="ln910">TRACE(&quot;      %*soutput: added output widget %ld\n&quot;, (int)depth * 2, &quot;&quot;, widget-&gt;node_id);</a>
<a name="ln911">			return true;</a>
<a name="ln912"> </a>
<a name="ln913">		case WT_AUDIO_MIXER:</a>
<a name="ln914">		case WT_AUDIO_SELECTOR:</a>
<a name="ln915">		{</a>
<a name="ln916">			// already used</a>
<a name="ln917">			if ((widget-&gt;flags &amp; WIDGET_FLAG_OUTPUT_PATH) != 0) {</a>
<a name="ln918">				alreadyUsed = true;</a>
<a name="ln919">				return false;</a>
<a name="ln920">			}</a>
<a name="ln921"> </a>
<a name="ln922">			// search for output in this path</a>
<a name="ln923">			bool found = false;</a>
<a name="ln924">			for (uint32 i = 0; i &lt; widget-&gt;num_inputs; i++) {</a>
<a name="ln925">				hda_widget* inputWidget = hda_audio_group_get_widget(audioGroup,</a>
<a name="ln926">					widget-&gt;inputs[i]);</a>
<a name="ln927"> </a>
<a name="ln928">				if (hda_widget_find_output_path(audioGroup, inputWidget,</a>
<a name="ln929">						depth + 1, alreadyUsed)) {</a>
<a name="ln930">					if (widget-&gt;active_input == -1)</a>
<a name="ln931">						widget-&gt;active_input = i;</a>
<a name="ln932"> </a>
<a name="ln933">					widget-&gt;flags |= WIDGET_FLAG_OUTPUT_PATH;</a>
<a name="ln934">TRACE(&quot;      %*soutput: added mixer/selector widget %ld\n&quot;, (int)depth * 2, &quot;&quot;, widget-&gt;node_id);</a>
<a name="ln935">					found = true;</a>
<a name="ln936">				}</a>
<a name="ln937">			}</a>
<a name="ln938">if (!found) TRACE(&quot;      %*soutput: not added mixer/selector widget %ld\n&quot;, (int)depth * 2, &quot;&quot;, widget-&gt;node_id);</a>
<a name="ln939">			return found;</a>
<a name="ln940">		}</a>
<a name="ln941"> </a>
<a name="ln942">		default:</a>
<a name="ln943">			return false;</a>
<a name="ln944">	}</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947"> </a>
<a name="ln948">/*! Find input path for widget */</a>
<a name="ln949">static bool</a>
<a name="ln950">hda_widget_find_input_path(hda_audio_group* audioGroup, hda_widget* widget,</a>
<a name="ln951">	uint32 depth)</a>
<a name="ln952">{</a>
<a name="ln953">	if (widget == NULL || depth &gt; 16)</a>
<a name="ln954">		return false;</a>
<a name="ln955"> </a>
<a name="ln956">	switch (widget-&gt;type) {</a>
<a name="ln957">		case WT_PIN_COMPLEX:</a>
<a name="ln958">			// already used</a>
<a name="ln959">			if ((widget-&gt;flags</a>
<a name="ln960">					&amp; (WIDGET_FLAG_INPUT_PATH | WIDGET_FLAG_OUTPUT_PATH)) != 0)</a>
<a name="ln961">				return false;</a>
<a name="ln962"> </a>
<a name="ln963">			if (PIN_CAP_IS_INPUT(widget-&gt;d.pin.capabilities)) {</a>
<a name="ln964">				switch (CONF_DEFAULT_DEVICE(widget-&gt;d.pin.config)) {</a>
<a name="ln965">					case PIN_DEV_CD:</a>
<a name="ln966">					case PIN_DEV_LINE_IN:</a>
<a name="ln967">					case PIN_DEV_MIC_IN:</a>
<a name="ln968">						widget-&gt;flags |= WIDGET_FLAG_INPUT_PATH;</a>
<a name="ln969">TRACE(&quot;      %*sinput: added input widget %ld\n&quot;, (int)depth * 2, &quot;&quot;, widget-&gt;node_id);</a>
<a name="ln970">						return true;</a>
<a name="ln971">					break;</a>
<a name="ln972">				}</a>
<a name="ln973">			}</a>
<a name="ln974">			return false;</a>
<a name="ln975">		case WT_AUDIO_INPUT:</a>
<a name="ln976">		case WT_AUDIO_MIXER:</a>
<a name="ln977">		case WT_AUDIO_SELECTOR:</a>
<a name="ln978">		{</a>
<a name="ln979">			// already used</a>
<a name="ln980">			if ((widget-&gt;flags</a>
<a name="ln981">					&amp; (WIDGET_FLAG_INPUT_PATH | WIDGET_FLAG_OUTPUT_PATH)) != 0)</a>
<a name="ln982">				return false;</a>
<a name="ln983"> </a>
<a name="ln984">			// search for pin complex in this path</a>
<a name="ln985">			bool found = false;</a>
<a name="ln986">			for (uint32 i = 0; i &lt; widget-&gt;num_inputs; i++) {</a>
<a name="ln987">				hda_widget* inputWidget = hda_audio_group_get_widget(audioGroup,</a>
<a name="ln988">					widget-&gt;inputs[i]);</a>
<a name="ln989"> </a>
<a name="ln990">				if (hda_widget_find_input_path(audioGroup, inputWidget,</a>
<a name="ln991">						depth + 1)) {</a>
<a name="ln992">					if (widget-&gt;active_input == -1)</a>
<a name="ln993">						widget-&gt;active_input = i;</a>
<a name="ln994"> </a>
<a name="ln995">					widget-&gt;flags |= WIDGET_FLAG_INPUT_PATH;</a>
<a name="ln996">TRACE(&quot;      %*sinput: added mixer/selector widget %ld\n&quot;, (int)depth * 2, &quot;&quot;, widget-&gt;node_id);</a>
<a name="ln997">					found = true;</a>
<a name="ln998">				}</a>
<a name="ln999">			}</a>
<a name="ln1000">if (!found) TRACE(&quot;      %*sinput: not added mixer/selector widget %ld\n&quot;, (int)depth * 2, &quot;&quot;, widget-&gt;node_id);</a>
<a name="ln1001">			return found;</a>
<a name="ln1002">		}</a>
<a name="ln1003"> </a>
<a name="ln1004">		default:</a>
<a name="ln1005">			return false;</a>
<a name="ln1006">	}</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009">static bool</a>
<a name="ln1010">hda_audio_group_build_output_tree(hda_audio_group* audioGroup, bool useMixer)</a>
<a name="ln1011">{</a>
<a name="ln1012">	bool found = false;</a>
<a name="ln1013"> </a>
<a name="ln1014">TRACE(&quot;build output tree: %suse mixer\n&quot;, useMixer ? &quot;&quot; : &quot;don't &quot;);</a>
<a name="ln1015">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count; i++) {</a>
<a name="ln1016">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln1017"> </a>
<a name="ln1018">		if (widget.type != WT_PIN_COMPLEX</a>
<a name="ln1019">			|| !PIN_CAP_IS_OUTPUT(widget.d.pin.capabilities))</a>
<a name="ln1020">			continue;</a>
<a name="ln1021"> </a>
<a name="ln1022">		int device = CONF_DEFAULT_DEVICE(widget.d.pin.config);</a>
<a name="ln1023">		if (device != PIN_DEV_HEAD_PHONE_OUT</a>
<a name="ln1024">			&amp;&amp; device != PIN_DEV_DIGITAL_OTHER_OUT</a>
<a name="ln1025">			&amp;&amp; device != PIN_DEV_SPEAKER</a>
<a name="ln1026">			&amp;&amp; device != PIN_DEV_LINE_OUT)</a>
<a name="ln1027">			continue;</a>
<a name="ln1028"> </a>
<a name="ln1029">TRACE(&quot;  look at pin widget %ld (%ld inputs)\n&quot;, widget.node_id, widget.num_inputs);</a>
<a name="ln1030">		for (uint32 j = 0; j &lt; widget.num_inputs; j++) {</a>
<a name="ln1031">			hda_widget* inputWidget = hda_audio_group_get_widget(audioGroup,</a>
<a name="ln1032">				widget.inputs[j]);</a>
<a name="ln1033">TRACE(&quot;    try widget %ld: %p\n&quot;, widget.inputs[j], inputWidget);</a>
<a name="ln1034">			if (inputWidget == NULL)</a>
<a name="ln1035">				continue;</a>
<a name="ln1036"> </a>
<a name="ln1037">			if (useMixer &amp;&amp; inputWidget-&gt;type != WT_AUDIO_MIXER</a>
<a name="ln1038">				&amp;&amp; inputWidget-&gt;type != WT_AUDIO_SELECTOR)</a>
<a name="ln1039">				continue;</a>
<a name="ln1040">TRACE(&quot;    widget %ld is candidate\n&quot;, inputWidget-&gt;node_id);</a>
<a name="ln1041"> </a>
<a name="ln1042">			bool alreadyUsed = false;</a>
<a name="ln1043">			if (hda_widget_find_output_path(audioGroup, inputWidget, 0,</a>
<a name="ln1044">				alreadyUsed)</a>
<a name="ln1045">				|| (device == PIN_DEV_HEAD_PHONE_OUT &amp;&amp; alreadyUsed)) {</a>
<a name="ln1046">				// find the output path to an audio output widget</a>
<a name="ln1047">				// or for headphones, an already used widget</a>
<a name="ln1048">TRACE(&quot;    add pin widget %ld\n&quot;, widget.node_id);</a>
<a name="ln1049">				if (widget.active_input == -1)</a>
<a name="ln1050">					widget.active_input = j;</a>
<a name="ln1051">				widget.flags |= WIDGET_FLAG_OUTPUT_PATH;</a>
<a name="ln1052">				found = true;</a>
<a name="ln1053">				break;</a>
<a name="ln1054">			}</a>
<a name="ln1055">		}</a>
<a name="ln1056">	}</a>
<a name="ln1057"> </a>
<a name="ln1058">	return found;</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061"> </a>
<a name="ln1062">static bool</a>
<a name="ln1063">hda_audio_group_build_input_tree(hda_audio_group* audioGroup)</a>
<a name="ln1064">{</a>
<a name="ln1065">	bool found = false;</a>
<a name="ln1066"> </a>
<a name="ln1067">TRACE(&quot;build input tree\n&quot;);</a>
<a name="ln1068">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count; i++) {</a>
<a name="ln1069">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln1070"> </a>
<a name="ln1071">		if (widget.type != WT_AUDIO_INPUT)</a>
<a name="ln1072">			continue;</a>
<a name="ln1073"> </a>
<a name="ln1074">TRACE(&quot;  look at input widget %ld (%ld inputs)\n&quot;, widget.node_id, widget.num_inputs);</a>
<a name="ln1075">		for (uint32 j = 0; j &lt; widget.num_inputs; j++) {</a>
<a name="ln1076">			hda_widget* inputWidget = hda_audio_group_get_widget(audioGroup,</a>
<a name="ln1077">				widget.inputs[j]);</a>
<a name="ln1078">TRACE(&quot;    try widget %ld: %p\n&quot;, widget.inputs[j], inputWidget);</a>
<a name="ln1079">			if (inputWidget == NULL)</a>
<a name="ln1080">				continue;</a>
<a name="ln1081"> </a>
<a name="ln1082">TRACE(&quot;    widget %ld is candidate\n&quot;, inputWidget-&gt;node_id);</a>
<a name="ln1083"> </a>
<a name="ln1084">			if (hda_widget_find_input_path(audioGroup, inputWidget, 0)) {</a>
<a name="ln1085">TRACE(&quot;    add pin widget %ld\n&quot;, widget.node_id);</a>
<a name="ln1086">				if (widget.active_input == -1)</a>
<a name="ln1087">					widget.active_input = j;</a>
<a name="ln1088">				widget.flags |= WIDGET_FLAG_INPUT_PATH;</a>
<a name="ln1089">				found = true;</a>
<a name="ln1090">				break;</a>
<a name="ln1091">			}</a>
<a name="ln1092">		}</a>
<a name="ln1093">	}</a>
<a name="ln1094"> </a>
<a name="ln1095">	return found;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098"> </a>
<a name="ln1099">static status_t</a>
<a name="ln1100">hda_audio_group_build_tree(hda_audio_group* audioGroup)</a>
<a name="ln1101">{</a>
<a name="ln1102">	if (!hda_audio_group_build_output_tree(audioGroup, true)) {</a>
<a name="ln1103">		// didn't find a mixer path, try again without</a>
<a name="ln1104">TRACE(&quot;try without mixer!\n&quot;);</a>
<a name="ln1105">		if (!hda_audio_group_build_output_tree(audioGroup, false))</a>
<a name="ln1106">			return ENODEV;</a>
<a name="ln1107">	}</a>
<a name="ln1108"> </a>
<a name="ln1109">	if (!hda_audio_group_build_input_tree(audioGroup)) {</a>
<a name="ln1110">		ERROR(&quot;build input tree failed\n&quot;);</a>
<a name="ln1111">	}</a>
<a name="ln1112"> </a>
<a name="ln1113">TRACE(&quot;build tree!\n&quot;);</a>
<a name="ln1114"> </a>
<a name="ln1115">	// select active connections</a>
<a name="ln1116"> </a>
<a name="ln1117">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count; i++) {</a>
<a name="ln1118">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln1119"> </a>
<a name="ln1120">		if (widget.active_input == -1)</a>
<a name="ln1121">			widget.active_input = 0;</a>
<a name="ln1122">		if (widget.num_inputs &lt; 2)</a>
<a name="ln1123">			continue;</a>
<a name="ln1124"> </a>
<a name="ln1125">		if (widget.type != WT_AUDIO_INPUT</a>
<a name="ln1126">			&amp;&amp; widget.type != WT_AUDIO_SELECTOR</a>
<a name="ln1127">			&amp;&amp; widget.type != WT_PIN_COMPLEX)</a>
<a name="ln1128">			continue;</a>
<a name="ln1129"> </a>
<a name="ln1130">		corb_t verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1131">			widget.node_id, VID_SET_CONNECTION_SELECT, widget.active_input);</a>
<a name="ln1132">		if (hda_send_verbs(audioGroup-&gt;codec, &amp;verb, NULL, 1) != B_OK)</a>
<a name="ln1133">			ERROR(&quot;Setting output selector %ld failed on widget %ld!\n&quot;,</a>
<a name="ln1134">				widget.active_input, widget.node_id);</a>
<a name="ln1135">	}</a>
<a name="ln1136"> </a>
<a name="ln1137">	// GPIO</a>
<a name="ln1138">	uint32 gpio = 0;</a>
<a name="ln1139">	for (uint32 i = 0; i &lt; GPIO_COUNT_NUM_GPIO(audioGroup-&gt;gpio)</a>
<a name="ln1140">		&amp;&amp; i &lt; HDA_QUIRK_GPIO_COUNT; i++) {</a>
<a name="ln1141">		if (audioGroup-&gt;codec-&gt;quirks &amp; (1 &lt;&lt; i)) {</a>
<a name="ln1142">			gpio |= (1 &lt;&lt; i);</a>
<a name="ln1143">		}</a>
<a name="ln1144">	}</a>
<a name="ln1145"> </a>
<a name="ln1146">	if (gpio != 0) {</a>
<a name="ln1147">		corb_t verb[] = {</a>
<a name="ln1148">			MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1149">				audioGroup-&gt;widget.node_id, VID_SET_GPIO_DATA, gpio),</a>
<a name="ln1150">			MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1151">				audioGroup-&gt;widget.node_id, VID_SET_GPIO_EN, gpio),</a>
<a name="ln1152">			MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1153">				audioGroup-&gt;widget.node_id, VID_SET_GPIO_DIR, gpio)</a>
<a name="ln1154">		};</a>
<a name="ln1155">		TRACE(&quot;Setting gpio 0x%lx\n&quot;, gpio);</a>
<a name="ln1156">		if (hda_send_verbs(audioGroup-&gt;codec, verb, NULL, 3) != B_OK)</a>
<a name="ln1157">			ERROR(&quot;Setting gpio failed!\n&quot;);</a>
<a name="ln1158">	}</a>
<a name="ln1159"> </a>
<a name="ln1160">	dump_audiogroup_widgets(audioGroup);</a>
<a name="ln1161"> </a>
<a name="ln1162">	return B_OK;</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165"> </a>
<a name="ln1166">static void</a>
<a name="ln1167">hda_audio_group_switch_init(hda_audio_group* audioGroup)</a>
<a name="ln1168">{</a>
<a name="ln1169">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count; i++) {</a>
<a name="ln1170">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln1171">		if (widget.type != WT_PIN_COMPLEX)</a>
<a name="ln1172">			continue;</a>
<a name="ln1173"> </a>
<a name="ln1174">		if ((widget.capabilities.audio &amp; AUDIO_CAP_UNSOLICITED_RESPONSES) != 0</a>
<a name="ln1175">			&amp;&amp; (widget.d.pin.capabilities &amp; PIN_CAP_PRES_DETECT) != 0</a>
<a name="ln1176">			&amp;&amp; (CONF_DEFAULT_MISC(widget.d.pin.config) &amp; 1) == 0) {</a>
<a name="ln1177">			corb_t verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget.node_id,</a>
<a name="ln1178">				VID_SET_UNSOLRESP, UNSOLRESP_ENABLE);</a>
<a name="ln1179">			hda_send_verbs(audioGroup-&gt;codec, &amp;verb, NULL, 1);</a>
<a name="ln1180">			TRACE(&quot;Enabled unsolicited responses on widget %ld\n&quot;,</a>
<a name="ln1181">				widget.node_id);</a>
<a name="ln1182">		}</a>
<a name="ln1183">	}</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186"> </a>
<a name="ln1187">static void</a>
<a name="ln1188">hda_audio_group_check_sense(hda_audio_group* audioGroup, bool disable)</a>
<a name="ln1189">{</a>
<a name="ln1190">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count; i++) {</a>
<a name="ln1191">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln1192"> </a>
<a name="ln1193">		if (widget.type != WT_PIN_COMPLEX</a>
<a name="ln1194">			|| !PIN_CAP_IS_OUTPUT(widget.d.pin.capabilities)</a>
<a name="ln1195">			|| CONF_DEFAULT_DEVICE(widget.d.pin.config)</a>
<a name="ln1196">				!= PIN_DEV_HEAD_PHONE_OUT)</a>
<a name="ln1197">			continue;</a>
<a name="ln1198"> </a>
<a name="ln1199">		corb_t verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget.node_id,</a>
<a name="ln1200">			VID_GET_PINSENSE, 0);</a>
<a name="ln1201">		uint32 response;</a>
<a name="ln1202">		hda_send_verbs(audioGroup-&gt;codec, &amp;verb, &amp;response, 1);</a>
<a name="ln1203">		disable = response &amp; PIN_SENSE_PRESENCE_DETECT;</a>
<a name="ln1204">		TRACE(&quot;sensed pin widget %ld, %d\n&quot;, widget.node_id, disable);</a>
<a name="ln1205"> </a>
<a name="ln1206">		uint32 ctrl = hda_widget_prepare_pin_ctrl(audioGroup, &amp;widget,</a>
<a name="ln1207">				true);</a>
<a name="ln1208">		verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget.node_id,</a>
<a name="ln1209">			VID_SET_PIN_WIDGET_CONTROL, disable ? ctrl : 0);</a>
<a name="ln1210">		hda_send_verbs(audioGroup-&gt;codec, &amp;verb, NULL, 1);</a>
<a name="ln1211">		break;</a>
<a name="ln1212">	}</a>
<a name="ln1213"> </a>
<a name="ln1214">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count; i++) {</a>
<a name="ln1215">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln1216"> </a>
<a name="ln1217">		if (widget.type != WT_PIN_COMPLEX</a>
<a name="ln1218">			|| !PIN_CAP_IS_OUTPUT(widget.d.pin.capabilities))</a>
<a name="ln1219">			continue;</a>
<a name="ln1220"> </a>
<a name="ln1221">		int device = CONF_DEFAULT_DEVICE(widget.d.pin.config);</a>
<a name="ln1222">		if (device != PIN_DEV_AUX</a>
<a name="ln1223">			&amp;&amp; device != PIN_DEV_SPEAKER</a>
<a name="ln1224">			&amp;&amp; device != PIN_DEV_LINE_OUT)</a>
<a name="ln1225">			continue;</a>
<a name="ln1226"> </a>
<a name="ln1227">		uint32 ctrl = hda_widget_prepare_pin_ctrl(audioGroup, &amp;widget,</a>
<a name="ln1228">				true);</a>
<a name="ln1229">		corb_t verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr, widget.node_id,</a>
<a name="ln1230">			VID_SET_PIN_WIDGET_CONTROL, disable ? 0 : ctrl);</a>
<a name="ln1231">		hda_send_verbs(audioGroup-&gt;codec, &amp;verb, NULL, 1);</a>
<a name="ln1232">	}</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235"> </a>
<a name="ln1236">static status_t</a>
<a name="ln1237">hda_codec_switch_handler(hda_codec* codec)</a>
<a name="ln1238">{</a>
<a name="ln1239">	while (acquire_sem(codec-&gt;unsol_response_sem) == B_OK) {</a>
<a name="ln1240">		uint32 response = codec-&gt;unsol_responses[codec-&gt;unsol_response_read++];</a>
<a name="ln1241">		codec-&gt;unsol_response_read %= MAX_CODEC_UNSOL_RESPONSES;</a>
<a name="ln1242"> </a>
<a name="ln1243">		bool disable = response &amp; 1;</a>
<a name="ln1244">		hda_audio_group* audioGroup = codec-&gt;audio_groups[0];</a>
<a name="ln1245">		hda_audio_group_check_sense(audioGroup, disable);</a>
<a name="ln1246">	}</a>
<a name="ln1247">	return B_OK;</a>
<a name="ln1248">}</a>
<a name="ln1249"> </a>
<a name="ln1250"> </a>
<a name="ln1251">static void</a>
<a name="ln1252">hda_codec_delete_audio_group(hda_audio_group* audioGroup)</a>
<a name="ln1253">{</a>
<a name="ln1254">	if (audioGroup == NULL)</a>
<a name="ln1255">		return;</a>
<a name="ln1256"> </a>
<a name="ln1257">	if (audioGroup-&gt;playback_stream != NULL)</a>
<a name="ln1258">		hda_stream_delete(audioGroup-&gt;playback_stream);</a>
<a name="ln1259"> </a>
<a name="ln1260">	if (audioGroup-&gt;record_stream != NULL)</a>
<a name="ln1261">		hda_stream_delete(audioGroup-&gt;record_stream);</a>
<a name="ln1262">	free(audioGroup-&gt;multi);</a>
<a name="ln1263">	free(audioGroup-&gt;widgets);</a>
<a name="ln1264">	free(audioGroup);</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267"> </a>
<a name="ln1268">static status_t</a>
<a name="ln1269">hda_codec_new_audio_group(hda_codec* codec, uint32 audioGroupNodeID)</a>
<a name="ln1270">{</a>
<a name="ln1271">	hda_audio_group* audioGroup = (hda_audio_group*)calloc(1,</a>
<a name="ln1272">		sizeof(hda_audio_group));</a>
<a name="ln1273">	if (audioGroup == NULL)</a>
<a name="ln1274">		return B_NO_MEMORY;</a>
<a name="ln1275"> </a>
<a name="ln1276">	// Setup minimal info needed by hda_codec_parse_afg</a>
<a name="ln1277">	audioGroup-&gt;widget.node_id = audioGroupNodeID;</a>
<a name="ln1278">	audioGroup-&gt;codec = codec;</a>
<a name="ln1279">	audioGroup-&gt;multi = (hda_multi*)calloc(1,</a>
<a name="ln1280">		sizeof(hda_multi));</a>
<a name="ln1281">	if (audioGroup-&gt;multi == NULL) {</a>
<a name="ln1282">		free(audioGroup);</a>
<a name="ln1283">		return B_NO_MEMORY;</a>
<a name="ln1284">	}</a>
<a name="ln1285">	audioGroup-&gt;multi-&gt;group = audioGroup;</a>
<a name="ln1286"> </a>
<a name="ln1287">	// Parse all widgets in Audio Function Group</a>
<a name="ln1288">	status_t status = hda_codec_parse_audio_group(audioGroup);</a>
<a name="ln1289">	if (status != B_OK)</a>
<a name="ln1290">		goto err;</a>
<a name="ln1291"> </a>
<a name="ln1292">	// Setup for worst-case scenario; we cannot find any output Pin Widgets</a>
<a name="ln1293">	status = ENODEV;</a>
<a name="ln1294"> </a>
<a name="ln1295">	if (hda_audio_group_build_tree(audioGroup) != B_OK)</a>
<a name="ln1296">		goto err;</a>
<a name="ln1297">	hda_audio_group_switch_init(audioGroup);</a>
<a name="ln1298"> </a>
<a name="ln1299">	audioGroup-&gt;playback_stream = hda_stream_new(audioGroup, STREAM_PLAYBACK);</a>
<a name="ln1300">	audioGroup-&gt;record_stream = hda_stream_new(audioGroup, STREAM_RECORD);</a>
<a name="ln1301">	TRACE(&quot;streams playback %p, record %p\n&quot;, audioGroup-&gt;playback_stream,</a>
<a name="ln1302">		audioGroup-&gt;record_stream);</a>
<a name="ln1303"> </a>
<a name="ln1304">	if (audioGroup-&gt;playback_stream != NULL</a>
<a name="ln1305">		|| audioGroup-&gt;record_stream != NULL) {</a>
<a name="ln1306">		codec-&gt;audio_groups[codec-&gt;num_audio_groups++] = audioGroup;</a>
<a name="ln1307">		hda_audio_group_check_sense(audioGroup, false);</a>
<a name="ln1308">		return B_OK;</a>
<a name="ln1309">	}</a>
<a name="ln1310"> </a>
<a name="ln1311">err:</a>
<a name="ln1312">	free(audioGroup-&gt;widgets);</a>
<a name="ln1313">	free(audioGroup);</a>
<a name="ln1314">	return status;</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317"> </a>
<a name="ln1318">//	#pragma mark -</a>
<a name="ln1319"> </a>
<a name="ln1320"> </a>
<a name="ln1321">status_t</a>
<a name="ln1322">hda_audio_group_get_widgets(hda_audio_group* audioGroup, hda_stream* stream)</a>
<a name="ln1323">{</a>
<a name="ln1324">	hda_widget_type type;</a>
<a name="ln1325">	uint32 flags;</a>
<a name="ln1326"> </a>
<a name="ln1327">	if (stream-&gt;type == STREAM_PLAYBACK) {</a>
<a name="ln1328">		type = WT_AUDIO_OUTPUT;</a>
<a name="ln1329">		flags = WIDGET_FLAG_OUTPUT_PATH;</a>
<a name="ln1330">	} else {</a>
<a name="ln1331">		// record</a>
<a name="ln1332">		type = WT_AUDIO_INPUT;</a>
<a name="ln1333">		flags = WIDGET_FLAG_INPUT_PATH;</a>
<a name="ln1334">	}</a>
<a name="ln1335"> </a>
<a name="ln1336">	uint32 count = 0;</a>
<a name="ln1337"> </a>
<a name="ln1338">	for (uint32 i = 0; i &lt; audioGroup-&gt;widget_count &amp;&amp; count &lt; MAX_IO_WIDGETS;</a>
<a name="ln1339">			i++) {</a>
<a name="ln1340">		hda_widget&amp; widget = audioGroup-&gt;widgets[i];</a>
<a name="ln1341"> </a>
<a name="ln1342">		if ((widget.flags &amp; flags) != 0) {</a>
<a name="ln1343">			if (widget.type == WT_PIN_COMPLEX) {</a>
<a name="ln1344">				stream-&gt;pin_widget = widget.node_id;</a>
<a name="ln1345"> </a>
<a name="ln1346">				uint32 ctrl = hda_widget_prepare_pin_ctrl(audioGroup, &amp;widget,</a>
<a name="ln1347">					flags == WIDGET_FLAG_OUTPUT_PATH);</a>
<a name="ln1348"> </a>
<a name="ln1349">TRACE(&quot;ENABLE pin widget %ld\n&quot;, widget.node_id);</a>
<a name="ln1350">				// FIXME: Force Pin Widget to unmute; enable hp/output</a>
<a name="ln1351">				corb_t verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1352">					widget.node_id,</a>
<a name="ln1353">					VID_SET_PIN_WIDGET_CONTROL, ctrl);</a>
<a name="ln1354">				hda_send_verbs(audioGroup-&gt;codec, &amp;verb, NULL, 1);</a>
<a name="ln1355"> </a>
<a name="ln1356">				if (PIN_CAP_IS_EAPD_CAP(widget.d.pin.capabilities)) {</a>
<a name="ln1357">					uint32 result;</a>
<a name="ln1358">					verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1359">						widget.node_id, VID_GET_EAPDBTL_EN, 0);</a>
<a name="ln1360">					if (hda_send_verbs(audioGroup-&gt;codec, &amp;verb,</a>
<a name="ln1361">						&amp;result, 1) == B_OK) {</a>
<a name="ln1362">						result &amp;= 0xff;</a>
<a name="ln1363">						verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1364">							widget.node_id, VID_SET_EAPDBTL_EN,</a>
<a name="ln1365">							result | EAPDBTL_ENABLE_EAPD);</a>
<a name="ln1366">						hda_send_verbs(audioGroup-&gt;codec,</a>
<a name="ln1367">							&amp;verb, NULL, 1);</a>
<a name="ln1368">TRACE(&quot;ENABLE EAPD pin widget %ld\n&quot;, widget.node_id);</a>
<a name="ln1369">					}</a>
<a name="ln1370">				}</a>
<a name="ln1371">			}</a>
<a name="ln1372"> </a>
<a name="ln1373">			if (widget.capabilities.output_amplifier != 0) {</a>
<a name="ln1374">TRACE(&quot;UNMUTE/SET OUTPUT GAIN widget %ld (offset %ld)\n&quot;, widget.node_id,</a>
<a name="ln1375">	AMP_CAP_OFFSET(widget.capabilities.output_amplifier));</a>
<a name="ln1376">				corb_t verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1377">					widget.node_id,</a>
<a name="ln1378">					VID_SET_AMPLIFIER_GAIN_MUTE,</a>
<a name="ln1379">					AMP_SET_OUTPUT | AMP_SET_LEFT_CHANNEL</a>
<a name="ln1380">						| AMP_SET_RIGHT_CHANNEL</a>
<a name="ln1381">						| AMP_CAP_OFFSET(widget.capabilities.output_amplifier));</a>
<a name="ln1382">				hda_send_verbs(audioGroup-&gt;codec, &amp;verb, NULL, 1);</a>
<a name="ln1383">			}</a>
<a name="ln1384">			if (widget.capabilities.input_amplifier != 0) {</a>
<a name="ln1385">TRACE(&quot;UNMUTE/SET INPUT GAIN widget %ld (offset %ld)\n&quot;, widget.node_id,</a>
<a name="ln1386">	AMP_CAP_OFFSET(widget.capabilities.input_amplifier));</a>
<a name="ln1387">				for (uint32 i = 0; i &lt; widget.num_inputs; i++) {</a>
<a name="ln1388">					corb_t verb = MAKE_VERB(audioGroup-&gt;codec-&gt;addr,</a>
<a name="ln1389">						widget.node_id,</a>
<a name="ln1390">						VID_SET_AMPLIFIER_GAIN_MUTE,</a>
<a name="ln1391">						AMP_SET_INPUT | AMP_SET_LEFT_CHANNEL</a>
<a name="ln1392">							| AMP_SET_RIGHT_CHANNEL</a>
<a name="ln1393">							| AMP_SET_INPUT_INDEX(i)</a>
<a name="ln1394">							| ((widget.active_input == (int32)i) ? 0 : AMP_MUTE)</a>
<a name="ln1395">							| AMP_CAP_OFFSET(widget.capabilities.input_amplifier));</a>
<a name="ln1396">					hda_send_verbs(audioGroup-&gt;codec, &amp;verb, NULL, 1);</a>
<a name="ln1397">				}</a>
<a name="ln1398">			}</a>
<a name="ln1399">		}</a>
<a name="ln1400"> </a>
<a name="ln1401">		if (widget.type != type || (widget.flags &amp; flags) == 0</a>
<a name="ln1402">			|| (widget.capabilities.audio</a>
<a name="ln1403">				&amp; (AUDIO_CAP_STEREO | AUDIO_CAP_DIGITAL)) != AUDIO_CAP_STEREO</a>
<a name="ln1404">			|| widget.d.io.formats == 0)</a>
<a name="ln1405">			continue;</a>
<a name="ln1406"> </a>
<a name="ln1407">		if (count == 0) {</a>
<a name="ln1408">			stream-&gt;sample_format = widget.d.io.formats;</a>
<a name="ln1409">			stream-&gt;sample_rate = widget.d.io.rates;</a>
<a name="ln1410">		} else {</a>
<a name="ln1411">			stream-&gt;sample_format &amp;= widget.d.io.formats;</a>
<a name="ln1412">			stream-&gt;sample_rate &amp;= widget.d.io.rates;</a>
<a name="ln1413">		}</a>
<a name="ln1414"> </a>
<a name="ln1415">		stream-&gt;io_widgets[count++] = widget.node_id;</a>
<a name="ln1416">	}</a>
<a name="ln1417"> </a>
<a name="ln1418">	if (count == 0)</a>
<a name="ln1419">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1420"> </a>
<a name="ln1421">	stream-&gt;num_io_widgets = count;</a>
<a name="ln1422">	return B_OK;</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425"> </a>
<a name="ln1426">void</a>
<a name="ln1427">hda_codec_delete(hda_codec* codec)</a>
<a name="ln1428">{</a>
<a name="ln1429">	if (codec == NULL)</a>
<a name="ln1430">		return;</a>
<a name="ln1431"> </a>
<a name="ln1432">	delete_sem(codec-&gt;response_sem);</a>
<a name="ln1433">	delete_sem(codec-&gt;unsol_response_sem);</a>
<a name="ln1434"> </a>
<a name="ln1435">	int32 result;</a>
<a name="ln1436">	wait_for_thread(codec-&gt;unsol_response_thread, &amp;result);</a>
<a name="ln1437"> </a>
<a name="ln1438">	for (uint32 i = 0; i &lt; codec-&gt;num_audio_groups; i++) {</a>
<a name="ln1439">		hda_codec_delete_audio_group(codec-&gt;audio_groups[i]);</a>
<a name="ln1440">		codec-&gt;audio_groups[i] = NULL;</a>
<a name="ln1441">	}</a>
<a name="ln1442"> </a>
<a name="ln1443">	free(codec);</a>
<a name="ln1444">}</a>
<a name="ln1445"> </a>
<a name="ln1446"> </a>
<a name="ln1447">hda_codec*</a>
<a name="ln1448">hda_codec_new(hda_controller* controller, uint32 codecAddress)</a>
<a name="ln1449">{</a>
<a name="ln1450">	if (codecAddress &gt; HDA_MAX_CODECS)</a>
<a name="ln1451">		return NULL;</a>
<a name="ln1452"> </a>
<a name="ln1453">	hda_codec* codec = (hda_codec*)calloc(1, sizeof(hda_codec));</a>
<a name="ln1454">	if (codec == NULL) {</a>
<a name="ln1455">		ERROR(&quot;Failed to alloc a codec\n&quot;);</a>
<a name="ln1456">		return NULL;</a>
<a name="ln1457">	}</a>
<a name="ln1458"> </a>
<a name="ln1459">	status_t status;</a>
<a name="ln1460"> </a>
<a name="ln1461">	codec-&gt;controller = controller;</a>
<a name="ln1462">	codec-&gt;addr = codecAddress;</a>
<a name="ln1463">	codec-&gt;response_sem = create_sem(0, &quot;hda_codec_response_sem&quot;);</a>
<a name="ln1464">	if (codec-&gt;response_sem &lt; B_OK) {</a>
<a name="ln1465">		ERROR(&quot;Failed to create semaphore\n&quot;);</a>
<a name="ln1466">		goto err;</a>
<a name="ln1467">	}</a>
<a name="ln1468">	controller-&gt;codecs[codecAddress] = codec;</a>
<a name="ln1469"> </a>
<a name="ln1470">	codec-&gt;unsol_response_sem = create_sem(0, &quot;hda_codec_unsol_response_sem&quot;);</a>
<a name="ln1471">	if (codec-&gt;unsol_response_sem &lt; B_OK) {</a>
<a name="ln1472">		ERROR(&quot;Failed to create semaphore\n&quot;);</a>
<a name="ln1473">		goto err;</a>
<a name="ln1474">	}</a>
<a name="ln1475">	codec-&gt;unsol_response_read = 0;</a>
<a name="ln1476">	codec-&gt;unsol_response_write = 0;</a>
<a name="ln1477"> </a>
<a name="ln1478">	struct {</a>
<a name="ln1479">		uint32 device : 16;</a>
<a name="ln1480">		uint32 vendor : 16;</a>
<a name="ln1481">		uint32 stepping : 8;</a>
<a name="ln1482">		uint32 revision : 8;</a>
<a name="ln1483">		uint32 minor : 4;</a>
<a name="ln1484">		uint32 major : 4;</a>
<a name="ln1485">		uint32 _reserved0 : 8;</a>
<a name="ln1486">		uint32 count : 8;</a>
<a name="ln1487">		uint32 _reserved1 : 8;</a>
<a name="ln1488">		uint32 start : 8;</a>
<a name="ln1489">		uint32 _reserved2 : 8;</a>
<a name="ln1490">	} response;</a>
<a name="ln1491"> </a>
<a name="ln1492">	corb_t verbs[3];</a>
<a name="ln1493">	verbs[0] = MAKE_VERB(codecAddress, 0, VID_GET_PARAMETER, PID_VENDOR_ID);</a>
<a name="ln1494">	verbs[1] = MAKE_VERB(codecAddress, 0, VID_GET_PARAMETER, PID_REVISION_ID);</a>
<a name="ln1495">	verbs[2] = MAKE_VERB(codecAddress, 0, VID_GET_PARAMETER,</a>
<a name="ln1496">		PID_SUB_NODE_COUNT);</a>
<a name="ln1497"> </a>
<a name="ln1498">	status = hda_send_verbs(codec, verbs, (uint32*)&amp;response, 3);</a>
<a name="ln1499">	if (status != B_OK) {</a>
<a name="ln1500">		ERROR(&quot;Failed to get vendor and revision parameters: %s\n&quot;,</a>
<a name="ln1501">			strerror(status));</a>
<a name="ln1502">		goto err;</a>
<a name="ln1503">	}</a>
<a name="ln1504"> </a>
<a name="ln1505">	codec-&gt;vendor_id = response.vendor;</a>
<a name="ln1506">	codec-&gt;product_id = response.device;</a>
<a name="ln1507">	codec-&gt;stepping = response.stepping;</a>
<a name="ln1508">	codec-&gt;revision = response.revision;</a>
<a name="ln1509">	codec-&gt;minor = response.minor;</a>
<a name="ln1510">	codec-&gt;major = response.major;</a>
<a name="ln1511">	hda_codec_get_quirks(codec);</a>
<a name="ln1512"> </a>
<a name="ln1513">	TRACE(&quot;Codec %ld Vendor: %04lx Product: %04lx, Revision: &quot;</a>
<a name="ln1514">		&quot;%lu.%lu.%lu.%lu Quirks: %04lx\n&quot;, codecAddress, response.vendor,</a>
<a name="ln1515">		response.device, response.major, response.minor, response.revision,</a>
<a name="ln1516">		response.stepping, codec-&gt;quirks);</a>
<a name="ln1517"> </a>
<a name="ln1518">	for (uint32 nodeID = response.start;</a>
<a name="ln1519">			nodeID &lt; response.start + response.count; nodeID++) {</a>
<a name="ln1520">		uint32 groupType;</a>
<a name="ln1521">		verbs[0] = MAKE_VERB(codecAddress, nodeID, VID_GET_PARAMETER,</a>
<a name="ln1522">			PID_FUNCTION_GROUP_TYPE);</a>
<a name="ln1523"> </a>
<a name="ln1524">		if (hda_send_verbs(codec, verbs, &amp;groupType, 1) != B_OK) {</a>
<a name="ln1525">			ERROR(&quot;Failed to get function group type\n&quot;);</a>
<a name="ln1526">			goto err;</a>
<a name="ln1527">		}</a>
<a name="ln1528"> </a>
<a name="ln1529">		if ((groupType &amp; FUNCTION_GROUP_NODETYPE_MASK)</a>
<a name="ln1530">				== FUNCTION_GROUP_NODETYPE_AUDIO) {</a>
<a name="ln1531">			// Found an Audio Function Group!</a>
<a name="ln1532">			status_t status = hda_codec_new_audio_group(codec, nodeID);</a>
<a name="ln1533">			if (status != B_OK) {</a>
<a name="ln1534">				ERROR(&quot;Failed to setup new audio function group (%s)!\n&quot;,</a>
<a name="ln1535">					strerror(status));</a>
<a name="ln1536">				goto err;</a>
<a name="ln1537">			}</a>
<a name="ln1538">		}</a>
<a name="ln1539">	}</a>
<a name="ln1540"> </a>
<a name="ln1541">	codec-&gt;unsol_response_thread = spawn_kernel_thread(</a>
<a name="ln1542">		(status_t(*)(void*))hda_codec_switch_handler,</a>
<a name="ln1543">		&quot;hda_codec_unsol_thread&quot;, B_LOW_PRIORITY, codec);</a>
<a name="ln1544">	if (codec-&gt;unsol_response_thread &lt; B_OK) {</a>
<a name="ln1545">		ERROR(&quot;Failed to spawn thread\n&quot;);</a>
<a name="ln1546">		goto err;</a>
<a name="ln1547">	}</a>
<a name="ln1548">	resume_thread(codec-&gt;unsol_response_thread);</a>
<a name="ln1549"> </a>
<a name="ln1550">	return codec;</a>
<a name="ln1551"> </a>
<a name="ln1552">err:</a>
<a name="ln1553">	controller-&gt;codecs[codecAddress] = NULL;</a>
<a name="ln1554">	hda_codec_delete(codec);</a>
<a name="ln1555">	return NULL;</a>
<a name="ln1556">}</a>

</code></pre>
<div class="balloon" rel="1074"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the ninth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the eighth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the seventh actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1074"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="612"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="612"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="735"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="735"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="740"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="740"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="740"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="821"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="848"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the eighth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="910"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="934"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="938"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="969"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="996"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1000"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1029"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1029"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1033"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1040"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1048"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="598"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1078"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="250"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1374"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1374"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1385"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1368"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1349"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1204"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="250"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1155"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1180"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1133"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1385"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1513"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1085"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1082"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="228"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'sprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="230"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'sprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1133"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
