
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>MemoryView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2011-2015, Rene Gollent, rene@gollent.com. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;MemoryView.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;algorithm&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;ctype.h&gt;</a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;ByteOrder.h&gt;</a>
<a name="ln15">#include &lt;Clipboard.h&gt;</a>
<a name="ln16">#include &lt;Looper.h&gt;</a>
<a name="ln17">#include &lt;MenuItem.h&gt;</a>
<a name="ln18">#include &lt;MessageRunner.h&gt;</a>
<a name="ln19">#include &lt;Messenger.h&gt;</a>
<a name="ln20">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln21">#include &lt;Region.h&gt;</a>
<a name="ln22">#include &lt;ScrollView.h&gt;</a>
<a name="ln23">#include &lt;String.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;Architecture.h&quot;</a>
<a name="ln26">#include &quot;AutoDeleter.h&quot;</a>
<a name="ln27">#include &quot;MessageCodes.h&quot;</a>
<a name="ln28">#include &quot;Team.h&quot;</a>
<a name="ln29">#include &quot;TeamMemoryBlock.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">enum {</a>
<a name="ln33">	MSG_TARGET_ADDRESS_CHANGED	= 'mtac',</a>
<a name="ln34">	MSG_VIEW_AUTOSCROLL			= 'mvas'</a>
<a name="ln35">};</a>
<a name="ln36"> </a>
<a name="ln37">static const bigtime_t kScrollTimer = 10000LL;</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">MemoryView::MemoryView(::Team* team, Listener* listener)</a>
<a name="ln41">	:</a>
<a name="ln42">	BView(&quot;memoryView&quot;, B_WILL_DRAW | B_FRAME_EVENTS | B_NAVIGABLE</a>
<a name="ln43">		| B_SUBPIXEL_PRECISE),</a>
<a name="ln44">	fTeam(team),</a>
<a name="ln45">	fTargetBlock(NULL),</a>
<a name="ln46">	fEditableData(NULL),</a>
<a name="ln47">	fEditedOffsets(),</a>
<a name="ln48">	fTargetAddress(0LL),</a>
<a name="ln49">	fEditMode(false),</a>
<a name="ln50">	fEditLowNybble(false),</a>
<a name="ln51">	fCharWidth(0.0),</a>
<a name="ln52">	fLineHeight(0.0),</a>
<a name="ln53">	fTextCharsPerLine(0),</a>
<a name="ln54">	fHexBlocksPerLine(0),</a>
<a name="ln55">	fHexMode(HexMode8BitInt),</a>
<a name="ln56">	fTextMode(TextModeASCII),</a>
<a name="ln57">	fSelectionBase(0),</a>
<a name="ln58">	fSelectionStart(0),</a>
<a name="ln59">	fSelectionEnd(0),</a>
<a name="ln60">	fScrollRunner(NULL),</a>
<a name="ln61">	fTrackingMouse(false),</a>
<a name="ln62">	fListener(listener)</a>
<a name="ln63">{</a>
<a name="ln64">	Architecture* architecture = team-&gt;GetArchitecture();</a>
<a name="ln65">	fTargetAddressSize = architecture-&gt;AddressSize() * 2;</a>
<a name="ln66">	fCurrentEndianMode = architecture-&gt;IsBigEndian()</a>
<a name="ln67">		? EndianModeBigEndian : EndianModeLittleEndian;</a>
<a name="ln68"> </a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">MemoryView::~MemoryView()</a>
<a name="ln73">{</a>
<a name="ln74">	if (fTargetBlock != NULL)</a>
<a name="ln75">		fTargetBlock-&gt;ReleaseReference();</a>
<a name="ln76"> </a>
<a name="ln77">	delete[] fEditableData;</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80"> </a>
<a name="ln81">/*static */ MemoryView*</a>
<a name="ln82">MemoryView::Create(::Team* team, Listener* listener)</a>
<a name="ln83">{</a>
<a name="ln84">	MemoryView* self = new MemoryView(team, listener);</a>
<a name="ln85"> </a>
<a name="ln86">	try {</a>
<a name="ln87">		self-&gt;_Init();</a>
<a name="ln88">	} catch(...) {</a>
<a name="ln89">		delete self;</a>
<a name="ln90">		throw;</a>
<a name="ln91">	}</a>
<a name="ln92"> </a>
<a name="ln93">	return self;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">void</a>
<a name="ln98">MemoryView::SetTargetAddress(TeamMemoryBlock* block, target_addr_t address)</a>
<a name="ln99">{</a>
<a name="ln100">	fTargetAddress = address;</a>
<a name="ln101">	if (block != fTargetBlock) {</a>
<a name="ln102">		if (fTargetBlock != NULL)</a>
<a name="ln103">			fTargetBlock-&gt;ReleaseReference();</a>
<a name="ln104"> </a>
<a name="ln105">		fTargetBlock = block;</a>
<a name="ln106">		if (block != NULL)</a>
<a name="ln107">			fTargetBlock-&gt;AcquireReference();</a>
<a name="ln108">	}</a>
<a name="ln109"> </a>
<a name="ln110">	MakeFocus(true);</a>
<a name="ln111">	BMessenger(this).SendMessage(MSG_TARGET_ADDRESS_CHANGED);</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">void</a>
<a name="ln116">MemoryView::UnsetListener()</a>
<a name="ln117">{</a>
<a name="ln118">	fListener = NULL;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">status_t</a>
<a name="ln123">MemoryView::SetEditMode(bool enabled)</a>
<a name="ln124">{</a>
<a name="ln125">	if (fTargetBlock == NULL)</a>
<a name="ln126">		return B_BAD_VALUE;</a>
<a name="ln127">	else if (fEditMode == enabled)</a>
<a name="ln128">		return B_OK;</a>
<a name="ln129"> </a>
<a name="ln130">	if (enabled) {</a>
<a name="ln131">		status_t error = _SetupEditableData();</a>
<a name="ln132">		if (error != B_OK)</a>
<a name="ln133">			return error;</a>
<a name="ln134">	} else {</a>
<a name="ln135">		delete[] fEditableData;</a>
<a name="ln136">		fEditableData = NULL;</a>
<a name="ln137">		fEditedOffsets.clear();</a>
<a name="ln138">		fEditLowNybble = false;</a>
<a name="ln139">	}</a>
<a name="ln140"> </a>
<a name="ln141">	fEditMode = enabled;</a>
<a name="ln142">	Invalidate();</a>
<a name="ln143"> </a>
<a name="ln144">	return B_OK;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">void</a>
<a name="ln149">MemoryView::AttachedToWindow()</a>
<a name="ln150">{</a>
<a name="ln151">	BView::AttachedToWindow();</a>
<a name="ln152">	SetViewUIColor(B_DOCUMENT_BACKGROUND_COLOR);</a>
<a name="ln153">	SetFont(be_fixed_font);</a>
<a name="ln154">	fCharWidth = be_fixed_font-&gt;StringWidth(&quot;a&quot;);</a>
<a name="ln155">	font_height fontHeight;</a>
<a name="ln156">	be_fixed_font-&gt;GetHeight(&amp;fontHeight);</a>
<a name="ln157">	fLineHeight = ceilf(fontHeight.ascent + fontHeight.descent</a>
<a name="ln158">		+ fontHeight.leading);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">void</a>
<a name="ln163">MemoryView::Draw(BRect rect)</a>
<a name="ln164">{</a>
<a name="ln165">	rect = Bounds();</a>
<a name="ln166"> </a>
<a name="ln167">	float divider = (fTargetAddressSize + 1) * fCharWidth;</a>
<a name="ln168">	StrokeLine(BPoint(divider, rect.top),</a>
<a name="ln169">				BPoint(divider, rect.bottom));</a>
<a name="ln170"> </a>
<a name="ln171">	if (fTargetBlock == NULL)</a>
<a name="ln172">		return;</a>
<a name="ln173"> </a>
<a name="ln174">	uint32 hexBlockSize = _GetHexDigitsPerBlock() + 1;</a>
<a name="ln175">	uint32 blockByteSize = hexBlockSize / 2;</a>
<a name="ln176">	if (fHexMode != HexModeNone &amp;&amp; fTextMode != TextModeNone) {</a>
<a name="ln177">		divider += (fHexBlocksPerLine * hexBlockSize + 1) * fCharWidth;</a>
<a name="ln178">		StrokeLine(BPoint(divider, rect.top),</a>
<a name="ln179">					BPoint(divider, rect.bottom));</a>
<a name="ln180">	}</a>
<a name="ln181"> </a>
<a name="ln182">	char buffer[32];</a>
<a name="ln183">	char textbuffer[512];</a>
<a name="ln184"> </a>
<a name="ln185">	const char* dataSource = (const char*)(fEditMode ? fEditableData</a>
<a name="ln186">			: fTargetBlock-&gt;Data());</a>
<a name="ln187"> </a>
<a name="ln188">	int32 startLine = int32(rect.top / fLineHeight);</a>
<a name="ln189">	const char* currentAddress = dataSource + fHexBlocksPerLine</a>
<a name="ln190">		* blockByteSize * startLine;</a>
<a name="ln191">	const char* maxAddress = dataSource + fTargetBlock-&gt;Size();</a>
<a name="ln192">	const char* targetAddress = dataSource + fTargetAddress</a>
<a name="ln193">		- fTargetBlock-&gt;BaseAddress();</a>
<a name="ln194">	BPoint drawPoint(1.0, (startLine + 1) * fLineHeight);</a>
<a name="ln195">	int32 currentBlocksPerLine = fHexBlocksPerLine;</a>
<a name="ln196">	int32 currentCharsPerLine = fTextCharsPerLine;</a>
<a name="ln197">	font_height fh;</a>
<a name="ln198">	GetFontHeight(&amp;fh);</a>
<a name="ln199">	target_addr_t lineAddress = fTargetBlock-&gt;BaseAddress() + startLine</a>
<a name="ln200">		* currentCharsPerLine;</a>
<a name="ln201">	bool highlightBlock = false;</a>
<a name="ln202">	rgb_color highlightColor;</a>
<a name="ln203">	for (; currentAddress &lt; maxAddress &amp;&amp; drawPoint.y &lt; rect.bottom</a>
<a name="ln204">		+ fLineHeight; drawPoint.y += fLineHeight) {</a>
<a name="ln205">		drawPoint.x = 1.0;</a>
<a name="ln206">		snprintf(buffer, sizeof(buffer), &quot;%0*&quot; B_PRIx64,</a>
<a name="ln207">			(int)fTargetAddressSize, lineAddress);</a>
<a name="ln208">		PushState();</a>
<a name="ln209">		SetHighColor(tint_color(HighColor(), B_LIGHTEN_1_TINT));</a>
<a name="ln210">		DrawString(buffer, drawPoint);</a>
<a name="ln211">		drawPoint.x += fCharWidth * (fTargetAddressSize + 2);</a>
<a name="ln212">		PopState();</a>
<a name="ln213">		if (fHexMode != HexModeNone) {</a>
<a name="ln214">			if (currentAddress + (currentBlocksPerLine * blockByteSize)</a>
<a name="ln215">				&gt; maxAddress) {</a>
<a name="ln216">				currentCharsPerLine = maxAddress - currentAddress;</a>
<a name="ln217">				currentBlocksPerLine = currentCharsPerLine</a>
<a name="ln218">					/ blockByteSize;</a>
<a name="ln219">			}</a>
<a name="ln220"> </a>
<a name="ln221">			for (int32 j = 0; j &lt; currentBlocksPerLine; j++) {</a>
<a name="ln222">				const char* blockAddress = currentAddress + (j</a>
<a name="ln223">					* blockByteSize);</a>
<a name="ln224">				_GetNextHexBlock(buffer, sizeof(buffer), blockAddress);</a>
<a name="ln225"> </a>
<a name="ln226">				highlightBlock = false;</a>
<a name="ln227">				if (fEditMode)</a>
<a name="ln228">				{</a>
<a name="ln229">					int32 offset = blockAddress - dataSource;</a>
<a name="ln230">					for (uint32 i = 0; i &lt; blockByteSize; i++) {</a>
<a name="ln231">						if (fEditedOffsets.count(offset + i) != 0) {</a>
<a name="ln232">							highlightBlock = true;</a>
<a name="ln233">							highlightColor.set_to(0, 216, 0);</a>
<a name="ln234">							break;</a>
<a name="ln235">						}</a>
<a name="ln236">					}</a>
<a name="ln237"> </a>
<a name="ln238">				} else if (targetAddress &gt;= blockAddress &amp;&amp; targetAddress &lt;</a>
<a name="ln239">						blockAddress + blockByteSize) {</a>
<a name="ln240">						highlightBlock = true;</a>
<a name="ln241">						highlightColor.set_to(216, 0, 0);</a>
<a name="ln242">				}</a>
<a name="ln243"> </a>
<a name="ln244">				if (highlightBlock) {</a>
<a name="ln245">					PushState();</a>
<a name="ln246">					SetHighColor(highlightColor);</a>
<a name="ln247">				}</a>
<a name="ln248"> </a>
<a name="ln249">				DrawString(buffer, drawPoint);</a>
<a name="ln250"> </a>
<a name="ln251">				if (highlightBlock)</a>
<a name="ln252">					PopState();</a>
<a name="ln253"> </a>
<a name="ln254">				drawPoint.x += fCharWidth * hexBlockSize;</a>
<a name="ln255">			}</a>
<a name="ln256"> </a>
<a name="ln257">			if (currentBlocksPerLine &lt; fHexBlocksPerLine)</a>
<a name="ln258">				drawPoint.x += fCharWidth * hexBlockSize</a>
<a name="ln259">					* (fHexBlocksPerLine - currentBlocksPerLine);</a>
<a name="ln260">		}</a>
<a name="ln261"> </a>
<a name="ln262">		if (fTextMode != TextModeNone) {</a>
<a name="ln263">			drawPoint.x += fCharWidth;</a>
<a name="ln264">			for (int32 j = 0; j &lt; currentCharsPerLine; j++) {</a>
<a name="ln265">				// filter non-printable characters</a>
<a name="ln266">				textbuffer[j] = currentAddress[j] &gt; 32 ? currentAddress[j]</a>
<a name="ln267">					: '.';</a>
<a name="ln268">			}</a>
<a name="ln269">			textbuffer[fTextCharsPerLine] = '\0';</a>
<a name="ln270">			DrawString(textbuffer, drawPoint);</a>
<a name="ln271">			if (targetAddress &gt;= currentAddress &amp;&amp; targetAddress</a>
<a name="ln272">				&lt; currentAddress + currentCharsPerLine) {</a>
<a name="ln273">				PushState();</a>
<a name="ln274">				SetHighColor(B_TRANSPARENT_COLOR);</a>
<a name="ln275">				SetDrawingMode(B_OP_INVERT);</a>
<a name="ln276">				uint32 blockAddress = uint32(targetAddress - currentAddress);</a>
<a name="ln277">				if (fHexMode != HexModeNone)</a>
<a name="ln278">					blockAddress &amp;= ~(blockByteSize - 1);</a>
<a name="ln279">				float startX = drawPoint.x + fCharWidth * blockAddress;</a>
<a name="ln280">				float endX = startX;</a>
<a name="ln281">				if (fHexMode != HexModeNone)</a>
<a name="ln282">					endX += fCharWidth * ((hexBlockSize - 1) / 2);</a>
<a name="ln283">				else</a>
<a name="ln284">					endX += fCharWidth;</a>
<a name="ln285">				FillRect(BRect(startX, drawPoint.y - fh.ascent, endX,</a>
<a name="ln286">					drawPoint.y + fh.descent));</a>
<a name="ln287">				PopState();</a>
<a name="ln288">			}</a>
<a name="ln289">		}</a>
<a name="ln290">		if (currentBlocksPerLine &gt; 0) {</a>
<a name="ln291">			currentAddress += currentBlocksPerLine * blockByteSize;</a>
<a name="ln292">			lineAddress += currentBlocksPerLine * blockByteSize;</a>
<a name="ln293">		} else {</a>
<a name="ln294">			currentAddress += fTextCharsPerLine;</a>
<a name="ln295">			lineAddress += fTextCharsPerLine;</a>
<a name="ln296">		}</a>
<a name="ln297">	}</a>
<a name="ln298"> </a>
<a name="ln299">	if (fSelectionStart != fSelectionEnd) {</a>
<a name="ln300">		PushState();</a>
<a name="ln301">		BRegion selectionRegion;</a>
<a name="ln302">		_GetSelectionRegion(selectionRegion);</a>
<a name="ln303">		SetDrawingMode(B_OP_INVERT);</a>
<a name="ln304">		FillRegion(&amp;selectionRegion, B_SOLID_HIGH);</a>
<a name="ln305">		PopState();</a>
<a name="ln306">	}</a>
<a name="ln307"> </a>
<a name="ln308">	if (fEditMode) {</a>
<a name="ln309">		PushState();</a>
<a name="ln310">		BRect caretRect;</a>
<a name="ln311">		_GetEditCaretRect(caretRect);</a>
<a name="ln312">		SetDrawingMode(B_OP_INVERT);</a>
<a name="ln313">		FillRect(caretRect, B_SOLID_HIGH);</a>
<a name="ln314">		PopState();</a>
<a name="ln315"> </a>
<a name="ln316">	}</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">void</a>
<a name="ln321">MemoryView::FrameResized(float width, float height)</a>
<a name="ln322">{</a>
<a name="ln323">	BView::FrameResized(width, height);</a>
<a name="ln324">	_RecalcScrollBars();</a>
<a name="ln325">	Invalidate();</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328"> </a>
<a name="ln329">void</a>
<a name="ln330">MemoryView::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln331">{</a>
<a name="ln332">	bool handled = true;</a>
<a name="ln333">	if (fTargetBlock != NULL) {</a>
<a name="ln334">		target_addr_t newAddress = fTargetAddress;</a>
<a name="ln335">		target_addr_t maxAddress = fTargetBlock-&gt;BaseAddress()</a>
<a name="ln336">			+ fTargetBlock-&gt;Size() - 1;</a>
<a name="ln337">		int32 blockSize = 1;</a>
<a name="ln338">		if (fHexMode != HexModeNone)</a>
<a name="ln339">			blockSize = 1 &lt;&lt; (fHexMode - 1);</a>
<a name="ln340">		int32 lineCount = int32(Bounds().Height() / fLineHeight);</a>
<a name="ln341"> </a>
<a name="ln342">		switch(bytes[0]) {</a>
<a name="ln343">			case B_UP_ARROW:</a>
<a name="ln344">			{</a>
<a name="ln345">				newAddress -= blockSize * fHexBlocksPerLine;</a>
<a name="ln346">				break;</a>
<a name="ln347">			}</a>
<a name="ln348">			case B_DOWN_ARROW:</a>
<a name="ln349">			{</a>
<a name="ln350">				newAddress += blockSize * fHexBlocksPerLine;</a>
<a name="ln351">				break;</a>
<a name="ln352">			}</a>
<a name="ln353">			case B_LEFT_ARROW:</a>
<a name="ln354">			{</a>
<a name="ln355">				if (fEditMode) {</a>
<a name="ln356">					if (!fEditLowNybble)</a>
<a name="ln357">						newAddress--;</a>
<a name="ln358">					fEditLowNybble = !fEditLowNybble;</a>
<a name="ln359">					if (newAddress == fTargetAddress)</a>
<a name="ln360">						Invalidate();</a>
<a name="ln361">				} else</a>
<a name="ln362">					newAddress -= blockSize;</a>
<a name="ln363">				break;</a>
<a name="ln364">			}</a>
<a name="ln365">			case B_RIGHT_ARROW:</a>
<a name="ln366">			{</a>
<a name="ln367">				if (fEditMode) {</a>
<a name="ln368">					if (fEditLowNybble)</a>
<a name="ln369">						newAddress++;</a>
<a name="ln370">					fEditLowNybble = !fEditLowNybble;</a>
<a name="ln371">					if (newAddress == fTargetAddress)</a>
<a name="ln372">						Invalidate();</a>
<a name="ln373">				} else</a>
<a name="ln374">					newAddress += blockSize;</a>
<a name="ln375">				break;</a>
<a name="ln376">			}</a>
<a name="ln377">			case B_PAGE_UP:</a>
<a name="ln378">			{</a>
<a name="ln379">				newAddress -= (blockSize * fHexBlocksPerLine) * lineCount;</a>
<a name="ln380">				break;</a>
<a name="ln381">			}</a>
<a name="ln382">			case B_PAGE_DOWN:</a>
<a name="ln383">			{</a>
<a name="ln384">				newAddress += (blockSize * fHexBlocksPerLine) * lineCount;</a>
<a name="ln385">				break;</a>
<a name="ln386">			}</a>
<a name="ln387">			case B_HOME:</a>
<a name="ln388">			{</a>
<a name="ln389">				newAddress = fTargetBlock-&gt;BaseAddress();</a>
<a name="ln390">				fEditLowNybble = false;</a>
<a name="ln391">				break;</a>
<a name="ln392">			}</a>
<a name="ln393">			case B_END:</a>
<a name="ln394">			{</a>
<a name="ln395">				newAddress = maxAddress;</a>
<a name="ln396">				fEditLowNybble = true;</a>
<a name="ln397">				break;</a>
<a name="ln398">			}</a>
<a name="ln399">			default:</a>
<a name="ln400">			{</a>
<a name="ln401">				if (fEditMode &amp;&amp; isxdigit(bytes[0]))</a>
<a name="ln402">				{</a>
<a name="ln403">					int value = 0;</a>
<a name="ln404">					if (isdigit(bytes[0]))</a>
<a name="ln405">						value = bytes[0] - '0';</a>
<a name="ln406">					else</a>
<a name="ln407">						value = (int)strtol(bytes, NULL, 16);</a>
<a name="ln408"> </a>
<a name="ln409">					int32 byteOffset = fTargetAddress</a>
<a name="ln410">						- fTargetBlock-&gt;BaseAddress();</a>
<a name="ln411"> </a>
<a name="ln412">					if (fEditLowNybble)</a>
<a name="ln413">						value = (fEditableData[byteOffset] &amp; 0xf0) | value;</a>
<a name="ln414">					else {</a>
<a name="ln415">						value = (fEditableData[byteOffset] &amp; 0x0f)</a>
<a name="ln416">							| (value &lt;&lt; 4);</a>
<a name="ln417">					}</a>
<a name="ln418"> </a>
<a name="ln419">					fEditableData[byteOffset] = value;</a>
<a name="ln420"> </a>
<a name="ln421">					if (fEditableData[byteOffset]</a>
<a name="ln422">						!= fTargetBlock-&gt;Data()[byteOffset]) {</a>
<a name="ln423">						fEditedOffsets.insert(byteOffset);</a>
<a name="ln424">					} else</a>
<a name="ln425">						fEditedOffsets.erase(byteOffset);</a>
<a name="ln426"> </a>
<a name="ln427">					if (fEditLowNybble) {</a>
<a name="ln428">						if (newAddress &lt; maxAddress) {</a>
<a name="ln429">							newAddress++;</a>
<a name="ln430">							fEditLowNybble = false;</a>
<a name="ln431">						}</a>
<a name="ln432">					} else</a>
<a name="ln433">						fEditLowNybble = true;</a>
<a name="ln434"> </a>
<a name="ln435">					Invalidate();</a>
<a name="ln436">				} else</a>
<a name="ln437">					handled = false;</a>
<a name="ln438"> </a>
<a name="ln439">				break;</a>
<a name="ln440">			}</a>
<a name="ln441">		}</a>
<a name="ln442"> </a>
<a name="ln443">		if (handled) {</a>
<a name="ln444">			if (newAddress &lt; fTargetBlock-&gt;BaseAddress())</a>
<a name="ln445">				newAddress = fTargetAddress;</a>
<a name="ln446">			else if (newAddress &gt; maxAddress)</a>
<a name="ln447">				newAddress = maxAddress;</a>
<a name="ln448"> </a>
<a name="ln449">			if (newAddress != fTargetAddress) {</a>
<a name="ln450">				fTargetAddress = newAddress;</a>
<a name="ln451">				BMessenger(this).SendMessage(MSG_TARGET_ADDRESS_CHANGED);</a>
<a name="ln452">			}</a>
<a name="ln453">		}</a>
<a name="ln454">	} else</a>
<a name="ln455">		handled = false;</a>
<a name="ln456"> </a>
<a name="ln457">	if (!handled)</a>
<a name="ln458">		BView::KeyDown(bytes, numBytes);</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461"> </a>
<a name="ln462">void</a>
<a name="ln463">MemoryView::MakeFocus(bool isFocused)</a>
<a name="ln464">{</a>
<a name="ln465">	BScrollView* parent = dynamic_cast&lt;BScrollView*&gt;(Parent());</a>
<a name="ln466">	if (parent != NULL)</a>
<a name="ln467">		parent-&gt;SetBorderHighlighted(isFocused);</a>
<a name="ln468"> </a>
<a name="ln469">	BView::MakeFocus(isFocused);</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472"> </a>
<a name="ln473">void</a>
<a name="ln474">MemoryView::MessageReceived(BMessage* message)</a>
<a name="ln475">{</a>
<a name="ln476">	switch(message-&gt;what) {</a>
<a name="ln477">		case B_COPY:</a>
<a name="ln478">		{</a>
<a name="ln479">			_CopySelectionToClipboard();</a>
<a name="ln480">			break;</a>
<a name="ln481">		}</a>
<a name="ln482">		case MSG_TARGET_ADDRESS_CHANGED:</a>
<a name="ln483">		{</a>
<a name="ln484">			_RecalcScrollBars();</a>
<a name="ln485">			ScrollToSelection();</a>
<a name="ln486">			Invalidate();</a>
<a name="ln487">			if (fListener != NULL)</a>
<a name="ln488">				fListener-&gt;TargetAddressChanged(fTargetAddress);</a>
<a name="ln489">			break;</a>
<a name="ln490">		}</a>
<a name="ln491">		case MSG_SET_HEX_MODE:</a>
<a name="ln492">		{</a>
<a name="ln493">			// while editing, hex view changes are disallowed.</a>
<a name="ln494">			if (fEditMode)</a>
<a name="ln495">				break;</a>
<a name="ln496"> </a>
<a name="ln497">			int32 mode;</a>
<a name="ln498">			if (message-&gt;FindInt32(&quot;mode&quot;, &amp;mode) == B_OK) {</a>
<a name="ln499">				if (fHexMode == mode)</a>
<a name="ln500">					break;</a>
<a name="ln501"> </a>
<a name="ln502">				fHexMode = mode;</a>
<a name="ln503">				_RecalcScrollBars();</a>
<a name="ln504">				Invalidate();</a>
<a name="ln505"> </a>
<a name="ln506">				if (fListener != NULL)</a>
<a name="ln507">					fListener-&gt;HexModeChanged(mode);</a>
<a name="ln508">			}</a>
<a name="ln509">			break;</a>
<a name="ln510">		}</a>
<a name="ln511">		case MSG_SET_ENDIAN_MODE:</a>
<a name="ln512">		{</a>
<a name="ln513">			int32 mode;</a>
<a name="ln514">			if (message-&gt;FindInt32(&quot;mode&quot;, &amp;mode) == B_OK) {</a>
<a name="ln515">				if (fCurrentEndianMode == mode)</a>
<a name="ln516">					break;</a>
<a name="ln517"> </a>
<a name="ln518">				fCurrentEndianMode = mode;</a>
<a name="ln519">				Invalidate();</a>
<a name="ln520"> </a>
<a name="ln521">				if (fListener != NULL)</a>
<a name="ln522">					fListener-&gt;EndianModeChanged(mode);</a>
<a name="ln523">			}</a>
<a name="ln524">			break;</a>
<a name="ln525">		}</a>
<a name="ln526">		case MSG_SET_TEXT_MODE:</a>
<a name="ln527">		{</a>
<a name="ln528">			int32 mode;</a>
<a name="ln529">			if (message-&gt;FindInt32(&quot;mode&quot;, &amp;mode) == B_OK) {</a>
<a name="ln530">				if (fTextMode == mode)</a>
<a name="ln531">					break;</a>
<a name="ln532"> </a>
<a name="ln533">				fTextMode = mode;</a>
<a name="ln534">				_RecalcScrollBars();</a>
<a name="ln535">				Invalidate();</a>
<a name="ln536"> </a>
<a name="ln537">				if (fListener != NULL)</a>
<a name="ln538">					fListener-&gt;TextModeChanged(mode);</a>
<a name="ln539">			}</a>
<a name="ln540">			break;</a>
<a name="ln541">		}</a>
<a name="ln542">		case MSG_VIEW_AUTOSCROLL:</a>
<a name="ln543">		{</a>
<a name="ln544">			_HandleAutoScroll();</a>
<a name="ln545">			break;</a>
<a name="ln546">		}</a>
<a name="ln547">		default:</a>
<a name="ln548">		{</a>
<a name="ln549">			BView::MessageReceived(message);</a>
<a name="ln550">			break;</a>
<a name="ln551">		}</a>
<a name="ln552">	}</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555"> </a>
<a name="ln556">void</a>
<a name="ln557">MemoryView::MouseDown(BPoint point)</a>
<a name="ln558">{</a>
<a name="ln559">	if (!IsFocus())</a>
<a name="ln560">		MakeFocus(true);</a>
<a name="ln561"> </a>
<a name="ln562">	if (fTargetBlock == NULL)</a>
<a name="ln563">		return;</a>
<a name="ln564"> </a>
<a name="ln565">	int32 buttons;</a>
<a name="ln566">	if (Looper()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons) != B_OK)</a>
<a name="ln567">		buttons = B_PRIMARY_MOUSE_BUTTON;</a>
<a name="ln568"> </a>
<a name="ln569">	if (buttons == B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln570">		_HandleContextMenu(point);</a>
<a name="ln571">		return;</a>
<a name="ln572">	}</a>
<a name="ln573"> </a>
<a name="ln574">	int32 offset = _GetOffsetAt(point);</a>
<a name="ln575">	if (offset &lt; fSelectionStart || offset &gt; fSelectionEnd) {</a>
<a name="ln576">		BRegion oldSelectionRegion;</a>
<a name="ln577">		_GetSelectionRegion(oldSelectionRegion);</a>
<a name="ln578">		fSelectionBase = offset;</a>
<a name="ln579">		fSelectionStart = fSelectionBase;</a>
<a name="ln580">		fSelectionEnd = fSelectionBase;</a>
<a name="ln581">		Invalidate(oldSelectionRegion.Frame());</a>
<a name="ln582">	}</a>
<a name="ln583"> </a>
<a name="ln584">	SetMouseEventMask(B_POINTER_EVENTS, B_NO_POINTER_HISTORY);</a>
<a name="ln585">	fTrackingMouse = true;</a>
<a name="ln586">}</a>
<a name="ln587"> </a>
<a name="ln588"> </a>
<a name="ln589">void</a>
<a name="ln590">MemoryView::MouseMoved(BPoint point, uint32 transit, const BMessage* message)</a>
<a name="ln591">{</a>
<a name="ln592">	if (!fTrackingMouse)</a>
<a name="ln593">		return;</a>
<a name="ln594"> </a>
<a name="ln595">	BRegion oldSelectionRegion;</a>
<a name="ln596">	_GetSelectionRegion(oldSelectionRegion);</a>
<a name="ln597">	int32 offset = _GetOffsetAt(point);</a>
<a name="ln598">	if (offset &lt; fSelectionBase) {</a>
<a name="ln599">		fSelectionStart = offset;</a>
<a name="ln600">		fSelectionEnd = fSelectionBase;</a>
<a name="ln601">	} else {</a>
<a name="ln602">		fSelectionStart = fSelectionBase;</a>
<a name="ln603">		fSelectionEnd = offset;</a>
<a name="ln604">	}</a>
<a name="ln605"> </a>
<a name="ln606">	BRegion region;</a>
<a name="ln607">	_GetSelectionRegion(region);</a>
<a name="ln608">	region.Include(&amp;oldSelectionRegion);</a>
<a name="ln609">	Invalidate(region.Frame());</a>
<a name="ln610"> </a>
<a name="ln611">	switch (transit) {</a>
<a name="ln612">		case B_EXITED_VIEW:</a>
<a name="ln613">			fScrollRunner = new BMessageRunner(BMessenger(this),</a>
<a name="ln614">				new BMessage(MSG_VIEW_AUTOSCROLL), kScrollTimer);</a>
<a name="ln615">			break;</a>
<a name="ln616"> </a>
<a name="ln617">		case B_ENTERED_VIEW:</a>
<a name="ln618">			delete fScrollRunner;</a>
<a name="ln619">			fScrollRunner = NULL;</a>
<a name="ln620">			break;</a>
<a name="ln621"> </a>
<a name="ln622">		default:</a>
<a name="ln623">			break;</a>
<a name="ln624">	}</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627"> </a>
<a name="ln628">void</a>
<a name="ln629">MemoryView::MouseUp(BPoint point)</a>
<a name="ln630">{</a>
<a name="ln631">	fTrackingMouse = false;</a>
<a name="ln632">	delete fScrollRunner;</a>
<a name="ln633">	fScrollRunner = NULL;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636"> </a>
<a name="ln637">void</a>
<a name="ln638">MemoryView::ScrollToSelection()</a>
<a name="ln639">{</a>
<a name="ln640">	if (fTargetBlock != NULL) {</a>
<a name="ln641">		target_addr_t offset = fTargetAddress - fTargetBlock-&gt;BaseAddress();</a>
<a name="ln642">		int32 lineNumber = 0;</a>
<a name="ln643">		if (fHexBlocksPerLine &gt; 0) {</a>
<a name="ln644">			lineNumber = offset / (fHexBlocksPerLine</a>
<a name="ln645">				* (_GetHexDigitsPerBlock() / 2));</a>
<a name="ln646">		} else if (fTextCharsPerLine &gt; 0)</a>
<a name="ln647">			lineNumber = offset / fTextCharsPerLine;</a>
<a name="ln648"> </a>
<a name="ln649">		float y = lineNumber * fLineHeight;</a>
<a name="ln650">		if (y &lt; Bounds().top)</a>
<a name="ln651">			ScrollTo(0.0, y);</a>
<a name="ln652">		else if (y + fLineHeight &gt; Bounds().bottom)</a>
<a name="ln653">			ScrollTo(0.0, y + fLineHeight - Bounds().Height());</a>
<a name="ln654">	}</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657"> </a>
<a name="ln658">void</a>
<a name="ln659">MemoryView::TargetedByScrollView(BScrollView* scrollView)</a>
<a name="ln660">{</a>
<a name="ln661">	BView::TargetedByScrollView(scrollView);</a>
<a name="ln662">	scrollView-&gt;ScrollBar(B_VERTICAL)-&gt;SetRange(0.0, 0.0);</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665"> </a>
<a name="ln666">BSize</a>
<a name="ln667">MemoryView::MinSize()</a>
<a name="ln668">{</a>
<a name="ln669">	return BSize(0.0, 0.0);</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672"> </a>
<a name="ln673">BSize</a>
<a name="ln674">MemoryView::PreferredSize()</a>
<a name="ln675">{</a>
<a name="ln676">	return MinSize();</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679"> </a>
<a name="ln680">BSize</a>
<a name="ln681">MemoryView::MaxSize()</a>
<a name="ln682">{</a>
<a name="ln683">	return BSize(B_SIZE_UNLIMITED, B_SIZE_UNLIMITED);</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686"> </a>
<a name="ln687">void</a>
<a name="ln688">MemoryView::_Init()</a>
<a name="ln689">{</a>
<a name="ln690">	SetViewUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693"> </a>
<a name="ln694">void</a>
<a name="ln695">MemoryView::_RecalcScrollBars()</a>
<a name="ln696">{</a>
<a name="ln697">	float max = 0.0;</a>
<a name="ln698">	BScrollBar *scrollBar = ScrollBar(B_VERTICAL);</a>
<a name="ln699">	if (fTargetBlock != NULL) {</a>
<a name="ln700">		int32 hexDigits = _GetHexDigitsPerBlock();</a>
<a name="ln701">		int32 sizeFactor = 1 + hexDigits;</a>
<a name="ln702">		_RecalcBounds();</a>
<a name="ln703"> </a>
<a name="ln704">		float hexWidth = fHexRight - fHexLeft;</a>
<a name="ln705">		int32 nybblesPerLine = int32(hexWidth / fCharWidth);</a>
<a name="ln706">		fHexBlocksPerLine = 0;</a>
<a name="ln707">		fTextCharsPerLine = 0;</a>
<a name="ln708">		if (fHexMode != HexModeNone) {</a>
<a name="ln709">			fHexBlocksPerLine = nybblesPerLine / sizeFactor;</a>
<a name="ln710">			fHexBlocksPerLine &amp;= ~1;</a>
<a name="ln711">			fHexRight = fHexLeft + (fHexBlocksPerLine * sizeFactor</a>
<a name="ln712">				* fCharWidth);</a>
<a name="ln713">			if (fTextMode != TextModeNone)</a>
<a name="ln714">				fTextCharsPerLine = fHexBlocksPerLine * hexDigits / 2;</a>
<a name="ln715">		} else if (fTextMode != TextModeNone)</a>
<a name="ln716">			fTextCharsPerLine = int32((fTextRight - fTextLeft) / fCharWidth);</a>
<a name="ln717">		int32 lineCount = 0;</a>
<a name="ln718">		float totalHeight = 0.0;</a>
<a name="ln719">		if (fHexBlocksPerLine &gt; 0) {</a>
<a name="ln720">			lineCount = fTargetBlock-&gt;Size() / (fHexBlocksPerLine</a>
<a name="ln721">					* hexDigits / 2);</a>
<a name="ln722">		} else if (fTextCharsPerLine &gt; 0)</a>
<a name="ln723">			lineCount = fTargetBlock-&gt;Size() / fTextCharsPerLine;</a>
<a name="ln724"> </a>
<a name="ln725">		totalHeight = lineCount * fLineHeight;</a>
<a name="ln726">		if (totalHeight &gt; 0.0) {</a>
<a name="ln727">			BRect bounds = Bounds();</a>
<a name="ln728">			max = totalHeight - bounds.Height();</a>
<a name="ln729">			scrollBar-&gt;SetProportion(bounds.Height() / totalHeight);</a>
<a name="ln730">			scrollBar-&gt;SetSteps(fLineHeight, bounds.Height());</a>
<a name="ln731">		}</a>
<a name="ln732">	}</a>
<a name="ln733">	scrollBar-&gt;SetRange(0.0, max);</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">void</a>
<a name="ln737">MemoryView::_GetNextHexBlock(char* buffer, int32 bufferSize,</a>
<a name="ln738">	const char* address) const</a>
<a name="ln739">{</a>
<a name="ln740">	switch(fHexMode) {</a>
<a name="ln741">		case HexMode8BitInt:</a>
<a name="ln742">		{</a>
<a name="ln743">			snprintf(buffer, bufferSize, &quot;%02&quot; B_PRIx8,</a>
<a name="ln744">				*((const uint8*)address));</a>
<a name="ln745">			break;</a>
<a name="ln746">		}</a>
<a name="ln747">		case HexMode16BitInt:</a>
<a name="ln748">		{</a>
<a name="ln749">			uint16 data = *((const uint16*)address);</a>
<a name="ln750">			switch(fCurrentEndianMode)</a>
<a name="ln751">			{</a>
<a name="ln752">				case EndianModeBigEndian:</a>
<a name="ln753">				{</a>
<a name="ln754">					data = B_HOST_TO_BENDIAN_INT16(data);</a>
<a name="ln755">				}</a>
<a name="ln756">				break;</a>
<a name="ln757"> </a>
<a name="ln758">				case EndianModeLittleEndian:</a>
<a name="ln759">				{</a>
<a name="ln760">					data = B_HOST_TO_LENDIAN_INT16(data);</a>
<a name="ln761">				}</a>
<a name="ln762">				break;</a>
<a name="ln763">			}</a>
<a name="ln764">			snprintf(buffer, bufferSize, &quot;%04&quot; B_PRIx16,</a>
<a name="ln765">				data);</a>
<a name="ln766">			break;</a>
<a name="ln767">		}</a>
<a name="ln768">		case HexMode32BitInt:</a>
<a name="ln769">		{</a>
<a name="ln770">			uint32 data = *((const uint32*)address);</a>
<a name="ln771">			switch(fCurrentEndianMode)</a>
<a name="ln772">			{</a>
<a name="ln773">				case EndianModeBigEndian:</a>
<a name="ln774">				{</a>
<a name="ln775">					data = B_HOST_TO_BENDIAN_INT32(data);</a>
<a name="ln776">				}</a>
<a name="ln777">				break;</a>
<a name="ln778"> </a>
<a name="ln779">				case EndianModeLittleEndian:</a>
<a name="ln780">				{</a>
<a name="ln781">					data = B_HOST_TO_LENDIAN_INT32(data);</a>
<a name="ln782">				}</a>
<a name="ln783">				break;</a>
<a name="ln784">			}</a>
<a name="ln785">			snprintf(buffer, bufferSize, &quot;%08&quot; B_PRIx32,</a>
<a name="ln786">				data);</a>
<a name="ln787">			break;</a>
<a name="ln788">		}</a>
<a name="ln789">		case HexMode64BitInt:</a>
<a name="ln790">		{</a>
<a name="ln791">			uint64 data = *((const uint64*)address);</a>
<a name="ln792">			switch(fCurrentEndianMode)</a>
<a name="ln793">			{</a>
<a name="ln794">				case EndianModeBigEndian:</a>
<a name="ln795">				{</a>
<a name="ln796">					data = B_HOST_TO_BENDIAN_INT64(data);</a>
<a name="ln797">				}</a>
<a name="ln798">				break;</a>
<a name="ln799"> </a>
<a name="ln800">				case EndianModeLittleEndian:</a>
<a name="ln801">				{</a>
<a name="ln802">					data = B_HOST_TO_LENDIAN_INT64(data);</a>
<a name="ln803">				}</a>
<a name="ln804">				break;</a>
<a name="ln805">			}</a>
<a name="ln806">			snprintf(buffer, bufferSize, &quot;%0*&quot; B_PRIx64,</a>
<a name="ln807">				16, data);</a>
<a name="ln808">			break;</a>
<a name="ln809">		}</a>
<a name="ln810">	}</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">int32</a>
<a name="ln815">MemoryView::_GetOffsetAt(BPoint point) const</a>
<a name="ln816">{</a>
<a name="ln817">	if (fTargetBlock == NULL)</a>
<a name="ln818">		return -1;</a>
<a name="ln819"> </a>
<a name="ln820">	// TODO: support selection in the text region as well</a>
<a name="ln821">	if (fHexMode == HexModeNone)</a>
<a name="ln822">		return -1;</a>
<a name="ln823"> </a>
<a name="ln824">	int32 lineNumber = int32(point.y / fLineHeight);</a>
<a name="ln825">	int32 charsPerBlock = _GetHexDigitsPerBlock() / 2;</a>
<a name="ln826">	int32 totalHexBlocks = fTargetBlock-&gt;Size() / charsPerBlock;</a>
<a name="ln827">	int32 lineCount = totalHexBlocks / fHexBlocksPerLine;</a>
<a name="ln828"> </a>
<a name="ln829">	if (lineNumber &gt;= lineCount)</a>
<a name="ln830">		return -1;</a>
<a name="ln831"> </a>
<a name="ln832">	point.x -= fHexLeft;</a>
<a name="ln833">	if (point.x &lt; 0)</a>
<a name="ln834">		point.x = 0;</a>
<a name="ln835">	else if (point.x &gt; fHexRight)</a>
<a name="ln836">		point.x = fHexRight;</a>
<a name="ln837"> </a>
<a name="ln838">	float blockWidth = (charsPerBlock * 2 + 1) * fCharWidth;</a>
<a name="ln839">	int32 containingBlock = int32(floor(point.x / blockWidth));</a>
<a name="ln840"> </a>
<a name="ln841">	return fHexBlocksPerLine * charsPerBlock * lineNumber</a>
<a name="ln842">		+ containingBlock * charsPerBlock;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845"> </a>
<a name="ln846">BPoint</a>
<a name="ln847">MemoryView::_GetPointForOffset(int32 offset) const</a>
<a name="ln848">{</a>
<a name="ln849">	BPoint point;</a>
<a name="ln850">	if (fHexMode == HexModeNone)</a>
<a name="ln851">		return point;</a>
<a name="ln852"> </a>
<a name="ln853">	int32 bytesPerLine = fHexBlocksPerLine * _GetHexDigitsPerBlock() / 2;</a>
<a name="ln854">	int32 line = offset / bytesPerLine;</a>
<a name="ln855">	int32 lineOffset = offset % bytesPerLine;</a>
<a name="ln856"> </a>
<a name="ln857">	point.x = fHexLeft + (lineOffset * 2 * fCharWidth)</a>
<a name="ln858">			+ (lineOffset * 2 * fCharWidth / _GetHexDigitsPerBlock());</a>
<a name="ln859">	point.y = line * fLineHeight;</a>
<a name="ln860"> </a>
<a name="ln861">	return point;</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864"> </a>
<a name="ln865">void</a>
<a name="ln866">MemoryView::_RecalcBounds()</a>
<a name="ln867">{</a>
<a name="ln868">	fHexLeft = 0;</a>
<a name="ln869">	fHexRight = 0;</a>
<a name="ln870">	fTextLeft = 0;</a>
<a name="ln871">	fTextRight = 0;</a>
<a name="ln872"> </a>
<a name="ln873">	// the left bound is determined by the space taken up by the actual</a>
<a name="ln874">	// displayed addresses.</a>
<a name="ln875">	float left = _GetAddressDisplayWidth();</a>
<a name="ln876">	float width = Bounds().Width() - left;</a>
<a name="ln877"> </a>
<a name="ln878">	if (fHexMode != HexModeNone) {</a>
<a name="ln879">		int32 hexDigits = _GetHexDigitsPerBlock();</a>
<a name="ln880">		int32 sizeFactor = 1 + hexDigits;</a>
<a name="ln881">		if (fTextMode != TextModeNone) {</a>
<a name="ln882">			float hexProportion = sizeFactor / (float)(sizeFactor</a>
<a name="ln883">				+ hexDigits / 2);</a>
<a name="ln884">			float hexWidth = width * hexProportion;</a>
<a name="ln885">			fTextLeft = left + hexWidth;</a>
<a name="ln886">			fHexLeft = left;</a>
<a name="ln887">			// when sharing the display between hex and text,</a>
<a name="ln888">			// we allocate a 2 character space to separate the views</a>
<a name="ln889">			hexWidth -= 2 * fCharWidth;</a>
<a name="ln890">			fHexRight = left + hexWidth;</a>
<a name="ln891">		} else {</a>
<a name="ln892">			fHexLeft = left;</a>
<a name="ln893">			fHexRight = left + width;</a>
<a name="ln894">		}</a>
<a name="ln895">	} else if (fTextMode != TextModeNone) {</a>
<a name="ln896">		fTextLeft = left;</a>
<a name="ln897">		fTextRight = left + width;</a>
<a name="ln898">	}</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901"> </a>
<a name="ln902">float</a>
<a name="ln903">MemoryView::_GetAddressDisplayWidth() const</a>
<a name="ln904">{</a>
<a name="ln905">	return (fTargetAddressSize + 2) * fCharWidth;</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908"> </a>
<a name="ln909">void</a>
<a name="ln910">MemoryView::_GetEditCaretRect(BRect&amp; rect) const</a>
<a name="ln911">{</a>
<a name="ln912">	if (!fEditMode)</a>
<a name="ln913">		return;</a>
<a name="ln914"> </a>
<a name="ln915">	int32 byteOffset = fTargetAddress - fTargetBlock-&gt;BaseAddress();</a>
<a name="ln916">	BPoint point = _GetPointForOffset(byteOffset);</a>
<a name="ln917">	if (fEditLowNybble)</a>
<a name="ln918">		point.x += fCharWidth;</a>
<a name="ln919"> </a>
<a name="ln920">	rect.left = point.x;</a>
<a name="ln921">	rect.right = point.x + fCharWidth;</a>
<a name="ln922">	rect.top = point.y;</a>
<a name="ln923">	rect.bottom = point.y + fLineHeight;</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926"> </a>
<a name="ln927">void</a>
<a name="ln928">MemoryView::_GetSelectionRegion(BRegion&amp; region) const</a>
<a name="ln929">{</a>
<a name="ln930">	if (fHexMode == HexModeNone || fTargetBlock == NULL)</a>
<a name="ln931">		return;</a>
<a name="ln932"> </a>
<a name="ln933">	region.MakeEmpty();</a>
<a name="ln934">	BPoint startPoint = _GetPointForOffset(fSelectionStart);</a>
<a name="ln935">	BPoint endPoint = _GetPointForOffset(fSelectionEnd);</a>
<a name="ln936"> </a>
<a name="ln937">	BRect rect;</a>
<a name="ln938">	if (startPoint.y == endPoint.y) {</a>
<a name="ln939">		// single line case</a>
<a name="ln940">		rect.left = startPoint.x;</a>
<a name="ln941">		rect.top = startPoint.y;</a>
<a name="ln942">		rect.right = endPoint.x;</a>
<a name="ln943">		rect.bottom = endPoint.y + fLineHeight;</a>
<a name="ln944">		region.Include(rect);</a>
<a name="ln945">	} else {</a>
<a name="ln946">		float currentLine = startPoint.y;</a>
<a name="ln947"> </a>
<a name="ln948">		// first line</a>
<a name="ln949">		rect.left = startPoint.x;</a>
<a name="ln950">		rect.top = startPoint.y;</a>
<a name="ln951">		rect.right = fHexRight;</a>
<a name="ln952">		rect.bottom = startPoint.y + fLineHeight;</a>
<a name="ln953">		region.Include(rect);</a>
<a name="ln954">		currentLine += fLineHeight;</a>
<a name="ln955"> </a>
<a name="ln956">		// middle region</a>
<a name="ln957">		if (currentLine &lt; endPoint.y) {</a>
<a name="ln958">			rect.left = fHexLeft;</a>
<a name="ln959">			rect.top = currentLine;</a>
<a name="ln960">			rect.right = fHexRight;</a>
<a name="ln961">			rect.bottom = endPoint.y;</a>
<a name="ln962">			region.Include(rect);</a>
<a name="ln963">		}</a>
<a name="ln964"> </a>
<a name="ln965">		rect.left = fHexLeft;</a>
<a name="ln966">		rect.top = endPoint.y;</a>
<a name="ln967">		rect.right = endPoint.x;</a>
<a name="ln968">		rect.bottom = endPoint.y + fLineHeight;</a>
<a name="ln969">		region.Include(rect);</a>
<a name="ln970">	}</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973"> </a>
<a name="ln974">void</a>
<a name="ln975">MemoryView::_GetSelectedText(BString&amp; text) const</a>
<a name="ln976">{</a>
<a name="ln977">	if (fSelectionStart == fSelectionEnd)</a>
<a name="ln978">		return;</a>
<a name="ln979"> </a>
<a name="ln980">	text.Truncate(0);</a>
<a name="ln981">	const uint8* dataSource = fEditMode ? fEditableData : fTargetBlock-&gt;Data();</a>
<a name="ln982"> </a>
<a name="ln983">	const char* data = (const char *)dataSource + fSelectionStart;</a>
<a name="ln984">	int16 blockSize = _GetHexDigitsPerBlock() / 2;</a>
<a name="ln985">	int32 count = (fSelectionEnd - fSelectionStart)</a>
<a name="ln986">		/ blockSize;</a>
<a name="ln987"> </a>
<a name="ln988">	char buffer[32];</a>
<a name="ln989">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln990">		_GetNextHexBlock(buffer, sizeof(buffer), data);</a>
<a name="ln991">		data += blockSize;</a>
<a name="ln992">		text &lt;&lt; buffer;</a>
<a name="ln993">		if (i &lt; count - 1)</a>
<a name="ln994">			text &lt;&lt; &quot; &quot;;</a>
<a name="ln995">	}</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998"> </a>
<a name="ln999">void</a>
<a name="ln1000">MemoryView::_CopySelectionToClipboard()</a>
<a name="ln1001">{</a>
<a name="ln1002">	BString text;</a>
<a name="ln1003">	_GetSelectedText(text);</a>
<a name="ln1004"> </a>
<a name="ln1005">	if (text.Length() &gt; 0) {</a>
<a name="ln1006">		be_clipboard-&gt;Lock();</a>
<a name="ln1007">		be_clipboard-&gt;Data()-&gt;RemoveData(&quot;text/plain&quot;);</a>
<a name="ln1008">		be_clipboard-&gt;Data()-&gt;AddData (&quot;text/plain&quot;,</a>
<a name="ln1009">			B_MIME_TYPE, text.String(), text.Length());</a>
<a name="ln1010">		be_clipboard-&gt;Commit();</a>
<a name="ln1011">		be_clipboard-&gt;Unlock();</a>
<a name="ln1012">	}</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015"> </a>
<a name="ln1016">void</a>
<a name="ln1017">MemoryView::_HandleAutoScroll()</a>
<a name="ln1018">{</a>
<a name="ln1019">	BPoint point;</a>
<a name="ln1020">	uint32 buttons;</a>
<a name="ln1021">	GetMouse(&amp;point, &amp;buttons);</a>
<a name="ln1022">	float difference = 0.0;</a>
<a name="ln1023">	int factor = 0;</a>
<a name="ln1024">	BRect visibleRect = Bounds();</a>
<a name="ln1025">	if (point.y &lt; visibleRect.top)</a>
<a name="ln1026">		difference = point.y - visibleRect.top;</a>
<a name="ln1027">	else if (point.y &gt; visibleRect.bottom)</a>
<a name="ln1028">		difference = point.y - visibleRect.bottom;</a>
<a name="ln1029">	if (difference != 0.0) {</a>
<a name="ln1030">		factor = (int)(ceilf(difference / fLineHeight));</a>
<a name="ln1031">		_ScrollByLines(factor);</a>
<a name="ln1032">	}</a>
<a name="ln1033"> </a>
<a name="ln1034">	MouseMoved(point, B_OUTSIDE_VIEW, NULL);</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037"> </a>
<a name="ln1038">void</a>
<a name="ln1039">MemoryView::_ScrollByLines(int32 lineCount)</a>
<a name="ln1040">{</a>
<a name="ln1041">	BScrollBar* vertical = ScrollBar(B_VERTICAL);</a>
<a name="ln1042">	if (vertical == NULL)</a>
<a name="ln1043">		return;</a>
<a name="ln1044"> </a>
<a name="ln1045">	float value = vertical-&gt;Value();</a>
<a name="ln1046">	vertical-&gt;SetValue(value + fLineHeight * lineCount);</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049"> </a>
<a name="ln1050">void</a>
<a name="ln1051">MemoryView::_HandleContextMenu(BPoint point)</a>
<a name="ln1052">{</a>
<a name="ln1053">	int32 offset = _GetOffsetAt(point);</a>
<a name="ln1054">	if (offset &lt; fSelectionStart || offset &gt; fSelectionEnd)</a>
<a name="ln1055">		return;</a>
<a name="ln1056"> </a>
<a name="ln1057">	BPopUpMenu* menu = new(std::nothrow) BPopUpMenu(&quot;Options&quot;);</a>
<a name="ln1058">	if (menu == NULL)</a>
<a name="ln1059">		return;</a>
<a name="ln1060"> </a>
<a name="ln1061">	ObjectDeleter&lt;BPopUpMenu&gt; menuDeleter(menu);</a>
<a name="ln1062">	ObjectDeleter&lt;BMenuItem&gt; itemDeleter;</a>
<a name="ln1063">	ObjectDeleter&lt;BMessage&gt; messageDeleter;</a>
<a name="ln1064">	BMessage* message = NULL;</a>
<a name="ln1065">	BMenuItem* item = NULL;</a>
<a name="ln1066">	if (fSelectionEnd - fSelectionStart == fTargetAddressSize / 2) {</a>
<a name="ln1067">		BMessage* message = new(std::nothrow) BMessage(MSG_INSPECT_ADDRESS);</a>
<a name="ln1068">		if (message == NULL)</a>
<a name="ln1069">			return;</a>
<a name="ln1070"> </a>
<a name="ln1071">		target_addr_t address;</a>
<a name="ln1072">		if (fTargetAddressSize == 8)</a>
<a name="ln1073">			address = *((uint32*)(fTargetBlock-&gt;Data() + fSelectionStart));</a>
<a name="ln1074">		else</a>
<a name="ln1075">			address = *((uint64*)(fTargetBlock-&gt;Data() + fSelectionStart));</a>
<a name="ln1076"> </a>
<a name="ln1077">		if (fCurrentEndianMode == EndianModeBigEndian)</a>
<a name="ln1078">			address = B_HOST_TO_BENDIAN_INT64(address);</a>
<a name="ln1079">		else</a>
<a name="ln1080">			address = B_HOST_TO_LENDIAN_INT64(address);</a>
<a name="ln1081"> </a>
<a name="ln1082">		messageDeleter.SetTo(message);</a>
<a name="ln1083">		message-&gt;AddUInt64(&quot;address&quot;, address);</a>
<a name="ln1084">		BMenuItem* item = new(std::nothrow) BMenuItem(&quot;Inspect&quot;, message);</a>
<a name="ln1085">		if (item == NULL)</a>
<a name="ln1086">			return;</a>
<a name="ln1087"> </a>
<a name="ln1088">		messageDeleter.Detach();</a>
<a name="ln1089">		itemDeleter.SetTo(item);</a>
<a name="ln1090">		if (!menu-&gt;AddItem(item))</a>
<a name="ln1091">			return;</a>
<a name="ln1092"> </a>
<a name="ln1093">		item-&gt;SetTarget(Looper());</a>
<a name="ln1094">		itemDeleter.Detach();</a>
<a name="ln1095">	}</a>
<a name="ln1096"> </a>
<a name="ln1097">	message = new(std::nothrow) BMessage(B_COPY);</a>
<a name="ln1098">	if (message == NULL)</a>
<a name="ln1099">		return;</a>
<a name="ln1100"> </a>
<a name="ln1101">	messageDeleter.SetTo(message);</a>
<a name="ln1102">	item = new(std::nothrow) BMenuItem(&quot;Copy&quot;, message);</a>
<a name="ln1103">	if (item == NULL)</a>
<a name="ln1104">		return;</a>
<a name="ln1105"> </a>
<a name="ln1106">	messageDeleter.Detach();</a>
<a name="ln1107">	itemDeleter.SetTo(item);</a>
<a name="ln1108">	if (!menu-&gt;AddItem(item))</a>
<a name="ln1109">		return;</a>
<a name="ln1110"> </a>
<a name="ln1111">	item-&gt;SetTarget(this);</a>
<a name="ln1112">	itemDeleter.Detach();</a>
<a name="ln1113">	menuDeleter.Detach();</a>
<a name="ln1114"> </a>
<a name="ln1115">	BPoint screenWhere(point);</a>
<a name="ln1116">	ConvertToScreen(&amp;screenWhere);</a>
<a name="ln1117">	BRect mouseRect(screenWhere, screenWhere);</a>
<a name="ln1118">	mouseRect.InsetBy(-4.0, -4.0);</a>
<a name="ln1119">	menu-&gt;Go(screenWhere, true, false, mouseRect, true);</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122"> </a>
<a name="ln1123">status_t</a>
<a name="ln1124">MemoryView::_SetupEditableData()</a>
<a name="ln1125">{</a>
<a name="ln1126">	fEditableData = new(std::nothrow) uint8[fTargetBlock-&gt;Size()];</a>
<a name="ln1127">	if (fEditableData == NULL)</a>
<a name="ln1128">		return B_NO_MEMORY;</a>
<a name="ln1129"> </a>
<a name="ln1130">	memcpy(fEditableData, fTargetBlock-&gt;Data(), fTargetBlock-&gt;Size());</a>
<a name="ln1131"> </a>
<a name="ln1132">	if (fHexMode != HexMode8BitInt) {</a>
<a name="ln1133">		fHexMode = HexMode8BitInt;</a>
<a name="ln1134">		if (fListener != NULL)</a>
<a name="ln1135">			fListener-&gt;HexModeChanged(fHexMode);</a>
<a name="ln1136"> </a>
<a name="ln1137">		_RecalcScrollBars();</a>
<a name="ln1138">	}</a>
<a name="ln1139"> </a>
<a name="ln1140">	return B_OK;</a>
<a name="ln1141">}</a>
<a name="ln1142"> </a>
<a name="ln1143"> </a>
<a name="ln1144">//#pragma mark - Listener</a>
<a name="ln1145"> </a>
<a name="ln1146"> </a>
<a name="ln1147">MemoryView::Listener::~Listener()</a>
<a name="ln1148">{</a>
<a name="ln1149">}</a>

</code></pre>
<div class="balloon" rel="40"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fHexLeft, fHexRight, fTextLeft, fTextRight.</p></div>
<div class="balloon" rel="802"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'data' variable is assigned to itself.</p></div>
<div class="balloon" rel="165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'rect' is always rewritten in function body before being used.</p></div>
<div class="balloon" rel="760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'data' variable is assigned to itself.</p></div>
<div class="balloon" rel="1080"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'address' variable is assigned to itself.</p></div>
<div class="balloon" rel="781"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'data' variable is assigned to itself.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
