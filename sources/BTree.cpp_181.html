
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>BTree.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2017, Chế Vũ Gia Hy, cvghy116@gmail.com.</a>
<a name="ln3"> * Copyright 2011, Jérôme Duval, korli@users.berlios.de.</a>
<a name="ln4"> * Copyright 2001-2010, Axel Dörfler, axeld@pinc-software.de.</a>
<a name="ln5"> * This file may be used under the terms of the MIT License.</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">//! BTree implementation</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;BTree.h&quot;</a>
<a name="ln13">#include &quot;Journal.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;algorithm&gt;</a>
<a name="ln16"> </a>
<a name="ln17"> </a>
<a name="ln18">//#define TRACE_BTRFS</a>
<a name="ln19">#ifdef TRACE_BTRFS</a>
<a name="ln20">#	define TRACE(x...) dprintf(&quot;\33[34mbtrfs:\33[0m &quot; x)</a>
<a name="ln21">#else</a>
<a name="ln22">#	define TRACE(x...) ;</a>
<a name="ln23">#endif</a>
<a name="ln24">#	define ERROR(x...) dprintf(&quot;\33[34mbtrfs:\33[0m &quot; x)</a>
<a name="ln25"> </a>
<a name="ln26"> </a>
<a name="ln27">BTree::Node::Node(Volume* volume)</a>
<a name="ln28">	:</a>
<a name="ln29">	fNode(NULL),</a>
<a name="ln30">	fVolume(volume),</a>
<a name="ln31">	fBlockNumber(0),</a>
<a name="ln32">	fWritable(false)</a>
<a name="ln33">{</a>
<a name="ln34">}</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">BTree::Node::Node(Volume* volume, off_t block)</a>
<a name="ln38">	:</a>
<a name="ln39">	fNode(NULL),</a>
<a name="ln40">	fVolume(volume),</a>
<a name="ln41">	fBlockNumber(0),</a>
<a name="ln42">	fWritable(false)</a>
<a name="ln43">{</a>
<a name="ln44">	SetTo(block);</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">BTree::Node::~Node()</a>
<a name="ln49">{</a>
<a name="ln50">	Unset();</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">void</a>
<a name="ln55">BTree::Node::Keep()</a>
<a name="ln56">{</a>
<a name="ln57">	fNode = NULL;</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">void</a>
<a name="ln62">BTree::Node::Unset()</a>
<a name="ln63">{</a>
<a name="ln64">	if (fNode != NULL) {</a>
<a name="ln65">		block_cache_put(fVolume-&gt;BlockCache(), fBlockNumber);</a>
<a name="ln66">		fNode = NULL;</a>
<a name="ln67">	}</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">void</a>
<a name="ln72">BTree::Node::SetTo(off_t block)</a>
<a name="ln73">{</a>
<a name="ln74">	Unset();</a>
<a name="ln75">	fBlockNumber = block;</a>
<a name="ln76">	fNode = (btrfs_stream*)block_cache_get(fVolume-&gt;BlockCache(), block);</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79"> </a>
<a name="ln80">void</a>
<a name="ln81">BTree::Node::SetToWritable(off_t block, int32 transactionId, bool empty)</a>
<a name="ln82">{</a>
<a name="ln83">	Unset();</a>
<a name="ln84">	fBlockNumber = block;</a>
<a name="ln85">	fWritable = true;</a>
<a name="ln86">	if (empty) {</a>
<a name="ln87">		fNode = (btrfs_stream*)block_cache_get_empty(fVolume-&gt;BlockCache(),</a>
<a name="ln88">			block, transactionId);</a>
<a name="ln89">	} else {</a>
<a name="ln90">		fNode = (btrfs_stream*)block_cache_get_writable(fVolume-&gt;BlockCache(),</a>
<a name="ln91">			block, transactionId);</a>
<a name="ln92">	}</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">status_t</a>
<a name="ln97">BTree::Node::SearchSlot(const btrfs_key&amp; key, int* slot, btree_traversing type)</a>
<a name="ln98">	const</a>
<a name="ln99">{</a>
<a name="ln100">	// binary search for item slot in a node</a>
<a name="ln101">	int entrySize = sizeof(btrfs_entry);</a>
<a name="ln102">	if (Level() != 0) {</a>
<a name="ln103">		// internal node</a>
<a name="ln104">		entrySize = sizeof(btrfs_index);</a>
<a name="ln105">	}</a>
<a name="ln106"> </a>
<a name="ln107">	int high = ItemCount();</a>
<a name="ln108">	int low = 0, mid = 0, comp = 0;</a>
<a name="ln109">	uint8* base = (uint8*)fNode + sizeof(btrfs_header);</a>
<a name="ln110">	const btrfs_key* other;</a>
<a name="ln111">	while (low &lt; high) {</a>
<a name="ln112">		mid = (low + high) / 2;</a>
<a name="ln113">		other = (const btrfs_key*)(base + mid * entrySize);</a>
<a name="ln114">		comp = key.Compare(*other);</a>
<a name="ln115">		if (comp &lt; 0)</a>
<a name="ln116">			high = mid;</a>
<a name="ln117">		else if (comp &gt; 0)</a>
<a name="ln118">			low = mid + 1;</a>
<a name="ln119">		else {</a>
<a name="ln120">			*slot = mid;</a>
<a name="ln121">			return B_OK;		// if key is in node</a>
<a name="ln122">		}</a>
<a name="ln123">	}</a>
<a name="ln124"> </a>
<a name="ln125">	// |--item1--|--item2--|--item3--|--etc--|</a>
<a name="ln126">	//     m-1        m        m+1</a>
<a name="ln127">	//           k          		: comp &lt; 0</a>
<a name="ln128">	//                     k		: comp &gt; 0</a>
<a name="ln129">	if (type == BTREE_BACKWARD &amp;&amp; comp &lt; 0)</a>
<a name="ln130">		mid--;</a>
<a name="ln131">	else if (type == BTREE_FORWARD &amp;&amp; comp &gt; 0)</a>
<a name="ln132">		mid++;</a>
<a name="ln133"> </a>
<a name="ln134">	if (type == BTREE_EXACT || mid &lt; 0)</a>
<a name="ln135">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln136"> </a>
<a name="ln137">	*slot = mid;</a>
<a name="ln138">	TRACE(&quot;SearchSlot() found slot %&quot; B_PRId32 &quot; comp %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln139">		*slot, comp);</a>
<a name="ln140">	return B_OK;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143"> </a>
<a name="ln144">/*</a>
<a name="ln145"> * calculate used space except the header.</a>
<a name="ln146"> * type is only for leaf node</a>
<a name="ln147"> * type 1: only item space</a>
<a name="ln148"> * type 2: only item data space</a>
<a name="ln149"> * type 3: both type 1 and 2</a>
<a name="ln150"> */</a>
<a name="ln151">int</a>
<a name="ln152">BTree::Node::_CalculateSpace(uint32 from, uint32 to, uint8 type) const</a>
<a name="ln153">{</a>
<a name="ln154">	if (to &lt; from || to &gt;= ItemCount())</a>
<a name="ln155">		return 0;</a>
<a name="ln156"> </a>
<a name="ln157">	if (Level() != 0)</a>
<a name="ln158">		return sizeof(btrfs_index) * (to - from + 1);</a>
<a name="ln159"> </a>
<a name="ln160">	uint32 result = 0;</a>
<a name="ln161">	if ((type &amp; 1) == 1) {</a>
<a name="ln162">		result += sizeof(btrfs_entry) * (to - from + 1);</a>
<a name="ln163">	}</a>
<a name="ln164">	if ((type &amp; 2) == 2) {</a>
<a name="ln165">		result += Item(from)-&gt;Offset() + Item(from)-&gt;Size()</a>
<a name="ln166">			- Item(to)-&gt;Offset();</a>
<a name="ln167">	}</a>
<a name="ln168"> </a>
<a name="ln169">	return result;</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">int</a>
<a name="ln174">BTree::Node::SpaceUsed() const</a>
<a name="ln175">{</a>
<a name="ln176">	if (Level() == 0)</a>
<a name="ln177">		return _CalculateSpace(0, ItemCount() - 1, 3);</a>
<a name="ln178">	return _CalculateSpace(0, ItemCount() - 1, 0);</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182">int</a>
<a name="ln183">BTree::Node::SpaceLeft() const</a>
<a name="ln184">{</a>
<a name="ln185">	return fVolume-&gt;BlockSize() - SpaceUsed() - sizeof(btrfs_header);</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">void</a>
<a name="ln190">BTree::Node::_Copy(const Node* origin, uint32 at, uint32 from, uint32 to,</a>
<a name="ln191">	int length) const</a>
<a name="ln192">{</a>
<a name="ln193">	TRACE(&quot;Node::_Copy() at: %d from: %d to: %d length: %d\n&quot;,</a>
<a name="ln194">		at, from, to, length);</a>
<a name="ln195"> </a>
<a name="ln196">	if (Level() == 0) {</a>
<a name="ln197">		memcpy(Item(at), origin-&gt;Item(from), origin-&gt;_CalculateSpace(from, to));</a>
<a name="ln198">		// Item offset of copied node must be changed to get the</a>
<a name="ln199">		// item data offset correctly. length can be zero</a>
<a name="ln200">		// but let it there doesn't harm anything.</a>
<a name="ln201">		for (uint32 i = at; i - at &lt;= to - from; ++i)</a>
<a name="ln202">			Item(i)-&gt;SetOffset(Item(i)-&gt;Offset() - length);</a>
<a name="ln203"> </a>
<a name="ln204">		memcpy(ItemData(at + to - from), origin-&gt;ItemData(to),</a>
<a name="ln205">			origin-&gt;_CalculateSpace(from, to, 2));</a>
<a name="ln206">	} else {</a>
<a name="ln207">		memcpy(Index(at), origin-&gt;Index(from),</a>
<a name="ln208">			origin-&gt;_CalculateSpace(from, to));</a>
<a name="ln209">	}</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212"> </a>
<a name="ln213">status_t</a>
<a name="ln214">BTree::Node::_SpaceCheck(int length) const</a>
<a name="ln215">{</a>
<a name="ln216">	// this is a little bit weird here because we can't find</a>
<a name="ln217">	// any suitable error code</a>
<a name="ln218">	if (length &lt; 0 &amp;&amp; std::abs(length) &gt;= SpaceUsed())</a>
<a name="ln219">		return B_DIRECTORY_NOT_EMPTY;	// not enough data to delete</a>
<a name="ln220">	if (length &gt; 0 &amp;&amp; length &gt;= SpaceLeft())</a>
<a name="ln221">		return B_DEVICE_FULL;			// no spare space</a>
<a name="ln222">	return B_OK;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">/*</a>
<a name="ln227"> * copy node header, items and items data</a>
<a name="ln228"> * length is size to insert/remove</a>
<a name="ln229"> * if node is a internal node, length isnt used</a>
<a name="ln230"> * length = 0: Copy a whole</a>
<a name="ln231"> * length &lt; 0: removing</a>
<a name="ln232"> * length &gt; 0: inserting</a>
<a name="ln233"> */</a>
<a name="ln234">status_t</a>
<a name="ln235">BTree::Node::Copy(const Node* origin, uint32 start, uint32 end, int length)</a>
<a name="ln236">	const</a>
<a name="ln237">{</a>
<a name="ln238">	status_t status = origin-&gt;_SpaceCheck(length);</a>
<a name="ln239">	if (status != B_OK)</a>
<a name="ln240">		return status;</a>
<a name="ln241"> </a>
<a name="ln242">	memcpy(fNode, origin-&gt;fNode, sizeof(btrfs_header));</a>
<a name="ln243">	if (length == 0) {</a>
<a name="ln244">		// like removing [0, start - 1] and keeping [start, end]</a>
<a name="ln245">		length = -origin-&gt;_CalculateSpace(0, start - 1, 2);</a>
<a name="ln246">		_Copy(origin, 0, start, end, length);</a>
<a name="ln247">	} else if (length &lt; 0) {</a>
<a name="ln248">		// removing all items in [start, end]</a>
<a name="ln249">		if (start &gt; 0)</a>
<a name="ln250">			_Copy(origin, 0, 0, start - 1, 0);	// &lt;-- [start,...</a>
<a name="ln251">		if (end + 1 &lt; origin-&gt;ItemCount()) {</a>
<a name="ln252">			// ..., end] --&gt;</a>
<a name="ln253">			// we only care data size</a>
<a name="ln254">			length += origin-&gt;_CalculateSpace(start, end);</a>
<a name="ln255">			_Copy(origin, start, end + 1, origin-&gt;ItemCount() - 1, length);</a>
<a name="ln256">		}</a>
<a name="ln257">	} else {</a>
<a name="ln258">		// inserting in [start, end] - make a hole for later</a>
<a name="ln259">		if (start &gt; 0)</a>
<a name="ln260">			_Copy(origin, 0, 0, start - 1, 0);</a>
<a name="ln261">		if (start &lt; origin-&gt;ItemCount()) {</a>
<a name="ln262">			length -= origin-&gt;_CalculateSpace(start, end);</a>
<a name="ln263">			_Copy(origin, end + 1, start, origin-&gt;ItemCount() - 1, length);</a>
<a name="ln264">		}</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	return B_OK;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270"> </a>
<a name="ln271">/* Like copy but here we use memmove on current node.</a>
<a name="ln272"> */</a>
<a name="ln273">status_t</a>
<a name="ln274">BTree::Node::MoveEntries(uint32 start, uint32 end, int length) const</a>
<a name="ln275">{</a>
<a name="ln276">	status_t status = _SpaceCheck(length);</a>
<a name="ln277">	if (status != B_OK || length == 0/*B_OK*/)</a>
<a name="ln278">		return status;</a>
<a name="ln279"> </a>
<a name="ln280">	int entrySize = sizeof(btrfs_entry);</a>
<a name="ln281">	if (Level() != 0)</a>
<a name="ln282">		entrySize = sizeof(btrfs_index);</a>
<a name="ln283"> </a>
<a name="ln284">	uint8* base = (uint8*)fNode + sizeof(btrfs_header);</a>
<a name="ln285">	end++;</a>
<a name="ln286">	if (length &lt; 0) {</a>
<a name="ln287">		// removing [start, end]</a>
<a name="ln288">		TRACE(&quot;Node::MoveEntries() removing ... start %&quot; B_PRIu32 &quot; end %&quot;</a>
<a name="ln289">			B_PRIu32 &quot; length %i\n&quot;, start, end, length);</a>
<a name="ln290">		length += _CalculateSpace(start, end - 1);</a>
<a name="ln291">	} else {</a>
<a name="ln292">		// length &gt; 0</a>
<a name="ln293">		// inserting into [start, end] - make room for later</a>
<a name="ln294">		TRACE(&quot;Node::MoveEntries() inserting ... start %&quot; B_PRIu32 &quot; end %&quot;</a>
<a name="ln295">			B_PRIu32 &quot; length %i\n&quot;, start, end, length);</a>
<a name="ln296">		length -= _CalculateSpace(start, end - 1);</a>
<a name="ln297">		std::swap(start, end);</a>
<a name="ln298">	}</a>
<a name="ln299"> </a>
<a name="ln300">	if (end &gt;= ItemCount())</a>
<a name="ln301">		return B_OK;</a>
<a name="ln302"> </a>
<a name="ln303">	int dataSize = _CalculateSpace(end, ItemCount() - 1, 2);</a>
<a name="ln304">	// moving items/block pointers</a>
<a name="ln305">	memmove(base + start * entrySize, base + end * entrySize,</a>
<a name="ln306">		_CalculateSpace(end, ItemCount() - 1));</a>
<a name="ln307">	if (Level() == 0) {</a>
<a name="ln308">		// moving item data</a>
<a name="ln309">		int num = start - end;</a>
<a name="ln310">		for (uint32 i = start; i &lt; ItemCount() + num; ++i)</a>
<a name="ln311">			Item(i)-&gt;SetOffset(Item(i)-&gt;Offset() - length);</a>
<a name="ln312"> </a>
<a name="ln313">		memmove(ItemData(ItemCount() - 1) - length, ItemData(ItemCount() - 1),</a>
<a name="ln314">			dataSize);</a>
<a name="ln315">	}</a>
<a name="ln316"> </a>
<a name="ln317">	return B_OK;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">//	#pragma mark - BTree::Path implementation</a>
<a name="ln322"> </a>
<a name="ln323"> </a>
<a name="ln324">BTree::Path::Path(BTree* tree)</a>
<a name="ln325">	:</a>
<a name="ln326">	fTree(tree)</a>
<a name="ln327">{</a>
<a name="ln328">	for (int i = 0; i &lt; BTRFS_MAX_TREE_DEPTH; ++i) {</a>
<a name="ln329">		fNodes[i] = NULL;</a>
<a name="ln330">		fSlots[i] = 0;</a>
<a name="ln331">	}</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">BTree::Path::~Path()</a>
<a name="ln336">{</a>
<a name="ln337">	for (int i = 0; i &lt; BTRFS_MAX_TREE_DEPTH; ++i) {</a>
<a name="ln338">		delete fNodes[i];</a>
<a name="ln339">		fNodes[i] = NULL;</a>
<a name="ln340">		fSlots[i] = 0;</a>
<a name="ln341">	}</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344"> </a>
<a name="ln345">BTree::Node*</a>
<a name="ln346">BTree::Path::GetNode(int level, int* _slot) const</a>
<a name="ln347">{</a>
<a name="ln348">	if (_slot != NULL)</a>
<a name="ln349">		*_slot = fSlots[level];</a>
<a name="ln350">	return fNodes[level];</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353"> </a>
<a name="ln354">BTree::Node*</a>
<a name="ln355">BTree::Path::SetNode(off_t block, int slot)</a>
<a name="ln356">{</a>
<a name="ln357">	Node node(fTree-&gt;SystemVolume(), block);</a>
<a name="ln358">	return SetNode(&amp;node, slot);</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361"> </a>
<a name="ln362">BTree::Node*</a>
<a name="ln363">BTree::Path::SetNode(const Node* node, int slot)</a>
<a name="ln364">{</a>
<a name="ln365">	uint8 level = node-&gt;Level();</a>
<a name="ln366">	if (fNodes[level] == NULL) {</a>
<a name="ln367">		fNodes[level] = new Node(fTree-&gt;SystemVolume(), node-&gt;BlockNum());</a>
<a name="ln368">		if (fNodes[level] == NULL)</a>
<a name="ln369">			return NULL;</a>
<a name="ln370">	} else</a>
<a name="ln371">		fNodes[level]-&gt;SetTo(node-&gt;BlockNum());</a>
<a name="ln372"> </a>
<a name="ln373">	if (slot == -1)</a>
<a name="ln374">		fSlots[level] = fNodes[level]-&gt;ItemCount() - 1;</a>
<a name="ln375">	else</a>
<a name="ln376">		fSlots[level] = slot;</a>
<a name="ln377">	return fNodes[level];</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">int</a>
<a name="ln382">BTree::Path::Move(int level, int step)</a>
<a name="ln383">{</a>
<a name="ln384">	fSlots[level] += step;</a>
<a name="ln385">	if (fSlots[level] &lt; 0)</a>
<a name="ln386">		return -1;</a>
<a name="ln387">	if (fSlots[level] &gt;= fNodes[level]-&gt;ItemCount())</a>
<a name="ln388">		return 1;</a>
<a name="ln389">	return 0;</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392"> </a>
<a name="ln393">status_t</a>
<a name="ln394">BTree::Path::GetEntry(int slot, btrfs_key* _key, void** _value, uint32* _size,</a>
<a name="ln395">	uint32* _offset)</a>
<a name="ln396">{</a>
<a name="ln397">	BTree::Node* leaf = fNodes[0];</a>
<a name="ln398">	if (slot &lt; 0 || slot &gt;= leaf-&gt;ItemCount())</a>
<a name="ln399">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln400"> </a>
<a name="ln401">	if (_key != NULL)</a>
<a name="ln402">		*_key = leaf-&gt;Item(slot)-&gt;key;</a>
<a name="ln403"> </a>
<a name="ln404">	uint32 itemSize = leaf-&gt;Item(slot)-&gt;Size();</a>
<a name="ln405">	if (_value != NULL) {</a>
<a name="ln406">		*_value = malloc(itemSize);</a>
<a name="ln407">		if (*_value == NULL)</a>
<a name="ln408">			return B_NO_MEMORY;</a>
<a name="ln409"> </a>
<a name="ln410">		memcpy(*_value, leaf-&gt;ItemData(slot), itemSize);</a>
<a name="ln411">	}</a>
<a name="ln412"> </a>
<a name="ln413">	if (_size != NULL)</a>
<a name="ln414">		*_size = itemSize;</a>
<a name="ln415"> </a>
<a name="ln416">	if (_offset != NULL)</a>
<a name="ln417">		*_offset = leaf-&gt;Item(slot)-&gt;Offset();</a>
<a name="ln418"> </a>
<a name="ln419">	return B_OK;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">status_t</a>
<a name="ln424">BTree::Path::SetEntry(int slot, const btrfs_entry&amp; entry, void* value)</a>
<a name="ln425">{</a>
<a name="ln426">	if (slot &lt; 0)</a>
<a name="ln427">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln428"> </a>
<a name="ln429">	memcpy(fNodes[0]-&gt;Item(slot), &amp;entry, sizeof(btrfs_entry));</a>
<a name="ln430">	memcpy(fNodes[0]-&gt;ItemData(slot), value, entry.Size());</a>
<a name="ln431">	return B_OK;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434"> </a>
<a name="ln435">/*</a>
<a name="ln436"> * Allocate and copy block and do all the changes that it can.</a>
<a name="ln437"> * for now, we only copy-on-write tree block,</a>
<a name="ln438"> * file data is &quot;nocow&quot; by default.</a>
<a name="ln439"> *</a>
<a name="ln440"> * 	o	parent	o</a>
<a name="ln441"> * 	|	 ===&gt; 	 \</a>
<a name="ln442"> * 	o	      	x o</a>
<a name="ln443"> */</a>
<a name="ln444">status_t</a>
<a name="ln445">BTree::Path::CopyOnWrite(Transaction&amp; transaction, int level, uint32 start,</a>
<a name="ln446">	int num, int length)</a>
<a name="ln447">{</a>
<a name="ln448">	Node* node = fNodes[level];</a>
<a name="ln449">	if (node == NULL)</a>
<a name="ln450">		return B_BAD_VALUE;</a>
<a name="ln451"> </a>
<a name="ln452">	status_t status;</a>
<a name="ln453">	if (transaction.HasBlock(node-&gt;BlockNum())) {</a>
<a name="ln454">		// cow-ed block can not be cow-ed again</a>
<a name="ln455">		status = node-&gt;MoveEntries(start, start + num - 1, length);</a>
<a name="ln456">		if (status != B_OK)</a>
<a name="ln457">			return status;</a>
<a name="ln458"> </a>
<a name="ln459">		node-&gt;SetGeneration(transaction.SystemID());</a>
<a name="ln460">		if (length &lt; 0)</a>
<a name="ln461">			node-&gt;SetItemCount(node-&gt;ItemCount() - num);</a>
<a name="ln462">		else if (length &gt; 0)</a>
<a name="ln463">			node-&gt;SetItemCount(node-&gt;ItemCount() + num);</a>
<a name="ln464"> </a>
<a name="ln465">		return B_OK;</a>
<a name="ln466">	}</a>
<a name="ln467"> </a>
<a name="ln468">	uint64 address;</a>
<a name="ln469">	fsblock_t block;</a>
<a name="ln470">	status = fTree-&gt;SystemVolume()-&gt;GetNewBlock(address, block);</a>
<a name="ln471">	if (status != B_OK)</a>
<a name="ln472">		return status;</a>
<a name="ln473"> </a>
<a name="ln474">	fNodes[level] = new(std::nothrow) BTree::Node(fTree-&gt;SystemVolume());</a>
<a name="ln475">	if (fNodes[level] == NULL)</a>
<a name="ln476">		return B_NO_MEMORY;</a>
<a name="ln477"> </a>
<a name="ln478">	fNodes[level]-&gt;SetToWritable(block, transaction.ID(), true);</a>
<a name="ln479"> </a>
<a name="ln480">	status = fNodes[level]-&gt;Copy(node, start, start + num - 1, length);</a>
<a name="ln481">	if (status != B_OK)</a>
<a name="ln482">		return status;</a>
<a name="ln483"> </a>
<a name="ln484">	fNodes[level]-&gt;SetGeneration(transaction.SystemID());</a>
<a name="ln485">	fNodes[level]-&gt;SetLogicalAddress(address);</a>
<a name="ln486">	if (length &lt; 0)</a>
<a name="ln487">		fNodes[level]-&gt;SetItemCount(node-&gt;ItemCount() - num);</a>
<a name="ln488">	else if (length &gt; 0)</a>
<a name="ln489">		fNodes[level]-&gt;SetItemCount(node-&gt;ItemCount() + num);</a>
<a name="ln490">	else</a>
<a name="ln491">		fNodes[level]-&gt;SetItemCount(num);</a>
<a name="ln492"> </a>
<a name="ln493">	// change pointer of this node in parent</a>
<a name="ln494">	int parentSlot;</a>
<a name="ln495">	Node* parentNode = GetNode(level + 1, &amp;parentSlot);</a>
<a name="ln496">	if (parentNode != NULL)</a>
<a name="ln497">		parentNode-&gt;Index(parentSlot)-&gt;SetLogicalAddress(address);</a>
<a name="ln498"> </a>
<a name="ln499">	if (level == fTree-&gt;RootLevel())</a>
<a name="ln500">		fTree-&gt;SetRoot(fNodes[level]);</a>
<a name="ln501"> </a>
<a name="ln502">	delete node;</a>
<a name="ln503">	return B_OK;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506"> </a>
<a name="ln507">/* Copy-On-Write all internal nodes start from a specific level.</a>
<a name="ln508"> * level &gt; 0: to root</a>
<a name="ln509"> * level &lt;= 0: to leaf</a>
<a name="ln510"> *</a>
<a name="ln511"> *		path	cow-path       path    cow-path</a>
<a name="ln512"> *	=================================================</a>
<a name="ln513"> *		root	cow-root       root	level &lt; 0</a>
<a name="ln514"> *		 |  	|               |</a>
<a name="ln515"> *		 n1 	cow-n1         ...______</a>
<a name="ln516"> *		 |  	|               |       \</a>
<a name="ln517"> *		 n2 	cow-n2          n1     cow-n1</a>
<a name="ln518"> *		 |  	/               |        |</a>
<a name="ln519"> *		...____/                n2     cow-n2</a>
<a name="ln520"> *		 |  	                |        |</a>
<a name="ln521"> *		leaf	level &gt; 0      leaf    cow-leaf</a>
<a name="ln522"> */</a>
<a name="ln523">status_t</a>
<a name="ln524">BTree::Path::InternalCopy(Transaction&amp; transaction, int level)</a>
<a name="ln525">{</a>
<a name="ln526">	if (std::abs(level) &gt;= fTree-&gt;RootLevel())</a>
<a name="ln527">		return B_OK;</a>
<a name="ln528"> </a>
<a name="ln529">	TRACE(&quot;Path::InternalCopy() level %i\n&quot;, level);</a>
<a name="ln530">	int from, to;</a>
<a name="ln531">	if (level &gt; 0) {</a>
<a name="ln532">		from = level;</a>
<a name="ln533">		to = fTree-&gt;RootLevel();</a>
<a name="ln534">	} else {</a>
<a name="ln535">		from = 0;</a>
<a name="ln536">		to = std::abs(level);</a>
<a name="ln537">	}</a>
<a name="ln538"> </a>
<a name="ln539">	Node* node = NULL;</a>
<a name="ln540">	status_t status;</a>
<a name="ln541">	while (from &lt;= to) {</a>
<a name="ln542">		node = fNodes[from];</a>
<a name="ln543">		status = CopyOnWrite(transaction, from, 0, node-&gt;ItemCount(), 0);</a>
<a name="ln544">		from++;</a>
<a name="ln545">		if (status != B_OK)</a>
<a name="ln546">			return status;</a>
<a name="ln547">	}</a>
<a name="ln548"> </a>
<a name="ln549">	return B_OK;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552"> </a>
<a name="ln553">//	#pragma mark - BTree implementation</a>
<a name="ln554"> </a>
<a name="ln555"> </a>
<a name="ln556">BTree::BTree(Volume* volume)</a>
<a name="ln557">	:</a>
<a name="ln558">	fRootBlock(0),</a>
<a name="ln559">	fRootLevel(0),</a>
<a name="ln560">	fVolume(volume)</a>
<a name="ln561">{</a>
<a name="ln562">	mutex_init(&amp;fIteratorLock, &quot;btrfs b+tree iterator&quot;);</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565"> </a>
<a name="ln566">BTree::BTree(Volume* volume, btrfs_stream* stream)</a>
<a name="ln567">	:</a>
<a name="ln568">	fRootBlock(0),</a>
<a name="ln569">	fRootLevel(0),</a>
<a name="ln570">	fVolume(volume)</a>
<a name="ln571">{</a>
<a name="ln572">	mutex_init(&amp;fIteratorLock, &quot;btrfs b+tree iterator&quot;);</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575"> </a>
<a name="ln576">BTree::BTree(Volume* volume, fsblock_t rootBlock)</a>
<a name="ln577">	:</a>
<a name="ln578">	fRootBlock(rootBlock),</a>
<a name="ln579">	fVolume(volume)</a>
<a name="ln580">{</a>
<a name="ln581">	mutex_init(&amp;fIteratorLock, &quot;btrfs b+tree iterator&quot;);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">BTree::~BTree()</a>
<a name="ln586">{</a>
<a name="ln587">	// if there are any TreeIterators left, we need to stop them</a>
<a name="ln588">	// (can happen when the tree's inode gets deleted while</a>
<a name="ln589">	// traversing the tree - a TreeIterator doesn't lock the inode)</a>
<a name="ln590">	mutex_lock(&amp;fIteratorLock);</a>
<a name="ln591"> </a>
<a name="ln592">	SinglyLinkedList&lt;TreeIterator&gt;::Iterator iterator</a>
<a name="ln593">		= fIterators.GetIterator();</a>
<a name="ln594">	while (iterator.HasNext())</a>
<a name="ln595">		iterator.Next()-&gt;Stop();</a>
<a name="ln596">	mutex_destroy(&amp;fIteratorLock);</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599"> </a>
<a name="ln600">int32</a>
<a name="ln601">btrfs_key::Compare(const btrfs_key&amp; key) const</a>
<a name="ln602">{</a>
<a name="ln603">	if (ObjectID() &gt; key.ObjectID())</a>
<a name="ln604">		return 1;</a>
<a name="ln605">	if (ObjectID() &lt; key.ObjectID())</a>
<a name="ln606">		return -1;</a>
<a name="ln607">	if (Type() &gt; key.Type())</a>
<a name="ln608">		return 1;</a>
<a name="ln609">	if (Type() &lt; key.Type())</a>
<a name="ln610">		return -1;</a>
<a name="ln611">	if (Offset() &gt; key.Offset())</a>
<a name="ln612">		return 1;</a>
<a name="ln613">	if (Offset() &lt; key.Offset())</a>
<a name="ln614">		return -1;</a>
<a name="ln615">	return 0;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">/* Traverse from root to fill in the path along way its finding.</a>
<a name="ln620"> * Return current slot at leaf if successful.</a>
<a name="ln621"> */</a>
<a name="ln622">status_t</a>
<a name="ln623">BTree::Traverse(btree_traversing type, Path* path, const btrfs_key&amp; key)</a>
<a name="ln624">	const</a>
<a name="ln625">{</a>
<a name="ln626">	TRACE(&quot;BTree::Traverse() objectid %&quot; B_PRId64 &quot; type %d offset %&quot;</a>
<a name="ln627">		B_PRId64 &quot; \n&quot;, key.ObjectID(),	key.Type(), key.Offset());</a>
<a name="ln628">	fsblock_t physicalBlock = fRootBlock;</a>
<a name="ln629">	Node node(fVolume, physicalBlock);</a>
<a name="ln630">	int slot;</a>
<a name="ln631">	status_t status = B_OK;</a>
<a name="ln632"> </a>
<a name="ln633">	while (node.Level() != 0) {</a>
<a name="ln634">		TRACE(&quot;BTree::Traverse() level %d count %d\n&quot;, node.Level(),</a>
<a name="ln635">			node.ItemCount());</a>
<a name="ln636">		status = node.SearchSlot(key, &amp;slot, BTREE_BACKWARD);</a>
<a name="ln637">		if (status != B_OK)</a>
<a name="ln638">			return status;</a>
<a name="ln639">		if (path-&gt;SetNode(&amp;node, slot) == NULL)</a>
<a name="ln640">			return B_NO_MEMORY;</a>
<a name="ln641"> </a>
<a name="ln642">		TRACE(&quot;BTree::Traverse() getting index %&quot; B_PRIu32 &quot;\n&quot;, slot);</a>
<a name="ln643"> </a>
<a name="ln644">		status = fVolume-&gt;FindBlock(node.Index(slot)-&gt;LogicalAddress(),</a>
<a name="ln645">				physicalBlock);</a>
<a name="ln646">		if (status != B_OK) {</a>
<a name="ln647">			ERROR(&quot;BTree::Traverse() unmapped block %&quot; B_PRId64 &quot;\n&quot;,</a>
<a name="ln648">				node.Index(slot)-&gt;LogicalAddress());</a>
<a name="ln649">			return status;</a>
<a name="ln650">		}</a>
<a name="ln651">		node.SetTo(physicalBlock);</a>
<a name="ln652">	}</a>
<a name="ln653"> </a>
<a name="ln654">	TRACE(&quot;BTree::Traverse() dump count %&quot; B_PRId32 &quot;\n&quot;, node.ItemCount());</a>
<a name="ln655">	status = node.SearchSlot(key, &amp;slot, type);</a>
<a name="ln656">	if (status != B_OK)</a>
<a name="ln657">		return status;</a>
<a name="ln658">	if (path-&gt;SetNode(&amp;node, slot) == NULL)</a>
<a name="ln659">		return B_NO_MEMORY;</a>
<a name="ln660"> </a>
<a name="ln661">	TRACE(&quot;BTree::Traverse() found %&quot; B_PRIu32 &quot; %&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln662">		node.Item(slot)-&gt;Offset(), node.Item(slot)-&gt;Size());</a>
<a name="ln663">	return slot;</a>
<a name="ln664">}</a>
<a name="ln665"> </a>
<a name="ln666"> </a>
<a name="ln667">/*!	Searches the key in the tree, and stores the allocated found item in</a>
<a name="ln668">	_value, if successful.</a>
<a name="ln669">	Returns B_OK when the key could be found, B_ENTRY_NOT_FOUND if not.</a>
<a name="ln670">	It can also return other errors to indicate that something went wrong.</a>
<a name="ln671">*/</a>
<a name="ln672">status_t</a>
<a name="ln673">BTree::_Find(Path* path, btrfs_key&amp; wanted, void** _value, uint32* _size,</a>
<a name="ln674">	uint32* _offset, btree_traversing type) const</a>
<a name="ln675">{</a>
<a name="ln676">	status_t status = Traverse(type, path, wanted);</a>
<a name="ln677">	if (status &lt; B_OK)</a>
<a name="ln678">		return status;</a>
<a name="ln679"> </a>
<a name="ln680">	btrfs_key found;</a>
<a name="ln681">	status = path-&gt;GetCurrentEntry(&amp;found, _value, _size, _offset);</a>
<a name="ln682">	if (status != B_OK)</a>
<a name="ln683">		return status;</a>
<a name="ln684"> </a>
<a name="ln685">	if (found.Type() != wanted.Type() &amp;&amp; wanted.Type() != BTRFS_KEY_TYPE_ANY) {</a>
<a name="ln686">		ERROR(&quot;Find() not found wanted: %&quot; B_PRIu64 &quot; %&quot; B_PRIu8 &quot; %&quot;</a>
<a name="ln687">			B_PRIu64 &quot; found: %&quot; B_PRIu64 &quot; %&quot; B_PRIu8 &quot; %&quot; B_PRIu64 &quot;\n&quot;,</a>
<a name="ln688">			wanted.ObjectID(), wanted.Type(), wanted.Offset(), found.ObjectID(),</a>
<a name="ln689">			found.Type(), found.Offset());</a>
<a name="ln690">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln691">	}</a>
<a name="ln692"> </a>
<a name="ln693">	wanted = found;</a>
<a name="ln694">	return B_OK;</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697"> </a>
<a name="ln698">status_t</a>
<a name="ln699">BTree::FindNext(Path* path, btrfs_key&amp; key, void** _value, uint32* _size,</a>
<a name="ln700">	uint32* _offset) const</a>
<a name="ln701">{</a>
<a name="ln702">	return _Find(path, key, _value, _size, _offset, BTREE_FORWARD);</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">status_t</a>
<a name="ln707">BTree::FindPrevious(Path* path, btrfs_key&amp; key, void** _value, uint32* _size,</a>
<a name="ln708">	uint32* _offset) const</a>
<a name="ln709">{</a>
<a name="ln710">	return _Find(path, key, _value, _size, _offset, BTREE_BACKWARD);</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">status_t</a>
<a name="ln715">BTree::FindExact(Path* path, btrfs_key&amp; key, void** _value, uint32* _size,</a>
<a name="ln716">	uint32* _offset) const</a>
<a name="ln717">{</a>
<a name="ln718">	return _Find(path, key, _value, _size, _offset, BTREE_EXACT);</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">/*</a>
<a name="ln723"> * Insert &quot;num&quot; of consecutive empty entries start with slot of &quot;startKey&quot;</a>
<a name="ln724"> * if successful return the starting slot, otherwise return error code.</a>
<a name="ln725"> */</a>
<a name="ln726">status_t</a>
<a name="ln727">BTree::MakeEntries(Transaction&amp; transaction, Path* path,</a>
<a name="ln728">	const btrfs_key&amp; startKey, int num, int length)</a>
<a name="ln729">{</a>
<a name="ln730">	TRACE(&quot;BTree::MakeEntries() num %i key (% &quot; B_PRIu64 &quot; %&quot; B_PRIu8 &quot; %&quot;</a>
<a name="ln731">		B_PRIu64 &quot;)\n&quot;, num, startKey.ObjectID(), startKey.Type(),</a>
<a name="ln732">		startKey.Offset());</a>
<a name="ln733"> </a>
<a name="ln734">	status_t status = Traverse(BTREE_FORWARD, path, startKey);</a>
<a name="ln735">	if (status &lt; B_OK)</a>
<a name="ln736">		return status;</a>
<a name="ln737"> </a>
<a name="ln738">	int slot = status;</a>
<a name="ln739">	status = path-&gt;InternalCopy(transaction, 1);</a>
<a name="ln740">	if (status != B_OK)</a>
<a name="ln741">		return status;</a>
<a name="ln742"> </a>
<a name="ln743">	status = path-&gt;CopyOnWrite(transaction, 0, slot, num, length);</a>
<a name="ln744">	if (status == B_DEVICE_FULL) {</a>
<a name="ln745">		// TODO: push data or split node</a>
<a name="ln746">		return status;</a>
<a name="ln747">	}</a>
<a name="ln748"> </a>
<a name="ln749">	if (status != B_OK)</a>
<a name="ln750">		return status;</a>
<a name="ln751">	return slot;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">/* MakeEntries and then fill in them.</a>
<a name="ln756"> */</a>
<a name="ln757">status_t</a>
<a name="ln758">BTree::InsertEntries(Transaction&amp; transaction, Path* path,</a>
<a name="ln759">	btrfs_entry* entries, void** data, int num)</a>
<a name="ln760">{</a>
<a name="ln761">	int totalLength = sizeof(btrfs_entry) * num;</a>
<a name="ln762">	for (int i = 0; i &lt; num; i++)</a>
<a name="ln763">		totalLength += entries[i].Size();</a>
<a name="ln764"> </a>
<a name="ln765">	status_t slot = MakeEntries(transaction, path, entries[0].key, num,</a>
<a name="ln766">		totalLength);</a>
<a name="ln767">	if (slot &lt; B_OK)</a>
<a name="ln768">		return slot;</a>
<a name="ln769"> </a>
<a name="ln770">	uint32 upperLimit;</a>
<a name="ln771">	if (slot &gt; 0) {</a>
<a name="ln772">		path-&gt;GetEntry(slot - 1, NULL, NULL, NULL, &amp;upperLimit);</a>
<a name="ln773">	} else</a>
<a name="ln774">		upperLimit = fVolume-&gt;BlockSize() - sizeof(btrfs_header);</a>
<a name="ln775"> </a>
<a name="ln776">	TRACE(&quot;BTree::InsertEntries() num: %i upper limit %&quot; B_PRIu32 &quot;\n&quot;, num,</a>
<a name="ln777">		upperLimit);</a>
<a name="ln778">	for (int i = 0; i &lt; num; i++) {</a>
<a name="ln779">		upperLimit -= entries[i].Size();</a>
<a name="ln780">		entries[i].SetOffset(upperLimit);</a>
<a name="ln781">		path-&gt;SetEntry(slot + i, entries[i], data[i]);</a>
<a name="ln782">	}</a>
<a name="ln783"> </a>
<a name="ln784">	return B_OK;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787"> </a>
<a name="ln788">/* Like MakeEntries, but here we remove entries instead.</a>
<a name="ln789"> * Removed data stored in _data</a>
<a name="ln790"> * May merge those functions into one.</a>
<a name="ln791"> */</a>
<a name="ln792">status_t</a>
<a name="ln793">BTree::RemoveEntries(Transaction&amp; transaction, Path* path,</a>
<a name="ln794">	const btrfs_key&amp; startKey, void** _data, int num)</a>
<a name="ln795">{</a>
<a name="ln796">	TRACE(&quot;BTree::RemoveEntries() num %i key (% &quot; B_PRIu64 &quot; %&quot; B_PRIu8 &quot; %&quot;</a>
<a name="ln797">		B_PRIu64 &quot;)\n&quot;, num, startKey.ObjectID(), startKey.Type(),</a>
<a name="ln798">		startKey.Offset());</a>
<a name="ln799"> </a>
<a name="ln800">	status_t status = Traverse(BTREE_EXACT, path, startKey);</a>
<a name="ln801">	if (status &lt; B_OK)</a>
<a name="ln802">		return status;</a>
<a name="ln803"> </a>
<a name="ln804">	int slot = status;</a>
<a name="ln805">	int length = -sizeof(btrfs_entry) * num;</a>
<a name="ln806">	for (int i = 0; i &lt; num; i++) {</a>
<a name="ln807">		uint32 itemSize;</a>
<a name="ln808">		path-&gt;GetEntry(slot + i, NULL, &amp;_data[i], &amp;itemSize);</a>
<a name="ln809">		length -= itemSize;</a>
<a name="ln810">	}</a>
<a name="ln811"> </a>
<a name="ln812">	status = path-&gt;InternalCopy(transaction, 1);</a>
<a name="ln813">	if (status != B_OK)</a>
<a name="ln814">		return status;</a>
<a name="ln815"> </a>
<a name="ln816">	status = path-&gt;CopyOnWrite(transaction, 0, slot, num, length);</a>
<a name="ln817">	if (status == B_DIRECTORY_NOT_EMPTY) {</a>
<a name="ln818">		// TODO: merge node or push data</a>
<a name="ln819">	}</a>
<a name="ln820"> </a>
<a name="ln821">	return status;</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">status_t</a>
<a name="ln826">BTree::PreviousLeaf(Path* path) const</a>
<a name="ln827">{</a>
<a name="ln828">	// TODO: use Traverse() ???</a>
<a name="ln829">	int level = 0;</a>
<a name="ln830">	int slot;</a>
<a name="ln831">	Node* node = NULL;</a>
<a name="ln832">	// iterate to the root until satisfy the condition</a>
<a name="ln833">	while (true) {</a>
<a name="ln834">		node = path-&gt;GetNode(level, &amp;slot);</a>
<a name="ln835">		if (node == NULL || slot != 0)</a>
<a name="ln836">			break;</a>
<a name="ln837">		level++;</a>
<a name="ln838">	}</a>
<a name="ln839"> </a>
<a name="ln840">	// the current leaf is already the left most leaf or</a>
<a name="ln841">	// path was not initialized</a>
<a name="ln842">	if (node == NULL)</a>
<a name="ln843">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln844"> </a>
<a name="ln845">	path-&gt;Move(level, BTREE_BACKWARD);</a>
<a name="ln846">	fsblock_t physicalBlock;</a>
<a name="ln847">	// change all nodes below this level and slot to the ending</a>
<a name="ln848">	do {</a>
<a name="ln849">		status_t status = fVolume-&gt;FindBlock(</a>
<a name="ln850">			node-&gt;Index(slot)-&gt;LogicalAddress(), physicalBlock);</a>
<a name="ln851">		if (status != B_OK)</a>
<a name="ln852">			return status;</a>
<a name="ln853"> </a>
<a name="ln854">		node = path-&gt;SetNode(physicalBlock, -1);</a>
<a name="ln855">		if (node == NULL)</a>
<a name="ln856">			return B_NO_MEMORY;</a>
<a name="ln857">		slot = node-&gt;ItemCount() - 1;</a>
<a name="ln858">		level--;</a>
<a name="ln859">	} while (level != 0);</a>
<a name="ln860"> </a>
<a name="ln861">	return B_OK;</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864"> </a>
<a name="ln865">status_t</a>
<a name="ln866">BTree::NextLeaf(Path* path) const</a>
<a name="ln867">{</a>
<a name="ln868">	int level = 0;</a>
<a name="ln869">	int slot;</a>
<a name="ln870">	Node* node = NULL;</a>
<a name="ln871">	// iterate to the root until satisfy the condition</a>
<a name="ln872">	while (true) {</a>
<a name="ln873">		node = path-&gt;GetNode(level, &amp;slot);</a>
<a name="ln874">		if (node == NULL || slot &lt; node-&gt;ItemCount() - 1)</a>
<a name="ln875">			break;</a>
<a name="ln876">		level++;</a>
<a name="ln877">	}</a>
<a name="ln878"> </a>
<a name="ln879">	// the current leaf is already the right most leaf or</a>
<a name="ln880">	// path was not initialized</a>
<a name="ln881">	if (node == NULL)</a>
<a name="ln882">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln883"> </a>
<a name="ln884">	path-&gt;Move(level, BTREE_FORWARD);</a>
<a name="ln885">	fsblock_t physicalBlock;</a>
<a name="ln886">	// change all nodes below this level and slot to the beginning</a>
<a name="ln887">	do {</a>
<a name="ln888">		status_t status = fVolume-&gt;FindBlock(</a>
<a name="ln889">			node-&gt;Index(slot)-&gt;LogicalAddress(), physicalBlock);</a>
<a name="ln890">		if (status != B_OK)</a>
<a name="ln891">			return status;</a>
<a name="ln892"> </a>
<a name="ln893">		node = path-&gt;SetNode(physicalBlock, 0);</a>
<a name="ln894">		if (node == NULL)</a>
<a name="ln895">			return B_NO_MEMORY;</a>
<a name="ln896">		slot = 0;</a>
<a name="ln897">		level--;</a>
<a name="ln898">	} while (level != 0);</a>
<a name="ln899"> </a>
<a name="ln900">	return B_OK;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903"> </a>
<a name="ln904">/* Set root infomation, to use this function root must be valid and</a>
<a name="ln905"> * exists on disk.</a>
<a name="ln906"> */</a>
<a name="ln907">status_t</a>
<a name="ln908">BTree::SetRoot(off_t logical, fsblock_t* block)</a>
<a name="ln909">{</a>
<a name="ln910">	if (block != NULL) {</a>
<a name="ln911">		fRootBlock = *block;</a>
<a name="ln912">	} else {</a>
<a name="ln913">		if (fVolume-&gt;FindBlock(logical, fRootBlock) != B_OK) {</a>
<a name="ln914">			ERROR(&quot;SetRoot() unmapped block %&quot; B_PRId64 &quot; %&quot; B_PRId64 &quot;\n&quot;,</a>
<a name="ln915">				logical, fRootBlock);</a>
<a name="ln916">			return B_ERROR;</a>
<a name="ln917">		}</a>
<a name="ln918">	}</a>
<a name="ln919"> </a>
<a name="ln920">	btrfs_header header;</a>
<a name="ln921">	read_pos(fVolume-&gt;Device(), fRootBlock * fVolume-&gt;BlockSize(), &amp;header,</a>
<a name="ln922">		sizeof(btrfs_header));</a>
<a name="ln923">	fRootLevel = header.Level();</a>
<a name="ln924">	fLogicalRoot = header.LogicalAddress();</a>
<a name="ln925">	return B_OK;</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928"> </a>
<a name="ln929">void</a>
<a name="ln930">BTree::SetRoot(Node* root)</a>
<a name="ln931">{</a>
<a name="ln932">	fRootBlock = root-&gt;BlockNum();</a>
<a name="ln933">	fLogicalRoot = root-&gt;LogicalAddress();</a>
<a name="ln934">	fRootLevel = root-&gt;Level();</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937"> </a>
<a name="ln938">void</a>
<a name="ln939">BTree::_AddIterator(TreeIterator* iterator)</a>
<a name="ln940">{</a>
<a name="ln941">	MutexLocker _(fIteratorLock);</a>
<a name="ln942">	fIterators.Add(iterator);</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945"> </a>
<a name="ln946">void</a>
<a name="ln947">BTree::_RemoveIterator(TreeIterator* iterator)</a>
<a name="ln948">{</a>
<a name="ln949">	MutexLocker _(fIteratorLock);</a>
<a name="ln950">	fIterators.Remove(iterator);</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">//	#pragma mark -</a>
<a name="ln955"> </a>
<a name="ln956"> </a>
<a name="ln957">TreeIterator::TreeIterator(BTree* tree, const btrfs_key&amp; key)</a>
<a name="ln958">	:</a>
<a name="ln959">	fTree(tree),</a>
<a name="ln960">	fKey(key),</a>
<a name="ln961">	fIteratorStatus(B_NO_INIT)</a>
<a name="ln962">{</a>
<a name="ln963">	tree-&gt;_AddIterator(this);</a>
<a name="ln964">	fPath = new(std::nothrow) BTree::Path(tree);</a>
<a name="ln965">	if (fPath == NULL)</a>
<a name="ln966">		fIteratorStatus = B_NO_MEMORY;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969"> </a>
<a name="ln970">TreeIterator::~TreeIterator()</a>
<a name="ln971">{</a>
<a name="ln972">	if (fTree)</a>
<a name="ln973">		fTree-&gt;_RemoveIterator(this);</a>
<a name="ln974"> </a>
<a name="ln975">	delete fPath;</a>
<a name="ln976">	fPath = NULL;</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979"> </a>
<a name="ln980">void</a>
<a name="ln981">TreeIterator::Rewind(bool inverse)</a>
<a name="ln982">{</a>
<a name="ln983">	if (inverse)</a>
<a name="ln984">		fKey.SetOffset(BTREE_END);</a>
<a name="ln985">	else</a>
<a name="ln986">		fKey.SetOffset(BTREE_BEGIN);</a>
<a name="ln987">	fIteratorStatus = B_NO_INIT;</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990"> </a>
<a name="ln991">/*!	Iterates through the tree in the specified direction.</a>
<a name="ln992">*/</a>
<a name="ln993">status_t</a>
<a name="ln994">TreeIterator::_Traverse(btree_traversing direction)</a>
<a name="ln995">{</a>
<a name="ln996">	status_t status = fTree-&gt;Traverse(direction, fPath, fKey);</a>
<a name="ln997">	if (status &lt; B_OK) {</a>
<a name="ln998">		ERROR(&quot;TreeIterator::Traverse() Find failed\n&quot;);</a>
<a name="ln999">		return status;</a>
<a name="ln1000">	}</a>
<a name="ln1001"> </a>
<a name="ln1002">	return (fIteratorStatus = B_OK);</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005"> </a>
<a name="ln1006">// Like GetEntry in BTree::Path but here we check the type and moving.</a>
<a name="ln1007">status_t</a>
<a name="ln1008">TreeIterator::_GetEntry(btree_traversing type, void** _value, uint32* _size,</a>
<a name="ln1009">	uint32* _offset)</a>
<a name="ln1010">{</a>
<a name="ln1011">	status_t status = B_OK;</a>
<a name="ln1012">	if (fIteratorStatus == B_NO_INIT) {</a>
<a name="ln1013">		status = _Traverse(type);</a>
<a name="ln1014">		if (status != B_OK)</a>
<a name="ln1015">			return status;</a>
<a name="ln1016">		type = BTREE_EXACT;</a>
<a name="ln1017">	}</a>
<a name="ln1018"> </a>
<a name="ln1019">	if (fIteratorStatus != B_OK)</a>
<a name="ln1020">		return fIteratorStatus;</a>
<a name="ln1021"> </a>
<a name="ln1022">	int move = fPath-&gt;Move(0, type);</a>
<a name="ln1023">	if (move &gt; 0)</a>
<a name="ln1024">		status = fTree-&gt;NextLeaf(fPath);</a>
<a name="ln1025">	else if (move &lt; 0)</a>
<a name="ln1026">		status = fTree-&gt;PreviousLeaf(fPath);</a>
<a name="ln1027">	if (status != B_OK)</a>
<a name="ln1028">		return status;</a>
<a name="ln1029"> </a>
<a name="ln1030">	btrfs_key found;</a>
<a name="ln1031">	status = fPath-&gt;GetCurrentEntry(&amp;found, _value, _size, _offset);</a>
<a name="ln1032">	if (status != B_OK)</a>
<a name="ln1033">		return status;</a>
<a name="ln1034"> </a>
<a name="ln1035">	fKey.SetObjectID(found.ObjectID());</a>
<a name="ln1036">	fKey.SetOffset(found.Offset());</a>
<a name="ln1037">	if (fKey.Type() != found.Type() &amp;&amp; fKey.Type() != BTRFS_KEY_TYPE_ANY)</a>
<a name="ln1038">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1039"> </a>
<a name="ln1040">	return B_OK;</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043"> </a>
<a name="ln1044">/*!	just sets the current key in the iterator.</a>
<a name="ln1045">*/</a>
<a name="ln1046">status_t</a>
<a name="ln1047">TreeIterator::Find(const btrfs_key&amp; key)</a>
<a name="ln1048">{</a>
<a name="ln1049">	if (fIteratorStatus == B_INTERRUPTED)</a>
<a name="ln1050">		return fIteratorStatus;</a>
<a name="ln1051"> </a>
<a name="ln1052">	fKey = key;</a>
<a name="ln1053">	fIteratorStatus = B_NO_INIT;</a>
<a name="ln1054">	return B_OK;</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057"> </a>
<a name="ln1058">void</a>
<a name="ln1059">TreeIterator::Stop()</a>
<a name="ln1060">{</a>
<a name="ln1061">	fTree = NULL;</a>
<a name="ln1062">	fIteratorStatus = B_INTERRUPTED;</a>
<a name="ln1063">}</a>

</code></pre>
<div class="balloon" rel="566"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fLogicalRoot.</p></div>
<div class="balloon" rel="576"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fLogicalRoot, fRootLevel.</p></div>
<div class="balloon" rel="556"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fLogicalRoot.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
