
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>utility.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 1989, 1993</a>
<a name="ln3"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions</a>
<a name="ln7"> * are met:</a>
<a name="ln8"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln9"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln10"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln12"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln13"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln14"> *    must display the following acknowledgement:</a>
<a name="ln15"> *	This product includes software developed by the University of</a>
<a name="ln16"> *	California, Berkeley and its contributors.</a>
<a name="ln17"> * 4. Neither the name of the University nor the names of its contributors</a>
<a name="ln18"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln19"> *    without specific prior written permission.</a>
<a name="ln20"> *</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln22"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln23"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln24"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln25"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln26"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln27"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln28"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln29"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln30"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln31"> * SUCH DAMAGE.</a>
<a name="ln32"> */</a>
<a name="ln33"> </a>
<a name="ln34">#if 0</a>
<a name="ln35">#ifndef lint</a>
<a name="ln36">static const char sccsid[] = &quot;@(#)utility.c	8.4 (Berkeley) 5/30/95&quot;;</a>
<a name="ln37">#endif /* not lint */</a>
<a name="ln38">#endif</a>
<a name="ln39">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln40">__FBSDID(&quot;$FreeBSD: src/contrib/telnet/telnetd/utility.c,v 1.13 2003/05/04 02:54:49 obrien Exp $&quot;);</a>
<a name="ln41"> </a>
<a name="ln42">#ifdef __FreeBSD__</a>
<a name="ln43">#include &lt;locale.h&gt;</a>
<a name="ln44">#include &lt;sys/utsname.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46">#include &lt;string.h&gt;</a>
<a name="ln47">#define PRINTOPTIONS</a>
<a name="ln48">#include &quot;telnetd.h&quot;</a>
<a name="ln49"> </a>
<a name="ln50">#ifdef	AUTHENTICATION</a>
<a name="ln51">#include &lt;libtelnet/auth.h&gt;</a>
<a name="ln52">#endif</a>
<a name="ln53">#ifdef	ENCRYPTION</a>
<a name="ln54">#include &lt;libtelnet/encrypt.h&gt;</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">/*</a>
<a name="ln58"> * utility functions performing io related tasks</a>
<a name="ln59"> */</a>
<a name="ln60"> </a>
<a name="ln61">/*</a>
<a name="ln62"> * ttloop</a>
<a name="ln63"> *</a>
<a name="ln64"> *	A small subroutine to flush the network output buffer, get some data</a>
<a name="ln65"> * from the network, and pass it through the telnet state machine.  We</a>
<a name="ln66"> * also flush the pty input buffer (by dropping its data) if it becomes</a>
<a name="ln67"> * too full.</a>
<a name="ln68"> */</a>
<a name="ln69"> </a>
<a name="ln70">    void</a>
<a name="ln71">ttloop()</a>
<a name="ln72">{</a>
<a name="ln73"> </a>
<a name="ln74">    DIAG(TD_REPORT, output_data(&quot;td: ttloop\r\n&quot;));</a>
<a name="ln75">    if (nfrontp - nbackp &gt; 0) {</a>
<a name="ln76">	netflush();</a>
<a name="ln77">    }</a>
<a name="ln78">    ncc = read(net, netibuf, sizeof netibuf);</a>
<a name="ln79">    if (ncc &lt; 0) {</a>
<a name="ln80">	syslog(LOG_INFO, &quot;ttloop:  read: %m&quot;);</a>
<a name="ln81">	exit(1);</a>
<a name="ln82">    } else if (ncc == 0) {</a>
<a name="ln83">	syslog(LOG_INFO, &quot;ttloop:  peer died: %m&quot;);</a>
<a name="ln84">	exit(1);</a>
<a name="ln85">    }</a>
<a name="ln86">    DIAG(TD_REPORT, output_data(&quot;td: ttloop read %d chars\r\n&quot;, ncc));</a>
<a name="ln87">    netip = netibuf;</a>
<a name="ln88">    telrcv();			/* state machine */</a>
<a name="ln89">    if (ncc &gt; 0) {</a>
<a name="ln90">	pfrontp = pbackp = ptyobuf;</a>
<a name="ln91">	telrcv();</a>
<a name="ln92">    }</a>
<a name="ln93">}  /* end of ttloop */</a>
<a name="ln94"> </a>
<a name="ln95">/*</a>
<a name="ln96"> * Check a descriptor to see if out of band data exists on it.</a>
<a name="ln97"> */</a>
<a name="ln98">int</a>
<a name="ln99">stilloob(int s)</a>
<a name="ln100">{</a>
<a name="ln101">    static struct timeval timeout = { 0, 0 };</a>
<a name="ln102">    fd_set	excepts;</a>
<a name="ln103">    int value;</a>
<a name="ln104"> </a>
<a name="ln105">    do {</a>
<a name="ln106">	FD_ZERO(&amp;excepts);</a>
<a name="ln107">	FD_SET(s, &amp;excepts);</a>
<a name="ln108">	memset((char *)&amp;timeout, 0, sizeof timeout);</a>
<a name="ln109">	value = select(s+1, (fd_set *)0, (fd_set *)0, &amp;excepts, &amp;timeout);</a>
<a name="ln110">    } while ((value == -1) &amp;&amp; (errno == EINTR));</a>
<a name="ln111"> </a>
<a name="ln112">    if (value &lt; 0) {</a>
<a name="ln113">	fatalperror(pty, &quot;select&quot;);</a>
<a name="ln114">    }</a>
<a name="ln115">    if (FD_ISSET(s, &amp;excepts)) {</a>
<a name="ln116">	return 1;</a>
<a name="ln117">    } else {</a>
<a name="ln118">	return 0;</a>
<a name="ln119">    }</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">void</a>
<a name="ln123">ptyflush(void)</a>
<a name="ln124">{</a>
<a name="ln125">	int n;</a>
<a name="ln126"> </a>
<a name="ln127">	if ((n = pfrontp - pbackp) &gt; 0) {</a>
<a name="ln128">		DIAG(TD_REPORT | TD_PTYDATA,</a>
<a name="ln129">		    output_data(&quot;td: ptyflush %d chars\r\n&quot;, n));</a>
<a name="ln130">		DIAG(TD_PTYDATA, printdata(&quot;pd&quot;, pbackp, n));</a>
<a name="ln131">		n = write(pty, pbackp, n);</a>
<a name="ln132">	}</a>
<a name="ln133">	if (n &lt; 0) {</a>
<a name="ln134">		if (errno == EWOULDBLOCK || errno == EINTR)</a>
<a name="ln135">			return;</a>
<a name="ln136">		cleanup(0);</a>
<a name="ln137">	}</a>
<a name="ln138">	pbackp += n;</a>
<a name="ln139">	if (pbackp == pfrontp)</a>
<a name="ln140">		pbackp = pfrontp = ptyobuf;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">/*</a>
<a name="ln144"> * nextitem()</a>
<a name="ln145"> *</a>
<a name="ln146"> *	Return the address of the next &quot;item&quot; in the TELNET data</a>
<a name="ln147"> * stream.  This will be the address of the next character if</a>
<a name="ln148"> * the current address is a user data character, or it will</a>
<a name="ln149"> * be the address of the character following the TELNET command</a>
<a name="ln150"> * if the current address is a TELNET IAC (&quot;I Am a Command&quot;)</a>
<a name="ln151"> * character.</a>
<a name="ln152"> */</a>
<a name="ln153">static char *</a>
<a name="ln154">nextitem(char *current)</a>
<a name="ln155">{</a>
<a name="ln156">    if ((*current&amp;0xff) != IAC) {</a>
<a name="ln157">	return current+1;</a>
<a name="ln158">    }</a>
<a name="ln159">    switch (*(current+1)&amp;0xff) {</a>
<a name="ln160">    case DO:</a>
<a name="ln161">    case DONT:</a>
<a name="ln162">    case WILL:</a>
<a name="ln163">    case WONT:</a>
<a name="ln164">	return current+3;</a>
<a name="ln165">    case SB:		/* loop forever looking for the SE */</a>
<a name="ln166">	{</a>
<a name="ln167">	    char *look = current+2;</a>
<a name="ln168"> </a>
<a name="ln169">	    for (;;) {</a>
<a name="ln170">		if ((*look++&amp;0xff) == IAC) {</a>
<a name="ln171">		    if ((*look++&amp;0xff) == SE) {</a>
<a name="ln172">			return look;</a>
<a name="ln173">		    }</a>
<a name="ln174">		}</a>
<a name="ln175">	    }</a>
<a name="ln176">	}</a>
<a name="ln177">    default:</a>
<a name="ln178">	return current+2;</a>
<a name="ln179">    }</a>
<a name="ln180">}  /* end of nextitem */</a>
<a name="ln181"> </a>
<a name="ln182">/*</a>
<a name="ln183"> * netclear()</a>
<a name="ln184"> *</a>
<a name="ln185"> *	We are about to do a TELNET SYNCH operation.  Clear</a>
<a name="ln186"> * the path to the network.</a>
<a name="ln187"> *</a>
<a name="ln188"> *	Things are a bit tricky since we may have sent the first</a>
<a name="ln189"> * byte or so of a previous TELNET command into the network.</a>
<a name="ln190"> * So, we have to scan the network buffer from the beginning</a>
<a name="ln191"> * until we are up to where we want to be.</a>
<a name="ln192"> *</a>
<a name="ln193"> *	A side effect of what we do, just to keep things</a>
<a name="ln194"> * simple, is to clear the urgent data pointer.  The principal</a>
<a name="ln195"> * caller should be setting the urgent data pointer AFTER calling</a>
<a name="ln196"> * us in any case.</a>
<a name="ln197"> */</a>
<a name="ln198">void</a>
<a name="ln199">netclear(void)</a>
<a name="ln200">{</a>
<a name="ln201">    char *thisitem, *next;</a>
<a name="ln202">    char *good;</a>
<a name="ln203">#define	wewant(p)	((nfrontp &gt; p) &amp;&amp; ((*p&amp;0xff) == IAC) &amp;&amp; \</a>
<a name="ln204">				((*(p+1)&amp;0xff) != EC) &amp;&amp; ((*(p+1)&amp;0xff) != EL))</a>
<a name="ln205"> </a>
<a name="ln206">#ifdef	ENCRYPTION</a>
<a name="ln207">    thisitem = nclearto &gt; netobuf ? nclearto : netobuf;</a>
<a name="ln208">#else	/* ENCRYPTION */</a>
<a name="ln209">    thisitem = netobuf;</a>
<a name="ln210">#endif	/* ENCRYPTION */</a>
<a name="ln211"> </a>
<a name="ln212">    while ((next = nextitem(thisitem)) &lt;= nbackp) {</a>
<a name="ln213">	thisitem = next;</a>
<a name="ln214">    }</a>
<a name="ln215"> </a>
<a name="ln216">    /* Now, thisitem is first before/at boundary. */</a>
<a name="ln217"> </a>
<a name="ln218">#ifdef	ENCRYPTION</a>
<a name="ln219">    good = nclearto &gt; netobuf ? nclearto : netobuf;</a>
<a name="ln220">#else	/* ENCRYPTION */</a>
<a name="ln221">    good = netobuf;	/* where the good bytes go */</a>
<a name="ln222">#endif	/* ENCRYPTION */</a>
<a name="ln223"> </a>
<a name="ln224">    while (nfrontp &gt; thisitem) {</a>
<a name="ln225">	if (wewant(thisitem)) {</a>
<a name="ln226">	    int length;</a>
<a name="ln227"> </a>
<a name="ln228">	    next = thisitem;</a>
<a name="ln229">	    do {</a>
<a name="ln230">		next = nextitem(next);</a>
<a name="ln231">	    } while (wewant(next) &amp;&amp; (nfrontp &gt; next));</a>
<a name="ln232">	    length = next-thisitem;</a>
<a name="ln233">	    memmove(good, thisitem, length);</a>
<a name="ln234">	    good += length;</a>
<a name="ln235">	    thisitem = next;</a>
<a name="ln236">	} else {</a>
<a name="ln237">	    thisitem = nextitem(thisitem);</a>
<a name="ln238">	}</a>
<a name="ln239">    }</a>
<a name="ln240"> </a>
<a name="ln241">    nbackp = netobuf;</a>
<a name="ln242">    nfrontp = good;		/* next byte to be sent */</a>
<a name="ln243">    neturg = 0;</a>
<a name="ln244">}  /* end of netclear */</a>
<a name="ln245"> </a>
<a name="ln246">/*</a>
<a name="ln247"> *  netflush</a>
<a name="ln248"> *		Send as much data as possible to the network,</a>
<a name="ln249"> *	handling requests for urgent data.</a>
<a name="ln250"> */</a>
<a name="ln251">void</a>
<a name="ln252">netflush(void)</a>
<a name="ln253">{</a>
<a name="ln254">    int n;</a>
<a name="ln255">    extern int not42;</a>
<a name="ln256"> </a>
<a name="ln257">    while ((n = nfrontp - nbackp) &gt; 0) {</a>
<a name="ln258">#if 0</a>
<a name="ln259">	/* XXX This causes output_data() to recurse and die */</a>
<a name="ln260">	DIAG(TD_REPORT, {</a>
<a name="ln261">	    n += output_data(&quot;td: netflush %d chars\r\n&quot;, n);</a>
<a name="ln262">	});</a>
<a name="ln263">#endif</a>
<a name="ln264">#ifdef	ENCRYPTION</a>
<a name="ln265">	if (encrypt_output) {</a>
<a name="ln266">		char *s = nclearto ? nclearto : nbackp;</a>
<a name="ln267">		if (nfrontp - s &gt; 0) {</a>
<a name="ln268">			(*encrypt_output)((unsigned char *)s, nfrontp-s);</a>
<a name="ln269">			nclearto = nfrontp;</a>
<a name="ln270">		}</a>
<a name="ln271">	}</a>
<a name="ln272">#endif	/* ENCRYPTION */</a>
<a name="ln273">	/*</a>
<a name="ln274">	 * if no urgent data, or if the other side appears to be an</a>
<a name="ln275">	 * old 4.2 client (and thus unable to survive TCP urgent data),</a>
<a name="ln276">	 * write the entire buffer in non-OOB mode.</a>
<a name="ln277">	 */</a>
<a name="ln278">	if ((neturg == 0) || (not42 == 0)) {</a>
<a name="ln279">	    n = write(net, nbackp, n);	/* normal write */</a>
<a name="ln280">	} else {</a>
<a name="ln281">	    n = neturg - nbackp;</a>
<a name="ln282">	    /*</a>
<a name="ln283">	     * In 4.2 (and 4.3) systems, there is some question about</a>
<a name="ln284">	     * what byte in a sendOOB operation is the &quot;OOB&quot; data.</a>
<a name="ln285">	     * To make ourselves compatible, we only send ONE byte</a>
<a name="ln286">	     * out of band, the one WE THINK should be OOB (though</a>
<a name="ln287">	     * we really have more the TCP philosophy of urgent data</a>
<a name="ln288">	     * rather than the Unix philosophy of OOB data).</a>
<a name="ln289">	     */</a>
<a name="ln290">	    if (n &gt; 1) {</a>
<a name="ln291">		n = send(net, nbackp, n-1, 0);	/* send URGENT all by itself */</a>
<a name="ln292">	    } else {</a>
<a name="ln293">		n = send(net, nbackp, n, MSG_OOB);	/* URGENT data */</a>
<a name="ln294">	    }</a>
<a name="ln295">	}</a>
<a name="ln296">	if (n == -1) {</a>
<a name="ln297">	    if (errno == EWOULDBLOCK || errno == EINTR)</a>
<a name="ln298">		continue;</a>
<a name="ln299">	    cleanup(0);</a>
<a name="ln300">	    /* NOTREACHED */</a>
<a name="ln301">	}</a>
<a name="ln302">	nbackp += n;</a>
<a name="ln303">#ifdef	ENCRYPTION</a>
<a name="ln304">	if (nbackp &gt; nclearto)</a>
<a name="ln305">	    nclearto = 0;</a>
<a name="ln306">#endif	/* ENCRYPTION */</a>
<a name="ln307">	if (nbackp &gt;= neturg) {</a>
<a name="ln308">	    neturg = 0;</a>
<a name="ln309">	}</a>
<a name="ln310">	if (nbackp == nfrontp) {</a>
<a name="ln311">	    nbackp = nfrontp = netobuf;</a>
<a name="ln312">#ifdef	ENCRYPTION</a>
<a name="ln313">	    nclearto = 0;</a>
<a name="ln314">#endif	/* ENCRYPTION */</a>
<a name="ln315">	}</a>
<a name="ln316">    }</a>
<a name="ln317">    return;</a>
<a name="ln318">}  /* end of netflush */</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">/*</a>
<a name="ln322"> * miscellaneous functions doing a variety of little jobs follow ...</a>
<a name="ln323"> */</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">void</a>
<a name="ln327">fatal(int f, const char *msg)</a>
<a name="ln328">{</a>
<a name="ln329">	char buf[BUFSIZ];</a>
<a name="ln330"> </a>
<a name="ln331">	(void) snprintf(buf, sizeof(buf), &quot;telnetd: %s.\r\n&quot;, msg);</a>
<a name="ln332">#ifdef	ENCRYPTION</a>
<a name="ln333">	if (encrypt_output) {</a>
<a name="ln334">		/*</a>
<a name="ln335">		 * Better turn off encryption first....</a>
<a name="ln336">		 * Hope it flushes...</a>
<a name="ln337">		 */</a>
<a name="ln338">		encrypt_send_end();</a>
<a name="ln339">		netflush();</a>
<a name="ln340">	}</a>
<a name="ln341">#endif	/* ENCRYPTION */</a>
<a name="ln342">	(void) write(f, buf, (int)strlen(buf));</a>
<a name="ln343">	sleep(1);	/*XXX*/</a>
<a name="ln344">	exit(1);</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">void</a>
<a name="ln348">fatalperror(int f, const char *msg)</a>
<a name="ln349">{</a>
<a name="ln350">	char buf[BUFSIZ];</a>
<a name="ln351"> </a>
<a name="ln352">	(void) snprintf(buf, sizeof(buf), &quot;%s: %s&quot;, msg, strerror(errno));</a>
<a name="ln353">	fatal(f, buf);</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">char editedhost[32];</a>
<a name="ln357"> </a>
<a name="ln358">void</a>
<a name="ln359">edithost(char *pat, char *host)</a>
<a name="ln360">{</a>
<a name="ln361">	char *res = editedhost;</a>
<a name="ln362"> </a>
<a name="ln363">	if (!pat)</a>
<a name="ln364">		pat = strdup(&quot;&quot;);</a>
<a name="ln365">	while (*pat) {</a>
<a name="ln366">		switch (*pat) {</a>
<a name="ln367"> </a>
<a name="ln368">		case '#':</a>
<a name="ln369">			if (*host)</a>
<a name="ln370">				host++;</a>
<a name="ln371">			break;</a>
<a name="ln372"> </a>
<a name="ln373">		case '@':</a>
<a name="ln374">			if (*host)</a>
<a name="ln375">				*res++ = *host++;</a>
<a name="ln376">			break;</a>
<a name="ln377"> </a>
<a name="ln378">		default:</a>
<a name="ln379">			*res++ = *pat;</a>
<a name="ln380">			break;</a>
<a name="ln381">		}</a>
<a name="ln382">		if (res == &amp;editedhost[sizeof editedhost - 1]) {</a>
<a name="ln383">			*res = '\0';</a>
<a name="ln384">			return;</a>
<a name="ln385">		}</a>
<a name="ln386">		pat++;</a>
<a name="ln387">	}</a>
<a name="ln388">	if (*host)</a>
<a name="ln389">		(void) strncpy(res, host,</a>
<a name="ln390">				sizeof editedhost - (res - editedhost) -1);</a>
<a name="ln391">	else</a>
<a name="ln392">		*res = '\0';</a>
<a name="ln393">	editedhost[sizeof editedhost - 1] = '\0';</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">static char *putlocation;</a>
<a name="ln397"> </a>
<a name="ln398">static void</a>
<a name="ln399">putstr(const char *s)</a>
<a name="ln400">{</a>
<a name="ln401"> </a>
<a name="ln402">	while (*s)</a>
<a name="ln403">		putchr(*s++);</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">void</a>
<a name="ln407">putchr(int cc)</a>
<a name="ln408">{</a>
<a name="ln409">	*putlocation++ = cc;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">#ifdef __FreeBSD__</a>
<a name="ln413">static char fmtstr[] = { &quot;%+&quot; };</a>
<a name="ln414">#else</a>
<a name="ln415">static char fmtstr[] = { &quot;%l:%M%P on %A, %d %B %Y&quot; };</a>
<a name="ln416">#endif</a>
<a name="ln417"> </a>
<a name="ln418">void</a>
<a name="ln419">putf(char *cp, char *where)</a>
<a name="ln420">{</a>
<a name="ln421">	char *slash;</a>
<a name="ln422">	time_t t;</a>
<a name="ln423">	char db[100];</a>
<a name="ln424">#ifdef __FreeBSD__</a>
<a name="ln425">	static struct utsname kerninfo;</a>
<a name="ln426"> </a>
<a name="ln427">	if (!*kerninfo.sysname)</a>
<a name="ln428">		uname(&amp;kerninfo);</a>
<a name="ln429">#endif</a>
<a name="ln430"> </a>
<a name="ln431">	putlocation = where;</a>
<a name="ln432"> </a>
<a name="ln433">	while (*cp) {</a>
<a name="ln434">		if (*cp =='\n') {</a>
<a name="ln435">			putstr(&quot;\r\n&quot;);</a>
<a name="ln436">			cp++;</a>
<a name="ln437">			continue;</a>
<a name="ln438">		} else if (*cp != '%') {</a>
<a name="ln439">			putchr(*cp++);</a>
<a name="ln440">			continue;</a>
<a name="ln441">		}</a>
<a name="ln442">		switch (*++cp) {</a>
<a name="ln443"> </a>
<a name="ln444">		case 't':</a>
<a name="ln445">#ifdef	STREAMSPTY</a>
<a name="ln446">			/* names are like /dev/pts/2 -- we want pts/2 */</a>
<a name="ln447">			slash = strchr(line+1, '/');</a>
<a name="ln448">#else</a>
<a name="ln449">			slash = strrchr(line, '/');</a>
<a name="ln450">#endif</a>
<a name="ln451">			if (slash == (char *) 0)</a>
<a name="ln452">				putstr(line);</a>
<a name="ln453">			else</a>
<a name="ln454">				putstr(&amp;slash[1]);</a>
<a name="ln455">			break;</a>
<a name="ln456"> </a>
<a name="ln457">		case 'h':</a>
<a name="ln458">			putstr(editedhost);</a>
<a name="ln459">			break;</a>
<a name="ln460"> </a>
<a name="ln461">		case 'd':</a>
<a name="ln462">#ifdef __FreeBSD__</a>
<a name="ln463">			setlocale(LC_TIME, &quot;&quot;);</a>
<a name="ln464">#endif</a>
<a name="ln465">			(void)time(&amp;t);</a>
<a name="ln466">			(void)strftime(db, sizeof(db), fmtstr, localtime(&amp;t));</a>
<a name="ln467">			putstr(db);</a>
<a name="ln468">			break;</a>
<a name="ln469"> </a>
<a name="ln470">#ifdef __FreeBSD__</a>
<a name="ln471">		case 's':</a>
<a name="ln472">			putstr(kerninfo.sysname);</a>
<a name="ln473">			break;</a>
<a name="ln474"> </a>
<a name="ln475">		case 'm':</a>
<a name="ln476">			putstr(kerninfo.machine);</a>
<a name="ln477">			break;</a>
<a name="ln478"> </a>
<a name="ln479">		case 'r':</a>
<a name="ln480">			putstr(kerninfo.release);</a>
<a name="ln481">			break;</a>
<a name="ln482"> </a>
<a name="ln483">		case 'v':</a>
<a name="ln484">			putstr(kerninfo.version);</a>
<a name="ln485">			break;</a>
<a name="ln486">#endif</a>
<a name="ln487"> </a>
<a name="ln488">		case '%':</a>
<a name="ln489">			putchr('%');</a>
<a name="ln490">			break;</a>
<a name="ln491">		}</a>
<a name="ln492">		cp++;</a>
<a name="ln493">	}</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">#ifdef DIAGNOSTICS</a>
<a name="ln497">/*</a>
<a name="ln498"> * Print telnet options and commands in plain text, if possible.</a>
<a name="ln499"> */</a>
<a name="ln500">void</a>
<a name="ln501">printoption(const char *fmt, int option)</a>
<a name="ln502">{</a>
<a name="ln503">	if (TELOPT_OK(option))</a>
<a name="ln504">		output_data(&quot;%s %s\r\n&quot;, fmt, TELOPT(option));</a>
<a name="ln505">	else if (TELCMD_OK(option))</a>
<a name="ln506">		output_data(&quot;%s %s\r\n&quot;, fmt, TELCMD(option));</a>
<a name="ln507">	else</a>
<a name="ln508">		output_data(&quot;%s %d\r\n&quot;, fmt, option);</a>
<a name="ln509">	return;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">void</a>
<a name="ln513">printsub(char direction, unsigned char *pointer, int length)</a>
<a name="ln514">{</a>
<a name="ln515">    int i = 0;</a>
<a name="ln516"> </a>
<a name="ln517">	if (!(diagnostic &amp; TD_OPTIONS))</a>
<a name="ln518">		return;</a>
<a name="ln519"> </a>
<a name="ln520">	if (direction) {</a>
<a name="ln521">	    output_data(&quot;td: %s suboption &quot;,</a>
<a name="ln522">					direction == '&lt;' ? &quot;recv&quot; : &quot;send&quot;);</a>
<a name="ln523">	    if (length &gt;= 3) {</a>
<a name="ln524">		int j;</a>
<a name="ln525"> </a>
<a name="ln526">		i = pointer[length-2];</a>
<a name="ln527">		j = pointer[length-1];</a>
<a name="ln528"> </a>
<a name="ln529">		if (i != IAC || j != SE) {</a>
<a name="ln530">		    output_data(&quot;(terminated by &quot;);</a>
<a name="ln531">		    if (TELOPT_OK(i))</a>
<a name="ln532">			output_data(&quot;%s &quot;, TELOPT(i));</a>
<a name="ln533">		    else if (TELCMD_OK(i))</a>
<a name="ln534">			output_data(&quot;%s &quot;, TELCMD(i));</a>
<a name="ln535">		    else</a>
<a name="ln536">			output_data(&quot;%d &quot;, i);</a>
<a name="ln537">		    if (TELOPT_OK(j))</a>
<a name="ln538">			output_data(&quot;%s&quot;, TELOPT(j));</a>
<a name="ln539">		    else if (TELCMD_OK(j))</a>
<a name="ln540">			output_data(&quot;%s&quot;, TELCMD(j));</a>
<a name="ln541">		    else</a>
<a name="ln542">			output_data(&quot;%d&quot;, j);</a>
<a name="ln543">		    output_data(&quot;, not IAC SE!) &quot;);</a>
<a name="ln544">		}</a>
<a name="ln545">	    }</a>
<a name="ln546">	    length -= 2;</a>
<a name="ln547">	}</a>
<a name="ln548">	if (length &lt; 1) {</a>
<a name="ln549">	    output_data(&quot;(Empty suboption??\?)&quot;);</a>
<a name="ln550">	    return;</a>
<a name="ln551">	}</a>
<a name="ln552">	switch (pointer[0]) {</a>
<a name="ln553">	case TELOPT_TTYPE:</a>
<a name="ln554">	    output_data(&quot;TERMINAL-TYPE &quot;);</a>
<a name="ln555">	    switch (pointer[1]) {</a>
<a name="ln556">	    case TELQUAL_IS:</a>
<a name="ln557">		output_data(&quot;IS \&quot;%.*s\&quot;&quot;, length-2, (char *)pointer+2);</a>
<a name="ln558">		break;</a>
<a name="ln559">	    case TELQUAL_SEND:</a>
<a name="ln560">		output_data(&quot;SEND&quot;);</a>
<a name="ln561">		break;</a>
<a name="ln562">	    default:</a>
<a name="ln563">		output_data(</a>
<a name="ln564">				&quot;- unknown qualifier %d (0x%x).&quot;,</a>
<a name="ln565">				pointer[1], pointer[1]);</a>
<a name="ln566">	    }</a>
<a name="ln567">	    break;</a>
<a name="ln568">	case TELOPT_TSPEED:</a>
<a name="ln569">	    output_data(&quot;TERMINAL-SPEED&quot;);</a>
<a name="ln570">	    if (length &lt; 2) {</a>
<a name="ln571">		output_data(&quot; (empty suboption??\?)&quot;);</a>
<a name="ln572">		break;</a>
<a name="ln573">	    }</a>
<a name="ln574">	    switch (pointer[1]) {</a>
<a name="ln575">	    case TELQUAL_IS:</a>
<a name="ln576">		output_data(&quot; IS %.*s&quot;, length-2, (char *)pointer+2);</a>
<a name="ln577">		break;</a>
<a name="ln578">	    default:</a>
<a name="ln579">		if (pointer[1] == 1)</a>
<a name="ln580">		    output_data(&quot; SEND&quot;);</a>
<a name="ln581">		else</a>
<a name="ln582">		    output_data(&quot; %d (unknown)&quot;, pointer[1]);</a>
<a name="ln583">		for (i = 2; i &lt; length; i++) {</a>
<a name="ln584">		    output_data(&quot; ?%d?&quot;, pointer[i]);</a>
<a name="ln585">		}</a>
<a name="ln586">		break;</a>
<a name="ln587">	    }</a>
<a name="ln588">	    break;</a>
<a name="ln589"> </a>
<a name="ln590">	case TELOPT_LFLOW:</a>
<a name="ln591">	    output_data(&quot;TOGGLE-FLOW-CONTROL&quot;);</a>
<a name="ln592">	    if (length &lt; 2) {</a>
<a name="ln593">		output_data(&quot; (empty suboption??\?)&quot;);</a>
<a name="ln594">		break;</a>
<a name="ln595">	    }</a>
<a name="ln596">	    switch (pointer[1]) {</a>
<a name="ln597">	    case LFLOW_OFF:</a>
<a name="ln598">		output_data(&quot; OFF&quot;); break;</a>
<a name="ln599">	    case LFLOW_ON:</a>
<a name="ln600">		output_data(&quot; ON&quot;); break;</a>
<a name="ln601">	    case LFLOW_RESTART_ANY:</a>
<a name="ln602">		output_data(&quot; RESTART-ANY&quot;); break;</a>
<a name="ln603">	    case LFLOW_RESTART_XON:</a>
<a name="ln604">		output_data(&quot; RESTART-XON&quot;); break;</a>
<a name="ln605">	    default:</a>
<a name="ln606">		output_data(&quot; %d (unknown)&quot;, pointer[1]);</a>
<a name="ln607">	    }</a>
<a name="ln608">	    for (i = 2; i &lt; length; i++) {</a>
<a name="ln609">		output_data(&quot; ?%d?&quot;, pointer[i]);</a>
<a name="ln610">	    }</a>
<a name="ln611">	    break;</a>
<a name="ln612"> </a>
<a name="ln613">	case TELOPT_NAWS:</a>
<a name="ln614">	    output_data(&quot;NAWS&quot;);</a>
<a name="ln615">	    if (length &lt; 2) {</a>
<a name="ln616">		output_data(&quot; (empty suboption??\?)&quot;);</a>
<a name="ln617">		break;</a>
<a name="ln618">	    }</a>
<a name="ln619">	    if (length == 2) {</a>
<a name="ln620">		output_data(&quot; ?%d?&quot;, pointer[1]);</a>
<a name="ln621">		break;</a>
<a name="ln622">	    }</a>
<a name="ln623">	    output_data(&quot; %d %d (%d)&quot;,</a>
<a name="ln624">		pointer[1], pointer[2],</a>
<a name="ln625">		(int)((((unsigned int)pointer[1])&lt;&lt;8)|((unsigned int)pointer[2])));</a>
<a name="ln626">	    if (length == 4) {</a>
<a name="ln627">		output_data(&quot; ?%d?&quot;, pointer[3]);</a>
<a name="ln628">		break;</a>
<a name="ln629">	    }</a>
<a name="ln630">	    output_data(&quot; %d %d (%d)&quot;,</a>
<a name="ln631">		pointer[3], pointer[4],</a>
<a name="ln632">		(int)((((unsigned int)pointer[3])&lt;&lt;8)|((unsigned int)pointer[4])));</a>
<a name="ln633">	    for (i = 5; i &lt; length; i++) {</a>
<a name="ln634">		output_data(&quot; ?%d?&quot;, pointer[i]);</a>
<a name="ln635">	    }</a>
<a name="ln636">	    break;</a>
<a name="ln637"> </a>
<a name="ln638">	case TELOPT_LINEMODE:</a>
<a name="ln639">	    output_data(&quot;LINEMODE &quot;);</a>
<a name="ln640">	    if (length &lt; 2) {</a>
<a name="ln641">		output_data(&quot; (empty suboption??\?)&quot;);</a>
<a name="ln642">		break;</a>
<a name="ln643">	    }</a>
<a name="ln644">	    switch (pointer[1]) {</a>
<a name="ln645">	    case WILL:</a>
<a name="ln646">		output_data(&quot;WILL &quot;);</a>
<a name="ln647">		goto common;</a>
<a name="ln648">	    case WONT:</a>
<a name="ln649">		output_data(&quot;WONT &quot;);</a>
<a name="ln650">		goto common;</a>
<a name="ln651">	    case DO:</a>
<a name="ln652">		output_data(&quot;DO &quot;);</a>
<a name="ln653">		goto common;</a>
<a name="ln654">	    case DONT:</a>
<a name="ln655">		output_data(&quot;DONT &quot;);</a>
<a name="ln656">	    common:</a>
<a name="ln657">		if (length &lt; 3) {</a>
<a name="ln658">		    output_data(&quot;(no option??\?)&quot;);</a>
<a name="ln659">		    break;</a>
<a name="ln660">		}</a>
<a name="ln661">		switch (pointer[2]) {</a>
<a name="ln662">		case LM_FORWARDMASK:</a>
<a name="ln663">		    output_data(&quot;Forward Mask&quot;);</a>
<a name="ln664">		    for (i = 3; i &lt; length; i++) {</a>
<a name="ln665">			output_data(&quot; %x&quot;, pointer[i]);</a>
<a name="ln666">		    }</a>
<a name="ln667">		    break;</a>
<a name="ln668">		default:</a>
<a name="ln669">		    output_data(&quot;%d (unknown)&quot;, pointer[2]);</a>
<a name="ln670">		    for (i = 3; i &lt; length; i++) {</a>
<a name="ln671">			output_data(&quot; %d&quot;, pointer[i]);</a>
<a name="ln672">		    }</a>
<a name="ln673">		    break;</a>
<a name="ln674">		}</a>
<a name="ln675">		break;</a>
<a name="ln676"> </a>
<a name="ln677">	    case LM_SLC:</a>
<a name="ln678">		output_data(&quot;SLC&quot;);</a>
<a name="ln679">		for (i = 2; i &lt; length - 2; i += 3) {</a>
<a name="ln680">		    if (SLC_NAME_OK(pointer[i+SLC_FUNC]))</a>
<a name="ln681">			output_data(&quot; %s&quot;, SLC_NAME(pointer[i+SLC_FUNC]));</a>
<a name="ln682">		    else</a>
<a name="ln683">			output_data(&quot; %d&quot;, pointer[i+SLC_FUNC]);</a>
<a name="ln684">		    switch (pointer[i+SLC_FLAGS]&amp;SLC_LEVELBITS) {</a>
<a name="ln685">		    case SLC_NOSUPPORT:</a>
<a name="ln686">			output_data(&quot; NOSUPPORT&quot;); break;</a>
<a name="ln687">		    case SLC_CANTCHANGE:</a>
<a name="ln688">			output_data(&quot; CANTCHANGE&quot;); break;</a>
<a name="ln689">		    case SLC_VARIABLE:</a>
<a name="ln690">			output_data(&quot; VARIABLE&quot;); break;</a>
<a name="ln691">		    case SLC_DEFAULT:</a>
<a name="ln692">			output_data(&quot; DEFAULT&quot;); break;</a>
<a name="ln693">		    }</a>
<a name="ln694">		    output_data(&quot;%s%s%s&quot;,</a>
<a name="ln695">			pointer[i+SLC_FLAGS]&amp;SLC_ACK ? &quot;|ACK&quot; : &quot;&quot;,</a>
<a name="ln696">			pointer[i+SLC_FLAGS]&amp;SLC_FLUSHIN ? &quot;|FLUSHIN&quot; : &quot;&quot;,</a>
<a name="ln697">			pointer[i+SLC_FLAGS]&amp;SLC_FLUSHOUT ? &quot;|FLUSHOUT&quot; : &quot;&quot;);</a>
<a name="ln698">		    if (pointer[i+SLC_FLAGS]&amp; ~(SLC_ACK|SLC_FLUSHIN|</a>
<a name="ln699">						SLC_FLUSHOUT| SLC_LEVELBITS)) {</a>
<a name="ln700">			output_data(&quot;(0x%x)&quot;, pointer[i+SLC_FLAGS]);</a>
<a name="ln701">		    }</a>
<a name="ln702">		    output_data(&quot; %d;&quot;, pointer[i+SLC_VALUE]);</a>
<a name="ln703">		    if ((pointer[i+SLC_VALUE] == IAC) &amp;&amp;</a>
<a name="ln704">			(pointer[i+SLC_VALUE+1] == IAC))</a>
<a name="ln705">				i++;</a>
<a name="ln706">		}</a>
<a name="ln707">		for (; i &lt; length; i++) {</a>
<a name="ln708">		    output_data(&quot; ?%d?&quot;, pointer[i]);</a>
<a name="ln709">		}</a>
<a name="ln710">		break;</a>
<a name="ln711"> </a>
<a name="ln712">	    case LM_MODE:</a>
<a name="ln713">		output_data(&quot;MODE &quot;);</a>
<a name="ln714">		if (length &lt; 3) {</a>
<a name="ln715">		    output_data(&quot;(no mode??\?)&quot;);</a>
<a name="ln716">		    break;</a>
<a name="ln717">		}</a>
<a name="ln718">		{</a>
<a name="ln719">		    char tbuf[32];</a>
<a name="ln720">		    sprintf(tbuf, &quot;%s%s%s%s%s&quot;,</a>
<a name="ln721">			pointer[2]&amp;MODE_EDIT ? &quot;|EDIT&quot; : &quot;&quot;,</a>
<a name="ln722">			pointer[2]&amp;MODE_TRAPSIG ? &quot;|TRAPSIG&quot; : &quot;&quot;,</a>
<a name="ln723">			pointer[2]&amp;MODE_SOFT_TAB ? &quot;|SOFT_TAB&quot; : &quot;&quot;,</a>
<a name="ln724">			pointer[2]&amp;MODE_LIT_ECHO ? &quot;|LIT_ECHO&quot; : &quot;&quot;,</a>
<a name="ln725">			pointer[2]&amp;MODE_ACK ? &quot;|ACK&quot; : &quot;&quot;);</a>
<a name="ln726">		    output_data(&quot;%s&quot;, tbuf[1] ? &amp;tbuf[1] : &quot;0&quot;);</a>
<a name="ln727">		}</a>
<a name="ln728">		if (pointer[2]&amp;~(MODE_EDIT|MODE_TRAPSIG|MODE_ACK)) {</a>
<a name="ln729">		    output_data(&quot; (0x%x)&quot;, pointer[2]);</a>
<a name="ln730">		}</a>
<a name="ln731">		for (i = 3; i &lt; length; i++) {</a>
<a name="ln732">		    output_data(&quot; ?0x%x?&quot;, pointer[i]);</a>
<a name="ln733">		}</a>
<a name="ln734">		break;</a>
<a name="ln735">	    default:</a>
<a name="ln736">		output_data(&quot;%d (unknown)&quot;, pointer[1]);</a>
<a name="ln737">		for (i = 2; i &lt; length; i++) {</a>
<a name="ln738">		    output_data(&quot; %d&quot;, pointer[i]);</a>
<a name="ln739">		}</a>
<a name="ln740">	    }</a>
<a name="ln741">	    break;</a>
<a name="ln742"> </a>
<a name="ln743">	case TELOPT_STATUS: {</a>
<a name="ln744">	    const char *cp;</a>
<a name="ln745">	    int j, k;</a>
<a name="ln746"> </a>
<a name="ln747">	    output_data(&quot;STATUS&quot;);</a>
<a name="ln748"> </a>
<a name="ln749">	    switch (pointer[1]) {</a>
<a name="ln750">	    default:</a>
<a name="ln751">		if (pointer[1] == TELQUAL_SEND)</a>
<a name="ln752">		    output_data(&quot; SEND&quot;);</a>
<a name="ln753">		else</a>
<a name="ln754">		    output_data(&quot; %d (unknown)&quot;, pointer[1]);</a>
<a name="ln755">		for (i = 2; i &lt; length; i++) {</a>
<a name="ln756">		    output_data(&quot; ?%d?&quot;, pointer[i]);</a>
<a name="ln757">		}</a>
<a name="ln758">		break;</a>
<a name="ln759">	    case TELQUAL_IS:</a>
<a name="ln760">		output_data(&quot; IS\r\n&quot;);</a>
<a name="ln761"> </a>
<a name="ln762">		for (i = 2; i &lt; length; i++) {</a>
<a name="ln763">		    switch(pointer[i]) {</a>
<a name="ln764">		    case DO:	cp = &quot;DO&quot;; goto common2;</a>
<a name="ln765">		    case DONT:	cp = &quot;DONT&quot;; goto common2;</a>
<a name="ln766">		    case WILL:	cp = &quot;WILL&quot;; goto common2;</a>
<a name="ln767">		    case WONT:	cp = &quot;WONT&quot;; goto common2;</a>
<a name="ln768">		    common2:</a>
<a name="ln769">			i++;</a>
<a name="ln770">			if (TELOPT_OK(pointer[i]))</a>
<a name="ln771">			    output_data(&quot; %s %s&quot;, cp, TELOPT(pointer[i]));</a>
<a name="ln772">			else</a>
<a name="ln773">			    output_data(&quot; %s %d&quot;, cp, pointer[i]);</a>
<a name="ln774"> </a>
<a name="ln775">			output_data(&quot;\r\n&quot;);</a>
<a name="ln776">			break;</a>
<a name="ln777"> </a>
<a name="ln778">		    case SB:</a>
<a name="ln779">			output_data(&quot; SB &quot;);</a>
<a name="ln780">			i++;</a>
<a name="ln781">			j = k = i;</a>
<a name="ln782">			while (j &lt; length) {</a>
<a name="ln783">			    if (pointer[j] == SE) {</a>
<a name="ln784">				if (j+1 == length)</a>
<a name="ln785">				    break;</a>
<a name="ln786">				if (pointer[j+1] == SE)</a>
<a name="ln787">				    j++;</a>
<a name="ln788">				else</a>
<a name="ln789">				    break;</a>
<a name="ln790">			    }</a>
<a name="ln791">			    pointer[k++] = pointer[j++];</a>
<a name="ln792">			}</a>
<a name="ln793">			printsub(0, &amp;pointer[i], k - i);</a>
<a name="ln794">			if (i &lt; length) {</a>
<a name="ln795">			    output_data(&quot; SE&quot;);</a>
<a name="ln796">			    i = j;</a>
<a name="ln797">			} else</a>
<a name="ln798">			    i = j - 1;</a>
<a name="ln799"> </a>
<a name="ln800">			output_data(&quot;\r\n&quot;);</a>
<a name="ln801"> </a>
<a name="ln802">			break;</a>
<a name="ln803"> </a>
<a name="ln804">		    default:</a>
<a name="ln805">			output_data(&quot; %d&quot;, pointer[i]);</a>
<a name="ln806">			break;</a>
<a name="ln807">		    }</a>
<a name="ln808">		}</a>
<a name="ln809">		break;</a>
<a name="ln810">	    }</a>
<a name="ln811">	    break;</a>
<a name="ln812">	  }</a>
<a name="ln813"> </a>
<a name="ln814">	case TELOPT_XDISPLOC:</a>
<a name="ln815">	    output_data(&quot;X-DISPLAY-LOCATION &quot;);</a>
<a name="ln816">	    switch (pointer[1]) {</a>
<a name="ln817">	    case TELQUAL_IS:</a>
<a name="ln818">		output_data(&quot;IS \&quot;%.*s\&quot;&quot;, length-2, (char *)pointer+2);</a>
<a name="ln819">		break;</a>
<a name="ln820">	    case TELQUAL_SEND:</a>
<a name="ln821">		output_data(&quot;SEND&quot;);</a>
<a name="ln822">		break;</a>
<a name="ln823">	    default:</a>
<a name="ln824">		output_data(&quot;- unknown qualifier %d (0x%x).&quot;,</a>
<a name="ln825">				pointer[1], pointer[1]);</a>
<a name="ln826">	    }</a>
<a name="ln827">	    break;</a>
<a name="ln828"> </a>
<a name="ln829">	case TELOPT_NEW_ENVIRON:</a>
<a name="ln830">	    output_data(&quot;NEW-ENVIRON &quot;);</a>
<a name="ln831">	    goto env_common1;</a>
<a name="ln832">	case TELOPT_OLD_ENVIRON:</a>
<a name="ln833">	    output_data(&quot;OLD-ENVIRON&quot;);</a>
<a name="ln834">	env_common1:</a>
<a name="ln835">	    switch (pointer[1]) {</a>
<a name="ln836">	    case TELQUAL_IS:</a>
<a name="ln837">		output_data(&quot;IS &quot;);</a>
<a name="ln838">		goto env_common;</a>
<a name="ln839">	    case TELQUAL_SEND:</a>
<a name="ln840">		output_data(&quot;SEND &quot;);</a>
<a name="ln841">		goto env_common;</a>
<a name="ln842">	    case TELQUAL_INFO:</a>
<a name="ln843">		output_data(&quot;INFO &quot;);</a>
<a name="ln844">	    env_common:</a>
<a name="ln845">		{</a>
<a name="ln846">		    int noquote = 2;</a>
<a name="ln847">		    for (i = 2; i &lt; length; i++ ) {</a>
<a name="ln848">			switch (pointer[i]) {</a>
<a name="ln849">			case NEW_ENV_VAR:</a>
<a name="ln850">			    output_data(&quot;\&quot; VAR &quot; + noquote);</a>
<a name="ln851">			    noquote = 2;</a>
<a name="ln852">			    break;</a>
<a name="ln853"> </a>
<a name="ln854">			case NEW_ENV_VALUE:</a>
<a name="ln855">			    output_data(&quot;\&quot; VALUE &quot; + noquote);</a>
<a name="ln856">			    noquote = 2;</a>
<a name="ln857">			    break;</a>
<a name="ln858"> </a>
<a name="ln859">			case ENV_ESC:</a>
<a name="ln860">			    output_data(&quot;\&quot; ESC &quot; + noquote);</a>
<a name="ln861">			    noquote = 2;</a>
<a name="ln862">			    break;</a>
<a name="ln863"> </a>
<a name="ln864">			case ENV_USERVAR:</a>
<a name="ln865">			    output_data(&quot;\&quot; USERVAR &quot; + noquote);</a>
<a name="ln866">			    noquote = 2;</a>
<a name="ln867">			    break;</a>
<a name="ln868"> </a>
<a name="ln869">			default:</a>
<a name="ln870">			    if (isprint(pointer[i]) &amp;&amp; pointer[i] != '&quot;') {</a>
<a name="ln871">				if (noquote) {</a>
<a name="ln872">				    output_data(&quot;\&quot;&quot;);</a>
<a name="ln873">				    noquote = 0;</a>
<a name="ln874">				}</a>
<a name="ln875">				output_data(&quot;%c&quot;, pointer[i]);</a>
<a name="ln876">			    } else {</a>
<a name="ln877">				output_data(&quot;\&quot; %03o &quot; + noquote,</a>
<a name="ln878">							pointer[i]);</a>
<a name="ln879">				noquote = 2;</a>
<a name="ln880">			    }</a>
<a name="ln881">			    break;</a>
<a name="ln882">			}</a>
<a name="ln883">		    }</a>
<a name="ln884">		    if (!noquote)</a>
<a name="ln885">			output_data(&quot;\&quot;&quot;);</a>
<a name="ln886">		    break;</a>
<a name="ln887">		}</a>
<a name="ln888">	    }</a>
<a name="ln889">	    break;</a>
<a name="ln890"> </a>
<a name="ln891">#ifdef	AUTHENTICATION</a>
<a name="ln892">	case TELOPT_AUTHENTICATION:</a>
<a name="ln893">	    output_data(&quot;AUTHENTICATION&quot;);</a>
<a name="ln894"> </a>
<a name="ln895">	    if (length &lt; 2) {</a>
<a name="ln896">		output_data(&quot; (empty suboption??\?)&quot;);</a>
<a name="ln897">		break;</a>
<a name="ln898">	    }</a>
<a name="ln899">	    switch (pointer[1]) {</a>
<a name="ln900">	    case TELQUAL_REPLY:</a>
<a name="ln901">	    case TELQUAL_IS:</a>
<a name="ln902">		output_data(&quot; %s &quot;, (pointer[1] == TELQUAL_IS) ?</a>
<a name="ln903">							&quot;IS&quot; : &quot;REPLY&quot;);</a>
<a name="ln904">		if (AUTHTYPE_NAME_OK(pointer[2]))</a>
<a name="ln905">		    output_data(&quot;%s &quot;, AUTHTYPE_NAME(pointer[2]));</a>
<a name="ln906">		else</a>
<a name="ln907">		    output_data(&quot;%d &quot;, pointer[2]);</a>
<a name="ln908">		if (length &lt; 3) {</a>
<a name="ln909">		    output_data(&quot;(partial suboption??\?)&quot;);</a>
<a name="ln910">		    break;</a>
<a name="ln911">		}</a>
<a name="ln912">		output_data(&quot;%s|%s&quot;,</a>
<a name="ln913">			((pointer[3] &amp; AUTH_WHO_MASK) == AUTH_WHO_CLIENT) ?</a>
<a name="ln914">			&quot;CLIENT&quot; : &quot;SERVER&quot;,</a>
<a name="ln915">			((pointer[3] &amp; AUTH_HOW_MASK) == AUTH_HOW_MUTUAL) ?</a>
<a name="ln916">			&quot;MUTUAL&quot; : &quot;ONE-WAY&quot;);</a>
<a name="ln917"> </a>
<a name="ln918">    		{</a>
<a name="ln919">		    char buf[512];</a>
<a name="ln920">		    auth_printsub(&amp;pointer[1], length - 1, buf, sizeof(buf));</a>
<a name="ln921">		    output_data(&quot;%s&quot;, buf);</a>
<a name="ln922">		}</a>
<a name="ln923">		break;</a>
<a name="ln924"> </a>
<a name="ln925">	    case TELQUAL_SEND:</a>
<a name="ln926">		i = 2;</a>
<a name="ln927">		output_data(&quot; SEND &quot;);</a>
<a name="ln928">		while (i &lt; length) {</a>
<a name="ln929">		    if (AUTHTYPE_NAME_OK(pointer[i]))</a>
<a name="ln930">			output_data(&quot;%s &quot;, AUTHTYPE_NAME(pointer[i]));</a>
<a name="ln931">		    else</a>
<a name="ln932">			output_data(&quot;%d &quot;, pointer[i]);</a>
<a name="ln933">		    if (++i &gt;= length) {</a>
<a name="ln934">			output_data(&quot;(partial suboption??\?)&quot;);</a>
<a name="ln935">			break;</a>
<a name="ln936">		    }</a>
<a name="ln937">		    output_data(&quot;%s|%s &quot;,</a>
<a name="ln938">			((pointer[i] &amp; AUTH_WHO_MASK) == AUTH_WHO_CLIENT) ?</a>
<a name="ln939">							&quot;CLIENT&quot; : &quot;SERVER&quot;,</a>
<a name="ln940">			((pointer[i] &amp; AUTH_HOW_MASK) == AUTH_HOW_MUTUAL) ?</a>
<a name="ln941">							&quot;MUTUAL&quot; : &quot;ONE-WAY&quot;);</a>
<a name="ln942">		    ++i;</a>
<a name="ln943">		}</a>
<a name="ln944">		break;</a>
<a name="ln945"> </a>
<a name="ln946">	    case TELQUAL_NAME:</a>
<a name="ln947">		output_data(&quot; NAME \&quot;%.*s\&quot;&quot;, length - 2, pointer + 2);</a>
<a name="ln948">		break;</a>
<a name="ln949"> </a>
<a name="ln950">	    default:</a>
<a name="ln951">		    for (i = 2; i &lt; length; i++) {</a>
<a name="ln952">			output_data(&quot; ?%d?&quot;, pointer[i]);</a>
<a name="ln953">		    }</a>
<a name="ln954">		    break;</a>
<a name="ln955">	    }</a>
<a name="ln956">	    break;</a>
<a name="ln957">#endif</a>
<a name="ln958"> </a>
<a name="ln959">#ifdef	ENCRYPTION</a>
<a name="ln960">	case TELOPT_ENCRYPT:</a>
<a name="ln961">	    output_data(&quot;ENCRYPT&quot;);</a>
<a name="ln962">	    if (length &lt; 2) {</a>
<a name="ln963">		output_data(&quot; (empty suboption??\?)&quot;);</a>
<a name="ln964">		break;</a>
<a name="ln965">	    }</a>
<a name="ln966">	    switch (pointer[1]) {</a>
<a name="ln967">	    case ENCRYPT_START:</a>
<a name="ln968">		output_data(&quot; START&quot;);</a>
<a name="ln969">		break;</a>
<a name="ln970"> </a>
<a name="ln971">	    case ENCRYPT_END:</a>
<a name="ln972">		output_data(&quot; END&quot;);</a>
<a name="ln973">		break;</a>
<a name="ln974"> </a>
<a name="ln975">	    case ENCRYPT_REQSTART:</a>
<a name="ln976">		output_data(&quot; REQUEST-START&quot;);</a>
<a name="ln977">		break;</a>
<a name="ln978"> </a>
<a name="ln979">	    case ENCRYPT_REQEND:</a>
<a name="ln980">		output_data(&quot; REQUEST-END&quot;);</a>
<a name="ln981">		break;</a>
<a name="ln982"> </a>
<a name="ln983">	    case ENCRYPT_IS:</a>
<a name="ln984">	    case ENCRYPT_REPLY:</a>
<a name="ln985">		output_data(&quot; %s &quot;, (pointer[1] == ENCRYPT_IS) ?</a>
<a name="ln986">							&quot;IS&quot; : &quot;REPLY&quot;);</a>
<a name="ln987">		if (length &lt; 3) {</a>
<a name="ln988">		    output_data(&quot; (partial suboption??\?)&quot;);</a>
<a name="ln989">		    break;</a>
<a name="ln990">		}</a>
<a name="ln991">		if (ENCTYPE_NAME_OK(pointer[2]))</a>
<a name="ln992">		    output_data(&quot;%s &quot;, ENCTYPE_NAME(pointer[2]));</a>
<a name="ln993">		else</a>
<a name="ln994">		    output_data(&quot; %d (unknown)&quot;, pointer[2]);</a>
<a name="ln995"> </a>
<a name="ln996">		{</a>
<a name="ln997">		    char buf[512];</a>
<a name="ln998">		    encrypt_printsub(&amp;pointer[1], length - 1, buf, sizeof(buf));</a>
<a name="ln999">		    output_data(&quot;%s&quot;, buf);</a>
<a name="ln1000">		}</a>
<a name="ln1001">		break;</a>
<a name="ln1002"> </a>
<a name="ln1003">	    case ENCRYPT_SUPPORT:</a>
<a name="ln1004">		i = 2;</a>
<a name="ln1005">		output_data(&quot; SUPPORT &quot;);</a>
<a name="ln1006">		while (i &lt; length) {</a>
<a name="ln1007">		    if (ENCTYPE_NAME_OK(pointer[i]))</a>
<a name="ln1008">			output_data(&quot;%s &quot;, ENCTYPE_NAME(pointer[i]));</a>
<a name="ln1009">		    else</a>
<a name="ln1010">			output_data(&quot;%d &quot;, pointer[i]);</a>
<a name="ln1011">		    i++;</a>
<a name="ln1012">		}</a>
<a name="ln1013">		break;</a>
<a name="ln1014"> </a>
<a name="ln1015">	    case ENCRYPT_ENC_KEYID:</a>
<a name="ln1016">		output_data(&quot; ENC_KEYID&quot;);</a>
<a name="ln1017">		goto encommon;</a>
<a name="ln1018"> </a>
<a name="ln1019">	    case ENCRYPT_DEC_KEYID:</a>
<a name="ln1020">		output_data(&quot; DEC_KEYID&quot;);</a>
<a name="ln1021">		goto encommon;</a>
<a name="ln1022"> </a>
<a name="ln1023">	    default:</a>
<a name="ln1024">		output_data(&quot; %d (unknown)&quot;, pointer[1]);</a>
<a name="ln1025">	    encommon:</a>
<a name="ln1026">		for (i = 2; i &lt; length; i++) {</a>
<a name="ln1027">		    output_data(&quot; %d&quot;, pointer[i]);</a>
<a name="ln1028">		}</a>
<a name="ln1029">		break;</a>
<a name="ln1030">	    }</a>
<a name="ln1031">	    break;</a>
<a name="ln1032">#endif	/* ENCRYPTION */</a>
<a name="ln1033"> </a>
<a name="ln1034">	default:</a>
<a name="ln1035">	    if (TELOPT_OK(pointer[0]))</a>
<a name="ln1036">		output_data(&quot;%s (unknown)&quot;, TELOPT(pointer[0]));</a>
<a name="ln1037">	    else</a>
<a name="ln1038">		output_data(&quot;%d (unknown)&quot;, pointer[i]);</a>
<a name="ln1039">	    for (i = 1; i &lt; length; i++) {</a>
<a name="ln1040">		output_data(&quot; %d&quot;, pointer[i]);</a>
<a name="ln1041">	    }</a>
<a name="ln1042">	    break;</a>
<a name="ln1043">	}</a>
<a name="ln1044">	output_data(&quot;\r\n&quot;);</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">/*</a>
<a name="ln1048"> * Dump a data buffer in hex and ascii to the output data stream.</a>
<a name="ln1049"> */</a>
<a name="ln1050">void</a>
<a name="ln1051">printdata(const char *tag, char *ptr, int cnt)</a>
<a name="ln1052">{</a>
<a name="ln1053">	int i;</a>
<a name="ln1054">	char xbuf[30];</a>
<a name="ln1055"> </a>
<a name="ln1056">	while (cnt) {</a>
<a name="ln1057">		/* flush net output buffer if no room for new data) */</a>
<a name="ln1058">		if ((&amp;netobuf[BUFSIZ] - nfrontp) &lt; 80) {</a>
<a name="ln1059">			netflush();</a>
<a name="ln1060">		}</a>
<a name="ln1061"> </a>
<a name="ln1062">		/* add a line of output */</a>
<a name="ln1063">		output_data(&quot;%s: &quot;, tag);</a>
<a name="ln1064">		for (i = 0; i &lt; 20 &amp;&amp; cnt; i++) {</a>
<a name="ln1065">			output_data(&quot;%02x&quot;, *ptr);</a>
<a name="ln1066">			if (isprint(*ptr)) {</a>
<a name="ln1067">				xbuf[i] = *ptr;</a>
<a name="ln1068">			} else {</a>
<a name="ln1069">				xbuf[i] = '.';</a>
<a name="ln1070">			}</a>
<a name="ln1071">			if (i % 2) {</a>
<a name="ln1072">				output_data(&quot; &quot;);</a>
<a name="ln1073">			}</a>
<a name="ln1074">			cnt--;</a>
<a name="ln1075">			ptr++;</a>
<a name="ln1076">		}</a>
<a name="ln1077">		xbuf[i] = '\0';</a>
<a name="ln1078">		output_data(&quot; %s\r\n&quot;, xbuf );</a>
<a name="ln1079">	}</a>
<a name="ln1080">}</a>
<a name="ln1081">#endif /* DIAGNOSTICS */</a>

</code></pre>
<div class="balloon" rel="231"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions '(nfrontp > next)' to the left and to the right of the '&&' operator.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
