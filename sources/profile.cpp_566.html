
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>profile.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2008-2010, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2013, Rene Gollent, rene@gollent.com.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;ctype.h&gt;</a>
<a name="ln9">#include &lt;errno.h&gt;</a>
<a name="ln10">#include &lt;getopt.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;algorithm&gt;</a>
<a name="ln16">#include &lt;map&gt;</a>
<a name="ln17">#include &lt;new&gt;</a>
<a name="ln18">#include &lt;string&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;debugger.h&gt;</a>
<a name="ln21">#include &lt;FindDirectory.h&gt;</a>
<a name="ln22">#include &lt;OS.h&gt;</a>
<a name="ln23">#include &lt;Path.h&gt;</a>
<a name="ln24">#include &lt;String.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;syscalls.h&gt;</a>
<a name="ln27">#include &lt;system_profiler_defs.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln30">#include &lt;debug_support.h&gt;</a>
<a name="ln31">#include &lt;ObjectList.h&gt;</a>
<a name="ln32">#include &lt;Referenceable.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;util/DoublyLinkedList.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;BasicProfileResult.h&quot;</a>
<a name="ln37">#include &quot;CallgrindProfileResult.h&quot;</a>
<a name="ln38">#include &quot;debug_utils.h&quot;</a>
<a name="ln39">#include &quot;Image.h&quot;</a>
<a name="ln40">#include &quot;Options.h&quot;</a>
<a name="ln41">#include &quot;SummaryProfileResult.h&quot;</a>
<a name="ln42">#include &quot;Team.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">// size of the sample buffer area for system profiling</a>
<a name="ln46">#define PROFILE_ALL_SAMPLE_AREA_SIZE	(4 * 1024 * 1024)</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">extern const char* __progname;</a>
<a name="ln50">const char* kCommandName = __progname;</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">class Image;</a>
<a name="ln54">class Team;</a>
<a name="ln55">class Thread;</a>
<a name="ln56"> </a>
<a name="ln57"> </a>
<a name="ln58">static const char* kUsage =</a>
<a name="ln59">	&quot;Usage: %s [ &lt;options&gt; ] [ &lt;command line&gt; ]\n&quot;</a>
<a name="ln60">	&quot;Profiles threads by periodically sampling the program counter. There are\n&quot;</a>
<a name="ln61">	&quot;two different modes: One profiles the complete system. The other starts\n&quot;</a>
<a name="ln62">	&quot;a program and profiles that and (optionally) its children. When a thread\n&quot;</a>
<a name="ln63">	&quot;terminates, a list of the functions where the thread was encountered is\n&quot;</a>
<a name="ln64">	&quot;printed.\n&quot;</a>
<a name="ln65">	&quot;\n&quot;</a>
<a name="ln66">	&quot;Options:\n&quot;</a>
<a name="ln67">	&quot;  -a, --all      - Profile all teams.\n&quot;</a>
<a name="ln68">	&quot;  -c             - Don't profile child threads. Default is to\n&quot;</a>
<a name="ln69">	&quot;                   recursively profile all threads created by a profiled\n&quot;</a>
<a name="ln70">	&quot;                   thread.\n&quot;</a>
<a name="ln71">	&quot;  -C             - Don't profile child teams. Default is to recursively\n&quot;</a>
<a name="ln72">	&quot;                   profile all teams created by a profiled team.\n&quot;</a>
<a name="ln73">	&quot;  -f             - Always analyze the full caller stack. The hit count\n&quot;</a>
<a name="ln74">	&quot;                   for every encountered function will be incremented.\n&quot;</a>
<a name="ln75">	&quot;                   This increases the default for the caller stack depth\n&quot;</a>
<a name="ln76">	&quot;                   (\&quot;-s\&quot;) to 64.\n&quot;</a>
<a name="ln77">	&quot;  -h, --help     - Print this usage info.\n&quot;</a>
<a name="ln78">	&quot;  -i &lt;interval&gt;  - Use a tick interval of &lt;interval&gt; microseconds.\n&quot;</a>
<a name="ln79">	&quot;                   Default is 1000 (1 ms). On a fast machine, a shorter\n&quot;</a>
<a name="ln80">	&quot;                   interval might lead to better results, while it might\n&quot;</a>
<a name="ln81">	&quot;                   make them worse on slow machines.\n&quot;</a>
<a name="ln82">	&quot;  -k             - Don't check kernel images for hits.\n&quot;</a>
<a name="ln83">	&quot;  -l             - Also profile loading the executable.\n&quot;</a>
<a name="ln84">	&quot;  -o &lt;output&gt;    - Print the results to file &lt;output&gt;.\n&quot;</a>
<a name="ln85">	&quot;  -r, --recorded - Don't profile, but evaluate a recorded kernel profile\n&quot;</a>
<a name="ln86">	&quot;                   data.\n&quot;</a>
<a name="ln87">	&quot;  -s &lt;depth&gt;     - Number of return address samples to take from the\n&quot;</a>
<a name="ln88">	&quot;                   caller stack per tick. If the topmost address doesn't\n&quot;</a>
<a name="ln89">	&quot;                   hit a known image, the next address will be matched\n&quot;</a>
<a name="ln90">	&quot;                   (and so on).\n&quot;</a>
<a name="ln91">	&quot;  -S             - Don't output results for individual threads, but\n&quot;</a>
<a name="ln92">	&quot;                   produce a combined output at the end.\n&quot;</a>
<a name="ln93">	&quot;  -v &lt;directory&gt; - Create valgrind/callgrind output. &lt;directory&gt; is the\n&quot;</a>
<a name="ln94">	&quot;                   directory where to put the output files.\n&quot;</a>
<a name="ln95">;</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">Options gOptions;</a>
<a name="ln99"> </a>
<a name="ln100">static bool sCaughtDeadlySignal = false;</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">class ThreadManager : private ProfiledEntity {</a>
<a name="ln104">public:</a>
<a name="ln105">	ThreadManager(port_id debuggerPort)</a>
<a name="ln106">		:</a>
<a name="ln107">		fTeams(20),</a>
<a name="ln108">		fThreads(20, true),</a>
<a name="ln109">		fKernelTeam(NULL),</a>
<a name="ln110">		fDebuggerPort(debuggerPort),</a>
<a name="ln111">		fSummaryProfileResult(NULL)</a>
<a name="ln112">	{</a>
<a name="ln113">	}</a>
<a name="ln114"> </a>
<a name="ln115">	virtual ~ThreadManager()</a>
<a name="ln116">	{</a>
<a name="ln117">		// release image references</a>
<a name="ln118">		for (ImageMap::iterator it = fImages.begin(); it != fImages.end(); ++it)</a>
<a name="ln119">			it-&gt;second-&gt;ReleaseReference();</a>
<a name="ln120"> </a>
<a name="ln121">		if (fSummaryProfileResult != NULL)</a>
<a name="ln122">			fSummaryProfileResult-&gt;ReleaseReference();</a>
<a name="ln123"> </a>
<a name="ln124">		for (int32 i = 0; Team* team = fTeams.ItemAt(i); i++)</a>
<a name="ln125">			team-&gt;ReleaseReference();</a>
<a name="ln126">	}</a>
<a name="ln127"> </a>
<a name="ln128">	status_t Init()</a>
<a name="ln129">	{</a>
<a name="ln130">		if (!gOptions.summary_result)</a>
<a name="ln131">			return B_OK;</a>
<a name="ln132"> </a>
<a name="ln133">		ProfileResult* profileResult;</a>
<a name="ln134">		status_t error = _CreateProfileResult(this, profileResult);</a>
<a name="ln135">		if (error != B_OK)</a>
<a name="ln136">			return error;</a>
<a name="ln137"> </a>
<a name="ln138">		BReference&lt;ProfileResult&gt; profileResultReference(profileResult, true);</a>
<a name="ln139"> </a>
<a name="ln140">		fSummaryProfileResult = new(std::nothrow) SummaryProfileResult(</a>
<a name="ln141">			profileResult);</a>
<a name="ln142">		if (fSummaryProfileResult == NULL)</a>
<a name="ln143">			return B_NO_MEMORY;</a>
<a name="ln144"> </a>
<a name="ln145">		return fSummaryProfileResult-&gt;Init(profileResult-&gt;Entity());</a>
<a name="ln146">	}</a>
<a name="ln147"> </a>
<a name="ln148">	status_t AddTeam(team_id teamID, Team** _team = NULL)</a>
<a name="ln149">	{</a>
<a name="ln150">		return _AddTeam(teamID, NULL, _team);</a>
<a name="ln151">	}</a>
<a name="ln152"> </a>
<a name="ln153">	status_t AddTeam(system_profiler_team_added* addedInfo, Team** _team = NULL)</a>
<a name="ln154">	{</a>
<a name="ln155">		return _AddTeam(addedInfo-&gt;team, addedInfo, _team);</a>
<a name="ln156">	}</a>
<a name="ln157"> </a>
<a name="ln158">	status_t AddThread(thread_id threadID)</a>
<a name="ln159">	{</a>
<a name="ln160">		thread_info threadInfo;</a>
<a name="ln161">		status_t error = get_thread_info(threadID, &amp;threadInfo);</a>
<a name="ln162">		if (error != B_OK)</a>
<a name="ln163">			return error;</a>
<a name="ln164"> </a>
<a name="ln165">		return AddThread(threadInfo.team, threadID, threadInfo.name);</a>
<a name="ln166">	}</a>
<a name="ln167"> </a>
<a name="ln168">	status_t AddThread(team_id teamID, thread_id threadID, const char* name)</a>
<a name="ln169">	{</a>
<a name="ln170">		if (FindThread(threadID) != NULL)</a>
<a name="ln171">			return B_BAD_VALUE;</a>
<a name="ln172"> </a>
<a name="ln173">		Team* team = FindTeam(teamID);</a>
<a name="ln174">		if (team == NULL)</a>
<a name="ln175">			return B_BAD_TEAM_ID;</a>
<a name="ln176"> </a>
<a name="ln177">		Thread* thread = new(std::nothrow) Thread(threadID, name, team);</a>
<a name="ln178">		if (thread == NULL)</a>
<a name="ln179">			return B_NO_MEMORY;</a>
<a name="ln180"> </a>
<a name="ln181">		status_t error = _CreateThreadProfileResult(thread);</a>
<a name="ln182">		if (error != B_OK) {</a>
<a name="ln183">			delete thread;</a>
<a name="ln184">			return error;</a>
<a name="ln185">		}</a>
<a name="ln186"> </a>
<a name="ln187">		error = team-&gt;InitThread(thread);</a>
<a name="ln188">		if (error != B_OK) {</a>
<a name="ln189">			delete thread;</a>
<a name="ln190">			return error;</a>
<a name="ln191">		}</a>
<a name="ln192"> </a>
<a name="ln193">		fThreads.AddItem(thread);</a>
<a name="ln194">		return B_OK;</a>
<a name="ln195">	}</a>
<a name="ln196"> </a>
<a name="ln197">	void RemoveTeam(team_id teamID)</a>
<a name="ln198">	{</a>
<a name="ln199">		if (Team* team = FindTeam(teamID)) {</a>
<a name="ln200">			if (team == fKernelTeam)</a>
<a name="ln201">				fKernelTeam = NULL;</a>
<a name="ln202">			fTeams.RemoveItem(team);</a>
<a name="ln203">			team-&gt;ReleaseReference();</a>
<a name="ln204">		}</a>
<a name="ln205">	}</a>
<a name="ln206"> </a>
<a name="ln207">	void RemoveThread(thread_id threadID)</a>
<a name="ln208">	{</a>
<a name="ln209">		if (Thread* thread = FindThread(threadID)) {</a>
<a name="ln210">			thread-&gt;GetTeam()-&gt;RemoveThread(thread);</a>
<a name="ln211">			fThreads.RemoveItem(thread, true);</a>
<a name="ln212">		}</a>
<a name="ln213">	}</a>
<a name="ln214"> </a>
<a name="ln215">	Team* FindTeam(team_id teamID) const</a>
<a name="ln216">	{</a>
<a name="ln217">		for (int32 i = 0; Team* team = fTeams.ItemAt(i); i++) {</a>
<a name="ln218">			if (team-&gt;ID() == teamID)</a>
<a name="ln219">				return team;</a>
<a name="ln220">		}</a>
<a name="ln221">		return NULL;</a>
<a name="ln222">	}</a>
<a name="ln223"> </a>
<a name="ln224">	Thread* FindThread(thread_id threadID) const</a>
<a name="ln225">	{</a>
<a name="ln226">		for (int32 i = 0; Thread* thread = fThreads.ItemAt(i); i++) {</a>
<a name="ln227">			if (thread-&gt;ID() == threadID)</a>
<a name="ln228">				return thread;</a>
<a name="ln229">		}</a>
<a name="ln230">		return NULL;</a>
<a name="ln231">	}</a>
<a name="ln232"> </a>
<a name="ln233">	int32 CountThreads() const</a>
<a name="ln234">	{</a>
<a name="ln235">		return fThreads.CountItems();</a>
<a name="ln236">	}</a>
<a name="ln237"> </a>
<a name="ln238">	Thread* ThreadAt(int32 index) const</a>
<a name="ln239">	{</a>
<a name="ln240">		return fThreads.ItemAt(index);</a>
<a name="ln241">	}</a>
<a name="ln242"> </a>
<a name="ln243">	status_t AddImage(team_id teamID, const image_info&amp; imageInfo, int32 event)</a>
<a name="ln244">	{</a>
<a name="ln245">		// get a shared image</a>
<a name="ln246">		SharedImage* sharedImage = NULL;</a>
<a name="ln247">		status_t error = _GetSharedImage(teamID, imageInfo, &amp;sharedImage);</a>
<a name="ln248">		if (error != B_OK)</a>
<a name="ln249">			return error;</a>
<a name="ln250"> </a>
<a name="ln251">		if (teamID == B_SYSTEM_TEAM) {</a>
<a name="ln252">			// a kernel image -- add it to all teams</a>
<a name="ln253">			int32 count = fTeams.CountItems();</a>
<a name="ln254">			for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln255">				fTeams.ItemAt(i)-&gt;AddImage(sharedImage, imageInfo, teamID,</a>
<a name="ln256">					event);</a>
<a name="ln257">			}</a>
<a name="ln258">		}</a>
<a name="ln259"> </a>
<a name="ln260">		// a userland team image -- add it to that image</a>
<a name="ln261">		if (Team* team = FindTeam(teamID))</a>
<a name="ln262">			return team-&gt;AddImage(sharedImage, imageInfo, teamID, event);</a>
<a name="ln263"> </a>
<a name="ln264">		return B_BAD_TEAM_ID;</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	void RemoveImage(team_id teamID, image_id imageID, int32 event)</a>
<a name="ln268">	{</a>
<a name="ln269">		if (teamID == B_SYSTEM_TEAM) {</a>
<a name="ln270">			// a kernel image -- remove it from all teams</a>
<a name="ln271">			int32 count = fTeams.CountItems();</a>
<a name="ln272">			for (int32 i = 0; i &lt; count; i++)</a>
<a name="ln273">				fTeams.ItemAt(i)-&gt;RemoveImage(imageID, event);</a>
<a name="ln274">		} else {</a>
<a name="ln275">			// a userland team image -- add it to that image</a>
<a name="ln276">			if (Team* team = FindTeam(teamID))</a>
<a name="ln277">				team-&gt;RemoveImage(imageID, event);</a>
<a name="ln278">		}</a>
<a name="ln279">	}</a>
<a name="ln280"> </a>
<a name="ln281">	void PrintSummaryResults()</a>
<a name="ln282">	{</a>
<a name="ln283">		if (fSummaryProfileResult != NULL)</a>
<a name="ln284">			fSummaryProfileResult-&gt;PrintSummaryResults();</a>
<a name="ln285">	}</a>
<a name="ln286"> </a>
<a name="ln287">private:</a>
<a name="ln288">	virtual int32 EntityID() const</a>
<a name="ln289">	{</a>
<a name="ln290">		return 1;</a>
<a name="ln291">	}</a>
<a name="ln292"> </a>
<a name="ln293">	virtual const char* EntityName() const</a>
<a name="ln294">	{</a>
<a name="ln295">		return &quot;all&quot;;</a>
<a name="ln296">	}</a>
<a name="ln297"> </a>
<a name="ln298">	virtual const char* EntityType() const</a>
<a name="ln299">	{</a>
<a name="ln300">		return &quot;summary&quot;;</a>
<a name="ln301">	}</a>
<a name="ln302"> </a>
<a name="ln303">private:</a>
<a name="ln304">	status_t _AddTeam(team_id teamID, system_profiler_team_added* addedInfo,</a>
<a name="ln305">		Team** _team = NULL)</a>
<a name="ln306">	{</a>
<a name="ln307">		if (FindTeam(teamID) != NULL)</a>
<a name="ln308">			return B_BAD_VALUE;</a>
<a name="ln309"> </a>
<a name="ln310">		Team* team = new(std::nothrow) Team;</a>
<a name="ln311">		if (team == NULL)</a>
<a name="ln312">			return B_NO_MEMORY;</a>
<a name="ln313"> </a>
<a name="ln314">		status_t error = addedInfo != NULL</a>
<a name="ln315">			? _InitUndebuggedTeam(team, addedInfo)</a>
<a name="ln316">			: _InitDebuggedTeam(team, teamID);</a>
<a name="ln317">		if (error != B_OK) {</a>
<a name="ln318">			team-&gt;ReleaseReference();</a>
<a name="ln319">			return error;</a>
<a name="ln320">		}</a>
<a name="ln321"> </a>
<a name="ln322">		fTeams.AddItem(team);</a>
<a name="ln323"> </a>
<a name="ln324">		if (teamID == B_SYSTEM_TEAM)</a>
<a name="ln325">			fKernelTeam = team;</a>
<a name="ln326"> </a>
<a name="ln327">		if (_team != NULL)</a>
<a name="ln328">			*_team = team;</a>
<a name="ln329"> </a>
<a name="ln330">		return B_OK;</a>
<a name="ln331">	}</a>
<a name="ln332"> </a>
<a name="ln333">	status_t _InitDebuggedTeam(Team* team, team_id teamID)</a>
<a name="ln334">	{</a>
<a name="ln335">		// init the team</a>
<a name="ln336">		status_t error = team-&gt;Init(teamID, fDebuggerPort);</a>
<a name="ln337">		if (error != B_OK)</a>
<a name="ln338">			return error;</a>
<a name="ln339"> </a>
<a name="ln340">		// add the team's images</a>
<a name="ln341">		error = _LoadTeamImages(team, teamID);</a>
<a name="ln342">		if (error != B_OK)</a>
<a name="ln343">			return error;</a>
<a name="ln344"> </a>
<a name="ln345">		// add the kernel images</a>
<a name="ln346">		return _LoadTeamImages(team, B_SYSTEM_TEAM);</a>
<a name="ln347">	}</a>
<a name="ln348"> </a>
<a name="ln349">	status_t _InitUndebuggedTeam(Team* team,</a>
<a name="ln350">		system_profiler_team_added* addedInfo)</a>
<a name="ln351">	{</a>
<a name="ln352">		// init the team</a>
<a name="ln353">		status_t error = team-&gt;Init(addedInfo);</a>
<a name="ln354">		if (error != B_OK)</a>
<a name="ln355">			return error;</a>
<a name="ln356"> </a>
<a name="ln357">		// in case of a user team, add the kernel images</a>
<a name="ln358">		if (team-&gt;ID() == B_SYSTEM_TEAM || fKernelTeam == NULL)</a>
<a name="ln359">			return B_OK;</a>
<a name="ln360"> </a>
<a name="ln361">		const BObjectList&lt;Image&gt;&amp; kernelImages = fKernelTeam-&gt;Images();</a>
<a name="ln362">		int32 count = kernelImages.CountItems();</a>
<a name="ln363">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln364">			SharedImage* sharedImage = kernelImages.ItemAt(i)-&gt;GetSharedImage();</a>
<a name="ln365">			team-&gt;AddImage(sharedImage, sharedImage-&gt;Info(), B_SYSTEM_TEAM, 0);</a>
<a name="ln366">		}</a>
<a name="ln367"> </a>
<a name="ln368">		return B_OK;</a>
<a name="ln369">	}</a>
<a name="ln370"> </a>
<a name="ln371">	status_t _LoadTeamImages(Team* team, team_id teamID)</a>
<a name="ln372">	{</a>
<a name="ln373">		// iterate through the team's images and collect the symbols</a>
<a name="ln374">		image_info imageInfo;</a>
<a name="ln375">		int32 cookie = 0;</a>
<a name="ln376">		while (get_next_image_info(teamID, &amp;cookie, &amp;imageInfo) == B_OK) {</a>
<a name="ln377">			// get a shared image</a>
<a name="ln378">			SharedImage* sharedImage;</a>
<a name="ln379">			status_t error = _GetSharedImage(teamID, imageInfo, &amp;sharedImage);</a>
<a name="ln380">			if (error != B_OK)</a>
<a name="ln381">				return error;</a>
<a name="ln382"> </a>
<a name="ln383">			// add the image to the team</a>
<a name="ln384">			error = team-&gt;AddImage(sharedImage, imageInfo, teamID, 0);</a>
<a name="ln385">			if (error != B_OK)</a>
<a name="ln386">				return error;</a>
<a name="ln387">		}</a>
<a name="ln388"> </a>
<a name="ln389">		return B_OK;</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	status_t _CreateThreadProfileResult(Thread* thread)</a>
<a name="ln393">	{</a>
<a name="ln394">		if (fSummaryProfileResult != NULL) {</a>
<a name="ln395">			thread-&gt;SetProfileResult(fSummaryProfileResult);</a>
<a name="ln396">			return B_OK;</a>
<a name="ln397">		}</a>
<a name="ln398"> </a>
<a name="ln399">		ProfileResult* profileResult;</a>
<a name="ln400">		status_t error = _CreateProfileResult(thread, profileResult);</a>
<a name="ln401">		if (error != B_OK)</a>
<a name="ln402">			return error;</a>
<a name="ln403"> </a>
<a name="ln404">		thread-&gt;SetProfileResult(profileResult);</a>
<a name="ln405"> </a>
<a name="ln406">		return B_OK;</a>
<a name="ln407">	}</a>
<a name="ln408"> </a>
<a name="ln409">	status_t _CreateProfileResult(ProfiledEntity* profiledEntity,</a>
<a name="ln410">		ProfileResult*&amp; _profileResult)</a>
<a name="ln411">	{</a>
<a name="ln412">		ProfileResult* profileResult;</a>
<a name="ln413"> </a>
<a name="ln414">		if (gOptions.callgrind_directory != NULL)</a>
<a name="ln415">			profileResult = new(std::nothrow) CallgrindProfileResult;</a>
<a name="ln416">		else if (gOptions.analyze_full_stack)</a>
<a name="ln417">			profileResult = new(std::nothrow) InclusiveProfileResult;</a>
<a name="ln418">		else</a>
<a name="ln419">			profileResult = new(std::nothrow) ExclusiveProfileResult;</a>
<a name="ln420"> </a>
<a name="ln421">		if (profileResult == NULL)</a>
<a name="ln422">			return B_NO_MEMORY;</a>
<a name="ln423"> </a>
<a name="ln424">		BReference&lt;ProfileResult&gt; profileResultReference(profileResult, true);</a>
<a name="ln425"> </a>
<a name="ln426">		status_t error = profileResult-&gt;Init(profiledEntity);</a>
<a name="ln427">		if (error != B_OK)</a>
<a name="ln428">			return error;</a>
<a name="ln429"> </a>
<a name="ln430">		_profileResult = profileResultReference.Detach();</a>
<a name="ln431">		return B_OK;</a>
<a name="ln432">	}</a>
<a name="ln433"> </a>
<a name="ln434">	status_t _GetSharedImage(team_id teamID, const image_info&amp; imageInfo,</a>
<a name="ln435">		SharedImage** _sharedImage)</a>
<a name="ln436">	{</a>
<a name="ln437">		// check whether the image has already been loaded</a>
<a name="ln438">		ImageMap::iterator it = fImages.find(imageInfo.name);</a>
<a name="ln439">		if (it != fImages.end()) {</a>
<a name="ln440">			*_sharedImage = it-&gt;second;</a>
<a name="ln441">			return B_OK;</a>
<a name="ln442">		}</a>
<a name="ln443"> </a>
<a name="ln444">		// create the shared image</a>
<a name="ln445">		SharedImage* sharedImage = new(std::nothrow) SharedImage;</a>
<a name="ln446">		if (sharedImage == NULL)</a>
<a name="ln447">			return B_NO_MEMORY;</a>
<a name="ln448">		ObjectDeleter&lt;SharedImage&gt; imageDeleter(sharedImage);</a>
<a name="ln449"> </a>
<a name="ln450">		// load the symbols</a>
<a name="ln451">		status_t error;</a>
<a name="ln452">		if (teamID == B_SYSTEM_TEAM) {</a>
<a name="ln453">			error = sharedImage-&gt;Init(teamID, imageInfo.id);</a>
<a name="ln454">			if (error != B_OK) {</a>
<a name="ln455">				// The image has obviously been unloaded already, try to get</a>
<a name="ln456">				// it by path.</a>
<a name="ln457">				BString name = imageInfo.name;</a>
<a name="ln458">				if (name.FindFirst('/') == -1) {</a>
<a name="ln459">					// modules without a path are likely to be boot modules</a>
<a name="ln460">					BPath bootAddonPath;</a>
<a name="ln461">					if (find_directory(B_SYSTEM_ADDONS_DIRECTORY,</a>
<a name="ln462">							&amp;bootAddonPath) == B_OK</a>
<a name="ln463">						&amp;&amp; bootAddonPath.Append(&quot;kernel&quot;) == B_OK</a>
<a name="ln464">						&amp;&amp; bootAddonPath.Append(&quot;boot&quot;) == B_OK) {</a>
<a name="ln465">						name = BString(bootAddonPath.Path()) &lt;&lt; &quot;/&quot; &lt;&lt; name;</a>
<a name="ln466">				}</a>
<a name="ln467">				}</a>
<a name="ln468"> </a>
<a name="ln469">				error = sharedImage-&gt;Init(name.String());</a>
<a name="ln470">			}</a>
<a name="ln471">		} else if (strcmp(imageInfo.name, &quot;commpage&quot;) == 0)</a>
<a name="ln472">			error = sharedImage-&gt;Init(teamID, imageInfo.id);</a>
<a name="ln473">		else</a>
<a name="ln474">			error = sharedImage-&gt;Init(imageInfo.name);</a>
<a name="ln475">		if (error != B_OK)</a>
<a name="ln476">			return error;</a>
<a name="ln477"> </a>
<a name="ln478">		try {</a>
<a name="ln479">			fImages[sharedImage-&gt;Name()] = sharedImage;</a>
<a name="ln480">		} catch (std::bad_alloc&amp;) {</a>
<a name="ln481">			return B_NO_MEMORY;</a>
<a name="ln482">		}</a>
<a name="ln483"> </a>
<a name="ln484">		imageDeleter.Detach();</a>
<a name="ln485">		*_sharedImage = sharedImage;</a>
<a name="ln486">		return B_OK;</a>
<a name="ln487">	}</a>
<a name="ln488"> </a>
<a name="ln489">private:</a>
<a name="ln490">	typedef std::map&lt;std::string, SharedImage*&gt; ImageMap;</a>
<a name="ln491"> </a>
<a name="ln492">private:</a>
<a name="ln493">	BObjectList&lt;Team&gt;				fTeams;</a>
<a name="ln494">	BObjectList&lt;Thread&gt;				fThreads;</a>
<a name="ln495">	ImageMap						fImages;</a>
<a name="ln496">	Team*							fKernelTeam;</a>
<a name="ln497">	port_id							fDebuggerPort;</a>
<a name="ln498">	SummaryProfileResult*			fSummaryProfileResult;</a>
<a name="ln499">};</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">static void</a>
<a name="ln503">print_usage_and_exit(bool error)</a>
<a name="ln504">{</a>
<a name="ln505">    fprintf(error ? stderr : stdout, kUsage, __progname);</a>
<a name="ln506">    exit(error ? 1 : 0);</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">/*</a>
<a name="ln511">// get_id</a>
<a name="ln512">static bool</a>
<a name="ln513">get_id(const char *str, int32 &amp;id)</a>
<a name="ln514">{</a>
<a name="ln515">	int32 len = strlen(str);</a>
<a name="ln516">	for (int32 i = 0; i &lt; len; i++) {</a>
<a name="ln517">		if (!isdigit(str[i]))</a>
<a name="ln518">			return false;</a>
<a name="ln519">	}</a>
<a name="ln520"> </a>
<a name="ln521">	id = atol(str);</a>
<a name="ln522">	return true;</a>
<a name="ln523">}</a>
<a name="ln524">*/</a>
<a name="ln525"> </a>
<a name="ln526"> </a>
<a name="ln527">static bool</a>
<a name="ln528">process_event_buffer(ThreadManager&amp; threadManager, uint8* buffer,</a>
<a name="ln529">	size_t bufferSize, team_id mainTeam)</a>
<a name="ln530">{</a>
<a name="ln531">//printf(&quot;process_event_buffer(%p, %lu)\n&quot;, buffer, bufferSize);</a>
<a name="ln532">	const uint8* bufferEnd = buffer + bufferSize;</a>
<a name="ln533"> </a>
<a name="ln534">	while (buffer &lt; bufferEnd) {</a>
<a name="ln535">		system_profiler_event_header* header</a>
<a name="ln536">			= (system_profiler_event_header*)buffer;</a>
<a name="ln537"> </a>
<a name="ln538">		buffer += sizeof(system_profiler_event_header);</a>
<a name="ln539"> </a>
<a name="ln540">		switch (header-&gt;event) {</a>
<a name="ln541">			case B_SYSTEM_PROFILER_TEAM_ADDED:</a>
<a name="ln542">			{</a>
<a name="ln543">				system_profiler_team_added* event</a>
<a name="ln544">					= (system_profiler_team_added*)buffer;</a>
<a name="ln545"> </a>
<a name="ln546">				if (threadManager.AddTeam(event) != B_OK)</a>
<a name="ln547">					exit(1);</a>
<a name="ln548">				break;</a>
<a name="ln549">			}</a>
<a name="ln550"> </a>
<a name="ln551">			case B_SYSTEM_PROFILER_TEAM_REMOVED:</a>
<a name="ln552">			{</a>
<a name="ln553">				system_profiler_team_removed* event</a>
<a name="ln554">					= (system_profiler_team_removed*)buffer;</a>
<a name="ln555"> </a>
<a name="ln556">				threadManager.RemoveTeam(event-&gt;team);</a>
<a name="ln557"> </a>
<a name="ln558">				// quit, if the main team we're interested in is gone</a>
<a name="ln559">				if (mainTeam &gt;= 0 &amp;&amp; event-&gt;team == mainTeam)</a>
<a name="ln560">					return true;</a>
<a name="ln561"> </a>
<a name="ln562">				break;</a>
<a name="ln563">			}</a>
<a name="ln564"> </a>
<a name="ln565">			case B_SYSTEM_PROFILER_TEAM_EXEC:</a>
<a name="ln566">			{</a>
<a name="ln567">				system_profiler_team_exec* event</a>
<a name="ln568">					= (system_profiler_team_exec*)buffer;</a>
<a name="ln569"> </a>
<a name="ln570">				if (Team* team = threadManager.FindTeam(event-&gt;team))</a>
<a name="ln571">					team-&gt;Exec(0, event-&gt;args, event-&gt;thread_name);</a>
<a name="ln572">				break;</a>
<a name="ln573">			}</a>
<a name="ln574"> </a>
<a name="ln575">			case B_SYSTEM_PROFILER_THREAD_ADDED:</a>
<a name="ln576">			{</a>
<a name="ln577">				system_profiler_thread_added* event</a>
<a name="ln578">					= (system_profiler_thread_added*)buffer;</a>
<a name="ln579"> </a>
<a name="ln580">				if (threadManager.AddThread(event-&gt;team, event-&gt;thread,</a>
<a name="ln581">						event-&gt;name) != B_OK) {</a>
<a name="ln582">					exit(1);</a>
<a name="ln583">				}</a>
<a name="ln584">				break;</a>
<a name="ln585">			}</a>
<a name="ln586"> </a>
<a name="ln587">			case B_SYSTEM_PROFILER_THREAD_REMOVED:</a>
<a name="ln588">			{</a>
<a name="ln589">				system_profiler_thread_removed* event</a>
<a name="ln590">					= (system_profiler_thread_removed*)buffer;</a>
<a name="ln591"> </a>
<a name="ln592">				if (Thread* thread = threadManager.FindThread(event-&gt;thread)) {</a>
<a name="ln593">					thread-&gt;PrintResults();</a>
<a name="ln594">					threadManager.RemoveThread(event-&gt;thread);</a>
<a name="ln595">				}</a>
<a name="ln596">				break;</a>
<a name="ln597">			}</a>
<a name="ln598"> </a>
<a name="ln599">			case B_SYSTEM_PROFILER_IMAGE_ADDED:</a>
<a name="ln600">			{</a>
<a name="ln601">				system_profiler_image_added* event</a>
<a name="ln602">					= (system_profiler_image_added*)buffer;</a>
<a name="ln603"> </a>
<a name="ln604">				threadManager.AddImage(event-&gt;team, event-&gt;info, 0);</a>
<a name="ln605">				break;</a>
<a name="ln606">			}</a>
<a name="ln607"> </a>
<a name="ln608">			case B_SYSTEM_PROFILER_IMAGE_REMOVED:</a>
<a name="ln609">			{</a>
<a name="ln610">				system_profiler_image_removed* event</a>
<a name="ln611">					= (system_profiler_image_removed*)buffer;</a>
<a name="ln612"> </a>
<a name="ln613"> 				threadManager.RemoveImage(event-&gt;team, event-&gt;image, 0);</a>
<a name="ln614">				break;</a>
<a name="ln615">			}</a>
<a name="ln616"> </a>
<a name="ln617">			case B_SYSTEM_PROFILER_SAMPLES:</a>
<a name="ln618">			{</a>
<a name="ln619">				system_profiler_samples* event</a>
<a name="ln620">					= (system_profiler_samples*)buffer;</a>
<a name="ln621"> </a>
<a name="ln622">				Thread* thread = threadManager.FindThread(event-&gt;thread);</a>
<a name="ln623">				if (thread != NULL) {</a>
<a name="ln624">					thread-&gt;AddSamples(event-&gt;samples,</a>
<a name="ln625">						(addr_t*)(buffer + header-&gt;size) - event-&gt;samples);</a>
<a name="ln626">				}</a>
<a name="ln627"> </a>
<a name="ln628">				break;</a>
<a name="ln629">			}</a>
<a name="ln630"> </a>
<a name="ln631">			case B_SYSTEM_PROFILER_BUFFER_END:</a>
<a name="ln632">			{</a>
<a name="ln633">				// Marks the end of the ring buffer -- we need to ignore the</a>
<a name="ln634">				// remaining bytes.</a>
<a name="ln635">				return false;</a>
<a name="ln636">			}</a>
<a name="ln637">		}</a>
<a name="ln638"> </a>
<a name="ln639">		buffer += header-&gt;size;</a>
<a name="ln640">	}</a>
<a name="ln641"> </a>
<a name="ln642">	return false;</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645"> </a>
<a name="ln646">static void</a>
<a name="ln647">signal_handler(int signal, void* data)</a>
<a name="ln648">{</a>
<a name="ln649">	sCaughtDeadlySignal = true;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652"> </a>
<a name="ln653">static void</a>
<a name="ln654">profile_all(const char* const* programArgs, int programArgCount)</a>
<a name="ln655">{</a>
<a name="ln656">	// Load the executable, if we have to.</a>
<a name="ln657">	thread_id threadID = -1;</a>
<a name="ln658">	if (programArgCount &gt;= 1) {</a>
<a name="ln659">		threadID = load_program(programArgs, programArgCount,</a>
<a name="ln660">			gOptions.profile_loading);</a>
<a name="ln661">		if (threadID &lt; 0) {</a>
<a name="ln662">			fprintf(stderr, &quot;%s: Failed to start `%s': %s\n&quot;, kCommandName,</a>
<a name="ln663">				programArgs[0], strerror(threadID));</a>
<a name="ln664">			exit(1);</a>
<a name="ln665">		}</a>
<a name="ln666">	}</a>
<a name="ln667"> </a>
<a name="ln668">	// install signal handlers so we can exit gracefully</a>
<a name="ln669">    struct sigaction action;</a>
<a name="ln670">    action.sa_handler = (__sighandler_t)signal_handler;</a>
<a name="ln671">    sigemptyset(&amp;action.sa_mask);</a>
<a name="ln672">    action.sa_userdata = NULL;</a>
<a name="ln673">    if (sigaction(SIGHUP, &amp;action, NULL) &lt; 0</a>
<a name="ln674">		|| sigaction(SIGINT, &amp;action, NULL) &lt; 0</a>
<a name="ln675">		|| sigaction(SIGQUIT, &amp;action, NULL) &lt; 0) {</a>
<a name="ln676">		fprintf(stderr, &quot;%s: Failed to install signal handlers: %s\n&quot;,</a>
<a name="ln677">			kCommandName, strerror(errno));</a>
<a name="ln678">		exit(1);</a>
<a name="ln679">    }</a>
<a name="ln680"> </a>
<a name="ln681">	// create an area for the sample buffer</a>
<a name="ln682">	system_profiler_buffer_header* bufferHeader;</a>
<a name="ln683">	area_id area = create_area(&quot;profiling buffer&quot;, (void**)&amp;bufferHeader,</a>
<a name="ln684">		B_ANY_ADDRESS, PROFILE_ALL_SAMPLE_AREA_SIZE, B_NO_LOCK,</a>
<a name="ln685">		B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln686">	if (area &lt; 0) {</a>
<a name="ln687">		fprintf(stderr, &quot;%s: Failed to create sample area: %s\n&quot;, kCommandName,</a>
<a name="ln688">			strerror(area));</a>
<a name="ln689">		exit(1);</a>
<a name="ln690">	}</a>
<a name="ln691"> </a>
<a name="ln692">	uint8* bufferBase = (uint8*)(bufferHeader + 1);</a>
<a name="ln693">	size_t totalBufferSize = PROFILE_ALL_SAMPLE_AREA_SIZE</a>
<a name="ln694">		- (bufferBase - (uint8*)bufferHeader);</a>
<a name="ln695"> </a>
<a name="ln696">	// create a thread manager</a>
<a name="ln697">	ThreadManager threadManager(-1);	// TODO: We don't need a debugger port!</a>
<a name="ln698">	status_t error = threadManager.Init();</a>
<a name="ln699">	if (error != B_OK) {</a>
<a name="ln700">		fprintf(stderr, &quot;%s: Failed to init thread manager: %s\n&quot;, kCommandName,</a>
<a name="ln701">			strerror(error));</a>
<a name="ln702">		exit(1);</a>
<a name="ln703">	}</a>
<a name="ln704"> </a>
<a name="ln705">	// start profiling</a>
<a name="ln706">	system_profiler_parameters profilerParameters;</a>
<a name="ln707">	profilerParameters.buffer_area = area;</a>
<a name="ln708">	profilerParameters.flags = B_SYSTEM_PROFILER_TEAM_EVENTS</a>
<a name="ln709">		| B_SYSTEM_PROFILER_THREAD_EVENTS | B_SYSTEM_PROFILER_IMAGE_EVENTS</a>
<a name="ln710">		| B_SYSTEM_PROFILER_SAMPLING_EVENTS;</a>
<a name="ln711">	profilerParameters.interval = gOptions.interval;</a>
<a name="ln712">	profilerParameters.stack_depth = gOptions.stack_depth;</a>
<a name="ln713"> </a>
<a name="ln714">	error = _kern_system_profiler_start(&amp;profilerParameters);</a>
<a name="ln715">	if (error != B_OK) {</a>
<a name="ln716">		fprintf(stderr, &quot;%s: Failed to start profiling: %s\n&quot;, kCommandName,</a>
<a name="ln717">			strerror(error));</a>
<a name="ln718">		exit(1);</a>
<a name="ln719">	}</a>
<a name="ln720"> </a>
<a name="ln721">	// resume the loaded team, if we have one</a>
<a name="ln722">	if (threadID &gt;= 0)</a>
<a name="ln723">		resume_thread(threadID);</a>
<a name="ln724"> </a>
<a name="ln725">	// main event loop</a>
<a name="ln726">	while (true) {</a>
<a name="ln727">		// get the current buffer</a>
<a name="ln728">		size_t bufferStart = bufferHeader-&gt;start;</a>
<a name="ln729">		size_t bufferSize = bufferHeader-&gt;size;</a>
<a name="ln730">		uint8* buffer = bufferBase + bufferStart;</a>
<a name="ln731">//printf(&quot;processing buffer of size %lu bytes\n&quot;, bufferSize);</a>
<a name="ln732"> </a>
<a name="ln733">		bool quit;</a>
<a name="ln734">		if (bufferStart + bufferSize &lt;= totalBufferSize) {</a>
<a name="ln735">			quit = process_event_buffer(threadManager, buffer, bufferSize,</a>
<a name="ln736">				threadID);</a>
<a name="ln737">		} else {</a>
<a name="ln738">			size_t remainingSize = bufferStart + bufferSize - totalBufferSize;</a>
<a name="ln739">			quit = process_event_buffer(threadManager, buffer,</a>
<a name="ln740">					bufferSize - remainingSize, threadID)</a>
<a name="ln741">				|| process_event_buffer(threadManager, bufferBase,</a>
<a name="ln742">					remainingSize, threadID);</a>
<a name="ln743">		}</a>
<a name="ln744"> </a>
<a name="ln745">		if (quit)</a>
<a name="ln746">			break;</a>
<a name="ln747"> </a>
<a name="ln748">		// get next buffer</a>
<a name="ln749">		uint64 droppedEvents = 0;</a>
<a name="ln750">		error = _kern_system_profiler_next_buffer(bufferSize, &amp;droppedEvents);</a>
<a name="ln751"> </a>
<a name="ln752">		if (error != B_OK) {</a>
<a name="ln753">			if (error == B_INTERRUPTED) {</a>
<a name="ln754">				if (sCaughtDeadlySignal)</a>
<a name="ln755">					break;</a>
<a name="ln756">				continue;</a>
<a name="ln757">			}</a>
<a name="ln758"> </a>
<a name="ln759">			fprintf(stderr, &quot;%s: Failed to get next sample buffer: %s\n&quot;,</a>
<a name="ln760">				kCommandName, strerror(error));</a>
<a name="ln761">			break;</a>
<a name="ln762">		}</a>
<a name="ln763">	}</a>
<a name="ln764"> </a>
<a name="ln765">	// stop profiling</a>
<a name="ln766">	_kern_system_profiler_stop();</a>
<a name="ln767"> </a>
<a name="ln768">	// print results</a>
<a name="ln769">	int32 threadCount = threadManager.CountThreads();</a>
<a name="ln770">	for (int32 i = 0; i &lt; threadCount; i++) {</a>
<a name="ln771">		Thread* thread = threadManager.ThreadAt(i);</a>
<a name="ln772">		thread-&gt;PrintResults();</a>
<a name="ln773">	}</a>
<a name="ln774"> </a>
<a name="ln775">	threadManager.PrintSummaryResults();</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778"> </a>
<a name="ln779">static void</a>
<a name="ln780">dump_recorded()</a>
<a name="ln781">{</a>
<a name="ln782">	// retrieve recorded samples and parameters</a>
<a name="ln783">	system_profiler_parameters profilerParameters;</a>
<a name="ln784">	status_t error = _kern_system_profiler_recorded(&amp;profilerParameters);</a>
<a name="ln785">	if (error != B_OK) {</a>
<a name="ln786">		fprintf(stderr, &quot;%s: Failed to get recorded profiling buffer: %s\n&quot;,</a>
<a name="ln787">			kCommandName, strerror(error));</a>
<a name="ln788">		exit(1);</a>
<a name="ln789">	}</a>
<a name="ln790"> </a>
<a name="ln791">	// set global options to those of the profiler parameters</a>
<a name="ln792">	gOptions.interval = profilerParameters.interval;</a>
<a name="ln793">	gOptions.stack_depth = profilerParameters.stack_depth;</a>
<a name="ln794"> </a>
<a name="ln795">	// create an area for the sample buffer</a>
<a name="ln796">	area_info info;</a>
<a name="ln797">	error = get_area_info(profilerParameters.buffer_area, &amp;info);</a>
<a name="ln798">	if (error != B_OK) {</a>
<a name="ln799">		fprintf(stderr, &quot;%s: Recorded profiling buffer invalid: %s\n&quot;,</a>
<a name="ln800">			kCommandName, strerror(error));</a>
<a name="ln801">		exit(1);</a>
<a name="ln802">	}</a>
<a name="ln803"> </a>
<a name="ln804">	system_profiler_buffer_header* bufferHeader</a>
<a name="ln805">		= (system_profiler_buffer_header*)info.address;</a>
<a name="ln806"> </a>
<a name="ln807">	uint8* bufferBase = (uint8*)(bufferHeader + 1);</a>
<a name="ln808">	size_t totalBufferSize = info.size - (bufferBase - (uint8*)bufferHeader);</a>
<a name="ln809"> </a>
<a name="ln810">	// create a thread manager</a>
<a name="ln811">	ThreadManager threadManager(-1);	// TODO: We don't need a debugger port!</a>
<a name="ln812">	error = threadManager.Init();</a>
<a name="ln813">	if (error != B_OK) {</a>
<a name="ln814">		fprintf(stderr, &quot;%s: Failed to init thread manager: %s\n&quot;, kCommandName,</a>
<a name="ln815">			strerror(error));</a>
<a name="ln816">		exit(1);</a>
<a name="ln817">	}</a>
<a name="ln818"> </a>
<a name="ln819">	// get the current buffer</a>
<a name="ln820">	size_t bufferStart = bufferHeader-&gt;start;</a>
<a name="ln821">	size_t bufferSize = bufferHeader-&gt;size;</a>
<a name="ln822">	uint8* buffer = bufferBase + bufferStart;</a>
<a name="ln823"> </a>
<a name="ln824">	if (bufferStart + bufferSize &lt;= totalBufferSize) {</a>
<a name="ln825">		process_event_buffer(threadManager, buffer, bufferSize, -1);</a>
<a name="ln826">	} else {</a>
<a name="ln827">		size_t remainingSize = bufferStart + bufferSize - totalBufferSize;</a>
<a name="ln828">		if (!process_event_buffer(threadManager, buffer,</a>
<a name="ln829">				bufferSize - remainingSize, -1)) {</a>
<a name="ln830">			process_event_buffer(threadManager, bufferBase, remainingSize, -1);</a>
<a name="ln831">		}</a>
<a name="ln832">	}</a>
<a name="ln833"> </a>
<a name="ln834">	// print results</a>
<a name="ln835">	int32 threadCount = threadManager.CountThreads();</a>
<a name="ln836">	for (int32 i = 0; i &lt; threadCount; i++) {</a>
<a name="ln837">		Thread* thread = threadManager.ThreadAt(i);</a>
<a name="ln838">		thread-&gt;PrintResults();</a>
<a name="ln839">	}</a>
<a name="ln840"> </a>
<a name="ln841">	threadManager.PrintSummaryResults();</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">static void</a>
<a name="ln846">profile_single(const char* const* programArgs, int programArgCount)</a>
<a name="ln847">{</a>
<a name="ln848">	// get thread/team to be debugged</a>
<a name="ln849">	thread_id threadID = load_program(programArgs, programArgCount,</a>
<a name="ln850">		gOptions.profile_loading);</a>
<a name="ln851">	if (threadID &lt; 0) {</a>
<a name="ln852">		fprintf(stderr, &quot;%s: Failed to start `%s': %s\n&quot;, kCommandName,</a>
<a name="ln853">			programArgs[0], strerror(threadID));</a>
<a name="ln854">		exit(1);</a>
<a name="ln855">	}</a>
<a name="ln856"> </a>
<a name="ln857">	// get the team ID</a>
<a name="ln858">	thread_info threadInfo;</a>
<a name="ln859">	status_t error = get_thread_info(threadID, &amp;threadInfo);</a>
<a name="ln860">	if (error != B_OK) {</a>
<a name="ln861">		fprintf(stderr, &quot;%s: Failed to get info for thread %ld: %s\n&quot;,</a>
<a name="ln862">			kCommandName, threadID, strerror(error));</a>
<a name="ln863">		exit(1);</a>
<a name="ln864">	}</a>
<a name="ln865">	team_id teamID = threadInfo.team;</a>
<a name="ln866"> </a>
<a name="ln867">	// create a debugger port</a>
<a name="ln868">	port_id debuggerPort = create_port(10, &quot;debugger port&quot;);</a>
<a name="ln869">	if (debuggerPort &lt; 0) {</a>
<a name="ln870">		fprintf(stderr, &quot;%s: Failed to create debugger port: %s\n&quot;,</a>
<a name="ln871">			kCommandName, strerror(debuggerPort));</a>
<a name="ln872">		exit(1);</a>
<a name="ln873">	}</a>
<a name="ln874"> </a>
<a name="ln875">	// add team and thread to the thread manager</a>
<a name="ln876">	ThreadManager threadManager(debuggerPort);</a>
<a name="ln877">	error = threadManager.Init();</a>
<a name="ln878">	if (error != B_OK) {</a>
<a name="ln879">		fprintf(stderr, &quot;%s: Failed to init thread manager: %s\n&quot;, kCommandName,</a>
<a name="ln880">			strerror(error));</a>
<a name="ln881">		exit(1);</a>
<a name="ln882">	}</a>
<a name="ln883"> </a>
<a name="ln884">	if (threadManager.AddTeam(teamID) != B_OK</a>
<a name="ln885">		|| threadManager.AddThread(threadID) != B_OK) {</a>
<a name="ln886">		exit(1);</a>
<a name="ln887">	}</a>
<a name="ln888"> </a>
<a name="ln889">	// debug loop</a>
<a name="ln890">	while (true) {</a>
<a name="ln891">		debug_debugger_message_data message;</a>
<a name="ln892">		bool quitLoop = false;</a>
<a name="ln893">		int32 code;</a>
<a name="ln894">		ssize_t messageSize = read_port(debuggerPort, &amp;code, &amp;message,</a>
<a name="ln895">			sizeof(message));</a>
<a name="ln896"> </a>
<a name="ln897">		if (messageSize &lt; 0) {</a>
<a name="ln898">			if (messageSize == B_INTERRUPTED)</a>
<a name="ln899">				continue;</a>
<a name="ln900"> </a>
<a name="ln901">			fprintf(stderr, &quot;%s: Reading from debugger port failed: %s\n&quot;,</a>
<a name="ln902">				kCommandName, strerror(messageSize));</a>
<a name="ln903">			exit(1);</a>
<a name="ln904">		}</a>
<a name="ln905"> </a>
<a name="ln906">		switch (code) {</a>
<a name="ln907">			case B_DEBUGGER_MESSAGE_PROFILER_UPDATE:</a>
<a name="ln908">			{</a>
<a name="ln909">				Thread* thread = threadManager.FindThread(</a>
<a name="ln910">					message.profiler_update.origin.thread);</a>
<a name="ln911">				if (thread == NULL)</a>
<a name="ln912">					break;</a>
<a name="ln913"> </a>
<a name="ln914">				thread-&gt;AddSamples(message.profiler_update.sample_count,</a>
<a name="ln915">					message.profiler_update.dropped_ticks,</a>
<a name="ln916">					message.profiler_update.stack_depth,</a>
<a name="ln917">					message.profiler_update.variable_stack_depth,</a>
<a name="ln918">					message.profiler_update.image_event);</a>
<a name="ln919"> </a>
<a name="ln920">				if (message.profiler_update.stopped) {</a>
<a name="ln921">					thread-&gt;PrintResults();</a>
<a name="ln922">					threadManager.RemoveThread(thread-&gt;ID());</a>
<a name="ln923">				}</a>
<a name="ln924">				break;</a>
<a name="ln925">			}</a>
<a name="ln926"> </a>
<a name="ln927">			case B_DEBUGGER_MESSAGE_TEAM_CREATED:</a>
<a name="ln928">				if (!gOptions.profile_teams)</a>
<a name="ln929">					break;</a>
<a name="ln930"> </a>
<a name="ln931">				if (threadManager.AddTeam(message.team_created.new_team)</a>
<a name="ln932">						== B_OK) {</a>
<a name="ln933">					threadManager.AddThread(message.team_created.new_team);</a>
<a name="ln934">				}</a>
<a name="ln935">				break;</a>
<a name="ln936">			case B_DEBUGGER_MESSAGE_TEAM_DELETED:</a>
<a name="ln937">				// a debugged team is gone -- quit, if it is our team</a>
<a name="ln938">				threadManager.RemoveTeam(message.origin.team);</a>
<a name="ln939">				quitLoop = message.origin.team == teamID;</a>
<a name="ln940">				break;</a>
<a name="ln941">			case B_DEBUGGER_MESSAGE_TEAM_EXEC:</a>
<a name="ln942">				if (Team* team = threadManager.FindTeam(message.origin.team)) {</a>
<a name="ln943">					team_info teamInfo;</a>
<a name="ln944">					thread_info threadInfo;</a>
<a name="ln945">					if (get_team_info(message.origin.team, &amp;teamInfo) == B_OK</a>
<a name="ln946">						&amp;&amp; get_thread_info(message.origin.team, &amp;threadInfo)</a>
<a name="ln947">							== B_OK) {</a>
<a name="ln948">						team-&gt;Exec(message.team_exec.image_event, teamInfo.args,</a>
<a name="ln949">							threadInfo.name);</a>
<a name="ln950">					}</a>
<a name="ln951">				}</a>
<a name="ln952">				break;</a>
<a name="ln953"> </a>
<a name="ln954">			case B_DEBUGGER_MESSAGE_THREAD_CREATED:</a>
<a name="ln955">				if (!gOptions.profile_threads)</a>
<a name="ln956">					break;</a>
<a name="ln957"> </a>
<a name="ln958">				threadManager.AddThread(message.thread_created.new_thread);</a>
<a name="ln959">				break;</a>
<a name="ln960">			case B_DEBUGGER_MESSAGE_THREAD_DELETED:</a>
<a name="ln961">				threadManager.RemoveThread(message.origin.thread);</a>
<a name="ln962">				break;</a>
<a name="ln963"> </a>
<a name="ln964">			case B_DEBUGGER_MESSAGE_IMAGE_CREATED:</a>
<a name="ln965">				threadManager.AddImage(message.origin.team,</a>
<a name="ln966">					message.image_created.info,</a>
<a name="ln967">					message.image_created.image_event);</a>
<a name="ln968">				break;</a>
<a name="ln969">			case B_DEBUGGER_MESSAGE_IMAGE_DELETED:</a>
<a name="ln970">				threadManager.RemoveImage(message.origin.team,</a>
<a name="ln971">					message.image_deleted.info.id,</a>
<a name="ln972">					message.image_deleted.image_event);</a>
<a name="ln973">				break;</a>
<a name="ln974"> </a>
<a name="ln975">			case B_DEBUGGER_MESSAGE_POST_SYSCALL:</a>
<a name="ln976">			case B_DEBUGGER_MESSAGE_SIGNAL_RECEIVED:</a>
<a name="ln977">			case B_DEBUGGER_MESSAGE_THREAD_DEBUGGED:</a>
<a name="ln978">			case B_DEBUGGER_MESSAGE_DEBUGGER_CALL:</a>
<a name="ln979">			case B_DEBUGGER_MESSAGE_BREAKPOINT_HIT:</a>
<a name="ln980">			case B_DEBUGGER_MESSAGE_WATCHPOINT_HIT:</a>
<a name="ln981">			case B_DEBUGGER_MESSAGE_SINGLE_STEP:</a>
<a name="ln982">			case B_DEBUGGER_MESSAGE_PRE_SYSCALL:</a>
<a name="ln983">			case B_DEBUGGER_MESSAGE_EXCEPTION_OCCURRED:</a>
<a name="ln984">				break;</a>
<a name="ln985">		}</a>
<a name="ln986"> </a>
<a name="ln987">		if (quitLoop)</a>
<a name="ln988">			break;</a>
<a name="ln989"> </a>
<a name="ln990">		// tell the thread to continue (only when there is a thread and the</a>
<a name="ln991">		// message was synchronous)</a>
<a name="ln992">		if (message.origin.thread &gt;= 0 &amp;&amp; message.origin.nub_port &gt;= 0)</a>
<a name="ln993">			continue_thread(message.origin.nub_port, message.origin.thread);</a>
<a name="ln994">	}</a>
<a name="ln995"> </a>
<a name="ln996">	// prints summary results</a>
<a name="ln997">	threadManager.PrintSummaryResults();</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000"> </a>
<a name="ln1001">int</a>
<a name="ln1002">main(int argc, const char* const* argv)</a>
<a name="ln1003">{</a>
<a name="ln1004">	int32 stackDepth = 0;</a>
<a name="ln1005">	bool dumpRecorded = false;</a>
<a name="ln1006">	const char* outputFile = NULL;</a>
<a name="ln1007"> </a>
<a name="ln1008">	while (true) {</a>
<a name="ln1009">		static struct option sLongOptions[] = {</a>
<a name="ln1010">			{ &quot;all&quot;, no_argument, 0, 'a' },</a>
<a name="ln1011">			{ &quot;help&quot;, no_argument, 0, 'h' },</a>
<a name="ln1012">			{ &quot;recorded&quot;, no_argument, 0, 'r' },</a>
<a name="ln1013">			{ 0, 0, 0, 0 }</a>
<a name="ln1014">		};</a>
<a name="ln1015"> </a>
<a name="ln1016">		opterr = 0; // don't print errors</a>
<a name="ln1017">		int c = getopt_long(argc, (char**)argv, &quot;+acCfhi:klo:rs:Sv:&quot;,</a>
<a name="ln1018">			sLongOptions, NULL);</a>
<a name="ln1019">		if (c == -1)</a>
<a name="ln1020">			break;</a>
<a name="ln1021"> </a>
<a name="ln1022">		switch (c) {</a>
<a name="ln1023">			case 'a':</a>
<a name="ln1024">				gOptions.profile_all = true;</a>
<a name="ln1025">				break;</a>
<a name="ln1026">			case 'c':</a>
<a name="ln1027">				gOptions.profile_threads = false;</a>
<a name="ln1028">				break;</a>
<a name="ln1029">			case 'C':</a>
<a name="ln1030">				gOptions.profile_teams = false;</a>
<a name="ln1031">				break;</a>
<a name="ln1032">			case 'f':</a>
<a name="ln1033">				gOptions.stack_depth = 64;</a>
<a name="ln1034">				gOptions.analyze_full_stack = true;</a>
<a name="ln1035">				break;</a>
<a name="ln1036">			case 'h':</a>
<a name="ln1037">				print_usage_and_exit(false);</a>
<a name="ln1038">				break;</a>
<a name="ln1039">			case 'i':</a>
<a name="ln1040">				gOptions.interval = atol(optarg);</a>
<a name="ln1041">				break;</a>
<a name="ln1042">			case 'k':</a>
<a name="ln1043">				gOptions.profile_kernel = false;</a>
<a name="ln1044">				break;</a>
<a name="ln1045">			case 'l':</a>
<a name="ln1046">				gOptions.profile_loading = true;</a>
<a name="ln1047">				break;</a>
<a name="ln1048">			case 'o':</a>
<a name="ln1049">				outputFile = optarg;</a>
<a name="ln1050">				break;</a>
<a name="ln1051">			case 'r':</a>
<a name="ln1052">				dumpRecorded = true;</a>
<a name="ln1053">				break;</a>
<a name="ln1054">			case 's':</a>
<a name="ln1055">				stackDepth = atol(optarg);</a>
<a name="ln1056">				break;</a>
<a name="ln1057">			case 'S':</a>
<a name="ln1058">				gOptions.summary_result = true;</a>
<a name="ln1059">				break;</a>
<a name="ln1060">			case 'v':</a>
<a name="ln1061">				gOptions.callgrind_directory = optarg;</a>
<a name="ln1062">				gOptions.analyze_full_stack = true;</a>
<a name="ln1063">				gOptions.stack_depth = 64;</a>
<a name="ln1064">				break;</a>
<a name="ln1065">			default:</a>
<a name="ln1066">				print_usage_and_exit(true);</a>
<a name="ln1067">				break;</a>
<a name="ln1068">		}</a>
<a name="ln1069">	}</a>
<a name="ln1070"> </a>
<a name="ln1071">	if ((!gOptions.profile_all &amp;&amp; !dumpRecorded &amp;&amp; optind &gt;= argc)</a>
<a name="ln1072">		|| (dumpRecorded &amp;&amp; optind != argc))</a>
<a name="ln1073">		print_usage_and_exit(true);</a>
<a name="ln1074"> </a>
<a name="ln1075">	if (stackDepth != 0)</a>
<a name="ln1076">		gOptions.stack_depth = stackDepth;</a>
<a name="ln1077"> </a>
<a name="ln1078">	if (outputFile != NULL) {</a>
<a name="ln1079">		gOptions.output = fopen(outputFile, &quot;w+&quot;);</a>
<a name="ln1080">		if (gOptions.output == NULL) {</a>
<a name="ln1081">			fprintf(stderr, &quot;%s: Failed to open output file \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln1082">				kCommandName, outputFile, strerror(errno));</a>
<a name="ln1083">			exit(1);</a>
<a name="ln1084">		}</a>
<a name="ln1085">	} else</a>
<a name="ln1086">		gOptions.output = stdout;</a>
<a name="ln1087"> </a>
<a name="ln1088">	if (dumpRecorded) {</a>
<a name="ln1089">		dump_recorded();</a>
<a name="ln1090">		return 0;</a>
<a name="ln1091">	}</a>
<a name="ln1092"> </a>
<a name="ln1093">	const char* const* programArgs = argv + optind;</a>
<a name="ln1094">	int programArgCount = argc - optind;</a>
<a name="ln1095"> </a>
<a name="ln1096">	if (gOptions.profile_all) {</a>
<a name="ln1097">		profile_all(programArgs, programArgCount);</a>
<a name="ln1098">		return 0;</a>
<a name="ln1099">	}</a>
<a name="ln1100"> </a>
<a name="ln1101">	profile_single(programArgs, programArgCount);</a>
<a name="ln1102">	return 0;</a>
<a name="ln1103">}</a>

</code></pre>
<div class="balloon" rel="861"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'fprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
