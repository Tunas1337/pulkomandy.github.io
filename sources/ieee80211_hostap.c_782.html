
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ieee80211_hostap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2007-2008 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> *</a>
<a name="ln16"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</a>
<a name="ln17"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</a>
<a name="ln18"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</a>
<a name="ln19"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</a>
<a name="ln20"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</a>
<a name="ln21"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln22"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln23"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln24"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</a>
<a name="ln25"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln26"> */</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln29">#ifdef __FreeBSD__</a>
<a name="ln30">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/net80211/ieee80211_hostap.c 326272 2017-11-27 15:23:17Z pfg $&quot;);</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33">/*</a>
<a name="ln34"> * IEEE 802.11 HOSTAP mode support.</a>
<a name="ln35"> */</a>
<a name="ln36">#include &quot;opt_inet.h&quot;</a>
<a name="ln37">#include &quot;opt_wlan.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;sys/param.h&gt;</a>
<a name="ln40">#include &lt;sys/systm.h&gt; </a>
<a name="ln41">#include &lt;sys/mbuf.h&gt;   </a>
<a name="ln42">#include &lt;sys/malloc.h&gt;</a>
<a name="ln43">#include &lt;sys/kernel.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;sys/socket.h&gt;</a>
<a name="ln46">#include &lt;sys/sockio.h&gt;</a>
<a name="ln47">#include &lt;sys/endian.h&gt;</a>
<a name="ln48">#include &lt;sys/errno.h&gt;</a>
<a name="ln49">#include &lt;sys/proc.h&gt;</a>
<a name="ln50">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;net/if.h&gt;</a>
<a name="ln53">#include &lt;net/if_var.h&gt;</a>
<a name="ln54">#include &lt;net/if_media.h&gt;</a>
<a name="ln55">#include &lt;net/if_llc.h&gt;</a>
<a name="ln56">#include &lt;net/ethernet.h&gt;</a>
<a name="ln57"> </a>
<a name="ln58">#include &lt;net/bpf.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln61">#include &lt;net80211/ieee80211_hostap.h&gt;</a>
<a name="ln62">#include &lt;net80211/ieee80211_input.h&gt;</a>
<a name="ln63">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln64">#include &lt;net80211/ieee80211_superg.h&gt;</a>
<a name="ln65">#endif</a>
<a name="ln66">#include &lt;net80211/ieee80211_wds.h&gt;</a>
<a name="ln67">#include &lt;net80211/ieee80211_vht.h&gt;</a>
<a name="ln68"> </a>
<a name="ln69">#define	IEEE80211_RATE2MBS(r)	(((r) &amp; IEEE80211_RATE_VAL) / 2)</a>
<a name="ln70"> </a>
<a name="ln71">static	void hostap_vattach(struct ieee80211vap *);</a>
<a name="ln72">static	int hostap_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln73">static	int hostap_input(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln74">	    const struct ieee80211_rx_stats *,</a>
<a name="ln75">	    int rssi, int nf);</a>
<a name="ln76">static void hostap_deliver_data(struct ieee80211vap *,</a>
<a name="ln77">	    struct ieee80211_node *, struct mbuf *);</a>
<a name="ln78">static void hostap_recv_mgmt(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln79">	    int subtype, const struct ieee80211_rx_stats *rxs, int rssi, int nf);</a>
<a name="ln80">static void hostap_recv_ctl(struct ieee80211_node *, struct mbuf *, int);</a>
<a name="ln81"> </a>
<a name="ln82">void</a>
<a name="ln83">ieee80211_hostap_attach(struct ieee80211com *ic)</a>
<a name="ln84">{</a>
<a name="ln85">	ic-&gt;ic_vattach[IEEE80211_M_HOSTAP] = hostap_vattach;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">void</a>
<a name="ln89">ieee80211_hostap_detach(struct ieee80211com *ic)</a>
<a name="ln90">{</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">static void</a>
<a name="ln94">hostap_vdetach(struct ieee80211vap *vap)</a>
<a name="ln95">{</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">static void</a>
<a name="ln99">hostap_vattach(struct ieee80211vap *vap)</a>
<a name="ln100">{</a>
<a name="ln101">	vap-&gt;iv_newstate = hostap_newstate;</a>
<a name="ln102">	vap-&gt;iv_input = hostap_input;</a>
<a name="ln103">	vap-&gt;iv_recv_mgmt = hostap_recv_mgmt;</a>
<a name="ln104">	vap-&gt;iv_recv_ctl = hostap_recv_ctl;</a>
<a name="ln105">	vap-&gt;iv_opdetach = hostap_vdetach;</a>
<a name="ln106">	vap-&gt;iv_deliver_data = hostap_deliver_data;</a>
<a name="ln107">	vap-&gt;iv_recv_pspoll = ieee80211_recv_pspoll;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">static void</a>
<a name="ln111">sta_disassoc(void *arg, struct ieee80211_node *ni)</a>
<a name="ln112">{</a>
<a name="ln113"> </a>
<a name="ln114">	if (ni-&gt;ni_associd != 0) {</a>
<a name="ln115">		IEEE80211_SEND_MGMT(ni, IEEE80211_FC0_SUBTYPE_DISASSOC,</a>
<a name="ln116">			IEEE80211_REASON_ASSOC_LEAVE);</a>
<a name="ln117">		ieee80211_node_leave(ni);</a>
<a name="ln118">	}</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">static void</a>
<a name="ln122">sta_csa(void *arg, struct ieee80211_node *ni)</a>
<a name="ln123">{</a>
<a name="ln124">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln125"> </a>
<a name="ln126">	if (ni-&gt;ni_associd != 0)</a>
<a name="ln127">		if (ni-&gt;ni_inact &gt; vap-&gt;iv_inact_init) {</a>
<a name="ln128">			ni-&gt;ni_inact = vap-&gt;iv_inact_init;</a>
<a name="ln129">			IEEE80211_NOTE(vap, IEEE80211_MSG_INACT, ni,</a>
<a name="ln130">			    &quot;%s: inact %u&quot;, __func__, ni-&gt;ni_inact);</a>
<a name="ln131">		}</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">static void</a>
<a name="ln135">sta_drop(void *arg, struct ieee80211_node *ni)</a>
<a name="ln136">{</a>
<a name="ln137"> </a>
<a name="ln138">	if (ni-&gt;ni_associd != 0)</a>
<a name="ln139">		ieee80211_node_leave(ni);</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">/*</a>
<a name="ln143"> * Does a channel change require associated stations to re-associate</a>
<a name="ln144"> * so protocol state is correct.  This is used when doing CSA across</a>
<a name="ln145"> * bands or similar (e.g. HT -&gt; legacy).</a>
<a name="ln146"> */</a>
<a name="ln147">static int</a>
<a name="ln148">isbandchange(struct ieee80211com *ic)</a>
<a name="ln149">{</a>
<a name="ln150">	return ((ic-&gt;ic_bsschan-&gt;ic_flags ^ ic-&gt;ic_csa_newchan-&gt;ic_flags) &amp;</a>
<a name="ln151">	    (IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_HALF |</a>
<a name="ln152">	     IEEE80211_CHAN_QUARTER | IEEE80211_CHAN_HT)) != 0;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">/*</a>
<a name="ln156"> * IEEE80211_M_HOSTAP vap state machine handler.</a>
<a name="ln157"> */</a>
<a name="ln158">static int</a>
<a name="ln159">hostap_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln160">{</a>
<a name="ln161">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln162">	enum ieee80211_state ostate;</a>
<a name="ln163"> </a>
<a name="ln164">	IEEE80211_LOCK_ASSERT(ic);</a>
<a name="ln165"> </a>
<a name="ln166">	ostate = vap-&gt;iv_state;</a>
<a name="ln167">	IEEE80211_DPRINTF(vap, IEEE80211_MSG_STATE, &quot;%s: %s -&gt; %s (%d)\n&quot;,</a>
<a name="ln168">	    __func__, ieee80211_state_name[ostate],</a>
<a name="ln169">	    ieee80211_state_name[nstate], arg);</a>
<a name="ln170">	vap-&gt;iv_state = nstate;			/* state transition */</a>
<a name="ln171">	if (ostate != IEEE80211_S_SCAN)</a>
<a name="ln172">		ieee80211_cancel_scan(vap);	/* background scan */</a>
<a name="ln173">	switch (nstate) {</a>
<a name="ln174">	case IEEE80211_S_INIT:</a>
<a name="ln175">		switch (ostate) {</a>
<a name="ln176">		case IEEE80211_S_SCAN:</a>
<a name="ln177">			ieee80211_cancel_scan(vap);</a>
<a name="ln178">			break;</a>
<a name="ln179">		case IEEE80211_S_CAC:</a>
<a name="ln180">			ieee80211_dfs_cac_stop(vap);</a>
<a name="ln181">			break;</a>
<a name="ln182">		case IEEE80211_S_RUN:</a>
<a name="ln183">			ieee80211_iterate_nodes_vap(&amp;ic-&gt;ic_sta, vap,</a>
<a name="ln184">			    sta_disassoc, NULL);</a>
<a name="ln185">			break;</a>
<a name="ln186">		default:</a>
<a name="ln187">			break;</a>
<a name="ln188">		}</a>
<a name="ln189">		if (ostate != IEEE80211_S_INIT) {</a>
<a name="ln190">			/* NB: optimize INIT -&gt; INIT case */</a>
<a name="ln191">			ieee80211_reset_bss(vap);</a>
<a name="ln192">		}</a>
<a name="ln193">		if (vap-&gt;iv_auth-&gt;ia_detach != NULL)</a>
<a name="ln194">			vap-&gt;iv_auth-&gt;ia_detach(vap);</a>
<a name="ln195">		break;</a>
<a name="ln196">	case IEEE80211_S_SCAN:</a>
<a name="ln197">		switch (ostate) {</a>
<a name="ln198">		case IEEE80211_S_CSA:</a>
<a name="ln199">		case IEEE80211_S_RUN:</a>
<a name="ln200">			ieee80211_iterate_nodes_vap(&amp;ic-&gt;ic_sta, vap,</a>
<a name="ln201">			    sta_disassoc, NULL);</a>
<a name="ln202">			/*</a>
<a name="ln203">			 * Clear overlapping BSS state; the beacon frame</a>
<a name="ln204">			 * will be reconstructed on transition to the RUN</a>
<a name="ln205">			 * state and the timeout routines check if the flag</a>
<a name="ln206">			 * is set before doing anything so this is sufficient.</a>
<a name="ln207">			 */</a>
<a name="ln208">			ic-&gt;ic_flags_ext &amp;= ~IEEE80211_FEXT_NONERP_PR;</a>
<a name="ln209">			ic-&gt;ic_flags_ht &amp;= ~IEEE80211_FHT_NONHT_PR;</a>
<a name="ln210">			/* fall thru... */</a>
<a name="ln211">		case IEEE80211_S_CAC:</a>
<a name="ln212">			/*</a>
<a name="ln213">			 * NB: We may get here because of a manual channel</a>
<a name="ln214">			 *     change in which case we need to stop CAC</a>
<a name="ln215">			 * XXX no need to stop if ostate RUN but it's ok</a>
<a name="ln216">			 */</a>
<a name="ln217">			ieee80211_dfs_cac_stop(vap);</a>
<a name="ln218">			/* fall thru... */</a>
<a name="ln219">		case IEEE80211_S_INIT:</a>
<a name="ln220">			if (vap-&gt;iv_des_chan != IEEE80211_CHAN_ANYC &amp;&amp;</a>
<a name="ln221">			    !IEEE80211_IS_CHAN_RADAR(vap-&gt;iv_des_chan)) {</a>
<a name="ln222">				/*</a>
<a name="ln223">				 * Already have a channel; bypass the</a>
<a name="ln224">				 * scan and startup immediately.  </a>
<a name="ln225">				 * ieee80211_create_ibss will call back to</a>
<a name="ln226">				 * move us to RUN state.</a>
<a name="ln227">				 */</a>
<a name="ln228">				ieee80211_create_ibss(vap, vap-&gt;iv_des_chan);</a>
<a name="ln229">				break;</a>
<a name="ln230">			}</a>
<a name="ln231">			/*</a>
<a name="ln232">			 * Initiate a scan.  We can come here as a result</a>
<a name="ln233">			 * of an IEEE80211_IOC_SCAN_REQ too in which case</a>
<a name="ln234">			 * the vap will be marked with IEEE80211_FEXT_SCANREQ</a>
<a name="ln235">			 * and the scan request parameters will be present</a>
<a name="ln236">			 * in iv_scanreq.  Otherwise we do the default.</a>
<a name="ln237">			 */</a>
<a name="ln238">			if (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_SCANREQ) {</a>
<a name="ln239">				ieee80211_check_scan(vap,</a>
<a name="ln240">				    vap-&gt;iv_scanreq_flags,</a>
<a name="ln241">				    vap-&gt;iv_scanreq_duration,</a>
<a name="ln242">				    vap-&gt;iv_scanreq_mindwell,</a>
<a name="ln243">				    vap-&gt;iv_scanreq_maxdwell,</a>
<a name="ln244">				    vap-&gt;iv_scanreq_nssid, vap-&gt;iv_scanreq_ssid);</a>
<a name="ln245">				vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_SCANREQ;</a>
<a name="ln246">			} else</a>
<a name="ln247">				ieee80211_check_scan_current(vap);</a>
<a name="ln248">			break;</a>
<a name="ln249">		case IEEE80211_S_SCAN:</a>
<a name="ln250">			/*</a>
<a name="ln251">			 * A state change requires a reset; scan.</a>
<a name="ln252">			 */</a>
<a name="ln253">			ieee80211_check_scan_current(vap);</a>
<a name="ln254">			break;</a>
<a name="ln255">		default:</a>
<a name="ln256">			break;</a>
<a name="ln257">		}</a>
<a name="ln258">		break;</a>
<a name="ln259">	case IEEE80211_S_CAC:</a>
<a name="ln260">		/*</a>
<a name="ln261">		 * Start CAC on a DFS channel.  We come here when starting</a>
<a name="ln262">		 * a bss on a DFS channel (see ieee80211_create_ibss).</a>
<a name="ln263">		 */</a>
<a name="ln264">		ieee80211_dfs_cac_start(vap);</a>
<a name="ln265">		break;</a>
<a name="ln266">	case IEEE80211_S_RUN:</a>
<a name="ln267">		if (vap-&gt;iv_flags &amp; IEEE80211_F_WPA) {</a>
<a name="ln268">			/* XXX validate prerequisites */</a>
<a name="ln269">		}</a>
<a name="ln270">		switch (ostate) {</a>
<a name="ln271">		case IEEE80211_S_INIT:</a>
<a name="ln272">			/*</a>
<a name="ln273">			 * Already have a channel; bypass the</a>
<a name="ln274">			 * scan and startup immediately.</a>
<a name="ln275">			 * Note that ieee80211_create_ibss will call</a>
<a name="ln276">			 * back to do a RUN-&gt;RUN state change.</a>
<a name="ln277">			 */</a>
<a name="ln278">			ieee80211_create_ibss(vap,</a>
<a name="ln279">			    ieee80211_ht_adjust_channel(ic,</a>
<a name="ln280">				ic-&gt;ic_curchan, vap-&gt;iv_flags_ht));</a>
<a name="ln281">			/* NB: iv_bss is changed on return */</a>
<a name="ln282">			break;</a>
<a name="ln283">		case IEEE80211_S_CAC:</a>
<a name="ln284">			/*</a>
<a name="ln285">			 * NB: This is the normal state change when CAC</a>
<a name="ln286">			 * expires and no radar was detected; no need to</a>
<a name="ln287">			 * clear the CAC timer as it's already expired.</a>
<a name="ln288">			 */</a>
<a name="ln289">			/* fall thru... */</a>
<a name="ln290">		case IEEE80211_S_CSA:</a>
<a name="ln291">			/*</a>
<a name="ln292">			 * Shorten inactivity timer of associated stations</a>
<a name="ln293">			 * to weed out sta's that don't follow a CSA.</a>
<a name="ln294">			 */</a>
<a name="ln295">			ieee80211_iterate_nodes_vap(&amp;ic-&gt;ic_sta, vap,</a>
<a name="ln296">			    sta_csa, NULL);</a>
<a name="ln297">			/*</a>
<a name="ln298">			 * Update bss node channel to reflect where</a>
<a name="ln299">			 * we landed after CSA.</a>
<a name="ln300">			 */</a>
<a name="ln301">			ieee80211_node_set_chan(vap-&gt;iv_bss,</a>
<a name="ln302">			    ieee80211_ht_adjust_channel(ic, ic-&gt;ic_curchan,</a>
<a name="ln303">				ieee80211_htchanflags(vap-&gt;iv_bss-&gt;ni_chan)));</a>
<a name="ln304">			/* XXX bypass debug msgs */</a>
<a name="ln305">			break;</a>
<a name="ln306">		case IEEE80211_S_SCAN:</a>
<a name="ln307">		case IEEE80211_S_RUN:</a>
<a name="ln308">#ifdef IEEE80211_DEBUG</a>
<a name="ln309">			if (ieee80211_msg_debug(vap)) {</a>
<a name="ln310">				struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln311">				ieee80211_note(vap,</a>
<a name="ln312">				    &quot;synchronized with %s ssid &quot;,</a>
<a name="ln313">				    ether_sprintf(ni-&gt;ni_bssid));</a>
<a name="ln314">				ieee80211_print_essid(ni-&gt;ni_essid,</a>
<a name="ln315">				    ni-&gt;ni_esslen);</a>
<a name="ln316">				/* XXX MCS/HT */</a>
<a name="ln317">				printf(&quot; channel %d start %uMb\n&quot;,</a>
<a name="ln318">				    ieee80211_chan2ieee(ic, ic-&gt;ic_curchan),</a>
<a name="ln319">				    IEEE80211_RATE2MBS(ni-&gt;ni_txrate));</a>
<a name="ln320">			}</a>
<a name="ln321">#endif</a>
<a name="ln322">			break;</a>
<a name="ln323">		default:</a>
<a name="ln324">			break;</a>
<a name="ln325">		}</a>
<a name="ln326">		/*</a>
<a name="ln327">		 * Start/stop the authenticator.  We delay until here</a>
<a name="ln328">		 * to allow configuration to happen out of order.</a>
<a name="ln329">		 */</a>
<a name="ln330">		if (vap-&gt;iv_auth-&gt;ia_attach != NULL) {</a>
<a name="ln331">			/* XXX check failure */</a>
<a name="ln332">			vap-&gt;iv_auth-&gt;ia_attach(vap);</a>
<a name="ln333">		} else if (vap-&gt;iv_auth-&gt;ia_detach != NULL) {</a>
<a name="ln334">			vap-&gt;iv_auth-&gt;ia_detach(vap);</a>
<a name="ln335">		}</a>
<a name="ln336">		ieee80211_node_authorize(vap-&gt;iv_bss);</a>
<a name="ln337">		break;</a>
<a name="ln338">	case IEEE80211_S_CSA:</a>
<a name="ln339">		if (ostate == IEEE80211_S_RUN &amp;&amp; isbandchange(ic)) {</a>
<a name="ln340">			/*</a>
<a name="ln341">			 * On a ``band change'' silently drop associated</a>
<a name="ln342">			 * stations as they must re-associate before they</a>
<a name="ln343">			 * can pass traffic (as otherwise protocol state</a>
<a name="ln344">			 * such as capabilities and the negotiated rate</a>
<a name="ln345">			 * set may/will be wrong).</a>
<a name="ln346">			 */</a>
<a name="ln347">			ieee80211_iterate_nodes_vap(&amp;ic-&gt;ic_sta, vap,</a>
<a name="ln348">			    sta_drop, NULL);</a>
<a name="ln349">		}</a>
<a name="ln350">		break;</a>
<a name="ln351">	default:</a>
<a name="ln352">		break;</a>
<a name="ln353">	}</a>
<a name="ln354">	return 0;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">static void</a>
<a name="ln358">hostap_deliver_data(struct ieee80211vap *vap,</a>
<a name="ln359">	struct ieee80211_node *ni, struct mbuf *m)</a>
<a name="ln360">{</a>
<a name="ln361">	struct ether_header *eh = mtod(m, struct ether_header *);</a>
<a name="ln362">	struct ifnet *ifp = vap-&gt;iv_ifp;</a>
<a name="ln363"> </a>
<a name="ln364">	/* clear driver/net80211 flags before passing up */</a>
<a name="ln365">	m-&gt;m_flags &amp;= ~(M_MCAST | M_BCAST);</a>
<a name="ln366">	m_clrprotoflags(m);</a>
<a name="ln367"> </a>
<a name="ln368">	KASSERT(vap-&gt;iv_opmode == IEEE80211_M_HOSTAP,</a>
<a name="ln369">	    (&quot;gack, opmode %d&quot;, vap-&gt;iv_opmode));</a>
<a name="ln370">	/*</a>
<a name="ln371">	 * Do accounting.</a>
<a name="ln372">	 */</a>
<a name="ln373">	if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln374">	IEEE80211_NODE_STAT(ni, rx_data);</a>
<a name="ln375">	IEEE80211_NODE_STAT_ADD(ni, rx_bytes, m-&gt;m_pkthdr.len);</a>
<a name="ln376">	if (ETHER_IS_MULTICAST(eh-&gt;ether_dhost)) {</a>
<a name="ln377">		m-&gt;m_flags |= M_MCAST;		/* XXX M_BCAST? */</a>
<a name="ln378">		IEEE80211_NODE_STAT(ni, rx_mcast);</a>
<a name="ln379">	} else</a>
<a name="ln380">		IEEE80211_NODE_STAT(ni, rx_ucast);</a>
<a name="ln381"> </a>
<a name="ln382">	/* perform as a bridge within the AP */</a>
<a name="ln383">	if ((vap-&gt;iv_flags &amp; IEEE80211_F_NOBRIDGE) == 0) {</a>
<a name="ln384">		struct mbuf *mcopy = NULL;</a>
<a name="ln385"> </a>
<a name="ln386">		if (m-&gt;m_flags &amp; M_MCAST) {</a>
<a name="ln387">			mcopy = m_dup(m, M_NOWAIT);</a>
<a name="ln388">			if (mcopy == NULL)</a>
<a name="ln389">				if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln390">			else</a>
<a name="ln391">				mcopy-&gt;m_flags |= M_MCAST;</a>
<a name="ln392">		} else {</a>
<a name="ln393">			/*</a>
<a name="ln394">			 * Check if the destination is associated with the</a>
<a name="ln395">			 * same vap and authorized to receive traffic.</a>
<a name="ln396">			 * Beware of traffic destined for the vap itself;</a>
<a name="ln397">			 * sending it will not work; just let it be delivered</a>
<a name="ln398">			 * normally.</a>
<a name="ln399">			 */</a>
<a name="ln400">			struct ieee80211_node *sta = ieee80211_find_vap_node(</a>
<a name="ln401">			     &amp;vap-&gt;iv_ic-&gt;ic_sta, vap, eh-&gt;ether_dhost);</a>
<a name="ln402">			if (sta != NULL) {</a>
<a name="ln403">				if (ieee80211_node_is_authorized(sta)) {</a>
<a name="ln404">					/*</a>
<a name="ln405">					 * Beware of sending to ourself; this</a>
<a name="ln406">					 * needs to happen via the normal</a>
<a name="ln407">					 * input path.</a>
<a name="ln408">					 */</a>
<a name="ln409">					if (sta != vap-&gt;iv_bss) {</a>
<a name="ln410">						mcopy = m;</a>
<a name="ln411">						m = NULL;</a>
<a name="ln412">					}</a>
<a name="ln413">				} else {</a>
<a name="ln414">					vap-&gt;iv_stats.is_rx_unauth++;</a>
<a name="ln415">					IEEE80211_NODE_STAT(sta, rx_unauth);</a>
<a name="ln416">				}</a>
<a name="ln417">				ieee80211_free_node(sta);</a>
<a name="ln418">			}</a>
<a name="ln419">		}</a>
<a name="ln420">		if (mcopy != NULL)</a>
<a name="ln421">			(void) ieee80211_vap_xmitpkt(vap, mcopy);</a>
<a name="ln422">	}</a>
<a name="ln423">	if (m != NULL) {</a>
<a name="ln424">		/*</a>
<a name="ln425">		 * Mark frame as coming from vap's interface.</a>
<a name="ln426">		 */</a>
<a name="ln427">		m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln428">		if (m-&gt;m_flags &amp; M_MCAST) {</a>
<a name="ln429">			/*</a>
<a name="ln430">			 * Spam DWDS vap's w/ multicast traffic.</a>
<a name="ln431">			 */</a>
<a name="ln432">			/* XXX only if dwds in use? */</a>
<a name="ln433">			ieee80211_dwds_mcast(vap, m);</a>
<a name="ln434">		}</a>
<a name="ln435">		if (ni-&gt;ni_vlan != 0) {</a>
<a name="ln436">			/* attach vlan tag */</a>
<a name="ln437">			m-&gt;m_pkthdr.ether_vtag = ni-&gt;ni_vlan;</a>
<a name="ln438">			m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln439">		}</a>
<a name="ln440">		ifp-&gt;if_input(ifp, m);</a>
<a name="ln441">	}</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">/*</a>
<a name="ln445"> * Decide if a received management frame should be</a>
<a name="ln446"> * printed when debugging is enabled.  This filters some</a>
<a name="ln447"> * of the less interesting frames that come frequently</a>
<a name="ln448"> * (e.g. beacons).</a>
<a name="ln449"> */</a>
<a name="ln450">static __inline int</a>
<a name="ln451">doprint(struct ieee80211vap *vap, int subtype)</a>
<a name="ln452">{</a>
<a name="ln453">	switch (subtype) {</a>
<a name="ln454">	case IEEE80211_FC0_SUBTYPE_BEACON:</a>
<a name="ln455">		return (vap-&gt;iv_ic-&gt;ic_flags &amp; IEEE80211_F_SCAN);</a>
<a name="ln456">	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:</a>
<a name="ln457">		return 0;</a>
<a name="ln458">	}</a>
<a name="ln459">	return 1;</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">/*</a>
<a name="ln463"> * Process a received frame.  The node associated with the sender</a>
<a name="ln464"> * should be supplied.  If nothing was found in the node table then</a>
<a name="ln465"> * the caller is assumed to supply a reference to iv_bss instead.</a>
<a name="ln466"> * The RSSI and a timestamp are also supplied.  The RSSI data is used</a>
<a name="ln467"> * during AP scanning to select a AP to associate with; it can have</a>
<a name="ln468"> * any units so long as values have consistent units and higher values</a>
<a name="ln469"> * mean ``better signal''.  The receive timestamp is currently not used</a>
<a name="ln470"> * by the 802.11 layer.</a>
<a name="ln471"> */</a>
<a name="ln472">static int</a>
<a name="ln473">hostap_input(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln474">    const struct ieee80211_rx_stats *rxs, int rssi, int nf)</a>
<a name="ln475">{</a>
<a name="ln476">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln477">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln478">	struct ifnet *ifp = vap-&gt;iv_ifp;</a>
<a name="ln479">	struct ieee80211_frame *wh;</a>
<a name="ln480">	struct ieee80211_key *key;</a>
<a name="ln481">	struct ether_header *eh;</a>
<a name="ln482">	int hdrspace, need_tap = 1;	/* mbuf need to be tapped. */</a>
<a name="ln483">	uint8_t dir, type, subtype, qos;</a>
<a name="ln484">	uint8_t *bssid;</a>
<a name="ln485">	int is_hw_decrypted = 0;</a>
<a name="ln486">	int has_decrypted = 0;</a>
<a name="ln487"> </a>
<a name="ln488">	/*</a>
<a name="ln489">	 * Some devices do hardware decryption all the way through</a>
<a name="ln490">	 * to pretending the frame wasn't encrypted in the first place.</a>
<a name="ln491">	 * So, tag it appropriately so it isn't discarded inappropriately.</a>
<a name="ln492">	 */</a>
<a name="ln493">	if ((rxs != NULL) &amp;&amp; (rxs-&gt;c_pktflags &amp; IEEE80211_RX_F_DECRYPTED))</a>
<a name="ln494">		is_hw_decrypted = 1;</a>
<a name="ln495"> </a>
<a name="ln496">	if (m-&gt;m_flags &amp; M_AMPDU_MPDU) {</a>
<a name="ln497">		/*</a>
<a name="ln498">		 * Fastpath for A-MPDU reorder q resubmission.  Frames</a>
<a name="ln499">		 * w/ M_AMPDU_MPDU marked have already passed through</a>
<a name="ln500">		 * here but were received out of order and been held on</a>
<a name="ln501">		 * the reorder queue.  When resubmitted they are marked</a>
<a name="ln502">		 * with the M_AMPDU_MPDU flag and we can bypass most of</a>
<a name="ln503">		 * the normal processing.</a>
<a name="ln504">		 */</a>
<a name="ln505">		wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln506">		type = IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln507">		dir = wh-&gt;i_fc[1] &amp; IEEE80211_FC1_DIR_MASK;</a>
<a name="ln508">		subtype = IEEE80211_FC0_SUBTYPE_QOS;</a>
<a name="ln509">		hdrspace = ieee80211_hdrspace(ic, wh);	/* XXX optimize? */</a>
<a name="ln510">		goto resubmit_ampdu;</a>
<a name="ln511">	}</a>
<a name="ln512"> </a>
<a name="ln513">	KASSERT(ni != NULL, (&quot;null node&quot;));</a>
<a name="ln514">	ni-&gt;ni_inact = ni-&gt;ni_inact_reload;</a>
<a name="ln515"> </a>
<a name="ln516">	type = -1;			/* undefined */</a>
<a name="ln517"> </a>
<a name="ln518">	if (m-&gt;m_pkthdr.len &lt; sizeof(struct ieee80211_frame_min)) {</a>
<a name="ln519">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,</a>
<a name="ln520">		    ni-&gt;ni_macaddr, NULL,</a>
<a name="ln521">		    &quot;too short (1): len %u&quot;, m-&gt;m_pkthdr.len);</a>
<a name="ln522">		vap-&gt;iv_stats.is_rx_tooshort++;</a>
<a name="ln523">		goto out;</a>
<a name="ln524">	}</a>
<a name="ln525">	/*</a>
<a name="ln526">	 * Bit of a cheat here, we use a pointer for a 3-address</a>
<a name="ln527">	 * frame format but don't reference fields past outside</a>
<a name="ln528">	 * ieee80211_frame_min w/o first validating the data is</a>
<a name="ln529">	 * present.</a>
<a name="ln530">	 */</a>
<a name="ln531">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln532"> </a>
<a name="ln533">	if ((wh-&gt;i_fc[0] &amp; IEEE80211_FC0_VERSION_MASK) !=</a>
<a name="ln534">	    IEEE80211_FC0_VERSION_0) {</a>
<a name="ln535">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,</a>
<a name="ln536">		    ni-&gt;ni_macaddr, NULL, &quot;wrong version, fc %02x:%02x&quot;,</a>
<a name="ln537">		    wh-&gt;i_fc[0], wh-&gt;i_fc[1]);</a>
<a name="ln538">		vap-&gt;iv_stats.is_rx_badversion++;</a>
<a name="ln539">		goto err;</a>
<a name="ln540">	}</a>
<a name="ln541"> </a>
<a name="ln542">	dir = wh-&gt;i_fc[1] &amp; IEEE80211_FC1_DIR_MASK;</a>
<a name="ln543">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln544">	subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln545">	if ((ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) == 0) {</a>
<a name="ln546">		if (dir != IEEE80211_FC1_DIR_NODS)</a>
<a name="ln547">			bssid = wh-&gt;i_addr1;</a>
<a name="ln548">		else if (type == IEEE80211_FC0_TYPE_CTL)</a>
<a name="ln549">			bssid = wh-&gt;i_addr1;</a>
<a name="ln550">		else {</a>
<a name="ln551">			if (m-&gt;m_pkthdr.len &lt; sizeof(struct ieee80211_frame)) {</a>
<a name="ln552">				IEEE80211_DISCARD_MAC(vap,</a>
<a name="ln553">				    IEEE80211_MSG_ANY, ni-&gt;ni_macaddr,</a>
<a name="ln554">				    NULL, &quot;too short (2): len %u&quot;,</a>
<a name="ln555">				    m-&gt;m_pkthdr.len);</a>
<a name="ln556">				vap-&gt;iv_stats.is_rx_tooshort++;</a>
<a name="ln557">				goto out;</a>
<a name="ln558">			}</a>
<a name="ln559">			bssid = wh-&gt;i_addr3;</a>
<a name="ln560">		}</a>
<a name="ln561">		/*</a>
<a name="ln562">		 * Validate the bssid.</a>
<a name="ln563">		 */</a>
<a name="ln564">		if (!(type == IEEE80211_FC0_TYPE_MGT &amp;&amp;</a>
<a name="ln565">		      subtype == IEEE80211_FC0_SUBTYPE_BEACON) &amp;&amp;</a>
<a name="ln566">		    !IEEE80211_ADDR_EQ(bssid, vap-&gt;iv_bss-&gt;ni_bssid) &amp;&amp;</a>
<a name="ln567">		    !IEEE80211_ADDR_EQ(bssid, ifp-&gt;if_broadcastaddr)) {</a>
<a name="ln568">			/* not interested in */</a>
<a name="ln569">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln570">			    bssid, NULL, &quot;%s&quot;, &quot;not to bss&quot;);</a>
<a name="ln571">			vap-&gt;iv_stats.is_rx_wrongbss++;</a>
<a name="ln572">			goto out;</a>
<a name="ln573">		}</a>
<a name="ln574"> </a>
<a name="ln575">		IEEE80211_RSSI_LPF(ni-&gt;ni_avgrssi, rssi);</a>
<a name="ln576">		ni-&gt;ni_noise = nf;</a>
<a name="ln577">		if (IEEE80211_HAS_SEQ(type, subtype)) {</a>
<a name="ln578">			uint8_t tid = ieee80211_gettid(wh);</a>
<a name="ln579">			if (IEEE80211_QOS_HAS_SEQ(wh) &amp;&amp;</a>
<a name="ln580">			    TID_TO_WME_AC(tid) &gt;= WME_AC_VI)</a>
<a name="ln581">				ic-&gt;ic_wme.wme_hipri_traffic++;</a>
<a name="ln582">			if (! ieee80211_check_rxseq(ni, wh, bssid, rxs))</a>
<a name="ln583">				goto out;</a>
<a name="ln584">		}</a>
<a name="ln585">	}</a>
<a name="ln586"> </a>
<a name="ln587">	switch (type) {</a>
<a name="ln588">	case IEEE80211_FC0_TYPE_DATA:</a>
<a name="ln589">		hdrspace = ieee80211_hdrspace(ic, wh);</a>
<a name="ln590">		if (m-&gt;m_len &lt; hdrspace &amp;&amp;</a>
<a name="ln591">		    (m = m_pullup(m, hdrspace)) == NULL) {</a>
<a name="ln592">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,</a>
<a name="ln593">			    ni-&gt;ni_macaddr, NULL,</a>
<a name="ln594">			    &quot;data too short: expecting %u&quot;, hdrspace);</a>
<a name="ln595">			vap-&gt;iv_stats.is_rx_tooshort++;</a>
<a name="ln596">			goto out;		/* XXX */</a>
<a name="ln597">		}</a>
<a name="ln598">		if (!(dir == IEEE80211_FC1_DIR_TODS ||</a>
<a name="ln599">		     (dir == IEEE80211_FC1_DIR_DSTODS &amp;&amp;</a>
<a name="ln600">		      (vap-&gt;iv_flags &amp; IEEE80211_F_DWDS)))) {</a>
<a name="ln601">			if (dir != IEEE80211_FC1_DIR_DSTODS) {</a>
<a name="ln602">				IEEE80211_DISCARD(vap,</a>
<a name="ln603">				    IEEE80211_MSG_INPUT, wh, &quot;data&quot;,</a>
<a name="ln604">				    &quot;incorrect dir 0x%x&quot;, dir);</a>
<a name="ln605">			} else {</a>
<a name="ln606">				IEEE80211_DISCARD(vap,</a>
<a name="ln607">				    IEEE80211_MSG_INPUT |</a>
<a name="ln608">				    IEEE80211_MSG_WDS, wh,</a>
<a name="ln609">				    &quot;4-address data&quot;,</a>
<a name="ln610">				    &quot;%s&quot;, &quot;DWDS not enabled&quot;);</a>
<a name="ln611">			}</a>
<a name="ln612">			vap-&gt;iv_stats.is_rx_wrongdir++;</a>
<a name="ln613">			goto out;</a>
<a name="ln614">		}</a>
<a name="ln615">		/* check if source STA is associated */</a>
<a name="ln616">		if (ni == vap-&gt;iv_bss) {</a>
<a name="ln617">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln618">			    wh, &quot;data&quot;, &quot;%s&quot;, &quot;unknown src&quot;);</a>
<a name="ln619">			ieee80211_send_error(ni, wh-&gt;i_addr2,</a>
<a name="ln620">			    IEEE80211_FC0_SUBTYPE_DEAUTH,</a>
<a name="ln621">			    IEEE80211_REASON_NOT_AUTHED);</a>
<a name="ln622">			vap-&gt;iv_stats.is_rx_notassoc++;</a>
<a name="ln623">			goto err;</a>
<a name="ln624">		}</a>
<a name="ln625">		if (ni-&gt;ni_associd == 0) {</a>
<a name="ln626">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln627">			    wh, &quot;data&quot;, &quot;%s&quot;, &quot;unassoc src&quot;);</a>
<a name="ln628">			IEEE80211_SEND_MGMT(ni,</a>
<a name="ln629">			    IEEE80211_FC0_SUBTYPE_DISASSOC,</a>
<a name="ln630">			    IEEE80211_REASON_NOT_ASSOCED);</a>
<a name="ln631">			vap-&gt;iv_stats.is_rx_notassoc++;</a>
<a name="ln632">			goto err;</a>
<a name="ln633">		}</a>
<a name="ln634"> </a>
<a name="ln635">		/*</a>
<a name="ln636">		 * Check for power save state change.</a>
<a name="ln637">		 * XXX out-of-order A-MPDU frames?</a>
<a name="ln638">		 */</a>
<a name="ln639">		if (((wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PWR_MGT) ^</a>
<a name="ln640">		    (ni-&gt;ni_flags &amp; IEEE80211_NODE_PWR_MGT)))</a>
<a name="ln641">			vap-&gt;iv_node_ps(ni,</a>
<a name="ln642">				wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PWR_MGT);</a>
<a name="ln643">		/*</a>
<a name="ln644">		 * For 4-address packets handle WDS discovery</a>
<a name="ln645">		 * notifications.  Once a WDS link is setup frames</a>
<a name="ln646">		 * are just delivered to the WDS vap (see below).</a>
<a name="ln647">		 */</a>
<a name="ln648">		if (dir == IEEE80211_FC1_DIR_DSTODS &amp;&amp; ni-&gt;ni_wdsvap == NULL) {</a>
<a name="ln649">			if (!ieee80211_node_is_authorized(ni)) {</a>
<a name="ln650">				IEEE80211_DISCARD(vap,</a>
<a name="ln651">				    IEEE80211_MSG_INPUT |</a>
<a name="ln652">				    IEEE80211_MSG_WDS, wh,</a>
<a name="ln653">				    &quot;4-address data&quot;,</a>
<a name="ln654">				    &quot;%s&quot;, &quot;unauthorized port&quot;);</a>
<a name="ln655">				vap-&gt;iv_stats.is_rx_unauth++;</a>
<a name="ln656">				IEEE80211_NODE_STAT(ni, rx_unauth);</a>
<a name="ln657">				goto err;</a>
<a name="ln658">			}</a>
<a name="ln659">			ieee80211_dwds_discover(ni, m);</a>
<a name="ln660">			return type;</a>
<a name="ln661">		}</a>
<a name="ln662"> </a>
<a name="ln663">		/*</a>
<a name="ln664">		 * Handle A-MPDU re-ordering.  If the frame is to be</a>
<a name="ln665">		 * processed directly then ieee80211_ampdu_reorder</a>
<a name="ln666">		 * will return 0; otherwise it has consumed the mbuf</a>
<a name="ln667">		 * and we should do nothing more with it.</a>
<a name="ln668">		 */</a>
<a name="ln669">		if ((m-&gt;m_flags &amp; M_AMPDU) &amp;&amp;</a>
<a name="ln670">		    ieee80211_ampdu_reorder(ni, m, rxs) != 0) {</a>
<a name="ln671">			m = NULL;</a>
<a name="ln672">			goto out;</a>
<a name="ln673">		}</a>
<a name="ln674">	resubmit_ampdu:</a>
<a name="ln675"> </a>
<a name="ln676">		/*</a>
<a name="ln677">		 * Handle privacy requirements.  Note that we</a>
<a name="ln678">		 * must not be preempted from here until after</a>
<a name="ln679">		 * we (potentially) call ieee80211_crypto_demic;</a>
<a name="ln680">		 * otherwise we may violate assumptions in the</a>
<a name="ln681">		 * crypto cipher modules used to do delayed update</a>
<a name="ln682">		 * of replay sequence numbers.</a>
<a name="ln683">		 */</a>
<a name="ln684">		if (is_hw_decrypted || wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln685">			if ((vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) == 0) {</a>
<a name="ln686">				/*</a>
<a name="ln687">				 * Discard encrypted frames when privacy is off.</a>
<a name="ln688">				 */</a>
<a name="ln689">				IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln690">				    wh, &quot;WEP&quot;, &quot;%s&quot;, &quot;PRIVACY off&quot;);</a>
<a name="ln691">				vap-&gt;iv_stats.is_rx_noprivacy++;</a>
<a name="ln692">				IEEE80211_NODE_STAT(ni, rx_noprivacy);</a>
<a name="ln693">				goto out;</a>
<a name="ln694">			}</a>
<a name="ln695">			if (ieee80211_crypto_decap(ni, m, hdrspace, &amp;key) == 0) {</a>
<a name="ln696">				/* NB: stats+msgs handled in crypto_decap */</a>
<a name="ln697">				IEEE80211_NODE_STAT(ni, rx_wepfail);</a>
<a name="ln698">				goto out;</a>
<a name="ln699">			}</a>
<a name="ln700">			wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln701">			wh-&gt;i_fc[1] &amp;= ~IEEE80211_FC1_PROTECTED;</a>
<a name="ln702">			has_decrypted = 1;</a>
<a name="ln703">		} else {</a>
<a name="ln704">			/* XXX M_WEP and IEEE80211_F_PRIVACY */</a>
<a name="ln705">			key = NULL;</a>
<a name="ln706">		}</a>
<a name="ln707"> </a>
<a name="ln708">		/*</a>
<a name="ln709">		 * Save QoS bits for use below--before we strip the header.</a>
<a name="ln710">		 */</a>
<a name="ln711">		if (subtype == IEEE80211_FC0_SUBTYPE_QOS) {</a>
<a name="ln712">			qos = (dir == IEEE80211_FC1_DIR_DSTODS) ?</a>
<a name="ln713">			    ((struct ieee80211_qosframe_addr4 *)wh)-&gt;i_qos[0] :</a>
<a name="ln714">			    ((struct ieee80211_qosframe *)wh)-&gt;i_qos[0];</a>
<a name="ln715">		} else</a>
<a name="ln716">			qos = 0;</a>
<a name="ln717"> </a>
<a name="ln718">		/*</a>
<a name="ln719">		 * Next up, any fragmentation.</a>
<a name="ln720">		 */</a>
<a name="ln721">		if (!IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln722">			m = ieee80211_defrag(ni, m, hdrspace);</a>
<a name="ln723">			if (m == NULL) {</a>
<a name="ln724">				/* Fragment dropped or frame not complete yet */</a>
<a name="ln725">				goto out;</a>
<a name="ln726">			}</a>
<a name="ln727">		}</a>
<a name="ln728">		wh = NULL;		/* no longer valid, catch any uses */</a>
<a name="ln729"> </a>
<a name="ln730">		/*</a>
<a name="ln731">		 * Next strip any MSDU crypto bits.</a>
<a name="ln732">		 */</a>
<a name="ln733">		if (key != NULL &amp;&amp; !ieee80211_crypto_demic(vap, key, m, 0)) {</a>
<a name="ln734">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln735">			    ni-&gt;ni_macaddr, &quot;data&quot;, &quot;%s&quot;, &quot;demic error&quot;);</a>
<a name="ln736">			vap-&gt;iv_stats.is_rx_demicfail++;</a>
<a name="ln737">			IEEE80211_NODE_STAT(ni, rx_demicfail);</a>
<a name="ln738">			goto out;</a>
<a name="ln739">		}</a>
<a name="ln740">		/* copy to listener after decrypt */</a>
<a name="ln741">		if (ieee80211_radiotap_active_vap(vap))</a>
<a name="ln742">			ieee80211_radiotap_rx(vap, m);</a>
<a name="ln743">		need_tap = 0;</a>
<a name="ln744">		/*</a>
<a name="ln745">		 * Finally, strip the 802.11 header.</a>
<a name="ln746">		 */</a>
<a name="ln747">		m = ieee80211_decap(vap, m, hdrspace);</a>
<a name="ln748">		if (m == NULL) {</a>
<a name="ln749">			/* XXX mask bit to check for both */</a>
<a name="ln750">			/* don't count Null data frames as errors */</a>
<a name="ln751">			if (subtype == IEEE80211_FC0_SUBTYPE_NODATA ||</a>
<a name="ln752">			    subtype == IEEE80211_FC0_SUBTYPE_QOS_NULL)</a>
<a name="ln753">				goto out;</a>
<a name="ln754">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln755">			    ni-&gt;ni_macaddr, &quot;data&quot;, &quot;%s&quot;, &quot;decap error&quot;);</a>
<a name="ln756">			vap-&gt;iv_stats.is_rx_decap++;</a>
<a name="ln757">			IEEE80211_NODE_STAT(ni, rx_decap);</a>
<a name="ln758">			goto err;</a>
<a name="ln759">		}</a>
<a name="ln760">		eh = mtod(m, struct ether_header *);</a>
<a name="ln761">		if (!ieee80211_node_is_authorized(ni)) {</a>
<a name="ln762">			/*</a>
<a name="ln763">			 * Deny any non-PAE frames received prior to</a>
<a name="ln764">			 * authorization.  For open/shared-key</a>
<a name="ln765">			 * authentication the port is mark authorized</a>
<a name="ln766">			 * after authentication completes.  For 802.1x</a>
<a name="ln767">			 * the port is not marked authorized by the</a>
<a name="ln768">			 * authenticator until the handshake has completed.</a>
<a name="ln769">			 */</a>
<a name="ln770">			if (eh-&gt;ether_type != htons(ETHERTYPE_PAE)) {</a>
<a name="ln771">				IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln772">				    eh-&gt;ether_shost, &quot;data&quot;,</a>
<a name="ln773">				    &quot;unauthorized port: ether type 0x%x len %u&quot;,</a>
<a name="ln774">				    eh-&gt;ether_type, m-&gt;m_pkthdr.len);</a>
<a name="ln775">				vap-&gt;iv_stats.is_rx_unauth++;</a>
<a name="ln776">				IEEE80211_NODE_STAT(ni, rx_unauth);</a>
<a name="ln777">				goto err;</a>
<a name="ln778">			}</a>
<a name="ln779">		} else {</a>
<a name="ln780">			/*</a>
<a name="ln781">			 * When denying unencrypted frames, discard</a>
<a name="ln782">			 * any non-PAE frames received without encryption.</a>
<a name="ln783">			 */</a>
<a name="ln784">			if ((vap-&gt;iv_flags &amp; IEEE80211_F_DROPUNENC) &amp;&amp;</a>
<a name="ln785">			    ((has_decrypted == 0) &amp;&amp; (m-&gt;m_flags &amp; M_WEP) == 0) &amp;&amp;</a>
<a name="ln786">			    (is_hw_decrypted == 0) &amp;&amp;</a>
<a name="ln787">			    eh-&gt;ether_type != htons(ETHERTYPE_PAE)) {</a>
<a name="ln788">				/*</a>
<a name="ln789">				 * Drop unencrypted frames.</a>
<a name="ln790">				 */</a>
<a name="ln791">				vap-&gt;iv_stats.is_rx_unencrypted++;</a>
<a name="ln792">				IEEE80211_NODE_STAT(ni, rx_unencrypted);</a>
<a name="ln793">				goto out;</a>
<a name="ln794">			}</a>
<a name="ln795">		}</a>
<a name="ln796">		/* XXX require HT? */</a>
<a name="ln797">		if (qos &amp; IEEE80211_QOS_AMSDU) {</a>
<a name="ln798">			m = ieee80211_decap_amsdu(ni, m);</a>
<a name="ln799">			if (m == NULL)</a>
<a name="ln800">				return IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln801">		} else {</a>
<a name="ln802">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln803">			m = ieee80211_decap_fastframe(vap, ni, m);</a>
<a name="ln804">			if (m == NULL)</a>
<a name="ln805">				return IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln806">#endif</a>
<a name="ln807">		}</a>
<a name="ln808">		if (dir == IEEE80211_FC1_DIR_DSTODS &amp;&amp; ni-&gt;ni_wdsvap != NULL)</a>
<a name="ln809">			ieee80211_deliver_data(ni-&gt;ni_wdsvap, ni, m);</a>
<a name="ln810">		else</a>
<a name="ln811">			hostap_deliver_data(vap, ni, m);</a>
<a name="ln812">		return IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln813"> </a>
<a name="ln814">	case IEEE80211_FC0_TYPE_MGT:</a>
<a name="ln815">		vap-&gt;iv_stats.is_rx_mgmt++;</a>
<a name="ln816">		IEEE80211_NODE_STAT(ni, rx_mgmt);</a>
<a name="ln817">		if (dir != IEEE80211_FC1_DIR_NODS) {</a>
<a name="ln818">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln819">			    wh, &quot;mgt&quot;, &quot;incorrect dir 0x%x&quot;, dir);</a>
<a name="ln820">			vap-&gt;iv_stats.is_rx_wrongdir++;</a>
<a name="ln821">			goto err;</a>
<a name="ln822">		}</a>
<a name="ln823">		if (m-&gt;m_pkthdr.len &lt; sizeof(struct ieee80211_frame)) {</a>
<a name="ln824">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,</a>
<a name="ln825">			    ni-&gt;ni_macaddr, &quot;mgt&quot;, &quot;too short: len %u&quot;,</a>
<a name="ln826">			    m-&gt;m_pkthdr.len);</a>
<a name="ln827">			vap-&gt;iv_stats.is_rx_tooshort++;</a>
<a name="ln828">			goto out;</a>
<a name="ln829">		}</a>
<a name="ln830">		if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr2)) {</a>
<a name="ln831">			/* ensure return frames are unicast */</a>
<a name="ln832">			IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln833">			    wh, NULL, &quot;source is multicast: %s&quot;,</a>
<a name="ln834">			    ether_sprintf(wh-&gt;i_addr2));</a>
<a name="ln835">			vap-&gt;iv_stats.is_rx_mgtdiscard++;	/* XXX stat */</a>
<a name="ln836">			goto out;</a>
<a name="ln837">		}</a>
<a name="ln838">#ifdef IEEE80211_DEBUG</a>
<a name="ln839">		if ((ieee80211_msg_debug(vap) &amp;&amp; doprint(vap, subtype)) ||</a>
<a name="ln840">		    ieee80211_msg_dumppkts(vap)) {</a>
<a name="ln841">			if_printf(ifp, &quot;received %s from %s rssi %d\n&quot;,</a>
<a name="ln842">			    ieee80211_mgt_subtype_name(subtype),</a>
<a name="ln843">			    ether_sprintf(wh-&gt;i_addr2), rssi);</a>
<a name="ln844">		}</a>
<a name="ln845">#endif</a>
<a name="ln846">		if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln847">			if (subtype != IEEE80211_FC0_SUBTYPE_AUTH) {</a>
<a name="ln848">				/*</a>
<a name="ln849">				 * Only shared key auth frames with a challenge</a>
<a name="ln850">				 * should be encrypted, discard all others.</a>
<a name="ln851">				 */</a>
<a name="ln852">				IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln853">				    wh, NULL,</a>
<a name="ln854">				    &quot;%s&quot;, &quot;WEP set but not permitted&quot;);</a>
<a name="ln855">				vap-&gt;iv_stats.is_rx_mgtdiscard++; /* XXX */</a>
<a name="ln856">				goto out;</a>
<a name="ln857">			}</a>
<a name="ln858">			if ((vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) == 0) {</a>
<a name="ln859">				/*</a>
<a name="ln860">				 * Discard encrypted frames when privacy is off.</a>
<a name="ln861">				 */</a>
<a name="ln862">				IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln863">				    wh, NULL, &quot;%s&quot;, &quot;WEP set but PRIVACY off&quot;);</a>
<a name="ln864">				vap-&gt;iv_stats.is_rx_noprivacy++;</a>
<a name="ln865">				goto out;</a>
<a name="ln866">			}</a>
<a name="ln867">			hdrspace = ieee80211_hdrspace(ic, wh);</a>
<a name="ln868">			if (ieee80211_crypto_decap(ni, m, hdrspace, &amp;key) == 0) {</a>
<a name="ln869">				/* NB: stats+msgs handled in crypto_decap */</a>
<a name="ln870">				goto out;</a>
<a name="ln871">			}</a>
<a name="ln872">			wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln873">			wh-&gt;i_fc[1] &amp;= ~IEEE80211_FC1_PROTECTED;</a>
<a name="ln874">			has_decrypted = 1;</a>
<a name="ln875">		}</a>
<a name="ln876">		/*</a>
<a name="ln877">		 * Pass the packet to radiotap before calling iv_recv_mgmt().</a>
<a name="ln878">		 * Otherwise iv_recv_mgmt() might pass another packet to</a>
<a name="ln879">		 * radiotap, resulting in out of order packet captures.</a>
<a name="ln880">		 */</a>
<a name="ln881">		if (ieee80211_radiotap_active_vap(vap))</a>
<a name="ln882">			ieee80211_radiotap_rx(vap, m);</a>
<a name="ln883">		need_tap = 0;</a>
<a name="ln884">		vap-&gt;iv_recv_mgmt(ni, m, subtype, rxs, rssi, nf);</a>
<a name="ln885">		goto out;</a>
<a name="ln886"> </a>
<a name="ln887">	case IEEE80211_FC0_TYPE_CTL:</a>
<a name="ln888">		vap-&gt;iv_stats.is_rx_ctl++;</a>
<a name="ln889">		IEEE80211_NODE_STAT(ni, rx_ctrl);</a>
<a name="ln890">		vap-&gt;iv_recv_ctl(ni, m, subtype);</a>
<a name="ln891">		goto out;</a>
<a name="ln892">	default:</a>
<a name="ln893">		IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln894">		    wh, &quot;bad&quot;, &quot;frame type 0x%x&quot;, type);</a>
<a name="ln895">		/* should not come here */</a>
<a name="ln896">		break;</a>
<a name="ln897">	}</a>
<a name="ln898">err:</a>
<a name="ln899">	if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln900">out:</a>
<a name="ln901">	if (m != NULL) {</a>
<a name="ln902">		if (need_tap &amp;&amp; ieee80211_radiotap_active_vap(vap))</a>
<a name="ln903">			ieee80211_radiotap_rx(vap, m);</a>
<a name="ln904">		m_freem(m);</a>
<a name="ln905">	}</a>
<a name="ln906">	return type;</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">static void</a>
<a name="ln910">hostap_auth_open(struct ieee80211_node *ni, struct ieee80211_frame *wh,</a>
<a name="ln911">    int rssi, int nf, uint16_t seq, uint16_t status)</a>
<a name="ln912">{</a>
<a name="ln913">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln914"> </a>
<a name="ln915">	KASSERT(vap-&gt;iv_state == IEEE80211_S_RUN, (&quot;state %d&quot;, vap-&gt;iv_state));</a>
<a name="ln916"> </a>
<a name="ln917">	if (ni-&gt;ni_authmode == IEEE80211_AUTH_SHARED) {</a>
<a name="ln918">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln919">		    ni-&gt;ni_macaddr, &quot;open auth&quot;,</a>
<a name="ln920">		    &quot;bad sta auth mode %u&quot;, ni-&gt;ni_authmode);</a>
<a name="ln921">		vap-&gt;iv_stats.is_rx_bad_auth++;	/* XXX */</a>
<a name="ln922">		/*</a>
<a name="ln923">		 * Clear any challenge text that may be there if</a>
<a name="ln924">		 * a previous shared key auth failed and then an</a>
<a name="ln925">		 * open auth is attempted.</a>
<a name="ln926">		 */</a>
<a name="ln927">		if (ni-&gt;ni_challenge != NULL) {</a>
<a name="ln928">			IEEE80211_FREE(ni-&gt;ni_challenge, M_80211_NODE);</a>
<a name="ln929">			ni-&gt;ni_challenge = NULL;</a>
<a name="ln930">		}</a>
<a name="ln931">		/* XXX hack to workaround calling convention */</a>
<a name="ln932">		ieee80211_send_error(ni, wh-&gt;i_addr2, </a>
<a name="ln933">		    IEEE80211_FC0_SUBTYPE_AUTH,</a>
<a name="ln934">		    (seq + 1) | (IEEE80211_STATUS_ALG&lt;&lt;16));</a>
<a name="ln935">		return;</a>
<a name="ln936">	}</a>
<a name="ln937">	if (seq != IEEE80211_AUTH_OPEN_REQUEST) {</a>
<a name="ln938">		vap-&gt;iv_stats.is_rx_bad_auth++;</a>
<a name="ln939">		return;</a>
<a name="ln940">	}</a>
<a name="ln941">	/* always accept open authentication requests */</a>
<a name="ln942">	if (ni == vap-&gt;iv_bss) {</a>
<a name="ln943">		ni = ieee80211_dup_bss(vap, wh-&gt;i_addr2);</a>
<a name="ln944">		if (ni == NULL)</a>
<a name="ln945">			return;</a>
<a name="ln946">	} else if ((ni-&gt;ni_flags &amp; IEEE80211_NODE_AREF) == 0)</a>
<a name="ln947">		(void) ieee80211_ref_node(ni);</a>
<a name="ln948">	/*</a>
<a name="ln949">	 * Mark the node as referenced to reflect that it's</a>
<a name="ln950">	 * reference count has been bumped to insure it remains</a>
<a name="ln951">	 * after the transaction completes.</a>
<a name="ln952">	 */</a>
<a name="ln953">	ni-&gt;ni_flags |= IEEE80211_NODE_AREF;</a>
<a name="ln954">	/*</a>
<a name="ln955">	 * Mark the node as requiring a valid association id</a>
<a name="ln956">	 * before outbound traffic is permitted.</a>
<a name="ln957">	 */</a>
<a name="ln958">	ni-&gt;ni_flags |= IEEE80211_NODE_ASSOCID;</a>
<a name="ln959"> </a>
<a name="ln960">	if (vap-&gt;iv_acl != NULL &amp;&amp;</a>
<a name="ln961">	    vap-&gt;iv_acl-&gt;iac_getpolicy(vap) == IEEE80211_MACCMD_POLICY_RADIUS) {</a>
<a name="ln962">		/*</a>
<a name="ln963">		 * When the ACL policy is set to RADIUS we defer the</a>
<a name="ln964">		 * authorization to a user agent.  Dispatch an event,</a>
<a name="ln965">		 * a subsequent MLME call will decide the fate of the</a>
<a name="ln966">		 * station.  If the user agent is not present then the</a>
<a name="ln967">		 * node will be reclaimed due to inactivity.</a>
<a name="ln968">		 */</a>
<a name="ln969">		IEEE80211_NOTE_MAC(vap,</a>
<a name="ln970">		    IEEE80211_MSG_AUTH | IEEE80211_MSG_ACL, ni-&gt;ni_macaddr,</a>
<a name="ln971">		    &quot;%s&quot;, &quot;station authentication defered (radius acl)&quot;);</a>
<a name="ln972">		ieee80211_notify_node_auth(ni);</a>
<a name="ln973">	} else {</a>
<a name="ln974">		IEEE80211_SEND_MGMT(ni, IEEE80211_FC0_SUBTYPE_AUTH, seq + 1);</a>
<a name="ln975">		IEEE80211_NOTE_MAC(vap,</a>
<a name="ln976">		    IEEE80211_MSG_DEBUG | IEEE80211_MSG_AUTH, ni-&gt;ni_macaddr,</a>
<a name="ln977">		    &quot;%s&quot;, &quot;station authenticated (open)&quot;);</a>
<a name="ln978">		/*</a>
<a name="ln979">		 * When 802.1x is not in use mark the port</a>
<a name="ln980">		 * authorized at this point so traffic can flow.</a>
<a name="ln981">		 */</a>
<a name="ln982">		if (ni-&gt;ni_authmode != IEEE80211_AUTH_8021X)</a>
<a name="ln983">			ieee80211_node_authorize(ni);</a>
<a name="ln984">	}</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">static void</a>
<a name="ln988">hostap_auth_shared(struct ieee80211_node *ni, struct ieee80211_frame *wh,</a>
<a name="ln989">    uint8_t *frm, uint8_t *efrm, int rssi, int nf,</a>
<a name="ln990">    uint16_t seq, uint16_t status)</a>
<a name="ln991">{</a>
<a name="ln992">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln993">	uint8_t *challenge;</a>
<a name="ln994">	int allocbs, estatus;</a>
<a name="ln995"> </a>
<a name="ln996">	KASSERT(vap-&gt;iv_state == IEEE80211_S_RUN, (&quot;state %d&quot;, vap-&gt;iv_state));</a>
<a name="ln997"> </a>
<a name="ln998">	/*</a>
<a name="ln999">	 * NB: this can happen as we allow pre-shared key</a>
<a name="ln1000">	 * authentication to be enabled w/o wep being turned</a>
<a name="ln1001">	 * on so that configuration of these can be done</a>
<a name="ln1002">	 * in any order.  It may be better to enforce the</a>
<a name="ln1003">	 * ordering in which case this check would just be</a>
<a name="ln1004">	 * for sanity/consistency.</a>
<a name="ln1005">	 */</a>
<a name="ln1006">	if ((vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) == 0) {</a>
<a name="ln1007">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1008">		    ni-&gt;ni_macaddr, &quot;shared key auth&quot;,</a>
<a name="ln1009">		    &quot;%s&quot;, &quot; PRIVACY is disabled&quot;);</a>
<a name="ln1010">		estatus = IEEE80211_STATUS_ALG;</a>
<a name="ln1011">		goto bad;</a>
<a name="ln1012">	}</a>
<a name="ln1013">	/*</a>
<a name="ln1014">	 * Pre-shared key authentication is evil; accept</a>
<a name="ln1015">	 * it only if explicitly configured (it is supported</a>
<a name="ln1016">	 * mainly for compatibility with clients like Mac OS X).</a>
<a name="ln1017">	 */</a>
<a name="ln1018">	if (ni-&gt;ni_authmode != IEEE80211_AUTH_AUTO &amp;&amp;</a>
<a name="ln1019">	    ni-&gt;ni_authmode != IEEE80211_AUTH_SHARED) {</a>
<a name="ln1020">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1021">		    ni-&gt;ni_macaddr, &quot;shared key auth&quot;,</a>
<a name="ln1022">		    &quot;bad sta auth mode %u&quot;, ni-&gt;ni_authmode);</a>
<a name="ln1023">		vap-&gt;iv_stats.is_rx_bad_auth++;	/* XXX maybe a unique error? */</a>
<a name="ln1024">		estatus = IEEE80211_STATUS_ALG;</a>
<a name="ln1025">		goto bad;</a>
<a name="ln1026">	}</a>
<a name="ln1027"> </a>
<a name="ln1028">	challenge = NULL;</a>
<a name="ln1029">	if (frm + 1 &lt; efrm) {</a>
<a name="ln1030">		if ((frm[1] + 2) &gt; (efrm - frm)) {</a>
<a name="ln1031">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1032">			    ni-&gt;ni_macaddr, &quot;shared key auth&quot;,</a>
<a name="ln1033">			    &quot;ie %d/%d too long&quot;,</a>
<a name="ln1034">			    frm[0], (frm[1] + 2) - (efrm - frm));</a>
<a name="ln1035">			vap-&gt;iv_stats.is_rx_bad_auth++;</a>
<a name="ln1036">			estatus = IEEE80211_STATUS_CHALLENGE;</a>
<a name="ln1037">			goto bad;</a>
<a name="ln1038">		}</a>
<a name="ln1039">		if (*frm == IEEE80211_ELEMID_CHALLENGE)</a>
<a name="ln1040">			challenge = frm;</a>
<a name="ln1041">		frm += frm[1] + 2;</a>
<a name="ln1042">	}</a>
<a name="ln1043">	switch (seq) {</a>
<a name="ln1044">	case IEEE80211_AUTH_SHARED_CHALLENGE:</a>
<a name="ln1045">	case IEEE80211_AUTH_SHARED_RESPONSE:</a>
<a name="ln1046">		if (challenge == NULL) {</a>
<a name="ln1047">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1048">			    ni-&gt;ni_macaddr, &quot;shared key auth&quot;,</a>
<a name="ln1049">			    &quot;%s&quot;, &quot;no challenge&quot;);</a>
<a name="ln1050">			vap-&gt;iv_stats.is_rx_bad_auth++;</a>
<a name="ln1051">			estatus = IEEE80211_STATUS_CHALLENGE;</a>
<a name="ln1052">			goto bad;</a>
<a name="ln1053">		}</a>
<a name="ln1054">		if (challenge[1] != IEEE80211_CHALLENGE_LEN) {</a>
<a name="ln1055">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1056">			    ni-&gt;ni_macaddr, &quot;shared key auth&quot;,</a>
<a name="ln1057">			    &quot;bad challenge len %d&quot;, challenge[1]);</a>
<a name="ln1058">			vap-&gt;iv_stats.is_rx_bad_auth++;</a>
<a name="ln1059">			estatus = IEEE80211_STATUS_CHALLENGE;</a>
<a name="ln1060">			goto bad;</a>
<a name="ln1061">		}</a>
<a name="ln1062">	default:</a>
<a name="ln1063">		break;</a>
<a name="ln1064">	}</a>
<a name="ln1065">	switch (seq) {</a>
<a name="ln1066">	case IEEE80211_AUTH_SHARED_REQUEST:</a>
<a name="ln1067">		if (ni == vap-&gt;iv_bss) {</a>
<a name="ln1068">			ni = ieee80211_dup_bss(vap, wh-&gt;i_addr2);</a>
<a name="ln1069">			if (ni == NULL) {</a>
<a name="ln1070">				/* NB: no way to return an error */</a>
<a name="ln1071">				return;</a>
<a name="ln1072">			}</a>
<a name="ln1073">			allocbs = 1;</a>
<a name="ln1074">		} else {</a>
<a name="ln1075">			if ((ni-&gt;ni_flags &amp; IEEE80211_NODE_AREF) == 0)</a>
<a name="ln1076">				(void) ieee80211_ref_node(ni);</a>
<a name="ln1077">			allocbs = 0;</a>
<a name="ln1078">		}</a>
<a name="ln1079">		/*</a>
<a name="ln1080">		 * Mark the node as referenced to reflect that it's</a>
<a name="ln1081">		 * reference count has been bumped to insure it remains</a>
<a name="ln1082">		 * after the transaction completes.</a>
<a name="ln1083">		 */</a>
<a name="ln1084">		ni-&gt;ni_flags |= IEEE80211_NODE_AREF;</a>
<a name="ln1085">		/*</a>
<a name="ln1086">		 * Mark the node as requiring a valid association id</a>
<a name="ln1087">		 * before outbound traffic is permitted.</a>
<a name="ln1088">		 */</a>
<a name="ln1089">		ni-&gt;ni_flags |= IEEE80211_NODE_ASSOCID;</a>
<a name="ln1090">		IEEE80211_RSSI_LPF(ni-&gt;ni_avgrssi, rssi);</a>
<a name="ln1091">		ni-&gt;ni_noise = nf;</a>
<a name="ln1092">		if (!ieee80211_alloc_challenge(ni)) {</a>
<a name="ln1093">			/* NB: don't return error so they rexmit */</a>
<a name="ln1094">			return;</a>
<a name="ln1095">		}</a>
<a name="ln1096">		get_random_bytes(ni-&gt;ni_challenge,</a>
<a name="ln1097">			IEEE80211_CHALLENGE_LEN);</a>
<a name="ln1098">		IEEE80211_NOTE(vap, IEEE80211_MSG_DEBUG | IEEE80211_MSG_AUTH,</a>
<a name="ln1099">		    ni, &quot;shared key %sauth request&quot;, allocbs ? &quot;&quot; : &quot;re&quot;);</a>
<a name="ln1100">		/*</a>
<a name="ln1101">		 * When the ACL policy is set to RADIUS we defer the</a>
<a name="ln1102">		 * authorization to a user agent.  Dispatch an event,</a>
<a name="ln1103">		 * a subsequent MLME call will decide the fate of the</a>
<a name="ln1104">		 * station.  If the user agent is not present then the</a>
<a name="ln1105">		 * node will be reclaimed due to inactivity.</a>
<a name="ln1106">		 */</a>
<a name="ln1107">		if (vap-&gt;iv_acl != NULL &amp;&amp;</a>
<a name="ln1108">		    vap-&gt;iv_acl-&gt;iac_getpolicy(vap) == IEEE80211_MACCMD_POLICY_RADIUS) {</a>
<a name="ln1109">			IEEE80211_NOTE_MAC(vap,</a>
<a name="ln1110">			    IEEE80211_MSG_AUTH | IEEE80211_MSG_ACL,</a>
<a name="ln1111">			    ni-&gt;ni_macaddr,</a>
<a name="ln1112">			    &quot;%s&quot;, &quot;station authentication defered (radius acl)&quot;);</a>
<a name="ln1113">			ieee80211_notify_node_auth(ni);</a>
<a name="ln1114">			return;</a>
<a name="ln1115">		}</a>
<a name="ln1116">		break;</a>
<a name="ln1117">	case IEEE80211_AUTH_SHARED_RESPONSE:</a>
<a name="ln1118">		if (ni == vap-&gt;iv_bss) {</a>
<a name="ln1119">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1120">			    ni-&gt;ni_macaddr, &quot;shared key response&quot;,</a>
<a name="ln1121">			    &quot;%s&quot;, &quot;unknown station&quot;);</a>
<a name="ln1122">			/* NB: don't send a response */</a>
<a name="ln1123">			return;</a>
<a name="ln1124">		}</a>
<a name="ln1125">		if (ni-&gt;ni_challenge == NULL) {</a>
<a name="ln1126">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1127">			    ni-&gt;ni_macaddr, &quot;shared key response&quot;,</a>
<a name="ln1128">			    &quot;%s&quot;, &quot;no challenge recorded&quot;);</a>
<a name="ln1129">			vap-&gt;iv_stats.is_rx_bad_auth++;</a>
<a name="ln1130">			estatus = IEEE80211_STATUS_CHALLENGE;</a>
<a name="ln1131">			goto bad;</a>
<a name="ln1132">		}</a>
<a name="ln1133">		if (memcmp(ni-&gt;ni_challenge, &amp;challenge[2],</a>
<a name="ln1134">			   challenge[1]) != 0) {</a>
<a name="ln1135">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1136">			    ni-&gt;ni_macaddr, &quot;shared key response&quot;,</a>
<a name="ln1137">			    &quot;%s&quot;, &quot;challenge mismatch&quot;);</a>
<a name="ln1138">			vap-&gt;iv_stats.is_rx_auth_fail++;</a>
<a name="ln1139">			estatus = IEEE80211_STATUS_CHALLENGE;</a>
<a name="ln1140">			goto bad;</a>
<a name="ln1141">		}</a>
<a name="ln1142">		IEEE80211_NOTE(vap, IEEE80211_MSG_DEBUG | IEEE80211_MSG_AUTH,</a>
<a name="ln1143">		    ni, &quot;%s&quot;, &quot;station authenticated (shared key)&quot;);</a>
<a name="ln1144">		ieee80211_node_authorize(ni);</a>
<a name="ln1145">		break;</a>
<a name="ln1146">	default:</a>
<a name="ln1147">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_AUTH,</a>
<a name="ln1148">		    ni-&gt;ni_macaddr, &quot;shared key auth&quot;,</a>
<a name="ln1149">		    &quot;bad seq %d&quot;, seq);</a>
<a name="ln1150">		vap-&gt;iv_stats.is_rx_bad_auth++;</a>
<a name="ln1151">		estatus = IEEE80211_STATUS_SEQUENCE;</a>
<a name="ln1152">		goto bad;</a>
<a name="ln1153">	}</a>
<a name="ln1154">	IEEE80211_SEND_MGMT(ni, IEEE80211_FC0_SUBTYPE_AUTH, seq + 1);</a>
<a name="ln1155">	return;</a>
<a name="ln1156">bad:</a>
<a name="ln1157">	/*</a>
<a name="ln1158">	 * Send an error response; but only when operating as an AP.</a>
<a name="ln1159">	 */</a>
<a name="ln1160">	/* XXX hack to workaround calling convention */</a>
<a name="ln1161">	ieee80211_send_error(ni, wh-&gt;i_addr2,</a>
<a name="ln1162">	    IEEE80211_FC0_SUBTYPE_AUTH,</a>
<a name="ln1163">	    (seq + 1) | (estatus&lt;&lt;16));</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">/*</a>
<a name="ln1167"> * Convert a WPA cipher selector OUI to an internal</a>
<a name="ln1168"> * cipher algorithm.  Where appropriate we also</a>
<a name="ln1169"> * record any key length.</a>
<a name="ln1170"> */</a>
<a name="ln1171">static int</a>
<a name="ln1172">wpa_cipher(const uint8_t *sel, uint8_t *keylen, uint8_t *cipher)</a>
<a name="ln1173">{</a>
<a name="ln1174">#define	WPA_SEL(x)	(((x)&lt;&lt;24)|WPA_OUI)</a>
<a name="ln1175">	uint32_t w = le32dec(sel);</a>
<a name="ln1176"> </a>
<a name="ln1177">	switch (w) {</a>
<a name="ln1178">	case WPA_SEL(WPA_CSE_NULL):</a>
<a name="ln1179">		*cipher = IEEE80211_CIPHER_NONE;</a>
<a name="ln1180">		break;</a>
<a name="ln1181">	case WPA_SEL(WPA_CSE_WEP40):</a>
<a name="ln1182">		if (keylen)</a>
<a name="ln1183">			*keylen = 40 / NBBY;</a>
<a name="ln1184">		*cipher = IEEE80211_CIPHER_WEP;</a>
<a name="ln1185">		break;</a>
<a name="ln1186">	case WPA_SEL(WPA_CSE_WEP104):</a>
<a name="ln1187">		if (keylen)</a>
<a name="ln1188">			*keylen = 104 / NBBY;</a>
<a name="ln1189">		*cipher = IEEE80211_CIPHER_WEP;</a>
<a name="ln1190">		break;</a>
<a name="ln1191">	case WPA_SEL(WPA_CSE_TKIP):</a>
<a name="ln1192">		*cipher = IEEE80211_CIPHER_TKIP;</a>
<a name="ln1193">		break;</a>
<a name="ln1194">	case WPA_SEL(WPA_CSE_CCMP):</a>
<a name="ln1195">		*cipher = IEEE80211_CIPHER_AES_CCM;</a>
<a name="ln1196">		break;</a>
<a name="ln1197">	default:</a>
<a name="ln1198">		return (EINVAL);</a>
<a name="ln1199">	}</a>
<a name="ln1200"> </a>
<a name="ln1201">	return (0);</a>
<a name="ln1202">#undef WPA_SEL</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205">/*</a>
<a name="ln1206"> * Convert a WPA key management/authentication algorithm</a>
<a name="ln1207"> * to an internal code.</a>
<a name="ln1208"> */</a>
<a name="ln1209">static int</a>
<a name="ln1210">wpa_keymgmt(const uint8_t *sel)</a>
<a name="ln1211">{</a>
<a name="ln1212">#define	WPA_SEL(x)	(((x)&lt;&lt;24)|WPA_OUI)</a>
<a name="ln1213">	uint32_t w = le32dec(sel);</a>
<a name="ln1214"> </a>
<a name="ln1215">	switch (w) {</a>
<a name="ln1216">	case WPA_SEL(WPA_ASE_8021X_UNSPEC):</a>
<a name="ln1217">		return WPA_ASE_8021X_UNSPEC;</a>
<a name="ln1218">	case WPA_SEL(WPA_ASE_8021X_PSK):</a>
<a name="ln1219">		return WPA_ASE_8021X_PSK;</a>
<a name="ln1220">	case WPA_SEL(WPA_ASE_NONE):</a>
<a name="ln1221">		return WPA_ASE_NONE;</a>
<a name="ln1222">	}</a>
<a name="ln1223">	return 0;		/* NB: so is discarded */</a>
<a name="ln1224">#undef WPA_SEL</a>
<a name="ln1225">}</a>
<a name="ln1226"> </a>
<a name="ln1227">/*</a>
<a name="ln1228"> * Parse a WPA information element to collect parameters.</a>
<a name="ln1229"> * Note that we do not validate security parameters; that</a>
<a name="ln1230"> * is handled by the authenticator; the parsing done here</a>
<a name="ln1231"> * is just for internal use in making operational decisions.</a>
<a name="ln1232"> */</a>
<a name="ln1233">static int</a>
<a name="ln1234">ieee80211_parse_wpa(struct ieee80211vap *vap, const uint8_t *frm,</a>
<a name="ln1235">	struct ieee80211_rsnparms *rsn, const struct ieee80211_frame *wh)</a>
<a name="ln1236">{</a>
<a name="ln1237">	uint8_t len = frm[1];</a>
<a name="ln1238">	uint32_t w;</a>
<a name="ln1239">	int error, n;</a>
<a name="ln1240"> </a>
<a name="ln1241">	/*</a>
<a name="ln1242">	 * Check the length once for fixed parts: OUI, type,</a>
<a name="ln1243">	 * version, mcast cipher, and 2 selector counts.</a>
<a name="ln1244">	 * Other, variable-length data, must be checked separately.</a>
<a name="ln1245">	 */</a>
<a name="ln1246">	if ((vap-&gt;iv_flags &amp; IEEE80211_F_WPA1) == 0) {</a>
<a name="ln1247">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1248">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1249">		    wh, &quot;WPA&quot;, &quot;not WPA, flags 0x%x&quot;, vap-&gt;iv_flags);</a>
<a name="ln1250">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1251">	}</a>
<a name="ln1252">	if (len &lt; 14) {</a>
<a name="ln1253">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1254">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1255">		    wh, &quot;WPA&quot;, &quot;too short, len %u&quot;, len);</a>
<a name="ln1256">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1257">	}</a>
<a name="ln1258">	frm += 6, len -= 4;		/* NB: len is payload only */</a>
<a name="ln1259">	/* NB: iswpaoui already validated the OUI and type */</a>
<a name="ln1260">	w = le16dec(frm);</a>
<a name="ln1261">	if (w != WPA_VERSION) {</a>
<a name="ln1262">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1263">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1264">		    wh, &quot;WPA&quot;, &quot;bad version %u&quot;, w);</a>
<a name="ln1265">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1266">	}</a>
<a name="ln1267">	frm += 2, len -= 2;</a>
<a name="ln1268"> </a>
<a name="ln1269">	memset(rsn, 0, sizeof(*rsn));</a>
<a name="ln1270"> </a>
<a name="ln1271">	/* multicast/group cipher */</a>
<a name="ln1272">	error = wpa_cipher(frm, &amp;rsn-&gt;rsn_mcastkeylen, &amp;rsn-&gt;rsn_mcastcipher);</a>
<a name="ln1273">	if (error != 0) {</a>
<a name="ln1274">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1275">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1276">		    wh, &quot;WPA&quot;, &quot;unknown mcast cipher suite %08X&quot;,</a>
<a name="ln1277">		    le32dec(frm));</a>
<a name="ln1278">		return IEEE80211_REASON_GROUP_CIPHER_INVALID;</a>
<a name="ln1279">	}</a>
<a name="ln1280">	frm += 4, len -= 4;</a>
<a name="ln1281"> </a>
<a name="ln1282">	/* unicast ciphers */</a>
<a name="ln1283">	n = le16dec(frm);</a>
<a name="ln1284">	frm += 2, len -= 2;</a>
<a name="ln1285">	if (len &lt; n*4+2) {</a>
<a name="ln1286">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1287">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1288">		    wh, &quot;WPA&quot;, &quot;ucast cipher data too short; len %u, n %u&quot;,</a>
<a name="ln1289">		    len, n);</a>
<a name="ln1290">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1291">	}</a>
<a name="ln1292">	w = 0;</a>
<a name="ln1293">	for (; n &gt; 0; n--) {</a>
<a name="ln1294">		uint8_t cipher;</a>
<a name="ln1295"> </a>
<a name="ln1296">		error = wpa_cipher(frm, &amp;rsn-&gt;rsn_ucastkeylen, &amp;cipher);</a>
<a name="ln1297">		if (error == 0)</a>
<a name="ln1298">			w |= 1 &lt;&lt; cipher;</a>
<a name="ln1299"> </a>
<a name="ln1300">		frm += 4, len -= 4;</a>
<a name="ln1301">	}</a>
<a name="ln1302">	if (w == 0) {</a>
<a name="ln1303">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1304">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1305">		    wh, &quot;WPA&quot;, &quot;no usable pairwise cipher suite found (w=%d)&quot;,</a>
<a name="ln1306">		    w);</a>
<a name="ln1307">		return IEEE80211_REASON_PAIRWISE_CIPHER_INVALID;</a>
<a name="ln1308">	}</a>
<a name="ln1309">	/* XXX other? */</a>
<a name="ln1310">	if (w &amp; (1 &lt;&lt; IEEE80211_CIPHER_AES_CCM))</a>
<a name="ln1311">		rsn-&gt;rsn_ucastcipher = IEEE80211_CIPHER_AES_CCM;</a>
<a name="ln1312">	else</a>
<a name="ln1313">		rsn-&gt;rsn_ucastcipher = IEEE80211_CIPHER_TKIP;</a>
<a name="ln1314"> </a>
<a name="ln1315">	/* key management algorithms */</a>
<a name="ln1316">	n = le16dec(frm);</a>
<a name="ln1317">	frm += 2, len -= 2;</a>
<a name="ln1318">	if (len &lt; n*4) {</a>
<a name="ln1319">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1320">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1321">		    wh, &quot;WPA&quot;, &quot;key mgmt alg data too short; len %u, n %u&quot;,</a>
<a name="ln1322">		    len, n);</a>
<a name="ln1323">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1324">	}</a>
<a name="ln1325">	w = 0;</a>
<a name="ln1326">	for (; n &gt; 0; n--) {</a>
<a name="ln1327">		w |= wpa_keymgmt(frm);</a>
<a name="ln1328">		frm += 4, len -= 4;</a>
<a name="ln1329">	}</a>
<a name="ln1330">	if (w &amp; WPA_ASE_8021X_UNSPEC)</a>
<a name="ln1331">		rsn-&gt;rsn_keymgmt = WPA_ASE_8021X_UNSPEC;</a>
<a name="ln1332">	else</a>
<a name="ln1333">		rsn-&gt;rsn_keymgmt = WPA_ASE_8021X_PSK;</a>
<a name="ln1334"> </a>
<a name="ln1335">	if (len &gt; 2)		/* optional capabilities */</a>
<a name="ln1336">		rsn-&gt;rsn_caps = le16dec(frm);</a>
<a name="ln1337"> </a>
<a name="ln1338">	return 0;</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">/*</a>
<a name="ln1342"> * Convert an RSN cipher selector OUI to an internal</a>
<a name="ln1343"> * cipher algorithm.  Where appropriate we also</a>
<a name="ln1344"> * record any key length.</a>
<a name="ln1345"> */</a>
<a name="ln1346">static int</a>
<a name="ln1347">rsn_cipher(const uint8_t *sel, uint8_t *keylen, uint8_t *cipher)</a>
<a name="ln1348">{</a>
<a name="ln1349">#define	RSN_SEL(x)	(((x)&lt;&lt;24)|RSN_OUI)</a>
<a name="ln1350">	uint32_t w = le32dec(sel);</a>
<a name="ln1351"> </a>
<a name="ln1352">	switch (w) {</a>
<a name="ln1353">	case RSN_SEL(RSN_CSE_NULL):</a>
<a name="ln1354">		*cipher = IEEE80211_CIPHER_NONE;</a>
<a name="ln1355">		break;</a>
<a name="ln1356">	case RSN_SEL(RSN_CSE_WEP40):</a>
<a name="ln1357">		if (keylen)</a>
<a name="ln1358">			*keylen = 40 / NBBY;</a>
<a name="ln1359">		*cipher = IEEE80211_CIPHER_WEP;</a>
<a name="ln1360">		break;</a>
<a name="ln1361">	case RSN_SEL(RSN_CSE_WEP104):</a>
<a name="ln1362">		if (keylen)</a>
<a name="ln1363">			*keylen = 104 / NBBY;</a>
<a name="ln1364">		*cipher = IEEE80211_CIPHER_WEP;</a>
<a name="ln1365">		break;</a>
<a name="ln1366">	case RSN_SEL(RSN_CSE_TKIP):</a>
<a name="ln1367">		*cipher = IEEE80211_CIPHER_TKIP;</a>
<a name="ln1368">		break;</a>
<a name="ln1369">	case RSN_SEL(RSN_CSE_CCMP):</a>
<a name="ln1370">		*cipher = IEEE80211_CIPHER_AES_CCM;</a>
<a name="ln1371">		break;</a>
<a name="ln1372">	case RSN_SEL(RSN_CSE_WRAP):</a>
<a name="ln1373">		*cipher = IEEE80211_CIPHER_AES_OCB;</a>
<a name="ln1374">		break;</a>
<a name="ln1375">	default:</a>
<a name="ln1376">		return (EINVAL);</a>
<a name="ln1377">	}</a>
<a name="ln1378"> </a>
<a name="ln1379">	return (0);</a>
<a name="ln1380">#undef WPA_SEL</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383">/*</a>
<a name="ln1384"> * Convert an RSN key management/authentication algorithm</a>
<a name="ln1385"> * to an internal code.</a>
<a name="ln1386"> */</a>
<a name="ln1387">static int</a>
<a name="ln1388">rsn_keymgmt(const uint8_t *sel)</a>
<a name="ln1389">{</a>
<a name="ln1390">#define	RSN_SEL(x)	(((x)&lt;&lt;24)|RSN_OUI)</a>
<a name="ln1391">	uint32_t w = le32dec(sel);</a>
<a name="ln1392"> </a>
<a name="ln1393">	switch (w) {</a>
<a name="ln1394">	case RSN_SEL(RSN_ASE_8021X_UNSPEC):</a>
<a name="ln1395">		return RSN_ASE_8021X_UNSPEC;</a>
<a name="ln1396">	case RSN_SEL(RSN_ASE_8021X_PSK):</a>
<a name="ln1397">		return RSN_ASE_8021X_PSK;</a>
<a name="ln1398">	case RSN_SEL(RSN_ASE_NONE):</a>
<a name="ln1399">		return RSN_ASE_NONE;</a>
<a name="ln1400">	}</a>
<a name="ln1401">	return 0;		/* NB: so is discarded */</a>
<a name="ln1402">#undef RSN_SEL</a>
<a name="ln1403">}</a>
<a name="ln1404"> </a>
<a name="ln1405">/*</a>
<a name="ln1406"> * Parse a WPA/RSN information element to collect parameters</a>
<a name="ln1407"> * and validate the parameters against what has been</a>
<a name="ln1408"> * configured for the system.</a>
<a name="ln1409"> */</a>
<a name="ln1410">static int</a>
<a name="ln1411">ieee80211_parse_rsn(struct ieee80211vap *vap, const uint8_t *frm,</a>
<a name="ln1412">	struct ieee80211_rsnparms *rsn, const struct ieee80211_frame *wh)</a>
<a name="ln1413">{</a>
<a name="ln1414">	uint8_t len = frm[1];</a>
<a name="ln1415">	uint32_t w;</a>
<a name="ln1416">	int error, n;</a>
<a name="ln1417"> </a>
<a name="ln1418">	/*</a>
<a name="ln1419">	 * Check the length once for fixed parts: </a>
<a name="ln1420">	 * version, mcast cipher, and 2 selector counts.</a>
<a name="ln1421">	 * Other, variable-length data, must be checked separately.</a>
<a name="ln1422">	 */</a>
<a name="ln1423">	if ((vap-&gt;iv_flags &amp; IEEE80211_F_WPA2) == 0) {</a>
<a name="ln1424">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1425">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1426">		    wh, &quot;WPA&quot;, &quot;not RSN, flags 0x%x&quot;, vap-&gt;iv_flags);</a>
<a name="ln1427">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1428">	}</a>
<a name="ln1429">	/* XXX may be shorter */</a>
<a name="ln1430">	if (len &lt; 10) {</a>
<a name="ln1431">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1432">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1433">		    wh, &quot;RSN&quot;, &quot;too short, len %u&quot;, len);</a>
<a name="ln1434">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1435">	}</a>
<a name="ln1436">	frm += 2;</a>
<a name="ln1437">	w = le16dec(frm);</a>
<a name="ln1438">	if (w != RSN_VERSION) {</a>
<a name="ln1439">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1440">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1441">		    wh, &quot;RSN&quot;, &quot;bad version %u&quot;, w);</a>
<a name="ln1442">		return IEEE80211_REASON_UNSUPP_RSN_IE_VERSION;</a>
<a name="ln1443">	}</a>
<a name="ln1444">	frm += 2, len -= 2;</a>
<a name="ln1445"> </a>
<a name="ln1446">	memset(rsn, 0, sizeof(*rsn));</a>
<a name="ln1447"> </a>
<a name="ln1448">	/* multicast/group cipher */</a>
<a name="ln1449">	error = rsn_cipher(frm, &amp;rsn-&gt;rsn_mcastkeylen, &amp;rsn-&gt;rsn_mcastcipher);</a>
<a name="ln1450">	if (error != 0) {</a>
<a name="ln1451">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1452">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1453">		    wh, &quot;RSN&quot;, &quot;unknown mcast cipher suite %08X&quot;,</a>
<a name="ln1454">		    le32dec(frm));</a>
<a name="ln1455">		return IEEE80211_REASON_GROUP_CIPHER_INVALID;</a>
<a name="ln1456">	}</a>
<a name="ln1457">	if (rsn-&gt;rsn_mcastcipher == IEEE80211_CIPHER_NONE) {</a>
<a name="ln1458">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1459">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1460">		    wh, &quot;RSN&quot;, &quot;invalid mcast cipher suite %d&quot;,</a>
<a name="ln1461">		    rsn-&gt;rsn_mcastcipher);</a>
<a name="ln1462">		return IEEE80211_REASON_GROUP_CIPHER_INVALID;</a>
<a name="ln1463">	}</a>
<a name="ln1464">	frm += 4, len -= 4;</a>
<a name="ln1465"> </a>
<a name="ln1466">	/* unicast ciphers */</a>
<a name="ln1467">	n = le16dec(frm);</a>
<a name="ln1468">	frm += 2, len -= 2;</a>
<a name="ln1469">	if (len &lt; n*4+2) {</a>
<a name="ln1470">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1471">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1472">		    wh, &quot;RSN&quot;, &quot;ucast cipher data too short; len %u, n %u&quot;,</a>
<a name="ln1473">		    len, n);</a>
<a name="ln1474">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1475">	}</a>
<a name="ln1476">	w = 0;</a>
<a name="ln1477"> </a>
<a name="ln1478">	for (; n &gt; 0; n--) {</a>
<a name="ln1479">		uint8_t cipher;</a>
<a name="ln1480"> </a>
<a name="ln1481">		error = rsn_cipher(frm, &amp;rsn-&gt;rsn_ucastkeylen, &amp;cipher);</a>
<a name="ln1482">		if (error == 0)</a>
<a name="ln1483">			w |= 1 &lt;&lt; cipher;</a>
<a name="ln1484"> </a>
<a name="ln1485">		frm += 4, len -= 4;</a>
<a name="ln1486">	}</a>
<a name="ln1487">        if (w &amp; (1 &lt;&lt; IEEE80211_CIPHER_AES_CCM))</a>
<a name="ln1488">                rsn-&gt;rsn_ucastcipher = IEEE80211_CIPHER_AES_CCM;</a>
<a name="ln1489">	else if (w &amp; (1 &lt;&lt; IEEE80211_CIPHER_AES_OCB))</a>
<a name="ln1490">		rsn-&gt;rsn_ucastcipher = IEEE80211_CIPHER_AES_OCB;</a>
<a name="ln1491">	else if (w &amp; (1 &lt;&lt; IEEE80211_CIPHER_TKIP))</a>
<a name="ln1492">		rsn-&gt;rsn_ucastcipher = IEEE80211_CIPHER_TKIP;</a>
<a name="ln1493">	else if ((w &amp; (1 &lt;&lt; IEEE80211_CIPHER_NONE)) &amp;&amp;</a>
<a name="ln1494">	    (rsn-&gt;rsn_mcastcipher == IEEE80211_CIPHER_WEP ||</a>
<a name="ln1495">	     rsn-&gt;rsn_mcastcipher == IEEE80211_CIPHER_TKIP))</a>
<a name="ln1496">		rsn-&gt;rsn_ucastcipher = IEEE80211_CIPHER_NONE;</a>
<a name="ln1497">	else {</a>
<a name="ln1498">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1499">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1500">		    wh, &quot;RSN&quot;, &quot;no usable pairwise cipher suite found (w=%d)&quot;,</a>
<a name="ln1501">		    w);</a>
<a name="ln1502">		return IEEE80211_REASON_PAIRWISE_CIPHER_INVALID;</a>
<a name="ln1503">	}</a>
<a name="ln1504"> </a>
<a name="ln1505">	/* key management algorithms */</a>
<a name="ln1506">	n = le16dec(frm);</a>
<a name="ln1507">	frm += 2, len -= 2;</a>
<a name="ln1508">	if (len &lt; n*4) {</a>
<a name="ln1509">		IEEE80211_DISCARD_IE(vap,</a>
<a name="ln1510">		    IEEE80211_MSG_ELEMID | IEEE80211_MSG_WPA,</a>
<a name="ln1511">		    wh, &quot;RSN&quot;, &quot;key mgmt alg data too short; len %u, n %u&quot;,</a>
<a name="ln1512">		    len, n);</a>
<a name="ln1513">		return IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1514">	}</a>
<a name="ln1515">	w = 0;</a>
<a name="ln1516">	for (; n &gt; 0; n--) {</a>
<a name="ln1517">		w |= rsn_keymgmt(frm);</a>
<a name="ln1518">		frm += 4, len -= 4;</a>
<a name="ln1519">	}</a>
<a name="ln1520">	if (w &amp; RSN_ASE_8021X_UNSPEC)</a>
<a name="ln1521">		rsn-&gt;rsn_keymgmt = RSN_ASE_8021X_UNSPEC;</a>
<a name="ln1522">	else</a>
<a name="ln1523">		rsn-&gt;rsn_keymgmt = RSN_ASE_8021X_PSK;</a>
<a name="ln1524"> </a>
<a name="ln1525">	/* optional RSN capabilities */</a>
<a name="ln1526">	if (len &gt; 2)</a>
<a name="ln1527">		rsn-&gt;rsn_caps = le16dec(frm);</a>
<a name="ln1528">	/* XXXPMKID */</a>
<a name="ln1529"> </a>
<a name="ln1530">	return 0;</a>
<a name="ln1531">}</a>
<a name="ln1532"> </a>
<a name="ln1533">/*</a>
<a name="ln1534"> * WPA/802.11i association request processing.</a>
<a name="ln1535"> */</a>
<a name="ln1536">static int</a>
<a name="ln1537">wpa_assocreq(struct ieee80211_node *ni, struct ieee80211_rsnparms *rsnparms,</a>
<a name="ln1538">	const struct ieee80211_frame *wh, const uint8_t *wpa,</a>
<a name="ln1539">	const uint8_t *rsn, uint16_t capinfo)</a>
<a name="ln1540">{</a>
<a name="ln1541">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1542">	uint8_t reason;</a>
<a name="ln1543">	int badwparsn;</a>
<a name="ln1544"> </a>
<a name="ln1545">	ni-&gt;ni_flags &amp;= ~(IEEE80211_NODE_WPS|IEEE80211_NODE_TSN);</a>
<a name="ln1546">	if (wpa == NULL &amp;&amp; rsn == NULL) {</a>
<a name="ln1547">		if (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_WPS) {</a>
<a name="ln1548">			/*</a>
<a name="ln1549">			 * W-Fi Protected Setup (WPS) permits</a>
<a name="ln1550">			 * clients to associate and pass EAPOL frames</a>
<a name="ln1551">			 * to establish initial credentials.</a>
<a name="ln1552">			 */</a>
<a name="ln1553">			ni-&gt;ni_flags |= IEEE80211_NODE_WPS;</a>
<a name="ln1554">			return 1;</a>
<a name="ln1555">		}</a>
<a name="ln1556">		if ((vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_TSN) &amp;&amp;</a>
<a name="ln1557">		    (capinfo &amp; IEEE80211_CAPINFO_PRIVACY)) {</a>
<a name="ln1558">			/* </a>
<a name="ln1559">			 * Transitional Security Network.  Permits clients</a>
<a name="ln1560">			 * to associate and use WEP while WPA is configured.</a>
<a name="ln1561">			 */</a>
<a name="ln1562">			ni-&gt;ni_flags |= IEEE80211_NODE_TSN;</a>
<a name="ln1563">			return 1;</a>
<a name="ln1564">		}</a>
<a name="ln1565">		IEEE80211_DISCARD(vap, IEEE80211_MSG_ASSOC | IEEE80211_MSG_WPA,</a>
<a name="ln1566">		    wh, NULL, &quot;%s&quot;, &quot;no WPA/RSN IE in association request&quot;);</a>
<a name="ln1567">		vap-&gt;iv_stats.is_rx_assoc_badwpaie++;</a>
<a name="ln1568">		reason = IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1569">		goto bad;</a>
<a name="ln1570">	}</a>
<a name="ln1571">	/* assert right association security credentials */</a>
<a name="ln1572">	badwparsn = 0;			/* NB: to silence compiler */</a>
<a name="ln1573">	switch (vap-&gt;iv_flags &amp; IEEE80211_F_WPA) {</a>
<a name="ln1574">	case IEEE80211_F_WPA1:</a>
<a name="ln1575">		badwparsn = (wpa == NULL);</a>
<a name="ln1576">		break;</a>
<a name="ln1577">	case IEEE80211_F_WPA2:</a>
<a name="ln1578">		badwparsn = (rsn == NULL);</a>
<a name="ln1579">		break;</a>
<a name="ln1580">	case IEEE80211_F_WPA1|IEEE80211_F_WPA2:</a>
<a name="ln1581">		badwparsn = (wpa == NULL &amp;&amp; rsn == NULL);</a>
<a name="ln1582">		break;</a>
<a name="ln1583">	}</a>
<a name="ln1584">	if (badwparsn) {</a>
<a name="ln1585">		IEEE80211_DISCARD(vap, IEEE80211_MSG_ASSOC | IEEE80211_MSG_WPA,</a>
<a name="ln1586">		    wh, NULL,</a>
<a name="ln1587">		    &quot;%s&quot;, &quot;missing WPA/RSN IE in association request&quot;);</a>
<a name="ln1588">		vap-&gt;iv_stats.is_rx_assoc_badwpaie++;</a>
<a name="ln1589">		reason = IEEE80211_REASON_IE_INVALID;</a>
<a name="ln1590">		goto bad;</a>
<a name="ln1591">	}</a>
<a name="ln1592">	/*</a>
<a name="ln1593">	 * Parse WPA/RSN information element.</a>
<a name="ln1594">	 */</a>
<a name="ln1595">	if (wpa != NULL)</a>
<a name="ln1596">		reason = ieee80211_parse_wpa(vap, wpa, rsnparms, wh);</a>
<a name="ln1597">	else</a>
<a name="ln1598">		reason = ieee80211_parse_rsn(vap, rsn, rsnparms, wh);</a>
<a name="ln1599">	if (reason != 0) {</a>
<a name="ln1600">		/* XXX wpa-&gt;rsn fallback? */</a>
<a name="ln1601">		/* XXX distinguish WPA/RSN? */</a>
<a name="ln1602">		vap-&gt;iv_stats.is_rx_assoc_badwpaie++;</a>
<a name="ln1603">		goto bad;</a>
<a name="ln1604">	}</a>
<a name="ln1605">	IEEE80211_NOTE(vap, IEEE80211_MSG_ASSOC | IEEE80211_MSG_WPA, ni,</a>
<a name="ln1606">	    &quot;%s ie: mc %u/%u uc %u/%u key %u caps 0x%x&quot;,</a>
<a name="ln1607">	    wpa != NULL ? &quot;WPA&quot; : &quot;RSN&quot;,</a>
<a name="ln1608">	    rsnparms-&gt;rsn_mcastcipher, rsnparms-&gt;rsn_mcastkeylen,</a>
<a name="ln1609">	    rsnparms-&gt;rsn_ucastcipher, rsnparms-&gt;rsn_ucastkeylen,</a>
<a name="ln1610">	    rsnparms-&gt;rsn_keymgmt, rsnparms-&gt;rsn_caps);</a>
<a name="ln1611"> </a>
<a name="ln1612">	return 1;</a>
<a name="ln1613">bad:</a>
<a name="ln1614">	ieee80211_node_deauth(ni, reason);</a>
<a name="ln1615">	return 0;</a>
<a name="ln1616">}</a>
<a name="ln1617"> </a>
<a name="ln1618">/* XXX find a better place for definition */</a>
<a name="ln1619">struct l2_update_frame {</a>
<a name="ln1620">	struct ether_header eh;</a>
<a name="ln1621">	uint8_t dsap;</a>
<a name="ln1622">	uint8_t ssap;</a>
<a name="ln1623">	uint8_t control;</a>
<a name="ln1624">	uint8_t xid[3];</a>
<a name="ln1625">}  __packed;</a>
<a name="ln1626"> </a>
<a name="ln1627">/*</a>
<a name="ln1628"> * Deliver a TGf L2UF frame on behalf of a station.</a>
<a name="ln1629"> * This primes any bridge when the station is roaming</a>
<a name="ln1630"> * between ap's on the same wired network.</a>
<a name="ln1631"> */</a>
<a name="ln1632">static void</a>
<a name="ln1633">ieee80211_deliver_l2uf(struct ieee80211_node *ni)</a>
<a name="ln1634">{</a>
<a name="ln1635">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1636">	struct ifnet *ifp = vap-&gt;iv_ifp;</a>
<a name="ln1637">	struct mbuf *m;</a>
<a name="ln1638">	struct l2_update_frame *l2uf;</a>
<a name="ln1639">	struct ether_header *eh;</a>
<a name="ln1640">	</a>
<a name="ln1641">	m = m_gethdr(M_NOWAIT, MT_DATA);</a>
<a name="ln1642">	if (m == NULL) {</a>
<a name="ln1643">		IEEE80211_NOTE(vap, IEEE80211_MSG_ASSOC, ni,</a>
<a name="ln1644">		    &quot;%s&quot;, &quot;no mbuf for l2uf frame&quot;);</a>
<a name="ln1645">		vap-&gt;iv_stats.is_rx_nobuf++;	/* XXX not right */</a>
<a name="ln1646">		return;</a>
<a name="ln1647">	}</a>
<a name="ln1648">	l2uf = mtod(m, struct l2_update_frame *);</a>
<a name="ln1649">	eh = &amp;l2uf-&gt;eh;</a>
<a name="ln1650">	/* dst: Broadcast address */</a>
<a name="ln1651">	IEEE80211_ADDR_COPY(eh-&gt;ether_dhost, ifp-&gt;if_broadcastaddr);</a>
<a name="ln1652">	/* src: associated STA */</a>
<a name="ln1653">	IEEE80211_ADDR_COPY(eh-&gt;ether_shost, ni-&gt;ni_macaddr);</a>
<a name="ln1654">	eh-&gt;ether_type = htons(sizeof(*l2uf) - sizeof(*eh));</a>
<a name="ln1655">	</a>
<a name="ln1656">	l2uf-&gt;dsap = 0;</a>
<a name="ln1657">	l2uf-&gt;ssap = 0;</a>
<a name="ln1658">	l2uf-&gt;control = 0xf5;</a>
<a name="ln1659">	l2uf-&gt;xid[0] = 0x81;</a>
<a name="ln1660">	l2uf-&gt;xid[1] = 0x80;</a>
<a name="ln1661">	l2uf-&gt;xid[2] = 0x00;</a>
<a name="ln1662">	</a>
<a name="ln1663">	m-&gt;m_pkthdr.len = m-&gt;m_len = sizeof(*l2uf);</a>
<a name="ln1664">	hostap_deliver_data(vap, ni, m);</a>
<a name="ln1665">}</a>
<a name="ln1666"> </a>
<a name="ln1667">static void</a>
<a name="ln1668">ratesetmismatch(struct ieee80211_node *ni, const struct ieee80211_frame *wh,</a>
<a name="ln1669">	int reassoc, int resp, const char *tag, int rate)</a>
<a name="ln1670">{</a>
<a name="ln1671">	IEEE80211_NOTE_MAC(ni-&gt;ni_vap, IEEE80211_MSG_ANY, wh-&gt;i_addr2,</a>
<a name="ln1672">	    &quot;deny %s request, %s rate set mismatch, rate/MCS %d&quot;,</a>
<a name="ln1673">	    reassoc ? &quot;reassoc&quot; : &quot;assoc&quot;, tag, rate &amp; IEEE80211_RATE_VAL);</a>
<a name="ln1674">	IEEE80211_SEND_MGMT(ni, resp, IEEE80211_STATUS_BASIC_RATE);</a>
<a name="ln1675">	ieee80211_node_leave(ni);</a>
<a name="ln1676">}</a>
<a name="ln1677"> </a>
<a name="ln1678">static void</a>
<a name="ln1679">capinfomismatch(struct ieee80211_node *ni, const struct ieee80211_frame *wh,</a>
<a name="ln1680">	int reassoc, int resp, const char *tag, int capinfo)</a>
<a name="ln1681">{</a>
<a name="ln1682">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1683"> </a>
<a name="ln1684">	IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_ANY, wh-&gt;i_addr2,</a>
<a name="ln1685">	    &quot;deny %s request, %s mismatch 0x%x&quot;,</a>
<a name="ln1686">	    reassoc ? &quot;reassoc&quot; : &quot;assoc&quot;, tag, capinfo);</a>
<a name="ln1687">	IEEE80211_SEND_MGMT(ni, resp, IEEE80211_STATUS_CAPINFO);</a>
<a name="ln1688">	ieee80211_node_leave(ni);</a>
<a name="ln1689">	vap-&gt;iv_stats.is_rx_assoc_capmismatch++;</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692">static void</a>
<a name="ln1693">htcapmismatch(struct ieee80211_node *ni, const struct ieee80211_frame *wh,</a>
<a name="ln1694">	int reassoc, int resp)</a>
<a name="ln1695">{</a>
<a name="ln1696">	IEEE80211_NOTE_MAC(ni-&gt;ni_vap, IEEE80211_MSG_ANY, wh-&gt;i_addr2,</a>
<a name="ln1697">	    &quot;deny %s request, %s missing HT ie&quot;, reassoc ? &quot;reassoc&quot; : &quot;assoc&quot;);</a>
<a name="ln1698">	/* XXX no better code */</a>
<a name="ln1699">	IEEE80211_SEND_MGMT(ni, resp, IEEE80211_STATUS_MISSING_HT_CAPS);</a>
<a name="ln1700">	ieee80211_node_leave(ni);</a>
<a name="ln1701">}</a>
<a name="ln1702"> </a>
<a name="ln1703">static void</a>
<a name="ln1704">authalgreject(struct ieee80211_node *ni, const struct ieee80211_frame *wh,</a>
<a name="ln1705">	int algo, int seq, int status)</a>
<a name="ln1706">{</a>
<a name="ln1707">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1708"> </a>
<a name="ln1709">	IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln1710">	    wh, NULL, &quot;unsupported alg %d&quot;, algo);</a>
<a name="ln1711">	vap-&gt;iv_stats.is_rx_auth_unsupported++;</a>
<a name="ln1712">	ieee80211_send_error(ni, wh-&gt;i_addr2, IEEE80211_FC0_SUBTYPE_AUTH,</a>
<a name="ln1713">	    seq | (status &lt;&lt; 16));</a>
<a name="ln1714">}</a>
<a name="ln1715"> </a>
<a name="ln1716">static __inline int</a>
<a name="ln1717">ishtmixed(const uint8_t *ie)</a>
<a name="ln1718">{</a>
<a name="ln1719">	const struct ieee80211_ie_htinfo *ht =</a>
<a name="ln1720">	    (const struct ieee80211_ie_htinfo *) ie;</a>
<a name="ln1721">	return (ht-&gt;hi_byte2 &amp; IEEE80211_HTINFO_OPMODE) ==</a>
<a name="ln1722">	    IEEE80211_HTINFO_OPMODE_MIXED;</a>
<a name="ln1723">}</a>
<a name="ln1724"> </a>
<a name="ln1725">static int</a>
<a name="ln1726">is11bclient(const uint8_t *rates, const uint8_t *xrates)</a>
<a name="ln1727">{</a>
<a name="ln1728">	static const uint32_t brates = (1&lt;&lt;2*1)|(1&lt;&lt;2*2)|(1&lt;&lt;11)|(1&lt;&lt;2*11);</a>
<a name="ln1729">	int i;</a>
<a name="ln1730"> </a>
<a name="ln1731">	/* NB: the 11b clients we care about will not have xrates */</a>
<a name="ln1732">	if (xrates != NULL || rates == NULL)</a>
<a name="ln1733">		return 0;</a>
<a name="ln1734">	for (i = 0; i &lt; rates[1]; i++) {</a>
<a name="ln1735">		int r = rates[2+i] &amp; IEEE80211_RATE_VAL;</a>
<a name="ln1736">		if (r &gt; 2*11 || ((1&lt;&lt;r) &amp; brates) == 0)</a>
<a name="ln1737">			return 0;</a>
<a name="ln1738">	}</a>
<a name="ln1739">	return 1;</a>
<a name="ln1740">}</a>
<a name="ln1741"> </a>
<a name="ln1742">static void</a>
<a name="ln1743">hostap_recv_mgmt(struct ieee80211_node *ni, struct mbuf *m0,</a>
<a name="ln1744">	int subtype, const struct ieee80211_rx_stats *rxs, int rssi, int nf)</a>
<a name="ln1745">{</a>
<a name="ln1746">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1747">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln1748">	struct ieee80211_frame *wh;</a>
<a name="ln1749">	uint8_t *frm, *efrm, *sfrm;</a>
<a name="ln1750">	uint8_t *ssid, *rates, *xrates, *wpa, *rsn, *wme, *ath, *htcap;</a>
<a name="ln1751">	uint8_t *vhtcap, *vhtinfo;</a>
<a name="ln1752">	int reassoc, resp;</a>
<a name="ln1753">	uint8_t rate;</a>
<a name="ln1754"> </a>
<a name="ln1755">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1756">	frm = (uint8_t *)&amp;wh[1];</a>
<a name="ln1757">	efrm = mtod(m0, uint8_t *) + m0-&gt;m_len;</a>
<a name="ln1758">	switch (subtype) {</a>
<a name="ln1759">	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:</a>
<a name="ln1760">		/*</a>
<a name="ln1761">		 * We process beacon/probe response frames when scanning;</a>
<a name="ln1762">		 * otherwise we check beacon frames for overlapping non-ERP</a>
<a name="ln1763">		 * BSS in 11g and/or overlapping legacy BSS when in HT.</a>
<a name="ln1764">		 */</a>
<a name="ln1765">		if ((ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) == 0) {</a>
<a name="ln1766">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln1767">			return;</a>
<a name="ln1768">		}</a>
<a name="ln1769">		/* FALLTHROUGH */</a>
<a name="ln1770">	case IEEE80211_FC0_SUBTYPE_BEACON: {</a>
<a name="ln1771">		struct ieee80211_scanparams scan;</a>
<a name="ln1772"> </a>
<a name="ln1773">		/* NB: accept off-channel frames */</a>
<a name="ln1774">		/* XXX TODO: use rxstatus to determine off-channel details */</a>
<a name="ln1775">		if (ieee80211_parse_beacon(ni, m0, ic-&gt;ic_curchan, &amp;scan) &amp;~ IEEE80211_BPARSE_OFFCHAN)</a>
<a name="ln1776">			return;</a>
<a name="ln1777">		/*</a>
<a name="ln1778">		 * Count frame now that we know it's to be processed.</a>
<a name="ln1779">		 */</a>
<a name="ln1780">		if (subtype == IEEE80211_FC0_SUBTYPE_BEACON) {</a>
<a name="ln1781">			vap-&gt;iv_stats.is_rx_beacon++;		/* XXX remove */</a>
<a name="ln1782">			IEEE80211_NODE_STAT(ni, rx_beacons);</a>
<a name="ln1783">		} else</a>
<a name="ln1784">			IEEE80211_NODE_STAT(ni, rx_proberesp);</a>
<a name="ln1785">		/*</a>
<a name="ln1786">		 * If scanning, just pass information to the scan module.</a>
<a name="ln1787">		 */</a>
<a name="ln1788">		if (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) {</a>
<a name="ln1789">			if (scan.status == 0 &amp;&amp;		/* NB: on channel */</a>
<a name="ln1790">			    (ic-&gt;ic_flags_ext &amp; IEEE80211_FEXT_PROBECHAN)) {</a>
<a name="ln1791">				/*</a>
<a name="ln1792">				 * Actively scanning a channel marked passive;</a>
<a name="ln1793">				 * send a probe request now that we know there</a>
<a name="ln1794">				 * is 802.11 traffic present.</a>
<a name="ln1795">				 *</a>
<a name="ln1796">				 * XXX check if the beacon we recv'd gives</a>
<a name="ln1797">				 * us what we need and suppress the probe req</a>
<a name="ln1798">				 */</a>
<a name="ln1799">				ieee80211_probe_curchan(vap, 1);</a>
<a name="ln1800">				ic-&gt;ic_flags_ext &amp;= ~IEEE80211_FEXT_PROBECHAN;</a>
<a name="ln1801">			}</a>
<a name="ln1802">			ieee80211_add_scan(vap, ic-&gt;ic_curchan, &amp;scan, wh,</a>
<a name="ln1803">			    subtype, rssi, nf);</a>
<a name="ln1804">			return;</a>
<a name="ln1805">		}</a>
<a name="ln1806">		/*</a>
<a name="ln1807">		 * Check beacon for overlapping bss w/ non ERP stations.</a>
<a name="ln1808">		 * If we detect one and protection is configured but not</a>
<a name="ln1809">		 * enabled, enable it and start a timer that'll bring us</a>
<a name="ln1810">		 * out if we stop seeing the bss.</a>
<a name="ln1811">		 */</a>
<a name="ln1812">		if (IEEE80211_IS_CHAN_ANYG(ic-&gt;ic_curchan) &amp;&amp;</a>
<a name="ln1813">		    scan.status == 0 &amp;&amp;			/* NB: on-channel */</a>
<a name="ln1814">		    ((scan.erp &amp; 0x100) == 0 ||		/* NB: no ERP, 11b sta*/</a>
<a name="ln1815">		     (scan.erp &amp; IEEE80211_ERP_NON_ERP_PRESENT))) {</a>
<a name="ln1816">			ic-&gt;ic_lastnonerp = ticks;</a>
<a name="ln1817">			ic-&gt;ic_flags_ext |= IEEE80211_FEXT_NONERP_PR;</a>
<a name="ln1818">			if (ic-&gt;ic_protmode != IEEE80211_PROT_NONE &amp;&amp;</a>
<a name="ln1819">			    (ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT) == 0) {</a>
<a name="ln1820">				IEEE80211_NOTE_FRAME(vap,</a>
<a name="ln1821">				    IEEE80211_MSG_ASSOC, wh,</a>
<a name="ln1822">				    &quot;non-ERP present on channel %d &quot;</a>
<a name="ln1823">				    &quot;(saw erp 0x%x from channel %d), &quot;</a>
<a name="ln1824">				    &quot;enable use of protection&quot;,</a>
<a name="ln1825">				    ic-&gt;ic_curchan-&gt;ic_ieee,</a>
<a name="ln1826">				    scan.erp, scan.chan);</a>
<a name="ln1827">				ic-&gt;ic_flags |= IEEE80211_F_USEPROT;</a>
<a name="ln1828">				ieee80211_notify_erp(ic);</a>
<a name="ln1829">			}</a>
<a name="ln1830">		}</a>
<a name="ln1831">		/* </a>
<a name="ln1832">		 * Check beacon for non-HT station on HT channel</a>
<a name="ln1833">		 * and update HT BSS occupancy as appropriate.</a>
<a name="ln1834">		 */</a>
<a name="ln1835">		if (IEEE80211_IS_CHAN_HT(ic-&gt;ic_curchan)) {</a>
<a name="ln1836">			if (scan.status &amp; IEEE80211_BPARSE_OFFCHAN) {</a>
<a name="ln1837">				/*</a>
<a name="ln1838">				 * Off control channel; only check frames</a>
<a name="ln1839">				 * that come in the extension channel when</a>
<a name="ln1840">				 * operating w/ HT40.</a>
<a name="ln1841">				 */</a>
<a name="ln1842">				if (!IEEE80211_IS_CHAN_HT40(ic-&gt;ic_curchan))</a>
<a name="ln1843">					break;</a>
<a name="ln1844">				if (scan.chan != ic-&gt;ic_curchan-&gt;ic_extieee)</a>
<a name="ln1845">					break;</a>
<a name="ln1846">			}</a>
<a name="ln1847">			if (scan.htinfo == NULL) {</a>
<a name="ln1848">				ieee80211_htprot_update(ic,</a>
<a name="ln1849">				    IEEE80211_HTINFO_OPMODE_PROTOPT |</a>
<a name="ln1850">				    IEEE80211_HTINFO_NONHT_PRESENT);</a>
<a name="ln1851">			} else if (ishtmixed(scan.htinfo)) {</a>
<a name="ln1852">				/* XXX? take NONHT_PRESENT from beacon? */</a>
<a name="ln1853">				ieee80211_htprot_update(ic,</a>
<a name="ln1854">				    IEEE80211_HTINFO_OPMODE_MIXED |</a>
<a name="ln1855">				    IEEE80211_HTINFO_NONHT_PRESENT);</a>
<a name="ln1856">			}</a>
<a name="ln1857">		}</a>
<a name="ln1858">		break;</a>
<a name="ln1859">	}</a>
<a name="ln1860"> </a>
<a name="ln1861">	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:</a>
<a name="ln1862">		if (vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln1863">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln1864">			return;</a>
<a name="ln1865">		}</a>
<a name="ln1866">		/*</a>
<a name="ln1867">		 * Consult the ACL policy module if setup.</a>
<a name="ln1868">		 */</a>
<a name="ln1869">		if (vap-&gt;iv_acl != NULL &amp;&amp; !vap-&gt;iv_acl-&gt;iac_check(vap, wh)) {</a>
<a name="ln1870">			IEEE80211_DISCARD(vap, IEEE80211_MSG_ACL,</a>
<a name="ln1871">			    wh, NULL, &quot;%s&quot;, &quot;disallowed by ACL&quot;);</a>
<a name="ln1872">			vap-&gt;iv_stats.is_rx_acl++;</a>
<a name="ln1873">			return;</a>
<a name="ln1874">		}</a>
<a name="ln1875">		/*</a>
<a name="ln1876">		 * prreq frame format</a>
<a name="ln1877">		 *	[tlv] ssid</a>
<a name="ln1878">		 *	[tlv] supported rates</a>
<a name="ln1879">		 *	[tlv] extended supported rates</a>
<a name="ln1880">		 */</a>
<a name="ln1881">		ssid = rates = xrates = NULL;</a>
<a name="ln1882">		while (efrm - frm &gt; 1) {</a>
<a name="ln1883">			IEEE80211_VERIFY_LENGTH(efrm - frm, frm[1] + 2, return);</a>
<a name="ln1884">			switch (*frm) {</a>
<a name="ln1885">			case IEEE80211_ELEMID_SSID:</a>
<a name="ln1886">				ssid = frm;</a>
<a name="ln1887">				break;</a>
<a name="ln1888">			case IEEE80211_ELEMID_RATES:</a>
<a name="ln1889">				rates = frm;</a>
<a name="ln1890">				break;</a>
<a name="ln1891">			case IEEE80211_ELEMID_XRATES:</a>
<a name="ln1892">				xrates = frm;</a>
<a name="ln1893">				break;</a>
<a name="ln1894">			}</a>
<a name="ln1895">			frm += frm[1] + 2;</a>
<a name="ln1896">		}</a>
<a name="ln1897">		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE, return);</a>
<a name="ln1898">		if (xrates != NULL)</a>
<a name="ln1899">			IEEE80211_VERIFY_ELEMENT(xrates,</a>
<a name="ln1900">				IEEE80211_RATE_MAXSIZE - rates[1], return);</a>
<a name="ln1901">		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN, return);</a>
<a name="ln1902">		IEEE80211_VERIFY_SSID(vap-&gt;iv_bss, ssid, return);</a>
<a name="ln1903">		if ((vap-&gt;iv_flags &amp; IEEE80211_F_HIDESSID) &amp;&amp; ssid[1] == 0) {</a>
<a name="ln1904">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln1905">			    wh, NULL,</a>
<a name="ln1906">			    &quot;%s&quot;, &quot;no ssid with ssid suppression enabled&quot;);</a>
<a name="ln1907">			vap-&gt;iv_stats.is_rx_ssidmismatch++; /*XXX*/</a>
<a name="ln1908">			return;</a>
<a name="ln1909">		}</a>
<a name="ln1910"> </a>
<a name="ln1911">		/* XXX find a better class or define it's own */</a>
<a name="ln1912">		IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_INPUT, wh-&gt;i_addr2,</a>
<a name="ln1913">		    &quot;%s&quot;, &quot;recv probe req&quot;);</a>
<a name="ln1914">		/*</a>
<a name="ln1915">		 * Some legacy 11b clients cannot hack a complete</a>
<a name="ln1916">		 * probe response frame.  When the request includes</a>
<a name="ln1917">		 * only a bare-bones rate set, communicate this to</a>
<a name="ln1918">		 * the transmit side.</a>
<a name="ln1919">		 */</a>
<a name="ln1920">		ieee80211_send_proberesp(vap, wh-&gt;i_addr2,</a>
<a name="ln1921">		    is11bclient(rates, xrates) ? IEEE80211_SEND_LEGACY_11B : 0);</a>
<a name="ln1922">		break;</a>
<a name="ln1923"> </a>
<a name="ln1924">	case IEEE80211_FC0_SUBTYPE_AUTH: {</a>
<a name="ln1925">		uint16_t algo, seq, status;</a>
<a name="ln1926"> </a>
<a name="ln1927">		if (vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln1928">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln1929">			return;</a>
<a name="ln1930">		}</a>
<a name="ln1931">		if (!IEEE80211_ADDR_EQ(wh-&gt;i_addr3, vap-&gt;iv_bss-&gt;ni_bssid)) {</a>
<a name="ln1932">			IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln1933">			    wh, NULL, &quot;%s&quot;, &quot;wrong bssid&quot;);</a>
<a name="ln1934">			vap-&gt;iv_stats.is_rx_wrongbss++;	/*XXX unique stat?*/</a>
<a name="ln1935">			return;</a>
<a name="ln1936">		}</a>
<a name="ln1937">		/*</a>
<a name="ln1938">		 * auth frame format</a>
<a name="ln1939">		 *	[2] algorithm</a>
<a name="ln1940">		 *	[2] sequence</a>
<a name="ln1941">		 *	[2] status</a>
<a name="ln1942">		 *	[tlv*] challenge</a>
<a name="ln1943">		 */</a>
<a name="ln1944">		IEEE80211_VERIFY_LENGTH(efrm - frm, 6, return);</a>
<a name="ln1945">		algo   = le16toh(*(uint16_t *)frm);</a>
<a name="ln1946">		seq    = le16toh(*(uint16_t *)(frm + 2));</a>
<a name="ln1947">		status = le16toh(*(uint16_t *)(frm + 4));</a>
<a name="ln1948">		IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_AUTH, wh-&gt;i_addr2,</a>
<a name="ln1949">		    &quot;recv auth frame with algorithm %d seq %d&quot;, algo, seq);</a>
<a name="ln1950">		/*</a>
<a name="ln1951">		 * Consult the ACL policy module if setup.</a>
<a name="ln1952">		 */</a>
<a name="ln1953">		if (vap-&gt;iv_acl != NULL &amp;&amp; !vap-&gt;iv_acl-&gt;iac_check(vap, wh)) {</a>
<a name="ln1954">			IEEE80211_DISCARD(vap, IEEE80211_MSG_ACL,</a>
<a name="ln1955">			    wh, NULL, &quot;%s&quot;, &quot;disallowed by ACL&quot;);</a>
<a name="ln1956">			vap-&gt;iv_stats.is_rx_acl++;</a>
<a name="ln1957">			ieee80211_send_error(ni, wh-&gt;i_addr2,</a>
<a name="ln1958">			    IEEE80211_FC0_SUBTYPE_AUTH,</a>
<a name="ln1959">			    (seq+1) | (IEEE80211_STATUS_UNSPECIFIED&lt;&lt;16));</a>
<a name="ln1960">			return;</a>
<a name="ln1961">		}</a>
<a name="ln1962">		if (vap-&gt;iv_flags &amp; IEEE80211_F_COUNTERM) {</a>
<a name="ln1963">			IEEE80211_DISCARD(vap,</a>
<a name="ln1964">			    IEEE80211_MSG_AUTH | IEEE80211_MSG_CRYPTO,</a>
<a name="ln1965">			    wh, NULL, &quot;%s&quot;, &quot;TKIP countermeasures enabled&quot;);</a>
<a name="ln1966">			vap-&gt;iv_stats.is_rx_auth_countermeasures++;</a>
<a name="ln1967">			ieee80211_send_error(ni, wh-&gt;i_addr2,</a>
<a name="ln1968">				IEEE80211_FC0_SUBTYPE_AUTH,</a>
<a name="ln1969">				IEEE80211_REASON_MIC_FAILURE);</a>
<a name="ln1970">			return;</a>
<a name="ln1971">		}</a>
<a name="ln1972">		if (algo == IEEE80211_AUTH_ALG_SHARED)</a>
<a name="ln1973">			hostap_auth_shared(ni, wh, frm + 6, efrm, rssi, nf,</a>
<a name="ln1974">			    seq, status);</a>
<a name="ln1975">		else if (algo == IEEE80211_AUTH_ALG_OPEN)</a>
<a name="ln1976">			hostap_auth_open(ni, wh, rssi, nf, seq, status);</a>
<a name="ln1977">		else if (algo == IEEE80211_AUTH_ALG_LEAP) {</a>
<a name="ln1978">			authalgreject(ni, wh, algo,</a>
<a name="ln1979">			    seq+1, IEEE80211_STATUS_ALG);</a>
<a name="ln1980">			return;</a>
<a name="ln1981">		} else {</a>
<a name="ln1982">			/*</a>
<a name="ln1983">			 * We assume that an unknown algorithm is the result</a>
<a name="ln1984">			 * of a decryption failure on a shared key auth frame;</a>
<a name="ln1985">			 * return a status code appropriate for that instead</a>
<a name="ln1986">			 * of IEEE80211_STATUS_ALG.</a>
<a name="ln1987">			 *</a>
<a name="ln1988">			 * NB: a seq# of 4 is intentional; the decrypted</a>
<a name="ln1989">			 *     frame likely has a bogus seq value.</a>
<a name="ln1990">			 */</a>
<a name="ln1991">			authalgreject(ni, wh, algo,</a>
<a name="ln1992">			    4, IEEE80211_STATUS_CHALLENGE);</a>
<a name="ln1993">			return;</a>
<a name="ln1994">		} </a>
<a name="ln1995">		break;</a>
<a name="ln1996">	}</a>
<a name="ln1997"> </a>
<a name="ln1998">	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:</a>
<a name="ln1999">	case IEEE80211_FC0_SUBTYPE_REASSOC_REQ: {</a>
<a name="ln2000">		uint16_t capinfo, lintval;</a>
<a name="ln2001">		struct ieee80211_rsnparms rsnparms;</a>
<a name="ln2002"> </a>
<a name="ln2003">		if (vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln2004">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln2005">			return;</a>
<a name="ln2006">		}</a>
<a name="ln2007">		if (!IEEE80211_ADDR_EQ(wh-&gt;i_addr3, vap-&gt;iv_bss-&gt;ni_bssid)) {</a>
<a name="ln2008">			IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln2009">			    wh, NULL, &quot;%s&quot;, &quot;wrong bssid&quot;);</a>
<a name="ln2010">			vap-&gt;iv_stats.is_rx_assoc_bss++;</a>
<a name="ln2011">			return;</a>
<a name="ln2012">		}</a>
<a name="ln2013">		if (subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) {</a>
<a name="ln2014">			reassoc = 1;</a>
<a name="ln2015">			resp = IEEE80211_FC0_SUBTYPE_REASSOC_RESP;</a>
<a name="ln2016">		} else {</a>
<a name="ln2017">			reassoc = 0;</a>
<a name="ln2018">			resp = IEEE80211_FC0_SUBTYPE_ASSOC_RESP;</a>
<a name="ln2019">		}</a>
<a name="ln2020">		if (ni == vap-&gt;iv_bss) {</a>
<a name="ln2021">			IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_ANY, wh-&gt;i_addr2,</a>
<a name="ln2022">			    &quot;deny %s request, sta not authenticated&quot;,</a>
<a name="ln2023">			    reassoc ? &quot;reassoc&quot; : &quot;assoc&quot;);</a>
<a name="ln2024">			ieee80211_send_error(ni, wh-&gt;i_addr2,</a>
<a name="ln2025">			    IEEE80211_FC0_SUBTYPE_DEAUTH,</a>
<a name="ln2026">			    IEEE80211_REASON_ASSOC_NOT_AUTHED);</a>
<a name="ln2027">			vap-&gt;iv_stats.is_rx_assoc_notauth++;</a>
<a name="ln2028">			return;</a>
<a name="ln2029">		}</a>
<a name="ln2030"> </a>
<a name="ln2031">		/*</a>
<a name="ln2032">		 * asreq frame format</a>
<a name="ln2033">		 *	[2] capability information</a>
<a name="ln2034">		 *	[2] listen interval</a>
<a name="ln2035">		 *	[6*] current AP address (reassoc only)</a>
<a name="ln2036">		 *	[tlv] ssid</a>
<a name="ln2037">		 *	[tlv] supported rates</a>
<a name="ln2038">		 *	[tlv] extended supported rates</a>
<a name="ln2039">		 *	[tlv] WPA or RSN</a>
<a name="ln2040">		 *	[tlv] HT capabilities</a>
<a name="ln2041">		 *	[tlv] Atheros capabilities</a>
<a name="ln2042">		 */</a>
<a name="ln2043">		IEEE80211_VERIFY_LENGTH(efrm - frm, (reassoc ? 10 : 4), return);</a>
<a name="ln2044">		capinfo = le16toh(*(uint16_t *)frm);	frm += 2;</a>
<a name="ln2045">		lintval = le16toh(*(uint16_t *)frm);	frm += 2;</a>
<a name="ln2046">		if (reassoc)</a>
<a name="ln2047">			frm += 6;	/* ignore current AP info */</a>
<a name="ln2048">		ssid = rates = xrates = wpa = rsn = wme = ath = htcap = NULL;</a>
<a name="ln2049">		vhtcap = vhtinfo = NULL;</a>
<a name="ln2050">		sfrm = frm;</a>
<a name="ln2051">		while (efrm - frm &gt; 1) {</a>
<a name="ln2052">			IEEE80211_VERIFY_LENGTH(efrm - frm, frm[1] + 2, return);</a>
<a name="ln2053">			switch (*frm) {</a>
<a name="ln2054">			case IEEE80211_ELEMID_SSID:</a>
<a name="ln2055">				ssid = frm;</a>
<a name="ln2056">				break;</a>
<a name="ln2057">			case IEEE80211_ELEMID_RATES:</a>
<a name="ln2058">				rates = frm;</a>
<a name="ln2059">				break;</a>
<a name="ln2060">			case IEEE80211_ELEMID_XRATES:</a>
<a name="ln2061">				xrates = frm;</a>
<a name="ln2062">				break;</a>
<a name="ln2063">			case IEEE80211_ELEMID_RSN:</a>
<a name="ln2064">				rsn = frm;</a>
<a name="ln2065">				break;</a>
<a name="ln2066">			case IEEE80211_ELEMID_HTCAP:</a>
<a name="ln2067">				htcap = frm;</a>
<a name="ln2068">				break;</a>
<a name="ln2069">			case IEEE80211_ELEMID_VHT_CAP:</a>
<a name="ln2070">				vhtcap = frm;</a>
<a name="ln2071">				break;</a>
<a name="ln2072">			case IEEE80211_ELEMID_VHT_OPMODE:</a>
<a name="ln2073">				vhtinfo = frm;</a>
<a name="ln2074">				break;</a>
<a name="ln2075">			case IEEE80211_ELEMID_VENDOR:</a>
<a name="ln2076">				if (iswpaoui(frm))</a>
<a name="ln2077">					wpa = frm;</a>
<a name="ln2078">				else if (iswmeinfo(frm))</a>
<a name="ln2079">					wme = frm;</a>
<a name="ln2080">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2081">				else if (isatherosoui(frm))</a>
<a name="ln2082">					ath = frm;</a>
<a name="ln2083">#endif</a>
<a name="ln2084">				else if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HTCOMPAT) {</a>
<a name="ln2085">					if (ishtcapoui(frm) &amp;&amp; htcap == NULL)</a>
<a name="ln2086">						htcap = frm;</a>
<a name="ln2087">				}</a>
<a name="ln2088">				break;</a>
<a name="ln2089">			}</a>
<a name="ln2090">			frm += frm[1] + 2;</a>
<a name="ln2091">		}</a>
<a name="ln2092">		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE, return);</a>
<a name="ln2093">		if (xrates != NULL)</a>
<a name="ln2094">			IEEE80211_VERIFY_ELEMENT(xrates,</a>
<a name="ln2095">				IEEE80211_RATE_MAXSIZE - rates[1], return);</a>
<a name="ln2096">		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN, return);</a>
<a name="ln2097">		IEEE80211_VERIFY_SSID(vap-&gt;iv_bss, ssid, return);</a>
<a name="ln2098">		if (htcap != NULL) {</a>
<a name="ln2099">			IEEE80211_VERIFY_LENGTH(htcap[1],</a>
<a name="ln2100">			     htcap[0] == IEEE80211_ELEMID_VENDOR ?</a>
<a name="ln2101">			         4 + sizeof(struct ieee80211_ie_htcap)-2 :</a>
<a name="ln2102">			         sizeof(struct ieee80211_ie_htcap)-2,</a>
<a name="ln2103">			     return);		/* XXX just NULL out? */</a>
<a name="ln2104">		}</a>
<a name="ln2105"> </a>
<a name="ln2106">		/* Validate VHT IEs */</a>
<a name="ln2107">		if (vhtcap != NULL) {</a>
<a name="ln2108">			IEEE80211_VERIFY_LENGTH(vhtcap[1],</a>
<a name="ln2109">			    sizeof(struct ieee80211_ie_vhtcap) - 2,</a>
<a name="ln2110">			    return);</a>
<a name="ln2111">		}</a>
<a name="ln2112">		if (vhtinfo != NULL) {</a>
<a name="ln2113">			IEEE80211_VERIFY_LENGTH(vhtinfo[1],</a>
<a name="ln2114">			    sizeof(struct ieee80211_ie_vht_operation) - 2,</a>
<a name="ln2115">			    return);</a>
<a name="ln2116">		}</a>
<a name="ln2117"> </a>
<a name="ln2118">		if ((vap-&gt;iv_flags &amp; IEEE80211_F_WPA) &amp;&amp;</a>
<a name="ln2119">		    !wpa_assocreq(ni, &amp;rsnparms, wh, wpa, rsn, capinfo))</a>
<a name="ln2120">			return;</a>
<a name="ln2121">		/* discard challenge after association */</a>
<a name="ln2122">		if (ni-&gt;ni_challenge != NULL) {</a>
<a name="ln2123">			IEEE80211_FREE(ni-&gt;ni_challenge, M_80211_NODE);</a>
<a name="ln2124">			ni-&gt;ni_challenge = NULL;</a>
<a name="ln2125">		}</a>
<a name="ln2126">		/* NB: 802.11 spec says to ignore station's privacy bit */</a>
<a name="ln2127">		if ((capinfo &amp; IEEE80211_CAPINFO_ESS) == 0) {</a>
<a name="ln2128">			capinfomismatch(ni, wh, reassoc, resp,</a>
<a name="ln2129">			    &quot;capability&quot;, capinfo);</a>
<a name="ln2130">			return;</a>
<a name="ln2131">		}</a>
<a name="ln2132">		/*</a>
<a name="ln2133">		 * Disallow re-associate w/ invalid slot time setting.</a>
<a name="ln2134">		 */</a>
<a name="ln2135">		if (ni-&gt;ni_associd != 0 &amp;&amp;</a>
<a name="ln2136">		    IEEE80211_IS_CHAN_ANYG(ic-&gt;ic_bsschan) &amp;&amp;</a>
<a name="ln2137">		    ((ni-&gt;ni_capinfo ^ capinfo) &amp; IEEE80211_CAPINFO_SHORT_SLOTTIME)) {</a>
<a name="ln2138">			capinfomismatch(ni, wh, reassoc, resp,</a>
<a name="ln2139">			    &quot;slot time&quot;, capinfo);</a>
<a name="ln2140">			return;</a>
<a name="ln2141">		}</a>
<a name="ln2142">		rate = ieee80211_setup_rates(ni, rates, xrates,</a>
<a name="ln2143">				IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE |</a>
<a name="ln2144">				IEEE80211_F_DONEGO | IEEE80211_F_DODEL);</a>
<a name="ln2145">		if (rate &amp; IEEE80211_RATE_BASIC) {</a>
<a name="ln2146">			ratesetmismatch(ni, wh, reassoc, resp, &quot;legacy&quot;, rate);</a>
<a name="ln2147">			vap-&gt;iv_stats.is_rx_assoc_norate++;</a>
<a name="ln2148">			return;</a>
<a name="ln2149">		}</a>
<a name="ln2150">		/*</a>
<a name="ln2151">		 * If constrained to 11g-only stations reject an</a>
<a name="ln2152">		 * 11b-only station.  We cheat a bit here by looking</a>
<a name="ln2153">		 * at the max negotiated xmit rate and assuming anyone</a>
<a name="ln2154">		 * with a best rate &lt;24Mb/s is an 11b station.</a>
<a name="ln2155">		 */</a>
<a name="ln2156">		if ((vap-&gt;iv_flags &amp; IEEE80211_F_PUREG) &amp;&amp; rate &lt; 48) {</a>
<a name="ln2157">			ratesetmismatch(ni, wh, reassoc, resp, &quot;11g&quot;, rate);</a>
<a name="ln2158">			vap-&gt;iv_stats.is_rx_assoc_norate++;</a>
<a name="ln2159">			return;</a>
<a name="ln2160">		}</a>
<a name="ln2161"> </a>
<a name="ln2162">		/*</a>
<a name="ln2163">		 * Do HT rate set handling and setup HT node state.</a>
<a name="ln2164">		 */</a>
<a name="ln2165">		ni-&gt;ni_chan = vap-&gt;iv_bss-&gt;ni_chan;</a>
<a name="ln2166"> </a>
<a name="ln2167">		/* VHT */</a>
<a name="ln2168">		if (IEEE80211_IS_CHAN_VHT(ni-&gt;ni_chan) &amp;&amp;</a>
<a name="ln2169">		    vhtcap != NULL &amp;&amp;</a>
<a name="ln2170">		    vhtinfo != NULL) {</a>
<a name="ln2171">			/* XXX TODO; see below */</a>
<a name="ln2172">			printf(&quot;%s: VHT TODO!\n&quot;, __func__);</a>
<a name="ln2173">			ieee80211_vht_node_init(ni);</a>
<a name="ln2174">			ieee80211_vht_update_cap(ni, vhtcap, vhtinfo);</a>
<a name="ln2175">		} else if (ni-&gt;ni_flags &amp; IEEE80211_NODE_VHT)</a>
<a name="ln2176">			ieee80211_vht_node_cleanup(ni);</a>
<a name="ln2177"> </a>
<a name="ln2178">		/* HT */</a>
<a name="ln2179">		if (IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan) &amp;&amp; htcap != NULL) {</a>
<a name="ln2180">			rate = ieee80211_setup_htrates(ni, htcap,</a>
<a name="ln2181">				IEEE80211_F_DOFMCS | IEEE80211_F_DONEGO |</a>
<a name="ln2182">				IEEE80211_F_DOBRS);</a>
<a name="ln2183">			if (rate &amp; IEEE80211_RATE_BASIC) {</a>
<a name="ln2184">				ratesetmismatch(ni, wh, reassoc, resp,</a>
<a name="ln2185">				    &quot;HT&quot;, rate);</a>
<a name="ln2186">				vap-&gt;iv_stats.is_ht_assoc_norate++;</a>
<a name="ln2187">				return;</a>
<a name="ln2188">			}</a>
<a name="ln2189">			ieee80211_ht_node_init(ni);</a>
<a name="ln2190">			ieee80211_ht_updatehtcap(ni, htcap);</a>
<a name="ln2191">		} else if (ni-&gt;ni_flags &amp; IEEE80211_NODE_HT)</a>
<a name="ln2192">			ieee80211_ht_node_cleanup(ni);</a>
<a name="ln2193"> </a>
<a name="ln2194">		/* Finally - this will use HT/VHT info to change node channel */</a>
<a name="ln2195">		if (IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan) &amp;&amp; htcap != NULL) {</a>
<a name="ln2196">			ieee80211_ht_updatehtcap_final(ni);</a>
<a name="ln2197">		}</a>
<a name="ln2198"> </a>
<a name="ln2199">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2200">		/* Always do ff node cleanup; for A-MSDU */</a>
<a name="ln2201">		ieee80211_ff_node_cleanup(ni);</a>
<a name="ln2202">#endif</a>
<a name="ln2203">		/*</a>
<a name="ln2204">		 * Allow AMPDU operation only with unencrypted traffic</a>
<a name="ln2205">		 * or AES-CCM; the 11n spec only specifies these ciphers</a>
<a name="ln2206">		 * so permitting any others is undefined and can lead</a>
<a name="ln2207">		 * to interoperability problems.</a>
<a name="ln2208">		 */</a>
<a name="ln2209">		if ((ni-&gt;ni_flags &amp; IEEE80211_NODE_HT) &amp;&amp;</a>
<a name="ln2210">		    (((vap-&gt;iv_flags &amp; IEEE80211_F_WPA) &amp;&amp;</a>
<a name="ln2211">		      rsnparms.rsn_ucastcipher != IEEE80211_CIPHER_AES_CCM) ||</a>
<a name="ln2212">		     (vap-&gt;iv_flags &amp; (IEEE80211_F_WPA|IEEE80211_F_PRIVACY)) == IEEE80211_F_PRIVACY)) {</a>
<a name="ln2213">			IEEE80211_NOTE(vap,</a>
<a name="ln2214">			    IEEE80211_MSG_ASSOC | IEEE80211_MSG_11N, ni,</a>
<a name="ln2215">			    &quot;disallow HT use because WEP or TKIP requested, &quot;</a>
<a name="ln2216">			    &quot;capinfo 0x%x ucastcipher %d&quot;, capinfo,</a>
<a name="ln2217">			    rsnparms.rsn_ucastcipher);</a>
<a name="ln2218">			ieee80211_ht_node_cleanup(ni);</a>
<a name="ln2219">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2220">			/* Always do ff node cleanup; for A-MSDU */</a>
<a name="ln2221">			ieee80211_ff_node_cleanup(ni);</a>
<a name="ln2222">#endif</a>
<a name="ln2223">			vap-&gt;iv_stats.is_ht_assoc_downgrade++;</a>
<a name="ln2224">		}</a>
<a name="ln2225">		/*</a>
<a name="ln2226">		 * If constrained to 11n-only stations reject legacy stations.</a>
<a name="ln2227">		 */</a>
<a name="ln2228">		if ((vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_PUREN) &amp;&amp;</a>
<a name="ln2229">		    (ni-&gt;ni_flags &amp; IEEE80211_NODE_HT) == 0) {</a>
<a name="ln2230">			htcapmismatch(ni, wh, reassoc, resp);</a>
<a name="ln2231">			vap-&gt;iv_stats.is_ht_assoc_nohtcap++;</a>
<a name="ln2232">			return;</a>
<a name="ln2233">		}</a>
<a name="ln2234">		IEEE80211_RSSI_LPF(ni-&gt;ni_avgrssi, rssi);</a>
<a name="ln2235">		ni-&gt;ni_noise = nf;</a>
<a name="ln2236">		ni-&gt;ni_intval = lintval;</a>
<a name="ln2237">		ni-&gt;ni_capinfo = capinfo;</a>
<a name="ln2238">		ni-&gt;ni_fhdwell = vap-&gt;iv_bss-&gt;ni_fhdwell;</a>
<a name="ln2239">		ni-&gt;ni_fhindex = vap-&gt;iv_bss-&gt;ni_fhindex;</a>
<a name="ln2240">		/*</a>
<a name="ln2241">		 * Store the IEs.</a>
<a name="ln2242">		 * XXX maybe better to just expand</a>
<a name="ln2243">		 */</a>
<a name="ln2244">		if (ieee80211_ies_init(&amp;ni-&gt;ni_ies, sfrm, efrm - sfrm)) {</a>
<a name="ln2245">#define	setie(_ie, _off)	ieee80211_ies_setie(ni-&gt;ni_ies, _ie, _off)</a>
<a name="ln2246">			if (wpa != NULL)</a>
<a name="ln2247">				setie(wpa_ie, wpa - sfrm);</a>
<a name="ln2248">			if (rsn != NULL)</a>
<a name="ln2249">				setie(rsn_ie, rsn - sfrm);</a>
<a name="ln2250">			if (htcap != NULL)</a>
<a name="ln2251">				setie(htcap_ie, htcap - sfrm);</a>
<a name="ln2252">			if (wme != NULL) {</a>
<a name="ln2253">				setie(wme_ie, wme - sfrm);</a>
<a name="ln2254">				/*</a>
<a name="ln2255">				 * Mark node as capable of QoS.</a>
<a name="ln2256">				 */</a>
<a name="ln2257">				ni-&gt;ni_flags |= IEEE80211_NODE_QOS;</a>
<a name="ln2258">			} else</a>
<a name="ln2259">				ni-&gt;ni_flags &amp;= ~IEEE80211_NODE_QOS;</a>
<a name="ln2260">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2261">			if (ath != NULL) {</a>
<a name="ln2262">				setie(ath_ie, ath - sfrm);</a>
<a name="ln2263">				/* </a>
<a name="ln2264">				 * Parse ATH station parameters.</a>
<a name="ln2265">				 */</a>
<a name="ln2266">				ieee80211_parse_ath(ni, ni-&gt;ni_ies.ath_ie);</a>
<a name="ln2267">			} else</a>
<a name="ln2268">#endif</a>
<a name="ln2269">				ni-&gt;ni_ath_flags = 0;</a>
<a name="ln2270">#undef setie</a>
<a name="ln2271">		} else {</a>
<a name="ln2272">			ni-&gt;ni_flags &amp;= ~IEEE80211_NODE_QOS;</a>
<a name="ln2273">			ni-&gt;ni_ath_flags = 0;</a>
<a name="ln2274">		}</a>
<a name="ln2275">		ieee80211_node_join(ni, resp);</a>
<a name="ln2276">		ieee80211_deliver_l2uf(ni);</a>
<a name="ln2277">		break;</a>
<a name="ln2278">	}</a>
<a name="ln2279"> </a>
<a name="ln2280">	case IEEE80211_FC0_SUBTYPE_DEAUTH:</a>
<a name="ln2281">	case IEEE80211_FC0_SUBTYPE_DISASSOC: {</a>
<a name="ln2282">		uint16_t reason;</a>
<a name="ln2283"> </a>
<a name="ln2284">		if (vap-&gt;iv_state != IEEE80211_S_RUN ||</a>
<a name="ln2285">		    /* NB: can happen when in promiscuous mode */</a>
<a name="ln2286">		    !IEEE80211_ADDR_EQ(wh-&gt;i_addr1, vap-&gt;iv_myaddr)) {</a>
<a name="ln2287">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln2288">			break;</a>
<a name="ln2289">		}</a>
<a name="ln2290">		/*</a>
<a name="ln2291">		 * deauth/disassoc frame format</a>
<a name="ln2292">		 *	[2] reason</a>
<a name="ln2293">		 */</a>
<a name="ln2294">		IEEE80211_VERIFY_LENGTH(efrm - frm, 2, return);</a>
<a name="ln2295">		reason = le16toh(*(uint16_t *)frm);</a>
<a name="ln2296">		if (subtype == IEEE80211_FC0_SUBTYPE_DEAUTH) {</a>
<a name="ln2297">			vap-&gt;iv_stats.is_rx_deauth++;</a>
<a name="ln2298">			IEEE80211_NODE_STAT(ni, rx_deauth);</a>
<a name="ln2299">		} else {</a>
<a name="ln2300">			vap-&gt;iv_stats.is_rx_disassoc++;</a>
<a name="ln2301">			IEEE80211_NODE_STAT(ni, rx_disassoc);</a>
<a name="ln2302">		}</a>
<a name="ln2303">		IEEE80211_NOTE(vap, IEEE80211_MSG_AUTH, ni,</a>
<a name="ln2304">		    &quot;recv %s (reason: %d (%s))&quot;,</a>
<a name="ln2305">		    ieee80211_mgt_subtype_name(subtype),</a>
<a name="ln2306">		    reason, ieee80211_reason_to_string(reason));</a>
<a name="ln2307">		if (ni != vap-&gt;iv_bss)</a>
<a name="ln2308">			ieee80211_node_leave(ni);</a>
<a name="ln2309">		break;</a>
<a name="ln2310">	}</a>
<a name="ln2311"> </a>
<a name="ln2312">	case IEEE80211_FC0_SUBTYPE_ACTION:</a>
<a name="ln2313">	case IEEE80211_FC0_SUBTYPE_ACTION_NOACK:</a>
<a name="ln2314">		if (ni == vap-&gt;iv_bss) {</a>
<a name="ln2315">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln2316">			    wh, NULL, &quot;%s&quot;, &quot;unknown node&quot;);</a>
<a name="ln2317">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln2318">		} else if (!IEEE80211_ADDR_EQ(vap-&gt;iv_myaddr, wh-&gt;i_addr1) &amp;&amp;</a>
<a name="ln2319">		    !IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln2320">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln2321">			    wh, NULL, &quot;%s&quot;, &quot;not for us&quot;);</a>
<a name="ln2322">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln2323">		} else if (vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln2324">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln2325">			    wh, NULL, &quot;wrong state %s&quot;,</a>
<a name="ln2326">			    ieee80211_state_name[vap-&gt;iv_state]);</a>
<a name="ln2327">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln2328">		} else {</a>
<a name="ln2329">			if (ieee80211_parse_action(ni, m0) == 0)</a>
<a name="ln2330">				(void)ic-&gt;ic_recv_action(ni, wh, frm, efrm);</a>
<a name="ln2331">		}</a>
<a name="ln2332">		break;</a>
<a name="ln2333"> </a>
<a name="ln2334">	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:</a>
<a name="ln2335">	case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:</a>
<a name="ln2336">	case IEEE80211_FC0_SUBTYPE_TIMING_ADV:</a>
<a name="ln2337">	case IEEE80211_FC0_SUBTYPE_ATIM:</a>
<a name="ln2338">		IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln2339">		    wh, NULL, &quot;%s&quot;, &quot;not handled&quot;);</a>
<a name="ln2340">		vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln2341">		break;</a>
<a name="ln2342"> </a>
<a name="ln2343">	default:</a>
<a name="ln2344">		IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln2345">		    wh, &quot;mgt&quot;, &quot;subtype 0x%x not handled&quot;, subtype);</a>
<a name="ln2346">		vap-&gt;iv_stats.is_rx_badsubtype++;</a>
<a name="ln2347">		break;</a>
<a name="ln2348">	}</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">static void</a>
<a name="ln2352">hostap_recv_ctl(struct ieee80211_node *ni, struct mbuf *m, int subtype)</a>
<a name="ln2353">{</a>
<a name="ln2354">	switch (subtype) {</a>
<a name="ln2355">	case IEEE80211_FC0_SUBTYPE_PS_POLL:</a>
<a name="ln2356">		ni-&gt;ni_vap-&gt;iv_recv_pspoll(ni, m);</a>
<a name="ln2357">		break;</a>
<a name="ln2358">	case IEEE80211_FC0_SUBTYPE_BAR:</a>
<a name="ln2359">		ieee80211_recv_bar(ni, m);</a>
<a name="ln2360">		break;</a>
<a name="ln2361">	}</a>
<a name="ln2362">}</a>
<a name="ln2363"> </a>
<a name="ln2364">/*</a>
<a name="ln2365"> * Process a received ps-poll frame.</a>
<a name="ln2366"> */</a>
<a name="ln2367">void</a>
<a name="ln2368">ieee80211_recv_pspoll(struct ieee80211_node *ni, struct mbuf *m0)</a>
<a name="ln2369">{</a>
<a name="ln2370">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln2371">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2372">	struct ieee80211_frame_min *wh;</a>
<a name="ln2373">	struct mbuf *m;</a>
<a name="ln2374">	uint16_t aid;</a>
<a name="ln2375">	int qlen;</a>
<a name="ln2376"> </a>
<a name="ln2377">	wh = mtod(m0, struct ieee80211_frame_min *);</a>
<a name="ln2378">	if (ni-&gt;ni_associd == 0) {</a>
<a name="ln2379">		IEEE80211_DISCARD(vap,</a>
<a name="ln2380">		    IEEE80211_MSG_POWER | IEEE80211_MSG_DEBUG,</a>
<a name="ln2381">		    (struct ieee80211_frame *) wh, NULL,</a>
<a name="ln2382">		    &quot;%s&quot;, &quot;unassociated station&quot;);</a>
<a name="ln2383">		vap-&gt;iv_stats.is_ps_unassoc++;</a>
<a name="ln2384">		IEEE80211_SEND_MGMT(ni, IEEE80211_FC0_SUBTYPE_DEAUTH,</a>
<a name="ln2385">			IEEE80211_REASON_NOT_ASSOCED);</a>
<a name="ln2386">		return;</a>
<a name="ln2387">	}</a>
<a name="ln2388"> </a>
<a name="ln2389">	aid = le16toh(*(uint16_t *)wh-&gt;i_dur);</a>
<a name="ln2390">	if (aid != ni-&gt;ni_associd) {</a>
<a name="ln2391">		IEEE80211_DISCARD(vap,</a>
<a name="ln2392">		    IEEE80211_MSG_POWER | IEEE80211_MSG_DEBUG,</a>
<a name="ln2393">		    (struct ieee80211_frame *) wh, NULL,</a>
<a name="ln2394">		    &quot;aid mismatch: sta aid 0x%x poll aid 0x%x&quot;,</a>
<a name="ln2395">		    ni-&gt;ni_associd, aid);</a>
<a name="ln2396">		vap-&gt;iv_stats.is_ps_badaid++;</a>
<a name="ln2397">		/*</a>
<a name="ln2398">		 * NB: We used to deauth the station but it turns out</a>
<a name="ln2399">		 * the Blackberry Curve 8230 (and perhaps other devices) </a>
<a name="ln2400">		 * sometimes send the wrong AID when WME is negotiated.</a>
<a name="ln2401">		 * Being more lenient here seems ok as we already check</a>
<a name="ln2402">		 * the station is associated and we only return frames</a>
<a name="ln2403">		 * queued for the station (i.e. we don't use the AID).</a>
<a name="ln2404">		 */</a>
<a name="ln2405">		return;</a>
<a name="ln2406">	}</a>
<a name="ln2407"> </a>
<a name="ln2408">	/* Okay, take the first queued packet and put it out... */</a>
<a name="ln2409">	m = ieee80211_node_psq_dequeue(ni, &amp;qlen);</a>
<a name="ln2410">	if (m == NULL) {</a>
<a name="ln2411">		IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_POWER, wh-&gt;i_addr2,</a>
<a name="ln2412">		    &quot;%s&quot;, &quot;recv ps-poll, but queue empty&quot;);</a>
<a name="ln2413">		ieee80211_send_nulldata(ieee80211_ref_node(ni));</a>
<a name="ln2414">		vap-&gt;iv_stats.is_ps_qempty++;	/* XXX node stat */</a>
<a name="ln2415">		if (vap-&gt;iv_set_tim != NULL)</a>
<a name="ln2416">			vap-&gt;iv_set_tim(ni, 0);	/* just in case */</a>
<a name="ln2417">		return;</a>
<a name="ln2418">	}</a>
<a name="ln2419">	/* </a>
<a name="ln2420">	 * If there are more packets, set the more packets bit</a>
<a name="ln2421">	 * in the packet dispatched to the station; otherwise</a>
<a name="ln2422">	 * turn off the TIM bit.</a>
<a name="ln2423">	 */</a>
<a name="ln2424">	if (qlen != 0) {</a>
<a name="ln2425">		IEEE80211_NOTE(vap, IEEE80211_MSG_POWER, ni,</a>
<a name="ln2426">		    &quot;recv ps-poll, send packet, %u still queued&quot;, qlen);</a>
<a name="ln2427">		m-&gt;m_flags |= M_MORE_DATA;</a>
<a name="ln2428">	} else {</a>
<a name="ln2429">		IEEE80211_NOTE(vap, IEEE80211_MSG_POWER, ni,</a>
<a name="ln2430">		    &quot;%s&quot;, &quot;recv ps-poll, send packet, queue empty&quot;);</a>
<a name="ln2431">		if (vap-&gt;iv_set_tim != NULL)</a>
<a name="ln2432">			vap-&gt;iv_set_tim(ni, 0);</a>
<a name="ln2433">	}</a>
<a name="ln2434">	m-&gt;m_flags |= M_PWR_SAV;		/* bypass PS handling */</a>
<a name="ln2435"> </a>
<a name="ln2436">	/*</a>
<a name="ln2437">	 * Do the right thing; if it's an encap'ed frame then</a>
<a name="ln2438">	 * call ieee80211_parent_xmitpkt() else</a>
<a name="ln2439">	 * call ieee80211_vap_xmitpkt().</a>
<a name="ln2440">	 */</a>
<a name="ln2441">	if (m-&gt;m_flags &amp; M_ENCAP) {</a>
<a name="ln2442">		(void) ieee80211_parent_xmitpkt(ic, m);</a>
<a name="ln2443">	} else {</a>
<a name="ln2444">		(void) ieee80211_vap_xmitpkt(vap, m);</a>
<a name="ln2445">	}</a>
<a name="ln2446">}</a>

</code></pre>
<div class="balloon" rel="1728"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v634/" target="_blank">V634</a> The priority of the '*' operation is higher than that of the '<<' operation. It's possible that parentheses should be used in the expression.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
