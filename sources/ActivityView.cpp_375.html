
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ActivityView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2008-2015, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;ActivityView.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;new&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;vector&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#ifdef __HAIKU__</a>
<a name="ln15">#	include &lt;AboutWindow.h&gt;</a>
<a name="ln16">#	include &lt;AbstractLayoutItem.h&gt;</a>
<a name="ln17">#	include &lt;ControlLook.h&gt;</a>
<a name="ln18">#endif</a>
<a name="ln19">#include &lt;Application.h&gt;</a>
<a name="ln20">#include &lt;Autolock.h&gt;</a>
<a name="ln21">#include &lt;Bitmap.h&gt;</a>
<a name="ln22">#include &lt;Catalog.h&gt;</a>
<a name="ln23">#include &lt;Dragger.h&gt;</a>
<a name="ln24">#include &lt;MenuItem.h&gt;</a>
<a name="ln25">#include &lt;MessageRunner.h&gt;</a>
<a name="ln26">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln27">#include &lt;Shape.h&gt;</a>
<a name="ln28">#include &lt;String.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;ActivityMonitor.h&quot;</a>
<a name="ln31">#include &quot;ActivityWindow.h&quot;</a>
<a name="ln32">#include &quot;SettingsWindow.h&quot;</a>
<a name="ln33">#include &quot;SystemInfo.h&quot;</a>
<a name="ln34">#include &quot;SystemInfoHandler.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln37">#define B_TRANSLATION_CONTEXT &quot;ActivityView&quot;</a>
<a name="ln38"> </a>
<a name="ln39">template&lt;typename ObjectType&gt;</a>
<a name="ln40">class ListAddDeleter {</a>
<a name="ln41">public:</a>
<a name="ln42">	ListAddDeleter(BObjectList&lt;ObjectType&gt;&amp; list, ObjectType* object,</a>
<a name="ln43">			int32 spot)</a>
<a name="ln44">		:</a>
<a name="ln45">		fList(list),</a>
<a name="ln46">		fObject(object)</a>
<a name="ln47">	{</a>
<a name="ln48">		if (fObject != NULL &amp;&amp; !fList.AddItem(fObject, spot)) {</a>
<a name="ln49">			delete fObject;</a>
<a name="ln50">			fObject = NULL;</a>
<a name="ln51">		}</a>
<a name="ln52">	}</a>
<a name="ln53"> </a>
<a name="ln54">	~ListAddDeleter()</a>
<a name="ln55">	{</a>
<a name="ln56">		if (fObject != NULL) {</a>
<a name="ln57">			fList.RemoveItem(fObject);</a>
<a name="ln58">			delete fObject;</a>
<a name="ln59">		}</a>
<a name="ln60">	}</a>
<a name="ln61"> </a>
<a name="ln62">	bool Failed() const</a>
<a name="ln63">	{</a>
<a name="ln64">		return fObject == NULL;</a>
<a name="ln65">	}</a>
<a name="ln66"> </a>
<a name="ln67">	void Detach()</a>
<a name="ln68">	{</a>
<a name="ln69">		fObject = NULL;</a>
<a name="ln70">	}</a>
<a name="ln71"> </a>
<a name="ln72">private:</a>
<a name="ln73">	BObjectList&lt;ObjectType&gt;&amp;	fList;</a>
<a name="ln74">	ObjectType*					fObject;</a>
<a name="ln75">};</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">/*!	This class manages the scale of a history with a dynamic scale.</a>
<a name="ln79">	Every history value will be input via Update(), and the minimum/maximum</a>
<a name="ln80">	is computed from that.</a>
<a name="ln81">*/</a>
<a name="ln82">class Scale {</a>
<a name="ln83">public:</a>
<a name="ln84">								Scale(scale_type type);</a>
<a name="ln85"> </a>
<a name="ln86">			int64				MinimumValue() const { return fMinimumValue; }</a>
<a name="ln87">			int64				MaximumValue() const { return fMaximumValue; }</a>
<a name="ln88"> </a>
<a name="ln89">			void				Update(int64 value);</a>
<a name="ln90"> </a>
<a name="ln91">private:</a>
<a name="ln92">			scale_type			fType;</a>
<a name="ln93">			int64				fMinimumValue;</a>
<a name="ln94">			int64				fMaximumValue;</a>
<a name="ln95">			bool				fInitialized;</a>
<a name="ln96">};</a>
<a name="ln97"> </a>
<a name="ln98">/*!	Stores the interpolated on screen view values. This is done so that the</a>
<a name="ln99">	interpolation is fixed, and does not change when being scrolled.</a>
<a name="ln100"> </a>
<a name="ln101">	We could also just do this by making sure we always ask for the same</a>
<a name="ln102">	interval only, but this way we also save the interpolation.</a>
<a name="ln103">*/</a>
<a name="ln104">class ViewHistory {</a>
<a name="ln105">public:</a>
<a name="ln106">								ViewHistory();</a>
<a name="ln107"> </a>
<a name="ln108">			int64				ValueAt(int32 x);</a>
<a name="ln109"> </a>
<a name="ln110">			int32				Start() const</a>
<a name="ln111">									{ return fValues.Size()</a>
<a name="ln112">										- fValues.CountItems(); }</a>
<a name="ln113"> </a>
<a name="ln114">			void				Update(DataHistory* history, int32 width,</a>
<a name="ln115">									int32 resolution, bigtime_t toTime,</a>
<a name="ln116">									bigtime_t step, bigtime_t refresh);</a>
<a name="ln117"> </a>
<a name="ln118">private:</a>
<a name="ln119">			CircularBuffer&lt;int64&gt; fValues;</a>
<a name="ln120">			int32				fResolution;</a>
<a name="ln121">			bigtime_t			fRefresh;</a>
<a name="ln122">			bigtime_t			fLastTime;</a>
<a name="ln123">};</a>
<a name="ln124"> </a>
<a name="ln125">struct data_item {</a>
<a name="ln126">	bigtime_t	time;</a>
<a name="ln127">	int64		value;</a>
<a name="ln128">};</a>
<a name="ln129"> </a>
<a name="ln130">#ifdef __HAIKU__</a>
<a name="ln131">class ActivityView::HistoryLayoutItem : public BAbstractLayoutItem {</a>
<a name="ln132">public:</a>
<a name="ln133">							HistoryLayoutItem(ActivityView* parent);</a>
<a name="ln134"> </a>
<a name="ln135">	virtual	bool			IsVisible();</a>
<a name="ln136">	virtual	void			SetVisible(bool visible);</a>
<a name="ln137"> </a>
<a name="ln138">	virtual	BRect			Frame();</a>
<a name="ln139">	virtual	void			SetFrame(BRect frame);</a>
<a name="ln140"> </a>
<a name="ln141">	virtual	BView*			View();</a>
<a name="ln142"> </a>
<a name="ln143">	virtual	BSize			BasePreferredSize();</a>
<a name="ln144"> </a>
<a name="ln145">private:</a>
<a name="ln146">	ActivityView*			fParent;</a>
<a name="ln147">	BRect					fFrame;</a>
<a name="ln148">};</a>
<a name="ln149"> </a>
<a name="ln150">class ActivityView::LegendLayoutItem : public BAbstractLayoutItem {</a>
<a name="ln151">public:</a>
<a name="ln152">							LegendLayoutItem(ActivityView* parent);</a>
<a name="ln153"> </a>
<a name="ln154">	virtual	bool			IsVisible();</a>
<a name="ln155">	virtual	void			SetVisible(bool visible);</a>
<a name="ln156"> </a>
<a name="ln157">	virtual	BRect			Frame();</a>
<a name="ln158">	virtual	void			SetFrame(BRect frame);</a>
<a name="ln159"> </a>
<a name="ln160">	virtual	BView*			View();</a>
<a name="ln161"> </a>
<a name="ln162">	virtual	BSize			BaseMinSize();</a>
<a name="ln163">	virtual	BSize			BaseMaxSize();</a>
<a name="ln164">	virtual	BSize			BasePreferredSize();</a>
<a name="ln165">	virtual	BAlignment		BaseAlignment();</a>
<a name="ln166"> </a>
<a name="ln167">private:</a>
<a name="ln168">	ActivityView*			fParent;</a>
<a name="ln169">	BRect					fFrame;</a>
<a name="ln170">};</a>
<a name="ln171">#endif</a>
<a name="ln172"> </a>
<a name="ln173">const bigtime_t kInitialRefreshInterval = 250000LL;</a>
<a name="ln174"> </a>
<a name="ln175">const uint32 kMsgToggleDataSource = 'tgds';</a>
<a name="ln176">const uint32 kMsgToggleLegend = 'tglg';</a>
<a name="ln177">const uint32 kMsgUpdateResolution = 'ures';</a>
<a name="ln178"> </a>
<a name="ln179">extern const char* kAppName;</a>
<a name="ln180">extern const char* kSignature;</a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">Scale::Scale(scale_type type)</a>
<a name="ln184">	:</a>
<a name="ln185">	fType(type),</a>
<a name="ln186">	fMinimumValue(0),</a>
<a name="ln187">	fMaximumValue(0),</a>
<a name="ln188">	fInitialized(false)</a>
<a name="ln189">{</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">void</a>
<a name="ln194">Scale::Update(int64 value)</a>
<a name="ln195">{</a>
<a name="ln196">	if (!fInitialized || fMinimumValue &gt; value)</a>
<a name="ln197">		fMinimumValue = value;</a>
<a name="ln198">	if (!fInitialized || fMaximumValue &lt; value)</a>
<a name="ln199">		fMaximumValue = value;</a>
<a name="ln200"> </a>
<a name="ln201">	fInitialized = true;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204"> </a>
<a name="ln205">//	#pragma mark -</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208">ViewHistory::ViewHistory()</a>
<a name="ln209">	:</a>
<a name="ln210">	fValues(1),</a>
<a name="ln211">	fResolution(-1),</a>
<a name="ln212">	fRefresh(-1),</a>
<a name="ln213">	fLastTime(0)</a>
<a name="ln214">{</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">int64</a>
<a name="ln219">ViewHistory::ValueAt(int32 x)</a>
<a name="ln220">{</a>
<a name="ln221">	int64* value = fValues.ItemAt(x - Start());</a>
<a name="ln222">	if (value != NULL)</a>
<a name="ln223">		return *value;</a>
<a name="ln224"> </a>
<a name="ln225">	return 0;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228"> </a>
<a name="ln229">void</a>
<a name="ln230">ViewHistory::Update(DataHistory* history, int32 width, int32 resolution,</a>
<a name="ln231">	bigtime_t toTime, bigtime_t step, bigtime_t refresh)</a>
<a name="ln232">{</a>
<a name="ln233">	if (width &gt; 16384) {</a>
<a name="ln234">		// ignore this - it seems the view hasn't been layouted yet</a>
<a name="ln235">		return;</a>
<a name="ln236">	}</a>
<a name="ln237"> </a>
<a name="ln238">	// Check if we need to invalidate the existing values</a>
<a name="ln239">	if ((int32)fValues.Size() != width</a>
<a name="ln240">		|| fResolution != resolution</a>
<a name="ln241">		|| fRefresh != refresh) {</a>
<a name="ln242">		fValues.SetSize(width);</a>
<a name="ln243">		fResolution = resolution;</a>
<a name="ln244">		fRefresh = refresh;</a>
<a name="ln245">		fLastTime = 0;</a>
<a name="ln246">	}</a>
<a name="ln247"> </a>
<a name="ln248">	// Compute how many new values we need to retrieve</a>
<a name="ln249">	if (fLastTime &lt; history-&gt;Start())</a>
<a name="ln250">		fLastTime = history-&gt;Start();</a>
<a name="ln251">	if (fLastTime &gt; history-&gt;End())</a>
<a name="ln252">		return;</a>
<a name="ln253"> </a>
<a name="ln254">	int32 updateWidth = int32((toTime - fLastTime) / step);</a>
<a name="ln255">	if (updateWidth &lt; 1)</a>
<a name="ln256">		return;</a>
<a name="ln257"> </a>
<a name="ln258">	if (updateWidth &gt; (int32)fValues.Size()) {</a>
<a name="ln259">		updateWidth = fValues.Size();</a>
<a name="ln260">		fLastTime = toTime - updateWidth * step;</a>
<a name="ln261">	}</a>
<a name="ln262"> </a>
<a name="ln263">	for (int32 i = 0; i &lt; updateWidth; i++) {</a>
<a name="ln264">		int64 value = history-&gt;ValueAt(fLastTime += step);</a>
<a name="ln265"> </a>
<a name="ln266">		if (step &gt; refresh) {</a>
<a name="ln267">			uint32 count = 1;</a>
<a name="ln268">			for (bigtime_t offset = refresh; offset &lt; step; offset += refresh) {</a>
<a name="ln269">				// TODO: handle int64 overflow correctly!</a>
<a name="ln270">				value += history-&gt;ValueAt(fLastTime + offset);</a>
<a name="ln271">				count++;</a>
<a name="ln272">			}</a>
<a name="ln273">			value /= count;</a>
<a name="ln274">		}</a>
<a name="ln275"> </a>
<a name="ln276">		fValues.AddItem(value);</a>
<a name="ln277">	}</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280"> </a>
<a name="ln281">//	#pragma mark -</a>
<a name="ln282"> </a>
<a name="ln283"> </a>
<a name="ln284">DataHistory::DataHistory(bigtime_t memorize, bigtime_t interval)</a>
<a name="ln285">	:</a>
<a name="ln286">	fBuffer(10000),</a>
<a name="ln287">	fMinimumValue(0),</a>
<a name="ln288">	fMaximumValue(0),</a>
<a name="ln289">	fRefreshInterval(interval),</a>
<a name="ln290">	fLastIndex(-1),</a>
<a name="ln291">	fScale(NULL)</a>
<a name="ln292">{</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">DataHistory::~DataHistory()</a>
<a name="ln297">{</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301">void</a>
<a name="ln302">DataHistory::AddValue(bigtime_t time, int64 value)</a>
<a name="ln303">{</a>
<a name="ln304">	if (fBuffer.IsEmpty() || fMaximumValue &lt; value)</a>
<a name="ln305">		fMaximumValue = value;</a>
<a name="ln306">	if (fBuffer.IsEmpty() || fMinimumValue &gt; value)</a>
<a name="ln307">		fMinimumValue = value;</a>
<a name="ln308">	if (fScale != NULL)</a>
<a name="ln309">		fScale-&gt;Update(value);</a>
<a name="ln310"> </a>
<a name="ln311">	data_item item = {time, value};</a>
<a name="ln312">	fBuffer.AddItem(item);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">int64</a>
<a name="ln317">DataHistory::ValueAt(bigtime_t time)</a>
<a name="ln318">{</a>
<a name="ln319">	int32 left = 0;</a>
<a name="ln320">	int32 right = fBuffer.CountItems() - 1;</a>
<a name="ln321">	data_item* item = NULL;</a>
<a name="ln322"> </a>
<a name="ln323">	while (left &lt;= right) {</a>
<a name="ln324">		int32 index = (left + right) / 2;</a>
<a name="ln325">		item = fBuffer.ItemAt(index);</a>
<a name="ln326"> </a>
<a name="ln327">		if (item-&gt;time &gt; time) {</a>
<a name="ln328">			// search in left part</a>
<a name="ln329">			right = index - 1;</a>
<a name="ln330">		} else {</a>
<a name="ln331">			data_item* nextItem = fBuffer.ItemAt(index + 1);</a>
<a name="ln332">			if (nextItem == NULL)</a>
<a name="ln333">				return item-&gt;value;</a>
<a name="ln334">			if (nextItem-&gt;time &gt; time) {</a>
<a name="ln335">				// found item</a>
<a name="ln336">				int64 value = item-&gt;value;</a>
<a name="ln337">				value += int64(double(nextItem-&gt;value - value)</a>
<a name="ln338">					/ (nextItem-&gt;time - item-&gt;time) * (time - item-&gt;time));</a>
<a name="ln339">				return value;</a>
<a name="ln340">			}</a>
<a name="ln341"> </a>
<a name="ln342">			// search in right part</a>
<a name="ln343">			left = index + 1;</a>
<a name="ln344">		}</a>
<a name="ln345">	}</a>
<a name="ln346"> </a>
<a name="ln347">	return 0;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350"> </a>
<a name="ln351">int64</a>
<a name="ln352">DataHistory::MaximumValue() const</a>
<a name="ln353">{</a>
<a name="ln354">	if (fScale != NULL)</a>
<a name="ln355">		return fScale-&gt;MaximumValue();</a>
<a name="ln356"> </a>
<a name="ln357">	return fMaximumValue;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360"> </a>
<a name="ln361">int64</a>
<a name="ln362">DataHistory::MinimumValue() const</a>
<a name="ln363">{</a>
<a name="ln364">	if (fScale != NULL)</a>
<a name="ln365">		return fScale-&gt;MinimumValue();</a>
<a name="ln366"> </a>
<a name="ln367">	return fMinimumValue;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">bigtime_t</a>
<a name="ln372">DataHistory::Start() const</a>
<a name="ln373">{</a>
<a name="ln374">	if (fBuffer.CountItems() == 0)</a>
<a name="ln375">		return 0;</a>
<a name="ln376"> </a>
<a name="ln377">	return fBuffer.ItemAt(0)-&gt;time;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">bigtime_t</a>
<a name="ln382">DataHistory::End() const</a>
<a name="ln383">{</a>
<a name="ln384">	if (fBuffer.CountItems() == 0)</a>
<a name="ln385">		return 0;</a>
<a name="ln386"> </a>
<a name="ln387">	return fBuffer.ItemAt(fBuffer.CountItems() - 1)-&gt;time;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">void</a>
<a name="ln392">DataHistory::SetRefreshInterval(bigtime_t interval)</a>
<a name="ln393">{</a>
<a name="ln394">	// TODO: adjust buffer size</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397"> </a>
<a name="ln398">void</a>
<a name="ln399">DataHistory::SetScale(Scale* scale)</a>
<a name="ln400">{</a>
<a name="ln401">	fScale = scale;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">//	#pragma mark -</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">#ifdef __HAIKU__</a>
<a name="ln409">ActivityView::HistoryLayoutItem::HistoryLayoutItem(ActivityView* parent)</a>
<a name="ln410">	:</a>
<a name="ln411">	fParent(parent),</a>
<a name="ln412">	fFrame()</a>
<a name="ln413">{</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416"> </a>
<a name="ln417">bool</a>
<a name="ln418">ActivityView::HistoryLayoutItem::IsVisible()</a>
<a name="ln419">{</a>
<a name="ln420">	return !fParent-&gt;IsHidden(fParent);</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423"> </a>
<a name="ln424">void</a>
<a name="ln425">ActivityView::HistoryLayoutItem::SetVisible(bool visible)</a>
<a name="ln426">{</a>
<a name="ln427">	// not allowed</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430"> </a>
<a name="ln431">BRect</a>
<a name="ln432">ActivityView::HistoryLayoutItem::Frame()</a>
<a name="ln433">{</a>
<a name="ln434">	return fFrame;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">void</a>
<a name="ln439">ActivityView::HistoryLayoutItem::SetFrame(BRect frame)</a>
<a name="ln440">{</a>
<a name="ln441">	fFrame = frame;</a>
<a name="ln442">	fParent-&gt;_UpdateFrame();</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445"> </a>
<a name="ln446">BView*</a>
<a name="ln447">ActivityView::HistoryLayoutItem::View()</a>
<a name="ln448">{</a>
<a name="ln449">	return fParent;</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452"> </a>
<a name="ln453">BSize</a>
<a name="ln454">ActivityView::HistoryLayoutItem::BasePreferredSize()</a>
<a name="ln455">{</a>
<a name="ln456">	BSize size(BaseMaxSize());</a>
<a name="ln457">	return size;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460"> </a>
<a name="ln461">//	#pragma mark -</a>
<a name="ln462"> </a>
<a name="ln463"> </a>
<a name="ln464">ActivityView::LegendLayoutItem::LegendLayoutItem(ActivityView* parent)</a>
<a name="ln465">	:</a>
<a name="ln466">	fParent(parent),</a>
<a name="ln467">	fFrame()</a>
<a name="ln468">{</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">bool</a>
<a name="ln473">ActivityView::LegendLayoutItem::IsVisible()</a>
<a name="ln474">{</a>
<a name="ln475">	return !fParent-&gt;IsHidden(fParent);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478"> </a>
<a name="ln479">void</a>
<a name="ln480">ActivityView::LegendLayoutItem::SetVisible(bool visible)</a>
<a name="ln481">{</a>
<a name="ln482">	// not allowed</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485"> </a>
<a name="ln486">BRect</a>
<a name="ln487">ActivityView::LegendLayoutItem::Frame()</a>
<a name="ln488">{</a>
<a name="ln489">	return fFrame;</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">void</a>
<a name="ln494">ActivityView::LegendLayoutItem::SetFrame(BRect frame)</a>
<a name="ln495">{</a>
<a name="ln496">	fFrame = frame;</a>
<a name="ln497">	fParent-&gt;_UpdateFrame();</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500"> </a>
<a name="ln501">BView*</a>
<a name="ln502">ActivityView::LegendLayoutItem::View()</a>
<a name="ln503">{</a>
<a name="ln504">	return fParent;</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507"> </a>
<a name="ln508">BSize</a>
<a name="ln509">ActivityView::LegendLayoutItem::BaseMinSize()</a>
<a name="ln510">{</a>
<a name="ln511">	// TODO: Cache the info. Might be too expensive for this call.</a>
<a name="ln512">	BSize size;</a>
<a name="ln513">	size.width = 80;</a>
<a name="ln514">	size.height = fParent-&gt;_LegendHeight();</a>
<a name="ln515"> </a>
<a name="ln516">	return size;</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">BSize</a>
<a name="ln521">ActivityView::LegendLayoutItem::BaseMaxSize()</a>
<a name="ln522">{</a>
<a name="ln523">	BSize size(BaseMinSize());</a>
<a name="ln524">	size.width = B_SIZE_UNLIMITED;</a>
<a name="ln525">	return size;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528"> </a>
<a name="ln529">BSize</a>
<a name="ln530">ActivityView::LegendLayoutItem::BasePreferredSize()</a>
<a name="ln531">{</a>
<a name="ln532">	BSize size(BaseMinSize());</a>
<a name="ln533">	return size;</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536"> </a>
<a name="ln537">BAlignment</a>
<a name="ln538">ActivityView::LegendLayoutItem::BaseAlignment()</a>
<a name="ln539">{</a>
<a name="ln540">	return BAlignment(B_ALIGN_USE_FULL_WIDTH, B_ALIGN_USE_FULL_HEIGHT);</a>
<a name="ln541">}</a>
<a name="ln542">#endif</a>
<a name="ln543"> </a>
<a name="ln544"> </a>
<a name="ln545">//	#pragma mark -</a>
<a name="ln546"> </a>
<a name="ln547"> </a>
<a name="ln548">const rgb_color kWhite = (rgb_color){255, 255, 255, 255};</a>
<a name="ln549">const rgb_color kBlack = (rgb_color){0, 0, 0, 255};</a>
<a name="ln550">const float kDraggerSize = 7;</a>
<a name="ln551"> </a>
<a name="ln552"> </a>
<a name="ln553">ActivityView::ActivityView(BRect frame, const char* name,</a>
<a name="ln554">		const BMessage* settings, uint32 resizingMode)</a>
<a name="ln555">	: BView(frame, name, resizingMode,</a>
<a name="ln556">		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_FRAME_EVENTS),</a>
<a name="ln557">	fSourcesLock(&quot;data sources&quot;)</a>
<a name="ln558">{</a>
<a name="ln559">	_Init(settings);</a>
<a name="ln560"> </a>
<a name="ln561">	BRect rect(Bounds());</a>
<a name="ln562">	rect.top = rect.bottom - kDraggerSize;</a>
<a name="ln563">	rect.left = rect.right - kDraggerSize;</a>
<a name="ln564">	BDragger* dragger = new BDragger(rect, this,</a>
<a name="ln565">		B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM);</a>
<a name="ln566">	AddChild(dragger);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569"> </a>
<a name="ln570">ActivityView::ActivityView(const char* name, const BMessage* settings)</a>
<a name="ln571">#ifdef __HAIKU__</a>
<a name="ln572">	: BView(name, B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_FRAME_EVENTS),</a>
<a name="ln573">#else</a>
<a name="ln574">	: BView(BRect(0, 0, 300, 200), name, B_FOLLOW_NONE,</a>
<a name="ln575">		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_FRAME_EVENTS),</a>
<a name="ln576">#endif</a>
<a name="ln577">	fSourcesLock(&quot;data sources&quot;)</a>
<a name="ln578">{</a>
<a name="ln579">	SetLowUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln580"> </a>
<a name="ln581">	_Init(settings);</a>
<a name="ln582"> </a>
<a name="ln583">	BRect rect(Bounds());</a>
<a name="ln584">	rect.top = rect.bottom - kDraggerSize;</a>
<a name="ln585">	rect.left = rect.right - kDraggerSize;</a>
<a name="ln586">	BDragger* dragger = new BDragger(rect, this,</a>
<a name="ln587">		B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM);</a>
<a name="ln588">	AddChild(dragger);</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591"> </a>
<a name="ln592">ActivityView::ActivityView(BMessage* archive)</a>
<a name="ln593">	: BView(archive)</a>
<a name="ln594">{</a>
<a name="ln595">	_Init(archive);</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598"> </a>
<a name="ln599">ActivityView::~ActivityView()</a>
<a name="ln600">{</a>
<a name="ln601">	delete fOffscreen;</a>
<a name="ln602">	delete fSystemInfoHandler;</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606">void</a>
<a name="ln607">ActivityView::_Init(const BMessage* settings)</a>
<a name="ln608">{</a>
<a name="ln609">	fHistoryBackgroundColor = (rgb_color){255, 255, 240};</a>
<a name="ln610">	fLegendBackgroundColor = LowColor();</a>
<a name="ln611">		// the low color is restored by the BView unarchiving</a>
<a name="ln612">	fOffscreen = NULL;</a>
<a name="ln613">#ifdef __HAIKU__</a>
<a name="ln614">	fHistoryLayoutItem = NULL;</a>
<a name="ln615">	fLegendLayoutItem = NULL;</a>
<a name="ln616">#endif</a>
<a name="ln617">	SetViewColor(B_TRANSPARENT_COLOR);</a>
<a name="ln618"> </a>
<a name="ln619">	fLastRefresh = 0;</a>
<a name="ln620">	fDrawResolution = 1;</a>
<a name="ln621">	fZooming = false;</a>
<a name="ln622"> </a>
<a name="ln623">	fSystemInfoHandler = new SystemInfoHandler;</a>
<a name="ln624"> </a>
<a name="ln625">	if (settings == NULL</a>
<a name="ln626">		|| settings-&gt;FindInt64(&quot;refresh interval&quot;, &amp;fRefreshInterval) != B_OK)</a>
<a name="ln627">		fRefreshInterval = kInitialRefreshInterval;</a>
<a name="ln628"> </a>
<a name="ln629">	if (settings == NULL</a>
<a name="ln630">		|| settings-&gt;FindBool(&quot;show legend&quot;, &amp;fShowLegend) != B_OK)</a>
<a name="ln631">		fShowLegend = true;</a>
<a name="ln632"> </a>
<a name="ln633">	if (settings == NULL)</a>
<a name="ln634">		return;</a>
<a name="ln635"> </a>
<a name="ln636">	ssize_t colorLength;</a>
<a name="ln637">	rgb_color *color;</a>
<a name="ln638">	if (settings-&gt;FindData(&quot;history background color&quot;, B_RGB_COLOR_TYPE,</a>
<a name="ln639">			(const void **)&amp;color, &amp;colorLength) == B_OK</a>
<a name="ln640">		&amp;&amp; colorLength == sizeof(rgb_color))</a>
<a name="ln641">		fHistoryBackgroundColor = *color;</a>
<a name="ln642"> </a>
<a name="ln643">	const char* name;</a>
<a name="ln644">	for (int32 i = 0; settings-&gt;FindString(&quot;source&quot;, i, &amp;name) == B_OK; i++)</a>
<a name="ln645">		AddDataSource(DataSource::FindSource(name), settings);</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649">status_t</a>
<a name="ln650">ActivityView::Archive(BMessage* into, bool deep) const</a>
<a name="ln651">{</a>
<a name="ln652">	status_t status;</a>
<a name="ln653"> </a>
<a name="ln654">	status = BView::Archive(into, deep);</a>
<a name="ln655">	if (status &lt; B_OK)</a>
<a name="ln656">		return status;</a>
<a name="ln657"> </a>
<a name="ln658">	status = into-&gt;AddString(&quot;add_on&quot;, kSignature);</a>
<a name="ln659">	if (status &lt; B_OK)</a>
<a name="ln660">		return status;</a>
<a name="ln661"> </a>
<a name="ln662">	status = SaveState(*into);</a>
<a name="ln663">	if (status &lt; B_OK)</a>
<a name="ln664">		return status;</a>
<a name="ln665"> </a>
<a name="ln666">	return B_OK;</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669"> </a>
<a name="ln670">BArchivable*</a>
<a name="ln671">ActivityView::Instantiate(BMessage* archive)</a>
<a name="ln672">{</a>
<a name="ln673">	if (!validate_instantiation(archive, &quot;ActivityView&quot;))</a>
<a name="ln674">		return NULL;</a>
<a name="ln675"> </a>
<a name="ln676">	return new ActivityView(archive);</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679"> </a>
<a name="ln680">status_t</a>
<a name="ln681">ActivityView::SaveState(BMessage&amp; state) const</a>
<a name="ln682">{</a>
<a name="ln683">	status_t status = state.AddBool(&quot;show legend&quot;, fShowLegend);</a>
<a name="ln684">	if (status != B_OK)</a>
<a name="ln685">		return status;</a>
<a name="ln686"> </a>
<a name="ln687">	status = state.AddInt64(&quot;refresh interval&quot;, fRefreshInterval);</a>
<a name="ln688">	if (status != B_OK)</a>
<a name="ln689">		return status;</a>
<a name="ln690"> </a>
<a name="ln691">	status = state.AddData(&quot;history background color&quot;, B_RGB_COLOR_TYPE,</a>
<a name="ln692">		&amp;fHistoryBackgroundColor, sizeof(rgb_color));</a>
<a name="ln693">	if (status != B_OK)</a>
<a name="ln694">		return status;</a>
<a name="ln695"> </a>
<a name="ln696">	for (int32 i = 0; i &lt; fSources.CountItems(); i++) {</a>
<a name="ln697">		DataSource* source = fSources.ItemAt(i);</a>
<a name="ln698"> </a>
<a name="ln699">		if (!source-&gt;PerCPU() || source-&gt;CPU() == 0)</a>
<a name="ln700">			status = state.AddString(&quot;source&quot;, source-&gt;InternalName());</a>
<a name="ln701">		if (status != B_OK)</a>
<a name="ln702">			return status;</a>
<a name="ln703"> </a>
<a name="ln704">		BString name = source-&gt;Name();</a>
<a name="ln705">		name &lt;&lt; &quot; color&quot;;</a>
<a name="ln706">		rgb_color color = source-&gt;Color();</a>
<a name="ln707">		state.AddData(name.String(), B_RGB_COLOR_TYPE, &amp;color,</a>
<a name="ln708">			sizeof(rgb_color));</a>
<a name="ln709">	}</a>
<a name="ln710">	return B_OK;</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">Scale*</a>
<a name="ln715">ActivityView::_ScaleFor(scale_type type)</a>
<a name="ln716">{</a>
<a name="ln717">	if (type == kNoScale)</a>
<a name="ln718">		return NULL;</a>
<a name="ln719"> </a>
<a name="ln720">	std::map&lt;scale_type, ::Scale*&gt;::iterator iterator = fScales.find(type);</a>
<a name="ln721">	if (iterator != fScales.end())</a>
<a name="ln722">		return iterator-&gt;second;</a>
<a name="ln723"> </a>
<a name="ln724">	// add new scale</a>
<a name="ln725">	::Scale* scale = new ::Scale(type);</a>
<a name="ln726">	fScales[type] = scale;</a>
<a name="ln727"> </a>
<a name="ln728">	return scale;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731"> </a>
<a name="ln732">#ifdef __HAIKU__</a>
<a name="ln733">BLayoutItem*</a>
<a name="ln734">ActivityView::CreateHistoryLayoutItem()</a>
<a name="ln735">{</a>
<a name="ln736">	if (fHistoryLayoutItem == NULL)</a>
<a name="ln737">		fHistoryLayoutItem = new HistoryLayoutItem(this);</a>
<a name="ln738"> </a>
<a name="ln739">	return fHistoryLayoutItem;</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742"> </a>
<a name="ln743">BLayoutItem*</a>
<a name="ln744">ActivityView::CreateLegendLayoutItem()</a>
<a name="ln745">{</a>
<a name="ln746">	if (fLegendLayoutItem == NULL)</a>
<a name="ln747">		fLegendLayoutItem = new LegendLayoutItem(this);</a>
<a name="ln748"> </a>
<a name="ln749">	return fLegendLayoutItem;</a>
<a name="ln750">}</a>
<a name="ln751">#endif</a>
<a name="ln752"> </a>
<a name="ln753"> </a>
<a name="ln754">DataSource*</a>
<a name="ln755">ActivityView::FindDataSource(const DataSource* search)</a>
<a name="ln756">{</a>
<a name="ln757">	BAutolock _(fSourcesLock);</a>
<a name="ln758"> </a>
<a name="ln759">	for (int32 i = fSources.CountItems(); i-- &gt; 0;) {</a>
<a name="ln760">		DataSource* source = fSources.ItemAt(i);</a>
<a name="ln761">		if (!strcmp(source-&gt;Name(), search-&gt;Name()))</a>
<a name="ln762">			return source;</a>
<a name="ln763">	}</a>
<a name="ln764"> </a>
<a name="ln765">	return NULL;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">status_t</a>
<a name="ln770">ActivityView::AddDataSource(const DataSource* source, const BMessage* state)</a>
<a name="ln771">{</a>
<a name="ln772">	if (source == NULL)</a>
<a name="ln773">		return B_BAD_VALUE;</a>
<a name="ln774"> </a>
<a name="ln775">	BAutolock _(fSourcesLock);</a>
<a name="ln776"> </a>
<a name="ln777">	// Search for the correct insert spot to maintain the order of the sources</a>
<a name="ln778">	int32 insert = DataSource::IndexOf(source);</a>
<a name="ln779">	for (int32 i = 0; i &lt; fSources.CountItems() &amp;&amp; i &lt; insert; i++) {</a>
<a name="ln780">		DataSource* before = fSources.ItemAt(i);</a>
<a name="ln781">		if (DataSource::IndexOf(before) &gt; insert) {</a>
<a name="ln782">			insert = i;</a>
<a name="ln783">			break;</a>
<a name="ln784">		}</a>
<a name="ln785">	}</a>
<a name="ln786">	if (insert &gt; fSources.CountItems())</a>
<a name="ln787">		insert = fSources.CountItems();</a>
<a name="ln788"> </a>
<a name="ln789">	// Generate DataHistory and ViewHistory objects for the source</a>
<a name="ln790">	// (one might need one history per CPU)</a>
<a name="ln791"> </a>
<a name="ln792">	uint32 count = 1;</a>
<a name="ln793">	if (source-&gt;PerCPU()) {</a>
<a name="ln794">		SystemInfo info;</a>
<a name="ln795">		count = info.CPUCount();</a>
<a name="ln796">	}</a>
<a name="ln797"> </a>
<a name="ln798">	for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln799">		DataHistory* values = new(std::nothrow) DataHistory(10 * 60000000LL,</a>
<a name="ln800">			RefreshInterval());</a>
<a name="ln801">		ListAddDeleter&lt;DataHistory&gt; valuesDeleter(fValues, values, insert);</a>
<a name="ln802"> </a>
<a name="ln803">		ViewHistory* viewValues = new(std::nothrow) ViewHistory;</a>
<a name="ln804">		ListAddDeleter&lt;ViewHistory&gt; viewValuesDeleter(fViewValues, viewValues,</a>
<a name="ln805">			insert);</a>
<a name="ln806"> </a>
<a name="ln807">		if (valuesDeleter.Failed() || viewValuesDeleter.Failed())</a>
<a name="ln808">			return B_NO_MEMORY;</a>
<a name="ln809"> </a>
<a name="ln810">		values-&gt;SetScale(_ScaleFor(source-&gt;ScaleType()));</a>
<a name="ln811"> </a>
<a name="ln812">		DataSource* copy;</a>
<a name="ln813">		if (source-&gt;PerCPU())</a>
<a name="ln814">			copy = source-&gt;CopyForCPU(i);</a>
<a name="ln815">		else</a>
<a name="ln816">			copy = source-&gt;Copy();</a>
<a name="ln817"> </a>
<a name="ln818">		ListAddDeleter&lt;DataSource&gt; sourceDeleter(fSources, copy, insert);</a>
<a name="ln819">		if (sourceDeleter.Failed())</a>
<a name="ln820">			return B_NO_MEMORY;</a>
<a name="ln821"> </a>
<a name="ln822">		BString colorName = source-&gt;Name();</a>
<a name="ln823">		colorName &lt;&lt; &quot; color&quot;;</a>
<a name="ln824">		if (state != NULL) {</a>
<a name="ln825">			const rgb_color* color = NULL;</a>
<a name="ln826">			ssize_t colorLength;</a>
<a name="ln827">			if (state-&gt;FindData(colorName.String(), B_RGB_COLOR_TYPE, i,</a>
<a name="ln828">					(const void**)&amp;color, &amp;colorLength) == B_OK</a>
<a name="ln829">				&amp;&amp; colorLength == sizeof(rgb_color))</a>
<a name="ln830">				copy-&gt;SetColor(*color);</a>
<a name="ln831">		}</a>
<a name="ln832"> </a>
<a name="ln833">		valuesDeleter.Detach();</a>
<a name="ln834">		viewValuesDeleter.Detach();</a>
<a name="ln835">		sourceDeleter.Detach();</a>
<a name="ln836">		insert++;</a>
<a name="ln837">	}</a>
<a name="ln838"> </a>
<a name="ln839">#ifdef __HAIKU__</a>
<a name="ln840">	InvalidateLayout();</a>
<a name="ln841">#endif</a>
<a name="ln842">	return B_OK;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845"> </a>
<a name="ln846">status_t</a>
<a name="ln847">ActivityView::RemoveDataSource(const DataSource* remove)</a>
<a name="ln848">{</a>
<a name="ln849">	bool removed = false;</a>
<a name="ln850"> </a>
<a name="ln851">	BAutolock _(fSourcesLock);</a>
<a name="ln852"> </a>
<a name="ln853">	while (true) {</a>
<a name="ln854">		DataSource* source = FindDataSource(remove);</a>
<a name="ln855">		if (source == NULL) {</a>
<a name="ln856">			if (removed)</a>
<a name="ln857">				break;</a>
<a name="ln858">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln859">		}</a>
<a name="ln860"> </a>
<a name="ln861">		int32 index = fSources.IndexOf(source);</a>
<a name="ln862">		if (index &lt; 0)</a>
<a name="ln863">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln864"> </a>
<a name="ln865">		fSources.RemoveItemAt(index);</a>
<a name="ln866">		delete source;</a>
<a name="ln867">		DataHistory* values = fValues.RemoveItemAt(index);</a>
<a name="ln868">		delete values;</a>
<a name="ln869">		removed = true;</a>
<a name="ln870">	}</a>
<a name="ln871"> </a>
<a name="ln872">#ifdef __HAIKU__</a>
<a name="ln873">	InvalidateLayout();</a>
<a name="ln874">#endif</a>
<a name="ln875">	return B_OK;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878"> </a>
<a name="ln879">void</a>
<a name="ln880">ActivityView::RemoveAllDataSources()</a>
<a name="ln881">{</a>
<a name="ln882">	BAutolock _(fSourcesLock);</a>
<a name="ln883"> </a>
<a name="ln884">	fSources.MakeEmpty();</a>
<a name="ln885">	fValues.MakeEmpty();</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888"> </a>
<a name="ln889">void</a>
<a name="ln890">ActivityView::AttachedToWindow()</a>
<a name="ln891">{</a>
<a name="ln892">	Looper()-&gt;AddHandler(fSystemInfoHandler);</a>
<a name="ln893">	fSystemInfoHandler-&gt;StartWatching();</a>
<a name="ln894"> </a>
<a name="ln895">	fRefreshSem = create_sem(0, &quot;refresh sem&quot;);</a>
<a name="ln896">	fRefreshThread = spawn_thread(&amp;_RefreshThread, &quot;source refresh&quot;,</a>
<a name="ln897">		B_URGENT_DISPLAY_PRIORITY, this);</a>
<a name="ln898">	resume_thread(fRefreshThread);</a>
<a name="ln899"> </a>
<a name="ln900">	FrameResized(Bounds().Width(), Bounds().Height());</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903"> </a>
<a name="ln904">void</a>
<a name="ln905">ActivityView::DetachedFromWindow()</a>
<a name="ln906">{</a>
<a name="ln907">	fSystemInfoHandler-&gt;StopWatching();</a>
<a name="ln908">	Looper()-&gt;RemoveHandler(fSystemInfoHandler);</a>
<a name="ln909"> </a>
<a name="ln910">	delete_sem(fRefreshSem);</a>
<a name="ln911">	wait_for_thread(fRefreshThread, NULL);</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914"> </a>
<a name="ln915">#ifdef __HAIKU__</a>
<a name="ln916">BSize</a>
<a name="ln917">ActivityView::MinSize()</a>
<a name="ln918">{</a>
<a name="ln919">	BSize size(32, 32);</a>
<a name="ln920">	if (fShowLegend)</a>
<a name="ln921">		size.height = _LegendHeight();</a>
<a name="ln922"> </a>
<a name="ln923">	return size;</a>
<a name="ln924">}</a>
<a name="ln925">#endif</a>
<a name="ln926"> </a>
<a name="ln927"> </a>
<a name="ln928">void</a>
<a name="ln929">ActivityView::FrameResized(float /*width*/, float /*height*/)</a>
<a name="ln930">{</a>
<a name="ln931">	_UpdateOffscreenBitmap();</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934"> </a>
<a name="ln935">void</a>
<a name="ln936">ActivityView::_UpdateOffscreenBitmap()</a>
<a name="ln937">{</a>
<a name="ln938">	BRect frame = _HistoryFrame();</a>
<a name="ln939">	frame.OffsetTo(B_ORIGIN);</a>
<a name="ln940"> </a>
<a name="ln941">	if (fOffscreen != NULL &amp;&amp; frame == fOffscreen-&gt;Bounds())</a>
<a name="ln942">		return;</a>
<a name="ln943"> </a>
<a name="ln944">	delete fOffscreen;</a>
<a name="ln945"> </a>
<a name="ln946">	// create offscreen bitmap</a>
<a name="ln947"> </a>
<a name="ln948">	fOffscreen = new(std::nothrow) BBitmap(frame, B_BITMAP_ACCEPTS_VIEWS,</a>
<a name="ln949">		B_RGB32);</a>
<a name="ln950">	if (fOffscreen == NULL || fOffscreen-&gt;InitCheck() != B_OK) {</a>
<a name="ln951">		delete fOffscreen;</a>
<a name="ln952">		fOffscreen = NULL;</a>
<a name="ln953">		return;</a>
<a name="ln954">	}</a>
<a name="ln955"> </a>
<a name="ln956">	BView* view = new BView(frame, NULL, B_FOLLOW_NONE, B_SUBPIXEL_PRECISE);</a>
<a name="ln957">	view-&gt;SetViewColor(fHistoryBackgroundColor);</a>
<a name="ln958">	view-&gt;SetLowColor(view-&gt;ViewColor());</a>
<a name="ln959">	fOffscreen-&gt;AddChild(view);</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962"> </a>
<a name="ln963">BView*</a>
<a name="ln964">ActivityView::_OffscreenView()</a>
<a name="ln965">{</a>
<a name="ln966">	if (fOffscreen == NULL)</a>
<a name="ln967">		return NULL;</a>
<a name="ln968"> </a>
<a name="ln969">	return fOffscreen-&gt;ChildAt(0);</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972"> </a>
<a name="ln973">void</a>
<a name="ln974">ActivityView::MouseDown(BPoint where)</a>
<a name="ln975">{</a>
<a name="ln976">	int32 buttons = B_SECONDARY_MOUSE_BUTTON;</a>
<a name="ln977">	if (Looper() != NULL &amp;&amp; Looper()-&gt;CurrentMessage() != NULL)</a>
<a name="ln978">		Looper()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons);</a>
<a name="ln979"> </a>
<a name="ln980">	if (buttons == B_PRIMARY_MOUSE_BUTTON) {</a>
<a name="ln981">		fZoomPoint = where;</a>
<a name="ln982">		fOriginalResolution = fDrawResolution;</a>
<a name="ln983">		fZooming = true;</a>
<a name="ln984">		SetMouseEventMask(B_POINTER_EVENTS);</a>
<a name="ln985">		return;</a>
<a name="ln986">	}</a>
<a name="ln987"> </a>
<a name="ln988">	BPopUpMenu *menu = new BPopUpMenu(B_EMPTY_STRING, false, false);</a>
<a name="ln989">	menu-&gt;SetFont(be_plain_font);</a>
<a name="ln990"> </a>
<a name="ln991">	BMenu* additionalMenu = new BMenu(B_TRANSLATE(&quot;Additional items&quot;));</a>
<a name="ln992">	additionalMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln993"> </a>
<a name="ln994">	SystemInfo info;</a>
<a name="ln995">	BMenuItem* item;</a>
<a name="ln996"> </a>
<a name="ln997">	for (int32 i = 0; i &lt; DataSource::CountSources(); i++) {</a>
<a name="ln998">		const DataSource* source = DataSource::SourceAt(i);</a>
<a name="ln999"> </a>
<a name="ln1000">		if (source-&gt;MultiCPUOnly() &amp;&amp; info.CPUCount() == 1)</a>
<a name="ln1001">			continue;</a>
<a name="ln1002"> </a>
<a name="ln1003">		BMessage* message = new BMessage(kMsgToggleDataSource);</a>
<a name="ln1004">		message-&gt;AddInt32(&quot;index&quot;, i);</a>
<a name="ln1005"> </a>
<a name="ln1006">		item = new BMenuItem(source-&gt;Name(), message);</a>
<a name="ln1007">		if (FindDataSource(source))</a>
<a name="ln1008">			item-&gt;SetMarked(true);</a>
<a name="ln1009"> </a>
<a name="ln1010">		if (source-&gt;Primary())</a>
<a name="ln1011">			menu-&gt;AddItem(item);</a>
<a name="ln1012">		else</a>
<a name="ln1013">			additionalMenu-&gt;AddItem(item);</a>
<a name="ln1014">	}</a>
<a name="ln1015"> </a>
<a name="ln1016">	menu-&gt;AddItem(new BMenuItem(additionalMenu));</a>
<a name="ln1017">	menu-&gt;AddSeparatorItem();</a>
<a name="ln1018">	menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Show legend&quot;),</a>
<a name="ln1019">		new BMessage(kMsgToggleLegend)));</a>
<a name="ln1020">	item-&gt;SetMarked(fShowLegend);</a>
<a name="ln1021"> </a>
<a name="ln1022">	menu-&gt;SetTargetForItems(this);</a>
<a name="ln1023">	additionalMenu-&gt;SetTargetForItems(this);</a>
<a name="ln1024"> </a>
<a name="ln1025">	ActivityWindow* window = dynamic_cast&lt;ActivityWindow*&gt;(Window());</a>
<a name="ln1026">	if (window != NULL &amp;&amp; window-&gt;ActivityViewCount() &gt; 1) {</a>
<a name="ln1027">		menu-&gt;AddSeparatorItem();</a>
<a name="ln1028">		BMessage* message = new BMessage(kMsgRemoveView);</a>
<a name="ln1029">		message-&gt;AddPointer(&quot;view&quot;, this);</a>
<a name="ln1030">		menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Remove graph&quot;),</a>
<a name="ln1031">			message));</a>
<a name="ln1032">		item-&gt;SetTarget(window);</a>
<a name="ln1033">	}</a>
<a name="ln1034"> </a>
<a name="ln1035">	ConvertToScreen(&amp;where);</a>
<a name="ln1036">	menu-&gt;Go(where, true, false, true);</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">void</a>
<a name="ln1041">ActivityView::MouseUp(BPoint where)</a>
<a name="ln1042">{</a>
<a name="ln1043">	fZooming = false;</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046"> </a>
<a name="ln1047">void</a>
<a name="ln1048">ActivityView::MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln1049">	const BMessage* dragMessage)</a>
<a name="ln1050">{</a>
<a name="ln1051">	if (!fZooming)</a>
<a name="ln1052">		return;</a>
<a name="ln1053"> </a>
<a name="ln1054">	int32 shift = int32(where.x - fZoomPoint.x) / 25;</a>
<a name="ln1055">	int32 resolution;</a>
<a name="ln1056">	if (shift &gt; 0)</a>
<a name="ln1057">		resolution = fOriginalResolution &lt;&lt; shift;</a>
<a name="ln1058">	else</a>
<a name="ln1059">		resolution = fOriginalResolution &gt;&gt; -shift;</a>
<a name="ln1060"> </a>
<a name="ln1061">	_UpdateResolution(resolution);</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064"> </a>
<a name="ln1065">void</a>
<a name="ln1066">ActivityView::MessageReceived(BMessage* message)</a>
<a name="ln1067">{</a>
<a name="ln1068">	// if a color is dropped, use it as background</a>
<a name="ln1069">	if (message-&gt;WasDropped()) {</a>
<a name="ln1070">		rgb_color* color;</a>
<a name="ln1071">		ssize_t size;</a>
<a name="ln1072">		if (message-&gt;FindData(&quot;RGBColor&quot;, B_RGB_COLOR_TYPE, 0,</a>
<a name="ln1073">				(const void**)&amp;color, &amp;size) == B_OK</a>
<a name="ln1074">			&amp;&amp; size == sizeof(rgb_color)) {</a>
<a name="ln1075">			BPoint dropPoint = message-&gt;DropPoint();</a>
<a name="ln1076">			ConvertFromScreen(&amp;dropPoint);</a>
<a name="ln1077"> </a>
<a name="ln1078">			if (_HistoryFrame().Contains(dropPoint)) {</a>
<a name="ln1079">				fHistoryBackgroundColor = *color;</a>
<a name="ln1080">				Invalidate(_HistoryFrame());</a>
<a name="ln1081">			} else {</a>
<a name="ln1082">				// check each legend color box</a>
<a name="ln1083">				BAutolock _(fSourcesLock);</a>
<a name="ln1084"> </a>
<a name="ln1085">				BRect legendFrame = _LegendFrame();</a>
<a name="ln1086">				for (int32 i = 0; i &lt; fSources.CountItems(); i++) {</a>
<a name="ln1087">					BRect frame = _LegendColorFrameAt(legendFrame, i);</a>
<a name="ln1088">					if (frame.Contains(dropPoint)) {</a>
<a name="ln1089">						fSources.ItemAt(i)-&gt;SetColor(*color);</a>
<a name="ln1090">						Invalidate(_HistoryFrame());</a>
<a name="ln1091">						Invalidate(frame);</a>
<a name="ln1092">						return;</a>
<a name="ln1093">					}</a>
<a name="ln1094">				}</a>
<a name="ln1095"> </a>
<a name="ln1096">				if (dynamic_cast&lt;ActivityMonitor*&gt;(be_app) == NULL) {</a>
<a name="ln1097">					// allow background color change in the replicant only</a>
<a name="ln1098">					fLegendBackgroundColor = *color;</a>
<a name="ln1099">					SetLowColor(fLegendBackgroundColor);</a>
<a name="ln1100">					Invalidate(legendFrame);</a>
<a name="ln1101">				}</a>
<a name="ln1102">			}</a>
<a name="ln1103">			return;</a>
<a name="ln1104">		}</a>
<a name="ln1105">	}</a>
<a name="ln1106"> </a>
<a name="ln1107">	switch (message-&gt;what) {</a>
<a name="ln1108">		case B_ABOUT_REQUESTED:</a>
<a name="ln1109">		{</a>
<a name="ln1110">			BAboutWindow* window = new BAboutWindow(kAppName, kSignature);</a>
<a name="ln1111"> </a>
<a name="ln1112">			const char* authors[] = {</a>
<a name="ln1113">				&quot;Axel DÃ¶rfler&quot;,</a>
<a name="ln1114">				NULL</a>
<a name="ln1115">			};</a>
<a name="ln1116"> </a>
<a name="ln1117">			window-&gt;AddCopyright(2008, &quot;Haiku, Inc.&quot;);</a>
<a name="ln1118">			window-&gt;AddAuthors(authors);</a>
<a name="ln1119"> </a>
<a name="ln1120">			window-&gt;Show();</a>
<a name="ln1121"> </a>
<a name="ln1122">			break;</a>
<a name="ln1123">		}</a>
<a name="ln1124">		case kMsgUpdateResolution:</a>
<a name="ln1125">		{</a>
<a name="ln1126">			int32 resolution;</a>
<a name="ln1127">			if (message-&gt;FindInt32(&quot;resolution&quot;, &amp;resolution) != B_OK)</a>
<a name="ln1128">				break;</a>
<a name="ln1129"> </a>
<a name="ln1130">			_UpdateResolution(resolution, false);</a>
<a name="ln1131">			break;</a>
<a name="ln1132">		}</a>
<a name="ln1133"> </a>
<a name="ln1134">		case kMsgTimeIntervalUpdated:</a>
<a name="ln1135">			bigtime_t interval;</a>
<a name="ln1136">			if (message-&gt;FindInt64(&quot;interval&quot;, &amp;interval) != B_OK)</a>
<a name="ln1137">				break;</a>
<a name="ln1138"> </a>
<a name="ln1139">			if (interval &lt; 10000)</a>
<a name="ln1140">				interval = 10000;</a>
<a name="ln1141"> </a>
<a name="ln1142">			atomic_set64(&amp;fRefreshInterval, interval);</a>
<a name="ln1143">			break;</a>
<a name="ln1144"> </a>
<a name="ln1145">		case kMsgToggleDataSource:</a>
<a name="ln1146">		{</a>
<a name="ln1147">			int32 index;</a>
<a name="ln1148">			if (message-&gt;FindInt32(&quot;index&quot;, &amp;index) != B_OK)</a>
<a name="ln1149">				break;</a>
<a name="ln1150"> </a>
<a name="ln1151">			const DataSource* baseSource = DataSource::SourceAt(index);</a>
<a name="ln1152">			if (baseSource == NULL)</a>
<a name="ln1153">				break;</a>
<a name="ln1154"> </a>
<a name="ln1155">			DataSource* source = FindDataSource(baseSource);</a>
<a name="ln1156">			if (source == NULL)</a>
<a name="ln1157">				AddDataSource(baseSource);</a>
<a name="ln1158">			else</a>
<a name="ln1159">				RemoveDataSource(baseSource);</a>
<a name="ln1160"> </a>
<a name="ln1161">			Invalidate();</a>
<a name="ln1162">			break;</a>
<a name="ln1163">		}</a>
<a name="ln1164"> </a>
<a name="ln1165">		case kMsgToggleLegend:</a>
<a name="ln1166">			fShowLegend = !fShowLegend;</a>
<a name="ln1167">			Invalidate();</a>
<a name="ln1168">			break;</a>
<a name="ln1169"> </a>
<a name="ln1170">		case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln1171">		{</a>
<a name="ln1172">			float deltaY = 0.0f;</a>
<a name="ln1173">			if (message-&gt;FindFloat(&quot;be:wheel_delta_y&quot;, &amp;deltaY) != B_OK</a>
<a name="ln1174">				|| deltaY == 0.0f)</a>
<a name="ln1175">				break;</a>
<a name="ln1176"> </a>
<a name="ln1177">			int32 resolution = fDrawResolution;</a>
<a name="ln1178">			if (deltaY &gt; 0)</a>
<a name="ln1179">				resolution *= 2;</a>
<a name="ln1180">			else</a>
<a name="ln1181">				resolution /= 2;</a>
<a name="ln1182"> </a>
<a name="ln1183">			_UpdateResolution(resolution);</a>
<a name="ln1184">			break;</a>
<a name="ln1185">		}</a>
<a name="ln1186"> </a>
<a name="ln1187">		default:</a>
<a name="ln1188">			BView::MessageReceived(message);</a>
<a name="ln1189">			break;</a>
<a name="ln1190">	}</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193"> </a>
<a name="ln1194">void</a>
<a name="ln1195">ActivityView::_UpdateFrame()</a>
<a name="ln1196">{</a>
<a name="ln1197">#ifdef __HAIKU__</a>
<a name="ln1198">	if (fLegendLayoutItem == NULL || fHistoryLayoutItem == NULL)</a>
<a name="ln1199">		return;</a>
<a name="ln1200"> </a>
<a name="ln1201">	BRect historyFrame = fHistoryLayoutItem-&gt;Frame();</a>
<a name="ln1202">	BRect legendFrame = fLegendLayoutItem-&gt;Frame();</a>
<a name="ln1203">#else</a>
<a name="ln1204">	BRect historyFrame = Bounds();</a>
<a name="ln1205">	BRect legendFrame = Bounds();</a>
<a name="ln1206">	historyFrame.bottom -= 2 * Bounds().Height() / 3;</a>
<a name="ln1207">	legendFrame.top += Bounds().Height() / 3;</a>
<a name="ln1208">#endif</a>
<a name="ln1209">	MoveTo(historyFrame.left, historyFrame.top);</a>
<a name="ln1210">	ResizeTo(legendFrame.left + legendFrame.Width() - historyFrame.left,</a>
<a name="ln1211">		legendFrame.top + legendFrame.Height() - historyFrame.top);</a>
<a name="ln1212">}</a>
<a name="ln1213"> </a>
<a name="ln1214"> </a>
<a name="ln1215">BRect</a>
<a name="ln1216">ActivityView::_HistoryFrame() const</a>
<a name="ln1217">{</a>
<a name="ln1218">	BRect frame = Bounds();</a>
<a name="ln1219"> </a>
<a name="ln1220">	if (fShowLegend) {</a>
<a name="ln1221">		BRect legendFrame = _LegendFrame();</a>
<a name="ln1222">		frame.bottom = legendFrame.top - 1;</a>
<a name="ln1223">	}</a>
<a name="ln1224"> </a>
<a name="ln1225">	frame.InsetBy(2, 2);</a>
<a name="ln1226"> </a>
<a name="ln1227">	return frame;</a>
<a name="ln1228">}</a>
<a name="ln1229"> </a>
<a name="ln1230"> </a>
<a name="ln1231">float</a>
<a name="ln1232">ActivityView::_LegendHeight() const</a>
<a name="ln1233">{</a>
<a name="ln1234">	font_height fontHeight;</a>
<a name="ln1235">	GetFontHeight(&amp;fontHeight);</a>
<a name="ln1236"> </a>
<a name="ln1237">	BAutolock _(fSourcesLock);</a>
<a name="ln1238"> </a>
<a name="ln1239">	int32 rows = (fSources.CountItems() + 1) / 2;</a>
<a name="ln1240"> </a>
<a name="ln1241">	int32 boldMargin = Parent()</a>
<a name="ln1242">		&amp;&amp; (Parent()-&gt;Flags() &amp; B_DRAW_ON_CHILDREN) != 0 ? 2 : 0;</a>
<a name="ln1243"> </a>
<a name="ln1244">	return rows * (4 + ceilf(fontHeight.ascent)</a>
<a name="ln1245">		+ ceilf(fontHeight.descent) + ceilf(fontHeight.leading)) + boldMargin;</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248"> </a>
<a name="ln1249">BRect</a>
<a name="ln1250">ActivityView::_LegendFrame() const</a>
<a name="ln1251">{</a>
<a name="ln1252">	float height;</a>
<a name="ln1253">#ifdef __HAIKU__</a>
<a name="ln1254">	if (fLegendLayoutItem != NULL)</a>
<a name="ln1255">		height = fLegendLayoutItem-&gt;Frame().Height();</a>
<a name="ln1256">	else</a>
<a name="ln1257">#endif</a>
<a name="ln1258">		height = _LegendHeight();</a>
<a name="ln1259"> </a>
<a name="ln1260">	BRect frame = Bounds();</a>
<a name="ln1261">	frame.bottom -= kDraggerSize;</a>
<a name="ln1262">	frame.top = frame.bottom - height;</a>
<a name="ln1263"> </a>
<a name="ln1264">	return frame;</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267"> </a>
<a name="ln1268">BRect</a>
<a name="ln1269">ActivityView::_LegendFrameAt(BRect frame, int32 index) const</a>
<a name="ln1270">{</a>
<a name="ln1271">	int32 column = index &amp; 1;</a>
<a name="ln1272">	int32 row = index / 2;</a>
<a name="ln1273">	if (column == 0) {</a>
<a name="ln1274">		// Use the full width if there is only one item</a>
<a name="ln1275">		if (fSources.CountItems() != 1)</a>
<a name="ln1276">			frame.right = frame.left + floorf(frame.Width() / 2) - 5;</a>
<a name="ln1277">	} else</a>
<a name="ln1278">		frame.left = frame.right - floorf(frame.Width() / 2) + 5;</a>
<a name="ln1279"> </a>
<a name="ln1280">	BAutolock _(fSourcesLock);</a>
<a name="ln1281"> </a>
<a name="ln1282">	int32 rows = (fSources.CountItems() + 1) / 2;</a>
<a name="ln1283">	float height = floorf((frame.Height() - 5) / rows);</a>
<a name="ln1284"> </a>
<a name="ln1285">	frame.top = frame.top + 5 + row * height;</a>
<a name="ln1286">	frame.bottom = frame.top + height - 1;</a>
<a name="ln1287"> </a>
<a name="ln1288">	return frame;</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291"> </a>
<a name="ln1292">BRect</a>
<a name="ln1293">ActivityView::_LegendColorFrameAt(BRect frame, int32 index) const</a>
<a name="ln1294">{</a>
<a name="ln1295">	frame = _LegendFrameAt(frame, index);</a>
<a name="ln1296">	frame.InsetBy(1, 1);</a>
<a name="ln1297">	frame.right = frame.left + frame.Height();</a>
<a name="ln1298"> </a>
<a name="ln1299">	return frame;</a>
<a name="ln1300">}</a>
<a name="ln1301"> </a>
<a name="ln1302"> </a>
<a name="ln1303">float</a>
<a name="ln1304">ActivityView::_PositionForValue(DataSource* source, DataHistory* values,</a>
<a name="ln1305">	int64 value)</a>
<a name="ln1306">{</a>
<a name="ln1307">	int64 min = source-&gt;Minimum();</a>
<a name="ln1308">	int64 max = source-&gt;Maximum();</a>
<a name="ln1309">	if (source-&gt;AdaptiveScale()) {</a>
<a name="ln1310">		int64 adaptiveMax = int64(values-&gt;MaximumValue() * 1.2);</a>
<a name="ln1311">		if (adaptiveMax &lt; max)</a>
<a name="ln1312">			max = adaptiveMax;</a>
<a name="ln1313">	}</a>
<a name="ln1314"> </a>
<a name="ln1315">	if (value &gt; max)</a>
<a name="ln1316">		value = max;</a>
<a name="ln1317">	if (value &lt; min)</a>
<a name="ln1318">		value = min;</a>
<a name="ln1319"> </a>
<a name="ln1320">	float height = _HistoryFrame().Height();</a>
<a name="ln1321">	return height - (value - min) * height / (max - min);</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324"> </a>
<a name="ln1325">void</a>
<a name="ln1326">ActivityView::_DrawHistory(bool drawBackground)</a>
<a name="ln1327">{</a>
<a name="ln1328">	_UpdateOffscreenBitmap();</a>
<a name="ln1329"> </a>
<a name="ln1330">	BView* view = this;</a>
<a name="ln1331">	if (fOffscreen != NULL) {</a>
<a name="ln1332">		fOffscreen-&gt;Lock();</a>
<a name="ln1333">		view = _OffscreenView();</a>
<a name="ln1334">	}</a>
<a name="ln1335"> </a>
<a name="ln1336">	BRect frame = _HistoryFrame();</a>
<a name="ln1337">	BRect outerFrame = frame.InsetByCopy(-2, -2);</a>
<a name="ln1338"> </a>
<a name="ln1339">	// draw the outer frame</a>
<a name="ln1340">	uint32 flags = 0;</a>
<a name="ln1341">	if (!drawBackground)</a>
<a name="ln1342">		flags |= BControlLook::B_BLEND_FRAME;</a>
<a name="ln1343">	be_control_look-&gt;DrawTextControlBorder(this, outerFrame,</a>
<a name="ln1344">		outerFrame, fLegendBackgroundColor, flags);</a>
<a name="ln1345"> </a>
<a name="ln1346">	// convert to offscreen view if necessary</a>
<a name="ln1347">	if (view != this)</a>
<a name="ln1348">		frame.OffsetTo(B_ORIGIN);</a>
<a name="ln1349"> </a>
<a name="ln1350">	view-&gt;SetLowColor(fHistoryBackgroundColor);</a>
<a name="ln1351">	view-&gt;FillRect(frame, B_SOLID_LOW);</a>
<a name="ln1352"> </a>
<a name="ln1353">	uint32 step = 2;</a>
<a name="ln1354">	uint32 resolution = fDrawResolution;</a>
<a name="ln1355">	if (fDrawResolution &gt; 1) {</a>
<a name="ln1356">		step = 1;</a>
<a name="ln1357">		resolution--;</a>
<a name="ln1358">	}</a>
<a name="ln1359"> </a>
<a name="ln1360">	// We would get a negative number of steps which isn't a good idea.</a>
<a name="ln1361">	if (frame.IntegerWidth() &lt;= 10)</a>
<a name="ln1362">		return;</a>
<a name="ln1363"> </a>
<a name="ln1364">	uint32 width = frame.IntegerWidth() - 10;</a>
<a name="ln1365">	uint32 steps = width / step;</a>
<a name="ln1366">	bigtime_t timeStep = RefreshInterval() * resolution;</a>
<a name="ln1367">	bigtime_t now = system_time();</a>
<a name="ln1368"> </a>
<a name="ln1369">	// Draw scale</a>
<a name="ln1370">	// TODO: add second markers?</a>
<a name="ln1371"> </a>
<a name="ln1372">	view-&gt;SetPenSize(1);</a>
<a name="ln1373"> </a>
<a name="ln1374">	rgb_color scaleColor = view-&gt;LowColor();</a>
<a name="ln1375">	uint32 average = (scaleColor.red + scaleColor.green + scaleColor.blue) / 3;</a>
<a name="ln1376">	if (average &lt; 96)</a>
<a name="ln1377">		scaleColor = tint_color(scaleColor, B_LIGHTEN_2_TINT);</a>
<a name="ln1378">	else</a>
<a name="ln1379">		scaleColor = tint_color(scaleColor, B_DARKEN_2_TINT);</a>
<a name="ln1380"> </a>
<a name="ln1381">	view-&gt;SetHighColor(scaleColor);</a>
<a name="ln1382">	view-&gt;StrokeLine(BPoint(frame.left, frame.top + frame.Height() / 2),</a>
<a name="ln1383">		BPoint(frame.right, frame.top + frame.Height() / 2));</a>
<a name="ln1384"> </a>
<a name="ln1385">	// Draw values</a>
<a name="ln1386"> </a>
<a name="ln1387">	view-&gt;SetPenSize(1.5);</a>
<a name="ln1388">	BAutolock _(fSourcesLock);</a>
<a name="ln1389"> </a>
<a name="ln1390">	for (uint32 i = fSources.CountItems(); i-- &gt; 0;) {</a>
<a name="ln1391">		ViewHistory* viewValues = fViewValues.ItemAt(i);</a>
<a name="ln1392">		DataSource* source = fSources.ItemAt(i);</a>
<a name="ln1393">		DataHistory* values = fValues.ItemAt(i);</a>
<a name="ln1394"> </a>
<a name="ln1395">		viewValues-&gt;Update(values, steps, fDrawResolution, now, timeStep,</a>
<a name="ln1396">			RefreshInterval());</a>
<a name="ln1397"> </a>
<a name="ln1398">		if (viewValues-&gt;Start() &gt;= (int32)steps - 1)</a>
<a name="ln1399">			continue;</a>
<a name="ln1400"> </a>
<a name="ln1401">		uint32 x = viewValues-&gt;Start() * step;</a>
<a name="ln1402"> </a>
<a name="ln1403">		bool first = true;</a>
<a name="ln1404"> </a>
<a name="ln1405">		view-&gt;SetHighColor(source-&gt;Color());</a>
<a name="ln1406">		view-&gt;SetLineMode(B_BUTT_CAP, B_ROUND_JOIN);</a>
<a name="ln1407">		view-&gt;MovePenTo(B_ORIGIN);</a>
<a name="ln1408"> </a>
<a name="ln1409">		try {</a>
<a name="ln1410">			view-&gt;BeginLineArray(steps - viewValues-&gt;Start() - 1);</a>
<a name="ln1411"> </a>
<a name="ln1412">			BPoint prev;</a>
<a name="ln1413"> </a>
<a name="ln1414">			for (uint32 j = viewValues-&gt;Start(); j &lt; steps; x += step, j++) {</a>
<a name="ln1415">				float y = _PositionForValue(source, values,</a>
<a name="ln1416">					viewValues-&gt;ValueAt(j));</a>
<a name="ln1417"> </a>
<a name="ln1418">				if (first) {</a>
<a name="ln1419">					first = false;</a>
<a name="ln1420">				} else</a>
<a name="ln1421">					view-&gt;AddLine(prev, BPoint(x, y), source-&gt;Color());</a>
<a name="ln1422"> </a>
<a name="ln1423">				prev.Set(x, y);</a>
<a name="ln1424">			}</a>
<a name="ln1425"> </a>
<a name="ln1426">		} catch (std::bad_alloc&amp;) {</a>
<a name="ln1427">			// Not enough memory to allocate the line array.</a>
<a name="ln1428">			// TODO we could try to draw using the slower but less memory</a>
<a name="ln1429">			// consuming solution using StrokeLine.</a>
<a name="ln1430">		}</a>
<a name="ln1431"> </a>
<a name="ln1432">		view-&gt;EndLineArray();</a>
<a name="ln1433">	}</a>
<a name="ln1434"> </a>
<a name="ln1435">	// TODO: add marks when an app started or quit</a>
<a name="ln1436">	view-&gt;Sync();</a>
<a name="ln1437">	if (fOffscreen != NULL) {</a>
<a name="ln1438">		fOffscreen-&gt;Unlock();</a>
<a name="ln1439">		DrawBitmap(fOffscreen, outerFrame.LeftTop());</a>
<a name="ln1440">	}</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443"> </a>
<a name="ln1444">void</a>
<a name="ln1445">ActivityView::_UpdateResolution(int32 resolution, bool broadcast)</a>
<a name="ln1446">{</a>
<a name="ln1447">	if (resolution &lt; 1)</a>
<a name="ln1448">		resolution = 1;</a>
<a name="ln1449">	if (resolution &gt; 128)</a>
<a name="ln1450">		resolution = 128;</a>
<a name="ln1451"> </a>
<a name="ln1452">	if (resolution == fDrawResolution)</a>
<a name="ln1453">		return;</a>
<a name="ln1454"> </a>
<a name="ln1455">	ActivityWindow* window = dynamic_cast&lt;ActivityWindow*&gt;(Window());</a>
<a name="ln1456">	if (broadcast &amp;&amp; window != NULL) {</a>
<a name="ln1457">		BMessage update(kMsgUpdateResolution);</a>
<a name="ln1458">		update.AddInt32(&quot;resolution&quot;, resolution);</a>
<a name="ln1459">		window-&gt;BroadcastToActivityViews(&amp;update, this);</a>
<a name="ln1460">	}</a>
<a name="ln1461"> </a>
<a name="ln1462">	fDrawResolution = resolution;</a>
<a name="ln1463">	Invalidate();</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466"> </a>
<a name="ln1467">void</a>
<a name="ln1468">ActivityView::Draw(BRect updateRect)</a>
<a name="ln1469">{</a>
<a name="ln1470">	bool drawBackground = true;</a>
<a name="ln1471">	if (Parent() &amp;&amp; (Parent()-&gt;Flags() &amp; B_DRAW_ON_CHILDREN) != 0)</a>
<a name="ln1472">		drawBackground = false;</a>
<a name="ln1473"> </a>
<a name="ln1474">	_DrawHistory(drawBackground);</a>
<a name="ln1475"> </a>
<a name="ln1476">	if (!fShowLegend)</a>
<a name="ln1477">		return;</a>
<a name="ln1478"> </a>
<a name="ln1479">	// draw legend</a>
<a name="ln1480">	BRect legendFrame = _LegendFrame();</a>
<a name="ln1481">	if (LowUIColor() == B_NO_COLOR)</a>
<a name="ln1482">		SetLowColor(fLegendBackgroundColor);</a>
<a name="ln1483"> </a>
<a name="ln1484">	if (drawBackground) {</a>
<a name="ln1485">		BRect backgroundFrame(legendFrame);</a>
<a name="ln1486">		backgroundFrame.bottom += kDraggerSize;</a>
<a name="ln1487">		FillRect(backgroundFrame, B_SOLID_LOW);</a>
<a name="ln1488">	}</a>
<a name="ln1489"> </a>
<a name="ln1490">	BAutolock _(fSourcesLock);</a>
<a name="ln1491"> </a>
<a name="ln1492">	font_height fontHeight;</a>
<a name="ln1493">	GetFontHeight(&amp;fontHeight);</a>
<a name="ln1494"> </a>
<a name="ln1495">	for (int32 i = 0; i &lt; fSources.CountItems(); i++) {</a>
<a name="ln1496">		DataSource* source = fSources.ItemAt(i);</a>
<a name="ln1497">		DataHistory* values = fValues.ItemAt(i);</a>
<a name="ln1498">		BRect frame = _LegendFrameAt(legendFrame, i);</a>
<a name="ln1499"> </a>
<a name="ln1500">		// draw color box</a>
<a name="ln1501">		BRect colorBox = _LegendColorFrameAt(legendFrame, i);</a>
<a name="ln1502">		BRect rect = colorBox;</a>
<a name="ln1503">		uint32 flags = BControlLook::B_BLEND_FRAME;</a>
<a name="ln1504">		be_control_look-&gt;DrawTextControlBorder(this, rect,</a>
<a name="ln1505">			rect, fLegendBackgroundColor, flags);</a>
<a name="ln1506">		SetHighColor(source-&gt;Color());</a>
<a name="ln1507">		FillRect(rect);</a>
<a name="ln1508"> </a>
<a name="ln1509">		// show current value and label</a>
<a name="ln1510">		float y = frame.top + ceilf(fontHeight.ascent);</a>
<a name="ln1511">		int64 value = values-&gt;ValueAt(values-&gt;End());</a>
<a name="ln1512">		BString text;</a>
<a name="ln1513">		source-&gt;Print(text, value);</a>
<a name="ln1514">		float width = StringWidth(text.String());</a>
<a name="ln1515"> </a>
<a name="ln1516">		BString label = source-&gt;Label();</a>
<a name="ln1517">		float possibleLabelWidth = frame.right - colorBox.right - 12 - width;</a>
<a name="ln1518">		// TODO: TruncateString() is broken... remove + 5 when fixed!</a>
<a name="ln1519">		if (ceilf(StringWidth(label.String()) + 5) &gt; possibleLabelWidth)</a>
<a name="ln1520">			label = source-&gt;ShortLabel();</a>
<a name="ln1521">		TruncateString(&amp;label, B_TRUNCATE_MIDDLE, possibleLabelWidth);</a>
<a name="ln1522"> </a>
<a name="ln1523">		if (drawBackground)</a>
<a name="ln1524">			SetHighColor(ui_color(B_PANEL_TEXT_COLOR));</a>
<a name="ln1525"> </a>
<a name="ln1526">		if (be_control_look == NULL) {</a>
<a name="ln1527">			DrawString(label.String(), BPoint(6 + colorBox.right, y));</a>
<a name="ln1528">			DrawString(text.String(), BPoint(frame.right - width, y));</a>
<a name="ln1529">		} else {</a>
<a name="ln1530">			be_control_look-&gt;DrawLabel(this, label.String(),</a>
<a name="ln1531">				Parent()-&gt;ViewColor(), 0, BPoint(6 + colorBox.right, y));</a>
<a name="ln1532">			be_control_look-&gt;DrawLabel(this, text.String(),</a>
<a name="ln1533">				Parent()-&gt;ViewColor(), 0, BPoint(frame.right - width, y));</a>
<a name="ln1534">		}</a>
<a name="ln1535">	}</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538"> </a>
<a name="ln1539">void</a>
<a name="ln1540">ActivityView::_Refresh()</a>
<a name="ln1541">{</a>
<a name="ln1542">	bigtime_t lastTimeout = system_time() - RefreshInterval();</a>
<a name="ln1543">	BMessenger target(this);</a>
<a name="ln1544"> </a>
<a name="ln1545">	while (true) {</a>
<a name="ln1546">		status_t status = acquire_sem_etc(fRefreshSem, 1, B_ABSOLUTE_TIMEOUT,</a>
<a name="ln1547">			lastTimeout + RefreshInterval());</a>
<a name="ln1548">		if (status == B_OK || status == B_BAD_SEM_ID)</a>
<a name="ln1549">			break;</a>
<a name="ln1550">		if (status == B_INTERRUPTED)</a>
<a name="ln1551">			continue;</a>
<a name="ln1552"> </a>
<a name="ln1553">		SystemInfo info(fSystemInfoHandler);</a>
<a name="ln1554">		lastTimeout += RefreshInterval();</a>
<a name="ln1555"> </a>
<a name="ln1556">		fSourcesLock.Lock();</a>
<a name="ln1557"> </a>
<a name="ln1558">		for (uint32 i = fSources.CountItems(); i-- &gt; 0;) {</a>
<a name="ln1559">			DataSource* source = fSources.ItemAt(i);</a>
<a name="ln1560">			DataHistory* values = fValues.ItemAt(i);</a>
<a name="ln1561"> </a>
<a name="ln1562">			int64 value = source-&gt;NextValue(info);</a>
<a name="ln1563">			values-&gt;AddValue(info.Time(), value);</a>
<a name="ln1564">		}</a>
<a name="ln1565"> </a>
<a name="ln1566">		fSourcesLock.Unlock();</a>
<a name="ln1567"> </a>
<a name="ln1568">		target.SendMessage(B_INVALIDATE);</a>
<a name="ln1569">	}</a>
<a name="ln1570">}</a>
<a name="ln1571"> </a>
<a name="ln1572"> </a>
<a name="ln1573">/*static*/ status_t</a>
<a name="ln1574">ActivityView::_RefreshThread(void* self)</a>
<a name="ln1575">{</a>
<a name="ln1576">	((ActivityView*)self)-&gt;_Refresh();</a>
<a name="ln1577">	return B_OK;</a>
<a name="ln1578">}</a>

</code></pre>
<div class="balloon" rel="1037"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'menu' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1504"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'be_control_look' pointer was utilized before it was verified against nullptr. Check lines: 1504, 1526.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
