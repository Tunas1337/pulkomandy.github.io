
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>inode.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * inode.c - Inode handling code. Originated from the Linux-NTFS project.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002-2005 Anton Altaparmakov</a>
<a name="ln5"> * Copyright (c) 2002-2008 Szabolcs Szakacsits</a>
<a name="ln6"> * Copyright (c) 2004-2007 Yura Pakhuchiy</a>
<a name="ln7"> * Copyright (c) 2004-2005 Richard Russon</a>
<a name="ln8"> * Copyright (c) 2009-2010 Jean-Pierre Andre</a>
<a name="ln9"> *</a>
<a name="ln10"> * This program/include file is free software; you can redistribute it and/or</a>
<a name="ln11"> * modify it under the terms of the GNU General Public License as published</a>
<a name="ln12"> * by the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln13"> * (at your option) any later version.</a>
<a name="ln14"> *</a>
<a name="ln15"> * This program/include file is distributed in the hope that it will be</a>
<a name="ln16"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</a>
<a name="ln17"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln18"> * GNU General Public License for more details.</a>
<a name="ln19"> *</a>
<a name="ln20"> * You should have received a copy of the GNU General Public License</a>
<a name="ln21"> * along with this program (in the main directory of the NTFS-3G</a>
<a name="ln22"> * distribution in the file COPYING); if not, write to the Free Software</a>
<a name="ln23"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln24"> */</a>
<a name="ln25"> </a>
<a name="ln26">#ifdef HAVE_CONFIG_H</a>
<a name="ln27">#include &quot;config.h&quot;</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#ifdef HAVE_STDLIB_H</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32">#endif</a>
<a name="ln33">#ifdef HAVE_STRING_H</a>
<a name="ln34">#include &lt;string.h&gt;</a>
<a name="ln35">#endif</a>
<a name="ln36">#ifdef HAVE_ERRNO_H</a>
<a name="ln37">#include &lt;errno.h&gt;</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;param.h&quot;</a>
<a name="ln41">#include &quot;compat.h&quot;</a>
<a name="ln42">#include &quot;types.h&quot;</a>
<a name="ln43">#include &quot;volume.h&quot;</a>
<a name="ln44">#include &quot;cache.h&quot;</a>
<a name="ln45">#include &quot;inode.h&quot;</a>
<a name="ln46">#include &quot;attrib.h&quot;</a>
<a name="ln47">#include &quot;debug.h&quot;</a>
<a name="ln48">#include &quot;mft.h&quot;</a>
<a name="ln49">#include &quot;attrlist.h&quot;</a>
<a name="ln50">#include &quot;runlist.h&quot;</a>
<a name="ln51">#include &quot;lcnalloc.h&quot;</a>
<a name="ln52">#include &quot;index.h&quot;</a>
<a name="ln53">#include &quot;dir.h&quot;</a>
<a name="ln54">#include &quot;ntfstime.h&quot;</a>
<a name="ln55">#include &quot;logging.h&quot;</a>
<a name="ln56">#include &quot;misc.h&quot;</a>
<a name="ln57">#include &quot;xattrs.h&quot;</a>
<a name="ln58"> </a>
<a name="ln59">ntfs_inode *ntfs_inode_base(ntfs_inode *ni)</a>
<a name="ln60">{</a>
<a name="ln61">	if (ni-&gt;nr_extents == -1)</a>
<a name="ln62">		return ni-&gt;base_ni;</a>
<a name="ln63">	return ni;</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">/**</a>
<a name="ln67"> * ntfs_inode_mark_dirty - set the inode (and its base inode if it exists) dirty</a>
<a name="ln68"> * @ni:		ntfs inode to set dirty</a>
<a name="ln69"> *</a>
<a name="ln70"> * Set the inode @ni dirty so it is written out later (at the latest at</a>
<a name="ln71"> * ntfs_inode_close() time). If @ni is an extent inode, set the base inode</a>
<a name="ln72"> * dirty, too.</a>
<a name="ln73"> *</a>
<a name="ln74"> * This function cannot fail.</a>
<a name="ln75"> */</a>
<a name="ln76">void ntfs_inode_mark_dirty(ntfs_inode *ni)</a>
<a name="ln77">{</a>
<a name="ln78">	NInoSetDirty(ni);</a>
<a name="ln79">	if (ni-&gt;nr_extents == -1)</a>
<a name="ln80">		NInoSetDirty(ni-&gt;base_ni);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">/**</a>
<a name="ln84"> * __ntfs_inode_allocate - Create and initialise an NTFS inode object</a>
<a name="ln85"> * @vol:</a>
<a name="ln86"> *</a>
<a name="ln87"> * Description...</a>
<a name="ln88"> *</a>
<a name="ln89"> * Returns:</a>
<a name="ln90"> */</a>
<a name="ln91">static ntfs_inode *__ntfs_inode_allocate(ntfs_volume *vol)</a>
<a name="ln92">{</a>
<a name="ln93">	ntfs_inode *ni;</a>
<a name="ln94"> </a>
<a name="ln95">	ni = (ntfs_inode*)ntfs_calloc(sizeof(ntfs_inode));</a>
<a name="ln96">	if (ni)</a>
<a name="ln97">		ni-&gt;vol = vol;</a>
<a name="ln98">	return ni;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">/**</a>
<a name="ln102"> * ntfs_inode_allocate - Create an NTFS inode object</a>
<a name="ln103"> * @vol:</a>
<a name="ln104"> *</a>
<a name="ln105"> * Description...</a>
<a name="ln106"> *</a>
<a name="ln107"> * Returns:</a>
<a name="ln108"> */</a>
<a name="ln109">ntfs_inode *ntfs_inode_allocate(ntfs_volume *vol)</a>
<a name="ln110">{</a>
<a name="ln111">	return __ntfs_inode_allocate(vol);</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">/**</a>
<a name="ln115"> * __ntfs_inode_release - Destroy an NTFS inode object</a>
<a name="ln116"> * @ni:</a>
<a name="ln117"> *</a>
<a name="ln118"> * Description...</a>
<a name="ln119"> *</a>
<a name="ln120"> * Returns:</a>
<a name="ln121"> */</a>
<a name="ln122">static void __ntfs_inode_release(ntfs_inode *ni)</a>
<a name="ln123">{</a>
<a name="ln124">	if (NInoDirty(ni))</a>
<a name="ln125">		ntfs_log_error(&quot;Releasing dirty inode %lld!\n&quot;, </a>
<a name="ln126">			       (long long)ni-&gt;mft_no);</a>
<a name="ln127">	if (NInoAttrList(ni) &amp;&amp; ni-&gt;attr_list)</a>
<a name="ln128">		free(ni-&gt;attr_list);</a>
<a name="ln129">	free(ni-&gt;mrec);</a>
<a name="ln130">	free(ni);</a>
<a name="ln131">	return;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">/**</a>
<a name="ln135"> * ntfs_inode_open - open an inode ready for access</a>
<a name="ln136"> * @vol:	volume to get the inode from</a>
<a name="ln137"> * @mref:	inode number / mft record number to open</a>
<a name="ln138"> *</a>
<a name="ln139"> * Allocate an ntfs_inode structure and initialize it for the given inode</a>
<a name="ln140"> * specified by @mref. @mref specifies the inode number / mft record to read,</a>
<a name="ln141"> * including the sequence number, which can be 0 if no sequence number checking</a>
<a name="ln142"> * is to be performed.</a>
<a name="ln143"> *</a>
<a name="ln144"> * Then, allocate a buffer for the mft record, read the mft record from the</a>
<a name="ln145"> * volume @vol, and attach it to the ntfs_inode structure (-&gt;mrec). The</a>
<a name="ln146"> * mft record is mst deprotected and sanity checked for validity and we abort</a>
<a name="ln147"> * if deprotection or checks fail.</a>
<a name="ln148"> *</a>
<a name="ln149"> * Finally, search for an attribute list attribute in the mft record and if one</a>
<a name="ln150"> * is found, load the attribute list attribute value and attach it to the</a>
<a name="ln151"> * ntfs_inode structure (-&gt;attr_list). Also set the NI_AttrList bit to indicate</a>
<a name="ln152"> * this.</a>
<a name="ln153"> *</a>
<a name="ln154"> * Return a pointer to the ntfs_inode structure on success or NULL on error,</a>
<a name="ln155"> * with errno set to the error code.</a>
<a name="ln156"> */</a>
<a name="ln157">static ntfs_inode *ntfs_inode_real_open(ntfs_volume *vol, const MFT_REF mref)</a>
<a name="ln158">{</a>
<a name="ln159">	s64 l;</a>
<a name="ln160">	ntfs_inode *ni = NULL;</a>
<a name="ln161">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln162">	STANDARD_INFORMATION *std_info;</a>
<a name="ln163">	le32 lthle;</a>
<a name="ln164">	int olderrno;</a>
<a name="ln165"> </a>
<a name="ln166">	ntfs_log_enter(&quot;Entering for inode %lld\n&quot;, (long long)MREF(mref));</a>
<a name="ln167">	if (!vol) {</a>
<a name="ln168">		errno = EINVAL;</a>
<a name="ln169">		goto out;</a>
<a name="ln170">	}</a>
<a name="ln171">	ni = __ntfs_inode_allocate(vol);</a>
<a name="ln172">	if (!ni)</a>
<a name="ln173">		goto out;</a>
<a name="ln174">	if (ntfs_file_record_read(vol, mref, &amp;ni-&gt;mrec, NULL))</a>
<a name="ln175">		goto err_out;</a>
<a name="ln176">	if (!(ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IN_USE)) {</a>
<a name="ln177">		errno = ENOENT;</a>
<a name="ln178">		goto err_out;</a>
<a name="ln179">	}</a>
<a name="ln180">	ni-&gt;mft_no = MREF(mref);</a>
<a name="ln181">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln182">	if (!ctx)</a>
<a name="ln183">		goto err_out;</a>
<a name="ln184">	/* Receive some basic information about inode. */</a>
<a name="ln185">	if (ntfs_attr_lookup(AT_STANDARD_INFORMATION, AT_UNNAMED,</a>
<a name="ln186">				0, CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln187">		if (!ni-&gt;mrec-&gt;base_mft_record)</a>
<a name="ln188">			ntfs_log_perror(&quot;No STANDARD_INFORMATION in base record&quot;</a>
<a name="ln189">					&quot; %lld&quot;, (long long)MREF(mref));</a>
<a name="ln190">		goto put_err_out;</a>
<a name="ln191">	}</a>
<a name="ln192">	std_info = (STANDARD_INFORMATION *)((u8 *)ctx-&gt;attr +</a>
<a name="ln193">			le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln194">	ni-&gt;flags = std_info-&gt;file_attributes;</a>
<a name="ln195">	ni-&gt;creation_time = std_info-&gt;creation_time;</a>
<a name="ln196">	ni-&gt;last_data_change_time = std_info-&gt;last_data_change_time;</a>
<a name="ln197">	ni-&gt;last_mft_change_time = std_info-&gt;last_mft_change_time;</a>
<a name="ln198">	ni-&gt;last_access_time = std_info-&gt;last_access_time;</a>
<a name="ln199">  		/* JPA insert v3 extensions if present */</a>
<a name="ln200">                /* length may be seen as 72 (v1.x) or 96 (v3.x) */</a>
<a name="ln201">	lthle = ctx-&gt;attr-&gt;length;</a>
<a name="ln202">	if (le32_to_cpu(lthle) &gt; sizeof(STANDARD_INFORMATION)) {</a>
<a name="ln203">		set_nino_flag(ni, v3_Extensions);</a>
<a name="ln204">		ni-&gt;owner_id = std_info-&gt;owner_id;</a>
<a name="ln205">		ni-&gt;security_id = std_info-&gt;security_id;</a>
<a name="ln206">		ni-&gt;quota_charged = std_info-&gt;quota_charged;</a>
<a name="ln207">		ni-&gt;usn = std_info-&gt;usn;</a>
<a name="ln208">	} else {</a>
<a name="ln209">		clear_nino_flag(ni, v3_Extensions);</a>
<a name="ln210">		ni-&gt;owner_id = const_cpu_to_le32(0);</a>
<a name="ln211">		ni-&gt;security_id = const_cpu_to_le32(0);</a>
<a name="ln212">	}</a>
<a name="ln213">	/* Set attribute list information. */</a>
<a name="ln214">	olderrno = errno;</a>
<a name="ln215">	if (ntfs_attr_lookup(AT_ATTRIBUTE_LIST, AT_UNNAMED, 0,</a>
<a name="ln216">			CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln217">		if (errno != ENOENT)</a>
<a name="ln218">			goto put_err_out;</a>
<a name="ln219">		/* Attribute list attribute does not present. */</a>
<a name="ln220">		/* restore previous errno to avoid misinterpretation */</a>
<a name="ln221">		errno = olderrno;</a>
<a name="ln222">		goto get_size;</a>
<a name="ln223">	}</a>
<a name="ln224">	NInoSetAttrList(ni);</a>
<a name="ln225">	l = ntfs_get_attribute_value_length(ctx-&gt;attr);</a>
<a name="ln226">	if (!l)</a>
<a name="ln227">		goto put_err_out;</a>
<a name="ln228">	if (l &gt; 0x40000) {</a>
<a name="ln229">		errno = EIO;</a>
<a name="ln230">		ntfs_log_perror(&quot;Too large attrlist attribute (%lld), inode &quot;</a>
<a name="ln231">				&quot;%lld&quot;, (long long)l, (long long)MREF(mref));</a>
<a name="ln232">		goto put_err_out;</a>
<a name="ln233">	}</a>
<a name="ln234">	ni-&gt;attr_list_size = l;</a>
<a name="ln235">	ni-&gt;attr_list = ntfs_malloc(ni-&gt;attr_list_size);</a>
<a name="ln236">	if (!ni-&gt;attr_list)</a>
<a name="ln237">		goto put_err_out;</a>
<a name="ln238">	l = ntfs_get_attribute_value(vol, ctx-&gt;attr, ni-&gt;attr_list);</a>
<a name="ln239">	if (!l)</a>
<a name="ln240">		goto put_err_out;</a>
<a name="ln241">	if (l != ni-&gt;attr_list_size) {</a>
<a name="ln242">		errno = EIO;</a>
<a name="ln243">		ntfs_log_perror(&quot;Unexpected attrlist size (%lld &lt;&gt; %u), inode &quot;</a>
<a name="ln244">				&quot;%lld&quot;, (long long)l, ni-&gt;attr_list_size, </a>
<a name="ln245">				(long long)MREF(mref));</a>
<a name="ln246">		goto put_err_out;</a>
<a name="ln247">	}</a>
<a name="ln248">get_size:</a>
<a name="ln249">	olderrno = errno;</a>
<a name="ln250">	if (ntfs_attr_lookup(AT_DATA, AT_UNNAMED, 0, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln251">		if (errno != ENOENT)</a>
<a name="ln252">			goto put_err_out;</a>
<a name="ln253">		/* Directory or special file. */</a>
<a name="ln254">		/* restore previous errno to avoid misinterpretation */</a>
<a name="ln255">		errno = olderrno;</a>
<a name="ln256">		ni-&gt;data_size = ni-&gt;allocated_size = 0;</a>
<a name="ln257">	} else {</a>
<a name="ln258">		if (ctx-&gt;attr-&gt;non_resident) {</a>
<a name="ln259">			ni-&gt;data_size = sle64_to_cpu(ctx-&gt;attr-&gt;data_size);</a>
<a name="ln260">			if (ctx-&gt;attr-&gt;flags &amp;</a>
<a name="ln261">					(ATTR_IS_COMPRESSED | ATTR_IS_SPARSE))</a>
<a name="ln262">				ni-&gt;allocated_size = sle64_to_cpu(</a>
<a name="ln263">						ctx-&gt;attr-&gt;compressed_size);</a>
<a name="ln264">			else</a>
<a name="ln265">				ni-&gt;allocated_size = sle64_to_cpu(</a>
<a name="ln266">						ctx-&gt;attr-&gt;allocated_size);</a>
<a name="ln267">		} else {</a>
<a name="ln268">			ni-&gt;data_size = le32_to_cpu(ctx-&gt;attr-&gt;value_length);</a>
<a name="ln269">			ni-&gt;allocated_size = (ni-&gt;data_size + 7) &amp; ~7;</a>
<a name="ln270">		}</a>
<a name="ln271">		set_nino_flag(ni,KnownSize);</a>
<a name="ln272">	}</a>
<a name="ln273">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln274">out:	</a>
<a name="ln275">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln276">	return ni;</a>
<a name="ln277"> </a>
<a name="ln278">put_err_out:</a>
<a name="ln279">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln280">err_out:</a>
<a name="ln281">	__ntfs_inode_release(ni);</a>
<a name="ln282">	ni = NULL;</a>
<a name="ln283">	goto out;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/**</a>
<a name="ln287"> * ntfs_inode_close - close an ntfs inode and free all associated memory</a>
<a name="ln288"> * @ni:		ntfs inode to close</a>
<a name="ln289"> *</a>
<a name="ln290"> * Make sure the ntfs inode @ni is clean.</a>
<a name="ln291"> *</a>
<a name="ln292"> * If the ntfs inode @ni is a base inode, close all associated extent inodes,</a>
<a name="ln293"> * then deallocate all memory attached to it, and finally free the ntfs inode</a>
<a name="ln294"> * structure itself.</a>
<a name="ln295"> *</a>
<a name="ln296"> * If it is an extent inode, we disconnect it from its base inode before we</a>
<a name="ln297"> * destroy it.</a>
<a name="ln298"> *</a>
<a name="ln299"> * It is OK to pass NULL to this function, it is just noop in this case.</a>
<a name="ln300"> *</a>
<a name="ln301"> * Return 0 on success or -1 on error with errno set to the error code. On</a>
<a name="ln302"> * error, @ni has not been freed. The user should attempt to handle the error</a>
<a name="ln303"> * and call ntfs_inode_close() again. The following error codes are defined:</a>
<a name="ln304"> *</a>
<a name="ln305"> *	EBUSY	@ni and/or its attribute list runlist is/are dirty and the</a>
<a name="ln306"> *		attempt to write it/them to disk failed.</a>
<a name="ln307"> *	EINVAL	@ni is invalid (probably it is an extent inode).</a>
<a name="ln308"> *	EIO	I/O error while trying to write inode to disk.</a>
<a name="ln309"> */</a>
<a name="ln310"> </a>
<a name="ln311">int ntfs_inode_real_close(ntfs_inode *ni)</a>
<a name="ln312">{</a>
<a name="ln313">	int ret = -1;</a>
<a name="ln314">	</a>
<a name="ln315">	if (!ni)</a>
<a name="ln316">		return 0;</a>
<a name="ln317"> </a>
<a name="ln318">	ntfs_log_enter(&quot;Entering for inode %lld\n&quot;, (long long)ni-&gt;mft_no);</a>
<a name="ln319"> </a>
<a name="ln320">	/* If we have dirty metadata, write it out. */</a>
<a name="ln321">	if (NInoDirty(ni) || NInoAttrListDirty(ni)) {</a>
<a name="ln322">		if (ntfs_inode_sync(ni)) {</a>
<a name="ln323">			if (errno != EIO)</a>
<a name="ln324">				errno = EBUSY;</a>
<a name="ln325">			goto err;</a>
<a name="ln326">		}</a>
<a name="ln327">	}</a>
<a name="ln328">	/* Is this a base inode with mapped extent inodes? */</a>
<a name="ln329">	if (ni-&gt;nr_extents &gt; 0) {</a>
<a name="ln330">		while (ni-&gt;nr_extents &gt; 0) {</a>
<a name="ln331">			if (ntfs_inode_real_close(ni-&gt;extent_nis[0])) {</a>
<a name="ln332">				if (errno != EIO)</a>
<a name="ln333">					errno = EBUSY;</a>
<a name="ln334">				goto err;</a>
<a name="ln335">			}</a>
<a name="ln336">		}</a>
<a name="ln337">	} else if (ni-&gt;nr_extents == -1) {</a>
<a name="ln338">		ntfs_inode **tmp_nis;</a>
<a name="ln339">		ntfs_inode *base_ni;</a>
<a name="ln340">		s32 i;</a>
<a name="ln341"> </a>
<a name="ln342">		/*</a>
<a name="ln343">		 * If the inode is an extent inode, disconnect it from the</a>
<a name="ln344">		 * base inode before destroying it.</a>
<a name="ln345">		 */</a>
<a name="ln346">		base_ni = ni-&gt;base_ni;</a>
<a name="ln347">		for (i = 0; i &lt; base_ni-&gt;nr_extents; ++i) {</a>
<a name="ln348">			tmp_nis = base_ni-&gt;extent_nis;</a>
<a name="ln349">			if (tmp_nis[i] != ni)</a>
<a name="ln350">				continue;</a>
<a name="ln351">			/* Found it. Disconnect. */</a>
<a name="ln352">			memmove(tmp_nis + i, tmp_nis + i + 1,</a>
<a name="ln353">					(base_ni-&gt;nr_extents - i - 1) *</a>
<a name="ln354">					sizeof(ntfs_inode *));</a>
<a name="ln355">			/* Buffer should be for multiple of four extents. */</a>
<a name="ln356">			if ((--base_ni-&gt;nr_extents) &amp; 3) {</a>
<a name="ln357">				i = -1;</a>
<a name="ln358">				break;</a>
<a name="ln359">			}</a>
<a name="ln360">			/*</a>
<a name="ln361">			 * ElectricFence is unhappy with realloc(x,0) as free(x)</a>
<a name="ln362">			 * thus we explicitly separate these two cases.</a>
<a name="ln363">			 */</a>
<a name="ln364">			if (base_ni-&gt;nr_extents) {</a>
<a name="ln365">				/* Resize the memory buffer. */</a>
<a name="ln366">				tmp_nis = realloc(tmp_nis, base_ni-&gt;nr_extents *</a>
<a name="ln367">						  sizeof(ntfs_inode *));</a>
<a name="ln368">				/* Ignore errors, they don't really matter. */</a>
<a name="ln369">				if (tmp_nis)</a>
<a name="ln370">					base_ni-&gt;extent_nis = tmp_nis;</a>
<a name="ln371">			} else if (tmp_nis) {</a>
<a name="ln372">				free(tmp_nis);</a>
<a name="ln373">				base_ni-&gt;extent_nis = (ntfs_inode**)NULL;</a>
<a name="ln374">			}</a>
<a name="ln375">			/* Allow for error checking. */</a>
<a name="ln376">			i = -1;</a>
<a name="ln377">			break;</a>
<a name="ln378">		}</a>
<a name="ln379">		</a>
<a name="ln380">		/* </a>
<a name="ln381">		 *  We could successfully sync, so only log this error</a>
<a name="ln382">		 *  and try to sync other inode extents too.</a>
<a name="ln383">		 */</a>
<a name="ln384">		if (i != -1)</a>
<a name="ln385">			ntfs_log_error(&quot;Extent inode %lld was not found\n&quot;,</a>
<a name="ln386">				       (long long)ni-&gt;mft_no);</a>
<a name="ln387">	}</a>
<a name="ln388">	</a>
<a name="ln389">	__ntfs_inode_release(ni);</a>
<a name="ln390">	ret = 0;</a>
<a name="ln391">err:</a>
<a name="ln392">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln393">	return ret;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">#if CACHE_NIDATA_SIZE</a>
<a name="ln397"> </a>
<a name="ln398">/*</a>
<a name="ln399"> *		Free an inode structure when there is not more space</a>
<a name="ln400"> *	in the cache</a>
<a name="ln401"> */</a>
<a name="ln402"> </a>
<a name="ln403">void ntfs_inode_nidata_free(const struct CACHED_GENERIC *cached)</a>
<a name="ln404">{</a>
<a name="ln405">        ntfs_inode_real_close(((const struct CACHED_NIDATA*)cached)-&gt;ni);</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">/*</a>
<a name="ln409"> *		Compute a hash value for an inode entry</a>
<a name="ln410"> */</a>
<a name="ln411"> </a>
<a name="ln412">int ntfs_inode_nidata_hash(const struct CACHED_GENERIC *item)</a>
<a name="ln413">{</a>
<a name="ln414">	return (((const struct CACHED_NIDATA*)item)-&gt;inum</a>
<a name="ln415">			% (2*CACHE_NIDATA_SIZE));</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">/*</a>
<a name="ln419"> *		inum comparing for entering/fetching from cache</a>
<a name="ln420"> */</a>
<a name="ln421"> </a>
<a name="ln422">static int idata_cache_compare(const struct CACHED_GENERIC *cached,</a>
<a name="ln423">			const struct CACHED_GENERIC *wanted)</a>
<a name="ln424">{</a>
<a name="ln425">	return (((const struct CACHED_NIDATA*)cached)-&gt;inum</a>
<a name="ln426">			!= ((const struct CACHED_NIDATA*)wanted)-&gt;inum);</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">/*</a>
<a name="ln430"> *		Invalidate an inode entry when not needed anymore.</a>
<a name="ln431"> *	The entry should have been synced, it may be reused later,</a>
<a name="ln432"> *	if it is requested before it is dropped from cache.</a>
<a name="ln433"> */</a>
<a name="ln434"> </a>
<a name="ln435">void ntfs_inode_invalidate(ntfs_volume *vol, const MFT_REF mref)</a>
<a name="ln436">{</a>
<a name="ln437">	struct CACHED_NIDATA item;</a>
<a name="ln438"> </a>
<a name="ln439">	item.inum = MREF(mref);</a>
<a name="ln440">	item.ni = (ntfs_inode*)NULL;</a>
<a name="ln441">	item.pathname = (const char*)NULL;</a>
<a name="ln442">	item.varsize = 0;</a>
<a name="ln443">	ntfs_invalidate_cache(vol-&gt;nidata_cache,</a>
<a name="ln444">				GENERIC(&amp;item),idata_cache_compare,CACHE_FREE);</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">#endif</a>
<a name="ln448"> </a>
<a name="ln449">/*</a>
<a name="ln450"> *		Open an inode</a>
<a name="ln451"> *</a>
<a name="ln452"> *	When possible, an entry recorded in the cache is reused</a>
<a name="ln453"> *</a>
<a name="ln454"> *	**NEVER REOPEN** an inode, this can lead to a duplicated</a>
<a name="ln455"> * 	cache entry (hard to detect), and to an obsolete one being</a>
<a name="ln456"> *	reused. System files are however protected from being cached.</a>
<a name="ln457"> */</a>
<a name="ln458"> </a>
<a name="ln459">ntfs_inode *ntfs_inode_open(ntfs_volume *vol, const MFT_REF mref)</a>
<a name="ln460">{</a>
<a name="ln461">	ntfs_inode *ni;</a>
<a name="ln462">#if CACHE_NIDATA_SIZE</a>
<a name="ln463">	struct CACHED_NIDATA item;</a>
<a name="ln464">	struct CACHED_NIDATA *cached;</a>
<a name="ln465"> </a>
<a name="ln466">		/* fetch idata from cache */</a>
<a name="ln467">	item.inum = MREF(mref);</a>
<a name="ln468">	debug_double_inode(item.inum,1);</a>
<a name="ln469">	item.pathname = (const char*)NULL;</a>
<a name="ln470">	item.varsize = 0;</a>
<a name="ln471">	cached = (struct CACHED_NIDATA*)ntfs_fetch_cache(vol-&gt;nidata_cache,</a>
<a name="ln472">				GENERIC(&amp;item),idata_cache_compare);</a>
<a name="ln473">	if (cached) {</a>
<a name="ln474">		ni = cached-&gt;ni;</a>
<a name="ln475">		/* do not keep open entries in cache */</a>
<a name="ln476">		ntfs_remove_cache(vol-&gt;nidata_cache,</a>
<a name="ln477">				(struct CACHED_GENERIC*)cached,0);</a>
<a name="ln478">	} else {</a>
<a name="ln479">		ni = ntfs_inode_real_open(vol, mref);</a>
<a name="ln480">	}</a>
<a name="ln481">	if (!ni) {</a>
<a name="ln482">		debug_double_inode(item.inum, 0);</a>
<a name="ln483">	}</a>
<a name="ln484">#else</a>
<a name="ln485">	ni = ntfs_inode_real_open(vol, mref);</a>
<a name="ln486">#endif</a>
<a name="ln487">	return (ni);</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">/*</a>
<a name="ln491"> *		Close an inode entry</a>
<a name="ln492"> *</a>
<a name="ln493"> *	If cacheing is in use, the entry is synced and kept available</a>
<a name="ln494"> *	in cache for further use.</a>
<a name="ln495"> *</a>
<a name="ln496"> *	System files (inode &lt; 16 or having the IS_4 flag) are protected</a>
<a name="ln497"> *	against being cached.</a>
<a name="ln498"> */</a>
<a name="ln499"> </a>
<a name="ln500">int ntfs_inode_close(ntfs_inode *ni)</a>
<a name="ln501">{</a>
<a name="ln502">	int res;</a>
<a name="ln503">#if CACHE_NIDATA_SIZE</a>
<a name="ln504">	BOOL dirty;</a>
<a name="ln505">	struct CACHED_NIDATA item;</a>
<a name="ln506"> </a>
<a name="ln507">	if (ni) {</a>
<a name="ln508">		debug_double_inode(ni-&gt;mft_no,0);</a>
<a name="ln509">		/* do not cache system files : could lead to double entries */</a>
<a name="ln510">		if (ni-&gt;vol &amp;&amp; ni-&gt;vol-&gt;nidata_cache</a>
<a name="ln511">			&amp;&amp; ((ni-&gt;mft_no == FILE_root)</a>
<a name="ln512">			    || ((ni-&gt;mft_no &gt;= FILE_first_user)</a>
<a name="ln513">				&amp;&amp; !(ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_4)))) {</a>
<a name="ln514">			/* If we have dirty metadata, write it out. */</a>
<a name="ln515">			dirty = NInoDirty(ni) || NInoAttrListDirty(ni);</a>
<a name="ln516">			if (dirty) {</a>
<a name="ln517">				res = ntfs_inode_sync(ni);</a>
<a name="ln518">					/* do a real close if sync failed */</a>
<a name="ln519">				if (res)</a>
<a name="ln520">					ntfs_inode_real_close(ni);</a>
<a name="ln521">			} else</a>
<a name="ln522">				res = 0;</a>
<a name="ln523"> </a>
<a name="ln524">			if (!res) {</a>
<a name="ln525">					/* feed idata into cache */</a>
<a name="ln526">				item.inum = ni-&gt;mft_no;</a>
<a name="ln527">				item.ni = ni;</a>
<a name="ln528">				item.pathname = (const char*)NULL;</a>
<a name="ln529">				item.varsize = 0;</a>
<a name="ln530">				debug_cached_inode(ni);</a>
<a name="ln531">				ntfs_enter_cache(ni-&gt;vol-&gt;nidata_cache,</a>
<a name="ln532">					GENERIC(&amp;item), idata_cache_compare);</a>
<a name="ln533">			}</a>
<a name="ln534">		} else {</a>
<a name="ln535">			/* cache not ready or system file, really close */</a>
<a name="ln536">			res = ntfs_inode_real_close(ni);</a>
<a name="ln537">		}</a>
<a name="ln538">	} else</a>
<a name="ln539">		res = 0;</a>
<a name="ln540">#else</a>
<a name="ln541">	res = ntfs_inode_real_close(ni);</a>
<a name="ln542">#endif</a>
<a name="ln543">	return (res);</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">/**</a>
<a name="ln547"> * ntfs_extent_inode_open - load an extent inode and attach it to its base</a>
<a name="ln548"> * @base_ni:	base ntfs inode</a>
<a name="ln549"> * @mref:	mft reference of the extent inode to load (in little endian)</a>
<a name="ln550"> *</a>
<a name="ln551"> * First check if the extent inode @mref is already attached to the base ntfs</a>
<a name="ln552"> * inode @base_ni, and if so, return a pointer to the attached extent inode.</a>
<a name="ln553"> *</a>
<a name="ln554"> * If the extent inode is not already attached to the base inode, allocate an</a>
<a name="ln555"> * ntfs_inode structure and initialize it for the given inode @mref. @mref</a>
<a name="ln556"> * specifies the inode number / mft record to read, including the sequence</a>
<a name="ln557"> * number, which can be 0 if no sequence number checking is to be performed.</a>
<a name="ln558"> *</a>
<a name="ln559"> * Then, allocate a buffer for the mft record, read the mft record from the</a>
<a name="ln560"> * volume @base_ni-&gt;vol, and attach it to the ntfs_inode structure (-&gt;mrec).</a>
<a name="ln561"> * The mft record is mst deprotected and sanity checked for validity and we</a>
<a name="ln562"> * abort if deprotection or checks fail.</a>
<a name="ln563"> *</a>
<a name="ln564"> * Finally attach the ntfs inode to its base inode @base_ni and return a</a>
<a name="ln565"> * pointer to the ntfs_inode structure on success or NULL on error, with errno</a>
<a name="ln566"> * set to the error code.</a>
<a name="ln567"> *</a>
<a name="ln568"> * Note, extent inodes are never closed directly. They are automatically</a>
<a name="ln569"> * disposed off by the closing of the base inode.</a>
<a name="ln570"> */</a>
<a name="ln571">ntfs_inode *ntfs_extent_inode_open(ntfs_inode *base_ni, const leMFT_REF mref)</a>
<a name="ln572">{</a>
<a name="ln573">	u64 mft_no = MREF_LE(mref);</a>
<a name="ln574">	VCN extent_vcn;</a>
<a name="ln575">	runlist_element *rl;</a>
<a name="ln576">	ntfs_volume *vol;</a>
<a name="ln577">	ntfs_inode *ni = NULL;</a>
<a name="ln578">	ntfs_inode **extent_nis;</a>
<a name="ln579">	int i;</a>
<a name="ln580"> </a>
<a name="ln581">	if (!base_ni) {</a>
<a name="ln582">		errno = EINVAL;</a>
<a name="ln583">		ntfs_log_perror(&quot;%s&quot;, __FUNCTION__);</a>
<a name="ln584">		return NULL;</a>
<a name="ln585">	}</a>
<a name="ln586">	</a>
<a name="ln587">	ntfs_log_enter(&quot;Opening extent inode %lld (base mft record %lld).\n&quot;,</a>
<a name="ln588">			(unsigned long long)mft_no,</a>
<a name="ln589">			(unsigned long long)base_ni-&gt;mft_no);</a>
<a name="ln590">	</a>
<a name="ln591">	if (!base_ni-&gt;mft_no) {</a>
<a name="ln592">			/*</a>
<a name="ln593">			 * When getting extents of MFT, we must be sure</a>
<a name="ln594">			 * they are in the MFT part which has already</a>
<a name="ln595">			 * been mapped, otherwise we fall into an endless</a>
<a name="ln596">			 * recursion.</a>
<a name="ln597">			 * Situations have been met where extents locations</a>
<a name="ln598">			 * are described in themselves.</a>
<a name="ln599">			 * This is a severe error which chkdsk cannot fix.</a>
<a name="ln600">			 */</a>
<a name="ln601">		vol = base_ni-&gt;vol;</a>
<a name="ln602">		extent_vcn = mft_no &lt;&lt; vol-&gt;mft_record_size_bits</a>
<a name="ln603">				&gt;&gt; vol-&gt;cluster_size_bits;</a>
<a name="ln604">		rl = vol-&gt;mft_na-&gt;rl;</a>
<a name="ln605">		if (rl) {</a>
<a name="ln606">			while (rl-&gt;length</a>
<a name="ln607">			    &amp;&amp; ((rl-&gt;vcn + rl-&gt;length) &lt;= extent_vcn))</a>
<a name="ln608">				rl++;</a>
<a name="ln609">		}</a>
<a name="ln610">		if (!rl || (rl-&gt;lcn &lt; 0)) {</a>
<a name="ln611">			ntfs_log_error(&quot;MFT is corrupt, cannot read&quot;</a>
<a name="ln612">				&quot; its unmapped extent record %lld\n&quot;,</a>
<a name="ln613">					(long long)mft_no);</a>
<a name="ln614">			ntfs_log_error(&quot;Note : chkdsk cannot fix this,&quot;</a>
<a name="ln615">				&quot; try ntfsfix\n&quot;);</a>
<a name="ln616">			errno = EIO;</a>
<a name="ln617">			ni = (ntfs_inode*)NULL;</a>
<a name="ln618">			goto out;</a>
<a name="ln619">		}</a>
<a name="ln620">	}</a>
<a name="ln621"> </a>
<a name="ln622">	/* Is the extent inode already open and attached to the base inode? */</a>
<a name="ln623">	if (base_ni-&gt;nr_extents &gt; 0) {</a>
<a name="ln624">		extent_nis = base_ni-&gt;extent_nis;</a>
<a name="ln625">		for (i = 0; i &lt; base_ni-&gt;nr_extents; i++) {</a>
<a name="ln626">			u16 seq_no;</a>
<a name="ln627"> </a>
<a name="ln628">			ni = extent_nis[i];</a>
<a name="ln629">			if (mft_no != ni-&gt;mft_no)</a>
<a name="ln630">				continue;</a>
<a name="ln631">			/* Verify the sequence number if given. */</a>
<a name="ln632">			seq_no = MSEQNO_LE(mref);</a>
<a name="ln633">			if (seq_no &amp;&amp; seq_no != le16_to_cpu(</a>
<a name="ln634">					ni-&gt;mrec-&gt;sequence_number)) {</a>
<a name="ln635">				errno = EIO;</a>
<a name="ln636">				ntfs_log_perror(&quot;Found stale extent mft &quot;</a>
<a name="ln637">					&quot;reference mft=%lld&quot;,</a>
<a name="ln638">					(long long)ni-&gt;mft_no);</a>
<a name="ln639">				goto out;</a>
<a name="ln640">			}</a>
<a name="ln641">			goto out;</a>
<a name="ln642">		}</a>
<a name="ln643">	}</a>
<a name="ln644">	/* Wasn't there, we need to load the extent inode. */</a>
<a name="ln645">	ni = __ntfs_inode_allocate(base_ni-&gt;vol);</a>
<a name="ln646">	if (!ni)</a>
<a name="ln647">		goto out;</a>
<a name="ln648">	if (ntfs_file_record_read(base_ni-&gt;vol, le64_to_cpu(mref), &amp;ni-&gt;mrec, NULL))</a>
<a name="ln649">		goto err_out;</a>
<a name="ln650">	ni-&gt;mft_no = mft_no;</a>
<a name="ln651">	ni-&gt;nr_extents = -1;</a>
<a name="ln652">	ni-&gt;base_ni = base_ni;</a>
<a name="ln653">	/* Attach extent inode to base inode, reallocating memory if needed. */</a>
<a name="ln654">	if (!(base_ni-&gt;nr_extents &amp; 3)) {</a>
<a name="ln655">		i = (base_ni-&gt;nr_extents + 4) * sizeof(ntfs_inode *);</a>
<a name="ln656"> </a>
<a name="ln657">		extent_nis = ntfs_malloc(i);</a>
<a name="ln658">		if (!extent_nis)</a>
<a name="ln659">			goto err_out;</a>
<a name="ln660">		if (base_ni-&gt;nr_extents) {</a>
<a name="ln661">			memcpy(extent_nis, base_ni-&gt;extent_nis,</a>
<a name="ln662">					i - 4 * sizeof(ntfs_inode *));</a>
<a name="ln663">			free(base_ni-&gt;extent_nis);</a>
<a name="ln664">		}</a>
<a name="ln665">		base_ni-&gt;extent_nis = extent_nis;</a>
<a name="ln666">	}</a>
<a name="ln667">	base_ni-&gt;extent_nis[base_ni-&gt;nr_extents++] = ni;</a>
<a name="ln668">out:</a>
<a name="ln669">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln670">	return ni;</a>
<a name="ln671">err_out:</a>
<a name="ln672">	__ntfs_inode_release(ni);</a>
<a name="ln673">	ni = NULL;</a>
<a name="ln674">	goto out;</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">/**</a>
<a name="ln678"> * ntfs_inode_attach_all_extents - attach all extents for target inode</a>
<a name="ln679"> * @ni:		opened ntfs inode for which perform attach</a>
<a name="ln680"> *</a>
<a name="ln681"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln682"> */</a>
<a name="ln683">int ntfs_inode_attach_all_extents(ntfs_inode *ni)</a>
<a name="ln684">{</a>
<a name="ln685">	ATTR_LIST_ENTRY *ale;</a>
<a name="ln686">	u64 prev_attached = 0;</a>
<a name="ln687"> </a>
<a name="ln688">	if (!ni) {</a>
<a name="ln689">		ntfs_log_trace(&quot;Invalid arguments.\n&quot;);</a>
<a name="ln690">		errno = EINVAL;</a>
<a name="ln691">		return -1;</a>
<a name="ln692">	}</a>
<a name="ln693"> </a>
<a name="ln694">	if (ni-&gt;nr_extents == -1)</a>
<a name="ln695">		ni = ni-&gt;base_ni;</a>
<a name="ln696"> </a>
<a name="ln697">	ntfs_log_trace(&quot;Entering for inode 0x%llx.\n&quot;, (long long) ni-&gt;mft_no);</a>
<a name="ln698"> </a>
<a name="ln699">	/* Inode haven't got attribute list, thus nothing to attach. */</a>
<a name="ln700">	if (!NInoAttrList(ni))</a>
<a name="ln701">		return 0;</a>
<a name="ln702"> </a>
<a name="ln703">	if (!ni-&gt;attr_list) {</a>
<a name="ln704">		ntfs_log_trace(&quot;Corrupt in-memory struct.\n&quot;);</a>
<a name="ln705">		errno = EINVAL;</a>
<a name="ln706">		return -1;</a>
<a name="ln707">	}</a>
<a name="ln708"> </a>
<a name="ln709">	/* Walk through attribute list and attach all extents. */</a>
<a name="ln710">	errno = 0;</a>
<a name="ln711">	ale = (ATTR_LIST_ENTRY *)ni-&gt;attr_list;</a>
<a name="ln712">	while ((u8*)ale &lt; ni-&gt;attr_list + ni-&gt;attr_list_size) {</a>
<a name="ln713">		if (ni-&gt;mft_no != MREF_LE(ale-&gt;mft_reference) &amp;&amp;</a>
<a name="ln714">				prev_attached != MREF_LE(ale-&gt;mft_reference)) {</a>
<a name="ln715">			if (!ntfs_extent_inode_open(ni, ale-&gt;mft_reference)) {</a>
<a name="ln716">				ntfs_log_trace(&quot;Couldn't attach extent inode.\n&quot;);</a>
<a name="ln717">				return -1;</a>
<a name="ln718">			}</a>
<a name="ln719">			prev_attached = MREF_LE(ale-&gt;mft_reference);</a>
<a name="ln720">		}</a>
<a name="ln721">		ale = (ATTR_LIST_ENTRY *)((u8*)ale + le16_to_cpu(ale-&gt;length));</a>
<a name="ln722">	}</a>
<a name="ln723">	return 0;</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">/**</a>
<a name="ln727"> * ntfs_inode_sync_standard_information - update standard information attribute</a>
<a name="ln728"> * @ni:		ntfs inode to update standard information</a>
<a name="ln729"> *</a>
<a name="ln730"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln731"> */</a>
<a name="ln732">static int ntfs_inode_sync_standard_information(ntfs_inode *ni)</a>
<a name="ln733">{</a>
<a name="ln734">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln735">	STANDARD_INFORMATION *std_info;</a>
<a name="ln736">	u32 lth;</a>
<a name="ln737">	le32 lthle;</a>
<a name="ln738"> </a>
<a name="ln739">	ntfs_log_trace(&quot;Entering for inode %lld\n&quot;, (long long)ni-&gt;mft_no);</a>
<a name="ln740"> </a>
<a name="ln741">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln742">	if (!ctx)</a>
<a name="ln743">		return -1;</a>
<a name="ln744">	if (ntfs_attr_lookup(AT_STANDARD_INFORMATION, AT_UNNAMED,</a>
<a name="ln745">			     0, CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln746">		ntfs_log_perror(&quot;Failed to sync standard info (inode %lld)&quot;,</a>
<a name="ln747">				(long long)ni-&gt;mft_no);</a>
<a name="ln748">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln749">		return -1;</a>
<a name="ln750">	}</a>
<a name="ln751">	std_info = (STANDARD_INFORMATION *)((u8 *)ctx-&gt;attr +</a>
<a name="ln752">			le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln753">	std_info-&gt;file_attributes = ni-&gt;flags;</a>
<a name="ln754">	if (!test_nino_flag(ni, TimesSet)) {</a>
<a name="ln755">		std_info-&gt;creation_time = ni-&gt;creation_time;</a>
<a name="ln756">		std_info-&gt;last_data_change_time = ni-&gt;last_data_change_time;</a>
<a name="ln757">		std_info-&gt;last_mft_change_time = ni-&gt;last_mft_change_time;</a>
<a name="ln758">		std_info-&gt;last_access_time = ni-&gt;last_access_time;</a>
<a name="ln759">	}</a>
<a name="ln760"> </a>
<a name="ln761">		/* JPA update v3.x extensions, ensuring consistency */</a>
<a name="ln762"> </a>
<a name="ln763">	lthle = ctx-&gt;attr-&gt;length;</a>
<a name="ln764">	lth = le32_to_cpu(lthle);</a>
<a name="ln765">	if (test_nino_flag(ni, v3_Extensions)</a>
<a name="ln766">	    &amp;&amp; (lth &lt;= sizeof(STANDARD_INFORMATION)))</a>
<a name="ln767">		ntfs_log_error(&quot;bad sync of standard information\n&quot;);</a>
<a name="ln768"> </a>
<a name="ln769">	if (lth &gt; sizeof(STANDARD_INFORMATION)) {</a>
<a name="ln770">		std_info-&gt;owner_id = ni-&gt;owner_id;</a>
<a name="ln771">		std_info-&gt;security_id = ni-&gt;security_id;</a>
<a name="ln772">		std_info-&gt;quota_charged = ni-&gt;quota_charged;</a>
<a name="ln773">		std_info-&gt;usn = ni-&gt;usn;</a>
<a name="ln774">	}</a>
<a name="ln775">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln776">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln777">	return 0;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">/**</a>
<a name="ln781"> * ntfs_inode_sync_file_name - update FILE_NAME attributes</a>
<a name="ln782"> * @ni:		ntfs inode to update FILE_NAME attributes</a>
<a name="ln783"> *</a>
<a name="ln784"> * Update all FILE_NAME attributes for inode @ni in the index.</a>
<a name="ln785"> *</a>
<a name="ln786"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln787"> */</a>
<a name="ln788">static int ntfs_inode_sync_file_name(ntfs_inode *ni, ntfs_inode *dir_ni)</a>
<a name="ln789">{</a>
<a name="ln790">	ntfs_attr_search_ctx *ctx = NULL;</a>
<a name="ln791">	ntfs_index_context *ictx;</a>
<a name="ln792">	ntfs_inode *index_ni;</a>
<a name="ln793">	FILE_NAME_ATTR *fn;</a>
<a name="ln794">	FILE_NAME_ATTR *fnx;</a>
<a name="ln795">	REPARSE_POINT *rpp;</a>
<a name="ln796">	le32 reparse_tag;</a>
<a name="ln797">	int err = 0;</a>
<a name="ln798"> </a>
<a name="ln799">	ntfs_log_trace(&quot;Entering for inode %lld\n&quot;, (long long)ni-&gt;mft_no);</a>
<a name="ln800"> </a>
<a name="ln801">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln802">	if (!ctx) {</a>
<a name="ln803">		err = errno;</a>
<a name="ln804">		goto err_out;</a>
<a name="ln805">	}</a>
<a name="ln806">	/* Collect the reparse tag, if any */</a>
<a name="ln807">	reparse_tag = const_cpu_to_le32(0);</a>
<a name="ln808">	if (ni-&gt;flags &amp; FILE_ATTR_REPARSE_POINT) {</a>
<a name="ln809">		if (!ntfs_attr_lookup(AT_REPARSE_POINT, NULL,</a>
<a name="ln810">				0, CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln811">			rpp = (REPARSE_POINT*)((u8 *)ctx-&gt;attr +</a>
<a name="ln812">					le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln813">			reparse_tag = rpp-&gt;reparse_tag;</a>
<a name="ln814">		}</a>
<a name="ln815">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln816">	}</a>
<a name="ln817">	/* Walk through all FILE_NAME attributes and update them. */</a>
<a name="ln818">	while (!ntfs_attr_lookup(AT_FILE_NAME, NULL, 0, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln819">		fn = (FILE_NAME_ATTR *)((u8 *)ctx-&gt;attr +</a>
<a name="ln820">				le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln821">		if (MREF_LE(fn-&gt;parent_directory) == ni-&gt;mft_no) {</a>
<a name="ln822">			/*</a>
<a name="ln823">			 * WARNING: We cheat here and obtain 2 attribute</a>
<a name="ln824">			 * search contexts for one inode (first we obtained</a>
<a name="ln825">			 * above, second will be obtained inside</a>
<a name="ln826">			 * ntfs_index_lookup), it's acceptable for library,</a>
<a name="ln827">			 * but will deadlock in the kernel.</a>
<a name="ln828">			 */</a>
<a name="ln829">			index_ni = ni;</a>
<a name="ln830">		} else</a>
<a name="ln831">			if (dir_ni)</a>
<a name="ln832">				index_ni = dir_ni;</a>
<a name="ln833">			else</a>
<a name="ln834">				index_ni = ntfs_inode_open(ni-&gt;vol, </a>
<a name="ln835">					le64_to_cpu(fn-&gt;parent_directory));</a>
<a name="ln836">		if (!index_ni) {</a>
<a name="ln837">			if (!err)</a>
<a name="ln838">				err = errno;</a>
<a name="ln839">			ntfs_log_perror(&quot;Failed to open inode %lld with index&quot;,</a>
<a name="ln840">				(long long)le64_to_cpu(fn-&gt;parent_directory));</a>
<a name="ln841">			continue;</a>
<a name="ln842">		}</a>
<a name="ln843">		ictx = ntfs_index_ctx_get(index_ni, NTFS_INDEX_I30, 4);</a>
<a name="ln844">		if (!ictx) {</a>
<a name="ln845">			if (!err)</a>
<a name="ln846">				err = errno;</a>
<a name="ln847">			ntfs_log_perror(&quot;Failed to get index ctx, inode %lld&quot;,</a>
<a name="ln848">					(long long)index_ni-&gt;mft_no);</a>
<a name="ln849">			if ((ni != index_ni) &amp;&amp; !dir_ni</a>
<a name="ln850">			    &amp;&amp; ntfs_inode_close(index_ni) &amp;&amp; !err)</a>
<a name="ln851">				err = errno;</a>
<a name="ln852">			continue;</a>
<a name="ln853">		}</a>
<a name="ln854">		if (ntfs_index_lookup(fn, sizeof(FILE_NAME_ATTR), ictx)) {</a>
<a name="ln855">			if (!err) {</a>
<a name="ln856">				if (errno == ENOENT)</a>
<a name="ln857">					err = EIO;</a>
<a name="ln858">				else</a>
<a name="ln859">					err = errno;</a>
<a name="ln860">			}</a>
<a name="ln861">			ntfs_log_perror(&quot;Index lookup failed, inode %lld&quot;,</a>
<a name="ln862">					(long long)index_ni-&gt;mft_no);</a>
<a name="ln863">			ntfs_index_ctx_put(ictx);</a>
<a name="ln864">			if (ni != index_ni &amp;&amp; ntfs_inode_close(index_ni) &amp;&amp; !err)</a>
<a name="ln865">				err = errno;</a>
<a name="ln866">			continue;</a>
<a name="ln867">		}</a>
<a name="ln868">		/* Update flags and file size. */</a>
<a name="ln869">		fnx = (FILE_NAME_ATTR *)ictx-&gt;data;</a>
<a name="ln870">		fnx-&gt;file_attributes =</a>
<a name="ln871">				(fnx-&gt;file_attributes &amp; ~FILE_ATTR_VALID_FLAGS) |</a>
<a name="ln872">				(ni-&gt;flags &amp; FILE_ATTR_VALID_FLAGS);</a>
<a name="ln873">		if (ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY)</a>
<a name="ln874">			fnx-&gt;data_size = fnx-&gt;allocated_size</a>
<a name="ln875">				= const_cpu_to_sle64(0);</a>
<a name="ln876">		else {</a>
<a name="ln877">			fnx-&gt;allocated_size = cpu_to_sle64(ni-&gt;allocated_size);</a>
<a name="ln878">			fnx-&gt;data_size = cpu_to_sle64(ni-&gt;data_size);</a>
<a name="ln879">			/*</a>
<a name="ln880">			 * The file name record has also to be fixed if some</a>
<a name="ln881">			 * attribute update implied the unnamed data to be</a>
<a name="ln882">			 * made non-resident</a>
<a name="ln883">			 */</a>
<a name="ln884">			fn-&gt;allocated_size = fnx-&gt;allocated_size;</a>
<a name="ln885">		}</a>
<a name="ln886">			/* update or clear the reparse tag in the index */</a>
<a name="ln887">		fnx-&gt;reparse_point_tag = reparse_tag;</a>
<a name="ln888">		if (!test_nino_flag(ni, TimesSet)) {</a>
<a name="ln889">			fnx-&gt;creation_time = ni-&gt;creation_time;</a>
<a name="ln890">			fnx-&gt;last_data_change_time = ni-&gt;last_data_change_time;</a>
<a name="ln891">			fnx-&gt;last_mft_change_time = ni-&gt;last_mft_change_time;</a>
<a name="ln892">			fnx-&gt;last_access_time = ni-&gt;last_access_time;</a>
<a name="ln893">		} else {</a>
<a name="ln894">			fnx-&gt;creation_time = fn-&gt;creation_time;</a>
<a name="ln895">			fnx-&gt;last_data_change_time = fn-&gt;last_data_change_time;</a>
<a name="ln896">			fnx-&gt;last_mft_change_time = fn-&gt;last_mft_change_time;</a>
<a name="ln897">			fnx-&gt;last_access_time = fn-&gt;last_access_time;</a>
<a name="ln898">		}</a>
<a name="ln899">		ntfs_index_entry_mark_dirty(ictx);</a>
<a name="ln900">		ntfs_index_ctx_put(ictx);</a>
<a name="ln901">		if ((ni != index_ni) &amp;&amp; !dir_ni</a>
<a name="ln902">		    &amp;&amp; ntfs_inode_close(index_ni) &amp;&amp; !err)</a>
<a name="ln903">			err = errno;</a>
<a name="ln904">	}</a>
<a name="ln905">	/* Check for real error occurred. */</a>
<a name="ln906">	if (errno != ENOENT) {</a>
<a name="ln907">		err = errno;</a>
<a name="ln908">		ntfs_log_perror(&quot;Attribute lookup failed, inode %lld&quot;,</a>
<a name="ln909">				(long long)ni-&gt;mft_no);</a>
<a name="ln910">		goto err_out;</a>
<a name="ln911">	}</a>
<a name="ln912">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln913">	if (err) {</a>
<a name="ln914">		errno = err;</a>
<a name="ln915">		return -1;</a>
<a name="ln916">	}</a>
<a name="ln917">	return 0;</a>
<a name="ln918">err_out:</a>
<a name="ln919">	if (ctx)</a>
<a name="ln920">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln921">	errno = err;</a>
<a name="ln922">	return -1;</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">/**</a>
<a name="ln926"> * ntfs_inode_sync - write the inode (and its dirty extents) to disk</a>
<a name="ln927"> * @ni:		ntfs inode to write</a>
<a name="ln928"> *</a>
<a name="ln929"> * Write the inode @ni to disk as well as its dirty extent inodes if such</a>
<a name="ln930"> * exist and @ni is a base inode. If @ni is an extent inode, only @ni is</a>
<a name="ln931"> * written completely disregarding its base inode and any other extent inodes.</a>
<a name="ln932"> *</a>
<a name="ln933"> * For a base inode with dirty extent inodes if any writes fail for whatever</a>
<a name="ln934"> * reason, the failing inode is skipped and the sync process is continued. At</a>
<a name="ln935"> * the end the error condition that brought about the failure is returned. Thus</a>
<a name="ln936"> * the smallest amount of data loss possible occurs.</a>
<a name="ln937"> *</a>
<a name="ln938"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln939"> * The following error codes are defined:</a>
<a name="ln940"> *	EINVAL	- Invalid arguments were passed to the function.</a>
<a name="ln941"> *	EBUSY	- Inode and/or one of its extents is busy, try again later.</a>
<a name="ln942"> *	EIO	- I/O error while writing the inode (or one of its extents).</a>
<a name="ln943"> */</a>
<a name="ln944">static int ntfs_inode_sync_in_dir(ntfs_inode *ni, ntfs_inode *dir_ni)</a>
<a name="ln945">{</a>
<a name="ln946">	int ret = 0;</a>
<a name="ln947">	int err = 0;</a>
<a name="ln948">	if (!ni) {</a>
<a name="ln949">		errno = EINVAL;</a>
<a name="ln950">		ntfs_log_error(&quot;Failed to sync NULL inode\n&quot;);</a>
<a name="ln951">		return -1;</a>
<a name="ln952">	}</a>
<a name="ln953"> </a>
<a name="ln954">	ntfs_log_enter(&quot;Entering for inode %lld\n&quot;, (long long)ni-&gt;mft_no);</a>
<a name="ln955"> </a>
<a name="ln956">	/* Update STANDARD_INFORMATION. */</a>
<a name="ln957">	if ((ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IN_USE) &amp;&amp; ni-&gt;nr_extents != -1 &amp;&amp;</a>
<a name="ln958">			ntfs_inode_sync_standard_information(ni)) {</a>
<a name="ln959">		if (!err || errno == EIO) {</a>
<a name="ln960">			err = errno;</a>
<a name="ln961">			if (err != EIO)</a>
<a name="ln962">				err = EBUSY;</a>
<a name="ln963">		}</a>
<a name="ln964">	}</a>
<a name="ln965"> </a>
<a name="ln966">	/* Update FILE_NAME's in the index. */</a>
<a name="ln967">	if ((ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IN_USE) &amp;&amp; ni-&gt;nr_extents != -1 &amp;&amp;</a>
<a name="ln968">			NInoFileNameTestAndClearDirty(ni) &amp;&amp;</a>
<a name="ln969">			ntfs_inode_sync_file_name(ni, dir_ni)) {</a>
<a name="ln970">		if (!err || errno == EIO) {</a>
<a name="ln971">			err = errno;</a>
<a name="ln972">			if (err != EIO)</a>
<a name="ln973">				err = EBUSY;</a>
<a name="ln974">		}</a>
<a name="ln975">		ntfs_log_perror(&quot;Failed to sync FILE_NAME (inode %lld)&quot;,</a>
<a name="ln976">				(long long)ni-&gt;mft_no);</a>
<a name="ln977">		NInoFileNameSetDirty(ni);</a>
<a name="ln978">	}</a>
<a name="ln979"> </a>
<a name="ln980">	/* Write out attribute list from cache to disk. */</a>
<a name="ln981">	if ((ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IN_USE) &amp;&amp; ni-&gt;nr_extents != -1 &amp;&amp;</a>
<a name="ln982">			NInoAttrList(ni) &amp;&amp; NInoAttrListTestAndClearDirty(ni)) {</a>
<a name="ln983">		ntfs_attr *na;</a>
<a name="ln984"> </a>
<a name="ln985">		na = ntfs_attr_open(ni, AT_ATTRIBUTE_LIST, AT_UNNAMED, 0);</a>
<a name="ln986">		if (!na) {</a>
<a name="ln987">			if (!err || errno == EIO) {</a>
<a name="ln988">				err = errno;</a>
<a name="ln989">				if (err != EIO)</a>
<a name="ln990">					err = EBUSY;</a>
<a name="ln991">				ntfs_log_perror(&quot;Attribute list sync failed &quot;</a>
<a name="ln992">						&quot;(open, inode %lld)&quot;,</a>
<a name="ln993">						(long long)ni-&gt;mft_no);</a>
<a name="ln994">			}</a>
<a name="ln995">			NInoAttrListSetDirty(ni);</a>
<a name="ln996">			goto sync_inode;</a>
<a name="ln997">		} </a>
<a name="ln998">		</a>
<a name="ln999">		if (na-&gt;data_size == ni-&gt;attr_list_size) {</a>
<a name="ln1000">			if (ntfs_attr_pwrite(na, 0, ni-&gt;attr_list_size,</a>
<a name="ln1001">				        ni-&gt;attr_list) != ni-&gt;attr_list_size) {</a>
<a name="ln1002">				if (!err || errno == EIO) {</a>
<a name="ln1003">					err = errno;</a>
<a name="ln1004">					if (err != EIO)</a>
<a name="ln1005">						err = EBUSY;</a>
<a name="ln1006">					ntfs_log_perror(&quot;Attribute list sync &quot;</a>
<a name="ln1007">						&quot;failed (write, inode %lld)&quot;,</a>
<a name="ln1008">						(long long)ni-&gt;mft_no);</a>
<a name="ln1009">				}</a>
<a name="ln1010">				NInoAttrListSetDirty(ni);</a>
<a name="ln1011">			}</a>
<a name="ln1012">		} else {</a>
<a name="ln1013">			err = EIO;</a>
<a name="ln1014">			ntfs_log_error(&quot;Attribute list sync failed (bad size, &quot;</a>
<a name="ln1015">				       &quot;inode %lld)\n&quot;, (long long)ni-&gt;mft_no);</a>
<a name="ln1016">			NInoAttrListSetDirty(ni);</a>
<a name="ln1017">		}</a>
<a name="ln1018">		ntfs_attr_close(na);</a>
<a name="ln1019">	}</a>
<a name="ln1020">	</a>
<a name="ln1021">sync_inode:</a>
<a name="ln1022">	/* Write this inode out to the $MFT (and $MFTMirr if applicable). */</a>
<a name="ln1023">	if (NInoTestAndClearDirty(ni)) {</a>
<a name="ln1024">		if (ntfs_mft_record_write(ni-&gt;vol, ni-&gt;mft_no, ni-&gt;mrec)) {</a>
<a name="ln1025">			if (!err || errno == EIO) {</a>
<a name="ln1026">				err = errno;</a>
<a name="ln1027">				if (err != EIO)</a>
<a name="ln1028">					err = EBUSY;</a>
<a name="ln1029">			}</a>
<a name="ln1030">			NInoSetDirty(ni);</a>
<a name="ln1031">			ntfs_log_perror(&quot;MFT record sync failed, inode %lld&quot;,</a>
<a name="ln1032">					(long long)ni-&gt;mft_no);</a>
<a name="ln1033">		}</a>
<a name="ln1034">	}</a>
<a name="ln1035"> </a>
<a name="ln1036">	/* If this is a base inode with extents write all dirty extents, too. */</a>
<a name="ln1037">	if (ni-&gt;nr_extents &gt; 0) {</a>
<a name="ln1038">		s32 i;</a>
<a name="ln1039"> </a>
<a name="ln1040">		for (i = 0; i &lt; ni-&gt;nr_extents; ++i) {</a>
<a name="ln1041">			ntfs_inode *eni;</a>
<a name="ln1042"> </a>
<a name="ln1043">			eni = ni-&gt;extent_nis[i];</a>
<a name="ln1044">			if (!NInoTestAndClearDirty(eni))</a>
<a name="ln1045">				continue;</a>
<a name="ln1046">			</a>
<a name="ln1047">			if (ntfs_mft_record_write(eni-&gt;vol, eni-&gt;mft_no, </a>
<a name="ln1048">						  eni-&gt;mrec)) {</a>
<a name="ln1049">				if (!err || errno == EIO) {</a>
<a name="ln1050">					err = errno;</a>
<a name="ln1051">					if (err != EIO)</a>
<a name="ln1052">						err = EBUSY;</a>
<a name="ln1053">				}</a>
<a name="ln1054">				NInoSetDirty(eni);</a>
<a name="ln1055">				ntfs_log_perror(&quot;Extent MFT record sync failed,&quot;</a>
<a name="ln1056">						&quot; inode %lld/%lld&quot;,</a>
<a name="ln1057">						(long long)ni-&gt;mft_no,</a>
<a name="ln1058">						(long long)eni-&gt;mft_no);</a>
<a name="ln1059">			}</a>
<a name="ln1060">		}</a>
<a name="ln1061">	}</a>
<a name="ln1062"> </a>
<a name="ln1063">	if (err) {</a>
<a name="ln1064">		errno = err;</a>
<a name="ln1065">		ret = -1;</a>
<a name="ln1066">	}</a>
<a name="ln1067">	</a>
<a name="ln1068">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln1069">	return ret;</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072">int ntfs_inode_sync(ntfs_inode *ni)</a>
<a name="ln1073">{</a>
<a name="ln1074">	return (ntfs_inode_sync_in_dir(ni, (ntfs_inode*)NULL));</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">/*</a>
<a name="ln1078"> *		Close an inode with an open parent inode</a>
<a name="ln1079"> */</a>
<a name="ln1080"> </a>
<a name="ln1081">int ntfs_inode_close_in_dir(ntfs_inode *ni, ntfs_inode *dir_ni)</a>
<a name="ln1082">{</a>
<a name="ln1083">	int res;</a>
<a name="ln1084"> </a>
<a name="ln1085">	res = ntfs_inode_sync_in_dir(ni, dir_ni);</a>
<a name="ln1086">	if (res) {</a>
<a name="ln1087">		if (errno != EIO)</a>
<a name="ln1088">			errno = EBUSY;</a>
<a name="ln1089">	} else</a>
<a name="ln1090">		res = ntfs_inode_close(ni);</a>
<a name="ln1091">	return (res);</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">/**</a>
<a name="ln1095"> * ntfs_inode_add_attrlist - add attribute list to inode and fill it</a>
<a name="ln1096"> * @ni: opened ntfs inode to which add attribute list</a>
<a name="ln1097"> *</a>
<a name="ln1098"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln1099"> * The following error codes are defined:</a>
<a name="ln1100"> *	EINVAL	- Invalid arguments were passed to the function.</a>
<a name="ln1101"> *	EEXIST	- Attribute list already exist.</a>
<a name="ln1102"> *	EIO	- Input/Ouput error occurred.</a>
<a name="ln1103"> *	ENOMEM	- Not enough memory to perform add.</a>
<a name="ln1104"> */</a>
<a name="ln1105">int ntfs_inode_add_attrlist(ntfs_inode *ni)</a>
<a name="ln1106">{</a>
<a name="ln1107">	int err;</a>
<a name="ln1108">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1109">	u8 *al = NULL, *aln;</a>
<a name="ln1110">	int al_len = 0;</a>
<a name="ln1111">	ATTR_LIST_ENTRY *ale = NULL;</a>
<a name="ln1112">	ntfs_attr *na;</a>
<a name="ln1113"> </a>
<a name="ln1114">	if (!ni) {</a>
<a name="ln1115">		errno = EINVAL;</a>
<a name="ln1116">		ntfs_log_perror(&quot;%s&quot;, __FUNCTION__);</a>
<a name="ln1117">		return -1;</a>
<a name="ln1118">	}</a>
<a name="ln1119"> </a>
<a name="ln1120">	ntfs_log_trace(&quot;inode %llu\n&quot;, (unsigned long long) ni-&gt;mft_no);</a>
<a name="ln1121"> </a>
<a name="ln1122">	if (NInoAttrList(ni) || ni-&gt;nr_extents) {</a>
<a name="ln1123">		errno = EEXIST;</a>
<a name="ln1124">		ntfs_log_perror(&quot;Inode already has attribute list&quot;);</a>
<a name="ln1125">		return -1;</a>
<a name="ln1126">	}</a>
<a name="ln1127"> </a>
<a name="ln1128">	/* Form attribute list. */</a>
<a name="ln1129">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln1130">	if (!ctx) {</a>
<a name="ln1131">		err = errno;</a>
<a name="ln1132">		goto err_out;</a>
<a name="ln1133">	}</a>
<a name="ln1134">	/* Walk through all attributes. */</a>
<a name="ln1135">	while (!ntfs_attr_lookup(AT_UNUSED, NULL, 0, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln1136">		</a>
<a name="ln1137">		int ale_size;</a>
<a name="ln1138">		</a>
<a name="ln1139">		if (ctx-&gt;attr-&gt;type == AT_ATTRIBUTE_LIST) {</a>
<a name="ln1140">			err = EIO;</a>
<a name="ln1141">			ntfs_log_perror(&quot;Attribute list already present&quot;);</a>
<a name="ln1142">			goto put_err_out;</a>
<a name="ln1143">		}</a>
<a name="ln1144">		</a>
<a name="ln1145">		ale_size = (sizeof(ATTR_LIST_ENTRY) + sizeof(ntfschar) *</a>
<a name="ln1146">					ctx-&gt;attr-&gt;name_length + 7) &amp; ~7;</a>
<a name="ln1147">		al_len += ale_size;</a>
<a name="ln1148">		</a>
<a name="ln1149">		aln = realloc(al, al_len);</a>
<a name="ln1150">		if (!aln) {</a>
<a name="ln1151">			err = errno;</a>
<a name="ln1152">			ntfs_log_perror(&quot;Failed to realloc %d bytes&quot;, al_len);</a>
<a name="ln1153">			goto put_err_out;</a>
<a name="ln1154">		}</a>
<a name="ln1155">		ale = (ATTR_LIST_ENTRY *)(aln + ((u8 *)ale - al));</a>
<a name="ln1156">		al = aln;</a>
<a name="ln1157">		</a>
<a name="ln1158">		memset(ale, 0, ale_size);</a>
<a name="ln1159">		</a>
<a name="ln1160">		/* Add attribute to attribute list. */</a>
<a name="ln1161">		ale-&gt;type = ctx-&gt;attr-&gt;type;</a>
<a name="ln1162">		ale-&gt;length = cpu_to_le16((sizeof(ATTR_LIST_ENTRY) +</a>
<a name="ln1163">			sizeof(ntfschar) * ctx-&gt;attr-&gt;name_length + 7) &amp; ~7);</a>
<a name="ln1164">		ale-&gt;name_length = ctx-&gt;attr-&gt;name_length;</a>
<a name="ln1165">		ale-&gt;name_offset = (u8 *)ale-&gt;name - (u8 *)ale;</a>
<a name="ln1166">		if (ctx-&gt;attr-&gt;non_resident)</a>
<a name="ln1167">			ale-&gt;lowest_vcn = ctx-&gt;attr-&gt;lowest_vcn;</a>
<a name="ln1168">		else</a>
<a name="ln1169">			ale-&gt;lowest_vcn = const_cpu_to_sle64(0);</a>
<a name="ln1170">		ale-&gt;mft_reference = MK_LE_MREF(ni-&gt;mft_no,</a>
<a name="ln1171">			le16_to_cpu(ni-&gt;mrec-&gt;sequence_number));</a>
<a name="ln1172">		ale-&gt;instance = ctx-&gt;attr-&gt;instance;</a>
<a name="ln1173">		memcpy(ale-&gt;name, (u8 *)ctx-&gt;attr +</a>
<a name="ln1174">				le16_to_cpu(ctx-&gt;attr-&gt;name_offset),</a>
<a name="ln1175">				ctx-&gt;attr-&gt;name_length * sizeof(ntfschar));</a>
<a name="ln1176">		ale = (ATTR_LIST_ENTRY *)(al + al_len);</a>
<a name="ln1177">	}</a>
<a name="ln1178">	/* Check for real error occurred. */</a>
<a name="ln1179">	if (errno != ENOENT) {</a>
<a name="ln1180">		err = errno;</a>
<a name="ln1181">		ntfs_log_perror(&quot;%s: Attribute lookup failed, inode %lld&quot;,</a>
<a name="ln1182">				__FUNCTION__, (long long)ni-&gt;mft_no);</a>
<a name="ln1183">		goto put_err_out;</a>
<a name="ln1184">	}</a>
<a name="ln1185"> </a>
<a name="ln1186">	/* Set in-memory attribute list. */</a>
<a name="ln1187">	ni-&gt;attr_list = al;</a>
<a name="ln1188">	ni-&gt;attr_list_size = al_len;</a>
<a name="ln1189">	NInoSetAttrList(ni);</a>
<a name="ln1190">	NInoAttrListSetDirty(ni);</a>
<a name="ln1191"> </a>
<a name="ln1192">	/* Free space if there is not enough it for $ATTRIBUTE_LIST. */</a>
<a name="ln1193">	if (le32_to_cpu(ni-&gt;mrec-&gt;bytes_allocated) -</a>
<a name="ln1194">			le32_to_cpu(ni-&gt;mrec-&gt;bytes_in_use) &lt;</a>
<a name="ln1195">			offsetof(ATTR_RECORD, resident_end)) {</a>
<a name="ln1196">		if (ntfs_inode_free_space(ni,</a>
<a name="ln1197">				offsetof(ATTR_RECORD, resident_end))) {</a>
<a name="ln1198">			/* Failed to free space. */</a>
<a name="ln1199">			err = errno;</a>
<a name="ln1200">			ntfs_log_perror(&quot;Failed to free space for attrlist&quot;);</a>
<a name="ln1201">			goto rollback;</a>
<a name="ln1202">		}</a>
<a name="ln1203">	}</a>
<a name="ln1204"> </a>
<a name="ln1205">	/* Add $ATTRIBUTE_LIST to mft record. */</a>
<a name="ln1206">	if (ntfs_resident_attr_record_add(ni,</a>
<a name="ln1207">				AT_ATTRIBUTE_LIST, NULL, 0, NULL, 0, const_cpu_to_le16(0)) &lt; 0) {</a>
<a name="ln1208">		err = errno;</a>
<a name="ln1209">		ntfs_log_perror(&quot;Couldn't add $ATTRIBUTE_LIST to MFT&quot;);</a>
<a name="ln1210">		goto rollback;</a>
<a name="ln1211">	}</a>
<a name="ln1212"> </a>
<a name="ln1213">	/* Resize it. */</a>
<a name="ln1214">	na = ntfs_attr_open(ni, AT_ATTRIBUTE_LIST, AT_UNNAMED, 0);</a>
<a name="ln1215">	if (!na) {</a>
<a name="ln1216">		err = errno;</a>
<a name="ln1217">		ntfs_log_perror(&quot;Failed to open just added $ATTRIBUTE_LIST&quot;);</a>
<a name="ln1218">		goto remove_attrlist_record;</a>
<a name="ln1219">	}</a>
<a name="ln1220">	if (ntfs_attr_truncate(na, al_len)) {</a>
<a name="ln1221">		err = errno;</a>
<a name="ln1222">		ntfs_log_perror(&quot;Failed to resize just added $ATTRIBUTE_LIST&quot;);</a>
<a name="ln1223">		ntfs_attr_close(na);</a>
<a name="ln1224">		goto remove_attrlist_record;;</a>
<a name="ln1225">	}</a>
<a name="ln1226">	</a>
<a name="ln1227">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1228">	ntfs_attr_close(na);</a>
<a name="ln1229">	return 0;</a>
<a name="ln1230"> </a>
<a name="ln1231">remove_attrlist_record:</a>
<a name="ln1232">	/* Prevent ntfs_attr_recorm_rm from freeing attribute list. */</a>
<a name="ln1233">	ni-&gt;attr_list = NULL;</a>
<a name="ln1234">	NInoClearAttrList(ni);</a>
<a name="ln1235">	/* Remove $ATTRIBUTE_LIST record. */</a>
<a name="ln1236">	ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln1237">	if (!ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0,</a>
<a name="ln1238">				CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln1239">		if (ntfs_attr_record_rm(ctx))</a>
<a name="ln1240">			ntfs_log_perror(&quot;Rollback failed to remove attrlist&quot;);</a>
<a name="ln1241">	} else</a>
<a name="ln1242">		ntfs_log_perror(&quot;Rollback failed to find attrlist&quot;);</a>
<a name="ln1243">	/* Setup back in-memory runlist. */</a>
<a name="ln1244">	ni-&gt;attr_list = al;</a>
<a name="ln1245">	ni-&gt;attr_list_size = al_len;</a>
<a name="ln1246">	NInoSetAttrList(ni);</a>
<a name="ln1247">rollback:</a>
<a name="ln1248">	/*</a>
<a name="ln1249">	 * Scan attribute list for attributes that placed not in the base MFT</a>
<a name="ln1250">	 * record and move them to it.</a>
<a name="ln1251">	 */</a>
<a name="ln1252">	ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln1253">	ale = (ATTR_LIST_ENTRY*)al;</a>
<a name="ln1254">	while ((u8*)ale &lt; al + al_len) {</a>
<a name="ln1255">		if (MREF_LE(ale-&gt;mft_reference) != ni-&gt;mft_no) {</a>
<a name="ln1256">			if (!ntfs_attr_lookup(ale-&gt;type, ale-&gt;name,</a>
<a name="ln1257">						ale-&gt;name_length,</a>
<a name="ln1258">						CASE_SENSITIVE,</a>
<a name="ln1259">						sle64_to_cpu(ale-&gt;lowest_vcn),</a>
<a name="ln1260">						NULL, 0, ctx)) {</a>
<a name="ln1261">				if (ntfs_attr_record_move_to(ctx, ni))</a>
<a name="ln1262">					ntfs_log_perror(&quot;Rollback failed to &quot;</a>
<a name="ln1263">							&quot;move attribute&quot;);</a>
<a name="ln1264">			} else</a>
<a name="ln1265">				ntfs_log_perror(&quot;Rollback failed to find attr&quot;);</a>
<a name="ln1266">			ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln1267">		}</a>
<a name="ln1268">		ale = (ATTR_LIST_ENTRY*)((u8*)ale + le16_to_cpu(ale-&gt;length));</a>
<a name="ln1269">	}</a>
<a name="ln1270">	/* Remove in-memory attribute list. */</a>
<a name="ln1271">	ni-&gt;attr_list = NULL;</a>
<a name="ln1272">	ni-&gt;attr_list_size = 0;</a>
<a name="ln1273">	NInoClearAttrList(ni);</a>
<a name="ln1274">	NInoAttrListClearDirty(ni);</a>
<a name="ln1275">put_err_out:</a>
<a name="ln1276">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1277">err_out:</a>
<a name="ln1278">	free(al);</a>
<a name="ln1279">	errno = err;</a>
<a name="ln1280">	return -1;</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283">/**</a>
<a name="ln1284"> * ntfs_inode_free_space - free space in the MFT record of an inode</a>
<a name="ln1285"> * @ni:		ntfs inode in which MFT record needs more free space</a>
<a name="ln1286"> * @size:	amount of space needed to free</a>
<a name="ln1287"> *</a>
<a name="ln1288"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln1289"> */</a>
<a name="ln1290">int ntfs_inode_free_space(ntfs_inode *ni, int size)</a>
<a name="ln1291">{</a>
<a name="ln1292">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1293">	int freed;</a>
<a name="ln1294"> </a>
<a name="ln1295">	if (!ni || size &lt; 0) {</a>
<a name="ln1296">		errno = EINVAL;</a>
<a name="ln1297">		ntfs_log_perror(&quot;%s: ni=%p size=%d&quot;, __FUNCTION__, ni, size);</a>
<a name="ln1298">		return -1;</a>
<a name="ln1299">	}</a>
<a name="ln1300"> </a>
<a name="ln1301">	ntfs_log_trace(&quot;Entering for inode %lld, size %d\n&quot;,</a>
<a name="ln1302">		       (unsigned long long)ni-&gt;mft_no, size);</a>
<a name="ln1303"> </a>
<a name="ln1304">	freed = (le32_to_cpu(ni-&gt;mrec-&gt;bytes_allocated) -</a>
<a name="ln1305">				le32_to_cpu(ni-&gt;mrec-&gt;bytes_in_use));</a>
<a name="ln1306"> </a>
<a name="ln1307">	if (size &lt;= freed)</a>
<a name="ln1308">		return 0;</a>
<a name="ln1309"> </a>
<a name="ln1310">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln1311">	if (!ctx)</a>
<a name="ln1312">		return -1;</a>
<a name="ln1313">	/*</a>
<a name="ln1314">	 * $STANDARD_INFORMATION and $ATTRIBUTE_LIST must stay in the base MFT</a>
<a name="ln1315">	 * record, so position search context on the first attribute after them.</a>
<a name="ln1316">	 */</a>
<a name="ln1317">	if (ntfs_attr_position(AT_FILE_NAME, ctx))</a>
<a name="ln1318">		goto put_err_out;</a>
<a name="ln1319"> </a>
<a name="ln1320">	while (1) {</a>
<a name="ln1321">		int record_size;</a>
<a name="ln1322">		/*</a>
<a name="ln1323">		 * Check whether attribute is from different MFT record. If so,</a>
<a name="ln1324">		 * find next, because we don't need such.</a>
<a name="ln1325">		 */</a>
<a name="ln1326">		while (ctx-&gt;ntfs_ino-&gt;mft_no != ni-&gt;mft_no) {</a>
<a name="ln1327">retry:			</a>
<a name="ln1328">			if (ntfs_attr_position(AT_UNUSED, ctx))</a>
<a name="ln1329">				goto put_err_out;</a>
<a name="ln1330">		}</a>
<a name="ln1331"> </a>
<a name="ln1332">		if (ntfs_inode_base(ctx-&gt;ntfs_ino)-&gt;mft_no == FILE_MFT &amp;&amp; </a>
<a name="ln1333">		    ctx-&gt;attr-&gt;type == AT_DATA)</a>
<a name="ln1334">			goto retry;</a>
<a name="ln1335"> </a>
<a name="ln1336">		if (ctx-&gt;attr-&gt;type == AT_INDEX_ROOT)</a>
<a name="ln1337">			goto retry;</a>
<a name="ln1338"> </a>
<a name="ln1339">		record_size = le32_to_cpu(ctx-&gt;attr-&gt;length);</a>
<a name="ln1340"> </a>
<a name="ln1341">		if (ntfs_attr_record_move_away(ctx, 0)) {</a>
<a name="ln1342">			ntfs_log_perror(&quot;Failed to move out attribute #2&quot;);</a>
<a name="ln1343">			break;</a>
<a name="ln1344">		}</a>
<a name="ln1345">		freed += record_size;</a>
<a name="ln1346"> </a>
<a name="ln1347">		/* Check whether we are done. */</a>
<a name="ln1348">		if (size &lt;= freed) {</a>
<a name="ln1349">			ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1350">			return 0;</a>
<a name="ln1351">		}</a>
<a name="ln1352">		/*</a>
<a name="ln1353">		 * Reposition to first attribute after $STANDARD_INFORMATION </a>
<a name="ln1354">		 * and $ATTRIBUTE_LIST instead of simply skipping this attribute </a>
<a name="ln1355">		 * because in the case when we have got only in-memory attribute </a>
<a name="ln1356">		 * list then ntfs_attr_lookup will fail when it tries to find </a>
<a name="ln1357">		 * $ATTRIBUTE_LIST.</a>
<a name="ln1358">		 */</a>
<a name="ln1359">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln1360">		if (ntfs_attr_position(AT_FILE_NAME, ctx))</a>
<a name="ln1361">			break;</a>
<a name="ln1362">	}</a>
<a name="ln1363">put_err_out:</a>
<a name="ln1364">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1365">	if (errno == ENOSPC)</a>
<a name="ln1366">		ntfs_log_trace(&quot;No attributes left that could be moved out.\n&quot;);</a>
<a name="ln1367">	return -1;</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370">/**</a>
<a name="ln1371"> * ntfs_inode_update_times - update selected time fields for ntfs inode</a>
<a name="ln1372"> * @ni:		ntfs inode for which update time fields</a>
<a name="ln1373"> * @mask:	select which time fields should be updated</a>
<a name="ln1374"> *</a>
<a name="ln1375"> * This function updates time fields to current time. Fields to update are</a>
<a name="ln1376"> * selected using @mask (see enum @ntfs_time_update_flags for posssible values).</a>
<a name="ln1377"> */</a>
<a name="ln1378">void ntfs_inode_update_times(ntfs_inode *ni, ntfs_time_update_flags mask)</a>
<a name="ln1379">{</a>
<a name="ln1380">	ntfs_time now;</a>
<a name="ln1381"> </a>
<a name="ln1382">	if (!ni) {</a>
<a name="ln1383">		ntfs_log_error(&quot;%s(): Invalid arguments.\n&quot;, __FUNCTION__);</a>
<a name="ln1384">		return;</a>
<a name="ln1385">	}</a>
<a name="ln1386"> </a>
<a name="ln1387">	if ((ni-&gt;mft_no &lt; FILE_first_user &amp;&amp; ni-&gt;mft_no != FILE_root) ||</a>
<a name="ln1388">			NVolReadOnly(ni-&gt;vol) || !mask)</a>
<a name="ln1389">		return;</a>
<a name="ln1390"> </a>
<a name="ln1391">	now = ntfs_current_time();</a>
<a name="ln1392">	if (mask &amp; NTFS_UPDATE_ATIME)</a>
<a name="ln1393">		ni-&gt;last_access_time = now;</a>
<a name="ln1394">	if (mask &amp; NTFS_UPDATE_MTIME)</a>
<a name="ln1395">		ni-&gt;last_data_change_time = now;</a>
<a name="ln1396">	if (mask &amp; NTFS_UPDATE_CTIME)</a>
<a name="ln1397">		ni-&gt;last_mft_change_time = now;</a>
<a name="ln1398">	</a>
<a name="ln1399">	NInoFileNameSetDirty(ni);</a>
<a name="ln1400">	NInoSetDirty(ni);</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403">/**</a>
<a name="ln1404"> * ntfs_inode_badclus_bad - check for $Badclus:$Bad data attribute</a>
<a name="ln1405"> * @mft_no:		mft record number where @attr is present</a>
<a name="ln1406"> * @attr:		attribute record used to check for the $Bad attribute</a>
<a name="ln1407"> *</a>
<a name="ln1408"> * Check if the mft record given by @mft_no and @attr contains the bad sector</a>
<a name="ln1409"> * list. Please note that mft record numbers describing $Badclus extent inodes</a>
<a name="ln1410"> * will not match the current $Badclus:$Bad check.</a>
<a name="ln1411"> * </a>
<a name="ln1412"> * On success return 1 if the file is $Badclus:$Bad, otherwise return 0.</a>
<a name="ln1413"> * On error return -1 with errno set to the error code.</a>
<a name="ln1414"> */</a>
<a name="ln1415">int ntfs_inode_badclus_bad(u64 mft_no, ATTR_RECORD *attr)</a>
<a name="ln1416">{</a>
<a name="ln1417">	int len, ret = 0;</a>
<a name="ln1418">	ntfschar *ustr;</a>
<a name="ln1419"> </a>
<a name="ln1420">	if (!attr) {</a>
<a name="ln1421">		ntfs_log_error(&quot;Invalid argument.\n&quot;);</a>
<a name="ln1422">		errno = EINVAL;</a>
<a name="ln1423">		return -1;</a>
<a name="ln1424">	}</a>
<a name="ln1425">	</a>
<a name="ln1426">	if (mft_no != FILE_BadClus)</a>
<a name="ln1427">	       	return 0;</a>
<a name="ln1428"> </a>
<a name="ln1429">	if (attr-&gt;type != AT_DATA)</a>
<a name="ln1430">	       	return 0;</a>
<a name="ln1431"> </a>
<a name="ln1432">	if ((ustr = ntfs_str2ucs(&quot;$Bad&quot;, &amp;len)) == NULL) {</a>
<a name="ln1433">		ntfs_log_perror(&quot;Couldn't convert '$Bad' to Unicode&quot;);</a>
<a name="ln1434">		return -1;</a>
<a name="ln1435">	}</a>
<a name="ln1436"> </a>
<a name="ln1437">	if (ustr &amp;&amp; ntfs_names_are_equal(ustr, len,</a>
<a name="ln1438">			(ntfschar *)((u8 *)attr + le16_to_cpu(attr-&gt;name_offset)),</a>
<a name="ln1439">			attr-&gt;name_length, 0, NULL, 0))</a>
<a name="ln1440">		ret = 1;</a>
<a name="ln1441"> </a>
<a name="ln1442">	ntfs_ucsfree(ustr);</a>
<a name="ln1443"> </a>
<a name="ln1444">	return ret;</a>
<a name="ln1445">}</a>
<a name="ln1446"> </a>
<a name="ln1447">/*</a>
<a name="ln1448"> *		Get high precision NTFS times</a>
<a name="ln1449"> *</a>
<a name="ln1450"> *	They are returned in following order : create, update, access, change</a>
<a name="ln1451"> *	provided they fit in requested size.</a>
<a name="ln1452"> *</a>
<a name="ln1453"> *	Returns the modified size if successfull (or 32 if buffer size is null)</a>
<a name="ln1454"> *		-errno if failed</a>
<a name="ln1455"> */</a>
<a name="ln1456"> </a>
<a name="ln1457">int ntfs_inode_get_times(ntfs_inode *ni, char *value, size_t size)</a>
<a name="ln1458">{</a>
<a name="ln1459">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1460">	STANDARD_INFORMATION *std_info;</a>
<a name="ln1461">	u64 *times;</a>
<a name="ln1462">	int ret;</a>
<a name="ln1463"> </a>
<a name="ln1464">	ret = 0;</a>
<a name="ln1465">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln1466">	if (ctx) {</a>
<a name="ln1467">		if (ntfs_attr_lookup(AT_STANDARD_INFORMATION, AT_UNNAMED,</a>
<a name="ln1468">				     0, CASE_SENSITIVE, 0, NULL, 0, ctx)) {</a>
<a name="ln1469">			ntfs_log_perror(&quot;Failed to get standard info (inode %lld)&quot;,</a>
<a name="ln1470">					(long long)ni-&gt;mft_no);</a>
<a name="ln1471">		} else {</a>
<a name="ln1472">			std_info = (STANDARD_INFORMATION *)((u8 *)ctx-&gt;attr +</a>
<a name="ln1473">					le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln1474">			if (value &amp;&amp; (size &gt;= 8)) {</a>
<a name="ln1475">				times = (u64*)value;</a>
<a name="ln1476">				times[0] = sle64_to_cpu(std_info-&gt;creation_time);</a>
<a name="ln1477">				ret = 8;</a>
<a name="ln1478">				if (size &gt;= 16) {</a>
<a name="ln1479">					times[1] = sle64_to_cpu(std_info-&gt;last_data_change_time);</a>
<a name="ln1480">					ret = 16;</a>
<a name="ln1481">				}</a>
<a name="ln1482">				if (size &gt;= 24) {</a>
<a name="ln1483">					times[2] = sle64_to_cpu(std_info-&gt;last_access_time);</a>
<a name="ln1484">					ret = 24;</a>
<a name="ln1485">				}</a>
<a name="ln1486">				if (size &gt;= 32) {</a>
<a name="ln1487">					times[3] = sle64_to_cpu(std_info-&gt;last_mft_change_time);</a>
<a name="ln1488">					ret = 32;</a>
<a name="ln1489">				}</a>
<a name="ln1490">			} else</a>
<a name="ln1491">				if (!size)</a>
<a name="ln1492">					ret = 32;</a>
<a name="ln1493">				else</a>
<a name="ln1494">					ret = -ERANGE;</a>
<a name="ln1495">			}</a>
<a name="ln1496">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1497">	}		</a>
<a name="ln1498">	return (ret ? ret : -errno);</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">/*</a>
<a name="ln1502"> *		Set high precision NTFS times</a>
<a name="ln1503"> *</a>
<a name="ln1504"> *	They are expected in this order : create, update, access</a>
<a name="ln1505"> *	provided they are present in input. The change time is set to</a>
<a name="ln1506"> *	current time.</a>
<a name="ln1507"> *</a>
<a name="ln1508"> *	The times are inserted directly in the standard_information and</a>
<a name="ln1509"> *	file names attributes to avoid manipulating low precision times</a>
<a name="ln1510"> *</a>
<a name="ln1511"> *	Returns 0 if success</a>
<a name="ln1512"> *		-1 if there were an error (described by errno)</a>
<a name="ln1513"> */</a>
<a name="ln1514"> </a>
<a name="ln1515">int ntfs_inode_set_times(ntfs_inode *ni, const char *value, size_t size,</a>
<a name="ln1516">			int flags)</a>
<a name="ln1517">{</a>
<a name="ln1518">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1519">	STANDARD_INFORMATION *std_info;</a>
<a name="ln1520">	FILE_NAME_ATTR *fn;</a>
<a name="ln1521">	const u64 *times;</a>
<a name="ln1522">	ntfs_time now;</a>
<a name="ln1523">	int cnt;</a>
<a name="ln1524">	int ret;</a>
<a name="ln1525"> </a>
<a name="ln1526">	ret = -1;</a>
<a name="ln1527">	if ((size &gt;= 8) &amp;&amp; !(flags &amp; XATTR_CREATE)) {</a>
<a name="ln1528">		times = (const u64*)value;</a>
<a name="ln1529">		now = ntfs_current_time();</a>
<a name="ln1530">			/* update the standard information attribute */</a>
<a name="ln1531">		ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln1532">		if (ctx) {</a>
<a name="ln1533">			if (ntfs_attr_lookup(AT_STANDARD_INFORMATION,</a>
<a name="ln1534">					AT_UNNAMED, 0, CASE_SENSITIVE,</a>
<a name="ln1535">					0, NULL, 0, ctx)) {</a>
<a name="ln1536">				ntfs_log_perror(&quot;Failed to get standard info (inode %lld)&quot;,</a>
<a name="ln1537">						(long long)ni-&gt;mft_no);</a>
<a name="ln1538">			} else {</a>
<a name="ln1539">				std_info = (STANDARD_INFORMATION *)((u8 *)ctx-&gt;attr +</a>
<a name="ln1540">					le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln1541">				/*</a>
<a name="ln1542">				 * Mark times set to avoid overwriting</a>
<a name="ln1543">				 * them when the inode is closed.</a>
<a name="ln1544">				 * The inode structure must also be updated</a>
<a name="ln1545">				 * (with loss of precision) because of cacheing.</a>
<a name="ln1546">				 * TODO : use NTFS precision in inode, and</a>
<a name="ln1547">				 * return sub-second times in getattr()</a>
<a name="ln1548">				 */</a>
<a name="ln1549">				set_nino_flag(ni, TimesSet);</a>
<a name="ln1550">				std_info-&gt;creation_time = cpu_to_sle64(times[0]);</a>
<a name="ln1551">				ni-&gt;creation_time</a>
<a name="ln1552">					= std_info-&gt;creation_time;</a>
<a name="ln1553">				if (size &gt;= 16) {</a>
<a name="ln1554">					std_info-&gt;last_data_change_time = cpu_to_sle64(times[1]);</a>
<a name="ln1555">					ni-&gt;last_data_change_time</a>
<a name="ln1556">						= std_info-&gt;last_data_change_time;</a>
<a name="ln1557">				}</a>
<a name="ln1558">				if (size &gt;= 24) {</a>
<a name="ln1559">					std_info-&gt;last_access_time = cpu_to_sle64(times[2]);</a>
<a name="ln1560">					ni-&gt;last_access_time</a>
<a name="ln1561">						= std_info-&gt;last_access_time;</a>
<a name="ln1562">				}</a>
<a name="ln1563">				std_info-&gt;last_mft_change_time = now;</a>
<a name="ln1564">				ni-&gt;last_mft_change_time = now;</a>
<a name="ln1565">				ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln1566">				NInoFileNameSetDirty(ni);</a>
<a name="ln1567"> </a>
<a name="ln1568">				/* update the file names attributes */</a>
<a name="ln1569">				ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln1570">				cnt = 0;</a>
<a name="ln1571">				while (!ntfs_attr_lookup(AT_FILE_NAME,</a>
<a name="ln1572">						AT_UNNAMED, 0, CASE_SENSITIVE,</a>
<a name="ln1573">						0, NULL, 0, ctx)) {</a>
<a name="ln1574">					fn = (FILE_NAME_ATTR*)((u8 *)ctx-&gt;attr +</a>
<a name="ln1575">						le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln1576">					fn-&gt;creation_time</a>
<a name="ln1577">						= cpu_to_sle64(times[0]);</a>
<a name="ln1578">					if (size &gt;= 16)</a>
<a name="ln1579">						fn-&gt;last_data_change_time</a>
<a name="ln1580">							= cpu_to_sle64(times[1]);</a>
<a name="ln1581">					if (size &gt;= 24)</a>
<a name="ln1582">						fn-&gt;last_access_time</a>
<a name="ln1583">							= cpu_to_sle64(times[2]);</a>
<a name="ln1584">					fn-&gt;last_mft_change_time = now;</a>
<a name="ln1585">					cnt++;</a>
<a name="ln1586">				}</a>
<a name="ln1587">				if (cnt)</a>
<a name="ln1588">					ret = 0;</a>
<a name="ln1589">				else {</a>
<a name="ln1590">					ntfs_log_perror(&quot;Failed to get file names (inode %lld)&quot;,</a>
<a name="ln1591">						(long long)ni-&gt;mft_no);</a>
<a name="ln1592">				}</a>
<a name="ln1593">			}</a>
<a name="ln1594">			ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1595">		}</a>
<a name="ln1596">	} else</a>
<a name="ln1597">		if (size &lt; 8)</a>
<a name="ln1598">			errno = ERANGE;</a>
<a name="ln1599">		else</a>
<a name="ln1600">			errno = EEXIST;</a>
<a name="ln1601">	return (ret);</a>
<a name="ln1602">}</a>

</code></pre>
<div class="balloon" rel="1155"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v774/" target="_blank">V774</a> The 'al' pointer was used after the memory was reallocated.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
