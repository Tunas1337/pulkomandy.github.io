
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>AccelerantHWInterface.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2016 Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan Aßmus, superstippi@gmx.de</a>
<a name="ln7"> *		DarkWyrm, bpmagic@columbus.rr.com</a>
<a name="ln8"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln9"> *		Michael Lotz, mmlr@mlotz.ch</a>
<a name="ln10"> *		John Scipione, jscipione@gmail.com</a>
<a name="ln11"> */</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">//!	Accelerant based HWInterface implementation</a>
<a name="ln15"> </a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;AccelerantHWInterface.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;new&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;dirent.h&gt;</a>
<a name="ln22">#include &lt;edid.h&gt;</a>
<a name="ln23">#include &lt;driver_settings.h&gt;</a>
<a name="ln24">#include &lt;graphic_driver.h&gt;</a>
<a name="ln25">#include &lt;image.h&gt;</a>
<a name="ln26">#include &lt;safemode_defs.h&gt;</a>
<a name="ln27">#include &lt;stdio.h&gt;</a>
<a name="ln28">#include &lt;stdlib.h&gt;</a>
<a name="ln29">#include &lt;strings.h&gt;</a>
<a name="ln30">#include &lt;sys/ioctl.h&gt;</a>
<a name="ln31">#include &lt;syscalls.h&gt;</a>
<a name="ln32">#include &lt;syslog.h&gt;</a>
<a name="ln33">#include &lt;unistd.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;Accelerant.h&gt;</a>
<a name="ln36">#include &lt;Cursor.h&gt;</a>
<a name="ln37">#include &lt;FindDirectory.h&gt;</a>
<a name="ln38">#include &lt;PathFinder.h&gt;</a>
<a name="ln39">#include &lt;String.h&gt;</a>
<a name="ln40">#include &lt;StringList.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;AccelerantBuffer.h&quot;</a>
<a name="ln43">#include &quot;MallocBuffer.h&quot;</a>
<a name="ln44">#include &quot;Overlay.h&quot;</a>
<a name="ln45">#include &quot;RGBColor.h&quot;</a>
<a name="ln46">#include &quot;ServerConfig.h&quot;</a>
<a name="ln47">#include &quot;ServerCursor.h&quot;</a>
<a name="ln48">#include &quot;ServerProtocol.h&quot;</a>
<a name="ln49">#include &quot;SystemPalette.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51"> </a>
<a name="ln52">using std::nothrow;</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">#ifdef DEBUG_DRIVER_MODULE</a>
<a name="ln56">#	include &lt;stdio.h&gt;</a>
<a name="ln57">#	define ATRACE(x) printf x</a>
<a name="ln58">#else</a>
<a name="ln59">#	define ATRACE(x) ;</a>
<a name="ln60">#endif</a>
<a name="ln61"> </a>
<a name="ln62">#define USE_ACCELERATION		0</a>
<a name="ln63">#define OFFSCREEN_BACK_BUFFER	0</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">const int32 kDefaultParamsCount = 64;</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">bool</a>
<a name="ln70">operator==(const display_mode&amp; a, const display_mode&amp; b)</a>
<a name="ln71">{</a>
<a name="ln72">	return memcmp(&amp;a, &amp;b, sizeof(display_mode)) == 0;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">bool</a>
<a name="ln77">use_fail_safe_video_mode()</a>
<a name="ln78">{</a>
<a name="ln79">	char buffer[B_FILE_NAME_LENGTH];</a>
<a name="ln80">	size_t size = sizeof(buffer);</a>
<a name="ln81"> </a>
<a name="ln82">	status_t status = _kern_get_safemode_option(</a>
<a name="ln83">		B_SAFEMODE_FAIL_SAFE_VIDEO_MODE, buffer, &amp;size);</a>
<a name="ln84">	if (status == B_OK) {</a>
<a name="ln85">		if (!strncasecmp(buffer, &quot;true&quot;, size)</a>
<a name="ln86">			|| !strncasecmp(buffer, &quot;yes&quot;, size)</a>
<a name="ln87">			|| !strncasecmp(buffer, &quot;on&quot;, size)</a>
<a name="ln88">			|| !strncasecmp(buffer, &quot;enabled&quot;, size)) {</a>
<a name="ln89">			return true;</a>
<a name="ln90">		}</a>
<a name="ln91">	}</a>
<a name="ln92"> </a>
<a name="ln93">	return false;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">//	#pragma mark - AccelerantHWInterface</a>
<a name="ln98"> </a>
<a name="ln99"> </a>
<a name="ln100">AccelerantHWInterface::AccelerantHWInterface()</a>
<a name="ln101">	:</a>
<a name="ln102">	HWInterface(),</a>
<a name="ln103">	fCardFD(-1),</a>
<a name="ln104">	fAccelerantImage(-1),</a>
<a name="ln105">	fAccelerantHook(NULL),</a>
<a name="ln106">	fEngineToken(NULL),</a>
<a name="ln107">	fSyncToken(),</a>
<a name="ln108"> </a>
<a name="ln109">	// required hooks</a>
<a name="ln110">	fAccAcquireEngine(NULL),</a>
<a name="ln111">	fAccReleaseEngine(NULL),</a>
<a name="ln112">	fAccSyncToToken(NULL),</a>
<a name="ln113">	fAccGetModeCount(NULL),</a>
<a name="ln114">	fAccGetModeList(NULL),</a>
<a name="ln115">	fAccGetFrameBufferConfig(NULL),</a>
<a name="ln116">	fAccSetDisplayMode(NULL),</a>
<a name="ln117">	fAccGetDisplayMode(NULL),</a>
<a name="ln118">	fAccGetPixelClockLimits(NULL),</a>
<a name="ln119"> </a>
<a name="ln120">	// optional accelerant hooks</a>
<a name="ln121">	fAccGetTimingConstraints(NULL),</a>
<a name="ln122">	fAccProposeDisplayMode(NULL),</a>
<a name="ln123">	fAccFillRect(NULL),</a>
<a name="ln124">	fAccInvertRect(NULL),</a>
<a name="ln125">	fAccScreenBlit(NULL),</a>
<a name="ln126">	fAccSetCursorShape(NULL),</a>
<a name="ln127">	fAccSetCursorBitmap(NULL),</a>
<a name="ln128">	fAccMoveCursor(NULL),</a>
<a name="ln129">	fAccShowCursor(NULL),</a>
<a name="ln130"> </a>
<a name="ln131">	// dpms hooks</a>
<a name="ln132">	fAccDPMSCapabilities(NULL),</a>
<a name="ln133">	fAccDPMSMode(NULL),</a>
<a name="ln134">	fAccSetDPMSMode(NULL),</a>
<a name="ln135"> </a>
<a name="ln136">	// brightness hooks</a>
<a name="ln137">	fAccSetBrightness(NULL),</a>
<a name="ln138">	fAccGetBrightness(NULL),</a>
<a name="ln139"> </a>
<a name="ln140">	// overlay hooks</a>
<a name="ln141">	fAccOverlayCount(NULL),</a>
<a name="ln142">	fAccOverlaySupportedSpaces(NULL),</a>
<a name="ln143">	fAccOverlaySupportedFeatures(NULL),</a>
<a name="ln144">	fAccAllocateOverlayBuffer(NULL),</a>
<a name="ln145">	fAccReleaseOverlayBuffer(NULL),</a>
<a name="ln146">	fAccGetOverlayConstraints(NULL),</a>
<a name="ln147">	fAccAllocateOverlay(NULL),</a>
<a name="ln148">	fAccReleaseOverlay(NULL),</a>
<a name="ln149">	fAccConfigureOverlay(NULL),</a>
<a name="ln150"> </a>
<a name="ln151">	fModeCount(0),</a>
<a name="ln152">	fModeList(NULL),</a>
<a name="ln153"> </a>
<a name="ln154">	fBackBuffer(NULL),</a>
<a name="ln155">	fFrontBuffer(new (nothrow) AccelerantBuffer()),</a>
<a name="ln156">	fOffscreenBackBuffer(false),</a>
<a name="ln157"> </a>
<a name="ln158">	fInitialModeSwitch(true),</a>
<a name="ln159"> </a>
<a name="ln160">	fRetraceSemaphore(-1),</a>
<a name="ln161"> </a>
<a name="ln162">	fRectParams(new (nothrow) fill_rect_params[kDefaultParamsCount]),</a>
<a name="ln163">	fRectParamsCount(kDefaultParamsCount),</a>
<a name="ln164">	fBlitParams(new (nothrow) blit_params[kDefaultParamsCount]),</a>
<a name="ln165">	fBlitParamsCount(kDefaultParamsCount)</a>
<a name="ln166">{</a>
<a name="ln167">	fDisplayMode.virtual_width = 640;</a>
<a name="ln168">	fDisplayMode.virtual_height = 480;</a>
<a name="ln169">	fDisplayMode.space = B_RGB32;</a>
<a name="ln170"> </a>
<a name="ln171">	// NOTE: I have no clue what I'm doing here.</a>
<a name="ln172">	//fSyncToken.counter = 0;</a>
<a name="ln173">	//fSyncToken.engine_id = 0;</a>
<a name="ln174">	memset(&amp;fSyncToken, 0, sizeof(sync_token));</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">AccelerantHWInterface::~AccelerantHWInterface()</a>
<a name="ln179">{</a>
<a name="ln180">	delete fBackBuffer;</a>
<a name="ln181">	delete fFrontBuffer;</a>
<a name="ln182"> </a>
<a name="ln183">	delete[] fRectParams;</a>
<a name="ln184">	delete[] fBlitParams;</a>
<a name="ln185"> </a>
<a name="ln186">	delete[] fModeList;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">/*!	Opens the first available graphics device and initializes it.</a>
<a name="ln191"> </a>
<a name="ln192">	\return B_OK on success or an appropriate error message on failure.</a>
<a name="ln193">*/</a>
<a name="ln194">status_t</a>
<a name="ln195">AccelerantHWInterface::Initialize()</a>
<a name="ln196">{</a>
<a name="ln197">	status_t ret = HWInterface::Initialize();</a>
<a name="ln198"> </a>
<a name="ln199">	if (!fRectParams || !fBlitParams)</a>
<a name="ln200">		return B_NO_MEMORY;</a>
<a name="ln201"> </a>
<a name="ln202">	if (ret &gt;= B_OK) {</a>
<a name="ln203">		for (int32 i = 1; fCardFD != B_ENTRY_NOT_FOUND; i++) {</a>
<a name="ln204">			fCardFD = _OpenGraphicsDevice(i);</a>
<a name="ln205">			if (fCardFD &lt; 0) {</a>
<a name="ln206">				ATRACE((&quot;Failed to open graphics device\n&quot;));</a>
<a name="ln207">				continue;</a>
<a name="ln208">			}</a>
<a name="ln209"> </a>
<a name="ln210">			if (_OpenAccelerant(fCardFD) == B_OK)</a>
<a name="ln211">				break;</a>
<a name="ln212"> </a>
<a name="ln213">			close(fCardFD);</a>
<a name="ln214">			// _OpenAccelerant() failed, try to open next graphics card</a>
<a name="ln215">		}</a>
<a name="ln216"> </a>
<a name="ln217">		return fCardFD &gt;= 0 ? B_OK : fCardFD;</a>
<a name="ln218">	}</a>
<a name="ln219">	return ret;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">/*!	Opens a graphics device for read-write access.</a>
<a name="ln224"> </a>
<a name="ln225">	The \a deviceNumber is relative to the number of graphics devices that can</a>
<a name="ln226">	be opened. One represents the first card that can be opened (not necessarily</a>
<a name="ln227">	the first one listed in the directory).</a>
<a name="ln228"> </a>
<a name="ln229">	Graphics drivers must be able to be opened more than once, so we really get</a>
<a name="ln230">	the first working entry.</a>
<a name="ln231"> </a>
<a name="ln232">	\param deviceNumber Number identifying which graphics card to open</a>
<a name="ln233">	       (1 for first card).</a>
<a name="ln234"> </a>
<a name="ln235">	\return The file descriptor of the opened graphics device.</a>
<a name="ln236">*/</a>
<a name="ln237">int</a>
<a name="ln238">AccelerantHWInterface::_OpenGraphicsDevice(int deviceNumber)</a>
<a name="ln239">{</a>
<a name="ln240">	DIR *directory = opendir(&quot;/dev/graphics&quot;);</a>
<a name="ln241">	if (!directory)</a>
<a name="ln242">		return -1;</a>
<a name="ln243"> </a>
<a name="ln244">	int device = -1;</a>
<a name="ln245">	int count = 0;</a>
<a name="ln246">	if (!use_fail_safe_video_mode()) {</a>
<a name="ln247">		// TODO: We do not need to avoid the &quot;vesa&quot; driver this way once it has</a>
<a name="ln248">		// been ported to the new driver architecture - the special case here</a>
<a name="ln249">		// can then be removed.</a>
<a name="ln250">		struct dirent *entry;</a>
<a name="ln251">		char path[PATH_MAX];</a>
<a name="ln252">		while (count &lt; deviceNumber &amp;&amp; (entry = readdir(directory)) != NULL) {</a>
<a name="ln253">			if (!strcmp(entry-&gt;d_name, &quot;.&quot;) || !strcmp(entry-&gt;d_name, &quot;..&quot;)</a>
<a name="ln254">				|| !strcmp(entry-&gt;d_name, &quot;vesa&quot;))</a>
<a name="ln255">				continue;</a>
<a name="ln256"> </a>
<a name="ln257">			if (device &gt;= 0) {</a>
<a name="ln258">				close(device);</a>
<a name="ln259">				device = -1;</a>
<a name="ln260">			}</a>
<a name="ln261"> </a>
<a name="ln262">			sprintf(path, &quot;/dev/graphics/%s&quot;, entry-&gt;d_name);</a>
<a name="ln263">			device = open(path, B_READ_WRITE);</a>
<a name="ln264">			if (device &gt;= 0)</a>
<a name="ln265">				count++;</a>
<a name="ln266">		}</a>
<a name="ln267">	}</a>
<a name="ln268"> </a>
<a name="ln269">	// Open VESA driver if we were not able to get a better one</a>
<a name="ln270">	if (count &lt; deviceNumber) {</a>
<a name="ln271">		if (deviceNumber == 1) {</a>
<a name="ln272">			device = open(&quot;/dev/graphics/vesa&quot;, B_READ_WRITE);</a>
<a name="ln273">			fVGADevice = device;</a>
<a name="ln274">				// store the device, so that we can access the planar blitter</a>
<a name="ln275">		} else {</a>
<a name="ln276">			close(device);</a>
<a name="ln277">			device = B_ENTRY_NOT_FOUND;</a>
<a name="ln278">		}</a>
<a name="ln279">	}</a>
<a name="ln280"> </a>
<a name="ln281">	closedir(directory);</a>
<a name="ln282"> </a>
<a name="ln283">	return device;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">status_t</a>
<a name="ln288">AccelerantHWInterface::_OpenAccelerant(int device)</a>
<a name="ln289">{</a>
<a name="ln290">	char signature[1024];</a>
<a name="ln291">	if (ioctl(device, B_GET_ACCELERANT_SIGNATURE,</a>
<a name="ln292">			&amp;signature, sizeof(signature)) != B_OK) {</a>
<a name="ln293">		return B_ERROR;</a>
<a name="ln294">	}</a>
<a name="ln295"> </a>
<a name="ln296">	ATRACE((&quot;accelerant signature is: %s\n&quot;, signature));</a>
<a name="ln297"> </a>
<a name="ln298">	fAccelerantImage = -1;</a>
<a name="ln299"> </a>
<a name="ln300">	BString leafPath(&quot;/accelerants/&quot;);</a>
<a name="ln301">	leafPath &lt;&lt; signature;</a>
<a name="ln302">	BStringList addOnPaths;</a>
<a name="ln303">	BPathFinder::FindPaths(B_FIND_PATH_ADD_ONS_DIRECTORY, leafPath.String(),</a>
<a name="ln304">		addOnPaths);</a>
<a name="ln305">	int32 count = addOnPaths.CountStrings();</a>
<a name="ln306">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln307">		const char* path = addOnPaths.StringAt(i).String();</a>
<a name="ln308">		struct stat accelerantStat;</a>
<a name="ln309">		if (stat(path, &amp;accelerantStat) != 0)</a>
<a name="ln310">			continue;</a>
<a name="ln311"> </a>
<a name="ln312">		ATRACE((&quot;accelerant path is: %s\n&quot;, path));</a>
<a name="ln313"> </a>
<a name="ln314">		fAccelerantImage = load_add_on(path);</a>
<a name="ln315">		if (fAccelerantImage &gt;= 0) {</a>
<a name="ln316">			if (get_image_symbol(fAccelerantImage, B_ACCELERANT_ENTRY_POINT,</a>
<a name="ln317">					B_SYMBOL_TYPE_ANY, (void**)(&amp;fAccelerantHook)) != B_OK) {</a>
<a name="ln318">				ATRACE((&quot;unable to get B_ACCELERANT_ENTRY_POINT\n&quot;));</a>
<a name="ln319">				unload_add_on(fAccelerantImage);</a>
<a name="ln320">				fAccelerantImage = -1;</a>
<a name="ln321">				return B_ERROR;</a>
<a name="ln322">			}</a>
<a name="ln323"> </a>
<a name="ln324">			init_accelerant initAccelerant;</a>
<a name="ln325">			initAccelerant = (init_accelerant)fAccelerantHook(</a>
<a name="ln326">				B_INIT_ACCELERANT, NULL);</a>
<a name="ln327">			if (!initAccelerant || initAccelerant(device) != B_OK) {</a>
<a name="ln328">				ATRACE((&quot;InitAccelerant unsuccessful\n&quot;));</a>
<a name="ln329">				unload_add_on(fAccelerantImage);</a>
<a name="ln330">				fAccelerantImage = -1;</a>
<a name="ln331">				return B_ERROR;</a>
<a name="ln332">			}</a>
<a name="ln333"> </a>
<a name="ln334">			break;</a>
<a name="ln335">		}</a>
<a name="ln336">	}</a>
<a name="ln337"> </a>
<a name="ln338">	if (fAccelerantImage &lt; B_OK)</a>
<a name="ln339">		return B_ERROR;</a>
<a name="ln340"> </a>
<a name="ln341">	if (_SetupDefaultHooks() != B_OK) {</a>
<a name="ln342">		syslog(LOG_ERR, &quot;Accelerant %s does not export the required hooks.\n&quot;,</a>
<a name="ln343">			signature);</a>
<a name="ln344"> </a>
<a name="ln345">		uninit_accelerant uninitAccelerant = (uninit_accelerant)</a>
<a name="ln346">			fAccelerantHook(B_UNINIT_ACCELERANT, NULL);</a>
<a name="ln347">		if (uninitAccelerant != NULL)</a>
<a name="ln348">			uninitAccelerant();</a>
<a name="ln349"> </a>
<a name="ln350">		unload_add_on(fAccelerantImage);</a>
<a name="ln351">		return B_ERROR;</a>
<a name="ln352">	}</a>
<a name="ln353"> </a>
<a name="ln354">	return B_OK;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358">status_t</a>
<a name="ln359">AccelerantHWInterface::_SetupDefaultHooks()</a>
<a name="ln360">{</a>
<a name="ln361">	// required</a>
<a name="ln362">	fAccAcquireEngine = (acquire_engine)fAccelerantHook(B_ACQUIRE_ENGINE, NULL);</a>
<a name="ln363">	fAccReleaseEngine = (release_engine)fAccelerantHook(B_RELEASE_ENGINE, NULL);</a>
<a name="ln364">	fAccSyncToToken = (sync_to_token)fAccelerantHook(B_SYNC_TO_TOKEN, NULL);</a>
<a name="ln365">	fAccGetModeCount</a>
<a name="ln366">		= (accelerant_mode_count)fAccelerantHook(B_ACCELERANT_MODE_COUNT, NULL);</a>
<a name="ln367">	fAccGetModeList = (get_mode_list)fAccelerantHook(B_GET_MODE_LIST, NULL);</a>
<a name="ln368">	fAccGetFrameBufferConfig = (get_frame_buffer_config)fAccelerantHook(</a>
<a name="ln369">		B_GET_FRAME_BUFFER_CONFIG, NULL);</a>
<a name="ln370">	fAccSetDisplayMode</a>
<a name="ln371">		= (set_display_mode)fAccelerantHook(B_SET_DISPLAY_MODE, NULL);</a>
<a name="ln372">	fAccGetDisplayMode</a>
<a name="ln373">		= (get_display_mode)fAccelerantHook(B_GET_DISPLAY_MODE, NULL);</a>
<a name="ln374">	fAccGetPixelClockLimits = (get_pixel_clock_limits)fAccelerantHook(</a>
<a name="ln375">		B_GET_PIXEL_CLOCK_LIMITS, NULL);</a>
<a name="ln376"> </a>
<a name="ln377">	if (!fAccAcquireEngine || !fAccReleaseEngine || !fAccGetFrameBufferConfig</a>
<a name="ln378">		|| !fAccGetModeCount || !fAccGetModeList || !fAccSetDisplayMode</a>
<a name="ln379">		|| !fAccGetDisplayMode || !fAccGetPixelClockLimits) {</a>
<a name="ln380">		return B_ERROR;</a>
<a name="ln381">	}</a>
<a name="ln382"> </a>
<a name="ln383">	// optional</a>
<a name="ln384">	fAccGetTimingConstraints = (get_timing_constraints)fAccelerantHook(</a>
<a name="ln385">		B_GET_TIMING_CONSTRAINTS, NULL);</a>
<a name="ln386">	fAccProposeDisplayMode = (propose_display_mode)fAccelerantHook(</a>
<a name="ln387">		B_PROPOSE_DISPLAY_MODE, NULL);</a>
<a name="ln388">	fAccGetPreferredDisplayMode = (get_preferred_display_mode)fAccelerantHook(</a>
<a name="ln389">		B_GET_PREFERRED_DISPLAY_MODE, NULL);</a>
<a name="ln390">	fAccGetMonitorInfo</a>
<a name="ln391">		= (get_monitor_info)fAccelerantHook(B_GET_MONITOR_INFO, NULL);</a>
<a name="ln392">	fAccGetEDIDInfo = (get_edid_info)fAccelerantHook(B_GET_EDID_INFO, NULL);</a>
<a name="ln393"> </a>
<a name="ln394">	// cursor</a>
<a name="ln395">	fAccSetCursorShape</a>
<a name="ln396">		= (set_cursor_shape)fAccelerantHook(B_SET_CURSOR_SHAPE, NULL);</a>
<a name="ln397">	fAccSetCursorBitmap</a>
<a name="ln398">		= (set_cursor_bitmap)fAccelerantHook(B_SET_CURSOR_BITMAP, NULL);</a>
<a name="ln399">	fAccMoveCursor = (move_cursor)fAccelerantHook(B_MOVE_CURSOR, NULL);</a>
<a name="ln400">	fAccShowCursor = (show_cursor)fAccelerantHook(B_SHOW_CURSOR, NULL);</a>
<a name="ln401"> </a>
<a name="ln402">	// dpms</a>
<a name="ln403">	fAccDPMSCapabilities</a>
<a name="ln404">		= (dpms_capabilities)fAccelerantHook(B_DPMS_CAPABILITIES, NULL);</a>
<a name="ln405">	fAccDPMSMode = (dpms_mode)fAccelerantHook(B_DPMS_MODE, NULL);</a>
<a name="ln406">	fAccSetDPMSMode = (set_dpms_mode)fAccelerantHook(B_SET_DPMS_MODE, NULL);</a>
<a name="ln407"> </a>
<a name="ln408">	// brightness</a>
<a name="ln409">	fAccGetBrightness = (get_brightness)fAccelerantHook(B_GET_BRIGHTNESS, NULL);</a>
<a name="ln410">	fAccSetBrightness = (set_brightness)fAccelerantHook(B_SET_BRIGHTNESS, NULL);</a>
<a name="ln411"> </a>
<a name="ln412">	return B_OK;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415"> </a>
<a name="ln416">void</a>
<a name="ln417">AccelerantHWInterface::_UpdateHooksAfterModeChange()</a>
<a name="ln418">{</a>
<a name="ln419">	// update acceleration hooks</a>
<a name="ln420">#if USE_ACCELERATION</a>
<a name="ln421">	fAccFillRect = (fill_rectangle)fAccelerantHook(B_FILL_RECTANGLE,</a>
<a name="ln422">		(void *)&amp;fDisplayMode);</a>
<a name="ln423">	fAccInvertRect = (invert_rectangle)fAccelerantHook(B_INVERT_RECTANGLE,</a>
<a name="ln424">		(void *)&amp;fDisplayMode);</a>
<a name="ln425">	fAccScreenBlit = (screen_to_screen_blit)fAccelerantHook(</a>
<a name="ln426">		B_SCREEN_TO_SCREEN_BLIT, (void *)&amp;fDisplayMode);</a>
<a name="ln427">#else</a>
<a name="ln428">	fAccFillRect = NULL;</a>
<a name="ln429">	fAccInvertRect = NULL;</a>
<a name="ln430">	fAccScreenBlit = NULL;</a>
<a name="ln431">#endif</a>
<a name="ln432"> </a>
<a name="ln433">	// overlay</a>
<a name="ln434">	fAccOverlayCount = (overlay_count)fAccelerantHook(B_OVERLAY_COUNT, NULL);</a>
<a name="ln435">	fAccOverlaySupportedSpaces = (overlay_supported_spaces)fAccelerantHook(</a>
<a name="ln436">		B_OVERLAY_SUPPORTED_SPACES, NULL);</a>
<a name="ln437">	fAccOverlaySupportedFeatures = (overlay_supported_features)fAccelerantHook(</a>
<a name="ln438">		B_OVERLAY_SUPPORTED_FEATURES, NULL);</a>
<a name="ln439">	fAccAllocateOverlayBuffer = (allocate_overlay_buffer)fAccelerantHook(</a>
<a name="ln440">		B_ALLOCATE_OVERLAY_BUFFER, NULL);</a>
<a name="ln441">	fAccReleaseOverlayBuffer = (release_overlay_buffer)fAccelerantHook(</a>
<a name="ln442">		B_RELEASE_OVERLAY_BUFFER, NULL);</a>
<a name="ln443">	fAccGetOverlayConstraints = (get_overlay_constraints)fAccelerantHook(</a>
<a name="ln444">		B_GET_OVERLAY_CONSTRAINTS, NULL);</a>
<a name="ln445">	fAccAllocateOverlay</a>
<a name="ln446">		= (allocate_overlay)fAccelerantHook(B_ALLOCATE_OVERLAY, NULL);</a>
<a name="ln447">	fAccReleaseOverlay</a>
<a name="ln448">		= (release_overlay)fAccelerantHook(B_RELEASE_OVERLAY, NULL);</a>
<a name="ln449">	fAccConfigureOverlay</a>
<a name="ln450">		= (configure_overlay)fAccelerantHook(B_CONFIGURE_OVERLAY, NULL);</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453"> </a>
<a name="ln454">status_t</a>
<a name="ln455">AccelerantHWInterface::Shutdown()</a>
<a name="ln456">{</a>
<a name="ln457">	if (fAccelerantHook != NULL) {</a>
<a name="ln458">		uninit_accelerant uninitAccelerant</a>
<a name="ln459">			= (uninit_accelerant)fAccelerantHook(B_UNINIT_ACCELERANT, NULL);</a>
<a name="ln460">		if (uninitAccelerant != NULL)</a>
<a name="ln461">			uninitAccelerant();</a>
<a name="ln462"> </a>
<a name="ln463">		fAccelerantHook = NULL;</a>
<a name="ln464">	}</a>
<a name="ln465"> </a>
<a name="ln466">	if (fAccelerantImage &gt;= 0) {</a>
<a name="ln467">		unload_add_on(fAccelerantImage);</a>
<a name="ln468">		fAccelerantImage = -1;</a>
<a name="ln469">	}</a>
<a name="ln470"> </a>
<a name="ln471">	if (fCardFD &gt;= 0) {</a>
<a name="ln472">		close(fCardFD);</a>
<a name="ln473">		fCardFD = -1;</a>
<a name="ln474">	}</a>
<a name="ln475"> </a>
<a name="ln476">	return B_OK;</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479"> </a>
<a name="ln480">/*!	Finds the mode in the mode list that is closest to the mode specified.</a>
<a name="ln481">	As long as the mode list is not empty, this method will always succeed.</a>
<a name="ln482">*/</a>
<a name="ln483">status_t</a>
<a name="ln484">AccelerantHWInterface::_FindBestMode(const display_mode&amp; compareMode,</a>
<a name="ln485">	float compareAspectRatio, display_mode&amp; modeFound, int32 *_diff) const</a>
<a name="ln486">{</a>
<a name="ln487">	int32 bestDiff = 0;</a>
<a name="ln488">	int32 bestIndex = -1;</a>
<a name="ln489">	for (int32 i = 0; i &lt; fModeCount; i++) {</a>
<a name="ln490">		display_mode&amp; mode = fModeList[i];</a>
<a name="ln491">		float aspectRatio = 0;</a>
<a name="ln492"> </a>
<a name="ln493">		if (compareAspectRatio != 0 &amp;&amp; mode.timing.v_display != 0)</a>
<a name="ln494">			aspectRatio = mode.timing.h_display / mode.timing.v_display;</a>
<a name="ln495"> </a>
<a name="ln496">		// compute some random equality score</a>
<a name="ln497">		// TODO: check if these scores make sense</a>
<a name="ln498">		int32 diff</a>
<a name="ln499">			= 1000 * abs(mode.timing.h_display - compareMode.timing.h_display)</a>
<a name="ln500">			+ 1000 * abs(mode.timing.v_display - compareMode.timing.v_display)</a>
<a name="ln501">			+ abs(mode.timing.h_total * mode.timing.v_total</a>
<a name="ln502">					- compareMode.timing.h_total * compareMode.timing.v_total)</a>
<a name="ln503">				/ 100</a>
<a name="ln504">			+ abs((int)(mode.timing.pixel_clock - compareMode.timing.pixel_clock))</a>
<a name="ln505">				/ 100</a>
<a name="ln506">			+ (int32)(500 * fabs(aspectRatio - compareAspectRatio))</a>
<a name="ln507">			+ 100 * abs((int)(mode.space - compareMode.space));</a>
<a name="ln508"> </a>
<a name="ln509">		if (bestIndex == -1 || diff &lt; bestDiff) {</a>
<a name="ln510">			bestDiff = diff;</a>
<a name="ln511">			bestIndex = i;</a>
<a name="ln512">		}</a>
<a name="ln513">	}</a>
<a name="ln514"> </a>
<a name="ln515">	if (bestIndex &lt; 0)</a>
<a name="ln516">		return B_ERROR;</a>
<a name="ln517"> </a>
<a name="ln518">	modeFound = fModeList[bestIndex];</a>
<a name="ln519">	if (_diff != 0)</a>
<a name="ln520">		*_diff = bestDiff;</a>
<a name="ln521"> </a>
<a name="ln522">	return B_OK;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">/*!	This method is used for the initial mode set only - because that one</a>
<a name="ln527">	should really not fail.</a>
<a name="ln528"> </a>
<a name="ln529">	Basically we try to set all modes as found in the mode list the driver</a>
<a name="ln530">	returned, but we start with the one that best fits the originally</a>
<a name="ln531">	desired mode.</a>
<a name="ln532"> </a>
<a name="ln533">	The mode list must have been retrieved already.</a>
<a name="ln534">*/</a>
<a name="ln535">status_t</a>
<a name="ln536">AccelerantHWInterface::_SetFallbackMode(display_mode&amp; newMode) const</a>
<a name="ln537">{</a>
<a name="ln538">	// At first, we search the closest display mode from the list of</a>
<a name="ln539">	// supported modes - if that fails, we just take one</a>
<a name="ln540"> </a>
<a name="ln541">	if (_FindBestMode(newMode, 0, newMode) == B_OK</a>
<a name="ln542">		&amp;&amp; fAccSetDisplayMode(&amp;newMode) == B_OK) {</a>
<a name="ln543">		return B_OK;</a>
<a name="ln544">	}</a>
<a name="ln545"> </a>
<a name="ln546">	// That failed as well, this looks like a bug in the graphics</a>
<a name="ln547">	// driver, but we have to try to be as forgiving as possible</a>
<a name="ln548">	// here - just take the first mode that works!</a>
<a name="ln549"> </a>
<a name="ln550">	for (int32 i = 0; i &lt; fModeCount; i++) {</a>
<a name="ln551">		newMode = fModeList[i];</a>
<a name="ln552">		if (fAccSetDisplayMode(&amp;newMode) == B_OK)</a>
<a name="ln553">			return B_OK;</a>
<a name="ln554">	}</a>
<a name="ln555"> </a>
<a name="ln556">	// Well, we tried.</a>
<a name="ln557">	return B_ERROR;</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560"> </a>
<a name="ln561">status_t</a>
<a name="ln562">AccelerantHWInterface::SetMode(const display_mode&amp; mode)</a>
<a name="ln563">{</a>
<a name="ln564">	AutoWriteLocker _(this);</a>
<a name="ln565">	// TODO: There are places this function can fail,</a>
<a name="ln566">	// maybe it needs to roll back changes in case of an</a>
<a name="ln567">	// error.</a>
<a name="ln568"> </a>
<a name="ln569">	// prevent from doing the unnecessary</a>
<a name="ln570">	if (fModeCount &gt; 0 &amp;&amp; fFrontBuffer &amp;&amp; fDisplayMode == mode) {</a>
<a name="ln571">		// TODO: better comparison of display modes</a>
<a name="ln572">		return B_OK;</a>
<a name="ln573">	}</a>
<a name="ln574"> </a>
<a name="ln575">	// some safety checks</a>
<a name="ln576">	// TODO: more of those!</a>
<a name="ln577">	if (!_IsValidMode(mode))</a>
<a name="ln578">		return B_BAD_VALUE;</a>
<a name="ln579"> </a>
<a name="ln580">	if (fFrontBuffer == NULL)</a>
<a name="ln581">		return B_NO_INIT;</a>
<a name="ln582"> </a>
<a name="ln583">	// just try to set the mode - we let the graphics driver</a>
<a name="ln584">	// approve or deny the request, as it should know best</a>
<a name="ln585"> </a>
<a name="ln586">	display_mode newMode = mode;</a>
<a name="ln587"> </a>
<a name="ln588">	bool tryOffscreenBackBuffer = false;</a>
<a name="ln589">	fOffscreenBackBuffer = false;</a>
<a name="ln590">#if USE_ACCELERATION &amp;&amp; OFFSCREEN_BACK_BUFFER</a>
<a name="ln591">	if (fVGADevice &lt; 0 &amp;&amp; (color_space)newMode.space == B_RGB32) {</a>
<a name="ln592">		// we should have an accelerated graphics driver, try</a>
<a name="ln593">		// to allocate a frame buffer large enough to contain</a>
<a name="ln594">		// the back buffer for double buffered drawing</a>
<a name="ln595">		newMode.virtual_height *= 2;</a>
<a name="ln596">		tryOffscreenBackBuffer = true;</a>
<a name="ln597">	}</a>
<a name="ln598">#endif</a>
<a name="ln599"> </a>
<a name="ln600">	status_t status = B_ERROR;</a>
<a name="ln601">	if (!use_fail_safe_video_mode() || !fInitialModeSwitch)</a>
<a name="ln602">		status = fAccSetDisplayMode(&amp;newMode);</a>
<a name="ln603">	if (status != B_OK) {</a>
<a name="ln604">		ATRACE((&quot;setting display mode failed\n&quot;));</a>
<a name="ln605">		if (!fInitialModeSwitch)</a>
<a name="ln606">			return status;</a>
<a name="ln607"> </a>
<a name="ln608">		// undo the offscreen backbuffer trick when trying the various</a>
<a name="ln609">		// fall back methods for the initial mode switch</a>
<a name="ln610">		// TODO: Do it even then, but it is more involved.</a>
<a name="ln611">		if (tryOffscreenBackBuffer) {</a>
<a name="ln612">			newMode.virtual_height /= 2;</a>
<a name="ln613">			tryOffscreenBackBuffer = false;</a>
<a name="ln614">		}</a>
<a name="ln615"> </a>
<a name="ln616">		if (fModeList == NULL) {</a>
<a name="ln617">			status = _UpdateModeList();</a>
<a name="ln618">			if (status != B_OK)</a>
<a name="ln619">				return status;</a>
<a name="ln620">		}</a>
<a name="ln621"> </a>
<a name="ln622">		// If this is the initial mode switch, we try a number of fallback</a>
<a name="ln623">		// modes first, before we have to fail</a>
<a name="ln624"> </a>
<a name="ln625">		status = use_fail_safe_video_mode()</a>
<a name="ln626">			? B_ERROR : _SetFallbackMode(newMode);</a>
<a name="ln627">		if (status != B_OK) {</a>
<a name="ln628">			// The driver doesn't allow us the mode switch - this usually</a>
<a name="ln629">			// means we have a driver that doesn't allow mode switches at</a>
<a name="ln630">			// all.</a>
<a name="ln631">			// All we can do now is to ask the driver which mode we can</a>
<a name="ln632">			// use - this is always necessary for VESA mode, for example.</a>
<a name="ln633">			if (fAccGetDisplayMode(&amp;newMode) != B_OK)</a>
<a name="ln634">				return B_ERROR;</a>
<a name="ln635"> </a>
<a name="ln636">			// TODO: check if the mode returned is valid!</a>
<a name="ln637">			if (!_IsValidMode(newMode))</a>
<a name="ln638">				return B_BAD_DATA;</a>
<a name="ln639"> </a>
<a name="ln640">			// TODO: if the mode switch before fails as well, we must forbid</a>
<a name="ln641">			//	any uses of this class!</a>
<a name="ln642">			status = B_OK;</a>
<a name="ln643">		}</a>
<a name="ln644">	}</a>
<a name="ln645"> </a>
<a name="ln646">	if (tryOffscreenBackBuffer) {</a>
<a name="ln647">		// The offscreen backbuffer was successfully allocated, since</a>
<a name="ln648">		// the mode switch succeeded! This should be handled transparently</a>
<a name="ln649">		// though and not be reflected in the mode structure, so that</a>
<a name="ln650">		// even real virtual screens should work eventually...</a>
<a name="ln651">		newMode.virtual_height /= 2;</a>
<a name="ln652">		fOffscreenBackBuffer = true;</a>
<a name="ln653">	}</a>
<a name="ln654"> </a>
<a name="ln655">	fDisplayMode = newMode;</a>
<a name="ln656">	fInitialModeSwitch = false;</a>
<a name="ln657"> </a>
<a name="ln658">	// update frontbuffer</a>
<a name="ln659">	fFrontBuffer-&gt;SetDisplayMode(fDisplayMode);</a>
<a name="ln660">	if (_UpdateFrameBufferConfig() != B_OK) {</a>
<a name="ln661">		// TODO: if this fails, we're basically toasted - we need to handle this</a>
<a name="ln662">		//	differently to crashing later on!</a>
<a name="ln663">		return B_ERROR;</a>
<a name="ln664">	}</a>
<a name="ln665"> </a>
<a name="ln666">	// Update the frame buffer used by the on-screen KDL</a>
<a name="ln667">#ifndef HAIKU_TARGET_PLATFORM_LIBBE_TEST</a>
<a name="ln668">	uint32 depth = (fFrameBufferConfig.bytes_per_row</a>
<a name="ln669">		/ fFrontBuffer-&gt;Width()) &lt;&lt; 3;</a>
<a name="ln670">	if (fDisplayMode.space == B_RGB15)</a>
<a name="ln671">		depth = 15;</a>
<a name="ln672"> </a>
<a name="ln673">	_kern_frame_buffer_update((addr_t)fFrameBufferConfig.frame_buffer,</a>
<a name="ln674">		fFrontBuffer-&gt;Width(), fFrontBuffer-&gt;Height(),</a>
<a name="ln675">		depth, fFrameBufferConfig.bytes_per_row);</a>
<a name="ln676">#endif</a>
<a name="ln677"> </a>
<a name="ln678">	_UpdateHooksAfterModeChange();</a>
<a name="ln679"> </a>
<a name="ln680">	// in case there is no accelerated blit function, using</a>
<a name="ln681">	// an offscreen located backbuffer will not be beneficial!</a>
<a name="ln682">	if (fAccScreenBlit == NULL)</a>
<a name="ln683">		fOffscreenBackBuffer = false;</a>
<a name="ln684"> </a>
<a name="ln685">	// update backbuffer if neccessary</a>
<a name="ln686">	if (!fBackBuffer || fBackBuffer-&gt;Width() != fFrontBuffer-&gt;Width()</a>
<a name="ln687">		|| fBackBuffer-&gt;Height() != fFrontBuffer-&gt;Height()</a>
<a name="ln688">		|| fOffscreenBackBuffer</a>
<a name="ln689">		|| (fFrontBuffer-&gt;ColorSpace() == B_RGB32 &amp;&amp; fBackBuffer != NULL</a>
<a name="ln690">			&amp;&amp; !HWInterface::IsDoubleBuffered())) {</a>
<a name="ln691">		// NOTE: backbuffer is always B_RGBA32, this simplifies the</a>
<a name="ln692">		// drawing backend implementation tremendously for the time</a>
<a name="ln693">		// being. The color space conversion is handled in CopyBackToFront()</a>
<a name="ln694"> </a>
<a name="ln695">		delete fBackBuffer;</a>
<a name="ln696">		fBackBuffer = NULL;</a>
<a name="ln697"> </a>
<a name="ln698">		// TODO: Above not true anymore for single buffered mode!!!</a>
<a name="ln699">		// -&gt; fall back to double buffer for fDisplayMode.space != B_RGB32</a>
<a name="ln700">		// as intermediate solution...</a>
<a name="ln701">		bool doubleBuffered = HWInterface::IsDoubleBuffered();</a>
<a name="ln702">		if ((fFrontBuffer-&gt;ColorSpace() != B_RGB32</a>
<a name="ln703">			&amp;&amp; fFrontBuffer-&gt;ColorSpace() != B_RGBA32)</a>
<a name="ln704">			|| fVGADevice &gt;= 0 || fOffscreenBackBuffer)</a>
<a name="ln705">			doubleBuffered = true;</a>
<a name="ln706">#if !USE_ACCELERATION</a>
<a name="ln707">		doubleBuffered = true;</a>
<a name="ln708">#endif</a>
<a name="ln709"> </a>
<a name="ln710">		if (doubleBuffered) {</a>
<a name="ln711">			if (fOffscreenBackBuffer) {</a>
<a name="ln712">				fBackBuffer = new(nothrow) AccelerantBuffer(*fFrontBuffer,</a>
<a name="ln713">					true);</a>
<a name="ln714">			} else {</a>
<a name="ln715">				fBackBuffer = new(nothrow) MallocBuffer(fFrontBuffer-&gt;Width(),</a>
<a name="ln716">					fFrontBuffer-&gt;Height());</a>
<a name="ln717">			}</a>
<a name="ln718"> </a>
<a name="ln719">			status = fBackBuffer ? fBackBuffer-&gt;InitCheck() : B_NO_MEMORY;</a>
<a name="ln720">			if (status &lt; B_OK) {</a>
<a name="ln721">				delete fBackBuffer;</a>
<a name="ln722">				fBackBuffer = NULL;</a>
<a name="ln723">				fOffscreenBackBuffer = false;</a>
<a name="ln724">				return status;</a>
<a name="ln725">			}</a>
<a name="ln726">			// clear out backbuffer, alpha is 255 this way</a>
<a name="ln727">			memset(fBackBuffer-&gt;Bits(), 255, fBackBuffer-&gt;BitsLength());</a>
<a name="ln728">		}</a>
<a name="ln729">#if 0</a>
<a name="ln730">// NOTE: Currently disabled, because it make the double buffered mode flicker</a>
<a name="ln731">// again. See HWInterface::Invalidate() for more information.</a>
<a name="ln732">		SetAsyncDoubleBuffered(doubleBuffered);</a>
<a name="ln733">#endif</a>
<a name="ln734">	}</a>
<a name="ln735"> </a>
<a name="ln736">	// update color palette configuration if necessary</a>
<a name="ln737">	if (fDisplayMode.space == B_CMAP8)</a>
<a name="ln738">		_SetSystemPalette();</a>
<a name="ln739">	else if (fDisplayMode.space == B_GRAY8)</a>
<a name="ln740">		_SetGrayscalePalette();</a>
<a name="ln741"> </a>
<a name="ln742">	// notify all listeners about the mode change</a>
<a name="ln743">	_NotifyFrameBufferChanged();</a>
<a name="ln744"> </a>
<a name="ln745">	return status;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748"> </a>
<a name="ln749">void</a>
<a name="ln750">AccelerantHWInterface::GetMode(display_mode* mode)</a>
<a name="ln751">{</a>
<a name="ln752">	if (mode &amp;&amp; LockParallelAccess()) {</a>
<a name="ln753">		*mode = fDisplayMode;</a>
<a name="ln754">		UnlockParallelAccess();</a>
<a name="ln755">	}</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758"> </a>
<a name="ln759">status_t</a>
<a name="ln760">AccelerantHWInterface::_UpdateModeList()</a>
<a name="ln761">{</a>
<a name="ln762">	fModeCount = fAccGetModeCount();</a>
<a name="ln763">	if (fModeCount &lt;= 0)</a>
<a name="ln764">		return B_ERROR;</a>
<a name="ln765"> </a>
<a name="ln766">	delete[] fModeList;</a>
<a name="ln767">	fModeList = new(nothrow) display_mode[fModeCount];</a>
<a name="ln768">	if (!fModeList)</a>
<a name="ln769">		return B_NO_MEMORY;</a>
<a name="ln770"> </a>
<a name="ln771">	if (fAccGetModeList(fModeList) != B_OK) {</a>
<a name="ln772">		ATRACE((&quot;unable to get mode list\n&quot;));</a>
<a name="ln773">		return B_ERROR;</a>
<a name="ln774">	}</a>
<a name="ln775"> </a>
<a name="ln776">	return B_OK;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779"> </a>
<a name="ln780">status_t</a>
<a name="ln781">AccelerantHWInterface::_UpdateFrameBufferConfig()</a>
<a name="ln782">{</a>
<a name="ln783">	if (fAccGetFrameBufferConfig(&amp;fFrameBufferConfig) != B_OK) {</a>
<a name="ln784">		ATRACE((&quot;unable to get frame buffer config\n&quot;));</a>
<a name="ln785">		return B_ERROR;</a>
<a name="ln786">	}</a>
<a name="ln787"> </a>
<a name="ln788">	fFrontBuffer-&gt;SetFrameBufferConfig(fFrameBufferConfig);</a>
<a name="ln789"> </a>
<a name="ln790">	return B_OK;</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793"> </a>
<a name="ln794">status_t</a>
<a name="ln795">AccelerantHWInterface::GetDeviceInfo(accelerant_device_info* info)</a>
<a name="ln796">{</a>
<a name="ln797">	get_accelerant_device_info GetAccelerantDeviceInfo</a>
<a name="ln798">		= (get_accelerant_device_info)fAccelerantHook(</a>
<a name="ln799">			B_GET_ACCELERANT_DEVICE_INFO, NULL);</a>
<a name="ln800">	if (!GetAccelerantDeviceInfo) {</a>
<a name="ln801">		ATRACE((&quot;No B_GET_ACCELERANT_DEVICE_INFO hook found\n&quot;));</a>
<a name="ln802">		return B_UNSUPPORTED;</a>
<a name="ln803">	}</a>
<a name="ln804"> </a>
<a name="ln805">	return GetAccelerantDeviceInfo(info);</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808"> </a>
<a name="ln809">status_t</a>
<a name="ln810">AccelerantHWInterface::GetFrameBufferConfig(frame_buffer_config&amp; config)</a>
<a name="ln811">{</a>
<a name="ln812">	config = fFrameBufferConfig;</a>
<a name="ln813">	return B_OK;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816"> </a>
<a name="ln817">status_t</a>
<a name="ln818">AccelerantHWInterface::GetModeList(display_mode** _modes, uint32* _count)</a>
<a name="ln819">{</a>
<a name="ln820">	AutoReadLocker _(this);</a>
<a name="ln821"> </a>
<a name="ln822">	if (_count == NULL || _modes == NULL)</a>
<a name="ln823">		return B_BAD_VALUE;</a>
<a name="ln824"> </a>
<a name="ln825">	status_t status = B_OK;</a>
<a name="ln826"> </a>
<a name="ln827">	if (fModeList == NULL)</a>
<a name="ln828">		status = _UpdateModeList();</a>
<a name="ln829"> </a>
<a name="ln830">	if (status &gt;= B_OK) {</a>
<a name="ln831">		*_modes = new(nothrow) display_mode[fModeCount];</a>
<a name="ln832">		if (*_modes) {</a>
<a name="ln833">			*_count = fModeCount;</a>
<a name="ln834">			memcpy(*_modes, fModeList, sizeof(display_mode) * fModeCount);</a>
<a name="ln835">		} else {</a>
<a name="ln836">			*_count = 0;</a>
<a name="ln837">			status = B_NO_MEMORY;</a>
<a name="ln838">		}</a>
<a name="ln839">	}</a>
<a name="ln840">	return status;</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843"> </a>
<a name="ln844">status_t</a>
<a name="ln845">AccelerantHWInterface::GetPixelClockLimits(display_mode *mode, uint32* _low,</a>
<a name="ln846">	uint32* _high)</a>
<a name="ln847">{</a>
<a name="ln848">	if (mode == NULL || _low == NULL || _high == NULL)</a>
<a name="ln849">		return B_BAD_VALUE;</a>
<a name="ln850"> </a>
<a name="ln851">	AutoReadLocker _(this);</a>
<a name="ln852">	return fAccGetPixelClockLimits(mode, _low, _high);</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855"> </a>
<a name="ln856">status_t</a>
<a name="ln857">AccelerantHWInterface::GetTimingConstraints(</a>
<a name="ln858">	display_timing_constraints* constraints)</a>
<a name="ln859">{</a>
<a name="ln860">	if (constraints == NULL)</a>
<a name="ln861">		return B_BAD_VALUE;</a>
<a name="ln862"> </a>
<a name="ln863">	AutoReadLocker _(this);</a>
<a name="ln864"> </a>
<a name="ln865">	if (fAccGetTimingConstraints)</a>
<a name="ln866">		return fAccGetTimingConstraints(constraints);</a>
<a name="ln867"> </a>
<a name="ln868">	return B_UNSUPPORTED;</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871"> </a>
<a name="ln872">status_t</a>
<a name="ln873">AccelerantHWInterface::ProposeMode(display_mode* candidate,</a>
<a name="ln874">	const display_mode* _low, const display_mode* _high)</a>
<a name="ln875">{</a>
<a name="ln876">	if (candidate == NULL || _low == NULL || _high == NULL)</a>
<a name="ln877">		return B_BAD_VALUE;</a>
<a name="ln878"> </a>
<a name="ln879">	AutoReadLocker _(this);</a>
<a name="ln880"> </a>
<a name="ln881">	if (fAccProposeDisplayMode == NULL)</a>
<a name="ln882">		return B_UNSUPPORTED;</a>
<a name="ln883"> </a>
<a name="ln884">	// avoid const issues</a>
<a name="ln885">	display_mode high, low;</a>
<a name="ln886">	high = *_high;</a>
<a name="ln887">	low = *_low;</a>
<a name="ln888"> </a>
<a name="ln889">	return fAccProposeDisplayMode(candidate, &amp;low, &amp;high);</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892"> </a>
<a name="ln893">status_t</a>
<a name="ln894">AccelerantHWInterface::GetPreferredMode(display_mode* preferredMode)</a>
<a name="ln895">{</a>
<a name="ln896">	status_t status = B_NOT_SUPPORTED;</a>
<a name="ln897"> </a>
<a name="ln898">	if (fAccGetPreferredDisplayMode != NULL) {</a>
<a name="ln899">		status = fAccGetPreferredDisplayMode(preferredMode);</a>
<a name="ln900">		if (status == B_OK)</a>
<a name="ln901">			return B_OK;</a>
<a name="ln902">	}</a>
<a name="ln903"> </a>
<a name="ln904">	if (fAccGetEDIDInfo != NULL) {</a>
<a name="ln905">		edid1_info info;</a>
<a name="ln906">		uint32 version;</a>
<a name="ln907">		status = fAccGetEDIDInfo(&amp;info, sizeof(info), &amp;version);</a>
<a name="ln908">		if (status &lt; B_OK)</a>
<a name="ln909">			return status;</a>
<a name="ln910">		if (version != EDID_VERSION_1)</a>
<a name="ln911">			return B_NOT_SUPPORTED;</a>
<a name="ln912"> </a>
<a name="ln913">		if (fModeList == NULL) {</a>
<a name="ln914">			status = _UpdateModeList();</a>
<a name="ln915">			if (status != B_OK)</a>
<a name="ln916">				return status;</a>
<a name="ln917">		}</a>
<a name="ln918"> </a>
<a name="ln919">		status = B_NOT_SUPPORTED;</a>
<a name="ln920">		display_mode bestMode;</a>
<a name="ln921">		int32 bestDiff = INT_MAX;</a>
<a name="ln922"> </a>
<a name="ln923">		// find preferred mode from EDID info</a>
<a name="ln924">		for (uint32 i = 0; i &lt; EDID1_NUM_DETAILED_MONITOR_DESC; ++i) {</a>
<a name="ln925">			if (info.detailed_monitor[i].monitor_desc_type</a>
<a name="ln926">					!= EDID1_IS_DETAILED_TIMING)</a>
<a name="ln927">				continue;</a>
<a name="ln928"> </a>
<a name="ln929">			// construct basic mode and find it in the mode list</a>
<a name="ln930">			const edid1_detailed_timing&amp; timing</a>
<a name="ln931">				= info.detailed_monitor[i].data.detailed_timing;</a>
<a name="ln932">			if (timing.h_active &lt; 640 || timing.v_active &lt; 350)</a>
<a name="ln933">				continue;</a>
<a name="ln934"> </a>
<a name="ln935">			float aspectRatio = 0.0f;</a>
<a name="ln936">			if (timing.h_size &gt; 0 &amp;&amp; timing.v_size &gt; 0)</a>
<a name="ln937">				aspectRatio = 1.0f * timing.h_size / timing.v_size;</a>
<a name="ln938"> </a>
<a name="ln939">			display_mode modeFound;</a>
<a name="ln940">			display_mode mode;</a>
<a name="ln941"> </a>
<a name="ln942">			mode.timing.pixel_clock = timing.pixel_clock * 10;</a>
<a name="ln943">			mode.timing.h_display = timing.h_active;</a>
<a name="ln944">			mode.timing.h_sync_start = timing.h_active + timing.h_sync_off;</a>
<a name="ln945">			mode.timing.h_sync_end = mode.timing.h_sync_start</a>
<a name="ln946">				+ timing.h_sync_width;</a>
<a name="ln947">			mode.timing.h_total = timing.h_active + timing.h_blank;</a>
<a name="ln948">			mode.timing.v_display = timing.v_active;</a>
<a name="ln949">			mode.timing.v_sync_start = timing.v_active + timing.v_sync_off;</a>
<a name="ln950">			mode.timing.v_sync_end = mode.timing.v_sync_start</a>
<a name="ln951">				+ timing.v_sync_width;</a>
<a name="ln952">			mode.timing.v_total = timing.v_active + timing.v_blank;</a>
<a name="ln953"> </a>
<a name="ln954">			mode.space = B_RGB32;</a>
<a name="ln955">			mode.virtual_width = mode.timing.h_display;</a>
<a name="ln956">			mode.virtual_height = mode.timing.v_display;</a>
<a name="ln957"> </a>
<a name="ln958">			// TODO: eventually ignore detailed modes for the preferred one</a>
<a name="ln959">			// if there are more than one usable?</a>
<a name="ln960">			int32 diff;</a>
<a name="ln961">			if (_FindBestMode(mode, aspectRatio, modeFound, &amp;diff) == B_OK) {</a>
<a name="ln962">				status = B_OK;</a>
<a name="ln963">				if (diff &lt; bestDiff) {</a>
<a name="ln964">					bestMode = modeFound;</a>
<a name="ln965">					bestDiff = diff;</a>
<a name="ln966">				}</a>
<a name="ln967">			}</a>
<a name="ln968">		}</a>
<a name="ln969"> </a>
<a name="ln970">		if (status == B_OK)</a>
<a name="ln971">			*preferredMode = bestMode;</a>
<a name="ln972">	}</a>
<a name="ln973"> </a>
<a name="ln974">	return status;</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977"> </a>
<a name="ln978">status_t</a>
<a name="ln979">AccelerantHWInterface::GetMonitorInfo(monitor_info* info)</a>
<a name="ln980">{</a>
<a name="ln981">	status_t status = B_NOT_SUPPORTED;</a>
<a name="ln982"> </a>
<a name="ln983">	if (fAccGetMonitorInfo != NULL) {</a>
<a name="ln984">		status = fAccGetMonitorInfo(info);</a>
<a name="ln985">		if (status == B_OK)</a>
<a name="ln986">			return B_OK;</a>
<a name="ln987">	}</a>
<a name="ln988"> </a>
<a name="ln989">	if (fAccGetEDIDInfo == NULL)</a>
<a name="ln990">		return status;</a>
<a name="ln991"> </a>
<a name="ln992">	edid1_info edid;</a>
<a name="ln993">	uint32 version;</a>
<a name="ln994">	status = fAccGetEDIDInfo(&amp;edid, sizeof(edid), &amp;version);</a>
<a name="ln995">	if (status &lt; B_OK)</a>
<a name="ln996">		return status;</a>
<a name="ln997">	if (version != EDID_VERSION_1)</a>
<a name="ln998">		return B_NOT_SUPPORTED;</a>
<a name="ln999"> </a>
<a name="ln1000">	memset(info, 0, sizeof(monitor_info));</a>
<a name="ln1001">	strlcpy(info-&gt;vendor, edid.vendor.manufacturer, sizeof(info-&gt;vendor));</a>
<a name="ln1002">	if (edid.vendor.serial != 0) {</a>
<a name="ln1003">		snprintf(info-&gt;serial_number, sizeof(info-&gt;serial_number), &quot;%&quot; B_PRIu32,</a>
<a name="ln1004">			edid.vendor.serial);</a>
<a name="ln1005">	}</a>
<a name="ln1006">	info-&gt;product_id = edid.vendor.prod_id;</a>
<a name="ln1007">	info-&gt;produced.week = edid.vendor.week;</a>
<a name="ln1008">	info-&gt;produced.year = edid.vendor.year;</a>
<a name="ln1009">	info-&gt;width = edid.display.h_size;</a>
<a name="ln1010">	info-&gt;height = edid.display.v_size;</a>
<a name="ln1011"> </a>
<a name="ln1012">	for (uint32 i = 0; i &lt; EDID1_NUM_DETAILED_MONITOR_DESC; ++i) {</a>
<a name="ln1013">		edid1_detailed_monitor *monitor = &amp;edid.detailed_monitor[i];</a>
<a name="ln1014"> </a>
<a name="ln1015">		switch (monitor-&gt;monitor_desc_type) {</a>
<a name="ln1016">			case EDID1_SERIAL_NUMBER:</a>
<a name="ln1017">				strlcpy(info-&gt;serial_number, monitor-&gt;data.serial_number,</a>
<a name="ln1018">					sizeof(info-&gt;serial_number));</a>
<a name="ln1019">				break;</a>
<a name="ln1020"> </a>
<a name="ln1021">			case EDID1_MONITOR_NAME:</a>
<a name="ln1022">				// There can be several of these; in this case we'll just</a>
<a name="ln1023">				// overwrite the previous entries</a>
<a name="ln1024">				// TODO: we could append them as well</a>
<a name="ln1025">				strlcpy(info-&gt;name, monitor-&gt;data.monitor_name,</a>
<a name="ln1026">					sizeof(info-&gt;name));</a>
<a name="ln1027">				break;</a>
<a name="ln1028"> </a>
<a name="ln1029">			case EDID1_MONITOR_RANGES:</a>
<a name="ln1030">			{</a>
<a name="ln1031">				edid1_monitor_range&amp; range = monitor-&gt;data.monitor_range;</a>
<a name="ln1032"> </a>
<a name="ln1033">				info-&gt;min_horizontal_frequency = range.min_h;</a>
<a name="ln1034">				info-&gt;max_horizontal_frequency = range.max_h;</a>
<a name="ln1035">				info-&gt;min_vertical_frequency = range.min_v;</a>
<a name="ln1036">				info-&gt;max_vertical_frequency = range.max_v;</a>
<a name="ln1037">				info-&gt;max_pixel_clock = range.max_clock * 10000;</a>
<a name="ln1038">				break;</a>
<a name="ln1039">			}</a>
<a name="ln1040"> </a>
<a name="ln1041">			case EDID1_IS_DETAILED_TIMING:</a>
<a name="ln1042">			{</a>
<a name="ln1043">				edid1_detailed_timing&amp; timing = monitor-&gt;data.detailed_timing;</a>
<a name="ln1044">				info-&gt;width = timing.h_size / 10.0;</a>
<a name="ln1045">				info-&gt;height = timing.v_size / 10.0;</a>
<a name="ln1046">			}</a>
<a name="ln1047"> </a>
<a name="ln1048">			default:</a>
<a name="ln1049">				break;</a>
<a name="ln1050">		}</a>
<a name="ln1051">	}</a>
<a name="ln1052"> </a>
<a name="ln1053">	return B_OK;</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056"> </a>
<a name="ln1057">sem_id</a>
<a name="ln1058">AccelerantHWInterface::RetraceSemaphore()</a>
<a name="ln1059">{</a>
<a name="ln1060">	AutoWriteLocker _(this);</a>
<a name="ln1061"> </a>
<a name="ln1062">	if (fRetraceSemaphore != -1)</a>
<a name="ln1063">		return fRetraceSemaphore;</a>
<a name="ln1064"> </a>
<a name="ln1065">	accelerant_retrace_semaphore AccelerantRetraceSemaphore =</a>
<a name="ln1066">		(accelerant_retrace_semaphore)fAccelerantHook(</a>
<a name="ln1067">			B_ACCELERANT_RETRACE_SEMAPHORE, NULL);</a>
<a name="ln1068">	if (!AccelerantRetraceSemaphore)</a>
<a name="ln1069">		fRetraceSemaphore = B_UNSUPPORTED;</a>
<a name="ln1070">	else</a>
<a name="ln1071">		fRetraceSemaphore = AccelerantRetraceSemaphore();</a>
<a name="ln1072"> </a>
<a name="ln1073">	return fRetraceSemaphore;</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076"> </a>
<a name="ln1077">status_t</a>
<a name="ln1078">AccelerantHWInterface::WaitForRetrace(bigtime_t timeout)</a>
<a name="ln1079">{</a>
<a name="ln1080">	sem_id sem = RetraceSemaphore();</a>
<a name="ln1081">	if (sem &lt; 0)</a>
<a name="ln1082">		return sem;</a>
<a name="ln1083"> </a>
<a name="ln1084">	return acquire_sem_etc(sem, 1, B_RELATIVE_TIMEOUT, timeout);</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087"> </a>
<a name="ln1088">status_t</a>
<a name="ln1089">AccelerantHWInterface::SetDPMSMode(uint32 state)</a>
<a name="ln1090">{</a>
<a name="ln1091">	AutoWriteLocker _(this);</a>
<a name="ln1092"> </a>
<a name="ln1093">	if (!fAccSetDPMSMode)</a>
<a name="ln1094">		return B_UNSUPPORTED;</a>
<a name="ln1095"> </a>
<a name="ln1096">	return fAccSetDPMSMode(state);</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099"> </a>
<a name="ln1100">uint32</a>
<a name="ln1101">AccelerantHWInterface::DPMSMode()</a>
<a name="ln1102">{</a>
<a name="ln1103">	AutoReadLocker _(this);</a>
<a name="ln1104"> </a>
<a name="ln1105">	if (!fAccDPMSMode)</a>
<a name="ln1106">		return B_UNSUPPORTED;</a>
<a name="ln1107"> </a>
<a name="ln1108">	return fAccDPMSMode();</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111"> </a>
<a name="ln1112">uint32</a>
<a name="ln1113">AccelerantHWInterface::DPMSCapabilities()</a>
<a name="ln1114">{</a>
<a name="ln1115">	AutoReadLocker _(this);</a>
<a name="ln1116"> </a>
<a name="ln1117">	if (!fAccDPMSCapabilities)</a>
<a name="ln1118">		return B_UNSUPPORTED;</a>
<a name="ln1119"> </a>
<a name="ln1120">	return fAccDPMSCapabilities();</a>
<a name="ln1121">}</a>
<a name="ln1122"> </a>
<a name="ln1123"> </a>
<a name="ln1124">status_t</a>
<a name="ln1125">AccelerantHWInterface::SetBrightness(float brightness)</a>
<a name="ln1126">{</a>
<a name="ln1127">	AutoReadLocker _(this);</a>
<a name="ln1128"> </a>
<a name="ln1129">	if (!fAccSetBrightness)</a>
<a name="ln1130">		return B_UNSUPPORTED;</a>
<a name="ln1131"> </a>
<a name="ln1132">	return fAccSetBrightness(brightness);</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135"> </a>
<a name="ln1136">status_t</a>
<a name="ln1137">AccelerantHWInterface::GetBrightness(float* brightness)</a>
<a name="ln1138">{</a>
<a name="ln1139">	AutoReadLocker _(this);</a>
<a name="ln1140"> </a>
<a name="ln1141">	if (!fAccGetBrightness)</a>
<a name="ln1142">		return B_UNSUPPORTED;</a>
<a name="ln1143"> </a>
<a name="ln1144">	return fAccGetBrightness(brightness);</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147"> </a>
<a name="ln1148">status_t</a>
<a name="ln1149">AccelerantHWInterface::GetAccelerantPath(BString&amp; string)</a>
<a name="ln1150">{</a>
<a name="ln1151">	image_info info;</a>
<a name="ln1152">	status_t status = get_image_info(fAccelerantImage, &amp;info);</a>
<a name="ln1153">	if (status == B_OK)</a>
<a name="ln1154">		string = info.name;</a>
<a name="ln1155">	return status;</a>
<a name="ln1156">}</a>
<a name="ln1157"> </a>
<a name="ln1158"> </a>
<a name="ln1159">status_t</a>
<a name="ln1160">AccelerantHWInterface::GetDriverPath(BString&amp; string)</a>
<a name="ln1161">{</a>
<a name="ln1162">	// TODO: this currently assumes that the accelerant's clone info</a>
<a name="ln1163">	//	is always the path name of its driver (that's the case for</a>
<a name="ln1164">	//	all of our drivers)</a>
<a name="ln1165">	char path[B_PATH_NAME_LENGTH];</a>
<a name="ln1166">	get_accelerant_clone_info getCloneInfo;</a>
<a name="ln1167">	getCloneInfo = (get_accelerant_clone_info)fAccelerantHook(</a>
<a name="ln1168">		B_GET_ACCELERANT_CLONE_INFO, NULL);</a>
<a name="ln1169"> </a>
<a name="ln1170">	if (getCloneInfo == NULL)</a>
<a name="ln1171">		return B_NOT_SUPPORTED;</a>
<a name="ln1172"> </a>
<a name="ln1173">	getCloneInfo((void*)path);</a>
<a name="ln1174">	string.SetTo(path);</a>
<a name="ln1175">	return B_OK;</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178"> </a>
<a name="ln1179">// #pragma mark - acceleration</a>
<a name="ln1180"> </a>
<a name="ln1181"> </a>
<a name="ln1182">uint32</a>
<a name="ln1183">AccelerantHWInterface::AvailableHWAcceleration() const</a>
<a name="ln1184">{</a>
<a name="ln1185">	uint32 flags = 0;</a>
<a name="ln1186"> </a>
<a name="ln1187">	if (!IsDoubleBuffered() || fOffscreenBackBuffer) {</a>
<a name="ln1188">		if (fAccScreenBlit)</a>
<a name="ln1189">			flags |= HW_ACC_COPY_REGION;</a>
<a name="ln1190">		if (fAccFillRect)</a>
<a name="ln1191">			flags |= HW_ACC_FILL_REGION;</a>
<a name="ln1192">		if (fAccInvertRect)</a>
<a name="ln1193">			flags |= HW_ACC_INVERT_REGION;</a>
<a name="ln1194">	}</a>
<a name="ln1195"> </a>
<a name="ln1196">	return flags;</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199"> </a>
<a name="ln1200">void</a>
<a name="ln1201">AccelerantHWInterface::CopyRegion(const clipping_rect* sortedRectList,</a>
<a name="ln1202">	uint32 count, int32 xOffset, int32 yOffset)</a>
<a name="ln1203">{</a>
<a name="ln1204">	_CopyRegion(sortedRectList, count, xOffset, yOffset, fOffscreenBackBuffer);</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207"> </a>
<a name="ln1208">void</a>
<a name="ln1209">AccelerantHWInterface::FillRegion(/*const*/ BRegion&amp; region,</a>
<a name="ln1210">	const rgb_color&amp; color, bool autoSync)</a>
<a name="ln1211">{</a>
<a name="ln1212">	if (fAccFillRect &amp;&amp; fAccAcquireEngine) {</a>
<a name="ln1213">		if (fAccAcquireEngine(B_2D_ACCELERATION, 0xff, &amp;fSyncToken,</a>
<a name="ln1214">				&amp;fEngineToken) &gt;= B_OK) {</a>
<a name="ln1215">			// convert the region</a>
<a name="ln1216">			uint32 count;</a>
<a name="ln1217">			_RegionToRectParams(&amp;region, &amp;count);</a>
<a name="ln1218"> </a>
<a name="ln1219">			// go</a>
<a name="ln1220">			fAccFillRect(fEngineToken, _NativeColor(color), fRectParams, count);</a>
<a name="ln1221"> </a>
<a name="ln1222">			// done</a>
<a name="ln1223">			if (fAccReleaseEngine)</a>
<a name="ln1224">				fAccReleaseEngine(fEngineToken, &amp;fSyncToken);</a>
<a name="ln1225"> </a>
<a name="ln1226">			// sync</a>
<a name="ln1227">			if (autoSync &amp;&amp; fAccSyncToToken)</a>
<a name="ln1228">				fAccSyncToToken(&amp;fSyncToken);</a>
<a name="ln1229">		}</a>
<a name="ln1230">	}</a>
<a name="ln1231">}</a>
<a name="ln1232"> </a>
<a name="ln1233"> </a>
<a name="ln1234">void</a>
<a name="ln1235">AccelerantHWInterface::InvertRegion(/*const*/ BRegion&amp; region)</a>
<a name="ln1236">{</a>
<a name="ln1237">	if (fAccInvertRect &amp;&amp; fAccAcquireEngine) {</a>
<a name="ln1238">		if (fAccAcquireEngine(B_2D_ACCELERATION, 0xff, &amp;fSyncToken,</a>
<a name="ln1239">				&amp;fEngineToken) &gt;= B_OK) {</a>
<a name="ln1240">			// convert the region</a>
<a name="ln1241">			uint32 count;</a>
<a name="ln1242">			_RegionToRectParams(&amp;region, &amp;count);</a>
<a name="ln1243"> </a>
<a name="ln1244">			fAccInvertRect(fEngineToken, fRectParams, count);</a>
<a name="ln1245"> </a>
<a name="ln1246">			if (fAccReleaseEngine)</a>
<a name="ln1247">				fAccReleaseEngine(fEngineToken, &amp;fSyncToken);</a>
<a name="ln1248">			if (fAccSyncToToken)</a>
<a name="ln1249">				fAccSyncToToken(&amp;fSyncToken);</a>
<a name="ln1250">		}</a>
<a name="ln1251">	}</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254"> </a>
<a name="ln1255">void</a>
<a name="ln1256">AccelerantHWInterface::Sync()</a>
<a name="ln1257">{</a>
<a name="ln1258">	if (fAccSyncToToken)</a>
<a name="ln1259">		fAccSyncToToken(&amp;fSyncToken);</a>
<a name="ln1260">}</a>
<a name="ln1261"> </a>
<a name="ln1262"> </a>
<a name="ln1263">// #pragma mark - overlays</a>
<a name="ln1264"> </a>
<a name="ln1265"> </a>
<a name="ln1266">overlay_token</a>
<a name="ln1267">AccelerantHWInterface::AcquireOverlayChannel()</a>
<a name="ln1268">{</a>
<a name="ln1269">	if (fAccAllocateOverlay == NULL</a>
<a name="ln1270">		|| fAccReleaseOverlay == NULL)</a>
<a name="ln1271">		return NULL;</a>
<a name="ln1272"> </a>
<a name="ln1273">	// The current display mode only matters at the time we're planning on</a>
<a name="ln1274">	// showing the overlay channel on screen - that's why we can't use</a>
<a name="ln1275">	// the B_OVERLAY_COUNT hook.</a>
<a name="ln1276">	// TODO: remove fAccOverlayCount if we're not going to need it at all.</a>
<a name="ln1277"> </a>
<a name="ln1278">	return fAccAllocateOverlay();</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281"> </a>
<a name="ln1282">void</a>
<a name="ln1283">AccelerantHWInterface::ReleaseOverlayChannel(overlay_token token)</a>
<a name="ln1284">{</a>
<a name="ln1285">	if (token == NULL)</a>
<a name="ln1286">		return;</a>
<a name="ln1287"> </a>
<a name="ln1288">	fAccReleaseOverlay(token);</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291"> </a>
<a name="ln1292">status_t</a>
<a name="ln1293">AccelerantHWInterface::GetOverlayRestrictions(const Overlay* overlay,</a>
<a name="ln1294">	overlay_restrictions* restrictions)</a>
<a name="ln1295">{</a>
<a name="ln1296">	if (overlay == NULL || restrictions == NULL)</a>
<a name="ln1297">		return B_BAD_VALUE;</a>
<a name="ln1298">	if (fAccGetOverlayConstraints == NULL)</a>
<a name="ln1299">		return B_NOT_SUPPORTED;</a>
<a name="ln1300"> </a>
<a name="ln1301">	overlay_constraints constraints;</a>
<a name="ln1302">	status_t status = fAccGetOverlayConstraints(&amp;fDisplayMode,</a>
<a name="ln1303">		overlay-&gt;OverlayBuffer(), &amp;constraints);</a>
<a name="ln1304">	if (status &lt; B_OK)</a>
<a name="ln1305">		return status;</a>
<a name="ln1306"> </a>
<a name="ln1307">	memset(restrictions, 0, sizeof(overlay_restrictions));</a>
<a name="ln1308">	memcpy(&amp;restrictions-&gt;source, &amp;constraints.view, sizeof(overlay_limits));</a>
<a name="ln1309">	memcpy(&amp;restrictions-&gt;destination, &amp;constraints.window,</a>
<a name="ln1310">		sizeof(overlay_limits));</a>
<a name="ln1311">	restrictions-&gt;min_width_scale = constraints.h_scale.min;</a>
<a name="ln1312">	restrictions-&gt;max_width_scale = constraints.h_scale.max;</a>
<a name="ln1313">	restrictions-&gt;min_height_scale = constraints.v_scale.min;</a>
<a name="ln1314">	restrictions-&gt;max_height_scale = constraints.v_scale.max;</a>
<a name="ln1315"> </a>
<a name="ln1316">	return B_OK;</a>
<a name="ln1317">}</a>
<a name="ln1318"> </a>
<a name="ln1319"> </a>
<a name="ln1320">bool</a>
<a name="ln1321">AccelerantHWInterface::CheckOverlayRestrictions(int32 width, int32 height,</a>
<a name="ln1322">	color_space colorSpace)</a>
<a name="ln1323">{</a>
<a name="ln1324">	if (fAccOverlaySupportedSpaces == NULL</a>
<a name="ln1325">		|| fAccGetOverlayConstraints == NULL</a>
<a name="ln1326">		|| fAccAllocateOverlayBuffer == NULL</a>
<a name="ln1327">		|| fAccReleaseOverlayBuffer == NULL)</a>
<a name="ln1328">		return false;</a>
<a name="ln1329"> </a>
<a name="ln1330">	// Note: we can't really check the size of the overlay upfront - we</a>
<a name="ln1331">	// must assume fAccAllocateOverlayBuffer() will fail in that case.</a>
<a name="ln1332">	if (width &lt; 0 || width &gt; 65535 || height &lt; 0 || height &gt; 65535)</a>
<a name="ln1333">		return false;</a>
<a name="ln1334"> </a>
<a name="ln1335">	// check color space</a>
<a name="ln1336"> </a>
<a name="ln1337">	const uint32* spaces = fAccOverlaySupportedSpaces(&amp;fDisplayMode);</a>
<a name="ln1338">	if (spaces == NULL)</a>
<a name="ln1339">		return false;</a>
<a name="ln1340"> </a>
<a name="ln1341">	for (int32 i = 0; spaces[i] != 0; i++) {</a>
<a name="ln1342">		if (spaces[i] == (uint32)colorSpace)</a>
<a name="ln1343">			return true;</a>
<a name="ln1344">	}</a>
<a name="ln1345"> </a>
<a name="ln1346">	return false;</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349"> </a>
<a name="ln1350">const overlay_buffer*</a>
<a name="ln1351">AccelerantHWInterface::AllocateOverlayBuffer(int32 width, int32 height,</a>
<a name="ln1352">	color_space space)</a>
<a name="ln1353">{</a>
<a name="ln1354">	if (fAccAllocateOverlayBuffer == NULL)</a>
<a name="ln1355">		return NULL;</a>
<a name="ln1356"> </a>
<a name="ln1357">	return fAccAllocateOverlayBuffer(space, width, height);</a>
<a name="ln1358">}</a>
<a name="ln1359"> </a>
<a name="ln1360"> </a>
<a name="ln1361">void</a>
<a name="ln1362">AccelerantHWInterface::FreeOverlayBuffer(const overlay_buffer* buffer)</a>
<a name="ln1363">{</a>
<a name="ln1364">	if (buffer == NULL || fAccReleaseOverlayBuffer == NULL)</a>
<a name="ln1365">		return;</a>
<a name="ln1366"> </a>
<a name="ln1367">	fAccReleaseOverlayBuffer(buffer);</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370"> </a>
<a name="ln1371">void</a>
<a name="ln1372">AccelerantHWInterface::ConfigureOverlay(Overlay* overlay)</a>
<a name="ln1373">{</a>
<a name="ln1374">	// TODO: this only needs to be done on mode changes!</a>
<a name="ln1375">	overlay-&gt;SetColorSpace(fDisplayMode.space);</a>
<a name="ln1376"> </a>
<a name="ln1377">	fAccConfigureOverlay(overlay-&gt;OverlayToken(), overlay-&gt;OverlayBuffer(),</a>
<a name="ln1378">		overlay-&gt;OverlayWindow(), overlay-&gt;OverlayView());</a>
<a name="ln1379">}</a>
<a name="ln1380"> </a>
<a name="ln1381"> </a>
<a name="ln1382">void</a>
<a name="ln1383">AccelerantHWInterface::HideOverlay(Overlay* overlay)</a>
<a name="ln1384">{</a>
<a name="ln1385">	fAccConfigureOverlay(overlay-&gt;OverlayToken(), overlay-&gt;OverlayBuffer(),</a>
<a name="ln1386">		NULL, NULL);</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389"> </a>
<a name="ln1390">// #pragma mark - cursor</a>
<a name="ln1391"> </a>
<a name="ln1392"> </a>
<a name="ln1393">void</a>
<a name="ln1394">AccelerantHWInterface::SetCursor(ServerCursor* cursor)</a>
<a name="ln1395">{</a>
<a name="ln1396">	// cursor should never be NULL, but let us be safe!!</a>
<a name="ln1397">	if (cursor == NULL || LockExclusiveAccess() == false)</a>
<a name="ln1398">		return;</a>
<a name="ln1399"> </a>
<a name="ln1400">	bool cursorSet = false;</a>
<a name="ln1401"> </a>
<a name="ln1402">	if (fAccSetCursorBitmap != NULL) {</a>
<a name="ln1403">		// Bitmap cursor</a>
<a name="ln1404">		// TODO are x and y switched for this, too?</a>
<a name="ln1405">		uint16 xHotSpot = (uint16)cursor-&gt;GetHotSpot().x;</a>
<a name="ln1406">		uint16 yHotSpot = (uint16)cursor-&gt;GetHotSpot().y;</a>
<a name="ln1407"> </a>
<a name="ln1408">		uint16 width = (uint16)cursor-&gt;Bounds().Width();</a>
<a name="ln1409">		uint16 height = (uint16)cursor-&gt;Bounds().Height();</a>
<a name="ln1410"> </a>
<a name="ln1411">		// Time to talk to the accelerant!</a>
<a name="ln1412">		cursorSet = fAccSetCursorBitmap(width, height, xHotSpot,</a>
<a name="ln1413">			yHotSpot, cursor-&gt;ColorSpace(), (uint16)cursor-&gt;BytesPerRow(),</a>
<a name="ln1414">			cursor-&gt;Bits()) == B_OK;</a>
<a name="ln1415">	} else if (cursor-&gt;CursorData() != NULL &amp;&amp; fAccSetCursorShape != NULL) {</a>
<a name="ln1416">		// BeOS BCursor, 16x16 monochrome</a>
<a name="ln1417">		uint8 size = cursor-&gt;CursorData()[0];</a>
<a name="ln1418">		// CursorData()[1] is color depth (always monochrome)</a>
<a name="ln1419">		// x and y are switched</a>
<a name="ln1420">		uint8 xHotSpot = cursor-&gt;CursorData()[3];</a>
<a name="ln1421">		uint8 yHotSpot = cursor-&gt;CursorData()[2];</a>
<a name="ln1422"> </a>
<a name="ln1423">		// Create pointers to the cursor and/xor bit arrays</a>
<a name="ln1424">		// for the BeOS BCursor there are two 32 byte, 16x16 bit arrays</a>
<a name="ln1425">		// in the first:  1 is black,  0 is white</a>
<a name="ln1426">		// in the second: 1 is opaque, 0 is transparent</a>
<a name="ln1427">		// 1st	2nd</a>
<a name="ln1428">		//  0	 0	 transparent</a>
<a name="ln1429">		//  0	 1	 white</a>
<a name="ln1430">		//  1	 0	 transparent</a>
<a name="ln1431">		//  1	 1	 black</a>
<a name="ln1432">		// for the HW cursor the first is ANDed and the second is XORed</a>
<a name="ln1433">		// AND	XOR</a>
<a name="ln1434">		//  0	 0	 white</a>
<a name="ln1435">		//  0	 1	 black</a>
<a name="ln1436">		//  1	 0	 transparent</a>
<a name="ln1437">		//  1	 1	 reverse</a>
<a name="ln1438">		// so, the first 32 bytes are the XOR mask</a>
<a name="ln1439">		const uint8* xorMask = cursor-&gt;CursorData() + 4;</a>
<a name="ln1440">		// the second 32 bytes *NOTed* are the AND mask</a>
<a name="ln1441">		// TODO maybe this should be NOTed when copied to the ServerCursor</a>
<a name="ln1442">		uint8 andMask[32];</a>
<a name="ln1443">		const uint8* transMask = cursor-&gt;CursorData() + 36;</a>
<a name="ln1444">		for (int32 i = 0; i &lt; 32; i++)</a>
<a name="ln1445">			andMask[i] = ~transMask[i];</a>
<a name="ln1446"> </a>
<a name="ln1447">		// Time to talk to the accelerant!</a>
<a name="ln1448">		cursorSet = fAccSetCursorShape(size, size, xHotSpot,</a>
<a name="ln1449">			yHotSpot, andMask, xorMask) == B_OK;</a>
<a name="ln1450">	}</a>
<a name="ln1451"> </a>
<a name="ln1452">	if (cursorSet &amp;&amp; !fHardwareCursorEnabled) {</a>
<a name="ln1453">		// we switched from SW to HW, so we need to erase the SW cursor</a>
<a name="ln1454">		if (fCursorVisible &amp;&amp; fFloatingOverlaysLock.Lock()) {</a>
<a name="ln1455">			IntRect r = _CursorFrame();</a>
<a name="ln1456">			fCursorVisible = false;</a>
<a name="ln1457">				// so the Invalidate doesn't draw it again</a>
<a name="ln1458">			_RestoreCursorArea();</a>
<a name="ln1459">			Invalidate(r);</a>
<a name="ln1460">			fCursorVisible = true;</a>
<a name="ln1461">			fFloatingOverlaysLock.Unlock();</a>
<a name="ln1462">		}</a>
<a name="ln1463">		// and we need to update our position</a>
<a name="ln1464">		if (fAccMoveCursor != NULL)</a>
<a name="ln1465">			fAccMoveCursor((uint16)fCursorLocation.x,</a>
<a name="ln1466">				(uint16)fCursorLocation.y);</a>
<a name="ln1467">	}</a>
<a name="ln1468"> </a>
<a name="ln1469">	if (fAccShowCursor != NULL)</a>
<a name="ln1470">		fAccShowCursor(cursorSet);</a>
<a name="ln1471"> </a>
<a name="ln1472">	UnlockExclusiveAccess();</a>
<a name="ln1473"> </a>
<a name="ln1474">	fHardwareCursorEnabled = cursorSet;</a>
<a name="ln1475"> </a>
<a name="ln1476">	HWInterface::SetCursor(cursor);</a>
<a name="ln1477">		// HWInterface claims ownership of cursor.</a>
<a name="ln1478">}</a>
<a name="ln1479"> </a>
<a name="ln1480"> </a>
<a name="ln1481">void</a>
<a name="ln1482">AccelerantHWInterface::SetCursorVisible(bool visible)</a>
<a name="ln1483">{</a>
<a name="ln1484">	HWInterface::SetCursorVisible(visible);</a>
<a name="ln1485"> </a>
<a name="ln1486">	if (fHardwareCursorEnabled &amp;&amp; LockExclusiveAccess()) {</a>
<a name="ln1487">		if (fAccShowCursor != NULL)</a>
<a name="ln1488">				fAccShowCursor(visible);</a>
<a name="ln1489">		else</a>
<a name="ln1490">			fHardwareCursorEnabled = false;</a>
<a name="ln1491"> </a>
<a name="ln1492">		UnlockExclusiveAccess();</a>
<a name="ln1493">	}</a>
<a name="ln1494">}</a>
<a name="ln1495"> </a>
<a name="ln1496"> </a>
<a name="ln1497">void</a>
<a name="ln1498">AccelerantHWInterface::MoveCursorTo(float x, float y)</a>
<a name="ln1499">{</a>
<a name="ln1500">	HWInterface::MoveCursorTo(x, y);</a>
<a name="ln1501"> </a>
<a name="ln1502">	if (fHardwareCursorEnabled &amp;&amp; LockExclusiveAccess()) {</a>
<a name="ln1503">		if (fAccMoveCursor != NULL)</a>
<a name="ln1504">				fAccMoveCursor((uint16)x, (uint16)y);</a>
<a name="ln1505">		else {</a>
<a name="ln1506">			fHardwareCursorEnabled = false;</a>
<a name="ln1507">			if (fAccShowCursor != NULL)</a>
<a name="ln1508">				fAccShowCursor(false);</a>
<a name="ln1509">		}</a>
<a name="ln1510"> </a>
<a name="ln1511">		UnlockExclusiveAccess();</a>
<a name="ln1512">	}</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515"> </a>
<a name="ln1516">// #pragma mark - buffer access</a>
<a name="ln1517"> </a>
<a name="ln1518"> </a>
<a name="ln1519">RenderingBuffer*</a>
<a name="ln1520">AccelerantHWInterface::FrontBuffer() const</a>
<a name="ln1521">{</a>
<a name="ln1522">	return fFrontBuffer;</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525"> </a>
<a name="ln1526">RenderingBuffer*</a>
<a name="ln1527">AccelerantHWInterface::BackBuffer() const</a>
<a name="ln1528">{</a>
<a name="ln1529">	return fBackBuffer;</a>
<a name="ln1530">}</a>
<a name="ln1531"> </a>
<a name="ln1532"> </a>
<a name="ln1533">bool</a>
<a name="ln1534">AccelerantHWInterface::IsDoubleBuffered() const</a>
<a name="ln1535">{</a>
<a name="ln1536">	return fBackBuffer != NULL;</a>
<a name="ln1537">}</a>
<a name="ln1538"> </a>
<a name="ln1539"> </a>
<a name="ln1540">void</a>
<a name="ln1541">AccelerantHWInterface::_CopyBackToFront(/*const*/ BRegion&amp; region)</a>
<a name="ln1542">{</a>
<a name="ln1543">	if (fOffscreenBackBuffer) {</a>
<a name="ln1544">		int32 xOffset = 0;</a>
<a name="ln1545">		int32 yOffset = -(int32)fFrontBuffer-&gt;Height();</a>
<a name="ln1546"> </a>
<a name="ln1547">		int32 count = region.CountRects();</a>
<a name="ln1548">		clipping_rect rects[count];</a>
<a name="ln1549">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1550">			rects[i] = region.RectAtInt(i);</a>
<a name="ln1551">			rects[i].top -= yOffset;</a>
<a name="ln1552">			rects[i].bottom -= yOffset;</a>
<a name="ln1553">		}</a>
<a name="ln1554"> </a>
<a name="ln1555">		_CopyRegion(rects, count, xOffset, yOffset, false);</a>
<a name="ln1556"> </a>
<a name="ln1557">		return;</a>
<a name="ln1558">	}</a>
<a name="ln1559"> </a>
<a name="ln1560">	return HWInterface::_CopyBackToFront(region);</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563"> </a>
<a name="ln1564">// #pragma mark -</a>
<a name="ln1565"> </a>
<a name="ln1566"> </a>
<a name="ln1567">void</a>
<a name="ln1568">AccelerantHWInterface::_DrawCursor(IntRect area) const</a>
<a name="ln1569">{</a>
<a name="ln1570">	if (!fHardwareCursorEnabled)</a>
<a name="ln1571">		HWInterface::_DrawCursor(area);</a>
<a name="ln1572">}</a>
<a name="ln1573"> </a>
<a name="ln1574"> </a>
<a name="ln1575">void</a>
<a name="ln1576">AccelerantHWInterface::_RegionToRectParams(/*const*/ BRegion* region,</a>
<a name="ln1577">	uint32* count) const</a>
<a name="ln1578">{</a>
<a name="ln1579">	*count = region-&gt;CountRects();</a>
<a name="ln1580">	// TODO: locking!!</a>
<a name="ln1581">	if (fRectParamsCount &lt; *count) {</a>
<a name="ln1582">		fRectParamsCount = (*count / kDefaultParamsCount + 1)</a>
<a name="ln1583">			* kDefaultParamsCount;</a>
<a name="ln1584">		// NOTE: realloc() could be used instead...</a>
<a name="ln1585">		fill_rect_params* params</a>
<a name="ln1586">			= new (nothrow) fill_rect_params[fRectParamsCount];</a>
<a name="ln1587">		if (params) {</a>
<a name="ln1588">			delete[] fRectParams;</a>
<a name="ln1589">			fRectParams = params;</a>
<a name="ln1590">		} else {</a>
<a name="ln1591">			*count = fRectParamsCount;</a>
<a name="ln1592">		}</a>
<a name="ln1593">	}</a>
<a name="ln1594"> </a>
<a name="ln1595">	int32 srcOffsetY = fOffscreenBackBuffer ? fFrontBuffer-&gt;Height() : 0;</a>
<a name="ln1596"> </a>
<a name="ln1597">	for (uint32 i = 0; i &lt; *count; i++) {</a>
<a name="ln1598">		clipping_rect r = region-&gt;RectAtInt(i);</a>
<a name="ln1599">		fRectParams[i].left = (uint16)r.left;</a>
<a name="ln1600">		fRectParams[i].top = (uint16)r.top + srcOffsetY;</a>
<a name="ln1601">		fRectParams[i].right = (uint16)r.right;</a>
<a name="ln1602">		fRectParams[i].bottom = (uint16)r.bottom + srcOffsetY;</a>
<a name="ln1603">	}</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606"> </a>
<a name="ln1607">void</a>
<a name="ln1608">AccelerantHWInterface::_CopyRegion(const clipping_rect* sortedRectList,</a>
<a name="ln1609">	uint32 count, int32 xOffset, int32 yOffset, bool inBackBuffer)</a>
<a name="ln1610">{</a>
<a name="ln1611">	if (fAccScreenBlit &amp;&amp; fAccAcquireEngine) {</a>
<a name="ln1612">		if (fAccAcquireEngine(B_2D_ACCELERATION, 0xff, &amp;fSyncToken,</a>
<a name="ln1613">				&amp;fEngineToken) &gt;= B_OK) {</a>
<a name="ln1614">			// make sure the blit_params cache is large enough</a>
<a name="ln1615">			// TODO: locking!!</a>
<a name="ln1616">			if (fBlitParamsCount &lt; count) {</a>
<a name="ln1617">				fBlitParamsCount = (count / kDefaultParamsCount + 1)</a>
<a name="ln1618">					* kDefaultParamsCount;</a>
<a name="ln1619">				// NOTE: realloc() could be used instead...</a>
<a name="ln1620">				blit_params* params</a>
<a name="ln1621">					= new (nothrow) blit_params[fBlitParamsCount];</a>
<a name="ln1622">				if (params) {</a>
<a name="ln1623">					delete[] fBlitParams;</a>
<a name="ln1624">					fBlitParams = params;</a>
<a name="ln1625">				} else {</a>
<a name="ln1626">					count = fBlitParamsCount;</a>
<a name="ln1627">				}</a>
<a name="ln1628">			}</a>
<a name="ln1629">			int32 srcOffsetY = inBackBuffer ? fFrontBuffer-&gt;Height() : 0;</a>
<a name="ln1630">			// convert the rects</a>
<a name="ln1631">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln1632">				fBlitParams[i].src_left = (uint16)sortedRectList[i].left;</a>
<a name="ln1633">				fBlitParams[i].src_top = (uint16)sortedRectList[i].top</a>
<a name="ln1634">					+ srcOffsetY;</a>
<a name="ln1635"> </a>
<a name="ln1636">				fBlitParams[i].dest_left = (uint16)sortedRectList[i].left</a>
<a name="ln1637">					+ xOffset;</a>
<a name="ln1638">				fBlitParams[i].dest_top = (uint16)sortedRectList[i].top</a>
<a name="ln1639">					+ yOffset + srcOffsetY;</a>
<a name="ln1640"> </a>
<a name="ln1641">				// NOTE: width and height are expressed as distance, not</a>
<a name="ln1642">				// pixel count!</a>
<a name="ln1643">				fBlitParams[i].width = (uint16)(sortedRectList[i].right</a>
<a name="ln1644">					- sortedRectList[i].left);</a>
<a name="ln1645">				fBlitParams[i].height = (uint16)(sortedRectList[i].bottom</a>
<a name="ln1646">					- sortedRectList[i].top);</a>
<a name="ln1647">			}</a>
<a name="ln1648"> </a>
<a name="ln1649">			// go</a>
<a name="ln1650">			fAccScreenBlit(fEngineToken, fBlitParams, count);</a>
<a name="ln1651"> </a>
<a name="ln1652">			// done</a>
<a name="ln1653">			if (fAccReleaseEngine)</a>
<a name="ln1654">				fAccReleaseEngine(fEngineToken, &amp;fSyncToken);</a>
<a name="ln1655"> </a>
<a name="ln1656">			// sync</a>
<a name="ln1657">			if (fAccSyncToToken)</a>
<a name="ln1658">				fAccSyncToToken(&amp;fSyncToken);</a>
<a name="ln1659">		}</a>
<a name="ln1660">	}</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663"> </a>
<a name="ln1664">uint32</a>
<a name="ln1665">AccelerantHWInterface::_NativeColor(const rgb_color&amp; color) const</a>
<a name="ln1666">{</a>
<a name="ln1667">	// NOTE: This functions looks somehow suspicios to me.</a>
<a name="ln1668">	// It assumes that all graphics cards have the same native endianess, no?</a>
<a name="ln1669">	switch (fDisplayMode.space) {</a>
<a name="ln1670">		case B_CMAP8:</a>
<a name="ln1671">		case B_GRAY8:</a>
<a name="ln1672">			return RGBColor(color).GetColor8();</a>
<a name="ln1673"> </a>
<a name="ln1674">		case B_RGB15_BIG:</a>
<a name="ln1675">		case B_RGBA15_BIG:</a>
<a name="ln1676">		case B_RGB15_LITTLE:</a>
<a name="ln1677">		case B_RGBA15_LITTLE:</a>
<a name="ln1678">			return RGBColor(color).GetColor15();</a>
<a name="ln1679"> </a>
<a name="ln1680">		case B_RGB16_BIG:</a>
<a name="ln1681">		case B_RGB16_LITTLE:</a>
<a name="ln1682">			return RGBColor(color).GetColor16();</a>
<a name="ln1683"> </a>
<a name="ln1684">		case B_RGB32_BIG:</a>
<a name="ln1685">		case B_RGBA32_BIG:</a>
<a name="ln1686">		case B_RGB32_LITTLE:</a>
<a name="ln1687">		case B_RGBA32_LITTLE: {</a>
<a name="ln1688">			return (uint32)((color.alpha &lt;&lt; 24) | (color.red &lt;&lt; 16)</a>
<a name="ln1689">				| (color.green &lt;&lt; 8) | color.blue);</a>
<a name="ln1690">		}</a>
<a name="ln1691">	}</a>
<a name="ln1692">	return 0;</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695"> </a>
<a name="ln1696">void</a>
<a name="ln1697">AccelerantHWInterface::_SetSystemPalette()</a>
<a name="ln1698">{</a>
<a name="ln1699">	set_indexed_colors setIndexedColors = (set_indexed_colors)fAccelerantHook(</a>
<a name="ln1700">		B_SET_INDEXED_COLORS, NULL);</a>
<a name="ln1701">	if (setIndexedColors == NULL)</a>
<a name="ln1702">		return;</a>
<a name="ln1703"> </a>
<a name="ln1704">	const rgb_color* palette = SystemPalette();</a>
<a name="ln1705">	uint8 colors[3 * 256];</a>
<a name="ln1706">		// the color table is an array with 3 bytes per color</a>
<a name="ln1707">	uint32 j = 0;</a>
<a name="ln1708"> </a>
<a name="ln1709">	for (int32 i = 0; i &lt; 256; i++) {</a>
<a name="ln1710">		colors[j++] = palette[i].red;</a>
<a name="ln1711">		colors[j++] = palette[i].green;</a>
<a name="ln1712">		colors[j++] = palette[i].blue;</a>
<a name="ln1713">	}</a>
<a name="ln1714"> </a>
<a name="ln1715">	setIndexedColors(256, 0, colors, 0);</a>
<a name="ln1716">}</a>
<a name="ln1717"> </a>
<a name="ln1718"> </a>
<a name="ln1719">void</a>
<a name="ln1720">AccelerantHWInterface::_SetGrayscalePalette()</a>
<a name="ln1721">{</a>
<a name="ln1722">	set_indexed_colors setIndexedColors = (set_indexed_colors)fAccelerantHook(</a>
<a name="ln1723">		B_SET_INDEXED_COLORS, NULL);</a>
<a name="ln1724">	if (setIndexedColors == NULL)</a>
<a name="ln1725">		return;</a>
<a name="ln1726"> </a>
<a name="ln1727">	uint8 colors[3 * 256];</a>
<a name="ln1728">		// the color table is an array with 3 bytes per color</a>
<a name="ln1729">	uint32 j = 0;</a>
<a name="ln1730"> </a>
<a name="ln1731">	if (fFrontBuffer-&gt;Width() &gt; fFrontBuffer-&gt;BytesPerRow()) {</a>
<a name="ln1732">		// VGA 16 color grayscale planar mode</a>
<a name="ln1733">		for (int32 i = 0; i &lt; 256; i++) {</a>
<a name="ln1734">			colors[j++] = (i &amp; 0xf) * 17;</a>
<a name="ln1735">			colors[j++] = (i &amp; 0xf) * 17;</a>
<a name="ln1736">			colors[j++] = (i &amp; 0xf) * 17;</a>
<a name="ln1737">		}</a>
<a name="ln1738"> </a>
<a name="ln1739">		setIndexedColors(256, 0, colors, 0);</a>
<a name="ln1740">	} else {</a>
<a name="ln1741">		for (int32 i = 0; i &lt; 256; i++) {</a>
<a name="ln1742">			colors[j++] = i;</a>
<a name="ln1743">			colors[j++] = i;</a>
<a name="ln1744">			colors[j++] = i;</a>
<a name="ln1745">		}</a>
<a name="ln1746"> </a>
<a name="ln1747">		setIndexedColors(256, 0, colors, 0);</a>
<a name="ln1748">	}</a>
<a name="ln1749">}</a>

</code></pre>
<div class="balloon" rel="100"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fAccGetPreferredDisplayMode, fAccGetMonitorInfo, fAccGetEDIDInfo, fFrameBufferConfig.</p></div>
<div class="balloon" rel="263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The 'device' pointer was assigned values twice without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
