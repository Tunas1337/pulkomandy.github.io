
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>VectorPath.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2012, Haiku.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan AÃŸmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;VectorPath.h&quot;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;agg_basics.h&gt;</a>
<a name="ln16">#include &lt;agg_bounding_rect.h&gt;</a>
<a name="ln17">#include &lt;agg_conv_curve.h&gt;</a>
<a name="ln18">#include &lt;agg_curves.h&gt;</a>
<a name="ln19">#include &lt;agg_math.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#ifdef ICON_O_MATIC</a>
<a name="ln22">#	include &lt;debugger.h&gt;</a>
<a name="ln23">#	include &lt;typeinfo&gt;</a>
<a name="ln24">#endif // ICON_O_MATIC</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;Message.h&gt;</a>
<a name="ln27">#include &lt;TypeConstants.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#ifdef ICON_O_MATIC</a>
<a name="ln30">#	include &quot;support.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#	include &quot;CommonPropertyIDs.h&quot;</a>
<a name="ln33">#	include &quot;IconProperty.h&quot;</a>
<a name="ln34">#	include &quot;Icons.h&quot;</a>
<a name="ln35">#	include &quot;Property.h&quot;</a>
<a name="ln36">#	include &quot;PropertyObject.h&quot;</a>
<a name="ln37">#endif // ICON_O_MATIC</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;Transformable.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">#define obj_new(type, n)		((type *)malloc ((n) * sizeof(type)))</a>
<a name="ln43">#define obj_renew(p, type, n)	((type *)realloc ((void *)p, (n) * sizeof(type)))</a>
<a name="ln44">#define obj_free				free</a>
<a name="ln45"> </a>
<a name="ln46">#define ALLOC_CHUNKS 20</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">bool</a>
<a name="ln50">get_path_storage(agg::path_storage&amp; path, const control_point* points,</a>
<a name="ln51">	int32 count, bool closed)</a>
<a name="ln52">{</a>
<a name="ln53">	if (count &gt; 1) {</a>
<a name="ln54">		path.move_to(points[0].point.x, points[0].point.y);</a>
<a name="ln55"> </a>
<a name="ln56">		for (int32 i = 1; i &lt; count; i++) {</a>
<a name="ln57">			path.curve4(points[i - 1].point_out.x, points[i - 1].point_out.y,</a>
<a name="ln58">				points[i].point_in.x, points[i].point_in.y,</a>
<a name="ln59">				points[i].point.x, points[i].point.y);</a>
<a name="ln60">		}</a>
<a name="ln61">		if (closed) {</a>
<a name="ln62">			// curve from last to first control point</a>
<a name="ln63">			path.curve4(</a>
<a name="ln64">				points[count - 1].point_out.x, points[count - 1].point_out.y,</a>
<a name="ln65">				points[0].point_in.x, points[0].point_in.y,</a>
<a name="ln66">				points[0].point.x, points[0].point.y);</a>
<a name="ln67">			path.close_polygon();</a>
<a name="ln68">		}</a>
<a name="ln69"> </a>
<a name="ln70">		return true;</a>
<a name="ln71">	}</a>
<a name="ln72">	return false;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">// #pragma mark -</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">#ifdef ICON_O_MATIC</a>
<a name="ln80">PathListener::PathListener()</a>
<a name="ln81">{</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84"> </a>
<a name="ln85">PathListener::~PathListener()</a>
<a name="ln86">{</a>
<a name="ln87">}</a>
<a name="ln88">#endif</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">// #pragma mark -</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">VectorPath::VectorPath()</a>
<a name="ln95">	:</a>
<a name="ln96">#ifdef ICON_O_MATIC</a>
<a name="ln97">	BArchivable(),</a>
<a name="ln98">	IconObject(&quot;&lt;path&gt;&quot;),</a>
<a name="ln99">	fListeners(20),</a>
<a name="ln100">#endif</a>
<a name="ln101">	fPath(NULL),</a>
<a name="ln102">	fClosed(false),</a>
<a name="ln103">	fPointCount(0),</a>
<a name="ln104">	fAllocCount(0),</a>
<a name="ln105">	fCachedBounds(0.0, 0.0, -1.0, -1.0)</a>
<a name="ln106">{</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">VectorPath::VectorPath(const VectorPath&amp; from)</a>
<a name="ln111">	:</a>
<a name="ln112">#ifdef ICON_O_MATIC</a>
<a name="ln113">	BArchivable(),</a>
<a name="ln114">	IconObject(from),</a>
<a name="ln115">	fListeners(20),</a>
<a name="ln116">#endif</a>
<a name="ln117">	fPath(NULL),</a>
<a name="ln118">	fClosed(false),</a>
<a name="ln119">	fPointCount(0),</a>
<a name="ln120">	fAllocCount(0),</a>
<a name="ln121">	fCachedBounds(0.0, 0.0, -1.0, -1.0)</a>
<a name="ln122">{</a>
<a name="ln123">	*this = from;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">VectorPath::VectorPath(BMessage* archive)</a>
<a name="ln128">	:</a>
<a name="ln129">#ifdef ICON_O_MATIC</a>
<a name="ln130">	BArchivable(),</a>
<a name="ln131">	IconObject(archive),</a>
<a name="ln132">	fListeners(20),</a>
<a name="ln133">#endif</a>
<a name="ln134">	fPath(NULL),</a>
<a name="ln135">	fClosed(false),</a>
<a name="ln136">	fPointCount(0),</a>
<a name="ln137">	fAllocCount(0),</a>
<a name="ln138">	fCachedBounds(0.0, 0.0, -1.0, -1.0)</a>
<a name="ln139">{</a>
<a name="ln140">	if (!archive)</a>
<a name="ln141">		return;</a>
<a name="ln142"> </a>
<a name="ln143">	type_code typeFound;</a>
<a name="ln144">	int32 countFound;</a>
<a name="ln145">	if (archive-&gt;GetInfo(&quot;point&quot;, &amp;typeFound, &amp;countFound) &gt;= B_OK</a>
<a name="ln146">		&amp;&amp; typeFound == B_POINT_TYPE</a>
<a name="ln147">		&amp;&amp; _SetPointCount(countFound)) {</a>
<a name="ln148">		memset((void*)fPath, 0, fAllocCount * sizeof(control_point));</a>
<a name="ln149"> </a>
<a name="ln150">		BPoint point;</a>
<a name="ln151">		BPoint pointIn;</a>
<a name="ln152">		BPoint pointOut;</a>
<a name="ln153">		bool connected;</a>
<a name="ln154">		for (int32 i = 0; i &lt; fPointCount</a>
<a name="ln155">				&amp;&amp; archive-&gt;FindPoint(&quot;point&quot;, i, &amp;point) &gt;= B_OK</a>
<a name="ln156">				&amp;&amp; archive-&gt;FindPoint(&quot;point in&quot;, i, &amp;pointIn) &gt;= B_OK</a>
<a name="ln157">				&amp;&amp; archive-&gt;FindPoint(&quot;point out&quot;, i, &amp;pointOut) &gt;= B_OK</a>
<a name="ln158">				&amp;&amp; archive-&gt;FindBool(&quot;connected&quot;, i, &amp;connected) &gt;= B_OK; i++) {</a>
<a name="ln159">			fPath[i].point = point;</a>
<a name="ln160">			fPath[i].point_in = pointIn;</a>
<a name="ln161">			fPath[i].point_out = pointOut;</a>
<a name="ln162">			fPath[i].connected = connected;</a>
<a name="ln163">		}</a>
<a name="ln164">	}</a>
<a name="ln165">	if (archive-&gt;FindBool(&quot;path closed&quot;, &amp;fClosed) &lt; B_OK)</a>
<a name="ln166">		fClosed = false;</a>
<a name="ln167"> </a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">VectorPath::~VectorPath()</a>
<a name="ln172">{</a>
<a name="ln173">	if (fPath)</a>
<a name="ln174">		obj_free(fPath);</a>
<a name="ln175"> </a>
<a name="ln176">#ifdef ICON_O_MATIC</a>
<a name="ln177">	if (fListeners.CountItems() &gt; 0) {</a>
<a name="ln178">		PathListener* listener = (PathListener*)fListeners.ItemAt(0);</a>
<a name="ln179">		char message[512];</a>
<a name="ln180">		sprintf(message, &quot;VectorPath::~VectorPath() - &quot;</a>
<a name="ln181">				 &quot;there are still listeners attached! %p/%s&quot;,</a>
<a name="ln182">				 listener, typeid(*listener).name());</a>
<a name="ln183">		debugger(message);</a>
<a name="ln184">	}</a>
<a name="ln185">#endif</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">// #pragma mark -</a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192">#ifdef ICON_O_MATIC</a>
<a name="ln193"> </a>
<a name="ln194">PropertyObject*</a>
<a name="ln195">VectorPath::MakePropertyObject() const</a>
<a name="ln196">{</a>
<a name="ln197">	PropertyObject* object = IconObject::MakePropertyObject();</a>
<a name="ln198">	if (!object)</a>
<a name="ln199">		return NULL;</a>
<a name="ln200"> </a>
<a name="ln201">	// closed</a>
<a name="ln202">	object-&gt;AddProperty(new BoolProperty(PROPERTY_CLOSED, fClosed));</a>
<a name="ln203"> </a>
<a name="ln204">	// archived path</a>
<a name="ln205">	BMessage* archive = new BMessage();</a>
<a name="ln206">	if (Archive(archive) == B_OK) {</a>
<a name="ln207">		object-&gt;AddProperty(new IconProperty(PROPERTY_PATH,</a>
<a name="ln208">			kPathPropertyIconBits, kPathPropertyIconWidth,</a>
<a name="ln209">			kPathPropertyIconHeight, kPathPropertyIconFormat, archive));</a>
<a name="ln210">	}</a>
<a name="ln211"> </a>
<a name="ln212">	return object;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215"> </a>
<a name="ln216">bool</a>
<a name="ln217">VectorPath::SetToPropertyObject(const PropertyObject* object)</a>
<a name="ln218">{</a>
<a name="ln219">	AutoNotificationSuspender _(this);</a>
<a name="ln220">	IconObject::SetToPropertyObject(object);</a>
<a name="ln221"> </a>
<a name="ln222">	SetClosed(object-&gt;Value(PROPERTY_CLOSED, fClosed));</a>
<a name="ln223"> </a>
<a name="ln224">	IconProperty* pathProperty = dynamic_cast&lt;IconProperty*&gt;(</a>
<a name="ln225">		object-&gt;FindProperty(PROPERTY_PATH));</a>
<a name="ln226">	if (pathProperty &amp;&amp; pathProperty-&gt;Message()) {</a>
<a name="ln227">		VectorPath archivedPath(pathProperty-&gt;Message());</a>
<a name="ln228">		*this = archivedPath;</a>
<a name="ln229">	}</a>
<a name="ln230"> </a>
<a name="ln231">	return HasPendingNotifications();</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234"> </a>
<a name="ln235">status_t</a>
<a name="ln236">VectorPath::Archive(BMessage* into, bool deep) const</a>
<a name="ln237">{</a>
<a name="ln238">	status_t ret = IconObject::Archive(into, deep);</a>
<a name="ln239">	if (ret != B_OK)</a>
<a name="ln240">		return ret;</a>
<a name="ln241"> </a>
<a name="ln242">	if (fPointCount &gt; 0) {</a>
<a name="ln243">		// improve BMessage efficency by preallocating storage for all points</a>
<a name="ln244">		// with the first call</a>
<a name="ln245">		ret = into-&gt;AddData(&quot;point&quot;, B_POINT_TYPE, &amp;fPath[0].point,</a>
<a name="ln246">			sizeof(BPoint), true, fPointCount);</a>
<a name="ln247">		if (ret &gt;= B_OK) {</a>
<a name="ln248">			ret = into-&gt;AddData(&quot;point in&quot;, B_POINT_TYPE, &amp;fPath[0].point_in,</a>
<a name="ln249">				sizeof(BPoint), true, fPointCount);</a>
<a name="ln250">		}</a>
<a name="ln251">		if (ret &gt;= B_OK) {</a>
<a name="ln252">			ret = into-&gt;AddData(&quot;point out&quot;, B_POINT_TYPE, &amp;fPath[0].point_out,</a>
<a name="ln253">				sizeof(BPoint), true, fPointCount);</a>
<a name="ln254">		}</a>
<a name="ln255">		if (ret &gt;= B_OK) {</a>
<a name="ln256">			ret = into-&gt;AddData(&quot;connected&quot;, B_BOOL_TYPE, &amp;fPath[0].connected,</a>
<a name="ln257">				sizeof(bool), true, fPointCount);</a>
<a name="ln258">		}</a>
<a name="ln259"> </a>
<a name="ln260">		// add the rest of the points</a>
<a name="ln261">		for (int32 i = 1; i &lt; fPointCount &amp;&amp; ret &gt;= B_OK; i++) {</a>
<a name="ln262">			ret = into-&gt;AddData(&quot;point&quot;, B_POINT_TYPE, &amp;fPath[i].point,</a>
<a name="ln263">				sizeof(BPoint));</a>
<a name="ln264">			if (ret &gt;= B_OK) {</a>
<a name="ln265">				ret = into-&gt;AddData(&quot;point in&quot;, B_POINT_TYPE, &amp;fPath[i].point_in,</a>
<a name="ln266">					sizeof(BPoint));</a>
<a name="ln267">			}</a>
<a name="ln268">			if (ret &gt;= B_OK) {</a>
<a name="ln269">				ret = into-&gt;AddData(&quot;point out&quot;, B_POINT_TYPE,</a>
<a name="ln270">					&amp;fPath[i].point_out, sizeof(BPoint));</a>
<a name="ln271">			}</a>
<a name="ln272">			if (ret &gt;= B_OK) {</a>
<a name="ln273">				ret = into-&gt;AddData(&quot;connected&quot;, B_BOOL_TYPE,</a>
<a name="ln274">					&amp;fPath[i].connected, sizeof(bool));</a>
<a name="ln275">			}</a>
<a name="ln276">		}</a>
<a name="ln277">	}</a>
<a name="ln278"> </a>
<a name="ln279">	if (ret &gt;= B_OK)</a>
<a name="ln280">		ret = into-&gt;AddBool(&quot;path closed&quot;, fClosed);</a>
<a name="ln281">	else</a>
<a name="ln282">		fprintf(stderr, &quot;failed adding points!\n&quot;);</a>
<a name="ln283"> </a>
<a name="ln284">	if (ret &lt; B_OK)</a>
<a name="ln285">		fprintf(stderr, &quot;failed adding close!\n&quot;);</a>
<a name="ln286"> </a>
<a name="ln287">	// finish off</a>
<a name="ln288">	if (ret &lt; B_OK)</a>
<a name="ln289">		ret = into-&gt;AddString(&quot;class&quot;, &quot;VectorPath&quot;);</a>
<a name="ln290"> </a>
<a name="ln291">	return ret;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">#endif // ICON_O_MATIC</a>
<a name="ln295"> </a>
<a name="ln296"> </a>
<a name="ln297">// #pragma mark -</a>
<a name="ln298"> </a>
<a name="ln299"> </a>
<a name="ln300">VectorPath&amp;</a>
<a name="ln301">VectorPath::operator=(const VectorPath&amp; from)</a>
<a name="ln302">{</a>
<a name="ln303">	_SetPointCount(from.fPointCount);</a>
<a name="ln304">	fClosed = from.fClosed;</a>
<a name="ln305">	if (fPath) {</a>
<a name="ln306">		memcpy((void*)fPath, from.fPath, fPointCount * sizeof(control_point));</a>
<a name="ln307">		fCachedBounds = from.fCachedBounds;</a>
<a name="ln308">	} else {</a>
<a name="ln309">		fprintf(stderr, &quot;VectorPath() -&gt; allocation failed in operator=!\n&quot;);</a>
<a name="ln310">		fAllocCount = 0;</a>
<a name="ln311">		fPointCount = 0;</a>
<a name="ln312">		fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln313">	}</a>
<a name="ln314">	Notify();</a>
<a name="ln315"> </a>
<a name="ln316">	return *this;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">bool</a>
<a name="ln321">VectorPath::operator==(const VectorPath&amp; other) const</a>
<a name="ln322">{</a>
<a name="ln323">	if (fClosed != other.fClosed)</a>
<a name="ln324">		return false;</a>
<a name="ln325"> </a>
<a name="ln326">	if (fPointCount != other.fPointCount)</a>
<a name="ln327">		return false;</a>
<a name="ln328"> </a>
<a name="ln329">	if (fPath == NULL &amp;&amp; other.fPath == NULL)</a>
<a name="ln330">		return true;</a>
<a name="ln331"> </a>
<a name="ln332">	if (fPath == NULL || other.fPath == NULL)</a>
<a name="ln333">		return false;</a>
<a name="ln334"> </a>
<a name="ln335">	for (int32 i = 0; i &lt; fPointCount; i++) {</a>
<a name="ln336">		if (fPath[i].point != other.fPath[i].point</a>
<a name="ln337">			|| fPath[i].point_in != other.fPath[i].point_in</a>
<a name="ln338">			|| fPath[i].point_out != other.fPath[i].point_out</a>
<a name="ln339">			|| fPath[i].connected != other.fPath[i].connected) {</a>
<a name="ln340">			return false;</a>
<a name="ln341">		}</a>
<a name="ln342">	}</a>
<a name="ln343"> </a>
<a name="ln344">	return true;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347"> </a>
<a name="ln348">void</a>
<a name="ln349">VectorPath::MakeEmpty()</a>
<a name="ln350">{</a>
<a name="ln351">	_SetPointCount(0);</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354"> </a>
<a name="ln355">// #pragma mark -</a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358">bool</a>
<a name="ln359">VectorPath::AddPoint(BPoint point)</a>
<a name="ln360">{</a>
<a name="ln361">	int32 index = fPointCount;</a>
<a name="ln362"> </a>
<a name="ln363">	if (_SetPointCount(fPointCount + 1)) {</a>
<a name="ln364">		_SetPoint(index, point);</a>
<a name="ln365">		_NotifyPointAdded(index);</a>
<a name="ln366">		return true;</a>
<a name="ln367">	}</a>
<a name="ln368"> </a>
<a name="ln369">	return false;</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372"> </a>
<a name="ln373">bool</a>
<a name="ln374">VectorPath::AddPoint(const BPoint&amp; point, const BPoint&amp; pointIn,</a>
<a name="ln375">	const BPoint&amp; pointOut, bool connected)</a>
<a name="ln376">{</a>
<a name="ln377">	int32 index = fPointCount;</a>
<a name="ln378"> </a>
<a name="ln379">	if (_SetPointCount(fPointCount + 1)) {</a>
<a name="ln380">		_SetPoint(index, point, pointIn, pointOut, connected);</a>
<a name="ln381">		_NotifyPointAdded(index);</a>
<a name="ln382">		return true;</a>
<a name="ln383">	}</a>
<a name="ln384"> </a>
<a name="ln385">	return false;</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388"> </a>
<a name="ln389">bool</a>
<a name="ln390">VectorPath::AddPoint(BPoint point, int32 index)</a>
<a name="ln391">{</a>
<a name="ln392">	if (index &lt; 0)</a>
<a name="ln393">		index = 0;</a>
<a name="ln394">	if (index &gt; fPointCount)</a>
<a name="ln395">		index = fPointCount;</a>
<a name="ln396"> </a>
<a name="ln397">	if (_SetPointCount(fPointCount + 1)) {</a>
<a name="ln398">		// handle insert</a>
<a name="ln399">		if (index &lt; fPointCount - 1) {</a>
<a name="ln400">			for (int32 i = fPointCount; i &gt; index; i--) {</a>
<a name="ln401">				fPath[i].point = fPath[i - 1].point;</a>
<a name="ln402">				fPath[i].point_in = fPath[i - 1].point_in;</a>
<a name="ln403">				fPath[i].point_out = fPath[i - 1].point_out;</a>
<a name="ln404">				fPath[i].connected = fPath[i - 1].connected;</a>
<a name="ln405">			}</a>
<a name="ln406">		}</a>
<a name="ln407">		_SetPoint(index, point);</a>
<a name="ln408">		_NotifyPointAdded(index);</a>
<a name="ln409">		return true;</a>
<a name="ln410">	}</a>
<a name="ln411">	return false;</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">bool</a>
<a name="ln416">VectorPath::RemovePoint(int32 index)</a>
<a name="ln417">{</a>
<a name="ln418">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln419">		if (index &lt; fPointCount - 1) {</a>
<a name="ln420">			// move points</a>
<a name="ln421">			for (int32 i = index; i &lt; fPointCount - 1; i++) {</a>
<a name="ln422">				fPath[i].point = fPath[i + 1].point;</a>
<a name="ln423">				fPath[i].point_in = fPath[i + 1].point_in;</a>
<a name="ln424">				fPath[i].point_out = fPath[i + 1].point_out;</a>
<a name="ln425">				fPath[i].connected = fPath[i + 1].connected;</a>
<a name="ln426">			}</a>
<a name="ln427">		}</a>
<a name="ln428">		fPointCount -= 1;</a>
<a name="ln429"> </a>
<a name="ln430">		fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln431"> </a>
<a name="ln432">		_NotifyPointRemoved(index);</a>
<a name="ln433">		return true;</a>
<a name="ln434">	}</a>
<a name="ln435">	return false;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438"> </a>
<a name="ln439">bool</a>
<a name="ln440">VectorPath::SetPoint(int32 index, BPoint point)</a>
<a name="ln441">{</a>
<a name="ln442">	if (index == fPointCount)</a>
<a name="ln443">		index = 0;</a>
<a name="ln444">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln445">		BPoint offset = point - fPath[index].point;</a>
<a name="ln446">		fPath[index].point = point;</a>
<a name="ln447">		fPath[index].point_in += offset;</a>
<a name="ln448">		fPath[index].point_out += offset;</a>
<a name="ln449"> </a>
<a name="ln450">		fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln451"> </a>
<a name="ln452">		_NotifyPointChanged(index);</a>
<a name="ln453">		return true;</a>
<a name="ln454">	}</a>
<a name="ln455">	return false;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459">bool</a>
<a name="ln460">VectorPath::SetPoint(int32 index, BPoint point, BPoint pointIn, BPoint pointOut,</a>
<a name="ln461">	bool connected)</a>
<a name="ln462">{</a>
<a name="ln463">	if (index == fPointCount)</a>
<a name="ln464">		index = 0;</a>
<a name="ln465">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln466">		fPath[index].point = point;</a>
<a name="ln467">		fPath[index].point_in = pointIn;</a>
<a name="ln468">		fPath[index].point_out = pointOut;</a>
<a name="ln469">		fPath[index].connected = connected;</a>
<a name="ln470"> </a>
<a name="ln471">		fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln472"> </a>
<a name="ln473">		_NotifyPointChanged(index);</a>
<a name="ln474">		return true;</a>
<a name="ln475">	}</a>
<a name="ln476">	return false;</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479"> </a>
<a name="ln480">bool</a>
<a name="ln481">VectorPath::SetPointIn(int32 i, BPoint point)</a>
<a name="ln482">{</a>
<a name="ln483">	if (i == fPointCount)</a>
<a name="ln484">		i = 0;</a>
<a name="ln485">	if (i &gt;= 0 &amp;&amp; i &lt; fPointCount) {</a>
<a name="ln486">		// first, set the &quot;in&quot; point</a>
<a name="ln487">		fPath[i].point_in = point;</a>
<a name="ln488">		// now see what to do about the &quot;out&quot; point</a>
<a name="ln489">		if (fPath[i].connected) {</a>
<a name="ln490">			// keep all three points in one line</a>
<a name="ln491">			BPoint v = fPath[i].point - fPath[i].point_in;</a>
<a name="ln492">			float distIn = sqrtf(v.x * v.x + v.y * v.y);</a>
<a name="ln493">			if (distIn &gt; 0.0) {</a>
<a name="ln494">				float distOut = agg::calc_distance(</a>
<a name="ln495">					fPath[i].point.x, fPath[i].point.y,</a>
<a name="ln496">					fPath[i].point_out.x, fPath[i].point_out.y);</a>
<a name="ln497">				float scale = (distIn + distOut) / distIn;</a>
<a name="ln498">				v.x *= scale;</a>
<a name="ln499">				v.y *= scale;</a>
<a name="ln500">				fPath[i].point_out = fPath[i].point_in + v;</a>
<a name="ln501">			}</a>
<a name="ln502">		}</a>
<a name="ln503"> </a>
<a name="ln504">		fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln505"> </a>
<a name="ln506">		_NotifyPointChanged(i);</a>
<a name="ln507">		return true;</a>
<a name="ln508">	}</a>
<a name="ln509">	return false;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512"> </a>
<a name="ln513">bool</a>
<a name="ln514">VectorPath::SetPointOut(int32 i, BPoint point, bool mirrorDist)</a>
<a name="ln515">{</a>
<a name="ln516">	if (i == fPointCount)</a>
<a name="ln517">		i = 0;</a>
<a name="ln518">	if (i &gt;= 0 &amp;&amp; i &lt; fPointCount) {</a>
<a name="ln519">		// first, set the &quot;out&quot; point</a>
<a name="ln520">		fPath[i].point_out = point;</a>
<a name="ln521">		// now see what to do about the &quot;out&quot; point</a>
<a name="ln522">		if (mirrorDist) {</a>
<a name="ln523">			// mirror &quot;in&quot; point around main control point</a>
<a name="ln524">			BPoint v = fPath[i].point - fPath[i].point_out;</a>
<a name="ln525">			fPath[i].point_in = fPath[i].point + v;</a>
<a name="ln526">		} else if (fPath[i].connected) {</a>
<a name="ln527">			// keep all three points in one line</a>
<a name="ln528">			BPoint v = fPath[i].point - fPath[i].point_out;</a>
<a name="ln529">			float distOut = sqrtf(v.x * v.x + v.y * v.y);</a>
<a name="ln530">			if (distOut &gt; 0.0) {</a>
<a name="ln531">				float distIn = agg::calc_distance(</a>
<a name="ln532">					fPath[i].point.x, fPath[i].point.y,</a>
<a name="ln533">					fPath[i].point_in.x, fPath[i].point_in.y);</a>
<a name="ln534">				float scale = (distIn + distOut) / distOut;</a>
<a name="ln535">				v.x *= scale;</a>
<a name="ln536">				v.y *= scale;</a>
<a name="ln537">				fPath[i].point_in = fPath[i].point_out + v;</a>
<a name="ln538">			}</a>
<a name="ln539">		}</a>
<a name="ln540"> </a>
<a name="ln541">		fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln542"> </a>
<a name="ln543">		_NotifyPointChanged(i);</a>
<a name="ln544">		return true;</a>
<a name="ln545">	}</a>
<a name="ln546">	return false;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">bool</a>
<a name="ln551">VectorPath::SetInOutConnected(int32 index, bool connected)</a>
<a name="ln552">{</a>
<a name="ln553">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln554">		fPath[index].connected = connected;</a>
<a name="ln555">		_NotifyPointChanged(index);</a>
<a name="ln556">		return true;</a>
<a name="ln557">	}</a>
<a name="ln558">	return false;</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561"> </a>
<a name="ln562">// #pragma mark -</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">bool</a>
<a name="ln566">VectorPath::GetPointAt(int32 index, BPoint&amp; point) const</a>
<a name="ln567">{</a>
<a name="ln568">	if (index == fPointCount)</a>
<a name="ln569">		index = 0;</a>
<a name="ln570">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln571">		point = fPath[index].point;</a>
<a name="ln572">		return true;</a>
<a name="ln573">	}</a>
<a name="ln574">	return false;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577"> </a>
<a name="ln578">bool</a>
<a name="ln579">VectorPath::GetPointInAt(int32 index, BPoint&amp; point) const</a>
<a name="ln580">{</a>
<a name="ln581">	if (index == fPointCount)</a>
<a name="ln582">		index = 0;</a>
<a name="ln583">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln584">		point = fPath[index].point_in;</a>
<a name="ln585">		return true;</a>
<a name="ln586">	}</a>
<a name="ln587">	return false;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590"> </a>
<a name="ln591">bool</a>
<a name="ln592">VectorPath::GetPointOutAt(int32 index, BPoint&amp; point) const</a>
<a name="ln593">{</a>
<a name="ln594">	if (index == fPointCount)</a>
<a name="ln595">		index = 0;</a>
<a name="ln596">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln597">		point = fPath[index].point_out;</a>
<a name="ln598">		return true;</a>
<a name="ln599">	}</a>
<a name="ln600">	return false;</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603"> </a>
<a name="ln604">bool</a>
<a name="ln605">VectorPath::GetPointsAt(int32 index, BPoint&amp; point, BPoint&amp; pointIn,</a>
<a name="ln606">	BPoint&amp; pointOut, bool* connected) const</a>
<a name="ln607">{</a>
<a name="ln608">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln609">		point = fPath[index].point;</a>
<a name="ln610">		pointIn = fPath[index].point_in;</a>
<a name="ln611">		pointOut = fPath[index].point_out;</a>
<a name="ln612"> </a>
<a name="ln613">		if (connected)</a>
<a name="ln614">			*connected = fPath[index].connected;</a>
<a name="ln615"> </a>
<a name="ln616">		return true;</a>
<a name="ln617">	}</a>
<a name="ln618">	return false;</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621"> </a>
<a name="ln622">int32</a>
<a name="ln623">VectorPath::CountPoints() const</a>
<a name="ln624">{</a>
<a name="ln625">	return fPointCount;</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628"> </a>
<a name="ln629">// #pragma mark -</a>
<a name="ln630"> </a>
<a name="ln631"> </a>
<a name="ln632">#ifdef ICON_O_MATIC</a>
<a name="ln633"> </a>
<a name="ln634">static float</a>
<a name="ln635">distance_to_curve(const BPoint&amp; p, const BPoint&amp; a, const BPoint&amp; aOut,</a>
<a name="ln636">	const BPoint&amp; bIn, const BPoint&amp; b)</a>
<a name="ln637">{</a>
<a name="ln638">	agg::curve4_inc curve(a.x, a.y, aOut.x, aOut.y, bIn.x, bIn.y, b.x, b.y);</a>
<a name="ln639"> </a>
<a name="ln640">	float segDist = FLT_MAX;</a>
<a name="ln641">	double x1, y1, x2, y2;</a>
<a name="ln642">	unsigned cmd = curve.vertex(&amp;x1, &amp;y1);</a>
<a name="ln643">	while (!agg::is_stop(cmd)) {</a>
<a name="ln644">		cmd = curve.vertex(&amp;x2, &amp;y2);</a>
<a name="ln645">		// first figure out if point is between segment start and end points</a>
<a name="ln646">		double a = agg::calc_distance(p.x, p.y, x2, y2);</a>
<a name="ln647">		double b = agg::calc_distance(p.x, p.y, x1, y1);</a>
<a name="ln648"> </a>
<a name="ln649">		float currentDist = min_c(a, b);</a>
<a name="ln650"> </a>
<a name="ln651">		if (a &gt; 0.0 &amp;&amp; b &gt; 0.0) {</a>
<a name="ln652">			double c = agg::calc_distance(x1, y1, x2, y2);</a>
<a name="ln653"> </a>
<a name="ln654">			double alpha = acos((b * b + c * c - a * a) / (2 * b * c));</a>
<a name="ln655">			double beta = acos((a * a + c * c - b * b) / (2 * a * c));</a>
<a name="ln656"> </a>
<a name="ln657">			if (alpha &lt;= M_PI_2 &amp;&amp; beta &lt;= M_PI_2) {</a>
<a name="ln658">				currentDist = fabs(agg::calc_line_point_distance(x1, y1, x2, y2,</a>
<a name="ln659">					p.x, p.y));</a>
<a name="ln660">			}</a>
<a name="ln661">		}</a>
<a name="ln662"> </a>
<a name="ln663">		if (currentDist &lt; segDist)</a>
<a name="ln664">			segDist = currentDist;</a>
<a name="ln665"> </a>
<a name="ln666">		x1 = x2;</a>
<a name="ln667">		y1 = y2;</a>
<a name="ln668">	}</a>
<a name="ln669">	return segDist;</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672"> </a>
<a name="ln673">bool</a>
<a name="ln674">VectorPath::GetDistance(BPoint p, float* distance, int32* index) const</a>
<a name="ln675">{</a>
<a name="ln676">	if (fPointCount &gt; 1) {</a>
<a name="ln677">		// generate a curve for each segment of the path</a>
<a name="ln678">		// then	iterate over the segments of the curve measuring the distance</a>
<a name="ln679">		*distance = FLT_MAX;</a>
<a name="ln680"> </a>
<a name="ln681">		for (int32 i = 0; i &lt; fPointCount - 1; i++) {</a>
<a name="ln682">			float segDist = distance_to_curve(p, fPath[i].point,</a>
<a name="ln683">				fPath[i].point_out, fPath[i + 1].point_in, fPath[i + 1].point);</a>
<a name="ln684">			if (segDist &lt; *distance) {</a>
<a name="ln685">				*distance = segDist;</a>
<a name="ln686">				*index = i + 1;</a>
<a name="ln687">			}</a>
<a name="ln688">		}</a>
<a name="ln689">		if (fClosed) {</a>
<a name="ln690">			float segDist = distance_to_curve(p, fPath[fPointCount - 1].point,</a>
<a name="ln691">				fPath[fPointCount - 1].point_out, fPath[0].point_in,</a>
<a name="ln692">				fPath[0].point);</a>
<a name="ln693">			if (segDist &lt; *distance) {</a>
<a name="ln694">				*distance = segDist;</a>
<a name="ln695">				*index = fPointCount;</a>
<a name="ln696">			}</a>
<a name="ln697">		}</a>
<a name="ln698">		return true;</a>
<a name="ln699">	}</a>
<a name="ln700">	return false;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704">bool</a>
<a name="ln705">VectorPath::FindBezierScale(int32 index, BPoint point, double* scale) const</a>
<a name="ln706">{</a>
<a name="ln707">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount &amp;&amp; scale) {</a>
<a name="ln708">		int maxStep = 1000;</a>
<a name="ln709"> </a>
<a name="ln710">		double t = 0.0;</a>
<a name="ln711">		double dt = 1.0 / maxStep;</a>
<a name="ln712"> </a>
<a name="ln713">		*scale = 0.0;</a>
<a name="ln714">		double min = FLT_MAX;</a>
<a name="ln715"> </a>
<a name="ln716">		BPoint curvePoint;</a>
<a name="ln717">		for (int step = 1; step &lt; maxStep; step++) {</a>
<a name="ln718">			t += dt;</a>
<a name="ln719"> </a>
<a name="ln720">			GetPoint(index, t, curvePoint);</a>
<a name="ln721">			double d = agg::calc_distance(curvePoint.x, curvePoint.y,</a>
<a name="ln722">				point.x, point.y);</a>
<a name="ln723"> </a>
<a name="ln724">			if (d &lt; min) {</a>
<a name="ln725">				min = d;</a>
<a name="ln726">				*scale = t;</a>
<a name="ln727">			}</a>
<a name="ln728">		}</a>
<a name="ln729">		return true;</a>
<a name="ln730">	}</a>
<a name="ln731">	return false;</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734"> </a>
<a name="ln735">bool</a>
<a name="ln736">VectorPath::GetPoint(int32 index, double t, BPoint&amp; point) const</a>
<a name="ln737">{</a>
<a name="ln738">	if (index &gt;= 0 &amp;&amp; index &lt; fPointCount) {</a>
<a name="ln739">		double t1 = (1 - t) * (1 - t) * (1 - t);</a>
<a name="ln740">		double t2 = (1 - t) * (1 - t) * t * 3;</a>
<a name="ln741">		double t3 = (1 - t) * t * t * 3;</a>
<a name="ln742">		double t4 = t * t * t;</a>
<a name="ln743"> </a>
<a name="ln744">		if (index &lt; fPointCount - 1) {</a>
<a name="ln745">			point.x = fPath[index].point.x * t1 + fPath[index].point_out.x * t2</a>
<a name="ln746">				+ fPath[index + 1].point_in.x * t3</a>
<a name="ln747">				+ fPath[index + 1].point.x * t4;</a>
<a name="ln748"> </a>
<a name="ln749">			point.y = fPath[index].point.y * t1 + fPath[index].point_out.y * t2</a>
<a name="ln750">				+ fPath[index + 1].point_in.y * t3</a>
<a name="ln751">				+ fPath[index + 1].point.y * t4;</a>
<a name="ln752">		} else if (fClosed) {</a>
<a name="ln753">			point.x = fPath[fPointCount - 1].point.x * t1</a>
<a name="ln754">				+ fPath[fPointCount - 1].point_out.x * t2</a>
<a name="ln755">				+ fPath[0].point_in.x * t3 + fPath[0].point.x * t4;</a>
<a name="ln756"> </a>
<a name="ln757">			point.y = fPath[fPointCount - 1].point.y * t1</a>
<a name="ln758">				+ fPath[fPointCount - 1].point_out.y * t2</a>
<a name="ln759">				+ fPath[0].point_in.y * t3 + fPath[0].point.y * t4;</a>
<a name="ln760">		}</a>
<a name="ln761"> </a>
<a name="ln762">		return true;</a>
<a name="ln763">	}</a>
<a name="ln764">	return false;</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767">#endif // ICON_O_MATIC</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">void</a>
<a name="ln771">VectorPath::SetClosed(bool closed)</a>
<a name="ln772">{</a>
<a name="ln773">	if (fClosed != closed) {</a>
<a name="ln774">		fClosed = closed;</a>
<a name="ln775">		_NotifyClosedChanged();</a>
<a name="ln776">		Notify();</a>
<a name="ln777">	}</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780"> </a>
<a name="ln781">BRect</a>
<a name="ln782">VectorPath::Bounds() const</a>
<a name="ln783">{</a>
<a name="ln784">	// the bounds of the actual curves, not the control points!</a>
<a name="ln785">	if (!fCachedBounds.IsValid())</a>
<a name="ln786">		 fCachedBounds = _Bounds();</a>
<a name="ln787">	return fCachedBounds;</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790"> </a>
<a name="ln791">BRect</a>
<a name="ln792">VectorPath::_Bounds() const</a>
<a name="ln793">{</a>
<a name="ln794">	agg::path_storage path;</a>
<a name="ln795"> </a>
<a name="ln796">	BRect b;</a>
<a name="ln797">	if (get_path_storage(path, fPath, fPointCount, fClosed)) {</a>
<a name="ln798">		agg::conv_curve&lt;agg::path_storage&gt; curve(path);</a>
<a name="ln799"> </a>
<a name="ln800">		uint32 pathID[1];</a>
<a name="ln801">		pathID[0] = 0;</a>
<a name="ln802">		double left, top, right, bottom;</a>
<a name="ln803"> </a>
<a name="ln804">		agg::bounding_rect(curve, pathID, 0, 1, &amp;left, &amp;top, &amp;right, &amp;bottom);</a>
<a name="ln805"> </a>
<a name="ln806">		b.Set(left, top, right, bottom);</a>
<a name="ln807">	} else if (fPointCount == 1) {</a>
<a name="ln808">		b.Set(fPath[0].point.x, fPath[0].point.y, fPath[0].point.x,</a>
<a name="ln809">			fPath[0].point.y);</a>
<a name="ln810">	} else {</a>
<a name="ln811">		b.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln812">	}</a>
<a name="ln813">	return b;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816"> </a>
<a name="ln817">BRect</a>
<a name="ln818">VectorPath::ControlPointBounds() const</a>
<a name="ln819">{</a>
<a name="ln820">	if (fPointCount &gt; 0) {</a>
<a name="ln821">		BRect r(fPath[0].point, fPath[0].point);</a>
<a name="ln822">		for (int32 i = 0; i &lt; fPointCount; i++) {</a>
<a name="ln823">			// include point</a>
<a name="ln824">			r.left = min_c(r.left, fPath[i].point.x);</a>
<a name="ln825">			r.top = min_c(r.top, fPath[i].point.y);</a>
<a name="ln826">			r.right = max_c(r.right, fPath[i].point.x);</a>
<a name="ln827">			r.bottom = max_c(r.bottom, fPath[i].point.y);</a>
<a name="ln828">			// include &quot;in&quot; point</a>
<a name="ln829">			r.left = min_c(r.left, fPath[i].point_in.x);</a>
<a name="ln830">			r.top = min_c(r.top, fPath[i].point_in.y);</a>
<a name="ln831">			r.right = max_c(r.right, fPath[i].point_in.x);</a>
<a name="ln832">			r.bottom = max_c(r.bottom, fPath[i].point_in.y);</a>
<a name="ln833">			// include &quot;out&quot; point</a>
<a name="ln834">			r.left = min_c(r.left, fPath[i].point_out.x);</a>
<a name="ln835">			r.top = min_c(r.top, fPath[i].point_out.y);</a>
<a name="ln836">			r.right = max_c(r.right, fPath[i].point_out.x);</a>
<a name="ln837">			r.bottom = max_c(r.bottom, fPath[i].point_out.y);</a>
<a name="ln838">		}</a>
<a name="ln839">		return r;</a>
<a name="ln840">	}</a>
<a name="ln841">	return BRect(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">void</a>
<a name="ln846">VectorPath::Iterate(Iterator* iterator, float smoothScale) const</a>
<a name="ln847">{</a>
<a name="ln848">	if (fPointCount &gt; 1) {</a>
<a name="ln849">		// generate a curve for each segment of the path</a>
<a name="ln850">		// then	iterate over the segments of the curve</a>
<a name="ln851">		agg::curve4_inc curve;</a>
<a name="ln852">		curve.approximation_scale(smoothScale);</a>
<a name="ln853"> </a>
<a name="ln854">		for (int32 i = 0; i &lt; fPointCount - 1; i++) {</a>
<a name="ln855">			iterator-&gt;MoveTo(fPath[i].point);</a>
<a name="ln856">			curve.init(fPath[i].point.x, fPath[i].point.y,</a>
<a name="ln857">				fPath[i].point_out.x, fPath[i].point_out.y,</a>
<a name="ln858">				fPath[i + 1].point_in.x, fPath[i + 1].point_in.y,</a>
<a name="ln859">				fPath[i + 1].point.x, fPath[i + 1].point.y);</a>
<a name="ln860"> </a>
<a name="ln861">			double x, y;</a>
<a name="ln862">			unsigned cmd = curve.vertex(&amp;x, &amp;y);</a>
<a name="ln863">			while (!agg::is_stop(cmd)) {</a>
<a name="ln864">				BPoint p(x, y);</a>
<a name="ln865">				iterator-&gt;LineTo(p);</a>
<a name="ln866">				cmd = curve.vertex(&amp;x, &amp;y);</a>
<a name="ln867">			}</a>
<a name="ln868">		}</a>
<a name="ln869">		if (fClosed) {</a>
<a name="ln870">			iterator-&gt;MoveTo(fPath[fPointCount - 1].point);</a>
<a name="ln871">			curve.init(fPath[fPointCount - 1].point.x,</a>
<a name="ln872">				fPath[fPointCount - 1].point.y,</a>
<a name="ln873">				fPath[fPointCount - 1].point_out.x,</a>
<a name="ln874">				fPath[fPointCount - 1].point_out.y,</a>
<a name="ln875">				fPath[0].point_in.x, fPath[0].point_in.y,</a>
<a name="ln876">				fPath[0].point.x, fPath[0].point.y);</a>
<a name="ln877"> </a>
<a name="ln878">			double x, y;</a>
<a name="ln879">			unsigned cmd = curve.vertex(&amp;x, &amp;y);</a>
<a name="ln880">			while (!agg::is_stop(cmd)) {</a>
<a name="ln881">				BPoint p(x, y);</a>
<a name="ln882">				iterator-&gt;LineTo(p);</a>
<a name="ln883">				cmd = curve.vertex(&amp;x, &amp;y);</a>
<a name="ln884">			}</a>
<a name="ln885">		}</a>
<a name="ln886">	}</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889"> </a>
<a name="ln890">void</a>
<a name="ln891">VectorPath::CleanUp()</a>
<a name="ln892">{</a>
<a name="ln893">	if (fPointCount == 0)</a>
<a name="ln894">		return;</a>
<a name="ln895"> </a>
<a name="ln896">	bool notify = false;</a>
<a name="ln897"> </a>
<a name="ln898">	// remove last point if it is coincident with the first</a>
<a name="ln899">	if (fClosed &amp;&amp; fPointCount &gt;= 1) {</a>
<a name="ln900">		if (fPath[0].point == fPath[fPointCount - 1].point) {</a>
<a name="ln901">			fPath[0].point_in = fPath[fPointCount - 1].point_in;</a>
<a name="ln902">			_SetPointCount(fPointCount - 1);</a>
<a name="ln903">			notify = true;</a>
<a name="ln904">		}</a>
<a name="ln905">	}</a>
<a name="ln906"> </a>
<a name="ln907">	for (int32 i = 0; i &lt; fPointCount; i++) {</a>
<a name="ln908">		// check for unnecessary, duplicate points</a>
<a name="ln909">		if (i &gt; 0) {</a>
<a name="ln910">			if (fPath[i - 1].point == fPath[i].point</a>
<a name="ln911">				&amp;&amp; fPath[i - 1].point == fPath[i - 1].point_out</a>
<a name="ln912">				&amp;&amp; fPath[i].point == fPath[i].point_in) {</a>
<a name="ln913">				// the previous point can be removed</a>
<a name="ln914">				BPoint in = fPath[i - 1].point_in;</a>
<a name="ln915">				if (RemovePoint(i - 1)) {</a>
<a name="ln916">					i--;</a>
<a name="ln917">					fPath[i].point_in = in;</a>
<a name="ln918">					notify = true;</a>
<a name="ln919">				}</a>
<a name="ln920">			}</a>
<a name="ln921">		}</a>
<a name="ln922">		// re-establish connections of in-out control points if</a>
<a name="ln923">		// they line up with the main control point</a>
<a name="ln924">		if (fPath[i].point_in == fPath[i].point_out</a>
<a name="ln925">			|| fPath[i].point == fPath[i].point_out</a>
<a name="ln926">			|| fPath[i].point == fPath[i].point_in</a>
<a name="ln927">			|| (fabs(agg::calc_line_point_distance(fPath[i].point_in.x,</a>
<a name="ln928">					fPath[i].point_in.y, fPath[i].point.x, fPath[i].point.y,</a>
<a name="ln929">					fPath[i].point_out.x, fPath[i].point_out.y)) &lt; 0.01</a>
<a name="ln930">				&amp;&amp; fabs(agg::calc_line_point_distance(fPath[i].point_out.x,</a>
<a name="ln931">					fPath[i].point_out.y, fPath[i].point.x, fPath[i].point.y,</a>
<a name="ln932">					fPath[i].point_in.x, fPath[i].point_in.y)) &lt; 0.01)) {</a>
<a name="ln933">			fPath[i].connected = true;</a>
<a name="ln934">			notify = true;</a>
<a name="ln935">		}</a>
<a name="ln936">	}</a>
<a name="ln937"> </a>
<a name="ln938">	if (notify)</a>
<a name="ln939">		_NotifyPathChanged();</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942"> </a>
<a name="ln943">void</a>
<a name="ln944">VectorPath::Reverse()</a>
<a name="ln945">{</a>
<a name="ln946">	VectorPath temp(*this);</a>
<a name="ln947">	int32 index = 0;</a>
<a name="ln948">	for (int32 i = fPointCount - 1; i &gt;= 0; i--) {</a>
<a name="ln949">		temp.SetPoint(index, fPath[i].point, fPath[i].point_out,</a>
<a name="ln950">			fPath[i].point_in, fPath[i].connected);</a>
<a name="ln951">		index++;</a>
<a name="ln952">	}</a>
<a name="ln953">	*this = temp;</a>
<a name="ln954"> </a>
<a name="ln955">	_NotifyPathReversed();</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958"> </a>
<a name="ln959">void</a>
<a name="ln960">VectorPath::ApplyTransform(const Transformable&amp; transform)</a>
<a name="ln961">{</a>
<a name="ln962">	if (transform.IsIdentity())</a>
<a name="ln963">		return;</a>
<a name="ln964"> </a>
<a name="ln965">	for (int32 i = 0; i &lt; fPointCount; i++) {</a>
<a name="ln966">		transform.Transform(&amp;(fPath[i].point));</a>
<a name="ln967">		transform.Transform(&amp;(fPath[i].point_out));</a>
<a name="ln968">		transform.Transform(&amp;(fPath[i].point_in));</a>
<a name="ln969">	}</a>
<a name="ln970"> </a>
<a name="ln971">	_NotifyPathChanged();</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">void</a>
<a name="ln976">VectorPath::PrintToStream() const</a>
<a name="ln977">{</a>
<a name="ln978">	for (int32 i = 0; i &lt; fPointCount; i++) {</a>
<a name="ln979">		printf(&quot;point %&quot; B_PRId32 &quot;: (%f, %f) -&gt; (%f, %f) -&gt; (%f, %f) (%d)\n&quot;, i,</a>
<a name="ln980">			fPath[i].point_in.x, fPath[i].point_in.y,</a>
<a name="ln981">			fPath[i].point.x, fPath[i].point.y,</a>
<a name="ln982">			fPath[i].point_out.x, fPath[i].point_out.y, fPath[i].connected);</a>
<a name="ln983">	}</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986"> </a>
<a name="ln987">bool</a>
<a name="ln988">VectorPath::GetAGGPathStorage(agg::path_storage&amp; path) const</a>
<a name="ln989">{</a>
<a name="ln990">	return get_path_storage(path, fPath, fPointCount, fClosed);</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">// #pragma mark -</a>
<a name="ln995"> </a>
<a name="ln996"> </a>
<a name="ln997">#ifdef ICON_O_MATIC</a>
<a name="ln998"> </a>
<a name="ln999">bool</a>
<a name="ln1000">VectorPath::AddListener(PathListener* listener)</a>
<a name="ln1001">{</a>
<a name="ln1002">	if (listener &amp;&amp; !fListeners.HasItem((void*)listener))</a>
<a name="ln1003">		return fListeners.AddItem((void*)listener);</a>
<a name="ln1004">	return false;</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007"> </a>
<a name="ln1008">bool</a>
<a name="ln1009">VectorPath::RemoveListener(PathListener* listener)</a>
<a name="ln1010">{</a>
<a name="ln1011">	return fListeners.RemoveItem((void*)listener);</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014"> </a>
<a name="ln1015">int32</a>
<a name="ln1016">VectorPath::CountListeners() const</a>
<a name="ln1017">{</a>
<a name="ln1018">	return fListeners.CountItems();</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021"> </a>
<a name="ln1022">PathListener*</a>
<a name="ln1023">VectorPath::ListenerAtFast(int32 index) const</a>
<a name="ln1024">{</a>
<a name="ln1025">	return (PathListener*)fListeners.ItemAtFast(index);</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028">#endif // ICON_O_MATIC</a>
<a name="ln1029"> </a>
<a name="ln1030"> </a>
<a name="ln1031">// #pragma mark -</a>
<a name="ln1032"> </a>
<a name="ln1033"> </a>
<a name="ln1034">void</a>
<a name="ln1035">VectorPath::_SetPoint(int32 index, BPoint point)</a>
<a name="ln1036">{</a>
<a name="ln1037">	fPath[index].point = point;</a>
<a name="ln1038">	fPath[index].point_in = point;</a>
<a name="ln1039">	fPath[index].point_out = point;</a>
<a name="ln1040"> </a>
<a name="ln1041">	fPath[index].connected = true;</a>
<a name="ln1042"> </a>
<a name="ln1043">	fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046"> </a>
<a name="ln1047">void</a>
<a name="ln1048">VectorPath::_SetPoint(int32 index, const BPoint&amp; point, const BPoint&amp; pointIn,</a>
<a name="ln1049">	const BPoint&amp; pointOut, bool connected)</a>
<a name="ln1050">{</a>
<a name="ln1051">	fPath[index].point = point;</a>
<a name="ln1052">	fPath[index].point_in = pointIn;</a>
<a name="ln1053">	fPath[index].point_out = pointOut;</a>
<a name="ln1054"> </a>
<a name="ln1055">	fPath[index].connected = connected;</a>
<a name="ln1056"> </a>
<a name="ln1057">	fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060"> </a>
<a name="ln1061">// #pragma mark -</a>
<a name="ln1062"> </a>
<a name="ln1063"> </a>
<a name="ln1064">bool</a>
<a name="ln1065">VectorPath::_SetPointCount(int32 count)</a>
<a name="ln1066">{</a>
<a name="ln1067">	// handle reallocation if we run out of room</a>
<a name="ln1068">	if (count &gt;= fAllocCount) {</a>
<a name="ln1069">		fAllocCount = ((count) / ALLOC_CHUNKS + 1) * ALLOC_CHUNKS;</a>
<a name="ln1070">		if (fPath)</a>
<a name="ln1071">			fPath = obj_renew(fPath, control_point, fAllocCount);</a>
<a name="ln1072">		else</a>
<a name="ln1073">			fPath = obj_new(control_point, fAllocCount);</a>
<a name="ln1074"> </a>
<a name="ln1075">		if (fPath != NULL) {</a>
<a name="ln1076">			memset((void*)(fPath + fPointCount), 0,</a>
<a name="ln1077">				(fAllocCount - fPointCount) * sizeof(control_point));</a>
<a name="ln1078">		}</a>
<a name="ln1079">	}</a>
<a name="ln1080"> </a>
<a name="ln1081">	// update point count</a>
<a name="ln1082">	if (fPath) {</a>
<a name="ln1083">		fPointCount = count;</a>
<a name="ln1084">	} else {</a>
<a name="ln1085">		// reallocation might have failed</a>
<a name="ln1086">		fPointCount = 0;</a>
<a name="ln1087">		fAllocCount = 0;</a>
<a name="ln1088">		fprintf(stderr, &quot;VectorPath::_SetPointCount(%&quot; B_PRId32 &quot;) - allocation failed!\n&quot;,</a>
<a name="ln1089">			count);</a>
<a name="ln1090">	}</a>
<a name="ln1091"> </a>
<a name="ln1092">	fCachedBounds.Set(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln1093"> </a>
<a name="ln1094">	return fPath != NULL;</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097"> </a>
<a name="ln1098">// #pragma mark -</a>
<a name="ln1099"> </a>
<a name="ln1100"> </a>
<a name="ln1101">#ifdef ICON_O_MATIC</a>
<a name="ln1102"> </a>
<a name="ln1103">void</a>
<a name="ln1104">VectorPath::_NotifyPointAdded(int32 index) const</a>
<a name="ln1105">{</a>
<a name="ln1106">	BList listeners(fListeners);</a>
<a name="ln1107">	int32 count = listeners.CountItems();</a>
<a name="ln1108">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1109">		PathListener* listener = (PathListener*)listeners.ItemAtFast(i);</a>
<a name="ln1110">		listener-&gt;PointAdded(index);</a>
<a name="ln1111">	}</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114"> </a>
<a name="ln1115">void</a>
<a name="ln1116">VectorPath::_NotifyPointChanged(int32 index) const</a>
<a name="ln1117">{</a>
<a name="ln1118">	BList listeners(fListeners);</a>
<a name="ln1119">	int32 count = listeners.CountItems();</a>
<a name="ln1120">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1121">		PathListener* listener = (PathListener*)listeners.ItemAtFast(i);</a>
<a name="ln1122">		listener-&gt;PointChanged(index);</a>
<a name="ln1123">	}</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126"> </a>
<a name="ln1127">void</a>
<a name="ln1128">VectorPath::_NotifyPointRemoved(int32 index) const</a>
<a name="ln1129">{</a>
<a name="ln1130">	BList listeners(fListeners);</a>
<a name="ln1131">	int32 count = listeners.CountItems();</a>
<a name="ln1132">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1133">		PathListener* listener = (PathListener*)listeners.ItemAtFast(i);</a>
<a name="ln1134">		listener-&gt;PointRemoved(index);</a>
<a name="ln1135">	}</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138"> </a>
<a name="ln1139">void</a>
<a name="ln1140">VectorPath::_NotifyPathChanged() const</a>
<a name="ln1141">{</a>
<a name="ln1142">	BList listeners(fListeners);</a>
<a name="ln1143">	int32 count = listeners.CountItems();</a>
<a name="ln1144">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1145">		PathListener* listener = (PathListener*)listeners.ItemAtFast(i);</a>
<a name="ln1146">		listener-&gt;PathChanged();</a>
<a name="ln1147">	}</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150"> </a>
<a name="ln1151">void</a>
<a name="ln1152">VectorPath::_NotifyClosedChanged() const</a>
<a name="ln1153">{</a>
<a name="ln1154">	BList listeners(fListeners);</a>
<a name="ln1155">	int32 count = listeners.CountItems();</a>
<a name="ln1156">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1157">		PathListener* listener = (PathListener*)listeners.ItemAtFast(i);</a>
<a name="ln1158">		listener-&gt;PathClosedChanged();</a>
<a name="ln1159">	}</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162"> </a>
<a name="ln1163">void</a>
<a name="ln1164">VectorPath::_NotifyPathReversed() const</a>
<a name="ln1165">{</a>
<a name="ln1166">	BList listeners(fListeners);</a>
<a name="ln1167">	int32 count = listeners.CountItems();</a>
<a name="ln1168">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1169">		PathListener* listener = (PathListener*)listeners.ItemAtFast(i);</a>
<a name="ln1170">		listener-&gt;PathReversed();</a>
<a name="ln1171">	}</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">#endif // ICON_O_MATIC</a>

</code></pre>
<div class="balloon" rel="1073"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors.</p></div>
<div class="balloon" rel="1071"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'realloc' function is used to allocate memory for an array of objects which are classes containing constructors.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
