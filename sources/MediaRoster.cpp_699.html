
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>MediaRoster.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2015 Dario Casalinuovo</a>
<a name="ln3"> * Copyright 2009-2012, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln4"> * Copyright 2008 Maurice Kalinowski, haiku@kaldience.com</a>
<a name="ln5"> *</a>
<a name="ln6"> * All rights reserved. Distributed under the terms of the MIT License.</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9">/*</a>
<a name="ln10"> * Copyright (c) 2002-2006 Marcus Overhagen &lt;Marcus@Overhagen.de&gt;</a>
<a name="ln11"> *</a>
<a name="ln12"> * Permission is hereby granted, free of charge, to any person obtaining</a>
<a name="ln13"> * a copy of this software and associated documentation files or portions</a>
<a name="ln14"> * thereof (the &quot;Software&quot;), to deal in the Software without restriction,</a>
<a name="ln15"> * including without limitation the rights to use, copy, modify, merge,</a>
<a name="ln16"> * publish, distribute, sublicense, and/or sell copies of the Software,</a>
<a name="ln17"> * and to permit persons to whom the Software is furnished to do so, subject</a>
<a name="ln18"> * to the following conditions:</a>
<a name="ln19"> *</a>
<a name="ln20"> *  * Redistributions of source code must retain the above copyright notice,</a>
<a name="ln21"> *    this list of conditions and the following disclaimer.</a>
<a name="ln22"> *</a>
<a name="ln23"> *  * Redistributions in binary form must reproduce the above copyright notice</a>
<a name="ln24"> *    in the  binary, as well as this list of conditions and the following</a>
<a name="ln25"> *    disclaimer in the documentation and/or other materials provided with</a>
<a name="ln26"> *    the distribution.</a>
<a name="ln27"> *</a>
<a name="ln28"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</a>
<a name="ln29"> * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</a>
<a name="ln30"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln31"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</a>
<a name="ln32"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</a>
<a name="ln33"> * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</a>
<a name="ln34"> * THE SOFTWARE.</a>
<a name="ln35"> */</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">/* to comply with the license above, do not remove the following line */</a>
<a name="ln39">char __dont_remove_copyright_from_binary[] = &quot;Copyright (c) 2002-2006 Marcus &quot;</a>
<a name="ln40">	&quot;Overhagen &lt;Marcus@Overhagen.de&gt;&quot;;</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;MediaRoster.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;Application.h&gt;</a>
<a name="ln46">#include &lt;Autolock.h&gt;</a>
<a name="ln47">#include &lt;BufferConsumer.h&gt;</a>
<a name="ln48">#include &lt;BufferProducer.h&gt;</a>
<a name="ln49">#include &lt;Locker.h&gt;</a>
<a name="ln50">#include &lt;Message.h&gt;</a>
<a name="ln51">#include &lt;Messenger.h&gt;</a>
<a name="ln52">#include &lt;MimeType.h&gt;</a>
<a name="ln53">#include &lt;OS.h&gt;</a>
<a name="ln54">#include &lt;ParameterWeb.h&gt;</a>
<a name="ln55">#include &lt;Roster.h&gt;</a>
<a name="ln56">#include &lt;StopWatch.h&gt;</a>
<a name="ln57">#include &lt;String.h&gt;</a>
<a name="ln58">#include &lt;TimeSource.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;new&gt;</a>
<a name="ln61"> </a>
<a name="ln62">#include &lt;AppMisc.h&gt;</a>
<a name="ln63">#include &lt;DataExchange.h&gt;</a>
<a name="ln64">#include &lt;MediaDebug.h&gt;</a>
<a name="ln65">#include &lt;DormantNodeManager.h&gt;</a>
<a name="ln66">#include &lt;MediaMisc.h&gt;</a>
<a name="ln67">#include &lt;MediaRosterEx.h&gt;</a>
<a name="ln68">#include &lt;Notifications.h&gt;</a>
<a name="ln69">#include &lt;ServerInterface.h&gt;</a>
<a name="ln70">#include &lt;SharedBufferList.h&gt;</a>
<a name="ln71">#include &lt;TList.h&gt;</a>
<a name="ln72"> </a>
<a name="ln73">#include &quot;TimeSourceObjectManager.h&quot;</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">namespace BPrivate {</a>
<a name="ln77">namespace media {</a>
<a name="ln78"> </a>
<a name="ln79"> </a>
<a name="ln80">struct RosterNotification {</a>
<a name="ln81">	BMessenger	messenger;</a>
<a name="ln82">	int32		what;</a>
<a name="ln83">};</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">struct SyncedMessage {</a>
<a name="ln87">	BMessage* message;</a>
<a name="ln88">};</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">struct LocalNode {</a>
<a name="ln92">				LocalNode(BMediaNode* local_node)</a>
<a name="ln93">					:</a>
<a name="ln94">					node(local_node) {}</a>
<a name="ln95"> </a>
<a name="ln96">				LocalNode()</a>
<a name="ln97">					:</a>
<a name="ln98">					node(NULL) {}</a>
<a name="ln99"> </a>
<a name="ln100">	bool 		operator==(const LocalNode&amp; a)</a>
<a name="ln101">				{</a>
<a name="ln102">					if (a.node == this-&gt;node)</a>
<a name="ln103">						return true;</a>
<a name="ln104">					return false;</a>
<a name="ln105">				}</a>
<a name="ln106"> </a>
<a name="ln107">	BMediaNode* node;</a>
<a name="ln108">};</a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">static bool sServerIsUp = false;</a>
<a name="ln112">static List&lt;RosterNotification&gt; sNotificationList;</a>
<a name="ln113">static BLocker sInitLocker(&quot;BMediaRoster::Roster locker&quot;);</a>
<a name="ln114">static List&lt;LocalNode&gt; sRegisteredNodes;</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">class MediaRosterUndertaker {</a>
<a name="ln118">public:</a>
<a name="ln119">	~MediaRosterUndertaker()</a>
<a name="ln120">	{</a>
<a name="ln121">		BAutolock _(sInitLocker);</a>
<a name="ln122">		if (BMediaRoster::CurrentRoster() != NULL) {</a>
<a name="ln123"> </a>
<a name="ln124">			// Detect any forgotten node</a>
<a name="ln125">			if (sRegisteredNodes.CountItems() &gt; 0) {</a>
<a name="ln126">				for (int32 i = 0; i &lt; sRegisteredNodes.CountItems(); i++) {</a>
<a name="ln127">					LocalNode* node = NULL;</a>
<a name="ln128">					sRegisteredNodes.Get(i, &amp;node);</a>
<a name="ln129">					if (node != NULL) {</a>
<a name="ln130">						ERROR(&quot;BMediaRoster: Node with ID %&quot; B_PRId32</a>
<a name="ln131">							&quot; was not released correctly\n&quot;, node-&gt;node-&gt;ID());</a>
<a name="ln132">					}</a>
<a name="ln133">				}</a>
<a name="ln134">			}</a>
<a name="ln135"> </a>
<a name="ln136">			if (be_app != NULL)</a>
<a name="ln137">				be_app-&gt;UnregisterLooper(BMediaRoster::CurrentRoster());</a>
<a name="ln138"> </a>
<a name="ln139">			status_t err = B_ERROR;</a>
<a name="ln140">			thread_id roster = BMediaRoster::CurrentRoster()-&gt;Thread();</a>
<a name="ln141"> </a>
<a name="ln142">			BMediaRoster::CurrentRoster()-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln143"> </a>
<a name="ln144">			wait_for_thread(roster, &amp;err);</a>
<a name="ln145">			if (err != B_OK)</a>
<a name="ln146">				ERROR(&quot;BMediaRoster: wait_for_thread returned error&quot;);</a>
<a name="ln147">		}</a>
<a name="ln148">	}</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">static MediaRosterUndertaker sMediaRosterUndertaker;</a>
<a name="ln153"> </a>
<a name="ln154">}	// namespace media</a>
<a name="ln155">}	// namespace BPrivate</a>
<a name="ln156"> </a>
<a name="ln157">using namespace BPrivate::media;</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">BMediaRosterEx::BMediaRosterEx(status_t* _error)</a>
<a name="ln161">	:</a>
<a name="ln162">	BMediaRoster(),</a>
<a name="ln163">	fLaunchNotification(false),</a>
<a name="ln164">	fAutoExit(false)</a>
<a name="ln165">{</a>
<a name="ln166">	gDormantNodeManager = new DormantNodeManager();</a>
<a name="ln167">	gTimeSourceObjectManager = new TimeSourceObjectManager();</a>
<a name="ln168"> </a>
<a name="ln169">	*_error = BuildConnections();</a>
<a name="ln170"> </a>
<a name="ln171">	InitRosterDataExchange(BMessenger(this, this));</a>
<a name="ln172"> </a>
<a name="ln173">	if (be_roster-&gt;StartWatching(BMessenger(this, this),</a>
<a name="ln174">			B_REQUEST_LAUNCHED | B_REQUEST_QUIT) != B_OK) {</a>
<a name="ln175">		*_error = B_ERROR;</a>
<a name="ln176">	}</a>
<a name="ln177">	sServerIsUp = BMediaRoster::IsRunning();</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">void</a>
<a name="ln182">BMediaRosterEx::Quit()</a>
<a name="ln183">{</a>
<a name="ln184">	if (be_roster-&gt;StopWatching(BMessenger(this, this)) != B_OK)</a>
<a name="ln185">			TRACE(&quot;Can't unregister roster notifications&quot;);</a>
<a name="ln186"> </a>
<a name="ln187">	if (sNotificationList.CountItems() != 0)</a>
<a name="ln188">		sNotificationList.MakeEmpty();</a>
<a name="ln189"> </a>
<a name="ln190">	BMediaRoster::Quit();</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">status_t</a>
<a name="ln195">BMediaRosterEx::BuildConnections()</a>
<a name="ln196">{</a>
<a name="ln197">	InitServerDataExchange();</a>
<a name="ln198">	// register this application with the media server</a>
<a name="ln199">	server_register_app_request request;</a>
<a name="ln200">	server_register_app_reply reply;</a>
<a name="ln201">	request.team = BPrivate::current_team();</a>
<a name="ln202">	request.messenger = BMessenger(NULL, this);</a>
<a name="ln203">	status_t status = QueryServer(SERVER_REGISTER_APP, &amp;request,</a>
<a name="ln204">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln205">	if (status != B_OK)</a>
<a name="ln206">		return B_MEDIA_SYSTEM_FAILURE;</a>
<a name="ln207"> </a>
<a name="ln208">	return B_OK;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">BMediaRosterEx::~BMediaRosterEx()</a>
<a name="ln213">{</a>
<a name="ln214">	CALLED();</a>
<a name="ln215"> </a>
<a name="ln216">	delete gTimeSourceObjectManager;</a>
<a name="ln217">	delete gDormantNodeManager;</a>
<a name="ln218"> </a>
<a name="ln219">	// unregister this application with the media server</a>
<a name="ln220">	server_unregister_app_request request;</a>
<a name="ln221">	server_unregister_app_reply reply;</a>
<a name="ln222">	request.team = BPrivate::current_team();</a>
<a name="ln223">	QueryServer(SERVER_UNREGISTER_APP, &amp;request, sizeof(request), &amp;reply,</a>
<a name="ln224">		sizeof(reply));</a>
<a name="ln225"> </a>
<a name="ln226">	BPrivate::SharedBufferList::Invalidate();</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230">void</a>
<a name="ln231">BMediaRosterEx::RegisterLocalNode(BMediaNode* node)</a>
<a name="ln232">{</a>
<a name="ln233">	sRegisteredNodes.Insert(LocalNode(node));</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236"> </a>
<a name="ln237">void</a>
<a name="ln238">BMediaRosterEx::UnregisterLocalNode(BMediaNode* node)</a>
<a name="ln239">{</a>
<a name="ln240">	int32 index = sRegisteredNodes.Find(LocalNode(node));</a>
<a name="ln241">	if (index != -1)</a>
<a name="ln242">		sRegisteredNodes.Remove(index);</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">void</a>
<a name="ln247">BMediaRosterEx::EnableLaunchNotification(bool enable, bool autoExit)</a>
<a name="ln248">{</a>
<a name="ln249">	// NOTE: in theory, we should personalize it depending on each</a>
<a name="ln250">	// request, but we are using it just in launch/shutdown_media_server,</a>
<a name="ln251">	// so we are enough safe to don't care about that.</a>
<a name="ln252">	fLaunchNotification = enable;</a>
<a name="ln253">	fAutoExit = autoExit;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">status_t</a>
<a name="ln258">BMediaRosterEx::SaveNodeConfiguration(BMediaNode* node)</a>
<a name="ln259">{</a>
<a name="ln260">	int32 flavorID;</a>
<a name="ln261">	BMediaAddOn* addon = node-&gt;AddOn(&amp;flavorID);</a>
<a name="ln262">	if (addon == NULL) {</a>
<a name="ln263">		// NOTE: This node could have been created by an application,</a>
<a name="ln264">		// it does not mean there is an error.</a>
<a name="ln265">		// TODO: this check incorrectly triggers on BeOS R5 BT848 node</a>
<a name="ln266">		TRACE(&quot;BMediaRosterEx::SaveNodeConfiguration node %&quot; B_PRId32 &quot; not &quot;</a>
<a name="ln267">			&quot;instantiated from BMediaAddOn!\n&quot;, node-&gt;ID());</a>
<a name="ln268">		return B_ERROR;</a>
<a name="ln269">	}</a>
<a name="ln270"> </a>
<a name="ln271">	media_addon_id addonID = addon-&gt;AddonID();</a>
<a name="ln272"> </a>
<a name="ln273">	// TODO: fix this</a>
<a name="ln274">	printf(&quot;### BMediaRosterEx::SaveNodeConfiguration should save addon-id &quot;</a>
<a name="ln275">		&quot;%&quot; B_PRId32 &quot;, flavor-id %&quot; B_PRId32 &quot; config NOW!\n&quot;, addonID,</a>
<a name="ln276">		flavorID);</a>
<a name="ln277">	return B_OK;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280"> </a>
<a name="ln281">status_t</a>
<a name="ln282">BMediaRosterEx::LoadNodeConfiguration(media_addon_id addonID, int32 flavorID,</a>
<a name="ln283">	BMessage *_msg)</a>
<a name="ln284">{</a>
<a name="ln285">	// TODO: fix this</a>
<a name="ln286">	_msg-&gt;MakeEmpty(); // to be fully R5 compliant</a>
<a name="ln287">	printf(&quot;### BMediaRosterEx::LoadNodeConfiguration should load addon-id &quot;</a>
<a name="ln288">		&quot;%&quot; B_PRId32 &quot;, flavor-id %&quot; B_PRId32 &quot; config NOW!\n&quot;, addonID,</a>
<a name="ln289">		flavorID);</a>
<a name="ln290">	return B_OK;</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293"> </a>
<a name="ln294">status_t</a>
<a name="ln295">BMediaRosterEx::IncrementAddonFlavorInstancesCount(media_addon_id addonID,</a>
<a name="ln296">	int32 flavorID)</a>
<a name="ln297">{</a>
<a name="ln298">	server_change_flavor_instances_count_request request;</a>
<a name="ln299">	server_change_flavor_instances_count_reply reply;</a>
<a name="ln300"> </a>
<a name="ln301">	request.add_on_id = addonID;</a>
<a name="ln302">	request.flavor_id = flavorID;</a>
<a name="ln303">	request.delta = 1;</a>
<a name="ln304">	request.team = BPrivate::current_team();</a>
<a name="ln305">	return QueryServer(SERVER_CHANGE_FLAVOR_INSTANCES_COUNT, &amp;request,</a>
<a name="ln306">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309"> </a>
<a name="ln310">status_t</a>
<a name="ln311">BMediaRosterEx::DecrementAddonFlavorInstancesCount(media_addon_id addonID,</a>
<a name="ln312">	int32 flavorID)</a>
<a name="ln313">{</a>
<a name="ln314">	server_change_flavor_instances_count_request request;</a>
<a name="ln315">	server_change_flavor_instances_count_reply reply;</a>
<a name="ln316"> </a>
<a name="ln317">	request.add_on_id = addonID;</a>
<a name="ln318">	request.flavor_id = flavorID;</a>
<a name="ln319">	request.delta = -1;</a>
<a name="ln320">	request.team = BPrivate::current_team();</a>
<a name="ln321">	return QueryServer(SERVER_CHANGE_FLAVOR_INSTANCES_COUNT, &amp;request,</a>
<a name="ln322">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">status_t</a>
<a name="ln327">BMediaRosterEx::ReleaseNodeAll(const media_node&amp; node)</a>
<a name="ln328">{</a>
<a name="ln329">		CALLED();</a>
<a name="ln330">	if (IS_INVALID_NODE(node))</a>
<a name="ln331">		return B_MEDIA_BAD_NODE;</a>
<a name="ln332"> </a>
<a name="ln333">	if (node.kind &amp; NODE_KIND_NO_REFCOUNTING)</a>
<a name="ln334">		return B_OK;</a>
<a name="ln335"> </a>
<a name="ln336">	server_release_node_request request;</a>
<a name="ln337">	server_release_node_reply reply;</a>
<a name="ln338">	status_t rv;</a>
<a name="ln339"> </a>
<a name="ln340">	request.node = node;</a>
<a name="ln341">	request.team = BPrivate::current_team();</a>
<a name="ln342"> </a>
<a name="ln343">	TRACE(&quot;BMediaRoster::ReleaseNodeAll, node %&quot; B_PRId32 &quot;, port %&quot; B_PRId32</a>
<a name="ln344">		&quot;, team %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln345">		node.node, node.port, BPrivate::current_team());</a>
<a name="ln346"> </a>
<a name="ln347">	rv = QueryServer(SERVER_RELEASE_NODE_ALL, &amp;request, sizeof(request), &amp;reply,</a>
<a name="ln348">		sizeof(reply));</a>
<a name="ln349">	if (rv != B_OK) {</a>
<a name="ln350">		ERROR(&quot;BMediaRoster::ReleaseNodeAll failed to query media_server, &quot;</a>
<a name="ln351">			&quot;retrying local, node %&quot; B_PRId32 &quot;, port %&quot;</a>
<a name="ln352">			B_PRId32 &quot;, team %&quot; B_PRId32 &quot;!\n&quot;, node.node, node.port,</a>
<a name="ln353">			BPrivate::current_team());</a>
<a name="ln354">		node_final_release_command command;</a>
<a name="ln355">		rv = SendToPort(node.port, NODE_FINAL_RELEASE, &amp;command,</a>
<a name="ln356">			sizeof(command));</a>
<a name="ln357">		if (rv != B_OK) {</a>
<a name="ln358">			ERROR(&quot;BMediaRoster::ReleaseNodeAll FAILED, node %&quot; B_PRId32 &quot;, port %&quot;</a>
<a name="ln359">				B_PRId32 &quot;, team %&quot; B_PRId32 &quot;!\n&quot;, node.node, node.port,</a>
<a name="ln360">				BPrivate::current_team());</a>
<a name="ln361">		}</a>
<a name="ln362">	}</a>
<a name="ln363">	return rv;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367">status_t</a>
<a name="ln368">BMediaRosterEx::SetNodeCreator(media_node_id node, team_id creator)</a>
<a name="ln369">{</a>
<a name="ln370">	server_set_node_creator_request request;</a>
<a name="ln371">	server_set_node_creator_reply reply;</a>
<a name="ln372"> </a>
<a name="ln373">	request.node = node;</a>
<a name="ln374">	request.creator = creator;</a>
<a name="ln375">	return QueryServer(SERVER_SET_NODE_CREATOR, &amp;request, sizeof(request),</a>
<a name="ln376">		&amp;reply, sizeof(reply));</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379"> </a>
<a name="ln380">status_t</a>
<a name="ln381">BMediaRosterEx::GetNode(node_type type, media_node* out_node,</a>
<a name="ln382">	int32* out_input_id, BString* out_input_name)</a>
<a name="ln383">{</a>
<a name="ln384">	if (out_node == NULL)</a>
<a name="ln385">		return B_BAD_VALUE;</a>
<a name="ln386"> </a>
<a name="ln387">	server_get_node_request request;</a>
<a name="ln388">	server_get_node_reply reply;</a>
<a name="ln389">	status_t rv;</a>
<a name="ln390"> </a>
<a name="ln391">	request.type = type;</a>
<a name="ln392">	request.team = BPrivate::current_team();</a>
<a name="ln393">	rv = QueryServer(SERVER_GET_NODE, &amp;request, sizeof(request), &amp;reply,</a>
<a name="ln394">		sizeof(reply));</a>
<a name="ln395">	if (rv != B_OK)</a>
<a name="ln396">		return rv;</a>
<a name="ln397"> </a>
<a name="ln398">	*out_node = reply.node;</a>
<a name="ln399">	if (out_input_id)</a>
<a name="ln400">		*out_input_id = reply.input_id;</a>
<a name="ln401">	if (out_input_name)</a>
<a name="ln402">		*out_input_name = reply.input_name;</a>
<a name="ln403">	return rv;</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">status_t</a>
<a name="ln408">BMediaRosterEx::SetNode(node_type type, const media_node* node,</a>
<a name="ln409">	const dormant_node_info* info, const media_input* input)</a>
<a name="ln410">{</a>
<a name="ln411">	server_set_node_request request;</a>
<a name="ln412">	server_set_node_reply reply;</a>
<a name="ln413"> </a>
<a name="ln414">	request.type = type;</a>
<a name="ln415">	request.use_node = node != NULL;</a>
<a name="ln416">	if (node != NULL)</a>
<a name="ln417">		request.node = *node;</a>
<a name="ln418">	request.use_dni = info != NULL;</a>
<a name="ln419">	if (info != NULL)</a>
<a name="ln420">		request.dni = *info;</a>
<a name="ln421">	request.use_input = input != NULL;</a>
<a name="ln422">	if (input != NULL)</a>
<a name="ln423">		request.input = *input;</a>
<a name="ln424"> </a>
<a name="ln425">	return QueryServer(SERVER_SET_NODE, &amp;request, sizeof(request), &amp;reply,</a>
<a name="ln426">		sizeof(reply));</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">status_t</a>
<a name="ln431">BMediaRosterEx::GetAllOutputs(const media_node&amp; node, List&lt;media_output&gt;* list)</a>
<a name="ln432">{</a>
<a name="ln433">	int32 cookie;</a>
<a name="ln434">	status_t rv;</a>
<a name="ln435">	status_t result;</a>
<a name="ln436"> </a>
<a name="ln437">	PRINT(4, &quot;BMediaRosterEx::GetAllOutputs() node %&quot; B_PRId32 &quot;, port %&quot;</a>
<a name="ln438">		B_PRId32 &quot;\n&quot;, node.node, node.port);</a>
<a name="ln439"> </a>
<a name="ln440">	if (!(node.kind &amp; B_BUFFER_PRODUCER)) {</a>
<a name="ln441">		ERROR(&quot;BMediaRosterEx::GetAllOutputs: node %&quot; B_PRId32 &quot; is not a &quot;</a>
<a name="ln442">			&quot;B_BUFFER_PRODUCER\n&quot;, node.node);</a>
<a name="ln443">		return B_MEDIA_BAD_NODE;</a>
<a name="ln444">	}</a>
<a name="ln445"> </a>
<a name="ln446">	result = B_OK;</a>
<a name="ln447">	cookie = 0;</a>
<a name="ln448">	list-&gt;MakeEmpty();</a>
<a name="ln449">	for (;;) {</a>
<a name="ln450">		producer_get_next_output_request request;</a>
<a name="ln451">		producer_get_next_output_reply reply;</a>
<a name="ln452">		request.cookie = cookie;</a>
<a name="ln453">		rv = QueryPort(node.port, PRODUCER_GET_NEXT_OUTPUT, &amp;request,</a>
<a name="ln454">			sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln455">		if (rv != B_OK)</a>
<a name="ln456">			break;</a>
<a name="ln457">		cookie = reply.cookie;</a>
<a name="ln458">		if (!list-&gt;Insert(reply.output)) {</a>
<a name="ln459">			ERROR(&quot;GetAllOutputs: list-&gt;Insert failed\n&quot;);</a>
<a name="ln460">			result = B_ERROR;</a>
<a name="ln461">		}</a>
<a name="ln462">		#if DEBUG &gt;= 3</a>
<a name="ln463">			PRINT(3,&quot; next cookie %&quot; B_PRId32 &quot;, &quot;, cookie);</a>
<a name="ln464">			PRINT_OUTPUT(&quot;output &quot;, reply.output);</a>
<a name="ln465">		#endif</a>
<a name="ln466">	}</a>
<a name="ln467"> </a>
<a name="ln468">	producer_dispose_output_cookie_request request;</a>
<a name="ln469">	producer_dispose_output_cookie_reply reply;</a>
<a name="ln470">	QueryPort(node.port, PRODUCER_DISPOSE_OUTPUT_COOKIE, &amp;request,</a>
<a name="ln471">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln472"> </a>
<a name="ln473">	return result;</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476"> </a>
<a name="ln477">status_t</a>
<a name="ln478">BMediaRosterEx::GetAllOutputs(BBufferProducer* node, List&lt;media_output&gt;* list)</a>
<a name="ln479">{</a>
<a name="ln480">	int32 cookie;</a>
<a name="ln481">	status_t result;</a>
<a name="ln482"> </a>
<a name="ln483">	PRINT(4, &quot;BMediaRosterEx::GetAllOutputs() (by pointer) node %&quot; B_PRId32</a>
<a name="ln484">		&quot;, port %&quot; B_PRId32 &quot;\n&quot;, node-&gt;ID(), node-&gt;ControlPort());</a>
<a name="ln485"> </a>
<a name="ln486">	result = B_OK;</a>
<a name="ln487">	cookie = 0;</a>
<a name="ln488">	list-&gt;MakeEmpty();</a>
<a name="ln489">	for (;;) {</a>
<a name="ln490">		media_output output;</a>
<a name="ln491">		if (B_OK != node-&gt;GetNextOutput(&amp;cookie, &amp;output))</a>
<a name="ln492">			break;</a>
<a name="ln493">		if (!list-&gt;Insert(output)) {</a>
<a name="ln494">			ERROR(&quot;GetAllOutputs: list-&gt;Insert failed\n&quot;);</a>
<a name="ln495">			result = B_ERROR;</a>
<a name="ln496">		}</a>
<a name="ln497">		#if DEBUG &gt;= 3</a>
<a name="ln498">			PRINT(3,&quot; next cookie %&quot; B_PRId32 &quot;, &quot;, cookie);</a>
<a name="ln499">			PRINT_OUTPUT(&quot;output &quot;, output);</a>
<a name="ln500">		#endif</a>
<a name="ln501">	}</a>
<a name="ln502">	node-&gt;DisposeOutputCookie(cookie);</a>
<a name="ln503">	return result;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506"> </a>
<a name="ln507">status_t</a>
<a name="ln508">BMediaRosterEx::GetAllInputs(const media_node&amp; node, List&lt;media_input&gt;* list)</a>
<a name="ln509">{</a>
<a name="ln510">	int32 cookie;</a>
<a name="ln511">	status_t rv;</a>
<a name="ln512">	status_t result;</a>
<a name="ln513"> </a>
<a name="ln514">	PRINT(4, &quot;BMediaRosterEx::GetAllInputs() node %&quot; B_PRId32 &quot;, port %&quot;</a>
<a name="ln515">		B_PRId32 &quot;\n&quot;, node.node, node.port);</a>
<a name="ln516"> </a>
<a name="ln517">	if (!(node.kind &amp; B_BUFFER_CONSUMER)) {</a>
<a name="ln518">		ERROR(&quot;BMediaRosterEx::GetAllInputs: node %&quot; B_PRId32 &quot; is not a &quot;</a>
<a name="ln519">			&quot;B_BUFFER_CONSUMER\n&quot;, node.node);</a>
<a name="ln520">		return B_MEDIA_BAD_NODE;</a>
<a name="ln521">	}</a>
<a name="ln522"> </a>
<a name="ln523">	result = B_OK;</a>
<a name="ln524">	cookie = 0;</a>
<a name="ln525">	list-&gt;MakeEmpty();</a>
<a name="ln526">	for (;;) {</a>
<a name="ln527">		consumer_get_next_input_request request;</a>
<a name="ln528">		consumer_get_next_input_reply reply;</a>
<a name="ln529">		request.cookie = cookie;</a>
<a name="ln530">		rv = QueryPort(node.port, CONSUMER_GET_NEXT_INPUT, &amp;request,</a>
<a name="ln531">			sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln532">		if (rv != B_OK)</a>
<a name="ln533">			break;</a>
<a name="ln534">		cookie = reply.cookie;</a>
<a name="ln535">		if (!list-&gt;Insert(reply.input)) {</a>
<a name="ln536">			ERROR(&quot;GetAllInputs: list-&gt;Insert failed\n&quot;);</a>
<a name="ln537">			result = B_ERROR;</a>
<a name="ln538">		}</a>
<a name="ln539">		#if DEBUG &gt;= 3</a>
<a name="ln540">			PRINT(3,&quot; next cookie %&quot; B_PRId32 &quot;, &quot;, cookie);</a>
<a name="ln541">			PRINT_OUTPUT(&quot;input &quot;, reply.input);</a>
<a name="ln542">		#endif</a>
<a name="ln543">	}</a>
<a name="ln544"> </a>
<a name="ln545">	consumer_dispose_input_cookie_request request;</a>
<a name="ln546">	consumer_dispose_input_cookie_reply reply;</a>
<a name="ln547">	QueryPort(node.port, CONSUMER_DISPOSE_INPUT_COOKIE, &amp;request,</a>
<a name="ln548">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln549"> </a>
<a name="ln550">	return result;</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553"> </a>
<a name="ln554">status_t</a>
<a name="ln555">BMediaRosterEx::GetAllInputs(BBufferConsumer* node, List&lt;media_input&gt;* list)</a>
<a name="ln556">{</a>
<a name="ln557">	int32 cookie;</a>
<a name="ln558">	status_t result;</a>
<a name="ln559"> </a>
<a name="ln560">	PRINT(4, &quot;BMediaRosterEx::GetAllInputs() (by pointer) node %&quot; B_PRId32</a>
<a name="ln561">		&quot;, port %&quot; B_PRId32 &quot;\n&quot;, node-&gt;ID(), node-&gt;ControlPort());</a>
<a name="ln562"> </a>
<a name="ln563">	result = B_OK;</a>
<a name="ln564">	cookie = 0;</a>
<a name="ln565">	list-&gt;MakeEmpty();</a>
<a name="ln566">	for (;;) {</a>
<a name="ln567">		media_input input;</a>
<a name="ln568">		if (B_OK != node-&gt;GetNextInput(&amp;cookie, &amp;input))</a>
<a name="ln569">			break;</a>
<a name="ln570">		if (!list-&gt;Insert(input)) {</a>
<a name="ln571">			ERROR(&quot;GetAllInputs: list-&gt;Insert failed\n&quot;);</a>
<a name="ln572">			result = B_ERROR;</a>
<a name="ln573">		}</a>
<a name="ln574">		#if DEBUG &gt;= 3</a>
<a name="ln575">			PRINT(3,&quot; next cookie %&quot; B_PRId32 &quot;, &quot;, cookie);</a>
<a name="ln576">			PRINT_INPUT(&quot;input &quot;, input);</a>
<a name="ln577">		#endif</a>
<a name="ln578">	}</a>
<a name="ln579">	node-&gt;DisposeInputCookie(cookie);</a>
<a name="ln580">	return result;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">status_t</a>
<a name="ln585">BMediaRosterEx::PublishOutputs(const media_node&amp; node, List&lt;media_output&gt;* list)</a>
<a name="ln586">{</a>
<a name="ln587">	server_publish_outputs_request request;</a>
<a name="ln588">	server_publish_outputs_reply reply;</a>
<a name="ln589">	media_output* output;</a>
<a name="ln590">	media_output* outputs;</a>
<a name="ln591">	int32 count;</a>
<a name="ln592">	status_t rv;</a>
<a name="ln593"> </a>
<a name="ln594">	count = list-&gt;CountItems();</a>
<a name="ln595">	TRACE(&quot;PublishOutputs: publishing %&quot; B_PRId32 &quot;\n&quot;, count);</a>
<a name="ln596"> </a>
<a name="ln597">	request.node = node;</a>
<a name="ln598">	request.count = count;</a>
<a name="ln599">	if (count &gt; MAX_OUTPUTS) {</a>
<a name="ln600">		void *start_addr;</a>
<a name="ln601">		size_t size;</a>
<a name="ln602">		size = ROUND_UP_TO_PAGE(count * sizeof(media_output));</a>
<a name="ln603">		request.area = create_area(&quot;publish outputs&quot;, &amp;start_addr,</a>
<a name="ln604">			B_ANY_ADDRESS, size, B_NO_LOCK, B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln605">		if (request.area &lt; B_OK) {</a>
<a name="ln606">			ERROR(&quot;PublishOutputs: failed to create area, %#&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln607">				request.area);</a>
<a name="ln608">			return (status_t)request.area;</a>
<a name="ln609">		}</a>
<a name="ln610">		outputs = static_cast&lt;media_output *&gt;(start_addr);</a>
<a name="ln611">	} else {</a>
<a name="ln612">		request.area = -1;</a>
<a name="ln613">		outputs = request.outputs;</a>
<a name="ln614">	}</a>
<a name="ln615">	TRACE(&quot;PublishOutputs: area %&quot; B_PRId32 &quot;\n&quot;, request.area);</a>
<a name="ln616"> </a>
<a name="ln617">	int i;</a>
<a name="ln618">	for (i = 0, list-&gt;Rewind(); list-&gt;GetNext(&amp;output); i++) {</a>
<a name="ln619">		ASSERT(i &lt; count);</a>
<a name="ln620">		outputs[i] = *output;</a>
<a name="ln621">	}</a>
<a name="ln622"> </a>
<a name="ln623">	rv = QueryServer(SERVER_PUBLISH_OUTPUTS, &amp;request, sizeof(request),</a>
<a name="ln624">		&amp;reply, sizeof(reply));</a>
<a name="ln625"> </a>
<a name="ln626">	if (request.area != -1)</a>
<a name="ln627">		delete_area(request.area);</a>
<a name="ln628"> </a>
<a name="ln629">	return rv;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632"> </a>
<a name="ln633">status_t</a>
<a name="ln634">BMediaRosterEx::PublishInputs(const media_node&amp; node, List&lt;media_input&gt;* list)</a>
<a name="ln635">{</a>
<a name="ln636">	server_publish_inputs_request request;</a>
<a name="ln637">	server_publish_inputs_reply reply;</a>
<a name="ln638">	media_input* input;</a>
<a name="ln639">	media_input* inputs;</a>
<a name="ln640">	int32 count;</a>
<a name="ln641">	status_t rv;</a>
<a name="ln642"> </a>
<a name="ln643">	count = list-&gt;CountItems();</a>
<a name="ln644">	TRACE(&quot;PublishInputs: publishing %&quot; B_PRId32 &quot;\n&quot;, count);</a>
<a name="ln645"> </a>
<a name="ln646">	request.node = node;</a>
<a name="ln647">	request.count = count;</a>
<a name="ln648">	if (count &gt; MAX_INPUTS) {</a>
<a name="ln649">		void* start_addr;</a>
<a name="ln650">		size_t size;</a>
<a name="ln651">		size = ROUND_UP_TO_PAGE(count * sizeof(media_input));</a>
<a name="ln652">		request.area = create_area(&quot;publish inputs&quot;, &amp;start_addr,</a>
<a name="ln653">			B_ANY_ADDRESS, size, B_NO_LOCK, B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln654">		if (request.area &lt; B_OK) {</a>
<a name="ln655">			ERROR(&quot;PublishInputs: failed to create area, %#&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln656">				request.area);</a>
<a name="ln657">			return (status_t)request.area;</a>
<a name="ln658">		}</a>
<a name="ln659">		inputs = static_cast&lt;media_input *&gt;(start_addr);</a>
<a name="ln660">	} else {</a>
<a name="ln661">		request.area = -1;</a>
<a name="ln662">		inputs = request.inputs;</a>
<a name="ln663">	}</a>
<a name="ln664">	TRACE(&quot;PublishInputs: area %&quot; B_PRId32 &quot;\n&quot;, request.area);</a>
<a name="ln665"> </a>
<a name="ln666">	int i;</a>
<a name="ln667">	for (i = 0, list-&gt;Rewind(); list-&gt;GetNext(&amp;input); i++) {</a>
<a name="ln668">		ASSERT(i &lt; count);</a>
<a name="ln669">		inputs[i] = *input;</a>
<a name="ln670">	}</a>
<a name="ln671"> </a>
<a name="ln672">	rv = QueryServer(SERVER_PUBLISH_INPUTS, &amp;request, sizeof(request),</a>
<a name="ln673">		&amp;reply, sizeof(reply));</a>
<a name="ln674"> </a>
<a name="ln675">	if (request.area != -1)</a>
<a name="ln676">		delete_area(request.area);</a>
<a name="ln677"> </a>
<a name="ln678">	return rv;</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681"> </a>
<a name="ln682">BTimeSource*</a>
<a name="ln683">BMediaRosterEx::MakeTimeSourceObject(media_node_id timeSourceID)</a>
<a name="ln684">{</a>
<a name="ln685">	media_node clone;</a>
<a name="ln686">	status_t status = GetNodeFor(timeSourceID, &amp;clone);</a>
<a name="ln687">	if (status != B_OK) {</a>
<a name="ln688">		ERROR(&quot;BMediaRosterEx::MakeTimeSourceObject: GetNodeFor failed: %s\n&quot;,</a>
<a name="ln689">			strerror(status));</a>
<a name="ln690">		return NULL;</a>
<a name="ln691">	}</a>
<a name="ln692"> </a>
<a name="ln693">	BTimeSource* source = gTimeSourceObjectManager-&gt;GetTimeSource(clone);</a>
<a name="ln694">	if (source == NULL) {</a>
<a name="ln695">		ERROR(&quot;BMediaRosterEx::MakeTimeSourceObject: GetTimeSource failed\n&quot;);</a>
<a name="ln696">		return NULL;</a>
<a name="ln697">	}</a>
<a name="ln698"> </a>
<a name="ln699">	// TODO: release?</a>
<a name="ln700">	ReleaseNode(clone);</a>
<a name="ln701"> </a>
<a name="ln702">	return source;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">//	#pragma mark - public BMediaRoster</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">status_t</a>
<a name="ln710">BMediaRoster::GetVideoInput(media_node* _node)</a>
<a name="ln711">{</a>
<a name="ln712">	CALLED();</a>
<a name="ln713">	return MediaRosterEx(this)-&gt;GetNode(VIDEO_INPUT, _node);</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">status_t</a>
<a name="ln718">BMediaRoster::GetAudioInput(media_node* _node)</a>
<a name="ln719">{</a>
<a name="ln720">	CALLED();</a>
<a name="ln721">	return MediaRosterEx(this)-&gt;GetNode(AUDIO_INPUT, _node);</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724"> </a>
<a name="ln725">status_t</a>
<a name="ln726">BMediaRoster::GetVideoOutput(media_node* _node)</a>
<a name="ln727">{</a>
<a name="ln728">	CALLED();</a>
<a name="ln729">	return MediaRosterEx(this)-&gt;GetNode(VIDEO_OUTPUT, _node);</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732"> </a>
<a name="ln733">status_t</a>
<a name="ln734">BMediaRoster::GetAudioMixer(media_node* _node)</a>
<a name="ln735">{</a>
<a name="ln736">	CALLED();</a>
<a name="ln737">	return MediaRosterEx(this)-&gt;GetNode(AUDIO_MIXER, _node);</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">status_t</a>
<a name="ln742">BMediaRoster::GetAudioOutput(media_node* _node)</a>
<a name="ln743">{</a>
<a name="ln744">	CALLED();</a>
<a name="ln745">	return MediaRosterEx(this)-&gt;GetNode(AUDIO_OUTPUT, _node);</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748"> </a>
<a name="ln749">status_t</a>
<a name="ln750">BMediaRoster::GetAudioOutput(media_node* _node, int32* _inputID,</a>
<a name="ln751">	BString* _inputName)</a>
<a name="ln752">{</a>
<a name="ln753">	CALLED();</a>
<a name="ln754">	return MediaRosterEx(this)-&gt;GetNode(AUDIO_OUTPUT_EX, _node, _inputID,</a>
<a name="ln755">		_inputName);</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758"> </a>
<a name="ln759">status_t</a>
<a name="ln760">BMediaRoster::GetTimeSource(media_node* _node)</a>
<a name="ln761">{</a>
<a name="ln762">	CALLED();</a>
<a name="ln763">	status_t rv;</a>
<a name="ln764"> </a>
<a name="ln765">	// TODO: need to do this in a nicer way.</a>
<a name="ln766"> </a>
<a name="ln767">	rv = MediaRosterEx(this)-&gt;GetNode(TIME_SOURCE, _node);</a>
<a name="ln768">	if (rv != B_OK)</a>
<a name="ln769">		return rv;</a>
<a name="ln770"> </a>
<a name="ln771">	// We don't do reference counting for timesources, that's why we</a>
<a name="ln772">	// release the node immediately.</a>
<a name="ln773">	ReleaseNode(*_node);</a>
<a name="ln774"> </a>
<a name="ln775">	// we need to remember to not use this node with server side reference counting</a>
<a name="ln776">	_node-&gt;kind |= NODE_KIND_NO_REFCOUNTING;</a>
<a name="ln777">	return B_OK;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780"> </a>
<a name="ln781">status_t</a>
<a name="ln782">BMediaRoster::SetVideoInput(const media_node&amp; producer)</a>
<a name="ln783">{</a>
<a name="ln784">	CALLED();</a>
<a name="ln785">	return MediaRosterEx(this)-&gt;SetNode(VIDEO_INPUT, &amp;producer);</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">status_t</a>
<a name="ln790">BMediaRoster::SetVideoInput(const dormant_node_info&amp; producer)</a>
<a name="ln791">{</a>
<a name="ln792">	CALLED();</a>
<a name="ln793">	return MediaRosterEx(this)-&gt;SetNode(VIDEO_INPUT, NULL, &amp;producer);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796"> </a>
<a name="ln797">status_t</a>
<a name="ln798">BMediaRoster::SetAudioInput(const media_node&amp; producer)</a>
<a name="ln799">{</a>
<a name="ln800">	CALLED();</a>
<a name="ln801">	return MediaRosterEx(this)-&gt;SetNode(AUDIO_INPUT, &amp;producer);</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804"> </a>
<a name="ln805">status_t</a>
<a name="ln806">BMediaRoster::SetAudioInput(const dormant_node_info&amp; producer)</a>
<a name="ln807">{</a>
<a name="ln808">	CALLED();</a>
<a name="ln809">	return MediaRosterEx(this)-&gt;SetNode(AUDIO_INPUT, NULL, &amp;producer);</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813">status_t</a>
<a name="ln814">BMediaRoster::SetVideoOutput(const media_node&amp; consumer)</a>
<a name="ln815">{</a>
<a name="ln816">	CALLED();</a>
<a name="ln817">	return MediaRosterEx(this)-&gt;SetNode(VIDEO_OUTPUT, &amp;consumer);</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820"> </a>
<a name="ln821">status_t</a>
<a name="ln822">BMediaRoster::SetVideoOutput(const dormant_node_info&amp; consumer)</a>
<a name="ln823">{</a>
<a name="ln824">	CALLED();</a>
<a name="ln825">	return MediaRosterEx(this)-&gt;SetNode(VIDEO_OUTPUT, NULL, &amp;consumer);</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828"> </a>
<a name="ln829">status_t</a>
<a name="ln830">BMediaRoster::SetAudioOutput(const media_node&amp; consumer)</a>
<a name="ln831">{</a>
<a name="ln832">	CALLED();</a>
<a name="ln833">	return MediaRosterEx(this)-&gt;SetNode(AUDIO_OUTPUT, &amp;consumer);</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836"> </a>
<a name="ln837">status_t</a>
<a name="ln838">BMediaRoster::SetAudioOutput(const media_input&amp; input)</a>
<a name="ln839">{</a>
<a name="ln840">	CALLED();</a>
<a name="ln841">	return MediaRosterEx(this)-&gt;SetNode(AUDIO_OUTPUT, NULL, NULL, &amp;input);</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">status_t</a>
<a name="ln846">BMediaRoster::SetAudioOutput(const dormant_node_info&amp; consumer)</a>
<a name="ln847">{</a>
<a name="ln848">	CALLED();</a>
<a name="ln849">	return MediaRosterEx(this)-&gt;SetNode(AUDIO_OUTPUT, NULL, &amp;consumer);</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852"> </a>
<a name="ln853">status_t</a>
<a name="ln854">BMediaRoster::GetNodeFor(media_node_id node, media_node* clone)</a>
<a name="ln855">{</a>
<a name="ln856">	CALLED();</a>
<a name="ln857">	if (clone == NULL)</a>
<a name="ln858">		return B_BAD_VALUE;</a>
<a name="ln859">	if (IS_INVALID_NODEID(node))</a>
<a name="ln860">		return B_MEDIA_BAD_NODE;</a>
<a name="ln861"> </a>
<a name="ln862">	server_get_node_for_request request;</a>
<a name="ln863">	server_get_node_for_reply reply;</a>
<a name="ln864">	status_t rv;</a>
<a name="ln865"> </a>
<a name="ln866">	request.node_id = node;</a>
<a name="ln867">	request.team = BPrivate::current_team();</a>
<a name="ln868"> </a>
<a name="ln869">	rv = QueryServer(SERVER_GET_NODE_FOR, &amp;request, sizeof(request), &amp;reply,</a>
<a name="ln870">		sizeof(reply));</a>
<a name="ln871">	if (rv != B_OK)</a>
<a name="ln872">		return rv;</a>
<a name="ln873"> </a>
<a name="ln874">	*clone = reply.clone;</a>
<a name="ln875">	return B_OK;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878"> </a>
<a name="ln879">status_t</a>
<a name="ln880">BMediaRoster::GetSystemTimeSource(media_node* clone)</a>
<a name="ln881">{</a>
<a name="ln882">	CALLED();</a>
<a name="ln883">	status_t rv;</a>
<a name="ln884"> </a>
<a name="ln885">	// TODO: need to do this in a nicer way.</a>
<a name="ln886"> </a>
<a name="ln887">	rv = MediaRosterEx(this)-&gt;GetNode(SYSTEM_TIME_SOURCE, clone);</a>
<a name="ln888">	if (rv != B_OK)</a>
<a name="ln889">		return rv;</a>
<a name="ln890"> </a>
<a name="ln891">	// We don't do reference counting for timesources, that's why we</a>
<a name="ln892">	// release the node immediately.</a>
<a name="ln893">	ReleaseNode(*clone);</a>
<a name="ln894"> </a>
<a name="ln895">	// we need to remember to not use this node with server side reference</a>
<a name="ln896">	// counting</a>
<a name="ln897">	clone-&gt;kind |= NODE_KIND_NO_REFCOUNTING;</a>
<a name="ln898"> </a>
<a name="ln899">	return B_OK;</a>
<a name="ln900">}</a>
<a name="ln901"> </a>
<a name="ln902"> </a>
<a name="ln903">status_t</a>
<a name="ln904">BMediaRoster::ReleaseNode(const media_node&amp; node)</a>
<a name="ln905">{</a>
<a name="ln906">	CALLED();</a>
<a name="ln907">	if (IS_INVALID_NODE(node))</a>
<a name="ln908">		return B_MEDIA_BAD_NODE;</a>
<a name="ln909"> </a>
<a name="ln910">	if (node.kind &amp; NODE_KIND_NO_REFCOUNTING) {</a>
<a name="ln911">		TRACE(&quot;BMediaRoster::ReleaseNode, trying to release reference &quot;</a>
<a name="ln912">			&quot;counting disabled timesource, node %&quot; B_PRId32 &quot;, port %&quot; B_PRId32</a>
<a name="ln913">			&quot;, team %&quot; B_PRId32 &quot;\n&quot;, node.node, node.port,</a>
<a name="ln914">			BPrivate::current_team());</a>
<a name="ln915">		return B_OK;</a>
<a name="ln916">	}</a>
<a name="ln917"> </a>
<a name="ln918">	server_release_node_request request;</a>
<a name="ln919">	server_release_node_reply reply;</a>
<a name="ln920">	status_t rv;</a>
<a name="ln921"> </a>
<a name="ln922">	request.node = node;</a>
<a name="ln923">	request.team = BPrivate::current_team();</a>
<a name="ln924"> </a>
<a name="ln925">	TRACE(&quot;BMediaRoster::ReleaseNode, node %&quot; B_PRId32 &quot;, port %&quot; B_PRId32</a>
<a name="ln926">		&quot;, team %&quot; B_PRId32 &quot;\n&quot;, node.node, node.port,</a>
<a name="ln927">		BPrivate::current_team());</a>
<a name="ln928"> </a>
<a name="ln929">	rv = QueryServer(SERVER_RELEASE_NODE, &amp;request, sizeof(request), &amp;reply,</a>
<a name="ln930">		sizeof(reply));</a>
<a name="ln931">	if (rv != B_OK) {</a>
<a name="ln932">		ERROR(&quot;BMediaRoster::ReleaseNode FAILED, node %&quot; B_PRId32 &quot;, port %&quot;</a>
<a name="ln933">			B_PRId32 &quot;, team %&quot; B_PRId32 &quot;!\n&quot;, node.node, node.port,</a>
<a name="ln934">			BPrivate::current_team());</a>
<a name="ln935">	}</a>
<a name="ln936">	return rv;</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939"> </a>
<a name="ln940">BTimeSource*</a>
<a name="ln941">BMediaRoster::MakeTimeSourceFor(const media_node&amp; forNode)</a>
<a name="ln942">{</a>
<a name="ln943">	// MakeTimeSourceFor() returns a BTimeSource object</a>
<a name="ln944">	// corresponding to the specified node's time source.</a>
<a name="ln945"> </a>
<a name="ln946">	CALLED();</a>
<a name="ln947"> </a>
<a name="ln948">	if (IS_SYSTEM_TIMESOURCE(forNode)) {</a>
<a name="ln949">		// special handling for the system time source</a>
<a name="ln950">		TRACE(&quot;BMediaRoster::MakeTimeSourceFor, asked for system time &quot;</a>
<a name="ln951">			&quot;source\n&quot;);</a>
<a name="ln952">		return MediaRosterEx(this)-&gt;MakeTimeSourceObject(</a>
<a name="ln953">			NODE_SYSTEM_TIMESOURCE_ID);</a>
<a name="ln954">	}</a>
<a name="ln955"> </a>
<a name="ln956">	if (IS_INVALID_NODE(forNode)) {</a>
<a name="ln957">		ERROR(&quot;BMediaRoster::MakeTimeSourceFor: for_node invalid, node %&quot;</a>
<a name="ln958">			B_PRId32 &quot;, port %&quot; B_PRId32 &quot;, kinds 0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln959">			forNode.node, forNode.port, forNode.kind);</a>
<a name="ln960">		return NULL;</a>
<a name="ln961">	}</a>
<a name="ln962"> </a>
<a name="ln963">	TRACE(&quot;BMediaRoster::MakeTimeSourceFor: node %&quot; B_PRId32 &quot; enter\n&quot;,</a>
<a name="ln964">		forNode.node);</a>
<a name="ln965"> </a>
<a name="ln966">	node_get_timesource_request request;</a>
<a name="ln967">	node_get_timesource_reply reply;</a>
<a name="ln968">	BTimeSource *source;</a>
<a name="ln969">	status_t rv;</a>
<a name="ln970"> </a>
<a name="ln971">	// ask the node to get it's current timesource id</a>
<a name="ln972">	rv = QueryPort(forNode.port, NODE_GET_TIMESOURCE, &amp;request,</a>
<a name="ln973">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln974">	if (rv != B_OK) {</a>
<a name="ln975">		ERROR(&quot;BMediaRoster::MakeTimeSourceFor: request failed\n&quot;);</a>
<a name="ln976">		return NULL;</a>
<a name="ln977">	}</a>
<a name="ln978"> </a>
<a name="ln979">	source = MediaRosterEx(this)-&gt;MakeTimeSourceObject(reply.timesource_id);</a>
<a name="ln980"> </a>
<a name="ln981">	TRACE(&quot;BMediaRoster::MakeTimeSourceFor: node %&quot; B_PRId32 &quot; leave\n&quot;,</a>
<a name="ln982">		forNode.node);</a>
<a name="ln983"> </a>
<a name="ln984">	return source;</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987"> </a>
<a name="ln988">status_t</a>
<a name="ln989">BMediaRoster::Connect(const media_source&amp; from, const media_destination&amp; to,</a>
<a name="ln990">	media_format* _format, media_output* _output, media_input* _input)</a>
<a name="ln991">{</a>
<a name="ln992">	return BMediaRoster::Connect(from, to, _format, _output, _input, 0);</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995"> </a>
<a name="ln996">status_t</a>
<a name="ln997">BMediaRoster::Connect(const media_source&amp; from, const media_destination&amp; to,</a>
<a name="ln998">	media_format* io_format, media_output* out_output, media_input* out_input,</a>
<a name="ln999">	uint32 in_flags, void* _reserved)</a>
<a name="ln1000">{</a>
<a name="ln1001">	CALLED();</a>
<a name="ln1002">	if (io_format == NULL || out_output == NULL || out_input == NULL)</a>
<a name="ln1003">		return B_BAD_VALUE;</a>
<a name="ln1004">	if (IS_INVALID_SOURCE(from)) {</a>
<a name="ln1005">		ERROR(&quot;BMediaRoster::Connect: media_source invalid\n&quot;);</a>
<a name="ln1006">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1007">	}</a>
<a name="ln1008">	if (IS_INVALID_DESTINATION(to)) {</a>
<a name="ln1009">		ERROR(&quot;BMediaRoster::Connect: media_destination invalid\n&quot;);</a>
<a name="ln1010">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1011">	}</a>
<a name="ln1012"> </a>
<a name="ln1013">	status_t rv;</a>
<a name="ln1014"> </a>
<a name="ln1015">	// find the output and input nodes</a>
<a name="ln1016">	// TODO: isn't there a easier way?</a>
<a name="ln1017">	media_node sourcenode;</a>
<a name="ln1018">	media_node destnode;</a>
<a name="ln1019">	rv = GetNodeFor(NodeIDFor(from.port), &amp;sourcenode);</a>
<a name="ln1020">	if (rv != B_OK) {</a>
<a name="ln1021">		ERROR(&quot;BMediaRoster::Connect: Can't find source node for port %&quot;</a>
<a name="ln1022">			B_PRId32 &quot;\n&quot;, from.port);</a>
<a name="ln1023">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1024">	}</a>
<a name="ln1025">	ReleaseNode(sourcenode);</a>
<a name="ln1026">	rv = GetNodeFor(NodeIDFor(to.port), &amp;destnode);</a>
<a name="ln1027">	if (rv != B_OK) {</a>
<a name="ln1028">		ERROR(&quot;BMediaRoster::Connect: Can't find destination node for port &quot;</a>
<a name="ln1029">			&quot;%&quot; B_PRId32 &quot;\n&quot;, to.port);</a>
<a name="ln1030">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1031">	}</a>
<a name="ln1032">	ReleaseNode(destnode);</a>
<a name="ln1033"> </a>
<a name="ln1034">	if (!(sourcenode.kind &amp; B_BUFFER_PRODUCER)) {</a>
<a name="ln1035">		ERROR(&quot;BMediaRoster::Connect: source node %&quot; B_PRId32 &quot; is not a &quot;</a>
<a name="ln1036">			&quot;B_BUFFER_PRODUCER\n&quot;, sourcenode.node);</a>
<a name="ln1037">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1038">	}</a>
<a name="ln1039">	if (!(destnode.kind &amp; B_BUFFER_CONSUMER)) {</a>
<a name="ln1040">		ERROR(&quot;BMediaRoster::Connect: destination node %&quot; B_PRId32 &quot; is not a &quot;</a>
<a name="ln1041">			&quot;B_BUFFER_CONSUMER\n&quot;, destnode.node);</a>
<a name="ln1042">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1043">	}</a>
<a name="ln1044"> </a>
<a name="ln1045">	producer_format_proposal_request request1;</a>
<a name="ln1046">	producer_format_proposal_reply reply1;</a>
<a name="ln1047"> </a>
<a name="ln1048">	PRINT_FORMAT(&quot;BMediaRoster::Connect calling &quot;</a>
<a name="ln1049">		&quot;BBufferProducer::FormatProposal with format  &quot;, *io_format);</a>
<a name="ln1050"> </a>
<a name="ln1051">	// BBufferProducer::FormatProposal</a>
<a name="ln1052">	request1.output = from;</a>
<a name="ln1053">	request1.format = *io_format;</a>
<a name="ln1054">	rv = QueryPort(from.port, PRODUCER_FORMAT_PROPOSAL, &amp;request1,</a>
<a name="ln1055">		sizeof(request1), &amp;reply1, sizeof(reply1));</a>
<a name="ln1056">	if (rv != B_OK) {</a>
<a name="ln1057">		ERROR(&quot;BMediaRoster::Connect: aborted after &quot;</a>
<a name="ln1058">			&quot;BBufferProducer::FormatProposal, status = %#&quot; B_PRIx32 &quot;\n&quot;,rv);</a>
<a name="ln1059">		return rv;</a>
<a name="ln1060">	}</a>
<a name="ln1061">	// reply1.format now contains the format proposed by the producer</a>
<a name="ln1062"> </a>
<a name="ln1063">	consumer_accept_format_request request2;</a>
<a name="ln1064">	consumer_accept_format_reply reply2;</a>
<a name="ln1065"> </a>
<a name="ln1066">	PRINT_FORMAT(&quot;BMediaRoster::Connect calling &quot;</a>
<a name="ln1067">		&quot;BBufferConsumer::AcceptFormat with format    &quot;, reply1.format);</a>
<a name="ln1068"> </a>
<a name="ln1069">	// BBufferConsumer::AcceptFormat</a>
<a name="ln1070">	request2.dest = to;</a>
<a name="ln1071">	request2.format = reply1.format;</a>
<a name="ln1072">	rv = QueryPort(to.port, CONSUMER_ACCEPT_FORMAT, &amp;request2,</a>
<a name="ln1073">		sizeof(request2), &amp;reply2, sizeof(reply2));</a>
<a name="ln1074">	if (rv != B_OK) {</a>
<a name="ln1075">		ERROR(&quot;BMediaRoster::Connect: aborted after &quot;</a>
<a name="ln1076">			&quot;BBufferConsumer::AcceptFormat, status = %#&quot; B_PRIx32 &quot;\n&quot;,rv);</a>
<a name="ln1077">		return rv;</a>
<a name="ln1078">	}</a>
<a name="ln1079">	// reply2.format now contains the format accepted by the consumer</a>
<a name="ln1080"> </a>
<a name="ln1081">	// BBufferProducer::PrepareToConnect</a>
<a name="ln1082">	producer_prepare_to_connect_request request3;</a>
<a name="ln1083">	producer_prepare_to_connect_reply reply3;</a>
<a name="ln1084"> </a>
<a name="ln1085">	PRINT_FORMAT(&quot;BMediaRoster::Connect calling &quot;</a>
<a name="ln1086">		&quot;BBufferProducer::PrepareToConnect with format&quot;, reply2.format);</a>
<a name="ln1087"> </a>
<a name="ln1088">	request3.source = from;</a>
<a name="ln1089">	request3.destination = to;</a>
<a name="ln1090">	request3.format = reply2.format;</a>
<a name="ln1091">	strcpy(request3.name, &quot;XXX some default name&quot;); // TODO: fix this</a>
<a name="ln1092">	rv = QueryPort(from.port, PRODUCER_PREPARE_TO_CONNECT, &amp;request3,</a>
<a name="ln1093">		sizeof(request3), &amp;reply3, sizeof(reply3));</a>
<a name="ln1094">	if (rv != B_OK) {</a>
<a name="ln1095">		ERROR(&quot;BMediaRoster::Connect: aborted after &quot;</a>
<a name="ln1096">			&quot;BBufferProducer::PrepareToConnect, status = %#&quot; B_PRIx32 &quot;\n&quot;, rv);</a>
<a name="ln1097">		return rv;</a>
<a name="ln1098">	}</a>
<a name="ln1099">	// reply3.format is still our pretty media format</a>
<a name="ln1100">	// reply3.out_source the real source to be used for the connection</a>
<a name="ln1101">	// reply3.name the name BBufferConsumer::Connected will see in the</a>
<a name="ln1102">	// outInput-&gt;name argument</a>
<a name="ln1103"> </a>
<a name="ln1104">	// BBufferConsumer::Connected</a>
<a name="ln1105">	consumer_connected_request request4;</a>
<a name="ln1106">	consumer_connected_reply reply4;</a>
<a name="ln1107">	status_t con_status;</a>
<a name="ln1108"> </a>
<a name="ln1109">	PRINT_FORMAT(&quot;BMediaRoster::Connect calling BBufferConsumer::Connected() &quot;</a>
<a name="ln1110">		&quot;with format       &quot;, reply3.format);</a>
<a name="ln1111"> </a>
<a name="ln1112">	request4.input.node = destnode;</a>
<a name="ln1113">	request4.input.source = reply3.out_source;</a>
<a name="ln1114">	request4.input.destination = to;</a>
<a name="ln1115">	request4.input.format = reply3.format;</a>
<a name="ln1116">	strcpy(request4.input.name, reply3.name);</a>
<a name="ln1117"> </a>
<a name="ln1118">	con_status = QueryPort(to.port, CONSUMER_CONNECTED, &amp;request4,</a>
<a name="ln1119">		sizeof(request4), &amp;reply4, sizeof(reply4));</a>
<a name="ln1120">	if (con_status != B_OK) {</a>
<a name="ln1121">		ERROR(&quot;BMediaRoster::Connect: aborting after &quot;</a>
<a name="ln1122">			&quot;BBufferConsumer::Connected, status = %#&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln1123">			con_status);</a>
<a name="ln1124">		// we do NOT return here!</a>
<a name="ln1125">	}</a>
<a name="ln1126">	// con_status contains the status code to be supplied to</a>
<a name="ln1127">	// BBufferProducer::Connect's status argument</a>
<a name="ln1128">	// reply4.input contains the media_input that describes the connection</a>
<a name="ln1129">	// from the consumer point of view</a>
<a name="ln1130"> </a>
<a name="ln1131">	// BBufferProducer::Connect</a>
<a name="ln1132">	producer_connect_request request5;</a>
<a name="ln1133">	producer_connect_reply reply5;</a>
<a name="ln1134"> </a>
<a name="ln1135">	PRINT_FORMAT(&quot;BMediaRoster::Connect calling BBufferProducer::Connect with &quot;</a>
<a name="ln1136">		&quot;format         &quot;, reply4.input.format);</a>
<a name="ln1137"> </a>
<a name="ln1138">	request5.error = con_status;</a>
<a name="ln1139">	request5.source = reply3.out_source;</a>
<a name="ln1140">	request5.destination = reply4.input.destination;</a>
<a name="ln1141">	request5.format = reply4.input.format;</a>
<a name="ln1142">	strcpy(request5.name, reply4.input.name);</a>
<a name="ln1143">	rv = QueryPort(reply4.input.source.port, PRODUCER_CONNECT, &amp;request5,</a>
<a name="ln1144">		sizeof(request5), &amp;reply5, sizeof(reply5));</a>
<a name="ln1145">	if (con_status != B_OK) {</a>
<a name="ln1146">		ERROR(&quot;BMediaRoster::Connect: aborted\n&quot;);</a>
<a name="ln1147">		return con_status;</a>
<a name="ln1148">	}</a>
<a name="ln1149">	if (rv != B_OK) {</a>
<a name="ln1150">		ERROR(&quot;BMediaRoster::Connect: aborted after BBufferProducer::Connect()&quot;</a>
<a name="ln1151">			&quot;, status = %#&quot; B_PRIx32 &quot;\n&quot;, rv);</a>
<a name="ln1152">		return rv;</a>
<a name="ln1153">	}</a>
<a name="ln1154">	// reply5.name contains the name assigned to the connection by the producer</a>
<a name="ln1155"> </a>
<a name="ln1156">	// initilize connection info</a>
<a name="ln1157">	*io_format = reply4.input.format;</a>
<a name="ln1158">	*out_input = reply4.input;</a>
<a name="ln1159">	out_output-&gt;node = sourcenode;</a>
<a name="ln1160">	out_output-&gt;source = reply4.input.source;</a>
<a name="ln1161">	out_output-&gt;destination = reply4.input.destination;</a>
<a name="ln1162">	out_output-&gt;format = reply4.input.format;</a>
<a name="ln1163">	strcpy(out_output-&gt;name, reply5.name);</a>
<a name="ln1164"> </a>
<a name="ln1165">	// the connection is now made</a>
<a name="ln1166">	PRINT_FORMAT(&quot;   format&quot;, *io_format);</a>
<a name="ln1167">	PRINT_INPUT(&quot;   input&quot;, *out_input);</a>
<a name="ln1168">	PRINT_OUTPUT(&quot;   output&quot;, *out_output);</a>
<a name="ln1169"> </a>
<a name="ln1170">	// TODO: register connection with server</a>
<a name="ln1171">	// TODO: we should just send a notification, instead of republishing all</a>
<a name="ln1172">	// endpoints</a>
<a name="ln1173">	List&lt;media_output&gt; outlist;</a>
<a name="ln1174">	List&lt;media_input&gt; inlist;</a>
<a name="ln1175">	if (MediaRosterEx(this)-&gt;GetAllOutputs(out_output-&gt;node , &amp;outlist) == B_OK)</a>
<a name="ln1176">		MediaRosterEx(this)-&gt;PublishOutputs(out_output-&gt;node , &amp;outlist);</a>
<a name="ln1177">	if (MediaRosterEx(this)-&gt;GetAllInputs(out_input-&gt;node , &amp;inlist) == B_OK)</a>
<a name="ln1178">		MediaRosterEx(this)-&gt;PublishInputs(out_input-&gt;node, &amp;inlist);</a>
<a name="ln1179"> </a>
<a name="ln1180">	// TODO: if (mute) BBufferProducer::EnableOutput(false)</a>
<a name="ln1181">	if (in_flags &amp; B_CONNECT_MUTED) {</a>
<a name="ln1182">	}</a>
<a name="ln1183"> </a>
<a name="ln1184">	// send a notification</a>
<a name="ln1185">	BPrivate::media::notifications::ConnectionMade(*out_input, *out_output,</a>
<a name="ln1186">		*io_format);</a>
<a name="ln1187"> </a>
<a name="ln1188">	return B_OK;</a>
<a name="ln1189">};</a>
<a name="ln1190"> </a>
<a name="ln1191"> </a>
<a name="ln1192">status_t</a>
<a name="ln1193">BMediaRoster::Disconnect(media_node_id source_nodeid,</a>
<a name="ln1194">	const media_source&amp; source, media_node_id destination_nodeid,</a>
<a name="ln1195">	const media_destination&amp; destination)</a>
<a name="ln1196">{</a>
<a name="ln1197">	CALLED();</a>
<a name="ln1198">	if (IS_INVALID_NODEID(source_nodeid)) {</a>
<a name="ln1199">		ERROR(&quot;BMediaRoster::Disconnect: source media_node_id invalid\n&quot;);</a>
<a name="ln1200">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1201">	}</a>
<a name="ln1202">	if (IS_INVALID_NODEID(destination_nodeid)) {</a>
<a name="ln1203">		ERROR(&quot;BMediaRoster::Disconnect: destination media_node_id invalid\n&quot;);</a>
<a name="ln1204">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1205">	}</a>
<a name="ln1206">	if (IS_INVALID_SOURCE(source)) {</a>
<a name="ln1207">		ERROR(&quot;BMediaRoster::Disconnect: media_source invalid\n&quot;);</a>
<a name="ln1208">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1209">	}</a>
<a name="ln1210">	if (IS_INVALID_DESTINATION(destination)) {</a>
<a name="ln1211">		ERROR(&quot;BMediaRoster::Disconnect: media_destination invalid\n&quot;);</a>
<a name="ln1212">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1213">	}</a>
<a name="ln1214"> </a>
<a name="ln1215">	producer_disconnect_request request2;</a>
<a name="ln1216">	producer_disconnect_reply reply2;</a>
<a name="ln1217">	consumer_disconnected_request request1;</a>
<a name="ln1218">	consumer_disconnected_reply reply1;</a>
<a name="ln1219">	status_t rv1, rv2;</a>
<a name="ln1220"> </a>
<a name="ln1221">	// TODO: we should ask the server if this connection really exists</a>
<a name="ln1222"> </a>
<a name="ln1223">	request1.source = source;</a>
<a name="ln1224">	request1.destination = destination;</a>
<a name="ln1225">	request2.source = source;</a>
<a name="ln1226">	request2.destination = destination;</a>
<a name="ln1227"> </a>
<a name="ln1228">	rv1 = QueryPort(source.port, PRODUCER_DISCONNECT, &amp;request1,</a>
<a name="ln1229">		sizeof(request1), &amp;reply1, sizeof(reply1));</a>
<a name="ln1230">	rv2 = QueryPort(destination.port, CONSUMER_DISCONNECTED, &amp;request2,</a>
<a name="ln1231">		sizeof(request2), &amp;reply2, sizeof(reply2));</a>
<a name="ln1232"> </a>
<a name="ln1233">	// TODO: unregister connection with server</a>
<a name="ln1234">	// TODO: we should just send a notification, instead of republishing all</a>
<a name="ln1235">	// endpoints</a>
<a name="ln1236">	List&lt;media_output&gt; outlist;</a>
<a name="ln1237">	List&lt;media_input&gt; inlist;</a>
<a name="ln1238">	media_node sourcenode;</a>
<a name="ln1239">	media_node destnode;</a>
<a name="ln1240">	if (GetNodeFor(source_nodeid, &amp;sourcenode) == B_OK) {</a>
<a name="ln1241">		if (!(sourcenode.kind &amp; B_BUFFER_PRODUCER)) {</a>
<a name="ln1242">			ERROR(&quot;BMediaRoster::Disconnect: source_nodeid %&quot; B_PRId32</a>
<a name="ln1243">				&quot; is not a B_BUFFER_PRODUCER\n&quot;, source_nodeid);</a>
<a name="ln1244">		}</a>
<a name="ln1245">		if (MediaRosterEx(this)-&gt;GetAllOutputs(sourcenode , &amp;outlist) == B_OK)</a>
<a name="ln1246">			MediaRosterEx(this)-&gt;PublishOutputs(sourcenode , &amp;outlist);</a>
<a name="ln1247">		ReleaseNode(sourcenode);</a>
<a name="ln1248">	} else {</a>
<a name="ln1249">		ERROR(&quot;BMediaRoster::Disconnect: GetNodeFor source_nodeid %&quot; B_PRId32</a>
<a name="ln1250">			&quot; failed\n&quot;, source_nodeid);</a>
<a name="ln1251">	}</a>
<a name="ln1252">	if (GetNodeFor(destination_nodeid, &amp;destnode) == B_OK) {</a>
<a name="ln1253">		if (!(destnode.kind &amp; B_BUFFER_CONSUMER)) {</a>
<a name="ln1254">			ERROR(&quot;BMediaRoster::Disconnect: destination_nodeid %&quot; B_PRId32</a>
<a name="ln1255">				&quot; is not a B_BUFFER_CONSUMER\n&quot;, destination_nodeid);</a>
<a name="ln1256">		}</a>
<a name="ln1257">		if (MediaRosterEx(this)-&gt;GetAllInputs(destnode , &amp;inlist) == B_OK)</a>
<a name="ln1258">			MediaRosterEx(this)-&gt;PublishInputs(destnode, &amp;inlist);</a>
<a name="ln1259">		ReleaseNode(destnode);</a>
<a name="ln1260">	} else {</a>
<a name="ln1261">		ERROR(&quot;BMediaRoster::Disconnect: GetNodeFor destination_nodeid %&quot;</a>
<a name="ln1262">			B_PRId32 &quot; failed\n&quot;, destination_nodeid);</a>
<a name="ln1263">	}</a>
<a name="ln1264"> </a>
<a name="ln1265">	// send a notification</a>
<a name="ln1266">	BPrivate::media::notifications::ConnectionBroken(source, destination);</a>
<a name="ln1267"> </a>
<a name="ln1268">	return rv1 != B_OK || rv2 != B_OK ? B_ERROR : B_OK;</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271"> </a>
<a name="ln1272">status_t</a>
<a name="ln1273">BMediaRoster::Disconnect(const media_output&amp; output, const media_input&amp; input)</a>
<a name="ln1274">{</a>
<a name="ln1275">	if (IS_INVALID_NODEID(output.node.node)) {</a>
<a name="ln1276">		printf(&quot;BMediaRoster::Disconnect: output.node.node %&quot; B_PRId32</a>
<a name="ln1277">			&quot; invalid\n&quot;, output.node.node);</a>
<a name="ln1278">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1279">	}</a>
<a name="ln1280">	if (IS_INVALID_NODEID(input.node.node)) {</a>
<a name="ln1281">		printf(&quot;BMediaRoster::Disconnect: input.node.node %&quot; B_PRId32</a>
<a name="ln1282">			&quot; invalid\n&quot;, input.node.node);</a>
<a name="ln1283">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1284">	}</a>
<a name="ln1285">	if (!(output.node.kind &amp; B_BUFFER_PRODUCER)) {</a>
<a name="ln1286">		printf(&quot;BMediaRoster::Disconnect: output.node.kind 0x%&quot; B_PRIx32</a>
<a name="ln1287">			&quot; is no B_BUFFER_PRODUCER\n&quot;, output.node.kind);</a>
<a name="ln1288">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1289">	}</a>
<a name="ln1290">	if (!(input.node.kind &amp; B_BUFFER_CONSUMER)) {</a>
<a name="ln1291">		printf(&quot;BMediaRoster::Disconnect: input.node.kind 0x%&quot; B_PRIx32</a>
<a name="ln1292">			&quot; is no B_BUFFER_PRODUCER\n&quot;, input.node.kind);</a>
<a name="ln1293">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1294">	}</a>
<a name="ln1295">	if (input.source.port != output.source.port) {</a>
<a name="ln1296">		printf(&quot;BMediaRoster::Disconnect: input.source.port %&quot; B_PRId32</a>
<a name="ln1297">			&quot; doesn't match output.source.port %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln1298">			input.source.port, output.source.port);</a>
<a name="ln1299">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1300">	}</a>
<a name="ln1301">	if (input.source.id != output.source.id) {</a>
<a name="ln1302">		printf(&quot;BMediaRoster::Disconnect: input.source.id %&quot; B_PRId32</a>
<a name="ln1303">			&quot; doesn't match output.source.id %&quot; B_PRId32 &quot;\n&quot;, input.source.id,</a>
<a name="ln1304">			output.source.id);</a>
<a name="ln1305">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1306">	}</a>
<a name="ln1307">	if (input.destination.port != output.destination.port) {</a>
<a name="ln1308">		printf(&quot;BMediaRoster::Disconnect: input.destination.port %&quot; B_PRId32</a>
<a name="ln1309">			&quot; doesn't match output.destination.port %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln1310">			input.destination.port, output.destination.port);</a>
<a name="ln1311">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1312">	}</a>
<a name="ln1313">	if (input.destination.id != output.destination.id) {</a>
<a name="ln1314">		printf(&quot;BMediaRoster::Disconnect: input.destination.id %&quot; B_PRId32</a>
<a name="ln1315">			&quot; doesn't match output.destination.id %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln1316">			input.destination.id, output.destination.id);</a>
<a name="ln1317">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln1318">	}</a>
<a name="ln1319"> </a>
<a name="ln1320">	return Disconnect(output.node.node, output.source, input.node.node,</a>
<a name="ln1321">		input.destination);</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324"> </a>
<a name="ln1325">status_t</a>
<a name="ln1326">BMediaRoster::StartNode(const media_node&amp; node, bigtime_t atPerformanceTime)</a>
<a name="ln1327">{</a>
<a name="ln1328">	CALLED();</a>
<a name="ln1329">	if (node.node &lt;= 0)</a>
<a name="ln1330">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1331"> </a>
<a name="ln1332">	TRACE(&quot;BMediaRoster::StartNode, node %&quot; B_PRId32 &quot;, at perf %&quot; B_PRId64</a>
<a name="ln1333">		&quot;\n&quot;, node.node, atPerformanceTime);</a>
<a name="ln1334"> </a>
<a name="ln1335">	node_start_command command;</a>
<a name="ln1336">	command.performance_time = atPerformanceTime;</a>
<a name="ln1337"> </a>
<a name="ln1338">	return SendToPort(node.port, NODE_START, &amp;command, sizeof(command));</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341"> </a>
<a name="ln1342">status_t</a>
<a name="ln1343">BMediaRoster::StopNode(const media_node&amp; node, bigtime_t atPerformanceTime,</a>
<a name="ln1344">	bool immediate)</a>
<a name="ln1345">{</a>
<a name="ln1346">	CALLED();</a>
<a name="ln1347">	if (IS_INVALID_NODE(node))</a>
<a name="ln1348">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1349"> </a>
<a name="ln1350">	TRACE(&quot;BMediaRoster::StopNode, node %&quot; B_PRId32 &quot;, at perf %&quot; B_PRId64</a>
<a name="ln1351">		&quot; %s\n&quot;, node.node, atPerformanceTime, immediate ? &quot;NOW&quot; : &quot;&quot;);</a>
<a name="ln1352"> </a>
<a name="ln1353">	node_stop_command command;</a>
<a name="ln1354">	command.performance_time = atPerformanceTime;</a>
<a name="ln1355">	command.immediate = immediate;</a>
<a name="ln1356"> </a>
<a name="ln1357">	return SendToPort(node.port, NODE_STOP, &amp;command, sizeof(command));</a>
<a name="ln1358">}</a>
<a name="ln1359"> </a>
<a name="ln1360"> </a>
<a name="ln1361">status_t</a>
<a name="ln1362">BMediaRoster::SeekNode(const media_node&amp; node, bigtime_t toMediaTime,</a>
<a name="ln1363">	bigtime_t atPerformanceTime)</a>
<a name="ln1364">{</a>
<a name="ln1365">	CALLED();</a>
<a name="ln1366">	if (IS_INVALID_NODE(node))</a>
<a name="ln1367">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1368"> </a>
<a name="ln1369">	TRACE(&quot;BMediaRoster::SeekNode, node %&quot; B_PRId32 &quot;, at perf %&quot; B_PRId64</a>
<a name="ln1370">		&quot;, to perf %&quot; B_PRId64 &quot;\n&quot;, node.node, atPerformanceTime, toMediaTime);</a>
<a name="ln1371"> </a>
<a name="ln1372">	node_seek_command command;</a>
<a name="ln1373">	command.media_time = toMediaTime;</a>
<a name="ln1374">	command.performance_time = atPerformanceTime;</a>
<a name="ln1375"> </a>
<a name="ln1376">	return SendToPort(node.port, NODE_SEEK, &amp;command, sizeof(command));</a>
<a name="ln1377">}</a>
<a name="ln1378"> </a>
<a name="ln1379"> </a>
<a name="ln1380">status_t</a>
<a name="ln1381">BMediaRoster::StartTimeSource(const media_node&amp; node, bigtime_t atRealTime)</a>
<a name="ln1382">{</a>
<a name="ln1383">	CALLED();</a>
<a name="ln1384">	if (IS_SYSTEM_TIMESOURCE(node)) {</a>
<a name="ln1385">		// TODO: debug this</a>
<a name="ln1386">		//ERROR(&quot;BMediaRoster::StartTimeSource node %&quot; B_PRId32 &quot; is system timesource\n&quot;, node.node);</a>
<a name="ln1387">		return B_OK;</a>
<a name="ln1388">	}</a>
<a name="ln1389">//	if (IS_SHADOW_TIMESOURCE(node)) {</a>
<a name="ln1390">//		// TODO: debug this</a>
<a name="ln1391">//		ERROR(&quot;BMediaRoster::StartTimeSource node %&quot; B_PRId32 &quot; is shadow timesource\n&quot;, node.node);</a>
<a name="ln1392">//		return B_OK;</a>
<a name="ln1393">//	}</a>
<a name="ln1394">	if (IS_INVALID_NODE(node)) {</a>
<a name="ln1395">		ERROR(&quot;BMediaRoster::StartTimeSource node %&quot; B_PRId32 &quot; invalid\n&quot;,</a>
<a name="ln1396">			node.node);</a>
<a name="ln1397">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1398">	}</a>
<a name="ln1399">	if ((node.kind &amp; B_TIME_SOURCE) == 0) {</a>
<a name="ln1400">		ERROR(&quot;BMediaRoster::StartTimeSource node %&quot; B_PRId32</a>
<a name="ln1401">			&quot; is no timesource\n&quot;, node.node);</a>
<a name="ln1402">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1403">	}</a>
<a name="ln1404"> </a>
<a name="ln1405">	TRACE(&quot;BMediaRoster::StartTimeSource, node %&quot; B_PRId32 &quot;, at real %&quot;</a>
<a name="ln1406">		B_PRId64 &quot;\n&quot;, node.node, atRealTime);</a>
<a name="ln1407"> </a>
<a name="ln1408">	BTimeSource::time_source_op_info msg;</a>
<a name="ln1409">	msg.op = BTimeSource::B_TIMESOURCE_START;</a>
<a name="ln1410">	msg.real_time = atRealTime;</a>
<a name="ln1411"> </a>
<a name="ln1412">	return write_port(node.port, TIMESOURCE_OP, &amp;msg, sizeof(msg));</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415"> </a>
<a name="ln1416">status_t</a>
<a name="ln1417">BMediaRoster::StopTimeSource(const media_node&amp; node, bigtime_t atRealTime,</a>
<a name="ln1418">	bool immediate)</a>
<a name="ln1419">{</a>
<a name="ln1420">	CALLED();</a>
<a name="ln1421">	if (IS_SYSTEM_TIMESOURCE(node)) {</a>
<a name="ln1422">		// TODO: debug this</a>
<a name="ln1423">		//ERROR(&quot;BMediaRoster::StopTimeSource node %ld is system timesource\n&quot;, node.node);</a>
<a name="ln1424">		return B_OK;</a>
<a name="ln1425">	}</a>
<a name="ln1426">//	if (IS_SHADOW_TIMESOURCE(node)) {</a>
<a name="ln1427">//		// TODO: debug this</a>
<a name="ln1428">//		ERROR(&quot;BMediaRoster::StopTimeSource node %ld is shadow timesource\n&quot;, node.node);</a>
<a name="ln1429">//		return B_OK;</a>
<a name="ln1430">//	}</a>
<a name="ln1431">	if (IS_INVALID_NODE(node)) {</a>
<a name="ln1432">		ERROR(&quot;BMediaRoster::StopTimeSource node %&quot; B_PRId32 &quot; invalid\n&quot;,</a>
<a name="ln1433">			node.node);</a>
<a name="ln1434">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1435">	}</a>
<a name="ln1436">	if ((node.kind &amp; B_TIME_SOURCE) == 0) {</a>
<a name="ln1437">		ERROR(&quot;BMediaRoster::StopTimeSource node %&quot; B_PRId32 &quot; is no &quot;</a>
<a name="ln1438">			&quot;timesource\n&quot;, node.node);</a>
<a name="ln1439">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1440">	}</a>
<a name="ln1441"> </a>
<a name="ln1442">	TRACE(&quot;BMediaRoster::StopTimeSource, node %&quot; B_PRId32 &quot;, at real %&quot; B_PRId64</a>
<a name="ln1443">		&quot; %s\n&quot;, node.node, atRealTime, immediate ? &quot;NOW&quot; : &quot;&quot;);</a>
<a name="ln1444"> </a>
<a name="ln1445">	BTimeSource::time_source_op_info msg;</a>
<a name="ln1446">	msg.op = immediate ? BTimeSource::B_TIMESOURCE_STOP_IMMEDIATELY</a>
<a name="ln1447">		: BTimeSource::B_TIMESOURCE_STOP;</a>
<a name="ln1448">	msg.real_time = atRealTime;</a>
<a name="ln1449"> </a>
<a name="ln1450">	return write_port(node.port, TIMESOURCE_OP, &amp;msg, sizeof(msg));</a>
<a name="ln1451">}</a>
<a name="ln1452"> </a>
<a name="ln1453"> </a>
<a name="ln1454">status_t</a>
<a name="ln1455">BMediaRoster::SeekTimeSource(const media_node&amp; node,</a>
<a name="ln1456">	bigtime_t toPerformanceTime, bigtime_t atRealTime)</a>
<a name="ln1457">{</a>
<a name="ln1458">	CALLED();</a>
<a name="ln1459">	if (IS_SYSTEM_TIMESOURCE(node)) {</a>
<a name="ln1460">		// TODO: debug this</a>
<a name="ln1461">		// ERROR(&quot;BMediaRoster::SeekTimeSource node %ld is system timesource\n&quot;, node.node);</a>
<a name="ln1462">		// you can't seek the system time source, but</a>
<a name="ln1463">		// returning B_ERROR would break StampTV</a>
<a name="ln1464">		return B_OK;</a>
<a name="ln1465">	}</a>
<a name="ln1466">//	if (IS_SHADOW_TIMESOURCE(node)) {</a>
<a name="ln1467">//		// TODO: debug this</a>
<a name="ln1468">//		ERROR(&quot;BMediaRoster::SeekTimeSource node %ld is shadow timesource\n&quot;, node.node);</a>
<a name="ln1469">//		return B_OK;</a>
<a name="ln1470">//	}</a>
<a name="ln1471">	if (IS_INVALID_NODE(node)) {</a>
<a name="ln1472">		ERROR(&quot;BMediaRoster::SeekTimeSource node %&quot; B_PRId32 &quot; invalid\n&quot;,</a>
<a name="ln1473">			node.node);</a>
<a name="ln1474">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1475">	}</a>
<a name="ln1476">	if ((node.kind &amp; B_TIME_SOURCE) == 0) {</a>
<a name="ln1477">		ERROR(&quot;BMediaRoster::SeekTimeSource node %&quot; B_PRId32</a>
<a name="ln1478">			&quot; is no timesource\n&quot;, node.node);</a>
<a name="ln1479">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1480">	}</a>
<a name="ln1481"> </a>
<a name="ln1482">	TRACE(&quot;BMediaRoster::SeekTimeSource, node %&quot; B_PRId32 &quot;, at real %&quot; B_PRId64</a>
<a name="ln1483">		&quot;, to perf %&quot; B_PRId64 &quot;\n&quot;, node.node, atRealTime, toPerformanceTime);</a>
<a name="ln1484"> </a>
<a name="ln1485">	BTimeSource::time_source_op_info msg;</a>
<a name="ln1486">	msg.op = BTimeSource::B_TIMESOURCE_SEEK;</a>
<a name="ln1487">	msg.real_time = atRealTime;</a>
<a name="ln1488">	msg.performance_time = toPerformanceTime;</a>
<a name="ln1489"> </a>
<a name="ln1490">	return write_port(node.port, TIMESOURCE_OP, &amp;msg, sizeof(msg));</a>
<a name="ln1491">}</a>
<a name="ln1492"> </a>
<a name="ln1493"> </a>
<a name="ln1494">status_t</a>
<a name="ln1495">BMediaRoster::SyncToNode(const media_node&amp; node, bigtime_t atTime,</a>
<a name="ln1496">	bigtime_t timeout)</a>
<a name="ln1497">{</a>
<a name="ln1498">	TRACE(&quot;BMediaRoster::SyncToNode, node %&quot; B_PRId32 &quot;, at real %&quot; B_PRId64</a>
<a name="ln1499">		&quot;, at timeout %&quot; B_PRId64 &quot;\n&quot;, node.node, atTime, timeout);</a>
<a name="ln1500">	if (IS_INVALID_NODE(node))</a>
<a name="ln1501">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1502"> </a>
<a name="ln1503">	port_id waitPort = create_port(1, &quot;SyncToNode wait port&quot;);</a>
<a name="ln1504">	if (waitPort &lt; B_OK)</a>
<a name="ln1505">		return waitPort;</a>
<a name="ln1506"> </a>
<a name="ln1507">	node_sync_to_request request;</a>
<a name="ln1508">	node_sync_to_reply reply;</a>
<a name="ln1509">	request.performance_time = atTime;</a>
<a name="ln1510">	request.port = waitPort;</a>
<a name="ln1511"> </a>
<a name="ln1512">	status_t status = QueryPort(node.port, NODE_SYNC_TO, &amp;request,</a>
<a name="ln1513">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln1514"> </a>
<a name="ln1515">	if (status == B_OK) {</a>
<a name="ln1516">		ssize_t readSize = read_port_etc(waitPort, NULL, &amp;status,</a>
<a name="ln1517">			sizeof(status), B_TIMEOUT, timeout);</a>
<a name="ln1518">		if (readSize &lt; 0)</a>
<a name="ln1519">			status = readSize;</a>
<a name="ln1520">	}</a>
<a name="ln1521">	close_port(waitPort);</a>
<a name="ln1522">	delete_port(waitPort);</a>
<a name="ln1523">	return status;</a>
<a name="ln1524">}</a>
<a name="ln1525"> </a>
<a name="ln1526"> </a>
<a name="ln1527">status_t</a>
<a name="ln1528">BMediaRoster::SetRunModeNode(const media_node&amp; node, BMediaNode::run_mode mode)</a>
<a name="ln1529">{</a>
<a name="ln1530">	TRACE(&quot;BMediaRoster::SetRunModeNode, node %&quot; B_PRId32 &quot;, mode %d\n&quot;,</a>
<a name="ln1531">		node.node, mode);</a>
<a name="ln1532">	if (IS_INVALID_NODE(node))</a>
<a name="ln1533">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1534"> </a>
<a name="ln1535">	node_set_run_mode_command msg;</a>
<a name="ln1536">	msg.mode = mode;</a>
<a name="ln1537"> </a>
<a name="ln1538">	return write_port(node.port, NODE_SET_RUN_MODE, &amp;msg, sizeof(msg));</a>
<a name="ln1539">}</a>
<a name="ln1540"> </a>
<a name="ln1541"> </a>
<a name="ln1542">status_t</a>
<a name="ln1543">BMediaRoster::PrerollNode(const media_node&amp; node)</a>
<a name="ln1544">{</a>
<a name="ln1545">	CALLED();</a>
<a name="ln1546">	if (IS_INVALID_NODE(node))</a>
<a name="ln1547">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1548"> </a>
<a name="ln1549">	char dummy;</a>
<a name="ln1550">	return write_port(node.port, NODE_PREROLL, &amp;dummy, sizeof(dummy));</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553"> </a>
<a name="ln1554">status_t</a>
<a name="ln1555">BMediaRoster::RollNode(const media_node&amp; node, bigtime_t startPerformance,</a>
<a name="ln1556">	bigtime_t stopPerformance, bigtime_t atMediaTime)</a>
<a name="ln1557">{</a>
<a name="ln1558">	CALLED();</a>
<a name="ln1559">	if (IS_INVALID_NODE(node))</a>
<a name="ln1560">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1561"> </a>
<a name="ln1562">	TRACE(&quot;BMediaRoster::RollNode, node %&quot; B_PRId32 &quot;, at start perf %&quot;</a>
<a name="ln1563">		B_PRId64 &quot;, at stop perf %&quot; B_PRId64 &quot;, at media time %&quot;</a>
<a name="ln1564">		B_PRId64 &quot;\n&quot;, node.node, startPerformance,</a>
<a name="ln1565">		stopPerformance, atMediaTime);</a>
<a name="ln1566"> </a>
<a name="ln1567">	node_roll_command command;</a>
<a name="ln1568">	command.start_performance_time = startPerformance;</a>
<a name="ln1569">	command.stop_performance_time = stopPerformance;</a>
<a name="ln1570">	command.seek_media_time = atMediaTime;</a>
<a name="ln1571"> </a>
<a name="ln1572">	return write_port(node.port, NODE_ROLL, &amp;command, sizeof(command));</a>
<a name="ln1573">}</a>
<a name="ln1574"> </a>
<a name="ln1575"> </a>
<a name="ln1576">status_t</a>
<a name="ln1577">BMediaRoster::SetProducerRunModeDelay(const media_node&amp; node,</a>
<a name="ln1578">	bigtime_t delay, BMediaNode::run_mode mode)</a>
<a name="ln1579">{</a>
<a name="ln1580">	TRACE(&quot;BMediaRoster::SetProducerRunModeDelay, node %&quot; B_PRId32 &quot;, delay %&quot;</a>
<a name="ln1581">		B_PRId64 &quot;, mode %d\n&quot;, node.node, delay, mode);</a>
<a name="ln1582">	if (IS_INVALID_NODE(node))</a>
<a name="ln1583">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1584">	if ((node.kind &amp; B_BUFFER_PRODUCER) == 0)</a>
<a name="ln1585">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1586"> </a>
<a name="ln1587">	producer_set_run_mode_delay_command command;</a>
<a name="ln1588">	command.mode = mode;</a>
<a name="ln1589">	command.delay = delay;</a>
<a name="ln1590"> </a>
<a name="ln1591">	return SendToPort(node.port, PRODUCER_SET_RUN_MODE_DELAY, &amp;command,</a>
<a name="ln1592">		sizeof(command));</a>
<a name="ln1593">}</a>
<a name="ln1594"> </a>
<a name="ln1595"> </a>
<a name="ln1596">status_t</a>
<a name="ln1597">BMediaRoster::SetProducerRate(const media_node&amp; producer, int32 numer,</a>
<a name="ln1598">	int32 denom)</a>
<a name="ln1599">{</a>
<a name="ln1600">	CALLED();</a>
<a name="ln1601">	if (IS_INVALID_NODE(producer))</a>
<a name="ln1602">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1603">	if ((producer.kind &amp; B_BUFFER_PRODUCER) == 0)</a>
<a name="ln1604">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1605"> </a>
<a name="ln1606">	producer_set_play_rate_request request;</a>
<a name="ln1607">	request.numer = numer;</a>
<a name="ln1608">	request.denom = denom;</a>
<a name="ln1609">	status_t status = write_port(producer.node, PRODUCER_SET_PLAY_RATE,</a>
<a name="ln1610">		&amp;request, sizeof(request));</a>
<a name="ln1611">	if (status != B_OK)</a>
<a name="ln1612">		return status;</a>
<a name="ln1613"> </a>
<a name="ln1614">	producer_set_play_rate_reply reply;</a>
<a name="ln1615">	int32 code;</a>
<a name="ln1616">	status = read_port(request.reply_port, &amp;code, &amp;reply, sizeof(reply));</a>
<a name="ln1617"> </a>
<a name="ln1618">	return status &lt; B_OK ? status : reply.result;</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621"> </a>
<a name="ln1622">/*!	Nodes will have available inputs/outputs as long as they are capable</a>
<a name="ln1623">	of accepting more connections. The node may create an additional</a>
<a name="ln1624">	output or input as the currently available is taken into usage.</a>
<a name="ln1625">*/</a>
<a name="ln1626">status_t</a>
<a name="ln1627">BMediaRoster::GetLiveNodeInfo(const media_node&amp; node,</a>
<a name="ln1628">	live_node_info* out_live_info)</a>
<a name="ln1629">{</a>
<a name="ln1630">	CALLED();</a>
<a name="ln1631">	if (out_live_info == NULL)</a>
<a name="ln1632">		return B_BAD_VALUE;</a>
<a name="ln1633">	if (IS_INVALID_NODE(node))</a>
<a name="ln1634">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1635"> </a>
<a name="ln1636">	server_get_live_node_info_request request;</a>
<a name="ln1637">	server_get_live_node_info_reply reply;</a>
<a name="ln1638">	status_t rv;</a>
<a name="ln1639"> </a>
<a name="ln1640">	request.node = node;</a>
<a name="ln1641"> </a>
<a name="ln1642">	rv = QueryServer(SERVER_GET_LIVE_NODE_INFO, &amp;request, sizeof(request),</a>
<a name="ln1643">		&amp;reply, sizeof(reply));</a>
<a name="ln1644">	if (rv != B_OK)</a>
<a name="ln1645">		return rv;</a>
<a name="ln1646"> </a>
<a name="ln1647">	*out_live_info = reply.live_info;</a>
<a name="ln1648">	return B_OK;</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651"> </a>
<a name="ln1652">status_t</a>
<a name="ln1653">BMediaRoster::GetLiveNodes(live_node_info* liveNodes, int32* _totalCount,</a>
<a name="ln1654">	const media_format* hasInput, const media_format* hasOutput,</a>
<a name="ln1655">	const char* name, uint64 nodeKinds)</a>
<a name="ln1656">{</a>
<a name="ln1657">	CALLED();</a>
<a name="ln1658">	if (liveNodes == NULL || _totalCount == NULL || *_totalCount &lt;= 0)</a>
<a name="ln1659">		return B_BAD_VALUE;</a>
<a name="ln1660"> </a>
<a name="ln1661">	// TODO: we also support the wildcard search as GetDormantNodes does.</a>
<a name="ln1662">	// This needs to be documented</a>
<a name="ln1663"> </a>
<a name="ln1664">	server_get_live_nodes_request request;</a>
<a name="ln1665">	request.team = BPrivate::current_team();</a>
<a name="ln1666"> </a>
<a name="ln1667">	request.max_count = *_totalCount;</a>
<a name="ln1668">	request.has_input = hasInput != NULL;</a>
<a name="ln1669">	if (hasInput != NULL) {</a>
<a name="ln1670">		// TODO: we should not make a flat copy of media_format</a>
<a name="ln1671">		request.input_format = *hasInput;</a>
<a name="ln1672">	}</a>
<a name="ln1673">	request.has_output = hasOutput != NULL;</a>
<a name="ln1674">	if (hasOutput != NULL) {</a>
<a name="ln1675">		// TODO: we should not make a flat copy of media_format</a>
<a name="ln1676">		request.output_format = *hasOutput;</a>
<a name="ln1677">	}</a>
<a name="ln1678">	request.has_name = name != NULL;</a>
<a name="ln1679">	if (name != NULL)</a>
<a name="ln1680">		strlcpy(request.name, name, sizeof(request.name));</a>
<a name="ln1681">	request.require_kinds = nodeKinds;</a>
<a name="ln1682"> </a>
<a name="ln1683">	server_get_live_nodes_reply reply;</a>
<a name="ln1684">	status_t status = QueryServer(SERVER_GET_LIVE_NODES, &amp;request,</a>
<a name="ln1685">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln1686">	if (status != B_OK) {</a>
<a name="ln1687">		ERROR(&quot;BMediaRoster::GetLiveNodes failed querying server: %s\n&quot;,</a>
<a name="ln1688">			strerror(status));</a>
<a name="ln1689">		*_totalCount = 0;</a>
<a name="ln1690">		return status;</a>
<a name="ln1691">	}</a>
<a name="ln1692"> </a>
<a name="ln1693">	const live_node_info* info;</a>
<a name="ln1694">	if (reply.area &gt;= 0)</a>
<a name="ln1695">		info = (live_node_info*)reply.address;</a>
<a name="ln1696">	else</a>
<a name="ln1697">		info = reply.live_info;</a>
<a name="ln1698"> </a>
<a name="ln1699">	for (int32 i = 0; i &lt; reply.count; i++)</a>
<a name="ln1700">		liveNodes[i] = info[i];</a>
<a name="ln1701"> </a>
<a name="ln1702">	if (reply.area &gt;= 0)</a>
<a name="ln1703">		delete_area(reply.area);</a>
<a name="ln1704"> </a>
<a name="ln1705">	*_totalCount = reply.count;</a>
<a name="ln1706">	return B_OK;</a>
<a name="ln1707">}</a>
<a name="ln1708"> </a>
<a name="ln1709"> </a>
<a name="ln1710">status_t</a>
<a name="ln1711">BMediaRoster::GetFreeInputsFor(const media_node&amp; node,</a>
<a name="ln1712">	media_input * out_free_inputs, int32 buf_num_inputs,</a>
<a name="ln1713">	int32 * out_total_count, media_type filter_type)</a>
<a name="ln1714">{</a>
<a name="ln1715">	CALLED();</a>
<a name="ln1716">	if (IS_INVALID_NODE(node)) {</a>
<a name="ln1717">		ERROR(&quot;BMediaRoster::GetFreeInputsFor: node %&quot; B_PRId32 &quot;, port %&quot;</a>
<a name="ln1718">			B_PRId32 &quot; invalid\n&quot;, node.node, node.port);</a>
<a name="ln1719">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1720">	}</a>
<a name="ln1721">	if ((node.kind &amp; B_BUFFER_CONSUMER) == 0) {</a>
<a name="ln1722">		ERROR(&quot;BMediaRoster::GetFreeInputsFor: node %&quot; B_PRId32 &quot;, port %&quot;</a>
<a name="ln1723">			B_PRId32 &quot; is not a consumer\n&quot;, node.node, node.port);</a>
<a name="ln1724">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1725">	}</a>
<a name="ln1726">	if (out_free_inputs == NULL || out_total_count == NULL)</a>
<a name="ln1727">		return B_BAD_VALUE;</a>
<a name="ln1728"> </a>
<a name="ln1729">	List&lt;media_input&gt; list;</a>
<a name="ln1730">	media_input *input;</a>
<a name="ln1731">	status_t rv;</a>
<a name="ln1732"> </a>
<a name="ln1733">	*out_total_count = 0;</a>
<a name="ln1734"> </a>
<a name="ln1735">	rv = MediaRosterEx(this)-&gt;GetAllInputs(node, &amp;list);</a>
<a name="ln1736">	if (B_OK != rv)</a>
<a name="ln1737">		return rv;</a>
<a name="ln1738"> </a>
<a name="ln1739">	PRINT(4, &quot;BMediaRoster::GetFreeInputsFor node %&quot; B_PRId32 &quot;, max %&quot; B_PRId32</a>
<a name="ln1740">		&quot;, filter-type %&quot; B_PRId32 &quot;\n&quot;, node.node, buf_num_inputs,</a>
<a name="ln1741">		filter_type);</a>
<a name="ln1742"> </a>
<a name="ln1743">	int32 i;</a>
<a name="ln1744">	for (i = 0, list.Rewind(); list.GetNext(&amp;input);) {</a>
<a name="ln1745">		if (filter_type != B_MEDIA_UNKNOWN_TYPE</a>
<a name="ln1746">			&amp;&amp; filter_type != input-&gt;format.type) {</a>
<a name="ln1747">			// media_type used, but doesn't match</a>
<a name="ln1748">			continue;</a>
<a name="ln1749">		}</a>
<a name="ln1750">		if (input-&gt;source != media_source::null) {</a>
<a name="ln1751">			// consumer source already connected</a>
<a name="ln1752">			continue;</a>
<a name="ln1753">		}</a>
<a name="ln1754"> </a>
<a name="ln1755">		out_free_inputs[i] = *input;</a>
<a name="ln1756">		*out_total_count += 1;</a>
<a name="ln1757">		buf_num_inputs -= 1;</a>
<a name="ln1758">		#if DEBUG &gt;= 3</a>
<a name="ln1759">			PRINT_OUTPUT(&quot;  input&quot;, out_free_inputs[i]);</a>
<a name="ln1760">		#endif</a>
<a name="ln1761">		if (buf_num_inputs == 0)</a>
<a name="ln1762">			break;</a>
<a name="ln1763">		i++;</a>
<a name="ln1764">	}</a>
<a name="ln1765"> </a>
<a name="ln1766">	MediaRosterEx(this)-&gt;PublishInputs(node, &amp;list);</a>
<a name="ln1767">	return B_OK;</a>
<a name="ln1768">}</a>
<a name="ln1769"> </a>
<a name="ln1770"> </a>
<a name="ln1771">status_t</a>
<a name="ln1772">BMediaRoster::GetConnectedInputsFor(const media_node&amp; node,</a>
<a name="ln1773">	media_input* out_active_inputs, int32 buf_num_inputs,</a>
<a name="ln1774">	int32* out_total_count)</a>
<a name="ln1775">{</a>
<a name="ln1776">	CALLED();</a>
<a name="ln1777">	if (IS_INVALID_NODE(node) || (node.kind &amp; B_BUFFER_CONSUMER) == 0)</a>
<a name="ln1778">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1779">	if (out_active_inputs == NULL || out_total_count == NULL)</a>
<a name="ln1780">		return B_BAD_VALUE;</a>
<a name="ln1781"> </a>
<a name="ln1782">	List&lt;media_input&gt; list;</a>
<a name="ln1783">	media_input *input;</a>
<a name="ln1784">	status_t rv;</a>
<a name="ln1785"> </a>
<a name="ln1786">	*out_total_count = 0;</a>
<a name="ln1787"> </a>
<a name="ln1788">	rv = MediaRosterEx(this)-&gt;GetAllInputs(node, &amp;list);</a>
<a name="ln1789">	if (B_OK != rv)</a>
<a name="ln1790">		return rv;</a>
<a name="ln1791"> </a>
<a name="ln1792">	PRINT(4, &quot;BMediaRoster::GetConnectedInputsFor node %&quot; B_PRId32 &quot;, max %&quot;</a>
<a name="ln1793">		B_PRId32 &quot;\n&quot;, node.node, buf_num_inputs);</a>
<a name="ln1794"> </a>
<a name="ln1795">	int32 i;</a>
<a name="ln1796">	for (i = 0, list.Rewind(); list.GetNext(&amp;input);) {</a>
<a name="ln1797">		if (input-&gt;source == media_source::null)</a>
<a name="ln1798">			continue; // consumer source not connected</a>
<a name="ln1799">		out_active_inputs[i] = *input;</a>
<a name="ln1800">		*out_total_count += 1;</a>
<a name="ln1801">		buf_num_inputs -= 1;</a>
<a name="ln1802">		#if DEBUG &gt;= 3</a>
<a name="ln1803">			PRINT_OUTPUT(&quot;  input &quot;, out_active_inputs[i]);</a>
<a name="ln1804">		#endif</a>
<a name="ln1805">		if (buf_num_inputs == 0)</a>
<a name="ln1806">			break;</a>
<a name="ln1807">		i++;</a>
<a name="ln1808">	}</a>
<a name="ln1809"> </a>
<a name="ln1810">	MediaRosterEx(this)-&gt;PublishInputs(node, &amp;list);</a>
<a name="ln1811">	return B_OK;</a>
<a name="ln1812">}</a>
<a name="ln1813"> </a>
<a name="ln1814"> </a>
<a name="ln1815">status_t</a>
<a name="ln1816">BMediaRoster::GetAllInputsFor(const media_node&amp; node, media_input* out_inputs,</a>
<a name="ln1817">	int32 buf_num_inputs, int32* out_total_count)</a>
<a name="ln1818">{</a>
<a name="ln1819">	CALLED();</a>
<a name="ln1820">	if (IS_INVALID_NODE(node) || (node.kind &amp; B_BUFFER_CONSUMER) == 0)</a>
<a name="ln1821">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1822">	if (out_inputs == NULL || out_total_count == NULL)</a>
<a name="ln1823">		return B_BAD_VALUE;</a>
<a name="ln1824"> </a>
<a name="ln1825">	List&lt;media_input&gt; list;</a>
<a name="ln1826">	media_input *input;</a>
<a name="ln1827">	status_t rv;</a>
<a name="ln1828"> </a>
<a name="ln1829">	*out_total_count = 0;</a>
<a name="ln1830"> </a>
<a name="ln1831">	rv = MediaRosterEx(this)-&gt;GetAllInputs(node, &amp;list);</a>
<a name="ln1832">	if (B_OK != rv)</a>
<a name="ln1833">		return rv;</a>
<a name="ln1834"> </a>
<a name="ln1835">	PRINT(4, &quot;BMediaRoster::GetAllInputsFor node %&quot; B_PRId32 &quot;, max %&quot; B_PRId32</a>
<a name="ln1836">		&quot;\n&quot;, node.node, buf_num_inputs);</a>
<a name="ln1837"> </a>
<a name="ln1838">	int32 i;</a>
<a name="ln1839">	for (i = 0, list.Rewind(); list.GetNext(&amp;input); i++) {</a>
<a name="ln1840">		out_inputs[i] = *input;</a>
<a name="ln1841">		*out_total_count += 1;</a>
<a name="ln1842">		buf_num_inputs -= 1;</a>
<a name="ln1843">		#if DEBUG &gt;= 3</a>
<a name="ln1844">			PRINT_OUTPUT(&quot;  input &quot;, out_inputs[i]);</a>
<a name="ln1845">		#endif</a>
<a name="ln1846">		if (buf_num_inputs == 0)</a>
<a name="ln1847">			break;</a>
<a name="ln1848">	}</a>
<a name="ln1849"> </a>
<a name="ln1850">	MediaRosterEx(this)-&gt;PublishInputs(node, &amp;list);</a>
<a name="ln1851">	return B_OK;</a>
<a name="ln1852">}</a>
<a name="ln1853"> </a>
<a name="ln1854"> </a>
<a name="ln1855">status_t</a>
<a name="ln1856">BMediaRoster::GetFreeOutputsFor(const media_node&amp; node,</a>
<a name="ln1857">	media_output* out_free_outputs, int32 buf_num_outputs,</a>
<a name="ln1858">	int32* out_total_count, media_type filter_type)</a>
<a name="ln1859">{</a>
<a name="ln1860">	CALLED();</a>
<a name="ln1861">	if (IS_INVALID_NODE(node) || (node.kind &amp; B_BUFFER_PRODUCER) == 0)</a>
<a name="ln1862">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1863">	if (out_free_outputs == NULL || out_total_count == NULL)</a>
<a name="ln1864">		return B_BAD_VALUE;</a>
<a name="ln1865"> </a>
<a name="ln1866">	List&lt;media_output&gt; list;</a>
<a name="ln1867">	media_output *output;</a>
<a name="ln1868">	status_t rv;</a>
<a name="ln1869"> </a>
<a name="ln1870">	*out_total_count = 0;</a>
<a name="ln1871"> </a>
<a name="ln1872">	rv = MediaRosterEx(this)-&gt;GetAllOutputs(node, &amp;list);</a>
<a name="ln1873">	if (B_OK != rv)</a>
<a name="ln1874">		return rv;</a>
<a name="ln1875"> </a>
<a name="ln1876">	PRINT(4, &quot;BMediaRoster::GetFreeOutputsFor node %&quot; B_PRId32 &quot;, max %&quot;</a>
<a name="ln1877">		B_PRId32 &quot;, filter-type %&quot; B_PRId32 &quot;\n&quot;, node.node, buf_num_outputs,</a>
<a name="ln1878">		filter_type);</a>
<a name="ln1879"> </a>
<a name="ln1880">	int32 i;</a>
<a name="ln1881">	for (i = 0, list.Rewind(); list.GetNext(&amp;output);) {</a>
<a name="ln1882">		if (filter_type != B_MEDIA_UNKNOWN_TYPE</a>
<a name="ln1883">			&amp;&amp; filter_type != output-&gt;format.type) {</a>
<a name="ln1884">			// media_type used, but doesn't match</a>
<a name="ln1885">			continue;</a>
<a name="ln1886">		}</a>
<a name="ln1887">		if (output-&gt;destination != media_destination::null) {</a>
<a name="ln1888">			// producer destination already connected</a>
<a name="ln1889">			continue;</a>
<a name="ln1890">		}</a>
<a name="ln1891"> </a>
<a name="ln1892">		out_free_outputs[i] = *output;</a>
<a name="ln1893">		*out_total_count += 1;</a>
<a name="ln1894">		buf_num_outputs -= 1;</a>
<a name="ln1895">		#if DEBUG &gt;= 3</a>
<a name="ln1896">			PRINT_OUTPUT(&quot;  output &quot;, out_free_outputs[i]);</a>
<a name="ln1897">		#endif</a>
<a name="ln1898">		if (buf_num_outputs == 0)</a>
<a name="ln1899">			break;</a>
<a name="ln1900">		i++;</a>
<a name="ln1901">	}</a>
<a name="ln1902"> </a>
<a name="ln1903">	MediaRosterEx(this)-&gt;PublishOutputs(node, &amp;list);</a>
<a name="ln1904">	return B_OK;</a>
<a name="ln1905">}</a>
<a name="ln1906"> </a>
<a name="ln1907"> </a>
<a name="ln1908">status_t</a>
<a name="ln1909">BMediaRoster::GetConnectedOutputsFor(const media_node&amp; node,</a>
<a name="ln1910">	media_output* out_active_outputs, int32 buf_num_outputs,</a>
<a name="ln1911">	int32* out_total_count)</a>
<a name="ln1912">{</a>
<a name="ln1913">	CALLED();</a>
<a name="ln1914">	if (IS_INVALID_NODE(node) || (node.kind &amp; B_BUFFER_PRODUCER) == 0)</a>
<a name="ln1915">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1916">	if (out_active_outputs == NULL || out_total_count == NULL)</a>
<a name="ln1917">		return B_BAD_VALUE;</a>
<a name="ln1918"> </a>
<a name="ln1919">	List&lt;media_output&gt; list;</a>
<a name="ln1920">	media_output *output;</a>
<a name="ln1921">	status_t rv;</a>
<a name="ln1922"> </a>
<a name="ln1923">	*out_total_count = 0;</a>
<a name="ln1924"> </a>
<a name="ln1925">	rv = MediaRosterEx(this)-&gt;GetAllOutputs(node, &amp;list);</a>
<a name="ln1926">	if (B_OK != rv)</a>
<a name="ln1927">		return rv;</a>
<a name="ln1928"> </a>
<a name="ln1929">	PRINT(4, &quot;BMediaRoster::GetConnectedOutputsFor node %&quot; B_PRId32 &quot;, max %&quot;</a>
<a name="ln1930">		B_PRId32 &quot;\n&quot;, node.node, buf_num_outputs);</a>
<a name="ln1931"> </a>
<a name="ln1932">	int32 i;</a>
<a name="ln1933">	for (i = 0, list.Rewind(); list.GetNext(&amp;output);) {</a>
<a name="ln1934">		if (output-&gt;destination == media_destination::null) {</a>
<a name="ln1935">			// producer destination not connected</a>
<a name="ln1936">			continue;</a>
<a name="ln1937">		}</a>
<a name="ln1938">		out_active_outputs[i] = *output;</a>
<a name="ln1939">		*out_total_count += 1;</a>
<a name="ln1940">		buf_num_outputs -= 1;</a>
<a name="ln1941">		#if DEBUG &gt;= 3</a>
<a name="ln1942">			PRINT_OUTPUT(&quot;  output &quot;, out_active_outputs[i]);</a>
<a name="ln1943">		#endif</a>
<a name="ln1944">		if (buf_num_outputs == 0)</a>
<a name="ln1945">			break;</a>
<a name="ln1946">		i++;</a>
<a name="ln1947">	}</a>
<a name="ln1948"> </a>
<a name="ln1949">	MediaRosterEx(this)-&gt;PublishOutputs(node, &amp;list);</a>
<a name="ln1950">	return B_OK;</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953"> </a>
<a name="ln1954">status_t</a>
<a name="ln1955">BMediaRoster::GetAllOutputsFor(const media_node&amp; node,</a>
<a name="ln1956">	media_output* out_outputs, int32 buf_num_outputs, int32* out_total_count)</a>
<a name="ln1957">{</a>
<a name="ln1958">	CALLED();</a>
<a name="ln1959">	if (IS_INVALID_NODE(node) || (node.kind &amp; B_BUFFER_PRODUCER) == 0)</a>
<a name="ln1960">		return B_MEDIA_BAD_NODE;</a>
<a name="ln1961">	if (out_outputs == NULL || out_total_count == NULL)</a>
<a name="ln1962">		return B_BAD_VALUE;</a>
<a name="ln1963"> </a>
<a name="ln1964">	List&lt;media_output&gt; list;</a>
<a name="ln1965">	media_output *output;</a>
<a name="ln1966">	status_t rv;</a>
<a name="ln1967"> </a>
<a name="ln1968">	*out_total_count = 0;</a>
<a name="ln1969"> </a>
<a name="ln1970">	rv = MediaRosterEx(this)-&gt;GetAllOutputs(node, &amp;list);</a>
<a name="ln1971">	if (B_OK != rv)</a>
<a name="ln1972">		return rv;</a>
<a name="ln1973"> </a>
<a name="ln1974">	PRINT(4, &quot;BMediaRoster::GetAllOutputsFor node %&quot; B_PRId32 &quot;, max %&quot; B_PRId32</a>
<a name="ln1975">		&quot;\n&quot;, node.node, buf_num_outputs);</a>
<a name="ln1976"> </a>
<a name="ln1977">	int32 i;</a>
<a name="ln1978">	for (i = 0, list.Rewind(); list.GetNext(&amp;output); i++) {</a>
<a name="ln1979">		out_outputs[i] = *output;</a>
<a name="ln1980">		*out_total_count += 1;</a>
<a name="ln1981">		buf_num_outputs -= 1;</a>
<a name="ln1982">		#if DEBUG &gt;= 3</a>
<a name="ln1983">			PRINT_OUTPUT(&quot;  output &quot;, out_outputs[i]);</a>
<a name="ln1984">		#endif</a>
<a name="ln1985">		if (buf_num_outputs == 0)</a>
<a name="ln1986">			break;</a>
<a name="ln1987">	}</a>
<a name="ln1988"> </a>
<a name="ln1989">	MediaRosterEx(this)-&gt;PublishOutputs(node, &amp;list);</a>
<a name="ln1990">	return B_OK;</a>
<a name="ln1991">}</a>
<a name="ln1992"> </a>
<a name="ln1993"> </a>
<a name="ln1994">status_t</a>
<a name="ln1995">BMediaRoster::StartWatching(const BMessenger&amp; where)</a>
<a name="ln1996">{</a>
<a name="ln1997">	CALLED();</a>
<a name="ln1998">	if (!where.IsValid()) {</a>
<a name="ln1999">		ERROR(&quot;BMediaRoster::StartWatching: messenger invalid!\n&quot;);</a>
<a name="ln2000">		return B_BAD_VALUE;</a>
<a name="ln2001">	}</a>
<a name="ln2002">	return BPrivate::media::notifications::Register(where, media_node::null,</a>
<a name="ln2003">		B_MEDIA_WILDCARD);</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006"> </a>
<a name="ln2007">status_t</a>
<a name="ln2008">BMediaRoster::StartWatching(const BMessenger &amp; where, int32 notificationType)</a>
<a name="ln2009">{</a>
<a name="ln2010">	CALLED();</a>
<a name="ln2011">	if (!where.IsValid()) {</a>
<a name="ln2012">		ERROR(&quot;BMediaRoster::StartWatching: messenger invalid!\n&quot;);</a>
<a name="ln2013">		return B_BAD_VALUE;</a>
<a name="ln2014">	}</a>
<a name="ln2015">	if (!BPrivate::media::notifications::IsValidNotificationRequest(false,</a>
<a name="ln2016">			notificationType)) {</a>
<a name="ln2017">		ERROR(&quot;BMediaRoster::StartWatching: notificationType invalid!\n&quot;);</a>
<a name="ln2018">		return B_BAD_VALUE;</a>
<a name="ln2019">	}</a>
<a name="ln2020"> </a>
<a name="ln2021">	// NOTE: we support only explicitly B_MEDIA_SERVER_STARTED/QUIT</a>
<a name="ln2022">	// notifications. This should be cleared in documentation.</a>
<a name="ln2023"> </a>
<a name="ln2024">	return BPrivate::media::notifications::Register(where, media_node::null,</a>
<a name="ln2025">		notificationType);</a>
<a name="ln2026">}</a>
<a name="ln2027"> </a>
<a name="ln2028"> </a>
<a name="ln2029">status_t</a>
<a name="ln2030">BMediaRoster::StartWatching(const BMessenger&amp; where, const media_node&amp; node,</a>
<a name="ln2031">	int32 notificationType)</a>
<a name="ln2032">{</a>
<a name="ln2033">	CALLED();</a>
<a name="ln2034">	if (!where.IsValid()) {</a>
<a name="ln2035">		ERROR(&quot;BMediaRoster::StartWatching: messenger invalid!\n&quot;);</a>
<a name="ln2036">		return B_BAD_VALUE;</a>
<a name="ln2037">	}</a>
<a name="ln2038">	if (IS_INVALID_NODE(node)) {</a>
<a name="ln2039">		ERROR(&quot;BMediaRoster::StartWatching: node invalid!\n&quot;);</a>
<a name="ln2040">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2041">	}</a>
<a name="ln2042">	if (!BPrivate::media::notifications::IsValidNotificationRequest(true,</a>
<a name="ln2043">			notificationType)) {</a>
<a name="ln2044">		ERROR(&quot;BMediaRoster::StartWatching: notificationType invalid!\n&quot;);</a>
<a name="ln2045">		return B_BAD_VALUE;</a>
<a name="ln2046">	}</a>
<a name="ln2047">	return BPrivate::media::notifications::Register(where, node,</a>
<a name="ln2048">		notificationType);</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051"> </a>
<a name="ln2052">status_t</a>
<a name="ln2053">BMediaRoster::StopWatching(const BMessenger&amp; where)</a>
<a name="ln2054">{</a>
<a name="ln2055">	CALLED();</a>
<a name="ln2056">	// messenger may already be invalid, so we don't check this</a>
<a name="ln2057">	return BPrivate::media::notifications::Unregister(where, media_node::null,</a>
<a name="ln2058">		B_MEDIA_WILDCARD);</a>
<a name="ln2059">}</a>
<a name="ln2060"> </a>
<a name="ln2061"> </a>
<a name="ln2062">status_t</a>
<a name="ln2063">BMediaRoster::StopWatching(const BMessenger&amp; where, int32 notificationType)</a>
<a name="ln2064">{</a>
<a name="ln2065">	CALLED();</a>
<a name="ln2066">	// messenger may already be invalid, so we don't check this</a>
<a name="ln2067">	if (!BPrivate::media::notifications::IsValidNotificationRequest(false,</a>
<a name="ln2068">			notificationType)) {</a>
<a name="ln2069">		ERROR(&quot;BMediaRoster::StopWatching: notificationType invalid!\n&quot;);</a>
<a name="ln2070">		return B_BAD_VALUE;</a>
<a name="ln2071">	}</a>
<a name="ln2072">	return BPrivate::media::notifications::Unregister(where, media_node::null,</a>
<a name="ln2073">		notificationType);</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076"> </a>
<a name="ln2077">status_t</a>
<a name="ln2078">BMediaRoster::StopWatching(const BMessenger&amp; where, const media_node&amp; node,</a>
<a name="ln2079">	int32 notificationType)</a>
<a name="ln2080">{</a>
<a name="ln2081">	CALLED();</a>
<a name="ln2082">	// messenger may already be invalid, so we don't check this</a>
<a name="ln2083">	if (IS_INVALID_NODE(node)) {</a>
<a name="ln2084">		ERROR(&quot;BMediaRoster::StopWatching: node invalid!\n&quot;);</a>
<a name="ln2085">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2086">	}</a>
<a name="ln2087">	if (!BPrivate::media::notifications::IsValidNotificationRequest(true,</a>
<a name="ln2088">			notificationType)) {</a>
<a name="ln2089">		ERROR(&quot;BMediaRoster::StopWatching: notificationType invalid!\n&quot;);</a>
<a name="ln2090">		return B_BAD_VALUE;</a>
<a name="ln2091">	}</a>
<a name="ln2092">	return BPrivate::media::notifications::Unregister(where, node,</a>
<a name="ln2093">		notificationType);</a>
<a name="ln2094">}</a>
<a name="ln2095"> </a>
<a name="ln2096"> </a>
<a name="ln2097">status_t</a>
<a name="ln2098">BMediaRoster::RegisterNode(BMediaNode* node)</a>
<a name="ln2099">{</a>
<a name="ln2100">	CALLED();</a>
<a name="ln2101">	// addon-id = -1 (unused), addon-flavor-id = 0 (unused, too)</a>
<a name="ln2102">	return MediaRosterEx(this)-&gt;RegisterNode(node, -1, 0);</a>
<a name="ln2103">}</a>
<a name="ln2104"> </a>
<a name="ln2105"> </a>
<a name="ln2106">status_t</a>
<a name="ln2107">BMediaRosterEx::RegisterNode(BMediaNode* node, media_addon_id addOnID,</a>
<a name="ln2108">	int32 flavorID)</a>
<a name="ln2109">{</a>
<a name="ln2110">	CALLED();</a>
<a name="ln2111">	if (node == NULL)</a>
<a name="ln2112">		return B_BAD_VALUE;</a>
<a name="ln2113"> </a>
<a name="ln2114">	// some sanity check</a>
<a name="ln2115">	// I'm not sure if the media kit warrants to call BMediaNode::AddOn() here.</a>
<a name="ln2116">	// Perhaps we don't need it.</a>
<a name="ln2117">	DEBUG_ONLY(</a>
<a name="ln2118">		int32 testFlavorID;</a>
<a name="ln2119">		BMediaAddOn* addon = node-&gt;AddOn(&amp;testFlavorID);</a>
<a name="ln2120"> </a>
<a name="ln2121">		ASSERT(addOnID == (addon != NULL ? addon-&gt;AddonID() : -1));</a>
<a name="ln2122">//		ASSERT(flavorID == testFlavorID);</a>
<a name="ln2123">	);</a>
<a name="ln2124"> </a>
<a name="ln2125">	server_register_node_request request;</a>
<a name="ln2126">	server_register_node_reply reply;</a>
<a name="ln2127"> </a>
<a name="ln2128">	request.add_on_id = addOnID;</a>
<a name="ln2129">	request.flavor_id = flavorID;</a>
<a name="ln2130">	strcpy(request.name, node-&gt;Name());</a>
<a name="ln2131">	request.kinds = node-&gt;Kinds();</a>
<a name="ln2132">	request.port = node-&gt;ControlPort();</a>
<a name="ln2133">	request.team = BPrivate::current_team();</a>
<a name="ln2134">	request.timesource_id = node-&gt;fTimeSourceID;</a>
<a name="ln2135"> </a>
<a name="ln2136">	TRACE(&quot;BMediaRoster::RegisterNode: sending SERVER_REGISTER_NODE: port &quot;</a>
<a name="ln2137">		&quot;%&quot; B_PRId32 &quot;, kinds 0x%&quot; B_PRIx64 &quot;, team %&quot; B_PRId32 &quot;, name '%s'\n&quot;,</a>
<a name="ln2138">		request.port, request.kinds, request.team, request.name);</a>
<a name="ln2139"> </a>
<a name="ln2140">	status_t status = QueryServer(SERVER_REGISTER_NODE, &amp;request,</a>
<a name="ln2141">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2142">	if (status != B_OK) {</a>
<a name="ln2143">		ERROR(&quot;BMediaRoster::RegisterNode: failed to register node %s: %s\n&quot;,</a>
<a name="ln2144">			node-&gt;Name(), strerror(status));</a>
<a name="ln2145">		return status;</a>
<a name="ln2146">	}</a>
<a name="ln2147"> </a>
<a name="ln2148">	TRACE(&quot;BMediaRoster::RegisterNode: QueryServer SERVER_REGISTER_NODE &quot;</a>
<a name="ln2149">		&quot;finished\n&quot;);</a>
<a name="ln2150"> </a>
<a name="ln2151">	// we are a friend class of BMediaNode and initialize this member variable</a>
<a name="ln2152">	node-&gt;fNodeID = reply.node_id;</a>
<a name="ln2153">	ASSERT(reply.node_id == node-&gt;Node().node);</a>
<a name="ln2154">	ASSERT(reply.node_id == node-&gt;ID());</a>
<a name="ln2155"> </a>
<a name="ln2156">	// if the BMediaNode also inherits from BTimeSource, we need to call</a>
<a name="ln2157">	// BTimeSource::FinishCreate()</a>
<a name="ln2158">	if ((node-&gt;Kinds() &amp; B_TIME_SOURCE) != 0) {</a>
<a name="ln2159">		if (BTimeSource* timeSource = dynamic_cast&lt;BTimeSource*&gt;(node))</a>
<a name="ln2160">			timeSource-&gt;FinishCreate();</a>
<a name="ln2161">	}</a>
<a name="ln2162"> </a>
<a name="ln2163">	// call the callback</a>
<a name="ln2164">	node-&gt;NodeRegistered();</a>
<a name="ln2165"> </a>
<a name="ln2166">	TRACE(&quot;BMediaRoster::RegisterNode: NodeRegistered callback finished\n&quot;);</a>
<a name="ln2167"> </a>
<a name="ln2168">	TRACE(&quot;BMediaRoster::RegisterNode: publishing inputs/outputs\n&quot;);</a>
<a name="ln2169"> </a>
<a name="ln2170">	// register existing inputs and outputs with the</a>
<a name="ln2171">	// media_server, this allows GetLiveNodes() to work</a>
<a name="ln2172">	// with created, but unconnected nodes.</a>
<a name="ln2173">	// The node control loop might not be running, or might deadlock</a>
<a name="ln2174">	// if we send a message and wait for a reply here.</a>
<a name="ln2175">	// We have a pointer to the node, and thus call the functions directly</a>
<a name="ln2176"> </a>
<a name="ln2177">	if ((node-&gt;Kinds() &amp; B_BUFFER_PRODUCER) != 0) {</a>
<a name="ln2178">		if (BBufferProducer* producer = dynamic_cast&lt;BBufferProducer*&gt;(node)) {</a>
<a name="ln2179">			List&lt;media_output&gt; list;</a>
<a name="ln2180">			if (GetAllOutputs(producer, &amp;list) == B_OK)</a>
<a name="ln2181">				PublishOutputs(node-&gt;Node(), &amp;list);</a>
<a name="ln2182">		}</a>
<a name="ln2183">	}</a>
<a name="ln2184">	if ((node-&gt;Kinds() &amp; B_BUFFER_CONSUMER) != 0) {</a>
<a name="ln2185">		if (BBufferConsumer* consumer = dynamic_cast&lt;BBufferConsumer*&gt;(node)) {</a>
<a name="ln2186">			List&lt;media_input&gt; list;</a>
<a name="ln2187">			if (GetAllInputs(consumer, &amp;list) == B_OK)</a>
<a name="ln2188">				PublishInputs(node-&gt;Node(), &amp;list);</a>
<a name="ln2189">		}</a>
<a name="ln2190">	}</a>
<a name="ln2191"> </a>
<a name="ln2192">	TRACE(&quot;BMediaRoster::RegisterNode: sending NodesCreated\n&quot;);</a>
<a name="ln2193"> </a>
<a name="ln2194">	BPrivate::media::notifications::NodesCreated(&amp;reply.node_id, 1);</a>
<a name="ln2195"> </a>
<a name="ln2196">	TRACE(&quot;BMediaRoster::RegisterNode: finished\n&quot;);</a>
<a name="ln2197"> </a>
<a name="ln2198">/*</a>
<a name="ln2199">	TRACE(&quot;BMediaRoster::RegisterNode: registered node name '%s', id %ld,</a>
<a name="ln2200">		addon %ld, flavor %ld\n&quot;, node-&gt;Name(), node-&gt;ID(), addOnID, flavorID);</a>
<a name="ln2201">	TRACE(&quot;BMediaRoster::RegisterNode: node this               %p\n&quot;, node);</a>
<a name="ln2202">	TRACE(&quot;BMediaRoster::RegisterNode: node fConsumerThis      %p\n&quot;,</a>
<a name="ln2203">		node-&gt;fConsumerThis);</a>
<a name="ln2204">	TRACE(&quot;BMediaRoster::RegisterNode: node fProducerThis      %p\n&quot;,</a>
<a name="ln2205">		node-&gt;fProducerThis);</a>
<a name="ln2206">	TRACE(&quot;BMediaRoster::RegisterNode: node fFileInterfaceThis %p\n&quot;,</a>
<a name="ln2207">		node-&gt;fFileInterfaceThis);</a>
<a name="ln2208">	TRACE(&quot;BMediaRoster::RegisterNode: node fControllableThis  %p\n&quot;,</a>
<a name="ln2209">		node-&gt;fControllableThis);</a>
<a name="ln2210">	TRACE(&quot;BMediaRoster::RegisterNode: node fTimeSourceThis    %p\n&quot;,</a>
<a name="ln2211">		node-&gt;fTimeSourceThis);</a>
<a name="ln2212">*/</a>
<a name="ln2213">	return B_OK;</a>
<a name="ln2214">}</a>
<a name="ln2215"> </a>
<a name="ln2216"> </a>
<a name="ln2217">status_t</a>
<a name="ln2218">BMediaRoster::UnregisterNode(BMediaNode* node)</a>
<a name="ln2219">{</a>
<a name="ln2220">	CALLED();</a>
<a name="ln2221">	if (node == NULL)</a>
<a name="ln2222">		return B_BAD_VALUE;</a>
<a name="ln2223"> </a>
<a name="ln2224">	TRACE(&quot;BMediaRoster::UnregisterNode %&quot;</a>
<a name="ln2225">		B_PRId32 &quot; (%p)\n&quot;, node-&gt;ID(), node);</a>
<a name="ln2226"> </a>
<a name="ln2227">	if ((node-&gt;fKinds &amp; NODE_KIND_NO_REFCOUNTING) !=0) {</a>
<a name="ln2228">		TRACE(&quot;BMediaRoster::UnregisterNode, trying to unregister reference &quot;</a>
<a name="ln2229">			&quot;counting disabled timesource, node %&quot;</a>
<a name="ln2230">			B_PRId32 &quot; , port %&quot; B_PRId32 &quot; , team %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln2231">			node-&gt;ID(), node-&gt;ControlPort(), BPrivate::current_team());</a>
<a name="ln2232">		return B_OK;</a>
<a name="ln2233">	}</a>
<a name="ln2234">	if (node-&gt;ID() == NODE_UNREGISTERED_ID) {</a>
<a name="ln2235">		PRINT(1, &quot;Warning: BMediaRoster::UnregisterNode: node id %ld, name &quot;</a>
<a name="ln2236">			&quot;'%s' already unregistered\n&quot;, node-&gt;ID(), node-&gt;Name());</a>
<a name="ln2237">		return B_OK;</a>
<a name="ln2238">	}</a>
<a name="ln2239">	if (node-&gt;fRefCount != 0) {</a>
<a name="ln2240">		PRINT(1, &quot;Warning: BMediaRoster::UnregisterNode: node id %ld, name &quot;</a>
<a name="ln2241">			&quot;'%s' has local reference count of %ld\n&quot;, node-&gt;ID(), node-&gt;Name(),</a>
<a name="ln2242">			node-&gt;fRefCount);</a>
<a name="ln2243">		// no return here, we continue and unregister!</a>
<a name="ln2244">	}</a>
<a name="ln2245"> </a>
<a name="ln2246">	// Calling BMediaAddOn::GetConfigurationFor(BMediaNode *node,</a>
<a name="ln2247">	// BMessage *config) if this node was instanciated by an add-on needs to</a>
<a name="ln2248">	// be done *somewhere*</a>
<a name="ln2249">	// We can't do it here because it is already to late (destructor of the node</a>
<a name="ln2250">	// might have been called).</a>
<a name="ln2251"> </a>
<a name="ln2252">	server_unregister_node_request request;</a>
<a name="ln2253">	request.node_id = node-&gt;ID();</a>
<a name="ln2254">	request.team = BPrivate::current_team();</a>
<a name="ln2255"> </a>
<a name="ln2256">	// send a notification</a>
<a name="ln2257">	BPrivate::media::notifications::NodesDeleted(&amp;request.node_id, 1);</a>
<a name="ln2258"> </a>
<a name="ln2259">	server_unregister_node_reply reply;</a>
<a name="ln2260">	reply.add_on_id = -1;</a>
<a name="ln2261">	status_t status = QueryServer(SERVER_UNREGISTER_NODE, &amp;request,</a>
<a name="ln2262">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2263">	if (status != B_OK) {</a>
<a name="ln2264">		ERROR(&quot;BMediaRoster::UnregisterNode: failed to unregister node id %&quot;</a>
<a name="ln2265">			B_PRId32 &quot;, name '%s': %s\n&quot;, node-&gt;ID(), node-&gt;Name(),</a>
<a name="ln2266">			strerror(status));</a>
<a name="ln2267">		BMediaAddOn *addon = node-&gt;AddOn(&amp;reply.flavor_id);</a>
<a name="ln2268">		if (addon != NULL)</a>
<a name="ln2269">			reply.add_on_id = addon-&gt;AddonID();</a>
<a name="ln2270">	}</a>
<a name="ln2271"> </a>
<a name="ln2272">	if (reply.add_on_id != -1) {</a>
<a name="ln2273">		// TODO: this doesn't look right</a>
<a name="ln2274">		// Small problem here, we can't use DormantNodeManager::PutAddOn(), as</a>
<a name="ln2275">		// UnregisterNode() is called by a dormant node itself (by the</a>
<a name="ln2276">		// destructor).</a>
<a name="ln2277">		// The add-on that contains the node needs to remain in memory until the</a>
<a name="ln2278">		// destructor execution is finished.</a>
<a name="ln2279">		// DormantNodeManager::PutAddOnDelayed() will delay unloading.</a>
<a name="ln2280">		gDormantNodeManager-&gt;PutAddOnDelayed(reply.add_on_id);</a>
<a name="ln2281"> </a>
<a name="ln2282">		status = MediaRosterEx(this)-&gt;DecrementAddonFlavorInstancesCount(</a>
<a name="ln2283">			reply.add_on_id, reply.flavor_id);</a>
<a name="ln2284">		if (status != B_OK) {</a>
<a name="ln2285">			ERROR(&quot;BMediaRoster::UnregisterNode: &quot;</a>
<a name="ln2286">				&quot;DecrementAddonFlavorInstancesCount() failed\n&quot;);</a>
<a name="ln2287">			// this is really a problem, but we can't fail now</a>
<a name="ln2288">		}</a>
<a name="ln2289">	}</a>
<a name="ln2290"> </a>
<a name="ln2291">	// we are a friend class of BMediaNode and invalidate this member variable</a>
<a name="ln2292">	node-&gt;fNodeID = NODE_UNREGISTERED_ID;</a>
<a name="ln2293"> </a>
<a name="ln2294">	return status;</a>
<a name="ln2295">}</a>
<a name="ln2296"> </a>
<a name="ln2297"> </a>
<a name="ln2298">//!	Thread safe for multiple calls to Roster()</a>
<a name="ln2299">/*static*/ BMediaRoster*</a>
<a name="ln2300">BMediaRoster::Roster(status_t* out_error)</a>
<a name="ln2301">{</a>
<a name="ln2302">	BAutolock lock(sInitLocker);</a>
<a name="ln2303"> </a>
<a name="ln2304">	if (be_app == NULL)</a>
<a name="ln2305">		TRACE(&quot;Warning! You should have a valid BApplication.&quot;);</a>
<a name="ln2306"> </a>
<a name="ln2307">	if (!lock.IsLocked())</a>
<a name="ln2308">		return NULL;</a>
<a name="ln2309"> </a>
<a name="ln2310">	if (out_error)</a>
<a name="ln2311">		*out_error = B_OK;</a>
<a name="ln2312"> </a>
<a name="ln2313">	if (sDefaultInstance == NULL) {</a>
<a name="ln2314">		status_t err;</a>
<a name="ln2315">		sDefaultInstance = new (std::nothrow) BMediaRosterEx(&amp;err);</a>
<a name="ln2316">		if (sDefaultInstance == NULL)</a>
<a name="ln2317">			err = B_NO_MEMORY;</a>
<a name="ln2318">		else if (err != B_OK) {</a>
<a name="ln2319">			if (sDefaultInstance) {</a>
<a name="ln2320">				sDefaultInstance-&gt;Lock();</a>
<a name="ln2321">				sDefaultInstance-&gt;Quit();</a>
<a name="ln2322">				sDefaultInstance = NULL;</a>
<a name="ln2323">			}</a>
<a name="ln2324">			if (out_error)</a>
<a name="ln2325">				*out_error = err;</a>
<a name="ln2326">		} else if (be_app != NULL) {</a>
<a name="ln2327">			be_app-&gt;RegisterLooper(sDefaultInstance);</a>
<a name="ln2328">		}</a>
<a name="ln2329">	}</a>
<a name="ln2330"> </a>
<a name="ln2331">	return sDefaultInstance;</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334"> </a>
<a name="ln2335">/*static*/ BMediaRoster*</a>
<a name="ln2336">BMediaRoster::CurrentRoster()</a>
<a name="ln2337">{</a>
<a name="ln2338">	return sDefaultInstance;</a>
<a name="ln2339">}</a>
<a name="ln2340"> </a>
<a name="ln2341"> </a>
<a name="ln2342">status_t</a>
<a name="ln2343">BMediaRoster::SetTimeSourceFor(media_node_id node, media_node_id time_source)</a>
<a name="ln2344">{</a>
<a name="ln2345">	CALLED();</a>
<a name="ln2346">	if (IS_INVALID_NODEID(node) || IS_INVALID_NODEID(time_source))</a>
<a name="ln2347">		return B_BAD_VALUE;</a>
<a name="ln2348"> </a>
<a name="ln2349">	media_node clone;</a>
<a name="ln2350">	// We need to get a clone of the node to have a port id</a>
<a name="ln2351">	status_t result = GetNodeFor(node, &amp;clone);</a>
<a name="ln2352">	if (result == B_OK) {</a>
<a name="ln2353">		// We just send the request to set time_source-id as</a>
<a name="ln2354">		// timesource to the node, the NODE_SET_TIMESOURCE handler</a>
<a name="ln2355">		// code will do the real assignment.</a>
<a name="ln2356">		result = B_OK;</a>
<a name="ln2357">		node_set_timesource_command cmd;</a>
<a name="ln2358">		cmd.timesource_id = time_source;</a>
<a name="ln2359">		result = SendToPort(clone.port, NODE_SET_TIMESOURCE,</a>
<a name="ln2360">			&amp;cmd, sizeof(cmd));</a>
<a name="ln2361">		if (result != B_OK) {</a>
<a name="ln2362">			ERROR(&quot;BMediaRoster::SetTimeSourceFor&quot;</a>
<a name="ln2363">				&quot;sending NODE_SET_TIMESOURCE failed, node id %&quot;</a>
<a name="ln2364">				B_PRId32 &quot;\n&quot;, clone.node);</a>
<a name="ln2365">		}</a>
<a name="ln2366">		// We release the clone</a>
<a name="ln2367">		result = ReleaseNode(clone);</a>
<a name="ln2368">		if (result != B_OK) {</a>
<a name="ln2369">			ERROR(&quot;BMediaRoster::SetTimeSourceFor, ReleaseNode failed,&quot;</a>
<a name="ln2370">				&quot; node id %&quot; B_PRId32 &quot;\n&quot;, clone.node);</a>
<a name="ln2371">		}</a>
<a name="ln2372">	} else {</a>
<a name="ln2373">		ERROR(&quot;BMediaRoster::SetTimeSourceFor GetCloneForID failed, &quot;</a>
<a name="ln2374">			&quot;node id %&quot; B_PRId32 &quot;\n&quot;, node);</a>
<a name="ln2375">	}</a>
<a name="ln2376"> </a>
<a name="ln2377">	if (result == B_OK) {</a>
<a name="ln2378">		// Notify the server</a>
<a name="ln2379">		server_set_node_timesource_request request;</a>
<a name="ln2380">		server_set_node_timesource_reply reply;</a>
<a name="ln2381"> </a>
<a name="ln2382">		request.node_id = node;</a>
<a name="ln2383">		request.timesource_id = time_source;</a>
<a name="ln2384"> </a>
<a name="ln2385">		result = QueryServer(SERVER_SET_NODE_TIMESOURCE, &amp;request,</a>
<a name="ln2386">			sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2387">		if (result != B_OK) {</a>
<a name="ln2388">			ERROR(&quot;BMediaRoster::SetTimeSourceFor, sending NODE_SET_TIMESOURCE &quot;</a>
<a name="ln2389">				&quot;failed, node id %&quot; B_PRId32 &quot;\n&quot;, node);</a>
<a name="ln2390">		} else {</a>
<a name="ln2391">			TRACE(&quot;BMediaRoster::SetTimeSourceFor: node %&quot; B_PRId32 &quot; time source %&quot;</a>
<a name="ln2392">				B_PRId32 &quot; OK\n&quot;, node, time_source);</a>
<a name="ln2393">		}</a>
<a name="ln2394">	}</a>
<a name="ln2395">	return result;</a>
<a name="ln2396">}</a>
<a name="ln2397"> </a>
<a name="ln2398"> </a>
<a name="ln2399">status_t</a>
<a name="ln2400">BMediaRoster::GetParameterWebFor(const media_node&amp; node, BParameterWeb** _web)</a>
<a name="ln2401">{</a>
<a name="ln2402">	CALLED();</a>
<a name="ln2403">	if (_web == NULL)</a>
<a name="ln2404">		return B_BAD_VALUE;</a>
<a name="ln2405">	if (IS_INVALID_NODE(node))</a>
<a name="ln2406">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2407">	if ((node.kind &amp; B_CONTROLLABLE) == 0)</a>
<a name="ln2408">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2409"> </a>
<a name="ln2410">	controllable_get_parameter_web_request request;</a>
<a name="ln2411">	controllable_get_parameter_web_reply reply;</a>
<a name="ln2412">	int32 requestsize[] = {B_PAGE_SIZE, 4 * B_PAGE_SIZE, 16 * B_PAGE_SIZE,</a>
<a name="ln2413">		64 * B_PAGE_SIZE, 128 * B_PAGE_SIZE, 256 * B_PAGE_SIZE, 0};</a>
<a name="ln2414">	int32 size;</a>
<a name="ln2415"> </a>
<a name="ln2416">	// TODO: it might be better to query the node for the (current) parameter</a>
<a name="ln2417">	// size first</a>
<a name="ln2418">	for (int i = 0; (size = requestsize[i]) != 0; i++) {</a>
<a name="ln2419">		status_t rv;</a>
<a name="ln2420">		area_id area;</a>
<a name="ln2421">		void *data;</a>
<a name="ln2422">		area = create_area(&quot;parameter web data&quot;, &amp;data, B_ANY_ADDRESS, size,</a>
<a name="ln2423">			B_NO_LOCK, B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln2424">		if (area &lt; B_OK) {</a>
<a name="ln2425">			ERROR(&quot;BMediaRoster::GetParameterWebFor couldn't create area of &quot;</a>
<a name="ln2426">				&quot;size %&quot; B_PRId32 &quot;\n&quot;, size);</a>
<a name="ln2427">			return B_ERROR;</a>
<a name="ln2428">		}</a>
<a name="ln2429">		request.max_size = size;</a>
<a name="ln2430">		request.area = area;</a>
<a name="ln2431">		rv = QueryPort(node.port, CONTROLLABLE_GET_PARAMETER_WEB, &amp;request,</a>
<a name="ln2432">			sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2433">		if (rv != B_OK) {</a>
<a name="ln2434">			ERROR(&quot;BMediaRoster::GetParameterWebFor &quot;</a>
<a name="ln2435">				&quot;CONTROLLABLE_GET_PARAMETER_WEB failed\n&quot;);</a>
<a name="ln2436">			delete_area(area);</a>
<a name="ln2437">			return B_ERROR;</a>
<a name="ln2438">		}</a>
<a name="ln2439">		if (reply.size == 0) {</a>
<a name="ln2440">			// no parameter web available</a>
<a name="ln2441">			// TODO: should we return an error?</a>
<a name="ln2442">			ERROR(&quot;BMediaRoster::GetParameterWebFor node %&quot; B_PRId32</a>
<a name="ln2443">				&quot; has no parameter web\n&quot;, node.node);</a>
<a name="ln2444">			*_web = new (std::nothrow) BParameterWeb();</a>
<a name="ln2445">			delete_area(area);</a>
<a name="ln2446">			return *_web != NULL ? B_OK : B_NO_MEMORY;</a>
<a name="ln2447">		}</a>
<a name="ln2448">		if (reply.size &gt; 0) {</a>
<a name="ln2449">			// we got a flattened parameter web!</a>
<a name="ln2450">			BParameterWeb* web = new (std::nothrow) BParameterWeb();</a>
<a name="ln2451">			if (web == NULL)</a>
<a name="ln2452">				rv = B_NO_MEMORY;</a>
<a name="ln2453">			else {</a>
<a name="ln2454">				rv = web-&gt;Unflatten(reply.code, data, reply.size);</a>
<a name="ln2455">				if (rv != B_OK) {</a>
<a name="ln2456">					ERROR(&quot;BMediaRoster::GetParameterWebFor Unflatten failed, &quot;</a>
<a name="ln2457">						&quot;%s\n&quot;, strerror(rv));</a>
<a name="ln2458">					delete web;</a>
<a name="ln2459">				} else</a>
<a name="ln2460">					*_web = web;</a>
<a name="ln2461">			}</a>
<a name="ln2462"> </a>
<a name="ln2463">			delete_area(area);</a>
<a name="ln2464">			return rv;</a>
<a name="ln2465">		}</a>
<a name="ln2466">		delete_area(area);</a>
<a name="ln2467">		ASSERT(reply.size == -1);</a>
<a name="ln2468">		// parameter web data was too large</a>
<a name="ln2469">		// loop and try a larger size</a>
<a name="ln2470">	}</a>
<a name="ln2471">	ERROR(&quot;BMediaRoster::GetParameterWebFor node %&quot; B_PRId32 &quot; has no &quot;</a>
<a name="ln2472">		&quot;parameter web larger than %&quot; B_PRId32 &quot;\n&quot;, node.node, size);</a>
<a name="ln2473">	return B_ERROR;</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476"> </a>
<a name="ln2477">status_t</a>
<a name="ln2478">BMediaRoster::StartControlPanel(const media_node&amp; node, BMessenger* _messenger)</a>
<a name="ln2479">{</a>
<a name="ln2480">	CALLED();</a>
<a name="ln2481"> </a>
<a name="ln2482">	controllable_start_control_panel_request request;</a>
<a name="ln2483">	controllable_start_control_panel_reply reply;</a>
<a name="ln2484"> </a>
<a name="ln2485">	request.node = node;</a>
<a name="ln2486"> </a>
<a name="ln2487">	status_t rv;</a>
<a name="ln2488">	rv = QueryPort(node.port, CONTROLLABLE_START_CONTROL_PANEL, &amp;request,</a>
<a name="ln2489">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2490">	if (rv != B_OK)</a>
<a name="ln2491">		return rv;</a>
<a name="ln2492"> </a>
<a name="ln2493">	if (reply.team != -1 &amp;&amp; _messenger != NULL)</a>
<a name="ln2494">		*_messenger = BMessenger(NULL, reply.team);</a>
<a name="ln2495"> </a>
<a name="ln2496">	return B_OK;</a>
<a name="ln2497">}</a>
<a name="ln2498"> </a>
<a name="ln2499"> </a>
<a name="ln2500">status_t</a>
<a name="ln2501">BMediaRoster::GetDormantNodes(dormant_node_info* _info, int32* _count,</a>
<a name="ln2502">	const media_format* hasInput, const media_format* hasOutput,</a>
<a name="ln2503">	const char* name, uint64 requireKinds, uint64 denyKinds)</a>
<a name="ln2504">{</a>
<a name="ln2505">	CALLED();</a>
<a name="ln2506">	if (_info == NULL || _count == NULL || *_count &lt;= 0)</a>
<a name="ln2507">		return B_BAD_VALUE;</a>
<a name="ln2508"> </a>
<a name="ln2509">	server_get_dormant_nodes_request request;</a>
<a name="ln2510">	request.max_count = *_count;</a>
<a name="ln2511">	request.has_input = hasInput != NULL;</a>
<a name="ln2512">	if (hasInput != NULL) {</a>
<a name="ln2513">		// TODO: we should not make a flat copy of media_format</a>
<a name="ln2514">		request.input_format = *hasInput;</a>
<a name="ln2515">	}</a>
<a name="ln2516">	request.has_output = hasOutput != NULL;</a>
<a name="ln2517">	if (hasOutput != NULL) {</a>
<a name="ln2518">		// TODO: we should not make a flat copy of media_format</a>
<a name="ln2519">		request.output_format = *hasOutput;</a>
<a name="ln2520">	}</a>
<a name="ln2521"> </a>
<a name="ln2522">	request.has_name = name != NULL;</a>
<a name="ln2523">	if (name != NULL)</a>
<a name="ln2524">		strlcpy(request.name, name, sizeof(request.name));</a>
<a name="ln2525"> </a>
<a name="ln2526">	request.require_kinds = requireKinds;</a>
<a name="ln2527">	request.deny_kinds = denyKinds;</a>
<a name="ln2528"> </a>
<a name="ln2529">	server_get_dormant_nodes_reply reply;</a>
<a name="ln2530">	status_t status = QueryServer(SERVER_GET_DORMANT_NODES, &amp;request,</a>
<a name="ln2531">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2532">	if (status != B_OK)</a>
<a name="ln2533">		return status;</a>
<a name="ln2534"> </a>
<a name="ln2535">	*_count = reply.count;</a>
<a name="ln2536"> </a>
<a name="ln2537">	if (reply.count &gt; 0) {</a>
<a name="ln2538">		int32 code;</a>
<a name="ln2539">		status = read_port(request.reply_port, &amp;code, _info,</a>
<a name="ln2540">			reply.count * sizeof(dormant_node_info));</a>
<a name="ln2541">		if (status &lt; B_OK)</a>
<a name="ln2542">			reply.result = status;</a>
<a name="ln2543">	}</a>
<a name="ln2544"> </a>
<a name="ln2545">	return reply.result;</a>
<a name="ln2546">}</a>
<a name="ln2547"> </a>
<a name="ln2548"> </a>
<a name="ln2549">/*!	This function is used to do the real work of instantiating a dormant node.</a>
<a name="ln2550">	It is either called by the media_addon_server to instantiate a global node,</a>
<a name="ln2551">	or it gets called from BMediaRoster::InstantiateDormantNode() to create a</a>
<a name="ln2552">	local one.</a>
<a name="ln2553"> </a>
<a name="ln2554">	Checks concerning global/local are not done here.</a>
<a name="ln2555">*/</a>
<a name="ln2556">status_t</a>
<a name="ln2557">BMediaRosterEx::InstantiateDormantNode(media_addon_id addonID, int32 flavorID,</a>
<a name="ln2558">	team_id creator, media_node *_node)</a>
<a name="ln2559">{</a>
<a name="ln2560">	// This function is always called from the correct context, if the node</a>
<a name="ln2561">	// is supposed to be global, it is called from the media_addon_server.</a>
<a name="ln2562"> </a>
<a name="ln2563">	// if B_FLAVOR_IS_GLOBAL, we need to use the BMediaAddOn object that</a>
<a name="ln2564">	// resides in the media_addon_server</a>
<a name="ln2565"> </a>
<a name="ln2566">	// RegisterNode() must be called for nodes instantiated from add-ons,</a>
<a name="ln2567">	// since the media kit warrants that it's done automatically.</a>
<a name="ln2568"> </a>
<a name="ln2569">	// addonID		Indicates the ID number of the media add-on in which the</a>
<a name="ln2570">	//				node resides.</a>
<a name="ln2571">	// flavorID		Indicates the internal ID number that the add-on uses to</a>
<a name="ln2572">	//				identify the flavor, this is the number that was published</a>
<a name="ln2573">	//				by BMediaAddOn::GetFlavorAt() in the</a>
<a name="ln2574">	//				flavor_info::internal_id field.</a>
<a name="ln2575">	// creator		The creator team is -1 if nodes are created locally. If</a>
<a name="ln2576">	//				created globally, it will contain (while called in</a>
<a name="ln2577">	//				media_addon_server context) the team-id of the team that</a>
<a name="ln2578">	//				requested the instantiation.</a>
<a name="ln2579"> </a>
<a name="ln2580">	TRACE(&quot;BMediaRosterEx::InstantiateDormantNode: addonID %&quot; B_PRId32</a>
<a name="ln2581">		&quot;, flavorID %&quot; B_PRId32 &quot;\n&quot;, addonID, flavorID);</a>
<a name="ln2582"> </a>
<a name="ln2583">	// Get flavor_info from the server</a>
<a name="ln2584">	dormant_flavor_info info;</a>
<a name="ln2585">	status_t rv;</a>
<a name="ln2586">	rv = GetDormantFlavorInfo(addonID, flavorID, &amp;info);</a>
<a name="ln2587">	if (rv != B_OK) {</a>
<a name="ln2588">		ERROR(&quot;BMediaRosterEx::InstantiateDormantNode error: failed to get &quot;</a>
<a name="ln2589">			&quot;dormant_flavor_info for addon-id %&quot; B_PRId32 &quot;, flavor-id %&quot;</a>
<a name="ln2590">			B_PRId32 &quot;\n&quot;, addonID, flavorID);</a>
<a name="ln2591">		return B_ERROR;</a>
<a name="ln2592">	}</a>
<a name="ln2593"> </a>
<a name="ln2594">	ASSERT(info.internal_id == flavorID);</a>
<a name="ln2595"> </a>
<a name="ln2596">	// load the BMediaAddOn object</a>
<a name="ln2597">	BMediaAddOn* addon = gDormantNodeManager-&gt;GetAddOn(addonID);</a>
<a name="ln2598">	if (addon == NULL) {</a>
<a name="ln2599">		ERROR(&quot;BMediaRosterEx::InstantiateDormantNode: GetAddon failed\n&quot;);</a>
<a name="ln2600">		return B_ERROR;</a>
<a name="ln2601">	}</a>
<a name="ln2602"> </a>
<a name="ln2603">	// Now we need to try to increment the use count of this addon flavor</a>
<a name="ln2604">	// in the server. This can fail if the total number instances of this</a>
<a name="ln2605">	// flavor is limited.</a>
<a name="ln2606">	rv = IncrementAddonFlavorInstancesCount(addonID, flavorID);</a>
<a name="ln2607">	if (rv != B_OK) {</a>
<a name="ln2608">		ERROR(&quot;BMediaRosterEx::InstantiateDormantNode error: can't create &quot;</a>
<a name="ln2609">			&quot;more nodes for addon-id %&quot; B_PRId32 &quot;, flavor-id %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln2610">			addonID, flavorID);</a>
<a name="ln2611">		// Put the addon back into the pool</a>
<a name="ln2612">		gDormantNodeManager-&gt;PutAddOn(addonID);</a>
<a name="ln2613">		return B_ERROR;</a>
<a name="ln2614">	}</a>
<a name="ln2615"> </a>
<a name="ln2616">	BMessage config;</a>
<a name="ln2617">	rv = LoadNodeConfiguration(addonID, flavorID, &amp;config);</a>
<a name="ln2618">	if (rv != B_OK) {</a>
<a name="ln2619">		ERROR(&quot;BMediaRosterEx::InstantiateDormantNode: couldn't load &quot;</a>
<a name="ln2620">			&quot;configuration for addon-id %&quot; B_PRId32 &quot;, flavor-id %&quot; B_PRId32</a>
<a name="ln2621">			&quot;\n&quot;, addonID, flavorID);</a>
<a name="ln2622">		// do not return, this is a minor problem, not a reason to fail</a>
<a name="ln2623">	}</a>
<a name="ln2624"> </a>
<a name="ln2625">	status_t status = B_OK;</a>
<a name="ln2626">	BMediaNode* node = addon-&gt;InstantiateNodeFor(&amp;info, &amp;config, &amp;status);</a>
<a name="ln2627">	if (node == NULL) {</a>
<a name="ln2628">		ERROR(&quot;BMediaRosterEx::InstantiateDormantNode: InstantiateNodeFor &quot;</a>
<a name="ln2629">			&quot;failed\n&quot;);</a>
<a name="ln2630"> </a>
<a name="ln2631">		// Put the addon back into the pool</a>
<a name="ln2632">		gDormantNodeManager-&gt;PutAddOn(addonID);</a>
<a name="ln2633"> </a>
<a name="ln2634">		// We must decrement the use count of this addon flavor in the</a>
<a name="ln2635">		// server to compensate the increment done in the beginning.</a>
<a name="ln2636">		rv = DecrementAddonFlavorInstancesCount(addonID, flavorID);</a>
<a name="ln2637">		if (rv != B_OK) {</a>
<a name="ln2638">			ERROR(&quot;BMediaRosterEx::InstantiateDormantNode: DecrementAddon&quot;</a>
<a name="ln2639">				&quot;FlavorInstancesCount failed\n&quot;);</a>
<a name="ln2640">		}</a>
<a name="ln2641">		return status != B_OK ? status : B_ERROR;</a>
<a name="ln2642">	}</a>
<a name="ln2643"> </a>
<a name="ln2644">	rv = RegisterNode(node, addonID, flavorID);</a>
<a name="ln2645">	if (rv != B_OK) {</a>
<a name="ln2646">		ERROR(&quot;BMediaRosterEx::InstantiateDormantNode: RegisterNode failed\n&quot;);</a>
<a name="ln2647">		delete node;</a>
<a name="ln2648">		// Put the addon back into the pool</a>
<a name="ln2649">		gDormantNodeManager-&gt;PutAddOn(addonID);</a>
<a name="ln2650">		// We must decrement the use count of this addon flavor in the</a>
<a name="ln2651">		// server to compensate the increment done in the beginning.</a>
<a name="ln2652">		rv = DecrementAddonFlavorInstancesCount(addonID, flavorID);</a>
<a name="ln2653">		if (rv != B_OK) {</a>
<a name="ln2654">			ERROR(&quot;BMediaRosterEx::InstantiateDormantNode: DecrementAddon&quot;</a>
<a name="ln2655">				&quot;FlavorInstancesCount failed\n&quot;);</a>
<a name="ln2656">		}</a>
<a name="ln2657">		return B_ERROR;</a>
<a name="ln2658">	}</a>
<a name="ln2659"> </a>
<a name="ln2660">	if (creator != -1) {</a>
<a name="ln2661">		// send a message to the server to assign team &quot;creator&quot; as creator</a>
<a name="ln2662">		// of node &quot;node-&gt;ID()&quot;</a>
<a name="ln2663">		printf(&quot;!!! BMediaRosterEx::InstantiateDormantNode assigning team %&quot;</a>
<a name="ln2664">			B_PRId32 &quot; as creator of node %&quot; B_PRId32 &quot;\n&quot;, creator,</a>
<a name="ln2665">			node-&gt;ID());</a>
<a name="ln2666"> </a>
<a name="ln2667">		rv = MediaRosterEx(this)-&gt;SetNodeCreator(node-&gt;ID(), creator);</a>
<a name="ln2668">		if (rv != B_OK) {</a>
<a name="ln2669">			ERROR(&quot;BMediaRosterEx::InstantiateDormantNode failed to assign &quot;</a>
<a name="ln2670">				&quot;team %&quot; B_PRId32 &quot; as creator of node %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln2671">				creator, node-&gt;ID());</a>
<a name="ln2672">			// do not return, this is a minor problem, not a reason to fail</a>
<a name="ln2673">		}</a>
<a name="ln2674">	}</a>
<a name="ln2675"> </a>
<a name="ln2676">	// RegisterNode() does remember the add-on id in the server</a>
<a name="ln2677">	// and UnregisterNode() will call DormantNodeManager::PutAddon()</a>
<a name="ln2678">	// when the node is unregistered.</a>
<a name="ln2679"> </a>
<a name="ln2680">	*_node = node-&gt;Node();</a>
<a name="ln2681"> </a>
<a name="ln2682">	TRACE(&quot;BMediaRosterEx::InstantiateDormantNode: addon-id %&quot; B_PRId32</a>
<a name="ln2683">		&quot;, flavor_id %&quot; B_PRId32 &quot; instanciated as node %&quot; B_PRId32 &quot;, port %&quot;</a>
<a name="ln2684">		B_PRId32 &quot; in team %&quot; B_PRId32 &quot;\n&quot;, addonID, flavorID, _node-&gt;node,</a>
<a name="ln2685">		_node-&gt;port, BPrivate::current_team());</a>
<a name="ln2686"> </a>
<a name="ln2687">	return B_OK;</a>
<a name="ln2688">}</a>
<a name="ln2689"> </a>
<a name="ln2690"> </a>
<a name="ln2691">status_t</a>
<a name="ln2692">BMediaRoster::InstantiateDormantNode(const dormant_node_info&amp; info,</a>
<a name="ln2693">	media_node* _node, uint32 flags)</a>
<a name="ln2694">{</a>
<a name="ln2695">	CALLED();</a>
<a name="ln2696">	if (_node == NULL)</a>
<a name="ln2697">		return B_BAD_VALUE;</a>
<a name="ln2698">	if (info.addon &lt;= B_OK) {</a>
<a name="ln2699">		ERROR(&quot;BMediaRoster::InstantiateDormantNode error: addon-id %&quot; B_PRId32</a>
<a name="ln2700">			&quot; invalid.\n&quot;, info.addon);</a>
<a name="ln2701">		return B_BAD_VALUE;</a>
<a name="ln2702">	}</a>
<a name="ln2703"> </a>
<a name="ln2704">	printf(&quot;BMediaRoster::InstantiateDormantNode: addon-id %&quot; B_PRId32</a>
<a name="ln2705">		&quot;, flavor_id %&quot; B_PRId32 &quot;, flags 0x%&quot; B_PRIx32 &quot;\n&quot;, info.addon,</a>
<a name="ln2706">		info.flavor_id, flags);</a>
<a name="ln2707"> </a>
<a name="ln2708">	// Get flavor_info from the server</a>
<a name="ln2709">	// TODO: this is a little overhead, as we get the full blown</a>
<a name="ln2710">	// dormant_flavor_info,</a>
<a name="ln2711">	// TODO: but only need the flags.</a>
<a name="ln2712">	dormant_flavor_info flavorInfo;</a>
<a name="ln2713">	status_t rv;</a>
<a name="ln2714">	rv = MediaRosterEx(this)-&gt;GetDormantFlavorInfo(info.addon, info.flavor_id,</a>
<a name="ln2715">		&amp;flavorInfo);</a>
<a name="ln2716">	if (rv != B_OK) {</a>
<a name="ln2717">		ERROR(&quot;BMediaRoster::InstantiateDormantNode: failed to get &quot;</a>
<a name="ln2718">			&quot;dormant_flavor_info for addon-id %&quot; B_PRId32 &quot;, flavor-id %&quot;</a>
<a name="ln2719">			B_PRId32 &quot;\n&quot;, info.addon, info.flavor_id);</a>
<a name="ln2720">		return B_NAME_NOT_FOUND;</a>
<a name="ln2721">	}</a>
<a name="ln2722"> </a>
<a name="ln2723">	ASSERT(flavorInfo.internal_id == info.flavor_id);</a>
<a name="ln2724"> </a>
<a name="ln2725">#if DEBUG</a>
<a name="ln2726">	printf(&quot;BMediaRoster::InstantiateDormantNode: name \&quot;%s\&quot;, info \&quot;%s\&quot;, &quot;</a>
<a name="ln2727">		&quot;flavor_flags 0x%&quot; B_PRIx32 &quot;, internal_id %&quot; B_PRId32</a>
<a name="ln2728">		&quot;, possible_count %&quot; B_PRId32 &quot;\n&quot;, flavorInfo.name, flavorInfo.info,</a>
<a name="ln2729">		flavorInfo.flavor_flags, flavorInfo.internal_id,</a>
<a name="ln2730">		flavorInfo.possible_count);</a>
<a name="ln2731"> </a>
<a name="ln2732">	if ((flags &amp; B_FLAVOR_IS_LOCAL) != 0) {</a>
<a name="ln2733">		printf(&quot;BMediaRoster::InstantiateDormantNode: caller requested &quot;</a>
<a name="ln2734">			&quot;B_FLAVOR_IS_LOCAL\n&quot;);</a>
<a name="ln2735">	}</a>
<a name="ln2736">	if ((flags &amp; B_FLAVOR_IS_GLOBAL) != 0) {</a>
<a name="ln2737">		printf(&quot;BMediaRoster::InstantiateDormantNode: caller requested &quot;</a>
<a name="ln2738">			&quot;B_FLAVOR_IS_GLOBAL\n&quot;);</a>
<a name="ln2739">	}</a>
<a name="ln2740">	if ((flavorInfo.flavor_flags &amp; B_FLAVOR_IS_LOCAL) != 0) {</a>
<a name="ln2741">		printf(&quot;BMediaRoster::InstantiateDormantNode: node requires &quot;</a>
<a name="ln2742">			&quot;B_FLAVOR_IS_LOCAL\n&quot;);</a>
<a name="ln2743">	}</a>
<a name="ln2744">	if ((flavorInfo.flavor_flags &amp; B_FLAVOR_IS_GLOBAL) != 0) {</a>
<a name="ln2745">		printf(&quot;BMediaRoster::InstantiateDormantNode: node requires &quot;</a>
<a name="ln2746">			&quot;B_FLAVOR_IS_GLOBAL\n&quot;);</a>
<a name="ln2747">	}</a>
<a name="ln2748">#endif</a>
<a name="ln2749"> </a>
<a name="ln2750">	// Make sure that flags demanded by the dormant node and those requested</a>
<a name="ln2751">	// by the caller are not incompatible.</a>
<a name="ln2752">	if ((flavorInfo.flavor_flags &amp; B_FLAVOR_IS_GLOBAL) != 0</a>
<a name="ln2753">		&amp;&amp; (flags &amp; B_FLAVOR_IS_LOCAL) != 0) {</a>
<a name="ln2754">		ERROR(&quot;BMediaRoster::InstantiateDormantNode: requested &quot;</a>
<a name="ln2755">			&quot;B_FLAVOR_IS_LOCAL, but dormant node has B_FLAVOR_IS_GLOBAL\n&quot;);</a>
<a name="ln2756">		return B_NAME_NOT_FOUND;</a>
<a name="ln2757">	}</a>
<a name="ln2758">	if ((flavorInfo.flavor_flags &amp; B_FLAVOR_IS_LOCAL) != 0</a>
<a name="ln2759">		&amp;&amp; (flags &amp; B_FLAVOR_IS_GLOBAL) != 0) {</a>
<a name="ln2760">		ERROR(&quot;BMediaRoster::InstantiateDormantNode: requested &quot;</a>
<a name="ln2761">			&quot;B_FLAVOR_IS_GLOBAL, but dormant node has B_FLAVOR_IS_LOCAL\n&quot;);</a>
<a name="ln2762">		return B_NAME_NOT_FOUND;</a>
<a name="ln2763">	}</a>
<a name="ln2764"> </a>
<a name="ln2765">	// If either the node, or the caller requested to make the instance global</a>
<a name="ln2766">	// we will do it by forwarding this request into the media_addon_server,</a>
<a name="ln2767">	// which in turn will call BMediaRosterEx::InstantiateDormantNode to create</a>
<a name="ln2768">	// the node there and make it globally available.</a>
<a name="ln2769">	if ((flavorInfo.flavor_flags &amp; B_FLAVOR_IS_GLOBAL) != 0</a>
<a name="ln2770">		|| (flags &amp; B_FLAVOR_IS_GLOBAL) != 0) {</a>
<a name="ln2771">		TRACE(&quot;BMediaRoster::InstantiateDormantNode: creating global object &quot;</a>
<a name="ln2772">			&quot;in media_addon_server\n&quot;);</a>
<a name="ln2773"> </a>
<a name="ln2774">		add_on_server_instantiate_dormant_node_request request;</a>
<a name="ln2775">		add_on_server_instantiate_dormant_node_reply reply;</a>
<a name="ln2776">		request.add_on_id = info.addon;</a>
<a name="ln2777">		request.flavor_id = info.flavor_id;</a>
<a name="ln2778">		request.creator_team = BPrivate::current_team();</a>
<a name="ln2779">			// creator team is allowed to also release global nodes</a>
<a name="ln2780">		rv = QueryAddOnServer(ADD_ON_SERVER_INSTANTIATE_DORMANT_NODE, &amp;request,</a>
<a name="ln2781">			sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2782">		if (rv == B_OK)</a>
<a name="ln2783">			*_node = reply.node;</a>
<a name="ln2784">	} else {</a>
<a name="ln2785">		// creator team = -1, as this is a local node</a>
<a name="ln2786">		rv = MediaRosterEx(this)-&gt;InstantiateDormantNode(info.addon,</a>
<a name="ln2787">			info.flavor_id, -1, _node);</a>
<a name="ln2788">	}</a>
<a name="ln2789">	if (rv != B_OK) {</a>
<a name="ln2790">		*_node = media_node::null;</a>
<a name="ln2791">		return B_NAME_NOT_FOUND;</a>
<a name="ln2792">	}</a>
<a name="ln2793">	return B_OK;</a>
<a name="ln2794">}</a>
<a name="ln2795"> </a>
<a name="ln2796"> </a>
<a name="ln2797">status_t</a>
<a name="ln2798">BMediaRoster::InstantiateDormantNode(const dormant_node_info&amp; info,</a>
<a name="ln2799">	media_node* _node)</a>
<a name="ln2800">{</a>
<a name="ln2801">	return InstantiateDormantNode(info, _node, 0);</a>
<a name="ln2802">}</a>
<a name="ln2803"> </a>
<a name="ln2804"> </a>
<a name="ln2805">status_t</a>
<a name="ln2806">BMediaRoster::GetDormantNodeFor(const media_node&amp; node,</a>
<a name="ln2807">	dormant_node_info* _info)</a>
<a name="ln2808">{</a>
<a name="ln2809">	CALLED();</a>
<a name="ln2810">	if (_info == NULL)</a>
<a name="ln2811">		return B_BAD_VALUE;</a>
<a name="ln2812">	if (IS_INVALID_NODE(node))</a>
<a name="ln2813">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2814"> </a>
<a name="ln2815">	server_get_dormant_node_for_request request;</a>
<a name="ln2816">	server_get_dormant_node_for_reply reply;</a>
<a name="ln2817">	status_t rv;</a>
<a name="ln2818"> </a>
<a name="ln2819">	request.node = node;</a>
<a name="ln2820"> </a>
<a name="ln2821">	rv = QueryServer(SERVER_GET_DORMANT_NODE_FOR, &amp;request, sizeof(request),</a>
<a name="ln2822">		&amp;reply, sizeof(reply));</a>
<a name="ln2823">	if (rv != B_OK)</a>
<a name="ln2824">		return rv;</a>
<a name="ln2825"> </a>
<a name="ln2826">	*_info = reply.node_info;</a>
<a name="ln2827">	return B_OK;</a>
<a name="ln2828">}</a>
<a name="ln2829"> </a>
<a name="ln2830"> </a>
<a name="ln2831">status_t</a>
<a name="ln2832">BMediaRosterEx::GetDormantFlavorInfo(media_addon_id addonID, int32 flavorID,</a>
<a name="ln2833">	dormant_flavor_info* _flavor)</a>
<a name="ln2834">{</a>
<a name="ln2835">	CALLED();</a>
<a name="ln2836">	if (_flavor == NULL)</a>
<a name="ln2837">		return B_BAD_VALUE;</a>
<a name="ln2838"> </a>
<a name="ln2839">	// TODO: better use an area here as well!</a>
<a name="ln2840"> </a>
<a name="ln2841">	server_get_dormant_flavor_info_reply* reply</a>
<a name="ln2842">		= (server_get_dormant_flavor_info_reply*)malloc(16300);</a>
<a name="ln2843">	if (reply == NULL)</a>
<a name="ln2844">		return B_NO_MEMORY;</a>
<a name="ln2845"> </a>
<a name="ln2846">	server_get_dormant_flavor_info_request request;</a>
<a name="ln2847">	request.add_on_id = addonID;</a>
<a name="ln2848">	request.flavor_id = flavorID;</a>
<a name="ln2849"> </a>
<a name="ln2850">	status_t status = QueryServer(SERVER_GET_DORMANT_FLAVOR_INFO, &amp;request,</a>
<a name="ln2851">		sizeof(request), reply, 16300);</a>
<a name="ln2852">	if (status != B_OK) {</a>
<a name="ln2853">		free(reply);</a>
<a name="ln2854">		return status;</a>
<a name="ln2855">	}</a>
<a name="ln2856"> </a>
<a name="ln2857">	if (reply-&gt;result == B_OK) {</a>
<a name="ln2858">		status = _flavor-&gt;Unflatten(reply-&gt;type, &amp;reply-&gt;flattened_data,</a>
<a name="ln2859">			reply-&gt;flattened_size);</a>
<a name="ln2860">	} else</a>
<a name="ln2861">		status = reply-&gt;result;</a>
<a name="ln2862"> </a>
<a name="ln2863">	free(reply);</a>
<a name="ln2864">	return status;</a>
<a name="ln2865">}</a>
<a name="ln2866"> </a>
<a name="ln2867"> </a>
<a name="ln2868">status_t</a>
<a name="ln2869">BMediaRoster::GetDormantFlavorInfoFor(const dormant_node_info&amp; dormant,</a>
<a name="ln2870">	dormant_flavor_info* _flavor)</a>
<a name="ln2871">{</a>
<a name="ln2872">	return MediaRosterEx(this)-&gt;GetDormantFlavorInfo(dormant.addon,</a>
<a name="ln2873">		dormant.flavor_id, _flavor);</a>
<a name="ln2874">}</a>
<a name="ln2875"> </a>
<a name="ln2876"> </a>
<a name="ln2877">// Reports in outLatency the maximum latency found downstream from</a>
<a name="ln2878">// the specified BBufferProducer, producer, given the current connections.</a>
<a name="ln2879">status_t</a>
<a name="ln2880">BMediaRoster::GetLatencyFor(const media_node&amp; producer, bigtime_t* _latency)</a>
<a name="ln2881">{</a>
<a name="ln2882">	CALLED();</a>
<a name="ln2883">	if (_latency == NULL)</a>
<a name="ln2884">		return B_BAD_VALUE;</a>
<a name="ln2885">	if (IS_INVALID_NODE(producer)</a>
<a name="ln2886">		|| (producer.kind &amp; B_BUFFER_PRODUCER) == 0)</a>
<a name="ln2887">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2888"> </a>
<a name="ln2889">	producer_get_latency_request request;</a>
<a name="ln2890">	producer_get_latency_reply reply;</a>
<a name="ln2891">	status_t rv;</a>
<a name="ln2892"> </a>
<a name="ln2893">	rv = QueryPort(producer.port, PRODUCER_GET_LATENCY, &amp;request,</a>
<a name="ln2894">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2895">	if (rv != B_OK)</a>
<a name="ln2896">		return rv;</a>
<a name="ln2897"> </a>
<a name="ln2898">	*_latency = reply.latency;</a>
<a name="ln2899"> </a>
<a name="ln2900">//	printf(&quot;BMediaRoster::GetLatencyFor producer %ld has maximum latency %Ld\n&quot;, producer.node, *out_latency);</a>
<a name="ln2901">	return B_OK;</a>
<a name="ln2902">}</a>
<a name="ln2903"> </a>
<a name="ln2904"> </a>
<a name="ln2905">status_t</a>
<a name="ln2906">BMediaRoster::GetInitialLatencyFor(const media_node&amp; producer,</a>
<a name="ln2907">	bigtime_t* _latency, uint32* _flags)</a>
<a name="ln2908">{</a>
<a name="ln2909">	CALLED();</a>
<a name="ln2910">	if (_latency == NULL)</a>
<a name="ln2911">		return B_BAD_VALUE;</a>
<a name="ln2912">	if (IS_INVALID_NODE(producer)</a>
<a name="ln2913">		|| (producer.kind &amp; B_BUFFER_PRODUCER) == 0)</a>
<a name="ln2914">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2915"> </a>
<a name="ln2916">	producer_get_initial_latency_request request;</a>
<a name="ln2917">	producer_get_initial_latency_reply reply;</a>
<a name="ln2918">	status_t rv;</a>
<a name="ln2919"> </a>
<a name="ln2920">	rv = QueryPort(producer.port, PRODUCER_GET_INITIAL_LATENCY, &amp;request,</a>
<a name="ln2921">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2922">	if (rv != B_OK)</a>
<a name="ln2923">		return rv;</a>
<a name="ln2924"> </a>
<a name="ln2925">	*_latency = reply.initial_latency;</a>
<a name="ln2926">	if (_flags != NULL)</a>
<a name="ln2927">		*_flags = reply.flags;</a>
<a name="ln2928"> </a>
<a name="ln2929">	TRACE(&quot;BMediaRoster::GetInitialLatencyFor producer %&quot; B_PRId32 &quot; has &quot;</a>
<a name="ln2930">		&quot;maximum initial latency %&quot; B_PRId64 &quot;\n&quot;, producer.node, *_latency);</a>
<a name="ln2931">	return B_OK;</a>
<a name="ln2932">}</a>
<a name="ln2933"> </a>
<a name="ln2934"> </a>
<a name="ln2935">status_t</a>
<a name="ln2936">BMediaRoster::GetStartLatencyFor(const media_node&amp; timeSource,</a>
<a name="ln2937">	bigtime_t* _latency)</a>
<a name="ln2938">{</a>
<a name="ln2939">	CALLED();</a>
<a name="ln2940">	if (_latency == NULL)</a>
<a name="ln2941">		return B_BAD_VALUE;</a>
<a name="ln2942">	if (IS_INVALID_NODE(timeSource)</a>
<a name="ln2943">		|| (timeSource.kind &amp; B_TIME_SOURCE) == 0)</a>
<a name="ln2944">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2945"> </a>
<a name="ln2946">	timesource_get_start_latency_request request;</a>
<a name="ln2947">	timesource_get_start_latency_reply reply;</a>
<a name="ln2948">	status_t rv;</a>
<a name="ln2949"> </a>
<a name="ln2950">	rv = QueryPort(timeSource.port, TIMESOURCE_GET_START_LATENCY, &amp;request,</a>
<a name="ln2951">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2952">	if (rv != B_OK)</a>
<a name="ln2953">		return rv;</a>
<a name="ln2954"> </a>
<a name="ln2955">	*_latency = reply.start_latency;</a>
<a name="ln2956"> </a>
<a name="ln2957">	TRACE(&quot;BMediaRoster::GetStartLatencyFor timesource %&quot; B_PRId32 &quot; has &quot;</a>
<a name="ln2958">		&quot;maximum initial latency %&quot; B_PRId64 &quot;\n&quot;, timeSource.node, *_latency);</a>
<a name="ln2959">	return B_OK;</a>
<a name="ln2960">}</a>
<a name="ln2961"> </a>
<a name="ln2962"> </a>
<a name="ln2963">status_t</a>
<a name="ln2964">BMediaRoster::GetFileFormatsFor(const media_node&amp; fileInterface,</a>
<a name="ln2965">	media_file_format* _formats, int32* _numFormats)</a>
<a name="ln2966">{</a>
<a name="ln2967">	CALLED();</a>
<a name="ln2968"> </a>
<a name="ln2969">	if (IS_INVALID_NODE(fileInterface)</a>
<a name="ln2970">		|| (fileInterface.kind &amp; B_FILE_INTERFACE) == 0)</a>
<a name="ln2971">		return B_MEDIA_BAD_NODE;</a>
<a name="ln2972"> </a>
<a name="ln2973">	if (_numFormats == NULL || *_numFormats &lt; 1)</a>
<a name="ln2974">		return B_BAD_VALUE;</a>
<a name="ln2975"> </a>
<a name="ln2976">	fileinterface_get_formats_request request;</a>
<a name="ln2977">	fileinterface_get_formats_reply reply;</a>
<a name="ln2978"> </a>
<a name="ln2979">	media_file_format* formats;</a>
<a name="ln2980">	size_t needSize = sizeof(media_file_format) * *_numFormats;</a>
<a name="ln2981">	size_t size = (needSize + (B_PAGE_SIZE - 1)) &amp; ~(B_PAGE_SIZE - 1);</a>
<a name="ln2982"> </a>
<a name="ln2983">	area_id area = create_area(&quot;formats area&quot;, (void**)&amp;formats,</a>
<a name="ln2984">		B_ANY_ADDRESS, size, B_NO_LOCK,</a>
<a name="ln2985">		B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln2986"> </a>
<a name="ln2987">	if (area &lt; 0)</a>
<a name="ln2988">		return B_NO_MEMORY;</a>
<a name="ln2989"> </a>
<a name="ln2990">	request.num_formats = *_numFormats;</a>
<a name="ln2991">	request.data_area = area;</a>
<a name="ln2992"> </a>
<a name="ln2993">	status_t status = QueryPort(fileInterface.port,</a>
<a name="ln2994">		FILEINTERFACE_GET_FORMATS, &amp;request,</a>
<a name="ln2995">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln2996"> </a>
<a name="ln2997">	if (status == B_OK) {</a>
<a name="ln2998">		memcpy(_formats, formats, sizeof(media_file_format)*reply.filled_slots);</a>
<a name="ln2999">		*_numFormats = reply.filled_slots;</a>
<a name="ln3000">	}</a>
<a name="ln3001">	delete_area(area);</a>
<a name="ln3002">	return status;</a>
<a name="ln3003">}</a>
<a name="ln3004"> </a>
<a name="ln3005"> </a>
<a name="ln3006">status_t</a>
<a name="ln3007">BMediaRoster::SetRefFor(const media_node&amp; file_interface, const entry_ref&amp; file,</a>
<a name="ln3008">	bool createAndTruncate, bigtime_t* _length)</a>
<a name="ln3009">{</a>
<a name="ln3010">	CALLED();</a>
<a name="ln3011"> </a>
<a name="ln3012">	if (IS_INVALID_NODE(file_interface)</a>
<a name="ln3013">		|| (file_interface.kind &amp; B_FILE_INTERFACE) == 0)</a>
<a name="ln3014">		return B_MEDIA_BAD_NODE;</a>
<a name="ln3015"> </a>
<a name="ln3016">	fileinterface_set_ref_request request;</a>
<a name="ln3017">	fileinterface_set_ref_reply reply;</a>
<a name="ln3018">	status_t rv;</a>
<a name="ln3019"> </a>
<a name="ln3020">	request.device = file.device;</a>
<a name="ln3021">	request.directory = file.directory;</a>
<a name="ln3022">	strcpy(request.name, file.name);</a>
<a name="ln3023">	request.create = createAndTruncate;</a>
<a name="ln3024">	if (_length != NULL)</a>
<a name="ln3025">		request.duration = *_length;</a>
<a name="ln3026"> </a>
<a name="ln3027">	rv = QueryPort(file_interface.port, FILEINTERFACE_SET_REF, &amp;request,</a>
<a name="ln3028">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln3029">	if (rv != B_OK)</a>
<a name="ln3030">		return rv;</a>
<a name="ln3031"> </a>
<a name="ln3032">	if (!createAndTruncate &amp;&amp; _length)</a>
<a name="ln3033">		*_length = reply.duration;</a>
<a name="ln3034"> </a>
<a name="ln3035">	return B_OK;</a>
<a name="ln3036">}</a>
<a name="ln3037"> </a>
<a name="ln3038"> </a>
<a name="ln3039">status_t</a>
<a name="ln3040">BMediaRoster::GetRefFor(const media_node&amp; node, entry_ref* _file,</a>
<a name="ln3041">	BMimeType* mimeType)</a>
<a name="ln3042">{</a>
<a name="ln3043">	CALLED();</a>
<a name="ln3044"> </a>
<a name="ln3045">	if (IS_INVALID_NODE(node)</a>
<a name="ln3046">		|| (node.kind &amp; B_FILE_INTERFACE) == 0)</a>
<a name="ln3047">		return B_MEDIA_BAD_NODE;</a>
<a name="ln3048"> </a>
<a name="ln3049">	if (!_file)</a>
<a name="ln3050">		return B_BAD_VALUE;</a>
<a name="ln3051"> </a>
<a name="ln3052">	fileinterface_get_ref_request request;</a>
<a name="ln3053">	fileinterface_get_ref_reply reply;</a>
<a name="ln3054">	status_t rv;</a>
<a name="ln3055"> </a>
<a name="ln3056">	rv = QueryPort(node.port, FILEINTERFACE_GET_REF, &amp;request, sizeof(request),</a>
<a name="ln3057">		&amp;reply, sizeof(reply));</a>
<a name="ln3058">	if (rv != B_OK)</a>
<a name="ln3059">		return rv;</a>
<a name="ln3060"> </a>
<a name="ln3061">	*_file = entry_ref(reply.device, reply.directory, reply.name);</a>
<a name="ln3062"> </a>
<a name="ln3063">	if (mimeType)</a>
<a name="ln3064">		mimeType-&gt;SetTo(reply.mimetype);</a>
<a name="ln3065"> </a>
<a name="ln3066">	return B_OK;</a>
<a name="ln3067">}</a>
<a name="ln3068"> </a>
<a name="ln3069"> </a>
<a name="ln3070">status_t</a>
<a name="ln3071">BMediaRoster::SniffRefFor(const media_node&amp; file_interface,</a>
<a name="ln3072">	const entry_ref&amp; file, BMimeType* mimeType, float* _capability)</a>
<a name="ln3073">{</a>
<a name="ln3074">	CALLED();</a>
<a name="ln3075"> </a>
<a name="ln3076">	if (IS_INVALID_NODE(file_interface)</a>
<a name="ln3077">		|| (file_interface.kind &amp; B_FILE_INTERFACE) == 0)</a>
<a name="ln3078">		return B_MEDIA_BAD_NODE;</a>
<a name="ln3079"> </a>
<a name="ln3080">	if (mimeType == NULL || _capability == NULL)</a>
<a name="ln3081">		return B_BAD_VALUE;</a>
<a name="ln3082"> </a>
<a name="ln3083">	fileinterface_sniff_ref_request request;</a>
<a name="ln3084">	fileinterface_sniff_ref_reply reply;</a>
<a name="ln3085">	status_t rv;</a>
<a name="ln3086"> </a>
<a name="ln3087">	request.device = file.device;</a>
<a name="ln3088">	request.directory = file.directory;</a>
<a name="ln3089">	strcpy(request.name, file.name);</a>
<a name="ln3090"> </a>
<a name="ln3091">	rv = QueryPort(file_interface.port, FILEINTERFACE_SNIFF_REF, &amp;request,</a>
<a name="ln3092">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln3093">	if (rv != B_OK)</a>
<a name="ln3094">		return rv;</a>
<a name="ln3095"> </a>
<a name="ln3096">	mimeType-&gt;SetTo(reply.mimetype);</a>
<a name="ln3097">	*_capability = reply.capability;</a>
<a name="ln3098"> </a>
<a name="ln3099">	return B_OK;</a>
<a name="ln3100">}</a>
<a name="ln3101"> </a>
<a name="ln3102"> </a>
<a name="ln3103">/*!	This is the generic &quot;here's a file, now can someone please play it&quot;</a>
<a name="ln3104">	interface.</a>
<a name="ln3105">*/</a>
<a name="ln3106">status_t</a>
<a name="ln3107">BMediaRoster::SniffRef(const entry_ref&amp; file, uint64 requireNodeKinds,</a>
<a name="ln3108">	dormant_node_info* _node, BMimeType* mimeType)</a>
<a name="ln3109">{</a>
<a name="ln3110">	CALLED();</a>
<a name="ln3111"> </a>
<a name="ln3112">	TRACE(&quot;BMediaRoster::SniffRef looking for a node to handle %s: 0x%&quot; B_PRIx64</a>
<a name="ln3113">		&quot;\n&quot;, file.name, requireNodeKinds);</a>
<a name="ln3114"> </a>
<a name="ln3115">	if (_node == NULL)</a>
<a name="ln3116">		return B_BAD_VALUE;</a>
<a name="ln3117"> </a>
<a name="ln3118">	BMimeType aMimeType;</a>
<a name="ln3119"> </a>
<a name="ln3120">	dormant_node_info nodes[30];</a>
<a name="ln3121">	int32 count = 30;</a>
<a name="ln3122">	int32 highestCapability = -1;</a>
<a name="ln3123">	float capability;</a>
<a name="ln3124"> </a>
<a name="ln3125">	media_node node;</a>
<a name="ln3126"> </a>
<a name="ln3127">	// Get all dormant nodes using GetDormantNodes</a>
<a name="ln3128">	if (GetDormantNodes(nodes, &amp;count, NULL, NULL, NULL, requireNodeKinds | B_FILE_INTERFACE, 0) == B_OK) {</a>
<a name="ln3129">		// Call SniffRefFor on each node that matches requireNodeKinds</a>
<a name="ln3130">		for (int32 i=0;i&lt;count;i++) {</a>
<a name="ln3131">			if (InstantiateDormantNode(nodes[i], &amp;node) == B_OK) {</a>
<a name="ln3132"> </a>
<a name="ln3133">				if (SniffRefFor(node, file, &amp;aMimeType, &amp;capability) == B_OK) {</a>
<a name="ln3134">					// find the first node that has 100% capability</a>
<a name="ln3135">					TRACE(&quot;%s has a %f%% chance of playing file\n&quot;,nodes[i].name, capability * 100.0);</a>
<a name="ln3136">					if (capability == 1.0) {</a>
<a name="ln3137">						highestCapability = i;</a>
<a name="ln3138">						break;</a>
<a name="ln3139">					}</a>
<a name="ln3140">				}</a>
<a name="ln3141">				ReleaseNode(node);</a>
<a name="ln3142">			}</a>
<a name="ln3143">		}</a>
<a name="ln3144"> </a>
<a name="ln3145">		if (highestCapability != -1) {</a>
<a name="ln3146">			*_node = nodes[highestCapability];</a>
<a name="ln3147"> </a>
<a name="ln3148">			TRACE(&quot;BMediaRoster::SniffRef: found a node %s addon-id %&quot; B_PRId32</a>
<a name="ln3149">				&quot;, flavor_id %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln3150">			nodes[highestCapability].name, nodes[highestCapability].addon,</a>
<a name="ln3151">				nodes[highestCapability].flavor_id);</a>
<a name="ln3152"> </a>
<a name="ln3153">			if (mimeType != NULL) {</a>
<a name="ln3154">				//*mimeType = aMimeType; -- need a copy constructor</a>
<a name="ln3155">			}</a>
<a name="ln3156"> </a>
<a name="ln3157">			return B_OK;</a>
<a name="ln3158">		}</a>
<a name="ln3159"> </a>
<a name="ln3160">	}</a>
<a name="ln3161"> </a>
<a name="ln3162">	return B_ERROR;</a>
<a name="ln3163">}</a>
<a name="ln3164"> </a>
<a name="ln3165"> </a>
<a name="ln3166">status_t</a>
<a name="ln3167">BMediaRoster::GetDormantNodeForType(const BMimeType&amp; type,</a>
<a name="ln3168">	uint64 requireNodeKinds, dormant_node_info* _node)</a>
<a name="ln3169">{</a>
<a name="ln3170">	UNIMPLEMENTED();</a>
<a name="ln3171">	return B_ERROR;</a>
<a name="ln3172">}</a>
<a name="ln3173"> </a>
<a name="ln3174"> </a>
<a name="ln3175">status_t</a>
<a name="ln3176">BMediaRoster::GetReadFileFormatsFor(const dormant_node_info&amp; node,</a>
<a name="ln3177">	media_file_format* _readFormats, int32 readCount, int32* _readCount)</a>
<a name="ln3178">{</a>
<a name="ln3179">	UNIMPLEMENTED();</a>
<a name="ln3180">	return B_ERROR;</a>
<a name="ln3181">}</a>
<a name="ln3182"> </a>
<a name="ln3183"> </a>
<a name="ln3184">status_t</a>
<a name="ln3185">BMediaRoster::GetWriteFileFormatsFor(const dormant_node_info&amp; node,</a>
<a name="ln3186">	media_file_format* _write_formats, int32 writeCount, int32* _writeCount)</a>
<a name="ln3187">{</a>
<a name="ln3188">	UNIMPLEMENTED();</a>
<a name="ln3189">	return B_ERROR;</a>
<a name="ln3190">}</a>
<a name="ln3191"> </a>
<a name="ln3192"> </a>
<a name="ln3193">status_t</a>
<a name="ln3194">BMediaRoster::GetFormatFor(const media_output&amp; output, media_format* _format,</a>
<a name="ln3195">	uint32 flags)</a>
<a name="ln3196">{</a>
<a name="ln3197">	CALLED();</a>
<a name="ln3198">	if (_format == NULL)</a>
<a name="ln3199">		return B_BAD_VALUE;</a>
<a name="ln3200">	if ((output.node.kind &amp; B_BUFFER_PRODUCER) == 0)</a>
<a name="ln3201">		return B_MEDIA_BAD_NODE;</a>
<a name="ln3202">	if (IS_INVALID_SOURCE(output.source))</a>
<a name="ln3203">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln3204"> </a>
<a name="ln3205">	producer_format_suggestion_requested_request request;</a>
<a name="ln3206">	producer_format_suggestion_requested_reply reply;</a>
<a name="ln3207">	status_t rv;</a>
<a name="ln3208"> </a>
<a name="ln3209">	request.type = B_MEDIA_UNKNOWN_TYPE;</a>
<a name="ln3210">	request.quality = 0; // TODO: what should this be?</a>
<a name="ln3211"> </a>
<a name="ln3212">	rv = QueryPort(output.source.port, PRODUCER_FORMAT_SUGGESTION_REQUESTED,</a>
<a name="ln3213">		&amp;request, sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln3214">	if (rv != B_OK)</a>
<a name="ln3215">		return rv;</a>
<a name="ln3216"> </a>
<a name="ln3217">	*_format = reply.format;</a>
<a name="ln3218">	return B_OK;</a>
<a name="ln3219">}</a>
<a name="ln3220"> </a>
<a name="ln3221"> </a>
<a name="ln3222">status_t</a>
<a name="ln3223">BMediaRoster::GetFormatFor(const media_input&amp; input, media_format* _format,</a>
<a name="ln3224">	uint32 flags)</a>
<a name="ln3225">{</a>
<a name="ln3226">	CALLED();</a>
<a name="ln3227">	if (_format == NULL)</a>
<a name="ln3228">		return B_BAD_VALUE;</a>
<a name="ln3229">	if ((input.node.kind &amp; B_BUFFER_CONSUMER) == 0)</a>
<a name="ln3230">		return B_MEDIA_BAD_NODE;</a>
<a name="ln3231">	if (IS_INVALID_DESTINATION(input.destination))</a>
<a name="ln3232">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln3233"> </a>
<a name="ln3234">	consumer_accept_format_request request;</a>
<a name="ln3235">	consumer_accept_format_reply reply;</a>
<a name="ln3236">	status_t rv;</a>
<a name="ln3237"> </a>
<a name="ln3238">	request.dest = input.destination;</a>
<a name="ln3239">	request.format.Clear(); // wildcard</a>
<a name="ln3240"> </a>
<a name="ln3241">	rv = QueryPort(input.destination.port, CONSUMER_ACCEPT_FORMAT, &amp;request,</a>
<a name="ln3242">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln3243">	if (rv != B_OK)</a>
<a name="ln3244">		return rv;</a>
<a name="ln3245"> </a>
<a name="ln3246">	*_format = reply.format;</a>
<a name="ln3247">	return B_OK;</a>
<a name="ln3248">}</a>
<a name="ln3249"> </a>
<a name="ln3250"> </a>
<a name="ln3251">status_t</a>
<a name="ln3252">BMediaRoster::GetFormatFor(const media_node&amp; node, media_format* _format,</a>
<a name="ln3253">	float quality)</a>
<a name="ln3254">{</a>
<a name="ln3255">	UNIMPLEMENTED();</a>
<a name="ln3256">	if (_format == NULL)</a>
<a name="ln3257">		return B_BAD_VALUE;</a>
<a name="ln3258">	if (IS_INVALID_NODE(node))</a>
<a name="ln3259">		return B_MEDIA_BAD_NODE;</a>
<a name="ln3260">	if ((node.kind &amp; (B_BUFFER_CONSUMER | B_BUFFER_PRODUCER)) == 0)</a>
<a name="ln3261">		return B_MEDIA_BAD_NODE;</a>
<a name="ln3262"> </a>
<a name="ln3263">	return B_ERROR;</a>
<a name="ln3264">}</a>
<a name="ln3265"> </a>
<a name="ln3266"> </a>
<a name="ln3267">ssize_t</a>
<a name="ln3268">BMediaRoster::GetNodeAttributesFor(const media_node&amp; node,</a>
<a name="ln3269">	media_node_attribute* _array, size_t maxCount)</a>
<a name="ln3270">{</a>
<a name="ln3271">	CALLED();</a>
<a name="ln3272"> </a>
<a name="ln3273">	if (IS_INVALID_NODE(node))</a>
<a name="ln3274">		return B_MEDIA_BAD_NODE;</a>
<a name="ln3275"> </a>
<a name="ln3276">	node_get_attributes_for_request request;</a>
<a name="ln3277">	node_get_attributes_for_reply reply;</a>
<a name="ln3278">	status_t status;</a>
<a name="ln3279"> </a>
<a name="ln3280">	media_node_attribute* addr = NULL;</a>
<a name="ln3281">	size_t totalSize = maxCount*sizeof(media_node_attribute);</a>
<a name="ln3282">	size_t size = (totalSize + (B_PAGE_SIZE - 1)) &amp; ~(B_PAGE_SIZE - 1);</a>
<a name="ln3283"> </a>
<a name="ln3284">	area_id dataArea = create_area(&quot;attributes area&quot;, (void**)&amp;addr,</a>
<a name="ln3285">		B_ANY_ADDRESS, size, B_NO_LOCK,</a>
<a name="ln3286">		B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln3287">	// No need to memset the padding</a>
<a name="ln3288">	memset(addr, 0, totalSize);</a>
<a name="ln3289"> </a>
<a name="ln3290">	if (dataArea &lt; 0)</a>
<a name="ln3291">		return B_NO_MEMORY;</a>
<a name="ln3292"> </a>
<a name="ln3293">	request.count = maxCount;</a>
<a name="ln3294">	request.area = dataArea;</a>
<a name="ln3295"> </a>
<a name="ln3296">	status = QueryPort(node.port, NODE_GET_ATTRIBUTES_FOR, &amp;request,</a>
<a name="ln3297">		sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln3298">	if (status != B_OK)</a>
<a name="ln3299">		return status;</a>
<a name="ln3300"> </a>
<a name="ln3301">	memcpy(_array, addr, reply.filled_count</a>
<a name="ln3302">		* sizeof(media_node_attribute));</a>
<a name="ln3303"> </a>
<a name="ln3304">	delete_area(dataArea);</a>
<a name="ln3305">	return reply.filled_count;</a>
<a name="ln3306">}</a>
<a name="ln3307"> </a>
<a name="ln3308"> </a>
<a name="ln3309">media_node_id</a>
<a name="ln3310">BMediaRoster::NodeIDFor(port_id port)</a>
<a name="ln3311">{</a>
<a name="ln3312">	CALLED();</a>
<a name="ln3313"> </a>
<a name="ln3314">	server_node_id_for_request request;</a>
<a name="ln3315">	server_node_id_for_reply reply;</a>
<a name="ln3316">	status_t rv;</a>
<a name="ln3317"> </a>
<a name="ln3318">	request.port = port;</a>
<a name="ln3319"> </a>
<a name="ln3320">	rv = QueryServer(SERVER_NODE_ID_FOR, &amp;request, sizeof(request), &amp;reply,</a>
<a name="ln3321">		sizeof(reply));</a>
<a name="ln3322">	if (rv != B_OK) {</a>
<a name="ln3323">		ERROR(&quot;BMediaRoster::NodeIDFor: failed (error %#&quot; B_PRIx32 &quot;)\n&quot;, rv);</a>
<a name="ln3324">		return -1;</a>
<a name="ln3325">	}</a>
<a name="ln3326"> </a>
<a name="ln3327">	return reply.node_id;</a>
<a name="ln3328">}</a>
<a name="ln3329"> </a>
<a name="ln3330"> </a>
<a name="ln3331">status_t</a>
<a name="ln3332">BMediaRoster::GetInstancesFor(media_addon_id addon, int32 flavor,</a>
<a name="ln3333">	media_node_id* _id, int32* _count)</a>
<a name="ln3334">{</a>
<a name="ln3335">	CALLED();</a>
<a name="ln3336">	if (_id == NULL)</a>
<a name="ln3337">		return B_BAD_VALUE;</a>
<a name="ln3338">	if (_count &amp;&amp; *_count &lt;= 0)</a>
<a name="ln3339">		return B_BAD_VALUE;</a>
<a name="ln3340"> </a>
<a name="ln3341">	server_get_instances_for_request request;</a>
<a name="ln3342">	server_get_instances_for_reply reply;</a>
<a name="ln3343">	status_t rv;</a>
<a name="ln3344"> </a>
<a name="ln3345">	request.max_count = (_count ? *_count : 1);</a>
<a name="ln3346">	request.add_on_id = addon;</a>
<a name="ln3347">	request.flavor_id = flavor;</a>
<a name="ln3348"> </a>
<a name="ln3349">	rv = QueryServer(SERVER_GET_INSTANCES_FOR, &amp;request, sizeof(request),</a>
<a name="ln3350">		&amp;reply, sizeof(reply));</a>
<a name="ln3351">	if (rv != B_OK) {</a>
<a name="ln3352">		ERROR(&quot;BMediaRoster::GetLiveNodes failed\n&quot;);</a>
<a name="ln3353">		return rv;</a>
<a name="ln3354">	}</a>
<a name="ln3355"> </a>
<a name="ln3356">	if (_count)</a>
<a name="ln3357">		*_count = reply.count;</a>
<a name="ln3358">	if (reply.count &gt; 0)</a>
<a name="ln3359">		memcpy(_id, reply.node_id, sizeof(media_node_id) * reply.count);</a>
<a name="ln3360"> </a>
<a name="ln3361">	return B_OK;</a>
<a name="ln3362">}</a>
<a name="ln3363"> </a>
<a name="ln3364"> </a>
<a name="ln3365">bool</a>
<a name="ln3366">BMediaRoster::IsRunning()</a>
<a name="ln3367">{</a>
<a name="ln3368">	return be_roster-&gt;IsRunning(B_MEDIA_SERVER_SIGNATURE)</a>
<a name="ln3369">		&amp;&amp; be_roster-&gt;IsRunning(B_MEDIA_ADDON_SERVER_SIGNATURE);</a>
<a name="ln3370">}</a>
<a name="ln3371"> </a>
<a name="ln3372"> </a>
<a name="ln3373">ssize_t</a>
<a name="ln3374">BMediaRoster::AudioBufferSizeFor(int32 channelCount, uint32 sampleFormat,</a>
<a name="ln3375">	float frameRate, bus_type busKind)</a>
<a name="ln3376">{</a>
<a name="ln3377">	bigtime_t bufferDuration;</a>
<a name="ln3378">	ssize_t bufferSize;</a>
<a name="ln3379"> </a>
<a name="ln3380">	if (busKind == B_ISA_BUS || busKind == B_PCMCIA_BUS)</a>
<a name="ln3381">		bufferDuration = 25000;</a>
<a name="ln3382">	else</a>
<a name="ln3383">		bufferDuration = 10000;</a>
<a name="ln3384"> </a>
<a name="ln3385">	bufferSize = (sampleFormat &amp; 0xf) * channelCount</a>
<a name="ln3386">		* (ssize_t)((frameRate * bufferDuration) / 1000000.0);</a>
<a name="ln3387"> </a>
<a name="ln3388">	printf(&quot;Suggested buffer duration %&quot; B_PRId64 &quot;, size %&quot; B_PRIdSSIZE &quot;\n&quot;,</a>
<a name="ln3389">		bufferDuration, bufferSize);</a>
<a name="ln3390"> </a>
<a name="ln3391">	return bufferSize;</a>
<a name="ln3392">}</a>
<a name="ln3393"> </a>
<a name="ln3394"> </a>
<a name="ln3395">/*!	Use MediaFlags to inquire about specific features of the Media Kit.</a>
<a name="ln3396">	Returns &lt; 0 for &quot;not present&quot;, positive size for output data size.</a>
<a name="ln3397">	0 means that the capability is present, but no data about it.</a>
<a name="ln3398">*/</a>
<a name="ln3399">/*static*/ ssize_t</a>
<a name="ln3400">BMediaRoster::MediaFlags(media_flags cap, void* buffer, size_t maxSize)</a>
<a name="ln3401">{</a>
<a name="ln3402">	UNIMPLEMENTED();</a>
<a name="ln3403">	return 0;</a>
<a name="ln3404">}</a>
<a name="ln3405"> </a>
<a name="ln3406"> </a>
<a name="ln3407">//	#pragma mark - BLooper overrides</a>
<a name="ln3408"> </a>
<a name="ln3409"> </a>
<a name="ln3410">void</a>
<a name="ln3411">BMediaRoster::MessageReceived(BMessage* message)</a>
<a name="ln3412">{</a>
<a name="ln3413">	switch (message-&gt;what) {</a>
<a name="ln3414">		case MEDIA_ROSTER_REQUEST_NOTIFICATIONS:</a>
<a name="ln3415">		{</a>
<a name="ln3416">			RosterNotification notification;</a>
<a name="ln3417">			if (message-&gt;FindInt32(NOTIFICATION_PARAM_WHAT, &amp;notification.what)</a>
<a name="ln3418">					!= B_OK) {</a>
<a name="ln3419">				TRACE(&quot;BMediaRoster MEDIA_ROSTER_REQUEST_NOTIFICATIONS can't&quot;</a>
<a name="ln3420">					&quot;find what parameter&quot;);</a>
<a name="ln3421">				return;</a>
<a name="ln3422">			}</a>
<a name="ln3423">			if (message-&gt;FindMessenger(NOTIFICATION_PARAM_MESSENGER,</a>
<a name="ln3424">					&amp;notification.messenger) != B_OK) {</a>
<a name="ln3425">				TRACE(&quot;BMediaRoster MEDIA_ROSTER_REQUEST_NOTIFICATIONS can't&quot;</a>
<a name="ln3426">					&quot;find messenger&quot;);</a>
<a name="ln3427">				return;</a>
<a name="ln3428">			}</a>
<a name="ln3429">			sNotificationList.Insert(notification);</a>
<a name="ln3430">			return;</a>
<a name="ln3431">		}</a>
<a name="ln3432"> </a>
<a name="ln3433">		case MEDIA_ROSTER_CANCEL_NOTIFICATIONS:</a>
<a name="ln3434">		{</a>
<a name="ln3435">			RosterNotification notification;</a>
<a name="ln3436">			if (message-&gt;FindInt32(NOTIFICATION_PARAM_WHAT, &amp;notification.what)</a>
<a name="ln3437">					!= B_OK) {</a>
<a name="ln3438">				TRACE(&quot;BMediaRoster MEDIA_ROSTER_CANCEL_NOTIFICATIONS can't&quot;</a>
<a name="ln3439">					&quot;find what parameter&quot;);</a>
<a name="ln3440">				return;</a>
<a name="ln3441">			}</a>
<a name="ln3442">			if (message-&gt;FindMessenger(NOTIFICATION_PARAM_MESSENGER,</a>
<a name="ln3443">					&amp;notification.messenger) != B_OK) {</a>
<a name="ln3444">				TRACE(&quot;BMediaRoster MEDIA_ROSTER_CANCEL_NOTIFICATIONS can't&quot;</a>
<a name="ln3445">					&quot;find messenger&quot;);</a>
<a name="ln3446">				return;</a>
<a name="ln3447">			}</a>
<a name="ln3448">			for (int32 i = 0; i &lt; sNotificationList.CountItems(); i++) {</a>
<a name="ln3449">				RosterNotification* current;</a>
<a name="ln3450">				if (sNotificationList.Get(i, &amp;current) != true)</a>
<a name="ln3451">					return;</a>
<a name="ln3452">				if (current-&gt;what == notification.what</a>
<a name="ln3453">						&amp;&amp; current-&gt;messenger == notification.messenger) {</a>
<a name="ln3454">					sNotificationList.Remove(i);</a>
<a name="ln3455">					return;</a>
<a name="ln3456">				}</a>
<a name="ln3457">			}</a>
<a name="ln3458">			return;</a>
<a name="ln3459">		}</a>
<a name="ln3460"> </a>
<a name="ln3461">		case B_SOME_APP_LAUNCHED:</a>
<a name="ln3462">		{</a>
<a name="ln3463">			BString mimeSig;</a>
<a name="ln3464">			if (message-&gt;FindString(&quot;be:signature&quot;, &amp;mimeSig) != B_OK)</a>
<a name="ln3465">				return;</a>
<a name="ln3466">			if (mimeSig != B_MEDIA_ADDON_SERVER_SIGNATURE</a>
<a name="ln3467">					&amp;&amp; mimeSig != B_MEDIA_SERVER_SIGNATURE)</a>
<a name="ln3468">				return;</a>
<a name="ln3469"> </a>
<a name="ln3470">			TRACE(&quot;BMediaRoster::MessageReceived media services are going up.&quot;);</a>
<a name="ln3471"> </a>
<a name="ln3472">			if (BMediaRoster::IsRunning()) {</a>
<a name="ln3473">				// Wait for media services to wake up and restore our friendship</a>
<a name="ln3474">				if (MediaRosterEx(this)-&gt;BuildConnections() != B_OK) {</a>
<a name="ln3475">					TRACE(&quot;BMediaRoster::MessageReceived can't reconnect&quot;</a>
<a name="ln3476">						&quot;to media_server.&quot;);</a>
<a name="ln3477">				}</a>
<a name="ln3478">			}</a>
<a name="ln3479">			return;</a>
<a name="ln3480">		}</a>
<a name="ln3481"> </a>
<a name="ln3482">		case B_SOME_APP_QUIT:</a>
<a name="ln3483">		{</a>
<a name="ln3484">			BString mimeSig;</a>
<a name="ln3485">			if (message-&gt;FindString(&quot;be:signature&quot;, &amp;mimeSig) != B_OK)</a>
<a name="ln3486">				return;</a>
<a name="ln3487">			if (mimeSig != B_MEDIA_ADDON_SERVER_SIGNATURE</a>
<a name="ln3488">					&amp;&amp; mimeSig != B_MEDIA_SERVER_SIGNATURE)</a>
<a name="ln3489">				return;</a>
<a name="ln3490"> </a>
<a name="ln3491">			TRACE(&quot;BMediaRoster::MessageReceived media services are down.&quot;);</a>
<a name="ln3492"> </a>
<a name="ln3493">			// Send the notification to our subscribers</a>
<a name="ln3494">			if (!BMediaRoster::IsRunning() &amp;&amp; sServerIsUp == true) {</a>
<a name="ln3495">				sServerIsUp = false;</a>
<a name="ln3496">				for (int32 i = 0; i &lt; sNotificationList.CountItems(); i++) {</a>
<a name="ln3497">					RosterNotification* current;</a>
<a name="ln3498">					if (sNotificationList.Get(i, &amp;current) != true)</a>
<a name="ln3499">						return;</a>
<a name="ln3500">					if (current-&gt;what == B_MEDIA_SERVER_QUIT) {</a>
<a name="ln3501">						if (current-&gt;messenger.SendMessage(</a>
<a name="ln3502">								B_MEDIA_SERVER_QUIT) != B_OK) {</a>
<a name="ln3503">							if(!current-&gt;messenger.IsValid())</a>
<a name="ln3504">								sNotificationList.Remove(i);</a>
<a name="ln3505">						}</a>
<a name="ln3506">					}</a>
<a name="ln3507">				}</a>
<a name="ln3508">			}</a>
<a name="ln3509">			return;</a>
<a name="ln3510">		}</a>
<a name="ln3511"> </a>
<a name="ln3512">		case MEDIA_SERVER_ALIVE:</a>
<a name="ln3513">		{</a>
<a name="ln3514">			if (!BMediaRoster::IsRunning())</a>
<a name="ln3515">				return;</a>
<a name="ln3516"> </a>
<a name="ln3517">			sServerIsUp = true;</a>
<a name="ln3518"> </a>
<a name="ln3519">			TRACE(&quot;BMediaRoster::MessageReceived media services are&quot;</a>
<a name="ln3520">				&quot; finally up.&quot;);</a>
<a name="ln3521"> </a>
<a name="ln3522">			if (MediaRosterEx(this)-&gt;fLaunchNotification) {</a>
<a name="ln3523">				progress_startup(100, NULL, NULL);</a>
<a name="ln3524">				if (MediaRosterEx(this)-&gt;fAutoExit)</a>
<a name="ln3525">					MediaRosterEx(this)-&gt;fLaunchNotification = false;</a>
<a name="ln3526">			}</a>
<a name="ln3527"> </a>
<a name="ln3528">			// Send the notification to our subscribers</a>
<a name="ln3529">			for (int32 i = 0; i &lt; sNotificationList.CountItems(); i++) {</a>
<a name="ln3530">				RosterNotification* current;</a>
<a name="ln3531">				if (sNotificationList.Get(i, &amp;current) != true)</a>
<a name="ln3532">					return;</a>
<a name="ln3533">				if (current-&gt;what == B_MEDIA_SERVER_STARTED) {</a>
<a name="ln3534">					if (current-&gt;messenger.SendMessage(</a>
<a name="ln3535">							B_MEDIA_SERVER_STARTED) != B_OK) {</a>
<a name="ln3536">						if(!current-&gt;messenger.IsValid())</a>
<a name="ln3537">							sNotificationList.Remove(i);</a>
<a name="ln3538">					}</a>
<a name="ln3539">				}</a>
<a name="ln3540">			}</a>
<a name="ln3541">			return;</a>
<a name="ln3542">		}</a>
<a name="ln3543"> </a>
<a name="ln3544">		case NODE_FINAL_RELEASE:</a>
<a name="ln3545">		{</a>
<a name="ln3546">			// This function is called by a BMediaNode to delete</a>
<a name="ln3547">			// itself, as this needs to be done from another thread</a>
<a name="ln3548">			// context, it is done here.</a>
<a name="ln3549"> </a>
<a name="ln3550">			BMediaNode* node = NULL;</a>
<a name="ln3551">			status_t err = message-&gt;FindPointer(&quot;node&quot;,</a>
<a name="ln3552">				reinterpret_cast&lt;void **&gt;(&amp;node));</a>
<a name="ln3553">			if (err == B_OK &amp;&amp; node != NULL)</a>
<a name="ln3554">				node-&gt;Release();</a>
<a name="ln3555">			else {</a>
<a name="ln3556">				TRACE(&quot;BMediaRoster::MessageReceived: CRITICAL! received&quot;</a>
<a name="ln3557">					&quot;a release request but the node can't be found.&quot;);</a>
<a name="ln3558">			}</a>
<a name="ln3559">			return;</a>
<a name="ln3560">		}</a>
<a name="ln3561"> </a>
<a name="ln3562">		default:</a>
<a name="ln3563">			BLooper::MessageReceived(message);</a>
<a name="ln3564">			break;</a>
<a name="ln3565">	}</a>
<a name="ln3566">}</a>
<a name="ln3567"> </a>
<a name="ln3568"> </a>
<a name="ln3569">bool</a>
<a name="ln3570">BMediaRoster::QuitRequested()</a>
<a name="ln3571">{</a>
<a name="ln3572">	CALLED();</a>
<a name="ln3573">	return true;</a>
<a name="ln3574">}</a>
<a name="ln3575"> </a>
<a name="ln3576"> </a>
<a name="ln3577">BHandler*</a>
<a name="ln3578">BMediaRoster::ResolveSpecifier(BMessage* msg, int32 index, BMessage* specifier,</a>
<a name="ln3579">	int32 form, const char* property)</a>
<a name="ln3580">{</a>
<a name="ln3581">	return BLooper::ResolveSpecifier(msg, index, specifier, form, property);</a>
<a name="ln3582">}</a>
<a name="ln3583"> </a>
<a name="ln3584"> </a>
<a name="ln3585">status_t</a>
<a name="ln3586">BMediaRoster::GetSupportedSuites(BMessage* data)</a>
<a name="ln3587">{</a>
<a name="ln3588">	return BLooper::GetSupportedSuites(data);</a>
<a name="ln3589">}</a>
<a name="ln3590"> </a>
<a name="ln3591"> </a>
<a name="ln3592">BMediaRoster::~BMediaRoster()</a>
<a name="ln3593">{</a>
<a name="ln3594">	CALLED();</a>
<a name="ln3595"> </a>
<a name="ln3596">	// Unset the global instance pointer, the destructor is also called</a>
<a name="ln3597">	// if a client app calls Lock(); and Quit(); directly.</a>
<a name="ln3598">	sDefaultInstance = NULL;</a>
<a name="ln3599">}</a>
<a name="ln3600"> </a>
<a name="ln3601">//	#pragma mark - private BMediaRoster</a>
<a name="ln3602"> </a>
<a name="ln3603">// FBC reserved virtuals</a>
<a name="ln3604">status_t BMediaRoster::_Reserved_MediaRoster_0(void*) { return B_ERROR; }</a>
<a name="ln3605">status_t BMediaRoster::_Reserved_MediaRoster_1(void*) { return B_ERROR; }</a>
<a name="ln3606">status_t BMediaRoster::_Reserved_MediaRoster_2(void*) { return B_ERROR; }</a>
<a name="ln3607">status_t BMediaRoster::_Reserved_MediaRoster_3(void*) { return B_ERROR; }</a>
<a name="ln3608">status_t BMediaRoster::_Reserved_MediaRoster_4(void*) { return B_ERROR; }</a>
<a name="ln3609">status_t BMediaRoster::_Reserved_MediaRoster_5(void*) { return B_ERROR; }</a>
<a name="ln3610">status_t BMediaRoster::_Reserved_MediaRoster_6(void*) { return B_ERROR; }</a>
<a name="ln3611">status_t BMediaRoster::_Reserved_MediaRoster_7(void*) { return B_ERROR; }</a>
<a name="ln3612"> </a>
<a name="ln3613"> </a>
<a name="ln3614">BMediaRoster::BMediaRoster()</a>
<a name="ln3615">	:</a>
<a name="ln3616">	BLooper(&quot;_BMediaRoster_&quot;, B_URGENT_DISPLAY_PRIORITY,</a>
<a name="ln3617">		B_LOOPER_PORT_DEFAULT_CAPACITY)</a>
<a name="ln3618">{</a>
<a name="ln3619">	CALLED();</a>
<a name="ln3620"> </a>
<a name="ln3621">	// start the looper</a>
<a name="ln3622">	Run();</a>
<a name="ln3623">}</a>
<a name="ln3624"> </a>
<a name="ln3625">// #pragma mark - static variables</a>
<a name="ln3626"> </a>
<a name="ln3627">BMediaRoster* BMediaRoster::sDefaultInstance = NULL;</a>

</code></pre>
<div class="balloon" rel="1550"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized variable 'dummy' used. Consider checking the third actual argument of the 'write_port' function.</p></div>
<div class="balloon" rel="2842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v641/" target="_blank">V641</a> The size of the allocated memory buffer is not a multiple of the element size.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
