
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>vfs.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2009, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Copyright 2001-2002, Travis Geiselbrecht. All rights reserved.</a>
<a name="ln6"> * Distributed under the terms of the NewOS License.</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9">/*! Virtual File System and File System Interface Layer */</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;vfs.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;new&gt;</a>
<a name="ln14">#include &lt;stdlib.h&gt;</a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;fd.h&quot;</a>
<a name="ln18">#include &quot;fssh_atomic.h&quot;</a>
<a name="ln19">#include &quot;fssh_defs.h&quot;</a>
<a name="ln20">#include &quot;fssh_dirent.h&quot;</a>
<a name="ln21">#include &quot;fssh_errno.h&quot;</a>
<a name="ln22">#include &quot;fssh_fcntl.h&quot;</a>
<a name="ln23">#include &quot;fssh_fs_info.h&quot;</a>
<a name="ln24">#include &quot;fssh_fs_volume.h&quot;</a>
<a name="ln25">#include &quot;fssh_kernel_export.h&quot;</a>
<a name="ln26">#include &quot;fssh_module.h&quot;</a>
<a name="ln27">#include &quot;fssh_stat.h&quot;</a>
<a name="ln28">#include &quot;fssh_stdio.h&quot;</a>
<a name="ln29">#include &quot;fssh_string.h&quot;</a>
<a name="ln30">#include &quot;fssh_uio.h&quot;</a>
<a name="ln31">#include &quot;fssh_unistd.h&quot;</a>
<a name="ln32">#include &quot;hash.h&quot;</a>
<a name="ln33">#include &quot;KPath.h&quot;</a>
<a name="ln34">#include &quot;posix_compatibility.h&quot;</a>
<a name="ln35">#include &quot;syscalls.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">//#define TRACE_VFS</a>
<a name="ln38">#ifdef TRACE_VFS</a>
<a name="ln39">#	define TRACE(x) fssh_dprintf x</a>
<a name="ln40">#	define FUNCTION(x) fssh_dprintf x</a>
<a name="ln41">#else</a>
<a name="ln42">#	define TRACE(x) ;</a>
<a name="ln43">#	define FUNCTION(x) ;</a>
<a name="ln44">#endif</a>
<a name="ln45"> </a>
<a name="ln46">#define ADD_DEBUGGER_COMMANDS</a>
<a name="ln47"> </a>
<a name="ln48">#define ASSERT_LOCKED_MUTEX(x)</a>
<a name="ln49">#define ASSERT(x)</a>
<a name="ln50"> </a>
<a name="ln51">namespace FSShell {</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">#define HAS_FS_CALL(vnode, op)			(vnode-&gt;ops-&gt;op != NULL)</a>
<a name="ln55">#define HAS_FS_MOUNT_CALL(mount, op)	(mount-&gt;volume-&gt;ops-&gt;op != NULL)</a>
<a name="ln56"> </a>
<a name="ln57">#define FS_CALL(vnode, op, params...) \</a>
<a name="ln58">			vnode-&gt;ops-&gt;op(vnode-&gt;mount-&gt;volume, vnode, params)</a>
<a name="ln59">#define FS_CALL_NO_PARAMS(vnode, op) \</a>
<a name="ln60">			vnode-&gt;ops-&gt;op(vnode-&gt;mount-&gt;volume, vnode)</a>
<a name="ln61">#define FS_MOUNT_CALL(mount, op, params...) \</a>
<a name="ln62">			mount-&gt;volume-&gt;ops-&gt;op(mount-&gt;volume, params)</a>
<a name="ln63">#define FS_MOUNT_CALL_NO_PARAMS(mount, op) \</a>
<a name="ln64">			mount-&gt;volume-&gt;ops-&gt;op(mount-&gt;volume)</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">const static uint32_t kMaxUnusedVnodes = 16;</a>
<a name="ln68">	// This is the maximum number of unused vnodes that the system</a>
<a name="ln69">	// will keep around (weak limit, if there is enough memory left,</a>
<a name="ln70">	// they won't get flushed even when hitting that limit).</a>
<a name="ln71">	// It may be chosen with respect to the available memory or enhanced</a>
<a name="ln72">	// by some timestamp/frequency heurism.</a>
<a name="ln73"> </a>
<a name="ln74">struct vnode : fssh_fs_vnode {</a>
<a name="ln75">	struct vnode	*next;</a>
<a name="ln76">	vm_cache_ref	*cache;</a>
<a name="ln77">	fssh_mount_id	device;</a>
<a name="ln78">	list_link		mount_link;</a>
<a name="ln79">	list_link		unused_link;</a>
<a name="ln80">	fssh_vnode_id	id;</a>
<a name="ln81">	struct fs_mount	*mount;</a>
<a name="ln82">	struct vnode	*covered_by;</a>
<a name="ln83">	int32_t			ref_count;</a>
<a name="ln84">	uint32_t		type : 29;</a>
<a name="ln85">						// TODO: S_INDEX_DIR actually needs another bit.</a>
<a name="ln86">						// Better combine this field with the following ones.</a>
<a name="ln87">	uint32_t		remove : 1;</a>
<a name="ln88">	uint32_t		busy : 1;</a>
<a name="ln89">	uint32_t		unpublished : 1;</a>
<a name="ln90">	struct file_descriptor *mandatory_locked_by;</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93">struct vnode_hash_key {</a>
<a name="ln94">	fssh_mount_id	device;</a>
<a name="ln95">	fssh_vnode_id	vnode;</a>
<a name="ln96">};</a>
<a name="ln97"> </a>
<a name="ln98">/**	\brief Structure to manage a mounted file system</a>
<a name="ln99"> </a>
<a name="ln100">	Note: The root_vnode and covers_vnode fields (what others?) are</a>
<a name="ln101">	initialized in fs_mount() and not changed afterwards. That is as soon</a>
<a name="ln102">	as the mount is mounted and it is made sure it won't be unmounted</a>
<a name="ln103">	(e.g. by holding a reference to a vnode of that mount) (read) access</a>
<a name="ln104">	to those fields is always safe, even without additional locking. Morever</a>
<a name="ln105">	while mounted the mount holds a reference to the covers_vnode, and thus</a>
<a name="ln106">	making the access path vnode-&gt;mount-&gt;covers_vnode-&gt;mount-&gt;... safe if a</a>
<a name="ln107">	reference to vnode is held (note that for the root mount covers_vnode</a>
<a name="ln108">	is NULL, though).</a>
<a name="ln109"> */</a>
<a name="ln110">struct fs_mount {</a>
<a name="ln111">	struct fs_mount	*next;</a>
<a name="ln112">	fssh_file_system_module_info *fs;</a>
<a name="ln113">	fssh_mount_id		id;</a>
<a name="ln114">	fssh_fs_volume		*volume;</a>
<a name="ln115">	char			*device_name;</a>
<a name="ln116">	char			*fs_name;</a>
<a name="ln117">	fssh_recursive_lock	rlock;	// guards the vnodes list</a>
<a name="ln118">	struct vnode	*root_vnode;</a>
<a name="ln119">	struct vnode	*covers_vnode;</a>
<a name="ln120">	struct list		vnodes;</a>
<a name="ln121">	bool			unmounting;</a>
<a name="ln122">	bool			owns_file_device;</a>
<a name="ln123">};</a>
<a name="ln124"> </a>
<a name="ln125">static fssh_mutex sFileSystemsMutex;</a>
<a name="ln126"> </a>
<a name="ln127">/**	\brief Guards sMountsTable.</a>
<a name="ln128"> *</a>
<a name="ln129"> *	The holder is allowed to read/write access the sMountsTable.</a>
<a name="ln130"> *	Manipulation of the fs_mount structures themselves</a>
<a name="ln131"> *	(and their destruction) requires different locks though.</a>
<a name="ln132"> */</a>
<a name="ln133">static fssh_mutex sMountMutex;</a>
<a name="ln134"> </a>
<a name="ln135">/**	\brief Guards mount/unmount operations.</a>
<a name="ln136"> *</a>
<a name="ln137"> *	The fs_mount() and fs_unmount() hold the lock during their whole operation.</a>
<a name="ln138"> *	That is locking the lock ensures that no FS is mounted/unmounted. In</a>
<a name="ln139"> *	particular this means that</a>
<a name="ln140"> *	- sMountsTable will not be modified,</a>
<a name="ln141"> *	- the fields immutable after initialization of the fs_mount structures in</a>
<a name="ln142"> *	  sMountsTable will not be modified,</a>
<a name="ln143"> *	- vnode::covered_by of any vnode in sVnodeTable will not be modified.</a>
<a name="ln144"> *</a>
<a name="ln145"> *	The thread trying to lock the lock must not hold sVnodeMutex or</a>
<a name="ln146"> *	sMountMutex.</a>
<a name="ln147"> */</a>
<a name="ln148">static fssh_recursive_lock sMountOpLock;</a>
<a name="ln149"> </a>
<a name="ln150">/**	\brief Guards the vnode::covered_by field of any vnode</a>
<a name="ln151"> *</a>
<a name="ln152"> *	The holder is allowed to read access the vnode::covered_by field of any</a>
<a name="ln153"> *	vnode. Additionally holding sMountOpLock allows for write access.</a>
<a name="ln154"> *</a>
<a name="ln155"> *	The thread trying to lock the must not hold sVnodeMutex.</a>
<a name="ln156"> */</a>
<a name="ln157">static fssh_mutex sVnodeCoveredByMutex;</a>
<a name="ln158"> </a>
<a name="ln159">/**	\brief Guards sVnodeTable.</a>
<a name="ln160"> *</a>
<a name="ln161"> *	The holder is allowed to read/write access sVnodeTable and to</a>
<a name="ln162"> *	to any unbusy vnode in that table, save</a>
<a name="ln163"> *	to the immutable fields (device, id, private_node, mount) to which</a>
<a name="ln164"> *	only read-only access is allowed, and to the field covered_by, which is</a>
<a name="ln165"> *	guarded by sMountOpLock and sVnodeCoveredByMutex.</a>
<a name="ln166"> *</a>
<a name="ln167"> *	The thread trying to lock the mutex must not hold sMountMutex.</a>
<a name="ln168"> *	You must not have this mutex held when calling create_sem(), as this</a>
<a name="ln169"> *	might call vfs_free_unused_vnodes().</a>
<a name="ln170"> */</a>
<a name="ln171">static fssh_mutex sVnodeMutex;</a>
<a name="ln172"> </a>
<a name="ln173">#define VNODE_HASH_TABLE_SIZE 1024</a>
<a name="ln174">static hash_table *sVnodeTable;</a>
<a name="ln175">static list sUnusedVnodeList;</a>
<a name="ln176">static uint32_t sUnusedVnodes = 0;</a>
<a name="ln177">static struct vnode *sRoot;</a>
<a name="ln178"> </a>
<a name="ln179">#define MOUNTS_HASH_TABLE_SIZE 16</a>
<a name="ln180">static hash_table *sMountsTable;</a>
<a name="ln181">static fssh_mount_id sNextMountID = 1;</a>
<a name="ln182"> </a>
<a name="ln183">#define MAX_TEMP_IO_VECS 8</a>
<a name="ln184"> </a>
<a name="ln185">fssh_mode_t __fssh_gUmask = 022;</a>
<a name="ln186"> </a>
<a name="ln187">/* function declarations */</a>
<a name="ln188"> </a>
<a name="ln189">// file descriptor operation prototypes</a>
<a name="ln190">static fssh_status_t file_read(struct file_descriptor *, fssh_off_t pos,</a>
<a name="ln191">			void *buffer, fssh_size_t *);</a>
<a name="ln192">static fssh_status_t file_write(struct file_descriptor *, fssh_off_t pos,</a>
<a name="ln193">			const void *buffer, fssh_size_t *);</a>
<a name="ln194">static fssh_off_t file_seek(struct file_descriptor *, fssh_off_t pos,</a>
<a name="ln195">			int seek_type);</a>
<a name="ln196">static void file_free_fd(struct file_descriptor *);</a>
<a name="ln197">static fssh_status_t file_close(struct file_descriptor *);</a>
<a name="ln198">static fssh_status_t dir_read(struct file_descriptor *,</a>
<a name="ln199">			struct fssh_dirent *buffer, fssh_size_t bufferSize,</a>
<a name="ln200">			uint32_t *_count);</a>
<a name="ln201">static fssh_status_t dir_read(struct vnode *vnode, void *cookie,</a>
<a name="ln202">			struct fssh_dirent *buffer, fssh_size_t bufferSize,</a>
<a name="ln203">			uint32_t *_count);</a>
<a name="ln204">static fssh_status_t dir_rewind(struct file_descriptor *);</a>
<a name="ln205">static void dir_free_fd(struct file_descriptor *);</a>
<a name="ln206">static fssh_status_t dir_close(struct file_descriptor *);</a>
<a name="ln207">static fssh_status_t attr_dir_read(struct file_descriptor *,</a>
<a name="ln208">			struct fssh_dirent *buffer, fssh_size_t bufferSize,</a>
<a name="ln209">			uint32_t *_count);</a>
<a name="ln210">static fssh_status_t attr_dir_rewind(struct file_descriptor *);</a>
<a name="ln211">static void attr_dir_free_fd(struct file_descriptor *);</a>
<a name="ln212">static fssh_status_t attr_dir_close(struct file_descriptor *);</a>
<a name="ln213">static fssh_status_t attr_read(struct file_descriptor *, fssh_off_t pos,</a>
<a name="ln214">			void *buffer, fssh_size_t *);</a>
<a name="ln215">static fssh_status_t attr_write(struct file_descriptor *, fssh_off_t pos,</a>
<a name="ln216">			const void *buffer, fssh_size_t *);</a>
<a name="ln217">static fssh_off_t attr_seek(struct file_descriptor *, fssh_off_t pos,</a>
<a name="ln218">			int seek_type);</a>
<a name="ln219">static void attr_free_fd(struct file_descriptor *);</a>
<a name="ln220">static fssh_status_t attr_close(struct file_descriptor *);</a>
<a name="ln221">static fssh_status_t attr_read_stat(struct file_descriptor *,</a>
<a name="ln222">			struct fssh_stat *);</a>
<a name="ln223">static fssh_status_t attr_write_stat(struct file_descriptor *,</a>
<a name="ln224">			const struct fssh_stat *, int statMask);</a>
<a name="ln225">static fssh_status_t index_dir_read(struct file_descriptor *,</a>
<a name="ln226">			struct fssh_dirent *buffer, fssh_size_t bufferSize,</a>
<a name="ln227">			uint32_t *_count);</a>
<a name="ln228">static fssh_status_t index_dir_rewind(struct file_descriptor *);</a>
<a name="ln229">static void index_dir_free_fd(struct file_descriptor *);</a>
<a name="ln230">static fssh_status_t index_dir_close(struct file_descriptor *);</a>
<a name="ln231">static fssh_status_t query_read(struct file_descriptor *,</a>
<a name="ln232">			struct fssh_dirent *buffer, fssh_size_t bufferSize,</a>
<a name="ln233">			uint32_t *_count);</a>
<a name="ln234">static fssh_status_t query_rewind(struct file_descriptor *);</a>
<a name="ln235">static void query_free_fd(struct file_descriptor *);</a>
<a name="ln236">static fssh_status_t query_close(struct file_descriptor *);</a>
<a name="ln237"> </a>
<a name="ln238">static fssh_status_t common_ioctl(struct file_descriptor *, uint32_t, void *buf,</a>
<a name="ln239">			fssh_size_t len);</a>
<a name="ln240">static fssh_status_t common_read_stat(struct file_descriptor *,</a>
<a name="ln241">			struct fssh_stat *);</a>
<a name="ln242">static fssh_status_t common_write_stat(struct file_descriptor *,</a>
<a name="ln243">			const struct fssh_stat *, int statMask);</a>
<a name="ln244"> </a>
<a name="ln245">static fssh_status_t vnode_path_to_vnode(struct vnode *vnode, char *path,</a>
<a name="ln246">			bool traverseLeafLink, int count, struct vnode **_vnode,</a>
<a name="ln247">			fssh_vnode_id *_parentID);</a>
<a name="ln248">static fssh_status_t dir_vnode_to_path(struct vnode *vnode, char *buffer,</a>
<a name="ln249">			fssh_size_t bufferSize);</a>
<a name="ln250">static fssh_status_t fd_and_path_to_vnode(int fd, char *path,</a>
<a name="ln251">			bool traverseLeafLink, struct vnode **_vnode,</a>
<a name="ln252">			fssh_vnode_id *_parentID, bool kernel);</a>
<a name="ln253">static void inc_vnode_ref_count(struct vnode *vnode);</a>
<a name="ln254">static fssh_status_t dec_vnode_ref_count(struct vnode *vnode, bool reenter);</a>
<a name="ln255">static inline void put_vnode(struct vnode *vnode);</a>
<a name="ln256"> </a>
<a name="ln257">static struct fd_ops sFileOps = {</a>
<a name="ln258">	file_read,</a>
<a name="ln259">	file_write,</a>
<a name="ln260">	file_seek,</a>
<a name="ln261">	common_ioctl,</a>
<a name="ln262">	NULL,</a>
<a name="ln263">	NULL,</a>
<a name="ln264">	NULL,		// read_dir()</a>
<a name="ln265">	NULL,		// rewind_dir()</a>
<a name="ln266">	common_read_stat,</a>
<a name="ln267">	common_write_stat,</a>
<a name="ln268">	file_close,</a>
<a name="ln269">	file_free_fd</a>
<a name="ln270">};</a>
<a name="ln271"> </a>
<a name="ln272">static struct fd_ops sDirectoryOps = {</a>
<a name="ln273">	NULL,		// read()</a>
<a name="ln274">	NULL,		// write()</a>
<a name="ln275">	NULL,		// seek()</a>
<a name="ln276">	common_ioctl,</a>
<a name="ln277">	NULL,		// select()</a>
<a name="ln278">	NULL,		// deselect()</a>
<a name="ln279">	dir_read,</a>
<a name="ln280">	dir_rewind,</a>
<a name="ln281">	common_read_stat,</a>
<a name="ln282">	common_write_stat,</a>
<a name="ln283">	dir_close,</a>
<a name="ln284">	dir_free_fd</a>
<a name="ln285">};</a>
<a name="ln286"> </a>
<a name="ln287">static struct fd_ops sAttributeDirectoryOps = {</a>
<a name="ln288">	NULL,		// read()</a>
<a name="ln289">	NULL,		// write()</a>
<a name="ln290">	NULL,		// seek()</a>
<a name="ln291">	common_ioctl,</a>
<a name="ln292">	NULL,		// select()</a>
<a name="ln293">	NULL,		// deselect()</a>
<a name="ln294">	attr_dir_read,</a>
<a name="ln295">	attr_dir_rewind,</a>
<a name="ln296">	common_read_stat,</a>
<a name="ln297">	common_write_stat,</a>
<a name="ln298">	attr_dir_close,</a>
<a name="ln299">	attr_dir_free_fd</a>
<a name="ln300">};</a>
<a name="ln301"> </a>
<a name="ln302">static struct fd_ops sAttributeOps = {</a>
<a name="ln303">	attr_read,</a>
<a name="ln304">	attr_write,</a>
<a name="ln305">	attr_seek,</a>
<a name="ln306">	common_ioctl,</a>
<a name="ln307">	NULL,		// select()</a>
<a name="ln308">	NULL,		// deselect()</a>
<a name="ln309">	NULL,		// read_dir()</a>
<a name="ln310">	NULL,		// rewind_dir()</a>
<a name="ln311">	attr_read_stat,</a>
<a name="ln312">	attr_write_stat,</a>
<a name="ln313">	attr_close,</a>
<a name="ln314">	attr_free_fd</a>
<a name="ln315">};</a>
<a name="ln316"> </a>
<a name="ln317">static struct fd_ops sIndexDirectoryOps = {</a>
<a name="ln318">	NULL,		// read()</a>
<a name="ln319">	NULL,		// write()</a>
<a name="ln320">	NULL,		// seek()</a>
<a name="ln321">	NULL,		// ioctl()</a>
<a name="ln322">	NULL,		// select()</a>
<a name="ln323">	NULL,		// deselect()</a>
<a name="ln324">	index_dir_read,</a>
<a name="ln325">	index_dir_rewind,</a>
<a name="ln326">	NULL,		// read_stat()</a>
<a name="ln327">	NULL,		// write_stat()</a>
<a name="ln328">	index_dir_close,</a>
<a name="ln329">	index_dir_free_fd</a>
<a name="ln330">};</a>
<a name="ln331"> </a>
<a name="ln332">#if 0</a>
<a name="ln333">static struct fd_ops sIndexOps = {</a>
<a name="ln334">	NULL,		// read()</a>
<a name="ln335">	NULL,		// write()</a>
<a name="ln336">	NULL,		// seek()</a>
<a name="ln337">	NULL,		// ioctl()</a>
<a name="ln338">	NULL,		// select()</a>
<a name="ln339">	NULL,		// deselect()</a>
<a name="ln340">	NULL,		// dir_read()</a>
<a name="ln341">	NULL,		// dir_rewind()</a>
<a name="ln342">	index_read_stat,	// read_stat()</a>
<a name="ln343">	NULL,		// write_stat()</a>
<a name="ln344">	NULL,		// dir_close()</a>
<a name="ln345">	NULL		// free_fd()</a>
<a name="ln346">};</a>
<a name="ln347">#endif</a>
<a name="ln348"> </a>
<a name="ln349">static struct fd_ops sQueryOps = {</a>
<a name="ln350">	NULL,		// read()</a>
<a name="ln351">	NULL,		// write()</a>
<a name="ln352">	NULL,		// seek()</a>
<a name="ln353">	NULL,		// ioctl()</a>
<a name="ln354">	NULL,		// select()</a>
<a name="ln355">	NULL,		// deselect()</a>
<a name="ln356">	query_read,</a>
<a name="ln357">	query_rewind,</a>
<a name="ln358">	NULL,		// read_stat()</a>
<a name="ln359">	NULL,		// write_stat()</a>
<a name="ln360">	query_close,</a>
<a name="ln361">	query_free_fd</a>
<a name="ln362">};</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">// VNodePutter</a>
<a name="ln366">class VNodePutter {</a>
<a name="ln367">public:</a>
<a name="ln368">	VNodePutter(struct vnode *vnode = NULL) : fVNode(vnode) {}</a>
<a name="ln369"> </a>
<a name="ln370">	~VNodePutter()</a>
<a name="ln371">	{</a>
<a name="ln372">		Put();</a>
<a name="ln373">	}</a>
<a name="ln374"> </a>
<a name="ln375">	void SetTo(struct vnode *vnode)</a>
<a name="ln376">	{</a>
<a name="ln377">		Put();</a>
<a name="ln378">		fVNode = vnode;</a>
<a name="ln379">	}</a>
<a name="ln380"> </a>
<a name="ln381">	void Put()</a>
<a name="ln382">	{</a>
<a name="ln383">		if (fVNode) {</a>
<a name="ln384">			put_vnode(fVNode);</a>
<a name="ln385">			fVNode = NULL;</a>
<a name="ln386">		}</a>
<a name="ln387">	}</a>
<a name="ln388"> </a>
<a name="ln389">	struct vnode *Detach()</a>
<a name="ln390">	{</a>
<a name="ln391">		struct vnode *vnode = fVNode;</a>
<a name="ln392">		fVNode = NULL;</a>
<a name="ln393">		return vnode;</a>
<a name="ln394">	}</a>
<a name="ln395"> </a>
<a name="ln396">private:</a>
<a name="ln397">	struct vnode *fVNode;</a>
<a name="ln398">};</a>
<a name="ln399"> </a>
<a name="ln400"> </a>
<a name="ln401">static int</a>
<a name="ln402">mount_compare(void *_m, const void *_key)</a>
<a name="ln403">{</a>
<a name="ln404">	struct fs_mount *mount = (fs_mount *)_m;</a>
<a name="ln405">	const fssh_mount_id *id = (fssh_mount_id *)_key;</a>
<a name="ln406"> </a>
<a name="ln407">	if (mount-&gt;id == *id)</a>
<a name="ln408">		return 0;</a>
<a name="ln409"> </a>
<a name="ln410">	return -1;</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413"> </a>
<a name="ln414">static uint32_t</a>
<a name="ln415">mount_hash(void *_m, const void *_key, uint32_t range)</a>
<a name="ln416">{</a>
<a name="ln417">	struct fs_mount *mount = (fs_mount *)_m;</a>
<a name="ln418">	const fssh_mount_id *id = (fssh_mount_id *)_key;</a>
<a name="ln419"> </a>
<a name="ln420">	if (mount)</a>
<a name="ln421">		return mount-&gt;id % range;</a>
<a name="ln422"> </a>
<a name="ln423">	return (uint32_t)*id % range;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426"> </a>
<a name="ln427">/** Finds the mounted device (the fs_mount structure) with the given ID.</a>
<a name="ln428"> *	Note, you must hold the gMountMutex lock when you call this function.</a>
<a name="ln429"> */</a>
<a name="ln430"> </a>
<a name="ln431">static struct fs_mount *</a>
<a name="ln432">find_mount(fssh_mount_id id)</a>
<a name="ln433">{</a>
<a name="ln434">	ASSERT_LOCKED_MUTEX(&amp;sMountMutex);</a>
<a name="ln435"> </a>
<a name="ln436">	return (fs_mount *)hash_lookup(sMountsTable, (void *)&amp;id);</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439"> </a>
<a name="ln440">static fssh_status_t</a>
<a name="ln441">get_mount(fssh_mount_id id, struct fs_mount **_mount)</a>
<a name="ln442">{</a>
<a name="ln443">	MutexLocker locker(&amp;sMountMutex);</a>
<a name="ln444"> </a>
<a name="ln445">	struct fs_mount *mount = find_mount(id);</a>
<a name="ln446">	if (mount == NULL)</a>
<a name="ln447">		return FSSH_B_BAD_VALUE;</a>
<a name="ln448"> </a>
<a name="ln449">	if (mount-&gt;root_vnode == NULL) {</a>
<a name="ln450">		// might have been called during a mount operation in which</a>
<a name="ln451">		// case the root node may still be NULL</a>
<a name="ln452">		return FSSH_B_BUSY;</a>
<a name="ln453">	}</a>
<a name="ln454"> </a>
<a name="ln455">	inc_vnode_ref_count(mount-&gt;root_vnode);</a>
<a name="ln456">	*_mount = mount;</a>
<a name="ln457"> </a>
<a name="ln458">	return FSSH_B_OK;</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461"> </a>
<a name="ln462">static void</a>
<a name="ln463">put_mount(struct fs_mount *mount)</a>
<a name="ln464">{</a>
<a name="ln465">	if (mount)</a>
<a name="ln466">		put_vnode(mount-&gt;root_vnode);</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469"> </a>
<a name="ln470">static fssh_status_t</a>
<a name="ln471">put_file_system(fssh_file_system_module_info *fs)</a>
<a name="ln472">{</a>
<a name="ln473">	return fssh_put_module(fs-&gt;info.name);</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476"> </a>
<a name="ln477">/**	Tries to open the specified file system module.</a>
<a name="ln478"> *	Accepts a file system name of the form &quot;bfs&quot; or &quot;file_systems/bfs/v1&quot;.</a>
<a name="ln479"> *	Returns a pointer to file system module interface, or NULL if it</a>
<a name="ln480"> *	could not open the module.</a>
<a name="ln481"> */</a>
<a name="ln482"> </a>
<a name="ln483">static fssh_file_system_module_info *</a>
<a name="ln484">get_file_system(const char *fsName)</a>
<a name="ln485">{</a>
<a name="ln486">	char name[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln487">	if (fssh_strncmp(fsName, &quot;file_systems/&quot;, fssh_strlen(&quot;file_systems/&quot;))) {</a>
<a name="ln488">		// construct module name if we didn't get one</a>
<a name="ln489">		// (we currently support only one API)</a>
<a name="ln490">		fssh_snprintf(name, sizeof(name), &quot;file_systems/%s/v1&quot;, fsName);</a>
<a name="ln491">		fsName = NULL;</a>
<a name="ln492">	}</a>
<a name="ln493"> </a>
<a name="ln494">	fssh_file_system_module_info *info;</a>
<a name="ln495">	if (fssh_get_module(fsName ? fsName : name, (fssh_module_info **)&amp;info) != FSSH_B_OK)</a>
<a name="ln496">		return NULL;</a>
<a name="ln497"> </a>
<a name="ln498">	return info;</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">/**	Accepts a file system name of the form &quot;bfs&quot; or &quot;file_systems/bfs/v1&quot;</a>
<a name="ln503"> *	and returns a compatible fs_info.fsh_name name (&quot;bfs&quot; in both cases).</a>
<a name="ln504"> *	The name is allocated for you, and you have to free() it when you're</a>
<a name="ln505"> *	done with it.</a>
<a name="ln506"> *	Returns NULL if the required memory is no available.</a>
<a name="ln507"> */</a>
<a name="ln508"> </a>
<a name="ln509">static char *</a>
<a name="ln510">get_file_system_name(const char *fsName)</a>
<a name="ln511">{</a>
<a name="ln512">	const fssh_size_t length = fssh_strlen(&quot;file_systems/&quot;);</a>
<a name="ln513"> </a>
<a name="ln514">	if (fssh_strncmp(fsName, &quot;file_systems/&quot;, length)) {</a>
<a name="ln515">		// the name already seems to be the module's file name</a>
<a name="ln516">		return fssh_strdup(fsName);</a>
<a name="ln517">	}</a>
<a name="ln518"> </a>
<a name="ln519">	fsName += length;</a>
<a name="ln520">	const char *end = fssh_strchr(fsName, '/');</a>
<a name="ln521">	if (end == NULL) {</a>
<a name="ln522">		// this doesn't seem to be a valid name, but well...</a>
<a name="ln523">		return fssh_strdup(fsName);</a>
<a name="ln524">	}</a>
<a name="ln525"> </a>
<a name="ln526">	// cut off the trailing /v1</a>
<a name="ln527"> </a>
<a name="ln528">	char *name = (char *)malloc(end + 1 - fsName);</a>
<a name="ln529">	if (name == NULL)</a>
<a name="ln530">		return NULL;</a>
<a name="ln531"> </a>
<a name="ln532">	fssh_strlcpy(name, fsName, end + 1 - fsName);</a>
<a name="ln533">	return name;</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536"> </a>
<a name="ln537">static int</a>
<a name="ln538">vnode_compare(void *_vnode, const void *_key)</a>
<a name="ln539">{</a>
<a name="ln540">	struct vnode *vnode = (struct vnode *)_vnode;</a>
<a name="ln541">	const struct vnode_hash_key *key = (vnode_hash_key *)_key;</a>
<a name="ln542"> </a>
<a name="ln543">	if (vnode-&gt;device == key-&gt;device &amp;&amp; vnode-&gt;id == key-&gt;vnode)</a>
<a name="ln544">		return 0;</a>
<a name="ln545"> </a>
<a name="ln546">	return -1;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">static uint32_t</a>
<a name="ln551">vnode_hash(void *_vnode, const void *_key, uint32_t range)</a>
<a name="ln552">{</a>
<a name="ln553">	struct vnode *vnode = (struct vnode *)_vnode;</a>
<a name="ln554">	const struct vnode_hash_key *key = (vnode_hash_key *)_key;</a>
<a name="ln555"> </a>
<a name="ln556">#define VHASH(mountid, vnodeid) (((uint32_t)((vnodeid) &gt;&gt; 32) + (uint32_t)(vnodeid)) ^ (uint32_t)(mountid))</a>
<a name="ln557"> </a>
<a name="ln558">	if (vnode != NULL)</a>
<a name="ln559">		return VHASH(vnode-&gt;device, vnode-&gt;id) % range;</a>
<a name="ln560"> </a>
<a name="ln561">	return VHASH(key-&gt;device, key-&gt;vnode) % range;</a>
<a name="ln562"> </a>
<a name="ln563">#undef VHASH</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566"> </a>
<a name="ln567">static void</a>
<a name="ln568">add_vnode_to_mount_list(struct vnode *vnode, struct fs_mount *mount)</a>
<a name="ln569">{</a>
<a name="ln570">	fssh_recursive_lock_lock(&amp;mount-&gt;rlock);</a>
<a name="ln571"> </a>
<a name="ln572">	list_add_link_to_head(&amp;mount-&gt;vnodes, &amp;vnode-&gt;mount_link);</a>
<a name="ln573"> </a>
<a name="ln574">	fssh_recursive_lock_unlock(&amp;mount-&gt;rlock);</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577"> </a>
<a name="ln578">static void</a>
<a name="ln579">remove_vnode_from_mount_list(struct vnode *vnode, struct fs_mount *mount)</a>
<a name="ln580">{</a>
<a name="ln581">	fssh_recursive_lock_lock(&amp;mount-&gt;rlock);</a>
<a name="ln582"> </a>
<a name="ln583">	list_remove_link(&amp;vnode-&gt;mount_link);</a>
<a name="ln584">	vnode-&gt;mount_link.next = vnode-&gt;mount_link.prev = NULL;</a>
<a name="ln585"> </a>
<a name="ln586">	fssh_recursive_lock_unlock(&amp;mount-&gt;rlock);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589"> </a>
<a name="ln590">static fssh_status_t</a>
<a name="ln591">create_new_vnode(struct vnode **_vnode, fssh_mount_id mountID, fssh_vnode_id vnodeID)</a>
<a name="ln592">{</a>
<a name="ln593">	FUNCTION((&quot;create_new_vnode()\n&quot;));</a>
<a name="ln594"> </a>
<a name="ln595">	struct vnode *vnode = (struct vnode *)malloc(sizeof(struct vnode));</a>
<a name="ln596">	if (vnode == NULL)</a>
<a name="ln597">		return FSSH_B_NO_MEMORY;</a>
<a name="ln598"> </a>
<a name="ln599">	// initialize basic values</a>
<a name="ln600">	fssh_memset(vnode, 0, sizeof(struct vnode));</a>
<a name="ln601">	vnode-&gt;device = mountID;</a>
<a name="ln602">	vnode-&gt;id = vnodeID;</a>
<a name="ln603"> </a>
<a name="ln604">	// add the vnode to the mount structure</a>
<a name="ln605">	fssh_mutex_lock(&amp;sMountMutex);</a>
<a name="ln606">	vnode-&gt;mount = find_mount(mountID);</a>
<a name="ln607">	if (!vnode-&gt;mount || vnode-&gt;mount-&gt;unmounting) {</a>
<a name="ln608">		fssh_mutex_unlock(&amp;sMountMutex);</a>
<a name="ln609">		free(vnode);</a>
<a name="ln610">		return FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln611">	}</a>
<a name="ln612"> </a>
<a name="ln613">	hash_insert(sVnodeTable, vnode);</a>
<a name="ln614">	add_vnode_to_mount_list(vnode, vnode-&gt;mount);</a>
<a name="ln615"> </a>
<a name="ln616">	fssh_mutex_unlock(&amp;sMountMutex);</a>
<a name="ln617"> </a>
<a name="ln618">	vnode-&gt;ref_count = 1;</a>
<a name="ln619">	*_vnode = vnode;</a>
<a name="ln620"> </a>
<a name="ln621">	return FSSH_B_OK;</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624"> </a>
<a name="ln625">/**	Frees the vnode and all resources it has acquired, and removes</a>
<a name="ln626"> *	it from the vnode hash as well as from its mount structure.</a>
<a name="ln627"> *	Will also make sure that any cache modifications are written back.</a>
<a name="ln628"> */</a>
<a name="ln629"> </a>
<a name="ln630">static void</a>
<a name="ln631">free_vnode(struct vnode *vnode, bool reenter)</a>
<a name="ln632">{</a>
<a name="ln633">	ASSERT(vnode-&gt;ref_count == 0 &amp;&amp; vnode-&gt;busy);</a>
<a name="ln634"> </a>
<a name="ln635">	// write back any changes in this vnode's cache -- but only</a>
<a name="ln636">	// if the vnode won't be deleted, in which case the changes</a>
<a name="ln637">	// will be discarded</a>
<a name="ln638"> </a>
<a name="ln639">	if (!vnode-&gt;remove &amp;&amp; HAS_FS_CALL(vnode, fsync))</a>
<a name="ln640">		FS_CALL_NO_PARAMS(vnode, fsync);</a>
<a name="ln641"> </a>
<a name="ln642">	if (!vnode-&gt;unpublished) {</a>
<a name="ln643">		if (vnode-&gt;remove)</a>
<a name="ln644">			FS_CALL(vnode, remove_vnode, reenter);</a>
<a name="ln645">		else</a>
<a name="ln646">			FS_CALL(vnode, put_vnode, reenter);</a>
<a name="ln647">	}</a>
<a name="ln648"> </a>
<a name="ln649">	// The file system has removed the resources of the vnode now, so we can</a>
<a name="ln650">	// make it available again (and remove the busy vnode from the hash)</a>
<a name="ln651">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln652">	hash_remove(sVnodeTable, vnode);</a>
<a name="ln653">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln654"> </a>
<a name="ln655">	remove_vnode_from_mount_list(vnode, vnode-&gt;mount);</a>
<a name="ln656"> </a>
<a name="ln657">	free(vnode);</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660"> </a>
<a name="ln661">/**	\brief Decrements the reference counter of the given vnode and deletes it,</a>
<a name="ln662"> *	if the counter dropped to 0.</a>
<a name="ln663"> *</a>
<a name="ln664"> *	The caller must, of course, own a reference to the vnode to call this</a>
<a name="ln665"> *	function.</a>
<a name="ln666"> *	The caller must not hold the sVnodeMutex or the sMountMutex.</a>
<a name="ln667"> *</a>
<a name="ln668"> *	\param vnode the vnode.</a>
<a name="ln669"> *	\param reenter \c true, if this function is called (indirectly) from within</a>
<a name="ln670"> *		   a file system.</a>
<a name="ln671"> *	\return \c FSSH_B_OK, if everything went fine, an error code otherwise.</a>
<a name="ln672"> */</a>
<a name="ln673"> </a>
<a name="ln674">static fssh_status_t</a>
<a name="ln675">dec_vnode_ref_count(struct vnode *vnode, bool reenter)</a>
<a name="ln676">{</a>
<a name="ln677">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln678"> </a>
<a name="ln679">	int32_t oldRefCount = fssh_atomic_add(&amp;vnode-&gt;ref_count, -1);</a>
<a name="ln680"> </a>
<a name="ln681">	TRACE((&quot;dec_vnode_ref_count: vnode %p, ref now %ld\n&quot;, vnode, vnode-&gt;ref_count));</a>
<a name="ln682"> </a>
<a name="ln683">	if (oldRefCount == 1) {</a>
<a name="ln684">		if (vnode-&gt;busy)</a>
<a name="ln685">			fssh_panic(&quot;dec_vnode_ref_count: called on busy vnode %p\n&quot;, vnode);</a>
<a name="ln686"> </a>
<a name="ln687">		bool freeNode = false;</a>
<a name="ln688"> </a>
<a name="ln689">		// Just insert the vnode into an unused list if we don't need</a>
<a name="ln690">		// to delete it</a>
<a name="ln691">		if (vnode-&gt;remove) {</a>
<a name="ln692">			vnode-&gt;busy = true;</a>
<a name="ln693">			freeNode = true;</a>
<a name="ln694">		} else {</a>
<a name="ln695">			list_add_item(&amp;sUnusedVnodeList, vnode);</a>
<a name="ln696">			if (++sUnusedVnodes &gt; kMaxUnusedVnodes) {</a>
<a name="ln697">				// there are too many unused vnodes so we free the oldest one</a>
<a name="ln698">				// ToDo: evaluate this mechanism</a>
<a name="ln699">				vnode = (struct vnode *)list_remove_head_item(&amp;sUnusedVnodeList);</a>
<a name="ln700">				vnode-&gt;busy = true;</a>
<a name="ln701">				freeNode = true;</a>
<a name="ln702">				sUnusedVnodes--;</a>
<a name="ln703">			}</a>
<a name="ln704">		}</a>
<a name="ln705"> </a>
<a name="ln706">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln707"> </a>
<a name="ln708">		if (freeNode)</a>
<a name="ln709">			free_vnode(vnode, reenter);</a>
<a name="ln710">	} else</a>
<a name="ln711">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln712"> </a>
<a name="ln713">	return FSSH_B_OK;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">/**	\brief Increments the reference counter of the given vnode.</a>
<a name="ln718"> *</a>
<a name="ln719"> *	The caller must either already have a reference to the vnode or hold</a>
<a name="ln720"> *	the sVnodeMutex.</a>
<a name="ln721"> *</a>
<a name="ln722"> *	\param vnode the vnode.</a>
<a name="ln723"> */</a>
<a name="ln724"> </a>
<a name="ln725">static void</a>
<a name="ln726">inc_vnode_ref_count(struct vnode *vnode)</a>
<a name="ln727">{</a>
<a name="ln728">	fssh_atomic_add(&amp;vnode-&gt;ref_count, 1);</a>
<a name="ln729">	TRACE((&quot;inc_vnode_ref_count: vnode %p, ref now %ld\n&quot;, vnode, vnode-&gt;ref_count));</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732"> </a>
<a name="ln733">/**	\brief Looks up a vnode by mount and node ID in the sVnodeTable.</a>
<a name="ln734"> *</a>
<a name="ln735"> *	The caller must hold the sVnodeMutex.</a>
<a name="ln736"> *</a>
<a name="ln737"> *	\param mountID the mount ID.</a>
<a name="ln738"> *	\param vnodeID the node ID.</a>
<a name="ln739"> *</a>
<a name="ln740"> *	\return The vnode structure, if it was found in the hash table, \c NULL</a>
<a name="ln741"> *			otherwise.</a>
<a name="ln742"> */</a>
<a name="ln743"> </a>
<a name="ln744">static struct vnode *</a>
<a name="ln745">lookup_vnode(fssh_mount_id mountID, fssh_vnode_id vnodeID)</a>
<a name="ln746">{</a>
<a name="ln747">	struct vnode_hash_key key;</a>
<a name="ln748"> </a>
<a name="ln749">	key.device = mountID;</a>
<a name="ln750">	key.vnode = vnodeID;</a>
<a name="ln751"> </a>
<a name="ln752">	return (vnode *)hash_lookup(sVnodeTable, &amp;key);</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">/**	\brief Retrieves a vnode for a given mount ID, node ID pair.</a>
<a name="ln757"> *</a>
<a name="ln758"> *	If the node is not yet in memory, it will be loaded.</a>
<a name="ln759"> *</a>
<a name="ln760"> *	The caller must not hold the sVnodeMutex or the sMountMutex.</a>
<a name="ln761"> *</a>
<a name="ln762"> *	\param mountID the mount ID.</a>
<a name="ln763"> *	\param vnodeID the node ID.</a>
<a name="ln764"> *	\param _vnode Pointer to a vnode* variable into which the pointer to the</a>
<a name="ln765"> *		   retrieved vnode structure shall be written.</a>
<a name="ln766"> *	\param reenter \c true, if this function is called (indirectly) from within</a>
<a name="ln767"> *		   a file system.</a>
<a name="ln768"> *	\return \c FSSH_B_OK, if everything when fine, an error code otherwise.</a>
<a name="ln769"> */</a>
<a name="ln770"> </a>
<a name="ln771">static fssh_status_t</a>
<a name="ln772">get_vnode(fssh_mount_id mountID, fssh_vnode_id vnodeID, struct vnode **_vnode, int reenter)</a>
<a name="ln773">{</a>
<a name="ln774">	FUNCTION((&quot;get_vnode: mountid %ld vnid 0x%Lx %p\n&quot;, mountID, vnodeID, _vnode));</a>
<a name="ln775"> </a>
<a name="ln776">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln777"> </a>
<a name="ln778">	int32_t tries = 300;</a>
<a name="ln779">		// try for 3 secs</a>
<a name="ln780">restart:</a>
<a name="ln781">	struct vnode *vnode = lookup_vnode(mountID, vnodeID);</a>
<a name="ln782">	if (vnode &amp;&amp; vnode-&gt;busy) {</a>
<a name="ln783">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln784">		if (--tries &lt; 0) {</a>
<a name="ln785">			// vnode doesn't seem to become unbusy</a>
<a name="ln786">			fssh_panic(&quot;vnode %d:%&quot; FSSH_B_PRIdINO &quot; is not becoming unbusy!\n&quot;,</a>
<a name="ln787">				(int)mountID, vnodeID);</a>
<a name="ln788">			return FSSH_B_BUSY;</a>
<a name="ln789">		}</a>
<a name="ln790">		fssh_snooze(10000); // 10 ms</a>
<a name="ln791">		fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln792">		goto restart;</a>
<a name="ln793">	}</a>
<a name="ln794"> </a>
<a name="ln795">	TRACE((&quot;get_vnode: tried to lookup vnode, got %p\n&quot;, vnode));</a>
<a name="ln796"> </a>
<a name="ln797">	fssh_status_t status;</a>
<a name="ln798"> </a>
<a name="ln799">	if (vnode) {</a>
<a name="ln800">		if (vnode-&gt;ref_count == 0) {</a>
<a name="ln801">			// this vnode has been unused before</a>
<a name="ln802">			list_remove_item(&amp;sUnusedVnodeList, vnode);</a>
<a name="ln803">			sUnusedVnodes--;</a>
<a name="ln804">		}</a>
<a name="ln805">		inc_vnode_ref_count(vnode);</a>
<a name="ln806">	} else {</a>
<a name="ln807">		// we need to create a new vnode and read it in</a>
<a name="ln808">		status = create_new_vnode(&amp;vnode, mountID, vnodeID);</a>
<a name="ln809">		if (status &lt; FSSH_B_OK)</a>
<a name="ln810">			goto err;</a>
<a name="ln811"> </a>
<a name="ln812">		vnode-&gt;busy = true;</a>
<a name="ln813">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln814"> </a>
<a name="ln815">		int type;</a>
<a name="ln816">		uint32_t flags;</a>
<a name="ln817">		status = FS_MOUNT_CALL(vnode-&gt;mount, get_vnode, vnodeID, vnode, &amp;type,</a>
<a name="ln818">			&amp;flags, reenter);</a>
<a name="ln819">		if (status == FSSH_B_OK &amp;&amp; vnode-&gt;private_node == NULL)</a>
<a name="ln820">			status = FSSH_B_BAD_VALUE;</a>
<a name="ln821"> </a>
<a name="ln822">		fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln823"> </a>
<a name="ln824">		if (status &lt; FSSH_B_OK)</a>
<a name="ln825">			goto err1;</a>
<a name="ln826"> </a>
<a name="ln827">		vnode-&gt;type = type;</a>
<a name="ln828">		vnode-&gt;busy = false;</a>
<a name="ln829">	}</a>
<a name="ln830"> </a>
<a name="ln831">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln832"> </a>
<a name="ln833">	TRACE((&quot;get_vnode: returning %p\n&quot;, vnode));</a>
<a name="ln834"> </a>
<a name="ln835">	*_vnode = vnode;</a>
<a name="ln836">	return FSSH_B_OK;</a>
<a name="ln837"> </a>
<a name="ln838">err1:</a>
<a name="ln839">	hash_remove(sVnodeTable, vnode);</a>
<a name="ln840">	remove_vnode_from_mount_list(vnode, vnode-&gt;mount);</a>
<a name="ln841">err:</a>
<a name="ln842">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln843">	if (vnode)</a>
<a name="ln844">		free(vnode);</a>
<a name="ln845"> </a>
<a name="ln846">	return status;</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849"> </a>
<a name="ln850">/**	\brief Decrements the reference counter of the given vnode and deletes it,</a>
<a name="ln851"> *	if the counter dropped to 0.</a>
<a name="ln852"> *</a>
<a name="ln853"> *	The caller must, of course, own a reference to the vnode to call this</a>
<a name="ln854"> *	function.</a>
<a name="ln855"> *	The caller must not hold the sVnodeMutex or the sMountMutex.</a>
<a name="ln856"> *</a>
<a name="ln857"> *	\param vnode the vnode.</a>
<a name="ln858"> */</a>
<a name="ln859"> </a>
<a name="ln860">static inline void</a>
<a name="ln861">put_vnode(struct vnode *vnode)</a>
<a name="ln862">{</a>
<a name="ln863">	dec_vnode_ref_count(vnode, false);</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866"> </a>
<a name="ln867">/**	Disconnects all file descriptors that are associated with the</a>
<a name="ln868"> *	\a vnodeToDisconnect, or if this is NULL, all vnodes of the specified</a>
<a name="ln869"> *	\a mount object.</a>
<a name="ln870"> *</a>
<a name="ln871"> *	Note, after you've called this function, there might still be ongoing</a>
<a name="ln872"> *	accesses - they won't be interrupted if they already happened before.</a>
<a name="ln873"> *	However, any subsequent access will fail.</a>
<a name="ln874"> *</a>
<a name="ln875"> *	This is not a cheap function and should be used with care and rarely.</a>
<a name="ln876"> *	TODO: there is currently no means to stop a blocking read/write!</a>
<a name="ln877"> */</a>
<a name="ln878"> </a>
<a name="ln879">void</a>
<a name="ln880">disconnect_mount_or_vnode_fds(struct fs_mount *mount,</a>
<a name="ln881">	struct vnode *vnodeToDisconnect)</a>
<a name="ln882">{</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885"> </a>
<a name="ln886">/**	\brief Resolves a mount point vnode to the volume root vnode it is covered</a>
<a name="ln887"> *		   by.</a>
<a name="ln888"> *</a>
<a name="ln889"> *	Given an arbitrary vnode, the function checks, whether the node is covered</a>
<a name="ln890"> *	by the root of a volume. If it is the function obtains a reference to the</a>
<a name="ln891"> *	volume root node and returns it.</a>
<a name="ln892"> *</a>
<a name="ln893"> *	\param vnode The vnode in question.</a>
<a name="ln894"> *	\return The volume root vnode the vnode cover is covered by, if it is</a>
<a name="ln895"> *			indeed a mount point, or \c NULL otherwise.</a>
<a name="ln896"> */</a>
<a name="ln897"> </a>
<a name="ln898">static struct vnode *</a>
<a name="ln899">resolve_mount_point_to_volume_root(struct vnode *vnode)</a>
<a name="ln900">{</a>
<a name="ln901">	if (!vnode)</a>
<a name="ln902">		return NULL;</a>
<a name="ln903"> </a>
<a name="ln904">	struct vnode *volumeRoot = NULL;</a>
<a name="ln905"> </a>
<a name="ln906">	fssh_mutex_lock(&amp;sVnodeCoveredByMutex);</a>
<a name="ln907">	if (vnode-&gt;covered_by) {</a>
<a name="ln908">		volumeRoot = vnode-&gt;covered_by;</a>
<a name="ln909">		inc_vnode_ref_count(volumeRoot);</a>
<a name="ln910">	}</a>
<a name="ln911">	fssh_mutex_unlock(&amp;sVnodeCoveredByMutex);</a>
<a name="ln912"> </a>
<a name="ln913">	return volumeRoot;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">/**	\brief Resolves a mount point vnode to the volume root vnode it is covered</a>
<a name="ln918"> *		   by.</a>
<a name="ln919"> *</a>
<a name="ln920"> *	Given an arbitrary vnode (identified by mount and node ID), the function</a>
<a name="ln921"> *	checks, whether the node is covered by the root of a volume. If it is the</a>
<a name="ln922"> *	function returns the mount and node ID of the volume root node. Otherwise</a>
<a name="ln923"> *	it simply returns the supplied mount and node ID.</a>
<a name="ln924"> *</a>
<a name="ln925"> *	In case of error (e.g. the supplied node could not be found) the variables</a>
<a name="ln926"> *	for storing the resolved mount and node ID remain untouched and an error</a>
<a name="ln927"> *	code is returned.</a>
<a name="ln928"> *</a>
<a name="ln929"> *	\param mountID The mount ID of the vnode in question.</a>
<a name="ln930"> *	\param nodeID The node ID of the vnode in question.</a>
<a name="ln931"> *	\param resolvedMountID Pointer to storage for the resolved mount ID.</a>
<a name="ln932"> *	\param resolvedNodeID Pointer to storage for the resolved node ID.</a>
<a name="ln933"> *	\return</a>
<a name="ln934"> *	- \c FSSH_B_OK, if everything went fine,</a>
<a name="ln935"> *	- another error code, if something went wrong.</a>
<a name="ln936"> */</a>
<a name="ln937"> </a>
<a name="ln938">fssh_status_t</a>
<a name="ln939">resolve_mount_point_to_volume_root(fssh_mount_id mountID, fssh_vnode_id nodeID,</a>
<a name="ln940">	fssh_mount_id *resolvedMountID, fssh_vnode_id *resolvedNodeID)</a>
<a name="ln941">{</a>
<a name="ln942">	// get the node</a>
<a name="ln943">	struct vnode *node;</a>
<a name="ln944">	fssh_status_t error = get_vnode(mountID, nodeID, &amp;node, false);</a>
<a name="ln945">	if (error != FSSH_B_OK)</a>
<a name="ln946">		return error;</a>
<a name="ln947"> </a>
<a name="ln948">	// resolve the node</a>
<a name="ln949">	struct vnode *resolvedNode = resolve_mount_point_to_volume_root(node);</a>
<a name="ln950">	if (resolvedNode) {</a>
<a name="ln951">		put_vnode(node);</a>
<a name="ln952">		node = resolvedNode;</a>
<a name="ln953">	}</a>
<a name="ln954"> </a>
<a name="ln955">	// set the return values</a>
<a name="ln956">	*resolvedMountID = node-&gt;device;</a>
<a name="ln957">	*resolvedNodeID = node-&gt;id;</a>
<a name="ln958"> </a>
<a name="ln959">	put_vnode(node);</a>
<a name="ln960"> </a>
<a name="ln961">	return FSSH_B_OK;</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964"> </a>
<a name="ln965">/**	\brief Resolves a volume root vnode to the underlying mount point vnode.</a>
<a name="ln966"> *</a>
<a name="ln967"> *	Given an arbitrary vnode, the function checks, whether the node is the</a>
<a name="ln968"> *	root of a volume. If it is (and if it is not &quot;/&quot;), the function obtains</a>
<a name="ln969"> *	a reference to the underlying mount point node and returns it.</a>
<a name="ln970"> *</a>
<a name="ln971"> *	\param vnode The vnode in question (caller must have a reference).</a>
<a name="ln972"> *	\return The mount point vnode the vnode covers, if it is indeed a volume</a>
<a name="ln973"> *			root and not &quot;/&quot;, or \c NULL otherwise.</a>
<a name="ln974"> */</a>
<a name="ln975"> </a>
<a name="ln976">static struct vnode *</a>
<a name="ln977">resolve_volume_root_to_mount_point(struct vnode *vnode)</a>
<a name="ln978">{</a>
<a name="ln979">	if (!vnode)</a>
<a name="ln980">		return NULL;</a>
<a name="ln981"> </a>
<a name="ln982">	struct vnode *mountPoint = NULL;</a>
<a name="ln983"> </a>
<a name="ln984">	struct fs_mount *mount = vnode-&gt;mount;</a>
<a name="ln985">	if (vnode == mount-&gt;root_vnode &amp;&amp; mount-&gt;covers_vnode) {</a>
<a name="ln986">		mountPoint = mount-&gt;covers_vnode;</a>
<a name="ln987">		inc_vnode_ref_count(mountPoint);</a>
<a name="ln988">	}</a>
<a name="ln989"> </a>
<a name="ln990">	return mountPoint;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">/**	\brief Gets the directory path and leaf name for a given path.</a>
<a name="ln995"> *</a>
<a name="ln996"> *	The supplied \a path is transformed to refer to the directory part of</a>
<a name="ln997"> *	the entry identified by the original path, and into the buffer \a filename</a>
<a name="ln998"> *	the leaf name of the original entry is written.</a>
<a name="ln999"> *	Neither the returned path nor the leaf name can be expected to be</a>
<a name="ln1000"> *	canonical.</a>
<a name="ln1001"> *</a>
<a name="ln1002"> *	\param path The path to be analyzed. Must be able to store at least one</a>
<a name="ln1003"> *		   additional character.</a>
<a name="ln1004"> *	\param filename The buffer into which the leaf name will be written.</a>
<a name="ln1005"> *		   Must be of size FSSH_B_FILE_NAME_LENGTH at least.</a>
<a name="ln1006"> *	\return \c FSSH_B_OK, if everything went fine, \c FSSH_B_NAME_TOO_LONG, if the leaf</a>
<a name="ln1007"> *		   name is longer than \c FSSH_B_FILE_NAME_LENGTH.</a>
<a name="ln1008"> */</a>
<a name="ln1009"> </a>
<a name="ln1010">static fssh_status_t</a>
<a name="ln1011">get_dir_path_and_leaf(char *path, char *filename)</a>
<a name="ln1012">{</a>
<a name="ln1013">	char *p = fssh_strrchr(path, '/');</a>
<a name="ln1014">		// '/' are not allowed in file names!</a>
<a name="ln1015"> </a>
<a name="ln1016">	FUNCTION((&quot;get_dir_path_and_leaf(path = %s)\n&quot;, path));</a>
<a name="ln1017"> </a>
<a name="ln1018">	if (!p) {</a>
<a name="ln1019">		// this path is single segment with no '/' in it</a>
<a name="ln1020">		// ex. &quot;foo&quot;</a>
<a name="ln1021">		if (fssh_strlcpy(filename, path, FSSH_B_FILE_NAME_LENGTH) &gt;= FSSH_B_FILE_NAME_LENGTH)</a>
<a name="ln1022">			return FSSH_B_NAME_TOO_LONG;</a>
<a name="ln1023">		fssh_strcpy(path, &quot;.&quot;);</a>
<a name="ln1024">	} else {</a>
<a name="ln1025">		p++;</a>
<a name="ln1026">		if (*p == '\0') {</a>
<a name="ln1027">			// special case: the path ends in '/'</a>
<a name="ln1028">			fssh_strcpy(filename, &quot;.&quot;);</a>
<a name="ln1029">		} else {</a>
<a name="ln1030">			// normal leaf: replace the leaf portion of the path with a '.'</a>
<a name="ln1031">			if (fssh_strlcpy(filename, p, FSSH_B_FILE_NAME_LENGTH)</a>
<a name="ln1032">				&gt;= FSSH_B_FILE_NAME_LENGTH) {</a>
<a name="ln1033">				return FSSH_B_NAME_TOO_LONG;</a>
<a name="ln1034">			}</a>
<a name="ln1035">		}</a>
<a name="ln1036">		p[0] = '.';</a>
<a name="ln1037">		p[1] = '\0';</a>
<a name="ln1038">	}</a>
<a name="ln1039">	return FSSH_B_OK;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042"> </a>
<a name="ln1043">static fssh_status_t</a>
<a name="ln1044">entry_ref_to_vnode(fssh_mount_id mountID, fssh_vnode_id directoryID, const char *name, struct vnode **_vnode)</a>
<a name="ln1045">{</a>
<a name="ln1046">	char clonedName[FSSH_B_FILE_NAME_LENGTH + 1];</a>
<a name="ln1047">	if (fssh_strlcpy(clonedName, name, FSSH_B_FILE_NAME_LENGTH) &gt;= FSSH_B_FILE_NAME_LENGTH)</a>
<a name="ln1048">		return FSSH_B_NAME_TOO_LONG;</a>
<a name="ln1049"> </a>
<a name="ln1050">	// get the directory vnode and let vnode_path_to_vnode() do the rest</a>
<a name="ln1051">	struct vnode *directory;</a>
<a name="ln1052"> </a>
<a name="ln1053">	fssh_status_t status = get_vnode(mountID, directoryID, &amp;directory, false);</a>
<a name="ln1054">	if (status &lt; 0)</a>
<a name="ln1055">		return status;</a>
<a name="ln1056"> </a>
<a name="ln1057">	return vnode_path_to_vnode(directory, clonedName, false, 0, _vnode, NULL);</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060"> </a>
<a name="ln1061">static fssh_status_t</a>
<a name="ln1062">lookup_dir_entry(struct vnode* dir, const char* name, struct vnode** _vnode)</a>
<a name="ln1063">{</a>
<a name="ln1064">	fssh_ino_t id;</a>
<a name="ln1065">	fssh_status_t status = FS_CALL(dir, lookup, name, &amp;id);</a>
<a name="ln1066">	if (status &lt; FSSH_B_OK)</a>
<a name="ln1067">		return status;</a>
<a name="ln1068"> </a>
<a name="ln1069">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln1070">	*_vnode = lookup_vnode(dir-&gt;device, id);</a>
<a name="ln1071">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln1072"> </a>
<a name="ln1073">	if (*_vnode == NULL) {</a>
<a name="ln1074">		fssh_panic(&quot;lookup_dir_entry(): could not lookup vnode (mountid %d &quot;</a>
<a name="ln1075">			&quot;vnid %&quot; FSSH_B_PRIdINO &quot;)\n&quot;, (int)dir-&gt;device, id);</a>
<a name="ln1076">		return FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln1077">	}</a>
<a name="ln1078"> </a>
<a name="ln1079">	return FSSH_B_OK;</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082"> </a>
<a name="ln1083">/*!	Returns the vnode for the relative path starting at the specified \a vnode.</a>
<a name="ln1084">	\a path must not be NULL.</a>
<a name="ln1085">	If it returns successfully, \a path contains the name of the last path</a>
<a name="ln1086">	component. This function clobbers the buffer pointed to by \a path only</a>
<a name="ln1087">	if it does contain more than one component.</a>
<a name="ln1088">	Note, this reduces the ref_count of the starting \a vnode, no matter if</a>
<a name="ln1089">	it is successful or not!</a>
<a name="ln1090">*/</a>
<a name="ln1091">static fssh_status_t</a>
<a name="ln1092">vnode_path_to_vnode(struct vnode *vnode, char *path, bool traverseLeafLink,</a>
<a name="ln1093">	int count, struct vnode **_vnode, fssh_vnode_id *_parentID)</a>
<a name="ln1094">{</a>
<a name="ln1095">	fssh_status_t status = 0;</a>
<a name="ln1096">	fssh_vnode_id lastParentID = vnode-&gt;id;</a>
<a name="ln1097"> </a>
<a name="ln1098">	FUNCTION((&quot;vnode_path_to_vnode(vnode = %p, path = %s)\n&quot;, vnode, path));</a>
<a name="ln1099"> </a>
<a name="ln1100">	if (path == NULL) {</a>
<a name="ln1101">		put_vnode(vnode);</a>
<a name="ln1102">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1103">	}</a>
<a name="ln1104"> </a>
<a name="ln1105">	while (true) {</a>
<a name="ln1106">		struct vnode *nextVnode;</a>
<a name="ln1107">		char *nextPath;</a>
<a name="ln1108"> </a>
<a name="ln1109">		TRACE((&quot;vnode_path_to_vnode: top of loop. p = %p, p = '%s'\n&quot;, path, path));</a>
<a name="ln1110"> </a>
<a name="ln1111">		// done?</a>
<a name="ln1112">		if (path[0] == '\0')</a>
<a name="ln1113">			break;</a>
<a name="ln1114"> </a>
<a name="ln1115">		// walk to find the next path component (&quot;path&quot; will point to a single</a>
<a name="ln1116">		// path component), and filter out multiple slashes</a>
<a name="ln1117">		for (nextPath = path + 1; *nextPath != '\0' &amp;&amp; *nextPath != '/'; nextPath++);</a>
<a name="ln1118"> </a>
<a name="ln1119">		if (*nextPath == '/') {</a>
<a name="ln1120">			*nextPath = '\0';</a>
<a name="ln1121">			do</a>
<a name="ln1122">				nextPath++;</a>
<a name="ln1123">			while (*nextPath == '/');</a>
<a name="ln1124">		}</a>
<a name="ln1125"> </a>
<a name="ln1126">		// See if the '..' is at the root of a mount and move to the covered</a>
<a name="ln1127">		// vnode so we pass the '..' path to the underlying filesystem</a>
<a name="ln1128">		if (!fssh_strcmp(&quot;..&quot;, path)</a>
<a name="ln1129">			&amp;&amp; vnode-&gt;mount-&gt;root_vnode == vnode</a>
<a name="ln1130">			&amp;&amp; vnode-&gt;mount-&gt;covers_vnode) {</a>
<a name="ln1131">			nextVnode = vnode-&gt;mount-&gt;covers_vnode;</a>
<a name="ln1132">			inc_vnode_ref_count(nextVnode);</a>
<a name="ln1133">			put_vnode(vnode);</a>
<a name="ln1134">			vnode = nextVnode;</a>
<a name="ln1135">		}</a>
<a name="ln1136"> </a>
<a name="ln1137">		// Check if we have the right to search the current directory vnode.</a>
<a name="ln1138">		// If a file system doesn't have the access() function, we assume that</a>
<a name="ln1139">		// searching a directory is always allowed</a>
<a name="ln1140">		if (HAS_FS_CALL(vnode, access))</a>
<a name="ln1141">			status = FS_CALL(vnode, access, FSSH_X_OK);</a>
<a name="ln1142"> </a>
<a name="ln1143">		// Tell the filesystem to get the vnode of this path component (if we got the</a>
<a name="ln1144">		// permission from the call above)</a>
<a name="ln1145">		if (status &gt;= FSSH_B_OK)</a>
<a name="ln1146">			status = lookup_dir_entry(vnode, path, &amp;nextVnode);</a>
<a name="ln1147"> </a>
<a name="ln1148">		if (status &lt; FSSH_B_OK) {</a>
<a name="ln1149">			put_vnode(vnode);</a>
<a name="ln1150">			return status;</a>
<a name="ln1151">		}</a>
<a name="ln1152"> </a>
<a name="ln1153">		// If the new node is a symbolic link, resolve it (if we've been told to do it)</a>
<a name="ln1154">		if (FSSH_S_ISLNK(vnode-&gt;type)</a>
<a name="ln1155">			&amp;&amp; !(!traverseLeafLink &amp;&amp; nextPath[0] == '\0')) {</a>
<a name="ln1156">			fssh_size_t bufferSize;</a>
<a name="ln1157">			char *buffer;</a>
<a name="ln1158"> </a>
<a name="ln1159">			TRACE((&quot;traverse link\n&quot;));</a>
<a name="ln1160"> </a>
<a name="ln1161">			// it's not exactly nice style using goto in this way, but hey, it works :-/</a>
<a name="ln1162">			if (count + 1 &gt; FSSH_B_MAX_SYMLINKS) {</a>
<a name="ln1163">				status = FSSH_B_LINK_LIMIT;</a>
<a name="ln1164">				goto resolve_link_error;</a>
<a name="ln1165">			}</a>
<a name="ln1166"> </a>
<a name="ln1167">			buffer = (char *)malloc(bufferSize = FSSH_B_PATH_NAME_LENGTH);</a>
<a name="ln1168">			if (buffer == NULL) {</a>
<a name="ln1169">				status = FSSH_B_NO_MEMORY;</a>
<a name="ln1170">				goto resolve_link_error;</a>
<a name="ln1171">			}</a>
<a name="ln1172"> </a>
<a name="ln1173">			if (HAS_FS_CALL(nextVnode, read_symlink)) {</a>
<a name="ln1174">				status = FS_CALL(nextVnode, read_symlink, buffer,</a>
<a name="ln1175">					&amp;bufferSize);</a>
<a name="ln1176">			} else</a>
<a name="ln1177">				status = FSSH_B_BAD_VALUE;</a>
<a name="ln1178"> </a>
<a name="ln1179">			if (status &lt; FSSH_B_OK) {</a>
<a name="ln1180">				free(buffer);</a>
<a name="ln1181"> </a>
<a name="ln1182">		resolve_link_error:</a>
<a name="ln1183">				put_vnode(vnode);</a>
<a name="ln1184">				put_vnode(nextVnode);</a>
<a name="ln1185"> </a>
<a name="ln1186">				return status;</a>
<a name="ln1187">			}</a>
<a name="ln1188">			put_vnode(nextVnode);</a>
<a name="ln1189"> </a>
<a name="ln1190">			// Check if we start from the root directory or the current</a>
<a name="ln1191">			// directory (&quot;vnode&quot; still points to that one).</a>
<a name="ln1192">			// Cut off all leading slashes if it's the root directory</a>
<a name="ln1193">			path = buffer;</a>
<a name="ln1194">			if (path[0] == '/') {</a>
<a name="ln1195">				// we don't need the old directory anymore</a>
<a name="ln1196">				put_vnode(vnode);</a>
<a name="ln1197"> </a>
<a name="ln1198">				while (*++path == '/')</a>
<a name="ln1199">					;</a>
<a name="ln1200">				vnode = sRoot;</a>
<a name="ln1201">				inc_vnode_ref_count(vnode);</a>
<a name="ln1202">			}</a>
<a name="ln1203">			inc_vnode_ref_count(vnode);</a>
<a name="ln1204">				// balance the next recursion - we will decrement the ref_count</a>
<a name="ln1205">				// of the vnode, no matter if we succeeded or not</a>
<a name="ln1206"> </a>
<a name="ln1207">			status = vnode_path_to_vnode(vnode, path, traverseLeafLink, count + 1,</a>
<a name="ln1208">				&amp;nextVnode, &amp;lastParentID);</a>
<a name="ln1209"> </a>
<a name="ln1210">			free(buffer);</a>
<a name="ln1211"> </a>
<a name="ln1212">			if (status &lt; FSSH_B_OK) {</a>
<a name="ln1213">				put_vnode(vnode);</a>
<a name="ln1214">				return status;</a>
<a name="ln1215">			}</a>
<a name="ln1216">		} else</a>
<a name="ln1217">			lastParentID = vnode-&gt;id;</a>
<a name="ln1218"> </a>
<a name="ln1219">		// decrease the ref count on the old dir we just looked up into</a>
<a name="ln1220">		put_vnode(vnode);</a>
<a name="ln1221"> </a>
<a name="ln1222">		path = nextPath;</a>
<a name="ln1223">		vnode = nextVnode;</a>
<a name="ln1224"> </a>
<a name="ln1225">		// see if we hit a mount point</a>
<a name="ln1226">		struct vnode *mountPoint = resolve_mount_point_to_volume_root(vnode);</a>
<a name="ln1227">		if (mountPoint) {</a>
<a name="ln1228">			put_vnode(vnode);</a>
<a name="ln1229">			vnode = mountPoint;</a>
<a name="ln1230">		}</a>
<a name="ln1231">	}</a>
<a name="ln1232"> </a>
<a name="ln1233">	*_vnode = vnode;</a>
<a name="ln1234">	if (_parentID)</a>
<a name="ln1235">		*_parentID = lastParentID;</a>
<a name="ln1236"> </a>
<a name="ln1237">	return FSSH_B_OK;</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240"> </a>
<a name="ln1241">static fssh_status_t</a>
<a name="ln1242">path_to_vnode(char *path, bool traverseLink, struct vnode **_vnode,</a>
<a name="ln1243">	fssh_vnode_id *_parentID, bool kernel)</a>
<a name="ln1244">{</a>
<a name="ln1245">	struct vnode *start = NULL;</a>
<a name="ln1246"> </a>
<a name="ln1247">	FUNCTION((&quot;path_to_vnode(path = \&quot;%s\&quot;)\n&quot;, path));</a>
<a name="ln1248"> </a>
<a name="ln1249">	if (!path)</a>
<a name="ln1250">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1251"> </a>
<a name="ln1252">	// figure out if we need to start at root or at cwd</a>
<a name="ln1253">	if (*path == '/') {</a>
<a name="ln1254">		if (sRoot == NULL) {</a>
<a name="ln1255">			// we're a bit early, aren't we?</a>
<a name="ln1256">			return FSSH_B_ERROR;</a>
<a name="ln1257">		}</a>
<a name="ln1258"> </a>
<a name="ln1259">		while (*++path == '/')</a>
<a name="ln1260">			;</a>
<a name="ln1261">		start = sRoot;</a>
<a name="ln1262">		inc_vnode_ref_count(start);</a>
<a name="ln1263">	} else {</a>
<a name="ln1264">		struct io_context *context = get_current_io_context(kernel);</a>
<a name="ln1265"> </a>
<a name="ln1266">		fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln1267">		start = context-&gt;cwd;</a>
<a name="ln1268">		if (start != NULL)</a>
<a name="ln1269">			inc_vnode_ref_count(start);</a>
<a name="ln1270">		fssh_mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln1271"> </a>
<a name="ln1272">		if (start == NULL)</a>
<a name="ln1273">			return FSSH_B_ERROR;</a>
<a name="ln1274">	}</a>
<a name="ln1275"> </a>
<a name="ln1276">	return vnode_path_to_vnode(start, path, traverseLink, 0, _vnode, _parentID);</a>
<a name="ln1277">}</a>
<a name="ln1278"> </a>
<a name="ln1279"> </a>
<a name="ln1280">/** Returns the vnode in the next to last segment of the path, and returns</a>
<a name="ln1281"> *	the last portion in filename.</a>
<a name="ln1282"> *	The path buffer must be able to store at least one additional character.</a>
<a name="ln1283"> */</a>
<a name="ln1284"> </a>
<a name="ln1285">static fssh_status_t</a>
<a name="ln1286">path_to_dir_vnode(char *path, struct vnode **_vnode, char *filename, bool kernel)</a>
<a name="ln1287">{</a>
<a name="ln1288">	fssh_status_t status = get_dir_path_and_leaf(path, filename);</a>
<a name="ln1289">	if (status != FSSH_B_OK)</a>
<a name="ln1290">		return status;</a>
<a name="ln1291"> </a>
<a name="ln1292">	return path_to_vnode(path, true, _vnode, NULL, kernel);</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295"> </a>
<a name="ln1296">/**	\brief Retrieves the directory vnode and the leaf name of an entry referred</a>
<a name="ln1297"> *		   to by a FD + path pair.</a>
<a name="ln1298"> *</a>
<a name="ln1299"> *	\a path must be given in either case. \a fd might be omitted, in which</a>
<a name="ln1300"> *	case \a path is either an absolute path or one relative to the current</a>
<a name="ln1301"> *	directory. If both a supplied and \a path is relative it is reckoned off</a>
<a name="ln1302"> *	of the directory referred to by \a fd. If \a path is absolute \a fd is</a>
<a name="ln1303"> *	ignored.</a>
<a name="ln1304"> *</a>
<a name="ln1305"> *	The caller has the responsibility to call put_vnode() on the returned</a>
<a name="ln1306"> *	directory vnode.</a>
<a name="ln1307"> *</a>
<a name="ln1308"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln1309"> *	\param path The absolute or relative path. Must not be \c NULL. The buffer</a>
<a name="ln1310"> *	       is modified by this function. It must have at least room for a</a>
<a name="ln1311"> *	       string one character longer than the path it contains.</a>
<a name="ln1312"> *	\param _vnode A pointer to a variable the directory vnode shall be written</a>
<a name="ln1313"> *		   into.</a>
<a name="ln1314"> *	\param filename A buffer of size FSSH_B_FILE_NAME_LENGTH or larger into which</a>
<a name="ln1315"> *		   the leaf name of the specified entry will be written.</a>
<a name="ln1316"> *	\param kernel \c true, if invoked from inside the kernel, \c false if</a>
<a name="ln1317"> *		   invoked from userland.</a>
<a name="ln1318"> *	\return \c FSSH_B_OK, if everything went fine, another error code otherwise.</a>
<a name="ln1319"> */</a>
<a name="ln1320"> </a>
<a name="ln1321">static fssh_status_t</a>
<a name="ln1322">fd_and_path_to_dir_vnode(int fd, char *path, struct vnode **_vnode,</a>
<a name="ln1323">	char *filename, bool kernel)</a>
<a name="ln1324">{</a>
<a name="ln1325">	if (!path)</a>
<a name="ln1326">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1327">	if (fd &lt; 0)</a>
<a name="ln1328">		return path_to_dir_vnode(path, _vnode, filename, kernel);</a>
<a name="ln1329"> </a>
<a name="ln1330">	fssh_status_t status = get_dir_path_and_leaf(path, filename);</a>
<a name="ln1331">	if (status != FSSH_B_OK)</a>
<a name="ln1332">		return status;</a>
<a name="ln1333"> </a>
<a name="ln1334">	return fd_and_path_to_vnode(fd, path, true, _vnode, NULL, kernel);</a>
<a name="ln1335">}</a>
<a name="ln1336"> </a>
<a name="ln1337"> </a>
<a name="ln1338">/** Returns a vnode's name in the d_name field of a supplied dirent buffer.</a>
<a name="ln1339"> */</a>
<a name="ln1340"> </a>
<a name="ln1341">static fssh_status_t</a>
<a name="ln1342">get_vnode_name(struct vnode *vnode, struct vnode *parent,</a>
<a name="ln1343">	struct fssh_dirent *buffer, fssh_size_t bufferSize)</a>
<a name="ln1344">{</a>
<a name="ln1345">	if (bufferSize &lt; sizeof(struct fssh_dirent))</a>
<a name="ln1346">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1347"> </a>
<a name="ln1348">	// See if vnode is the root of a mount and move to the covered</a>
<a name="ln1349">	// vnode so we get the underlying file system</a>
<a name="ln1350">	VNodePutter vnodePutter;</a>
<a name="ln1351">	if (vnode-&gt;mount-&gt;root_vnode == vnode &amp;&amp; vnode-&gt;mount-&gt;covers_vnode != NULL) {</a>
<a name="ln1352">		vnode = vnode-&gt;mount-&gt;covers_vnode;</a>
<a name="ln1353">		inc_vnode_ref_count(vnode);</a>
<a name="ln1354">		vnodePutter.SetTo(vnode);</a>
<a name="ln1355">	}</a>
<a name="ln1356"> </a>
<a name="ln1357">	if (HAS_FS_CALL(vnode, get_vnode_name)) {</a>
<a name="ln1358">		// The FS supports getting the name of a vnode.</a>
<a name="ln1359">		return FS_CALL(vnode, get_vnode_name, buffer-&gt;d_name,</a>
<a name="ln1360">			(char*)buffer + bufferSize - buffer-&gt;d_name);</a>
<a name="ln1361">	}</a>
<a name="ln1362"> </a>
<a name="ln1363">	// The FS doesn't support getting the name of a vnode. So we search the</a>
<a name="ln1364">	// parent directory for the vnode, if the caller let us.</a>
<a name="ln1365"> </a>
<a name="ln1366">	if (parent == NULL)</a>
<a name="ln1367">		return FSSH_EOPNOTSUPP;</a>
<a name="ln1368"> </a>
<a name="ln1369">	void *cookie;</a>
<a name="ln1370"> </a>
<a name="ln1371">	fssh_status_t status = FS_CALL(parent, open_dir, &amp;cookie);</a>
<a name="ln1372">	if (status &gt;= FSSH_B_OK) {</a>
<a name="ln1373">		while (true) {</a>
<a name="ln1374">			uint32_t num = 1;</a>
<a name="ln1375">			status = dir_read(parent, cookie, buffer, bufferSize, &amp;num);</a>
<a name="ln1376">			if (status &lt; FSSH_B_OK)</a>
<a name="ln1377">				break;</a>
<a name="ln1378">			if (num == 0) {</a>
<a name="ln1379">				status = FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln1380">				break;</a>
<a name="ln1381">			}</a>
<a name="ln1382"> </a>
<a name="ln1383">			if (vnode-&gt;id == buffer-&gt;d_ino) {</a>
<a name="ln1384">				// found correct entry!</a>
<a name="ln1385">				break;</a>
<a name="ln1386">			}</a>
<a name="ln1387">		}</a>
<a name="ln1388"> </a>
<a name="ln1389">		FS_CALL(vnode, close_dir, cookie);</a>
<a name="ln1390">		FS_CALL(vnode, free_dir_cookie, cookie);</a>
<a name="ln1391">	}</a>
<a name="ln1392">	return status;</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395"> </a>
<a name="ln1396">static fssh_status_t</a>
<a name="ln1397">get_vnode_name(struct vnode *vnode, struct vnode *parent, char *name,</a>
<a name="ln1398">	fssh_size_t nameSize)</a>
<a name="ln1399">{</a>
<a name="ln1400">	char buffer[sizeof(struct fssh_dirent) + FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln1401">	struct fssh_dirent *dirent = (struct fssh_dirent *)buffer;</a>
<a name="ln1402"> </a>
<a name="ln1403">	fssh_status_t status = get_vnode_name(vnode, parent, buffer, sizeof(buffer));</a>
<a name="ln1404">	if (status != FSSH_B_OK)</a>
<a name="ln1405">		return status;</a>
<a name="ln1406"> </a>
<a name="ln1407">	if (fssh_strlcpy(name, dirent-&gt;d_name, nameSize) &gt;= nameSize)</a>
<a name="ln1408">		return FSSH_B_BUFFER_OVERFLOW;</a>
<a name="ln1409"> </a>
<a name="ln1410">	return FSSH_B_OK;</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413"> </a>
<a name="ln1414">/**	Gets the full path to a given directory vnode.</a>
<a name="ln1415"> *	It uses the fs_get_vnode_name() call to get the name of a vnode; if a</a>
<a name="ln1416"> *	file system doesn't support this call, it will fall back to iterating</a>
<a name="ln1417"> *	through the parent directory to get the name of the child.</a>
<a name="ln1418"> *</a>
<a name="ln1419"> *	To protect against circular loops, it supports a maximum tree depth</a>
<a name="ln1420"> *	of 256 levels.</a>
<a name="ln1421"> *</a>
<a name="ln1422"> *	Note that the path may not be correct the time this function returns!</a>
<a name="ln1423"> *	It doesn't use any locking to prevent returning the correct path, as</a>
<a name="ln1424"> *	paths aren't safe anyway: the path to a file can change at any time.</a>
<a name="ln1425"> *</a>
<a name="ln1426"> *	It might be a good idea, though, to check if the returned path exists</a>
<a name="ln1427"> *	in the calling function (it's not done here because of efficiency)</a>
<a name="ln1428"> */</a>
<a name="ln1429"> </a>
<a name="ln1430">static fssh_status_t</a>
<a name="ln1431">dir_vnode_to_path(struct vnode *vnode, char *buffer, fssh_size_t bufferSize)</a>
<a name="ln1432">{</a>
<a name="ln1433">	FUNCTION((&quot;dir_vnode_to_path(%p, %p, %lu)\n&quot;, vnode, buffer, bufferSize));</a>
<a name="ln1434"> </a>
<a name="ln1435">	if (vnode == NULL || buffer == NULL)</a>
<a name="ln1436">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1437"> </a>
<a name="ln1438">	/* this implementation is currently bound to FSSH_B_PATH_NAME_LENGTH */</a>
<a name="ln1439">	KPath pathBuffer;</a>
<a name="ln1440">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln1441">		return FSSH_B_NO_MEMORY;</a>
<a name="ln1442"> </a>
<a name="ln1443">	char *path = pathBuffer.LockBuffer();</a>
<a name="ln1444">	int32_t insert = pathBuffer.BufferSize();</a>
<a name="ln1445">	int32_t maxLevel = 256;</a>
<a name="ln1446">	int32_t length;</a>
<a name="ln1447">	fssh_status_t status;</a>
<a name="ln1448"> </a>
<a name="ln1449">	// we don't use get_vnode() here because this call is more</a>
<a name="ln1450">	// efficient and does all we need from get_vnode()</a>
<a name="ln1451">	inc_vnode_ref_count(vnode);</a>
<a name="ln1452"> </a>
<a name="ln1453">	// resolve a volume root to its mount point</a>
<a name="ln1454">	struct vnode *mountPoint = resolve_volume_root_to_mount_point(vnode);</a>
<a name="ln1455">	if (mountPoint) {</a>
<a name="ln1456">		put_vnode(vnode);</a>
<a name="ln1457">		vnode = mountPoint;</a>
<a name="ln1458">	}</a>
<a name="ln1459"> </a>
<a name="ln1460">	path[--insert] = '\0';</a>
<a name="ln1461"> </a>
<a name="ln1462">	while (true) {</a>
<a name="ln1463">		// the name buffer is also used for fs_read_dir()</a>
<a name="ln1464">		char nameBuffer[sizeof(struct fssh_dirent) + FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln1465">		char *name = &amp;((struct fssh_dirent *)nameBuffer)-&gt;d_name[0];</a>
<a name="ln1466">		struct vnode *parentVnode;</a>
<a name="ln1467">		fssh_vnode_id parentID;</a>
<a name="ln1468"> </a>
<a name="ln1469">		// lookup the parent vnode</a>
<a name="ln1470">		status = lookup_dir_entry(vnode, &quot;..&quot;, &amp;parentVnode);</a>
<a name="ln1471">		if (status &lt; FSSH_B_OK)</a>
<a name="ln1472">			goto out;</a>
<a name="ln1473"> </a>
<a name="ln1474">		// get the node's name</a>
<a name="ln1475">		status = get_vnode_name(vnode, parentVnode,</a>
<a name="ln1476">			(struct fssh_dirent*)nameBuffer, sizeof(nameBuffer));</a>
<a name="ln1477"> </a>
<a name="ln1478">		// resolve a volume root to its mount point</a>
<a name="ln1479">		mountPoint = resolve_volume_root_to_mount_point(parentVnode);</a>
<a name="ln1480">		if (mountPoint) {</a>
<a name="ln1481">			put_vnode(parentVnode);</a>
<a name="ln1482">			parentVnode = mountPoint;</a>
<a name="ln1483">			parentID = parentVnode-&gt;id;</a>
<a name="ln1484">		}</a>
<a name="ln1485"> </a>
<a name="ln1486">		bool hitRoot = (parentVnode == vnode);</a>
<a name="ln1487"> </a>
<a name="ln1488">		// release the current vnode, we only need its parent from now on</a>
<a name="ln1489">		put_vnode(vnode);</a>
<a name="ln1490">		vnode = parentVnode;</a>
<a name="ln1491"> </a>
<a name="ln1492">		if (status &lt; FSSH_B_OK)</a>
<a name="ln1493">			goto out;</a>
<a name="ln1494"> </a>
<a name="ln1495">		if (hitRoot) {</a>
<a name="ln1496">			// we have reached &quot;/&quot;, which means we have constructed the full</a>
<a name="ln1497">			// path</a>
<a name="ln1498">			break;</a>
<a name="ln1499">		}</a>
<a name="ln1500"> </a>
<a name="ln1501">		// ToDo: add an explicit check for loops in about 10 levels to do</a>
<a name="ln1502">		// real loop detection</a>
<a name="ln1503"> </a>
<a name="ln1504">		// don't go deeper as 'maxLevel' to prevent circular loops</a>
<a name="ln1505">		if (maxLevel-- &lt; 0) {</a>
<a name="ln1506">			status = FSSH_ELOOP;</a>
<a name="ln1507">			goto out;</a>
<a name="ln1508">		}</a>
<a name="ln1509"> </a>
<a name="ln1510">		// add the name in front of the current path</a>
<a name="ln1511">		name[FSSH_B_FILE_NAME_LENGTH - 1] = '\0';</a>
<a name="ln1512">		length = fssh_strlen(name);</a>
<a name="ln1513">		insert -= length;</a>
<a name="ln1514">		if (insert &lt;= 0) {</a>
<a name="ln1515">			status = FSSH_ENOBUFS;</a>
<a name="ln1516">			goto out;</a>
<a name="ln1517">		}</a>
<a name="ln1518">		fssh_memcpy(path + insert, name, length);</a>
<a name="ln1519">		path[--insert] = '/';</a>
<a name="ln1520">	}</a>
<a name="ln1521"> </a>
<a name="ln1522">	// the root dir will result in an empty path: fix it</a>
<a name="ln1523">	if (path[insert] == '\0')</a>
<a name="ln1524">		path[--insert] = '/';</a>
<a name="ln1525"> </a>
<a name="ln1526">	TRACE((&quot;  path is: %s\n&quot;, path + insert));</a>
<a name="ln1527"> </a>
<a name="ln1528">	// copy the path to the output buffer</a>
<a name="ln1529">	length = pathBuffer.BufferSize() - insert;</a>
<a name="ln1530">	if (length &lt;= (int)bufferSize)</a>
<a name="ln1531">		fssh_memcpy(buffer, path + insert, length);</a>
<a name="ln1532">	else</a>
<a name="ln1533">		status = FSSH_ENOBUFS;</a>
<a name="ln1534"> </a>
<a name="ln1535">out:</a>
<a name="ln1536">	put_vnode(vnode);</a>
<a name="ln1537">	return status;</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540"> </a>
<a name="ln1541">/**	Checks the length of every path component, and adds a '.'</a>
<a name="ln1542"> *	if the path ends in a slash.</a>
<a name="ln1543"> *	The given path buffer must be able to store at least one</a>
<a name="ln1544"> *	additional character.</a>
<a name="ln1545"> */</a>
<a name="ln1546"> </a>
<a name="ln1547">static fssh_status_t</a>
<a name="ln1548">check_path(char *to)</a>
<a name="ln1549">{</a>
<a name="ln1550">	int32_t length = 0;</a>
<a name="ln1551"> </a>
<a name="ln1552">	// check length of every path component</a>
<a name="ln1553"> </a>
<a name="ln1554">	while (*to) {</a>
<a name="ln1555">		char *begin;</a>
<a name="ln1556">		if (*to == '/')</a>
<a name="ln1557">			to++, length++;</a>
<a name="ln1558"> </a>
<a name="ln1559">		begin = to;</a>
<a name="ln1560">		while (*to != '/' &amp;&amp; *to)</a>
<a name="ln1561">			to++, length++;</a>
<a name="ln1562"> </a>
<a name="ln1563">		if (to - begin &gt; FSSH_B_FILE_NAME_LENGTH)</a>
<a name="ln1564">			return FSSH_B_NAME_TOO_LONG;</a>
<a name="ln1565">	}</a>
<a name="ln1566"> </a>
<a name="ln1567">	if (length == 0)</a>
<a name="ln1568">		return FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln1569"> </a>
<a name="ln1570">	// complete path if there is a slash at the end</a>
<a name="ln1571"> </a>
<a name="ln1572">	if (*(to - 1) == '/') {</a>
<a name="ln1573">		if (length &gt; FSSH_B_PATH_NAME_LENGTH - 2)</a>
<a name="ln1574">			return FSSH_B_NAME_TOO_LONG;</a>
<a name="ln1575"> </a>
<a name="ln1576">		to[0] = '.';</a>
<a name="ln1577">		to[1] = '\0';</a>
<a name="ln1578">	}</a>
<a name="ln1579"> </a>
<a name="ln1580">	return FSSH_B_OK;</a>
<a name="ln1581">}</a>
<a name="ln1582"> </a>
<a name="ln1583"> </a>
<a name="ln1584">static struct file_descriptor *</a>
<a name="ln1585">get_fd_and_vnode(int fd, struct vnode **_vnode, bool kernel)</a>
<a name="ln1586">{</a>
<a name="ln1587">	struct file_descriptor *descriptor = get_fd(get_current_io_context(kernel), fd);</a>
<a name="ln1588">	if (descriptor == NULL)</a>
<a name="ln1589">		return NULL;</a>
<a name="ln1590"> </a>
<a name="ln1591">	if (fd_vnode(descriptor) == NULL) {</a>
<a name="ln1592">		put_fd(descriptor);</a>
<a name="ln1593">		return NULL;</a>
<a name="ln1594">	}</a>
<a name="ln1595"> </a>
<a name="ln1596">	// ToDo: when we can close a file descriptor at any point, investigate</a>
<a name="ln1597">	//	if this is still valid to do (accessing the vnode without ref_count</a>
<a name="ln1598">	//	or locking)</a>
<a name="ln1599">	*_vnode = descriptor-&gt;u.vnode;</a>
<a name="ln1600">	return descriptor;</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603"> </a>
<a name="ln1604">static struct vnode *</a>
<a name="ln1605">get_vnode_from_fd(int fd, bool kernel)</a>
<a name="ln1606">{</a>
<a name="ln1607">	struct file_descriptor *descriptor;</a>
<a name="ln1608">	struct vnode *vnode;</a>
<a name="ln1609"> </a>
<a name="ln1610">	descriptor = get_fd(get_current_io_context(kernel), fd);</a>
<a name="ln1611">	if (descriptor == NULL)</a>
<a name="ln1612">		return NULL;</a>
<a name="ln1613"> </a>
<a name="ln1614">	vnode = fd_vnode(descriptor);</a>
<a name="ln1615">	if (vnode != NULL)</a>
<a name="ln1616">		inc_vnode_ref_count(vnode);</a>
<a name="ln1617"> </a>
<a name="ln1618">	put_fd(descriptor);</a>
<a name="ln1619">	return vnode;</a>
<a name="ln1620">}</a>
<a name="ln1621"> </a>
<a name="ln1622"> </a>
<a name="ln1623">/**	Gets the vnode from an FD + path combination. If \a fd is lower than zero,</a>
<a name="ln1624"> *	only the path will be considered. In this case, the \a path must not be</a>
<a name="ln1625"> *	NULL.</a>
<a name="ln1626"> *	If \a fd is a valid file descriptor, \a path may be NULL for directories,</a>
<a name="ln1627"> *	and should be NULL for files.</a>
<a name="ln1628"> */</a>
<a name="ln1629"> </a>
<a name="ln1630">static fssh_status_t</a>
<a name="ln1631">fd_and_path_to_vnode(int fd, char *path, bool traverseLeafLink,</a>
<a name="ln1632">	struct vnode **_vnode, fssh_vnode_id *_parentID, bool kernel)</a>
<a name="ln1633">{</a>
<a name="ln1634">	if (fd &lt; 0 &amp;&amp; !path)</a>
<a name="ln1635">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1636"> </a>
<a name="ln1637">	if (fd &lt; 0 || (path != NULL &amp;&amp; path[0] == '/')) {</a>
<a name="ln1638">		// no FD or absolute path</a>
<a name="ln1639">		return path_to_vnode(path, traverseLeafLink, _vnode, _parentID, kernel);</a>
<a name="ln1640">	}</a>
<a name="ln1641"> </a>
<a name="ln1642">	// FD only, or FD + relative path</a>
<a name="ln1643">	struct vnode *vnode = get_vnode_from_fd(fd, kernel);</a>
<a name="ln1644">	if (!vnode)</a>
<a name="ln1645">		return FSSH_B_FILE_ERROR;</a>
<a name="ln1646"> </a>
<a name="ln1647">	if (path != NULL) {</a>
<a name="ln1648">		return vnode_path_to_vnode(vnode, path, traverseLeafLink, 0,</a>
<a name="ln1649">			_vnode, _parentID);</a>
<a name="ln1650">	}</a>
<a name="ln1651"> </a>
<a name="ln1652">	// there is no relative path to take into account</a>
<a name="ln1653"> </a>
<a name="ln1654">	*_vnode = vnode;</a>
<a name="ln1655">	if (_parentID)</a>
<a name="ln1656">		*_parentID = -1;</a>
<a name="ln1657"> </a>
<a name="ln1658">	return FSSH_B_OK;</a>
<a name="ln1659">}</a>
<a name="ln1660"> </a>
<a name="ln1661"> </a>
<a name="ln1662">static int</a>
<a name="ln1663">get_new_fd(int type, struct fs_mount *mount, struct vnode *vnode,</a>
<a name="ln1664">	void *cookie, int openMode, bool kernel)</a>
<a name="ln1665">{</a>
<a name="ln1666">	struct file_descriptor *descriptor;</a>
<a name="ln1667">	int fd;</a>
<a name="ln1668"> </a>
<a name="ln1669">	// if the vnode is locked, we don't allow creating a new file descriptor for it</a>
<a name="ln1670">	if (vnode &amp;&amp; vnode-&gt;mandatory_locked_by != NULL)</a>
<a name="ln1671">		return FSSH_B_BUSY;</a>
<a name="ln1672"> </a>
<a name="ln1673">	descriptor = alloc_fd();</a>
<a name="ln1674">	if (!descriptor)</a>
<a name="ln1675">		return FSSH_B_NO_MEMORY;</a>
<a name="ln1676"> </a>
<a name="ln1677">	if (vnode)</a>
<a name="ln1678">		descriptor-&gt;u.vnode = vnode;</a>
<a name="ln1679">	else</a>
<a name="ln1680">		descriptor-&gt;u.mount = mount;</a>
<a name="ln1681">	descriptor-&gt;cookie = cookie;</a>
<a name="ln1682"> </a>
<a name="ln1683">	switch (type) {</a>
<a name="ln1684">		// vnode types</a>
<a name="ln1685">		case FDTYPE_FILE:</a>
<a name="ln1686">			descriptor-&gt;ops = &amp;sFileOps;</a>
<a name="ln1687">			break;</a>
<a name="ln1688">		case FDTYPE_DIR:</a>
<a name="ln1689">			descriptor-&gt;ops = &amp;sDirectoryOps;</a>
<a name="ln1690">			break;</a>
<a name="ln1691">		case FDTYPE_ATTR:</a>
<a name="ln1692">			descriptor-&gt;ops = &amp;sAttributeOps;</a>
<a name="ln1693">			break;</a>
<a name="ln1694">		case FDTYPE_ATTR_DIR:</a>
<a name="ln1695">			descriptor-&gt;ops = &amp;sAttributeDirectoryOps;</a>
<a name="ln1696">			break;</a>
<a name="ln1697"> </a>
<a name="ln1698">		// mount types</a>
<a name="ln1699">		case FDTYPE_INDEX_DIR:</a>
<a name="ln1700">			descriptor-&gt;ops = &amp;sIndexDirectoryOps;</a>
<a name="ln1701">			break;</a>
<a name="ln1702">		case FDTYPE_QUERY:</a>
<a name="ln1703">			descriptor-&gt;ops = &amp;sQueryOps;</a>
<a name="ln1704">			break;</a>
<a name="ln1705"> </a>
<a name="ln1706">		default:</a>
<a name="ln1707">			fssh_panic(&quot;get_new_fd() called with unknown type %d\n&quot;, type);</a>
<a name="ln1708">			break;</a>
<a name="ln1709">	}</a>
<a name="ln1710">	descriptor-&gt;type = type;</a>
<a name="ln1711">	descriptor-&gt;open_mode = openMode;</a>
<a name="ln1712"> </a>
<a name="ln1713">	fd = new_fd(get_current_io_context(kernel), descriptor);</a>
<a name="ln1714">	if (fd &lt; 0) {</a>
<a name="ln1715">		free(descriptor);</a>
<a name="ln1716">		return FSSH_B_NO_MORE_FDS;</a>
<a name="ln1717">	}</a>
<a name="ln1718"> </a>
<a name="ln1719">	return fd;</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722"> </a>
<a name="ln1723">/*!	Does the dirty work of combining the file_io_vecs with the iovecs</a>
<a name="ln1724">	and calls the file system hooks to read/write the request to disk.</a>
<a name="ln1725">*/</a>
<a name="ln1726">static fssh_status_t</a>
<a name="ln1727">common_file_io_vec_pages(int fd, const fssh_file_io_vec *fileVecs,</a>
<a name="ln1728">	fssh_size_t fileVecCount, const fssh_iovec *vecs, fssh_size_t vecCount,</a>
<a name="ln1729">	uint32_t *_vecIndex, fssh_size_t *_vecOffset, fssh_size_t *_numBytes,</a>
<a name="ln1730">	bool doWrite)</a>
<a name="ln1731">{</a>
<a name="ln1732">	if (fileVecCount == 0) {</a>
<a name="ln1733">		// There are no file vecs at this offset, so we're obviously trying</a>
<a name="ln1734">		// to access the file outside of its bounds</a>
<a name="ln1735">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1736">	}</a>
<a name="ln1737"> </a>
<a name="ln1738">	fssh_size_t numBytes = *_numBytes;</a>
<a name="ln1739">	uint32_t fileVecIndex;</a>
<a name="ln1740">	fssh_size_t vecOffset = *_vecOffset;</a>
<a name="ln1741">	uint32_t vecIndex = *_vecIndex;</a>
<a name="ln1742">	fssh_status_t status;</a>
<a name="ln1743">	fssh_size_t size;</a>
<a name="ln1744"> </a>
<a name="ln1745">	if (!doWrite &amp;&amp; vecOffset == 0) {</a>
<a name="ln1746">		// now directly read the data from the device</a>
<a name="ln1747">		// the first file_io_vec can be read directly</a>
<a name="ln1748"> </a>
<a name="ln1749">		size = fileVecs[0].length;</a>
<a name="ln1750">		if (size &gt; numBytes)</a>
<a name="ln1751">			size = numBytes;</a>
<a name="ln1752"> </a>
<a name="ln1753">		status = fssh_read_pages(fd, fileVecs[0].offset, &amp;vecs[vecIndex],</a>
<a name="ln1754">			vecCount - vecIndex, &amp;size);</a>
<a name="ln1755">		if (status &lt; FSSH_B_OK)</a>
<a name="ln1756">			return status;</a>
<a name="ln1757"> </a>
<a name="ln1758">		// TODO: this is a work-around for buggy device drivers!</a>
<a name="ln1759">		//	When our own drivers honour the length, we can:</a>
<a name="ln1760">		//	a) also use this direct I/O for writes (otherwise, it would</a>
<a name="ln1761">		//	   overwrite precious data)</a>
<a name="ln1762">		//	b) panic if the term below is true (at least for writes)</a>
<a name="ln1763">		if ((uint64_t)size &gt; (uint64_t)fileVecs[0].length) {</a>
<a name="ln1764">			//dprintf(&quot;warning: device driver %p doesn't respect total length in read_pages() call!\n&quot;, ref-&gt;device);</a>
<a name="ln1765">			size = fileVecs[0].length;</a>
<a name="ln1766">		}</a>
<a name="ln1767"> </a>
<a name="ln1768">		ASSERT(size &lt;= fileVecs[0].length);</a>
<a name="ln1769"> </a>
<a name="ln1770">		// If the file portion was contiguous, we're already done now</a>
<a name="ln1771">		if (size == numBytes)</a>
<a name="ln1772">			return FSSH_B_OK;</a>
<a name="ln1773"> </a>
<a name="ln1774">		// if we reached the end of the file, we can return as well</a>
<a name="ln1775">		if ((uint64_t)size != (uint64_t)fileVecs[0].length) {</a>
<a name="ln1776">			*_numBytes = size;</a>
<a name="ln1777">			return FSSH_B_OK;</a>
<a name="ln1778">		}</a>
<a name="ln1779"> </a>
<a name="ln1780">		fileVecIndex = 1;</a>
<a name="ln1781"> </a>
<a name="ln1782">		// first, find out where we have to continue in our iovecs</a>
<a name="ln1783">		for (; vecIndex &lt; vecCount; vecIndex++) {</a>
<a name="ln1784">			if (size &lt; vecs[vecIndex].iov_len)</a>
<a name="ln1785">				break;</a>
<a name="ln1786"> </a>
<a name="ln1787">			size -= vecs[vecIndex].iov_len;</a>
<a name="ln1788">		}</a>
<a name="ln1789"> </a>
<a name="ln1790">		vecOffset = size;</a>
<a name="ln1791">	} else {</a>
<a name="ln1792">		fileVecIndex = 0;</a>
<a name="ln1793">		size = 0;</a>
<a name="ln1794">	}</a>
<a name="ln1795"> </a>
<a name="ln1796">	// Too bad, let's process the rest of the file_io_vecs</a>
<a name="ln1797"> </a>
<a name="ln1798">	fssh_size_t totalSize = size;</a>
<a name="ln1799">	fssh_size_t bytesLeft = numBytes - size;</a>
<a name="ln1800"> </a>
<a name="ln1801">	for (; fileVecIndex &lt; fileVecCount; fileVecIndex++) {</a>
<a name="ln1802">		const fssh_file_io_vec &amp;fileVec = fileVecs[fileVecIndex];</a>
<a name="ln1803">		fssh_off_t fileOffset = fileVec.offset;</a>
<a name="ln1804">		fssh_off_t fileLeft = fssh_min_c((uint64_t)fileVec.length, (uint64_t)bytesLeft);</a>
<a name="ln1805"> </a>
<a name="ln1806">		TRACE((&quot;FILE VEC [%lu] length %Ld\n&quot;, fileVecIndex, fileLeft));</a>
<a name="ln1807"> </a>
<a name="ln1808">		// process the complete fileVec</a>
<a name="ln1809">		while (fileLeft &gt; 0) {</a>
<a name="ln1810">			fssh_iovec tempVecs[MAX_TEMP_IO_VECS];</a>
<a name="ln1811">			uint32_t tempCount = 0;</a>
<a name="ln1812"> </a>
<a name="ln1813">			// size tracks how much of what is left of the current fileVec</a>
<a name="ln1814">			// (fileLeft) has been assigned to tempVecs</a>
<a name="ln1815">			size = 0;</a>
<a name="ln1816"> </a>
<a name="ln1817">			// assign what is left of the current fileVec to the tempVecs</a>
<a name="ln1818">			for (size = 0; (uint64_t)size &lt; (uint64_t)fileLeft &amp;&amp; vecIndex &lt; vecCount</a>
<a name="ln1819">					&amp;&amp; tempCount &lt; MAX_TEMP_IO_VECS;) {</a>
<a name="ln1820">				// try to satisfy one iovec per iteration (or as much as</a>
<a name="ln1821">				// possible)</a>
<a name="ln1822"> </a>
<a name="ln1823">				// bytes left of the current iovec</a>
<a name="ln1824">				fssh_size_t vecLeft = vecs[vecIndex].iov_len - vecOffset;</a>
<a name="ln1825">				if (vecLeft == 0) {</a>
<a name="ln1826">					vecOffset = 0;</a>
<a name="ln1827">					vecIndex++;</a>
<a name="ln1828">					continue;</a>
<a name="ln1829">				}</a>
<a name="ln1830"> </a>
<a name="ln1831">				TRACE((&quot;fill vec %ld, offset = %lu, size = %lu\n&quot;,</a>
<a name="ln1832">					vecIndex, vecOffset, size));</a>
<a name="ln1833"> </a>
<a name="ln1834">				// actually available bytes</a>
<a name="ln1835">				fssh_size_t tempVecSize = fssh_min_c(vecLeft, fileLeft - size);</a>
<a name="ln1836"> </a>
<a name="ln1837">				tempVecs[tempCount].iov_base</a>
<a name="ln1838">					= (void *)((fssh_addr_t)vecs[vecIndex].iov_base + vecOffset);</a>
<a name="ln1839">				tempVecs[tempCount].iov_len = tempVecSize;</a>
<a name="ln1840">				tempCount++;</a>
<a name="ln1841"> </a>
<a name="ln1842">				size += tempVecSize;</a>
<a name="ln1843">				vecOffset += tempVecSize;</a>
<a name="ln1844">			}</a>
<a name="ln1845"> </a>
<a name="ln1846">			fssh_size_t bytes = size;</a>
<a name="ln1847">			if (doWrite) {</a>
<a name="ln1848">				status = fssh_write_pages(fd, fileOffset, tempVecs,</a>
<a name="ln1849">					tempCount, &amp;bytes);</a>
<a name="ln1850">			} else {</a>
<a name="ln1851">				status = fssh_read_pages(fd, fileOffset, tempVecs,</a>
<a name="ln1852">					tempCount, &amp;bytes);</a>
<a name="ln1853">			}</a>
<a name="ln1854">			if (status &lt; FSSH_B_OK)</a>
<a name="ln1855">				return status;</a>
<a name="ln1856"> </a>
<a name="ln1857">			totalSize += bytes;</a>
<a name="ln1858">			bytesLeft -= size;</a>
<a name="ln1859">			fileOffset += size;</a>
<a name="ln1860">			fileLeft -= size;</a>
<a name="ln1861"> </a>
<a name="ln1862">			if (size != bytes || vecIndex &gt;= vecCount) {</a>
<a name="ln1863">				// there are no more bytes or iovecs, let's bail out</a>
<a name="ln1864">				*_numBytes = totalSize;</a>
<a name="ln1865">				return FSSH_B_OK;</a>
<a name="ln1866">			}</a>
<a name="ln1867">		}</a>
<a name="ln1868">	}</a>
<a name="ln1869"> </a>
<a name="ln1870">	*_vecIndex = vecIndex;</a>
<a name="ln1871">	*_vecOffset = vecOffset;</a>
<a name="ln1872">	*_numBytes = totalSize;</a>
<a name="ln1873">	return FSSH_B_OK;</a>
<a name="ln1874">}</a>
<a name="ln1875"> </a>
<a name="ln1876"> </a>
<a name="ln1877">//	#pragma mark - public VFS API</a>
<a name="ln1878"> </a>
<a name="ln1879"> </a>
<a name="ln1880">extern &quot;C&quot; fssh_status_t</a>
<a name="ln1881">fssh_new_vnode(fssh_fs_volume *volume, fssh_vnode_id vnodeID,</a>
<a name="ln1882">	void *privateNode, fssh_fs_vnode_ops *ops)</a>
<a name="ln1883">{</a>
<a name="ln1884">	FUNCTION((&quot;new_vnode(volume = %p (%ld), vnodeID = %Ld, node = %p)\n&quot;,</a>
<a name="ln1885">		volume, volume-&gt;id, vnodeID, privateNode));</a>
<a name="ln1886"> </a>
<a name="ln1887">	if (privateNode == NULL)</a>
<a name="ln1888">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1889"> </a>
<a name="ln1890">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln1891"> </a>
<a name="ln1892">	// file system integrity check:</a>
<a name="ln1893">	// test if the vnode already exists and bail out if this is the case!</a>
<a name="ln1894"> </a>
<a name="ln1895">	// ToDo: the R5 implementation obviously checks for a different cookie</a>
<a name="ln1896">	//	and doesn't panic if they are equal</a>
<a name="ln1897"> </a>
<a name="ln1898">	struct vnode *vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln1899">	if (vnode != NULL) {</a>
<a name="ln1900">		fssh_panic(&quot;vnode %d:%&quot; FSSH_B_PRIdINO &quot; already exists (node = %p, &quot;</a>
<a name="ln1901">			&quot;vnode-&gt;node = %p)!&quot;, (int)volume-&gt;id, vnodeID, privateNode,</a>
<a name="ln1902">			vnode-&gt;private_node);</a>
<a name="ln1903">	}</a>
<a name="ln1904"> </a>
<a name="ln1905">	fssh_status_t status = create_new_vnode(&amp;vnode, volume-&gt;id, vnodeID);</a>
<a name="ln1906">	if (status == FSSH_B_OK) {</a>
<a name="ln1907">		vnode-&gt;private_node = privateNode;</a>
<a name="ln1908">		vnode-&gt;ops = ops;</a>
<a name="ln1909">		vnode-&gt;busy = true;</a>
<a name="ln1910">		vnode-&gt;unpublished = true;</a>
<a name="ln1911">	}</a>
<a name="ln1912"> </a>
<a name="ln1913">	TRACE((&quot;returns: %s\n&quot;, strerror(status)));</a>
<a name="ln1914"> </a>
<a name="ln1915">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln1916">	return status;</a>
<a name="ln1917">}</a>
<a name="ln1918"> </a>
<a name="ln1919"> </a>
<a name="ln1920">extern &quot;C&quot; fssh_status_t</a>
<a name="ln1921">fssh_publish_vnode(fssh_fs_volume *volume, fssh_vnode_id vnodeID,</a>
<a name="ln1922">	void *privateNode, fssh_fs_vnode_ops *ops, int type, uint32_t flags)</a>
<a name="ln1923">{</a>
<a name="ln1924">	FUNCTION((&quot;publish_vnode()\n&quot;));</a>
<a name="ln1925"> </a>
<a name="ln1926">	MutexLocker locker(sVnodeMutex);</a>
<a name="ln1927"> </a>
<a name="ln1928">	struct vnode *vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln1929">	fssh_status_t status = FSSH_B_OK;</a>
<a name="ln1930"> </a>
<a name="ln1931">	if (vnode != NULL &amp;&amp; vnode-&gt;busy &amp;&amp; vnode-&gt;unpublished</a>
<a name="ln1932">		&amp;&amp; vnode-&gt;private_node == privateNode) {</a>
<a name="ln1933">		// already known, but not published</a>
<a name="ln1934">	} else if (vnode == NULL &amp;&amp; privateNode != NULL) {</a>
<a name="ln1935">		status = create_new_vnode(&amp;vnode, volume-&gt;id, vnodeID);</a>
<a name="ln1936">		if (status == FSSH_B_OK) {</a>
<a name="ln1937">			vnode-&gt;private_node = privateNode;</a>
<a name="ln1938">			vnode-&gt;ops = ops;</a>
<a name="ln1939">			vnode-&gt;busy = true;</a>
<a name="ln1940">			vnode-&gt;unpublished = true;</a>
<a name="ln1941">		}</a>
<a name="ln1942">	} else</a>
<a name="ln1943">		status = FSSH_B_BAD_VALUE;</a>
<a name="ln1944"> </a>
<a name="ln1945">	// create sub vnodes, if necessary</a>
<a name="ln1946">	if (status == FSSH_B_OK &amp;&amp; volume-&gt;sub_volume != NULL) {</a>
<a name="ln1947">		locker.Unlock();</a>
<a name="ln1948"> </a>
<a name="ln1949">		fssh_fs_volume *subVolume = volume;</a>
<a name="ln1950">		while (status == FSSH_B_OK &amp;&amp; subVolume-&gt;sub_volume != NULL) {</a>
<a name="ln1951">			subVolume = subVolume-&gt;sub_volume;</a>
<a name="ln1952">			status = subVolume-&gt;ops-&gt;create_sub_vnode(subVolume, vnodeID,</a>
<a name="ln1953">				vnode);</a>
<a name="ln1954">		}</a>
<a name="ln1955"> </a>
<a name="ln1956">		if (status != FSSH_B_OK) {</a>
<a name="ln1957">			// error -- clean up the created sub vnodes</a>
<a name="ln1958">			while (subVolume-&gt;super_volume != volume) {</a>
<a name="ln1959">				subVolume = subVolume-&gt;super_volume;</a>
<a name="ln1960">				subVolume-&gt;ops-&gt;delete_sub_vnode(subVolume, vnode);</a>
<a name="ln1961">			}</a>
<a name="ln1962">		}</a>
<a name="ln1963"> </a>
<a name="ln1964">		locker.Lock();</a>
<a name="ln1965">	}</a>
<a name="ln1966"> </a>
<a name="ln1967">	if (status == FSSH_B_OK) {</a>
<a name="ln1968">		vnode-&gt;type = type;</a>
<a name="ln1969">		vnode-&gt;busy = false;</a>
<a name="ln1970">		vnode-&gt;unpublished = false;</a>
<a name="ln1971">	}</a>
<a name="ln1972"> </a>
<a name="ln1973">	TRACE((&quot;returns: %s\n&quot;, strerror(status)));</a>
<a name="ln1974"> </a>
<a name="ln1975">	return status;</a>
<a name="ln1976">}</a>
<a name="ln1977"> </a>
<a name="ln1978"> </a>
<a name="ln1979">extern &quot;C&quot; fssh_status_t</a>
<a name="ln1980">fssh_get_vnode(fssh_fs_volume *volume, fssh_vnode_id vnodeID,</a>
<a name="ln1981">	void **privateNode)</a>
<a name="ln1982">{</a>
<a name="ln1983">	struct vnode *vnode;</a>
<a name="ln1984"> </a>
<a name="ln1985">	if (volume == NULL)</a>
<a name="ln1986">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1987"> </a>
<a name="ln1988">	fssh_status_t status = get_vnode(volume-&gt;id, vnodeID, &amp;vnode, true);</a>
<a name="ln1989">	if (status &lt; FSSH_B_OK)</a>
<a name="ln1990">		return status;</a>
<a name="ln1991"> </a>
<a name="ln1992">	// If this is a layered FS, we need to get the node cookie for the requested</a>
<a name="ln1993">	// layer.</a>
<a name="ln1994">	if (HAS_FS_CALL(vnode, get_super_vnode)) {</a>
<a name="ln1995">		fssh_fs_vnode resolvedNode;</a>
<a name="ln1996">		fssh_status_t status = FS_CALL(vnode, get_super_vnode, volume,</a>
<a name="ln1997">			&amp;resolvedNode);</a>
<a name="ln1998">		if (status != FSSH_B_OK) {</a>
<a name="ln1999">			fssh_panic(&quot;get_vnode(): Failed to get super node for vnode %p, &quot;</a>
<a name="ln2000">				&quot;volume: %p&quot;, vnode, volume);</a>
<a name="ln2001">			put_vnode(vnode);</a>
<a name="ln2002">			return status;</a>
<a name="ln2003">		}</a>
<a name="ln2004"> </a>
<a name="ln2005">		if (privateNode != NULL)</a>
<a name="ln2006">			*privateNode = resolvedNode.private_node;</a>
<a name="ln2007">	} else if (privateNode != NULL)</a>
<a name="ln2008">		*privateNode = vnode-&gt;private_node;</a>
<a name="ln2009"> </a>
<a name="ln2010">	return FSSH_B_OK;</a>
<a name="ln2011">}</a>
<a name="ln2012"> </a>
<a name="ln2013"> </a>
<a name="ln2014">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2015">fssh_acquire_vnode(fssh_fs_volume *volume, fssh_vnode_id vnodeID)</a>
<a name="ln2016">{</a>
<a name="ln2017">	struct vnode *vnode;</a>
<a name="ln2018"> </a>
<a name="ln2019">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln2020">	vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln2021">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2022"> </a>
<a name="ln2023">	if (vnode == NULL)</a>
<a name="ln2024">		return FSSH_B_BAD_VALUE;</a>
<a name="ln2025"> </a>
<a name="ln2026">	inc_vnode_ref_count(vnode);</a>
<a name="ln2027">	return FSSH_B_OK;</a>
<a name="ln2028">}</a>
<a name="ln2029"> </a>
<a name="ln2030"> </a>
<a name="ln2031">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2032">fssh_put_vnode(fssh_fs_volume *volume, fssh_vnode_id vnodeID)</a>
<a name="ln2033">{</a>
<a name="ln2034">	struct vnode *vnode;</a>
<a name="ln2035"> </a>
<a name="ln2036">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln2037">	vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln2038">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2039"> </a>
<a name="ln2040">	if (vnode == NULL)</a>
<a name="ln2041">		return FSSH_B_BAD_VALUE;</a>
<a name="ln2042"> </a>
<a name="ln2043">	dec_vnode_ref_count(vnode, true);</a>
<a name="ln2044">	return FSSH_B_OK;</a>
<a name="ln2045">}</a>
<a name="ln2046"> </a>
<a name="ln2047"> </a>
<a name="ln2048">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2049">fssh_remove_vnode(fssh_fs_volume *volume, fssh_vnode_id vnodeID)</a>
<a name="ln2050">{</a>
<a name="ln2051">	struct vnode *vnode;</a>
<a name="ln2052">	bool remove = false;</a>
<a name="ln2053"> </a>
<a name="ln2054">	MutexLocker locker(sVnodeMutex);</a>
<a name="ln2055"> </a>
<a name="ln2056">	vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln2057">	if (vnode == NULL)</a>
<a name="ln2058">		return FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln2059"> </a>
<a name="ln2060">	if (vnode-&gt;covered_by != NULL) {</a>
<a name="ln2061">		// this vnode is in use</a>
<a name="ln2062">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2063">		return FSSH_B_BUSY;</a>
<a name="ln2064">	}</a>
<a name="ln2065"> </a>
<a name="ln2066">	vnode-&gt;remove = true;</a>
<a name="ln2067">	if (vnode-&gt;unpublished) {</a>
<a name="ln2068">		// prepare the vnode for deletion</a>
<a name="ln2069">		vnode-&gt;busy = true;</a>
<a name="ln2070">		remove = true;</a>
<a name="ln2071">	}</a>
<a name="ln2072"> </a>
<a name="ln2073">	locker.Unlock();</a>
<a name="ln2074"> </a>
<a name="ln2075">	if (remove) {</a>
<a name="ln2076">		// if the vnode hasn't been published yet, we delete it here</a>
<a name="ln2077">		fssh_atomic_add(&amp;vnode-&gt;ref_count, -1);</a>
<a name="ln2078">		free_vnode(vnode, true);</a>
<a name="ln2079">	}</a>
<a name="ln2080"> </a>
<a name="ln2081">	return FSSH_B_OK;</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084"> </a>
<a name="ln2085">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2086">fssh_unremove_vnode(fssh_fs_volume *volume, fssh_vnode_id vnodeID)</a>
<a name="ln2087">{</a>
<a name="ln2088">	struct vnode *vnode;</a>
<a name="ln2089"> </a>
<a name="ln2090">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln2091"> </a>
<a name="ln2092">	vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln2093">	if (vnode)</a>
<a name="ln2094">		vnode-&gt;remove = false;</a>
<a name="ln2095"> </a>
<a name="ln2096">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2097">	return FSSH_B_OK;</a>
<a name="ln2098">}</a>
<a name="ln2099"> </a>
<a name="ln2100"> </a>
<a name="ln2101">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2102">fssh_get_vnode_removed(fssh_fs_volume *volume, fssh_vnode_id vnodeID, bool* removed)</a>
<a name="ln2103">{</a>
<a name="ln2104">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln2105"> </a>
<a name="ln2106">	fssh_status_t result;</a>
<a name="ln2107"> </a>
<a name="ln2108">	if (struct vnode* vnode = lookup_vnode(volume-&gt;id, vnodeID)) {</a>
<a name="ln2109">		if (removed)</a>
<a name="ln2110">			*removed = vnode-&gt;remove;</a>
<a name="ln2111">		result = FSSH_B_OK;</a>
<a name="ln2112">	} else</a>
<a name="ln2113">		result = FSSH_B_BAD_VALUE;</a>
<a name="ln2114"> </a>
<a name="ln2115">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2116">	return result;</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119"> </a>
<a name="ln2120">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2121">fssh_mark_vnode_busy(fssh_fs_volume* volume, fssh_vnode_id vnodeID, bool busy)</a>
<a name="ln2122">{</a>
<a name="ln2123">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln2124"> </a>
<a name="ln2125">	struct vnode* vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln2126">	if (vnode == NULL) {</a>
<a name="ln2127">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2128">		return FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln2129">	}</a>
<a name="ln2130"> </a>
<a name="ln2131">	// are we trying to mark an already busy node busy again?</a>
<a name="ln2132">	if (busy &amp;&amp; vnode-&gt;busy) {</a>
<a name="ln2133">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2134">		return FSSH_B_BUSY;</a>
<a name="ln2135">	}</a>
<a name="ln2136"> </a>
<a name="ln2137">	vnode-&gt;busy = busy;</a>
<a name="ln2138"> </a>
<a name="ln2139">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2140">	return FSSH_B_OK;</a>
<a name="ln2141">}</a>
<a name="ln2142"> </a>
<a name="ln2143"> </a>
<a name="ln2144">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2145">fssh_change_vnode_id(fssh_fs_volume* volume, fssh_vnode_id vnodeID,</a>
<a name="ln2146">	fssh_vnode_id newID)</a>
<a name="ln2147">{</a>
<a name="ln2148">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln2149"> </a>
<a name="ln2150">	struct vnode* vnode = lookup_vnode(volume-&gt;id, vnodeID);</a>
<a name="ln2151">	if (vnode == NULL) {</a>
<a name="ln2152">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2153">		return FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln2154">	}</a>
<a name="ln2155"> </a>
<a name="ln2156">	hash_remove(sVnodeTable, vnode);</a>
<a name="ln2157">	vnode-&gt;id = newID;</a>
<a name="ln2158">	hash_insert(sVnodeTable, vnode);</a>
<a name="ln2159"> </a>
<a name="ln2160">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2161">	return FSSH_B_OK;</a>
<a name="ln2162">}</a>
<a name="ln2163"> </a>
<a name="ln2164"> </a>
<a name="ln2165">extern &quot;C&quot; fssh_fs_volume*</a>
<a name="ln2166">fssh_volume_for_vnode(fssh_fs_vnode *_vnode)</a>
<a name="ln2167">{</a>
<a name="ln2168">	if (_vnode == NULL)</a>
<a name="ln2169">		return NULL;</a>
<a name="ln2170"> </a>
<a name="ln2171">	struct vnode* vnode = static_cast&lt;struct vnode*&gt;(_vnode);</a>
<a name="ln2172">	return vnode-&gt;mount-&gt;volume;</a>
<a name="ln2173">}</a>
<a name="ln2174"> </a>
<a name="ln2175"> </a>
<a name="ln2176">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2177">fssh_check_access_permissions(int accessMode, fssh_mode_t mode,</a>
<a name="ln2178">	fssh_gid_t nodeGroupID, fssh_uid_t nodeUserID)</a>
<a name="ln2179">{</a>
<a name="ln2180">	// get node permissions</a>
<a name="ln2181">	int userPermissions = (mode &amp; FSSH_S_IRWXU) &gt;&gt; 6;</a>
<a name="ln2182">	int groupPermissions = (mode &amp; FSSH_S_IRWXG) &gt;&gt; 3;</a>
<a name="ln2183">	int otherPermissions = mode &amp; FSSH_S_IRWXO;</a>
<a name="ln2184"> </a>
<a name="ln2185">	// get the node permissions for this uid/gid</a>
<a name="ln2186">	int permissions = 0;</a>
<a name="ln2187">	fssh_uid_t uid = fssh_geteuid();</a>
<a name="ln2188"> </a>
<a name="ln2189">	if (uid == 0) {</a>
<a name="ln2190">		// user is root</a>
<a name="ln2191">		// root has always read/write permission, but at least one of the</a>
<a name="ln2192">		// X bits must be set for execute permission</a>
<a name="ln2193">		permissions = userPermissions | groupPermissions | otherPermissions</a>
<a name="ln2194">			| FSSH_S_IROTH | FSSH_S_IWOTH;</a>
<a name="ln2195">		if (FSSH_S_ISDIR(mode))</a>
<a name="ln2196">			permissions |= FSSH_S_IXOTH;</a>
<a name="ln2197">	} else if (uid == nodeUserID) {</a>
<a name="ln2198">		// user is node owner</a>
<a name="ln2199">		permissions = userPermissions;</a>
<a name="ln2200">	} else if (fssh_getegid() == nodeGroupID) {</a>
<a name="ln2201">		// user is in owning group</a>
<a name="ln2202">		permissions = groupPermissions;</a>
<a name="ln2203">	} else {</a>
<a name="ln2204">		// user is one of the others</a>
<a name="ln2205">		permissions = otherPermissions;</a>
<a name="ln2206">	}</a>
<a name="ln2207"> </a>
<a name="ln2208">	return (accessMode &amp; ~permissions) == 0 ? FSSH_B_OK : FSSH_B_NOT_ALLOWED;</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211"> </a>
<a name="ln2212">//! Works directly on the host's file system</a>
<a name="ln2213">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2214">fssh_read_pages(int fd, fssh_off_t pos, const fssh_iovec *vecs,</a>
<a name="ln2215">	fssh_size_t count, fssh_size_t *_numBytes)</a>
<a name="ln2216">{</a>
<a name="ln2217">	// check how much the iovecs allow us to read</a>
<a name="ln2218">	fssh_size_t toRead = 0;</a>
<a name="ln2219">	for (fssh_size_t i = 0; i &lt; count; i++)</a>
<a name="ln2220">		toRead += vecs[i].iov_len;</a>
<a name="ln2221"> </a>
<a name="ln2222">	fssh_iovec* newVecs = NULL;</a>
<a name="ln2223">	if (*_numBytes &lt; toRead) {</a>
<a name="ln2224">		// We're supposed to read less than specified by the vecs. Since</a>
<a name="ln2225">		// readv_pos() doesn't support this, we need to clone the vecs.</a>
<a name="ln2226">		newVecs = new(std::nothrow) fssh_iovec[count];</a>
<a name="ln2227">		if (!newVecs)</a>
<a name="ln2228">			return FSSH_B_NO_MEMORY;</a>
<a name="ln2229"> </a>
<a name="ln2230">		fssh_size_t newCount = 0;</a>
<a name="ln2231">		for (fssh_size_t i = 0; i &lt; count &amp;&amp; toRead &gt; 0; i++) {</a>
<a name="ln2232">			fssh_size_t vecLen = fssh_min_c(vecs[i].iov_len, toRead);</a>
<a name="ln2233">			newVecs[i].iov_base = vecs[i].iov_base;</a>
<a name="ln2234">			newVecs[i].iov_len = vecLen;</a>
<a name="ln2235">			toRead -= vecLen;</a>
<a name="ln2236">			newCount++;</a>
<a name="ln2237">		}</a>
<a name="ln2238"> </a>
<a name="ln2239">		vecs = newVecs;</a>
<a name="ln2240">		count = newCount;</a>
<a name="ln2241">	}</a>
<a name="ln2242"> </a>
<a name="ln2243">	fssh_ssize_t bytesRead = fssh_readv_pos(fd, pos, vecs, count);</a>
<a name="ln2244">	delete[] newVecs;</a>
<a name="ln2245">	if (bytesRead &lt; 0)</a>
<a name="ln2246">		return fssh_get_errno();</a>
<a name="ln2247"> </a>
<a name="ln2248">	*_numBytes = bytesRead;</a>
<a name="ln2249">	return FSSH_B_OK;</a>
<a name="ln2250">}</a>
<a name="ln2251"> </a>
<a name="ln2252"> </a>
<a name="ln2253">//! Works directly on the host's file system</a>
<a name="ln2254">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2255">fssh_write_pages(int fd, fssh_off_t pos, const fssh_iovec *vecs,</a>
<a name="ln2256">	fssh_size_t count, fssh_size_t *_numBytes)</a>
<a name="ln2257">{</a>
<a name="ln2258">	// check how much the iovecs allow us to write</a>
<a name="ln2259">	fssh_size_t toWrite = 0;</a>
<a name="ln2260">	for (fssh_size_t i = 0; i &lt; count; i++)</a>
<a name="ln2261">		toWrite += vecs[i].iov_len;</a>
<a name="ln2262"> </a>
<a name="ln2263">	fssh_iovec* newVecs = NULL;</a>
<a name="ln2264">	if (*_numBytes &lt; toWrite) {</a>
<a name="ln2265">		// We're supposed to write less than specified by the vecs. Since</a>
<a name="ln2266">		// writev_pos() doesn't support this, we need to clone the vecs.</a>
<a name="ln2267">		newVecs = new(std::nothrow) fssh_iovec[count];</a>
<a name="ln2268">		if (!newVecs)</a>
<a name="ln2269">			return FSSH_B_NO_MEMORY;</a>
<a name="ln2270"> </a>
<a name="ln2271">		fssh_size_t newCount = 0;</a>
<a name="ln2272">		for (fssh_size_t i = 0; i &lt; count &amp;&amp; toWrite &gt; 0; i++) {</a>
<a name="ln2273">			fssh_size_t vecLen = fssh_min_c(vecs[i].iov_len, toWrite);</a>
<a name="ln2274">			newVecs[i].iov_base = vecs[i].iov_base;</a>
<a name="ln2275">			newVecs[i].iov_len = vecLen;</a>
<a name="ln2276">			toWrite -= vecLen;</a>
<a name="ln2277">			newCount++;</a>
<a name="ln2278">		}</a>
<a name="ln2279"> </a>
<a name="ln2280">		vecs = newVecs;</a>
<a name="ln2281">		count = newCount;</a>
<a name="ln2282">	}</a>
<a name="ln2283"> </a>
<a name="ln2284">	fssh_ssize_t bytesWritten = fssh_writev_pos(fd, pos, vecs, count);</a>
<a name="ln2285">	delete[] newVecs;</a>
<a name="ln2286">	if (bytesWritten &lt; 0)</a>
<a name="ln2287">		return fssh_get_errno();</a>
<a name="ln2288"> </a>
<a name="ln2289">	*_numBytes = bytesWritten;</a>
<a name="ln2290">	return FSSH_B_OK;</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293"> </a>
<a name="ln2294">//! Works directly on the host's file system</a>
<a name="ln2295">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2296">fssh_read_file_io_vec_pages(int fd, const fssh_file_io_vec *fileVecs,</a>
<a name="ln2297">	fssh_size_t fileVecCount, const fssh_iovec *vecs, fssh_size_t vecCount,</a>
<a name="ln2298">	uint32_t *_vecIndex, fssh_size_t *_vecOffset, fssh_size_t *_bytes)</a>
<a name="ln2299">{</a>
<a name="ln2300">	return common_file_io_vec_pages(fd, fileVecs, fileVecCount,</a>
<a name="ln2301">		vecs, vecCount, _vecIndex, _vecOffset, _bytes, false);</a>
<a name="ln2302">}</a>
<a name="ln2303"> </a>
<a name="ln2304"> </a>
<a name="ln2305">//! Works directly on the host's file system</a>
<a name="ln2306">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2307">fssh_write_file_io_vec_pages(int fd, const fssh_file_io_vec *fileVecs,</a>
<a name="ln2308">	fssh_size_t fileVecCount, const fssh_iovec *vecs, fssh_size_t vecCount,</a>
<a name="ln2309">	uint32_t *_vecIndex, fssh_size_t *_vecOffset, fssh_size_t *_bytes)</a>
<a name="ln2310">{</a>
<a name="ln2311">	return common_file_io_vec_pages(fd, fileVecs, fileVecCount,</a>
<a name="ln2312">		vecs, vecCount, _vecIndex, _vecOffset, _bytes, true);</a>
<a name="ln2313">}</a>
<a name="ln2314"> </a>
<a name="ln2315"> </a>
<a name="ln2316">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2317">fssh_entry_cache_add(fssh_dev_t mountID, fssh_ino_t dirID, const char* name,</a>
<a name="ln2318">	fssh_ino_t nodeID)</a>
<a name="ln2319">{</a>
<a name="ln2320">	// We don't implement an entry cache in the FS shell.</a>
<a name="ln2321">	return FSSH_B_OK;</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324"> </a>
<a name="ln2325">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2326">fssh_entry_cache_add_missing(fssh_dev_t mountID, fssh_ino_t dirID,</a>
<a name="ln2327">	const char* name)</a>
<a name="ln2328">{</a>
<a name="ln2329">	// We don't implement an entry cache in the FS shell.</a>
<a name="ln2330">	return FSSH_B_OK;</a>
<a name="ln2331">}</a>
<a name="ln2332"> </a>
<a name="ln2333"> </a>
<a name="ln2334">extern &quot;C&quot; fssh_status_t</a>
<a name="ln2335">fssh_entry_cache_remove(fssh_dev_t mountID, fssh_ino_t dirID, const char* name)</a>
<a name="ln2336">{</a>
<a name="ln2337">	// We don't implement an entry cache in the FS shell.</a>
<a name="ln2338">	return FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln2339">}</a>
<a name="ln2340"> </a>
<a name="ln2341"> </a>
<a name="ln2342">//	#pragma mark - private VFS API</a>
<a name="ln2343">//	Functions the VFS exports for other parts of the kernel</a>
<a name="ln2344"> </a>
<a name="ln2345"> </a>
<a name="ln2346">/** Acquires another reference to the vnode that has to be released</a>
<a name="ln2347"> *	by calling vfs_put_vnode().</a>
<a name="ln2348"> */</a>
<a name="ln2349"> </a>
<a name="ln2350">void</a>
<a name="ln2351">vfs_acquire_vnode(void *_vnode)</a>
<a name="ln2352">{</a>
<a name="ln2353">	inc_vnode_ref_count((struct vnode *)_vnode);</a>
<a name="ln2354">}</a>
<a name="ln2355"> </a>
<a name="ln2356"> </a>
<a name="ln2357">/** This is currently called from file_cache_create() only.</a>
<a name="ln2358"> *	It's probably a temporary solution as long as devfs requires that</a>
<a name="ln2359"> *	fs_read_pages()/fs_write_pages() are called with the standard</a>
<a name="ln2360"> *	open cookie and not with a device cookie.</a>
<a name="ln2361"> *	If that's done differently, remove this call; it has no other</a>
<a name="ln2362"> *	purpose.</a>
<a name="ln2363"> */</a>
<a name="ln2364"> </a>
<a name="ln2365">fssh_status_t</a>
<a name="ln2366">vfs_get_cookie_from_fd(int fd, void **_cookie)</a>
<a name="ln2367">{</a>
<a name="ln2368">	struct file_descriptor *descriptor;</a>
<a name="ln2369"> </a>
<a name="ln2370">	descriptor = get_fd(get_current_io_context(true), fd);</a>
<a name="ln2371">	if (descriptor == NULL)</a>
<a name="ln2372">		return FSSH_B_FILE_ERROR;</a>
<a name="ln2373"> </a>
<a name="ln2374">	*_cookie = descriptor-&gt;cookie;</a>
<a name="ln2375">	return FSSH_B_OK;</a>
<a name="ln2376">}</a>
<a name="ln2377"> </a>
<a name="ln2378"> </a>
<a name="ln2379">int</a>
<a name="ln2380">vfs_get_vnode_from_fd(int fd, bool kernel, void **vnode)</a>
<a name="ln2381">{</a>
<a name="ln2382">	*vnode = get_vnode_from_fd(fd, kernel);</a>
<a name="ln2383"> </a>
<a name="ln2384">	if (*vnode == NULL)</a>
<a name="ln2385">		return FSSH_B_FILE_ERROR;</a>
<a name="ln2386"> </a>
<a name="ln2387">	return FSSH_B_NO_ERROR;</a>
<a name="ln2388">}</a>
<a name="ln2389"> </a>
<a name="ln2390"> </a>
<a name="ln2391">fssh_status_t</a>
<a name="ln2392">vfs_get_vnode_from_path(const char *path, bool kernel, void **_vnode)</a>
<a name="ln2393">{</a>
<a name="ln2394">	TRACE((&quot;vfs_get_vnode_from_path: entry. path = '%s', kernel %d\n&quot;, path, kernel));</a>
<a name="ln2395"> </a>
<a name="ln2396">	KPath pathBuffer(FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln2397">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln2398">		return FSSH_B_NO_MEMORY;</a>
<a name="ln2399"> </a>
<a name="ln2400">	char *buffer = pathBuffer.LockBuffer();</a>
<a name="ln2401">	fssh_strlcpy(buffer, path, pathBuffer.BufferSize());</a>
<a name="ln2402"> </a>
<a name="ln2403">	struct vnode *vnode;</a>
<a name="ln2404">	fssh_status_t status = path_to_vnode(buffer, true, &amp;vnode, NULL, kernel);</a>
<a name="ln2405">	if (status &lt; FSSH_B_OK)</a>
<a name="ln2406">		return status;</a>
<a name="ln2407"> </a>
<a name="ln2408">	*_vnode = vnode;</a>
<a name="ln2409">	return FSSH_B_OK;</a>
<a name="ln2410">}</a>
<a name="ln2411"> </a>
<a name="ln2412"> </a>
<a name="ln2413">fssh_status_t</a>
<a name="ln2414">vfs_get_vnode(fssh_mount_id mountID, fssh_vnode_id vnodeID, void **_vnode)</a>
<a name="ln2415">{</a>
<a name="ln2416">	struct vnode *vnode;</a>
<a name="ln2417"> </a>
<a name="ln2418">	fssh_status_t status = get_vnode(mountID, vnodeID, &amp;vnode, false);</a>
<a name="ln2419">	if (status &lt; FSSH_B_OK)</a>
<a name="ln2420">		return status;</a>
<a name="ln2421"> </a>
<a name="ln2422">	*_vnode = vnode;</a>
<a name="ln2423">	return FSSH_B_OK;</a>
<a name="ln2424">}</a>
<a name="ln2425"> </a>
<a name="ln2426"> </a>
<a name="ln2427">fssh_status_t</a>
<a name="ln2428">vfs_read_pages(void *_vnode, void *cookie, fssh_off_t pos,</a>
<a name="ln2429">	const fssh_iovec *vecs, fssh_size_t count, fssh_size_t *_numBytes)</a>
<a name="ln2430">{</a>
<a name="ln2431">	struct vnode *vnode = (struct vnode *)_vnode;</a>
<a name="ln2432"> </a>
<a name="ln2433">	return FS_CALL(vnode, read_pages,</a>
<a name="ln2434">		cookie, pos, vecs, count, _numBytes);</a>
<a name="ln2435">}</a>
<a name="ln2436"> </a>
<a name="ln2437"> </a>
<a name="ln2438">fssh_status_t</a>
<a name="ln2439">vfs_write_pages(void *_vnode, void *cookie, fssh_off_t pos,</a>
<a name="ln2440">	const fssh_iovec *vecs, fssh_size_t count, fssh_size_t *_numBytes)</a>
<a name="ln2441">{</a>
<a name="ln2442">	struct vnode *vnode = (struct vnode *)_vnode;</a>
<a name="ln2443"> </a>
<a name="ln2444">	return FS_CALL(vnode, write_pages,</a>
<a name="ln2445">		cookie, pos, vecs, count, _numBytes);</a>
<a name="ln2446">}</a>
<a name="ln2447"> </a>
<a name="ln2448"> </a>
<a name="ln2449">fssh_status_t</a>
<a name="ln2450">vfs_entry_ref_to_vnode(fssh_mount_id mountID, fssh_vnode_id directoryID,</a>
<a name="ln2451">	const char *name, void **_vnode)</a>
<a name="ln2452">{</a>
<a name="ln2453">	return entry_ref_to_vnode(mountID, directoryID, name,</a>
<a name="ln2454">		(struct vnode **)_vnode);</a>
<a name="ln2455">}</a>
<a name="ln2456"> </a>
<a name="ln2457"> </a>
<a name="ln2458">void</a>
<a name="ln2459">vfs_fs_vnode_to_node_ref(void *_vnode, fssh_mount_id *_mountID,</a>
<a name="ln2460">	fssh_vnode_id *_vnodeID)</a>
<a name="ln2461">{</a>
<a name="ln2462">	struct vnode *vnode = (struct vnode *)_vnode;</a>
<a name="ln2463"> </a>
<a name="ln2464">	*_mountID = vnode-&gt;device;</a>
<a name="ln2465">	*_vnodeID = vnode-&gt;id;</a>
<a name="ln2466">}</a>
<a name="ln2467"> </a>
<a name="ln2468"> </a>
<a name="ln2469">/**	Looks up a vnode with the given mount and vnode ID.</a>
<a name="ln2470"> *	Must only be used with &quot;in-use&quot; vnodes as it doesn't grab a reference</a>
<a name="ln2471"> *	to the node.</a>
<a name="ln2472"> *	It's currently only be used by file_cache_create().</a>
<a name="ln2473"> */</a>
<a name="ln2474"> </a>
<a name="ln2475">fssh_status_t</a>
<a name="ln2476">vfs_lookup_vnode(fssh_mount_id mountID, fssh_vnode_id vnodeID,</a>
<a name="ln2477">	struct vnode **_vnode)</a>
<a name="ln2478">{</a>
<a name="ln2479">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln2480">	struct vnode *vnode = lookup_vnode(mountID, vnodeID);</a>
<a name="ln2481">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln2482"> </a>
<a name="ln2483">	if (vnode == NULL)</a>
<a name="ln2484">		return FSSH_B_ERROR;</a>
<a name="ln2485"> </a>
<a name="ln2486">	*_vnode = vnode;</a>
<a name="ln2487">	return FSSH_B_OK;</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490"> </a>
<a name="ln2491">fssh_status_t</a>
<a name="ln2492">vfs_get_fs_node_from_path(fssh_fs_volume *volume, const char *path,</a>
<a name="ln2493">	bool kernel, void **_node)</a>
<a name="ln2494">{</a>
<a name="ln2495">	TRACE((&quot;vfs_get_fs_node_from_path(volume = %p (%ld), path = \&quot;%s\&quot;, &quot;</a>
<a name="ln2496">		&quot;kernel %d)\n&quot;, volume, volume-&gt;id, path, kernel));</a>
<a name="ln2497"> </a>
<a name="ln2498">	KPath pathBuffer(FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln2499">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln2500">		return FSSH_B_NO_MEMORY;</a>
<a name="ln2501"> </a>
<a name="ln2502">	fs_mount *mount;</a>
<a name="ln2503">	fssh_status_t status = get_mount(volume-&gt;id, &amp;mount);</a>
<a name="ln2504">	if (status &lt; FSSH_B_OK)</a>
<a name="ln2505">		return status;</a>
<a name="ln2506"> </a>
<a name="ln2507">	char *buffer = pathBuffer.LockBuffer();</a>
<a name="ln2508">	fssh_strlcpy(buffer, path, pathBuffer.BufferSize());</a>
<a name="ln2509"> </a>
<a name="ln2510">	struct vnode *vnode = mount-&gt;root_vnode;</a>
<a name="ln2511"> </a>
<a name="ln2512">	if (buffer[0] == '/')</a>
<a name="ln2513">		status = path_to_vnode(buffer, true, &amp;vnode, NULL, true);</a>
<a name="ln2514">	else {</a>
<a name="ln2515">		inc_vnode_ref_count(vnode);</a>
<a name="ln2516">			// vnode_path_to_vnode() releases a reference to the starting vnode</a>
<a name="ln2517">		status = vnode_path_to_vnode(vnode, buffer, true, 0, &amp;vnode, NULL);</a>
<a name="ln2518">	}</a>
<a name="ln2519"> </a>
<a name="ln2520">	put_mount(mount);</a>
<a name="ln2521"> </a>
<a name="ln2522">	if (status &lt; FSSH_B_OK)</a>
<a name="ln2523">		return status;</a>
<a name="ln2524"> </a>
<a name="ln2525">	if (vnode-&gt;device != volume-&gt;id) {</a>
<a name="ln2526">		// wrong mount ID - must not gain access on foreign file system nodes</a>
<a name="ln2527">		put_vnode(vnode);</a>
<a name="ln2528">		return FSSH_B_BAD_VALUE;</a>
<a name="ln2529">	}</a>
<a name="ln2530"> </a>
<a name="ln2531">	// Use get_vnode() to resolve the cookie for the right layer.</a>
<a name="ln2532">	status = ::fssh_get_vnode(volume, vnode-&gt;id, _node);</a>
<a name="ln2533">	put_vnode(vnode);</a>
<a name="ln2534"> </a>
<a name="ln2535">	return FSSH_B_OK;</a>
<a name="ln2536">}</a>
<a name="ln2537"> </a>
<a name="ln2538"> </a>
<a name="ln2539">/**	Finds the full path to the file that contains the module \a moduleName,</a>
<a name="ln2540"> *	puts it into \a pathBuffer, and returns FSSH_B_OK for success.</a>
<a name="ln2541"> *	If \a pathBuffer was too small, it returns \c FSSH_B_BUFFER_OVERFLOW,</a>
<a name="ln2542"> *	\c FSSH_B_ENTRY_NOT_FOUNT if no file could be found.</a>
<a name="ln2543"> *	\a pathBuffer is clobbered in any case and must not be relied on if this</a>
<a name="ln2544"> *	functions returns unsuccessfully.</a>
<a name="ln2545"> */</a>
<a name="ln2546"> </a>
<a name="ln2547">fssh_status_t</a>
<a name="ln2548">vfs_get_module_path(const char *basePath, const char *moduleName, char *pathBuffer,</a>
<a name="ln2549">	fssh_size_t bufferSize)</a>
<a name="ln2550">{</a>
<a name="ln2551">	struct vnode *dir, *file;</a>
<a name="ln2552">	fssh_status_t status;</a>
<a name="ln2553">	fssh_size_t length;</a>
<a name="ln2554">	char *path;</a>
<a name="ln2555"> </a>
<a name="ln2556">	if (bufferSize == 0 || fssh_strlcpy(pathBuffer, basePath, bufferSize) &gt;= bufferSize)</a>
<a name="ln2557">		return FSSH_B_BUFFER_OVERFLOW;</a>
<a name="ln2558"> </a>
<a name="ln2559">	status = path_to_vnode(pathBuffer, true, &amp;dir, NULL, true);</a>
<a name="ln2560">	if (status &lt; FSSH_B_OK)</a>
<a name="ln2561">		return status;</a>
<a name="ln2562"> </a>
<a name="ln2563">	// the path buffer had been clobbered by the above call</a>
<a name="ln2564">	length = fssh_strlcpy(pathBuffer, basePath, bufferSize);</a>
<a name="ln2565">	if (pathBuffer[length - 1] != '/')</a>
<a name="ln2566">		pathBuffer[length++] = '/';</a>
<a name="ln2567"> </a>
<a name="ln2568">	path = pathBuffer + length;</a>
<a name="ln2569">	bufferSize -= length;</a>
<a name="ln2570"> </a>
<a name="ln2571">	while (moduleName) {</a>
<a name="ln2572">		char *nextPath = fssh_strchr(moduleName, '/');</a>
<a name="ln2573">		if (nextPath == NULL)</a>
<a name="ln2574">			length = fssh_strlen(moduleName);</a>
<a name="ln2575">		else {</a>
<a name="ln2576">			length = nextPath - moduleName;</a>
<a name="ln2577">			nextPath++;</a>
<a name="ln2578">		}</a>
<a name="ln2579"> </a>
<a name="ln2580">		if (length + 1 &gt;= bufferSize) {</a>
<a name="ln2581">			status = FSSH_B_BUFFER_OVERFLOW;</a>
<a name="ln2582">			goto err;</a>
<a name="ln2583">		}</a>
<a name="ln2584"> </a>
<a name="ln2585">		fssh_memcpy(path, moduleName, length);</a>
<a name="ln2586">		path[length] = '\0';</a>
<a name="ln2587">		moduleName = nextPath;</a>
<a name="ln2588"> </a>
<a name="ln2589">		status = vnode_path_to_vnode(dir, path, true, 0, &amp;file, NULL);</a>
<a name="ln2590">		if (status &lt; FSSH_B_OK) {</a>
<a name="ln2591">			// vnode_path_to_vnode() has already released the reference to dir</a>
<a name="ln2592">			return status;</a>
<a name="ln2593">		}</a>
<a name="ln2594"> </a>
<a name="ln2595">		if (FSSH_S_ISDIR(file-&gt;type)) {</a>
<a name="ln2596">			// goto the next directory</a>
<a name="ln2597">			path[length] = '/';</a>
<a name="ln2598">			path[length + 1] = '\0';</a>
<a name="ln2599">			path += length + 1;</a>
<a name="ln2600">			bufferSize -= length + 1;</a>
<a name="ln2601"> </a>
<a name="ln2602">			dir = file;</a>
<a name="ln2603">		} else if (FSSH_S_ISREG(file-&gt;type)) {</a>
<a name="ln2604">			// it's a file so it should be what we've searched for</a>
<a name="ln2605">			put_vnode(file);</a>
<a name="ln2606"> </a>
<a name="ln2607">			return FSSH_B_OK;</a>
<a name="ln2608">		} else {</a>
<a name="ln2609">			TRACE((&quot;vfs_get_module_path(): something is strange here: %d...\n&quot;, file-&gt;type));</a>
<a name="ln2610">			status = FSSH_B_ERROR;</a>
<a name="ln2611">			dir = file;</a>
<a name="ln2612">			goto err;</a>
<a name="ln2613">		}</a>
<a name="ln2614">	}</a>
<a name="ln2615"> </a>
<a name="ln2616">	// if we got here, the moduleName just pointed to a directory, not to</a>
<a name="ln2617">	// a real module - what should we do in this case?</a>
<a name="ln2618">	status = FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln2619"> </a>
<a name="ln2620">err:</a>
<a name="ln2621">	put_vnode(dir);</a>
<a name="ln2622">	return status;</a>
<a name="ln2623">}</a>
<a name="ln2624"> </a>
<a name="ln2625"> </a>
<a name="ln2626">/**	\brief Normalizes a given path.</a>
<a name="ln2627"> *</a>
<a name="ln2628"> *	The path must refer to an existing or non-existing entry in an existing</a>
<a name="ln2629"> *	directory, that is chopping off the leaf component the remaining path must</a>
<a name="ln2630"> *	refer to an existing directory.</a>
<a name="ln2631"> *</a>
<a name="ln2632"> *	The returned will be canonical in that it will be absolute, will not</a>
<a name="ln2633"> *	contain any &quot;.&quot; or &quot;..&quot; components or duplicate occurrences of '/'s,</a>
<a name="ln2634"> *	and none of the directory components will by symbolic links.</a>
<a name="ln2635"> *</a>
<a name="ln2636"> *	Any two paths referring to the same entry, will result in the same</a>
<a name="ln2637"> *	normalized path (well, that is pretty much the definition of `normalized',</a>
<a name="ln2638"> *	isn't it :-).</a>
<a name="ln2639"> *</a>
<a name="ln2640"> *	\param path The path to be normalized.</a>
<a name="ln2641"> *	\param buffer The buffer into which the normalized path will be written.</a>
<a name="ln2642"> *	\param bufferSize The size of \a buffer.</a>
<a name="ln2643"> *	\param kernel \c true, if the IO context of the kernel shall be used,</a>
<a name="ln2644"> *		   otherwise that of the team this thread belongs to. Only relevant,</a>
<a name="ln2645"> *		   if the path is relative (to get the CWD).</a>
<a name="ln2646"> *	\return \c FSSH_B_OK if everything went fine, another error code otherwise.</a>
<a name="ln2647"> */</a>
<a name="ln2648"> </a>
<a name="ln2649">fssh_status_t</a>
<a name="ln2650">vfs_normalize_path(const char *path, char *buffer, fssh_size_t bufferSize,</a>
<a name="ln2651">	bool kernel)</a>
<a name="ln2652">{</a>
<a name="ln2653">	if (!path || !buffer || bufferSize &lt; 1)</a>
<a name="ln2654">		return FSSH_B_BAD_VALUE;</a>
<a name="ln2655"> </a>
<a name="ln2656">	TRACE((&quot;vfs_normalize_path(`%s')\n&quot;, path));</a>
<a name="ln2657"> </a>
<a name="ln2658">	// copy the supplied path to the stack, so it can be modified</a>
<a name="ln2659">	KPath mutablePathBuffer(FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln2660">	if (mutablePathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln2661">		return FSSH_B_NO_MEMORY;</a>
<a name="ln2662"> </a>
<a name="ln2663">	char *mutablePath = mutablePathBuffer.LockBuffer();</a>
<a name="ln2664">	if (fssh_strlcpy(mutablePath, path, FSSH_B_PATH_NAME_LENGTH) &gt;= FSSH_B_PATH_NAME_LENGTH)</a>
<a name="ln2665">		return FSSH_B_NAME_TOO_LONG;</a>
<a name="ln2666"> </a>
<a name="ln2667">	// get the dir vnode and the leaf name</a>
<a name="ln2668">	struct vnode *dirNode;</a>
<a name="ln2669">	char leaf[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln2670">	fssh_status_t error = path_to_dir_vnode(mutablePath, &amp;dirNode, leaf, kernel);</a>
<a name="ln2671">	if (error != FSSH_B_OK) {</a>
<a name="ln2672">		TRACE((&quot;vfs_normalize_path(): failed to get dir vnode: %s\n&quot;, strerror(error)));</a>
<a name="ln2673">		return error;</a>
<a name="ln2674">	}</a>
<a name="ln2675"> </a>
<a name="ln2676">	// if the leaf is &quot;.&quot; or &quot;..&quot;, we directly get the correct directory</a>
<a name="ln2677">	// vnode and ignore the leaf later</a>
<a name="ln2678">	bool isDir = (fssh_strcmp(leaf, &quot;.&quot;) == 0 || fssh_strcmp(leaf, &quot;..&quot;) == 0);</a>
<a name="ln2679">	if (isDir)</a>
<a name="ln2680">		error = vnode_path_to_vnode(dirNode, leaf, false, 0, &amp;dirNode, NULL);</a>
<a name="ln2681">	if (error != FSSH_B_OK) {</a>
<a name="ln2682">		TRACE((&quot;vfs_normalize_path(): failed to get dir vnode for \&quot;.\&quot; or \&quot;..\&quot;: %s\n&quot;,</a>
<a name="ln2683">			strerror(error)));</a>
<a name="ln2684">		return error;</a>
<a name="ln2685">	}</a>
<a name="ln2686"> </a>
<a name="ln2687">	// get the directory path</a>
<a name="ln2688">	error = dir_vnode_to_path(dirNode, buffer, bufferSize);</a>
<a name="ln2689">	put_vnode(dirNode);</a>
<a name="ln2690">	if (error &lt; FSSH_B_OK) {</a>
<a name="ln2691">		TRACE((&quot;vfs_normalize_path(): failed to get dir path: %s\n&quot;, strerror(error)));</a>
<a name="ln2692">		return error;</a>
<a name="ln2693">	}</a>
<a name="ln2694"> </a>
<a name="ln2695">	// append the leaf name</a>
<a name="ln2696">	if (!isDir) {</a>
<a name="ln2697">		// insert a directory separator only if this is not the file system root</a>
<a name="ln2698">		if ((fssh_strcmp(buffer, &quot;/&quot;) != 0</a>
<a name="ln2699">			 &amp;&amp; fssh_strlcat(buffer, &quot;/&quot;, bufferSize) &gt;= bufferSize)</a>
<a name="ln2700">			|| fssh_strlcat(buffer, leaf, bufferSize) &gt;= bufferSize) {</a>
<a name="ln2701">			return FSSH_B_NAME_TOO_LONG;</a>
<a name="ln2702">		}</a>
<a name="ln2703">	}</a>
<a name="ln2704"> </a>
<a name="ln2705">	TRACE((&quot;vfs_normalize_path() -&gt; `%s'\n&quot;, buffer));</a>
<a name="ln2706">	return FSSH_B_OK;</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709"> </a>
<a name="ln2710">void</a>
<a name="ln2711">vfs_put_vnode(void *_vnode)</a>
<a name="ln2712">{</a>
<a name="ln2713">	put_vnode((struct vnode *)_vnode);</a>
<a name="ln2714">}</a>
<a name="ln2715"> </a>
<a name="ln2716"> </a>
<a name="ln2717">fssh_status_t</a>
<a name="ln2718">vfs_get_cwd(fssh_mount_id *_mountID, fssh_vnode_id *_vnodeID)</a>
<a name="ln2719">{</a>
<a name="ln2720">	// Get current working directory from io context</a>
<a name="ln2721">	struct io_context *context = get_current_io_context(false);</a>
<a name="ln2722">	fssh_status_t status = FSSH_B_OK;</a>
<a name="ln2723"> </a>
<a name="ln2724">	fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln2725"> </a>
<a name="ln2726">	if (context-&gt;cwd != NULL) {</a>
<a name="ln2727">		*_mountID = context-&gt;cwd-&gt;device;</a>
<a name="ln2728">		*_vnodeID = context-&gt;cwd-&gt;id;</a>
<a name="ln2729">	} else</a>
<a name="ln2730">		status = FSSH_B_ERROR;</a>
<a name="ln2731"> </a>
<a name="ln2732">	fssh_mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln2733">	return status;</a>
<a name="ln2734">}</a>
<a name="ln2735"> </a>
<a name="ln2736"> </a>
<a name="ln2737">fssh_status_t</a>
<a name="ln2738">vfs_get_file_map(void *_vnode, fssh_off_t offset, fssh_size_t size,</a>
<a name="ln2739">	fssh_file_io_vec *vecs, fssh_size_t *_count)</a>
<a name="ln2740">{</a>
<a name="ln2741">	struct vnode *vnode = (struct vnode *)_vnode;</a>
<a name="ln2742"> </a>
<a name="ln2743">	FUNCTION((&quot;vfs_get_file_map: vnode %p, vecs %p, offset %lld, size = %u\n&quot;, vnode, vecs, offset, (unsigned)size));</a>
<a name="ln2744"> </a>
<a name="ln2745">	return FS_CALL(vnode, get_file_map, offset, size, vecs, _count);</a>
<a name="ln2746">}</a>
<a name="ln2747"> </a>
<a name="ln2748"> </a>
<a name="ln2749">fssh_status_t</a>
<a name="ln2750">vfs_stat_vnode(void *_vnode, struct fssh_stat *stat)</a>
<a name="ln2751">{</a>
<a name="ln2752">	struct vnode *vnode = (struct vnode *)_vnode;</a>
<a name="ln2753"> </a>
<a name="ln2754">	fssh_status_t status = FS_CALL(vnode, read_stat, stat);</a>
<a name="ln2755"> </a>
<a name="ln2756">	// fill in the st_dev and st_ino fields</a>
<a name="ln2757">	if (status == FSSH_B_OK) {</a>
<a name="ln2758">		stat-&gt;fssh_st_dev = vnode-&gt;device;</a>
<a name="ln2759">		stat-&gt;fssh_st_ino = vnode-&gt;id;</a>
<a name="ln2760">	}</a>
<a name="ln2761"> </a>
<a name="ln2762">	return status;</a>
<a name="ln2763">}</a>
<a name="ln2764"> </a>
<a name="ln2765"> </a>
<a name="ln2766">fssh_status_t</a>
<a name="ln2767">vfs_get_vnode_name(void *_vnode, char *name, fssh_size_t nameSize)</a>
<a name="ln2768">{</a>
<a name="ln2769">	return get_vnode_name((struct vnode *)_vnode, NULL, name, nameSize);</a>
<a name="ln2770">}</a>
<a name="ln2771"> </a>
<a name="ln2772"> </a>
<a name="ln2773">fssh_status_t</a>
<a name="ln2774">vfs_entry_ref_to_path(fssh_dev_t device, fssh_ino_t inode, const char *leaf,</a>
<a name="ln2775">	bool kernel, char *path, fssh_size_t pathLength)</a>
<a name="ln2776">{</a>
<a name="ln2777">	struct vnode *vnode;</a>
<a name="ln2778">	fssh_status_t status;</a>
<a name="ln2779"> </a>
<a name="ln2780">	// filter invalid leaf names</a>
<a name="ln2781">	if (leaf != NULL &amp;&amp; (leaf[0] == '\0' || fssh_strchr(leaf, '/')))</a>
<a name="ln2782">		return FSSH_B_BAD_VALUE;</a>
<a name="ln2783"> </a>
<a name="ln2784">	// get the vnode matching the dir's node_ref</a>
<a name="ln2785">	if (leaf &amp;&amp; (fssh_strcmp(leaf, &quot;.&quot;) == 0 || fssh_strcmp(leaf, &quot;..&quot;) == 0)) {</a>
<a name="ln2786">		// special cases &quot;.&quot; and &quot;..&quot;: we can directly get the vnode of the</a>
<a name="ln2787">		// referenced directory</a>
<a name="ln2788">		status = entry_ref_to_vnode(device, inode, leaf, &amp;vnode);</a>
<a name="ln2789">		leaf = NULL;</a>
<a name="ln2790">	} else</a>
<a name="ln2791">		status = get_vnode(device, inode, &amp;vnode, false);</a>
<a name="ln2792">	if (status &lt; FSSH_B_OK)</a>
<a name="ln2793">		return status;</a>
<a name="ln2794"> </a>
<a name="ln2795">	// get the directory path</a>
<a name="ln2796">	status = dir_vnode_to_path(vnode, path, pathLength);</a>
<a name="ln2797">	put_vnode(vnode);</a>
<a name="ln2798">		// we don't need the vnode anymore</a>
<a name="ln2799">	if (status &lt; FSSH_B_OK)</a>
<a name="ln2800">		return status;</a>
<a name="ln2801"> </a>
<a name="ln2802">	// append the leaf name</a>
<a name="ln2803">	if (leaf) {</a>
<a name="ln2804">		// insert a directory separator if this is not the file system root</a>
<a name="ln2805">		if ((fssh_strcmp(path, &quot;/&quot;) &amp;&amp; fssh_strlcat(path, &quot;/&quot;, pathLength)</a>
<a name="ln2806">				&gt;= pathLength)</a>
<a name="ln2807">			|| fssh_strlcat(path, leaf, pathLength) &gt;= pathLength) {</a>
<a name="ln2808">			return FSSH_B_NAME_TOO_LONG;</a>
<a name="ln2809">		}</a>
<a name="ln2810">	}</a>
<a name="ln2811"> </a>
<a name="ln2812">	return FSSH_B_OK;</a>
<a name="ln2813">}</a>
<a name="ln2814"> </a>
<a name="ln2815"> </a>
<a name="ln2816">/**	If the given descriptor locked its vnode, that lock will be released.</a>
<a name="ln2817"> */</a>
<a name="ln2818"> </a>
<a name="ln2819">void</a>
<a name="ln2820">vfs_unlock_vnode_if_locked(struct file_descriptor *descriptor)</a>
<a name="ln2821">{</a>
<a name="ln2822">	struct vnode *vnode = fd_vnode(descriptor);</a>
<a name="ln2823"> </a>
<a name="ln2824">	if (vnode != NULL &amp;&amp; vnode-&gt;mandatory_locked_by == descriptor)</a>
<a name="ln2825">		vnode-&gt;mandatory_locked_by = NULL;</a>
<a name="ln2826">}</a>
<a name="ln2827"> </a>
<a name="ln2828"> </a>
<a name="ln2829">/**	Closes all file descriptors of the specified I/O context that</a>
<a name="ln2830"> *	don't have the FSSH_O_CLOEXEC flag set.</a>
<a name="ln2831"> */</a>
<a name="ln2832"> </a>
<a name="ln2833">void</a>
<a name="ln2834">vfs_exec_io_context(void *_context)</a>
<a name="ln2835">{</a>
<a name="ln2836">	struct io_context *context = (struct io_context *)_context;</a>
<a name="ln2837">	uint32_t i;</a>
<a name="ln2838"> </a>
<a name="ln2839">	for (i = 0; i &lt; context-&gt;table_size; i++) {</a>
<a name="ln2840">		fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln2841"> </a>
<a name="ln2842">		struct file_descriptor *descriptor = context-&gt;fds[i];</a>
<a name="ln2843">		bool remove = false;</a>
<a name="ln2844"> </a>
<a name="ln2845">		if (descriptor != NULL &amp;&amp; fd_close_on_exec(context, i)) {</a>
<a name="ln2846">			context-&gt;fds[i] = NULL;</a>
<a name="ln2847">			context-&gt;num_used_fds--;</a>
<a name="ln2848"> </a>
<a name="ln2849">			remove = true;</a>
<a name="ln2850">		}</a>
<a name="ln2851"> </a>
<a name="ln2852">		fssh_mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln2853"> </a>
<a name="ln2854">		if (remove) {</a>
<a name="ln2855">			close_fd(descriptor);</a>
<a name="ln2856">			put_fd(descriptor);</a>
<a name="ln2857">		}</a>
<a name="ln2858">	}</a>
<a name="ln2859">}</a>
<a name="ln2860"> </a>
<a name="ln2861"> </a>
<a name="ln2862">/** Sets up a new io_control structure, and inherits the properties</a>
<a name="ln2863"> *	of the parent io_control if it is given.</a>
<a name="ln2864"> */</a>
<a name="ln2865"> </a>
<a name="ln2866">void *</a>
<a name="ln2867">vfs_new_io_context(void *_parentContext)</a>
<a name="ln2868">{</a>
<a name="ln2869">	fssh_size_t tableSize;</a>
<a name="ln2870">	struct io_context *context;</a>
<a name="ln2871">	struct io_context *parentContext;</a>
<a name="ln2872"> </a>
<a name="ln2873">	context = (io_context *)malloc(sizeof(struct io_context));</a>
<a name="ln2874">	if (context == NULL)</a>
<a name="ln2875">		return NULL;</a>
<a name="ln2876"> </a>
<a name="ln2877">	fssh_memset(context, 0, sizeof(struct io_context));</a>
<a name="ln2878"> </a>
<a name="ln2879">	parentContext = (struct io_context *)_parentContext;</a>
<a name="ln2880">	if (parentContext)</a>
<a name="ln2881">		tableSize = parentContext-&gt;table_size;</a>
<a name="ln2882">	else</a>
<a name="ln2883">		tableSize = DEFAULT_FD_TABLE_SIZE;</a>
<a name="ln2884"> </a>
<a name="ln2885">	// allocate space for FDs and their close-on-exec flag</a>
<a name="ln2886">	context-&gt;fds = (file_descriptor **)malloc(sizeof(struct file_descriptor *) * tableSize</a>
<a name="ln2887">		+ (tableSize + 7) / 8);</a>
<a name="ln2888">	if (context-&gt;fds == NULL) {</a>
<a name="ln2889">		free(context);</a>
<a name="ln2890">		return NULL;</a>
<a name="ln2891">	}</a>
<a name="ln2892"> </a>
<a name="ln2893">	fssh_memset(context-&gt;fds, 0, sizeof(struct file_descriptor *) * tableSize</a>
<a name="ln2894">		+ (tableSize + 7) / 8);</a>
<a name="ln2895">	context-&gt;fds_close_on_exec = (uint8_t *)(context-&gt;fds + tableSize);</a>
<a name="ln2896"> </a>
<a name="ln2897">	fssh_mutex_init(&amp;context-&gt;io_mutex, &quot;I/O context&quot;);</a>
<a name="ln2898"> </a>
<a name="ln2899">	// Copy all parent files which don't have the FSSH_O_CLOEXEC flag set</a>
<a name="ln2900"> </a>
<a name="ln2901">	if (parentContext) {</a>
<a name="ln2902">		fssh_size_t i;</a>
<a name="ln2903"> </a>
<a name="ln2904">		fssh_mutex_lock(&amp;parentContext-&gt;io_mutex);</a>
<a name="ln2905"> </a>
<a name="ln2906">		context-&gt;cwd = parentContext-&gt;cwd;</a>
<a name="ln2907">		if (context-&gt;cwd)</a>
<a name="ln2908">			inc_vnode_ref_count(context-&gt;cwd);</a>
<a name="ln2909"> </a>
<a name="ln2910">		for (i = 0; i &lt; tableSize; i++) {</a>
<a name="ln2911">			struct file_descriptor *descriptor = parentContext-&gt;fds[i];</a>
<a name="ln2912"> </a>
<a name="ln2913">			if (descriptor != NULL &amp;&amp; !fd_close_on_exec(parentContext, i)) {</a>
<a name="ln2914">				context-&gt;fds[i] = descriptor;</a>
<a name="ln2915">				context-&gt;num_used_fds++;</a>
<a name="ln2916">				fssh_atomic_add(&amp;descriptor-&gt;ref_count, 1);</a>
<a name="ln2917">				fssh_atomic_add(&amp;descriptor-&gt;open_count, 1);</a>
<a name="ln2918">			}</a>
<a name="ln2919">		}</a>
<a name="ln2920"> </a>
<a name="ln2921">		fssh_mutex_unlock(&amp;parentContext-&gt;io_mutex);</a>
<a name="ln2922">	} else {</a>
<a name="ln2923">		context-&gt;cwd = sRoot;</a>
<a name="ln2924"> </a>
<a name="ln2925">		if (context-&gt;cwd)</a>
<a name="ln2926">			inc_vnode_ref_count(context-&gt;cwd);</a>
<a name="ln2927">	}</a>
<a name="ln2928"> </a>
<a name="ln2929">	context-&gt;table_size = tableSize;</a>
<a name="ln2930"> </a>
<a name="ln2931">	return context;</a>
<a name="ln2932">}</a>
<a name="ln2933"> </a>
<a name="ln2934"> </a>
<a name="ln2935">fssh_status_t</a>
<a name="ln2936">vfs_free_io_context(void *_ioContext)</a>
<a name="ln2937">{</a>
<a name="ln2938">	struct io_context *context = (struct io_context *)_ioContext;</a>
<a name="ln2939">	uint32_t i;</a>
<a name="ln2940"> </a>
<a name="ln2941">	if (context-&gt;cwd)</a>
<a name="ln2942">		dec_vnode_ref_count(context-&gt;cwd, false);</a>
<a name="ln2943"> </a>
<a name="ln2944">	fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln2945"> </a>
<a name="ln2946">	for (i = 0; i &lt; context-&gt;table_size; i++) {</a>
<a name="ln2947">		if (struct file_descriptor *descriptor = context-&gt;fds[i]) {</a>
<a name="ln2948">			close_fd(descriptor);</a>
<a name="ln2949">			put_fd(descriptor);</a>
<a name="ln2950">		}</a>
<a name="ln2951">	}</a>
<a name="ln2952"> </a>
<a name="ln2953">	fssh_mutex_destroy(&amp;context-&gt;io_mutex);</a>
<a name="ln2954"> </a>
<a name="ln2955">	free(context-&gt;fds);</a>
<a name="ln2956">	free(context);</a>
<a name="ln2957"> </a>
<a name="ln2958">	return FSSH_B_OK;</a>
<a name="ln2959">}</a>
<a name="ln2960"> </a>
<a name="ln2961"> </a>
<a name="ln2962">fssh_status_t</a>
<a name="ln2963">vfs_init(kernel_args *args)</a>
<a name="ln2964">{</a>
<a name="ln2965">	sVnodeTable = hash_init(VNODE_HASH_TABLE_SIZE, fssh_offsetof(struct vnode, next),</a>
<a name="ln2966">		&amp;vnode_compare, &amp;vnode_hash);</a>
<a name="ln2967">	if (sVnodeTable == NULL)</a>
<a name="ln2968">		fssh_panic(&quot;vfs_init: error creating vnode hash table\n&quot;);</a>
<a name="ln2969"> </a>
<a name="ln2970">	list_init_etc(&amp;sUnusedVnodeList, fssh_offsetof(struct vnode, unused_link));</a>
<a name="ln2971"> </a>
<a name="ln2972">	sMountsTable = hash_init(MOUNTS_HASH_TABLE_SIZE, fssh_offsetof(struct fs_mount, next),</a>
<a name="ln2973">		&amp;mount_compare, &amp;mount_hash);</a>
<a name="ln2974">	if (sMountsTable == NULL)</a>
<a name="ln2975">		fssh_panic(&quot;vfs_init: error creating mounts hash table\n&quot;);</a>
<a name="ln2976"> </a>
<a name="ln2977">	sRoot = NULL;</a>
<a name="ln2978"> </a>
<a name="ln2979">	fssh_mutex_init(&amp;sFileSystemsMutex, &quot;vfs_lock&quot;);</a>
<a name="ln2980">	fssh_recursive_lock_init(&amp;sMountOpLock, &quot;vfs_mount_op_lock&quot;);</a>
<a name="ln2981">	fssh_mutex_init(&amp;sMountMutex, &quot;vfs_mount_lock&quot;);</a>
<a name="ln2982">	fssh_mutex_init(&amp;sVnodeCoveredByMutex, &quot;vfs_vnode_covered_by_lock&quot;);</a>
<a name="ln2983">	fssh_mutex_init(&amp;sVnodeMutex, &quot;vfs_vnode_lock&quot;);</a>
<a name="ln2984"> </a>
<a name="ln2985">	if (block_cache_init() != FSSH_B_OK)</a>
<a name="ln2986">		return FSSH_B_ERROR;</a>
<a name="ln2987"> </a>
<a name="ln2988">	return file_cache_init();</a>
<a name="ln2989">}</a>
<a name="ln2990"> </a>
<a name="ln2991"> </a>
<a name="ln2992">//	#pragma mark -</a>
<a name="ln2993">//	The filetype-dependent implementations (fd_ops + open/create/rename/remove, ...)</a>
<a name="ln2994"> </a>
<a name="ln2995"> </a>
<a name="ln2996">/** Calls fs_open() on the given vnode and returns a new</a>
<a name="ln2997"> *	file descriptor for it</a>
<a name="ln2998"> */</a>
<a name="ln2999"> </a>
<a name="ln3000">static int</a>
<a name="ln3001">create_vnode(struct vnode *directory, const char *name, int openMode, int perms, bool kernel)</a>
<a name="ln3002">{</a>
<a name="ln3003">	struct vnode *vnode;</a>
<a name="ln3004">	void *cookie;</a>
<a name="ln3005">	fssh_vnode_id newID;</a>
<a name="ln3006">	int status;</a>
<a name="ln3007"> </a>
<a name="ln3008">	if (!HAS_FS_CALL(directory, create))</a>
<a name="ln3009">		return FSSH_EROFS;</a>
<a name="ln3010"> </a>
<a name="ln3011">	status = FS_CALL(directory, create, name, openMode, perms, &amp;cookie, &amp;newID);</a>
<a name="ln3012">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3013">		return status;</a>
<a name="ln3014"> </a>
<a name="ln3015">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln3016">	vnode = lookup_vnode(directory-&gt;device, newID);</a>
<a name="ln3017">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln3018"> </a>
<a name="ln3019">	if (vnode == NULL) {</a>
<a name="ln3020">		fssh_dprintf(&quot;vfs: fs_create() returned success but there is no vnode!&quot;);</a>
<a name="ln3021">		return FSSH_EINVAL;</a>
<a name="ln3022">	}</a>
<a name="ln3023"> </a>
<a name="ln3024">	if ((status = get_new_fd(FDTYPE_FILE, NULL, vnode, cookie, openMode, kernel)) &gt;= 0)</a>
<a name="ln3025">		return status;</a>
<a name="ln3026"> </a>
<a name="ln3027">	// something went wrong, clean up</a>
<a name="ln3028"> </a>
<a name="ln3029">	FS_CALL(vnode, close, cookie);</a>
<a name="ln3030">	FS_CALL(vnode, free_cookie, cookie);</a>
<a name="ln3031">	put_vnode(vnode);</a>
<a name="ln3032"> </a>
<a name="ln3033">	FS_CALL(directory, unlink, name);</a>
<a name="ln3034"> </a>
<a name="ln3035">	return status;</a>
<a name="ln3036">}</a>
<a name="ln3037"> </a>
<a name="ln3038"> </a>
<a name="ln3039">/** Calls fs_open() on the given vnode and returns a new</a>
<a name="ln3040"> *	file descriptor for it</a>
<a name="ln3041"> */</a>
<a name="ln3042"> </a>
<a name="ln3043">static int</a>
<a name="ln3044">open_vnode(struct vnode *vnode, int openMode, bool kernel)</a>
<a name="ln3045">{</a>
<a name="ln3046">	void *cookie;</a>
<a name="ln3047">	int status;</a>
<a name="ln3048"> </a>
<a name="ln3049">	status = FS_CALL(vnode, open, openMode, &amp;cookie);</a>
<a name="ln3050">	if (status &lt; 0)</a>
<a name="ln3051">		return status;</a>
<a name="ln3052"> </a>
<a name="ln3053">	status = get_new_fd(FDTYPE_FILE, NULL, vnode, cookie, openMode, kernel);</a>
<a name="ln3054">	if (status &lt; 0) {</a>
<a name="ln3055">		FS_CALL(vnode, close, cookie);</a>
<a name="ln3056">		FS_CALL(vnode, free_cookie, cookie);</a>
<a name="ln3057">	}</a>
<a name="ln3058">	return status;</a>
<a name="ln3059">}</a>
<a name="ln3060"> </a>
<a name="ln3061"> </a>
<a name="ln3062">/** Calls fs open_dir() on the given vnode and returns a new</a>
<a name="ln3063"> *	file descriptor for it</a>
<a name="ln3064"> */</a>
<a name="ln3065"> </a>
<a name="ln3066">static int</a>
<a name="ln3067">open_dir_vnode(struct vnode *vnode, bool kernel)</a>
<a name="ln3068">{</a>
<a name="ln3069">	void *cookie;</a>
<a name="ln3070">	int status;</a>
<a name="ln3071"> </a>
<a name="ln3072">	status = FS_CALL(vnode, open_dir, &amp;cookie);</a>
<a name="ln3073">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3074">		return status;</a>
<a name="ln3075"> </a>
<a name="ln3076">	// file is opened, create a fd</a>
<a name="ln3077">	status = get_new_fd(FDTYPE_DIR, NULL, vnode, cookie, 0, kernel);</a>
<a name="ln3078">	if (status &gt;= 0)</a>
<a name="ln3079">		return status;</a>
<a name="ln3080"> </a>
<a name="ln3081">	FS_CALL(vnode, close_dir, cookie);</a>
<a name="ln3082">	FS_CALL(vnode, free_dir_cookie, cookie);</a>
<a name="ln3083"> </a>
<a name="ln3084">	return status;</a>
<a name="ln3085">}</a>
<a name="ln3086"> </a>
<a name="ln3087"> </a>
<a name="ln3088">/** Calls fs open_attr_dir() on the given vnode and returns a new</a>
<a name="ln3089"> *	file descriptor for it.</a>
<a name="ln3090"> *	Used by attr_dir_open(), and attr_dir_open_fd().</a>
<a name="ln3091"> */</a>
<a name="ln3092"> </a>
<a name="ln3093">static int</a>
<a name="ln3094">open_attr_dir_vnode(struct vnode *vnode, bool kernel)</a>
<a name="ln3095">{</a>
<a name="ln3096">	void *cookie;</a>
<a name="ln3097">	int status;</a>
<a name="ln3098"> </a>
<a name="ln3099">	if (!HAS_FS_CALL(vnode, open_attr_dir))</a>
<a name="ln3100">		return FSSH_EOPNOTSUPP;</a>
<a name="ln3101"> </a>
<a name="ln3102">	status = FS_CALL(vnode, open_attr_dir, &amp;cookie);</a>
<a name="ln3103">	if (status &lt; 0)</a>
<a name="ln3104">		return status;</a>
<a name="ln3105"> </a>
<a name="ln3106">	// file is opened, create a fd</a>
<a name="ln3107">	status = get_new_fd(FDTYPE_ATTR_DIR, NULL, vnode, cookie, 0, kernel);</a>
<a name="ln3108">	if (status &gt;= 0)</a>
<a name="ln3109">		return status;</a>
<a name="ln3110"> </a>
<a name="ln3111">	FS_CALL(vnode, close_attr_dir, cookie);</a>
<a name="ln3112">	FS_CALL(vnode, free_attr_dir_cookie, cookie);</a>
<a name="ln3113"> </a>
<a name="ln3114">	return status;</a>
<a name="ln3115">}</a>
<a name="ln3116"> </a>
<a name="ln3117"> </a>
<a name="ln3118">static int</a>
<a name="ln3119">file_create_entry_ref(fssh_mount_id mountID, fssh_vnode_id directoryID, const char *name, int openMode, int perms, bool kernel)</a>
<a name="ln3120">{</a>
<a name="ln3121">	struct vnode *directory;</a>
<a name="ln3122">	int status;</a>
<a name="ln3123"> </a>
<a name="ln3124">	FUNCTION((&quot;file_create_entry_ref: name = '%s', omode %x, perms %d, kernel %d\n&quot;, name, openMode, perms, kernel));</a>
<a name="ln3125"> </a>
<a name="ln3126">	// get directory to put the new file in</a>
<a name="ln3127">	status = get_vnode(mountID, directoryID, &amp;directory, false);</a>
<a name="ln3128">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3129">		return status;</a>
<a name="ln3130"> </a>
<a name="ln3131">	status = create_vnode(directory, name, openMode, perms, kernel);</a>
<a name="ln3132">	put_vnode(directory);</a>
<a name="ln3133"> </a>
<a name="ln3134">	return status;</a>
<a name="ln3135">}</a>
<a name="ln3136"> </a>
<a name="ln3137"> </a>
<a name="ln3138">static int</a>
<a name="ln3139">file_create(int fd, char *path, int openMode, int perms, bool kernel)</a>
<a name="ln3140">{</a>
<a name="ln3141">	char name[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln3142">	struct vnode *directory;</a>
<a name="ln3143">	int status;</a>
<a name="ln3144"> </a>
<a name="ln3145">	FUNCTION((&quot;file_create: path '%s', omode %x, perms %d, kernel %d\n&quot;, path, openMode, perms, kernel));</a>
<a name="ln3146"> </a>
<a name="ln3147">	// get directory to put the new file in</a>
<a name="ln3148">	status = fd_and_path_to_dir_vnode(fd, path, &amp;directory, name, kernel);</a>
<a name="ln3149">	if (status &lt; 0)</a>
<a name="ln3150">		return status;</a>
<a name="ln3151"> </a>
<a name="ln3152">	status = create_vnode(directory, name, openMode, perms, kernel);</a>
<a name="ln3153"> </a>
<a name="ln3154">	put_vnode(directory);</a>
<a name="ln3155">	return status;</a>
<a name="ln3156">}</a>
<a name="ln3157"> </a>
<a name="ln3158"> </a>
<a name="ln3159">static int</a>
<a name="ln3160">file_open_entry_ref(fssh_mount_id mountID, fssh_vnode_id directoryID, const char *name, int openMode, bool kernel)</a>
<a name="ln3161">{</a>
<a name="ln3162">	struct vnode *vnode;</a>
<a name="ln3163">	int status;</a>
<a name="ln3164"> </a>
<a name="ln3165">	if (name == NULL || *name == '\0')</a>
<a name="ln3166">		return FSSH_B_BAD_VALUE;</a>
<a name="ln3167"> </a>
<a name="ln3168">	FUNCTION((&quot;file_open_entry_ref(ref = (%ld, %Ld, %s), openMode = %d)\n&quot;,</a>
<a name="ln3169">		mountID, directoryID, name, openMode));</a>
<a name="ln3170"> </a>
<a name="ln3171">	// get the vnode matching the entry_ref</a>
<a name="ln3172">	status = entry_ref_to_vnode(mountID, directoryID, name, &amp;vnode);</a>
<a name="ln3173">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3174">		return status;</a>
<a name="ln3175"> </a>
<a name="ln3176">	status = open_vnode(vnode, openMode, kernel);</a>
<a name="ln3177">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3178">		put_vnode(vnode);</a>
<a name="ln3179"> </a>
<a name="ln3180">	return status;</a>
<a name="ln3181">}</a>
<a name="ln3182"> </a>
<a name="ln3183"> </a>
<a name="ln3184">static int</a>
<a name="ln3185">file_open(int fd, char *path, int openMode, bool kernel)</a>
<a name="ln3186">{</a>
<a name="ln3187">	int status = FSSH_B_OK;</a>
<a name="ln3188">	bool traverse = ((openMode &amp; FSSH_O_NOTRAVERSE) == 0);</a>
<a name="ln3189"> </a>
<a name="ln3190">	FUNCTION((&quot;file_open: fd: %d, entry path = '%s', omode %d, kernel %d\n&quot;,</a>
<a name="ln3191">		fd, path, openMode, kernel));</a>
<a name="ln3192"> </a>
<a name="ln3193">	// get the vnode matching the vnode + path combination</a>
<a name="ln3194">	struct vnode *vnode = NULL;</a>
<a name="ln3195">	fssh_vnode_id parentID;</a>
<a name="ln3196">	status = fd_and_path_to_vnode(fd, path, traverse, &amp;vnode, &amp;parentID, kernel);</a>
<a name="ln3197">	if (status != FSSH_B_OK)</a>
<a name="ln3198">		return status;</a>
<a name="ln3199"> </a>
<a name="ln3200">	// open the vnode</a>
<a name="ln3201">	status = open_vnode(vnode, openMode, kernel);</a>
<a name="ln3202">	// put only on error -- otherwise our reference was transferred to the FD</a>
<a name="ln3203">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3204">		put_vnode(vnode);</a>
<a name="ln3205"> </a>
<a name="ln3206">	return status;</a>
<a name="ln3207">}</a>
<a name="ln3208"> </a>
<a name="ln3209"> </a>
<a name="ln3210">static fssh_status_t</a>
<a name="ln3211">file_close(struct file_descriptor *descriptor)</a>
<a name="ln3212">{</a>
<a name="ln3213">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3214">	fssh_status_t status = FSSH_B_OK;</a>
<a name="ln3215"> </a>
<a name="ln3216">	FUNCTION((&quot;file_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln3217"> </a>
<a name="ln3218">	if (HAS_FS_CALL(vnode, close))</a>
<a name="ln3219">		status = FS_CALL(vnode, close, descriptor-&gt;cookie);</a>
<a name="ln3220"> </a>
<a name="ln3221">	return status;</a>
<a name="ln3222">}</a>
<a name="ln3223"> </a>
<a name="ln3224"> </a>
<a name="ln3225">static void</a>
<a name="ln3226">file_free_fd(struct file_descriptor *descriptor)</a>
<a name="ln3227">{</a>
<a name="ln3228">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3229"> </a>
<a name="ln3230">	if (vnode != NULL) {</a>
<a name="ln3231">		FS_CALL(vnode, free_cookie, descriptor-&gt;cookie);</a>
<a name="ln3232">		put_vnode(vnode);</a>
<a name="ln3233">	}</a>
<a name="ln3234">}</a>
<a name="ln3235"> </a>
<a name="ln3236"> </a>
<a name="ln3237">static fssh_status_t</a>
<a name="ln3238">file_read(struct file_descriptor *descriptor, fssh_off_t pos, void *buffer, fssh_size_t *length)</a>
<a name="ln3239">{</a>
<a name="ln3240">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3241"> </a>
<a name="ln3242">	FUNCTION((&quot;file_read: buf %p, pos %Ld, len %p = %ld\n&quot;, buffer, pos, length, *length));</a>
<a name="ln3243">	return FS_CALL(vnode, read, descriptor-&gt;cookie, pos, buffer, length);</a>
<a name="ln3244">}</a>
<a name="ln3245"> </a>
<a name="ln3246"> </a>
<a name="ln3247">static fssh_status_t</a>
<a name="ln3248">file_write(struct file_descriptor *descriptor, fssh_off_t pos, const void *buffer, fssh_size_t *length)</a>
<a name="ln3249">{</a>
<a name="ln3250">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3251"> </a>
<a name="ln3252">	FUNCTION((&quot;file_write: buf %p, pos %Ld, len %p\n&quot;, buffer, pos, length));</a>
<a name="ln3253">	return FS_CALL(vnode, write, descriptor-&gt;cookie, pos, buffer, length);</a>
<a name="ln3254">}</a>
<a name="ln3255"> </a>
<a name="ln3256"> </a>
<a name="ln3257">static fssh_off_t</a>
<a name="ln3258">file_seek(struct file_descriptor *descriptor, fssh_off_t pos, int seekType)</a>
<a name="ln3259">{</a>
<a name="ln3260">	fssh_off_t offset;</a>
<a name="ln3261"> </a>
<a name="ln3262">	FUNCTION((&quot;file_seek(pos = %Ld, seekType = %d)\n&quot;, pos, seekType));</a>
<a name="ln3263">	// ToDo: seek should fail for pipes and FIFOs...</a>
<a name="ln3264"> </a>
<a name="ln3265">	switch (seekType) {</a>
<a name="ln3266">		case FSSH_SEEK_SET:</a>
<a name="ln3267">			offset = 0;</a>
<a name="ln3268">			break;</a>
<a name="ln3269">		case FSSH_SEEK_CUR:</a>
<a name="ln3270">			offset = descriptor-&gt;pos;</a>
<a name="ln3271">			break;</a>
<a name="ln3272">		case FSSH_SEEK_END:</a>
<a name="ln3273">		{</a>
<a name="ln3274">			struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3275">			struct fssh_stat stat;</a>
<a name="ln3276">			fssh_status_t status;</a>
<a name="ln3277"> </a>
<a name="ln3278">			if (!HAS_FS_CALL(vnode, read_stat))</a>
<a name="ln3279">				return FSSH_EOPNOTSUPP;</a>
<a name="ln3280"> </a>
<a name="ln3281">			status = FS_CALL(vnode, read_stat, &amp;stat);</a>
<a name="ln3282">			if (status &lt; FSSH_B_OK)</a>
<a name="ln3283">				return status;</a>
<a name="ln3284"> </a>
<a name="ln3285">			offset = stat.fssh_st_size;</a>
<a name="ln3286">			break;</a>
<a name="ln3287">		}</a>
<a name="ln3288">		default:</a>
<a name="ln3289">			return FSSH_B_BAD_VALUE;</a>
<a name="ln3290">	}</a>
<a name="ln3291"> </a>
<a name="ln3292">	// assumes fssh_off_t is 64 bits wide</a>
<a name="ln3293">	if (offset &gt; 0 &amp;&amp; LLONG_MAX - offset &lt; pos)</a>
<a name="ln3294">		return FSSH_EOVERFLOW;</a>
<a name="ln3295"> </a>
<a name="ln3296">	pos += offset;</a>
<a name="ln3297">	if (pos &lt; 0)</a>
<a name="ln3298">		return FSSH_B_BAD_VALUE;</a>
<a name="ln3299"> </a>
<a name="ln3300">	return descriptor-&gt;pos = pos;</a>
<a name="ln3301">}</a>
<a name="ln3302"> </a>
<a name="ln3303"> </a>
<a name="ln3304">static fssh_status_t</a>
<a name="ln3305">dir_create_entry_ref(fssh_mount_id mountID, fssh_vnode_id parentID, const char *name, int perms, bool kernel)</a>
<a name="ln3306">{</a>
<a name="ln3307">	struct vnode *vnode;</a>
<a name="ln3308">	fssh_status_t status;</a>
<a name="ln3309"> </a>
<a name="ln3310">	if (name == NULL || *name == '\0')</a>
<a name="ln3311">		return FSSH_B_BAD_VALUE;</a>
<a name="ln3312"> </a>
<a name="ln3313">	FUNCTION((&quot;dir_create_entry_ref(dev = %ld, ino = %Ld, name = '%s', perms = %d)\n&quot;, mountID, parentID, name, perms));</a>
<a name="ln3314"> </a>
<a name="ln3315">	status = get_vnode(mountID, parentID, &amp;vnode, kernel);</a>
<a name="ln3316">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3317">		return status;</a>
<a name="ln3318"> </a>
<a name="ln3319">	if (HAS_FS_CALL(vnode, create_dir))</a>
<a name="ln3320">		status = FS_CALL(vnode, create_dir, name, perms);</a>
<a name="ln3321">	else</a>
<a name="ln3322">		status = FSSH_EROFS;</a>
<a name="ln3323"> </a>
<a name="ln3324">	put_vnode(vnode);</a>
<a name="ln3325">	return status;</a>
<a name="ln3326">}</a>
<a name="ln3327"> </a>
<a name="ln3328"> </a>
<a name="ln3329">static fssh_status_t</a>
<a name="ln3330">dir_create(int fd, char *path, int perms, bool kernel)</a>
<a name="ln3331">{</a>
<a name="ln3332">	char filename[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln3333">	struct vnode *vnode;</a>
<a name="ln3334">	fssh_status_t status;</a>
<a name="ln3335"> </a>
<a name="ln3336">	FUNCTION((&quot;dir_create: path '%s', perms %d, kernel %d\n&quot;, path, perms, kernel));</a>
<a name="ln3337"> </a>
<a name="ln3338">	status = fd_and_path_to_dir_vnode(fd, path, &amp;vnode, filename, kernel);</a>
<a name="ln3339">	if (status &lt; 0)</a>
<a name="ln3340">		return status;</a>
<a name="ln3341"> </a>
<a name="ln3342">	if (HAS_FS_CALL(vnode, create_dir))</a>
<a name="ln3343">		status = FS_CALL(vnode, create_dir, filename, perms);</a>
<a name="ln3344">	else</a>
<a name="ln3345">		status = FSSH_EROFS;</a>
<a name="ln3346"> </a>
<a name="ln3347">	put_vnode(vnode);</a>
<a name="ln3348">	return status;</a>
<a name="ln3349">}</a>
<a name="ln3350"> </a>
<a name="ln3351"> </a>
<a name="ln3352">static int</a>
<a name="ln3353">dir_open_entry_ref(fssh_mount_id mountID, fssh_vnode_id parentID, const char *name, bool kernel)</a>
<a name="ln3354">{</a>
<a name="ln3355">	struct vnode *vnode;</a>
<a name="ln3356">	int status;</a>
<a name="ln3357"> </a>
<a name="ln3358">	FUNCTION((&quot;dir_open_entry_ref()\n&quot;));</a>
<a name="ln3359"> </a>
<a name="ln3360">	if (name &amp;&amp; *name == '\0')</a>
<a name="ln3361">		return FSSH_B_BAD_VALUE;</a>
<a name="ln3362"> </a>
<a name="ln3363">	// get the vnode matching the entry_ref/node_ref</a>
<a name="ln3364">	if (name)</a>
<a name="ln3365">		status = entry_ref_to_vnode(mountID, parentID, name, &amp;vnode);</a>
<a name="ln3366">	else</a>
<a name="ln3367">		status = get_vnode(mountID, parentID, &amp;vnode, false);</a>
<a name="ln3368">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3369">		return status;</a>
<a name="ln3370"> </a>
<a name="ln3371">	status = open_dir_vnode(vnode, kernel);</a>
<a name="ln3372">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3373">		put_vnode(vnode);</a>
<a name="ln3374"> </a>
<a name="ln3375">	return status;</a>
<a name="ln3376">}</a>
<a name="ln3377"> </a>
<a name="ln3378"> </a>
<a name="ln3379">static int</a>
<a name="ln3380">dir_open(int fd, char *path, bool kernel)</a>
<a name="ln3381">{</a>
<a name="ln3382">	int status = FSSH_B_OK;</a>
<a name="ln3383"> </a>
<a name="ln3384">	FUNCTION((&quot;dir_open: fd: %d, entry path = '%s', kernel %d\n&quot;, fd, path, kernel));</a>
<a name="ln3385"> </a>
<a name="ln3386">	// get the vnode matching the vnode + path combination</a>
<a name="ln3387">	struct vnode *vnode = NULL;</a>
<a name="ln3388">	fssh_vnode_id parentID;</a>
<a name="ln3389">	status = fd_and_path_to_vnode(fd, path, true, &amp;vnode, &amp;parentID, kernel);</a>
<a name="ln3390">	if (status != FSSH_B_OK)</a>
<a name="ln3391">		return status;</a>
<a name="ln3392"> </a>
<a name="ln3393">	// open the dir</a>
<a name="ln3394">	status = open_dir_vnode(vnode, kernel);</a>
<a name="ln3395">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3396">		put_vnode(vnode);</a>
<a name="ln3397"> </a>
<a name="ln3398">	return status;</a>
<a name="ln3399">}</a>
<a name="ln3400"> </a>
<a name="ln3401"> </a>
<a name="ln3402">static fssh_status_t</a>
<a name="ln3403">dir_close(struct file_descriptor *descriptor)</a>
<a name="ln3404">{</a>
<a name="ln3405">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3406"> </a>
<a name="ln3407">	FUNCTION((&quot;dir_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln3408"> </a>
<a name="ln3409">	if (HAS_FS_CALL(vnode, close_dir))</a>
<a name="ln3410">		return FS_CALL(vnode, close_dir, descriptor-&gt;cookie);</a>
<a name="ln3411"> </a>
<a name="ln3412">	return FSSH_B_OK;</a>
<a name="ln3413">}</a>
<a name="ln3414"> </a>
<a name="ln3415"> </a>
<a name="ln3416">static void</a>
<a name="ln3417">dir_free_fd(struct file_descriptor *descriptor)</a>
<a name="ln3418">{</a>
<a name="ln3419">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3420"> </a>
<a name="ln3421">	if (vnode != NULL) {</a>
<a name="ln3422">		FS_CALL(vnode, free_dir_cookie, descriptor-&gt;cookie);</a>
<a name="ln3423">		put_vnode(vnode);</a>
<a name="ln3424">	}</a>
<a name="ln3425">}</a>
<a name="ln3426"> </a>
<a name="ln3427"> </a>
<a name="ln3428">static fssh_status_t</a>
<a name="ln3429">dir_read(struct file_descriptor *descriptor, struct fssh_dirent *buffer,</a>
<a name="ln3430">	fssh_size_t bufferSize, uint32_t *_count)</a>
<a name="ln3431">{</a>
<a name="ln3432">	return dir_read(descriptor-&gt;u.vnode, descriptor-&gt;cookie, buffer, bufferSize, _count);</a>
<a name="ln3433">}</a>
<a name="ln3434"> </a>
<a name="ln3435"> </a>
<a name="ln3436">static void</a>
<a name="ln3437">fix_dirent(struct vnode *parent, struct fssh_dirent *entry)</a>
<a name="ln3438">{</a>
<a name="ln3439">	// set d_pdev and d_pino</a>
<a name="ln3440">	entry-&gt;d_pdev = parent-&gt;device;</a>
<a name="ln3441">	entry-&gt;d_pino = parent-&gt;id;</a>
<a name="ln3442"> </a>
<a name="ln3443">	// If this is the &quot;..&quot; entry and the directory is the root of a FS,</a>
<a name="ln3444">	// we need to replace d_dev and d_ino with the actual values.</a>
<a name="ln3445">	if (fssh_strcmp(entry-&gt;d_name, &quot;..&quot;) == 0</a>
<a name="ln3446">		&amp;&amp; parent-&gt;mount-&gt;root_vnode == parent</a>
<a name="ln3447">		&amp;&amp; parent-&gt;mount-&gt;covers_vnode) {</a>
<a name="ln3448">		inc_vnode_ref_count(parent);</a>
<a name="ln3449">			// vnode_path_to_vnode() puts the node</a>
<a name="ln3450"> </a>
<a name="ln3451">		// &quot;..&quot; is guaranteed to to be clobbered by this call</a>
<a name="ln3452">		struct vnode *vnode;</a>
<a name="ln3453">		fssh_status_t status = vnode_path_to_vnode(parent, (char*)&quot;..&quot;, false,</a>
<a name="ln3454">			0, &amp;vnode, NULL);</a>
<a name="ln3455"> </a>
<a name="ln3456">		if (status == FSSH_B_OK) {</a>
<a name="ln3457">			entry-&gt;d_dev = vnode-&gt;device;</a>
<a name="ln3458">			entry-&gt;d_ino = vnode-&gt;id;</a>
<a name="ln3459">		}</a>
<a name="ln3460">	} else {</a>
<a name="ln3461">		// resolve mount points</a>
<a name="ln3462">		struct vnode *vnode = NULL;</a>
<a name="ln3463">		fssh_status_t status = get_vnode(entry-&gt;d_dev, entry-&gt;d_ino, &amp;vnode, false);</a>
<a name="ln3464">		if (status != FSSH_B_OK)</a>
<a name="ln3465">			return;</a>
<a name="ln3466"> </a>
<a name="ln3467">		fssh_mutex_lock(&amp;sVnodeCoveredByMutex);</a>
<a name="ln3468">		if (vnode-&gt;covered_by) {</a>
<a name="ln3469">			entry-&gt;d_dev = vnode-&gt;covered_by-&gt;device;</a>
<a name="ln3470">			entry-&gt;d_ino = vnode-&gt;covered_by-&gt;id;</a>
<a name="ln3471">		}</a>
<a name="ln3472">		fssh_mutex_unlock(&amp;sVnodeCoveredByMutex);</a>
<a name="ln3473"> </a>
<a name="ln3474">		put_vnode(vnode);</a>
<a name="ln3475">	}</a>
<a name="ln3476">}</a>
<a name="ln3477"> </a>
<a name="ln3478"> </a>
<a name="ln3479">static fssh_status_t</a>
<a name="ln3480">dir_read(struct vnode *vnode, void *cookie, struct fssh_dirent *buffer,</a>
<a name="ln3481">	fssh_size_t bufferSize, uint32_t *_count)</a>
<a name="ln3482">{</a>
<a name="ln3483">	if (!HAS_FS_CALL(vnode, read_dir))</a>
<a name="ln3484">		return FSSH_EOPNOTSUPP;</a>
<a name="ln3485"> </a>
<a name="ln3486">	fssh_status_t error = FS_CALL(vnode, read_dir,cookie,buffer,bufferSize,_count);</a>
<a name="ln3487">	if (error != FSSH_B_OK)</a>
<a name="ln3488">		return error;</a>
<a name="ln3489"> </a>
<a name="ln3490">	// we need to adjust the read dirents</a>
<a name="ln3491">	if (*_count &gt; 0) {</a>
<a name="ln3492">		// XXX: Currently reading only one dirent is supported. Make this a loop!</a>
<a name="ln3493">		fix_dirent(vnode, buffer);</a>
<a name="ln3494">	}</a>
<a name="ln3495"> </a>
<a name="ln3496">	return error;</a>
<a name="ln3497">}</a>
<a name="ln3498"> </a>
<a name="ln3499"> </a>
<a name="ln3500">static fssh_status_t</a>
<a name="ln3501">dir_rewind(struct file_descriptor *descriptor)</a>
<a name="ln3502">{</a>
<a name="ln3503">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3504"> </a>
<a name="ln3505">	if (HAS_FS_CALL(vnode, rewind_dir))</a>
<a name="ln3506">		return FS_CALL(vnode, rewind_dir,descriptor-&gt;cookie);</a>
<a name="ln3507"> </a>
<a name="ln3508">	return FSSH_EOPNOTSUPP;</a>
<a name="ln3509">}</a>
<a name="ln3510"> </a>
<a name="ln3511"> </a>
<a name="ln3512">static fssh_status_t</a>
<a name="ln3513">dir_remove(int fd, char *path, bool kernel)</a>
<a name="ln3514">{</a>
<a name="ln3515">	char name[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln3516">	struct vnode *directory;</a>
<a name="ln3517">	fssh_status_t status;</a>
<a name="ln3518"> </a>
<a name="ln3519">	if (path != NULL) {</a>
<a name="ln3520">		// we need to make sure our path name doesn't stop with &quot;/&quot;, &quot;.&quot;, or &quot;..&quot;</a>
<a name="ln3521">		char *lastSlash = fssh_strrchr(path, '/');</a>
<a name="ln3522">		if (lastSlash != NULL) {</a>
<a name="ln3523">			char *leaf = lastSlash + 1;</a>
<a name="ln3524">			if (!fssh_strcmp(leaf, &quot;..&quot;))</a>
<a name="ln3525">				return FSSH_B_NOT_ALLOWED;</a>
<a name="ln3526"> </a>
<a name="ln3527">			// omit multiple slashes</a>
<a name="ln3528">			while (lastSlash &gt; path &amp;&amp; lastSlash[-1] == '/') {</a>
<a name="ln3529">				lastSlash--;</a>
<a name="ln3530">			}</a>
<a name="ln3531"> </a>
<a name="ln3532">			if (!leaf[0]</a>
<a name="ln3533">				|| !fssh_strcmp(leaf, &quot;.&quot;)) {</a>
<a name="ln3534">				// &quot;name/&quot; -&gt; &quot;name&quot;, or &quot;name/.&quot; -&gt; &quot;name&quot;</a>
<a name="ln3535">				lastSlash[0] = '\0';</a>
<a name="ln3536">			}</a>
<a name="ln3537">		} else if (!fssh_strcmp(path, &quot;..&quot;))</a>
<a name="ln3538">			return FSSH_B_NOT_ALLOWED;</a>
<a name="ln3539">	}</a>
<a name="ln3540"> </a>
<a name="ln3541">	status = fd_and_path_to_dir_vnode(fd, path, &amp;directory, name, kernel);</a>
<a name="ln3542">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3543">		return status;</a>
<a name="ln3544"> </a>
<a name="ln3545">	if (HAS_FS_CALL(directory, remove_dir)) {</a>
<a name="ln3546">		status = FS_CALL(directory, remove_dir, name);</a>
<a name="ln3547">	} else</a>
<a name="ln3548">		status = FSSH_EROFS;</a>
<a name="ln3549"> </a>
<a name="ln3550">	put_vnode(directory);</a>
<a name="ln3551">	return status;</a>
<a name="ln3552">}</a>
<a name="ln3553"> </a>
<a name="ln3554"> </a>
<a name="ln3555">static fssh_status_t</a>
<a name="ln3556">common_ioctl(struct file_descriptor *descriptor, uint32_t op, void *buffer,</a>
<a name="ln3557">	fssh_size_t length)</a>
<a name="ln3558">{</a>
<a name="ln3559">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3560"> </a>
<a name="ln3561">	if (HAS_FS_CALL(vnode, ioctl)) {</a>
<a name="ln3562">		return FS_CALL(vnode, ioctl,</a>
<a name="ln3563">			descriptor-&gt;cookie, op, buffer, length);</a>
<a name="ln3564">	}</a>
<a name="ln3565"> </a>
<a name="ln3566">	return FSSH_EOPNOTSUPP;</a>
<a name="ln3567">}</a>
<a name="ln3568"> </a>
<a name="ln3569"> </a>
<a name="ln3570">static fssh_status_t</a>
<a name="ln3571">common_fcntl(int fd, int op, uint32_t argument, bool kernel)</a>
<a name="ln3572">{</a>
<a name="ln3573">	struct file_descriptor *descriptor;</a>
<a name="ln3574">	struct vnode *vnode;</a>
<a name="ln3575">	fssh_status_t status;</a>
<a name="ln3576"> </a>
<a name="ln3577">	FUNCTION((&quot;common_fcntl(fd = %d, op = %d, argument = %lx, %s)\n&quot;,</a>
<a name="ln3578">		fd, op, argument, kernel ? &quot;kernel&quot; : &quot;user&quot;));</a>
<a name="ln3579"> </a>
<a name="ln3580">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln3581">	if (descriptor == NULL)</a>
<a name="ln3582">		return FSSH_B_FILE_ERROR;</a>
<a name="ln3583"> </a>
<a name="ln3584">	switch (op) {</a>
<a name="ln3585">		case FSSH_F_SETFD:</a>
<a name="ln3586">		{</a>
<a name="ln3587">			struct io_context *context = get_current_io_context(kernel);</a>
<a name="ln3588">			// Set file descriptor flags</a>
<a name="ln3589"> </a>
<a name="ln3590">			// FSSH_O_CLOEXEC is the only flag available at this time</a>
<a name="ln3591">			fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln3592">			fd_set_close_on_exec(context, fd, argument == FSSH_FD_CLOEXEC);</a>
<a name="ln3593">			fssh_mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln3594"> </a>
<a name="ln3595">			status = FSSH_B_OK;</a>
<a name="ln3596">			break;</a>
<a name="ln3597">		}</a>
<a name="ln3598"> </a>
<a name="ln3599">		case FSSH_F_GETFD:</a>
<a name="ln3600">		{</a>
<a name="ln3601">			struct io_context *context = get_current_io_context(kernel);</a>
<a name="ln3602"> </a>
<a name="ln3603">			// Get file descriptor flags</a>
<a name="ln3604">			fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln3605">			status = fd_close_on_exec(context, fd) ? FSSH_FD_CLOEXEC : 0;</a>
<a name="ln3606">			fssh_mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln3607">			break;</a>
<a name="ln3608">		}</a>
<a name="ln3609"> </a>
<a name="ln3610">		case FSSH_F_SETFL:</a>
<a name="ln3611">			// Set file descriptor open mode</a>
<a name="ln3612">			if (HAS_FS_CALL(vnode, set_flags)) {</a>
<a name="ln3613">				// we only accept changes to FSSH_O_APPEND and FSSH_O_NONBLOCK</a>
<a name="ln3614">				argument &amp;= FSSH_O_APPEND | FSSH_O_NONBLOCK;</a>
<a name="ln3615"> </a>
<a name="ln3616">				status = FS_CALL(vnode, set_flags, descriptor-&gt;cookie, (int)argument);</a>
<a name="ln3617">				if (status == FSSH_B_OK) {</a>
<a name="ln3618">					// update this descriptor's open_mode field</a>
<a name="ln3619">					descriptor-&gt;open_mode = (descriptor-&gt;open_mode &amp; ~(FSSH_O_APPEND | FSSH_O_NONBLOCK))</a>
<a name="ln3620">						| argument;</a>
<a name="ln3621">				}</a>
<a name="ln3622">			} else</a>
<a name="ln3623">				status = FSSH_EOPNOTSUPP;</a>
<a name="ln3624">			break;</a>
<a name="ln3625"> </a>
<a name="ln3626">		case FSSH_F_GETFL:</a>
<a name="ln3627">			// Get file descriptor open mode</a>
<a name="ln3628">			status = descriptor-&gt;open_mode;</a>
<a name="ln3629">			break;</a>
<a name="ln3630"> </a>
<a name="ln3631">		case FSSH_F_DUPFD:</a>
<a name="ln3632">		{</a>
<a name="ln3633">			struct io_context *context = get_current_io_context(kernel);</a>
<a name="ln3634"> </a>
<a name="ln3635">			status = new_fd_etc(context, descriptor, (int)argument);</a>
<a name="ln3636">			if (status &gt;= 0) {</a>
<a name="ln3637">				fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln3638">				fd_set_close_on_exec(context, fd, false);</a>
<a name="ln3639">				fssh_mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln3640"> </a>
<a name="ln3641">				fssh_atomic_add(&amp;descriptor-&gt;ref_count, 1);</a>
<a name="ln3642">			}</a>
<a name="ln3643">			break;</a>
<a name="ln3644">		}</a>
<a name="ln3645"> </a>
<a name="ln3646">		case FSSH_F_GETLK:</a>
<a name="ln3647">		case FSSH_F_SETLK:</a>
<a name="ln3648">		case FSSH_F_SETLKW:</a>
<a name="ln3649">			status = FSSH_B_BAD_VALUE;</a>
<a name="ln3650">			break;</a>
<a name="ln3651"> </a>
<a name="ln3652">		// ToDo: add support for more ops?</a>
<a name="ln3653"> </a>
<a name="ln3654">		default:</a>
<a name="ln3655">			status = FSSH_B_BAD_VALUE;</a>
<a name="ln3656">	}</a>
<a name="ln3657"> </a>
<a name="ln3658">	put_fd(descriptor);</a>
<a name="ln3659">	return status;</a>
<a name="ln3660">}</a>
<a name="ln3661"> </a>
<a name="ln3662"> </a>
<a name="ln3663">static fssh_status_t</a>
<a name="ln3664">common_sync(int fd, bool kernel)</a>
<a name="ln3665">{</a>
<a name="ln3666">	struct file_descriptor *descriptor;</a>
<a name="ln3667">	struct vnode *vnode;</a>
<a name="ln3668">	fssh_status_t status;</a>
<a name="ln3669"> </a>
<a name="ln3670">	FUNCTION((&quot;common_fsync: entry. fd %d kernel %d\n&quot;, fd, kernel));</a>
<a name="ln3671"> </a>
<a name="ln3672">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln3673">	if (descriptor == NULL)</a>
<a name="ln3674">		return FSSH_B_FILE_ERROR;</a>
<a name="ln3675"> </a>
<a name="ln3676">	if (HAS_FS_CALL(vnode, fsync))</a>
<a name="ln3677">		status = FS_CALL_NO_PARAMS(vnode, fsync);</a>
<a name="ln3678">	else</a>
<a name="ln3679">		status = FSSH_EOPNOTSUPP;</a>
<a name="ln3680"> </a>
<a name="ln3681">	put_fd(descriptor);</a>
<a name="ln3682">	return status;</a>
<a name="ln3683">}</a>
<a name="ln3684"> </a>
<a name="ln3685"> </a>
<a name="ln3686">static fssh_status_t</a>
<a name="ln3687">common_lock_node(int fd, bool kernel)</a>
<a name="ln3688">{</a>
<a name="ln3689">	struct file_descriptor *descriptor;</a>
<a name="ln3690">	struct vnode *vnode;</a>
<a name="ln3691"> </a>
<a name="ln3692">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln3693">	if (descriptor == NULL)</a>
<a name="ln3694">		return FSSH_B_FILE_ERROR;</a>
<a name="ln3695"> </a>
<a name="ln3696">	fssh_status_t status = FSSH_B_OK;</a>
<a name="ln3697"> </a>
<a name="ln3698">	// We need to set the locking atomically - someone</a>
<a name="ln3699">	// else might set one at the same time</a>
<a name="ln3700">#ifdef __x86_64__</a>
<a name="ln3701">	if (fssh_atomic_test_and_set64((int64_t *)&amp;vnode-&gt;mandatory_locked_by,</a>
<a name="ln3702">			(fssh_addr_t)descriptor, 0) != 0)</a>
<a name="ln3703">#else</a>
<a name="ln3704">	if (fssh_atomic_test_and_set((int32_t *)&amp;vnode-&gt;mandatory_locked_by,</a>
<a name="ln3705">			(fssh_addr_t)descriptor, 0) != 0)</a>
<a name="ln3706">#endif</a>
<a name="ln3707">		status = FSSH_B_BUSY;</a>
<a name="ln3708"> </a>
<a name="ln3709">	put_fd(descriptor);</a>
<a name="ln3710">	return status;</a>
<a name="ln3711">}</a>
<a name="ln3712"> </a>
<a name="ln3713"> </a>
<a name="ln3714">static fssh_status_t</a>
<a name="ln3715">common_unlock_node(int fd, bool kernel)</a>
<a name="ln3716">{</a>
<a name="ln3717">	struct file_descriptor *descriptor;</a>
<a name="ln3718">	struct vnode *vnode;</a>
<a name="ln3719"> </a>
<a name="ln3720">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln3721">	if (descriptor == NULL)</a>
<a name="ln3722">		return FSSH_B_FILE_ERROR;</a>
<a name="ln3723"> </a>
<a name="ln3724">	fssh_status_t status = FSSH_B_OK;</a>
<a name="ln3725"> </a>
<a name="ln3726">	// We need to set the locking atomically - someone</a>
<a name="ln3727">	// else might set one at the same time</a>
<a name="ln3728">#ifdef __x86_64__</a>
<a name="ln3729">	if (fssh_atomic_test_and_set64((int64_t *)&amp;vnode-&gt;mandatory_locked_by,</a>
<a name="ln3730">			0, (fssh_addr_t)descriptor) != (int64_t)descriptor)</a>
<a name="ln3731">#else</a>
<a name="ln3732">	if (fssh_atomic_test_and_set((int32_t *)&amp;vnode-&gt;mandatory_locked_by,</a>
<a name="ln3733">			0, (fssh_addr_t)descriptor) != (int32_t)descriptor)</a>
<a name="ln3734">#endif</a>
<a name="ln3735">		status = FSSH_B_BAD_VALUE;</a>
<a name="ln3736"> </a>
<a name="ln3737">	put_fd(descriptor);</a>
<a name="ln3738">	return status;</a>
<a name="ln3739">}</a>
<a name="ln3740"> </a>
<a name="ln3741"> </a>
<a name="ln3742">static fssh_status_t</a>
<a name="ln3743">common_read_link(int fd, char *path, char *buffer, fssh_size_t *_bufferSize,</a>
<a name="ln3744">	bool kernel)</a>
<a name="ln3745">{</a>
<a name="ln3746">	struct vnode *vnode;</a>
<a name="ln3747">	fssh_status_t status;</a>
<a name="ln3748"> </a>
<a name="ln3749">	status = fd_and_path_to_vnode(fd, path, false, &amp;vnode, NULL, kernel);</a>
<a name="ln3750">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3751">		return status;</a>
<a name="ln3752"> </a>
<a name="ln3753">	if (HAS_FS_CALL(vnode, read_symlink)) {</a>
<a name="ln3754">		status = FS_CALL(vnode, read_symlink, buffer, _bufferSize);</a>
<a name="ln3755">	} else</a>
<a name="ln3756">		status = FSSH_B_BAD_VALUE;</a>
<a name="ln3757"> </a>
<a name="ln3758">	put_vnode(vnode);</a>
<a name="ln3759">	return status;</a>
<a name="ln3760">}</a>
<a name="ln3761"> </a>
<a name="ln3762"> </a>
<a name="ln3763">static fssh_status_t</a>
<a name="ln3764">common_create_symlink(int fd, char *path, const char *toPath, int mode,</a>
<a name="ln3765">	bool kernel)</a>
<a name="ln3766">{</a>
<a name="ln3767">	// path validity checks have to be in the calling function!</a>
<a name="ln3768">	char name[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln3769">	struct vnode *vnode;</a>
<a name="ln3770">	fssh_status_t status;</a>
<a name="ln3771"> </a>
<a name="ln3772">	FUNCTION((&quot;common_create_symlink(fd = %d, path = %s, toPath = %s, mode = %d, kernel = %d)\n&quot;, fd, path, toPath, mode, kernel));</a>
<a name="ln3773"> </a>
<a name="ln3774">	status = fd_and_path_to_dir_vnode(fd, path, &amp;vnode, name, kernel);</a>
<a name="ln3775">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3776">		return status;</a>
<a name="ln3777"> </a>
<a name="ln3778">	if (HAS_FS_CALL(vnode, create_symlink))</a>
<a name="ln3779">		status = FS_CALL(vnode, create_symlink, name, toPath, mode);</a>
<a name="ln3780">	else</a>
<a name="ln3781">		status = FSSH_EROFS;</a>
<a name="ln3782"> </a>
<a name="ln3783">	put_vnode(vnode);</a>
<a name="ln3784"> </a>
<a name="ln3785">	return status;</a>
<a name="ln3786">}</a>
<a name="ln3787"> </a>
<a name="ln3788"> </a>
<a name="ln3789">static fssh_status_t</a>
<a name="ln3790">common_create_link(char *path, char *toPath, bool kernel)</a>
<a name="ln3791">{</a>
<a name="ln3792">	// path validity checks have to be in the calling function!</a>
<a name="ln3793">	char name[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln3794">	struct vnode *directory, *vnode;</a>
<a name="ln3795">	fssh_status_t status;</a>
<a name="ln3796"> </a>
<a name="ln3797">	FUNCTION((&quot;common_create_link(path = %s, toPath = %s, kernel = %d)\n&quot;, path, toPath, kernel));</a>
<a name="ln3798"> </a>
<a name="ln3799">	status = path_to_dir_vnode(path, &amp;directory, name, kernel);</a>
<a name="ln3800">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3801">		return status;</a>
<a name="ln3802"> </a>
<a name="ln3803">	status = path_to_vnode(toPath, true, &amp;vnode, NULL, kernel);</a>
<a name="ln3804">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3805">		goto err;</a>
<a name="ln3806"> </a>
<a name="ln3807">	if (directory-&gt;mount != vnode-&gt;mount) {</a>
<a name="ln3808">		status = FSSH_B_CROSS_DEVICE_LINK;</a>
<a name="ln3809">		goto err1;</a>
<a name="ln3810">	}</a>
<a name="ln3811"> </a>
<a name="ln3812">	if (HAS_FS_CALL(directory, link))</a>
<a name="ln3813">		status = FS_CALL(directory, link, name, vnode);</a>
<a name="ln3814">	else</a>
<a name="ln3815">		status = FSSH_EROFS;</a>
<a name="ln3816"> </a>
<a name="ln3817">err1:</a>
<a name="ln3818">	put_vnode(vnode);</a>
<a name="ln3819">err:</a>
<a name="ln3820">	put_vnode(directory);</a>
<a name="ln3821"> </a>
<a name="ln3822">	return status;</a>
<a name="ln3823">}</a>
<a name="ln3824"> </a>
<a name="ln3825"> </a>
<a name="ln3826">static fssh_status_t</a>
<a name="ln3827">common_unlink(int fd, char *path, bool kernel)</a>
<a name="ln3828">{</a>
<a name="ln3829">	char filename[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln3830">	struct vnode *vnode;</a>
<a name="ln3831">	fssh_status_t status;</a>
<a name="ln3832"> </a>
<a name="ln3833">	FUNCTION((&quot;common_unlink: fd: %d, path '%s', kernel %d\n&quot;, fd, path, kernel));</a>
<a name="ln3834"> </a>
<a name="ln3835">	status = fd_and_path_to_dir_vnode(fd, path, &amp;vnode, filename, kernel);</a>
<a name="ln3836">	if (status &lt; 0)</a>
<a name="ln3837">		return status;</a>
<a name="ln3838"> </a>
<a name="ln3839">	if (HAS_FS_CALL(vnode, unlink))</a>
<a name="ln3840">		status = FS_CALL(vnode, unlink, filename);</a>
<a name="ln3841">	else</a>
<a name="ln3842">		status = FSSH_EROFS;</a>
<a name="ln3843"> </a>
<a name="ln3844">	put_vnode(vnode);</a>
<a name="ln3845"> </a>
<a name="ln3846">	return status;</a>
<a name="ln3847">}</a>
<a name="ln3848"> </a>
<a name="ln3849"> </a>
<a name="ln3850">static fssh_status_t</a>
<a name="ln3851">common_access(char *path, int mode, bool kernel)</a>
<a name="ln3852">{</a>
<a name="ln3853">	struct vnode *vnode;</a>
<a name="ln3854">	fssh_status_t status;</a>
<a name="ln3855"> </a>
<a name="ln3856">	status = path_to_vnode(path, true, &amp;vnode, NULL, kernel);</a>
<a name="ln3857">	if (status &lt; FSSH_B_OK)</a>
<a name="ln3858">		return status;</a>
<a name="ln3859"> </a>
<a name="ln3860">	if (HAS_FS_CALL(vnode, access))</a>
<a name="ln3861">		status = FS_CALL(vnode, access, mode);</a>
<a name="ln3862">	else</a>
<a name="ln3863">		status = FSSH_B_OK;</a>
<a name="ln3864"> </a>
<a name="ln3865">	put_vnode(vnode);</a>
<a name="ln3866"> </a>
<a name="ln3867">	return status;</a>
<a name="ln3868">}</a>
<a name="ln3869"> </a>
<a name="ln3870"> </a>
<a name="ln3871">static fssh_status_t</a>
<a name="ln3872">common_rename(int fd, char *path, int newFD, char *newPath, bool kernel)</a>
<a name="ln3873">{</a>
<a name="ln3874">	struct vnode *fromVnode, *toVnode;</a>
<a name="ln3875">	char fromName[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln3876">	char toName[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln3877">	fssh_status_t status;</a>
<a name="ln3878"> </a>
<a name="ln3879">	FUNCTION((&quot;common_rename(fd = %d, path = %s, newFD = %d, newPath = %s, kernel = %d)\n&quot;, fd, path, newFD, newPath, kernel));</a>
<a name="ln3880"> </a>
<a name="ln3881">	status = fd_and_path_to_dir_vnode(fd, path, &amp;fromVnode, fromName, kernel);</a>
<a name="ln3882">	if (status &lt; 0)</a>
<a name="ln3883">		return status;</a>
<a name="ln3884"> </a>
<a name="ln3885">	status = fd_and_path_to_dir_vnode(newFD, newPath, &amp;toVnode, toName, kernel);</a>
<a name="ln3886">	if (status &lt; 0)</a>
<a name="ln3887">		goto err;</a>
<a name="ln3888"> </a>
<a name="ln3889">	if (fromVnode-&gt;device != toVnode-&gt;device) {</a>
<a name="ln3890">		status = FSSH_B_CROSS_DEVICE_LINK;</a>
<a name="ln3891">		goto err1;</a>
<a name="ln3892">	}</a>
<a name="ln3893"> </a>
<a name="ln3894">	if (HAS_FS_CALL(fromVnode, rename))</a>
<a name="ln3895">		status = FS_CALL(fromVnode, rename, fromName, toVnode, toName);</a>
<a name="ln3896">	else</a>
<a name="ln3897">		status = FSSH_EROFS;</a>
<a name="ln3898"> </a>
<a name="ln3899">err1:</a>
<a name="ln3900">	put_vnode(toVnode);</a>
<a name="ln3901">err:</a>
<a name="ln3902">	put_vnode(fromVnode);</a>
<a name="ln3903"> </a>
<a name="ln3904">	return status;</a>
<a name="ln3905">}</a>
<a name="ln3906"> </a>
<a name="ln3907"> </a>
<a name="ln3908">static fssh_status_t</a>
<a name="ln3909">common_read_stat(struct file_descriptor *descriptor, struct fssh_stat *stat)</a>
<a name="ln3910">{</a>
<a name="ln3911">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3912"> </a>
<a name="ln3913">	FUNCTION((&quot;common_read_stat: stat %p\n&quot;, stat));</a>
<a name="ln3914"> </a>
<a name="ln3915">	stat-&gt;fssh_st_atim.tv_nsec = 0;</a>
<a name="ln3916">	stat-&gt;fssh_st_mtim.tv_nsec = 0;</a>
<a name="ln3917">	stat-&gt;fssh_st_ctim.tv_nsec = 0;</a>
<a name="ln3918">	stat-&gt;fssh_st_crtim.tv_nsec = 0;</a>
<a name="ln3919"> </a>
<a name="ln3920">	fssh_status_t status = FS_CALL(vnode, read_stat, stat);</a>
<a name="ln3921"> </a>
<a name="ln3922">	// fill in the st_dev and st_ino fields</a>
<a name="ln3923">	if (status == FSSH_B_OK) {</a>
<a name="ln3924">		stat-&gt;fssh_st_dev = vnode-&gt;device;</a>
<a name="ln3925">		stat-&gt;fssh_st_ino = vnode-&gt;id;</a>
<a name="ln3926">	}</a>
<a name="ln3927"> </a>
<a name="ln3928">	return status;</a>
<a name="ln3929">}</a>
<a name="ln3930"> </a>
<a name="ln3931"> </a>
<a name="ln3932">static fssh_status_t</a>
<a name="ln3933">common_write_stat(struct file_descriptor *descriptor,</a>
<a name="ln3934">	const struct fssh_stat *stat, int statMask)</a>
<a name="ln3935">{</a>
<a name="ln3936">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln3937"> </a>
<a name="ln3938">	FUNCTION((&quot;common_write_stat(vnode = %p, stat = %p, statMask = %d)\n&quot;, vnode, stat, statMask));</a>
<a name="ln3939">	if (!HAS_FS_CALL(vnode, write_stat))</a>
<a name="ln3940">		return FSSH_EROFS;</a>
<a name="ln3941"> </a>
<a name="ln3942">	return FS_CALL(vnode, write_stat, stat, statMask);</a>
<a name="ln3943">}</a>
<a name="ln3944"> </a>
<a name="ln3945"> </a>
<a name="ln3946">static fssh_status_t</a>
<a name="ln3947">common_path_read_stat(int fd, char *path, bool traverseLeafLink,</a>
<a name="ln3948">	struct fssh_stat *stat, bool kernel)</a>
<a name="ln3949">{</a>
<a name="ln3950">	struct vnode *vnode;</a>
<a name="ln3951">	fssh_status_t status;</a>
<a name="ln3952"> </a>
<a name="ln3953">	FUNCTION((&quot;common_path_read_stat: fd: %d, path '%s', stat %p,\n&quot;, fd, path, stat));</a>
<a name="ln3954"> </a>
<a name="ln3955">	status = fd_and_path_to_vnode(fd, path, traverseLeafLink, &amp;vnode, NULL, kernel);</a>
<a name="ln3956">	if (status &lt; 0)</a>
<a name="ln3957">		return status;</a>
<a name="ln3958"> </a>
<a name="ln3959">	status = FS_CALL(vnode, read_stat, stat);</a>
<a name="ln3960"> </a>
<a name="ln3961">	// fill in the st_dev and st_ino fields</a>
<a name="ln3962">	if (status == FSSH_B_OK) {</a>
<a name="ln3963">		stat-&gt;fssh_st_dev = vnode-&gt;device;</a>
<a name="ln3964">		stat-&gt;fssh_st_ino = vnode-&gt;id;</a>
<a name="ln3965">	}</a>
<a name="ln3966"> </a>
<a name="ln3967">	put_vnode(vnode);</a>
<a name="ln3968">	return status;</a>
<a name="ln3969">}</a>
<a name="ln3970"> </a>
<a name="ln3971"> </a>
<a name="ln3972">static fssh_status_t</a>
<a name="ln3973">common_path_write_stat(int fd, char *path, bool traverseLeafLink,</a>
<a name="ln3974">	const struct fssh_stat *stat, int statMask, bool kernel)</a>
<a name="ln3975">{</a>
<a name="ln3976">	struct vnode *vnode;</a>
<a name="ln3977">	fssh_status_t status;</a>
<a name="ln3978"> </a>
<a name="ln3979">	FUNCTION((&quot;common_write_stat: fd: %d, path '%s', stat %p, stat_mask %d, kernel %d\n&quot;, fd, path, stat, statMask, kernel));</a>
<a name="ln3980"> </a>
<a name="ln3981">	status = fd_and_path_to_vnode(fd, path, traverseLeafLink, &amp;vnode, NULL, kernel);</a>
<a name="ln3982">	if (status &lt; 0)</a>
<a name="ln3983">		return status;</a>
<a name="ln3984"> </a>
<a name="ln3985">	if (HAS_FS_CALL(vnode, write_stat))</a>
<a name="ln3986">		status = FS_CALL(vnode, write_stat, stat, statMask);</a>
<a name="ln3987">	else</a>
<a name="ln3988">		status = FSSH_EROFS;</a>
<a name="ln3989"> </a>
<a name="ln3990">	put_vnode(vnode);</a>
<a name="ln3991"> </a>
<a name="ln3992">	return status;</a>
<a name="ln3993">}</a>
<a name="ln3994"> </a>
<a name="ln3995"> </a>
<a name="ln3996">static int</a>
<a name="ln3997">attr_dir_open(int fd, char *path, bool kernel)</a>
<a name="ln3998">{</a>
<a name="ln3999">	struct vnode *vnode;</a>
<a name="ln4000">	int status;</a>
<a name="ln4001"> </a>
<a name="ln4002">	FUNCTION((&quot;attr_dir_open(fd = %d, path = '%s', kernel = %d)\n&quot;, fd, path, kernel));</a>
<a name="ln4003"> </a>
<a name="ln4004">	status = fd_and_path_to_vnode(fd, path, true, &amp;vnode, NULL, kernel);</a>
<a name="ln4005">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4006">		return status;</a>
<a name="ln4007"> </a>
<a name="ln4008">	status = open_attr_dir_vnode(vnode, kernel);</a>
<a name="ln4009">	if (status &lt; 0)</a>
<a name="ln4010">		put_vnode(vnode);</a>
<a name="ln4011"> </a>
<a name="ln4012">	return status;</a>
<a name="ln4013">}</a>
<a name="ln4014"> </a>
<a name="ln4015"> </a>
<a name="ln4016">static fssh_status_t</a>
<a name="ln4017">attr_dir_close(struct file_descriptor *descriptor)</a>
<a name="ln4018">{</a>
<a name="ln4019">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4020"> </a>
<a name="ln4021">	FUNCTION((&quot;attr_dir_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln4022"> </a>
<a name="ln4023">	if (HAS_FS_CALL(vnode, close_attr_dir))</a>
<a name="ln4024">		return FS_CALL(vnode, close_attr_dir, descriptor-&gt;cookie);</a>
<a name="ln4025"> </a>
<a name="ln4026">	return FSSH_B_OK;</a>
<a name="ln4027">}</a>
<a name="ln4028"> </a>
<a name="ln4029"> </a>
<a name="ln4030">static void</a>
<a name="ln4031">attr_dir_free_fd(struct file_descriptor *descriptor)</a>
<a name="ln4032">{</a>
<a name="ln4033">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4034"> </a>
<a name="ln4035">	if (vnode != NULL) {</a>
<a name="ln4036">		FS_CALL(vnode, free_attr_dir_cookie, descriptor-&gt;cookie);</a>
<a name="ln4037">		put_vnode(vnode);</a>
<a name="ln4038">	}</a>
<a name="ln4039">}</a>
<a name="ln4040"> </a>
<a name="ln4041"> </a>
<a name="ln4042">static fssh_status_t</a>
<a name="ln4043">attr_dir_read(struct file_descriptor *descriptor, struct fssh_dirent *buffer,</a>
<a name="ln4044">	fssh_size_t bufferSize, uint32_t *_count)</a>
<a name="ln4045">{</a>
<a name="ln4046">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4047"> </a>
<a name="ln4048">	FUNCTION((&quot;attr_dir_read(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln4049"> </a>
<a name="ln4050">	if (HAS_FS_CALL(vnode, read_attr_dir))</a>
<a name="ln4051">		return FS_CALL(vnode, read_attr_dir, descriptor-&gt;cookie, buffer, bufferSize, _count);</a>
<a name="ln4052"> </a>
<a name="ln4053">	return FSSH_EOPNOTSUPP;</a>
<a name="ln4054">}</a>
<a name="ln4055"> </a>
<a name="ln4056"> </a>
<a name="ln4057">static fssh_status_t</a>
<a name="ln4058">attr_dir_rewind(struct file_descriptor *descriptor)</a>
<a name="ln4059">{</a>
<a name="ln4060">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4061"> </a>
<a name="ln4062">	FUNCTION((&quot;attr_dir_rewind(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln4063"> </a>
<a name="ln4064">	if (HAS_FS_CALL(vnode, rewind_attr_dir))</a>
<a name="ln4065">		return FS_CALL(vnode, rewind_attr_dir, descriptor-&gt;cookie);</a>
<a name="ln4066"> </a>
<a name="ln4067">	return FSSH_EOPNOTSUPP;</a>
<a name="ln4068">}</a>
<a name="ln4069"> </a>
<a name="ln4070"> </a>
<a name="ln4071">static int</a>
<a name="ln4072">attr_create(int fd, const char *name, uint32_t type, int openMode, bool kernel)</a>
<a name="ln4073">{</a>
<a name="ln4074">	struct vnode *vnode;</a>
<a name="ln4075">	void *cookie;</a>
<a name="ln4076">	int status;</a>
<a name="ln4077"> </a>
<a name="ln4078">	if (name == NULL || *name == '\0')</a>
<a name="ln4079">		return FSSH_B_BAD_VALUE;</a>
<a name="ln4080"> </a>
<a name="ln4081">	vnode = get_vnode_from_fd(fd, kernel);</a>
<a name="ln4082">	if (vnode == NULL)</a>
<a name="ln4083">		return FSSH_B_FILE_ERROR;</a>
<a name="ln4084"> </a>
<a name="ln4085">	if (!HAS_FS_CALL(vnode, create_attr)) {</a>
<a name="ln4086">		status = FSSH_EROFS;</a>
<a name="ln4087">		goto err;</a>
<a name="ln4088">	}</a>
<a name="ln4089"> </a>
<a name="ln4090">	status = FS_CALL(vnode, create_attr, name, type, openMode, &amp;cookie);</a>
<a name="ln4091">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4092">		goto err;</a>
<a name="ln4093"> </a>
<a name="ln4094">	if ((status = get_new_fd(FDTYPE_ATTR, NULL, vnode, cookie, openMode, kernel)) &gt;= 0)</a>
<a name="ln4095">		return status;</a>
<a name="ln4096"> </a>
<a name="ln4097">	FS_CALL(vnode, close_attr, cookie);</a>
<a name="ln4098">	FS_CALL(vnode, free_attr_cookie, cookie);</a>
<a name="ln4099"> </a>
<a name="ln4100">	FS_CALL(vnode, remove_attr, name);</a>
<a name="ln4101"> </a>
<a name="ln4102">err:</a>
<a name="ln4103">	put_vnode(vnode);</a>
<a name="ln4104"> </a>
<a name="ln4105">	return status;</a>
<a name="ln4106">}</a>
<a name="ln4107"> </a>
<a name="ln4108"> </a>
<a name="ln4109">static int</a>
<a name="ln4110">attr_open(int fd, const char *name, int openMode, bool kernel)</a>
<a name="ln4111">{</a>
<a name="ln4112">	struct vnode *vnode;</a>
<a name="ln4113">	void *cookie;</a>
<a name="ln4114">	int status;</a>
<a name="ln4115"> </a>
<a name="ln4116">	if (name == NULL || *name == '\0')</a>
<a name="ln4117">		return FSSH_B_BAD_VALUE;</a>
<a name="ln4118"> </a>
<a name="ln4119">	vnode = get_vnode_from_fd(fd, kernel);</a>
<a name="ln4120">	if (vnode == NULL)</a>
<a name="ln4121">		return FSSH_B_FILE_ERROR;</a>
<a name="ln4122"> </a>
<a name="ln4123">	if (!HAS_FS_CALL(vnode, open_attr)) {</a>
<a name="ln4124">		status = FSSH_EOPNOTSUPP;</a>
<a name="ln4125">		goto err;</a>
<a name="ln4126">	}</a>
<a name="ln4127"> </a>
<a name="ln4128">	status = FS_CALL(vnode, open_attr, name, openMode, &amp;cookie);</a>
<a name="ln4129">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4130">		goto err;</a>
<a name="ln4131"> </a>
<a name="ln4132">	// now we only need a file descriptor for this attribute and we're done</a>
<a name="ln4133">	if ((status = get_new_fd(FDTYPE_ATTR, NULL, vnode, cookie, openMode, kernel)) &gt;= 0)</a>
<a name="ln4134">		return status;</a>
<a name="ln4135"> </a>
<a name="ln4136">	FS_CALL(vnode, close_attr, cookie);</a>
<a name="ln4137">	FS_CALL(vnode, free_attr_cookie, cookie);</a>
<a name="ln4138"> </a>
<a name="ln4139">err:</a>
<a name="ln4140">	put_vnode(vnode);</a>
<a name="ln4141"> </a>
<a name="ln4142">	return status;</a>
<a name="ln4143">}</a>
<a name="ln4144"> </a>
<a name="ln4145"> </a>
<a name="ln4146">static fssh_status_t</a>
<a name="ln4147">attr_close(struct file_descriptor *descriptor)</a>
<a name="ln4148">{</a>
<a name="ln4149">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4150"> </a>
<a name="ln4151">	FUNCTION((&quot;attr_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln4152"> </a>
<a name="ln4153">	if (HAS_FS_CALL(vnode, close_attr))</a>
<a name="ln4154">		return FS_CALL(vnode, close_attr, descriptor-&gt;cookie);</a>
<a name="ln4155"> </a>
<a name="ln4156">	return FSSH_B_OK;</a>
<a name="ln4157">}</a>
<a name="ln4158"> </a>
<a name="ln4159"> </a>
<a name="ln4160">static void</a>
<a name="ln4161">attr_free_fd(struct file_descriptor *descriptor)</a>
<a name="ln4162">{</a>
<a name="ln4163">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4164"> </a>
<a name="ln4165">	if (vnode != NULL) {</a>
<a name="ln4166">		FS_CALL(vnode, free_attr_cookie, descriptor-&gt;cookie);</a>
<a name="ln4167">		put_vnode(vnode);</a>
<a name="ln4168">	}</a>
<a name="ln4169">}</a>
<a name="ln4170"> </a>
<a name="ln4171"> </a>
<a name="ln4172">static fssh_status_t</a>
<a name="ln4173">attr_read(struct file_descriptor *descriptor, fssh_off_t pos, void *buffer, fssh_size_t *length)</a>
<a name="ln4174">{</a>
<a name="ln4175">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4176"> </a>
<a name="ln4177">	FUNCTION((&quot;attr_read: buf %p, pos %Ld, len %p = %ld\n&quot;, buffer, pos, length, *length));</a>
<a name="ln4178">	if (!HAS_FS_CALL(vnode, read_attr))</a>
<a name="ln4179">		return FSSH_EOPNOTSUPP;</a>
<a name="ln4180"> </a>
<a name="ln4181">	return FS_CALL(vnode, read_attr, descriptor-&gt;cookie, pos, buffer, length);</a>
<a name="ln4182">}</a>
<a name="ln4183"> </a>
<a name="ln4184"> </a>
<a name="ln4185">static fssh_status_t</a>
<a name="ln4186">attr_write(struct file_descriptor *descriptor, fssh_off_t pos, const void *buffer, fssh_size_t *length)</a>
<a name="ln4187">{</a>
<a name="ln4188">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4189"> </a>
<a name="ln4190">	FUNCTION((&quot;attr_write: buf %p, pos %Ld, len %p\n&quot;, buffer, pos, length));</a>
<a name="ln4191">	if (!HAS_FS_CALL(vnode, write_attr))</a>
<a name="ln4192">		return FSSH_EOPNOTSUPP;</a>
<a name="ln4193"> </a>
<a name="ln4194">	return FS_CALL(vnode, write_attr, descriptor-&gt;cookie, pos, buffer, length);</a>
<a name="ln4195">}</a>
<a name="ln4196"> </a>
<a name="ln4197"> </a>
<a name="ln4198">static fssh_off_t</a>
<a name="ln4199">attr_seek(struct file_descriptor *descriptor, fssh_off_t pos, int seekType)</a>
<a name="ln4200">{</a>
<a name="ln4201">	fssh_off_t offset;</a>
<a name="ln4202"> </a>
<a name="ln4203">	switch (seekType) {</a>
<a name="ln4204">		case FSSH_SEEK_SET:</a>
<a name="ln4205">			offset = 0;</a>
<a name="ln4206">			break;</a>
<a name="ln4207">		case FSSH_SEEK_CUR:</a>
<a name="ln4208">			offset = descriptor-&gt;pos;</a>
<a name="ln4209">			break;</a>
<a name="ln4210">		case FSSH_SEEK_END:</a>
<a name="ln4211">		{</a>
<a name="ln4212">			struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4213">			struct fssh_stat stat;</a>
<a name="ln4214">			fssh_status_t status;</a>
<a name="ln4215"> </a>
<a name="ln4216">			if (!HAS_FS_CALL(vnode, read_stat))</a>
<a name="ln4217">				return FSSH_EOPNOTSUPP;</a>
<a name="ln4218"> </a>
<a name="ln4219">			status = FS_CALL(vnode, read_attr_stat, descriptor-&gt;cookie, &amp;stat);</a>
<a name="ln4220">			if (status &lt; FSSH_B_OK)</a>
<a name="ln4221">				return status;</a>
<a name="ln4222"> </a>
<a name="ln4223">			offset = stat.fssh_st_size;</a>
<a name="ln4224">			break;</a>
<a name="ln4225">		}</a>
<a name="ln4226">		default:</a>
<a name="ln4227">			return FSSH_B_BAD_VALUE;</a>
<a name="ln4228">	}</a>
<a name="ln4229"> </a>
<a name="ln4230">	// assumes fssh_off_t is 64 bits wide</a>
<a name="ln4231">	if (offset &gt; 0 &amp;&amp; LLONG_MAX - offset &lt; pos)</a>
<a name="ln4232">		return FSSH_EOVERFLOW;</a>
<a name="ln4233"> </a>
<a name="ln4234">	pos += offset;</a>
<a name="ln4235">	if (pos &lt; 0)</a>
<a name="ln4236">		return FSSH_B_BAD_VALUE;</a>
<a name="ln4237"> </a>
<a name="ln4238">	return descriptor-&gt;pos = pos;</a>
<a name="ln4239">}</a>
<a name="ln4240"> </a>
<a name="ln4241"> </a>
<a name="ln4242">static fssh_status_t</a>
<a name="ln4243">attr_read_stat(struct file_descriptor *descriptor, struct fssh_stat *stat)</a>
<a name="ln4244">{</a>
<a name="ln4245">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4246"> </a>
<a name="ln4247">	FUNCTION((&quot;attr_read_stat: stat 0x%p\n&quot;, stat));</a>
<a name="ln4248"> </a>
<a name="ln4249">	if (!HAS_FS_CALL(vnode, read_attr_stat))</a>
<a name="ln4250">		return FSSH_EOPNOTSUPP;</a>
<a name="ln4251"> </a>
<a name="ln4252">	return FS_CALL(vnode, read_attr_stat, descriptor-&gt;cookie, stat);</a>
<a name="ln4253">}</a>
<a name="ln4254"> </a>
<a name="ln4255"> </a>
<a name="ln4256">static fssh_status_t</a>
<a name="ln4257">attr_write_stat(struct file_descriptor *descriptor,</a>
<a name="ln4258">	const struct fssh_stat *stat, int statMask)</a>
<a name="ln4259">{</a>
<a name="ln4260">	struct vnode *vnode = descriptor-&gt;u.vnode;</a>
<a name="ln4261"> </a>
<a name="ln4262">	FUNCTION((&quot;attr_write_stat: stat = %p, statMask %d\n&quot;, stat, statMask));</a>
<a name="ln4263"> </a>
<a name="ln4264">	if (!HAS_FS_CALL(vnode, write_attr_stat))</a>
<a name="ln4265">		return FSSH_EROFS;</a>
<a name="ln4266"> </a>
<a name="ln4267">	return FS_CALL(vnode, write_attr_stat, descriptor-&gt;cookie, stat, statMask);</a>
<a name="ln4268">}</a>
<a name="ln4269"> </a>
<a name="ln4270"> </a>
<a name="ln4271">static fssh_status_t</a>
<a name="ln4272">attr_remove(int fd, const char *name, bool kernel)</a>
<a name="ln4273">{</a>
<a name="ln4274">	struct file_descriptor *descriptor;</a>
<a name="ln4275">	struct vnode *vnode;</a>
<a name="ln4276">	fssh_status_t status;</a>
<a name="ln4277"> </a>
<a name="ln4278">	if (name == NULL || *name == '\0')</a>
<a name="ln4279">		return FSSH_B_BAD_VALUE;</a>
<a name="ln4280"> </a>
<a name="ln4281">	FUNCTION((&quot;attr_remove: fd = %d, name = \&quot;%s\&quot;, kernel %d\n&quot;, fd, name, kernel));</a>
<a name="ln4282"> </a>
<a name="ln4283">	descriptor = get_fd_and_vnode(fd, &amp;vnode, kernel);</a>
<a name="ln4284">	if (descriptor == NULL)</a>
<a name="ln4285">		return FSSH_B_FILE_ERROR;</a>
<a name="ln4286"> </a>
<a name="ln4287">	if (HAS_FS_CALL(vnode, remove_attr))</a>
<a name="ln4288">		status = FS_CALL(vnode, remove_attr, name);</a>
<a name="ln4289">	else</a>
<a name="ln4290">		status = FSSH_EROFS;</a>
<a name="ln4291"> </a>
<a name="ln4292">	put_fd(descriptor);</a>
<a name="ln4293"> </a>
<a name="ln4294">	return status;</a>
<a name="ln4295">}</a>
<a name="ln4296"> </a>
<a name="ln4297"> </a>
<a name="ln4298">static fssh_status_t</a>
<a name="ln4299">attr_rename(int fromfd, const char *fromName, int tofd, const char *toName, bool kernel)</a>
<a name="ln4300">{</a>
<a name="ln4301">	struct file_descriptor *fromDescriptor, *toDescriptor;</a>
<a name="ln4302">	struct vnode *fromVnode, *toVnode;</a>
<a name="ln4303">	fssh_status_t status;</a>
<a name="ln4304"> </a>
<a name="ln4305">	if (fromName == NULL || *fromName == '\0' || toName == NULL || *toName == '\0')</a>
<a name="ln4306">		return FSSH_B_BAD_VALUE;</a>
<a name="ln4307"> </a>
<a name="ln4308">	FUNCTION((&quot;attr_rename: from fd = %d, from name = \&quot;%s\&quot;, to fd = %d, to name = \&quot;%s\&quot;, kernel %d\n&quot;, fromfd, fromName, tofd, toName, kernel));</a>
<a name="ln4309"> </a>
<a name="ln4310">	fromDescriptor = get_fd_and_vnode(fromfd, &amp;fromVnode, kernel);</a>
<a name="ln4311">	if (fromDescriptor == NULL)</a>
<a name="ln4312">		return FSSH_B_FILE_ERROR;</a>
<a name="ln4313"> </a>
<a name="ln4314">	toDescriptor = get_fd_and_vnode(tofd, &amp;toVnode, kernel);</a>
<a name="ln4315">	if (toDescriptor == NULL) {</a>
<a name="ln4316">		status = FSSH_B_FILE_ERROR;</a>
<a name="ln4317">		goto err;</a>
<a name="ln4318">	}</a>
<a name="ln4319"> </a>
<a name="ln4320">	// are the files on the same volume?</a>
<a name="ln4321">	if (fromVnode-&gt;device != toVnode-&gt;device) {</a>
<a name="ln4322">		status = FSSH_B_CROSS_DEVICE_LINK;</a>
<a name="ln4323">		goto err1;</a>
<a name="ln4324">	}</a>
<a name="ln4325"> </a>
<a name="ln4326">	if (HAS_FS_CALL(fromVnode, rename_attr))</a>
<a name="ln4327">		status = FS_CALL(fromVnode, rename_attr, fromName, toVnode, toName);</a>
<a name="ln4328">	else</a>
<a name="ln4329">		status = FSSH_EROFS;</a>
<a name="ln4330"> </a>
<a name="ln4331">err1:</a>
<a name="ln4332">	put_fd(toDescriptor);</a>
<a name="ln4333">err:</a>
<a name="ln4334">	put_fd(fromDescriptor);</a>
<a name="ln4335"> </a>
<a name="ln4336">	return status;</a>
<a name="ln4337">}</a>
<a name="ln4338"> </a>
<a name="ln4339"> </a>
<a name="ln4340">static fssh_status_t</a>
<a name="ln4341">index_dir_open(fssh_mount_id mountID, bool kernel)</a>
<a name="ln4342">{</a>
<a name="ln4343">	struct fs_mount *mount;</a>
<a name="ln4344">	void *cookie;</a>
<a name="ln4345"> </a>
<a name="ln4346">	FUNCTION((&quot;index_dir_open(mountID = %ld, kernel = %d)\n&quot;, mountID, kernel));</a>
<a name="ln4347"> </a>
<a name="ln4348">	fssh_status_t status = get_mount(mountID, &amp;mount);</a>
<a name="ln4349">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4350">		return status;</a>
<a name="ln4351"> </a>
<a name="ln4352">	if (!HAS_FS_MOUNT_CALL(mount, open_index_dir)) {</a>
<a name="ln4353">		status = FSSH_EOPNOTSUPP;</a>
<a name="ln4354">		goto out;</a>
<a name="ln4355">	}</a>
<a name="ln4356"> </a>
<a name="ln4357">	status = FS_MOUNT_CALL(mount, open_index_dir, &amp;cookie);</a>
<a name="ln4358">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4359">		goto out;</a>
<a name="ln4360"> </a>
<a name="ln4361">	// get fd for the index directory</a>
<a name="ln4362">	status = get_new_fd(FDTYPE_INDEX_DIR, mount, NULL, cookie, 0, kernel);</a>
<a name="ln4363">	if (status &gt;= 0)</a>
<a name="ln4364">		goto out;</a>
<a name="ln4365"> </a>
<a name="ln4366">	// something went wrong</a>
<a name="ln4367">	FS_MOUNT_CALL(mount, close_index_dir, cookie);</a>
<a name="ln4368">	FS_MOUNT_CALL(mount, free_index_dir_cookie, cookie);</a>
<a name="ln4369"> </a>
<a name="ln4370">out:</a>
<a name="ln4371">	put_mount(mount);</a>
<a name="ln4372">	return status;</a>
<a name="ln4373">}</a>
<a name="ln4374"> </a>
<a name="ln4375"> </a>
<a name="ln4376">static fssh_status_t</a>
<a name="ln4377">index_dir_close(struct file_descriptor *descriptor)</a>
<a name="ln4378">{</a>
<a name="ln4379">	struct fs_mount *mount = descriptor-&gt;u.mount;</a>
<a name="ln4380"> </a>
<a name="ln4381">	FUNCTION((&quot;index_dir_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln4382"> </a>
<a name="ln4383">	if (HAS_FS_MOUNT_CALL(mount, close_index_dir))</a>
<a name="ln4384">		return FS_MOUNT_CALL(mount, close_index_dir, descriptor-&gt;cookie);</a>
<a name="ln4385"> </a>
<a name="ln4386">	return FSSH_B_OK;</a>
<a name="ln4387">}</a>
<a name="ln4388"> </a>
<a name="ln4389"> </a>
<a name="ln4390">static void</a>
<a name="ln4391">index_dir_free_fd(struct file_descriptor *descriptor)</a>
<a name="ln4392">{</a>
<a name="ln4393">	struct fs_mount *mount = descriptor-&gt;u.mount;</a>
<a name="ln4394"> </a>
<a name="ln4395">	if (mount != NULL) {</a>
<a name="ln4396">		FS_MOUNT_CALL(mount, free_index_dir_cookie, descriptor-&gt;cookie);</a>
<a name="ln4397">		// ToDo: find a replacement ref_count object - perhaps the root dir?</a>
<a name="ln4398">		//put_vnode(vnode);</a>
<a name="ln4399">	}</a>
<a name="ln4400">}</a>
<a name="ln4401"> </a>
<a name="ln4402"> </a>
<a name="ln4403">static fssh_status_t</a>
<a name="ln4404">index_dir_read(struct file_descriptor *descriptor, struct fssh_dirent *buffer,</a>
<a name="ln4405">	fssh_size_t bufferSize, uint32_t *_count)</a>
<a name="ln4406">{</a>
<a name="ln4407">	struct fs_mount *mount = descriptor-&gt;u.mount;</a>
<a name="ln4408"> </a>
<a name="ln4409">	if (HAS_FS_MOUNT_CALL(mount, read_index_dir))</a>
<a name="ln4410">		return FS_MOUNT_CALL(mount, read_index_dir, descriptor-&gt;cookie, buffer, bufferSize, _count);</a>
<a name="ln4411"> </a>
<a name="ln4412">	return FSSH_EOPNOTSUPP;</a>
<a name="ln4413">}</a>
<a name="ln4414"> </a>
<a name="ln4415"> </a>
<a name="ln4416">static fssh_status_t</a>
<a name="ln4417">index_dir_rewind(struct file_descriptor *descriptor)</a>
<a name="ln4418">{</a>
<a name="ln4419">	struct fs_mount *mount = descriptor-&gt;u.mount;</a>
<a name="ln4420"> </a>
<a name="ln4421">	if (HAS_FS_MOUNT_CALL(mount, rewind_index_dir))</a>
<a name="ln4422">		return FS_MOUNT_CALL(mount, rewind_index_dir, descriptor-&gt;cookie);</a>
<a name="ln4423"> </a>
<a name="ln4424">	return FSSH_EOPNOTSUPP;</a>
<a name="ln4425">}</a>
<a name="ln4426"> </a>
<a name="ln4427"> </a>
<a name="ln4428">static fssh_status_t</a>
<a name="ln4429">index_create(fssh_mount_id mountID, const char *name, uint32_t type, uint32_t flags, bool kernel)</a>
<a name="ln4430">{</a>
<a name="ln4431">	FUNCTION((&quot;index_create(mountID = %ld, name = %s, kernel = %d)\n&quot;, mountID, name, kernel));</a>
<a name="ln4432"> </a>
<a name="ln4433">	struct fs_mount *mount;</a>
<a name="ln4434">	fssh_status_t status = get_mount(mountID, &amp;mount);</a>
<a name="ln4435">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4436">		return status;</a>
<a name="ln4437"> </a>
<a name="ln4438">	if (!HAS_FS_MOUNT_CALL(mount, create_index)) {</a>
<a name="ln4439">		status = FSSH_EROFS;</a>
<a name="ln4440">		goto out;</a>
<a name="ln4441">	}</a>
<a name="ln4442"> </a>
<a name="ln4443">	status = FS_MOUNT_CALL(mount, create_index, name, type, flags);</a>
<a name="ln4444"> </a>
<a name="ln4445">out:</a>
<a name="ln4446">	put_mount(mount);</a>
<a name="ln4447">	return status;</a>
<a name="ln4448">}</a>
<a name="ln4449"> </a>
<a name="ln4450"> </a>
<a name="ln4451">static fssh_status_t</a>
<a name="ln4452">index_name_read_stat(fssh_mount_id mountID, const char *name,</a>
<a name="ln4453">	struct fssh_stat *stat, bool kernel)</a>
<a name="ln4454">{</a>
<a name="ln4455">	FUNCTION((&quot;index_remove(mountID = %ld, name = %s, kernel = %d)\n&quot;, mountID, name, kernel));</a>
<a name="ln4456"> </a>
<a name="ln4457">	struct fs_mount *mount;</a>
<a name="ln4458">	fssh_status_t status = get_mount(mountID, &amp;mount);</a>
<a name="ln4459">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4460">		return status;</a>
<a name="ln4461"> </a>
<a name="ln4462">	if (!HAS_FS_MOUNT_CALL(mount, read_index_stat)) {</a>
<a name="ln4463">		status = FSSH_EOPNOTSUPP;</a>
<a name="ln4464">		goto out;</a>
<a name="ln4465">	}</a>
<a name="ln4466"> </a>
<a name="ln4467">	status = FS_MOUNT_CALL(mount, read_index_stat, name, stat);</a>
<a name="ln4468"> </a>
<a name="ln4469">out:</a>
<a name="ln4470">	put_mount(mount);</a>
<a name="ln4471">	return status;</a>
<a name="ln4472">}</a>
<a name="ln4473"> </a>
<a name="ln4474"> </a>
<a name="ln4475">static fssh_status_t</a>
<a name="ln4476">index_remove(fssh_mount_id mountID, const char *name, bool kernel)</a>
<a name="ln4477">{</a>
<a name="ln4478">	FUNCTION((&quot;index_remove(mountID = %ld, name = %s, kernel = %d)\n&quot;, mountID, name, kernel));</a>
<a name="ln4479"> </a>
<a name="ln4480">	struct fs_mount *mount;</a>
<a name="ln4481">	fssh_status_t status = get_mount(mountID, &amp;mount);</a>
<a name="ln4482">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4483">		return status;</a>
<a name="ln4484"> </a>
<a name="ln4485">	if (!HAS_FS_MOUNT_CALL(mount, remove_index)) {</a>
<a name="ln4486">		status = FSSH_EROFS;</a>
<a name="ln4487">		goto out;</a>
<a name="ln4488">	}</a>
<a name="ln4489"> </a>
<a name="ln4490">	status = FS_MOUNT_CALL(mount, remove_index, name);</a>
<a name="ln4491"> </a>
<a name="ln4492">out:</a>
<a name="ln4493">	put_mount(mount);</a>
<a name="ln4494">	return status;</a>
<a name="ln4495">}</a>
<a name="ln4496"> </a>
<a name="ln4497"> </a>
<a name="ln4498">/*!	ToDo: the query FS API is still the pretty much the same as in R5.</a>
<a name="ln4499">		It would be nice if the FS would find some more kernel support</a>
<a name="ln4500">		for them.</a>
<a name="ln4501">		For example, query parsing should be moved into the kernel.</a>
<a name="ln4502">*/</a>
<a name="ln4503">static int</a>
<a name="ln4504">query_open(fssh_dev_t device, const char *query, uint32_t flags,</a>
<a name="ln4505">	fssh_port_id port, int32_t token, bool kernel)</a>
<a name="ln4506">{</a>
<a name="ln4507">	struct fs_mount *mount;</a>
<a name="ln4508">	void *cookie;</a>
<a name="ln4509"> </a>
<a name="ln4510">	FUNCTION((&quot;query_open(device = %ld, query = \&quot;%s\&quot;, kernel = %d)\n&quot;, device, query, kernel));</a>
<a name="ln4511"> </a>
<a name="ln4512">	fssh_status_t status = get_mount(device, &amp;mount);</a>
<a name="ln4513">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4514">		return status;</a>
<a name="ln4515"> </a>
<a name="ln4516">	if (!HAS_FS_MOUNT_CALL(mount, open_query)) {</a>
<a name="ln4517">		status = FSSH_EOPNOTSUPP;</a>
<a name="ln4518">		goto out;</a>
<a name="ln4519">	}</a>
<a name="ln4520"> </a>
<a name="ln4521">	status = FS_MOUNT_CALL(mount, open_query, query, flags, port, token, &amp;cookie);</a>
<a name="ln4522">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4523">		goto out;</a>
<a name="ln4524"> </a>
<a name="ln4525">	// get fd for the index directory</a>
<a name="ln4526">	status = get_new_fd(FDTYPE_QUERY, mount, NULL, cookie, 0, kernel);</a>
<a name="ln4527">	if (status &gt;= 0)</a>
<a name="ln4528">		goto out;</a>
<a name="ln4529"> </a>
<a name="ln4530">	// something went wrong</a>
<a name="ln4531">	FS_MOUNT_CALL(mount, close_query, cookie);</a>
<a name="ln4532">	FS_MOUNT_CALL(mount, free_query_cookie, cookie);</a>
<a name="ln4533"> </a>
<a name="ln4534">out:</a>
<a name="ln4535">	put_mount(mount);</a>
<a name="ln4536">	return status;</a>
<a name="ln4537">}</a>
<a name="ln4538"> </a>
<a name="ln4539"> </a>
<a name="ln4540">static fssh_status_t</a>
<a name="ln4541">query_close(struct file_descriptor *descriptor)</a>
<a name="ln4542">{</a>
<a name="ln4543">	struct fs_mount *mount = descriptor-&gt;u.mount;</a>
<a name="ln4544"> </a>
<a name="ln4545">	FUNCTION((&quot;query_close(descriptor = %p)\n&quot;, descriptor));</a>
<a name="ln4546"> </a>
<a name="ln4547">	if (HAS_FS_MOUNT_CALL(mount, close_query))</a>
<a name="ln4548">		return FS_MOUNT_CALL(mount, close_query, descriptor-&gt;cookie);</a>
<a name="ln4549"> </a>
<a name="ln4550">	return FSSH_B_OK;</a>
<a name="ln4551">}</a>
<a name="ln4552"> </a>
<a name="ln4553"> </a>
<a name="ln4554">static void</a>
<a name="ln4555">query_free_fd(struct file_descriptor *descriptor)</a>
<a name="ln4556">{</a>
<a name="ln4557">	struct fs_mount *mount = descriptor-&gt;u.mount;</a>
<a name="ln4558"> </a>
<a name="ln4559">	if (mount != NULL) {</a>
<a name="ln4560">		FS_MOUNT_CALL(mount, free_query_cookie, descriptor-&gt;cookie);</a>
<a name="ln4561">		// ToDo: find a replacement ref_count object - perhaps the root dir?</a>
<a name="ln4562">		//put_vnode(vnode);</a>
<a name="ln4563">	}</a>
<a name="ln4564">}</a>
<a name="ln4565"> </a>
<a name="ln4566"> </a>
<a name="ln4567">static fssh_status_t</a>
<a name="ln4568">query_read(struct file_descriptor *descriptor, struct fssh_dirent *buffer,</a>
<a name="ln4569">	fssh_size_t bufferSize, uint32_t *_count)</a>
<a name="ln4570">{</a>
<a name="ln4571">	struct fs_mount *mount = descriptor-&gt;u.mount;</a>
<a name="ln4572"> </a>
<a name="ln4573">	if (HAS_FS_MOUNT_CALL(mount, read_query))</a>
<a name="ln4574">		return FS_MOUNT_CALL(mount, read_query, descriptor-&gt;cookie, buffer, bufferSize, _count);</a>
<a name="ln4575"> </a>
<a name="ln4576">	return FSSH_EOPNOTSUPP;</a>
<a name="ln4577">}</a>
<a name="ln4578"> </a>
<a name="ln4579"> </a>
<a name="ln4580">static fssh_status_t</a>
<a name="ln4581">query_rewind(struct file_descriptor *descriptor)</a>
<a name="ln4582">{</a>
<a name="ln4583">	struct fs_mount *mount = descriptor-&gt;u.mount;</a>
<a name="ln4584"> </a>
<a name="ln4585">	if (HAS_FS_MOUNT_CALL(mount, rewind_query))</a>
<a name="ln4586">		return FS_MOUNT_CALL(mount, rewind_query, descriptor-&gt;cookie);</a>
<a name="ln4587"> </a>
<a name="ln4588">	return FSSH_EOPNOTSUPP;</a>
<a name="ln4589">}</a>
<a name="ln4590"> </a>
<a name="ln4591"> </a>
<a name="ln4592">//	#pragma mark -</a>
<a name="ln4593">//	General File System functions</a>
<a name="ln4594"> </a>
<a name="ln4595"> </a>
<a name="ln4596">static fssh_dev_t</a>
<a name="ln4597">fs_mount(char *path, const char *device, const char *fsName, uint32_t flags,</a>
<a name="ln4598">	const char *args, bool kernel)</a>
<a name="ln4599">{</a>
<a name="ln4600">	struct fs_mount *mount;</a>
<a name="ln4601">	fssh_status_t status = 0;</a>
<a name="ln4602"> </a>
<a name="ln4603">	FUNCTION((&quot;fs_mount: entry. path = '%s', fs_name = '%s'\n&quot;, path, fsName));</a>
<a name="ln4604"> </a>
<a name="ln4605">	// The path is always safe, we just have to make sure that fsName is</a>
<a name="ln4606">	// almost valid - we can't make any assumptions about args, though.</a>
<a name="ln4607">	// A NULL fsName is OK, if a device was given and the FS is not virtual.</a>
<a name="ln4608">	// We'll get it from the DDM later.</a>
<a name="ln4609">	if (fsName == NULL) {</a>
<a name="ln4610">		if (!device || flags &amp; FSSH_B_MOUNT_VIRTUAL_DEVICE)</a>
<a name="ln4611">			return FSSH_B_BAD_VALUE;</a>
<a name="ln4612">	} else if (fsName[0] == '\0')</a>
<a name="ln4613">		return FSSH_B_BAD_VALUE;</a>
<a name="ln4614"> </a>
<a name="ln4615">	RecursiveLocker mountOpLocker(sMountOpLock);</a>
<a name="ln4616"> </a>
<a name="ln4617">	// If the file system is not a &quot;virtual&quot; one, the device argument should</a>
<a name="ln4618">	// point to a real file/device (if given at all).</a>
<a name="ln4619">	// get the partition</a>
<a name="ln4620">	KPath normalizedDevice;</a>
<a name="ln4621"> </a>
<a name="ln4622">	if (!(flags &amp; FSSH_B_MOUNT_VIRTUAL_DEVICE) &amp;&amp; device) {</a>
<a name="ln4623">		// normalize the device path</a>
<a name="ln4624">//		status = normalizedDevice.SetTo(device, true);</a>
<a name="ln4625">// NOTE: normalizing works only in our namespace.</a>
<a name="ln4626">		status = normalizedDevice.SetTo(device, false);</a>
<a name="ln4627">		if (status != FSSH_B_OK)</a>
<a name="ln4628">			return status;</a>
<a name="ln4629"> </a>
<a name="ln4630">		device = normalizedDevice.Path();</a>
<a name="ln4631">			// correct path to file device</a>
<a name="ln4632">	}</a>
<a name="ln4633"> </a>
<a name="ln4634">	mount = (struct fs_mount *)malloc(sizeof(struct fs_mount));</a>
<a name="ln4635">	if (mount == NULL)</a>
<a name="ln4636">		return FSSH_B_NO_MEMORY;</a>
<a name="ln4637"> </a>
<a name="ln4638">	mount-&gt;volume = (fssh_fs_volume*)malloc(sizeof(fssh_fs_volume));</a>
<a name="ln4639">	if (mount-&gt;volume == NULL) {</a>
<a name="ln4640">		free(mount);</a>
<a name="ln4641">		return FSSH_B_NO_MEMORY;</a>
<a name="ln4642">	}</a>
<a name="ln4643"> </a>
<a name="ln4644">	list_init_etc(&amp;mount-&gt;vnodes, fssh_offsetof(struct vnode, mount_link));</a>
<a name="ln4645"> </a>
<a name="ln4646">	mount-&gt;fs_name = get_file_system_name(fsName);</a>
<a name="ln4647">	if (mount-&gt;fs_name == NULL) {</a>
<a name="ln4648">		status = FSSH_B_NO_MEMORY;</a>
<a name="ln4649">		goto err1;</a>
<a name="ln4650">	}</a>
<a name="ln4651"> </a>
<a name="ln4652">	mount-&gt;device_name = fssh_strdup(device);</a>
<a name="ln4653">		// &quot;device&quot; can be NULL</a>
<a name="ln4654"> </a>
<a name="ln4655">	mount-&gt;fs = get_file_system(fsName);</a>
<a name="ln4656">	if (mount-&gt;fs == NULL) {</a>
<a name="ln4657">		status = FSSH_ENODEV;</a>
<a name="ln4658">		goto err3;</a>
<a name="ln4659">	}</a>
<a name="ln4660"> </a>
<a name="ln4661">	fssh_recursive_lock_init(&amp;mount-&gt;rlock, &quot;mount rlock&quot;);</a>
<a name="ln4662"> </a>
<a name="ln4663">	// initialize structure</a>
<a name="ln4664">	mount-&gt;id = sNextMountID++;</a>
<a name="ln4665">	mount-&gt;root_vnode = NULL;</a>
<a name="ln4666">	mount-&gt;covers_vnode = NULL;</a>
<a name="ln4667">	mount-&gt;unmounting = false;</a>
<a name="ln4668">	mount-&gt;owns_file_device = false;</a>
<a name="ln4669"> </a>
<a name="ln4670">	mount-&gt;volume-&gt;id = mount-&gt;id;</a>
<a name="ln4671">	mount-&gt;volume-&gt;layer = 0;</a>
<a name="ln4672">	mount-&gt;volume-&gt;private_volume = NULL;</a>
<a name="ln4673">	mount-&gt;volume-&gt;ops = NULL;</a>
<a name="ln4674">	mount-&gt;volume-&gt;sub_volume = NULL;</a>
<a name="ln4675">	mount-&gt;volume-&gt;super_volume = NULL;</a>
<a name="ln4676"> </a>
<a name="ln4677">	// insert mount struct into list before we call FS's mount() function</a>
<a name="ln4678">	// so that vnodes can be created for this mount</a>
<a name="ln4679">	fssh_mutex_lock(&amp;sMountMutex);</a>
<a name="ln4680">	hash_insert(sMountsTable, mount);</a>
<a name="ln4681">	fssh_mutex_unlock(&amp;sMountMutex);</a>
<a name="ln4682"> </a>
<a name="ln4683">	fssh_vnode_id rootID;</a>
<a name="ln4684"> </a>
<a name="ln4685">	if (!sRoot) {</a>
<a name="ln4686">		// we haven't mounted anything yet</a>
<a name="ln4687">		if (fssh_strcmp(path, &quot;/&quot;) != 0) {</a>
<a name="ln4688">			status = FSSH_B_ERROR;</a>
<a name="ln4689">			goto err4;</a>
<a name="ln4690">		}</a>
<a name="ln4691"> </a>
<a name="ln4692">		status = mount-&gt;fs-&gt;mount(mount-&gt;volume, device, flags, args, &amp;rootID);</a>
<a name="ln4693">		if (status &lt; 0) {</a>
<a name="ln4694">			// ToDo: why should we hide the error code from the file system here?</a>
<a name="ln4695">			//status = ERR_VFS_GENERAL;</a>
<a name="ln4696">			goto err4;</a>
<a name="ln4697">		}</a>
<a name="ln4698">	} else {</a>
<a name="ln4699">		struct vnode *coveredVnode;</a>
<a name="ln4700">		status = path_to_vnode(path, true, &amp;coveredVnode, NULL, kernel);</a>
<a name="ln4701">		if (status &lt; FSSH_B_OK)</a>
<a name="ln4702">			goto err4;</a>
<a name="ln4703"> </a>
<a name="ln4704">		// make sure covered_vnode is a DIR</a>
<a name="ln4705">		struct fssh_stat coveredNodeStat;</a>
<a name="ln4706">		status = FS_CALL(coveredVnode, read_stat, &amp;coveredNodeStat);</a>
<a name="ln4707">		if (status &lt; FSSH_B_OK)</a>
<a name="ln4708">			goto err4;</a>
<a name="ln4709"> </a>
<a name="ln4710">		if (!FSSH_S_ISDIR(coveredNodeStat.fssh_st_mode)) {</a>
<a name="ln4711">			status = FSSH_B_NOT_A_DIRECTORY;</a>
<a name="ln4712">			goto err4;</a>
<a name="ln4713">		}</a>
<a name="ln4714"> </a>
<a name="ln4715">		if (coveredVnode-&gt;mount-&gt;root_vnode == coveredVnode) {</a>
<a name="ln4716">			// this is already a mount point</a>
<a name="ln4717">			status = FSSH_B_BUSY;</a>
<a name="ln4718">			goto err4;</a>
<a name="ln4719">		}</a>
<a name="ln4720"> </a>
<a name="ln4721">		mount-&gt;covers_vnode = coveredVnode;</a>
<a name="ln4722"> </a>
<a name="ln4723">		// mount it</a>
<a name="ln4724">		status = mount-&gt;fs-&gt;mount(mount-&gt;volume, device, flags, args, &amp;rootID);</a>
<a name="ln4725">		if (status &lt; FSSH_B_OK)</a>
<a name="ln4726">			goto err5;</a>
<a name="ln4727">	}</a>
<a name="ln4728"> </a>
<a name="ln4729">	// the root node is supposed to be owned by the file system - it must</a>
<a name="ln4730">	// exist at this point</a>
<a name="ln4731">	mount-&gt;root_vnode = lookup_vnode(mount-&gt;id, rootID);</a>
<a name="ln4732">	if (mount-&gt;root_vnode == NULL || mount-&gt;root_vnode-&gt;ref_count != 1) {</a>
<a name="ln4733">		fssh_panic(&quot;fs_mount: file system does not own its root node!\n&quot;);</a>
<a name="ln4734">		status = FSSH_B_ERROR;</a>
<a name="ln4735">		goto err6;</a>
<a name="ln4736">	}</a>
<a name="ln4737"> </a>
<a name="ln4738">	// No race here, since fs_mount() is the only function changing</a>
<a name="ln4739">	// covers_vnode (and holds sMountOpLock at that time).</a>
<a name="ln4740">	fssh_mutex_lock(&amp;sVnodeCoveredByMutex);</a>
<a name="ln4741">	if (mount-&gt;covers_vnode)</a>
<a name="ln4742">		mount-&gt;covers_vnode-&gt;covered_by = mount-&gt;root_vnode;</a>
<a name="ln4743">	fssh_mutex_unlock(&amp;sVnodeCoveredByMutex);</a>
<a name="ln4744"> </a>
<a name="ln4745">	if (!sRoot)</a>
<a name="ln4746">		sRoot = mount-&gt;root_vnode;</a>
<a name="ln4747"> </a>
<a name="ln4748">	return mount-&gt;id;</a>
<a name="ln4749"> </a>
<a name="ln4750">err6:</a>
<a name="ln4751">	FS_MOUNT_CALL_NO_PARAMS(mount, unmount);</a>
<a name="ln4752">err5:</a>
<a name="ln4753">	if (mount-&gt;covers_vnode)</a>
<a name="ln4754">		put_vnode(mount-&gt;covers_vnode);</a>
<a name="ln4755"> </a>
<a name="ln4756">err4:</a>
<a name="ln4757">	fssh_mutex_lock(&amp;sMountMutex);</a>
<a name="ln4758">	hash_remove(sMountsTable, mount);</a>
<a name="ln4759">	fssh_mutex_unlock(&amp;sMountMutex);</a>
<a name="ln4760"> </a>
<a name="ln4761">	fssh_recursive_lock_destroy(&amp;mount-&gt;rlock);</a>
<a name="ln4762"> </a>
<a name="ln4763">	put_file_system(mount-&gt;fs);</a>
<a name="ln4764">	free(mount-&gt;device_name);</a>
<a name="ln4765">err3:</a>
<a name="ln4766">	free(mount-&gt;fs_name);</a>
<a name="ln4767">err1:</a>
<a name="ln4768">	free(mount-&gt;volume);</a>
<a name="ln4769">	free(mount);</a>
<a name="ln4770"> </a>
<a name="ln4771">	return status;</a>
<a name="ln4772">}</a>
<a name="ln4773"> </a>
<a name="ln4774"> </a>
<a name="ln4775">static fssh_status_t</a>
<a name="ln4776">fs_unmount(char *path, uint32_t flags, bool kernel)</a>
<a name="ln4777">{</a>
<a name="ln4778">	struct fs_mount *mount;</a>
<a name="ln4779">	struct vnode *vnode;</a>
<a name="ln4780">	fssh_status_t err;</a>
<a name="ln4781"> </a>
<a name="ln4782">	FUNCTION((&quot;vfs_unmount: entry. path = '%s', kernel %d\n&quot;, path, kernel));</a>
<a name="ln4783"> </a>
<a name="ln4784">	err = path_to_vnode(path, true, &amp;vnode, NULL, kernel);</a>
<a name="ln4785">	if (err &lt; 0)</a>
<a name="ln4786">		return FSSH_B_ENTRY_NOT_FOUND;</a>
<a name="ln4787"> </a>
<a name="ln4788">	RecursiveLocker mountOpLocker(sMountOpLock);</a>
<a name="ln4789"> </a>
<a name="ln4790">	mount = find_mount(vnode-&gt;device);</a>
<a name="ln4791">	if (!mount)</a>
<a name="ln4792">		fssh_panic(&quot;vfs_unmount: find_mount() failed on root vnode @%p of mount\n&quot;, vnode);</a>
<a name="ln4793"> </a>
<a name="ln4794">	if (mount-&gt;root_vnode != vnode) {</a>
<a name="ln4795">		// not mountpoint</a>
<a name="ln4796">		put_vnode(vnode);</a>
<a name="ln4797">		return FSSH_B_BAD_VALUE;</a>
<a name="ln4798">	}</a>
<a name="ln4799"> </a>
<a name="ln4800">	// grab the vnode master mutex to keep someone from creating</a>
<a name="ln4801">	// a vnode while we're figuring out if we can continue</a>
<a name="ln4802">	fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln4803"> </a>
<a name="ln4804">	bool disconnectedDescriptors = false;</a>
<a name="ln4805"> </a>
<a name="ln4806">	while (true) {</a>
<a name="ln4807">		bool busy = false;</a>
<a name="ln4808"> </a>
<a name="ln4809">		// cycle through the list of vnodes associated with this mount and</a>
<a name="ln4810">		// make sure all of them are not busy or have refs on them</a>
<a name="ln4811">		vnode = NULL;</a>
<a name="ln4812">		while ((vnode = (struct vnode *)list_get_next_item(&amp;mount-&gt;vnodes, vnode)) != NULL) {</a>
<a name="ln4813">			// The root vnode ref_count needs to be 2 here: one for the file</a>
<a name="ln4814">			// system, one from the path_to_vnode() call above</a>
<a name="ln4815">			if (vnode-&gt;busy</a>
<a name="ln4816">				|| ((vnode-&gt;ref_count != 0 &amp;&amp; mount-&gt;root_vnode != vnode)</a>
<a name="ln4817">					|| (vnode-&gt;ref_count != 2 &amp;&amp; mount-&gt;root_vnode == vnode))) {</a>
<a name="ln4818">				// there are still vnodes in use on this mount, so we cannot</a>
<a name="ln4819">				// unmount yet</a>
<a name="ln4820">				busy = true;</a>
<a name="ln4821">				break;</a>
<a name="ln4822">			}</a>
<a name="ln4823">		}</a>
<a name="ln4824"> </a>
<a name="ln4825">		if (!busy)</a>
<a name="ln4826">			break;</a>
<a name="ln4827"> </a>
<a name="ln4828">		if ((flags &amp; FSSH_B_FORCE_UNMOUNT) == 0) {</a>
<a name="ln4829">			fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln4830">			put_vnode(mount-&gt;root_vnode);</a>
<a name="ln4831"> </a>
<a name="ln4832">			return FSSH_B_BUSY;</a>
<a name="ln4833">		}</a>
<a name="ln4834"> </a>
<a name="ln4835">		if (disconnectedDescriptors) {</a>
<a name="ln4836">			// wait a bit until the last access is finished, and then try again</a>
<a name="ln4837">			fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln4838">			fssh_snooze(100000);</a>
<a name="ln4839">			// TODO: if there is some kind of bug that prevents the ref counts</a>
<a name="ln4840">			//	from getting back to zero, this will fall into an endless loop...</a>
<a name="ln4841">			fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln4842">			continue;</a>
<a name="ln4843">		}</a>
<a name="ln4844"> </a>
<a name="ln4845">		// the file system is still busy - but we're forced to unmount it,</a>
<a name="ln4846">		// so let's disconnect all open file descriptors</a>
<a name="ln4847"> </a>
<a name="ln4848">		mount-&gt;unmounting = true;</a>
<a name="ln4849">			// prevent new vnodes from being created</a>
<a name="ln4850"> </a>
<a name="ln4851">		fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln4852"> </a>
<a name="ln4853">		disconnect_mount_or_vnode_fds(mount, NULL);</a>
<a name="ln4854">		disconnectedDescriptors = true;</a>
<a name="ln4855"> </a>
<a name="ln4856">		fssh_mutex_lock(&amp;sVnodeMutex);</a>
<a name="ln4857">	}</a>
<a name="ln4858"> </a>
<a name="ln4859">	// we can safely continue, mark all of the vnodes busy and this mount</a>
<a name="ln4860">	// structure in unmounting state</a>
<a name="ln4861">	mount-&gt;unmounting = true;</a>
<a name="ln4862"> </a>
<a name="ln4863">	while ((vnode = (struct vnode *)list_get_next_item(&amp;mount-&gt;vnodes, vnode)) != NULL) {</a>
<a name="ln4864">		vnode-&gt;busy = true;</a>
<a name="ln4865"> </a>
<a name="ln4866">		if (vnode-&gt;ref_count == 0) {</a>
<a name="ln4867">			// this vnode has been unused before</a>
<a name="ln4868">			list_remove_item(&amp;sUnusedVnodeList, vnode);</a>
<a name="ln4869">			sUnusedVnodes--;</a>
<a name="ln4870">		}</a>
<a name="ln4871">	}</a>
<a name="ln4872"> </a>
<a name="ln4873">	// The ref_count of the root node is 2 at this point, see above why this is</a>
<a name="ln4874">	mount-&gt;root_vnode-&gt;ref_count -= 2;</a>
<a name="ln4875"> </a>
<a name="ln4876">	fssh_mutex_unlock(&amp;sVnodeMutex);</a>
<a name="ln4877"> </a>
<a name="ln4878">	fssh_mutex_lock(&amp;sVnodeCoveredByMutex);</a>
<a name="ln4879">	mount-&gt;covers_vnode-&gt;covered_by = NULL;</a>
<a name="ln4880">	fssh_mutex_unlock(&amp;sVnodeCoveredByMutex);</a>
<a name="ln4881">	put_vnode(mount-&gt;covers_vnode);</a>
<a name="ln4882"> </a>
<a name="ln4883">	// Free all vnodes associated with this mount.</a>
<a name="ln4884">	// They will be removed from the mount list by free_vnode(), so</a>
<a name="ln4885">	// we don't have to do this.</a>
<a name="ln4886">	while ((vnode = (struct vnode *)list_get_first_item(&amp;mount-&gt;vnodes)) != NULL) {</a>
<a name="ln4887">		free_vnode(vnode, false);</a>
<a name="ln4888">	}</a>
<a name="ln4889"> </a>
<a name="ln4890">	// remove the mount structure from the hash table</a>
<a name="ln4891">	fssh_mutex_lock(&amp;sMountMutex);</a>
<a name="ln4892">	hash_remove(sMountsTable, mount);</a>
<a name="ln4893">	fssh_mutex_unlock(&amp;sMountMutex);</a>
<a name="ln4894"> </a>
<a name="ln4895">	mountOpLocker.Unlock();</a>
<a name="ln4896"> </a>
<a name="ln4897">	FS_MOUNT_CALL_NO_PARAMS(mount, unmount);</a>
<a name="ln4898"> </a>
<a name="ln4899">	// release the file system</a>
<a name="ln4900">	put_file_system(mount-&gt;fs);</a>
<a name="ln4901"> </a>
<a name="ln4902">	free(mount-&gt;device_name);</a>
<a name="ln4903">	free(mount-&gt;fs_name);</a>
<a name="ln4904">	free(mount);</a>
<a name="ln4905"> </a>
<a name="ln4906">	return FSSH_B_OK;</a>
<a name="ln4907">}</a>
<a name="ln4908"> </a>
<a name="ln4909"> </a>
<a name="ln4910">static fssh_status_t</a>
<a name="ln4911">fs_sync(fssh_dev_t device)</a>
<a name="ln4912">{</a>
<a name="ln4913">	struct fs_mount *mount;</a>
<a name="ln4914">	fssh_status_t status = get_mount(device, &amp;mount);</a>
<a name="ln4915">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4916">		return status;</a>
<a name="ln4917"> </a>
<a name="ln4918">	fssh_mutex_lock(&amp;sMountMutex);</a>
<a name="ln4919"> </a>
<a name="ln4920">	if (HAS_FS_MOUNT_CALL(mount, sync))</a>
<a name="ln4921">		status = FS_MOUNT_CALL_NO_PARAMS(mount, sync);</a>
<a name="ln4922"> </a>
<a name="ln4923">	fssh_mutex_unlock(&amp;sMountMutex);</a>
<a name="ln4924"> </a>
<a name="ln4925">	struct vnode *previousVnode = NULL;</a>
<a name="ln4926">	while (true) {</a>
<a name="ln4927">		// synchronize access to vnode list</a>
<a name="ln4928">		fssh_recursive_lock_lock(&amp;mount-&gt;rlock);</a>
<a name="ln4929"> </a>
<a name="ln4930">		struct vnode *vnode = (struct vnode *)list_get_next_item(&amp;mount-&gt;vnodes,</a>
<a name="ln4931">			previousVnode);</a>
<a name="ln4932"> </a>
<a name="ln4933">		fssh_vnode_id id = -1;</a>
<a name="ln4934">		if (vnode != NULL)</a>
<a name="ln4935">			id = vnode-&gt;id;</a>
<a name="ln4936"> </a>
<a name="ln4937">		fssh_recursive_lock_unlock(&amp;mount-&gt;rlock);</a>
<a name="ln4938"> </a>
<a name="ln4939">		if (vnode == NULL)</a>
<a name="ln4940">			break;</a>
<a name="ln4941"> </a>
<a name="ln4942">		// acquire a reference to the vnode</a>
<a name="ln4943"> </a>
<a name="ln4944">		if (get_vnode(mount-&gt;id, id, &amp;vnode, true) == FSSH_B_OK) {</a>
<a name="ln4945">			if (previousVnode != NULL)</a>
<a name="ln4946">				put_vnode(previousVnode);</a>
<a name="ln4947"> </a>
<a name="ln4948">			if (HAS_FS_CALL(vnode, fsync))</a>
<a name="ln4949">				FS_CALL_NO_PARAMS(vnode, fsync);</a>
<a name="ln4950"> </a>
<a name="ln4951">			// the next vnode might change until we lock the vnode list again,</a>
<a name="ln4952">			// but this vnode won't go away since we keep a reference to it.</a>
<a name="ln4953">			previousVnode = vnode;</a>
<a name="ln4954">		} else {</a>
<a name="ln4955">			fssh_dprintf(&quot;syncing of mount %d stopped due to vnode %&quot;</a>
<a name="ln4956">				FSSH_B_PRIdINO &quot;.\n&quot;, (int)mount-&gt;id, id);</a>
<a name="ln4957">			break;</a>
<a name="ln4958">		}</a>
<a name="ln4959">	}</a>
<a name="ln4960"> </a>
<a name="ln4961">	if (previousVnode != NULL)</a>
<a name="ln4962">		put_vnode(previousVnode);</a>
<a name="ln4963"> </a>
<a name="ln4964">	put_mount(mount);</a>
<a name="ln4965">	return status;</a>
<a name="ln4966">}</a>
<a name="ln4967"> </a>
<a name="ln4968"> </a>
<a name="ln4969">static fssh_status_t</a>
<a name="ln4970">fs_read_info(fssh_dev_t device, struct fssh_fs_info *info)</a>
<a name="ln4971">{</a>
<a name="ln4972">	struct fs_mount *mount;</a>
<a name="ln4973">	fssh_status_t status = get_mount(device, &amp;mount);</a>
<a name="ln4974">	if (status &lt; FSSH_B_OK)</a>
<a name="ln4975">		return status;</a>
<a name="ln4976"> </a>
<a name="ln4977">	fssh_memset(info, 0, sizeof(struct fssh_fs_info));</a>
<a name="ln4978"> </a>
<a name="ln4979">	if (HAS_FS_MOUNT_CALL(mount, read_fs_info))</a>
<a name="ln4980">		status = FS_MOUNT_CALL(mount, read_fs_info, info);</a>
<a name="ln4981"> </a>
<a name="ln4982">	// fill in info the file system doesn't (have to) know about</a>
<a name="ln4983">	if (status == FSSH_B_OK) {</a>
<a name="ln4984">		info-&gt;dev = mount-&gt;id;</a>
<a name="ln4985">		info-&gt;root = mount-&gt;root_vnode-&gt;id;</a>
<a name="ln4986">		fssh_strlcpy(info-&gt;fsh_name, mount-&gt;fs_name, sizeof(info-&gt;fsh_name));</a>
<a name="ln4987">		if (mount-&gt;device_name != NULL) {</a>
<a name="ln4988">			fssh_strlcpy(info-&gt;device_name, mount-&gt;device_name,</a>
<a name="ln4989">				sizeof(info-&gt;device_name));</a>
<a name="ln4990">		}</a>
<a name="ln4991">	}</a>
<a name="ln4992"> </a>
<a name="ln4993">	// if the call is not supported by the file system, there are still</a>
<a name="ln4994">	// the parts that we filled out ourselves</a>
<a name="ln4995"> </a>
<a name="ln4996">	put_mount(mount);</a>
<a name="ln4997">	return status;</a>
<a name="ln4998">}</a>
<a name="ln4999"> </a>
<a name="ln5000"> </a>
<a name="ln5001">static fssh_status_t</a>
<a name="ln5002">fs_write_info(fssh_dev_t device, const struct fssh_fs_info *info, int mask)</a>
<a name="ln5003">{</a>
<a name="ln5004">	struct fs_mount *mount;</a>
<a name="ln5005">	fssh_status_t status = get_mount(device, &amp;mount);</a>
<a name="ln5006">	if (status &lt; FSSH_B_OK)</a>
<a name="ln5007">		return status;</a>
<a name="ln5008"> </a>
<a name="ln5009">	if (HAS_FS_MOUNT_CALL(mount, write_fs_info))</a>
<a name="ln5010">		status = FS_MOUNT_CALL(mount, write_fs_info, info, mask);</a>
<a name="ln5011">	else</a>
<a name="ln5012">		status = FSSH_EROFS;</a>
<a name="ln5013"> </a>
<a name="ln5014">	put_mount(mount);</a>
<a name="ln5015">	return status;</a>
<a name="ln5016">}</a>
<a name="ln5017"> </a>
<a name="ln5018"> </a>
<a name="ln5019">static fssh_dev_t</a>
<a name="ln5020">fs_next_device(int32_t *_cookie)</a>
<a name="ln5021">{</a>
<a name="ln5022">	struct fs_mount *mount = NULL;</a>
<a name="ln5023">	fssh_dev_t device = *_cookie;</a>
<a name="ln5024"> </a>
<a name="ln5025">	fssh_mutex_lock(&amp;sMountMutex);</a>
<a name="ln5026"> </a>
<a name="ln5027">	// Since device IDs are assigned sequentially, this algorithm</a>
<a name="ln5028">	// does work good enough. It makes sure that the device list</a>
<a name="ln5029">	// returned is sorted, and that no device is skipped when an</a>
<a name="ln5030">	// already visited device got unmounted.</a>
<a name="ln5031"> </a>
<a name="ln5032">	while (device &lt; sNextMountID) {</a>
<a name="ln5033">		mount = find_mount(device++);</a>
<a name="ln5034">		if (mount != NULL &amp;&amp; mount-&gt;volume-&gt;private_volume != NULL)</a>
<a name="ln5035">			break;</a>
<a name="ln5036">	}</a>
<a name="ln5037"> </a>
<a name="ln5038">	*_cookie = device;</a>
<a name="ln5039"> </a>
<a name="ln5040">	if (mount != NULL)</a>
<a name="ln5041">		device = mount-&gt;id;</a>
<a name="ln5042">	else</a>
<a name="ln5043">		device = FSSH_B_BAD_VALUE;</a>
<a name="ln5044"> </a>
<a name="ln5045">	fssh_mutex_unlock(&amp;sMountMutex);</a>
<a name="ln5046"> </a>
<a name="ln5047">	return device;</a>
<a name="ln5048">}</a>
<a name="ln5049"> </a>
<a name="ln5050"> </a>
<a name="ln5051">static fssh_status_t</a>
<a name="ln5052">get_cwd(char *buffer, fssh_size_t size, bool kernel)</a>
<a name="ln5053">{</a>
<a name="ln5054">	// Get current working directory from io context</a>
<a name="ln5055">	struct io_context *context = get_current_io_context(kernel);</a>
<a name="ln5056">	fssh_status_t status;</a>
<a name="ln5057"> </a>
<a name="ln5058">	FUNCTION((&quot;vfs_get_cwd: buf %p, size %ld\n&quot;, buffer, size));</a>
<a name="ln5059"> </a>
<a name="ln5060">	fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln5061"> </a>
<a name="ln5062">	if (context-&gt;cwd)</a>
<a name="ln5063">		status = dir_vnode_to_path(context-&gt;cwd, buffer, size);</a>
<a name="ln5064">	else</a>
<a name="ln5065">		status = FSSH_B_ERROR;</a>
<a name="ln5066"> </a>
<a name="ln5067">	fssh_mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln5068">	return status;</a>
<a name="ln5069">}</a>
<a name="ln5070"> </a>
<a name="ln5071"> </a>
<a name="ln5072">static fssh_status_t</a>
<a name="ln5073">set_cwd(int fd, char *path, bool kernel)</a>
<a name="ln5074">{</a>
<a name="ln5075">	struct io_context *context;</a>
<a name="ln5076">	struct vnode *vnode = NULL;</a>
<a name="ln5077">	struct vnode *oldDirectory;</a>
<a name="ln5078">	struct fssh_stat stat;</a>
<a name="ln5079">	fssh_status_t status;</a>
<a name="ln5080"> </a>
<a name="ln5081">	FUNCTION((&quot;set_cwd: path = \'%s\'\n&quot;, path));</a>
<a name="ln5082"> </a>
<a name="ln5083">	// Get vnode for passed path, and bail if it failed</a>
<a name="ln5084">	status = fd_and_path_to_vnode(fd, path, true, &amp;vnode, NULL, kernel);</a>
<a name="ln5085">	if (status &lt; 0)</a>
<a name="ln5086">		return status;</a>
<a name="ln5087"> </a>
<a name="ln5088">	status = FS_CALL(vnode, read_stat, &amp;stat);</a>
<a name="ln5089">	if (status &lt; 0)</a>
<a name="ln5090">		goto err;</a>
<a name="ln5091"> </a>
<a name="ln5092">	if (!FSSH_S_ISDIR(stat.fssh_st_mode)) {</a>
<a name="ln5093">		// nope, can't cwd to here</a>
<a name="ln5094">		status = FSSH_B_NOT_A_DIRECTORY;</a>
<a name="ln5095">		goto err;</a>
<a name="ln5096">	}</a>
<a name="ln5097"> </a>
<a name="ln5098">	// Get current io context and lock</a>
<a name="ln5099">	context = get_current_io_context(kernel);</a>
<a name="ln5100">	fssh_mutex_lock(&amp;context-&gt;io_mutex);</a>
<a name="ln5101"> </a>
<a name="ln5102">	// save the old current working directory first</a>
<a name="ln5103">	oldDirectory = context-&gt;cwd;</a>
<a name="ln5104">	context-&gt;cwd = vnode;</a>
<a name="ln5105"> </a>
<a name="ln5106">	fssh_mutex_unlock(&amp;context-&gt;io_mutex);</a>
<a name="ln5107"> </a>
<a name="ln5108">	if (oldDirectory)</a>
<a name="ln5109">		put_vnode(oldDirectory);</a>
<a name="ln5110"> </a>
<a name="ln5111">	return FSSH_B_NO_ERROR;</a>
<a name="ln5112"> </a>
<a name="ln5113">err:</a>
<a name="ln5114">	put_vnode(vnode);</a>
<a name="ln5115">	return status;</a>
<a name="ln5116">}</a>
<a name="ln5117"> </a>
<a name="ln5118"> </a>
<a name="ln5119">//	#pragma mark -</a>
<a name="ln5120">//	Calls from within the kernel</a>
<a name="ln5121"> </a>
<a name="ln5122"> </a>
<a name="ln5123">fssh_dev_t</a>
<a name="ln5124">_kern_mount(const char *path, const char *device, const char *fsName,</a>
<a name="ln5125">	uint32_t flags, const char *args, fssh_size_t argsLength)</a>
<a name="ln5126">{</a>
<a name="ln5127">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5128">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5129">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5130"> </a>
<a name="ln5131">	return fs_mount(pathBuffer.LockBuffer(), device, fsName, flags, args, true);</a>
<a name="ln5132">}</a>
<a name="ln5133"> </a>
<a name="ln5134"> </a>
<a name="ln5135">fssh_status_t</a>
<a name="ln5136">_kern_unmount(const char *path, uint32_t flags)</a>
<a name="ln5137">{</a>
<a name="ln5138">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5139">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5140">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5141"> </a>
<a name="ln5142">	return fs_unmount(pathBuffer.LockBuffer(), flags, true);</a>
<a name="ln5143">}</a>
<a name="ln5144"> </a>
<a name="ln5145"> </a>
<a name="ln5146">fssh_status_t</a>
<a name="ln5147">_kern_read_fs_info(fssh_dev_t device, struct fssh_fs_info *info)</a>
<a name="ln5148">{</a>
<a name="ln5149">	if (info == NULL)</a>
<a name="ln5150">		return FSSH_B_BAD_VALUE;</a>
<a name="ln5151"> </a>
<a name="ln5152">	return fs_read_info(device, info);</a>
<a name="ln5153">}</a>
<a name="ln5154"> </a>
<a name="ln5155"> </a>
<a name="ln5156">fssh_status_t</a>
<a name="ln5157">_kern_write_fs_info(fssh_dev_t device, const struct fssh_fs_info *info, int mask)</a>
<a name="ln5158">{</a>
<a name="ln5159">	if (info == NULL)</a>
<a name="ln5160">		return FSSH_B_BAD_VALUE;</a>
<a name="ln5161"> </a>
<a name="ln5162">	return fs_write_info(device, info, mask);</a>
<a name="ln5163">}</a>
<a name="ln5164"> </a>
<a name="ln5165"> </a>
<a name="ln5166">fssh_status_t</a>
<a name="ln5167">_kern_sync(void)</a>
<a name="ln5168">{</a>
<a name="ln5169">	// Note: _kern_sync() is also called from _user_sync()</a>
<a name="ln5170">	int32_t cookie = 0;</a>
<a name="ln5171">	fssh_dev_t device;</a>
<a name="ln5172">	while ((device = fs_next_device(&amp;cookie)) &gt;= 0) {</a>
<a name="ln5173">		fssh_status_t status = fs_sync(device);</a>
<a name="ln5174">		if (status != FSSH_B_OK &amp;&amp; status != FSSH_B_BAD_VALUE)</a>
<a name="ln5175">			fssh_dprintf(&quot;sync: device %d couldn't sync: %s\n&quot;, (int)device, fssh_strerror(status));</a>
<a name="ln5176">	}</a>
<a name="ln5177"> </a>
<a name="ln5178">	return FSSH_B_OK;</a>
<a name="ln5179">}</a>
<a name="ln5180"> </a>
<a name="ln5181"> </a>
<a name="ln5182">fssh_dev_t</a>
<a name="ln5183">_kern_next_device(int32_t *_cookie)</a>
<a name="ln5184">{</a>
<a name="ln5185">	return fs_next_device(_cookie);</a>
<a name="ln5186">}</a>
<a name="ln5187"> </a>
<a name="ln5188"> </a>
<a name="ln5189">int</a>
<a name="ln5190">_kern_open_entry_ref(fssh_dev_t device, fssh_ino_t inode, const char *name, int openMode, int perms)</a>
<a name="ln5191">{</a>
<a name="ln5192">	if (openMode &amp; FSSH_O_CREAT)</a>
<a name="ln5193">		return file_create_entry_ref(device, inode, name, openMode, perms, true);</a>
<a name="ln5194"> </a>
<a name="ln5195">	return file_open_entry_ref(device, inode, name, openMode, true);</a>
<a name="ln5196">}</a>
<a name="ln5197"> </a>
<a name="ln5198"> </a>
<a name="ln5199">/**	\brief Opens a node specified by a FD + path pair.</a>
<a name="ln5200"> *</a>
<a name="ln5201"> *	At least one of \a fd and \a path must be specified.</a>
<a name="ln5202"> *	If only \a fd is given, the function opens the node identified by this</a>
<a name="ln5203"> *	FD. If only a path is given, this path is opened. If both are given and</a>
<a name="ln5204"> *	the path is absolute, \a fd is ignored; a relative path is reckoned off</a>
<a name="ln5205"> *	of the directory (!) identified by \a fd.</a>
<a name="ln5206"> *</a>
<a name="ln5207"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln5208"> *	\param path The absolute or relative path. May be \c NULL.</a>
<a name="ln5209"> *	\param openMode The open mode.</a>
<a name="ln5210"> *	\return A FD referring to the newly opened node, or an error code,</a>
<a name="ln5211"> *			if an error occurs.</a>
<a name="ln5212"> */</a>
<a name="ln5213"> </a>
<a name="ln5214">int</a>
<a name="ln5215">_kern_open(int fd, const char *path, int openMode, int perms)</a>
<a name="ln5216">{</a>
<a name="ln5217">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5218">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5219">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5220"> </a>
<a name="ln5221">	if (openMode &amp; FSSH_O_CREAT)</a>
<a name="ln5222">		return file_create(fd, pathBuffer.LockBuffer(), openMode, perms, true);</a>
<a name="ln5223"> </a>
<a name="ln5224">	return file_open(fd, pathBuffer.LockBuffer(), openMode, true);</a>
<a name="ln5225">}</a>
<a name="ln5226"> </a>
<a name="ln5227"> </a>
<a name="ln5228">/**	\brief Opens a directory specified by entry_ref or node_ref.</a>
<a name="ln5229"> *</a>
<a name="ln5230"> *	The supplied name may be \c NULL, in which case directory identified</a>
<a name="ln5231"> *	by \a device and \a inode will be opened. Otherwise \a device and</a>
<a name="ln5232"> *	\a inode identify the parent directory of the directory to be opened</a>
<a name="ln5233"> *	and \a name its entry name.</a>
<a name="ln5234"> *</a>
<a name="ln5235"> *	\param device If \a name is specified the ID of the device the parent</a>
<a name="ln5236"> *		   directory of the directory to be opened resides on, otherwise</a>
<a name="ln5237"> *		   the device of the directory itself.</a>
<a name="ln5238"> *	\param inode If \a name is specified the node ID of the parent</a>
<a name="ln5239"> *		   directory of the directory to be opened, otherwise node ID of the</a>
<a name="ln5240"> *		   directory itself.</a>
<a name="ln5241"> *	\param name The entry name of the directory to be opened. If \c NULL,</a>
<a name="ln5242"> *		   the \a device + \a inode pair identify the node to be opened.</a>
<a name="ln5243"> *	\return The FD of the newly opened directory or an error code, if</a>
<a name="ln5244"> *			something went wrong.</a>
<a name="ln5245"> */</a>
<a name="ln5246"> </a>
<a name="ln5247">int</a>
<a name="ln5248">_kern_open_dir_entry_ref(fssh_dev_t device, fssh_ino_t inode, const char *name)</a>
<a name="ln5249">{</a>
<a name="ln5250">	return dir_open_entry_ref(device, inode, name, true);</a>
<a name="ln5251">}</a>
<a name="ln5252"> </a>
<a name="ln5253"> </a>
<a name="ln5254">/**	\brief Opens a directory specified by a FD + path pair.</a>
<a name="ln5255"> *</a>
<a name="ln5256"> *	At least one of \a fd and \a path must be specified.</a>
<a name="ln5257"> *	If only \a fd is given, the function opens the directory identified by this</a>
<a name="ln5258"> *	FD. If only a path is given, this path is opened. If both are given and</a>
<a name="ln5259"> *	the path is absolute, \a fd is ignored; a relative path is reckoned off</a>
<a name="ln5260"> *	of the directory (!) identified by \a fd.</a>
<a name="ln5261"> *</a>
<a name="ln5262"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln5263"> *	\param path The absolute or relative path. May be \c NULL.</a>
<a name="ln5264"> *	\return A FD referring to the newly opened directory, or an error code,</a>
<a name="ln5265"> *			if an error occurs.</a>
<a name="ln5266"> */</a>
<a name="ln5267"> </a>
<a name="ln5268">int</a>
<a name="ln5269">_kern_open_dir(int fd, const char *path)</a>
<a name="ln5270">{</a>
<a name="ln5271">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5272">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5273">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5274"> </a>
<a name="ln5275">	return dir_open(fd, pathBuffer.LockBuffer(), true);</a>
<a name="ln5276">}</a>
<a name="ln5277"> </a>
<a name="ln5278"> </a>
<a name="ln5279">fssh_status_t</a>
<a name="ln5280">_kern_fcntl(int fd, int op, uint32_t argument)</a>
<a name="ln5281">{</a>
<a name="ln5282">	return common_fcntl(fd, op, argument, true);</a>
<a name="ln5283">}</a>
<a name="ln5284"> </a>
<a name="ln5285"> </a>
<a name="ln5286">fssh_status_t</a>
<a name="ln5287">_kern_fsync(int fd)</a>
<a name="ln5288">{</a>
<a name="ln5289">	return common_sync(fd, true);</a>
<a name="ln5290">}</a>
<a name="ln5291"> </a>
<a name="ln5292"> </a>
<a name="ln5293">fssh_status_t</a>
<a name="ln5294">_kern_lock_node(int fd)</a>
<a name="ln5295">{</a>
<a name="ln5296">	return common_lock_node(fd, true);</a>
<a name="ln5297">}</a>
<a name="ln5298"> </a>
<a name="ln5299"> </a>
<a name="ln5300">fssh_status_t</a>
<a name="ln5301">_kern_unlock_node(int fd)</a>
<a name="ln5302">{</a>
<a name="ln5303">	return common_unlock_node(fd, true);</a>
<a name="ln5304">}</a>
<a name="ln5305"> </a>
<a name="ln5306"> </a>
<a name="ln5307">fssh_status_t</a>
<a name="ln5308">_kern_create_dir_entry_ref(fssh_dev_t device, fssh_ino_t inode, const char *name, int perms)</a>
<a name="ln5309">{</a>
<a name="ln5310">	return dir_create_entry_ref(device, inode, name, perms, true);</a>
<a name="ln5311">}</a>
<a name="ln5312"> </a>
<a name="ln5313"> </a>
<a name="ln5314">/**	\brief Creates a directory specified by a FD + path pair.</a>
<a name="ln5315"> *</a>
<a name="ln5316"> *	\a path must always be specified (it contains the name of the new directory</a>
<a name="ln5317"> *	at least). If only a path is given, this path identifies the location at</a>
<a name="ln5318"> *	which the directory shall be created. If both \a fd and \a path are given and</a>
<a name="ln5319"> *	the path is absolute, \a fd is ignored; a relative path is reckoned off</a>
<a name="ln5320"> *	of the directory (!) identified by \a fd.</a>
<a name="ln5321"> *</a>
<a name="ln5322"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln5323"> *	\param path The absolute or relative path. Must not be \c NULL.</a>
<a name="ln5324"> *	\param perms The access permissions the new directory shall have.</a>
<a name="ln5325"> *	\return \c FSSH_B_OK, if the directory has been created successfully, another</a>
<a name="ln5326"> *			error code otherwise.</a>
<a name="ln5327"> */</a>
<a name="ln5328"> </a>
<a name="ln5329">fssh_status_t</a>
<a name="ln5330">_kern_create_dir(int fd, const char *path, int perms)</a>
<a name="ln5331">{</a>
<a name="ln5332">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5333">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5334">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5335"> </a>
<a name="ln5336">	return dir_create(fd, pathBuffer.LockBuffer(), perms, true);</a>
<a name="ln5337">}</a>
<a name="ln5338"> </a>
<a name="ln5339"> </a>
<a name="ln5340">fssh_status_t</a>
<a name="ln5341">_kern_remove_dir(int fd, const char *path)</a>
<a name="ln5342">{</a>
<a name="ln5343">	if (path) {</a>
<a name="ln5344">		KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5345">		if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5346">			return FSSH_B_NO_MEMORY;</a>
<a name="ln5347"> </a>
<a name="ln5348">		return dir_remove(fd, pathBuffer.LockBuffer(), true);</a>
<a name="ln5349">	}</a>
<a name="ln5350"> </a>
<a name="ln5351">	return dir_remove(fd, NULL, true);</a>
<a name="ln5352">}</a>
<a name="ln5353"> </a>
<a name="ln5354"> </a>
<a name="ln5355">/**	\brief Reads the contents of a symlink referred to by a FD + path pair.</a>
<a name="ln5356"> *</a>
<a name="ln5357"> *	At least one of \a fd and \a path must be specified.</a>
<a name="ln5358"> *	If only \a fd is given, the function the symlink to be read is the node</a>
<a name="ln5359"> *	identified by this FD. If only a path is given, this path identifies the</a>
<a name="ln5360"> *	symlink to be read. If both are given and the path is absolute, \a fd is</a>
<a name="ln5361"> *	ignored; a relative path is reckoned off of the directory (!) identified</a>
<a name="ln5362"> *	by \a fd.</a>
<a name="ln5363"> *	If this function fails with FSSH_B_BUFFER_OVERFLOW, the \a _bufferSize pointer</a>
<a name="ln5364"> *	will still be updated to reflect the required buffer size.</a>
<a name="ln5365"> *</a>
<a name="ln5366"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln5367"> *	\param path The absolute or relative path. May be \c NULL.</a>
<a name="ln5368"> *	\param buffer The buffer into which the contents of the symlink shall be</a>
<a name="ln5369"> *		   written.</a>
<a name="ln5370"> *	\param _bufferSize A pointer to the size of the supplied buffer.</a>
<a name="ln5371"> *	\return The length of the link on success or an appropriate error code</a>
<a name="ln5372"> */</a>
<a name="ln5373"> </a>
<a name="ln5374">fssh_status_t</a>
<a name="ln5375">_kern_read_link(int fd, const char *path, char *buffer, fssh_size_t *_bufferSize)</a>
<a name="ln5376">{</a>
<a name="ln5377">	if (path) {</a>
<a name="ln5378">		KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5379">		if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5380">			return FSSH_B_NO_MEMORY;</a>
<a name="ln5381"> </a>
<a name="ln5382">		return common_read_link(fd, pathBuffer.LockBuffer(),</a>
<a name="ln5383">			buffer, _bufferSize, true);</a>
<a name="ln5384">	}</a>
<a name="ln5385"> </a>
<a name="ln5386">	return common_read_link(fd, NULL, buffer, _bufferSize, true);</a>
<a name="ln5387">}</a>
<a name="ln5388"> </a>
<a name="ln5389"> </a>
<a name="ln5390">/**	\brief Creates a symlink specified by a FD + path pair.</a>
<a name="ln5391"> *</a>
<a name="ln5392"> *	\a path must always be specified (it contains the name of the new symlink</a>
<a name="ln5393"> *	at least). If only a path is given, this path identifies the location at</a>
<a name="ln5394"> *	which the symlink shall be created. If both \a fd and \a path are given and</a>
<a name="ln5395"> *	the path is absolute, \a fd is ignored; a relative path is reckoned off</a>
<a name="ln5396"> *	of the directory (!) identified by \a fd.</a>
<a name="ln5397"> *</a>
<a name="ln5398"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln5399"> *	\param toPath The absolute or relative path. Must not be \c NULL.</a>
<a name="ln5400"> *	\param mode The access permissions the new symlink shall have.</a>
<a name="ln5401"> *	\return \c FSSH_B_OK, if the symlink has been created successfully, another</a>
<a name="ln5402"> *			error code otherwise.</a>
<a name="ln5403"> */</a>
<a name="ln5404"> </a>
<a name="ln5405">fssh_status_t</a>
<a name="ln5406">_kern_create_symlink(int fd, const char *path, const char *toPath, int mode)</a>
<a name="ln5407">{</a>
<a name="ln5408">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5409">	KPath toPathBuffer(toPath, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5410">	if (pathBuffer.InitCheck() != FSSH_B_OK || toPathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5411">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5412"> </a>
<a name="ln5413">	char *toBuffer = toPathBuffer.LockBuffer();</a>
<a name="ln5414"> </a>
<a name="ln5415">	fssh_status_t status = check_path(toBuffer);</a>
<a name="ln5416">	if (status &lt; FSSH_B_OK)</a>
<a name="ln5417">		return status;</a>
<a name="ln5418"> </a>
<a name="ln5419">	return common_create_symlink(fd, pathBuffer.LockBuffer(),</a>
<a name="ln5420">		toBuffer, mode, true);</a>
<a name="ln5421">}</a>
<a name="ln5422"> </a>
<a name="ln5423"> </a>
<a name="ln5424">fssh_status_t</a>
<a name="ln5425">_kern_create_link(const char *path, const char *toPath)</a>
<a name="ln5426">{</a>
<a name="ln5427">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5428">	KPath toPathBuffer(toPath, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5429">	if (pathBuffer.InitCheck() != FSSH_B_OK || toPathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5430">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5431"> </a>
<a name="ln5432">	return common_create_link(pathBuffer.LockBuffer(),</a>
<a name="ln5433">		toPathBuffer.LockBuffer(), true);</a>
<a name="ln5434">}</a>
<a name="ln5435"> </a>
<a name="ln5436"> </a>
<a name="ln5437">/**	\brief Removes an entry specified by a FD + path pair from its directory.</a>
<a name="ln5438"> *</a>
<a name="ln5439"> *	\a path must always be specified (it contains at least the name of the entry</a>
<a name="ln5440"> *	to be deleted). If only a path is given, this path identifies the entry</a>
<a name="ln5441"> *	directly. If both \a fd and \a path are given and the path is absolute,</a>
<a name="ln5442"> *	\a fd is ignored; a relative path is reckoned off of the directory (!)</a>
<a name="ln5443"> *	identified by \a fd.</a>
<a name="ln5444"> *</a>
<a name="ln5445"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln5446"> *	\param path The absolute or relative path. Must not be \c NULL.</a>
<a name="ln5447"> *	\return \c FSSH_B_OK, if the entry has been removed successfully, another</a>
<a name="ln5448"> *			error code otherwise.</a>
<a name="ln5449"> */</a>
<a name="ln5450"> </a>
<a name="ln5451">fssh_status_t</a>
<a name="ln5452">_kern_unlink(int fd, const char *path)</a>
<a name="ln5453">{</a>
<a name="ln5454">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5455">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5456">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5457"> </a>
<a name="ln5458">	return common_unlink(fd, pathBuffer.LockBuffer(), true);</a>
<a name="ln5459">}</a>
<a name="ln5460"> </a>
<a name="ln5461"> </a>
<a name="ln5462">/**	\brief Moves an entry specified by a FD + path pair to a an entry specified</a>
<a name="ln5463"> *		   by another FD + path pair.</a>
<a name="ln5464"> *</a>
<a name="ln5465"> *	\a oldPath and \a newPath must always be specified (they contain at least</a>
<a name="ln5466"> *	the name of the entry). If only a path is given, this path identifies the</a>
<a name="ln5467"> *	entry directly. If both a FD and a path are given and the path is absolute,</a>
<a name="ln5468"> *	the FD is ignored; a relative path is reckoned off of the directory (!)</a>
<a name="ln5469"> *	identified by the respective FD.</a>
<a name="ln5470"> *</a>
<a name="ln5471"> *	\param oldFD The FD of the old location. May be &lt; 0.</a>
<a name="ln5472"> *	\param oldPath The absolute or relative path of the old location. Must not</a>
<a name="ln5473"> *		   be \c NULL.</a>
<a name="ln5474"> *	\param newFD The FD of the new location. May be &lt; 0.</a>
<a name="ln5475"> *	\param newPath The absolute or relative path of the new location. Must not</a>
<a name="ln5476"> *		   be \c NULL.</a>
<a name="ln5477"> *	\return \c FSSH_B_OK, if the entry has been moved successfully, another</a>
<a name="ln5478"> *			error code otherwise.</a>
<a name="ln5479"> */</a>
<a name="ln5480"> </a>
<a name="ln5481">fssh_status_t</a>
<a name="ln5482">_kern_rename(int oldFD, const char *oldPath, int newFD, const char *newPath)</a>
<a name="ln5483">{</a>
<a name="ln5484">	KPath oldPathBuffer(oldPath, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5485">	KPath newPathBuffer(newPath, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5486">	if (oldPathBuffer.InitCheck() != FSSH_B_OK || newPathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5487">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5488"> </a>
<a name="ln5489">	return common_rename(oldFD, oldPathBuffer.LockBuffer(),</a>
<a name="ln5490">		newFD, newPathBuffer.LockBuffer(), true);</a>
<a name="ln5491">}</a>
<a name="ln5492"> </a>
<a name="ln5493"> </a>
<a name="ln5494">fssh_status_t</a>
<a name="ln5495">_kern_access(const char *path, int mode)</a>
<a name="ln5496">{</a>
<a name="ln5497">	KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5498">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5499">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5500"> </a>
<a name="ln5501">	return common_access(pathBuffer.LockBuffer(), mode, true);</a>
<a name="ln5502">}</a>
<a name="ln5503"> </a>
<a name="ln5504"> </a>
<a name="ln5505">/**	\brief Reads stat data of an entity specified by a FD + path pair.</a>
<a name="ln5506"> *</a>
<a name="ln5507"> *	If only \a fd is given, the stat operation associated with the type</a>
<a name="ln5508"> *	of the FD (node, attr, attr dir etc.) is performed. If only \a path is</a>
<a name="ln5509"> *	given, this path identifies the entry for whose node to retrieve the</a>
<a name="ln5510"> *	stat data. If both \a fd and \a path are given and the path is absolute,</a>
<a name="ln5511"> *	\a fd is ignored; a relative path is reckoned off of the directory (!)</a>
<a name="ln5512"> *	identified by \a fd and specifies the entry whose stat data shall be</a>
<a name="ln5513"> *	retrieved.</a>
<a name="ln5514"> *</a>
<a name="ln5515"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln5516"> *	\param path The absolute or relative path. Must not be \c NULL.</a>
<a name="ln5517"> *	\param traverseLeafLink If \a path is given, \c true specifies that the</a>
<a name="ln5518"> *		   function shall not stick to symlinks, but traverse them.</a>
<a name="ln5519"> *	\param stat The buffer the stat data shall be written into.</a>
<a name="ln5520"> *	\param statSize The size of the supplied stat buffer.</a>
<a name="ln5521"> *	\return \c FSSH_B_OK, if the the stat data have been read successfully, another</a>
<a name="ln5522"> *			error code otherwise.</a>
<a name="ln5523"> */</a>
<a name="ln5524"> </a>
<a name="ln5525">fssh_status_t</a>
<a name="ln5526">_kern_read_stat(int fd, const char *path, bool traverseLeafLink,</a>
<a name="ln5527">	fssh_struct_stat *stat, fssh_size_t statSize)</a>
<a name="ln5528">{</a>
<a name="ln5529">	fssh_struct_stat completeStat;</a>
<a name="ln5530">	fssh_struct_stat *originalStat = NULL;</a>
<a name="ln5531">	fssh_status_t status;</a>
<a name="ln5532"> </a>
<a name="ln5533">	if (statSize &gt; sizeof(fssh_struct_stat))</a>
<a name="ln5534">		return FSSH_B_BAD_VALUE;</a>
<a name="ln5535"> </a>
<a name="ln5536">	// this supports different stat extensions</a>
<a name="ln5537">	if (statSize &lt; sizeof(fssh_struct_stat)) {</a>
<a name="ln5538">		originalStat = stat;</a>
<a name="ln5539">		stat = &amp;completeStat;</a>
<a name="ln5540">	}</a>
<a name="ln5541"> </a>
<a name="ln5542">	if (path) {</a>
<a name="ln5543">		// path given: get the stat of the node referred to by (fd, path)</a>
<a name="ln5544">		KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5545">		if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5546">			return FSSH_B_NO_MEMORY;</a>
<a name="ln5547"> </a>
<a name="ln5548">		status = common_path_read_stat(fd, pathBuffer.LockBuffer(),</a>
<a name="ln5549">			traverseLeafLink, stat, true);</a>
<a name="ln5550">	} else {</a>
<a name="ln5551">		// no path given: get the FD and use the FD operation</a>
<a name="ln5552">		struct file_descriptor *descriptor</a>
<a name="ln5553">			= get_fd(get_current_io_context(true), fd);</a>
<a name="ln5554">		if (descriptor == NULL)</a>
<a name="ln5555">			return FSSH_B_FILE_ERROR;</a>
<a name="ln5556"> </a>
<a name="ln5557">		if (descriptor-&gt;ops-&gt;fd_read_stat)</a>
<a name="ln5558">			status = descriptor-&gt;ops-&gt;fd_read_stat(descriptor, stat);</a>
<a name="ln5559">		else</a>
<a name="ln5560">			status = FSSH_EOPNOTSUPP;</a>
<a name="ln5561"> </a>
<a name="ln5562">		put_fd(descriptor);</a>
<a name="ln5563">	}</a>
<a name="ln5564"> </a>
<a name="ln5565">	if (status == FSSH_B_OK &amp;&amp; originalStat != NULL)</a>
<a name="ln5566">		fssh_memcpy(originalStat, stat, statSize);</a>
<a name="ln5567"> </a>
<a name="ln5568">	return status;</a>
<a name="ln5569">}</a>
<a name="ln5570"> </a>
<a name="ln5571"> </a>
<a name="ln5572">/**	\brief Writes stat data of an entity specified by a FD + path pair.</a>
<a name="ln5573"> *</a>
<a name="ln5574"> *	If only \a fd is given, the stat operation associated with the type</a>
<a name="ln5575"> *	of the FD (node, attr, attr dir etc.) is performed. If only \a path is</a>
<a name="ln5576"> *	given, this path identifies the entry for whose node to write the</a>
<a name="ln5577"> *	stat data. If both \a fd and \a path are given and the path is absolute,</a>
<a name="ln5578"> *	\a fd is ignored; a relative path is reckoned off of the directory (!)</a>
<a name="ln5579"> *	identified by \a fd and specifies the entry whose stat data shall be</a>
<a name="ln5580"> *	written.</a>
<a name="ln5581"> *</a>
<a name="ln5582"> *	\param fd The FD. May be &lt; 0.</a>
<a name="ln5583"> *	\param path The absolute or relative path. Must not be \c NULL.</a>
<a name="ln5584"> *	\param traverseLeafLink If \a path is given, \c true specifies that the</a>
<a name="ln5585"> *		   function shall not stick to symlinks, but traverse them.</a>
<a name="ln5586"> *	\param stat The buffer containing the stat data to be written.</a>
<a name="ln5587"> *	\param statSize The size of the supplied stat buffer.</a>
<a name="ln5588"> *	\param statMask A mask specifying which parts of the stat data shall be</a>
<a name="ln5589"> *		   written.</a>
<a name="ln5590"> *	\return \c FSSH_B_OK, if the the stat data have been written successfully,</a>
<a name="ln5591"> *			another error code otherwise.</a>
<a name="ln5592"> */</a>
<a name="ln5593"> </a>
<a name="ln5594">fssh_status_t</a>
<a name="ln5595">_kern_write_stat(int fd, const char *path, bool traverseLeafLink,</a>
<a name="ln5596">	const fssh_struct_stat *stat, fssh_size_t statSize, int statMask)</a>
<a name="ln5597">{</a>
<a name="ln5598">	fssh_struct_stat completeStat;</a>
<a name="ln5599"> </a>
<a name="ln5600">	if (statSize &gt; sizeof(fssh_struct_stat))</a>
<a name="ln5601">		return FSSH_B_BAD_VALUE;</a>
<a name="ln5602"> </a>
<a name="ln5603">	// this supports different stat extensions</a>
<a name="ln5604">	if (statSize &lt; sizeof(fssh_struct_stat)) {</a>
<a name="ln5605">		fssh_memset((uint8_t *)&amp;completeStat + statSize, 0, sizeof(fssh_struct_stat) - statSize);</a>
<a name="ln5606">		fssh_memcpy(&amp;completeStat, stat, statSize);</a>
<a name="ln5607">		stat = &amp;completeStat;</a>
<a name="ln5608">	}</a>
<a name="ln5609"> </a>
<a name="ln5610">	fssh_status_t status;</a>
<a name="ln5611"> </a>
<a name="ln5612">	if (path) {</a>
<a name="ln5613">		// path given: write the stat of the node referred to by (fd, path)</a>
<a name="ln5614">		KPath pathBuffer(path, false, FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5615">		if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5616">			return FSSH_B_NO_MEMORY;</a>
<a name="ln5617"> </a>
<a name="ln5618">		status = common_path_write_stat(fd, pathBuffer.LockBuffer(),</a>
<a name="ln5619">			traverseLeafLink, stat, statMask, true);</a>
<a name="ln5620">	} else {</a>
<a name="ln5621">		// no path given: get the FD and use the FD operation</a>
<a name="ln5622">		struct file_descriptor *descriptor</a>
<a name="ln5623">			= get_fd(get_current_io_context(true), fd);</a>
<a name="ln5624">		if (descriptor == NULL)</a>
<a name="ln5625">			return FSSH_B_FILE_ERROR;</a>
<a name="ln5626"> </a>
<a name="ln5627">		if (descriptor-&gt;ops-&gt;fd_write_stat)</a>
<a name="ln5628">			status = descriptor-&gt;ops-&gt;fd_write_stat(descriptor, stat, statMask);</a>
<a name="ln5629">		else</a>
<a name="ln5630">			status = FSSH_EOPNOTSUPP;</a>
<a name="ln5631"> </a>
<a name="ln5632">		put_fd(descriptor);</a>
<a name="ln5633">	}</a>
<a name="ln5634"> </a>
<a name="ln5635">	return status;</a>
<a name="ln5636">}</a>
<a name="ln5637"> </a>
<a name="ln5638"> </a>
<a name="ln5639">int</a>
<a name="ln5640">_kern_open_attr_dir(int fd, const char *path)</a>
<a name="ln5641">{</a>
<a name="ln5642">	KPath pathBuffer(FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5643">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5644">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5645"> </a>
<a name="ln5646">	if (path != NULL)</a>
<a name="ln5647">		pathBuffer.SetTo(path);</a>
<a name="ln5648"> </a>
<a name="ln5649">	return attr_dir_open(fd, path ? pathBuffer.LockBuffer() : NULL, true);</a>
<a name="ln5650">}</a>
<a name="ln5651"> </a>
<a name="ln5652"> </a>
<a name="ln5653">int</a>
<a name="ln5654">_kern_create_attr(int fd, const char *name, uint32_t type, int openMode)</a>
<a name="ln5655">{</a>
<a name="ln5656">	return attr_create(fd, name, type, openMode, true);</a>
<a name="ln5657">}</a>
<a name="ln5658"> </a>
<a name="ln5659"> </a>
<a name="ln5660">int</a>
<a name="ln5661">_kern_open_attr(int fd, const char *name, int openMode)</a>
<a name="ln5662">{</a>
<a name="ln5663">	return attr_open(fd, name, openMode, true);</a>
<a name="ln5664">}</a>
<a name="ln5665"> </a>
<a name="ln5666"> </a>
<a name="ln5667">fssh_status_t</a>
<a name="ln5668">_kern_remove_attr(int fd, const char *name)</a>
<a name="ln5669">{</a>
<a name="ln5670">	return attr_remove(fd, name, true);</a>
<a name="ln5671">}</a>
<a name="ln5672"> </a>
<a name="ln5673"> </a>
<a name="ln5674">fssh_status_t</a>
<a name="ln5675">_kern_rename_attr(int fromFile, const char *fromName, int toFile, const char *toName)</a>
<a name="ln5676">{</a>
<a name="ln5677">	return attr_rename(fromFile, fromName, toFile, toName, true);</a>
<a name="ln5678">}</a>
<a name="ln5679"> </a>
<a name="ln5680"> </a>
<a name="ln5681">int</a>
<a name="ln5682">_kern_open_index_dir(fssh_dev_t device)</a>
<a name="ln5683">{</a>
<a name="ln5684">	return index_dir_open(device, true);</a>
<a name="ln5685">}</a>
<a name="ln5686"> </a>
<a name="ln5687"> </a>
<a name="ln5688">fssh_status_t</a>
<a name="ln5689">_kern_create_index(fssh_dev_t device, const char *name, uint32_t type, uint32_t flags)</a>
<a name="ln5690">{</a>
<a name="ln5691">	return index_create(device, name, type, flags, true);</a>
<a name="ln5692">}</a>
<a name="ln5693"> </a>
<a name="ln5694"> </a>
<a name="ln5695">fssh_status_t</a>
<a name="ln5696">_kern_read_index_stat(fssh_dev_t device, const char *name, fssh_struct_stat *stat)</a>
<a name="ln5697">{</a>
<a name="ln5698">	return index_name_read_stat(device, name, stat, true);</a>
<a name="ln5699">}</a>
<a name="ln5700"> </a>
<a name="ln5701"> </a>
<a name="ln5702">fssh_status_t</a>
<a name="ln5703">_kern_remove_index(fssh_dev_t device, const char *name)</a>
<a name="ln5704">{</a>
<a name="ln5705">	return index_remove(device, name, true);</a>
<a name="ln5706">}</a>
<a name="ln5707"> </a>
<a name="ln5708"> </a>
<a name="ln5709">fssh_status_t</a>
<a name="ln5710">_kern_getcwd(char *buffer, fssh_size_t size)</a>
<a name="ln5711">{</a>
<a name="ln5712">	TRACE((&quot;_kern_getcwd: buf %p, %ld\n&quot;, buffer, size));</a>
<a name="ln5713"> </a>
<a name="ln5714">	// Call vfs to get current working directory</a>
<a name="ln5715">	return get_cwd(buffer, size, true);</a>
<a name="ln5716">}</a>
<a name="ln5717"> </a>
<a name="ln5718"> </a>
<a name="ln5719">fssh_status_t</a>
<a name="ln5720">_kern_setcwd(int fd, const char *path)</a>
<a name="ln5721">{</a>
<a name="ln5722">	KPath pathBuffer(FSSH_B_PATH_NAME_LENGTH + 1);</a>
<a name="ln5723">	if (pathBuffer.InitCheck() != FSSH_B_OK)</a>
<a name="ln5724">		return FSSH_B_NO_MEMORY;</a>
<a name="ln5725"> </a>
<a name="ln5726">	if (path != NULL)</a>
<a name="ln5727">		pathBuffer.SetTo(path);</a>
<a name="ln5728"> </a>
<a name="ln5729">	return set_cwd(fd, path != NULL ? pathBuffer.LockBuffer() : NULL, true);</a>
<a name="ln5730">}</a>
<a name="ln5731"> </a>
<a name="ln5732"> </a>
<a name="ln5733">fssh_status_t</a>
<a name="ln5734">_kern_initialize_volume(const char* fsName, const char *partition,</a>
<a name="ln5735">	const char *name, const char *parameters)</a>
<a name="ln5736">{</a>
<a name="ln5737">	if (!fsName || ! partition)</a>
<a name="ln5738">		return FSSH_B_BAD_VALUE;</a>
<a name="ln5739"> </a>
<a name="ln5740">	// The partition argument should point to a real file/device.</a>
<a name="ln5741"> </a>
<a name="ln5742">	// open partition</a>
<a name="ln5743">	int fd = fssh_open(partition, FSSH_O_RDWR);</a>
<a name="ln5744">	if (fd &lt; 0)</a>
<a name="ln5745">		return fssh_errno;</a>
<a name="ln5746"> </a>
<a name="ln5747">	// get the file system module</a>
<a name="ln5748">	fssh_file_system_module_info* fsModule = get_file_system(fsName);</a>
<a name="ln5749">	if (fsModule == NULL) {</a>
<a name="ln5750">		fssh_close(fd);</a>
<a name="ln5751">		return FSSH_ENODEV;</a>
<a name="ln5752">	}</a>
<a name="ln5753"> </a>
<a name="ln5754">	// initialize</a>
<a name="ln5755">	fssh_status_t status;</a>
<a name="ln5756">	if (fsModule-&gt;initialize) {</a>
<a name="ln5757">		status = (*fsModule-&gt;initialize)(fd, -1, name, parameters, 0, -1);</a>
<a name="ln5758">			// We've got no partition or job IDs -- the FS will hopefully</a>
<a name="ln5759">			// ignore that.</a>
<a name="ln5760">			// TODO: Get the actual size!</a>
<a name="ln5761">	} else</a>
<a name="ln5762">		status = FSSH_B_NOT_SUPPORTED;</a>
<a name="ln5763"> </a>
<a name="ln5764">	// put the file system module, close partition</a>
<a name="ln5765">	put_file_system(fsModule);</a>
<a name="ln5766">	fssh_close(fd);</a>
<a name="ln5767"> </a>
<a name="ln5768">	return status;</a>
<a name="ln5769">}</a>
<a name="ln5770"> </a>
<a name="ln5771"> </a>
<a name="ln5772">fssh_status_t</a>
<a name="ln5773">_kern_entry_ref_to_path(fssh_dev_t device, fssh_ino_t inode, const char *leaf,</a>
<a name="ln5774">	char* path, fssh_size_t pathLength)</a>
<a name="ln5775">{</a>
<a name="ln5776">	return vfs_entry_ref_to_path(device, inode, leaf, true, path, pathLength);</a>
<a name="ln5777">}</a>
<a name="ln5778"> </a>
<a name="ln5779"> </a>
<a name="ln5780">int</a>
<a name="ln5781">_kern_open_query(fssh_dev_t device, const char *query, fssh_size_t queryLength,</a>
<a name="ln5782">	uint32_t flags, fssh_port_id port, int32_t token)</a>
<a name="ln5783">{</a>
<a name="ln5784">	return query_open(device, query, flags, port, token, false);</a>
<a name="ln5785">}</a>
<a name="ln5786"> </a>
<a name="ln5787"> </a>
<a name="ln5788">}	// namespace FSShell</a>
<a name="ln5789"> </a>
<a name="ln5790"> </a>
<a name="ln5791">#include &quot;vfs_request_io.cpp&quot;</a>

</code></pre>
<div class="balloon" rel="4955"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'fssh_dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1900"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'fssh_panic' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1074"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'fssh_panic' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="786"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'fssh_panic' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
