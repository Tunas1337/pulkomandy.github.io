
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>PackageInfo.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 2007-2010, Haiku, Inc.</a>
<a name="ln3"> * Distributed under the terms of the MIT license.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Author:</a>
<a name="ln6"> *		≈Åukasz 'Sil2100' Zemczak &lt;sil2100@vexillium.org&gt;</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;PackageInfo.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;Alert.h&gt;</a>
<a name="ln13">#include &lt;ByteOrder.h&gt;</a>
<a name="ln14">#include &lt;Catalog.h&gt;</a>
<a name="ln15">#include &lt;FindDirectory.h&gt;</a>
<a name="ln16">#include &lt;Locale.h&gt;</a>
<a name="ln17">#include &lt;Path.h&gt;</a>
<a name="ln18">#include &lt;kernel/OS.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20"> </a>
<a name="ln21">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln22">#define B_TRANSLATION_CONTEXT &quot;PackageInfo&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#define RETURN_AND_SET_STATUS(err) fStatus = err; \</a>
<a name="ln25">	fprintf(stderr, &quot;err at %s():%d: %x\n&quot;, __FUNCTION__, __LINE__, err); \</a>
<a name="ln26">	return fStatus;</a>
<a name="ln27"> </a>
<a name="ln28">const uint32 kSkipOffset = 33;</a>
<a name="ln29"> </a>
<a name="ln30">// Section constants</a>
<a name="ln31">enum {</a>
<a name="ln32">	P_GROUPS_SECTION = 0,</a>
<a name="ln33">	P_PATH_SECTION,</a>
<a name="ln34">	P_USER_PATH_SECTION,</a>
<a name="ln35">	P_LICENSE_SECTION</a>
<a name="ln36">};</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">// Element constants</a>
<a name="ln40">enum {</a>
<a name="ln41">	P_NONE = 0,</a>
<a name="ln42">	P_FILE,</a>
<a name="ln43">	P_DIRECTORY,</a>
<a name="ln44">	P_LINK,</a>
<a name="ln45">	P_SCRIPT</a>
<a name="ln46">};</a>
<a name="ln47"> </a>
<a name="ln48">typedef enum {</a>
<a name="ln49">	B_BEBOX_PLATFORM = 0,</a>
<a name="ln50">	B_MAC_PLATFORM,</a>
<a name="ln51">	B_AT_CLONE_PLATFORM,</a>
<a name="ln52">	B_ENIAC_PLATFORM,</a>
<a name="ln53">	B_APPLE_II_PLATFORM,</a>
<a name="ln54">	B_CRAY_PLATFORM,</a>
<a name="ln55">	B_LISA_PLATFORM,</a>
<a name="ln56">	B_TI_994A_PLATFORM,</a>
<a name="ln57">	B_TIMEX_SINCLAIR_PLATFORM,</a>
<a name="ln58">	B_ORAC_1_PLATFORM,</a>
<a name="ln59">	B_HAL_PLATFORM,</a>
<a name="ln60">	B_INVALID_PLATFORM</a>
<a name="ln61">} platform_type;</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">PackageInfo::PackageInfo()</a>
<a name="ln65">	:</a>
<a name="ln66">	fStatus(B_NO_INIT),</a>
<a name="ln67">	fPackageFile(0),</a>
<a name="ln68">	fDescription(B_TRANSLATE(&quot;No package available.&quot;)),</a>
<a name="ln69">	fProfiles(2),</a>
<a name="ln70">	fHasImage(false)</a>
<a name="ln71">{</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">PackageInfo::PackageInfo(const entry_ref *ref)</a>
<a name="ln76">	:</a>
<a name="ln77">	fStatus(B_NO_INIT),</a>
<a name="ln78">	fPackageFile(new BFile(ref, B_READ_ONLY)),</a>
<a name="ln79">	fDescription(B_TRANSLATE(&quot;No package selected.&quot;)),</a>
<a name="ln80">	fProfiles(2),</a>
<a name="ln81">	fHasImage(false)</a>
<a name="ln82">{</a>
<a name="ln83">	fStatus = Parse();</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">PackageInfo::~PackageInfo()</a>
<a name="ln88">{</a>
<a name="ln89">	pkg_profile *iter = 0;</a>
<a name="ln90">	while (1) {</a>
<a name="ln91">		iter = static_cast&lt;pkg_profile *&gt;(fProfiles.RemoveItem((int32)0));</a>
<a name="ln92">		if (iter == NULL)</a>
<a name="ln93">			break;</a>
<a name="ln94"> </a>
<a name="ln95">		delete iter;</a>
<a name="ln96">	}</a>
<a name="ln97"> </a>
<a name="ln98">	PackageItem *file = 0;</a>
<a name="ln99">	while (true) {</a>
<a name="ln100">		file = static_cast&lt;PackageItem *&gt;(fFiles.RemoveItem((int32)0));</a>
<a name="ln101">		if (file == NULL)</a>
<a name="ln102">			break;</a>
<a name="ln103"> </a>
<a name="ln104">		delete file;</a>
<a name="ln105">	}</a>
<a name="ln106"> </a>
<a name="ln107">	while (true) {</a>
<a name="ln108">		file = static_cast&lt;PackageScript *&gt;(fScripts.RemoveItem((int32)0));</a>
<a name="ln109">		if (file == NULL)</a>
<a name="ln110">			break;</a>
<a name="ln111"> </a>
<a name="ln112">		delete file;</a>
<a name="ln113">	}</a>
<a name="ln114"> </a>
<a name="ln115">	delete fPackageFile;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">status_t</a>
<a name="ln120">PackageInfo::Parse()</a>
<a name="ln121">{</a>
<a name="ln122">	// TODO: Clean up</a>
<a name="ln123">	if (!fPackageFile || fPackageFile-&gt;InitCheck() != B_OK) {</a>
<a name="ln124">		RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln125">	}</a>
<a name="ln126"> </a>
<a name="ln127">	// Check for the presence of the first AlB tag - as the 'magic number'.</a>
<a name="ln128">	// This also ensures that the file header section is present - which</a>
<a name="ln129">	// is a crucial pkg section</a>
<a name="ln130">	char buffer[16];</a>
<a name="ln131">	fPackageFile-&gt;Read(buffer, 8);</a>
<a name="ln132">	if (buffer[0] != 'A' || buffer[1] != 'l' || buffer[2] != 'B'</a>
<a name="ln133">		|| buffer[3] != 0x1a) {</a>
<a name="ln134">		RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln135">	}</a>
<a name="ln136"> </a>
<a name="ln137">	fHasImage = false;</a>
<a name="ln138"> </a>
<a name="ln139">	// Parse all known parts of the given .pkg file</a>
<a name="ln140"> </a>
<a name="ln141">	uint32 i;</a>
<a name="ln142">	int8 bytesRead;</a>
<a name="ln143">	off_t actualSize = 0;</a>
<a name="ln144">	fPackageFile-&gt;GetSize(&amp;actualSize);</a>
<a name="ln145">	uint64 fileSize = 0;</a>
<a name="ln146"> </a>
<a name="ln147">	const char padding[7] = { 0, 0, 0, 0, 0, 0, 0 };</a>
<a name="ln148"> </a>
<a name="ln149">	platform_type thisPlatform = B_INVALID_PLATFORM;</a>
<a name="ln150">	cpu_topology_node_info topologyRoot;</a>
<a name="ln151">	uint32 topologyNodeCount = 1;</a>
<a name="ln152">	if (get_cpu_topology_info(&amp;topologyRoot, &amp;topologyNodeCount) == B_OK) {</a>
<a name="ln153">		switch (topologyRoot.data.root.platform) {</a>
<a name="ln154">			case B_CPU_x86:</a>
<a name="ln155">				thisPlatform = B_AT_CLONE_PLATFORM;</a>
<a name="ln156">				break;</a>
<a name="ln157"> </a>
<a name="ln158">			default:</a>
<a name="ln159">				break;</a>
<a name="ln160">		}</a>
<a name="ln161">	}</a>
<a name="ln162"> </a>
<a name="ln163">	uint64 infoOffset = 0, groupsOffset = 0;</a>
<a name="ln164">	uint64 length = 0;</a>
<a name="ln165"> </a>
<a name="ln166">	// Parse the file header</a>
<a name="ln167">	while (true) {</a>
<a name="ln168">		bytesRead = fPackageFile-&gt;Read(buffer, 7);</a>
<a name="ln169">		if (bytesRead != 7) {</a>
<a name="ln170">			RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln171">		}</a>
<a name="ln172"> </a>
<a name="ln173">		if (!memcmp(buffer, &quot;PhIn&quot;, 5)) {</a>
<a name="ln174">		} else if (!memcmp(buffer, &quot;FVer&quot;, 5)) {</a>
<a name="ln175">			// Not used right now</a>
<a name="ln176">			fPackageFile-&gt;Seek(4, SEEK_CUR);</a>
<a name="ln177">			parser_debug(&quot;FVer\n&quot;);</a>
<a name="ln178">		} else if (!memcmp(buffer, &quot;AFla&quot;, 5)) {</a>
<a name="ln179">			// Not used right now TODO: Check what this tag is for</a>
<a name="ln180">			fPackageFile-&gt;Seek(8, SEEK_CUR);</a>
<a name="ln181">			parser_debug(&quot;AFla\n&quot;);</a>
<a name="ln182">		} else if (!memcmp(buffer, &quot;FSiz&quot;, 5)) {</a>
<a name="ln183">			fPackageFile-&gt;Read(&amp;fileSize, 8);</a>
<a name="ln184">			swap_data(B_UINT64_TYPE, &amp;fileSize, sizeof(uint64),</a>
<a name="ln185">					B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln186">			parser_debug(&quot;FSiz %llu\n&quot;, fileSize);</a>
<a name="ln187">		} else if (!memcmp(buffer, &quot;COff&quot;, 5)) {</a>
<a name="ln188">			fPackageFile-&gt;Read(&amp;infoOffset, 8);</a>
<a name="ln189">			swap_data(B_UINT64_TYPE, &amp;infoOffset, sizeof(uint64),</a>
<a name="ln190">					B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln191">			parser_debug(&quot;COff %llu\n&quot;, infoOffset);</a>
<a name="ln192">		} else if (!memcmp(buffer, &quot;AOff&quot;, 5)) {</a>
<a name="ln193">			fPackageFile-&gt;Read(&amp;groupsOffset, 8);</a>
<a name="ln194">			swap_data(B_UINT64_TYPE, &amp;groupsOffset, sizeof(uint64),</a>
<a name="ln195">					B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln196">			parser_debug(&quot;AOff %llu\n&quot;, groupsOffset);</a>
<a name="ln197">		} else if (!memcmp(buffer, padding, 7)) {</a>
<a name="ln198">			// This means the end of this section - we should move to the</a>
<a name="ln199">			// groups section.</a>
<a name="ln200">			if (groupsOffset) {</a>
<a name="ln201">				fPackageFile-&gt;Seek(groupsOffset, SEEK_SET);</a>
<a name="ln202">			}</a>
<a name="ln203">			parser_debug(&quot;End!\n&quot;);</a>
<a name="ln204">			break;</a>
<a name="ln205">		} else {</a>
<a name="ln206">			RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln207">		}</a>
<a name="ln208">	}</a>
<a name="ln209"> </a>
<a name="ln210">	fPackageFile-&gt;Read(buffer, 7);</a>
<a name="ln211">	if (memcmp(buffer, &quot;PkgA&quot;, 5) || !groupsOffset || !infoOffset) {</a>
<a name="ln212">		RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln213">	}</a>
<a name="ln214"> </a>
<a name="ln215">	// Section header identifying constant byte sequences:</a>
<a name="ln216">	const char groupsMarker[7] = { 0, 0, 0, 1, 0, 0, 4 };</a>
<a name="ln217">	const char idMarker[7] = { 0, 0, 0, 2, 0, 0, 4 };</a>
<a name="ln218">	const char pathMarker[7] = { 0, 0, 0, 3, 0, 0, 4 };</a>
<a name="ln219">	const char upathMarker[7] = { 0, 0, 0, 4, 0, 0, 4 };</a>
<a name="ln220">	const char licenseMarker[7] = { 0, 0, 0, 18, 0, 0, 4 };</a>
<a name="ln221">	const char descMarker[7] = { 0, 0, 0, 5, 0, 0, 2 };</a>
<a name="ln222">	const char helpMarker[7] = { 0, 0, 0, 10, 0, 0, 3 };</a>
<a name="ln223"> </a>
<a name="ln224">	const char splashScreenMarker[7] = { 0, 0, 0, 8, 0, 0, 3 };</a>
<a name="ln225">	const char disclaimerMarker[7] = { 0, 0, 0, 7, 0, 0, 3 };</a>
<a name="ln226"> </a>
<a name="ln227">	const char nameMarker[7] = { 0, 0, 0, 13, 0, 0, 2 };</a>
<a name="ln228">	const char versionMarker[7] = { 0, 0, 0, 14, 0, 0, 2 };</a>
<a name="ln229">	const char devMarker[7] = { 0, 0, 0, 15, 0, 0, 2 };</a>
<a name="ln230">	const char shortDescMarker[7] = { 0, 0, 0, 17, 0, 0, 2 };</a>
<a name="ln231"> </a>
<a name="ln232">	int8 section = P_GROUPS_SECTION, installDirectoryFlag = 0;</a>
<a name="ln233"> </a>
<a name="ln234">	pkg_profile group;</a>
<a name="ln235">	BList groups(3), userPaths(3), systemPaths(10);</a>
<a name="ln236">	bool groupStarted = false;</a>
<a name="ln237">	parser_debug(&quot;Package Info reached!\n&quot;);</a>
<a name="ln238">	// TODO: Maybe checking whether the needed number of bytes are read</a>
<a name="ln239">	//	everytime would be a good idea</a>
<a name="ln240"> </a>
<a name="ln241">	// Parse the package info section</a>
<a name="ln242">	while (true) {</a>
<a name="ln243">		bytesRead = fPackageFile-&gt;Read(buffer, 7);</a>
<a name="ln244">		if (bytesRead != 7) {</a>
<a name="ln245">			parser_debug(&quot;EOF!\n&quot;);</a>
<a name="ln246">			break;</a>
<a name="ln247">		}</a>
<a name="ln248"> </a>
<a name="ln249">		if (!memcmp(buffer, groupsMarker, 7)) {</a>
<a name="ln250">			section = P_GROUPS_SECTION;</a>
<a name="ln251">			parser_debug(&quot;Got to Groups section\n&quot;);</a>
<a name="ln252">			continue;</a>
<a name="ln253">		} else if (!memcmp(buffer, pathMarker, 7)) {</a>
<a name="ln254">			section = P_PATH_SECTION;</a>
<a name="ln255">			parser_debug(&quot;Got to System Paths\n&quot;);</a>
<a name="ln256">			continue;</a>
<a name="ln257">		} else if (!memcmp(buffer, upathMarker, 7)) {</a>
<a name="ln258">			section = P_USER_PATH_SECTION;</a>
<a name="ln259">			parser_debug(&quot;Got to User Paths\n&quot;);</a>
<a name="ln260">			continue;</a>
<a name="ln261">		} else if (!memcmp(buffer, licenseMarker, 7)) {</a>
<a name="ln262">			section = P_LICENSE_SECTION;</a>
<a name="ln263">			parser_debug(&quot;Got to License\n&quot;);</a>
<a name="ln264">			continue;</a>
<a name="ln265">			// After this, non sectioned tags follow</a>
<a name="ln266">		} else if (!memcmp(buffer, disclaimerMarker, 7)) {</a>
<a name="ln267">			uint64 length;</a>
<a name="ln268">			fPackageFile-&gt;Read(&amp;length, 8);</a>
<a name="ln269">			swap_data(B_UINT64_TYPE, &amp;length, sizeof(uint64),</a>
<a name="ln270">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln271"> </a>
<a name="ln272">			uint64 original;</a>
<a name="ln273">			if (fPackageFile-&gt;Read(&amp;original, 8) != 8) {</a>
<a name="ln274">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln275">			}</a>
<a name="ln276">			swap_data(B_UINT64_TYPE, &amp;original, sizeof(uint64),</a>
<a name="ln277">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln278"> </a>
<a name="ln279">			fPackageFile-&gt;Seek(4, SEEK_CUR);</a>
<a name="ln280"> </a>
<a name="ln281">			uint8 *compressed = new uint8[length];</a>
<a name="ln282">			if (fPackageFile-&gt;Read(compressed, length)</a>
<a name="ln283">					!= static_cast&lt;int64&gt;(length)) {</a>
<a name="ln284">				delete[] compressed;</a>
<a name="ln285">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln286">			}</a>
<a name="ln287"> </a>
<a name="ln288">			uint8 *disclaimer = new uint8[original + 1];</a>
<a name="ln289">			status_t ret = inflate_data(compressed, length, disclaimer,</a>
<a name="ln290">				original);</a>
<a name="ln291">			disclaimer[original] = 0;</a>
<a name="ln292">			delete[] compressed;</a>
<a name="ln293">			if (ret != B_OK) {</a>
<a name="ln294">				delete[] disclaimer;</a>
<a name="ln295">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln296">			}</a>
<a name="ln297"> </a>
<a name="ln298">			fDisclaimer = (char *)disclaimer;</a>
<a name="ln299">			delete[] disclaimer;</a>
<a name="ln300"> </a>
<a name="ln301">			continue;</a>
<a name="ln302">		} else if (!memcmp(buffer, splashScreenMarker, 7)) {</a>
<a name="ln303">			uint64 length;</a>
<a name="ln304">			fPackageFile-&gt;Read(&amp;length, 8);</a>
<a name="ln305">			swap_data(B_UINT64_TYPE, &amp;length, sizeof(uint64),</a>
<a name="ln306">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln307"> </a>
<a name="ln308">			uint64 original;</a>
<a name="ln309">			if (fPackageFile-&gt;Read(&amp;original, 8) != 8) {</a>
<a name="ln310">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln311">			}</a>
<a name="ln312">			swap_data(B_UINT64_TYPE, &amp;original, sizeof(uint64),</a>
<a name="ln313">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln314"> </a>
<a name="ln315">			fPackageFile-&gt;Seek(4, SEEK_CUR);</a>
<a name="ln316"> </a>
<a name="ln317">			uint8 *compressed = new uint8[length];</a>
<a name="ln318">			if (fPackageFile-&gt;Read(compressed, length)</a>
<a name="ln319">					!= static_cast&lt;int64&gt;(length)) {</a>
<a name="ln320">				delete[] compressed;</a>
<a name="ln321">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln322">			}</a>
<a name="ln323"> </a>
<a name="ln324">			fImage.SetSize(original);</a>
<a name="ln325">			status_t ret = inflate_data(compressed, length,</a>
<a name="ln326">				static_cast&lt;uint8 *&gt;(const_cast&lt;void *&gt;(fImage.Buffer())),</a>
<a name="ln327">				original);</a>
<a name="ln328">			delete[] compressed;</a>
<a name="ln329">			if (ret != B_OK) {</a>
<a name="ln330">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln331">			}</a>
<a name="ln332">			fHasImage = true;</a>
<a name="ln333">			continue;</a>
<a name="ln334">		}</a>
<a name="ln335"> </a>
<a name="ln336">		switch (section) {</a>
<a name="ln337">			case P_PATH_SECTION:</a>
<a name="ln338">			{</a>
<a name="ln339">				if (!memcmp(buffer, &quot;DPat&quot;, 5)) {</a>
<a name="ln340">					parser_debug(&quot;DPat\n&quot;);</a>
<a name="ln341">					continue;</a>
<a name="ln342">				} else if (!memcmp(buffer, &quot;FDst&quot;, 5)) {</a>
<a name="ln343">					parser_debug(&quot;FDst - &quot;);</a>
<a name="ln344">					directory_which dir;</a>
<a name="ln345">					if (fPackageFile-&gt;Read(&amp;dir, 4) != 4) {</a>
<a name="ln346">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln347">					}</a>
<a name="ln348">					swap_data(B_UINT32_TYPE, &amp;dir, sizeof(uint32),</a>
<a name="ln349">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln350">					BPath *path = new BPath();</a>
<a name="ln351">					status_t ret = find_directory(dir, path);</a>
<a name="ln352">					if (ret != B_OK) {</a>
<a name="ln353">						delete path;</a>
<a name="ln354">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln355">					}</a>
<a name="ln356"> </a>
<a name="ln357">					parser_debug(&quot;%s\n&quot;, path-&gt;Path());</a>
<a name="ln358"> </a>
<a name="ln359">					systemPaths.AddItem(path);</a>
<a name="ln360">				} else if (!memcmp(buffer, &quot;PaNa&quot;, 5)) {</a>
<a name="ln361">					parser_debug(&quot;PaNa\n&quot;);</a>
<a name="ln362">					if (fPackageFile-&gt;Read(&amp;length, 4) != 4) {</a>
<a name="ln363">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln364">					}</a>
<a name="ln365">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln366">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln367">					// Since its a default, system path, we can ignore the path</a>
<a name="ln368">					// name - all information needed is beside the FDst tag.</a>
<a name="ln369">					fPackageFile-&gt;Seek(length, SEEK_CUR);</a>
<a name="ln370">				} else if (!memcmp(buffer, padding, 7)) {</a>
<a name="ln371">					parser_debug(&quot;Padding!\n&quot;);</a>
<a name="ln372">					continue;</a>
<a name="ln373">				} else {</a>
<a name="ln374">					RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln375">				}</a>
<a name="ln376">				break;</a>
<a name="ln377">			}</a>
<a name="ln378"> </a>
<a name="ln379">			case P_GROUPS_SECTION:</a>
<a name="ln380">			{</a>
<a name="ln381">				if (!memcmp(buffer, &quot;IGrp&quot;, 5)) {</a>
<a name="ln382">					// Creata a new group</a>
<a name="ln383">					groupStarted = true;</a>
<a name="ln384">					group = pkg_profile();</a>
<a name="ln385">					parser_debug(&quot;IGrp\n&quot;);</a>
<a name="ln386">				} else if (!memcmp(buffer, &quot;GrpN&quot;, 5)) {</a>
<a name="ln387">					if (!groupStarted) {</a>
<a name="ln388">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln389">					}</a>
<a name="ln390"> </a>
<a name="ln391">					parser_debug(&quot;GrpN\n&quot;);</a>
<a name="ln392">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln393">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln394">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln395"> </a>
<a name="ln396">					char *name = new char[length + 1];</a>
<a name="ln397">					fPackageFile-&gt;Read(name, length);</a>
<a name="ln398">					name[length] = 0;</a>
<a name="ln399">					group.name = name;</a>
<a name="ln400">					delete[] name;</a>
<a name="ln401">				} else if (!memcmp(buffer, &quot;GrpD&quot;, 5)) {</a>
<a name="ln402">					if (!groupStarted) {</a>
<a name="ln403">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln404">					}</a>
<a name="ln405"> </a>
<a name="ln406">					parser_debug(&quot;GrpD\n&quot;);</a>
<a name="ln407">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln408">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln409">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln410"> </a>
<a name="ln411">					char *desc = new char[length + 1];</a>
<a name="ln412">					fPackageFile-&gt;Read(desc, length);</a>
<a name="ln413">					desc[length] = 0;</a>
<a name="ln414">					group.description = desc;</a>
<a name="ln415">					delete[] desc;</a>
<a name="ln416">				} else if (!memcmp(buffer, &quot;GrHt&quot;, 5)) {</a>
<a name="ln417">					if (!groupStarted) {</a>
<a name="ln418">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln419">					}</a>
<a name="ln420"> </a>
<a name="ln421">					parser_debug(&quot;GrHt\n&quot;);</a>
<a name="ln422">					// For now, we don't need group help</a>
<a name="ln423">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln424">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln425">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln426">					fPackageFile-&gt;Seek(length, SEEK_CUR);</a>
<a name="ln427">				} else if (!memcmp(buffer, padding, 5)) {</a>
<a name="ln428">					if (!groupStarted) {</a>
<a name="ln429">						parser_debug(&quot;No group - padding!\n&quot;);</a>
<a name="ln430">						continue;</a>
<a name="ln431">					}</a>
<a name="ln432"> </a>
<a name="ln433">					fProfiles.AddItem(new pkg_profile(group));</a>
<a name="ln434">					parser_debug(&quot;Group added: %s %s\n&quot;, group.name.String(),</a>
<a name="ln435">						group.description.String());</a>
<a name="ln436"> </a>
<a name="ln437">					groupStarted = false;</a>
<a name="ln438">				} else if (!memcmp(buffer, &quot;GrId&quot;, 5)) {</a>
<a name="ln439">					uint32 id;</a>
<a name="ln440">					fPackageFile-&gt;Read(&amp;id, 4);</a>
<a name="ln441">					swap_data(B_UINT32_TYPE, &amp;id, sizeof(uint32),</a>
<a name="ln442">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln443"> </a>
<a name="ln444">					parser_debug(&quot;GrId\n&quot;);</a>
<a name="ln445"> </a>
<a name="ln446">					if (id == 0xffffffff)</a>
<a name="ln447">						groups.AddItem(NULL);</a>
<a name="ln448">					else</a>
<a name="ln449">						groups.AddItem(fProfiles.ItemAt(id));</a>
<a name="ln450">				} else if (!memcmp(buffer, idMarker, 7)</a>
<a name="ln451">					|| !memcmp(buffer, groupsMarker, 7)) {</a>
<a name="ln452">					parser_debug(&quot;Marker, jumping!\n&quot;);</a>
<a name="ln453">					continue;</a>
<a name="ln454">				} else {</a>
<a name="ln455">					RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln456">				}</a>
<a name="ln457">				break;</a>
<a name="ln458">			}</a>
<a name="ln459"> </a>
<a name="ln460">			case P_LICENSE_SECTION:</a>
<a name="ln461">			{</a>
<a name="ln462">				if (!memcmp(buffer, &quot;Lic?&quot;, 5)) {</a>
<a name="ln463">					parser_debug(&quot;Lic?\n&quot;);</a>
<a name="ln464">					// This tag informs whether a license is present in the</a>
<a name="ln465">					// package or not. Since we don't care about licenses right</a>
<a name="ln466">					// now, just skip this section</a>
<a name="ln467">					fPackageFile-&gt;Seek(4, SEEK_CUR);</a>
<a name="ln468">				} else if (!memcmp(buffer, &quot;LicP&quot;, 5)) {</a>
<a name="ln469">					parser_debug(&quot;LicP\n&quot;);</a>
<a name="ln470">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln471">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln472">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln473"> </a>
<a name="ln474">					fPackageFile-&gt;Seek(length, SEEK_CUR);</a>
<a name="ln475">				} else if (!memcmp(buffer, padding, 7)) {</a>
<a name="ln476">					continue;</a>
<a name="ln477">				} else if (!memcmp(buffer, descMarker, 7)) {</a>
<a name="ln478">					parser_debug(&quot;Description text reached\n&quot;);</a>
<a name="ln479">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln480">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln481">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln482"> </a>
<a name="ln483">					char *description = new char[length + 1];</a>
<a name="ln484">					fPackageFile-&gt;Read(description, length);</a>
<a name="ln485">					description[length] = 0;</a>
<a name="ln486">					fDescription = description;</a>
<a name="ln487"> </a>
<a name="ln488">					// Truncate all leading newlines</a>
<a name="ln489">					for (i = 0; i &lt; length; i++) {</a>
<a name="ln490">						if (fDescription[i] != '\n')</a>
<a name="ln491">							break;</a>
<a name="ln492">					}</a>
<a name="ln493">					fDescription.Remove(0, i);</a>
<a name="ln494"> </a>
<a name="ln495">					delete[] description;</a>
<a name="ln496">					parser_debug(&quot;Description text reached\n&quot;);</a>
<a name="ln497"> </a>
<a name="ln498">					// After this, there's a known size sequence of bytes, which</a>
<a name="ln499">					// meaning is yet to be determined.</a>
<a name="ln500"> </a>
<a name="ln501">					// One is already known. The byte (or just its least</a>
<a name="ln502">					// significant bit) at offset 21 from the description text</a>
<a name="ln503">					// is responsible for the install folder existence</a>
<a name="ln504">					// information. If it is 0, there is no install folder, if</a>
<a name="ln505">					// it is 1 (or the least significant bit is set) it means</a>
<a name="ln506">					// we should install all 0xffffffff files/directories to</a>
<a name="ln507">					// the first directory existing in the package</a>
<a name="ln508">					fPackageFile-&gt;Seek(21, SEEK_CUR);</a>
<a name="ln509">					if (fPackageFile-&gt;Read(&amp;installDirectoryFlag, 1) != 1) {</a>
<a name="ln510">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln511">					}</a>
<a name="ln512"> </a>
<a name="ln513">					fPackageFile-&gt;Seek(11, SEEK_CUR);</a>
<a name="ln514">				} else if (!memcmp(buffer, nameMarker, 7)) {</a>
<a name="ln515">					parser_debug(&quot;Package name reached\n&quot;);</a>
<a name="ln516">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln517">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln518">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln519"> </a>
<a name="ln520">					char *name = new char[length + 1];</a>
<a name="ln521">					fPackageFile-&gt;Read(name, length);</a>
<a name="ln522">					name[length] = 0;</a>
<a name="ln523">					fName = name;</a>
<a name="ln524">					delete[] name;</a>
<a name="ln525">				} else if (!memcmp(buffer, versionMarker, 7)) {</a>
<a name="ln526">					parser_debug(&quot;Package version reached\n&quot;);</a>
<a name="ln527">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln528">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln529">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln530"> </a>
<a name="ln531">					char *version = new char[length + 1];</a>
<a name="ln532">					fPackageFile-&gt;Read(version, length);</a>
<a name="ln533">					version[length] = 0;</a>
<a name="ln534">					fVersion = version;</a>
<a name="ln535">					delete[] version;</a>
<a name="ln536">				} else if (!memcmp(buffer, devMarker, 7)) {</a>
<a name="ln537">					parser_debug(&quot;Package developer reached\n&quot;);</a>
<a name="ln538">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln539">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln540">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln541"> </a>
<a name="ln542">					char *dev = new char[length + 1];</a>
<a name="ln543">					fPackageFile-&gt;Read(dev, length);</a>
<a name="ln544">					dev[length] = 0;</a>
<a name="ln545">					fDeveloper = dev;</a>
<a name="ln546">					delete[] dev;</a>
<a name="ln547">				} else if (!memcmp(buffer, shortDescMarker, 7)) {</a>
<a name="ln548">					parser_debug(&quot;Package short description reached\n&quot;);</a>
<a name="ln549">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln550">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln551">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln552"> </a>
<a name="ln553">					char *desc = new char[length + 1];</a>
<a name="ln554">					fPackageFile-&gt;Read(desc, length);</a>
<a name="ln555">					desc[length] = 0;</a>
<a name="ln556">					fShortDesc = desc;</a>
<a name="ln557">					delete[] desc;</a>
<a name="ln558">				} else if (!memcmp(buffer, helpMarker, 7)) {</a>
<a name="ln559">					// The help text is a stored in deflated state, preceded by a 64 bit</a>
<a name="ln560">					// compressed size, 64 bit inflated size and a 32 bit integer</a>
<a name="ln561">					// Since there was no discussion whether we need this help text,</a>
<a name="ln562">					// it will be skipped</a>
<a name="ln563">					parser_debug(&quot;Help text reached\n&quot;);</a>
<a name="ln564">					//uint64 length64;</a>
<a name="ln565">					fPackageFile-&gt;Read(&amp;length, 8);</a>
<a name="ln566">					swap_data(B_UINT64_TYPE, &amp;length, sizeof(uint64),</a>
<a name="ln567">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln568"> </a>
<a name="ln569">					fPackageFile-&gt;Seek(12 + length, SEEK_CUR);</a>
<a name="ln570">				}</a>
<a name="ln571">				break;</a>
<a name="ln572">			}</a>
<a name="ln573"> </a>
<a name="ln574">			case P_USER_PATH_SECTION:</a>
<a name="ln575">			{</a>
<a name="ln576">				if (!memcmp(buffer, &quot;DPat&quot;, 5)) {</a>
<a name="ln577">					parser_debug(&quot;DPat\n&quot;);</a>
<a name="ln578">					continue;</a>
<a name="ln579">				} else if (!memcmp(buffer, &quot;DQue&quot;, 5)) {</a>
<a name="ln580">					parser_debug(&quot;DQue\n&quot;);</a>
<a name="ln581">					continue;</a>
<a name="ln582">				} else if (!memcmp(buffer, &quot;DQTi&quot;, 5)) {</a>
<a name="ln583">					parser_debug(&quot;DQTi\n&quot;);</a>
<a name="ln584">					uint32 length;</a>
<a name="ln585">					if (fPackageFile-&gt;Read(&amp;length, 4) != 4) {</a>
<a name="ln586">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln587">					}</a>
<a name="ln588">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln589">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln590">					char *ti = new char[length + 1];</a>
<a name="ln591">					fPackageFile-&gt;Read(ti, length);</a>
<a name="ln592">					ti[length] = 0;</a>
<a name="ln593">					parser_debug(&quot;DQTi - %s\n&quot;, ti);</a>
<a name="ln594">					delete[] ti;</a>
<a name="ln595">				} else if (!memcmp(buffer, &quot;DQSz&quot;, 5)) {</a>
<a name="ln596">					parser_debug(&quot;DQSz\n&quot;);</a>
<a name="ln597">					uint64 size;</a>
<a name="ln598">					if (fPackageFile-&gt;Read(&amp;size, 8) != 8) {</a>
<a name="ln599">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln600">					}</a>
<a name="ln601">					swap_data(B_UINT64_TYPE, &amp;size, sizeof(uint64),</a>
<a name="ln602">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln603">					parser_debug(&quot;DQSz - %Ld\n&quot;, size);</a>
<a name="ln604">				} else if (!memcmp(buffer, &quot;DQMi&quot;, 5)) {</a>
<a name="ln605">					// TODO actually check if the query finds a file with</a>
<a name="ln606">					// size found previously</a>
<a name="ln607">					parser_debug(&quot;DQMi\n&quot;);</a>
<a name="ln608">					uint32 length;</a>
<a name="ln609">					if (fPackageFile-&gt;Read(&amp;length, 4) != 4) {</a>
<a name="ln610">						RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln611">					}</a>
<a name="ln612">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln613">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln614">					char *signature = new char[length + 1];</a>
<a name="ln615">					fPackageFile-&gt;Read(signature, length);</a>
<a name="ln616">					signature[length] = 0;</a>
<a name="ln617">					parser_debug(&quot;DQMi - %s\n&quot;, signature);</a>
<a name="ln618">					delete[] signature;</a>
<a name="ln619">				} else if (!memcmp(buffer, &quot;PaNa&quot;, 5)) {</a>
<a name="ln620">					parser_debug(&quot;PaNa\n&quot;);</a>
<a name="ln621">					fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln622">					swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln623">						B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln624"> </a>
<a name="ln625">					char *pathname = new char[length + 1];</a>
<a name="ln626">					fPackageFile-&gt;Read(pathname, length);</a>
<a name="ln627">					pathname[length] = 0;</a>
<a name="ln628">					BString *path = new BString(pathname);</a>
<a name="ln629">					if (length &gt; 0 &amp;&amp; pathname[length - 1] == '/')</a>
<a name="ln630">						path-&gt;Remove(length - 1, 1);</a>
<a name="ln631">					userPaths.AddItem(path);</a>
<a name="ln632">					delete[] pathname;</a>
<a name="ln633">				} else if (!memcmp(buffer, padding, 7)) {</a>
<a name="ln634">					parser_debug(&quot;Padding!\n&quot;);</a>
<a name="ln635">					continue;</a>
<a name="ln636">				} else {</a>
<a name="ln637">					parser_debug(&quot;Unknown user path section %s\n&quot;, buffer);</a>
<a name="ln638">					RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln639">				}</a>
<a name="ln640">				break;</a>
<a name="ln641">			}</a>
<a name="ln642">		}</a>
<a name="ln643">	}</a>
<a name="ln644"> </a>
<a name="ln645">	BString nameString, mimeString, signatureString, linkString;</a>
<a name="ln646">	BString itemPath = &quot;&quot;, installDirectory = &quot;&quot;;</a>
<a name="ln647">	uint32 directoryCount = 0;</a>
<a name="ln648"> </a>
<a name="ln649">	uint8 element = P_NONE;</a>
<a name="ln650">	uint32 itemGroups = 0, path = 0, cust = 0, ctime = 0, mtime = 0;</a>
<a name="ln651">	uint32 platform = 0xffffffff;</a>
<a name="ln652">	uint64 offset = 0, size = 0, originalSize = 0, mode = 0;</a>
<a name="ln653">	uint8 pathType = P_INSTALL_PATH;</a>
<a name="ln654">	status_t ret;</a>
<a name="ln655"> </a>
<a name="ln656">	fPackageFile-&gt;Seek(infoOffset, SEEK_SET);</a>
<a name="ln657"> </a>
<a name="ln658">	// Parse package file data</a>
<a name="ln659">	while (true) {</a>
<a name="ln660">		bytesRead = fPackageFile-&gt;Read(buffer, 7);</a>
<a name="ln661">		if (bytesRead != 7) {</a>
<a name="ln662">			RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln663">		}</a>
<a name="ln664"> </a>
<a name="ln665">#define INIT_VARS(tag, type) \</a>
<a name="ln666">		parser_debug(tag &quot;\n&quot;); \</a>
<a name="ln667">		element = type; \</a>
<a name="ln668">		mimeString = &quot;&quot;; \</a>
<a name="ln669">		nameString = &quot;&quot;; \</a>
<a name="ln670">		linkString = &quot;&quot;; \</a>
<a name="ln671">		signatureString = &quot;&quot;; \</a>
<a name="ln672">		itemGroups = 0; \</a>
<a name="ln673">		ctime = 0; \</a>
<a name="ln674">		mtime = 0; \</a>
<a name="ln675">		offset = 0; \</a>
<a name="ln676">		cust = 0; \</a>
<a name="ln677">		mode = 0; \</a>
<a name="ln678">		platform = 0xffffffff; \</a>
<a name="ln679">		size = 0; \</a>
<a name="ln680">		originalSize = 0</a>
<a name="ln681"> </a>
<a name="ln682">		if (!memcmp(buffer, &quot;FilI&quot;, 5)) {</a>
<a name="ln683">			INIT_VARS(&quot;FilI&quot;, P_FILE);</a>
<a name="ln684">		} else if (!memcmp(buffer, &quot;FldI&quot;, 5)) {</a>
<a name="ln685">			INIT_VARS(&quot;FldI&quot;, P_DIRECTORY);</a>
<a name="ln686">		} else if (!memcmp(buffer, &quot;LnkI&quot;, 5)) {</a>
<a name="ln687">			INIT_VARS(&quot;LnkI&quot;, P_LINK);</a>
<a name="ln688">		} else if (!memcmp(buffer, &quot;ScrI&quot;, 5)) {</a>
<a name="ln689">			INIT_VARS(&quot;ScrI&quot;, P_SCRIPT);</a>
<a name="ln690">		} else if (!memcmp(buffer, &quot;Name&quot;, 5)) {</a>
<a name="ln691">			if (element == P_NONE) {</a>
<a name="ln692">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln693">			}</a>
<a name="ln694"> </a>
<a name="ln695">			parser_debug(&quot;Name\n&quot;);</a>
<a name="ln696">			fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln697">			swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln698">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln699"> </a>
<a name="ln700">			char *name = new char[length + 1];</a>
<a name="ln701">			fPackageFile-&gt;Read(name, length);</a>
<a name="ln702">			name[length] = 0;</a>
<a name="ln703"> </a>
<a name="ln704">			nameString = name;</a>
<a name="ln705">			delete[] name;</a>
<a name="ln706">		} else if (!memcmp(buffer, &quot;Grps&quot;, 5)) {</a>
<a name="ln707">			if (element == P_NONE) {</a>
<a name="ln708">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln709">			}</a>
<a name="ln710"> </a>
<a name="ln711">			parser_debug(&quot;Grps\n&quot;);</a>
<a name="ln712">			fPackageFile-&gt;Read(&amp;itemGroups, 4);</a>
<a name="ln713">			swap_data(B_UINT32_TYPE, &amp;itemGroups, sizeof(uint32),</a>
<a name="ln714">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln715">		} else if (!memcmp(buffer, &quot;Dest&quot;, 5)) {</a>
<a name="ln716">			if (element == P_NONE) {</a>
<a name="ln717">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln718">			}</a>
<a name="ln719"> </a>
<a name="ln720">			parser_debug(&quot;Dest\n&quot;);</a>
<a name="ln721">			fPackageFile-&gt;Read(&amp;path, 4);</a>
<a name="ln722">			swap_data(B_UINT32_TYPE, &amp;path, sizeof(uint32),</a>
<a name="ln723">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln724">		} else if (!memcmp(buffer, &quot;Cust&quot;, 5)) {</a>
<a name="ln725">			if (element == P_NONE) {</a>
<a name="ln726">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln727">			}</a>
<a name="ln728"> </a>
<a name="ln729">			parser_debug(&quot;Cust\n&quot;);</a>
<a name="ln730">			fPackageFile-&gt;Read(&amp;cust, 4);</a>
<a name="ln731">			swap_data(B_UINT32_TYPE, &amp;cust, sizeof(uint32),</a>
<a name="ln732">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln733">		} else if (!memcmp(buffer, &quot;Repl&quot;, 5)) {</a>
<a name="ln734">			if (element == P_NONE) {</a>
<a name="ln735">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln736">			}</a>
<a name="ln737"> </a>
<a name="ln738">			parser_debug(&quot;Repl\n&quot;);</a>
<a name="ln739">			fPackageFile-&gt;Seek(4, SEEK_CUR);</a>
<a name="ln740">			// TODO: Should the replace philosophy depend on this flag? For now</a>
<a name="ln741">			//	I always leave the decision to the user</a>
<a name="ln742">		} else if (!memcmp(buffer, &quot;Plat&quot;, 5)) {</a>
<a name="ln743">			if (element == P_NONE) {</a>
<a name="ln744">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln745">			}</a>
<a name="ln746"> </a>
<a name="ln747">			parser_debug(&quot;Plat\n&quot;);</a>
<a name="ln748">			fPackageFile-&gt;Read(&amp;platform, 4);</a>
<a name="ln749">			swap_data(B_UINT32_TYPE, &amp;platform, sizeof(uint32),</a>
<a name="ln750">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln751">		} else if (!memcmp(buffer, &quot;CTim&quot;, 5)) {</a>
<a name="ln752">			if (element == P_NONE) {</a>
<a name="ln753">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln754">			}</a>
<a name="ln755"> </a>
<a name="ln756">			parser_debug(&quot;CTim\n&quot;);</a>
<a name="ln757">			fPackageFile-&gt;Read(&amp;ctime, 4);</a>
<a name="ln758">			swap_data(B_UINT32_TYPE, &amp;ctime, sizeof(uint32),</a>
<a name="ln759">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln760">		} else if (!memcmp(buffer, &quot;MTim&quot;, 5)) {</a>
<a name="ln761">			if (element == P_NONE) {</a>
<a name="ln762">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln763">			}</a>
<a name="ln764"> </a>
<a name="ln765">			parser_debug(&quot;MTim\n&quot;);</a>
<a name="ln766">			fPackageFile-&gt;Read(&amp;mtime, 4);</a>
<a name="ln767">			swap_data(B_UINT32_TYPE, &amp;mtime, sizeof(uint32),</a>
<a name="ln768">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln769">		} else if (!memcmp(buffer, &quot;OffT&quot;, 5)) {</a>
<a name="ln770">			if (element == P_NONE) {</a>
<a name="ln771">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln772">			}</a>
<a name="ln773"> </a>
<a name="ln774">			parser_debug(&quot;OffT\n&quot;);</a>
<a name="ln775">			fPackageFile-&gt;Read(&amp;offset, 8);</a>
<a name="ln776">			swap_data(B_UINT64_TYPE, &amp;offset, sizeof(uint64),</a>
<a name="ln777">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln778">		} else if (!memcmp(buffer, &quot;Mime&quot;, 5)) {</a>
<a name="ln779">			if (element != P_FILE) {</a>
<a name="ln780">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln781">			}</a>
<a name="ln782"> </a>
<a name="ln783">			fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln784">			swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln785">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln786"> </a>
<a name="ln787">			char *mime = new char[length + 1];</a>
<a name="ln788">			fPackageFile-&gt;Read(mime, length);</a>
<a name="ln789">			mime[length] = 0;</a>
<a name="ln790">			parser_debug(&quot;Mime: %s\n&quot;, mime);</a>
<a name="ln791"> </a>
<a name="ln792">			mimeString = mime;</a>
<a name="ln793">			delete[] mime;</a>
<a name="ln794">		} else if (!memcmp(buffer, &quot;CmpS&quot;, 5)) {</a>
<a name="ln795">			if (element == P_NONE) {</a>
<a name="ln796">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln797">			}</a>
<a name="ln798"> </a>
<a name="ln799">			parser_debug(&quot;CmpS\n&quot;);</a>
<a name="ln800">			fPackageFile-&gt;Read(&amp;size, 8);</a>
<a name="ln801">			swap_data(B_UINT64_TYPE, &amp;size, sizeof(uint64),</a>
<a name="ln802">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln803">		} else if (!memcmp(buffer, &quot;OrgS&quot;, 5)) {</a>
<a name="ln804">			if (element != P_FILE &amp;&amp; element != P_LINK &amp;&amp; element != P_SCRIPT) {</a>
<a name="ln805">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln806">			}</a>
<a name="ln807"> </a>
<a name="ln808">			parser_debug(&quot;OrgS\n&quot;);</a>
<a name="ln809">			fPackageFile-&gt;Read(&amp;originalSize, 8);</a>
<a name="ln810">			swap_data(B_UINT64_TYPE, &amp;originalSize, sizeof(uint64),</a>
<a name="ln811">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln812">		} else if (!memcmp(buffer, &quot;VrsI&quot;, 5)) {</a>
<a name="ln813">			if (element != P_FILE) {</a>
<a name="ln814">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln815">			}</a>
<a name="ln816"> </a>
<a name="ln817">			parser_debug(&quot;VrsI\n&quot;);</a>
<a name="ln818">			fPackageFile-&gt;Seek(24, SEEK_CUR);</a>
<a name="ln819">			// TODO</a>
<a name="ln820">			// Also, check what those empty 20 bytes mean</a>
<a name="ln821">		} else if (!memcmp(buffer, &quot;Mode&quot;, 5)) {</a>
<a name="ln822">			if (element != P_FILE &amp;&amp; element != P_LINK) {</a>
<a name="ln823">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln824">			}</a>
<a name="ln825"> </a>
<a name="ln826">			parser_debug(&quot;Mode\n&quot;);</a>
<a name="ln827">			fPackageFile-&gt;Read(&amp;mode, 4);</a>
<a name="ln828">			swap_data(B_UINT32_TYPE, &amp;mode, sizeof(uint32),</a>
<a name="ln829">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln830">		} else if (!memcmp(buffer, &quot;FDat&quot;, 5)) {</a>
<a name="ln831">			if (element != P_DIRECTORY) {</a>
<a name="ln832">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln833">			}</a>
<a name="ln834"> </a>
<a name="ln835">			parser_debug(&quot;FDat\n&quot;);</a>
<a name="ln836">		} else if (!memcmp(buffer, &quot;ASig&quot;, 5)) {</a>
<a name="ln837">			if (element != P_FILE) {</a>
<a name="ln838">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln839">			}</a>
<a name="ln840"> </a>
<a name="ln841">			fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln842">			swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln843">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln844"> </a>
<a name="ln845">			char *signature = new char[length + 1];</a>
<a name="ln846">			fPackageFile-&gt;Read(signature, length);</a>
<a name="ln847">			signature[length] = 0;</a>
<a name="ln848">			parser_debug(&quot;Signature: %s\n&quot;, signature);</a>
<a name="ln849"> </a>
<a name="ln850">			signatureString = signature;</a>
<a name="ln851">			delete[] signature;</a>
<a name="ln852">		} else if (!memcmp(buffer, &quot;Link&quot;, 5)) {</a>
<a name="ln853">			if (element != P_LINK) {</a>
<a name="ln854">				RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln855">			}</a>
<a name="ln856"> </a>
<a name="ln857">			fPackageFile-&gt;Read(&amp;length, 4);</a>
<a name="ln858">			swap_data(B_UINT32_TYPE, &amp;length, sizeof(uint32),</a>
<a name="ln859">				B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln860"> </a>
<a name="ln861">			char *link = new char[length + 1];</a>
<a name="ln862">			fPackageFile-&gt;Read(link, length);</a>
<a name="ln863">			link[length] = 0;</a>
<a name="ln864">			parser_debug(&quot;Link: %s\n&quot;, link);</a>
<a name="ln865"> </a>
<a name="ln866">			linkString = link;</a>
<a name="ln867">			delete[] link;</a>
<a name="ln868">		} else if (!memcmp(buffer, padding, 7)) {</a>
<a name="ln869">			PackageItem *item = NULL;</a>
<a name="ln870"> </a>
<a name="ln871">			parser_debug(&quot;Padding!\n&quot;);</a>
<a name="ln872">			if (platform != 0xffffffff</a>
<a name="ln873">				&amp;&amp; static_cast&lt;platform_type&gt;(platform) != thisPlatform) {</a>
<a name="ln874">				// If the file/directory/item's platform is different than the</a>
<a name="ln875">				// target platform (or different than the 'any' constant),</a>
<a name="ln876">				// ignore this file</a>
<a name="ln877">			} else if (element == P_FILE) {</a>
<a name="ln878">				if (itemGroups &amp;&amp; offset &amp;&amp; size) {</a>
<a name="ln879">					BString dest = &quot;&quot;;</a>
<a name="ln880">					uint8 localType = pathType;</a>
<a name="ln881"> </a>
<a name="ln882">					if (path == 0xfffffffe)</a>
<a name="ln883">						dest &lt;&lt; itemPath &lt;&lt; &quot;/&quot; &lt;&lt; nameString.String();</a>
<a name="ln884">					else if (path == 0xffffffff) {</a>
<a name="ln885">						localType = P_INSTALL_PATH;</a>
<a name="ln886">						dest = installDirectory;</a>
<a name="ln887">						dest &lt;&lt; nameString;</a>
<a name="ln888">					} else {</a>
<a name="ln889">						if (cust) {</a>
<a name="ln890">							BString *def = static_cast&lt;BString *&gt;(</a>
<a name="ln891">								userPaths.ItemAt(path));</a>
<a name="ln892">							if (!def) {</a>
<a name="ln893">								RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln894">							}</a>
<a name="ln895">							if ((*def)[0] == '/')</a>
<a name="ln896">								localType = P_SYSTEM_PATH;</a>
<a name="ln897">							else</a>
<a name="ln898">								localType = P_USER_PATH;</a>
<a name="ln899"> </a>
<a name="ln900">							dest &lt;&lt; *def &lt;&lt; &quot;/&quot; &lt;&lt; nameString;</a>
<a name="ln901">						} else {</a>
<a name="ln902">							BPath *def = static_cast&lt;BPath *&gt;(</a>
<a name="ln903">								systemPaths.ItemAt(path));</a>
<a name="ln904">							if (!def) {</a>
<a name="ln905">								RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln906">							}</a>
<a name="ln907">							localType = P_SYSTEM_PATH;</a>
<a name="ln908"> </a>
<a name="ln909">							dest &lt;&lt; def-&gt;Path() &lt;&lt; &quot;/&quot; &lt;&lt; nameString;</a>
<a name="ln910">						}</a>
<a name="ln911">					}</a>
<a name="ln912"> </a>
<a name="ln913">					parser_debug(&quot;Adding file: %s!\n&quot;, dest.String());</a>
<a name="ln914"> </a>
<a name="ln915">					item = new PackageFile(fPackageFile, dest, localType, ctime,</a>
<a name="ln916">						mtime, offset, size, originalSize, 0, mimeString,</a>
<a name="ln917">						signatureString, mode);</a>
<a name="ln918">				}</a>
<a name="ln919">			} else if (element == P_DIRECTORY) {</a>
<a name="ln920">				if (itemGroups) {</a>
<a name="ln921">					if (installDirectoryFlag != 0) {</a>
<a name="ln922">						if (installDirectoryFlag &lt; 0) {</a>
<a name="ln923">							// Normal directory</a>
<a name="ln924">							if (path == 0xfffffffe) {</a>
<a name="ln925">								// Install to current directory</a>
<a name="ln926">								itemPath &lt;&lt; &quot;/&quot; &lt;&lt; nameString.String();</a>
<a name="ln927">								directoryCount++;</a>
<a name="ln928">							} else if (path == 0xffffffff) {</a>
<a name="ln929">								// Install to install directory</a>
<a name="ln930">								pathType = P_INSTALL_PATH;</a>
<a name="ln931">								itemPath = installDirectory;</a>
<a name="ln932">								itemPath &lt;&lt; nameString;</a>
<a name="ln933">								directoryCount = 1;</a>
<a name="ln934">							} else {</a>
<a name="ln935">								// Install to defined directory</a>
<a name="ln936">								if (cust) {</a>
<a name="ln937">									BString *def = static_cast&lt;BString *&gt;(</a>
<a name="ln938">										userPaths.ItemAt(path));</a>
<a name="ln939">									if (!def) {</a>
<a name="ln940">										RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln941">									}</a>
<a name="ln942">									if ((*def)[0] == '/')</a>
<a name="ln943">										pathType = P_SYSTEM_PATH;</a>
<a name="ln944">									else</a>
<a name="ln945">										pathType = P_USER_PATH;</a>
<a name="ln946"> </a>
<a name="ln947">									itemPath = *def;</a>
<a name="ln948">								} else {</a>
<a name="ln949">									BPath *def = static_cast&lt;BPath *&gt;(</a>
<a name="ln950">										systemPaths.ItemAt(path));</a>
<a name="ln951">									if (!def) {</a>
<a name="ln952">										RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln953">									}</a>
<a name="ln954">									pathType = P_SYSTEM_PATH;</a>
<a name="ln955"> </a>
<a name="ln956">									itemPath = def-&gt;Path();</a>
<a name="ln957">								}</a>
<a name="ln958"> </a>
<a name="ln959">								itemPath &lt;&lt; &quot;/&quot; &lt;&lt; nameString;</a>
<a name="ln960">								directoryCount = 1;</a>
<a name="ln961">							}</a>
<a name="ln962">						} else {</a>
<a name="ln963">							// Install directory</a>
<a name="ln964">							if (path != 0xffffffff) {</a>
<a name="ln965">								RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln966">							}</a>
<a name="ln967"> </a>
<a name="ln968">							installDirectory = nameString;</a>
<a name="ln969">							installDirectory &lt;&lt; &quot;/&quot;;</a>
<a name="ln970">							pathType = P_INSTALL_PATH;</a>
<a name="ln971">							itemPath = nameString;</a>
<a name="ln972"> </a>
<a name="ln973">							installDirectoryFlag = -1;</a>
<a name="ln974">						}</a>
<a name="ln975"> </a>
<a name="ln976">						parser_debug(&quot;Adding the directory %s!\n&quot;,</a>
<a name="ln977">							itemPath.String());</a>
<a name="ln978"> </a>
<a name="ln979">						item = new PackageDirectory(fPackageFile, itemPath,</a>
<a name="ln980">							pathType, ctime, mtime, offset, size);</a>
<a name="ln981">					} else</a>
<a name="ln982">						installDirectoryFlag = -1;</a>
<a name="ln983">				}</a>
<a name="ln984">			} else if (element == P_LINK) {</a>
<a name="ln985">				if (itemGroups &amp;&amp; linkString.Length()) {</a>
<a name="ln986">					BString dest = &quot;&quot;;</a>
<a name="ln987">					uint8 localType = pathType;</a>
<a name="ln988"> </a>
<a name="ln989">					if (path == 0xfffffffe)</a>
<a name="ln990">						dest &lt;&lt; itemPath &lt;&lt; &quot;/&quot; &lt;&lt; nameString.String();</a>
<a name="ln991">					else if (path == 0xffffffff) {</a>
<a name="ln992">						localType = P_INSTALL_PATH;</a>
<a name="ln993">						dest = installDirectory;</a>
<a name="ln994">						dest &lt;&lt; nameString;</a>
<a name="ln995">					} else {</a>
<a name="ln996">						if (cust) {</a>
<a name="ln997">							BString *def = static_cast&lt;BString *&gt;(</a>
<a name="ln998">								userPaths.ItemAt(path));</a>
<a name="ln999">							if (!def) {</a>
<a name="ln1000">								RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln1001">							}</a>
<a name="ln1002">							if ((*def)[0] == '/')</a>
<a name="ln1003">								localType = P_SYSTEM_PATH;</a>
<a name="ln1004">							else</a>
<a name="ln1005">								localType = P_USER_PATH;</a>
<a name="ln1006"> </a>
<a name="ln1007">							dest &lt;&lt; *def &lt;&lt; &quot;/&quot; &lt;&lt; nameString;</a>
<a name="ln1008">						} else {</a>
<a name="ln1009">							BPath *def = static_cast&lt;BPath *&gt;(systemPaths.ItemAt(path));</a>
<a name="ln1010">							if (!def) {</a>
<a name="ln1011">								RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln1012">							}</a>
<a name="ln1013">							localType = P_SYSTEM_PATH;</a>
<a name="ln1014"> </a>
<a name="ln1015">							dest &lt;&lt; def-&gt;Path() &lt;&lt; &quot;/&quot; &lt;&lt; nameString;</a>
<a name="ln1016">						}</a>
<a name="ln1017">					}</a>
<a name="ln1018"> </a>
<a name="ln1019">					parser_debug(&quot;Adding link: %s! (type %s)\n&quot;, dest.String(),</a>
<a name="ln1020">						pathType == P_SYSTEM_PATH</a>
<a name="ln1021">							? &quot;System&quot; : localType == P_INSTALL_PATH</a>
<a name="ln1022">							? &quot;Install&quot; : &quot;User&quot;);</a>
<a name="ln1023"> </a>
<a name="ln1024">					item = new PackageLink(fPackageFile, dest, linkString,</a>
<a name="ln1025">						localType, ctime, mtime, mode, offset, size);</a>
<a name="ln1026">				}</a>
<a name="ln1027">			} else if (element == P_SCRIPT) {</a>
<a name="ln1028">				parser_debug(&quot;Adding the script %s!\n&quot;,</a>
<a name="ln1029">					nameString.String());</a>
<a name="ln1030"> </a>
<a name="ln1031">				BString workingDirectory;</a>
<a name="ln1032">				uint8 localType = P_SYSTEM_PATH;</a>
<a name="ln1033">				if (path == 1)</a>
<a name="ln1034">					workingDirectory &lt;&lt; itemPath;</a>
<a name="ln1035">				else if (path == 0xffffffff) {</a>
<a name="ln1036">					workingDirectory &lt;&lt; installDirectory;</a>
<a name="ln1037">					localType = P_INSTALL_PATH;</a>
<a name="ln1038">				}</a>
<a name="ln1039"> </a>
<a name="ln1040">				fScripts.AddItem(new PackageScript(fPackageFile,</a>
<a name="ln1041">					workingDirectory, localType, offset, size, originalSize));</a>
<a name="ln1042">			} else {</a>
<a name="ln1043">				// If the directory tree count is equal to zero, this means all</a>
<a name="ln1044">				// directory trees have been closed and a padding sequence means the</a>
<a name="ln1045">				// end of the section</a>
<a name="ln1046">				if (directoryCount == 0)</a>
<a name="ln1047">					break;</a>
<a name="ln1048">				ret = itemPath.FindLast('/');</a>
<a name="ln1049">				if (ret == B_ERROR) {</a>
<a name="ln1050">					itemPath = &quot;&quot;;</a>
<a name="ln1051">				}</a>
<a name="ln1052">				else {</a>
<a name="ln1053">					itemPath.Truncate(ret);</a>
<a name="ln1054">				}</a>
<a name="ln1055">				directoryCount--;</a>
<a name="ln1056">			}</a>
<a name="ln1057"> </a>
<a name="ln1058">			if (item) {</a>
<a name="ln1059">				_AddItem(item, originalSize, itemGroups, path, cust);</a>
<a name="ln1060">			}</a>
<a name="ln1061"> </a>
<a name="ln1062">			element = P_NONE;</a>
<a name="ln1063">		} else if (!memcmp(buffer, &quot;PkgA&quot;, 5)) {</a>
<a name="ln1064">			parser_debug(&quot;PkgA\n&quot;);</a>
<a name="ln1065">			break;</a>
<a name="ln1066">		} else if (!memcmp(buffer, &quot;PtcI&quot;, 5)) {</a>
<a name="ln1067">			parser_debug(&quot;PtcI\n&quot;);</a>
<a name="ln1068">			break;</a>
<a name="ln1069">		} else {</a>
<a name="ln1070">			fprintf(stderr, &quot;Unknown file tag %s\n&quot;, buffer);</a>
<a name="ln1071">			RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln1072">		}</a>
<a name="ln1073">	}</a>
<a name="ln1074"> </a>
<a name="ln1075">	if (static_cast&lt;uint64&gt;(actualSize) != fileSize) {</a>
<a name="ln1076">		// Inform the user of a possible error</a>
<a name="ln1077">		int32 selection;</a>
<a name="ln1078">		BAlert *warning = new BAlert(&quot;filesize_wrong&quot;,</a>
<a name="ln1079">			B_TRANSLATE(&quot;There seems to be a file size mismatch in the &quot;</a>
<a name="ln1080">				&quot;package file. The package might be corrupted or have been &quot;</a>
<a name="ln1081">				&quot;modified after its creation. Do you still wish to continue?&quot;),</a>
<a name="ln1082">				B_TRANSLATE(&quot;Continue&quot;),</a>
<a name="ln1083">				B_TRANSLATE(&quot;Abort&quot;), NULL,</a>
<a name="ln1084">			B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1085">		warning-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln1086">		selection = warning-&gt;Go();</a>
<a name="ln1087"> </a>
<a name="ln1088">		if (selection == 1) {</a>
<a name="ln1089">			RETURN_AND_SET_STATUS(B_ERROR);</a>
<a name="ln1090">		}</a>
<a name="ln1091">	}</a>
<a name="ln1092"> </a>
<a name="ln1093">	if (!groups.IsEmpty())</a>
<a name="ln1094">		fProfiles = groups;</a>
<a name="ln1095"> </a>
<a name="ln1096">	return B_OK;</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099"> </a>
<a name="ln1100">void</a>
<a name="ln1101">PackageInfo::_AddItem(PackageItem *item, uint64 size, uint32 groups,</a>
<a name="ln1102">	uint32 path, uint32 cust)</a>
<a name="ln1103">{</a>
<a name="ln1104">	// Add the item to all groups it resides in</a>
<a name="ln1105">	uint32 i, n = fProfiles.CountItems(), mask = 1;</a>
<a name="ln1106">	pkg_profile *profile;</a>
<a name="ln1107"> </a>
<a name="ln1108">	fFiles.AddItem(item);</a>
<a name="ln1109"> </a>
<a name="ln1110">	for (i = 0;i &lt; n;i++) {</a>
<a name="ln1111">		if (groups &amp; mask) {</a>
<a name="ln1112">			profile = static_cast&lt;pkg_profile *&gt;(fProfiles.ItemAt(i));</a>
<a name="ln1113">			profile-&gt;items.AddItem(item);</a>
<a name="ln1114">			profile-&gt;space_needed += size;</a>
<a name="ln1115">			// If there is at least one non-predefined destination element</a>
<a name="ln1116">			// in the package, we give the user the ability to select the</a>
<a name="ln1117">			// installation directory.</a>
<a name="ln1118">			// If there are only predefined path files in the package, but</a>
<a name="ln1119">			// such defined by the user, the user will be able to select</a>
<a name="ln1120">			// the destination volume</a>
<a name="ln1121">			if (path == 0xffffffff)</a>
<a name="ln1122">				profile-&gt;path_type = P_INSTALL_PATH;</a>
<a name="ln1123">			else if (path &lt; 0xfffffffe &amp;&amp;</a>
<a name="ln1124">					profile-&gt;path_type != P_INSTALL_PATH) {</a>
<a name="ln1125">				if (cust) {</a>
<a name="ln1126">					profile-&gt;path_type = P_USER_PATH;</a>
<a name="ln1127">				}</a>
<a name="ln1128">			}</a>
<a name="ln1129">		}</a>
<a name="ln1130">		mask = mask &lt;&lt; 1;</a>
<a name="ln1131">	}</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>

</code></pre>
<div class="balloon" rel="1089"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'warning' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
