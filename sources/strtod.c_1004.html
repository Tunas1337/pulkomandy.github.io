
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>strtod.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* [zooey]:</a>
<a name="ln2"> * This implementation is broken, as e.g. strtod(&quot;1.7E+064&quot;, ...) yields an</a>
<a name="ln3"> * incorrect (inaccurate) result.</a>
<a name="ln4"> * For libroot, we use the glibc version instead.</a>
<a name="ln5"> * This file is still used in the kernel, however, since I didn't dare</a>
<a name="ln6"> * introducing a glibc-based source into the kernel.</a>
<a name="ln7"> * So, currently we have to live with the fact that strtod() in our kernel</a>
<a name="ln8"> * gives somewhat inaccurate results.</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11">/*-</a>
<a name="ln12"> * Copyright (c) 1993</a>
<a name="ln13"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln14"> *</a>
<a name="ln15"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln16"> * modification, are permitted provided that the following conditions</a>
<a name="ln17"> * are met:</a>
<a name="ln18"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln19"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln20"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln21"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln22"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln23"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln24"> *    must display the following acknowledgement:</a>
<a name="ln25"> *	This product includes software developed by the University of</a>
<a name="ln26"> *	California, Berkeley and its contributors.</a>
<a name="ln27"> * 4. Neither the name of the University nor the names of its contributors</a>
<a name="ln28"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln29"> *    without specific prior written permission.</a>
<a name="ln30"> *</a>
<a name="ln31"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln32"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln33"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln34"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln35"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln36"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln37"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln38"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln39"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln40"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln41"> * SUCH DAMAGE.</a>
<a name="ln42"> */</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">/****************************************************************</a>
<a name="ln46"> *</a>
<a name="ln47"> * The author of this software is David M. Gay.</a>
<a name="ln48"> *</a>
<a name="ln49"> * Copyright (c) 1991 by AT&amp;T.</a>
<a name="ln50"> *</a>
<a name="ln51"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln52"> * purpose without fee is hereby granted, provided that this entire notice</a>
<a name="ln53"> * is included in all copies of any software which is or includes a copy</a>
<a name="ln54"> * or modification of this software and in all copies of the supporting</a>
<a name="ln55"> * documentation for such software.</a>
<a name="ln56"> *</a>
<a name="ln57"> * THIS SOFTWARE IS BEING PROVIDED &quot;AS IS&quot;, WITHOUT ANY EXPRESS OR IMPLIED</a>
<a name="ln58"> * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR AT&amp;T MAKES ANY</a>
<a name="ln59"> * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY</a>
<a name="ln60"> * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.</a>
<a name="ln61"> *</a>
<a name="ln62"> ***************************************************************/</a>
<a name="ln63"> </a>
<a name="ln64">/* Please send bug reports to</a>
<a name="ln65">	David M. Gay</a>
<a name="ln66">	AT&amp;T Bell Laboratories, Room 2C-463</a>
<a name="ln67">	600 Mountain Avenue</a>
<a name="ln68">	Murray Hill, NJ 07974-2070</a>
<a name="ln69">	U.S.A.</a>
<a name="ln70">	dmg@research.att.com or research!dmg</a>
<a name="ln71"> */</a>
<a name="ln72"> </a>
<a name="ln73">/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.</a>
<a name="ln74"> *</a>
<a name="ln75"> * This strtod returns a nearest machine number to the input decimal</a>
<a name="ln76"> * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are</a>
<a name="ln77"> * broken by the IEEE round-even rule.  Otherwise ties are broken by</a>
<a name="ln78"> * biased rounding (add half and chop).</a>
<a name="ln79"> *</a>
<a name="ln80"> * Inspired loosely by William D. Clinger's paper &quot;How to Read Floating</a>
<a name="ln81"> * Point Numbers Accurately&quot; [Proc. ACM SIGPLAN '90, pp. 92-101].</a>
<a name="ln82"> *</a>
<a name="ln83"> * Modifications:</a>
<a name="ln84"> *</a>
<a name="ln85"> *	1. We only require IEEE, IBM, or VAX double-precision</a>
<a name="ln86"> *		arithmetic (not IEEE double-extended).</a>
<a name="ln87"> *	2. We get by with floating-point arithmetic in a case that</a>
<a name="ln88"> *		Clinger missed -- when we're computing d * 10^n</a>
<a name="ln89"> *		for a small integer d and the integer n is not too</a>
<a name="ln90"> *		much larger than 22 (the maximum integer k for which</a>
<a name="ln91"> *		we can represent 10^k exactly), we may be able to</a>
<a name="ln92"> *		compute (d*10^k) * 10^(e-k) with just one roundoff.</a>
<a name="ln93"> *	3. Rather than a bit-at-a-time adjustment of the binary</a>
<a name="ln94"> *		result in the hard case, we use floating-point</a>
<a name="ln95"> *		arithmetic to determine the adjustment to within</a>
<a name="ln96"> *		one bit; only in really hard cases do we need to</a>
<a name="ln97"> *		compute a second residual.</a>
<a name="ln98"> *	4. Because of 3., we don't need a large table of powers of 10</a>
<a name="ln99"> *		for ten-to-e (just some small tables, e.g. of 10^k</a>
<a name="ln100"> *		for 0 &lt;= k &lt;= 22).</a>
<a name="ln101"> */</a>
<a name="ln102"> </a>
<a name="ln103">/*</a>
<a name="ln104"> * #define Sudden_Underflow for IEEE-format machines without gradual</a>
<a name="ln105"> *	underflow (i.e., that flush to zero on underflow).</a>
<a name="ln106"> * #define IBM for IBM mainframe-style floating-point arithmetic.</a>
<a name="ln107"> * #define VAX for VAX-style floating-point arithmetic.</a>
<a name="ln108"> * #define Unsigned_Shifts if &gt;&gt; does treats its left operand as unsigned.</a>
<a name="ln109"> * #define No_leftright to omit left-right logic in fast floating-point</a>
<a name="ln110"> *	computation of dtoa.</a>
<a name="ln111"> * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3.</a>
<a name="ln112"> * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines</a>
<a name="ln113"> *	that use extended-precision instructions to compute rounded</a>
<a name="ln114"> *	products and quotients) with IBM.</a>
<a name="ln115"> * #define ROUND_BIASED for IEEE-format with biased rounding.</a>
<a name="ln116"> * #define Inaccurate_Divide for IEEE-format with correctly rounded</a>
<a name="ln117"> *	products but inaccurate quotients, e.g., for Intel i860.</a>
<a name="ln118"> * #define Just_16 to store 16 bits per 32-bit Long when doing high-precision</a>
<a name="ln119"> *	integer arithmetic.  Whether this speeds things up or slows things</a>
<a name="ln120"> *	down depends on the machine and the number being converted.</a>
<a name="ln121"> * #define Bad_float_h if your system lacks a float.h or if it does not</a>
<a name="ln122"> *	define some or all of DBL_DIG, DBL_MAX_10_EXP, DBL_MAX_EXP,</a>
<a name="ln123"> *	FLT_RADIX, FLT_ROUNDS, and DBL_MAX.</a>
<a name="ln124"> */</a>
<a name="ln125"> </a>
<a name="ln126">#if defined(__i386__) || defined(__ia64__) || defined(__alpha__) || \</a>
<a name="ln127">    defined(__sparc64__) || defined(__powerpc__) || defined(__POWERPC__) || \</a>
<a name="ln128">    defined(__m68k__) || defined(__M68K__) || defined(__arm__) || \</a>
<a name="ln129">    defined(__mipsel__) || defined(__MIPSEL__) || defined(__x86_64__) || \</a>
<a name="ln130">    defined(__riscv64__)</a>
<a name="ln131">#	include &lt;sys/types.h&gt;</a>
<a name="ln132">#	if BYTE_ORDER == BIG_ENDIAN</a>
<a name="ln133">#		define IEEE_BIG_ENDIAN</a>
<a name="ln134">#	else</a>
<a name="ln135">#		define IEEE_LITTLE_ENDIAN</a>
<a name="ln136">#	endif</a>
<a name="ln137">#endif /* defined(__i386__) ... */</a>
<a name="ln138"> </a>
<a name="ln139">#include &lt;inttypes.h&gt;</a>
<a name="ln140"> </a>
<a name="ln141">typedef	int32_t   Long;</a>
<a name="ln142">typedef	u_int32_t ULong;</a>
<a name="ln143"> </a>
<a name="ln144">#ifdef DEBUG</a>
<a name="ln145">#	if	_KERNEL_MODE</a>
<a name="ln146">#		include &lt;KernelExport.h&gt;</a>
<a name="ln147">#		define Bug(x) {dprintf(&quot;%s\n&quot;, x);}</a>
<a name="ln148">#	else</a>
<a name="ln149">#		include &lt;stdio.h&gt;</a>
<a name="ln150">#		define Bug(x) {fprintf(stderr, &quot;%s\n&quot;, x); exit(1);}</a>
<a name="ln151">#	endif</a>
<a name="ln152">#endif</a>
<a name="ln153"> </a>
<a name="ln154">#include &lt;locale.h&gt;</a>
<a name="ln155">#include &lt;stdlib.h&gt;</a>
<a name="ln156">#include &lt;string.h&gt;</a>
<a name="ln157"> </a>
<a name="ln158">#include &lt;errno.h&gt;</a>
<a name="ln159">#include &lt;ctype.h&gt;</a>
<a name="ln160"> </a>
<a name="ln161">#include &lt;errno_private.h&gt;</a>
<a name="ln162"> </a>
<a name="ln163">#ifdef Bad_float_h</a>
<a name="ln164">#undef __STDC__</a>
<a name="ln165">#ifdef IEEE_BIG_ENDIAN</a>
<a name="ln166">#	define IEEE_ARITHMETIC</a>
<a name="ln167">#endif</a>
<a name="ln168">#ifdef IEEE_LITTLE_ENDIAN</a>
<a name="ln169">#	define IEEE_ARITHMETIC</a>
<a name="ln170">#endif</a>
<a name="ln171">#ifdef IEEE_ARITHMETIC</a>
<a name="ln172">#	define DBL_DIG 15</a>
<a name="ln173">#	define DBL_MAX_10_EXP 308</a>
<a name="ln174">#	define DBL_MAX_EXP 1024</a>
<a name="ln175">#	define FLT_RADIX 2</a>
<a name="ln176">#	define FLT_ROUNDS 1</a>
<a name="ln177">#	define DBL_MAX 1.7976931348623157e+308</a>
<a name="ln178">#endif</a>
<a name="ln179"> </a>
<a name="ln180">#ifdef IBM</a>
<a name="ln181">#	define DBL_DIG 16</a>
<a name="ln182">#	define DBL_MAX_10_EXP 75</a>
<a name="ln183">#	define DBL_MAX_EXP 63</a>
<a name="ln184">#	define FLT_RADIX 16</a>
<a name="ln185">#	define FLT_ROUNDS 0</a>
<a name="ln186">#	define DBL_MAX 7.2370055773322621e+75</a>
<a name="ln187">#endif</a>
<a name="ln188"> </a>
<a name="ln189">#ifdef VAX</a>
<a name="ln190">#	define DBL_DIG 16</a>
<a name="ln191">#	define DBL_MAX_10_EXP 38</a>
<a name="ln192">#	define DBL_MAX_EXP 127</a>
<a name="ln193">#	define FLT_RADIX 2</a>
<a name="ln194">#	define FLT_ROUNDS 1</a>
<a name="ln195">#	define DBL_MAX 1.7014118346046923e+38</a>
<a name="ln196">#endif</a>
<a name="ln197"> </a>
<a name="ln198">#ifndef LONG_MAX</a>
<a name="ln199">#	define LONG_MAX 2147483647</a>
<a name="ln200">#endif</a>
<a name="ln201">#else</a>
<a name="ln202">#	include &quot;float.h&quot;</a>
<a name="ln203">#endif</a>
<a name="ln204">#ifndef __MATH_H__</a>
<a name="ln205">#	include &quot;math.h&quot;</a>
<a name="ln206">#endif</a>
<a name="ln207"> </a>
<a name="ln208">#ifdef __cplusplus</a>
<a name="ln209">extern &quot;C&quot; {</a>
<a name="ln210">#endif</a>
<a name="ln211"> </a>
<a name="ln212">#ifdef Unsigned_Shifts</a>
<a name="ln213">#	define Sign_Extend(a,b) if (b &lt; 0) a |= 0xffff0000;</a>
<a name="ln214">#else</a>
<a name="ln215">#	define Sign_Extend(a,b) /*no-op*/</a>
<a name="ln216">#endif</a>
<a name="ln217"> </a>
<a name="ln218">#if defined(IEEE_LITTLE_ENDIAN) + defined(IEEE_BIG_ENDIAN) + defined(VAX) + \</a>
<a name="ln219">    defined(IBM) != 1</a>
<a name="ln220">#error Only one of IEEE_LITTLE_ENDIAN, IEEE_BIG_ENDIAN, VAX, or IBM should be defined.</a>
<a name="ln221">#endif</a>
<a name="ln222"> </a>
<a name="ln223">union doubleasulongs {</a>
<a name="ln224">	double x;</a>
<a name="ln225">	ULong w[2];</a>
<a name="ln226">};</a>
<a name="ln227"> </a>
<a name="ln228">#ifdef IEEE_LITTLE_ENDIAN</a>
<a name="ln229">#	define word0(x) (((union doubleasulongs *)&amp;x)-&gt;w)[1]</a>
<a name="ln230">#	define word1(x) (((union doubleasulongs *)&amp;x)-&gt;w)[0]</a>
<a name="ln231">#else</a>
<a name="ln232">#	define word0(x) (((union doubleasulongs *)&amp;x)-&gt;w)[0]</a>
<a name="ln233">#	define word1(x) (((union doubleasulongs *)&amp;x)-&gt;w)[1]</a>
<a name="ln234">#endif</a>
<a name="ln235"> </a>
<a name="ln236">/* The following definition of Storeinc is appropriate for MIPS processors.</a>
<a name="ln237"> * An alternative that might be better on some machines is</a>
<a name="ln238"> * #define Storeinc(a,b,c) (*a++ = b &lt;&lt; 16 | c &amp; 0xffff)</a>
<a name="ln239"> */</a>
<a name="ln240">#if defined(IEEE_LITTLE_ENDIAN) + defined(VAX)</a>
<a name="ln241">#	define Storeinc(a,b,c) (((unsigned short *)a)[1] = (unsigned short)b, \</a>
<a name="ln242">		((unsigned short *)a)[0] = (unsigned short)c, a++)</a>
<a name="ln243">#else</a>
<a name="ln244">#	define Storeinc(a,b,c) (((unsigned short *)a)[0] = (unsigned short)b, \</a>
<a name="ln245">		((unsigned short *)a)[1] = (unsigned short)c, a++)</a>
<a name="ln246">#endif</a>
<a name="ln247"> </a>
<a name="ln248">/* #define P DBL_MANT_DIG */</a>
<a name="ln249">/* Ten_pmax = floor(P*log(2)/log(5)) */</a>
<a name="ln250">/* Bletch = (highest power of 2 &lt; DBL_MAX_10_EXP) / 16 */</a>
<a name="ln251">/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */</a>
<a name="ln252">/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */</a>
<a name="ln253"> </a>
<a name="ln254">#if defined(IEEE_LITTLE_ENDIAN) + defined(IEEE_BIG_ENDIAN)</a>
<a name="ln255">#define Exp_shift  20</a>
<a name="ln256">#define Exp_shift1 20</a>
<a name="ln257">#define Exp_msk1    0x100000</a>
<a name="ln258">#define Exp_msk11   0x100000</a>
<a name="ln259">#define Exp_mask  0x7ff00000</a>
<a name="ln260">#define P 53</a>
<a name="ln261">#define Bias 1023</a>
<a name="ln262">#define IEEE_Arith</a>
<a name="ln263">#define Emin (-1022)</a>
<a name="ln264">#define Exp_1  0x3ff00000</a>
<a name="ln265">#define Exp_11 0x3ff00000</a>
<a name="ln266">#define Ebits 11</a>
<a name="ln267">#define Frac_mask  0xfffff</a>
<a name="ln268">#define Frac_mask1 0xfffff</a>
<a name="ln269">#define Ten_pmax 22</a>
<a name="ln270">#define Bletch 0x10</a>
<a name="ln271">#define Bndry_mask  0xfffff</a>
<a name="ln272">#define Bndry_mask1 0xfffff</a>
<a name="ln273">#define LSB 1</a>
<a name="ln274">#define Sign_bit 0x80000000</a>
<a name="ln275">#define Log2P 1</a>
<a name="ln276">#define Tiny0 0</a>
<a name="ln277">#define Tiny1 1</a>
<a name="ln278">#define Quick_max 14</a>
<a name="ln279">#define Int_max 14</a>
<a name="ln280">#define Infinite(x) (word0(x) == 0x7ff00000) /* sufficient test for here */</a>
<a name="ln281">#else</a>
<a name="ln282">#undef  Sudden_Underflow</a>
<a name="ln283">#define Sudden_Underflow</a>
<a name="ln284">#ifdef IBM</a>
<a name="ln285">#define Exp_shift  24</a>
<a name="ln286">#define Exp_shift1 24</a>
<a name="ln287">#define Exp_msk1   0x1000000</a>
<a name="ln288">#define Exp_msk11  0x1000000</a>
<a name="ln289">#define Exp_mask  0x7f000000</a>
<a name="ln290">#define P 14</a>
<a name="ln291">#define Bias 65</a>
<a name="ln292">#define Exp_1  0x41000000</a>
<a name="ln293">#define Exp_11 0x41000000</a>
<a name="ln294">#define Ebits 8	/* exponent has 7 bits, but 8 is the right value in b2d */</a>
<a name="ln295">#define Frac_mask  0xffffff</a>
<a name="ln296">#define Frac_mask1 0xffffff</a>
<a name="ln297">#define Bletch 4</a>
<a name="ln298">#define Ten_pmax 22</a>
<a name="ln299">#define Bndry_mask  0xefffff</a>
<a name="ln300">#define Bndry_mask1 0xffffff</a>
<a name="ln301">#define LSB 1</a>
<a name="ln302">#define Sign_bit 0x80000000</a>
<a name="ln303">#define Log2P 4</a>
<a name="ln304">#define Tiny0 0x100000</a>
<a name="ln305">#define Tiny1 0</a>
<a name="ln306">#define Quick_max 14</a>
<a name="ln307">#define Int_max 15</a>
<a name="ln308">#else /* VAX */</a>
<a name="ln309">#define Exp_shift  23</a>
<a name="ln310">#define Exp_shift1 7</a>
<a name="ln311">#define Exp_msk1    0x80</a>
<a name="ln312">#define Exp_msk11   0x800000</a>
<a name="ln313">#define Exp_mask  0x7f80</a>
<a name="ln314">#define P 56</a>
<a name="ln315">#define Bias 129</a>
<a name="ln316">#define Exp_1  0x40800000</a>
<a name="ln317">#define Exp_11 0x4080</a>
<a name="ln318">#define Ebits 8</a>
<a name="ln319">#define Frac_mask  0x7fffff</a>
<a name="ln320">#define Frac_mask1 0xffff007f</a>
<a name="ln321">#define Ten_pmax 24</a>
<a name="ln322">#define Bletch 2</a>
<a name="ln323">#define Bndry_mask  0xffff007f</a>
<a name="ln324">#define Bndry_mask1 0xffff007f</a>
<a name="ln325">#define LSB 0x10000</a>
<a name="ln326">#define Sign_bit 0x8000</a>
<a name="ln327">#define Log2P 1</a>
<a name="ln328">#define Tiny0 0x80</a>
<a name="ln329">#define Tiny1 0</a>
<a name="ln330">#define Quick_max 15</a>
<a name="ln331">#define Int_max 15</a>
<a name="ln332">#endif</a>
<a name="ln333">#endif</a>
<a name="ln334"> </a>
<a name="ln335">#ifndef IEEE_Arith</a>
<a name="ln336">#define ROUND_BIASED</a>
<a name="ln337">#endif</a>
<a name="ln338"> </a>
<a name="ln339">#ifdef RND_PRODQUOT</a>
<a name="ln340">#define rounded_product(a,b) a = rnd_prod(a, b)</a>
<a name="ln341">#define rounded_quotient(a,b) a = rnd_quot(a, b)</a>
<a name="ln342">extern double rnd_prod(double, double), rnd_quot(double, double);</a>
<a name="ln343">#else</a>
<a name="ln344">#define rounded_product(a,b) a *= b</a>
<a name="ln345">#define rounded_quotient(a,b) a /= b</a>
<a name="ln346">#endif</a>
<a name="ln347"> </a>
<a name="ln348">#define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))</a>
<a name="ln349">#define Big1 0xffffffff</a>
<a name="ln350"> </a>
<a name="ln351">#ifndef Just_16</a>
<a name="ln352">/* When Pack_32 is not defined, we store 16 bits per 32-bit Long.</a>
<a name="ln353"> * This makes some inner loops simpler and sometimes saves work</a>
<a name="ln354"> * during multiplications, but it often seems to make things slightly</a>
<a name="ln355"> * slower.  Hence the default is now to store 32 bits per Long.</a>
<a name="ln356"> */</a>
<a name="ln357">#ifndef Pack_32</a>
<a name="ln358">#define Pack_32</a>
<a name="ln359">#endif</a>
<a name="ln360">#endif</a>
<a name="ln361"> </a>
<a name="ln362">#define Kmax 15</a>
<a name="ln363"> </a>
<a name="ln364">#ifdef __cplusplus</a>
<a name="ln365">extern &quot;C&quot; double strtod(const char *s00, char **se);</a>
<a name="ln366">extern &quot;C&quot; char *__dtoa(double d, int mode, int ndigits,</a>
<a name="ln367">			int *decpt, int *sign, char **rve, char **resultp);</a>
<a name="ln368">#endif</a>
<a name="ln369"> </a>
<a name="ln370">struct</a>
<a name="ln371">Bigint {</a>
<a name="ln372">	struct Bigint *next;</a>
<a name="ln373">	int k, maxwds, sign, wds;</a>
<a name="ln374">	ULong x[1];</a>
<a name="ln375">};</a>
<a name="ln376"> </a>
<a name="ln377">typedef struct Bigint Bigint;</a>
<a name="ln378"> </a>
<a name="ln379">static Bigint *</a>
<a name="ln380">Balloc(int k)</a>
<a name="ln381">{</a>
<a name="ln382">	int x;</a>
<a name="ln383">	Bigint *rv;</a>
<a name="ln384"> </a>
<a name="ln385">	x = 1 &lt;&lt; k;</a>
<a name="ln386">	rv = (Bigint *)malloc(sizeof(Bigint) + (x-1)*sizeof(Long));</a>
<a name="ln387">	rv-&gt;k = k;</a>
<a name="ln388">	rv-&gt;maxwds = x;</a>
<a name="ln389">	rv-&gt;sign = rv-&gt;wds = 0;</a>
<a name="ln390">	return rv;</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393"> </a>
<a name="ln394">static void</a>
<a name="ln395">Bfree(Bigint *v)</a>
<a name="ln396">{</a>
<a name="ln397">	free(v);</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400"> </a>
<a name="ln401">#define Bcopy(x,y) memcpy((char *)&amp;x-&gt;sign, (char *)&amp;y-&gt;sign, \</a>
<a name="ln402">	y-&gt;wds*sizeof(Long) + 2*sizeof(int))</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">static Bigint *</a>
<a name="ln406">multadd(Bigint *b, int m, int a)	/* multiply by m and add a */</a>
<a name="ln407">{</a>
<a name="ln408">	int i, wds;</a>
<a name="ln409">	ULong *x, y;</a>
<a name="ln410">#ifdef Pack_32</a>
<a name="ln411">	ULong xi, z;</a>
<a name="ln412">#endif</a>
<a name="ln413">	Bigint *b1;</a>
<a name="ln414"> </a>
<a name="ln415">	wds = b-&gt;wds;</a>
<a name="ln416">	x = b-&gt;x;</a>
<a name="ln417">	i = 0;</a>
<a name="ln418">	do {</a>
<a name="ln419">#ifdef Pack_32</a>
<a name="ln420">		xi = *x;</a>
<a name="ln421">		y = (xi &amp; 0xffff) * m + a;</a>
<a name="ln422">		z = (xi &gt;&gt; 16) * m + (y &gt;&gt; 16);</a>
<a name="ln423">		a = (int)(z &gt;&gt; 16);</a>
<a name="ln424">		*x++ = (z &lt;&lt; 16) + (y &amp; 0xffff);</a>
<a name="ln425">#else</a>
<a name="ln426">		y = *x * m + a;</a>
<a name="ln427">		a = (int)(y &gt;&gt; 16);</a>
<a name="ln428">		*x++ = y &amp; 0xffff;</a>
<a name="ln429">#endif</a>
<a name="ln430">	} while (++i &lt; wds);</a>
<a name="ln431">	if (a) {</a>
<a name="ln432">		if (wds &gt;= b-&gt;maxwds) {</a>
<a name="ln433">			b1 = Balloc(b-&gt;k+1);</a>
<a name="ln434">			Bcopy(b1, b);</a>
<a name="ln435">			Bfree(b);</a>
<a name="ln436">			b = b1;</a>
<a name="ln437">			}</a>
<a name="ln438">		b-&gt;x[wds++] = a;</a>
<a name="ln439">		b-&gt;wds = wds;</a>
<a name="ln440">	}</a>
<a name="ln441">	return b;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">static Bigint *</a>
<a name="ln446">s2b(const char *s, int nd0, int nd, ULong y9)</a>
<a name="ln447">{</a>
<a name="ln448">	Bigint *b;</a>
<a name="ln449">	int i, k;</a>
<a name="ln450">	Long x, y;</a>
<a name="ln451"> </a>
<a name="ln452">	x = (nd + 8) / 9;</a>
<a name="ln453">	for (k = 0, y = 1; x &gt; y; y &lt;&lt;= 1, k++) ;</a>
<a name="ln454">#ifdef Pack_32</a>
<a name="ln455">	b = Balloc(k);</a>
<a name="ln456">	b-&gt;x[0] = y9;</a>
<a name="ln457">	b-&gt;wds = 1;</a>
<a name="ln458">#else</a>
<a name="ln459">	b = Balloc(k+1);</a>
<a name="ln460">	b-&gt;x[0] = y9 &amp; 0xffff;</a>
<a name="ln461">	b-&gt;wds = (b-&gt;x[1] = y9 &gt;&gt; 16) ? 2 : 1;</a>
<a name="ln462">#endif</a>
<a name="ln463"> </a>
<a name="ln464">	i = 9;</a>
<a name="ln465">	if (9 &lt; nd0) {</a>
<a name="ln466">		s += 9;</a>
<a name="ln467">		do</a>
<a name="ln468">			b = multadd(b, 10, *s++ - '0');</a>
<a name="ln469">		while (++i &lt; nd0);</a>
<a name="ln470">		s++;</a>
<a name="ln471">	} else</a>
<a name="ln472">		s += 10;</a>
<a name="ln473">	for (; i &lt; nd; i++)</a>
<a name="ln474">		b = multadd(b, 10, *s++ - '0');</a>
<a name="ln475">	return b;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478"> </a>
<a name="ln479">static int</a>
<a name="ln480">hi0bits(ULong x)</a>
<a name="ln481">{</a>
<a name="ln482">	int k = 0;</a>
<a name="ln483"> </a>
<a name="ln484">	if (!(x &amp; 0xffff0000)) {</a>
<a name="ln485">		k = 16;</a>
<a name="ln486">		x &lt;&lt;= 16;</a>
<a name="ln487">	}</a>
<a name="ln488">	if (!(x &amp; 0xff000000)) {</a>
<a name="ln489">		k += 8;</a>
<a name="ln490">		x &lt;&lt;= 8;</a>
<a name="ln491">	}</a>
<a name="ln492">	if (!(x &amp; 0xf0000000)) {</a>
<a name="ln493">		k += 4;</a>
<a name="ln494">		x &lt;&lt;= 4;</a>
<a name="ln495">	}</a>
<a name="ln496">	if (!(x &amp; 0xc0000000)) {</a>
<a name="ln497">		k += 2;</a>
<a name="ln498">		x &lt;&lt;= 2;</a>
<a name="ln499">	}</a>
<a name="ln500">	if (!(x &amp; 0x80000000)) {</a>
<a name="ln501">		k++;</a>
<a name="ln502">		if (!(x &amp; 0x40000000))</a>
<a name="ln503">			return 32;</a>
<a name="ln504">	}</a>
<a name="ln505">	return k;</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508"> </a>
<a name="ln509">static int</a>
<a name="ln510">lo0bits(ULong *y)</a>
<a name="ln511">{</a>
<a name="ln512">	int k;</a>
<a name="ln513">	ULong x = *y;</a>
<a name="ln514"> </a>
<a name="ln515">	if (x &amp; 7) {</a>
<a name="ln516">		if (x &amp; 1)</a>
<a name="ln517">			return 0;</a>
<a name="ln518">		if (x &amp; 2) {</a>
<a name="ln519">			*y = x &gt;&gt; 1;</a>
<a name="ln520">			return 1;</a>
<a name="ln521">		}</a>
<a name="ln522">		*y = x &gt;&gt; 2;</a>
<a name="ln523">		return 2;</a>
<a name="ln524">	}</a>
<a name="ln525">	k = 0;</a>
<a name="ln526">	if (!(x &amp; 0xffff)) {</a>
<a name="ln527">		k = 16;</a>
<a name="ln528">		x &gt;&gt;= 16;</a>
<a name="ln529">	}</a>
<a name="ln530">	if (!(x &amp; 0xff)) {</a>
<a name="ln531">		k += 8;</a>
<a name="ln532">		x &gt;&gt;= 8;</a>
<a name="ln533">	}</a>
<a name="ln534">	if (!(x &amp; 0xf)) {</a>
<a name="ln535">		k += 4;</a>
<a name="ln536">		x &gt;&gt;= 4;</a>
<a name="ln537">	}</a>
<a name="ln538">	if (!(x &amp; 0x3)) {</a>
<a name="ln539">		k += 2;</a>
<a name="ln540">		x &gt;&gt;= 2;</a>
<a name="ln541">	}</a>
<a name="ln542">	if (!(x &amp; 1)) {</a>
<a name="ln543">		k++;</a>
<a name="ln544">		x &gt;&gt;= 1;</a>
<a name="ln545">		if (!x &amp; 1)</a>
<a name="ln546">			return 32;</a>
<a name="ln547">	}</a>
<a name="ln548">	*y = x;</a>
<a name="ln549">	return k;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552"> </a>
<a name="ln553">static Bigint *</a>
<a name="ln554">i2b(int i)</a>
<a name="ln555">{</a>
<a name="ln556">	Bigint *b;</a>
<a name="ln557"> </a>
<a name="ln558">	b = Balloc(1);</a>
<a name="ln559">	b-&gt;x[0] = i;</a>
<a name="ln560">	b-&gt;wds = 1;</a>
<a name="ln561">	return b;</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">static Bigint *</a>
<a name="ln566">mult(Bigint *a, Bigint *b)</a>
<a name="ln567">{</a>
<a name="ln568">	Bigint *c;</a>
<a name="ln569">	int k, wa, wb, wc;</a>
<a name="ln570">	ULong carry, y, z;</a>
<a name="ln571">	ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;</a>
<a name="ln572">#ifdef Pack_32</a>
<a name="ln573">	ULong z2;</a>
<a name="ln574">#endif</a>
<a name="ln575"> </a>
<a name="ln576">	if (a-&gt;wds &lt; b-&gt;wds) {</a>
<a name="ln577">		c = a;</a>
<a name="ln578">		a = b;</a>
<a name="ln579">		b = c;</a>
<a name="ln580">	}</a>
<a name="ln581">	k = a-&gt;k;</a>
<a name="ln582">	wa = a-&gt;wds;</a>
<a name="ln583">	wb = b-&gt;wds;</a>
<a name="ln584">	wc = wa + wb;</a>
<a name="ln585">	if (wc &gt; a-&gt;maxwds)</a>
<a name="ln586">		k++;</a>
<a name="ln587">	c = Balloc(k);</a>
<a name="ln588">	for (x = c-&gt;x, xa = x + wc; x &lt; xa; x++)</a>
<a name="ln589">		*x = 0;</a>
<a name="ln590">	xa = a-&gt;x;</a>
<a name="ln591">	xae = xa + wa;</a>
<a name="ln592">	xb = b-&gt;x;</a>
<a name="ln593">	xbe = xb + wb;</a>
<a name="ln594">	xc0 = c-&gt;x;</a>
<a name="ln595">#ifdef Pack_32</a>
<a name="ln596">	for (; xb &lt; xbe; xb++, xc0++) {</a>
<a name="ln597">		if ( (y = *xb &amp; 0xffff) ) {</a>
<a name="ln598">			x = xa;</a>
<a name="ln599">			xc = xc0;</a>
<a name="ln600">			carry = 0;</a>
<a name="ln601">			do {</a>
<a name="ln602">				z = (*x &amp; 0xffff) * y + (*xc &amp; 0xffff) + carry;</a>
<a name="ln603">				carry = z &gt;&gt; 16;</a>
<a name="ln604">				z2 = (*x++ &gt;&gt; 16) * y + (*xc &gt;&gt; 16) + carry;</a>
<a name="ln605">				carry = z2 &gt;&gt; 16;</a>
<a name="ln606">				Storeinc(xc, z2, z);</a>
<a name="ln607">			} while (x &lt; xae);</a>
<a name="ln608">			*xc = carry;</a>
<a name="ln609">		}</a>
<a name="ln610">		if ( (y = *xb &gt;&gt; 16) ) {</a>
<a name="ln611">			x = xa;</a>
<a name="ln612">			xc = xc0;</a>
<a name="ln613">			carry = 0;</a>
<a name="ln614">			z2 = *xc;</a>
<a name="ln615">			do {</a>
<a name="ln616">				z = (*x &amp; 0xffff) * y + (*xc &gt;&gt; 16) + carry;</a>
<a name="ln617">				carry = z &gt;&gt; 16;</a>
<a name="ln618">				Storeinc(xc, z, z2);</a>
<a name="ln619">				z2 = (*x++ &gt;&gt; 16) * y + (*xc &amp; 0xffff) + carry;</a>
<a name="ln620">				carry = z2 &gt;&gt; 16;</a>
<a name="ln621">			} while (x &lt; xae);</a>
<a name="ln622">			*xc = z2;</a>
<a name="ln623">		}</a>
<a name="ln624">	}</a>
<a name="ln625">#else</a>
<a name="ln626">	for (; xb &lt; xbe; xc0++) {</a>
<a name="ln627">		if (y = *xb++) {</a>
<a name="ln628">			x = xa;</a>
<a name="ln629">			xc = xc0;</a>
<a name="ln630">			carry = 0;</a>
<a name="ln631">			do {</a>
<a name="ln632">				z = *x++ * y + *xc + carry;</a>
<a name="ln633">				carry = z &gt;&gt; 16;</a>
<a name="ln634">				*xc++ = z &amp; 0xffff;</a>
<a name="ln635">			} while (x &lt; xae);</a>
<a name="ln636">			*xc = carry;</a>
<a name="ln637">		}</a>
<a name="ln638">	}</a>
<a name="ln639">#endif</a>
<a name="ln640">	for (xc0 = c-&gt;x, xc = xc0 + wc; wc &gt; 0 &amp;&amp; !*--xc; --wc) ;</a>
<a name="ln641">	c-&gt;wds = wc;</a>
<a name="ln642">	return c;</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645"> </a>
<a name="ln646">static Bigint *p5s;</a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649">static Bigint *</a>
<a name="ln650">pow5mult(Bigint *b, int k)</a>
<a name="ln651">{</a>
<a name="ln652">	Bigint *b1, *p5, *p51;</a>
<a name="ln653">	int i;</a>
<a name="ln654">	static int p05[3] = { 5, 25, 125 };</a>
<a name="ln655"> </a>
<a name="ln656">	if ( (i = k &amp; 3) )</a>
<a name="ln657">		b = multadd(b, p05[i-1], 0);</a>
<a name="ln658"> </a>
<a name="ln659">	if (!(k &gt;&gt;= 2))</a>
<a name="ln660">		return b;</a>
<a name="ln661">	if (!(p5 = p5s)) {</a>
<a name="ln662">		/* first time */</a>
<a name="ln663">		p5 = p5s = i2b(625);</a>
<a name="ln664">		p5-&gt;next = 0;</a>
<a name="ln665">	}</a>
<a name="ln666">	for (;;) {</a>
<a name="ln667">		if (k &amp; 1) {</a>
<a name="ln668">			b1 = mult(b, p5);</a>
<a name="ln669">			Bfree(b);</a>
<a name="ln670">			b = b1;</a>
<a name="ln671">		}</a>
<a name="ln672">		if (!(k &gt;&gt;= 1))</a>
<a name="ln673">			break;</a>
<a name="ln674">		if (!(p51 = p5-&gt;next)) {</a>
<a name="ln675">			p51 = p5-&gt;next = mult(p5,p5);</a>
<a name="ln676">			p51-&gt;next = 0;</a>
<a name="ln677">		}</a>
<a name="ln678">		p5 = p51;</a>
<a name="ln679">	}</a>
<a name="ln680">	return b;</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683"> </a>
<a name="ln684">static Bigint *</a>
<a name="ln685">lshift(Bigint *b, int k)</a>
<a name="ln686">{</a>
<a name="ln687">	int i, k1, n, n1;</a>
<a name="ln688">	Bigint *b1;</a>
<a name="ln689">	ULong *x, *x1, *xe, z;</a>
<a name="ln690"> </a>
<a name="ln691">#ifdef Pack_32</a>
<a name="ln692">	n = k &gt;&gt; 5;</a>
<a name="ln693">#else</a>
<a name="ln694">	n = k &gt;&gt; 4;</a>
<a name="ln695">#endif</a>
<a name="ln696">	k1 = b-&gt;k;</a>
<a name="ln697">	n1 = n + b-&gt;wds + 1;</a>
<a name="ln698">	for (i = b-&gt;maxwds; n1 &gt; i; i &lt;&lt;= 1)</a>
<a name="ln699">		k1++;</a>
<a name="ln700">	b1 = Balloc(k1);</a>
<a name="ln701">	x1 = b1-&gt;x;</a>
<a name="ln702">	for (i = 0; i &lt; n; i++)</a>
<a name="ln703">		*x1++ = 0;</a>
<a name="ln704">	x = b-&gt;x;</a>
<a name="ln705">	xe = x + b-&gt;wds;</a>
<a name="ln706">#ifdef Pack_32</a>
<a name="ln707">	if (k &amp;= 0x1f) {</a>
<a name="ln708">		k1 = 32 - k;</a>
<a name="ln709">		z = 0;</a>
<a name="ln710">		do {</a>
<a name="ln711">			*x1++ = *x &lt;&lt; k | z;</a>
<a name="ln712">			z = *x++ &gt;&gt; k1;</a>
<a name="ln713">		} while (x &lt; xe);</a>
<a name="ln714">		if ( (*x1 = z) )</a>
<a name="ln715">			++n1;</a>
<a name="ln716">	}</a>
<a name="ln717">#else</a>
<a name="ln718">	if (k &amp;= 0xf) {</a>
<a name="ln719">		k1 = 16 - k;</a>
<a name="ln720">		z = 0;</a>
<a name="ln721">		do {</a>
<a name="ln722">			*x1++ = *x &lt;&lt; k  &amp; 0xffff | z;</a>
<a name="ln723">			z = *x++ &gt;&gt; k1;</a>
<a name="ln724">		} while (x &lt; xe);</a>
<a name="ln725">		if (*x1 = z)</a>
<a name="ln726">			++n1;</a>
<a name="ln727">	}</a>
<a name="ln728">#endif</a>
<a name="ln729">	else</a>
<a name="ln730">		do</a>
<a name="ln731">			*x1++ = *x++;</a>
<a name="ln732">		while (x &lt; xe);</a>
<a name="ln733">	b1-&gt;wds = n1 - 1;</a>
<a name="ln734">	Bfree(b);</a>
<a name="ln735">	return b1;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">static int</a>
<a name="ln740">cmp(Bigint *a, Bigint *b)</a>
<a name="ln741">{</a>
<a name="ln742">	ULong *xa, *xa0, *xb, *xb0;</a>
<a name="ln743">	int i, j;</a>
<a name="ln744"> </a>
<a name="ln745">	i = a-&gt;wds;</a>
<a name="ln746">	j = b-&gt;wds;</a>
<a name="ln747">#ifdef DEBUG</a>
<a name="ln748">	if (i &gt; 1 &amp;&amp; !a-&gt;x[i-1])</a>
<a name="ln749">		Bug(&quot;cmp called with a-&gt;x[a-&gt;wds-1] == 0&quot;);</a>
<a name="ln750">	if (j &gt; 1 &amp;&amp; !b-&gt;x[j-1])</a>
<a name="ln751">		Bug(&quot;cmp called with b-&gt;x[b-&gt;wds-1] == 0&quot;);</a>
<a name="ln752">#endif</a>
<a name="ln753">	if (i -= j)</a>
<a name="ln754">		return i;</a>
<a name="ln755">	xa0 = a-&gt;x;</a>
<a name="ln756">	xa = xa0 + j;</a>
<a name="ln757">	xb0 = b-&gt;x;</a>
<a name="ln758">	xb = xb0 + j;</a>
<a name="ln759">	for (;;) {</a>
<a name="ln760">		if (*--xa != *--xb)</a>
<a name="ln761">			return *xa &lt; *xb ? -1 : 1;</a>
<a name="ln762">		if (xa &lt;= xa0)</a>
<a name="ln763">			break;</a>
<a name="ln764">	}</a>
<a name="ln765">	return 0;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">static Bigint *</a>
<a name="ln770">diff(Bigint *a, Bigint *b)</a>
<a name="ln771">{</a>
<a name="ln772">	Bigint *c;</a>
<a name="ln773">	int i, wa, wb;</a>
<a name="ln774">	Long borrow, y;	/* We need signed shifts here. */</a>
<a name="ln775">	ULong *xa, *xae, *xb, *xbe, *xc;</a>
<a name="ln776">#ifdef Pack_32</a>
<a name="ln777">	Long z;</a>
<a name="ln778">#endif</a>
<a name="ln779"> </a>
<a name="ln780">	i = cmp(a,b);</a>
<a name="ln781">	if (!i) {</a>
<a name="ln782">		c = Balloc(0);</a>
<a name="ln783">		c-&gt;wds = 1;</a>
<a name="ln784">		c-&gt;x[0] = 0;</a>
<a name="ln785">		return c;</a>
<a name="ln786">	}</a>
<a name="ln787">	if (i &lt; 0) {</a>
<a name="ln788">		c = a;</a>
<a name="ln789">		a = b;</a>
<a name="ln790">		b = c;</a>
<a name="ln791">		i = 1;</a>
<a name="ln792">	} else</a>
<a name="ln793">		i = 0;</a>
<a name="ln794">	c = Balloc(a-&gt;k);</a>
<a name="ln795">	c-&gt;sign = i;</a>
<a name="ln796">	wa = a-&gt;wds;</a>
<a name="ln797">	xa = a-&gt;x;</a>
<a name="ln798">	xae = xa + wa;</a>
<a name="ln799">	wb = b-&gt;wds;</a>
<a name="ln800">	xb = b-&gt;x;</a>
<a name="ln801">	xbe = xb + wb;</a>
<a name="ln802">	xc = c-&gt;x;</a>
<a name="ln803">	borrow = 0;</a>
<a name="ln804">#ifdef Pack_32</a>
<a name="ln805">	do {</a>
<a name="ln806">		y = (*xa &amp; 0xffff) - (*xb &amp; 0xffff) + borrow;</a>
<a name="ln807">		borrow = y &gt;&gt; 16;</a>
<a name="ln808">		Sign_Extend(borrow, y);</a>
<a name="ln809">		z = (*xa++ &gt;&gt; 16) - (*xb++ &gt;&gt; 16) + borrow;</a>
<a name="ln810">		borrow = z &gt;&gt; 16;</a>
<a name="ln811">		Sign_Extend(borrow, z);</a>
<a name="ln812">		Storeinc(xc, z, y);</a>
<a name="ln813">	} while (xb &lt; xbe);</a>
<a name="ln814">	while (xa &lt; xae) {</a>
<a name="ln815">		y = (*xa &amp; 0xffff) + borrow;</a>
<a name="ln816">		borrow = y &gt;&gt; 16;</a>
<a name="ln817">		Sign_Extend(borrow, y);</a>
<a name="ln818">		z = (*xa++ &gt;&gt; 16) + borrow;</a>
<a name="ln819">		borrow = z &gt;&gt; 16;</a>
<a name="ln820">		Sign_Extend(borrow, z);</a>
<a name="ln821">		Storeinc(xc, z, y);</a>
<a name="ln822">	}</a>
<a name="ln823">#else</a>
<a name="ln824">	do {</a>
<a name="ln825">		y = *xa++ - *xb++ + borrow;</a>
<a name="ln826">		borrow = y &gt;&gt; 16;</a>
<a name="ln827">		Sign_Extend(borrow, y);</a>
<a name="ln828">		*xc++ = y &amp; 0xffff;</a>
<a name="ln829">	} while (xb &lt; xbe);</a>
<a name="ln830">	while (xa &lt; xae) {</a>
<a name="ln831">		y = *xa++ + borrow;</a>
<a name="ln832">		borrow = y &gt;&gt; 16;</a>
<a name="ln833">		Sign_Extend(borrow, y);</a>
<a name="ln834">		*xc++ = y &amp; 0xffff;</a>
<a name="ln835">	}</a>
<a name="ln836">#endif</a>
<a name="ln837">	while (!*--xc)</a>
<a name="ln838">		wa--;</a>
<a name="ln839">	c-&gt;wds = wa;</a>
<a name="ln840">	return c;</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843"> </a>
<a name="ln844">static double</a>
<a name="ln845">ulp(double x)</a>
<a name="ln846">{</a>
<a name="ln847">	Long L;</a>
<a name="ln848">	double a;</a>
<a name="ln849"> </a>
<a name="ln850">	L = (word0(x) &amp; Exp_mask) - (P-1)*Exp_msk1;</a>
<a name="ln851">#ifndef Sudden_Underflow</a>
<a name="ln852">	if (L &gt; 0) {</a>
<a name="ln853">#endif</a>
<a name="ln854">#ifdef IBM</a>
<a name="ln855">		L |= Exp_msk1 &gt;&gt; 4;</a>
<a name="ln856">#endif</a>
<a name="ln857">		word0(a) = L;</a>
<a name="ln858">		word1(a) = 0;</a>
<a name="ln859">#ifndef Sudden_Underflow</a>
<a name="ln860">	} else {</a>
<a name="ln861">		L = -L &gt;&gt; Exp_shift;</a>
<a name="ln862">		if (L &lt; Exp_shift) {</a>
<a name="ln863">			word0(a) = 0x80000 &gt;&gt; L;</a>
<a name="ln864">			word1(a) = 0;</a>
<a name="ln865">		} else {</a>
<a name="ln866">			word0(a) = 0;</a>
<a name="ln867">			L -= Exp_shift;</a>
<a name="ln868">			word1(a) = L &gt;= 31 ? 1 : 1 &lt;&lt; (31 - L);</a>
<a name="ln869">		}</a>
<a name="ln870">	}</a>
<a name="ln871">#endif</a>
<a name="ln872">	return a;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">static double</a>
<a name="ln877">b2d(Bigint *a, int *e)</a>
<a name="ln878">{</a>
<a name="ln879">	ULong *xa, *xa0, w, y, z;</a>
<a name="ln880">	int k;</a>
<a name="ln881">	double d;</a>
<a name="ln882">#ifdef VAX</a>
<a name="ln883">	ULong d0, d1;</a>
<a name="ln884">#else</a>
<a name="ln885">#define d0 word0(d)</a>
<a name="ln886">#define d1 word1(d)</a>
<a name="ln887">#endif</a>
<a name="ln888"> </a>
<a name="ln889">	xa0 = a-&gt;x;</a>
<a name="ln890">	xa = xa0 + a-&gt;wds;</a>
<a name="ln891">	y = *--xa;</a>
<a name="ln892">#ifdef DEBUG</a>
<a name="ln893">	if (!y) Bug(&quot;zero y in b2d&quot;);</a>
<a name="ln894">#endif</a>
<a name="ln895">	k = hi0bits(y);</a>
<a name="ln896">	*e = 32 - k;</a>
<a name="ln897">#ifdef Pack_32</a>
<a name="ln898">	if (k &lt; Ebits) {</a>
<a name="ln899">		d0 = Exp_1 | (y &gt;&gt; (Ebits - k));</a>
<a name="ln900">		w = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln901">		d1 = (y &lt;&lt; ((32-Ebits) + k)) | (w &gt;&gt; (Ebits - k));</a>
<a name="ln902">		goto ret_d;</a>
<a name="ln903">		}</a>
<a name="ln904">	z = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln905">	if (k -= Ebits) {</a>
<a name="ln906">		d0 = Exp_1 | (y &lt;&lt; k) | (z &gt;&gt; (32 - k));</a>
<a name="ln907">		y = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln908">		d1 = (z &lt;&lt; k) | (y &gt;&gt; (32 - k));</a>
<a name="ln909">	} else {</a>
<a name="ln910">		d0 = Exp_1 | y;</a>
<a name="ln911">		d1 = z;</a>
<a name="ln912">	}</a>
<a name="ln913">#else</a>
<a name="ln914">	if (k &lt; Ebits + 16) {</a>
<a name="ln915">		z = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln916">		d0 = Exp_1 | y &lt;&lt; k - Ebits | z &gt;&gt; Ebits + 16 - k;</a>
<a name="ln917">		w = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln918">		y = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln919">		d1 = z &lt;&lt; k + 16 - Ebits | w &lt;&lt; k - Ebits | y &gt;&gt; 16 + Ebits - k;</a>
<a name="ln920">		goto ret_d;</a>
<a name="ln921">	}</a>
<a name="ln922">	z = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln923">	w = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln924">	k -= Ebits + 16;</a>
<a name="ln925">	d0 = Exp_1 | y &lt;&lt; k + 16 | z &lt;&lt; k | w &gt;&gt; 16 - k;</a>
<a name="ln926">	y = xa &gt; xa0 ? *--xa : 0;</a>
<a name="ln927">	d1 = w &lt;&lt; k + 16 | y &lt;&lt; k;</a>
<a name="ln928">#endif</a>
<a name="ln929"> ret_d:</a>
<a name="ln930">#ifdef VAX</a>
<a name="ln931">	word0(d) = d0 &gt;&gt; 16 | d0 &lt;&lt; 16;</a>
<a name="ln932">	word1(d) = d1 &gt;&gt; 16 | d1 &lt;&lt; 16;</a>
<a name="ln933">#else</a>
<a name="ln934">#undef d0</a>
<a name="ln935">#undef d1</a>
<a name="ln936">#endif</a>
<a name="ln937">	return d;</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940"> </a>
<a name="ln941">static Bigint *</a>
<a name="ln942">d2b(double d, int *e, int *bits)</a>
<a name="ln943">{</a>
<a name="ln944">	Bigint *b;</a>
<a name="ln945">	int de, i, k;</a>
<a name="ln946">	ULong *x, y, z;</a>
<a name="ln947">#ifdef VAX</a>
<a name="ln948">	ULong d0, d1;</a>
<a name="ln949">	d0 = word0(d) &gt;&gt; 16 | word0(d) &lt;&lt; 16;</a>
<a name="ln950">	d1 = word1(d) &gt;&gt; 16 | word1(d) &lt;&lt; 16;</a>
<a name="ln951">#else</a>
<a name="ln952">#define d0 word0(d)</a>
<a name="ln953">#define d1 word1(d)</a>
<a name="ln954">#endif</a>
<a name="ln955"> </a>
<a name="ln956">#ifdef Pack_32</a>
<a name="ln957">	b = Balloc(1);</a>
<a name="ln958">#else</a>
<a name="ln959">	b = Balloc(2);</a>
<a name="ln960">#endif</a>
<a name="ln961">	x = b-&gt;x;</a>
<a name="ln962"> </a>
<a name="ln963">	z = d0 &amp; Frac_mask;</a>
<a name="ln964">	d0 &amp;= 0x7fffffff;	/* clear sign bit, which we ignore */</a>
<a name="ln965">#ifdef Sudden_Underflow</a>
<a name="ln966">	de = (int)(d0 &gt;&gt; Exp_shift);</a>
<a name="ln967">#ifndef IBM</a>
<a name="ln968">	z |= Exp_msk11;</a>
<a name="ln969">#endif</a>
<a name="ln970">#else</a>
<a name="ln971">	if ( (de = (int)(d0 &gt;&gt; Exp_shift)) )</a>
<a name="ln972">		z |= Exp_msk1;</a>
<a name="ln973">#endif</a>
<a name="ln974">#ifdef Pack_32</a>
<a name="ln975">	if ( (y = d1) ) {</a>
<a name="ln976">		if ( (k = lo0bits(&amp;y)) ) {</a>
<a name="ln977">			x[0] = y | (z &lt;&lt; (32 - k));</a>
<a name="ln978">			z &gt;&gt;= k;</a>
<a name="ln979">			}</a>
<a name="ln980">		else</a>
<a name="ln981">			x[0] = y;</a>
<a name="ln982">		i = b-&gt;wds = (x[1] = z) ? 2 : 1;</a>
<a name="ln983">	} else {</a>
<a name="ln984">#ifdef DEBUG</a>
<a name="ln985">		if (!z)</a>
<a name="ln986">			Bug(&quot;Zero passed to d2b&quot;);</a>
<a name="ln987">#endif</a>
<a name="ln988">		k = lo0bits(&amp;z);</a>
<a name="ln989">		x[0] = z;</a>
<a name="ln990">		i = b-&gt;wds = 1;</a>
<a name="ln991">		k += 32;</a>
<a name="ln992">	}</a>
<a name="ln993">#else</a>
<a name="ln994">	if (y = d1) {</a>
<a name="ln995">		if (k = lo0bits(&amp;y))</a>
<a name="ln996">			if (k &gt;= 16) {</a>
<a name="ln997">				x[0] = y | z &lt;&lt; 32 - k &amp; 0xffff;</a>
<a name="ln998">				x[1] = z &gt;&gt; k - 16 &amp; 0xffff;</a>
<a name="ln999">				x[2] = z &gt;&gt; k;</a>
<a name="ln1000">				i = 2;</a>
<a name="ln1001">			} else {</a>
<a name="ln1002">				x[0] = y &amp; 0xffff;</a>
<a name="ln1003">				x[1] = y &gt;&gt; 16 | z &lt;&lt; 16 - k &amp; 0xffff;</a>
<a name="ln1004">				x[2] = z &gt;&gt; k &amp; 0xffff;</a>
<a name="ln1005">				x[3] = z &gt;&gt; k+16;</a>
<a name="ln1006">				i = 3;</a>
<a name="ln1007">			}</a>
<a name="ln1008">		else {</a>
<a name="ln1009">			x[0] = y &amp; 0xffff;</a>
<a name="ln1010">			x[1] = y &gt;&gt; 16;</a>
<a name="ln1011">			x[2] = z &amp; 0xffff;</a>
<a name="ln1012">			x[3] = z &gt;&gt; 16;</a>
<a name="ln1013">			i = 3;</a>
<a name="ln1014">		}</a>
<a name="ln1015">	} else {</a>
<a name="ln1016">#ifdef DEBUG</a>
<a name="ln1017">		if (!z)</a>
<a name="ln1018">			Bug(&quot;Zero passed to d2b&quot;);</a>
<a name="ln1019">#endif</a>
<a name="ln1020">		k = lo0bits(&amp;z);</a>
<a name="ln1021">		if (k &gt;= 16) {</a>
<a name="ln1022">			x[0] = z;</a>
<a name="ln1023">			i = 0;</a>
<a name="ln1024">		} else {</a>
<a name="ln1025">			x[0] = z &amp; 0xffff;</a>
<a name="ln1026">			x[1] = z &gt;&gt; 16;</a>
<a name="ln1027">			i = 1;</a>
<a name="ln1028">		}</a>
<a name="ln1029">		k += 32;</a>
<a name="ln1030">	}</a>
<a name="ln1031">	while (!x[i])</a>
<a name="ln1032">		--i;</a>
<a name="ln1033">	b-&gt;wds = i + 1;</a>
<a name="ln1034">#endif</a>
<a name="ln1035">#ifndef Sudden_Underflow</a>
<a name="ln1036">	if (de) {</a>
<a name="ln1037">#endif</a>
<a name="ln1038">#ifdef IBM</a>
<a name="ln1039">		*e = (de - Bias - (P-1) &lt;&lt; 2) + k;</a>
<a name="ln1040">		*bits = 4*P + 8 - k - hi0bits(word0(d) &amp; Frac_mask);</a>
<a name="ln1041">#else</a>
<a name="ln1042">		*e = de - Bias - (P-1) + k;</a>
<a name="ln1043">		*bits = P - k;</a>
<a name="ln1044">#endif</a>
<a name="ln1045">#ifndef Sudden_Underflow</a>
<a name="ln1046">	} else {</a>
<a name="ln1047">		*e = de - Bias - (P-1) + 1 + k;</a>
<a name="ln1048">#ifdef Pack_32</a>
<a name="ln1049">		*bits = 32*i - hi0bits(x[i-1]);</a>
<a name="ln1050">#else</a>
<a name="ln1051">		*bits = (i+2)*16 - hi0bits(x[i]);</a>
<a name="ln1052">#endif</a>
<a name="ln1053">	}</a>
<a name="ln1054">#endif</a>
<a name="ln1055">	return b;</a>
<a name="ln1056">}</a>
<a name="ln1057">#undef d0</a>
<a name="ln1058">#undef d1</a>
<a name="ln1059"> </a>
<a name="ln1060"> </a>
<a name="ln1061">static double</a>
<a name="ln1062">ratio(Bigint *a, Bigint *b)</a>
<a name="ln1063">{</a>
<a name="ln1064">	double da, db;</a>
<a name="ln1065">	int k, ka, kb;</a>
<a name="ln1066"> </a>
<a name="ln1067">	da = b2d(a, &amp;ka);</a>
<a name="ln1068">	db = b2d(b, &amp;kb);</a>
<a name="ln1069">#ifdef Pack_32</a>
<a name="ln1070">	k = ka - kb + 32*(a-&gt;wds - b-&gt;wds);</a>
<a name="ln1071">#else</a>
<a name="ln1072">	k = ka - kb + 16*(a-&gt;wds - b-&gt;wds);</a>
<a name="ln1073">#endif</a>
<a name="ln1074">#ifdef IBM</a>
<a name="ln1075">	if (k &gt; 0) {</a>
<a name="ln1076">		word0(da) += (k &gt;&gt; 2)*Exp_msk1;</a>
<a name="ln1077">		if (k &amp;= 3)</a>
<a name="ln1078">			da *= 1 &lt;&lt; k;</a>
<a name="ln1079">	} else {</a>
<a name="ln1080">		k = -k;</a>
<a name="ln1081">		word0(db) += (k &gt;&gt; 2)*Exp_msk1;</a>
<a name="ln1082">		if (k &amp;= 3)</a>
<a name="ln1083">			db *= 1 &lt;&lt; k;</a>
<a name="ln1084">	}</a>
<a name="ln1085">#else</a>
<a name="ln1086">	if (k &gt; 0)</a>
<a name="ln1087">		word0(da) += k*Exp_msk1;</a>
<a name="ln1088">	else {</a>
<a name="ln1089">		k = -k;</a>
<a name="ln1090">		word0(db) += k*Exp_msk1;</a>
<a name="ln1091">	}</a>
<a name="ln1092">#endif</a>
<a name="ln1093">	return da / db;</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">static double</a>
<a name="ln1097">tens[] = {</a>
<a name="ln1098">		1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,</a>
<a name="ln1099">		1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,</a>
<a name="ln1100">		1e20, 1e21, 1e22</a>
<a name="ln1101">#ifdef VAX</a>
<a name="ln1102">		, 1e23, 1e24</a>
<a name="ln1103">#endif</a>
<a name="ln1104">		};</a>
<a name="ln1105"> </a>
<a name="ln1106">static double</a>
<a name="ln1107">#ifdef IEEE_Arith</a>
<a name="ln1108">bigtens[] = { 1e16, 1e32, 1e64, 1e128, 1e256 };</a>
<a name="ln1109">static double tinytens[] = { 1e-16, 1e-32, 1e-64, 1e-128, 1e-256 };</a>
<a name="ln1110">#define n_bigtens 5</a>
<a name="ln1111">#else</a>
<a name="ln1112">#ifdef IBM</a>
<a name="ln1113">bigtens[] = { 1e16, 1e32, 1e64 };</a>
<a name="ln1114">static double tinytens[] = { 1e-16, 1e-32, 1e-64 };</a>
<a name="ln1115">#define n_bigtens 3</a>
<a name="ln1116">#else</a>
<a name="ln1117">bigtens[] = { 1e16, 1e32 };</a>
<a name="ln1118">static double tinytens[] = { 1e-16, 1e-32 };</a>
<a name="ln1119">#define n_bigtens 2</a>
<a name="ln1120">#endif</a>
<a name="ln1121">#endif</a>
<a name="ln1122"> </a>
<a name="ln1123"> </a>
<a name="ln1124">double</a>
<a name="ln1125">strtod(const char * __restrict s00, char ** __restrict se)</a>
<a name="ln1126">{</a>
<a name="ln1127">	int bb2, bb5, bbe, bd2, bd5, bbbits, bs2, c, dsign,</a>
<a name="ln1128">		 e, e1, esign, i, j, k, nd, nd0, nf, nz, nz0, sign;</a>
<a name="ln1129">	const char *s, *s0, *s1;</a>
<a name="ln1130">	double aadj, aadj1, adj, rv, rv0;</a>
<a name="ln1131">	Long L;</a>
<a name="ln1132">	ULong y, z;</a>
<a name="ln1133">	Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;</a>
<a name="ln1134">	char decimal_point = localeconv()-&gt;decimal_point[0];</a>
<a name="ln1135"> </a>
<a name="ln1136">	sign = nz0 = nz = 0;</a>
<a name="ln1137">	rv = 0.;</a>
<a name="ln1138">	for (s = s00;;s++) switch(*s) {</a>
<a name="ln1139">		case '-':</a>
<a name="ln1140">			sign = 1;</a>
<a name="ln1141">			/* no break */</a>
<a name="ln1142">		case '+':</a>
<a name="ln1143">			if (*++s)</a>
<a name="ln1144">				goto break2;</a>
<a name="ln1145">			/* no break */</a>
<a name="ln1146">		case 0:</a>
<a name="ln1147">			s = s00;</a>
<a name="ln1148">			goto ret;</a>
<a name="ln1149">		default:</a>
<a name="ln1150">			if (isspace((unsigned char)*s))</a>
<a name="ln1151">				continue;</a>
<a name="ln1152">			goto break2;</a>
<a name="ln1153">	}</a>
<a name="ln1154"> break2:</a>
<a name="ln1155">	if (*s == '0') {</a>
<a name="ln1156">		nz0 = 1;</a>
<a name="ln1157">		while (*++s == '0') ;</a>
<a name="ln1158">		if (!*s)</a>
<a name="ln1159">			goto ret;</a>
<a name="ln1160">	}</a>
<a name="ln1161">	s0 = s;</a>
<a name="ln1162">	y = z = 0;</a>
<a name="ln1163">	for (nd = nf = 0; (c = *s) &gt;= '0' &amp;&amp; c &lt;= '9'; nd++, s++)</a>
<a name="ln1164">		if (nd &lt; 9)</a>
<a name="ln1165">			y = 10*y + c - '0';</a>
<a name="ln1166">		else if (nd &lt; 16)</a>
<a name="ln1167">			z = 10*z + c - '0';</a>
<a name="ln1168">	nd0 = nd;</a>
<a name="ln1169">	if ((char)c == decimal_point) {</a>
<a name="ln1170">		c = *++s;</a>
<a name="ln1171">		if (!nd) {</a>
<a name="ln1172">			for (; c == '0'; c = *++s)</a>
<a name="ln1173">				nz++;</a>
<a name="ln1174">			if (c &gt; '0' &amp;&amp; c &lt;= '9') {</a>
<a name="ln1175">				s0 = s;</a>
<a name="ln1176">				nf += nz;</a>
<a name="ln1177">				nz = 0;</a>
<a name="ln1178">				goto have_dig;</a>
<a name="ln1179">			}</a>
<a name="ln1180">			goto dig_done;</a>
<a name="ln1181">		}</a>
<a name="ln1182">		for (; c &gt;= '0' &amp;&amp; c &lt;= '9'; c = *++s) {</a>
<a name="ln1183"> have_dig:</a>
<a name="ln1184">			nz++;</a>
<a name="ln1185">			if (c - '0' &gt; 0) {</a>
<a name="ln1186">				nf += nz;</a>
<a name="ln1187">				for (i = 1; i &lt; nz; i++)</a>
<a name="ln1188">					if (nd++ &lt; 9)</a>
<a name="ln1189">						y *= 10;</a>
<a name="ln1190">					else if (nd &lt;= DBL_DIG + 1)</a>
<a name="ln1191">						z *= 10;</a>
<a name="ln1192">				if (nd++ &lt; 9)</a>
<a name="ln1193">					y = 10*y + c - '0';</a>
<a name="ln1194">				else if (nd &lt;= DBL_DIG + 1)</a>
<a name="ln1195">					z = 10*z + c - '0';</a>
<a name="ln1196">				nz = 0;</a>
<a name="ln1197">			}</a>
<a name="ln1198">		}</a>
<a name="ln1199">	}</a>
<a name="ln1200"> dig_done:</a>
<a name="ln1201">	e = 0;</a>
<a name="ln1202">	if (c == 'e' || c == 'E') {</a>
<a name="ln1203">		if (!nd &amp;&amp; !nz &amp;&amp; !nz0) {</a>
<a name="ln1204">			s = s00;</a>
<a name="ln1205">			goto ret;</a>
<a name="ln1206">		}</a>
<a name="ln1207">		s00 = s;</a>
<a name="ln1208">		esign = 0;</a>
<a name="ln1209">		switch(c = *++s) {</a>
<a name="ln1210">			case '-':</a>
<a name="ln1211">				esign = 1;</a>
<a name="ln1212">			case '+':</a>
<a name="ln1213">				c = *++s;</a>
<a name="ln1214">		}</a>
<a name="ln1215">		if (c &gt;= '0' &amp;&amp; c &lt;= '9') {</a>
<a name="ln1216">			while (c == '0')</a>
<a name="ln1217">				c = *++s;</a>
<a name="ln1218">			if (c &gt; '0' &amp;&amp; c &lt;= '9') {</a>
<a name="ln1219">				L = c - '0';</a>
<a name="ln1220">				s1 = s;</a>
<a name="ln1221">				while ((c = *++s) &gt;= '0' &amp;&amp; c &lt;= '9')</a>
<a name="ln1222">					L = 10*L + c - '0';</a>
<a name="ln1223">				if (s - s1 &gt; 8 || L &gt; 19999)</a>
<a name="ln1224">					/* Avoid confusion from exponents</a>
<a name="ln1225">					 * so large that e might overflow.</a>
<a name="ln1226">					 */</a>
<a name="ln1227">					e = 19999; /* safe for 16 bit ints */</a>
<a name="ln1228">				else</a>
<a name="ln1229">					e = (int)L;</a>
<a name="ln1230">				if (esign)</a>
<a name="ln1231">					e = -e;</a>
<a name="ln1232">			} else</a>
<a name="ln1233">				e = 0;</a>
<a name="ln1234">		} else</a>
<a name="ln1235">			s = s00;</a>
<a name="ln1236">	}</a>
<a name="ln1237">	if (!nd) {</a>
<a name="ln1238">		if (!nz &amp;&amp; !nz0)</a>
<a name="ln1239">			s = s00;</a>
<a name="ln1240">		goto ret;</a>
<a name="ln1241">	}</a>
<a name="ln1242">	e1 = e -= nf;</a>
<a name="ln1243"> </a>
<a name="ln1244">	/* Now we have nd0 digits, starting at s0, followed by a</a>
<a name="ln1245">	 * decimal point, followed by nd-nd0 digits.  The number we're</a>
<a name="ln1246">	 * after is the integer represented by those digits times</a>
<a name="ln1247">	 * 10**e */</a>
<a name="ln1248"> </a>
<a name="ln1249">	if (!nd0)</a>
<a name="ln1250">		nd0 = nd;</a>
<a name="ln1251">	k = nd &lt; DBL_DIG + 1 ? nd : DBL_DIG + 1;</a>
<a name="ln1252">	rv = y;</a>
<a name="ln1253">	if (k &gt; 9)</a>
<a name="ln1254">		rv = tens[k - 9] * rv + z;</a>
<a name="ln1255">	if (nd &lt;= DBL_DIG</a>
<a name="ln1256">#ifndef RND_PRODQUOT</a>
<a name="ln1257">		&amp;&amp; FLT_ROUNDS == 1</a>
<a name="ln1258">#endif</a>
<a name="ln1259">			) {</a>
<a name="ln1260">		if (!e)</a>
<a name="ln1261">			goto ret;</a>
<a name="ln1262">		if (e &gt; 0) {</a>
<a name="ln1263">			if (e &lt;= Ten_pmax) {</a>
<a name="ln1264">#ifdef VAX</a>
<a name="ln1265">				goto vax_ovfl_check;</a>
<a name="ln1266">#else</a>
<a name="ln1267">				/* rv = */ rounded_product(rv, tens[e]);</a>
<a name="ln1268">				goto ret;</a>
<a name="ln1269">#endif</a>
<a name="ln1270">				}</a>
<a name="ln1271">			i = DBL_DIG - nd;</a>
<a name="ln1272">			if (e &lt;= Ten_pmax + i) {</a>
<a name="ln1273">				/* A fancier test would sometimes let us do</a>
<a name="ln1274">				 * this for larger i values.</a>
<a name="ln1275">				 */</a>
<a name="ln1276">				e -= i;</a>
<a name="ln1277">				rv *= tens[i];</a>
<a name="ln1278">#ifdef VAX</a>
<a name="ln1279">				/* VAX exponent range is so narrow we must</a>
<a name="ln1280">				 * worry about overflow here...</a>
<a name="ln1281">				 */</a>
<a name="ln1282"> vax_ovfl_check:</a>
<a name="ln1283">				word0(rv) -= P*Exp_msk1;</a>
<a name="ln1284">				/* rv = */ rounded_product(rv, tens[e]);</a>
<a name="ln1285">				if ((word0(rv) &amp; Exp_mask)</a>
<a name="ln1286">				 &gt; Exp_msk1*(DBL_MAX_EXP+Bias-1-P))</a>
<a name="ln1287">					goto ovfl;</a>
<a name="ln1288">				word0(rv) += P*Exp_msk1;</a>
<a name="ln1289">#else</a>
<a name="ln1290">				/* rv = */ rounded_product(rv, tens[e]);</a>
<a name="ln1291">#endif</a>
<a name="ln1292">				goto ret;</a>
<a name="ln1293">			}</a>
<a name="ln1294">		}</a>
<a name="ln1295">#ifndef Inaccurate_Divide</a>
<a name="ln1296">		else if (e &gt;= -Ten_pmax) {</a>
<a name="ln1297">			/* rv = */ rounded_quotient(rv, tens[-e]);</a>
<a name="ln1298">			goto ret;</a>
<a name="ln1299">		}</a>
<a name="ln1300">#endif</a>
<a name="ln1301">	}</a>
<a name="ln1302">	e1 += nd - k;</a>
<a name="ln1303"> </a>
<a name="ln1304">	/* Get starting approximation = rv * 10**e1 */</a>
<a name="ln1305"> </a>
<a name="ln1306">	if (e1 &gt; 0) {</a>
<a name="ln1307">		if ( (i = e1 &amp; 15) )</a>
<a name="ln1308">			rv *= tens[i];</a>
<a name="ln1309">		if ( (e1 &amp;= ~15) ) {</a>
<a name="ln1310">			if (e1 &gt; DBL_MAX_10_EXP) {</a>
<a name="ln1311"> ovfl:</a>
<a name="ln1312">				__set_errno(ERANGE);</a>
<a name="ln1313">				rv = HUGE_VAL;</a>
<a name="ln1314">				goto ret;</a>
<a name="ln1315">			}</a>
<a name="ln1316">			if (e1 &gt;&gt;= 4) {</a>
<a name="ln1317">				for (j = 0; e1 &gt; 1; j++, e1 &gt;&gt;= 1)</a>
<a name="ln1318">					if (e1 &amp; 1)</a>
<a name="ln1319">						rv *= bigtens[j];</a>
<a name="ln1320">			/* The last multiplication could overflow. */</a>
<a name="ln1321">				word0(rv) -= P*Exp_msk1;</a>
<a name="ln1322">				rv *= bigtens[j];</a>
<a name="ln1323">				if ((z = word0(rv) &amp; Exp_mask)</a>
<a name="ln1324">				 &gt; Exp_msk1*(DBL_MAX_EXP+Bias-P))</a>
<a name="ln1325">					goto ovfl;</a>
<a name="ln1326">				if (z &gt; Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {</a>
<a name="ln1327">					/* set to largest number */</a>
<a name="ln1328">					/* (Can't trust DBL_MAX) */</a>
<a name="ln1329">					word0(rv) = Big0;</a>
<a name="ln1330">					word1(rv) = Big1;</a>
<a name="ln1331">					}</a>
<a name="ln1332">				else</a>
<a name="ln1333">					word0(rv) += P*Exp_msk1;</a>
<a name="ln1334">			}</a>
<a name="ln1335">		}</a>
<a name="ln1336">	} else if (e1 &lt; 0) {</a>
<a name="ln1337">		e1 = -e1;</a>
<a name="ln1338">		if ( (i = e1 &amp; 15) )</a>
<a name="ln1339">			rv /= tens[i];</a>
<a name="ln1340">		if ( (e1 &amp;= ~15) ) {</a>
<a name="ln1341">			e1 &gt;&gt;= 4;</a>
<a name="ln1342">			for (j = 0; e1 &gt; 1; j++, e1 &gt;&gt;= 1)</a>
<a name="ln1343">				if (e1 &amp; 1)</a>
<a name="ln1344">					rv *= tinytens[j];</a>
<a name="ln1345">			/* The last multiplication could underflow. */</a>
<a name="ln1346">			rv0 = rv;</a>
<a name="ln1347">			rv *= tinytens[j];</a>
<a name="ln1348">			if (!rv) {</a>
<a name="ln1349">				rv = 2.*rv0;</a>
<a name="ln1350">				rv *= tinytens[j];</a>
<a name="ln1351">				if (!rv) {</a>
<a name="ln1352"> undfl:</a>
<a name="ln1353">					rv = 0.;</a>
<a name="ln1354">					__set_errno(ERANGE);</a>
<a name="ln1355">					goto ret;</a>
<a name="ln1356">					}</a>
<a name="ln1357">				word0(rv) = Tiny0;</a>
<a name="ln1358">				word1(rv) = Tiny1;</a>
<a name="ln1359">				/* The refinement below will clean</a>
<a name="ln1360">				 * this approximation up.</a>
<a name="ln1361">				 */</a>
<a name="ln1362">			}</a>
<a name="ln1363">		}</a>
<a name="ln1364">	}</a>
<a name="ln1365"> </a>
<a name="ln1366">	/* Now the hard part -- adjusting rv to the correct value.*/</a>
<a name="ln1367"> </a>
<a name="ln1368">	/* Put digits into bd: true value = bd * 10^e */</a>
<a name="ln1369"> </a>
<a name="ln1370">	bd0 = s2b(s0, nd0, nd, y);</a>
<a name="ln1371"> </a>
<a name="ln1372">	for (;;) {</a>
<a name="ln1373">		bd = Balloc(bd0-&gt;k);</a>
<a name="ln1374">		Bcopy(bd, bd0);</a>
<a name="ln1375">		bb = d2b(rv, &amp;bbe, &amp;bbbits);	/* rv = bb * 2^bbe */</a>
<a name="ln1376">		bs = i2b(1);</a>
<a name="ln1377"> </a>
<a name="ln1378">		if (e &gt;= 0) {</a>
<a name="ln1379">			bb2 = bb5 = 0;</a>
<a name="ln1380">			bd2 = bd5 = e;</a>
<a name="ln1381">		} else {</a>
<a name="ln1382">			bb2 = bb5 = -e;</a>
<a name="ln1383">			bd2 = bd5 = 0;</a>
<a name="ln1384">		}</a>
<a name="ln1385">		if (bbe &gt;= 0)</a>
<a name="ln1386">			bb2 += bbe;</a>
<a name="ln1387">		else</a>
<a name="ln1388">			bd2 -= bbe;</a>
<a name="ln1389">		bs2 = bb2;</a>
<a name="ln1390">#ifdef Sudden_Underflow</a>
<a name="ln1391">#ifdef IBM</a>
<a name="ln1392">		j = 1 + 4*P - 3 - bbbits + ((bbe + bbbits - 1) &amp; 3);</a>
<a name="ln1393">#else</a>
<a name="ln1394">		j = P + 1 - bbbits;</a>
<a name="ln1395">#endif</a>
<a name="ln1396">#else</a>
<a name="ln1397">		i = bbe + bbbits - 1;	/* logb(rv) */</a>
<a name="ln1398">		if (i &lt; Emin)	/* denormal */</a>
<a name="ln1399">			j = bbe + (P-Emin);</a>
<a name="ln1400">		else</a>
<a name="ln1401">			j = P + 1 - bbbits;</a>
<a name="ln1402">#endif</a>
<a name="ln1403">		bb2 += j;</a>
<a name="ln1404">		bd2 += j;</a>
<a name="ln1405">		i = bb2 &lt; bd2 ? bb2 : bd2;</a>
<a name="ln1406">		if (i &gt; bs2)</a>
<a name="ln1407">			i = bs2;</a>
<a name="ln1408">		if (i &gt; 0) {</a>
<a name="ln1409">			bb2 -= i;</a>
<a name="ln1410">			bd2 -= i;</a>
<a name="ln1411">			bs2 -= i;</a>
<a name="ln1412">			}</a>
<a name="ln1413">		if (bb5 &gt; 0) {</a>
<a name="ln1414">			bs = pow5mult(bs, bb5);</a>
<a name="ln1415">			bb1 = mult(bs, bb);</a>
<a name="ln1416">			Bfree(bb);</a>
<a name="ln1417">			bb = bb1;</a>
<a name="ln1418">			}</a>
<a name="ln1419">		if (bb2 &gt; 0)</a>
<a name="ln1420">			bb = lshift(bb, bb2);</a>
<a name="ln1421">		if (bd5 &gt; 0)</a>
<a name="ln1422">			bd = pow5mult(bd, bd5);</a>
<a name="ln1423">		if (bd2 &gt; 0)</a>
<a name="ln1424">			bd = lshift(bd, bd2);</a>
<a name="ln1425">		if (bs2 &gt; 0)</a>
<a name="ln1426">			bs = lshift(bs, bs2);</a>
<a name="ln1427">		delta = diff(bb, bd);</a>
<a name="ln1428">		dsign = delta-&gt;sign;</a>
<a name="ln1429">		delta-&gt;sign = 0;</a>
<a name="ln1430">		i = cmp(delta, bs);</a>
<a name="ln1431">		if (i &lt; 0) {</a>
<a name="ln1432">			/* Error is less than half an ulp -- check for</a>
<a name="ln1433">			 * special case of mantissa a power of two.</a>
<a name="ln1434">			 */</a>
<a name="ln1435">			if (dsign || word1(rv) || word0(rv) &amp; Bndry_mask)</a>
<a name="ln1436">				break;</a>
<a name="ln1437">			delta = lshift(delta,Log2P);</a>
<a name="ln1438">			if (cmp(delta, bs) &gt; 0)</a>
<a name="ln1439">				goto drop_down;</a>
<a name="ln1440">			break;</a>
<a name="ln1441">		}</a>
<a name="ln1442">		if (i == 0) {</a>
<a name="ln1443">			/* exactly half-way between */</a>
<a name="ln1444">			if (dsign) {</a>
<a name="ln1445">				if ((word0(rv) &amp; Bndry_mask1) == Bndry_mask1</a>
<a name="ln1446">				 &amp;&amp;  word1(rv) == 0xffffffff) {</a>
<a name="ln1447">					/*boundary case -- increment exponent*/</a>
<a name="ln1448">					word0(rv) = (word0(rv) &amp; Exp_mask)</a>
<a name="ln1449">						+ Exp_msk1</a>
<a name="ln1450">#ifdef IBM</a>
<a name="ln1451">						| Exp_msk1 &gt;&gt; 4</a>
<a name="ln1452">#endif</a>
<a name="ln1453">						;</a>
<a name="ln1454">					word1(rv) = 0;</a>
<a name="ln1455">					break;</a>
<a name="ln1456">				}</a>
<a name="ln1457">			} else if (!(word0(rv) &amp; Bndry_mask) &amp;&amp; !word1(rv)) {</a>
<a name="ln1458"> drop_down:</a>
<a name="ln1459">				/* boundary case -- decrement exponent */</a>
<a name="ln1460">#ifdef Sudden_Underflow</a>
<a name="ln1461">				L = word0(rv) &amp; Exp_mask;</a>
<a name="ln1462">#ifdef IBM</a>
<a name="ln1463">				if (L &lt;  Exp_msk1)</a>
<a name="ln1464">#else</a>
<a name="ln1465">				if (L &lt;= Exp_msk1)</a>
<a name="ln1466">#endif</a>
<a name="ln1467">					goto undfl;</a>
<a name="ln1468">				L -= Exp_msk1;</a>
<a name="ln1469">#else</a>
<a name="ln1470">				L = (word0(rv) &amp; Exp_mask) - Exp_msk1;</a>
<a name="ln1471">#endif</a>
<a name="ln1472">				word0(rv) = L | Bndry_mask1;</a>
<a name="ln1473">				word1(rv) = 0xffffffff;</a>
<a name="ln1474">#ifdef IBM</a>
<a name="ln1475">				goto cont;</a>
<a name="ln1476">#else</a>
<a name="ln1477">				break;</a>
<a name="ln1478">#endif</a>
<a name="ln1479">			}</a>
<a name="ln1480">#ifndef ROUND_BIASED</a>
<a name="ln1481">			if (!(word1(rv) &amp; LSB))</a>
<a name="ln1482">				break;</a>
<a name="ln1483">#endif</a>
<a name="ln1484">			if (dsign)</a>
<a name="ln1485">				rv += ulp(rv);</a>
<a name="ln1486">#ifndef ROUND_BIASED</a>
<a name="ln1487">			else {</a>
<a name="ln1488">				rv -= ulp(rv);</a>
<a name="ln1489">#ifndef Sudden_Underflow</a>
<a name="ln1490">				if (!rv)</a>
<a name="ln1491">					goto undfl;</a>
<a name="ln1492">#endif</a>
<a name="ln1493">			}</a>
<a name="ln1494">#endif</a>
<a name="ln1495">			break;</a>
<a name="ln1496">		}</a>
<a name="ln1497">		if ((aadj = ratio(delta, bs)) &lt;= 2.) {</a>
<a name="ln1498">			if (dsign)</a>
<a name="ln1499">				aadj = aadj1 = 1.;</a>
<a name="ln1500">			else if (word1(rv) || word0(rv) &amp; Bndry_mask) {</a>
<a name="ln1501">#ifndef Sudden_Underflow</a>
<a name="ln1502">				if (word1(rv) == Tiny1 &amp;&amp; !word0(rv))</a>
<a name="ln1503">					goto undfl;</a>
<a name="ln1504">#endif</a>
<a name="ln1505">				aadj = 1.;</a>
<a name="ln1506">				aadj1 = -1.;</a>
<a name="ln1507">			} else {</a>
<a name="ln1508">				/* special case -- power of FLT_RADIX to be */</a>
<a name="ln1509">				/* rounded down... */</a>
<a name="ln1510"> </a>
<a name="ln1511">				if (aadj &lt; 2./FLT_RADIX)</a>
<a name="ln1512">					aadj = 1./FLT_RADIX;</a>
<a name="ln1513">				else</a>
<a name="ln1514">					aadj *= 0.5;</a>
<a name="ln1515">				aadj1 = -aadj;</a>
<a name="ln1516">			}</a>
<a name="ln1517">		} else {</a>
<a name="ln1518">			aadj *= 0.5;</a>
<a name="ln1519">			aadj1 = dsign ? aadj : -aadj;</a>
<a name="ln1520">#ifdef Check_FLT_ROUNDS</a>
<a name="ln1521">			switch(FLT_ROUNDS) {</a>
<a name="ln1522">				case 2: /* towards +infinity */</a>
<a name="ln1523">					aadj1 -= 0.5;</a>
<a name="ln1524">					break;</a>
<a name="ln1525">				case 0: /* towards 0 */</a>
<a name="ln1526">				case 3: /* towards -infinity */</a>
<a name="ln1527">					aadj1 += 0.5;</a>
<a name="ln1528">			}</a>
<a name="ln1529">#else</a>
<a name="ln1530">			if (FLT_ROUNDS == 0)</a>
<a name="ln1531">				aadj1 += 0.5;</a>
<a name="ln1532">#endif</a>
<a name="ln1533">		}</a>
<a name="ln1534">		y = word0(rv) &amp; Exp_mask;</a>
<a name="ln1535"> </a>
<a name="ln1536">		/* Check for overflow */</a>
<a name="ln1537"> </a>
<a name="ln1538">		if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {</a>
<a name="ln1539">			rv0 = rv;</a>
<a name="ln1540">			word0(rv) -= P*Exp_msk1;</a>
<a name="ln1541">			adj = aadj1 * ulp(rv);</a>
<a name="ln1542">			rv += adj;</a>
<a name="ln1543">			if ((word0(rv) &amp; Exp_mask) &gt;=</a>
<a name="ln1544">					Exp_msk1*(DBL_MAX_EXP+Bias-P)) {</a>
<a name="ln1545">				if (word0(rv0) == Big0 &amp;&amp; word1(rv0) == Big1)</a>
<a name="ln1546">					goto ovfl;</a>
<a name="ln1547">				word0(rv) = Big0;</a>
<a name="ln1548">				word1(rv) = Big1;</a>
<a name="ln1549">				goto cont;</a>
<a name="ln1550">			} else</a>
<a name="ln1551">				word0(rv) += P*Exp_msk1;</a>
<a name="ln1552">		} else {</a>
<a name="ln1553">#ifdef Sudden_Underflow</a>
<a name="ln1554">			if ((word0(rv) &amp; Exp_mask) &lt;= P*Exp_msk1) {</a>
<a name="ln1555">				rv0 = rv;</a>
<a name="ln1556">				word0(rv) += P*Exp_msk1;</a>
<a name="ln1557">				adj = aadj1 * ulp(rv);</a>
<a name="ln1558">				rv += adj;</a>
<a name="ln1559">#ifdef IBM</a>
<a name="ln1560">				if ((word0(rv) &amp; Exp_mask) &lt;  P*Exp_msk1)</a>
<a name="ln1561">#else</a>
<a name="ln1562">				if ((word0(rv) &amp; Exp_mask) &lt;= P*Exp_msk1)</a>
<a name="ln1563">#endif</a>
<a name="ln1564">				{</a>
<a name="ln1565">					if (word0(rv0) == Tiny0</a>
<a name="ln1566">					 &amp;&amp; word1(rv0) == Tiny1)</a>
<a name="ln1567">						goto undfl;</a>
<a name="ln1568">					word0(rv) = Tiny0;</a>
<a name="ln1569">					word1(rv) = Tiny1;</a>
<a name="ln1570">					goto cont;</a>
<a name="ln1571">				} else</a>
<a name="ln1572">					word0(rv) -= P*Exp_msk1;</a>
<a name="ln1573">			} else {</a>
<a name="ln1574">				adj = aadj1 * ulp(rv);</a>
<a name="ln1575">				rv += adj;</a>
<a name="ln1576">			}</a>
<a name="ln1577">#else</a>
<a name="ln1578">			/* Compute adj so that the IEEE rounding rules will</a>
<a name="ln1579">			 * correctly round rv + adj in some half-way cases.</a>
<a name="ln1580">			 * If rv * ulp(rv) is denormalized (i.e.,</a>
<a name="ln1581">			 * y &lt;= (P-1)*Exp_msk1), we must adjust aadj to avoid</a>
<a name="ln1582">			 * trouble from bits lost to denormalization;</a>
<a name="ln1583">			 * example: 1.2e-307 .</a>
<a name="ln1584">			 */</a>
<a name="ln1585">			if (y &lt;= (P-1)*Exp_msk1 &amp;&amp; aadj &gt;= 1.) {</a>
<a name="ln1586">				aadj1 = (double)(int)(aadj + 0.5);</a>
<a name="ln1587">				if (!dsign)</a>
<a name="ln1588">					aadj1 = -aadj1;</a>
<a name="ln1589">			}</a>
<a name="ln1590">			adj = aadj1 * ulp(rv);</a>
<a name="ln1591">			rv += adj;</a>
<a name="ln1592">#endif</a>
<a name="ln1593">		}</a>
<a name="ln1594">		z = word0(rv) &amp; Exp_mask;</a>
<a name="ln1595">		if (y == z) {</a>
<a name="ln1596">			/* Can we stop now? */</a>
<a name="ln1597">			L = aadj;</a>
<a name="ln1598">			aadj -= L;</a>
<a name="ln1599">			/* The tolerances below are conservative. */</a>
<a name="ln1600">			if (dsign || word1(rv) || word0(rv) &amp; Bndry_mask) {</a>
<a name="ln1601">				if (aadj &lt; .4999999 || aadj &gt; .5000001)</a>
<a name="ln1602">					break;</a>
<a name="ln1603">			} else if (aadj &lt; .4999999/FLT_RADIX)</a>
<a name="ln1604">				break;</a>
<a name="ln1605">		}</a>
<a name="ln1606"> cont:</a>
<a name="ln1607">		Bfree(bb);</a>
<a name="ln1608">		Bfree(bd);</a>
<a name="ln1609">		Bfree(bs);</a>
<a name="ln1610">		Bfree(delta);</a>
<a name="ln1611">	}</a>
<a name="ln1612">	Bfree(bb);</a>
<a name="ln1613">	Bfree(bd);</a>
<a name="ln1614">	Bfree(bs);</a>
<a name="ln1615">	Bfree(bd0);</a>
<a name="ln1616">	Bfree(delta);</a>
<a name="ln1617"> ret:</a>
<a name="ln1618">	if (se)</a>
<a name="ln1619">		*se = (char *)s;</a>
<a name="ln1620">	return sign ? -rv : rv;</a>
<a name="ln1621">}</a>
<a name="ln1622"> </a>
<a name="ln1623"> </a>
<a name="ln1624">double __strtod_internal(const char *number, char **_end, int group);</a>
<a name="ln1625"> </a>
<a name="ln1626">double</a>
<a name="ln1627">__strtod_internal(const char *number, char **_end, int group)</a>
<a name="ln1628">{</a>
<a name="ln1629">	// ToDo: group is currently not supported!</a>
<a name="ln1630">	(void)group;</a>
<a name="ln1631"> </a>
<a name="ln1632">	return strtod(number, _end);</a>
<a name="ln1633">}</a>
<a name="ln1634"> </a>
<a name="ln1635">// XXX this is not correct</a>
<a name="ln1636"> </a>
<a name="ln1637">long double __strtold_internal(const char *number, char **_end, int group);</a>
<a name="ln1638"> </a>
<a name="ln1639">long double</a>
<a name="ln1640">__strtold_internal(const char *number, char **_end, int group)</a>
<a name="ln1641">{</a>
<a name="ln1642">	return __strtod_internal(number, _end, group);</a>
<a name="ln1643">}</a>
<a name="ln1644"> </a>
<a name="ln1645">float __strtof_internal(const char *number, char **_end, int group);</a>
<a name="ln1646"> </a>
<a name="ln1647">float</a>
<a name="ln1648">__strtof_internal(const char *number, char **_end, int group)</a>
<a name="ln1649">{</a>
<a name="ln1650">	return __strtod_internal(number, _end, group);</a>
<a name="ln1651">}</a>
<a name="ln1652"> </a>
<a name="ln1653"> </a>
<a name="ln1654">/* removed from the build, is only used by __dtoa() */</a>
<a name="ln1655">#if 0</a>
<a name="ln1656">static int</a>
<a name="ln1657">quorem(Bigint *b, Bigint *S)</a>
<a name="ln1658">{</a>
<a name="ln1659">	int n;</a>
<a name="ln1660">	Long borrow, y;</a>
<a name="ln1661">	ULong carry, q, ys;</a>
<a name="ln1662">	ULong *bx, *bxe, *sx, *sxe;</a>
<a name="ln1663">#ifdef Pack_32</a>
<a name="ln1664">	Long z;</a>
<a name="ln1665">	ULong si, zs;</a>
<a name="ln1666">#endif</a>
<a name="ln1667"> </a>
<a name="ln1668">	n = S-&gt;wds;</a>
<a name="ln1669">#ifdef DEBUG</a>
<a name="ln1670">	/*debug*/ if (b-&gt;wds &gt; n)</a>
<a name="ln1671">	/*debug*/	Bug(&quot;oversize b in quorem&quot;);</a>
<a name="ln1672">#endif</a>
<a name="ln1673">	if (b-&gt;wds &lt; n)</a>
<a name="ln1674">		return 0;</a>
<a name="ln1675">	sx = S-&gt;x;</a>
<a name="ln1676">	sxe = sx + --n;</a>
<a name="ln1677">	bx = b-&gt;x;</a>
<a name="ln1678">	bxe = bx + n;</a>
<a name="ln1679">	q = *bxe / (*sxe + 1);	/* ensure q &lt;= true quotient */</a>
<a name="ln1680">#ifdef DEBUG</a>
<a name="ln1681">	/*debug*/ if (q &gt; 9)</a>
<a name="ln1682">	/*debug*/	Bug(&quot;oversized quotient in quorem&quot;);</a>
<a name="ln1683">#endif</a>
<a name="ln1684">	if (q) {</a>
<a name="ln1685">		borrow = 0;</a>
<a name="ln1686">		carry = 0;</a>
<a name="ln1687">		do {</a>
<a name="ln1688">#ifdef Pack_32</a>
<a name="ln1689">			si = *sx++;</a>
<a name="ln1690">			ys = (si &amp; 0xffff) * q + carry;</a>
<a name="ln1691">			zs = (si &gt;&gt; 16) * q + (ys &gt;&gt; 16);</a>
<a name="ln1692">			carry = zs &gt;&gt; 16;</a>
<a name="ln1693">			y = (*bx &amp; 0xffff) - (ys &amp; 0xffff) + borrow;</a>
<a name="ln1694">			borrow = y &gt;&gt; 16;</a>
<a name="ln1695">			Sign_Extend(borrow, y);</a>
<a name="ln1696">			z = (*bx &gt;&gt; 16) - (zs &amp; 0xffff) + borrow;</a>
<a name="ln1697">			borrow = z &gt;&gt; 16;</a>
<a name="ln1698">			Sign_Extend(borrow, z);</a>
<a name="ln1699">			Storeinc(bx, z, y);</a>
<a name="ln1700">#else</a>
<a name="ln1701">			ys = *sx++ * q + carry;</a>
<a name="ln1702">			carry = ys &gt;&gt; 16;</a>
<a name="ln1703">			y = *bx - (ys &amp; 0xffff) + borrow;</a>
<a name="ln1704">			borrow = y &gt;&gt; 16;</a>
<a name="ln1705">			Sign_Extend(borrow, y);</a>
<a name="ln1706">			*bx++ = y &amp; 0xffff;</a>
<a name="ln1707">#endif</a>
<a name="ln1708">		} while (sx &lt;= sxe);</a>
<a name="ln1709">		if (!*bxe) {</a>
<a name="ln1710">			bx = b-&gt;x;</a>
<a name="ln1711">			while (--bxe &gt; bx &amp;&amp; !*bxe)</a>
<a name="ln1712">				--n;</a>
<a name="ln1713">			b-&gt;wds = n;</a>
<a name="ln1714">		}</a>
<a name="ln1715">	}</a>
<a name="ln1716">	if (cmp(b, S) &gt;= 0) {</a>
<a name="ln1717">		q++;</a>
<a name="ln1718">		borrow = 0;</a>
<a name="ln1719">		carry = 0;</a>
<a name="ln1720">		bx = b-&gt;x;</a>
<a name="ln1721">		sx = S-&gt;x;</a>
<a name="ln1722">		do {</a>
<a name="ln1723">#ifdef Pack_32</a>
<a name="ln1724">			si = *sx++;</a>
<a name="ln1725">			ys = (si &amp; 0xffff) + carry;</a>
<a name="ln1726">			zs = (si &gt;&gt; 16) + (ys &gt;&gt; 16);</a>
<a name="ln1727">			carry = zs &gt;&gt; 16;</a>
<a name="ln1728">			y = (*bx &amp; 0xffff) - (ys &amp; 0xffff) + borrow;</a>
<a name="ln1729">			borrow = y &gt;&gt; 16;</a>
<a name="ln1730">			Sign_Extend(borrow, y);</a>
<a name="ln1731">			z = (*bx &gt;&gt; 16) - (zs &amp; 0xffff) + borrow;</a>
<a name="ln1732">			borrow = z &gt;&gt; 16;</a>
<a name="ln1733">			Sign_Extend(borrow, z);</a>
<a name="ln1734">			Storeinc(bx, z, y);</a>
<a name="ln1735">#else</a>
<a name="ln1736">			ys = *sx++ + carry;</a>
<a name="ln1737">			carry = ys &gt;&gt; 16;</a>
<a name="ln1738">			y = *bx - (ys &amp; 0xffff) + borrow;</a>
<a name="ln1739">			borrow = y &gt;&gt; 16;</a>
<a name="ln1740">			Sign_Extend(borrow, y);</a>
<a name="ln1741">			*bx++ = y &amp; 0xffff;</a>
<a name="ln1742">#endif</a>
<a name="ln1743">		} while (sx &lt;= sxe);</a>
<a name="ln1744">		bx = b-&gt;x;</a>
<a name="ln1745">		bxe = bx + n;</a>
<a name="ln1746">		if (!*bxe) {</a>
<a name="ln1747">			while (--bxe &gt; bx &amp;&amp; !*bxe)</a>
<a name="ln1748">				--n;</a>
<a name="ln1749">			b-&gt;wds = n;</a>
<a name="ln1750">		}</a>
<a name="ln1751">	}</a>
<a name="ln1752">	return q;</a>
<a name="ln1753">}</a>
<a name="ln1754">#endif	/* removed from the build, is only used by __dtoa() */</a>
<a name="ln1755"> </a>
<a name="ln1756">/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.</a>
<a name="ln1757"> *</a>
<a name="ln1758"> * Inspired by &quot;How to Print Floating-Point Numbers Accurately&quot; by</a>
<a name="ln1759"> * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].</a>
<a name="ln1760"> *</a>
<a name="ln1761"> * Modifications:</a>
<a name="ln1762"> *	1. Rather than iterating, we use a simple numeric overestimate</a>
<a name="ln1763"> *	   to determine k = floor(log10(d)).  We scale relevant</a>
<a name="ln1764"> *	   quantities using O(log2(k)) rather than O(k) multiplications.</a>
<a name="ln1765"> *	2. For some modes &gt; 2 (corresponding to ecvt and fcvt), we don't</a>
<a name="ln1766"> *	   try to generate digits strictly left to right.  Instead, we</a>
<a name="ln1767"> *	   compute with fewer bits and propagate the carry if necessary</a>
<a name="ln1768"> *	   when rounding the final digit up.  This is often faster.</a>
<a name="ln1769"> *	3. Under the assumption that input will be rounded nearest,</a>
<a name="ln1770"> *	   mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.</a>
<a name="ln1771"> *	   That is, we allow equality in stopping tests when the</a>
<a name="ln1772"> *	   round-nearest rule will give the same floating-point value</a>
<a name="ln1773"> *	   as would satisfaction of the stopping test with strict</a>
<a name="ln1774"> *	   inequality.</a>
<a name="ln1775"> *	4. We remove common factors of powers of 2 from relevant</a>
<a name="ln1776"> *	   quantities.</a>
<a name="ln1777"> *	5. When converting floating-point integers less than 1e16,</a>
<a name="ln1778"> *	   we use floating-point arithmetic rather than resorting</a>
<a name="ln1779"> *	   to multiple-precision integers.</a>
<a name="ln1780"> *	6. When asked to produce fewer than 15 digits, we first try</a>
<a name="ln1781"> *	   to get by with floating-point arithmetic; we resort to</a>
<a name="ln1782"> *	   multiple-precision integer arithmetic only if we cannot</a>
<a name="ln1783"> *	   guarantee that the floating-point calculation has given</a>
<a name="ln1784"> *	   the correctly rounded result.  For k requested digits and</a>
<a name="ln1785"> *	   &quot;uniformly&quot; distributed input, the probability is</a>
<a name="ln1786"> *	   something like 10^(k-15) that we must resort to the Long</a>
<a name="ln1787"> *	   calculation.</a>
<a name="ln1788"> */</a>
<a name="ln1789"> </a>
<a name="ln1790">#if 0</a>
<a name="ln1791">char *</a>
<a name="ln1792">__dtoa(double d, int mode, int ndigits, int *decpt, int *sign, char **rve,</a>
<a name="ln1793">	 char **resultp)</a>
<a name="ln1794">{</a>
<a name="ln1795"> /*	Arguments ndigits, decpt, sign are similar to those</a>
<a name="ln1796">	of ecvt and fcvt; trailing zeros are suppressed from</a>
<a name="ln1797">	the returned string.  If not null, *rve is set to point</a>
<a name="ln1798">	to the end of the return value.  If d is +-Infinity or NaN,</a>
<a name="ln1799">	then *decpt is set to 9999.</a>
<a name="ln1800"> </a>
<a name="ln1801">	mode:</a>
<a name="ln1802">		0 ==&gt; shortest string that yields d when read in</a>
<a name="ln1803">			and rounded to nearest.</a>
<a name="ln1804">		1 ==&gt; like 0, but with Steele &amp; White stopping rule;</a>
<a name="ln1805">			e.g. with IEEE P754 arithmetic , mode 0 gives</a>
<a name="ln1806">			1e23 whereas mode 1 gives 9.999999999999999e22.</a>
<a name="ln1807">		2 ==&gt; max(1,ndigits) significant digits.  This gives a</a>
<a name="ln1808">			return value similar to that of ecvt, except</a>
<a name="ln1809">			that trailing zeros are suppressed.</a>
<a name="ln1810">		3 ==&gt; through ndigits past the decimal point.  This</a>
<a name="ln1811">			gives a return value similar to that from fcvt,</a>
<a name="ln1812">			except that trailing zeros are suppressed, and</a>
<a name="ln1813">			ndigits can be negative.</a>
<a name="ln1814">		4-9 should give the same return values as 2-3, i.e.,</a>
<a name="ln1815">			4 &lt;= mode &lt;= 9 ==&gt; same return as mode</a>
<a name="ln1816">			2 + (mode &amp; 1).  These modes are mainly for</a>
<a name="ln1817">			debugging; often they run slower but sometimes</a>
<a name="ln1818">			faster than modes 2-3.</a>
<a name="ln1819">		4,5,8,9 ==&gt; left-to-right digit generation.</a>
<a name="ln1820">		6-9 ==&gt; don't try fast floating-point estimate</a>
<a name="ln1821">			(if applicable).</a>
<a name="ln1822"> </a>
<a name="ln1823">		Values of mode other than 0-9 are treated as mode 0.</a>
<a name="ln1824"> </a>
<a name="ln1825">		Sufficient space is allocated to the return value</a>
<a name="ln1826">		to hold the suppressed trailing zeros.</a>
<a name="ln1827">	*/</a>
<a name="ln1828"> </a>
<a name="ln1829">	int bbits, b2, b5, be, dig, i, ieps, ilim, ilim0, ilim1,</a>
<a name="ln1830">		j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,</a>
<a name="ln1831">		spec_case, try_quick;</a>
<a name="ln1832">	Long L;</a>
<a name="ln1833">#ifndef Sudden_Underflow</a>
<a name="ln1834">	int denorm;</a>
<a name="ln1835">	ULong x;</a>
<a name="ln1836">#endif</a>
<a name="ln1837">	Bigint *b, *b1, *delta, *mlo, *mhi, *S;</a>
<a name="ln1838">	double d2, ds, eps;</a>
<a name="ln1839">	char *s, *s0;</a>
<a name="ln1840"> </a>
<a name="ln1841">	if (word0(d) &amp; Sign_bit) {</a>
<a name="ln1842">		/* set sign for everything, including 0's and NaNs */</a>
<a name="ln1843">		*sign = 1;</a>
<a name="ln1844">		word0(d) &amp;= ~Sign_bit;	/* clear sign bit */</a>
<a name="ln1845">	}</a>
<a name="ln1846">	else</a>
<a name="ln1847">		*sign = 0;</a>
<a name="ln1848"> </a>
<a name="ln1849">#if defined(IEEE_Arith) + defined(VAX)</a>
<a name="ln1850">#ifdef IEEE_Arith</a>
<a name="ln1851">	if ((word0(d) &amp; Exp_mask) == Exp_mask)</a>
<a name="ln1852">#else</a>
<a name="ln1853">	if (word0(d)  == 0x8000)</a>
<a name="ln1854">#endif</a>
<a name="ln1855">	{</a>
<a name="ln1856">		/* Infinity or NaN */</a>
<a name="ln1857">		*decpt = 9999;</a>
<a name="ln1858">		s =</a>
<a name="ln1859">#ifdef IEEE_Arith</a>
<a name="ln1860">			!word1(d) &amp;&amp; !(word0(d) &amp; 0xfffff) ? &quot;Infinity&quot; :</a>
<a name="ln1861">#endif</a>
<a name="ln1862">				&quot;NaN&quot;;</a>
<a name="ln1863">		if (rve)</a>
<a name="ln1864">			*rve =</a>
<a name="ln1865">#ifdef IEEE_Arith</a>
<a name="ln1866">				s[3] ? s + 8 :</a>
<a name="ln1867">#endif</a>
<a name="ln1868">						s + 3;</a>
<a name="ln1869">		return s;</a>
<a name="ln1870">	}</a>
<a name="ln1871">#endif</a>
<a name="ln1872">#ifdef IBM</a>
<a name="ln1873">	d += 0; /* normalize */</a>
<a name="ln1874">#endif</a>
<a name="ln1875">	if (!d) {</a>
<a name="ln1876">		*decpt = 1;</a>
<a name="ln1877">		s = &quot;0&quot;;</a>
<a name="ln1878">		if (rve)</a>
<a name="ln1879">			*rve = s + 1;</a>
<a name="ln1880">		return s;</a>
<a name="ln1881">	}</a>
<a name="ln1882"> </a>
<a name="ln1883">	b = d2b(d, &amp;be, &amp;bbits);</a>
<a name="ln1884">#ifdef Sudden_Underflow</a>
<a name="ln1885">	i = (int)(word0(d) &gt;&gt; Exp_shift1 &amp; (Exp_mask&gt;&gt;Exp_shift1));</a>
<a name="ln1886">#else</a>
<a name="ln1887">	if ( (i = (int)((word0(d) &gt;&gt; Exp_shift1) &amp; (Exp_mask&gt;&gt;Exp_shift1))) ) {</a>
<a name="ln1888">#endif</a>
<a name="ln1889">		d2 = d;</a>
<a name="ln1890">		word0(d2) &amp;= Frac_mask1;</a>
<a name="ln1891">		word0(d2) |= Exp_11;</a>
<a name="ln1892">#ifdef IBM</a>
<a name="ln1893">		if ( (j = 11 - hi0bits(word0(d2) &amp; Frac_mask)) )</a>
<a name="ln1894">			d2 /= 1 &lt;&lt; j;</a>
<a name="ln1895">#endif</a>
<a name="ln1896"> </a>
<a name="ln1897">		/* log(x)	~=~ log(1.5) + (x-1.5)/1.5</a>
<a name="ln1898">		 * log10(x)	 =  log(x) / log(10)</a>
<a name="ln1899">		 *		~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))</a>
<a name="ln1900">		 * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)</a>
<a name="ln1901">		 *</a>
<a name="ln1902">		 * This suggests computing an approximation k to log10(d) by</a>
<a name="ln1903">		 *</a>
<a name="ln1904">		 * k = (i - Bias)*0.301029995663981</a>
<a name="ln1905">		 *	+ ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );</a>
<a name="ln1906">		 *</a>
<a name="ln1907">		 * We want k to be too large rather than too small.</a>
<a name="ln1908">		 * The error in the first-order Taylor series approximation</a>
<a name="ln1909">		 * is in our favor, so we just round up the constant enough</a>
<a name="ln1910">		 * to compensate for any error in the multiplication of</a>
<a name="ln1911">		 * (i - Bias) by 0.301029995663981; since |i - Bias| &lt;= 1077,</a>
<a name="ln1912">		 * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,</a>
<a name="ln1913">		 * adding 1e-13 to the constant term more than suffices.</a>
<a name="ln1914">		 * Hence we adjust the constant term to 0.1760912590558.</a>
<a name="ln1915">		 * (We could get a more accurate k by invoking log10,</a>
<a name="ln1916">		 *  but this is probably not worthwhile.)</a>
<a name="ln1917">		 */</a>
<a name="ln1918"> </a>
<a name="ln1919">		i -= Bias;</a>
<a name="ln1920">#ifdef IBM</a>
<a name="ln1921">		i &lt;&lt;= 2;</a>
<a name="ln1922">		i += j;</a>
<a name="ln1923">#endif</a>
<a name="ln1924">#ifndef Sudden_Underflow</a>
<a name="ln1925">		denorm = 0;</a>
<a name="ln1926">	} else {</a>
<a name="ln1927">		/* d is denormalized */</a>
<a name="ln1928"> </a>
<a name="ln1929">		i = bbits + be + (Bias + (P-1) - 1);</a>
<a name="ln1930">		x = i &gt; 32  ? ((word0(d) &lt;&lt; (64 - i)) | (word1(d) &gt;&gt; (i - 32)))</a>
<a name="ln1931">			    : (word1(d) &lt;&lt; (32 - i));</a>
<a name="ln1932">		d2 = x;</a>
<a name="ln1933">		word0(d2) -= 31*Exp_msk1; /* adjust exponent */</a>
<a name="ln1934">		i -= (Bias + (P-1) - 1) + 1;</a>
<a name="ln1935">		denorm = 1;</a>
<a name="ln1936">	}</a>
<a name="ln1937">#endif</a>
<a name="ln1938">	ds = (d2-1.5)*0.289529654602168 + 0.1760912590558 + i*0.301029995663981;</a>
<a name="ln1939">	k = (int)ds;</a>
<a name="ln1940">	if (ds &lt; 0. &amp;&amp; ds != k)</a>
<a name="ln1941">		k--;	/* want k = floor(ds) */</a>
<a name="ln1942">	k_check = 1;</a>
<a name="ln1943">	if (k &gt;= 0 &amp;&amp; k &lt;= Ten_pmax) {</a>
<a name="ln1944">		if (d &lt; tens[k])</a>
<a name="ln1945">			k--;</a>
<a name="ln1946">		k_check = 0;</a>
<a name="ln1947">	}</a>
<a name="ln1948">	j = bbits - i - 1;</a>
<a name="ln1949">	if (j &gt;= 0) {</a>
<a name="ln1950">		b2 = 0;</a>
<a name="ln1951">		s2 = j;</a>
<a name="ln1952">	} else {</a>
<a name="ln1953">		b2 = -j;</a>
<a name="ln1954">		s2 = 0;</a>
<a name="ln1955">	}</a>
<a name="ln1956">	if (k &gt;= 0) {</a>
<a name="ln1957">		b5 = 0;</a>
<a name="ln1958">		s5 = k;</a>
<a name="ln1959">		s2 += k;</a>
<a name="ln1960">	} else {</a>
<a name="ln1961">		b2 -= k;</a>
<a name="ln1962">		b5 = -k;</a>
<a name="ln1963">		s5 = 0;</a>
<a name="ln1964">	}</a>
<a name="ln1965">	if (mode &lt; 0 || mode &gt; 9)</a>
<a name="ln1966">		mode = 0;</a>
<a name="ln1967">	try_quick = 1;</a>
<a name="ln1968">	if (mode &gt; 5) {</a>
<a name="ln1969">		mode -= 4;</a>
<a name="ln1970">		try_quick = 0;</a>
<a name="ln1971">	}</a>
<a name="ln1972">	leftright = 1;</a>
<a name="ln1973">	switch(mode) {</a>
<a name="ln1974">		case 0:</a>
<a name="ln1975">		case 1:</a>
<a name="ln1976">			ilim = ilim1 = -1;</a>
<a name="ln1977">			i = 18;</a>
<a name="ln1978">			ndigits = 0;</a>
<a name="ln1979">			break;</a>
<a name="ln1980">		case 2:</a>
<a name="ln1981">			leftright = 0;</a>
<a name="ln1982">			/* no break */</a>
<a name="ln1983">		case 4:</a>
<a name="ln1984">			if (ndigits &lt;= 0)</a>
<a name="ln1985">				ndigits = 1;</a>
<a name="ln1986">			ilim = ilim1 = i = ndigits;</a>
<a name="ln1987">			break;</a>
<a name="ln1988">		case 3:</a>
<a name="ln1989">			leftright = 0;</a>
<a name="ln1990">			/* no break */</a>
<a name="ln1991">		case 5:</a>
<a name="ln1992">			i = ndigits + k + 1;</a>
<a name="ln1993">			ilim = i;</a>
<a name="ln1994">			ilim1 = i - 1;</a>
<a name="ln1995">			if (i &lt;= 0)</a>
<a name="ln1996">				i = 1;</a>
<a name="ln1997">	}</a>
<a name="ln1998">	*resultp = (char *) malloc(i + 1);</a>
<a name="ln1999">	s = s0 = *resultp;</a>
<a name="ln2000"> </a>
<a name="ln2001">	if (ilim &gt;= 0 &amp;&amp; ilim &lt;= Quick_max &amp;&amp; try_quick) {</a>
<a name="ln2002"> </a>
<a name="ln2003">		/* Try to get by with floating-point arithmetic. */</a>
<a name="ln2004"> </a>
<a name="ln2005">		i = 0;</a>
<a name="ln2006">		d2 = d;</a>
<a name="ln2007">		k0 = k;</a>
<a name="ln2008">		ilim0 = ilim;</a>
<a name="ln2009">		ieps = 2; /* conservative */</a>
<a name="ln2010">		if (k &gt; 0) {</a>
<a name="ln2011">			ds = tens[k&amp;0xf];</a>
<a name="ln2012">			j = k &gt;&gt; 4;</a>
<a name="ln2013">			if (j &amp; Bletch) {</a>
<a name="ln2014">				/* prevent overflows */</a>
<a name="ln2015">				j &amp;= Bletch - 1;</a>
<a name="ln2016">				d /= bigtens[n_bigtens-1];</a>
<a name="ln2017">				ieps++;</a>
<a name="ln2018">			}</a>
<a name="ln2019">			for (; j; j &gt;&gt;= 1, i++)</a>
<a name="ln2020">				if (j &amp; 1) {</a>
<a name="ln2021">					ieps++;</a>
<a name="ln2022">					ds *= bigtens[i];</a>
<a name="ln2023">				}</a>
<a name="ln2024">			d /= ds;</a>
<a name="ln2025">		} else if ( (j1 = -k) ) {</a>
<a name="ln2026">			d *= tens[j1 &amp; 0xf];</a>
<a name="ln2027">			for (j = j1 &gt;&gt; 4; j; j &gt;&gt;= 1, i++)</a>
<a name="ln2028">				if (j &amp; 1) {</a>
<a name="ln2029">					ieps++;</a>
<a name="ln2030">					d *= bigtens[i];</a>
<a name="ln2031">				}</a>
<a name="ln2032">		}</a>
<a name="ln2033">		if (k_check &amp;&amp; d &lt; 1. &amp;&amp; ilim &gt; 0) {</a>
<a name="ln2034">			if (ilim1 &lt;= 0)</a>
<a name="ln2035">				goto fast_failed;</a>
<a name="ln2036">			ilim = ilim1;</a>
<a name="ln2037">			k--;</a>
<a name="ln2038">			d *= 10.;</a>
<a name="ln2039">			ieps++;</a>
<a name="ln2040">		}</a>
<a name="ln2041">		eps = ieps*d + 7.;</a>
<a name="ln2042">		word0(eps) -= (P-1)*Exp_msk1;</a>
<a name="ln2043">		if (ilim == 0) {</a>
<a name="ln2044">			S = mhi = 0;</a>
<a name="ln2045">			d -= 5.;</a>
<a name="ln2046">			if (d &gt; eps)</a>
<a name="ln2047">				goto one_digit;</a>
<a name="ln2048">			if (d &lt; -eps)</a>
<a name="ln2049">				goto no_digits;</a>
<a name="ln2050">			goto fast_failed;</a>
<a name="ln2051">		}</a>
<a name="ln2052">#ifndef No_leftright</a>
<a name="ln2053">		if (leftright) {</a>
<a name="ln2054">			/* Use Steele &amp; White method of only</a>
<a name="ln2055">			 * generating digits needed.</a>
<a name="ln2056">			 */</a>
<a name="ln2057">			eps = 0.5/tens[ilim-1] - eps;</a>
<a name="ln2058">			for (i = 0;;) {</a>
<a name="ln2059">				L = d;</a>
<a name="ln2060">				d -= L;</a>
<a name="ln2061">				*s++ = '0' + (int)L;</a>
<a name="ln2062">				if (d &lt; eps)</a>
<a name="ln2063">					goto ret1;</a>
<a name="ln2064">				if (1. - d &lt; eps)</a>
<a name="ln2065">					goto bump_up;</a>
<a name="ln2066">				if (++i &gt;= ilim)</a>
<a name="ln2067">					break;</a>
<a name="ln2068">				eps *= 10.;</a>
<a name="ln2069">				d *= 10.;</a>
<a name="ln2070">			}</a>
<a name="ln2071">		} else {</a>
<a name="ln2072">#endif</a>
<a name="ln2073">			/* Generate ilim digits, then fix them up. */</a>
<a name="ln2074">			eps *= tens[ilim-1];</a>
<a name="ln2075">			for (i = 1;; i++, d *= 10.) {</a>
<a name="ln2076">				L = d;</a>
<a name="ln2077">				d -= L;</a>
<a name="ln2078">				*s++ = '0' + (int)L;</a>
<a name="ln2079">				if (i == ilim) {</a>
<a name="ln2080">					if (d &gt; 0.5 + eps)</a>
<a name="ln2081">						goto bump_up;</a>
<a name="ln2082">					else if (d &lt; 0.5 - eps) {</a>
<a name="ln2083">						while (*--s == '0');</a>
<a name="ln2084">						s++;</a>
<a name="ln2085">						goto ret1;</a>
<a name="ln2086">					}</a>
<a name="ln2087">					break;</a>
<a name="ln2088">				}</a>
<a name="ln2089">			}</a>
<a name="ln2090">#ifndef No_leftright</a>
<a name="ln2091">		}</a>
<a name="ln2092">#endif</a>
<a name="ln2093"> fast_failed:</a>
<a name="ln2094">		s = s0;</a>
<a name="ln2095">		d = d2;</a>
<a name="ln2096">		k = k0;</a>
<a name="ln2097">		ilim = ilim0;</a>
<a name="ln2098">	}</a>
<a name="ln2099"> </a>
<a name="ln2100">	/* Do we have a &quot;small&quot; integer? */</a>
<a name="ln2101"> </a>
<a name="ln2102">	if (be &gt;= 0 &amp;&amp; k &lt;= Int_max) {</a>
<a name="ln2103">		/* Yes. */</a>
<a name="ln2104">		ds = tens[k];</a>
<a name="ln2105">		if (ndigits &lt; 0 &amp;&amp; ilim &lt;= 0) {</a>
<a name="ln2106">			S = mhi = 0;</a>
<a name="ln2107">			if (ilim &lt; 0 || d &lt;= 5*ds)</a>
<a name="ln2108">				goto no_digits;</a>
<a name="ln2109">			goto one_digit;</a>
<a name="ln2110">		}</a>
<a name="ln2111">		for (i = 1;; i++) {</a>
<a name="ln2112">			L = d / ds;</a>
<a name="ln2113">			d -= L*ds;</a>
<a name="ln2114">#ifdef Check_FLT_ROUNDS</a>
<a name="ln2115">			/* If FLT_ROUNDS == 2, L will usually be high by 1 */</a>
<a name="ln2116">			if (d &lt; 0) {</a>
<a name="ln2117">				L--;</a>
<a name="ln2118">				d += ds;</a>
<a name="ln2119">			}</a>
<a name="ln2120">#endif</a>
<a name="ln2121">			*s++ = '0' + (int)L;</a>
<a name="ln2122">			if (i == ilim) {</a>
<a name="ln2123">				d += d;</a>
<a name="ln2124">				if (d &gt; ds || (d == ds &amp;&amp; L &amp; 1)) {</a>
<a name="ln2125"> bump_up:</a>
<a name="ln2126">					while (*--s == '9')</a>
<a name="ln2127">						if (s == s0) {</a>
<a name="ln2128">							k++;</a>
<a name="ln2129">							*s = '0';</a>
<a name="ln2130">							break;</a>
<a name="ln2131">						}</a>
<a name="ln2132">					++*s++;</a>
<a name="ln2133">				}</a>
<a name="ln2134">				break;</a>
<a name="ln2135">			}</a>
<a name="ln2136">			if (!(d *= 10.))</a>
<a name="ln2137">				break;</a>
<a name="ln2138">		}</a>
<a name="ln2139">		goto ret1;</a>
<a name="ln2140">	}</a>
<a name="ln2141"> </a>
<a name="ln2142">	m2 = b2;</a>
<a name="ln2143">	m5 = b5;</a>
<a name="ln2144">	mhi = mlo = 0;</a>
<a name="ln2145">	if (leftright) {</a>
<a name="ln2146">		if (mode &lt; 2) {</a>
<a name="ln2147">			i =</a>
<a name="ln2148">#ifndef Sudden_Underflow</a>
<a name="ln2149">				denorm ? be + (Bias + (P-1) - 1 + 1) :</a>
<a name="ln2150">#endif</a>
<a name="ln2151">#ifdef IBM</a>
<a name="ln2152">				1 + 4*P - 3 - bbits + ((bbits + be - 1) &amp; 3);</a>
<a name="ln2153">#else</a>
<a name="ln2154">				1 + P - bbits;</a>
<a name="ln2155">#endif</a>
<a name="ln2156">		} else {</a>
<a name="ln2157">			j = ilim - 1;</a>
<a name="ln2158">			if (m5 &gt;= j)</a>
<a name="ln2159">				m5 -= j;</a>
<a name="ln2160">			else {</a>
<a name="ln2161">				s5 += j -= m5;</a>
<a name="ln2162">				b5 += j;</a>
<a name="ln2163">				m5 = 0;</a>
<a name="ln2164">			}</a>
<a name="ln2165">			if ((i = ilim) &lt; 0) {</a>
<a name="ln2166">				m2 -= i;</a>
<a name="ln2167">				i = 0;</a>
<a name="ln2168">			}</a>
<a name="ln2169">		}</a>
<a name="ln2170">		b2 += i;</a>
<a name="ln2171">		s2 += i;</a>
<a name="ln2172">		mhi = i2b(1);</a>
<a name="ln2173">	}</a>
<a name="ln2174">	if (m2 &gt; 0 &amp;&amp; s2 &gt; 0) {</a>
<a name="ln2175">		i = m2 &lt; s2 ? m2 : s2;</a>
<a name="ln2176">		b2 -= i;</a>
<a name="ln2177">		m2 -= i;</a>
<a name="ln2178">		s2 -= i;</a>
<a name="ln2179">	}</a>
<a name="ln2180">	if (b5 &gt; 0) {</a>
<a name="ln2181">		if (leftright) {</a>
<a name="ln2182">			if (m5 &gt; 0) {</a>
<a name="ln2183">				mhi = pow5mult(mhi, m5);</a>
<a name="ln2184">				b1 = mult(mhi, b);</a>
<a name="ln2185">				Bfree(b);</a>
<a name="ln2186">				b = b1;</a>
<a name="ln2187">				}</a>
<a name="ln2188">			if ( (j = b5 - m5) )</a>
<a name="ln2189">				b = pow5mult(b, j);</a>
<a name="ln2190">		} else</a>
<a name="ln2191">			b = pow5mult(b, b5);</a>
<a name="ln2192">	}</a>
<a name="ln2193">	S = i2b(1);</a>
<a name="ln2194">	if (s5 &gt; 0)</a>
<a name="ln2195">		S = pow5mult(S, s5);</a>
<a name="ln2196"> </a>
<a name="ln2197">	/* Check for special case that d is a normalized power of 2. */</a>
<a name="ln2198"> </a>
<a name="ln2199">	if (mode &lt; 2) {</a>
<a name="ln2200">		if (!word1(d) &amp;&amp; !(word0(d) &amp; Bndry_mask)</a>
<a name="ln2201">#ifndef Sudden_Underflow</a>
<a name="ln2202">		 &amp;&amp; word0(d) &amp; Exp_mask</a>
<a name="ln2203">#endif</a>
<a name="ln2204">				) {</a>
<a name="ln2205">			/* The special case */</a>
<a name="ln2206">			b2 += Log2P;</a>
<a name="ln2207">			s2 += Log2P;</a>
<a name="ln2208">			spec_case = 1;</a>
<a name="ln2209">		} else</a>
<a name="ln2210">			spec_case = 0;</a>
<a name="ln2211">	}</a>
<a name="ln2212"> </a>
<a name="ln2213">	/* Arrange for convenient computation of quotients:</a>
<a name="ln2214">	 * shift left if necessary so divisor has 4 leading 0 bits.</a>
<a name="ln2215">	 *</a>
<a name="ln2216">	 * Perhaps we should just compute leading 28 bits of S once</a>
<a name="ln2217">	 * and for all and pass them and a shift to quorem, so it</a>
<a name="ln2218">	 * can do shifts and ors to compute the numerator for q.</a>
<a name="ln2219">	 */</a>
<a name="ln2220">#ifdef Pack_32</a>
<a name="ln2221">	if ( (i = ((s5 ? 32 - hi0bits(S-&gt;x[S-&gt;wds-1]) : 1) + s2) &amp; 0x1f) )</a>
<a name="ln2222">		i = 32 - i;</a>
<a name="ln2223">#else</a>
<a name="ln2224">	if ( (i = ((s5 ? 32 - hi0bits(S-&gt;x[S-&gt;wds-1]) : 1) + s2) &amp; 0xf) )</a>
<a name="ln2225">		i = 16 - i;</a>
<a name="ln2226">#endif</a>
<a name="ln2227">	if (i &gt; 4) {</a>
<a name="ln2228">		i -= 4;</a>
<a name="ln2229">		b2 += i;</a>
<a name="ln2230">		m2 += i;</a>
<a name="ln2231">		s2 += i;</a>
<a name="ln2232">	} else if (i &lt; 4) {</a>
<a name="ln2233">		i += 28;</a>
<a name="ln2234">		b2 += i;</a>
<a name="ln2235">		m2 += i;</a>
<a name="ln2236">		s2 += i;</a>
<a name="ln2237">	}</a>
<a name="ln2238">	if (b2 &gt; 0)</a>
<a name="ln2239">		b = lshift(b, b2);</a>
<a name="ln2240">	if (s2 &gt; 0)</a>
<a name="ln2241">		S = lshift(S, s2);</a>
<a name="ln2242">	if (k_check) {</a>
<a name="ln2243">		if (cmp(b,S) &lt; 0) {</a>
<a name="ln2244">			k--;</a>
<a name="ln2245">			b = multadd(b, 10, 0);	/* we botched the k estimate */</a>
<a name="ln2246">			if (leftright)</a>
<a name="ln2247">				mhi = multadd(mhi, 10, 0);</a>
<a name="ln2248">			ilim = ilim1;</a>
<a name="ln2249">		}</a>
<a name="ln2250">	}</a>
<a name="ln2251">	if (ilim &lt;= 0 &amp;&amp; mode &gt; 2) {</a>
<a name="ln2252">		if (ilim &lt; 0 || cmp(b,S = multadd(S,5,0)) &lt;= 0) {</a>
<a name="ln2253">			/* no digits, fcvt style */</a>
<a name="ln2254"> no_digits:</a>
<a name="ln2255">			k = -1 - ndigits;</a>
<a name="ln2256">			goto ret;</a>
<a name="ln2257">		}</a>
<a name="ln2258"> one_digit:</a>
<a name="ln2259">		*s++ = '1';</a>
<a name="ln2260">		k++;</a>
<a name="ln2261">		goto ret;</a>
<a name="ln2262">	}</a>
<a name="ln2263">	if (leftright) {</a>
<a name="ln2264">		if (m2 &gt; 0)</a>
<a name="ln2265">			mhi = lshift(mhi, m2);</a>
<a name="ln2266"> </a>
<a name="ln2267">		/* Compute mlo -- check for special case</a>
<a name="ln2268">		 * that d is a normalized power of 2.</a>
<a name="ln2269">		 */</a>
<a name="ln2270"> </a>
<a name="ln2271">		mlo = mhi;</a>
<a name="ln2272">		if (spec_case) {</a>
<a name="ln2273">			mhi = Balloc(mhi-&gt;k);</a>
<a name="ln2274">			Bcopy(mhi, mlo);</a>
<a name="ln2275">			mhi = lshift(mhi, Log2P);</a>
<a name="ln2276">		}</a>
<a name="ln2277"> </a>
<a name="ln2278">		for (i = 1;;i++) {</a>
<a name="ln2279">			dig = quorem(b,S) + '0';</a>
<a name="ln2280">			/* Do we yet have the shortest decimal string</a>
<a name="ln2281">			 * that will round to d?</a>
<a name="ln2282">			 */</a>
<a name="ln2283">			j = cmp(b, mlo);</a>
<a name="ln2284">			delta = diff(S, mhi);</a>
<a name="ln2285">			j1 = delta-&gt;sign ? 1 : cmp(b, delta);</a>
<a name="ln2286">			Bfree(delta);</a>
<a name="ln2287">#ifndef ROUND_BIASED</a>
<a name="ln2288">			if (j1 == 0 &amp;&amp; !mode &amp;&amp; !(word1(d) &amp; 1)) {</a>
<a name="ln2289">				if (dig == '9')</a>
<a name="ln2290">					goto round_9_up;</a>
<a name="ln2291">				if (j &gt; 0)</a>
<a name="ln2292">					dig++;</a>
<a name="ln2293">				*s++ = dig;</a>
<a name="ln2294">				goto ret;</a>
<a name="ln2295">			}</a>
<a name="ln2296">#endif</a>
<a name="ln2297">			if (j &lt; 0 || (j == 0 &amp;&amp; !mode</a>
<a name="ln2298">#ifndef ROUND_BIASED</a>
<a name="ln2299">							&amp;&amp; !(word1(d) &amp; 1)</a>
<a name="ln2300">#endif</a>
<a name="ln2301">					)) {</a>
<a name="ln2302">				if (j1 &gt; 0) {</a>
<a name="ln2303">					b = lshift(b, 1);</a>
<a name="ln2304">					j1 = cmp(b, S);</a>
<a name="ln2305">					if ((j1 &gt; 0 || (j1 == 0 &amp;&amp; dig &amp; 1))</a>
<a name="ln2306">					&amp;&amp; dig++ == '9')</a>
<a name="ln2307">						goto round_9_up;</a>
<a name="ln2308">				}</a>
<a name="ln2309">				*s++ = dig;</a>
<a name="ln2310">				goto ret;</a>
<a name="ln2311">			}</a>
<a name="ln2312">			if (j1 &gt; 0) {</a>
<a name="ln2313">				if (dig == '9') { /* possible if i == 1 */</a>
<a name="ln2314"> round_9_up:</a>
<a name="ln2315">					*s++ = '9';</a>
<a name="ln2316">					goto roundoff;</a>
<a name="ln2317">				}</a>
<a name="ln2318">				*s++ = dig + 1;</a>
<a name="ln2319">				goto ret;</a>
<a name="ln2320">			}</a>
<a name="ln2321">			*s++ = dig;</a>
<a name="ln2322">			if (i == ilim)</a>
<a name="ln2323">				break;</a>
<a name="ln2324">			b = multadd(b, 10, 0);</a>
<a name="ln2325">			if (mlo == mhi)</a>
<a name="ln2326">				mlo = mhi = multadd(mhi, 10, 0);</a>
<a name="ln2327">			else {</a>
<a name="ln2328">				mlo = multadd(mlo, 10, 0);</a>
<a name="ln2329">				mhi = multadd(mhi, 10, 0);</a>
<a name="ln2330">			}</a>
<a name="ln2331">		}</a>
<a name="ln2332">	} else</a>
<a name="ln2333">		for (i = 1;; i++) {</a>
<a name="ln2334">			*s++ = dig = quorem(b,S) + '0';</a>
<a name="ln2335">			if (i &gt;= ilim)</a>
<a name="ln2336">				break;</a>
<a name="ln2337">			b = multadd(b, 10, 0);</a>
<a name="ln2338">		}</a>
<a name="ln2339"> </a>
<a name="ln2340">	/* Round off last digit */</a>
<a name="ln2341"> </a>
<a name="ln2342">	b = lshift(b, 1);</a>
<a name="ln2343">	j = cmp(b, S);</a>
<a name="ln2344">	if (j &gt; 0 || (j == 0 &amp;&amp; dig &amp; 1)) {</a>
<a name="ln2345"> roundoff:</a>
<a name="ln2346">		while (*--s == '9')</a>
<a name="ln2347">			if (s == s0) {</a>
<a name="ln2348">				k++;</a>
<a name="ln2349">				*s++ = '1';</a>
<a name="ln2350">				goto ret;</a>
<a name="ln2351">			}</a>
<a name="ln2352">		++*s++;</a>
<a name="ln2353">	} else {</a>
<a name="ln2354">		while (*--s == '0');</a>
<a name="ln2355">		s++;</a>
<a name="ln2356">	}</a>
<a name="ln2357"> ret:</a>
<a name="ln2358">	Bfree(S);</a>
<a name="ln2359">	if (mhi) {</a>
<a name="ln2360">		if (mlo &amp;&amp; mlo != mhi)</a>
<a name="ln2361">			Bfree(mlo);</a>
<a name="ln2362">		Bfree(mhi);</a>
<a name="ln2363">	}</a>
<a name="ln2364"> ret1:</a>
<a name="ln2365">	Bfree(b);</a>
<a name="ln2366">	if (s == s0) {	/* don't return empty string */</a>
<a name="ln2367">		*s++ = '0';</a>
<a name="ln2368">		k = 0;</a>
<a name="ln2369">	}</a>
<a name="ln2370">	*s = 0;</a>
<a name="ln2371">	*decpt = k + 1;</a>
<a name="ln2372">	if (rve)</a>
<a name="ln2373">		*rve = s;</a>
<a name="ln2374">	return s0;</a>
<a name="ln2375">}</a>
<a name="ln2376">#endif	// 0 -&gt; __dtoa() is removed from the build</a>
<a name="ln2377"> </a>
<a name="ln2378">#ifdef __cplusplus</a>
<a name="ln2379">}</a>
<a name="ln2380">#endif</a>

</code></pre>
<div class="balloon" rel="545"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v564/" target="_blank">V564</a> The '&' operator is applied to bool type value. You've probably forgotten to include parentheses or intended to use the '&&' operator.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
