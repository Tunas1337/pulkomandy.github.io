
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar9300_reset.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 2013 Qualcomm Atheros, Inc.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln5"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln6"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln7"> *</a>
<a name="ln8"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH</a>
<a name="ln9"> * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</a>
<a name="ln10"> * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,</a>
<a name="ln11"> * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM</a>
<a name="ln12"> * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR</a>
<a name="ln13"> * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</a>
<a name="ln14"> * PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln15"> */</a>
<a name="ln16"> </a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;opt_ah.h&quot;</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;ah.h&quot;</a>
<a name="ln22">#include &quot;ah_internal.h&quot;</a>
<a name="ln23">#include &quot;ah_devid.h&quot;</a>
<a name="ln24">#include &quot;ah_desc.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;ar9300.h&quot;</a>
<a name="ln27">#include &quot;ar9300reg.h&quot;</a>
<a name="ln28">#include &quot;ar9300phy.h&quot;</a>
<a name="ln29">#include &quot;ar9300desc.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#define FIX_NOISE_FLOOR     1</a>
<a name="ln32"> </a>
<a name="ln33"> </a>
<a name="ln34">/* Additional Time delay to wait after activiting the Base band */</a>
<a name="ln35">#define BASE_ACTIVATE_DELAY         100     /* usec */</a>
<a name="ln36">#define RTC_PLL_SETTLE_DELAY        100     /* usec */</a>
<a name="ln37">#define COEF_SCALE_S                24</a>
<a name="ln38">#define HT40_CHANNEL_CENTER_SHIFT   10      /* MHz      */</a>
<a name="ln39"> </a>
<a name="ln40">#define DELPT 32</a>
<a name="ln41"> </a>
<a name="ln42">/* XXX Duplicates! (in ar9300desc.h) */</a>
<a name="ln43">#if 0</a>
<a name="ln44">extern  HAL_BOOL ar9300_reset_tx_queue(struct ath_hal *ah, u_int q);</a>
<a name="ln45">extern  u_int32_t ar9300_num_tx_pending(struct ath_hal *ah, u_int q);</a>
<a name="ln46">#endif</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">#define MAX_MEASUREMENT 8</a>
<a name="ln50">#define MAXIQCAL 3</a>
<a name="ln51">struct coeff_t {</a>
<a name="ln52">    int32_t mag_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT][MAXIQCAL];</a>
<a name="ln53">    int32_t phs_coeff[AR9300_MAX_CHAINS][MAX_MEASUREMENT][MAXIQCAL];</a>
<a name="ln54">    int32_t iqc_coeff[2];</a>
<a name="ln55">    int last_nmeasurement;</a>
<a name="ln56">    HAL_BOOL last_cal;</a>
<a name="ln57">};</a>
<a name="ln58"> </a>
<a name="ln59">static HAL_BOOL ar9300_tx_iq_cal_hw_run(struct ath_hal *ah);</a>
<a name="ln60">static void ar9300_tx_iq_cal_post_proc(struct ath_hal *ah,HAL_CHANNEL_INTERNAL *ichan,</a>
<a name="ln61">       int iqcal_idx, int max_iqcal, HAL_BOOL is_cal_reusable, HAL_BOOL apply_last_corr);</a>
<a name="ln62">static void ar9300_tx_iq_cal_outlier_detection(struct ath_hal *ah,HAL_CHANNEL_INTERNAL *ichan,</a>
<a name="ln63">       u_int32_t num_chains, struct coeff_t *coeff, HAL_BOOL is_cal_reusable);</a>
<a name="ln64">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln65">static void ar9300_tx_iq_cal_apply(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *ichan);</a>
<a name="ln66">#endif</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">static inline void ar9300_prog_ini(struct ath_hal *ah, struct ar9300_ini_array *ini_arr, int column);</a>
<a name="ln70">static inline void ar9300_set_rf_mode(struct ath_hal *ah, struct ieee80211_channel *chan);</a>
<a name="ln71">static inline HAL_BOOL ar9300_init_cal(struct ath_hal *ah, struct ieee80211_channel *chan, HAL_BOOL skip_if_none, HAL_BOOL apply_last_corr);</a>
<a name="ln72">static inline void ar9300_init_user_settings(struct ath_hal *ah);</a>
<a name="ln73"> </a>
<a name="ln74">#ifdef HOST_OFFLOAD</a>
<a name="ln75">/* </a>
<a name="ln76"> * For usb offload solution, some USB registers must be tuned </a>
<a name="ln77"> * to gain better stability/performance but these registers</a>
<a name="ln78"> * might be changed while doing wlan reset so do this here </a>
<a name="ln79"> */</a>
<a name="ln80">#define WAR_USB_DISABLE_PLL_LOCK_DETECT(__ah) \</a>
<a name="ln81">do { \</a>
<a name="ln82">    if (AR_SREV_HORNET(__ah) || AR_SREV_WASP(__ah)) { \</a>
<a name="ln83">        volatile u_int32_t *usb_ctrl_r1 = (u_int32_t *) 0xb8116c84; \</a>
<a name="ln84">        volatile u_int32_t *usb_ctrl_r2 = (u_int32_t *) 0xb8116c88; \</a>
<a name="ln85">        *usb_ctrl_r1 = (*usb_ctrl_r1 &amp; 0xffefffff); \</a>
<a name="ln86">        *usb_ctrl_r2 = (*usb_ctrl_r2 &amp; 0xfc1fffff) | (1 &lt;&lt; 21) | (3 &lt;&lt; 22); \</a>
<a name="ln87">    } \</a>
<a name="ln88">} while (0)</a>
<a name="ln89">#else</a>
<a name="ln90">#define WAR_USB_DISABLE_PLL_LOCK_DETECT(__ah)</a>
<a name="ln91">#endif</a>
<a name="ln92"> </a>
<a name="ln93">/*</a>
<a name="ln94"> * Note: the below is the version that ships with ath9k.</a>
<a name="ln95"> * The original HAL version is above.</a>
<a name="ln96"> */</a>
<a name="ln97"> </a>
<a name="ln98">static void</a>
<a name="ln99">ar9300_disable_pll_lock_detect(struct ath_hal *ah)</a>
<a name="ln100">{</a>
<a name="ln101">	/*</a>
<a name="ln102">	 * On AR9330 and AR9340 devices, some PHY registers must be</a>
<a name="ln103">	 * tuned to gain better stability/performance. These registers</a>
<a name="ln104">	 * might be changed while doing wlan reset so the registers must</a>
<a name="ln105">	 * be reprogrammed after each reset.</a>
<a name="ln106">	 */</a>
<a name="ln107">	if (AR_SREV_HORNET(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln108">		HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln109">		OS_REG_CLR_BIT(ah, AR_PHY_USB_CTRL1, (1 &lt;&lt; 20));</a>
<a name="ln110">		OS_REG_RMW(ah, AR_PHY_USB_CTRL2,</a>
<a name="ln111">		    (1 &lt;&lt; 21) | (0xf &lt;&lt; 22),</a>
<a name="ln112">		    (1 &lt;&lt; 21) | (0x3 &lt;&lt; 22));</a>
<a name="ln113">	}</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116">static inline void</a>
<a name="ln117">ar9300_attach_hw_platform(struct ath_hal *ah)</a>
<a name="ln118">{</a>
<a name="ln119">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln120"> </a>
<a name="ln121">    ahp-&gt;ah_hwp = HAL_TRUE_CHIP;</a>
<a name="ln122">    return;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">/* Adjust various register settings based on half/quarter rate clock setting.</a>
<a name="ln126"> * This includes: +USEC, TX/RX latency, </a>
<a name="ln127"> *                + IFS params: slot, eifs, misc etc.</a>
<a name="ln128"> * SIFS stays the same.</a>
<a name="ln129"> */</a>
<a name="ln130">static void </a>
<a name="ln131">ar9300_set_ifs_timing(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln132">{</a>
<a name="ln133">    u_int32_t tx_lat, rx_lat, usec, slot, regval, eifs;</a>
<a name="ln134"> </a>
<a name="ln135">    regval = OS_REG_READ(ah, AR_USEC);</a>
<a name="ln136">    regval &amp;= ~(AR_USEC_RX_LATENCY | AR_USEC_TX_LATENCY | AR_USEC_USEC);</a>
<a name="ln137">    if (IEEE80211_IS_CHAN_HALF(chan)) { /* half rates */</a>
<a name="ln138">        slot = ar9300_mac_to_clks(ah, AR_SLOT_HALF);</a>
<a name="ln139">        eifs = ar9300_mac_to_clks(ah, AR_EIFS_HALF);</a>
<a name="ln140">        if (IS_5GHZ_FAST_CLOCK_EN(ah, chan)) { /* fast clock */</a>
<a name="ln141">            rx_lat = SM(AR_RX_LATENCY_HALF_FAST_CLOCK, AR_USEC_RX_LATENCY);</a>
<a name="ln142">            tx_lat = SM(AR_TX_LATENCY_HALF_FAST_CLOCK, AR_USEC_TX_LATENCY);</a>
<a name="ln143">            usec = SM(AR_USEC_HALF_FAST_CLOCK, AR_USEC_USEC);</a>
<a name="ln144">        } else {</a>
<a name="ln145">            rx_lat = SM(AR_RX_LATENCY_HALF, AR_USEC_RX_LATENCY);</a>
<a name="ln146">            tx_lat = SM(AR_TX_LATENCY_HALF, AR_USEC_TX_LATENCY);</a>
<a name="ln147">            usec = SM(AR_USEC_HALF, AR_USEC_USEC);</a>
<a name="ln148">        }</a>
<a name="ln149">    } else { /* quarter rate */</a>
<a name="ln150">        slot = ar9300_mac_to_clks(ah, AR_SLOT_QUARTER);</a>
<a name="ln151">        eifs = ar9300_mac_to_clks(ah, AR_EIFS_QUARTER);</a>
<a name="ln152">        if (IS_5GHZ_FAST_CLOCK_EN(ah, chan)) { /* fast clock */</a>
<a name="ln153">            rx_lat = SM(AR_RX_LATENCY_QUARTER_FAST_CLOCK, AR_USEC_RX_LATENCY);</a>
<a name="ln154">            tx_lat = SM(AR_TX_LATENCY_QUARTER_FAST_CLOCK, AR_USEC_TX_LATENCY);</a>
<a name="ln155">            usec = SM(AR_USEC_QUARTER_FAST_CLOCK, AR_USEC_USEC);</a>
<a name="ln156">        } else {</a>
<a name="ln157">            rx_lat = SM(AR_RX_LATENCY_QUARTER, AR_USEC_RX_LATENCY);</a>
<a name="ln158">            tx_lat = SM(AR_TX_LATENCY_QUARTER, AR_USEC_TX_LATENCY);</a>
<a name="ln159">            usec = SM(AR_USEC_QUARTER, AR_USEC_USEC);</a>
<a name="ln160">        }</a>
<a name="ln161">    }</a>
<a name="ln162"> </a>
<a name="ln163">    OS_REG_WRITE(ah, AR_USEC, (usec | regval | tx_lat | rx_lat));</a>
<a name="ln164">    OS_REG_WRITE(ah, AR_D_GBL_IFS_SLOT, slot);</a>
<a name="ln165">    OS_REG_WRITE(ah, AR_D_GBL_IFS_EIFS, eifs);</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168"> </a>
<a name="ln169">/*</a>
<a name="ln170"> * This inline function configures the chip either</a>
<a name="ln171"> * to encrypt/decrypt management frames or pass thru</a>
<a name="ln172"> */</a>
<a name="ln173">static inline void</a>
<a name="ln174">ar9300_init_mfp(struct ath_hal * ah)</a>
<a name="ln175">{</a>
<a name="ln176">    u_int32_t   mfpcap, mfp_qos;</a>
<a name="ln177"> </a>
<a name="ln178">    ath_hal_getcapability(ah, HAL_CAP_MFP, 0, &amp;mfpcap);</a>
<a name="ln179"> </a>
<a name="ln180">    if (mfpcap == HAL_MFP_QOSDATA) {</a>
<a name="ln181">        /* Treat like legacy hardware. Do not touch the MFP registers. */</a>
<a name="ln182">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s forced to use QOSDATA\n&quot;, __func__);</a>
<a name="ln183">        return;</a>
<a name="ln184">    }</a>
<a name="ln185"> </a>
<a name="ln186">    /* MFP support (Sowl 1.0 or greater) */</a>
<a name="ln187">    if (mfpcap == HAL_MFP_HW_CRYPTO) {</a>
<a name="ln188">        /* configure hardware MFP support */</a>
<a name="ln189">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s using HW crypto\n&quot;, __func__);</a>
<a name="ln190">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln191">            AR_AES_MUTE_MASK1, AR_AES_MUTE_MASK1_FC_MGMT, AR_AES_MUTE_MASK1_FC_MGMT_MFP);</a>
<a name="ln192">        OS_REG_RMW(ah,</a>
<a name="ln193">            AR_PCU_MISC_MODE2, AR_PCU_MISC_MODE2_MGMT_CRYPTO_ENABLE,</a>
<a name="ln194">            AR_PCU_MISC_MODE2_NO_CRYPTO_FOR_NON_DATA_PKT);</a>
<a name="ln195">        /*</a>
<a name="ln196">        * Mask used to construct AAD for CCMP-AES</a>
<a name="ln197">        * Cisco spec defined bits 0-3 as mask </a>
<a name="ln198">        * IEEE802.11w defined as bit 4.</a>
<a name="ln199">        */		</a>
<a name="ln200">        if (ath_hal_get_mfp_qos(ah)) {</a>
<a name="ln201">            mfp_qos = AR_MFP_QOS_MASK_IEEE;</a>
<a name="ln202">        } else {</a>
<a name="ln203">            mfp_qos = AR_MFP_QOS_MASK_CISCO;</a>
<a name="ln204">        }</a>
<a name="ln205">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln206">            AR_PCU_MISC_MODE2, AR_PCU_MISC_MODE2_MGMT_QOS, mfp_qos);</a>
<a name="ln207">    } else if (mfpcap == HAL_MFP_PASSTHRU) {</a>
<a name="ln208">        /* Disable en/decrypt by hardware */</a>
<a name="ln209">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s using passthru\n&quot;, __func__);</a>
<a name="ln210">        OS_REG_RMW(ah,</a>
<a name="ln211">            AR_PCU_MISC_MODE2,</a>
<a name="ln212">            AR_PCU_MISC_MODE2_NO_CRYPTO_FOR_NON_DATA_PKT,</a>
<a name="ln213">            AR_PCU_MISC_MODE2_MGMT_CRYPTO_ENABLE);</a>
<a name="ln214">    }</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">void</a>
<a name="ln218">ar9300_get_channel_centers(struct ath_hal *ah, const struct ieee80211_channel *chan,</a>
<a name="ln219">    CHAN_CENTERS *centers)</a>
<a name="ln220">{</a>
<a name="ln221">    int8_t      extoff;</a>
<a name="ln222">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln223">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln224"> </a>
<a name="ln225">    if (!IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln226">        centers-&gt;ctl_center = centers-&gt;ext_center =</a>
<a name="ln227">        centers-&gt;synth_center = ichan-&gt;channel;</a>
<a name="ln228">        return;</a>
<a name="ln229">    }</a>
<a name="ln230"> </a>
<a name="ln231">    HALASSERT(IEEE80211_IS_CHAN_HT40(chan));</a>
<a name="ln232"> </a>
<a name="ln233">    /*</a>
<a name="ln234">     * In 20/40 phy mode, the center frequency is</a>
<a name="ln235">     * &quot;between&quot; the primary and extension channels.</a>
<a name="ln236">     */</a>
<a name="ln237">    if (IEEE80211_IS_CHAN_HT40U(chan)) {</a>
<a name="ln238">        centers-&gt;synth_center = ichan-&gt;channel + HT40_CHANNEL_CENTER_SHIFT;</a>
<a name="ln239">        extoff = 1;</a>
<a name="ln240">    } else {</a>
<a name="ln241">        centers-&gt;synth_center = ichan-&gt;channel - HT40_CHANNEL_CENTER_SHIFT;</a>
<a name="ln242">        extoff = -1;</a>
<a name="ln243">    }</a>
<a name="ln244"> </a>
<a name="ln245">    centers-&gt;ctl_center =</a>
<a name="ln246">        centers-&gt;synth_center - (extoff * HT40_CHANNEL_CENTER_SHIFT);</a>
<a name="ln247">    centers-&gt;ext_center =</a>
<a name="ln248">        centers-&gt;synth_center +</a>
<a name="ln249">        (extoff * ((ahp-&gt;ah_ext_prot_spacing == HAL_HT_EXTPROTSPACING_20) ?</a>
<a name="ln250">            HT40_CHANNEL_CENTER_SHIFT : 15));</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">/*</a>
<a name="ln254"> * Read the noise-floor values from the HW.</a>
<a name="ln255"> * Specifically, read the minimum clear-channel assessment value for</a>
<a name="ln256"> * each chain, for both the control and extension channels.</a>
<a name="ln257"> * (The received power level during clear-channel periods is the</a>
<a name="ln258"> * noise floor.)</a>
<a name="ln259"> * These noise floor values computed by the HW will be stored in the</a>
<a name="ln260"> * NF history buffer.</a>
<a name="ln261"> * The HW sometimes produces bogus NF values.  To avoid using these</a>
<a name="ln262"> * bogus values, the NF data is (a) range-limited, and (b) filtered.</a>
<a name="ln263"> * However, this data-processing is done when reading the NF values</a>
<a name="ln264"> * out of the history buffer.  The history buffer stores the raw values.</a>
<a name="ln265"> * This allows the NF history buffer to be used to check for interference.</a>
<a name="ln266"> * A single high NF reading might be a bogus HW value, but if the NF</a>
<a name="ln267"> * readings are consistently high, it must be due to interference.</a>
<a name="ln268"> * This is the purpose of storing raw NF values in the history buffer,</a>
<a name="ln269"> * rather than processed values.  By looking at a history of NF values</a>
<a name="ln270"> * that have not been range-limited, we can check if they are consistently</a>
<a name="ln271"> * high (due to interference).</a>
<a name="ln272"> */</a>
<a name="ln273">#define AH_NF_SIGN_EXTEND(nf)      \</a>
<a name="ln274">    ((nf) &amp; 0x100) ?               \</a>
<a name="ln275">        0 - (((nf) ^ 0x1ff) + 1) : \</a>
<a name="ln276">        (nf)</a>
<a name="ln277">void</a>
<a name="ln278">ar9300_upload_noise_floor(struct ath_hal *ah, int is_2g,</a>
<a name="ln279">    int16_t nfarray[HAL_NUM_NF_READINGS])</a>
<a name="ln280">{</a>
<a name="ln281">    int16_t nf;</a>
<a name="ln282">    int chan, chain;</a>
<a name="ln283">    u_int32_t regs[HAL_NUM_NF_READINGS] = {</a>
<a name="ln284">        /* control channel */</a>
<a name="ln285">        AR_PHY_CCA_0,     /* chain 0 */</a>
<a name="ln286">        AR_PHY_CCA_1,     /* chain 1 */</a>
<a name="ln287">        AR_PHY_CCA_2,     /* chain 2 */</a>
<a name="ln288">        /* extension channel */</a>
<a name="ln289">        AR_PHY_EXT_CCA,   /* chain 0 */</a>
<a name="ln290">        AR_PHY_EXT_CCA_1, /* chain 1 */</a>
<a name="ln291">        AR_PHY_EXT_CCA_2, /* chain 2 */</a>
<a name="ln292">    };</a>
<a name="ln293">    u_int8_t chainmask;</a>
<a name="ln294"> </a>
<a name="ln295">    /*</a>
<a name="ln296">     * Within a given channel (ctl vs. ext), the CH0, CH1, and CH2</a>
<a name="ln297">     * masks and shifts are the same, though they differ for the</a>
<a name="ln298">     * control vs. extension channels.</a>
<a name="ln299">     */</a>
<a name="ln300">    u_int32_t masks[2] = {</a>
<a name="ln301">        AR_PHY_MINCCA_PWR,     /* control channel */</a>
<a name="ln302">        AR_PHY_EXT_MINCCA_PWR, /* extention channel */</a>
<a name="ln303">    };</a>
<a name="ln304">    u_int8_t shifts[2] = {</a>
<a name="ln305">        AR_PHY_MINCCA_PWR_S,     /* control channel */</a>
<a name="ln306">        AR_PHY_EXT_MINCCA_PWR_S, /* extention channel */</a>
<a name="ln307">    };</a>
<a name="ln308"> </a>
<a name="ln309">    /*</a>
<a name="ln310">     * Force NF calibration for all chains.</a>
<a name="ln311">     */</a>
<a name="ln312">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln313">        chainmask = 0x01;</a>
<a name="ln314">    } else if (AR_SREV_WASP(ah) || AR_SREV_JUPITER(ah) || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln315">        chainmask = 0x03;</a>
<a name="ln316">    } else {</a>
<a name="ln317">        chainmask = 0x07;</a>
<a name="ln318">    }</a>
<a name="ln319"> </a>
<a name="ln320">    for (chan = 0; chan &lt; 2 /*ctl,ext*/; chan++) {</a>
<a name="ln321">        for (chain = 0; chain &lt; AR9300_MAX_CHAINS; chain++) {</a>
<a name="ln322">            int i;</a>
<a name="ln323">            </a>
<a name="ln324">            if (!((chainmask &gt;&gt; chain) &amp; 0x1)) {</a>
<a name="ln325">                continue;</a>
<a name="ln326">            }</a>
<a name="ln327">            i = chan * AR9300_MAX_CHAINS + chain;</a>
<a name="ln328">            nf = (OS_REG_READ(ah, regs[i]) &amp; masks[chan]) &gt;&gt; shifts[chan];</a>
<a name="ln329">            nfarray[i] = AH_NF_SIGN_EXTEND(nf);</a>
<a name="ln330">        }</a>
<a name="ln331">    }</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">/* ar9300_get_min_cca_pwr -</a>
<a name="ln335"> * Used by the scan function for a quick read of the noise floor.</a>
<a name="ln336"> * This is used to detect presence of CW interference such as video bridge.</a>
<a name="ln337"> * The noise floor is assumed to have been already started during reset</a>
<a name="ln338"> * called during channel change. The function checks if the noise floor</a>
<a name="ln339"> * reading is done. In case it has been done, it reads the noise floor value.</a>
<a name="ln340"> * If the noise floor calibration has not been finished, it assumes this is</a>
<a name="ln341"> * due to presence of CW interference an returns a high value for noise floor,</a>
<a name="ln342"> * derived from the CW interference threshold + margin fudge factor. </a>
<a name="ln343"> */</a>
<a name="ln344">#define BAD_SCAN_NF_MARGIN (30)</a>
<a name="ln345">int16_t ar9300_get_min_cca_pwr(struct ath_hal *ah)</a>
<a name="ln346">{</a>
<a name="ln347">    int16_t nf;</a>
<a name="ln348">//    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln349"> </a>
<a name="ln350"> </a>
<a name="ln351">    if ((OS_REG_READ(ah, AR_PHY_AGC_CONTROL) &amp; AR_PHY_AGC_CONTROL_NF) == 0) {</a>
<a name="ln352">        nf = MS(OS_REG_READ(ah, AR_PHY_CCA_0), AR9280_PHY_MINCCA_PWR);</a>
<a name="ln353">        if (nf &amp; 0x100) {</a>
<a name="ln354">            nf = 0 - ((nf ^ 0x1ff) + 1);</a>
<a name="ln355">        }</a>
<a name="ln356">    } else {</a>
<a name="ln357">        /* NF calibration is not done, assume CW interference */</a>
<a name="ln358">        nf = AH9300(ah)-&gt;nfp-&gt;nominal + AH9300(ah)-&gt;nf_cw_int_delta +</a>
<a name="ln359">            BAD_SCAN_NF_MARGIN;</a>
<a name="ln360">    }</a>
<a name="ln361">    return nf;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">/* </a>
<a name="ln366"> * Noise Floor values for all chains. </a>
<a name="ln367"> * Most recently updated values from the NF history buffer are used.</a>
<a name="ln368"> */</a>
<a name="ln369">void ar9300_chain_noise_floor(struct ath_hal *ah, int16_t *nf_buf,</a>
<a name="ln370">    struct ieee80211_channel *chan, int is_scan)</a>
<a name="ln371">{</a>
<a name="ln372">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln373">    int i, nf_hist_len, recent_nf_index = 0;</a>
<a name="ln374">    HAL_NFCAL_HIST_FULL *h;</a>
<a name="ln375">    u_int8_t rx_chainmask = ahp-&gt;ah_rx_chainmask | (ahp-&gt;ah_rx_chainmask &lt;&lt; 3);</a>
<a name="ln376">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan); </a>
<a name="ln377">    HALASSERT(ichan);</a>
<a name="ln378"> </a>
<a name="ln379">#ifdef ATH_NF_PER_CHAN</a>
<a name="ln380">    /* Fill 0 if valid internal channel is not found */</a>
<a name="ln381">    if (ichan == AH_NULL) {</a>
<a name="ln382">        OS_MEMZERO(nf_buf, sizeof(nf_buf[0])*HAL_NUM_NF_READINGS);</a>
<a name="ln383">        return;</a>
<a name="ln384">    }</a>
<a name="ln385">    h = &amp;ichan-&gt;nf_cal_hist;</a>
<a name="ln386">    nf_hist_len = HAL_NF_CAL_HIST_LEN_FULL;</a>
<a name="ln387">#else</a>
<a name="ln388">    /*</a>
<a name="ln389">     * If a scan is not in progress, then the most recent value goes</a>
<a name="ln390">     * into ahpriv-&gt;nf_cal_hist.  If a scan is in progress, then</a>
<a name="ln391">     * the most recent value goes into ichan-&gt;nf_cal_hist.</a>
<a name="ln392">     * Thus, return the value from ahpriv-&gt;nf_cal_hist if there's</a>
<a name="ln393">     * no scan, and if the specified channel is the current channel.</a>
<a name="ln394">     * Otherwise, return the noise floor from ichan-&gt;nf_cal_hist.</a>
<a name="ln395">     */</a>
<a name="ln396">    if ((!is_scan) &amp;&amp; chan == AH_PRIVATE(ah)-&gt;ah_curchan) {</a>
<a name="ln397">        h = &amp;AH_PRIVATE(ah)-&gt;nf_cal_hist;</a>
<a name="ln398">        nf_hist_len = HAL_NF_CAL_HIST_LEN_FULL;</a>
<a name="ln399">    } else {</a>
<a name="ln400">        /* Fill 0 if valid internal channel is not found */</a>
<a name="ln401">        if (ichan == AH_NULL) {</a>
<a name="ln402">            OS_MEMZERO(nf_buf, sizeof(nf_buf[0])*HAL_NUM_NF_READINGS);</a>
<a name="ln403">            return;</a>
<a name="ln404">        }</a>
<a name="ln405">       /*</a>
<a name="ln406">        * It is okay to treat a HAL_NFCAL_HIST_SMALL struct as if it were a</a>
<a name="ln407">        * HAL_NFCAL_HIST_FULL struct, as long as only the index 0 of the</a>
<a name="ln408">        * nf_cal_buffer is used (nf_cal_buffer[0][0:HAL_NUM_NF_READINGS-1])</a>
<a name="ln409">        */</a>
<a name="ln410">        h = (HAL_NFCAL_HIST_FULL *) &amp;ichan-&gt;nf_cal_hist;</a>
<a name="ln411">        nf_hist_len = HAL_NF_CAL_HIST_LEN_SMALL;</a>
<a name="ln412">    }</a>
<a name="ln413">#endif</a>
<a name="ln414">    /* Get most recently updated values from nf cal history buffer */</a>
<a name="ln415">    recent_nf_index =</a>
<a name="ln416">        (h-&gt;base.curr_index) ? h-&gt;base.curr_index - 1 : nf_hist_len - 1;</a>
<a name="ln417"> </a>
<a name="ln418">    for (i = 0; i &lt; HAL_NUM_NF_READINGS; i++) {</a>
<a name="ln419">        /* Fill 0 for unsupported chains */</a>
<a name="ln420">        if (!(rx_chainmask &amp; (1 &lt;&lt; i))) {</a>
<a name="ln421">            nf_buf[i] = 0;</a>
<a name="ln422">            continue;</a>
<a name="ln423">        }</a>
<a name="ln424">        nf_buf[i] = h-&gt;nf_cal_buffer[recent_nf_index][i];</a>
<a name="ln425">    }</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">/*</a>
<a name="ln429"> * Return the current NF value in register.</a>
<a name="ln430"> * If the current NF cal is not completed, return 0.</a>
<a name="ln431"> */</a>
<a name="ln432">int16_t ar9300_get_nf_from_reg(struct ath_hal *ah, struct ieee80211_channel *chan, int wait_time)</a>
<a name="ln433">{</a>
<a name="ln434">    int16_t nfarray[HAL_NUM_NF_READINGS] = {0};</a>
<a name="ln435">    int is_2g = 0;</a>
<a name="ln436">    HAL_CHANNEL_INTERNAL *ichan = NULL;</a>
<a name="ln437"> </a>
<a name="ln438">    ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln439">    if (ichan == NULL)</a>
<a name="ln440">        return (0);</a>
<a name="ln441"> </a>
<a name="ln442">    if (wait_time &lt;= 0) {</a>
<a name="ln443">        return 0;</a>
<a name="ln444">    }</a>
<a name="ln445"> </a>
<a name="ln446">    if (!ath_hal_waitfor(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF, 0, wait_time)) {</a>
<a name="ln447">        ath_hal_printf(ah, &quot;%s: NF cal is not complete in %dus&quot;, __func__, wait_time);</a>
<a name="ln448">        return 0;</a>
<a name="ln449">    }</a>
<a name="ln450">    is_2g = !! (IS_CHAN_2GHZ(ichan));</a>
<a name="ln451">    ar9300_upload_noise_floor(ah, is_2g, nfarray);</a>
<a name="ln452"> </a>
<a name="ln453">    return nfarray[0];</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">/*</a>
<a name="ln457"> * Pick up the medium one in the noise floor buffer and update the</a>
<a name="ln458"> * corresponding range for valid noise floor values</a>
<a name="ln459"> */</a>
<a name="ln460">static int16_t</a>
<a name="ln461">ar9300_get_nf_hist_mid(struct ath_hal *ah, HAL_NFCAL_HIST_FULL *h, int reading,</a>
<a name="ln462">    int hist_len)</a>
<a name="ln463">{</a>
<a name="ln464">    int16_t nfval;</a>
<a name="ln465">    int16_t sort[HAL_NF_CAL_HIST_LEN_FULL]; /* upper bound for hist_len */</a>
<a name="ln466">    int i, j;</a>
<a name="ln467"> </a>
<a name="ln468"> </a>
<a name="ln469">    for (i = 0; i &lt; hist_len; i++) {</a>
<a name="ln470">        sort[i] = h-&gt;nf_cal_buffer[i][reading];</a>
<a name="ln471">        HALDEBUG(ah, HAL_DEBUG_NFCAL,</a>
<a name="ln472">            &quot;nf_cal_buffer[%d][%d] = %d\n&quot;, i, reading, (int)sort[i]);</a>
<a name="ln473">    }</a>
<a name="ln474">    for (i = 0; i &lt; hist_len - 1; i++) {</a>
<a name="ln475">        for (j = 1; j &lt; hist_len - i; j++) {</a>
<a name="ln476">            if (sort[j] &gt; sort[j - 1]) {</a>
<a name="ln477">                nfval = sort[j];</a>
<a name="ln478">                sort[j] = sort[j - 1];</a>
<a name="ln479">                sort[j - 1] = nfval;</a>
<a name="ln480">            }</a>
<a name="ln481">        }</a>
<a name="ln482">    }</a>
<a name="ln483">    nfval = sort[(hist_len - 1) &gt;&gt; 1];</a>
<a name="ln484"> </a>
<a name="ln485">    return nfval;</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">static int16_t ar9300_limit_nf_range(struct ath_hal *ah, int16_t nf)</a>
<a name="ln489">{</a>
<a name="ln490">    if (nf &lt; AH9300(ah)-&gt;nfp-&gt;min) {</a>
<a name="ln491">        return AH9300(ah)-&gt;nfp-&gt;nominal;</a>
<a name="ln492">    } else if (nf &gt; AH9300(ah)-&gt;nfp-&gt;max) {</a>
<a name="ln493">        return AH9300(ah)-&gt;nfp-&gt;max;</a>
<a name="ln494">    }</a>
<a name="ln495">    return nf;</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">#ifndef ATH_NF_PER_CHAN</a>
<a name="ln499">inline static void</a>
<a name="ln500">ar9300_reset_nf_hist_buff(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *ichan)</a>
<a name="ln501">{</a>
<a name="ln502">    HAL_CHAN_NFCAL_HIST *h = &amp;ichan-&gt;nf_cal_hist;</a>
<a name="ln503">    HAL_NFCAL_HIST_FULL *home = &amp;AH_PRIVATE(ah)-&gt;nf_cal_hist;</a>
<a name="ln504">    int i;</a>
<a name="ln505">    </a>
<a name="ln506">    /* </a>
<a name="ln507">     * Copy the value for the channel in question into the home-channel</a>
<a name="ln508">     * NF history buffer.  The channel NF is probably a value filled in by</a>
<a name="ln509">     * a prior background channel scan, but if no scan has been done then</a>
<a name="ln510">     * it is the nominal noise floor filled in by ath_hal_init_NF_buffer</a>
<a name="ln511">     * for this chip and the channel's band.</a>
<a name="ln512">     * Replicate this channel NF into all entries of the home-channel NF</a>
<a name="ln513">     * history buffer.</a>
<a name="ln514">     * If the channel NF was filled in by a channel scan, it has not had</a>
<a name="ln515">     * bounds limits applied to it yet - do so now.  It is important to</a>
<a name="ln516">     * apply bounds limits to the priv_nf value that gets loaded into the</a>
<a name="ln517">     * WLAN chip's min_cca_pwr register field.  It is also necessary to</a>
<a name="ln518">     * apply bounds limits to the nf_cal_buffer[] elements.  Since we are</a>
<a name="ln519">     * replicating a single NF reading into all nf_cal_buffer elements,</a>
<a name="ln520">     * if the single reading were above the CW_INT threshold, the CW_INT</a>
<a name="ln521">     * check in ar9300_get_nf would immediately conclude that CW interference</a>
<a name="ln522">     * is present, even though we're not supposed to set CW_INT unless</a>
<a name="ln523">     * NF values are _consistently_ above the CW_INT threshold.</a>
<a name="ln524">     * Applying the bounds limits to the nf_cal_buffer contents fixes this</a>
<a name="ln525">     * problem.</a>
<a name="ln526">     */</a>
<a name="ln527">    for (i = 0; i &lt; HAL_NUM_NF_READINGS; i ++) {</a>
<a name="ln528">        int j;</a>
<a name="ln529">        int16_t nf;</a>
<a name="ln530">        /*</a>
<a name="ln531">         * No need to set curr_index, since it already has a value in</a>
<a name="ln532">         * the range [0..HAL_NF_CAL_HIST_LEN_FULL), and all nf_cal_buffer</a>
<a name="ln533">         * values will be the same.</a>
<a name="ln534">         */</a>
<a name="ln535">        nf = ar9300_limit_nf_range(ah, h-&gt;nf_cal_buffer[0][i]);</a>
<a name="ln536">        for (j = 0; j &lt; HAL_NF_CAL_HIST_LEN_FULL; j++) {</a>
<a name="ln537">            home-&gt;nf_cal_buffer[j][i] = nf;</a>
<a name="ln538">        }</a>
<a name="ln539">        AH_PRIVATE(ah)-&gt;nf_cal_hist.base.priv_nf[i] = nf;</a>
<a name="ln540">    }</a>
<a name="ln541">}</a>
<a name="ln542">#endif</a>
<a name="ln543"> </a>
<a name="ln544">/*</a>
<a name="ln545"> *  Update the noise floor buffer as a ring buffer</a>
<a name="ln546"> */</a>
<a name="ln547">static int16_t</a>
<a name="ln548">ar9300_update_nf_hist_buff(struct ath_hal *ah, HAL_NFCAL_HIST_FULL *h,</a>
<a name="ln549">   int16_t *nfarray, int hist_len)</a>
<a name="ln550">{</a>
<a name="ln551">    int i, nr;</a>
<a name="ln552">    int16_t nf_no_lim_chain0;</a>
<a name="ln553"> </a>
<a name="ln554">    nf_no_lim_chain0 = ar9300_get_nf_hist_mid(ah, h, 0, hist_len);</a>
<a name="ln555"> </a>
<a name="ln556">    HALDEBUG(ah, HAL_DEBUG_NFCAL, &quot;%s[%d] BEFORE\n&quot;, __func__, __LINE__);</a>
<a name="ln557">    for (nr = 0; nr &lt; HAL_NF_CAL_HIST_LEN_FULL; nr++) {</a>
<a name="ln558">        for (i = 0; i &lt; HAL_NUM_NF_READINGS; i++) {</a>
<a name="ln559">            HALDEBUG(ah, HAL_DEBUG_NFCAL,</a>
<a name="ln560">                &quot;nf_cal_buffer[%d][%d] = %d\n&quot;,</a>
<a name="ln561">                nr, i, (int)h-&gt;nf_cal_buffer[nr][i]);</a>
<a name="ln562">        }</a>
<a name="ln563">    }</a>
<a name="ln564">    for (i = 0; i &lt; HAL_NUM_NF_READINGS; i++) {</a>
<a name="ln565">        h-&gt;nf_cal_buffer[h-&gt;base.curr_index][i] = nfarray[i];</a>
<a name="ln566">        h-&gt;base.priv_nf[i] = ar9300_limit_nf_range(</a>
<a name="ln567">            ah, ar9300_get_nf_hist_mid(ah, h, i, hist_len));</a>
<a name="ln568">    }</a>
<a name="ln569">    HALDEBUG(ah, HAL_DEBUG_NFCAL, &quot;%s[%d] AFTER\n&quot;, __func__, __LINE__);</a>
<a name="ln570">    for (nr = 0; nr &lt; HAL_NF_CAL_HIST_LEN_FULL; nr++) {</a>
<a name="ln571">        for (i = 0; i &lt; HAL_NUM_NF_READINGS; i++) {</a>
<a name="ln572">            HALDEBUG(ah, HAL_DEBUG_NFCAL,</a>
<a name="ln573">                &quot;nf_cal_buffer[%d][%d] = %d\n&quot;,</a>
<a name="ln574">                nr, i, (int)h-&gt;nf_cal_buffer[nr][i]);</a>
<a name="ln575">        }</a>
<a name="ln576">    }</a>
<a name="ln577"> </a>
<a name="ln578">    if (++h-&gt;base.curr_index &gt;= hist_len) {</a>
<a name="ln579">        h-&gt;base.curr_index = 0;</a>
<a name="ln580">    }</a>
<a name="ln581"> </a>
<a name="ln582">    return nf_no_lim_chain0;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">#ifdef UNUSED</a>
<a name="ln586">static HAL_BOOL</a>
<a name="ln587">get_noise_floor_thresh(struct ath_hal *ah, const HAL_CHANNEL_INTERNAL *chan,</a>
<a name="ln588">    int16_t *nft)</a>
<a name="ln589">{</a>
<a name="ln590">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln591"> </a>
<a name="ln592"> </a>
<a name="ln593">    switch (chan-&gt;channel_flags &amp; CHANNEL_ALL_NOTURBO) {</a>
<a name="ln594">    case CHANNEL_A:</a>
<a name="ln595">    case CHANNEL_A_HT20:</a>
<a name="ln596">    case CHANNEL_A_HT40PLUS:</a>
<a name="ln597">    case CHANNEL_A_HT40MINUS:</a>
<a name="ln598">        *nft = (int8_t)ar9300_eeprom_get(ahp, EEP_NFTHRESH_5);</a>
<a name="ln599">        break;</a>
<a name="ln600">    case CHANNEL_B:</a>
<a name="ln601">    case CHANNEL_G:</a>
<a name="ln602">    case CHANNEL_G_HT20:</a>
<a name="ln603">    case CHANNEL_G_HT40PLUS:</a>
<a name="ln604">    case CHANNEL_G_HT40MINUS:</a>
<a name="ln605">        *nft = (int8_t)ar9300_eeprom_get(ahp, EEP_NFTHRESH_2);</a>
<a name="ln606">        break;</a>
<a name="ln607">    default:</a>
<a name="ln608">        HALDEBUG(ah, HAL_DEBUG_CHANNEL, &quot;%s: invalid channel flags 0x%x\n&quot;,</a>
<a name="ln609">                __func__, chan-&gt;channel_flags);</a>
<a name="ln610">        return AH_FALSE;</a>
<a name="ln611">    }</a>
<a name="ln612">    return AH_TRUE;</a>
<a name="ln613">}</a>
<a name="ln614">#endif</a>
<a name="ln615"> </a>
<a name="ln616">/*</a>
<a name="ln617"> * Read the NF and check it against the noise floor threshhold</a>
<a name="ln618"> */</a>
<a name="ln619">#define IS(_c, _f)       (((_c)-&gt;channel_flags &amp; _f) || 0)</a>
<a name="ln620">static int</a>
<a name="ln621">ar9300_store_new_nf(struct ath_hal *ah, struct ieee80211_channel *chan,</a>
<a name="ln622">  int is_scan)</a>
<a name="ln623">{</a>
<a name="ln624">//    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln625">    int nf_hist_len;</a>
<a name="ln626">    int16_t nf_no_lim;</a>
<a name="ln627">    int16_t nfarray[HAL_NUM_NF_READINGS] = {0};</a>
<a name="ln628">    HAL_NFCAL_HIST_FULL *h;</a>
<a name="ln629">    int is_2g = 0;</a>
<a name="ln630">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln631">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln632"> </a>
<a name="ln633">    if (OS_REG_READ(ah, AR_PHY_AGC_CONTROL) &amp; AR_PHY_AGC_CONTROL_NF) {</a>
<a name="ln634">        u_int32_t tsf32, nf_cal_dur_tsf;</a>
<a name="ln635">        /*</a>
<a name="ln636">         * The reason the NF calibration did not complete may just be that</a>
<a name="ln637">         * not enough time has passed since the NF calibration was started,</a>
<a name="ln638">         * because under certain conditions (when first moving to a new</a>
<a name="ln639">         * channel) the NF calibration may be checked very repeatedly.</a>
<a name="ln640">         * Or, there may be CW interference keeping the NF calibration</a>
<a name="ln641">         * from completing.  Check the delta time between when the NF</a>
<a name="ln642">         * calibration was started and now to see whether the NF calibration</a>
<a name="ln643">         * should have already completed (but hasn't, probably due to CW</a>
<a name="ln644">         * interference), or hasn't had enough time to finish yet.</a>
<a name="ln645">         */</a>
<a name="ln646">        /*</a>
<a name="ln647">         * AH_NF_CAL_DUR_MAX_TSF - A conservative maximum time that the</a>
<a name="ln648">         *     HW should need to finish a NF calibration.  If the HW</a>
<a name="ln649">         *     does not complete a NF calibration within this time period,</a>
<a name="ln650">         *     there must be a problem - probably CW interference.</a>
<a name="ln651">         * AH_NF_CAL_PERIOD_MAX_TSF - A conservative maximum time between</a>
<a name="ln652">         *     check of the HW's NF calibration being finished.</a>
<a name="ln653">         *     If the difference between the current TSF and the TSF</a>
<a name="ln654">         *     recorded when the NF calibration started is larger than this</a>
<a name="ln655">         *     value, the TSF must have been reset.</a>
<a name="ln656">         *     In general, we expect the TSF to only be reset during</a>
<a name="ln657">         *     regular operation for STAs, not for APs.  However, an</a>
<a name="ln658">         *     AP's TSF could be reset when joining an IBSS.</a>
<a name="ln659">         *     There's an outside chance that this could result in the</a>
<a name="ln660">         *     CW_INT flag being erroneously set, if the TSF adjustment</a>
<a name="ln661">         *     is smaller than AH_NF_CAL_PERIOD_MAX_TSF but larger than</a>
<a name="ln662">         *     AH_NF_CAL_DUR_TSF.  However, even if this does happen,</a>
<a name="ln663">         *     it shouldn't matter, as the IBSS case shouldn't be</a>
<a name="ln664">         *     concerned about CW_INT.</a>
<a name="ln665">         */</a>
<a name="ln666">        /* AH_NF_CAL_DUR_TSF - 90 sec in usec units */</a>
<a name="ln667">        #define AH_NF_CAL_DUR_TSF (90 * 1000 * 1000)</a>
<a name="ln668">        /* AH_NF_CAL_PERIOD_MAX_TSF - 180 sec in usec units */</a>
<a name="ln669">        #define AH_NF_CAL_PERIOD_MAX_TSF (180 * 1000 * 1000)</a>
<a name="ln670">        /* wraparound handled by using unsigned values */</a>
<a name="ln671">        tsf32 = ar9300_get_tsf32(ah);</a>
<a name="ln672">        nf_cal_dur_tsf = tsf32 - AH9300(ah)-&gt;nf_tsf32;</a>
<a name="ln673">        if (nf_cal_dur_tsf &gt; AH_NF_CAL_PERIOD_MAX_TSF) {</a>
<a name="ln674">            /*</a>
<a name="ln675">             * The TSF must have gotten reset during the NF cal -</a>
<a name="ln676">             * just reset the NF TSF timestamp, so the next time</a>
<a name="ln677">             * this function is called, the timestamp comparison</a>
<a name="ln678">             * will be valid.</a>
<a name="ln679">             */</a>
<a name="ln680">            AH9300(ah)-&gt;nf_tsf32 = tsf32;</a>
<a name="ln681">        } else if (nf_cal_dur_tsf &gt; AH_NF_CAL_DUR_TSF) {</a>
<a name="ln682">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln683">                &quot;%s: NF did not complete in calibration window\n&quot;, __func__);</a>
<a name="ln684">            /* the NF incompletion is probably due to CW interference */</a>
<a name="ln685">            chan-&gt;ic_state |= IEEE80211_CHANSTATE_CWINT;</a>
<a name="ln686">        }</a>
<a name="ln687">        return 0; /* HW's NF measurement not finished */</a>
<a name="ln688">    }</a>
<a name="ln689">    HALDEBUG(ah, HAL_DEBUG_NFCAL,</a>
<a name="ln690">        &quot;%s[%d] chan %d\n&quot;, __func__, __LINE__, ichan-&gt;channel);</a>
<a name="ln691">    is_2g = !! IS_CHAN_2GHZ(ichan);</a>
<a name="ln692">    ar9300_upload_noise_floor(ah, is_2g, nfarray);</a>
<a name="ln693"> </a>
<a name="ln694">    /* Update the NF buffer for each chain masked by chainmask */</a>
<a name="ln695">#ifdef ATH_NF_PER_CHAN</a>
<a name="ln696">    h = &amp;ichan-&gt;nf_cal_hist;</a>
<a name="ln697">    nf_hist_len = HAL_NF_CAL_HIST_LEN_FULL;</a>
<a name="ln698">#else</a>
<a name="ln699">    if (is_scan) {</a>
<a name="ln700">        /*</a>
<a name="ln701">         * This channel's NF cal info is just a HAL_NFCAL_HIST_SMALL struct</a>
<a name="ln702">         * rather than a HAL_NFCAL_HIST_FULL struct.</a>
<a name="ln703">         * As long as we only use the first history element of nf_cal_buffer</a>
<a name="ln704">         * (nf_cal_buffer[0][0:HAL_NUM_NF_READINGS-1]), we can use</a>
<a name="ln705">         * HAL_NFCAL_HIST_SMALL and HAL_NFCAL_HIST_FULL interchangeably.</a>
<a name="ln706">         */</a>
<a name="ln707">        h = (HAL_NFCAL_HIST_FULL *) &amp;ichan-&gt;nf_cal_hist;</a>
<a name="ln708">        nf_hist_len = HAL_NF_CAL_HIST_LEN_SMALL;</a>
<a name="ln709">    } else {</a>
<a name="ln710">        h = &amp;AH_PRIVATE(ah)-&gt;nf_cal_hist;</a>
<a name="ln711">        nf_hist_len = HAL_NF_CAL_HIST_LEN_FULL;</a>
<a name="ln712">    }</a>
<a name="ln713">#endif</a>
<a name="ln714"> </a>
<a name="ln715">    /*</a>
<a name="ln716">     * nf_no_lim = median value from NF history buffer without bounds limits,</a>
<a name="ln717">     * priv_nf = median value from NF history buffer with bounds limits.</a>
<a name="ln718">     */</a>
<a name="ln719">    nf_no_lim = ar9300_update_nf_hist_buff(ah, h, nfarray, nf_hist_len);</a>
<a name="ln720">    ichan-&gt;rawNoiseFloor = h-&gt;base.priv_nf[0];</a>
<a name="ln721"> </a>
<a name="ln722">    /* check if there is interference */</a>
<a name="ln723">//    ichan-&gt;channel_flags &amp;= (~CHANNEL_CW_INT);</a>
<a name="ln724">    /*</a>
<a name="ln725">     * Use AR9300_EMULATION to check for emulation purpose as PCIE Device ID</a>
<a name="ln726">     * 0xABCD is recognized as valid Osprey as WAR in some EVs.</a>
<a name="ln727">     */</a>
<a name="ln728">    if (nf_no_lim &gt; ahp-&gt;nfp-&gt;nominal + ahp-&gt;nf_cw_int_delta) {</a>
<a name="ln729">        /*</a>
<a name="ln730">         * Since this CW interference check is being applied to the</a>
<a name="ln731">         * median element of the NF history buffer, this indicates that</a>
<a name="ln732">         * the CW interference is persistent.  A single high NF reading</a>
<a name="ln733">         * will not show up in the median, and thus will not cause the</a>
<a name="ln734">         * CW_INT flag to be set.</a>
<a name="ln735">         */</a>
<a name="ln736">        HALDEBUG(ah, HAL_DEBUG_NFCAL,</a>
<a name="ln737">            &quot;%s: NF Cal: CW interferer detected through NF: %d\n&quot;,</a>
<a name="ln738">            __func__, nf_no_lim); </a>
<a name="ln739">        chan-&gt;ic_state |= IEEE80211_CHANSTATE_CWINT;</a>
<a name="ln740">    }</a>
<a name="ln741">    return 1; /* HW's NF measurement finished */</a>
<a name="ln742">}</a>
<a name="ln743">#undef IS</a>
<a name="ln744"> </a>
<a name="ln745">static inline void</a>
<a name="ln746">ar9300_get_delta_slope_values(struct ath_hal *ah, u_int32_t coef_scaled,</a>
<a name="ln747">    u_int32_t *coef_mantissa, u_int32_t *coef_exponent)</a>
<a name="ln748">{</a>
<a name="ln749">    u_int32_t coef_exp, coef_man;</a>
<a name="ln750"> </a>
<a name="ln751">    /*</a>
<a name="ln752">     * ALGO -&gt; coef_exp = 14-floor(log2(coef));</a>
<a name="ln753">     * floor(log2(x)) is the highest set bit position</a>
<a name="ln754">     */</a>
<a name="ln755">    for (coef_exp = 31; coef_exp &gt; 0; coef_exp--) {</a>
<a name="ln756">        if ((coef_scaled &gt;&gt; coef_exp) &amp; 0x1) {</a>
<a name="ln757">            break;</a>
<a name="ln758">        }</a>
<a name="ln759">    }</a>
<a name="ln760">    /* A coef_exp of 0 is a legal bit position but an unexpected coef_exp */</a>
<a name="ln761">    HALASSERT(coef_exp);</a>
<a name="ln762">    coef_exp = 14 - (coef_exp - COEF_SCALE_S);</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">    /*</a>
<a name="ln766">     * ALGO -&gt; coef_man = floor(coef* 2^coef_exp+0.5);</a>
<a name="ln767">     * The coefficient is already shifted up for scaling</a>
<a name="ln768">     */</a>
<a name="ln769">    coef_man = coef_scaled + (1 &lt;&lt; (COEF_SCALE_S - coef_exp - 1));</a>
<a name="ln770"> </a>
<a name="ln771">    *coef_mantissa = coef_man &gt;&gt; (COEF_SCALE_S - coef_exp);</a>
<a name="ln772">    *coef_exponent = coef_exp - 16;</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">#define MAX_ANALOG_START        319             /* XXX */</a>
<a name="ln776"> </a>
<a name="ln777">/*</a>
<a name="ln778"> * Delta slope coefficient computation.</a>
<a name="ln779"> * Required for OFDM operation.</a>
<a name="ln780"> */</a>
<a name="ln781">static void</a>
<a name="ln782">ar9300_set_delta_slope(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln783">{</a>
<a name="ln784">    u_int32_t coef_scaled, ds_coef_exp, ds_coef_man;</a>
<a name="ln785">    u_int32_t fclk = COEFF; /* clock * 2.5 */</a>
<a name="ln786"> </a>
<a name="ln787">    u_int32_t clock_mhz_scaled = 0x1000000 * fclk;</a>
<a name="ln788">    CHAN_CENTERS centers;</a>
<a name="ln789"> </a>
<a name="ln790">    /*</a>
<a name="ln791">     * half and quarter rate can divide the scaled clock by 2 or 4</a>
<a name="ln792">     * scale for selected channel bandwidth</a>
<a name="ln793">     */</a>
<a name="ln794">    if (IEEE80211_IS_CHAN_HALF(chan)) {</a>
<a name="ln795">        clock_mhz_scaled = clock_mhz_scaled &gt;&gt; 1;</a>
<a name="ln796">    } else if (IEEE80211_IS_CHAN_QUARTER(chan)) {</a>
<a name="ln797">        clock_mhz_scaled = clock_mhz_scaled &gt;&gt; 2;</a>
<a name="ln798">    }</a>
<a name="ln799"> </a>
<a name="ln800">    /*</a>
<a name="ln801">     * ALGO -&gt; coef = 1e8/fcarrier*fclock/40;</a>
<a name="ln802">     * scaled coef to provide precision for this floating calculation</a>
<a name="ln803">     */</a>
<a name="ln804">    ar9300_get_channel_centers(ah, chan, &amp;centers);</a>
<a name="ln805">    coef_scaled = clock_mhz_scaled / centers.synth_center;</a>
<a name="ln806"> </a>
<a name="ln807">    ar9300_get_delta_slope_values(ah, coef_scaled, &amp;ds_coef_man, &amp;ds_coef_exp);</a>
<a name="ln808"> </a>
<a name="ln809">    OS_REG_RMW_FIELD(ah, AR_PHY_TIMING3, AR_PHY_TIMING3_DSC_MAN, ds_coef_man);</a>
<a name="ln810">    OS_REG_RMW_FIELD(ah, AR_PHY_TIMING3, AR_PHY_TIMING3_DSC_EXP, ds_coef_exp);</a>
<a name="ln811"> </a>
<a name="ln812">    /*</a>
<a name="ln813">     * For Short GI,</a>
<a name="ln814">     * scaled coeff is 9/10 that of normal coeff</a>
<a name="ln815">     */</a>
<a name="ln816">    coef_scaled = (9 * coef_scaled) / 10;</a>
<a name="ln817"> </a>
<a name="ln818">    ar9300_get_delta_slope_values(ah, coef_scaled, &amp;ds_coef_man, &amp;ds_coef_exp);</a>
<a name="ln819"> </a>
<a name="ln820">    /* for short gi */</a>
<a name="ln821">    OS_REG_RMW_FIELD(ah, AR_PHY_SGI_DELTA, AR_PHY_SGI_DSC_MAN, ds_coef_man);</a>
<a name="ln822">    OS_REG_RMW_FIELD(ah, AR_PHY_SGI_DELTA, AR_PHY_SGI_DSC_EXP, ds_coef_exp);</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">#define IS(_c, _f)       (IEEE80211_IS_ ## _f(_c))</a>
<a name="ln826"> </a>
<a name="ln827">/*</a>
<a name="ln828"> * XXX FreeBSD: This should be turned into something generic in ath_hal!</a>
<a name="ln829"> */</a>
<a name="ln830">HAL_CHANNEL_INTERNAL *</a>
<a name="ln831">ar9300_check_chan(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln832">{</a>
<a name="ln833"> </a>
<a name="ln834">    if (chan == NULL) {</a>
<a name="ln835">        return AH_NULL;</a>
<a name="ln836">    }</a>
<a name="ln837"> </a>
<a name="ln838">    if ((IS(chan, CHAN_2GHZ) ^ IS(chan, CHAN_5GHZ)) == 0) {</a>
<a name="ln839">        HALDEBUG(ah, HAL_DEBUG_CHANNEL,</a>
<a name="ln840">            &quot;%s: invalid channel %u/0x%x; not marked as 2GHz or 5GHz\n&quot;,</a>
<a name="ln841">            __func__, chan-&gt;ic_freq , chan-&gt;ic_flags);</a>
<a name="ln842">        return AH_NULL;</a>
<a name="ln843">    }</a>
<a name="ln844"> </a>
<a name="ln845">    /*</a>
<a name="ln846">     * FreeBSD sets multiple flags, so this will fail.</a>
<a name="ln847">     */</a>
<a name="ln848">#if 0</a>
<a name="ln849">    if ((IS(chan, CHAN_OFDM) ^ IS(chan, CHAN_CCK) ^ IS(chan, CHAN_DYN) ^</a>
<a name="ln850">         IS(chan, CHAN_HT20) ^ IS(chan, CHAN_HT40U) ^</a>
<a name="ln851">         IS(chan, CHAN_HT40D)) == 0)</a>
<a name="ln852">    {</a>
<a name="ln853">        HALDEBUG(ah, HAL_DEBUG_CHANNEL,</a>
<a name="ln854">            &quot;%s: invalid channel %u/0x%x; not marked as &quot;</a>
<a name="ln855">            &quot;OFDM or CCK or DYN or HT20 or HT40PLUS or HT40MINUS\n&quot;,</a>
<a name="ln856">            __func__, chan-&gt;ic_freq , chan-&gt;ic_flags);</a>
<a name="ln857">        return AH_NULL;</a>
<a name="ln858">    }</a>
<a name="ln859">#endif</a>
<a name="ln860"> </a>
<a name="ln861">    return (ath_hal_checkchannel(ah, chan));</a>
<a name="ln862">}</a>
<a name="ln863">#undef IS</a>
<a name="ln864"> </a>
<a name="ln865">static void</a>
<a name="ln866">ar9300_set_11n_regs(struct ath_hal *ah, struct ieee80211_channel *chan,</a>
<a name="ln867">    HAL_HT_MACMODE macmode)</a>
<a name="ln868">{</a>
<a name="ln869">    u_int32_t phymode;</a>
<a name="ln870">//    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln871">    u_int32_t enable_dac_fifo;</a>
<a name="ln872"> </a>
<a name="ln873">    /* XXX */</a>
<a name="ln874">    enable_dac_fifo =</a>
<a name="ln875">        OS_REG_READ(ah, AR_PHY_GEN_CTRL) &amp; AR_PHY_GC_ENABLE_DAC_FIFO;</a>
<a name="ln876"> </a>
<a name="ln877">    /* Enable 11n HT, 20 MHz */</a>
<a name="ln878">    phymode =</a>
<a name="ln879">        AR_PHY_GC_HT_EN | AR_PHY_GC_SINGLE_HT_LTF1 | AR_PHY_GC_SHORT_GI_40</a>
<a name="ln880">        | enable_dac_fifo;</a>
<a name="ln881">    /* Configure baseband for dynamic 20/40 operation */</a>
<a name="ln882">    if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln883">        phymode |= AR_PHY_GC_DYN2040_EN;</a>
<a name="ln884">        /* Configure control (primary) channel at +-10MHz */</a>
<a name="ln885">        if (IEEE80211_IS_CHAN_HT40U(chan)) {</a>
<a name="ln886">            phymode |= AR_PHY_GC_DYN2040_PRI_CH;</a>
<a name="ln887">        }</a>
<a name="ln888"> </a>
<a name="ln889">#if 0</a>
<a name="ln890">        /* Configure 20/25 spacing */</a>
<a name="ln891">        if (ahp-&gt;ah_ext_prot_spacing == HAL_HT_EXTPROTSPACING_25) {</a>
<a name="ln892">            phymode |= AR_PHY_GC_DYN2040_EXT_CH;</a>
<a name="ln893">        }</a>
<a name="ln894">#endif</a>
<a name="ln895">    }</a>
<a name="ln896"> </a>
<a name="ln897">    /* make sure we preserve INI settings */</a>
<a name="ln898">    phymode |= OS_REG_READ(ah, AR_PHY_GEN_CTRL);</a>
<a name="ln899"> </a>
<a name="ln900">    /* EV 62881/64991 - turn off Green Field detection for Maverick STA beta */</a>
<a name="ln901">    phymode &amp;= ~AR_PHY_GC_GF_DETECT_EN;</a>
<a name="ln902"> </a>
<a name="ln903">    OS_REG_WRITE(ah, AR_PHY_GEN_CTRL, phymode);</a>
<a name="ln904"> </a>
<a name="ln905">    /* Set IFS timing for half/quarter rates */</a>
<a name="ln906">    if (IEEE80211_IS_CHAN_HALF(chan) || IEEE80211_IS_CHAN_QUARTER(chan)) {</a>
<a name="ln907">        u_int32_t modeselect = OS_REG_READ(ah, AR_PHY_MODE);</a>
<a name="ln908"> </a>
<a name="ln909">        if (IEEE80211_IS_CHAN_HALF(chan)) {</a>
<a name="ln910">            modeselect |= AR_PHY_MS_HALF_RATE;</a>
<a name="ln911">        } else if (IEEE80211_IS_CHAN_QUARTER(chan)) {</a>
<a name="ln912">            modeselect |= AR_PHY_MS_QUARTER_RATE;</a>
<a name="ln913">        }</a>
<a name="ln914">        OS_REG_WRITE(ah, AR_PHY_MODE, modeselect);</a>
<a name="ln915"> </a>
<a name="ln916">        ar9300_set_ifs_timing(ah, chan);</a>
<a name="ln917">        OS_REG_RMW_FIELD(</a>
<a name="ln918">            ah, AR_PHY_FRAME_CTL, AR_PHY_FRAME_CTL_CF_OVERLAP_WINDOW, 0x3);</a>
<a name="ln919">    }</a>
<a name="ln920"> </a>
<a name="ln921">    /* Configure MAC for 20/40 operation */</a>
<a name="ln922">    ar9300_set_11n_mac2040(ah, macmode);</a>
<a name="ln923"> </a>
<a name="ln924">    /* global transmit timeout (25 TUs default)*/</a>
<a name="ln925">    /* XXX - put this elsewhere??? */</a>
<a name="ln926">    OS_REG_WRITE(ah, AR_GTXTO, 25 &lt;&lt; AR_GTXTO_TIMEOUT_LIMIT_S);</a>
<a name="ln927"> </a>
<a name="ln928">    /* carrier sense timeout */</a>
<a name="ln929">    OS_REG_WRITE(ah, AR_CST, 0xF &lt;&lt; AR_CST_TIMEOUT_LIMIT_S);</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">/*</a>
<a name="ln933"> * Spur mitigation for MRC CCK</a>
<a name="ln934"> */</a>
<a name="ln935">static void</a>
<a name="ln936">ar9300_spur_mitigate_mrc_cck(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln937">{</a>
<a name="ln938">    int i;</a>
<a name="ln939">    /* spur_freq_for_osprey - hardcoded by Systems team for now. */</a>
<a name="ln940">    u_int32_t spur_freq_for_osprey[4] = { 2420, 2440, 2464, 2480 };</a>
<a name="ln941">    u_int32_t spur_freq_for_jupiter[2] = { 2440, 2464};</a>
<a name="ln942">    int cur_bb_spur, negative = 0, cck_spur_freq;</a>
<a name="ln943">    u_int8_t* spur_fbin_ptr = NULL;</a>
<a name="ln944">    int synth_freq;</a>
<a name="ln945">    int range = 10;</a>
<a name="ln946">    int max_spurcounts = OSPREY_EEPROM_MODAL_SPURS; </a>
<a name="ln947">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln948"> </a>
<a name="ln949">    /*</a>
<a name="ln950">     * Need to verify range +/- 10 MHz in control channel, otherwise spur</a>
<a name="ln951">     * is out-of-band and can be ignored.</a>
<a name="ln952">     */</a>
<a name="ln953">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) ||</a>
<a name="ln954">        AR_SREV_WASP(ah)  || AR_SREV_SCORPION(ah)) {</a>
<a name="ln955">        spur_fbin_ptr = ar9300_eeprom_get_spur_chans_ptr(ah, 1);</a>
<a name="ln956">        if (spur_fbin_ptr[0] == 0) {</a>
<a name="ln957">            return;      /* No spur in the mode */</a>
<a name="ln958">        }</a>
<a name="ln959">        if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln960">            range = 19;</a>
<a name="ln961">            if (OS_REG_READ_FIELD(ah, AR_PHY_GEN_CTRL, AR_PHY_GC_DYN2040_PRI_CH)</a>
<a name="ln962">                == 0x0)</a>
<a name="ln963">            {</a>
<a name="ln964">                synth_freq = ichan-&gt;channel + 10;</a>
<a name="ln965">            } else {</a>
<a name="ln966">                synth_freq = ichan-&gt;channel - 10;</a>
<a name="ln967">            }</a>
<a name="ln968">        } else {</a>
<a name="ln969">            range = 10;</a>
<a name="ln970">            synth_freq = ichan-&gt;channel;</a>
<a name="ln971">        }</a>
<a name="ln972">    } else if(AR_SREV_JUPITER(ah)) {</a>
<a name="ln973">        range = 5;</a>
<a name="ln974">        max_spurcounts = 2; /* Hardcoded by Jupiter Systems team for now. */</a>
<a name="ln975">        synth_freq = ichan-&gt;channel;</a>
<a name="ln976">    } else {</a>
<a name="ln977">        range = 10;</a>
<a name="ln978">        max_spurcounts = 4; /* Hardcoded by Osprey Systems team for now. */</a>
<a name="ln979">        synth_freq = ichan-&gt;channel;</a>
<a name="ln980">    }</a>
<a name="ln981"> </a>
<a name="ln982">    for (i = 0; i &lt; max_spurcounts; i++) {</a>
<a name="ln983">        negative = 0;</a>
<a name="ln984"> </a>
<a name="ln985">        if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) ||</a>
<a name="ln986">            AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah)) {</a>
<a name="ln987">            cur_bb_spur = </a>
<a name="ln988">                FBIN2FREQ(spur_fbin_ptr[i], HAL_FREQ_BAND_2GHZ) - synth_freq;</a>
<a name="ln989">        } else if(AR_SREV_JUPITER(ah)) {</a>
<a name="ln990">            cur_bb_spur = spur_freq_for_jupiter[i] - synth_freq;</a>
<a name="ln991">        } else {</a>
<a name="ln992">            cur_bb_spur = spur_freq_for_osprey[i] - synth_freq;</a>
<a name="ln993">        }</a>
<a name="ln994">        </a>
<a name="ln995">        if (cur_bb_spur &lt; 0) {</a>
<a name="ln996">            negative = 1;</a>
<a name="ln997">            cur_bb_spur = -cur_bb_spur;</a>
<a name="ln998">        }</a>
<a name="ln999">        if (cur_bb_spur &lt; range) {</a>
<a name="ln1000">            cck_spur_freq = (int)((cur_bb_spur &lt;&lt; 19) / 11);</a>
<a name="ln1001">            if (negative == 1) {</a>
<a name="ln1002">                cck_spur_freq = -cck_spur_freq;</a>
<a name="ln1003">            }</a>
<a name="ln1004">            cck_spur_freq = cck_spur_freq &amp; 0xfffff;</a>
<a name="ln1005">            /*OS_REG_WRITE_field(ah, BB_agc_control.ycok_max, 0x7);*/</a>
<a name="ln1006">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1007">                AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_YCOK_MAX, 0x7);</a>
<a name="ln1008">            /*OS_REG_WRITE_field(ah, BB_cck_spur_mit.spur_rssi_thr, 0x7f);*/</a>
<a name="ln1009">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1010">                AR_PHY_CCK_SPUR_MIT, AR_PHY_CCK_SPUR_MIT_SPUR_RSSI_THR, 0x7f);</a>
<a name="ln1011">            /*OS_REG_WRITE(ah, BB_cck_spur_mit.spur_filter_type, 0x2);*/</a>
<a name="ln1012">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1013">                AR_PHY_CCK_SPUR_MIT, AR_PHY_CCK_SPUR_MIT_SPUR_FILTER_TYPE, 0x2);</a>
<a name="ln1014">            /*OS_REG_WRITE(ah, BB_cck_spur_mit.use_cck_spur_mit, 0x1);*/</a>
<a name="ln1015">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1016">                AR_PHY_CCK_SPUR_MIT, AR_PHY_CCK_SPUR_MIT_USE_CCK_SPUR_MIT, 0x1);</a>
<a name="ln1017">            /*OS_REG_WRITE(ah, BB_cck_spur_mit.cck_spur_freq, cck_spur_freq);*/</a>
<a name="ln1018">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1019">                AR_PHY_CCK_SPUR_MIT, AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ,</a>
<a name="ln1020">                cck_spur_freq);</a>
<a name="ln1021">            return; </a>
<a name="ln1022">        }</a>
<a name="ln1023">    }</a>
<a name="ln1024"> </a>
<a name="ln1025">    /*OS_REG_WRITE(ah, BB_agc_control.ycok_max, 0x5);*/</a>
<a name="ln1026">    OS_REG_RMW_FIELD(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_YCOK_MAX, 0x5);</a>
<a name="ln1027">    /*OS_REG_WRITE(ah, BB_cck_spur_mit.use_cck_spur_mit, 0x0);*/</a>
<a name="ln1028">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1029">        AR_PHY_CCK_SPUR_MIT, AR_PHY_CCK_SPUR_MIT_USE_CCK_SPUR_MIT, 0x0);</a>
<a name="ln1030">    /*OS_REG_WRITE(ah, BB_cck_spur_mit.cck_spur_freq, 0x0);*/</a>
<a name="ln1031">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1032">        AR_PHY_CCK_SPUR_MIT, AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ, 0x0);</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035">/* Spur mitigation for OFDM */</a>
<a name="ln1036">static void</a>
<a name="ln1037">ar9300_spur_mitigate_ofdm(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln1038">{ </a>
<a name="ln1039">    int synth_freq;</a>
<a name="ln1040">    int range = 10;</a>
<a name="ln1041">    int freq_offset = 0;</a>
<a name="ln1042">    int spur_freq_sd = 0;</a>
<a name="ln1043">    int spur_subchannel_sd = 0;</a>
<a name="ln1044">    int spur_delta_phase = 0;</a>
<a name="ln1045">    int mask_index = 0;</a>
<a name="ln1046">    int i;</a>
<a name="ln1047">    int mode;</a>
<a name="ln1048">    u_int8_t* spur_chans_ptr;</a>
<a name="ln1049">    struct ath_hal_9300 *ahp;</a>
<a name="ln1050">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln1051">	ahp = AH9300(ah);</a>
<a name="ln1052"> </a>
<a name="ln1053">    if (IS_CHAN_5GHZ(ichan)) {</a>
<a name="ln1054">        spur_chans_ptr = ar9300_eeprom_get_spur_chans_ptr(ah, 0);</a>
<a name="ln1055">        mode = 0;</a>
<a name="ln1056">    } else {</a>
<a name="ln1057">        spur_chans_ptr = ar9300_eeprom_get_spur_chans_ptr(ah, 1);</a>
<a name="ln1058">        mode = 1;</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">    if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln1062">        range = 19;</a>
<a name="ln1063">        if (OS_REG_READ_FIELD(ah, AR_PHY_GEN_CTRL, AR_PHY_GC_DYN2040_PRI_CH)</a>
<a name="ln1064">            == 0x0)</a>
<a name="ln1065">        {</a>
<a name="ln1066">            synth_freq = ichan-&gt;channel - 10;</a>
<a name="ln1067">        } else {</a>
<a name="ln1068">            synth_freq = ichan-&gt;channel + 10;</a>
<a name="ln1069">        }</a>
<a name="ln1070">    } else {</a>
<a name="ln1071">        range = 10;</a>
<a name="ln1072">        synth_freq = ichan-&gt;channel;</a>
<a name="ln1073">    }</a>
<a name="ln1074"> </a>
<a name="ln1075">    /* Clean all spur register fields */</a>
<a name="ln1076">    OS_REG_RMW_FIELD(ah, AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_SPUR_FILTER, 0);</a>
<a name="ln1077">    OS_REG_RMW_FIELD(ah, AR_PHY_TIMING11, AR_PHY_TIMING11_SPUR_FREQ_SD, 0);</a>
<a name="ln1078">    OS_REG_RMW_FIELD(ah, AR_PHY_TIMING11, AR_PHY_TIMING11_SPUR_DELTA_PHASE, 0);</a>
<a name="ln1079">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1080">        AR_PHY_SFCORR_EXT, AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD, 0);</a>
<a name="ln1081">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1082">        AR_PHY_TIMING11, AR_PHY_TIMING11_USE_SPUR_FILTER_IN_AGC, 0);</a>
<a name="ln1083">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1084">        AR_PHY_TIMING11, AR_PHY_TIMING11_USE_SPUR_FILTER_IN_SELFCOR, 0);</a>
<a name="ln1085">    OS_REG_RMW_FIELD(ah, AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_SPUR_RSSI, 0);</a>
<a name="ln1086">    OS_REG_RMW_FIELD(ah, AR_PHY_SPUR_REG, AR_PHY_SPUR_REG_EN_VIT_SPUR_RSSI, 0);</a>
<a name="ln1087">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1088">        AR_PHY_SPUR_REG, AR_PHY_SPUR_REG_ENABLE_NF_RSSI_SPUR_MIT, 0);</a>
<a name="ln1089">    OS_REG_RMW_FIELD(ah, AR_PHY_SPUR_REG, AR_PHY_SPUR_REG_ENABLE_MASK_PPM, 0);</a>
<a name="ln1090">    OS_REG_RMW_FIELD(ah, AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_PILOT_MASK, 0);</a>
<a name="ln1091">    OS_REG_RMW_FIELD(ah, AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_CHAN_MASK, 0);</a>
<a name="ln1092">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1093">        AR_PHY_PILOT_SPUR_MASK, AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A, 0);</a>
<a name="ln1094">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1095">        AR_PHY_SPUR_MASK_A, AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A, 0);</a>
<a name="ln1096">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1097">        AR_PHY_CHAN_SPUR_MASK, AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_IDX_A, 0);</a>
<a name="ln1098">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1099">        AR_PHY_PILOT_SPUR_MASK, AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_A, 0);</a>
<a name="ln1100">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1101">        AR_PHY_CHAN_SPUR_MASK, AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_A, 0);</a>
<a name="ln1102">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln1103">        AR_PHY_SPUR_MASK_A, AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A, 0);</a>
<a name="ln1104">    OS_REG_RMW_FIELD(ah, AR_PHY_SPUR_REG, AR_PHY_SPUR_REG_MASK_RATE_CNTL, 0);</a>
<a name="ln1105"> </a>
<a name="ln1106">    i = 0;</a>
<a name="ln1107">    while (spur_chans_ptr[i] &amp;&amp; i &lt; 5) {</a>
<a name="ln1108">        freq_offset = FBIN2FREQ(spur_chans_ptr[i], mode) - synth_freq;</a>
<a name="ln1109">        if (abs(freq_offset) &lt; range) {</a>
<a name="ln1110">            /*</a>
<a name="ln1111">            printf(</a>
<a name="ln1112">                &quot;Spur Mitigation for OFDM: Synth Frequency = %d, &quot;</a>
<a name="ln1113">                &quot;Spur Frequency = %d\n&quot;,</a>
<a name="ln1114">                synth_freq, FBIN2FREQ(spur_chans_ptr[i], mode));</a>
<a name="ln1115">             */</a>
<a name="ln1116">            if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln1117">                if (freq_offset &lt; 0) {</a>
<a name="ln1118">                    if (OS_REG_READ_FIELD(</a>
<a name="ln1119">                        ah, AR_PHY_GEN_CTRL, AR_PHY_GC_DYN2040_PRI_CH) == 0x0)</a>
<a name="ln1120">                    {</a>
<a name="ln1121">                        spur_subchannel_sd = 1;</a>
<a name="ln1122">                    } else {</a>
<a name="ln1123">                        spur_subchannel_sd = 0;</a>
<a name="ln1124">                    }</a>
<a name="ln1125">                    spur_freq_sd = ((freq_offset + 10) &lt;&lt; 9) / 11;</a>
<a name="ln1126">                } else {</a>
<a name="ln1127">                    if (OS_REG_READ_FIELD(ah,</a>
<a name="ln1128">                        AR_PHY_GEN_CTRL, AR_PHY_GC_DYN2040_PRI_CH) == 0x0)</a>
<a name="ln1129">                    {</a>
<a name="ln1130">                        spur_subchannel_sd = 0;</a>
<a name="ln1131">                    } else {</a>
<a name="ln1132">                        spur_subchannel_sd = 1;</a>
<a name="ln1133">                    }</a>
<a name="ln1134">                    spur_freq_sd = ((freq_offset - 10) &lt;&lt; 9) / 11;</a>
<a name="ln1135">                }</a>
<a name="ln1136">                spur_delta_phase = (freq_offset &lt;&lt; 17) / 5;</a>
<a name="ln1137">            } else {</a>
<a name="ln1138">                spur_subchannel_sd = 0;</a>
<a name="ln1139">                spur_freq_sd = (freq_offset &lt;&lt; 9) / 11;</a>
<a name="ln1140">                spur_delta_phase = (freq_offset &lt;&lt; 18) / 5;</a>
<a name="ln1141">            }</a>
<a name="ln1142">            spur_freq_sd = spur_freq_sd &amp; 0x3ff;</a>
<a name="ln1143">            spur_delta_phase = spur_delta_phase &amp; 0xfffff;</a>
<a name="ln1144">            /*</a>
<a name="ln1145">            printf(</a>
<a name="ln1146">                &quot;spur_subchannel_sd = %d, spur_freq_sd = 0x%x, &quot;</a>
<a name="ln1147">                &quot;spur_delta_phase = 0x%x\n&quot;, spur_subchannel_sd,</a>
<a name="ln1148">                spur_freq_sd, spur_delta_phase);</a>
<a name="ln1149">             */</a>
<a name="ln1150"> </a>
<a name="ln1151">            /* OFDM Spur mitigation */</a>
<a name="ln1152">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1153">                AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_SPUR_FILTER, 0x1);</a>
<a name="ln1154">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1155">                AR_PHY_TIMING11, AR_PHY_TIMING11_SPUR_FREQ_SD, spur_freq_sd);</a>
<a name="ln1156">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1157">                AR_PHY_TIMING11, AR_PHY_TIMING11_SPUR_DELTA_PHASE,</a>
<a name="ln1158">                spur_delta_phase);</a>
<a name="ln1159">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1160">                AR_PHY_SFCORR_EXT, AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD,</a>
<a name="ln1161">                spur_subchannel_sd);</a>
<a name="ln1162">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1163">                AR_PHY_TIMING11, AR_PHY_TIMING11_USE_SPUR_FILTER_IN_AGC, 0x1);</a>
<a name="ln1164">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1165">                AR_PHY_TIMING11, AR_PHY_TIMING11_USE_SPUR_FILTER_IN_SELFCOR,</a>
<a name="ln1166">                0x1);</a>
<a name="ln1167">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1168">                AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_SPUR_RSSI, 0x1);</a>
<a name="ln1169">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1170">                AR_PHY_SPUR_REG, AR_PHY_SPUR_REG_SPUR_RSSI_THRESH, 34);</a>
<a name="ln1171">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1172">                AR_PHY_SPUR_REG, AR_PHY_SPUR_REG_EN_VIT_SPUR_RSSI, 1);</a>
<a name="ln1173"> </a>
<a name="ln1174">            /*</a>
<a name="ln1175">             * Do not subtract spur power from noise floor for wasp.</a>
<a name="ln1176">             * This causes the maximum client test (on Veriwave) to fail</a>
<a name="ln1177">             * when run on spur channel (2464 MHz).</a>
<a name="ln1178">             * Refer to ev#82746 and ev#82744.</a>
<a name="ln1179">             */</a>
<a name="ln1180">            if (!AR_SREV_WASP(ah) &amp;&amp; (OS_REG_READ_FIELD(ah, AR_PHY_MODE,</a>
<a name="ln1181">                                           AR_PHY_MODE_DYNAMIC) == 0x1)) {</a>
<a name="ln1182">                OS_REG_RMW_FIELD(ah, AR_PHY_SPUR_REG,</a>
<a name="ln1183">                    AR_PHY_SPUR_REG_ENABLE_NF_RSSI_SPUR_MIT, 1);</a>
<a name="ln1184">            }</a>
<a name="ln1185"> </a>
<a name="ln1186">            mask_index = (freq_offset &lt;&lt; 4) / 5;</a>
<a name="ln1187">            if (mask_index &lt; 0) {</a>
<a name="ln1188">                mask_index = mask_index - 1;</a>
<a name="ln1189">            }</a>
<a name="ln1190">            mask_index = mask_index &amp; 0x7f;</a>
<a name="ln1191">            /*printf(&quot;Bin 0x%x\n&quot;, mask_index);*/</a>
<a name="ln1192"> </a>
<a name="ln1193">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1194">                AR_PHY_SPUR_REG, AR_PHY_SPUR_REG_ENABLE_MASK_PPM, 0x1);</a>
<a name="ln1195">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1196">                AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_PILOT_MASK, 0x1);</a>
<a name="ln1197">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1198">                AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_CHAN_MASK, 0x1);</a>
<a name="ln1199">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1200">                AR_PHY_PILOT_SPUR_MASK,</a>
<a name="ln1201">                AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A, mask_index);</a>
<a name="ln1202">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1203">                AR_PHY_SPUR_MASK_A, AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A,</a>
<a name="ln1204">                mask_index);</a>
<a name="ln1205">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1206">                AR_PHY_CHAN_SPUR_MASK,</a>
<a name="ln1207">                AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_IDX_A, mask_index);</a>
<a name="ln1208">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1209">                AR_PHY_PILOT_SPUR_MASK, AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_A,</a>
<a name="ln1210">                0xc);</a>
<a name="ln1211">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1212">                AR_PHY_CHAN_SPUR_MASK, AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_A,</a>
<a name="ln1213">                0xc);</a>
<a name="ln1214">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1215">                AR_PHY_SPUR_MASK_A, AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A, 0xa0);</a>
<a name="ln1216">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln1217">                AR_PHY_SPUR_REG, AR_PHY_SPUR_REG_MASK_RATE_CNTL, 0xff);</a>
<a name="ln1218">            /*</a>
<a name="ln1219">            printf(&quot;BB_timing_control_4 = 0x%x\n&quot;,</a>
<a name="ln1220">                OS_REG_READ(ah, AR_PHY_TIMING4));</a>
<a name="ln1221">            printf(&quot;BB_timing_control_11 = 0x%x\n&quot;,</a>
<a name="ln1222">                OS_REG_READ(ah, AR_PHY_TIMING11));</a>
<a name="ln1223">            printf(&quot;BB_ext_chan_scorr_thr = 0x%x\n&quot;,</a>
<a name="ln1224">                OS_REG_READ(ah, AR_PHY_SFCORR_EXT));</a>
<a name="ln1225">            printf(&quot;BB_spur_mask_controls = 0x%x\n&quot;,</a>
<a name="ln1226">                OS_REG_READ(ah, AR_PHY_SPUR_REG));</a>
<a name="ln1227">            printf(&quot;BB_pilot_spur_mask = 0x%x\n&quot;,</a>
<a name="ln1228">                OS_REG_READ(ah, AR_PHY_PILOT_SPUR_MASK));</a>
<a name="ln1229">            printf(&quot;BB_chan_spur_mask = 0x%x\n&quot;,</a>
<a name="ln1230">                OS_REG_READ(ah, AR_PHY_CHAN_SPUR_MASK));</a>
<a name="ln1231">            printf(&quot;BB_vit_spur_mask_A = 0x%x\n&quot;,</a>
<a name="ln1232">                OS_REG_READ(ah, AR_PHY_SPUR_MASK_A));</a>
<a name="ln1233">             */</a>
<a name="ln1234">            break;</a>
<a name="ln1235">        }</a>
<a name="ln1236">        i++;</a>
<a name="ln1237">    }</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240"> </a>
<a name="ln1241">/*</a>
<a name="ln1242"> * Convert to baseband spur frequency given input channel frequency </a>
<a name="ln1243"> * and compute register settings below.</a>
<a name="ln1244"> */</a>
<a name="ln1245">static void</a>
<a name="ln1246">ar9300_spur_mitigate(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln1247">{</a>
<a name="ln1248">    ar9300_spur_mitigate_ofdm(ah, chan);</a>
<a name="ln1249">    ar9300_spur_mitigate_mrc_cck(ah, chan);</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252">/**************************************************************</a>
<a name="ln1253"> * ar9300_channel_change</a>
<a name="ln1254"> * Assumes caller wants to change channel, and not reset.</a>
<a name="ln1255"> */</a>
<a name="ln1256">static inline HAL_BOOL</a>
<a name="ln1257">ar9300_channel_change(struct ath_hal *ah, struct ieee80211_channel *chan,</a>
<a name="ln1258">    HAL_CHANNEL_INTERNAL *ichan, HAL_HT_MACMODE macmode)</a>
<a name="ln1259">{</a>
<a name="ln1260"> </a>
<a name="ln1261">    u_int32_t synth_delay, qnum;</a>
<a name="ln1262">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1263"> </a>
<a name="ln1264">    /* TX must be stopped by now */</a>
<a name="ln1265">    for (qnum = 0; qnum &lt; AR_NUM_QCU; qnum++) {</a>
<a name="ln1266">        if (ar9300_num_tx_pending(ah, qnum)) {</a>
<a name="ln1267">            HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln1268">                &quot;%s: Transmit frames pending on queue %d\n&quot;, __func__, qnum);</a>
<a name="ln1269">            HALASSERT(0);</a>
<a name="ln1270">            return AH_FALSE;</a>
<a name="ln1271">        }</a>
<a name="ln1272">    }</a>
<a name="ln1273"> </a>
<a name="ln1274"> </a>
<a name="ln1275">    /*</a>
<a name="ln1276">     * Kill last Baseband Rx Frame - Request analog bus grant</a>
<a name="ln1277">     */</a>
<a name="ln1278">    OS_REG_WRITE(ah, AR_PHY_RFBUS_REQ, AR_PHY_RFBUS_REQ_EN);</a>
<a name="ln1279">    if (!ath_hal_wait(ah, AR_PHY_RFBUS_GRANT, AR_PHY_RFBUS_GRANT_EN,</a>
<a name="ln1280">            AR_PHY_RFBUS_GRANT_EN))</a>
<a name="ln1281">    {</a>
<a name="ln1282">        HALDEBUG(ah, HAL_DEBUG_PHYIO,</a>
<a name="ln1283">            &quot;%s: Could not kill baseband RX\n&quot;, __func__);</a>
<a name="ln1284">        return AH_FALSE;</a>
<a name="ln1285">    }</a>
<a name="ln1286"> </a>
<a name="ln1287"> </a>
<a name="ln1288">    /* Setup 11n MAC/Phy mode registers */</a>
<a name="ln1289">    ar9300_set_11n_regs(ah, chan, macmode);</a>
<a name="ln1290"> </a>
<a name="ln1291">    /*</a>
<a name="ln1292">     * Change the synth</a>
<a name="ln1293">     */</a>
<a name="ln1294">    if (!ahp-&gt;ah_rf_hal.set_channel(ah, chan)) {</a>
<a name="ln1295">        HALDEBUG(ah, HAL_DEBUG_CHANNEL, &quot;%s: failed to set channel\n&quot;, __func__);</a>
<a name="ln1296">        return AH_FALSE;</a>
<a name="ln1297">    }</a>
<a name="ln1298"> </a>
<a name="ln1299">    /* </a>
<a name="ln1300">     * Some registers get reinitialized during ATH_INI_POST INI programming. </a>
<a name="ln1301">     */</a>
<a name="ln1302">    ar9300_init_user_settings(ah);</a>
<a name="ln1303"> </a>
<a name="ln1304">    /*</a>
<a name="ln1305">     * Setup the transmit power values.</a>
<a name="ln1306">     *</a>
<a name="ln1307">     * After the public to private hal channel mapping, ichan contains the</a>
<a name="ln1308">     * valid regulatory power value.</a>
<a name="ln1309">     * ath_hal_getctl and ath_hal_getantennaallowed look up ichan from chan.</a>
<a name="ln1310">     */</a>
<a name="ln1311">    if (ar9300_eeprom_set_transmit_power(</a>
<a name="ln1312">         ah, &amp;ahp-&gt;ah_eeprom, chan, ath_hal_getctl(ah, chan),</a>
<a name="ln1313">         ath_hal_getantennaallowed(ah, chan),</a>
<a name="ln1314">         ath_hal_get_twice_max_regpower(AH_PRIVATE(ah), ichan, chan),</a>
<a name="ln1315">         AH_MIN(MAX_RATE_POWER, AH_PRIVATE(ah)-&gt;ah_powerLimit)) != HAL_OK)</a>
<a name="ln1316">    {</a>
<a name="ln1317">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln1318">            &quot;%s: error init'ing transmit power\n&quot;, __func__);</a>
<a name="ln1319">        return AH_FALSE;</a>
<a name="ln1320">    }</a>
<a name="ln1321"> </a>
<a name="ln1322">    /*</a>
<a name="ln1323">     * Release the RFBus Grant.</a>
<a name="ln1324">     */</a>
<a name="ln1325">    OS_REG_WRITE(ah, AR_PHY_RFBUS_REQ, 0);</a>
<a name="ln1326"> </a>
<a name="ln1327">    /*</a>
<a name="ln1328">     * Write spur immunity and delta slope for OFDM enabled modes (A, G, Turbo)</a>
<a name="ln1329">     */</a>
<a name="ln1330">    if (IEEE80211_IS_CHAN_OFDM(chan) || IEEE80211_IS_CHAN_HT(chan)) {</a>
<a name="ln1331">        ar9300_set_delta_slope(ah, chan);</a>
<a name="ln1332">    } else {</a>
<a name="ln1333">        /* Set to Ini default */</a>
<a name="ln1334">        OS_REG_WRITE(ah, AR_PHY_TIMING3, 0x9c0a9f6b);</a>
<a name="ln1335">        OS_REG_WRITE(ah, AR_PHY_SGI_DELTA, 0x00046384);</a>
<a name="ln1336">    }</a>
<a name="ln1337"> </a>
<a name="ln1338">    ar9300_spur_mitigate(ah, chan);</a>
<a name="ln1339"> </a>
<a name="ln1340"> </a>
<a name="ln1341">    /*</a>
<a name="ln1342">     * Wait for the frequency synth to settle (synth goes on via PHY_ACTIVE_EN).</a>
<a name="ln1343">     * Read the phy active delay register. Value is in 100ns increments.</a>
<a name="ln1344">     */</a>
<a name="ln1345">    synth_delay = OS_REG_READ(ah, AR_PHY_RX_DELAY) &amp; AR_PHY_RX_DELAY_DELAY;</a>
<a name="ln1346">    if (IEEE80211_IS_CHAN_CCK(chan)) {</a>
<a name="ln1347">        synth_delay = (4 * synth_delay) / 22;</a>
<a name="ln1348">    } else {</a>
<a name="ln1349">        synth_delay /= 10;</a>
<a name="ln1350">    }</a>
<a name="ln1351"> </a>
<a name="ln1352">    OS_DELAY(synth_delay + BASE_ACTIVATE_DELAY);</a>
<a name="ln1353"> </a>
<a name="ln1354">    /*</a>
<a name="ln1355">     * Do calibration.</a>
<a name="ln1356">     */</a>
<a name="ln1357"> </a>
<a name="ln1358">    return AH_TRUE;</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361">void</a>
<a name="ln1362">ar9300_set_operating_mode(struct ath_hal *ah, int opmode)</a>
<a name="ln1363">{</a>
<a name="ln1364">    u_int32_t val;</a>
<a name="ln1365"> </a>
<a name="ln1366">    val = OS_REG_READ(ah, AR_STA_ID1);</a>
<a name="ln1367">    val &amp;= ~(AR_STA_ID1_STA_AP | AR_STA_ID1_ADHOC);</a>
<a name="ln1368">    switch (opmode) {</a>
<a name="ln1369">    case HAL_M_HOSTAP:</a>
<a name="ln1370">        OS_REG_WRITE(ah, AR_STA_ID1,</a>
<a name="ln1371">            val | AR_STA_ID1_STA_AP | AR_STA_ID1_KSRCH_MODE);</a>
<a name="ln1372">        OS_REG_CLR_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);</a>
<a name="ln1373">        break;</a>
<a name="ln1374">    case HAL_M_IBSS:</a>
<a name="ln1375">        OS_REG_WRITE(ah, AR_STA_ID1,</a>
<a name="ln1376">            val | AR_STA_ID1_ADHOC | AR_STA_ID1_KSRCH_MODE);</a>
<a name="ln1377">        OS_REG_SET_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);</a>
<a name="ln1378">        break;</a>
<a name="ln1379">    case HAL_M_STA:</a>
<a name="ln1380">    case HAL_M_MONITOR:</a>
<a name="ln1381">        OS_REG_WRITE(ah, AR_STA_ID1, val | AR_STA_ID1_KSRCH_MODE);</a>
<a name="ln1382">        break;</a>
<a name="ln1383">    }</a>
<a name="ln1384">}</a>
<a name="ln1385"> </a>
<a name="ln1386">/* XXX need the logic for Osprey */</a>
<a name="ln1387">void</a>
<a name="ln1388">ar9300_init_pll(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln1389">{</a>
<a name="ln1390">    u_int32_t pll;</a>
<a name="ln1391">    u_int8_t clk_25mhz = AH9300(ah)-&gt;clk_25mhz;</a>
<a name="ln1392">    HAL_CHANNEL_INTERNAL *ichan = NULL;</a>
<a name="ln1393"> </a>
<a name="ln1394">    if (chan)</a>
<a name="ln1395">        ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln1396"> </a>
<a name="ln1397">    if (AR_SREV_HORNET(ah)) {</a>
<a name="ln1398">        if (clk_25mhz) {</a>
<a name="ln1399">            /* Hornet uses PLL_CONTROL_2. Xtal is 25MHz for Hornet.</a>
<a name="ln1400">             * REFDIV set to 0x1.</a>
<a name="ln1401">             * $xtal_freq = 25;</a>
<a name="ln1402">             * $PLL2_div = (704/$xtal_freq); # 176 * 4 = 704.</a>
<a name="ln1403">             * MAC and BB run at 176 MHz.</a>
<a name="ln1404">             * $PLL2_divint = int($PLL2_div);</a>
<a name="ln1405">             * $PLL2_divfrac = $PLL2_div - $PLL2_divint;</a>
<a name="ln1406">             * $PLL2_divfrac = int($PLL2_divfrac * 0x4000); # 2^14</a>
<a name="ln1407">             * $PLL2_Val = ($PLL2_divint &amp; 0x3f) &lt;&lt; 19 | (0x1) &lt;&lt; 14 |</a>
<a name="ln1408">             *     $PLL2_divfrac &amp; 0x3fff;</a>
<a name="ln1409">             * Therefore, $PLL2_Val = 0xe04a3d</a>
<a name="ln1410">             */</a>
<a name="ln1411">#define DPLL2_KD_VAL            0x1D</a>
<a name="ln1412">#define DPLL2_KI_VAL            0x06</a>
<a name="ln1413">#define DPLL3_PHASE_SHIFT_VAL   0x1</a>
<a name="ln1414"> </a>
<a name="ln1415">            /* Rewrite DDR PLL2 and PLL3 */</a>
<a name="ln1416">            /* program DDR PLL ki and kd value, ki=0x6, kd=0x1d */</a>
<a name="ln1417">            OS_REG_WRITE(ah, AR_HORNET_CH0_DDR_DPLL2, 0x18e82f01);</a>
<a name="ln1418"> </a>
<a name="ln1419">            /* program DDR PLL phase_shift to 0x1 */</a>
<a name="ln1420">            OS_REG_RMW_FIELD(ah, AR_HORNET_CH0_DDR_DPLL3,</a>
<a name="ln1421">                AR_PHY_BB_DPLL3_PHASE_SHIFT, DPLL3_PHASE_SHIFT_VAL);</a>
<a name="ln1422"> </a>
<a name="ln1423">            OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL, 0x1142c);</a>
<a name="ln1424">            OS_DELAY(1000);</a>
<a name="ln1425"> </a>
<a name="ln1426">            /* program refdiv, nint, frac to RTC register */</a>
<a name="ln1427">            OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL2, 0xe04a3d);</a>
<a name="ln1428"> </a>
<a name="ln1429">            /* program BB PLL ki and kd value, ki=0x6, kd=0x1d */</a>
<a name="ln1430">            OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2,</a>
<a name="ln1431">                AR_PHY_BB_DPLL2_KD, DPLL2_KD_VAL);</a>
<a name="ln1432">            OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2,</a>
<a name="ln1433">                AR_PHY_BB_DPLL2_KI, DPLL2_KI_VAL);</a>
<a name="ln1434"> </a>
<a name="ln1435">            /* program BB PLL phase_shift to 0x1 */</a>
<a name="ln1436">            OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL3,</a>
<a name="ln1437">                AR_PHY_BB_DPLL3_PHASE_SHIFT, DPLL3_PHASE_SHIFT_VAL);</a>
<a name="ln1438">        } else { /* 40MHz */</a>
<a name="ln1439">#undef  DPLL2_KD_VAL</a>
<a name="ln1440">#undef  DPLL2_KI_VAL</a>
<a name="ln1441">#define DPLL2_KD_VAL            0x3D</a>
<a name="ln1442">#define DPLL2_KI_VAL            0x06</a>
<a name="ln1443">            /* Rewrite DDR PLL2 and PLL3 */</a>
<a name="ln1444">            /* program DDR PLL ki and kd value, ki=0x6, kd=0x3d */</a>
<a name="ln1445">            OS_REG_WRITE(ah, AR_HORNET_CH0_DDR_DPLL2, 0x19e82f01);</a>
<a name="ln1446"> </a>
<a name="ln1447">            /* program DDR PLL phase_shift to 0x1 */</a>
<a name="ln1448">            OS_REG_RMW_FIELD(ah, AR_HORNET_CH0_DDR_DPLL3,</a>
<a name="ln1449">                AR_PHY_BB_DPLL3_PHASE_SHIFT, DPLL3_PHASE_SHIFT_VAL);</a>
<a name="ln1450"> </a>
<a name="ln1451">            OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL, 0x1142c);</a>
<a name="ln1452">            OS_DELAY(1000);</a>
<a name="ln1453"> </a>
<a name="ln1454">            /* program refdiv, nint, frac to RTC register */</a>
<a name="ln1455">            OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL2, 0x886666);</a>
<a name="ln1456"> </a>
<a name="ln1457">            /* program BB PLL ki and kd value, ki=0x6, kd=0x3d */</a>
<a name="ln1458">            OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2,</a>
<a name="ln1459">                AR_PHY_BB_DPLL2_KD, DPLL2_KD_VAL);</a>
<a name="ln1460">            OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2,</a>
<a name="ln1461">                AR_PHY_BB_DPLL2_KI, DPLL2_KI_VAL);</a>
<a name="ln1462"> </a>
<a name="ln1463">            /* program BB PLL phase_shift to 0x1 */</a>
<a name="ln1464">            OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL3,</a>
<a name="ln1465">                AR_PHY_BB_DPLL3_PHASE_SHIFT, DPLL3_PHASE_SHIFT_VAL);</a>
<a name="ln1466">        }</a>
<a name="ln1467">        OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL, 0x142c);</a>
<a name="ln1468">        OS_DELAY(1000);</a>
<a name="ln1469">    } else if (AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1470">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2, AR_PHY_BB_DPLL2_PLL_PWD, 0x1);</a>
<a name="ln1471"> </a>
<a name="ln1472">        /* program BB PLL ki and kd value, ki=0x4, kd=0x40 */</a>
<a name="ln1473">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2, </a>
<a name="ln1474">            AR_PHY_BB_DPLL2_KD, 0x40);</a>
<a name="ln1475">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2, </a>
<a name="ln1476">            AR_PHY_BB_DPLL2_KI, 0x4);</a>
<a name="ln1477"> </a>
<a name="ln1478">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL1, </a>
<a name="ln1479">            AR_PHY_BB_DPLL1_REFDIV, 0x5);</a>
<a name="ln1480">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL1, </a>
<a name="ln1481">            AR_PHY_BB_DPLL1_NINI, 0x58);</a>
<a name="ln1482">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL1, </a>
<a name="ln1483">            AR_PHY_BB_DPLL1_NFRAC, 0x0);</a>
<a name="ln1484"> </a>
<a name="ln1485">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2, </a>
<a name="ln1486">            AR_PHY_BB_DPLL2_OUTDIV, 0x1);      </a>
<a name="ln1487">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2, </a>
<a name="ln1488">            AR_PHY_BB_DPLL2_LOCAL_PLL, 0x1);      </a>
<a name="ln1489">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2, </a>
<a name="ln1490">            AR_PHY_BB_DPLL2_EN_NEGTRIG, 0x1); </a>
<a name="ln1491"> </a>
<a name="ln1492">        /* program BB PLL phase_shift to 0x6 */</a>
<a name="ln1493">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL3, </a>
<a name="ln1494">            AR_PHY_BB_DPLL3_PHASE_SHIFT, 0x6); </a>
<a name="ln1495"> </a>
<a name="ln1496">        OS_REG_RMW_FIELD(ah, AR_PHY_BB_DPLL2, </a>
<a name="ln1497">            AR_PHY_BB_DPLL2_PLL_PWD, 0x0); </a>
<a name="ln1498">        OS_DELAY(1000);</a>
<a name="ln1499"> </a>
<a name="ln1500">        OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL, 0x142c);</a>
<a name="ln1501">        OS_DELAY(1000);</a>
<a name="ln1502">    } else if (AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah) || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln1503">#define SRIF_PLL 1</a>
<a name="ln1504">        u_int32_t regdata, pll2_divint, pll2_divfrac;</a>
<a name="ln1505"> </a>
<a name="ln1506">#ifndef SRIF_PLL</a>
<a name="ln1507">	u_int32_t pll2_clkmode;</a>
<a name="ln1508">#endif</a>
<a name="ln1509"> </a>
<a name="ln1510">#ifdef SRIF_PLL</a>
<a name="ln1511">        u_int32_t refdiv;</a>
<a name="ln1512">#endif</a>
<a name="ln1513">        if (clk_25mhz) {</a>
<a name="ln1514">#ifndef SRIF_PLL</a>
<a name="ln1515">            pll2_divint = 0x1c;</a>
<a name="ln1516">            pll2_divfrac = 0xa3d7;</a>
<a name="ln1517">#else</a>
<a name="ln1518">            if (AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln1519">                pll2_divint = 0x1c;</a>
<a name="ln1520">                pll2_divfrac = 0xa3d2;</a>
<a name="ln1521">                refdiv = 1;</a>
<a name="ln1522">            } else {</a>
<a name="ln1523">                pll2_divint = 0x54;</a>
<a name="ln1524">                pll2_divfrac = 0x1eb85;</a>
<a name="ln1525">                refdiv = 3;</a>
<a name="ln1526">            }</a>
<a name="ln1527">#endif</a>
<a name="ln1528">        } else {</a>
<a name="ln1529">#ifndef SRIF_PLL</a>
<a name="ln1530">            pll2_divint = 0x11;</a>
<a name="ln1531">            pll2_divfrac = 0x26666;</a>
<a name="ln1532">#else</a>
<a name="ln1533">            if (AR_SREV_WASP(ah)) {</a>
<a name="ln1534">                pll2_divint = 88;</a>
<a name="ln1535">                pll2_divfrac = 0;</a>
<a name="ln1536">                refdiv = 5;</a>
<a name="ln1537">            } else {</a>
<a name="ln1538">                pll2_divint = 0x11;</a>
<a name="ln1539">                pll2_divfrac = 0x26666;</a>
<a name="ln1540">                refdiv = 1;</a>
<a name="ln1541">            }</a>
<a name="ln1542">#endif</a>
<a name="ln1543">        }</a>
<a name="ln1544">#ifndef SRIF_PLL</a>
<a name="ln1545">        pll2_clkmode = 0x3d;</a>
<a name="ln1546">#endif</a>
<a name="ln1547">        /* PLL programming through SRIF Local Mode */</a>
<a name="ln1548">        OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL, 0x1142c); /* Bypass mode */</a>
<a name="ln1549">        OS_DELAY(1000);</a>
<a name="ln1550">        do {</a>
<a name="ln1551">            regdata = OS_REG_READ(ah, AR_PHY_PLL_MODE);</a>
<a name="ln1552">            if (AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln1553">                regdata = regdata | (0x1 &lt;&lt; 22);</a>
<a name="ln1554">            } else {</a>
<a name="ln1555">                regdata = regdata | (0x1 &lt;&lt; 16);</a>
<a name="ln1556">            }</a>
<a name="ln1557">            OS_REG_WRITE(ah, AR_PHY_PLL_MODE, regdata); /* PWD_PLL set to 1 */</a>
<a name="ln1558">            OS_DELAY(100);</a>
<a name="ln1559">            /* override int, frac, refdiv */</a>
<a name="ln1560">#ifndef SRIF_PLL</a>
<a name="ln1561">            OS_REG_WRITE(ah, AR_PHY_PLL_CONTROL,</a>
<a name="ln1562">                ((1 &lt;&lt; 27) | (pll2_divint &lt;&lt; 18) | pll2_divfrac));</a>
<a name="ln1563">#else</a>
<a name="ln1564">            OS_REG_WRITE(ah, AR_PHY_PLL_CONTROL,</a>
<a name="ln1565">                ((refdiv &lt;&lt; 27) | (pll2_divint &lt;&lt; 18) | pll2_divfrac));</a>
<a name="ln1566">#endif</a>
<a name="ln1567">            OS_DELAY(100);</a>
<a name="ln1568">            regdata = OS_REG_READ(ah, AR_PHY_PLL_MODE);</a>
<a name="ln1569">#ifndef SRIF_PLL</a>
<a name="ln1570">            regdata = (regdata &amp; 0x80071fff) |</a>
<a name="ln1571">                (0x1 &lt;&lt; 30) | (0x1 &lt;&lt; 13) | (0x6 &lt;&lt; 26) | (pll2_clkmode &lt;&lt; 19);</a>
<a name="ln1572">#else</a>
<a name="ln1573">            if (AR_SREV_WASP(ah)) {</a>
<a name="ln1574">                regdata = (regdata &amp; 0x80071fff) |</a>
<a name="ln1575">                    (0x1 &lt;&lt; 30) | (0x1 &lt;&lt; 13) | (0x4 &lt;&lt; 26) | (0x18 &lt;&lt; 19);</a>
<a name="ln1576">            } else if (AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln1577">                /*</a>
<a name="ln1578">                 * Kd=10, Ki=2, Outdiv=1, Local PLL=0, Phase Shift=4 </a>
<a name="ln1579">                 */</a>
<a name="ln1580">                regdata = (regdata &amp; 0x01c00fff) |</a>
<a name="ln1581">                    (0x1 &lt;&lt; 31) | (0x2 &lt;&lt; 29) | (0xa &lt;&lt; 25) | (0x1 &lt;&lt; 19) | (0x6 &lt;&lt; 12);</a>
<a name="ln1582">            } else {</a>
<a name="ln1583">                regdata = (regdata &amp; 0x80071fff) |</a>
<a name="ln1584">                    (0x3 &lt;&lt; 30) | (0x1 &lt;&lt; 13) | (0x4 &lt;&lt; 26) | (0x60 &lt;&lt; 19);</a>
<a name="ln1585">            }</a>
<a name="ln1586">#endif</a>
<a name="ln1587">            /* Ki, Kd, Local PLL, Outdiv */</a>
<a name="ln1588">            OS_REG_WRITE(ah, AR_PHY_PLL_MODE, regdata);</a>
<a name="ln1589">            regdata = OS_REG_READ(ah, AR_PHY_PLL_MODE);</a>
<a name="ln1590">            if (AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln1591">                regdata = (regdata &amp; 0xffbfffff);</a>
<a name="ln1592">            } else {</a>
<a name="ln1593">                regdata = (regdata &amp; 0xfffeffff);</a>
<a name="ln1594">            }</a>
<a name="ln1595">            OS_REG_WRITE(ah, AR_PHY_PLL_MODE, regdata); /* PWD_PLL set to 0 */</a>
<a name="ln1596">            OS_DELAY(1000);</a>
<a name="ln1597">            if (AR_SREV_WASP(ah)) {</a>
<a name="ln1598">                /* clear do measure */</a>
<a name="ln1599">                regdata = OS_REG_READ(ah, AR_PHY_PLL_BB_DPLL3);</a>
<a name="ln1600">                regdata &amp;= ~(1 &lt;&lt; 30);</a>
<a name="ln1601">                OS_REG_WRITE(ah, AR_PHY_PLL_BB_DPLL3, regdata);</a>
<a name="ln1602">                OS_DELAY(100);</a>
<a name="ln1603">            </a>
<a name="ln1604">                /* set do measure */</a>
<a name="ln1605">                regdata = OS_REG_READ(ah, AR_PHY_PLL_BB_DPLL3);</a>
<a name="ln1606">                regdata |= (1 &lt;&lt; 30);</a>
<a name="ln1607">                OS_REG_WRITE(ah, AR_PHY_PLL_BB_DPLL3, regdata);</a>
<a name="ln1608">            </a>
<a name="ln1609">                /* wait for measure done */</a>
<a name="ln1610">                do {</a>
<a name="ln1611">                    regdata = OS_REG_READ(ah, AR_PHY_PLL_BB_DPLL4);</a>
<a name="ln1612">                } while ((regdata &amp; (1 &lt;&lt; 3)) == 0);</a>
<a name="ln1613">            </a>
<a name="ln1614">                /* clear do measure */</a>
<a name="ln1615">                regdata = OS_REG_READ(ah, AR_PHY_PLL_BB_DPLL3);</a>
<a name="ln1616">                regdata &amp;= ~(1 &lt;&lt; 30);</a>
<a name="ln1617">                OS_REG_WRITE(ah, AR_PHY_PLL_BB_DPLL3, regdata);</a>
<a name="ln1618">            </a>
<a name="ln1619">                /* get measure sqsum dvc */</a>
<a name="ln1620">                regdata = (OS_REG_READ(ah, AR_PHY_PLL_BB_DPLL3) &amp; 0x007FFFF8) &gt;&gt; 3;</a>
<a name="ln1621">            } else {</a>
<a name="ln1622">                break;</a>
<a name="ln1623">            }</a>
<a name="ln1624">        } while (regdata &gt;= 0x40000);</a>
<a name="ln1625"> </a>
<a name="ln1626">        /* Remove from Bypass mode */</a>
<a name="ln1627">        OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL, 0x142c);</a>
<a name="ln1628">        OS_DELAY(1000);</a>
<a name="ln1629">    } else {</a>
<a name="ln1630">        pll = SM(0x5, AR_RTC_PLL_REFDIV);</a>
<a name="ln1631">  </a>
<a name="ln1632">        /* Supposedly not needed on Osprey */</a>
<a name="ln1633">#if 0</a>
<a name="ln1634">        if (chan &amp;&amp; IS_CHAN_HALF_RATE(chan)) {</a>
<a name="ln1635">            pll |= SM(0x1, AR_RTC_PLL_CLKSEL);</a>
<a name="ln1636">        } else if (chan &amp;&amp; IS_CHAN_QUARTER_RATE(chan)) {</a>
<a name="ln1637">            pll |= SM(0x2, AR_RTC_PLL_CLKSEL);</a>
<a name="ln1638">        }</a>
<a name="ln1639">#endif</a>
<a name="ln1640">        if (ichan &amp;&amp; IS_CHAN_5GHZ(ichan)) {</a>
<a name="ln1641">            pll |= SM(0x28, AR_RTC_PLL_DIV);</a>
<a name="ln1642">            /* </a>
<a name="ln1643">             * When doing fast clock, set PLL to 0x142c</a>
<a name="ln1644">             */</a>
<a name="ln1645">            if (IS_5GHZ_FAST_CLOCK_EN(ah, chan)) {</a>
<a name="ln1646">                pll = 0x142c;</a>
<a name="ln1647">            }</a>
<a name="ln1648">        } else {</a>
<a name="ln1649">            pll |= SM(0x2c, AR_RTC_PLL_DIV);</a>
<a name="ln1650">        }</a>
<a name="ln1651"> </a>
<a name="ln1652">        OS_REG_WRITE(ah, AR_RTC_PLL_CONTROL, pll);</a>
<a name="ln1653">    }</a>
<a name="ln1654"> </a>
<a name="ln1655">    /* TODO:</a>
<a name="ln1656">     * For multi-band owl, switch between bands by reiniting the PLL.</a>
<a name="ln1657">     */</a>
<a name="ln1658">    OS_DELAY(RTC_PLL_SETTLE_DELAY);</a>
<a name="ln1659"> </a>
<a name="ln1660">    OS_REG_WRITE(ah, AR_RTC_SLEEP_CLK,</a>
<a name="ln1661">        AR_RTC_FORCE_DERIVED_CLK | AR_RTC_PCIE_RST_PWDN_EN);</a>
<a name="ln1662"> </a>
<a name="ln1663">    /* XXX TODO: honeybee? */</a>
<a name="ln1664">    if (AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah)) {</a>
<a name="ln1665">        if (clk_25mhz) {</a>
<a name="ln1666">            OS_REG_WRITE(ah,</a>
<a name="ln1667">                AR_RTC_DERIVED_RTC_CLK, (0x17c &lt;&lt; 1)); /* 32KHz sleep clk */</a>
<a name="ln1668">            OS_REG_WRITE(ah, AR_SLP32_MODE, 0x0010f3d7);</a>
<a name="ln1669">            OS_REG_WRITE(ah, AR_SLP32_INC, 0x0001e7ae);</a>
<a name="ln1670">        } else {</a>
<a name="ln1671">            OS_REG_WRITE(ah,</a>
<a name="ln1672">                AR_RTC_DERIVED_RTC_CLK, (0x261 &lt;&lt; 1)); /* 32KHz sleep clk */</a>
<a name="ln1673">            OS_REG_WRITE(ah, AR_SLP32_MODE, 0x0010f400);</a>
<a name="ln1674">            OS_REG_WRITE(ah, AR_SLP32_INC, 0x0001e800);</a>
<a name="ln1675">        }</a>
<a name="ln1676">        OS_DELAY(100);</a>
<a name="ln1677">    }</a>
<a name="ln1678">}</a>
<a name="ln1679"> </a>
<a name="ln1680">static inline HAL_BOOL</a>
<a name="ln1681">ar9300_set_reset(struct ath_hal *ah, int type)</a>
<a name="ln1682">{</a>
<a name="ln1683">    u_int32_t rst_flags;</a>
<a name="ln1684">    u_int32_t tmp_reg;</a>
<a name="ln1685">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1686"> </a>
<a name="ln1687">    HALASSERT(type == HAL_RESET_WARM || type == HAL_RESET_COLD);</a>
<a name="ln1688"> </a>
<a name="ln1689">    /*</a>
<a name="ln1690">     * RTC Force wake should be done before resetting the MAC.</a>
<a name="ln1691">     * MDK/ART does it that way.</a>
<a name="ln1692">     */</a>
<a name="ln1693">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_WA), AH9300(ah)-&gt;ah_wa_reg_val);</a>
<a name="ln1694">    OS_DELAY(10); /* delay to allow AR_WA reg write to kick in */</a>
<a name="ln1695">    OS_REG_WRITE(ah,</a>
<a name="ln1696">        AR_RTC_FORCE_WAKE, AR_RTC_FORCE_WAKE_EN | AR_RTC_FORCE_WAKE_ON_INT);</a>
<a name="ln1697"> </a>
<a name="ln1698">    /* Reset AHB */</a>
<a name="ln1699">    /* Bug26871 */</a>
<a name="ln1700">    tmp_reg = OS_REG_READ(ah, AR_HOSTIF_REG(ah, AR_INTR_SYNC_CAUSE));</a>
<a name="ln1701">    if (AR_SREV_WASP(ah)) {</a>
<a name="ln1702">        if (tmp_reg &amp; (AR9340_INTR_SYNC_LOCAL_TIMEOUT)) {</a>
<a name="ln1703">            OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_INTR_SYNC_ENABLE), 0);</a>
<a name="ln1704">            OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_RC), AR_RC_HOSTIF);</a>
<a name="ln1705">        }</a>
<a name="ln1706">    } else {</a>
<a name="ln1707">        if (tmp_reg &amp; (AR9300_INTR_SYNC_LOCAL_TIMEOUT | AR9300_INTR_SYNC_RADM_CPL_TIMEOUT)) {</a>
<a name="ln1708">            OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_INTR_SYNC_ENABLE), 0);</a>
<a name="ln1709">            OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_RC), AR_RC_HOSTIF);</a>
<a name="ln1710">        }</a>
<a name="ln1711">        else {</a>
<a name="ln1712">            /* NO AR_RC_AHB in Osprey */</a>
<a name="ln1713">            /*OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_RC), AR_RC_AHB);*/</a>
<a name="ln1714">        }</a>
<a name="ln1715">    }</a>
<a name="ln1716">    </a>
<a name="ln1717">    rst_flags = AR_RTC_RC_MAC_WARM;</a>
<a name="ln1718">    if (type == HAL_RESET_COLD) {</a>
<a name="ln1719">        rst_flags |= AR_RTC_RC_MAC_COLD;</a>
<a name="ln1720">    }</a>
<a name="ln1721"> </a>
<a name="ln1722">#ifdef AH_SUPPORT_HORNET</a>
<a name="ln1723">    /* Hornet WAR: trigger SoC to reset WMAC if ...</a>
<a name="ln1724">     * (1) doing cold reset. Ref: EV 69254 </a>
<a name="ln1725">     * (2) beacon pending. Ref: EV 70983</a>
<a name="ln1726">     */</a>
<a name="ln1727">    if (AR_SREV_HORNET(ah) &amp;&amp;</a>
<a name="ln1728">        (ar9300_num_tx_pending(</a>
<a name="ln1729">            ah, AH_PRIVATE(ah)-&gt;ah_caps.halTotalQueues - 1) != 0 ||</a>
<a name="ln1730">         type == HAL_RESET_COLD))</a>
<a name="ln1731">    {</a>
<a name="ln1732">        u_int32_t time_out;</a>
<a name="ln1733">#define AR_SOC_RST_RESET         0xB806001C</a>
<a name="ln1734">#define AR_SOC_BOOT_STRAP        0xB80600AC</a>
<a name="ln1735">#define AR_SOC_WLAN_RST          0x00000800 /* WLAN reset */</a>
<a name="ln1736">#define REG_WRITE(_reg, _val)    *((volatile u_int32_t *)(_reg)) = (_val);</a>
<a name="ln1737">#define REG_READ(_reg)           *((volatile u_int32_t *)(_reg))</a>
<a name="ln1738">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: Hornet SoC reset WMAC.\n&quot;, __func__);</a>
<a name="ln1739"> </a>
<a name="ln1740">        REG_WRITE(AR_SOC_RST_RESET,</a>
<a name="ln1741">            REG_READ(AR_SOC_RST_RESET) | AR_SOC_WLAN_RST);</a>
<a name="ln1742">        REG_WRITE(AR_SOC_RST_RESET,</a>
<a name="ln1743">            REG_READ(AR_SOC_RST_RESET) &amp; (~AR_SOC_WLAN_RST));</a>
<a name="ln1744"> </a>
<a name="ln1745">        time_out = 0;</a>
<a name="ln1746"> </a>
<a name="ln1747">        while (1) {</a>
<a name="ln1748">            tmp_reg = REG_READ(AR_SOC_BOOT_STRAP);</a>
<a name="ln1749">            if ((tmp_reg &amp; 0x10) == 0) {</a>
<a name="ln1750">                break;</a>
<a name="ln1751">            }</a>
<a name="ln1752">            if (time_out &gt; 20) {</a>
<a name="ln1753">                break;</a>
<a name="ln1754">            }</a>
<a name="ln1755">            OS_DELAY(10000);</a>
<a name="ln1756">            time_out++;</a>
<a name="ln1757">        }</a>
<a name="ln1758"> </a>
<a name="ln1759">        OS_REG_WRITE(ah, AR_RTC_RESET, 1);</a>
<a name="ln1760">#undef REG_READ</a>
<a name="ln1761">#undef REG_WRITE</a>
<a name="ln1762">#undef AR_SOC_WLAN_RST</a>
<a name="ln1763">#undef AR_SOC_RST_RESET</a>
<a name="ln1764">#undef AR_SOC_BOOT_STRAP</a>
<a name="ln1765">    }</a>
<a name="ln1766">#endif /* AH_SUPPORT_HORNET */</a>
<a name="ln1767"> </a>
<a name="ln1768">#ifdef AH_SUPPORT_SCORPION</a>
<a name="ln1769">    if (AR_SREV_SCORPION(ah)) {</a>
<a name="ln1770">#define DDR_CTL_CONFIG_ADDRESS                                       0xb8000000</a>
<a name="ln1771">#define DDR_CTL_CONFIG_OFFSET                                        0x0108</a>
<a name="ln1772">#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MSB                           29</a>
<a name="ln1773">#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB                           21</a>
<a name="ln1774">#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK                          0x3fe00000</a>
<a name="ln1775">#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(x)                        (((x) &amp; DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK) &gt;&gt; DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB)</a>
<a name="ln1776">#define DDR_CTL_CONFIG_CLIENT_ACTIVITY_SET(x)                        (((x) &lt;&lt; DDR_CTL_CONFIG_CLIENT_ACTIVITY_LSB) &amp; DDR_CTL_CONFIG_CLIENT_ACTIVITY_MASK)</a>
<a name="ln1777">#define MAC_DMA_CFG_ADDRESS                                          0xb8100000</a>
<a name="ln1778">#define MAC_DMA_CFG_OFFSET                                           0x0014</a>
<a name="ln1779"> </a>
<a name="ln1780">#define MAC_DMA_CFG_HALT_REQ_MSB                                     11</a>
<a name="ln1781">#define MAC_DMA_CFG_HALT_REQ_LSB                                     11</a>
<a name="ln1782">#define MAC_DMA_CFG_HALT_REQ_MASK                                    0x00000800</a>
<a name="ln1783">#define MAC_DMA_CFG_HALT_REQ_GET(x)                                  (((x) &amp; MAC_DMA_CFG_HALT_REQ_MASK) &gt;&gt; MAC_DMA_CFG_HALT_REQ_LSB)</a>
<a name="ln1784">#define MAC_DMA_CFG_HALT_REQ_SET(x)                                  (((x) &lt;&lt; MAC_DMA_CFG_HALT_REQ_LSB) &amp; MAC_DMA_CFG_HALT_REQ_MASK)</a>
<a name="ln1785">#define MAC_DMA_CFG_HALT_ACK_MSB                                     12</a>
<a name="ln1786">#define MAC_DMA_CFG_HALT_ACK_LSB                                     12</a>
<a name="ln1787">#define MAC_DMA_CFG_HALT_ACK_MASK                                    0x00001000</a>
<a name="ln1788">#define MAC_DMA_CFG_HALT_ACK_GET(x)                                  (((x) &amp; MAC_DMA_CFG_HALT_ACK_MASK) &gt;&gt; MAC_DMA_CFG_HALT_ACK_LSB)</a>
<a name="ln1789">#define MAC_DMA_CFG_HALT_ACK_SET(x)                                  (((x) &lt;&lt; MAC_DMA_CFG_HALT_ACK_LSB) &amp; MAC_DMA_CFG_HALT_ACK_MASK)</a>
<a name="ln1790"> </a>
<a name="ln1791">#define RST_RESET                                                    0xB806001c</a>
<a name="ln1792">#define RTC_RESET                                                    (1&lt;&lt;27)</a>
<a name="ln1793"> </a>
<a name="ln1794">#define REG_READ(_reg)          *((volatile u_int32_t *)(_reg))</a>
<a name="ln1795">#define REG_WRITE(_reg, _val)   *((volatile u_int32_t *)(_reg)) = (_val);</a>
<a name="ln1796"> </a>
<a name="ln1797">#define DDR_REG_READ(_ah, _reg) \</a>
<a name="ln1798">	    *((volatile u_int32_t *)( DDR_CTL_CONFIG_ADDRESS + (_reg)))</a>
<a name="ln1799">#define DDR_REG_WRITE(_ah, _reg, _val) \</a>
<a name="ln1800">	    *((volatile u_int32_t *)(DDR_CTL_CONFIG_ADDRESS + (_reg))) = (_val)</a>
<a name="ln1801"> </a>
<a name="ln1802">	    OS_REG_WRITE(ah,MAC_DMA_CFG_OFFSET, (OS_REG_READ(ah,MAC_DMA_CFG_OFFSET) &amp; ~MAC_DMA_CFG_HALT_REQ_MASK) |</a>
<a name="ln1803">			    MAC_DMA_CFG_HALT_REQ_SET(1));</a>
<a name="ln1804"> </a>
<a name="ln1805">	    {</a>
<a name="ln1806">		    int count;</a>
<a name="ln1807">            u_int32_t data;</a>
<a name="ln1808"> </a>
<a name="ln1809">		    count = 0;</a>
<a name="ln1810">		    while (!MAC_DMA_CFG_HALT_ACK_GET(OS_REG_READ(ah, MAC_DMA_CFG_OFFSET) ))</a>
<a name="ln1811">		    {</a>
<a name="ln1812">			    count++;</a>
<a name="ln1813">			    if (count &gt; 10) {</a>
<a name="ln1814">				    ath_hal_printf(ah, &quot;Halt ACK timeout\n&quot;);</a>
<a name="ln1815">				    break;</a>
<a name="ln1816">			    }</a>
<a name="ln1817">			    OS_DELAY(10);</a>
<a name="ln1818">		    }</a>
<a name="ln1819"> </a>
<a name="ln1820">		    data = DDR_REG_READ(ah,DDR_CTL_CONFIG_OFFSET);</a>
<a name="ln1821">		    HALDEBUG(ah, HAL_DEBUG_RESET, &quot;check DDR Activity - HIGH\n&quot;);</a>
<a name="ln1822"> </a>
<a name="ln1823">		    count = 0;</a>
<a name="ln1824">		    while (DDR_CTL_CONFIG_CLIENT_ACTIVITY_GET(data)) {</a>
<a name="ln1825">			    //      AVE_DEBUG(0,&quot;DDR Activity - HIGH\n&quot;);</a>
<a name="ln1826">			    HALDEBUG(ah, HAL_DEBUG_RESET, &quot;DDR Activity - HIGH\n&quot;);</a>
<a name="ln1827">			    count++;</a>
<a name="ln1828">			    OS_DELAY(10);</a>
<a name="ln1829">			    data = DDR_REG_READ(ah,DDR_CTL_CONFIG_OFFSET);</a>
<a name="ln1830">			    if (count &gt; 10) {</a>
<a name="ln1831">				    ath_hal_printf(ah, &quot;DDR Activity timeout\n&quot;);</a>
<a name="ln1832">				    break;</a>
<a name="ln1833">			    }</a>
<a name="ln1834">		    }</a>
<a name="ln1835">	    }</a>
<a name="ln1836"> </a>
<a name="ln1837"> </a>
<a name="ln1838">	    {</a>
<a name="ln1839">		    //Force RTC reset</a>
<a name="ln1840">		    REG_WRITE(RST_RESET, (REG_READ(RST_RESET) | RTC_RESET));</a>
<a name="ln1841">		    OS_DELAY(10);</a>
<a name="ln1842">		    REG_WRITE(RST_RESET, (REG_READ(RST_RESET) &amp; ~RTC_RESET));</a>
<a name="ln1843">		    OS_DELAY(10);</a>
<a name="ln1844">		    OS_REG_WRITE(ah, AR_RTC_RESET, 0);</a>
<a name="ln1845">		    OS_DELAY(10);</a>
<a name="ln1846">		    OS_REG_WRITE(ah, AR_RTC_RESET, 1);</a>
<a name="ln1847">		    OS_DELAY(10);</a>
<a name="ln1848">		    HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: Scorpion SoC RTC reset done.\n&quot;, __func__);</a>
<a name="ln1849">	    }</a>
<a name="ln1850">#undef REG_READ</a>
<a name="ln1851">#undef REG_WRITE</a>
<a name="ln1852">    }</a>
<a name="ln1853">#endif  /* AH_SUPPORT_SCORPION */</a>
<a name="ln1854"> </a>
<a name="ln1855">    /*</a>
<a name="ln1856">     * Set Mac(BB,Phy) Warm Reset</a>
<a name="ln1857">     */</a>
<a name="ln1858">    OS_REG_WRITE(ah, AR_RTC_RC, rst_flags);</a>
<a name="ln1859"> </a>
<a name="ln1860">    OS_DELAY(50); /* XXX 50 usec */</a>
<a name="ln1861"> </a>
<a name="ln1862">    /*</a>
<a name="ln1863">     * Clear resets and force wakeup</a>
<a name="ln1864">     */</a>
<a name="ln1865">    OS_REG_WRITE(ah, AR_RTC_RC, 0);</a>
<a name="ln1866">    if (!ath_hal_wait(ah, AR_RTC_RC, AR_RTC_RC_M, 0)) {</a>
<a name="ln1867">        HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln1868">            &quot;%s: RTC stuck in MAC reset\n&quot;, __FUNCTION__);</a>
<a name="ln1869">        HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln1870">            &quot;%s: AR_RTC_RC = 0x%x\n&quot;, __func__, OS_REG_READ(ah, AR_RTC_RC));</a>
<a name="ln1871">        return AH_FALSE;</a>
<a name="ln1872">    }</a>
<a name="ln1873"> </a>
<a name="ln1874">    /* Clear AHB reset */</a>
<a name="ln1875">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_RC), 0);</a>
<a name="ln1876">    ar9300_disable_pll_lock_detect(ah);</a>
<a name="ln1877"> </a>
<a name="ln1878">    ar9300_attach_hw_platform(ah);</a>
<a name="ln1879"> </a>
<a name="ln1880">    ahp-&gt;ah_chip_reset_done = 1;</a>
<a name="ln1881">    return AH_TRUE;</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884">static inline HAL_BOOL</a>
<a name="ln1885">ar9300_set_reset_power_on(struct ath_hal *ah)</a>
<a name="ln1886">{</a>
<a name="ln1887">    /* Force wake */</a>
<a name="ln1888">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_WA), AH9300(ah)-&gt;ah_wa_reg_val);</a>
<a name="ln1889">    OS_DELAY(10); /* delay to allow AR_WA reg write to kick in */</a>
<a name="ln1890">    OS_REG_WRITE(ah, AR_RTC_FORCE_WAKE,</a>
<a name="ln1891">        AR_RTC_FORCE_WAKE_EN | AR_RTC_FORCE_WAKE_ON_INT);</a>
<a name="ln1892">    /*</a>
<a name="ln1893">     * RTC reset and clear. Some delay in between is needed </a>
<a name="ln1894">     * to give the chip time to settle.</a>
<a name="ln1895">     */</a>
<a name="ln1896">    OS_REG_WRITE(ah, AR_RTC_RESET, 0);</a>
<a name="ln1897">    OS_DELAY(2);</a>
<a name="ln1898">    OS_REG_WRITE(ah, AR_RTC_RESET, 1);</a>
<a name="ln1899"> </a>
<a name="ln1900">    /*</a>
<a name="ln1901">     * Poll till RTC is ON</a>
<a name="ln1902">     */</a>
<a name="ln1903">    if (!ath_hal_wait(ah,</a>
<a name="ln1904">             AR_RTC_STATUS, AR_RTC_STATUS_M,</a>
<a name="ln1905">             AR_RTC_STATUS_ON))</a>
<a name="ln1906">    {</a>
<a name="ln1907">        HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln1908">            &quot;%s: RTC not waking up for %d\n&quot;, __FUNCTION__, 1000);</a>
<a name="ln1909">        return AH_FALSE;</a>
<a name="ln1910">    }</a>
<a name="ln1911"> </a>
<a name="ln1912">    /*</a>
<a name="ln1913">     * Read Revisions from Chip right after RTC is on for the first time.</a>
<a name="ln1914">     * This helps us detect the chip type early and initialize it accordingly.</a>
<a name="ln1915">     */</a>
<a name="ln1916">    ar9300_read_revisions(ah);</a>
<a name="ln1917"> </a>
<a name="ln1918">    /*</a>
<a name="ln1919">     * Warm reset if we aren't really powering on,</a>
<a name="ln1920">     * just restarting the driver.</a>
<a name="ln1921">     */</a>
<a name="ln1922">    return ar9300_set_reset(ah, HAL_RESET_WARM);</a>
<a name="ln1923">}</a>
<a name="ln1924"> </a>
<a name="ln1925">/*</a>
<a name="ln1926"> * Write the given reset bit mask into the reset register</a>
<a name="ln1927"> */</a>
<a name="ln1928">HAL_BOOL</a>
<a name="ln1929">ar9300_set_reset_reg(struct ath_hal *ah, u_int32_t type)</a>
<a name="ln1930">{</a>
<a name="ln1931">    HAL_BOOL ret = AH_FALSE;</a>
<a name="ln1932"> </a>
<a name="ln1933">    /*</a>
<a name="ln1934">     * Set force wake</a>
<a name="ln1935">     */</a>
<a name="ln1936">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_WA), AH9300(ah)-&gt;ah_wa_reg_val);</a>
<a name="ln1937">    OS_DELAY(10); /* delay to allow AR_WA reg write to kick in */</a>
<a name="ln1938">    OS_REG_WRITE(ah, AR_RTC_FORCE_WAKE,</a>
<a name="ln1939">        AR_RTC_FORCE_WAKE_EN | AR_RTC_FORCE_WAKE_ON_INT);</a>
<a name="ln1940"> </a>
<a name="ln1941">    switch (type) {</a>
<a name="ln1942">    case HAL_RESET_POWER_ON:</a>
<a name="ln1943">        ret = ar9300_set_reset_power_on(ah);</a>
<a name="ln1944">        break;</a>
<a name="ln1945">    case HAL_RESET_WARM:</a>
<a name="ln1946">    case HAL_RESET_COLD:</a>
<a name="ln1947">        ret = ar9300_set_reset(ah, type);</a>
<a name="ln1948">        break;</a>
<a name="ln1949">    default:</a>
<a name="ln1950">        break;</a>
<a name="ln1951">    }</a>
<a name="ln1952">    </a>
<a name="ln1953">#if ATH_SUPPORT_MCI</a>
<a name="ln1954">    if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport) {</a>
<a name="ln1955">        OS_REG_WRITE(ah, AR_RTC_KEEP_AWAKE, 0x2);</a>
<a name="ln1956">    }</a>
<a name="ln1957">#endif</a>
<a name="ln1958"> </a>
<a name="ln1959">    return ret;</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">/*</a>
<a name="ln1963"> * Places the PHY and Radio chips into reset.  A full reset</a>
<a name="ln1964"> * must be called to leave this state.  The PCI/MAC/PCU are</a>
<a name="ln1965"> * not placed into reset as we must receive interrupt to</a>
<a name="ln1966"> * re-enable the hardware.</a>
<a name="ln1967"> */</a>
<a name="ln1968">HAL_BOOL</a>
<a name="ln1969">ar9300_phy_disable(struct ath_hal *ah)</a>
<a name="ln1970">{</a>
<a name="ln1971">    if (!ar9300_set_reset_reg(ah, HAL_RESET_WARM)) {</a>
<a name="ln1972">        return AH_FALSE;</a>
<a name="ln1973">    }</a>
<a name="ln1974"> </a>
<a name="ln1975">#ifdef ATH_SUPPORT_LED</a>
<a name="ln1976">#define REG_READ(_reg)          *((volatile u_int32_t *)(_reg))</a>
<a name="ln1977">#define REG_WRITE(_reg, _val)   *((volatile u_int32_t *)(_reg)) = (_val);</a>
<a name="ln1978">#define ATH_GPIO_OE             0xB8040000</a>
<a name="ln1979">#define ATH_GPIO_OUT            0xB8040008 /* GPIO Ouput Value reg.*/</a>
<a name="ln1980">    if (AR_SREV_WASP(ah)) {</a>
<a name="ln1981">        if (IS_CHAN_2GHZ((AH_PRIVATE(ah)-&gt;ah_curchan))) {</a>
<a name="ln1982">            REG_WRITE(ATH_GPIO_OE, (REG_READ(ATH_GPIO_OE) | (0x1 &lt;&lt; 13)));</a>
<a name="ln1983">        }</a>
<a name="ln1984">        else { </a>
<a name="ln1985">            REG_WRITE(ATH_GPIO_OE, (REG_READ(ATH_GPIO_OE) | (0x1 &lt;&lt; 12)));</a>
<a name="ln1986">        }</a>
<a name="ln1987">    }</a>
<a name="ln1988">    else if (AR_SREV_SCORPION(ah)) {</a>
<a name="ln1989">        if (IS_CHAN_2GHZ((AH_PRIVATE(ah)-&gt;ah_curchan))) {</a>
<a name="ln1990">            REG_WRITE(ATH_GPIO_OE, (REG_READ(ATH_GPIO_OE) | (0x1 &lt;&lt; 13)));</a>
<a name="ln1991">        }</a>
<a name="ln1992">        else {</a>
<a name="ln1993">            REG_WRITE(ATH_GPIO_OE, (REG_READ(ATH_GPIO_OE) | (0x1 &lt;&lt; 12)));</a>
<a name="ln1994">        }</a>
<a name="ln1995">        /* Turn off JMPST led */</a>
<a name="ln1996">        REG_WRITE(ATH_GPIO_OUT, (REG_READ(ATH_GPIO_OUT) | (0x1 &lt;&lt; 15)));</a>
<a name="ln1997">    }</a>
<a name="ln1998">    else if (AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln1999">        REG_WRITE(ATH_GPIO_OE, (REG_READ(ATH_GPIO_OE) | (0x1 &lt;&lt; 12)));</a>
<a name="ln2000">    }</a>
<a name="ln2001">#undef REG_READ</a>
<a name="ln2002">#undef REG_WRITE</a>
<a name="ln2003">#endif</a>
<a name="ln2004"> </a>
<a name="ln2005">    if ( AR_SREV_OSPREY(ah) ) { </a>
<a name="ln2006">        OS_REG_RMW(ah, AR_HOSTIF_REG(ah, AR_GPIO_OUTPUT_MUX1), 0x0, 0x1f);</a>
<a name="ln2007">    }</a>
<a name="ln2008"> </a>
<a name="ln2009"> </a>
<a name="ln2010">    ar9300_init_pll(ah, AH_NULL);</a>
<a name="ln2011">    ar9300_disable_pll_lock_detect(ah);</a>
<a name="ln2012"> </a>
<a name="ln2013">    return AH_TRUE;</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">/*</a>
<a name="ln2017"> * Places all of hardware into reset</a>
<a name="ln2018"> */</a>
<a name="ln2019">HAL_BOOL</a>
<a name="ln2020">ar9300_disable(struct ath_hal *ah)</a>
<a name="ln2021">{</a>
<a name="ln2022">    if (!ar9300_set_power_mode(ah, HAL_PM_AWAKE, AH_TRUE)) {</a>
<a name="ln2023">        return AH_FALSE;</a>
<a name="ln2024">    }</a>
<a name="ln2025">    if (!ar9300_set_reset_reg(ah, HAL_RESET_COLD)) {</a>
<a name="ln2026">        return AH_FALSE;</a>
<a name="ln2027">    }</a>
<a name="ln2028"> </a>
<a name="ln2029">    ar9300_init_pll(ah, AH_NULL);</a>
<a name="ln2030"> </a>
<a name="ln2031">    return AH_TRUE;</a>
<a name="ln2032">}</a>
<a name="ln2033"> </a>
<a name="ln2034">/*</a>
<a name="ln2035"> * TODO: Only write the PLL if we're changing to or from CCK mode</a>
<a name="ln2036"> *</a>
<a name="ln2037"> * WARNING: The order of the PLL and mode registers must be correct.</a>
<a name="ln2038"> */</a>
<a name="ln2039">static inline void</a>
<a name="ln2040">ar9300_set_rf_mode(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln2041">{</a>
<a name="ln2042">    u_int32_t rf_mode = 0;</a>
<a name="ln2043"> </a>
<a name="ln2044">    if (chan == AH_NULL) {</a>
<a name="ln2045">        return;</a>
<a name="ln2046">    }</a>
<a name="ln2047">    switch (AH9300(ah)-&gt;ah_hwp) {</a>
<a name="ln2048">    case HAL_TRUE_CHIP:</a>
<a name="ln2049">        rf_mode |= (IEEE80211_IS_CHAN_B(chan) || IEEE80211_IS_CHAN_G(chan)) ?</a>
<a name="ln2050">            AR_PHY_MODE_DYNAMIC : AR_PHY_MODE_OFDM;</a>
<a name="ln2051">        break;</a>
<a name="ln2052">    default:</a>
<a name="ln2053">        HALASSERT(0);</a>
<a name="ln2054">        break;</a>
<a name="ln2055">    }</a>
<a name="ln2056">    /*  Phy mode bits for 5GHz channels requiring Fast Clock */</a>
<a name="ln2057">    if ( IS_5GHZ_FAST_CLOCK_EN(ah, chan)) {</a>
<a name="ln2058">        rf_mode |= (AR_PHY_MODE_DYNAMIC | AR_PHY_MODE_DYN_CCK_DISABLE);</a>
<a name="ln2059">    }</a>
<a name="ln2060">    OS_REG_WRITE(ah, AR_PHY_MODE, rf_mode);</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063">/*</a>
<a name="ln2064"> * Places the hardware into reset and then pulls it out of reset</a>
<a name="ln2065"> */</a>
<a name="ln2066">HAL_BOOL</a>
<a name="ln2067">ar9300_chip_reset(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln2068">{</a>
<a name="ln2069">    struct ath_hal_9300     *ahp = AH9300(ah);</a>
<a name="ln2070">    int type = HAL_RESET_WARM;</a>
<a name="ln2071"> </a>
<a name="ln2072">    OS_MARK(ah, AH_MARK_CHIPRESET, chan ? chan-&gt;ic_freq : 0);</a>
<a name="ln2073"> </a>
<a name="ln2074">    /*</a>
<a name="ln2075">     * Warm reset is optimistic.</a>
<a name="ln2076">     *</a>
<a name="ln2077">     * If the TX/RX DMA engines aren't shut down (eg, they're</a>
<a name="ln2078">     * wedged) then we're better off doing a full cold reset</a>
<a name="ln2079">     * to try and shake that condition.</a>
<a name="ln2080">     */</a>
<a name="ln2081">    if (ahp-&gt;ah_chip_full_sleep ||</a>
<a name="ln2082">        (ah-&gt;ah_config.ah_force_full_reset == 1) ||</a>
<a name="ln2083">        OS_REG_READ(ah, AR_Q_TXE) ||</a>
<a name="ln2084">        (OS_REG_READ(ah, AR_CR) &amp; AR_CR_RXE)) {</a>
<a name="ln2085">            type = HAL_RESET_COLD;</a>
<a name="ln2086">    }</a>
<a name="ln2087"> </a>
<a name="ln2088">    if (!ar9300_set_reset_reg(ah, type)) {</a>
<a name="ln2089">        return AH_FALSE;</a>
<a name="ln2090">    }</a>
<a name="ln2091"> </a>
<a name="ln2092">    /* Bring out of sleep mode (AGAIN) */</a>
<a name="ln2093">    if (!ar9300_set_power_mode(ah, HAL_PM_AWAKE, AH_TRUE)) {</a>
<a name="ln2094">        return AH_FALSE;</a>
<a name="ln2095">    }</a>
<a name="ln2096"> </a>
<a name="ln2097">    ahp-&gt;ah_chip_full_sleep = AH_FALSE;</a>
<a name="ln2098"> </a>
<a name="ln2099">    if (AR_SREV_HORNET(ah)) {</a>
<a name="ln2100">        ar9300_internal_regulator_apply(ah);</a>
<a name="ln2101">    }</a>
<a name="ln2102"> </a>
<a name="ln2103">    ar9300_init_pll(ah, chan);</a>
<a name="ln2104"> </a>
<a name="ln2105">    /*</a>
<a name="ln2106">     * Perform warm reset before the mode/PLL/turbo registers</a>
<a name="ln2107">     * are changed in order to deactivate the radio.  Mode changes</a>
<a name="ln2108">     * with an active radio can result in corrupted shifts to the</a>
<a name="ln2109">     * radio device.</a>
<a name="ln2110">     */</a>
<a name="ln2111">    ar9300_set_rf_mode(ah, chan);</a>
<a name="ln2112"> </a>
<a name="ln2113">    return AH_TRUE;</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116">/* ar9300_setup_calibration</a>
<a name="ln2117"> * Setup HW to collect samples used for current cal</a>
<a name="ln2118"> */</a>
<a name="ln2119">inline static void</a>
<a name="ln2120">ar9300_setup_calibration(struct ath_hal *ah, HAL_CAL_LIST *curr_cal)</a>
<a name="ln2121">{</a>
<a name="ln2122">    /* Select calibration to run */</a>
<a name="ln2123">    switch (curr_cal-&gt;cal_data-&gt;cal_type) {</a>
<a name="ln2124">    case IQ_MISMATCH_CAL:</a>
<a name="ln2125">        /* Start calibration w/ 2^(INIT_IQCAL_LOG_COUNT_MAX+1) samples */</a>
<a name="ln2126">        OS_REG_RMW_FIELD(ah, AR_PHY_TIMING4,</a>
<a name="ln2127">            AR_PHY_TIMING4_IQCAL_LOG_COUNT_MAX,</a>
<a name="ln2128">            curr_cal-&gt;cal_data-&gt;cal_count_max);</a>
<a name="ln2129">        OS_REG_WRITE(ah, AR_PHY_CALMODE, AR_PHY_CALMODE_IQ);</a>
<a name="ln2130"> </a>
<a name="ln2131">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2132">            &quot;%s: starting IQ Mismatch Calibration\n&quot;, __func__);</a>
<a name="ln2133"> </a>
<a name="ln2134">        /* Kick-off cal */</a>
<a name="ln2135">        OS_REG_SET_BIT(ah, AR_PHY_TIMING4, AR_PHY_TIMING4_DO_CAL);</a>
<a name="ln2136"> </a>
<a name="ln2137">        break;</a>
<a name="ln2138">    case TEMP_COMP_CAL:</a>
<a name="ln2139">        if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) ||</a>
<a name="ln2140">            AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah)) {</a>
<a name="ln2141">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2142">                AR_HORNET_CH0_THERM, AR_PHY_65NM_CH0_THERM_LOCAL, 1);</a>
<a name="ln2143">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2144">                AR_HORNET_CH0_THERM, AR_PHY_65NM_CH0_THERM_START, 1);</a>
<a name="ln2145">        } else if (AR_SREV_JUPITER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln2146">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2147">                AR_PHY_65NM_CH0_THERM_JUPITER, AR_PHY_65NM_CH0_THERM_LOCAL, 1);</a>
<a name="ln2148">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2149">                AR_PHY_65NM_CH0_THERM_JUPITER, AR_PHY_65NM_CH0_THERM_START, 1);</a>
<a name="ln2150">        } else {</a>
<a name="ln2151">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2152">                AR_PHY_65NM_CH0_THERM, AR_PHY_65NM_CH0_THERM_LOCAL, 1);</a>
<a name="ln2153">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2154">                AR_PHY_65NM_CH0_THERM, AR_PHY_65NM_CH0_THERM_START, 1);</a>
<a name="ln2155">        }</a>
<a name="ln2156"> </a>
<a name="ln2157">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2158">            &quot;%s: starting Temperature Compensation Calibration\n&quot;, __func__);</a>
<a name="ln2159">        break;</a>
<a name="ln2160">    default:</a>
<a name="ln2161">        HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln2162">            &quot;%s called with incorrect calibration type.\n&quot;, __func__);</a>
<a name="ln2163">    }</a>
<a name="ln2164">}</a>
<a name="ln2165"> </a>
<a name="ln2166">/* ar9300_reset_calibration</a>
<a name="ln2167"> * Initialize shared data structures and prepare a cal to be run.</a>
<a name="ln2168"> */</a>
<a name="ln2169">inline static void</a>
<a name="ln2170">ar9300_reset_calibration(struct ath_hal *ah, HAL_CAL_LIST *curr_cal)</a>
<a name="ln2171">{</a>
<a name="ln2172">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2173">    int i;</a>
<a name="ln2174"> </a>
<a name="ln2175">    /* Setup HW for new calibration */</a>
<a name="ln2176">    ar9300_setup_calibration(ah, curr_cal);</a>
<a name="ln2177"> </a>
<a name="ln2178">    /* Change SW state to RUNNING for this calibration */</a>
<a name="ln2179">    curr_cal-&gt;cal_state = CAL_RUNNING;</a>
<a name="ln2180"> </a>
<a name="ln2181">    /* Reset data structures shared between different calibrations */</a>
<a name="ln2182">    for (i = 0; i &lt; AR9300_MAX_CHAINS; i++) {</a>
<a name="ln2183">        ahp-&gt;ah_meas0.sign[i] = 0;</a>
<a name="ln2184">        ahp-&gt;ah_meas1.sign[i] = 0;</a>
<a name="ln2185">        ahp-&gt;ah_meas2.sign[i] = 0;</a>
<a name="ln2186">        ahp-&gt;ah_meas3.sign[i] = 0;</a>
<a name="ln2187">    }</a>
<a name="ln2188"> </a>
<a name="ln2189">    ahp-&gt;ah_cal_samples = 0;</a>
<a name="ln2190">}</a>
<a name="ln2191"> </a>
<a name="ln2192">#ifdef XXX_UNUSED_FUNCTION</a>
<a name="ln2193">/*</a>
<a name="ln2194"> * Find out which of the RX chains are enabled</a>
<a name="ln2195"> */</a>
<a name="ln2196">static u_int32_t</a>
<a name="ln2197">ar9300_get_rx_chain_mask(struct ath_hal *ah)</a>
<a name="ln2198">{</a>
<a name="ln2199">    u_int32_t ret_val = OS_REG_READ(ah, AR_PHY_RX_CHAINMASK);</a>
<a name="ln2200">    /* The bits [2:0] indicate the rx chain mask and are to be</a>
<a name="ln2201">     * interpreted as follows:</a>
<a name="ln2202">     * 00x =&gt; Only chain 0 is enabled</a>
<a name="ln2203">     * 01x =&gt; Chain 1 and 0 enabled</a>
<a name="ln2204">     * 1xx =&gt; Chain 2,1 and 0 enabled</a>
<a name="ln2205">     */</a>
<a name="ln2206">    return (ret_val &amp; 0x7);</a>
<a name="ln2207">}</a>
<a name="ln2208">#endif</a>
<a name="ln2209"> </a>
<a name="ln2210">static void </a>
<a name="ln2211">ar9300_get_nf_hist_base(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *chan,</a>
<a name="ln2212">    int is_scan, int16_t nf[])</a>
<a name="ln2213">{</a>
<a name="ln2214">    HAL_NFCAL_BASE *h_base;</a>
<a name="ln2215"> </a>
<a name="ln2216">#ifdef ATH_NF_PER_CHAN</a>
<a name="ln2217">    h_base = &amp;chan-&gt;nf_cal_hist.base;</a>
<a name="ln2218">#else</a>
<a name="ln2219">    if (is_scan) {</a>
<a name="ln2220">        /*</a>
<a name="ln2221">         * The channel we are currently on is not the home channel,</a>
<a name="ln2222">         * so we shouldn't use the home channel NF buffer's values on</a>
<a name="ln2223">         * this channel.  Instead, use the NF single value already</a>
<a name="ln2224">         * read for this channel.  (Or, if we haven't read the NF for</a>
<a name="ln2225">         * this channel yet, the SW default for this chip/band will</a>
<a name="ln2226">         * be used.)</a>
<a name="ln2227">         */</a>
<a name="ln2228">        h_base = &amp;chan-&gt;nf_cal_hist.base;</a>
<a name="ln2229">    } else {</a>
<a name="ln2230">        /* use the home channel NF info */</a>
<a name="ln2231">        h_base = &amp;AH_PRIVATE(ah)-&gt;nf_cal_hist.base;</a>
<a name="ln2232">    }</a>
<a name="ln2233">#endif</a>
<a name="ln2234">    OS_MEMCPY(nf, h_base-&gt;priv_nf, sizeof(h_base-&gt;priv_nf));</a>
<a name="ln2235">}</a>
<a name="ln2236"> </a>
<a name="ln2237">HAL_BOOL</a>
<a name="ln2238">ar9300_load_nf(struct ath_hal *ah, int16_t nf[])</a>
<a name="ln2239">{</a>
<a name="ln2240">    int i, j;</a>
<a name="ln2241">    int32_t val;</a>
<a name="ln2242">    /* XXX where are EXT regs defined */</a>
<a name="ln2243">    const u_int32_t ar9300_cca_regs[] = {</a>
<a name="ln2244">        AR_PHY_CCA_0,</a>
<a name="ln2245">        AR_PHY_CCA_1,</a>
<a name="ln2246">        AR_PHY_CCA_2,</a>
<a name="ln2247">        AR_PHY_EXT_CCA,</a>
<a name="ln2248">        AR_PHY_EXT_CCA_1,</a>
<a name="ln2249">        AR_PHY_EXT_CCA_2,</a>
<a name="ln2250">    };</a>
<a name="ln2251">    u_int8_t chainmask;</a>
<a name="ln2252"> </a>
<a name="ln2253">    /*</a>
<a name="ln2254">     * Force NF calibration for all chains, otherwise Vista station</a>
<a name="ln2255">     * would conduct a bad performance</a>
<a name="ln2256">     */</a>
<a name="ln2257">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln2258">        chainmask = 0x9;</a>
<a name="ln2259">    } else if (AR_SREV_WASP(ah) || AR_SREV_JUPITER(ah) || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln2260">        chainmask = 0x1b;</a>
<a name="ln2261">    } else {</a>
<a name="ln2262">        chainmask = 0x3F;</a>
<a name="ln2263">    }</a>
<a name="ln2264"> </a>
<a name="ln2265">    /*</a>
<a name="ln2266">     * Write filtered NF values into max_cca_pwr register parameter</a>
<a name="ln2267">     * so we can load below.</a>
<a name="ln2268">     */</a>
<a name="ln2269">    for (i = 0; i &lt; HAL_NUM_NF_READINGS; i++) {</a>
<a name="ln2270">        if (chainmask &amp; (1 &lt;&lt; i)) {</a>
<a name="ln2271">            val = OS_REG_READ(ah, ar9300_cca_regs[i]);</a>
<a name="ln2272">            val &amp;= 0xFFFFFE00;</a>
<a name="ln2273">            val |= (((u_int32_t)(nf[i]) &lt;&lt; 1) &amp; 0x1ff);</a>
<a name="ln2274">            OS_REG_WRITE(ah, ar9300_cca_regs[i], val);</a>
<a name="ln2275">        }</a>
<a name="ln2276">    }</a>
<a name="ln2277"> </a>
<a name="ln2278">    HALDEBUG(ah, HAL_DEBUG_NFCAL, &quot;%s: load %d %d %d %d %d %d\n&quot;,</a>
<a name="ln2279">      __func__,</a>
<a name="ln2280">      nf[0], nf[1], nf[2],</a>
<a name="ln2281">      nf[3], nf[4], nf[5]);</a>
<a name="ln2282"> </a>
<a name="ln2283">    /*</a>
<a name="ln2284">     * Load software filtered NF value into baseband internal min_cca_pwr</a>
<a name="ln2285">     * variable.</a>
<a name="ln2286">     */</a>
<a name="ln2287">    OS_REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_ENABLE_NF);</a>
<a name="ln2288">    OS_REG_CLR_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NO_UPDATE_NF);</a>
<a name="ln2289">    OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);</a>
<a name="ln2290"> </a>
<a name="ln2291">    /* Wait for load to complete, should be fast, a few 10s of us. */</a>
<a name="ln2292">    /* Changed the max delay 250us back to 10000us, since 250us often</a>
<a name="ln2293">     * results in NF load timeout and causes deaf condition</a>
<a name="ln2294">     * during stress testing 12/12/2009</a>
<a name="ln2295">     */</a>
<a name="ln2296">    for (j = 0; j &lt; 10000; j++) {</a>
<a name="ln2297">        if ((OS_REG_READ(ah, AR_PHY_AGC_CONTROL) &amp; AR_PHY_AGC_CONTROL_NF) == 0){</a>
<a name="ln2298">            break;</a>
<a name="ln2299">        }</a>
<a name="ln2300">        OS_DELAY(10);</a>
<a name="ln2301">    }</a>
<a name="ln2302">    if (j == 10000) {</a>
<a name="ln2303">        /*</a>
<a name="ln2304">         * We timed out waiting for the noisefloor to load, probably</a>
<a name="ln2305">         * due to an in-progress rx.  Simply return here and allow</a>
<a name="ln2306">         * the load plenty of time to complete before the next </a>
<a name="ln2307">         * calibration interval.  We need to avoid trying to load -50</a>
<a name="ln2308">         * (which happens below) while the previous load is still in</a>
<a name="ln2309">         * progress as this can cause rx deafness (see EV 66368,62830).</a>
<a name="ln2310">         * Instead by returning here, the baseband nf cal will </a>
<a name="ln2311">         * just be capped by our present noisefloor until the next</a>
<a name="ln2312">         * calibration timer.</a>
<a name="ln2313">         */</a>
<a name="ln2314">        HALDEBUG(AH_NULL, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln2315">            &quot;%s: *** TIMEOUT while waiting for nf to load: &quot;</a>
<a name="ln2316">            &quot;AR_PHY_AGC_CONTROL=0x%x ***\n&quot;, </a>
<a name="ln2317">            __func__, OS_REG_READ(ah, AR_PHY_AGC_CONTROL));</a>
<a name="ln2318">        return AH_FALSE;</a>
<a name="ln2319">    }</a>
<a name="ln2320"> </a>
<a name="ln2321">    /*</a>
<a name="ln2322">     * Restore max_cca_power register parameter again so that we're not capped</a>
<a name="ln2323">     * by the median we just loaded.  This will be initial (and max) value</a>
<a name="ln2324">     * of next noise floor calibration the baseband does.</a>
<a name="ln2325">     */</a>
<a name="ln2326">    for (i = 0; i &lt; HAL_NUM_NF_READINGS; i++) {</a>
<a name="ln2327">        if (chainmask &amp; (1 &lt;&lt; i)) {</a>
<a name="ln2328">            val = OS_REG_READ(ah, ar9300_cca_regs[i]);</a>
<a name="ln2329">            val &amp;= 0xFFFFFE00;</a>
<a name="ln2330">            val |= (((u_int32_t)(-50) &lt;&lt; 1) &amp; 0x1ff);</a>
<a name="ln2331">            OS_REG_WRITE(ah, ar9300_cca_regs[i], val);</a>
<a name="ln2332">        }</a>
<a name="ln2333">    }</a>
<a name="ln2334">    return AH_TRUE;</a>
<a name="ln2335">}</a>
<a name="ln2336"> </a>
<a name="ln2337">/* ar9300_per_calibration</a>
<a name="ln2338"> * Generic calibration routine.</a>
<a name="ln2339"> * Recalibrate the lower PHY chips to account for temperature/environment</a>
<a name="ln2340"> * changes.</a>
<a name="ln2341"> */</a>
<a name="ln2342">inline static void</a>
<a name="ln2343">ar9300_per_calibration(struct ath_hal *ah,  HAL_CHANNEL_INTERNAL *ichan,</a>
<a name="ln2344">    u_int8_t rxchainmask, HAL_CAL_LIST *curr_cal, HAL_BOOL *is_cal_done)</a>
<a name="ln2345">{</a>
<a name="ln2346">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2347"> </a>
<a name="ln2348">    /* Cal is assumed not done until explicitly set below */</a>
<a name="ln2349">    *is_cal_done = AH_FALSE;</a>
<a name="ln2350"> </a>
<a name="ln2351">    /* Calibration in progress. */</a>
<a name="ln2352">    if (curr_cal-&gt;cal_state == CAL_RUNNING) {</a>
<a name="ln2353">        /* Check to see if it has finished. */</a>
<a name="ln2354">        if (!(OS_REG_READ(ah, AR_PHY_TIMING4) &amp; AR_PHY_TIMING4_DO_CAL)) {</a>
<a name="ln2355">            int i, num_chains = 0;</a>
<a name="ln2356">            for (i = 0; i &lt; AR9300_MAX_CHAINS; i++) {</a>
<a name="ln2357">                if (rxchainmask &amp; (1 &lt;&lt; i)) {</a>
<a name="ln2358">                    num_chains++;</a>
<a name="ln2359">                }</a>
<a name="ln2360">            }</a>
<a name="ln2361"> </a>
<a name="ln2362">            /*</a>
<a name="ln2363">             * Accumulate cal measures for active chains</a>
<a name="ln2364">             */</a>
<a name="ln2365">            curr_cal-&gt;cal_data-&gt;cal_collect(ah, num_chains);</a>
<a name="ln2366"> </a>
<a name="ln2367">            ahp-&gt;ah_cal_samples++;</a>
<a name="ln2368"> </a>
<a name="ln2369">            if (ahp-&gt;ah_cal_samples &gt;= curr_cal-&gt;cal_data-&gt;cal_num_samples) {</a>
<a name="ln2370">                /*</a>
<a name="ln2371">                 * Process accumulated data</a>
<a name="ln2372">                 */</a>
<a name="ln2373">                curr_cal-&gt;cal_data-&gt;cal_post_proc(ah, num_chains);</a>
<a name="ln2374"> </a>
<a name="ln2375">                /* Calibration has finished. */</a>
<a name="ln2376">                ichan-&gt;calValid |= curr_cal-&gt;cal_data-&gt;cal_type;</a>
<a name="ln2377">                curr_cal-&gt;cal_state = CAL_DONE;</a>
<a name="ln2378">                *is_cal_done = AH_TRUE;</a>
<a name="ln2379">            } else {</a>
<a name="ln2380">                /* Set-up collection of another sub-sample until we</a>
<a name="ln2381">                 * get desired number</a>
<a name="ln2382">                 */</a>
<a name="ln2383">                ar9300_setup_calibration(ah, curr_cal);</a>
<a name="ln2384">            }</a>
<a name="ln2385">        }</a>
<a name="ln2386">    } else if (!(ichan-&gt;calValid &amp; curr_cal-&gt;cal_data-&gt;cal_type)) {</a>
<a name="ln2387">        /* If current cal is marked invalid in channel, kick it off */</a>
<a name="ln2388">        ar9300_reset_calibration(ah, curr_cal);</a>
<a name="ln2389">    }</a>
<a name="ln2390">}</a>
<a name="ln2391"> </a>
<a name="ln2392">static void</a>
<a name="ln2393">ar9300_start_nf_cal(struct ath_hal *ah)</a>
<a name="ln2394">{</a>
<a name="ln2395">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2396">    OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_ENABLE_NF);</a>
<a name="ln2397">    OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NO_UPDATE_NF);</a>
<a name="ln2398">    OS_REG_SET_BIT(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_NF);</a>
<a name="ln2399">    AH9300(ah)-&gt;nf_tsf32 = ar9300_get_tsf32(ah);</a>
<a name="ln2400"> </a>
<a name="ln2401">/*  </a>
<a name="ln2402"> *  We are reading the NF values before we start the NF operation, because</a>
<a name="ln2403"> *  of that we are getting very high values like -45.</a>
<a name="ln2404"> *  This triggers the CW_INT detected and EACS module triggers the channel change</a>
<a name="ln2405"> *  chip_reset_done value is used to fix this issue.</a>
<a name="ln2406"> *  chip_reset_flag is set during the RTC reset.</a>
<a name="ln2407"> *  chip_reset_flag is cleared during the starting NF operation.</a>
<a name="ln2408"> *  if flag is set we will clear the flag and will not read the NF values.</a>
<a name="ln2409"> */</a>
<a name="ln2410">    ahp-&gt;ah_chip_reset_done = 0;    </a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413">/* ar9300_calibration</a>
<a name="ln2414"> * Wrapper for a more generic Calibration routine. Primarily to abstract to</a>
<a name="ln2415"> * upper layers whether there is 1 or more calibrations to be run.</a>
<a name="ln2416"> */</a>
<a name="ln2417">HAL_BOOL</a>
<a name="ln2418">ar9300_calibration(struct ath_hal *ah, struct ieee80211_channel *chan, u_int8_t rxchainmask,</a>
<a name="ln2419">    HAL_BOOL do_nf_cal, HAL_BOOL *is_cal_done, int is_scan,</a>
<a name="ln2420">    u_int32_t *sched_cals)</a>
<a name="ln2421">{</a>
<a name="ln2422">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2423">    HAL_CAL_LIST *curr_cal = ahp-&gt;ah_cal_list_curr;</a>
<a name="ln2424">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln2425">    int16_t nf_buf[HAL_NUM_NF_READINGS];</a>
<a name="ln2426"> </a>
<a name="ln2427">    *is_cal_done = AH_TRUE;</a>
<a name="ln2428"> </a>
<a name="ln2429"> </a>
<a name="ln2430">    /* XXX: For initial wasp bringup - disable periodic calibration */</a>
<a name="ln2431">    /* Invalid channel check */</a>
<a name="ln2432">    if (ichan == AH_NULL) {</a>
<a name="ln2433">        HALDEBUG(ah, HAL_DEBUG_CHANNEL,</a>
<a name="ln2434">            &quot;%s: invalid channel %u/0x%x; no mapping\n&quot;,</a>
<a name="ln2435">            __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln2436">        return AH_FALSE;</a>
<a name="ln2437">    }</a>
<a name="ln2438"> </a>
<a name="ln2439">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2440">        &quot;%s: Entering, Doing NF Cal = %d\n&quot;, __func__, do_nf_cal);</a>
<a name="ln2441">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE, &quot;%s: Chain 0 Rx IQ Cal Correction 0x%08x\n&quot;,</a>
<a name="ln2442">        __func__, OS_REG_READ(ah, AR_PHY_RX_IQCAL_CORR_B0));</a>
<a name="ln2443">    if (!AR_SREV_HORNET(ah) &amp;&amp; !AR_SREV_POSEIDON(ah) &amp;&amp; !AR_SREV_APHRODITE(ah)) {</a>
<a name="ln2444">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2445">            &quot;%s: Chain 1 Rx IQ Cal Correction 0x%08x\n&quot;,</a>
<a name="ln2446">            __func__, OS_REG_READ(ah, AR_PHY_RX_IQCAL_CORR_B1));</a>
<a name="ln2447">        if (!AR_SREV_WASP(ah) &amp;&amp; !AR_SREV_JUPITER(ah) &amp;&amp; !AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln2448">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2449">                &quot;%s: Chain 2 Rx IQ Cal Correction 0x%08x\n&quot;,</a>
<a name="ln2450">                __func__, OS_REG_READ(ah, AR_PHY_RX_IQCAL_CORR_B2));</a>
<a name="ln2451">        }</a>
<a name="ln2452">    }</a>
<a name="ln2453"> </a>
<a name="ln2454">    OS_MARK(ah, AH_MARK_PERCAL, chan-&gt;ic_freq);</a>
<a name="ln2455"> </a>
<a name="ln2456">    /* For given calibration:</a>
<a name="ln2457">     * 1. Call generic cal routine</a>
<a name="ln2458">     * 2. When this cal is done (is_cal_done) if we have more cals waiting</a>
<a name="ln2459">     *    (eg after reset), mask this to upper layers by not propagating</a>
<a name="ln2460">     *    is_cal_done if it is set to TRUE.</a>
<a name="ln2461">     *    Instead, change is_cal_done to FALSE and setup the waiting cal(s)</a>
<a name="ln2462">     *    to be run.</a>
<a name="ln2463">     */</a>
<a name="ln2464">    if (curr_cal &amp;&amp; (curr_cal-&gt;cal_data-&gt;cal_type &amp; *sched_cals) &amp;&amp;</a>
<a name="ln2465">        (curr_cal-&gt;cal_state == CAL_RUNNING ||</a>
<a name="ln2466">         curr_cal-&gt;cal_state == CAL_WAITING))</a>
<a name="ln2467">    {</a>
<a name="ln2468">        ar9300_per_calibration(ah, ichan, rxchainmask, curr_cal, is_cal_done);</a>
<a name="ln2469"> </a>
<a name="ln2470">        if (*is_cal_done == AH_TRUE) {</a>
<a name="ln2471">            ahp-&gt;ah_cal_list_curr = curr_cal = curr_cal-&gt;cal_next;</a>
<a name="ln2472"> </a>
<a name="ln2473">            if (curr_cal &amp;&amp; curr_cal-&gt;cal_state == CAL_WAITING) {</a>
<a name="ln2474">                *is_cal_done = AH_FALSE;</a>
<a name="ln2475">                ar9300_reset_calibration(ah, curr_cal);</a>
<a name="ln2476">            } else {</a>
<a name="ln2477">                *sched_cals &amp;= ~IQ_MISMATCH_CAL;</a>
<a name="ln2478">            }</a>
<a name="ln2479">        }</a>
<a name="ln2480">    }</a>
<a name="ln2481"> </a>
<a name="ln2482">    /* Do NF cal only at longer intervals */</a>
<a name="ln2483">    if (do_nf_cal) {</a>
<a name="ln2484">        int nf_done;</a>
<a name="ln2485"> </a>
<a name="ln2486">        /* Get the value from the previous NF cal and update history buffer */</a>
<a name="ln2487">        nf_done = ar9300_store_new_nf(ah, chan, is_scan);</a>
<a name="ln2488">#if 0</a>
<a name="ln2489">        if (ichan-&gt;channel_flags &amp; CHANNEL_CW_INT) {</a>
<a name="ln2490">            chan-&gt;channel_flags |= CHANNEL_CW_INT;</a>
<a name="ln2491">        }</a>
<a name="ln2492">#endif</a>
<a name="ln2493">        chan-&gt;ic_state &amp;= ~IEEE80211_CHANSTATE_CWINT;</a>
<a name="ln2494"> </a>
<a name="ln2495">        if (nf_done) {</a>
<a name="ln2496">            int ret;</a>
<a name="ln2497">            /*</a>
<a name="ln2498">             * Load the NF from history buffer of the current channel.</a>
<a name="ln2499">             * NF is slow time-variant, so it is OK to use a historical value.</a>
<a name="ln2500">             */</a>
<a name="ln2501">            ar9300_get_nf_hist_base(ah, ichan, is_scan, nf_buf);</a>
<a name="ln2502"> </a>
<a name="ln2503">            ret = ar9300_load_nf(ah, nf_buf);</a>
<a name="ln2504">            /* start NF calibration, without updating BB NF register*/</a>
<a name="ln2505">            ar9300_start_nf_cal(ah);</a>
<a name="ln2506"> </a>
<a name="ln2507">            /*</a>
<a name="ln2508">             * If we failed the NF cal then tell the upper layer that we</a>
<a name="ln2509">             * failed so we can do a full reset</a>
<a name="ln2510">             */</a>
<a name="ln2511">            if (! ret)</a>
<a name="ln2512">                return AH_FALSE;</a>
<a name="ln2513">        }</a>
<a name="ln2514">    }</a>
<a name="ln2515">    return AH_TRUE;</a>
<a name="ln2516">}</a>
<a name="ln2517"> </a>
<a name="ln2518">/* ar9300_iq_cal_collect</a>
<a name="ln2519"> * Collect data from HW to later perform IQ Mismatch Calibration</a>
<a name="ln2520"> */</a>
<a name="ln2521">void</a>
<a name="ln2522">ar9300_iq_cal_collect(struct ath_hal *ah, u_int8_t num_chains)</a>
<a name="ln2523">{</a>
<a name="ln2524">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2525">    int i;</a>
<a name="ln2526"> </a>
<a name="ln2527">    /*</a>
<a name="ln2528">     * Accumulate IQ cal measures for active chains</a>
<a name="ln2529">     */</a>
<a name="ln2530">    for (i = 0; i &lt; num_chains; i++) {</a>
<a name="ln2531">        ahp-&gt;ah_total_power_meas_i[i] = OS_REG_READ(ah, AR_PHY_CAL_MEAS_0(i));</a>
<a name="ln2532">        ahp-&gt;ah_total_power_meas_q[i] = OS_REG_READ(ah, AR_PHY_CAL_MEAS_1(i));</a>
<a name="ln2533">        ahp-&gt;ah_total_iq_corr_meas[i] =</a>
<a name="ln2534">            (int32_t) OS_REG_READ(ah, AR_PHY_CAL_MEAS_2(i));</a>
<a name="ln2535">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2536">            &quot;%d: Chn %d &quot;</a>
<a name="ln2537">            &quot;Reg Offset(0x%04x)pmi=0x%08x; &quot;</a>
<a name="ln2538">            &quot;Reg Offset(0x%04x)pmq=0x%08x; &quot;</a>
<a name="ln2539">            &quot;Reg Offset (0x%04x)iqcm=0x%08x;\n&quot;,</a>
<a name="ln2540">            ahp-&gt;ah_cal_samples,</a>
<a name="ln2541">            i,</a>
<a name="ln2542">            (unsigned) AR_PHY_CAL_MEAS_0(i),</a>
<a name="ln2543">            ahp-&gt;ah_total_power_meas_i[i],</a>
<a name="ln2544">            (unsigned) AR_PHY_CAL_MEAS_1(i),</a>
<a name="ln2545">            ahp-&gt;ah_total_power_meas_q[i],</a>
<a name="ln2546">            (unsigned) AR_PHY_CAL_MEAS_2(i),</a>
<a name="ln2547">            ahp-&gt;ah_total_iq_corr_meas[i]);</a>
<a name="ln2548">    }</a>
<a name="ln2549">}</a>
<a name="ln2550"> </a>
<a name="ln2551">/* ar9300_iq_calibration</a>
<a name="ln2552"> * Use HW data to perform IQ Mismatch Calibration</a>
<a name="ln2553"> */</a>
<a name="ln2554">void</a>
<a name="ln2555">ar9300_iq_calibration(struct ath_hal *ah, u_int8_t num_chains)</a>
<a name="ln2556">{</a>
<a name="ln2557">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2558">    u_int32_t power_meas_q, power_meas_i, iq_corr_meas;</a>
<a name="ln2559">    u_int32_t q_coff_denom, i_coff_denom;</a>
<a name="ln2560">    int32_t q_coff, i_coff;</a>
<a name="ln2561">    int iq_corr_neg, i;</a>
<a name="ln2562">    HAL_CHANNEL_INTERNAL *ichan;</a>
<a name="ln2563">    static const u_int32_t offset_array[3] = {</a>
<a name="ln2564">        AR_PHY_RX_IQCAL_CORR_B0,</a>
<a name="ln2565">        AR_PHY_RX_IQCAL_CORR_B1,</a>
<a name="ln2566">        AR_PHY_RX_IQCAL_CORR_B2,</a>
<a name="ln2567">    };</a>
<a name="ln2568"> </a>
<a name="ln2569">    ichan = ath_hal_checkchannel(ah, AH_PRIVATE(ah)-&gt;ah_curchan);</a>
<a name="ln2570"> </a>
<a name="ln2571">    for (i = 0; i &lt; num_chains; i++) {</a>
<a name="ln2572">        power_meas_i = ahp-&gt;ah_total_power_meas_i[i];</a>
<a name="ln2573">        power_meas_q = ahp-&gt;ah_total_power_meas_q[i];</a>
<a name="ln2574">        iq_corr_meas = ahp-&gt;ah_total_iq_corr_meas[i];</a>
<a name="ln2575"> </a>
<a name="ln2576">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2577">            &quot;Starting IQ Cal and Correction for Chain %d\n&quot;, i);</a>
<a name="ln2578">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2579">            &quot;Orignal: Chn %diq_corr_meas = 0x%08x\n&quot;,</a>
<a name="ln2580">            i, ahp-&gt;ah_total_iq_corr_meas[i]);</a>
<a name="ln2581"> </a>
<a name="ln2582">        iq_corr_neg = 0;</a>
<a name="ln2583"> </a>
<a name="ln2584">        /* iq_corr_meas is always negative. */</a>
<a name="ln2585">        if (iq_corr_meas &gt; 0x80000000)  {</a>
<a name="ln2586">            iq_corr_meas = (0xffffffff - iq_corr_meas) + 1;</a>
<a name="ln2587">            iq_corr_neg = 1;</a>
<a name="ln2588">        }</a>
<a name="ln2589"> </a>
<a name="ln2590">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2591">            &quot;Chn %d pwr_meas_i = 0x%08x\n&quot;, i, power_meas_i);</a>
<a name="ln2592">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2593">            &quot;Chn %d pwr_meas_q = 0x%08x\n&quot;, i, power_meas_q);</a>
<a name="ln2594">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2595">            &quot;iq_corr_neg is 0x%08x\n&quot;, iq_corr_neg);</a>
<a name="ln2596"> </a>
<a name="ln2597">        i_coff_denom = (power_meas_i / 2 + power_meas_q / 2) / 256;</a>
<a name="ln2598">        q_coff_denom = power_meas_q / 64;</a>
<a name="ln2599"> </a>
<a name="ln2600">        /* Protect against divide-by-0 */</a>
<a name="ln2601">        if ((i_coff_denom != 0) &amp;&amp; (q_coff_denom != 0)) {</a>
<a name="ln2602">            /* IQ corr_meas is already negated if iqcorr_neg == 1 */</a>
<a name="ln2603">            i_coff = iq_corr_meas / i_coff_denom;</a>
<a name="ln2604">            q_coff = power_meas_i / q_coff_denom - 64;</a>
<a name="ln2605">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2606">                &quot;Chn %d i_coff = 0x%08x\n&quot;, i, i_coff);</a>
<a name="ln2607">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2608">                &quot;Chn %d q_coff = 0x%08x\n&quot;, i, q_coff);</a>
<a name="ln2609"> </a>
<a name="ln2610">            /* Force bounds on i_coff */</a>
<a name="ln2611">            if (i_coff &gt;= 63) {</a>
<a name="ln2612">                i_coff = 63;</a>
<a name="ln2613">            } else if (i_coff &lt;= -63) {</a>
<a name="ln2614">                i_coff = -63;</a>
<a name="ln2615">            }</a>
<a name="ln2616"> </a>
<a name="ln2617">            /* Negate i_coff if iq_corr_neg == 0 */</a>
<a name="ln2618">            if (iq_corr_neg == 0x0) {</a>
<a name="ln2619">                i_coff = -i_coff;</a>
<a name="ln2620">            }</a>
<a name="ln2621"> </a>
<a name="ln2622">            /* Force bounds on q_coff */</a>
<a name="ln2623">            if (q_coff &gt;= 63) {</a>
<a name="ln2624">                q_coff = 63;</a>
<a name="ln2625">            } else if (q_coff &lt;= -63) {</a>
<a name="ln2626">                q_coff = -63;</a>
<a name="ln2627">            }</a>
<a name="ln2628"> </a>
<a name="ln2629">            i_coff = i_coff &amp; 0x7f;</a>
<a name="ln2630">            q_coff = q_coff &amp; 0x7f;</a>
<a name="ln2631"> </a>
<a name="ln2632">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2633">                &quot;Chn %d : i_coff = 0x%x  q_coff = 0x%x\n&quot;, i, i_coff, q_coff);</a>
<a name="ln2634">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2635">                &quot;Register offset (0x%04x) before update = 0x%x\n&quot;,</a>
<a name="ln2636">                offset_array[i], OS_REG_READ(ah, offset_array[i]));</a>
<a name="ln2637"> </a>
<a name="ln2638">            OS_REG_RMW_FIELD(ah, offset_array[i],</a>
<a name="ln2639">                AR_PHY_RX_IQCAL_CORR_IQCORR_Q_I_COFF, i_coff);</a>
<a name="ln2640">            OS_REG_RMW_FIELD(ah, offset_array[i],</a>
<a name="ln2641">                AR_PHY_RX_IQCAL_CORR_IQCORR_Q_Q_COFF, q_coff);</a>
<a name="ln2642"> </a>
<a name="ln2643">            /* store the RX cal results */</a>
<a name="ln2644">	    if (ichan != NULL) {</a>
<a name="ln2645">            ahp-&gt;ah_rx_cal_corr[i] = OS_REG_READ(ah, offset_array[i]) &amp; 0x7fff;</a>
<a name="ln2646">            ahp-&gt;ah_rx_cal_complete = AH_TRUE;</a>
<a name="ln2647">            ahp-&gt;ah_rx_cal_chan = ichan-&gt;channel;</a>
<a name="ln2648">//            ahp-&gt;ah_rx_cal_chan_flag = ichan-&gt;channel_flags &amp;~ CHANNEL_PASSIVE; </a>
<a name="ln2649">            ahp-&gt;ah_rx_cal_chan_flag = 0; /* XXX */</a>
<a name="ln2650">	    } else {</a>
<a name="ln2651">	        /* XXX? Is this what I should do? */</a>
<a name="ln2652">            	ahp-&gt;ah_rx_cal_complete = AH_FALSE;</a>
<a name="ln2653"> </a>
<a name="ln2654">	    }</a>
<a name="ln2655"> </a>
<a name="ln2656">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2657">                &quot;Register offset (0x%04x) QI COFF (bitfields 0x%08x) &quot;</a>
<a name="ln2658">                &quot;after update = 0x%x\n&quot;,</a>
<a name="ln2659">                offset_array[i], AR_PHY_RX_IQCAL_CORR_IQCORR_Q_I_COFF,</a>
<a name="ln2660">                OS_REG_READ(ah, offset_array[i]));</a>
<a name="ln2661">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2662">                &quot;Register offset (0x%04x) QQ COFF (bitfields 0x%08x) &quot;</a>
<a name="ln2663">                &quot;after update = 0x%x\n&quot;,</a>
<a name="ln2664">                offset_array[i], AR_PHY_RX_IQCAL_CORR_IQCORR_Q_Q_COFF,</a>
<a name="ln2665">                OS_REG_READ(ah, offset_array[i]));</a>
<a name="ln2666">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2667">                &quot;IQ Cal and Correction done for Chain %d\n&quot;, i);</a>
<a name="ln2668">        }</a>
<a name="ln2669">    }</a>
<a name="ln2670"> </a>
<a name="ln2671">    OS_REG_SET_BIT(ah,</a>
<a name="ln2672">        AR_PHY_RX_IQCAL_CORR_B0, AR_PHY_RX_IQCAL_CORR_IQCORR_ENABLE);</a>
<a name="ln2673">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2674">        &quot;IQ Cal and Correction (offset 0x%04x) enabled &quot;</a>
<a name="ln2675">        &quot;(bit position 0x%08x). New Value 0x%08x\n&quot;,</a>
<a name="ln2676">        (unsigned) (AR_PHY_RX_IQCAL_CORR_B0),</a>
<a name="ln2677">        AR_PHY_RX_IQCAL_CORR_IQCORR_ENABLE,</a>
<a name="ln2678">        OS_REG_READ(ah, AR_PHY_RX_IQCAL_CORR_B0));</a>
<a name="ln2679">}</a>
<a name="ln2680"> </a>
<a name="ln2681">/*</a>
<a name="ln2682"> * When coming back from offchan, we do not perform RX IQ Cal.</a>
<a name="ln2683"> * But the chip reset will clear all previous results</a>
<a name="ln2684"> * We store the previous results and restore here.</a>
<a name="ln2685"> */</a>
<a name="ln2686">static void</a>
<a name="ln2687">ar9300_rx_iq_cal_restore(struct ath_hal *ah)</a>
<a name="ln2688">{</a>
<a name="ln2689">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2690">    u_int32_t   i_coff, q_coff;</a>
<a name="ln2691">    HAL_BOOL is_restore = AH_FALSE;</a>
<a name="ln2692">    int i;</a>
<a name="ln2693">    static const u_int32_t offset_array[3] = {</a>
<a name="ln2694">        AR_PHY_RX_IQCAL_CORR_B0,</a>
<a name="ln2695">        AR_PHY_RX_IQCAL_CORR_B1,</a>
<a name="ln2696">        AR_PHY_RX_IQCAL_CORR_B2,</a>
<a name="ln2697">    };</a>
<a name="ln2698"> </a>
<a name="ln2699">    for (i=0; i&lt;AR9300_MAX_CHAINS; i++) {</a>
<a name="ln2700">        if (ahp-&gt;ah_rx_cal_corr[i]) {</a>
<a name="ln2701">            i_coff = (ahp-&gt;ah_rx_cal_corr[i] &amp;</a>
<a name="ln2702">                        AR_PHY_RX_IQCAL_CORR_IQCORR_Q_I_COFF) &gt;&gt;</a>
<a name="ln2703">                        AR_PHY_RX_IQCAL_CORR_IQCORR_Q_I_COFF_S;</a>
<a name="ln2704">            q_coff = (ahp-&gt;ah_rx_cal_corr[i] &amp;</a>
<a name="ln2705">                        AR_PHY_RX_IQCAL_CORR_IQCORR_Q_Q_COFF) &gt;&gt;</a>
<a name="ln2706">                        AR_PHY_RX_IQCAL_CORR_IQCORR_Q_Q_COFF_S;</a>
<a name="ln2707"> </a>
<a name="ln2708">            OS_REG_RMW_FIELD(ah, offset_array[i],</a>
<a name="ln2709">                AR_PHY_RX_IQCAL_CORR_IQCORR_Q_I_COFF, i_coff);</a>
<a name="ln2710">            OS_REG_RMW_FIELD(ah, offset_array[i],</a>
<a name="ln2711">                AR_PHY_RX_IQCAL_CORR_IQCORR_Q_Q_COFF, q_coff);</a>
<a name="ln2712"> </a>
<a name="ln2713">            is_restore = AH_TRUE;</a>
<a name="ln2714">        }</a>
<a name="ln2715">    }</a>
<a name="ln2716"> </a>
<a name="ln2717">    if (is_restore)</a>
<a name="ln2718">        OS_REG_SET_BIT(ah,</a>
<a name="ln2719">            AR_PHY_RX_IQCAL_CORR_B0, AR_PHY_RX_IQCAL_CORR_IQCORR_ENABLE);</a>
<a name="ln2720"> </a>
<a name="ln2721">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln2722">        &quot;%s: IQ Cal and Correction (offset 0x%04x) enabled &quot;</a>
<a name="ln2723">        &quot;(bit position 0x%08x). New Value 0x%08x\n&quot;,</a>
<a name="ln2724">        __func__,</a>
<a name="ln2725">        (unsigned) (AR_PHY_RX_IQCAL_CORR_B0),</a>
<a name="ln2726">        AR_PHY_RX_IQCAL_CORR_IQCORR_ENABLE,</a>
<a name="ln2727">        OS_REG_READ(ah, AR_PHY_RX_IQCAL_CORR_B0));</a>
<a name="ln2728">}</a>
<a name="ln2729"> </a>
<a name="ln2730">/*</a>
<a name="ln2731"> * Set a limit on the overall output power.  Used for dynamic</a>
<a name="ln2732"> * transmit power control and the like.</a>
<a name="ln2733"> *</a>
<a name="ln2734"> * NB: limit is in units of 0.5 dbM.</a>
<a name="ln2735"> */</a>
<a name="ln2736">HAL_BOOL</a>
<a name="ln2737">ar9300_set_tx_power_limit(struct ath_hal *ah, u_int32_t limit,</a>
<a name="ln2738">    u_int16_t extra_txpow, u_int16_t tpc_in_db)</a>
<a name="ln2739">{</a>
<a name="ln2740">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2741">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln2742">    const struct ieee80211_channel *chan = ahpriv-&gt;ah_curchan;</a>
<a name="ln2743">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln2744"> </a>
<a name="ln2745">    if (NULL == chan) {</a>
<a name="ln2746">        return AH_FALSE;</a>
<a name="ln2747">    }</a>
<a name="ln2748"> </a>
<a name="ln2749">    ahpriv-&gt;ah_powerLimit = AH_MIN(limit, MAX_RATE_POWER);</a>
<a name="ln2750">    ahpriv-&gt;ah_extraTxPow = extra_txpow;</a>
<a name="ln2751"> </a>
<a name="ln2752">    if(chan == NULL) {</a>
<a name="ln2753">        return AH_FALSE;</a>
<a name="ln2754">    }</a>
<a name="ln2755">    if (ar9300_eeprom_set_transmit_power(ah, &amp;ahp-&gt;ah_eeprom, chan,</a>
<a name="ln2756">        ath_hal_getctl(ah, chan), ath_hal_getantennaallowed(ah, chan),</a>
<a name="ln2757">        ath_hal_get_twice_max_regpower(ahpriv, ichan, chan),</a>
<a name="ln2758">        AH_MIN(MAX_RATE_POWER, ahpriv-&gt;ah_powerLimit)) != HAL_OK)</a>
<a name="ln2759">    {</a>
<a name="ln2760">        return AH_FALSE;</a>
<a name="ln2761">    }</a>
<a name="ln2762">    return AH_TRUE;</a>
<a name="ln2763">}</a>
<a name="ln2764"> </a>
<a name="ln2765">/*</a>
<a name="ln2766"> * Exported call to check for a recent gain reading and return</a>
<a name="ln2767"> * the current state of the thermal calibration gain engine.</a>
<a name="ln2768"> */</a>
<a name="ln2769">HAL_RFGAIN</a>
<a name="ln2770">ar9300_get_rfgain(struct ath_hal *ah)</a>
<a name="ln2771">{</a>
<a name="ln2772">    return HAL_RFGAIN_INACTIVE;</a>
<a name="ln2773">}</a>
<a name="ln2774"> </a>
<a name="ln2775">#define HAL_GREEN_AP_RX_MASK 0x1</a>
<a name="ln2776"> </a>
<a name="ln2777">static inline void</a>
<a name="ln2778">ar9300_init_chain_masks(struct ath_hal *ah, int rx_chainmask, int tx_chainmask)</a>
<a name="ln2779">{</a>
<a name="ln2780">    if (AH9300(ah)-&gt;green_ap_ps_on) {</a>
<a name="ln2781">        rx_chainmask = HAL_GREEN_AP_RX_MASK;</a>
<a name="ln2782">    }</a>
<a name="ln2783">    if (rx_chainmask == 0x5) {</a>
<a name="ln2784">        OS_REG_SET_BIT(ah, AR_PHY_ANALOG_SWAP, AR_PHY_SWAP_ALT_CHAIN);</a>
<a name="ln2785">    }</a>
<a name="ln2786">    OS_REG_WRITE(ah, AR_PHY_RX_CHAINMASK, rx_chainmask);</a>
<a name="ln2787">    OS_REG_WRITE(ah, AR_PHY_CAL_CHAINMASK, rx_chainmask);</a>
<a name="ln2788"> </a>
<a name="ln2789">    /*</a>
<a name="ln2790">     * Adaptive Power Management:</a>
<a name="ln2791">     * Some 3 stream chips exceed the PCIe power requirements.</a>
<a name="ln2792">     * This workaround will reduce power consumption by using 2 tx chains</a>
<a name="ln2793">     * for 1 and 2 stream rates (5 GHz only).</a>
<a name="ln2794">     *</a>
<a name="ln2795">     * Set the self gen mask to 2 tx chains when APM is enabled.</a>
<a name="ln2796">     *</a>
<a name="ln2797">     */</a>
<a name="ln2798">    if (AH_PRIVATE(ah)-&gt;ah_caps.halApmEnable &amp;&amp; (tx_chainmask == 0x7)) {</a>
<a name="ln2799">        OS_REG_WRITE(ah, AR_SELFGEN_MASK, 0x3);</a>
<a name="ln2800">    }</a>
<a name="ln2801">    else {</a>
<a name="ln2802">        OS_REG_WRITE(ah, AR_SELFGEN_MASK, tx_chainmask);</a>
<a name="ln2803">    }</a>
<a name="ln2804"> </a>
<a name="ln2805">    if (tx_chainmask == 0x5) {</a>
<a name="ln2806">        OS_REG_SET_BIT(ah, AR_PHY_ANALOG_SWAP, AR_PHY_SWAP_ALT_CHAIN);</a>
<a name="ln2807">    }</a>
<a name="ln2808">}</a>
<a name="ln2809"> </a>
<a name="ln2810">/*</a>
<a name="ln2811"> * Override INI values with chip specific configuration.</a>
<a name="ln2812"> */</a>
<a name="ln2813">static inline void</a>
<a name="ln2814">ar9300_override_ini(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln2815">{</a>
<a name="ln2816">    u_int32_t val;</a>
<a name="ln2817">    HAL_CAPABILITIES *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln2818"> </a>
<a name="ln2819">    /*</a>
<a name="ln2820">     * Set the RX_ABORT and RX_DIS and clear it only after</a>
<a name="ln2821">     * RXE is set for MAC. This prevents frames with</a>
<a name="ln2822">     * corrupted descriptor status.</a>
<a name="ln2823">     */</a>
<a name="ln2824">    OS_REG_SET_BIT(ah, AR_DIAG_SW, (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));</a>
<a name="ln2825">    /*</a>
<a name="ln2826">     * For Merlin and above, there is a new feature that allows Multicast</a>
<a name="ln2827">     * search based on both MAC Address and Key ID.</a>
<a name="ln2828">     * By default, this feature is enabled.</a>
<a name="ln2829">     * But since the driver is not using this feature, we switch it off;</a>
<a name="ln2830">     * otherwise multicast search based on MAC addr only will fail.</a>
<a name="ln2831">     */</a>
<a name="ln2832">    val = OS_REG_READ(ah, AR_PCU_MISC_MODE2) &amp; (~AR_ADHOC_MCAST_KEYID_ENABLE);</a>
<a name="ln2833">    OS_REG_WRITE(ah, AR_PCU_MISC_MODE2,</a>
<a name="ln2834">        val | AR_BUG_58603_FIX_ENABLE | AR_AGG_WEP_ENABLE);</a>
<a name="ln2835"> </a>
<a name="ln2836"> </a>
<a name="ln2837">    /* Osprey revision specific configuration */</a>
<a name="ln2838"> </a>
<a name="ln2839">    /* Osprey 2.0+ - if SW RAC support is disabled, must also disable</a>
<a name="ln2840">     * the Osprey 2.0 hardware RAC fix.</a>
<a name="ln2841">     */</a>
<a name="ln2842">    if (p_cap-&gt;halIsrRacSupport == AH_FALSE) {</a>
<a name="ln2843">        OS_REG_CLR_BIT(ah, AR_CFG, AR_CFG_MISSING_TX_INTR_FIX_ENABLE);</a>
<a name="ln2844">    }</a>
<a name="ln2845"> </a>
<a name="ln2846">    /* try to enable old pal if it is needed for h/w green tx */</a>
<a name="ln2847">    ar9300_hwgreentx_set_pal_spare(ah, 1);</a>
<a name="ln2848">}</a>
<a name="ln2849"> </a>
<a name="ln2850">static inline void</a>
<a name="ln2851">ar9300_prog_ini(struct ath_hal *ah, struct ar9300_ini_array *ini_arr,</a>
<a name="ln2852">    int column)</a>
<a name="ln2853">{</a>
<a name="ln2854">    int i, reg_writes = 0;</a>
<a name="ln2855"> </a>
<a name="ln2856">    /* New INI format: Array may be undefined (pre, core, post arrays) */</a>
<a name="ln2857">    if (ini_arr-&gt;ia_array == NULL) {</a>
<a name="ln2858">        return;</a>
<a name="ln2859">    }</a>
<a name="ln2860"> </a>
<a name="ln2861">    /*</a>
<a name="ln2862">     * New INI format: Pre, core, and post arrays for a given subsystem may be</a>
<a name="ln2863">     * modal (&gt; 2 columns) or non-modal (2 columns).</a>
<a name="ln2864">     * Determine if the array is non-modal and force the column to 1.</a>
<a name="ln2865">     */</a>
<a name="ln2866">    if (column &gt;= ini_arr-&gt;ia_columns) {</a>
<a name="ln2867">        column = 1;</a>
<a name="ln2868">    }</a>
<a name="ln2869"> </a>
<a name="ln2870">    for (i = 0; i &lt; ini_arr-&gt;ia_rows; i++) {</a>
<a name="ln2871">        u_int32_t reg = INI_RA(ini_arr, i, 0);</a>
<a name="ln2872">        u_int32_t val = INI_RA(ini_arr, i, column);</a>
<a name="ln2873"> </a>
<a name="ln2874">        /*</a>
<a name="ln2875">        ** Determine if this is a shift register value </a>
<a name="ln2876">        ** (reg &gt;= 0x16000 &amp;&amp; reg &lt; 0x17000 for Osprey) , </a>
<a name="ln2877">        ** and insert the configured delay if so. </a>
<a name="ln2878">        ** -this delay is not required for Osprey (EV#71410)</a>
<a name="ln2879">        */</a>
<a name="ln2880">        OS_REG_WRITE(ah, reg, val);</a>
<a name="ln2881">        WAR_6773(reg_writes);</a>
<a name="ln2882"> </a>
<a name="ln2883">    }</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">static inline HAL_STATUS</a>
<a name="ln2887">ar9300_process_ini(struct ath_hal *ah, struct ieee80211_channel *chan,</a>
<a name="ln2888">    HAL_CHANNEL_INTERNAL *ichan, HAL_HT_MACMODE macmode)</a>
<a name="ln2889">{</a>
<a name="ln2890">    int reg_writes = 0;</a>
<a name="ln2891">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2892">    u_int modes_index, modes_txgaintable_index = 0;</a>
<a name="ln2893">    int i;</a>
<a name="ln2894">    HAL_STATUS status;</a>
<a name="ln2895">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln2896">    /* Setup the indices for the next set of register array writes */</a>
<a name="ln2897">    /* TODO:</a>
<a name="ln2898">     * If the channel marker is indicative of the current mode rather</a>
<a name="ln2899">     * than capability, we do not need to check the phy mode below.</a>
<a name="ln2900">     */</a>
<a name="ln2901">#if 0</a>
<a name="ln2902">    switch (chan-&gt;channel_flags &amp; CHANNEL_ALL) {</a>
<a name="ln2903">    case CHANNEL_A:</a>
<a name="ln2904">    case CHANNEL_A_HT20:</a>
<a name="ln2905">        if (AR_SREV_SCORPION(ah)){</a>
<a name="ln2906">            if (chan-&gt;channel &lt;= 5350){</a>
<a name="ln2907">                modes_txgaintable_index = 1;</a>
<a name="ln2908">            }else if ((chan-&gt;channel &gt; 5350) &amp;&amp; (chan-&gt;channel &lt;= 5600)){</a>
<a name="ln2909">                modes_txgaintable_index = 3;</a>
<a name="ln2910">            }else if (chan-&gt;channel &gt; 5600){</a>
<a name="ln2911">                modes_txgaintable_index = 5;</a>
<a name="ln2912">            }</a>
<a name="ln2913">        }</a>
<a name="ln2914">        modes_index = 1;</a>
<a name="ln2915">        freq_index  = 1;</a>
<a name="ln2916">        break;</a>
<a name="ln2917"> </a>
<a name="ln2918">    case CHANNEL_A_HT40PLUS:</a>
<a name="ln2919">    case CHANNEL_A_HT40MINUS:</a>
<a name="ln2920">        if (AR_SREV_SCORPION(ah)){</a>
<a name="ln2921">            if (chan-&gt;channel &lt;= 5350){</a>
<a name="ln2922">                modes_txgaintable_index = 2;</a>
<a name="ln2923">            }else if ((chan-&gt;channel &gt; 5350) &amp;&amp; (chan-&gt;channel &lt;= 5600)){</a>
<a name="ln2924">                modes_txgaintable_index = 4;</a>
<a name="ln2925">            }else if (chan-&gt;channel &gt; 5600){</a>
<a name="ln2926">                modes_txgaintable_index = 6;</a>
<a name="ln2927">            }</a>
<a name="ln2928">        }</a>
<a name="ln2929">        modes_index = 2;</a>
<a name="ln2930">        freq_index  = 1;</a>
<a name="ln2931">        break;</a>
<a name="ln2932"> </a>
<a name="ln2933">    case CHANNEL_PUREG:</a>
<a name="ln2934">    case CHANNEL_G_HT20:</a>
<a name="ln2935">    case CHANNEL_B:</a>
<a name="ln2936">        if (AR_SREV_SCORPION(ah)){</a>
<a name="ln2937">            modes_txgaintable_index = 8;</a>
<a name="ln2938">        }else if (AR_SREV_HONEYBEE(ah)){</a>
<a name="ln2939">	    modes_txgaintable_index = 1;</a>
<a name="ln2940">	}</a>
<a name="ln2941">        modes_index = 4;</a>
<a name="ln2942">        freq_index  = 2;</a>
<a name="ln2943">        break;</a>
<a name="ln2944"> </a>
<a name="ln2945">    case CHANNEL_G_HT40PLUS:</a>
<a name="ln2946">    case CHANNEL_G_HT40MINUS:</a>
<a name="ln2947">        if (AR_SREV_SCORPION(ah)){</a>
<a name="ln2948">            modes_txgaintable_index = 7;</a>
<a name="ln2949">        }else if (AR_SREV_HONEYBEE(ah)){</a>
<a name="ln2950">            modes_txgaintable_index = 1;</a>
<a name="ln2951">        }</a>
<a name="ln2952">        modes_index = 3;</a>
<a name="ln2953">        freq_index  = 2;</a>
<a name="ln2954">        break;</a>
<a name="ln2955"> </a>
<a name="ln2956">    case CHANNEL_108G:</a>
<a name="ln2957">        modes_index = 5;</a>
<a name="ln2958">        freq_index  = 2;</a>
<a name="ln2959">        break;</a>
<a name="ln2960"> </a>
<a name="ln2961">    default:</a>
<a name="ln2962">        HALASSERT(0);</a>
<a name="ln2963">        return HAL_EINVAL;</a>
<a name="ln2964">    }</a>
<a name="ln2965">#endif</a>
<a name="ln2966"> </a>
<a name="ln2967">    /* FreeBSD */</a>
<a name="ln2968">    if (IS_CHAN_5GHZ(ichan)) {</a>
<a name="ln2969">        if (IEEE80211_IS_CHAN_HT40U(chan) || IEEE80211_IS_CHAN_HT40D(chan)) {</a>
<a name="ln2970">            if (AR_SREV_SCORPION(ah)){</a>
<a name="ln2971">                if (ichan-&gt;channel &lt;= 5350){</a>
<a name="ln2972">                    modes_txgaintable_index = 2;</a>
<a name="ln2973">                }else if ((ichan-&gt;channel &gt; 5350) &amp;&amp; (ichan-&gt;channel &lt;= 5600)){</a>
<a name="ln2974">                    modes_txgaintable_index = 4;</a>
<a name="ln2975">                }else if (ichan-&gt;channel &gt; 5600){</a>
<a name="ln2976">                    modes_txgaintable_index = 6;</a>
<a name="ln2977">                }</a>
<a name="ln2978">            }</a>
<a name="ln2979">            modes_index = 2;</a>
<a name="ln2980">        } else if (IEEE80211_IS_CHAN_A(chan) || IEEE80211_IS_CHAN_HT20(chan)) {</a>
<a name="ln2981">            if (AR_SREV_SCORPION(ah)){</a>
<a name="ln2982">                if (ichan-&gt;channel &lt;= 5350){</a>
<a name="ln2983">                    modes_txgaintable_index = 1;</a>
<a name="ln2984">                }else if ((ichan-&gt;channel &gt; 5350) &amp;&amp; (ichan-&gt;channel &lt;= 5600)){</a>
<a name="ln2985">                    modes_txgaintable_index = 3;</a>
<a name="ln2986">                }else if (ichan-&gt;channel &gt; 5600){</a>
<a name="ln2987">                    modes_txgaintable_index = 5;</a>
<a name="ln2988">                }</a>
<a name="ln2989">            }</a>
<a name="ln2990">            modes_index = 1;</a>
<a name="ln2991">        } else</a>
<a name="ln2992">            return HAL_EINVAL;</a>
<a name="ln2993">    } else if (IS_CHAN_2GHZ(ichan)) {</a>
<a name="ln2994">        if (IEEE80211_IS_CHAN_108G(chan)) {</a>
<a name="ln2995">            modes_index = 5;</a>
<a name="ln2996">        } else if (IEEE80211_IS_CHAN_HT40U(chan) || IEEE80211_IS_CHAN_HT40D(chan)) {</a>
<a name="ln2997">            if (AR_SREV_SCORPION(ah)){</a>
<a name="ln2998">                modes_txgaintable_index = 7;</a>
<a name="ln2999">            } else if (AR_SREV_HONEYBEE(ah)){</a>
<a name="ln3000">                modes_txgaintable_index = 1;</a>
<a name="ln3001">            }</a>
<a name="ln3002">            modes_index = 3;</a>
<a name="ln3003">        } else if (IEEE80211_IS_CHAN_HT20(chan) || IEEE80211_IS_CHAN_G(chan) || IEEE80211_IS_CHAN_B(chan) || IEEE80211_IS_CHAN_PUREG(chan)) {</a>
<a name="ln3004">            if (AR_SREV_SCORPION(ah)){</a>
<a name="ln3005">                modes_txgaintable_index = 8;</a>
<a name="ln3006">            } else if (AR_SREV_HONEYBEE(ah)){</a>
<a name="ln3007">                modes_txgaintable_index = 1;</a>
<a name="ln3008">            }</a>
<a name="ln3009">            modes_index = 4;</a>
<a name="ln3010">        } else</a>
<a name="ln3011">            return HAL_EINVAL;</a>
<a name="ln3012">    } else</a>
<a name="ln3013">            return HAL_EINVAL;</a>
<a name="ln3014"> </a>
<a name="ln3015">#if 0</a>
<a name="ln3016">    /* Set correct Baseband to analog shift setting to access analog chips. */</a>
<a name="ln3017">    OS_REG_WRITE(ah, AR_PHY(0), 0x00000007);</a>
<a name="ln3018">#endif</a>
<a name="ln3019"> </a>
<a name="ln3020">    HALDEBUG(ah, HAL_DEBUG_RESET,</a>
<a name="ln3021">        &quot;ar9300_process_ini: &quot;</a>
<a name="ln3022">        &quot;Skipping OS-REG-WRITE(ah, AR-PHY(0), 0x00000007)\n&quot;);</a>
<a name="ln3023">    HALDEBUG(ah, HAL_DEBUG_RESET,</a>
<a name="ln3024">        &quot;ar9300_process_ini: no ADDac programming\n&quot;);</a>
<a name="ln3025"> </a>
<a name="ln3026"> </a>
<a name="ln3027">    /*</a>
<a name="ln3028">     * Osprey 2.0+ - new INI format.</a>
<a name="ln3029">     * Each subsystem has a pre, core, and post array.</a>
<a name="ln3030">     */</a>
<a name="ln3031">    for (i = 0; i &lt; ATH_INI_NUM_SPLIT; i++) {</a>
<a name="ln3032">        ar9300_prog_ini(ah, &amp;ahp-&gt;ah_ini_soc[i], modes_index);</a>
<a name="ln3033">        ar9300_prog_ini(ah, &amp;ahp-&gt;ah_ini_mac[i], modes_index);</a>
<a name="ln3034">        ar9300_prog_ini(ah, &amp;ahp-&gt;ah_ini_bb[i], modes_index);</a>
<a name="ln3035">        ar9300_prog_ini(ah, &amp;ahp-&gt;ah_ini_radio[i], modes_index);</a>
<a name="ln3036">        if ((i == ATH_INI_POST) &amp;&amp; (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah))) {</a>
<a name="ln3037">            ar9300_prog_ini(ah, &amp;ahp-&gt;ah_ini_radio_post_sys2ant, modes_index);</a>
<a name="ln3038">        }</a>
<a name="ln3039"> </a>
<a name="ln3040">    }</a>
<a name="ln3041"> </a>
<a name="ln3042">	if (!(AR_SREV_SOC(ah))) {</a>
<a name="ln3043">			/* Doubler issue : Some board doesn't work well with MCS15. Turn off doubler after freq locking is complete*/</a>
<a name="ln3044">			//ath_hal_printf(ah, &quot;%s[%d] ==== before reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));</a>
<a name="ln3045">			OS_REG_RMW(ah, AR_PHY_65NM_CH0_RXTX2, 1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S | </a>
<a name="ln3046">			               1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S, 0); /*Set synthon, synthover */</a>
<a name="ln3047">			//ath_hal_printf(ah, &quot;%s[%d] ==== after reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));</a>
<a name="ln3048">			</a>
<a name="ln3049">			OS_REG_RMW(ah, AR_PHY_65NM_CH1_RXTX2, 1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S | </a>
<a name="ln3050">			               1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S, 0); /*Set synthon, synthover */</a>
<a name="ln3051">			OS_REG_RMW(ah, AR_PHY_65NM_CH2_RXTX2, 1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S | </a>
<a name="ln3052">			               1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S, 0); /*Set synthon, synthover */</a>
<a name="ln3053">			OS_DELAY(200);</a>
<a name="ln3054">			</a>
<a name="ln3055">			//ath_hal_printf(ah, &quot;%s[%d] ==== before reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));</a>
<a name="ln3056">			OS_REG_CLR_BIT(ah, AR_PHY_65NM_CH0_RXTX2, AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK); /* clr synthon */</a>
<a name="ln3057">			OS_REG_CLR_BIT(ah, AR_PHY_65NM_CH1_RXTX2, AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK); /* clr synthon */</a>
<a name="ln3058">			OS_REG_CLR_BIT(ah, AR_PHY_65NM_CH2_RXTX2, AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK); /* clr synthon */</a>
<a name="ln3059">			//ath_hal_printf(ah, &quot;%s[%d] ==== after reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));</a>
<a name="ln3060">			</a>
<a name="ln3061">			OS_DELAY(1);</a>
<a name="ln3062">			</a>
<a name="ln3063">			//ath_hal_printf(ah, &quot;%s[%d] ==== before reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));</a>
<a name="ln3064">			OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_RXTX2, AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK, 1); /* set synthon */</a>
<a name="ln3065">			OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH1_RXTX2, AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK, 1); /* set synthon */</a>
<a name="ln3066">			OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX2, AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK, 1); /* set synthon */</a>
<a name="ln3067">			//ath_hal_printf(ah, &quot;%s[%d] ==== after reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));</a>
<a name="ln3068">			</a>
<a name="ln3069">			OS_DELAY(200);</a>
<a name="ln3070">			</a>
<a name="ln3071">			//ath_hal_printf(ah, &quot;%s[%d] ==== before reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_SYNTH12, OS_REG_READ(ah, AR_PHY_65NM_CH0_SYNTH12));</a>
<a name="ln3072">			OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_SYNTH12, AR_PHY_65NM_CH0_SYNTH12_VREFMUL3, 0xf);</a>
<a name="ln3073">			//OS_REG_CLR_BIT(ah, AR_PHY_65NM_CH0_SYNTH12, 1&lt;&lt; 16); /* clr charge pump */</a>
<a name="ln3074">			//ath_hal_printf(ah, &quot;%s[%d] ==== After  reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_SYNTH12, OS_REG_READ(ah, AR_PHY_65NM_CH0_SYNTH12));</a>
<a name="ln3075">			</a>
<a name="ln3076">			OS_REG_RMW(ah, AR_PHY_65NM_CH0_RXTX2, 0, 1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S | </a>
<a name="ln3077">			               1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S); /*Clr synthon, synthover */</a>
<a name="ln3078">			OS_REG_RMW(ah, AR_PHY_65NM_CH1_RXTX2, 0, 1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S | </a>
<a name="ln3079">			               1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S); /*Clr synthon, synthover */</a>
<a name="ln3080">			OS_REG_RMW(ah, AR_PHY_65NM_CH2_RXTX2, 0, 1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHON_MASK_S | </a>
<a name="ln3081">			               1 &lt;&lt; AR_PHY_65NM_CH0_RXTX2_SYNTHOVR_MASK_S); /*Clr synthon, synthover */</a>
<a name="ln3082">			//ath_hal_printf(ah, &quot;%s[%d] ==== after reg[0x%08x] = 0x%08x\n&quot;, __func__, __LINE__, AR_PHY_65NM_CH0_RXTX2, OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2));</a>
<a name="ln3083">		}</a>
<a name="ln3084"> </a>
<a name="ln3085">    /* Write rxgain Array Parameters */</a>
<a name="ln3086">    REG_WRITE_ARRAY(&amp;ahp-&gt;ah_ini_modes_rxgain, 1, reg_writes);</a>
<a name="ln3087">    HALDEBUG(ah, HAL_DEBUG_RESET, &quot;ar9300_process_ini: Rx Gain programming\n&quot;);</a>
<a name="ln3088"> </a>
<a name="ln3089">    if (AR_SREV_JUPITER_20_OR_LATER(ah)) {</a>
<a name="ln3090">        /*</a>
<a name="ln3091">         * CUS217 mix LNA mode.</a>
<a name="ln3092">         */</a>
<a name="ln3093">        if (ar9300_rx_gain_index_get(ah) == 2) {</a>
<a name="ln3094">            REG_WRITE_ARRAY(&amp;ahp-&gt;ah_ini_modes_rxgain_bb_core, 1, reg_writes);</a>
<a name="ln3095">            REG_WRITE_ARRAY(&amp;ahp-&gt;ah_ini_modes_rxgain_bb_postamble,</a>
<a name="ln3096">                modes_index, reg_writes);</a>
<a name="ln3097">        }</a>
<a name="ln3098"> </a>
<a name="ln3099">        /*</a>
<a name="ln3100">         * 5G-XLNA</a>
<a name="ln3101">         */</a>
<a name="ln3102">        if ((ar9300_rx_gain_index_get(ah) == 2) ||</a>
<a name="ln3103">            (ar9300_rx_gain_index_get(ah) == 3)) {</a>
<a name="ln3104">            REG_WRITE_ARRAY(&amp;ahp-&gt;ah_ini_modes_rxgain_xlna, modes_index,</a>
<a name="ln3105">              reg_writes);</a>
<a name="ln3106">        }</a>
<a name="ln3107">    }</a>
<a name="ln3108"> </a>
<a name="ln3109">    if (AR_SREV_SCORPION(ah)) {</a>
<a name="ln3110">        /* Write rxgain bounds Array */</a>
<a name="ln3111">        REG_WRITE_ARRAY(&amp;ahp-&gt;ah_ini_modes_rxgain_bounds, modes_index, reg_writes);</a>
<a name="ln3112">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;ar9300_process_ini: Rx Gain table bounds programming\n&quot;);</a>
<a name="ln3113">    }</a>
<a name="ln3114">    /* UB124 xLNA settings */</a>
<a name="ln3115">    if (AR_SREV_WASP(ah) &amp;&amp; ar9300_rx_gain_index_get(ah) == 2) {</a>
<a name="ln3116">#define REG_WRITE(_reg,_val)    *((volatile u_int32_t *)(_reg)) = (_val);</a>
<a name="ln3117">#define REG_READ(_reg)          *((volatile u_int32_t *)(_reg))</a>
<a name="ln3118">        u_int32_t val;</a>
<a name="ln3119">        /* B8040000:  bit[0]=0, bit[3]=0; */</a>
<a name="ln3120">        val = REG_READ(0xB8040000);</a>
<a name="ln3121">        val &amp;= 0xfffffff6;</a>
<a name="ln3122">        REG_WRITE(0xB8040000, val);</a>
<a name="ln3123">        /* B804002c:  bit[31:24]=0x2e; bit[7:0]=0x2f; */</a>
<a name="ln3124">        val = REG_READ(0xB804002c);</a>
<a name="ln3125">        val &amp;= 0x00ffff00;</a>
<a name="ln3126">        val |= 0x2e00002f;</a>
<a name="ln3127">        REG_WRITE(0xB804002c, val);</a>
<a name="ln3128">        /* B804006c:  bit[1]=1; */</a>
<a name="ln3129">        val = REG_READ(0xB804006c);</a>
<a name="ln3130">        val |= 0x2;</a>
<a name="ln3131">        REG_WRITE(0xB804006c, val);</a>
<a name="ln3132">#undef REG_READ</a>
<a name="ln3133">#undef REG_WRITE</a>
<a name="ln3134">    }</a>
<a name="ln3135"> </a>
<a name="ln3136"> </a>
<a name="ln3137">    /* Write txgain Array Parameters */</a>
<a name="ln3138">    if (AR_SREV_SCORPION(ah) || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln3139">        REG_WRITE_ARRAY(&amp;ahp-&gt;ah_ini_modes_txgain, modes_txgaintable_index, </a>
<a name="ln3140">            reg_writes);</a>
<a name="ln3141">    }else{</a>
<a name="ln3142">        REG_WRITE_ARRAY(&amp;ahp-&gt;ah_ini_modes_txgain, modes_index, reg_writes);</a>
<a name="ln3143">    }</a>
<a name="ln3144">    HALDEBUG(ah, HAL_DEBUG_RESET, &quot;ar9300_process_ini: Tx Gain programming\n&quot;);</a>
<a name="ln3145"> </a>
<a name="ln3146"> </a>
<a name="ln3147">    /* For 5GHz channels requiring Fast Clock, apply different modal values */</a>
<a name="ln3148">    if (IS_5GHZ_FAST_CLOCK_EN(ah, chan)) {</a>
<a name="ln3149">        HALDEBUG(ah, HAL_DEBUG_RESET,</a>
<a name="ln3150">            &quot;%s: Fast clock enabled, use special ini values\n&quot;, __func__);</a>
<a name="ln3151">        REG_WRITE_ARRAY(&amp;ahp-&gt;ah_ini_modes_additional, modes_index, reg_writes);</a>
<a name="ln3152">    }</a>
<a name="ln3153"> </a>
<a name="ln3154">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah)) {</a>
<a name="ln3155">        HALDEBUG(ah, HAL_DEBUG_RESET,</a>
<a name="ln3156">            &quot;%s: use xtal ini for AH9300(ah)-&gt;clk_25mhz: %d\n&quot;,</a>
<a name="ln3157">            __func__, AH9300(ah)-&gt;clk_25mhz);</a>
<a name="ln3158">        REG_WRITE_ARRAY(</a>
<a name="ln3159">            &amp;ahp-&gt;ah_ini_modes_additional, 1/*modes_index*/, reg_writes);</a>
<a name="ln3160">    }</a>
<a name="ln3161"> </a>
<a name="ln3162">    if (AR_SREV_WASP(ah) &amp;&amp; (AH9300(ah)-&gt;clk_25mhz == 0)) {</a>
<a name="ln3163">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: Apply 40MHz ini settings\n&quot;, __func__);</a>
<a name="ln3164">        REG_WRITE_ARRAY(</a>
<a name="ln3165">            &amp;ahp-&gt;ah_ini_modes_additional_40mhz, 1/*modesIndex*/, reg_writes);</a>
<a name="ln3166">    }</a>
<a name="ln3167"> </a>
<a name="ln3168">    /* Handle Japan Channel 14 channel spreading */</a>
<a name="ln3169">    if (2484 == ichan-&gt;channel) {</a>
<a name="ln3170">        ar9300_prog_ini(ah, &amp;ahp-&gt;ah_ini_japan2484, 1);</a>
<a name="ln3171">    }</a>
<a name="ln3172"> </a>
<a name="ln3173">#if 0</a>
<a name="ln3174">    /* XXX TODO! */</a>
<a name="ln3175">    if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln3176">        ar9300_prog_ini(ah, &amp;ahp-&gt;ah_ini_BTCOEX_MAX_TXPWR, 1);</a>
<a name="ln3177">    }</a>
<a name="ln3178">#endif</a>
<a name="ln3179"> </a>
<a name="ln3180">    /* Override INI with chip specific configuration */</a>
<a name="ln3181">    ar9300_override_ini(ah, chan);</a>
<a name="ln3182"> </a>
<a name="ln3183">    /* Setup 11n MAC/Phy mode registers */</a>
<a name="ln3184">    ar9300_set_11n_regs(ah, chan, macmode);</a>
<a name="ln3185"> </a>
<a name="ln3186">    /*</a>
<a name="ln3187">     * Moved ar9300_init_chain_masks() here to ensure the swap bit is set before</a>
<a name="ln3188">     * the pdadc table is written.  Swap must occur before any radio dependent</a>
<a name="ln3189">     * replicated register access.  The pdadc curve addressing in particular</a>
<a name="ln3190">     * depends on the consistent setting of the swap bit.</a>
<a name="ln3191">     */</a>
<a name="ln3192">    ar9300_init_chain_masks(ah, ahp-&gt;ah_rx_chainmask, ahp-&gt;ah_tx_chainmask);</a>
<a name="ln3193"> </a>
<a name="ln3194">    /*</a>
<a name="ln3195">     * Setup the transmit power values.</a>
<a name="ln3196">     *</a>
<a name="ln3197">     * After the public to private hal channel mapping, ichan contains the</a>
<a name="ln3198">     * valid regulatory power value.</a>
<a name="ln3199">     * ath_hal_getctl and ath_hal_getantennaallowed look up ichan from chan.</a>
<a name="ln3200">     */</a>
<a name="ln3201">    status = ar9300_eeprom_set_transmit_power(ah, &amp;ahp-&gt;ah_eeprom, chan,</a>
<a name="ln3202">             ath_hal_getctl(ah, chan), ath_hal_getantennaallowed(ah, chan),</a>
<a name="ln3203">             ath_hal_get_twice_max_regpower(ahpriv, ichan, chan),</a>
<a name="ln3204">             AH_MIN(MAX_RATE_POWER, ahpriv-&gt;ah_powerLimit));</a>
<a name="ln3205">    if (status != HAL_OK) {</a>
<a name="ln3206">        HALDEBUG(ah, HAL_DEBUG_POWER_MGMT,</a>
<a name="ln3207">            &quot;%s: error init'ing transmit power\n&quot;, __func__);</a>
<a name="ln3208">        return HAL_EIO;</a>
<a name="ln3209">    }</a>
<a name="ln3210"> </a>
<a name="ln3211"> </a>
<a name="ln3212">    return HAL_OK;</a>
<a name="ln3213">#undef N</a>
<a name="ln3214">}</a>
<a name="ln3215"> </a>
<a name="ln3216">/* ar9300_is_cal_supp</a>
<a name="ln3217"> * Determine if calibration is supported by device and channel flags</a>
<a name="ln3218"> */</a>
<a name="ln3219">inline static HAL_BOOL</a>
<a name="ln3220">ar9300_is_cal_supp(struct ath_hal *ah, const struct ieee80211_channel *chan,</a>
<a name="ln3221">    HAL_CAL_TYPES cal_type) </a>
<a name="ln3222">{</a>
<a name="ln3223">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3224">    HAL_BOOL retval = AH_FALSE;</a>
<a name="ln3225"> </a>
<a name="ln3226">    switch (cal_type &amp; ahp-&gt;ah_supp_cals) {</a>
<a name="ln3227">    case IQ_MISMATCH_CAL:</a>
<a name="ln3228">        /* Run IQ Mismatch for non-CCK only */</a>
<a name="ln3229">        if (!IEEE80211_IS_CHAN_B(chan)) {</a>
<a name="ln3230">            retval = AH_TRUE;</a>
<a name="ln3231">        }</a>
<a name="ln3232">        break;</a>
<a name="ln3233">    case TEMP_COMP_CAL:</a>
<a name="ln3234">        retval = AH_TRUE;</a>
<a name="ln3235">        break;</a>
<a name="ln3236">    }</a>
<a name="ln3237"> </a>
<a name="ln3238">    return retval;</a>
<a name="ln3239">}</a>
<a name="ln3240"> </a>
<a name="ln3241"> </a>
<a name="ln3242">#if 0</a>
<a name="ln3243">/* ar9285_pa_cal</a>
<a name="ln3244"> * PA Calibration for Kite 1.1 and later versions of Kite.</a>
<a name="ln3245"> * - from system's team.</a>
<a name="ln3246"> */</a>
<a name="ln3247">static inline void</a>
<a name="ln3248">ar9285_pa_cal(struct ath_hal *ah)</a>
<a name="ln3249">{</a>
<a name="ln3250">    u_int32_t reg_val;</a>
<a name="ln3251">    int i, lo_gn, offs_6_1, offs_0;</a>
<a name="ln3252">    u_int8_t reflo;</a>
<a name="ln3253">    u_int32_t phy_test2_reg_val, phy_adc_ctl_reg_val;</a>
<a name="ln3254">    u_int32_t an_top2_reg_val, phy_tst_dac_reg_val;</a>
<a name="ln3255"> </a>
<a name="ln3256"> </a>
<a name="ln3257">    /* Kite 1.1 WAR for Bug 35666 </a>
<a name="ln3258">     * Increase the LDO value to 1.28V before accessing analog Reg */</a>
<a name="ln3259">    if (AR_SREV_KITE_11(ah)) {</a>
<a name="ln3260">        OS_REG_WRITE(ah, AR9285_AN_TOP4, (AR9285_AN_TOP4_DEFAULT | 0x14) );</a>
<a name="ln3261">    }</a>
<a name="ln3262">    an_top2_reg_val = OS_REG_READ(ah, AR9285_AN_TOP2);</a>
<a name="ln3263"> </a>
<a name="ln3264">    /* set pdv2i pdrxtxbb */</a>
<a name="ln3265">    reg_val = OS_REG_READ(ah, AR9285_AN_RXTXBB1);</a>
<a name="ln3266">    reg_val |= ((0x1 &lt;&lt; 5) | (0x1 &lt;&lt; 7));</a>
<a name="ln3267">    OS_REG_WRITE(ah, AR9285_AN_RXTXBB1, reg_val);</a>
<a name="ln3268"> </a>
<a name="ln3269">    /* clear pwddb */</a>
<a name="ln3270">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G7);</a>
<a name="ln3271">    reg_val &amp;= 0xfffffffd;</a>
<a name="ln3272">    OS_REG_WRITE(ah, AR9285_AN_RF2G7, reg_val);</a>
<a name="ln3273"> </a>
<a name="ln3274">    /* clear enpacal */</a>
<a name="ln3275">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G1);</a>
<a name="ln3276">    reg_val &amp;= 0xfffff7ff;</a>
<a name="ln3277">    OS_REG_WRITE(ah, AR9285_AN_RF2G1, reg_val);</a>
<a name="ln3278"> </a>
<a name="ln3279">    /* set offcal */</a>
<a name="ln3280">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G2);</a>
<a name="ln3281">    reg_val |= (0x1 &lt;&lt; 12);</a>
<a name="ln3282">    OS_REG_WRITE(ah, AR9285_AN_RF2G2, reg_val);</a>
<a name="ln3283"> </a>
<a name="ln3284">    /* set pdpadrv1=pdpadrv2=pdpaout=1 */</a>
<a name="ln3285">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G1);</a>
<a name="ln3286">    reg_val |= (0x7 &lt;&lt; 23);</a>
<a name="ln3287">    OS_REG_WRITE(ah, AR9285_AN_RF2G1, reg_val);</a>
<a name="ln3288"> </a>
<a name="ln3289">    /* Read back reflo, increase it by 1 and write it. */</a>
<a name="ln3290">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);</a>
<a name="ln3291">    reflo = ((reg_val &gt;&gt; 26) &amp; 0x7);</a>
<a name="ln3292">    </a>
<a name="ln3293">    if (reflo &lt; 0x7) {</a>
<a name="ln3294">        reflo++;</a>
<a name="ln3295">    }</a>
<a name="ln3296">    reg_val = ((reg_val &amp; 0xe3ffffff) | (reflo &lt;&lt; 26));</a>
<a name="ln3297">    OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);</a>
<a name="ln3298"> </a>
<a name="ln3299">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);</a>
<a name="ln3300">    reflo = ((reg_val &gt;&gt; 26) &amp; 0x7);</a>
<a name="ln3301"> </a>
<a name="ln3302">    /* use TX single carrier to transmit</a>
<a name="ln3303">     * dac const</a>
<a name="ln3304">     * reg. 15</a>
<a name="ln3305">     */</a>
<a name="ln3306">    phy_tst_dac_reg_val = OS_REG_READ(ah, AR_PHY_TSTDAC_CONST);</a>
<a name="ln3307">    OS_REG_WRITE(ah, AR_PHY_TSTDAC_CONST, ((0x7ff &lt;&lt; 11) | 0x7ff)); </a>
<a name="ln3308">    reg_val = OS_REG_READ(ah, AR_PHY_TSTDAC_CONST);</a>
<a name="ln3309"> </a>
<a name="ln3310">    /* source is dac const</a>
<a name="ln3311">     * reg. 2</a>
<a name="ln3312">     */</a>
<a name="ln3313">    phy_test2_reg_val = OS_REG_READ(ah, AR_PHY_TEST2);</a>
<a name="ln3314">    OS_REG_WRITE(ah, AR_PHY_TEST2, ((0x1 &lt;&lt; 7) | (0x1 &lt;&lt; 1)));</a>
<a name="ln3315">    reg_val = OS_REG_READ(ah, AR_PHY_TEST2);</a>
<a name="ln3316"> </a>
<a name="ln3317">    /* set dac on</a>
<a name="ln3318">     * reg. 11</a>
<a name="ln3319">     */</a>
<a name="ln3320">    phy_adc_ctl_reg_val = OS_REG_READ(ah, AR_PHY_ADC_CTL);</a>
<a name="ln3321">    OS_REG_WRITE(ah, AR_PHY_ADC_CTL, 0x80008000);</a>
<a name="ln3322">    reg_val = OS_REG_READ(ah, AR_PHY_ADC_CTL);</a>
<a name="ln3323"> </a>
<a name="ln3324">    OS_REG_WRITE(ah, AR9285_AN_TOP2, (0x1 &lt;&lt; 27) | (0x1 &lt;&lt; 17) | (0x1 &lt;&lt; 16) |</a>
<a name="ln3325">              (0x1 &lt;&lt; 14) | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 11) |</a>
<a name="ln3326">              (0x1 &lt;&lt; 7) | (0x1 &lt;&lt; 5));</a>
<a name="ln3327"> </a>
<a name="ln3328">    OS_DELAY(10); /* 10 usec */</a>
<a name="ln3329"> </a>
<a name="ln3330">    /* clear off[6:0] */</a>
<a name="ln3331">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G6);</a>
<a name="ln3332">    reg_val &amp;= 0xfc0fffff;</a>
<a name="ln3333">    OS_REG_WRITE(ah, AR9285_AN_RF2G6, reg_val);</a>
<a name="ln3334">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);</a>
<a name="ln3335">    reg_val &amp;= 0xfdffffff;</a>
<a name="ln3336">    OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);</a>
<a name="ln3337"> </a>
<a name="ln3338">    offs_6_1 = 0;</a>
<a name="ln3339">    for (i = 6; i &gt; 0; i--) {</a>
<a name="ln3340">        /* sef off[$k]==1 */</a>
<a name="ln3341">        reg_val = OS_REG_READ(ah, AR9285_AN_RF2G6);</a>
<a name="ln3342">        reg_val &amp;= 0xfc0fffff;</a>
<a name="ln3343">        reg_val = reg_val | (0x1 &lt;&lt; (19 + i)) | ((offs_6_1) &lt;&lt; 20);</a>
<a name="ln3344">        OS_REG_WRITE(ah, AR9285_AN_RF2G6, reg_val);</a>
<a name="ln3345">        lo_gn = (OS_REG_READ(ah, AR9285_AN_RF2G9)) &amp; 0x1;</a>
<a name="ln3346">        offs_6_1 = offs_6_1 | (lo_gn &lt;&lt; (i - 1));</a>
<a name="ln3347">    }</a>
<a name="ln3348"> </a>
<a name="ln3349">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G6);</a>
<a name="ln3350">    reg_val &amp;= 0xfc0fffff;</a>
<a name="ln3351">    reg_val = reg_val | ((offs_6_1 - 1) &lt;&lt; 20);</a>
<a name="ln3352">    OS_REG_WRITE(ah, AR9285_AN_RF2G6, reg_val);</a>
<a name="ln3353"> </a>
<a name="ln3354">    /* set off_0=1; */</a>
<a name="ln3355">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);</a>
<a name="ln3356">    reg_val &amp;= 0xfdffffff;</a>
<a name="ln3357">    reg_val = reg_val | (0x1 &lt;&lt; 25);</a>
<a name="ln3358">    OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);</a>
<a name="ln3359"> </a>
<a name="ln3360">    lo_gn = OS_REG_READ(ah, AR9285_AN_RF2G9) &amp; 0x1;</a>
<a name="ln3361">    offs_0 = lo_gn;</a>
<a name="ln3362"> </a>
<a name="ln3363">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);</a>
<a name="ln3364">    reg_val &amp;= 0xfdffffff;</a>
<a name="ln3365">    reg_val = reg_val | (offs_0 &lt;&lt; 25);</a>
<a name="ln3366">    OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);</a>
<a name="ln3367"> </a>
<a name="ln3368">    /* clear pdv2i */</a>
<a name="ln3369">    reg_val = OS_REG_READ(ah, AR9285_AN_RXTXBB1);</a>
<a name="ln3370">    reg_val &amp;= 0xffffff5f;</a>
<a name="ln3371">    OS_REG_WRITE(ah, AR9285_AN_RXTXBB1, reg_val);</a>
<a name="ln3372"> </a>
<a name="ln3373">    /* set enpacal */</a>
<a name="ln3374">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G1);</a>
<a name="ln3375">    reg_val |= (0x1 &lt;&lt; 11);</a>
<a name="ln3376">    OS_REG_WRITE(ah, AR9285_AN_RF2G1, reg_val);</a>
<a name="ln3377"> </a>
<a name="ln3378">    /* clear offcal */</a>
<a name="ln3379">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G2);</a>
<a name="ln3380">    reg_val &amp;= 0xffffefff;</a>
<a name="ln3381">    OS_REG_WRITE(ah, AR9285_AN_RF2G2, reg_val);</a>
<a name="ln3382"> </a>
<a name="ln3383">    /* set pdpadrv1=pdpadrv2=pdpaout=0 */</a>
<a name="ln3384">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G1);</a>
<a name="ln3385">    reg_val &amp;= 0xfc7fffff;</a>
<a name="ln3386">    OS_REG_WRITE(ah, AR9285_AN_RF2G1, reg_val);</a>
<a name="ln3387"> </a>
<a name="ln3388">    /* Read back reflo, decrease it by 1 and write it. */</a>
<a name="ln3389">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);</a>
<a name="ln3390">    reflo = (reg_val &gt;&gt; 26) &amp; 0x7;</a>
<a name="ln3391">    if (reflo) {</a>
<a name="ln3392">        reflo--;</a>
<a name="ln3393">    }</a>
<a name="ln3394">    reg_val = ((reg_val &amp; 0xe3ffffff) | (reflo &lt;&lt; 26));</a>
<a name="ln3395">    OS_REG_WRITE(ah, AR9285_AN_RF2G3, reg_val);</a>
<a name="ln3396">    reg_val = OS_REG_READ(ah, AR9285_AN_RF2G3);</a>
<a name="ln3397">    reflo = (reg_val &gt;&gt; 26) &amp; 0x7;</a>
<a name="ln3398"> </a>
<a name="ln3399">    /* write back registers */</a>
<a name="ln3400">    OS_REG_WRITE(ah, AR_PHY_TSTDAC_CONST, phy_tst_dac_reg_val);</a>
<a name="ln3401">    OS_REG_WRITE(ah, AR_PHY_TEST2, phy_test2_reg_val);</a>
<a name="ln3402">    OS_REG_WRITE(ah, AR_PHY_ADC_CTL, phy_adc_ctl_reg_val);</a>
<a name="ln3403">    OS_REG_WRITE(ah, AR9285_AN_TOP2, an_top2_reg_val);</a>
<a name="ln3404"> </a>
<a name="ln3405">    /* Kite 1.1 WAR for Bug 35666 </a>
<a name="ln3406">     * Decrease the LDO value back to 1.20V */</a>
<a name="ln3407">    if (AR_SREV_KITE_11(ah)) {</a>
<a name="ln3408">        OS_REG_WRITE(ah, AR9285_AN_TOP4, AR9285_AN_TOP4_DEFAULT);</a>
<a name="ln3409">    }</a>
<a name="ln3410">}</a>
<a name="ln3411">#endif</a>
<a name="ln3412"> </a>
<a name="ln3413">/* ar9300_run_init_cals</a>
<a name="ln3414"> * Runs non-periodic calibrations</a>
<a name="ln3415"> */</a>
<a name="ln3416">inline static HAL_BOOL</a>
<a name="ln3417">ar9300_run_init_cals(struct ath_hal *ah, int init_cal_count)</a>
<a name="ln3418">{</a>
<a name="ln3419">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3420">    HAL_CHANNEL_INTERNAL ichan; /* bogus */</a>
<a name="ln3421">    HAL_BOOL is_cal_done;</a>
<a name="ln3422">    HAL_CAL_LIST *curr_cal;</a>
<a name="ln3423">    const HAL_PERCAL_DATA *cal_data;</a>
<a name="ln3424">    int i;</a>
<a name="ln3425"> </a>
<a name="ln3426">    curr_cal = ahp-&gt;ah_cal_list_curr;</a>
<a name="ln3427">    if (curr_cal == AH_NULL) {</a>
<a name="ln3428">        return AH_FALSE;</a>
<a name="ln3429">    }</a>
<a name="ln3430">    cal_data = curr_cal-&gt;cal_data;</a>
<a name="ln3431">    ichan.calValid = 0;</a>
<a name="ln3432"> </a>
<a name="ln3433">    for (i = 0; i &lt; init_cal_count; i++) {</a>
<a name="ln3434">        /* Reset this Cal */</a>
<a name="ln3435">        ar9300_reset_calibration(ah, curr_cal);</a>
<a name="ln3436">        /* Poll for offset calibration complete */</a>
<a name="ln3437">        if (!ath_hal_wait(</a>
<a name="ln3438">                ah, AR_PHY_TIMING4, AR_PHY_TIMING4_DO_CAL, 0))</a>
<a name="ln3439">        {</a>
<a name="ln3440">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3441">                &quot;%s: Cal %d failed to complete in 100ms.\n&quot;,</a>
<a name="ln3442">                __func__, curr_cal-&gt;cal_data-&gt;cal_type);</a>
<a name="ln3443">            /* Re-initialize list pointers for periodic cals */</a>
<a name="ln3444">            ahp-&gt;ah_cal_list = ahp-&gt;ah_cal_list_last = ahp-&gt;ah_cal_list_curr</a>
<a name="ln3445">                = AH_NULL;</a>
<a name="ln3446">            return AH_FALSE;</a>
<a name="ln3447">        } </a>
<a name="ln3448">        /* Run this cal */</a>
<a name="ln3449">        ar9300_per_calibration(</a>
<a name="ln3450">            ah, &amp;ichan, ahp-&gt;ah_rx_chainmask, curr_cal, &amp;is_cal_done);</a>
<a name="ln3451">        if (is_cal_done == AH_FALSE) {</a>
<a name="ln3452">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3453">                &quot;%s: Not able to run Init Cal %d.\n&quot;, __func__,</a>
<a name="ln3454">                curr_cal-&gt;cal_data-&gt;cal_type);</a>
<a name="ln3455">        }</a>
<a name="ln3456">        if (curr_cal-&gt;cal_next) {</a>
<a name="ln3457">            curr_cal = curr_cal-&gt;cal_next;</a>
<a name="ln3458">        }</a>
<a name="ln3459">    }</a>
<a name="ln3460"> </a>
<a name="ln3461">    /* Re-initialize list pointers for periodic cals */</a>
<a name="ln3462">    ahp-&gt;ah_cal_list = ahp-&gt;ah_cal_list_last = ahp-&gt;ah_cal_list_curr = AH_NULL;</a>
<a name="ln3463">    return AH_TRUE;</a>
<a name="ln3464">}</a>
<a name="ln3465"> </a>
<a name="ln3466">#if 0</a>
<a name="ln3467">static void</a>
<a name="ln3468">ar9300_tx_carrier_leak_war(struct ath_hal *ah)</a>
<a name="ln3469">{</a>
<a name="ln3470">    unsigned long tx_gain_table_max;</a>
<a name="ln3471">    unsigned long reg_bb_cl_map_0_b0 = 0xffffffff;</a>
<a name="ln3472">    unsigned long reg_bb_cl_map_1_b0 = 0xffffffff;</a>
<a name="ln3473">    unsigned long reg_bb_cl_map_2_b0 = 0xffffffff;</a>
<a name="ln3474">    unsigned long reg_bb_cl_map_3_b0 = 0xffffffff;</a>
<a name="ln3475">    unsigned long tx_gain, cal_run = 0;</a>
<a name="ln3476">    unsigned long cal_gain[AR_PHY_TPC_7_TX_GAIN_TABLE_MAX + 1];</a>
<a name="ln3477">    unsigned long cal_gain_index[AR_PHY_TPC_7_TX_GAIN_TABLE_MAX + 1];</a>
<a name="ln3478">    unsigned long new_gain[AR_PHY_TPC_7_TX_GAIN_TABLE_MAX + 1];</a>
<a name="ln3479">    int i, j;</a>
<a name="ln3480"> </a>
<a name="ln3481">    OS_MEMSET(new_gain, 0, sizeof(new_gain));</a>
<a name="ln3482">    /*printf(&quot;     Running TxCarrierLeakWAR\n&quot;);*/</a>
<a name="ln3483"> </a>
<a name="ln3484">    /* process tx gain table, we use cl_map_hw_gen=0. */</a>
<a name="ln3485">    OS_REG_RMW_FIELD(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_MAP_HW_GEN, 0);</a>
<a name="ln3486"> </a>
<a name="ln3487">	//the table we used is txbb_gc[2:0], 1dB[2:1].</a>
<a name="ln3488">    tx_gain_table_max = OS_REG_READ_FIELD(ah,</a>
<a name="ln3489">        AR_PHY_TPC_7, AR_PHY_TPC_7_TX_GAIN_TABLE_MAX);</a>
<a name="ln3490"> </a>
<a name="ln3491">    for (i = 0; i &lt;= tx_gain_table_max; i++) {</a>
<a name="ln3492">        tx_gain = OS_REG_READ(ah, AR_PHY_TXGAIN_TAB(1) + i * 4);</a>
<a name="ln3493">        cal_gain[i] = (((tx_gain &gt;&gt; 5)&amp; 0x7) &lt;&lt; 2) |</a>
<a name="ln3494">            (((tx_gain &gt;&gt; 1) &amp; 0x3) &lt;&lt; 0);</a>
<a name="ln3495">        if (i == 0) {</a>
<a name="ln3496">            cal_gain_index[i] = cal_run;</a>
<a name="ln3497">            new_gain[i] = 1;</a>
<a name="ln3498">            cal_run++;</a>
<a name="ln3499">        } else {</a>
<a name="ln3500">            new_gain[i] = 1;</a>
<a name="ln3501">            for (j = 0; j &lt; i; j++) {</a>
<a name="ln3502">                /*</a>
<a name="ln3503">                printf(&quot;i=%d, j=%d cal_gain[$i]=0x%04x\n&quot;, i, j, cal_gain[i]);</a>
<a name="ln3504">                 */</a>
<a name="ln3505">                if (new_gain[i]) {</a>
<a name="ln3506">                    if ((cal_gain[i] != cal_gain[j])) {</a>
<a name="ln3507">                        new_gain[i] = 1;</a>
<a name="ln3508">                    } else {</a>
<a name="ln3509">                        /* if old gain found, use old cal_run value. */</a>
<a name="ln3510">                        new_gain[i] = 0;</a>
<a name="ln3511">                        cal_gain_index[i] = cal_gain_index[j];</a>
<a name="ln3512">                    }</a>
<a name="ln3513">                }</a>
<a name="ln3514">            }</a>
<a name="ln3515">            /* if new gain found, increase cal_run */</a>
<a name="ln3516">            if (new_gain[i] == 1) {</a>
<a name="ln3517">                cal_gain_index[i] = cal_run;</a>
<a name="ln3518">                cal_run++;</a>
<a name="ln3519">            }</a>
<a name="ln3520">        }</a>
<a name="ln3521"> </a>
<a name="ln3522">        reg_bb_cl_map_0_b0 = (reg_bb_cl_map_0_b0 &amp; ~(0x1 &lt;&lt; i)) |</a>
<a name="ln3523">            ((cal_gain_index[i] &gt;&gt; 0 &amp; 0x1) &lt;&lt; i);</a>
<a name="ln3524">        reg_bb_cl_map_1_b0 = (reg_bb_cl_map_1_b0 &amp; ~(0x1 &lt;&lt; i)) |</a>
<a name="ln3525">            ((cal_gain_index[i] &gt;&gt; 1 &amp; 0x1) &lt;&lt; i);</a>
<a name="ln3526">        reg_bb_cl_map_2_b0 = (reg_bb_cl_map_2_b0 &amp; ~(0x1 &lt;&lt; i)) |</a>
<a name="ln3527">            ((cal_gain_index[i] &gt;&gt; 2 &amp; 0x1) &lt;&lt; i);</a>
<a name="ln3528">        reg_bb_cl_map_3_b0 = (reg_bb_cl_map_3_b0 &amp; ~(0x1 &lt;&lt; i)) |</a>
<a name="ln3529">            ((cal_gain_index[i] &gt;&gt; 3 &amp; 0x1) &lt;&lt; i);</a>
<a name="ln3530"> </a>
<a name="ln3531">        /*</a>
<a name="ln3532">        printf(&quot;i=%2d, cal_gain[$i]= 0x%04x, cal_run= %d, &quot;</a>
<a name="ln3533">            &quot;cal_gain_index[i]=%d, new_gain[i] = %d\n&quot;,</a>
<a name="ln3534">            i, cal_gain[i], cal_run, cal_gain_index[i], new_gain[i]);</a>
<a name="ln3535">         */</a>
<a name="ln3536">    }</a>
<a name="ln3537">    OS_REG_WRITE(ah, AR_PHY_CL_MAP_0_B0, reg_bb_cl_map_0_b0);</a>
<a name="ln3538">    OS_REG_WRITE(ah, AR_PHY_CL_MAP_1_B0, reg_bb_cl_map_1_b0);</a>
<a name="ln3539">    OS_REG_WRITE(ah, AR_PHY_CL_MAP_2_B0, reg_bb_cl_map_2_b0);</a>
<a name="ln3540">    OS_REG_WRITE(ah, AR_PHY_CL_MAP_3_B0, reg_bb_cl_map_3_b0);</a>
<a name="ln3541">    if (AR_SREV_WASP(ah)) {</a>
<a name="ln3542">        OS_REG_WRITE(ah, AR_PHY_CL_MAP_0_B1, reg_bb_cl_map_0_b0);</a>
<a name="ln3543">        OS_REG_WRITE(ah, AR_PHY_CL_MAP_1_B1, reg_bb_cl_map_1_b0);</a>
<a name="ln3544">        OS_REG_WRITE(ah, AR_PHY_CL_MAP_2_B1, reg_bb_cl_map_2_b0);</a>
<a name="ln3545">        OS_REG_WRITE(ah, AR_PHY_CL_MAP_3_B1, reg_bb_cl_map_3_b0);</a>
<a name="ln3546">    }</a>
<a name="ln3547">}</a>
<a name="ln3548">#endif</a>
<a name="ln3549"> </a>
<a name="ln3550"> </a>
<a name="ln3551">static inline void</a>
<a name="ln3552">ar9300_invalidate_saved_cals(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *ichan)</a>
<a name="ln3553">{</a>
<a name="ln3554">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln3555">    if (AH_PRIVATE(ah)-&gt;ah_config.ath_hal_cal_reuse &amp;</a>
<a name="ln3556">        ATH_CAL_REUSE_REDO_IN_FULL_RESET)</a>
<a name="ln3557">    {</a>
<a name="ln3558">        ichan-&gt;one_time_txiqcal_done = AH_FALSE;</a>
<a name="ln3559">        ichan-&gt;one_time_txclcal_done = AH_FALSE;</a>
<a name="ln3560">    }</a>
<a name="ln3561">#endif</a>
<a name="ln3562">}</a>
<a name="ln3563"> </a>
<a name="ln3564">static inline HAL_BOOL</a>
<a name="ln3565">ar9300_restore_rtt_cals(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *ichan)</a>
<a name="ln3566">{</a>
<a name="ln3567">    HAL_BOOL restore_status = AH_FALSE;</a>
<a name="ln3568"> </a>
<a name="ln3569">    return restore_status;</a>
<a name="ln3570">}</a>
<a name="ln3571"> </a>
<a name="ln3572">/* ar9300_init_cal</a>
<a name="ln3573"> * Initialize Calibration infrastructure</a>
<a name="ln3574"> */</a>
<a name="ln3575">static inline HAL_BOOL</a>
<a name="ln3576">ar9300_init_cal_internal(struct ath_hal *ah, struct ieee80211_channel *chan,</a>
<a name="ln3577">                         HAL_CHANNEL_INTERNAL *ichan,</a>
<a name="ln3578">                         HAL_BOOL enable_rtt, HAL_BOOL do_rtt_cal, HAL_BOOL skip_if_none, HAL_BOOL apply_last_iqcorr)</a>
<a name="ln3579">{</a>
<a name="ln3580">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3581">    HAL_BOOL txiqcal_success_flag = AH_FALSE;</a>
<a name="ln3582">    HAL_BOOL cal_done = AH_FALSE;</a>
<a name="ln3583">    int iqcal_idx = 0;</a>
<a name="ln3584">    HAL_BOOL do_sep_iq_cal = AH_FALSE;</a>
<a name="ln3585">    HAL_BOOL do_agc_cal = do_rtt_cal;</a>
<a name="ln3586">    HAL_BOOL is_cal_reusable = AH_TRUE;</a>
<a name="ln3587">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln3588">    HAL_BOOL      cal_reuse_enable = AH_PRIVATE(ah)-&gt;ah_config.ath_hal_cal_reuse &amp;</a>
<a name="ln3589">                                 ATH_CAL_REUSE_ENABLE;</a>
<a name="ln3590">    HAL_BOOL      clc_success = AH_FALSE;</a>
<a name="ln3591">    int32_t   ch_idx, j, cl_tab_reg;</a>
<a name="ln3592">    u_int32_t BB_cl_tab_entry = MAX_BB_CL_TABLE_ENTRY;</a>
<a name="ln3593">    u_int32_t BB_cl_tab_b[AR9300_MAX_CHAINS] = {</a>
<a name="ln3594">                    AR_PHY_CL_TAB_0,</a>
<a name="ln3595">                    AR_PHY_CL_TAB_1,</a>
<a name="ln3596">                    AR_PHY_CL_TAB_2</a>
<a name="ln3597">                };</a>
<a name="ln3598">#endif</a>
<a name="ln3599"> </a>
<a name="ln3600">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln3601">        /* Hornet: 1 x 1 */</a>
<a name="ln3602">        ahp-&gt;ah_rx_cal_chainmask = 0x1;</a>
<a name="ln3603">        ahp-&gt;ah_tx_cal_chainmask = 0x1;</a>
<a name="ln3604">    } else if (AR_SREV_WASP(ah) || AR_SREV_JUPITER(ah) || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln3605">        /* Wasp/Jupiter: 2 x 2 */</a>
<a name="ln3606">        ahp-&gt;ah_rx_cal_chainmask = 0x3;</a>
<a name="ln3607">        ahp-&gt;ah_tx_cal_chainmask = 0x3;</a>
<a name="ln3608">    } else {</a>
<a name="ln3609">        /*</a>
<a name="ln3610">         * Osprey needs to be configured for the correct chain mode</a>
<a name="ln3611">         * before running AGC/TxIQ cals.</a>
<a name="ln3612">         */</a>
<a name="ln3613">        if (ahp-&gt;ah_enterprise_mode &amp; AR_ENT_OTP_CHAIN2_DISABLE) {</a>
<a name="ln3614">            /* chain 2 disabled - 2 chain mode */</a>
<a name="ln3615">            ahp-&gt;ah_rx_cal_chainmask = 0x3;</a>
<a name="ln3616">            ahp-&gt;ah_tx_cal_chainmask = 0x3;</a>
<a name="ln3617">        } else {</a>
<a name="ln3618">            ahp-&gt;ah_rx_cal_chainmask = 0x7;</a>
<a name="ln3619">            ahp-&gt;ah_tx_cal_chainmask = 0x7;</a>
<a name="ln3620">        }</a>
<a name="ln3621">    }</a>
<a name="ln3622">        ar9300_init_chain_masks(ah, ahp-&gt;ah_rx_cal_chainmask, ahp-&gt;ah_tx_cal_chainmask);</a>
<a name="ln3623"> </a>
<a name="ln3624"> </a>
<a name="ln3625">    if (ahp-&gt;tx_cl_cal_enable) {</a>
<a name="ln3626">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln3627">        /* disable Carrie Leak or set do_agc_cal accordingly */</a>
<a name="ln3628">        if (cal_reuse_enable &amp;&amp; ichan-&gt;one_time_txclcal_done)</a>
<a name="ln3629">        {</a>
<a name="ln3630">            OS_REG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);</a>
<a name="ln3631">        } else</a>
<a name="ln3632">#endif /* ATH_SUPPORT_CAL_REUSE */</a>
<a name="ln3633">        {</a>
<a name="ln3634">            OS_REG_SET_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);</a>
<a name="ln3635">            do_agc_cal = AH_TRUE;</a>
<a name="ln3636">        }</a>
<a name="ln3637">    }</a>
<a name="ln3638"> </a>
<a name="ln3639">    /* Do Tx IQ Calibration here for osprey hornet and wasp */</a>
<a name="ln3640">    /* XXX: For initial wasp bringup - check and enable this */</a>
<a name="ln3641">    /* EV 74233: Tx IQ fails to complete for half/quarter rates */</a>
<a name="ln3642">    if (!(IEEE80211_IS_CHAN_HALF(chan) || IEEE80211_IS_CHAN_QUARTER(chan))) {</a>
<a name="ln3643">        if (ahp-&gt;tx_iq_cal_enable) {</a>
<a name="ln3644">            /* this should be eventually moved to INI file */</a>
<a name="ln3645">            OS_REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_1(ah),</a>
<a name="ln3646">                AR_PHY_TX_IQCAL_CONTROL_1_IQCORR_I_Q_COFF_DELPT, DELPT);</a>
<a name="ln3647"> </a>
<a name="ln3648">            /*</a>
<a name="ln3649">             * For poseidon and later chips,</a>
<a name="ln3650">             * Tx IQ cal HW run will be a part of AGC calibration</a>
<a name="ln3651">             */</a>
<a name="ln3652">            if (ahp-&gt;tx_iq_cal_during_agc_cal) {</a>
<a name="ln3653">                /*</a>
<a name="ln3654">                 * txiqcal_success_flag always set to 1 to run</a>
<a name="ln3655">                 *     ar9300_tx_iq_cal_post_proc</a>
<a name="ln3656">                 * if following AGC cal passes</a>
<a name="ln3657">                */</a>
<a name="ln3658">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln3659">                if (!cal_reuse_enable || !ichan-&gt;one_time_txiqcal_done)</a>
<a name="ln3660">                {</a>
<a name="ln3661">                    txiqcal_success_flag = AH_TRUE;</a>
<a name="ln3662">                    OS_REG_WRITE(ah, AR_PHY_TX_IQCAL_CONTROL_0(ah),</a>
<a name="ln3663">                        OS_REG_READ(ah, AR_PHY_TX_IQCAL_CONTROL_0(ah)) |</a>
<a name="ln3664">                        AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL);</a>
<a name="ln3665">                } else {</a>
<a name="ln3666">                    OS_REG_WRITE(ah, AR_PHY_TX_IQCAL_CONTROL_0(ah),</a>
<a name="ln3667">                        OS_REG_READ(ah, AR_PHY_TX_IQCAL_CONTROL_0(ah)) &amp;</a>
<a name="ln3668">                        (~AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL));</a>
<a name="ln3669">                }</a>
<a name="ln3670">#else</a>
<a name="ln3671">		if (OS_REG_READ_FIELD(ah,</a>
<a name="ln3672">					AR_PHY_TX_IQCAL_CONTROL_0(ah),</a>
<a name="ln3673">					AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL)){</a>
<a name="ln3674">			if (apply_last_iqcorr == AH_TRUE) {</a>
<a name="ln3675">				OS_REG_CLR_BIT(ah, AR_PHY_TX_IQCAL_CONTROL_0(ah),</a>
<a name="ln3676">						AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL);</a>
<a name="ln3677">				txiqcal_success_flag = AH_FALSE;</a>
<a name="ln3678">			} else {</a>
<a name="ln3679">				txiqcal_success_flag = AH_TRUE;</a>
<a name="ln3680">			}</a>
<a name="ln3681">		}else{</a>
<a name="ln3682">			txiqcal_success_flag = AH_FALSE;</a>
<a name="ln3683">		}</a>
<a name="ln3684">#endif</a>
<a name="ln3685">                if (txiqcal_success_flag) {</a>
<a name="ln3686">                    do_agc_cal = AH_TRUE;</a>
<a name="ln3687">                }</a>
<a name="ln3688">            } else</a>
<a name="ln3689">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln3690">            if (!cal_reuse_enable || !ichan-&gt;one_time_txiqcal_done)</a>
<a name="ln3691">#endif</a>
<a name="ln3692">            {</a>
<a name="ln3693">                do_sep_iq_cal = AH_TRUE;</a>
<a name="ln3694">                do_agc_cal = AH_TRUE;</a>
<a name="ln3695">            }</a>
<a name="ln3696">        }</a>
<a name="ln3697">    }</a>
<a name="ln3698"> </a>
<a name="ln3699">#if ATH_SUPPORT_MCI</a>
<a name="ln3700">    if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport &amp;&amp;</a>
<a name="ln3701">        IS_CHAN_2GHZ(ichan) &amp;&amp;</a>
<a name="ln3702">        (ahp-&gt;ah_mci_bt_state == MCI_BT_AWAKE) &amp;&amp;</a>
<a name="ln3703">        do_agc_cal &amp;&amp;</a>
<a name="ln3704">        !(ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln3705">        ATH_MCI_CONFIG_DISABLE_MCI_CAL))</a>
<a name="ln3706">    {</a>
<a name="ln3707">        u_int32_t payload[4] = {0, 0, 0, 0};</a>
<a name="ln3708"> </a>
<a name="ln3709">        /* Send CAL_REQ only when BT is AWAKE. */</a>
<a name="ln3710">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: Send WLAN_CAL_REQ 0x%X\n&quot;,</a>
<a name="ln3711">            __func__, ahp-&gt;ah_mci_wlan_cal_seq);</a>
<a name="ln3712">        MCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_REQ);</a>
<a name="ln3713">        payload[MCI_GPM_WLAN_CAL_W_SEQUENCE] = ahp-&gt;ah_mci_wlan_cal_seq++;</a>
<a name="ln3714">        ar9300_mci_send_message(ah, MCI_GPM, 0, payload, 16, AH_TRUE, AH_FALSE);</a>
<a name="ln3715"> </a>
<a name="ln3716">        /* Wait BT_CAL_GRANT for 50ms */</a>
<a name="ln3717">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln3718">            &quot;(MCI) %s: Wait for BT_CAL_GRANT\n&quot;, __func__);</a>
<a name="ln3719">        if (ar9300_mci_wait_for_gpm(ah, MCI_GPM_BT_CAL_GRANT, 0, 50000))</a>
<a name="ln3720">        {</a>
<a name="ln3721">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln3722">                &quot;(MCI) %s: Got BT_CAL_GRANT.\n&quot;, __func__);</a>
<a name="ln3723">        }</a>
<a name="ln3724">        else {</a>
<a name="ln3725">            is_cal_reusable = AH_FALSE;</a>
<a name="ln3726">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln3727">                &quot;(MCI) %s: BT is not responding.\n&quot;, __func__);</a>
<a name="ln3728">        }</a>
<a name="ln3729">    }</a>
<a name="ln3730">#endif /* ATH_SUPPORT_MCI */</a>
<a name="ln3731"> </a>
<a name="ln3732">    if (do_sep_iq_cal)</a>
<a name="ln3733">    {</a>
<a name="ln3734">        /* enable Tx IQ Calibration HW for osprey/hornet/wasp */</a>
<a name="ln3735">        txiqcal_success_flag = ar9300_tx_iq_cal_hw_run(ah);</a>
<a name="ln3736">        OS_REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);</a>
<a name="ln3737">        OS_DELAY(5);</a>
<a name="ln3738">        OS_REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);</a>
<a name="ln3739">    }</a>
<a name="ln3740">#if 0</a>
<a name="ln3741">    if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah)) {</a>
<a name="ln3742">        ar9300_tx_carrier_leak_war(ah);</a>
<a name="ln3743">    }</a>
<a name="ln3744">#endif</a>
<a name="ln3745">    /*</a>
<a name="ln3746">     * Calibrate the AGC</a>
<a name="ln3747">     *</a>
<a name="ln3748">     * Tx IQ cal is a part of AGC cal for Jupiter/Poseidon, etc.</a>
<a name="ln3749">     * please enable the bit of txiqcal_control_0[31] in INI file</a>
<a name="ln3750">     * for Jupiter/Poseidon/etc.</a>
<a name="ln3751">     */</a>
<a name="ln3752">    if(!AR_SREV_SCORPION(ah)) {</a>
<a name="ln3753">        if (do_agc_cal || !skip_if_none) {</a>
<a name="ln3754">            OS_REG_WRITE(ah, AR_PHY_AGC_CONTROL,</a>
<a name="ln3755">                OS_REG_READ(ah, AR_PHY_AGC_CONTROL) | AR_PHY_AGC_CONTROL_CAL);</a>
<a name="ln3756"> </a>
<a name="ln3757">            /* Poll for offset calibration complete */</a>
<a name="ln3758">            cal_done = ath_hal_wait(ah,</a>
<a name="ln3759">                    AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_CAL, 0);</a>
<a name="ln3760">            if (!cal_done) {</a>
<a name="ln3761">                HALDEBUG(ah, HAL_DEBUG_FCS_RTT,</a>
<a name="ln3762">                    &quot;(FCS) CAL NOT DONE!!! - %d\n&quot;, ichan-&gt;channel);</a>
<a name="ln3763">            }</a>
<a name="ln3764">        } else { </a>
<a name="ln3765">            cal_done = AH_TRUE;</a>
<a name="ln3766">        }</a>
<a name="ln3767">            /*</a>
<a name="ln3768">             * Tx IQ cal post-processing in SW</a>
<a name="ln3769">             * This part of code should be common to all chips,</a>
<a name="ln3770">             * no chip specific code for Jupiter/Posdeion except for register names.</a>
<a name="ln3771">             */</a>
<a name="ln3772">            if (txiqcal_success_flag) {</a>
<a name="ln3773">                ar9300_tx_iq_cal_post_proc(ah,ichan, 1, 1,is_cal_reusable, AH_FALSE);</a>
<a name="ln3774">            }</a>
<a name="ln3775">    } else {</a>
<a name="ln3776">        if (!txiqcal_success_flag) {</a>
<a name="ln3777">            OS_REG_WRITE(ah, AR_PHY_AGC_CONTROL,</a>
<a name="ln3778">                OS_REG_READ(ah, AR_PHY_AGC_CONTROL) | AR_PHY_AGC_CONTROL_CAL);</a>
<a name="ln3779">            if (!ath_hal_wait(ah, AR_PHY_AGC_CONTROL, AR_PHY_AGC_CONTROL_CAL, </a>
<a name="ln3780">                    0)) {</a>
<a name="ln3781">                HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3782">                    &quot;%s: offset calibration failed to complete in 1ms; &quot;</a>
<a name="ln3783">                    &quot;noisy environment?\n&quot;, __func__);</a>
<a name="ln3784">                return AH_FALSE;</a>
<a name="ln3785">            }</a>
<a name="ln3786">            if (apply_last_iqcorr == AH_TRUE) {</a>
<a name="ln3787">                ar9300_tx_iq_cal_post_proc(ah, ichan, 0, 0, is_cal_reusable, AH_TRUE);</a>
<a name="ln3788">            }</a>
<a name="ln3789">        } else {</a>
<a name="ln3790">            for (iqcal_idx=0;iqcal_idx&lt;MAXIQCAL;iqcal_idx++) {</a>
<a name="ln3791">                OS_REG_WRITE(ah, AR_PHY_AGC_CONTROL,</a>
<a name="ln3792">                    OS_REG_READ(ah, AR_PHY_AGC_CONTROL) | AR_PHY_AGC_CONTROL_CAL);</a>
<a name="ln3793"> </a>
<a name="ln3794">                /* Poll for offset calibration complete */</a>
<a name="ln3795">                if (!ath_hal_wait(ah, AR_PHY_AGC_CONTROL, </a>
<a name="ln3796">                        AR_PHY_AGC_CONTROL_CAL, 0)) {</a>
<a name="ln3797">                    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3798">                        &quot;%s: offset calibration failed to complete in 1ms; &quot;</a>
<a name="ln3799">                        &quot;noisy environment?\n&quot;, __func__);</a>
<a name="ln3800">                    return AH_FALSE;</a>
<a name="ln3801">                }</a>
<a name="ln3802">                /*</a>
<a name="ln3803">                 * Tx IQ cal post-processing in SW</a>
<a name="ln3804">                 * This part of code should be common to all chips,</a>
<a name="ln3805">                 * no chip specific code for Jupiter/Posdeion except for register names.</a>
<a name="ln3806">                 */</a>
<a name="ln3807">                ar9300_tx_iq_cal_post_proc(ah, ichan, iqcal_idx+1, MAXIQCAL, is_cal_reusable, AH_FALSE);</a>
<a name="ln3808">            }</a>
<a name="ln3809">       }</a>
<a name="ln3810">    }</a>
<a name="ln3811"> </a>
<a name="ln3812"> </a>
<a name="ln3813">#if ATH_SUPPORT_MCI</a>
<a name="ln3814">    if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport &amp;&amp;</a>
<a name="ln3815">        IS_CHAN_2GHZ(ichan) &amp;&amp;</a>
<a name="ln3816">        (ahp-&gt;ah_mci_bt_state == MCI_BT_AWAKE) &amp;&amp;</a>
<a name="ln3817">        do_agc_cal &amp;&amp;</a>
<a name="ln3818">        !(ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln3819">        ATH_MCI_CONFIG_DISABLE_MCI_CAL))</a>
<a name="ln3820">    {</a>
<a name="ln3821">        u_int32_t payload[4] = {0, 0, 0, 0};</a>
<a name="ln3822"> </a>
<a name="ln3823">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: Send WLAN_CAL_DONE 0x%X\n&quot;,</a>
<a name="ln3824">            __func__, ahp-&gt;ah_mci_wlan_cal_done);</a>
<a name="ln3825">        MCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_DONE);</a>
<a name="ln3826">        payload[MCI_GPM_WLAN_CAL_W_SEQUENCE] = ahp-&gt;ah_mci_wlan_cal_done++;</a>
<a name="ln3827">        ar9300_mci_send_message(ah, MCI_GPM, 0, payload, 16, AH_TRUE, AH_FALSE);</a>
<a name="ln3828">    }</a>
<a name="ln3829">#endif /* ATH_SUPPORT_MCI */</a>
<a name="ln3830"> </a>
<a name="ln3831"> </a>
<a name="ln3832">    if (!cal_done &amp;&amp; !AR_SREV_SCORPION(ah) )</a>
<a name="ln3833">    {</a>
<a name="ln3834">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3835">            &quot;%s: offset calibration failed to complete in 1ms; &quot;</a>
<a name="ln3836">            &quot;noisy environment?\n&quot;, __func__);</a>
<a name="ln3837">        return AH_FALSE;</a>
<a name="ln3838">    }</a>
<a name="ln3839"> </a>
<a name="ln3840">#if 0</a>
<a name="ln3841">     /* Beacon stuck fix, refer to EV 120056 */</a>
<a name="ln3842">    if(IS_CHAN_2GHZ(chan) &amp;&amp; AR_SREV_SCORPION(ah))</a>
<a name="ln3843">        OS_REG_WRITE(ah, AR_PHY_TIMING5, OS_REG_READ(ah,AR_PHY_TIMING5) &amp; ~AR_PHY_TIMING5_CYCPWR_THR1_ENABLE);</a>
<a name="ln3844">#endif</a>
<a name="ln3845"> </a>
<a name="ln3846">#if 0</a>
<a name="ln3847">    /* Do PA Calibration */</a>
<a name="ln3848">    if (AR_SREV_KITE(ah) &amp;&amp; AR_SREV_KITE_11_OR_LATER(ah)) {</a>
<a name="ln3849">        ar9285_pa_cal(ah);</a>
<a name="ln3850">    }</a>
<a name="ln3851">#endif</a>
<a name="ln3852"> </a>
<a name="ln3853">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln3854">     if (ichan-&gt;one_time_txiqcal_done) {</a>
<a name="ln3855">        ar9300_tx_iq_cal_apply(ah, ichan);</a>
<a name="ln3856">        HALDEBUG(ah, HAL_DEBUG_FCS_RTT,</a>
<a name="ln3857">            &quot;(FCS) TXIQCAL applied - %d\n&quot;, ichan-&gt;channel);</a>
<a name="ln3858">    }</a>
<a name="ln3859">#endif /* ATH_SUPPORT_CAL_REUSE */</a>
<a name="ln3860"> </a>
<a name="ln3861">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln3862">    if (cal_reuse_enable &amp;&amp; ahp-&gt;tx_cl_cal_enable)</a>
<a name="ln3863">    {</a>
<a name="ln3864">        clc_success = (OS_REG_READ(ah, AR_PHY_AGC_CONTROL) &amp;</a>
<a name="ln3865">                  AR_PHY_AGC_CONTROL_CLC_SUCCESS) ? 1 : 0;</a>
<a name="ln3866"> </a>
<a name="ln3867">        if (ichan-&gt;one_time_txclcal_done)</a>
<a name="ln3868">        {</a>
<a name="ln3869">            /* reapply CL cal results */</a>
<a name="ln3870">            for (ch_idx = 0; ch_idx &lt; AR9300_MAX_CHAINS; ch_idx++) {</a>
<a name="ln3871">                if ((ahp-&gt;ah_tx_cal_chainmask &amp; (1 &lt;&lt; ch_idx)) == 0) {</a>
<a name="ln3872">                    continue;</a>
<a name="ln3873">                }</a>
<a name="ln3874">                cl_tab_reg = BB_cl_tab_b[ch_idx];</a>
<a name="ln3875">                for (j = 0; j &lt; BB_cl_tab_entry; j++) {</a>
<a name="ln3876">                    OS_REG_WRITE(ah, cl_tab_reg, ichan-&gt;tx_clcal[ch_idx][j]);</a>
<a name="ln3877">                    cl_tab_reg += 4;;</a>
<a name="ln3878">                }</a>
<a name="ln3879">            }</a>
<a name="ln3880">            HALDEBUG(ah, HAL_DEBUG_FCS_RTT,</a>
<a name="ln3881">                &quot;(FCS) TX CL CAL applied - %d\n&quot;, ichan-&gt;channel);</a>
<a name="ln3882">        }</a>
<a name="ln3883">        else if (is_cal_reusable &amp;&amp; clc_success) {</a>
<a name="ln3884">            /* save CL cal results */</a>
<a name="ln3885">            for (ch_idx = 0; ch_idx &lt; AR9300_MAX_CHAINS; ch_idx++) {</a>
<a name="ln3886">                if ((ahp-&gt;ah_tx_cal_chainmask &amp; (1 &lt;&lt; ch_idx)) == 0) {</a>
<a name="ln3887">                    continue;</a>
<a name="ln3888">                }</a>
<a name="ln3889">                cl_tab_reg = BB_cl_tab_b[ch_idx];</a>
<a name="ln3890">                for (j = 0; j &lt; BB_cl_tab_entry; j++) {</a>
<a name="ln3891">                    ichan-&gt;tx_clcal[ch_idx][j] = OS_REG_READ(ah, cl_tab_reg);</a>
<a name="ln3892">                    cl_tab_reg += 4;</a>
<a name="ln3893">                }</a>
<a name="ln3894">            }</a>
<a name="ln3895">            ichan-&gt;one_time_txclcal_done = AH_TRUE;</a>
<a name="ln3896">            HALDEBUG(ah, HAL_DEBUG_FCS_RTT,</a>
<a name="ln3897">                &quot;(FCS) TX CL CAL saved - %d\n&quot;, ichan-&gt;channel);</a>
<a name="ln3898">        }</a>
<a name="ln3899">    }</a>
<a name="ln3900">#endif /* ATH_SUPPORT_CAL_REUSE */</a>
<a name="ln3901"> </a>
<a name="ln3902">    /* Revert chainmasks to their original values before NF cal */</a>
<a name="ln3903">    ar9300_init_chain_masks(ah, ahp-&gt;ah_rx_chainmask, ahp-&gt;ah_tx_chainmask);</a>
<a name="ln3904"> </a>
<a name="ln3905">#if !FIX_NOISE_FLOOR</a>
<a name="ln3906">    /*</a>
<a name="ln3907">     * Do NF calibration after DC offset and other CALs.</a>
<a name="ln3908">     * Per system engineers, noise floor value can sometimes be 20 dB</a>
<a name="ln3909">     * higher than normal value if DC offset and noise floor cal are</a>
<a name="ln3910">     * triggered at the same time.</a>
<a name="ln3911">     */</a>
<a name="ln3912">    OS_REG_WRITE(ah, AR_PHY_AGC_CONTROL,</a>
<a name="ln3913">        OS_REG_READ(ah, AR_PHY_AGC_CONTROL) | AR_PHY_AGC_CONTROL_NF);</a>
<a name="ln3914">#endif </a>
<a name="ln3915"> </a>
<a name="ln3916">    /* Initialize list pointers */</a>
<a name="ln3917">    ahp-&gt;ah_cal_list = ahp-&gt;ah_cal_list_last = ahp-&gt;ah_cal_list_curr = AH_NULL;</a>
<a name="ln3918"> </a>
<a name="ln3919">    /*</a>
<a name="ln3920">     * Enable IQ, ADC Gain, ADC DC Offset Cals</a>
<a name="ln3921">     */</a>
<a name="ln3922">    /* Setup all non-periodic, init time only calibrations */</a>
<a name="ln3923">    /* XXX: Init DC Offset not working yet */</a>
<a name="ln3924">#ifdef not_yet</a>
<a name="ln3925">    if (AH_TRUE == ar9300_is_cal_supp(ah, chan, ADC_DC_INIT_CAL)) {</a>
<a name="ln3926">        INIT_CAL(&amp;ahp-&gt;ah_adc_dc_cal_init_data);</a>
<a name="ln3927">        INSERT_CAL(ahp, &amp;ahp-&gt;ah_adc_dc_cal_init_data);</a>
<a name="ln3928">    }</a>
<a name="ln3929"> </a>
<a name="ln3930">    /* Initialize current pointer to first element in list */</a>
<a name="ln3931">    ahp-&gt;ah_cal_list_curr = ahp-&gt;ah_cal_list;</a>
<a name="ln3932"> </a>
<a name="ln3933">    if (ahp-&gt;ah_cal_list_curr) {</a>
<a name="ln3934">        if (ar9300_run_init_cals(ah, 0) == AH_FALSE) {</a>
<a name="ln3935">            return AH_FALSE;</a>
<a name="ln3936">        }</a>
<a name="ln3937">    }</a>
<a name="ln3938">#endif</a>
<a name="ln3939">    /* end - Init time calibrations */</a>
<a name="ln3940"> </a>
<a name="ln3941">    /* Do not do RX cal in case of offchan, or cal data already exists on same channel*/</a>
<a name="ln3942">    if (ahp-&gt;ah_skip_rx_iq_cal) {</a>
<a name="ln3943">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3944">                &quot;Skip RX IQ Cal\n&quot;);</a>
<a name="ln3945">        return AH_TRUE;</a>
<a name="ln3946">    }</a>
<a name="ln3947"> </a>
<a name="ln3948">    /* If Cals are supported, add them to list via INIT/INSERT_CAL */</a>
<a name="ln3949">    if (AH_TRUE == ar9300_is_cal_supp(ah, chan, IQ_MISMATCH_CAL)) {</a>
<a name="ln3950">        INIT_CAL(&amp;ahp-&gt;ah_iq_cal_data);</a>
<a name="ln3951">        INSERT_CAL(ahp, &amp;ahp-&gt;ah_iq_cal_data);</a>
<a name="ln3952">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3953">            &quot;%s: enabling IQ Calibration.\n&quot;, __func__);</a>
<a name="ln3954">    }</a>
<a name="ln3955">    if (AH_TRUE == ar9300_is_cal_supp(ah, chan, TEMP_COMP_CAL)) {</a>
<a name="ln3956">        INIT_CAL(&amp;ahp-&gt;ah_temp_comp_cal_data);</a>
<a name="ln3957">        INSERT_CAL(ahp, &amp;ahp-&gt;ah_temp_comp_cal_data);</a>
<a name="ln3958">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln3959">            &quot;%s: enabling Temperature Compensation Calibration.\n&quot;, __func__);</a>
<a name="ln3960">    }</a>
<a name="ln3961"> </a>
<a name="ln3962">    /* Initialize current pointer to first element in list */</a>
<a name="ln3963">    ahp-&gt;ah_cal_list_curr = ahp-&gt;ah_cal_list;</a>
<a name="ln3964"> </a>
<a name="ln3965">    /* Reset state within current cal */</a>
<a name="ln3966">    if (ahp-&gt;ah_cal_list_curr) {</a>
<a name="ln3967">        ar9300_reset_calibration(ah, ahp-&gt;ah_cal_list_curr);</a>
<a name="ln3968">    }</a>
<a name="ln3969"> </a>
<a name="ln3970">    /* Mark all calibrations on this channel as being invalid */</a>
<a name="ln3971">    ichan-&gt;calValid = 0;</a>
<a name="ln3972"> </a>
<a name="ln3973">    return AH_TRUE;</a>
<a name="ln3974">}</a>
<a name="ln3975"> </a>
<a name="ln3976">static inline HAL_BOOL</a>
<a name="ln3977">ar9300_init_cal(struct ath_hal *ah, struct ieee80211_channel *chan, HAL_BOOL skip_if_none, HAL_BOOL apply_last_iqcorr)</a>
<a name="ln3978">{</a>
<a name="ln3979">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln3980">    HAL_BOOL do_rtt_cal = AH_TRUE;</a>
<a name="ln3981">    HAL_BOOL enable_rtt = AH_FALSE;</a>
<a name="ln3982"> </a>
<a name="ln3983">    HALASSERT(ichan);</a>
<a name="ln3984"> </a>
<a name="ln3985">    return ar9300_init_cal_internal(ah, chan, ichan, enable_rtt, do_rtt_cal, skip_if_none, apply_last_iqcorr);</a>
<a name="ln3986">}</a>
<a name="ln3987"> </a>
<a name="ln3988">/* ar9300_reset_cal_valid</a>
<a name="ln3989"> * Entry point for upper layers to restart current cal.</a>
<a name="ln3990"> * Reset the calibration valid bit in channel.</a>
<a name="ln3991"> */</a>
<a name="ln3992">void</a>
<a name="ln3993">ar9300_reset_cal_valid(struct ath_hal *ah, const struct ieee80211_channel *chan,</a>
<a name="ln3994">    HAL_BOOL *is_cal_done, u_int32_t cal_type)</a>
<a name="ln3995">{</a>
<a name="ln3996">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3997">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln3998">    HAL_CAL_LIST *curr_cal = ahp-&gt;ah_cal_list_curr;</a>
<a name="ln3999"> </a>
<a name="ln4000">    *is_cal_done = AH_TRUE;</a>
<a name="ln4001"> </a>
<a name="ln4002">    if (curr_cal == AH_NULL) {</a>
<a name="ln4003">        return;</a>
<a name="ln4004">    }</a>
<a name="ln4005">    if (ichan == AH_NULL) {</a>
<a name="ln4006">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln4007">            &quot;%s: invalid channel %u/0x%x; no mapping\n&quot;,</a>
<a name="ln4008">            __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln4009">        return;</a>
<a name="ln4010">    }</a>
<a name="ln4011"> </a>
<a name="ln4012">    if (!(cal_type &amp; IQ_MISMATCH_CAL)) {</a>
<a name="ln4013">        *is_cal_done = AH_FALSE;</a>
<a name="ln4014">        return;</a>
<a name="ln4015">    }</a>
<a name="ln4016"> </a>
<a name="ln4017">    /* Expected that this calibration has run before, post-reset.</a>
<a name="ln4018">     * Current state should be done</a>
<a name="ln4019">     */</a>
<a name="ln4020">    if (curr_cal-&gt;cal_state != CAL_DONE) {</a>
<a name="ln4021">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln4022">            &quot;%s: Calibration state incorrect, %d\n&quot;,</a>
<a name="ln4023">            __func__, curr_cal-&gt;cal_state);</a>
<a name="ln4024">        return;</a>
<a name="ln4025">    }</a>
<a name="ln4026"> </a>
<a name="ln4027">    /* Verify Cal is supported on this channel */</a>
<a name="ln4028">    if (ar9300_is_cal_supp(ah, chan, curr_cal-&gt;cal_data-&gt;cal_type) == AH_FALSE) {</a>
<a name="ln4029">        return;</a>
<a name="ln4030">    }</a>
<a name="ln4031"> </a>
<a name="ln4032">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln4033">        &quot;%s: Resetting Cal %d state for channel %u/0x%x\n&quot;, __func__,</a>
<a name="ln4034">        curr_cal-&gt;cal_data-&gt;cal_type, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln4035"> </a>
<a name="ln4036">    /* Disable cal validity in channel */</a>
<a name="ln4037">    ichan-&gt;calValid &amp;= ~curr_cal-&gt;cal_data-&gt;cal_type;</a>
<a name="ln4038">    curr_cal-&gt;cal_state = CAL_WAITING;</a>
<a name="ln4039">    /* Indicate to upper layers that we need polling */</a>
<a name="ln4040">    *is_cal_done = AH_FALSE;</a>
<a name="ln4041">}</a>
<a name="ln4042"> </a>
<a name="ln4043">static inline void</a>
<a name="ln4044">ar9300_set_dma(struct ath_hal *ah)</a>
<a name="ln4045">{</a>
<a name="ln4046">    u_int32_t   regval;</a>
<a name="ln4047">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4048">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln4049">    HAL_CAPABILITIES *pCap = &amp;ahpriv-&gt;ah_caps;</a>
<a name="ln4050"> </a>
<a name="ln4051">#if 0</a>
<a name="ln4052">    /*</a>
<a name="ln4053">     * set AHB_MODE not to do cacheline prefetches</a>
<a name="ln4054">     */</a>
<a name="ln4055">    regval = OS_REG_READ(ah, AR_AHB_MODE);</a>
<a name="ln4056">    OS_REG_WRITE(ah, AR_AHB_MODE, regval | AR_AHB_PREFETCH_RD_EN);</a>
<a name="ln4057">#endif</a>
<a name="ln4058"> </a>
<a name="ln4059">    /*</a>
<a name="ln4060">     * let mac dma reads be in 128 byte chunks</a>
<a name="ln4061">     */</a>
<a name="ln4062">    regval = OS_REG_READ(ah, AR_TXCFG) &amp; ~AR_TXCFG_DMASZ_MASK;</a>
<a name="ln4063">    OS_REG_WRITE(ah, AR_TXCFG, regval | AR_TXCFG_DMASZ_128B);</a>
<a name="ln4064"> </a>
<a name="ln4065">    /*</a>
<a name="ln4066">     * Restore TX Trigger Level to its pre-reset value.</a>
<a name="ln4067">     * The initial value depends on whether aggregation is enabled, and is</a>
<a name="ln4068">     * adjusted whenever underruns are detected.</a>
<a name="ln4069">     */</a>
<a name="ln4070">    /*</a>
<a name="ln4071">    OS_REG_RMW_FIELD(ah, AR_TXCFG, AR_FTRIG, AH_PRIVATE(ah)-&gt;ah_tx_trig_level);</a>
<a name="ln4072">     */</a>
<a name="ln4073">    /* </a>
<a name="ln4074">     * Osprey 1.0 bug (EV 61936). Don't change trigger level from .ini default.</a>
<a name="ln4075">     * Osprey 2.0 - hardware recommends using the default INI settings.</a>
<a name="ln4076">     */</a>
<a name="ln4077">#if 0</a>
<a name="ln4078">    OS_REG_RMW_FIELD(ah, AR_TXCFG, AR_FTRIG, 0x3f);</a>
<a name="ln4079">#endif</a>
<a name="ln4080">    /*</a>
<a name="ln4081">     * let mac dma writes be in 128 byte chunks</a>
<a name="ln4082">     */</a>
<a name="ln4083">    regval = OS_REG_READ(ah, AR_RXCFG) &amp; ~AR_RXCFG_DMASZ_MASK;</a>
<a name="ln4084">    OS_REG_WRITE(ah, AR_RXCFG, regval | AR_RXCFG_DMASZ_128B);</a>
<a name="ln4085"> </a>
<a name="ln4086">    /*</a>
<a name="ln4087">     * Setup receive FIFO threshold to hold off TX activities</a>
<a name="ln4088">     */</a>
<a name="ln4089">    OS_REG_WRITE(ah, AR_RXFIFO_CFG, 0x200);</a>
<a name="ln4090"> </a>
<a name="ln4091">    /*</a>
<a name="ln4092">     * reduce the number of usable entries in PCU TXBUF to avoid</a>
<a name="ln4093">     * wrap around bugs. (bug 20428)</a>
<a name="ln4094">     */</a>
<a name="ln4095">    </a>
<a name="ln4096">    if (AR_SREV_WASP(ah) &amp;&amp; </a>
<a name="ln4097">        (AH_PRIVATE((ah))-&gt;ah_macRev &gt; AR_SREV_REVISION_WASP_12)) {</a>
<a name="ln4098">        /* Wasp 1.3 fix for EV#85395 requires usable entries </a>
<a name="ln4099">         * to be set to 0x500 </a>
<a name="ln4100">         */</a>
<a name="ln4101">        OS_REG_WRITE(ah, AR_PCU_TXBUF_CTRL, 0x500);</a>
<a name="ln4102">    } else {</a>
<a name="ln4103">        OS_REG_WRITE(ah, AR_PCU_TXBUF_CTRL, AR_PCU_TXBUF_CTRL_USABLE_SIZE);</a>
<a name="ln4104">    }</a>
<a name="ln4105"> </a>
<a name="ln4106">    /*</a>
<a name="ln4107">     * Enable HPQ for UAPSD</a>
<a name="ln4108">     */</a>
<a name="ln4109">    if (pCap-&gt;halHwUapsdTrig == AH_TRUE) {</a>
<a name="ln4110">    /* Only enable this if HAL capabilities says it is OK */</a>
<a name="ln4111">        if (AH_PRIVATE(ah)-&gt;ah_opmode == HAL_M_HOSTAP) {</a>
<a name="ln4112">            OS_REG_WRITE(ah, AR_HP_Q_CONTROL,</a>
<a name="ln4113">                    AR_HPQ_ENABLE | AR_HPQ_UAPSD | AR_HPQ_UAPSD_TRIGGER_EN);</a>
<a name="ln4114">        }</a>
<a name="ln4115">    } else {</a>
<a name="ln4116">        /* use default value from ini file - which disable HPQ queue usage */</a>
<a name="ln4117">    }</a>
<a name="ln4118"> </a>
<a name="ln4119">    /*</a>
<a name="ln4120">     * set the transmit status ring</a>
<a name="ln4121">     */</a>
<a name="ln4122">    ar9300_reset_tx_status_ring(ah);</a>
<a name="ln4123"> </a>
<a name="ln4124">    /*</a>
<a name="ln4125">     * set rxbp threshold.  Must be non-zero for RX_EOL to occur.</a>
<a name="ln4126">     * For Osprey 2.0+, keep the original thresholds</a>
<a name="ln4127">     * otherwise performance is lost due to excessive RX EOL interrupts.</a>
<a name="ln4128">     */</a>
<a name="ln4129">    OS_REG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_HP, 0x1);</a>
<a name="ln4130">    OS_REG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_LP, 0x1);</a>
<a name="ln4131"> </a>
<a name="ln4132">    /*</a>
<a name="ln4133">     * set receive buffer size.</a>
<a name="ln4134">     */</a>
<a name="ln4135">    if (ahp-&gt;rx_buf_size) {</a>
<a name="ln4136">        OS_REG_WRITE(ah, AR_DATABUF, ahp-&gt;rx_buf_size);</a>
<a name="ln4137">    }</a>
<a name="ln4138">}</a>
<a name="ln4139"> </a>
<a name="ln4140">static inline void</a>
<a name="ln4141">ar9300_init_bb(struct ath_hal *ah, struct ieee80211_channel *chan)</a>
<a name="ln4142">{</a>
<a name="ln4143">    u_int32_t synth_delay;</a>
<a name="ln4144"> </a>
<a name="ln4145">    /*</a>
<a name="ln4146">     * Wait for the frequency synth to settle (synth goes on</a>
<a name="ln4147">     * via AR_PHY_ACTIVE_EN).  Read the phy active delay register.</a>
<a name="ln4148">     * Value is in 100ns increments.</a>
<a name="ln4149">     */</a>
<a name="ln4150">    synth_delay = OS_REG_READ(ah, AR_PHY_RX_DELAY) &amp; AR_PHY_RX_DELAY_DELAY;</a>
<a name="ln4151">    if (IEEE80211_IS_CHAN_CCK(chan)) {</a>
<a name="ln4152">        synth_delay = (4 * synth_delay) / 22;</a>
<a name="ln4153">    } else {</a>
<a name="ln4154">        synth_delay /= 10;</a>
<a name="ln4155">    }</a>
<a name="ln4156"> </a>
<a name="ln4157">    /* Activate the PHY (includes baseband activate + synthesizer on) */</a>
<a name="ln4158">    OS_REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);</a>
<a name="ln4159"> </a>
<a name="ln4160">    /*</a>
<a name="ln4161">     * There is an issue if the AP starts the calibration before</a>
<a name="ln4162">     * the base band timeout completes.  This could result in the</a>
<a name="ln4163">     * rx_clear false triggering.  As a workaround we add delay an</a>
<a name="ln4164">     * extra BASE_ACTIVATE_DELAY usecs to ensure this condition</a>
<a name="ln4165">     * does not happen.</a>
<a name="ln4166">     */</a>
<a name="ln4167">    OS_DELAY(synth_delay + BASE_ACTIVATE_DELAY);</a>
<a name="ln4168">}</a>
<a name="ln4169"> </a>
<a name="ln4170">static inline void</a>
<a name="ln4171">ar9300_init_interrupt_masks(struct ath_hal *ah, HAL_OPMODE opmode)</a>
<a name="ln4172">{</a>
<a name="ln4173">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4174">    u_int32_t msi_cfg = 0;</a>
<a name="ln4175">    u_int32_t sync_en_def = AR9300_INTR_SYNC_DEFAULT;</a>
<a name="ln4176"> </a>
<a name="ln4177">    /*</a>
<a name="ln4178">     * Setup interrupt handling.  Note that ar9300_reset_tx_queue</a>
<a name="ln4179">     * manipulates the secondary IMR's as queues are enabled</a>
<a name="ln4180">     * and disabled.  This is done with RMW ops to insure the</a>
<a name="ln4181">     * settings we make here are preserved.</a>
<a name="ln4182">     */</a>
<a name="ln4183">    ahp-&gt;ah_mask_reg =</a>
<a name="ln4184">        AR_IMR_TXERR | AR_IMR_TXURN |</a>
<a name="ln4185">        AR_IMR_RXERR | AR_IMR_RXORN |</a>
<a name="ln4186">        AR_IMR_BCNMISC;</a>
<a name="ln4187"> </a>
<a name="ln4188">    if (ahp-&gt;ah_intr_mitigation_rx) {</a>
<a name="ln4189">        /* enable interrupt mitigation for rx */</a>
<a name="ln4190">        ahp-&gt;ah_mask_reg |= AR_IMR_RXINTM | AR_IMR_RXMINTR | AR_IMR_RXOK_HP;</a>
<a name="ln4191">        msi_cfg |= AR_INTCFG_MSI_RXINTM | AR_INTCFG_MSI_RXMINTR;</a>
<a name="ln4192">    } else {</a>
<a name="ln4193">        ahp-&gt;ah_mask_reg |= AR_IMR_RXOK_LP | AR_IMR_RXOK_HP;</a>
<a name="ln4194">        msi_cfg |= AR_INTCFG_MSI_RXOK;</a>
<a name="ln4195">    }</a>
<a name="ln4196">    if (ahp-&gt;ah_intr_mitigation_tx) {</a>
<a name="ln4197">        /* enable interrupt mitigation for tx */</a>
<a name="ln4198">        ahp-&gt;ah_mask_reg |= AR_IMR_TXINTM | AR_IMR_TXMINTR;</a>
<a name="ln4199">        msi_cfg |= AR_INTCFG_MSI_TXINTM | AR_INTCFG_MSI_TXMINTR;</a>
<a name="ln4200">    } else {</a>
<a name="ln4201">        ahp-&gt;ah_mask_reg |= AR_IMR_TXOK;</a>
<a name="ln4202">        msi_cfg |= AR_INTCFG_MSI_TXOK;</a>
<a name="ln4203">    }</a>
<a name="ln4204">    if (opmode == HAL_M_HOSTAP) {</a>
<a name="ln4205">        ahp-&gt;ah_mask_reg |= AR_IMR_MIB;</a>
<a name="ln4206">    }</a>
<a name="ln4207"> </a>
<a name="ln4208">    OS_REG_WRITE(ah, AR_IMR, ahp-&gt;ah_mask_reg);</a>
<a name="ln4209">    OS_REG_WRITE(ah, AR_IMR_S2, OS_REG_READ(ah, AR_IMR_S2) | AR_IMR_S2_GTT);</a>
<a name="ln4210">    ahp-&gt;ah_mask2Reg = OS_REG_READ(ah, AR_IMR_S2);</a>
<a name="ln4211"> </a>
<a name="ln4212">    if (ah-&gt;ah_config.ath_hal_enable_msi) {</a>
<a name="ln4213">        /* Cache MSI register value */</a>
<a name="ln4214">        ahp-&gt;ah_msi_reg = OS_REG_READ(ah, AR_HOSTIF_REG(ah, AR_PCIE_MSI));</a>
<a name="ln4215">        ahp-&gt;ah_msi_reg |= AR_PCIE_MSI_HW_DBI_WR_EN;</a>
<a name="ln4216">        if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln4217">            ahp-&gt;ah_msi_reg &amp;= AR_PCIE_MSI_HW_INT_PENDING_ADDR_MSI_64;</a>
<a name="ln4218">        } else {</a>
<a name="ln4219">            ahp-&gt;ah_msi_reg &amp;= AR_PCIE_MSI_HW_INT_PENDING_ADDR;</a>
<a name="ln4220">        }</a>
<a name="ln4221">        /* Program MSI configuration */</a>
<a name="ln4222">        OS_REG_WRITE(ah, AR_INTCFG, msi_cfg);</a>
<a name="ln4223">    }</a>
<a name="ln4224"> </a>
<a name="ln4225">    /*</a>
<a name="ln4226">     * debug - enable to see all synchronous interrupts status</a>
<a name="ln4227">     */</a>
<a name="ln4228">    /* Clear any pending sync cause interrupts */</a>
<a name="ln4229">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_INTR_SYNC_CAUSE), 0xFFFFFFFF);</a>
<a name="ln4230"> </a>
<a name="ln4231">    /* Allow host interface sync interrupt sources to set cause bit */</a>
<a name="ln4232">    if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln4233">        sync_en_def = AR9300_INTR_SYNC_DEF_NO_HOST1_PERR;</a>
<a name="ln4234">    }</a>
<a name="ln4235">    else if (AR_SREV_WASP(ah)) {</a>
<a name="ln4236">        sync_en_def = AR9340_INTR_SYNC_DEFAULT;</a>
<a name="ln4237">    }</a>
<a name="ln4238">    OS_REG_WRITE(ah,</a>
<a name="ln4239">        AR_HOSTIF_REG(ah, AR_INTR_SYNC_ENABLE), sync_en_def);</a>
<a name="ln4240">    </a>
<a name="ln4241">    /* _Disable_ host interface sync interrupt when cause bits set */</a>
<a name="ln4242">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_INTR_SYNC_MASK), 0);</a>
<a name="ln4243"> </a>
<a name="ln4244">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_INTR_PRIO_ASYNC_ENABLE), 0);</a>
<a name="ln4245">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_INTR_PRIO_ASYNC_MASK), 0);</a>
<a name="ln4246">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_INTR_PRIO_SYNC_ENABLE), 0);</a>
<a name="ln4247">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_INTR_PRIO_SYNC_MASK), 0);</a>
<a name="ln4248">}</a>
<a name="ln4249"> </a>
<a name="ln4250">static inline void</a>
<a name="ln4251">ar9300_init_qos(struct ath_hal *ah)</a>
<a name="ln4252">{</a>
<a name="ln4253">    OS_REG_WRITE(ah, AR_MIC_QOS_CONTROL, 0x100aa);  /* XXX magic */</a>
<a name="ln4254">    OS_REG_WRITE(ah, AR_MIC_QOS_SELECT, 0x3210);    /* XXX magic */</a>
<a name="ln4255"> </a>
<a name="ln4256">    /* Turn on NOACK Support for QoS packets */</a>
<a name="ln4257">    OS_REG_WRITE(ah, AR_QOS_NO_ACK,</a>
<a name="ln4258">        SM(2, AR_QOS_NO_ACK_TWO_BIT) |</a>
<a name="ln4259">        SM(5, AR_QOS_NO_ACK_BIT_OFF) |</a>
<a name="ln4260">        SM(0, AR_QOS_NO_ACK_BYTE_OFF));</a>
<a name="ln4261"> </a>
<a name="ln4262">    /*</a>
<a name="ln4263">     * initialize TXOP for all TIDs</a>
<a name="ln4264">     */</a>
<a name="ln4265">    OS_REG_WRITE(ah, AR_TXOP_X, AR_TXOP_X_VAL);</a>
<a name="ln4266">    OS_REG_WRITE(ah, AR_TXOP_0_3, 0xFFFFFFFF);</a>
<a name="ln4267">    OS_REG_WRITE(ah, AR_TXOP_4_7, 0xFFFFFFFF);</a>
<a name="ln4268">    OS_REG_WRITE(ah, AR_TXOP_8_11, 0xFFFFFFFF);</a>
<a name="ln4269">    OS_REG_WRITE(ah, AR_TXOP_12_15, 0xFFFFFFFF);</a>
<a name="ln4270">}</a>
<a name="ln4271"> </a>
<a name="ln4272">static inline void</a>
<a name="ln4273">ar9300_init_user_settings(struct ath_hal *ah)</a>
<a name="ln4274">{</a>
<a name="ln4275">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln4276"> </a>
<a name="ln4277">    /* Restore user-specified settings */</a>
<a name="ln4278">    HALDEBUG(ah, HAL_DEBUG_RESET,</a>
<a name="ln4279">        &quot;--AP %s ahp-&gt;ah_misc_mode 0x%x\n&quot;, __func__, ahp-&gt;ah_misc_mode);</a>
<a name="ln4280">    if (ahp-&gt;ah_misc_mode != 0) {</a>
<a name="ln4281">        OS_REG_WRITE(ah,</a>
<a name="ln4282">            AR_PCU_MISC, OS_REG_READ(ah, AR_PCU_MISC) | ahp-&gt;ah_misc_mode);</a>
<a name="ln4283">    }</a>
<a name="ln4284">    if (ahp-&gt;ah_get_plcp_hdr) {</a>
<a name="ln4285">        OS_REG_CLR_BIT(ah, AR_PCU_MISC, AR_PCU_SEL_EVM);</a>
<a name="ln4286">    }</a>
<a name="ln4287">    if (ahp-&gt;ah_slot_time != (u_int) -1) {</a>
<a name="ln4288">        ar9300_set_slot_time(ah, ahp-&gt;ah_slot_time);</a>
<a name="ln4289">    }</a>
<a name="ln4290">    if (ahp-&gt;ah_ack_timeout != (u_int) -1) {</a>
<a name="ln4291">        ar9300_set_ack_timeout(ah, ahp-&gt;ah_ack_timeout);</a>
<a name="ln4292">    }</a>
<a name="ln4293">    if (AH_PRIVATE(ah)-&gt;ah_diagreg != 0) {</a>
<a name="ln4294">        OS_REG_SET_BIT(ah, AR_DIAG_SW, AH_PRIVATE(ah)-&gt;ah_diagreg);</a>
<a name="ln4295">    }</a>
<a name="ln4296">    if (ahp-&gt;ah_beacon_rssi_threshold != 0) {</a>
<a name="ln4297">        ar9300_set_hw_beacon_rssi_threshold(ah, ahp-&gt;ah_beacon_rssi_threshold);</a>
<a name="ln4298">    }</a>
<a name="ln4299">//#ifdef ATH_SUPPORT_DFS</a>
<a name="ln4300">    if (ahp-&gt;ah_cac_quiet_enabled) {</a>
<a name="ln4301">        ar9300_cac_tx_quiet(ah, 1);</a>
<a name="ln4302">    }</a>
<a name="ln4303">//#endif /* ATH_SUPPORT_DFS */</a>
<a name="ln4304">}</a>
<a name="ln4305"> </a>
<a name="ln4306">int</a>
<a name="ln4307">ar9300_get_spur_info(struct ath_hal * ah, int *enable, int len, u_int16_t *freq)</a>
<a name="ln4308">{</a>
<a name="ln4309">//    struct ath_hal_private *ap = AH_PRIVATE(ah);</a>
<a name="ln4310">    int i, j;</a>
<a name="ln4311"> </a>
<a name="ln4312">    for (i = 0; i &lt; len; i++) {</a>
<a name="ln4313">        freq[i] =  0;</a>
<a name="ln4314">    }</a>
<a name="ln4315"> </a>
<a name="ln4316">    *enable = ah-&gt;ah_config.ath_hal_spur_mode;</a>
<a name="ln4317">    for (i = 0, j = 0; i &lt; AR_EEPROM_MODAL_SPURS; i++) {</a>
<a name="ln4318">        if (AH9300(ah)-&gt;ath_hal_spur_chans[i][0] != AR_NO_SPUR) {</a>
<a name="ln4319">            freq[j++] = AH9300(ah)-&gt;ath_hal_spur_chans[i][0];</a>
<a name="ln4320">            HALDEBUG(ah, HAL_DEBUG_ANI,</a>
<a name="ln4321">                &quot;1. get spur %d\n&quot;, AH9300(ah)-&gt;ath_hal_spur_chans[i][0]);</a>
<a name="ln4322">        }</a>
<a name="ln4323">        if (AH9300(ah)-&gt;ath_hal_spur_chans[i][1] != AR_NO_SPUR) {</a>
<a name="ln4324">            freq[j++] = AH9300(ah)-&gt;ath_hal_spur_chans[i][1];</a>
<a name="ln4325">            HALDEBUG(ah, HAL_DEBUG_ANI,</a>
<a name="ln4326">                &quot;2. get spur %d\n&quot;, AH9300(ah)-&gt;ath_hal_spur_chans[i][1]);</a>
<a name="ln4327">        }</a>
<a name="ln4328">    }</a>
<a name="ln4329"> </a>
<a name="ln4330">    return 0;</a>
<a name="ln4331">}</a>
<a name="ln4332"> </a>
<a name="ln4333">#define ATH_HAL_2GHZ_FREQ_MIN   20000</a>
<a name="ln4334">#define ATH_HAL_2GHZ_FREQ_MAX   29999</a>
<a name="ln4335">#define ATH_HAL_5GHZ_FREQ_MIN   50000</a>
<a name="ln4336">#define ATH_HAL_5GHZ_FREQ_MAX   59999</a>
<a name="ln4337"> </a>
<a name="ln4338">#if 0</a>
<a name="ln4339">int</a>
<a name="ln4340">ar9300_set_spur_info(struct ath_hal * ah, int enable, int len, u_int16_t *freq)</a>
<a name="ln4341">{</a>
<a name="ln4342">    struct ath_hal_private *ap = AH_PRIVATE(ah);</a>
<a name="ln4343">    int i, j, k;</a>
<a name="ln4344"> </a>
<a name="ln4345">    ap-&gt;ah_config.ath_hal_spur_mode = enable;</a>
<a name="ln4346"> </a>
<a name="ln4347">    if (ap-&gt;ah_config.ath_hal_spur_mode == SPUR_ENABLE_IOCTL) {</a>
<a name="ln4348">        for (i = 0; i &lt; AR_EEPROM_MODAL_SPURS; i++) {</a>
<a name="ln4349">            AH9300(ah)-&gt;ath_hal_spur_chans[i][0] = AR_NO_SPUR;</a>
<a name="ln4350">            AH9300(ah)-&gt;ath_hal_spur_chans[i][1] = AR_NO_SPUR;</a>
<a name="ln4351">        }</a>
<a name="ln4352">        for (i = 0, j = 0, k = 0; i &lt; len; i++) {</a>
<a name="ln4353">            if (freq[i] &gt; ATH_HAL_2GHZ_FREQ_MIN &amp;&amp;</a>
<a name="ln4354">                freq[i] &lt; ATH_HAL_2GHZ_FREQ_MAX)</a>
<a name="ln4355">            {</a>
<a name="ln4356">                /* 2GHz Spur */</a>
<a name="ln4357">                if (j &lt; AR_EEPROM_MODAL_SPURS) {</a>
<a name="ln4358">                    AH9300(ah)-&gt;ath_hal_spur_chans[j++][1] =  freq[i];</a>
<a name="ln4359">                    HALDEBUG(ah, HAL_DEBUG_ANI, &quot;1 set spur %d\n&quot;, freq[i]);</a>
<a name="ln4360">                }</a>
<a name="ln4361">            } else if (freq[i] &gt; ATH_HAL_5GHZ_FREQ_MIN &amp;&amp;</a>
<a name="ln4362">                       freq[i] &lt; ATH_HAL_5GHZ_FREQ_MAX)</a>
<a name="ln4363">            {</a>
<a name="ln4364">                /* 5Ghz Spur */</a>
<a name="ln4365">                if (k &lt; AR_EEPROM_MODAL_SPURS) {</a>
<a name="ln4366">                    AH9300(ah)-&gt;ath_hal_spur_chans[k++][0] =  freq[i];</a>
<a name="ln4367">                    HALDEBUG(ah, HAL_DEBUG_ANI, &quot;2 set spur %d\n&quot;, freq[i]);</a>
<a name="ln4368">                }</a>
<a name="ln4369">            }</a>
<a name="ln4370">        }</a>
<a name="ln4371">    }</a>
<a name="ln4372"> </a>
<a name="ln4373">    return 0;</a>
<a name="ln4374">}</a>
<a name="ln4375">#endif</a>
<a name="ln4376"> </a>
<a name="ln4377">#define ar9300_check_op_mode(_opmode) \</a>
<a name="ln4378">    ((_opmode == HAL_M_STA) || (_opmode == HAL_M_IBSS) ||\</a>
<a name="ln4379">     (_opmode == HAL_M_HOSTAP) || (_opmode == HAL_M_MONITOR))</a>
<a name="ln4380"> </a>
<a name="ln4381"> </a>
<a name="ln4382"> </a>
<a name="ln4383"> </a>
<a name="ln4384">#ifndef ATH_NF_PER_CHAN</a>
<a name="ln4385">/*</a>
<a name="ln4386">* To fixed first reset noise floor value not correct issue</a>
<a name="ln4387">* For ART need it to fixed low rate sens too low issue	</a>
<a name="ln4388">*/</a>
<a name="ln4389">static int</a>
<a name="ln4390">First_NFCal(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *ichan, </a>
<a name="ln4391">    int is_scan, struct ieee80211_channel *chan)</a>
<a name="ln4392">{</a>
<a name="ln4393">    HAL_NFCAL_HIST_FULL *nfh;</a>
<a name="ln4394">    int i, j, k;</a>
<a name="ln4395">    int16_t nfarray[HAL_NUM_NF_READINGS] = {0};</a>
<a name="ln4396">    int is_2g = 0;</a>
<a name="ln4397">    int nf_hist_len;</a>
<a name="ln4398">    int stats = 0;</a>
<a name="ln4399">	</a>
<a name="ln4400">    int16_t nf_buf[HAL_NUM_NF_READINGS];</a>
<a name="ln4401">#define IS(_c, _f)       (((_c)-&gt;channel_flags &amp; _f) || 0)</a>
<a name="ln4402"> </a>
<a name="ln4403"> </a>
<a name="ln4404">    if ((!is_scan) &amp;&amp;</a>
<a name="ln4405">        chan-&gt;ic_freq == AH_PRIVATE(ah)-&gt;ah_curchan-&gt;ic_freq)</a>
<a name="ln4406">    {</a>
<a name="ln4407">        nfh = &amp;AH_PRIVATE(ah)-&gt;nf_cal_hist;</a>
<a name="ln4408">    } else {</a>
<a name="ln4409">        nfh = (HAL_NFCAL_HIST_FULL *) &amp;ichan-&gt;nf_cal_hist;</a>
<a name="ln4410">    }</a>
<a name="ln4411"> </a>
<a name="ln4412">    ar9300_start_nf_cal(ah);</a>
<a name="ln4413">    for (j = 0; j &lt; 10000; j++) {</a>
<a name="ln4414">        if ((OS_REG_READ(ah, AR_PHY_AGC_CONTROL) &amp; AR_PHY_AGC_CONTROL_NF) == 0){</a>
<a name="ln4415">            break;</a>
<a name="ln4416">		}</a>
<a name="ln4417">        OS_DELAY(10);</a>
<a name="ln4418">    }</a>
<a name="ln4419">	if (j &lt; 10000) {</a>
<a name="ln4420">        is_2g = IEEE80211_IS_CHAN_2GHZ(chan);</a>
<a name="ln4421">        ar9300_upload_noise_floor(ah, is_2g, nfarray);</a>
<a name="ln4422"> </a>
<a name="ln4423">	    if (is_scan) {</a>
<a name="ln4424">			/*</a>
<a name="ln4425">			 * This channel's NF cal info is just a HAL_NFCAL_HIST_SMALL struct</a>
<a name="ln4426">			 * rather than a HAL_NFCAL_HIST_FULL struct.</a>
<a name="ln4427">			 * As long as we only use the first history element of nf_cal_buffer</a>
<a name="ln4428">			 * (nf_cal_buffer[0][0:HAL_NUM_NF_READINGS-1]), we can use</a>
<a name="ln4429">			 * HAL_NFCAL_HIST_SMALL and HAL_NFCAL_HIST_FULL interchangeably.</a>
<a name="ln4430">			 */</a>
<a name="ln4431">            nfh = (HAL_NFCAL_HIST_FULL *) &amp;ichan-&gt;nf_cal_hist;</a>
<a name="ln4432">            nf_hist_len = HAL_NF_CAL_HIST_LEN_SMALL;</a>
<a name="ln4433">		} else {</a>
<a name="ln4434">            nfh = &amp;AH_PRIVATE(ah)-&gt;nf_cal_hist;</a>
<a name="ln4435">            nf_hist_len = HAL_NF_CAL_HIST_LEN_FULL;</a>
<a name="ln4436">		}</a>
<a name="ln4437"> </a>
<a name="ln4438">  	    for (i = 0; i &lt; HAL_NUM_NF_READINGS; i ++) {</a>
<a name="ln4439">    		for (k = 0; k &lt; HAL_NF_CAL_HIST_LEN_FULL; k++) {</a>
<a name="ln4440">                nfh-&gt;nf_cal_buffer[k][i] = nfarray[i];</a>
<a name="ln4441">            }</a>
<a name="ln4442">            nfh-&gt;base.priv_nf[i] = ar9300_limit_nf_range(ah, </a>
<a name="ln4443">							ar9300_get_nf_hist_mid(ah, nfh, i, nf_hist_len));</a>
<a name="ln4444">  		}</a>
<a name="ln4445"> </a>
<a name="ln4446"> </a>
<a name="ln4447">		//ar9300StoreNewNf(ah, ichan, is_scan);</a>
<a name="ln4448"> </a>
<a name="ln4449">		/*</a>
<a name="ln4450">		 * See if the NF value from the old channel should be</a>
<a name="ln4451">		 * retained when switching to a new channel.</a>
<a name="ln4452">		 * TBD: this may need to be changed, as it wipes out the</a>
<a name="ln4453">		 * purpose of saving NF values for each channel.</a>
<a name="ln4454">		 */</a>
<a name="ln4455">		for (i = 0; i &lt; HAL_NUM_NF_READINGS; i++)</a>
<a name="ln4456">		{</a>
<a name="ln4457">    		if (IEEE80211_IS_CHAN_2GHZ(chan))</a>
<a name="ln4458">    		{     </a>
<a name="ln4459">    			if (nfh-&gt;nf_cal_buffer[0][i] &lt;</a>
<a name="ln4460">					AR_PHY_CCA_MAX_GOOD_VAL_OSPREY_2GHZ)</a>
<a name="ln4461">                {</a>
<a name="ln4462">                    ichan-&gt;nf_cal_hist.nf_cal_buffer[0][i] =</a>
<a name="ln4463">							AH_PRIVATE(ah)-&gt;nf_cal_hist.nf_cal_buffer[0][i];</a>
<a name="ln4464">				}</a>
<a name="ln4465">    		} else {</a>
<a name="ln4466">                if (AR_SREV_AR9580(ah)) {</a>
<a name="ln4467">                    if (nfh-&gt;nf_cal_buffer[0][i] &lt;</a>
<a name="ln4468">                        AR_PHY_CCA_NOM_VAL_PEACOCK_5GHZ)  </a>
<a name="ln4469">                    {</a>
<a name="ln4470">                       ichan-&gt;nf_cal_hist.nf_cal_buffer[0][i] =</a>
<a name="ln4471">                       AH_PRIVATE(ah)-&gt;nf_cal_hist.nf_cal_buffer[0][i];</a>
<a name="ln4472">                    }</a>
<a name="ln4473">                } else {</a>
<a name="ln4474">                   if (nfh-&gt;nf_cal_buffer[0][i] &lt;</a>
<a name="ln4475">                       AR_PHY_CCA_NOM_VAL_OSPREY_5GHZ)  </a>
<a name="ln4476">                    {  </a>
<a name="ln4477">                        ichan-&gt;nf_cal_hist.nf_cal_buffer[0][i] =</a>
<a name="ln4478">                            AH_PRIVATE(ah)-&gt;nf_cal_hist.nf_cal_buffer[0][i];</a>
<a name="ln4479">                     }</a>
<a name="ln4480">                }</a>
<a name="ln4481">            }</a>
<a name="ln4482">        }</a>
<a name="ln4483">		/*</a>
<a name="ln4484">		 * Copy the channel's NF buffer, which may have been modified</a>
<a name="ln4485">		 * just above here, to the full NF history buffer.</a>
<a name="ln4486">		 */</a>
<a name="ln4487">        ar9300_reset_nf_hist_buff(ah, ichan);</a>
<a name="ln4488">        ar9300_get_nf_hist_base(ah, ichan, is_scan, nf_buf);</a>
<a name="ln4489">        ar9300_load_nf(ah, nf_buf);</a>
<a name="ln4490">        /* XXX TODO: handle failure from load_nf */</a>
<a name="ln4491">        stats = 0;</a>
<a name="ln4492">	} else {</a>
<a name="ln4493">        stats = 1;	</a>
<a name="ln4494">	}</a>
<a name="ln4495">#undef IS</a>
<a name="ln4496">    return stats;</a>
<a name="ln4497">}</a>
<a name="ln4498">#endif</a>
<a name="ln4499"> </a>
<a name="ln4500"> </a>
<a name="ln4501">/*</a>
<a name="ln4502"> * Places the device in and out of reset and then places sane</a>
<a name="ln4503"> * values in the registers based on EEPROM config, initialization</a>
<a name="ln4504"> * vectors (as determined by the mode), and station configuration</a>
<a name="ln4505"> *</a>
<a name="ln4506"> * b_channel_change is used to preserve DMA/PCU registers across</a>
<a name="ln4507"> * a HW Reset during channel change.</a>
<a name="ln4508"> */</a>
<a name="ln4509">HAL_BOOL</a>
<a name="ln4510">ar9300_reset(struct ath_hal *ah, HAL_OPMODE opmode, struct ieee80211_channel *chan,</a>
<a name="ln4511">    HAL_HT_MACMODE macmode, u_int8_t txchainmask, u_int8_t rxchainmask,</a>
<a name="ln4512">    HAL_HT_EXTPROTSPACING extprotspacing, HAL_BOOL b_channel_change,</a>
<a name="ln4513">    HAL_STATUS *status, int is_scan)</a>
<a name="ln4514">{</a>
<a name="ln4515">#define FAIL(_code)     do { ecode = _code; goto bad; } while (0)</a>
<a name="ln4516">    u_int32_t               save_led_state;</a>
<a name="ln4517">    struct ath_hal_9300     *ahp = AH9300(ah);</a>
<a name="ln4518">    struct ath_hal_private  *ap  = AH_PRIVATE(ah);</a>
<a name="ln4519">    HAL_CHANNEL_INTERNAL    *ichan;</a>
<a name="ln4520">    //const struct ieee80211_channel *curchan = ap-&gt;ah_curchan;</a>
<a name="ln4521">#if ATH_SUPPORT_MCI    </a>
<a name="ln4522">    HAL_BOOL                    save_full_sleep = ahp-&gt;ah_chip_full_sleep;</a>
<a name="ln4523">#endif    </a>
<a name="ln4524">    u_int32_t               save_def_antenna;</a>
<a name="ln4525">    u_int32_t               mac_sta_id1;</a>
<a name="ln4526">    HAL_STATUS              ecode;</a>
<a name="ln4527">    int                     i, rx_chainmask;</a>
<a name="ln4528">    int                     nf_hist_buff_reset = 0;</a>
<a name="ln4529">    int16_t                 nf_buf[HAL_NUM_NF_READINGS];</a>
<a name="ln4530">#ifdef ATH_FORCE_PPM</a>
<a name="ln4531">    u_int32_t               save_force_val, tmp_reg;</a>
<a name="ln4532">#endif</a>
<a name="ln4533">    u_int8_t                clk_25mhz = AH9300(ah)-&gt;clk_25mhz;</a>
<a name="ln4534">    HAL_BOOL                    stopped, cal_ret;</a>
<a name="ln4535">    HAL_BOOL                    apply_last_iqcorr = AH_FALSE;</a>
<a name="ln4536"> </a>
<a name="ln4537"> </a>
<a name="ln4538">    if (OS_REG_READ(ah, AR_IER) == AR_IER_ENABLE) {</a>
<a name="ln4539">        HALDEBUG(AH_NULL, HAL_DEBUG_UNMASKABLE, &quot;** Reset called with WLAN &quot;</a>
<a name="ln4540">                &quot;interrupt enabled %08x **\n&quot;, ar9300_get_interrupts(ah));</a>
<a name="ln4541">    }</a>
<a name="ln4542"> </a>
<a name="ln4543">    /*</a>
<a name="ln4544">     * Set the status to &quot;ok&quot; by default to cover the cases</a>
<a name="ln4545">     * where we return false without going to &quot;bad&quot;</a>
<a name="ln4546">     */</a>
<a name="ln4547">    HALASSERT(status);</a>
<a name="ln4548">    *status = HAL_OK;</a>
<a name="ln4549">    if ((ah-&gt;ah_config.ath_hal_sta_update_tx_pwr_enable)) {</a>
<a name="ln4550">        AH9300(ah)-&gt;green_tx_status = HAL_RSSI_TX_POWER_NONE;</a>
<a name="ln4551">    }</a>
<a name="ln4552"> </a>
<a name="ln4553">#if ATH_SUPPORT_MCI</a>
<a name="ln4554">    if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport &amp;&amp;</a>
<a name="ln4555">        (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)))</a>
<a name="ln4556">    {</a>
<a name="ln4557">        ar9300_mci_2g5g_changed(ah, IEEE80211_IS_CHAN_2GHZ(chan));</a>
<a name="ln4558">    }</a>
<a name="ln4559">#endif</a>
<a name="ln4560"> </a>
<a name="ln4561">    ahp-&gt;ah_ext_prot_spacing = extprotspacing;</a>
<a name="ln4562">    ahp-&gt;ah_tx_chainmask = txchainmask &amp; ap-&gt;ah_caps.halTxChainMask;</a>
<a name="ln4563">    ahp-&gt;ah_rx_chainmask = rxchainmask &amp; ap-&gt;ah_caps.halRxChainMask;</a>
<a name="ln4564">    ahp-&gt;ah_tx_cal_chainmask = ap-&gt;ah_caps.halTxChainMask;</a>
<a name="ln4565">    ahp-&gt;ah_rx_cal_chainmask = ap-&gt;ah_caps.halRxChainMask;</a>
<a name="ln4566"> </a>
<a name="ln4567">    /* </a>
<a name="ln4568">     * Keep the previous optinal txchainmask value</a>
<a name="ln4569">     */</a>
<a name="ln4570"> </a>
<a name="ln4571">    HALASSERT(ar9300_check_op_mode(opmode));</a>
<a name="ln4572"> </a>
<a name="ln4573">    OS_MARK(ah, AH_MARK_RESET, b_channel_change);</a>
<a name="ln4574"> </a>
<a name="ln4575">    /*</a>
<a name="ln4576">     * Map public channel to private.</a>
<a name="ln4577">     */</a>
<a name="ln4578">    ichan = ar9300_check_chan(ah, chan);</a>
<a name="ln4579">    if (ichan == AH_NULL) {</a>
<a name="ln4580">        HALDEBUG(ah, HAL_DEBUG_CHANNEL,</a>
<a name="ln4581">            &quot;%s: invalid channel %u/0x%x; no mapping\n&quot;,</a>
<a name="ln4582">            __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln4583">        FAIL(HAL_EINVAL);</a>
<a name="ln4584">    }</a>
<a name="ln4585">    </a>
<a name="ln4586">    ichan-&gt;paprd_table_write_done = 0;  /* Clear PAPRD table write flag */</a>
<a name="ln4587">#if 0</a>
<a name="ln4588">    chan-&gt;paprd_table_write_done = 0;  /* Clear PAPRD table write flag */</a>
<a name="ln4589">#endif</a>
<a name="ln4590"> </a>
<a name="ln4591">    if (ar9300_get_power_mode(ah) != HAL_PM_FULL_SLEEP) {</a>
<a name="ln4592">        /* Need to stop RX DMA before reset otherwise chip might hang */</a>
<a name="ln4593">        stopped = ar9300_set_rx_abort(ah, AH_TRUE); /* abort and disable PCU */</a>
<a name="ln4594">        ar9300_set_rx_filter(ah, 0);</a>
<a name="ln4595">        stopped &amp;= ar9300_stop_dma_receive(ah, 0); /* stop and disable RX DMA */</a>
<a name="ln4596">        if (!stopped) {</a>
<a name="ln4597">            /*</a>
<a name="ln4598">             * During the transition from full sleep to reset,</a>
<a name="ln4599">             * recv DMA regs are not available to be read</a>
<a name="ln4600">             */</a>
<a name="ln4601">            HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln4602">                &quot;%s[%d]: ar9300_stop_dma_receive failed\n&quot;, __func__, __LINE__);</a>
<a name="ln4603">            b_channel_change = AH_FALSE;</a>
<a name="ln4604">        }</a>
<a name="ln4605">    } else {</a>
<a name="ln4606">        HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln4607">            &quot;%s[%d]: Chip is already in full sleep\n&quot;, __func__, __LINE__);</a>
<a name="ln4608">    }</a>
<a name="ln4609"> </a>
<a name="ln4610">#if ATH_SUPPORT_MCI</a>
<a name="ln4611">    if ((AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport) &amp;&amp;</a>
<a name="ln4612">        (ahp-&gt;ah_mci_bt_state == MCI_BT_CAL_START))</a>
<a name="ln4613">    {</a>
<a name="ln4614">        u_int32_t payload[4] = {0, 0, 0, 0};</a>
<a name="ln4615"> </a>
<a name="ln4616">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln4617">            &quot;(MCI) %s: Stop rx for BT cal.\n&quot;, __func__);</a>
<a name="ln4618">        ahp-&gt;ah_mci_bt_state = MCI_BT_CAL;</a>
<a name="ln4619"> </a>
<a name="ln4620">        /*</a>
<a name="ln4621">         * MCIFIX: disable mci interrupt here. This is to avoid SW_MSG_DONE or</a>
<a name="ln4622">         * RX_MSG bits to trigger MCI_INT and lead to mci_intr reentry.</a>
<a name="ln4623">         */</a>
<a name="ln4624">        ar9300_mci_disable_interrupt(ah);</a>
<a name="ln4625"> </a>
<a name="ln4626">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln4627">            &quot;(MCI) %s: Send WLAN_CAL_GRANT\n&quot;, __func__);</a>
<a name="ln4628">        MCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_GRANT);</a>
<a name="ln4629">        ar9300_mci_send_message(ah, MCI_GPM, 0, payload, 16, AH_TRUE, AH_FALSE);</a>
<a name="ln4630"> </a>
<a name="ln4631">        /* Wait BT calibration to be completed for 25ms */</a>
<a name="ln4632">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln4633">            &quot;(MCI) %s: BT is calibrating.\n&quot;, __func__);</a>
<a name="ln4634">        if (ar9300_mci_wait_for_gpm(ah, MCI_GPM_BT_CAL_DONE, 0, 25000)) {</a>
<a name="ln4635">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln4636">                &quot;(MCI) %s: Got BT_CAL_DONE.\n&quot;, __func__);</a>
<a name="ln4637">        }</a>
<a name="ln4638">        else {</a>
<a name="ln4639">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln4640">                &quot;(MCI) %s: ### BT cal takes too long. Force bt_state to be bt_awake.\n&quot;, </a>
<a name="ln4641">                __func__);</a>
<a name="ln4642">        }</a>
<a name="ln4643">        ahp-&gt;ah_mci_bt_state = MCI_BT_AWAKE;</a>
<a name="ln4644">        /* MCIFIX: enable mci interrupt here */</a>
<a name="ln4645">        ar9300_mci_enable_interrupt(ah);</a>
<a name="ln4646"> </a>
<a name="ln4647">        return AH_TRUE;</a>
<a name="ln4648">    }</a>
<a name="ln4649">#endif</a>
<a name="ln4650"> </a>
<a name="ln4651">    /* Bring out of sleep mode */</a>
<a name="ln4652">    if (!ar9300_set_power_mode(ah, HAL_PM_AWAKE, AH_TRUE)) {</a>
<a name="ln4653">        *status = HAL_INV_PMODE;</a>
<a name="ln4654">        return AH_FALSE;</a>
<a name="ln4655">    }</a>
<a name="ln4656"> </a>
<a name="ln4657">    /* Check the Rx mitigation config again, it might have changed</a>
<a name="ln4658">     * during attach in ath_vap_attach.</a>
<a name="ln4659">     */</a>
<a name="ln4660">    if (ah-&gt;ah_config.ath_hal_intr_mitigation_rx != 0) {</a>
<a name="ln4661">        ahp-&gt;ah_intr_mitigation_rx = AH_TRUE;</a>
<a name="ln4662">    } else {</a>
<a name="ln4663">        ahp-&gt;ah_intr_mitigation_rx = AH_FALSE;</a>
<a name="ln4664">    }</a>
<a name="ln4665"> </a>
<a name="ln4666">    /*</a>
<a name="ln4667">     * XXX TODO FreeBSD:</a>
<a name="ln4668">     *</a>
<a name="ln4669">     * This is painful because we don't have a non-const channel pointer</a>
<a name="ln4670">     * at this stage.</a>
<a name="ln4671">     *</a>
<a name="ln4672">     * Make sure this gets fixed!</a>
<a name="ln4673">     */</a>
<a name="ln4674">#if 0</a>
<a name="ln4675">    /* Get the value from the previous NF cal and update history buffer */</a>
<a name="ln4676">    if (curchan &amp;&amp; (ahp-&gt;ah_chip_full_sleep != AH_TRUE)) {</a>
<a name="ln4677"> </a>
<a name="ln4678">        if(ahp-&gt;ah_chip_reset_done){</a>
<a name="ln4679">            ahp-&gt;ah_chip_reset_done = 0;</a>
<a name="ln4680">        } else {</a>
<a name="ln4681">        	/*</a>
<a name="ln4682">         	 * is_scan controls updating NF for home channel or off channel.</a>
<a name="ln4683">         	 * Home -&gt; Off, update home channel</a>
<a name="ln4684">         	 * Off -&gt; Home, update off channel</a>
<a name="ln4685">         	 * Home -&gt; Home, uppdate home channel</a>
<a name="ln4686">         	 */</a>
<a name="ln4687">        	if (ap-&gt;ah_curchan-&gt;channel != chan-&gt;channel)</a>
<a name="ln4688">            	ar9300_store_new_nf(ah, curchan, !is_scan);</a>
<a name="ln4689">        	else</a>
<a name="ln4690">            	ar9300_store_new_nf(ah, curchan, is_scan);</a>
<a name="ln4691">        }</a>
<a name="ln4692">    }</a>
<a name="ln4693">#endif</a>
<a name="ln4694"> </a>
<a name="ln4695">    /*</a>
<a name="ln4696">     * Account for the effect of being in either the 2 GHz or 5 GHz band</a>
<a name="ln4697">     * on the nominal, max allowable, and min allowable noise floor values.</a>
<a name="ln4698">     */</a>
<a name="ln4699">    AH9300(ah)-&gt;nfp = IS_CHAN_2GHZ(ichan) ? &amp;ahp-&gt;nf_2GHz : &amp;ahp-&gt;nf_5GHz;</a>
<a name="ln4700"> </a>
<a name="ln4701">    /*</a>
<a name="ln4702">     * XXX FreeBSD For now, don't apply the last IQ correction.</a>
<a name="ln4703">     *</a>
<a name="ln4704">     * This should be done when scorpion is enabled on FreeBSD; just be</a>
<a name="ln4705">     * sure to fix this channel match code so it uses net80211 flags</a>
<a name="ln4706">     * instead.</a>
<a name="ln4707">     */</a>
<a name="ln4708">#if 0</a>
<a name="ln4709">    if (AR_SREV_SCORPION(ah) &amp;&amp; curchan &amp;&amp; (chan-&gt;channel == curchan-&gt;channel) &amp;&amp;</a>
<a name="ln4710">        ((chan-&gt;channel_flags &amp; (CHANNEL_ALL|CHANNEL_HALF|CHANNEL_QUARTER)) ==</a>
<a name="ln4711">         (curchan-&gt;channel_flags &amp;</a>
<a name="ln4712">          (CHANNEL_ALL | CHANNEL_HALF | CHANNEL_QUARTER)))) {</a>
<a name="ln4713">            apply_last_iqcorr = AH_TRUE;</a>
<a name="ln4714">    }</a>
<a name="ln4715">#endif</a>
<a name="ln4716">    apply_last_iqcorr = AH_FALSE;</a>
<a name="ln4717"> </a>
<a name="ln4718"> </a>
<a name="ln4719">#ifndef ATH_NF_PER_CHAN</a>
<a name="ln4720">    /*</a>
<a name="ln4721">     * If there's only one full-size home-channel NF history buffer</a>
<a name="ln4722">     * rather than a full-size NF history buffer per channel, decide</a>
<a name="ln4723">     * whether to (re)initialize the home-channel NF buffer.</a>
<a name="ln4724">     * If this is just a channel change for a scan, or if the channel</a>
<a name="ln4725">     * is not being changed, don't mess up the home channel NF history</a>
<a name="ln4726">     * buffer with NF values from this scanned channel.  If we're</a>
<a name="ln4727">     * changing the home channel to a new channel, reset the home-channel</a>
<a name="ln4728">     * NF history buffer with the most accurate NF known for the new channel.</a>
<a name="ln4729">     */</a>
<a name="ln4730">    if (!is_scan &amp;&amp; (!ap-&gt;ah_curchan ||</a>
<a name="ln4731">        ap-&gt;ah_curchan-&gt;ic_freq != chan-&gt;ic_freq)) // ||</a>
<a name="ln4732">//        ap-&gt;ah_curchan-&gt;channel_flags != chan-&gt;channel_flags))</a>
<a name="ln4733">    {</a>
<a name="ln4734">        nf_hist_buff_reset = 1;</a>
<a name="ln4735">        ar9300_reset_nf_hist_buff(ah, ichan);</a>
<a name="ln4736">    }</a>
<a name="ln4737">#endif</a>
<a name="ln4738">    /*</a>
<a name="ln4739">     * In case of</a>
<a name="ln4740">     * - offchan scan, or</a>
<a name="ln4741">     * - same channel and RX IQ Cal already available</a>
<a name="ln4742">     * disable RX IQ Cal.</a>
<a name="ln4743">     */</a>
<a name="ln4744">    if (is_scan) {</a>
<a name="ln4745">        ahp-&gt;ah_skip_rx_iq_cal = AH_TRUE;</a>
<a name="ln4746">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln4747">                &quot;Skip RX IQ Cal due to scanning\n&quot;);</a>
<a name="ln4748">    } else {</a>
<a name="ln4749">#if 0</a>
<a name="ln4750">        /* XXX FreeBSD: always just do the RX IQ cal */</a>
<a name="ln4751">	/* XXX I think it's just going to speed things up; I don't think it's to avoid chan bugs */</a>
<a name="ln4752">        if (ahp-&gt;ah_rx_cal_complete &amp;&amp;</a>
<a name="ln4753">            ahp-&gt;ah_rx_cal_chan == ichan-&gt;channel &amp;&amp;</a>
<a name="ln4754">            ahp-&gt;ah_rx_cal_chan_flag == chan-&gt;channel_flags) {</a>
<a name="ln4755">            ahp-&gt;ah_skip_rx_iq_cal = AH_TRUE;</a>
<a name="ln4756">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln4757">                    &quot;Skip RX IQ Cal due to same channel with completed RX IQ Cal\n&quot;);</a>
<a name="ln4758">        } else</a>
<a name="ln4759">#endif</a>
<a name="ln4760">            ahp-&gt;ah_skip_rx_iq_cal = AH_FALSE;</a>
<a name="ln4761">    }</a>
<a name="ln4762"> </a>
<a name="ln4763">    /* FreeBSD: clear the channel survey data */</a>
<a name="ln4764">    ath_hal_survey_clear(ah);</a>
<a name="ln4765"> </a>
<a name="ln4766">    /*</a>
<a name="ln4767">     * Fast channel change (Change synthesizer based on channel freq</a>
<a name="ln4768">     * without resetting chip)</a>
<a name="ln4769">     * Don't do it when</a>
<a name="ln4770">     *   - Flag is not set</a>
<a name="ln4771">     *   - Chip is just coming out of full sleep</a>
<a name="ln4772">     *   - Channel to be set is same as current channel</a>
<a name="ln4773">     *   - Channel flags are different, like when moving from 2GHz to 5GHz</a>
<a name="ln4774">     *     channels</a>
<a name="ln4775">     *   - Merlin: Switching in/out of fast clock enabled channels</a>
<a name="ln4776">     *             (not currently coded, since fast clock is enabled</a>
<a name="ln4777">     *             across the 5GHz band</a>
<a name="ln4778">     *             and we already do a full reset when switching in/out</a>
<a name="ln4779">     *             of 5GHz channels)</a>
<a name="ln4780">     */</a>
<a name="ln4781">#if 0</a>
<a name="ln4782">    if (b_channel_change &amp;&amp;</a>
<a name="ln4783">        (ahp-&gt;ah_chip_full_sleep != AH_TRUE) &amp;&amp;</a>
<a name="ln4784">        (AH_PRIVATE(ah)-&gt;ah_curchan != AH_NULL) &amp;&amp;</a>
<a name="ln4785">        ((chan-&gt;channel != AH_PRIVATE(ah)-&gt;ah_curchan-&gt;channel) &amp;&amp;</a>
<a name="ln4786">        (((CHANNEL_ALL|CHANNEL_HALF|CHANNEL_QUARTER) &amp; chan-&gt;channel_flags) == </a>
<a name="ln4787">        ((CHANNEL_ALL|CHANNEL_HALF|CHANNEL_QUARTER) &amp; AH_PRIVATE(ah)-&gt;ah_curchan-&gt;channel_flags))))</a>
<a name="ln4788">    {</a>
<a name="ln4789">        if (ar9300_channel_change(ah, chan, ichan, macmode)) {</a>
<a name="ln4790">            chan-&gt;channel_flags = ichan-&gt;channel_flags;</a>
<a name="ln4791">            chan-&gt;priv_flags = ichan-&gt;priv_flags;</a>
<a name="ln4792">            AH_PRIVATE(ah)-&gt;ah_curchan-&gt;ah_channel_time = 0;</a>
<a name="ln4793">            AH_PRIVATE(ah)-&gt;ah_curchan-&gt;ah_tsf_last = ar9300_get_tsf64(ah);</a>
<a name="ln4794"> </a>
<a name="ln4795">            /*</a>
<a name="ln4796">             * Load the NF from history buffer of the current channel.</a>
<a name="ln4797">             * NF is slow time-variant, so it is OK to use a historical value.</a>
<a name="ln4798">             */</a>
<a name="ln4799">            ar9300_get_nf_hist_base(ah,</a>
<a name="ln4800">                AH_PRIVATE(ah)-&gt;ah_curchan, is_scan, nf_buf);</a>
<a name="ln4801">            ar9300_load_nf(ah, nf_buf);</a>
<a name="ln4802"> </a>
<a name="ln4803">            /* start NF calibration, without updating BB NF register*/</a>
<a name="ln4804">            ar9300_start_nf_cal(ah);</a>
<a name="ln4805"> </a>
<a name="ln4806">            /*</a>
<a name="ln4807">             * If channel_change completed and DMA was stopped</a>
<a name="ln4808">             * successfully - skip the rest of reset</a>
<a name="ln4809">             */</a>
<a name="ln4810">            if (AH9300(ah)-&gt;ah_dma_stuck != AH_TRUE) {</a>
<a name="ln4811">                ar9300_disable_pll_lock_detect(ah);</a>
<a name="ln4812">#if ATH_SUPPORT_MCI</a>
<a name="ln4813">                if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport &amp;&amp; ahp-&gt;ah_mci_ready)</a>
<a name="ln4814">                {</a>
<a name="ln4815">                    ar9300_mci_2g5g_switch(ah, AH_TRUE);</a>
<a name="ln4816">                }</a>
<a name="ln4817">#endif</a>
<a name="ln4818">                return HAL_OK;</a>
<a name="ln4819">            }</a>
<a name="ln4820">         }</a>
<a name="ln4821">    }</a>
<a name="ln4822">#endif /* #if 0 */</a>
<a name="ln4823"> </a>
<a name="ln4824">#if ATH_SUPPORT_MCI</a>
<a name="ln4825">    if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport) {</a>
<a name="ln4826">        ar9300_mci_disable_interrupt(ah);</a>
<a name="ln4827">        if (ahp-&gt;ah_mci_ready &amp;&amp; !save_full_sleep) {</a>
<a name="ln4828">            ar9300_mci_mute_bt(ah);</a>
<a name="ln4829">            OS_DELAY(20);</a>
<a name="ln4830">            OS_REG_WRITE(ah, AR_BTCOEX_CTRL, 0);</a>
<a name="ln4831">        }</a>
<a name="ln4832"> </a>
<a name="ln4833">        ahp-&gt;ah_mci_bt_state = MCI_BT_SLEEP;</a>
<a name="ln4834">        ahp-&gt;ah_mci_ready = AH_FALSE;</a>
<a name="ln4835">    }</a>
<a name="ln4836">#endif</a>
<a name="ln4837"> </a>
<a name="ln4838">    AH9300(ah)-&gt;ah_dma_stuck = AH_FALSE;</a>
<a name="ln4839">#ifdef ATH_FORCE_PPM</a>
<a name="ln4840">    /* Preserve force ppm state */</a>
<a name="ln4841">    save_force_val =</a>
<a name="ln4842">        OS_REG_READ(ah, AR_PHY_TIMING2) &amp;</a>
<a name="ln4843">        (AR_PHY_TIMING2_USE_FORCE | AR_PHY_TIMING2_FORCE_VAL);</a>
<a name="ln4844">#endif</a>
<a name="ln4845">    /*</a>
<a name="ln4846">     * Preserve the antenna on a channel change</a>
<a name="ln4847">     */</a>
<a name="ln4848">    save_def_antenna = OS_REG_READ(ah, AR_DEF_ANTENNA);</a>
<a name="ln4849">    if (0 == ahp-&gt;ah_smartantenna_enable )</a>
<a name="ln4850">    {</a>
<a name="ln4851">        if (save_def_antenna == 0) {</a>
<a name="ln4852">            save_def_antenna = 1;</a>
<a name="ln4853">        }</a>
<a name="ln4854">    } </a>
<a name="ln4855"> </a>
<a name="ln4856">    /* Save hardware flag before chip reset clears the register */</a>
<a name="ln4857">    mac_sta_id1 = OS_REG_READ(ah, AR_STA_ID1) &amp; AR_STA_ID1_BASE_RATE_11B;</a>
<a name="ln4858"> </a>
<a name="ln4859">    /* Save led state from pci config register */</a>
<a name="ln4860">    save_led_state = OS_REG_READ(ah, AR_CFG_LED) &amp;</a>
<a name="ln4861">        (AR_CFG_LED_ASSOC_CTL | AR_CFG_LED_MODE_SEL |</a>
<a name="ln4862">        AR_CFG_LED_BLINK_THRESH_SEL | AR_CFG_LED_BLINK_SLOW);</a>
<a name="ln4863"> </a>
<a name="ln4864">    /* Mark PHY inactive prior to reset, to be undone in ar9300_init_bb () */</a>
<a name="ln4865">    ar9300_mark_phy_inactive(ah);</a>
<a name="ln4866"> </a>
<a name="ln4867">    if (!ar9300_chip_reset(ah, chan)) {</a>
<a name="ln4868">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: chip reset failed\n&quot;, __func__);</a>
<a name="ln4869">        FAIL(HAL_EIO);</a>
<a name="ln4870">    }</a>
<a name="ln4871"> </a>
<a name="ln4872">    OS_MARK(ah, AH_MARK_RESET_LINE, __LINE__);</a>
<a name="ln4873"> </a>
<a name="ln4874"> </a>
<a name="ln4875">    /* Disable JTAG */</a>
<a name="ln4876">    OS_REG_SET_BIT(ah,</a>
<a name="ln4877">        AR_HOSTIF_REG(ah, AR_GPIO_INPUT_EN_VAL), AR_GPIO_JTAG_DISABLE);</a>
<a name="ln4878"> </a>
<a name="ln4879">    /*</a>
<a name="ln4880">     * Note that ar9300_init_chain_masks() is called from within</a>
<a name="ln4881">     * ar9300_process_ini() to ensure the swap bit is set before</a>
<a name="ln4882">     * the pdadc table is written.</a>
<a name="ln4883">     */</a>
<a name="ln4884">    ecode = ar9300_process_ini(ah, chan, ichan, macmode);</a>
<a name="ln4885">    if (ecode != HAL_OK) {</a>
<a name="ln4886">        goto bad;</a>
<a name="ln4887">    }</a>
<a name="ln4888"> </a>
<a name="ln4889">    /*</a>
<a name="ln4890">     * Configuring WMAC PLL values for 25/40 MHz </a>
<a name="ln4891">     */</a>
<a name="ln4892">    if(AR_SREV_WASP(ah) || AR_SREV_HONEYBEE(ah) || AR_SREV_SCORPION(ah) ) {</a>
<a name="ln4893">        if(clk_25mhz) {</a>
<a name="ln4894">            OS_REG_WRITE(ah, AR_RTC_DERIVED_RTC_CLK, (0x17c &lt;&lt; 1)); // 32KHz sleep clk</a>
<a name="ln4895">        } else {</a>
<a name="ln4896">            OS_REG_WRITE(ah, AR_RTC_DERIVED_RTC_CLK, (0x261 &lt;&lt; 1)); // 32KHz sleep clk</a>
<a name="ln4897">        }</a>
<a name="ln4898">        OS_DELAY(100);</a>
<a name="ln4899">    }</a>
<a name="ln4900"> </a>
<a name="ln4901">    ahp-&gt;ah_immunity_on = AH_FALSE;</a>
<a name="ln4902"> </a>
<a name="ln4903">    if (AR_SREV_JUPITER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln4904">        ahp-&gt;tx_iq_cal_enable = OS_REG_READ_FIELD(ah,</a>
<a name="ln4905">                                AR_PHY_TX_IQCAL_CONTROL_0(ah),</a>
<a name="ln4906">                                AR_PHY_TX_IQCAL_CONTROL_0_ENABLE_TXIQ_CAL) ?</a>
<a name="ln4907">                                1 : 0;</a>
<a name="ln4908">    }</a>
<a name="ln4909">    ahp-&gt;tx_cl_cal_enable = (OS_REG_READ(ah, AR_PHY_CL_CAL_CTL) &amp;</a>
<a name="ln4910">                                AR_PHY_CL_CAL_ENABLE) ? 1 : 0;</a>
<a name="ln4911"> </a>
<a name="ln4912">    /* For devices with full HW RIFS Rx support (Sowl/Howl/Merlin, etc),</a>
<a name="ln4913">     * restore register settings from prior to reset.</a>
<a name="ln4914">     */</a>
<a name="ln4915">    if ((AH_PRIVATE(ah)-&gt;ah_curchan != AH_NULL) &amp;&amp;</a>
<a name="ln4916">        (ar9300_get_capability(ah, HAL_CAP_LDPCWAR, 0, AH_NULL) == HAL_OK))</a>
<a name="ln4917">    {</a>
<a name="ln4918">        /* Re-program RIFS Rx policy after reset */</a>
<a name="ln4919">        ar9300_set_rifs_delay(ah, ahp-&gt;ah_rifs_enabled);</a>
<a name="ln4920">    }</a>
<a name="ln4921"> </a>
<a name="ln4922">#if ATH_SUPPORT_MCI</a>
<a name="ln4923">    if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport) {</a>
<a name="ln4924">        ar9300_mci_reset(ah, AH_FALSE, IS_CHAN_2GHZ(ichan), save_full_sleep);</a>
<a name="ln4925">    }</a>
<a name="ln4926">#endif</a>
<a name="ln4927"> </a>
<a name="ln4928">    /* Initialize Management Frame Protection */</a>
<a name="ln4929">    ar9300_init_mfp(ah);</a>
<a name="ln4930"> </a>
<a name="ln4931">    ahp-&gt;ah_immunity_vals[0] = OS_REG_READ_FIELD(ah, AR_PHY_SFCORR_LOW,</a>
<a name="ln4932">        AR_PHY_SFCORR_LOW_M1_THRESH_LOW);</a>
<a name="ln4933">    ahp-&gt;ah_immunity_vals[1] = OS_REG_READ_FIELD(ah, AR_PHY_SFCORR_LOW,</a>
<a name="ln4934">        AR_PHY_SFCORR_LOW_M2_THRESH_LOW);</a>
<a name="ln4935">    ahp-&gt;ah_immunity_vals[2] = OS_REG_READ_FIELD(ah, AR_PHY_SFCORR,</a>
<a name="ln4936">        AR_PHY_SFCORR_M1_THRESH);</a>
<a name="ln4937">    ahp-&gt;ah_immunity_vals[3] = OS_REG_READ_FIELD(ah, AR_PHY_SFCORR,</a>
<a name="ln4938">        AR_PHY_SFCORR_M2_THRESH);</a>
<a name="ln4939">    ahp-&gt;ah_immunity_vals[4] = OS_REG_READ_FIELD(ah, AR_PHY_SFCORR,</a>
<a name="ln4940">        AR_PHY_SFCORR_M2COUNT_THR);</a>
<a name="ln4941">    ahp-&gt;ah_immunity_vals[5] = OS_REG_READ_FIELD(ah, AR_PHY_SFCORR_LOW,</a>
<a name="ln4942">        AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW);</a>
<a name="ln4943"> </a>
<a name="ln4944">    /* Write delta slope for OFDM enabled modes (A, G, Turbo) */</a>
<a name="ln4945">    if (IEEE80211_IS_CHAN_OFDM(chan) || IEEE80211_IS_CHAN_HT(chan)) {</a>
<a name="ln4946">        ar9300_set_delta_slope(ah, chan);</a>
<a name="ln4947">    }</a>
<a name="ln4948"> </a>
<a name="ln4949">    ar9300_spur_mitigate(ah, chan);</a>
<a name="ln4950">    if (!ar9300_eeprom_set_board_values(ah, chan)) {</a>
<a name="ln4951">        HALDEBUG(ah, HAL_DEBUG_EEPROM,</a>
<a name="ln4952">            &quot;%s: error setting board options\n&quot;, __func__);</a>
<a name="ln4953">        FAIL(HAL_EIO);</a>
<a name="ln4954">    }</a>
<a name="ln4955"> </a>
<a name="ln4956">#ifdef ATH_HAL_WAR_REG16284_APH128</a>
<a name="ln4957">    /* temp work around, will be removed. */</a>
<a name="ln4958">    if (AR_SREV_WASP(ah)) {</a>
<a name="ln4959">        OS_REG_WRITE(ah, 0x16284, 0x1553e000); </a>
<a name="ln4960">    }</a>
<a name="ln4961">#endif</a>
<a name="ln4962"> </a>
<a name="ln4963">    OS_MARK(ah, AH_MARK_RESET_LINE, __LINE__);</a>
<a name="ln4964"> </a>
<a name="ln4965">    OS_REG_WRITE(ah, AR_STA_ID0, LE_READ_4(ahp-&gt;ah_macaddr));</a>
<a name="ln4966">    OS_REG_WRITE(ah, AR_STA_ID1, LE_READ_2(ahp-&gt;ah_macaddr + 4)</a>
<a name="ln4967">            | mac_sta_id1</a>
<a name="ln4968">            | AR_STA_ID1_RTS_USE_DEF</a>
<a name="ln4969">            | (ah-&gt;ah_config.ath_hal_6mb_ack ? AR_STA_ID1_ACKCTS_6MB : 0)</a>
<a name="ln4970">            | ahp-&gt;ah_sta_id1_defaults</a>
<a name="ln4971">    );</a>
<a name="ln4972">    ar9300_set_operating_mode(ah, opmode);</a>
<a name="ln4973"> </a>
<a name="ln4974">    /* Set Venice BSSID mask according to current state */</a>
<a name="ln4975">    OS_REG_WRITE(ah, AR_BSSMSKL, LE_READ_4(ahp-&gt;ah_bssid_mask));</a>
<a name="ln4976">    OS_REG_WRITE(ah, AR_BSSMSKU, LE_READ_2(ahp-&gt;ah_bssid_mask + 4));</a>
<a name="ln4977"> </a>
<a name="ln4978">    /* Restore previous antenna */</a>
<a name="ln4979">    OS_REG_WRITE(ah, AR_DEF_ANTENNA, save_def_antenna);</a>
<a name="ln4980">#ifdef ATH_FORCE_PPM</a>
<a name="ln4981">    /* Restore force ppm state */</a>
<a name="ln4982">    tmp_reg = OS_REG_READ(ah, AR_PHY_TIMING2) &amp;</a>
<a name="ln4983">        ~(AR_PHY_TIMING2_USE_FORCE | AR_PHY_TIMING2_FORCE_VAL);</a>
<a name="ln4984">    OS_REG_WRITE(ah, AR_PHY_TIMING2, tmp_reg | save_force_val);</a>
<a name="ln4985">#endif</a>
<a name="ln4986"> </a>
<a name="ln4987">    /* then our BSSID and assocID */</a>
<a name="ln4988">    OS_REG_WRITE(ah, AR_BSS_ID0, LE_READ_4(ahp-&gt;ah_bssid));</a>
<a name="ln4989">    OS_REG_WRITE(ah, AR_BSS_ID1,</a>
<a name="ln4990">        LE_READ_2(ahp-&gt;ah_bssid + 4) |</a>
<a name="ln4991">        ((ahp-&gt;ah_assoc_id &amp; 0x3fff) &lt;&lt; AR_BSS_ID1_AID_S));</a>
<a name="ln4992"> </a>
<a name="ln4993">    OS_REG_WRITE(ah, AR_ISR, ~0); /* cleared on write */</a>
<a name="ln4994"> </a>
<a name="ln4995">    OS_REG_RMW_FIELD(ah, AR_RSSI_THR, AR_RSSI_THR_BM_THR, INIT_RSSI_THR);</a>
<a name="ln4996"> </a>
<a name="ln4997">    /* HW beacon processing */</a>
<a name="ln4998">    /*</a>
<a name="ln4999">     * XXX what happens if I just leave filter_interval=0?</a>
<a name="ln5000">     * it stays disabled?</a>
<a name="ln5001">     */</a>
<a name="ln5002">    OS_REG_RMW_FIELD(ah, AR_RSSI_THR, AR_RSSI_BCN_WEIGHT,</a>
<a name="ln5003">            INIT_RSSI_BEACON_WEIGHT);</a>
<a name="ln5004">    OS_REG_SET_BIT(ah, AR_HWBCNPROC1, AR_HWBCNPROC1_CRC_ENABLE |</a>
<a name="ln5005">            AR_HWBCNPROC1_EXCLUDE_TIM_ELM);</a>
<a name="ln5006">    if (ah-&gt;ah_config.ath_hal_beacon_filter_interval) {</a>
<a name="ln5007">        OS_REG_RMW_FIELD(ah, AR_HWBCNPROC2, AR_HWBCNPROC2_FILTER_INTERVAL,</a>
<a name="ln5008">                ah-&gt;ah_config.ath_hal_beacon_filter_interval);</a>
<a name="ln5009">        OS_REG_SET_BIT(ah, AR_HWBCNPROC2,</a>
<a name="ln5010">                AR_HWBCNPROC2_FILTER_INTERVAL_ENABLE);</a>
<a name="ln5011">    }</a>
<a name="ln5012"> </a>
<a name="ln5013"> </a>
<a name="ln5014">    /*</a>
<a name="ln5015">     * Set Channel now modifies bank 6 parameters for FOWL workaround</a>
<a name="ln5016">     * to force rf_pwd_icsyndiv bias current as function of synth</a>
<a name="ln5017">     * frequency.Thus must be called after ar9300_process_ini() to ensure</a>
<a name="ln5018">     * analog register cache is valid.</a>
<a name="ln5019">     */</a>
<a name="ln5020">    if (!ahp-&gt;ah_rf_hal.set_channel(ah, chan)) {</a>
<a name="ln5021">        FAIL(HAL_EIO);</a>
<a name="ln5022">    }</a>
<a name="ln5023"> </a>
<a name="ln5024"> </a>
<a name="ln5025">    OS_MARK(ah, AH_MARK_RESET_LINE, __LINE__);</a>
<a name="ln5026"> </a>
<a name="ln5027">    /* Set 1:1 QCU to DCU mapping for all queues */</a>
<a name="ln5028">    for (i = 0; i &lt; AR_NUM_DCU; i++) {</a>
<a name="ln5029">        OS_REG_WRITE(ah, AR_DQCUMASK(i), 1 &lt;&lt; i);</a>
<a name="ln5030">    }</a>
<a name="ln5031"> </a>
<a name="ln5032">    ahp-&gt;ah_intr_txqs = 0;</a>
<a name="ln5033">    for (i = 0; i &lt; AH_PRIVATE(ah)-&gt;ah_caps.halTotalQueues; i++) {</a>
<a name="ln5034">        ar9300_reset_tx_queue(ah, i);</a>
<a name="ln5035">    }</a>
<a name="ln5036"> </a>
<a name="ln5037">    ar9300_init_interrupt_masks(ah, opmode);</a>
<a name="ln5038"> </a>
<a name="ln5039">    /* Reset ier reference count to disabled */</a>
<a name="ln5040">//    OS_ATOMIC_SET(&amp;ahp-&gt;ah_ier_ref_count, 1); </a>
<a name="ln5041">    if (ath_hal_isrfkillenabled(ah)) {</a>
<a name="ln5042">        ar9300_enable_rf_kill(ah);</a>
<a name="ln5043">    }</a>
<a name="ln5044"> </a>
<a name="ln5045">    /* must be called AFTER ini is processed */</a>
<a name="ln5046">    ar9300_ani_init_defaults(ah, macmode);</a>
<a name="ln5047"> </a>
<a name="ln5048">    ar9300_init_qos(ah);</a>
<a name="ln5049"> </a>
<a name="ln5050">    ar9300_init_user_settings(ah);</a>
<a name="ln5051"> </a>
<a name="ln5052"> </a>
<a name="ln5053">    AH_PRIVATE(ah)-&gt;ah_opmode = opmode; /* record operating mode */</a>
<a name="ln5054"> </a>
<a name="ln5055">    OS_MARK(ah, AH_MARK_RESET_DONE, 0);</a>
<a name="ln5056"> </a>
<a name="ln5057">    /*</a>
<a name="ln5058">     * disable seq number generation in hw</a>
<a name="ln5059">     */</a>
<a name="ln5060">    OS_REG_WRITE(ah, AR_STA_ID1,</a>
<a name="ln5061">        OS_REG_READ(ah, AR_STA_ID1) | AR_STA_ID1_PRESERVE_SEQNUM);</a>
<a name="ln5062"> </a>
<a name="ln5063">    ar9300_set_dma(ah);</a>
<a name="ln5064"> </a>
<a name="ln5065">    /*</a>
<a name="ln5066">     * program OBS bus to see MAC interrupts</a>
<a name="ln5067">     */</a>
<a name="ln5068">#if ATH_SUPPORT_MCI</a>
<a name="ln5069">    if (!AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport) {</a>
<a name="ln5070">        OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_OBS), 8);</a>
<a name="ln5071">    }</a>
<a name="ln5072">#else</a>
<a name="ln5073">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_OBS), 8);</a>
<a name="ln5074">#endif</a>
<a name="ln5075"> </a>
<a name="ln5076"> </a>
<a name="ln5077">    /* enabling AR_GTTM_IGNORE_IDLE in GTTM register so that</a>
<a name="ln5078">       GTT timer will not increment if the channel idle indicates </a>
<a name="ln5079">       the air is busy or NAV is still counting down */</a>
<a name="ln5080">    OS_REG_WRITE(ah, AR_GTTM, AR_GTTM_IGNORE_IDLE);</a>
<a name="ln5081"> </a>
<a name="ln5082">    /*</a>
<a name="ln5083">     * GTT debug mode setting</a>
<a name="ln5084">     */</a>
<a name="ln5085">    /*</a>
<a name="ln5086">    OS_REG_WRITE(ah, 0x64, 0x00320000);</a>
<a name="ln5087">    OS_REG_WRITE(ah, 0x68, 7);</a>
<a name="ln5088">    OS_REG_WRITE(ah, 0x4080, 0xC);</a>
<a name="ln5089">     */</a>
<a name="ln5090">    /*</a>
<a name="ln5091">     * Disable general interrupt mitigation by setting MIRT = 0x0</a>
<a name="ln5092">     * Rx and tx interrupt mitigation are conditionally enabled below.</a>
<a name="ln5093">     */</a>
<a name="ln5094">    OS_REG_WRITE(ah, AR_MIRT, 0);</a>
<a name="ln5095">    if (ahp-&gt;ah_intr_mitigation_rx) {</a>
<a name="ln5096">        /*</a>
<a name="ln5097">         * Enable Interrupt Mitigation for Rx.</a>
<a name="ln5098">         * If no build-specific limits for the rx interrupt mitigation</a>
<a name="ln5099">         * timer have been specified, use conservative defaults.</a>
<a name="ln5100">         */</a>
<a name="ln5101">        #ifndef AH_RIMT_VAL_LAST</a>
<a name="ln5102">            #define AH_RIMT_LAST_MICROSEC 500</a>
<a name="ln5103">        #endif</a>
<a name="ln5104">        #ifndef AH_RIMT_VAL_FIRST</a>
<a name="ln5105">            #define AH_RIMT_FIRST_MICROSEC 2000</a>
<a name="ln5106">        #endif</a>
<a name="ln5107">#ifndef HOST_OFFLOAD</a>
<a name="ln5108">        OS_REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, AH_RIMT_LAST_MICROSEC);</a>
<a name="ln5109">        OS_REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, AH_RIMT_FIRST_MICROSEC);</a>
<a name="ln5110">#else</a>
<a name="ln5111">        /* lower mitigation level to reduce latency for offload arch. */</a>
<a name="ln5112">        OS_REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, </a>
<a name="ln5113">            (AH_RIMT_LAST_MICROSEC &gt;&gt; 2));</a>
<a name="ln5114">        OS_REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, </a>
<a name="ln5115">            (AH_RIMT_FIRST_MICROSEC &gt;&gt; 2));</a>
<a name="ln5116">#endif</a>
<a name="ln5117">    }</a>
<a name="ln5118"> </a>
<a name="ln5119">    if (ahp-&gt;ah_intr_mitigation_tx) {</a>
<a name="ln5120">        /*</a>
<a name="ln5121">         * Enable Interrupt Mitigation for Tx.</a>
<a name="ln5122">         * If no build-specific limits for the tx interrupt mitigation</a>
<a name="ln5123">         * timer have been specified, use the values preferred for</a>
<a name="ln5124">         * the carrier group's products.</a>
<a name="ln5125">         */</a>
<a name="ln5126">        #ifndef AH_TIMT_LAST</a>
<a name="ln5127">            #define AH_TIMT_LAST_MICROSEC 300</a>
<a name="ln5128">        #endif</a>
<a name="ln5129">        #ifndef AH_TIMT_FIRST</a>
<a name="ln5130">            #define AH_TIMT_FIRST_MICROSEC 750</a>
<a name="ln5131">        #endif</a>
<a name="ln5132">        OS_REG_RMW_FIELD(ah, AR_TIMT, AR_TIMT_LAST, AH_TIMT_LAST_MICROSEC);</a>
<a name="ln5133">        OS_REG_RMW_FIELD(ah, AR_TIMT, AR_TIMT_FIRST, AH_TIMT_FIRST_MICROSEC);</a>
<a name="ln5134">    }</a>
<a name="ln5135"> </a>
<a name="ln5136">    rx_chainmask = ahp-&gt;ah_rx_chainmask;</a>
<a name="ln5137"> </a>
<a name="ln5138">    OS_REG_WRITE(ah, AR_PHY_RX_CHAINMASK, rx_chainmask);</a>
<a name="ln5139">    OS_REG_WRITE(ah, AR_PHY_CAL_CHAINMASK, rx_chainmask);</a>
<a name="ln5140"> </a>
<a name="ln5141">    ar9300_init_bb(ah, chan);</a>
<a name="ln5142"> </a>
<a name="ln5143">    /* BB Step 7: Calibration */</a>
<a name="ln5144">    /*</a>
<a name="ln5145">     * Only kick off calibration not on offchan.</a>
<a name="ln5146">     * If coming back from offchan, restore prevous Cal results</a>
<a name="ln5147">     * since chip reset will clear existings.</a>
<a name="ln5148">     */</a>
<a name="ln5149">    if (!ahp-&gt;ah_skip_rx_iq_cal) {</a>
<a name="ln5150">        int i;</a>
<a name="ln5151">        /* clear existing RX cal data */</a>
<a name="ln5152">        for (i=0; i&lt;AR9300_MAX_CHAINS; i++)</a>
<a name="ln5153">            ahp-&gt;ah_rx_cal_corr[i] = 0;</a>
<a name="ln5154"> </a>
<a name="ln5155">        ahp-&gt;ah_rx_cal_complete = AH_FALSE;</a>
<a name="ln5156">//        ahp-&gt;ah_rx_cal_chan = chan-&gt;channel;</a>
<a name="ln5157">//        ahp-&gt;ah_rx_cal_chan_flag = ichan-&gt;channel_flags;</a>
<a name="ln5158">        ahp-&gt;ah_rx_cal_chan = 0;</a>
<a name="ln5159">        ahp-&gt;ah_rx_cal_chan_flag = 0; /* XXX FreeBSD */</a>
<a name="ln5160">    }</a>
<a name="ln5161">    ar9300_invalidate_saved_cals(ah, ichan);</a>
<a name="ln5162">    cal_ret = ar9300_init_cal(ah, chan, AH_FALSE, apply_last_iqcorr);</a>
<a name="ln5163"> </a>
<a name="ln5164">#if ATH_SUPPORT_MCI</a>
<a name="ln5165">    if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport &amp;&amp; ahp-&gt;ah_mci_ready) {</a>
<a name="ln5166">        if (IS_CHAN_2GHZ(ichan) &amp;&amp;</a>
<a name="ln5167">            (ahp-&gt;ah_mci_bt_state == MCI_BT_SLEEP))</a>
<a name="ln5168">        {</a>
<a name="ln5169">            if (ar9300_mci_check_int(ah, AR_MCI_INTERRUPT_RX_MSG_REMOTE_RESET) ||</a>
<a name="ln5170">                ar9300_mci_check_int(ah, AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE))</a>
<a name="ln5171">            {</a>
<a name="ln5172">                /* </a>
<a name="ln5173">                 * BT is sleeping. Check if BT wakes up duing WLAN </a>
<a name="ln5174">                 * calibration. If BT wakes up during WLAN calibration, need</a>
<a name="ln5175">                 * to go through all message exchanges again and recal.</a>
<a name="ln5176">                 */</a>
<a name="ln5177">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln5178">                    &quot;(MCI) ### %s: BT wakes up during WLAN calibration.\n&quot;,</a>
<a name="ln5179">                    __func__);</a>
<a name="ln5180">                OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,</a>
<a name="ln5181">                        AR_MCI_INTERRUPT_RX_MSG_REMOTE_RESET |</a>
<a name="ln5182">                        AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE);</a>
<a name="ln5183">                HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) send REMOTE_RESET\n&quot;);</a>
<a name="ln5184">                ar9300_mci_remote_reset(ah, AH_TRUE);</a>
<a name="ln5185">                ar9300_mci_send_sys_waking(ah, AH_TRUE);</a>
<a name="ln5186">                OS_DELAY(1);</a>
<a name="ln5187">                if (IS_CHAN_2GHZ(ichan)) {</a>
<a name="ln5188">                    ar9300_mci_send_lna_transfer(ah, AH_TRUE);</a>
<a name="ln5189">                }</a>
<a name="ln5190">                ahp-&gt;ah_mci_bt_state = MCI_BT_AWAKE;</a>
<a name="ln5191"> </a>
<a name="ln5192">                /* Redo calibration */</a>
<a name="ln5193">                HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: Re-calibrate.\n&quot;,</a>
<a name="ln5194">                    __func__);</a>
<a name="ln5195">                ar9300_invalidate_saved_cals(ah, ichan);</a>
<a name="ln5196">                cal_ret = ar9300_init_cal(ah, chan, AH_FALSE, apply_last_iqcorr);</a>
<a name="ln5197">            }</a>
<a name="ln5198">        }</a>
<a name="ln5199">        ar9300_mci_enable_interrupt(ah);</a>
<a name="ln5200">    }</a>
<a name="ln5201">#endif</a>
<a name="ln5202"> </a>
<a name="ln5203">    if (!cal_ret) {</a>
<a name="ln5204">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: Init Cal Failed\n&quot;, __func__);</a>
<a name="ln5205">        FAIL(HAL_ESELFTEST);</a>
<a name="ln5206">    }</a>
<a name="ln5207"> </a>
<a name="ln5208">    ar9300_init_txbf(ah);</a>
<a name="ln5209">#if 0</a>
<a name="ln5210">    /*</a>
<a name="ln5211">     * WAR for owl 1.0 - restore chain mask for 2-chain cfgs after cal</a>
<a name="ln5212">     */</a>
<a name="ln5213">    rx_chainmask = ahp-&gt;ah_rx_chainmask;</a>
<a name="ln5214">    if ((rx_chainmask == 0x5) || (rx_chainmask == 0x3)) {</a>
<a name="ln5215">        OS_REG_WRITE(ah, AR_PHY_RX_CHAINMASK, rx_chainmask);</a>
<a name="ln5216">        OS_REG_WRITE(ah, AR_PHY_CAL_CHAINMASK, rx_chainmask);</a>
<a name="ln5217">    }</a>
<a name="ln5218">#endif</a>
<a name="ln5219"> </a>
<a name="ln5220">    /* Restore previous led state */</a>
<a name="ln5221">    OS_REG_WRITE(ah, AR_CFG_LED, save_led_state | AR_CFG_SCLK_32KHZ);</a>
<a name="ln5222"> </a>
<a name="ln5223">#if ATH_BT_COEX</a>
<a name="ln5224">    if (ahp-&gt;ah_bt_coex_config_type != HAL_BT_COEX_CFG_NONE) {</a>
<a name="ln5225">        ar9300_init_bt_coex(ah);</a>
<a name="ln5226"> </a>
<a name="ln5227">#if ATH_SUPPORT_MCI</a>
<a name="ln5228">        if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport &amp;&amp; ahp-&gt;ah_mci_ready) {</a>
<a name="ln5229">            /* Check BT state again to make sure it's not changed. */</a>
<a name="ln5230">            ar9300_mci_sync_bt_state(ah);</a>
<a name="ln5231">            ar9300_mci_2g5g_switch(ah, AH_TRUE);</a>
<a name="ln5232"> </a>
<a name="ln5233">            if ((ahp-&gt;ah_mci_bt_state == MCI_BT_AWAKE) &amp;&amp;</a>
<a name="ln5234">                (ahp-&gt;ah_mci_query_bt == AH_TRUE))</a>
<a name="ln5235">            {</a>
<a name="ln5236">                ahp-&gt;ah_mci_need_flush_btinfo = AH_TRUE;</a>
<a name="ln5237">            }</a>
<a name="ln5238">        }</a>
<a name="ln5239">#endif</a>
<a name="ln5240">    }</a>
<a name="ln5241">#endif</a>
<a name="ln5242"> </a>
<a name="ln5243">    /* Start TSF2 for generic timer 8-15. */</a>
<a name="ln5244">    ar9300_start_tsf2(ah);</a>
<a name="ln5245"> </a>
<a name="ln5246">    /* MIMO Power save setting */</a>
<a name="ln5247">    if (ar9300_get_capability(ah, HAL_CAP_DYNAMIC_SMPS, 0, AH_NULL) == HAL_OK) {</a>
<a name="ln5248">        ar9300_set_sm_power_mode(ah, ahp-&gt;ah_sm_power_mode);</a>
<a name="ln5249">    }</a>
<a name="ln5250"> </a>
<a name="ln5251">    /*</a>
<a name="ln5252">     * For big endian systems turn on swapping for descriptors</a>
<a name="ln5253">     */</a>
<a name="ln5254">#if AH_BYTE_ORDER == AH_BIG_ENDIAN</a>
<a name="ln5255">    if (AR_SREV_HORNET(ah) || AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah) || AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln5256">        OS_REG_RMW(ah, AR_CFG, AR_CFG_SWTB | AR_CFG_SWRB, 0);</a>
<a name="ln5257">    } else {</a>
<a name="ln5258">        ar9300_init_cfg_reg(ah);</a>
<a name="ln5259">    }</a>
<a name="ln5260">#endif</a>
<a name="ln5261"> </a>
<a name="ln5262">    if ( AR_SREV_OSPREY(ah) || AR_SREV_WASP(ah) || AR_SREV_SCORPION(ah) || AR_SREV_HONEYBEE(ah) ) {</a>
<a name="ln5263">        OS_REG_RMW(ah, AR_CFG_LED, AR_CFG_LED_ASSOC_CTL, AR_CFG_LED_ASSOC_CTL);</a>
<a name="ln5264">    }</a>
<a name="ln5265"> </a>
<a name="ln5266">#if !(defined(ART_BUILD)) &amp;&amp; defined(ATH_SUPPORT_LED)</a>
<a name="ln5267">#define REG_WRITE(_reg, _val)   *((volatile u_int32_t *)(_reg)) = (_val);</a>
<a name="ln5268">#define REG_READ(_reg)          *((volatile u_int32_t *)(_reg))</a>
<a name="ln5269">#define ATH_GPIO_OUT_FUNCTION3  0xB8040038</a>
<a name="ln5270">#define ATH_GPIO_OE             0xB8040000</a>
<a name="ln5271">    if ( AR_SREV_WASP(ah)) {</a>
<a name="ln5272">        if (IS_CHAN_2GHZ((AH_PRIVATE(ah)-&gt;ah_curchan))) {</a>
<a name="ln5273">            REG_WRITE(ATH_GPIO_OUT_FUNCTION3, ( REG_READ(ATH_GPIO_OUT_FUNCTION3) &amp; (~(0xff &lt;&lt; 8))) | (0x33 &lt;&lt; 8) );</a>
<a name="ln5274">            REG_WRITE(ATH_GPIO_OE, ( REG_READ(ATH_GPIO_OE) &amp; (~(0x1 &lt;&lt; 13) )));</a>
<a name="ln5275">        }</a>
<a name="ln5276">        else {</a>
<a name="ln5277"> </a>
<a name="ln5278">            /* Disable 2G WLAN LED. During ath_open, reset function is called even before channel is set. </a>
<a name="ln5279">            So 2GHz is taken as default and it also blinks. Hence </a>
<a name="ln5280">            to avoid both from blinking, disable 2G led while in 5G mode */</a>
<a name="ln5281"> </a>
<a name="ln5282">            REG_WRITE(ATH_GPIO_OE, ( REG_READ(ATH_GPIO_OE) | (1 &lt;&lt; 13) ));</a>
<a name="ln5283">            REG_WRITE(ATH_GPIO_OUT_FUNCTION3, ( REG_READ(ATH_GPIO_OUT_FUNCTION3) &amp; (~(0xff))) | (0x33) );</a>
<a name="ln5284">            REG_WRITE(ATH_GPIO_OE, ( REG_READ(ATH_GPIO_OE) &amp; (~(0x1 &lt;&lt; 12) )));		</a>
<a name="ln5285">        }</a>
<a name="ln5286"> </a>
<a name="ln5287">    }</a>
<a name="ln5288">    else if (AR_SREV_SCORPION(ah)) {</a>
<a name="ln5289">        if (IS_CHAN_2GHZ((AH_PRIVATE(ah)-&gt;ah_curchan))) {</a>
<a name="ln5290">            REG_WRITE(ATH_GPIO_OUT_FUNCTION3, ( REG_READ(ATH_GPIO_OUT_FUNCTION3) &amp; (~(0xff &lt;&lt; 8))) | (0x2F &lt;&lt; 8) );</a>
<a name="ln5291">    	    REG_WRITE(ATH_GPIO_OE, (( REG_READ(ATH_GPIO_OE) &amp; (~(0x1 &lt;&lt; 13) )) | (0x1 &lt;&lt; 12)));</a>
<a name="ln5292">        } else if (IS_CHAN_5GHZ((AH_PRIVATE(ah)-&gt;ah_curchan))) {</a>
<a name="ln5293">            REG_WRITE(ATH_GPIO_OUT_FUNCTION3, ( REG_READ(ATH_GPIO_OUT_FUNCTION3) &amp; (~(0xff))) | (0x2F) );</a>
<a name="ln5294">    	    REG_WRITE(ATH_GPIO_OE, (( REG_READ(ATH_GPIO_OE) &amp; (~(0x1 &lt;&lt; 12) )) | (0x1 &lt;&lt; 13)));</a>
<a name="ln5295">        }</a>
<a name="ln5296">    }</a>
<a name="ln5297">    else if (AR_SREV_HONEYBEE(ah)) {</a>
<a name="ln5298">            REG_WRITE(ATH_GPIO_OUT_FUNCTION3, ( REG_READ(ATH_GPIO_OUT_FUNCTION3) &amp; (~(0xff))) | (0x32) );</a>
<a name="ln5299">            REG_WRITE(ATH_GPIO_OE, (( REG_READ(ATH_GPIO_OE) &amp; (~(0x1 &lt;&lt; 12) ))));</a>
<a name="ln5300">    }</a>
<a name="ln5301">#undef REG_READ</a>
<a name="ln5302">#undef REG_WRITE</a>
<a name="ln5303">#endif</a>
<a name="ln5304"> </a>
<a name="ln5305">    /* XXX FreeBSD What's this? -adrian */</a>
<a name="ln5306">#if 0</a>
<a name="ln5307">    chan-&gt;channel_flags = ichan-&gt;channel_flags;</a>
<a name="ln5308">    chan-&gt;priv_flags = ichan-&gt;priv_flags;</a>
<a name="ln5309">#endif</a>
<a name="ln5310"> </a>
<a name="ln5311">#if FIX_NOISE_FLOOR</a>
<a name="ln5312">    /* XXX FreeBSD is ichan appropariate? It was curchan.. */</a>
<a name="ln5313">    ar9300_get_nf_hist_base(ah, ichan, is_scan, nf_buf);</a>
<a name="ln5314">    ar9300_load_nf(ah, nf_buf);</a>
<a name="ln5315">    /* XXX TODO: handle NF load failure */</a>
<a name="ln5316">    if (nf_hist_buff_reset == 1)    </a>
<a name="ln5317">    {</a>
<a name="ln5318">        nf_hist_buff_reset = 0;</a>
<a name="ln5319">    #ifndef ATH_NF_PER_CHAN</a>
<a name="ln5320">	    if (First_NFCal(ah, ichan, is_scan, chan)){</a>
<a name="ln5321">            if (ahp-&gt;ah_skip_rx_iq_cal &amp;&amp; !is_scan) {</a>
<a name="ln5322">                /* restore RX Cal result if existing */</a>
<a name="ln5323">                ar9300_rx_iq_cal_restore(ah);</a>
<a name="ln5324">                ahp-&gt;ah_skip_rx_iq_cal = AH_FALSE;</a>
<a name="ln5325">            }</a>
<a name="ln5326">        }</a>
<a name="ln5327">    #endif /* ATH_NF_PER_CHAN */</a>
<a name="ln5328">    } </a>
<a name="ln5329">    else{</a>
<a name="ln5330">        ar9300_start_nf_cal(ah); </a>
<a name="ln5331">    }</a>
<a name="ln5332">#endif</a>
<a name="ln5333"> </a>
<a name="ln5334">#ifdef AH_SUPPORT_AR9300</a>
<a name="ln5335">    /* BB Panic Watchdog */</a>
<a name="ln5336">    if (ar9300_get_capability(ah, HAL_CAP_BB_PANIC_WATCHDOG, 0, AH_NULL) ==</a>
<a name="ln5337">        HAL_OK)</a>
<a name="ln5338">    {</a>
<a name="ln5339">        ar9300_config_bb_panic_watchdog(ah);</a>
<a name="ln5340">    }</a>
<a name="ln5341">#endif</a>
<a name="ln5342"> </a>
<a name="ln5343">    /* While receiving unsupported rate frame receive state machine</a>
<a name="ln5344">     * gets into a state 0xb and if phy_restart happens when rx</a>
<a name="ln5345">     * state machine is in 0xb state, BB would go hang, if we</a>
<a name="ln5346">     * see 0xb state after first bb panic, make sure that we</a>
<a name="ln5347">     * disable the phy_restart.</a>
<a name="ln5348">     * </a>
<a name="ln5349">     * There may be multiple panics, make sure that we always do</a>
<a name="ln5350">     * this if we see this panic at least once. This is required</a>
<a name="ln5351">     * because reset seems to be writing from INI file.</a>
<a name="ln5352">     */</a>
<a name="ln5353">    if ((ar9300_get_capability(ah, HAL_CAP_PHYRESTART_CLR_WAR, 0, AH_NULL)</a>
<a name="ln5354">         == HAL_OK) &amp;&amp; (((MS((AH9300(ah)-&gt;ah_bb_panic_last_status),</a>
<a name="ln5355">                AR_PHY_BB_WD_RX_OFDM_SM)) == 0xb) ||</a>
<a name="ln5356">            AH9300(ah)-&gt;ah_phyrestart_disabled) )</a>
<a name="ln5357">    {</a>
<a name="ln5358">        ar9300_disable_phy_restart(ah, 1);</a>
<a name="ln5359">    }</a>
<a name="ln5360"> </a>
<a name="ln5361"> </a>
<a name="ln5362"> </a>
<a name="ln5363">    ahp-&gt;ah_radar1 = MS(OS_REG_READ(ah, AR_PHY_RADAR_1),</a>
<a name="ln5364">                        AR_PHY_RADAR_1_CF_BIN_THRESH);</a>
<a name="ln5365">    ahp-&gt;ah_dc_offset = MS(OS_REG_READ(ah, AR_PHY_TIMING2),</a>
<a name="ln5366">                        AR_PHY_TIMING2_DC_OFFSET);</a>
<a name="ln5367">    ahp-&gt;ah_disable_cck = MS(OS_REG_READ(ah, AR_PHY_MODE),</a>
<a name="ln5368">                        AR_PHY_MODE_DISABLE_CCK);</a>
<a name="ln5369"> </a>
<a name="ln5370">    if (AH9300(ah)-&gt;ah_enable_keysearch_always) {</a>
<a name="ln5371">        ar9300_enable_keysearch_always(ah, 1);</a>
<a name="ln5372">    }</a>
<a name="ln5373"> </a>
<a name="ln5374">#if ATH_LOW_POWER_ENABLE</a>
<a name="ln5375">#define REG_WRITE(_reg, _val)   *((volatile u_int32_t *)(_reg)) = (_val)</a>
<a name="ln5376">#define REG_READ(_reg)      *((volatile u_int32_t *)(_reg))</a>
<a name="ln5377">    if (AR_SREV_OSPREY(ah)) {</a>
<a name="ln5378">        REG_WRITE(0xb4000080, REG_READ(0xb4000080) | 3);</a>
<a name="ln5379">        OS_REG_WRITE(ah, AR_RTC_RESET, 1);</a>
<a name="ln5380">        OS_REG_SET_BIT(ah, AR_HOSTIF_REG(ah, AR_PCIE_PM_CTRL),</a>
<a name="ln5381">                        AR_PCIE_PM_CTRL_ENA);</a>
<a name="ln5382">        OS_REG_SET_BIT(ah, AR_HOSTIF_REG(ah, AR_SPARE), 0xffffffff);</a>
<a name="ln5383">    }</a>
<a name="ln5384">#undef REG_READ</a>
<a name="ln5385">#undef REG_WRITE</a>
<a name="ln5386">#endif  /* ATH_LOW_POWER_ENABLE */</a>
<a name="ln5387"> </a>
<a name="ln5388">    ar9300_disable_pll_lock_detect(ah);</a>
<a name="ln5389"> </a>
<a name="ln5390">    /* H/W Green TX */</a>
<a name="ln5391">    ar9300_control_signals_for_green_tx_mode(ah);</a>
<a name="ln5392">    /* Smart Antenna, only for 5GHz on Scropion */</a>
<a name="ln5393">    if (IEEE80211_IS_CHAN_2GHZ((AH_PRIVATE(ah)-&gt;ah_curchan)) &amp;&amp; AR_SREV_SCORPION(ah)) {</a>
<a name="ln5394">        ahp-&gt;ah_smartantenna_enable = 0;</a>
<a name="ln5395">    }</a>
<a name="ln5396"> </a>
<a name="ln5397">    ar9300_set_smart_antenna(ah, ahp-&gt;ah_smartantenna_enable);</a>
<a name="ln5398"> </a>
<a name="ln5399">    if (AR_SREV_APHRODITE(ah) &amp;&amp; ahp-&gt;ah_lna_div_use_bt_ant_enable)</a>
<a name="ln5400">        OS_REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);</a>
<a name="ln5401"> </a>
<a name="ln5402">    if (ahp-&gt;ah_skip_rx_iq_cal &amp;&amp; !is_scan) {</a>
<a name="ln5403">        /* restore RX Cal result if existing */</a>
<a name="ln5404">        ar9300_rx_iq_cal_restore(ah);</a>
<a name="ln5405">        ahp-&gt;ah_skip_rx_iq_cal = AH_FALSE;</a>
<a name="ln5406">    }</a>
<a name="ln5407"> </a>
<a name="ln5408"> </a>
<a name="ln5409">    return AH_TRUE;</a>
<a name="ln5410">bad:</a>
<a name="ln5411">    OS_MARK(ah, AH_MARK_RESET_DONE, ecode);</a>
<a name="ln5412">    *status = ecode;</a>
<a name="ln5413"> </a>
<a name="ln5414">    if (ahp-&gt;ah_skip_rx_iq_cal &amp;&amp; !is_scan) {</a>
<a name="ln5415">        /* restore RX Cal result if existing */</a>
<a name="ln5416">        ar9300_rx_iq_cal_restore(ah);</a>
<a name="ln5417">        ahp-&gt;ah_skip_rx_iq_cal = AH_FALSE;</a>
<a name="ln5418">    }</a>
<a name="ln5419"> </a>
<a name="ln5420">    return AH_FALSE;</a>
<a name="ln5421">#undef FAIL</a>
<a name="ln5422">}</a>
<a name="ln5423"> </a>
<a name="ln5424">void</a>
<a name="ln5425">ar9300_green_ap_ps_on_off( struct ath_hal *ah, u_int16_t on_off)</a>
<a name="ln5426">{</a>
<a name="ln5427">    /* Set/reset the ps flag */</a>
<a name="ln5428">    AH9300(ah)-&gt;green_ap_ps_on = !!on_off;</a>
<a name="ln5429">}</a>
<a name="ln5430"> </a>
<a name="ln5431">/*</a>
<a name="ln5432"> * This function returns 1, where it is possible to do</a>
<a name="ln5433"> * single-chain power save.</a>
<a name="ln5434"> */</a>
<a name="ln5435">u_int16_t</a>
<a name="ln5436">ar9300_is_single_ant_power_save_possible(struct ath_hal *ah)</a>
<a name="ln5437">{</a>
<a name="ln5438">    return AH_TRUE;</a>
<a name="ln5439">}</a>
<a name="ln5440"> </a>
<a name="ln5441">/* To avoid compilation warnings. Functions not used when EMULATION. */</a>
<a name="ln5442">/*</a>
<a name="ln5443"> * ar9300_find_mag_approx()</a>
<a name="ln5444"> */</a>
<a name="ln5445">static int32_t</a>
<a name="ln5446">ar9300_find_mag_approx(struct ath_hal *ah, int32_t in_re, int32_t in_im)</a>
<a name="ln5447">{</a>
<a name="ln5448">    int32_t abs_i = abs(in_re);</a>
<a name="ln5449">    int32_t abs_q = abs(in_im);</a>
<a name="ln5450">    int32_t max_abs, min_abs;</a>
<a name="ln5451"> </a>
<a name="ln5452">    if (abs_i &gt; abs_q) {</a>
<a name="ln5453">        max_abs = abs_i;</a>
<a name="ln5454">        min_abs = abs_q;</a>
<a name="ln5455">    } else {</a>
<a name="ln5456">        max_abs = abs_q;</a>
<a name="ln5457">        min_abs = abs_i; </a>
<a name="ln5458">    }</a>
<a name="ln5459"> </a>
<a name="ln5460">    return (max_abs - (max_abs / 32) + (min_abs / 8) + (min_abs / 4));</a>
<a name="ln5461">}</a>
<a name="ln5462"> </a>
<a name="ln5463">/* </a>
<a name="ln5464"> * ar9300_solve_iq_cal()       </a>
<a name="ln5465"> * solve 4x4 linear equation used in loopback iq cal.</a>
<a name="ln5466"> */</a>
<a name="ln5467">static HAL_BOOL</a>
<a name="ln5468">ar9300_solve_iq_cal(</a>
<a name="ln5469">    struct ath_hal *ah,</a>
<a name="ln5470">    int32_t sin_2phi_1,</a>
<a name="ln5471">    int32_t cos_2phi_1,</a>
<a name="ln5472">    int32_t sin_2phi_2,</a>
<a name="ln5473">    int32_t cos_2phi_2,</a>
<a name="ln5474">    int32_t mag_a0_d0,</a>
<a name="ln5475">    int32_t phs_a0_d0,</a>
<a name="ln5476">    int32_t mag_a1_d0,</a>
<a name="ln5477">    int32_t phs_a1_d0,</a>
<a name="ln5478">    int32_t solved_eq[])</a>
<a name="ln5479">{</a>
<a name="ln5480">    int32_t f1 = cos_2phi_1 - cos_2phi_2;</a>
<a name="ln5481">    int32_t f3 = sin_2phi_1 - sin_2phi_2;</a>
<a name="ln5482">    int32_t f2;</a>
<a name="ln5483">    int32_t mag_tx, phs_tx, mag_rx, phs_rx;</a>
<a name="ln5484">    const int32_t result_shift = 1 &lt;&lt; 15;</a>
<a name="ln5485"> </a>
<a name="ln5486">    f2 = (((int64_t)f1 * (int64_t)f1) / result_shift) + (((int64_t)f3 * (int64_t)f3) / result_shift);</a>
<a name="ln5487"> </a>
<a name="ln5488">    if (0 == f2) {</a>
<a name="ln5489">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE, &quot;%s: Divide by 0(%d).\n&quot;,</a>
<a name="ln5490">            __func__, __LINE__);</a>
<a name="ln5491">        return AH_FALSE;</a>
<a name="ln5492">    }</a>
<a name="ln5493"> </a>
<a name="ln5494">    /* magnitude mismatch, tx */</a>
<a name="ln5495">    mag_tx = f1 * (mag_a0_d0  - mag_a1_d0) + f3 * (phs_a0_d0 - phs_a1_d0);</a>
<a name="ln5496">    /* phase mismatch, tx */</a>
<a name="ln5497">    phs_tx = f3 * (-mag_a0_d0 + mag_a1_d0) + f1 * (phs_a0_d0 - phs_a1_d0);</a>
<a name="ln5498"> </a>
<a name="ln5499">    mag_tx = (mag_tx / f2);</a>
<a name="ln5500">    phs_tx = (phs_tx / f2);</a>
<a name="ln5501"> </a>
<a name="ln5502">    /* magnitude mismatch, rx */</a>
<a name="ln5503">    mag_rx =</a>
<a name="ln5504">        mag_a0_d0 - (cos_2phi_1 * mag_tx + sin_2phi_1 * phs_tx) / result_shift;</a>
<a name="ln5505">    /* phase mismatch, rx */</a>
<a name="ln5506">    phs_rx =</a>
<a name="ln5507">        phs_a0_d0 + (sin_2phi_1 * mag_tx - cos_2phi_1 * phs_tx) / result_shift;</a>
<a name="ln5508"> </a>
<a name="ln5509">    solved_eq[0] = mag_tx;</a>
<a name="ln5510">    solved_eq[1] = phs_tx;</a>
<a name="ln5511">    solved_eq[2] = mag_rx;</a>
<a name="ln5512">    solved_eq[3] = phs_rx;</a>
<a name="ln5513"> </a>
<a name="ln5514">    return AH_TRUE;</a>
<a name="ln5515">}</a>
<a name="ln5516"> </a>
<a name="ln5517">/*</a>
<a name="ln5518"> * ar9300_calc_iq_corr()</a>
<a name="ln5519"> */</a>
<a name="ln5520">static HAL_BOOL</a>
<a name="ln5521">ar9300_calc_iq_corr(struct ath_hal *ah, int32_t chain_idx,</a>
<a name="ln5522">    const int32_t iq_res[], int32_t iqc_coeff[])</a>
<a name="ln5523">{</a>
<a name="ln5524">    int32_t i2_m_q2_a0_d0, i2_p_q2_a0_d0, iq_corr_a0_d0;</a>
<a name="ln5525">    int32_t i2_m_q2_a0_d1, i2_p_q2_a0_d1, iq_corr_a0_d1;</a>
<a name="ln5526">    int32_t i2_m_q2_a1_d0, i2_p_q2_a1_d0, iq_corr_a1_d0;</a>
<a name="ln5527">    int32_t i2_m_q2_a1_d1, i2_p_q2_a1_d1, iq_corr_a1_d1;</a>
<a name="ln5528">    int32_t mag_a0_d0, mag_a1_d0, mag_a0_d1, mag_a1_d1;</a>
<a name="ln5529">    int32_t phs_a0_d0, phs_a1_d0, phs_a0_d1, phs_a1_d1;</a>
<a name="ln5530">    int32_t sin_2phi_1, cos_2phi_1, sin_2phi_2, cos_2phi_2;</a>
<a name="ln5531">    int32_t mag_tx, phs_tx, mag_rx, phs_rx;</a>
<a name="ln5532">    int32_t solved_eq[4], mag_corr_tx, phs_corr_tx, mag_corr_rx, phs_corr_rx;</a>
<a name="ln5533">    int32_t q_q_coff, q_i_coff;</a>
<a name="ln5534">    const int32_t res_scale = 1 &lt;&lt; 15;</a>
<a name="ln5535">    const int32_t delpt_shift = 1 &lt;&lt; 8;</a>
<a name="ln5536">    int32_t mag1, mag2;</a>
<a name="ln5537"> </a>
<a name="ln5538">    i2_m_q2_a0_d0 = iq_res[0] &amp; 0xfff;</a>
<a name="ln5539">    i2_p_q2_a0_d0 = (iq_res[0] &gt;&gt; 12) &amp; 0xfff;</a>
<a name="ln5540">    iq_corr_a0_d0 = ((iq_res[0] &gt;&gt; 24) &amp; 0xff) + ((iq_res[1] &amp; 0xf) &lt;&lt; 8);</a>
<a name="ln5541"> </a>
<a name="ln5542">    if (i2_m_q2_a0_d0 &gt; 0x800)  {</a>
<a name="ln5543">        i2_m_q2_a0_d0 = -((0xfff - i2_m_q2_a0_d0) + 1);</a>
<a name="ln5544">    }</a>
<a name="ln5545">    if (iq_corr_a0_d0 &gt; 0x800)  {</a>
<a name="ln5546">        iq_corr_a0_d0 = -((0xfff - iq_corr_a0_d0) + 1);</a>
<a name="ln5547">    }</a>
<a name="ln5548"> </a>
<a name="ln5549">    i2_m_q2_a0_d1 = (iq_res[1] &gt;&gt; 4) &amp; 0xfff;</a>
<a name="ln5550">    i2_p_q2_a0_d1 = (iq_res[2] &amp; 0xfff); </a>
<a name="ln5551">    iq_corr_a0_d1 = (iq_res[2] &gt;&gt; 12) &amp; 0xfff;</a>
<a name="ln5552"> </a>
<a name="ln5553">    if (i2_m_q2_a0_d1 &gt; 0x800)  {</a>
<a name="ln5554">        i2_m_q2_a0_d1 = -((0xfff - i2_m_q2_a0_d1) + 1);</a>
<a name="ln5555">    }</a>
<a name="ln5556">    if (iq_corr_a0_d1 &gt; 0x800)  {</a>
<a name="ln5557">        iq_corr_a0_d1 = -((0xfff - iq_corr_a0_d1) + 1);</a>
<a name="ln5558">    }</a>
<a name="ln5559"> </a>
<a name="ln5560">    i2_m_q2_a1_d0 = ((iq_res[2] &gt;&gt; 24) &amp; 0xff) + ((iq_res[3] &amp; 0xf) &lt;&lt; 8);</a>
<a name="ln5561">    i2_p_q2_a1_d0 = (iq_res[3] &gt;&gt; 4) &amp; 0xfff; </a>
<a name="ln5562">    iq_corr_a1_d0 = iq_res[4] &amp; 0xfff;</a>
<a name="ln5563"> </a>
<a name="ln5564">    if (i2_m_q2_a1_d0 &gt; 0x800)  {</a>
<a name="ln5565">        i2_m_q2_a1_d0 = -((0xfff - i2_m_q2_a1_d0) + 1);</a>
<a name="ln5566">    }</a>
<a name="ln5567">    if (iq_corr_a1_d0 &gt; 0x800)  {</a>
<a name="ln5568">        iq_corr_a1_d0 = -((0xfff - iq_corr_a1_d0) + 1);</a>
<a name="ln5569">    }</a>
<a name="ln5570"> </a>
<a name="ln5571">    i2_m_q2_a1_d1 = (iq_res[4] &gt;&gt; 12) &amp; 0xfff;</a>
<a name="ln5572">    i2_p_q2_a1_d1 = ((iq_res[4] &gt;&gt; 24) &amp; 0xff) + ((iq_res[5] &amp; 0xf) &lt;&lt; 8); </a>
<a name="ln5573">    iq_corr_a1_d1 = (iq_res[5] &gt;&gt; 4) &amp; 0xfff;</a>
<a name="ln5574"> </a>
<a name="ln5575">    if (i2_m_q2_a1_d1 &gt; 0x800)  {</a>
<a name="ln5576">        i2_m_q2_a1_d1 = -((0xfff - i2_m_q2_a1_d1) + 1);</a>
<a name="ln5577">    }</a>
<a name="ln5578">    if (iq_corr_a1_d1 &gt; 0x800)  {</a>
<a name="ln5579">        iq_corr_a1_d1 = -((0xfff - iq_corr_a1_d1) + 1);</a>
<a name="ln5580">    }</a>
<a name="ln5581"> </a>
<a name="ln5582">    if ((i2_p_q2_a0_d0 == 0) ||</a>
<a name="ln5583">        (i2_p_q2_a0_d1 == 0) ||</a>
<a name="ln5584">        (i2_p_q2_a1_d0 == 0) ||</a>
<a name="ln5585">        (i2_p_q2_a1_d1 == 0)) {</a>
<a name="ln5586">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln5587">            &quot;%s: Divide by 0(%d):\na0_d0=%d\na0_d1=%d\na2_d0=%d\na1_d1=%d\n&quot;,</a>
<a name="ln5588">            __func__, __LINE__,</a>
<a name="ln5589">            i2_p_q2_a0_d0, i2_p_q2_a0_d1, i2_p_q2_a1_d0, i2_p_q2_a1_d1);</a>
<a name="ln5590">        return AH_FALSE;</a>
<a name="ln5591">    }</a>
<a name="ln5592"> </a>
<a name="ln5593">    if ((i2_p_q2_a0_d0 &lt;= 1024) || (i2_p_q2_a0_d0 &gt; 2047) ||</a>
<a name="ln5594">            (i2_p_q2_a1_d0 &lt; 0) || (i2_p_q2_a1_d1 &lt; 0) ||</a>
<a name="ln5595">            (i2_p_q2_a0_d0 &lt;= i2_m_q2_a0_d0) ||</a>
<a name="ln5596">            (i2_p_q2_a0_d0 &lt;= iq_corr_a0_d0) ||</a>
<a name="ln5597">            (i2_p_q2_a0_d1 &lt;= i2_m_q2_a0_d1) ||</a>
<a name="ln5598">            (i2_p_q2_a0_d1 &lt;= iq_corr_a0_d1) ||</a>
<a name="ln5599">            (i2_p_q2_a1_d0 &lt;= i2_m_q2_a1_d0) ||</a>
<a name="ln5600">            (i2_p_q2_a1_d0 &lt;= iq_corr_a1_d0) ||</a>
<a name="ln5601">            (i2_p_q2_a1_d1 &lt;= i2_m_q2_a1_d1) ||</a>
<a name="ln5602">            (i2_p_q2_a1_d1 &lt;= iq_corr_a1_d1)) {</a>
<a name="ln5603">        return AH_FALSE;</a>
<a name="ln5604">    }</a>
<a name="ln5605"> </a>
<a name="ln5606">    mag_a0_d0 = (i2_m_q2_a0_d0 * res_scale) / i2_p_q2_a0_d0;</a>
<a name="ln5607">    phs_a0_d0 = (iq_corr_a0_d0 * res_scale) / i2_p_q2_a0_d0;</a>
<a name="ln5608"> </a>
<a name="ln5609">    mag_a0_d1 = (i2_m_q2_a0_d1 * res_scale) / i2_p_q2_a0_d1;</a>
<a name="ln5610">    phs_a0_d1 = (iq_corr_a0_d1 * res_scale) / i2_p_q2_a0_d1;</a>
<a name="ln5611"> </a>
<a name="ln5612">    mag_a1_d0 = (i2_m_q2_a1_d0 * res_scale) / i2_p_q2_a1_d0;</a>
<a name="ln5613">    phs_a1_d0 = (iq_corr_a1_d0 * res_scale) / i2_p_q2_a1_d0;</a>
<a name="ln5614"> </a>
<a name="ln5615">    mag_a1_d1 = (i2_m_q2_a1_d1 * res_scale) / i2_p_q2_a1_d1;</a>
<a name="ln5616">    phs_a1_d1 = (iq_corr_a1_d1 * res_scale) / i2_p_q2_a1_d1;</a>
<a name="ln5617"> </a>
<a name="ln5618">    /* without analog phase shift */</a>
<a name="ln5619">    sin_2phi_1 = (((mag_a0_d0 - mag_a0_d1) * delpt_shift) / DELPT);</a>
<a name="ln5620">    /* without analog phase shift */</a>
<a name="ln5621">    cos_2phi_1 = (((phs_a0_d1 - phs_a0_d0) * delpt_shift) / DELPT);</a>
<a name="ln5622">    /* with  analog phase shift */</a>
<a name="ln5623">    sin_2phi_2 = (((mag_a1_d0 - mag_a1_d1) * delpt_shift) / DELPT);</a>
<a name="ln5624">    /* with analog phase shift */</a>
<a name="ln5625">    cos_2phi_2 = (((phs_a1_d1 - phs_a1_d0) * delpt_shift) / DELPT);</a>
<a name="ln5626"> </a>
<a name="ln5627">    /* force sin^2 + cos^2 = 1; */</a>
<a name="ln5628">    /* find magnitude by approximation */</a>
<a name="ln5629">    mag1 = ar9300_find_mag_approx(ah, cos_2phi_1, sin_2phi_1);</a>
<a name="ln5630">    mag2 = ar9300_find_mag_approx(ah, cos_2phi_2, sin_2phi_2);</a>
<a name="ln5631"> </a>
<a name="ln5632">    if ((mag1 == 0) || (mag2 == 0)) {</a>
<a name="ln5633">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln5634">            &quot;%s: Divide by 0(%d): mag1=%d, mag2=%d\n&quot;,</a>
<a name="ln5635">            __func__, __LINE__, mag1, mag2);</a>
<a name="ln5636">        return AH_FALSE;</a>
<a name="ln5637">    }</a>
<a name="ln5638"> </a>
<a name="ln5639">    /* normalization sin and cos by mag */</a>
<a name="ln5640">    sin_2phi_1 = (sin_2phi_1 * res_scale / mag1);</a>
<a name="ln5641">    cos_2phi_1 = (cos_2phi_1 * res_scale / mag1);</a>
<a name="ln5642">    sin_2phi_2 = (sin_2phi_2 * res_scale / mag2);</a>
<a name="ln5643">    cos_2phi_2 = (cos_2phi_2 * res_scale / mag2);</a>
<a name="ln5644"> </a>
<a name="ln5645">    /* calculate IQ mismatch */</a>
<a name="ln5646">    if (AH_FALSE == ar9300_solve_iq_cal(ah,</a>
<a name="ln5647">            sin_2phi_1, cos_2phi_1, sin_2phi_2, cos_2phi_2, mag_a0_d0,</a>
<a name="ln5648">            phs_a0_d0, mag_a1_d0, phs_a1_d0, solved_eq))</a>
<a name="ln5649">    {</a>
<a name="ln5650">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln5651">            &quot;%s: Call to ar9300_solve_iq_cal failed.\n&quot;, __func__);</a>
<a name="ln5652">        return AH_FALSE;</a>
<a name="ln5653">    }</a>
<a name="ln5654">   </a>
<a name="ln5655">    mag_tx = solved_eq[0];</a>
<a name="ln5656">    phs_tx = solved_eq[1];</a>
<a name="ln5657">    mag_rx = solved_eq[2];</a>
<a name="ln5658">    phs_rx = solved_eq[3];</a>
<a name="ln5659"> </a>
<a name="ln5660">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln5661">        &quot;%s: chain %d: mag mismatch=%d phase mismatch=%d\n&quot;,</a>
<a name="ln5662">        __func__, chain_idx, mag_tx / res_scale, phs_tx / res_scale);</a>
<a name="ln5663">  </a>
<a name="ln5664">    if (res_scale == mag_tx) {</a>
<a name="ln5665">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln5666">            &quot;%s: Divide by 0(%d): mag_tx=%d, res_scale=%d\n&quot;,</a>
<a name="ln5667">            __func__, __LINE__, mag_tx, res_scale);</a>
<a name="ln5668">        return AH_FALSE;</a>
<a name="ln5669">    }</a>
<a name="ln5670"> </a>
<a name="ln5671">    /* calculate and quantize Tx IQ correction factor */</a>
<a name="ln5672">    mag_corr_tx = (mag_tx * res_scale) / (res_scale - mag_tx);</a>
<a name="ln5673">    phs_corr_tx = -phs_tx;</a>
<a name="ln5674"> </a>
<a name="ln5675">    q_q_coff = (mag_corr_tx * 128 / res_scale);</a>
<a name="ln5676">    q_i_coff = (phs_corr_tx * 256 / res_scale);</a>
<a name="ln5677"> </a>
<a name="ln5678">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln5679">        &quot;%s: tx chain %d: mag corr=%d  phase corr=%d\n&quot;,</a>
<a name="ln5680">        __func__, chain_idx, q_q_coff, q_i_coff);</a>
<a name="ln5681"> </a>
<a name="ln5682">    if (q_i_coff &lt; -63) {</a>
<a name="ln5683">        q_i_coff = -63;</a>
<a name="ln5684">    }</a>
<a name="ln5685">    if (q_i_coff &gt; 63) {</a>
<a name="ln5686">        q_i_coff = 63;</a>
<a name="ln5687">    }</a>
<a name="ln5688">    if (q_q_coff &lt; -63) {</a>
<a name="ln5689">        q_q_coff = -63;</a>
<a name="ln5690">    }</a>
<a name="ln5691">    if (q_q_coff &gt; 63) {</a>
<a name="ln5692">        q_q_coff = 63;</a>
<a name="ln5693">    }</a>
<a name="ln5694"> </a>
<a name="ln5695">    iqc_coeff[0] = (q_q_coff * 128) + (0x7f &amp; q_i_coff);</a>
<a name="ln5696"> </a>
<a name="ln5697">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE, &quot;%s: tx chain %d: iq corr coeff=%x\n&quot;,</a>
<a name="ln5698">        __func__, chain_idx, iqc_coeff[0]);  </a>
<a name="ln5699"> </a>
<a name="ln5700">    if (-mag_rx == res_scale) {</a>
<a name="ln5701">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln5702">            &quot;%s: Divide by 0(%d): mag_rx=%d, res_scale=%d\n&quot;,</a>
<a name="ln5703">            __func__, __LINE__, mag_rx, res_scale);</a>
<a name="ln5704">        return AH_FALSE;</a>
<a name="ln5705">    }</a>
<a name="ln5706"> </a>
<a name="ln5707">    /* calculate and quantize Rx IQ correction factors */</a>
<a name="ln5708">    mag_corr_rx = (-mag_rx * res_scale) / (res_scale + mag_rx);</a>
<a name="ln5709">    phs_corr_rx = -phs_rx;</a>
<a name="ln5710"> </a>
<a name="ln5711">    q_q_coff = (mag_corr_rx * 128 / res_scale);</a>
<a name="ln5712">    q_i_coff = (phs_corr_rx * 256 / res_scale);</a>
<a name="ln5713"> </a>
<a name="ln5714">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln5715">        &quot;%s: rx chain %d: mag corr=%d  phase corr=%d\n&quot;,</a>
<a name="ln5716">        __func__, chain_idx, q_q_coff, q_i_coff);</a>
<a name="ln5717"> </a>
<a name="ln5718">    if (q_i_coff &lt; -63) {</a>
<a name="ln5719">        q_i_coff = -63;</a>
<a name="ln5720">    }</a>
<a name="ln5721">    if (q_i_coff &gt; 63) {</a>
<a name="ln5722">        q_i_coff = 63;</a>
<a name="ln5723">    }</a>
<a name="ln5724">    if (q_q_coff &lt; -63) {</a>
<a name="ln5725">        q_q_coff = -63;</a>
<a name="ln5726">    }</a>
<a name="ln5727">    if (q_q_coff &gt; 63) {</a>
<a name="ln5728">        q_q_coff = 63;</a>
<a name="ln5729">    }</a>
<a name="ln5730">   </a>
<a name="ln5731">    iqc_coeff[1] = (q_q_coff * 128) + (0x7f &amp; q_i_coff);</a>
<a name="ln5732"> </a>
<a name="ln5733">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE, &quot;%s: rx chain %d: iq corr coeff=%x\n&quot;,</a>
<a name="ln5734">        __func__, chain_idx, iqc_coeff[1]);  </a>
<a name="ln5735"> </a>
<a name="ln5736">    return AH_TRUE;</a>
<a name="ln5737">}</a>
<a name="ln5738"> </a>
<a name="ln5739">#define MAX_MAG_DELTA 11 //maximum magnitude mismatch delta across gains</a>
<a name="ln5740">#define MAX_PHS_DELTA 10 //maximum phase mismatch delta across gains</a>
<a name="ln5741">#define ABS(x) ((x) &gt;= 0 ? (x) : (-(x)))</a>
<a name="ln5742"> </a>
<a name="ln5743">    u_int32_t tx_corr_coeff[MAX_MEASUREMENT][AR9300_MAX_CHAINS] = {</a>
<a name="ln5744">    {   AR_PHY_TX_IQCAL_CORR_COEFF_01_B0,</a>
<a name="ln5745">        AR_PHY_TX_IQCAL_CORR_COEFF_01_B1,</a>
<a name="ln5746">        AR_PHY_TX_IQCAL_CORR_COEFF_01_B2},</a>
<a name="ln5747">    {   AR_PHY_TX_IQCAL_CORR_COEFF_01_B0,</a>
<a name="ln5748">        AR_PHY_TX_IQCAL_CORR_COEFF_01_B1,</a>
<a name="ln5749">        AR_PHY_TX_IQCAL_CORR_COEFF_01_B2},</a>
<a name="ln5750">    {   AR_PHY_TX_IQCAL_CORR_COEFF_23_B0,</a>
<a name="ln5751">        AR_PHY_TX_IQCAL_CORR_COEFF_23_B1,</a>
<a name="ln5752">        AR_PHY_TX_IQCAL_CORR_COEFF_23_B2},</a>
<a name="ln5753">    {   AR_PHY_TX_IQCAL_CORR_COEFF_23_B0,</a>
<a name="ln5754">        AR_PHY_TX_IQCAL_CORR_COEFF_23_B1,</a>
<a name="ln5755">        AR_PHY_TX_IQCAL_CORR_COEFF_23_B2},</a>
<a name="ln5756">    {   AR_PHY_TX_IQCAL_CORR_COEFF_45_B0,</a>
<a name="ln5757">        AR_PHY_TX_IQCAL_CORR_COEFF_45_B1,</a>
<a name="ln5758">        AR_PHY_TX_IQCAL_CORR_COEFF_45_B2},</a>
<a name="ln5759">    {   AR_PHY_TX_IQCAL_CORR_COEFF_45_B0,</a>
<a name="ln5760">        AR_PHY_TX_IQCAL_CORR_COEFF_45_B1,</a>
<a name="ln5761">        AR_PHY_TX_IQCAL_CORR_COEFF_45_B2},</a>
<a name="ln5762">    {   AR_PHY_TX_IQCAL_CORR_COEFF_67_B0,</a>
<a name="ln5763">        AR_PHY_TX_IQCAL_CORR_COEFF_67_B1,</a>
<a name="ln5764">        AR_PHY_TX_IQCAL_CORR_COEFF_67_B2},</a>
<a name="ln5765">    {   AR_PHY_TX_IQCAL_CORR_COEFF_67_B0,</a>
<a name="ln5766">        AR_PHY_TX_IQCAL_CORR_COEFF_67_B1,</a>
<a name="ln5767">        AR_PHY_TX_IQCAL_CORR_COEFF_67_B2},</a>
<a name="ln5768">    };</a>
<a name="ln5769"> </a>
<a name="ln5770">static void</a>
<a name="ln5771">ar9300_tx_iq_cal_outlier_detection(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *ichan, u_int32_t num_chains,</a>
<a name="ln5772">    struct coeff_t *coeff, HAL_BOOL is_cal_reusable)</a>
<a name="ln5773">{</a>
<a name="ln5774">    int nmeasurement, ch_idx, im;</a>
<a name="ln5775">    int32_t magnitude, phase;</a>
<a name="ln5776">    int32_t magnitude_max, phase_max;</a>
<a name="ln5777">    int32_t magnitude_min, phase_min;</a>
<a name="ln5778"> </a>
<a name="ln5779">    int32_t magnitude_max_idx, phase_max_idx;</a>
<a name="ln5780">    int32_t magnitude_min_idx, phase_min_idx;</a>
<a name="ln5781"> </a>
<a name="ln5782">    int32_t magnitude_avg, phase_avg;</a>
<a name="ln5783">    int32_t outlier_mag_idx = 0;</a>
<a name="ln5784">    int32_t outlier_phs_idx = 0;</a>
<a name="ln5785"> </a>
<a name="ln5786"> </a>
<a name="ln5787">    if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln5788">        HALASSERT(num_chains == 0x1);</a>
<a name="ln5789"> </a>
<a name="ln5790">        tx_corr_coeff[0][0] = AR_PHY_TX_IQCAL_CORR_COEFF_01_B0_POSEIDON;</a>
<a name="ln5791">        tx_corr_coeff[1][0] = AR_PHY_TX_IQCAL_CORR_COEFF_01_B0_POSEIDON;</a>
<a name="ln5792">        tx_corr_coeff[2][0] = AR_PHY_TX_IQCAL_CORR_COEFF_23_B0_POSEIDON;</a>
<a name="ln5793">        tx_corr_coeff[3][0] = AR_PHY_TX_IQCAL_CORR_COEFF_23_B0_POSEIDON;</a>
<a name="ln5794">        tx_corr_coeff[4][0] = AR_PHY_TX_IQCAL_CORR_COEFF_45_B0_POSEIDON;</a>
<a name="ln5795">        tx_corr_coeff[5][0] = AR_PHY_TX_IQCAL_CORR_COEFF_45_B0_POSEIDON;</a>
<a name="ln5796">        tx_corr_coeff[6][0] = AR_PHY_TX_IQCAL_CORR_COEFF_67_B0_POSEIDON;</a>
<a name="ln5797">        tx_corr_coeff[7][0] = AR_PHY_TX_IQCAL_CORR_COEFF_67_B0_POSEIDON;</a>
<a name="ln5798">    }</a>
<a name="ln5799"> </a>
<a name="ln5800">    for (ch_idx = 0; ch_idx &lt; num_chains; ch_idx++) {</a>
<a name="ln5801">        nmeasurement = OS_REG_READ_FIELD(ah,</a>
<a name="ln5802">            AR_PHY_TX_IQCAL_STATUS_B0(ah), AR_PHY_CALIBRATED_GAINS_0);</a>
<a name="ln5803">        if (nmeasurement &gt; MAX_MEASUREMENT) {</a>
<a name="ln5804">            nmeasurement = MAX_MEASUREMENT;</a>
<a name="ln5805">        }</a>
<a name="ln5806"> </a>
<a name="ln5807">        if (!AR_SREV_SCORPION(ah)) {</a>
<a name="ln5808">            /*</a>
<a name="ln5809">             * reset max/min variable to min/max values so that</a>
<a name="ln5810">             * we always start with 1st calibrated gain value</a>
<a name="ln5811">             */</a>
<a name="ln5812">            magnitude_max = -64;</a>
<a name="ln5813">            phase_max     = -64;</a>
<a name="ln5814">            magnitude_min = 63;</a>
<a name="ln5815">            phase_min     = 63;</a>
<a name="ln5816">            magnitude_avg = 0;</a>
<a name="ln5817">            phase_avg     = 0;</a>
<a name="ln5818">            magnitude_max_idx = 0;</a>
<a name="ln5819">            magnitude_min_idx = 0;</a>
<a name="ln5820">            phase_max_idx = 0;</a>
<a name="ln5821">            phase_min_idx = 0;</a>
<a name="ln5822"> </a>
<a name="ln5823">            /* detect outlier only if nmeasurement &gt; 1 */</a>
<a name="ln5824">            if (nmeasurement &gt; 1) {</a>
<a name="ln5825">                /* printf(&quot;----------- start outlier detection -----------\n&quot;); */</a>
<a name="ln5826">                /*</a>
<a name="ln5827">                 * find max/min and phase/mag mismatch across all calibrated gains</a>
<a name="ln5828">                 */</a>
<a name="ln5829">                for (im = 0; im &lt; nmeasurement; im++) {</a>
<a name="ln5830">                    magnitude = coeff-&gt;mag_coeff[ch_idx][im][0];</a>
<a name="ln5831">                    phase = coeff-&gt;phs_coeff[ch_idx][im][0];</a>
<a name="ln5832"> </a>
<a name="ln5833">                    magnitude_avg = magnitude_avg + magnitude;</a>
<a name="ln5834">                    phase_avg = phase_avg + phase;</a>
<a name="ln5835">                    if (magnitude &gt; magnitude_max) {</a>
<a name="ln5836">                        magnitude_max = magnitude;</a>
<a name="ln5837">                        magnitude_max_idx = im;</a>
<a name="ln5838">                    }</a>
<a name="ln5839">                    if (magnitude &lt; magnitude_min) {</a>
<a name="ln5840">                        magnitude_min = magnitude;</a>
<a name="ln5841">                        magnitude_min_idx = im;</a>
<a name="ln5842">                    }</a>
<a name="ln5843">                    if (phase &gt; phase_max) {</a>
<a name="ln5844">                        phase_max = phase;</a>
<a name="ln5845">                        phase_max_idx = im;</a>
<a name="ln5846">                    }</a>
<a name="ln5847">                    if (phase &lt; phase_min) {</a>
<a name="ln5848">                        phase_min = phase;</a>
<a name="ln5849">                        phase_min_idx = im;</a>
<a name="ln5850">                    }</a>
<a name="ln5851">                }</a>
<a name="ln5852">                /* find average (exclude max abs value) */</a>
<a name="ln5853">                for (im = 0; im &lt; nmeasurement; im++) {</a>
<a name="ln5854">                    magnitude = coeff-&gt;mag_coeff[ch_idx][im][0];</a>
<a name="ln5855">                    phase = coeff-&gt;phs_coeff[ch_idx][im][0];</a>
<a name="ln5856">                    if ((ABS(magnitude) &lt; ABS(magnitude_max)) ||</a>
<a name="ln5857">                        (ABS(magnitude) &lt; ABS(magnitude_min)))</a>
<a name="ln5858">                    {</a>
<a name="ln5859">                        magnitude_avg = magnitude_avg + magnitude;</a>
<a name="ln5860">                    }</a>
<a name="ln5861">                    if ((ABS(phase) &lt; ABS(phase_max)) ||</a>
<a name="ln5862">                        (ABS(phase) &lt; ABS(phase_min)))</a>
<a name="ln5863">                    {</a>
<a name="ln5864">                        phase_avg = phase_avg + phase;</a>
<a name="ln5865">                    }</a>
<a name="ln5866">                }</a>
<a name="ln5867">                magnitude_avg = magnitude_avg / (nmeasurement - 1);</a>
<a name="ln5868">                phase_avg = phase_avg / (nmeasurement - 1);</a>
<a name="ln5869"> </a>
<a name="ln5870">                /* detect magnitude outlier */</a>
<a name="ln5871">                if (ABS(magnitude_max - magnitude_min) &gt; MAX_MAG_DELTA) {</a>
<a name="ln5872">                    if (ABS(magnitude_max - magnitude_avg) &gt;</a>
<a name="ln5873">                        ABS(magnitude_min - magnitude_avg))</a>
<a name="ln5874">                    {</a>
<a name="ln5875">                        /* max is outlier, force to avg */</a>
<a name="ln5876">                        outlier_mag_idx = magnitude_max_idx;</a>
<a name="ln5877">                    } else {</a>
<a name="ln5878">                        /* min is outlier, force to avg */</a>
<a name="ln5879">                        outlier_mag_idx = magnitude_min_idx;</a>
<a name="ln5880">                    }</a>
<a name="ln5881">                    coeff-&gt;mag_coeff[ch_idx][outlier_mag_idx][0] = magnitude_avg;</a>
<a name="ln5882">                    coeff-&gt;phs_coeff[ch_idx][outlier_mag_idx][0] = phase_avg;</a>
<a name="ln5883">                    HALDEBUG(ah, HAL_DEBUG_CALIBRATE, </a>
<a name="ln5884">                        &quot;[ch%d][outlier mag gain%d]:: &quot;</a>
<a name="ln5885">                        &quot;mag_avg = %d (/128), phase_avg = %d (/256)\n&quot;,</a>
<a name="ln5886">                        ch_idx, outlier_mag_idx, magnitude_avg, phase_avg);</a>
<a name="ln5887">                }</a>
<a name="ln5888">                /* detect phase outlier */</a>
<a name="ln5889">                if (ABS(phase_max - phase_min) &gt; MAX_PHS_DELTA) {</a>
<a name="ln5890">                    if (ABS(phase_max-phase_avg) &gt; ABS(phase_min - phase_avg)) {</a>
<a name="ln5891">                        /* max is outlier, force to avg */</a>
<a name="ln5892">                        outlier_phs_idx = phase_max_idx;</a>
<a name="ln5893">                    } else{</a>
<a name="ln5894">                        /* min is outlier, force to avg */</a>
<a name="ln5895">                        outlier_phs_idx = phase_min_idx;</a>
<a name="ln5896">                    }</a>
<a name="ln5897">                    coeff-&gt;mag_coeff[ch_idx][outlier_phs_idx][0] = magnitude_avg;</a>
<a name="ln5898">                    coeff-&gt;phs_coeff[ch_idx][outlier_phs_idx][0] = phase_avg;</a>
<a name="ln5899">                    HALDEBUG(ah, HAL_DEBUG_CALIBRATE, </a>
<a name="ln5900">                        &quot;[ch%d][outlier phs gain%d]:: &quot; </a>
<a name="ln5901">                        &quot;mag_avg = %d (/128), phase_avg = %d (/256)\n&quot;,</a>
<a name="ln5902">                        ch_idx, outlier_phs_idx, magnitude_avg, phase_avg);</a>
<a name="ln5903">                }</a>
<a name="ln5904">            }</a>
<a name="ln5905">        }</a>
<a name="ln5906"> </a>
<a name="ln5907">        /*printf(&quot;------------ after outlier detection -------------\n&quot;);*/</a>
<a name="ln5908">        for (im = 0; im &lt; nmeasurement; im++) {</a>
<a name="ln5909">            magnitude = coeff-&gt;mag_coeff[ch_idx][im][0];</a>
<a name="ln5910">            phase = coeff-&gt;phs_coeff[ch_idx][im][0];</a>
<a name="ln5911"> </a>
<a name="ln5912">            #if 0</a>
<a name="ln5913">            printf(&quot;[ch%d][gain%d]:: mag = %d (/128), phase = %d (/256)\n&quot;,</a>
<a name="ln5914">                ch_idx, im, magnitude, phase);</a>
<a name="ln5915">            #endif</a>
<a name="ln5916"> </a>
<a name="ln5917">            coeff-&gt;iqc_coeff[0] = (phase &amp; 0x7f) | ((magnitude &amp; 0x7f) &lt;&lt; 7);</a>
<a name="ln5918"> </a>
<a name="ln5919">            if ((im % 2) == 0) {</a>
<a name="ln5920">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln5921">                    tx_corr_coeff[im][ch_idx],</a>
<a name="ln5922">                    AR_PHY_TX_IQCAL_CORR_COEFF_00_COEFF_TABLE,</a>
<a name="ln5923">                    coeff-&gt;iqc_coeff[0]);</a>
<a name="ln5924">            } else {</a>
<a name="ln5925">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln5926">                    tx_corr_coeff[im][ch_idx],</a>
<a name="ln5927">                    AR_PHY_TX_IQCAL_CORR_COEFF_01_COEFF_TABLE,</a>
<a name="ln5928">                    coeff-&gt;iqc_coeff[0]);</a>
<a name="ln5929">            }</a>
<a name="ln5930">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln5931">            ichan-&gt;tx_corr_coeff[im][ch_idx] = coeff-&gt;iqc_coeff[0];</a>
<a name="ln5932">#endif</a>
<a name="ln5933">        }</a>
<a name="ln5934">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln5935">        ichan-&gt;num_measures[ch_idx] = nmeasurement;</a>
<a name="ln5936">#endif</a>
<a name="ln5937">    }</a>
<a name="ln5938"> </a>
<a name="ln5939">    OS_REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_3,</a>
<a name="ln5940">                     AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN, 0x1);</a>
<a name="ln5941">    OS_REG_RMW_FIELD(ah, AR_PHY_RX_IQCAL_CORR_B0,</a>
<a name="ln5942">                     AR_PHY_RX_IQCAL_CORR_B0_LOOPBACK_IQCORR_EN, 0x1);</a>
<a name="ln5943"> </a>
<a name="ln5944">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln5945">    if (is_cal_reusable) {</a>
<a name="ln5946">        ichan-&gt;one_time_txiqcal_done = AH_TRUE;</a>
<a name="ln5947">        HALDEBUG(ah, HAL_DEBUG_FCS_RTT,</a>
<a name="ln5948">            &quot;(FCS) TXIQCAL saved - %d\n&quot;, ichan-&gt;channel);</a>
<a name="ln5949">    }</a>
<a name="ln5950">#endif</a>
<a name="ln5951">}</a>
<a name="ln5952"> </a>
<a name="ln5953">#if ATH_SUPPORT_CAL_REUSE</a>
<a name="ln5954">static void</a>
<a name="ln5955">ar9300_tx_iq_cal_apply(struct ath_hal *ah, HAL_CHANNEL_INTERNAL *ichan)</a>
<a name="ln5956">{</a>
<a name="ln5957">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln5958">    int nmeasurement, ch_idx, im;</a>
<a name="ln5959"> </a>
<a name="ln5960">    u_int32_t tx_corr_coeff[MAX_MEASUREMENT][AR9300_MAX_CHAINS] = {</a>
<a name="ln5961">        {   AR_PHY_TX_IQCAL_CORR_COEFF_01_B0,</a>
<a name="ln5962">            AR_PHY_TX_IQCAL_CORR_COEFF_01_B1,</a>
<a name="ln5963">            AR_PHY_TX_IQCAL_CORR_COEFF_01_B2},</a>
<a name="ln5964">        {   AR_PHY_TX_IQCAL_CORR_COEFF_01_B0,</a>
<a name="ln5965">            AR_PHY_TX_IQCAL_CORR_COEFF_01_B1,</a>
<a name="ln5966">            AR_PHY_TX_IQCAL_CORR_COEFF_01_B2},</a>
<a name="ln5967">        {   AR_PHY_TX_IQCAL_CORR_COEFF_23_B0,</a>
<a name="ln5968">            AR_PHY_TX_IQCAL_CORR_COEFF_23_B1,</a>
<a name="ln5969">            AR_PHY_TX_IQCAL_CORR_COEFF_23_B2},</a>
<a name="ln5970">        {   AR_PHY_TX_IQCAL_CORR_COEFF_23_B0,</a>
<a name="ln5971">            AR_PHY_TX_IQCAL_CORR_COEFF_23_B1,</a>
<a name="ln5972">            AR_PHY_TX_IQCAL_CORR_COEFF_23_B2},</a>
<a name="ln5973">        {   AR_PHY_TX_IQCAL_CORR_COEFF_45_B0,</a>
<a name="ln5974">            AR_PHY_TX_IQCAL_CORR_COEFF_45_B1,</a>
<a name="ln5975">            AR_PHY_TX_IQCAL_CORR_COEFF_45_B2},</a>
<a name="ln5976">        {   AR_PHY_TX_IQCAL_CORR_COEFF_45_B0,</a>
<a name="ln5977">            AR_PHY_TX_IQCAL_CORR_COEFF_45_B1,</a>
<a name="ln5978">            AR_PHY_TX_IQCAL_CORR_COEFF_45_B2},</a>
<a name="ln5979">        {   AR_PHY_TX_IQCAL_CORR_COEFF_67_B0,</a>
<a name="ln5980">            AR_PHY_TX_IQCAL_CORR_COEFF_67_B1,</a>
<a name="ln5981">            AR_PHY_TX_IQCAL_CORR_COEFF_67_B2},</a>
<a name="ln5982">        {   AR_PHY_TX_IQCAL_CORR_COEFF_67_B0,</a>
<a name="ln5983">            AR_PHY_TX_IQCAL_CORR_COEFF_67_B1,</a>
<a name="ln5984">            AR_PHY_TX_IQCAL_CORR_COEFF_67_B2},</a>
<a name="ln5985">    };</a>
<a name="ln5986"> </a>
<a name="ln5987">    if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln5988">        HALASSERT(ahp-&gt;ah_tx_cal_chainmask == 0x1);</a>
<a name="ln5989"> </a>
<a name="ln5990">        tx_corr_coeff[0][0] = AR_PHY_TX_IQCAL_CORR_COEFF_01_B0_POSEIDON;</a>
<a name="ln5991">        tx_corr_coeff[1][0] = AR_PHY_TX_IQCAL_CORR_COEFF_01_B0_POSEIDON;</a>
<a name="ln5992">        tx_corr_coeff[2][0] = AR_PHY_TX_IQCAL_CORR_COEFF_23_B0_POSEIDON;</a>
<a name="ln5993">        tx_corr_coeff[3][0] = AR_PHY_TX_IQCAL_CORR_COEFF_23_B0_POSEIDON;</a>
<a name="ln5994">        tx_corr_coeff[4][0] = AR_PHY_TX_IQCAL_CORR_COEFF_45_B0_POSEIDON;</a>
<a name="ln5995">        tx_corr_coeff[5][0] = AR_PHY_TX_IQCAL_CORR_COEFF_45_B0_POSEIDON;</a>
<a name="ln5996">        tx_corr_coeff[6][0] = AR_PHY_TX_IQCAL_CORR_COEFF_67_B0_POSEIDON;</a>
<a name="ln5997">        tx_corr_coeff[7][0] = AR_PHY_TX_IQCAL_CORR_COEFF_67_B0_POSEIDON;</a>
<a name="ln5998">    }</a>
<a name="ln5999"> </a>
<a name="ln6000">    for (ch_idx = 0; ch_idx &lt; AR9300_MAX_CHAINS; ch_idx++) {</a>
<a name="ln6001">        if ((ahp-&gt;ah_tx_cal_chainmask &amp; (1 &lt;&lt; ch_idx)) == 0) {</a>
<a name="ln6002">            continue;</a>
<a name="ln6003">        }</a>
<a name="ln6004">        nmeasurement = ichan-&gt;num_measures[ch_idx];</a>
<a name="ln6005"> </a>
<a name="ln6006">        for (im = 0; im &lt; nmeasurement; im++) {</a>
<a name="ln6007">            if ((im % 2) == 0) {</a>
<a name="ln6008">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln6009">                    tx_corr_coeff[im][ch_idx],</a>
<a name="ln6010">                    AR_PHY_TX_IQCAL_CORR_COEFF_00_COEFF_TABLE,</a>
<a name="ln6011">                    ichan-&gt;tx_corr_coeff[im][ch_idx]);</a>
<a name="ln6012">            } else {</a>
<a name="ln6013">                OS_REG_RMW_FIELD(ah,</a>
<a name="ln6014">                    tx_corr_coeff[im][ch_idx],</a>
<a name="ln6015">                    AR_PHY_TX_IQCAL_CORR_COEFF_01_COEFF_TABLE,</a>
<a name="ln6016">                    ichan-&gt;tx_corr_coeff[im][ch_idx]);</a>
<a name="ln6017">            }</a>
<a name="ln6018">        }</a>
<a name="ln6019">    }</a>
<a name="ln6020"> </a>
<a name="ln6021">    OS_REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_3,</a>
<a name="ln6022">                     AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN, 0x1);</a>
<a name="ln6023">    OS_REG_RMW_FIELD(ah, AR_PHY_RX_IQCAL_CORR_B0,</a>
<a name="ln6024">                     AR_PHY_RX_IQCAL_CORR_B0_LOOPBACK_IQCORR_EN, 0x1);</a>
<a name="ln6025">}</a>
<a name="ln6026">#endif</a>
<a name="ln6027"> </a>
<a name="ln6028">/*</a>
<a name="ln6029"> * ar9300_tx_iq_cal_hw_run is only needed for osprey/wasp/hornet</a>
<a name="ln6030"> * It is not needed for jupiter/poseidon.</a>
<a name="ln6031"> */</a>
<a name="ln6032">HAL_BOOL</a>
<a name="ln6033">ar9300_tx_iq_cal_hw_run(struct ath_hal *ah)</a>
<a name="ln6034">{</a>
<a name="ln6035">    int is_tx_gain_forced;</a>
<a name="ln6036"> </a>
<a name="ln6037">    is_tx_gain_forced = OS_REG_READ_FIELD(ah,</a>
<a name="ln6038">        AR_PHY_TX_FORCED_GAIN, AR_PHY_TXGAIN_FORCE);</a>
<a name="ln6039">    if (is_tx_gain_forced) {</a>
<a name="ln6040">        /*printf(&quot;Tx gain can not be forced during tx I/Q cal!\n&quot;);*/</a>
<a name="ln6041">        OS_REG_RMW_FIELD(ah, AR_PHY_TX_FORCED_GAIN, AR_PHY_TXGAIN_FORCE, 0);</a>
<a name="ln6042">    }</a>
<a name="ln6043"> </a>
<a name="ln6044">    /* enable tx IQ cal */</a>
<a name="ln6045">    OS_REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_START(ah),</a>
<a name="ln6046">        AR_PHY_TX_IQCAL_START_DO_CAL, AR_PHY_TX_IQCAL_START_DO_CAL);</a>
<a name="ln6047"> </a>
<a name="ln6048">    if (!ath_hal_wait(ah,</a>
<a name="ln6049">            AR_PHY_TX_IQCAL_START(ah), AR_PHY_TX_IQCAL_START_DO_CAL, 0))</a>
<a name="ln6050">    {</a>
<a name="ln6051">        HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln6052">            &quot;%s: Tx IQ Cal is never completed.\n&quot;, __func__);</a>
<a name="ln6053">        return AH_FALSE;</a>
<a name="ln6054">    }</a>
<a name="ln6055">    return AH_TRUE;</a>
<a name="ln6056">}</a>
<a name="ln6057"> </a>
<a name="ln6058">static void</a>
<a name="ln6059">ar9300_tx_iq_cal_post_proc(struct ath_hal *ah,HAL_CHANNEL_INTERNAL *ichan,</a>
<a name="ln6060">                           int iqcal_idx, int max_iqcal,HAL_BOOL is_cal_reusable, HAL_BOOL apply_last_corr)</a>
<a name="ln6061">{</a>
<a name="ln6062">    int nmeasurement=0, im, ix, iy, temp;</a>
<a name="ln6063">    struct ath_hal_9300     *ahp = AH9300(ah);</a>
<a name="ln6064">    u_int32_t txiqcal_status[AR9300_MAX_CHAINS] = {</a>
<a name="ln6065">        AR_PHY_TX_IQCAL_STATUS_B0(ah),</a>
<a name="ln6066">        AR_PHY_TX_IQCAL_STATUS_B1,</a>
<a name="ln6067">        AR_PHY_TX_IQCAL_STATUS_B2,</a>
<a name="ln6068">    };</a>
<a name="ln6069">    const u_int32_t chan_info_tab[] = {</a>
<a name="ln6070">        AR_PHY_CHAN_INFO_TAB_0,</a>
<a name="ln6071">        AR_PHY_CHAN_INFO_TAB_1,</a>
<a name="ln6072">        AR_PHY_CHAN_INFO_TAB_2,</a>
<a name="ln6073">    };</a>
<a name="ln6074">    int32_t iq_res[6];</a>
<a name="ln6075">    int32_t ch_idx, j;</a>
<a name="ln6076">    u_int32_t num_chains = 0;</a>
<a name="ln6077">    static struct coeff_t coeff;</a>
<a name="ln6078">    txiqcal_status[0] = AR_PHY_TX_IQCAL_STATUS_B0(ah);</a>
<a name="ln6079"> </a>
<a name="ln6080">    for (ch_idx = 0; ch_idx &lt; AR9300_MAX_CHAINS; ch_idx++) {</a>
<a name="ln6081">        if (ahp-&gt;ah_tx_chainmask &amp; (1 &lt;&lt; ch_idx)) {</a>
<a name="ln6082">            num_chains++;</a>
<a name="ln6083">        }</a>
<a name="ln6084">    }</a>
<a name="ln6085"> </a>
<a name="ln6086">    if (apply_last_corr) {</a>
<a name="ln6087">	    if (coeff.last_cal == AH_TRUE) {</a>
<a name="ln6088">		    int32_t magnitude, phase;</a>
<a name="ln6089">		    int ch_idx, im;</a>
<a name="ln6090">		    u_int32_t tx_corr_coeff[MAX_MEASUREMENT][AR9300_MAX_CHAINS] = {</a>
<a name="ln6091">			    {   AR_PHY_TX_IQCAL_CORR_COEFF_01_B0,</a>
<a name="ln6092">				    AR_PHY_TX_IQCAL_CORR_COEFF_01_B1,</a>
<a name="ln6093">				    AR_PHY_TX_IQCAL_CORR_COEFF_01_B2},</a>
<a name="ln6094">			    {   AR_PHY_TX_IQCAL_CORR_COEFF_01_B0,</a>
<a name="ln6095">				    AR_PHY_TX_IQCAL_CORR_COEFF_01_B1,</a>
<a name="ln6096">				    AR_PHY_TX_IQCAL_CORR_COEFF_01_B2},</a>
<a name="ln6097">			    {   AR_PHY_TX_IQCAL_CORR_COEFF_23_B0,</a>
<a name="ln6098">				    AR_PHY_TX_IQCAL_CORR_COEFF_23_B1,</a>
<a name="ln6099">				    AR_PHY_TX_IQCAL_CORR_COEFF_23_B2},</a>
<a name="ln6100">			    {   AR_PHY_TX_IQCAL_CORR_COEFF_23_B0,</a>
<a name="ln6101">				    AR_PHY_TX_IQCAL_CORR_COEFF_23_B1,</a>
<a name="ln6102">				    AR_PHY_TX_IQCAL_CORR_COEFF_23_B2},</a>
<a name="ln6103">			    {   AR_PHY_TX_IQCAL_CORR_COEFF_45_B0,</a>
<a name="ln6104">				    AR_PHY_TX_IQCAL_CORR_COEFF_45_B1,</a>
<a name="ln6105">				    AR_PHY_TX_IQCAL_CORR_COEFF_45_B2},</a>
<a name="ln6106">			    {   AR_PHY_TX_IQCAL_CORR_COEFF_45_B0,</a>
<a name="ln6107">				    AR_PHY_TX_IQCAL_CORR_COEFF_45_B1,</a>
<a name="ln6108">				    AR_PHY_TX_IQCAL_CORR_COEFF_45_B2},</a>
<a name="ln6109">			    {   AR_PHY_TX_IQCAL_CORR_COEFF_67_B0,</a>
<a name="ln6110">				    AR_PHY_TX_IQCAL_CORR_COEFF_67_B1,</a>
<a name="ln6111">				    AR_PHY_TX_IQCAL_CORR_COEFF_67_B2},</a>
<a name="ln6112">			    {   AR_PHY_TX_IQCAL_CORR_COEFF_67_B0,</a>
<a name="ln6113">				    AR_PHY_TX_IQCAL_CORR_COEFF_67_B1,</a>
<a name="ln6114">				    AR_PHY_TX_IQCAL_CORR_COEFF_67_B2},</a>
<a name="ln6115">		    };</a>
<a name="ln6116">		    for (ch_idx = 0; ch_idx &lt; num_chains; ch_idx++) {</a>
<a name="ln6117">			    for (im = 0; im &lt; coeff.last_nmeasurement; im++) {</a>
<a name="ln6118">				    magnitude = coeff.mag_coeff[ch_idx][im][0];</a>
<a name="ln6119">				    phase = coeff.phs_coeff[ch_idx][im][0];</a>
<a name="ln6120"> </a>
<a name="ln6121">#if 0</a>
<a name="ln6122">				    printf(&quot;[ch%d][gain%d]:: mag = %d (/128), phase = %d (/256)\n&quot;,</a>
<a name="ln6123">						    ch_idx, im, magnitude, phase);</a>
<a name="ln6124">#endif</a>
<a name="ln6125"> </a>
<a name="ln6126">				    coeff.iqc_coeff[0] = (phase &amp; 0x7f) | ((magnitude &amp; 0x7f) &lt;&lt; 7);</a>
<a name="ln6127">				    if ((im % 2) == 0) {</a>
<a name="ln6128">					    OS_REG_RMW_FIELD(ah,</a>
<a name="ln6129">							    tx_corr_coeff[im][ch_idx],</a>
<a name="ln6130">							    AR_PHY_TX_IQCAL_CORR_COEFF_00_COEFF_TABLE,</a>
<a name="ln6131">							    coeff.iqc_coeff[0]);</a>
<a name="ln6132">				    } else {</a>
<a name="ln6133">					    OS_REG_RMW_FIELD(ah,</a>
<a name="ln6134">							    tx_corr_coeff[im][ch_idx],</a>
<a name="ln6135">							    AR_PHY_TX_IQCAL_CORR_COEFF_01_COEFF_TABLE,</a>
<a name="ln6136">							    coeff.iqc_coeff[0]);</a>
<a name="ln6137">				    }</a>
<a name="ln6138">			    }</a>
<a name="ln6139">		    }</a>
<a name="ln6140">		    OS_REG_RMW_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_3,</a>
<a name="ln6141">				    AR_PHY_TX_IQCAL_CONTROL_3_IQCORR_EN, 0x1);</a>
<a name="ln6142">	    }</a>
<a name="ln6143">	    return;</a>
<a name="ln6144">    }</a>
<a name="ln6145"> </a>
<a name="ln6146"> </a>
<a name="ln6147">    for (ch_idx = 0; ch_idx &lt; num_chains; ch_idx++) {</a>
<a name="ln6148">        nmeasurement = OS_REG_READ_FIELD(ah,</a>
<a name="ln6149">            AR_PHY_TX_IQCAL_STATUS_B0(ah), AR_PHY_CALIBRATED_GAINS_0);</a>
<a name="ln6150">        if (nmeasurement &gt; MAX_MEASUREMENT) {</a>
<a name="ln6151">            nmeasurement = MAX_MEASUREMENT;</a>
<a name="ln6152">        }</a>
<a name="ln6153"> </a>
<a name="ln6154">        for (im = 0; im &lt; nmeasurement; im++) {</a>
<a name="ln6155">            HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln6156">                &quot;%s: Doing Tx IQ Cal for chain %d.\n&quot;, __func__, ch_idx);</a>
<a name="ln6157">            if (OS_REG_READ(ah, txiqcal_status[ch_idx]) &amp;</a>
<a name="ln6158">                AR_PHY_TX_IQCAL_STATUS_FAILED)</a>
<a name="ln6159">            {</a>
<a name="ln6160">                HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln6161">                    &quot;%s: Tx IQ Cal failed for chain %d.\n&quot;, __func__, ch_idx);</a>
<a name="ln6162">                goto TX_IQ_CAL_FAILED_;</a>
<a name="ln6163">            }</a>
<a name="ln6164"> </a>
<a name="ln6165">            for (j = 0; j &lt; 3; j++) {</a>
<a name="ln6166">                u_int32_t idx = 2 * j;</a>
<a name="ln6167">                /* 3 registers for each calibration result */</a>
<a name="ln6168">                u_int32_t offset = 4 * (3 * im + j);</a>
<a name="ln6169"> </a>
<a name="ln6170">                OS_REG_RMW_FIELD(ah, AR_PHY_CHAN_INFO_MEMORY,</a>
<a name="ln6171">                    AR_PHY_CHAN_INFO_TAB_S2_READ, 0);</a>
<a name="ln6172">                /* 32 bits */    </a>
<a name="ln6173">                iq_res[idx] = OS_REG_READ(ah, chan_info_tab[ch_idx] + offset);</a>
<a name="ln6174">                OS_REG_RMW_FIELD(ah, AR_PHY_CHAN_INFO_MEMORY,</a>
<a name="ln6175">                    AR_PHY_CHAN_INFO_TAB_S2_READ, 1);</a>
<a name="ln6176">                /* 16 bits */</a>
<a name="ln6177">                iq_res[idx + 1] = 0xffff &amp;</a>
<a name="ln6178">                    OS_REG_READ(ah, chan_info_tab[ch_idx] + offset);</a>
<a name="ln6179">    </a>
<a name="ln6180">                HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln6181">                    &quot;%s: IQ RES[%d]=0x%x IQ_RES[%d]=0x%x\n&quot;,</a>
<a name="ln6182">                    __func__, idx, iq_res[idx], idx + 1, iq_res[idx + 1]);</a>
<a name="ln6183">            }</a>
<a name="ln6184"> </a>
<a name="ln6185">            if (AH_FALSE == ar9300_calc_iq_corr(</a>
<a name="ln6186">                             ah, ch_idx, iq_res, coeff.iqc_coeff))</a>
<a name="ln6187">            {</a>
<a name="ln6188">                HALDEBUG(ah, HAL_DEBUG_CALIBRATE,</a>
<a name="ln6189">                    &quot;%s: Failed in calculation of IQ correction.\n&quot;,</a>
<a name="ln6190">                     __func__);</a>
<a name="ln6191">                goto TX_IQ_CAL_FAILED_;</a>
<a name="ln6192">            }</a>
<a name="ln6193"> </a>
<a name="ln6194">            coeff.phs_coeff[ch_idx][im][iqcal_idx-1] = coeff.iqc_coeff[0] &amp; 0x7f;</a>
<a name="ln6195">            coeff.mag_coeff[ch_idx][im][iqcal_idx-1] = (coeff.iqc_coeff[0] &gt;&gt; 7) &amp; 0x7f;</a>
<a name="ln6196">            if (coeff.mag_coeff[ch_idx][im][iqcal_idx-1] &gt; 63) {</a>
<a name="ln6197">                coeff.mag_coeff[ch_idx][im][iqcal_idx-1] -= 128;</a>
<a name="ln6198">            }</a>
<a name="ln6199">            if (coeff.phs_coeff[ch_idx][im][iqcal_idx-1] &gt; 63) {</a>
<a name="ln6200">                coeff.phs_coeff[ch_idx][im][iqcal_idx-1] -= 128;     </a>
<a name="ln6201">            }</a>
<a name="ln6202">#if 0</a>
<a name="ln6203">            ath_hal_printf(ah, &quot;IQCAL::[ch%d][gain%d]:: mag = %d phase = %d \n&quot;,</a>
<a name="ln6204">                ch_idx, im, coeff.mag_coeff[ch_idx][im][iqcal_idx-1],</a>
<a name="ln6205">                coeff.phs_coeff[ch_idx][im][iqcal_idx-1]);</a>
<a name="ln6206">#endif</a>
<a name="ln6207">        }</a>
<a name="ln6208">    }</a>
<a name="ln6209">    //last iteration; calculate mag and phs</a>
<a name="ln6210">    if (iqcal_idx == max_iqcal) {</a>
<a name="ln6211">        if (max_iqcal&gt;1) {</a>
<a name="ln6212">            for (ch_idx = 0; ch_idx &lt; num_chains; ch_idx++) {</a>
<a name="ln6213">                for (im = 0; im &lt; nmeasurement; im++) {</a>
<a name="ln6214">                    //sort mag and phs</a>
<a name="ln6215">                    for( ix=0;ix&lt;max_iqcal-1;ix++){</a>
<a name="ln6216">                        for( iy=ix+1;iy&lt;=max_iqcal-1;iy++){</a>
<a name="ln6217">                            if(coeff.mag_coeff[ch_idx][im][iy] &lt; </a>
<a name="ln6218">                                coeff.mag_coeff[ch_idx][im][ix]) {</a>
<a name="ln6219">                                //swap</a>
<a name="ln6220">                                temp=coeff.mag_coeff[ch_idx][im][ix];</a>
<a name="ln6221">                                coeff.mag_coeff[ch_idx][im][ix] = coeff.mag_coeff[ch_idx][im][iy];</a>
<a name="ln6222">                                coeff.mag_coeff[ch_idx][im][iy] = temp;</a>
<a name="ln6223">                            }</a>
<a name="ln6224">                            if(coeff.phs_coeff[ch_idx][im][iy] &lt; </a>
<a name="ln6225">                                coeff.phs_coeff[ch_idx][im][ix]){</a>
<a name="ln6226">                                //swap</a>
<a name="ln6227">                                temp=coeff.phs_coeff[ch_idx][im][ix];</a>
<a name="ln6228">                                coeff.phs_coeff[ch_idx][im][ix]=coeff.phs_coeff[ch_idx][im][iy];</a>
<a name="ln6229">                                coeff.phs_coeff[ch_idx][im][iy]=temp;</a>
<a name="ln6230">                            }</a>
<a name="ln6231">                        }  </a>
<a name="ln6232">                    }</a>
<a name="ln6233">                    //select median; 3rd entry in the sorted array</a>
<a name="ln6234">                    coeff.mag_coeff[ch_idx][im][0] = </a>
<a name="ln6235">                        coeff.mag_coeff[ch_idx][im][max_iqcal/2];</a>
<a name="ln6236">                    coeff.phs_coeff[ch_idx][im][0] =</a>
<a name="ln6237">                        coeff.phs_coeff[ch_idx][im][max_iqcal/2];</a>
<a name="ln6238">                    HALDEBUG(ah, HAL_DEBUG_CALIBRATE, </a>
<a name="ln6239">                        &quot;IQCAL: Median [ch%d][gain%d]:: mag = %d phase = %d \n&quot;, </a>
<a name="ln6240">                        ch_idx, im,coeff.mag_coeff[ch_idx][im][0], </a>
<a name="ln6241">                        coeff.phs_coeff[ch_idx][im][0]);</a>
<a name="ln6242">                }</a>
<a name="ln6243">            }	</a>
<a name="ln6244">        }</a>
<a name="ln6245">        ar9300_tx_iq_cal_outlier_detection(ah,ichan, num_chains, &amp;coeff,is_cal_reusable);</a>
<a name="ln6246">    }</a>
<a name="ln6247"> </a>
<a name="ln6248"> </a>
<a name="ln6249">    coeff.last_nmeasurement = nmeasurement;</a>
<a name="ln6250">    coeff.last_cal = AH_TRUE;</a>
<a name="ln6251"> </a>
<a name="ln6252">    return;</a>
<a name="ln6253"> </a>
<a name="ln6254">TX_IQ_CAL_FAILED_:</a>
<a name="ln6255">    /* no need to print this, it is AGC failure not chip stuck */</a>
<a name="ln6256">    /*ath_hal_printf(ah, &quot;Tx IQ Cal failed(%d)\n&quot;, line);*/</a>
<a name="ln6257">    coeff.last_cal = AH_FALSE;</a>
<a name="ln6258">    return;</a>
<a name="ln6259">}</a>
<a name="ln6260"> </a>
<a name="ln6261"> </a>
<a name="ln6262">/*</a>
<a name="ln6263"> * ar9300_disable_phy_restart</a>
<a name="ln6264"> *</a>
<a name="ln6265"> * In some BBpanics, we can disable the phyrestart</a>
<a name="ln6266"> * disable_phy_restart</a>
<a name="ln6267"> *      != 0, disable the phy restart in h/w</a>
<a name="ln6268"> *      == 0, enable the phy restart in h/w</a>
<a name="ln6269"> */</a>
<a name="ln6270">void ar9300_disable_phy_restart(struct ath_hal *ah, int disable_phy_restart)</a>
<a name="ln6271">{</a>
<a name="ln6272">    u_int32_t val;</a>
<a name="ln6273"> </a>
<a name="ln6274">    val = OS_REG_READ(ah, AR_PHY_RESTART);</a>
<a name="ln6275">    if (disable_phy_restart) {</a>
<a name="ln6276">        val &amp;= ~AR_PHY_RESTART_ENA;</a>
<a name="ln6277">        AH9300(ah)-&gt;ah_phyrestart_disabled = 1;</a>
<a name="ln6278">    } else {</a>
<a name="ln6279">        val |= AR_PHY_RESTART_ENA;</a>
<a name="ln6280">        AH9300(ah)-&gt;ah_phyrestart_disabled = 0;</a>
<a name="ln6281">    }</a>
<a name="ln6282">    OS_REG_WRITE(ah, AR_PHY_RESTART, val);</a>
<a name="ln6283"> </a>
<a name="ln6284">    val = OS_REG_READ(ah, AR_PHY_RESTART);</a>
<a name="ln6285">}</a>
<a name="ln6286"> </a>
<a name="ln6287">HAL_BOOL</a>
<a name="ln6288">ar9300_interference_is_present(struct ath_hal *ah)</a>
<a name="ln6289">{</a>
<a name="ln6290">    int i;</a>
<a name="ln6291">	HAL_NFCAL_HIST_FULL *h;</a>
<a name="ln6292">    struct ath_hal_private  *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln6293">    const struct ieee80211_channel *chan = ahpriv-&gt;ah_curchan;</a>
<a name="ln6294">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln6295"> </a>
<a name="ln6296">    if (ichan == NULL) {</a>
<a name="ln6297">        ath_hal_printf(ah, &quot;%s: called with ichan=NULL\n&quot;, __func__);</a>
<a name="ln6298">        return AH_FALSE;</a>
<a name="ln6299">    }</a>
<a name="ln6300"> </a>
<a name="ln6301">    /* This function is called after a stuck beacon, if EACS is enabled.</a>
<a name="ln6302">     * If CW interference is severe, then HW goes into a loop of continuous</a>
<a name="ln6303">     * stuck beacons and resets. On reset the NF cal history is cleared.</a>
<a name="ln6304">     * So the median value of the history cannot be used -</a>
<a name="ln6305">     * hence check if any value (Chain 0/Primary Channel)</a>
<a name="ln6306">     * is outside the bounds.</a>
<a name="ln6307">     */</a>
<a name="ln6308">    h = AH_HOME_CHAN_NFCAL_HIST(ah, ichan);</a>
<a name="ln6309">    for (i = 0; i &lt; HAL_NF_CAL_HIST_LEN_FULL; i++) {</a>
<a name="ln6310">        if (h-&gt;nf_cal_buffer[i][0] &gt;</a>
<a name="ln6311">            AH9300(ah)-&gt;nfp-&gt;nominal + AH9300(ah)-&gt;nf_cw_int_delta)</a>
<a name="ln6312">        {</a>
<a name="ln6313">            return AH_TRUE;</a>
<a name="ln6314">        }</a>
<a name="ln6315"> </a>
<a name="ln6316">    }</a>
<a name="ln6317">    return AH_FALSE;</a>
<a name="ln6318">}</a>
<a name="ln6319"> </a>
<a name="ln6320">#if ATH_SUPPORT_CRDC</a>
<a name="ln6321">void</a>
<a name="ln6322">ar9300_crdc_rx_notify(struct ath_hal *ah, struct ath_rx_status *rxs)</a>
<a name="ln6323">{</a>
<a name="ln6324">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln6325">    int rssi_index;</a>
<a name="ln6326">    </a>
<a name="ln6327">    if ((!AR_SREV_WASP(ah)) ||</a>
<a name="ln6328">        (!ahpriv-&gt;ah_config.ath_hal_crdc_enable)) {</a>
<a name="ln6329">        return;</a>
<a name="ln6330">    }</a>
<a name="ln6331"> </a>
<a name="ln6332">    if (rxs-&gt;rs_isaggr &amp;&amp; rxs-&gt;rs_moreaggr) {</a>
<a name="ln6333">        return;</a>
<a name="ln6334">    }</a>
<a name="ln6335"> </a>
<a name="ln6336">    if ((rxs-&gt;rs_rssi_ctl0 &gt;= HAL_RSSI_BAD) ||</a>
<a name="ln6337">        (rxs-&gt;rs_rssi_ctl1 &gt;= HAL_RSSI_BAD)) {</a>
<a name="ln6338">        return;</a>
<a name="ln6339">    }</a>
<a name="ln6340"> </a>
<a name="ln6341">    rssi_index = ah-&gt;ah_crdc_rssi_ptr % HAL_MAX_CRDC_RSSI_SAMPLE;</a>
<a name="ln6342"> </a>
<a name="ln6343">    ah-&gt;ah_crdc_rssi_sample[0][rssi_index] = rxs-&gt;rs_rssi_ctl0;</a>
<a name="ln6344">    ah-&gt;ah_crdc_rssi_sample[1][rssi_index] = rxs-&gt;rs_rssi_ctl1;</a>
<a name="ln6345"> </a>
<a name="ln6346">    ah-&gt;ah_crdc_rssi_ptr++;</a>
<a name="ln6347">}</a>
<a name="ln6348"> </a>
<a name="ln6349">static int</a>
<a name="ln6350">ar9300_crdc_avg_rssi(struct ath_hal *ah, int chain)</a>
<a name="ln6351">{</a>
<a name="ln6352">    int crdc_rssi_sum = 0;</a>
<a name="ln6353">    int crdc_rssi_ptr = ah-&gt;ah_crdc_rssi_ptr, i;</a>
<a name="ln6354">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln6355">    int crdc_window = ahpriv-&gt;ah_config.ath_hal_crdc_window;</a>
<a name="ln6356"> </a>
<a name="ln6357">    if (crdc_window &gt; HAL_MAX_CRDC_RSSI_SAMPLE) {</a>
<a name="ln6358">        crdc_window = HAL_MAX_CRDC_RSSI_SAMPLE;</a>
<a name="ln6359">    }</a>
<a name="ln6360"> </a>
<a name="ln6361">    for (i = 1; i &lt;= crdc_window; i++) {</a>
<a name="ln6362">        crdc_rssi_sum += </a>
<a name="ln6363">            ah-&gt;ah_crdc_rssi_sample[chain]</a>
<a name="ln6364">            [(crdc_rssi_ptr - i) % HAL_MAX_CRDC_RSSI_SAMPLE];</a>
<a name="ln6365">    }</a>
<a name="ln6366"> </a>
<a name="ln6367">    return crdc_rssi_sum / crdc_window;</a>
<a name="ln6368">}</a>
<a name="ln6369"> </a>
<a name="ln6370">static void</a>
<a name="ln6371">ar9300_crdc_activate(struct ath_hal *ah, int rssi_diff, int enable)</a>
<a name="ln6372">{</a>
<a name="ln6373">    int val, orig_val;</a>
<a name="ln6374">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln6375">    int crdc_numerator = ahpriv-&gt;ah_config.ath_hal_crdc_numerator;</a>
<a name="ln6376">    int crdc_denominator = ahpriv-&gt;ah_config.ath_hal_crdc_denominator;</a>
<a name="ln6377">    int c = (rssi_diff * crdc_numerator) / crdc_denominator;</a>
<a name="ln6378"> </a>
<a name="ln6379">    val = orig_val = OS_REG_READ(ah, AR_PHY_MULTICHAIN_CTRL);</a>
<a name="ln6380">    val &amp;= 0xffffff00;</a>
<a name="ln6381">    if (enable) {</a>
<a name="ln6382">        val |= 0x1;</a>
<a name="ln6383">        val |= ((c &lt;&lt; 1) &amp; 0xff);</a>
<a name="ln6384">    }</a>
<a name="ln6385">    OS_REG_WRITE(ah, AR_PHY_MULTICHAIN_CTRL, val);</a>
<a name="ln6386">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE, &quot;diff: %02d comp: %02d reg: %08x %08x\n&quot;, </a>
<a name="ln6387">        rssi_diff, c, orig_val, val);</a>
<a name="ln6388">}</a>
<a name="ln6389"> </a>
<a name="ln6390"> </a>
<a name="ln6391">void ar9300_chain_rssi_diff_compensation(struct ath_hal *ah)</a>
<a name="ln6392">{</a>
<a name="ln6393">    struct ath_hal_private  *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln6394">    int crdc_window = ahpriv-&gt;ah_config.ath_hal_crdc_window;</a>
<a name="ln6395">    int crdc_rssi_ptr = ah-&gt;ah_crdc_rssi_ptr;</a>
<a name="ln6396">    int crdc_rssi_thresh = ahpriv-&gt;ah_config.ath_hal_crdc_rssithresh;</a>
<a name="ln6397">    int crdc_diff_thresh = ahpriv-&gt;ah_config.ath_hal_crdc_diffthresh;</a>
<a name="ln6398">    int avg_rssi[2], avg_rssi_diff;</a>
<a name="ln6399"> </a>
<a name="ln6400">    if ((!AR_SREV_WASP(ah)) ||</a>
<a name="ln6401">        (!ahpriv-&gt;ah_config.ath_hal_crdc_enable)) {</a>
<a name="ln6402">        if (ah-&gt;ah_crdc_rssi_ptr) {</a>
<a name="ln6403">            ar9300_crdc_activate(ah, 0, 0);</a>
<a name="ln6404">            ah-&gt;ah_crdc_rssi_ptr = 0;</a>
<a name="ln6405">        }</a>
<a name="ln6406">        return;</a>
<a name="ln6407">    }</a>
<a name="ln6408"> </a>
<a name="ln6409">    if (crdc_window &gt; HAL_MAX_CRDC_RSSI_SAMPLE) {</a>
<a name="ln6410">        crdc_window = HAL_MAX_CRDC_RSSI_SAMPLE;</a>
<a name="ln6411">    }</a>
<a name="ln6412"> </a>
<a name="ln6413">    if (crdc_rssi_ptr &lt; crdc_window) {</a>
<a name="ln6414">        return;</a>
<a name="ln6415">    }</a>
<a name="ln6416"> </a>
<a name="ln6417">    avg_rssi[0] = ar9300_crdc_avg_rssi(ah, 0);</a>
<a name="ln6418">    avg_rssi[1] = ar9300_crdc_avg_rssi(ah, 1);</a>
<a name="ln6419">    avg_rssi_diff = avg_rssi[1] - avg_rssi[0];</a>
<a name="ln6420"> </a>
<a name="ln6421">    HALDEBUG(ah, HAL_DEBUG_CALIBRATE, &quot;crdc: avg: %02d %02d &quot;, </a>
<a name="ln6422">        avg_rssi[0], avg_rssi[1]);</a>
<a name="ln6423"> </a>
<a name="ln6424">    if ((avg_rssi[0] &lt; crdc_rssi_thresh) &amp;&amp;</a>
<a name="ln6425">        (avg_rssi[1] &lt; crdc_rssi_thresh)) {</a>
<a name="ln6426">        ar9300_crdc_activate(ah, 0, 0);</a>
<a name="ln6427">    } else {</a>
<a name="ln6428">        if (ABS(avg_rssi_diff) &gt;= crdc_diff_thresh) {</a>
<a name="ln6429">            ar9300_crdc_activate(ah, avg_rssi_diff, 1);</a>
<a name="ln6430">        } else {</a>
<a name="ln6431">            ar9300_crdc_activate(ah, 0, 1);</a>
<a name="ln6432">        }</a>
<a name="ln6433">    }</a>
<a name="ln6434">}</a>
<a name="ln6435">#endif</a>
<a name="ln6436"> </a>
<a name="ln6437">#if ATH_ANT_DIV_COMB</a>
<a name="ln6438">HAL_BOOL</a>
<a name="ln6439">ar9300_ant_ctrl_set_lna_div_use_bt_ant(struct ath_hal *ah, HAL_BOOL enable, const struct ieee80211_channel *chan)</a>
<a name="ln6440">{</a>
<a name="ln6441">    u_int32_t value;</a>
<a name="ln6442">    u_int32_t regval;</a>
<a name="ln6443">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln6444">    HAL_CHANNEL_INTERNAL *ichan;</a>
<a name="ln6445">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln6446">    HAL_CAPABILITIES *pcap = &amp;ahpriv-&gt;ah_caps;</a>
<a name="ln6447"> </a>
<a name="ln6448">    HALDEBUG(ah, HAL_DEBUG_RESET | HAL_DEBUG_BT_COEX,</a>
<a name="ln6449">      &quot;%s: called; enable=%d\n&quot;, __func__, enable);</a>
<a name="ln6450"> </a>
<a name="ln6451">    if (AR_SREV_POSEIDON(ah)) {</a>
<a name="ln6452">        // Make sure this scheme is only used for WB225(Astra)</a>
<a name="ln6453">        ahp-&gt;ah_lna_div_use_bt_ant_enable = enable;</a>
<a name="ln6454"> </a>
<a name="ln6455">        ichan = ar9300_check_chan(ah, chan);</a>
<a name="ln6456">        if ( ichan == AH_NULL ) {</a>
<a name="ln6457">            HALDEBUG(ah, HAL_DEBUG_CHANNEL, &quot;%s: invalid channel %u/0x%x; no mapping\n&quot;,</a>
<a name="ln6458">                     __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln6459">            return AH_FALSE;</a>
<a name="ln6460">        }</a>
<a name="ln6461"> </a>
<a name="ln6462">        if ( enable == TRUE ) {</a>
<a name="ln6463">            pcap-&gt;halAntDivCombSupport = TRUE;</a>
<a name="ln6464">        } else {</a>
<a name="ln6465">            pcap-&gt;halAntDivCombSupport = pcap-&gt;halAntDivCombSupportOrg;</a>
<a name="ln6466">        }</a>
<a name="ln6467"> </a>
<a name="ln6468">#define AR_SWITCH_TABLE_COM2_ALL (0xffffff)</a>
<a name="ln6469">#define AR_SWITCH_TABLE_COM2_ALL_S (0)</a>
<a name="ln6470">        value = ar9300_ant_ctrl_common2_get(ah, IS_CHAN_2GHZ(ichan));</a>
<a name="ln6471">        if ( enable == TRUE ) {</a>
<a name="ln6472">            value &amp;= ~AR_SWITCH_TABLE_COM2_ALL;</a>
<a name="ln6473">            value |= ah-&gt;ah_config.ath_hal_ant_ctrl_comm2g_switch_enable;</a>
<a name="ln6474">        }</a>
<a name="ln6475">	HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: com2=0x%08x\n&quot;, __func__, value);</a>
<a name="ln6476">        OS_REG_RMW_FIELD(ah, AR_PHY_SWITCH_COM_2, AR_SWITCH_TABLE_COM2_ALL, value);</a>
<a name="ln6477"> </a>
<a name="ln6478">        value = ar9300_eeprom_get(ahp, EEP_ANTDIV_control);</a>
<a name="ln6479">        /* main_lnaconf, alt_lnaconf, main_tb, alt_tb */</a>
<a name="ln6480">        regval = OS_REG_READ(ah, AR_PHY_MC_GAIN_CTRL);</a>
<a name="ln6481">        regval &amp;= (~ANT_DIV_CONTROL_ALL); /* clear bit 25~30 */     </a>
<a name="ln6482">        regval |= (value &amp; 0x3f) &lt;&lt; ANT_DIV_CONTROL_ALL_S; </a>
<a name="ln6483">        /* enable_lnadiv */</a>
<a name="ln6484">        regval &amp;= (~MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__MASK);</a>
<a name="ln6485">        regval |= ((value &gt;&gt; 6) &amp; 0x1) &lt;&lt; </a>
<a name="ln6486">                  MULTICHAIN_GAIN_CTRL__ENABLE_ANT_DIV_LNADIV__SHIFT;</a>
<a name="ln6487">        if ( enable == TRUE ) {</a>
<a name="ln6488">            regval |= ANT_DIV_ENABLE;</a>
<a name="ln6489">        }</a>
<a name="ln6490">        OS_REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);</a>
<a name="ln6491"> </a>
<a name="ln6492">        /* enable fast_div */</a>
<a name="ln6493">        regval = OS_REG_READ(ah, AR_PHY_CCK_DETECT);</a>
<a name="ln6494">        regval &amp;= (~BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__MASK);</a>
<a name="ln6495">        regval |= ((value &gt;&gt; 7) &amp; 0x1) &lt;&lt; </a>
<a name="ln6496">                  BBB_SIG_DETECT__ENABLE_ANT_FAST_DIV__SHIFT;</a>
<a name="ln6497">        if ( enable == TRUE ) {</a>
<a name="ln6498">            regval |= FAST_DIV_ENABLE;</a>
<a name="ln6499">        }</a>
<a name="ln6500">        OS_REG_WRITE(ah, AR_PHY_CCK_DETECT, regval);</a>
<a name="ln6501">  </a>
<a name="ln6502">        if ( AR_SREV_POSEIDON_11_OR_LATER(ah) ) {</a>
<a name="ln6503">            if (pcap-&gt;halAntDivCombSupport) {</a>
<a name="ln6504">                /* If support DivComb, set MAIN to LNA1 and ALT to LNA2 at the first beginning */</a>
<a name="ln6505">                regval = OS_REG_READ(ah, AR_PHY_MC_GAIN_CTRL);</a>
<a name="ln6506">                /* clear bit 25~30 main_lnaconf, alt_lnaconf, main_tb, alt_tb */</a>
<a name="ln6507">                regval &amp;= (~(MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__MASK | </a>
<a name="ln6508">                             MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__MASK | </a>
<a name="ln6509">                             MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_GAINTB__MASK | </a>
<a name="ln6510">                             MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_GAINTB__MASK)); </a>
<a name="ln6511">                regval |= (HAL_ANT_DIV_COMB_LNA1 &lt;&lt; </a>
<a name="ln6512">                           MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT); </a>
<a name="ln6513">                regval |= (HAL_ANT_DIV_COMB_LNA2 &lt;&lt; </a>
<a name="ln6514">                           MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT); </a>
<a name="ln6515">                OS_REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);</a>
<a name="ln6516">            }</a>
<a name="ln6517">        }</a>
<a name="ln6518"> </a>
<a name="ln6519">        return AH_TRUE;</a>
<a name="ln6520">    } else if (AR_SREV_APHRODITE(ah)) {</a>
<a name="ln6521">        ahp-&gt;ah_lna_div_use_bt_ant_enable = enable;</a>
<a name="ln6522">        if (enable) {</a>
<a name="ln6523">                OS_REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL, ANT_DIV_ENABLE);</a>
<a name="ln6524">                OS_REG_SET_BIT(ah, AR_PHY_MC_GAIN_CTRL, (1 &lt;&lt; MULTICHAIN_GAIN_CTRL__ENABLE_ANT_SW_RX_PROT__SHIFT));</a>
<a name="ln6525">                OS_REG_SET_BIT(ah, AR_PHY_CCK_DETECT, AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);</a>
<a name="ln6526">                OS_REG_SET_BIT(ah, AR_PHY_RESTART, RESTART__ENABLE_ANT_FAST_DIV_M2FLAG__MASK);</a>
<a name="ln6527">                OS_REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);</a>
<a name="ln6528">        } else {</a>
<a name="ln6529">                OS_REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL, ANT_DIV_ENABLE);</a>
<a name="ln6530">                OS_REG_CLR_BIT(ah, AR_PHY_MC_GAIN_CTRL, (1 &lt;&lt; MULTICHAIN_GAIN_CTRL__ENABLE_ANT_SW_RX_PROT__SHIFT));</a>
<a name="ln6531">                OS_REG_CLR_BIT(ah, AR_PHY_CCK_DETECT, AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);</a>
<a name="ln6532">                OS_REG_CLR_BIT(ah, AR_PHY_RESTART, RESTART__ENABLE_ANT_FAST_DIV_M2FLAG__MASK);</a>
<a name="ln6533">                OS_REG_CLR_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);</a>
<a name="ln6534"> </a>
<a name="ln6535">                regval = OS_REG_READ(ah, AR_PHY_MC_GAIN_CTRL);</a>
<a name="ln6536">                regval &amp;= (~(MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__MASK |</a>
<a name="ln6537">                             MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__MASK |</a>
<a name="ln6538">                             MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_GAINTB__MASK |</a>
<a name="ln6539">                             MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_GAINTB__MASK));</a>
<a name="ln6540">                regval |= (HAL_ANT_DIV_COMB_LNA1 &lt;&lt;</a>
<a name="ln6541">                           MULTICHAIN_GAIN_CTRL__ANT_DIV_MAIN_LNACONF__SHIFT);</a>
<a name="ln6542">                regval |= (HAL_ANT_DIV_COMB_LNA2 &lt;&lt;</a>
<a name="ln6543">                           MULTICHAIN_GAIN_CTRL__ANT_DIV_ALT_LNACONF__SHIFT);</a>
<a name="ln6544"> </a>
<a name="ln6545">                OS_REG_WRITE(ah, AR_PHY_MC_GAIN_CTRL, regval);</a>
<a name="ln6546">        }</a>
<a name="ln6547">        return AH_TRUE;</a>
<a name="ln6548">    }</a>
<a name="ln6549">    return AH_TRUE;</a>
<a name="ln6550">}</a>
<a name="ln6551">#endif /* ATH_ANT_DIV_COMB */</a>

</code></pre>
<div class="balloon" rel="2743"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'chan' pointer was utilized before it was verified against nullptr. Check lines: 2743, 2745.</p></div>
<div class="balloon" rel="1134"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand is negative ('(freq_offset - 10)' = [-10..6075]).</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
