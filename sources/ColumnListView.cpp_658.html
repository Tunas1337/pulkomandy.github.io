
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ColumnListView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35">/*******************************************************************************</a>
<a name="ln36">/</a>
<a name="ln37">/	File:			ColumnListView.cpp</a>
<a name="ln38">/</a>
<a name="ln39">/   Description:    Experimental multi-column list view.</a>
<a name="ln40">/</a>
<a name="ln41">/	Copyright 2000+, Be Incorporated, All Rights Reserved</a>
<a name="ln42">/					 By Jeff Bush</a>
<a name="ln43">/</a>
<a name="ln44">*******************************************************************************/</a>
<a name="ln45"> </a>
<a name="ln46">#include &quot;ColumnListView.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;typeinfo&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;algorithm&gt;</a>
<a name="ln51">#include &lt;stdio.h&gt;</a>
<a name="ln52">#include &lt;stdlib.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#include &lt;Application.h&gt;</a>
<a name="ln55">#include &lt;Bitmap.h&gt;</a>
<a name="ln56">#include &lt;ControlLook.h&gt;</a>
<a name="ln57">#include &lt;Cursor.h&gt;</a>
<a name="ln58">#include &lt;Debug.h&gt;</a>
<a name="ln59">#include &lt;GraphicsDefs.h&gt;</a>
<a name="ln60">#include &lt;LayoutUtils.h&gt;</a>
<a name="ln61">#include &lt;MenuItem.h&gt;</a>
<a name="ln62">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln63">#include &lt;Region.h&gt;</a>
<a name="ln64">#include &lt;ScrollBar.h&gt;</a>
<a name="ln65">#include &lt;String.h&gt;</a>
<a name="ln66">#include &lt;SupportDefs.h&gt;</a>
<a name="ln67">#include &lt;Window.h&gt;</a>
<a name="ln68"> </a>
<a name="ln69">#include &lt;ObjectListPrivate.h&gt;</a>
<a name="ln70"> </a>
<a name="ln71">#include &quot;ObjectList.h&quot;</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">#define DOUBLE_BUFFERED_COLUMN_RESIZE 1</a>
<a name="ln75">#define SMART_REDRAW 1</a>
<a name="ln76">#define DRAG_TITLE_OUTLINE 1</a>
<a name="ln77">#define CONSTRAIN_CLIPPING_REGION 1</a>
<a name="ln78">#define LOWER_SCROLLBAR 0</a>
<a name="ln79"> </a>
<a name="ln80"> </a>
<a name="ln81">namespace BPrivate {</a>
<a name="ln82"> </a>
<a name="ln83">static const unsigned char kDownSortArrow8x8[] = {</a>
<a name="ln84">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln85">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln86">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln87">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln88">	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,</a>
<a name="ln89">	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,</a>
<a name="ln90">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln91">	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94">static const unsigned char kUpSortArrow8x8[] = {</a>
<a name="ln95">	0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln96">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln97">	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,</a>
<a name="ln98">	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,</a>
<a name="ln99">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln100">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln101">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,</a>
<a name="ln102">	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff</a>
<a name="ln103">};</a>
<a name="ln104"> </a>
<a name="ln105">static const unsigned char kDownSortArrow8x8Invert[] = {</a>
<a name="ln106">	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln107">	0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0xff,</a>
<a name="ln108">	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln109">	0xff, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0xff, 0xff,</a>
<a name="ln110">	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln111">	0xff, 0xff, 0x1f, 0x1f, 0x1f, 0xff, 0xff, 0xff,</a>
<a name="ln112">	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln113">	0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff</a>
<a name="ln114">};</a>
<a name="ln115"> </a>
<a name="ln116">static const unsigned char kUpSortArrow8x8Invert[] = {</a>
<a name="ln117">	0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln118">	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln119">	0xff, 0xff, 0x1f, 0x1f, 0x1f, 0xff, 0xff, 0xff,</a>
<a name="ln120">	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln121">	0xff, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0xff, 0xff,</a>
<a name="ln122">	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,</a>
<a name="ln123">	0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0xff,</a>
<a name="ln124">	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff</a>
<a name="ln125">};</a>
<a name="ln126"> </a>
<a name="ln127">static const float kTintedLineTint = 1.04;</a>
<a name="ln128"> </a>
<a name="ln129">static const float kMinTitleHeight = 16.0;</a>
<a name="ln130">static const float kMinRowHeight = 16.0;</a>
<a name="ln131">static const float kTitleSpacing = 1.4;</a>
<a name="ln132">static const float kRowSpacing = 1.4;</a>
<a name="ln133">static const float kLatchWidth = 15.0;</a>
<a name="ln134"> </a>
<a name="ln135">static const int32 kMaxDepth = 1024;</a>
<a name="ln136">static const float kLeftMargin = kLatchWidth;</a>
<a name="ln137">static const float kRightMargin = 8;</a>
<a name="ln138">static const float kOutlineLevelIndent = kLatchWidth;</a>
<a name="ln139">static const float kColumnResizeAreaWidth = 10.0;</a>
<a name="ln140">static const float kRowDragSensitivity = 5.0;</a>
<a name="ln141">static const float kDoubleClickMoveSensitivity = 4.0;</a>
<a name="ln142">static const float kSortIndicatorWidth = 9.0;</a>
<a name="ln143">static const float kDropHighlightLineHeight = 2.0;</a>
<a name="ln144"> </a>
<a name="ln145">static const uint32 kToggleColumn = 'BTCL';</a>
<a name="ln146"> </a>
<a name="ln147">class BRowContainer : public BObjectList&lt;BRow&gt;</a>
<a name="ln148">{</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151">class TitleView : public BView {</a>
<a name="ln152">	typedef BView _inherited;</a>
<a name="ln153">public:</a>
<a name="ln154">								TitleView(BRect frame, OutlineView* outlineView,</a>
<a name="ln155">									BList* visibleColumns, BList* sortColumns,</a>
<a name="ln156">									BColumnListView* masterView,</a>
<a name="ln157">									uint32 resizingMode);</a>
<a name="ln158">	virtual						~TitleView();</a>
<a name="ln159"> </a>
<a name="ln160">			void				ColumnAdded(BColumn* column);</a>
<a name="ln161">			void				ColumnResized(BColumn* column, float oldWidth);</a>
<a name="ln162">			void				SetColumnVisible(BColumn* column, bool visible);</a>
<a name="ln163"> </a>
<a name="ln164">	virtual	void				Draw(BRect updateRect);</a>
<a name="ln165">	virtual	void				ScrollTo(BPoint where);</a>
<a name="ln166">	virtual	void				MessageReceived(BMessage* message);</a>
<a name="ln167">	virtual	void				MouseDown(BPoint where);</a>
<a name="ln168">	virtual	void				MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln169">									const BMessage* dragMessage);</a>
<a name="ln170">	virtual	void				MouseUp(BPoint where);</a>
<a name="ln171">	virtual	void				FrameResized(float width, float height);</a>
<a name="ln172"> </a>
<a name="ln173">			void				MoveColumn(BColumn* column, int32 index);</a>
<a name="ln174">			void				SetColumnFlags(column_flags flags);</a>
<a name="ln175"> </a>
<a name="ln176">			void				SetEditMode(bool state)</a>
<a name="ln177">									{ fEditMode = state; }</a>
<a name="ln178"> </a>
<a name="ln179">			float				MarginWidth() const;</a>
<a name="ln180"> </a>
<a name="ln181">private:</a>
<a name="ln182">			void				GetTitleRect(BColumn* column, BRect* _rect);</a>
<a name="ln183">			int32				FindColumn(BPoint where, float* _leftEdge);</a>
<a name="ln184">			void				FixScrollBar(bool scrollToFit);</a>
<a name="ln185">			void				DragSelectedColumn(BPoint where);</a>
<a name="ln186">			void				ResizeSelectedColumn(BPoint where,</a>
<a name="ln187">									bool preferred = false);</a>
<a name="ln188">			void				ComputeDragBoundries(BColumn* column,</a>
<a name="ln189">									BPoint where);</a>
<a name="ln190">			void				DrawTitle(BView* view, BRect frame,</a>
<a name="ln191">									BColumn* column, bool depressed);</a>
<a name="ln192"> </a>
<a name="ln193">			float				_VirtualWidth() const;</a>
<a name="ln194"> </a>
<a name="ln195">			OutlineView*		fOutlineView;</a>
<a name="ln196">			BList*				fColumns;</a>
<a name="ln197">			BList*				fSortColumns;</a>
<a name="ln198">//			float				fColumnsWidth;</a>
<a name="ln199">			BRect				fVisibleRect;</a>
<a name="ln200"> </a>
<a name="ln201">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln202">			BBitmap*			fDrawBuffer;</a>
<a name="ln203">			BView*				fDrawBufferView;</a>
<a name="ln204">#endif</a>
<a name="ln205"> </a>
<a name="ln206">			enum {</a>
<a name="ln207">				INACTIVE,</a>
<a name="ln208">				RESIZING_COLUMN,</a>
<a name="ln209">				PRESSING_COLUMN,</a>
<a name="ln210">				DRAG_COLUMN_INSIDE_TITLE,</a>
<a name="ln211">				DRAG_COLUMN_OUTSIDE_TITLE</a>
<a name="ln212">			}					fCurrentState;</a>
<a name="ln213"> </a>
<a name="ln214">			BPopUpMenu*			fColumnPop;</a>
<a name="ln215">			BColumnListView*	fMasterView;</a>
<a name="ln216">			bool				fEditMode;</a>
<a name="ln217">			int32				fColumnFlags;</a>
<a name="ln218"> </a>
<a name="ln219">	// State information for resizing/dragging</a>
<a name="ln220">			BColumn*			fSelectedColumn;</a>
<a name="ln221">			BRect				fSelectedColumnRect;</a>
<a name="ln222">			bool				fResizingFirstColumn;</a>
<a name="ln223">			BPoint				fClickPoint; // offset within cell</a>
<a name="ln224">			float				fLeftDragBoundry;</a>
<a name="ln225">			float				fRightDragBoundry;</a>
<a name="ln226">			BPoint				fCurrentDragPosition;</a>
<a name="ln227"> </a>
<a name="ln228"> </a>
<a name="ln229">			BBitmap*			fUpSortArrow;</a>
<a name="ln230">			BBitmap*			fDownSortArrow;</a>
<a name="ln231"> </a>
<a name="ln232">			BCursor*			fResizeCursor;</a>
<a name="ln233">			BCursor*			fMinResizeCursor;</a>
<a name="ln234">			BCursor*			fMaxResizeCursor;</a>
<a name="ln235">			BCursor*			fColumnMoveCursor;</a>
<a name="ln236">};</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239">class OutlineView : public BView {</a>
<a name="ln240">	typedef BView _inherited;</a>
<a name="ln241">public:</a>
<a name="ln242">								OutlineView(BRect, BList* visibleColumns,</a>
<a name="ln243">									BList* sortColumns,</a>
<a name="ln244">									BColumnListView* listView);</a>
<a name="ln245">	virtual						~OutlineView();</a>
<a name="ln246"> </a>
<a name="ln247">	virtual void				Draw(BRect);</a>
<a name="ln248">	const 	BRect&amp;				VisibleRect() const;</a>
<a name="ln249"> </a>
<a name="ln250">			void				RedrawColumn(BColumn* column, float leftEdge,</a>
<a name="ln251">									bool isFirstColumn);</a>
<a name="ln252">			void 				StartSorting();</a>
<a name="ln253">			float				GetColumnPreferredWidth(BColumn* column);</a>
<a name="ln254"> </a>
<a name="ln255">			void				AddRow(BRow*, int32 index, BRow* TheRow);</a>
<a name="ln256">			BRow*				CurrentSelection(BRow* lastSelected) const;</a>
<a name="ln257">			void 				ToggleFocusRowSelection(bool selectRange);</a>
<a name="ln258">			void 				ToggleFocusRowOpen();</a>
<a name="ln259">			void 				ChangeFocusRow(bool up, bool updateSelection,</a>
<a name="ln260">									bool addToCurrentSelection);</a>
<a name="ln261">			void 				MoveFocusToVisibleRect();</a>
<a name="ln262">			void 				ExpandOrCollapse(BRow* parent, bool expand);</a>
<a name="ln263">			void 				RemoveRow(BRow*);</a>
<a name="ln264">			BRowContainer*		RowList();</a>
<a name="ln265">			void				UpdateRow(BRow*);</a>
<a name="ln266">			bool				FindParent(BRow* row, BRow** _parent,</a>
<a name="ln267">									bool* _isVisible);</a>
<a name="ln268">			int32				IndexOf(BRow* row);</a>
<a name="ln269">			void				Deselect(BRow*);</a>
<a name="ln270">			void				AddToSelection(BRow*);</a>
<a name="ln271">			void				DeselectAll();</a>
<a name="ln272">			BRow*				FocusRow() const;</a>
<a name="ln273">			void				SetFocusRow(BRow* row, bool select);</a>
<a name="ln274">			BRow*				FindRow(float ypos, int32* _indent,</a>
<a name="ln275">									float* _top);</a>
<a name="ln276">			bool				FindRect(const BRow* row, BRect* _rect);</a>
<a name="ln277">			void				ScrollTo(const BRow* row);</a>
<a name="ln278"> </a>
<a name="ln279">			void				Clear();</a>
<a name="ln280">			void				SetSelectionMode(list_view_type type);</a>
<a name="ln281">			list_view_type		SelectionMode() const;</a>
<a name="ln282">			void				SetMouseTrackingEnabled(bool);</a>
<a name="ln283">			void				FixScrollBar(bool scrollToFit);</a>
<a name="ln284">			void				SetEditMode(bool state)</a>
<a name="ln285">									{ fEditMode = state; }</a>
<a name="ln286"> </a>
<a name="ln287">	virtual void				FrameResized(float width, float height);</a>
<a name="ln288">	virtual void				ScrollTo(BPoint where);</a>
<a name="ln289">	virtual void				MouseDown(BPoint where);</a>
<a name="ln290">	virtual void				MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln291">									const BMessage* dragMessage);</a>
<a name="ln292">	virtual void				MouseUp(BPoint where);</a>
<a name="ln293">	virtual void				MessageReceived(BMessage* message);</a>
<a name="ln294"> </a>
<a name="ln295">private:</a>
<a name="ln296">			bool				SortList(BRowContainer* list, bool isVisible);</a>
<a name="ln297">	static	int32				DeepSortThreadEntry(void* outlineView);</a>
<a name="ln298">			void				DeepSort();</a>
<a name="ln299">			void				SelectRange(BRow* start, BRow* end);</a>
<a name="ln300">			int32				CompareRows(BRow* row1, BRow* row2);</a>
<a name="ln301">			void				AddSorted(BRowContainer* list, BRow* row);</a>
<a name="ln302">			void				RecursiveDeleteRows(BRowContainer* list,</a>
<a name="ln303">									bool owner);</a>
<a name="ln304">			void				InvalidateCachedPositions();</a>
<a name="ln305">			bool				FindVisibleRect(BRow* row, BRect* _rect);</a>
<a name="ln306"> </a>
<a name="ln307">			BList*				fColumns;</a>
<a name="ln308">			BList*				fSortColumns;</a>
<a name="ln309">			float				fItemsHeight;</a>
<a name="ln310">			BRowContainer		fRows;</a>
<a name="ln311">			BRect				fVisibleRect;</a>
<a name="ln312"> </a>
<a name="ln313">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln314">			BBitmap*			fDrawBuffer;</a>
<a name="ln315">			BView*				fDrawBufferView;</a>
<a name="ln316">#endif</a>
<a name="ln317"> </a>
<a name="ln318">			BRow*				fFocusRow;</a>
<a name="ln319">			BRect				fFocusRowRect;</a>
<a name="ln320">			BRow*				fRollOverRow;</a>
<a name="ln321"> </a>
<a name="ln322">			BRow				fSelectionListDummyHead;</a>
<a name="ln323">			BRow*				fLastSelectedItem;</a>
<a name="ln324">			BRow*				fFirstSelectedItem;</a>
<a name="ln325"> </a>
<a name="ln326">			thread_id			fSortThread;</a>
<a name="ln327">			int32				fNumSorted;</a>
<a name="ln328">			bool				fSortCancelled;</a>
<a name="ln329"> </a>
<a name="ln330">			enum CurrentState {</a>
<a name="ln331">				INACTIVE,</a>
<a name="ln332">				LATCH_CLICKED,</a>
<a name="ln333">				ROW_CLICKED,</a>
<a name="ln334">				DRAGGING_ROWS</a>
<a name="ln335">			};</a>
<a name="ln336"> </a>
<a name="ln337">			CurrentState		fCurrentState;</a>
<a name="ln338"> </a>
<a name="ln339"> </a>
<a name="ln340">			BColumnListView*	fMasterView;</a>
<a name="ln341">			list_view_type		fSelectionMode;</a>
<a name="ln342">			bool				fTrackMouse;</a>
<a name="ln343">			BField*				fCurrentField;</a>
<a name="ln344">			BRow*				fCurrentRow;</a>
<a name="ln345">			BColumn*			fCurrentColumn;</a>
<a name="ln346">			bool				fMouseDown;</a>
<a name="ln347">			BRect				fFieldRect;</a>
<a name="ln348">			int32				fCurrentCode;</a>
<a name="ln349">			bool				fEditMode;</a>
<a name="ln350"> </a>
<a name="ln351">	// State information for mouse/keyboard interaction</a>
<a name="ln352">			BPoint				fClickPoint;</a>
<a name="ln353">			bool				fDragging;</a>
<a name="ln354">			int32				fClickCount;</a>
<a name="ln355">			BRow*				fTargetRow;</a>
<a name="ln356">			float				fTargetRowTop;</a>
<a name="ln357">			BRect				fLatchRect;</a>
<a name="ln358">			float				fDropHighlightY;</a>
<a name="ln359"> </a>
<a name="ln360">	friend class RecursiveOutlineIterator;</a>
<a name="ln361">};</a>
<a name="ln362"> </a>
<a name="ln363"> </a>
<a name="ln364">class RecursiveOutlineIterator {</a>
<a name="ln365">public:</a>
<a name="ln366">								RecursiveOutlineIterator(</a>
<a name="ln367">									BRowContainer* container,</a>
<a name="ln368">									bool openBranchesOnly = true);</a>
<a name="ln369"> </a>
<a name="ln370">			BRow*				CurrentRow() const;</a>
<a name="ln371">			int32				CurrentLevel() const;</a>
<a name="ln372">			void				GoToNext();</a>
<a name="ln373"> </a>
<a name="ln374">private:</a>
<a name="ln375">			struct {</a>
<a name="ln376">				BRowContainer* fRowSet;</a>
<a name="ln377">				int32 fIndex;</a>
<a name="ln378">				int32 fDepth;</a>
<a name="ln379">			}					fStack[kMaxDepth];</a>
<a name="ln380"> </a>
<a name="ln381">			int32				fStackIndex;</a>
<a name="ln382">			BRowContainer*		fCurrentList;</a>
<a name="ln383">			int32				fCurrentListIndex;</a>
<a name="ln384">			int32				fCurrentListDepth;</a>
<a name="ln385">			bool				fOpenBranchesOnly;</a>
<a name="ln386">};</a>
<a name="ln387"> </a>
<a name="ln388">}	// namespace BPrivate</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">using namespace BPrivate;</a>
<a name="ln392"> </a>
<a name="ln393"> </a>
<a name="ln394">BField::BField()</a>
<a name="ln395">{</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398"> </a>
<a name="ln399">BField::~BField()</a>
<a name="ln400">{</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403"> </a>
<a name="ln404">// #pragma mark -</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">void</a>
<a name="ln408">BColumn::MouseMoved(BColumnListView* /*parent*/, BRow* /*row*/,</a>
<a name="ln409">	BField* /*field*/, BRect /*field_rect*/, BPoint/*point*/,</a>
<a name="ln410">	uint32 /*buttons*/, int32 /*code*/)</a>
<a name="ln411">{</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">void</a>
<a name="ln416">BColumn::MouseDown(BColumnListView* /*parent*/, BRow* /*row*/,</a>
<a name="ln417">	BField* /*field*/, BRect /*field_rect*/, BPoint /*point*/,</a>
<a name="ln418">	uint32 /*buttons*/)</a>
<a name="ln419">{</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">void</a>
<a name="ln424">BColumn::MouseUp(BColumnListView* /*parent*/, BRow* /*row*/, BField* /*field*/)</a>
<a name="ln425">{</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428"> </a>
<a name="ln429">// #pragma mark -</a>
<a name="ln430"> </a>
<a name="ln431"> </a>
<a name="ln432">BRow::BRow()</a>
<a name="ln433">	:</a>
<a name="ln434">	fChildList(NULL),</a>
<a name="ln435">	fIsExpanded(false),</a>
<a name="ln436">	fHeight(std::max(kMinRowHeight,</a>
<a name="ln437">		ceilf(be_plain_font-&gt;Size() * kRowSpacing))),</a>
<a name="ln438">	fNextSelected(NULL),</a>
<a name="ln439">	fPrevSelected(NULL),</a>
<a name="ln440">	fParent(NULL),</a>
<a name="ln441">	fList(NULL)</a>
<a name="ln442">{</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445"> </a>
<a name="ln446">BRow::BRow(float height)</a>
<a name="ln447">	:</a>
<a name="ln448">	fChildList(NULL),</a>
<a name="ln449">	fIsExpanded(false),</a>
<a name="ln450">	fHeight(height),</a>
<a name="ln451">	fNextSelected(NULL),</a>
<a name="ln452">	fPrevSelected(NULL),</a>
<a name="ln453">	fParent(NULL),</a>
<a name="ln454">	fList(NULL)</a>
<a name="ln455">{</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459">BRow::~BRow()</a>
<a name="ln460">{</a>
<a name="ln461">	while (true) {</a>
<a name="ln462">		BField* field = (BField*) fFields.RemoveItem((int32)0);</a>
<a name="ln463">		if (field == 0)</a>
<a name="ln464">			break;</a>
<a name="ln465"> </a>
<a name="ln466">		delete field;</a>
<a name="ln467">	}</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">bool</a>
<a name="ln472">BRow::HasLatch() const</a>
<a name="ln473">{</a>
<a name="ln474">	return fChildList != 0;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477"> </a>
<a name="ln478">int32</a>
<a name="ln479">BRow::CountFields() const</a>
<a name="ln480">{</a>
<a name="ln481">	return fFields.CountItems();</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484"> </a>
<a name="ln485">BField*</a>
<a name="ln486">BRow::GetField(int32 index)</a>
<a name="ln487">{</a>
<a name="ln488">	return (BField*)fFields.ItemAt(index);</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491"> </a>
<a name="ln492">const BField*</a>
<a name="ln493">BRow::GetField(int32 index) const</a>
<a name="ln494">{</a>
<a name="ln495">	return (const BField*)fFields.ItemAt(index);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498"> </a>
<a name="ln499">void</a>
<a name="ln500">BRow::SetField(BField* field, int32 logicalFieldIndex)</a>
<a name="ln501">{</a>
<a name="ln502">	if (fFields.ItemAt(logicalFieldIndex) != 0)</a>
<a name="ln503">		delete (BField*)fFields.RemoveItem(logicalFieldIndex);</a>
<a name="ln504"> </a>
<a name="ln505">	if (NULL != fList) {</a>
<a name="ln506">		ValidateField(field, logicalFieldIndex);</a>
<a name="ln507">		Invalidate();</a>
<a name="ln508">	}</a>
<a name="ln509"> </a>
<a name="ln510">	fFields.AddItem(field, logicalFieldIndex);</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513"> </a>
<a name="ln514">float</a>
<a name="ln515">BRow::Height() const</a>
<a name="ln516">{</a>
<a name="ln517">	return fHeight;</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520"> </a>
<a name="ln521">bool</a>
<a name="ln522">BRow::IsExpanded() const</a>
<a name="ln523">{</a>
<a name="ln524">	return fIsExpanded;</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527"> </a>
<a name="ln528">bool</a>
<a name="ln529">BRow::IsSelected() const</a>
<a name="ln530">{</a>
<a name="ln531">	return fPrevSelected != NULL;</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534"> </a>
<a name="ln535">void</a>
<a name="ln536">BRow::Invalidate()</a>
<a name="ln537">{</a>
<a name="ln538">	if (fList != NULL)</a>
<a name="ln539">		fList-&gt;InvalidateRow(this);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">void</a>
<a name="ln544">BRow::ValidateFields() const</a>
<a name="ln545">{</a>
<a name="ln546">	for (int32 i = 0; i &lt; CountFields(); i++)</a>
<a name="ln547">		ValidateField(GetField(i), i);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551">void</a>
<a name="ln552">BRow::ValidateField(const BField* field, int32 logicalFieldIndex) const</a>
<a name="ln553">{</a>
<a name="ln554">	// The Fields may be moved by the user, but the logicalFieldIndexes</a>
<a name="ln555">	// do not change, so we need to map them over when checking the</a>
<a name="ln556">	// Field types.</a>
<a name="ln557">	BColumn* column = NULL;</a>
<a name="ln558">	int32 items = fList-&gt;CountColumns();</a>
<a name="ln559">	for (int32 i = 0 ; i &lt; items; ++i) {</a>
<a name="ln560">		column = fList-&gt;ColumnAt(i);</a>
<a name="ln561">		if(column-&gt;LogicalFieldNum() == logicalFieldIndex )</a>
<a name="ln562">			break;</a>
<a name="ln563">	}</a>
<a name="ln564"> </a>
<a name="ln565">	if (column == NULL) {</a>
<a name="ln566">		BString dbmessage(&quot;\n\n\tThe parent BColumnListView does not have &quot;</a>
<a name="ln567">			&quot;\n\ta BColumn at the logical field index &quot;);</a>
<a name="ln568">		dbmessage &lt;&lt; logicalFieldIndex &lt;&lt; &quot;.\n&quot;;</a>
<a name="ln569">		puts(dbmessage.String());</a>
<a name="ln570">	} else {</a>
<a name="ln571">		if (!column-&gt;AcceptsField(field)) {</a>
<a name="ln572">			BString dbmessage(&quot;\n\n\tThe BColumn of type &quot;);</a>
<a name="ln573">			dbmessage &lt;&lt; typeid(*column).name() &lt;&lt; &quot;\n\tat logical field index &quot;</a>
<a name="ln574">				&lt;&lt; logicalFieldIndex &lt;&lt; &quot;\n\tdoes not support the field type &quot;</a>
<a name="ln575">				&lt;&lt; typeid(*field).name() &lt;&lt; &quot;.\n\n&quot;;</a>
<a name="ln576">			debugger(dbmessage.String());</a>
<a name="ln577">		}</a>
<a name="ln578">	}</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">// #pragma mark -</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">BColumn::BColumn(float width, float minWidth, float maxWidth, alignment align)</a>
<a name="ln586">	:</a>
<a name="ln587">	fWidth(width),</a>
<a name="ln588">	fMinWidth(minWidth),</a>
<a name="ln589">	fMaxWidth(maxWidth),</a>
<a name="ln590">	fVisible(true),</a>
<a name="ln591">	fList(0),</a>
<a name="ln592">	fShowHeading(true),</a>
<a name="ln593">	fAlignment(align)</a>
<a name="ln594">{</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597"> </a>
<a name="ln598">BColumn::~BColumn()</a>
<a name="ln599">{</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602"> </a>
<a name="ln603">float</a>
<a name="ln604">BColumn::Width() const</a>
<a name="ln605">{</a>
<a name="ln606">	return fWidth;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">void</a>
<a name="ln611">BColumn::SetWidth(float width)</a>
<a name="ln612">{</a>
<a name="ln613">	fWidth = width;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616"> </a>
<a name="ln617">float</a>
<a name="ln618">BColumn::MinWidth() const</a>
<a name="ln619">{</a>
<a name="ln620">	return fMinWidth;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623"> </a>
<a name="ln624">float</a>
<a name="ln625">BColumn::MaxWidth() const</a>
<a name="ln626">{</a>
<a name="ln627">	return fMaxWidth;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">void</a>
<a name="ln632">BColumn::DrawTitle(BRect, BView*)</a>
<a name="ln633">{</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636"> </a>
<a name="ln637">void</a>
<a name="ln638">BColumn::DrawField(BField*, BRect, BView*)</a>
<a name="ln639">{</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642"> </a>
<a name="ln643">int</a>
<a name="ln644">BColumn::CompareFields(BField*, BField*)</a>
<a name="ln645">{</a>
<a name="ln646">	return 0;</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649"> </a>
<a name="ln650">void</a>
<a name="ln651">BColumn::GetColumnName(BString* into) const</a>
<a name="ln652">{</a>
<a name="ln653">	*into = &quot;(Unnamed)&quot;;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656"> </a>
<a name="ln657">float</a>
<a name="ln658">BColumn::GetPreferredWidth(BField* field, BView* parent) const</a>
<a name="ln659">{</a>
<a name="ln660">	return fWidth;</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663"> </a>
<a name="ln664">bool</a>
<a name="ln665">BColumn::IsVisible() const</a>
<a name="ln666">{</a>
<a name="ln667">	return fVisible;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671">void</a>
<a name="ln672">BColumn::SetVisible(bool visible)</a>
<a name="ln673">{</a>
<a name="ln674">	if (fList &amp;&amp; (fVisible != visible))</a>
<a name="ln675">		fList-&gt;SetColumnVisible(this, visible);</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678"> </a>
<a name="ln679">bool</a>
<a name="ln680">BColumn::ShowHeading() const</a>
<a name="ln681">{</a>
<a name="ln682">	return fShowHeading;</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">void</a>
<a name="ln687">BColumn::SetShowHeading(bool state)</a>
<a name="ln688">{</a>
<a name="ln689">	fShowHeading = state;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">alignment</a>
<a name="ln694">BColumn::Alignment() const</a>
<a name="ln695">{</a>
<a name="ln696">	return fAlignment;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699"> </a>
<a name="ln700">void</a>
<a name="ln701">BColumn::SetAlignment(alignment align)</a>
<a name="ln702">{</a>
<a name="ln703">	fAlignment = align;</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706"> </a>
<a name="ln707">bool</a>
<a name="ln708">BColumn::WantsEvents() const</a>
<a name="ln709">{</a>
<a name="ln710">	return fWantsEvents;</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">void</a>
<a name="ln715">BColumn::SetWantsEvents(bool state)</a>
<a name="ln716">{</a>
<a name="ln717">	fWantsEvents = state;</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720"> </a>
<a name="ln721">int32</a>
<a name="ln722">BColumn::LogicalFieldNum() const</a>
<a name="ln723">{</a>
<a name="ln724">	return fFieldID;</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727"> </a>
<a name="ln728">bool</a>
<a name="ln729">BColumn::AcceptsField(const BField*) const</a>
<a name="ln730">{</a>
<a name="ln731">	return true;</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734"> </a>
<a name="ln735">// #pragma mark -</a>
<a name="ln736"> </a>
<a name="ln737"> </a>
<a name="ln738">BColumnListView::BColumnListView(BRect rect, const char* name,</a>
<a name="ln739">	uint32 resizingMode, uint32 flags, border_style border,</a>
<a name="ln740">	bool showHorizontalScrollbar)</a>
<a name="ln741">	:</a>
<a name="ln742">	BView(rect, name, resizingMode,</a>
<a name="ln743">		flags | B_WILL_DRAW | B_FRAME_EVENTS | B_FULL_UPDATE_ON_RESIZE),</a>
<a name="ln744">	fStatusView(NULL),</a>
<a name="ln745">	fSelectionMessage(NULL),</a>
<a name="ln746">	fSortingEnabled(true),</a>
<a name="ln747">	fLatchWidth(kLatchWidth),</a>
<a name="ln748">	fBorderStyle(border),</a>
<a name="ln749">	fShowingHorizontalScrollBar(showHorizontalScrollbar)</a>
<a name="ln750">{</a>
<a name="ln751">	_Init();</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">BColumnListView::BColumnListView(const char* name, uint32 flags,</a>
<a name="ln756">	border_style border, bool showHorizontalScrollbar)</a>
<a name="ln757">	:</a>
<a name="ln758">	BView(name, flags | B_WILL_DRAW | B_FRAME_EVENTS | B_FULL_UPDATE_ON_RESIZE),</a>
<a name="ln759">	fStatusView(NULL),</a>
<a name="ln760">	fSelectionMessage(NULL),</a>
<a name="ln761">	fSortingEnabled(true),</a>
<a name="ln762">	fLatchWidth(kLatchWidth),</a>
<a name="ln763">	fBorderStyle(border),</a>
<a name="ln764">	fShowingHorizontalScrollBar(showHorizontalScrollbar)</a>
<a name="ln765">{</a>
<a name="ln766">	_Init();</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">BColumnListView::~BColumnListView()</a>
<a name="ln771">{</a>
<a name="ln772">	while (BColumn* column = (BColumn*)fColumns.RemoveItem((int32)0))</a>
<a name="ln773">		delete column;</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777">bool</a>
<a name="ln778">BColumnListView::InitiateDrag(BPoint, bool)</a>
<a name="ln779">{</a>
<a name="ln780">	return false;</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784">void</a>
<a name="ln785">BColumnListView::MessageDropped(BMessage*, BPoint)</a>
<a name="ln786">{</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789"> </a>
<a name="ln790">void</a>
<a name="ln791">BColumnListView::ExpandOrCollapse(BRow* row, bool Open)</a>
<a name="ln792">{</a>
<a name="ln793">	fOutlineView-&gt;ExpandOrCollapse(row, Open);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796"> </a>
<a name="ln797">status_t</a>
<a name="ln798">BColumnListView::Invoke(BMessage* message)</a>
<a name="ln799">{</a>
<a name="ln800">	if (message == 0)</a>
<a name="ln801">		message = Message();</a>
<a name="ln802"> </a>
<a name="ln803">	return BInvoker::Invoke(message);</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806"> </a>
<a name="ln807">void</a>
<a name="ln808">BColumnListView::ItemInvoked()</a>
<a name="ln809">{</a>
<a name="ln810">	Invoke();</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">void</a>
<a name="ln815">BColumnListView::SetInvocationMessage(BMessage* message)</a>
<a name="ln816">{</a>
<a name="ln817">	SetMessage(message);</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820"> </a>
<a name="ln821">BMessage*</a>
<a name="ln822">BColumnListView::InvocationMessage() const</a>
<a name="ln823">{</a>
<a name="ln824">	return Message();</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827"> </a>
<a name="ln828">uint32</a>
<a name="ln829">BColumnListView::InvocationCommand() const</a>
<a name="ln830">{</a>
<a name="ln831">	return Command();</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834"> </a>
<a name="ln835">BRow*</a>
<a name="ln836">BColumnListView::FocusRow() const</a>
<a name="ln837">{</a>
<a name="ln838">	return fOutlineView-&gt;FocusRow();</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841"> </a>
<a name="ln842">void</a>
<a name="ln843">BColumnListView::SetFocusRow(int32 Index, bool Select)</a>
<a name="ln844">{</a>
<a name="ln845">	SetFocusRow(RowAt(Index), Select);</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848"> </a>
<a name="ln849">void</a>
<a name="ln850">BColumnListView::SetFocusRow(BRow* row, bool Select)</a>
<a name="ln851">{</a>
<a name="ln852">	fOutlineView-&gt;SetFocusRow(row, Select);</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855"> </a>
<a name="ln856">void</a>
<a name="ln857">BColumnListView::SetMouseTrackingEnabled(bool Enabled)</a>
<a name="ln858">{</a>
<a name="ln859">	fOutlineView-&gt;SetMouseTrackingEnabled(Enabled);</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862"> </a>
<a name="ln863">list_view_type</a>
<a name="ln864">BColumnListView::SelectionMode() const</a>
<a name="ln865">{</a>
<a name="ln866">	return fOutlineView-&gt;SelectionMode();</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869"> </a>
<a name="ln870">void</a>
<a name="ln871">BColumnListView::Deselect(BRow* row)</a>
<a name="ln872">{</a>
<a name="ln873">	fOutlineView-&gt;Deselect(row);</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876"> </a>
<a name="ln877">void</a>
<a name="ln878">BColumnListView::AddToSelection(BRow* row)</a>
<a name="ln879">{</a>
<a name="ln880">	fOutlineView-&gt;AddToSelection(row);</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883"> </a>
<a name="ln884">void</a>
<a name="ln885">BColumnListView::DeselectAll()</a>
<a name="ln886">{</a>
<a name="ln887">	fOutlineView-&gt;DeselectAll();</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890"> </a>
<a name="ln891">BRow*</a>
<a name="ln892">BColumnListView::CurrentSelection(BRow* lastSelected) const</a>
<a name="ln893">{</a>
<a name="ln894">	return fOutlineView-&gt;CurrentSelection(lastSelected);</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897"> </a>
<a name="ln898">void</a>
<a name="ln899">BColumnListView::SelectionChanged()</a>
<a name="ln900">{</a>
<a name="ln901">	if (fSelectionMessage)</a>
<a name="ln902">		Invoke(fSelectionMessage);</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905"> </a>
<a name="ln906">void</a>
<a name="ln907">BColumnListView::SetSelectionMessage(BMessage* message)</a>
<a name="ln908">{</a>
<a name="ln909">	if (fSelectionMessage == message)</a>
<a name="ln910">		return;</a>
<a name="ln911"> </a>
<a name="ln912">	delete fSelectionMessage;</a>
<a name="ln913">	fSelectionMessage = message;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">BMessage*</a>
<a name="ln918">BColumnListView::SelectionMessage()</a>
<a name="ln919">{</a>
<a name="ln920">	return fSelectionMessage;</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923"> </a>
<a name="ln924">uint32</a>
<a name="ln925">BColumnListView::SelectionCommand() const</a>
<a name="ln926">{</a>
<a name="ln927">	if (fSelectionMessage)</a>
<a name="ln928">		return fSelectionMessage-&gt;what;</a>
<a name="ln929"> </a>
<a name="ln930">	return 0;</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933"> </a>
<a name="ln934">void</a>
<a name="ln935">BColumnListView::SetSelectionMode(list_view_type mode)</a>
<a name="ln936">{</a>
<a name="ln937">	fOutlineView-&gt;SetSelectionMode(mode);</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940"> </a>
<a name="ln941">void</a>
<a name="ln942">BColumnListView::SetSortingEnabled(bool enabled)</a>
<a name="ln943">{</a>
<a name="ln944">	fSortingEnabled = enabled;</a>
<a name="ln945">	fSortColumns.MakeEmpty();</a>
<a name="ln946">	fTitleView-&gt;Invalidate();</a>
<a name="ln947">		// erase sort indicators</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950"> </a>
<a name="ln951">bool</a>
<a name="ln952">BColumnListView::SortingEnabled() const</a>
<a name="ln953">{</a>
<a name="ln954">	return fSortingEnabled;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957"> </a>
<a name="ln958">void</a>
<a name="ln959">BColumnListView::SetSortColumn(BColumn* column, bool add, bool ascending)</a>
<a name="ln960">{</a>
<a name="ln961">	if (!SortingEnabled())</a>
<a name="ln962">		return;</a>
<a name="ln963"> </a>
<a name="ln964">	if (!add)</a>
<a name="ln965">		fSortColumns.MakeEmpty();</a>
<a name="ln966"> </a>
<a name="ln967">	if (!fSortColumns.HasItem(column))</a>
<a name="ln968">		fSortColumns.AddItem(column);</a>
<a name="ln969"> </a>
<a name="ln970">	column-&gt;fSortAscending = ascending;</a>
<a name="ln971">	fTitleView-&gt;Invalidate();</a>
<a name="ln972">	fOutlineView-&gt;StartSorting();</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975"> </a>
<a name="ln976">void</a>
<a name="ln977">BColumnListView::ClearSortColumns()</a>
<a name="ln978">{</a>
<a name="ln979">	fSortColumns.MakeEmpty();</a>
<a name="ln980">	fTitleView-&gt;Invalidate();</a>
<a name="ln981">		// erase sort indicators</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984"> </a>
<a name="ln985">void</a>
<a name="ln986">BColumnListView::AddStatusView(BView* view)</a>
<a name="ln987">{</a>
<a name="ln988">	BRect bounds = Bounds();</a>
<a name="ln989">	float width = view-&gt;Bounds().Width();</a>
<a name="ln990">	if (width &gt; bounds.Width() / 2)</a>
<a name="ln991">		width = bounds.Width() / 2;</a>
<a name="ln992"> </a>
<a name="ln993">	fStatusView = view;</a>
<a name="ln994"> </a>
<a name="ln995">	Window()-&gt;BeginViewTransaction();</a>
<a name="ln996">	fHorizontalScrollBar-&gt;ResizeBy(-(width + 1), 0);</a>
<a name="ln997">	fHorizontalScrollBar-&gt;MoveBy((width + 1), 0);</a>
<a name="ln998">	AddChild(view);</a>
<a name="ln999"> </a>
<a name="ln1000">	BRect viewRect(bounds);</a>
<a name="ln1001">	viewRect.right = width;</a>
<a name="ln1002">	viewRect.top = viewRect.bottom - B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln1003">	if (fBorderStyle == B_PLAIN_BORDER)</a>
<a name="ln1004">		viewRect.OffsetBy(1, -1);</a>
<a name="ln1005">	else if (fBorderStyle == B_FANCY_BORDER)</a>
<a name="ln1006">		viewRect.OffsetBy(2, -2);</a>
<a name="ln1007"> </a>
<a name="ln1008">	view-&gt;SetResizingMode(B_FOLLOW_LEFT | B_FOLLOW_BOTTOM);</a>
<a name="ln1009">	view-&gt;ResizeTo(viewRect.Width(), viewRect.Height());</a>
<a name="ln1010">	view-&gt;MoveTo(viewRect.left, viewRect.top);</a>
<a name="ln1011">	Window()-&gt;EndViewTransaction();</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014"> </a>
<a name="ln1015">BView*</a>
<a name="ln1016">BColumnListView::RemoveStatusView()</a>
<a name="ln1017">{</a>
<a name="ln1018">	if (fStatusView) {</a>
<a name="ln1019">		float width = fStatusView-&gt;Bounds().Width();</a>
<a name="ln1020">		Window()-&gt;BeginViewTransaction();</a>
<a name="ln1021">		fStatusView-&gt;RemoveSelf();</a>
<a name="ln1022">		fHorizontalScrollBar-&gt;MoveBy(-width, 0);</a>
<a name="ln1023">		fHorizontalScrollBar-&gt;ResizeBy(width, 0);</a>
<a name="ln1024">		Window()-&gt;EndViewTransaction();</a>
<a name="ln1025">	}</a>
<a name="ln1026"> </a>
<a name="ln1027">	BView* view = fStatusView;</a>
<a name="ln1028">	fStatusView = 0;</a>
<a name="ln1029">	return view;</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032"> </a>
<a name="ln1033">void</a>
<a name="ln1034">BColumnListView::AddColumn(BColumn* column, int32 logicalFieldIndex)</a>
<a name="ln1035">{</a>
<a name="ln1036">	ASSERT(column != NULL);</a>
<a name="ln1037"> </a>
<a name="ln1038">	column-&gt;fList = this;</a>
<a name="ln1039">	column-&gt;fFieldID = logicalFieldIndex;</a>
<a name="ln1040"> </a>
<a name="ln1041">	// sanity check -- if there is already a field with this ID, remove it.</a>
<a name="ln1042">	for (int32 index = 0; index &lt; fColumns.CountItems(); index++) {</a>
<a name="ln1043">		BColumn* existingColumn = (BColumn*) fColumns.ItemAt(index);</a>
<a name="ln1044">		if (existingColumn &amp;&amp; existingColumn-&gt;fFieldID == logicalFieldIndex) {</a>
<a name="ln1045">			RemoveColumn(existingColumn);</a>
<a name="ln1046">			break;</a>
<a name="ln1047">		}</a>
<a name="ln1048">	}</a>
<a name="ln1049"> </a>
<a name="ln1050">	if (column-&gt;Width() &lt; column-&gt;MinWidth())</a>
<a name="ln1051">		column-&gt;SetWidth(column-&gt;MinWidth());</a>
<a name="ln1052">	else if (column-&gt;Width() &gt; column-&gt;MaxWidth())</a>
<a name="ln1053">		column-&gt;SetWidth(column-&gt;MaxWidth());</a>
<a name="ln1054"> </a>
<a name="ln1055">	fColumns.AddItem((void*) column);</a>
<a name="ln1056">	fTitleView-&gt;ColumnAdded(column);</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059"> </a>
<a name="ln1060">void</a>
<a name="ln1061">BColumnListView::MoveColumn(BColumn* column, int32 index)</a>
<a name="ln1062">{</a>
<a name="ln1063">	ASSERT(column != NULL);</a>
<a name="ln1064">	fTitleView-&gt;MoveColumn(column, index);</a>
<a name="ln1065">}</a>
<a name="ln1066"> </a>
<a name="ln1067"> </a>
<a name="ln1068">void</a>
<a name="ln1069">BColumnListView::RemoveColumn(BColumn* column)</a>
<a name="ln1070">{</a>
<a name="ln1071">	if (fColumns.HasItem(column)) {</a>
<a name="ln1072">		SetColumnVisible(column, false);</a>
<a name="ln1073">		if (Window() != NULL)</a>
<a name="ln1074">			Window()-&gt;UpdateIfNeeded();</a>
<a name="ln1075">		fColumns.RemoveItem(column);</a>
<a name="ln1076">	}</a>
<a name="ln1077">}</a>
<a name="ln1078"> </a>
<a name="ln1079"> </a>
<a name="ln1080">int32</a>
<a name="ln1081">BColumnListView::CountColumns() const</a>
<a name="ln1082">{</a>
<a name="ln1083">	return fColumns.CountItems();</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086"> </a>
<a name="ln1087">BColumn*</a>
<a name="ln1088">BColumnListView::ColumnAt(int32 field) const</a>
<a name="ln1089">{</a>
<a name="ln1090">	return (BColumn*) fColumns.ItemAt(field);</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093"> </a>
<a name="ln1094">BColumn*</a>
<a name="ln1095">BColumnListView::ColumnAt(BPoint point) const</a>
<a name="ln1096">{</a>
<a name="ln1097">	float left = MAX(kLeftMargin, LatchWidth());</a>
<a name="ln1098"> </a>
<a name="ln1099">	for (int i = 0; BColumn* column = (BColumn*)fColumns.ItemAt(i); i++) {</a>
<a name="ln1100">		if (column == NULL || !column-&gt;IsVisible())</a>
<a name="ln1101">			continue;</a>
<a name="ln1102"> </a>
<a name="ln1103">		float right = left + column-&gt;Width();</a>
<a name="ln1104">		if (point.x &gt;= left &amp;&amp; point.x &lt;= right)</a>
<a name="ln1105">			return column;</a>
<a name="ln1106"> </a>
<a name="ln1107">		left = right + 1;</a>
<a name="ln1108">	}</a>
<a name="ln1109"> </a>
<a name="ln1110">	return NULL;</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113"> </a>
<a name="ln1114">void</a>
<a name="ln1115">BColumnListView::SetColumnVisible(BColumn* column, bool visible)</a>
<a name="ln1116">{</a>
<a name="ln1117">	fTitleView-&gt;SetColumnVisible(column, visible);</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120"> </a>
<a name="ln1121">void</a>
<a name="ln1122">BColumnListView::SetColumnVisible(int32 index, bool isVisible)</a>
<a name="ln1123">{</a>
<a name="ln1124">	BColumn* column = ColumnAt(index);</a>
<a name="ln1125">	if (column != NULL)</a>
<a name="ln1126">		column-&gt;SetVisible(isVisible);</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129"> </a>
<a name="ln1130">bool</a>
<a name="ln1131">BColumnListView::IsColumnVisible(int32 index) const</a>
<a name="ln1132">{</a>
<a name="ln1133">	BColumn* column = ColumnAt(index);</a>
<a name="ln1134">	if (column != NULL)</a>
<a name="ln1135">		return column-&gt;IsVisible();</a>
<a name="ln1136"> </a>
<a name="ln1137">	return false;</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140"> </a>
<a name="ln1141">void</a>
<a name="ln1142">BColumnListView::SetColumnFlags(column_flags flags)</a>
<a name="ln1143">{</a>
<a name="ln1144">	fTitleView-&gt;SetColumnFlags(flags);</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147"> </a>
<a name="ln1148">void</a>
<a name="ln1149">BColumnListView::ResizeColumnToPreferred(int32 index)</a>
<a name="ln1150">{</a>
<a name="ln1151">	BColumn* column = ColumnAt(index);</a>
<a name="ln1152">	if (column == NULL)</a>
<a name="ln1153">		return;</a>
<a name="ln1154"> </a>
<a name="ln1155">	// get the preferred column width</a>
<a name="ln1156">	float width = fOutlineView-&gt;GetColumnPreferredWidth(column);</a>
<a name="ln1157"> </a>
<a name="ln1158">	// set it</a>
<a name="ln1159">	float oldWidth = column-&gt;Width();</a>
<a name="ln1160">	column-&gt;SetWidth(width);</a>
<a name="ln1161"> </a>
<a name="ln1162">	fTitleView-&gt;ColumnResized(column, oldWidth);</a>
<a name="ln1163">	fOutlineView-&gt;Invalidate();</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166"> </a>
<a name="ln1167">void</a>
<a name="ln1168">BColumnListView::ResizeAllColumnsToPreferred()</a>
<a name="ln1169">{</a>
<a name="ln1170">	int32 count = CountColumns();</a>
<a name="ln1171">	for (int32 i = 0; i &lt; count; i++)</a>
<a name="ln1172">		ResizeColumnToPreferred(i);</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176">const BRow*</a>
<a name="ln1177">BColumnListView::RowAt(int32 Index, BRow* parentRow) const</a>
<a name="ln1178">{</a>
<a name="ln1179">	if (parentRow == 0)</a>
<a name="ln1180">		return fOutlineView-&gt;RowList()-&gt;ItemAt(Index);</a>
<a name="ln1181"> </a>
<a name="ln1182">	return parentRow-&gt;fChildList ? parentRow-&gt;fChildList-&gt;ItemAt(Index) : NULL;</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185"> </a>
<a name="ln1186">BRow*</a>
<a name="ln1187">BColumnListView::RowAt(int32 Index, BRow* parentRow)</a>
<a name="ln1188">{</a>
<a name="ln1189">	if (parentRow == 0)</a>
<a name="ln1190">		return fOutlineView-&gt;RowList()-&gt;ItemAt(Index);</a>
<a name="ln1191"> </a>
<a name="ln1192">	return parentRow-&gt;fChildList ? parentRow-&gt;fChildList-&gt;ItemAt(Index) : 0;</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195"> </a>
<a name="ln1196">const BRow*</a>
<a name="ln1197">BColumnListView::RowAt(BPoint point) const</a>
<a name="ln1198">{</a>
<a name="ln1199">	float top;</a>
<a name="ln1200">	int32 indent;</a>
<a name="ln1201">	return fOutlineView-&gt;FindRow(point.y, &amp;indent, &amp;top);</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204"> </a>
<a name="ln1205">BRow*</a>
<a name="ln1206">BColumnListView::RowAt(BPoint point)</a>
<a name="ln1207">{</a>
<a name="ln1208">	float top;</a>
<a name="ln1209">	int32 indent;</a>
<a name="ln1210">	return fOutlineView-&gt;FindRow(point.y, &amp;indent, &amp;top);</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213"> </a>
<a name="ln1214">bool</a>
<a name="ln1215">BColumnListView::GetRowRect(const BRow* row, BRect* outRect) const</a>
<a name="ln1216">{</a>
<a name="ln1217">	return fOutlineView-&gt;FindRect(row, outRect);</a>
<a name="ln1218">}</a>
<a name="ln1219"> </a>
<a name="ln1220"> </a>
<a name="ln1221">bool</a>
<a name="ln1222">BColumnListView::FindParent(BRow* row, BRow** _parent, bool* _isVisible) const</a>
<a name="ln1223">{</a>
<a name="ln1224">	return fOutlineView-&gt;FindParent(row, _parent, _isVisible);</a>
<a name="ln1225">}</a>
<a name="ln1226"> </a>
<a name="ln1227"> </a>
<a name="ln1228">int32</a>
<a name="ln1229">BColumnListView::IndexOf(BRow* row)</a>
<a name="ln1230">{</a>
<a name="ln1231">	return fOutlineView-&gt;IndexOf(row);</a>
<a name="ln1232">}</a>
<a name="ln1233"> </a>
<a name="ln1234"> </a>
<a name="ln1235">int32</a>
<a name="ln1236">BColumnListView::CountRows(BRow* parentRow) const</a>
<a name="ln1237">{</a>
<a name="ln1238">	if (parentRow == 0)</a>
<a name="ln1239">		return fOutlineView-&gt;RowList()-&gt;CountItems();</a>
<a name="ln1240">	if (parentRow-&gt;fChildList)</a>
<a name="ln1241">		return parentRow-&gt;fChildList-&gt;CountItems();</a>
<a name="ln1242">	else</a>
<a name="ln1243">		return 0;</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246"> </a>
<a name="ln1247">void</a>
<a name="ln1248">BColumnListView::AddRow(BRow* row, BRow* parentRow)</a>
<a name="ln1249">{</a>
<a name="ln1250">	AddRow(row, -1, parentRow);</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253"> </a>
<a name="ln1254">void</a>
<a name="ln1255">BColumnListView::AddRow(BRow* row, int32 index, BRow* parentRow)</a>
<a name="ln1256">{</a>
<a name="ln1257">	row-&gt;fChildList = 0;</a>
<a name="ln1258">	row-&gt;fList = this;</a>
<a name="ln1259">	row-&gt;ValidateFields();</a>
<a name="ln1260">	fOutlineView-&gt;AddRow(row, index, parentRow);</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263"> </a>
<a name="ln1264">void</a>
<a name="ln1265">BColumnListView::RemoveRow(BRow* row)</a>
<a name="ln1266">{</a>
<a name="ln1267">	fOutlineView-&gt;RemoveRow(row);</a>
<a name="ln1268">	row-&gt;fList = NULL;</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271"> </a>
<a name="ln1272">void</a>
<a name="ln1273">BColumnListView::UpdateRow(BRow* row)</a>
<a name="ln1274">{</a>
<a name="ln1275">	fOutlineView-&gt;UpdateRow(row);</a>
<a name="ln1276">}</a>
<a name="ln1277"> </a>
<a name="ln1278"> </a>
<a name="ln1279">bool</a>
<a name="ln1280">BColumnListView::SwapRows(int32 index1, int32 index2, BRow* parentRow1,</a>
<a name="ln1281">	BRow* parentRow2)</a>
<a name="ln1282">{</a>
<a name="ln1283">	BRow* row1 = NULL;</a>
<a name="ln1284">	BRow* row2 = NULL;</a>
<a name="ln1285"> </a>
<a name="ln1286">	BRowContainer* container1 = NULL;</a>
<a name="ln1287">	BRowContainer* container2 = NULL;</a>
<a name="ln1288"> </a>
<a name="ln1289">	if (parentRow1 == NULL)</a>
<a name="ln1290">		container1 = fOutlineView-&gt;RowList();</a>
<a name="ln1291">	else</a>
<a name="ln1292">		container1 = parentRow1-&gt;fChildList;</a>
<a name="ln1293"> </a>
<a name="ln1294">	if (container1 == NULL)</a>
<a name="ln1295">		return false;</a>
<a name="ln1296"> </a>
<a name="ln1297">	if (parentRow2 == NULL)</a>
<a name="ln1298">		container2 = fOutlineView-&gt;RowList();</a>
<a name="ln1299">	else</a>
<a name="ln1300">		container2 = parentRow2-&gt;fChildList;</a>
<a name="ln1301"> </a>
<a name="ln1302">	if (container2 == NULL)</a>
<a name="ln1303">		return false;</a>
<a name="ln1304"> </a>
<a name="ln1305">	row1 = container1-&gt;ItemAt(index1);</a>
<a name="ln1306"> </a>
<a name="ln1307">	if (row1 == NULL)</a>
<a name="ln1308">		return false;</a>
<a name="ln1309"> </a>
<a name="ln1310">	row2 = container2-&gt;ItemAt(index2);</a>
<a name="ln1311"> </a>
<a name="ln1312">	if (row2 == NULL)</a>
<a name="ln1313">		return false;</a>
<a name="ln1314"> </a>
<a name="ln1315">	container1-&gt;ReplaceItem(index2, row1);</a>
<a name="ln1316">	container2-&gt;ReplaceItem(index1, row2);</a>
<a name="ln1317"> </a>
<a name="ln1318">	BRect rect1;</a>
<a name="ln1319">	BRect rect2;</a>
<a name="ln1320">	BRect rect;</a>
<a name="ln1321"> </a>
<a name="ln1322">	fOutlineView-&gt;FindRect(row1, &amp;rect1);</a>
<a name="ln1323">	fOutlineView-&gt;FindRect(row2, &amp;rect2);</a>
<a name="ln1324"> </a>
<a name="ln1325">	rect = rect1 | rect2;</a>
<a name="ln1326"> </a>
<a name="ln1327">	fOutlineView-&gt;Invalidate(rect);</a>
<a name="ln1328"> </a>
<a name="ln1329">	return true;</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332"> </a>
<a name="ln1333">void</a>
<a name="ln1334">BColumnListView::ScrollTo(const BRow* row)</a>
<a name="ln1335">{</a>
<a name="ln1336">	fOutlineView-&gt;ScrollTo(row);</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339"> </a>
<a name="ln1340">void</a>
<a name="ln1341">BColumnListView::ScrollTo(BPoint point)</a>
<a name="ln1342">{</a>
<a name="ln1343">	fOutlineView-&gt;ScrollTo(point);</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346"> </a>
<a name="ln1347">void</a>
<a name="ln1348">BColumnListView::Clear()</a>
<a name="ln1349">{</a>
<a name="ln1350">	fOutlineView-&gt;Clear();</a>
<a name="ln1351">}</a>
<a name="ln1352"> </a>
<a name="ln1353"> </a>
<a name="ln1354">void</a>
<a name="ln1355">BColumnListView::InvalidateRow(BRow* row)</a>
<a name="ln1356">{</a>
<a name="ln1357">	BRect updateRect;</a>
<a name="ln1358">	GetRowRect(row, &amp;updateRect);</a>
<a name="ln1359">	fOutlineView-&gt;Invalidate(updateRect);</a>
<a name="ln1360">}</a>
<a name="ln1361"> </a>
<a name="ln1362"> </a>
<a name="ln1363">// This method is deprecated.</a>
<a name="ln1364">void</a>
<a name="ln1365">BColumnListView::SetFont(const BFont* font, uint32 mask)</a>
<a name="ln1366">{</a>
<a name="ln1367">	fOutlineView-&gt;SetFont(font, mask);</a>
<a name="ln1368">	fTitleView-&gt;SetFont(font, mask);</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371"> </a>
<a name="ln1372">void</a>
<a name="ln1373">BColumnListView::SetFont(ColumnListViewFont font_num, const BFont* font,</a>
<a name="ln1374">	uint32 mask)</a>
<a name="ln1375">{</a>
<a name="ln1376">	switch (font_num) {</a>
<a name="ln1377">		case B_FONT_ROW:</a>
<a name="ln1378">			fOutlineView-&gt;SetFont(font, mask);</a>
<a name="ln1379">			break;</a>
<a name="ln1380"> </a>
<a name="ln1381">		case B_FONT_HEADER:</a>
<a name="ln1382">			fTitleView-&gt;SetFont(font, mask);</a>
<a name="ln1383">			break;</a>
<a name="ln1384"> </a>
<a name="ln1385">		default:</a>
<a name="ln1386">			ASSERT(false);</a>
<a name="ln1387">			break;</a>
<a name="ln1388">	}</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391"> </a>
<a name="ln1392">void</a>
<a name="ln1393">BColumnListView::GetFont(ColumnListViewFont font_num, BFont* font) const</a>
<a name="ln1394">{</a>
<a name="ln1395">	switch (font_num) {</a>
<a name="ln1396">		case B_FONT_ROW:</a>
<a name="ln1397">			fOutlineView-&gt;GetFont(font);</a>
<a name="ln1398">			break;</a>
<a name="ln1399"> </a>
<a name="ln1400">		case B_FONT_HEADER:</a>
<a name="ln1401">			fTitleView-&gt;GetFont(font);</a>
<a name="ln1402">			break;</a>
<a name="ln1403"> </a>
<a name="ln1404">		default:</a>
<a name="ln1405">			ASSERT(false);</a>
<a name="ln1406">			break;</a>
<a name="ln1407">	}</a>
<a name="ln1408">}</a>
<a name="ln1409"> </a>
<a name="ln1410"> </a>
<a name="ln1411">void</a>
<a name="ln1412">BColumnListView::SetColor(ColumnListViewColor colorIndex, const rgb_color color)</a>
<a name="ln1413">{</a>
<a name="ln1414">	if ((int)colorIndex &lt; 0) {</a>
<a name="ln1415">		ASSERT(false);</a>
<a name="ln1416">		colorIndex = (ColumnListViewColor)0;</a>
<a name="ln1417">	}</a>
<a name="ln1418"> </a>
<a name="ln1419">	if ((int)colorIndex &gt;= (int)B_COLOR_TOTAL) {</a>
<a name="ln1420">		ASSERT(false);</a>
<a name="ln1421">		colorIndex = (ColumnListViewColor)(B_COLOR_TOTAL - 1);</a>
<a name="ln1422">	}</a>
<a name="ln1423"> </a>
<a name="ln1424">	fColorList[colorIndex] = color;</a>
<a name="ln1425">	fCustomColors = true;</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428"> </a>
<a name="ln1429">void</a>
<a name="ln1430">BColumnListView::ResetColors()</a>
<a name="ln1431">{</a>
<a name="ln1432">	fCustomColors = false;</a>
<a name="ln1433">	_UpdateColors();</a>
<a name="ln1434">	Invalidate();</a>
<a name="ln1435">}</a>
<a name="ln1436"> </a>
<a name="ln1437"> </a>
<a name="ln1438">rgb_color</a>
<a name="ln1439">BColumnListView::Color(ColumnListViewColor colorIndex) const</a>
<a name="ln1440">{</a>
<a name="ln1441">	if ((int)colorIndex &lt; 0) {</a>
<a name="ln1442">		ASSERT(false);</a>
<a name="ln1443">		colorIndex = (ColumnListViewColor)0;</a>
<a name="ln1444">	}</a>
<a name="ln1445"> </a>
<a name="ln1446">	if ((int)colorIndex &gt;= (int)B_COLOR_TOTAL) {</a>
<a name="ln1447">		ASSERT(false);</a>
<a name="ln1448">		colorIndex = (ColumnListViewColor)(B_COLOR_TOTAL - 1);</a>
<a name="ln1449">	}</a>
<a name="ln1450"> </a>
<a name="ln1451">	return fColorList[colorIndex];</a>
<a name="ln1452">}</a>
<a name="ln1453"> </a>
<a name="ln1454"> </a>
<a name="ln1455">void</a>
<a name="ln1456">BColumnListView::SetHighColor(rgb_color color)</a>
<a name="ln1457">{</a>
<a name="ln1458">	BView::SetHighColor(color);</a>
<a name="ln1459">//	fOutlineView-&gt;Invalidate();</a>
<a name="ln1460">		// Redraw with the new color.</a>
<a name="ln1461">		// Note that this will currently cause an infinite loop, refreshing</a>
<a name="ln1462">		// over and over. A better solution is needed.</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465"> </a>
<a name="ln1466">void</a>
<a name="ln1467">BColumnListView::SetSelectionColor(rgb_color color)</a>
<a name="ln1468">{</a>
<a name="ln1469">	fColorList[B_COLOR_SELECTION] = color;</a>
<a name="ln1470">	fCustomColors = true;</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473"> </a>
<a name="ln1474">void</a>
<a name="ln1475">BColumnListView::SetBackgroundColor(rgb_color color)</a>
<a name="ln1476">{</a>
<a name="ln1477">	fColorList[B_COLOR_BACKGROUND] = color;</a>
<a name="ln1478">	fCustomColors = true;</a>
<a name="ln1479">	fOutlineView-&gt;Invalidate();</a>
<a name="ln1480">		// repaint with new color</a>
<a name="ln1481">}</a>
<a name="ln1482"> </a>
<a name="ln1483"> </a>
<a name="ln1484">void</a>
<a name="ln1485">BColumnListView::SetEditColor(rgb_color color)</a>
<a name="ln1486">{</a>
<a name="ln1487">	fColorList[B_COLOR_EDIT_BACKGROUND] = color;</a>
<a name="ln1488">	fCustomColors = true;</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491"> </a>
<a name="ln1492">const rgb_color</a>
<a name="ln1493">BColumnListView::SelectionColor() const</a>
<a name="ln1494">{</a>
<a name="ln1495">	return fColorList[B_COLOR_SELECTION];</a>
<a name="ln1496">}</a>
<a name="ln1497"> </a>
<a name="ln1498"> </a>
<a name="ln1499">const rgb_color</a>
<a name="ln1500">BColumnListView::BackgroundColor() const</a>
<a name="ln1501">{</a>
<a name="ln1502">	return fColorList[B_COLOR_BACKGROUND];</a>
<a name="ln1503">}</a>
<a name="ln1504"> </a>
<a name="ln1505"> </a>
<a name="ln1506">const rgb_color</a>
<a name="ln1507">BColumnListView::EditColor() const</a>
<a name="ln1508">{</a>
<a name="ln1509">	return fColorList[B_COLOR_EDIT_BACKGROUND];</a>
<a name="ln1510">}</a>
<a name="ln1511"> </a>
<a name="ln1512"> </a>
<a name="ln1513">BPoint</a>
<a name="ln1514">BColumnListView::SuggestTextPosition(const BRow* row,</a>
<a name="ln1515">	const BColumn* inColumn) const</a>
<a name="ln1516">{</a>
<a name="ln1517">	BRect rect(GetFieldRect(row, inColumn));</a>
<a name="ln1518"> </a>
<a name="ln1519">	font_height fh;</a>
<a name="ln1520">	fOutlineView-&gt;GetFontHeight(&amp;fh);</a>
<a name="ln1521">	float baseline = floor(rect.top + fh.ascent</a>
<a name="ln1522">		+ (rect.Height() + 1 - (fh.ascent + fh.descent)) / 2);</a>
<a name="ln1523">	return BPoint(rect.left + 8, baseline);</a>
<a name="ln1524">}</a>
<a name="ln1525"> </a>
<a name="ln1526"> </a>
<a name="ln1527">BRect</a>
<a name="ln1528">BColumnListView::GetFieldRect(const BRow* row, const BColumn* inColumn) const</a>
<a name="ln1529">{</a>
<a name="ln1530">	BRect rect;</a>
<a name="ln1531">	GetRowRect(row, &amp;rect);</a>
<a name="ln1532">	if (inColumn != NULL) {</a>
<a name="ln1533">		float leftEdge = MAX(kLeftMargin, LatchWidth());</a>
<a name="ln1534">		for (int index = 0; index &lt; fColumns.CountItems(); index++) {</a>
<a name="ln1535">			BColumn* column = (BColumn*) fColumns.ItemAt(index);</a>
<a name="ln1536">			if (column == NULL || !column-&gt;IsVisible())</a>
<a name="ln1537">				continue;</a>
<a name="ln1538"> </a>
<a name="ln1539">			if (column == inColumn) {</a>
<a name="ln1540">				rect.left = leftEdge;</a>
<a name="ln1541">				rect.right = rect.left + column-&gt;Width();</a>
<a name="ln1542">				break;</a>
<a name="ln1543">			}</a>
<a name="ln1544"> </a>
<a name="ln1545">			leftEdge += column-&gt;Width() + 1;</a>
<a name="ln1546">		}</a>
<a name="ln1547">	}</a>
<a name="ln1548"> </a>
<a name="ln1549">	return rect;</a>
<a name="ln1550">}</a>
<a name="ln1551"> </a>
<a name="ln1552"> </a>
<a name="ln1553">void</a>
<a name="ln1554">BColumnListView::SetLatchWidth(float width)</a>
<a name="ln1555">{</a>
<a name="ln1556">	fLatchWidth = width;</a>
<a name="ln1557">	Invalidate();</a>
<a name="ln1558">}</a>
<a name="ln1559"> </a>
<a name="ln1560"> </a>
<a name="ln1561">float</a>
<a name="ln1562">BColumnListView::LatchWidth() const</a>
<a name="ln1563">{</a>
<a name="ln1564">	return fLatchWidth;</a>
<a name="ln1565">}</a>
<a name="ln1566"> </a>
<a name="ln1567">void</a>
<a name="ln1568">BColumnListView::DrawLatch(BView* view, BRect rect, LatchType position, BRow*)</a>
<a name="ln1569">{</a>
<a name="ln1570">	const int32 rectInset = 4;</a>
<a name="ln1571"> </a>
<a name="ln1572">	// make square</a>
<a name="ln1573">	int32 sideLen = rect.IntegerWidth();</a>
<a name="ln1574">	if (sideLen &gt; rect.IntegerHeight())</a>
<a name="ln1575">		sideLen = rect.IntegerHeight();</a>
<a name="ln1576"> </a>
<a name="ln1577">	// make center</a>
<a name="ln1578">	int32 halfWidth  = rect.IntegerWidth() / 2;</a>
<a name="ln1579">	int32 halfHeight = rect.IntegerHeight() / 2;</a>
<a name="ln1580">	int32 halfSide   = sideLen / 2;</a>
<a name="ln1581"> </a>
<a name="ln1582">	float left = rect.left + halfWidth  - halfSide;</a>
<a name="ln1583">	float top  = rect.top  + halfHeight - halfSide;</a>
<a name="ln1584"> </a>
<a name="ln1585">	BRect itemRect(left, top, left + sideLen, top + sideLen);</a>
<a name="ln1586"> </a>
<a name="ln1587">	// Why it is a pixel high? I don't know.</a>
<a name="ln1588">	itemRect.OffsetBy(0, -1);</a>
<a name="ln1589"> </a>
<a name="ln1590">	itemRect.InsetBy(rectInset, rectInset);</a>
<a name="ln1591"> </a>
<a name="ln1592">	// make it an odd number of pixels wide, the latch looks better this way</a>
<a name="ln1593">	if ((itemRect.IntegerWidth() % 2) == 1) {</a>
<a name="ln1594">		itemRect.right += 1;</a>
<a name="ln1595">		itemRect.bottom += 1;</a>
<a name="ln1596">	}</a>
<a name="ln1597"> </a>
<a name="ln1598">	rgb_color highColor = view-&gt;HighColor();</a>
<a name="ln1599">	view-&gt;SetHighColor(0, 0, 0);</a>
<a name="ln1600"> </a>
<a name="ln1601">	switch (position) {</a>
<a name="ln1602">		case B_OPEN_LATCH:</a>
<a name="ln1603">			view-&gt;StrokeRect(itemRect);</a>
<a name="ln1604">			view-&gt;StrokeLine(</a>
<a name="ln1605">				BPoint(itemRect.left + 2,</a>
<a name="ln1606">					(itemRect.top + itemRect.bottom) / 2),</a>
<a name="ln1607">				BPoint(itemRect.right - 2,</a>
<a name="ln1608">					(itemRect.top + itemRect.bottom) / 2));</a>
<a name="ln1609">			break;</a>
<a name="ln1610"> </a>
<a name="ln1611">		case B_PRESSED_LATCH:</a>
<a name="ln1612">			view-&gt;StrokeRect(itemRect);</a>
<a name="ln1613">			view-&gt;StrokeLine(</a>
<a name="ln1614">				BPoint(itemRect.left + 2,</a>
<a name="ln1615">					(itemRect.top + itemRect.bottom) / 2),</a>
<a name="ln1616">				BPoint(itemRect.right - 2,</a>
<a name="ln1617">					(itemRect.top + itemRect.bottom) / 2));</a>
<a name="ln1618">			view-&gt;StrokeLine(</a>
<a name="ln1619">				BPoint((itemRect.left + itemRect.right) / 2,</a>
<a name="ln1620">					itemRect.top +  2),</a>
<a name="ln1621">				BPoint((itemRect.left + itemRect.right) / 2,</a>
<a name="ln1622">					itemRect.bottom - 2));</a>
<a name="ln1623">			view-&gt;InvertRect(itemRect);</a>
<a name="ln1624">			break;</a>
<a name="ln1625"> </a>
<a name="ln1626">		case B_CLOSED_LATCH:</a>
<a name="ln1627">			view-&gt;StrokeRect(itemRect);</a>
<a name="ln1628">			view-&gt;StrokeLine(</a>
<a name="ln1629">				BPoint(itemRect.left + 2,</a>
<a name="ln1630">					(itemRect.top + itemRect.bottom) / 2),</a>
<a name="ln1631">				BPoint(itemRect.right - 2,</a>
<a name="ln1632">					(itemRect.top + itemRect.bottom) / 2));</a>
<a name="ln1633">			view-&gt;StrokeLine(</a>
<a name="ln1634">				BPoint((itemRect.left + itemRect.right) / 2,</a>
<a name="ln1635">					itemRect.top +  2),</a>
<a name="ln1636">				BPoint((itemRect.left + itemRect.right) / 2,</a>
<a name="ln1637">					itemRect.bottom - 2));</a>
<a name="ln1638">			break;</a>
<a name="ln1639"> </a>
<a name="ln1640">		case B_NO_LATCH:</a>
<a name="ln1641">		default:</a>
<a name="ln1642">			// No drawing</a>
<a name="ln1643">			break;</a>
<a name="ln1644">	}</a>
<a name="ln1645"> </a>
<a name="ln1646">	view-&gt;SetHighColor(highColor);</a>
<a name="ln1647">}</a>
<a name="ln1648"> </a>
<a name="ln1649"> </a>
<a name="ln1650">void</a>
<a name="ln1651">BColumnListView::MakeFocus(bool isFocus)</a>
<a name="ln1652">{</a>
<a name="ln1653">	if (fBorderStyle != B_NO_BORDER) {</a>
<a name="ln1654">		// Redraw focus marks around view</a>
<a name="ln1655">		Invalidate();</a>
<a name="ln1656">		fHorizontalScrollBar-&gt;SetBorderHighlighted(isFocus);</a>
<a name="ln1657">		fVerticalScrollBar-&gt;SetBorderHighlighted(isFocus);</a>
<a name="ln1658">	}</a>
<a name="ln1659"> </a>
<a name="ln1660">	BView::MakeFocus(isFocus);</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663"> </a>
<a name="ln1664">void</a>
<a name="ln1665">BColumnListView::MessageReceived(BMessage* message)</a>
<a name="ln1666">{</a>
<a name="ln1667">	// Propagate mouse wheel messages down to child, so that it can</a>
<a name="ln1668">	// scroll.  Note we have done so, so we don't go into infinite</a>
<a name="ln1669">	// recursion if this comes back up here.</a>
<a name="ln1670">	if (message-&gt;what == B_MOUSE_WHEEL_CHANGED) {</a>
<a name="ln1671">		bool handled;</a>
<a name="ln1672">		if (message-&gt;FindBool(&quot;be:clvhandled&quot;, &amp;handled) != B_OK) {</a>
<a name="ln1673">			message-&gt;AddBool(&quot;be:clvhandled&quot;, true);</a>
<a name="ln1674">			fOutlineView-&gt;MessageReceived(message);</a>
<a name="ln1675">			return;</a>
<a name="ln1676">		}</a>
<a name="ln1677">	} else if (message-&gt;what == B_COLORS_UPDATED) {</a>
<a name="ln1678">		// Todo: Is it worthwhile to optimize this?</a>
<a name="ln1679">		_UpdateColors();</a>
<a name="ln1680">	}</a>
<a name="ln1681"> </a>
<a name="ln1682">	BView::MessageReceived(message);</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685"> </a>
<a name="ln1686">void</a>
<a name="ln1687">BColumnListView::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln1688">{</a>
<a name="ln1689">	char c = bytes[0];</a>
<a name="ln1690">	switch (c) {</a>
<a name="ln1691">		case B_RIGHT_ARROW:</a>
<a name="ln1692">		case B_LEFT_ARROW:</a>
<a name="ln1693">		{</a>
<a name="ln1694">			if ((modifiers() &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln1695">				float  minVal, maxVal;</a>
<a name="ln1696">				fHorizontalScrollBar-&gt;GetRange(&amp;minVal, &amp;maxVal);</a>
<a name="ln1697">				float smallStep, largeStep;</a>
<a name="ln1698">				fHorizontalScrollBar-&gt;GetSteps(&amp;smallStep, &amp;largeStep);</a>
<a name="ln1699">				float oldVal = fHorizontalScrollBar-&gt;Value();</a>
<a name="ln1700">				float newVal = oldVal;</a>
<a name="ln1701"> </a>
<a name="ln1702">				if (c == B_LEFT_ARROW)</a>
<a name="ln1703">					newVal -= smallStep;</a>
<a name="ln1704">				else if (c == B_RIGHT_ARROW)</a>
<a name="ln1705">					newVal += smallStep;</a>
<a name="ln1706"> </a>
<a name="ln1707">				if (newVal &lt; minVal)</a>
<a name="ln1708">					newVal = minVal;</a>
<a name="ln1709">				else if (newVal &gt; maxVal)</a>
<a name="ln1710">					newVal = maxVal;</a>
<a name="ln1711"> </a>
<a name="ln1712">				fHorizontalScrollBar-&gt;SetValue(newVal);</a>
<a name="ln1713">			} else {</a>
<a name="ln1714">				BRow* focusRow = fOutlineView-&gt;FocusRow();</a>
<a name="ln1715">				if (focusRow == NULL)</a>
<a name="ln1716">					break;</a>
<a name="ln1717"> </a>
<a name="ln1718">				bool expanded = focusRow-&gt;IsExpanded();</a>
<a name="ln1719">				if ((c == B_RIGHT_ARROW &amp;&amp; !expanded)</a>
<a name="ln1720">					|| (c == B_LEFT_ARROW &amp;&amp; expanded)) {</a>
<a name="ln1721">					fOutlineView-&gt;ToggleFocusRowOpen();</a>
<a name="ln1722">				}</a>
<a name="ln1723">			}</a>
<a name="ln1724">			break;</a>
<a name="ln1725">		}</a>
<a name="ln1726"> </a>
<a name="ln1727">		case B_DOWN_ARROW:</a>
<a name="ln1728">			fOutlineView-&gt;ChangeFocusRow(false,</a>
<a name="ln1729">				(modifiers() &amp; B_CONTROL_KEY) == 0,</a>
<a name="ln1730">				(modifiers() &amp; B_SHIFT_KEY) != 0);</a>
<a name="ln1731">			break;</a>
<a name="ln1732"> </a>
<a name="ln1733">		case B_UP_ARROW:</a>
<a name="ln1734">			fOutlineView-&gt;ChangeFocusRow(true,</a>
<a name="ln1735">				(modifiers() &amp; B_CONTROL_KEY) == 0,</a>
<a name="ln1736">				(modifiers() &amp; B_SHIFT_KEY) != 0);</a>
<a name="ln1737">			break;</a>
<a name="ln1738"> </a>
<a name="ln1739">		case B_PAGE_UP:</a>
<a name="ln1740">		case B_PAGE_DOWN:</a>
<a name="ln1741">		{</a>
<a name="ln1742">			float minValue, maxValue;</a>
<a name="ln1743">			fVerticalScrollBar-&gt;GetRange(&amp;minValue, &amp;maxValue);</a>
<a name="ln1744">			float smallStep, largeStep;</a>
<a name="ln1745">			fVerticalScrollBar-&gt;GetSteps(&amp;smallStep, &amp;largeStep);</a>
<a name="ln1746">			float currentValue = fVerticalScrollBar-&gt;Value();</a>
<a name="ln1747">			float newValue = currentValue;</a>
<a name="ln1748"> </a>
<a name="ln1749">			if (c == B_PAGE_UP)</a>
<a name="ln1750">				newValue -= largeStep;</a>
<a name="ln1751">			else</a>
<a name="ln1752">				newValue += largeStep;</a>
<a name="ln1753"> </a>
<a name="ln1754">			if (newValue &gt; maxValue)</a>
<a name="ln1755">				newValue = maxValue;</a>
<a name="ln1756">			else if (newValue &lt; minValue)</a>
<a name="ln1757">				newValue = minValue;</a>
<a name="ln1758"> </a>
<a name="ln1759">			fVerticalScrollBar-&gt;SetValue(newValue);</a>
<a name="ln1760"> </a>
<a name="ln1761">			// Option + pgup or pgdn scrolls and changes the selection.</a>
<a name="ln1762">			if (modifiers() &amp; B_OPTION_KEY)</a>
<a name="ln1763">				fOutlineView-&gt;MoveFocusToVisibleRect();</a>
<a name="ln1764"> </a>
<a name="ln1765">			break;</a>
<a name="ln1766">		}</a>
<a name="ln1767"> </a>
<a name="ln1768">		case B_ENTER:</a>
<a name="ln1769">			Invoke();</a>
<a name="ln1770">			break;</a>
<a name="ln1771"> </a>
<a name="ln1772">		case B_SPACE:</a>
<a name="ln1773">			fOutlineView-&gt;ToggleFocusRowSelection(</a>
<a name="ln1774">				(modifiers() &amp; B_SHIFT_KEY) != 0);</a>
<a name="ln1775">			break;</a>
<a name="ln1776"> </a>
<a name="ln1777">		case '+':</a>
<a name="ln1778">			fOutlineView-&gt;ToggleFocusRowOpen();</a>
<a name="ln1779">			break;</a>
<a name="ln1780"> </a>
<a name="ln1781">		default:</a>
<a name="ln1782">			BView::KeyDown(bytes, numBytes);</a>
<a name="ln1783">	}</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786"> </a>
<a name="ln1787">void</a>
<a name="ln1788">BColumnListView::AttachedToWindow()</a>
<a name="ln1789">{</a>
<a name="ln1790">	if (!Messenger().IsValid())</a>
<a name="ln1791">		SetTarget(Window());</a>
<a name="ln1792"> </a>
<a name="ln1793">	if (SortingEnabled()) fOutlineView-&gt;StartSorting();</a>
<a name="ln1794">}</a>
<a name="ln1795"> </a>
<a name="ln1796"> </a>
<a name="ln1797">void</a>
<a name="ln1798">BColumnListView::WindowActivated(bool active)</a>
<a name="ln1799">{</a>
<a name="ln1800">	fOutlineView-&gt;Invalidate();</a>
<a name="ln1801">		// focus and selection appearance changes with focus</a>
<a name="ln1802"> </a>
<a name="ln1803">	Invalidate();</a>
<a name="ln1804">		// redraw focus marks around view</a>
<a name="ln1805">	BView::WindowActivated(active);</a>
<a name="ln1806">}</a>
<a name="ln1807"> </a>
<a name="ln1808"> </a>
<a name="ln1809">void</a>
<a name="ln1810">BColumnListView::Draw(BRect updateRect)</a>
<a name="ln1811">{</a>
<a name="ln1812">	BRect rect = Bounds();</a>
<a name="ln1813"> </a>
<a name="ln1814">	uint32 flags = 0;</a>
<a name="ln1815">	if (IsFocus() &amp;&amp; Window()-&gt;IsActive())</a>
<a name="ln1816">		flags |= BControlLook::B_FOCUSED;</a>
<a name="ln1817"> </a>
<a name="ln1818">	rgb_color base = ui_color(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln1819"> </a>
<a name="ln1820">	BRect verticalScrollBarFrame;</a>
<a name="ln1821">	if (!fVerticalScrollBar-&gt;IsHidden())</a>
<a name="ln1822">		verticalScrollBarFrame = fVerticalScrollBar-&gt;Frame();</a>
<a name="ln1823"> </a>
<a name="ln1824">	BRect horizontalScrollBarFrame;</a>
<a name="ln1825">	if (!fHorizontalScrollBar-&gt;IsHidden())</a>
<a name="ln1826">		horizontalScrollBarFrame = fHorizontalScrollBar-&gt;Frame();</a>
<a name="ln1827"> </a>
<a name="ln1828">	if (fBorderStyle == B_NO_BORDER) {</a>
<a name="ln1829">		// We still draw the left/top border, but not focused.</a>
<a name="ln1830">		// The scrollbars cannot be displayed without frame and</a>
<a name="ln1831">		// it looks bad to have no frame only along the left/top</a>
<a name="ln1832">		// side.</a>
<a name="ln1833">		rgb_color borderColor = tint_color(base, B_DARKEN_2_TINT);</a>
<a name="ln1834">		SetHighColor(borderColor);</a>
<a name="ln1835">		StrokeLine(BPoint(rect.left, rect.bottom),</a>
<a name="ln1836">			BPoint(rect.left, rect.top));</a>
<a name="ln1837">		StrokeLine(BPoint(rect.left + 1, rect.top),</a>
<a name="ln1838">			BPoint(rect.right, rect.top));</a>
<a name="ln1839">	}</a>
<a name="ln1840"> </a>
<a name="ln1841">	be_control_look-&gt;DrawScrollViewFrame(this, rect, updateRect,</a>
<a name="ln1842">		verticalScrollBarFrame, horizontalScrollBarFrame,</a>
<a name="ln1843">		base, fBorderStyle, flags);</a>
<a name="ln1844"> </a>
<a name="ln1845">	if (fStatusView != NULL) {</a>
<a name="ln1846">		rect = Bounds();</a>
<a name="ln1847">		BRegion region(rect &amp; fStatusView-&gt;Frame().InsetByCopy(-2, -2));</a>
<a name="ln1848">		ConstrainClippingRegion(&amp;region);</a>
<a name="ln1849">		rect.bottom = fStatusView-&gt;Frame().top - 1;</a>
<a name="ln1850">		be_control_look-&gt;DrawScrollViewFrame(this, rect, updateRect,</a>
<a name="ln1851">			BRect(), BRect(), base, fBorderStyle, flags);</a>
<a name="ln1852">	}</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855"> </a>
<a name="ln1856">void</a>
<a name="ln1857">BColumnListView::SaveState(BMessage* message)</a>
<a name="ln1858">{</a>
<a name="ln1859">	message-&gt;MakeEmpty();</a>
<a name="ln1860"> </a>
<a name="ln1861">	for (int32 i = 0; BColumn* column = (BColumn*)fColumns.ItemAt(i); i++) {</a>
<a name="ln1862">		message-&gt;AddInt32(&quot;ID&quot;, column-&gt;fFieldID);</a>
<a name="ln1863">		message-&gt;AddFloat(&quot;width&quot;, column-&gt;fWidth);</a>
<a name="ln1864">		message-&gt;AddBool(&quot;visible&quot;, column-&gt;fVisible);</a>
<a name="ln1865">	}</a>
<a name="ln1866"> </a>
<a name="ln1867">	message-&gt;AddBool(&quot;sortingenabled&quot;, fSortingEnabled);</a>
<a name="ln1868"> </a>
<a name="ln1869">	if (fSortingEnabled) {</a>
<a name="ln1870">		for (int32 i = 0; BColumn* column = (BColumn*)fSortColumns.ItemAt(i);</a>
<a name="ln1871">				i++) {</a>
<a name="ln1872">			message-&gt;AddInt32(&quot;sortID&quot;, column-&gt;fFieldID);</a>
<a name="ln1873">			message-&gt;AddBool(&quot;sortascending&quot;, column-&gt;fSortAscending);</a>
<a name="ln1874">		}</a>
<a name="ln1875">	}</a>
<a name="ln1876">}</a>
<a name="ln1877"> </a>
<a name="ln1878"> </a>
<a name="ln1879">void</a>
<a name="ln1880">BColumnListView::LoadState(BMessage* message)</a>
<a name="ln1881">{</a>
<a name="ln1882">	int32 id;</a>
<a name="ln1883">	for (int i = 0; message-&gt;FindInt32(&quot;ID&quot;, i, &amp;id) == B_OK; i++) {</a>
<a name="ln1884">		for (int j = 0; BColumn* column = (BColumn*)fColumns.ItemAt(j); j++) {</a>
<a name="ln1885">			if (column-&gt;fFieldID == id) {</a>
<a name="ln1886">				// move this column to position 'i' and set its attributes</a>
<a name="ln1887">				MoveColumn(column, i);</a>
<a name="ln1888">				float width;</a>
<a name="ln1889">				if (message-&gt;FindFloat(&quot;width&quot;, i, &amp;width) == B_OK)</a>
<a name="ln1890">					column-&gt;SetWidth(width);</a>
<a name="ln1891">				bool visible;</a>
<a name="ln1892">				if (message-&gt;FindBool(&quot;visible&quot;, i, &amp;visible) == B_OK)</a>
<a name="ln1893">					column-&gt;SetVisible(visible);</a>
<a name="ln1894">			}</a>
<a name="ln1895">		}</a>
<a name="ln1896">	}</a>
<a name="ln1897">	bool b;</a>
<a name="ln1898">	if (message-&gt;FindBool(&quot;sortingenabled&quot;, &amp;b) == B_OK) {</a>
<a name="ln1899">		SetSortingEnabled(b);</a>
<a name="ln1900">		for (int k = 0; message-&gt;FindInt32(&quot;sortID&quot;, k, &amp;id) == B_OK; k++) {</a>
<a name="ln1901">			for (int j = 0; BColumn* column = (BColumn*)fColumns.ItemAt(j);</a>
<a name="ln1902">					j++) {</a>
<a name="ln1903">				if (column-&gt;fFieldID == id) {</a>
<a name="ln1904">					// add this column to the sort list</a>
<a name="ln1905">					bool value;</a>
<a name="ln1906">					if (message-&gt;FindBool(&quot;sortascending&quot;, k, &amp;value) == B_OK)</a>
<a name="ln1907">						SetSortColumn(column, true, value);</a>
<a name="ln1908">				}</a>
<a name="ln1909">			}</a>
<a name="ln1910">		}</a>
<a name="ln1911">	}</a>
<a name="ln1912">}</a>
<a name="ln1913"> </a>
<a name="ln1914"> </a>
<a name="ln1915">void</a>
<a name="ln1916">BColumnListView::SetEditMode(bool state)</a>
<a name="ln1917">{</a>
<a name="ln1918">	fOutlineView-&gt;SetEditMode(state);</a>
<a name="ln1919">	fTitleView-&gt;SetEditMode(state);</a>
<a name="ln1920">}</a>
<a name="ln1921"> </a>
<a name="ln1922"> </a>
<a name="ln1923">void</a>
<a name="ln1924">BColumnListView::Refresh()</a>
<a name="ln1925">{</a>
<a name="ln1926">	if (LockLooper()) {</a>
<a name="ln1927">		Invalidate();</a>
<a name="ln1928">		fOutlineView-&gt;FixScrollBar (true);</a>
<a name="ln1929">		fOutlineView-&gt;Invalidate();</a>
<a name="ln1930">		Window()-&gt;UpdateIfNeeded();</a>
<a name="ln1931">		UnlockLooper();</a>
<a name="ln1932">	}</a>
<a name="ln1933">}</a>
<a name="ln1934"> </a>
<a name="ln1935"> </a>
<a name="ln1936">BSize</a>
<a name="ln1937">BColumnListView::MinSize()</a>
<a name="ln1938">{</a>
<a name="ln1939">	BSize size;</a>
<a name="ln1940">	size.width = 100;</a>
<a name="ln1941">	size.height = std::max(kMinTitleHeight,</a>
<a name="ln1942">		ceilf(be_plain_font-&gt;Size() * kTitleSpacing))</a>
<a name="ln1943">		+ 4 * B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln1944">	if (!fHorizontalScrollBar-&gt;IsHidden())</a>
<a name="ln1945">		size.height += fHorizontalScrollBar-&gt;Frame().Height() + 1;</a>
<a name="ln1946">	// TODO: Take border size into account</a>
<a name="ln1947"> </a>
<a name="ln1948">	return BLayoutUtils::ComposeSize(ExplicitMinSize(), size);</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951"> </a>
<a name="ln1952">BSize</a>
<a name="ln1953">BColumnListView::PreferredSize()</a>
<a name="ln1954">{</a>
<a name="ln1955">	BSize size = MinSize();</a>
<a name="ln1956">	size.height += ceilf(be_plain_font-&gt;Size()) * 20;</a>
<a name="ln1957"> </a>
<a name="ln1958">	// return MinSize().width if there are no columns.</a>
<a name="ln1959">	int32 count = CountColumns();</a>
<a name="ln1960">	if (count &gt; 0) {</a>
<a name="ln1961">		BRect titleRect;</a>
<a name="ln1962">		BRect outlineRect;</a>
<a name="ln1963">		BRect vScrollBarRect;</a>
<a name="ln1964">		BRect hScrollBarRect;</a>
<a name="ln1965">		_GetChildViewRects(Bounds(), titleRect, outlineRect, vScrollBarRect,</a>
<a name="ln1966">			hScrollBarRect);</a>
<a name="ln1967">		// Start with the extra width for border and scrollbars etc.</a>
<a name="ln1968">		size.width = titleRect.left - Bounds().left;</a>
<a name="ln1969">		size.width += Bounds().right - titleRect.right;</a>
<a name="ln1970">		// If we want all columns to be visible at their preferred width,</a>
<a name="ln1971">		// we also need to add the extra margin width that the TitleView</a>
<a name="ln1972">		// uses to compute its _VirtualWidth() for the horizontal scroll bar.</a>
<a name="ln1973">		size.width += fTitleView-&gt;MarginWidth();</a>
<a name="ln1974">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1975">			BColumn* column = ColumnAt(i);</a>
<a name="ln1976">			if (column != NULL)</a>
<a name="ln1977">				size.width += fOutlineView-&gt;GetColumnPreferredWidth(column);</a>
<a name="ln1978">		}</a>
<a name="ln1979">	}</a>
<a name="ln1980"> </a>
<a name="ln1981">	return BLayoutUtils::ComposeSize(ExplicitPreferredSize(), size);</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984"> </a>
<a name="ln1985">BSize</a>
<a name="ln1986">BColumnListView::MaxSize()</a>
<a name="ln1987">{</a>
<a name="ln1988">	BSize size(B_SIZE_UNLIMITED, B_SIZE_UNLIMITED);</a>
<a name="ln1989">	return BLayoutUtils::ComposeSize(ExplicitMaxSize(), size);</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992"> </a>
<a name="ln1993">void</a>
<a name="ln1994">BColumnListView::LayoutInvalidated(bool descendants)</a>
<a name="ln1995">{</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998"> </a>
<a name="ln1999">void</a>
<a name="ln2000">BColumnListView::DoLayout()</a>
<a name="ln2001">{</a>
<a name="ln2002">	if ((Flags() &amp; B_SUPPORTS_LAYOUT) == 0)</a>
<a name="ln2003">		return;</a>
<a name="ln2004"> </a>
<a name="ln2005">	BRect titleRect;</a>
<a name="ln2006">	BRect outlineRect;</a>
<a name="ln2007">	BRect vScrollBarRect;</a>
<a name="ln2008">	BRect hScrollBarRect;</a>
<a name="ln2009">	_GetChildViewRects(Bounds(), titleRect, outlineRect, vScrollBarRect,</a>
<a name="ln2010">		hScrollBarRect);</a>
<a name="ln2011"> </a>
<a name="ln2012">	fTitleView-&gt;MoveTo(titleRect.LeftTop());</a>
<a name="ln2013">	fTitleView-&gt;ResizeTo(titleRect.Width(), titleRect.Height());</a>
<a name="ln2014"> </a>
<a name="ln2015">	fOutlineView-&gt;MoveTo(outlineRect.LeftTop());</a>
<a name="ln2016">	fOutlineView-&gt;ResizeTo(outlineRect.Width(), outlineRect.Height());</a>
<a name="ln2017"> </a>
<a name="ln2018">	fVerticalScrollBar-&gt;MoveTo(vScrollBarRect.LeftTop());</a>
<a name="ln2019">	fVerticalScrollBar-&gt;ResizeTo(vScrollBarRect.Width(),</a>
<a name="ln2020">		vScrollBarRect.Height());</a>
<a name="ln2021"> </a>
<a name="ln2022">	if (fStatusView != NULL) {</a>
<a name="ln2023">		BSize size = fStatusView-&gt;MinSize();</a>
<a name="ln2024">		if (size.height &gt; B_H_SCROLL_BAR_HEIGHT)</a>
<a name="ln2025">			size.height = B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln2026">		if (size.width &gt; Bounds().Width() / 2)</a>
<a name="ln2027">			size.width = floorf(Bounds().Width() / 2);</a>
<a name="ln2028"> </a>
<a name="ln2029">		BPoint offset(hScrollBarRect.LeftTop());</a>
<a name="ln2030"> </a>
<a name="ln2031">		if (fBorderStyle == B_PLAIN_BORDER) {</a>
<a name="ln2032">			offset += BPoint(0, 1);</a>
<a name="ln2033">		} else if (fBorderStyle == B_FANCY_BORDER) {</a>
<a name="ln2034">			offset += BPoint(-1, 2);</a>
<a name="ln2035">			size.height -= 1;</a>
<a name="ln2036">		}</a>
<a name="ln2037"> </a>
<a name="ln2038">		fStatusView-&gt;MoveTo(offset);</a>
<a name="ln2039">		fStatusView-&gt;ResizeTo(size.width, size.height);</a>
<a name="ln2040">		hScrollBarRect.left = offset.x + size.width + 1;</a>
<a name="ln2041">	}</a>
<a name="ln2042"> </a>
<a name="ln2043">	fHorizontalScrollBar-&gt;MoveTo(hScrollBarRect.LeftTop());</a>
<a name="ln2044">	fHorizontalScrollBar-&gt;ResizeTo(hScrollBarRect.Width(),</a>
<a name="ln2045">		hScrollBarRect.Height());</a>
<a name="ln2046"> </a>
<a name="ln2047">	fOutlineView-&gt;FixScrollBar(true);</a>
<a name="ln2048">}</a>
<a name="ln2049"> </a>
<a name="ln2050"> </a>
<a name="ln2051">void</a>
<a name="ln2052">BColumnListView::_Init()</a>
<a name="ln2053">{</a>
<a name="ln2054">	SetViewColor(B_TRANSPARENT_32_BIT);</a>
<a name="ln2055"> </a>
<a name="ln2056">	BRect bounds(Bounds());</a>
<a name="ln2057">	if (bounds.Width() &lt;= 0)</a>
<a name="ln2058">		bounds.right = 100;</a>
<a name="ln2059"> </a>
<a name="ln2060">	if (bounds.Height() &lt;= 0)</a>
<a name="ln2061">		bounds.bottom = 100;</a>
<a name="ln2062"> </a>
<a name="ln2063">	fCustomColors = false;</a>
<a name="ln2064">	_UpdateColors();</a>
<a name="ln2065"> </a>
<a name="ln2066">	BRect titleRect;</a>
<a name="ln2067">	BRect outlineRect;</a>
<a name="ln2068">	BRect vScrollBarRect;</a>
<a name="ln2069">	BRect hScrollBarRect;</a>
<a name="ln2070">	_GetChildViewRects(bounds, titleRect, outlineRect, vScrollBarRect,</a>
<a name="ln2071">		hScrollBarRect);</a>
<a name="ln2072"> </a>
<a name="ln2073">	fOutlineView = new OutlineView(outlineRect, &amp;fColumns, &amp;fSortColumns, this);</a>
<a name="ln2074">	AddChild(fOutlineView);</a>
<a name="ln2075"> </a>
<a name="ln2076"> </a>
<a name="ln2077">	fTitleView = new TitleView(titleRect, fOutlineView, &amp;fColumns,</a>
<a name="ln2078">		&amp;fSortColumns, this, B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP);</a>
<a name="ln2079">	AddChild(fTitleView);</a>
<a name="ln2080"> </a>
<a name="ln2081">	fVerticalScrollBar = new BScrollBar(vScrollBarRect, &quot;vertical_scroll_bar&quot;,</a>
<a name="ln2082">		fOutlineView, 0.0, bounds.Height(), B_VERTICAL);</a>
<a name="ln2083">	AddChild(fVerticalScrollBar);</a>
<a name="ln2084"> </a>
<a name="ln2085">	fHorizontalScrollBar = new BScrollBar(hScrollBarRect,</a>
<a name="ln2086">		&quot;horizontal_scroll_bar&quot;, fTitleView, 0.0, bounds.Width(), B_HORIZONTAL);</a>
<a name="ln2087">	AddChild(fHorizontalScrollBar);</a>
<a name="ln2088"> </a>
<a name="ln2089">	if (!fShowingHorizontalScrollBar)</a>
<a name="ln2090">		fHorizontalScrollBar-&gt;Hide();</a>
<a name="ln2091"> </a>
<a name="ln2092">	fOutlineView-&gt;FixScrollBar(true);</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095"> </a>
<a name="ln2096">void</a>
<a name="ln2097">BColumnListView::_UpdateColors()</a>
<a name="ln2098">{</a>
<a name="ln2099">	if (fCustomColors)</a>
<a name="ln2100">		return;</a>
<a name="ln2101"> </a>
<a name="ln2102">	fColorList[B_COLOR_BACKGROUND] = ui_color(B_LIST_BACKGROUND_COLOR);</a>
<a name="ln2103">	fColorList[B_COLOR_TEXT] = ui_color(B_LIST_ITEM_TEXT_COLOR);</a>
<a name="ln2104">	fColorList[B_COLOR_ROW_DIVIDER] = tint_color(</a>
<a name="ln2105">		ui_color(B_LIST_SELECTED_BACKGROUND_COLOR), B_DARKEN_2_TINT);</a>
<a name="ln2106">	fColorList[B_COLOR_SELECTION] = ui_color(B_LIST_SELECTED_BACKGROUND_COLOR);</a>
<a name="ln2107">	fColorList[B_COLOR_SELECTION_TEXT] =</a>
<a name="ln2108">		ui_color(B_LIST_SELECTED_ITEM_TEXT_COLOR);</a>
<a name="ln2109"> </a>
<a name="ln2110">	// For non focus selection uses the selection color as BListView</a>
<a name="ln2111">	fColorList[B_COLOR_NON_FOCUS_SELECTION] =</a>
<a name="ln2112">		ui_color(B_LIST_SELECTED_BACKGROUND_COLOR);</a>
<a name="ln2113"> </a>
<a name="ln2114">	// edit mode doesn't work very well</a>
<a name="ln2115">	fColorList[B_COLOR_EDIT_BACKGROUND] = tint_color(</a>
<a name="ln2116">		ui_color(B_LIST_SELECTED_BACKGROUND_COLOR), B_DARKEN_1_TINT);</a>
<a name="ln2117">	fColorList[B_COLOR_EDIT_BACKGROUND].alpha = 180;</a>
<a name="ln2118"> </a>
<a name="ln2119">	// Unused color</a>
<a name="ln2120">	fColorList[B_COLOR_EDIT_TEXT] = ui_color(B_LIST_SELECTED_ITEM_TEXT_COLOR);</a>
<a name="ln2121"> </a>
<a name="ln2122">	fColorList[B_COLOR_HEADER_BACKGROUND] = ui_color(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln2123">	fColorList[B_COLOR_HEADER_TEXT] = ui_color(B_PANEL_TEXT_COLOR);</a>
<a name="ln2124"> </a>
<a name="ln2125">	// Unused colors</a>
<a name="ln2126">	fColorList[B_COLOR_SEPARATOR_LINE] = ui_color(B_LIST_ITEM_TEXT_COLOR);</a>
<a name="ln2127">	fColorList[B_COLOR_SEPARATOR_BORDER] = ui_color(B_LIST_ITEM_TEXT_COLOR);</a>
<a name="ln2128">}</a>
<a name="ln2129"> </a>
<a name="ln2130"> </a>
<a name="ln2131">void</a>
<a name="ln2132">BColumnListView::_GetChildViewRects(const BRect&amp; bounds, BRect&amp; titleRect,</a>
<a name="ln2133">	BRect&amp; outlineRect, BRect&amp; vScrollBarRect, BRect&amp; hScrollBarRect)</a>
<a name="ln2134">{</a>
<a name="ln2135">	titleRect = bounds;</a>
<a name="ln2136">	titleRect.bottom = titleRect.top + std::max(kMinTitleHeight,</a>
<a name="ln2137">		ceilf(be_plain_font-&gt;Size() * kTitleSpacing));</a>
<a name="ln2138">#if !LOWER_SCROLLBAR</a>
<a name="ln2139">	titleRect.right -= B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln2140">#endif</a>
<a name="ln2141"> </a>
<a name="ln2142">	outlineRect = bounds;</a>
<a name="ln2143">	outlineRect.top = titleRect.bottom + 1.0;</a>
<a name="ln2144">	outlineRect.right -= B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln2145">	if (fShowingHorizontalScrollBar)</a>
<a name="ln2146">		outlineRect.bottom -= B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln2147"> </a>
<a name="ln2148">	vScrollBarRect = bounds;</a>
<a name="ln2149">#if LOWER_SCROLLBAR</a>
<a name="ln2150">	vScrollBarRect.top += std::max(kMinTitleHeight,</a>
<a name="ln2151">		ceilf(be_plain_font-&gt;Size() * kTitleSpacing));</a>
<a name="ln2152">#endif</a>
<a name="ln2153"> </a>
<a name="ln2154">	vScrollBarRect.left = vScrollBarRect.right - B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln2155">	if (fShowingHorizontalScrollBar)</a>
<a name="ln2156">		vScrollBarRect.bottom -= B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln2157"> </a>
<a name="ln2158">	hScrollBarRect = bounds;</a>
<a name="ln2159">	hScrollBarRect.top = hScrollBarRect.bottom - B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln2160">	hScrollBarRect.right -= B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln2161"> </a>
<a name="ln2162">	// Adjust stuff so the border will fit.</a>
<a name="ln2163">	if (fBorderStyle == B_PLAIN_BORDER || fBorderStyle == B_NO_BORDER) {</a>
<a name="ln2164">		titleRect.InsetBy(1, 0);</a>
<a name="ln2165">		titleRect.OffsetBy(0, 1);</a>
<a name="ln2166">		outlineRect.InsetBy(1, 1);</a>
<a name="ln2167">	} else if (fBorderStyle == B_FANCY_BORDER) {</a>
<a name="ln2168">		titleRect.InsetBy(2, 0);</a>
<a name="ln2169">		titleRect.OffsetBy(0, 2);</a>
<a name="ln2170">		outlineRect.InsetBy(2, 2);</a>
<a name="ln2171"> </a>
<a name="ln2172">		vScrollBarRect.OffsetBy(-1, 0);</a>
<a name="ln2173">#if LOWER_SCROLLBAR</a>
<a name="ln2174">		vScrollBarRect.top += 2;</a>
<a name="ln2175">		vScrollBarRect.bottom -= 1;</a>
<a name="ln2176">#else</a>
<a name="ln2177">		vScrollBarRect.InsetBy(0, 1);</a>
<a name="ln2178">#endif</a>
<a name="ln2179">		hScrollBarRect.OffsetBy(0, -1);</a>
<a name="ln2180">		hScrollBarRect.InsetBy(1, 0);</a>
<a name="ln2181">	}</a>
<a name="ln2182">}</a>
<a name="ln2183"> </a>
<a name="ln2184"> </a>
<a name="ln2185">// #pragma mark -</a>
<a name="ln2186"> </a>
<a name="ln2187"> </a>
<a name="ln2188">TitleView::TitleView(BRect rect, OutlineView* horizontalSlave,</a>
<a name="ln2189">	BList* visibleColumns, BList* sortColumns, BColumnListView* listView,</a>
<a name="ln2190">	uint32 resizingMode)</a>
<a name="ln2191">	:</a>
<a name="ln2192">	BView(rect, &quot;title_view&quot;, resizingMode, B_WILL_DRAW | B_FRAME_EVENTS),</a>
<a name="ln2193">	fOutlineView(horizontalSlave),</a>
<a name="ln2194">	fColumns(visibleColumns),</a>
<a name="ln2195">	fSortColumns(sortColumns),</a>
<a name="ln2196">//	fColumnsWidth(0),</a>
<a name="ln2197">	fVisibleRect(rect.OffsetToCopy(0, 0)),</a>
<a name="ln2198">	fCurrentState(INACTIVE),</a>
<a name="ln2199">	fColumnPop(NULL),</a>
<a name="ln2200">	fMasterView(listView),</a>
<a name="ln2201">	fEditMode(false),</a>
<a name="ln2202">	fColumnFlags(B_ALLOW_COLUMN_MOVE | B_ALLOW_COLUMN_RESIZE</a>
<a name="ln2203">		| B_ALLOW_COLUMN_POPUP | B_ALLOW_COLUMN_REMOVE)</a>
<a name="ln2204">{</a>
<a name="ln2205">	SetViewColor(B_TRANSPARENT_COLOR);</a>
<a name="ln2206"> </a>
<a name="ln2207">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln2208">	// xxx this needs to be smart about the size of the backbuffer.</a>
<a name="ln2209">	BRect doubleBufferRect(0, 0, 600, 35);</a>
<a name="ln2210">	fDrawBuffer = new BBitmap(doubleBufferRect, B_RGB32, true);</a>
<a name="ln2211">	fDrawBufferView = new BView(doubleBufferRect, &quot;double_buffer_view&quot;,</a>
<a name="ln2212">		B_FOLLOW_ALL_SIDES, 0);</a>
<a name="ln2213">	fDrawBuffer-&gt;Lock();</a>
<a name="ln2214">	fDrawBuffer-&gt;AddChild(fDrawBufferView);</a>
<a name="ln2215">	fDrawBuffer-&gt;Unlock();</a>
<a name="ln2216">#endif</a>
<a name="ln2217"> </a>
<a name="ln2218">	fUpSortArrow = new BBitmap(BRect(0, 0, 7, 7), B_CMAP8);</a>
<a name="ln2219">	fDownSortArrow = new BBitmap(BRect(0, 0, 7, 7), B_CMAP8);</a>
<a name="ln2220"> </a>
<a name="ln2221">	fUpSortArrow-&gt;SetBits((const void*) kUpSortArrow8x8, 64, 0, B_CMAP8);</a>
<a name="ln2222">	fDownSortArrow-&gt;SetBits((const void*) kDownSortArrow8x8, 64, 0, B_CMAP8);</a>
<a name="ln2223"> </a>
<a name="ln2224">	fResizeCursor = new BCursor(B_CURSOR_ID_RESIZE_EAST_WEST);</a>
<a name="ln2225">	fMinResizeCursor = new BCursor(B_CURSOR_ID_RESIZE_EAST);</a>
<a name="ln2226">	fMaxResizeCursor = new BCursor(B_CURSOR_ID_RESIZE_WEST);</a>
<a name="ln2227">	fColumnMoveCursor = new BCursor(B_CURSOR_ID_MOVE);</a>
<a name="ln2228"> </a>
<a name="ln2229">	FixScrollBar(true);</a>
<a name="ln2230">}</a>
<a name="ln2231"> </a>
<a name="ln2232"> </a>
<a name="ln2233">TitleView::~TitleView()</a>
<a name="ln2234">{</a>
<a name="ln2235">	delete fColumnPop;</a>
<a name="ln2236">	fColumnPop = NULL;</a>
<a name="ln2237"> </a>
<a name="ln2238">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln2239">	delete fDrawBuffer;</a>
<a name="ln2240">#endif</a>
<a name="ln2241">	delete fUpSortArrow;</a>
<a name="ln2242">	delete fDownSortArrow;</a>
<a name="ln2243"> </a>
<a name="ln2244">	delete fResizeCursor;</a>
<a name="ln2245">	delete fMaxResizeCursor;</a>
<a name="ln2246">	delete fMinResizeCursor;</a>
<a name="ln2247">	delete fColumnMoveCursor;</a>
<a name="ln2248">}</a>
<a name="ln2249"> </a>
<a name="ln2250"> </a>
<a name="ln2251">void</a>
<a name="ln2252">TitleView::ColumnAdded(BColumn* column)</a>
<a name="ln2253">{</a>
<a name="ln2254">//	fColumnsWidth += column-&gt;Width();</a>
<a name="ln2255">	FixScrollBar(false);</a>
<a name="ln2256">	Invalidate();</a>
<a name="ln2257">}</a>
<a name="ln2258"> </a>
<a name="ln2259"> </a>
<a name="ln2260">void</a>
<a name="ln2261">TitleView::ColumnResized(BColumn* column, float oldWidth)</a>
<a name="ln2262">{</a>
<a name="ln2263">//	fColumnsWidth += column-&gt;Width() - oldWidth;</a>
<a name="ln2264">	FixScrollBar(false);</a>
<a name="ln2265">	Invalidate();</a>
<a name="ln2266">}</a>
<a name="ln2267"> </a>
<a name="ln2268"> </a>
<a name="ln2269">void</a>
<a name="ln2270">TitleView::SetColumnVisible(BColumn* column, bool visible)</a>
<a name="ln2271">{</a>
<a name="ln2272">	if (column-&gt;fVisible == visible)</a>
<a name="ln2273">		return;</a>
<a name="ln2274"> </a>
<a name="ln2275">	// If setting it visible, do this first so we can find its position</a>
<a name="ln2276">	// to invalidate.  If hiding it, do it last.</a>
<a name="ln2277">	if (visible)</a>
<a name="ln2278">		column-&gt;fVisible = visible;</a>
<a name="ln2279"> </a>
<a name="ln2280">	BRect titleInvalid;</a>
<a name="ln2281">	GetTitleRect(column, &amp;titleInvalid);</a>
<a name="ln2282"> </a>
<a name="ln2283">	// Now really set the visibility</a>
<a name="ln2284">	column-&gt;fVisible = visible;</a>
<a name="ln2285"> </a>
<a name="ln2286">//	if (visible)</a>
<a name="ln2287">//		fColumnsWidth += column-&gt;Width();</a>
<a name="ln2288">//	else</a>
<a name="ln2289">//		fColumnsWidth -= column-&gt;Width();</a>
<a name="ln2290"> </a>
<a name="ln2291">	BRect outlineInvalid(fOutlineView-&gt;VisibleRect());</a>
<a name="ln2292">	outlineInvalid.left = titleInvalid.left;</a>
<a name="ln2293">	titleInvalid.right = outlineInvalid.right;</a>
<a name="ln2294"> </a>
<a name="ln2295">	Invalidate(titleInvalid);</a>
<a name="ln2296">	fOutlineView-&gt;Invalidate(outlineInvalid);</a>
<a name="ln2297"> </a>
<a name="ln2298">	FixScrollBar(false);</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301"> </a>
<a name="ln2302">void</a>
<a name="ln2303">TitleView::GetTitleRect(BColumn* findColumn, BRect* _rect)</a>
<a name="ln2304">{</a>
<a name="ln2305">	float leftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());</a>
<a name="ln2306">	int32 numColumns = fColumns-&gt;CountItems();</a>
<a name="ln2307">	for (int index = 0; index &lt; numColumns; index++) {</a>
<a name="ln2308">		BColumn* column = (BColumn*) fColumns-&gt;ItemAt(index);</a>
<a name="ln2309">		if (!column-&gt;IsVisible())</a>
<a name="ln2310">			continue;</a>
<a name="ln2311"> </a>
<a name="ln2312">		if (column == findColumn) {</a>
<a name="ln2313">			_rect-&gt;Set(leftEdge, 0, leftEdge + column-&gt;Width(),</a>
<a name="ln2314">				fVisibleRect.bottom);</a>
<a name="ln2315">			return;</a>
<a name="ln2316">		}</a>
<a name="ln2317"> </a>
<a name="ln2318">		leftEdge += column-&gt;Width() + 1;</a>
<a name="ln2319">	}</a>
<a name="ln2320"> </a>
<a name="ln2321">	TRESPASS();</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324"> </a>
<a name="ln2325">int32</a>
<a name="ln2326">TitleView::FindColumn(BPoint position, float* _leftEdge)</a>
<a name="ln2327">{</a>
<a name="ln2328">	float leftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());</a>
<a name="ln2329">	int32 numColumns = fColumns-&gt;CountItems();</a>
<a name="ln2330">	for (int index = 0; index &lt; numColumns; index++) {</a>
<a name="ln2331">		BColumn* column = (BColumn*) fColumns-&gt;ItemAt(index);</a>
<a name="ln2332">		if (!column-&gt;IsVisible())</a>
<a name="ln2333">			continue;</a>
<a name="ln2334"> </a>
<a name="ln2335">		if (leftEdge &gt; position.x)</a>
<a name="ln2336">			break;</a>
<a name="ln2337"> </a>
<a name="ln2338">		if (position.x &gt;= leftEdge</a>
<a name="ln2339">			&amp;&amp; position.x &lt;= leftEdge + column-&gt;Width()) {</a>
<a name="ln2340">			*_leftEdge = leftEdge;</a>
<a name="ln2341">			return index;</a>
<a name="ln2342">		}</a>
<a name="ln2343"> </a>
<a name="ln2344">		leftEdge += column-&gt;Width() + 1;</a>
<a name="ln2345">	}</a>
<a name="ln2346"> </a>
<a name="ln2347">	return 0;</a>
<a name="ln2348">}</a>
<a name="ln2349"> </a>
<a name="ln2350"> </a>
<a name="ln2351">void</a>
<a name="ln2352">TitleView::FixScrollBar(bool scrollToFit)</a>
<a name="ln2353">{</a>
<a name="ln2354">	BScrollBar* hScrollBar = ScrollBar(B_HORIZONTAL);</a>
<a name="ln2355">	if (hScrollBar == NULL)</a>
<a name="ln2356">		return;</a>
<a name="ln2357"> </a>
<a name="ln2358">	float virtualWidth = _VirtualWidth();</a>
<a name="ln2359"> </a>
<a name="ln2360">	if (virtualWidth &gt; fVisibleRect.Width()) {</a>
<a name="ln2361">		hScrollBar-&gt;SetProportion(fVisibleRect.Width() / virtualWidth);</a>
<a name="ln2362"> </a>
<a name="ln2363">		// Perform the little trick if the user is scrolled over too far.</a>
<a name="ln2364">		// See OutlineView::FixScrollBar for a more in depth explanation</a>
<a name="ln2365">		float maxScrollBarValue = virtualWidth - fVisibleRect.Width();</a>
<a name="ln2366">		if (scrollToFit || hScrollBar-&gt;Value() &lt;= maxScrollBarValue) {</a>
<a name="ln2367">			hScrollBar-&gt;SetRange(0.0, maxScrollBarValue);</a>
<a name="ln2368">			hScrollBar-&gt;SetSteps(50, fVisibleRect.Width());</a>
<a name="ln2369">		}</a>
<a name="ln2370">	} else if (hScrollBar-&gt;Value() == 0.0) {</a>
<a name="ln2371">		// disable scroll bar.</a>
<a name="ln2372">		hScrollBar-&gt;SetRange(0.0, 0.0);</a>
<a name="ln2373">	}</a>
<a name="ln2374">}</a>
<a name="ln2375"> </a>
<a name="ln2376"> </a>
<a name="ln2377">void</a>
<a name="ln2378">TitleView::DragSelectedColumn(BPoint position)</a>
<a name="ln2379">{</a>
<a name="ln2380">	float invalidLeft = fSelectedColumnRect.left;</a>
<a name="ln2381">	float invalidRight = fSelectedColumnRect.right;</a>
<a name="ln2382"> </a>
<a name="ln2383">	float leftEdge;</a>
<a name="ln2384">	int32 columnIndex = FindColumn(position, &amp;leftEdge);</a>
<a name="ln2385">	fSelectedColumnRect.OffsetTo(leftEdge, 0);</a>
<a name="ln2386"> </a>
<a name="ln2387">	MoveColumn(fSelectedColumn, columnIndex);</a>
<a name="ln2388"> </a>
<a name="ln2389">	fSelectedColumn-&gt;fVisible = true;</a>
<a name="ln2390">	ComputeDragBoundries(fSelectedColumn, position);</a>
<a name="ln2391"> </a>
<a name="ln2392">	// Redraw the new column position</a>
<a name="ln2393">	GetTitleRect(fSelectedColumn, &amp;fSelectedColumnRect);</a>
<a name="ln2394">	invalidLeft = MIN(fSelectedColumnRect.left, invalidLeft);</a>
<a name="ln2395">	invalidRight = MAX(fSelectedColumnRect.right, invalidRight);</a>
<a name="ln2396"> </a>
<a name="ln2397">	Invalidate(BRect(invalidLeft, 0, invalidRight, fVisibleRect.bottom));</a>
<a name="ln2398">	fOutlineView-&gt;Invalidate(BRect(invalidLeft, 0, invalidRight,</a>
<a name="ln2399">		fOutlineView-&gt;VisibleRect().bottom));</a>
<a name="ln2400"> </a>
<a name="ln2401">	DrawTitle(this, fSelectedColumnRect, fSelectedColumn, true);</a>
<a name="ln2402">}</a>
<a name="ln2403"> </a>
<a name="ln2404"> </a>
<a name="ln2405">void</a>
<a name="ln2406">TitleView::MoveColumn(BColumn* column, int32 index)</a>
<a name="ln2407">{</a>
<a name="ln2408">	fColumns-&gt;RemoveItem((void*) column);</a>
<a name="ln2409"> </a>
<a name="ln2410">	if (-1 == index) {</a>
<a name="ln2411">		// Re-add the column at the end of the list.</a>
<a name="ln2412">		fColumns-&gt;AddItem((void*) column);</a>
<a name="ln2413">	} else {</a>
<a name="ln2414">		fColumns-&gt;AddItem((void*) column, index);</a>
<a name="ln2415">	}</a>
<a name="ln2416">}</a>
<a name="ln2417"> </a>
<a name="ln2418"> </a>
<a name="ln2419">void</a>
<a name="ln2420">TitleView::SetColumnFlags(column_flags flags)</a>
<a name="ln2421">{</a>
<a name="ln2422">	fColumnFlags = flags;</a>
<a name="ln2423">}</a>
<a name="ln2424"> </a>
<a name="ln2425"> </a>
<a name="ln2426">float</a>
<a name="ln2427">TitleView::MarginWidth() const</a>
<a name="ln2428">{</a>
<a name="ln2429">	return MAX(kLeftMargin, fMasterView-&gt;LatchWidth()) + kRightMargin;</a>
<a name="ln2430">}</a>
<a name="ln2431"> </a>
<a name="ln2432"> </a>
<a name="ln2433">void</a>
<a name="ln2434">TitleView::ResizeSelectedColumn(BPoint position, bool preferred)</a>
<a name="ln2435">{</a>
<a name="ln2436">	float minWidth = fSelectedColumn-&gt;MinWidth();</a>
<a name="ln2437">	float maxWidth = fSelectedColumn-&gt;MaxWidth();</a>
<a name="ln2438"> </a>
<a name="ln2439">	float oldWidth = fSelectedColumn-&gt;Width();</a>
<a name="ln2440">	float originalEdge = fSelectedColumnRect.left + oldWidth;</a>
<a name="ln2441">	if (preferred) {</a>
<a name="ln2442">		float width = fOutlineView-&gt;GetColumnPreferredWidth(fSelectedColumn);</a>
<a name="ln2443">		fSelectedColumn-&gt;SetWidth(width);</a>
<a name="ln2444">	} else if (position.x &gt; fSelectedColumnRect.left + maxWidth)</a>
<a name="ln2445">		fSelectedColumn-&gt;SetWidth(maxWidth);</a>
<a name="ln2446">	else if (position.x &lt; fSelectedColumnRect.left + minWidth)</a>
<a name="ln2447">		fSelectedColumn-&gt;SetWidth(minWidth);</a>
<a name="ln2448">	else</a>
<a name="ln2449">		fSelectedColumn-&gt;SetWidth(position.x - fSelectedColumnRect.left - 1);</a>
<a name="ln2450"> </a>
<a name="ln2451">	float dX = fSelectedColumnRect.left + fSelectedColumn-&gt;Width()</a>
<a name="ln2452">		 - originalEdge;</a>
<a name="ln2453">	if (dX != 0) {</a>
<a name="ln2454">		float columnHeight = fVisibleRect.Height();</a>
<a name="ln2455">		BRect originalRect(originalEdge, 0, 1000000.0, columnHeight);</a>
<a name="ln2456">		BRect movedRect(originalRect);</a>
<a name="ln2457">		movedRect.OffsetBy(dX, 0);</a>
<a name="ln2458"> </a>
<a name="ln2459">		// Update the size of the title column</a>
<a name="ln2460">		BRect sourceRect(0, 0, fSelectedColumn-&gt;Width(), columnHeight);</a>
<a name="ln2461">		BRect destRect(sourceRect);</a>
<a name="ln2462">		destRect.OffsetBy(fSelectedColumnRect.left, 0);</a>
<a name="ln2463"> </a>
<a name="ln2464">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln2465">		fDrawBuffer-&gt;Lock();</a>
<a name="ln2466">		DrawTitle(fDrawBufferView, sourceRect, fSelectedColumn, false);</a>
<a name="ln2467">		fDrawBufferView-&gt;Sync();</a>
<a name="ln2468">		fDrawBuffer-&gt;Unlock();</a>
<a name="ln2469"> </a>
<a name="ln2470">		CopyBits(originalRect, movedRect);</a>
<a name="ln2471">		DrawBitmap(fDrawBuffer, sourceRect, destRect);</a>
<a name="ln2472">#else</a>
<a name="ln2473">		CopyBits(originalRect, movedRect);</a>
<a name="ln2474">		DrawTitle(this, destRect, fSelectedColumn, false);</a>
<a name="ln2475">#endif</a>
<a name="ln2476"> </a>
<a name="ln2477">		// Update the body view</a>
<a name="ln2478">		BRect slaveSize = fOutlineView-&gt;VisibleRect();</a>
<a name="ln2479">		BRect slaveSource(originalRect);</a>
<a name="ln2480">		slaveSource.bottom = slaveSize.bottom;</a>
<a name="ln2481">		BRect slaveDest(movedRect);</a>
<a name="ln2482">		slaveDest.bottom = slaveSize.bottom;</a>
<a name="ln2483">		fOutlineView-&gt;CopyBits(slaveSource, slaveDest);</a>
<a name="ln2484">		fOutlineView-&gt;RedrawColumn(fSelectedColumn, fSelectedColumnRect.left,</a>
<a name="ln2485">			fResizingFirstColumn);</a>
<a name="ln2486"> </a>
<a name="ln2487">//		fColumnsWidth += dX;</a>
<a name="ln2488"> </a>
<a name="ln2489">		// Update the cursor</a>
<a name="ln2490">		if (fSelectedColumn-&gt;Width() == minWidth)</a>
<a name="ln2491">			SetViewCursor(fMinResizeCursor, true);</a>
<a name="ln2492">		else if (fSelectedColumn-&gt;Width() == maxWidth)</a>
<a name="ln2493">			SetViewCursor(fMaxResizeCursor, true);</a>
<a name="ln2494">		else</a>
<a name="ln2495">			SetViewCursor(fResizeCursor, true);</a>
<a name="ln2496"> </a>
<a name="ln2497">		ColumnResized(fSelectedColumn, oldWidth);</a>
<a name="ln2498">	}</a>
<a name="ln2499">}</a>
<a name="ln2500"> </a>
<a name="ln2501"> </a>
<a name="ln2502">void</a>
<a name="ln2503">TitleView::ComputeDragBoundries(BColumn* findColumn, BPoint)</a>
<a name="ln2504">{</a>
<a name="ln2505">	float previousColumnLeftEdge = -1000000.0;</a>
<a name="ln2506">	float nextColumnRightEdge = 1000000.0;</a>
<a name="ln2507"> </a>
<a name="ln2508">	bool foundColumn = false;</a>
<a name="ln2509">	float leftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());</a>
<a name="ln2510">	int32 numColumns = fColumns-&gt;CountItems();</a>
<a name="ln2511">	for (int index = 0; index &lt; numColumns; index++) {</a>
<a name="ln2512">		BColumn* column = (BColumn*) fColumns-&gt;ItemAt(index);</a>
<a name="ln2513">		if (!column-&gt;IsVisible())</a>
<a name="ln2514">			continue;</a>
<a name="ln2515"> </a>
<a name="ln2516">		if (column == findColumn) {</a>
<a name="ln2517">			foundColumn = true;</a>
<a name="ln2518">			continue;</a>
<a name="ln2519">		}</a>
<a name="ln2520"> </a>
<a name="ln2521">		if (foundColumn) {</a>
<a name="ln2522">			nextColumnRightEdge = leftEdge + column-&gt;Width();</a>
<a name="ln2523">			break;</a>
<a name="ln2524">		} else</a>
<a name="ln2525">			previousColumnLeftEdge = leftEdge;</a>
<a name="ln2526"> </a>
<a name="ln2527">		leftEdge += column-&gt;Width() + 1;</a>
<a name="ln2528">	}</a>
<a name="ln2529"> </a>
<a name="ln2530">	float rightEdge = leftEdge + findColumn-&gt;Width();</a>
<a name="ln2531"> </a>
<a name="ln2532">	fLeftDragBoundry = MIN(previousColumnLeftEdge + findColumn-&gt;Width(),</a>
<a name="ln2533">		leftEdge);</a>
<a name="ln2534">	fRightDragBoundry = MAX(nextColumnRightEdge, rightEdge);</a>
<a name="ln2535">}</a>
<a name="ln2536"> </a>
<a name="ln2537"> </a>
<a name="ln2538">void</a>
<a name="ln2539">TitleView::DrawTitle(BView* view, BRect rect, BColumn* column, bool depressed)</a>
<a name="ln2540">{</a>
<a name="ln2541">	BRect drawRect;</a>
<a name="ln2542">	drawRect = rect;</a>
<a name="ln2543"> </a>
<a name="ln2544">	font_height fh;</a>
<a name="ln2545">	GetFontHeight(&amp;fh);</a>
<a name="ln2546"> </a>
<a name="ln2547">	float baseline = floor(drawRect.top + fh.ascent</a>
<a name="ln2548">		+ (drawRect.Height() + 1 - (fh.ascent + fh.descent)) / 2);</a>
<a name="ln2549"> </a>
<a name="ln2550">	BRect bgRect = rect;</a>
<a name="ln2551"> </a>
<a name="ln2552">	rgb_color base = ui_color(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln2553">	view-&gt;SetHighColor(tint_color(base, B_DARKEN_2_TINT));</a>
<a name="ln2554">	view-&gt;StrokeLine(bgRect.LeftBottom(), bgRect.RightBottom());</a>
<a name="ln2555"> </a>
<a name="ln2556">	bgRect.bottom--;</a>
<a name="ln2557">	bgRect.right--;</a>
<a name="ln2558"> </a>
<a name="ln2559">	if (depressed)</a>
<a name="ln2560">		base = tint_color(base, B_DARKEN_1_TINT);</a>
<a name="ln2561"> </a>
<a name="ln2562">	be_control_look-&gt;DrawButtonBackground(view, bgRect, rect, base, 0,</a>
<a name="ln2563">		BControlLook::B_TOP_BORDER | BControlLook::B_BOTTOM_BORDER);</a>
<a name="ln2564"> </a>
<a name="ln2565">	view-&gt;SetHighColor(tint_color(ui_color(B_PANEL_BACKGROUND_COLOR),</a>
<a name="ln2566">		B_DARKEN_2_TINT));</a>
<a name="ln2567">	view-&gt;StrokeLine(rect.RightTop(), rect.RightBottom());</a>
<a name="ln2568"> </a>
<a name="ln2569">	// If no column given, nothing else to draw.</a>
<a name="ln2570">	if (column == NULL)</a>
<a name="ln2571">		return;</a>
<a name="ln2572"> </a>
<a name="ln2573">	view-&gt;SetHighColor(fMasterView-&gt;Color(B_COLOR_HEADER_TEXT));</a>
<a name="ln2574"> </a>
<a name="ln2575">	BFont font;</a>
<a name="ln2576">	GetFont(&amp;font);</a>
<a name="ln2577">	view-&gt;SetFont(&amp;font);</a>
<a name="ln2578"> </a>
<a name="ln2579">	int sortIndex = fSortColumns-&gt;IndexOf(column);</a>
<a name="ln2580">	if (sortIndex &gt;= 0) {</a>
<a name="ln2581">		// Draw sort notation.</a>
<a name="ln2582">		BPoint upperLeft(drawRect.right - kSortIndicatorWidth, baseline);</a>
<a name="ln2583"> </a>
<a name="ln2584">		if (fSortColumns-&gt;CountItems() &gt; 1) {</a>
<a name="ln2585">			char str[256];</a>
<a name="ln2586">			sprintf(str, &quot;%d&quot;, sortIndex + 1);</a>
<a name="ln2587">			const float w = view-&gt;StringWidth(str);</a>
<a name="ln2588">			upperLeft.x -= w;</a>
<a name="ln2589"> </a>
<a name="ln2590">			view-&gt;SetDrawingMode(B_OP_COPY);</a>
<a name="ln2591">			view-&gt;MovePenTo(BPoint(upperLeft.x + kSortIndicatorWidth,</a>
<a name="ln2592">				baseline));</a>
<a name="ln2593">			view-&gt;DrawString(str);</a>
<a name="ln2594">		}</a>
<a name="ln2595"> </a>
<a name="ln2596">		float bmh = fDownSortArrow-&gt;Bounds().Height()+1;</a>
<a name="ln2597"> </a>
<a name="ln2598">		view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln2599"> </a>
<a name="ln2600">		if (column-&gt;fSortAscending) {</a>
<a name="ln2601">			BPoint leftTop(upperLeft.x, drawRect.top + (drawRect.IntegerHeight()</a>
<a name="ln2602">				- fDownSortArrow-&gt;Bounds().IntegerHeight()) / 2);</a>
<a name="ln2603">			view-&gt;DrawBitmapAsync(fDownSortArrow, leftTop);</a>
<a name="ln2604">		} else {</a>
<a name="ln2605">			BPoint leftTop(upperLeft.x, drawRect.top + (drawRect.IntegerHeight()</a>
<a name="ln2606">				- fUpSortArrow-&gt;Bounds().IntegerHeight()) / 2);</a>
<a name="ln2607">			view-&gt;DrawBitmapAsync(fUpSortArrow, leftTop);</a>
<a name="ln2608">		}</a>
<a name="ln2609"> </a>
<a name="ln2610">		upperLeft.y = baseline - bmh + floor((fh.ascent + fh.descent - bmh) / 2);</a>
<a name="ln2611">		if (upperLeft.y &lt; drawRect.top)</a>
<a name="ln2612">			upperLeft.y = drawRect.top;</a>
<a name="ln2613"> </a>
<a name="ln2614">		// Adjust title stuff for sort indicator</a>
<a name="ln2615">		drawRect.right = upperLeft.x - 2;</a>
<a name="ln2616">	}</a>
<a name="ln2617"> </a>
<a name="ln2618">	if (drawRect.right &gt; drawRect.left) {</a>
<a name="ln2619">#if CONSTRAIN_CLIPPING_REGION</a>
<a name="ln2620">		BRegion clipRegion(drawRect);</a>
<a name="ln2621">		view-&gt;PushState();</a>
<a name="ln2622">		view-&gt;ConstrainClippingRegion(&amp;clipRegion);</a>
<a name="ln2623">#endif</a>
<a name="ln2624">		view-&gt;MovePenTo(BPoint(drawRect.left + 8, baseline));</a>
<a name="ln2625">		view-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln2626">		view-&gt;SetHighColor(fMasterView-&gt;Color(B_COLOR_HEADER_TEXT));</a>
<a name="ln2627">		column-&gt;DrawTitle(drawRect, view);</a>
<a name="ln2628"> </a>
<a name="ln2629">#if CONSTRAIN_CLIPPING_REGION</a>
<a name="ln2630">		view-&gt;PopState();</a>
<a name="ln2631">#endif</a>
<a name="ln2632">	}</a>
<a name="ln2633">}</a>
<a name="ln2634"> </a>
<a name="ln2635"> </a>
<a name="ln2636">float</a>
<a name="ln2637">TitleView::_VirtualWidth() const</a>
<a name="ln2638">{</a>
<a name="ln2639">	float width = MarginWidth();</a>
<a name="ln2640"> </a>
<a name="ln2641">	int32 count = fColumns-&gt;CountItems();</a>
<a name="ln2642">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2643">		BColumn* column = reinterpret_cast&lt;BColumn*&gt;(fColumns-&gt;ItemAt(i));</a>
<a name="ln2644">		if (column-&gt;IsVisible())</a>
<a name="ln2645">			width += column-&gt;Width();</a>
<a name="ln2646">	}</a>
<a name="ln2647"> </a>
<a name="ln2648">	return width;</a>
<a name="ln2649">}</a>
<a name="ln2650"> </a>
<a name="ln2651"> </a>
<a name="ln2652">void</a>
<a name="ln2653">TitleView::Draw(BRect invalidRect)</a>
<a name="ln2654">{</a>
<a name="ln2655">	float columnLeftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());</a>
<a name="ln2656">	for (int32 columnIndex = 0; columnIndex &lt; fColumns-&gt;CountItems();</a>
<a name="ln2657">		columnIndex++) {</a>
<a name="ln2658"> </a>
<a name="ln2659">		BColumn* column = (BColumn*) fColumns-&gt;ItemAt(columnIndex);</a>
<a name="ln2660">		if (!column-&gt;IsVisible())</a>
<a name="ln2661">			continue;</a>
<a name="ln2662"> </a>
<a name="ln2663">		if (columnLeftEdge &gt; invalidRect.right)</a>
<a name="ln2664">			break;</a>
<a name="ln2665"> </a>
<a name="ln2666">		if (columnLeftEdge + column-&gt;Width() &gt;= invalidRect.left) {</a>
<a name="ln2667">			BRect titleRect(columnLeftEdge, 0,</a>
<a name="ln2668">				columnLeftEdge + column-&gt;Width(), fVisibleRect.Height());</a>
<a name="ln2669">			DrawTitle(this, titleRect, column,</a>
<a name="ln2670">				(fCurrentState == DRAG_COLUMN_INSIDE_TITLE</a>
<a name="ln2671">				&amp;&amp; fSelectedColumn == column));</a>
<a name="ln2672">		}</a>
<a name="ln2673"> </a>
<a name="ln2674">		columnLeftEdge += column-&gt;Width() + 1;</a>
<a name="ln2675">	}</a>
<a name="ln2676"> </a>
<a name="ln2677"> </a>
<a name="ln2678">	// bevels for right title margin</a>
<a name="ln2679">	if (columnLeftEdge &lt;= invalidRect.right) {</a>
<a name="ln2680">		BRect titleRect(columnLeftEdge, 0, Bounds().right + 2,</a>
<a name="ln2681">			fVisibleRect.Height());</a>
<a name="ln2682">		DrawTitle(this, titleRect, NULL, false);</a>
<a name="ln2683">	}</a>
<a name="ln2684"> </a>
<a name="ln2685">	// bevels for left title margin</a>
<a name="ln2686">	if (invalidRect.left &lt; MAX(kLeftMargin, fMasterView-&gt;LatchWidth())) {</a>
<a name="ln2687">		BRect titleRect(0, 0, MAX(kLeftMargin, fMasterView-&gt;LatchWidth()) - 1,</a>
<a name="ln2688">			fVisibleRect.Height());</a>
<a name="ln2689">		DrawTitle(this, titleRect, NULL, false);</a>
<a name="ln2690">	}</a>
<a name="ln2691"> </a>
<a name="ln2692">#if DRAG_TITLE_OUTLINE</a>
<a name="ln2693">	// (internal) column drag indicator</a>
<a name="ln2694">	if (fCurrentState == DRAG_COLUMN_INSIDE_TITLE) {</a>
<a name="ln2695">		BRect dragRect(fSelectedColumnRect);</a>
<a name="ln2696">		dragRect.OffsetTo(fCurrentDragPosition.x - fClickPoint.x, 0);</a>
<a name="ln2697">		if (dragRect.Intersects(invalidRect)) {</a>
<a name="ln2698">			SetHighColor(0, 0, 255);</a>
<a name="ln2699">			StrokeRect(dragRect);</a>
<a name="ln2700">		}</a>
<a name="ln2701">	}</a>
<a name="ln2702">#endif</a>
<a name="ln2703">}</a>
<a name="ln2704"> </a>
<a name="ln2705"> </a>
<a name="ln2706">void</a>
<a name="ln2707">TitleView::ScrollTo(BPoint position)</a>
<a name="ln2708">{</a>
<a name="ln2709">	fOutlineView-&gt;ScrollBy(position.x - fVisibleRect.left, 0);</a>
<a name="ln2710">	fVisibleRect.OffsetTo(position.x, position.y);</a>
<a name="ln2711"> </a>
<a name="ln2712">	// Perform the little trick if the user is scrolled over too far.</a>
<a name="ln2713">	// See OutlineView::ScrollTo for a more in depth explanation</a>
<a name="ln2714">	float maxScrollBarValue = _VirtualWidth() - fVisibleRect.Width();</a>
<a name="ln2715">	BScrollBar* hScrollBar = ScrollBar(B_HORIZONTAL);</a>
<a name="ln2716">	float min, max;</a>
<a name="ln2717">	hScrollBar-&gt;GetRange(&amp;min, &amp;max);</a>
<a name="ln2718">	if (max != maxScrollBarValue &amp;&amp; position.x &gt; maxScrollBarValue)</a>
<a name="ln2719">		FixScrollBar(true);</a>
<a name="ln2720"> </a>
<a name="ln2721">	_inherited::ScrollTo(position);</a>
<a name="ln2722">}</a>
<a name="ln2723"> </a>
<a name="ln2724"> </a>
<a name="ln2725">void</a>
<a name="ln2726">TitleView::MessageReceived(BMessage* message)</a>
<a name="ln2727">{</a>
<a name="ln2728">	if (message-&gt;what == kToggleColumn) {</a>
<a name="ln2729">		int32 num;</a>
<a name="ln2730">		if (message-&gt;FindInt32(&quot;be:field_num&quot;, &amp;num) == B_OK) {</a>
<a name="ln2731">			for (int index = 0; index &lt; fColumns-&gt;CountItems(); index++) {</a>
<a name="ln2732">				BColumn* column = (BColumn*) fColumns-&gt;ItemAt(index);</a>
<a name="ln2733">				if (column == NULL)</a>
<a name="ln2734">					continue;</a>
<a name="ln2735"> </a>
<a name="ln2736">				if (column-&gt;LogicalFieldNum() == num)</a>
<a name="ln2737">					column-&gt;SetVisible(!column-&gt;IsVisible());</a>
<a name="ln2738">			}</a>
<a name="ln2739">		}</a>
<a name="ln2740">		return;</a>
<a name="ln2741">	}</a>
<a name="ln2742"> </a>
<a name="ln2743">	BView::MessageReceived(message);</a>
<a name="ln2744">}</a>
<a name="ln2745"> </a>
<a name="ln2746"> </a>
<a name="ln2747">void</a>
<a name="ln2748">TitleView::MouseDown(BPoint position)</a>
<a name="ln2749">{</a>
<a name="ln2750">	if (fEditMode)</a>
<a name="ln2751">		return;</a>
<a name="ln2752"> </a>
<a name="ln2753">	int32 buttons = 1;</a>
<a name="ln2754">	Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons);</a>
<a name="ln2755">	if (buttons == B_SECONDARY_MOUSE_BUTTON</a>
<a name="ln2756">		&amp;&amp; (fColumnFlags &amp; B_ALLOW_COLUMN_POPUP)) {</a>
<a name="ln2757">		// Right mouse button -- bring up menu to show/hide columns.</a>
<a name="ln2758">		if (fColumnPop == NULL)</a>
<a name="ln2759">			fColumnPop = new BPopUpMenu(&quot;Columns&quot;, false, false);</a>
<a name="ln2760"> </a>
<a name="ln2761">		fColumnPop-&gt;RemoveItems(0, fColumnPop-&gt;CountItems(), true);</a>
<a name="ln2762">		BMessenger me(this);</a>
<a name="ln2763">		for (int index = 0; index &lt; fColumns-&gt;CountItems(); index++) {</a>
<a name="ln2764">			BColumn* column = (BColumn*) fColumns-&gt;ItemAt(index);</a>
<a name="ln2765">			if (column == NULL)</a>
<a name="ln2766">				continue;</a>
<a name="ln2767"> </a>
<a name="ln2768">			BString name;</a>
<a name="ln2769">			column-&gt;GetColumnName(&amp;name);</a>
<a name="ln2770">			BMessage* message = new BMessage(kToggleColumn);</a>
<a name="ln2771">			message-&gt;AddInt32(&quot;be:field_num&quot;, column-&gt;LogicalFieldNum());</a>
<a name="ln2772">			BMenuItem* item = new BMenuItem(name.String(), message);</a>
<a name="ln2773">			item-&gt;SetMarked(column-&gt;IsVisible());</a>
<a name="ln2774">			item-&gt;SetTarget(me);</a>
<a name="ln2775">			fColumnPop-&gt;AddItem(item);</a>
<a name="ln2776">		}</a>
<a name="ln2777"> </a>
<a name="ln2778">		BPoint screenPosition = ConvertToScreen(position);</a>
<a name="ln2779">		BRect sticky(screenPosition, screenPosition);</a>
<a name="ln2780">		sticky.InsetBy(-5, -5);</a>
<a name="ln2781">		fColumnPop-&gt;Go(ConvertToScreen(position), true, false, sticky, true);</a>
<a name="ln2782"> </a>
<a name="ln2783">		return;</a>
<a name="ln2784">	}</a>
<a name="ln2785"> </a>
<a name="ln2786">	fResizingFirstColumn = true;</a>
<a name="ln2787">	float leftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());</a>
<a name="ln2788">	for (int index = 0; index &lt; fColumns-&gt;CountItems(); index++) {</a>
<a name="ln2789">		BColumn* column = (BColumn*)fColumns-&gt;ItemAt(index);</a>
<a name="ln2790">		if (column == NULL || !column-&gt;IsVisible())</a>
<a name="ln2791">			continue;</a>
<a name="ln2792"> </a>
<a name="ln2793">		if (leftEdge &gt; position.x + kColumnResizeAreaWidth / 2)</a>
<a name="ln2794">			break;</a>
<a name="ln2795"> </a>
<a name="ln2796">		// check for resizing a column</a>
<a name="ln2797">		float rightEdge = leftEdge + column-&gt;Width();</a>
<a name="ln2798"> </a>
<a name="ln2799">		if (column-&gt;ShowHeading()) {</a>
<a name="ln2800">			if (position.x &gt; rightEdge - kColumnResizeAreaWidth / 2</a>
<a name="ln2801">				&amp;&amp; position.x &lt; rightEdge + kColumnResizeAreaWidth / 2</a>
<a name="ln2802">				&amp;&amp; column-&gt;MaxWidth() &gt; column-&gt;MinWidth()</a>
<a name="ln2803">				&amp;&amp; (fColumnFlags &amp; B_ALLOW_COLUMN_RESIZE) != 0) {</a>
<a name="ln2804"> </a>
<a name="ln2805">				int32 clicks = 0;</a>
<a name="ln2806">				fSelectedColumn = column;</a>
<a name="ln2807">				fSelectedColumnRect.Set(leftEdge, 0, rightEdge,</a>
<a name="ln2808">					fVisibleRect.Height());</a>
<a name="ln2809">				Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;clicks&quot;, &amp;clicks);</a>
<a name="ln2810">				if (clicks == 2 || buttons == B_TERTIARY_MOUSE_BUTTON) {</a>
<a name="ln2811">					ResizeSelectedColumn(position, true);</a>
<a name="ln2812">					fCurrentState = INACTIVE;</a>
<a name="ln2813">					break;</a>
<a name="ln2814">				}</a>
<a name="ln2815">				fCurrentState = RESIZING_COLUMN;</a>
<a name="ln2816">				fClickPoint = BPoint(position.x - rightEdge - 1,</a>
<a name="ln2817">					position.y - fSelectedColumnRect.top);</a>
<a name="ln2818">				SetMouseEventMask(B_POINTER_EVENTS,</a>
<a name="ln2819">					B_LOCK_WINDOW_FOCUS | B_NO_POINTER_HISTORY);</a>
<a name="ln2820">				break;</a>
<a name="ln2821">			}</a>
<a name="ln2822"> </a>
<a name="ln2823">			fResizingFirstColumn = false;</a>
<a name="ln2824"> </a>
<a name="ln2825">			// check for clicking on a column</a>
<a name="ln2826">			if (position.x &gt; leftEdge &amp;&amp; position.x &lt; rightEdge) {</a>
<a name="ln2827">				fCurrentState = PRESSING_COLUMN;</a>
<a name="ln2828">				fSelectedColumn = column;</a>
<a name="ln2829">				fSelectedColumnRect.Set(leftEdge, 0, rightEdge,</a>
<a name="ln2830">					fVisibleRect.Height());</a>
<a name="ln2831">				DrawTitle(this, fSelectedColumnRect, fSelectedColumn, true);</a>
<a name="ln2832">				fClickPoint = BPoint(position.x - fSelectedColumnRect.left,</a>
<a name="ln2833">					position.y - fSelectedColumnRect.top);</a>
<a name="ln2834">				SetMouseEventMask(B_POINTER_EVENTS,</a>
<a name="ln2835">					B_LOCK_WINDOW_FOCUS | B_NO_POINTER_HISTORY);</a>
<a name="ln2836">				break;</a>
<a name="ln2837">			}</a>
<a name="ln2838">		}</a>
<a name="ln2839">		leftEdge = rightEdge + 1;</a>
<a name="ln2840">	}</a>
<a name="ln2841">}</a>
<a name="ln2842"> </a>
<a name="ln2843"> </a>
<a name="ln2844">void</a>
<a name="ln2845">TitleView::MouseMoved(BPoint position, uint32 transit,</a>
<a name="ln2846">	const BMessage* dragMessage)</a>
<a name="ln2847">{</a>
<a name="ln2848">	if (fEditMode)</a>
<a name="ln2849">		return;</a>
<a name="ln2850"> </a>
<a name="ln2851">	// Handle column manipulation</a>
<a name="ln2852">	switch (fCurrentState) {</a>
<a name="ln2853">		case RESIZING_COLUMN:</a>
<a name="ln2854">			ResizeSelectedColumn(position - BPoint(fClickPoint.x, 0));</a>
<a name="ln2855">			break;</a>
<a name="ln2856"> </a>
<a name="ln2857">		case PRESSING_COLUMN: {</a>
<a name="ln2858">			if (abs((int32)(position.x - (fClickPoint.x</a>
<a name="ln2859">					+ fSelectedColumnRect.left))) &gt; kColumnResizeAreaWidth</a>
<a name="ln2860">				|| abs((int32)(position.y - (fClickPoint.y</a>
<a name="ln2861">					+ fSelectedColumnRect.top))) &gt; kColumnResizeAreaWidth) {</a>
<a name="ln2862">				// User has moved the mouse more than the tolerable amount,</a>
<a name="ln2863">				// initiate a drag.</a>
<a name="ln2864">				if (transit == B_INSIDE_VIEW || transit == B_ENTERED_VIEW) {</a>
<a name="ln2865">					if(fColumnFlags &amp; B_ALLOW_COLUMN_MOVE) {</a>
<a name="ln2866">						fCurrentState = DRAG_COLUMN_INSIDE_TITLE;</a>
<a name="ln2867">						ComputeDragBoundries(fSelectedColumn, position);</a>
<a name="ln2868">						SetViewCursor(fColumnMoveCursor, true);</a>
<a name="ln2869">#if DRAG_TITLE_OUTLINE</a>
<a name="ln2870">						BRect invalidRect(fSelectedColumnRect);</a>
<a name="ln2871">						invalidRect.OffsetTo(position.x - fClickPoint.x, 0);</a>
<a name="ln2872">						fCurrentDragPosition = position;</a>
<a name="ln2873">						Invalidate(invalidRect);</a>
<a name="ln2874">#endif</a>
<a name="ln2875">					}</a>
<a name="ln2876">				} else {</a>
<a name="ln2877">					if(fColumnFlags &amp; B_ALLOW_COLUMN_REMOVE) {</a>
<a name="ln2878">						// Dragged outside view</a>
<a name="ln2879">						fCurrentState = DRAG_COLUMN_OUTSIDE_TITLE;</a>
<a name="ln2880">						fSelectedColumn-&gt;SetVisible(false);</a>
<a name="ln2881">						BRect dragRect(fSelectedColumnRect);</a>
<a name="ln2882"> </a>
<a name="ln2883">						// There is a race condition where the mouse may have</a>
<a name="ln2884">						// moved by the time we get to handle this message.</a>
<a name="ln2885">						// If the user drags a column very quickly, this</a>
<a name="ln2886">						// results in the annoying bug where the cursor is</a>
<a name="ln2887">						// outside of the rectangle that is being dragged</a>
<a name="ln2888">						// around.  Call GetMouse with the checkQueue flag set</a>
<a name="ln2889">						// to false so we can get the most recent position of</a>
<a name="ln2890">						// the mouse.  This minimizes this problem (although</a>
<a name="ln2891">						// it is currently not possible to completely eliminate</a>
<a name="ln2892">						// it).</a>
<a name="ln2893">						uint32 buttons;</a>
<a name="ln2894">						GetMouse(&amp;position, &amp;buttons, false);</a>
<a name="ln2895">						dragRect.OffsetTo(position.x - fClickPoint.x,</a>
<a name="ln2896">							position.y - dragRect.Height() / 2);</a>
<a name="ln2897">						BeginRectTracking(dragRect, B_TRACK_WHOLE_RECT);</a>
<a name="ln2898">					}</a>
<a name="ln2899">				}</a>
<a name="ln2900">			}</a>
<a name="ln2901"> </a>
<a name="ln2902">			break;</a>
<a name="ln2903">		}</a>
<a name="ln2904"> </a>
<a name="ln2905">		case DRAG_COLUMN_INSIDE_TITLE: {</a>
<a name="ln2906">			if (transit == B_EXITED_VIEW</a>
<a name="ln2907">				&amp;&amp; (fColumnFlags &amp; B_ALLOW_COLUMN_REMOVE)) {</a>
<a name="ln2908">				// Dragged outside view</a>
<a name="ln2909">				fCurrentState = DRAG_COLUMN_OUTSIDE_TITLE;</a>
<a name="ln2910">				fSelectedColumn-&gt;SetVisible(false);</a>
<a name="ln2911">				BRect dragRect(fSelectedColumnRect);</a>
<a name="ln2912"> </a>
<a name="ln2913">				// See explanation above.</a>
<a name="ln2914">				uint32 buttons;</a>
<a name="ln2915">				GetMouse(&amp;position, &amp;buttons, false);</a>
<a name="ln2916"> </a>
<a name="ln2917">				dragRect.OffsetTo(position.x - fClickPoint.x,</a>
<a name="ln2918">					position.y - fClickPoint.y);</a>
<a name="ln2919">				BeginRectTracking(dragRect, B_TRACK_WHOLE_RECT);</a>
<a name="ln2920">			} else if (position.x &lt; fLeftDragBoundry</a>
<a name="ln2921">				|| position.x &gt; fRightDragBoundry) {</a>
<a name="ln2922">				DragSelectedColumn(position - BPoint(fClickPoint.x, 0));</a>
<a name="ln2923">			}</a>
<a name="ln2924"> </a>
<a name="ln2925">#if DRAG_TITLE_OUTLINE</a>
<a name="ln2926">			// Set up the invalid rect to include the rect for the previous</a>
<a name="ln2927">			// position of the drag rect, as well as the new one.</a>
<a name="ln2928">			BRect invalidRect(fSelectedColumnRect);</a>
<a name="ln2929">			invalidRect.OffsetTo(fCurrentDragPosition.x - fClickPoint.x, 0);</a>
<a name="ln2930">			if (position.x &lt; fCurrentDragPosition.x)</a>
<a name="ln2931">				invalidRect.left -= fCurrentDragPosition.x - position.x;</a>
<a name="ln2932">			else</a>
<a name="ln2933">				invalidRect.right += position.x - fCurrentDragPosition.x;</a>
<a name="ln2934"> </a>
<a name="ln2935">			fCurrentDragPosition = position;</a>
<a name="ln2936">			Invalidate(invalidRect);</a>
<a name="ln2937">#endif</a>
<a name="ln2938">			break;</a>
<a name="ln2939">		}</a>
<a name="ln2940"> </a>
<a name="ln2941">		case DRAG_COLUMN_OUTSIDE_TITLE:</a>
<a name="ln2942">			if (transit == B_ENTERED_VIEW) {</a>
<a name="ln2943">				// Drag back into view</a>
<a name="ln2944">				EndRectTracking();</a>
<a name="ln2945">				fCurrentState = DRAG_COLUMN_INSIDE_TITLE;</a>
<a name="ln2946">				fSelectedColumn-&gt;SetVisible(true);</a>
<a name="ln2947">				DragSelectedColumn(position - BPoint(fClickPoint.x, 0));</a>
<a name="ln2948">			}</a>
<a name="ln2949"> </a>
<a name="ln2950">			break;</a>
<a name="ln2951"> </a>
<a name="ln2952">		case INACTIVE:</a>
<a name="ln2953">			// Check for cursor changes if we are over the resize area for</a>
<a name="ln2954">			// a column.</a>
<a name="ln2955">			BColumn* resizeColumn = 0;</a>
<a name="ln2956">			float leftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());</a>
<a name="ln2957">			for (int index = 0; index &lt; fColumns-&gt;CountItems(); index++) {</a>
<a name="ln2958">				BColumn* column = (BColumn*) fColumns-&gt;ItemAt(index);</a>
<a name="ln2959">				if (!column-&gt;IsVisible())</a>
<a name="ln2960">					continue;</a>
<a name="ln2961"> </a>
<a name="ln2962">				if (leftEdge &gt; position.x + kColumnResizeAreaWidth / 2)</a>
<a name="ln2963">					break;</a>
<a name="ln2964"> </a>
<a name="ln2965">				float rightEdge = leftEdge + column-&gt;Width();</a>
<a name="ln2966">				if (position.x &gt; rightEdge - kColumnResizeAreaWidth / 2</a>
<a name="ln2967">					&amp;&amp; position.x &lt; rightEdge + kColumnResizeAreaWidth / 2</a>
<a name="ln2968">					&amp;&amp; column-&gt;MaxWidth() &gt; column-&gt;MinWidth()) {</a>
<a name="ln2969">					resizeColumn = column;</a>
<a name="ln2970">					break;</a>
<a name="ln2971">				}</a>
<a name="ln2972"> </a>
<a name="ln2973">				leftEdge = rightEdge + 1;</a>
<a name="ln2974">			}</a>
<a name="ln2975"> </a>
<a name="ln2976">			// Update the cursor</a>
<a name="ln2977">			if (resizeColumn) {</a>
<a name="ln2978">				if (resizeColumn-&gt;Width() == resizeColumn-&gt;MinWidth())</a>
<a name="ln2979">					SetViewCursor(fMinResizeCursor, true);</a>
<a name="ln2980">				else if (resizeColumn-&gt;Width() == resizeColumn-&gt;MaxWidth())</a>
<a name="ln2981">					SetViewCursor(fMaxResizeCursor, true);</a>
<a name="ln2982">				else</a>
<a name="ln2983">					SetViewCursor(fResizeCursor, true);</a>
<a name="ln2984">			} else</a>
<a name="ln2985">				SetViewCursor(B_CURSOR_SYSTEM_DEFAULT, true);</a>
<a name="ln2986">			break;</a>
<a name="ln2987">	}</a>
<a name="ln2988">}</a>
<a name="ln2989"> </a>
<a name="ln2990"> </a>
<a name="ln2991">void</a>
<a name="ln2992">TitleView::MouseUp(BPoint position)</a>
<a name="ln2993">{</a>
<a name="ln2994">	if (fEditMode)</a>
<a name="ln2995">		return;</a>
<a name="ln2996"> </a>
<a name="ln2997">	switch (fCurrentState) {</a>
<a name="ln2998">		case RESIZING_COLUMN:</a>
<a name="ln2999">			ResizeSelectedColumn(position - BPoint(fClickPoint.x, 0));</a>
<a name="ln3000">			fCurrentState = INACTIVE;</a>
<a name="ln3001">			FixScrollBar(false);</a>
<a name="ln3002">			break;</a>
<a name="ln3003"> </a>
<a name="ln3004">		case PRESSING_COLUMN: {</a>
<a name="ln3005">			if (fMasterView-&gt;SortingEnabled()) {</a>
<a name="ln3006">				if (fSortColumns-&gt;HasItem(fSelectedColumn)) {</a>
<a name="ln3007">					if ((modifiers() &amp; B_CONTROL_KEY) == 0</a>
<a name="ln3008">						&amp;&amp; fSortColumns-&gt;CountItems() &gt; 1) {</a>
<a name="ln3009">						fSortColumns-&gt;MakeEmpty();</a>
<a name="ln3010">						fSortColumns-&gt;AddItem(fSelectedColumn);</a>
<a name="ln3011">					}</a>
<a name="ln3012"> </a>
<a name="ln3013">					fSelectedColumn-&gt;fSortAscending</a>
<a name="ln3014">						= !fSelectedColumn-&gt;fSortAscending;</a>
<a name="ln3015">				} else {</a>
<a name="ln3016">					if ((modifiers() &amp; B_CONTROL_KEY) == 0)</a>
<a name="ln3017">						fSortColumns-&gt;MakeEmpty();</a>
<a name="ln3018"> </a>
<a name="ln3019">					fSortColumns-&gt;AddItem(fSelectedColumn);</a>
<a name="ln3020">					fSelectedColumn-&gt;fSortAscending = true;</a>
<a name="ln3021">				}</a>
<a name="ln3022"> </a>
<a name="ln3023">				fOutlineView-&gt;StartSorting();</a>
<a name="ln3024">			}</a>
<a name="ln3025"> </a>
<a name="ln3026">			fCurrentState = INACTIVE;</a>
<a name="ln3027">			Invalidate();</a>
<a name="ln3028">			break;</a>
<a name="ln3029">		}</a>
<a name="ln3030"> </a>
<a name="ln3031">		case DRAG_COLUMN_INSIDE_TITLE:</a>
<a name="ln3032">			fCurrentState = INACTIVE;</a>
<a name="ln3033"> </a>
<a name="ln3034">#if DRAG_TITLE_OUTLINE</a>
<a name="ln3035">			Invalidate();	// xxx Can make this smaller</a>
<a name="ln3036">#else</a>
<a name="ln3037">			Invalidate(fSelectedColumnRect);</a>
<a name="ln3038">#endif</a>
<a name="ln3039">			SetViewCursor(B_CURSOR_SYSTEM_DEFAULT, true);</a>
<a name="ln3040">			break;</a>
<a name="ln3041"> </a>
<a name="ln3042">		case DRAG_COLUMN_OUTSIDE_TITLE:</a>
<a name="ln3043">			fCurrentState = INACTIVE;</a>
<a name="ln3044">			EndRectTracking();</a>
<a name="ln3045">			SetViewCursor(B_CURSOR_SYSTEM_DEFAULT, true);</a>
<a name="ln3046">			break;</a>
<a name="ln3047"> </a>
<a name="ln3048">		default:</a>
<a name="ln3049">			;</a>
<a name="ln3050">	}</a>
<a name="ln3051">}</a>
<a name="ln3052"> </a>
<a name="ln3053"> </a>
<a name="ln3054">void</a>
<a name="ln3055">TitleView::FrameResized(float width, float height)</a>
<a name="ln3056">{</a>
<a name="ln3057">	fVisibleRect.right = fVisibleRect.left + width;</a>
<a name="ln3058">	fVisibleRect.bottom = fVisibleRect.top + height;</a>
<a name="ln3059">	FixScrollBar(true);</a>
<a name="ln3060">}</a>
<a name="ln3061"> </a>
<a name="ln3062"> </a>
<a name="ln3063">// #pragma mark - OutlineView</a>
<a name="ln3064"> </a>
<a name="ln3065"> </a>
<a name="ln3066">OutlineView::OutlineView(BRect rect, BList* visibleColumns, BList* sortColumns,</a>
<a name="ln3067">	BColumnListView* listView)</a>
<a name="ln3068">	:</a>
<a name="ln3069">	BView(rect, &quot;outline_view&quot;, B_FOLLOW_ALL_SIDES,</a>
<a name="ln3070">		B_WILL_DRAW | B_FRAME_EVENTS),</a>
<a name="ln3071">	fColumns(visibleColumns),</a>
<a name="ln3072">	fSortColumns(sortColumns),</a>
<a name="ln3073">	fItemsHeight(0.0),</a>
<a name="ln3074">	fVisibleRect(rect.OffsetToCopy(0, 0)),</a>
<a name="ln3075">	fFocusRow(0),</a>
<a name="ln3076">	fRollOverRow(0),</a>
<a name="ln3077">	fLastSelectedItem(0),</a>
<a name="ln3078">	fFirstSelectedItem(0),</a>
<a name="ln3079">	fSortThread(B_BAD_THREAD_ID),</a>
<a name="ln3080">	fCurrentState(INACTIVE),</a>
<a name="ln3081">	fMasterView(listView),</a>
<a name="ln3082">	fSelectionMode(B_MULTIPLE_SELECTION_LIST),</a>
<a name="ln3083">	fTrackMouse(false),</a>
<a name="ln3084">	fCurrentField(0),</a>
<a name="ln3085">	fCurrentRow(0),</a>
<a name="ln3086">	fCurrentColumn(0),</a>
<a name="ln3087">	fMouseDown(false),</a>
<a name="ln3088">	fCurrentCode(B_OUTSIDE_VIEW),</a>
<a name="ln3089">	fEditMode(false),</a>
<a name="ln3090">	fDragging(false),</a>
<a name="ln3091">	fClickCount(0),</a>
<a name="ln3092">	fDropHighlightY(-1)</a>
<a name="ln3093">{</a>
<a name="ln3094">	SetViewColor(B_TRANSPARENT_COLOR);</a>
<a name="ln3095"> </a>
<a name="ln3096">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln3097">	// TODO: This needs to be smart about the size of the buffer.</a>
<a name="ln3098">	// Also, the buffer can be shared with the title's buffer.</a>
<a name="ln3099">	BRect doubleBufferRect(0, 0, 600, 35);</a>
<a name="ln3100">	fDrawBuffer = new BBitmap(doubleBufferRect, B_RGB32, true);</a>
<a name="ln3101">	fDrawBufferView = new BView(doubleBufferRect, &quot;double_buffer_view&quot;,</a>
<a name="ln3102">		B_FOLLOW_ALL_SIDES, 0);</a>
<a name="ln3103">	fDrawBuffer-&gt;Lock();</a>
<a name="ln3104">	fDrawBuffer-&gt;AddChild(fDrawBufferView);</a>
<a name="ln3105">	fDrawBuffer-&gt;Unlock();</a>
<a name="ln3106">#endif</a>
<a name="ln3107"> </a>
<a name="ln3108">	FixScrollBar(true);</a>
<a name="ln3109">	fSelectionListDummyHead.fNextSelected = &amp;fSelectionListDummyHead;</a>
<a name="ln3110">	fSelectionListDummyHead.fPrevSelected = &amp;fSelectionListDummyHead;</a>
<a name="ln3111">}</a>
<a name="ln3112"> </a>
<a name="ln3113"> </a>
<a name="ln3114">OutlineView::~OutlineView()</a>
<a name="ln3115">{</a>
<a name="ln3116">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln3117">	delete fDrawBuffer;</a>
<a name="ln3118">#endif</a>
<a name="ln3119"> </a>
<a name="ln3120">	Clear();</a>
<a name="ln3121">}</a>
<a name="ln3122"> </a>
<a name="ln3123"> </a>
<a name="ln3124">void</a>
<a name="ln3125">OutlineView::Clear()</a>
<a name="ln3126">{</a>
<a name="ln3127">	DeselectAll();</a>
<a name="ln3128">		// Make sure selection list doesn't point to deleted rows!</a>
<a name="ln3129">	RecursiveDeleteRows(&amp;fRows, false);</a>
<a name="ln3130">	fItemsHeight = 0.0;</a>
<a name="ln3131">	FixScrollBar(true);</a>
<a name="ln3132">	Invalidate();</a>
<a name="ln3133">}</a>
<a name="ln3134"> </a>
<a name="ln3135"> </a>
<a name="ln3136">void</a>
<a name="ln3137">OutlineView::SetSelectionMode(list_view_type mode)</a>
<a name="ln3138">{</a>
<a name="ln3139">	DeselectAll();</a>
<a name="ln3140">	fSelectionMode = mode;</a>
<a name="ln3141">}</a>
<a name="ln3142"> </a>
<a name="ln3143"> </a>
<a name="ln3144">list_view_type</a>
<a name="ln3145">OutlineView::SelectionMode() const</a>
<a name="ln3146">{</a>
<a name="ln3147">	return fSelectionMode;</a>
<a name="ln3148">}</a>
<a name="ln3149"> </a>
<a name="ln3150"> </a>
<a name="ln3151">void</a>
<a name="ln3152">OutlineView::Deselect(BRow* row)</a>
<a name="ln3153">{</a>
<a name="ln3154">	if (row == NULL)</a>
<a name="ln3155">		return;</a>
<a name="ln3156"> </a>
<a name="ln3157">	if (row-&gt;fNextSelected != 0) {</a>
<a name="ln3158">		row-&gt;fNextSelected-&gt;fPrevSelected = row-&gt;fPrevSelected;</a>
<a name="ln3159">		row-&gt;fPrevSelected-&gt;fNextSelected = row-&gt;fNextSelected;</a>
<a name="ln3160">		row-&gt;fNextSelected = 0;</a>
<a name="ln3161">		row-&gt;fPrevSelected = 0;</a>
<a name="ln3162">		Invalidate();</a>
<a name="ln3163">	}</a>
<a name="ln3164">}</a>
<a name="ln3165"> </a>
<a name="ln3166"> </a>
<a name="ln3167">void</a>
<a name="ln3168">OutlineView::AddToSelection(BRow* row)</a>
<a name="ln3169">{</a>
<a name="ln3170">	if (row == NULL)</a>
<a name="ln3171">		return;</a>
<a name="ln3172"> </a>
<a name="ln3173">	if (row-&gt;fNextSelected == 0) {</a>
<a name="ln3174">		if (fSelectionMode == B_SINGLE_SELECTION_LIST)</a>
<a name="ln3175">			DeselectAll();</a>
<a name="ln3176"> </a>
<a name="ln3177">		row-&gt;fNextSelected = fSelectionListDummyHead.fNextSelected;</a>
<a name="ln3178">		row-&gt;fPrevSelected = &amp;fSelectionListDummyHead;</a>
<a name="ln3179">		row-&gt;fNextSelected-&gt;fPrevSelected = row;</a>
<a name="ln3180">		row-&gt;fPrevSelected-&gt;fNextSelected = row;</a>
<a name="ln3181"> </a>
<a name="ln3182">		BRect invalidRect;</a>
<a name="ln3183">		if (FindVisibleRect(row, &amp;invalidRect))</a>
<a name="ln3184">			Invalidate(invalidRect);</a>
<a name="ln3185">	}</a>
<a name="ln3186">}</a>
<a name="ln3187"> </a>
<a name="ln3188"> </a>
<a name="ln3189">void</a>
<a name="ln3190">OutlineView::RecursiveDeleteRows(BRowContainer* list, bool isOwner)</a>
<a name="ln3191">{</a>
<a name="ln3192">	if (list == NULL)</a>
<a name="ln3193">		return;</a>
<a name="ln3194"> </a>
<a name="ln3195">	while (true) {</a>
<a name="ln3196">		BRow* row = list-&gt;RemoveItemAt(0L);</a>
<a name="ln3197">		if (row == 0)</a>
<a name="ln3198">			break;</a>
<a name="ln3199"> </a>
<a name="ln3200">		if (row-&gt;fChildList)</a>
<a name="ln3201">			RecursiveDeleteRows(row-&gt;fChildList, true);</a>
<a name="ln3202"> </a>
<a name="ln3203">		delete row;</a>
<a name="ln3204">	}</a>
<a name="ln3205"> </a>
<a name="ln3206">	if (isOwner)</a>
<a name="ln3207">		delete list;</a>
<a name="ln3208">}</a>
<a name="ln3209"> </a>
<a name="ln3210"> </a>
<a name="ln3211">void</a>
<a name="ln3212">OutlineView::RedrawColumn(BColumn* column, float leftEdge, bool isFirstColumn)</a>
<a name="ln3213">{</a>
<a name="ln3214">	// TODO: Remove code duplication (private function which takes a view</a>
<a name="ln3215">	// pointer, pass &quot;this&quot; in non-double buffered mode)!</a>
<a name="ln3216">	// Watch out for sourceRect versus destRect though!</a>
<a name="ln3217">	if (!column)</a>
<a name="ln3218">		return;</a>
<a name="ln3219"> </a>
<a name="ln3220">	font_height fh;</a>
<a name="ln3221">	GetFontHeight(&amp;fh);</a>
<a name="ln3222">	float line = 0.0;</a>
<a name="ln3223">	bool tintedLine = true;</a>
<a name="ln3224">	for (RecursiveOutlineIterator iterator(&amp;fRows); iterator.CurrentRow();</a>
<a name="ln3225">		line += iterator.CurrentRow()-&gt;Height() + 1, iterator.GoToNext()) {</a>
<a name="ln3226"> </a>
<a name="ln3227">		BRow* row = iterator.CurrentRow();</a>
<a name="ln3228">		float rowHeight = row-&gt;Height();</a>
<a name="ln3229">		if (line &gt; fVisibleRect.bottom)</a>
<a name="ln3230">			break;</a>
<a name="ln3231">		tintedLine = !tintedLine;</a>
<a name="ln3232"> </a>
<a name="ln3233">		if (line + rowHeight &gt;= fVisibleRect.top) {</a>
<a name="ln3234">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln3235">			BRect sourceRect(0, 0, column-&gt;Width(), rowHeight);</a>
<a name="ln3236">#endif</a>
<a name="ln3237">			BRect destRect(leftEdge, line, leftEdge + column-&gt;Width(),</a>
<a name="ln3238">				line + rowHeight);</a>
<a name="ln3239"> </a>
<a name="ln3240">			rgb_color highColor;</a>
<a name="ln3241">			rgb_color lowColor;</a>
<a name="ln3242">			if (row-&gt;fNextSelected != 0) {</a>
<a name="ln3243">				if (fEditMode) {</a>
<a name="ln3244">					highColor = fMasterView-&gt;Color(B_COLOR_EDIT_BACKGROUND);</a>
<a name="ln3245">					lowColor = fMasterView-&gt;Color(B_COLOR_EDIT_BACKGROUND);</a>
<a name="ln3246">				} else {</a>
<a name="ln3247">					highColor = fMasterView-&gt;Color(B_COLOR_SELECTION);</a>
<a name="ln3248">					lowColor = fMasterView-&gt;Color(B_COLOR_SELECTION);</a>
<a name="ln3249">				}</a>
<a name="ln3250">			} else {</a>
<a name="ln3251">				highColor = fMasterView-&gt;Color(B_COLOR_BACKGROUND);</a>
<a name="ln3252">				lowColor = fMasterView-&gt;Color(B_COLOR_BACKGROUND);</a>
<a name="ln3253">			}</a>
<a name="ln3254">			if (tintedLine)</a>
<a name="ln3255">				lowColor = tint_color(lowColor, kTintedLineTint);</a>
<a name="ln3256"> </a>
<a name="ln3257"> </a>
<a name="ln3258">#if DOUBLE_BUFFERED_COLUMN_RESIZE</a>
<a name="ln3259">			fDrawBuffer-&gt;Lock();</a>
<a name="ln3260"> </a>
<a name="ln3261">			fDrawBufferView-&gt;SetHighColor(highColor);</a>
<a name="ln3262">			fDrawBufferView-&gt;SetLowColor(lowColor);</a>
<a name="ln3263"> </a>
<a name="ln3264">			BFont font;</a>
<a name="ln3265">			GetFont(&amp;font);</a>
<a name="ln3266">			fDrawBufferView-&gt;SetFont(&amp;font);</a>
<a name="ln3267">			fDrawBufferView-&gt;FillRect(sourceRect, B_SOLID_LOW);</a>
<a name="ln3268"> </a>
<a name="ln3269">			if (isFirstColumn) {</a>
<a name="ln3270">				// If this is the first column, double buffer drawing the latch</a>
<a name="ln3271">				// too.</a>
<a name="ln3272">				destRect.left += iterator.CurrentLevel() * kOutlineLevelIndent</a>
<a name="ln3273">					- fMasterView-&gt;LatchWidth();</a>
<a name="ln3274">				sourceRect.left += iterator.CurrentLevel() * kOutlineLevelIndent</a>
<a name="ln3275">					- fMasterView-&gt;LatchWidth();</a>
<a name="ln3276"> </a>
<a name="ln3277">				LatchType pos = B_NO_LATCH;</a>
<a name="ln3278">				if (row-&gt;HasLatch())</a>
<a name="ln3279">					pos = row-&gt;fIsExpanded ? B_OPEN_LATCH : B_CLOSED_LATCH;</a>
<a name="ln3280"> </a>
<a name="ln3281">				BRect latchRect(sourceRect);</a>
<a name="ln3282">				latchRect.right = latchRect.left + fMasterView-&gt;LatchWidth();</a>
<a name="ln3283">				fMasterView-&gt;DrawLatch(fDrawBufferView, latchRect, pos, row);</a>
<a name="ln3284">			}</a>
<a name="ln3285"> </a>
<a name="ln3286">			BField* field = row-&gt;GetField(column-&gt;fFieldID);</a>
<a name="ln3287">			if (field) {</a>
<a name="ln3288">				BRect fieldRect(sourceRect);</a>
<a name="ln3289">				if (isFirstColumn)</a>
<a name="ln3290">					fieldRect.left += fMasterView-&gt;LatchWidth();</a>
<a name="ln3291"> </a>
<a name="ln3292">	#if CONSTRAIN_CLIPPING_REGION</a>
<a name="ln3293">				BRegion clipRegion(fieldRect);</a>
<a name="ln3294">				fDrawBufferView-&gt;PushState();</a>
<a name="ln3295">				fDrawBufferView-&gt;ConstrainClippingRegion(&amp;clipRegion);</a>
<a name="ln3296">	#endif</a>
<a name="ln3297">				fDrawBufferView-&gt;SetHighColor(fMasterView-&gt;Color(</a>
<a name="ln3298">					row-&gt;fNextSelected ? B_COLOR_SELECTION_TEXT</a>
<a name="ln3299">						: B_COLOR_TEXT));</a>
<a name="ln3300">				float baseline = floor(fieldRect.top + fh.ascent</a>
<a name="ln3301">					+ (fieldRect.Height() + 1 - (fh.ascent+fh.descent)) / 2);</a>
<a name="ln3302">				fDrawBufferView-&gt;MovePenTo(fieldRect.left + 8, baseline);</a>
<a name="ln3303">				column-&gt;DrawField(field, fieldRect, fDrawBufferView);</a>
<a name="ln3304">	#if CONSTRAIN_CLIPPING_REGION</a>
<a name="ln3305">				fDrawBufferView-&gt;PopState();</a>
<a name="ln3306">	#endif</a>
<a name="ln3307">			}</a>
<a name="ln3308"> </a>
<a name="ln3309">			if (fFocusRow == row &amp;&amp; !fEditMode &amp;&amp; fMasterView-&gt;IsFocus()</a>
<a name="ln3310">				&amp;&amp; Window()-&gt;IsActive()) {</a>
<a name="ln3311">				fDrawBufferView-&gt;SetHighColor(fMasterView-&gt;Color(</a>
<a name="ln3312">					B_COLOR_ROW_DIVIDER));</a>
<a name="ln3313">				fDrawBufferView-&gt;StrokeRect(BRect(-1, sourceRect.top,</a>
<a name="ln3314">					10000.0, sourceRect.bottom));</a>
<a name="ln3315">			}</a>
<a name="ln3316"> </a>
<a name="ln3317">			fDrawBufferView-&gt;Sync();</a>
<a name="ln3318">			fDrawBuffer-&gt;Unlock();</a>
<a name="ln3319">			SetDrawingMode(B_OP_COPY);</a>
<a name="ln3320">			DrawBitmap(fDrawBuffer, sourceRect, destRect);</a>
<a name="ln3321"> </a>
<a name="ln3322">#else</a>
<a name="ln3323"> </a>
<a name="ln3324">			SetHighColor(highColor);</a>
<a name="ln3325">			SetLowColor(lowColor);</a>
<a name="ln3326">			FillRect(destRect, B_SOLID_LOW);</a>
<a name="ln3327"> </a>
<a name="ln3328">			BField* field = row-&gt;GetField(column-&gt;fFieldID);</a>
<a name="ln3329">			if (field) {</a>
<a name="ln3330">	#if CONSTRAIN_CLIPPING_REGION</a>
<a name="ln3331">				BRegion clipRegion(destRect);</a>
<a name="ln3332">				PushState();</a>
<a name="ln3333">				ConstrainClippingRegion(&amp;clipRegion);</a>
<a name="ln3334">	#endif</a>
<a name="ln3335">				SetHighColor(fMasterView-&gt;Color(row-&gt;fNextSelected</a>
<a name="ln3336">					? B_COLOR_SELECTION_TEXT : B_COLOR_TEXT));</a>
<a name="ln3337">				float baseline = floor(destRect.top + fh.ascent</a>
<a name="ln3338">					+ (destRect.Height() + 1 - (fh.ascent + fh.descent)) / 2);</a>
<a name="ln3339">				MovePenTo(destRect.left + 8, baseline);</a>
<a name="ln3340">				column-&gt;DrawField(field, destRect, this);</a>
<a name="ln3341">	#if CONSTRAIN_CLIPPING_REGION</a>
<a name="ln3342">				PopState();</a>
<a name="ln3343">	#endif</a>
<a name="ln3344">			}</a>
<a name="ln3345"> </a>
<a name="ln3346">			if (fFocusRow == row &amp;&amp; !fEditMode &amp;&amp; fMasterView-&gt;IsFocus()</a>
<a name="ln3347">				&amp;&amp; Window()-&gt;IsActive()) {</a>
<a name="ln3348">				SetHighColor(fMasterView-&gt;Color(B_COLOR_ROW_DIVIDER));</a>
<a name="ln3349">				StrokeRect(BRect(0, destRect.top, 10000.0, destRect.bottom));</a>
<a name="ln3350">			}</a>
<a name="ln3351">#endif</a>
<a name="ln3352">		}</a>
<a name="ln3353">	}</a>
<a name="ln3354">}</a>
<a name="ln3355"> </a>
<a name="ln3356"> </a>
<a name="ln3357">void</a>
<a name="ln3358">OutlineView::Draw(BRect invalidBounds)</a>
<a name="ln3359">{</a>
<a name="ln3360">#if SMART_REDRAW</a>
<a name="ln3361">	BRegion invalidRegion;</a>
<a name="ln3362">	GetClippingRegion(&amp;invalidRegion);</a>
<a name="ln3363">#endif</a>
<a name="ln3364"> </a>
<a name="ln3365">	font_height fh;</a>
<a name="ln3366">	GetFontHeight(&amp;fh);</a>
<a name="ln3367"> </a>
<a name="ln3368">	float line = 0.0;</a>
<a name="ln3369">	bool tintedLine = true;</a>
<a name="ln3370">	int32 numColumns = fColumns-&gt;CountItems();</a>
<a name="ln3371">	for (RecursiveOutlineIterator iterator(&amp;fRows); iterator.CurrentRow();</a>
<a name="ln3372">		iterator.GoToNext()) {</a>
<a name="ln3373">		BRow* row = iterator.CurrentRow();</a>
<a name="ln3374">		if (line &gt; invalidBounds.bottom)</a>
<a name="ln3375">			break;</a>
<a name="ln3376"> </a>
<a name="ln3377">		tintedLine = !tintedLine;</a>
<a name="ln3378">		float rowHeight = row-&gt;Height();</a>
<a name="ln3379"> </a>
<a name="ln3380">		if (line &gt;= invalidBounds.top - rowHeight) {</a>
<a name="ln3381">			bool isFirstColumn = true;</a>
<a name="ln3382">			float fieldLeftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());</a>
<a name="ln3383"> </a>
<a name="ln3384">			// setup background color</a>
<a name="ln3385">			rgb_color lowColor;</a>
<a name="ln3386">			if (row-&gt;fNextSelected != 0) {</a>
<a name="ln3387">				if (Window()-&gt;IsActive()) {</a>
<a name="ln3388">					if (fEditMode)</a>
<a name="ln3389">						lowColor = fMasterView-&gt;Color(B_COLOR_EDIT_BACKGROUND);</a>
<a name="ln3390">					else</a>
<a name="ln3391">						lowColor = fMasterView-&gt;Color(B_COLOR_SELECTION);</a>
<a name="ln3392">				}</a>
<a name="ln3393">				else</a>
<a name="ln3394">					lowColor = fMasterView-&gt;Color(B_COLOR_NON_FOCUS_SELECTION);</a>
<a name="ln3395">			} else</a>
<a name="ln3396">				lowColor = fMasterView-&gt;Color(B_COLOR_BACKGROUND);</a>
<a name="ln3397">			if (tintedLine)</a>
<a name="ln3398">				lowColor = tint_color(lowColor, kTintedLineTint);</a>
<a name="ln3399"> </a>
<a name="ln3400">			for (int columnIndex = 0; columnIndex &lt; numColumns; columnIndex++) {</a>
<a name="ln3401">				BColumn* column = (BColumn*) fColumns-&gt;ItemAt(columnIndex);</a>
<a name="ln3402">				if (!column-&gt;IsVisible())</a>
<a name="ln3403">					continue;</a>
<a name="ln3404"> </a>
<a name="ln3405">				if (!isFirstColumn &amp;&amp; fieldLeftEdge &gt; invalidBounds.right)</a>
<a name="ln3406">					break;</a>
<a name="ln3407"> </a>
<a name="ln3408">				if (fieldLeftEdge + column-&gt;Width() &gt;= invalidBounds.left) {</a>
<a name="ln3409">					BRect fullRect(fieldLeftEdge, line,</a>
<a name="ln3410">						fieldLeftEdge + column-&gt;Width(), line + rowHeight);</a>
<a name="ln3411"> </a>
<a name="ln3412">					bool clippedFirstColumn = false;</a>
<a name="ln3413">						// This happens when a column is indented past the</a>
<a name="ln3414">						// beginning of the next column.</a>
<a name="ln3415"> </a>
<a name="ln3416">					SetHighColor(lowColor);</a>
<a name="ln3417"> </a>
<a name="ln3418">					BRect destRect(fullRect);</a>
<a name="ln3419">					if (isFirstColumn) {</a>
<a name="ln3420">						fullRect.left -= fMasterView-&gt;LatchWidth();</a>
<a name="ln3421">						destRect.left += iterator.CurrentLevel()</a>
<a name="ln3422">							* kOutlineLevelIndent;</a>
<a name="ln3423">						if (destRect.left &gt;= destRect.right) {</a>
<a name="ln3424">							// clipped</a>
<a name="ln3425">							FillRect(BRect(0, line, fieldLeftEdge</a>
<a name="ln3426">								+ column-&gt;Width(), line + rowHeight));</a>
<a name="ln3427">							clippedFirstColumn = true;</a>
<a name="ln3428">						}</a>
<a name="ln3429"> </a>
<a name="ln3430">						FillRect(BRect(0, line, MAX(kLeftMargin,</a>
<a name="ln3431">							fMasterView-&gt;LatchWidth()), line + row-&gt;Height()));</a>
<a name="ln3432">					}</a>
<a name="ln3433"> </a>
<a name="ln3434"> </a>
<a name="ln3435">#if SMART_REDRAW</a>
<a name="ln3436">					if (!clippedFirstColumn</a>
<a name="ln3437">						&amp;&amp; invalidRegion.Intersects(fullRect)) {</a>
<a name="ln3438">#else</a>
<a name="ln3439">					if (!clippedFirstColumn) {</a>
<a name="ln3440">#endif</a>
<a name="ln3441">						FillRect(fullRect);	// Using color set above</a>
<a name="ln3442"> </a>
<a name="ln3443">						// Draw the latch widget if it has one.</a>
<a name="ln3444">						if (isFirstColumn) {</a>
<a name="ln3445">							if (row == fTargetRow</a>
<a name="ln3446">								&amp;&amp; fCurrentState == LATCH_CLICKED) {</a>
<a name="ln3447">								// Note that this only occurs if the user is</a>
<a name="ln3448">								// holding down a latch while items are added</a>
<a name="ln3449">								// in the background.</a>
<a name="ln3450">								BPoint pos;</a>
<a name="ln3451">								uint32 buttons;</a>
<a name="ln3452">								GetMouse(&amp;pos, &amp;buttons);</a>
<a name="ln3453">								if (fLatchRect.Contains(pos)) {</a>
<a name="ln3454">									fMasterView-&gt;DrawLatch(this, fLatchRect,</a>
<a name="ln3455">										B_PRESSED_LATCH, fTargetRow);</a>
<a name="ln3456">								} else {</a>
<a name="ln3457">									fMasterView-&gt;DrawLatch(this, fLatchRect,</a>
<a name="ln3458">										row-&gt;fIsExpanded ? B_OPEN_LATCH</a>
<a name="ln3459">											: B_CLOSED_LATCH, fTargetRow);</a>
<a name="ln3460">								}</a>
<a name="ln3461">							} else {</a>
<a name="ln3462">								LatchType pos = B_NO_LATCH;</a>
<a name="ln3463">								if (row-&gt;HasLatch())</a>
<a name="ln3464">									pos = row-&gt;fIsExpanded ? B_OPEN_LATCH</a>
<a name="ln3465">										: B_CLOSED_LATCH;</a>
<a name="ln3466"> </a>
<a name="ln3467">								fMasterView-&gt;DrawLatch(this,</a>
<a name="ln3468">									BRect(destRect.left</a>
<a name="ln3469">										- fMasterView-&gt;LatchWidth(),</a>
<a name="ln3470">									destRect.top, destRect.left,</a>
<a name="ln3471">									destRect.bottom), pos, row);</a>
<a name="ln3472">							}</a>
<a name="ln3473">						}</a>
<a name="ln3474"> </a>
<a name="ln3475">						SetHighColor(fMasterView-&gt;HighColor());</a>
<a name="ln3476">							// The master view just holds the high color for us.</a>
<a name="ln3477">						SetLowColor(lowColor);</a>
<a name="ln3478"> </a>
<a name="ln3479">						BField* field = row-&gt;GetField(column-&gt;fFieldID);</a>
<a name="ln3480">						if (field) {</a>
<a name="ln3481">#if CONSTRAIN_CLIPPING_REGION</a>
<a name="ln3482">							BRegion clipRegion(destRect);</a>
<a name="ln3483">							PushState();</a>
<a name="ln3484">							ConstrainClippingRegion(&amp;clipRegion);</a>
<a name="ln3485">#endif</a>
<a name="ln3486">							SetHighColor(fMasterView-&gt;Color(</a>
<a name="ln3487">								row-&gt;fNextSelected ? B_COLOR_SELECTION_TEXT</a>
<a name="ln3488">								: B_COLOR_TEXT));</a>
<a name="ln3489">							float baseline = floor(destRect.top + fh.ascent</a>
<a name="ln3490">								+ (destRect.Height() + 1</a>
<a name="ln3491">								- (fh.ascent+fh.descent)) / 2);</a>
<a name="ln3492">							MovePenTo(destRect.left + 8, baseline);</a>
<a name="ln3493">							column-&gt;DrawField(field, destRect, this);</a>
<a name="ln3494">#if CONSTRAIN_CLIPPING_REGION</a>
<a name="ln3495">							PopState();</a>
<a name="ln3496">#endif</a>
<a name="ln3497">						}</a>
<a name="ln3498">					}</a>
<a name="ln3499">				}</a>
<a name="ln3500"> </a>
<a name="ln3501">				isFirstColumn = false;</a>
<a name="ln3502">				fieldLeftEdge += column-&gt;Width() + 1;</a>
<a name="ln3503">			}</a>
<a name="ln3504"> </a>
<a name="ln3505">			if (fieldLeftEdge &lt;= invalidBounds.right) {</a>
<a name="ln3506">				SetHighColor(lowColor);</a>
<a name="ln3507">				FillRect(BRect(fieldLeftEdge, line, invalidBounds.right,</a>
<a name="ln3508">					line + rowHeight));</a>
<a name="ln3509">			}</a>
<a name="ln3510">		}</a>
<a name="ln3511"> </a>
<a name="ln3512">		// indicate the keyboard focus row</a>
<a name="ln3513">		if (fFocusRow == row &amp;&amp; !fEditMode &amp;&amp; fMasterView-&gt;IsFocus()</a>
<a name="ln3514">			&amp;&amp; Window()-&gt;IsActive()) {</a>
<a name="ln3515">			SetHighColor(fMasterView-&gt;Color(B_COLOR_ROW_DIVIDER));</a>
<a name="ln3516">			StrokeRect(BRect(0, line, 10000.0, line + rowHeight));</a>
<a name="ln3517">		}</a>
<a name="ln3518"> </a>
<a name="ln3519">		line += rowHeight + 1;</a>
<a name="ln3520">	}</a>
<a name="ln3521"> </a>
<a name="ln3522">	if (line &lt;= invalidBounds.bottom) {</a>
<a name="ln3523">		// fill background below last item</a>
<a name="ln3524">		SetHighColor(fMasterView-&gt;Color(B_COLOR_BACKGROUND));</a>
<a name="ln3525">		FillRect(BRect(invalidBounds.left, line, invalidBounds.right,</a>
<a name="ln3526">			invalidBounds.bottom));</a>
<a name="ln3527">	}</a>
<a name="ln3528"> </a>
<a name="ln3529">	// Draw the drop target line</a>
<a name="ln3530">	if (fDropHighlightY != -1) {</a>
<a name="ln3531">		InvertRect(BRect(0, fDropHighlightY - kDropHighlightLineHeight / 2,</a>
<a name="ln3532">			1000000, fDropHighlightY + kDropHighlightLineHeight / 2));</a>
<a name="ln3533">	}</a>
<a name="ln3534">}</a>
<a name="ln3535"> </a>
<a name="ln3536"> </a>
<a name="ln3537">BRow*</a>
<a name="ln3538">OutlineView::FindRow(float ypos, int32* _rowIndent, float* _top)</a>
<a name="ln3539">{</a>
<a name="ln3540">	if (_rowIndent &amp;&amp; _top) {</a>
<a name="ln3541">		float line = 0.0;</a>
<a name="ln3542">		for (RecursiveOutlineIterator iterator(&amp;fRows); iterator.CurrentRow();</a>
<a name="ln3543">			iterator.GoToNext()) {</a>
<a name="ln3544"> </a>
<a name="ln3545">			BRow* row = iterator.CurrentRow();</a>
<a name="ln3546">			if (line &gt; ypos)</a>
<a name="ln3547">				break;</a>
<a name="ln3548"> </a>
<a name="ln3549">			float rowHeight = row-&gt;Height();</a>
<a name="ln3550">			if (ypos &lt;= line + rowHeight) {</a>
<a name="ln3551">				*_top = line;</a>
<a name="ln3552">				*_rowIndent = iterator.CurrentLevel();</a>
<a name="ln3553">				return row;</a>
<a name="ln3554">			}</a>
<a name="ln3555"> </a>
<a name="ln3556">			line += rowHeight + 1;</a>
<a name="ln3557">		}</a>
<a name="ln3558">	}</a>
<a name="ln3559"> </a>
<a name="ln3560">	return NULL;</a>
<a name="ln3561">}</a>
<a name="ln3562"> </a>
<a name="ln3563">void OutlineView::SetMouseTrackingEnabled(bool enabled)</a>
<a name="ln3564">{</a>
<a name="ln3565">	fTrackMouse = enabled;</a>
<a name="ln3566">	if (!enabled &amp;&amp; fDropHighlightY != -1) {</a>
<a name="ln3567">		// Erase the old target line</a>
<a name="ln3568">		InvertRect(BRect(0, fDropHighlightY - kDropHighlightLineHeight / 2,</a>
<a name="ln3569">			1000000, fDropHighlightY + kDropHighlightLineHeight / 2));</a>
<a name="ln3570">		fDropHighlightY = -1;</a>
<a name="ln3571">	}</a>
<a name="ln3572">}</a>
<a name="ln3573"> </a>
<a name="ln3574"> </a>
<a name="ln3575">//</a>
<a name="ln3576">// Note that this interaction is not totally safe.  If items are added to</a>
<a name="ln3577">// the list in the background, the widget rect will be incorrect, possibly</a>
<a name="ln3578">// resulting in drawing glitches.  The code that adds items needs to be a little smarter</a>
<a name="ln3579">// about invalidating state.</a>
<a name="ln3580">//</a>
<a name="ln3581">void</a>
<a name="ln3582">OutlineView::MouseDown(BPoint position)</a>
<a name="ln3583">{</a>
<a name="ln3584">	if (!fEditMode)</a>
<a name="ln3585">		fMasterView-&gt;MakeFocus(true);</a>
<a name="ln3586"> </a>
<a name="ln3587">	// Check to see if the user is clicking on a widget to open a section</a>
<a name="ln3588">	// of the list.</a>
<a name="ln3589">	bool reset_click_count = false;</a>
<a name="ln3590">	int32 indent;</a>
<a name="ln3591">	float rowTop;</a>
<a name="ln3592">	BRow* row = FindRow(position.y, &amp;indent, &amp;rowTop);</a>
<a name="ln3593">	if (row != NULL) {</a>
<a name="ln3594"> </a>
<a name="ln3595">		// Update fCurrentField</a>
<a name="ln3596">		bool handle_field = false;</a>
<a name="ln3597">		BField* new_field = 0;</a>
<a name="ln3598">		BRow* new_row = 0;</a>
<a name="ln3599">		BColumn* new_column = 0;</a>
<a name="ln3600">		BRect new_rect;</a>
<a name="ln3601"> </a>
<a name="ln3602">		if (position.y &gt;= 0) {</a>
<a name="ln3603">			if (position.x &gt;= 0) {</a>
<a name="ln3604">				float x = 0;</a>
<a name="ln3605">				for (int32 c = 0; c &lt; fMasterView-&gt;CountColumns(); c++) {</a>
<a name="ln3606">					new_column = fMasterView-&gt;ColumnAt(c);</a>
<a name="ln3607">					if (!new_column-&gt;IsVisible())</a>
<a name="ln3608">						continue;</a>
<a name="ln3609">					if ((MAX(kLeftMargin, fMasterView-&gt;LatchWidth()) + x)</a>
<a name="ln3610">						+ new_column-&gt;Width() &gt;= position.x) {</a>
<a name="ln3611">						if (new_column-&gt;WantsEvents()) {</a>
<a name="ln3612">							new_field = row-&gt;GetField(c);</a>
<a name="ln3613">							new_row = row;</a>
<a name="ln3614">							FindRect(new_row,&amp;new_rect);</a>
<a name="ln3615">							new_rect.left = MAX(kLeftMargin,</a>
<a name="ln3616">								fMasterView-&gt;LatchWidth()) + x;</a>
<a name="ln3617">							new_rect.right = new_rect.left</a>
<a name="ln3618">								+ new_column-&gt;Width() - 1;</a>
<a name="ln3619">							handle_field = true;</a>
<a name="ln3620">						}</a>
<a name="ln3621">						break;</a>
<a name="ln3622">					}</a>
<a name="ln3623">					x += new_column-&gt;Width();</a>
<a name="ln3624">				}</a>
<a name="ln3625">			}</a>
<a name="ln3626">		}</a>
<a name="ln3627"> </a>
<a name="ln3628">		// Handle mouse down</a>
<a name="ln3629">		if (handle_field) {</a>
<a name="ln3630">			fMouseDown = true;</a>
<a name="ln3631">			fFieldRect = new_rect;</a>
<a name="ln3632">			fCurrentColumn = new_column;</a>
<a name="ln3633">			fCurrentRow = new_row;</a>
<a name="ln3634">			fCurrentField = new_field;</a>
<a name="ln3635">			fCurrentCode = B_INSIDE_VIEW;</a>
<a name="ln3636">			BMessage* message = Window()-&gt;CurrentMessage();</a>
<a name="ln3637">			int32 buttons = 1;</a>
<a name="ln3638">			message-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons);</a>
<a name="ln3639">			fCurrentColumn-&gt;MouseDown(fMasterView, fCurrentRow,</a>
<a name="ln3640">				fCurrentField, fFieldRect, position, buttons);</a>
<a name="ln3641">		}</a>
<a name="ln3642"> </a>
<a name="ln3643">		if (!fEditMode) {</a>
<a name="ln3644"> </a>
<a name="ln3645">			fTargetRow = row;</a>
<a name="ln3646">			fTargetRowTop = rowTop;</a>
<a name="ln3647">			FindVisibleRect(fFocusRow, &amp;fFocusRowRect);</a>
<a name="ln3648"> </a>
<a name="ln3649">			float leftWidgetBoundry = indent * kOutlineLevelIndent</a>
<a name="ln3650">				+ MAX(kLeftMargin, fMasterView-&gt;LatchWidth())</a>
<a name="ln3651">				- fMasterView-&gt;LatchWidth();</a>
<a name="ln3652">			fLatchRect.Set(leftWidgetBoundry, rowTop, leftWidgetBoundry</a>
<a name="ln3653">				+ fMasterView-&gt;LatchWidth(), rowTop + row-&gt;Height());</a>
<a name="ln3654">			if (fLatchRect.Contains(position) &amp;&amp; row-&gt;HasLatch()) {</a>
<a name="ln3655">				fCurrentState = LATCH_CLICKED;</a>
<a name="ln3656">				if (fTargetRow-&gt;fNextSelected != 0)</a>
<a name="ln3657">					SetHighColor(fMasterView-&gt;Color(B_COLOR_SELECTION));</a>
<a name="ln3658">				else</a>
<a name="ln3659">					SetHighColor(fMasterView-&gt;Color(B_COLOR_BACKGROUND));</a>
<a name="ln3660"> </a>
<a name="ln3661">				FillRect(fLatchRect);</a>
<a name="ln3662">				if (fLatchRect.Contains(position)) {</a>
<a name="ln3663">					fMasterView-&gt;DrawLatch(this, fLatchRect, B_PRESSED_LATCH,</a>
<a name="ln3664">						row);</a>
<a name="ln3665">				} else {</a>
<a name="ln3666">					fMasterView-&gt;DrawLatch(this, fLatchRect,</a>
<a name="ln3667">						fTargetRow-&gt;fIsExpanded ? B_OPEN_LATCH</a>
<a name="ln3668">						: B_CLOSED_LATCH, row);</a>
<a name="ln3669">				}</a>
<a name="ln3670">			} else {</a>
<a name="ln3671">				Invalidate(fFocusRowRect);</a>
<a name="ln3672">				fFocusRow = fTargetRow;</a>
<a name="ln3673">				FindVisibleRect(fFocusRow, &amp;fFocusRowRect);</a>
<a name="ln3674"> </a>
<a name="ln3675">				ASSERT(fTargetRow != 0);</a>
<a name="ln3676"> </a>
<a name="ln3677">				if ((modifiers() &amp; B_CONTROL_KEY) == 0)</a>
<a name="ln3678">					DeselectAll();</a>
<a name="ln3679"> </a>
<a name="ln3680">				if ((modifiers() &amp; B_SHIFT_KEY) != 0 &amp;&amp; fFirstSelectedItem != 0</a>
<a name="ln3681">					&amp;&amp; fSelectionMode == B_MULTIPLE_SELECTION_LIST) {</a>
<a name="ln3682">					SelectRange(fFirstSelectedItem, fTargetRow);</a>
<a name="ln3683">				}</a>
<a name="ln3684">				else {</a>
<a name="ln3685">					if (fTargetRow-&gt;fNextSelected != 0) {</a>
<a name="ln3686">						// Unselect row</a>
<a name="ln3687">						fTargetRow-&gt;fNextSelected-&gt;fPrevSelected</a>
<a name="ln3688">							= fTargetRow-&gt;fPrevSelected;</a>
<a name="ln3689">						fTargetRow-&gt;fPrevSelected-&gt;fNextSelected</a>
<a name="ln3690">							= fTargetRow-&gt;fNextSelected;</a>
<a name="ln3691">						fTargetRow-&gt;fPrevSelected = 0;</a>
<a name="ln3692">						fTargetRow-&gt;fNextSelected = 0;</a>
<a name="ln3693">						fFirstSelectedItem = NULL;</a>
<a name="ln3694">					} else {</a>
<a name="ln3695">						// Select row</a>
<a name="ln3696">						if (fSelectionMode == B_SINGLE_SELECTION_LIST)</a>
<a name="ln3697">							DeselectAll();</a>
<a name="ln3698"> </a>
<a name="ln3699">						fTargetRow-&gt;fNextSelected</a>
<a name="ln3700">							= fSelectionListDummyHead.fNextSelected;</a>
<a name="ln3701">						fTargetRow-&gt;fPrevSelected</a>
<a name="ln3702">							= &amp;fSelectionListDummyHead;</a>
<a name="ln3703">						fTargetRow-&gt;fNextSelected-&gt;fPrevSelected = fTargetRow;</a>
<a name="ln3704">						fTargetRow-&gt;fPrevSelected-&gt;fNextSelected = fTargetRow;</a>
<a name="ln3705">						fFirstSelectedItem = fTargetRow;</a>
<a name="ln3706">					}</a>
<a name="ln3707"> </a>
<a name="ln3708">					Invalidate(BRect(fVisibleRect.left, fTargetRowTop,</a>
<a name="ln3709">						fVisibleRect.right,</a>
<a name="ln3710">						fTargetRowTop + fTargetRow-&gt;Height()));</a>
<a name="ln3711">				}</a>
<a name="ln3712"> </a>
<a name="ln3713">				fCurrentState = ROW_CLICKED;</a>
<a name="ln3714">				if (fLastSelectedItem != fTargetRow)</a>
<a name="ln3715">					reset_click_count = true;</a>
<a name="ln3716">				fLastSelectedItem = fTargetRow;</a>
<a name="ln3717">				fMasterView-&gt;SelectionChanged();</a>
<a name="ln3718"> </a>
<a name="ln3719">			}</a>
<a name="ln3720">		}</a>
<a name="ln3721"> </a>
<a name="ln3722">		SetMouseEventMask(B_POINTER_EVENTS, B_LOCK_WINDOW_FOCUS |</a>
<a name="ln3723">			B_NO_POINTER_HISTORY);</a>
<a name="ln3724"> </a>
<a name="ln3725">	} else if (fFocusRow != 0) {</a>
<a name="ln3726">		// User clicked in open space, unhighlight focus row.</a>
<a name="ln3727">		FindVisibleRect(fFocusRow, &amp;fFocusRowRect);</a>
<a name="ln3728">		fFocusRow = 0;</a>
<a name="ln3729">		Invalidate(fFocusRowRect);</a>
<a name="ln3730">	}</a>
<a name="ln3731"> </a>
<a name="ln3732">	// We stash the click counts here because the 'clicks' field</a>
<a name="ln3733">	// is not in the CurrentMessage() when MouseUp is called... ;(</a>
<a name="ln3734">	if (reset_click_count)</a>
<a name="ln3735">		fClickCount = 1;</a>
<a name="ln3736">	else</a>
<a name="ln3737">		Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;clicks&quot;, &amp;fClickCount);</a>
<a name="ln3738">	fClickPoint = position;</a>
<a name="ln3739"> </a>
<a name="ln3740">}</a>
<a name="ln3741"> </a>
<a name="ln3742"> </a>
<a name="ln3743">void</a>
<a name="ln3744">OutlineView::MouseMoved(BPoint position, uint32 /*transit*/,</a>
<a name="ln3745">	const BMessage* /*dragMessage*/)</a>
<a name="ln3746">{</a>
<a name="ln3747">	if (!fMouseDown) {</a>
<a name="ln3748">		// Update fCurrentField</a>
<a name="ln3749">		bool handle_field = false;</a>
<a name="ln3750">		BField* new_field = 0;</a>
<a name="ln3751">		BRow* new_row = 0;</a>
<a name="ln3752">		BColumn* new_column = 0;</a>
<a name="ln3753">		BRect new_rect(0,0,0,0);</a>
<a name="ln3754">		if (position.y &gt;=0 ) {</a>
<a name="ln3755">			float top;</a>
<a name="ln3756">			int32 indent;</a>
<a name="ln3757">			BRow* row = FindRow(position.y, &amp;indent, &amp;top);</a>
<a name="ln3758">			if (row &amp;&amp; position.x &gt;=0 ) {</a>
<a name="ln3759">				float x=0;</a>
<a name="ln3760">				for (int32 c=0;c&lt;fMasterView-&gt;CountColumns();c++) {</a>
<a name="ln3761">					new_column = fMasterView-&gt;ColumnAt(c);</a>
<a name="ln3762">					if (!new_column-&gt;IsVisible())</a>
<a name="ln3763">						continue;</a>
<a name="ln3764">					if ((MAX(kLeftMargin,</a>
<a name="ln3765">						fMasterView-&gt;LatchWidth()) + x) + new_column-&gt;Width()</a>
<a name="ln3766">						&gt; position.x) {</a>
<a name="ln3767"> </a>
<a name="ln3768">						if(new_column-&gt;WantsEvents()) {</a>
<a name="ln3769">							new_field = row-&gt;GetField(c);</a>
<a name="ln3770">							new_row = row;</a>
<a name="ln3771">							FindRect(new_row,&amp;new_rect);</a>
<a name="ln3772">							new_rect.left = MAX(kLeftMargin,</a>
<a name="ln3773">								fMasterView-&gt;LatchWidth()) + x;</a>
<a name="ln3774">							new_rect.right = new_rect.left</a>
<a name="ln3775">								+ new_column-&gt;Width() - 1;</a>
<a name="ln3776">							handle_field = true;</a>
<a name="ln3777">						}</a>
<a name="ln3778">						break;</a>
<a name="ln3779">					}</a>
<a name="ln3780">					x += new_column-&gt;Width();</a>
<a name="ln3781">				}</a>
<a name="ln3782">			}</a>
<a name="ln3783">		}</a>
<a name="ln3784"> </a>
<a name="ln3785">		// Handle mouse moved</a>
<a name="ln3786">		if (handle_field) {</a>
<a name="ln3787">			if (new_field != fCurrentField) {</a>
<a name="ln3788">				if (fCurrentField) {</a>
<a name="ln3789">					fCurrentColumn-&gt;MouseMoved(fMasterView, fCurrentRow,</a>
<a name="ln3790">						fCurrentField, fFieldRect, position, 0,</a>
<a name="ln3791">						fCurrentCode = B_EXITED_VIEW);</a>
<a name="ln3792">				}</a>
<a name="ln3793">				fCurrentColumn = new_column;</a>
<a name="ln3794">				fCurrentRow = new_row;</a>
<a name="ln3795">				fCurrentField = new_field;</a>
<a name="ln3796">				fFieldRect = new_rect;</a>
<a name="ln3797">				if (fCurrentField) {</a>
<a name="ln3798">					fCurrentColumn-&gt;MouseMoved(fMasterView, fCurrentRow,</a>
<a name="ln3799">						fCurrentField, fFieldRect, position, 0,</a>
<a name="ln3800">						fCurrentCode = B_ENTERED_VIEW);</a>
<a name="ln3801">				}</a>
<a name="ln3802">			} else {</a>
<a name="ln3803">				if (fCurrentField) {</a>
<a name="ln3804">					fCurrentColumn-&gt;MouseMoved(fMasterView, fCurrentRow,</a>
<a name="ln3805">						fCurrentField, fFieldRect, position, 0,</a>
<a name="ln3806">						fCurrentCode = B_INSIDE_VIEW);</a>
<a name="ln3807">				}</a>
<a name="ln3808">			}</a>
<a name="ln3809">		} else {</a>
<a name="ln3810">			if (fCurrentField) {</a>
<a name="ln3811">				fCurrentColumn-&gt;MouseMoved(fMasterView, fCurrentRow,</a>
<a name="ln3812">					fCurrentField, fFieldRect, position, 0,</a>
<a name="ln3813">					fCurrentCode = B_EXITED_VIEW);</a>
<a name="ln3814">				fCurrentField = 0;</a>
<a name="ln3815">				fCurrentColumn = 0;</a>
<a name="ln3816">				fCurrentRow = 0;</a>
<a name="ln3817">			}</a>
<a name="ln3818">		}</a>
<a name="ln3819">	} else {</a>
<a name="ln3820">		if (fCurrentField) {</a>
<a name="ln3821">			if (fFieldRect.Contains(position)) {</a>
<a name="ln3822">				if (fCurrentCode == B_OUTSIDE_VIEW</a>
<a name="ln3823">					|| fCurrentCode == B_EXITED_VIEW) {</a>
<a name="ln3824">					fCurrentColumn-&gt;MouseMoved(fMasterView, fCurrentRow,</a>
<a name="ln3825">						fCurrentField, fFieldRect, position, 1,</a>
<a name="ln3826">						fCurrentCode = B_ENTERED_VIEW);</a>
<a name="ln3827">				} else {</a>
<a name="ln3828">					fCurrentColumn-&gt;MouseMoved(fMasterView, fCurrentRow,</a>
<a name="ln3829">						fCurrentField, fFieldRect, position, 1,</a>
<a name="ln3830">						fCurrentCode = B_INSIDE_VIEW);</a>
<a name="ln3831">				}</a>
<a name="ln3832">			} else {</a>
<a name="ln3833">				if (fCurrentCode == B_INSIDE_VIEW</a>
<a name="ln3834">					|| fCurrentCode == B_ENTERED_VIEW) {</a>
<a name="ln3835">					fCurrentColumn-&gt;MouseMoved(fMasterView, fCurrentRow,</a>
<a name="ln3836">						fCurrentField, fFieldRect, position, 1,</a>
<a name="ln3837">						fCurrentCode = B_EXITED_VIEW);</a>
<a name="ln3838">				} else {</a>
<a name="ln3839">					fCurrentColumn-&gt;MouseMoved(fMasterView, fCurrentRow,</a>
<a name="ln3840">						fCurrentField, fFieldRect, position, 1,</a>
<a name="ln3841">						fCurrentCode = B_OUTSIDE_VIEW);</a>
<a name="ln3842">				}</a>
<a name="ln3843">			}</a>
<a name="ln3844">		}</a>
<a name="ln3845">	}</a>
<a name="ln3846"> </a>
<a name="ln3847">	if (!fEditMode) {</a>
<a name="ln3848"> </a>
<a name="ln3849">		switch (fCurrentState) {</a>
<a name="ln3850">			case LATCH_CLICKED:</a>
<a name="ln3851">				if (fTargetRow-&gt;fNextSelected != 0)</a>
<a name="ln3852">					SetHighColor(fMasterView-&gt;Color(B_COLOR_SELECTION));</a>
<a name="ln3853">				else</a>
<a name="ln3854">					SetHighColor(fMasterView-&gt;Color(B_COLOR_BACKGROUND));</a>
<a name="ln3855"> </a>
<a name="ln3856">				FillRect(fLatchRect);</a>
<a name="ln3857">				if (fLatchRect.Contains(position)) {</a>
<a name="ln3858">					fMasterView-&gt;DrawLatch(this, fLatchRect, B_PRESSED_LATCH,</a>
<a name="ln3859">						fTargetRow);</a>
<a name="ln3860">				} else {</a>
<a name="ln3861">					fMasterView-&gt;DrawLatch(this, fLatchRect,</a>
<a name="ln3862">						fTargetRow-&gt;fIsExpanded ? B_OPEN_LATCH : B_CLOSED_LATCH,</a>
<a name="ln3863">						fTargetRow);</a>
<a name="ln3864">				}</a>
<a name="ln3865">				break;</a>
<a name="ln3866"> </a>
<a name="ln3867">			case ROW_CLICKED:</a>
<a name="ln3868">				if (abs((int)(position.x - fClickPoint.x)) &gt; kRowDragSensitivity</a>
<a name="ln3869">					|| abs((int)(position.y - fClickPoint.y))</a>
<a name="ln3870">						&gt; kRowDragSensitivity) {</a>
<a name="ln3871">					fCurrentState = DRAGGING_ROWS;</a>
<a name="ln3872">					fMasterView-&gt;InitiateDrag(fClickPoint,</a>
<a name="ln3873">						fTargetRow-&gt;fNextSelected != 0);</a>
<a name="ln3874">				}</a>
<a name="ln3875">				break;</a>
<a name="ln3876"> </a>
<a name="ln3877">			case DRAGGING_ROWS:</a>
<a name="ln3878">#if 0</a>
<a name="ln3879">				// falls through...</a>
<a name="ln3880">#else</a>
<a name="ln3881">				if (fTrackMouse /*&amp;&amp; message*/) {</a>
<a name="ln3882">					if (fVisibleRect.Contains(position)) {</a>
<a name="ln3883">						float top;</a>
<a name="ln3884">						int32 indent;</a>
<a name="ln3885">						BRow* target = FindRow(position.y, &amp;indent, &amp;top);</a>
<a name="ln3886">						if (target)</a>
<a name="ln3887">							SetFocusRow(target, true);</a>
<a name="ln3888">					}</a>
<a name="ln3889">				}</a>
<a name="ln3890">				break;</a>
<a name="ln3891">#endif</a>
<a name="ln3892"> </a>
<a name="ln3893">			default: {</a>
<a name="ln3894"> </a>
<a name="ln3895">				if (fTrackMouse /*&amp;&amp; message*/) {</a>
<a name="ln3896">					// Draw a highlight line...</a>
<a name="ln3897">					if (fVisibleRect.Contains(position)) {</a>
<a name="ln3898">						float top;</a>
<a name="ln3899">						int32 indent;</a>
<a name="ln3900">						BRow* target = FindRow(position.y, &amp;indent, &amp;top);</a>
<a name="ln3901">						if (target == fRollOverRow)</a>
<a name="ln3902">							break;</a>
<a name="ln3903">						if (fRollOverRow) {</a>
<a name="ln3904">							BRect rect;</a>
<a name="ln3905">							FindRect(fRollOverRow, &amp;rect);</a>
<a name="ln3906">							Invalidate(rect);</a>
<a name="ln3907">						}</a>
<a name="ln3908">						fRollOverRow = target;</a>
<a name="ln3909">#if 0</a>
<a name="ln3910">						SetFocusRow(fRollOverRow,false);</a>
<a name="ln3911">#else</a>
<a name="ln3912">						PushState();</a>
<a name="ln3913">						SetDrawingMode(B_OP_BLEND);</a>
<a name="ln3914">						SetHighColor(255, 255, 255, 255);</a>
<a name="ln3915">						BRect rect;</a>
<a name="ln3916">						FindRect(fRollOverRow, &amp;rect);</a>
<a name="ln3917">						rect.bottom -= 1.0;</a>
<a name="ln3918">						FillRect(rect);</a>
<a name="ln3919">						PopState();</a>
<a name="ln3920">#endif</a>
<a name="ln3921">					} else {</a>
<a name="ln3922">						if (fRollOverRow) {</a>
<a name="ln3923">							BRect rect;</a>
<a name="ln3924">							FindRect(fRollOverRow, &amp;rect);</a>
<a name="ln3925">							Invalidate(rect);</a>
<a name="ln3926">							fRollOverRow = NULL;</a>
<a name="ln3927">						}</a>
<a name="ln3928">					}</a>
<a name="ln3929">				}</a>
<a name="ln3930">			}</a>
<a name="ln3931">		}</a>
<a name="ln3932">	}</a>
<a name="ln3933">}</a>
<a name="ln3934"> </a>
<a name="ln3935"> </a>
<a name="ln3936">void</a>
<a name="ln3937">OutlineView::MouseUp(BPoint position)</a>
<a name="ln3938">{</a>
<a name="ln3939">	if (fCurrentField) {</a>
<a name="ln3940">		fCurrentColumn-&gt;MouseUp(fMasterView, fCurrentRow, fCurrentField);</a>
<a name="ln3941">		fMouseDown = false;</a>
<a name="ln3942">	}</a>
<a name="ln3943"> </a>
<a name="ln3944">	if (fEditMode)</a>
<a name="ln3945">		return;</a>
<a name="ln3946"> </a>
<a name="ln3947">	switch (fCurrentState) {</a>
<a name="ln3948">		case LATCH_CLICKED:</a>
<a name="ln3949">			if (fLatchRect.Contains(position)) {</a>
<a name="ln3950">				fMasterView-&gt;ExpandOrCollapse(fTargetRow,</a>
<a name="ln3951">					!fTargetRow-&gt;fIsExpanded);</a>
<a name="ln3952">			}</a>
<a name="ln3953"> </a>
<a name="ln3954">			Invalidate(fLatchRect);</a>
<a name="ln3955">			fCurrentState = INACTIVE;</a>
<a name="ln3956">			break;</a>
<a name="ln3957"> </a>
<a name="ln3958">		case ROW_CLICKED:</a>
<a name="ln3959">			if (fClickCount &gt; 1</a>
<a name="ln3960">				&amp;&amp; abs((int)fClickPoint.x - (int)position.x)</a>
<a name="ln3961">					&lt; kDoubleClickMoveSensitivity</a>
<a name="ln3962">				&amp;&amp; abs((int)fClickPoint.y - (int)position.y)</a>
<a name="ln3963">					&lt; kDoubleClickMoveSensitivity) {</a>
<a name="ln3964">				fMasterView-&gt;ItemInvoked();</a>
<a name="ln3965">			}</a>
<a name="ln3966">			fCurrentState = INACTIVE;</a>
<a name="ln3967">			break;</a>
<a name="ln3968"> </a>
<a name="ln3969">		case DRAGGING_ROWS:</a>
<a name="ln3970">			fCurrentState = INACTIVE;</a>
<a name="ln3971">			// Falls through</a>
<a name="ln3972"> </a>
<a name="ln3973">		default:</a>
<a name="ln3974">			if (fDropHighlightY != -1) {</a>
<a name="ln3975">				InvertRect(BRect(0,</a>
<a name="ln3976">					fDropHighlightY - kDropHighlightLineHeight / 2,</a>
<a name="ln3977">					1000000, fDropHighlightY + kDropHighlightLineHeight / 2));</a>
<a name="ln3978">					// Erase the old target line</a>
<a name="ln3979">				fDropHighlightY = -1;</a>
<a name="ln3980">			}</a>
<a name="ln3981">	}</a>
<a name="ln3982">}</a>
<a name="ln3983"> </a>
<a name="ln3984"> </a>
<a name="ln3985">void</a>
<a name="ln3986">OutlineView::MessageReceived(BMessage* message)</a>
<a name="ln3987">{</a>
<a name="ln3988">	if (message-&gt;WasDropped()) {</a>
<a name="ln3989">		fMasterView-&gt;MessageDropped(message,</a>
<a name="ln3990">			ConvertFromScreen(message-&gt;DropPoint()));</a>
<a name="ln3991">	} else {</a>
<a name="ln3992">		BView::MessageReceived(message);</a>
<a name="ln3993">	}</a>
<a name="ln3994">}</a>
<a name="ln3995"> </a>
<a name="ln3996"> </a>
<a name="ln3997">void</a>
<a name="ln3998">OutlineView::ChangeFocusRow(bool up, bool updateSelection,</a>
<a name="ln3999">	bool addToCurrentSelection)</a>
<a name="ln4000">{</a>
<a name="ln4001">	int32 indent;</a>
<a name="ln4002">	float top;</a>
<a name="ln4003">	float newRowPos = 0;</a>
<a name="ln4004">	float verticalScroll = 0;</a>
<a name="ln4005"> </a>
<a name="ln4006">	if (fFocusRow) {</a>
<a name="ln4007">		// A row currently has the focus, get information about it</a>
<a name="ln4008">		newRowPos = fFocusRowRect.top + (up ? -4 : fFocusRow-&gt;Height() + 4);</a>
<a name="ln4009">		if (newRowPos &lt; fVisibleRect.top + 20)</a>
<a name="ln4010">			verticalScroll = newRowPos - 20;</a>
<a name="ln4011">		else if (newRowPos &gt; fVisibleRect.bottom - 20)</a>
<a name="ln4012">			verticalScroll = newRowPos - fVisibleRect.Height() + 20;</a>
<a name="ln4013">	} else</a>
<a name="ln4014">		newRowPos = fVisibleRect.top + 2;</a>
<a name="ln4015">			// no row is currently focused, set this to the top of the window</a>
<a name="ln4016">			// so we will select the first visible item in the list.</a>
<a name="ln4017"> </a>
<a name="ln4018">	BRow* newRow = FindRow(newRowPos, &amp;indent, &amp;top);</a>
<a name="ln4019">	if (newRow) {</a>
<a name="ln4020">		if (fFocusRow) {</a>
<a name="ln4021">			fFocusRowRect.right = 10000;</a>
<a name="ln4022">			Invalidate(fFocusRowRect);</a>
<a name="ln4023">		}</a>
<a name="ln4024">		BRow* oldFocusRow = fFocusRow;</a>
<a name="ln4025">		fFocusRow = newRow;</a>
<a name="ln4026">		fFocusRowRect.top = top;</a>
<a name="ln4027">		fFocusRowRect.left = 0;</a>
<a name="ln4028">		fFocusRowRect.right = 10000;</a>
<a name="ln4029">		fFocusRowRect.bottom = fFocusRowRect.top + fFocusRow-&gt;Height();</a>
<a name="ln4030">		Invalidate(fFocusRowRect);</a>
<a name="ln4031"> </a>
<a name="ln4032">		if (updateSelection) {</a>
<a name="ln4033">			if (!addToCurrentSelection</a>
<a name="ln4034">				|| fSelectionMode == B_SINGLE_SELECTION_LIST) {</a>
<a name="ln4035">				DeselectAll();</a>
<a name="ln4036">			}</a>
<a name="ln4037"> </a>
<a name="ln4038">			// if the focus row isn't selected, add it to the selection</a>
<a name="ln4039">			if (fFocusRow-&gt;fNextSelected == 0) {</a>
<a name="ln4040">				fFocusRow-&gt;fNextSelected</a>
<a name="ln4041">					= fSelectionListDummyHead.fNextSelected;</a>
<a name="ln4042">				fFocusRow-&gt;fPrevSelected = &amp;fSelectionListDummyHead;</a>
<a name="ln4043">				fFocusRow-&gt;fNextSelected-&gt;fPrevSelected = fFocusRow;</a>
<a name="ln4044">				fFocusRow-&gt;fPrevSelected-&gt;fNextSelected = fFocusRow;</a>
<a name="ln4045">			} else if (oldFocusRow != NULL</a>
<a name="ln4046">				&amp;&amp; fSelectionListDummyHead.fNextSelected == oldFocusRow</a>
<a name="ln4047">				&amp;&amp; (((IndexOf(oldFocusRow-&gt;fNextSelected)</a>
<a name="ln4048">						&lt; IndexOf(oldFocusRow)) == up)</a>
<a name="ln4049">					|| fFocusRow == oldFocusRow-&gt;fNextSelected)) {</a>
<a name="ln4050">					// if the focus row is selected, if:</a>
<a name="ln4051">					// 1. the previous focus row is last in the selection</a>
<a name="ln4052">					// 2a. the next selected row is now the focus row</a>
<a name="ln4053">					// 2b. or the next selected row is beyond the focus row</a>
<a name="ln4054">					//	   in the move direction</a>
<a name="ln4055">					// then deselect the previous focus row</a>
<a name="ln4056">				fSelectionListDummyHead.fNextSelected</a>
<a name="ln4057">					= oldFocusRow-&gt;fNextSelected;</a>
<a name="ln4058">				if (fSelectionListDummyHead.fNextSelected != NULL) {</a>
<a name="ln4059">					fSelectionListDummyHead.fNextSelected-&gt;fPrevSelected</a>
<a name="ln4060">						= &amp;fSelectionListDummyHead;</a>
<a name="ln4061">					oldFocusRow-&gt;fNextSelected = NULL;</a>
<a name="ln4062">				}</a>
<a name="ln4063">				oldFocusRow-&gt;fPrevSelected = NULL;</a>
<a name="ln4064">			}</a>
<a name="ln4065"> </a>
<a name="ln4066">			fLastSelectedItem = fFocusRow;</a>
<a name="ln4067">		}</a>
<a name="ln4068">	} else</a>
<a name="ln4069">		Invalidate(fFocusRowRect);</a>
<a name="ln4070"> </a>
<a name="ln4071">	if (verticalScroll != 0) {</a>
<a name="ln4072">		BScrollBar* vScrollBar = ScrollBar(B_VERTICAL);</a>
<a name="ln4073">		float min, max;</a>
<a name="ln4074">		vScrollBar-&gt;GetRange(&amp;min, &amp;max);</a>
<a name="ln4075">		if (verticalScroll &lt; min)</a>
<a name="ln4076">			verticalScroll = min;</a>
<a name="ln4077">		else if (verticalScroll &gt; max)</a>
<a name="ln4078">			verticalScroll = max;</a>
<a name="ln4079"> </a>
<a name="ln4080">		vScrollBar-&gt;SetValue(verticalScroll);</a>
<a name="ln4081">	}</a>
<a name="ln4082"> </a>
<a name="ln4083">	if (newRow &amp;&amp; updateSelection)</a>
<a name="ln4084">		fMasterView-&gt;SelectionChanged();</a>
<a name="ln4085">}</a>
<a name="ln4086"> </a>
<a name="ln4087"> </a>
<a name="ln4088">void</a>
<a name="ln4089">OutlineView::MoveFocusToVisibleRect()</a>
<a name="ln4090">{</a>
<a name="ln4091">	fFocusRow = 0;</a>
<a name="ln4092">	ChangeFocusRow(true, true, false);</a>
<a name="ln4093">}</a>
<a name="ln4094"> </a>
<a name="ln4095"> </a>
<a name="ln4096">BRow*</a>
<a name="ln4097">OutlineView::CurrentSelection(BRow* lastSelected) const</a>
<a name="ln4098">{</a>
<a name="ln4099">	BRow* row;</a>
<a name="ln4100">	if (lastSelected == 0)</a>
<a name="ln4101">		row = fSelectionListDummyHead.fNextSelected;</a>
<a name="ln4102">	else</a>
<a name="ln4103">		row = lastSelected-&gt;fNextSelected;</a>
<a name="ln4104"> </a>
<a name="ln4105"> </a>
<a name="ln4106">	if (row == &amp;fSelectionListDummyHead)</a>
<a name="ln4107">		row = 0;</a>
<a name="ln4108"> </a>
<a name="ln4109">	return row;</a>
<a name="ln4110">}</a>
<a name="ln4111"> </a>
<a name="ln4112"> </a>
<a name="ln4113">void</a>
<a name="ln4114">OutlineView::ToggleFocusRowSelection(bool selectRange)</a>
<a name="ln4115">{</a>
<a name="ln4116">	if (fFocusRow == 0)</a>
<a name="ln4117">		return;</a>
<a name="ln4118"> </a>
<a name="ln4119">	if (selectRange &amp;&amp; fSelectionMode == B_MULTIPLE_SELECTION_LIST)</a>
<a name="ln4120">		SelectRange(fLastSelectedItem, fFocusRow);</a>
<a name="ln4121">	else {</a>
<a name="ln4122">		if (fFocusRow-&gt;fNextSelected != 0) {</a>
<a name="ln4123">			// Unselect row</a>
<a name="ln4124">			fFocusRow-&gt;fNextSelected-&gt;fPrevSelected = fFocusRow-&gt;fPrevSelected;</a>
<a name="ln4125">			fFocusRow-&gt;fPrevSelected-&gt;fNextSelected = fFocusRow-&gt;fNextSelected;</a>
<a name="ln4126">			fFocusRow-&gt;fPrevSelected = 0;</a>
<a name="ln4127">			fFocusRow-&gt;fNextSelected = 0;</a>
<a name="ln4128">		} else {</a>
<a name="ln4129">			// Select row</a>
<a name="ln4130">			if (fSelectionMode == B_SINGLE_SELECTION_LIST)</a>
<a name="ln4131">				DeselectAll();</a>
<a name="ln4132"> </a>
<a name="ln4133">			fFocusRow-&gt;fNextSelected = fSelectionListDummyHead.fNextSelected;</a>
<a name="ln4134">			fFocusRow-&gt;fPrevSelected = &amp;fSelectionListDummyHead;</a>
<a name="ln4135">			fFocusRow-&gt;fNextSelected-&gt;fPrevSelected = fFocusRow;</a>
<a name="ln4136">			fFocusRow-&gt;fPrevSelected-&gt;fNextSelected = fFocusRow;</a>
<a name="ln4137">		}</a>
<a name="ln4138">	}</a>
<a name="ln4139"> </a>
<a name="ln4140">	fLastSelectedItem = fFocusRow;</a>
<a name="ln4141">	fMasterView-&gt;SelectionChanged();</a>
<a name="ln4142">	Invalidate(fFocusRowRect);</a>
<a name="ln4143">}</a>
<a name="ln4144"> </a>
<a name="ln4145"> </a>
<a name="ln4146">void</a>
<a name="ln4147">OutlineView::ToggleFocusRowOpen()</a>
<a name="ln4148">{</a>
<a name="ln4149">	if (fFocusRow)</a>
<a name="ln4150">		fMasterView-&gt;ExpandOrCollapse(fFocusRow, !fFocusRow-&gt;fIsExpanded);</a>
<a name="ln4151">}</a>
<a name="ln4152"> </a>
<a name="ln4153"> </a>
<a name="ln4154">void</a>
<a name="ln4155">OutlineView::ExpandOrCollapse(BRow* parentRow, bool expand)</a>
<a name="ln4156">{</a>
<a name="ln4157">	// TODO: Could use CopyBits here to speed things up.</a>
<a name="ln4158"> </a>
<a name="ln4159">	if (parentRow == NULL)</a>
<a name="ln4160">		return;</a>
<a name="ln4161"> </a>
<a name="ln4162">	if (parentRow-&gt;fIsExpanded == expand)</a>
<a name="ln4163">		return;</a>
<a name="ln4164"> </a>
<a name="ln4165">	parentRow-&gt;fIsExpanded = expand;</a>
<a name="ln4166"> </a>
<a name="ln4167">	BRect parentRect;</a>
<a name="ln4168">	if (FindRect(parentRow, &amp;parentRect)) {</a>
<a name="ln4169">		// Determine my new height</a>
<a name="ln4170">		float subTreeHeight = 0.0;</a>
<a name="ln4171">		if (parentRow-&gt;fIsExpanded)</a>
<a name="ln4172">			for (RecursiveOutlineIterator iterator(parentRow-&gt;fChildList);</a>
<a name="ln4173">			     iterator.CurrentRow();</a>
<a name="ln4174">			     iterator.GoToNext()</a>
<a name="ln4175">			    )</a>
<a name="ln4176">			{</a>
<a name="ln4177">				subTreeHeight += iterator.CurrentRow()-&gt;Height()+1;</a>
<a name="ln4178">			}</a>
<a name="ln4179">		else</a>
<a name="ln4180">			for (RecursiveOutlineIterator iterator(parentRow-&gt;fChildList);</a>
<a name="ln4181">			     iterator.CurrentRow();</a>
<a name="ln4182">			     iterator.GoToNext()</a>
<a name="ln4183">			    )</a>
<a name="ln4184">			{</a>
<a name="ln4185">				subTreeHeight -= iterator.CurrentRow()-&gt;Height()+1;</a>
<a name="ln4186">			}</a>
<a name="ln4187">		fItemsHeight += subTreeHeight;</a>
<a name="ln4188"> </a>
<a name="ln4189">		// Adjust focus row if necessary.</a>
<a name="ln4190">		if (FindRect(fFocusRow, &amp;fFocusRowRect) == false) {</a>
<a name="ln4191">			// focus row is in a subtree that has collapsed,</a>
<a name="ln4192">			// move it up to the parent.</a>
<a name="ln4193">			fFocusRow = parentRow;</a>
<a name="ln4194">			FindRect(fFocusRow, &amp;fFocusRowRect);</a>
<a name="ln4195">		}</a>
<a name="ln4196"> </a>
<a name="ln4197">		Invalidate(BRect(0, parentRect.top, fVisibleRect.right,</a>
<a name="ln4198">			fVisibleRect.bottom));</a>
<a name="ln4199">		FixScrollBar(false);</a>
<a name="ln4200">	}</a>
<a name="ln4201">}</a>
<a name="ln4202"> </a>
<a name="ln4203">void</a>
<a name="ln4204">OutlineView::RemoveRow(BRow* row)</a>
<a name="ln4205">{</a>
<a name="ln4206">	if (row == NULL)</a>
<a name="ln4207">		return;</a>
<a name="ln4208"> </a>
<a name="ln4209">	BRow* parentRow;</a>
<a name="ln4210">	bool parentIsVisible;</a>
<a name="ln4211">	FindParent(row, &amp;parentRow, &amp;parentIsVisible);</a>
<a name="ln4212">		// NOTE: This could be a root row without a parent, in which case</a>
<a name="ln4213">		// it is always visible, though.</a>
<a name="ln4214"> </a>
<a name="ln4215">	// Adjust height for the visible sub-tree that is going to be removed.</a>
<a name="ln4216">	float subTreeHeight = 0.0f;</a>
<a name="ln4217">	if (parentIsVisible &amp;&amp; (parentRow == NULL || parentRow-&gt;fIsExpanded)) {</a>
<a name="ln4218">		// The row itself is visible at least.</a>
<a name="ln4219">		subTreeHeight = row-&gt;Height() + 1;</a>
<a name="ln4220">		if (row-&gt;fIsExpanded) {</a>
<a name="ln4221">			// Adjust for the height of visible sub-items as well.</a>
<a name="ln4222">			// (By default, the iterator follows open branches only.)</a>
<a name="ln4223">			for (RecursiveOutlineIterator iterator(row-&gt;fChildList);</a>
<a name="ln4224">				iterator.CurrentRow(); iterator.GoToNext())</a>
<a name="ln4225">				subTreeHeight += iterator.CurrentRow()-&gt;Height() + 1;</a>
<a name="ln4226">		}</a>
<a name="ln4227">		BRect invalid;</a>
<a name="ln4228">		if (FindRect(row, &amp;invalid)) {</a>
<a name="ln4229">			invalid.bottom = Bounds().bottom;</a>
<a name="ln4230">			if (invalid.IsValid())</a>
<a name="ln4231">				Invalidate(invalid);</a>
<a name="ln4232">		}</a>
<a name="ln4233">	}</a>
<a name="ln4234"> </a>
<a name="ln4235">	fItemsHeight -= subTreeHeight;</a>
<a name="ln4236"> </a>
<a name="ln4237">	FixScrollBar(false);</a>
<a name="ln4238">	int32 indent = 0;</a>
<a name="ln4239">	float top = 0.0;</a>
<a name="ln4240">	if (FindRow(fVisibleRect.top, &amp;indent, &amp;top) == NULL &amp;&amp; ScrollBar(B_VERTICAL) != NULL) {</a>
<a name="ln4241">		// after removing this row, no rows are actually visible any more,</a>
<a name="ln4242">		// force a scroll to make them visible again</a>
<a name="ln4243">		if (fItemsHeight &gt; fVisibleRect.Height())</a>
<a name="ln4244">			ScrollBy(0.0, fItemsHeight - fVisibleRect.Height() - Bounds().top);</a>
<a name="ln4245">		else</a>
<a name="ln4246">			ScrollBy(0.0, -Bounds().top);</a>
<a name="ln4247">	}</a>
<a name="ln4248">	if (parentRow != NULL) {</a>
<a name="ln4249">		parentRow-&gt;fChildList-&gt;RemoveItem(row);</a>
<a name="ln4250">		if (parentRow-&gt;fChildList-&gt;CountItems() == 0) {</a>
<a name="ln4251">			delete parentRow-&gt;fChildList;</a>
<a name="ln4252">			parentRow-&gt;fChildList = 0;</a>
<a name="ln4253">			// It was the last child row of the parent, which also means the</a>
<a name="ln4254">			// latch disappears.</a>
<a name="ln4255">			BRect parentRowRect;</a>
<a name="ln4256">			if (parentIsVisible &amp;&amp; FindRect(parentRow, &amp;parentRowRect))</a>
<a name="ln4257">				Invalidate(parentRowRect);</a>
<a name="ln4258">		}</a>
<a name="ln4259">	} else</a>
<a name="ln4260">		fRows.RemoveItem(row);</a>
<a name="ln4261"> </a>
<a name="ln4262">	// Adjust focus row if necessary.</a>
<a name="ln4263">	if (fFocusRow &amp;&amp; !FindRect(fFocusRow, &amp;fFocusRowRect)) {</a>
<a name="ln4264">		// focus row is in a subtree that is gone, move it up to the parent.</a>
<a name="ln4265">		fFocusRow = parentRow;</a>
<a name="ln4266">		if (fFocusRow)</a>
<a name="ln4267">			FindRect(fFocusRow, &amp;fFocusRowRect);</a>
<a name="ln4268">	}</a>
<a name="ln4269"> </a>
<a name="ln4270">	// Remove this from the selection if necessary</a>
<a name="ln4271">	if (row-&gt;fNextSelected != 0) {</a>
<a name="ln4272">		row-&gt;fNextSelected-&gt;fPrevSelected = row-&gt;fPrevSelected;</a>
<a name="ln4273">		row-&gt;fPrevSelected-&gt;fNextSelected = row-&gt;fNextSelected;</a>
<a name="ln4274">		row-&gt;fPrevSelected = 0;</a>
<a name="ln4275">		row-&gt;fNextSelected = 0;</a>
<a name="ln4276">		fMasterView-&gt;SelectionChanged();</a>
<a name="ln4277">	}</a>
<a name="ln4278"> </a>
<a name="ln4279">	fCurrentColumn = 0;</a>
<a name="ln4280">	fCurrentRow = 0;</a>
<a name="ln4281">	fCurrentField = 0;</a>
<a name="ln4282">}</a>
<a name="ln4283"> </a>
<a name="ln4284"> </a>
<a name="ln4285">BRowContainer*</a>
<a name="ln4286">OutlineView::RowList()</a>
<a name="ln4287">{</a>
<a name="ln4288">	return &amp;fRows;</a>
<a name="ln4289">}</a>
<a name="ln4290"> </a>
<a name="ln4291"> </a>
<a name="ln4292">void</a>
<a name="ln4293">OutlineView::UpdateRow(BRow* row)</a>
<a name="ln4294">{</a>
<a name="ln4295">	if (row) {</a>
<a name="ln4296">		// Determine if this row has changed its sort order</a>
<a name="ln4297">		BRow* parentRow = NULL;</a>
<a name="ln4298">		bool parentIsVisible = false;</a>
<a name="ln4299">		FindParent(row, &amp;parentRow, &amp;parentIsVisible);</a>
<a name="ln4300"> </a>
<a name="ln4301">		BRowContainer* list = (parentRow == NULL) ? &amp;fRows : parentRow-&gt;fChildList;</a>
<a name="ln4302"> </a>
<a name="ln4303">		if(list) {</a>
<a name="ln4304">			int32 rowIndex = list-&gt;IndexOf(row);</a>
<a name="ln4305">			ASSERT(rowIndex &gt;= 0);</a>
<a name="ln4306">			ASSERT(list-&gt;ItemAt(rowIndex) == row);</a>
<a name="ln4307"> </a>
<a name="ln4308">			bool rowMoved = false;</a>
<a name="ln4309">			if (rowIndex &gt; 0 &amp;&amp; CompareRows(list-&gt;ItemAt(rowIndex - 1), row) &gt; 0)</a>
<a name="ln4310">				rowMoved = true;</a>
<a name="ln4311"> </a>
<a name="ln4312">			if (rowIndex &lt; list-&gt;CountItems() - 1 &amp;&amp; CompareRows(list-&gt;ItemAt(rowIndex + 1),</a>
<a name="ln4313">				row) &lt; 0)</a>
<a name="ln4314">				rowMoved = true;</a>
<a name="ln4315"> </a>
<a name="ln4316">			if (rowMoved) {</a>
<a name="ln4317">				// Sort location of this row has changed.</a>
<a name="ln4318">				// Remove and re-add in the right spot</a>
<a name="ln4319">				SortList(list, parentIsVisible &amp;&amp; (parentRow == NULL || parentRow-&gt;fIsExpanded));</a>
<a name="ln4320">			} else if (parentIsVisible &amp;&amp; (parentRow == NULL || parentRow-&gt;fIsExpanded)) {</a>
<a name="ln4321">				BRect invalidRect;</a>
<a name="ln4322">				if (FindVisibleRect(row, &amp;invalidRect))</a>
<a name="ln4323">					Invalidate(invalidRect);</a>
<a name="ln4324">			}</a>
<a name="ln4325">		}</a>
<a name="ln4326">	}</a>
<a name="ln4327">}</a>
<a name="ln4328"> </a>
<a name="ln4329"> </a>
<a name="ln4330">void</a>
<a name="ln4331">OutlineView::AddRow(BRow* row, int32 Index, BRow* parentRow)</a>
<a name="ln4332">{</a>
<a name="ln4333">	if (!row)</a>
<a name="ln4334">		return;</a>
<a name="ln4335"> </a>
<a name="ln4336">	row-&gt;fParent = parentRow;</a>
<a name="ln4337"> </a>
<a name="ln4338">	if (fMasterView-&gt;SortingEnabled() &amp;&amp; !fSortColumns-&gt;IsEmpty()) {</a>
<a name="ln4339">		// Ignore index here.</a>
<a name="ln4340">		if (parentRow) {</a>
<a name="ln4341">			if (parentRow-&gt;fChildList == NULL)</a>
<a name="ln4342">				parentRow-&gt;fChildList = new BRowContainer;</a>
<a name="ln4343"> </a>
<a name="ln4344">			AddSorted(parentRow-&gt;fChildList, row);</a>
<a name="ln4345">		} else</a>
<a name="ln4346">			AddSorted(&amp;fRows, row);</a>
<a name="ln4347">	} else {</a>
<a name="ln4348">		// Note, a -1 index implies add to end if sorting is not enabled</a>
<a name="ln4349">		if (parentRow) {</a>
<a name="ln4350">			if (parentRow-&gt;fChildList == 0)</a>
<a name="ln4351">				parentRow-&gt;fChildList = new BRowContainer;</a>
<a name="ln4352"> </a>
<a name="ln4353">			if (Index &lt; 0 || Index &gt; parentRow-&gt;fChildList-&gt;CountItems())</a>
<a name="ln4354">				parentRow-&gt;fChildList-&gt;AddItem(row);</a>
<a name="ln4355">			else</a>
<a name="ln4356">				parentRow-&gt;fChildList-&gt;AddItem(row, Index);</a>
<a name="ln4357">		} else {</a>
<a name="ln4358">			if (Index &lt; 0 || Index &gt;= fRows.CountItems())</a>
<a name="ln4359">				fRows.AddItem(row);</a>
<a name="ln4360">			else</a>
<a name="ln4361">				fRows.AddItem(row, Index);</a>
<a name="ln4362">		}</a>
<a name="ln4363">	}</a>
<a name="ln4364"> </a>
<a name="ln4365">	if (parentRow == 0 || parentRow-&gt;fIsExpanded)</a>
<a name="ln4366">		fItemsHeight += row-&gt;Height() + 1;</a>
<a name="ln4367"> </a>
<a name="ln4368">	FixScrollBar(false);</a>
<a name="ln4369"> </a>
<a name="ln4370">	BRect newRowRect;</a>
<a name="ln4371">	bool newRowIsInOpenBranch = FindRect(row, &amp;newRowRect);</a>
<a name="ln4372"> </a>
<a name="ln4373">	if (fFocusRow &amp;&amp; fFocusRowRect.top &gt; newRowRect.bottom) {</a>
<a name="ln4374">		// The focus row has moved.</a>
<a name="ln4375">		Invalidate(fFocusRowRect);</a>
<a name="ln4376">		FindRect(fFocusRow, &amp;fFocusRowRect);</a>
<a name="ln4377">		Invalidate(fFocusRowRect);</a>
<a name="ln4378">	}</a>
<a name="ln4379"> </a>
<a name="ln4380">	if (newRowIsInOpenBranch) {</a>
<a name="ln4381">		if (fCurrentState == INACTIVE) {</a>
<a name="ln4382">			if (newRowRect.bottom &lt; fVisibleRect.top) {</a>
<a name="ln4383">				// The new row is totally above the current viewport, move</a>
<a name="ln4384">				// everything down and redraw the first line.</a>
<a name="ln4385">				BRect source(fVisibleRect);</a>
<a name="ln4386">				BRect dest(fVisibleRect);</a>
<a name="ln4387">				source.bottom -= row-&gt;Height() + 1;</a>
<a name="ln4388">				dest.top += row-&gt;Height() + 1;</a>
<a name="ln4389">				CopyBits(source, dest);</a>
<a name="ln4390">				Invalidate(BRect(fVisibleRect.left, fVisibleRect.top, fVisibleRect.right,</a>
<a name="ln4391">					fVisibleRect.top + newRowRect.Height()));</a>
<a name="ln4392">			} else if (newRowRect.top &lt; fVisibleRect.bottom) {</a>
<a name="ln4393">				// New item is somewhere in the current region.  Scroll everything</a>
<a name="ln4394">				// beneath it down and invalidate just the new row rect.</a>
<a name="ln4395">				BRect source(fVisibleRect.left, newRowRect.top, fVisibleRect.right,</a>
<a name="ln4396">					fVisibleRect.bottom - newRowRect.Height());</a>
<a name="ln4397">				BRect dest(source);</a>
<a name="ln4398">				dest.OffsetBy(0, newRowRect.Height() + 1);</a>
<a name="ln4399">				CopyBits(source, dest);</a>
<a name="ln4400">				Invalidate(newRowRect);</a>
<a name="ln4401">			} // otherwise, this is below the currently visible region</a>
<a name="ln4402">		} else {</a>
<a name="ln4403">			// Adding the item may have caused the item that the user is currently</a>
<a name="ln4404">			// selected to move.  This would cause annoying drawing and interaction</a>
<a name="ln4405">			// bugs, as the position of that item is cached.  If this happens, resize</a>
<a name="ln4406">			// the scroll bar, then scroll back so the selected item is in view.</a>
<a name="ln4407">			BRect targetRect;</a>
<a name="ln4408">			if (FindRect(fTargetRow, &amp;targetRect)) {</a>
<a name="ln4409">				float delta = targetRect.top - fTargetRowTop;</a>
<a name="ln4410">				if (delta != 0) {</a>
<a name="ln4411">					// This causes a jump because ScrollBy will copy a chunk of the view.</a>
<a name="ln4412">					// Since the actual contents of the view have been offset, we don't</a>
<a name="ln4413">					// want this, we just want to change the virtual origin of the window.</a>
<a name="ln4414">					// Constrain the clipping region so everything is clipped out so no</a>
<a name="ln4415">					// copy occurs.</a>
<a name="ln4416">					//</a>
<a name="ln4417">					//	xxx this currently doesn't work if the scroll bars aren't enabled.</a>
<a name="ln4418">					//  everything will still move anyway.  A minor annoyance.</a>
<a name="ln4419">					BRegion emptyRegion;</a>
<a name="ln4420">					ConstrainClippingRegion(&amp;emptyRegion);</a>
<a name="ln4421">					PushState();</a>
<a name="ln4422">					ScrollBy(0, delta);</a>
<a name="ln4423">					PopState();</a>
<a name="ln4424">					ConstrainClippingRegion(NULL);</a>
<a name="ln4425"> </a>
<a name="ln4426">					fTargetRowTop += delta;</a>
<a name="ln4427">					fClickPoint.y += delta;</a>
<a name="ln4428">					fLatchRect.OffsetBy(0, delta);</a>
<a name="ln4429">				}</a>
<a name="ln4430">			}</a>
<a name="ln4431">		}</a>
<a name="ln4432">	}</a>
<a name="ln4433"> </a>
<a name="ln4434">	// If the parent was previously childless, it will need to have a latch</a>
<a name="ln4435">	// drawn.</a>
<a name="ln4436">	BRect parentRect;</a>
<a name="ln4437">	if (parentRow &amp;&amp; parentRow-&gt;fChildList-&gt;CountItems() == 1</a>
<a name="ln4438">		&amp;&amp; FindVisibleRect(parentRow, &amp;parentRect))</a>
<a name="ln4439">		Invalidate(parentRect);</a>
<a name="ln4440">}</a>
<a name="ln4441"> </a>
<a name="ln4442"> </a>
<a name="ln4443">void</a>
<a name="ln4444">OutlineView::FixScrollBar(bool scrollToFit)</a>
<a name="ln4445">{</a>
<a name="ln4446">	BScrollBar* vScrollBar = ScrollBar(B_VERTICAL);</a>
<a name="ln4447">	if (vScrollBar) {</a>
<a name="ln4448">		if (fItemsHeight &gt; fVisibleRect.Height()) {</a>
<a name="ln4449">			float maxScrollBarValue = fItemsHeight - fVisibleRect.Height();</a>
<a name="ln4450">			vScrollBar-&gt;SetProportion(fVisibleRect.Height() / fItemsHeight);</a>
<a name="ln4451"> </a>
<a name="ln4452">			// If the user is scrolled down too far when making the range smaller, the list</a>
<a name="ln4453">			// will jump suddenly, which is undesirable.  In this case, don't fix the scroll</a>
<a name="ln4454">			// bar here. In ScrollTo, it checks to see if this has occured, and will</a>
<a name="ln4455">			// fix the scroll bars sneakily if the user has scrolled up far enough.</a>
<a name="ln4456">			if (scrollToFit || vScrollBar-&gt;Value() &lt;= maxScrollBarValue) {</a>
<a name="ln4457">				vScrollBar-&gt;SetRange(0.0, maxScrollBarValue);</a>
<a name="ln4458">				vScrollBar-&gt;SetSteps(20.0, fVisibleRect.Height());</a>
<a name="ln4459">			}</a>
<a name="ln4460">		} else if (vScrollBar-&gt;Value() == 0.0 || fItemsHeight == 0.0)</a>
<a name="ln4461">			vScrollBar-&gt;SetRange(0.0, 0.0);		// disable scroll bar.</a>
<a name="ln4462">	}</a>
<a name="ln4463">}</a>
<a name="ln4464"> </a>
<a name="ln4465"> </a>
<a name="ln4466">void</a>
<a name="ln4467">OutlineView::AddSorted(BRowContainer* list, BRow* row)</a>
<a name="ln4468">{</a>
<a name="ln4469">	if (list &amp;&amp; row) {</a>
<a name="ln4470">		// Find general vicinity with binary search.</a>
<a name="ln4471">		int32 lower = 0;</a>
<a name="ln4472">		int32 upper = list-&gt;CountItems()-1;</a>
<a name="ln4473">		while( lower &lt; upper ) {</a>
<a name="ln4474">			int32 middle = lower + (upper-lower+1)/2;</a>
<a name="ln4475">			int32 cmp = CompareRows(row, list-&gt;ItemAt(middle));</a>
<a name="ln4476">			if( cmp &lt; 0 ) upper = middle-1;</a>
<a name="ln4477">			else if( cmp &gt; 0 ) lower = middle+1;</a>
<a name="ln4478">			else lower = upper = middle;</a>
<a name="ln4479">		}</a>
<a name="ln4480"> </a>
<a name="ln4481">		// At this point, 'upper' and 'lower' at the last found item.</a>
<a name="ln4482">		// Arbitrarily use 'upper' and determine the final insertion</a>
<a name="ln4483">		// point -- either before or after this item.</a>
<a name="ln4484">		if( upper &lt; 0 ) upper = 0;</a>
<a name="ln4485">		else if( upper &lt; list-&gt;CountItems() ) {</a>
<a name="ln4486">			if( CompareRows(row, list-&gt;ItemAt(upper)) &gt; 0 ) upper++;</a>
<a name="ln4487">		}</a>
<a name="ln4488"> </a>
<a name="ln4489">		if (upper &gt;= list-&gt;CountItems())</a>
<a name="ln4490">			list-&gt;AddItem(row);				// Adding to end.</a>
<a name="ln4491">		else</a>
<a name="ln4492">			list-&gt;AddItem(row, upper);		// Insert</a>
<a name="ln4493">	}</a>
<a name="ln4494">}</a>
<a name="ln4495"> </a>
<a name="ln4496"> </a>
<a name="ln4497">int32</a>
<a name="ln4498">OutlineView::CompareRows(BRow* row1, BRow* row2)</a>
<a name="ln4499">{</a>
<a name="ln4500">	int32 itemCount (fSortColumns-&gt;CountItems());</a>
<a name="ln4501">	if (row1 &amp;&amp; row2) {</a>
<a name="ln4502">		for (int32 index = 0; index &lt; itemCount; index++) {</a>
<a name="ln4503">			BColumn* column = (BColumn*) fSortColumns-&gt;ItemAt(index);</a>
<a name="ln4504">			int comp = 0;</a>
<a name="ln4505">			BField* field1 = (BField*) row1-&gt;GetField(column-&gt;fFieldID);</a>
<a name="ln4506">			BField* field2 = (BField*) row2-&gt;GetField(column-&gt;fFieldID);</a>
<a name="ln4507">			if (field1 &amp;&amp; field2)</a>
<a name="ln4508">				comp = column-&gt;CompareFields(field1, field2);</a>
<a name="ln4509"> </a>
<a name="ln4510">			if (!column-&gt;fSortAscending)</a>
<a name="ln4511">				comp = -comp;</a>
<a name="ln4512"> </a>
<a name="ln4513">			if (comp != 0)</a>
<a name="ln4514">				return comp;</a>
<a name="ln4515">		}</a>
<a name="ln4516">	}</a>
<a name="ln4517">	return 0;</a>
<a name="ln4518">}</a>
<a name="ln4519"> </a>
<a name="ln4520"> </a>
<a name="ln4521">void</a>
<a name="ln4522">OutlineView::FrameResized(float width, float height)</a>
<a name="ln4523">{</a>
<a name="ln4524">	fVisibleRect.right = fVisibleRect.left + width;</a>
<a name="ln4525">	fVisibleRect.bottom = fVisibleRect.top + height;</a>
<a name="ln4526">	FixScrollBar(true);</a>
<a name="ln4527">	_inherited::FrameResized(width, height);</a>
<a name="ln4528">}</a>
<a name="ln4529"> </a>
<a name="ln4530"> </a>
<a name="ln4531">void</a>
<a name="ln4532">OutlineView::ScrollTo(BPoint position)</a>
<a name="ln4533">{</a>
<a name="ln4534">	fVisibleRect.OffsetTo(position.x, position.y);</a>
<a name="ln4535"> </a>
<a name="ln4536">	// In FixScrollBar, we might not have been able to change the size of</a>
<a name="ln4537">	// the scroll bar because the user was scrolled down too far.  Take</a>
<a name="ln4538">	// this opportunity to sneak it in if we can.</a>
<a name="ln4539">	BScrollBar* vScrollBar = ScrollBar(B_VERTICAL);</a>
<a name="ln4540">	float maxScrollBarValue = fItemsHeight - fVisibleRect.Height();</a>
<a name="ln4541">	float min, max;</a>
<a name="ln4542">	vScrollBar-&gt;GetRange(&amp;min, &amp;max);</a>
<a name="ln4543">	if (max != maxScrollBarValue &amp;&amp; position.y &gt; maxScrollBarValue)</a>
<a name="ln4544">		FixScrollBar(true);</a>
<a name="ln4545"> </a>
<a name="ln4546">	_inherited::ScrollTo(position);</a>
<a name="ln4547">}</a>
<a name="ln4548"> </a>
<a name="ln4549"> </a>
<a name="ln4550">const BRect&amp;</a>
<a name="ln4551">OutlineView::VisibleRect() const</a>
<a name="ln4552">{</a>
<a name="ln4553">	return fVisibleRect;</a>
<a name="ln4554">}</a>
<a name="ln4555"> </a>
<a name="ln4556"> </a>
<a name="ln4557">bool</a>
<a name="ln4558">OutlineView::FindVisibleRect(BRow* row, BRect* _rect)</a>
<a name="ln4559">{</a>
<a name="ln4560">	if (row &amp;&amp; _rect) {</a>
<a name="ln4561">		float line = 0.0;</a>
<a name="ln4562">		for (RecursiveOutlineIterator iterator(&amp;fRows); iterator.CurrentRow();</a>
<a name="ln4563">			iterator.GoToNext()) {</a>
<a name="ln4564"> </a>
<a name="ln4565">			if (iterator.CurrentRow() == row) {</a>
<a name="ln4566">				_rect-&gt;Set(fVisibleRect.left, line, fVisibleRect.right,</a>
<a name="ln4567">					line + row-&gt;Height());</a>
<a name="ln4568">				return line &lt;= fVisibleRect.bottom;</a>
<a name="ln4569">			}</a>
<a name="ln4570"> </a>
<a name="ln4571">			line += iterator.CurrentRow()-&gt;Height() + 1;</a>
<a name="ln4572">		}</a>
<a name="ln4573">	}</a>
<a name="ln4574">	return false;</a>
<a name="ln4575">}</a>
<a name="ln4576"> </a>
<a name="ln4577"> </a>
<a name="ln4578">bool</a>
<a name="ln4579">OutlineView::FindRect(const BRow* row, BRect* _rect)</a>
<a name="ln4580">{</a>
<a name="ln4581">	float line = 0.0;</a>
<a name="ln4582">	for (RecursiveOutlineIterator iterator(&amp;fRows); iterator.CurrentRow();</a>
<a name="ln4583">		iterator.GoToNext()) {</a>
<a name="ln4584">		if (iterator.CurrentRow() == row) {</a>
<a name="ln4585">			_rect-&gt;Set(fVisibleRect.left, line, fVisibleRect.right,</a>
<a name="ln4586">				line + row-&gt;Height());</a>
<a name="ln4587">			return true;</a>
<a name="ln4588">		}</a>
<a name="ln4589"> </a>
<a name="ln4590">		line += iterator.CurrentRow()-&gt;Height() + 1;</a>
<a name="ln4591">	}</a>
<a name="ln4592"> </a>
<a name="ln4593">	return false;</a>
<a name="ln4594">}</a>
<a name="ln4595"> </a>
<a name="ln4596"> </a>
<a name="ln4597">void</a>
<a name="ln4598">OutlineView::ScrollTo(const BRow* row)</a>
<a name="ln4599">{</a>
<a name="ln4600">	BRect rect;</a>
<a name="ln4601">	if (FindRect(row, &amp;rect)) {</a>
<a name="ln4602">		BRect bounds = Bounds();</a>
<a name="ln4603">		if (rect.top &lt; bounds.top)</a>
<a name="ln4604">			ScrollTo(BPoint(bounds.left, rect.top));</a>
<a name="ln4605">		else if (rect.bottom &gt; bounds.bottom)</a>
<a name="ln4606">			ScrollBy(0, rect.bottom - bounds.bottom);</a>
<a name="ln4607">	}</a>
<a name="ln4608">}</a>
<a name="ln4609"> </a>
<a name="ln4610"> </a>
<a name="ln4611">void</a>
<a name="ln4612">OutlineView::DeselectAll()</a>
<a name="ln4613">{</a>
<a name="ln4614">	// Invalidate all selected rows</a>
<a name="ln4615">	float line = 0.0;</a>
<a name="ln4616">	for (RecursiveOutlineIterator iterator(&amp;fRows); iterator.CurrentRow();</a>
<a name="ln4617">		iterator.GoToNext()) {</a>
<a name="ln4618">		if (line &gt; fVisibleRect.bottom)</a>
<a name="ln4619">			break;</a>
<a name="ln4620"> </a>
<a name="ln4621">		BRow* row = iterator.CurrentRow();</a>
<a name="ln4622">		if (line + row-&gt;Height() &gt; fVisibleRect.top) {</a>
<a name="ln4623">			if (row-&gt;fNextSelected != 0)</a>
<a name="ln4624">				Invalidate(BRect(fVisibleRect.left, line, fVisibleRect.right,</a>
<a name="ln4625">					line + row-&gt;Height()));</a>
<a name="ln4626">		}</a>
<a name="ln4627"> </a>
<a name="ln4628">		line += row-&gt;Height() + 1;</a>
<a name="ln4629">	}</a>
<a name="ln4630"> </a>
<a name="ln4631">	// Set items not selected</a>
<a name="ln4632">	while (fSelectionListDummyHead.fNextSelected != &amp;fSelectionListDummyHead) {</a>
<a name="ln4633">		BRow* row = fSelectionListDummyHead.fNextSelected;</a>
<a name="ln4634">		row-&gt;fNextSelected-&gt;fPrevSelected = row-&gt;fPrevSelected;</a>
<a name="ln4635">		row-&gt;fPrevSelected-&gt;fNextSelected = row-&gt;fNextSelected;</a>
<a name="ln4636">		row-&gt;fNextSelected = 0;</a>
<a name="ln4637">		row-&gt;fPrevSelected = 0;</a>
<a name="ln4638">	}</a>
<a name="ln4639">}</a>
<a name="ln4640"> </a>
<a name="ln4641"> </a>
<a name="ln4642">BRow*</a>
<a name="ln4643">OutlineView::FocusRow() const</a>
<a name="ln4644">{</a>
<a name="ln4645">	return fFocusRow;</a>
<a name="ln4646">}</a>
<a name="ln4647"> </a>
<a name="ln4648"> </a>
<a name="ln4649">void</a>
<a name="ln4650">OutlineView::SetFocusRow(BRow* row, bool Select)</a>
<a name="ln4651">{</a>
<a name="ln4652">	if (row) {</a>
<a name="ln4653">		if (Select)</a>
<a name="ln4654">			AddToSelection(row);</a>
<a name="ln4655"> </a>
<a name="ln4656">		if (fFocusRow == row)</a>
<a name="ln4657">			return;</a>
<a name="ln4658"> </a>
<a name="ln4659">		Invalidate(fFocusRowRect); // invalidate previous</a>
<a name="ln4660"> </a>
<a name="ln4661">		fTargetRow = fFocusRow = row;</a>
<a name="ln4662"> </a>
<a name="ln4663">		FindVisibleRect(fFocusRow, &amp;fFocusRowRect);</a>
<a name="ln4664">		Invalidate(fFocusRowRect); // invalidate current</a>
<a name="ln4665"> </a>
<a name="ln4666">		fFocusRowRect.right = 10000;</a>
<a name="ln4667">		fMasterView-&gt;SelectionChanged();</a>
<a name="ln4668">	}</a>
<a name="ln4669">}</a>
<a name="ln4670"> </a>
<a name="ln4671"> </a>
<a name="ln4672">bool</a>
<a name="ln4673">OutlineView::SortList(BRowContainer* list, bool isVisible)</a>
<a name="ln4674">{</a>
<a name="ln4675">	if (list) {</a>
<a name="ln4676">		// Shellsort</a>
<a name="ln4677">		BRow** items</a>
<a name="ln4678">			= (BRow**) BObjectList&lt;BRow&gt;::Private(list).AsBList()-&gt;Items();</a>
<a name="ln4679">		int32 numItems = list-&gt;CountItems();</a>
<a name="ln4680">		int h;</a>
<a name="ln4681">		for (h = 1; h &lt; numItems / 9; h = 3 * h + 1)</a>
<a name="ln4682">			;</a>
<a name="ln4683"> </a>
<a name="ln4684">		for (;h &gt; 0; h /= 3) {</a>
<a name="ln4685">			for (int step = h; step &lt; numItems; step++) {</a>
<a name="ln4686">				BRow* temp = items[step];</a>
<a name="ln4687">				int i;</a>
<a name="ln4688">				for (i = step - h; i &gt;= 0; i -= h) {</a>
<a name="ln4689">					if (CompareRows(temp, items[i]) &lt; 0)</a>
<a name="ln4690">						items[i + h] = items[i];</a>
<a name="ln4691">					else</a>
<a name="ln4692">						break;</a>
<a name="ln4693">				}</a>
<a name="ln4694"> </a>
<a name="ln4695">				items[i + h] = temp;</a>
<a name="ln4696">			}</a>
<a name="ln4697">		}</a>
<a name="ln4698"> </a>
<a name="ln4699">		if (isVisible) {</a>
<a name="ln4700">			Invalidate();</a>
<a name="ln4701"> </a>
<a name="ln4702">			InvalidateCachedPositions();</a>
<a name="ln4703">			int lockCount = Window()-&gt;CountLocks();</a>
<a name="ln4704">			for (int i = 0; i &lt; lockCount; i++)</a>
<a name="ln4705">				Window()-&gt;Unlock();</a>
<a name="ln4706"> </a>
<a name="ln4707">			while (lockCount--)</a>
<a name="ln4708">				if (!Window()-&gt;Lock())</a>
<a name="ln4709">					return false;	// Window is gone...</a>
<a name="ln4710">		}</a>
<a name="ln4711">	}</a>
<a name="ln4712">	return true;</a>
<a name="ln4713">}</a>
<a name="ln4714"> </a>
<a name="ln4715"> </a>
<a name="ln4716">int32</a>
<a name="ln4717">OutlineView::DeepSortThreadEntry(void* _outlineView)</a>
<a name="ln4718">{</a>
<a name="ln4719">	((OutlineView*) _outlineView)-&gt;DeepSort();</a>
<a name="ln4720">	return 0;</a>
<a name="ln4721">}</a>
<a name="ln4722"> </a>
<a name="ln4723"> </a>
<a name="ln4724">void</a>
<a name="ln4725">OutlineView::DeepSort()</a>
<a name="ln4726">{</a>
<a name="ln4727">	struct stack_entry {</a>
<a name="ln4728">		bool isVisible;</a>
<a name="ln4729">		BRowContainer* list;</a>
<a name="ln4730">		int32 listIndex;</a>
<a name="ln4731">	} stack[kMaxDepth];</a>
<a name="ln4732">	int32 stackTop = 0;</a>
<a name="ln4733"> </a>
<a name="ln4734">	stack[stackTop].list = &amp;fRows;</a>
<a name="ln4735">	stack[stackTop].isVisible = true;</a>
<a name="ln4736">	stack[stackTop].listIndex = 0;</a>
<a name="ln4737">	fNumSorted = 0;</a>
<a name="ln4738"> </a>
<a name="ln4739">	if (Window()-&gt;Lock() == false)</a>
<a name="ln4740">		return;</a>
<a name="ln4741"> </a>
<a name="ln4742">	bool doneSorting = false;</a>
<a name="ln4743">	while (!doneSorting &amp;&amp; !fSortCancelled) {</a>
<a name="ln4744"> </a>
<a name="ln4745">		stack_entry* currentEntry = &amp;stack[stackTop];</a>
<a name="ln4746"> </a>
<a name="ln4747">		// xxx Can make the invalidate area smaller by finding the rect for the</a>
<a name="ln4748">		// parent item and using that as the top of the invalid rect.</a>
<a name="ln4749"> </a>
<a name="ln4750">		bool haveLock = SortList(currentEntry-&gt;list, currentEntry-&gt;isVisible);</a>
<a name="ln4751">		if (!haveLock)</a>
<a name="ln4752">			return ;	// window is gone.</a>
<a name="ln4753"> </a>
<a name="ln4754">		// Fix focus rect.</a>
<a name="ln4755">		InvalidateCachedPositions();</a>
<a name="ln4756">		if (fCurrentState != INACTIVE)</a>
<a name="ln4757">			fCurrentState = INACTIVE;	// sorry...</a>
<a name="ln4758"> </a>
<a name="ln4759">		// next list.</a>
<a name="ln4760">		bool foundNextList = false;</a>
<a name="ln4761">		while (!foundNextList &amp;&amp; !fSortCancelled) {</a>
<a name="ln4762">			for (int32 index = currentEntry-&gt;listIndex; index &lt; currentEntry-&gt;list-&gt;CountItems();</a>
<a name="ln4763">				index++) {</a>
<a name="ln4764">				BRow* parentRow = currentEntry-&gt;list-&gt;ItemAt(index);</a>
<a name="ln4765">				BRowContainer* childList = parentRow-&gt;fChildList;</a>
<a name="ln4766">				if (childList != 0) {</a>
<a name="ln4767">					currentEntry-&gt;listIndex = index + 1;</a>
<a name="ln4768">					stackTop++;</a>
<a name="ln4769">					ASSERT(stackTop &lt; kMaxDepth);</a>
<a name="ln4770">					stack[stackTop].listIndex = 0;</a>
<a name="ln4771">					stack[stackTop].list = childList;</a>
<a name="ln4772">					stack[stackTop].isVisible = (currentEntry-&gt;isVisible &amp;&amp; parentRow-&gt;fIsExpanded);</a>
<a name="ln4773">					foundNextList = true;</a>
<a name="ln4774">					break;</a>
<a name="ln4775">				}</a>
<a name="ln4776">			}</a>
<a name="ln4777"> </a>
<a name="ln4778">			if (!foundNextList) {</a>
<a name="ln4779">				// back up</a>
<a name="ln4780">				if (--stackTop &lt; 0) {</a>
<a name="ln4781">					doneSorting = true;</a>
<a name="ln4782">					break;</a>
<a name="ln4783">				}</a>
<a name="ln4784"> </a>
<a name="ln4785">				currentEntry = &amp;stack[stackTop];</a>
<a name="ln4786">			}</a>
<a name="ln4787">		}</a>
<a name="ln4788">	}</a>
<a name="ln4789"> </a>
<a name="ln4790">	Window()-&gt;Unlock();</a>
<a name="ln4791">}</a>
<a name="ln4792"> </a>
<a name="ln4793"> </a>
<a name="ln4794">void</a>
<a name="ln4795">OutlineView::StartSorting()</a>
<a name="ln4796">{</a>
<a name="ln4797">	// If this view is not yet attached to a window, don't start a sort thread!</a>
<a name="ln4798">	if (Window() == NULL)</a>
<a name="ln4799">		return;</a>
<a name="ln4800"> </a>
<a name="ln4801">	if (fSortThread != B_BAD_THREAD_ID) {</a>
<a name="ln4802">		thread_info tinfo;</a>
<a name="ln4803">		if (get_thread_info(fSortThread, &amp;tinfo) == B_OK) {</a>
<a name="ln4804">			// Unlock window so this won't deadlock (sort thread is probably</a>
<a name="ln4805">			// waiting to lock window).</a>
<a name="ln4806"> </a>
<a name="ln4807">			int lockCount = Window()-&gt;CountLocks();</a>
<a name="ln4808">			for (int i = 0; i &lt; lockCount; i++)</a>
<a name="ln4809">				Window()-&gt;Unlock();</a>
<a name="ln4810"> </a>
<a name="ln4811">			fSortCancelled = true;</a>
<a name="ln4812">			int32 status;</a>
<a name="ln4813">			wait_for_thread(fSortThread, &amp;status);</a>
<a name="ln4814"> </a>
<a name="ln4815">			while (lockCount--)</a>
<a name="ln4816">				if (!Window()-&gt;Lock())</a>
<a name="ln4817">					return ;	// Window is gone...</a>
<a name="ln4818">		}</a>
<a name="ln4819">	}</a>
<a name="ln4820"> </a>
<a name="ln4821">	fSortCancelled = false;</a>
<a name="ln4822">	fSortThread = spawn_thread(DeepSortThreadEntry, &quot;sort_thread&quot;, B_NORMAL_PRIORITY, this);</a>
<a name="ln4823">	resume_thread(fSortThread);</a>
<a name="ln4824">}</a>
<a name="ln4825"> </a>
<a name="ln4826"> </a>
<a name="ln4827">void</a>
<a name="ln4828">OutlineView::SelectRange(BRow* start, BRow* end)</a>
<a name="ln4829">{</a>
<a name="ln4830">	if (!start || !end)</a>
<a name="ln4831">		return;</a>
<a name="ln4832"> </a>
<a name="ln4833">	if (start == end)	// start is always selected when this is called</a>
<a name="ln4834">		return;</a>
<a name="ln4835"> </a>
<a name="ln4836">	RecursiveOutlineIterator iterator(&amp;fRows, false);</a>
<a name="ln4837">	while (iterator.CurrentRow() != 0) {</a>
<a name="ln4838">		if (iterator.CurrentRow() == end) {</a>
<a name="ln4839">			// reverse selection, swap to fix special case</a>
<a name="ln4840">			BRow* temp = start;</a>
<a name="ln4841">			start = end;</a>
<a name="ln4842">			end = temp;</a>
<a name="ln4843">			break;</a>
<a name="ln4844">		} else if (iterator.CurrentRow() == start)</a>
<a name="ln4845">			break;</a>
<a name="ln4846"> </a>
<a name="ln4847">		iterator.GoToNext();</a>
<a name="ln4848">	}</a>
<a name="ln4849"> </a>
<a name="ln4850">	while (true) {</a>
<a name="ln4851">		BRow* row = iterator.CurrentRow();</a>
<a name="ln4852">		if (row) {</a>
<a name="ln4853">			if (row-&gt;fNextSelected == 0) {</a>
<a name="ln4854">				row-&gt;fNextSelected = fSelectionListDummyHead.fNextSelected;</a>
<a name="ln4855">				row-&gt;fPrevSelected = &amp;fSelectionListDummyHead;</a>
<a name="ln4856">				row-&gt;fNextSelected-&gt;fPrevSelected = row;</a>
<a name="ln4857">				row-&gt;fPrevSelected-&gt;fNextSelected = row;</a>
<a name="ln4858">			}</a>
<a name="ln4859">		} else</a>
<a name="ln4860">			break;</a>
<a name="ln4861"> </a>
<a name="ln4862">		if (row == end)</a>
<a name="ln4863">			break;</a>
<a name="ln4864"> </a>
<a name="ln4865">		iterator.GoToNext();</a>
<a name="ln4866">	}</a>
<a name="ln4867"> </a>
<a name="ln4868">	Invalidate();  // xxx make invalidation smaller</a>
<a name="ln4869">}</a>
<a name="ln4870"> </a>
<a name="ln4871"> </a>
<a name="ln4872">bool</a>
<a name="ln4873">OutlineView::FindParent(BRow* row, BRow** outParent, bool* outParentIsVisible)</a>
<a name="ln4874">{</a>
<a name="ln4875">	bool result = false;</a>
<a name="ln4876">	if (row != NULL &amp;&amp; outParent != NULL) {</a>
<a name="ln4877">		*outParent = row-&gt;fParent;</a>
<a name="ln4878"> </a>
<a name="ln4879">		if (outParentIsVisible != NULL) {</a>
<a name="ln4880">			// Walk up the parent chain to determine if this row is visible</a>
<a name="ln4881">			*outParentIsVisible = true;</a>
<a name="ln4882">			for (BRow* currentRow = row-&gt;fParent; currentRow != NULL;</a>
<a name="ln4883">				currentRow = currentRow-&gt;fParent) {</a>
<a name="ln4884">				if (!currentRow-&gt;fIsExpanded) {</a>
<a name="ln4885">					*outParentIsVisible = false;</a>
<a name="ln4886">					break;</a>
<a name="ln4887">				}</a>
<a name="ln4888">			}</a>
<a name="ln4889">		}</a>
<a name="ln4890"> </a>
<a name="ln4891">		result = *outParent != NULL;</a>
<a name="ln4892">	}</a>
<a name="ln4893"> </a>
<a name="ln4894">	return result;</a>
<a name="ln4895">}</a>
<a name="ln4896"> </a>
<a name="ln4897"> </a>
<a name="ln4898">int32</a>
<a name="ln4899">OutlineView::IndexOf(BRow* row)</a>
<a name="ln4900">{</a>
<a name="ln4901">	if (row) {</a>
<a name="ln4902">		if (row-&gt;fParent == 0)</a>
<a name="ln4903">			return fRows.IndexOf(row);</a>
<a name="ln4904"> </a>
<a name="ln4905">		ASSERT(row-&gt;fParent-&gt;fChildList);</a>
<a name="ln4906">		return row-&gt;fParent-&gt;fChildList-&gt;IndexOf(row);</a>
<a name="ln4907">	}</a>
<a name="ln4908"> </a>
<a name="ln4909">	return B_ERROR;</a>
<a name="ln4910">}</a>
<a name="ln4911"> </a>
<a name="ln4912"> </a>
<a name="ln4913">void</a>
<a name="ln4914">OutlineView::InvalidateCachedPositions()</a>
<a name="ln4915">{</a>
<a name="ln4916">	if (fFocusRow)</a>
<a name="ln4917">		FindRect(fFocusRow, &amp;fFocusRowRect);</a>
<a name="ln4918">}</a>
<a name="ln4919"> </a>
<a name="ln4920"> </a>
<a name="ln4921">float</a>
<a name="ln4922">OutlineView::GetColumnPreferredWidth(BColumn* column)</a>
<a name="ln4923">{</a>
<a name="ln4924">	float preferred = 0.0;</a>
<a name="ln4925">	for (RecursiveOutlineIterator iterator(&amp;fRows); BRow* row =</a>
<a name="ln4926">		iterator.CurrentRow(); iterator.GoToNext()) {</a>
<a name="ln4927">		BField* field = row-&gt;GetField(column-&gt;fFieldID);</a>
<a name="ln4928">		if (field) {</a>
<a name="ln4929">			float width = column-&gt;GetPreferredWidth(field, this)</a>
<a name="ln4930">				+ iterator.CurrentLevel() * kOutlineLevelIndent;</a>
<a name="ln4931">			preferred = max_c(preferred, width);</a>
<a name="ln4932">		}</a>
<a name="ln4933">	}</a>
<a name="ln4934"> </a>
<a name="ln4935">	BString name;</a>
<a name="ln4936">	column-&gt;GetColumnName(&amp;name);</a>
<a name="ln4937">	preferred = max_c(preferred, StringWidth(name));</a>
<a name="ln4938"> </a>
<a name="ln4939">	// Constrain to preferred width. This makes the method do a little</a>
<a name="ln4940">	// more than asked, but it's for convenience.</a>
<a name="ln4941">	if (preferred &lt; column-&gt;MinWidth())</a>
<a name="ln4942">		preferred = column-&gt;MinWidth();</a>
<a name="ln4943">	else if (preferred &gt; column-&gt;MaxWidth())</a>
<a name="ln4944">		preferred = column-&gt;MaxWidth();</a>
<a name="ln4945"> </a>
<a name="ln4946">	return preferred;</a>
<a name="ln4947">}</a>
<a name="ln4948"> </a>
<a name="ln4949"> </a>
<a name="ln4950">// #pragma mark -</a>
<a name="ln4951"> </a>
<a name="ln4952"> </a>
<a name="ln4953">RecursiveOutlineIterator::RecursiveOutlineIterator(BRowContainer* list,</a>
<a name="ln4954">	bool openBranchesOnly)</a>
<a name="ln4955">	:</a>
<a name="ln4956">	fStackIndex(0),</a>
<a name="ln4957">	fCurrentListIndex(0),</a>
<a name="ln4958">	fCurrentListDepth(0),</a>
<a name="ln4959">	fOpenBranchesOnly(openBranchesOnly)</a>
<a name="ln4960">{</a>
<a name="ln4961">	if (list == 0 || list-&gt;CountItems() == 0)</a>
<a name="ln4962">		fCurrentList = 0;</a>
<a name="ln4963">	else</a>
<a name="ln4964">		fCurrentList = list;</a>
<a name="ln4965">}</a>
<a name="ln4966"> </a>
<a name="ln4967"> </a>
<a name="ln4968">BRow*</a>
<a name="ln4969">RecursiveOutlineIterator::CurrentRow() const</a>
<a name="ln4970">{</a>
<a name="ln4971">	if (fCurrentList == 0)</a>
<a name="ln4972">		return 0;</a>
<a name="ln4973"> </a>
<a name="ln4974">	return fCurrentList-&gt;ItemAt(fCurrentListIndex);</a>
<a name="ln4975">}</a>
<a name="ln4976"> </a>
<a name="ln4977"> </a>
<a name="ln4978">void</a>
<a name="ln4979">RecursiveOutlineIterator::GoToNext()</a>
<a name="ln4980">{</a>
<a name="ln4981">	if (fCurrentList == 0)</a>
<a name="ln4982">		return;</a>
<a name="ln4983">	if (fCurrentListIndex &lt; 0 || fCurrentListIndex &gt;= fCurrentList-&gt;CountItems()) {</a>
<a name="ln4984">		fCurrentList = 0;</a>
<a name="ln4985">		return;</a>
<a name="ln4986">	}</a>
<a name="ln4987"> </a>
<a name="ln4988">	BRow* currentRow = fCurrentList-&gt;ItemAt(fCurrentListIndex);</a>
<a name="ln4989">	if(currentRow) {</a>
<a name="ln4990">		if (currentRow-&gt;fChildList &amp;&amp; (currentRow-&gt;fIsExpanded || !fOpenBranchesOnly)</a>
<a name="ln4991">			&amp;&amp; currentRow-&gt;fChildList-&gt;CountItems() &gt; 0) {</a>
<a name="ln4992">			// Visit child.</a>
<a name="ln4993">			// Put current list on the stack if it needs to be revisited.</a>
<a name="ln4994">			if (fCurrentListIndex &lt; fCurrentList-&gt;CountItems() - 1) {</a>
<a name="ln4995">				fStack[fStackIndex].fRowSet = fCurrentList;</a>
<a name="ln4996">				fStack[fStackIndex].fIndex = fCurrentListIndex + 1;</a>
<a name="ln4997">				fStack[fStackIndex].fDepth = fCurrentListDepth;</a>
<a name="ln4998">				fStackIndex++;</a>
<a name="ln4999">			}</a>
<a name="ln5000"> </a>
<a name="ln5001">			fCurrentList = currentRow-&gt;fChildList;</a>
<a name="ln5002">			fCurrentListIndex = 0;</a>
<a name="ln5003">			fCurrentListDepth++;</a>
<a name="ln5004">		} else if (fCurrentListIndex &lt; fCurrentList-&gt;CountItems() - 1)</a>
<a name="ln5005">			fCurrentListIndex++; // next item in current list</a>
<a name="ln5006">		else if (--fStackIndex &gt;= 0) {</a>
<a name="ln5007">			fCurrentList = fStack[fStackIndex].fRowSet;</a>
<a name="ln5008">			fCurrentListIndex = fStack[fStackIndex].fIndex;</a>
<a name="ln5009">			fCurrentListDepth = fStack[fStackIndex].fDepth;</a>
<a name="ln5010">		} else</a>
<a name="ln5011">			fCurrentList = 0;</a>
<a name="ln5012">	}</a>
<a name="ln5013">}</a>
<a name="ln5014"> </a>
<a name="ln5015"> </a>
<a name="ln5016">int32</a>
<a name="ln5017">RecursiveOutlineIterator::CurrentLevel() const</a>
<a name="ln5018">{</a>
<a name="ln5019">	return fCurrentListDepth;</a>
<a name="ln5020">}</a>
<a name="ln5021"> </a>
<a name="ln5022"> </a>

</code></pre>
<div class="balloon" rel="585"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fFieldID, fSortAscending, fWantsEvents.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
