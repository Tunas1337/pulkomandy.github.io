
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Ports.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2015, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> *		Michael Lotz, mmlr@mlotz.ch</a>
<a name="ln8"> *		Alexander von Gluck IV, kallisti5@unixzen.com</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;Ports.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;ddc.h&gt;</a>
<a name="ln15">#include &lt;stdlib.h&gt;</a>
<a name="ln16">#include &lt;string.h&gt;</a>
<a name="ln17">#include &lt;Debug.h&gt;</a>
<a name="ln18">#include &lt;KernelExport.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;accelerant.h&quot;</a>
<a name="ln21">#include &quot;accelerant_protos.h&quot;</a>
<a name="ln22">#include &quot;FlexibleDisplayInterface.h&quot;</a>
<a name="ln23">#include &quot;intel_extreme.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;new&gt;</a>
<a name="ln26"> </a>
<a name="ln27"> </a>
<a name="ln28">#undef TRACE</a>
<a name="ln29">#define TRACE_PORTS</a>
<a name="ln30">#ifdef TRACE_PORTS</a>
<a name="ln31">#   define TRACE(x...) _sPrintf(&quot;intel_extreme: &quot; x)</a>
<a name="ln32">#else</a>
<a name="ln33">#   define TRACE(x...)</a>
<a name="ln34">#endif</a>
<a name="ln35"> </a>
<a name="ln36">#define ERROR(x...) _sPrintf(&quot;intel_extreme: &quot; x)</a>
<a name="ln37">#define CALLED(x...) TRACE(&quot;CALLED %s\n&quot;, __PRETTY_FUNCTION__)</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">static bool</a>
<a name="ln41">wait_for_set(addr_t address, uint32 mask, uint32 timeout)</a>
<a name="ln42">{</a>
<a name="ln43">	int interval = 50;</a>
<a name="ln44">	uint32 i = 0;</a>
<a name="ln45">	for(i = 0; i &lt;= timeout; i += interval) {</a>
<a name="ln46">		spin(interval);</a>
<a name="ln47">		if ((read32(address) &amp; mask) != 0)</a>
<a name="ln48">			return true;</a>
<a name="ln49">	}</a>
<a name="ln50">	return false;</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">static bool</a>
<a name="ln55">wait_for_clear(addr_t address, uint32 mask, uint32 timeout)</a>
<a name="ln56">{</a>
<a name="ln57">	int interval = 50;</a>
<a name="ln58">	uint32 i = 0;</a>
<a name="ln59">	for(i = 0; i &lt;= timeout; i += interval) {</a>
<a name="ln60">		spin(interval);</a>
<a name="ln61">		if ((read32(address) &amp; mask) == 0)</a>
<a name="ln62">			return true;</a>
<a name="ln63">	}</a>
<a name="ln64">	return false;</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">Port::Port(port_index index, const char* baseName)</a>
<a name="ln69">	:</a>
<a name="ln70">	fPipe(NULL),</a>
<a name="ln71">	fEDIDState(B_NO_INIT),</a>
<a name="ln72">	fPortIndex(index),</a>
<a name="ln73">	fPortName(NULL)</a>
<a name="ln74">{</a>
<a name="ln75">	char portID[2];</a>
<a name="ln76">	portID[0] = 'A' + index - INTEL_PORT_A;</a>
<a name="ln77">	portID[1] = 0;</a>
<a name="ln78"> </a>
<a name="ln79">	char buffer[32];</a>
<a name="ln80">	buffer[0] = 0;</a>
<a name="ln81"> </a>
<a name="ln82">	strlcat(buffer, baseName, sizeof(buffer));</a>
<a name="ln83">	strlcat(buffer, &quot; &quot;, sizeof(buffer));</a>
<a name="ln84">	strlcat(buffer, portID, sizeof(buffer));</a>
<a name="ln85">	fPortName = strdup(buffer);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88"> </a>
<a name="ln89">Port::~Port()</a>
<a name="ln90">{</a>
<a name="ln91">	free(fPortName);</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">bool</a>
<a name="ln96">Port::HasEDID()</a>
<a name="ln97">{</a>
<a name="ln98">	if (fEDIDState == B_NO_INIT)</a>
<a name="ln99">		GetEDID(NULL);</a>
<a name="ln100"> </a>
<a name="ln101">	return fEDIDState == B_OK;</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104"> </a>
<a name="ln105">status_t</a>
<a name="ln106">Port::SetPipe(Pipe* pipe)</a>
<a name="ln107">{</a>
<a name="ln108">	CALLED();</a>
<a name="ln109"> </a>
<a name="ln110">	if (pipe == NULL) {</a>
<a name="ln111">		ERROR(&quot;%s: Invalid pipe provided!\n&quot;, __func__);</a>
<a name="ln112">		return B_ERROR;</a>
<a name="ln113">	}</a>
<a name="ln114"> </a>
<a name="ln115">	uint32 portRegister = _PortRegister();</a>
<a name="ln116">	if (portRegister == 0) {</a>
<a name="ln117">		ERROR(&quot;%s: Invalid PortRegister ((0x%&quot; B_PRIx32 &quot;) for %s\n&quot;, __func__,</a>
<a name="ln118">			portRegister, PortName());</a>
<a name="ln119">		return B_ERROR;</a>
<a name="ln120">	}</a>
<a name="ln121"> </a>
<a name="ln122">	// TODO: UnAssignPipe?  This likely needs reworked a little</a>
<a name="ln123">	if (fPipe != NULL) {</a>
<a name="ln124">		ERROR(&quot;%s: Can't reassign display pipe (yet)\n&quot;, __func__);</a>
<a name="ln125">		return B_ERROR;</a>
<a name="ln126">	}</a>
<a name="ln127"> </a>
<a name="ln128">	TRACE(&quot;%s: Assigning %s (0x%&quot; B_PRIx32 &quot;) to pipe %s\n&quot;, __func__,</a>
<a name="ln129">		PortName(), portRegister, (pipe-&gt;Index() == INTEL_PIPE_A) ? &quot;A&quot; : &quot;B&quot;);</a>
<a name="ln130"> </a>
<a name="ln131">	uint32 portState = read32(portRegister);</a>
<a name="ln132"> </a>
<a name="ln133">	if (gInfo-&gt;shared_info-&gt;pch_info == INTEL_PCH_CPT) {</a>
<a name="ln134">		portState &amp;= PORT_TRANS_SEL_MASK;</a>
<a name="ln135">		if (pipe-&gt;Index() == INTEL_PIPE_A)</a>
<a name="ln136">			write32(portRegister, portState | PORT_TRANS_A_SEL_CPT);</a>
<a name="ln137">		else</a>
<a name="ln138">			write32(portRegister, portState | PORT_TRANS_B_SEL_CPT);</a>
<a name="ln139">	} else {</a>
<a name="ln140">		if (pipe-&gt;Index() == INTEL_PIPE_A)</a>
<a name="ln141">			write32(portRegister, portState &amp; ~DISPLAY_MONITOR_PIPE_B);</a>
<a name="ln142">		else</a>
<a name="ln143">			write32(portRegister, portState | DISPLAY_MONITOR_PIPE_B);</a>
<a name="ln144">	}</a>
<a name="ln145"> </a>
<a name="ln146">	fPipe = pipe;</a>
<a name="ln147"> </a>
<a name="ln148">	if (fPipe == NULL)</a>
<a name="ln149">		return B_NO_MEMORY;</a>
<a name="ln150"> </a>
<a name="ln151">	// Disable display pipe until modesetting enables it</a>
<a name="ln152">	if (fPipe-&gt;IsEnabled())</a>
<a name="ln153">		fPipe-&gt;Enable(false);</a>
<a name="ln154"> </a>
<a name="ln155">	read32(portRegister);</a>
<a name="ln156"> </a>
<a name="ln157">	return B_OK;</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">status_t</a>
<a name="ln162">Port::Power(bool enabled)</a>
<a name="ln163">{</a>
<a name="ln164">	fPipe-&gt;Enable(enabled);</a>
<a name="ln165"> </a>
<a name="ln166">	return B_OK;</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169"> </a>
<a name="ln170">status_t</a>
<a name="ln171">Port::GetEDID(edid1_info* edid, bool forceRead)</a>
<a name="ln172">{</a>
<a name="ln173">	CALLED();</a>
<a name="ln174"> </a>
<a name="ln175">	if (fEDIDState == B_NO_INIT || forceRead) {</a>
<a name="ln176">		TRACE(&quot;%s: trying to read EDID\n&quot;, PortName());</a>
<a name="ln177"> </a>
<a name="ln178">		addr_t ddcRegister = _DDCRegister();</a>
<a name="ln179">		if (ddcRegister == 0) {</a>
<a name="ln180">			TRACE(&quot;%s: no DDC register found\n&quot;, PortName());</a>
<a name="ln181">			fEDIDState = B_ERROR;</a>
<a name="ln182">			return fEDIDState;</a>
<a name="ln183">		}</a>
<a name="ln184"> </a>
<a name="ln185">		TRACE(&quot;%s: using ddc @ 0x%&quot; B_PRIxADDR &quot;\n&quot;, PortName(), ddcRegister);</a>
<a name="ln186"> </a>
<a name="ln187">		i2c_bus bus;</a>
<a name="ln188">		bus.cookie = (void*)ddcRegister;</a>
<a name="ln189">		bus.set_signals = &amp;_SetI2CSignals;</a>
<a name="ln190">		bus.get_signals = &amp;_GetI2CSignals;</a>
<a name="ln191">		ddc2_init_timing(&amp;bus);</a>
<a name="ln192"> </a>
<a name="ln193">		fEDIDState = ddc2_read_edid1(&amp;bus, &amp;fEDIDInfo, NULL, NULL);</a>
<a name="ln194"> </a>
<a name="ln195">		if (fEDIDState == B_OK) {</a>
<a name="ln196">			TRACE(&quot;%s: found EDID information!\n&quot;, PortName());</a>
<a name="ln197">			edid_dump(&amp;fEDIDInfo);</a>
<a name="ln198">		}</a>
<a name="ln199">	}</a>
<a name="ln200"> </a>
<a name="ln201">	if (fEDIDState != B_OK) {</a>
<a name="ln202">		TRACE(&quot;%s: no EDID information found.\n&quot;, PortName());</a>
<a name="ln203">		return fEDIDState;</a>
<a name="ln204">	}</a>
<a name="ln205"> </a>
<a name="ln206">	if (edid != NULL)</a>
<a name="ln207">		memcpy(edid, &amp;fEDIDInfo, sizeof(edid1_info));</a>
<a name="ln208"> </a>
<a name="ln209">	return B_OK;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212"> </a>
<a name="ln213">status_t</a>
<a name="ln214">Port::GetPLLLimits(pll_limits&amp; limits)</a>
<a name="ln215">{</a>
<a name="ln216">	return B_ERROR;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">status_t</a>
<a name="ln221">Port::_GetI2CSignals(void* cookie, int* _clock, int* _data)</a>
<a name="ln222">{</a>
<a name="ln223">	addr_t ioRegister = (addr_t)cookie;</a>
<a name="ln224">	uint32 value = read32(ioRegister);</a>
<a name="ln225"> </a>
<a name="ln226">	*_clock = (value &amp; I2C_CLOCK_VALUE_IN) != 0;</a>
<a name="ln227">	*_data = (value &amp; I2C_DATA_VALUE_IN) != 0;</a>
<a name="ln228"> </a>
<a name="ln229">	return B_OK;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">status_t</a>
<a name="ln234">Port::_SetI2CSignals(void* cookie, int clock, int data)</a>
<a name="ln235">{</a>
<a name="ln236">	addr_t ioRegister = (addr_t)cookie;</a>
<a name="ln237">	uint32 value;</a>
<a name="ln238"> </a>
<a name="ln239">	if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_83x)) {</a>
<a name="ln240">		// on these chips, the reserved values are fixed</a>
<a name="ln241">		value = 0;</a>
<a name="ln242">	} else {</a>
<a name="ln243">		// on all others, we have to preserve them manually</a>
<a name="ln244">		value = read32(ioRegister) &amp; I2C_RESERVED;</a>
<a name="ln245">	}</a>
<a name="ln246"> </a>
<a name="ln247">	if (data != 0)</a>
<a name="ln248">		value |= I2C_DATA_DIRECTION_MASK;</a>
<a name="ln249">	else {</a>
<a name="ln250">		value |= I2C_DATA_DIRECTION_MASK | I2C_DATA_DIRECTION_OUT</a>
<a name="ln251">			| I2C_DATA_VALUE_MASK;</a>
<a name="ln252">	}</a>
<a name="ln253"> </a>
<a name="ln254">	if (clock != 0)</a>
<a name="ln255">		value |= I2C_CLOCK_DIRECTION_MASK;</a>
<a name="ln256">	else {</a>
<a name="ln257">		value |= I2C_CLOCK_DIRECTION_MASK | I2C_CLOCK_DIRECTION_OUT</a>
<a name="ln258">			| I2C_CLOCK_VALUE_MASK;</a>
<a name="ln259">	}</a>
<a name="ln260"> </a>
<a name="ln261">	write32(ioRegister, value);</a>
<a name="ln262">	read32(ioRegister);</a>
<a name="ln263">		// make sure the PCI bus has flushed the write</a>
<a name="ln264"> </a>
<a name="ln265">	return B_OK;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">// #pragma mark - Analog Port</a>
<a name="ln270"> </a>
<a name="ln271"> </a>
<a name="ln272">AnalogPort::AnalogPort()</a>
<a name="ln273">	:</a>
<a name="ln274">	Port(INTEL_PORT_A, &quot;Analog&quot;)</a>
<a name="ln275">{</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278"> </a>
<a name="ln279">bool</a>
<a name="ln280">AnalogPort::IsConnected()</a>
<a name="ln281">{</a>
<a name="ln282">	TRACE(&quot;%s: %s PortRegister: 0x%&quot; B_PRIxADDR &quot;\n&quot;, __func__, PortName(),</a>
<a name="ln283">		_PortRegister());</a>
<a name="ln284">	return HasEDID();</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287"> </a>
<a name="ln288">addr_t</a>
<a name="ln289">AnalogPort::_DDCRegister()</a>
<a name="ln290">{</a>
<a name="ln291">	// always fixed</a>
<a name="ln292">	return INTEL_I2C_IO_A;</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">addr_t</a>
<a name="ln297">AnalogPort::_PortRegister()</a>
<a name="ln298">{</a>
<a name="ln299">	// always fixed</a>
<a name="ln300">	return INTEL_ANALOG_PORT;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">status_t</a>
<a name="ln305">AnalogPort::SetDisplayMode(display_mode* target, uint32 colorMode)</a>
<a name="ln306">{</a>
<a name="ln307">	TRACE(&quot;%s: %s %dx%d\n&quot;, __func__, PortName(), target-&gt;virtual_width,</a>
<a name="ln308">		target-&gt;virtual_height);</a>
<a name="ln309"> </a>
<a name="ln310">	if (fPipe == NULL) {</a>
<a name="ln311">		ERROR(&quot;%s: Setting display mode without assigned pipe!\n&quot;, __func__);</a>
<a name="ln312">		return B_ERROR;</a>
<a name="ln313">	}</a>
<a name="ln314"> </a>
<a name="ln315">	// Train FDI if it exists</a>
<a name="ln316">	FDILink* link = fPipe-&gt;FDI();</a>
<a name="ln317">	if (link != NULL)</a>
<a name="ln318">		link-&gt;Train(target);</a>
<a name="ln319"> </a>
<a name="ln320">	pll_divisors divisors;</a>
<a name="ln321">	compute_pll_divisors(target, &amp;divisors, false);</a>
<a name="ln322"> </a>
<a name="ln323">	uint32 extraPLLFlags = 0;</a>
<a name="ln324">	if (gInfo-&gt;shared_info-&gt;device_type.Generation() &gt;= 3)</a>
<a name="ln325">		extraPLLFlags |= DISPLAY_PLL_MODE_NORMAL;</a>
<a name="ln326"> </a>
<a name="ln327">	// Program general pipe config</a>
<a name="ln328">	fPipe-&gt;Configure(target);</a>
<a name="ln329"> </a>
<a name="ln330">	// Program pipe PLL's</a>
<a name="ln331">	fPipe-&gt;ConfigureClocks(divisors, target-&gt;timing.pixel_clock, extraPLLFlags);</a>
<a name="ln332"> </a>
<a name="ln333">	write32(_PortRegister(), (read32(_PortRegister())</a>
<a name="ln334">		&amp; ~(DISPLAY_MONITOR_POLARITY_MASK | DISPLAY_MONITOR_VGA_POLARITY))</a>
<a name="ln335">		| ((target-&gt;timing.flags &amp; B_POSITIVE_HSYNC) != 0</a>
<a name="ln336">			? DISPLAY_MONITOR_POSITIVE_HSYNC : 0)</a>
<a name="ln337">		| ((target-&gt;timing.flags &amp; B_POSITIVE_VSYNC) != 0</a>
<a name="ln338">			? DISPLAY_MONITOR_POSITIVE_VSYNC : 0));</a>
<a name="ln339"> </a>
<a name="ln340">	// Program target display mode</a>
<a name="ln341">	fPipe-&gt;ConfigureTimings(target);</a>
<a name="ln342"> </a>
<a name="ln343">	// Set fCurrentMode to our set display mode</a>
<a name="ln344">	memcpy(&amp;fCurrentMode, target, sizeof(display_mode));</a>
<a name="ln345"> </a>
<a name="ln346">	return B_OK;</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349"> </a>
<a name="ln350">// #pragma mark - LVDS Panel</a>
<a name="ln351"> </a>
<a name="ln352"> </a>
<a name="ln353">LVDSPort::LVDSPort()</a>
<a name="ln354">	:</a>
<a name="ln355">	Port(INTEL_PORT_C, &quot;LVDS&quot;)</a>
<a name="ln356">{</a>
<a name="ln357">	// Always unlock LVDS port as soon as we start messing with it.</a>
<a name="ln358">	uint32 panelControl = INTEL_PANEL_CONTROL;</a>
<a name="ln359">	if (gInfo-&gt;shared_info-&gt;pch_info != INTEL_PCH_NONE) {</a>
<a name="ln360">		// FIXME writing there results in black screen on SandyBridge</a>
<a name="ln361">		return;</a>
<a name="ln362">		// panelControl = PCH_PANEL_CONTROL;</a>
<a name="ln363">	}</a>
<a name="ln364">	write32(panelControl, read32(panelControl) | PANEL_REGISTER_UNLOCK);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368">pipe_index</a>
<a name="ln369">LVDSPort::PipePreference()</a>
<a name="ln370">{</a>
<a name="ln371">	// TODO: Technically INTEL_PIPE_B is only required on &lt; gen 4</a>
<a name="ln372">	// otherwise we can use INTEL_PIPE_ANY, however it seems to break</a>
<a name="ln373">	// modesetting atm. (likely due to a bug on our end)</a>
<a name="ln374">	//if (gInfo-&gt;shared_info-&gt;device_type.Generation() &lt; 4)</a>
<a name="ln375">	//	return INTEL_PIPE_B;</a>
<a name="ln376"> </a>
<a name="ln377">	return INTEL_PIPE_B;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">bool</a>
<a name="ln382">LVDSPort::IsConnected()</a>
<a name="ln383">{</a>
<a name="ln384">	TRACE(&quot;%s: %s PortRegister: 0x%&quot; B_PRIxADDR &quot;\n&quot;, __func__, PortName(),</a>
<a name="ln385">		_PortRegister());</a>
<a name="ln386"> </a>
<a name="ln387">	if (gInfo-&gt;shared_info-&gt;pch_info != INTEL_PCH_NONE) {</a>
<a name="ln388">		uint32 registerValue = read32(_PortRegister());</a>
<a name="ln389">		// there's a detection bit we can use</a>
<a name="ln390">		if ((registerValue &amp; PCH_LVDS_DETECTED) == 0) {</a>
<a name="ln391">			TRACE(&quot;LVDS: Not detected\n&quot;);</a>
<a name="ln392">			return false;</a>
<a name="ln393">		}</a>
<a name="ln394">		// TODO: Skip if eDP support</a>
<a name="ln395">	} else if (gInfo-&gt;shared_info-&gt;device_type.Generation() &lt;= 4) {</a>
<a name="ln396">		// Older generations don't have LVDS detection. If not mobile skip.</a>
<a name="ln397">		if (!gInfo-&gt;shared_info-&gt;device_type.IsMobile()) {</a>
<a name="ln398">			TRACE(&quot;LVDS: Skipping LVDS detection due to gen and not mobile\n&quot;);</a>
<a name="ln399">			return false;</a>
<a name="ln400">		}</a>
<a name="ln401">		// If mobile, try to grab EDID</a>
<a name="ln402">		// Linux seems to look at lid status for LVDS port detection</a>
<a name="ln403">		// If we don't get EDID, we can use vbios native mode or vesa?</a>
<a name="ln404">		if (!HasEDID()) {</a>
<a name="ln405">			#if 0</a>
<a name="ln406">			if (gInfo-&gt;shared_info-&gt;got_vbt) {</a>
<a name="ln407">				// TODO: Fake EDID from vbios native mode?</a>
<a name="ln408">				// I feel like this would be more accurate</a>
<a name="ln409">			} else if...</a>
<a name="ln410">			#endif</a>
<a name="ln411">			if (gInfo-&gt;shared_info-&gt;has_vesa_edid_info) {</a>
<a name="ln412">				TRACE(&quot;LVDS: Using VESA edid info\n&quot;);</a>
<a name="ln413">				memcpy(&amp;fEDIDInfo, &amp;gInfo-&gt;shared_info-&gt;vesa_edid_info,</a>
<a name="ln414">					sizeof(edid1_info));</a>
<a name="ln415">				fEDIDState = B_OK;</a>
<a name="ln416">				// HasEDID now true</a>
<a name="ln417">			} else {</a>
<a name="ln418">				TRACE(&quot;LVDS: Couldn't find any valid EDID!\n&quot;);</a>
<a name="ln419">				return false;</a>
<a name="ln420">			}</a>
<a name="ln421">		}</a>
<a name="ln422">	}</a>
<a name="ln423"> </a>
<a name="ln424">	// Try getting EDID, as the LVDS port doesn't overlap with anything else,</a>
<a name="ln425">	// we don't run the risk of getting someone else's data.</a>
<a name="ln426">	return HasEDID();</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">addr_t</a>
<a name="ln431">LVDSPort::_DDCRegister()</a>
<a name="ln432">{</a>
<a name="ln433">	// always fixed</a>
<a name="ln434">	return INTEL_I2C_IO_C;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">addr_t</a>
<a name="ln439">LVDSPort::_PortRegister()</a>
<a name="ln440">{</a>
<a name="ln441">	// always fixed</a>
<a name="ln442">	return INTEL_DIGITAL_LVDS_PORT;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445"> </a>
<a name="ln446">status_t</a>
<a name="ln447">LVDSPort::SetDisplayMode(display_mode* target, uint32 colorMode)</a>
<a name="ln448">{</a>
<a name="ln449">	CALLED();</a>
<a name="ln450">	if (target == NULL) {</a>
<a name="ln451">		ERROR(&quot;%s: Invalid target mode passed!\n&quot;, __func__);</a>
<a name="ln452">		return B_ERROR;</a>
<a name="ln453">	}</a>
<a name="ln454"> </a>
<a name="ln455">	TRACE(&quot;%s: %s-%d %dx%d\n&quot;, __func__, PortName(), PortIndex(),</a>
<a name="ln456">		target-&gt;virtual_width, target-&gt;virtual_height);</a>
<a name="ln457"> </a>
<a name="ln458">	if (fPipe == NULL) {</a>
<a name="ln459">		ERROR(&quot;%s: Setting display mode without assigned pipe!\n&quot;, __func__);</a>
<a name="ln460">		return B_ERROR;</a>
<a name="ln461">	}</a>
<a name="ln462"> </a>
<a name="ln463">	addr_t panelControl = INTEL_PANEL_CONTROL;</a>
<a name="ln464">	addr_t panelStatus = INTEL_PANEL_STATUS;</a>
<a name="ln465">	if (gInfo-&gt;shared_info-&gt;pch_info != INTEL_PCH_NONE) {</a>
<a name="ln466">		panelControl = PCH_PANEL_CONTROL;</a>
<a name="ln467">		panelStatus = PCH_PANEL_STATUS;</a>
<a name="ln468">	}</a>
<a name="ln469"> </a>
<a name="ln470">	// Power off Panel</a>
<a name="ln471">	write32(panelControl, read32(panelControl) &amp; ~PANEL_CONTROL_POWER_TARGET_ON);</a>
<a name="ln472">	read32(panelControl);</a>
<a name="ln473"> </a>
<a name="ln474">	if (!wait_for_clear(panelStatus, PANEL_STATUS_POWER_ON, 1000))</a>
<a name="ln475">		ERROR(&quot;%s: %s didn't power off within 1000ms!\n&quot;, __func__, PortName());</a>
<a name="ln476"> </a>
<a name="ln477">	// Train FDI if it exists</a>
<a name="ln478">	FDILink* link = fPipe-&gt;FDI();</a>
<a name="ln479">	if (link != NULL)</a>
<a name="ln480">		link-&gt;Train(target);</a>
<a name="ln481"> </a>
<a name="ln482">#if 0</a>
<a name="ln483">	// Disable PanelFitter for now</a>
<a name="ln484">	addr_t panelFitterControl = PCH_PANEL_FITTER_BASE_REGISTER</a>
<a name="ln485">		+ PCH_PANEL_FITTER_CONTROL;</a>
<a name="ln486">	if (fPipe-&gt;Index() == INTEL_PIPE_B)</a>
<a name="ln487">		panelFitterControl += PCH_PANEL_FITTER_PIPE_OFFSET;</a>
<a name="ln488">	write32(panelFitterControl, (read32(panelFitterControl) &amp; ~PANEL_FITTER_ENABLED));</a>
<a name="ln489">	read32(panelFitterControl);</a>
<a name="ln490">#endif</a>
<a name="ln491"> </a>
<a name="ln492">	// For LVDS panels, we actually always set the native mode in hardware</a>
<a name="ln493">	// Then we use the panel fitter to scale the picture to that.</a>
<a name="ln494">	display_mode hardwareTarget;</a>
<a name="ln495">	bool needsScaling = false;</a>
<a name="ln496">		// Try to get the panel preferred screen mode from EDID info</a>
<a name="ln497"> </a>
<a name="ln498">	if (gInfo-&gt;shared_info-&gt;got_vbt) {</a>
<a name="ln499">		// Set vbios hardware panel mode as base</a>
<a name="ln500">		memcpy(&amp;hardwareTarget, &amp;gInfo-&gt;shared_info-&gt;panel_mode,</a>
<a name="ln501">			sizeof(display_mode));</a>
<a name="ln502">		hardwareTarget.space = target-&gt;space;</a>
<a name="ln503"> </a>
<a name="ln504">		if ((hardwareTarget.virtual_width &lt;= target-&gt;virtual_width</a>
<a name="ln505">				&amp;&amp; hardwareTarget.virtual_height &lt;= target-&gt;virtual_height</a>
<a name="ln506">				&amp;&amp; hardwareTarget.space &lt;= target-&gt;space)</a>
<a name="ln507">			|| intel_propose_display_mode(&amp;hardwareTarget, target, target)) {</a>
<a name="ln508">			hardwareTarget = *target;</a>
<a name="ln509">		} else</a>
<a name="ln510">			needsScaling = true;</a>
<a name="ln511"> </a>
<a name="ln512">		TRACE(&quot;%s: hardware mode will actually be %dx%d (%s)\n&quot;, __func__,</a>
<a name="ln513">			hardwareTarget.virtual_width, hardwareTarget.virtual_height,</a>
<a name="ln514">			needsScaling ? &quot;scaled&quot; : &quot;unscaled&quot;);</a>
<a name="ln515">	} else {</a>
<a name="ln516">		// We don't have EDID data, try to set the requested mode directly</a>
<a name="ln517">		hardwareTarget = *target;</a>
<a name="ln518">	}</a>
<a name="ln519"> </a>
<a name="ln520">	pll_divisors divisors;</a>
<a name="ln521">	if (needsScaling)</a>
<a name="ln522">		compute_pll_divisors(&amp;hardwareTarget, &amp;divisors, true);</a>
<a name="ln523">	else</a>
<a name="ln524">		compute_pll_divisors(target, &amp;divisors, true);</a>
<a name="ln525"> </a>
<a name="ln526">	uint32 lvds = read32(_PortRegister())</a>
<a name="ln527">		| LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;</a>
<a name="ln528"> </a>
<a name="ln529">	if (gInfo-&gt;shared_info-&gt;device_type.Generation() == 4) {</a>
<a name="ln530">		// LVDS_A3_POWER_UP == 24bpp</a>
<a name="ln531">		// otherwise, 18bpp</a>
<a name="ln532">		if ((lvds &amp; LVDS_A3_POWER_MASK) != LVDS_A3_POWER_UP)</a>
<a name="ln533">			lvds |= LVDS_18BIT_DITHER;</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	// LVDS on PCH needs set before display enable</a>
<a name="ln537">	if (gInfo-&gt;shared_info-&gt;pch_info == INTEL_PCH_CPT) {</a>
<a name="ln538">		lvds &amp;= PORT_TRANS_SEL_MASK;</a>
<a name="ln539">		if (fPipe-&gt;Index() == INTEL_PIPE_A)</a>
<a name="ln540">			lvds |= PORT_TRANS_A_SEL_CPT;</a>
<a name="ln541">		else</a>
<a name="ln542">			lvds |= PORT_TRANS_B_SEL_CPT;</a>
<a name="ln543">	}</a>
<a name="ln544"> </a>
<a name="ln545">	// Set the B0-B3 data pairs corresponding to whether we're going to</a>
<a name="ln546">	// set the DPLLs for dual-channel mode or not.</a>
<a name="ln547">	if (divisors.p2 == 5 || divisors.p2 == 7) {</a>
<a name="ln548">		TRACE(&quot;LVDS: dual channel\n&quot;);</a>
<a name="ln549">		lvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;</a>
<a name="ln550">	} else {</a>
<a name="ln551">		TRACE(&quot;LVDS: single channel\n&quot;);</a>
<a name="ln552">		lvds &amp;= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);</a>
<a name="ln553">	}</a>
<a name="ln554"> </a>
<a name="ln555">	// LVDS port control moves polarity bits because Intel hates you.</a>
<a name="ln556">	// Set LVDS sync polarity</a>
<a name="ln557">	lvds &amp;= ~(LVDS_HSYNC_POLARITY | LVDS_VSYNC_POLARITY);</a>
<a name="ln558"> </a>
<a name="ln559">	// set on - polarity.</a>
<a name="ln560">	if ((target-&gt;timing.flags &amp; B_POSITIVE_HSYNC) == 0)</a>
<a name="ln561">		lvds |= LVDS_HSYNC_POLARITY;</a>
<a name="ln562">	if ((target-&gt;timing.flags &amp; B_POSITIVE_VSYNC) == 0)</a>
<a name="ln563">		lvds |= LVDS_VSYNC_POLARITY;</a>
<a name="ln564"> </a>
<a name="ln565">	TRACE(&quot;%s: LVDS Write: 0x%&quot; B_PRIx32 &quot;\n&quot;, __func__, lvds);</a>
<a name="ln566">	write32(_PortRegister(), lvds);</a>
<a name="ln567">	read32(_PortRegister());</a>
<a name="ln568"> </a>
<a name="ln569">	uint32 extraPLLFlags = 0;</a>
<a name="ln570"> </a>
<a name="ln571">	// DPLL mode LVDS for i915+</a>
<a name="ln572">	if (gInfo-&gt;shared_info-&gt;device_type.Generation() &gt;= 3)</a>
<a name="ln573">		extraPLLFlags |= DISPLAY_PLL_MODE_LVDS;</a>
<a name="ln574"> </a>
<a name="ln575">	// Program general pipe config</a>
<a name="ln576">	fPipe-&gt;Configure(target);</a>
<a name="ln577"> </a>
<a name="ln578">	// Program pipe PLL's (pixel_clock is *always* the hardware pixel clock)</a>
<a name="ln579">	fPipe-&gt;ConfigureClocks(divisors, hardwareTarget.timing.pixel_clock,</a>
<a name="ln580">		extraPLLFlags);</a>
<a name="ln581"> </a>
<a name="ln582">	// Disable panel fitting, but enable 8 to 6-bit dithering</a>
<a name="ln583">	write32(INTEL_PANEL_FIT_CONTROL, 0x4);</a>
<a name="ln584">		// TODO: do not do this if the connected panel is 24-bit</a>
<a name="ln585">		// (I don't know how to detect that)</a>
<a name="ln586"> </a>
<a name="ln587">	// Power on Panel</a>
<a name="ln588">	write32(panelControl, read32(panelControl) | PANEL_CONTROL_POWER_TARGET_ON);</a>
<a name="ln589">	read32(panelControl);</a>
<a name="ln590"> </a>
<a name="ln591">	if (!wait_for_set(panelStatus, PANEL_STATUS_POWER_ON, 1000))</a>
<a name="ln592">		ERROR(&quot;%s: %s didn't power on within 1000ms!\n&quot;, __func__, PortName());</a>
<a name="ln593"> </a>
<a name="ln594">	// Program target display mode</a>
<a name="ln595">	fPipe-&gt;ConfigureTimings(target);</a>
<a name="ln596"> </a>
<a name="ln597">#if 0</a>
<a name="ln598">	// update timing parameters</a>
<a name="ln599">	if (needsScaling) {</a>
<a name="ln600">		// TODO: Alternatively, it should be possible to use the panel</a>
<a name="ln601">		// fitter and scale the picture.</a>
<a name="ln602"> </a>
<a name="ln603">		// TODO: Perform some sanity check, for example if the target is</a>
<a name="ln604">		// wider than the hardware mode we end up with negative borders and</a>
<a name="ln605">		// broken timings</a>
<a name="ln606">		uint32 borderWidth = hardwareTarget.timing.h_display</a>
<a name="ln607">			- target-&gt;timing.h_display;</a>
<a name="ln608"> </a>
<a name="ln609">		uint32 syncWidth = hardwareTarget.timing.h_sync_end</a>
<a name="ln610">			- hardwareTarget.timing.h_sync_start;</a>
<a name="ln611"> </a>
<a name="ln612">		uint32 syncCenter = target-&gt;timing.h_display</a>
<a name="ln613">			+ (hardwareTarget.timing.h_total</a>
<a name="ln614">			- target-&gt;timing.h_display) / 2;</a>
<a name="ln615"> </a>
<a name="ln616">		write32(INTEL_DISPLAY_B_HTOTAL,</a>
<a name="ln617">			((uint32)(hardwareTarget.timing.h_total - 1) &lt;&lt; 16)</a>
<a name="ln618">			| ((uint32)target-&gt;timing.h_display - 1));</a>
<a name="ln619">		write32(INTEL_DISPLAY_B_HBLANK,</a>
<a name="ln620">			((uint32)(hardwareTarget.timing.h_total - borderWidth / 2 - 1)</a>
<a name="ln621">				&lt;&lt; 16)</a>
<a name="ln622">			| ((uint32)target-&gt;timing.h_display + borderWidth / 2 - 1));</a>
<a name="ln623">		write32(INTEL_DISPLAY_B_HSYNC,</a>
<a name="ln624">			((uint32)(syncCenter + syncWidth / 2 - 1) &lt;&lt; 16)</a>
<a name="ln625">			| ((uint32)syncCenter - syncWidth / 2 - 1));</a>
<a name="ln626"> </a>
<a name="ln627">		uint32 borderHeight = hardwareTarget.timing.v_display</a>
<a name="ln628">			- target-&gt;timing.v_display;</a>
<a name="ln629"> </a>
<a name="ln630">		uint32 syncHeight = hardwareTarget.timing.v_sync_end</a>
<a name="ln631">			- hardwareTarget.timing.v_sync_start;</a>
<a name="ln632"> </a>
<a name="ln633">		syncCenter = target-&gt;timing.v_display</a>
<a name="ln634">			+ (hardwareTarget.timing.v_total</a>
<a name="ln635">			- target-&gt;timing.v_display) / 2;</a>
<a name="ln636"> </a>
<a name="ln637">		write32(INTEL_DISPLAY_B_VTOTAL,</a>
<a name="ln638">			((uint32)(hardwareTarget.timing.v_total - 1) &lt;&lt; 16)</a>
<a name="ln639">			| ((uint32)target-&gt;timing.v_display - 1));</a>
<a name="ln640">		write32(INTEL_DISPLAY_B_VBLANK,</a>
<a name="ln641">			((uint32)(hardwareTarget.timing.v_total - borderHeight / 2 - 1)</a>
<a name="ln642">				&lt;&lt; 16)</a>
<a name="ln643">			| ((uint32)target-&gt;timing.v_display</a>
<a name="ln644">				+ borderHeight / 2 - 1));</a>
<a name="ln645">		write32(INTEL_DISPLAY_B_VSYNC,</a>
<a name="ln646">			((uint32)(syncCenter + syncHeight / 2 - 1) &lt;&lt; 16)</a>
<a name="ln647">			| ((uint32)syncCenter - syncHeight / 2 - 1));</a>
<a name="ln648"> </a>
<a name="ln649">		// This is useful for debugging: it sets the border to red, so you</a>
<a name="ln650">		// can see what is border and what is porch (black area around the</a>
<a name="ln651">		// sync)</a>
<a name="ln652">		// write32(0x61020, 0x00FF0000);</a>
<a name="ln653">	} else {</a>
<a name="ln654">		write32(INTEL_DISPLAY_B_HTOTAL,</a>
<a name="ln655">			((uint32)(target-&gt;timing.h_total - 1) &lt;&lt; 16)</a>
<a name="ln656">			| ((uint32)target-&gt;timing.h_display - 1));</a>
<a name="ln657">		write32(INTEL_DISPLAY_B_HBLANK,</a>
<a name="ln658">			((uint32)(target-&gt;timing.h_total - 1) &lt;&lt; 16)</a>
<a name="ln659">			| ((uint32)target-&gt;timing.h_display - 1));</a>
<a name="ln660">		write32(INTEL_DISPLAY_B_HSYNC,</a>
<a name="ln661">			((uint32)(target-&gt;timing.h_sync_end - 1) &lt;&lt; 16)</a>
<a name="ln662">			| ((uint32)target-&gt;timing.h_sync_start - 1));</a>
<a name="ln663"> </a>
<a name="ln664">		write32(INTEL_DISPLAY_B_VTOTAL,</a>
<a name="ln665">			((uint32)(target-&gt;timing.v_total - 1) &lt;&lt; 16)</a>
<a name="ln666">			| ((uint32)target-&gt;timing.v_display - 1));</a>
<a name="ln667">		write32(INTEL_DISPLAY_B_VBLANK,</a>
<a name="ln668">			((uint32)(target-&gt;timing.v_total - 1) &lt;&lt; 16)</a>
<a name="ln669">			| ((uint32)target-&gt;timing.v_display - 1));</a>
<a name="ln670">		write32(INTEL_DISPLAY_B_VSYNC, (</a>
<a name="ln671">			(uint32)(target-&gt;timing.v_sync_end - 1) &lt;&lt; 16)</a>
<a name="ln672">			| ((uint32)target-&gt;timing.v_sync_start - 1));</a>
<a name="ln673">	}</a>
<a name="ln674">#endif</a>
<a name="ln675"> </a>
<a name="ln676">	// Set fCurrentMode to our set display mode</a>
<a name="ln677">	memcpy(&amp;fCurrentMode, target, sizeof(display_mode));</a>
<a name="ln678"> </a>
<a name="ln679">	return B_OK;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682"> </a>
<a name="ln683">// #pragma mark - DVI/SDVO/generic</a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">DigitalPort::DigitalPort(port_index index, const char* baseName)</a>
<a name="ln687">	:</a>
<a name="ln688">	Port(index, baseName)</a>
<a name="ln689">{</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">bool</a>
<a name="ln694">DigitalPort::IsConnected()</a>
<a name="ln695">{</a>
<a name="ln696">	TRACE(&quot;%s: %s PortRegister: 0x%&quot; B_PRIxADDR &quot;\n&quot;, __func__, PortName(),</a>
<a name="ln697">		_PortRegister());</a>
<a name="ln698"> </a>
<a name="ln699">	// As this port overlaps with pretty much everything, this must be called</a>
<a name="ln700">	// after having ruled out all other port types.</a>
<a name="ln701">	return HasEDID();</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">addr_t</a>
<a name="ln706">DigitalPort::_DDCRegister()</a>
<a name="ln707">{</a>
<a name="ln708">	//TODO: IS BROXTON, B = B, C = C, D = NIL</a>
<a name="ln709">	switch (PortIndex()) {</a>
<a name="ln710">		case INTEL_PORT_B:</a>
<a name="ln711">			return INTEL_I2C_IO_E;</a>
<a name="ln712">		case INTEL_PORT_C:</a>
<a name="ln713">			return INTEL_I2C_IO_D;</a>
<a name="ln714">		case INTEL_PORT_D:</a>
<a name="ln715">			return INTEL_I2C_IO_F;</a>
<a name="ln716">		default:</a>
<a name="ln717">			return 0;</a>
<a name="ln718">	}</a>
<a name="ln719"> </a>
<a name="ln720">	return 0;</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723"> </a>
<a name="ln724">addr_t</a>
<a name="ln725">DigitalPort::_PortRegister()</a>
<a name="ln726">{</a>
<a name="ln727">	switch (PortIndex()) {</a>
<a name="ln728">		case INTEL_PORT_A:</a>
<a name="ln729">			return INTEL_DIGITAL_PORT_A;</a>
<a name="ln730">		case INTEL_PORT_B:</a>
<a name="ln731">			return INTEL_DIGITAL_PORT_B;</a>
<a name="ln732">		case INTEL_PORT_C:</a>
<a name="ln733">			return INTEL_DIGITAL_PORT_C;</a>
<a name="ln734">		default:</a>
<a name="ln735">			return 0;</a>
<a name="ln736">	}</a>
<a name="ln737">	return 0;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740"> </a>
<a name="ln741">status_t</a>
<a name="ln742">DigitalPort::SetDisplayMode(display_mode* target, uint32 colorMode)</a>
<a name="ln743">{</a>
<a name="ln744">	TRACE(&quot;%s: %s %dx%d\n&quot;, __func__, PortName(), target-&gt;virtual_width,</a>
<a name="ln745">		target-&gt;virtual_height);</a>
<a name="ln746"> </a>
<a name="ln747">	if (fPipe == NULL) {</a>
<a name="ln748">		ERROR(&quot;%s: Setting display mode without assigned pipe!\n&quot;, __func__);</a>
<a name="ln749">		return B_ERROR;</a>
<a name="ln750">	}</a>
<a name="ln751"> </a>
<a name="ln752">	// Train FDI if it exists</a>
<a name="ln753">	FDILink* link = fPipe-&gt;FDI();</a>
<a name="ln754">	if (link != NULL)</a>
<a name="ln755">		link-&gt;Train(target);</a>
<a name="ln756"> </a>
<a name="ln757">	pll_divisors divisors;</a>
<a name="ln758">	compute_pll_divisors(target, &amp;divisors, false);</a>
<a name="ln759"> </a>
<a name="ln760">	uint32 extraPLLFlags = 0;</a>
<a name="ln761">	if (gInfo-&gt;shared_info-&gt;device_type.Generation() &gt;= 3)</a>
<a name="ln762">		extraPLLFlags |= DISPLAY_PLL_MODE_NORMAL;</a>
<a name="ln763"> </a>
<a name="ln764">	// Program general pipe config</a>
<a name="ln765">	fPipe-&gt;Configure(target);</a>
<a name="ln766"> </a>
<a name="ln767">	// Program pipe PLL's</a>
<a name="ln768">	fPipe-&gt;ConfigureClocks(divisors, target-&gt;timing.pixel_clock, extraPLLFlags);</a>
<a name="ln769"> </a>
<a name="ln770">	// Program target display mode</a>
<a name="ln771">	fPipe-&gt;ConfigureTimings(target);</a>
<a name="ln772"> </a>
<a name="ln773">	// Set fCurrentMode to our set display mode</a>
<a name="ln774">	memcpy(&amp;fCurrentMode, target, sizeof(display_mode));</a>
<a name="ln775"> </a>
<a name="ln776">	return B_OK;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779"> </a>
<a name="ln780">// #pragma mark - LVDS Panel</a>
<a name="ln781">// #pragma mark - HDMI</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784">HDMIPort::HDMIPort(port_index index)</a>
<a name="ln785">	:</a>
<a name="ln786">	DigitalPort(index, &quot;HDMI&quot;)</a>
<a name="ln787">{</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790"> </a>
<a name="ln791">bool</a>
<a name="ln792">HDMIPort::IsConnected()</a>
<a name="ln793">{</a>
<a name="ln794">	if (!gInfo-&gt;shared_info-&gt;device_type.SupportsHDMI())</a>
<a name="ln795">		return false;</a>
<a name="ln796"> </a>
<a name="ln797">	addr_t portRegister = _PortRegister();</a>
<a name="ln798">	TRACE(&quot;%s: %s PortRegister: 0x%&quot; B_PRIxADDR &quot;\n&quot;, __func__, PortName(),</a>
<a name="ln799">		portRegister);</a>
<a name="ln800"> </a>
<a name="ln801">	if (portRegister == 0)</a>
<a name="ln802">		return false;</a>
<a name="ln803"> </a>
<a name="ln804">	bool hasPCH = (gInfo-&gt;shared_info-&gt;pch_info != INTEL_PCH_NONE);</a>
<a name="ln805">	if (!hasPCH &amp;&amp; PortIndex() == INTEL_PORT_C) {</a>
<a name="ln806">		// there's no detection bit on this port</a>
<a name="ln807">	} else if ((read32(portRegister) &amp; DISPLAY_MONITOR_PORT_DETECTED) == 0)</a>
<a name="ln808">		return false;</a>
<a name="ln809"> </a>
<a name="ln810">	return HasEDID();</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">addr_t</a>
<a name="ln815">HDMIPort::_PortRegister()</a>
<a name="ln816">{</a>
<a name="ln817">	// on PCH there's an additional port sandwiched in</a>
<a name="ln818">	bool hasPCH = (gInfo-&gt;shared_info-&gt;pch_info != INTEL_PCH_NONE);</a>
<a name="ln819">	bool fourthGen = gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_VLV);</a>
<a name="ln820"> </a>
<a name="ln821">	switch (PortIndex()) {</a>
<a name="ln822">		case INTEL_PORT_B:</a>
<a name="ln823">			if (fourthGen)</a>
<a name="ln824">				return GEN4_HDMI_PORT_B;</a>
<a name="ln825">			return hasPCH ? PCH_HDMI_PORT_B : INTEL_HDMI_PORT_B;</a>
<a name="ln826">		case INTEL_PORT_C:</a>
<a name="ln827">			if (fourthGen)</a>
<a name="ln828">				return GEN4_HDMI_PORT_C;</a>
<a name="ln829">			return hasPCH ? PCH_HDMI_PORT_C : INTEL_HDMI_PORT_C;</a>
<a name="ln830">		case INTEL_PORT_D:</a>
<a name="ln831">			if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_CHV))</a>
<a name="ln832">				return CHV_HDMI_PORT_D;</a>
<a name="ln833">			return hasPCH ? PCH_HDMI_PORT_D : 0;</a>
<a name="ln834">		default:</a>
<a name="ln835">			return 0;</a>
<a name="ln836">		}</a>
<a name="ln837"> </a>
<a name="ln838">	return 0;</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841"> </a>
<a name="ln842">// #pragma mark - DisplayPort</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">DisplayPort::DisplayPort(port_index index, const char* baseName)</a>
<a name="ln846">	:</a>
<a name="ln847">	Port(index, baseName)</a>
<a name="ln848">{</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851"> </a>
<a name="ln852">bool</a>
<a name="ln853">DisplayPort::IsConnected()</a>
<a name="ln854">{</a>
<a name="ln855">	addr_t portRegister = _PortRegister();</a>
<a name="ln856"> </a>
<a name="ln857">	TRACE(&quot;%s: %s PortRegister: 0x%&quot; B_PRIxADDR &quot;\n&quot;, __func__, PortName(),</a>
<a name="ln858">		portRegister);</a>
<a name="ln859"> </a>
<a name="ln860">	if (portRegister == 0)</a>
<a name="ln861">		return false;</a>
<a name="ln862"> </a>
<a name="ln863">	if ((read32(portRegister) &amp; DISPLAY_MONITOR_PORT_DETECTED) == 0) {</a>
<a name="ln864">		TRACE(&quot;%s: %s link not detected\n&quot;, __func__, PortName());</a>
<a name="ln865">		return false;</a>
<a name="ln866">	}</a>
<a name="ln867"> </a>
<a name="ln868">	return HasEDID();</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871"> </a>
<a name="ln872">addr_t</a>
<a name="ln873">DisplayPort::_DDCRegister()</a>
<a name="ln874">{</a>
<a name="ln875">	// TODO: Do VLV + CHV use the VLV_DP_AUX_CTL_B + VLV_DP_AUX_CTL_C?</a>
<a name="ln876">	switch (PortIndex()) {</a>
<a name="ln877">		case INTEL_PORT_A:</a>
<a name="ln878">			return INTEL_DP_AUX_CTL_A;</a>
<a name="ln879">		case INTEL_PORT_B:</a>
<a name="ln880">			if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_VLV))</a>
<a name="ln881">				return VLV_DP_AUX_CTL_B;</a>
<a name="ln882">			return INTEL_DP_AUX_CTL_B;</a>
<a name="ln883">		case INTEL_PORT_C:</a>
<a name="ln884">			if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_VLV))</a>
<a name="ln885">				return VLV_DP_AUX_CTL_C;</a>
<a name="ln886">			return INTEL_DP_AUX_CTL_C;</a>
<a name="ln887">		case INTEL_PORT_D:</a>
<a name="ln888">			if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_CHV))</a>
<a name="ln889">				return CHV_DP_AUX_CTL_D;</a>
<a name="ln890">			else if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_VLV))</a>
<a name="ln891">				return 0;</a>
<a name="ln892">			return INTEL_DP_AUX_CTL_D;</a>
<a name="ln893">		default:</a>
<a name="ln894">			return 0;</a>
<a name="ln895">	}</a>
<a name="ln896"> </a>
<a name="ln897">	return 0;</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900"> </a>
<a name="ln901">addr_t</a>
<a name="ln902">DisplayPort::_PortRegister()</a>
<a name="ln903">{</a>
<a name="ln904">	// There are 6000 lines of intel linux code probing DP registers</a>
<a name="ln905">	// to properly detect DP vs eDP to then in-turn properly figure out</a>
<a name="ln906">	// what is DP and what is HDMI. It only takes 3 lines to</a>
<a name="ln907">	// ignore DisplayPort on ValleyView / CherryView</a>
<a name="ln908"> </a>
<a name="ln909">	if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_VLV)</a>
<a name="ln910">		|| gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_CHV)) {</a>
<a name="ln911">		ERROR(&quot;TODO: DisplayPort on ValleyView / CherryView&quot;);</a>
<a name="ln912">		return 0;</a>
<a name="ln913">	}</a>
<a name="ln914"> </a>
<a name="ln915">	// Intel, are humans even involved anymore?</a>
<a name="ln916">	// This is a lot more complex than this code makes it look. (see defines)</a>
<a name="ln917">	// INTEL_DISPLAY_PORT_X moves around a lot based on PCH</a>
<a name="ln918">	// except on ValleyView and CherryView.</a>
<a name="ln919">	switch (PortIndex()) {</a>
<a name="ln920">		case INTEL_PORT_A:</a>
<a name="ln921">			return INTEL_DISPLAY_PORT_A;</a>
<a name="ln922">		case INTEL_PORT_B:</a>
<a name="ln923">			if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_VLV))</a>
<a name="ln924">				return VLV_DISPLAY_PORT_B;</a>
<a name="ln925">			return INTEL_DISPLAY_PORT_B;</a>
<a name="ln926">		case INTEL_PORT_C:</a>
<a name="ln927">			if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_VLV))</a>
<a name="ln928">				return VLV_DISPLAY_PORT_C;</a>
<a name="ln929">			return INTEL_DISPLAY_PORT_C;</a>
<a name="ln930">		case INTEL_PORT_D:</a>
<a name="ln931">			if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_CHV))</a>
<a name="ln932">				return CHV_DISPLAY_PORT_D;</a>
<a name="ln933">			else if (gInfo-&gt;shared_info-&gt;device_type.InGroup(INTEL_GROUP_VLV))</a>
<a name="ln934">				return 0;</a>
<a name="ln935">			return INTEL_DISPLAY_PORT_D;</a>
<a name="ln936">		default:</a>
<a name="ln937">			return 0;</a>
<a name="ln938">	}</a>
<a name="ln939"> </a>
<a name="ln940">	return 0;</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943"> </a>
<a name="ln944">status_t</a>
<a name="ln945">DisplayPort::SetDisplayMode(display_mode* target, uint32 colorMode)</a>
<a name="ln946">{</a>
<a name="ln947">	TRACE(&quot;%s: %s %dx%d\n&quot;, __func__, PortName(), target-&gt;virtual_width,</a>
<a name="ln948">		target-&gt;virtual_height);</a>
<a name="ln949"> </a>
<a name="ln950">	ERROR(&quot;TODO: DisplayPort\n&quot;);</a>
<a name="ln951">	return B_ERROR;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954"> </a>
<a name="ln955">// #pragma mark - Embedded DisplayPort</a>
<a name="ln956"> </a>
<a name="ln957"> </a>
<a name="ln958">EmbeddedDisplayPort::EmbeddedDisplayPort()</a>
<a name="ln959">	:</a>
<a name="ln960">	DisplayPort(INTEL_PORT_A, &quot;Embedded DisplayPort&quot;)</a>
<a name="ln961">{</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964"> </a>
<a name="ln965">bool</a>
<a name="ln966">EmbeddedDisplayPort::IsConnected()</a>
<a name="ln967">{</a>
<a name="ln968">	addr_t portRegister = _PortRegister();</a>
<a name="ln969"> </a>
<a name="ln970">	TRACE(&quot;%s: %s PortRegister: 0x%&quot; B_PRIxADDR &quot;\n&quot;, __func__, PortName(),</a>
<a name="ln971">		portRegister);</a>
<a name="ln972"> </a>
<a name="ln973">	if (!gInfo-&gt;shared_info-&gt;device_type.IsMobile()) {</a>
<a name="ln974">		TRACE(&quot;%s: skipping eDP on non-mobile GPU\n&quot;, __func__);</a>
<a name="ln975">		return false;</a>
<a name="ln976">	}</a>
<a name="ln977"> </a>
<a name="ln978">	if ((read32(portRegister) &amp; DISPLAY_MONITOR_PORT_DETECTED) == 0) {</a>
<a name="ln979">		TRACE(&quot;%s: %s link not detected\n&quot;, __func__, PortName());</a>
<a name="ln980">		return false;</a>
<a name="ln981">	}</a>
<a name="ln982"> </a>
<a name="ln983">	HasEDID();</a>
<a name="ln984"> </a>
<a name="ln985">	// If eDP has EDID, awesome. We use it.</a>
<a name="ln986">	// No EDID? The modesetting code falls back to VBIOS panel_mode</a>
<a name="ln987">	return true;</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990"> </a>
<a name="ln991">// #pragma mark - Digital Display Port</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">DigitalDisplayInterface::DigitalDisplayInterface(port_index index,</a>
<a name="ln995">		const char* baseName)</a>
<a name="ln996">	:</a>
<a name="ln997">	Port(index, baseName)</a>
<a name="ln998">{</a>
<a name="ln999">	// As of Haswell, Intel decided to change eDP ports to a &quot;DDI&quot; bus...</a>
<a name="ln1000">	// on a dare because the hardware engineers were drunk one night.</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003"> </a>
<a name="ln1004">addr_t</a>
<a name="ln1005">DigitalDisplayInterface::_PortRegister()</a>
<a name="ln1006">{</a>
<a name="ln1007">	// TODO: Linux does a DDI_BUF_CTL(INTEL_PORT_A) which is cleaner</a>
<a name="ln1008">	// (but we have to ensure the offsets + region base is correct)</a>
<a name="ln1009">	switch (PortIndex()) {</a>
<a name="ln1010">		case INTEL_PORT_A:</a>
<a name="ln1011">			return DDI_BUF_CTL_A;</a>
<a name="ln1012">		case INTEL_PORT_B:</a>
<a name="ln1013">			return DDI_BUF_CTL_B;</a>
<a name="ln1014">		case INTEL_PORT_C:</a>
<a name="ln1015">			return DDI_BUF_CTL_C;</a>
<a name="ln1016">		case INTEL_PORT_D:</a>
<a name="ln1017">			return DDI_BUF_CTL_D;</a>
<a name="ln1018">		case INTEL_PORT_E:</a>
<a name="ln1019">			return DDI_BUF_CTL_E;</a>
<a name="ln1020">		default:</a>
<a name="ln1021">			return 0;</a>
<a name="ln1022">	}</a>
<a name="ln1023">	return 0;</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026"> </a>
<a name="ln1027">addr_t</a>
<a name="ln1028">DigitalDisplayInterface::_DDCRegister()</a>
<a name="ln1029">{</a>
<a name="ln1030">	// TODO: No idea, does DDI have DDC?</a>
<a name="ln1031">	return 0;</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034"> </a>
<a name="ln1035">status_t</a>
<a name="ln1036">DigitalDisplayInterface::Power(bool enabled)</a>
<a name="ln1037">{</a>
<a name="ln1038">	TRACE(&quot;%s: %s DDI enabled: %s\n&quot;, __func__, PortName(),</a>
<a name="ln1039">		enabled ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln1040"> </a>
<a name="ln1041">	fPipe-&gt;Enable(enabled);</a>
<a name="ln1042"> </a>
<a name="ln1043">	addr_t portRegister = _PortRegister();</a>
<a name="ln1044">	uint32 state = read32(portRegister);</a>
<a name="ln1045">	write32(portRegister,</a>
<a name="ln1046">		enabled ? (state | DDI_BUF_CTL_ENABLE) : (state &amp; ~DDI_BUF_CTL_ENABLE));</a>
<a name="ln1047">	read32(portRegister);</a>
<a name="ln1048"> </a>
<a name="ln1049">	return B_OK;</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052"> </a>
<a name="ln1053">bool</a>
<a name="ln1054">DigitalDisplayInterface::IsConnected()</a>
<a name="ln1055">{</a>
<a name="ln1056">	addr_t portRegister = _PortRegister();</a>
<a name="ln1057"> </a>
<a name="ln1058">	TRACE(&quot;%s: %s PortRegister: 0x%&quot; B_PRIxADDR &quot;\n&quot;, __func__, PortName(),</a>
<a name="ln1059">		portRegister);</a>
<a name="ln1060"> </a>
<a name="ln1061">	if (portRegister == 0)</a>
<a name="ln1062">		return false;</a>
<a name="ln1063"> </a>
<a name="ln1064">	if ((read32(portRegister) &amp; DDI_INIT_DISPLAY_DETECTED) == 0) {</a>
<a name="ln1065">		TRACE(&quot;%s: %s link not detected\n&quot;, __func__, PortName());</a>
<a name="ln1066">		return false;</a>
<a name="ln1067">	}</a>
<a name="ln1068"> </a>
<a name="ln1069">	// Probe a little port info.</a>
<a name="ln1070">	if ((read32(DDI_BUF_CTL_A) &amp; DDI_A_4_LANES) != 0) {</a>
<a name="ln1071">		switch (PortIndex()) {</a>
<a name="ln1072">			case INTEL_PORT_A:</a>
<a name="ln1073">				fMaxLanes = 4;</a>
<a name="ln1074">				break;</a>
<a name="ln1075">			case INTEL_PORT_E:</a>
<a name="ln1076">				fMaxLanes = 0;</a>
<a name="ln1077">				break;</a>
<a name="ln1078">			default:</a>
<a name="ln1079">				fMaxLanes = 4;</a>
<a name="ln1080">				break;</a>
<a name="ln1081">		}</a>
<a name="ln1082">	} else {</a>
<a name="ln1083">		switch (PortIndex()) {</a>
<a name="ln1084">			case INTEL_PORT_A:</a>
<a name="ln1085">				fMaxLanes = 2;</a>
<a name="ln1086">				break;</a>
<a name="ln1087">			case INTEL_PORT_E:</a>
<a name="ln1088">				fMaxLanes = 2;</a>
<a name="ln1089">				break;</a>
<a name="ln1090">			default:</a>
<a name="ln1091">				fMaxLanes = 4;</a>
<a name="ln1092">				break;</a>
<a name="ln1093">		}</a>
<a name="ln1094">	}</a>
<a name="ln1095"> </a>
<a name="ln1096">	TRACE(&quot;%s: %s Maximum Lanes: %&quot; B_PRId8 &quot;\n&quot;, __func__,</a>
<a name="ln1097">		PortName(), fMaxLanes);</a>
<a name="ln1098"> </a>
<a name="ln1099">	HasEDID();</a>
<a name="ln1100"> </a>
<a name="ln1101">	return true;</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104"> </a>
<a name="ln1105">status_t</a>
<a name="ln1106">DigitalDisplayInterface::SetDisplayMode(display_mode* target, uint32 colorMode)</a>
<a name="ln1107">{</a>
<a name="ln1108">	TRACE(&quot;%s: %s %dx%d\n&quot;, __func__, PortName(), target-&gt;virtual_width,</a>
<a name="ln1109">		target-&gt;virtual_height);</a>
<a name="ln1110"> </a>
<a name="ln1111">	if (fPipe == NULL) {</a>
<a name="ln1112">		ERROR(&quot;%s: Setting display mode without assigned pipe!\n&quot;, __func__);</a>
<a name="ln1113">		return B_ERROR;</a>
<a name="ln1114">	}</a>
<a name="ln1115"> </a>
<a name="ln1116">	// Train FDI if it exists</a>
<a name="ln1117">	FDILink* link = fPipe-&gt;FDI();</a>
<a name="ln1118">	if (link != NULL)</a>
<a name="ln1119">		link-&gt;Train(target);</a>
<a name="ln1120"> </a>
<a name="ln1121">	pll_divisors divisors;</a>
<a name="ln1122">	compute_pll_divisors(target, &amp;divisors, false);</a>
<a name="ln1123"> </a>
<a name="ln1124">	uint32 extraPLLFlags = 0;</a>
<a name="ln1125">	if (gInfo-&gt;shared_info-&gt;device_type.Generation() &gt;= 3)</a>
<a name="ln1126">		extraPLLFlags |= DISPLAY_PLL_MODE_NORMAL;</a>
<a name="ln1127"> </a>
<a name="ln1128">	// Program general pipe config</a>
<a name="ln1129">	fPipe-&gt;Configure(target);</a>
<a name="ln1130"> </a>
<a name="ln1131">	// Program pipe PLL's</a>
<a name="ln1132">	fPipe-&gt;ConfigureClocks(divisors, target-&gt;timing.pixel_clock, extraPLLFlags);</a>
<a name="ln1133"> </a>
<a name="ln1134">	// Program target display mode</a>
<a name="ln1135">	fPipe-&gt;ConfigureTimings(target);</a>
<a name="ln1136"> </a>
<a name="ln1137">	// Set fCurrentMode to our set display mode</a>
<a name="ln1138">	memcpy(&amp;fCurrentMode, target, sizeof(display_mode));</a>
<a name="ln1139"> </a>
<a name="ln1140">	return B_OK;</a>
<a name="ln1141">}</a>

</code></pre>
<div class="balloon" rel="994"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fMaxLanes.</p></div>
<div class="balloon" rel="68"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fCurrentMode, fEDIDInfo.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
