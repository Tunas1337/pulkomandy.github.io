
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DatabaseLocation.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2014 Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Tyler Dauwalder</a>
<a name="ln7"> *		Rene Gollent, rene@gollent.com</a>
<a name="ln8"> *		Ingo Weinhold, ingo_weinhold@gmx.de</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;mime/DatabaseLocation.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;stdlib.h&gt;</a>
<a name="ln15">#include &lt;syslog.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;new&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;Bitmap.h&gt;</a>
<a name="ln20">#include &lt;DataIO.h&gt;</a>
<a name="ln21">#include &lt;Directory.h&gt;</a>
<a name="ln22">#include &lt;File.h&gt;</a>
<a name="ln23">#include &lt;fs_attr.h&gt;</a>
<a name="ln24">#include &lt;IconUtils.h&gt;</a>
<a name="ln25">#include &lt;Message.h&gt;</a>
<a name="ln26">#include &lt;Node.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln29">#include &lt;mime/database_support.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">namespace BPrivate {</a>
<a name="ln33">namespace Storage {</a>
<a name="ln34">namespace Mime {</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">DatabaseLocation::DatabaseLocation()</a>
<a name="ln38">	:</a>
<a name="ln39">	fDirectories()</a>
<a name="ln40">{</a>
<a name="ln41">}</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">DatabaseLocation::~DatabaseLocation()</a>
<a name="ln45">{</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">bool</a>
<a name="ln50">DatabaseLocation::AddDirectory(const BString&amp; directory)</a>
<a name="ln51">{</a>
<a name="ln52">	return !directory.IsEmpty() &amp;&amp; fDirectories.Add(directory);</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">/*!	Opens a BNode on the given type, failing if the type has no</a>
<a name="ln57">	corresponding file in the database.</a>
<a name="ln58"> </a>
<a name="ln59">	\param type The MIME type to open.</a>
<a name="ln60">	\param _node Node opened on the given MIME type.</a>
<a name="ln61">*/</a>
<a name="ln62">status_t</a>
<a name="ln63">DatabaseLocation::OpenType(const char* type, BNode&amp; _node) const</a>
<a name="ln64">{</a>
<a name="ln65">	if (type == NULL)</a>
<a name="ln66">		return B_BAD_VALUE;</a>
<a name="ln67"> </a>
<a name="ln68">	int32 index;</a>
<a name="ln69">	return _OpenType(type, _node, index);</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">/*!	Opens a BNode on the given type, creating a node of the</a>
<a name="ln74">	appropriate flavor if requested (and necessary).</a>
<a name="ln75"> </a>
<a name="ln76">	All MIME types are converted to lowercase for use in the filesystem.</a>
<a name="ln77"> </a>
<a name="ln78">	\param type The MIME type to open.</a>
<a name="ln79">	\param _node Node opened on the given MIME type.</a>
<a name="ln80">	\param _didCreate If not \c NULL, the variable the pointer refers to is</a>
<a name="ln81">	       set to \c true, if the node has been newly created, to \c false</a>
<a name="ln82">	       otherwise.</a>
<a name="ln83"> </a>
<a name="ln84">	\return A status code.</a>
<a name="ln85">*/</a>
<a name="ln86">status_t</a>
<a name="ln87">DatabaseLocation::OpenWritableType(const char* type, BNode&amp; _node, bool create,</a>
<a name="ln88">	bool* _didCreate) const</a>
<a name="ln89">{</a>
<a name="ln90">	if (_didCreate)</a>
<a name="ln91">		*_didCreate = false;</a>
<a name="ln92"> </a>
<a name="ln93">	// See, if the type already exists.</a>
<a name="ln94">	int32 index;</a>
<a name="ln95">	status_t result = _OpenType(type, _node, index);</a>
<a name="ln96">	if (result == B_OK) {</a>
<a name="ln97">		if (index == 0)</a>
<a name="ln98">			return B_OK;</a>
<a name="ln99">		else if (!create)</a>
<a name="ln100">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln101"> </a>
<a name="ln102">		// The caller wants a editable node, but the node found is not in the</a>
<a name="ln103">		// user's settings directory. Copy the node.</a>
<a name="ln104">		BNode nodeToClone(_node);</a>
<a name="ln105">		if (nodeToClone.InitCheck() != B_OK)</a>
<a name="ln106">			return nodeToClone.InitCheck();</a>
<a name="ln107"> </a>
<a name="ln108">		result = _CopyTypeNode(nodeToClone, type, _node);</a>
<a name="ln109">		if (result != B_OK) {</a>
<a name="ln110">			_node.Unset();</a>
<a name="ln111">			return result;</a>
<a name="ln112">		}</a>
<a name="ln113"> </a>
<a name="ln114">		if (_didCreate != NULL)</a>
<a name="ln115">			*_didCreate = true;</a>
<a name="ln116"> </a>
<a name="ln117">		return result;</a>
<a name="ln118">	} else if (!create)</a>
<a name="ln119">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln120"> </a>
<a name="ln121">	// type doesn't exist yet -- create the respective node</a>
<a name="ln122">	result = _CreateTypeNode(type, _node);</a>
<a name="ln123">	if (result != B_OK)</a>
<a name="ln124">		return result;</a>
<a name="ln125"> </a>
<a name="ln126">	// write the type attribute</a>
<a name="ln127">	size_t toWrite = strlen(type) + 1;</a>
<a name="ln128">	ssize_t bytesWritten = _node.WriteAttr(kTypeAttr, B_STRING_TYPE, 0, type,</a>
<a name="ln129">		toWrite);</a>
<a name="ln130">	if (bytesWritten &lt; 0)</a>
<a name="ln131">		result = bytesWritten;</a>
<a name="ln132">	else if ((size_t)bytesWritten != toWrite)</a>
<a name="ln133">		result = B_FILE_ERROR;</a>
<a name="ln134"> </a>
<a name="ln135">	if (result != B_OK) {</a>
<a name="ln136">		_node.Unset();</a>
<a name="ln137">		return result;</a>
<a name="ln138">	}</a>
<a name="ln139"> </a>
<a name="ln140">	if (_didCreate != NULL)</a>
<a name="ln141">		*_didCreate = true;</a>
<a name="ln142">	return B_OK;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145"> </a>
<a name="ln146">/*! Reads up to \c length bytes of the given data from the given attribute</a>
<a name="ln147">	for the given MIME type.</a>
<a name="ln148"> </a>
<a name="ln149">	If no entry for the given type exists in the database, the function fails,</a>
<a name="ln150">	and the contents of \c data are undefined.</a>
<a name="ln151"> </a>
<a name="ln152">	\param type The MIME type.</a>
<a name="ln153">	\param attribute The attribute name.</a>
<a name="ln154">	\param data Pointer to a memory buffer into which the data should be copied.</a>
<a name="ln155">	\param length The maximum number of bytes to read.</a>
<a name="ln156">	\param datatype The expected data type.</a>
<a name="ln157"> </a>
<a name="ln158">	\return If successful, the number of bytes read is returned, otherwise, an</a>
<a name="ln159">	        error code is returned.</a>
<a name="ln160">*/</a>
<a name="ln161">ssize_t</a>
<a name="ln162">DatabaseLocation::ReadAttribute(const char* type, const char* attribute,</a>
<a name="ln163">	void* data, size_t length, type_code datatype) const</a>
<a name="ln164">{</a>
<a name="ln165">	if (type == NULL || attribute == NULL || data == NULL)</a>
<a name="ln166">		return B_BAD_VALUE;</a>
<a name="ln167"> </a>
<a name="ln168">	BNode node;</a>
<a name="ln169">	status_t result = OpenType(type, node);</a>
<a name="ln170">	if (result != B_OK)</a>
<a name="ln171">		return result;</a>
<a name="ln172"> </a>
<a name="ln173">	return node.ReadAttr(attribute, datatype, 0, data, length);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">/*!	Reads a flattened BMessage from the given attribute of the given</a>
<a name="ln178">	MIME type.</a>
<a name="ln179"> </a>
<a name="ln180">	If no entry for the given type exists in the database, or if the data</a>
<a name="ln181">	stored in the attribute is not a flattened BMessage, the function fails</a>
<a name="ln182">	and the contents of \c msg are undefined.</a>
<a name="ln183"> </a>
<a name="ln184">	\param type The MIME type.</a>
<a name="ln185">	\param attribute The attribute name.</a>
<a name="ln186">	\param data Reference to a pre-allocated BMessage into which the attribute</a>
<a name="ln187">	       data is unflattened.</a>
<a name="ln188"> </a>
<a name="ln189">	\return A status code.</a>
<a name="ln190">*/</a>
<a name="ln191">status_t</a>
<a name="ln192">DatabaseLocation::ReadMessageAttribute(const char* type, const char* attribute,</a>
<a name="ln193">	BMessage&amp; _message) const</a>
<a name="ln194">{</a>
<a name="ln195">	if (type == NULL || attribute == NULL)</a>
<a name="ln196">		return B_BAD_VALUE;</a>
<a name="ln197"> </a>
<a name="ln198">	BNode node;</a>
<a name="ln199">	attr_info info;</a>
<a name="ln200"> </a>
<a name="ln201">	status_t result = OpenType(type, node);</a>
<a name="ln202">	if (result != B_OK)</a>
<a name="ln203">		return result;</a>
<a name="ln204"> </a>
<a name="ln205">	result = node.GetAttrInfo(attribute, &amp;info);</a>
<a name="ln206">	if (result != B_OK)</a>
<a name="ln207">		return result;</a>
<a name="ln208"> </a>
<a name="ln209">	if (info.type != B_MESSAGE_TYPE)</a>
<a name="ln210">		return B_BAD_VALUE;</a>
<a name="ln211"> </a>
<a name="ln212">	void* buffer = malloc(info.size);</a>
<a name="ln213">	if (buffer == NULL)</a>
<a name="ln214">		return B_NO_MEMORY;</a>
<a name="ln215">	MemoryDeleter bufferDeleter(buffer);</a>
<a name="ln216"> </a>
<a name="ln217">	ssize_t bytesRead = node.ReadAttr(attribute, B_MESSAGE_TYPE, 0, buffer,</a>
<a name="ln218">		info.size);</a>
<a name="ln219">	if (bytesRead != info.size)</a>
<a name="ln220">		return bytesRead &lt; 0 ? (status_t)bytesRead : (status_t)B_FILE_ERROR;</a>
<a name="ln221"> </a>
<a name="ln222">	return _message.Unflatten((const char*)buffer);</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">/*!	Reads a BString from the given attribute of the given MIME type.</a>
<a name="ln227"> </a>
<a name="ln228">	If no entry for the given type exists in the database, the function fails</a>
<a name="ln229">	and the contents of \c str are undefined.</a>
<a name="ln230"> </a>
<a name="ln231">	\param type The MIME type.</a>
<a name="ln232">	\param attribute The attribute name.</a>
<a name="ln233">	\param _string Reference to a pre-allocated BString into which the attribute</a>
<a name="ln234">	       data stored.</a>
<a name="ln235"> </a>
<a name="ln236">	\return A status code.</a>
<a name="ln237">*/</a>
<a name="ln238">status_t</a>
<a name="ln239">DatabaseLocation::ReadStringAttribute(const char* type, const char* attribute,</a>
<a name="ln240">	BString&amp; _string) const</a>
<a name="ln241">{</a>
<a name="ln242">	if (type == NULL || attribute == NULL)</a>
<a name="ln243">		return B_BAD_VALUE;</a>
<a name="ln244"> </a>
<a name="ln245">	BNode node;</a>
<a name="ln246">	status_t result = OpenType(type, node);</a>
<a name="ln247">	if (result != B_OK)</a>
<a name="ln248">		return result;</a>
<a name="ln249"> </a>
<a name="ln250">	return node.ReadAttrString(attribute, &amp;_string);</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253"> </a>
<a name="ln254">/*!	Writes \c len bytes of the given data to the given attribute</a>
<a name="ln255">	for the given MIME type.</a>
<a name="ln256"> </a>
<a name="ln257">	If no entry for the given type exists in the database, it is created.</a>
<a name="ln258"> </a>
<a name="ln259">	\param type The MIME type.</a>
<a name="ln260">	\param attribute The attribute name.</a>
<a name="ln261">	\param data Pointer to the data to write.</a>
<a name="ln262">	\param length The number of bytes to write.</a>
<a name="ln263">	\param datatype The data type of the given data.</a>
<a name="ln264"> </a>
<a name="ln265">	\return A status code.</a>
<a name="ln266">*/</a>
<a name="ln267">status_t</a>
<a name="ln268">DatabaseLocation::WriteAttribute(const char* type, const char* attribute,</a>
<a name="ln269">	const void* data, size_t length, type_code datatype, bool* _didCreate) const</a>
<a name="ln270">{</a>
<a name="ln271">	if (type == NULL || attribute == NULL || data == NULL)</a>
<a name="ln272">		return B_BAD_VALUE;</a>
<a name="ln273"> </a>
<a name="ln274">	BNode node;</a>
<a name="ln275">	status_t result = OpenWritableType(type, node, true, _didCreate);</a>
<a name="ln276">	if (result != B_OK)</a>
<a name="ln277">		return result;</a>
<a name="ln278"> </a>
<a name="ln279">	ssize_t bytesWritten = node.WriteAttr(attribute, datatype, 0, data, length);</a>
<a name="ln280">	if (bytesWritten &lt; 0)</a>
<a name="ln281">		return bytesWritten;</a>
<a name="ln282">	return bytesWritten == (ssize_t)length</a>
<a name="ln283">		? (status_t)B_OK : (status_t)B_FILE_ERROR;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">/*! Flattens the given \c BMessage and writes it to the given attribute</a>
<a name="ln288">	of the given MIME type.</a>
<a name="ln289"> </a>
<a name="ln290">	If no entry for the given type exists in the database, it is created.</a>
<a name="ln291"> </a>
<a name="ln292">	\param type The MIME type.</a>
<a name="ln293">	\param attribute The attribute name.</a>
<a name="ln294">	\param message The BMessage to flatten and write.</a>
<a name="ln295"> </a>
<a name="ln296">	\return A status code.</a>
<a name="ln297">*/</a>
<a name="ln298">status_t</a>
<a name="ln299">DatabaseLocation::WriteMessageAttribute(const char* type, const char* attribute,</a>
<a name="ln300">	const BMessage&amp; message, bool* _didCreate) const</a>
<a name="ln301">{</a>
<a name="ln302">	BMallocIO data;</a>
<a name="ln303">	status_t result = data.SetSize(message.FlattenedSize());</a>
<a name="ln304">	if (result != B_OK)</a>
<a name="ln305">		return result;</a>
<a name="ln306"> </a>
<a name="ln307">	ssize_t bytes;</a>
<a name="ln308">	result = message.Flatten(&amp;data, &amp;bytes);</a>
<a name="ln309">	if (result != B_OK)</a>
<a name="ln310">		return result;</a>
<a name="ln311"> </a>
<a name="ln312">	return WriteAttribute(type, attribute, data.Buffer(), data.BufferLength(),</a>
<a name="ln313">		B_MESSAGE_TYPE, _didCreate);</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316"> </a>
<a name="ln317">/*!	Deletes the given attribute for the given type</a>
<a name="ln318"> </a>
<a name="ln319">	\param type The mime type</a>
<a name="ln320">	\param attribute The attribute name</a>
<a name="ln321"> </a>
<a name="ln322">	\return A status code, \c B_OK on success or an error code on failure.</a>
<a name="ln323">	\retval B_OK Success.</a>
<a name="ln324">	\retval B_ENTRY_NOT_FOUND No such type or attribute.</a>
<a name="ln325">*/</a>
<a name="ln326">status_t</a>
<a name="ln327">DatabaseLocation::DeleteAttribute(const char* type, const char* attribute) const</a>
<a name="ln328">{</a>
<a name="ln329">	if (type == NULL || attribute == NULL)</a>
<a name="ln330">		return B_BAD_VALUE;</a>
<a name="ln331"> </a>
<a name="ln332">	BNode node;</a>
<a name="ln333">	status_t result = OpenWritableType(type, node, false);</a>
<a name="ln334">	if (result != B_OK)</a>
<a name="ln335">		return result;</a>
<a name="ln336"> </a>
<a name="ln337">	return node.RemoveAttr(attribute);</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340"> </a>
<a name="ln341">/*! Fetches the application hint for the given MIME type.</a>
<a name="ln342"> </a>
<a name="ln343">	The entry_ref pointed to by \c ref must be pre-allocated.</a>
<a name="ln344"> </a>
<a name="ln345">	\param type The MIME type of interest</a>
<a name="ln346">	\param _ref Reference to a pre-allocated \c entry_ref struct into</a>
<a name="ln347">	       which the location of the hint application is copied.</a>
<a name="ln348"> </a>
<a name="ln349">	\return A status code, \c B_OK on success or an error code on failure.</a>
<a name="ln350">	\retval B_OK Success.</a>
<a name="ln351">	\retval B_ENTRY_NOT_FOUND No app hint exists for the given type</a>
<a name="ln352">*/</a>
<a name="ln353">status_t</a>
<a name="ln354">DatabaseLocation::GetAppHint(const char* type, entry_ref&amp; _ref)</a>
<a name="ln355">{</a>
<a name="ln356">	if (type == NULL)</a>
<a name="ln357">		return B_BAD_VALUE;</a>
<a name="ln358"> </a>
<a name="ln359">	char path[B_PATH_NAME_LENGTH];</a>
<a name="ln360">	BEntry entry;</a>
<a name="ln361">	ssize_t status = ReadAttribute(type, kAppHintAttr, path, B_PATH_NAME_LENGTH,</a>
<a name="ln362">		kAppHintType);</a>
<a name="ln363"> </a>
<a name="ln364">	if (status &gt;= B_OK)</a>
<a name="ln365">		status = entry.SetTo(path);</a>
<a name="ln366">	if (status == B_OK)</a>
<a name="ln367">		status = entry.GetRef(&amp;_ref);</a>
<a name="ln368"> </a>
<a name="ln369">	return status;</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372"> </a>
<a name="ln373">/*!	Fetches from the MIME database a BMessage describing the attributes</a>
<a name="ln374">	typically associated with files of the given MIME type</a>
<a name="ln375"> </a>
<a name="ln376">	The attribute information is returned in a pre-allocated BMessage pointed to</a>
<a name="ln377">	by the \c info parameter (note that the any prior contents of the message</a>
<a name="ln378">	will be destroyed). Please see BMimeType::SetAttrInfo() for a description</a>
<a name="ln379">	of the expected format of such a message.</a>
<a name="ln380"> </a>
<a name="ln381">	\param _info Reference to a pre-allocated BMessage into which information</a>
<a name="ln382">	       about the MIME type's associated file attributes is stored.</a>
<a name="ln383"> </a>
<a name="ln384">	\return A status code, \c B_OK on success or an error code on failure.</a>
<a name="ln385">*/</a>
<a name="ln386">status_t</a>
<a name="ln387">DatabaseLocation::GetAttributesInfo(const char* type, BMessage&amp; _info)</a>
<a name="ln388">{</a>
<a name="ln389">	status_t result = ReadMessageAttribute(type, kAttrInfoAttr, _info);</a>
<a name="ln390"> </a>
<a name="ln391">	if (result == B_ENTRY_NOT_FOUND) {</a>
<a name="ln392">		// return an empty message</a>
<a name="ln393">		_info.MakeEmpty();</a>
<a name="ln394">		result = B_OK;</a>
<a name="ln395">	}</a>
<a name="ln396"> </a>
<a name="ln397">	if (result == B_OK) {</a>
<a name="ln398">		_info.what = 233;</a>
<a name="ln399">			// Don't know why, but that's what R5 does.</a>
<a name="ln400">		result = _info.AddString(&quot;type&quot;, type);</a>
<a name="ln401">	}</a>
<a name="ln402"> </a>
<a name="ln403">	return result;</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">/*!	Fetches the short description for the given MIME type.</a>
<a name="ln408"> </a>
<a name="ln409">	The string pointed to by \c description must be long enough to</a>
<a name="ln410">	hold the short description; a length of \c B_MIME_TYPE_LENGTH is</a>
<a name="ln411">	recommended.</a>
<a name="ln412"> </a>
<a name="ln413">	\param type The MIME type of interest</a>
<a name="ln414">	\param description Pointer to a pre-allocated string into which the short</a>
<a name="ln415">	       description is copied. If the function fails, the contents of the</a>
<a name="ln416">	       string are undefined.</a>
<a name="ln417"> </a>
<a name="ln418">	\return A status code, \c B_OK on success or an error code on failure.</a>
<a name="ln419">	\retval B_OK Success.</a>
<a name="ln420">	\retval B_ENTRY_NOT_FOUND No short description exists for the given type.</a>
<a name="ln421">*/</a>
<a name="ln422">status_t</a>
<a name="ln423">DatabaseLocation::GetShortDescription(const char* type, char* description)</a>
<a name="ln424">{</a>
<a name="ln425">	ssize_t result = ReadAttribute(type, kShortDescriptionAttr, description,</a>
<a name="ln426">		B_MIME_TYPE_LENGTH, kShortDescriptionType);</a>
<a name="ln427"> </a>
<a name="ln428">	return result &gt;= 0 ? B_OK : result;</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431"> </a>
<a name="ln432">/*!	Fetches the long description for the given MIME type.</a>
<a name="ln433"> </a>
<a name="ln434">	The string pointed to by \c description must be long enough to</a>
<a name="ln435">	hold the long description; a length of \c B_MIME_TYPE_LENGTH is</a>
<a name="ln436">	recommended.</a>
<a name="ln437"> </a>
<a name="ln438">	\param type The MIME type of interest</a>
<a name="ln439">	\param description Pointer to a pre-allocated string into which the long</a>
<a name="ln440">	       description is copied. If the function fails, the contents of the</a>
<a name="ln441">	       string are undefined.</a>
<a name="ln442"> </a>
<a name="ln443">	\return A status code, \c B_OK on success or an error code on failure.</a>
<a name="ln444">	\retval B_OK Success.</a>
<a name="ln445">	\retval B_ENTRY_NOT_FOUND No long description exists for the given type</a>
<a name="ln446">*/</a>
<a name="ln447">status_t</a>
<a name="ln448">DatabaseLocation::GetLongDescription(const char* type, char* description)</a>
<a name="ln449">{</a>
<a name="ln450">	ssize_t result = ReadAttribute(type, kLongDescriptionAttr, description,</a>
<a name="ln451">		B_MIME_TYPE_LENGTH, kLongDescriptionType);</a>
<a name="ln452"> </a>
<a name="ln453">	return result &gt;= 0 ? B_OK : result;</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456"> </a>
<a name="ln457">/*!	Fetches a BMessage describing the MIME type's associated filename</a>
<a name="ln458">	extensions.</a>
<a name="ln459"> </a>
<a name="ln460">	The list of extensions is returned in a pre-allocated BMessage pointed to</a>
<a name="ln461">	by the \c extensions parameter (note that the any prior contents of the</a>
<a name="ln462">	message will be destroyed). Please see BMimeType::GetFileExtensions() for</a>
<a name="ln463">	a description of the message format.</a>
<a name="ln464"> </a>
<a name="ln465">	\param extensions Reference to a pre-allocated BMessage into which the MIME</a>
<a name="ln466">	       type's associated file extensions will be stored.</a>
<a name="ln467"> </a>
<a name="ln468">	\return A status code, \c B_OK on success or an error code on failure.</a>
<a name="ln469">*/</a>
<a name="ln470">status_t</a>
<a name="ln471">DatabaseLocation::GetFileExtensions(const char* type, BMessage&amp; _extensions)</a>
<a name="ln472">{</a>
<a name="ln473">	status_t result = ReadMessageAttribute(type, kFileExtensionsAttr, _extensions);</a>
<a name="ln474">	if (result == B_ENTRY_NOT_FOUND) {</a>
<a name="ln475">		// return an empty message</a>
<a name="ln476">		_extensions.MakeEmpty();</a>
<a name="ln477">		result = B_OK;</a>
<a name="ln478">	}</a>
<a name="ln479"> </a>
<a name="ln480">	if (result == B_OK) {</a>
<a name="ln481">		_extensions.what = 234;	// Don't know why, but that's what R5 does.</a>
<a name="ln482">		result = _extensions.AddString(&quot;type&quot;, type);</a>
<a name="ln483">	}</a>
<a name="ln484"> </a>
<a name="ln485">	return result;</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488"> </a>
<a name="ln489">/*!	Fetches the icon of given size associated with the given MIME type.</a>
<a name="ln490"> </a>
<a name="ln491">	The bitmap pointed to by \c icon must be of the proper size (\c 32x32</a>
<a name="ln492">	for \c B_LARGE_ICON, \c 16x16 for \c B_MINI_ICON) and color depth</a>
<a name="ln493">	(\c B_CMAP8).</a>
<a name="ln494"> </a>
<a name="ln495">	\param type The mime type</a>
<a name="ln496">	\param icon Reference to a pre-allocated bitmap of proper dimensions and</a>
<a name="ln497">	       color depth</a>
<a name="ln498">	\param size The size icon you're interested in (\c B_LARGE_ICON or</a>
<a name="ln499">	       \c B_MINI_ICON)</a>
<a name="ln500"> </a>
<a name="ln501">	\return A status code.</a>
<a name="ln502">*/</a>
<a name="ln503">status_t</a>
<a name="ln504">DatabaseLocation::GetIcon(const char* type, BBitmap&amp; _icon, icon_size size)</a>
<a name="ln505">{</a>
<a name="ln506">	return GetIconForType(type, NULL, _icon, size);</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">/*!	Fetches the vector icon associated with the given MIME type.</a>
<a name="ln511"> </a>
<a name="ln512">	\param type The mime type</a>
<a name="ln513">	\param _data Reference via which the allocated icon data is returned. You</a>
<a name="ln514">	       need to free the buffer once you're done with it.</a>
<a name="ln515">	\param _size Reference via which the size of the icon data is returned.</a>
<a name="ln516"> </a>
<a name="ln517">	\return A status code.</a>
<a name="ln518">*/</a>
<a name="ln519">status_t</a>
<a name="ln520">DatabaseLocation::GetIcon(const char* type, uint8*&amp; _data, size_t&amp; _size)</a>
<a name="ln521">{</a>
<a name="ln522">	return GetIconForType(type, NULL, _data, _size);</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">/*!	Fetches the large or mini icon used by an application of this type</a>
<a name="ln527">	for files of the given type.</a>
<a name="ln528"> </a>
<a name="ln529">	The type of the \c BMimeType object is not required to actually be a subtype</a>
<a name="ln530">	of \c &quot;application/&quot;; that is the intended use however, and calling</a>
<a name="ln531">	\c GetIconForType() on a non-application type will likely return</a>
<a name="ln532">	\c B_ENTRY_NOT_FOUND.</a>
<a name="ln533"> </a>
<a name="ln534">	The icon is copied into the \c BBitmap pointed to by \c icon. The bitmap</a>
<a name="ln535">	must be the proper size: \c 32x32 for the large icon, \c 16x16 for the mini</a>
<a name="ln536">	icon.</a>
<a name="ln537"> </a>
<a name="ln538">	\param type The MIME type</a>
<a name="ln539">	\param fileType Pointer to a pre-allocated string containing the MIME type</a>
<a name="ln540">	       whose custom icon you wish to fetch. If NULL, works just like</a>
<a name="ln541">	       GetIcon().</a>
<a name="ln542">	\param icon Reference to a pre-allocated \c BBitmap of proper size and</a>
<a name="ln543">	       colorspace into which the icon is copied.</a>
<a name="ln544">	\param icon_size Value that specifies which icon to return. Currently</a>
<a name="ln545">	       \c B_LARGE_ICON and \c B_MINI_ICON are supported.</a>
<a name="ln546"> </a>
<a name="ln547">	\return A status code, \c B_OK on success or an error code on failure.</a>
<a name="ln548">	\retval B_OK Success.</a>
<a name="ln549">	\retval B_ENTRY_NOT_FOUND No icon of the given size exists for the given type</a>
<a name="ln550">*/</a>
<a name="ln551">status_t</a>
<a name="ln552">DatabaseLocation::GetIconForType(const char* type, const char* fileType,</a>
<a name="ln553">	BBitmap&amp; _icon, icon_size which)</a>
<a name="ln554">{</a>
<a name="ln555">	if (type == NULL)</a>
<a name="ln556">		return B_BAD_VALUE;</a>
<a name="ln557"> </a>
<a name="ln558">	// open the node for the given type</a>
<a name="ln559">	BNode node;</a>
<a name="ln560">	status_t result = OpenType(type, node);</a>
<a name="ln561">	if (result != B_OK)</a>
<a name="ln562">		return result;</a>
<a name="ln563"> </a>
<a name="ln564">	// construct our attribute name</a>
<a name="ln565">	BString vectorIconAttrName;</a>
<a name="ln566">	BString smallIconAttrName;</a>
<a name="ln567">	BString largeIconAttrName;</a>
<a name="ln568"> </a>
<a name="ln569">	if (fileType != NULL) {</a>
<a name="ln570">		BString lowerCaseFileType(fileType);</a>
<a name="ln571">		lowerCaseFileType.ToLower();</a>
<a name="ln572"> </a>
<a name="ln573">		vectorIconAttrName &lt;&lt; kIconAttrPrefix &lt;&lt; lowerCaseFileType;</a>
<a name="ln574">		smallIconAttrName &lt;&lt; kMiniIconAttrPrefix &lt;&lt; lowerCaseFileType;</a>
<a name="ln575">		largeIconAttrName &lt;&lt; kLargeIconAttrPrefix &lt;&lt; lowerCaseFileType;</a>
<a name="ln576">	} else {</a>
<a name="ln577">		vectorIconAttrName = kIconAttr;</a>
<a name="ln578">		smallIconAttrName = kMiniIconAttr;</a>
<a name="ln579">		largeIconAttrName = kLargeIconAttr;</a>
<a name="ln580">	}</a>
<a name="ln581"> </a>
<a name="ln582">	return BIconUtils::GetIcon(&amp;node, vectorIconAttrName, smallIconAttrName,</a>
<a name="ln583">		largeIconAttrName, which, &amp;_icon);</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586"> </a>
<a name="ln587">/*!	Fetches the vector icon used by an application of this type for files</a>
<a name="ln588">	of the given type.</a>
<a name="ln589"> </a>
<a name="ln590">	The type of the \c BMimeType object is not required to actually be a subtype</a>
<a name="ln591">	of \c &quot;application/&quot;; that is the intended use however, and calling</a>
<a name="ln592">	\c GetIconForType() on a non-application type will likely return</a>
<a name="ln593">	\c B_ENTRY_NOT_FOUND.</a>
<a name="ln594"> </a>
<a name="ln595">	The icon data is allocated and returned in \a _data.</a>
<a name="ln596"> </a>
<a name="ln597">	\param type The MIME type</a>
<a name="ln598">	\param fileType Reference to a pre-allocated string containing the MIME type</a>
<a name="ln599">	       whose custom icon you wish to fetch. If NULL, works just like</a>
<a name="ln600">	       GetIcon().</a>
<a name="ln601">	\param _data Reference via which the icon data is returned on success.</a>
<a name="ln602">	\param _size Reference via which the size of the icon data is returned.</a>
<a name="ln603"> </a>
<a name="ln604">	\return A status code, \c B_OK on success or another code on failure.</a>
<a name="ln605">	\retval B_OK Success.</a>
<a name="ln606">	\retval B_ENTRY_NOT_FOUND No vector icon existed for the given type.</a>
<a name="ln607">*/</a>
<a name="ln608">status_t</a>
<a name="ln609">DatabaseLocation::GetIconForType(const char* type, const char* fileType,</a>
<a name="ln610">	uint8*&amp; _data, size_t&amp; _size)</a>
<a name="ln611">{</a>
<a name="ln612">	if (type == NULL)</a>
<a name="ln613">		return B_BAD_VALUE;</a>
<a name="ln614"> </a>
<a name="ln615">	// open the node for the given type</a>
<a name="ln616">	BNode node;</a>
<a name="ln617">	status_t result = OpenType(type, node);</a>
<a name="ln618">	if (result != B_OK)</a>
<a name="ln619">		return result;</a>
<a name="ln620"> </a>
<a name="ln621">	// construct our attribute name</a>
<a name="ln622">	BString iconAttrName;</a>
<a name="ln623"> </a>
<a name="ln624">	if (fileType != NULL)</a>
<a name="ln625">		iconAttrName &lt;&lt; kIconAttrPrefix &lt;&lt; BString(fileType).ToLower();</a>
<a name="ln626">	else</a>
<a name="ln627">		iconAttrName = kIconAttr;</a>
<a name="ln628"> </a>
<a name="ln629">	// get info about attribute for that name</a>
<a name="ln630">	attr_info info;</a>
<a name="ln631">	if (result == B_OK)</a>
<a name="ln632">		result = node.GetAttrInfo(iconAttrName, &amp;info);</a>
<a name="ln633"> </a>
<a name="ln634">	// validate attribute type</a>
<a name="ln635">	if (result == B_OK)</a>
<a name="ln636">		result = (info.type == B_VECTOR_ICON_TYPE) ? B_OK : B_BAD_VALUE;</a>
<a name="ln637"> </a>
<a name="ln638">	// allocate a buffer and read the attribute data into it</a>
<a name="ln639">	if (result == B_OK) {</a>
<a name="ln640">		uint8* buffer = new(std::nothrow) uint8[info.size];</a>
<a name="ln641">		if (buffer == NULL)</a>
<a name="ln642">			result = B_NO_MEMORY;</a>
<a name="ln643"> </a>
<a name="ln644">		ssize_t bytesRead = -1;</a>
<a name="ln645">		if (result == B_OK) {</a>
<a name="ln646">			bytesRead = node.ReadAttr(iconAttrName, B_VECTOR_ICON_TYPE, 0, buffer,</a>
<a name="ln647">				info.size);</a>
<a name="ln648">		}</a>
<a name="ln649"> </a>
<a name="ln650">		if (bytesRead &gt;= 0)</a>
<a name="ln651">			result = bytesRead == info.size ? B_OK : B_FILE_ERROR;</a>
<a name="ln652"> </a>
<a name="ln653">		if (result == B_OK) {</a>
<a name="ln654">			// success, set data pointer and size</a>
<a name="ln655">			_data = buffer;</a>
<a name="ln656">			_size = info.size;</a>
<a name="ln657">		} else</a>
<a name="ln658">			delete[] buffer;</a>
<a name="ln659">	}</a>
<a name="ln660"> </a>
<a name="ln661">	return result;</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664"> </a>
<a name="ln665">/*!	Fetches signature of the MIME type's preferred application for the</a>
<a name="ln666">	given action.</a>
<a name="ln667"> </a>
<a name="ln668">	The string pointed to by \c signature must be long enough to</a>
<a name="ln669">	hold the short description; a length of \c B_MIME_TYPE_LENGTH is</a>
<a name="ln670">	recommended.</a>
<a name="ln671"> </a>
<a name="ln672">	Currently, the only supported app verb is \c B_OPEN.</a>
<a name="ln673"> </a>
<a name="ln674">	\param type The MIME type of interest</a>
<a name="ln675">	\param description Pointer to a pre-allocated string into which the</a>
<a name="ln676">	       preferred application's signature is copied. If the function fails,</a>
<a name="ln677">	       the contents of the string are undefined.</a>
<a name="ln678">	\param verb \c The action of interest</a>
<a name="ln679"> </a>
<a name="ln680">	\return A status code, \c B_OK on success or another code on failure.</a>
<a name="ln681">	\retval B_OK Success.</a>
<a name="ln682">	\retval B_ENTRY_NOT_FOUND No such preferred application exists</a>
<a name="ln683">*/</a>
<a name="ln684">status_t</a>
<a name="ln685">DatabaseLocation::GetPreferredApp(const char* type, char* signature,</a>
<a name="ln686">	app_verb verb)</a>
<a name="ln687">{</a>
<a name="ln688">	// Since B_OPEN is the currently the only app_verb, it is essentially</a>
<a name="ln689">	// ignored</a>
<a name="ln690">	ssize_t result = ReadAttribute(type, kPreferredAppAttr, signature,</a>
<a name="ln691">		B_MIME_TYPE_LENGTH, kPreferredAppType);</a>
<a name="ln692"> </a>
<a name="ln693">	return result &gt;= 0 ? B_OK : result;</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696"> </a>
<a name="ln697">/*!	Fetches the sniffer rule for the given MIME type.</a>
<a name="ln698">	\param type The MIME type of interest</a>
<a name="ln699">	\param _result Pointer to a pre-allocated BString into which the type's</a>
<a name="ln700">	       sniffer rule is copied.</a>
<a name="ln701"> </a>
<a name="ln702">	\return A status code, \c B_OK on success or another code on failure.</a>
<a name="ln703">	\retval B_OK Success.</a>
<a name="ln704">	\retval B_ENTRY_NOT_FOUND No such preferred application exists.</a>
<a name="ln705">*/</a>
<a name="ln706">status_t</a>
<a name="ln707">DatabaseLocation::GetSnifferRule(const char* type, BString&amp; _result)</a>
<a name="ln708">{</a>
<a name="ln709">	return ReadStringAttribute(type, kSnifferRuleAttr, _result);</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">status_t</a>
<a name="ln714">DatabaseLocation::GetSupportedTypes(const char* type, BMessage&amp; _types)</a>
<a name="ln715">{</a>
<a name="ln716">	status_t result = ReadMessageAttribute(type, kSupportedTypesAttr, _types);</a>
<a name="ln717">	if (result == B_ENTRY_NOT_FOUND) {</a>
<a name="ln718">		// return an empty message</a>
<a name="ln719">		_types.MakeEmpty();</a>
<a name="ln720">		result = B_OK;</a>
<a name="ln721">	}</a>
<a name="ln722">	if (result == B_OK) {</a>
<a name="ln723">		_types.what = 0;</a>
<a name="ln724">		result = _types.AddString(&quot;type&quot;, type);</a>
<a name="ln725">	}</a>
<a name="ln726"> </a>
<a name="ln727">	return result;</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730"> </a>
<a name="ln731">//! Checks if the given MIME type is present in the database</a>
<a name="ln732">bool</a>
<a name="ln733">DatabaseLocation::IsInstalled(const char* type)</a>
<a name="ln734">{</a>
<a name="ln735">	BNode node;</a>
<a name="ln736">	return OpenType(type, node) == B_OK;</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739"> </a>
<a name="ln740">BString</a>
<a name="ln741">DatabaseLocation::_TypeToFilename(const char* type, int32 index) const</a>
<a name="ln742">{</a>
<a name="ln743">	BString path = fDirectories.StringAt(index);</a>
<a name="ln744">	return path &lt;&lt; '/' &lt;&lt; BString(type).ToLower();</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747"> </a>
<a name="ln748">status_t</a>
<a name="ln749">DatabaseLocation::_OpenType(const char* type, BNode&amp; _node, int32&amp; _index) const</a>
<a name="ln750">{</a>
<a name="ln751">	int32 count = fDirectories.CountStrings();</a>
<a name="ln752">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln753">		status_t result = _node.SetTo(_TypeToFilename(type, i));</a>
<a name="ln754">		attr_info attrInfo;</a>
<a name="ln755">		if (result == B_OK &amp;&amp; _node.GetAttrInfo(kTypeAttr, &amp;attrInfo) == B_OK) {</a>
<a name="ln756">			_index = i;</a>
<a name="ln757">			return B_OK;</a>
<a name="ln758">		}</a>
<a name="ln759">	}</a>
<a name="ln760"> </a>
<a name="ln761">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">status_t</a>
<a name="ln766">DatabaseLocation::_CreateTypeNode(const char* type, BNode&amp; _node) const</a>
<a name="ln767">{</a>
<a name="ln768">	const char* slash = strchr(type, '/');</a>
<a name="ln769">	BString superTypeName;</a>
<a name="ln770">	if (slash != NULL)</a>
<a name="ln771">		superTypeName.SetTo(type, slash - type);</a>
<a name="ln772">	else</a>
<a name="ln773">		superTypeName = type;</a>
<a name="ln774">	superTypeName.ToLower();</a>
<a name="ln775"> </a>
<a name="ln776">	// open/create the directory for the supertype</a>
<a name="ln777">	BDirectory parent(WritableDirectory());</a>
<a name="ln778">	status_t result = parent.InitCheck();</a>
<a name="ln779">	if (result != B_OK)</a>
<a name="ln780">		return result;</a>
<a name="ln781"> </a>
<a name="ln782">	BDirectory superTypeDirectory;</a>
<a name="ln783">	if (BEntry(&amp;parent, superTypeName).Exists())</a>
<a name="ln784">		result = superTypeDirectory.SetTo(&amp;parent, superTypeName);</a>
<a name="ln785">	else</a>
<a name="ln786">		result = parent.CreateDirectory(superTypeName, &amp;superTypeDirectory);</a>
<a name="ln787"> </a>
<a name="ln788">	if (result != B_OK)</a>
<a name="ln789">		return result;</a>
<a name="ln790"> </a>
<a name="ln791">	// create the subtype</a>
<a name="ln792">	BFile subTypeFile;</a>
<a name="ln793">	if (slash != NULL) {</a>
<a name="ln794">		result = superTypeDirectory.CreateFile(BString(slash + 1).ToLower(),</a>
<a name="ln795">			&amp;subTypeFile);</a>
<a name="ln796">		if (result != B_OK)</a>
<a name="ln797">			return result;</a>
<a name="ln798">	}</a>
<a name="ln799"> </a>
<a name="ln800">	// assign the result</a>
<a name="ln801">	if (slash != NULL)</a>
<a name="ln802">		_node = subTypeFile;</a>
<a name="ln803">	else</a>
<a name="ln804">		_node = superTypeDirectory;</a>
<a name="ln805">	return _node.InitCheck();</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808"> </a>
<a name="ln809">status_t</a>
<a name="ln810">DatabaseLocation::_CopyTypeNode(BNode&amp; source, const char* type, BNode&amp; _target)</a>
<a name="ln811">	const</a>
<a name="ln812">{</a>
<a name="ln813">	status_t result = _CreateTypeNode(type, _target);</a>
<a name="ln814">	if (result != B_OK)</a>
<a name="ln815">		return result;</a>
<a name="ln816"> </a>
<a name="ln817">	// copy the attributes</a>
<a name="ln818">	MemoryDeleter bufferDeleter;</a>
<a name="ln819">	size_t bufferSize = 0;</a>
<a name="ln820"> </a>
<a name="ln821">	source.RewindAttrs();</a>
<a name="ln822">	char attribute[B_ATTR_NAME_LENGTH];</a>
<a name="ln823">	while (source.GetNextAttrName(attribute) == B_OK) {</a>
<a name="ln824">		attr_info info;</a>
<a name="ln825">		result = source.GetAttrInfo(attribute, &amp;info);</a>
<a name="ln826">		if (result != B_OK) {</a>
<a name="ln827">			syslog(LOG_ERR, &quot;Failed to get info for attribute \&quot;%s\&quot; of MIME &quot;</a>
<a name="ln828">				&quot;type \&quot;%s\&quot;: %s&quot;, attribute, type, strerror(result));</a>
<a name="ln829">			continue;</a>
<a name="ln830">		}</a>
<a name="ln831"> </a>
<a name="ln832">		// resize our buffer, if necessary</a>
<a name="ln833">		if (info.size &gt; (off_t)bufferSize) {</a>
<a name="ln834">			bufferDeleter.SetTo(malloc(info.size));</a>
<a name="ln835">			if (bufferDeleter.Get() == NULL)</a>
<a name="ln836">				return B_NO_MEMORY;</a>
<a name="ln837">			bufferSize = info.size;</a>
<a name="ln838">		}</a>
<a name="ln839"> </a>
<a name="ln840">		ssize_t bytesRead = source.ReadAttr(attribute, info.type, 0,</a>
<a name="ln841">			bufferDeleter.Get(), info.size);</a>
<a name="ln842">		if (bytesRead != info.size) {</a>
<a name="ln843">			syslog(LOG_ERR, &quot;Failed to read attribute \&quot;%s\&quot; of MIME &quot;</a>
<a name="ln844">				&quot;type \&quot;%s\&quot;: %s&quot;, attribute, type,</a>
<a name="ln845">		  		bytesRead &lt; 0 ? strerror(bytesRead) : &quot;short read&quot;);</a>
<a name="ln846">			continue;</a>
<a name="ln847">		}</a>
<a name="ln848"> </a>
<a name="ln849">		ssize_t bytesWritten = _target.WriteAttr(attribute, info.type, 0,</a>
<a name="ln850">			bufferDeleter.Get(), info.size);</a>
<a name="ln851">		if (bytesWritten &lt; 0) {</a>
<a name="ln852">			syslog(LOG_ERR, &quot;Failed to write attribute \&quot;%s\&quot; of MIME &quot;</a>
<a name="ln853">				&quot;type \&quot;%s\&quot;: %s&quot;, attribute, type,</a>
<a name="ln854">		  		bytesWritten &lt; 0 ? strerror(bytesWritten) : &quot;short write&quot;);</a>
<a name="ln855">			continue;</a>
<a name="ln856">		}</a>
<a name="ln857">	}</a>
<a name="ln858"> </a>
<a name="ln859">	return B_OK;</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862"> </a>
<a name="ln863">} // namespace Mime</a>
<a name="ln864">} // namespace Storage</a>
<a name="ln865">} // namespace BPrivate</a>

</code></pre>
<div class="balloon" rel="631"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'result == ((int) 0)' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
