
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ParameterWeb.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2012, Haiku. All Rights Reserved.</a>
<a name="ln3"> * This file may be used under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Author: Zousar Shaker</a>
<a name="ln6"> *         Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> *         Marcus Overhagen</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">/*! Implements the following classes:</a>
<a name="ln12">	BParameterWeb, BParameterGroup, BParameter, BNullParameter,</a>
<a name="ln13">	BContinuousParameter, BDiscreteParameter</a>
<a name="ln14">*/</a>
<a name="ln15"> </a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;ParameterWeb.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;new&gt;</a>
<a name="ln20">#include &lt;string.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;MediaNode.h&gt;</a>
<a name="ln23">#include &lt;MediaRoster.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;DataExchange.h&quot;</a>
<a name="ln26">#include &quot;MediaDebug.h&quot;</a>
<a name="ln27">#include &quot;MediaMisc.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29"> </a>
<a name="ln30">/*</a>
<a name="ln31">	The following is documentation on the flattened format</a>
<a name="ln32">	of structures/classes in this module:</a>
<a name="ln33"> </a>
<a name="ln34">	//--------BEGIN-CORE-BPARAMETER-STRUCT---------------------</a>
<a name="ln35">	?? (0x02040607): 4 bytes</a>
<a name="ln36">	BParameter Struct Size (in bytes): 4 bytes</a>
<a name="ln37">	ID: 4 bytes</a>
<a name="ln38">	Name String Length: 1 byte (??)</a>
<a name="ln39">		Name String: 'Name String Length' bytes</a>
<a name="ln40">	Kind String Length: 1 byte (??)</a>
<a name="ln41">		Kind String: 'Kind String Length' bytes</a>
<a name="ln42">	Unit String Length: 1 byte (??)</a>
<a name="ln43">		Unit String: 'Unit String Length' bytes</a>
<a name="ln44">	Inputs Count: 4 bytes</a>
<a name="ln45">		Inputs (pointers): ('Inputs Count')*4 bytes</a>
<a name="ln46">	Outputs Count: 4 bytes</a>
<a name="ln47">		Outputs (pointers): ('Outputs Count')*4 bytes</a>
<a name="ln48">	Media Type: 4 bytes</a>
<a name="ln49">	ChannelCount: 4 bytes</a>
<a name="ln50">	Flags: 4 bytes</a>
<a name="ln51">	//---------END-CORE-BPARAMETER-STRUCT-----------------------</a>
<a name="ln52">	//--------BEGIN-BCONTINUOUSPARAMETER-STRUCT---------</a>
<a name="ln53">	Min: 4 bytes (as float)</a>
<a name="ln54">	Max: 4 bytes (as float)</a>
<a name="ln55">	Stepping: 4 bytes (as float)</a>
<a name="ln56">	Response: 4 bytes (as int or enum)</a>
<a name="ln57">	Factor: 4 bytes (as float)</a>
<a name="ln58">	Offset: 4 bytes (as float)</a>
<a name="ln59">	//--------END-BCONTINUOUSPARAMETER-STRUCT-------------</a>
<a name="ln60">	//--------BEGIN-BDISCRETEPARAMETER-STRUCT----------------</a>
<a name="ln61">	NumItems: 4 bytes (as int)</a>
<a name="ln62">		//for each item BEGIN</a>
<a name="ln63">		Item Name String Length: 1 byte</a>
<a name="ln64">			Item Name String: 'Item Name String Length' bytes</a>
<a name="ln65">		Item Value: 4 bytes (as int)</a>
<a name="ln66">		//for each item END</a>
<a name="ln67">	//--------END-BDISCRETEPARAMETER-STRUCT-------------------</a>
<a name="ln68"> </a>
<a name="ln69">	//--------BEGIN-CORE-BPARAMETERGROUP-STRUCT-----------</a>
<a name="ln70">	?? (0x03040507 OR 0x03040509 depending if the flags field is included or not???): 4 bytes</a>
<a name="ln71">	(possible) Flags: 4 bytes</a>
<a name="ln72">	Name String Length: 1 byte (??)</a>
<a name="ln73">		Name String: 'Name String Length' bytes</a>
<a name="ln74">	Param Count: 4 bytes</a>
<a name="ln75">		//for each Param BEGIN</a>
<a name="ln76">		Pointer: 4 bytes</a>
<a name="ln77">		Parameter Type: 4 bytes</a>
<a name="ln78">		Flattened Parameter Size: 4 bytes</a>
<a name="ln79">		Flattened Parameter: 'Flattened Parameter Size' bytes</a>
<a name="ln80">		//for each Param END</a>
<a name="ln81">	Subgroup Count: 4 bytes</a>
<a name="ln82">		//for each SubGroup BEGIN</a>
<a name="ln83">		Pointer: 4 bytes</a>
<a name="ln84">		MEDIA PARAMETER GROUP TYPE('BMCG' (opposite byte order in file)): 4 bytes</a>
<a name="ln85">		Flattened Group Size: 4 bytes</a>
<a name="ln86">		Flattened Group: 'Flattened Group Size' bytes</a>
<a name="ln87">		//for each SubGroup END</a>
<a name="ln88"> </a>
<a name="ln89">	//---------END-CORE-BPARAMETERGROUP-STRUCT--------------</a>
<a name="ln90"> </a>
<a name="ln91">	//--------BEGIN-CORE-BPARAMETERWEB-STRUCT-----------</a>
<a name="ln92">	?? 0x01030506: 4 bytes</a>
<a name="ln93">	??: 4 bytes (is always 1)</a>
<a name="ln94">	Group Count: 4 bytes</a>
<a name="ln95">	Node (as media_node): 0x18 bytes (decimal 24 bytes)</a>
<a name="ln96">		//for each Group BEGIN</a>
<a name="ln97">		Flattened Group Size: 4 bytes</a>
<a name="ln98">		Flattened Group: 'Flattened Group Size' bytes</a>
<a name="ln99">		//for each Group END</a>
<a name="ln100">		//for each Group BEGIN</a>
<a name="ln101">		??: 4 bytes (never get written to (holds uninitialized value))</a>
<a name="ln102">		//for each Group END</a>
<a name="ln103">	//---------END-CORE-BPARAMETERWEB-STRUCT--------------</a>
<a name="ln104"> </a>
<a name="ln105">*/</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">const char * const B_GENERIC			 = &quot;&quot;;</a>
<a name="ln109">const char * const B_MASTER_GAIN		 = &quot;Master&quot;;</a>
<a name="ln110">const char * const B_GAIN				 = &quot;Gain&quot;;</a>
<a name="ln111">const char * const B_BALANCE			 = &quot;Balance&quot;;</a>
<a name="ln112">const char * const B_FREQUENCY			 = &quot;Frequency&quot;;</a>
<a name="ln113">const char * const B_LEVEL				 = &quot;Level&quot;;</a>
<a name="ln114">const char * const B_SHUTTLE_SPEED		 = &quot;Speed&quot;;</a>
<a name="ln115">const char * const B_CROSSFADE			 = &quot;XFade&quot;;</a>
<a name="ln116">const char * const B_EQUALIZATION		 = &quot;EQ&quot;;</a>
<a name="ln117">const char * const B_COMPRESSION		 = &quot;Compression&quot;;</a>
<a name="ln118">const char * const B_QUALITY			 = &quot;Quality&quot;;</a>
<a name="ln119">const char * const B_BITRATE			 = &quot;Bitrate&quot;;</a>
<a name="ln120">const char * const B_GOP_SIZE			 = &quot;GOPSize&quot;;</a>
<a name="ln121">const char * const B_MUTE				 = &quot;Mute&quot;;</a>
<a name="ln122">const char * const B_ENABLE				 = &quot;Enable&quot;;</a>
<a name="ln123">const char * const B_INPUT_MUX			 = &quot;Input&quot;;</a>
<a name="ln124">const char * const B_OUTPUT_MUX			 = &quot;Output&quot;;</a>
<a name="ln125">const char * const B_TUNER_CHANNEL		 = &quot;Channel&quot;;</a>
<a name="ln126">const char * const B_TRACK				 = &quot;Track&quot;;</a>
<a name="ln127">const char * const B_RECSTATE			 = &quot;RecState&quot;;</a>
<a name="ln128">const char * const B_SHUTTLE_MODE		 = &quot;Shuttle&quot;;</a>
<a name="ln129">const char * const B_RESOLUTION			 = &quot;Resolution&quot;;</a>
<a name="ln130">const char * const B_COLOR_SPACE		 = &quot;Colorspace&quot;;</a>
<a name="ln131">const char * const B_FRAME_RATE			 = &quot;FrameRate&quot;;</a>
<a name="ln132">const char * const B_VIDEO_FORMAT		 = &quot;VideoFormat&quot;;</a>
<a name="ln133">const char * const B_WEB_PHYSICAL_INPUT	 = &quot;PhysInput&quot;;</a>
<a name="ln134">const char * const B_WEB_PHYSICAL_OUTPUT = &quot;PhysOutput&quot;;</a>
<a name="ln135">const char * const B_WEB_ADC_CONVERTER	 = &quot;ADC&quot;;</a>
<a name="ln136">const char * const B_WEB_DAC_CONVERTER	 = &quot;DAC&quot;;</a>
<a name="ln137">const char * const B_WEB_LOGICAL_INPUT	 = &quot;LogInput&quot;;</a>
<a name="ln138">const char * const B_WEB_LOGICAL_OUTPUT	 = &quot;LogOutput&quot;;</a>
<a name="ln139">const char * const B_WEB_LOGICAL_BUS	 = &quot;LogBus&quot;;</a>
<a name="ln140">const char * const B_WEB_BUFFER_INPUT	 = &quot;DataInput&quot;;</a>
<a name="ln141">const char * const B_WEB_BUFFER_OUTPUT	 = &quot;DataOutput&quot;;</a>
<a name="ln142">const char * const B_SIMPLE_TRANSPORT	 = &quot;SimpleTransport&quot;;</a>
<a name="ln143"> </a>
<a name="ln144">// Flattened data</a>
<a name="ln145"> </a>
<a name="ln146">static const int32 kCurrentParameterWebVersion = 1;</a>
<a name="ln147">static const uint32 kParameterWebMagic = 0x01030506;</a>
<a name="ln148">static const uint32 kBufferGroupMagic = 0x03040509;</a>
<a name="ln149">static const uint32 kBufferGroupMagicNoFlags = 0x03040507;</a>
<a name="ln150">static const uint32 kParameterMagic = 0x02040607;</a>
<a name="ln151"> </a>
<a name="ln152">static const ssize_t kAdditionalParameterGroupSize = 12;</a>
<a name="ln153">static const ssize_t kAdditionalParameterSize = 23 + 3 * sizeof(ssize_t);</a>
<a name="ln154"> </a>
<a name="ln155">/* BContinuousParameter - FlattenedSize() fixed part</a>
<a name="ln156"> *	Min: 4 bytes (as float)</a>
<a name="ln157"> *	Max: 4 bytes (as float)</a>
<a name="ln158"> *	Stepping: 4 bytes (as float)</a>
<a name="ln159"> *	Response: 4 bytes (as int or enum)</a>
<a name="ln160"> *	Factor: 4 bytes (as float)</a>
<a name="ln161"> *	Offset: 4 bytes (as float)</a>
<a name="ln162"> */</a>
<a name="ln163">static const ssize_t kAdditionalContinuousParameterSize = 5 * sizeof(float)</a>
<a name="ln164">	+ sizeof(BContinuousParameter::response);</a>
<a name="ln165">static const ssize_t kAdditionalDiscreteParameterSize = sizeof(ssize_t);</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">// helper functions</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">template&lt;class Type&gt; Type</a>
<a name="ln172">read_from_buffer(const void **_buffer)</a>
<a name="ln173">{</a>
<a name="ln174">	const Type *typedBuffer = static_cast&lt;const Type *&gt;(*_buffer);</a>
<a name="ln175">	Type value = *typedBuffer;</a>
<a name="ln176"> </a>
<a name="ln177">	typedBuffer++;</a>
<a name="ln178">	*_buffer = static_cast&lt;const void *&gt;(typedBuffer);</a>
<a name="ln179"> </a>
<a name="ln180">	return value;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183"> </a>
<a name="ln184">static status_t</a>
<a name="ln185">read_string_from_buffer(const void **_buffer, char **_string, ssize_t size)</a>
<a name="ln186">{</a>
<a name="ln187">	if (size &lt; 1)</a>
<a name="ln188">		return B_BAD_VALUE;</a>
<a name="ln189"> </a>
<a name="ln190">	const uint8 *buffer = static_cast&lt;const uint8 *&gt;(*_buffer);</a>
<a name="ln191">	uint8 length = *buffer++;</a>
<a name="ln192">	if (length &gt; size - 1)</a>
<a name="ln193">		return B_BAD_VALUE;</a>
<a name="ln194"> </a>
<a name="ln195">	char *string = (char *)malloc(length + 1);</a>
<a name="ln196">	if (string == NULL)</a>
<a name="ln197">		return B_NO_MEMORY;</a>
<a name="ln198"> </a>
<a name="ln199">	memcpy(string, buffer, length);</a>
<a name="ln200">	string[length] = '\0';</a>
<a name="ln201"> </a>
<a name="ln202">	free(*_string);</a>
<a name="ln203"> </a>
<a name="ln204">	*_buffer = static_cast&lt;const void *&gt;(buffer + length);</a>
<a name="ln205">	*_string = string;</a>
<a name="ln206">	return B_OK;</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209"> </a>
<a name="ln210">// currently unused</a>
<a name="ln211">#if 0</a>
<a name="ln212">template&lt;class Type&gt; Type *</a>
<a name="ln213">reserve_in_buffer(void **_buffer)</a>
<a name="ln214">{</a>
<a name="ln215">	Type *typedBuffer = static_cast&lt;Type *&gt;(*_buffer);</a>
<a name="ln216"> </a>
<a name="ln217">	*typedBuffer = 0;</a>
<a name="ln218">	typedBuffer++;</a>
<a name="ln219"> </a>
<a name="ln220">	*_buffer = static_cast&lt;void *&gt;(typedBuffer);</a>
<a name="ln221">}</a>
<a name="ln222">#endif</a>
<a name="ln223"> </a>
<a name="ln224">template&lt;class Type&gt; void</a>
<a name="ln225">write_to_buffer(void **_buffer, Type value)</a>
<a name="ln226">{</a>
<a name="ln227">	Type *typedBuffer = static_cast&lt;Type *&gt;(*_buffer);</a>
<a name="ln228"> </a>
<a name="ln229">	*typedBuffer = value;</a>
<a name="ln230">	typedBuffer++;</a>
<a name="ln231"> </a>
<a name="ln232">	*_buffer = static_cast&lt;void *&gt;(typedBuffer);</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235"> </a>
<a name="ln236">void</a>
<a name="ln237">write_string_to_buffer(void **_buffer, const char *string)</a>
<a name="ln238">{</a>
<a name="ln239">	uint8 *buffer = static_cast&lt;uint8 *&gt;(*_buffer);</a>
<a name="ln240">	uint32 length = string ? strlen(string) : 0;</a>
<a name="ln241">	if (length &gt; 255)</a>
<a name="ln242">		length = 255;</a>
<a name="ln243"> </a>
<a name="ln244">	*buffer++ = static_cast&lt;uint8&gt;(length);</a>
<a name="ln245">	if (length) {</a>
<a name="ln246">		memcpy(buffer, string, length);</a>
<a name="ln247">		buffer += length;</a>
<a name="ln248">	}</a>
<a name="ln249"> </a>
<a name="ln250">	*_buffer = static_cast&lt;void *&gt;(buffer);</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253"> </a>
<a name="ln254">static void</a>
<a name="ln255">skip_in_buffer(const void **_buffer, uint32 bytes)</a>
<a name="ln256">{</a>
<a name="ln257">	const uint8 *buffer = static_cast&lt;const uint8 *&gt;(*_buffer);</a>
<a name="ln258"> </a>
<a name="ln259">	buffer += bytes;</a>
<a name="ln260"> </a>
<a name="ln261">	*_buffer = static_cast&lt;const void *&gt;(buffer);</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">static void inline</a>
<a name="ln266">skip_in_buffer(void **_buffer, uint32 bytes)</a>
<a name="ln267">{</a>
<a name="ln268">	// This actually shouldn't be necessary, but I believe it's a</a>
<a name="ln269">	// bug in Be's gcc - it complains about &quot;adds cv-quals without intervening `const'&quot;</a>
<a name="ln270">	// when passing a &quot;const void **&quot; pointer as the first argument.</a>
<a name="ln271">	// Maybe I am just stupid, though -- axeld.</a>
<a name="ln272"> </a>
<a name="ln273">	skip_in_buffer((const void **)_buffer, bytes);</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276"> </a>
<a name="ln277">template&lt;class Type&gt; Type</a>
<a name="ln278">swap32(Type value, bool doSwap)</a>
<a name="ln279">{</a>
<a name="ln280">	STATIC_ASSERT(sizeof(Type) == 4);</a>
<a name="ln281"> </a>
<a name="ln282">	if (doSwap)</a>
<a name="ln283">		return (Type)B_SWAP_INT32((int32)value);</a>
<a name="ln284"> </a>
<a name="ln285">	return value;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288"> </a>
<a name="ln289">template&lt;class Type&gt; Type</a>
<a name="ln290">swap64(Type value, bool doSwap)</a>
<a name="ln291">{</a>
<a name="ln292">	STATIC_ASSERT(sizeof(Type) == 8);</a>
<a name="ln293"> </a>
<a name="ln294">	if (doSwap)</a>
<a name="ln295">		return (Type)B_SWAP_INT64((int64)value);</a>
<a name="ln296"> </a>
<a name="ln297">	return value;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301">template&lt;class Type&gt; Type</a>
<a name="ln302">read_from_buffer_swap32(const void **_buffer, bool doSwap)</a>
<a name="ln303">{</a>
<a name="ln304">	return swap32&lt;Type&gt;(read_from_buffer&lt;Type&gt;(_buffer), doSwap);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307"> </a>
<a name="ln308">template&lt;class Type&gt; Type</a>
<a name="ln309">read_pointer_from_buffer_swap(const void **_buffer, bool doSwap)</a>
<a name="ln310">{</a>
<a name="ln311">#if B_HAIKU_32_BIT</a>
<a name="ln312">	return swap32&lt;Type&gt;(read_from_buffer&lt;Type&gt;(_buffer), doSwap);</a>
<a name="ln313">#elif B_HAIKU_64_BIT</a>
<a name="ln314">	return swap64&lt;Type&gt;(read_from_buffer&lt;Type&gt;(_buffer), doSwap);</a>
<a name="ln315">#else</a>
<a name="ln316">#	error Interesting</a>
<a name="ln317">#endif</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">static inline ssize_t</a>
<a name="ln322">size_left(ssize_t size, const void *bufferStart, const void *buffer)</a>
<a name="ln323">{</a>
<a name="ln324">	return size - static_cast&lt;ssize_t&gt;((const uint8 *)buffer - (const uint8 *)bufferStart);</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">//	#pragma mark - BParameterWeb</a>
<a name="ln329"> </a>
<a name="ln330"> </a>
<a name="ln331">BParameterWeb::BParameterWeb()</a>
<a name="ln332">	:</a>
<a name="ln333">	fNode(media_node::null)</a>
<a name="ln334">		// fNode is set in BControllable::SetParameterWeb()</a>
<a name="ln335">{</a>
<a name="ln336">	CALLED();</a>
<a name="ln337"> </a>
<a name="ln338">	fGroups = new BList();</a>
<a name="ln339">	fOldRefs = new BList();</a>
<a name="ln340">	fNewRefs = new BList();</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343"> </a>
<a name="ln344">BParameterWeb::~BParameterWeb()</a>
<a name="ln345">{</a>
<a name="ln346">	CALLED();</a>
<a name="ln347"> </a>
<a name="ln348">	for (int32 i = fGroups-&gt;CountItems(); i-- &gt; 0;) {</a>
<a name="ln349">		delete static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(i));</a>
<a name="ln350">	}</a>
<a name="ln351"> </a>
<a name="ln352">	delete fGroups;</a>
<a name="ln353">	delete fOldRefs;</a>
<a name="ln354">	delete fNewRefs;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358">media_node</a>
<a name="ln359">BParameterWeb::Node()</a>
<a name="ln360">{</a>
<a name="ln361">	return fNode;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">BParameterGroup*</a>
<a name="ln366">BParameterWeb::MakeGroup(const char* name)</a>
<a name="ln367">{</a>
<a name="ln368">	CALLED();</a>
<a name="ln369"> </a>
<a name="ln370">	BParameterGroup* group = new(std::nothrow) BParameterGroup(this, name);</a>
<a name="ln371">	if (group == NULL)</a>
<a name="ln372">		return NULL;</a>
<a name="ln373"> </a>
<a name="ln374">	if (!fGroups-&gt;AddItem(group)) {</a>
<a name="ln375">		delete group;</a>
<a name="ln376">		return NULL;</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	return group;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382"> </a>
<a name="ln383">int32</a>
<a name="ln384">BParameterWeb::CountGroups()</a>
<a name="ln385">{</a>
<a name="ln386">	return fGroups-&gt;CountItems();</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">BParameterGroup*</a>
<a name="ln391">BParameterWeb::GroupAt(int32 index)</a>
<a name="ln392">{</a>
<a name="ln393">	return static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(index));</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396"> </a>
<a name="ln397">int32</a>
<a name="ln398">BParameterWeb::CountParameters()</a>
<a name="ln399">{</a>
<a name="ln400">	CALLED();</a>
<a name="ln401"> </a>
<a name="ln402">	// Counts over all groups (and sub-groups) in the web.</a>
<a name="ln403">	// The &quot;groups&quot; list is used as count stack</a>
<a name="ln404"> </a>
<a name="ln405">	BList groups(*fGroups);</a>
<a name="ln406">	int32 count = 0;</a>
<a name="ln407"> </a>
<a name="ln408">	for (int32 i = 0; i &lt; groups.CountItems(); i++) {</a>
<a name="ln409">		BParameterGroup* group</a>
<a name="ln410">			= static_cast&lt;BParameterGroup*&gt;(groups.ItemAt(i));</a>
<a name="ln411"> </a>
<a name="ln412">		count += group-&gt;CountParameters();</a>
<a name="ln413"> </a>
<a name="ln414">		if (group-&gt;fGroups != NULL)</a>
<a name="ln415">			groups.AddList(group-&gt;fGroups);</a>
<a name="ln416">	}</a>
<a name="ln417"> </a>
<a name="ln418">	return count;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">BParameter*</a>
<a name="ln423">BParameterWeb::ParameterAt(int32 index)</a>
<a name="ln424">{</a>
<a name="ln425">	CALLED();</a>
<a name="ln426"> </a>
<a name="ln427">	// Iterates over all groups (and sub-groups) in the web.</a>
<a name="ln428">	// The &quot;groups&quot; list is used as iteration stack (breadth search style)</a>
<a name="ln429">	// Maintains the same order as the Be implementation</a>
<a name="ln430"> </a>
<a name="ln431">	BList groups(*fGroups);</a>
<a name="ln432"> </a>
<a name="ln433">	for (int32 i = 0; i &lt; groups.CountItems(); i++) {</a>
<a name="ln434">		BParameterGroup* group</a>
<a name="ln435">			= static_cast&lt;BParameterGroup*&gt;(groups.ItemAt(i));</a>
<a name="ln436">		int32 count = group-&gt;CountParameters();</a>
<a name="ln437">		if (index &lt; count)</a>
<a name="ln438">			return group-&gt;ParameterAt(index);</a>
<a name="ln439"> </a>
<a name="ln440">		index -= count;</a>
<a name="ln441">			// the index is always relative to the start of the current group</a>
<a name="ln442"> </a>
<a name="ln443">		if (group-&gt;fGroups != NULL)</a>
<a name="ln444">			groups.AddList(group-&gt;fGroups);</a>
<a name="ln445">	}</a>
<a name="ln446"> </a>
<a name="ln447">	TRACE(&quot;*** could not find parameter at %&quot;</a>
<a name="ln448">		B_PRId32 &quot; (count = %&quot; B_PRId32 &quot;)\n&quot;, index, CountParameters());</a>
<a name="ln449"> </a>
<a name="ln450">	return NULL;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453"> </a>
<a name="ln454">bool</a>
<a name="ln455">BParameterWeb::IsFixedSize() const</a>
<a name="ln456">{</a>
<a name="ln457">	return false;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460"> </a>
<a name="ln461">type_code</a>
<a name="ln462">BParameterWeb::TypeCode() const</a>
<a name="ln463">{</a>
<a name="ln464">	return B_MEDIA_PARAMETER_WEB_TYPE;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467"> </a>
<a name="ln468">ssize_t</a>
<a name="ln469">BParameterWeb::FlattenedSize() const</a>
<a name="ln470">{</a>
<a name="ln471">	CALLED();</a>
<a name="ln472"> </a>
<a name="ln473">/*</a>
<a name="ln474">	//--------BEGIN-CORE-BPARAMETERWEB-STRUCT-----------</a>
<a name="ln475">	?? 0x01030506: 4 bytes</a>
<a name="ln476">	??: 4 bytes (is always 1)</a>
<a name="ln477">	Group Count: 4 bytes</a>
<a name="ln478">	Node (as media_node): 0x18 bytes (decimal 24 bytes)</a>
<a name="ln479">		//for each Group BEGIN</a>
<a name="ln480">		Flattened Group Size: 4 bytes</a>
<a name="ln481">		Flattened Group: 'Flattened Group Size' bytes</a>
<a name="ln482">		//for each Group END</a>
<a name="ln483">		//for each Group BEGIN</a>
<a name="ln484">		??: 4 bytes (never get written to (holds uninitialized value))</a>
<a name="ln485">		//for each Group END</a>
<a name="ln486">	//---------END-CORE-BPARAMETERWEB-STRUCT--------------</a>
<a name="ln487">*/</a>
<a name="ln488">	//36 guaranteed bytes, variable after that.</a>
<a name="ln489">	ssize_t size = sizeof(int32) + 2 * sizeof(int32) + sizeof(media_node);</a>
<a name="ln490"> </a>
<a name="ln491">	for (int32 i = fGroups-&gt;CountItems(); i-- &gt; 0;) {</a>
<a name="ln492">		BParameterGroup* group</a>
<a name="ln493">			= static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(i));</a>
<a name="ln494">		if (group != NULL) {</a>
<a name="ln495">			size += sizeof(ssize_t) + group-&gt;FlattenedSize();</a>
<a name="ln496">		}</a>
<a name="ln497">	}</a>
<a name="ln498"> </a>
<a name="ln499">	return size;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">status_t</a>
<a name="ln504">BParameterWeb::Flatten(void* buffer, ssize_t size) const</a>
<a name="ln505">{</a>
<a name="ln506">	CALLED();</a>
<a name="ln507"> </a>
<a name="ln508">	if (buffer == NULL)</a>
<a name="ln509">		return B_NO_INIT;</a>
<a name="ln510"> </a>
<a name="ln511">	ssize_t actualSize = BParameterWeb::FlattenedSize();</a>
<a name="ln512">	if (size &lt; actualSize)</a>
<a name="ln513">		return B_NO_MEMORY;</a>
<a name="ln514"> </a>
<a name="ln515">	void* bufferStart = buffer;</a>
<a name="ln516"> </a>
<a name="ln517">	write_to_buffer&lt;int32&gt;(&amp;buffer, kParameterWebMagic);</a>
<a name="ln518">	write_to_buffer&lt;int32&gt;(&amp;buffer, kCurrentParameterWebVersion);</a>
<a name="ln519"> </a>
<a name="ln520">	// flatten all groups into this buffer</a>
<a name="ln521"> </a>
<a name="ln522">	int32 count = fGroups-&gt;CountItems();</a>
<a name="ln523">	write_to_buffer&lt;int32&gt;(&amp;buffer, count);</a>
<a name="ln524"> </a>
<a name="ln525">	write_to_buffer&lt;media_node&gt;(&amp;buffer, fNode);</a>
<a name="ln526"> </a>
<a name="ln527">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln528">		BParameterGroup* group</a>
<a name="ln529">			= static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(i));</a>
<a name="ln530">		if (group == NULL) {</a>
<a name="ln531">			ERROR(&quot;BParameterWeb::Flatten(): group is NULL\n&quot;);</a>
<a name="ln532">			continue;</a>
<a name="ln533">		}</a>
<a name="ln534"> </a>
<a name="ln535">		ssize_t groupSize = group-&gt;FlattenedSize();</a>
<a name="ln536">		if (groupSize &gt; size_left(size, bufferStart, buffer)) {</a>
<a name="ln537">			ERROR(&quot;BParameterWeb::Flatten(): buffer too small\n&quot;);</a>
<a name="ln538">			return B_BAD_VALUE;</a>
<a name="ln539">		}</a>
<a name="ln540"> </a>
<a name="ln541">		write_to_buffer&lt;ssize_t&gt;(&amp;buffer, groupSize);</a>
<a name="ln542"> </a>
<a name="ln543">		// write the flattened sub group</a>
<a name="ln544">		status_t status = group-&gt;Flatten(buffer, groupSize);</a>
<a name="ln545">		if (status &lt; B_OK)</a>
<a name="ln546">			return status;</a>
<a name="ln547"> </a>
<a name="ln548">		skip_in_buffer(&amp;buffer, groupSize);</a>
<a name="ln549">	}</a>
<a name="ln550"> </a>
<a name="ln551">	return B_OK;</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554"> </a>
<a name="ln555">bool</a>
<a name="ln556">BParameterWeb::AllowsTypeCode(type_code code) const</a>
<a name="ln557">{</a>
<a name="ln558">	return code == TypeCode();</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561"> </a>
<a name="ln562">status_t</a>
<a name="ln563">BParameterWeb::Unflatten(type_code code, const void* buffer, ssize_t size)</a>
<a name="ln564">{</a>
<a name="ln565">	CALLED();</a>
<a name="ln566"> </a>
<a name="ln567">	if (!AllowsTypeCode(code)) {</a>
<a name="ln568">		ERROR(&quot;BParameterWeb::Unflatten(): wrong type code\n&quot;);</a>
<a name="ln569">		return B_BAD_TYPE;</a>
<a name="ln570">	}</a>
<a name="ln571"> </a>
<a name="ln572">	if (buffer == NULL) {</a>
<a name="ln573">		ERROR(&quot;BParameterWeb::Unflatten(): NULL buffer pointer\n&quot;);</a>
<a name="ln574">		return B_NO_INIT;</a>
<a name="ln575">	}</a>
<a name="ln576"> </a>
<a name="ln577">	// if the buffer is smaller than the size needed to read the</a>
<a name="ln578">	// signature field, the mystery field, the group count, and the Node, then there is a problem</a>
<a name="ln579">	if (size &lt; static_cast&lt;ssize_t&gt;(sizeof(int32) + sizeof(int32)</a>
<a name="ln580">			+ sizeof(ssize_t) + sizeof(media_node))) {</a>
<a name="ln581">		ERROR(&quot;BParameterWeb::Unflatten(): size to small\n&quot;);</a>
<a name="ln582">		return B_ERROR;</a>
<a name="ln583">	}</a>
<a name="ln584"> </a>
<a name="ln585">	const void* bufferStart = buffer;</a>
<a name="ln586"> </a>
<a name="ln587">	uint32 magic = read_from_buffer&lt;uint32&gt;(&amp;buffer);</a>
<a name="ln588">	bool isSwapped = false;</a>
<a name="ln589"> </a>
<a name="ln590">	if (magic == B_SWAP_INT32(kParameterWebMagic)) {</a>
<a name="ln591">		isSwapped = true;</a>
<a name="ln592">		magic = B_SWAP_INT32(magic);</a>
<a name="ln593">	}</a>
<a name="ln594">	if (magic != kParameterWebMagic)</a>
<a name="ln595">		return B_BAD_DATA;</a>
<a name="ln596"> </a>
<a name="ln597">	// Note, it's not completely sure that this field is the version</a>
<a name="ln598">	// information - but it doesn't seem to have another purpose</a>
<a name="ln599">	int32 version = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer, isSwapped);</a>
<a name="ln600">	if (version != kCurrentParameterWebVersion) {</a>
<a name="ln601">		ERROR(&quot;BParameterWeb::Unflatten(): wrong version %&quot; B_PRId32 &quot; (%&quot;</a>
<a name="ln602">			B_PRIx32 &quot;)?!\n&quot;, version, version);</a>
<a name="ln603">		return B_ERROR;</a>
<a name="ln604">	}</a>
<a name="ln605"> </a>
<a name="ln606">	for (int32 i = 0; i &lt; fGroups-&gt;CountItems(); i++) {</a>
<a name="ln607">		delete static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(i));</a>
<a name="ln608">	}</a>
<a name="ln609">	fGroups-&gt;MakeEmpty();</a>
<a name="ln610"> </a>
<a name="ln611">	int32 count = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer, isSwapped);</a>
<a name="ln612"> </a>
<a name="ln613">	fNode = read_from_buffer&lt;media_node&gt;(&amp;buffer);</a>
<a name="ln614">	if (isSwapped)</a>
<a name="ln615">		swap_data(B_INT32_TYPE, &amp;fNode, sizeof(media_node), B_SWAP_ALWAYS);</a>
<a name="ln616"> </a>
<a name="ln617">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln618">		ssize_t groupSize</a>
<a name="ln619">			= read_pointer_from_buffer_swap&lt;ssize_t&gt;(&amp;buffer, isSwapped);</a>
<a name="ln620">		if (groupSize &gt; size_left(size, bufferStart, buffer)) {</a>
<a name="ln621">			ERROR(&quot;BParameterWeb::Unflatten(): buffer too small\n&quot;);</a>
<a name="ln622">			return B_BAD_DATA;</a>
<a name="ln623">		}</a>
<a name="ln624"> </a>
<a name="ln625">		BParameterGroup* group = new BParameterGroup(this, &quot;unnamed&quot;);</a>
<a name="ln626">		status_t status = group-&gt;Unflatten(group-&gt;TypeCode(), buffer,</a>
<a name="ln627">			groupSize);</a>
<a name="ln628">		if (status &lt; B_OK) {</a>
<a name="ln629">			ERROR(&quot;BParameterWeb::Unflatten(): unflatten group failed\n&quot;);</a>
<a name="ln630">			delete group;</a>
<a name="ln631">			return status;</a>
<a name="ln632">		}</a>
<a name="ln633"> </a>
<a name="ln634">		skip_in_buffer(&amp;buffer, groupSize);</a>
<a name="ln635"> </a>
<a name="ln636">		fGroups-&gt;AddItem(group);</a>
<a name="ln637">	}</a>
<a name="ln638"> </a>
<a name="ln639">	// fix all references (ParameterAt() style)</a>
<a name="ln640"> </a>
<a name="ln641">	BList groups(*fGroups);</a>
<a name="ln642"> </a>
<a name="ln643">	for (int32 i = 0; i &lt; groups.CountItems(); i++) {</a>
<a name="ln644">		BParameterGroup* group</a>
<a name="ln645">			= static_cast&lt;BParameterGroup*&gt;(groups.ItemAt(i));</a>
<a name="ln646"> </a>
<a name="ln647">		for (int32 index = group-&gt;CountParameters(); index-- &gt; 0;) {</a>
<a name="ln648">			BParameter* parameter</a>
<a name="ln649">				= static_cast&lt;BParameter*&gt;(group-&gt;ParameterAt(index));</a>
<a name="ln650"> </a>
<a name="ln651">			parameter-&gt;FixRefs(*fOldRefs, *fNewRefs);</a>
<a name="ln652">		}</a>
<a name="ln653"> </a>
<a name="ln654">		if (group-&gt;fGroups != NULL)</a>
<a name="ln655">			groups.AddList(group-&gt;fGroups);</a>
<a name="ln656">	}</a>
<a name="ln657"> </a>
<a name="ln658">	fOldRefs-&gt;MakeEmpty();</a>
<a name="ln659">	fNewRefs-&gt;MakeEmpty();</a>
<a name="ln660"> </a>
<a name="ln661">	return B_OK;</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664"> </a>
<a name="ln665">void</a>
<a name="ln666">BParameterWeb::AddRefFix(void* oldItem, void* newItem)</a>
<a name="ln667">{</a>
<a name="ln668">	fOldRefs-&gt;AddItem(oldItem);</a>
<a name="ln669">	fNewRefs-&gt;AddItem(newItem);</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672"> </a>
<a name="ln673">//	#pragma mark - BParameterGroup</a>
<a name="ln674"> </a>
<a name="ln675"> </a>
<a name="ln676">BParameterGroup::BParameterGroup(BParameterWeb* web, const char* name)</a>
<a name="ln677">	:</a>
<a name="ln678">	fWeb(web),</a>
<a name="ln679">	fFlags(0)</a>
<a name="ln680">{</a>
<a name="ln681">	CALLED();</a>
<a name="ln682">	TRACE(&quot;BParameterGroup: web = %p, name = \&quot;%s\&quot;\n&quot;, web, name);</a>
<a name="ln683"> </a>
<a name="ln684">	fName = strndup(name, 255);</a>
<a name="ln685"> </a>
<a name="ln686">	fControls = new BList();</a>
<a name="ln687">	fGroups = new BList();</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">BParameterGroup::~BParameterGroup()</a>
<a name="ln692">{</a>
<a name="ln693">	CALLED();</a>
<a name="ln694"> </a>
<a name="ln695">	for (int i = fControls-&gt;CountItems(); i-- &gt; 0;) {</a>
<a name="ln696">		delete static_cast&lt;BParameter*&gt;(fControls-&gt;ItemAt(i));</a>
<a name="ln697">	}</a>
<a name="ln698">	delete fControls;</a>
<a name="ln699"> </a>
<a name="ln700">	for (int i = fGroups-&gt;CountItems(); i-- &gt; 0;) {</a>
<a name="ln701">		delete static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(i));</a>
<a name="ln702">	}</a>
<a name="ln703">	delete fGroups;</a>
<a name="ln704"> </a>
<a name="ln705">	free(fName);</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">BParameterWeb*</a>
<a name="ln710">BParameterGroup::Web() const</a>
<a name="ln711">{</a>
<a name="ln712">	return fWeb;</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715"> </a>
<a name="ln716">const char*</a>
<a name="ln717">BParameterGroup::Name() const</a>
<a name="ln718">{</a>
<a name="ln719">	return fName;</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">void</a>
<a name="ln724">BParameterGroup::SetFlags(uint32 flags)</a>
<a name="ln725">{</a>
<a name="ln726">	fFlags = flags;</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729"> </a>
<a name="ln730">uint32</a>
<a name="ln731">BParameterGroup::Flags() const</a>
<a name="ln732">{</a>
<a name="ln733">	return fFlags;</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736"> </a>
<a name="ln737">BNullParameter*</a>
<a name="ln738">BParameterGroup::MakeNullParameter(int32 id, media_type mediaType,</a>
<a name="ln739">	const char* name, const char* kind)</a>
<a name="ln740">{</a>
<a name="ln741">	CALLED();</a>
<a name="ln742"> </a>
<a name="ln743">	BNullParameter* parameter = new(std::nothrow) BNullParameter(id, mediaType,</a>
<a name="ln744">		fWeb, name, kind);</a>
<a name="ln745">	if (parameter == NULL)</a>
<a name="ln746">		return NULL;</a>
<a name="ln747"> </a>
<a name="ln748">	parameter-&gt;fGroup = this;</a>
<a name="ln749">	fControls-&gt;AddItem(parameter);</a>
<a name="ln750"> </a>
<a name="ln751">	return parameter;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">BContinuousParameter*</a>
<a name="ln756">BParameterGroup::MakeContinuousParameter(int32 id, media_type mediaType,</a>
<a name="ln757">	const char* name, const char* kind, const char* unit,</a>
<a name="ln758">	float minimum, float maximum, float stepping)</a>
<a name="ln759">{</a>
<a name="ln760">	CALLED();</a>
<a name="ln761"> </a>
<a name="ln762">	BContinuousParameter* parameter</a>
<a name="ln763">		= new(std::nothrow) BContinuousParameter(id, mediaType, fWeb, name,</a>
<a name="ln764">			kind, unit, minimum, maximum, stepping);</a>
<a name="ln765">	if (parameter == NULL)</a>
<a name="ln766">		return NULL;</a>
<a name="ln767"> </a>
<a name="ln768">	parameter-&gt;fGroup = this;</a>
<a name="ln769">	fControls-&gt;AddItem(parameter);</a>
<a name="ln770"> </a>
<a name="ln771">	return parameter;</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774"> </a>
<a name="ln775">BDiscreteParameter*</a>
<a name="ln776">BParameterGroup::MakeDiscreteParameter(int32 id, media_type mediaType,</a>
<a name="ln777">	const char* name, const char* kind)</a>
<a name="ln778">{</a>
<a name="ln779">	CALLED();</a>
<a name="ln780"> </a>
<a name="ln781">	BDiscreteParameter* parameter = new(std::nothrow) BDiscreteParameter(id,</a>
<a name="ln782">		mediaType, fWeb, name, kind);</a>
<a name="ln783">	if (parameter == NULL)</a>
<a name="ln784">		return NULL;</a>
<a name="ln785"> </a>
<a name="ln786">	parameter-&gt;fGroup = this;</a>
<a name="ln787">	fControls-&gt;AddItem(parameter);</a>
<a name="ln788"> </a>
<a name="ln789">	return parameter;</a>
<a name="ln790">}</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">BTextParameter*</a>
<a name="ln794">BParameterGroup::MakeTextParameter(int32 id, media_type mediaType,</a>
<a name="ln795">	const char* name, const char* kind, size_t maxBytes)</a>
<a name="ln796">{</a>
<a name="ln797">	CALLED();</a>
<a name="ln798"> </a>
<a name="ln799">	BTextParameter* parameter = new(std::nothrow) BTextParameter(id, mediaType,</a>
<a name="ln800">		fWeb, name, kind, maxBytes);</a>
<a name="ln801">	if (parameter == NULL)</a>
<a name="ln802">		return NULL;</a>
<a name="ln803"> </a>
<a name="ln804">	parameter-&gt;fGroup = this;</a>
<a name="ln805">	fControls-&gt;AddItem(parameter);</a>
<a name="ln806"> </a>
<a name="ln807">	return parameter;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810"> </a>
<a name="ln811">BParameterGroup*</a>
<a name="ln812">BParameterGroup::MakeGroup(const char* name)</a>
<a name="ln813">{</a>
<a name="ln814">	CALLED();</a>
<a name="ln815"> </a>
<a name="ln816">	BParameterGroup* group = new(std::nothrow) BParameterGroup(fWeb, name);</a>
<a name="ln817">	if (group != NULL)</a>
<a name="ln818">		fGroups-&gt;AddItem(group);</a>
<a name="ln819"> </a>
<a name="ln820">	return group;</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823"> </a>
<a name="ln824">int32</a>
<a name="ln825">BParameterGroup::CountParameters()</a>
<a name="ln826">{</a>
<a name="ln827">	return fControls-&gt;CountItems();</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830"> </a>
<a name="ln831">BParameter*</a>
<a name="ln832">BParameterGroup::ParameterAt(int32 index)</a>
<a name="ln833">{</a>
<a name="ln834">	return static_cast&lt;BParameter*&gt;(fControls-&gt;ItemAt(index));</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837"> </a>
<a name="ln838">int32</a>
<a name="ln839">BParameterGroup::CountGroups()</a>
<a name="ln840">{</a>
<a name="ln841">	return fGroups-&gt;CountItems();</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">BParameterGroup*</a>
<a name="ln846">BParameterGroup::GroupAt(int32 index)</a>
<a name="ln847">{</a>
<a name="ln848">	return static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(index));</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851"> </a>
<a name="ln852">bool</a>
<a name="ln853">BParameterGroup::IsFixedSize() const</a>
<a name="ln854">{</a>
<a name="ln855">	return false;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858"> </a>
<a name="ln859">type_code</a>
<a name="ln860">BParameterGroup::TypeCode() const</a>
<a name="ln861">{</a>
<a name="ln862">	return B_MEDIA_PARAMETER_GROUP_TYPE;</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865"> </a>
<a name="ln866">ssize_t</a>
<a name="ln867">BParameterGroup::FlattenedSize() const</a>
<a name="ln868">{</a>
<a name="ln869">	CALLED();</a>
<a name="ln870"> </a>
<a name="ln871">	/*</a>
<a name="ln872">		//--------BEGIN-CORE-BPARAMETERGROUP-STRUCT-----------</a>
<a name="ln873">		?? (0x03040507 OR 0x03040509 depending if the flags field is included or not???): 4 bytes</a>
<a name="ln874">		(possible) Flags: 4 bytes</a>
<a name="ln875">		Name String Length: 1 byte (??)</a>
<a name="ln876">			Name String: 'Name String Length' bytes</a>
<a name="ln877">		Param Count: 4 bytes</a>
<a name="ln878">			//for each Param BEGIN</a>
<a name="ln879">			Pointer: 4 bytes</a>
<a name="ln880">			Parameter Type: 4 bytes</a>
<a name="ln881">			Flattened Parameter Size: 4 bytes</a>
<a name="ln882">			Flattened Parameter: 'Flattened Parameter Size' bytes</a>
<a name="ln883">			//for each Param END</a>
<a name="ln884">		Subgroup Count: 4 bytes</a>
<a name="ln885">			//for each SubGroup BEGIN</a>
<a name="ln886">			Pointer: 4 bytes</a>
<a name="ln887">			MEDIA PARAMETER GROUP TYPE('BMCG' (opposite byte order in file)): 4 bytes</a>
<a name="ln888">			Flattened Group Size: 4 bytes</a>
<a name="ln889">			Flattened Group: 'Flattened Group Size' bytes</a>
<a name="ln890">			//for each SubGroup END</a>
<a name="ln891"> </a>
<a name="ln892">		//---------END-CORE-BPARAMETERGROUP-STRUCT--------------</a>
<a name="ln893">	*/</a>
<a name="ln894">	//13 guaranteed bytes, variable after that.</a>
<a name="ln895">	ssize_t size = 13;</a>
<a name="ln896"> </a>
<a name="ln897">	if (fFlags != 0)</a>
<a name="ln898">		size += sizeof(uint32);</a>
<a name="ln899"> </a>
<a name="ln900">	if (fName != NULL)</a>
<a name="ln901">		size += min_c(strlen(fName), 255);</a>
<a name="ln902"> </a>
<a name="ln903">	int limit = fControls-&gt;CountItems();</a>
<a name="ln904">	for (int i = 0; i &lt; limit; i++) {</a>
<a name="ln905">		BParameter* parameter = static_cast&lt;BParameter*&gt;(fControls-&gt;ItemAt(i));</a>
<a name="ln906">		if (parameter != NULL) {</a>
<a name="ln907">			// overhead for each parameter flattened</a>
<a name="ln908">			size += sizeof(BParameter*) + sizeof(BParameter::media_parameter_type)</a>
<a name="ln909">				 + sizeof(ssize_t) + parameter-&gt;FlattenedSize();</a>
<a name="ln910">		}</a>
<a name="ln911">	}</a>
<a name="ln912"> </a>
<a name="ln913">	limit = fGroups-&gt;CountItems();</a>
<a name="ln914">	for (int i = 0; i &lt; limit; i++) {</a>
<a name="ln915">		BParameterGroup* group</a>
<a name="ln916">			= static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(i));</a>
<a name="ln917">		if (group != NULL) {</a>
<a name="ln918">			// overhead for each group flattened</a>
<a name="ln919">			size += sizeof(BParameterGroup*) + sizeof(type_code)</a>
<a name="ln920">				+ sizeof(ssize_t) + group-&gt;FlattenedSize();</a>
<a name="ln921">		}</a>
<a name="ln922">	}</a>
<a name="ln923"> </a>
<a name="ln924">	return size;</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927"> </a>
<a name="ln928">status_t</a>
<a name="ln929">BParameterGroup::Flatten(void* buffer, ssize_t size) const</a>
<a name="ln930">{</a>
<a name="ln931">	CALLED();</a>
<a name="ln932"> </a>
<a name="ln933">	if (buffer == NULL) {</a>
<a name="ln934">		ERROR(&quot;BParameterGroup::Flatten buffer is NULL\n&quot;);</a>
<a name="ln935">		return B_NO_INIT;</a>
<a name="ln936">	}</a>
<a name="ln937"> </a>
<a name="ln938">	// NOTICE: It is important that this value is the size returned by</a>
<a name="ln939">	// BParameterGroup::FlattenedSize, not by a descendent's override of this method.</a>
<a name="ln940">	ssize_t actualSize = BParameterGroup::FlattenedSize();</a>
<a name="ln941">	if (size &lt; actualSize) {</a>
<a name="ln942">		ERROR(&quot;BParameterGroup::Flatten size to small\n&quot;);</a>
<a name="ln943">		return B_NO_MEMORY;</a>
<a name="ln944">	}</a>
<a name="ln945"> </a>
<a name="ln946">	if (fFlags != 0) {</a>
<a name="ln947">		write_to_buffer&lt;int32&gt;(&amp;buffer, kBufferGroupMagic);</a>
<a name="ln948">		write_to_buffer&lt;uint32&gt;(&amp;buffer, fFlags);</a>
<a name="ln949">	} else</a>
<a name="ln950">		write_to_buffer&lt;int32&gt;(&amp;buffer, kBufferGroupMagicNoFlags);</a>
<a name="ln951"> </a>
<a name="ln952">	write_string_to_buffer(&amp;buffer, fName);</a>
<a name="ln953"> </a>
<a name="ln954">	int32 count = fControls-&gt;CountItems();</a>
<a name="ln955">	write_to_buffer&lt;int32&gt;(&amp;buffer, count);</a>
<a name="ln956"> </a>
<a name="ln957">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln958">		BParameter* parameter = static_cast&lt;BParameter*&gt;(fControls-&gt;ItemAt(i));</a>
<a name="ln959">		if (parameter == NULL) {</a>
<a name="ln960">			ERROR(&quot;BParameterGroup::Flatten(): NULL parameter\n&quot;);</a>
<a name="ln961">			continue;</a>
<a name="ln962">		}</a>
<a name="ln963"> </a>
<a name="ln964">		write_to_buffer&lt;BParameter*&gt;(&amp;buffer, parameter);</a>
<a name="ln965">		write_to_buffer&lt;BParameter::media_parameter_type&gt;(&amp;buffer,</a>
<a name="ln966">			parameter-&gt;Type());</a>
<a name="ln967"> </a>
<a name="ln968">		// flatten parameter into this buffer</a>
<a name="ln969"> </a>
<a name="ln970">		ssize_t parameterSize = parameter-&gt;FlattenedSize();</a>
<a name="ln971">		write_to_buffer&lt;ssize_t&gt;(&amp;buffer, parameterSize);</a>
<a name="ln972"> </a>
<a name="ln973">		status_t status = parameter-&gt;Flatten(buffer, parameterSize);</a>
<a name="ln974">			// we have only that much bytes left to write in this buffer</a>
<a name="ln975">		if (status &lt; B_OK)</a>
<a name="ln976">			return status;</a>
<a name="ln977"> </a>
<a name="ln978">		skip_in_buffer(&amp;buffer, parameterSize);</a>
<a name="ln979">	}</a>
<a name="ln980"> </a>
<a name="ln981">	count = fGroups-&gt;CountItems();</a>
<a name="ln982">	write_to_buffer&lt;int32&gt;(&amp;buffer, count);</a>
<a name="ln983"> </a>
<a name="ln984">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln985">		BParameterGroup* group</a>
<a name="ln986">			= static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(i));</a>
<a name="ln987">		if (group == NULL) {</a>
<a name="ln988">			ERROR(&quot;BParameterGroup::Flatten(): NULL group\n&quot;);</a>
<a name="ln989">			continue;</a>
<a name="ln990">		}</a>
<a name="ln991"> </a>
<a name="ln992">		write_to_buffer&lt;BParameterGroup*&gt;(&amp;buffer, group);</a>
<a name="ln993">		write_to_buffer&lt;type_code&gt;(&amp;buffer, group-&gt;TypeCode());</a>
<a name="ln994"> </a>
<a name="ln995">		// flatten sub group into this buffer</a>
<a name="ln996"> </a>
<a name="ln997">		ssize_t groupSize = group-&gt;FlattenedSize();</a>
<a name="ln998">		write_to_buffer&lt;ssize_t&gt;(&amp;buffer, groupSize);</a>
<a name="ln999"> </a>
<a name="ln1000">		status_t status = group-&gt;Flatten(buffer, groupSize);</a>
<a name="ln1001">			// we have only that much bytes left to write in this buffer</a>
<a name="ln1002">		if (status &lt; B_OK)</a>
<a name="ln1003">			return status;</a>
<a name="ln1004"> </a>
<a name="ln1005">		skip_in_buffer(&amp;buffer, groupSize);</a>
<a name="ln1006">	}</a>
<a name="ln1007"> </a>
<a name="ln1008">	return B_OK;</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011"> </a>
<a name="ln1012">bool</a>
<a name="ln1013">BParameterGroup::AllowsTypeCode(type_code code) const</a>
<a name="ln1014">{</a>
<a name="ln1015">	return code == TypeCode();</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018"> </a>
<a name="ln1019">status_t</a>
<a name="ln1020">BParameterGroup::Unflatten(type_code code, const void* buffer, ssize_t size)</a>
<a name="ln1021">{</a>
<a name="ln1022">	CALLED();</a>
<a name="ln1023"> </a>
<a name="ln1024">	if (!AllowsTypeCode(code)) {</a>
<a name="ln1025">		ERROR(&quot;BParameterGroup::Unflatten() wrong type code\n&quot;);</a>
<a name="ln1026">		return B_BAD_TYPE;</a>
<a name="ln1027">	}</a>
<a name="ln1028"> </a>
<a name="ln1029">	if (buffer == NULL) {</a>
<a name="ln1030">		ERROR(&quot;BParameterGroup::Unflatten() buffer is NULL\n&quot;);</a>
<a name="ln1031">		return B_NO_INIT;</a>
<a name="ln1032">	}</a>
<a name="ln1033"> </a>
<a name="ln1034">	// if the buffer is smaller than the size needed to read the</a>
<a name="ln1035">	// signature field, then there is a problem</a>
<a name="ln1036">	if (size &lt; static_cast&lt;ssize_t&gt;(sizeof(int32))) {</a>
<a name="ln1037">		ERROR(&quot;BParameterGroup::Unflatten() size to small\n&quot;);</a>
<a name="ln1038">		return B_ERROR;</a>
<a name="ln1039">	}</a>
<a name="ln1040"> </a>
<a name="ln1041">	const void* bufferStart = buffer;</a>
<a name="ln1042">		// used to compute the rest length of the buffer when needed</a>
<a name="ln1043"> </a>
<a name="ln1044">	uint32 magic = read_from_buffer&lt;uint32&gt;(&amp;buffer);</a>
<a name="ln1045">	bool isSwapped = false;</a>
<a name="ln1046"> </a>
<a name="ln1047">	if (magic == B_SWAP_INT32(kBufferGroupMagic)</a>
<a name="ln1048">		|| magic == B_SWAP_INT32(kBufferGroupMagicNoFlags)) {</a>
<a name="ln1049">		isSwapped = true;</a>
<a name="ln1050">		magic = B_SWAP_INT32(magic);</a>
<a name="ln1051">	}</a>
<a name="ln1052"> </a>
<a name="ln1053">	if (magic == kBufferGroupMagic)</a>
<a name="ln1054">		fFlags = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer, isSwapped);</a>
<a name="ln1055">	else if (magic == kBufferGroupMagicNoFlags)</a>
<a name="ln1056">		fFlags = 0;</a>
<a name="ln1057">	else</a>
<a name="ln1058">		return B_BAD_TYPE;</a>
<a name="ln1059"> </a>
<a name="ln1060">	if (read_string_from_buffer(&amp;buffer, &amp;fName,</a>
<a name="ln1061">			size - (ssize_t)((uint8*)buffer - (uint8*)bufferStart)) &lt; B_OK)</a>
<a name="ln1062">		return B_BAD_VALUE;</a>
<a name="ln1063"> </a>
<a name="ln1064">	// Clear all existing parameters/subgroups</a>
<a name="ln1065">	for (int32 i = 0; i &lt; fControls-&gt;CountItems(); i++) {</a>
<a name="ln1066">		delete static_cast&lt;BParameter*&gt;(fControls-&gt;ItemAt(i));</a>
<a name="ln1067">	}</a>
<a name="ln1068">	fControls-&gt;MakeEmpty();</a>
<a name="ln1069"> </a>
<a name="ln1070">	for (int32 i = 0; i &lt; fGroups-&gt;CountItems(); i++) {</a>
<a name="ln1071">		delete static_cast&lt;BParameterGroup*&gt;(fGroups-&gt;ItemAt(i));</a>
<a name="ln1072">	}</a>
<a name="ln1073">	fGroups-&gt;MakeEmpty();</a>
<a name="ln1074"> </a>
<a name="ln1075">	// unflatten parameter list</a>
<a name="ln1076"> </a>
<a name="ln1077">	int32 count = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer, isSwapped);</a>
<a name="ln1078">	if (count &lt; 0 || count * kAdditionalParameterSize</a>
<a name="ln1079">			&gt; size_left(size, bufferStart, buffer))</a>
<a name="ln1080">		return B_BAD_VALUE;</a>
<a name="ln1081"> </a>
<a name="ln1082">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1083">		// make sure we can read as many bytes</a>
<a name="ln1084">		if (size_left(size, bufferStart, buffer) &lt; (ssize_t)(</a>
<a name="ln1085">				sizeof(BParameter*) + sizeof(BParameter::media_parameter_type)</a>
<a name="ln1086">				+ sizeof(ssize_t))) {</a>
<a name="ln1087">			return B_BAD_VALUE;</a>
<a name="ln1088">		}</a>
<a name="ln1089"> </a>
<a name="ln1090">		BParameter* oldPointer = read_pointer_from_buffer_swap&lt;BParameter*&gt;(</a>
<a name="ln1091">			&amp;buffer, isSwapped);</a>
<a name="ln1092">		BParameter::media_parameter_type mediaType</a>
<a name="ln1093">			= read_from_buffer_swap32&lt;BParameter::media_parameter_type&gt;(&amp;buffer,</a>
<a name="ln1094">				isSwapped);</a>
<a name="ln1095"> </a>
<a name="ln1096">		ssize_t parameterSize = read_pointer_from_buffer_swap&lt;ssize_t&gt;(&amp;buffer,</a>
<a name="ln1097">			isSwapped);</a>
<a name="ln1098">		if (parameterSize &gt; size_left(size, bufferStart, buffer))</a>
<a name="ln1099">			return B_BAD_VALUE;</a>
<a name="ln1100"> </a>
<a name="ln1101">		BParameter* parameter = MakeControl(mediaType);</a>
<a name="ln1102">		if (parameter == NULL) {</a>
<a name="ln1103">			ERROR(&quot;BParameterGroup::Unflatten(): MakeControl() failed\n&quot;);</a>
<a name="ln1104">			return B_ERROR;</a>
<a name="ln1105">		}</a>
<a name="ln1106"> </a>
<a name="ln1107">		status_t status = parameter-&gt;Unflatten(parameter-&gt;TypeCode(), buffer,</a>
<a name="ln1108">			parameterSize);</a>
<a name="ln1109">		if (status &lt; B_OK) {</a>
<a name="ln1110">			ERROR(&quot;BParameterGroup::Unflatten(): parameter-&gt;Unflatten() failed\n&quot;);</a>
<a name="ln1111">			delete parameter;</a>
<a name="ln1112">			return status;</a>
<a name="ln1113">		}</a>
<a name="ln1114"> </a>
<a name="ln1115">		skip_in_buffer(&amp;buffer, parameterSize);</a>
<a name="ln1116"> </a>
<a name="ln1117">		// add the item to the list</a>
<a name="ln1118">		parameter-&gt;fGroup = this;</a>
<a name="ln1119">		parameter-&gt;fWeb = fWeb;</a>
<a name="ln1120">		fControls-&gt;AddItem(parameter);</a>
<a name="ln1121"> </a>
<a name="ln1122">		// add it's old pointer value to the RefFix list kept by the owner web</a>
<a name="ln1123">		if (fWeb != NULL)</a>
<a name="ln1124">			fWeb-&gt;AddRefFix(oldPointer, parameter);</a>
<a name="ln1125">	}</a>
<a name="ln1126"> </a>
<a name="ln1127">	// unflatten sub groups</a>
<a name="ln1128"> </a>
<a name="ln1129">	count = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer, isSwapped);</a>
<a name="ln1130">	if (count &lt; 0 || count * kAdditionalParameterGroupSize</a>
<a name="ln1131">			&gt; size_left(size, bufferStart, buffer))</a>
<a name="ln1132">		return B_BAD_VALUE;</a>
<a name="ln1133"> </a>
<a name="ln1134">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1135">		// make sure we can read as many bytes</a>
<a name="ln1136">		if (size_left(size, bufferStart, buffer) &lt; (ssize_t)(</a>
<a name="ln1137">				sizeof(BParameterGroup*) + sizeof(type_code)</a>
<a name="ln1138">				+ sizeof(ssize_t))) {</a>
<a name="ln1139">			return B_BAD_VALUE;</a>
<a name="ln1140">		}</a>
<a name="ln1141"> </a>
<a name="ln1142">		BParameterGroup* oldPointer = read_pointer_from_buffer_swap&lt;</a>
<a name="ln1143">			BParameterGroup*&gt;(&amp;buffer, isSwapped);</a>
<a name="ln1144">		type_code type = read_from_buffer_swap32&lt;type_code&gt;(&amp;buffer, isSwapped);</a>
<a name="ln1145"> </a>
<a name="ln1146">		ssize_t groupSize</a>
<a name="ln1147">			= read_pointer_from_buffer_swap&lt;ssize_t&gt;(&amp;buffer, isSwapped);</a>
<a name="ln1148">		if (groupSize &gt; size_left(size, bufferStart, buffer))</a>
<a name="ln1149">			return B_BAD_VALUE;</a>
<a name="ln1150"> </a>
<a name="ln1151">		BParameterGroup* group = new BParameterGroup(fWeb, &quot;sub-unnamed&quot;);</a>
<a name="ln1152">		if (group == NULL) {</a>
<a name="ln1153">			ERROR(&quot;BParameterGroup::Unflatten(): MakeGroup() failed\n&quot;);</a>
<a name="ln1154">			return B_ERROR;</a>
<a name="ln1155">		}</a>
<a name="ln1156"> </a>
<a name="ln1157">		status_t status = group-&gt;Unflatten(type, buffer, groupSize);</a>
<a name="ln1158">		if (status != B_OK) {</a>
<a name="ln1159">			ERROR(&quot;BParameterGroup::Unflatten(): group-&gt;Unflatten() failed\n&quot;);</a>
<a name="ln1160">			delete group;</a>
<a name="ln1161">			return status;</a>
<a name="ln1162">		}</a>
<a name="ln1163"> </a>
<a name="ln1164">		skip_in_buffer(&amp;buffer, groupSize);</a>
<a name="ln1165"> </a>
<a name="ln1166">		fGroups-&gt;AddItem(group);</a>
<a name="ln1167"> </a>
<a name="ln1168">		// add it's old pointer value to the RefFix list kept by the owner web</a>
<a name="ln1169">		if (fWeb != NULL)</a>
<a name="ln1170">			fWeb-&gt;AddRefFix(oldPointer, group);</a>
<a name="ln1171">	}</a>
<a name="ln1172"> </a>
<a name="ln1173">	return B_OK;</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176"> </a>
<a name="ln1177">/*!	Creates an uninitialized parameter of the specified type.</a>
<a name="ln1178">	Unlike the BParameterGroup::MakeXXXParameter() type of methods, this</a>
<a name="ln1179">	method does not add the parameter to this group automatically.</a>
<a name="ln1180">*/</a>
<a name="ln1181">BParameter*</a>
<a name="ln1182">BParameterGroup::MakeControl(int32 type)</a>
<a name="ln1183">{</a>
<a name="ln1184">	CALLED();</a>
<a name="ln1185"> </a>
<a name="ln1186">	switch (type) {</a>
<a name="ln1187">		case BParameter::B_NULL_PARAMETER:</a>
<a name="ln1188">			return new BNullParameter(-1, B_MEDIA_NO_TYPE, NULL, NULL, NULL);</a>
<a name="ln1189"> </a>
<a name="ln1190">		case BParameter::B_DISCRETE_PARAMETER:</a>
<a name="ln1191">			return new BDiscreteParameter(-1, B_MEDIA_NO_TYPE, NULL, NULL,</a>
<a name="ln1192">				NULL);</a>
<a name="ln1193"> </a>
<a name="ln1194">		case BParameter::B_CONTINUOUS_PARAMETER:</a>
<a name="ln1195">			return new BContinuousParameter(-1, B_MEDIA_NO_TYPE, NULL, NULL,</a>
<a name="ln1196">				NULL, NULL, 0, 0, 0);</a>
<a name="ln1197"> </a>
<a name="ln1198">		case BParameter::B_TEXT_PARAMETER:</a>
<a name="ln1199">			return new BTextParameter(-1, B_MEDIA_NO_TYPE, NULL, NULL, NULL, 0);</a>
<a name="ln1200"> </a>
<a name="ln1201">		default:</a>
<a name="ln1202">			ERROR(&quot;BParameterGroup::MakeControl unknown type %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln1203">				type);</a>
<a name="ln1204">			return NULL;</a>
<a name="ln1205">	}</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208"> </a>
<a name="ln1209">//	#pragma mark - BParameter</a>
<a name="ln1210"> </a>
<a name="ln1211"> </a>
<a name="ln1212">BParameter::media_parameter_type</a>
<a name="ln1213">BParameter::Type() const</a>
<a name="ln1214">{</a>
<a name="ln1215">	return fType;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218"> </a>
<a name="ln1219">BParameterWeb*</a>
<a name="ln1220">BParameter::Web() const</a>
<a name="ln1221">{</a>
<a name="ln1222">	return fWeb;</a>
<a name="ln1223">}</a>
<a name="ln1224"> </a>
<a name="ln1225"> </a>
<a name="ln1226">BParameterGroup*</a>
<a name="ln1227">BParameter::Group() const</a>
<a name="ln1228">{</a>
<a name="ln1229">	return fGroup;</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232"> </a>
<a name="ln1233">const char*</a>
<a name="ln1234">BParameter::Name() const</a>
<a name="ln1235">{</a>
<a name="ln1236">	return fName;</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239"> </a>
<a name="ln1240">const char*</a>
<a name="ln1241">BParameter::Kind() const</a>
<a name="ln1242">{</a>
<a name="ln1243">	return fKind;</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246"> </a>
<a name="ln1247">const char*</a>
<a name="ln1248">BParameter::Unit() const</a>
<a name="ln1249">{</a>
<a name="ln1250">	return fUnit;</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253"> </a>
<a name="ln1254">int32</a>
<a name="ln1255">BParameter::ID() const</a>
<a name="ln1256">{</a>
<a name="ln1257">	return fID;</a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260"> </a>
<a name="ln1261">void</a>
<a name="ln1262">BParameter::SetFlags(uint32 flags)</a>
<a name="ln1263">{</a>
<a name="ln1264">	fFlags = flags;</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267"> </a>
<a name="ln1268">uint32</a>
<a name="ln1269">BParameter::Flags() const</a>
<a name="ln1270">{</a>
<a name="ln1271">	return fFlags;</a>
<a name="ln1272">}</a>
<a name="ln1273"> </a>
<a name="ln1274"> </a>
<a name="ln1275">status_t</a>
<a name="ln1276">BParameter::GetValue(void* buffer, size_t* _size, bigtime_t* _when)</a>
<a name="ln1277">{</a>
<a name="ln1278">	CALLED();</a>
<a name="ln1279"> </a>
<a name="ln1280">	if (buffer == NULL || _size == NULL)</a>
<a name="ln1281">		return B_BAD_VALUE;</a>
<a name="ln1282"> </a>
<a name="ln1283">	size_t size = *_size;</a>
<a name="ln1284">	if (size &lt;= 0)</a>
<a name="ln1285">		return B_NO_MEMORY;</a>
<a name="ln1286"> </a>
<a name="ln1287">	if (fWeb == NULL) {</a>
<a name="ln1288">		ERROR(&quot;BParameter::GetValue: no parent BParameterWeb\n&quot;);</a>
<a name="ln1289">		return B_NO_INIT;</a>
<a name="ln1290">	}</a>
<a name="ln1291"> </a>
<a name="ln1292">	media_node node = fWeb-&gt;Node();</a>
<a name="ln1293">	if (IS_INVALID_NODE(node)) {</a>
<a name="ln1294">		ERROR(&quot;BParameter::GetValue: the parent BParameterWeb is not assigned to a BMediaNode\n&quot;);</a>
<a name="ln1295">		return B_NO_INIT;</a>
<a name="ln1296">	}</a>
<a name="ln1297"> </a>
<a name="ln1298">	controllable_get_parameter_data_request request;</a>
<a name="ln1299">	controllable_get_parameter_data_reply reply;</a>
<a name="ln1300"> </a>
<a name="ln1301">	area_id area;</a>
<a name="ln1302">	void* data;</a>
<a name="ln1303">	if (size &gt; MAX_PARAMETER_DATA) {</a>
<a name="ln1304">		// create an area if large data needs to be transfered</a>
<a name="ln1305">		area = create_area(&quot;get parameter data&quot;, &amp;data, B_ANY_ADDRESS,</a>
<a name="ln1306">			ROUND_UP_TO_PAGE(size), B_NO_LOCK, B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln1307">		if (area &lt; B_OK) {</a>
<a name="ln1308">			ERROR(&quot;BParameter::GetValue can't create area of %ld bytes\n&quot;,</a>
<a name="ln1309">				size);</a>
<a name="ln1310">			return B_NO_MEMORY;</a>
<a name="ln1311">		}</a>
<a name="ln1312">	} else {</a>
<a name="ln1313">		area = -1;</a>
<a name="ln1314">		data = reply.raw_data;</a>
<a name="ln1315">	}</a>
<a name="ln1316"> </a>
<a name="ln1317">	request.parameter_id = fID;</a>
<a name="ln1318">	request.request_size = size;</a>
<a name="ln1319">	request.area = area;</a>
<a name="ln1320"> </a>
<a name="ln1321">	status_t status = QueryPort(node.port, CONTROLLABLE_GET_PARAMETER_DATA,</a>
<a name="ln1322">		&amp;request, sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln1323">	if (status == B_OK) {</a>
<a name="ln1324">		// we don't want to copy more than the buffer provides</a>
<a name="ln1325">		if (reply.size &lt; size)</a>
<a name="ln1326">			size = reply.size;</a>
<a name="ln1327"> </a>
<a name="ln1328">		memcpy(buffer, data, size);</a>
<a name="ln1329"> </a>
<a name="ln1330">		// store reported values</a>
<a name="ln1331"> </a>
<a name="ln1332">		*_size = reply.size;</a>
<a name="ln1333">		if (_when != NULL)</a>
<a name="ln1334">			*_when = reply.last_change;</a>
<a name="ln1335">	} else {</a>
<a name="ln1336">		ERROR(&quot;BParameter::GetValue parameter '%s' querying node %d, &quot;</a>
<a name="ln1337">			&quot;port %d failed: %s\n&quot;,  fName, (int)node.node, (int)node.port,</a>
<a name="ln1338">			strerror(status));</a>
<a name="ln1339">	}</a>
<a name="ln1340"> </a>
<a name="ln1341">	if (area &gt;= B_OK)</a>
<a name="ln1342">		delete_area(area);</a>
<a name="ln1343"> </a>
<a name="ln1344">	return status;</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347"> </a>
<a name="ln1348">status_t</a>
<a name="ln1349">BParameter::SetValue(const void* buffer, size_t size, bigtime_t when)</a>
<a name="ln1350">{</a>
<a name="ln1351">	CALLED();</a>
<a name="ln1352"> </a>
<a name="ln1353">	if (buffer == 0)</a>
<a name="ln1354">		return B_BAD_VALUE;</a>
<a name="ln1355">	if (size &lt;= 0)</a>
<a name="ln1356">		return B_NO_MEMORY;</a>
<a name="ln1357"> </a>
<a name="ln1358">	if (fWeb == 0) {</a>
<a name="ln1359">		ERROR(&quot;BParameter::SetValue: no parent BParameterWeb\n&quot;);</a>
<a name="ln1360">		return B_NO_INIT;</a>
<a name="ln1361">	}</a>
<a name="ln1362"> </a>
<a name="ln1363">	media_node node = fWeb-&gt;Node();</a>
<a name="ln1364">	if (IS_INVALID_NODE(node)) {</a>
<a name="ln1365">		ERROR(&quot;BParameter::SetValue: the parent BParameterWeb is not assigned &quot;</a>
<a name="ln1366">			&quot;to a BMediaNode\n&quot;);</a>
<a name="ln1367">		return B_NO_INIT;</a>
<a name="ln1368">	}</a>
<a name="ln1369"> </a>
<a name="ln1370">	controllable_set_parameter_data_request request;</a>
<a name="ln1371">	controllable_set_parameter_data_reply reply;</a>
<a name="ln1372">	area_id area;</a>
<a name="ln1373">	void* data;</a>
<a name="ln1374"> </a>
<a name="ln1375">	if (size &gt; MAX_PARAMETER_DATA) {</a>
<a name="ln1376">		// create an area if large data needs to be transfered</a>
<a name="ln1377">		area = create_area(&quot;set parameter data&quot;, &amp;data, B_ANY_ADDRESS,</a>
<a name="ln1378">			ROUND_UP_TO_PAGE(size), B_NO_LOCK, B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln1379">		if (area &lt; B_OK) {</a>
<a name="ln1380">			ERROR(&quot;BParameter::SetValue can't create area of %ld bytes\n&quot;, size);</a>
<a name="ln1381">			return B_NO_MEMORY;</a>
<a name="ln1382">		}</a>
<a name="ln1383">	} else {</a>
<a name="ln1384">		area = -1;</a>
<a name="ln1385">		data = request.raw_data;</a>
<a name="ln1386">	}</a>
<a name="ln1387"> </a>
<a name="ln1388">	memcpy(data, buffer, size);</a>
<a name="ln1389">	request.parameter_id = fID;</a>
<a name="ln1390">	request.when = when;</a>
<a name="ln1391">	request.area = area;</a>
<a name="ln1392">	request.size = size;</a>
<a name="ln1393"> </a>
<a name="ln1394">	status_t status = QueryPort(node.port, CONTROLLABLE_SET_PARAMETER_DATA,</a>
<a name="ln1395">		&amp;request, sizeof(request), &amp;reply, sizeof(reply));</a>
<a name="ln1396">	if (status != B_OK) {</a>
<a name="ln1397">		ERROR(&quot;BParameter::SetValue querying node failed: %s\n&quot;,</a>
<a name="ln1398">			strerror(status));</a>
<a name="ln1399">	}</a>
<a name="ln1400"> </a>
<a name="ln1401">	if (area != -1)</a>
<a name="ln1402">		delete_area(area);</a>
<a name="ln1403"> </a>
<a name="ln1404">	return status;</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407"> </a>
<a name="ln1408">int32</a>
<a name="ln1409">BParameter::CountChannels()</a>
<a name="ln1410">{</a>
<a name="ln1411">	return fChannels;</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414"> </a>
<a name="ln1415">void</a>
<a name="ln1416">BParameter::SetChannelCount(int32 count)</a>
<a name="ln1417">{</a>
<a name="ln1418">	fChannels = count;</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421"> </a>
<a name="ln1422">media_type</a>
<a name="ln1423">BParameter::MediaType()</a>
<a name="ln1424">{</a>
<a name="ln1425">	return fMediaType;</a>
<a name="ln1426">}</a>
<a name="ln1427"> </a>
<a name="ln1428"> </a>
<a name="ln1429">void</a>
<a name="ln1430">BParameter::SetMediaType(media_type type)</a>
<a name="ln1431">{</a>
<a name="ln1432">	fMediaType = type;</a>
<a name="ln1433">}</a>
<a name="ln1434"> </a>
<a name="ln1435"> </a>
<a name="ln1436">int32</a>
<a name="ln1437">BParameter::CountInputs()</a>
<a name="ln1438">{</a>
<a name="ln1439">	return fInputs-&gt;CountItems();</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442"> </a>
<a name="ln1443">BParameter*</a>
<a name="ln1444">BParameter::InputAt(int32 index)</a>
<a name="ln1445">{</a>
<a name="ln1446">	return static_cast&lt;BParameter*&gt;(fInputs-&gt;ItemAt(index));</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449"> </a>
<a name="ln1450">void</a>
<a name="ln1451">BParameter::AddInput(BParameter* input)</a>
<a name="ln1452">{</a>
<a name="ln1453">	CALLED();</a>
<a name="ln1454"> </a>
<a name="ln1455">	// BeBook has this method returning a status value,</a>
<a name="ln1456">	// but it should be updated</a>
<a name="ln1457">	if (input == NULL)</a>
<a name="ln1458">		return;</a>
<a name="ln1459"> </a>
<a name="ln1460">	if (fInputs-&gt;HasItem(input)) {</a>
<a name="ln1461">		// if already in input list, don't duplicate.</a>
<a name="ln1462">		return;</a>
<a name="ln1463">	}</a>
<a name="ln1464"> </a>
<a name="ln1465">	fInputs-&gt;AddItem(input);</a>
<a name="ln1466">	input-&gt;AddOutput(this);</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469"> </a>
<a name="ln1470">int32</a>
<a name="ln1471">BParameter::CountOutputs()</a>
<a name="ln1472">{</a>
<a name="ln1473">	return fOutputs-&gt;CountItems();</a>
<a name="ln1474">}</a>
<a name="ln1475"> </a>
<a name="ln1476"> </a>
<a name="ln1477">BParameter*</a>
<a name="ln1478">BParameter::OutputAt(int32 index)</a>
<a name="ln1479">{</a>
<a name="ln1480">	return static_cast&lt;BParameter*&gt;(fOutputs-&gt;ItemAt(index));</a>
<a name="ln1481">}</a>
<a name="ln1482"> </a>
<a name="ln1483"> </a>
<a name="ln1484">void</a>
<a name="ln1485">BParameter::AddOutput(BParameter* output)</a>
<a name="ln1486">{</a>
<a name="ln1487">	CALLED();</a>
<a name="ln1488"> </a>
<a name="ln1489">	// BeBook has this method returning a status value,</a>
<a name="ln1490">	// but it should be updated</a>
<a name="ln1491">	if (output == NULL)</a>
<a name="ln1492">		return;</a>
<a name="ln1493"> </a>
<a name="ln1494">	if (fOutputs-&gt;HasItem(output)) {</a>
<a name="ln1495">		// if already in output list, don't duplicate.</a>
<a name="ln1496">		return;</a>
<a name="ln1497">	}</a>
<a name="ln1498"> </a>
<a name="ln1499">	fOutputs-&gt;AddItem(output);</a>
<a name="ln1500">	output-&gt;AddInput(this);</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503"> </a>
<a name="ln1504">bool</a>
<a name="ln1505">BParameter::IsFixedSize() const</a>
<a name="ln1506">{</a>
<a name="ln1507">	return false;</a>
<a name="ln1508">}</a>
<a name="ln1509"> </a>
<a name="ln1510"> </a>
<a name="ln1511">type_code</a>
<a name="ln1512">BParameter::TypeCode() const</a>
<a name="ln1513">{</a>
<a name="ln1514">	return B_MEDIA_PARAMETER_TYPE;</a>
<a name="ln1515">}</a>
<a name="ln1516"> </a>
<a name="ln1517"> </a>
<a name="ln1518">ssize_t</a>
<a name="ln1519">BParameter::FlattenedSize() const</a>
<a name="ln1520">{</a>
<a name="ln1521">	CALLED();</a>
<a name="ln1522">	/*</a>
<a name="ln1523">		?? (0x02040607): 4 bytes</a>
<a name="ln1524">		BParameter Struct Size (in bytes): 4 bytes</a>
<a name="ln1525">		ID: 4 bytes</a>
<a name="ln1526">		Name String Length: 1 byte (??)</a>
<a name="ln1527">			Name String: 'Name String Length' bytes</a>
<a name="ln1528">		Kind String Length: 1 byte (??)</a>
<a name="ln1529">			Kind String: 'Kind String Length' bytes</a>
<a name="ln1530">		Unit String Length: 1 byte (??)</a>
<a name="ln1531">			Unit String: 'Unit String Length' bytes</a>
<a name="ln1532">		Inputs Count: 4 bytes</a>
<a name="ln1533">			Inputs (pointers): ('Inputs Count')*4 bytes</a>
<a name="ln1534">		Outputs Count: 4 bytes</a>
<a name="ln1535">			Outputs (pointers): ('Outputs Count')*4 bytes</a>
<a name="ln1536">		Media Type: 4 bytes</a>
<a name="ln1537">		ChannelCount: 4 bytes</a>
<a name="ln1538">		Flags: 4 bytes</a>
<a name="ln1539">	*/</a>
<a name="ln1540">	//35 bytes are guaranteed, after that, add the variable length parts.</a>
<a name="ln1541">	ssize_t size = kAdditionalParameterSize;</a>
<a name="ln1542"> </a>
<a name="ln1543">	if (fName != NULL)</a>
<a name="ln1544">		size += strlen(fName);</a>
<a name="ln1545">	if (fKind != NULL)</a>
<a name="ln1546">		size += strlen(fKind);</a>
<a name="ln1547">	if (fUnit != NULL)</a>
<a name="ln1548">		size += strlen(fUnit);</a>
<a name="ln1549"> </a>
<a name="ln1550">	size += fInputs-&gt;CountItems() * sizeof(BParameter*);</a>
<a name="ln1551">	size += fOutputs-&gt;CountItems() * sizeof(BParameter*);</a>
<a name="ln1552"> </a>
<a name="ln1553">	return size;</a>
<a name="ln1554">}</a>
<a name="ln1555"> </a>
<a name="ln1556"> </a>
<a name="ln1557">status_t</a>
<a name="ln1558">BParameter::Flatten(void* buffer, ssize_t size) const</a>
<a name="ln1559">{</a>
<a name="ln1560">	CALLED();</a>
<a name="ln1561"> </a>
<a name="ln1562">	if (buffer == NULL) {</a>
<a name="ln1563">		ERROR(&quot;BParameter::Flatten buffer is NULL\n&quot;);</a>
<a name="ln1564">		return B_NO_INIT;</a>
<a name="ln1565">	}</a>
<a name="ln1566"> </a>
<a name="ln1567">	// NOTICE: It is important that this value is the size returned by</a>
<a name="ln1568">	// BParameter::FlattenedSize(), not by a descendent's override of this method.</a>
<a name="ln1569">	ssize_t actualSize = BParameter::FlattenedSize();</a>
<a name="ln1570">	if (size &lt; actualSize) {</a>
<a name="ln1571">		ERROR(&quot;BParameter::Flatten(): size too small\n&quot;);</a>
<a name="ln1572">		return B_NO_MEMORY;</a>
<a name="ln1573">	}</a>
<a name="ln1574"> </a>
<a name="ln1575">	write_to_buffer&lt;uint32&gt;(&amp;buffer, kParameterMagic);</a>
<a name="ln1576">	write_to_buffer&lt;ssize_t&gt;(&amp;buffer, actualSize);</a>
<a name="ln1577">	write_to_buffer&lt;int32&gt;(&amp;buffer, fID);</a>
<a name="ln1578"> </a>
<a name="ln1579">	write_string_to_buffer(&amp;buffer, fName);</a>
<a name="ln1580">	write_string_to_buffer(&amp;buffer, fKind);</a>
<a name="ln1581">	write_string_to_buffer(&amp;buffer, fUnit);</a>
<a name="ln1582"> </a>
<a name="ln1583">	// flatten and write the list of inputs</a>
<a name="ln1584">	ssize_t count = fInputs-&gt;CountItems();</a>
<a name="ln1585">	write_to_buffer&lt;ssize_t&gt;(&amp;buffer, count);</a>
<a name="ln1586"> </a>
<a name="ln1587">	if (count &gt; 0) {</a>
<a name="ln1588">		memcpy(buffer, fInputs-&gt;Items(), sizeof(BParameter*) * count);</a>
<a name="ln1589">		skip_in_buffer(&amp;buffer, sizeof(BParameter*) * count);</a>
<a name="ln1590">	}</a>
<a name="ln1591"> </a>
<a name="ln1592">	// flatten and write the list of outputs</a>
<a name="ln1593">	count = fOutputs-&gt;CountItems();</a>
<a name="ln1594">	write_to_buffer&lt;ssize_t&gt;(&amp;buffer, count);</a>
<a name="ln1595"> </a>
<a name="ln1596">	if (count &gt; 0) {</a>
<a name="ln1597">		memcpy(buffer, fOutputs-&gt;Items(), sizeof(BParameter*) * count);</a>
<a name="ln1598">		skip_in_buffer(&amp;buffer, sizeof(BParameter*) * count);</a>
<a name="ln1599">	}</a>
<a name="ln1600"> </a>
<a name="ln1601">	write_to_buffer&lt;media_type&gt;(&amp;buffer, fMediaType);</a>
<a name="ln1602">	write_to_buffer&lt;int32&gt;(&amp;buffer, fChannels);</a>
<a name="ln1603">	write_to_buffer&lt;uint32&gt;(&amp;buffer, fFlags);</a>
<a name="ln1604"> </a>
<a name="ln1605">	return B_OK;</a>
<a name="ln1606">}</a>
<a name="ln1607"> </a>
<a name="ln1608"> </a>
<a name="ln1609">bool</a>
<a name="ln1610">BParameter::AllowsTypeCode(type_code code) const</a>
<a name="ln1611">{</a>
<a name="ln1612">	return code == TypeCode();</a>
<a name="ln1613">}</a>
<a name="ln1614"> </a>
<a name="ln1615"> </a>
<a name="ln1616">status_t</a>
<a name="ln1617">BParameter::Unflatten(type_code code, const void* buffer, ssize_t size)</a>
<a name="ln1618">{</a>
<a name="ln1619">	CALLED();</a>
<a name="ln1620"> </a>
<a name="ln1621">	if (!AllowsTypeCode(code)) {</a>
<a name="ln1622">		ERROR(&quot;BParameter::Unflatten(): wrong type code\n&quot;);</a>
<a name="ln1623">		return B_BAD_TYPE;</a>
<a name="ln1624">	}</a>
<a name="ln1625"> </a>
<a name="ln1626">	if (buffer == NULL) {</a>
<a name="ln1627">		ERROR(&quot;BParameter::Unflatten(): buffer is NULL\n&quot;);</a>
<a name="ln1628">		return B_NO_INIT;</a>
<a name="ln1629">	}</a>
<a name="ln1630"> </a>
<a name="ln1631">	// if the buffer is smaller than the size needed to read the</a>
<a name="ln1632">	// signature and struct size fields, then there is a problem</a>
<a name="ln1633">	if (size &lt; static_cast&lt;ssize_t&gt;(sizeof(int32) + sizeof(ssize_t))) {</a>
<a name="ln1634">		ERROR(&quot;BParameter::Unflatten() size too small\n&quot;);</a>
<a name="ln1635">		return B_BAD_VALUE;</a>
<a name="ln1636">	}</a>
<a name="ln1637"> </a>
<a name="ln1638">	const void* bufferStart = buffer;</a>
<a name="ln1639"> </a>
<a name="ln1640">	// check magic</a>
<a name="ln1641"> </a>
<a name="ln1642">	uint32 magic = read_from_buffer&lt;uint32&gt;(&amp;buffer);</a>
<a name="ln1643">	if (magic == B_SWAP_INT32(kParameterMagic))</a>
<a name="ln1644">		fSwapDetected = true;</a>
<a name="ln1645">	else if (magic == kParameterMagic)</a>
<a name="ln1646">		fSwapDetected = false;</a>
<a name="ln1647">	else {</a>
<a name="ln1648">		ERROR(&quot;BParameter::Unflatten(): bad magic\n&quot;);</a>
<a name="ln1649">		return B_BAD_TYPE;</a>
<a name="ln1650">	}</a>
<a name="ln1651"> </a>
<a name="ln1652">	ssize_t parameterSize = read_pointer_from_buffer_swap&lt;ssize_t&gt;(&amp;buffer,</a>
<a name="ln1653">		fSwapDetected);</a>
<a name="ln1654">	if (parameterSize &gt; size) {</a>
<a name="ln1655">		ERROR(&quot;BParameter::Unflatten(): buffer too small (%ld &gt; %ld)\n&quot;,</a>
<a name="ln1656">			parameterSize, size);</a>
<a name="ln1657">		return B_BAD_VALUE;</a>
<a name="ln1658">	}</a>
<a name="ln1659"> </a>
<a name="ln1660">	// if the struct doesn't meet the minimum size for</a>
<a name="ln1661">	// a flattened BParameter, then return an error.</a>
<a name="ln1662">	// MinFlattenedParamSize =</a>
<a name="ln1663">	// ID (4 bytes)</a>
<a name="ln1664">	// Name String Length (1 byte)</a>
<a name="ln1665">	// Kind String Length (1 byte)</a>
<a name="ln1666">	// Unit String Length (1 byte)</a>
<a name="ln1667">	// Inputs Count (4 bytes)</a>
<a name="ln1668">	// Outputs Count (4 bytes)</a>
<a name="ln1669">	// Media Type (4 bytes)</a>
<a name="ln1670">	// Channel Count (4 bytes)</a>
<a name="ln1671">	// Flags (4 bytes)</a>
<a name="ln1672">	// TOTAL: 27 bytes</a>
<a name="ln1673">	const ssize_t kMinFlattenedParamSize = 15 + 3 * sizeof(ssize_t);</a>
<a name="ln1674">	if (parameterSize &lt; kMinFlattenedParamSize) {</a>
<a name="ln1675">		ERROR(&quot;BParameter::Unflatten out of memory (2)\n&quot;);</a>
<a name="ln1676">		return B_ERROR;</a>
<a name="ln1677">	}</a>
<a name="ln1678"> </a>
<a name="ln1679">	fID = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer, fSwapDetected);</a>
<a name="ln1680"> </a>
<a name="ln1681">	if (read_string_from_buffer(&amp;buffer, &amp;fName,</a>
<a name="ln1682">				size_left(size, bufferStart, buffer)) &lt; B_OK</a>
<a name="ln1683">		|| read_string_from_buffer(&amp;buffer, &amp;fKind,</a>
<a name="ln1684">				size_left(size, bufferStart, buffer)) &lt; B_OK</a>
<a name="ln1685">		|| read_string_from_buffer(&amp;buffer, &amp;fUnit,</a>
<a name="ln1686">				size_left(size, bufferStart, buffer)) &lt; B_OK)</a>
<a name="ln1687">		return B_NO_MEMORY;</a>
<a name="ln1688"> </a>
<a name="ln1689">	// read the list of inputs</a>
<a name="ln1690"> </a>
<a name="ln1691">	// it will directly add the pointers in the flattened message to the list;</a>
<a name="ln1692">	// these will be fixed to point to the real inputs/outputs later in FixRefs()</a>
<a name="ln1693"> </a>
<a name="ln1694">	ssize_t count = read_pointer_from_buffer_swap&lt;ssize_t&gt;(&amp;buffer,</a>
<a name="ln1695">		fSwapDetected);</a>
<a name="ln1696"> </a>
<a name="ln1697">	fInputs-&gt;MakeEmpty();</a>
<a name="ln1698">	for (ssize_t i = 0; i &lt; count; i++) {</a>
<a name="ln1699">		fInputs-&gt;AddItem(read_pointer_from_buffer_swap&lt;BParameter * const&gt;(</a>
<a name="ln1700">			&amp;buffer, fSwapDetected));</a>
<a name="ln1701">	}</a>
<a name="ln1702"> </a>
<a name="ln1703">	// read the list of outputs</a>
<a name="ln1704"> </a>
<a name="ln1705">	count = read_pointer_from_buffer_swap&lt;ssize_t&gt;(&amp;buffer, fSwapDetected);</a>
<a name="ln1706"> </a>
<a name="ln1707">	fOutputs-&gt;MakeEmpty();</a>
<a name="ln1708">	for (ssize_t i = 0; i &lt; count; i++) {</a>
<a name="ln1709">		fOutputs-&gt;AddItem(read_pointer_from_buffer_swap&lt;BParameter * const&gt;(</a>
<a name="ln1710">			&amp;buffer, fSwapDetected));</a>
<a name="ln1711">	}</a>
<a name="ln1712"> </a>
<a name="ln1713">	fMediaType = read_from_buffer_swap32&lt;media_type&gt;(&amp;buffer, fSwapDetected);</a>
<a name="ln1714">	fChannels = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer, fSwapDetected);</a>
<a name="ln1715">	fFlags = read_from_buffer_swap32&lt;uint32&gt;(&amp;buffer, fSwapDetected);</a>
<a name="ln1716"> </a>
<a name="ln1717">	return B_OK;</a>
<a name="ln1718">}</a>
<a name="ln1719"> </a>
<a name="ln1720"> </a>
<a name="ln1721">BParameter::BParameter(int32 id, media_type mediaType,</a>
<a name="ln1722">		media_parameter_type type, BParameterWeb* web, const char* name,</a>
<a name="ln1723">		const char* kind, const char* unit)</a>
<a name="ln1724">	:</a>
<a name="ln1725">	fID(id),</a>
<a name="ln1726">	fType(type),</a>
<a name="ln1727">	fWeb(web),</a>
<a name="ln1728">	fGroup(NULL),</a>
<a name="ln1729">	fSwapDetected(true),</a>
<a name="ln1730">	fMediaType(mediaType),</a>
<a name="ln1731">	fChannels(1),</a>
<a name="ln1732">	fFlags(0)</a>
<a name="ln1733">{</a>
<a name="ln1734">	CALLED();</a>
<a name="ln1735"> </a>
<a name="ln1736">	fName = strndup(name, 255);</a>
<a name="ln1737">	fKind = strndup(kind, 255);</a>
<a name="ln1738">	fUnit = strndup(unit, 255);</a>
<a name="ln1739"> </a>
<a name="ln1740">	// create empty input/output lists</a>
<a name="ln1741">	fInputs = new BList();</a>
<a name="ln1742">	fOutputs = new BList();</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745"> </a>
<a name="ln1746">BParameter::~BParameter()</a>
<a name="ln1747">{</a>
<a name="ln1748">	CALLED();</a>
<a name="ln1749"> </a>
<a name="ln1750">	// don't worry about the fWeb/fGroup properties, you don't need</a>
<a name="ln1751">	// to remove yourself from a web/group since the only way in which</a>
<a name="ln1752">	// a parameter is destroyed is when the owner web/group destroys it</a>
<a name="ln1753"> </a>
<a name="ln1754">	free(fName);</a>
<a name="ln1755">	free(fKind);</a>
<a name="ln1756">	free(fUnit);</a>
<a name="ln1757"> </a>
<a name="ln1758">	delete fInputs;</a>
<a name="ln1759">	delete fOutputs;</a>
<a name="ln1760">}</a>
<a name="ln1761"> </a>
<a name="ln1762"> </a>
<a name="ln1763">/*!	Replaces references to items in the old list with the corresponding</a>
<a name="ln1764">	items in the updated list. The references are replaced in the input</a>
<a name="ln1765">	and output lists.</a>
<a name="ln1766">	This is called by BParameterWeb::Unflatten().</a>
<a name="ln1767">*/</a>
<a name="ln1768">void</a>
<a name="ln1769">BParameter::FixRefs(BList&amp; old, BList&amp; updated)</a>
<a name="ln1770">{</a>
<a name="ln1771">	CALLED();</a>
<a name="ln1772"> </a>
<a name="ln1773">	// update inputs</a>
<a name="ln1774"> </a>
<a name="ln1775">	void** items = static_cast&lt;void**&gt;(fInputs-&gt;Items());</a>
<a name="ln1776">	int32 count = fInputs-&gt;CountItems();</a>
<a name="ln1777"> </a>
<a name="ln1778">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1779">		int32 index = old.IndexOf(items[i]);</a>
<a name="ln1780">		if (index &gt;= 0)</a>
<a name="ln1781">			items[i] = updated.ItemAt(index);</a>
<a name="ln1782">		else {</a>
<a name="ln1783">			ERROR(&quot;BParameter::FixRefs(): No mapping found for input&quot;);</a>
<a name="ln1784">			items[i] = NULL;</a>
<a name="ln1785">		}</a>
<a name="ln1786">	}</a>
<a name="ln1787"> </a>
<a name="ln1788">	// remove all NULL inputs (those which couldn't be mapped)</a>
<a name="ln1789"> </a>
<a name="ln1790">	for (int32 i = count; i-- &gt; 0;) {</a>
<a name="ln1791">		if (items[i] == NULL)</a>
<a name="ln1792">			fInputs-&gt;RemoveItem(i);</a>
<a name="ln1793">	}</a>
<a name="ln1794"> </a>
<a name="ln1795">	// update outputs</a>
<a name="ln1796"> </a>
<a name="ln1797">	items = static_cast&lt;void **&gt;(fOutputs-&gt;Items());</a>
<a name="ln1798">	count = fOutputs-&gt;CountItems();</a>
<a name="ln1799"> </a>
<a name="ln1800">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1801">		int32 index = old.IndexOf(items[i]);</a>
<a name="ln1802">		if (index &gt;= 0)</a>
<a name="ln1803">			items[i] = updated.ItemAt(index);</a>
<a name="ln1804">		else {</a>
<a name="ln1805">			ERROR(&quot;BParameter::FixRefs(): No mapping found for output&quot;);</a>
<a name="ln1806">			items[i] = NULL;</a>
<a name="ln1807">		}</a>
<a name="ln1808">	}</a>
<a name="ln1809"> </a>
<a name="ln1810">	// remove all NULL outputs (those which couldn't be mapped)</a>
<a name="ln1811"> </a>
<a name="ln1812">	for (int32 i = count; i-- &gt; 0;) {</a>
<a name="ln1813">		if (items[i] == NULL)</a>
<a name="ln1814">			fOutputs-&gt;RemoveItem(i);</a>
<a name="ln1815">	}</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818"> </a>
<a name="ln1819">//	#pragma mark - public BContinuousParameter</a>
<a name="ln1820"> </a>
<a name="ln1821"> </a>
<a name="ln1822">type_code</a>
<a name="ln1823">BContinuousParameter::ValueType()</a>
<a name="ln1824">{</a>
<a name="ln1825">	return B_FLOAT_TYPE;</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828"> </a>
<a name="ln1829">float</a>
<a name="ln1830">BContinuousParameter::MinValue()</a>
<a name="ln1831">{</a>
<a name="ln1832">	return fMinimum;</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835"> </a>
<a name="ln1836">float</a>
<a name="ln1837">BContinuousParameter::MaxValue()</a>
<a name="ln1838">{</a>
<a name="ln1839">	return fMaximum;</a>
<a name="ln1840">}</a>
<a name="ln1841"> </a>
<a name="ln1842"> </a>
<a name="ln1843">float</a>
<a name="ln1844">BContinuousParameter::ValueStep()</a>
<a name="ln1845">{</a>
<a name="ln1846">	return fStepping;</a>
<a name="ln1847">}</a>
<a name="ln1848"> </a>
<a name="ln1849"> </a>
<a name="ln1850">void</a>
<a name="ln1851">BContinuousParameter::SetResponse(int resp, float factor, float offset)</a>
<a name="ln1852">{</a>
<a name="ln1853">	fResponse = static_cast&lt;response&gt;(resp);</a>
<a name="ln1854">	fFactor = factor;</a>
<a name="ln1855">	fOffset = offset;</a>
<a name="ln1856">}</a>
<a name="ln1857"> </a>
<a name="ln1858"> </a>
<a name="ln1859">void</a>
<a name="ln1860">BContinuousParameter::GetResponse(int* _resp, float* _factor, float* _offset)</a>
<a name="ln1861">{</a>
<a name="ln1862">	if (_resp != NULL)</a>
<a name="ln1863">		*_resp = fResponse;</a>
<a name="ln1864">	if (_factor != NULL)</a>
<a name="ln1865">		*_factor = fFactor;</a>
<a name="ln1866">	if (_offset != NULL)</a>
<a name="ln1867">		*_offset = fOffset;</a>
<a name="ln1868">}</a>
<a name="ln1869"> </a>
<a name="ln1870"> </a>
<a name="ln1871">ssize_t</a>
<a name="ln1872">BContinuousParameter::FlattenedSize() const</a>
<a name="ln1873">{</a>
<a name="ln1874">	CALLED();</a>
<a name="ln1875"> </a>
<a name="ln1876">	// only adds a fixed amount of bytes</a>
<a name="ln1877">	return BParameter::FlattenedSize() + kAdditionalContinuousParameterSize;</a>
<a name="ln1878">}</a>
<a name="ln1879"> </a>
<a name="ln1880"> </a>
<a name="ln1881">status_t</a>
<a name="ln1882">BContinuousParameter::Flatten(void* buffer, ssize_t size) const</a>
<a name="ln1883">{</a>
<a name="ln1884">	CALLED();</a>
<a name="ln1885"> </a>
<a name="ln1886">	if (buffer == NULL) {</a>
<a name="ln1887">		ERROR(&quot;BContinuousParameter::Flatten(): buffer is NULL\n&quot;);</a>
<a name="ln1888">		return B_NO_INIT;</a>
<a name="ln1889">	}</a>
<a name="ln1890"> </a>
<a name="ln1891">	ssize_t parameterSize = BParameter::FlattenedSize();</a>
<a name="ln1892">	if (size &lt; (parameterSize + kAdditionalContinuousParameterSize)) {</a>
<a name="ln1893">		ERROR(&quot;BContinuousParameter::Flatten(): size to small\n&quot;);</a>
<a name="ln1894">		return B_NO_MEMORY;</a>
<a name="ln1895">	}</a>
<a name="ln1896"> </a>
<a name="ln1897">	status_t status = BParameter::Flatten(buffer, size);</a>
<a name="ln1898">	if (status != B_OK) {</a>
<a name="ln1899">		ERROR(&quot;BContinuousParameter::Flatten(): BParameter::Flatten() failed\n&quot;);</a>
<a name="ln1900">		return status;</a>
<a name="ln1901">	}</a>
<a name="ln1902"> </a>
<a name="ln1903">	// add our data to the general flattened BParameter</a>
<a name="ln1904"> </a>
<a name="ln1905">	skip_in_buffer(&amp;buffer, parameterSize);</a>
<a name="ln1906"> </a>
<a name="ln1907">	write_to_buffer&lt;float&gt;(&amp;buffer, fMinimum);</a>
<a name="ln1908">	write_to_buffer&lt;float&gt;(&amp;buffer, fMaximum);</a>
<a name="ln1909">	write_to_buffer&lt;float&gt;(&amp;buffer, fStepping);</a>
<a name="ln1910">	write_to_buffer&lt;response&gt;(&amp;buffer, fResponse);</a>
<a name="ln1911">	write_to_buffer&lt;float&gt;(&amp;buffer, fFactor);</a>
<a name="ln1912">	write_to_buffer&lt;float&gt;(&amp;buffer, fOffset);</a>
<a name="ln1913"> </a>
<a name="ln1914">	return B_OK;</a>
<a name="ln1915">}</a>
<a name="ln1916"> </a>
<a name="ln1917"> </a>
<a name="ln1918">status_t</a>
<a name="ln1919">BContinuousParameter::Unflatten(type_code code, const void* buffer,</a>
<a name="ln1920">	ssize_t size)</a>
<a name="ln1921">{</a>
<a name="ln1922">	CALLED();</a>
<a name="ln1923"> </a>
<a name="ln1924">	// we try to check if the buffer size is long enough to hold an object</a>
<a name="ln1925">	// as early as possible.</a>
<a name="ln1926"> </a>
<a name="ln1927">	if (!AllowsTypeCode(code)) {</a>
<a name="ln1928">		ERROR(&quot;BContinuousParameter::Unflatten wrong type code\n&quot;);</a>
<a name="ln1929">		return B_BAD_TYPE;</a>
<a name="ln1930">	}</a>
<a name="ln1931"> </a>
<a name="ln1932">	if (buffer == NULL) {</a>
<a name="ln1933">		ERROR(&quot;BContinuousParameter::Unflatten buffer is NULL\n&quot;);</a>
<a name="ln1934">		return B_NO_INIT;</a>
<a name="ln1935">	}</a>
<a name="ln1936"> </a>
<a name="ln1937">	// if the buffer is smaller than the size needed to read the</a>
<a name="ln1938">	// signature and struct size fields, then there is a problem</a>
<a name="ln1939">	if (size &lt; static_cast&lt;ssize_t&gt;(sizeof(int32) + sizeof(ssize_t))) {</a>
<a name="ln1940">		ERROR(&quot;BContinuousParameter::Unflatten size too small\n&quot;);</a>
<a name="ln1941">		return B_ERROR;</a>
<a name="ln1942">	}</a>
<a name="ln1943"> </a>
<a name="ln1944">	status_t status = BParameter::Unflatten(code, buffer, size);</a>
<a name="ln1945">	if (status != B_OK) {</a>
<a name="ln1946">		ERROR(&quot;BContinuousParameter::Unflatten(): BParameter::Unflatten &quot;</a>
<a name="ln1947">			&quot;failed: %s\n&quot;, strerror(status));</a>
<a name="ln1948">		return status;</a>
<a name="ln1949">	}</a>
<a name="ln1950"> </a>
<a name="ln1951">	ssize_t parameterSize = BParameter::FlattenedSize();</a>
<a name="ln1952">	skip_in_buffer(&amp;buffer, parameterSize);</a>
<a name="ln1953"> </a>
<a name="ln1954">	if (size &lt; (parameterSize + kAdditionalContinuousParameterSize)) {</a>
<a name="ln1955">		ERROR(&quot;BContinuousParameter::Unflatten(): buffer too small\n&quot;);</a>
<a name="ln1956">		return B_BAD_VALUE;</a>
<a name="ln1957">	}</a>
<a name="ln1958"> </a>
<a name="ln1959">	fMinimum = read_from_buffer_swap32&lt;float&gt;(&amp;buffer, SwapOnUnflatten());</a>
<a name="ln1960">	fMaximum = read_from_buffer_swap32&lt;float&gt;(&amp;buffer, SwapOnUnflatten());</a>
<a name="ln1961">	fStepping = read_from_buffer_swap32&lt;float&gt;(&amp;buffer, SwapOnUnflatten());</a>
<a name="ln1962">	fResponse = read_from_buffer_swap32&lt;response&gt;(&amp;buffer, SwapOnUnflatten());</a>
<a name="ln1963">	fFactor = read_from_buffer_swap32&lt;float&gt;(&amp;buffer, SwapOnUnflatten());</a>
<a name="ln1964">	fOffset = read_from_buffer_swap32&lt;float&gt;(&amp;buffer, SwapOnUnflatten());</a>
<a name="ln1965"> </a>
<a name="ln1966">	return B_OK;</a>
<a name="ln1967">}</a>
<a name="ln1968"> </a>
<a name="ln1969"> </a>
<a name="ln1970">BContinuousParameter::BContinuousParameter(int32 id, media_type mediaType,</a>
<a name="ln1971">		BParameterWeb* web, const char* name, const char* kind,</a>
<a name="ln1972">		const char* unit, float minimum, float maximum, float stepping)</a>
<a name="ln1973">	: BParameter(id, mediaType, B_CONTINUOUS_PARAMETER, web, name, kind, unit),</a>
<a name="ln1974">	fMinimum(minimum),</a>
<a name="ln1975">	fMaximum(maximum),</a>
<a name="ln1976">	fStepping(stepping),</a>
<a name="ln1977">	fResponse(B_LINEAR),</a>
<a name="ln1978">	fFactor(1.0),</a>
<a name="ln1979">	fOffset(0.0)</a>
<a name="ln1980">{</a>
<a name="ln1981">	CALLED();</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984"> </a>
<a name="ln1985">BContinuousParameter::~BContinuousParameter()</a>
<a name="ln1986">{</a>
<a name="ln1987">	CALLED();</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990"> </a>
<a name="ln1991">//	#pragma mark - public BDiscreteParameter</a>
<a name="ln1992"> </a>
<a name="ln1993"> </a>
<a name="ln1994">type_code</a>
<a name="ln1995">BDiscreteParameter::ValueType()</a>
<a name="ln1996">{</a>
<a name="ln1997">	return B_INT32_TYPE;</a>
<a name="ln1998">}</a>
<a name="ln1999"> </a>
<a name="ln2000"> </a>
<a name="ln2001">int32</a>
<a name="ln2002">BDiscreteParameter::CountItems()</a>
<a name="ln2003">{</a>
<a name="ln2004">	return fValues-&gt;CountItems();</a>
<a name="ln2005">}</a>
<a name="ln2006"> </a>
<a name="ln2007"> </a>
<a name="ln2008">const char*</a>
<a name="ln2009">BDiscreteParameter::ItemNameAt(int32 index)</a>
<a name="ln2010">{</a>
<a name="ln2011">	return reinterpret_cast&lt;const char*&gt;(fSelections-&gt;ItemAt(index));</a>
<a name="ln2012">}</a>
<a name="ln2013"> </a>
<a name="ln2014"> </a>
<a name="ln2015">int32</a>
<a name="ln2016">BDiscreteParameter::ItemValueAt(int32 index)</a>
<a name="ln2017">{</a>
<a name="ln2018">	int32* item = static_cast&lt;int32*&gt;(fValues-&gt;ItemAt(index));</a>
<a name="ln2019">	if (item == NULL)</a>
<a name="ln2020">		return 0;</a>
<a name="ln2021"> </a>
<a name="ln2022">	return *item;</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025"> </a>
<a name="ln2026">status_t</a>
<a name="ln2027">BDiscreteParameter::AddItem(int32 value, const char* name)</a>
<a name="ln2028">{</a>
<a name="ln2029">	CALLED();</a>
<a name="ln2030"> </a>
<a name="ln2031">	int32* valueCopy = new(std::nothrow) int32(value);</a>
<a name="ln2032">	if (valueCopy == NULL)</a>
<a name="ln2033">		return B_NO_MEMORY;</a>
<a name="ln2034">	char* nameCopy = strndup(name, 255);</a>
<a name="ln2035">	if (name != NULL &amp;&amp; nameCopy == NULL) {</a>
<a name="ln2036">		delete valueCopy;</a>
<a name="ln2037">		return B_NO_MEMORY;</a>
<a name="ln2038">	}</a>
<a name="ln2039"> </a>
<a name="ln2040">	if (!fValues-&gt;AddItem(valueCopy))</a>
<a name="ln2041">		goto err;</a>
<a name="ln2042">	if (!fSelections-&gt;AddItem(nameCopy)) {</a>
<a name="ln2043">		fValues-&gt;RemoveItem(valueCopy);</a>
<a name="ln2044">		goto err;</a>
<a name="ln2045">	}</a>
<a name="ln2046">	return B_OK;</a>
<a name="ln2047"> </a>
<a name="ln2048">err:</a>
<a name="ln2049">	free(nameCopy);</a>
<a name="ln2050">	delete valueCopy;</a>
<a name="ln2051">	return B_NO_MEMORY;</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054"> </a>
<a name="ln2055">status_t</a>
<a name="ln2056">BDiscreteParameter::MakeItemsFromInputs()</a>
<a name="ln2057">{</a>
<a name="ln2058">	CALLED();</a>
<a name="ln2059"> </a>
<a name="ln2060">	int32 count = fInputs-&gt;CountItems();</a>
<a name="ln2061">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2062">		BParameter* parameter = static_cast&lt;BParameter*&gt;(fInputs-&gt;ItemAt(i));</a>
<a name="ln2063">		AddItem(i, parameter-&gt;Name());</a>
<a name="ln2064">	}</a>
<a name="ln2065"> </a>
<a name="ln2066">	return B_OK;</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069"> </a>
<a name="ln2070">status_t</a>
<a name="ln2071">BDiscreteParameter::MakeItemsFromOutputs()</a>
<a name="ln2072">{</a>
<a name="ln2073">	CALLED();</a>
<a name="ln2074"> </a>
<a name="ln2075">	int32 count = fOutputs-&gt;CountItems();</a>
<a name="ln2076">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2077">		BParameter* parameter = static_cast&lt;BParameter*&gt;(fOutputs-&gt;ItemAt(i));</a>
<a name="ln2078">		AddItem(i, parameter-&gt;Name());</a>
<a name="ln2079">	}</a>
<a name="ln2080"> </a>
<a name="ln2081">	return B_OK;</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084"> </a>
<a name="ln2085">void</a>
<a name="ln2086">BDiscreteParameter::MakeEmpty()</a>
<a name="ln2087">{</a>
<a name="ln2088">	CALLED();</a>
<a name="ln2089"> </a>
<a name="ln2090">	for (int32 i = fValues-&gt;CountItems(); i-- &gt; 0;) {</a>
<a name="ln2091">		delete static_cast&lt;int32*&gt;(fValues-&gt;ItemAt(i));</a>
<a name="ln2092">	}</a>
<a name="ln2093">	fValues-&gt;MakeEmpty();</a>
<a name="ln2094"> </a>
<a name="ln2095">	for (int32 i = fSelections-&gt;CountItems(); i-- &gt; 0;) {</a>
<a name="ln2096">		free(static_cast&lt;char*&gt;(fSelections-&gt;ItemAt(i)));</a>
<a name="ln2097">	}</a>
<a name="ln2098">	fSelections-&gt;MakeEmpty();</a>
<a name="ln2099">}</a>
<a name="ln2100"> </a>
<a name="ln2101"> </a>
<a name="ln2102">ssize_t</a>
<a name="ln2103">BDiscreteParameter::FlattenedSize() const</a>
<a name="ln2104">{</a>
<a name="ln2105">	CALLED();</a>
<a name="ln2106"> </a>
<a name="ln2107">	ssize_t size = BParameter::FlattenedSize()</a>
<a name="ln2108">		+ kAdditionalDiscreteParameterSize;</a>
<a name="ln2109"> </a>
<a name="ln2110">	int32 count = fValues-&gt;CountItems();</a>
<a name="ln2111">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2112">		char* selection = static_cast&lt;char*&gt;(fSelections-&gt;ItemAt(i));</a>
<a name="ln2113"> </a>
<a name="ln2114">		if (selection != NULL)</a>
<a name="ln2115">			size += min_c(strlen(selection), 255);</a>
<a name="ln2116"> </a>
<a name="ln2117">		size += 5;</a>
<a name="ln2118">			// string length + value</a>
<a name="ln2119">	}</a>
<a name="ln2120"> </a>
<a name="ln2121">	return size;</a>
<a name="ln2122">}</a>
<a name="ln2123"> </a>
<a name="ln2124"> </a>
<a name="ln2125">status_t</a>
<a name="ln2126">BDiscreteParameter::Flatten(void* buffer, ssize_t size) const</a>
<a name="ln2127">{</a>
<a name="ln2128">	CALLED();</a>
<a name="ln2129"> </a>
<a name="ln2130">	if (buffer == NULL) {</a>
<a name="ln2131">		ERROR(&quot;BDiscreteParameter::Flatten(): buffer is NULL\n&quot;);</a>
<a name="ln2132">		return B_NO_INIT;</a>
<a name="ln2133">	}</a>
<a name="ln2134"> </a>
<a name="ln2135">	ssize_t parameterSize = BParameter::FlattenedSize();</a>
<a name="ln2136"> </a>
<a name="ln2137">	if (size &lt; FlattenedSize()) {</a>
<a name="ln2138">		ERROR(&quot;BDiscreteParameter::Flatten(): size too small\n&quot;);</a>
<a name="ln2139">		return B_NO_MEMORY;</a>
<a name="ln2140">	}</a>
<a name="ln2141"> </a>
<a name="ln2142">	status_t status = BParameter::Flatten(buffer, size);</a>
<a name="ln2143">	if (status != B_OK) {</a>
<a name="ln2144">		ERROR(&quot;BDiscreteParameter::Flatten(): BParameter::Flatten failed\n&quot;);</a>
<a name="ln2145">		return status;</a>
<a name="ln2146">	}</a>
<a name="ln2147"> </a>
<a name="ln2148">	skip_in_buffer(&amp;buffer, parameterSize);</a>
<a name="ln2149"> </a>
<a name="ln2150">	int32 count = fValues-&gt;CountItems();</a>
<a name="ln2151">	write_to_buffer&lt;int32&gt;(&amp;buffer, count);</a>
<a name="ln2152"> </a>
<a name="ln2153">	// write out all value/name pairs</a>
<a name="ln2154">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2155">		const char* selection = static_cast&lt;char*&gt;(fSelections-&gt;ItemAt(i));</a>
<a name="ln2156">		const int32* value = static_cast&lt;int32*&gt;(fValues-&gt;ItemAt(i));</a>
<a name="ln2157"> </a>
<a name="ln2158">		write_string_to_buffer(&amp;buffer, selection);</a>
<a name="ln2159">		write_to_buffer&lt;int32&gt;(&amp;buffer, value ? *value : 0);</a>
<a name="ln2160">	}</a>
<a name="ln2161"> </a>
<a name="ln2162">	return B_OK;</a>
<a name="ln2163">}</a>
<a name="ln2164"> </a>
<a name="ln2165"> </a>
<a name="ln2166">status_t</a>
<a name="ln2167">BDiscreteParameter::Unflatten(type_code code, const void* buffer, ssize_t size)</a>
<a name="ln2168">{</a>
<a name="ln2169">	CALLED();</a>
<a name="ln2170"> </a>
<a name="ln2171">	if (!AllowsTypeCode(code)) {</a>
<a name="ln2172">		ERROR(&quot;BDiscreteParameter::Unflatten(): bad type code\n&quot;);</a>
<a name="ln2173">		return B_BAD_TYPE;</a>
<a name="ln2174">	}</a>
<a name="ln2175"> </a>
<a name="ln2176">	if (buffer == NULL) {</a>
<a name="ln2177">		ERROR(&quot;BDiscreteParameter::Unflatten(): buffer is NULL\n&quot;);</a>
<a name="ln2178">		return B_NO_INIT;</a>
<a name="ln2179">	}</a>
<a name="ln2180"> </a>
<a name="ln2181">	// if the buffer is smaller than the size needed to read the</a>
<a name="ln2182">	// signature and struct size fields, then there is a problem</a>
<a name="ln2183">	if (size &lt; static_cast&lt;ssize_t&gt;(sizeof(int32) + sizeof(ssize_t))) {</a>
<a name="ln2184">		ERROR(&quot;BDiscreteParameter::Unflatten(): size too small\n&quot;);</a>
<a name="ln2185">		return B_ERROR;</a>
<a name="ln2186">	}</a>
<a name="ln2187"> </a>
<a name="ln2188">	const void* bufferStart = buffer;</a>
<a name="ln2189"> </a>
<a name="ln2190">	status_t status = BParameter::Unflatten(code, buffer, size);</a>
<a name="ln2191">	if (status != B_OK) {</a>
<a name="ln2192">		ERROR(&quot;BDiscreteParameter::Unflatten(): BParameter::Unflatten failed\n&quot;);</a>
<a name="ln2193">		return status;</a>
<a name="ln2194">	}</a>
<a name="ln2195"> </a>
<a name="ln2196">	ssize_t parameterSize = BParameter::FlattenedSize();</a>
<a name="ln2197">	skip_in_buffer(&amp;buffer, parameterSize);</a>
<a name="ln2198"> </a>
<a name="ln2199">	if (size &lt; (parameterSize + kAdditionalDiscreteParameterSize)) {</a>
<a name="ln2200">		ERROR(&quot;BDiscreteParameter::Unflatten(): buffer too small\n&quot;);</a>
<a name="ln2201">		return B_BAD_VALUE;</a>
<a name="ln2202">	}</a>
<a name="ln2203"> </a>
<a name="ln2204">	int32 count = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer, SwapOnUnflatten());</a>
<a name="ln2205"> </a>
<a name="ln2206">	// clear any existing name/value pairs</a>
<a name="ln2207">	MakeEmpty();</a>
<a name="ln2208"> </a>
<a name="ln2209">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2210">		char* name = NULL;</a>
<a name="ln2211">		if (read_string_from_buffer(&amp;buffer, &amp;name, size_left(size, bufferStart,</a>
<a name="ln2212">				buffer)) &lt; B_OK)</a>
<a name="ln2213">			return B_BAD_DATA;</a>
<a name="ln2214"> </a>
<a name="ln2215">		if (size_left(size, bufferStart, buffer) &lt; (int)sizeof(int32)) {</a>
<a name="ln2216">			free(name);</a>
<a name="ln2217">			return B_BAD_DATA;</a>
<a name="ln2218">		}</a>
<a name="ln2219"> </a>
<a name="ln2220">		int32 value = read_from_buffer_swap32&lt;int32&gt;(&amp;buffer,</a>
<a name="ln2221">			SwapOnUnflatten());</a>
<a name="ln2222"> </a>
<a name="ln2223">		AddItem(value, name);</a>
<a name="ln2224">		free(name);</a>
<a name="ln2225">	}</a>
<a name="ln2226"> </a>
<a name="ln2227">	return B_OK;</a>
<a name="ln2228">}</a>
<a name="ln2229"> </a>
<a name="ln2230"> </a>
<a name="ln2231">BDiscreteParameter::BDiscreteParameter(int32 id, media_type mediaType,</a>
<a name="ln2232">	BParameterWeb* web, const char* name, const char* kind)</a>
<a name="ln2233">	:	BParameter(id, mediaType, B_DISCRETE_PARAMETER, web, name, kind, NULL)</a>
<a name="ln2234">{</a>
<a name="ln2235">	CALLED();</a>
<a name="ln2236"> </a>
<a name="ln2237">	fSelections = new BList();</a>
<a name="ln2238">	fValues = new BList();</a>
<a name="ln2239">}</a>
<a name="ln2240"> </a>
<a name="ln2241"> </a>
<a name="ln2242">BDiscreteParameter::~BDiscreteParameter()</a>
<a name="ln2243">{</a>
<a name="ln2244">	CALLED();</a>
<a name="ln2245"> </a>
<a name="ln2246">	MakeEmpty();</a>
<a name="ln2247"> </a>
<a name="ln2248">	delete fSelections;</a>
<a name="ln2249">	delete fValues;</a>
<a name="ln2250">}</a>
<a name="ln2251"> </a>
<a name="ln2252"> </a>
<a name="ln2253">//	#pragma mark - public BTextParameter</a>
<a name="ln2254"> </a>
<a name="ln2255"> </a>
<a name="ln2256">size_t</a>
<a name="ln2257">BTextParameter::MaxBytes() const</a>
<a name="ln2258">{</a>
<a name="ln2259">	return fMaxBytes;</a>
<a name="ln2260">}</a>
<a name="ln2261"> </a>
<a name="ln2262"> </a>
<a name="ln2263">type_code</a>
<a name="ln2264">BTextParameter::ValueType()</a>
<a name="ln2265">{</a>
<a name="ln2266">	return B_FLOAT_TYPE;</a>
<a name="ln2267">}</a>
<a name="ln2268"> </a>
<a name="ln2269"> </a>
<a name="ln2270">ssize_t</a>
<a name="ln2271">BTextParameter::FlattenedSize() const</a>
<a name="ln2272">{</a>
<a name="ln2273">	return BParameter::FlattenedSize() + sizeof(fMaxBytes);</a>
<a name="ln2274">}</a>
<a name="ln2275"> </a>
<a name="ln2276"> </a>
<a name="ln2277">status_t</a>
<a name="ln2278">BTextParameter::Flatten(void* buffer, ssize_t size) const</a>
<a name="ln2279">{</a>
<a name="ln2280">	if (buffer == NULL) {</a>
<a name="ln2281">		ERROR(&quot;BTextParameter::Flatten(): buffer is NULL\n&quot;);</a>
<a name="ln2282">		return B_NO_INIT;</a>
<a name="ln2283">	}</a>
<a name="ln2284"> </a>
<a name="ln2285">	ssize_t parameterSize = BParameter::FlattenedSize();</a>
<a name="ln2286">	if (size &lt; static_cast&lt;ssize_t&gt;(parameterSize + sizeof(fMaxBytes))) {</a>
<a name="ln2287">		ERROR(&quot;BContinuousParameter::Flatten(): size to small\n&quot;);</a>
<a name="ln2288">		return B_NO_MEMORY;</a>
<a name="ln2289">	}</a>
<a name="ln2290"> </a>
<a name="ln2291">	status_t status = BParameter::Flatten(buffer, size);</a>
<a name="ln2292">	if (status != B_OK) {</a>
<a name="ln2293">		ERROR(&quot;BTextParameter::Flatten(): BParameter::Flatten() failed\n&quot;);</a>
<a name="ln2294">		return status;</a>
<a name="ln2295">	}</a>
<a name="ln2296"> </a>
<a name="ln2297">	// add our data to the general flattened BParameter</a>
<a name="ln2298"> </a>
<a name="ln2299">	skip_in_buffer(&amp;buffer, parameterSize);</a>
<a name="ln2300"> </a>
<a name="ln2301">	write_to_buffer&lt;uint32&gt;(&amp;buffer, fMaxBytes);</a>
<a name="ln2302"> </a>
<a name="ln2303">	return B_OK;</a>
<a name="ln2304">}</a>
<a name="ln2305"> </a>
<a name="ln2306"> </a>
<a name="ln2307">status_t</a>
<a name="ln2308">BTextParameter::Unflatten(type_code code, const void* buffer, ssize_t size)</a>
<a name="ln2309">{</a>
<a name="ln2310">	// we try to check if the buffer size is long enough to hold an object</a>
<a name="ln2311">	// as early as possible.</a>
<a name="ln2312"> </a>
<a name="ln2313">	if (!AllowsTypeCode(code)) {</a>
<a name="ln2314">		ERROR(&quot;BTextParameter::Unflatten wrong type code\n&quot;);</a>
<a name="ln2315">		return B_BAD_TYPE;</a>
<a name="ln2316">	}</a>
<a name="ln2317"> </a>
<a name="ln2318">	if (buffer == NULL) {</a>
<a name="ln2319">		ERROR(&quot;BTextParameter::Unflatten buffer is NULL\n&quot;);</a>
<a name="ln2320">		return B_NO_INIT;</a>
<a name="ln2321">	}</a>
<a name="ln2322"> </a>
<a name="ln2323">	if (size &lt; static_cast&lt;ssize_t&gt;(sizeof(fMaxBytes))) {</a>
<a name="ln2324">		ERROR(&quot;BTextParameter::Unflatten size too small\n&quot;);</a>
<a name="ln2325">		return B_ERROR;</a>
<a name="ln2326">	}</a>
<a name="ln2327"> </a>
<a name="ln2328">	status_t status = BParameter::Unflatten(code, buffer, size);</a>
<a name="ln2329">	if (status != B_OK) {</a>
<a name="ln2330">		ERROR(&quot;BTextParameter::Unflatten(): BParameter::Unflatten failed\n&quot;);</a>
<a name="ln2331">		return status;</a>
<a name="ln2332">	}</a>
<a name="ln2333"> </a>
<a name="ln2334">	ssize_t parameterSize = BParameter::FlattenedSize();</a>
<a name="ln2335">	skip_in_buffer(&amp;buffer, parameterSize);</a>
<a name="ln2336"> </a>
<a name="ln2337">	if (size &lt; static_cast&lt;ssize_t&gt;(parameterSize + sizeof(fMaxBytes))) {</a>
<a name="ln2338">		ERROR(&quot;BTextParameter::Unflatten(): buffer too small\n&quot;);</a>
<a name="ln2339">		return B_BAD_VALUE;</a>
<a name="ln2340">	}</a>
<a name="ln2341"> </a>
<a name="ln2342">	fMaxBytes = read_from_buffer_swap32&lt;uint32&gt;(&amp;buffer, SwapOnUnflatten());</a>
<a name="ln2343"> </a>
<a name="ln2344">	return B_OK;</a>
<a name="ln2345">}</a>
<a name="ln2346"> </a>
<a name="ln2347"> </a>
<a name="ln2348">BTextParameter::BTextParameter(int32 id, media_type mediaType,</a>
<a name="ln2349">		BParameterWeb* web, const char* name, const char* kind,</a>
<a name="ln2350">		size_t maxBytes)</a>
<a name="ln2351">	: BParameter(id, mediaType, B_TEXT_PARAMETER, web, name, kind, NULL)</a>
<a name="ln2352">{</a>
<a name="ln2353">	fMaxBytes = maxBytes;</a>
<a name="ln2354">}</a>
<a name="ln2355"> </a>
<a name="ln2356"> </a>
<a name="ln2357">BTextParameter::~BTextParameter()</a>
<a name="ln2358">{</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361"> </a>
<a name="ln2362">//	#pragma mark - public BNullParameter</a>
<a name="ln2363"> </a>
<a name="ln2364"> </a>
<a name="ln2365">type_code</a>
<a name="ln2366">BNullParameter::ValueType()</a>
<a name="ln2367">{</a>
<a name="ln2368">	// NULL parameters have no value type</a>
<a name="ln2369">	return 0;</a>
<a name="ln2370">}</a>
<a name="ln2371"> </a>
<a name="ln2372"> </a>
<a name="ln2373">ssize_t</a>
<a name="ln2374">BNullParameter::FlattenedSize() const</a>
<a name="ln2375">{</a>
<a name="ln2376">	return BParameter::FlattenedSize();</a>
<a name="ln2377">}</a>
<a name="ln2378"> </a>
<a name="ln2379"> </a>
<a name="ln2380">status_t</a>
<a name="ln2381">BNullParameter::Flatten(void* buffer, ssize_t size) const</a>
<a name="ln2382">{</a>
<a name="ln2383">	return BParameter::Flatten(buffer, size);</a>
<a name="ln2384">}</a>
<a name="ln2385"> </a>
<a name="ln2386"> </a>
<a name="ln2387">status_t</a>
<a name="ln2388">BNullParameter::Unflatten(type_code code, const void* buffer, ssize_t size)</a>
<a name="ln2389">{</a>
<a name="ln2390">	return BParameter::Unflatten(code, buffer, size);</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393"> </a>
<a name="ln2394">BNullParameter::BNullParameter(int32 id, media_type mediaType,</a>
<a name="ln2395">		BParameterWeb* web, const char* name, const char* kind)</a>
<a name="ln2396">	: BParameter(id, mediaType, B_NULL_PARAMETER, web, name, kind, NULL)</a>
<a name="ln2397">{</a>
<a name="ln2398">}</a>
<a name="ln2399"> </a>
<a name="ln2400"> </a>
<a name="ln2401">BNullParameter::~BNullParameter()</a>
<a name="ln2402">{</a>
<a name="ln2403">}</a>
<a name="ln2404"> </a>
<a name="ln2405"> </a>
<a name="ln2406">//	#pragma mark - reserved functions</a>
<a name="ln2407"> </a>
<a name="ln2408"> </a>
<a name="ln2409">status_t BParameterWeb::_Reserved_ControlWeb_0(void *) { return B_ERROR; }</a>
<a name="ln2410">status_t BParameterWeb::_Reserved_ControlWeb_1(void *) { return B_ERROR; }</a>
<a name="ln2411">status_t BParameterWeb::_Reserved_ControlWeb_2(void *) { return B_ERROR; }</a>
<a name="ln2412">status_t BParameterWeb::_Reserved_ControlWeb_3(void *) { return B_ERROR; }</a>
<a name="ln2413">status_t BParameterWeb::_Reserved_ControlWeb_4(void *) { return B_ERROR; }</a>
<a name="ln2414">status_t BParameterWeb::_Reserved_ControlWeb_5(void *) { return B_ERROR; }</a>
<a name="ln2415">status_t BParameterWeb::_Reserved_ControlWeb_6(void *) { return B_ERROR; }</a>
<a name="ln2416">status_t BParameterWeb::_Reserved_ControlWeb_7(void *) { return B_ERROR; }</a>
<a name="ln2417"> </a>
<a name="ln2418">status_t BParameterGroup::_Reserved_ControlGroup_0(void *) { return B_ERROR; }</a>
<a name="ln2419">status_t BParameterGroup::_Reserved_ControlGroup_1(void *) { return B_ERROR; }</a>
<a name="ln2420">status_t BParameterGroup::_Reserved_ControlGroup_2(void *) { return B_ERROR; }</a>
<a name="ln2421">status_t BParameterGroup::_Reserved_ControlGroup_3(void *) { return B_ERROR; }</a>
<a name="ln2422">status_t BParameterGroup::_Reserved_ControlGroup_4(void *) { return B_ERROR; }</a>
<a name="ln2423">status_t BParameterGroup::_Reserved_ControlGroup_5(void *) { return B_ERROR; }</a>
<a name="ln2424">status_t BParameterGroup::_Reserved_ControlGroup_6(void *) { return B_ERROR; }</a>
<a name="ln2425">status_t BParameterGroup::_Reserved_ControlGroup_7(void *) { return B_ERROR; }</a>
<a name="ln2426"> </a>
<a name="ln2427">status_t BParameter::_Reserved_Control_0(void *) { return B_ERROR; }</a>
<a name="ln2428">status_t BParameter::_Reserved_Control_1(void *) { return B_ERROR; }</a>
<a name="ln2429">status_t BParameter::_Reserved_Control_2(void *) { return B_ERROR; }</a>
<a name="ln2430">status_t BParameter::_Reserved_Control_3(void *) { return B_ERROR; }</a>
<a name="ln2431">status_t BParameter::_Reserved_Control_4(void *) { return B_ERROR; }</a>
<a name="ln2432">status_t BParameter::_Reserved_Control_5(void *) { return B_ERROR; }</a>
<a name="ln2433">status_t BParameter::_Reserved_Control_6(void *) { return B_ERROR; }</a>
<a name="ln2434">status_t BParameter::_Reserved_Control_7(void *) { return B_ERROR; }</a>
<a name="ln2435"> </a>
<a name="ln2436">status_t BContinuousParameter::_Reserved_ContinuousParameter_0(void *) { return B_ERROR; }</a>
<a name="ln2437">status_t BContinuousParameter::_Reserved_ContinuousParameter_1(void *) { return B_ERROR; }</a>
<a name="ln2438">status_t BContinuousParameter::_Reserved_ContinuousParameter_2(void *) { return B_ERROR; }</a>
<a name="ln2439">status_t BContinuousParameter::_Reserved_ContinuousParameter_3(void *) { return B_ERROR; }</a>
<a name="ln2440">status_t BContinuousParameter::_Reserved_ContinuousParameter_4(void *) { return B_ERROR; }</a>
<a name="ln2441">status_t BContinuousParameter::_Reserved_ContinuousParameter_5(void *) { return B_ERROR; }</a>
<a name="ln2442">status_t BContinuousParameter::_Reserved_ContinuousParameter_6(void *) { return B_ERROR; }</a>
<a name="ln2443">status_t BContinuousParameter::_Reserved_ContinuousParameter_7(void *) { return B_ERROR; }</a>
<a name="ln2444"> </a>
<a name="ln2445">status_t BDiscreteParameter::_Reserved_DiscreteParameter_0(void *) { return B_ERROR; }</a>
<a name="ln2446">status_t BDiscreteParameter::_Reserved_DiscreteParameter_1(void *) { return B_ERROR; }</a>
<a name="ln2447">status_t BDiscreteParameter::_Reserved_DiscreteParameter_2(void *) { return B_ERROR; }</a>
<a name="ln2448">status_t BDiscreteParameter::_Reserved_DiscreteParameter_3(void *) { return B_ERROR; }</a>
<a name="ln2449">status_t BDiscreteParameter::_Reserved_DiscreteParameter_4(void *) { return B_ERROR; }</a>
<a name="ln2450">status_t BDiscreteParameter::_Reserved_DiscreteParameter_5(void *) { return B_ERROR; }</a>
<a name="ln2451">status_t BDiscreteParameter::_Reserved_DiscreteParameter_6(void *) { return B_ERROR; }</a>
<a name="ln2452">status_t BDiscreteParameter::_Reserved_DiscreteParameter_7(void *) { return B_ERROR; }</a>
<a name="ln2453"> </a>
<a name="ln2454">status_t BNullParameter::_Reserved_NullParameter_0(void *) { return B_ERROR; }</a>
<a name="ln2455">status_t BNullParameter::_Reserved_NullParameter_1(void *) { return B_ERROR; }</a>
<a name="ln2456">status_t BNullParameter::_Reserved_NullParameter_2(void *) { return B_ERROR; }</a>
<a name="ln2457">status_t BNullParameter::_Reserved_NullParameter_3(void *) { return B_ERROR; }</a>
<a name="ln2458">status_t BNullParameter::_Reserved_NullParameter_4(void *) { return B_ERROR; }</a>
<a name="ln2459">status_t BNullParameter::_Reserved_NullParameter_5(void *) { return B_ERROR; }</a>
<a name="ln2460">status_t BNullParameter::_Reserved_NullParameter_6(void *) { return B_ERROR; }</a>
<a name="ln2461">status_t BNullParameter::_Reserved_NullParameter_7(void *) { return B_ERROR; }</a>
<a name="ln2462"> </a>
<a name="ln2463">status_t BTextParameter::_Reserved_TextParameter_0(void *) { return B_ERROR; }</a>
<a name="ln2464">status_t BTextParameter::_Reserved_TextParameter_1(void *) { return B_ERROR; }</a>
<a name="ln2465">status_t BTextParameter::_Reserved_TextParameter_2(void *) { return B_ERROR; }</a>
<a name="ln2466">status_t BTextParameter::_Reserved_TextParameter_3(void *) { return B_ERROR; }</a>
<a name="ln2467">status_t BTextParameter::_Reserved_TextParameter_4(void *) { return B_ERROR; }</a>
<a name="ln2468">status_t BTextParameter::_Reserved_TextParameter_5(void *) { return B_ERROR; }</a>
<a name="ln2469">status_t BTextParameter::_Reserved_TextParameter_6(void *) { return B_ERROR; }</a>
<a name="ln2470">status_t BTextParameter::_Reserved_TextParameter_7(void *) { return B_ERROR; }</a>

</code></pre>
<div class="balloon" rel="2034"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'name' pointer was utilized before it was verified against nullptr. Check lines: 2034, 2035.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
