
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>AddressTextControl.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2015, Axel Dörfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Copyright 2010 Stephan Aßmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;AddressTextControl.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;Autolock.h&gt;</a>
<a name="ln11">#include &lt;Button.h&gt;</a>
<a name="ln12">#include &lt;Catalog.h&gt;</a>
<a name="ln13">#include &lt;ControlLook.h&gt;</a>
<a name="ln14">#include &lt;Clipboard.h&gt;</a>
<a name="ln15">#include &lt;File.h&gt;</a>
<a name="ln16">#include &lt;LayoutBuilder.h&gt;</a>
<a name="ln17">#include &lt;Locale.h&gt;</a>
<a name="ln18">#include &lt;LayoutUtils.h&gt;</a>
<a name="ln19">#include &lt;NodeInfo.h&gt;</a>
<a name="ln20">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln21">#include &lt;SeparatorView.h&gt;</a>
<a name="ln22">#include &lt;TextView.h&gt;</a>
<a name="ln23">#include &lt;Window.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;stdio.h&gt;</a>
<a name="ln26">#include &lt;stdlib.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;MailApp.h&quot;</a>
<a name="ln29">#include &quot;Messages.h&quot;</a>
<a name="ln30">#include &quot;QueryList.h&quot;</a>
<a name="ln31">#include &quot;TextViewCompleter.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33"> </a>
<a name="ln34">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln35">#define B_TRANSLATION_CONTEXT &quot;AddressTextControl&quot;</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">static const uint32 kMsgAddAddress = 'adad';</a>
<a name="ln39">static const float kVerticalTextRectInset = 2.0;</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">class AddressTextControl::TextView : public BTextView {</a>
<a name="ln43">private:</a>
<a name="ln44">	static const uint32 MSG_CLEAR = 'cler';</a>
<a name="ln45"> </a>
<a name="ln46">public:</a>
<a name="ln47">								TextView(AddressTextControl* parent);</a>
<a name="ln48">	virtual						~TextView();</a>
<a name="ln49"> </a>
<a name="ln50">	virtual	void				MessageReceived(BMessage* message);</a>
<a name="ln51">	virtual	void				FrameResized(float width, float height);</a>
<a name="ln52">	virtual	void				KeyDown(const char* bytes, int32 numBytes);</a>
<a name="ln53">	virtual	void				MakeFocus(bool focused = true);</a>
<a name="ln54"> </a>
<a name="ln55">	virtual	BSize				MinSize();</a>
<a name="ln56">	virtual	BSize				MaxSize();</a>
<a name="ln57"> </a>
<a name="ln58">			const BMessage*		ModificationMessage() const;</a>
<a name="ln59">			void				SetModificationMessage(BMessage* message);</a>
<a name="ln60"> </a>
<a name="ln61">			void				SetUpdateAutoCompleterChoices(bool update);</a>
<a name="ln62"> </a>
<a name="ln63">protected:</a>
<a name="ln64">	virtual	void				InsertText(const char* text, int32 length,</a>
<a name="ln65">									int32 offset,</a>
<a name="ln66">									const text_run_array* runs);</a>
<a name="ln67">	virtual	void				DeleteText(int32 fromOffset, int32 toOffset);</a>
<a name="ln68"> </a>
<a name="ln69">private:</a>
<a name="ln70">			void				_AlignTextRect();</a>
<a name="ln71"> </a>
<a name="ln72">private:</a>
<a name="ln73">			AddressTextControl*	fAddressTextControl;</a>
<a name="ln74">			TextViewCompleter*	fAutoCompleter;</a>
<a name="ln75">			BString				fPreviousText;</a>
<a name="ln76">			bool				fUpdateAutoCompleterChoices;</a>
<a name="ln77">			BMessage*			fModificationMessage;</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80"> </a>
<a name="ln81">class AddressPopUpMenu : public BPopUpMenu, public QueryListener {</a>
<a name="ln82">public:</a>
<a name="ln83">								AddressPopUpMenu();</a>
<a name="ln84">	virtual						~AddressPopUpMenu();</a>
<a name="ln85"> </a>
<a name="ln86">protected:</a>
<a name="ln87">	virtual	void				EntryCreated(QueryList&amp; source,</a>
<a name="ln88">									const entry_ref&amp; ref, ino_t node);</a>
<a name="ln89">	virtual	void				EntryRemoved(QueryList&amp; source,</a>
<a name="ln90">									const node_ref&amp; nodeRef);</a>
<a name="ln91"> </a>
<a name="ln92">private:</a>
<a name="ln93">			void				_RebuildMenu();</a>
<a name="ln94">			void				_AddGroup(const char* label, const char* group,</a>
<a name="ln95">									PersonList&amp; peopleList);</a>
<a name="ln96">			void				_AddPeople(BMenu* menu, PersonList&amp; peopleList,</a>
<a name="ln97">									const char* group,</a>
<a name="ln98">									bool addSeparator = false);</a>
<a name="ln99">			bool				_MatchesGroup(const Person&amp; person,</a>
<a name="ln100">									const char* group);</a>
<a name="ln101">};</a>
<a name="ln102"> </a>
<a name="ln103"> </a>
<a name="ln104">class AddressTextControl::PopUpButton : public BControl {</a>
<a name="ln105">public:</a>
<a name="ln106">								PopUpButton();</a>
<a name="ln107">	virtual						~PopUpButton();</a>
<a name="ln108"> </a>
<a name="ln109">	virtual BSize				MinSize();</a>
<a name="ln110">	virtual BSize				PreferredSize();</a>
<a name="ln111">	virtual BSize				MaxSize();</a>
<a name="ln112"> </a>
<a name="ln113">	virtual	void				MouseDown(BPoint where);</a>
<a name="ln114">	virtual	void				Draw(BRect updateRect);</a>
<a name="ln115"> </a>
<a name="ln116">private:</a>
<a name="ln117">			AddressPopUpMenu*	fPopUpMenu;</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120"> </a>
<a name="ln121">class PeopleChoiceModel : public BAutoCompleter::ChoiceModel {</a>
<a name="ln122">public:</a>
<a name="ln123">	PeopleChoiceModel()</a>
<a name="ln124">		:</a>
<a name="ln125">		fChoices(5, true)</a>
<a name="ln126">	{</a>
<a name="ln127">	}</a>
<a name="ln128"> </a>
<a name="ln129">	~PeopleChoiceModel()</a>
<a name="ln130">	{</a>
<a name="ln131">	}</a>
<a name="ln132"> </a>
<a name="ln133">	virtual void FetchChoicesFor(const BString&amp; pattern)</a>
<a name="ln134">	{</a>
<a name="ln135">		// Remove all existing choices</a>
<a name="ln136">		fChoices.MakeEmpty();</a>
<a name="ln137"> </a>
<a name="ln138">		// Search through the people list for any matches</a>
<a name="ln139">		PersonList&amp; peopleList = static_cast&lt;TMailApp*&gt;(be_app)-&gt;People();</a>
<a name="ln140">		BAutolock locker(peopleList);</a>
<a name="ln141"> </a>
<a name="ln142">		for (int32 index = 0; index &lt; peopleList.CountPersons(); index++) {</a>
<a name="ln143">			const Person* person = peopleList.PersonAt(index);</a>
<a name="ln144"> </a>
<a name="ln145">			const BString&amp; baseText = person-&gt;Name();</a>
<a name="ln146">			for (int32 addressIndex = 0;</a>
<a name="ln147">					addressIndex &lt; person-&gt;CountAddresses(); addressIndex++) {</a>
<a name="ln148">				BString choiceText = baseText;</a>
<a name="ln149">				choiceText &lt;&lt; &quot; &lt;&quot; &lt;&lt; person-&gt;AddressAt(addressIndex) &lt;&lt; &quot;&gt;&quot;;</a>
<a name="ln150"> </a>
<a name="ln151">				int32 match = choiceText.IFindFirst(pattern);</a>
<a name="ln152">				if (match &lt; 0)</a>
<a name="ln153">					continue;</a>
<a name="ln154"> </a>
<a name="ln155">				fChoices.AddItem(new BAutoCompleter::Choice(choiceText,</a>
<a name="ln156">					choiceText, match, pattern.Length()));</a>
<a name="ln157">			}</a>
<a name="ln158">		}</a>
<a name="ln159"> </a>
<a name="ln160">		locker.Unlock();</a>
<a name="ln161">		fChoices.SortItems(_CompareChoices);</a>
<a name="ln162">	}</a>
<a name="ln163"> </a>
<a name="ln164">	virtual int32 CountChoices() const</a>
<a name="ln165">	{</a>
<a name="ln166">		return fChoices.CountItems();</a>
<a name="ln167">	}</a>
<a name="ln168"> </a>
<a name="ln169">	virtual const BAutoCompleter::Choice* ChoiceAt(int32 index) const</a>
<a name="ln170">	{</a>
<a name="ln171">		return fChoices.ItemAt(index);</a>
<a name="ln172">	}</a>
<a name="ln173"> </a>
<a name="ln174">	static int _CompareChoices(const BAutoCompleter::Choice* a,</a>
<a name="ln175">		const BAutoCompleter::Choice* b)</a>
<a name="ln176">	{</a>
<a name="ln177">		return a-&gt;DisplayText().Compare(b-&gt;DisplayText());</a>
<a name="ln178">	}</a>
<a name="ln179"> </a>
<a name="ln180">private:</a>
<a name="ln181">	BObjectList&lt;BAutoCompleter::Choice&gt; fChoices;</a>
<a name="ln182">};</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">// #pragma mark - TextView</a>
<a name="ln186"> </a>
<a name="ln187"> </a>
<a name="ln188">AddressTextControl::TextView::TextView(AddressTextControl* parent)</a>
<a name="ln189">	:</a>
<a name="ln190">	BTextView(&quot;mail&quot;),</a>
<a name="ln191">	fAddressTextControl(parent),</a>
<a name="ln192">	fAutoCompleter(new TextViewCompleter(this,</a>
<a name="ln193">		new PeopleChoiceModel())),</a>
<a name="ln194">	fPreviousText(&quot;&quot;),</a>
<a name="ln195">	fUpdateAutoCompleterChoices(true)</a>
<a name="ln196">{</a>
<a name="ln197">	MakeResizable(true);</a>
<a name="ln198">	SetStylable(true);</a>
<a name="ln199">	fAutoCompleter-&gt;SetModificationsReported(true);</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">AddressTextControl::TextView::~TextView()</a>
<a name="ln204">{</a>
<a name="ln205">	delete fAutoCompleter;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208"> </a>
<a name="ln209">void</a>
<a name="ln210">AddressTextControl::TextView::MessageReceived(BMessage* message)</a>
<a name="ln211">{</a>
<a name="ln212">	switch (message-&gt;what) {</a>
<a name="ln213">		case MSG_CLEAR:</a>
<a name="ln214">			SetText(&quot;&quot;);</a>
<a name="ln215">			break;</a>
<a name="ln216"> </a>
<a name="ln217">		default:</a>
<a name="ln218">			BTextView::MessageReceived(message);</a>
<a name="ln219">			break;</a>
<a name="ln220">	}</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224">void</a>
<a name="ln225">AddressTextControl::TextView::FrameResized(float width, float height)</a>
<a name="ln226">{</a>
<a name="ln227">	BTextView::FrameResized(width, height);</a>
<a name="ln228">	_AlignTextRect();</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231"> </a>
<a name="ln232">void</a>
<a name="ln233">AddressTextControl::TextView::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln234">{</a>
<a name="ln235">	switch (bytes[0]) {</a>
<a name="ln236">		case B_TAB:</a>
<a name="ln237">			BView::KeyDown(bytes, numBytes);</a>
<a name="ln238">			break;</a>
<a name="ln239"> </a>
<a name="ln240">		case B_ESCAPE:</a>
<a name="ln241">			// Revert to text as it was when we received keyboard focus.</a>
<a name="ln242">			SetText(fPreviousText.String());</a>
<a name="ln243">			SelectAll();</a>
<a name="ln244">			break;</a>
<a name="ln245"> </a>
<a name="ln246">		case B_RETURN:</a>
<a name="ln247">			// Don't let this through to the text view.</a>
<a name="ln248">			break;</a>
<a name="ln249"> </a>
<a name="ln250">		default:</a>
<a name="ln251">			BTextView::KeyDown(bytes, numBytes);</a>
<a name="ln252">			break;</a>
<a name="ln253">	}</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">void</a>
<a name="ln257">AddressTextControl::TextView::MakeFocus(bool focus)</a>
<a name="ln258">{</a>
<a name="ln259">	if (focus == IsFocus())</a>
<a name="ln260">		return;</a>
<a name="ln261"> </a>
<a name="ln262">	BTextView::MakeFocus(focus);</a>
<a name="ln263"> </a>
<a name="ln264">	if (focus) {</a>
<a name="ln265">		fPreviousText = Text();</a>
<a name="ln266">		SelectAll();</a>
<a name="ln267">	}</a>
<a name="ln268"> </a>
<a name="ln269">	fAddressTextControl-&gt;Invalidate();</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272"> </a>
<a name="ln273">BSize</a>
<a name="ln274">AddressTextControl::TextView::MinSize()</a>
<a name="ln275">{</a>
<a name="ln276">	BSize min;</a>
<a name="ln277">	min.height = ceilf(LineHeight(0) + kVerticalTextRectInset);</a>
<a name="ln278">		// we always add at least one pixel vertical inset top/bottom for</a>
<a name="ln279">		// the text rect.</a>
<a name="ln280">	min.width = min.height * 3;</a>
<a name="ln281">	return BLayoutUtils::ComposeSize(ExplicitMinSize(), min);</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284"> </a>
<a name="ln285">BSize</a>
<a name="ln286">AddressTextControl::TextView::MaxSize()</a>
<a name="ln287">{</a>
<a name="ln288">	BSize max(MinSize());</a>
<a name="ln289">	max.width = B_SIZE_UNLIMITED;</a>
<a name="ln290">	return BLayoutUtils::ComposeSize(ExplicitMaxSize(), max);</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293"> </a>
<a name="ln294">const BMessage*</a>
<a name="ln295">AddressTextControl::TextView::ModificationMessage() const</a>
<a name="ln296">{</a>
<a name="ln297">	return fModificationMessage;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301">void</a>
<a name="ln302">AddressTextControl::TextView::SetModificationMessage(BMessage* message)</a>
<a name="ln303">{</a>
<a name="ln304">	fModificationMessage = message;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307"> </a>
<a name="ln308">void</a>
<a name="ln309">AddressTextControl::TextView::SetUpdateAutoCompleterChoices(bool update)</a>
<a name="ln310">{</a>
<a name="ln311">	fUpdateAutoCompleterChoices = update;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314"> </a>
<a name="ln315">void</a>
<a name="ln316">AddressTextControl::TextView::InsertText(const char* text,</a>
<a name="ln317">	int32 length, int32 offset, const text_run_array* runs)</a>
<a name="ln318">{</a>
<a name="ln319">	if (!strncmp(text, &quot;mailto:&quot;, 7)) {</a>
<a name="ln320">		text += 7;</a>
<a name="ln321">		length -= 7;</a>
<a name="ln322">		if (runs != NULL)</a>
<a name="ln323">			runs = NULL;</a>
<a name="ln324">	}</a>
<a name="ln325"> </a>
<a name="ln326">	// Filter all line breaks, note that text is not terminated.</a>
<a name="ln327">	if (length == 1) {</a>
<a name="ln328">		if (*text == '\n' || *text == '\r')</a>
<a name="ln329">			BTextView::InsertText(&quot; &quot;, 1, offset, runs);</a>
<a name="ln330">		else</a>
<a name="ln331">			BTextView::InsertText(text, 1, offset, runs);</a>
<a name="ln332">	} else {</a>
<a name="ln333">		BString filteredText(text, length);</a>
<a name="ln334">		filteredText.ReplaceAll('\n', ' ');</a>
<a name="ln335">		filteredText.ReplaceAll('\r', ' ');</a>
<a name="ln336">		BTextView::InsertText(filteredText.String(), length, offset,</a>
<a name="ln337">			runs);</a>
<a name="ln338">	}</a>
<a name="ln339"> </a>
<a name="ln340">	// TODO: change E-mail representation</a>
<a name="ln341">/*</a>
<a name="ln342">	// Make the base URL part bold.</a>
<a name="ln343">	BString text(Text(), TextLength());</a>
<a name="ln344">	int32 baseUrlStart = text.FindFirst(&quot;://&quot;);</a>
<a name="ln345">	if (baseUrlStart &gt;= 0)</a>
<a name="ln346">		baseUrlStart += 3;</a>
<a name="ln347">	else</a>
<a name="ln348">		baseUrlStart = 0;</a>
<a name="ln349">	int32 baseUrlEnd = text.FindFirst(&quot;/&quot;, baseUrlStart);</a>
<a name="ln350">	if (baseUrlEnd &lt; 0)</a>
<a name="ln351">		baseUrlEnd = TextLength();</a>
<a name="ln352"> </a>
<a name="ln353">	BFont font;</a>
<a name="ln354">	GetFont(&amp;font);</a>
<a name="ln355">	const rgb_color black = (rgb_color) { 0, 0, 0, 255 };</a>
<a name="ln356">	const rgb_color gray = (rgb_color) { 60, 60, 60, 255 };</a>
<a name="ln357">	if (baseUrlStart &gt; 0)</a>
<a name="ln358">		SetFontAndColor(0, baseUrlStart, &amp;font, B_FONT_ALL, &amp;gray);</a>
<a name="ln359">	if (baseUrlEnd &gt; baseUrlStart) {</a>
<a name="ln360">		font.SetFace(B_BOLD_FACE);</a>
<a name="ln361">		SetFontAndColor(baseUrlStart, baseUrlEnd, &amp;font, B_FONT_ALL, &amp;black);</a>
<a name="ln362">	}</a>
<a name="ln363">	if (baseUrlEnd &lt; TextLength()) {</a>
<a name="ln364">		font.SetFace(B_REGULAR_FACE);</a>
<a name="ln365">		SetFontAndColor(baseUrlEnd, TextLength(), &amp;font, B_FONT_ALL, &amp;gray);</a>
<a name="ln366">	}</a>
<a name="ln367">*/</a>
<a name="ln368">	fAutoCompleter-&gt;TextModified(fUpdateAutoCompleterChoices);</a>
<a name="ln369">	fAddressTextControl-&gt;InvokeNotify(fModificationMessage,</a>
<a name="ln370">		B_CONTROL_MODIFIED);</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">void</a>
<a name="ln375">AddressTextControl::TextView::DeleteText(int32 fromOffset,</a>
<a name="ln376">	int32 toOffset)</a>
<a name="ln377">{</a>
<a name="ln378">	BTextView::DeleteText(fromOffset, toOffset);</a>
<a name="ln379"> </a>
<a name="ln380">	fAutoCompleter-&gt;TextModified(fUpdateAutoCompleterChoices);</a>
<a name="ln381">	fAddressTextControl-&gt;InvokeNotify(fModificationMessage,</a>
<a name="ln382">		B_CONTROL_MODIFIED);</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385"> </a>
<a name="ln386">void</a>
<a name="ln387">AddressTextControl::TextView::_AlignTextRect()</a>
<a name="ln388">{</a>
<a name="ln389">	// Layout the text rect to be in the middle, normally this means there</a>
<a name="ln390">	// is one pixel spacing on each side.</a>
<a name="ln391">	BRect textRect(Bounds());</a>
<a name="ln392">	textRect.left = 0.0;</a>
<a name="ln393">	float vInset = max_c(1,</a>
<a name="ln394">		floorf((textRect.Height() - LineHeight(0)) / 2.0 + 0.5));</a>
<a name="ln395"> </a>
<a name="ln396">	float hInset = 0;</a>
<a name="ln397">	if (be_control_look != NULL)</a>
<a name="ln398">		hInset = be_control_look-&gt;DefaultLabelSpacing();</a>
<a name="ln399"> </a>
<a name="ln400">	textRect.InsetBy(hInset, vInset);</a>
<a name="ln401">	SetTextRect(textRect);</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">//	#pragma mark - PopUpButton</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">AddressTextControl::PopUpButton::PopUpButton()</a>
<a name="ln409">	:</a>
<a name="ln410">	BControl(NULL, NULL, NULL, B_WILL_DRAW)</a>
<a name="ln411">{</a>
<a name="ln412">	fPopUpMenu = new AddressPopUpMenu();</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415"> </a>
<a name="ln416">AddressTextControl::PopUpButton::~PopUpButton()</a>
<a name="ln417">{</a>
<a name="ln418">	delete fPopUpMenu;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">BSize</a>
<a name="ln423">AddressTextControl::PopUpButton::MinSize()</a>
<a name="ln424">{</a>
<a name="ln425">	// TODO: BControlLook does not give us any size information!</a>
<a name="ln426">	return BSize(10, 10);</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">BSize</a>
<a name="ln431">AddressTextControl::PopUpButton::PreferredSize()</a>
<a name="ln432">{</a>
<a name="ln433">	return BSize(10, B_SIZE_UNSET);</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436"> </a>
<a name="ln437">BSize</a>
<a name="ln438">AddressTextControl::PopUpButton::MaxSize()</a>
<a name="ln439">{</a>
<a name="ln440">	return BSize(10, B_SIZE_UNLIMITED);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">void</a>
<a name="ln445">AddressTextControl::PopUpButton::MouseDown(BPoint where)</a>
<a name="ln446">{</a>
<a name="ln447">	if (fPopUpMenu-&gt;Parent() != NULL)</a>
<a name="ln448">		return;</a>
<a name="ln449"> </a>
<a name="ln450">	float width;</a>
<a name="ln451">	fPopUpMenu-&gt;GetPreferredSize(&amp;width, NULL);</a>
<a name="ln452">	fPopUpMenu-&gt;SetTargetForItems(Parent());</a>
<a name="ln453"> </a>
<a name="ln454">	BPoint point(Bounds().Width() - width, Bounds().Height() + 2);</a>
<a name="ln455">	ConvertToScreen(&amp;point);</a>
<a name="ln456">	fPopUpMenu-&gt;Go(point, true, true, true);</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">void</a>
<a name="ln461">AddressTextControl::PopUpButton::Draw(BRect updateRect)</a>
<a name="ln462">{</a>
<a name="ln463">	uint32 flags = 0;</a>
<a name="ln464">	if (!IsEnabled())</a>
<a name="ln465">		flags |= BControlLook::B_DISABLED;</a>
<a name="ln466"> </a>
<a name="ln467">	if (IsFocus() &amp;&amp; Window()-&gt;IsActive())</a>
<a name="ln468">		flags |= BControlLook::B_FOCUSED;</a>
<a name="ln469"> </a>
<a name="ln470">	rgb_color base = ui_color(B_MENU_BACKGROUND_COLOR);</a>
<a name="ln471">	BRect rect = Bounds();</a>
<a name="ln472">	be_control_look-&gt;DrawMenuFieldBackground(this, rect,</a>
<a name="ln473">		updateRect, base, true, flags);</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476"> </a>
<a name="ln477">//	#pragma mark - PopUpMenu</a>
<a name="ln478"> </a>
<a name="ln479"> </a>
<a name="ln480">AddressPopUpMenu::AddressPopUpMenu()</a>
<a name="ln481">	:</a>
<a name="ln482">	BPopUpMenu(&quot;&quot;, true)</a>
<a name="ln483">{</a>
<a name="ln484">	static_cast&lt;TMailApp*&gt;(be_app)-&gt;PeopleQueryList().AddListener(this);</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487"> </a>
<a name="ln488">AddressPopUpMenu::~AddressPopUpMenu()</a>
<a name="ln489">{</a>
<a name="ln490">	static_cast&lt;TMailApp*&gt;(be_app)-&gt;PeopleQueryList().RemoveListener(this);</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493"> </a>
<a name="ln494">void</a>
<a name="ln495">AddressPopUpMenu::EntryCreated(QueryList&amp; source,</a>
<a name="ln496">	const entry_ref&amp; ref, ino_t node)</a>
<a name="ln497">{</a>
<a name="ln498">	_RebuildMenu();</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">void</a>
<a name="ln503">AddressPopUpMenu::EntryRemoved(QueryList&amp; source,</a>
<a name="ln504">	const node_ref&amp; nodeRef)</a>
<a name="ln505">{</a>
<a name="ln506">	_RebuildMenu();</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">void</a>
<a name="ln511">AddressPopUpMenu::_RebuildMenu()</a>
<a name="ln512">{</a>
<a name="ln513">	// Remove all items</a>
<a name="ln514">	int32 index = CountItems();</a>
<a name="ln515">	while (index-- &gt; 0) {</a>
<a name="ln516">		 delete RemoveItem(index);</a>
<a name="ln517">	}</a>
<a name="ln518"> </a>
<a name="ln519">	// Rebuild contents</a>
<a name="ln520">	PersonList&amp; peopleList = static_cast&lt;TMailApp*&gt;(be_app)-&gt;People();</a>
<a name="ln521">	BAutolock locker(peopleList);</a>
<a name="ln522"> </a>
<a name="ln523">	if (peopleList.CountPersons() &gt; 0)</a>
<a name="ln524">		_AddGroup(B_TRANSLATE(&quot;All people&quot;), NULL, peopleList);</a>
<a name="ln525"> </a>
<a name="ln526">	GroupList&amp; groupList = static_cast&lt;TMailApp*&gt;(be_app)-&gt;PeopleGroups();</a>
<a name="ln527">	BAutolock groupLocker(groupList);</a>
<a name="ln528"> </a>
<a name="ln529">	for (int32 index = 0; index &lt; groupList.CountGroups(); index++) {</a>
<a name="ln530">		BString group = groupList.GroupAt(index);</a>
<a name="ln531">		_AddGroup(group, group, peopleList);</a>
<a name="ln532">	}</a>
<a name="ln533"> </a>
<a name="ln534">	groupLocker.Unlock();</a>
<a name="ln535"> </a>
<a name="ln536">	_AddPeople(this, peopleList, &quot;&quot;, true);</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539"> </a>
<a name="ln540">void</a>
<a name="ln541">AddressPopUpMenu::_AddGroup(const char* label, const char* group,</a>
<a name="ln542">	PersonList&amp; peopleList)</a>
<a name="ln543">{</a>
<a name="ln544">	BMenu* menu = new BMenu(label);</a>
<a name="ln545">	AddItem(menu);</a>
<a name="ln546">	menu-&gt;Superitem()-&gt;SetMessage(new BMessage(kMsgAddAddress));</a>
<a name="ln547"> </a>
<a name="ln548">	_AddPeople(menu, peopleList, group);</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551"> </a>
<a name="ln552">void</a>
<a name="ln553">AddressPopUpMenu::_AddPeople(BMenu* menu, PersonList&amp; peopleList,</a>
<a name="ln554">	const char* group, bool addSeparator)</a>
<a name="ln555">{</a>
<a name="ln556">	for (int32 index = 0; index &lt; peopleList.CountPersons(); index++) {</a>
<a name="ln557">		const Person* person = peopleList.PersonAt(index);</a>
<a name="ln558">		if (!_MatchesGroup(*person, group))</a>
<a name="ln559">			continue;</a>
<a name="ln560"> </a>
<a name="ln561">		if (person-&gt;CountAddresses() != 0 &amp;&amp; addSeparator) {</a>
<a name="ln562">			menu-&gt;AddSeparatorItem();</a>
<a name="ln563">			addSeparator = false;</a>
<a name="ln564">		}</a>
<a name="ln565"> </a>
<a name="ln566">		for (int32 addressIndex = 0; addressIndex &lt; person-&gt;CountAddresses();</a>
<a name="ln567">				addressIndex++) {</a>
<a name="ln568">			BString email = person-&gt;Name();</a>
<a name="ln569">			email &lt;&lt; &quot; &lt;&quot; &lt;&lt; person-&gt;AddressAt(addressIndex) &lt;&lt; &quot;&gt;&quot;;</a>
<a name="ln570"> </a>
<a name="ln571">			BMessage* message = new BMessage(kMsgAddAddress);</a>
<a name="ln572">			message-&gt;AddString(&quot;email&quot;, email);</a>
<a name="ln573">			menu-&gt;AddItem(new BMenuItem(email, message));</a>
<a name="ln574"> </a>
<a name="ln575">			if (menu-&gt;Superitem() != NULL)</a>
<a name="ln576">				menu-&gt;Superitem()-&gt;Message()-&gt;AddString(&quot;email&quot;, email);</a>
<a name="ln577">		}</a>
<a name="ln578">	}</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">bool</a>
<a name="ln583">AddressPopUpMenu::_MatchesGroup(const Person&amp; person, const char* group)</a>
<a name="ln584">{</a>
<a name="ln585">	if (group == NULL)</a>
<a name="ln586">		return true;</a>
<a name="ln587"> </a>
<a name="ln588">	if (group[0] == '\0')</a>
<a name="ln589">		return person.CountGroups() == 0;</a>
<a name="ln590"> </a>
<a name="ln591">	return person.IsInGroup(group);</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594"> </a>
<a name="ln595">// TODO: sort lists!</a>
<a name="ln596">/*</a>
<a name="ln597">void</a>
<a name="ln598">AddressTextControl::PopUpMenu::_AddPersonItem(const entry_ref *ref, ino_t node, BString &amp;name,</a>
<a name="ln599">	BString &amp;email, const char *attr, BMenu *groupMenu, BMenuItem *superItem)</a>
<a name="ln600">{</a>
<a name="ln601">	BString	label;</a>
<a name="ln602">	BString	sortKey;</a>
<a name="ln603">		// For alphabetical order sorting, usually last name.</a>
<a name="ln604"> </a>
<a name="ln605">	// if we have no Name, just use the email address</a>
<a name="ln606">	if (name.Length() == 0) {</a>
<a name="ln607">		label = email;</a>
<a name="ln608">		sortKey = email;</a>
<a name="ln609">	} else {</a>
<a name="ln610">		// otherwise, pretty-format it</a>
<a name="ln611">		label &lt;&lt; name &lt;&lt; &quot; (&quot; &lt;&lt; email &lt;&lt; &quot;)&quot;;</a>
<a name="ln612"> </a>
<a name="ln613">		// Extract the last name (last word in the name),</a>
<a name="ln614">		// removing trailing and leading spaces.</a>
<a name="ln615">		const char *nameStart = name.String();</a>
<a name="ln616">		const char *string = nameStart + strlen(nameStart) - 1;</a>
<a name="ln617">		const char *wordEnd;</a>
<a name="ln618"> </a>
<a name="ln619">		while (string &gt;= nameStart &amp;&amp; isspace(*string))</a>
<a name="ln620">			string--;</a>
<a name="ln621">		wordEnd = string + 1; // Points to just after last word.</a>
<a name="ln622">		while (string &gt;= nameStart &amp;&amp; !isspace(*string))</a>
<a name="ln623">			string--;</a>
<a name="ln624">		string++; // Point to first letter in the word.</a>
<a name="ln625">		if (wordEnd &gt; string)</a>
<a name="ln626">			sortKey.SetTo(string, wordEnd - string);</a>
<a name="ln627">		else // Blank name, pretend that the last name is after it.</a>
<a name="ln628">			string = nameStart + strlen(nameStart);</a>
<a name="ln629"> </a>
<a name="ln630">		// Append the first names to the end, so that people with the same last</a>
<a name="ln631">		// name get sorted by first name.  Note no space between the end of the</a>
<a name="ln632">		// last name and the start of the first names, but that shouldn't</a>
<a name="ln633">		// matter for sorting.</a>
<a name="ln634">		sortKey.Append(nameStart, string - nameStart);</a>
<a name="ln635">	}</a>
<a name="ln636">}</a>
<a name="ln637">*/</a>
<a name="ln638"> </a>
<a name="ln639">// #pragma mark - AddressTextControl</a>
<a name="ln640"> </a>
<a name="ln641"> </a>
<a name="ln642">AddressTextControl::AddressTextControl(const char* name, BMessage* message)</a>
<a name="ln643">	:</a>
<a name="ln644">	BControl(name, NULL, message, B_WILL_DRAW),</a>
<a name="ln645">	fRefDropMenu(NULL),</a>
<a name="ln646">	fWindowActive(false),</a>
<a name="ln647">	fEditable(true)</a>
<a name="ln648">{</a>
<a name="ln649">	fTextView = new TextView(this);</a>
<a name="ln650">	fTextView-&gt;SetExplicitMinSize(BSize(100, B_SIZE_UNSET));</a>
<a name="ln651">	fPopUpButton = new PopUpButton();</a>
<a name="ln652"> </a>
<a name="ln653">	BLayoutBuilder::Group&lt;&gt;(this, B_HORIZONTAL, 0)</a>
<a name="ln654">		.SetInsets(2)</a>
<a name="ln655">		.Add(fTextView)</a>
<a name="ln656">		.Add(fPopUpButton);</a>
<a name="ln657"> </a>
<a name="ln658">	SetFlags(Flags() | B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE);</a>
<a name="ln659">	SetLowUIColor(ViewUIColor());</a>
<a name="ln660">	SetViewUIColor(fTextView-&gt;ViewUIColor());</a>
<a name="ln661"> </a>
<a name="ln662">	SetExplicitAlignment(BAlignment(B_ALIGN_USE_FULL_WIDTH,</a>
<a name="ln663">		B_ALIGN_VERTICAL_CENTER));</a>
<a name="ln664"> </a>
<a name="ln665">	SetEnabled(fEditable);</a>
<a name="ln666">		// Sets the B_NAVIGABLE flag on the TextView</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669"> </a>
<a name="ln670">AddressTextControl::~AddressTextControl()</a>
<a name="ln671">{</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">void</a>
<a name="ln676">AddressTextControl::AttachedToWindow()</a>
<a name="ln677">{</a>
<a name="ln678">	BControl::AttachedToWindow();</a>
<a name="ln679">	fWindowActive = Window()-&gt;IsActive();</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682"> </a>
<a name="ln683">void</a>
<a name="ln684">AddressTextControl::WindowActivated(bool active)</a>
<a name="ln685">{</a>
<a name="ln686">	BControl::WindowActivated(active);</a>
<a name="ln687">	if (fWindowActive != active) {</a>
<a name="ln688">		fWindowActive = active;</a>
<a name="ln689">		Invalidate();</a>
<a name="ln690">	}</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693"> </a>
<a name="ln694">void</a>
<a name="ln695">AddressTextControl::Draw(BRect updateRect)</a>
<a name="ln696">{</a>
<a name="ln697">	if (!IsEditable())</a>
<a name="ln698">		return;</a>
<a name="ln699"> </a>
<a name="ln700">	BRect bounds(Bounds());</a>
<a name="ln701">	rgb_color base(LowColor());</a>
<a name="ln702">	uint32 flags = 0;</a>
<a name="ln703">	if (!IsEnabled())</a>
<a name="ln704">		flags |= BControlLook::B_DISABLED;</a>
<a name="ln705">	if (fWindowActive &amp;&amp; fTextView-&gt;IsFocus())</a>
<a name="ln706">		flags |= BControlLook::B_FOCUSED;</a>
<a name="ln707">	be_control_look-&gt;DrawTextControlBorder(this, bounds, updateRect, base,</a>
<a name="ln708">		flags);</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711"> </a>
<a name="ln712">void</a>
<a name="ln713">AddressTextControl::MakeFocus(bool focus)</a>
<a name="ln714">{</a>
<a name="ln715">	// Forward this to the text view, we never accept focus ourselves.</a>
<a name="ln716">	fTextView-&gt;MakeFocus(focus);</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719"> </a>
<a name="ln720">void</a>
<a name="ln721">AddressTextControl::SetEnabled(bool enabled)</a>
<a name="ln722">{</a>
<a name="ln723">	BControl::SetEnabled(enabled);</a>
<a name="ln724">	fTextView-&gt;MakeEditable(enabled &amp;&amp; fEditable);</a>
<a name="ln725">	if (enabled)</a>
<a name="ln726">		fTextView-&gt;SetFlags(fTextView-&gt;Flags() | B_NAVIGABLE);</a>
<a name="ln727">	else</a>
<a name="ln728">		fTextView-&gt;SetFlags(fTextView-&gt;Flags() &amp; ~B_NAVIGABLE);</a>
<a name="ln729"> </a>
<a name="ln730">	fPopUpButton-&gt;SetEnabled(enabled);</a>
<a name="ln731"> </a>
<a name="ln732">	_UpdateTextViewColors();</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735"> </a>
<a name="ln736">void</a>
<a name="ln737">AddressTextControl::MessageReceived(BMessage* message)</a>
<a name="ln738">{</a>
<a name="ln739">	switch (message-&gt;what) {</a>
<a name="ln740">		case B_SIMPLE_DATA:</a>
<a name="ln741">		{</a>
<a name="ln742">			int32 buttons = -1;</a>
<a name="ln743">			BPoint point;</a>
<a name="ln744">			if (message-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons) != B_OK)</a>
<a name="ln745">				buttons = B_PRIMARY_MOUSE_BUTTON;</a>
<a name="ln746"> </a>
<a name="ln747">			if (buttons != B_PRIMARY_MOUSE_BUTTON</a>
<a name="ln748">				&amp;&amp; message-&gt;FindPoint(&quot;_drop_point_&quot;, &amp;point) != B_OK)</a>
<a name="ln749">				return;</a>
<a name="ln750"> </a>
<a name="ln751">			BMessage forwardRefs(B_REFS_RECEIVED);</a>
<a name="ln752">			bool forward = false;</a>
<a name="ln753"> </a>
<a name="ln754">			entry_ref ref;</a>
<a name="ln755">			for (int32 index = 0;message-&gt;FindRef(&quot;refs&quot;, index, &amp;ref) == B_OK; index++) {</a>
<a name="ln756">				BFile file(&amp;ref, B_READ_ONLY);</a>
<a name="ln757">				if (file.InitCheck() == B_NO_ERROR) {</a>
<a name="ln758">					BNodeInfo info(&amp;file);</a>
<a name="ln759">					char type[B_FILE_NAME_LENGTH];</a>
<a name="ln760">					info.GetType(type);</a>
<a name="ln761"> </a>
<a name="ln762">					if (!strcmp(type,&quot;application/x-person&quot;)) {</a>
<a name="ln763">						// add person's E-mail address to the To: field</a>
<a name="ln764"> </a>
<a name="ln765">						BString attr = &quot;&quot;;</a>
<a name="ln766">						if (buttons == B_PRIMARY_MOUSE_BUTTON) {</a>
<a name="ln767">							if (message-&gt;FindString(&quot;attr&quot;, &amp;attr) &lt; B_OK)</a>
<a name="ln768">								attr = &quot;META:email&quot;;</a>
<a name="ln769">						} else {</a>
<a name="ln770">							BNode node(&amp;ref);</a>
<a name="ln771">							node.RewindAttrs();</a>
<a name="ln772"> </a>
<a name="ln773">							char buffer[B_ATTR_NAME_LENGTH];</a>
<a name="ln774"> </a>
<a name="ln775">							delete fRefDropMenu;</a>
<a name="ln776">							fRefDropMenu = new BPopUpMenu(&quot;RecipientMenu&quot;);</a>
<a name="ln777"> </a>
<a name="ln778">							while (node.GetNextAttrName(buffer) == B_OK) {</a>
<a name="ln779">								if (strstr(buffer, &quot;email&quot;) == NULL)</a>
<a name="ln780">									continue;</a>
<a name="ln781"> </a>
<a name="ln782">								attr = buffer;</a>
<a name="ln783"> </a>
<a name="ln784">								BString address;</a>
<a name="ln785">								node.ReadAttrString(buffer, &amp;address);</a>
<a name="ln786">								if (address.Length() &lt;= 0)</a>
<a name="ln787">									continue;</a>
<a name="ln788"> </a>
<a name="ln789">								BMessage* itemMsg</a>
<a name="ln790">									= new BMessage(kMsgAddAddress);</a>
<a name="ln791">								itemMsg-&gt;AddString(&quot;email&quot;, address.String());</a>
<a name="ln792"> </a>
<a name="ln793">								BMenuItem* item = new BMenuItem(</a>
<a name="ln794">									address.String(), itemMsg);</a>
<a name="ln795">								fRefDropMenu-&gt;AddItem(item);</a>
<a name="ln796">							}</a>
<a name="ln797"> </a>
<a name="ln798">							if (fRefDropMenu-&gt;CountItems() &gt; 1) {</a>
<a name="ln799">								fRefDropMenu-&gt;SetTargetForItems(this);</a>
<a name="ln800">								fRefDropMenu-&gt;Go(point, true, true, true);</a>
<a name="ln801">								return;</a>
<a name="ln802">							} else {</a>
<a name="ln803">								delete fRefDropMenu;</a>
<a name="ln804">								fRefDropMenu = NULL;</a>
<a name="ln805">							}</a>
<a name="ln806">						}</a>
<a name="ln807"> </a>
<a name="ln808">						BString email;</a>
<a name="ln809">						file.ReadAttrString(attr.String(), &amp;email);</a>
<a name="ln810"> </a>
<a name="ln811">						// we got something...</a>
<a name="ln812">						if (email.Length() &gt; 0) {</a>
<a name="ln813">							// see if we can get a username as well</a>
<a name="ln814">							BString name;</a>
<a name="ln815">							file.ReadAttrString(&quot;META:name&quot;, &amp;name);</a>
<a name="ln816"> </a>
<a name="ln817">							BString	address;</a>
<a name="ln818">							if (name.Length() == 0) {</a>
<a name="ln819">								// if we have no Name, just use the email address</a>
<a name="ln820">								address = email;</a>
<a name="ln821">							} else {</a>
<a name="ln822">								// otherwise, pretty-format it</a>
<a name="ln823">								address &lt;&lt; &quot;\&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\&quot; &lt;&quot; &lt;&lt; email &lt;&lt; &quot;&gt;&quot;;</a>
<a name="ln824">							}</a>
<a name="ln825"> </a>
<a name="ln826">							_AddAddress(address);</a>
<a name="ln827">						}</a>
<a name="ln828">					} else {</a>
<a name="ln829">						forward = true;</a>
<a name="ln830">						forwardRefs.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln831">					}</a>
<a name="ln832">				}</a>
<a name="ln833">			}</a>
<a name="ln834"> </a>
<a name="ln835">			if (forward) {</a>
<a name="ln836">				// Pass on to parent</a>
<a name="ln837">				Window()-&gt;PostMessage(&amp;forwardRefs, Parent());</a>
<a name="ln838">			}</a>
<a name="ln839">			break;</a>
<a name="ln840">		}</a>
<a name="ln841"> </a>
<a name="ln842">		case M_SELECT:</a>
<a name="ln843">		{</a>
<a name="ln844">			BTextView *textView = (BTextView *)ChildAt(0);</a>
<a name="ln845">			if (textView != NULL)</a>
<a name="ln846">				textView-&gt;Select(0, textView-&gt;TextLength());</a>
<a name="ln847">			break;</a>
<a name="ln848">		}</a>
<a name="ln849"> </a>
<a name="ln850">		case kMsgAddAddress:</a>
<a name="ln851">		{</a>
<a name="ln852">			const char* email;</a>
<a name="ln853">			for (int32 index = 0;</a>
<a name="ln854">					message-&gt;FindString(&quot;email&quot;, index++, &amp;email) == B_OK;)</a>
<a name="ln855">				_AddAddress(email);</a>
<a name="ln856">			break;</a>
<a name="ln857">		}</a>
<a name="ln858"> </a>
<a name="ln859">		default:</a>
<a name="ln860">			BControl::MessageReceived(message);</a>
<a name="ln861">			break;</a>
<a name="ln862">	}</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865"> </a>
<a name="ln866">const BMessage*</a>
<a name="ln867">AddressTextControl::ModificationMessage() const</a>
<a name="ln868">{</a>
<a name="ln869">	return fTextView-&gt;ModificationMessage();</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872"> </a>
<a name="ln873">void</a>
<a name="ln874">AddressTextControl::SetModificationMessage(BMessage* message)</a>
<a name="ln875">{</a>
<a name="ln876">	fTextView-&gt;SetModificationMessage(message);</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879"> </a>
<a name="ln880">bool</a>
<a name="ln881">AddressTextControl::IsEditable() const</a>
<a name="ln882">{</a>
<a name="ln883">	return fEditable;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886"> </a>
<a name="ln887">void</a>
<a name="ln888">AddressTextControl::SetEditable(bool editable)</a>
<a name="ln889">{</a>
<a name="ln890">	fTextView-&gt;MakeEditable(IsEnabled() &amp;&amp; editable);</a>
<a name="ln891">	fEditable = editable;</a>
<a name="ln892"> </a>
<a name="ln893">	if (editable &amp;&amp; fPopUpButton-&gt;IsHidden(this))</a>
<a name="ln894">		fPopUpButton-&gt;Show();</a>
<a name="ln895">	else if (!editable &amp;&amp; !fPopUpButton-&gt;IsHidden(this))</a>
<a name="ln896">		fPopUpButton-&gt;Hide();</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899"> </a>
<a name="ln900">void</a>
<a name="ln901">AddressTextControl::SetText(const char* text)</a>
<a name="ln902">{</a>
<a name="ln903">	if (text == NULL || Text() == NULL || strcmp(Text(), text) != 0) {</a>
<a name="ln904">		fTextView-&gt;SetUpdateAutoCompleterChoices(false);</a>
<a name="ln905">		fTextView-&gt;SetText(text);</a>
<a name="ln906">		fTextView-&gt;SetUpdateAutoCompleterChoices(true);</a>
<a name="ln907">	}</a>
<a name="ln908">}</a>
<a name="ln909"> </a>
<a name="ln910"> </a>
<a name="ln911">const char*</a>
<a name="ln912">AddressTextControl::Text() const</a>
<a name="ln913">{</a>
<a name="ln914">	return fTextView-&gt;Text();</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917"> </a>
<a name="ln918">int32</a>
<a name="ln919">AddressTextControl::TextLength() const</a>
<a name="ln920">{</a>
<a name="ln921">	return fTextView-&gt;TextLength();</a>
<a name="ln922">}</a>
<a name="ln923"> </a>
<a name="ln924"> </a>
<a name="ln925">void</a>
<a name="ln926">AddressTextControl::GetSelection(int32* start, int32* end) const</a>
<a name="ln927">{</a>
<a name="ln928">	fTextView-&gt;GetSelection(start, end);</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931"> </a>
<a name="ln932">void</a>
<a name="ln933">AddressTextControl::Select(int32 start, int32 end)</a>
<a name="ln934">{</a>
<a name="ln935">	fTextView-&gt;Select(start, end);</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938"> </a>
<a name="ln939">void</a>
<a name="ln940">AddressTextControl::SelectAll()</a>
<a name="ln941">{</a>
<a name="ln942">	fTextView-&gt;Select(0, TextLength());</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945"> </a>
<a name="ln946">bool</a>
<a name="ln947">AddressTextControl::HasFocus()</a>
<a name="ln948">{</a>
<a name="ln949">	return fTextView-&gt;IsFocus();</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952"> </a>
<a name="ln953">void</a>
<a name="ln954">AddressTextControl::_AddAddress(const char* text)</a>
<a name="ln955">{</a>
<a name="ln956">	int last = fTextView-&gt;TextLength();</a>
<a name="ln957">	if (last != 0) {</a>
<a name="ln958">		fTextView-&gt;Select(last, last);</a>
<a name="ln959">		// TODO: test if there is already a ','</a>
<a name="ln960">		fTextView-&gt;Insert(&quot;, &quot;);</a>
<a name="ln961">	}</a>
<a name="ln962">	fTextView-&gt;Insert(text);</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965"> </a>
<a name="ln966">void</a>
<a name="ln967">AddressTextControl::_UpdateTextViewColors()</a>
<a name="ln968">{</a>
<a name="ln969">	BFont font;</a>
<a name="ln970">	fTextView-&gt;GetFontAndColor(0, &amp;font);</a>
<a name="ln971"> </a>
<a name="ln972">	rgb_color textColor;</a>
<a name="ln973">	if (!IsEditable() || IsEnabled())</a>
<a name="ln974">		textColor = ui_color(B_DOCUMENT_TEXT_COLOR);</a>
<a name="ln975">	else {</a>
<a name="ln976">		textColor = tint_color(ui_color(B_PANEL_BACKGROUND_COLOR),</a>
<a name="ln977">			B_DISABLED_LABEL_TINT);</a>
<a name="ln978">	}</a>
<a name="ln979"> </a>
<a name="ln980">	fTextView-&gt;SetFontAndColor(&amp;font, B_FONT_ALL, &amp;textColor);</a>
<a name="ln981"> </a>
<a name="ln982">	rgb_color color;</a>
<a name="ln983">	if (!IsEditable())</a>
<a name="ln984">		color = ui_color(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln985">	else if (IsEnabled())</a>
<a name="ln986">		color = ui_color(B_DOCUMENT_BACKGROUND_COLOR);</a>
<a name="ln987">	else {</a>
<a name="ln988">		color = tint_color(ui_color(B_PANEL_BACKGROUND_COLOR),</a>
<a name="ln989">			B_LIGHTEN_2_TINT);</a>
<a name="ln990">	}</a>
<a name="ln991"> </a>
<a name="ln992">	fTextView-&gt;SetViewColor(color);</a>
<a name="ln993">	fTextView-&gt;SetLowColor(color);</a>
<a name="ln994">}</a>

</code></pre>
<div class="balloon" rel="188"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fModificationMessage.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
