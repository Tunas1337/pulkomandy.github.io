
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ServerWindow.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2019, Haiku.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		DarkWyrm &lt;bpmagic@columbus.rr.com&gt;</a>
<a name="ln7"> *		Adrian Oanca &lt;adioanca@gmail.com&gt;</a>
<a name="ln8"> *		Stephan Aßmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln9"> *		Stefano Ceccherini &lt;stefano.ceccherini@gmail.com&gt;</a>
<a name="ln10"> *		Axel Dörfler &lt;axeld@pinc-software.de&gt;</a>
<a name="ln11"> *		Artur Wyszynski &lt;harakash@gmail.com&gt;</a>
<a name="ln12"> *		Philippe Saint-Pierre &lt;stpere@gmail.com&gt;</a>
<a name="ln13"> *		Brecht Machiels &lt;brecht@mos6581.org&gt;</a>
<a name="ln14"> *		Julian Harnath &lt;julian.harnath@rwth-aachen.de&gt;</a>
<a name="ln15"> *		Joseph Groover &lt;looncraz@looncraz.net&gt;</a>
<a name="ln16"> */</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">/*!	\class ServerWindow</a>
<a name="ln20"> </a>
<a name="ln21">	The ServerWindow class handles all BWindow messaging; it forwards all</a>
<a name="ln22">	BWindow requests to the corresponding app_server classes, that is Desktop,</a>
<a name="ln23">	Window, and View.</a>
<a name="ln24">	Furthermore, it also sends app_server requests/notices to its BWindow. There</a>
<a name="ln25">	is one ServerWindow per BWindow.</a>
<a name="ln26">*/</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;ServerWindow.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;syslog.h&gt;</a>
<a name="ln32">#include &lt;new&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;AppDefs.h&gt;</a>
<a name="ln35">#include &lt;Autolock.h&gt;</a>
<a name="ln36">#include &lt;Debug.h&gt;</a>
<a name="ln37">#include &lt;DirectWindow.h&gt;</a>
<a name="ln38">#include &lt;TokenSpace.h&gt;</a>
<a name="ln39">#include &lt;View.h&gt;</a>
<a name="ln40">#include &lt;GradientLinear.h&gt;</a>
<a name="ln41">#include &lt;GradientRadial.h&gt;</a>
<a name="ln42">#include &lt;GradientRadialFocus.h&gt;</a>
<a name="ln43">#include &lt;GradientDiamond.h&gt;</a>
<a name="ln44">#include &lt;GradientConic.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;MessagePrivate.h&gt;</a>
<a name="ln47">#include &lt;PortLink.h&gt;</a>
<a name="ln48">#include &lt;ShapePrivate.h&gt;</a>
<a name="ln49">#include &lt;ServerProtocolStructs.h&gt;</a>
<a name="ln50">#include &lt;ViewPrivate.h&gt;</a>
<a name="ln51">#include &lt;WindowInfo.h&gt;</a>
<a name="ln52">#include &lt;WindowPrivate.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;clipping.h&quot;</a>
<a name="ln55">#include &quot;utf8_functions.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">#include &quot;AlphaMask.h&quot;</a>
<a name="ln58">#include &quot;AppServer.h&quot;</a>
<a name="ln59">#include &quot;AutoDeleter.h&quot;</a>
<a name="ln60">#include &quot;BBitmapBuffer.h&quot;</a>
<a name="ln61">#include &quot;BitmapManager.h&quot;</a>
<a name="ln62">#include &quot;Desktop.h&quot;</a>
<a name="ln63">#include &quot;DirectWindowInfo.h&quot;</a>
<a name="ln64">#include &quot;DrawingEngine.h&quot;</a>
<a name="ln65">#include &quot;DrawState.h&quot;</a>
<a name="ln66">#include &quot;HWInterface.h&quot;</a>
<a name="ln67">#include &quot;Layer.h&quot;</a>
<a name="ln68">#include &quot;Overlay.h&quot;</a>
<a name="ln69">#include &quot;ProfileMessageSupport.h&quot;</a>
<a name="ln70">#include &quot;RenderingBuffer.h&quot;</a>
<a name="ln71">#include &quot;ServerApp.h&quot;</a>
<a name="ln72">#include &quot;ServerBitmap.h&quot;</a>
<a name="ln73">#include &quot;ServerPicture.h&quot;</a>
<a name="ln74">#include &quot;ServerProtocol.h&quot;</a>
<a name="ln75">#include &quot;Window.h&quot;</a>
<a name="ln76">#include &quot;WorkspacesView.h&quot;</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">using std::nothrow;</a>
<a name="ln80"> </a>
<a name="ln81"> </a>
<a name="ln82">//#define TRACE_SERVER_WINDOW</a>
<a name="ln83">#ifdef TRACE_SERVER_WINDOW</a>
<a name="ln84">#	include &lt;stdio.h&gt;</a>
<a name="ln85">#	define STRACE(x) debug_printf x</a>
<a name="ln86">#else</a>
<a name="ln87">#	define STRACE(x) ;</a>
<a name="ln88">#endif</a>
<a name="ln89"> </a>
<a name="ln90">//#define TRACE_SERVER_WINDOW_MESSAGES</a>
<a name="ln91">#ifdef TRACE_SERVER_WINDOW_MESSAGES</a>
<a name="ln92">#	include &lt;stdio.h&gt;</a>
<a name="ln93">static const char* kDrawingModeMap[] = {</a>
<a name="ln94">	&quot;B_OP_COPY&quot;,</a>
<a name="ln95">	&quot;B_OP_OVER&quot;,</a>
<a name="ln96">	&quot;B_OP_ERASE&quot;,</a>
<a name="ln97">	&quot;B_OP_INVERT&quot;,</a>
<a name="ln98">	&quot;B_OP_ADD&quot;,</a>
<a name="ln99">	&quot;B_OP_SUBTRACT&quot;,</a>
<a name="ln100">	&quot;B_OP_BLEND&quot;,</a>
<a name="ln101">	&quot;B_OP_MIN&quot;,</a>
<a name="ln102">	&quot;B_OP_MAX&quot;,</a>
<a name="ln103">	&quot;B_OP_SELECT&quot;,</a>
<a name="ln104">	&quot;B_OP_ALPHA&quot;,</a>
<a name="ln105"> </a>
<a name="ln106">	&quot;fix kDrawingModeMap&quot;,</a>
<a name="ln107">	&quot;fix kDrawingModeMap&quot;,</a>
<a name="ln108">	&quot;fix kDrawingModeMap&quot;,</a>
<a name="ln109">	&quot;fix kDrawingModeMap&quot;,</a>
<a name="ln110">	&quot;fix kDrawingModeMap&quot;,</a>
<a name="ln111">};</a>
<a name="ln112">#	define DTRACE(x) debug_printf x</a>
<a name="ln113">#else</a>
<a name="ln114">#	define DTRACE(x) ;</a>
<a name="ln115">#endif</a>
<a name="ln116"> </a>
<a name="ln117">//#define TRACE_SERVER_GRADIENTS</a>
<a name="ln118">#ifdef TRACE_SERVER_GRADIENTS</a>
<a name="ln119">#	include &lt;OS.h&gt;</a>
<a name="ln120">#	define GTRACE(x) debug_printf x</a>
<a name="ln121">#else</a>
<a name="ln122">#	define GTRACE(x) ;</a>
<a name="ln123">#endif</a>
<a name="ln124"> </a>
<a name="ln125">//#define PROFILE_MESSAGE_LOOP</a>
<a name="ln126">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln127">struct profile { int32 code; int32 count; bigtime_t time; };</a>
<a name="ln128">static profile sMessageProfile[AS_LAST_CODE];</a>
<a name="ln129">static profile sRedrawProcessingTime;</a>
<a name="ln130">//static profile sNextMessageTime;</a>
<a name="ln131">#endif</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">//	#pragma mark -</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln138">static int</a>
<a name="ln139">compare_message_profiles(const void* _a, const void* _b)</a>
<a name="ln140">{</a>
<a name="ln141">	profile* a = (profile*)*(void**)_a;</a>
<a name="ln142">	profile* b = (profile*)*(void**)_b;</a>
<a name="ln143">	if (a-&gt;time &lt; b-&gt;time)</a>
<a name="ln144">		return 1;</a>
<a name="ln145">	if (a-&gt;time &gt; b-&gt;time)</a>
<a name="ln146">		return -1;</a>
<a name="ln147">	return 0;</a>
<a name="ln148">}</a>
<a name="ln149">#endif</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">//	#pragma mark -</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">/*!	Sets up the basic BWindow counterpart - you have to call Init() before</a>
<a name="ln156">	you can actually use it, though.</a>
<a name="ln157">*/</a>
<a name="ln158">ServerWindow::ServerWindow(const char* title, ServerApp* app,</a>
<a name="ln159">		port_id clientPort, port_id looperPort, int32 clientToken)</a>
<a name="ln160">	:</a>
<a name="ln161">	MessageLooper(title &amp;&amp; *title ? title : &quot;Unnamed Window&quot;),</a>
<a name="ln162">	fTitle(NULL),</a>
<a name="ln163">	fDesktop(app-&gt;GetDesktop()),</a>
<a name="ln164">	fServerApp(app),</a>
<a name="ln165">	fWindow(NULL),</a>
<a name="ln166">	fWindowAddedToDesktop(false),</a>
<a name="ln167"> </a>
<a name="ln168">	fClientTeam(app-&gt;ClientTeam()),</a>
<a name="ln169"> </a>
<a name="ln170">	fMessagePort(-1),</a>
<a name="ln171">	fClientReplyPort(clientPort),</a>
<a name="ln172">	fClientLooperPort(looperPort),</a>
<a name="ln173"> </a>
<a name="ln174">	fClientToken(clientToken),</a>
<a name="ln175"> </a>
<a name="ln176">	fCurrentView(NULL),</a>
<a name="ln177">	fCurrentDrawingRegion(),</a>
<a name="ln178">	fCurrentDrawingRegionValid(false),</a>
<a name="ln179"> </a>
<a name="ln180">	fDirectWindowInfo(NULL),</a>
<a name="ln181">	fIsDirectlyAccessing(false)</a>
<a name="ln182">{</a>
<a name="ln183">	STRACE((&quot;ServerWindow(%s)::ServerWindow()\n&quot;, title));</a>
<a name="ln184"> </a>
<a name="ln185">	SetTitle(title);</a>
<a name="ln186">	fServerToken = BPrivate::gDefaultTokens.NewToken(B_SERVER_TOKEN, this);</a>
<a name="ln187"> </a>
<a name="ln188">	BMessenger::Private(fFocusMessenger).SetTo(fClientTeam,</a>
<a name="ln189">		looperPort, B_PREFERRED_TOKEN);</a>
<a name="ln190">	BMessenger::Private(fHandlerMessenger).SetTo(fClientTeam,</a>
<a name="ln191">		looperPort, clientToken);</a>
<a name="ln192"> </a>
<a name="ln193">	fEventTarget.SetTo(fFocusMessenger);</a>
<a name="ln194"> </a>
<a name="ln195">	fDeathSemaphore = create_sem(0, &quot;window death&quot;);</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198"> </a>
<a name="ln199">/*! Tears down all connections the main app_server objects, and deletes some</a>
<a name="ln200">	internals.</a>
<a name="ln201">*/</a>
<a name="ln202">ServerWindow::~ServerWindow()</a>
<a name="ln203">{</a>
<a name="ln204">	STRACE((&quot;ServerWindow(%s@%p):~ServerWindow()\n&quot;, fTitle, this));</a>
<a name="ln205"> </a>
<a name="ln206">	if (!fWindow-&gt;IsOffscreenWindow()) {</a>
<a name="ln207">		fWindowAddedToDesktop = false;</a>
<a name="ln208">		fDesktop-&gt;RemoveWindow(fWindow);</a>
<a name="ln209">	}</a>
<a name="ln210"> </a>
<a name="ln211">	if (App() != NULL) {</a>
<a name="ln212">		App()-&gt;RemoveWindow(this);</a>
<a name="ln213">		fServerApp = NULL;</a>
<a name="ln214">	}</a>
<a name="ln215"> </a>
<a name="ln216">	delete fWindow;</a>
<a name="ln217"> </a>
<a name="ln218">	free(fTitle);</a>
<a name="ln219">	delete_port(fMessagePort);</a>
<a name="ln220"> </a>
<a name="ln221">	BPrivate::gDefaultTokens.RemoveToken(fServerToken);</a>
<a name="ln222"> </a>
<a name="ln223">	delete fDirectWindowInfo;</a>
<a name="ln224">	STRACE((&quot;ServerWindow(%p) will exit NOW\n&quot;, this));</a>
<a name="ln225"> </a>
<a name="ln226">	delete_sem(fDeathSemaphore);</a>
<a name="ln227"> </a>
<a name="ln228">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln229">	BList profiles;</a>
<a name="ln230">	for (int32 i = 0; i &lt; AS_LAST_CODE; i++) {</a>
<a name="ln231">		if (sMessageProfile[i].count == 0)</a>
<a name="ln232">			continue;</a>
<a name="ln233">		sMessageProfile[i].code = i;</a>
<a name="ln234">		profiles.AddItem(&amp;sMessageProfile[i]);</a>
<a name="ln235">	}</a>
<a name="ln236"> </a>
<a name="ln237">	profiles.SortItems(compare_message_profiles);</a>
<a name="ln238"> </a>
<a name="ln239">	BString codeName;</a>
<a name="ln240">	int32 count = profiles.CountItems();</a>
<a name="ln241">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln242">		profile* p = (profile*)profiles.ItemAtFast(i);</a>
<a name="ln243">		string_for_message_code(p-&gt;code, codeName);</a>
<a name="ln244">		printf(&quot;[%s] called %&quot; B_PRId32 &quot; times, %g secs (%&quot; B_PRId64 &quot; usecs &quot;</a>
<a name="ln245">			&quot;per call)\n&quot;, codeName.String(), p-&gt;count, p-&gt;time / 1000000.0,</a>
<a name="ln246">			p-&gt;time / p-&gt;count);</a>
<a name="ln247">	}</a>
<a name="ln248">	if (sRedrawProcessingTime.count &gt; 0) {</a>
<a name="ln249">		printf(&quot;average redraw processing time: %g secs, count: %&quot; B_PRId32 &quot; &quot;</a>
<a name="ln250">			&quot;(%&quot; B_PRId64 &quot; usecs per call)\n&quot;,</a>
<a name="ln251">			sRedrawProcessingTime.time / 1000000.0, sRedrawProcessingTime.count,</a>
<a name="ln252">			sRedrawProcessingTime.time / sRedrawProcessingTime.count);</a>
<a name="ln253">	}</a>
<a name="ln254">//	if (sNextMessageTime.count &gt; 0) {</a>
<a name="ln255">//		printf(&quot;average NextMessage() time: %g secs, count: %ld (%lld usecs per call)\n&quot;,</a>
<a name="ln256">//			sNextMessageTime.time / 1000000.0, sNextMessageTime.count,</a>
<a name="ln257">//			sNextMessageTime.time / sNextMessageTime.count);</a>
<a name="ln258">//	}</a>
<a name="ln259">#endif</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">status_t</a>
<a name="ln264">ServerWindow::Init(BRect frame, window_look look, window_feel feel,</a>
<a name="ln265">	uint32 flags, uint32 workspace)</a>
<a name="ln266">{</a>
<a name="ln267">	if (!App()-&gt;AddWindow(this)) {</a>
<a name="ln268">		fServerApp = NULL;</a>
<a name="ln269">		return B_NO_MEMORY;</a>
<a name="ln270">	}</a>
<a name="ln271"> </a>
<a name="ln272">	if (fTitle == NULL)</a>
<a name="ln273">		return B_NO_MEMORY;</a>
<a name="ln274"> </a>
<a name="ln275">	// fMessagePort is the port to which the app sends messages for the server</a>
<a name="ln276">	fMessagePort = create_port(100, fTitle);</a>
<a name="ln277">	if (fMessagePort &lt; B_OK)</a>
<a name="ln278">		return fMessagePort;</a>
<a name="ln279"> </a>
<a name="ln280">	fLink.SetSenderPort(fClientReplyPort);</a>
<a name="ln281">	fLink.SetReceiverPort(fMessagePort);</a>
<a name="ln282"> </a>
<a name="ln283">	// We cannot call MakeWindow in the constructor, since it</a>
<a name="ln284">	// is a virtual function!</a>
<a name="ln285">	fWindow = MakeWindow(frame, fTitle, look, feel, flags, workspace);</a>
<a name="ln286">	if (!fWindow || fWindow-&gt;InitCheck() != B_OK) {</a>
<a name="ln287">		delete fWindow;</a>
<a name="ln288">		fWindow = NULL;</a>
<a name="ln289">		return B_NO_MEMORY;</a>
<a name="ln290">	}</a>
<a name="ln291"> </a>
<a name="ln292">	if (!fWindow-&gt;IsOffscreenWindow()) {</a>
<a name="ln293">		fDesktop-&gt;AddWindow(fWindow);</a>
<a name="ln294">		fWindowAddedToDesktop = true;</a>
<a name="ln295">	}</a>
<a name="ln296"> </a>
<a name="ln297">	return B_OK;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301">/*!	Returns the ServerWindow's Window, if it exists and has been</a>
<a name="ln302">	added to the Desktop already.</a>
<a name="ln303">	In other words, you cannot assume this method will always give you</a>
<a name="ln304">	a valid pointer.</a>
<a name="ln305">*/</a>
<a name="ln306">Window*</a>
<a name="ln307">ServerWindow::Window() const</a>
<a name="ln308">{</a>
<a name="ln309">	if (!fWindowAddedToDesktop)</a>
<a name="ln310">		return NULL;</a>
<a name="ln311"> </a>
<a name="ln312">	return fWindow;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">void</a>
<a name="ln317">ServerWindow::_PrepareQuit()</a>
<a name="ln318">{</a>
<a name="ln319">	if (fThread == find_thread(NULL)) {</a>
<a name="ln320">		// make sure we're hidden</a>
<a name="ln321">		fDesktop-&gt;LockSingleWindow();</a>
<a name="ln322">		_Hide();</a>
<a name="ln323">		fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln324">	} else if (fThread &gt;= B_OK)</a>
<a name="ln325">		PostMessage(AS_INTERNAL_HIDE_WINDOW);</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328"> </a>
<a name="ln329">void</a>
<a name="ln330">ServerWindow::_GetLooperName(char* name, size_t length)</a>
<a name="ln331">{</a>
<a name="ln332">	const char *title = Title();</a>
<a name="ln333">	if (title == NULL || !title[0])</a>
<a name="ln334">		title = &quot;Unnamed Window&quot;;</a>
<a name="ln335"> </a>
<a name="ln336">	snprintf(name, length, &quot;w:%&quot; B_PRId32 &quot;:%s&quot;, ClientTeam(), title);</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339"> </a>
<a name="ln340">/*! Shows the window's Window.</a>
<a name="ln341">*/</a>
<a name="ln342">void</a>
<a name="ln343">ServerWindow::_Show()</a>
<a name="ln344">{</a>
<a name="ln345">	// NOTE: if you do something else, other than sending a port message, PLEASE lock</a>
<a name="ln346">	STRACE((&quot;ServerWindow %s: _Show\n&quot;, Title()));</a>
<a name="ln347"> </a>
<a name="ln348">	if (fQuitting || fWindow-&gt;IsMinimized() || !fWindow-&gt;IsHidden()</a>
<a name="ln349">		|| fWindow-&gt;IsOffscreenWindow() || fWindow-&gt;TopView() == NULL)</a>
<a name="ln350">		return;</a>
<a name="ln351"> </a>
<a name="ln352">	// TODO: Maybe we need to dispatch a message to the desktop to show/hide us</a>
<a name="ln353">	// instead of doing it from this thread.</a>
<a name="ln354">	fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln355">	fDesktop-&gt;ShowWindow(fWindow);</a>
<a name="ln356">	if (fDirectWindowInfo &amp;&amp; fDirectWindowInfo-&gt;IsFullScreen())</a>
<a name="ln357">		_ResizeToFullScreen();</a>
<a name="ln358"> </a>
<a name="ln359">	fDesktop-&gt;LockSingleWindow();</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">/*! Hides the window's Window. You need to have all windows locked when</a>
<a name="ln364">	calling this function.</a>
<a name="ln365">*/</a>
<a name="ln366">void</a>
<a name="ln367">ServerWindow::_Hide()</a>
<a name="ln368">{</a>
<a name="ln369">	STRACE((&quot;ServerWindow %s: _Hide\n&quot;, Title()));</a>
<a name="ln370"> </a>
<a name="ln371">	if (fWindow-&gt;IsHidden() || fWindow-&gt;IsOffscreenWindow())</a>
<a name="ln372">		return;</a>
<a name="ln373"> </a>
<a name="ln374">	fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln375">	fDesktop-&gt;HideWindow(fWindow);</a>
<a name="ln376">	fDesktop-&gt;LockSingleWindow();</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379"> </a>
<a name="ln380">void</a>
<a name="ln381">ServerWindow::RequestRedraw()</a>
<a name="ln382">{</a>
<a name="ln383">	PostMessage(AS_REDRAW, 0);</a>
<a name="ln384">		// we don't care if this fails - it's only a notification, and if</a>
<a name="ln385">		// it fails, there are obviously enough messages in the queue</a>
<a name="ln386">		// already</a>
<a name="ln387"> </a>
<a name="ln388">	atomic_add(&amp;fRedrawRequested, 1);</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391"> </a>
<a name="ln392">void</a>
<a name="ln393">ServerWindow::SetTitle(const char* newTitle)</a>
<a name="ln394">{</a>
<a name="ln395">	char* oldTitle = fTitle;</a>
<a name="ln396"> </a>
<a name="ln397">	if (newTitle == NULL)</a>
<a name="ln398">		newTitle = &quot;&quot;;</a>
<a name="ln399"> </a>
<a name="ln400">	fTitle = strdup(newTitle);</a>
<a name="ln401">	if (fTitle == NULL) {</a>
<a name="ln402">		// out of memory condition</a>
<a name="ln403">		fTitle = oldTitle;</a>
<a name="ln404">		return;</a>
<a name="ln405">	}</a>
<a name="ln406"> </a>
<a name="ln407">	free(oldTitle);</a>
<a name="ln408"> </a>
<a name="ln409">	if (Thread() &gt;= B_OK) {</a>
<a name="ln410">		char name[B_OS_NAME_LENGTH];</a>
<a name="ln411">		_GetLooperName(name, sizeof(name));</a>
<a name="ln412">		rename_thread(Thread(), name);</a>
<a name="ln413">	}</a>
<a name="ln414"> </a>
<a name="ln415">	if (fWindow != NULL)</a>
<a name="ln416">		fDesktop-&gt;SetWindowTitle(fWindow, newTitle);</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419"> </a>
<a name="ln420">//! Requests that the ServerWindow's BWindow quit</a>
<a name="ln421">void</a>
<a name="ln422">ServerWindow::NotifyQuitRequested()</a>
<a name="ln423">{</a>
<a name="ln424">	// NOTE: if you do something else, other than sending a port message,</a>
<a name="ln425">	// PLEASE lock</a>
<a name="ln426">	STRACE((&quot;ServerWindow %s: Quit\n&quot;, fTitle));</a>
<a name="ln427"> </a>
<a name="ln428">	BMessage msg(B_QUIT_REQUESTED);</a>
<a name="ln429">	SendMessageToClient(&amp;msg);</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432"> </a>
<a name="ln433">void</a>
<a name="ln434">ServerWindow::NotifyMinimize(bool minimize)</a>
<a name="ln435">{</a>
<a name="ln436">	if (fWindow-&gt;Feel() != B_NORMAL_WINDOW_FEEL)</a>
<a name="ln437">		return;</a>
<a name="ln438"> </a>
<a name="ln439">	// The client is responsible for the actual minimization</a>
<a name="ln440"> </a>
<a name="ln441">	BMessage msg(B_MINIMIZE);</a>
<a name="ln442">	msg.AddInt64(&quot;when&quot;, real_time_clock_usecs());</a>
<a name="ln443">	msg.AddBool(&quot;minimize&quot;, minimize);</a>
<a name="ln444"> </a>
<a name="ln445">	SendMessageToClient(&amp;msg);</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448"> </a>
<a name="ln449">//! Sends a message to the client to perform a Zoom</a>
<a name="ln450">void</a>
<a name="ln451">ServerWindow::NotifyZoom()</a>
<a name="ln452">{</a>
<a name="ln453">	// NOTE: if you do something else, other than sending a port message,</a>
<a name="ln454">	// PLEASE lock</a>
<a name="ln455">	BMessage msg(B_ZOOM);</a>
<a name="ln456">	SendMessageToClient(&amp;msg);</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">void</a>
<a name="ln461">ServerWindow::GetInfo(window_info&amp; info)</a>
<a name="ln462">{</a>
<a name="ln463">	info.team = ClientTeam();</a>
<a name="ln464">	info.server_token = ServerToken();</a>
<a name="ln465"> </a>
<a name="ln466">	info.thread = Thread();</a>
<a name="ln467">	info.client_token = ClientToken();</a>
<a name="ln468">	info.client_port = fClientLooperPort;</a>
<a name="ln469">	info.workspaces = fWindow-&gt;Workspaces();</a>
<a name="ln470"> </a>
<a name="ln471">	// logic taken from Switcher comments and experiments</a>
<a name="ln472">	if (fWindow-&gt;IsHidden())</a>
<a name="ln473">		info.layer = 0;</a>
<a name="ln474">	else if (fWindow-&gt;IsVisible()) {</a>
<a name="ln475">		if (fWindow-&gt;Feel() == kDesktopWindowFeel)</a>
<a name="ln476">			info.layer = 2;</a>
<a name="ln477">		else if (fWindow-&gt;IsFloating() || fWindow-&gt;IsModal())</a>
<a name="ln478">			info.layer = 4;</a>
<a name="ln479">		else</a>
<a name="ln480">			info.layer = 3;</a>
<a name="ln481">	} else</a>
<a name="ln482">		info.layer = 1;</a>
<a name="ln483"> </a>
<a name="ln484">	info.feel = fWindow-&gt;Feel();</a>
<a name="ln485">	info.flags = fWindow-&gt;Flags();</a>
<a name="ln486">	info.window_left = (int)floor(fWindow-&gt;Frame().left);</a>
<a name="ln487">	info.window_top = (int)floor(fWindow-&gt;Frame().top);</a>
<a name="ln488">	info.window_right = (int)floor(fWindow-&gt;Frame().right);</a>
<a name="ln489">	info.window_bottom = (int)floor(fWindow-&gt;Frame().bottom);</a>
<a name="ln490"> </a>
<a name="ln491">	info.show_hide_level = fWindow-&gt;ShowLevel();</a>
<a name="ln492">	info.is_mini = fWindow-&gt;IsMinimized();</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495"> </a>
<a name="ln496">void</a>
<a name="ln497">ServerWindow::ResyncDrawState()</a>
<a name="ln498">{</a>
<a name="ln499">	_UpdateDrawState(fCurrentView);</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">View*</a>
<a name="ln504">ServerWindow::_CreateView(BPrivate::LinkReceiver&amp; link, View** _parent)</a>
<a name="ln505">{</a>
<a name="ln506">	// NOTE: no need to check for a lock. This is a private method.</a>
<a name="ln507"> </a>
<a name="ln508">	int32 token;</a>
<a name="ln509">	BRect frame;</a>
<a name="ln510">	uint32 resizeMask;</a>
<a name="ln511">	uint32 eventMask;</a>
<a name="ln512">	uint32 eventOptions;</a>
<a name="ln513">	uint32 flags;</a>
<a name="ln514">	bool hidden;</a>
<a name="ln515">	int32 parentToken;</a>
<a name="ln516">	char* name = NULL;</a>
<a name="ln517">	rgb_color viewColor;</a>
<a name="ln518">	BPoint scrollingOffset;</a>
<a name="ln519"> </a>
<a name="ln520">	link.Read&lt;int32&gt;(&amp;token);</a>
<a name="ln521">	link.ReadString(&amp;name);</a>
<a name="ln522">	link.Read&lt;BRect&gt;(&amp;frame);</a>
<a name="ln523">	link.Read&lt;BPoint&gt;(&amp;scrollingOffset);</a>
<a name="ln524">	link.Read&lt;uint32&gt;(&amp;resizeMask);</a>
<a name="ln525">	link.Read&lt;uint32&gt;(&amp;eventMask);</a>
<a name="ln526">	link.Read&lt;uint32&gt;(&amp;eventOptions);</a>
<a name="ln527">	link.Read&lt;uint32&gt;(&amp;flags);</a>
<a name="ln528">	link.Read&lt;bool&gt;(&amp;hidden);</a>
<a name="ln529">	link.Read&lt;rgb_color&gt;(&amp;viewColor);</a>
<a name="ln530">	link.Read&lt;int32&gt;(&amp;parentToken);</a>
<a name="ln531"> </a>
<a name="ln532">	STRACE((&quot;ServerWindow(%s)::_CreateView()-&gt; view %s, token %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln533">		fTitle, name, token));</a>
<a name="ln534"> </a>
<a name="ln535">	View* newView;</a>
<a name="ln536"> </a>
<a name="ln537">	if ((flags &amp; kWorkspacesViewFlag) != 0) {</a>
<a name="ln538">		newView = new (nothrow) WorkspacesView(frame, scrollingOffset, name,</a>
<a name="ln539">			token, resizeMask, flags);</a>
<a name="ln540">	} else {</a>
<a name="ln541">		newView = new (nothrow) View(frame, scrollingOffset, name, token,</a>
<a name="ln542">			resizeMask, flags);</a>
<a name="ln543">	}</a>
<a name="ln544"> </a>
<a name="ln545">	free(name);</a>
<a name="ln546"> </a>
<a name="ln547">	if (newView == NULL)</a>
<a name="ln548">		return NULL;</a>
<a name="ln549"> </a>
<a name="ln550">	if (newView-&gt;InitCheck() != B_OK) {</a>
<a name="ln551">		delete newView;</a>
<a name="ln552">		return NULL;</a>
<a name="ln553">	}</a>
<a name="ln554"> </a>
<a name="ln555">	// there is no way of setting this, other than manually :-)</a>
<a name="ln556">	newView-&gt;SetViewColor(viewColor);</a>
<a name="ln557">	newView-&gt;SetHidden(hidden);</a>
<a name="ln558">	newView-&gt;SetEventMask(eventMask, eventOptions);</a>
<a name="ln559"> </a>
<a name="ln560">	if (eventMask != 0 || eventOptions != 0) {</a>
<a name="ln561">//		fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln562">//		fDesktop-&gt;LockAllWindows();</a>
<a name="ln563">fDesktop-&gt;UnlockAllWindows();</a>
<a name="ln564">		// TODO: possible deadlock</a>
<a name="ln565">		fDesktop-&gt;EventDispatcher().AddListener(EventTarget(),</a>
<a name="ln566">			newView-&gt;Token(), eventMask, eventOptions);</a>
<a name="ln567">fDesktop-&gt;LockAllWindows();</a>
<a name="ln568">//		fDesktop-&gt;UnlockAllWindows();</a>
<a name="ln569">//		fDesktop-&gt;LockSingleWindow();</a>
<a name="ln570">	}</a>
<a name="ln571"> </a>
<a name="ln572">	// Initialize the view with the current application plain font.</a>
<a name="ln573">	// NOTE: This might be out of sync with the global app_server plain</a>
<a name="ln574">	// font, but that is so on purpose! The client needs to resync itself</a>
<a name="ln575">	// with the app_server fonts upon notification, but if we just use</a>
<a name="ln576">	// the current font here, the be_plain_font on the client may still</a>
<a name="ln577">	// hold old values. So this needs to be an update initiated by the</a>
<a name="ln578">	// client application.</a>
<a name="ln579">	newView-&gt;CurrentState()-&gt;SetFont(App()-&gt;PlainFont());</a>
<a name="ln580"> </a>
<a name="ln581">	if (_parent) {</a>
<a name="ln582">		View *parent;</a>
<a name="ln583">		if (App()-&gt;ViewTokens().GetToken(parentToken, B_HANDLER_TOKEN,</a>
<a name="ln584">				(void**)&amp;parent) != B_OK</a>
<a name="ln585">			|| parent-&gt;Window()-&gt;ServerWindow() != this) {</a>
<a name="ln586">			debug_printf(&quot;View token not found!\n&quot;);</a>
<a name="ln587">			parent = NULL;</a>
<a name="ln588">		}</a>
<a name="ln589"> </a>
<a name="ln590">		*_parent = parent;</a>
<a name="ln591">	}</a>
<a name="ln592"> </a>
<a name="ln593">	return newView;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596"> </a>
<a name="ln597">/*!	Dispatches all window messages, and those view messages that</a>
<a name="ln598">	don't need a valid fCurrentView (ie. view creation).</a>
<a name="ln599">*/</a>
<a name="ln600">void</a>
<a name="ln601">ServerWindow::_DispatchMessage(int32 code, BPrivate::LinkReceiver&amp; link)</a>
<a name="ln602">{</a>
<a name="ln603">	switch (code) {</a>
<a name="ln604">		case AS_SHOW_OR_HIDE_WINDOW:</a>
<a name="ln605">		{</a>
<a name="ln606">			int32 showLevel;</a>
<a name="ln607">			if (link.Read&lt;int32&gt;(&amp;showLevel) == B_OK) {</a>
<a name="ln608">				DTRACE((&quot;ServerWindow %s: Message AS_SHOW_OR_HIDE_WINDOW, &quot;</a>
<a name="ln609">					&quot;show level: %&quot; B_PRId32 &quot;\n&quot;, Title(), showLevel));</a>
<a name="ln610"> </a>
<a name="ln611">				fWindow-&gt;SetShowLevel(showLevel);</a>
<a name="ln612">				if (showLevel &lt;= 0)</a>
<a name="ln613">					_Show();</a>
<a name="ln614">				else</a>
<a name="ln615">					_Hide();</a>
<a name="ln616">			}</a>
<a name="ln617">			break;</a>
<a name="ln618">		}</a>
<a name="ln619">		// Only for internal use within this class</a>
<a name="ln620">		case AS_INTERNAL_HIDE_WINDOW:</a>
<a name="ln621">			_Hide();</a>
<a name="ln622">			break;</a>
<a name="ln623">		case AS_MINIMIZE_WINDOW:</a>
<a name="ln624">		{</a>
<a name="ln625">			bool minimize;</a>
<a name="ln626">			if (link.Read&lt;bool&gt;(&amp;minimize) == B_OK) {</a>
<a name="ln627">				DTRACE((&quot;ServerWindow %s: Message AS_MINIMIZE_WINDOW, &quot;</a>
<a name="ln628">					&quot;minimize: %d\n&quot;, Title(), minimize));</a>
<a name="ln629"> </a>
<a name="ln630">				fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln631">				fDesktop-&gt;MinimizeWindow(fWindow, minimize);</a>
<a name="ln632">				fDesktop-&gt;LockSingleWindow();</a>
<a name="ln633">			}</a>
<a name="ln634">			break;</a>
<a name="ln635">		}</a>
<a name="ln636"> </a>
<a name="ln637">		case AS_ACTIVATE_WINDOW:</a>
<a name="ln638">		{</a>
<a name="ln639">			bool activate = true;</a>
<a name="ln640">			if (link.Read&lt;bool&gt;(&amp;activate) != B_OK)</a>
<a name="ln641">				break;</a>
<a name="ln642"> </a>
<a name="ln643">			DTRACE((&quot;ServerWindow %s: Message AS_ACTIVATE_WINDOW: activate: &quot;</a>
<a name="ln644">				&quot;%d\n&quot;, Title(), activate));</a>
<a name="ln645"> </a>
<a name="ln646">			fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln647"> </a>
<a name="ln648">			if (activate)</a>
<a name="ln649">				fDesktop-&gt;SelectWindow(fWindow);</a>
<a name="ln650">			else</a>
<a name="ln651">				fDesktop-&gt;SendWindowBehind(fWindow, NULL);</a>
<a name="ln652"> </a>
<a name="ln653">			fDesktop-&gt;LockSingleWindow();</a>
<a name="ln654">			break;</a>
<a name="ln655">		}</a>
<a name="ln656">		case AS_SEND_BEHIND:</a>
<a name="ln657">		{</a>
<a name="ln658">			// Has the all-window lock</a>
<a name="ln659">			int32 token;</a>
<a name="ln660">			team_id teamID;</a>
<a name="ln661">			status_t status = B_ERROR;</a>
<a name="ln662"> </a>
<a name="ln663">			link.Read&lt;int32&gt;(&amp;token);</a>
<a name="ln664">			if (link.Read&lt;team_id&gt;(&amp;teamID) == B_OK) {</a>
<a name="ln665">				::Window* behindOf = fDesktop-&gt;FindWindowByClientToken(token,</a>
<a name="ln666">					teamID);</a>
<a name="ln667"> </a>
<a name="ln668">				DTRACE((&quot;ServerWindow %s: Message AS_SEND_BEHIND %s\n&quot;,</a>
<a name="ln669">					Title(), behindOf != NULL ? behindOf-&gt;Title() : &quot;NULL&quot;));</a>
<a name="ln670"> </a>
<a name="ln671">				if (behindOf != NULL || token == -1) {</a>
<a name="ln672">					fDesktop-&gt;SendWindowBehind(fWindow, behindOf);</a>
<a name="ln673">					status = B_OK;</a>
<a name="ln674">				} else</a>
<a name="ln675">					status = B_NAME_NOT_FOUND;</a>
<a name="ln676">			}</a>
<a name="ln677"> </a>
<a name="ln678">			fLink.StartMessage(status);</a>
<a name="ln679">			fLink.Flush();</a>
<a name="ln680">			break;</a>
<a name="ln681">		}</a>
<a name="ln682"> </a>
<a name="ln683">		case B_QUIT_REQUESTED:</a>
<a name="ln684">			DTRACE((&quot;ServerWindow %s received quit request\n&quot;, Title()));</a>
<a name="ln685">			NotifyQuitRequested();</a>
<a name="ln686">			break;</a>
<a name="ln687"> </a>
<a name="ln688">		case AS_ENABLE_UPDATES:</a>
<a name="ln689">			DTRACE((&quot;ServerWindow %s: Message AS_ENABLE_UPDATES\n&quot;, Title()));</a>
<a name="ln690">			fWindow-&gt;EnableUpdateRequests();</a>
<a name="ln691">			break;</a>
<a name="ln692"> </a>
<a name="ln693">		case AS_DISABLE_UPDATES:</a>
<a name="ln694">			DTRACE((&quot;ServerWindow %s: Message AS_DISABLE_UPDATES\n&quot;, Title()));</a>
<a name="ln695">			fWindow-&gt;DisableUpdateRequests();</a>
<a name="ln696">			break;</a>
<a name="ln697"> </a>
<a name="ln698">		case AS_NEEDS_UPDATE:</a>
<a name="ln699">			DTRACE((&quot;ServerWindow %s: Message AS_NEEDS_UPDATE: %d\n&quot;,</a>
<a name="ln700">				Title(), fWindow-&gt;NeedsUpdate()));</a>
<a name="ln701">			if (fWindow-&gt;NeedsUpdate())</a>
<a name="ln702">				fLink.StartMessage(B_OK);</a>
<a name="ln703">			else</a>
<a name="ln704">				fLink.StartMessage(B_ERROR);</a>
<a name="ln705">			fLink.Flush();</a>
<a name="ln706">			break;</a>
<a name="ln707"> </a>
<a name="ln708">		case AS_SET_WINDOW_TITLE:</a>
<a name="ln709">		{</a>
<a name="ln710">			char* newTitle;</a>
<a name="ln711">			if (link.ReadString(&amp;newTitle) == B_OK) {</a>
<a name="ln712">				DTRACE((&quot;ServerWindow %s: Message AS_SET_WINDOW_TITLE: %s\n&quot;,</a>
<a name="ln713">					Title(), newTitle));</a>
<a name="ln714"> </a>
<a name="ln715">				SetTitle(newTitle);</a>
<a name="ln716">				free(newTitle);</a>
<a name="ln717">			}</a>
<a name="ln718">			break;</a>
<a name="ln719">		}</a>
<a name="ln720"> </a>
<a name="ln721">		case AS_ADD_TO_SUBSET:</a>
<a name="ln722">		{</a>
<a name="ln723">			// Has the all-window lock</a>
<a name="ln724">			DTRACE((&quot;ServerWindow %s: Message AS_ADD_TO_SUBSET\n&quot;, Title()));</a>
<a name="ln725">			status_t status = B_ERROR;</a>
<a name="ln726"> </a>
<a name="ln727">			int32 token;</a>
<a name="ln728">			if (link.Read&lt;int32&gt;(&amp;token) == B_OK) {</a>
<a name="ln729">				::Window* window = fDesktop-&gt;FindWindowByClientToken(token,</a>
<a name="ln730">					App()-&gt;ClientTeam());</a>
<a name="ln731">				if (window == NULL || window-&gt;Feel() != B_NORMAL_WINDOW_FEEL) {</a>
<a name="ln732">					status = B_BAD_VALUE;</a>
<a name="ln733">				} else {</a>
<a name="ln734">					status = fDesktop-&gt;AddWindowToSubset(fWindow, window)</a>
<a name="ln735">						? B_OK : B_NO_MEMORY;</a>
<a name="ln736">				}</a>
<a name="ln737">			}</a>
<a name="ln738"> </a>
<a name="ln739">			fLink.StartMessage(status);</a>
<a name="ln740">			fLink.Flush();</a>
<a name="ln741">			break;</a>
<a name="ln742">		}</a>
<a name="ln743">		case AS_REMOVE_FROM_SUBSET:</a>
<a name="ln744">		{</a>
<a name="ln745">			// Has the all-window lock</a>
<a name="ln746">			DTRACE((&quot;ServerWindow %s: Message AS_REM_FROM_SUBSET\n&quot;, Title()));</a>
<a name="ln747">			status_t status = B_ERROR;</a>
<a name="ln748"> </a>
<a name="ln749">			int32 token;</a>
<a name="ln750">			if (link.Read&lt;int32&gt;(&amp;token) == B_OK) {</a>
<a name="ln751">				::Window* window = fDesktop-&gt;FindWindowByClientToken(token,</a>
<a name="ln752">					App()-&gt;ClientTeam());</a>
<a name="ln753">				if (window != NULL) {</a>
<a name="ln754">					fDesktop-&gt;RemoveWindowFromSubset(fWindow, window);</a>
<a name="ln755">					status = B_OK;</a>
<a name="ln756">				} else</a>
<a name="ln757">					status = B_BAD_VALUE;</a>
<a name="ln758">			}</a>
<a name="ln759"> </a>
<a name="ln760">			fLink.StartMessage(status);</a>
<a name="ln761">			fLink.Flush();</a>
<a name="ln762">			break;</a>
<a name="ln763">		}</a>
<a name="ln764"> </a>
<a name="ln765">		case AS_SET_LOOK:</a>
<a name="ln766">		{</a>
<a name="ln767">			// Has the all-window look</a>
<a name="ln768">			DTRACE((&quot;ServerWindow %s: Message AS_SET_LOOK\n&quot;, Title()));</a>
<a name="ln769"> </a>
<a name="ln770">			status_t status = B_ERROR;</a>
<a name="ln771">			int32 look;</a>
<a name="ln772">			if (link.Read&lt;int32&gt;(&amp;look) == B_OK) {</a>
<a name="ln773">				// test if look is valid</a>
<a name="ln774">				status = Window::IsValidLook((window_look)look)</a>
<a name="ln775">					? B_OK : B_BAD_VALUE;</a>
<a name="ln776">			}</a>
<a name="ln777"> </a>
<a name="ln778">			if (status == B_OK &amp;&amp; !fWindow-&gt;IsOffscreenWindow())</a>
<a name="ln779">				fDesktop-&gt;SetWindowLook(fWindow, (window_look)look);</a>
<a name="ln780"> </a>
<a name="ln781">			fLink.StartMessage(status);</a>
<a name="ln782">			fLink.Flush();</a>
<a name="ln783">			break;</a>
<a name="ln784">		}</a>
<a name="ln785">		case AS_SET_FEEL:</a>
<a name="ln786">		{</a>
<a name="ln787">			// Has the all-window look</a>
<a name="ln788">			DTRACE((&quot;ServerWindow %s: Message AS_SET_FEEL\n&quot;, Title()));</a>
<a name="ln789"> </a>
<a name="ln790">			status_t status = B_ERROR;</a>
<a name="ln791">			int32 feel;</a>
<a name="ln792">			if (link.Read&lt;int32&gt;(&amp;feel) == B_OK) {</a>
<a name="ln793">				// test if feel is valid</a>
<a name="ln794">				status = Window::IsValidFeel((window_feel)feel)</a>
<a name="ln795">					? B_OK : B_BAD_VALUE;</a>
<a name="ln796">			}</a>
<a name="ln797"> </a>
<a name="ln798">			if (status == B_OK &amp;&amp; !fWindow-&gt;IsOffscreenWindow())</a>
<a name="ln799">				fDesktop-&gt;SetWindowFeel(fWindow, (window_feel)feel);</a>
<a name="ln800"> </a>
<a name="ln801">			fLink.StartMessage(status);</a>
<a name="ln802">			fLink.Flush();</a>
<a name="ln803">			break;</a>
<a name="ln804">		}</a>
<a name="ln805">		case AS_SET_FLAGS:</a>
<a name="ln806">		{</a>
<a name="ln807">			// Has the all-window look</a>
<a name="ln808">			DTRACE((&quot;ServerWindow %s: Message AS_SET_FLAGS\n&quot;, Title()));</a>
<a name="ln809"> </a>
<a name="ln810">			status_t status = B_ERROR;</a>
<a name="ln811">			uint32 flags;</a>
<a name="ln812">			if (link.Read&lt;uint32&gt;(&amp;flags) == B_OK) {</a>
<a name="ln813">				// test if flags are valid</a>
<a name="ln814">				status = (flags &amp; ~Window::ValidWindowFlags()) == 0</a>
<a name="ln815">					? B_OK : B_BAD_VALUE;</a>
<a name="ln816">			}</a>
<a name="ln817"> </a>
<a name="ln818">			if (status == B_OK &amp;&amp; !fWindow-&gt;IsOffscreenWindow())</a>
<a name="ln819">				fDesktop-&gt;SetWindowFlags(fWindow, flags);</a>
<a name="ln820"> </a>
<a name="ln821">			fLink.StartMessage(status);</a>
<a name="ln822">			fLink.Flush();</a>
<a name="ln823">			break;</a>
<a name="ln824">		}</a>
<a name="ln825">#if 0</a>
<a name="ln826">		case AS_SET_ALIGNMENT:</a>
<a name="ln827">		{</a>
<a name="ln828">			// TODO: Implement AS_SET_ALIGNMENT</a>
<a name="ln829">			DTRACE((&quot;ServerWindow %s: Message Set_Alignment unimplemented\n&quot;,</a>
<a name="ln830">				Title()));</a>
<a name="ln831">			break;</a>
<a name="ln832">		}</a>
<a name="ln833">		case AS_GET_ALIGNMENT:</a>
<a name="ln834">		{</a>
<a name="ln835">			// TODO: Implement AS_GET_ALIGNMENT</a>
<a name="ln836">			DTRACE((&quot;ServerWindow %s: Message Get_Alignment unimplemented\n&quot;,</a>
<a name="ln837">				Title()));</a>
<a name="ln838">			break;</a>
<a name="ln839">		}</a>
<a name="ln840">#endif</a>
<a name="ln841">		case AS_IS_FRONT_WINDOW:</a>
<a name="ln842">		{</a>
<a name="ln843">			bool isFront = fDesktop-&gt;FrontWindow() == fWindow;</a>
<a name="ln844">			DTRACE((&quot;ServerWindow %s: Message AS_IS_FRONT_WINDOW: %d\n&quot;,</a>
<a name="ln845">				Title(), isFront));</a>
<a name="ln846">			fLink.StartMessage(isFront ? B_OK : B_ERROR);</a>
<a name="ln847">			fLink.Flush();</a>
<a name="ln848">			break;</a>
<a name="ln849">		}</a>
<a name="ln850"> </a>
<a name="ln851">		case AS_GET_WORKSPACES:</a>
<a name="ln852">		{</a>
<a name="ln853">			DTRACE((&quot;ServerWindow %s: Message AS_GET_WORKSPACES\n&quot;, Title()));</a>
<a name="ln854">			fLink.StartMessage(B_OK);</a>
<a name="ln855">			fLink.Attach&lt;uint32&gt;(fWindow-&gt;Workspaces());</a>
<a name="ln856">			fLink.Flush();</a>
<a name="ln857">			break;</a>
<a name="ln858">		}</a>
<a name="ln859">		case AS_SET_WORKSPACES:</a>
<a name="ln860">		{</a>
<a name="ln861">			// Has the all-window lock (but would actually not need to lock at</a>
<a name="ln862">			// all)</a>
<a name="ln863">			uint32 newWorkspaces;</a>
<a name="ln864">			if (link.Read&lt;uint32&gt;(&amp;newWorkspaces) != B_OK)</a>
<a name="ln865">				break;</a>
<a name="ln866"> </a>
<a name="ln867">			DTRACE((&quot;ServerWindow %s: Message AS_SET_WORKSPACES %&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln868">				Title(), newWorkspaces));</a>
<a name="ln869"> </a>
<a name="ln870">			fDesktop-&gt;SetWindowWorkspaces(fWindow, newWorkspaces);</a>
<a name="ln871">			break;</a>
<a name="ln872">		}</a>
<a name="ln873">		case AS_WINDOW_RESIZE:</a>
<a name="ln874">		{</a>
<a name="ln875">			// Has the all-window look</a>
<a name="ln876">			float xResizeTo;</a>
<a name="ln877">			float yResizeTo;</a>
<a name="ln878">			link.Read&lt;float&gt;(&amp;xResizeTo);</a>
<a name="ln879">			if (link.Read&lt;float&gt;(&amp;yResizeTo) != B_OK)</a>
<a name="ln880">				break;</a>
<a name="ln881"> </a>
<a name="ln882">			DTRACE((&quot;ServerWindow %s: Message AS_WINDOW_RESIZE %.1f, %.1f\n&quot;,</a>
<a name="ln883">				Title(), xResizeTo, yResizeTo));</a>
<a name="ln884"> </a>
<a name="ln885">			// comment this code for the time being, as some apps rely</a>
<a name="ln886">			// on the programmatically resize behavior during user resize</a>
<a name="ln887">//			if (fWindow-&gt;IsResizing()) {</a>
<a name="ln888">				// While the user resizes the window, we ignore</a>
<a name="ln889">				// pragmatically set window bounds</a>
<a name="ln890">//				fLink.StartMessage(B_BUSY);</a>
<a name="ln891">//			} else {</a>
<a name="ln892">				fDesktop-&gt;ResizeWindowBy(fWindow,</a>
<a name="ln893">					xResizeTo - fWindow-&gt;Frame().Width(),</a>
<a name="ln894">					yResizeTo - fWindow-&gt;Frame().Height());</a>
<a name="ln895">				fLink.StartMessage(B_OK);</a>
<a name="ln896">//			}</a>
<a name="ln897">			fLink.Flush();</a>
<a name="ln898">			break;</a>
<a name="ln899">		}</a>
<a name="ln900">		case AS_WINDOW_MOVE:</a>
<a name="ln901">		{</a>
<a name="ln902">			// Has the all-window look</a>
<a name="ln903">			float xMoveTo;</a>
<a name="ln904">			float yMoveTo;</a>
<a name="ln905">			link.Read&lt;float&gt;(&amp;xMoveTo);</a>
<a name="ln906">			if (link.Read&lt;float&gt;(&amp;yMoveTo) != B_OK)</a>
<a name="ln907">				break;</a>
<a name="ln908"> </a>
<a name="ln909">			DTRACE((&quot;ServerWindow %s: Message AS_WINDOW_MOVE: %.1f, %.1f\n&quot;,</a>
<a name="ln910">				Title(), xMoveTo, yMoveTo));</a>
<a name="ln911"> </a>
<a name="ln912">			if (fWindow-&gt;IsDragging()) {</a>
<a name="ln913">				// While the user moves the window, we ignore</a>
<a name="ln914">				// pragmatically set window positions</a>
<a name="ln915">				fLink.StartMessage(B_BUSY);</a>
<a name="ln916">			} else {</a>
<a name="ln917">				fDesktop-&gt;MoveWindowBy(fWindow, xMoveTo - fWindow-&gt;Frame().left,</a>
<a name="ln918">					yMoveTo - fWindow-&gt;Frame().top);</a>
<a name="ln919">				fLink.StartMessage(B_OK);</a>
<a name="ln920">			}</a>
<a name="ln921">			fLink.Flush();</a>
<a name="ln922">			break;</a>
<a name="ln923">		}</a>
<a name="ln924">		case AS_SET_SIZE_LIMITS:</a>
<a name="ln925">		{</a>
<a name="ln926">			// Has the all-window look</a>
<a name="ln927"> </a>
<a name="ln928">			// Attached Data:</a>
<a name="ln929">			// 1) float minimum width</a>
<a name="ln930">			// 2) float maximum width</a>
<a name="ln931">			// 3) float minimum height</a>
<a name="ln932">			// 4) float maximum height</a>
<a name="ln933"> </a>
<a name="ln934">			// TODO: for now, move the client to int32 as well!</a>
<a name="ln935">			int32 minWidth, maxWidth, minHeight, maxHeight;</a>
<a name="ln936">			float value;</a>
<a name="ln937">			link.Read&lt;float&gt;(&amp;value);	minWidth = (int32)value;</a>
<a name="ln938">			link.Read&lt;float&gt;(&amp;value);	maxWidth = (int32)value;</a>
<a name="ln939">			link.Read&lt;float&gt;(&amp;value);	minHeight = (int32)value;</a>
<a name="ln940">			link.Read&lt;float&gt;(&amp;value);	maxHeight = (int32)value;</a>
<a name="ln941">/*</a>
<a name="ln942">			link.Read&lt;int32&gt;(&amp;minWidth);</a>
<a name="ln943">			link.Read&lt;int32&gt;(&amp;maxWidth);</a>
<a name="ln944">			link.Read&lt;int32&gt;(&amp;minHeight);</a>
<a name="ln945">			link.Read&lt;int32&gt;(&amp;maxHeight);</a>
<a name="ln946">*/</a>
<a name="ln947">			DTRACE((&quot;ServerWindow %s: Message AS_SET_SIZE_LIMITS: &quot;</a>
<a name="ln948">				&quot;x: %&quot; B_PRId32 &quot;-%&quot; B_PRId32 &quot;, y: %&quot; B_PRId32 &quot;-%&quot; B_PRId32</a>
<a name="ln949">				&quot;\n&quot;, Title(), minWidth, maxWidth, minHeight, maxHeight));</a>
<a name="ln950"> </a>
<a name="ln951">			fWindow-&gt;SetSizeLimits(minWidth, maxWidth, minHeight, maxHeight);</a>
<a name="ln952"> </a>
<a name="ln953">			// and now, sync the client to the limits that we were able to enforce</a>
<a name="ln954">			fWindow-&gt;GetSizeLimits(&amp;minWidth, &amp;maxWidth,</a>
<a name="ln955">				&amp;minHeight, &amp;maxHeight);</a>
<a name="ln956"> </a>
<a name="ln957">			fLink.StartMessage(B_OK);</a>
<a name="ln958">			fLink.Attach&lt;BRect&gt;(fWindow-&gt;Frame());</a>
<a name="ln959">			fLink.Attach&lt;float&gt;((float)minWidth);</a>
<a name="ln960">			fLink.Attach&lt;float&gt;((float)maxWidth);</a>
<a name="ln961">			fLink.Attach&lt;float&gt;((float)minHeight);</a>
<a name="ln962">			fLink.Attach&lt;float&gt;((float)maxHeight);</a>
<a name="ln963"> </a>
<a name="ln964">			fLink.Flush();</a>
<a name="ln965"> </a>
<a name="ln966">			fDesktop-&gt;NotifySizeLimitsChanged(fWindow, minWidth, maxWidth,</a>
<a name="ln967">				minHeight, maxHeight);</a>
<a name="ln968">			break;</a>
<a name="ln969">		}</a>
<a name="ln970"> </a>
<a name="ln971">		case AS_SET_DECORATOR_SETTINGS:</a>
<a name="ln972">		{</a>
<a name="ln973">			// Has the all-window look</a>
<a name="ln974">			DTRACE((&quot;ServerWindow %s: Message AS_SET_DECORATOR_SETTINGS\n&quot;,</a>
<a name="ln975">				Title()));</a>
<a name="ln976"> </a>
<a name="ln977">			int32 size;</a>
<a name="ln978">			if (fWindow &amp;&amp; link.Read&lt;int32&gt;(&amp;size) == B_OK) {</a>
<a name="ln979">				char buffer[size];</a>
<a name="ln980">				if (link.Read(buffer, size) == B_OK) {</a>
<a name="ln981">					BMessage settings;</a>
<a name="ln982">					if (settings.Unflatten(buffer) == B_OK)</a>
<a name="ln983">						fDesktop-&gt;SetWindowDecoratorSettings(fWindow, settings);</a>
<a name="ln984">				}</a>
<a name="ln985">			}</a>
<a name="ln986">			break;</a>
<a name="ln987">		}</a>
<a name="ln988"> </a>
<a name="ln989">		case AS_GET_DECORATOR_SETTINGS:</a>
<a name="ln990">		{</a>
<a name="ln991">			DTRACE((&quot;ServerWindow %s: Message AS_GET_DECORATOR_SETTINGS\n&quot;,</a>
<a name="ln992">				Title()));</a>
<a name="ln993"> </a>
<a name="ln994">			bool success = false;</a>
<a name="ln995"> </a>
<a name="ln996">			BMessage settings;</a>
<a name="ln997">			if (fWindow-&gt;GetDecoratorSettings(&amp;settings)) {</a>
<a name="ln998">				int32 size = settings.FlattenedSize();</a>
<a name="ln999">				char buffer[size];</a>
<a name="ln1000">				if (settings.Flatten(buffer, size) == B_OK) {</a>
<a name="ln1001">					success = true;</a>
<a name="ln1002">					fLink.StartMessage(B_OK);</a>
<a name="ln1003">					fLink.Attach&lt;int32&gt;(size);</a>
<a name="ln1004">					fLink.Attach(buffer, size);</a>
<a name="ln1005">				}</a>
<a name="ln1006">			}</a>
<a name="ln1007"> </a>
<a name="ln1008">			if (!success)</a>
<a name="ln1009">				fLink.StartMessage(B_ERROR);</a>
<a name="ln1010"> </a>
<a name="ln1011">			fLink.Flush();</a>
<a name="ln1012">			break;</a>
<a name="ln1013">		}</a>
<a name="ln1014"> </a>
<a name="ln1015">		case AS_SYSTEM_FONT_CHANGED:</a>
<a name="ln1016">		{</a>
<a name="ln1017">			// Has the all-window look</a>
<a name="ln1018">			fDesktop-&gt;FontsChanged(fWindow);</a>
<a name="ln1019">			break;</a>
<a name="ln1020">		}</a>
<a name="ln1021"> </a>
<a name="ln1022">		// Forward to client</a>
<a name="ln1023">		case B_FONTS_UPDATED:</a>
<a name="ln1024">		{</a>
<a name="ln1025">			// TODO: would knowing which font was changed be useful?</a>
<a name="ln1026">			BMessage message(code);</a>
<a name="ln1027">			SendMessageToClient(&amp;message);</a>
<a name="ln1028">			break;</a>
<a name="ln1029">		}</a>
<a name="ln1030"> </a>
<a name="ln1031">		case AS_REDRAW:</a>
<a name="ln1032">			// Nothing to do here - the redraws are actually handled by looking</a>
<a name="ln1033">			// at the fRedrawRequested member variable in _MessageLooper().</a>
<a name="ln1034">			break;</a>
<a name="ln1035"> </a>
<a name="ln1036">		case AS_SYNC:</a>
<a name="ln1037">			DTRACE((&quot;ServerWindow %s: Message AS_SYNC\n&quot;, Title()));</a>
<a name="ln1038">			// the synchronisation works by the fact that the client</a>
<a name="ln1039">			// window is waiting for this reply, after having received it,</a>
<a name="ln1040">			// client and server queues are in sync (earlier, the client</a>
<a name="ln1041">			// may have pushed drawing commands at the server and now it</a>
<a name="ln1042">			// knows they have all been carried out)</a>
<a name="ln1043">			fLink.StartMessage(B_OK);</a>
<a name="ln1044">			fLink.Flush();</a>
<a name="ln1045">			break;</a>
<a name="ln1046"> </a>
<a name="ln1047">		case AS_BEGIN_UPDATE:</a>
<a name="ln1048">			DTRACE((&quot;ServerWindow %s: Message AS_BEGIN_UPDATE\n&quot;, Title()));</a>
<a name="ln1049">			fWindow-&gt;BeginUpdate(fLink);</a>
<a name="ln1050">			break;</a>
<a name="ln1051"> </a>
<a name="ln1052">		case AS_END_UPDATE:</a>
<a name="ln1053">			DTRACE((&quot;ServerWindow %s: Message AS_END_UPDATE\n&quot;, Title()));</a>
<a name="ln1054">			fWindow-&gt;EndUpdate();</a>
<a name="ln1055">			break;</a>
<a name="ln1056"> </a>
<a name="ln1057">		case AS_GET_MOUSE:</a>
<a name="ln1058">		{</a>
<a name="ln1059">			// Has the all-window look</a>
<a name="ln1060">			DTRACE((&quot;ServerWindow %s: Message AS_GET_MOUSE\n&quot;, fTitle));</a>
<a name="ln1061"> </a>
<a name="ln1062">			// Returns</a>
<a name="ln1063">			// 1) BPoint mouse location</a>
<a name="ln1064">			// 2) int32 button state</a>
<a name="ln1065"> </a>
<a name="ln1066">			BPoint where;</a>
<a name="ln1067">			int32 buttons;</a>
<a name="ln1068">			fDesktop-&gt;GetLastMouseState(&amp;where, &amp;buttons);</a>
<a name="ln1069"> </a>
<a name="ln1070">			fLink.StartMessage(B_OK);</a>
<a name="ln1071">			fLink.Attach&lt;BPoint&gt;(where);</a>
<a name="ln1072">			fLink.Attach&lt;int32&gt;(buttons);</a>
<a name="ln1073">			fLink.Flush();</a>
<a name="ln1074">			break;</a>
<a name="ln1075">		}</a>
<a name="ln1076"> </a>
<a name="ln1077">		// BDirectWindow communication</a>
<a name="ln1078"> </a>
<a name="ln1079">		case AS_DIRECT_WINDOW_GET_SYNC_DATA:</a>
<a name="ln1080">		{</a>
<a name="ln1081">			status_t status = _EnableDirectWindowMode();</a>
<a name="ln1082"> </a>
<a name="ln1083">			fLink.StartMessage(status);</a>
<a name="ln1084">			if (status == B_OK) {</a>
<a name="ln1085">				struct direct_window_sync_data syncData;</a>
<a name="ln1086">				fDirectWindowInfo-&gt;GetSyncData(syncData);</a>
<a name="ln1087"> </a>
<a name="ln1088">				fLink.Attach(&amp;syncData, sizeof(syncData));</a>
<a name="ln1089">			}</a>
<a name="ln1090"> </a>
<a name="ln1091">			fLink.Flush();</a>
<a name="ln1092">			break;</a>
<a name="ln1093">		}</a>
<a name="ln1094">		case AS_DIRECT_WINDOW_SET_FULLSCREEN:</a>
<a name="ln1095">		{</a>
<a name="ln1096">			// Has the all-window look</a>
<a name="ln1097">			bool enable;</a>
<a name="ln1098">			link.Read&lt;bool&gt;(&amp;enable);</a>
<a name="ln1099"> </a>
<a name="ln1100">			status_t status = B_OK;</a>
<a name="ln1101">			if (fDirectWindowInfo != NULL)</a>
<a name="ln1102">				_DirectWindowSetFullScreen(enable);</a>
<a name="ln1103">			else</a>
<a name="ln1104">				status = B_BAD_TYPE;</a>
<a name="ln1105"> </a>
<a name="ln1106">			fLink.StartMessage(status);</a>
<a name="ln1107">			fLink.Flush();</a>
<a name="ln1108">			break;</a>
<a name="ln1109">		}</a>
<a name="ln1110"> </a>
<a name="ln1111">		// View creation and destruction (don't need a valid fCurrentView)</a>
<a name="ln1112"> </a>
<a name="ln1113">		case AS_SET_CURRENT_VIEW:</a>
<a name="ln1114">		{</a>
<a name="ln1115">			int32 token;</a>
<a name="ln1116">			if (link.Read&lt;int32&gt;(&amp;token) != B_OK)</a>
<a name="ln1117">				break;</a>
<a name="ln1118"> </a>
<a name="ln1119">			View *current;</a>
<a name="ln1120">			if (App()-&gt;ViewTokens().GetToken(token, B_HANDLER_TOKEN,</a>
<a name="ln1121">					(void**)&amp;current) != B_OK</a>
<a name="ln1122">				|| current-&gt;Window()-&gt;ServerWindow() != this) {</a>
<a name="ln1123">				// TODO: if this happens, we probably want to kill the app and</a>
<a name="ln1124">				// clean up</a>
<a name="ln1125">				debug_printf(&quot;ServerWindow %s: Message &quot;</a>
<a name="ln1126">					&quot;\n\n\nAS_SET_CURRENT_VIEW: view not found, token %&quot;</a>
<a name="ln1127">					B_PRId32 &quot;\n&quot;, fTitle, token);</a>
<a name="ln1128">				current = NULL;</a>
<a name="ln1129">			} else {</a>
<a name="ln1130">				DTRACE((&quot;\n\n\nServerWindow %s: Message AS_SET_CURRENT_VIEW: %s, &quot;</a>
<a name="ln1131">					&quot;token %&quot; B_PRId32 &quot;\n&quot;, fTitle, current-&gt;Name(), token));</a>
<a name="ln1132">				_SetCurrentView(current);</a>
<a name="ln1133">			}</a>
<a name="ln1134">			break;</a>
<a name="ln1135">		}</a>
<a name="ln1136"> </a>
<a name="ln1137">		case AS_VIEW_CREATE_ROOT:</a>
<a name="ln1138">		{</a>
<a name="ln1139">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_CREATE_ROOT\n&quot;, fTitle));</a>
<a name="ln1140"> </a>
<a name="ln1141">			// Start receiving top_view data -- pass NULL as the parent view.</a>
<a name="ln1142">			// This should be the *only* place where this happens.</a>
<a name="ln1143">			if (fCurrentView != NULL) {</a>
<a name="ln1144">				debug_printf(&quot;ServerWindow %s: Message &quot;</a>
<a name="ln1145">					&quot;AS_VIEW_CREATE_ROOT: fCurrentView already set!!\n&quot;,</a>
<a name="ln1146">					fTitle);</a>
<a name="ln1147">				break;</a>
<a name="ln1148">			}</a>
<a name="ln1149"> </a>
<a name="ln1150">			_SetCurrentView(_CreateView(link, NULL));</a>
<a name="ln1151">			fWindow-&gt;SetTopView(fCurrentView);</a>
<a name="ln1152">			break;</a>
<a name="ln1153">		}</a>
<a name="ln1154"> </a>
<a name="ln1155">		case AS_VIEW_CREATE:</a>
<a name="ln1156">		{</a>
<a name="ln1157">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_CREATE: View name: &quot;</a>
<a name="ln1158">				&quot;%s\n&quot;, fTitle, fCurrentView-&gt;Name()));</a>
<a name="ln1159"> </a>
<a name="ln1160">			View* parent = NULL;</a>
<a name="ln1161">			View* newView = _CreateView(link, &amp;parent);</a>
<a name="ln1162">			if (parent != NULL &amp;&amp; newView != NULL)</a>
<a name="ln1163">				parent-&gt;AddChild(newView);</a>
<a name="ln1164">			else {</a>
<a name="ln1165">				delete newView;</a>
<a name="ln1166">				debug_printf(&quot;ServerWindow %s: Message AS_VIEW_CREATE: &quot;</a>
<a name="ln1167">					&quot;parent or newView NULL!!\n&quot;, fTitle);</a>
<a name="ln1168">			}</a>
<a name="ln1169">			break;</a>
<a name="ln1170">		}</a>
<a name="ln1171"> </a>
<a name="ln1172">		case AS_TALK_TO_DESKTOP_LISTENER:</a>
<a name="ln1173">		{</a>
<a name="ln1174">			if (fDesktop-&gt;MessageForListener(fWindow, fLink.Receiver(),</a>
<a name="ln1175">				fLink.Sender()))</a>
<a name="ln1176">				break;</a>
<a name="ln1177">			// unhandled message at least send an error if needed</a>
<a name="ln1178">			if (link.NeedsReply()) {</a>
<a name="ln1179">				fLink.StartMessage(B_ERROR);</a>
<a name="ln1180">				fLink.Flush();</a>
<a name="ln1181">			}</a>
<a name="ln1182">			break;</a>
<a name="ln1183">		}</a>
<a name="ln1184"> </a>
<a name="ln1185">		default:</a>
<a name="ln1186">			if (fCurrentView == NULL) {</a>
<a name="ln1187">				BString codeName;</a>
<a name="ln1188">				string_for_message_code(code, codeName);</a>
<a name="ln1189">				debug_printf(&quot;ServerWindow %s received unexpected code - &quot;</a>
<a name="ln1190">					&quot;message '%s' before top_view attached.\n&quot;,</a>
<a name="ln1191">					Title(), codeName.String());</a>
<a name="ln1192">				if (link.NeedsReply()) {</a>
<a name="ln1193">					fLink.StartMessage(B_ERROR);</a>
<a name="ln1194">					fLink.Flush();</a>
<a name="ln1195">				}</a>
<a name="ln1196">				return;</a>
<a name="ln1197">			}</a>
<a name="ln1198"> </a>
<a name="ln1199">			_DispatchViewMessage(code, link);</a>
<a name="ln1200">			break;</a>
<a name="ln1201">	}</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204"> </a>
<a name="ln1205">/*!</a>
<a name="ln1206">	Dispatches all view messages that need a valid fCurrentView.</a>
<a name="ln1207">*/</a>
<a name="ln1208">void</a>
<a name="ln1209">ServerWindow::_DispatchViewMessage(int32 code,</a>
<a name="ln1210">	BPrivate::LinkReceiver &amp;link)</a>
<a name="ln1211">{</a>
<a name="ln1212">	if (_DispatchPictureMessage(code, link))</a>
<a name="ln1213">		return;</a>
<a name="ln1214"> </a>
<a name="ln1215">	switch (code) {</a>
<a name="ln1216">		case AS_VIEW_SCROLL:</a>
<a name="ln1217">		{</a>
<a name="ln1218">			float dh;</a>
<a name="ln1219">			float dv;</a>
<a name="ln1220">			link.Read&lt;float&gt;(&amp;dh);</a>
<a name="ln1221">			if (link.Read&lt;float&gt;(&amp;dv) != B_OK)</a>
<a name="ln1222">				break;</a>
<a name="ln1223"> </a>
<a name="ln1224">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SCROLL: View name: &quot;</a>
<a name="ln1225">				&quot;%s, %.1f x %.1f\n&quot;, fTitle, fCurrentView-&gt;Name(), dh, dv));</a>
<a name="ln1226">			fWindow-&gt;ScrollViewBy(fCurrentView, dh, dv);</a>
<a name="ln1227">			break;</a>
<a name="ln1228">		}</a>
<a name="ln1229">		case AS_VIEW_COPY_BITS:</a>
<a name="ln1230">		{</a>
<a name="ln1231">			BRect src;</a>
<a name="ln1232">			BRect dst;</a>
<a name="ln1233"> </a>
<a name="ln1234">			link.Read&lt;BRect&gt;(&amp;src);</a>
<a name="ln1235">			if (link.Read&lt;BRect&gt;(&amp;dst) != B_OK)</a>
<a name="ln1236">				break;</a>
<a name="ln1237"> </a>
<a name="ln1238">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_COPY_BITS: View name: &quot;</a>
<a name="ln1239">				&quot;%s, BRect(%.1f, %.1f, %.1f, %.1f) -&gt; &quot;</a>
<a name="ln1240">				&quot;BRect(%.1f, %.1f, %.1f, %.1f)\n&quot;, fTitle,</a>
<a name="ln1241">				fCurrentView-&gt;Name(), src.left, src.top, src.right, src.bottom,</a>
<a name="ln1242">				dst.left, dst.top, dst.right, dst.bottom));</a>
<a name="ln1243"> </a>
<a name="ln1244">			BRegion contentRegion;</a>
<a name="ln1245">			// TODO: avoid copy operation maybe?</a>
<a name="ln1246">			fWindow-&gt;GetContentRegion(&amp;contentRegion);</a>
<a name="ln1247">			fCurrentView-&gt;CopyBits(src, dst, contentRegion);</a>
<a name="ln1248">			break;</a>
<a name="ln1249">		}</a>
<a name="ln1250">		case AS_VIEW_DELETE:</a>
<a name="ln1251">		{</a>
<a name="ln1252">			// Received when a view is detached from a window</a>
<a name="ln1253"> </a>
<a name="ln1254">			int32 token;</a>
<a name="ln1255">			if (link.Read&lt;int32&gt;(&amp;token) != B_OK)</a>
<a name="ln1256">				break;</a>
<a name="ln1257"> </a>
<a name="ln1258">			View *view;</a>
<a name="ln1259">			if (App()-&gt;ViewTokens().GetToken(token, B_HANDLER_TOKEN,</a>
<a name="ln1260">					(void**)&amp;view) == B_OK</a>
<a name="ln1261">				&amp;&amp; view-&gt;Window()-&gt;ServerWindow() == this) {</a>
<a name="ln1262">				View* parent = view-&gt;Parent();</a>
<a name="ln1263"> </a>
<a name="ln1264">				DTRACE((&quot;ServerWindow %s: AS_VIEW_DELETE view: %p, &quot;</a>
<a name="ln1265">					&quot;parent: %p\n&quot;, fTitle, view, parent));</a>
<a name="ln1266"> </a>
<a name="ln1267">				if (parent != NULL) {</a>
<a name="ln1268">					parent-&gt;RemoveChild(view);</a>
<a name="ln1269"> </a>
<a name="ln1270">					if (view-&gt;EventMask() != 0) {</a>
<a name="ln1271">						// TODO: possible deadlock (event dispatcher already</a>
<a name="ln1272">						// locked itself, waits for Desktop write lock, but</a>
<a name="ln1273">						// we have it, now we are trying to lock the event</a>
<a name="ln1274">						// dispatcher -&gt; deadlock)</a>
<a name="ln1275">fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln1276">						fDesktop-&gt;EventDispatcher().RemoveListener(</a>
<a name="ln1277">							EventTarget(), token);</a>
<a name="ln1278">fDesktop-&gt;LockSingleWindow();</a>
<a name="ln1279">					}</a>
<a name="ln1280"> </a>
<a name="ln1281">					if (fCurrentView == view || fCurrentView-&gt;HasParent(view))</a>
<a name="ln1282">						_SetCurrentView(parent);</a>
<a name="ln1283"> </a>
<a name="ln1284">					delete view;</a>
<a name="ln1285">				} // else we don't delete the root view</a>
<a name="ln1286">			}</a>
<a name="ln1287">			break;</a>
<a name="ln1288">		}</a>
<a name="ln1289">		case AS_VIEW_SET_STATE:</a>
<a name="ln1290">		{</a>
<a name="ln1291">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_STATE: &quot;</a>
<a name="ln1292">				&quot;View name: %s\n&quot;, fTitle, fCurrentView-&gt;Name()));</a>
<a name="ln1293"> </a>
<a name="ln1294">			fCurrentView-&gt;CurrentState()-&gt;ReadFromLink(link);</a>
<a name="ln1295">			// TODO: When is this used?!?</a>
<a name="ln1296">			fCurrentView-&gt;RebuildClipping(true);</a>
<a name="ln1297">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1298"> </a>
<a name="ln1299">			break;</a>
<a name="ln1300">		}</a>
<a name="ln1301">		case AS_VIEW_SET_FONT_STATE:</a>
<a name="ln1302">		{</a>
<a name="ln1303">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_FONT_STATE: &quot;</a>
<a name="ln1304">				&quot;View name: %s\n&quot;, fTitle, fCurrentView-&gt;Name()));</a>
<a name="ln1305"> </a>
<a name="ln1306">			fCurrentView-&gt;CurrentState()-&gt;ReadFontFromLink(link);</a>
<a name="ln1307">			fWindow-&gt;GetDrawingEngine()-&gt;SetFont(</a>
<a name="ln1308">				fCurrentView-&gt;CurrentState());</a>
<a name="ln1309">			break;</a>
<a name="ln1310">		}</a>
<a name="ln1311">		case AS_VIEW_GET_STATE:</a>
<a name="ln1312">		{</a>
<a name="ln1313">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_STATE: &quot;</a>
<a name="ln1314">				&quot;View name: %s\n&quot;, fTitle, fCurrentView-&gt;Name()));</a>
<a name="ln1315"> </a>
<a name="ln1316">			fLink.StartMessage(B_OK);</a>
<a name="ln1317"> </a>
<a name="ln1318">			// attach state data</a>
<a name="ln1319">			fCurrentView-&gt;CurrentState()-&gt;WriteToLink(fLink.Sender());</a>
<a name="ln1320">			fLink.Flush();</a>
<a name="ln1321">			break;</a>
<a name="ln1322">		}</a>
<a name="ln1323">		case AS_VIEW_SET_EVENT_MASK:</a>
<a name="ln1324">		{</a>
<a name="ln1325">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_EVENT_MASK: &quot;</a>
<a name="ln1326">				&quot;View name: %s\n&quot;, fTitle, fCurrentView-&gt;Name()));</a>
<a name="ln1327">			uint32 eventMask, options;</a>
<a name="ln1328"> </a>
<a name="ln1329">			link.Read&lt;uint32&gt;(&amp;eventMask);</a>
<a name="ln1330">			if (link.Read&lt;uint32&gt;(&amp;options) == B_OK) {</a>
<a name="ln1331">				fCurrentView-&gt;SetEventMask(eventMask, options);</a>
<a name="ln1332"> </a>
<a name="ln1333">fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln1334">				// TODO: possible deadlock!</a>
<a name="ln1335">				if (eventMask != 0 || options != 0) {</a>
<a name="ln1336">					fDesktop-&gt;EventDispatcher().AddListener(EventTarget(),</a>
<a name="ln1337">						fCurrentView-&gt;Token(), eventMask, options);</a>
<a name="ln1338">				} else {</a>
<a name="ln1339">					fDesktop-&gt;EventDispatcher().RemoveListener(EventTarget(),</a>
<a name="ln1340">						fCurrentView-&gt;Token());</a>
<a name="ln1341">				}</a>
<a name="ln1342">fDesktop-&gt;LockSingleWindow();</a>
<a name="ln1343">			}</a>
<a name="ln1344">			break;</a>
<a name="ln1345">		}</a>
<a name="ln1346">		case AS_VIEW_SET_MOUSE_EVENT_MASK:</a>
<a name="ln1347">		{</a>
<a name="ln1348">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_MOUSE_EVENT_MASK: &quot;</a>
<a name="ln1349">				&quot;View name: %s\n&quot;, fTitle, fCurrentView-&gt;Name()));</a>
<a name="ln1350">			uint32 eventMask, options;</a>
<a name="ln1351"> </a>
<a name="ln1352">			link.Read&lt;uint32&gt;(&amp;eventMask);</a>
<a name="ln1353">			if (link.Read&lt;uint32&gt;(&amp;options) == B_OK) {</a>
<a name="ln1354">fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln1355">				// TODO: possible deadlock</a>
<a name="ln1356">				if (eventMask != 0 || options != 0) {</a>
<a name="ln1357">					if (options &amp; B_LOCK_WINDOW_FOCUS)</a>
<a name="ln1358">						fDesktop-&gt;SetFocusLocked(fWindow);</a>
<a name="ln1359">					fDesktop-&gt;EventDispatcher().AddTemporaryListener(EventTarget(),</a>
<a name="ln1360">						fCurrentView-&gt;Token(), eventMask, options);</a>
<a name="ln1361">				} else {</a>
<a name="ln1362">					fDesktop-&gt;EventDispatcher().RemoveTemporaryListener(EventTarget(),</a>
<a name="ln1363">						fCurrentView-&gt;Token());</a>
<a name="ln1364">				}</a>
<a name="ln1365">fDesktop-&gt;LockSingleWindow();</a>
<a name="ln1366">			}</a>
<a name="ln1367"> </a>
<a name="ln1368">			// TODO: support B_LOCK_WINDOW_FOCUS option in Desktop</a>
<a name="ln1369">			break;</a>
<a name="ln1370">		}</a>
<a name="ln1371">		case AS_VIEW_MOVE_TO:</a>
<a name="ln1372">		{</a>
<a name="ln1373">			float x, y;</a>
<a name="ln1374">			link.Read&lt;float&gt;(&amp;x);</a>
<a name="ln1375">			if (link.Read&lt;float&gt;(&amp;y) != B_OK)</a>
<a name="ln1376">				break;</a>
<a name="ln1377"> </a>
<a name="ln1378">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_MOVE_TO: View name: &quot;</a>
<a name="ln1379">				&quot;%s, x: %.1f, y: %.1f\n&quot;, fTitle, fCurrentView-&gt;Name(), x, y));</a>
<a name="ln1380"> </a>
<a name="ln1381">			float offsetX = x - fCurrentView-&gt;Frame().left;</a>
<a name="ln1382">			float offsetY = y - fCurrentView-&gt;Frame().top;</a>
<a name="ln1383"> </a>
<a name="ln1384">			BRegion dirty;</a>
<a name="ln1385">			fCurrentView-&gt;MoveBy(offsetX, offsetY, &amp;dirty);</a>
<a name="ln1386"> </a>
<a name="ln1387">			// TODO: think about how to avoid this hack:</a>
<a name="ln1388">			// the parent clipping needs to be updated, it is not</a>
<a name="ln1389">			// done in MoveBy() since it would cause</a>
<a name="ln1390">			// too much computations when children are resized because</a>
<a name="ln1391">			// follow modes</a>
<a name="ln1392">			if (View* parent = fCurrentView-&gt;Parent())</a>
<a name="ln1393">				parent-&gt;RebuildClipping(false);</a>
<a name="ln1394"> </a>
<a name="ln1395">			fWindow-&gt;MarkContentDirty(dirty);</a>
<a name="ln1396">			break;</a>
<a name="ln1397">		}</a>
<a name="ln1398">		case AS_VIEW_RESIZE_TO:</a>
<a name="ln1399">		{</a>
<a name="ln1400">			float newWidth, newHeight;</a>
<a name="ln1401">			link.Read&lt;float&gt;(&amp;newWidth);</a>
<a name="ln1402">			if (link.Read&lt;float&gt;(&amp;newHeight) != B_OK)</a>
<a name="ln1403">				break;</a>
<a name="ln1404"> </a>
<a name="ln1405">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_RESIZE_TO: View name: &quot;</a>
<a name="ln1406">				&quot;%s, width: %.1f, height: %.1f\n&quot;, fTitle,</a>
<a name="ln1407">				fCurrentView-&gt;Name(), newWidth, newHeight));</a>
<a name="ln1408"> </a>
<a name="ln1409">			float deltaWidth = newWidth - fCurrentView-&gt;Frame().Width();</a>
<a name="ln1410">			float deltaHeight = newHeight - fCurrentView-&gt;Frame().Height();</a>
<a name="ln1411"> </a>
<a name="ln1412">			BRegion dirty;</a>
<a name="ln1413">			fCurrentView-&gt;ResizeBy(deltaWidth, deltaHeight, &amp;dirty);</a>
<a name="ln1414"> </a>
<a name="ln1415">			// TODO: see above</a>
<a name="ln1416">			if (View* parent = fCurrentView-&gt;Parent())</a>
<a name="ln1417">				parent-&gt;RebuildClipping(false);</a>
<a name="ln1418"> </a>
<a name="ln1419">			fWindow-&gt;MarkContentDirty(dirty);</a>
<a name="ln1420">			break;</a>
<a name="ln1421">		}</a>
<a name="ln1422">		case AS_VIEW_GET_COORD:</a>
<a name="ln1423">		{</a>
<a name="ln1424">			// our offset in the parent -&gt; will be originX and originY</a>
<a name="ln1425">			// in BView</a>
<a name="ln1426">			BPoint parentOffset = fCurrentView-&gt;Frame().LeftTop();</a>
<a name="ln1427"> </a>
<a name="ln1428">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_COORD: &quot;</a>
<a name="ln1429">				&quot;View: %s -&gt; x: %.1f, y: %.1f\n&quot;, Title(),</a>
<a name="ln1430">				fCurrentView-&gt;Name(), parentOffset.x, parentOffset.y));</a>
<a name="ln1431"> </a>
<a name="ln1432">			fLink.StartMessage(B_OK);</a>
<a name="ln1433">			fLink.Attach&lt;BPoint&gt;(parentOffset);</a>
<a name="ln1434">			fLink.Attach&lt;BRect&gt;(fCurrentView-&gt;Bounds());</a>
<a name="ln1435">			fLink.Flush();</a>
<a name="ln1436">			break;</a>
<a name="ln1437">		}</a>
<a name="ln1438">		case AS_VIEW_SET_ORIGIN:</a>
<a name="ln1439">		{</a>
<a name="ln1440">			float x, y;</a>
<a name="ln1441">			link.Read&lt;float&gt;(&amp;x);</a>
<a name="ln1442">			if (link.Read&lt;float&gt;(&amp;y) != B_OK)</a>
<a name="ln1443">				break;</a>
<a name="ln1444"> </a>
<a name="ln1445">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_ORIGIN: &quot;</a>
<a name="ln1446">				&quot;View: %s -&gt; x: %.1f, y: %.1f\n&quot;, Title(),</a>
<a name="ln1447">				fCurrentView-&gt;Name(), x, y));</a>
<a name="ln1448"> </a>
<a name="ln1449">			fCurrentView-&gt;SetDrawingOrigin(BPoint(x, y));</a>
<a name="ln1450">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1451">			break;</a>
<a name="ln1452">		}</a>
<a name="ln1453">		case AS_VIEW_GET_ORIGIN:</a>
<a name="ln1454">		{</a>
<a name="ln1455">			BPoint drawingOrigin = fCurrentView-&gt;DrawingOrigin();</a>
<a name="ln1456"> </a>
<a name="ln1457">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_ORIGIN: &quot;</a>
<a name="ln1458">				&quot;View: %s -&gt; x: %.1f, y: %.1f\n&quot;, Title(),</a>
<a name="ln1459">				fCurrentView-&gt;Name(), drawingOrigin.x, drawingOrigin.y));</a>
<a name="ln1460"> </a>
<a name="ln1461">			fLink.StartMessage(B_OK);</a>
<a name="ln1462">			fLink.Attach&lt;BPoint&gt;(drawingOrigin);</a>
<a name="ln1463">			fLink.Flush();</a>
<a name="ln1464">			break;</a>
<a name="ln1465">		}</a>
<a name="ln1466">		case AS_VIEW_RESIZE_MODE:</a>
<a name="ln1467">		{</a>
<a name="ln1468">			uint32 resizeMode;</a>
<a name="ln1469">			if (link.Read&lt;uint32&gt;(&amp;resizeMode) != B_OK)</a>
<a name="ln1470">				break;</a>
<a name="ln1471"> </a>
<a name="ln1472">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_RESIZE_MODE: &quot;</a>
<a name="ln1473">				&quot;View: %s -&gt; %&quot; B_PRId32 &quot;\n&quot;, Title(), fCurrentView-&gt;Name(),</a>
<a name="ln1474">				resizeMode));</a>
<a name="ln1475"> </a>
<a name="ln1476">			fCurrentView-&gt;SetResizeMode(resizeMode);</a>
<a name="ln1477">			break;</a>
<a name="ln1478">		}</a>
<a name="ln1479">		case AS_VIEW_SET_FLAGS:</a>
<a name="ln1480">		{</a>
<a name="ln1481">			uint32 flags;</a>
<a name="ln1482">			link.Read&lt;uint32&gt;(&amp;flags);</a>
<a name="ln1483"> </a>
<a name="ln1484">			// The views clipping changes when the B_DRAW_ON_CHILDREN flag is</a>
<a name="ln1485">			// toggled.</a>
<a name="ln1486">			bool updateClipping = (flags &amp; B_DRAW_ON_CHILDREN)</a>
<a name="ln1487">				^ (fCurrentView-&gt;Flags() &amp; B_DRAW_ON_CHILDREN);</a>
<a name="ln1488"> </a>
<a name="ln1489">			fCurrentView-&gt;SetFlags(flags);</a>
<a name="ln1490">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1491"> </a>
<a name="ln1492">			if (updateClipping) {</a>
<a name="ln1493">				fCurrentView-&gt;RebuildClipping(false);</a>
<a name="ln1494">				fCurrentDrawingRegionValid = false;</a>
<a name="ln1495">			}</a>
<a name="ln1496"> </a>
<a name="ln1497">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_FLAGS: &quot;</a>
<a name="ln1498">				&quot;View: %s -&gt; flags: %&quot; B_PRIu32 &quot;\n&quot;, Title(),</a>
<a name="ln1499">				fCurrentView-&gt;Name(), flags));</a>
<a name="ln1500">			break;</a>
<a name="ln1501">		}</a>
<a name="ln1502">		case AS_VIEW_HIDE:</a>
<a name="ln1503">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_HIDE: View: %s\n&quot;,</a>
<a name="ln1504">				Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1505">			fCurrentView-&gt;SetHidden(true);</a>
<a name="ln1506">			break;</a>
<a name="ln1507"> </a>
<a name="ln1508">		case AS_VIEW_SHOW:</a>
<a name="ln1509">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SHOW: View: %s\n&quot;,</a>
<a name="ln1510">				Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1511">			fCurrentView-&gt;SetHidden(false);</a>
<a name="ln1512">			break;</a>
<a name="ln1513"> </a>
<a name="ln1514">		case AS_VIEW_SET_LINE_MODE:</a>
<a name="ln1515">		{</a>
<a name="ln1516">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_LINE_MODE: &quot;</a>
<a name="ln1517">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1518">			ViewSetLineModeInfo info;</a>
<a name="ln1519">			if (link.Read&lt;ViewSetLineModeInfo&gt;(&amp;info) != B_OK)</a>
<a name="ln1520">				break;</a>
<a name="ln1521"> </a>
<a name="ln1522">			fCurrentView-&gt;CurrentState()-&gt;SetLineCapMode(info.lineCap);</a>
<a name="ln1523">			fCurrentView-&gt;CurrentState()-&gt;SetLineJoinMode(info.lineJoin);</a>
<a name="ln1524">			fCurrentView-&gt;CurrentState()-&gt;SetMiterLimit(info.miterLimit);</a>
<a name="ln1525"> </a>
<a name="ln1526">			fWindow-&gt;GetDrawingEngine()-&gt;SetStrokeMode(info.lineCap,</a>
<a name="ln1527">				info.lineJoin, info.miterLimit);</a>
<a name="ln1528"> </a>
<a name="ln1529">			break;</a>
<a name="ln1530">		}</a>
<a name="ln1531">		case AS_VIEW_GET_LINE_MODE:</a>
<a name="ln1532">		{</a>
<a name="ln1533">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_LINE_MODE: &quot;</a>
<a name="ln1534">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1535">			ViewSetLineModeInfo info;</a>
<a name="ln1536">			info.lineJoin = fCurrentView-&gt;CurrentState()-&gt;LineJoinMode();</a>
<a name="ln1537">			info.lineCap = fCurrentView-&gt;CurrentState()-&gt;LineCapMode();</a>
<a name="ln1538">			info.miterLimit = fCurrentView-&gt;CurrentState()-&gt;MiterLimit();</a>
<a name="ln1539"> </a>
<a name="ln1540">			fLink.StartMessage(B_OK);</a>
<a name="ln1541">			fLink.Attach&lt;ViewSetLineModeInfo&gt;(info);</a>
<a name="ln1542">			fLink.Flush();</a>
<a name="ln1543"> </a>
<a name="ln1544">			break;</a>
<a name="ln1545">		}</a>
<a name="ln1546">		case AS_VIEW_SET_FILL_RULE:</a>
<a name="ln1547">		{</a>
<a name="ln1548">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_FILL_RULE: &quot;</a>
<a name="ln1549">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1550">			int32 fillRule;</a>
<a name="ln1551">			if (link.Read&lt;int32&gt;(&amp;fillRule) != B_OK)</a>
<a name="ln1552">				break;</a>
<a name="ln1553"> </a>
<a name="ln1554">			fCurrentView-&gt;CurrentState()-&gt;SetFillRule(fillRule);</a>
<a name="ln1555">			fWindow-&gt;GetDrawingEngine()-&gt;SetFillRule(fillRule);</a>
<a name="ln1556"> </a>
<a name="ln1557">			break;</a>
<a name="ln1558">		}</a>
<a name="ln1559">		case AS_VIEW_GET_FILL_RULE:</a>
<a name="ln1560">		{</a>
<a name="ln1561">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_FILL_RULE: &quot;</a>
<a name="ln1562">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1563">			int32 fillRule = fCurrentView-&gt;CurrentState()-&gt;FillRule();</a>
<a name="ln1564"> </a>
<a name="ln1565">			fLink.StartMessage(B_OK);</a>
<a name="ln1566">			fLink.Attach&lt;int32&gt;(fillRule);</a>
<a name="ln1567">			fLink.Flush();</a>
<a name="ln1568"> </a>
<a name="ln1569">			break;</a>
<a name="ln1570">		}</a>
<a name="ln1571">		case AS_VIEW_PUSH_STATE:</a>
<a name="ln1572">		{</a>
<a name="ln1573">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_PUSH_STATE: View: &quot;</a>
<a name="ln1574">				&quot;%s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1575"> </a>
<a name="ln1576">			fCurrentView-&gt;PushState();</a>
<a name="ln1577">			// TODO: is this necessary?</a>
<a name="ln1578">//			_UpdateDrawState(fCurrentView);</a>
<a name="ln1579">			break;</a>
<a name="ln1580">		}</a>
<a name="ln1581">		case AS_VIEW_POP_STATE:</a>
<a name="ln1582">		{</a>
<a name="ln1583">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_POP_STATE: View: %s\n&quot;,</a>
<a name="ln1584">				Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1585"> </a>
<a name="ln1586">			fCurrentView-&gt;PopState();</a>
<a name="ln1587">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1588">			break;</a>
<a name="ln1589">		}</a>
<a name="ln1590">		case AS_VIEW_SET_SCALE:</a>
<a name="ln1591">		{</a>
<a name="ln1592">			float scale;</a>
<a name="ln1593">			if (link.Read&lt;float&gt;(&amp;scale) != B_OK)</a>
<a name="ln1594">				break;</a>
<a name="ln1595"> </a>
<a name="ln1596">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_SCALE: &quot;</a>
<a name="ln1597">				&quot;View: %s -&gt; scale: %.2f\n&quot;, Title(), fCurrentView-&gt;Name(),</a>
<a name="ln1598">				scale));</a>
<a name="ln1599"> </a>
<a name="ln1600">			fCurrentView-&gt;SetScale(scale);</a>
<a name="ln1601">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1602">			break;</a>
<a name="ln1603">		}</a>
<a name="ln1604">		case AS_VIEW_GET_SCALE:</a>
<a name="ln1605">		{</a>
<a name="ln1606">			float scale = fCurrentView-&gt;CurrentState()-&gt;Scale();</a>
<a name="ln1607"> </a>
<a name="ln1608">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_SCALE: &quot;</a>
<a name="ln1609">				&quot;View: %s -&gt; scale: %.2f\n&quot;,</a>
<a name="ln1610">				Title(), fCurrentView-&gt;Name(), scale));</a>
<a name="ln1611"> </a>
<a name="ln1612">			fLink.StartMessage(B_OK);</a>
<a name="ln1613">			fLink.Attach&lt;float&gt;(scale);</a>
<a name="ln1614">			fLink.Flush();</a>
<a name="ln1615">			break;</a>
<a name="ln1616">		}</a>
<a name="ln1617">		case AS_VIEW_SET_TRANSFORM:</a>
<a name="ln1618">		{</a>
<a name="ln1619">			BAffineTransform transform;</a>
<a name="ln1620">			if (link.Read&lt;BAffineTransform&gt;(&amp;transform) != B_OK)</a>
<a name="ln1621">				break;</a>
<a name="ln1622"> </a>
<a name="ln1623">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_TRANSFORM: &quot;</a>
<a name="ln1624">				&quot;View: %s -&gt; transform: %.2f, %.2f, %.2f, %.2f, %.2f, %.2f\n&quot;,</a>
<a name="ln1625">				Title(), fCurrentView-&gt;Name(), transform.sx, transform.shy,</a>
<a name="ln1626">				transform.shx, transform.sy, transform.tx, transform.ty));</a>
<a name="ln1627"> </a>
<a name="ln1628">			fCurrentView-&gt;CurrentState()-&gt;SetTransform(transform);</a>
<a name="ln1629">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1630">			break;</a>
<a name="ln1631">		}</a>
<a name="ln1632">		case AS_VIEW_GET_TRANSFORM:</a>
<a name="ln1633">		{</a>
<a name="ln1634">			BAffineTransform transform</a>
<a name="ln1635">				= fCurrentView-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln1636"> </a>
<a name="ln1637">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_TRANSFORM: &quot;</a>
<a name="ln1638">				&quot;View: %s -&gt; transform: %.2f, %.2f, %.2f, %.2f, %.2f, %.2f\n&quot;,</a>
<a name="ln1639">				Title(), fCurrentView-&gt;Name(), transform.sx, transform.shy,</a>
<a name="ln1640">				transform.shx, transform.sy, transform.tx, transform.ty));</a>
<a name="ln1641"> </a>
<a name="ln1642">			fLink.StartMessage(B_OK);</a>
<a name="ln1643">			fLink.Attach&lt;BAffineTransform&gt;(transform);</a>
<a name="ln1644">			fLink.Flush();</a>
<a name="ln1645">			break;</a>
<a name="ln1646">		}</a>
<a name="ln1647">		case AS_VIEW_AFFINE_TRANSLATE:</a>
<a name="ln1648">		{</a>
<a name="ln1649">			double x, y;</a>
<a name="ln1650">			link.Read&lt;double&gt;(&amp;x);</a>
<a name="ln1651">			link.Read&lt;double&gt;(&amp;y);</a>
<a name="ln1652">			BAffineTransform current =</a>
<a name="ln1653">				fCurrentView-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln1654">			current.PreTranslateBy(x, y);</a>
<a name="ln1655">			fCurrentView-&gt;CurrentState()-&gt;SetTransform(current);</a>
<a name="ln1656">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1657">			break;</a>
<a name="ln1658">		}</a>
<a name="ln1659"> </a>
<a name="ln1660">		case AS_VIEW_AFFINE_SCALE:</a>
<a name="ln1661">		{</a>
<a name="ln1662">			double x, y;</a>
<a name="ln1663">			link.Read&lt;double&gt;(&amp;x);</a>
<a name="ln1664">			link.Read&lt;double&gt;(&amp;y);</a>
<a name="ln1665">			BAffineTransform current =</a>
<a name="ln1666">				fCurrentView-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln1667">			current.PreScaleBy(x, y);</a>
<a name="ln1668">			fCurrentView-&gt;CurrentState()-&gt;SetTransform(current);</a>
<a name="ln1669">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1670">			break;</a>
<a name="ln1671">		}</a>
<a name="ln1672"> </a>
<a name="ln1673">		case AS_VIEW_AFFINE_ROTATE:</a>
<a name="ln1674">		{</a>
<a name="ln1675">			double angleRadians;</a>
<a name="ln1676">			link.Read&lt;double&gt;(&amp;angleRadians);</a>
<a name="ln1677">			BAffineTransform current =</a>
<a name="ln1678">				fCurrentView-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln1679">			current.PreRotateBy(angleRadians);</a>
<a name="ln1680">			fCurrentView-&gt;CurrentState()-&gt;SetTransform(current);</a>
<a name="ln1681">			_UpdateDrawState(fCurrentView);</a>
<a name="ln1682">			break;</a>
<a name="ln1683">		}</a>
<a name="ln1684"> </a>
<a name="ln1685">		case AS_VIEW_SET_PEN_LOC:</a>
<a name="ln1686">		{</a>
<a name="ln1687">			BPoint location;</a>
<a name="ln1688">			if (link.Read&lt;BPoint&gt;(&amp;location) != B_OK)</a>
<a name="ln1689">				break;</a>
<a name="ln1690"> </a>
<a name="ln1691">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_PEN_LOC: &quot;</a>
<a name="ln1692">				&quot;View: %s -&gt; BPoint(%.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln1693">				fCurrentView-&gt;Name(), location.x, location.y));</a>
<a name="ln1694"> </a>
<a name="ln1695">			fCurrentView-&gt;CurrentState()-&gt;SetPenLocation(location);</a>
<a name="ln1696">			break;</a>
<a name="ln1697">		}</a>
<a name="ln1698">		case AS_VIEW_GET_PEN_LOC:</a>
<a name="ln1699">		{</a>
<a name="ln1700">			BPoint location = fCurrentView-&gt;CurrentState()-&gt;PenLocation();</a>
<a name="ln1701"> </a>
<a name="ln1702">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_PEN_LOC: &quot;</a>
<a name="ln1703">				&quot;View: %s -&gt; BPoint(%.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln1704">				fCurrentView-&gt;Name(), location.x, location.y));</a>
<a name="ln1705"> </a>
<a name="ln1706">			fLink.StartMessage(B_OK);</a>
<a name="ln1707">			fLink.Attach&lt;BPoint&gt;(location);</a>
<a name="ln1708">			fLink.Flush();</a>
<a name="ln1709"> </a>
<a name="ln1710">			break;</a>
<a name="ln1711">		}</a>
<a name="ln1712">		case AS_VIEW_SET_PEN_SIZE:</a>
<a name="ln1713">		{</a>
<a name="ln1714">			float penSize;</a>
<a name="ln1715">			if (link.Read&lt;float&gt;(&amp;penSize) != B_OK)</a>
<a name="ln1716">				break;</a>
<a name="ln1717"> </a>
<a name="ln1718">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_PEN_SIZE: &quot;</a>
<a name="ln1719">				&quot;View: %s -&gt; %.1f\n&quot;, Title(), fCurrentView-&gt;Name(), penSize));</a>
<a name="ln1720"> </a>
<a name="ln1721">			fCurrentView-&gt;CurrentState()-&gt;SetPenSize(penSize);</a>
<a name="ln1722">			fWindow-&gt;GetDrawingEngine()-&gt;SetPenSize(</a>
<a name="ln1723">				fCurrentView-&gt;CurrentState()-&gt;PenSize());</a>
<a name="ln1724">			break;</a>
<a name="ln1725">		}</a>
<a name="ln1726">		case AS_VIEW_GET_PEN_SIZE:</a>
<a name="ln1727">		{</a>
<a name="ln1728">			float penSize = fCurrentView-&gt;CurrentState()-&gt;UnscaledPenSize();</a>
<a name="ln1729"> </a>
<a name="ln1730">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_PEN_SIZE: &quot;</a>
<a name="ln1731">				&quot;View: %s -&gt; %.1f\n&quot;, Title(), fCurrentView-&gt;Name(), penSize));</a>
<a name="ln1732"> </a>
<a name="ln1733">			fLink.StartMessage(B_OK);</a>
<a name="ln1734">			fLink.Attach&lt;float&gt;(penSize);</a>
<a name="ln1735">			fLink.Flush();</a>
<a name="ln1736"> </a>
<a name="ln1737">			break;</a>
<a name="ln1738">		}</a>
<a name="ln1739">		case AS_VIEW_SET_VIEW_COLOR:</a>
<a name="ln1740">		{</a>
<a name="ln1741">			rgb_color color;</a>
<a name="ln1742">			if (link.Read(&amp;color, sizeof(rgb_color)) != B_OK)</a>
<a name="ln1743">				break;</a>
<a name="ln1744"> </a>
<a name="ln1745">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_VIEW_COLOR: &quot;</a>
<a name="ln1746">				&quot;View: %s -&gt; rgb_color(%d, %d, %d, %d)\n&quot;, Title(),</a>
<a name="ln1747">				fCurrentView-&gt;Name(), color.red, color.green, color.blue,</a>
<a name="ln1748">				color.alpha));</a>
<a name="ln1749"> </a>
<a name="ln1750">			fCurrentView-&gt;SetViewColor(color);</a>
<a name="ln1751">			break;</a>
<a name="ln1752">		}</a>
<a name="ln1753">		case AS_VIEW_GET_VIEW_COLOR:</a>
<a name="ln1754">		{</a>
<a name="ln1755">			rgb_color color = fCurrentView-&gt;ViewColor();</a>
<a name="ln1756"> </a>
<a name="ln1757">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_VIEW_COLOR: &quot;</a>
<a name="ln1758">				&quot;View: %s -&gt; rgb_color(%d, %d, %d, %d)\n&quot;,</a>
<a name="ln1759">				Title(), fCurrentView-&gt;Name(), color.red, color.green,</a>
<a name="ln1760">				color.blue, color.alpha));</a>
<a name="ln1761"> </a>
<a name="ln1762">			fLink.StartMessage(B_OK);</a>
<a name="ln1763">			fLink.Attach&lt;rgb_color&gt;(color);</a>
<a name="ln1764">			fLink.Flush();</a>
<a name="ln1765">			break;</a>
<a name="ln1766">		}</a>
<a name="ln1767">		case AS_VIEW_SET_HIGH_COLOR:</a>
<a name="ln1768">		{</a>
<a name="ln1769">			rgb_color color;</a>
<a name="ln1770">			if (link.Read(&amp;color, sizeof(rgb_color)) != B_OK)</a>
<a name="ln1771">				break;</a>
<a name="ln1772"> </a>
<a name="ln1773">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_HIGH_COLOR: &quot;</a>
<a name="ln1774">				&quot;View: %s -&gt; rgb_color(%d, %d, %d, %d)\n&quot;,</a>
<a name="ln1775">				Title(), fCurrentView-&gt;Name(), color.red, color.green,</a>
<a name="ln1776">				color.blue, color.alpha));</a>
<a name="ln1777"> </a>
<a name="ln1778">			fCurrentView-&gt;CurrentState()-&gt;SetHighColor(color);</a>
<a name="ln1779">			fWindow-&gt;GetDrawingEngine()-&gt;SetHighColor(color);</a>
<a name="ln1780">			break;</a>
<a name="ln1781">		}</a>
<a name="ln1782"> </a>
<a name="ln1783">		case AS_VIEW_SET_HIGH_UI_COLOR:</a>
<a name="ln1784">		{</a>
<a name="ln1785">			color_which which = B_NO_COLOR;</a>
<a name="ln1786">			float tint = B_NO_TINT;</a>
<a name="ln1787"> </a>
<a name="ln1788">			if (link.Read&lt;color_which&gt;(&amp;which) != B_OK</a>
<a name="ln1789">				|| link.Read&lt;float&gt;(&amp;tint) != B_OK )</a>
<a name="ln1790">				break;</a>
<a name="ln1791"> </a>
<a name="ln1792">			fCurrentView-&gt;CurrentState()-&gt;SetHighUIColor(which, tint);</a>
<a name="ln1793"> </a>
<a name="ln1794">			// TODO: should we do more color_which validity checking?</a>
<a name="ln1795">			if (which != B_NO_COLOR) {</a>
<a name="ln1796">				DesktopSettings settings(fDesktop);</a>
<a name="ln1797">				rgb_color color = tint_color(settings.UIColor(which), tint);</a>
<a name="ln1798"> </a>
<a name="ln1799">				fCurrentView-&gt;CurrentState()-&gt;SetHighColor(color);</a>
<a name="ln1800">				fWindow-&gt;GetDrawingEngine()-&gt;SetHighColor(color);</a>
<a name="ln1801">			}</a>
<a name="ln1802">			break;</a>
<a name="ln1803">		}</a>
<a name="ln1804">		case AS_VIEW_SET_LOW_UI_COLOR:</a>
<a name="ln1805">		{</a>
<a name="ln1806">			color_which which = B_NO_COLOR;</a>
<a name="ln1807">			float tint = B_NO_TINT;</a>
<a name="ln1808"> </a>
<a name="ln1809">			if (link.Read&lt;color_which&gt;(&amp;which) != B_OK</a>
<a name="ln1810">				|| link.Read&lt;float&gt;(&amp;tint) != B_OK )</a>
<a name="ln1811">				break;</a>
<a name="ln1812"> </a>
<a name="ln1813">			fCurrentView-&gt;CurrentState()-&gt;SetLowUIColor(which, tint);</a>
<a name="ln1814"> </a>
<a name="ln1815">			// TODO: should we do more color_which validity checking?</a>
<a name="ln1816">			if (which != B_NO_COLOR) {</a>
<a name="ln1817">				DesktopSettings settings(fDesktop);</a>
<a name="ln1818">				rgb_color color = tint_color(settings.UIColor(which), tint);</a>
<a name="ln1819"> </a>
<a name="ln1820">				fCurrentView-&gt;CurrentState()-&gt;SetLowColor(color);</a>
<a name="ln1821">				fWindow-&gt;GetDrawingEngine()-&gt;SetLowColor(color);</a>
<a name="ln1822">			}</a>
<a name="ln1823">			break;</a>
<a name="ln1824">		}</a>
<a name="ln1825">		case AS_VIEW_SET_VIEW_UI_COLOR:</a>
<a name="ln1826">		{</a>
<a name="ln1827">			color_which which = B_NO_COLOR;</a>
<a name="ln1828">			float tint = B_NO_TINT;</a>
<a name="ln1829"> </a>
<a name="ln1830">			if (link.Read&lt;color_which&gt;(&amp;which) != B_OK</a>
<a name="ln1831">				|| link.Read&lt;float&gt;(&amp;tint) != B_OK )</a>
<a name="ln1832">				break;</a>
<a name="ln1833"> </a>
<a name="ln1834">			// TODO: should we do more color_which validity checking?</a>
<a name="ln1835">			fCurrentView-&gt;SetViewUIColor(which, tint);</a>
<a name="ln1836">			break;</a>
<a name="ln1837">		}</a>
<a name="ln1838">		case AS_VIEW_GET_HIGH_UI_COLOR:</a>
<a name="ln1839">		{</a>
<a name="ln1840">			float tint;</a>
<a name="ln1841">			color_which which = fCurrentView-&gt;CurrentState()-&gt;HighUIColor(&amp;tint);</a>
<a name="ln1842">			rgb_color color = fCurrentView-&gt;CurrentState()-&gt;HighColor();</a>
<a name="ln1843"> </a>
<a name="ln1844">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_HIGH_UI_COLOR: &quot;</a>
<a name="ln1845">				&quot;View: %s -&gt; color_which(%i) tint(%.3f) - rgb_color(%i, %i,&quot;</a>
<a name="ln1846">				&quot; %i, %i)\n&quot;, Title(), fCurrentView-&gt;Name(), which, tint,</a>
<a name="ln1847">				color.red, color.green, color.blue, color.alpha));</a>
<a name="ln1848"> </a>
<a name="ln1849">			fLink.StartMessage(B_OK);</a>
<a name="ln1850">			fLink.Attach&lt;color_which&gt;(which);</a>
<a name="ln1851">			fLink.Attach&lt;float&gt;(tint);</a>
<a name="ln1852">			fLink.Attach&lt;rgb_color&gt;(color);</a>
<a name="ln1853">			fLink.Flush();</a>
<a name="ln1854">			break;</a>
<a name="ln1855">		}</a>
<a name="ln1856">		case AS_VIEW_GET_LOW_UI_COLOR:</a>
<a name="ln1857">		{</a>
<a name="ln1858">			float tint;</a>
<a name="ln1859">			color_which which = fCurrentView-&gt;CurrentState()-&gt;LowUIColor(&amp;tint);</a>
<a name="ln1860">			rgb_color color = fCurrentView-&gt;CurrentState()-&gt;LowColor();</a>
<a name="ln1861"> </a>
<a name="ln1862">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_LOW_UI_COLOR: &quot;</a>
<a name="ln1863">				&quot;View: %s -&gt; color_which(%i) tint(%.3f) - rgb_color(%i, %i,&quot;</a>
<a name="ln1864">				&quot; %i, %i)\n&quot;, Title(), fCurrentView-&gt;Name(), which, tint,</a>
<a name="ln1865">				color.red, color.green, color.blue, color.alpha));</a>
<a name="ln1866"> </a>
<a name="ln1867">			fLink.StartMessage(B_OK);</a>
<a name="ln1868">			fLink.Attach&lt;color_which&gt;(which);</a>
<a name="ln1869">			fLink.Attach&lt;float&gt;(tint);</a>
<a name="ln1870">			fLink.Attach&lt;rgb_color&gt;(color);</a>
<a name="ln1871">			fLink.Flush();</a>
<a name="ln1872">			break;</a>
<a name="ln1873">		}</a>
<a name="ln1874">		case AS_VIEW_GET_VIEW_UI_COLOR:</a>
<a name="ln1875">		{</a>
<a name="ln1876">			float tint;</a>
<a name="ln1877">			color_which which = fCurrentView-&gt;ViewUIColor(&amp;tint);</a>
<a name="ln1878">			rgb_color color = fCurrentView-&gt;ViewColor();</a>
<a name="ln1879"> </a>
<a name="ln1880">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_VIEW_UI_COLOR: &quot;</a>
<a name="ln1881">				&quot;View: %s -&gt; color_which(%i) tint(%.3f) - rgb_color(%i, %i,&quot;</a>
<a name="ln1882">				&quot; %i, %i)\n&quot;, Title(), fCurrentView-&gt;Name(), which, tint,</a>
<a name="ln1883">				color.red, color.green, color.blue, color.alpha));</a>
<a name="ln1884"> </a>
<a name="ln1885">			fLink.StartMessage(B_OK);</a>
<a name="ln1886">			fLink.Attach&lt;color_which&gt;(which);</a>
<a name="ln1887">			fLink.Attach&lt;float&gt;(tint);</a>
<a name="ln1888">			fLink.Attach&lt;rgb_color&gt;(color);</a>
<a name="ln1889">			fLink.Flush();</a>
<a name="ln1890">			break;</a>
<a name="ln1891">		}</a>
<a name="ln1892">		case AS_VIEW_GET_HIGH_COLOR:</a>
<a name="ln1893">		{</a>
<a name="ln1894">			rgb_color color = fCurrentView-&gt;CurrentState()-&gt;HighColor();</a>
<a name="ln1895"> </a>
<a name="ln1896">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_HIGH_COLOR: &quot;</a>
<a name="ln1897">				&quot;View: %s -&gt; rgb_color(%d, %d, %d, %d)\n&quot;,</a>
<a name="ln1898">				Title(), fCurrentView-&gt;Name(), color.red, color.green,</a>
<a name="ln1899">				color.blue, color.alpha));</a>
<a name="ln1900"> </a>
<a name="ln1901">			fLink.StartMessage(B_OK);</a>
<a name="ln1902">			fLink.Attach&lt;rgb_color&gt;(color);</a>
<a name="ln1903">			fLink.Flush();</a>
<a name="ln1904">			break;</a>
<a name="ln1905">		}</a>
<a name="ln1906">		case AS_VIEW_SET_LOW_COLOR:</a>
<a name="ln1907">		{</a>
<a name="ln1908">			rgb_color color;</a>
<a name="ln1909">			if (link.Read(&amp;color, sizeof(rgb_color)) != B_OK)</a>
<a name="ln1910">				break;</a>
<a name="ln1911"> </a>
<a name="ln1912">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_LOW_COLOR: &quot;</a>
<a name="ln1913">				&quot;View: %s -&gt; rgb_color(%d, %d, %d, %d)\n&quot;,</a>
<a name="ln1914">				Title(), fCurrentView-&gt;Name(), color.red, color.green,</a>
<a name="ln1915">				color.blue, color.alpha));</a>
<a name="ln1916"> </a>
<a name="ln1917">			fCurrentView-&gt;CurrentState()-&gt;SetLowColor(color);</a>
<a name="ln1918">			fWindow-&gt;GetDrawingEngine()-&gt;SetLowColor(color);</a>
<a name="ln1919">			break;</a>
<a name="ln1920">		}</a>
<a name="ln1921">		case AS_VIEW_GET_LOW_COLOR:</a>
<a name="ln1922">		{</a>
<a name="ln1923">			rgb_color color = fCurrentView-&gt;CurrentState()-&gt;LowColor();</a>
<a name="ln1924"> </a>
<a name="ln1925">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_LOW_COLOR: &quot;</a>
<a name="ln1926">				&quot;View: %s -&gt; rgb_color(%d, %d, %d, %d)\n&quot;,</a>
<a name="ln1927">				Title(), fCurrentView-&gt;Name(), color.red, color.green,</a>
<a name="ln1928">				color.blue, color.alpha));</a>
<a name="ln1929"> </a>
<a name="ln1930">			fLink.StartMessage(B_OK);</a>
<a name="ln1931">			fLink.Attach&lt;rgb_color&gt;(color);</a>
<a name="ln1932">			fLink.Flush();</a>
<a name="ln1933">			break;</a>
<a name="ln1934">		}</a>
<a name="ln1935">		case AS_VIEW_SET_PATTERN:</a>
<a name="ln1936">		{</a>
<a name="ln1937">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_PATTERN: &quot;</a>
<a name="ln1938">				&quot;View: %s\n&quot;, fTitle, fCurrentView-&gt;Name()));</a>
<a name="ln1939"> </a>
<a name="ln1940">			pattern pat;</a>
<a name="ln1941">			if (link.Read(&amp;pat, sizeof(pattern)) != B_OK)</a>
<a name="ln1942">				break;</a>
<a name="ln1943"> </a>
<a name="ln1944">			fCurrentView-&gt;CurrentState()-&gt;SetPattern(Pattern(pat));</a>
<a name="ln1945">			fWindow-&gt;GetDrawingEngine()-&gt;SetPattern(pat);</a>
<a name="ln1946">			break;</a>
<a name="ln1947">		}</a>
<a name="ln1948"> </a>
<a name="ln1949">		case AS_VIEW_SET_BLENDING_MODE:</a>
<a name="ln1950">		{</a>
<a name="ln1951">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_BLEND_MODE: &quot;</a>
<a name="ln1952">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1953"> </a>
<a name="ln1954">			ViewBlendingModeInfo info;</a>
<a name="ln1955">			if (link.Read&lt;ViewBlendingModeInfo&gt;(&amp;info) != B_OK)</a>
<a name="ln1956">				break;</a>
<a name="ln1957"> </a>
<a name="ln1958">			fCurrentView-&gt;CurrentState()-&gt;SetBlendingMode(</a>
<a name="ln1959">				info.sourceAlpha, info.alphaFunction);</a>
<a name="ln1960">			fWindow-&gt;GetDrawingEngine()-&gt;SetBlendingMode(</a>
<a name="ln1961">				info.sourceAlpha, info.alphaFunction);</a>
<a name="ln1962">			break;</a>
<a name="ln1963">		}</a>
<a name="ln1964">		case AS_VIEW_GET_BLENDING_MODE:</a>
<a name="ln1965">		{</a>
<a name="ln1966">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_BLEND_MODE: &quot;</a>
<a name="ln1967">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln1968"> </a>
<a name="ln1969">			ViewBlendingModeInfo info;</a>
<a name="ln1970">			info.sourceAlpha = fCurrentView-&gt;CurrentState()-&gt;AlphaSrcMode();</a>
<a name="ln1971">			info.alphaFunction = fCurrentView-&gt;CurrentState()-&gt;AlphaFncMode();</a>
<a name="ln1972"> </a>
<a name="ln1973">			fLink.StartMessage(B_OK);</a>
<a name="ln1974">			fLink.Attach&lt;ViewBlendingModeInfo&gt;(info);</a>
<a name="ln1975">			fLink.Flush();</a>
<a name="ln1976"> </a>
<a name="ln1977">			break;</a>
<a name="ln1978">		}</a>
<a name="ln1979">		case AS_VIEW_SET_DRAWING_MODE:</a>
<a name="ln1980">		{</a>
<a name="ln1981">			int8 drawingMode;</a>
<a name="ln1982">			if (link.Read&lt;int8&gt;(&amp;drawingMode) != B_OK)</a>
<a name="ln1983">				break;</a>
<a name="ln1984"> </a>
<a name="ln1985">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_DRAW_MODE: &quot;</a>
<a name="ln1986">				&quot;View: %s -&gt; %s\n&quot;, Title(), fCurrentView-&gt;Name(),</a>
<a name="ln1987">				kDrawingModeMap[drawingMode]));</a>
<a name="ln1988"> </a>
<a name="ln1989">			fCurrentView-&gt;CurrentState()-&gt;SetDrawingMode(</a>
<a name="ln1990">				(drawing_mode)drawingMode);</a>
<a name="ln1991">			fWindow-&gt;GetDrawingEngine()-&gt;SetDrawingMode(</a>
<a name="ln1992">				(drawing_mode)drawingMode);</a>
<a name="ln1993">			break;</a>
<a name="ln1994">		}</a>
<a name="ln1995">		case AS_VIEW_GET_DRAWING_MODE:</a>
<a name="ln1996">		{</a>
<a name="ln1997">			int8 drawingMode</a>
<a name="ln1998">				= (int8)(fCurrentView-&gt;CurrentState()-&gt;GetDrawingMode());</a>
<a name="ln1999"> </a>
<a name="ln2000">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_DRAW_MODE: &quot;</a>
<a name="ln2001">				&quot;View: %s -&gt; %s\n&quot;, Title(), fCurrentView-&gt;Name(),</a>
<a name="ln2002">				kDrawingModeMap[drawingMode]));</a>
<a name="ln2003"> </a>
<a name="ln2004">			fLink.StartMessage(B_OK);</a>
<a name="ln2005">			fLink.Attach&lt;int8&gt;(drawingMode);</a>
<a name="ln2006">			fLink.Flush();</a>
<a name="ln2007"> </a>
<a name="ln2008">			break;</a>
<a name="ln2009">		}</a>
<a name="ln2010">		case AS_VIEW_SET_VIEW_BITMAP:</a>
<a name="ln2011">		{</a>
<a name="ln2012">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_VIEW_BITMAP: &quot;</a>
<a name="ln2013">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln2014"> </a>
<a name="ln2015">			int32 bitmapToken, resizingMode, options;</a>
<a name="ln2016">			BRect srcRect, dstRect;</a>
<a name="ln2017"> </a>
<a name="ln2018">			link.Read&lt;int32&gt;(&amp;bitmapToken);</a>
<a name="ln2019">			link.Read&lt;BRect&gt;(&amp;srcRect);</a>
<a name="ln2020">			link.Read&lt;BRect&gt;(&amp;dstRect);</a>
<a name="ln2021">			link.Read&lt;int32&gt;(&amp;resizingMode);</a>
<a name="ln2022">			status_t status = link.Read&lt;int32&gt;(&amp;options);</a>
<a name="ln2023"> </a>
<a name="ln2024">			rgb_color colorKey = {0};</a>
<a name="ln2025"> </a>
<a name="ln2026">			if (status == B_OK) {</a>
<a name="ln2027">				ServerBitmap* bitmap = fServerApp-&gt;GetBitmap(bitmapToken);</a>
<a name="ln2028">				if (bitmapToken == -1 || bitmap != NULL) {</a>
<a name="ln2029">					bool wasOverlay = fCurrentView-&gt;ViewBitmap() != NULL</a>
<a name="ln2030">						&amp;&amp; fCurrentView-&gt;ViewBitmap()-&gt;Overlay() != NULL;</a>
<a name="ln2031"> </a>
<a name="ln2032">					fCurrentView-&gt;SetViewBitmap(bitmap, srcRect, dstRect,</a>
<a name="ln2033">						resizingMode, options);</a>
<a name="ln2034"> </a>
<a name="ln2035">					// TODO: if we revert the view color overlay handling</a>
<a name="ln2036">					//	in View::Draw() to the BeOS version, we never</a>
<a name="ln2037">					//	need to invalidate the view for overlays.</a>
<a name="ln2038"> </a>
<a name="ln2039">					// Invalidate view - but only if this is a non-overlay</a>
<a name="ln2040">					// switch</a>
<a name="ln2041">					if (bitmap == NULL || bitmap-&gt;Overlay() == NULL</a>
<a name="ln2042">						|| !wasOverlay) {</a>
<a name="ln2043">						BRegion dirty((BRect)fCurrentView-&gt;Bounds());</a>
<a name="ln2044">						fWindow-&gt;InvalidateView(fCurrentView, dirty);</a>
<a name="ln2045">					}</a>
<a name="ln2046"> </a>
<a name="ln2047">					if (bitmap != NULL &amp;&amp; bitmap-&gt;Overlay() != NULL) {</a>
<a name="ln2048">						bitmap-&gt;Overlay()-&gt;SetFlags(options);</a>
<a name="ln2049">						colorKey = bitmap-&gt;Overlay()-&gt;Color();</a>
<a name="ln2050">					}</a>
<a name="ln2051"> </a>
<a name="ln2052">					if (bitmap != NULL)</a>
<a name="ln2053">						bitmap-&gt;ReleaseReference();</a>
<a name="ln2054">				} else</a>
<a name="ln2055">					status = B_BAD_VALUE;</a>
<a name="ln2056">			}</a>
<a name="ln2057"> </a>
<a name="ln2058">			fLink.StartMessage(status);</a>
<a name="ln2059">			if (status == B_OK &amp;&amp; (options &amp; AS_REQUEST_COLOR_KEY) != 0) {</a>
<a name="ln2060">				// Attach color key for the overlay bitmap</a>
<a name="ln2061">				fLink.Attach&lt;rgb_color&gt;(colorKey);</a>
<a name="ln2062">			}</a>
<a name="ln2063"> </a>
<a name="ln2064">			fLink.Flush();</a>
<a name="ln2065">			break;</a>
<a name="ln2066">		}</a>
<a name="ln2067">		case AS_VIEW_PRINT_ALIASING:</a>
<a name="ln2068">		{</a>
<a name="ln2069">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_PRINT_ALIASING: &quot;</a>
<a name="ln2070">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln2071"> </a>
<a name="ln2072">			bool fontAliasing;</a>
<a name="ln2073">			if (link.Read&lt;bool&gt;(&amp;fontAliasing) == B_OK) {</a>
<a name="ln2074">				fCurrentView-&gt;CurrentState()-&gt;SetForceFontAliasing(fontAliasing);</a>
<a name="ln2075">				_UpdateDrawState(fCurrentView);</a>
<a name="ln2076">			}</a>
<a name="ln2077">			break;</a>
<a name="ln2078">		}</a>
<a name="ln2079">		case AS_VIEW_CLIP_TO_PICTURE:</a>
<a name="ln2080">		{</a>
<a name="ln2081">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_CLIP_TO_PICTURE: &quot;</a>
<a name="ln2082">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln2083"> </a>
<a name="ln2084">			int32 pictureToken;</a>
<a name="ln2085">			BPoint where;</a>
<a name="ln2086">			bool inverse = false;</a>
<a name="ln2087"> </a>
<a name="ln2088">			link.Read&lt;int32&gt;(&amp;pictureToken);</a>
<a name="ln2089">			if (pictureToken &lt; 0) {</a>
<a name="ln2090">				fCurrentView-&gt;SetAlphaMask(NULL);</a>
<a name="ln2091">				_UpdateDrawState(fCurrentView);</a>
<a name="ln2092">				break;</a>
<a name="ln2093">			}</a>
<a name="ln2094"> </a>
<a name="ln2095">			link.Read&lt;BPoint&gt;(&amp;where);</a>
<a name="ln2096">			if (link.Read&lt;bool&gt;(&amp;inverse) != B_OK)</a>
<a name="ln2097">				break;</a>
<a name="ln2098"> </a>
<a name="ln2099">			ServerPicture* picture = fServerApp-&gt;GetPicture(pictureToken);</a>
<a name="ln2100">			if (picture == NULL)</a>
<a name="ln2101">				break;</a>
<a name="ln2102"> </a>
<a name="ln2103">			AlphaMask* const mask = new(std::nothrow) PictureAlphaMask(</a>
<a name="ln2104">				fCurrentView-&gt;GetAlphaMask(), picture,</a>
<a name="ln2105">				*fCurrentView-&gt;CurrentState(), where, inverse);</a>
<a name="ln2106">			fCurrentView-&gt;SetAlphaMask(mask);</a>
<a name="ln2107">			if (mask != NULL)</a>
<a name="ln2108">				mask-&gt;ReleaseReference();</a>
<a name="ln2109"> </a>
<a name="ln2110">			_UpdateDrawState(fCurrentView);</a>
<a name="ln2111"> </a>
<a name="ln2112">			picture-&gt;ReleaseReference();</a>
<a name="ln2113">			break;</a>
<a name="ln2114">		}</a>
<a name="ln2115"> </a>
<a name="ln2116">		case AS_VIEW_GET_CLIP_REGION:</a>
<a name="ln2117">		{</a>
<a name="ln2118">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_GET_CLIP_REGION: &quot;</a>
<a name="ln2119">				&quot;View: %s\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln2120"> </a>
<a name="ln2121">			// if this view is hidden, it has no visible region</a>
<a name="ln2122">			fLink.StartMessage(B_OK);</a>
<a name="ln2123">			if (!fWindow-&gt;IsVisible() || !fCurrentView-&gt;IsVisible()) {</a>
<a name="ln2124">				BRegion empty;</a>
<a name="ln2125">				fLink.AttachRegion(empty);</a>
<a name="ln2126">			} else {</a>
<a name="ln2127">				_UpdateCurrentDrawingRegion();</a>
<a name="ln2128">				BRegion region(fCurrentDrawingRegion);</a>
<a name="ln2129">				fCurrentView-&gt;ScreenToLocalTransform().Apply(&amp;region);</a>
<a name="ln2130">				fLink.AttachRegion(region);</a>
<a name="ln2131">			}</a>
<a name="ln2132">			fLink.Flush();</a>
<a name="ln2133"> </a>
<a name="ln2134">			break;</a>
<a name="ln2135">		}</a>
<a name="ln2136">		case AS_VIEW_SET_CLIP_REGION:</a>
<a name="ln2137">		{</a>
<a name="ln2138">			int32 rectCount;</a>
<a name="ln2139">			status_t status = link.Read&lt;int32&gt;(&amp;rectCount);</a>
<a name="ln2140">				// a negative count means no</a>
<a name="ln2141">				// region for the current draw state,</a>
<a name="ln2142">				// but an *empty* region is actually valid!</a>
<a name="ln2143">				// even if it means no drawing is allowed</a>
<a name="ln2144"> </a>
<a name="ln2145">			if (status &lt; B_OK)</a>
<a name="ln2146">				break;</a>
<a name="ln2147"> </a>
<a name="ln2148">			if (rectCount &gt;= 0) {</a>
<a name="ln2149">				// we are supposed to set the clipping region</a>
<a name="ln2150">				BRegion region;</a>
<a name="ln2151">				if (rectCount &gt; 0 &amp;&amp; link.ReadRegion(&amp;region) &lt; B_OK)</a>
<a name="ln2152">					break;</a>
<a name="ln2153"> </a>
<a name="ln2154">				DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_CLIP_REGION: &quot;</a>
<a name="ln2155">					&quot;View: %s -&gt; rect count: %&quot; B_PRId32 &quot;, frame = &quot;</a>
<a name="ln2156">					&quot;BRect(%.1f, %.1f, %.1f, %.1f)\n&quot;,</a>
<a name="ln2157">					Title(), fCurrentView-&gt;Name(), rectCount,</a>
<a name="ln2158">					region.Frame().left, region.Frame().top,</a>
<a name="ln2159">					region.Frame().right, region.Frame().bottom));</a>
<a name="ln2160"> </a>
<a name="ln2161">				fCurrentView-&gt;SetUserClipping(&amp;region);</a>
<a name="ln2162">			} else {</a>
<a name="ln2163">				// we are supposed to unset the clipping region</a>
<a name="ln2164">				// passing NULL sets this states region to that</a>
<a name="ln2165">				// of the previous state</a>
<a name="ln2166"> </a>
<a name="ln2167">				DTRACE((&quot;ServerWindow %s: Message AS_VIEW_SET_CLIP_REGION: &quot;</a>
<a name="ln2168">					&quot;View: %s -&gt; unset\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln2169"> </a>
<a name="ln2170">				fCurrentView-&gt;SetUserClipping(NULL);</a>
<a name="ln2171">			}</a>
<a name="ln2172">			fCurrentDrawingRegionValid = false;</a>
<a name="ln2173"> </a>
<a name="ln2174">			break;</a>
<a name="ln2175">		}</a>
<a name="ln2176"> </a>
<a name="ln2177">		case AS_VIEW_CLIP_TO_RECT:</a>
<a name="ln2178">		{</a>
<a name="ln2179">			bool inverse;</a>
<a name="ln2180">			BRect rect;</a>
<a name="ln2181"> </a>
<a name="ln2182">			link.Read&lt;bool&gt;(&amp;inverse);</a>
<a name="ln2183">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln2184"> </a>
<a name="ln2185">			bool needDrawStateUpdate = fCurrentView-&gt;ClipToRect(</a>
<a name="ln2186">				rect, inverse);</a>
<a name="ln2187">			fCurrentDrawingRegionValid = false;</a>
<a name="ln2188"> </a>
<a name="ln2189">			if (needDrawStateUpdate)</a>
<a name="ln2190">				_UpdateDrawState(fCurrentView);</a>
<a name="ln2191"> </a>
<a name="ln2192">			_UpdateCurrentDrawingRegion();</a>
<a name="ln2193"> </a>
<a name="ln2194">			BRegion region(fCurrentDrawingRegion);</a>
<a name="ln2195">			fCurrentView-&gt;ScreenToLocalTransform().Apply(&amp;region);</a>
<a name="ln2196"> </a>
<a name="ln2197">			break;</a>
<a name="ln2198">		}</a>
<a name="ln2199"> </a>
<a name="ln2200">		case AS_VIEW_CLIP_TO_SHAPE:</a>
<a name="ln2201">		{</a>
<a name="ln2202">			bool inverse;</a>
<a name="ln2203">			link.Read&lt;bool&gt;(&amp;inverse);</a>
<a name="ln2204"> </a>
<a name="ln2205">			shape_data shape;</a>
<a name="ln2206">			link.Read&lt;int32&gt;(&amp;shape.opCount);</a>
<a name="ln2207">			link.Read&lt;int32&gt;(&amp;shape.ptCount);</a>
<a name="ln2208">			shape.opSize = shape.opCount * sizeof(uint32);</a>
<a name="ln2209">			shape.ptSize = shape.ptCount * sizeof(BPoint);</a>
<a name="ln2210">			shape.opList = new(nothrow) uint32[shape.opCount];</a>
<a name="ln2211">			shape.ptList = new(nothrow) BPoint[shape.ptCount];</a>
<a name="ln2212">			if (link.Read(shape.opList, shape.opSize) &gt;= B_OK</a>
<a name="ln2213">				&amp;&amp; link.Read(shape.ptList, shape.ptSize) &gt;= B_OK) {</a>
<a name="ln2214">				fCurrentView-&gt;ClipToShape(&amp;shape, inverse);</a>
<a name="ln2215">				_UpdateDrawState(fCurrentView);</a>
<a name="ln2216">			}</a>
<a name="ln2217"> </a>
<a name="ln2218">			delete[] shape.opList;</a>
<a name="ln2219">			delete[] shape.ptList;</a>
<a name="ln2220">			break;</a>
<a name="ln2221">		}</a>
<a name="ln2222"> </a>
<a name="ln2223">		case AS_VIEW_INVALIDATE_RECT:</a>
<a name="ln2224">		{</a>
<a name="ln2225">			// NOTE: looks like this call is NOT affected by origin and scale</a>
<a name="ln2226">			// on R5 so this implementation is &quot;correct&quot;</a>
<a name="ln2227">			BRect invalidRect;</a>
<a name="ln2228">			if (link.Read&lt;BRect&gt;(&amp;invalidRect) == B_OK) {</a>
<a name="ln2229">				DTRACE((&quot;ServerWindow %s: Message AS_VIEW_INVALIDATE_RECT: &quot;</a>
<a name="ln2230">					&quot;View: %s -&gt; BRect(%.1f, %.1f, %.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln2231">					fCurrentView-&gt;Name(), invalidRect.left, invalidRect.top,</a>
<a name="ln2232">					invalidRect.right, invalidRect.bottom));</a>
<a name="ln2233"> </a>
<a name="ln2234">				View* view = NULL;</a>
<a name="ln2235">				if (link.Read&lt;View*&gt;(&amp;view) != B_OK)</a>
<a name="ln2236">					view = fCurrentView;</a>
<a name="ln2237"> </a>
<a name="ln2238">				// make sure the view is still available!</a>
<a name="ln2239">				if (view != fCurrentView</a>
<a name="ln2240">					&amp;&amp; !fWindow-&gt;TopView()-&gt;HasView(view))</a>
<a name="ln2241">					break;</a>
<a name="ln2242"> </a>
<a name="ln2243">				BRegion dirty(invalidRect);</a>
<a name="ln2244">				fWindow-&gt;InvalidateView(view, dirty);</a>
<a name="ln2245">			}</a>
<a name="ln2246">			break;</a>
<a name="ln2247">		}</a>
<a name="ln2248"> </a>
<a name="ln2249">		case AS_VIEW_DELAYED_INVALIDATE_RECT:</a>
<a name="ln2250">		{</a>
<a name="ln2251">			bigtime_t time = 0;</a>
<a name="ln2252">			BRect invalidRect;</a>
<a name="ln2253">			if (link.Read&lt;bigtime_t&gt;(&amp;time) == B_OK</a>
<a name="ln2254">				&amp;&amp; link.Read&lt;BRect&gt;(&amp;invalidRect) == B_OK) {</a>
<a name="ln2255">				DTRACE((&quot;ServerWindow %s: Message &quot;</a>
<a name="ln2256">					&quot;AS_VIEW_DELAYED_INVALIDATE_RECT: &quot;</a>
<a name="ln2257">					&quot;View: %s -&gt; BRect(%.1f, %.1f, %.1f, %.1f) at time %llu\n&quot;,</a>
<a name="ln2258">					Title(), fCurrentView-&gt;Name(), invalidRect.left,</a>
<a name="ln2259">					invalidRect.top, invalidRect.right, invalidRect.bottom,</a>
<a name="ln2260">					time));</a>
<a name="ln2261"> </a>
<a name="ln2262">				DelayedMessage delayed(AS_VIEW_INVALIDATE_RECT, time, true);</a>
<a name="ln2263">				delayed.AddTarget(MessagePort());</a>
<a name="ln2264">				delayed.SetMerge(DM_MERGE_DUPLICATES);</a>
<a name="ln2265"> </a>
<a name="ln2266">				if (delayed.Attach&lt;BRect&gt;(invalidRect) == B_OK</a>
<a name="ln2267">						&amp;&amp; delayed.Attach&lt;View*&gt;(fCurrentView) == B_OK)</a>
<a name="ln2268">					delayed.Flush();</a>
<a name="ln2269">			}</a>
<a name="ln2270">			break;</a>
<a name="ln2271">		}</a>
<a name="ln2272"> </a>
<a name="ln2273">		case AS_VIEW_INVALIDATE_REGION:</a>
<a name="ln2274">		{</a>
<a name="ln2275">			// NOTE: looks like this call is NOT affected by origin and scale</a>
<a name="ln2276">			// on R5 so this implementation is &quot;correct&quot;</a>
<a name="ln2277">			BRegion region;</a>
<a name="ln2278">			if (link.ReadRegion(&amp;region) &lt; B_OK)</a>
<a name="ln2279">				break;</a>
<a name="ln2280"> </a>
<a name="ln2281">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_INVALIDATE_REGION: &quot;</a>
<a name="ln2282">					&quot;View: %s -&gt; rect count: %&quot; B_PRId32 &quot;, frame: BRect(%.1f, &quot;</a>
<a name="ln2283">					&quot;%.1f, %.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln2284">					fCurrentView-&gt;Name(), region.CountRects(),</a>
<a name="ln2285">					region.Frame().left, region.Frame().top,</a>
<a name="ln2286">					region.Frame().right, region.Frame().bottom));</a>
<a name="ln2287"> </a>
<a name="ln2288">			fWindow-&gt;InvalidateView(fCurrentView, region);</a>
<a name="ln2289">			break;</a>
<a name="ln2290">		}</a>
<a name="ln2291"> </a>
<a name="ln2292">		case AS_VIEW_DRAG_IMAGE:</a>
<a name="ln2293">		{</a>
<a name="ln2294">			// TODO: flesh out AS_VIEW_DRAG_IMAGE</a>
<a name="ln2295">			DTRACE((&quot;ServerWindow %s: Message AS_DRAG_IMAGE\n&quot;, Title()));</a>
<a name="ln2296"> </a>
<a name="ln2297">			int32 bitmapToken;</a>
<a name="ln2298">			drawing_mode dragMode;</a>
<a name="ln2299">			BPoint offset;</a>
<a name="ln2300">			int32 bufferSize;</a>
<a name="ln2301"> </a>
<a name="ln2302">			link.Read&lt;int32&gt;(&amp;bitmapToken);</a>
<a name="ln2303">			link.Read&lt;int32&gt;((int32*)&amp;dragMode);</a>
<a name="ln2304">			link.Read&lt;BPoint&gt;(&amp;offset);</a>
<a name="ln2305">			link.Read&lt;int32&gt;(&amp;bufferSize);</a>
<a name="ln2306"> </a>
<a name="ln2307">			if (bufferSize &gt; 0) {</a>
<a name="ln2308">				char* buffer = new (nothrow) char[bufferSize];</a>
<a name="ln2309">				BMessage dragMessage;</a>
<a name="ln2310">				if (link.Read(buffer, bufferSize) == B_OK</a>
<a name="ln2311">					&amp;&amp; dragMessage.Unflatten(buffer) == B_OK) {</a>
<a name="ln2312">						ServerBitmap* bitmap</a>
<a name="ln2313">							= fServerApp-&gt;GetBitmap(bitmapToken);</a>
<a name="ln2314">						// TODO: possible deadlock</a>
<a name="ln2315">fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln2316">						fDesktop-&gt;EventDispatcher().SetDragMessage(dragMessage,</a>
<a name="ln2317">							bitmap, offset);</a>
<a name="ln2318">fDesktop-&gt;LockSingleWindow();</a>
<a name="ln2319">						if (bitmap != NULL)</a>
<a name="ln2320">							bitmap-&gt;ReleaseReference();</a>
<a name="ln2321">				}</a>
<a name="ln2322">				delete[] buffer;</a>
<a name="ln2323">			}</a>
<a name="ln2324">			// sync the client (it can now delete the bitmap)</a>
<a name="ln2325">			fLink.StartMessage(B_OK);</a>
<a name="ln2326">			fLink.Flush();</a>
<a name="ln2327"> </a>
<a name="ln2328">			break;</a>
<a name="ln2329">		}</a>
<a name="ln2330">		case AS_VIEW_DRAG_RECT:</a>
<a name="ln2331">		{</a>
<a name="ln2332">			// TODO: flesh out AS_VIEW_DRAG_RECT</a>
<a name="ln2333">			DTRACE((&quot;ServerWindow %s: Message AS_DRAG_RECT\n&quot;, Title()));</a>
<a name="ln2334"> </a>
<a name="ln2335">			BRect dragRect;</a>
<a name="ln2336">			BPoint offset;</a>
<a name="ln2337">			int32 bufferSize;</a>
<a name="ln2338"> </a>
<a name="ln2339">			link.Read&lt;BRect&gt;(&amp;dragRect);</a>
<a name="ln2340">			link.Read&lt;BPoint&gt;(&amp;offset);</a>
<a name="ln2341">			link.Read&lt;int32&gt;(&amp;bufferSize);</a>
<a name="ln2342"> </a>
<a name="ln2343">			if (bufferSize &gt; 0) {</a>
<a name="ln2344">				char* buffer = new (nothrow) char[bufferSize];</a>
<a name="ln2345">				BMessage dragMessage;</a>
<a name="ln2346">				if (link.Read(buffer, bufferSize) == B_OK</a>
<a name="ln2347">					&amp;&amp; dragMessage.Unflatten(buffer) == B_OK) {</a>
<a name="ln2348">						// TODO: possible deadlock</a>
<a name="ln2349">fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln2350">						fDesktop-&gt;EventDispatcher().SetDragMessage(dragMessage,</a>
<a name="ln2351">							NULL /* should be dragRect */, offset);</a>
<a name="ln2352">fDesktop-&gt;LockSingleWindow();</a>
<a name="ln2353">				}</a>
<a name="ln2354">				delete[] buffer;</a>
<a name="ln2355">			}</a>
<a name="ln2356">			break;</a>
<a name="ln2357">		}</a>
<a name="ln2358"> </a>
<a name="ln2359">		case AS_VIEW_BEGIN_RECT_TRACK:</a>
<a name="ln2360">		{</a>
<a name="ln2361">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_BEGIN_RECT_TRACK\n&quot;,</a>
<a name="ln2362">				Title()));</a>
<a name="ln2363">			BRect dragRect;</a>
<a name="ln2364">			uint32 style;</a>
<a name="ln2365"> </a>
<a name="ln2366">			link.Read&lt;BRect&gt;(&amp;dragRect);</a>
<a name="ln2367">			link.Read&lt;uint32&gt;(&amp;style);</a>
<a name="ln2368"> </a>
<a name="ln2369">			// TODO: implement rect tracking (used sometimes for selecting</a>
<a name="ln2370">			// a group of things, also sometimes used to appear to drag</a>
<a name="ln2371">			// something, but without real drag message)</a>
<a name="ln2372">			break;</a>
<a name="ln2373">		}</a>
<a name="ln2374">		case AS_VIEW_END_RECT_TRACK:</a>
<a name="ln2375">		{</a>
<a name="ln2376">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_END_RECT_TRACK\n&quot;,</a>
<a name="ln2377">				Title()));</a>
<a name="ln2378">			// TODO: implement rect tracking</a>
<a name="ln2379">			break;</a>
<a name="ln2380">		}</a>
<a name="ln2381"> </a>
<a name="ln2382">		case AS_VIEW_BEGIN_PICTURE:</a>
<a name="ln2383">		{</a>
<a name="ln2384">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_BEGIN_PICTURE\n&quot;,</a>
<a name="ln2385">				Title()));</a>
<a name="ln2386">			ServerPicture* picture = App()-&gt;CreatePicture();</a>
<a name="ln2387">			if (picture != NULL) {</a>
<a name="ln2388">				picture-&gt;SyncState(fCurrentView);</a>
<a name="ln2389">				fCurrentView-&gt;SetPicture(picture);</a>
<a name="ln2390">			}</a>
<a name="ln2391">			break;</a>
<a name="ln2392">		}</a>
<a name="ln2393"> </a>
<a name="ln2394">		case AS_VIEW_APPEND_TO_PICTURE:</a>
<a name="ln2395">		{</a>
<a name="ln2396">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_APPEND_TO_PICTURE\n&quot;,</a>
<a name="ln2397">				Title()));</a>
<a name="ln2398"> </a>
<a name="ln2399">			int32 token;</a>
<a name="ln2400">			link.Read&lt;int32&gt;(&amp;token);</a>
<a name="ln2401"> </a>
<a name="ln2402">			ServerPicture* picture = App()-&gt;GetPicture(token);</a>
<a name="ln2403">			if (picture != NULL)</a>
<a name="ln2404">				picture-&gt;SyncState(fCurrentView);</a>
<a name="ln2405"> </a>
<a name="ln2406">			fCurrentView-&gt;SetPicture(picture);</a>
<a name="ln2407"> </a>
<a name="ln2408">			if (picture != NULL)</a>
<a name="ln2409">				picture-&gt;ReleaseReference();</a>
<a name="ln2410">			break;</a>
<a name="ln2411">		}</a>
<a name="ln2412"> </a>
<a name="ln2413">		case AS_VIEW_END_PICTURE:</a>
<a name="ln2414">		{</a>
<a name="ln2415">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_END_PICTURE\n&quot;,</a>
<a name="ln2416">				Title()));</a>
<a name="ln2417"> </a>
<a name="ln2418">			ServerPicture* picture = fCurrentView-&gt;Picture();</a>
<a name="ln2419">			if (picture != NULL) {</a>
<a name="ln2420">				fCurrentView-&gt;SetPicture(NULL);</a>
<a name="ln2421">				fLink.StartMessage(B_OK);</a>
<a name="ln2422">				fLink.Attach&lt;int32&gt;(picture-&gt;Token());</a>
<a name="ln2423">			} else</a>
<a name="ln2424">				fLink.StartMessage(B_ERROR);</a>
<a name="ln2425"> </a>
<a name="ln2426">			fLink.Flush();</a>
<a name="ln2427">			break;</a>
<a name="ln2428">		}</a>
<a name="ln2429"> </a>
<a name="ln2430">		case AS_VIEW_BEGIN_LAYER:</a>
<a name="ln2431">		{</a>
<a name="ln2432">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_BEGIN_LAYER\n&quot;,</a>
<a name="ln2433">				Title()));</a>
<a name="ln2434"> </a>
<a name="ln2435">			uint8 opacity;</a>
<a name="ln2436">			link.Read&lt;uint8&gt;(&amp;opacity);</a>
<a name="ln2437"> </a>
<a name="ln2438">			Layer* layer = new(std::nothrow) Layer(opacity);</a>
<a name="ln2439">			if (layer == NULL)</a>
<a name="ln2440">				break;</a>
<a name="ln2441"> </a>
<a name="ln2442">			if (opacity != 255) {</a>
<a name="ln2443">				fCurrentView-&gt;CurrentState()-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln2444">				fCurrentView-&gt;CurrentState()-&gt;SetBlendingMode(B_PIXEL_ALPHA,</a>
<a name="ln2445">					B_ALPHA_COMPOSITE);</a>
<a name="ln2446">				fCurrentView-&gt;CurrentState()-&gt;SetDrawingModeLocked(true);</a>
<a name="ln2447">			}</a>
<a name="ln2448"> </a>
<a name="ln2449">			fCurrentView-&gt;SetPicture(layer);</a>
<a name="ln2450">			break;</a>
<a name="ln2451">		}</a>
<a name="ln2452"> </a>
<a name="ln2453">		default:</a>
<a name="ln2454">			_DispatchViewDrawingMessage(code, link);</a>
<a name="ln2455">			break;</a>
<a name="ln2456">	}</a>
<a name="ln2457">}</a>
<a name="ln2458"> </a>
<a name="ln2459"> </a>
<a name="ln2460">/*!	Dispatches all view drawing messages.</a>
<a name="ln2461">	The desktop clipping must be read locked when entering this method.</a>
<a name="ln2462">	Requires a valid fCurrentView.</a>
<a name="ln2463">*/</a>
<a name="ln2464">void</a>
<a name="ln2465">ServerWindow::_DispatchViewDrawingMessage(int32 code,</a>
<a name="ln2466">	BPrivate::LinkReceiver &amp;link)</a>
<a name="ln2467">{</a>
<a name="ln2468">	if (!fCurrentView-&gt;IsVisible() || !fWindow-&gt;IsVisible()) {</a>
<a name="ln2469">		if (link.NeedsReply()) {</a>
<a name="ln2470">			debug_printf(&quot;ServerWindow::DispatchViewDrawingMessage() got &quot;</a>
<a name="ln2471">				&quot;message %&quot; B_PRId32 &quot; that needs a reply!\n&quot;, code);</a>
<a name="ln2472">			// the client is now blocking and waiting for a reply!</a>
<a name="ln2473">			fLink.StartMessage(B_ERROR);</a>
<a name="ln2474">			fLink.Flush();</a>
<a name="ln2475">		}</a>
<a name="ln2476">		return;</a>
<a name="ln2477">	}</a>
<a name="ln2478"> </a>
<a name="ln2479">	DrawingEngine* drawingEngine = fWindow-&gt;GetDrawingEngine();</a>
<a name="ln2480">	if (!drawingEngine) {</a>
<a name="ln2481">		// ?!?</a>
<a name="ln2482">		debug_printf(&quot;ServerWindow %s: no drawing engine!!\n&quot;, Title());</a>
<a name="ln2483">		if (link.NeedsReply()) {</a>
<a name="ln2484">			// the client is now blocking and waiting for a reply!</a>
<a name="ln2485">			fLink.StartMessage(B_ERROR);</a>
<a name="ln2486">			fLink.Flush();</a>
<a name="ln2487">		}</a>
<a name="ln2488">		return;</a>
<a name="ln2489">	}</a>
<a name="ln2490"> </a>
<a name="ln2491">	_UpdateCurrentDrawingRegion();</a>
<a name="ln2492">	if (fCurrentDrawingRegion.CountRects() &lt;= 0 &amp;&amp; code != AS_VIEW_END_LAYER) {</a>
<a name="ln2493">			// If the command is AS_VIEW_END_LAYER, then we continue even if</a>
<a name="ln2494">			// the clipping region is empty. The layer itself might set a valid</a>
<a name="ln2495">			// clipping while its contents are drawn, and even if it doesn't,</a>
<a name="ln2496">			// we must still play back its picture so that we don't leak</a>
<a name="ln2497">			// nested layer instances.</a>
<a name="ln2498"> </a>
<a name="ln2499">		DTRACE((&quot;ServerWindow %s: _DispatchViewDrawingMessage(): View: %s, &quot;</a>
<a name="ln2500">			&quot;INVALID CLIPPING!\n&quot;, Title(), fCurrentView-&gt;Name()));</a>
<a name="ln2501">		if (link.NeedsReply()) {</a>
<a name="ln2502">			// the client is now blocking and waiting for a reply!</a>
<a name="ln2503">			fLink.StartMessage(B_ERROR);</a>
<a name="ln2504">			fLink.Flush();</a>
<a name="ln2505">		}</a>
<a name="ln2506">		return;</a>
<a name="ln2507">	}</a>
<a name="ln2508"> </a>
<a name="ln2509">	drawingEngine-&gt;LockParallelAccess();</a>
<a name="ln2510">	// NOTE: the region is not copied, Painter keeps a pointer,</a>
<a name="ln2511">	// that's why you need to use the clipping only for as long</a>
<a name="ln2512">	// as you have it locked</a>
<a name="ln2513">	drawingEngine-&gt;ConstrainClippingRegion(&amp;fCurrentDrawingRegion);</a>
<a name="ln2514"> </a>
<a name="ln2515">	switch (code) {</a>
<a name="ln2516">		case AS_STROKE_LINE:</a>
<a name="ln2517">		{</a>
<a name="ln2518">			ViewStrokeLineInfo info;</a>
<a name="ln2519">			if (link.Read&lt;ViewStrokeLineInfo&gt;(&amp;info) != B_OK)</a>
<a name="ln2520">				break;</a>
<a name="ln2521"> </a>
<a name="ln2522">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE_LINE: View: %s -&gt; &quot;</a>
<a name="ln2523">				&quot;BPoint(%.1f, %.1f) - BPoint(%.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln2524">					fCurrentView-&gt;Name(),</a>
<a name="ln2525">					info.startPoint.x, info.startPoint.y,</a>
<a name="ln2526">					info.endPoint.x, info.endPoint.y));</a>
<a name="ln2527"> </a>
<a name="ln2528">			BPoint penPos = info.endPoint;</a>
<a name="ln2529">			const SimpleTransform transform =</a>
<a name="ln2530">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2531">			transform.Apply(&amp;info.startPoint);</a>
<a name="ln2532">			transform.Apply(&amp;info.endPoint);</a>
<a name="ln2533">			drawingEngine-&gt;StrokeLine(info.startPoint, info.endPoint);</a>
<a name="ln2534"> </a>
<a name="ln2535">			// We update the pen here because many DrawingEngine calls which</a>
<a name="ln2536">			// do not update the pen position actually call StrokeLine</a>
<a name="ln2537"> </a>
<a name="ln2538">			// TODO: Decide where to put this, for example, it cannot be done</a>
<a name="ln2539">			// for DrawString(), also there needs to be a decision, if the pen</a>
<a name="ln2540">			// location is in View coordinates (I think it should be) or in</a>
<a name="ln2541">			// screen coordinates.</a>
<a name="ln2542">			fCurrentView-&gt;CurrentState()-&gt;SetPenLocation(penPos);</a>
<a name="ln2543">			break;</a>
<a name="ln2544">		}</a>
<a name="ln2545">		case AS_VIEW_INVERT_RECT:</a>
<a name="ln2546">		{</a>
<a name="ln2547">			BRect rect;</a>
<a name="ln2548">			if (link.Read&lt;BRect&gt;(&amp;rect) != B_OK)</a>
<a name="ln2549">				break;</a>
<a name="ln2550"> </a>
<a name="ln2551">			DTRACE((&quot;ServerWindow %s: Message AS_INVERT_RECT: View: %s -&gt; &quot;</a>
<a name="ln2552">				&quot;BRect(%.1f, %.1f, %.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln2553">				fCurrentView-&gt;Name(), rect.left, rect.top, rect.right,</a>
<a name="ln2554">				rect.bottom));</a>
<a name="ln2555"> </a>
<a name="ln2556">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln2557">			drawingEngine-&gt;InvertRect(rect);</a>
<a name="ln2558">			break;</a>
<a name="ln2559">		}</a>
<a name="ln2560">		case AS_STROKE_RECT:</a>
<a name="ln2561">		{</a>
<a name="ln2562">			BRect rect;</a>
<a name="ln2563">			if (link.Read&lt;BRect&gt;(&amp;rect) != B_OK)</a>
<a name="ln2564">				break;</a>
<a name="ln2565"> </a>
<a name="ln2566">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE_RECT: View: %s -&gt; &quot;</a>
<a name="ln2567">				&quot;BRect(%.1f, %.1f, %.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln2568">				fCurrentView-&gt;Name(), rect.left, rect.top, rect.right,</a>
<a name="ln2569">				rect.bottom));</a>
<a name="ln2570"> </a>
<a name="ln2571">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln2572">			drawingEngine-&gt;StrokeRect(rect);</a>
<a name="ln2573">			break;</a>
<a name="ln2574">		}</a>
<a name="ln2575">		case AS_FILL_RECT:</a>
<a name="ln2576">		{</a>
<a name="ln2577">			BRect rect;</a>
<a name="ln2578">			if (link.Read&lt;BRect&gt;(&amp;rect) != B_OK)</a>
<a name="ln2579">				break;</a>
<a name="ln2580"> </a>
<a name="ln2581">			DTRACE((&quot;ServerWindow %s: Message AS_FILL_RECT: View: %s -&gt; &quot;</a>
<a name="ln2582">				&quot;BRect(%.1f, %.1f, %.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln2583">				fCurrentView-&gt;Name(), rect.left, rect.top, rect.right,</a>
<a name="ln2584">				rect.bottom));</a>
<a name="ln2585"> </a>
<a name="ln2586">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln2587">			drawingEngine-&gt;FillRect(rect);</a>
<a name="ln2588">			break;</a>
<a name="ln2589">		}</a>
<a name="ln2590">		case AS_FILL_RECT_GRADIENT:</a>
<a name="ln2591">		{</a>
<a name="ln2592">			BRect rect;</a>
<a name="ln2593">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln2594">			BGradient* gradient;</a>
<a name="ln2595">			if (link.ReadGradient(&amp;gradient) != B_OK)</a>
<a name="ln2596">				break;</a>
<a name="ln2597"> </a>
<a name="ln2598">			GTRACE((&quot;ServerWindow %s: Message AS_FILL_RECT_GRADIENT: View: %s &quot;</a>
<a name="ln2599">				&quot;-&gt; BRect(%.1f, %.1f, %.1f, %.1f)\n&quot;, Title(),</a>
<a name="ln2600">				fCurrentView-&gt;Name(), rect.left, rect.top, rect.right,</a>
<a name="ln2601">				rect.bottom));</a>
<a name="ln2602"> </a>
<a name="ln2603">			const SimpleTransform transform =</a>
<a name="ln2604">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2605">			transform.Apply(&amp;rect);</a>
<a name="ln2606">			transform.Apply(gradient);</a>
<a name="ln2607">			drawingEngine-&gt;FillRect(rect, *gradient);</a>
<a name="ln2608">			delete gradient;</a>
<a name="ln2609">			break;</a>
<a name="ln2610">		}</a>
<a name="ln2611">		case AS_VIEW_DRAW_BITMAP:</a>
<a name="ln2612">		{</a>
<a name="ln2613">			ViewDrawBitmapInfo info;</a>
<a name="ln2614">			if (link.Read&lt;ViewDrawBitmapInfo&gt;(&amp;info) != B_OK)</a>
<a name="ln2615">				break;</a>
<a name="ln2616"> </a>
<a name="ln2617">#if 0</a>
<a name="ln2618">			if (strcmp(fServerApp-&gt;SignatureLeaf(), &quot;x-vnd.videolan-vlc&quot;) == 0)</a>
<a name="ln2619">				info.options |= B_FILTER_BITMAP_BILINEAR;</a>
<a name="ln2620">#endif</a>
<a name="ln2621"> </a>
<a name="ln2622">			ServerBitmap* bitmap = fServerApp-&gt;GetBitmap(info.bitmapToken);</a>
<a name="ln2623">			if (bitmap != NULL) {</a>
<a name="ln2624">				DTRACE((&quot;ServerWindow %s: Message AS_VIEW_DRAW_BITMAP: &quot;</a>
<a name="ln2625">					&quot;View: %s, bitmap: %&quot; B_PRId32 &quot; (size %&quot; B_PRId32 &quot; x &quot;</a>
<a name="ln2626">					&quot;%&quot; B_PRId32 &quot;), BRect(%.1f, %.1f, %.1f, %.1f) -&gt; &quot;</a>
<a name="ln2627">					&quot;BRect(%.1f, %.1f, %.1f, %.1f)\n&quot;,</a>
<a name="ln2628">					fTitle, fCurrentView-&gt;Name(), info.bitmapToken,</a>
<a name="ln2629">					bitmap-&gt;Width(), bitmap-&gt;Height(),</a>
<a name="ln2630">					info.bitmapRect.left, info.bitmapRect.top,</a>
<a name="ln2631">					info.bitmapRect.right, info.bitmapRect.bottom,</a>
<a name="ln2632">					info.viewRect.left, info.viewRect.top,</a>
<a name="ln2633">					info.viewRect.right, info.viewRect.bottom));</a>
<a name="ln2634"> </a>
<a name="ln2635">				fCurrentView-&gt;PenToScreenTransform().Apply(&amp;info.viewRect);</a>
<a name="ln2636"> </a>
<a name="ln2637">// TODO: Unbreak...</a>
<a name="ln2638">//				if ((info.options &amp; B_WAIT_FOR_RETRACE) != 0)</a>
<a name="ln2639">//					fDesktop-&gt;HWInterface()-&gt;WaitForRetrace(20000);</a>
<a name="ln2640"> </a>
<a name="ln2641">				drawingEngine-&gt;DrawBitmap(bitmap, info.bitmapRect,</a>
<a name="ln2642">					info.viewRect, info.options);</a>
<a name="ln2643"> </a>
<a name="ln2644">				bitmap-&gt;ReleaseReference();</a>
<a name="ln2645">			}</a>
<a name="ln2646">			break;</a>
<a name="ln2647">		}</a>
<a name="ln2648">		case AS_STROKE_ARC:</a>
<a name="ln2649">		case AS_FILL_ARC:</a>
<a name="ln2650">		{</a>
<a name="ln2651">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE/FILL_ARC\n&quot;, Title()));</a>
<a name="ln2652"> </a>
<a name="ln2653">			float angle, span;</a>
<a name="ln2654">			BRect r;</a>
<a name="ln2655"> </a>
<a name="ln2656">			link.Read&lt;BRect&gt;(&amp;r);</a>
<a name="ln2657">			link.Read&lt;float&gt;(&amp;angle);</a>
<a name="ln2658">			if (link.Read&lt;float&gt;(&amp;span) != B_OK)</a>
<a name="ln2659">				break;</a>
<a name="ln2660"> </a>
<a name="ln2661">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;r);</a>
<a name="ln2662">			drawingEngine-&gt;DrawArc(r, angle, span, code == AS_FILL_ARC);</a>
<a name="ln2663">			break;</a>
<a name="ln2664">		}</a>
<a name="ln2665">		case AS_FILL_ARC_GRADIENT:</a>
<a name="ln2666">		{</a>
<a name="ln2667">			GTRACE((&quot;ServerWindow %s: Message AS_FILL_ARC_GRADIENT\n&quot;,</a>
<a name="ln2668">				Title()));</a>
<a name="ln2669"> </a>
<a name="ln2670">			float angle, span;</a>
<a name="ln2671">			BRect r;</a>
<a name="ln2672">			link.Read&lt;BRect&gt;(&amp;r);</a>
<a name="ln2673">			link.Read&lt;float&gt;(&amp;angle);</a>
<a name="ln2674">			link.Read&lt;float&gt;(&amp;span);</a>
<a name="ln2675">			BGradient* gradient;</a>
<a name="ln2676">			if (link.ReadGradient(&amp;gradient) != B_OK)</a>
<a name="ln2677">				break;</a>
<a name="ln2678">			const SimpleTransform transform =</a>
<a name="ln2679">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2680">			transform.Apply(&amp;r);</a>
<a name="ln2681">			transform.Apply(gradient);</a>
<a name="ln2682">			drawingEngine-&gt;FillArc(r, angle, span, *gradient);</a>
<a name="ln2683">			delete gradient;</a>
<a name="ln2684">			break;</a>
<a name="ln2685">		}</a>
<a name="ln2686">		case AS_STROKE_BEZIER:</a>
<a name="ln2687">		case AS_FILL_BEZIER:</a>
<a name="ln2688">		{</a>
<a name="ln2689">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE/FILL_BEZIER\n&quot;,</a>
<a name="ln2690">				Title()));</a>
<a name="ln2691"> </a>
<a name="ln2692">			const SimpleTransform transform =</a>
<a name="ln2693">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2694">			BPoint pts[4];</a>
<a name="ln2695">			status_t status;</a>
<a name="ln2696">			for (int32 i = 0; i &lt; 4; i++) {</a>
<a name="ln2697">				status = link.Read&lt;BPoint&gt;(&amp;(pts[i]));</a>
<a name="ln2698">				transform.Apply(&amp;pts[i]);</a>
<a name="ln2699">			}</a>
<a name="ln2700">			if (status != B_OK)</a>
<a name="ln2701">				break;</a>
<a name="ln2702"> </a>
<a name="ln2703">			drawingEngine-&gt;DrawBezier(pts, code == AS_FILL_BEZIER);</a>
<a name="ln2704">			break;</a>
<a name="ln2705">		}</a>
<a name="ln2706">		case AS_FILL_BEZIER_GRADIENT:</a>
<a name="ln2707">		{</a>
<a name="ln2708">			GTRACE((&quot;ServerWindow %s: Message AS_FILL_BEZIER_GRADIENT\n&quot;,</a>
<a name="ln2709">				Title()));</a>
<a name="ln2710"> </a>
<a name="ln2711">			const SimpleTransform transform =</a>
<a name="ln2712">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2713">			BPoint pts[4];</a>
<a name="ln2714">			for (int32 i = 0; i &lt; 4; i++) {</a>
<a name="ln2715">				link.Read&lt;BPoint&gt;(&amp;(pts[i]));</a>
<a name="ln2716">				transform.Apply(&amp;pts[i]);</a>
<a name="ln2717">			}</a>
<a name="ln2718">			BGradient* gradient;</a>
<a name="ln2719">			if (link.ReadGradient(&amp;gradient) != B_OK)</a>
<a name="ln2720">				break;</a>
<a name="ln2721">			transform.Apply(gradient);</a>
<a name="ln2722">			drawingEngine-&gt;FillBezier(pts, *gradient);</a>
<a name="ln2723">			delete gradient;</a>
<a name="ln2724">			break;</a>
<a name="ln2725">		}</a>
<a name="ln2726">		case AS_STROKE_ELLIPSE:</a>
<a name="ln2727">		case AS_FILL_ELLIPSE:</a>
<a name="ln2728">		{</a>
<a name="ln2729">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE/FILL_ELLIPSE\n&quot;,</a>
<a name="ln2730">				Title()));</a>
<a name="ln2731"> </a>
<a name="ln2732">			BRect rect;</a>
<a name="ln2733">			if (link.Read&lt;BRect&gt;(&amp;rect) != B_OK)</a>
<a name="ln2734">				break;</a>
<a name="ln2735"> </a>
<a name="ln2736">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln2737">			drawingEngine-&gt;DrawEllipse(rect, code == AS_FILL_ELLIPSE);</a>
<a name="ln2738">			break;</a>
<a name="ln2739">		}</a>
<a name="ln2740">		case AS_FILL_ELLIPSE_GRADIENT:</a>
<a name="ln2741">		{</a>
<a name="ln2742">			GTRACE((&quot;ServerWindow %s: Message AS_FILL_ELLIPSE_GRADIENT\n&quot;,</a>
<a name="ln2743">				Title()));</a>
<a name="ln2744"> </a>
<a name="ln2745">			BRect rect;</a>
<a name="ln2746">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln2747">			BGradient* gradient;</a>
<a name="ln2748">			if (link.ReadGradient(&amp;gradient) != B_OK)</a>
<a name="ln2749">				break;</a>
<a name="ln2750">			const SimpleTransform transform =</a>
<a name="ln2751">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2752">			transform.Apply(&amp;rect);</a>
<a name="ln2753">			transform.Apply(gradient);</a>
<a name="ln2754">			drawingEngine-&gt;FillEllipse(rect, *gradient);</a>
<a name="ln2755">			delete gradient;</a>
<a name="ln2756">			break;</a>
<a name="ln2757">		}</a>
<a name="ln2758">		case AS_STROKE_ROUNDRECT:</a>
<a name="ln2759">		case AS_FILL_ROUNDRECT:</a>
<a name="ln2760">		{</a>
<a name="ln2761">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE/FILL_ROUNDRECT\n&quot;,</a>
<a name="ln2762">				Title()));</a>
<a name="ln2763"> </a>
<a name="ln2764">			BRect rect;</a>
<a name="ln2765">			float xRadius;</a>
<a name="ln2766">			float yRadius;</a>
<a name="ln2767">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln2768">			link.Read&lt;float&gt;(&amp;xRadius);</a>
<a name="ln2769">			if (link.Read&lt;float&gt;(&amp;yRadius) != B_OK)</a>
<a name="ln2770">				break;</a>
<a name="ln2771"> </a>
<a name="ln2772">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln2773">			float scale = fCurrentView-&gt;CurrentState()-&gt;CombinedScale();</a>
<a name="ln2774">			drawingEngine-&gt;DrawRoundRect(rect, xRadius * scale, yRadius * scale,</a>
<a name="ln2775">				code == AS_FILL_ROUNDRECT);</a>
<a name="ln2776">			break;</a>
<a name="ln2777">		}</a>
<a name="ln2778">		case AS_FILL_ROUNDRECT_GRADIENT:</a>
<a name="ln2779">		{</a>
<a name="ln2780">			GTRACE((&quot;ServerWindow %s: Message AS_FILL_ROUNDRECT_GRADIENT\n&quot;,</a>
<a name="ln2781">				Title()));</a>
<a name="ln2782"> </a>
<a name="ln2783">			BRect rect;</a>
<a name="ln2784">			float xrad,yrad;</a>
<a name="ln2785">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln2786">			link.Read&lt;float&gt;(&amp;xrad);</a>
<a name="ln2787">			link.Read&lt;float&gt;(&amp;yrad);</a>
<a name="ln2788">			BGradient* gradient;</a>
<a name="ln2789">			if (link.ReadGradient(&amp;gradient) != B_OK)</a>
<a name="ln2790">				break;</a>
<a name="ln2791">			const SimpleTransform transform =</a>
<a name="ln2792">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2793">			transform.Apply(&amp;rect);</a>
<a name="ln2794">			transform.Apply(gradient);</a>
<a name="ln2795">			drawingEngine-&gt;FillRoundRect(rect, xrad, yrad, *gradient);</a>
<a name="ln2796">			delete gradient;</a>
<a name="ln2797">			break;</a>
<a name="ln2798">		}</a>
<a name="ln2799">		case AS_STROKE_TRIANGLE:</a>
<a name="ln2800">		case AS_FILL_TRIANGLE:</a>
<a name="ln2801">		{</a>
<a name="ln2802">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE/FILL_TRIANGLE\n&quot;,</a>
<a name="ln2803">				Title()));</a>
<a name="ln2804"> </a>
<a name="ln2805">			const SimpleTransform transform =</a>
<a name="ln2806">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2807">			BPoint pts[3];</a>
<a name="ln2808">			BRect rect;</a>
<a name="ln2809"> </a>
<a name="ln2810">			for (int32 i = 0; i &lt; 3; i++) {</a>
<a name="ln2811">				link.Read&lt;BPoint&gt;(&amp;(pts[i]));</a>
<a name="ln2812">				transform.Apply(&amp;pts[i]);</a>
<a name="ln2813">			}</a>
<a name="ln2814"> </a>
<a name="ln2815">			if (link.Read&lt;BRect&gt;(&amp;rect) != B_OK)</a>
<a name="ln2816">				break;</a>
<a name="ln2817"> </a>
<a name="ln2818">			transform.Apply(&amp;rect);</a>
<a name="ln2819">			drawingEngine-&gt;DrawTriangle(pts, rect, code == AS_FILL_TRIANGLE);</a>
<a name="ln2820">			break;</a>
<a name="ln2821">		}</a>
<a name="ln2822">		case AS_FILL_TRIANGLE_GRADIENT:</a>
<a name="ln2823">		{</a>
<a name="ln2824">			DTRACE((&quot;ServerWindow %s: Message AS_FILL_TRIANGLE_GRADIENT\n&quot;,</a>
<a name="ln2825">				Title()));</a>
<a name="ln2826"> </a>
<a name="ln2827">			const SimpleTransform transform =</a>
<a name="ln2828">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2829">			BPoint pts[3];</a>
<a name="ln2830">			BRect rect;</a>
<a name="ln2831">			for (int32 i = 0; i &lt; 3; i++) {</a>
<a name="ln2832">				link.Read&lt;BPoint&gt;(&amp;(pts[i]));</a>
<a name="ln2833">				transform.Apply(&amp;pts[i]);</a>
<a name="ln2834">			}</a>
<a name="ln2835">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln2836">			BGradient* gradient;</a>
<a name="ln2837">			if (link.ReadGradient(&amp;gradient) != B_OK)</a>
<a name="ln2838">				break;</a>
<a name="ln2839">			transform.Apply(&amp;rect);</a>
<a name="ln2840">			transform.Apply(gradient);</a>
<a name="ln2841">			drawingEngine-&gt;FillTriangle(pts, rect, *gradient);</a>
<a name="ln2842">			delete gradient;</a>
<a name="ln2843">			break;</a>
<a name="ln2844">		}</a>
<a name="ln2845">		case AS_STROKE_POLYGON:</a>
<a name="ln2846">		case AS_FILL_POLYGON:</a>
<a name="ln2847">		{</a>
<a name="ln2848">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE/FILL_POLYGON\n&quot;,</a>
<a name="ln2849">				Title()));</a>
<a name="ln2850"> </a>
<a name="ln2851">			BRect polyFrame;</a>
<a name="ln2852">			bool isClosed = true;</a>
<a name="ln2853">			int32 pointCount;</a>
<a name="ln2854"> </a>
<a name="ln2855">			link.Read&lt;BRect&gt;(&amp;polyFrame);</a>
<a name="ln2856">			if (code == AS_STROKE_POLYGON)</a>
<a name="ln2857">				link.Read&lt;bool&gt;(&amp;isClosed);</a>
<a name="ln2858">			link.Read&lt;int32&gt;(&amp;pointCount);</a>
<a name="ln2859"> </a>
<a name="ln2860">			const SimpleTransform transform =</a>
<a name="ln2861">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2862">			BPoint* pointList = new(nothrow) BPoint[pointCount];</a>
<a name="ln2863">			if (link.Read(pointList, pointCount * sizeof(BPoint)) &gt;= B_OK) {</a>
<a name="ln2864">				for (int32 i = 0; i &lt; pointCount; i++)</a>
<a name="ln2865">					transform.Apply(&amp;pointList[i]);</a>
<a name="ln2866">				transform.Apply(&amp;polyFrame);</a>
<a name="ln2867"> </a>
<a name="ln2868">				drawingEngine-&gt;DrawPolygon(pointList, pointCount, polyFrame,</a>
<a name="ln2869">					code == AS_FILL_POLYGON, isClosed &amp;&amp; pointCount &gt; 2);</a>
<a name="ln2870">			}</a>
<a name="ln2871">			delete[] pointList;</a>
<a name="ln2872">			break;</a>
<a name="ln2873">		}</a>
<a name="ln2874">		case AS_FILL_POLYGON_GRADIENT:</a>
<a name="ln2875">		{</a>
<a name="ln2876">			DTRACE((&quot;ServerWindow %s: Message AS_FILL_POLYGON_GRADIENT\n&quot;,</a>
<a name="ln2877">				Title()));</a>
<a name="ln2878"> </a>
<a name="ln2879">			BRect polyFrame;</a>
<a name="ln2880">			bool isClosed = true;</a>
<a name="ln2881">			int32 pointCount;</a>
<a name="ln2882">			link.Read&lt;BRect&gt;(&amp;polyFrame);</a>
<a name="ln2883">			link.Read&lt;int32&gt;(&amp;pointCount);</a>
<a name="ln2884"> </a>
<a name="ln2885">			const SimpleTransform transform =</a>
<a name="ln2886">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2887">			BPoint* pointList = new(nothrow) BPoint[pointCount];</a>
<a name="ln2888">			BGradient* gradient;</a>
<a name="ln2889">			if (link.Read(pointList, pointCount * sizeof(BPoint)) == B_OK</a>
<a name="ln2890">				&amp;&amp; link.ReadGradient(&amp;gradient) == B_OK) {</a>
<a name="ln2891">				for (int32 i = 0; i &lt; pointCount; i++)</a>
<a name="ln2892">					transform.Apply(&amp;pointList[i]);</a>
<a name="ln2893">				transform.Apply(&amp;polyFrame);</a>
<a name="ln2894">				transform.Apply(gradient);</a>
<a name="ln2895"> </a>
<a name="ln2896">				drawingEngine-&gt;FillPolygon(pointList, pointCount,</a>
<a name="ln2897">					polyFrame, *gradient, isClosed &amp;&amp; pointCount &gt; 2);</a>
<a name="ln2898">				delete gradient;</a>
<a name="ln2899">			}</a>
<a name="ln2900">			delete[] pointList;</a>
<a name="ln2901">			break;</a>
<a name="ln2902">		}</a>
<a name="ln2903">		case AS_STROKE_SHAPE:</a>
<a name="ln2904">		case AS_FILL_SHAPE:</a>
<a name="ln2905">		{</a>
<a name="ln2906">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE/FILL_SHAPE\n&quot;,</a>
<a name="ln2907">				Title()));</a>
<a name="ln2908"> </a>
<a name="ln2909">			BRect shapeFrame;</a>
<a name="ln2910">			int32 opCount;</a>
<a name="ln2911">			int32 ptCount;</a>
<a name="ln2912"> </a>
<a name="ln2913">			link.Read&lt;BRect&gt;(&amp;shapeFrame);</a>
<a name="ln2914">			link.Read&lt;int32&gt;(&amp;opCount);</a>
<a name="ln2915">			link.Read&lt;int32&gt;(&amp;ptCount);</a>
<a name="ln2916"> </a>
<a name="ln2917">			uint32* opList = new(nothrow) uint32[opCount];</a>
<a name="ln2918">			BPoint* ptList = new(nothrow) BPoint[ptCount];</a>
<a name="ln2919">			if (link.Read(opList, opCount * sizeof(uint32)) &gt;= B_OK &amp;&amp;</a>
<a name="ln2920">				link.Read(ptList, ptCount * sizeof(BPoint)) &gt;= B_OK) {</a>
<a name="ln2921"> </a>
<a name="ln2922">				// this might seem a bit weird, but under R5, the shapes</a>
<a name="ln2923">				// are always offset by the current pen location</a>
<a name="ln2924">				BPoint screenOffset</a>
<a name="ln2925">					= fCurrentView-&gt;CurrentState()-&gt;PenLocation();</a>
<a name="ln2926">				shapeFrame.OffsetBy(screenOffset);</a>
<a name="ln2927"> </a>
<a name="ln2928">				const SimpleTransform transform =</a>
<a name="ln2929">					fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2930">				transform.Apply(&amp;screenOffset);</a>
<a name="ln2931">				transform.Apply(&amp;shapeFrame);</a>
<a name="ln2932"> </a>
<a name="ln2933">				drawingEngine-&gt;DrawShape(shapeFrame, opCount, opList, ptCount,</a>
<a name="ln2934">					ptList, code == AS_FILL_SHAPE, screenOffset,</a>
<a name="ln2935">					fCurrentView-&gt;Scale());</a>
<a name="ln2936">			}</a>
<a name="ln2937"> </a>
<a name="ln2938">			delete[] opList;</a>
<a name="ln2939">			delete[] ptList;</a>
<a name="ln2940">			break;</a>
<a name="ln2941">		}</a>
<a name="ln2942">		case AS_FILL_SHAPE_GRADIENT:</a>
<a name="ln2943">		{</a>
<a name="ln2944">			DTRACE((&quot;ServerWindow %s: Message AS_FILL_SHAPE_GRADIENT\n&quot;,</a>
<a name="ln2945">				Title()));</a>
<a name="ln2946"> </a>
<a name="ln2947">			BRect shapeFrame;</a>
<a name="ln2948">			int32 opCount;</a>
<a name="ln2949">			int32 ptCount;</a>
<a name="ln2950"> </a>
<a name="ln2951">			link.Read&lt;BRect&gt;(&amp;shapeFrame);</a>
<a name="ln2952">			link.Read&lt;int32&gt;(&amp;opCount);</a>
<a name="ln2953">			link.Read&lt;int32&gt;(&amp;ptCount);</a>
<a name="ln2954"> </a>
<a name="ln2955">			uint32* opList = new(nothrow) uint32[opCount];</a>
<a name="ln2956">			BPoint* ptList = new(nothrow) BPoint[ptCount];</a>
<a name="ln2957">			BGradient* gradient;</a>
<a name="ln2958">			if (link.Read(opList, opCount * sizeof(uint32)) == B_OK</a>
<a name="ln2959">				&amp;&amp; link.Read(ptList, ptCount * sizeof(BPoint)) == B_OK</a>
<a name="ln2960">				&amp;&amp; link.ReadGradient(&amp;gradient) == B_OK) {</a>
<a name="ln2961"> </a>
<a name="ln2962">				// this might seem a bit weird, but under R5, the shapes</a>
<a name="ln2963">				// are always offset by the current pen location</a>
<a name="ln2964">				BPoint screenOffset</a>
<a name="ln2965">					= fCurrentView-&gt;CurrentState()-&gt;PenLocation();</a>
<a name="ln2966">				shapeFrame.OffsetBy(screenOffset);</a>
<a name="ln2967"> </a>
<a name="ln2968">				const SimpleTransform transform =</a>
<a name="ln2969">					fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln2970">				transform.Apply(&amp;screenOffset);</a>
<a name="ln2971">				transform.Apply(&amp;shapeFrame);</a>
<a name="ln2972">				transform.Apply(gradient);</a>
<a name="ln2973">				drawingEngine-&gt;FillShape(shapeFrame, opCount, opList,</a>
<a name="ln2974">					ptCount, ptList, *gradient, screenOffset,</a>
<a name="ln2975">					fCurrentView-&gt;Scale());</a>
<a name="ln2976">				delete gradient;</a>
<a name="ln2977">			}</a>
<a name="ln2978"> </a>
<a name="ln2979">			delete[] opList;</a>
<a name="ln2980">			delete[] ptList;</a>
<a name="ln2981">			break;</a>
<a name="ln2982">		}</a>
<a name="ln2983">		case AS_FILL_REGION:</a>
<a name="ln2984">		{</a>
<a name="ln2985">			DTRACE((&quot;ServerWindow %s: Message AS_FILL_REGION\n&quot;, Title()));</a>
<a name="ln2986"> </a>
<a name="ln2987">			BRegion region;</a>
<a name="ln2988">			if (link.ReadRegion(&amp;region) &lt; B_OK)</a>
<a name="ln2989">				break;</a>
<a name="ln2990"> </a>
<a name="ln2991">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;region);</a>
<a name="ln2992">			drawingEngine-&gt;FillRegion(region);</a>
<a name="ln2993"> </a>
<a name="ln2994">			break;</a>
<a name="ln2995">		}</a>
<a name="ln2996">		case AS_FILL_REGION_GRADIENT:</a>
<a name="ln2997">		{</a>
<a name="ln2998">			DTRACE((&quot;ServerWindow %s: Message AS_FILL_REGION_GRADIENT\n&quot;,</a>
<a name="ln2999">				Title()));</a>
<a name="ln3000"> </a>
<a name="ln3001">			BRegion region;</a>
<a name="ln3002">			link.ReadRegion(&amp;region);</a>
<a name="ln3003"> </a>
<a name="ln3004">			BGradient* gradient;</a>
<a name="ln3005">			if (link.ReadGradient(&amp;gradient) != B_OK)</a>
<a name="ln3006">				break;</a>
<a name="ln3007"> </a>
<a name="ln3008">			const SimpleTransform transform =</a>
<a name="ln3009">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln3010">			transform.Apply(&amp;region);</a>
<a name="ln3011">			transform.Apply(gradient);</a>
<a name="ln3012">			drawingEngine-&gt;FillRegion(region, *gradient);</a>
<a name="ln3013">			delete gradient;</a>
<a name="ln3014">			break;</a>
<a name="ln3015">		}</a>
<a name="ln3016">		case AS_STROKE_LINEARRAY:</a>
<a name="ln3017">		{</a>
<a name="ln3018">			DTRACE((&quot;ServerWindow %s: Message AS_STROKE_LINEARRAY\n&quot;,</a>
<a name="ln3019">				Title()));</a>
<a name="ln3020"> </a>
<a name="ln3021">			// Attached Data:</a>
<a name="ln3022">			// 1) int32 Number of lines in the array</a>
<a name="ln3023">			// 2) LineArrayData</a>
<a name="ln3024"> </a>
<a name="ln3025">			int32 lineCount;</a>
<a name="ln3026">			if (link.Read&lt;int32&gt;(&amp;lineCount) != B_OK || lineCount &lt;= 0)</a>
<a name="ln3027">				break;</a>
<a name="ln3028"> </a>
<a name="ln3029">			// To speed things up, try to use a stack allocation and only</a>
<a name="ln3030">			// fall back to the heap if there are enough lines...</a>
<a name="ln3031">			ViewLineArrayInfo* lineData;</a>
<a name="ln3032">			const int32 kStackBufferLineDataCount = 64;</a>
<a name="ln3033">			ViewLineArrayInfo lineDataStackBuffer[kStackBufferLineDataCount];</a>
<a name="ln3034">			if (lineCount &gt; kStackBufferLineDataCount) {</a>
<a name="ln3035">				lineData = new(std::nothrow) ViewLineArrayInfo[lineCount];</a>
<a name="ln3036">				if (lineData == NULL)</a>
<a name="ln3037">					break;</a>
<a name="ln3038">			} else</a>
<a name="ln3039">				lineData = lineDataStackBuffer;</a>
<a name="ln3040"> </a>
<a name="ln3041">			// Read them all in one go</a>
<a name="ln3042">			size_t dataSize = lineCount * sizeof(ViewLineArrayInfo);</a>
<a name="ln3043">			if (link.Read(lineData, dataSize) != B_OK) {</a>
<a name="ln3044">				if (lineData != lineDataStackBuffer)</a>
<a name="ln3045">					delete[] lineData;</a>
<a name="ln3046">				break;</a>
<a name="ln3047">			}</a>
<a name="ln3048"> </a>
<a name="ln3049">			// Convert to screen coords and draw</a>
<a name="ln3050">			const SimpleTransform transform =</a>
<a name="ln3051">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln3052">			for (int32 i = 0; i &lt; lineCount; i++) {</a>
<a name="ln3053">				transform.Apply(&amp;lineData[i].startPoint);</a>
<a name="ln3054">				transform.Apply(&amp;lineData[i].endPoint);</a>
<a name="ln3055">			}</a>
<a name="ln3056">			drawingEngine-&gt;StrokeLineArray(lineCount, lineData);</a>
<a name="ln3057"> </a>
<a name="ln3058">			if (lineData != lineDataStackBuffer)</a>
<a name="ln3059">				delete[] lineData;</a>
<a name="ln3060">			break;</a>
<a name="ln3061">		}</a>
<a name="ln3062">		case AS_DRAW_STRING:</a>
<a name="ln3063">		case AS_DRAW_STRING_WITH_DELTA:</a>
<a name="ln3064">		{</a>
<a name="ln3065">			ViewDrawStringInfo info;</a>
<a name="ln3066">			if (link.Read&lt;ViewDrawStringInfo&gt;(&amp;info) != B_OK</a>
<a name="ln3067">				|| info.stringLength &lt;= 0) {</a>
<a name="ln3068">				break;</a>
<a name="ln3069">			}</a>
<a name="ln3070"> </a>
<a name="ln3071">			const ssize_t kMaxStackStringSize = 4096;</a>
<a name="ln3072">			char stackString[kMaxStackStringSize];</a>
<a name="ln3073">			char* string = stackString;</a>
<a name="ln3074">			if (info.stringLength &gt;= kMaxStackStringSize) {</a>
<a name="ln3075">				// NOTE: Careful, the + 1 is for termination!</a>
<a name="ln3076">				string = (char*)malloc((info.stringLength + 1 + 63) / 64 * 64);</a>
<a name="ln3077">				if (string == NULL)</a>
<a name="ln3078">					break;</a>
<a name="ln3079">			}</a>
<a name="ln3080"> </a>
<a name="ln3081">			escapement_delta* delta = NULL;</a>
<a name="ln3082">			if (code == AS_DRAW_STRING_WITH_DELTA) {</a>
<a name="ln3083">				// In this case, info.delta will contain valid values.</a>
<a name="ln3084">				delta = &amp;info.delta;</a>
<a name="ln3085">			}</a>
<a name="ln3086"> </a>
<a name="ln3087">			if (link.Read(string, info.stringLength) != B_OK) {</a>
<a name="ln3088">				if (string != stackString)</a>
<a name="ln3089">					free(string);</a>
<a name="ln3090">				break;</a>
<a name="ln3091">			}</a>
<a name="ln3092">			// Terminate the string, if nothing else, it's important</a>
<a name="ln3093">			// for the DTRACE call below...</a>
<a name="ln3094">			string[info.stringLength] = '\0';</a>
<a name="ln3095"> </a>
<a name="ln3096">			DTRACE((&quot;ServerWindow %s: Message AS_DRAW_STRING, View: %s &quot;</a>
<a name="ln3097">				&quot;-&gt; %s\n&quot;, Title(), fCurrentView-&gt;Name(), string));</a>
<a name="ln3098"> </a>
<a name="ln3099">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;info.location);</a>
<a name="ln3100">			BPoint penLocation = drawingEngine-&gt;DrawString(string,</a>
<a name="ln3101">				info.stringLength, info.location, delta);</a>
<a name="ln3102"> </a>
<a name="ln3103">			fCurrentView-&gt;ScreenToPenTransform().Apply(&amp;penLocation);</a>
<a name="ln3104">			fCurrentView-&gt;CurrentState()-&gt;SetPenLocation(penLocation);</a>
<a name="ln3105"> </a>
<a name="ln3106">			if (string != stackString)</a>
<a name="ln3107">				free(string);</a>
<a name="ln3108">			break;</a>
<a name="ln3109">		}</a>
<a name="ln3110">		case AS_DRAW_STRING_WITH_OFFSETS:</a>
<a name="ln3111">		{</a>
<a name="ln3112">			int32 stringLength;</a>
<a name="ln3113">			if (link.Read&lt;int32&gt;(&amp;stringLength) != B_OK || stringLength &lt;= 0)</a>
<a name="ln3114">				break;</a>
<a name="ln3115"> </a>
<a name="ln3116">			int32 glyphCount;</a>
<a name="ln3117">			if (link.Read&lt;int32&gt;(&amp;glyphCount) != B_OK || glyphCount &lt;= 0)</a>
<a name="ln3118">				break;</a>
<a name="ln3119"> </a>
<a name="ln3120">			const ssize_t kMaxStackStringSize = 512;</a>
<a name="ln3121">			char stackString[kMaxStackStringSize];</a>
<a name="ln3122">			char* string = stackString;</a>
<a name="ln3123">			BPoint stackLocations[kMaxStackStringSize];</a>
<a name="ln3124">			BPoint* locations = stackLocations;</a>
<a name="ln3125">			MemoryDeleter stringDeleter;</a>
<a name="ln3126">			MemoryDeleter locationsDeleter;</a>
<a name="ln3127">			if (stringLength &gt;= kMaxStackStringSize) {</a>
<a name="ln3128">				// NOTE: Careful, the + 1 is for termination!</a>
<a name="ln3129">				string = (char*)malloc((stringLength + 1 + 63) / 64 * 64);</a>
<a name="ln3130">				if (string == NULL)</a>
<a name="ln3131">					break;</a>
<a name="ln3132">				stringDeleter.SetTo(string);</a>
<a name="ln3133">			}</a>
<a name="ln3134">			if (glyphCount &gt; kMaxStackStringSize) {</a>
<a name="ln3135">				locations = (BPoint*)malloc(</a>
<a name="ln3136">					((glyphCount * sizeof(BPoint)) + 63) / 64 * 64);</a>
<a name="ln3137">				if (locations == NULL)</a>
<a name="ln3138">					break;</a>
<a name="ln3139">				locationsDeleter.SetTo(locations);</a>
<a name="ln3140">			}</a>
<a name="ln3141"> </a>
<a name="ln3142">			if (link.Read(string, stringLength) != B_OK)</a>
<a name="ln3143">				break;</a>
<a name="ln3144">			// Count UTF8 glyphs and make sure we have enough locations</a>
<a name="ln3145">			if ((int32)UTF8CountChars(string, stringLength) &gt; glyphCount)</a>
<a name="ln3146">				break;</a>
<a name="ln3147">			if (link.Read(locations, glyphCount * sizeof(BPoint)) != B_OK)</a>
<a name="ln3148">				break;</a>
<a name="ln3149">			// Terminate the string, if nothing else, it's important</a>
<a name="ln3150">			// for the DTRACE call below...</a>
<a name="ln3151">			string[stringLength] = '\0';</a>
<a name="ln3152"> </a>
<a name="ln3153">			DTRACE((&quot;ServerWindow %s: Message AS_DRAW_STRING_WITH_OFFSETS, View: %s &quot;</a>
<a name="ln3154">				&quot;-&gt; %s\n&quot;, Title(), fCurrentView-&gt;Name(), string));</a>
<a name="ln3155"> </a>
<a name="ln3156">			const SimpleTransform transform =</a>
<a name="ln3157">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln3158">			for (int32 i = 0; i &lt; glyphCount; i++)</a>
<a name="ln3159">				transform.Apply(&amp;locations[i]);</a>
<a name="ln3160"> </a>
<a name="ln3161">			BPoint penLocation = drawingEngine-&gt;DrawString(string,</a>
<a name="ln3162">				stringLength, locations);</a>
<a name="ln3163"> </a>
<a name="ln3164">			fCurrentView-&gt;ScreenToPenTransform().Apply(&amp;penLocation);</a>
<a name="ln3165">			fCurrentView-&gt;CurrentState()-&gt;SetPenLocation(penLocation);</a>
<a name="ln3166"> </a>
<a name="ln3167">			break;</a>
<a name="ln3168">		}</a>
<a name="ln3169"> </a>
<a name="ln3170">		case AS_VIEW_DRAW_PICTURE:</a>
<a name="ln3171">		{</a>
<a name="ln3172">			int32 token;</a>
<a name="ln3173">			link.Read&lt;int32&gt;(&amp;token);</a>
<a name="ln3174"> </a>
<a name="ln3175">			BPoint where;</a>
<a name="ln3176">			if (link.Read&lt;BPoint&gt;(&amp;where) == B_OK) {</a>
<a name="ln3177">				ServerPicture* picture = App()-&gt;GetPicture(token);</a>
<a name="ln3178">				if (picture != NULL) {</a>
<a name="ln3179">					// Setting the drawing origin outside of the</a>
<a name="ln3180">					// state makes sure that everything the picture</a>
<a name="ln3181">					// does is relative to the global picture offset.</a>
<a name="ln3182">					fCurrentView-&gt;PushState();</a>
<a name="ln3183">					fCurrentView-&gt;SetDrawingOrigin(where);</a>
<a name="ln3184"> </a>
<a name="ln3185">					fCurrentView-&gt;PushState();</a>
<a name="ln3186">					picture-&gt;Play(fCurrentView);</a>
<a name="ln3187">					fCurrentView-&gt;PopState();</a>
<a name="ln3188"> </a>
<a name="ln3189">					fCurrentView-&gt;PopState();</a>
<a name="ln3190"> </a>
<a name="ln3191">					picture-&gt;ReleaseReference();</a>
<a name="ln3192">				}</a>
<a name="ln3193">			}</a>
<a name="ln3194">			break;</a>
<a name="ln3195">		}</a>
<a name="ln3196"> </a>
<a name="ln3197">		case AS_VIEW_END_LAYER:</a>
<a name="ln3198">		{</a>
<a name="ln3199">			DTRACE((&quot;ServerWindow %s: Message AS_VIEW_END_LAYER\n&quot;,</a>
<a name="ln3200">				Title()));</a>
<a name="ln3201"> </a>
<a name="ln3202">			fCurrentView-&gt;BlendAllLayers();</a>
<a name="ln3203">			fCurrentView-&gt;SetPicture(NULL);</a>
<a name="ln3204">			fCurrentView-&gt;CurrentState()-&gt;SetDrawingModeLocked(false);</a>
<a name="ln3205">			break;</a>
<a name="ln3206">		}</a>
<a name="ln3207"> </a>
<a name="ln3208">		default:</a>
<a name="ln3209">			BString codeString;</a>
<a name="ln3210">			string_for_message_code(code, codeString);</a>
<a name="ln3211">			debug_printf(&quot;ServerWindow %s received unexpected code: %s\n&quot;,</a>
<a name="ln3212">				Title(), codeString.String());</a>
<a name="ln3213"> </a>
<a name="ln3214">			if (link.NeedsReply()) {</a>
<a name="ln3215">				// the client is now blocking and waiting for a reply!</a>
<a name="ln3216">				fLink.StartMessage(B_ERROR);</a>
<a name="ln3217">				fLink.Flush();</a>
<a name="ln3218">			}</a>
<a name="ln3219">			break;</a>
<a name="ln3220">	}</a>
<a name="ln3221"> </a>
<a name="ln3222">	drawingEngine-&gt;UnlockParallelAccess();</a>
<a name="ln3223">}</a>
<a name="ln3224"> </a>
<a name="ln3225"> </a>
<a name="ln3226">bool</a>
<a name="ln3227">ServerWindow::_DispatchPictureMessage(int32 code, BPrivate::LinkReceiver&amp; link)</a>
<a name="ln3228">{</a>
<a name="ln3229">	ServerPicture* picture = fCurrentView-&gt;Picture();</a>
<a name="ln3230">	if (picture == NULL)</a>
<a name="ln3231">		return false;</a>
<a name="ln3232"> </a>
<a name="ln3233">	switch (code) {</a>
<a name="ln3234">		case AS_VIEW_SET_ORIGIN:</a>
<a name="ln3235">		{</a>
<a name="ln3236">			float x, y;</a>
<a name="ln3237">			link.Read&lt;float&gt;(&amp;x);</a>
<a name="ln3238">			link.Read&lt;float&gt;(&amp;y);</a>
<a name="ln3239"> </a>
<a name="ln3240">			picture-&gt;WriteSetOrigin(BPoint(x, y));</a>
<a name="ln3241">			break;</a>
<a name="ln3242">		}</a>
<a name="ln3243"> </a>
<a name="ln3244">		case AS_VIEW_INVERT_RECT:</a>
<a name="ln3245">		{</a>
<a name="ln3246">			BRect rect;</a>
<a name="ln3247">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln3248">			picture-&gt;WriteInvertRect(rect);</a>
<a name="ln3249">			break;</a>
<a name="ln3250">		}</a>
<a name="ln3251"> </a>
<a name="ln3252">		case AS_VIEW_PUSH_STATE:</a>
<a name="ln3253">		{</a>
<a name="ln3254">			picture-&gt;WritePushState();</a>
<a name="ln3255">			break;</a>
<a name="ln3256">		}</a>
<a name="ln3257"> </a>
<a name="ln3258">		case AS_VIEW_POP_STATE:</a>
<a name="ln3259">		{</a>
<a name="ln3260">			picture-&gt;WritePopState();</a>
<a name="ln3261">			break;</a>
<a name="ln3262">		}</a>
<a name="ln3263"> </a>
<a name="ln3264">		case AS_VIEW_SET_DRAWING_MODE:</a>
<a name="ln3265">		{</a>
<a name="ln3266">			int8 drawingMode;</a>
<a name="ln3267">			link.Read&lt;int8&gt;(&amp;drawingMode);</a>
<a name="ln3268"> </a>
<a name="ln3269">			picture-&gt;WriteSetDrawingMode((drawing_mode)drawingMode);</a>
<a name="ln3270"> </a>
<a name="ln3271">			fCurrentView-&gt;CurrentState()-&gt;SetDrawingMode(</a>
<a name="ln3272">				(drawing_mode)drawingMode);</a>
<a name="ln3273">			fWindow-&gt;GetDrawingEngine()-&gt;SetDrawingMode(</a>
<a name="ln3274">				(drawing_mode)drawingMode);</a>
<a name="ln3275">			break;</a>
<a name="ln3276">		}</a>
<a name="ln3277"> </a>
<a name="ln3278">		case AS_VIEW_SET_PEN_LOC:</a>
<a name="ln3279">		{</a>
<a name="ln3280">			BPoint location;</a>
<a name="ln3281">			link.Read&lt;BPoint&gt;(&amp;location);</a>
<a name="ln3282">			picture-&gt;WriteSetPenLocation(location);</a>
<a name="ln3283"> </a>
<a name="ln3284">			fCurrentView-&gt;CurrentState()-&gt;SetPenLocation(location);</a>
<a name="ln3285">			break;</a>
<a name="ln3286">		}</a>
<a name="ln3287"> </a>
<a name="ln3288">		case AS_VIEW_SET_PEN_SIZE:</a>
<a name="ln3289">		{</a>
<a name="ln3290">			float penSize;</a>
<a name="ln3291">			link.Read&lt;float&gt;(&amp;penSize);</a>
<a name="ln3292">			picture-&gt;WriteSetPenSize(penSize);</a>
<a name="ln3293"> </a>
<a name="ln3294">			fCurrentView-&gt;CurrentState()-&gt;SetPenSize(penSize);</a>
<a name="ln3295">			fWindow-&gt;GetDrawingEngine()-&gt;SetPenSize(</a>
<a name="ln3296">				fCurrentView-&gt;CurrentState()-&gt;PenSize());</a>
<a name="ln3297">			break;</a>
<a name="ln3298">		}</a>
<a name="ln3299"> </a>
<a name="ln3300">		case AS_VIEW_SET_LINE_MODE:</a>
<a name="ln3301">		{</a>
<a name="ln3302"> </a>
<a name="ln3303">			ViewSetLineModeInfo info;</a>
<a name="ln3304">			link.Read&lt;ViewSetLineModeInfo&gt;(&amp;info);</a>
<a name="ln3305"> </a>
<a name="ln3306">			picture-&gt;WriteSetLineMode(info.lineCap, info.lineJoin,</a>
<a name="ln3307">				info.miterLimit);</a>
<a name="ln3308"> </a>
<a name="ln3309">			fCurrentView-&gt;CurrentState()-&gt;SetLineCapMode(info.lineCap);</a>
<a name="ln3310">			fCurrentView-&gt;CurrentState()-&gt;SetLineJoinMode(info.lineJoin);</a>
<a name="ln3311">			fCurrentView-&gt;CurrentState()-&gt;SetMiterLimit(info.miterLimit);</a>
<a name="ln3312"> </a>
<a name="ln3313">			fWindow-&gt;GetDrawingEngine()-&gt;SetStrokeMode(info.lineCap,</a>
<a name="ln3314">				info.lineJoin, info.miterLimit);</a>
<a name="ln3315">			break;</a>
<a name="ln3316">		}</a>
<a name="ln3317">		case AS_VIEW_SET_SCALE:</a>
<a name="ln3318">		{</a>
<a name="ln3319">			float scale;</a>
<a name="ln3320">			if (link.Read&lt;float&gt;(&amp;scale) != B_OK)</a>
<a name="ln3321">				break;</a>
<a name="ln3322"> </a>
<a name="ln3323">			picture-&gt;WriteSetScale(scale);</a>
<a name="ln3324"> </a>
<a name="ln3325">			fCurrentView-&gt;SetScale(scale);</a>
<a name="ln3326">			_UpdateDrawState(fCurrentView);</a>
<a name="ln3327">			break;</a>
<a name="ln3328">		}</a>
<a name="ln3329">		case AS_VIEW_SET_TRANSFORM:</a>
<a name="ln3330">		{</a>
<a name="ln3331">			BAffineTransform transform;</a>
<a name="ln3332">			if (link.Read&lt;BAffineTransform&gt;(&amp;transform) != B_OK)</a>
<a name="ln3333">				break;</a>
<a name="ln3334"> </a>
<a name="ln3335">			picture-&gt;WriteSetTransform(transform);</a>
<a name="ln3336"> </a>
<a name="ln3337">			fCurrentView-&gt;CurrentState()-&gt;SetTransform(transform);</a>
<a name="ln3338">			_UpdateDrawState(fCurrentView);</a>
<a name="ln3339">			break;</a>
<a name="ln3340">		}</a>
<a name="ln3341"> </a>
<a name="ln3342">		case AS_VIEW_AFFINE_TRANSLATE:</a>
<a name="ln3343">		{</a>
<a name="ln3344">			double x, y;</a>
<a name="ln3345">			link.Read&lt;double&gt;(&amp;x);</a>
<a name="ln3346">			link.Read&lt;double&gt;(&amp;y);</a>
<a name="ln3347"> </a>
<a name="ln3348">			picture-&gt;WriteTranslateBy(x, y);</a>
<a name="ln3349"> </a>
<a name="ln3350">			BAffineTransform current =</a>
<a name="ln3351">				fCurrentView-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln3352">			current.PreTranslateBy(x, y);</a>
<a name="ln3353">			fCurrentView-&gt;CurrentState()-&gt;SetTransform(current);</a>
<a name="ln3354">			_UpdateDrawState(fCurrentView);</a>
<a name="ln3355">			break;</a>
<a name="ln3356">		}</a>
<a name="ln3357"> </a>
<a name="ln3358">		case AS_VIEW_AFFINE_SCALE:</a>
<a name="ln3359">		{</a>
<a name="ln3360">			double x, y;</a>
<a name="ln3361">			link.Read&lt;double&gt;(&amp;x);</a>
<a name="ln3362">			link.Read&lt;double&gt;(&amp;y);</a>
<a name="ln3363"> </a>
<a name="ln3364">			picture-&gt;WriteScaleBy(x, y);</a>
<a name="ln3365"> </a>
<a name="ln3366">			BAffineTransform current =</a>
<a name="ln3367">				fCurrentView-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln3368">			current.PreScaleBy(x, y);</a>
<a name="ln3369">			fCurrentView-&gt;CurrentState()-&gt;SetTransform(current);</a>
<a name="ln3370">			_UpdateDrawState(fCurrentView);</a>
<a name="ln3371">			break;</a>
<a name="ln3372">		}</a>
<a name="ln3373"> </a>
<a name="ln3374">		case AS_VIEW_AFFINE_ROTATE:</a>
<a name="ln3375">		{</a>
<a name="ln3376">			double angleRadians;</a>
<a name="ln3377">			link.Read&lt;double&gt;(&amp;angleRadians);</a>
<a name="ln3378"> </a>
<a name="ln3379">			picture-&gt;WriteRotateBy(angleRadians);</a>
<a name="ln3380"> </a>
<a name="ln3381">			BAffineTransform current =</a>
<a name="ln3382">				fCurrentView-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln3383">			current.PreRotateBy(angleRadians);</a>
<a name="ln3384">			fCurrentView-&gt;CurrentState()-&gt;SetTransform(current);</a>
<a name="ln3385">			_UpdateDrawState(fCurrentView);</a>
<a name="ln3386">			break;</a>
<a name="ln3387">		}</a>
<a name="ln3388"> </a>
<a name="ln3389"> </a>
<a name="ln3390">		case AS_VIEW_SET_PATTERN:</a>
<a name="ln3391">		{</a>
<a name="ln3392">			pattern pat;</a>
<a name="ln3393">			link.Read(&amp;pat, sizeof(pattern));</a>
<a name="ln3394">			picture-&gt;WriteSetPattern(pat);</a>
<a name="ln3395">			break;</a>
<a name="ln3396">		}</a>
<a name="ln3397"> </a>
<a name="ln3398">		case AS_VIEW_SET_FONT_STATE:</a>
<a name="ln3399">		{</a>
<a name="ln3400">			uint16 mask = fCurrentView-&gt;CurrentState()-&gt;ReadFontFromLink(link);</a>
<a name="ln3401">			fWindow-&gt;GetDrawingEngine()-&gt;SetFont(</a>
<a name="ln3402">				fCurrentView-&gt;CurrentState());</a>
<a name="ln3403"> </a>
<a name="ln3404">			picture-&gt;WriteFontState(fCurrentView-&gt;CurrentState()-&gt;Font(), mask);</a>
<a name="ln3405">			break;</a>
<a name="ln3406">		}</a>
<a name="ln3407"> </a>
<a name="ln3408">		case AS_FILL_RECT:</a>
<a name="ln3409">		case AS_STROKE_RECT:</a>
<a name="ln3410">		{</a>
<a name="ln3411">			BRect rect;</a>
<a name="ln3412">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln3413"> </a>
<a name="ln3414">			picture-&gt;WriteDrawRect(rect, code == AS_FILL_RECT);</a>
<a name="ln3415">			break;</a>
<a name="ln3416">		}</a>
<a name="ln3417"> </a>
<a name="ln3418">		case AS_FILL_REGION:</a>
<a name="ln3419">		{</a>
<a name="ln3420">			// There is no B_PIC_FILL_REGION op, we have to</a>
<a name="ln3421">			// implement it using B_PIC_FILL_RECT</a>
<a name="ln3422">			BRegion region;</a>
<a name="ln3423">			if (link.ReadRegion(&amp;region) &lt; B_OK)</a>
<a name="ln3424">				break;</a>
<a name="ln3425">			for (int32 i = 0; i &lt; region.CountRects(); i++)</a>
<a name="ln3426">				picture-&gt;WriteDrawRect(region.RectAt(i), true);</a>
<a name="ln3427">			break;</a>
<a name="ln3428">		}</a>
<a name="ln3429"> </a>
<a name="ln3430">		case AS_STROKE_ROUNDRECT:</a>
<a name="ln3431">		case AS_FILL_ROUNDRECT:</a>
<a name="ln3432">		{</a>
<a name="ln3433">			BRect rect;</a>
<a name="ln3434">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln3435"> </a>
<a name="ln3436">			BPoint radii;</a>
<a name="ln3437">			link.Read&lt;float&gt;(&amp;radii.x);</a>
<a name="ln3438">			link.Read&lt;float&gt;(&amp;radii.y);</a>
<a name="ln3439"> </a>
<a name="ln3440">			picture-&gt;WriteDrawRoundRect(rect, radii, code == AS_FILL_ROUNDRECT);</a>
<a name="ln3441">			break;</a>
<a name="ln3442">		}</a>
<a name="ln3443"> </a>
<a name="ln3444">		case AS_STROKE_ELLIPSE:</a>
<a name="ln3445">		case AS_FILL_ELLIPSE:</a>
<a name="ln3446">		{</a>
<a name="ln3447">			BRect rect;</a>
<a name="ln3448">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln3449">			picture-&gt;WriteDrawEllipse(rect, code == AS_FILL_ELLIPSE);</a>
<a name="ln3450">			break;</a>
<a name="ln3451">		}</a>
<a name="ln3452"> </a>
<a name="ln3453">		case AS_STROKE_ARC:</a>
<a name="ln3454">		case AS_FILL_ARC:</a>
<a name="ln3455">		{</a>
<a name="ln3456">			BRect rect;</a>
<a name="ln3457">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln3458">			float startTheta, arcTheta;</a>
<a name="ln3459">			link.Read&lt;float&gt;(&amp;startTheta);</a>
<a name="ln3460">			link.Read&lt;float&gt;(&amp;arcTheta);</a>
<a name="ln3461"> </a>
<a name="ln3462">			BPoint radii((rect.Width() + 1) / 2, (rect.Height() + 1) / 2);</a>
<a name="ln3463">			BPoint center = rect.LeftTop() + radii;</a>
<a name="ln3464"> </a>
<a name="ln3465">			picture-&gt;WriteDrawArc(center, radii, startTheta, arcTheta,</a>
<a name="ln3466">				code == AS_FILL_ARC);</a>
<a name="ln3467">			break;</a>
<a name="ln3468">		}</a>
<a name="ln3469"> </a>
<a name="ln3470">		case AS_STROKE_TRIANGLE:</a>
<a name="ln3471">		case AS_FILL_TRIANGLE:</a>
<a name="ln3472">		{</a>
<a name="ln3473">			// There is no B_PIC_FILL/STROKE_TRIANGLE op,</a>
<a name="ln3474">			// we implement it using B_PIC_FILL/STROKE_POLYGON</a>
<a name="ln3475">			BPoint points[3];</a>
<a name="ln3476"> </a>
<a name="ln3477">			for (int32 i = 0; i &lt; 3; i++) {</a>
<a name="ln3478">				link.Read&lt;BPoint&gt;(&amp;(points[i]));</a>
<a name="ln3479">			}</a>
<a name="ln3480"> </a>
<a name="ln3481">			BRect rect;</a>
<a name="ln3482">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln3483"> </a>
<a name="ln3484">			picture-&gt;WriteDrawPolygon(3, points,</a>
<a name="ln3485">					true, code == AS_FILL_TRIANGLE);</a>
<a name="ln3486">			break;</a>
<a name="ln3487">		}</a>
<a name="ln3488">		case AS_STROKE_POLYGON:</a>
<a name="ln3489">		case AS_FILL_POLYGON:</a>
<a name="ln3490">		{</a>
<a name="ln3491">			BRect polyFrame;</a>
<a name="ln3492">			bool isClosed = true;</a>
<a name="ln3493">			int32 pointCount;</a>
<a name="ln3494">			const bool fill = (code == AS_FILL_POLYGON);</a>
<a name="ln3495"> </a>
<a name="ln3496">			link.Read&lt;BRect&gt;(&amp;polyFrame);</a>
<a name="ln3497">			if (code == AS_STROKE_POLYGON)</a>
<a name="ln3498">				link.Read&lt;bool&gt;(&amp;isClosed);</a>
<a name="ln3499">			link.Read&lt;int32&gt;(&amp;pointCount);</a>
<a name="ln3500"> </a>
<a name="ln3501">			BPoint* pointList = new(nothrow) BPoint[pointCount];</a>
<a name="ln3502">			if (link.Read(pointList, pointCount * sizeof(BPoint)) &gt;= B_OK) {</a>
<a name="ln3503">				picture-&gt;WriteDrawPolygon(pointCount, pointList,</a>
<a name="ln3504">					isClosed &amp;&amp; pointCount &gt; 2, fill);</a>
<a name="ln3505">			}</a>
<a name="ln3506">			delete[] pointList;</a>
<a name="ln3507">			break;</a>
<a name="ln3508">		}</a>
<a name="ln3509"> </a>
<a name="ln3510">		case AS_STROKE_BEZIER:</a>
<a name="ln3511">		case AS_FILL_BEZIER:</a>
<a name="ln3512">		{</a>
<a name="ln3513">			BPoint points[4];</a>
<a name="ln3514">			for (int32 i = 0; i &lt; 4; i++) {</a>
<a name="ln3515">				link.Read&lt;BPoint&gt;(&amp;(points[i]));</a>
<a name="ln3516">			}</a>
<a name="ln3517">			picture-&gt;WriteDrawBezier(points, code == AS_FILL_BEZIER);</a>
<a name="ln3518">			break;</a>
<a name="ln3519">		}</a>
<a name="ln3520"> </a>
<a name="ln3521">		case AS_STROKE_LINE:</a>
<a name="ln3522">		{</a>
<a name="ln3523">			ViewStrokeLineInfo info;</a>
<a name="ln3524">			link.Read&lt;ViewStrokeLineInfo&gt;(&amp;info);</a>
<a name="ln3525"> </a>
<a name="ln3526">			picture-&gt;WriteStrokeLine(info.startPoint, info.endPoint);</a>
<a name="ln3527"> </a>
<a name="ln3528">			BPoint penPos = info.endPoint;</a>
<a name="ln3529">			const SimpleTransform transform =</a>
<a name="ln3530">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln3531">			transform.Apply(&amp;info.endPoint);</a>
<a name="ln3532">			fCurrentView-&gt;CurrentState()-&gt;SetPenLocation(penPos);</a>
<a name="ln3533">			break;</a>
<a name="ln3534">		}</a>
<a name="ln3535"> </a>
<a name="ln3536">		case AS_STROKE_LINEARRAY:</a>
<a name="ln3537">		{</a>
<a name="ln3538">			int32 lineCount;</a>
<a name="ln3539">			if (link.Read&lt;int32&gt;(&amp;lineCount) != B_OK || lineCount &lt;= 0)</a>
<a name="ln3540">				break;</a>
<a name="ln3541"> </a>
<a name="ln3542">			// To speed things up, try to use a stack allocation and only</a>
<a name="ln3543">			// fall back to the heap if there are enough lines...</a>
<a name="ln3544">			ViewLineArrayInfo* lineData;</a>
<a name="ln3545">			const int32 kStackBufferLineDataCount = 64;</a>
<a name="ln3546">			ViewLineArrayInfo lineDataStackBuffer[kStackBufferLineDataCount];</a>
<a name="ln3547">			if (lineCount &gt; kStackBufferLineDataCount) {</a>
<a name="ln3548">				lineData = new(std::nothrow) ViewLineArrayInfo[lineCount];</a>
<a name="ln3549">				if (lineData == NULL)</a>
<a name="ln3550">					break;</a>
<a name="ln3551">			} else</a>
<a name="ln3552">				lineData = lineDataStackBuffer;</a>
<a name="ln3553"> </a>
<a name="ln3554">			// Read them all in one go</a>
<a name="ln3555">			size_t dataSize = lineCount * sizeof(ViewLineArrayInfo);</a>
<a name="ln3556">			if (link.Read(lineData, dataSize) != B_OK) {</a>
<a name="ln3557">				if (lineData != lineDataStackBuffer)</a>
<a name="ln3558">					delete[] lineData;</a>
<a name="ln3559">				break;</a>
<a name="ln3560">			}</a>
<a name="ln3561"> </a>
<a name="ln3562">			picture-&gt;WritePushState();</a>
<a name="ln3563"> </a>
<a name="ln3564">			for (int32 i = 0; i &lt; lineCount; i++) {</a>
<a name="ln3565">				picture-&gt;WriteSetHighColor(lineData[i].color);</a>
<a name="ln3566">				picture-&gt;WriteStrokeLine(lineData[i].startPoint,</a>
<a name="ln3567">					lineData[i].endPoint);</a>
<a name="ln3568">			}</a>
<a name="ln3569"> </a>
<a name="ln3570">			picture-&gt;WritePopState();</a>
<a name="ln3571"> </a>
<a name="ln3572">			if (lineData != lineDataStackBuffer)</a>
<a name="ln3573">				delete[] lineData;</a>
<a name="ln3574">			break;</a>
<a name="ln3575">		}</a>
<a name="ln3576"> </a>
<a name="ln3577">		case AS_VIEW_SET_LOW_COLOR:</a>
<a name="ln3578">		case AS_VIEW_SET_HIGH_COLOR:</a>
<a name="ln3579">		{</a>
<a name="ln3580">			rgb_color color;</a>
<a name="ln3581">			link.Read(&amp;color, sizeof(rgb_color));</a>
<a name="ln3582"> </a>
<a name="ln3583">			if (code == AS_VIEW_SET_HIGH_COLOR) {</a>
<a name="ln3584">				picture-&gt;WriteSetHighColor(color);</a>
<a name="ln3585">				fCurrentView-&gt;CurrentState()-&gt;SetHighColor(color);</a>
<a name="ln3586">				fWindow-&gt;GetDrawingEngine()-&gt;SetHighColor(color);</a>
<a name="ln3587">			} else {</a>
<a name="ln3588">				picture-&gt;WriteSetLowColor(color);</a>
<a name="ln3589">				fCurrentView-&gt;CurrentState()-&gt;SetLowColor(color);</a>
<a name="ln3590">				fWindow-&gt;GetDrawingEngine()-&gt;SetLowColor(color);</a>
<a name="ln3591">			}</a>
<a name="ln3592">		}	break;</a>
<a name="ln3593"> </a>
<a name="ln3594">		case AS_DRAW_STRING:</a>
<a name="ln3595">		case AS_DRAW_STRING_WITH_DELTA:</a>
<a name="ln3596">		{</a>
<a name="ln3597">			ViewDrawStringInfo info;</a>
<a name="ln3598">			if (link.Read&lt;ViewDrawStringInfo&gt;(&amp;info) != B_OK)</a>
<a name="ln3599">				break;</a>
<a name="ln3600"> </a>
<a name="ln3601">			char* string = (char*)malloc(info.stringLength + 1);</a>
<a name="ln3602">			if (string == NULL)</a>
<a name="ln3603">				break;</a>
<a name="ln3604"> </a>
<a name="ln3605">			if (code != AS_DRAW_STRING_WITH_DELTA) {</a>
<a name="ln3606">				// In this case, info.delta will NOT contain valid values.</a>
<a name="ln3607">				info.delta = (escapement_delta){ 0, 0 };</a>
<a name="ln3608">			}</a>
<a name="ln3609"> </a>
<a name="ln3610">			if (link.Read(string, info.stringLength) != B_OK) {</a>
<a name="ln3611">				free(string);</a>
<a name="ln3612">				break;</a>
<a name="ln3613">			}</a>
<a name="ln3614">			// Terminate the string</a>
<a name="ln3615">			string[info.stringLength] = '\0';</a>
<a name="ln3616"> </a>
<a name="ln3617">			picture-&gt;WriteDrawString(info.location, string, info.stringLength,</a>
<a name="ln3618">				info.delta);</a>
<a name="ln3619"> </a>
<a name="ln3620">			// We need to update the pen location</a>
<a name="ln3621">			fCurrentView-&gt;PenToScreenTransform().Apply(&amp;info.location);</a>
<a name="ln3622">			BPoint penLocation = fWindow-&gt;GetDrawingEngine()-&gt;DrawStringDry(</a>
<a name="ln3623">				string, info.stringLength, info.location, &amp;info.delta);</a>
<a name="ln3624"> </a>
<a name="ln3625">			fCurrentView-&gt;ScreenToPenTransform().Apply(&amp;penLocation);</a>
<a name="ln3626">			fCurrentView-&gt;CurrentState()-&gt;SetPenLocation(penLocation);</a>
<a name="ln3627"> </a>
<a name="ln3628">			free(string);</a>
<a name="ln3629">			break;</a>
<a name="ln3630">		}</a>
<a name="ln3631"> </a>
<a name="ln3632">		case AS_DRAW_STRING_WITH_OFFSETS:</a>
<a name="ln3633">		{</a>
<a name="ln3634">			int32 stringLength;</a>
<a name="ln3635">			if (link.Read&lt;int32&gt;(&amp;stringLength) != B_OK || stringLength &lt;= 0)</a>
<a name="ln3636">				break;</a>
<a name="ln3637"> </a>
<a name="ln3638">			int32 glyphCount;</a>
<a name="ln3639">			if (link.Read&lt;int32&gt;(&amp;glyphCount) != B_OK || glyphCount &lt;= 0)</a>
<a name="ln3640">				break;</a>
<a name="ln3641"> </a>
<a name="ln3642">			const ssize_t kMaxStackStringSize = 512;</a>
<a name="ln3643">			char stackString[kMaxStackStringSize];</a>
<a name="ln3644">			char* string = stackString;</a>
<a name="ln3645">			BPoint stackLocations[kMaxStackStringSize];</a>
<a name="ln3646">			BPoint* locations = stackLocations;</a>
<a name="ln3647">			MemoryDeleter stringDeleter;</a>
<a name="ln3648">			MemoryDeleter locationsDeleter;</a>
<a name="ln3649">			if (stringLength &gt;= kMaxStackStringSize) {</a>
<a name="ln3650">				// NOTE: Careful, the + 1 is for termination!</a>
<a name="ln3651">				string = (char*)malloc((stringLength + 1 + 63) / 64 * 64);</a>
<a name="ln3652">				if (string == NULL)</a>
<a name="ln3653">					break;</a>
<a name="ln3654">				stringDeleter.SetTo(string);</a>
<a name="ln3655">			}</a>
<a name="ln3656">			if (glyphCount &gt; kMaxStackStringSize) {</a>
<a name="ln3657">				locations = (BPoint*)malloc(</a>
<a name="ln3658">					((glyphCount * sizeof(BPoint)) + 63) / 64 * 64);</a>
<a name="ln3659">				if (locations == NULL)</a>
<a name="ln3660">					break;</a>
<a name="ln3661">				locationsDeleter.SetTo(locations);</a>
<a name="ln3662">			}</a>
<a name="ln3663"> </a>
<a name="ln3664">			if (link.Read(string, stringLength) != B_OK)</a>
<a name="ln3665">				break;</a>
<a name="ln3666">			// Count UTF8 glyphs and make sure we have enough locations</a>
<a name="ln3667">			if ((int32)UTF8CountChars(string, stringLength) &gt; glyphCount)</a>
<a name="ln3668">				break;</a>
<a name="ln3669">			if (link.Read(locations, glyphCount * sizeof(BPoint)) != B_OK)</a>
<a name="ln3670">				break;</a>
<a name="ln3671">			// Terminate the string</a>
<a name="ln3672">			string[stringLength] = '\0';</a>
<a name="ln3673"> </a>
<a name="ln3674">			const SimpleTransform transform =</a>
<a name="ln3675">				fCurrentView-&gt;PenToScreenTransform();</a>
<a name="ln3676">			for (int32 i = 0; i &lt; glyphCount; i++)</a>
<a name="ln3677">				transform.Apply(&amp;locations[i]);</a>
<a name="ln3678"> </a>
<a name="ln3679">			picture-&gt;WriteDrawString(string, stringLength, locations,</a>
<a name="ln3680">				glyphCount);</a>
<a name="ln3681"> </a>
<a name="ln3682">			// Update pen location</a>
<a name="ln3683">			BPoint penLocation = fWindow-&gt;GetDrawingEngine()-&gt;DrawStringDry(</a>
<a name="ln3684">				string, stringLength, locations);</a>
<a name="ln3685"> </a>
<a name="ln3686">			fCurrentView-&gt;ScreenToPenTransform().Apply(&amp;penLocation);</a>
<a name="ln3687">			fCurrentView-&gt;CurrentState()-&gt;SetPenLocation(penLocation);</a>
<a name="ln3688"> </a>
<a name="ln3689">			break;</a>
<a name="ln3690">		}</a>
<a name="ln3691"> </a>
<a name="ln3692">		case AS_STROKE_SHAPE:</a>
<a name="ln3693">		case AS_FILL_SHAPE:</a>
<a name="ln3694">		{</a>
<a name="ln3695">			BRect shapeFrame;</a>
<a name="ln3696">			int32 opCount;</a>
<a name="ln3697">			int32 ptCount;</a>
<a name="ln3698"> </a>
<a name="ln3699">			link.Read&lt;BRect&gt;(&amp;shapeFrame);</a>
<a name="ln3700">			link.Read&lt;int32&gt;(&amp;opCount);</a>
<a name="ln3701">			link.Read&lt;int32&gt;(&amp;ptCount);</a>
<a name="ln3702"> </a>
<a name="ln3703">			uint32* opList = new(std::nothrow) uint32[opCount];</a>
<a name="ln3704">			BPoint* ptList = new(std::nothrow) BPoint[ptCount];</a>
<a name="ln3705">			if (opList != NULL &amp;&amp; ptList != NULL</a>
<a name="ln3706">				&amp;&amp; link.Read(opList, opCount * sizeof(uint32)) &gt;= B_OK</a>
<a name="ln3707">				&amp;&amp; link.Read(ptList, ptCount * sizeof(BPoint)) &gt;= B_OK) {</a>
<a name="ln3708">				// This might seem a bit weird, but under BeOS, the shapes</a>
<a name="ln3709">				// are always offset by the current pen location</a>
<a name="ln3710">				BPoint penLocation</a>
<a name="ln3711">					= fCurrentView-&gt;CurrentState()-&gt;PenLocation();</a>
<a name="ln3712">				for (int32 i = 0; i &lt; ptCount; i++) {</a>
<a name="ln3713">					ptList[i] += penLocation;</a>
<a name="ln3714">				}</a>
<a name="ln3715">				const bool fill = (code == AS_FILL_SHAPE);</a>
<a name="ln3716">				picture-&gt;WriteDrawShape(opCount, opList, ptCount, ptList, fill);</a>
<a name="ln3717">			}</a>
<a name="ln3718"> </a>
<a name="ln3719">			delete[] opList;</a>
<a name="ln3720">			delete[] ptList;</a>
<a name="ln3721">			break;</a>
<a name="ln3722">		}</a>
<a name="ln3723"> </a>
<a name="ln3724">		case AS_VIEW_DRAW_BITMAP:</a>
<a name="ln3725">		{</a>
<a name="ln3726">			ViewDrawBitmapInfo info;</a>
<a name="ln3727">			link.Read&lt;ViewDrawBitmapInfo&gt;(&amp;info);</a>
<a name="ln3728"> </a>
<a name="ln3729">			ServerBitmap* bitmap = App()-&gt;GetBitmap(info.bitmapToken);</a>
<a name="ln3730">			if (bitmap == NULL)</a>
<a name="ln3731">				break;</a>
<a name="ln3732"> </a>
<a name="ln3733">			picture-&gt;WriteDrawBitmap(info.bitmapRect, info.viewRect,</a>
<a name="ln3734">				bitmap-&gt;Width(), bitmap-&gt;Height(), bitmap-&gt;BytesPerRow(),</a>
<a name="ln3735">				bitmap-&gt;ColorSpace(), info.options, bitmap-&gt;Bits(),</a>
<a name="ln3736">				bitmap-&gt;BitsLength());</a>
<a name="ln3737"> </a>
<a name="ln3738">			bitmap-&gt;ReleaseReference();</a>
<a name="ln3739">			break;</a>
<a name="ln3740">		}</a>
<a name="ln3741"> </a>
<a name="ln3742">		case AS_VIEW_DRAW_PICTURE:</a>
<a name="ln3743">		{</a>
<a name="ln3744">			int32 token;</a>
<a name="ln3745">			link.Read&lt;int32&gt;(&amp;token);</a>
<a name="ln3746"> </a>
<a name="ln3747">			BPoint where;</a>
<a name="ln3748">			if (link.Read&lt;BPoint&gt;(&amp;where) == B_OK) {</a>
<a name="ln3749">				ServerPicture* pictureToDraw = App()-&gt;GetPicture(token);</a>
<a name="ln3750">				if (pictureToDraw != NULL) {</a>
<a name="ln3751">					// We need to make a copy of the picture, since it can</a>
<a name="ln3752">					// change after it has been drawn</a>
<a name="ln3753">					ServerPicture* copy = App()-&gt;CreatePicture(pictureToDraw);</a>
<a name="ln3754">					picture-&gt;NestPicture(copy);</a>
<a name="ln3755">					picture-&gt;WriteDrawPicture(where, copy-&gt;Token());</a>
<a name="ln3756"> </a>
<a name="ln3757">					pictureToDraw-&gt;ReleaseReference();</a>
<a name="ln3758">				}</a>
<a name="ln3759">			}</a>
<a name="ln3760">			break;</a>
<a name="ln3761">		}</a>
<a name="ln3762"> </a>
<a name="ln3763">		case AS_VIEW_SET_CLIP_REGION:</a>
<a name="ln3764">		{</a>
<a name="ln3765">			int32 rectCount;</a>
<a name="ln3766">			status_t status = link.Read&lt;int32&gt;(&amp;rectCount);</a>
<a name="ln3767">				// a negative count means no</a>
<a name="ln3768">				// region for the current draw state,</a>
<a name="ln3769">				// but an *empty* region is actually valid!</a>
<a name="ln3770">				// even if it means no drawing is allowed</a>
<a name="ln3771"> </a>
<a name="ln3772">			if (status &lt; B_OK)</a>
<a name="ln3773">				break;</a>
<a name="ln3774"> </a>
<a name="ln3775">			if (rectCount &gt;= 0) {</a>
<a name="ln3776">				// we are supposed to set the clipping region</a>
<a name="ln3777">				BRegion region;</a>
<a name="ln3778">				if (rectCount &gt; 0 &amp;&amp; link.ReadRegion(&amp;region) &lt; B_OK)</a>
<a name="ln3779">					break;</a>
<a name="ln3780">				picture-&gt;WriteSetClipping(region);</a>
<a name="ln3781">			} else {</a>
<a name="ln3782">				// we are supposed to clear the clipping region</a>
<a name="ln3783">				picture-&gt;WriteClearClipping();</a>
<a name="ln3784">			}</a>
<a name="ln3785">			break;</a>
<a name="ln3786">		}</a>
<a name="ln3787"> </a>
<a name="ln3788">		case AS_VIEW_CLIP_TO_PICTURE:</a>
<a name="ln3789">		{</a>
<a name="ln3790">			int32 pictureToken;</a>
<a name="ln3791">			BPoint where;</a>
<a name="ln3792">			bool inverse = false;</a>
<a name="ln3793"> </a>
<a name="ln3794">			link.Read&lt;int32&gt;(&amp;pictureToken);</a>
<a name="ln3795">			if (pictureToken &lt; 0)</a>
<a name="ln3796">				break;</a>
<a name="ln3797"> </a>
<a name="ln3798">			link.Read&lt;BPoint&gt;(&amp;where);</a>
<a name="ln3799">			if (link.Read&lt;bool&gt;(&amp;inverse) != B_OK)</a>
<a name="ln3800">				break;</a>
<a name="ln3801"> </a>
<a name="ln3802">			ServerPicture* pictureToClip = fServerApp-&gt;GetPicture(pictureToken);</a>
<a name="ln3803">			if (pictureToClip != NULL) {</a>
<a name="ln3804">				// We need to make a copy of the picture, since it can</a>
<a name="ln3805">				// change after it has been drawn</a>
<a name="ln3806">				ServerPicture* copy = App()-&gt;CreatePicture(pictureToClip);</a>
<a name="ln3807">				picture-&gt;NestPicture(copy);</a>
<a name="ln3808">				picture-&gt;WriteClipToPicture(copy-&gt;Token(), where, inverse);</a>
<a name="ln3809"> </a>
<a name="ln3810">				pictureToClip-&gt;ReleaseReference();</a>
<a name="ln3811">			}</a>
<a name="ln3812">			break;</a>
<a name="ln3813">		}</a>
<a name="ln3814"> </a>
<a name="ln3815">		case AS_VIEW_CLIP_TO_RECT:</a>
<a name="ln3816">		{</a>
<a name="ln3817">			bool inverse;</a>
<a name="ln3818">			BRect rect;</a>
<a name="ln3819">			link.Read&lt;bool&gt;(&amp;inverse);</a>
<a name="ln3820">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln3821">			picture-&gt;WriteClipToRect(rect, inverse);</a>
<a name="ln3822"> </a>
<a name="ln3823">			break;</a>
<a name="ln3824">		}</a>
<a name="ln3825"> </a>
<a name="ln3826">		case AS_VIEW_CLIP_TO_SHAPE:</a>
<a name="ln3827">		{</a>
<a name="ln3828">			bool inverse;</a>
<a name="ln3829">			link.Read&lt;bool&gt;(&amp;inverse);</a>
<a name="ln3830"> </a>
<a name="ln3831">			shape_data shape;</a>
<a name="ln3832">			link.Read&lt;int32&gt;(&amp;shape.opCount);</a>
<a name="ln3833">			link.Read&lt;int32&gt;(&amp;shape.ptCount);</a>
<a name="ln3834">			shape.opSize = shape.opCount * sizeof(uint32);</a>
<a name="ln3835">			shape.ptSize = shape.ptCount * sizeof(BPoint);</a>
<a name="ln3836">			shape.opList = new(nothrow) uint32[shape.opCount];</a>
<a name="ln3837">			shape.ptList = new(nothrow) BPoint[shape.ptCount];</a>
<a name="ln3838">			if (link.Read(shape.opList, shape.opSize) &gt;= B_OK</a>
<a name="ln3839">				&amp;&amp; link.Read(shape.ptList, shape.ptSize) &gt;= B_OK) {</a>
<a name="ln3840">				picture-&gt;WriteClipToShape(shape.opCount, shape.opList,</a>
<a name="ln3841">					shape.ptCount, shape.ptList, inverse);</a>
<a name="ln3842">			}</a>
<a name="ln3843"> </a>
<a name="ln3844">			delete[] shape.opList;</a>
<a name="ln3845">			delete[] shape.ptList;</a>
<a name="ln3846">			break;</a>
<a name="ln3847">		}</a>
<a name="ln3848"> </a>
<a name="ln3849">		case AS_VIEW_BEGIN_PICTURE:</a>
<a name="ln3850">		{</a>
<a name="ln3851">			ServerPicture* newPicture = App()-&gt;CreatePicture();</a>
<a name="ln3852">			if (newPicture != NULL) {</a>
<a name="ln3853">				newPicture-&gt;PushPicture(picture);</a>
<a name="ln3854">				newPicture-&gt;SyncState(fCurrentView);</a>
<a name="ln3855">				fCurrentView-&gt;SetPicture(newPicture);</a>
<a name="ln3856">			}</a>
<a name="ln3857">			break;</a>
<a name="ln3858">		}</a>
<a name="ln3859"> </a>
<a name="ln3860">		case AS_VIEW_APPEND_TO_PICTURE:</a>
<a name="ln3861">		{</a>
<a name="ln3862">			int32 token;</a>
<a name="ln3863">			link.Read&lt;int32&gt;(&amp;token);</a>
<a name="ln3864"> </a>
<a name="ln3865">			ServerPicture* appendPicture = App()-&gt;GetPicture(token);</a>
<a name="ln3866">			if (appendPicture != NULL) {</a>
<a name="ln3867">				//picture-&gt;SyncState(fCurrentView);</a>
<a name="ln3868">				appendPicture-&gt;AppendPicture(picture);</a>
<a name="ln3869">			}</a>
<a name="ln3870"> </a>
<a name="ln3871">			fCurrentView-&gt;SetPicture(appendPicture);</a>
<a name="ln3872"> </a>
<a name="ln3873">			if (appendPicture != NULL)</a>
<a name="ln3874">				appendPicture-&gt;ReleaseReference();</a>
<a name="ln3875">			break;</a>
<a name="ln3876">		}</a>
<a name="ln3877"> </a>
<a name="ln3878">		case AS_VIEW_END_PICTURE:</a>
<a name="ln3879">		{</a>
<a name="ln3880">			ServerPicture* poppedPicture = picture-&gt;PopPicture();</a>
<a name="ln3881">			fCurrentView-&gt;SetPicture(poppedPicture);</a>
<a name="ln3882">			if (poppedPicture != NULL)</a>
<a name="ln3883">				poppedPicture-&gt;ReleaseReference();</a>
<a name="ln3884"> </a>
<a name="ln3885">			fLink.StartMessage(B_OK);</a>
<a name="ln3886">			fLink.Attach&lt;int32&gt;(picture-&gt;Token());</a>
<a name="ln3887">			fLink.Flush();</a>
<a name="ln3888">			return true;</a>
<a name="ln3889">		}</a>
<a name="ln3890"> </a>
<a name="ln3891">		case AS_VIEW_BEGIN_LAYER:</a>
<a name="ln3892">		{</a>
<a name="ln3893">			uint8 opacity;</a>
<a name="ln3894">			link.Read&lt;uint8&gt;(&amp;opacity);</a>
<a name="ln3895"> </a>
<a name="ln3896">			Layer* layer = dynamic_cast&lt;Layer*&gt;(picture);</a>
<a name="ln3897">			if (layer == NULL)</a>
<a name="ln3898">				break;</a>
<a name="ln3899"> </a>
<a name="ln3900">			Layer* nextLayer = new(std::nothrow) Layer(opacity);</a>
<a name="ln3901">			if (nextLayer == NULL)</a>
<a name="ln3902">				break;</a>
<a name="ln3903"> </a>
<a name="ln3904">			if (opacity != 255) {</a>
<a name="ln3905">				fCurrentView-&gt;CurrentState()-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln3906">				fCurrentView-&gt;CurrentState()-&gt;SetBlendingMode(B_PIXEL_ALPHA,</a>
<a name="ln3907">					B_ALPHA_COMPOSITE);</a>
<a name="ln3908">				fCurrentView-&gt;CurrentState()-&gt;SetDrawingModeLocked(true);</a>
<a name="ln3909">			}</a>
<a name="ln3910"> </a>
<a name="ln3911">			nextLayer-&gt;PushLayer(layer);</a>
<a name="ln3912">			fCurrentView-&gt;SetPicture(nextLayer);</a>
<a name="ln3913">			break;</a>
<a name="ln3914">		}</a>
<a name="ln3915"> </a>
<a name="ln3916">		case AS_VIEW_END_LAYER:</a>
<a name="ln3917">		{</a>
<a name="ln3918">			Layer* layer = dynamic_cast&lt;Layer*&gt;(picture);</a>
<a name="ln3919">			if (layer == NULL)</a>
<a name="ln3920">				break;</a>
<a name="ln3921"> </a>
<a name="ln3922">			Layer* previousLayer = layer-&gt;PopLayer();</a>
<a name="ln3923">			if (previousLayer == NULL) {</a>
<a name="ln3924">				// End last layer</a>
<a name="ln3925">				return false;</a>
<a name="ln3926">			}</a>
<a name="ln3927">			fCurrentView-&gt;SetPicture(previousLayer);</a>
<a name="ln3928"> </a>
<a name="ln3929">			previousLayer-&gt;WriteBlendLayer(layer);</a>
<a name="ln3930">			break;</a>
<a name="ln3931">		}</a>
<a name="ln3932"> </a>
<a name="ln3933">/*</a>
<a name="ln3934">		case AS_VIEW_SET_BLENDING_MODE:</a>
<a name="ln3935">		{</a>
<a name="ln3936">			ViewBlendingModeInfo info;</a>
<a name="ln3937">			link.Read&lt;ViewBlendingModeInfo&gt;(&amp;info);</a>
<a name="ln3938"> </a>
<a name="ln3939">			picture-&gt;BeginOp(B_PIC_SET_BLENDING_MODE);</a>
<a name="ln3940">			picture-&gt;AddInt16((int16)info.sourceAlpha);</a>
<a name="ln3941">			picture-&gt;AddInt16((int16)info.alphaFunction);</a>
<a name="ln3942">			picture-&gt;EndOp();</a>
<a name="ln3943"> </a>
<a name="ln3944">			fCurrentView-&gt;CurrentState()-&gt;SetBlendingMode(info.sourceAlpha,</a>
<a name="ln3945">				info.alphaFunction);</a>
<a name="ln3946">			fWindow-&gt;GetDrawingEngine()-&gt;SetBlendingMode(info.sourceAlpha,</a>
<a name="ln3947">				info.alphaFunction);</a>
<a name="ln3948">			break;</a>
<a name="ln3949">		}*/</a>
<a name="ln3950">		default:</a>
<a name="ln3951">			return false;</a>
<a name="ln3952">	}</a>
<a name="ln3953"> </a>
<a name="ln3954">	if (link.NeedsReply()) {</a>
<a name="ln3955">		fLink.StartMessage(B_ERROR);</a>
<a name="ln3956">		fLink.Flush();</a>
<a name="ln3957">	}</a>
<a name="ln3958">	return true;</a>
<a name="ln3959">}</a>
<a name="ln3960"> </a>
<a name="ln3961"> </a>
<a name="ln3962">/*!	\brief Message-dispatching loop for the ServerWindow</a>
<a name="ln3963"> </a>
<a name="ln3964">	Watches the ServerWindow's message port and dispatches as necessary</a>
<a name="ln3965">*/</a>
<a name="ln3966">void</a>
<a name="ln3967">ServerWindow::_MessageLooper()</a>
<a name="ln3968">{</a>
<a name="ln3969">	// Send a reply to our window - it is expecting fMessagePort</a>
<a name="ln3970">	// port and some other info.</a>
<a name="ln3971"> </a>
<a name="ln3972">	fLink.StartMessage(B_OK);</a>
<a name="ln3973">	fLink.Attach&lt;port_id&gt;(fMessagePort);</a>
<a name="ln3974"> </a>
<a name="ln3975">	int32 minWidth, maxWidth, minHeight, maxHeight;</a>
<a name="ln3976">	fWindow-&gt;GetSizeLimits(&amp;minWidth, &amp;maxWidth, &amp;minHeight, &amp;maxHeight);</a>
<a name="ln3977"> </a>
<a name="ln3978">	fLink.Attach&lt;BRect&gt;(fWindow-&gt;Frame());</a>
<a name="ln3979">	fLink.Attach&lt;float&gt;((float)minWidth);</a>
<a name="ln3980">	fLink.Attach&lt;float&gt;((float)maxWidth);</a>
<a name="ln3981">	fLink.Attach&lt;float&gt;((float)minHeight);</a>
<a name="ln3982">	fLink.Attach&lt;float&gt;((float)maxHeight);</a>
<a name="ln3983">	fLink.Flush();</a>
<a name="ln3984"> </a>
<a name="ln3985">	BPrivate::LinkReceiver&amp; receiver = fLink.Receiver();</a>
<a name="ln3986">	bool quitLoop = false;</a>
<a name="ln3987"> </a>
<a name="ln3988">	while (!quitLoop) {</a>
<a name="ln3989">		//STRACE((&quot;info: ServerWindow::MonitorWin listening on port %ld.\n&quot;,</a>
<a name="ln3990">		//	fMessagePort));</a>
<a name="ln3991"> </a>
<a name="ln3992">		int32 code;</a>
<a name="ln3993">		status_t status = receiver.GetNextMessage(code);</a>
<a name="ln3994">		if (status != B_OK) {</a>
<a name="ln3995">			// that shouldn't happen, it's our port</a>
<a name="ln3996">			printf(&quot;Someone deleted our message port!\n&quot;);</a>
<a name="ln3997"> </a>
<a name="ln3998">			// try to let our client die happily</a>
<a name="ln3999">			NotifyQuitRequested();</a>
<a name="ln4000">			break;</a>
<a name="ln4001">		}</a>
<a name="ln4002"> </a>
<a name="ln4003">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln4004">		bigtime_t start = system_time();</a>
<a name="ln4005">#endif</a>
<a name="ln4006"> </a>
<a name="ln4007">		Lock();</a>
<a name="ln4008"> </a>
<a name="ln4009">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln4010">		bigtime_t diff = system_time() - start;</a>
<a name="ln4011">		if (diff &gt; 10000) {</a>
<a name="ln4012">			printf(&quot;ServerWindow %s: lock acquisition took %&quot; B_PRId64 &quot; usecs\n&quot;,</a>
<a name="ln4013">				Title(), diff);</a>
<a name="ln4014">		}</a>
<a name="ln4015">#endif</a>
<a name="ln4016"> </a>
<a name="ln4017">		int32 messagesProcessed = 0;</a>
<a name="ln4018">		bigtime_t processingStart = system_time();</a>
<a name="ln4019">		bool lockedDesktopSingleWindow = false;</a>
<a name="ln4020"> </a>
<a name="ln4021">		while (true) {</a>
<a name="ln4022">			if (code == AS_DELETE_WINDOW || code == kMsgQuitLooper) {</a>
<a name="ln4023">				// this means the client has been killed</a>
<a name="ln4024">				DTRACE((&quot;ServerWindow %s received 'AS_DELETE_WINDOW' message &quot;</a>
<a name="ln4025">					&quot;code\n&quot;, Title()));</a>
<a name="ln4026"> </a>
<a name="ln4027">				if (code == AS_DELETE_WINDOW) {</a>
<a name="ln4028">					fLink.StartMessage(B_OK);</a>
<a name="ln4029">					fLink.Flush();</a>
<a name="ln4030">				}</a>
<a name="ln4031"> </a>
<a name="ln4032">				if (lockedDesktopSingleWindow)</a>
<a name="ln4033">					fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln4034"> </a>
<a name="ln4035">				quitLoop = true;</a>
<a name="ln4036"> </a>
<a name="ln4037">				// ServerWindow's destructor takes care of pulling this object</a>
<a name="ln4038">				// off the desktop.</a>
<a name="ln4039">				ASSERT(fWindow-&gt;IsHidden());</a>
<a name="ln4040">				break;</a>
<a name="ln4041">			}</a>
<a name="ln4042"> </a>
<a name="ln4043">			// Acquire the appropriate lock</a>
<a name="ln4044">			bool needsAllWindowsLocked = _MessageNeedsAllWindowsLocked(code);</a>
<a name="ln4045">			if (needsAllWindowsLocked) {</a>
<a name="ln4046">				// We may already still hold the read-lock from the previous</a>
<a name="ln4047">				// inner-loop iteration.</a>
<a name="ln4048">				if (lockedDesktopSingleWindow) {</a>
<a name="ln4049">					fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln4050">					lockedDesktopSingleWindow = false;</a>
<a name="ln4051">				}</a>
<a name="ln4052">				fDesktop-&gt;LockAllWindows();</a>
<a name="ln4053">			} else {</a>
<a name="ln4054">				// We never keep the write-lock across inner-loop iterations,</a>
<a name="ln4055">				// so there is nothing else to do besides read-locking unless</a>
<a name="ln4056">				// we already have the read-lock from the previous iteration.</a>
<a name="ln4057">				if (!lockedDesktopSingleWindow) {</a>
<a name="ln4058">					fDesktop-&gt;LockSingleWindow();</a>
<a name="ln4059">					lockedDesktopSingleWindow = true;</a>
<a name="ln4060">				}</a>
<a name="ln4061">			}</a>
<a name="ln4062"> </a>
<a name="ln4063">			if (atomic_and(&amp;fRedrawRequested, 0) != 0) {</a>
<a name="ln4064">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln4065">				bigtime_t redrawStart = system_time();</a>
<a name="ln4066">#endif</a>
<a name="ln4067">				fWindow-&gt;RedrawDirtyRegion();</a>
<a name="ln4068">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln4069">				diff = system_time() - redrawStart;</a>
<a name="ln4070">				atomic_add(&amp;sRedrawProcessingTime.count, 1);</a>
<a name="ln4071"># ifndef HAIKU_TARGET_PLATFORM_LIBBE_TEST</a>
<a name="ln4072">				atomic_add64(&amp;sRedrawProcessingTime.time, diff);</a>
<a name="ln4073"># else</a>
<a name="ln4074">				sRedrawProcessingTime.time += diff;</a>
<a name="ln4075"># endif</a>
<a name="ln4076">#endif</a>
<a name="ln4077">			}</a>
<a name="ln4078"> </a>
<a name="ln4079">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln4080">			bigtime_t dispatchStart = system_time();</a>
<a name="ln4081">#endif</a>
<a name="ln4082">			_DispatchMessage(code, receiver);</a>
<a name="ln4083"> </a>
<a name="ln4084">#ifdef PROFILE_MESSAGE_LOOP</a>
<a name="ln4085">			if (code &gt;= 0 &amp;&amp; code &lt; AS_LAST_CODE) {</a>
<a name="ln4086">				diff = system_time() - dispatchStart;</a>
<a name="ln4087">				atomic_add(&amp;sMessageProfile[code].count, 1);</a>
<a name="ln4088">#ifndef HAIKU_TARGET_PLATFORM_LIBBE_TEST</a>
<a name="ln4089">				atomic_add64(&amp;sMessageProfile[code].time, diff);</a>
<a name="ln4090">#else</a>
<a name="ln4091">				sMessageProfile[code].time += diff;</a>
<a name="ln4092">#endif</a>
<a name="ln4093">				if (diff &gt; 10000) {</a>
<a name="ln4094">					printf(&quot;ServerWindow %s: message %&quot; B_PRId32 &quot; took %&quot;</a>
<a name="ln4095">						B_PRId64 &quot; usecs\n&quot;, Title(), code, diff);</a>
<a name="ln4096">				}</a>
<a name="ln4097">			}</a>
<a name="ln4098">#endif</a>
<a name="ln4099"> </a>
<a name="ln4100">			if (needsAllWindowsLocked)</a>
<a name="ln4101">				fDesktop-&gt;UnlockAllWindows();</a>
<a name="ln4102"> </a>
<a name="ln4103">			// Only process up to 70 waiting messages at once (we have the</a>
<a name="ln4104">			// Desktop locked), but don't hold the lock longer than 10 ms</a>
<a name="ln4105">			if (!receiver.HasMessages() || ++messagesProcessed &gt; 70</a>
<a name="ln4106">				|| system_time() - processingStart &gt; 10000) {</a>
<a name="ln4107">				if (lockedDesktopSingleWindow)</a>
<a name="ln4108">					fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln4109">				break;</a>
<a name="ln4110">			}</a>
<a name="ln4111"> </a>
<a name="ln4112">			// next message</a>
<a name="ln4113">			status_t status = receiver.GetNextMessage(code);</a>
<a name="ln4114">			if (status != B_OK) {</a>
<a name="ln4115">				// that shouldn't happen, it's our port</a>
<a name="ln4116">				printf(&quot;Someone deleted our message port!\n&quot;);</a>
<a name="ln4117">				if (lockedDesktopSingleWindow)</a>
<a name="ln4118">					fDesktop-&gt;UnlockSingleWindow();</a>
<a name="ln4119"> </a>
<a name="ln4120">				// try to let our client die happily</a>
<a name="ln4121">				NotifyQuitRequested();</a>
<a name="ln4122">				break;</a>
<a name="ln4123">			}</a>
<a name="ln4124">		}</a>
<a name="ln4125"> </a>
<a name="ln4126">		Unlock();</a>
<a name="ln4127">	}</a>
<a name="ln4128"> </a>
<a name="ln4129">	// We were asked to quit the message loop - either on request or because of</a>
<a name="ln4130">	// an error.</a>
<a name="ln4131">	Quit();</a>
<a name="ln4132">		// does not return</a>
<a name="ln4133">}</a>
<a name="ln4134"> </a>
<a name="ln4135"> </a>
<a name="ln4136">void</a>
<a name="ln4137">ServerWindow::ScreenChanged(const BMessage* message)</a>
<a name="ln4138">{</a>
<a name="ln4139">	SendMessageToClient(message);</a>
<a name="ln4140"> </a>
<a name="ln4141">	if (fDirectWindowInfo != NULL &amp;&amp; fDirectWindowInfo-&gt;IsFullScreen())</a>
<a name="ln4142">		_ResizeToFullScreen();</a>
<a name="ln4143">}</a>
<a name="ln4144"> </a>
<a name="ln4145"> </a>
<a name="ln4146">status_t</a>
<a name="ln4147">ServerWindow::SendMessageToClient(const BMessage* msg, int32 target) const</a>
<a name="ln4148">{</a>
<a name="ln4149">	if (target == B_NULL_TOKEN)</a>
<a name="ln4150">		target = fClientToken;</a>
<a name="ln4151"> </a>
<a name="ln4152">	BMessenger reply;</a>
<a name="ln4153">	BMessage::Private messagePrivate((BMessage*)msg);</a>
<a name="ln4154">	return messagePrivate.SendMessage(fClientLooperPort, fClientTeam, target,</a>
<a name="ln4155">		0, false, reply);</a>
<a name="ln4156">}</a>
<a name="ln4157"> </a>
<a name="ln4158"> </a>
<a name="ln4159">Window*</a>
<a name="ln4160">ServerWindow::MakeWindow(BRect frame, const char* name,</a>
<a name="ln4161">	window_look look, window_feel feel, uint32 flags, uint32 workspace)</a>
<a name="ln4162">{</a>
<a name="ln4163">	// The non-offscreen ServerWindow uses the DrawingEngine instance from</a>
<a name="ln4164">	// the desktop.</a>
<a name="ln4165">	return new(std::nothrow) ::Window(frame, name, look, feel, flags,</a>
<a name="ln4166">		workspace, this, fDesktop-&gt;HWInterface()-&gt;CreateDrawingEngine());</a>
<a name="ln4167">}</a>
<a name="ln4168"> </a>
<a name="ln4169"> </a>
<a name="ln4170">void</a>
<a name="ln4171">ServerWindow::HandleDirectConnection(int32 bufferState, int32 driverState)</a>
<a name="ln4172">{</a>
<a name="ln4173">	ASSERT_MULTI_LOCKED(fDesktop-&gt;WindowLocker());</a>
<a name="ln4174"> </a>
<a name="ln4175">	if (fDirectWindowInfo == NULL)</a>
<a name="ln4176">		return;</a>
<a name="ln4177"> </a>
<a name="ln4178">	STRACE((&quot;HandleDirectConnection(bufferState = %&quot; B_PRId32 &quot;, driverState = &quot;</a>
<a name="ln4179">		&quot;%&quot; B_PRId32 &quot;)\n&quot;, bufferState, driverState));</a>
<a name="ln4180"> </a>
<a name="ln4181">	status_t status = fDirectWindowInfo-&gt;SetState(</a>
<a name="ln4182">		(direct_buffer_state)bufferState, (direct_driver_state)driverState,</a>
<a name="ln4183">		fDesktop-&gt;HWInterface()-&gt;FrontBuffer(), fWindow-&gt;Frame(),</a>
<a name="ln4184">		fWindow-&gt;VisibleContentRegion());</a>
<a name="ln4185"> </a>
<a name="ln4186">	if (status != B_OK) {</a>
<a name="ln4187">		char errorString[256];</a>
<a name="ln4188">		snprintf(errorString, sizeof(errorString),</a>
<a name="ln4189">			&quot;%s killed for a problem in DirectConnected(): %s&quot;,</a>
<a name="ln4190">			App()-&gt;Signature(), strerror(status));</a>
<a name="ln4191">		syslog(LOG_ERR, errorString);</a>
<a name="ln4192"> </a>
<a name="ln4193">		// The client application didn't release the semaphore</a>
<a name="ln4194">		// within the given timeout. Or something else went wrong.</a>
<a name="ln4195">		// Deleting this member should make it crash.</a>
<a name="ln4196">		delete fDirectWindowInfo;</a>
<a name="ln4197">		fDirectWindowInfo = NULL;</a>
<a name="ln4198">	} else if ((bufferState &amp; B_DIRECT_MODE_MASK) == B_DIRECT_START)</a>
<a name="ln4199">		fIsDirectlyAccessing = true;</a>
<a name="ln4200">	else if ((bufferState &amp; B_DIRECT_MODE_MASK) == B_DIRECT_STOP)</a>
<a name="ln4201">		fIsDirectlyAccessing = false;</a>
<a name="ln4202">}</a>
<a name="ln4203"> </a>
<a name="ln4204"> </a>
<a name="ln4205">void</a>
<a name="ln4206">ServerWindow::_SetCurrentView(View* view)</a>
<a name="ln4207">{</a>
<a name="ln4208">	if (fCurrentView == view)</a>
<a name="ln4209">		return;</a>
<a name="ln4210"> </a>
<a name="ln4211">	fCurrentView = view;</a>
<a name="ln4212">	fCurrentDrawingRegionValid = false;</a>
<a name="ln4213">	_UpdateDrawState(fCurrentView);</a>
<a name="ln4214"> </a>
<a name="ln4215">#if 0</a>
<a name="ln4216">#if DELAYED_BACKGROUND_CLEARING</a>
<a name="ln4217">	if (fCurrentView &amp;&amp; fCurrentView-&gt;IsBackgroundDirty()</a>
<a name="ln4218">		&amp;&amp; fWindow-&gt;InUpdate()) {</a>
<a name="ln4219">		DrawingEngine* drawingEngine = fWindow-&gt;GetDrawingEngine();</a>
<a name="ln4220">		if (drawingEngine-&gt;LockParallelAccess()) {</a>
<a name="ln4221">			fWindow-&gt;GetEffectiveDrawingRegion(fCurrentView,</a>
<a name="ln4222">				fCurrentDrawingRegion);</a>
<a name="ln4223">			fCurrentDrawingRegionValid = true;</a>
<a name="ln4224">			BRegion dirty(fCurrentDrawingRegion);</a>
<a name="ln4225"> </a>
<a name="ln4226">			BRegion content;</a>
<a name="ln4227">			fWindow-&gt;GetContentRegion(&amp;content);</a>
<a name="ln4228"> </a>
<a name="ln4229">			fCurrentView-&gt;Draw(drawingEngine, &amp;dirty, &amp;content, false);</a>
<a name="ln4230"> </a>
<a name="ln4231">			drawingEngine-&gt;UnlockParallelAccess();</a>
<a name="ln4232">		}</a>
<a name="ln4233">	}</a>
<a name="ln4234">#endif</a>
<a name="ln4235">#endif // 0</a>
<a name="ln4236">}</a>
<a name="ln4237"> </a>
<a name="ln4238"> </a>
<a name="ln4239">void</a>
<a name="ln4240">ServerWindow::_UpdateDrawState(View* view)</a>
<a name="ln4241">{</a>
<a name="ln4242">	// switch the drawing state</a>
<a name="ln4243">	// TODO: is it possible to scroll a view while it</a>
<a name="ln4244">	// is being drawn? probably not... otherwise the</a>
<a name="ln4245">	// &quot;offsets&quot; passed below would need to be updated again</a>
<a name="ln4246">	DrawingEngine* drawingEngine = fWindow-&gt;GetDrawingEngine();</a>
<a name="ln4247">	if (view != NULL &amp;&amp; drawingEngine != NULL) {</a>
<a name="ln4248">		BPoint leftTop(0, 0);</a>
<a name="ln4249">		if (view-&gt;GetAlphaMask() != NULL) {</a>
<a name="ln4250">			view-&gt;LocalToScreenTransform().Apply(&amp;leftTop);</a>
<a name="ln4251">			view-&gt;GetAlphaMask()-&gt;SetCanvasGeometry(leftTop, view-&gt;Bounds());</a>
<a name="ln4252">			leftTop = BPoint(0, 0);</a>
<a name="ln4253">		}</a>
<a name="ln4254">		view-&gt;PenToScreenTransform().Apply(&amp;leftTop);</a>
<a name="ln4255">		drawingEngine-&gt;SetDrawState(view-&gt;CurrentState(), leftTop.x, leftTop.y);</a>
<a name="ln4256">	}</a>
<a name="ln4257">}</a>
<a name="ln4258"> </a>
<a name="ln4259"> </a>
<a name="ln4260">void</a>
<a name="ln4261">ServerWindow::_UpdateCurrentDrawingRegion()</a>
<a name="ln4262">{</a>
<a name="ln4263">	if (!fCurrentDrawingRegionValid</a>
<a name="ln4264">		|| fWindow-&gt;DrawingRegionChanged(fCurrentView)) {</a>
<a name="ln4265">		fWindow-&gt;GetEffectiveDrawingRegion(fCurrentView, fCurrentDrawingRegion);</a>
<a name="ln4266">		fCurrentDrawingRegionValid = true;</a>
<a name="ln4267">	}</a>
<a name="ln4268">}</a>
<a name="ln4269"> </a>
<a name="ln4270"> </a>
<a name="ln4271">bool</a>
<a name="ln4272">ServerWindow::_MessageNeedsAllWindowsLocked(uint32 code) const</a>
<a name="ln4273">{</a>
<a name="ln4274">	switch (code) {</a>
<a name="ln4275">		case AS_SET_WINDOW_TITLE:</a>
<a name="ln4276">		case AS_ADD_TO_SUBSET:</a>
<a name="ln4277">		case AS_REMOVE_FROM_SUBSET:</a>
<a name="ln4278">		case AS_VIEW_CREATE_ROOT:</a>
<a name="ln4279">		case AS_VIEW_CREATE:</a>
<a name="ln4280">		case AS_SEND_BEHIND:</a>
<a name="ln4281">		case AS_SET_LOOK:</a>
<a name="ln4282">		case AS_SET_FEEL:</a>
<a name="ln4283">		case AS_SET_FLAGS:</a>
<a name="ln4284">		case AS_SET_WORKSPACES:</a>
<a name="ln4285">		case AS_WINDOW_MOVE:</a>
<a name="ln4286">		case AS_WINDOW_RESIZE:</a>
<a name="ln4287">		case AS_SET_SIZE_LIMITS:</a>
<a name="ln4288">		case AS_SYSTEM_FONT_CHANGED:</a>
<a name="ln4289">		case AS_SET_DECORATOR_SETTINGS:</a>
<a name="ln4290">		case AS_GET_MOUSE:</a>
<a name="ln4291">		case AS_DIRECT_WINDOW_SET_FULLSCREEN:</a>
<a name="ln4292">//		case AS_VIEW_SET_EVENT_MASK:</a>
<a name="ln4293">//		case AS_VIEW_SET_MOUSE_EVENT_MASK:</a>
<a name="ln4294">		case AS_TALK_TO_DESKTOP_LISTENER:</a>
<a name="ln4295">			return true;</a>
<a name="ln4296">		default:</a>
<a name="ln4297">			return false;</a>
<a name="ln4298">	}</a>
<a name="ln4299">}</a>
<a name="ln4300"> </a>
<a name="ln4301"> </a>
<a name="ln4302">void</a>
<a name="ln4303">ServerWindow::_ResizeToFullScreen()</a>
<a name="ln4304">{</a>
<a name="ln4305">	BRect screenFrame;</a>
<a name="ln4306"> </a>
<a name="ln4307">	{</a>
<a name="ln4308">		AutoReadLocker _(fDesktop-&gt;ScreenLocker());</a>
<a name="ln4309">		const Screen* screen = fWindow-&gt;Screen();</a>
<a name="ln4310">		if (screen == NULL)</a>
<a name="ln4311">			return;</a>
<a name="ln4312"> </a>
<a name="ln4313">		screenFrame = fWindow-&gt;Screen()-&gt;Frame();</a>
<a name="ln4314">	}</a>
<a name="ln4315"> </a>
<a name="ln4316">	fDesktop-&gt;MoveWindowBy(fWindow,</a>
<a name="ln4317">		screenFrame.left - fWindow-&gt;Frame().left,</a>
<a name="ln4318">		screenFrame.top - fWindow-&gt;Frame().top);</a>
<a name="ln4319">	fDesktop-&gt;ResizeWindowBy(fWindow,</a>
<a name="ln4320">		screenFrame.Width() - fWindow-&gt;Frame().Width(),</a>
<a name="ln4321">		screenFrame.Height() - fWindow-&gt;Frame().Height());</a>
<a name="ln4322">}</a>
<a name="ln4323"> </a>
<a name="ln4324"> </a>
<a name="ln4325">status_t</a>
<a name="ln4326">ServerWindow::_EnableDirectWindowMode()</a>
<a name="ln4327">{</a>
<a name="ln4328">	if (fDirectWindowInfo != NULL) {</a>
<a name="ln4329">		// already in direct window mode</a>
<a name="ln4330">		return B_ERROR;</a>
<a name="ln4331">	}</a>
<a name="ln4332"> </a>
<a name="ln4333">	if (fDesktop-&gt;HWInterface()-&gt;FrontBuffer() == NULL) {</a>
<a name="ln4334">		// direct window mode not supported</a>
<a name="ln4335">		return B_UNSUPPORTED;</a>
<a name="ln4336">	}</a>
<a name="ln4337"> </a>
<a name="ln4338">	fDirectWindowInfo = new(std::nothrow) DirectWindowInfo;</a>
<a name="ln4339">	if (fDirectWindowInfo == NULL)</a>
<a name="ln4340">		return B_NO_MEMORY;</a>
<a name="ln4341"> </a>
<a name="ln4342">	status_t status = fDirectWindowInfo-&gt;InitCheck();</a>
<a name="ln4343">	if (status != B_OK) {</a>
<a name="ln4344">		delete fDirectWindowInfo;</a>
<a name="ln4345">		fDirectWindowInfo = NULL;</a>
<a name="ln4346"> </a>
<a name="ln4347">		return status;</a>
<a name="ln4348">	}</a>
<a name="ln4349"> </a>
<a name="ln4350">	return B_OK;</a>
<a name="ln4351">}</a>
<a name="ln4352"> </a>
<a name="ln4353"> </a>
<a name="ln4354">void</a>
<a name="ln4355">ServerWindow::_DirectWindowSetFullScreen(bool enable)</a>
<a name="ln4356">{</a>
<a name="ln4357">	window_feel feel = kWindowScreenFeel;</a>
<a name="ln4358"> </a>
<a name="ln4359">	if (enable) {</a>
<a name="ln4360">		fDesktop-&gt;HWInterface()-&gt;SetCursorVisible(false);</a>
<a name="ln4361"> </a>
<a name="ln4362">		fDirectWindowInfo-&gt;EnableFullScreen(fWindow-&gt;Frame(), fWindow-&gt;Feel());</a>
<a name="ln4363">		_ResizeToFullScreen();</a>
<a name="ln4364">	} else {</a>
<a name="ln4365">		const BRect&amp; originalFrame = fDirectWindowInfo-&gt;OriginalFrame();</a>
<a name="ln4366"> </a>
<a name="ln4367">		fDirectWindowInfo-&gt;DisableFullScreen();</a>
<a name="ln4368"> </a>
<a name="ln4369">		// Resize window back to its original size</a>
<a name="ln4370">		fDesktop-&gt;MoveWindowBy(fWindow,</a>
<a name="ln4371">			originalFrame.left - fWindow-&gt;Frame().left,</a>
<a name="ln4372">			originalFrame.top - fWindow-&gt;Frame().top);</a>
<a name="ln4373">		fDesktop-&gt;ResizeWindowBy(fWindow,</a>
<a name="ln4374">			originalFrame.Width() - fWindow-&gt;Frame().Width(),</a>
<a name="ln4375">			originalFrame.Height() - fWindow-&gt;Frame().Height());</a>
<a name="ln4376"> </a>
<a name="ln4377">		fDesktop-&gt;HWInterface()-&gt;SetCursorVisible(true);</a>
<a name="ln4378">	}</a>
<a name="ln4379"> </a>
<a name="ln4380">	fDesktop-&gt;SetWindowFeel(fWindow, feel);</a>
<a name="ln4381">}</a>

</code></pre>
<div class="balloon" rel="3657"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors.</p></div>
<div class="balloon" rel="3135"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
