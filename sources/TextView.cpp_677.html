
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>TextView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2015 Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan AÃŸmus, superstippi@gmx.de</a>
<a name="ln7"> *		Stefano Ceccherini, stefano.ceccherini@gmail.com</a>
<a name="ln8"> *		Marc Flerackers, mflerackers@androme.be</a>
<a name="ln9"> *		Hiroshi Lockheimer (BTextView is based on his STEEngine)</a>
<a name="ln10"> *		John Scipione, jscipione@gmail.com</a>
<a name="ln11"> *		Oliver Tappe, zooey@hirschkaefer.de</a>
<a name="ln12"> */</a>
<a name="ln13"> </a>
<a name="ln14"> </a>
<a name="ln15">// TODOs:</a>
<a name="ln16">// - Consider using BObjectList instead of BList</a>
<a name="ln17">// 	 for disallowed characters (it would remove a lot of reinterpret_casts)</a>
<a name="ln18">// - Check for correctness and possible optimizations the calls to _Refresh(),</a>
<a name="ln19">// 	 to refresh only changed parts of text (currently we often redraw the whole</a>
<a name="ln20">//   text)</a>
<a name="ln21"> </a>
<a name="ln22">// Known Bugs:</a>
<a name="ln23">// - Double buffering doesn't work well (disabled by default)</a>
<a name="ln24"> </a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;TextView.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;new&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;stdio.h&gt;</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;Application.h&gt;</a>
<a name="ln34">#include &lt;Beep.h&gt;</a>
<a name="ln35">#include &lt;Bitmap.h&gt;</a>
<a name="ln36">#include &lt;Clipboard.h&gt;</a>
<a name="ln37">#include &lt;Debug.h&gt;</a>
<a name="ln38">#include &lt;Entry.h&gt;</a>
<a name="ln39">#include &lt;Input.h&gt;</a>
<a name="ln40">#include &lt;LayoutBuilder.h&gt;</a>
<a name="ln41">#include &lt;LayoutUtils.h&gt;</a>
<a name="ln42">#include &lt;MessageRunner.h&gt;</a>
<a name="ln43">#include &lt;Path.h&gt;</a>
<a name="ln44">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln45">#include &lt;PropertyInfo.h&gt;</a>
<a name="ln46">#include &lt;Region.h&gt;</a>
<a name="ln47">#include &lt;ScrollBar.h&gt;</a>
<a name="ln48">#include &lt;SystemCatalog.h&gt;</a>
<a name="ln49">#include &lt;Window.h&gt;</a>
<a name="ln50"> </a>
<a name="ln51">#include &lt;binary_compatibility/Interface.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;InlineInput.h&quot;</a>
<a name="ln54">#include &quot;LineBuffer.h&quot;</a>
<a name="ln55">#include &quot;StyleBuffer.h&quot;</a>
<a name="ln56">#include &quot;TextGapBuffer.h&quot;</a>
<a name="ln57">#include &quot;UndoBuffer.h&quot;</a>
<a name="ln58">#include &quot;WidthBuffer.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">using namespace std;</a>
<a name="ln62">using BPrivate::gSystemCatalog;</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln66">#define B_TRANSLATION_CONTEXT &quot;TextView&quot;</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">#define TRANSLATE(str) \</a>
<a name="ln70">	gSystemCatalog.GetString(B_TRANSLATE_MARK(str), &quot;TextView&quot;)</a>
<a name="ln71"> </a>
<a name="ln72">#undef TRACE</a>
<a name="ln73">#undef CALLED</a>
<a name="ln74">//#define TRACE_TEXT_VIEW</a>
<a name="ln75">#ifdef TRACE_TEXT_VIEW</a>
<a name="ln76">#	include &lt;FunctionTracer.h&gt;</a>
<a name="ln77">	static int32 sFunctionDepth = -1;</a>
<a name="ln78">#	define CALLED(x...)	FunctionTracer _ft(&quot;BTextView&quot;, __FUNCTION__, \</a>
<a name="ln79">							sFunctionDepth)</a>
<a name="ln80">#	define TRACE(x...)	{ BString _to; \</a>
<a name="ln81">							_to.Append(' ', (sFunctionDepth + 1) * 2); \</a>
<a name="ln82">							printf(&quot;%s&quot;, _to.String()); printf(x); }</a>
<a name="ln83">#else</a>
<a name="ln84">#	define CALLED(x...)</a>
<a name="ln85">#	define TRACE(x...)</a>
<a name="ln86">#endif</a>
<a name="ln87"> </a>
<a name="ln88"> </a>
<a name="ln89">#define USE_WIDTHBUFFER 1</a>
<a name="ln90">#define USE_DOUBLEBUFFERING 0</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">struct flattened_text_run {</a>
<a name="ln94">	int32	offset;</a>
<a name="ln95">	font_family	family;</a>
<a name="ln96">	font_style style;</a>
<a name="ln97">	float	size;</a>
<a name="ln98">	float	shear;		// typically 90.0</a>
<a name="ln99">	uint16	face;		// typically 0</a>
<a name="ln100">	uint8	red;</a>
<a name="ln101">	uint8	green;</a>
<a name="ln102">	uint8	blue;</a>
<a name="ln103">	uint8	alpha;		// 255 == opaque</a>
<a name="ln104">	uint16	_reserved_;	// 0</a>
<a name="ln105">};</a>
<a name="ln106"> </a>
<a name="ln107">struct flattened_text_run_array {</a>
<a name="ln108">	uint32	magic;</a>
<a name="ln109">	uint32	version;</a>
<a name="ln110">	int32	count;</a>
<a name="ln111">	flattened_text_run styles[1];</a>
<a name="ln112">};</a>
<a name="ln113"> </a>
<a name="ln114">static const uint32 kFlattenedTextRunArrayMagic = 'Ali!';</a>
<a name="ln115">static const uint32 kFlattenedTextRunArrayVersion = 0;</a>
<a name="ln116"> </a>
<a name="ln117"> </a>
<a name="ln118">enum {</a>
<a name="ln119">	CHAR_CLASS_DEFAULT,</a>
<a name="ln120">	CHAR_CLASS_WHITESPACE,</a>
<a name="ln121">	CHAR_CLASS_GRAPHICAL,</a>
<a name="ln122">	CHAR_CLASS_QUOTE,</a>
<a name="ln123">	CHAR_CLASS_PUNCTUATION,</a>
<a name="ln124">	CHAR_CLASS_PARENS_OPEN,</a>
<a name="ln125">	CHAR_CLASS_PARENS_CLOSE,</a>
<a name="ln126">	CHAR_CLASS_END_OF_TEXT</a>
<a name="ln127">};</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">class BTextView::TextTrackState {</a>
<a name="ln131">public:</a>
<a name="ln132">	TextTrackState(BMessenger messenger);</a>
<a name="ln133">	~TextTrackState();</a>
<a name="ln134"> </a>
<a name="ln135">	void SimulateMouseMovement(BTextView* view);</a>
<a name="ln136"> </a>
<a name="ln137">public:</a>
<a name="ln138">	int32				clickOffset;</a>
<a name="ln139">	bool				shiftDown;</a>
<a name="ln140">	BRect				selectionRect;</a>
<a name="ln141">	BPoint				where;</a>
<a name="ln142"> </a>
<a name="ln143">	int32				anchor;</a>
<a name="ln144">	int32				selStart;</a>
<a name="ln145">	int32				selEnd;</a>
<a name="ln146"> </a>
<a name="ln147">private:</a>
<a name="ln148">	BMessageRunner*		fRunner;</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">struct BTextView::LayoutData {</a>
<a name="ln153">	LayoutData()</a>
<a name="ln154">		: leftInset(0),</a>
<a name="ln155">		  topInset(0),</a>
<a name="ln156">		  rightInset(0),</a>
<a name="ln157">		  bottomInset(0),</a>
<a name="ln158">		  valid(false)</a>
<a name="ln159">	{</a>
<a name="ln160">	}</a>
<a name="ln161"> </a>
<a name="ln162">	void UpdateInsets(const BRect&amp; bounds, const BRect&amp; textRect)</a>
<a name="ln163">	{</a>
<a name="ln164">		// we disallow negative insets, as they would cause parts of the</a>
<a name="ln165">		// text to be hidden</a>
<a name="ln166">		leftInset = textRect.left &gt;= bounds.left</a>
<a name="ln167">			? textRect.left - bounds.left</a>
<a name="ln168">			: 0;</a>
<a name="ln169">		topInset = textRect.top &gt;= bounds.top</a>
<a name="ln170">			? textRect.top - bounds.top</a>
<a name="ln171">			: 0;</a>
<a name="ln172">		rightInset = bounds.right &gt;= textRect.right</a>
<a name="ln173">			? bounds.right - textRect.right</a>
<a name="ln174">			: leftInset;</a>
<a name="ln175">		bottomInset = bounds.bottom &gt;= textRect.bottom</a>
<a name="ln176">			? bounds.bottom - textRect.bottom</a>
<a name="ln177">			: topInset;</a>
<a name="ln178">	}</a>
<a name="ln179"> </a>
<a name="ln180">	float				leftInset;</a>
<a name="ln181">	float				topInset;</a>
<a name="ln182">	float				rightInset;</a>
<a name="ln183">	float				bottomInset;</a>
<a name="ln184"> </a>
<a name="ln185">	BSize				min;</a>
<a name="ln186">	BSize				preferred;</a>
<a name="ln187">	bool				valid;</a>
<a name="ln188">};</a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191">static const rgb_color kBlueInputColor = { 152, 203, 255, 255 };</a>
<a name="ln192">static const rgb_color kRedInputColor = { 255, 152, 152, 255 };</a>
<a name="ln193"> </a>
<a name="ln194">static const float kHorizontalScrollBarStep = 10.0;</a>
<a name="ln195">static const float kVerticalScrollBarStep = 12.0;</a>
<a name="ln196"> </a>
<a name="ln197">static const int32 kMsgNavigateArrow = '_NvA';</a>
<a name="ln198">static const int32 kMsgNavigatePage  = '_NvP';</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">static property_info sPropertyList[] = {</a>
<a name="ln202">	{</a>
<a name="ln203">		&quot;selection&quot;,</a>
<a name="ln204">		{ B_GET_PROPERTY, 0 },</a>
<a name="ln205">		{ B_DIRECT_SPECIFIER, 0 },</a>
<a name="ln206">		&quot;Returns the current selection.&quot;, 0,</a>
<a name="ln207">		{ B_INT32_TYPE, 0 }</a>
<a name="ln208">	},</a>
<a name="ln209">	{</a>
<a name="ln210">		&quot;selection&quot;,</a>
<a name="ln211">		{ B_SET_PROPERTY, 0 },</a>
<a name="ln212">		{ B_DIRECT_SPECIFIER, 0 },</a>
<a name="ln213">		&quot;Sets the current selection.&quot;, 0,</a>
<a name="ln214">		{ B_INT32_TYPE, 0 }</a>
<a name="ln215">	},</a>
<a name="ln216">	{</a>
<a name="ln217">		&quot;Text&quot;,</a>
<a name="ln218">		{ B_COUNT_PROPERTIES, 0 },</a>
<a name="ln219">		{ B_DIRECT_SPECIFIER, 0 },</a>
<a name="ln220">		&quot;Returns the length of the text in bytes.&quot;, 0,</a>
<a name="ln221">		{ B_INT32_TYPE, 0 }</a>
<a name="ln222">	},</a>
<a name="ln223">	{</a>
<a name="ln224">		&quot;Text&quot;,</a>
<a name="ln225">		{ B_GET_PROPERTY, 0 },</a>
<a name="ln226">		{ B_RANGE_SPECIFIER, B_REVERSE_RANGE_SPECIFIER, 0 },</a>
<a name="ln227">		&quot;Returns the text in the specified range in the BTextView.&quot;, 0,</a>
<a name="ln228">		{ B_STRING_TYPE, 0 }</a>
<a name="ln229">	},</a>
<a name="ln230">	{</a>
<a name="ln231">		&quot;Text&quot;,</a>
<a name="ln232">		{ B_SET_PROPERTY, 0 },</a>
<a name="ln233">		{ B_RANGE_SPECIFIER, B_REVERSE_RANGE_SPECIFIER, 0 },</a>
<a name="ln234">		&quot;Removes or inserts text into the specified range in the BTextView.&quot;, 0,</a>
<a name="ln235">		{ B_STRING_TYPE, 0 }</a>
<a name="ln236">	},</a>
<a name="ln237">	{</a>
<a name="ln238">		&quot;text_run_array&quot;,</a>
<a name="ln239">		{ B_GET_PROPERTY, 0 },</a>
<a name="ln240">		{ B_RANGE_SPECIFIER, B_REVERSE_RANGE_SPECIFIER, 0 },</a>
<a name="ln241">		&quot;Returns the style information for the text in the specified range in &quot;</a>
<a name="ln242">			&quot;the BTextView.&quot;, 0,</a>
<a name="ln243">		{ B_RAW_TYPE, 0 },</a>
<a name="ln244">	},</a>
<a name="ln245">	{</a>
<a name="ln246">		&quot;text_run_array&quot;,</a>
<a name="ln247">		{ B_SET_PROPERTY, 0 },</a>
<a name="ln248">		{ B_RANGE_SPECIFIER, B_REVERSE_RANGE_SPECIFIER, 0 },</a>
<a name="ln249">		&quot;Sets the style information for the text in the specified range in the &quot;</a>
<a name="ln250">			&quot;BTextView.&quot;, 0,</a>
<a name="ln251">		{ B_RAW_TYPE, 0 },</a>
<a name="ln252">	},</a>
<a name="ln253"> </a>
<a name="ln254">	{ 0 }</a>
<a name="ln255">};</a>
<a name="ln256"> </a>
<a name="ln257"> </a>
<a name="ln258">BTextView::BTextView(BRect frame, const char* name, BRect textRect,</a>
<a name="ln259">	uint32 resizeMask, uint32 flags)</a>
<a name="ln260">	:</a>
<a name="ln261">	BView(frame, name, resizeMask,</a>
<a name="ln262">		flags | B_FRAME_EVENTS | B_PULSE_NEEDED | B_INPUT_METHOD_AWARE)</a>
<a name="ln263">{</a>
<a name="ln264">	_InitObject(textRect, NULL, NULL);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267"> </a>
<a name="ln268">BTextView::BTextView(BRect frame, const char* name, BRect textRect,</a>
<a name="ln269">	const BFont* initialFont, const rgb_color* initialColor,</a>
<a name="ln270">	uint32 resizeMask, uint32 flags)</a>
<a name="ln271">	:</a>
<a name="ln272">	BView(frame, name, resizeMask,</a>
<a name="ln273">		flags | B_FRAME_EVENTS | B_PULSE_NEEDED | B_INPUT_METHOD_AWARE)</a>
<a name="ln274">{</a>
<a name="ln275">	_InitObject(textRect, initialFont, initialColor);</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278"> </a>
<a name="ln279">BTextView::BTextView(const char* name, uint32 flags)</a>
<a name="ln280">	:</a>
<a name="ln281">	BView(name,</a>
<a name="ln282">		flags | B_FRAME_EVENTS | B_PULSE_NEEDED | B_INPUT_METHOD_AWARE)</a>
<a name="ln283">{</a>
<a name="ln284">	_InitObject(Bounds(), NULL, NULL);</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287"> </a>
<a name="ln288">BTextView::BTextView(const char* name, const BFont* initialFont,</a>
<a name="ln289">	const rgb_color* initialColor, uint32 flags)</a>
<a name="ln290">	:</a>
<a name="ln291">	BView(name,</a>
<a name="ln292">		flags | B_FRAME_EVENTS | B_PULSE_NEEDED | B_INPUT_METHOD_AWARE)</a>
<a name="ln293">{</a>
<a name="ln294">	_InitObject(Bounds(), initialFont, initialColor);</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297"> </a>
<a name="ln298">BTextView::BTextView(BMessage* archive)</a>
<a name="ln299">	:</a>
<a name="ln300">	BView(archive)</a>
<a name="ln301">{</a>
<a name="ln302">	CALLED();</a>
<a name="ln303">	BRect rect;</a>
<a name="ln304"> </a>
<a name="ln305">	if (archive-&gt;FindRect(&quot;_trect&quot;, &amp;rect) != B_OK)</a>
<a name="ln306">		rect.Set(0, 0, 0, 0);</a>
<a name="ln307"> </a>
<a name="ln308">	_InitObject(rect, NULL, NULL);</a>
<a name="ln309"> </a>
<a name="ln310">	const char* text = NULL;</a>
<a name="ln311">	if (archive-&gt;FindString(&quot;_text&quot;, &amp;text) == B_OK)</a>
<a name="ln312">		SetText(text);</a>
<a name="ln313"> </a>
<a name="ln314">	int32 flag, flag2;</a>
<a name="ln315">	if (archive-&gt;FindInt32(&quot;_align&quot;, &amp;flag) == B_OK)</a>
<a name="ln316">		SetAlignment((alignment)flag);</a>
<a name="ln317"> </a>
<a name="ln318">	float value;</a>
<a name="ln319"> </a>
<a name="ln320">	if (archive-&gt;FindFloat(&quot;_tab&quot;, &amp;value) == B_OK)</a>
<a name="ln321">		SetTabWidth(value);</a>
<a name="ln322"> </a>
<a name="ln323">	if (archive-&gt;FindInt32(&quot;_col_sp&quot;, &amp;flag) == B_OK)</a>
<a name="ln324">		SetColorSpace((color_space)flag);</a>
<a name="ln325"> </a>
<a name="ln326">	if (archive-&gt;FindInt32(&quot;_max&quot;, &amp;flag) == B_OK)</a>
<a name="ln327">		SetMaxBytes(flag);</a>
<a name="ln328"> </a>
<a name="ln329">	if (archive-&gt;FindInt32(&quot;_sel&quot;, &amp;flag) == B_OK &amp;&amp;</a>
<a name="ln330">		archive-&gt;FindInt32(&quot;_sel&quot;, &amp;flag2) == B_OK)</a>
<a name="ln331">		Select(flag, flag2);</a>
<a name="ln332"> </a>
<a name="ln333">	bool toggle;</a>
<a name="ln334"> </a>
<a name="ln335">	if (archive-&gt;FindBool(&quot;_stylable&quot;, &amp;toggle) == B_OK)</a>
<a name="ln336">		SetStylable(toggle);</a>
<a name="ln337"> </a>
<a name="ln338">	if (archive-&gt;FindBool(&quot;_auto_in&quot;, &amp;toggle) == B_OK)</a>
<a name="ln339">		SetAutoindent(toggle);</a>
<a name="ln340"> </a>
<a name="ln341">	if (archive-&gt;FindBool(&quot;_wrap&quot;, &amp;toggle) == B_OK)</a>
<a name="ln342">		SetWordWrap(toggle);</a>
<a name="ln343"> </a>
<a name="ln344">	if (archive-&gt;FindBool(&quot;_nsel&quot;, &amp;toggle) == B_OK)</a>
<a name="ln345">		MakeSelectable(!toggle);</a>
<a name="ln346"> </a>
<a name="ln347">	if (archive-&gt;FindBool(&quot;_nedit&quot;, &amp;toggle) == B_OK)</a>
<a name="ln348">		MakeEditable(!toggle);</a>
<a name="ln349"> </a>
<a name="ln350">	ssize_t disallowedCount = 0;</a>
<a name="ln351">	const int32* disallowedChars = NULL;</a>
<a name="ln352">	if (archive-&gt;FindData(&quot;_dis_ch&quot;, B_RAW_TYPE,</a>
<a name="ln353">		(const void**)&amp;disallowedChars, &amp;disallowedCount) == B_OK) {</a>
<a name="ln354"> </a>
<a name="ln355">		fDisallowedChars = new BList;</a>
<a name="ln356">		disallowedCount /= sizeof(int32);</a>
<a name="ln357">		for (int32 x = 0; x &lt; disallowedCount; x++) {</a>
<a name="ln358">			fDisallowedChars-&gt;AddItem(</a>
<a name="ln359">				reinterpret_cast&lt;void*&gt;(disallowedChars[x]));</a>
<a name="ln360">		}</a>
<a name="ln361">	}</a>
<a name="ln362"> </a>
<a name="ln363">	ssize_t runSize = 0;</a>
<a name="ln364">	const void* flattenedRun = NULL;</a>
<a name="ln365"> </a>
<a name="ln366">	if (archive-&gt;FindData(&quot;_runs&quot;, B_RAW_TYPE, &amp;flattenedRun, &amp;runSize)</a>
<a name="ln367">			== B_OK) {</a>
<a name="ln368">		text_run_array* runArray = UnflattenRunArray(flattenedRun,</a>
<a name="ln369">			(int32*)&amp;runSize);</a>
<a name="ln370">		if (runArray) {</a>
<a name="ln371">			SetRunArray(0, TextLength(), runArray);</a>
<a name="ln372">			FreeRunArray(runArray);</a>
<a name="ln373">		}</a>
<a name="ln374">	}</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377"> </a>
<a name="ln378">BTextView::~BTextView()</a>
<a name="ln379">{</a>
<a name="ln380">	_CancelInputMethod();</a>
<a name="ln381">	_StopMouseTracking();</a>
<a name="ln382">	_DeleteOffscreen();</a>
<a name="ln383"> </a>
<a name="ln384">	delete fText;</a>
<a name="ln385">	delete fLines;</a>
<a name="ln386">	delete fStyles;</a>
<a name="ln387">	delete fDisallowedChars;</a>
<a name="ln388">	delete fUndo;</a>
<a name="ln389">	delete fClickRunner;</a>
<a name="ln390">	delete fDragRunner;</a>
<a name="ln391">	delete fLayoutData;</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394"> </a>
<a name="ln395">BArchivable*</a>
<a name="ln396">BTextView::Instantiate(BMessage* archive)</a>
<a name="ln397">{</a>
<a name="ln398">	CALLED();</a>
<a name="ln399">	if (validate_instantiation(archive, &quot;BTextView&quot;))</a>
<a name="ln400">		return new BTextView(archive);</a>
<a name="ln401">	return NULL;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">status_t</a>
<a name="ln406">BTextView::Archive(BMessage* data, bool deep) const</a>
<a name="ln407">{</a>
<a name="ln408">	CALLED();</a>
<a name="ln409">	status_t err = BView::Archive(data, deep);</a>
<a name="ln410">	if (err == B_OK)</a>
<a name="ln411">		err = data-&gt;AddString(&quot;_text&quot;, Text());</a>
<a name="ln412">	if (err == B_OK)</a>
<a name="ln413">		err = data-&gt;AddInt32(&quot;_align&quot;, fAlignment);</a>
<a name="ln414">	if (err == B_OK)</a>
<a name="ln415">		err = data-&gt;AddFloat(&quot;_tab&quot;, fTabWidth);</a>
<a name="ln416">	if (err == B_OK)</a>
<a name="ln417">		err = data-&gt;AddInt32(&quot;_col_sp&quot;, fColorSpace);</a>
<a name="ln418">	if (err == B_OK)</a>
<a name="ln419">		err = data-&gt;AddRect(&quot;_trect&quot;, fTextRect);</a>
<a name="ln420">	if (err == B_OK)</a>
<a name="ln421">		err = data-&gt;AddInt32(&quot;_max&quot;, fMaxBytes);</a>
<a name="ln422">	if (err == B_OK)</a>
<a name="ln423">		err = data-&gt;AddInt32(&quot;_sel&quot;, fSelStart);</a>
<a name="ln424">	if (err == B_OK)</a>
<a name="ln425">		err = data-&gt;AddInt32(&quot;_sel&quot;, fSelEnd);</a>
<a name="ln426">	if (err == B_OK)</a>
<a name="ln427">		err = data-&gt;AddBool(&quot;_stylable&quot;, fStylable);</a>
<a name="ln428">	if (err == B_OK)</a>
<a name="ln429">		err = data-&gt;AddBool(&quot;_auto_in&quot;, fAutoindent);</a>
<a name="ln430">	if (err == B_OK)</a>
<a name="ln431">		err = data-&gt;AddBool(&quot;_wrap&quot;, fWrap);</a>
<a name="ln432">	if (err == B_OK)</a>
<a name="ln433">		err = data-&gt;AddBool(&quot;_nsel&quot;, !fSelectable);</a>
<a name="ln434">	if (err == B_OK)</a>
<a name="ln435">		err = data-&gt;AddBool(&quot;_nedit&quot;, !fEditable);</a>
<a name="ln436"> </a>
<a name="ln437">	if (err == B_OK &amp;&amp; fDisallowedChars != NULL &amp;&amp; fDisallowedChars-&gt;CountItems() &gt; 0) {</a>
<a name="ln438">		err = data-&gt;AddData(&quot;_dis_ch&quot;, B_RAW_TYPE, fDisallowedChars-&gt;Items(),</a>
<a name="ln439">			fDisallowedChars-&gt;CountItems() * sizeof(int32));</a>
<a name="ln440">	}</a>
<a name="ln441"> </a>
<a name="ln442">	if (err == B_OK) {</a>
<a name="ln443">		int32 runSize = 0;</a>
<a name="ln444">		text_run_array* runArray = RunArray(0, TextLength());</a>
<a name="ln445"> </a>
<a name="ln446">		void* flattened = FlattenRunArray(runArray, &amp;runSize);</a>
<a name="ln447">		if (flattened != NULL) {</a>
<a name="ln448">			data-&gt;AddData(&quot;_runs&quot;, B_RAW_TYPE, flattened, runSize);</a>
<a name="ln449">			free(flattened);</a>
<a name="ln450">		} else</a>
<a name="ln451">			err = B_NO_MEMORY;</a>
<a name="ln452"> </a>
<a name="ln453">		FreeRunArray(runArray);</a>
<a name="ln454">	}</a>
<a name="ln455"> </a>
<a name="ln456">	return err;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">void</a>
<a name="ln461">BTextView::AttachedToWindow()</a>
<a name="ln462">{</a>
<a name="ln463">	BView::AttachedToWindow();</a>
<a name="ln464"> </a>
<a name="ln465">	SetDrawingMode(B_OP_COPY);</a>
<a name="ln466"> </a>
<a name="ln467">	Window()-&gt;SetPulseRate(500000);</a>
<a name="ln468"> </a>
<a name="ln469">	fCaretVisible = false;</a>
<a name="ln470">	fCaretTime = 0;</a>
<a name="ln471">	fClickCount = 0;</a>
<a name="ln472">	fClickTime = 0;</a>
<a name="ln473">	fDragOffset = -1;</a>
<a name="ln474">	fActive = false;</a>
<a name="ln475"> </a>
<a name="ln476">	_AutoResize(true);</a>
<a name="ln477"> </a>
<a name="ln478">	_UpdateScrollbars();</a>
<a name="ln479"> </a>
<a name="ln480">	SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">void</a>
<a name="ln485">BTextView::DetachedFromWindow()</a>
<a name="ln486">{</a>
<a name="ln487">	BView::DetachedFromWindow();</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">void</a>
<a name="ln492">BTextView::Draw(BRect updateRect)</a>
<a name="ln493">{</a>
<a name="ln494">	// what lines need to be drawn?</a>
<a name="ln495">	int32 startLine = _LineAt(BPoint(0.0, updateRect.top));</a>
<a name="ln496">	int32 endLine = _LineAt(BPoint(0.0, updateRect.bottom));</a>
<a name="ln497"> </a>
<a name="ln498">	_DrawLines(startLine, endLine, -1, true);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">void</a>
<a name="ln503">BTextView::MouseDown(BPoint where)</a>
<a name="ln504">{</a>
<a name="ln505">	// should we even bother?</a>
<a name="ln506">	if (!fEditable &amp;&amp; !fSelectable)</a>
<a name="ln507">		return;</a>
<a name="ln508"> </a>
<a name="ln509">	_CancelInputMethod();</a>
<a name="ln510"> </a>
<a name="ln511">	if (!IsFocus())</a>
<a name="ln512">		MakeFocus();</a>
<a name="ln513"> </a>
<a name="ln514">	_HideCaret();</a>
<a name="ln515"> </a>
<a name="ln516">	_StopMouseTracking();</a>
<a name="ln517"> </a>
<a name="ln518">	int32 modifiers = 0;</a>
<a name="ln519">	uint32 buttons = 0;</a>
<a name="ln520">	BMessage* currentMessage = Window()-&gt;CurrentMessage();</a>
<a name="ln521">	if (currentMessage != NULL) {</a>
<a name="ln522">		currentMessage-&gt;FindInt32(&quot;modifiers&quot;, &amp;modifiers);</a>
<a name="ln523">		currentMessage-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons);</a>
<a name="ln524">	}</a>
<a name="ln525"> </a>
<a name="ln526">	if (buttons == B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln527">		_ShowContextMenu(where);</a>
<a name="ln528">		return;</a>
<a name="ln529">	}</a>
<a name="ln530"> </a>
<a name="ln531">	BMessenger messenger(this);</a>
<a name="ln532">	fTrackingMouse = new (nothrow) TextTrackState(messenger);</a>
<a name="ln533">	if (fTrackingMouse == NULL)</a>
<a name="ln534">		return;</a>
<a name="ln535"> </a>
<a name="ln536">	fTrackingMouse-&gt;clickOffset = OffsetAt(where);</a>
<a name="ln537">	fTrackingMouse-&gt;shiftDown = modifiers &amp; B_SHIFT_KEY;</a>
<a name="ln538">	fTrackingMouse-&gt;where = where;</a>
<a name="ln539"> </a>
<a name="ln540">	bigtime_t clickTime = system_time();</a>
<a name="ln541">	bigtime_t clickSpeed = 0;</a>
<a name="ln542">	get_click_speed(&amp;clickSpeed);</a>
<a name="ln543">	bool multipleClick</a>
<a name="ln544">		= clickTime - fClickTime &lt; clickSpeed</a>
<a name="ln545">			&amp;&amp; fLastClickOffset == fTrackingMouse-&gt;clickOffset;</a>
<a name="ln546"> </a>
<a name="ln547">	fWhere = where;</a>
<a name="ln548"> </a>
<a name="ln549">	SetMouseEventMask(B_POINTER_EVENTS | B_KEYBOARD_EVENTS,</a>
<a name="ln550">		B_LOCK_WINDOW_FOCUS | B_NO_POINTER_HISTORY);</a>
<a name="ln551"> </a>
<a name="ln552">	if (fSelStart != fSelEnd &amp;&amp; !fTrackingMouse-&gt;shiftDown &amp;&amp; !multipleClick) {</a>
<a name="ln553">		BRegion region;</a>
<a name="ln554">		GetTextRegion(fSelStart, fSelEnd, &amp;region);</a>
<a name="ln555">		if (region.Contains(where)) {</a>
<a name="ln556">			// Setup things for dragging</a>
<a name="ln557">			fTrackingMouse-&gt;selectionRect = region.Frame();</a>
<a name="ln558">			fClickCount = 1;</a>
<a name="ln559">			fClickTime = clickTime;</a>
<a name="ln560">			fLastClickOffset = OffsetAt(where);</a>
<a name="ln561">			return;</a>
<a name="ln562">		}</a>
<a name="ln563">	}</a>
<a name="ln564"> </a>
<a name="ln565">	if (multipleClick) {</a>
<a name="ln566">		if (fClickCount &gt; 3) {</a>
<a name="ln567">			fClickCount = 0;</a>
<a name="ln568">			fClickTime = 0;</a>
<a name="ln569">		} else {</a>
<a name="ln570">			fClickCount++;</a>
<a name="ln571">			fClickTime = clickTime;</a>
<a name="ln572">		}</a>
<a name="ln573">	} else if (!fTrackingMouse-&gt;shiftDown) {</a>
<a name="ln574">		// If no multiple click yet and shift is not pressed, this is an</a>
<a name="ln575">		// independent first click somewhere into the textview - we initialize</a>
<a name="ln576">		// the corresponding members for handling potential multiple clicks:</a>
<a name="ln577">		fLastClickOffset = fCaretOffset = fTrackingMouse-&gt;clickOffset;</a>
<a name="ln578">		fClickCount = 1;</a>
<a name="ln579">		fClickTime = clickTime;</a>
<a name="ln580"> </a>
<a name="ln581">		// Deselect any previously selected text</a>
<a name="ln582">		Select(fTrackingMouse-&gt;clickOffset, fTrackingMouse-&gt;clickOffset);</a>
<a name="ln583">	}</a>
<a name="ln584"> </a>
<a name="ln585">	if (fClickTime == clickTime) {</a>
<a name="ln586">		BMessage message(_PING_);</a>
<a name="ln587">		message.AddInt64(&quot;clickTime&quot;, clickTime);</a>
<a name="ln588">		delete fClickRunner;</a>
<a name="ln589"> </a>
<a name="ln590">		BMessenger messenger(this);</a>
<a name="ln591">		fClickRunner = new (nothrow) BMessageRunner(messenger, &amp;message,</a>
<a name="ln592">			clickSpeed, 1);</a>
<a name="ln593">	}</a>
<a name="ln594"> </a>
<a name="ln595">	if (!fSelectable) {</a>
<a name="ln596">		_StopMouseTracking();</a>
<a name="ln597">		return;</a>
<a name="ln598">	}</a>
<a name="ln599"> </a>
<a name="ln600">	int32 offset = fSelStart;</a>
<a name="ln601">	if (fTrackingMouse-&gt;clickOffset &gt; fSelStart)</a>
<a name="ln602">		offset = fSelEnd;</a>
<a name="ln603"> </a>
<a name="ln604">	fTrackingMouse-&gt;anchor = offset;</a>
<a name="ln605"> </a>
<a name="ln606">	MouseMoved(where, B_INSIDE_VIEW, NULL);</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">void</a>
<a name="ln611">BTextView::MouseUp(BPoint where)</a>
<a name="ln612">{</a>
<a name="ln613">	BView::MouseUp(where);</a>
<a name="ln614">	_PerformMouseUp(where);</a>
<a name="ln615"> </a>
<a name="ln616">	delete fDragRunner;</a>
<a name="ln617">	fDragRunner = NULL;</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">void</a>
<a name="ln622">BTextView::MouseMoved(BPoint where, uint32 code, const BMessage* dragMessage)</a>
<a name="ln623">{</a>
<a name="ln624">	// check if it's a &quot;click'n'move&quot;</a>
<a name="ln625">	if (_PerformMouseMoved(where, code))</a>
<a name="ln626">		return;</a>
<a name="ln627"> </a>
<a name="ln628">	switch (code) {</a>
<a name="ln629">		case B_ENTERED_VIEW:</a>
<a name="ln630">		case B_INSIDE_VIEW:</a>
<a name="ln631">			_TrackMouse(where, dragMessage, true);</a>
<a name="ln632">			break;</a>
<a name="ln633"> </a>
<a name="ln634">		case B_EXITED_VIEW:</a>
<a name="ln635">			_DragCaret(-1);</a>
<a name="ln636">			if (Window()-&gt;IsActive() &amp;&amp; dragMessage == NULL)</a>
<a name="ln637">				SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln638">			break;</a>
<a name="ln639"> </a>
<a name="ln640">		default:</a>
<a name="ln641">			BView::MouseMoved(where, code, dragMessage);</a>
<a name="ln642">	}</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645"> </a>
<a name="ln646">void</a>
<a name="ln647">BTextView::WindowActivated(bool active)</a>
<a name="ln648">{</a>
<a name="ln649">	BView::WindowActivated(active);</a>
<a name="ln650"> </a>
<a name="ln651">	if (active &amp;&amp; IsFocus()) {</a>
<a name="ln652">		if (!fActive)</a>
<a name="ln653">			_Activate();</a>
<a name="ln654">	} else {</a>
<a name="ln655">		if (fActive)</a>
<a name="ln656">			_Deactivate();</a>
<a name="ln657">	}</a>
<a name="ln658"> </a>
<a name="ln659">	BPoint where;</a>
<a name="ln660">	uint32 buttons;</a>
<a name="ln661">	GetMouse(&amp;where, &amp;buttons, false);</a>
<a name="ln662"> </a>
<a name="ln663">	if (Bounds().Contains(where))</a>
<a name="ln664">		_TrackMouse(where, NULL);</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667"> </a>
<a name="ln668">void</a>
<a name="ln669">BTextView::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln670">{</a>
<a name="ln671">	const char keyPressed = bytes[0];</a>
<a name="ln672"> </a>
<a name="ln673">	if (!fEditable) {</a>
<a name="ln674">		// only arrow and page keys are allowed</a>
<a name="ln675">		// (no need to hide the cursor)</a>
<a name="ln676">		switch (keyPressed) {</a>
<a name="ln677">			case B_LEFT_ARROW:</a>
<a name="ln678">			case B_RIGHT_ARROW:</a>
<a name="ln679">			case B_UP_ARROW:</a>
<a name="ln680">			case B_DOWN_ARROW:</a>
<a name="ln681">				_HandleArrowKey(keyPressed);</a>
<a name="ln682">				break;</a>
<a name="ln683"> </a>
<a name="ln684">			case B_HOME:</a>
<a name="ln685">			case B_END:</a>
<a name="ln686">			case B_PAGE_UP:</a>
<a name="ln687">			case B_PAGE_DOWN:</a>
<a name="ln688">				_HandlePageKey(keyPressed);</a>
<a name="ln689">				break;</a>
<a name="ln690"> </a>
<a name="ln691">			default:</a>
<a name="ln692">				BView::KeyDown(bytes, numBytes);</a>
<a name="ln693">				break;</a>
<a name="ln694">		}</a>
<a name="ln695"> </a>
<a name="ln696">		return;</a>
<a name="ln697">	}</a>
<a name="ln698"> </a>
<a name="ln699">	// hide the cursor and caret</a>
<a name="ln700">	if (IsFocus())</a>
<a name="ln701">		be_app-&gt;ObscureCursor();</a>
<a name="ln702">	_HideCaret();</a>
<a name="ln703"> </a>
<a name="ln704">	switch (keyPressed) {</a>
<a name="ln705">		case B_BACKSPACE:</a>
<a name="ln706">			_HandleBackspace();</a>
<a name="ln707">			break;</a>
<a name="ln708"> </a>
<a name="ln709">		case B_LEFT_ARROW:</a>
<a name="ln710">		case B_RIGHT_ARROW:</a>
<a name="ln711">		case B_UP_ARROW:</a>
<a name="ln712">		case B_DOWN_ARROW:</a>
<a name="ln713">			_HandleArrowKey(keyPressed);</a>
<a name="ln714">			break;</a>
<a name="ln715"> </a>
<a name="ln716">		case B_DELETE:</a>
<a name="ln717">			_HandleDelete();</a>
<a name="ln718">			break;</a>
<a name="ln719"> </a>
<a name="ln720">		case B_HOME:</a>
<a name="ln721">		case B_END:</a>
<a name="ln722">		case B_PAGE_UP:</a>
<a name="ln723">		case B_PAGE_DOWN:</a>
<a name="ln724">			_HandlePageKey(keyPressed);</a>
<a name="ln725">			break;</a>
<a name="ln726"> </a>
<a name="ln727">		case B_ESCAPE:</a>
<a name="ln728">		case B_INSERT:</a>
<a name="ln729">		case B_FUNCTION_KEY:</a>
<a name="ln730">			// ignore, pass it up to superclass</a>
<a name="ln731">			BView::KeyDown(bytes, numBytes);</a>
<a name="ln732">			break;</a>
<a name="ln733"> </a>
<a name="ln734">		default:</a>
<a name="ln735">			// bail out if the character is not allowed</a>
<a name="ln736">			if (fDisallowedChars</a>
<a name="ln737">				&amp;&amp; fDisallowedChars-&gt;HasItem(</a>
<a name="ln738">					reinterpret_cast&lt;void*&gt;((uint32)keyPressed))) {</a>
<a name="ln739">				beep();</a>
<a name="ln740">				return;</a>
<a name="ln741">			}</a>
<a name="ln742"> </a>
<a name="ln743">			_HandleAlphaKey(bytes, numBytes);</a>
<a name="ln744">			break;</a>
<a name="ln745">	}</a>
<a name="ln746"> </a>
<a name="ln747">	// draw the caret</a>
<a name="ln748">	if (fSelStart == fSelEnd)</a>
<a name="ln749">		_ShowCaret();</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752"> </a>
<a name="ln753">void</a>
<a name="ln754">BTextView::Pulse()</a>
<a name="ln755">{</a>
<a name="ln756">	if (fActive &amp;&amp; fEditable &amp;&amp; fSelStart == fSelEnd) {</a>
<a name="ln757">		if (system_time() &gt; (fCaretTime + 500000.0))</a>
<a name="ln758">			_InvertCaret();</a>
<a name="ln759">	}</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762"> </a>
<a name="ln763">void</a>
<a name="ln764">BTextView::FrameResized(float newWidth, float newHeight)</a>
<a name="ln765">{</a>
<a name="ln766">	BView::FrameResized(newWidth, newHeight);</a>
<a name="ln767">	_UpdateScrollbars();</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770"> </a>
<a name="ln771">void</a>
<a name="ln772">BTextView::MakeFocus(bool focus)</a>
<a name="ln773">{</a>
<a name="ln774">	BView::MakeFocus(focus);</a>
<a name="ln775"> </a>
<a name="ln776">	if (focus &amp;&amp; Window() != NULL &amp;&amp; Window()-&gt;IsActive()) {</a>
<a name="ln777">		if (!fActive)</a>
<a name="ln778">			_Activate();</a>
<a name="ln779">	} else {</a>
<a name="ln780">		if (fActive)</a>
<a name="ln781">			_Deactivate();</a>
<a name="ln782">	}</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785"> </a>
<a name="ln786">void</a>
<a name="ln787">BTextView::MessageReceived(BMessage* message)</a>
<a name="ln788">{</a>
<a name="ln789">	// ToDo: block input if not editable (Andrew)</a>
<a name="ln790"> </a>
<a name="ln791">	// was this message dropped?</a>
<a name="ln792">	if (message-&gt;WasDropped()) {</a>
<a name="ln793">		BPoint dropOffset;</a>
<a name="ln794">		BPoint dropPoint = message-&gt;DropPoint(&amp;dropOffset);</a>
<a name="ln795">		ConvertFromScreen(&amp;dropPoint);</a>
<a name="ln796">		ConvertFromScreen(&amp;dropOffset);</a>
<a name="ln797">		if (!_MessageDropped(message, dropPoint, dropOffset))</a>
<a name="ln798">			BView::MessageReceived(message);</a>
<a name="ln799"> </a>
<a name="ln800">		return;</a>
<a name="ln801">	}</a>
<a name="ln802"> </a>
<a name="ln803">	switch (message-&gt;what) {</a>
<a name="ln804">		case B_CUT:</a>
<a name="ln805">			if (!IsTypingHidden())</a>
<a name="ln806">				Cut(be_clipboard);</a>
<a name="ln807">			else</a>
<a name="ln808">				beep();</a>
<a name="ln809">			break;</a>
<a name="ln810"> </a>
<a name="ln811">		case B_COPY:</a>
<a name="ln812">			if (!IsTypingHidden())</a>
<a name="ln813">				Copy(be_clipboard);</a>
<a name="ln814">			else</a>
<a name="ln815">				beep();</a>
<a name="ln816">			break;</a>
<a name="ln817"> </a>
<a name="ln818">		case B_PASTE:</a>
<a name="ln819">			Paste(be_clipboard);</a>
<a name="ln820">			break;</a>
<a name="ln821"> </a>
<a name="ln822">		case B_UNDO:</a>
<a name="ln823">			Undo(be_clipboard);</a>
<a name="ln824">			break;</a>
<a name="ln825"> </a>
<a name="ln826">		case B_SELECT_ALL:</a>
<a name="ln827">			SelectAll();</a>
<a name="ln828">			break;</a>
<a name="ln829"> </a>
<a name="ln830">		case B_INPUT_METHOD_EVENT:</a>
<a name="ln831">		{</a>
<a name="ln832">			int32 opcode;</a>
<a name="ln833">			if (message-&gt;FindInt32(&quot;be:opcode&quot;, &amp;opcode) == B_OK) {</a>
<a name="ln834">				switch (opcode) {</a>
<a name="ln835">					case B_INPUT_METHOD_STARTED:</a>
<a name="ln836">					{</a>
<a name="ln837">						BMessenger messenger;</a>
<a name="ln838">						if (message-&gt;FindMessenger(&quot;be:reply_to&quot;, &amp;messenger)</a>
<a name="ln839">								== B_OK) {</a>
<a name="ln840">							ASSERT(fInline == NULL);</a>
<a name="ln841">							fInline = new InlineInput(messenger);</a>
<a name="ln842">						}</a>
<a name="ln843">						break;</a>
<a name="ln844">					}</a>
<a name="ln845"> </a>
<a name="ln846">					case B_INPUT_METHOD_STOPPED:</a>
<a name="ln847">						delete fInline;</a>
<a name="ln848">						fInline = NULL;</a>
<a name="ln849">						break;</a>
<a name="ln850"> </a>
<a name="ln851">					case B_INPUT_METHOD_CHANGED:</a>
<a name="ln852">						if (fInline != NULL)</a>
<a name="ln853">							_HandleInputMethodChanged(message);</a>
<a name="ln854">						break;</a>
<a name="ln855"> </a>
<a name="ln856">					case B_INPUT_METHOD_LOCATION_REQUEST:</a>
<a name="ln857">						if (fInline != NULL)</a>
<a name="ln858">							_HandleInputMethodLocationRequest();</a>
<a name="ln859">						break;</a>
<a name="ln860"> </a>
<a name="ln861">					default:</a>
<a name="ln862">						break;</a>
<a name="ln863">				}</a>
<a name="ln864">			}</a>
<a name="ln865">			break;</a>
<a name="ln866">		}</a>
<a name="ln867"> </a>
<a name="ln868">		case B_SET_PROPERTY:</a>
<a name="ln869">		case B_GET_PROPERTY:</a>
<a name="ln870">		case B_COUNT_PROPERTIES:</a>
<a name="ln871">		{</a>
<a name="ln872">			BPropertyInfo propInfo(sPropertyList);</a>
<a name="ln873">			BMessage specifier;</a>
<a name="ln874">			const char* property;</a>
<a name="ln875"> </a>
<a name="ln876">			if (message-&gt;GetCurrentSpecifier(NULL, &amp;specifier) &lt; B_OK</a>
<a name="ln877">				|| specifier.FindString(&quot;property&quot;, &amp;property) &lt; B_OK)</a>
<a name="ln878">				return;</a>
<a name="ln879"> </a>
<a name="ln880">			if (propInfo.FindMatch(message, 0, &amp;specifier, specifier.what,</a>
<a name="ln881">					property) &lt; B_OK) {</a>
<a name="ln882">				BView::MessageReceived(message);</a>
<a name="ln883">				break;</a>
<a name="ln884">			}</a>
<a name="ln885"> </a>
<a name="ln886">			BMessage reply;</a>
<a name="ln887">			bool handled = false;</a>
<a name="ln888">			switch(message-&gt;what) {</a>
<a name="ln889">				case B_GET_PROPERTY:</a>
<a name="ln890">					handled = _GetProperty(&amp;specifier, specifier.what, property,</a>
<a name="ln891">						&amp;reply);</a>
<a name="ln892">					break;</a>
<a name="ln893"> </a>
<a name="ln894">				case B_SET_PROPERTY:</a>
<a name="ln895">					handled = _SetProperty(&amp;specifier, specifier.what, property,</a>
<a name="ln896">						&amp;reply);</a>
<a name="ln897">					break;</a>
<a name="ln898"> </a>
<a name="ln899">				case B_COUNT_PROPERTIES:</a>
<a name="ln900">					handled = _CountProperties(&amp;specifier, specifier.what,</a>
<a name="ln901">						property, &amp;reply);</a>
<a name="ln902">					break;</a>
<a name="ln903"> </a>
<a name="ln904">				default:</a>
<a name="ln905">					break;</a>
<a name="ln906">			}</a>
<a name="ln907">			if (handled)</a>
<a name="ln908">				message-&gt;SendReply(&amp;reply);</a>
<a name="ln909">			else</a>
<a name="ln910">				BView::MessageReceived(message);</a>
<a name="ln911">			break;</a>
<a name="ln912">		}</a>
<a name="ln913"> </a>
<a name="ln914">		case _PING_:</a>
<a name="ln915">		{</a>
<a name="ln916">			if (message-&gt;HasInt64(&quot;clickTime&quot;)) {</a>
<a name="ln917">				bigtime_t clickTime;</a>
<a name="ln918">				message-&gt;FindInt64(&quot;clickTime&quot;, &amp;clickTime);</a>
<a name="ln919">				if (clickTime == fClickTime) {</a>
<a name="ln920">					if (fSelStart != fSelEnd &amp;&amp; fSelectable) {</a>
<a name="ln921">						BRegion region;</a>
<a name="ln922">						GetTextRegion(fSelStart, fSelEnd, &amp;region);</a>
<a name="ln923">						if (region.Contains(fWhere))</a>
<a name="ln924">							_TrackMouse(fWhere, NULL);</a>
<a name="ln925">					}</a>
<a name="ln926">					delete fClickRunner;</a>
<a name="ln927">					fClickRunner = NULL;</a>
<a name="ln928">				}</a>
<a name="ln929">			} else if (fTrackingMouse) {</a>
<a name="ln930">				fTrackingMouse-&gt;SimulateMouseMovement(this);</a>
<a name="ln931">				_PerformAutoScrolling();</a>
<a name="ln932">			}</a>
<a name="ln933">			break;</a>
<a name="ln934">		}</a>
<a name="ln935"> </a>
<a name="ln936">		case _DISPOSE_DRAG_:</a>
<a name="ln937">			if (fEditable)</a>
<a name="ln938">				_TrackDrag(fWhere);</a>
<a name="ln939">			break;</a>
<a name="ln940"> </a>
<a name="ln941">		case kMsgNavigateArrow:</a>
<a name="ln942">		{</a>
<a name="ln943">			int32 key = message-&gt;GetInt32(&quot;key&quot;, 0);</a>
<a name="ln944">			int32 modifiers = message-&gt;GetInt32(&quot;modifiers&quot;, 0);</a>
<a name="ln945">			_HandleArrowKey(key, modifiers);</a>
<a name="ln946">			break;</a>
<a name="ln947">		}</a>
<a name="ln948"> </a>
<a name="ln949">		case kMsgNavigatePage:</a>
<a name="ln950">		{</a>
<a name="ln951">			int32 key = message-&gt;GetInt32(&quot;key&quot;, 0);</a>
<a name="ln952">			int32 modifiers = message-&gt;GetInt32(&quot;modifiers&quot;, 0);</a>
<a name="ln953">			_HandlePageKey(key, modifiers);</a>
<a name="ln954">			break;</a>
<a name="ln955">		}</a>
<a name="ln956"> </a>
<a name="ln957">		default:</a>
<a name="ln958">			BView::MessageReceived(message);</a>
<a name="ln959">			break;</a>
<a name="ln960">	}</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963"> </a>
<a name="ln964">BHandler*</a>
<a name="ln965">BTextView::ResolveSpecifier(BMessage* message, int32 index, BMessage* specifier,</a>
<a name="ln966">	int32 what, const char* property)</a>
<a name="ln967">{</a>
<a name="ln968">	BPropertyInfo propInfo(sPropertyList);</a>
<a name="ln969">	BHandler* target = this;</a>
<a name="ln970"> </a>
<a name="ln971">	if (propInfo.FindMatch(message, index, specifier, what, property) &lt; B_OK) {</a>
<a name="ln972">		target = BView::ResolveSpecifier(message, index, specifier, what,</a>
<a name="ln973">			property);</a>
<a name="ln974">	}</a>
<a name="ln975"> </a>
<a name="ln976">	return target;</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979"> </a>
<a name="ln980">status_t</a>
<a name="ln981">BTextView::GetSupportedSuites(BMessage* data)</a>
<a name="ln982">{</a>
<a name="ln983">	if (data == NULL)</a>
<a name="ln984">		return B_BAD_VALUE;</a>
<a name="ln985"> </a>
<a name="ln986">	status_t err = data-&gt;AddString(&quot;suites&quot;, &quot;suite/vnd.Be-text-view&quot;);</a>
<a name="ln987">	if (err != B_OK)</a>
<a name="ln988">		return err;</a>
<a name="ln989"> </a>
<a name="ln990">	BPropertyInfo prop_info(sPropertyList);</a>
<a name="ln991">	err = data-&gt;AddFlat(&quot;messages&quot;, &amp;prop_info);</a>
<a name="ln992"> </a>
<a name="ln993">	if (err != B_OK)</a>
<a name="ln994">		return err;</a>
<a name="ln995">	return BView::GetSupportedSuites(data);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998"> </a>
<a name="ln999">status_t</a>
<a name="ln1000">BTextView::Perform(perform_code code, void* _data)</a>
<a name="ln1001">{</a>
<a name="ln1002">	switch (code) {</a>
<a name="ln1003">		case PERFORM_CODE_MIN_SIZE:</a>
<a name="ln1004">			((perform_data_min_size*)_data)-&gt;return_value</a>
<a name="ln1005">				= BTextView::MinSize();</a>
<a name="ln1006">			return B_OK;</a>
<a name="ln1007">		case PERFORM_CODE_MAX_SIZE:</a>
<a name="ln1008">			((perform_data_max_size*)_data)-&gt;return_value</a>
<a name="ln1009">				= BTextView::MaxSize();</a>
<a name="ln1010">			return B_OK;</a>
<a name="ln1011">		case PERFORM_CODE_PREFERRED_SIZE:</a>
<a name="ln1012">			((perform_data_preferred_size*)_data)-&gt;return_value</a>
<a name="ln1013">				= BTextView::PreferredSize();</a>
<a name="ln1014">			return B_OK;</a>
<a name="ln1015">		case PERFORM_CODE_LAYOUT_ALIGNMENT:</a>
<a name="ln1016">			((perform_data_layout_alignment*)_data)-&gt;return_value</a>
<a name="ln1017">				= BTextView::LayoutAlignment();</a>
<a name="ln1018">			return B_OK;</a>
<a name="ln1019">		case PERFORM_CODE_HAS_HEIGHT_FOR_WIDTH:</a>
<a name="ln1020">			((perform_data_has_height_for_width*)_data)-&gt;return_value</a>
<a name="ln1021">				= BTextView::HasHeightForWidth();</a>
<a name="ln1022">			return B_OK;</a>
<a name="ln1023">		case PERFORM_CODE_GET_HEIGHT_FOR_WIDTH:</a>
<a name="ln1024">		{</a>
<a name="ln1025">			perform_data_get_height_for_width* data</a>
<a name="ln1026">				= (perform_data_get_height_for_width*)_data;</a>
<a name="ln1027">			BTextView::GetHeightForWidth(data-&gt;width, &amp;data-&gt;min, &amp;data-&gt;max,</a>
<a name="ln1028">				&amp;data-&gt;preferred);</a>
<a name="ln1029">			return B_OK;</a>
<a name="ln1030">		}</a>
<a name="ln1031">		case PERFORM_CODE_SET_LAYOUT:</a>
<a name="ln1032">		{</a>
<a name="ln1033">			perform_data_set_layout* data = (perform_data_set_layout*)_data;</a>
<a name="ln1034">			BTextView::SetLayout(data-&gt;layout);</a>
<a name="ln1035">			return B_OK;</a>
<a name="ln1036">		}</a>
<a name="ln1037">		case PERFORM_CODE_LAYOUT_INVALIDATED:</a>
<a name="ln1038">		{</a>
<a name="ln1039">			perform_data_layout_invalidated* data</a>
<a name="ln1040">				= (perform_data_layout_invalidated*)_data;</a>
<a name="ln1041">			BTextView::LayoutInvalidated(data-&gt;descendants);</a>
<a name="ln1042">			return B_OK;</a>
<a name="ln1043">		}</a>
<a name="ln1044">		case PERFORM_CODE_DO_LAYOUT:</a>
<a name="ln1045">		{</a>
<a name="ln1046">			BTextView::DoLayout();</a>
<a name="ln1047">			return B_OK;</a>
<a name="ln1048">		}</a>
<a name="ln1049">	}</a>
<a name="ln1050"> </a>
<a name="ln1051">	return BView::Perform(code, _data);</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055">void</a>
<a name="ln1056">BTextView::SetText(const char* text, const text_run_array* runs)</a>
<a name="ln1057">{</a>
<a name="ln1058">	SetText(text, text ? strlen(text) : 0, runs);</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061"> </a>
<a name="ln1062">void</a>
<a name="ln1063">BTextView::SetText(const char* text, int32 length, const text_run_array* runs)</a>
<a name="ln1064">{</a>
<a name="ln1065">	_CancelInputMethod();</a>
<a name="ln1066"> </a>
<a name="ln1067">	// hide the caret/unhighlight the selection</a>
<a name="ln1068">	if (fActive) {</a>
<a name="ln1069">		if (fSelStart != fSelEnd) {</a>
<a name="ln1070">			if (fSelectable)</a>
<a name="ln1071">				Highlight(fSelStart, fSelEnd);</a>
<a name="ln1072">		} else</a>
<a name="ln1073">			_HideCaret();</a>
<a name="ln1074">	}</a>
<a name="ln1075"> </a>
<a name="ln1076">	// remove data from buffer</a>
<a name="ln1077">	if (fText-&gt;Length() &gt; 0)</a>
<a name="ln1078">		DeleteText(0, fText-&gt;Length());</a>
<a name="ln1079"> </a>
<a name="ln1080">	if (text != NULL &amp;&amp; length &gt; 0)</a>
<a name="ln1081">		InsertText(text, length, 0, runs);</a>
<a name="ln1082"> </a>
<a name="ln1083">	// recalculate line breaks and draw the text</a>
<a name="ln1084">	_Refresh(0, length, false);</a>
<a name="ln1085">	fCaretOffset = fSelStart = fSelEnd = 0;</a>
<a name="ln1086">	ScrollTo(B_ORIGIN);</a>
<a name="ln1087"> </a>
<a name="ln1088">	// draw the caret</a>
<a name="ln1089">	_ShowCaret();</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092"> </a>
<a name="ln1093">void</a>
<a name="ln1094">BTextView::SetText(BFile* file, int32 offset, int32 length,</a>
<a name="ln1095">	const text_run_array* runs)</a>
<a name="ln1096">{</a>
<a name="ln1097">	CALLED();</a>
<a name="ln1098"> </a>
<a name="ln1099">	_CancelInputMethod();</a>
<a name="ln1100"> </a>
<a name="ln1101">	if (file == NULL)</a>
<a name="ln1102">		return;</a>
<a name="ln1103"> </a>
<a name="ln1104">	if (fText-&gt;Length() &gt; 0)</a>
<a name="ln1105">		DeleteText(0, fText-&gt;Length());</a>
<a name="ln1106"> </a>
<a name="ln1107">	if (!fText-&gt;InsertText(file, offset, length, 0))</a>
<a name="ln1108">		return;</a>
<a name="ln1109"> </a>
<a name="ln1110">	// update the start offsets of each line below offset</a>
<a name="ln1111">	fLines-&gt;BumpOffset(length, _LineAt(offset) + 1);</a>
<a name="ln1112"> </a>
<a name="ln1113">	// update the style runs</a>
<a name="ln1114">	fStyles-&gt;BumpOffset(length, fStyles-&gt;OffsetToRun(offset - 1) + 1);</a>
<a name="ln1115"> </a>
<a name="ln1116">	if (fStylable &amp;&amp; runs != NULL)</a>
<a name="ln1117">		SetRunArray(offset, offset + length, runs);</a>
<a name="ln1118">	else {</a>
<a name="ln1119">		// apply null-style to inserted text</a>
<a name="ln1120">		_ApplyStyleRange(offset, offset + length);</a>
<a name="ln1121">	}</a>
<a name="ln1122"> </a>
<a name="ln1123">	// recalculate line breaks and draw the text</a>
<a name="ln1124">	_Refresh(0, length, false);</a>
<a name="ln1125">	fCaretOffset = fSelStart = fSelEnd = 0;</a>
<a name="ln1126">	ScrollToOffset(fSelStart);</a>
<a name="ln1127"> </a>
<a name="ln1128">	// draw the caret</a>
<a name="ln1129">	_ShowCaret();</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132"> </a>
<a name="ln1133">void</a>
<a name="ln1134">BTextView::Insert(const char* text, const text_run_array* runs)</a>
<a name="ln1135">{</a>
<a name="ln1136">	if (text != NULL)</a>
<a name="ln1137">		_DoInsertText(text, strlen(text), fSelStart, runs);</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140"> </a>
<a name="ln1141">void</a>
<a name="ln1142">BTextView::Insert(const char* text, int32 length, const text_run_array* runs)</a>
<a name="ln1143">{</a>
<a name="ln1144">	if (text != NULL &amp;&amp; length &gt; 0)</a>
<a name="ln1145">		_DoInsertText(text, strnlen(text, length), fSelStart, runs);</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148"> </a>
<a name="ln1149">void</a>
<a name="ln1150">BTextView::Insert(int32 offset, const char* text, int32 length,</a>
<a name="ln1151">	const text_run_array* runs)</a>
<a name="ln1152">{</a>
<a name="ln1153">	// pin offset at reasonable values</a>
<a name="ln1154">	if (offset &lt; 0)</a>
<a name="ln1155">		offset = 0;</a>
<a name="ln1156">	else if (offset &gt; fText-&gt;Length())</a>
<a name="ln1157">		offset = fText-&gt;Length();</a>
<a name="ln1158"> </a>
<a name="ln1159">	if (text != NULL &amp;&amp; length &gt; 0)</a>
<a name="ln1160">		_DoInsertText(text, strnlen(text, length), offset, runs);</a>
<a name="ln1161">}</a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164">void</a>
<a name="ln1165">BTextView::Delete()</a>
<a name="ln1166">{</a>
<a name="ln1167">	Delete(fSelStart, fSelEnd);</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170"> </a>
<a name="ln1171">void</a>
<a name="ln1172">BTextView::Delete(int32 startOffset, int32 endOffset)</a>
<a name="ln1173">{</a>
<a name="ln1174">	CALLED();</a>
<a name="ln1175"> </a>
<a name="ln1176">	// pin offsets at reasonable values</a>
<a name="ln1177">	if (startOffset &lt; 0)</a>
<a name="ln1178">		startOffset = 0;</a>
<a name="ln1179">	else if (startOffset &gt; fText-&gt;Length())</a>
<a name="ln1180">		startOffset = fText-&gt;Length();</a>
<a name="ln1181">	if (endOffset &lt; 0)</a>
<a name="ln1182">		endOffset = 0;</a>
<a name="ln1183">	else if (endOffset &gt; fText-&gt;Length())</a>
<a name="ln1184">		endOffset = fText-&gt;Length();</a>
<a name="ln1185"> </a>
<a name="ln1186">	// anything to delete?</a>
<a name="ln1187">	if (startOffset == endOffset)</a>
<a name="ln1188">		return;</a>
<a name="ln1189"> </a>
<a name="ln1190">	// hide the caret/unhighlight the selection</a>
<a name="ln1191">	if (fActive) {</a>
<a name="ln1192">		if (fSelStart != fSelEnd) {</a>
<a name="ln1193">			if (fSelectable)</a>
<a name="ln1194">				Highlight(fSelStart, fSelEnd);</a>
<a name="ln1195">		} else</a>
<a name="ln1196">			_HideCaret();</a>
<a name="ln1197">	}</a>
<a name="ln1198">	// remove data from buffer</a>
<a name="ln1199">	DeleteText(startOffset, endOffset);</a>
<a name="ln1200"> </a>
<a name="ln1201">	// check if the caret needs to be moved</a>
<a name="ln1202">	if (fCaretOffset &gt;= endOffset)</a>
<a name="ln1203">		fCaretOffset -= (endOffset - startOffset);</a>
<a name="ln1204">	else if (fCaretOffset &gt;= startOffset &amp;&amp; fCaretOffset &lt; endOffset)</a>
<a name="ln1205">		fCaretOffset = startOffset;</a>
<a name="ln1206"> </a>
<a name="ln1207">	fSelEnd = fSelStart = fCaretOffset;</a>
<a name="ln1208"> </a>
<a name="ln1209">	// recalculate line breaks and draw what's left</a>
<a name="ln1210">	_Refresh(startOffset, endOffset, false);</a>
<a name="ln1211"> </a>
<a name="ln1212">	// draw the caret</a>
<a name="ln1213">	_ShowCaret();</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216"> </a>
<a name="ln1217">const char*</a>
<a name="ln1218">BTextView::Text() const</a>
<a name="ln1219">{</a>
<a name="ln1220">	return fText-&gt;RealText();</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223"> </a>
<a name="ln1224">int32</a>
<a name="ln1225">BTextView::TextLength() const</a>
<a name="ln1226">{</a>
<a name="ln1227">	return fText-&gt;Length();</a>
<a name="ln1228">}</a>
<a name="ln1229"> </a>
<a name="ln1230"> </a>
<a name="ln1231">void</a>
<a name="ln1232">BTextView::GetText(int32 offset, int32 length, char* buffer) const</a>
<a name="ln1233">{</a>
<a name="ln1234">	if (buffer != NULL)</a>
<a name="ln1235">		fText-&gt;GetString(offset, length, buffer);</a>
<a name="ln1236">}</a>
<a name="ln1237"> </a>
<a name="ln1238"> </a>
<a name="ln1239">uchar</a>
<a name="ln1240">BTextView::ByteAt(int32 offset) const</a>
<a name="ln1241">{</a>
<a name="ln1242">	if (offset &lt; 0 || offset &gt;= fText-&gt;Length())</a>
<a name="ln1243">		return '\0';</a>
<a name="ln1244"> </a>
<a name="ln1245">	return fText-&gt;RealCharAt(offset);</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248"> </a>
<a name="ln1249">int32</a>
<a name="ln1250">BTextView::CountLines() const</a>
<a name="ln1251">{</a>
<a name="ln1252">	return fLines-&gt;NumLines();</a>
<a name="ln1253">}</a>
<a name="ln1254"> </a>
<a name="ln1255"> </a>
<a name="ln1256">int32</a>
<a name="ln1257">BTextView::CurrentLine() const</a>
<a name="ln1258">{</a>
<a name="ln1259">	return LineAt(fSelStart);</a>
<a name="ln1260">}</a>
<a name="ln1261"> </a>
<a name="ln1262"> </a>
<a name="ln1263">void</a>
<a name="ln1264">BTextView::GoToLine(int32 index)</a>
<a name="ln1265">{</a>
<a name="ln1266">	_CancelInputMethod();</a>
<a name="ln1267">	_HideCaret();</a>
<a name="ln1268">	fSelStart = fSelEnd = fCaretOffset = OffsetAt(index);</a>
<a name="ln1269">	_ShowCaret();</a>
<a name="ln1270">}</a>
<a name="ln1271"> </a>
<a name="ln1272"> </a>
<a name="ln1273">void</a>
<a name="ln1274">BTextView::Cut(BClipboard* clipboard)</a>
<a name="ln1275">{</a>
<a name="ln1276">	_CancelInputMethod();</a>
<a name="ln1277">	if (!fEditable)</a>
<a name="ln1278">		return;</a>
<a name="ln1279">	if (fUndo) {</a>
<a name="ln1280">		delete fUndo;</a>
<a name="ln1281">		fUndo = new CutUndoBuffer(this);</a>
<a name="ln1282">	}</a>
<a name="ln1283">	Copy(clipboard);</a>
<a name="ln1284">	Delete();</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287"> </a>
<a name="ln1288">void</a>
<a name="ln1289">BTextView::Copy(BClipboard* clipboard)</a>
<a name="ln1290">{</a>
<a name="ln1291">	_CancelInputMethod();</a>
<a name="ln1292"> </a>
<a name="ln1293">	if (clipboard-&gt;Lock()) {</a>
<a name="ln1294">		clipboard-&gt;Clear();</a>
<a name="ln1295"> </a>
<a name="ln1296">		BMessage* clip = clipboard-&gt;Data();</a>
<a name="ln1297">		if (clip != NULL) {</a>
<a name="ln1298">			int32 numBytes = fSelEnd - fSelStart;</a>
<a name="ln1299">			const char* text = fText-&gt;GetString(fSelStart, &amp;numBytes);</a>
<a name="ln1300">			clip-&gt;AddData(&quot;text/plain&quot;, B_MIME_TYPE, text, numBytes);</a>
<a name="ln1301"> </a>
<a name="ln1302">			int32 size;</a>
<a name="ln1303">			if (fStylable) {</a>
<a name="ln1304">				text_run_array* runArray = RunArray(fSelStart, fSelEnd, &amp;size);</a>
<a name="ln1305">				clip-&gt;AddData(&quot;application/x-vnd.Be-text_run_array&quot;,</a>
<a name="ln1306">					B_MIME_TYPE, runArray, size);</a>
<a name="ln1307">				FreeRunArray(runArray);</a>
<a name="ln1308">			}</a>
<a name="ln1309">			clipboard-&gt;Commit();</a>
<a name="ln1310">		}</a>
<a name="ln1311">		clipboard-&gt;Unlock();</a>
<a name="ln1312">	}</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315"> </a>
<a name="ln1316">void</a>
<a name="ln1317">BTextView::Paste(BClipboard* clipboard)</a>
<a name="ln1318">{</a>
<a name="ln1319">	CALLED();</a>
<a name="ln1320">	_CancelInputMethod();</a>
<a name="ln1321"> </a>
<a name="ln1322">	if (!fEditable || !clipboard-&gt;Lock())</a>
<a name="ln1323">		return;</a>
<a name="ln1324"> </a>
<a name="ln1325">	BMessage* clip = clipboard-&gt;Data();</a>
<a name="ln1326">	if (clip != NULL) {</a>
<a name="ln1327">		const char* text = NULL;</a>
<a name="ln1328">		ssize_t length = 0;</a>
<a name="ln1329"> </a>
<a name="ln1330">		if (clip-&gt;FindData(&quot;text/plain&quot;, B_MIME_TYPE,</a>
<a name="ln1331">				(const void**)&amp;text, &amp;length) == B_OK) {</a>
<a name="ln1332">			text_run_array* runArray = NULL;</a>
<a name="ln1333">			ssize_t runLength = 0;</a>
<a name="ln1334"> </a>
<a name="ln1335">			if (fStylable) {</a>
<a name="ln1336">				clip-&gt;FindData(&quot;application/x-vnd.Be-text_run_array&quot;,</a>
<a name="ln1337">					B_MIME_TYPE, (const void**)&amp;runArray, &amp;runLength);</a>
<a name="ln1338">			}</a>
<a name="ln1339"> </a>
<a name="ln1340">			_FilterDisallowedChars((char*)text, length, runArray);</a>
<a name="ln1341"> </a>
<a name="ln1342">			if (length &lt; 1) {</a>
<a name="ln1343">				beep();</a>
<a name="ln1344">				clipboard-&gt;Unlock();</a>
<a name="ln1345">				return;</a>
<a name="ln1346">			}</a>
<a name="ln1347"> </a>
<a name="ln1348">			if (fUndo) {</a>
<a name="ln1349">				delete fUndo;</a>
<a name="ln1350">				fUndo = new PasteUndoBuffer(this, text, length, runArray,</a>
<a name="ln1351">					runLength);</a>
<a name="ln1352">			}</a>
<a name="ln1353"> </a>
<a name="ln1354">			if (fSelStart != fSelEnd)</a>
<a name="ln1355">				Delete();</a>
<a name="ln1356"> </a>
<a name="ln1357">			Insert(text, length, runArray);</a>
<a name="ln1358">			ScrollToOffset(fSelEnd);</a>
<a name="ln1359">		}</a>
<a name="ln1360">	}</a>
<a name="ln1361"> </a>
<a name="ln1362">	clipboard-&gt;Unlock();</a>
<a name="ln1363">}</a>
<a name="ln1364"> </a>
<a name="ln1365"> </a>
<a name="ln1366">void</a>
<a name="ln1367">BTextView::Clear()</a>
<a name="ln1368">{</a>
<a name="ln1369">	// We always check for fUndo != NULL (not only here),</a>
<a name="ln1370">	// because when fUndo is NULL, undo is deactivated.</a>
<a name="ln1371">	if (fUndo) {</a>
<a name="ln1372">		delete fUndo;</a>
<a name="ln1373">		fUndo = new ClearUndoBuffer(this);</a>
<a name="ln1374">	}</a>
<a name="ln1375"> </a>
<a name="ln1376">	Delete();</a>
<a name="ln1377">}</a>
<a name="ln1378"> </a>
<a name="ln1379"> </a>
<a name="ln1380">bool</a>
<a name="ln1381">BTextView::AcceptsPaste(BClipboard* clipboard)</a>
<a name="ln1382">{</a>
<a name="ln1383">	bool result = false;</a>
<a name="ln1384"> </a>
<a name="ln1385">	if (fEditable &amp;&amp; clipboard &amp;&amp; clipboard-&gt;Lock()) {</a>
<a name="ln1386">		BMessage* data = clipboard-&gt;Data();</a>
<a name="ln1387">		result = data &amp;&amp; data-&gt;HasData(&quot;text/plain&quot;, B_MIME_TYPE);</a>
<a name="ln1388">		clipboard-&gt;Unlock();</a>
<a name="ln1389">	}</a>
<a name="ln1390"> </a>
<a name="ln1391">	return result;</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394"> </a>
<a name="ln1395">bool</a>
<a name="ln1396">BTextView::AcceptsDrop(const BMessage* message)</a>
<a name="ln1397">{</a>
<a name="ln1398">	return fEditable &amp;&amp; message</a>
<a name="ln1399">		&amp;&amp; message-&gt;HasData(&quot;text/plain&quot;, B_MIME_TYPE);</a>
<a name="ln1400">}</a>
<a name="ln1401"> </a>
<a name="ln1402"> </a>
<a name="ln1403">void</a>
<a name="ln1404">BTextView::Select(int32 startOffset, int32 endOffset)</a>
<a name="ln1405">{</a>
<a name="ln1406">	CALLED();</a>
<a name="ln1407">	if (!fSelectable)</a>
<a name="ln1408">		return;</a>
<a name="ln1409"> </a>
<a name="ln1410">	_CancelInputMethod();</a>
<a name="ln1411"> </a>
<a name="ln1412">	// pin offsets at reasonable values</a>
<a name="ln1413">	if (startOffset &lt; 0)</a>
<a name="ln1414">		startOffset = 0;</a>
<a name="ln1415">	else if (startOffset &gt; fText-&gt;Length())</a>
<a name="ln1416">		startOffset = fText-&gt;Length();</a>
<a name="ln1417">	if (endOffset &lt; 0)</a>
<a name="ln1418">		endOffset = 0;</a>
<a name="ln1419">	else if (endOffset &gt; fText-&gt;Length())</a>
<a name="ln1420">		endOffset = fText-&gt;Length();</a>
<a name="ln1421"> </a>
<a name="ln1422">	// a negative selection?</a>
<a name="ln1423">	if (startOffset &gt; endOffset)</a>
<a name="ln1424">		return;</a>
<a name="ln1425"> </a>
<a name="ln1426">	// is the new selection any different from the current selection?</a>
<a name="ln1427">	if (startOffset == fSelStart &amp;&amp; endOffset == fSelEnd)</a>
<a name="ln1428">		return;</a>
<a name="ln1429"> </a>
<a name="ln1430">	fStyles-&gt;InvalidateNullStyle();</a>
<a name="ln1431"> </a>
<a name="ln1432">	_HideCaret();</a>
<a name="ln1433"> </a>
<a name="ln1434">	if (startOffset == endOffset) {</a>
<a name="ln1435">		if (fSelStart != fSelEnd) {</a>
<a name="ln1436">			// unhilite the selection</a>
<a name="ln1437">			if (fActive)</a>
<a name="ln1438">				Highlight(fSelStart, fSelEnd);</a>
<a name="ln1439">		}</a>
<a name="ln1440">		fSelStart = fSelEnd = fCaretOffset = startOffset;</a>
<a name="ln1441">		_ShowCaret();</a>
<a name="ln1442">	} else {</a>
<a name="ln1443">		if (fActive) {</a>
<a name="ln1444">			// draw only those ranges that are different</a>
<a name="ln1445">			long start, end;</a>
<a name="ln1446">			if (startOffset != fSelStart) {</a>
<a name="ln1447">				// start of selection has changed</a>
<a name="ln1448">				if (startOffset &gt; fSelStart) {</a>
<a name="ln1449">					start = fSelStart;</a>
<a name="ln1450">					end = startOffset;</a>
<a name="ln1451">				} else {</a>
<a name="ln1452">					start = startOffset;</a>
<a name="ln1453">					end = fSelStart;</a>
<a name="ln1454">				}</a>
<a name="ln1455">				Highlight(start, end);</a>
<a name="ln1456">			}</a>
<a name="ln1457"> </a>
<a name="ln1458">			if (endOffset != fSelEnd) {</a>
<a name="ln1459">				// end of selection has changed</a>
<a name="ln1460">				if (endOffset &gt; fSelEnd) {</a>
<a name="ln1461">					start = fSelEnd;</a>
<a name="ln1462">					end = endOffset;</a>
<a name="ln1463">				} else {</a>
<a name="ln1464">					start = endOffset;</a>
<a name="ln1465">					end = fSelEnd;</a>
<a name="ln1466">				}</a>
<a name="ln1467">				Highlight(start, end);</a>
<a name="ln1468">			}</a>
<a name="ln1469">		}</a>
<a name="ln1470">		fSelStart = startOffset;</a>
<a name="ln1471">		fSelEnd = endOffset;</a>
<a name="ln1472">	}</a>
<a name="ln1473">}</a>
<a name="ln1474"> </a>
<a name="ln1475"> </a>
<a name="ln1476">void</a>
<a name="ln1477">BTextView::SelectAll()</a>
<a name="ln1478">{</a>
<a name="ln1479">	Select(0, fText-&gt;Length());</a>
<a name="ln1480">}</a>
<a name="ln1481"> </a>
<a name="ln1482"> </a>
<a name="ln1483">void</a>
<a name="ln1484">BTextView::GetSelection(int32* _start, int32* _end) const</a>
<a name="ln1485">{</a>
<a name="ln1486">	int32 start = 0;</a>
<a name="ln1487">	int32 end = 0;</a>
<a name="ln1488"> </a>
<a name="ln1489">	if (fSelectable) {</a>
<a name="ln1490">		start = fSelStart;</a>
<a name="ln1491">		end = fSelEnd;</a>
<a name="ln1492">	}</a>
<a name="ln1493"> </a>
<a name="ln1494">	if (_start)</a>
<a name="ln1495">		*_start = start;</a>
<a name="ln1496"> </a>
<a name="ln1497">	if (_end)</a>
<a name="ln1498">		*_end = end;</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501"> </a>
<a name="ln1502">void</a>
<a name="ln1503">BTextView::SetFontAndColor(const BFont* font, uint32 mode,</a>
<a name="ln1504">	const rgb_color* color)</a>
<a name="ln1505">{</a>
<a name="ln1506">	SetFontAndColor(fSelStart, fSelEnd, font, mode, color);</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509"> </a>
<a name="ln1510">void</a>
<a name="ln1511">BTextView::SetFontAndColor(int32 startOffset, int32 endOffset,</a>
<a name="ln1512">	const BFont* font, uint32 mode, const rgb_color* color)</a>
<a name="ln1513">{</a>
<a name="ln1514">	CALLED();</a>
<a name="ln1515"> </a>
<a name="ln1516">	_HideCaret();</a>
<a name="ln1517"> </a>
<a name="ln1518">	const int32 textLength = fText-&gt;Length();</a>
<a name="ln1519"> </a>
<a name="ln1520">	if (!fStylable) {</a>
<a name="ln1521">		// When the text view is not stylable, we always set the whole text's</a>
<a name="ln1522">		// style and ignore the offsets</a>
<a name="ln1523">		startOffset = 0;</a>
<a name="ln1524">		endOffset = textLength;</a>
<a name="ln1525">	} else {</a>
<a name="ln1526">		// pin offsets at reasonable values</a>
<a name="ln1527">		if (startOffset &lt; 0)</a>
<a name="ln1528">			startOffset = 0;</a>
<a name="ln1529">		else if (startOffset &gt; textLength)</a>
<a name="ln1530">			startOffset = textLength;</a>
<a name="ln1531"> </a>
<a name="ln1532">		if (endOffset &lt; 0)</a>
<a name="ln1533">			endOffset = 0;</a>
<a name="ln1534">		else if (endOffset &gt; textLength)</a>
<a name="ln1535">			endOffset = textLength;</a>
<a name="ln1536">	}</a>
<a name="ln1537"> </a>
<a name="ln1538">	// apply the style to the style buffer</a>
<a name="ln1539">	fStyles-&gt;InvalidateNullStyle();</a>
<a name="ln1540">	_ApplyStyleRange(startOffset, endOffset, mode, font, color);</a>
<a name="ln1541"> </a>
<a name="ln1542">	if ((mode &amp; (B_FONT_FAMILY_AND_STYLE | B_FONT_SIZE)) != 0) {</a>
<a name="ln1543">		// ToDo: maybe only invalidate the layout (depending on</a>
<a name="ln1544">		// B_SUPPORTS_LAYOUT) and have it _Refresh() automatically?</a>
<a name="ln1545">		InvalidateLayout();</a>
<a name="ln1546">		// recalc the line breaks and redraw with new style</a>
<a name="ln1547">		_Refresh(startOffset, endOffset, false);</a>
<a name="ln1548">	} else {</a>
<a name="ln1549">		// the line breaks wont change, simply redraw</a>
<a name="ln1550">		_RequestDrawLines(_LineAt(startOffset), _LineAt(endOffset));</a>
<a name="ln1551">	}</a>
<a name="ln1552"> </a>
<a name="ln1553">	_ShowCaret();</a>
<a name="ln1554">}</a>
<a name="ln1555"> </a>
<a name="ln1556"> </a>
<a name="ln1557">void</a>
<a name="ln1558">BTextView::GetFontAndColor(int32 offset, BFont* _font,</a>
<a name="ln1559">	rgb_color* _color) const</a>
<a name="ln1560">{</a>
<a name="ln1561">	fStyles-&gt;GetStyle(offset, _font, _color);</a>
<a name="ln1562">}</a>
<a name="ln1563"> </a>
<a name="ln1564"> </a>
<a name="ln1565">void</a>
<a name="ln1566">BTextView::GetFontAndColor(BFont* _font, uint32* _mode,</a>
<a name="ln1567">	rgb_color* _color, bool* _sameColor) const</a>
<a name="ln1568">{</a>
<a name="ln1569">	fStyles-&gt;ContinuousGetStyle(_font, _mode, _color, _sameColor,</a>
<a name="ln1570">		fSelStart, fSelEnd);</a>
<a name="ln1571">}</a>
<a name="ln1572"> </a>
<a name="ln1573"> </a>
<a name="ln1574">void</a>
<a name="ln1575">BTextView::SetRunArray(int32 startOffset, int32 endOffset,</a>
<a name="ln1576">	const text_run_array* runs)</a>
<a name="ln1577">{</a>
<a name="ln1578">	CALLED();</a>
<a name="ln1579"> </a>
<a name="ln1580">	_CancelInputMethod();</a>
<a name="ln1581"> </a>
<a name="ln1582">	text_run_array oneRun;</a>
<a name="ln1583"> </a>
<a name="ln1584">	if (!fStylable) {</a>
<a name="ln1585">		// when the text view is not stylable, we always set the whole text's</a>
<a name="ln1586">		// style with the first run and ignore the offsets</a>
<a name="ln1587">		if (runs-&gt;count == 0)</a>
<a name="ln1588">			return;</a>
<a name="ln1589"> </a>
<a name="ln1590">		startOffset = 0;</a>
<a name="ln1591">		endOffset = fText-&gt;Length();</a>
<a name="ln1592">		oneRun.count = 1;</a>
<a name="ln1593">		oneRun.runs[0] = runs-&gt;runs[0];</a>
<a name="ln1594">		oneRun.runs[0].offset = 0;</a>
<a name="ln1595">		runs = &amp;oneRun;</a>
<a name="ln1596">	} else {</a>
<a name="ln1597">		// pin offsets at reasonable values</a>
<a name="ln1598">		if (startOffset &lt; 0)</a>
<a name="ln1599">			startOffset = 0;</a>
<a name="ln1600">		else if (startOffset &gt; fText-&gt;Length())</a>
<a name="ln1601">			startOffset = fText-&gt;Length();</a>
<a name="ln1602"> </a>
<a name="ln1603">		if (endOffset &lt; 0)</a>
<a name="ln1604">			endOffset = 0;</a>
<a name="ln1605">		else if (endOffset &gt; fText-&gt;Length())</a>
<a name="ln1606">			endOffset = fText-&gt;Length();</a>
<a name="ln1607">	}</a>
<a name="ln1608"> </a>
<a name="ln1609">	_SetRunArray(startOffset, endOffset, runs);</a>
<a name="ln1610"> </a>
<a name="ln1611">	_Refresh(startOffset, endOffset, false);</a>
<a name="ln1612">}</a>
<a name="ln1613"> </a>
<a name="ln1614"> </a>
<a name="ln1615">text_run_array*</a>
<a name="ln1616">BTextView::RunArray(int32 startOffset, int32 endOffset, int32* _size) const</a>
<a name="ln1617">{</a>
<a name="ln1618">	// pin offsets at reasonable values</a>
<a name="ln1619">	if (startOffset &lt; 0)</a>
<a name="ln1620">		startOffset = 0;</a>
<a name="ln1621">	else if (startOffset &gt; fText-&gt;Length())</a>
<a name="ln1622">		startOffset = fText-&gt;Length();</a>
<a name="ln1623"> </a>
<a name="ln1624">	if (endOffset &lt; 0)</a>
<a name="ln1625">		endOffset = 0;</a>
<a name="ln1626">	else if (endOffset &gt; fText-&gt;Length())</a>
<a name="ln1627">		endOffset = fText-&gt;Length();</a>
<a name="ln1628"> </a>
<a name="ln1629">	STEStyleRange* styleRange</a>
<a name="ln1630">		= fStyles-&gt;GetStyleRange(startOffset, endOffset - 1);</a>
<a name="ln1631">	if (styleRange == NULL)</a>
<a name="ln1632">		return NULL;</a>
<a name="ln1633"> </a>
<a name="ln1634">	text_run_array* runArray = AllocRunArray(styleRange-&gt;count, _size);</a>
<a name="ln1635">	if (runArray != NULL) {</a>
<a name="ln1636">		for (int32 i = 0; i &lt; runArray-&gt;count; i++) {</a>
<a name="ln1637">			runArray-&gt;runs[i].offset = styleRange-&gt;runs[i].offset;</a>
<a name="ln1638">			runArray-&gt;runs[i].font = styleRange-&gt;runs[i].style.font;</a>
<a name="ln1639">			runArray-&gt;runs[i].color = styleRange-&gt;runs[i].style.color;</a>
<a name="ln1640">		}</a>
<a name="ln1641">	}</a>
<a name="ln1642"> </a>
<a name="ln1643">	free(styleRange);</a>
<a name="ln1644"> </a>
<a name="ln1645">	return runArray;</a>
<a name="ln1646">}</a>
<a name="ln1647"> </a>
<a name="ln1648"> </a>
<a name="ln1649">int32</a>
<a name="ln1650">BTextView::LineAt(int32 offset) const</a>
<a name="ln1651">{</a>
<a name="ln1652">	// pin offset at reasonable values</a>
<a name="ln1653">	if (offset &lt; 0)</a>
<a name="ln1654">		offset = 0;</a>
<a name="ln1655">	else if (offset &gt; fText-&gt;Length())</a>
<a name="ln1656">		offset = fText-&gt;Length();</a>
<a name="ln1657"> </a>
<a name="ln1658">	int32 lineNum = _LineAt(offset);</a>
<a name="ln1659">	if (_IsOnEmptyLastLine(offset))</a>
<a name="ln1660">		lineNum++;</a>
<a name="ln1661">	return lineNum;</a>
<a name="ln1662">}</a>
<a name="ln1663"> </a>
<a name="ln1664"> </a>
<a name="ln1665">int32</a>
<a name="ln1666">BTextView::LineAt(BPoint point) const</a>
<a name="ln1667">{</a>
<a name="ln1668">	int32 lineNum = _LineAt(point);</a>
<a name="ln1669">	if ((*fLines)[lineNum + 1]-&gt;origin &lt;= point.y - fTextRect.top)</a>
<a name="ln1670">		lineNum++;</a>
<a name="ln1671"> </a>
<a name="ln1672">	return lineNum;</a>
<a name="ln1673">}</a>
<a name="ln1674"> </a>
<a name="ln1675"> </a>
<a name="ln1676">BPoint</a>
<a name="ln1677">BTextView::PointAt(int32 offset, float* _height) const</a>
<a name="ln1678">{</a>
<a name="ln1679">	// pin offset at reasonable values</a>
<a name="ln1680">	if (offset &lt; 0)</a>
<a name="ln1681">		offset = 0;</a>
<a name="ln1682">	else if (offset &gt; fText-&gt;Length())</a>
<a name="ln1683">		offset = fText-&gt;Length();</a>
<a name="ln1684"> </a>
<a name="ln1685">	// ToDo: Cleanup.</a>
<a name="ln1686">	int32 lineNum = _LineAt(offset);</a>
<a name="ln1687">	STELine* line = (*fLines)[lineNum];</a>
<a name="ln1688">	float height = 0;</a>
<a name="ln1689"> </a>
<a name="ln1690">	BPoint result;</a>
<a name="ln1691">	result.x = 0.0;</a>
<a name="ln1692">	result.y = line-&gt;origin + fTextRect.top;</a>
<a name="ln1693"> </a>
<a name="ln1694">	bool onEmptyLastLine = _IsOnEmptyLastLine(offset);</a>
<a name="ln1695"> </a>
<a name="ln1696">	if (fStyles-&gt;NumRuns() == 0) {</a>
<a name="ln1697">		// Handle the case where there is only one line (no text inserted)</a>
<a name="ln1698">		fStyles-&gt;SyncNullStyle(0);</a>
<a name="ln1699">		height = _NullStyleHeight();</a>
<a name="ln1700">	} else {</a>
<a name="ln1701">		height = (line + 1)-&gt;origin - line-&gt;origin;</a>
<a name="ln1702"> </a>
<a name="ln1703">		if (onEmptyLastLine) {</a>
<a name="ln1704">			// special case: go down one line if offset is at the newline</a>
<a name="ln1705">			// at the end of the buffer ...</a>
<a name="ln1706">			result.y += height;</a>
<a name="ln1707">			// ... and return the height of that (empty) line</a>
<a name="ln1708">			fStyles-&gt;SyncNullStyle(offset);</a>
<a name="ln1709">			height = _NullStyleHeight();</a>
<a name="ln1710">		} else {</a>
<a name="ln1711">			int32 length = offset - line-&gt;offset;</a>
<a name="ln1712">			result.x += _TabExpandedStyledWidth(line-&gt;offset, length);</a>
<a name="ln1713">		}</a>
<a name="ln1714">	}</a>
<a name="ln1715"> </a>
<a name="ln1716">	if (fAlignment != B_ALIGN_LEFT) {</a>
<a name="ln1717">		float lineWidth = onEmptyLastLine ? 0.0 : LineWidth(lineNum);</a>
<a name="ln1718">		float alignmentOffset = fTextRect.Width() - lineWidth;</a>
<a name="ln1719">		if (fAlignment == B_ALIGN_CENTER)</a>
<a name="ln1720">			alignmentOffset /= 2;</a>
<a name="ln1721">		result.x += alignmentOffset;</a>
<a name="ln1722">	}</a>
<a name="ln1723"> </a>
<a name="ln1724">	// convert from text rect coordinates</a>
<a name="ln1725">	result.x += fTextRect.left;</a>
<a name="ln1726"> </a>
<a name="ln1727">	// round up</a>
<a name="ln1728">	result.x = lroundf(result.x);</a>
<a name="ln1729">	result.y = lroundf(result.y);</a>
<a name="ln1730">	if (_height != NULL)</a>
<a name="ln1731">		*_height = height;</a>
<a name="ln1732"> </a>
<a name="ln1733">	return result;</a>
<a name="ln1734">}</a>
<a name="ln1735"> </a>
<a name="ln1736"> </a>
<a name="ln1737">int32</a>
<a name="ln1738">BTextView::OffsetAt(BPoint point) const</a>
<a name="ln1739">{</a>
<a name="ln1740">	const int32 textLength = fText-&gt;Length();</a>
<a name="ln1741"> </a>
<a name="ln1742">	// should we even bother?</a>
<a name="ln1743">	if (point.y &gt;= fTextRect.bottom)</a>
<a name="ln1744">		return textLength;</a>
<a name="ln1745">	else if (point.y &lt; fTextRect.top)</a>
<a name="ln1746">		return 0;</a>
<a name="ln1747"> </a>
<a name="ln1748">	int32 lineNum = _LineAt(point);</a>
<a name="ln1749">	STELine* line = (*fLines)[lineNum];</a>
<a name="ln1750"> </a>
<a name="ln1751">#define COMPILE_PROBABLY_BAD_CODE 1</a>
<a name="ln1752"> </a>
<a name="ln1753">#if COMPILE_PROBABLY_BAD_CODE</a>
<a name="ln1754">	// special case: if point is within the text rect and PixelToLine()</a>
<a name="ln1755">	// tells us that it's on the last line, but if point is actually</a>
<a name="ln1756">	// lower than the bottom of the last line, return the last offset</a>
<a name="ln1757">	// (can happen for newlines)</a>
<a name="ln1758">	if (lineNum == (fLines-&gt;NumLines() - 1)) {</a>
<a name="ln1759">		if (point.y &gt;= ((line + 1)-&gt;origin + fTextRect.top))</a>
<a name="ln1760">			return textLength;</a>
<a name="ln1761">	}</a>
<a name="ln1762">#endif</a>
<a name="ln1763"> </a>
<a name="ln1764">	// convert to text rect coordinates</a>
<a name="ln1765">	if (fAlignment != B_ALIGN_LEFT) {</a>
<a name="ln1766">		float alignmentOffset = fTextRect.Width() - LineWidth(lineNum);</a>
<a name="ln1767">		if (fAlignment == B_ALIGN_CENTER)</a>
<a name="ln1768">			alignmentOffset /= 2;</a>
<a name="ln1769">		point.x -= alignmentOffset;</a>
<a name="ln1770">	}</a>
<a name="ln1771"> </a>
<a name="ln1772">	point.x -= fTextRect.left;</a>
<a name="ln1773">	point.x = max_c(point.x, 0.0);</a>
<a name="ln1774"> </a>
<a name="ln1775">	// ToDo: The following code isn't very efficient, because it always starts</a>
<a name="ln1776">	// from the left end, so when the point is near the right end it's very</a>
<a name="ln1777">	// slow.</a>
<a name="ln1778">	int32 offset = line-&gt;offset;</a>
<a name="ln1779">	const int32 limit = (line + 1)-&gt;offset;</a>
<a name="ln1780">	float location = 0;</a>
<a name="ln1781">	do {</a>
<a name="ln1782">		const int32 nextInitial = _NextInitialByte(offset);</a>
<a name="ln1783">		const int32 saveOffset = offset;</a>
<a name="ln1784">		float width = 0;</a>
<a name="ln1785">		if (ByteAt(offset) == B_TAB)</a>
<a name="ln1786">			width = _ActualTabWidth(location);</a>
<a name="ln1787">		else</a>
<a name="ln1788">			width = _StyledWidth(saveOffset, nextInitial - saveOffset);</a>
<a name="ln1789">		if (location + width &gt; point.x) {</a>
<a name="ln1790">			if (fabs(location + width - point.x) &lt; fabs(location - point.x))</a>
<a name="ln1791">				offset = nextInitial;</a>
<a name="ln1792">			break;</a>
<a name="ln1793">		}</a>
<a name="ln1794"> </a>
<a name="ln1795">		location += width;</a>
<a name="ln1796">		offset = nextInitial;</a>
<a name="ln1797">	} while (offset &lt; limit);</a>
<a name="ln1798"> </a>
<a name="ln1799">	if (offset == (line + 1)-&gt;offset) {</a>
<a name="ln1800">		// special case: newlines aren't visible</a>
<a name="ln1801">		// return the offset of the character preceding the newline</a>
<a name="ln1802">		if (ByteAt(offset - 1) == B_ENTER)</a>
<a name="ln1803">			return --offset;</a>
<a name="ln1804"> </a>
<a name="ln1805">		// special case: return the offset preceding any spaces that</a>
<a name="ln1806">		// aren't at the end of the buffer</a>
<a name="ln1807">		if (offset != textLength &amp;&amp; ByteAt(offset - 1) == B_SPACE)</a>
<a name="ln1808">			return --offset;</a>
<a name="ln1809">	}</a>
<a name="ln1810"> </a>
<a name="ln1811">	return offset;</a>
<a name="ln1812">}</a>
<a name="ln1813"> </a>
<a name="ln1814"> </a>
<a name="ln1815">int32</a>
<a name="ln1816">BTextView::OffsetAt(int32 line) const</a>
<a name="ln1817">{</a>
<a name="ln1818">	if (line &lt; 0)</a>
<a name="ln1819">		return 0;</a>
<a name="ln1820"> </a>
<a name="ln1821">	if (line &gt; fLines-&gt;NumLines())</a>
<a name="ln1822">		return fText-&gt;Length();</a>
<a name="ln1823"> </a>
<a name="ln1824">	return (*fLines)[line]-&gt;offset;</a>
<a name="ln1825">}</a>
<a name="ln1826"> </a>
<a name="ln1827"> </a>
<a name="ln1828">void</a>
<a name="ln1829">BTextView::FindWord(int32 offset, int32* _fromOffset, int32* _toOffset)</a>
<a name="ln1830">{</a>
<a name="ln1831">	if (offset &lt; 0) {</a>
<a name="ln1832">		if (_fromOffset)</a>
<a name="ln1833">			*_fromOffset = 0;</a>
<a name="ln1834"> </a>
<a name="ln1835">		if (_toOffset)</a>
<a name="ln1836">			*_toOffset = 0;</a>
<a name="ln1837"> </a>
<a name="ln1838">		return;</a>
<a name="ln1839">	}</a>
<a name="ln1840"> </a>
<a name="ln1841">	if (offset &gt; fText-&gt;Length()) {</a>
<a name="ln1842">		if (_fromOffset)</a>
<a name="ln1843">			*_fromOffset = fText-&gt;Length();</a>
<a name="ln1844"> </a>
<a name="ln1845">		if (_toOffset)</a>
<a name="ln1846">			*_toOffset = fText-&gt;Length();</a>
<a name="ln1847"> </a>
<a name="ln1848">		return;</a>
<a name="ln1849">	}</a>
<a name="ln1850"> </a>
<a name="ln1851">	if (_fromOffset)</a>
<a name="ln1852">		*_fromOffset = _PreviousWordBoundary(offset);</a>
<a name="ln1853"> </a>
<a name="ln1854">	if (_toOffset)</a>
<a name="ln1855">		*_toOffset = _NextWordBoundary(offset);</a>
<a name="ln1856">}</a>
<a name="ln1857"> </a>
<a name="ln1858"> </a>
<a name="ln1859">bool</a>
<a name="ln1860">BTextView::CanEndLine(int32 offset)</a>
<a name="ln1861">{</a>
<a name="ln1862">	if (offset &lt; 0 || offset &gt; fText-&gt;Length())</a>
<a name="ln1863">		return false;</a>
<a name="ln1864"> </a>
<a name="ln1865">	// TODO: This should be improved using the LocaleKit.</a>
<a name="ln1866">	uint32 classification = _CharClassification(offset);</a>
<a name="ln1867"> </a>
<a name="ln1868">	// wrapping is always allowed at end of text and at newlines</a>
<a name="ln1869">	if (classification == CHAR_CLASS_END_OF_TEXT || ByteAt(offset) == B_ENTER)</a>
<a name="ln1870">		return true;</a>
<a name="ln1871"> </a>
<a name="ln1872">	uint32 nextClassification = _CharClassification(offset + 1);</a>
<a name="ln1873">	if (nextClassification == CHAR_CLASS_END_OF_TEXT)</a>
<a name="ln1874">		return true;</a>
<a name="ln1875"> </a>
<a name="ln1876">	// never separate a punctuation char from its preceeding word</a>
<a name="ln1877">	if (classification == CHAR_CLASS_DEFAULT</a>
<a name="ln1878">		&amp;&amp; nextClassification == CHAR_CLASS_PUNCTUATION) {</a>
<a name="ln1879">		return false;</a>
<a name="ln1880">	}</a>
<a name="ln1881"> </a>
<a name="ln1882">	if ((classification == CHAR_CLASS_WHITESPACE</a>
<a name="ln1883">			&amp;&amp; nextClassification != CHAR_CLASS_WHITESPACE)</a>
<a name="ln1884">		|| (classification != CHAR_CLASS_WHITESPACE</a>
<a name="ln1885">			&amp;&amp; nextClassification == CHAR_CLASS_WHITESPACE)) {</a>
<a name="ln1886">		return true;</a>
<a name="ln1887">	}</a>
<a name="ln1888"> </a>
<a name="ln1889">	// allow wrapping after whitespace, unless more whitespace (except for</a>
<a name="ln1890">	// newline) follows</a>
<a name="ln1891">	if (classification == CHAR_CLASS_WHITESPACE</a>
<a name="ln1892">		&amp;&amp; (nextClassification != CHAR_CLASS_WHITESPACE</a>
<a name="ln1893">			|| ByteAt(offset + 1) == B_ENTER)) {</a>
<a name="ln1894">		return true;</a>
<a name="ln1895">	}</a>
<a name="ln1896"> </a>
<a name="ln1897">	// allow wrapping after punctuation chars, unless more punctuation, closing</a>
<a name="ln1898">	// parens or quotes follow</a>
<a name="ln1899">	if (classification == CHAR_CLASS_PUNCTUATION</a>
<a name="ln1900">		&amp;&amp; nextClassification != CHAR_CLASS_PUNCTUATION</a>
<a name="ln1901">		&amp;&amp; nextClassification != CHAR_CLASS_PARENS_CLOSE</a>
<a name="ln1902">		&amp;&amp; nextClassification != CHAR_CLASS_QUOTE) {</a>
<a name="ln1903">		return true;</a>
<a name="ln1904">	}</a>
<a name="ln1905"> </a>
<a name="ln1906">	// allow wrapping after quotes, graphical chars and closing parens only if</a>
<a name="ln1907">	// whitespace follows (not perfect, but seems to do the right thing most</a>
<a name="ln1908">	// of the time)</a>
<a name="ln1909">	if ((classification == CHAR_CLASS_QUOTE</a>
<a name="ln1910">			|| classification == CHAR_CLASS_GRAPHICAL</a>
<a name="ln1911">			|| classification == CHAR_CLASS_PARENS_CLOSE)</a>
<a name="ln1912">		&amp;&amp; nextClassification == CHAR_CLASS_WHITESPACE) {</a>
<a name="ln1913">		return true;</a>
<a name="ln1914">	}</a>
<a name="ln1915"> </a>
<a name="ln1916">	return false;</a>
<a name="ln1917">}</a>
<a name="ln1918"> </a>
<a name="ln1919"> </a>
<a name="ln1920">float</a>
<a name="ln1921">BTextView::LineWidth(int32 lineNumber) const</a>
<a name="ln1922">{</a>
<a name="ln1923">	if (lineNumber &lt; 0 || lineNumber &gt;= fLines-&gt;NumLines())</a>
<a name="ln1924">		return 0;</a>
<a name="ln1925"> </a>
<a name="ln1926">	STELine* line = (*fLines)[lineNumber];</a>
<a name="ln1927">	int32 length = (line + 1)-&gt;offset - line-&gt;offset;</a>
<a name="ln1928"> </a>
<a name="ln1929">	// skip newline at the end of the line, if any, as it does no contribute</a>
<a name="ln1930">	// to the width</a>
<a name="ln1931">	if (ByteAt((line + 1)-&gt;offset - 1) == B_ENTER)</a>
<a name="ln1932">		length--;</a>
<a name="ln1933"> </a>
<a name="ln1934">	return _TabExpandedStyledWidth(line-&gt;offset, length);</a>
<a name="ln1935">}</a>
<a name="ln1936"> </a>
<a name="ln1937"> </a>
<a name="ln1938">float</a>
<a name="ln1939">BTextView::LineHeight(int32 lineNumber) const</a>
<a name="ln1940">{</a>
<a name="ln1941">	float lineHeight = TextHeight(lineNumber, lineNumber);</a>
<a name="ln1942">	if (lineHeight == 0.0) {</a>
<a name="ln1943">		// We probably don't have text content yet. Take the initial</a>
<a name="ln1944">		// style's font height or fall back to the plain font.</a>
<a name="ln1945">		const BFont* font;</a>
<a name="ln1946">		fStyles-&gt;GetNullStyle(&amp;font, NULL);</a>
<a name="ln1947">		if (font == NULL)</a>
<a name="ln1948">			font = be_plain_font;</a>
<a name="ln1949"> </a>
<a name="ln1950">		font_height fontHeight;</a>
<a name="ln1951">		font-&gt;GetHeight(&amp;fontHeight);</a>
<a name="ln1952">		// This is how the height is calculated in _RecalculateLineBreaks().</a>
<a name="ln1953">		lineHeight = ceilf(fontHeight.ascent + fontHeight.descent) + 1;</a>
<a name="ln1954">	}</a>
<a name="ln1955"> </a>
<a name="ln1956">	return lineHeight;</a>
<a name="ln1957">}</a>
<a name="ln1958"> </a>
<a name="ln1959"> </a>
<a name="ln1960">float</a>
<a name="ln1961">BTextView::TextHeight(int32 startLine, int32 endLine) const</a>
<a name="ln1962">{</a>
<a name="ln1963">	const int32 numLines = fLines-&gt;NumLines();</a>
<a name="ln1964">	if (startLine &lt; 0)</a>
<a name="ln1965">		startLine = 0;</a>
<a name="ln1966">	else if (startLine &gt; numLines - 1)</a>
<a name="ln1967">		startLine = numLines - 1;</a>
<a name="ln1968"> </a>
<a name="ln1969">	if (endLine &lt; 0)</a>
<a name="ln1970">		endLine = 0;</a>
<a name="ln1971">	else if (endLine &gt; numLines - 1)</a>
<a name="ln1972">		endLine = numLines - 1;</a>
<a name="ln1973"> </a>
<a name="ln1974">	float height = (*fLines)[endLine + 1]-&gt;origin</a>
<a name="ln1975">		- (*fLines)[startLine]-&gt;origin;</a>
<a name="ln1976"> </a>
<a name="ln1977">	if (startLine != endLine &amp;&amp; endLine == numLines - 1</a>
<a name="ln1978">		&amp;&amp; fText-&gt;RealCharAt(fText-&gt;Length() - 1) == B_ENTER) {</a>
<a name="ln1979">		height += (*fLines)[endLine + 1]-&gt;origin - (*fLines)[endLine]-&gt;origin;</a>
<a name="ln1980">	}</a>
<a name="ln1981"> </a>
<a name="ln1982">	return ceilf(height);</a>
<a name="ln1983">}</a>
<a name="ln1984"> </a>
<a name="ln1985"> </a>
<a name="ln1986">void</a>
<a name="ln1987">BTextView::GetTextRegion(int32 startOffset, int32 endOffset,</a>
<a name="ln1988">	BRegion* outRegion) const</a>
<a name="ln1989">{</a>
<a name="ln1990">	if (!outRegion)</a>
<a name="ln1991">		return;</a>
<a name="ln1992"> </a>
<a name="ln1993">	outRegion-&gt;MakeEmpty();</a>
<a name="ln1994"> </a>
<a name="ln1995">	// pin offsets at reasonable values</a>
<a name="ln1996">	if (startOffset &lt; 0)</a>
<a name="ln1997">		startOffset = 0;</a>
<a name="ln1998">	else if (startOffset &gt; fText-&gt;Length())</a>
<a name="ln1999">		startOffset = fText-&gt;Length();</a>
<a name="ln2000">	if (endOffset &lt; 0)</a>
<a name="ln2001">		endOffset = 0;</a>
<a name="ln2002">	else if (endOffset &gt; fText-&gt;Length())</a>
<a name="ln2003">		endOffset = fText-&gt;Length();</a>
<a name="ln2004"> </a>
<a name="ln2005">	// return an empty region if the range is invalid</a>
<a name="ln2006">	if (startOffset &gt;= endOffset)</a>
<a name="ln2007">		return;</a>
<a name="ln2008"> </a>
<a name="ln2009">	float startLineHeight = 0.0;</a>
<a name="ln2010">	float endLineHeight = 0.0;</a>
<a name="ln2011">	BPoint startPt = PointAt(startOffset, &amp;startLineHeight);</a>
<a name="ln2012">	BPoint endPt = PointAt(endOffset, &amp;endLineHeight);</a>
<a name="ln2013"> </a>
<a name="ln2014">	startLineHeight = ceilf(startLineHeight);</a>
<a name="ln2015">	endLineHeight = ceilf(endLineHeight);</a>
<a name="ln2016"> </a>
<a name="ln2017">	BRect selRect;</a>
<a name="ln2018"> </a>
<a name="ln2019">	if (startPt.y == endPt.y) {</a>
<a name="ln2020">		// this is a one-line region</a>
<a name="ln2021">		selRect.left = max_c(startPt.x, fTextRect.left);</a>
<a name="ln2022">		selRect.top = startPt.y;</a>
<a name="ln2023">		selRect.right = endPt.x - 1.0;</a>
<a name="ln2024">		selRect.bottom = endPt.y + endLineHeight - 1.0;</a>
<a name="ln2025">		outRegion-&gt;Include(selRect);</a>
<a name="ln2026">	} else {</a>
<a name="ln2027">		// more than one line in the specified offset range</a>
<a name="ln2028">		selRect.left = max_c(startPt.x, fTextRect.left);</a>
<a name="ln2029">		selRect.top = startPt.y;</a>
<a name="ln2030">		selRect.right = fTextRect.right;</a>
<a name="ln2031">		selRect.bottom = startPt.y + startLineHeight - 1.0;</a>
<a name="ln2032">		outRegion-&gt;Include(selRect);</a>
<a name="ln2033"> </a>
<a name="ln2034">		if (startPt.y + startLineHeight &lt; endPt.y) {</a>
<a name="ln2035">			// more than two lines in the range</a>
<a name="ln2036">			selRect.left = fTextRect.left;</a>
<a name="ln2037">			selRect.top = startPt.y + startLineHeight;</a>
<a name="ln2038">			selRect.right = fTextRect.right;</a>
<a name="ln2039">			selRect.bottom = endPt.y - 1.0;</a>
<a name="ln2040">			outRegion-&gt;Include(selRect);</a>
<a name="ln2041">		}</a>
<a name="ln2042"> </a>
<a name="ln2043">		selRect.left = fTextRect.left;</a>
<a name="ln2044">		selRect.top = endPt.y;</a>
<a name="ln2045">		selRect.right = endPt.x - 1.0;</a>
<a name="ln2046">		selRect.bottom = endPt.y + endLineHeight - 1.0;</a>
<a name="ln2047">		outRegion-&gt;Include(selRect);</a>
<a name="ln2048">	}</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051"> </a>
<a name="ln2052">void</a>
<a name="ln2053">BTextView::ScrollToOffset(int32 offset)</a>
<a name="ln2054">{</a>
<a name="ln2055">	BRect bounds = Bounds();</a>
<a name="ln2056">	float lineHeight = 0.0;</a>
<a name="ln2057">	float xDiff = 0.0;</a>
<a name="ln2058">	float yDiff = 0.0;</a>
<a name="ln2059">	BPoint point = PointAt(offset, &amp;lineHeight);</a>
<a name="ln2060"> </a>
<a name="ln2061">	// horizontal</a>
<a name="ln2062">	float extraSpace = fAlignment == B_ALIGN_LEFT ?</a>
<a name="ln2063">		ceilf(bounds.IntegerWidth() / 2) : 0.0;</a>
<a name="ln2064"> </a>
<a name="ln2065">	if (point.x &lt; bounds.left)</a>
<a name="ln2066">		xDiff = point.x - bounds.left - extraSpace;</a>
<a name="ln2067">	else if (point.x &gt; bounds.right)</a>
<a name="ln2068">		xDiff = point.x - bounds.right + extraSpace;</a>
<a name="ln2069"> </a>
<a name="ln2070">	// vertical</a>
<a name="ln2071">	if (point.y &lt; bounds.top)</a>
<a name="ln2072">		yDiff = point.y - bounds.top;</a>
<a name="ln2073">	else if (point.y + lineHeight &gt; bounds.bottom</a>
<a name="ln2074">		&amp;&amp; point.y - lineHeight &gt; bounds.top) {</a>
<a name="ln2075">		yDiff = point.y + lineHeight - bounds.bottom;</a>
<a name="ln2076">	}</a>
<a name="ln2077"> </a>
<a name="ln2078">	// prevent negative scroll offset</a>
<a name="ln2079">	if (bounds.left + xDiff &lt; 0.0)</a>
<a name="ln2080">		xDiff = -bounds.left;</a>
<a name="ln2081">	if (bounds.top + yDiff &lt; 0.0)</a>
<a name="ln2082">		yDiff = -bounds.top;</a>
<a name="ln2083"> </a>
<a name="ln2084">	ScrollBy(xDiff, yDiff);</a>
<a name="ln2085">}</a>
<a name="ln2086"> </a>
<a name="ln2087"> </a>
<a name="ln2088">void</a>
<a name="ln2089">BTextView::ScrollToSelection()</a>
<a name="ln2090">{</a>
<a name="ln2091">	ScrollToOffset(fSelStart);</a>
<a name="ln2092">}</a>
<a name="ln2093"> </a>
<a name="ln2094"> </a>
<a name="ln2095">void</a>
<a name="ln2096">BTextView::Highlight(int32 startOffset, int32 endOffset)</a>
<a name="ln2097">{</a>
<a name="ln2098">	// pin offsets at reasonable values</a>
<a name="ln2099">	if (startOffset &lt; 0)</a>
<a name="ln2100">		startOffset = 0;</a>
<a name="ln2101">	else if (startOffset &gt; fText-&gt;Length())</a>
<a name="ln2102">		startOffset = fText-&gt;Length();</a>
<a name="ln2103">	if (endOffset &lt; 0)</a>
<a name="ln2104">		endOffset = 0;</a>
<a name="ln2105">	else if (endOffset &gt; fText-&gt;Length())</a>
<a name="ln2106">		endOffset = fText-&gt;Length();</a>
<a name="ln2107"> </a>
<a name="ln2108">	if (startOffset &gt;= endOffset)</a>
<a name="ln2109">		return;</a>
<a name="ln2110"> </a>
<a name="ln2111">	BRegion selRegion;</a>
<a name="ln2112">	GetTextRegion(startOffset, endOffset, &amp;selRegion);</a>
<a name="ln2113"> </a>
<a name="ln2114">	SetDrawingMode(B_OP_INVERT);</a>
<a name="ln2115">	FillRegion(&amp;selRegion, B_SOLID_HIGH);</a>
<a name="ln2116">	SetDrawingMode(B_OP_COPY);</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119"> </a>
<a name="ln2120">// #pragma mark - Configuration methods</a>
<a name="ln2121"> </a>
<a name="ln2122"> </a>
<a name="ln2123">void</a>
<a name="ln2124">BTextView::SetTextRect(BRect rect)</a>
<a name="ln2125">{</a>
<a name="ln2126">	if (rect == fTextRect)</a>
<a name="ln2127">		return;</a>
<a name="ln2128"> </a>
<a name="ln2129">	if (!fWrap) {</a>
<a name="ln2130">		rect.right = Bounds().right - fLayoutData-&gt;rightInset;</a>
<a name="ln2131">		rect.bottom = Bounds().bottom - fLayoutData-&gt;bottomInset;</a>
<a name="ln2132">	}</a>
<a name="ln2133"> </a>
<a name="ln2134">	fLayoutData-&gt;UpdateInsets(Bounds().OffsetToCopy(B_ORIGIN), rect);</a>
<a name="ln2135"> </a>
<a name="ln2136">	_ResetTextRect();</a>
<a name="ln2137">}</a>
<a name="ln2138"> </a>
<a name="ln2139"> </a>
<a name="ln2140">BRect</a>
<a name="ln2141">BTextView::TextRect() const</a>
<a name="ln2142">{</a>
<a name="ln2143">	return fTextRect;</a>
<a name="ln2144">}</a>
<a name="ln2145"> </a>
<a name="ln2146"> </a>
<a name="ln2147">void</a>
<a name="ln2148">BTextView::_ResetTextRect()</a>
<a name="ln2149">{</a>
<a name="ln2150">	BRect oldTextRect(fTextRect);</a>
<a name="ln2151">	// reset text rect to bounds minus insets ...</a>
<a name="ln2152">	fTextRect = Bounds().OffsetToCopy(B_ORIGIN);</a>
<a name="ln2153">	fTextRect.left += fLayoutData-&gt;leftInset;</a>
<a name="ln2154">	fTextRect.top += fLayoutData-&gt;topInset;</a>
<a name="ln2155">	fTextRect.right -= fLayoutData-&gt;rightInset;</a>
<a name="ln2156">	fTextRect.bottom -= fLayoutData-&gt;bottomInset;</a>
<a name="ln2157"> </a>
<a name="ln2158">	// and rewrap (potentially adjusting the right and the bottom of the text</a>
<a name="ln2159">	// rect)</a>
<a name="ln2160">	_Refresh(0, TextLength(), false);</a>
<a name="ln2161"> </a>
<a name="ln2162">	// Make sure that the dirty area outside the text is redrawn too.</a>
<a name="ln2163">	BRegion invalid(oldTextRect | fTextRect);</a>
<a name="ln2164">	invalid.Exclude(fTextRect);</a>
<a name="ln2165">	Invalidate(&amp;invalid);</a>
<a name="ln2166">}</a>
<a name="ln2167"> </a>
<a name="ln2168"> </a>
<a name="ln2169">void</a>
<a name="ln2170">BTextView::SetInsets(float left, float top, float right, float bottom)</a>
<a name="ln2171">{</a>
<a name="ln2172">	if (fLayoutData-&gt;leftInset == left</a>
<a name="ln2173">		&amp;&amp; fLayoutData-&gt;topInset == top</a>
<a name="ln2174">		&amp;&amp; fLayoutData-&gt;rightInset == right</a>
<a name="ln2175">		&amp;&amp; fLayoutData-&gt;bottomInset == bottom)</a>
<a name="ln2176">		return;</a>
<a name="ln2177"> </a>
<a name="ln2178">	fLayoutData-&gt;leftInset = left;</a>
<a name="ln2179">	fLayoutData-&gt;topInset = top;</a>
<a name="ln2180">	fLayoutData-&gt;rightInset = right;</a>
<a name="ln2181">	fLayoutData-&gt;bottomInset = bottom;</a>
<a name="ln2182"> </a>
<a name="ln2183">	InvalidateLayout();</a>
<a name="ln2184">	Invalidate();</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187"> </a>
<a name="ln2188">void</a>
<a name="ln2189">BTextView::GetInsets(float* _left, float* _top, float* _right,</a>
<a name="ln2190">	float* _bottom) const</a>
<a name="ln2191">{</a>
<a name="ln2192">	if (_left)</a>
<a name="ln2193">		*_left = fLayoutData-&gt;leftInset;</a>
<a name="ln2194">	if (_top)</a>
<a name="ln2195">		*_top = fLayoutData-&gt;topInset;</a>
<a name="ln2196">	if (_right)</a>
<a name="ln2197">		*_right = fLayoutData-&gt;rightInset;</a>
<a name="ln2198">	if (_bottom)</a>
<a name="ln2199">		*_bottom = fLayoutData-&gt;bottomInset;</a>
<a name="ln2200">}</a>
<a name="ln2201"> </a>
<a name="ln2202"> </a>
<a name="ln2203">void</a>
<a name="ln2204">BTextView::SetStylable(bool stylable)</a>
<a name="ln2205">{</a>
<a name="ln2206">	fStylable = stylable;</a>
<a name="ln2207">}</a>
<a name="ln2208"> </a>
<a name="ln2209"> </a>
<a name="ln2210">bool</a>
<a name="ln2211">BTextView::IsStylable() const</a>
<a name="ln2212">{</a>
<a name="ln2213">	return fStylable;</a>
<a name="ln2214">}</a>
<a name="ln2215"> </a>
<a name="ln2216"> </a>
<a name="ln2217">void</a>
<a name="ln2218">BTextView::SetTabWidth(float width)</a>
<a name="ln2219">{</a>
<a name="ln2220">	if (width == fTabWidth)</a>
<a name="ln2221">		return;</a>
<a name="ln2222"> </a>
<a name="ln2223">	fTabWidth = width;</a>
<a name="ln2224"> </a>
<a name="ln2225">	if (Window() != NULL)</a>
<a name="ln2226">		_Refresh(0, fText-&gt;Length(), false);</a>
<a name="ln2227">}</a>
<a name="ln2228"> </a>
<a name="ln2229"> </a>
<a name="ln2230">float</a>
<a name="ln2231">BTextView::TabWidth() const</a>
<a name="ln2232">{</a>
<a name="ln2233">	return fTabWidth;</a>
<a name="ln2234">}</a>
<a name="ln2235"> </a>
<a name="ln2236"> </a>
<a name="ln2237">void</a>
<a name="ln2238">BTextView::MakeSelectable(bool selectable)</a>
<a name="ln2239">{</a>
<a name="ln2240">	if (selectable == fSelectable)</a>
<a name="ln2241">		return;</a>
<a name="ln2242"> </a>
<a name="ln2243">	fSelectable = selectable;</a>
<a name="ln2244"> </a>
<a name="ln2245">	if (fActive &amp;&amp; fSelStart != fSelEnd &amp;&amp; Window() != NULL)</a>
<a name="ln2246">		Highlight(fSelStart, fSelEnd);</a>
<a name="ln2247">}</a>
<a name="ln2248"> </a>
<a name="ln2249"> </a>
<a name="ln2250">bool</a>
<a name="ln2251">BTextView::IsSelectable() const</a>
<a name="ln2252">{</a>
<a name="ln2253">	return fSelectable;</a>
<a name="ln2254">}</a>
<a name="ln2255"> </a>
<a name="ln2256"> </a>
<a name="ln2257">void</a>
<a name="ln2258">BTextView::MakeEditable(bool editable)</a>
<a name="ln2259">{</a>
<a name="ln2260">	if (editable == fEditable)</a>
<a name="ln2261">		return;</a>
<a name="ln2262"> </a>
<a name="ln2263">	fEditable = editable;</a>
<a name="ln2264">	// TextControls change the color of the text when</a>
<a name="ln2265">	// they are made editable, so we need to invalidate</a>
<a name="ln2266">	// the NULL style here</a>
<a name="ln2267">	// TODO: it works well, but it could be caused by a bug somewhere else</a>
<a name="ln2268">	if (fEditable)</a>
<a name="ln2269">		fStyles-&gt;InvalidateNullStyle();</a>
<a name="ln2270">	if (Window() != NULL &amp;&amp; fActive) {</a>
<a name="ln2271">		if (!fEditable) {</a>
<a name="ln2272">			_HideCaret();</a>
<a name="ln2273">			_CancelInputMethod();</a>
<a name="ln2274">		}</a>
<a name="ln2275">	}</a>
<a name="ln2276">}</a>
<a name="ln2277"> </a>
<a name="ln2278"> </a>
<a name="ln2279">bool</a>
<a name="ln2280">BTextView::IsEditable() const</a>
<a name="ln2281">{</a>
<a name="ln2282">	return fEditable;</a>
<a name="ln2283">}</a>
<a name="ln2284"> </a>
<a name="ln2285"> </a>
<a name="ln2286">void</a>
<a name="ln2287">BTextView::SetWordWrap(bool wrap)</a>
<a name="ln2288">{</a>
<a name="ln2289">	if (wrap == fWrap)</a>
<a name="ln2290">		return;</a>
<a name="ln2291"> </a>
<a name="ln2292">	bool updateOnScreen = fActive &amp;&amp; Window() != NULL;</a>
<a name="ln2293">	if (updateOnScreen) {</a>
<a name="ln2294">		// hide the caret, unhilite the selection</a>
<a name="ln2295">		if (fSelStart != fSelEnd) {</a>
<a name="ln2296">			if (fSelectable)</a>
<a name="ln2297">				Highlight(fSelStart, fSelEnd);</a>
<a name="ln2298">		} else</a>
<a name="ln2299">			_HideCaret();</a>
<a name="ln2300">	}</a>
<a name="ln2301"> </a>
<a name="ln2302">	fWrap = wrap;</a>
<a name="ln2303">	if (wrap)</a>
<a name="ln2304">		_ResetTextRect();</a>
<a name="ln2305">	_Refresh(0, fText-&gt;Length(), false);</a>
<a name="ln2306"> </a>
<a name="ln2307">	if (updateOnScreen) {</a>
<a name="ln2308">		// show the caret, hilite the selection</a>
<a name="ln2309">		if (fSelStart != fSelEnd) {</a>
<a name="ln2310">			if (fSelectable)</a>
<a name="ln2311">				Highlight(fSelStart, fSelEnd);</a>
<a name="ln2312">		} else</a>
<a name="ln2313">			_ShowCaret();</a>
<a name="ln2314">	}</a>
<a name="ln2315">}</a>
<a name="ln2316"> </a>
<a name="ln2317"> </a>
<a name="ln2318">bool</a>
<a name="ln2319">BTextView::DoesWordWrap() const</a>
<a name="ln2320">{</a>
<a name="ln2321">	return fWrap;</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324"> </a>
<a name="ln2325">void</a>
<a name="ln2326">BTextView::SetMaxBytes(int32 max)</a>
<a name="ln2327">{</a>
<a name="ln2328">	const int32 textLength = fText-&gt;Length();</a>
<a name="ln2329">	fMaxBytes = max;</a>
<a name="ln2330"> </a>
<a name="ln2331">	if (fMaxBytes &lt; textLength) {</a>
<a name="ln2332">		int32 offset = fMaxBytes;</a>
<a name="ln2333">		// Delete the text after fMaxBytes, but</a>
<a name="ln2334">		// respect multibyte characters boundaries.</a>
<a name="ln2335">		const int32 previousInitial = _PreviousInitialByte(offset);</a>
<a name="ln2336">		if (_NextInitialByte(previousInitial) != offset)</a>
<a name="ln2337">			offset = previousInitial;</a>
<a name="ln2338"> </a>
<a name="ln2339">		Delete(offset, textLength);</a>
<a name="ln2340">	}</a>
<a name="ln2341">}</a>
<a name="ln2342"> </a>
<a name="ln2343"> </a>
<a name="ln2344">int32</a>
<a name="ln2345">BTextView::MaxBytes() const</a>
<a name="ln2346">{</a>
<a name="ln2347">	return fMaxBytes;</a>
<a name="ln2348">}</a>
<a name="ln2349"> </a>
<a name="ln2350"> </a>
<a name="ln2351">void</a>
<a name="ln2352">BTextView::DisallowChar(uint32 character)</a>
<a name="ln2353">{</a>
<a name="ln2354">	if (fDisallowedChars == NULL)</a>
<a name="ln2355">		fDisallowedChars = new BList;</a>
<a name="ln2356">	if (!fDisallowedChars-&gt;HasItem(reinterpret_cast&lt;void*&gt;(character)))</a>
<a name="ln2357">		fDisallowedChars-&gt;AddItem(reinterpret_cast&lt;void*&gt;(character));</a>
<a name="ln2358">}</a>
<a name="ln2359"> </a>
<a name="ln2360"> </a>
<a name="ln2361">void</a>
<a name="ln2362">BTextView::AllowChar(uint32 character)</a>
<a name="ln2363">{</a>
<a name="ln2364">	if (fDisallowedChars != NULL)</a>
<a name="ln2365">		fDisallowedChars-&gt;RemoveItem(reinterpret_cast&lt;void*&gt;(character));</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368"> </a>
<a name="ln2369">void</a>
<a name="ln2370">BTextView::SetAlignment(alignment align)</a>
<a name="ln2371">{</a>
<a name="ln2372">	// Do a reality check</a>
<a name="ln2373">	if (fAlignment != align &amp;&amp;</a>
<a name="ln2374">			(align == B_ALIGN_LEFT ||</a>
<a name="ln2375">			 align == B_ALIGN_RIGHT ||</a>
<a name="ln2376">			 align == B_ALIGN_CENTER)) {</a>
<a name="ln2377">		fAlignment = align;</a>
<a name="ln2378"> </a>
<a name="ln2379">		// After setting new alignment, update the view/window</a>
<a name="ln2380">		if (Window() != NULL)</a>
<a name="ln2381">			Invalidate();</a>
<a name="ln2382">	}</a>
<a name="ln2383">}</a>
<a name="ln2384"> </a>
<a name="ln2385"> </a>
<a name="ln2386">alignment</a>
<a name="ln2387">BTextView::Alignment() const</a>
<a name="ln2388">{</a>
<a name="ln2389">	return fAlignment;</a>
<a name="ln2390">}</a>
<a name="ln2391"> </a>
<a name="ln2392"> </a>
<a name="ln2393">void</a>
<a name="ln2394">BTextView::SetAutoindent(bool state)</a>
<a name="ln2395">{</a>
<a name="ln2396">	fAutoindent = state;</a>
<a name="ln2397">}</a>
<a name="ln2398"> </a>
<a name="ln2399"> </a>
<a name="ln2400">bool</a>
<a name="ln2401">BTextView::DoesAutoindent() const</a>
<a name="ln2402">{</a>
<a name="ln2403">	return fAutoindent;</a>
<a name="ln2404">}</a>
<a name="ln2405"> </a>
<a name="ln2406"> </a>
<a name="ln2407">void</a>
<a name="ln2408">BTextView::SetColorSpace(color_space colors)</a>
<a name="ln2409">{</a>
<a name="ln2410">	if (colors != fColorSpace &amp;&amp; fOffscreen) {</a>
<a name="ln2411">		fColorSpace = colors;</a>
<a name="ln2412">		_DeleteOffscreen();</a>
<a name="ln2413">		_NewOffscreen();</a>
<a name="ln2414">	}</a>
<a name="ln2415">}</a>
<a name="ln2416"> </a>
<a name="ln2417"> </a>
<a name="ln2418">color_space</a>
<a name="ln2419">BTextView::ColorSpace() const</a>
<a name="ln2420">{</a>
<a name="ln2421">	return fColorSpace;</a>
<a name="ln2422">}</a>
<a name="ln2423"> </a>
<a name="ln2424"> </a>
<a name="ln2425">void</a>
<a name="ln2426">BTextView::MakeResizable(bool resize, BView* resizeView)</a>
<a name="ln2427">{</a>
<a name="ln2428">	if (resize) {</a>
<a name="ln2429">		fResizable = true;</a>
<a name="ln2430">		fContainerView = resizeView;</a>
<a name="ln2431"> </a>
<a name="ln2432">		// Wrapping mode and resizable mode can't live together</a>
<a name="ln2433">		if (fWrap) {</a>
<a name="ln2434">			fWrap = false;</a>
<a name="ln2435"> </a>
<a name="ln2436">			if (fActive &amp;&amp; Window() != NULL) {</a>
<a name="ln2437">				if (fSelStart != fSelEnd) {</a>
<a name="ln2438">					if (fSelectable)</a>
<a name="ln2439">						Highlight(fSelStart, fSelEnd);</a>
<a name="ln2440">				} else</a>
<a name="ln2441">					_HideCaret();</a>
<a name="ln2442">			}</a>
<a name="ln2443">		}</a>
<a name="ln2444">		// We need to reset the right inset, as otherwise the auto-resize would</a>
<a name="ln2445">		// get confused about just how wide the textview needs to be.</a>
<a name="ln2446">		// This seems to be an artefact of how Tracker creates the textview</a>
<a name="ln2447">		// during a rename action.</a>
<a name="ln2448">		fLayoutData-&gt;rightInset = fLayoutData-&gt;leftInset;</a>
<a name="ln2449">	} else {</a>
<a name="ln2450">		fResizable = false;</a>
<a name="ln2451">		fContainerView = NULL;</a>
<a name="ln2452">		if (fOffscreen)</a>
<a name="ln2453">			_DeleteOffscreen();</a>
<a name="ln2454">		_NewOffscreen();</a>
<a name="ln2455">	}</a>
<a name="ln2456"> </a>
<a name="ln2457">	_Refresh(0, fText-&gt;Length(), false);</a>
<a name="ln2458">}</a>
<a name="ln2459"> </a>
<a name="ln2460"> </a>
<a name="ln2461">bool</a>
<a name="ln2462">BTextView::IsResizable() const</a>
<a name="ln2463">{</a>
<a name="ln2464">	return fResizable;</a>
<a name="ln2465">}</a>
<a name="ln2466"> </a>
<a name="ln2467"> </a>
<a name="ln2468">void</a>
<a name="ln2469">BTextView::SetDoesUndo(bool undo)</a>
<a name="ln2470">{</a>
<a name="ln2471">	if (undo &amp;&amp; fUndo == NULL)</a>
<a name="ln2472">		fUndo = new UndoBuffer(this, B_UNDO_UNAVAILABLE);</a>
<a name="ln2473">	else if (!undo &amp;&amp; fUndo != NULL) {</a>
<a name="ln2474">		delete fUndo;</a>
<a name="ln2475">		fUndo = NULL;</a>
<a name="ln2476">	}</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479"> </a>
<a name="ln2480">bool</a>
<a name="ln2481">BTextView::DoesUndo() const</a>
<a name="ln2482">{</a>
<a name="ln2483">	return fUndo != NULL;</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486"> </a>
<a name="ln2487">void</a>
<a name="ln2488">BTextView::HideTyping(bool enabled)</a>
<a name="ln2489">{</a>
<a name="ln2490">	if (enabled)</a>
<a name="ln2491">		Delete(0, fText-&gt;Length());</a>
<a name="ln2492"> </a>
<a name="ln2493">	fText-&gt;SetPasswordMode(enabled);</a>
<a name="ln2494">}</a>
<a name="ln2495"> </a>
<a name="ln2496"> </a>
<a name="ln2497">bool</a>
<a name="ln2498">BTextView::IsTypingHidden() const</a>
<a name="ln2499">{</a>
<a name="ln2500">	return fText-&gt;PasswordMode();</a>
<a name="ln2501">}</a>
<a name="ln2502"> </a>
<a name="ln2503"> </a>
<a name="ln2504">// #pragma mark - Size methods</a>
<a name="ln2505"> </a>
<a name="ln2506"> </a>
<a name="ln2507">void</a>
<a name="ln2508">BTextView::ResizeToPreferred()</a>
<a name="ln2509">{</a>
<a name="ln2510">	BView::ResizeToPreferred();</a>
<a name="ln2511">}</a>
<a name="ln2512"> </a>
<a name="ln2513"> </a>
<a name="ln2514">void</a>
<a name="ln2515">BTextView::GetPreferredSize(float* _width, float* _height)</a>
<a name="ln2516">{</a>
<a name="ln2517">	CALLED();</a>
<a name="ln2518"> </a>
<a name="ln2519">	_ValidateLayoutData();</a>
<a name="ln2520"> </a>
<a name="ln2521">	if (_width) {</a>
<a name="ln2522">		float width = Bounds().Width();</a>
<a name="ln2523">		if (width &lt; fLayoutData-&gt;min.width</a>
<a name="ln2524">			|| (Flags() &amp; B_SUPPORTS_LAYOUT) != 0) {</a>
<a name="ln2525">			width = fLayoutData-&gt;min.width;</a>
<a name="ln2526">		}</a>
<a name="ln2527">		*_width = width;</a>
<a name="ln2528">	}</a>
<a name="ln2529"> </a>
<a name="ln2530">	if (_height) {</a>
<a name="ln2531">		float height = Bounds().Height();</a>
<a name="ln2532">		if (height &lt; fLayoutData-&gt;min.height</a>
<a name="ln2533">			|| (Flags() &amp; B_SUPPORTS_LAYOUT) != 0) {</a>
<a name="ln2534">			height = fLayoutData-&gt;min.height;</a>
<a name="ln2535">		}</a>
<a name="ln2536">		*_height = height;</a>
<a name="ln2537">	}</a>
<a name="ln2538">}</a>
<a name="ln2539"> </a>
<a name="ln2540"> </a>
<a name="ln2541">BSize</a>
<a name="ln2542">BTextView::MinSize()</a>
<a name="ln2543">{</a>
<a name="ln2544">	CALLED();</a>
<a name="ln2545"> </a>
<a name="ln2546">	_ValidateLayoutData();</a>
<a name="ln2547">	return BLayoutUtils::ComposeSize(ExplicitMinSize(), fLayoutData-&gt;min);</a>
<a name="ln2548">}</a>
<a name="ln2549"> </a>
<a name="ln2550"> </a>
<a name="ln2551">BSize</a>
<a name="ln2552">BTextView::MaxSize()</a>
<a name="ln2553">{</a>
<a name="ln2554">	CALLED();</a>
<a name="ln2555"> </a>
<a name="ln2556">	return BLayoutUtils::ComposeSize(ExplicitMaxSize(),</a>
<a name="ln2557">		BSize(B_SIZE_UNLIMITED, B_SIZE_UNLIMITED));</a>
<a name="ln2558">}</a>
<a name="ln2559"> </a>
<a name="ln2560"> </a>
<a name="ln2561">BSize</a>
<a name="ln2562">BTextView::PreferredSize()</a>
<a name="ln2563">{</a>
<a name="ln2564">	CALLED();</a>
<a name="ln2565"> </a>
<a name="ln2566">	_ValidateLayoutData();</a>
<a name="ln2567">	return BLayoutUtils::ComposeSize(ExplicitPreferredSize(),</a>
<a name="ln2568">		fLayoutData-&gt;preferred);</a>
<a name="ln2569">}</a>
<a name="ln2570"> </a>
<a name="ln2571"> </a>
<a name="ln2572">bool</a>
<a name="ln2573">BTextView::HasHeightForWidth()</a>
<a name="ln2574">{</a>
<a name="ln2575">	if (IsEditable())</a>
<a name="ln2576">		return BView::HasHeightForWidth();</a>
<a name="ln2577"> </a>
<a name="ln2578">	// When not editable, we assume that all text is supposed to be visible.</a>
<a name="ln2579">	return true;</a>
<a name="ln2580">}</a>
<a name="ln2581"> </a>
<a name="ln2582"> </a>
<a name="ln2583">void</a>
<a name="ln2584">BTextView::GetHeightForWidth(float width, float* min, float* max,</a>
<a name="ln2585">	float* preferred)</a>
<a name="ln2586">{</a>
<a name="ln2587">	if (IsEditable()) {</a>
<a name="ln2588">		BView::GetHeightForWidth(width, min, max, preferred);</a>
<a name="ln2589">		return;</a>
<a name="ln2590">	}</a>
<a name="ln2591"> </a>
<a name="ln2592">	// TODO: don't change the actual text rect!</a>
<a name="ln2593">	fTextRect.right = fTextRect.left + width;</a>
<a name="ln2594">	_Refresh(0, TextLength(), false);</a>
<a name="ln2595"> </a>
<a name="ln2596">	if (min != NULL)</a>
<a name="ln2597">		*min = fTextRect.Height();</a>
<a name="ln2598">	if (max != NULL)</a>
<a name="ln2599">		*max = B_SIZE_UNLIMITED;</a>
<a name="ln2600">	if (preferred != NULL)</a>
<a name="ln2601">		*preferred = fTextRect.Height();</a>
<a name="ln2602">}</a>
<a name="ln2603"> </a>
<a name="ln2604"> </a>
<a name="ln2605">//	#pragma mark - Layout methods</a>
<a name="ln2606"> </a>
<a name="ln2607"> </a>
<a name="ln2608">void</a>
<a name="ln2609">BTextView::LayoutInvalidated(bool descendants)</a>
<a name="ln2610">{</a>
<a name="ln2611">	CALLED();</a>
<a name="ln2612"> </a>
<a name="ln2613">	fLayoutData-&gt;valid = false;</a>
<a name="ln2614">}</a>
<a name="ln2615"> </a>
<a name="ln2616"> </a>
<a name="ln2617">void</a>
<a name="ln2618">BTextView::DoLayout()</a>
<a name="ln2619">{</a>
<a name="ln2620">	// Bail out, if we shan't do layout.</a>
<a name="ln2621">	if (!(Flags() &amp; B_SUPPORTS_LAYOUT))</a>
<a name="ln2622">		return;</a>
<a name="ln2623"> </a>
<a name="ln2624">	CALLED();</a>
<a name="ln2625"> </a>
<a name="ln2626">	// If the user set a layout, we let the base class version call its</a>
<a name="ln2627">	// hook.</a>
<a name="ln2628">	if (GetLayout()) {</a>
<a name="ln2629">		BView::DoLayout();</a>
<a name="ln2630">		return;</a>
<a name="ln2631">	}</a>
<a name="ln2632"> </a>
<a name="ln2633">	_ValidateLayoutData();</a>
<a name="ln2634"> </a>
<a name="ln2635">	// validate current size</a>
<a name="ln2636">	BSize size(Bounds().Size());</a>
<a name="ln2637">	if (size.width &lt; fLayoutData-&gt;min.width)</a>
<a name="ln2638">		size.width = fLayoutData-&gt;min.width;</a>
<a name="ln2639">	if (size.height &lt; fLayoutData-&gt;min.height)</a>
<a name="ln2640">		size.height = fLayoutData-&gt;min.height;</a>
<a name="ln2641"> </a>
<a name="ln2642">	_ResetTextRect();</a>
<a name="ln2643">}</a>
<a name="ln2644"> </a>
<a name="ln2645"> </a>
<a name="ln2646">void</a>
<a name="ln2647">BTextView::_ValidateLayoutData()</a>
<a name="ln2648">{</a>
<a name="ln2649">	if (fLayoutData-&gt;valid)</a>
<a name="ln2650">		return;</a>
<a name="ln2651"> </a>
<a name="ln2652">	CALLED();</a>
<a name="ln2653"> </a>
<a name="ln2654">	float lineHeight = ceilf(LineHeight(0));</a>
<a name="ln2655">	TRACE(&quot;line height: %.2f\n&quot;, lineHeight);</a>
<a name="ln2656"> </a>
<a name="ln2657">	// compute our minimal size</a>
<a name="ln2658">	BSize min(lineHeight * 3, lineHeight);</a>
<a name="ln2659">	min.width += fLayoutData-&gt;leftInset + fLayoutData-&gt;rightInset;</a>
<a name="ln2660">	min.height += fLayoutData-&gt;topInset + fLayoutData-&gt;bottomInset;</a>
<a name="ln2661"> </a>
<a name="ln2662">	fLayoutData-&gt;min = min;</a>
<a name="ln2663"> </a>
<a name="ln2664">	// compute our preferred size</a>
<a name="ln2665">	fLayoutData-&gt;preferred.height = fTextRect.Height()</a>
<a name="ln2666">		+ fLayoutData-&gt;topInset + fLayoutData-&gt;bottomInset;</a>
<a name="ln2667"> </a>
<a name="ln2668">	if (fWrap)</a>
<a name="ln2669">		fLayoutData-&gt;preferred.width = min.width + 5 * lineHeight;</a>
<a name="ln2670">	else {</a>
<a name="ln2671">		float maxWidth = fLines-&gt;MaxWidth();</a>
<a name="ln2672">		if (maxWidth &lt; min.width)</a>
<a name="ln2673">			maxWidth = min.width;</a>
<a name="ln2674"> </a>
<a name="ln2675">		fLayoutData-&gt;preferred.width</a>
<a name="ln2676">			= maxWidth + fLayoutData-&gt;leftInset + fLayoutData-&gt;rightInset;</a>
<a name="ln2677">	}</a>
<a name="ln2678"> </a>
<a name="ln2679">	fLayoutData-&gt;valid = true;</a>
<a name="ln2680">	ResetLayoutInvalidation();</a>
<a name="ln2681"> </a>
<a name="ln2682">	TRACE(&quot;width: %.2f, height: %.2f\n&quot;, min.width, min.height);</a>
<a name="ln2683">}</a>
<a name="ln2684"> </a>
<a name="ln2685"> </a>
<a name="ln2686">//	#pragma mark -</a>
<a name="ln2687"> </a>
<a name="ln2688"> </a>
<a name="ln2689">void</a>
<a name="ln2690">BTextView::AllAttached()</a>
<a name="ln2691">{</a>
<a name="ln2692">	BView::AllAttached();</a>
<a name="ln2693">}</a>
<a name="ln2694"> </a>
<a name="ln2695"> </a>
<a name="ln2696">void</a>
<a name="ln2697">BTextView::AllDetached()</a>
<a name="ln2698">{</a>
<a name="ln2699">	BView::AllDetached();</a>
<a name="ln2700">}</a>
<a name="ln2701"> </a>
<a name="ln2702"> </a>
<a name="ln2703">/* static */</a>
<a name="ln2704">text_run_array*</a>
<a name="ln2705">BTextView::AllocRunArray(int32 entryCount, int32* outSize)</a>
<a name="ln2706">{</a>
<a name="ln2707">	int32 size = sizeof(text_run_array) + (entryCount - 1) * sizeof(text_run);</a>
<a name="ln2708"> </a>
<a name="ln2709">	text_run_array* runArray = (text_run_array*)calloc(size, 1);</a>
<a name="ln2710">	if (runArray == NULL) {</a>
<a name="ln2711">		if (outSize != NULL)</a>
<a name="ln2712">			*outSize = 0;</a>
<a name="ln2713">		return NULL;</a>
<a name="ln2714">	}</a>
<a name="ln2715"> </a>
<a name="ln2716">	runArray-&gt;count = entryCount;</a>
<a name="ln2717"> </a>
<a name="ln2718">	// Call constructors explicitly as the text_run_array</a>
<a name="ln2719">	// was allocated with malloc (and has to, for backwards</a>
<a name="ln2720">	// compatibility)</a>
<a name="ln2721">	for (int32 i = 0; i &lt; runArray-&gt;count; i++) {</a>
<a name="ln2722">		new (&amp;runArray-&gt;runs[i].font) BFont;</a>
<a name="ln2723">	}</a>
<a name="ln2724"> </a>
<a name="ln2725">	if (outSize != NULL)</a>
<a name="ln2726">		*outSize = size;</a>
<a name="ln2727"> </a>
<a name="ln2728">	return runArray;</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731"> </a>
<a name="ln2732">/* static */</a>
<a name="ln2733">text_run_array*</a>
<a name="ln2734">BTextView::CopyRunArray(const text_run_array* orig, int32 countDelta)</a>
<a name="ln2735">{</a>
<a name="ln2736">	text_run_array* copy = AllocRunArray(countDelta, NULL);</a>
<a name="ln2737">	if (copy != NULL) {</a>
<a name="ln2738">		for (int32 i = 0; i &lt; countDelta; i++) {</a>
<a name="ln2739">			copy-&gt;runs[i].offset = orig-&gt;runs[i].offset;</a>
<a name="ln2740">			copy-&gt;runs[i].font = orig-&gt;runs[i].font;</a>
<a name="ln2741">			copy-&gt;runs[i].color = orig-&gt;runs[i].color;</a>
<a name="ln2742">		}</a>
<a name="ln2743">	}</a>
<a name="ln2744">	return copy;</a>
<a name="ln2745">}</a>
<a name="ln2746"> </a>
<a name="ln2747"> </a>
<a name="ln2748">/* static */</a>
<a name="ln2749">void</a>
<a name="ln2750">BTextView::FreeRunArray(text_run_array* array)</a>
<a name="ln2751">{</a>
<a name="ln2752">	if (array == NULL)</a>
<a name="ln2753">		return;</a>
<a name="ln2754"> </a>
<a name="ln2755">	// Call destructors explicitly</a>
<a name="ln2756">	for (int32 i = 0; i &lt; array-&gt;count; i++)</a>
<a name="ln2757">		array-&gt;runs[i].font.~BFont();</a>
<a name="ln2758"> </a>
<a name="ln2759">	free(array);</a>
<a name="ln2760">}</a>
<a name="ln2761"> </a>
<a name="ln2762"> </a>
<a name="ln2763">/* static */</a>
<a name="ln2764">void*</a>
<a name="ln2765">BTextView::FlattenRunArray(const text_run_array* runArray, int32* _size)</a>
<a name="ln2766">{</a>
<a name="ln2767">	CALLED();</a>
<a name="ln2768">	int32 size = sizeof(flattened_text_run_array) + (runArray-&gt;count - 1)</a>
<a name="ln2769">		* sizeof(flattened_text_run);</a>
<a name="ln2770"> </a>
<a name="ln2771">	flattened_text_run_array* array = (flattened_text_run_array*)malloc(size);</a>
<a name="ln2772">	if (array == NULL) {</a>
<a name="ln2773">		if (_size)</a>
<a name="ln2774">			*_size = 0;</a>
<a name="ln2775">		return NULL;</a>
<a name="ln2776">	}</a>
<a name="ln2777"> </a>
<a name="ln2778">	array-&gt;magic = B_HOST_TO_BENDIAN_INT32(kFlattenedTextRunArrayMagic);</a>
<a name="ln2779">	array-&gt;version = B_HOST_TO_BENDIAN_INT32(kFlattenedTextRunArrayVersion);</a>
<a name="ln2780">	array-&gt;count = B_HOST_TO_BENDIAN_INT32(runArray-&gt;count);</a>
<a name="ln2781"> </a>
<a name="ln2782">	for (int32 i = 0; i &lt; runArray-&gt;count; i++) {</a>
<a name="ln2783">		array-&gt;styles[i].offset = B_HOST_TO_BENDIAN_INT32(</a>
<a name="ln2784">			runArray-&gt;runs[i].offset);</a>
<a name="ln2785">		runArray-&gt;runs[i].font.GetFamilyAndStyle(&amp;array-&gt;styles[i].family,</a>
<a name="ln2786">			&amp;array-&gt;styles[i].style);</a>
<a name="ln2787">		array-&gt;styles[i].size = B_HOST_TO_BENDIAN_FLOAT(</a>
<a name="ln2788">			runArray-&gt;runs[i].font.Size());</a>
<a name="ln2789">		array-&gt;styles[i].shear = B_HOST_TO_BENDIAN_FLOAT(</a>
<a name="ln2790">			runArray-&gt;runs[i].font.Shear());</a>
<a name="ln2791">		array-&gt;styles[i].face = B_HOST_TO_BENDIAN_INT16(</a>
<a name="ln2792">			runArray-&gt;runs[i].font.Face());</a>
<a name="ln2793">		array-&gt;styles[i].red = runArray-&gt;runs[i].color.red;</a>
<a name="ln2794">		array-&gt;styles[i].green = runArray-&gt;runs[i].color.green;</a>
<a name="ln2795">		array-&gt;styles[i].blue = runArray-&gt;runs[i].color.blue;</a>
<a name="ln2796">		array-&gt;styles[i].alpha = 255;</a>
<a name="ln2797">		array-&gt;styles[i]._reserved_ = 0;</a>
<a name="ln2798">	}</a>
<a name="ln2799"> </a>
<a name="ln2800">	if (_size)</a>
<a name="ln2801">		*_size = size;</a>
<a name="ln2802"> </a>
<a name="ln2803">	return array;</a>
<a name="ln2804">}</a>
<a name="ln2805"> </a>
<a name="ln2806"> </a>
<a name="ln2807">/* static */</a>
<a name="ln2808">text_run_array*</a>
<a name="ln2809">BTextView::UnflattenRunArray(const void* data, int32* _size)</a>
<a name="ln2810">{</a>
<a name="ln2811">	CALLED();</a>
<a name="ln2812">	flattened_text_run_array* array = (flattened_text_run_array*)data;</a>
<a name="ln2813"> </a>
<a name="ln2814">	if (B_BENDIAN_TO_HOST_INT32(array-&gt;magic) != kFlattenedTextRunArrayMagic</a>
<a name="ln2815">		|| B_BENDIAN_TO_HOST_INT32(array-&gt;version)</a>
<a name="ln2816">			!= kFlattenedTextRunArrayVersion) {</a>
<a name="ln2817">		if (_size)</a>
<a name="ln2818">			*_size = 0;</a>
<a name="ln2819"> </a>
<a name="ln2820">		return NULL;</a>
<a name="ln2821">	}</a>
<a name="ln2822"> </a>
<a name="ln2823">	int32 count = B_BENDIAN_TO_HOST_INT32(array-&gt;count);</a>
<a name="ln2824"> </a>
<a name="ln2825">	text_run_array* runArray = AllocRunArray(count, _size);</a>
<a name="ln2826">	if (runArray == NULL)</a>
<a name="ln2827">		return NULL;</a>
<a name="ln2828"> </a>
<a name="ln2829">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2830">		runArray-&gt;runs[i].offset = B_BENDIAN_TO_HOST_INT32(</a>
<a name="ln2831">			array-&gt;styles[i].offset);</a>
<a name="ln2832"> </a>
<a name="ln2833">		// Set family and style independently from each other, so that</a>
<a name="ln2834">		// even if the family doesn't exist, we try to preserve the style</a>
<a name="ln2835">		runArray-&gt;runs[i].font.SetFamilyAndStyle(array-&gt;styles[i].family, NULL);</a>
<a name="ln2836">		runArray-&gt;runs[i].font.SetFamilyAndStyle(NULL, array-&gt;styles[i].style);</a>
<a name="ln2837"> </a>
<a name="ln2838">		runArray-&gt;runs[i].font.SetSize(B_BENDIAN_TO_HOST_FLOAT(</a>
<a name="ln2839">			array-&gt;styles[i].size));</a>
<a name="ln2840">		runArray-&gt;runs[i].font.SetShear(B_BENDIAN_TO_HOST_FLOAT(</a>
<a name="ln2841">			array-&gt;styles[i].shear));</a>
<a name="ln2842"> </a>
<a name="ln2843">		uint16 face = B_BENDIAN_TO_HOST_INT16(array-&gt;styles[i].face);</a>
<a name="ln2844">		if (face != B_REGULAR_FACE) {</a>
<a name="ln2845">			// Be's version doesn't seem to set this correctly</a>
<a name="ln2846">			runArray-&gt;runs[i].font.SetFace(face);</a>
<a name="ln2847">		}</a>
<a name="ln2848"> </a>
<a name="ln2849">		runArray-&gt;runs[i].color.red = array-&gt;styles[i].red;</a>
<a name="ln2850">		runArray-&gt;runs[i].color.green = array-&gt;styles[i].green;</a>
<a name="ln2851">		runArray-&gt;runs[i].color.blue = array-&gt;styles[i].blue;</a>
<a name="ln2852">		runArray-&gt;runs[i].color.alpha = array-&gt;styles[i].alpha;</a>
<a name="ln2853">	}</a>
<a name="ln2854"> </a>
<a name="ln2855">	return runArray;</a>
<a name="ln2856">}</a>
<a name="ln2857"> </a>
<a name="ln2858"> </a>
<a name="ln2859">void</a>
<a name="ln2860">BTextView::InsertText(const char* text, int32 length, int32 offset,</a>
<a name="ln2861">	const text_run_array* runs)</a>
<a name="ln2862">{</a>
<a name="ln2863">	CALLED();</a>
<a name="ln2864"> </a>
<a name="ln2865">	if (length &lt; 0)</a>
<a name="ln2866">		length = 0;</a>
<a name="ln2867"> </a>
<a name="ln2868">	if (offset &lt; 0)</a>
<a name="ln2869">		offset = 0;</a>
<a name="ln2870">	else if (offset &gt; fText-&gt;Length())</a>
<a name="ln2871">		offset = fText-&gt;Length();</a>
<a name="ln2872"> </a>
<a name="ln2873">	if (length &gt; 0) {</a>
<a name="ln2874">		// add the text to the buffer</a>
<a name="ln2875">		fText-&gt;InsertText(text, length, offset);</a>
<a name="ln2876"> </a>
<a name="ln2877">		// update the start offsets of each line below offset</a>
<a name="ln2878">		fLines-&gt;BumpOffset(length, _LineAt(offset) + 1);</a>
<a name="ln2879"> </a>
<a name="ln2880">		// update the style runs</a>
<a name="ln2881">		fStyles-&gt;BumpOffset(length, fStyles-&gt;OffsetToRun(offset - 1) + 1);</a>
<a name="ln2882"> </a>
<a name="ln2883">		// offset the caret/selection, if the text was inserted before it</a>
<a name="ln2884">		if (offset &lt;= fSelEnd) {</a>
<a name="ln2885">			fSelStart += length;</a>
<a name="ln2886">			fCaretOffset = fSelEnd = fSelStart;</a>
<a name="ln2887">		}</a>
<a name="ln2888">	}</a>
<a name="ln2889"> </a>
<a name="ln2890">	if (fStylable &amp;&amp; runs != NULL) {</a>
<a name="ln2891">		_SetRunArray(offset, offset + length, runs);</a>
<a name="ln2892">	} else {</a>
<a name="ln2893">		// apply null-style to inserted text</a>
<a name="ln2894">		_ApplyStyleRange(offset, offset + length);</a>
<a name="ln2895">	}</a>
<a name="ln2896">}</a>
<a name="ln2897"> </a>
<a name="ln2898"> </a>
<a name="ln2899">void</a>
<a name="ln2900">BTextView::DeleteText(int32 fromOffset, int32 toOffset)</a>
<a name="ln2901">{</a>
<a name="ln2902">	CALLED();</a>
<a name="ln2903"> </a>
<a name="ln2904">	if (fromOffset &lt; 0)</a>
<a name="ln2905">		fromOffset = 0;</a>
<a name="ln2906">	else if (fromOffset &gt; fText-&gt;Length())</a>
<a name="ln2907">		fromOffset = fText-&gt;Length();</a>
<a name="ln2908"> </a>
<a name="ln2909">	if (toOffset &lt; 0)</a>
<a name="ln2910">		toOffset = 0;</a>
<a name="ln2911">	else if (toOffset &gt; fText-&gt;Length())</a>
<a name="ln2912">		toOffset = fText-&gt;Length();</a>
<a name="ln2913"> </a>
<a name="ln2914">	if (fromOffset &gt;= toOffset)</a>
<a name="ln2915">		return;</a>
<a name="ln2916"> </a>
<a name="ln2917">	// set nullStyle to style at beginning of range</a>
<a name="ln2918">	fStyles-&gt;InvalidateNullStyle();</a>
<a name="ln2919">	fStyles-&gt;SyncNullStyle(fromOffset);</a>
<a name="ln2920"> </a>
<a name="ln2921">	// remove from the text buffer</a>
<a name="ln2922">	fText-&gt;RemoveRange(fromOffset, toOffset);</a>
<a name="ln2923"> </a>
<a name="ln2924">	// remove any lines that have been obliterated</a>
<a name="ln2925">	fLines-&gt;RemoveLineRange(fromOffset, toOffset);</a>
<a name="ln2926"> </a>
<a name="ln2927">	// remove any style runs that have been obliterated</a>
<a name="ln2928">	fStyles-&gt;RemoveStyleRange(fromOffset, toOffset);</a>
<a name="ln2929"> </a>
<a name="ln2930">	// adjust the selection accordingly, assumes fSelEnd &gt;= fSelStart!</a>
<a name="ln2931">	int32 range = toOffset - fromOffset;</a>
<a name="ln2932">	if (fSelStart &gt;= toOffset) {</a>
<a name="ln2933">		// selection is behind the range that was removed</a>
<a name="ln2934">		fSelStart -= range;</a>
<a name="ln2935">		fSelEnd -= range;</a>
<a name="ln2936">	} else if (fSelStart &gt;= fromOffset &amp;&amp; fSelEnd &lt;= toOffset) {</a>
<a name="ln2937">		// the selection is within the range that was removed</a>
<a name="ln2938">		fSelStart = fSelEnd = fromOffset;</a>
<a name="ln2939">	} else if (fSelStart &gt;= fromOffset &amp;&amp; fSelEnd &gt; toOffset) {</a>
<a name="ln2940">		// the selection starts within and ends after the range</a>
<a name="ln2941">		// the remaining part is the part that was after the range</a>
<a name="ln2942">		fSelStart = fromOffset;</a>
<a name="ln2943">		fSelEnd = fromOffset + fSelEnd - toOffset;</a>
<a name="ln2944">	} else if (fSelStart &lt; fromOffset &amp;&amp; fSelEnd &lt; toOffset) {</a>
<a name="ln2945">		// the selection starts before, but ends within the range</a>
<a name="ln2946">		fSelEnd = fromOffset;</a>
<a name="ln2947">	} else if (fSelStart &lt; fromOffset &amp;&amp; fSelEnd &gt;= toOffset) {</a>
<a name="ln2948">		// the selection starts before and ends after the range</a>
<a name="ln2949">		fSelEnd -= range;</a>
<a name="ln2950">	}</a>
<a name="ln2951">}</a>
<a name="ln2952"> </a>
<a name="ln2953"> </a>
<a name="ln2954">/*!	Undoes the last changes.</a>
<a name="ln2955"> </a>
<a name="ln2956">	\param clipboard A \a clipboard to use for the undo operation.</a>
<a name="ln2957">*/</a>
<a name="ln2958">void</a>
<a name="ln2959">BTextView::Undo(BClipboard* clipboard)</a>
<a name="ln2960">{</a>
<a name="ln2961">	if (fUndo)</a>
<a name="ln2962">		fUndo-&gt;Undo(clipboard);</a>
<a name="ln2963">}</a>
<a name="ln2964"> </a>
<a name="ln2965"> </a>
<a name="ln2966">undo_state</a>
<a name="ln2967">BTextView::UndoState(bool* isRedo) const</a>
<a name="ln2968">{</a>
<a name="ln2969">	return fUndo == NULL ? B_UNDO_UNAVAILABLE : fUndo-&gt;State(isRedo);</a>
<a name="ln2970">}</a>
<a name="ln2971"> </a>
<a name="ln2972"> </a>
<a name="ln2973">//	#pragma mark - GetDragParameters() is protected</a>
<a name="ln2974"> </a>
<a name="ln2975"> </a>
<a name="ln2976">void</a>
<a name="ln2977">BTextView::GetDragParameters(BMessage* drag, BBitmap** bitmap, BPoint* point,</a>
<a name="ln2978">	BHandler** handler)</a>
<a name="ln2979">{</a>
<a name="ln2980">	CALLED();</a>
<a name="ln2981">	if (drag == NULL)</a>
<a name="ln2982">		return;</a>
<a name="ln2983"> </a>
<a name="ln2984">	// Add originator and action</a>
<a name="ln2985">	drag-&gt;AddPointer(&quot;be:originator&quot;, this);</a>
<a name="ln2986">	drag-&gt;AddInt32(&quot;be_actions&quot;, B_TRASH_TARGET);</a>
<a name="ln2987"> </a>
<a name="ln2988">	// add the text</a>
<a name="ln2989">	int32 numBytes = fSelEnd - fSelStart;</a>
<a name="ln2990">	const char* text = fText-&gt;GetString(fSelStart, &amp;numBytes);</a>
<a name="ln2991">	drag-&gt;AddData(&quot;text/plain&quot;, B_MIME_TYPE, text, numBytes);</a>
<a name="ln2992"> </a>
<a name="ln2993">	// add the corresponding styles</a>
<a name="ln2994">	int32 size = 0;</a>
<a name="ln2995">	text_run_array* styles = RunArray(fSelStart, fSelEnd, &amp;size);</a>
<a name="ln2996"> </a>
<a name="ln2997">	if (styles != NULL) {</a>
<a name="ln2998">		drag-&gt;AddData(&quot;application/x-vnd.Be-text_run_array&quot;, B_MIME_TYPE,</a>
<a name="ln2999">			styles, size);</a>
<a name="ln3000"> </a>
<a name="ln3001">		FreeRunArray(styles);</a>
<a name="ln3002">	}</a>
<a name="ln3003"> </a>
<a name="ln3004">	if (bitmap != NULL)</a>
<a name="ln3005">		*bitmap = NULL;</a>
<a name="ln3006"> </a>
<a name="ln3007">	if (handler != NULL)</a>
<a name="ln3008">		*handler = NULL;</a>
<a name="ln3009">}</a>
<a name="ln3010"> </a>
<a name="ln3011"> </a>
<a name="ln3012">//	#pragma mark - FBC padding and forbidden methods</a>
<a name="ln3013"> </a>
<a name="ln3014"> </a>
<a name="ln3015">void BTextView::_ReservedTextView3() {}</a>
<a name="ln3016">void BTextView::_ReservedTextView4() {}</a>
<a name="ln3017">void BTextView::_ReservedTextView5() {}</a>
<a name="ln3018">void BTextView::_ReservedTextView6() {}</a>
<a name="ln3019">void BTextView::_ReservedTextView7() {}</a>
<a name="ln3020">void BTextView::_ReservedTextView8() {}</a>
<a name="ln3021">void BTextView::_ReservedTextView9() {}</a>
<a name="ln3022">void BTextView::_ReservedTextView10() {}</a>
<a name="ln3023">void BTextView::_ReservedTextView11() {}</a>
<a name="ln3024">void BTextView::_ReservedTextView12() {}</a>
<a name="ln3025"> </a>
<a name="ln3026"> </a>
<a name="ln3027">// #pragma mark - Private methods</a>
<a name="ln3028"> </a>
<a name="ln3029"> </a>
<a name="ln3030">/*!	Inits the BTextView object.</a>
<a name="ln3031"> </a>
<a name="ln3032">	\param textRect The BTextView's text rect.</a>
<a name="ln3033">	\param initialFont The font which the BTextView will use.</a>
<a name="ln3034">	\param initialColor The initial color of the text.</a>
<a name="ln3035">*/</a>
<a name="ln3036">void</a>
<a name="ln3037">BTextView::_InitObject(BRect textRect, const BFont* initialFont,</a>
<a name="ln3038">	const rgb_color* initialColor)</a>
<a name="ln3039">{</a>
<a name="ln3040">	BFont font;</a>
<a name="ln3041">	if (initialFont == NULL)</a>
<a name="ln3042">		GetFont(&amp;font);</a>
<a name="ln3043">	else</a>
<a name="ln3044">		font = *initialFont;</a>
<a name="ln3045"> </a>
<a name="ln3046">	_NormalizeFont(&amp;font);</a>
<a name="ln3047"> </a>
<a name="ln3048">	rgb_color documentTextColor = ui_color(B_DOCUMENT_TEXT_COLOR);</a>
<a name="ln3049"> </a>
<a name="ln3050">	if (initialColor == NULL)</a>
<a name="ln3051">		initialColor = &amp;documentTextColor;</a>
<a name="ln3052"> </a>
<a name="ln3053">	fText = new BPrivate::TextGapBuffer;</a>
<a name="ln3054">	fLines = new LineBuffer;</a>
<a name="ln3055">	fStyles = new StyleBuffer(&amp;font, initialColor);</a>
<a name="ln3056"> </a>
<a name="ln3057">	fInstalledNavigateCommandWordwiseShortcuts = false;</a>
<a name="ln3058">	fInstalledNavigateOptionWordwiseShortcuts = false;</a>
<a name="ln3059">	fInstalledNavigateOptionLinewiseShortcuts = false;</a>
<a name="ln3060">	fInstalledNavigateHomeEndDocwiseShortcuts = false;</a>
<a name="ln3061"> </a>
<a name="ln3062">	fInstalledSelectCommandWordwiseShortcuts = false;</a>
<a name="ln3063">	fInstalledSelectOptionWordwiseShortcuts = false;</a>
<a name="ln3064">	fInstalledSelectOptionLinewiseShortcuts = false;</a>
<a name="ln3065">	fInstalledSelectHomeEndDocwiseShortcuts = false;</a>
<a name="ln3066"> </a>
<a name="ln3067">	// We put these here instead of in the constructor initializer list</a>
<a name="ln3068">	// to have less code duplication, and a single place where to do changes</a>
<a name="ln3069">	// if needed.</a>
<a name="ln3070">	fTextRect = textRect;</a>
<a name="ln3071">		// NOTE: The only places where text rect is changed:</a>
<a name="ln3072">		// * width is possibly adjusted in _AutoResize(),</a>
<a name="ln3073">		// * height is adjusted in _RecalculateLineBreaks().</a>
<a name="ln3074">		// When used within the layout management framework, the</a>
<a name="ln3075">		// text rect is changed to maintain constant insets.</a>
<a name="ln3076">	fMinTextRectWidth = fTextRect.Width();</a>
<a name="ln3077">		// see SetTextRect()</a>
<a name="ln3078">	fSelStart = fSelEnd = 0;</a>
<a name="ln3079">	fCaretVisible = false;</a>
<a name="ln3080">	fCaretTime = 0;</a>
<a name="ln3081">	fCaretOffset = 0;</a>
<a name="ln3082">	fClickCount = 0;</a>
<a name="ln3083">	fClickTime = 0;</a>
<a name="ln3084">	fDragOffset = -1;</a>
<a name="ln3085">	fCursor = 0;</a>
<a name="ln3086">	fActive = false;</a>
<a name="ln3087">	fStylable = false;</a>
<a name="ln3088">	fTabWidth = 28.0;</a>
<a name="ln3089">	fSelectable = true;</a>
<a name="ln3090">	fEditable = true;</a>
<a name="ln3091">	fWrap = true;</a>
<a name="ln3092">	fMaxBytes = INT32_MAX;</a>
<a name="ln3093">	fDisallowedChars = NULL;</a>
<a name="ln3094">	fAlignment = B_ALIGN_LEFT;</a>
<a name="ln3095">	fAutoindent = false;</a>
<a name="ln3096">	fOffscreen = NULL;</a>
<a name="ln3097">	fColorSpace = B_CMAP8;</a>
<a name="ln3098">	fResizable = false;</a>
<a name="ln3099">	fContainerView = NULL;</a>
<a name="ln3100">	fUndo = NULL;</a>
<a name="ln3101">	fInline = NULL;</a>
<a name="ln3102">	fDragRunner = NULL;</a>
<a name="ln3103">	fClickRunner = NULL;</a>
<a name="ln3104">	fTrackingMouse = NULL;</a>
<a name="ln3105"> </a>
<a name="ln3106">	fLayoutData = new LayoutData;</a>
<a name="ln3107">	fLayoutData-&gt;UpdateInsets(Bounds().OffsetToCopy(B_ORIGIN), fTextRect);</a>
<a name="ln3108"> </a>
<a name="ln3109">	fLastClickOffset = -1;</a>
<a name="ln3110"> </a>
<a name="ln3111">	SetDoesUndo(true);</a>
<a name="ln3112">	SetViewUIColor(B_DOCUMENT_BACKGROUND_COLOR);</a>
<a name="ln3113">}</a>
<a name="ln3114"> </a>
<a name="ln3115"> </a>
<a name="ln3116">//!	Handles when Backspace key is pressed.</a>
<a name="ln3117">void</a>
<a name="ln3118">BTextView::_HandleBackspace()</a>
<a name="ln3119">{</a>
<a name="ln3120">	if (fUndo) {</a>
<a name="ln3121">		TypingUndoBuffer* undoBuffer = dynamic_cast&lt;TypingUndoBuffer*&gt;(</a>
<a name="ln3122">			fUndo);</a>
<a name="ln3123">		if (!undoBuffer) {</a>
<a name="ln3124">			delete fUndo;</a>
<a name="ln3125">			fUndo = undoBuffer = new TypingUndoBuffer(this);</a>
<a name="ln3126">		}</a>
<a name="ln3127">		undoBuffer-&gt;BackwardErase();</a>
<a name="ln3128">	}</a>
<a name="ln3129"> </a>
<a name="ln3130">	if (fSelStart == fSelEnd) {</a>
<a name="ln3131">		if (fSelStart == 0)</a>
<a name="ln3132">			return;</a>
<a name="ln3133">		else</a>
<a name="ln3134">			fSelStart = _PreviousInitialByte(fSelStart);</a>
<a name="ln3135">	} else</a>
<a name="ln3136">		Highlight(fSelStart, fSelEnd);</a>
<a name="ln3137"> </a>
<a name="ln3138">	DeleteText(fSelStart, fSelEnd);</a>
<a name="ln3139">	fCaretOffset = fSelEnd = fSelStart;</a>
<a name="ln3140"> </a>
<a name="ln3141">	_Refresh(fSelStart, fSelEnd, true);</a>
<a name="ln3142">}</a>
<a name="ln3143"> </a>
<a name="ln3144"> </a>
<a name="ln3145">//!	Handles when an arrow key is pressed.</a>
<a name="ln3146">void</a>
<a name="ln3147">BTextView::_HandleArrowKey(uint32 arrowKey, int32 modifiers)</a>
<a name="ln3148">{</a>
<a name="ln3149">	// return if there's nowhere to go</a>
<a name="ln3150">	if (fText-&gt;Length() == 0)</a>
<a name="ln3151">		return;</a>
<a name="ln3152"> </a>
<a name="ln3153">	int32 selStart = fSelStart;</a>
<a name="ln3154">	int32 selEnd = fSelEnd;</a>
<a name="ln3155"> </a>
<a name="ln3156">	if (modifiers &lt; 0) {</a>
<a name="ln3157">		BMessage* currentMessage = Window()-&gt;CurrentMessage();</a>
<a name="ln3158">		if (currentMessage == NULL</a>
<a name="ln3159">			|| currentMessage-&gt;FindInt32(&quot;modifiers&quot;, &amp;modifiers) != B_OK) {</a>
<a name="ln3160">			modifiers = 0;</a>
<a name="ln3161">		}</a>
<a name="ln3162">	}</a>
<a name="ln3163"> </a>
<a name="ln3164">	bool shiftKeyDown   = (modifiers &amp; B_SHIFT_KEY)   != 0;</a>
<a name="ln3165">	bool controlKeyDown = (modifiers &amp; B_CONTROL_KEY) != 0;</a>
<a name="ln3166">	bool optionKeyDown  = (modifiers &amp; B_OPTION_KEY)  != 0;</a>
<a name="ln3167">	bool commandKeyDown = (modifiers &amp; B_COMMAND_KEY) != 0;</a>
<a name="ln3168"> </a>
<a name="ln3169">	int32 lastClickOffset = fCaretOffset;</a>
<a name="ln3170"> </a>
<a name="ln3171">	switch (arrowKey) {</a>
<a name="ln3172">		case B_LEFT_ARROW:</a>
<a name="ln3173">			if (!fEditable)</a>
<a name="ln3174">				_ScrollBy(-1 * kHorizontalScrollBarStep, 0);</a>
<a name="ln3175">			else if (fSelStart != fSelEnd &amp;&amp; !shiftKeyDown)</a>
<a name="ln3176">				fCaretOffset = fSelStart;</a>
<a name="ln3177">			else {</a>
<a name="ln3178">				if ((commandKeyDown || optionKeyDown) &amp;&amp; !controlKeyDown)</a>
<a name="ln3179">					fCaretOffset = _PreviousWordStart(fCaretOffset - 1);</a>
<a name="ln3180">				else</a>
<a name="ln3181">					fCaretOffset = _PreviousInitialByte(fCaretOffset);</a>
<a name="ln3182"> </a>
<a name="ln3183">				if (shiftKeyDown &amp;&amp; fCaretOffset != lastClickOffset) {</a>
<a name="ln3184">					if (fCaretOffset &lt; fSelStart) {</a>
<a name="ln3185">						// extend selection to the left</a>
<a name="ln3186">						selStart = fCaretOffset;</a>
<a name="ln3187">						if (lastClickOffset &gt; fSelStart) {</a>
<a name="ln3188">							// caret has jumped across &quot;anchor&quot;</a>
<a name="ln3189">							selEnd = fSelStart;</a>
<a name="ln3190">						}</a>
<a name="ln3191">					} else {</a>
<a name="ln3192">						// shrink selection from the right</a>
<a name="ln3193">						selEnd = fCaretOffset;</a>
<a name="ln3194">					}</a>
<a name="ln3195">				}</a>
<a name="ln3196">			}</a>
<a name="ln3197">			break;</a>
<a name="ln3198"> </a>
<a name="ln3199">		case B_RIGHT_ARROW:</a>
<a name="ln3200">			if (!fEditable)</a>
<a name="ln3201">				_ScrollBy(kHorizontalScrollBarStep, 0);</a>
<a name="ln3202">			else if (fSelStart != fSelEnd &amp;&amp; !shiftKeyDown)</a>
<a name="ln3203">				fCaretOffset = fSelEnd;</a>
<a name="ln3204">			else {</a>
<a name="ln3205">				if ((commandKeyDown || optionKeyDown) &amp;&amp; !controlKeyDown)</a>
<a name="ln3206">					fCaretOffset = _NextWordEnd(fCaretOffset);</a>
<a name="ln3207">				else</a>
<a name="ln3208">					fCaretOffset = _NextInitialByte(fCaretOffset);</a>
<a name="ln3209"> </a>
<a name="ln3210">				if (shiftKeyDown &amp;&amp; fCaretOffset != lastClickOffset) {</a>
<a name="ln3211">					if (fCaretOffset &gt; fSelEnd) {</a>
<a name="ln3212">						// extend selection to the right</a>
<a name="ln3213">						selEnd = fCaretOffset;</a>
<a name="ln3214">						if (lastClickOffset &lt; fSelEnd) {</a>
<a name="ln3215">							// caret has jumped across &quot;anchor&quot;</a>
<a name="ln3216">							selStart = fSelEnd;</a>
<a name="ln3217">						}</a>
<a name="ln3218">					} else {</a>
<a name="ln3219">						// shrink selection from the left</a>
<a name="ln3220">						selStart = fCaretOffset;</a>
<a name="ln3221">					}</a>
<a name="ln3222">				}</a>
<a name="ln3223">			}</a>
<a name="ln3224">			break;</a>
<a name="ln3225"> </a>
<a name="ln3226">		case B_UP_ARROW:</a>
<a name="ln3227">		{</a>
<a name="ln3228">			if (!fEditable)</a>
<a name="ln3229">				_ScrollBy(0, -1 * kVerticalScrollBarStep);</a>
<a name="ln3230">			else if (fSelStart != fSelEnd &amp;&amp; !shiftKeyDown)</a>
<a name="ln3231">				fCaretOffset = fSelStart;</a>
<a name="ln3232">			else {</a>
<a name="ln3233">				if (optionKeyDown &amp;&amp; !commandKeyDown &amp;&amp; !controlKeyDown)</a>
<a name="ln3234">					fCaretOffset = _PreviousLineStart(fCaretOffset);</a>
<a name="ln3235">				else if (commandKeyDown &amp;&amp; !optionKeyDown &amp;&amp; !controlKeyDown) {</a>
<a name="ln3236">					_ScrollTo(0, 0);</a>
<a name="ln3237">					fCaretOffset = 0;</a>
<a name="ln3238">				} else {</a>
<a name="ln3239">					float height;</a>
<a name="ln3240">					BPoint point = PointAt(fCaretOffset, &amp;height);</a>
<a name="ln3241">					// find the caret position on the previous</a>
<a name="ln3242">					// line by gently stepping onto this line</a>
<a name="ln3243">					for (int i = 1; i &lt;= height; i++) {</a>
<a name="ln3244">						point.y--;</a>
<a name="ln3245">						int32 offset = OffsetAt(point);</a>
<a name="ln3246">						if (offset &lt; fCaretOffset || i == height) {</a>
<a name="ln3247">							fCaretOffset = offset;</a>
<a name="ln3248">							break;</a>
<a name="ln3249">						}</a>
<a name="ln3250">					}</a>
<a name="ln3251">				}</a>
<a name="ln3252"> </a>
<a name="ln3253">				if (shiftKeyDown &amp;&amp; fCaretOffset != lastClickOffset) {</a>
<a name="ln3254">					if (fCaretOffset &lt; fSelStart) {</a>
<a name="ln3255">						// extend selection to the top</a>
<a name="ln3256">						selStart = fCaretOffset;</a>
<a name="ln3257">						if (lastClickOffset &gt; fSelStart) {</a>
<a name="ln3258">							// caret has jumped across &quot;anchor&quot;</a>
<a name="ln3259">							selEnd = fSelStart;</a>
<a name="ln3260">						}</a>
<a name="ln3261">					} else {</a>
<a name="ln3262">						// shrink selection from the bottom</a>
<a name="ln3263">						selEnd = fCaretOffset;</a>
<a name="ln3264">					}</a>
<a name="ln3265">				}</a>
<a name="ln3266">			}</a>
<a name="ln3267">			break;</a>
<a name="ln3268">		}</a>
<a name="ln3269"> </a>
<a name="ln3270">		case B_DOWN_ARROW:</a>
<a name="ln3271">		{</a>
<a name="ln3272">			if (!fEditable)</a>
<a name="ln3273">				_ScrollBy(0, kVerticalScrollBarStep);</a>
<a name="ln3274">			else if (fSelStart != fSelEnd &amp;&amp; !shiftKeyDown)</a>
<a name="ln3275">				fCaretOffset = fSelEnd;</a>
<a name="ln3276">			else {</a>
<a name="ln3277">				if (optionKeyDown &amp;&amp; !commandKeyDown &amp;&amp; !controlKeyDown)</a>
<a name="ln3278">					fCaretOffset = _NextLineEnd(fCaretOffset);</a>
<a name="ln3279">				else if (commandKeyDown &amp;&amp; !optionKeyDown &amp;&amp; !controlKeyDown) {</a>
<a name="ln3280">					_ScrollTo(0, fTextRect.bottom + fLayoutData-&gt;bottomInset);</a>
<a name="ln3281">					fCaretOffset = fText-&gt;Length();</a>
<a name="ln3282">				} else {</a>
<a name="ln3283">					float height;</a>
<a name="ln3284">					BPoint point = PointAt(fCaretOffset, &amp;height);</a>
<a name="ln3285">					point.y += height;</a>
<a name="ln3286">					fCaretOffset = OffsetAt(point);</a>
<a name="ln3287">				}</a>
<a name="ln3288"> </a>
<a name="ln3289">				if (shiftKeyDown &amp;&amp; fCaretOffset != lastClickOffset) {</a>
<a name="ln3290">					if (fCaretOffset &gt; fSelEnd) {</a>
<a name="ln3291">						// extend selection to the bottom</a>
<a name="ln3292">						selEnd = fCaretOffset;</a>
<a name="ln3293">						if (lastClickOffset &lt; fSelEnd) {</a>
<a name="ln3294">							// caret has jumped across &quot;anchor&quot;</a>
<a name="ln3295">							selStart = fSelEnd;</a>
<a name="ln3296">						}</a>
<a name="ln3297">					} else {</a>
<a name="ln3298">						// shrink selection from the top</a>
<a name="ln3299">						selStart = fCaretOffset;</a>
<a name="ln3300">					}</a>
<a name="ln3301">				}</a>
<a name="ln3302">			}</a>
<a name="ln3303">			break;</a>
<a name="ln3304">		}</a>
<a name="ln3305">	}</a>
<a name="ln3306"> </a>
<a name="ln3307">	fStyles-&gt;InvalidateNullStyle();</a>
<a name="ln3308"> </a>
<a name="ln3309">	if (fEditable) {</a>
<a name="ln3310">		if (shiftKeyDown)</a>
<a name="ln3311">			Select(selStart, selEnd);</a>
<a name="ln3312">		else</a>
<a name="ln3313">			Select(fCaretOffset, fCaretOffset);</a>
<a name="ln3314"> </a>
<a name="ln3315">		// scroll if needed</a>
<a name="ln3316">		ScrollToOffset(fCaretOffset);</a>
<a name="ln3317">	}</a>
<a name="ln3318">}</a>
<a name="ln3319"> </a>
<a name="ln3320"> </a>
<a name="ln3321">//!	Handles when the Delete key is pressed.</a>
<a name="ln3322">void</a>
<a name="ln3323">BTextView::_HandleDelete()</a>
<a name="ln3324">{</a>
<a name="ln3325">	if (fUndo) {</a>
<a name="ln3326">		TypingUndoBuffer* undoBuffer = dynamic_cast&lt;TypingUndoBuffer*&gt;(</a>
<a name="ln3327">			fUndo);</a>
<a name="ln3328">		if (!undoBuffer) {</a>
<a name="ln3329">			delete fUndo;</a>
<a name="ln3330">			fUndo = undoBuffer = new TypingUndoBuffer(this);</a>
<a name="ln3331">		}</a>
<a name="ln3332">		undoBuffer-&gt;ForwardErase();</a>
<a name="ln3333">	}</a>
<a name="ln3334"> </a>
<a name="ln3335">	if (fSelStart == fSelEnd) {</a>
<a name="ln3336">		if (fSelEnd == fText-&gt;Length())</a>
<a name="ln3337">			return;</a>
<a name="ln3338">		else</a>
<a name="ln3339">			fSelEnd = _NextInitialByte(fSelEnd);</a>
<a name="ln3340">	} else</a>
<a name="ln3341">		Highlight(fSelStart, fSelEnd);</a>
<a name="ln3342"> </a>
<a name="ln3343">	DeleteText(fSelStart, fSelEnd);</a>
<a name="ln3344">	fCaretOffset = fSelEnd = fSelStart;</a>
<a name="ln3345"> </a>
<a name="ln3346">	_Refresh(fSelStart, fSelEnd, true);</a>
<a name="ln3347">}</a>
<a name="ln3348"> </a>
<a name="ln3349"> </a>
<a name="ln3350">//!	Handles when the Page Up, Page Down, Home, or End key is pressed.</a>
<a name="ln3351">void</a>
<a name="ln3352">BTextView::_HandlePageKey(uint32 pageKey, int32 modifiers)</a>
<a name="ln3353">{</a>
<a name="ln3354">	if (modifiers &lt; 0) {</a>
<a name="ln3355">		BMessage* currentMessage = Window()-&gt;CurrentMessage();</a>
<a name="ln3356">		if (currentMessage == NULL</a>
<a name="ln3357">			|| currentMessage-&gt;FindInt32(&quot;modifiers&quot;, &amp;modifiers) != B_OK) {</a>
<a name="ln3358">			modifiers = 0;</a>
<a name="ln3359">		}</a>
<a name="ln3360">	}</a>
<a name="ln3361"> </a>
<a name="ln3362">	bool shiftKeyDown   = (modifiers &amp; B_SHIFT_KEY)   != 0;</a>
<a name="ln3363">	bool controlKeyDown = (modifiers &amp; B_CONTROL_KEY) != 0;</a>
<a name="ln3364">	bool optionKeyDown  = (modifiers &amp; B_OPTION_KEY)  != 0;</a>
<a name="ln3365">	bool commandKeyDown = (modifiers &amp; B_COMMAND_KEY) != 0;</a>
<a name="ln3366"> </a>
<a name="ln3367">	STELine* line = NULL;</a>
<a name="ln3368">	int32 selStart = fSelStart;</a>
<a name="ln3369">	int32 selEnd = fSelEnd;</a>
<a name="ln3370"> </a>
<a name="ln3371">	int32 lastClickOffset = fCaretOffset;</a>
<a name="ln3372">	switch (pageKey) {</a>
<a name="ln3373">		case B_HOME:</a>
<a name="ln3374">			if (!fEditable) {</a>
<a name="ln3375">				fCaretOffset = 0;</a>
<a name="ln3376">				_ScrollTo(0, 0);</a>
<a name="ln3377">				break;</a>
<a name="ln3378">			} else {</a>
<a name="ln3379">				if (commandKeyDown &amp;&amp; !optionKeyDown &amp;&amp; !controlKeyDown) {</a>
<a name="ln3380">					_ScrollTo(0, 0);</a>
<a name="ln3381">					fCaretOffset = 0;</a>
<a name="ln3382">				} else {</a>
<a name="ln3383">					// get the start of the last line if caret is on it</a>
<a name="ln3384">					line = (*fLines)[_LineAt(lastClickOffset)];</a>
<a name="ln3385">					fCaretOffset = line-&gt;offset;</a>
<a name="ln3386">				}</a>
<a name="ln3387"> </a>
<a name="ln3388">				if (!shiftKeyDown)</a>
<a name="ln3389">					selStart = selEnd = fCaretOffset;</a>
<a name="ln3390">				else if (fCaretOffset != lastClickOffset) {</a>
<a name="ln3391">					if (fCaretOffset &lt; fSelStart) {</a>
<a name="ln3392">						// extend selection to the left</a>
<a name="ln3393">						selStart = fCaretOffset;</a>
<a name="ln3394">						if (lastClickOffset &gt; fSelStart) {</a>
<a name="ln3395">							// caret has jumped across &quot;anchor&quot;</a>
<a name="ln3396">							selEnd = fSelStart;</a>
<a name="ln3397">						}</a>
<a name="ln3398">					} else {</a>
<a name="ln3399">						// shrink selection from the right</a>
<a name="ln3400">						selEnd = fCaretOffset;</a>
<a name="ln3401">					}</a>
<a name="ln3402">				}</a>
<a name="ln3403">			}</a>
<a name="ln3404">			break;</a>
<a name="ln3405"> </a>
<a name="ln3406">		case B_END:</a>
<a name="ln3407">			if (!fEditable) {</a>
<a name="ln3408">				fCaretOffset = fText-&gt;Length();</a>
<a name="ln3409">				_ScrollTo(0, fTextRect.bottom + fLayoutData-&gt;bottomInset);</a>
<a name="ln3410">				break;</a>
<a name="ln3411">			} else {</a>
<a name="ln3412">				if (commandKeyDown &amp;&amp; !optionKeyDown &amp;&amp; !controlKeyDown) {</a>
<a name="ln3413">					_ScrollTo(0, fTextRect.bottom + fLayoutData-&gt;bottomInset);</a>
<a name="ln3414">					fCaretOffset = fText-&gt;Length();</a>
<a name="ln3415">				} else {</a>
<a name="ln3416">					// If we are on the last line, just go to the last</a>
<a name="ln3417">					// character in the buffer, otherwise get the starting</a>
<a name="ln3418">					// offset of the next line, and go to the previous character</a>
<a name="ln3419">					int32 currentLine = _LineAt(lastClickOffset);</a>
<a name="ln3420">					if (currentLine + 1 &lt; fLines-&gt;NumLines()) {</a>
<a name="ln3421">						line = (*fLines)[currentLine + 1];</a>
<a name="ln3422">						fCaretOffset = _PreviousInitialByte(line-&gt;offset);</a>
<a name="ln3423">					} else {</a>
<a name="ln3424">						// This check is needed to avoid moving the cursor</a>
<a name="ln3425">						// when the cursor is on the last line, and that line</a>
<a name="ln3426">						// is empty</a>
<a name="ln3427">						if (fCaretOffset != fText-&gt;Length()) {</a>
<a name="ln3428">							fCaretOffset = fText-&gt;Length();</a>
<a name="ln3429">							if (ByteAt(fCaretOffset - 1) == B_ENTER)</a>
<a name="ln3430">								fCaretOffset--;</a>
<a name="ln3431">						}</a>
<a name="ln3432">					}</a>
<a name="ln3433">				}</a>
<a name="ln3434"> </a>
<a name="ln3435">				if (!shiftKeyDown)</a>
<a name="ln3436">					selStart = selEnd = fCaretOffset;</a>
<a name="ln3437">				else if (fCaretOffset != lastClickOffset) {</a>
<a name="ln3438">					if (fCaretOffset &gt; fSelEnd) {</a>
<a name="ln3439">						// extend selection to the right</a>
<a name="ln3440">						selEnd = fCaretOffset;</a>
<a name="ln3441">						if (lastClickOffset &lt; fSelEnd) {</a>
<a name="ln3442">							// caret has jumped across &quot;anchor&quot;</a>
<a name="ln3443">							selStart = fSelEnd;</a>
<a name="ln3444">						}</a>
<a name="ln3445">					} else {</a>
<a name="ln3446">						// shrink selection from the left</a>
<a name="ln3447">						selStart = fCaretOffset;</a>
<a name="ln3448">					}</a>
<a name="ln3449">				}</a>
<a name="ln3450">			}</a>
<a name="ln3451">			break;</a>
<a name="ln3452"> </a>
<a name="ln3453">		case B_PAGE_UP:</a>
<a name="ln3454">		{</a>
<a name="ln3455">			float lineHeight;</a>
<a name="ln3456">			BPoint currentPos = PointAt(fCaretOffset, &amp;lineHeight);</a>
<a name="ln3457">			BPoint nextPos(currentPos.x,</a>
<a name="ln3458">				currentPos.y + lineHeight - Bounds().Height());</a>
<a name="ln3459">			fCaretOffset = OffsetAt(nextPos);</a>
<a name="ln3460">			nextPos = PointAt(fCaretOffset);</a>
<a name="ln3461">			_ScrollBy(0, nextPos.y - currentPos.y);</a>
<a name="ln3462"> </a>
<a name="ln3463">			if (!fEditable)</a>
<a name="ln3464">				break;</a>
<a name="ln3465"> </a>
<a name="ln3466">			if (!shiftKeyDown)</a>
<a name="ln3467">				selStart = selEnd = fCaretOffset;</a>
<a name="ln3468">			else if (fCaretOffset != lastClickOffset) {</a>
<a name="ln3469">				if (fCaretOffset &lt; fSelStart) {</a>
<a name="ln3470">					// extend selection to the top</a>
<a name="ln3471">					selStart = fCaretOffset;</a>
<a name="ln3472">					if (lastClickOffset &gt; fSelStart) {</a>
<a name="ln3473">						// caret has jumped across &quot;anchor&quot;</a>
<a name="ln3474">						selEnd = fSelStart;</a>
<a name="ln3475">					}</a>
<a name="ln3476">				} else {</a>
<a name="ln3477">					// shrink selection from the bottom</a>
<a name="ln3478">					selEnd = fCaretOffset;</a>
<a name="ln3479">				}</a>
<a name="ln3480">			}</a>
<a name="ln3481"> </a>
<a name="ln3482">			break;</a>
<a name="ln3483">		}</a>
<a name="ln3484"> </a>
<a name="ln3485">		case B_PAGE_DOWN:</a>
<a name="ln3486">		{</a>
<a name="ln3487">			BPoint currentPos = PointAt(fCaretOffset);</a>
<a name="ln3488">			BPoint nextPos(currentPos.x, currentPos.y + Bounds().Height());</a>
<a name="ln3489">			fCaretOffset = OffsetAt(nextPos);</a>
<a name="ln3490">			nextPos = PointAt(fCaretOffset);</a>
<a name="ln3491">			_ScrollBy(0, nextPos.y - currentPos.y);</a>
<a name="ln3492"> </a>
<a name="ln3493">			if (!fEditable)</a>
<a name="ln3494">				break;</a>
<a name="ln3495"> </a>
<a name="ln3496">			if (!shiftKeyDown)</a>
<a name="ln3497">				selStart = selEnd = fCaretOffset;</a>
<a name="ln3498">			else if (fCaretOffset != lastClickOffset) {</a>
<a name="ln3499">				if (fCaretOffset &gt; fSelEnd) {</a>
<a name="ln3500">					// extend selection to the bottom</a>
<a name="ln3501">					selEnd = fCaretOffset;</a>
<a name="ln3502">					if (lastClickOffset &lt; fSelEnd) {</a>
<a name="ln3503">						// caret has jumped across &quot;anchor&quot;</a>
<a name="ln3504">						selStart = fSelEnd;</a>
<a name="ln3505">					}</a>
<a name="ln3506">				} else {</a>
<a name="ln3507">					// shrink selection from the top</a>
<a name="ln3508">					selStart = fCaretOffset;</a>
<a name="ln3509">				}</a>
<a name="ln3510">			}</a>
<a name="ln3511"> </a>
<a name="ln3512">			break;</a>
<a name="ln3513">		}</a>
<a name="ln3514">	}</a>
<a name="ln3515"> </a>
<a name="ln3516">	if (fEditable) {</a>
<a name="ln3517">		if (shiftKeyDown)</a>
<a name="ln3518">			Select(selStart, selEnd);</a>
<a name="ln3519">		else</a>
<a name="ln3520">			Select(fCaretOffset, fCaretOffset);</a>
<a name="ln3521"> </a>
<a name="ln3522">		ScrollToOffset(fCaretOffset);</a>
<a name="ln3523">	}</a>
<a name="ln3524">}</a>
<a name="ln3525"> </a>
<a name="ln3526"> </a>
<a name="ln3527">/*!	Handles when an alpha-numeric key is pressed.</a>
<a name="ln3528"> </a>
<a name="ln3529">	\param bytes The string or character associated with the key.</a>
<a name="ln3530">	\param numBytes The amount of bytes containes in &quot;bytes&quot;.</a>
<a name="ln3531">*/</a>
<a name="ln3532">void</a>
<a name="ln3533">BTextView::_HandleAlphaKey(const char* bytes, int32 numBytes)</a>
<a name="ln3534">{</a>
<a name="ln3535">	// TODO: block input if not editable (Andrew)</a>
<a name="ln3536">	if (fUndo) {</a>
<a name="ln3537">		TypingUndoBuffer* undoBuffer = dynamic_cast&lt;TypingUndoBuffer*&gt;(fUndo);</a>
<a name="ln3538">		if (!undoBuffer) {</a>
<a name="ln3539">			delete fUndo;</a>
<a name="ln3540">			fUndo = undoBuffer = new TypingUndoBuffer(this);</a>
<a name="ln3541">		}</a>
<a name="ln3542">		undoBuffer-&gt;InputCharacter(numBytes);</a>
<a name="ln3543">	}</a>
<a name="ln3544"> </a>
<a name="ln3545">	if (fSelStart != fSelEnd) {</a>
<a name="ln3546">		Highlight(fSelStart, fSelEnd);</a>
<a name="ln3547">		DeleteText(fSelStart, fSelEnd);</a>
<a name="ln3548">	}</a>
<a name="ln3549"> </a>
<a name="ln3550">	if (fAutoindent &amp;&amp; numBytes == 1 &amp;&amp; *bytes == B_ENTER) {</a>
<a name="ln3551">		int32 start, offset;</a>
<a name="ln3552">		start = offset = OffsetAt(_LineAt(fSelStart));</a>
<a name="ln3553"> </a>
<a name="ln3554">		while (ByteAt(offset) != '\0' &amp;&amp;</a>
<a name="ln3555">				(ByteAt(offset) == B_TAB || ByteAt(offset) == B_SPACE)</a>
<a name="ln3556">				&amp;&amp; offset &lt; fSelStart)</a>
<a name="ln3557">			offset++;</a>
<a name="ln3558"> </a>
<a name="ln3559">		_DoInsertText(bytes, numBytes, fSelStart, NULL);</a>
<a name="ln3560">		if (start != offset)</a>
<a name="ln3561">			_DoInsertText(Text() + start, offset - start, fSelStart, NULL);</a>
<a name="ln3562">	} else</a>
<a name="ln3563">		_DoInsertText(bytes, numBytes, fSelStart, NULL);</a>
<a name="ln3564"> </a>
<a name="ln3565">	fCaretOffset = fSelEnd;</a>
<a name="ln3566"> </a>
<a name="ln3567">	ScrollToOffset(fCaretOffset);</a>
<a name="ln3568">}</a>
<a name="ln3569"> </a>
<a name="ln3570"> </a>
<a name="ln3571">/*!	Redraw the text between the two given offsets, recalculating line-breaks</a>
<a name="ln3572">	if needed.</a>
<a name="ln3573"> </a>
<a name="ln3574">	\param fromOffset The offset from where to refresh.</a>
<a name="ln3575">	\param toOffset The offset where to refresh to.</a>
<a name="ln3576">	\param scroll If \c true, scroll the view to the end offset.</a>
<a name="ln3577">*/</a>
<a name="ln3578">void</a>
<a name="ln3579">BTextView::_Refresh(int32 fromOffset, int32 toOffset, bool scroll)</a>
<a name="ln3580">{</a>
<a name="ln3581">	// TODO: Cleanup</a>
<a name="ln3582">	float saveHeight = fTextRect.Height();</a>
<a name="ln3583">	float saveWidth = fTextRect.Width();</a>
<a name="ln3584">	int32 fromLine = _LineAt(fromOffset);</a>
<a name="ln3585">	int32 toLine = _LineAt(toOffset);</a>
<a name="ln3586">	int32 saveFromLine = fromLine;</a>
<a name="ln3587">	int32 saveToLine = toLine;</a>
<a name="ln3588"> </a>
<a name="ln3589">	_RecalculateLineBreaks(&amp;fromLine, &amp;toLine);</a>
<a name="ln3590"> </a>
<a name="ln3591">	// TODO: Maybe there is still something we can do without a window...</a>
<a name="ln3592">	if (!Window())</a>
<a name="ln3593">		return;</a>
<a name="ln3594"> </a>
<a name="ln3595">	BRect bounds = Bounds();</a>
<a name="ln3596">	float newHeight = fTextRect.Height();</a>
<a name="ln3597"> </a>
<a name="ln3598">	// if the line breaks have changed, force an erase</a>
<a name="ln3599">	if (fromLine != saveFromLine || toLine != saveToLine</a>
<a name="ln3600">			|| newHeight != saveHeight) {</a>
<a name="ln3601">		fromOffset = -1;</a>
<a name="ln3602">	}</a>
<a name="ln3603"> </a>
<a name="ln3604">	if (newHeight != saveHeight) {</a>
<a name="ln3605">		// the text area has changed</a>
<a name="ln3606">		if (newHeight &lt; saveHeight)</a>
<a name="ln3607">			toLine = _LineAt(BPoint(0.0f, saveHeight + fTextRect.top));</a>
<a name="ln3608">		else</a>
<a name="ln3609">			toLine = _LineAt(BPoint(0.0f, newHeight + fTextRect.top));</a>
<a name="ln3610">	}</a>
<a name="ln3611"> </a>
<a name="ln3612">	// draw only those lines that are visible</a>
<a name="ln3613">	int32 fromVisible = _LineAt(BPoint(0.0f, bounds.top));</a>
<a name="ln3614">	int32 toVisible = _LineAt(BPoint(0.0f, bounds.bottom));</a>
<a name="ln3615">	fromLine = max_c(fromVisible, fromLine);</a>
<a name="ln3616">	toLine = min_c(toLine, toVisible);</a>
<a name="ln3617"> </a>
<a name="ln3618">	_AutoResize(false);</a>
<a name="ln3619"> </a>
<a name="ln3620">	_RequestDrawLines(fromLine, toLine);</a>
<a name="ln3621"> </a>
<a name="ln3622">	// erase the area below the text</a>
<a name="ln3623">	BRect eraseRect = bounds;</a>
<a name="ln3624">	eraseRect.top = fTextRect.top + (*fLines)[fLines-&gt;NumLines()]-&gt;origin;</a>
<a name="ln3625">	eraseRect.bottom = fTextRect.top + saveHeight;</a>
<a name="ln3626">	if (eraseRect.bottom &gt; eraseRect.top &amp;&amp; eraseRect.Intersects(bounds)) {</a>
<a name="ln3627">		SetLowColor(ViewColor());</a>
<a name="ln3628">		FillRect(eraseRect, B_SOLID_LOW);</a>
<a name="ln3629">	}</a>
<a name="ln3630"> </a>
<a name="ln3631">	// update the scroll bars if the text area has changed</a>
<a name="ln3632">	if (newHeight != saveHeight || fMinTextRectWidth != saveWidth)</a>
<a name="ln3633">		_UpdateScrollbars();</a>
<a name="ln3634"> </a>
<a name="ln3635">	if (scroll)</a>
<a name="ln3636">		ScrollToOffset(fSelEnd);</a>
<a name="ln3637"> </a>
<a name="ln3638">	Flush();</a>
<a name="ln3639">}</a>
<a name="ln3640"> </a>
<a name="ln3641"> </a>
<a name="ln3642">/*!	Recalculate line breaks between two lines.</a>
<a name="ln3643"> </a>
<a name="ln3644">	\param startLine The line number to start recalculating line breaks.</a>
<a name="ln3645">	\param endLine The line number to stop recalculating line breaks.</a>
<a name="ln3646">*/</a>
<a name="ln3647">void</a>
<a name="ln3648">BTextView::_RecalculateLineBreaks(int32* startLine, int32* endLine)</a>
<a name="ln3649">{</a>
<a name="ln3650">	CALLED();</a>
<a name="ln3651"> </a>
<a name="ln3652">	// are we insane?</a>
<a name="ln3653">	*startLine = (*startLine &lt; 0) ? 0 : *startLine;</a>
<a name="ln3654">	*endLine = (*endLine &gt; fLines-&gt;NumLines() - 1) ? fLines-&gt;NumLines() - 1</a>
<a name="ln3655">		: *endLine;</a>
<a name="ln3656"> </a>
<a name="ln3657">	int32 textLength = fText-&gt;Length();</a>
<a name="ln3658">	int32 lineIndex = (*startLine &gt; 0) ? *startLine - 1 : 0;</a>
<a name="ln3659">	int32 recalThreshold = (*fLines)[*endLine + 1]-&gt;offset;</a>
<a name="ln3660">	float width = max_c(fTextRect.Width(), 10);</a>
<a name="ln3661">		// TODO: The minimum width of 10 is a work around for the following</a>
<a name="ln3662">		// problem: If the text rect is too small, we are not calculating any</a>
<a name="ln3663">		// line heights, not even for the first line. Maybe this is a bug</a>
<a name="ln3664">		// in the algorithm, but other places in the class rely on at least</a>
<a name="ln3665">		// the first line to return a valid height. Maybe &quot;10&quot; should really</a>
<a name="ln3666">		// be the width of the very first glyph instead.</a>
<a name="ln3667">	STELine* curLine = (*fLines)[lineIndex];</a>
<a name="ln3668">	STELine* nextLine = curLine + 1;</a>
<a name="ln3669"> </a>
<a name="ln3670">	do {</a>
<a name="ln3671">		float ascent, descent;</a>
<a name="ln3672">		int32 fromOffset = curLine-&gt;offset;</a>
<a name="ln3673">		int32 toOffset = _FindLineBreak(fromOffset, &amp;ascent, &amp;descent, &amp;width);</a>
<a name="ln3674"> </a>
<a name="ln3675">		curLine-&gt;ascent = ascent;</a>
<a name="ln3676">		curLine-&gt;width = width;</a>
<a name="ln3677"> </a>
<a name="ln3678">		// we want to advance at least by one character</a>
<a name="ln3679">		int32 nextOffset = _NextInitialByte(fromOffset);</a>
<a name="ln3680">		if (toOffset &lt; nextOffset &amp;&amp; fromOffset &lt; textLength)</a>
<a name="ln3681">			toOffset = nextOffset;</a>
<a name="ln3682"> </a>
<a name="ln3683">		lineIndex++;</a>
<a name="ln3684">		STELine saveLine = *nextLine;</a>
<a name="ln3685">		if (lineIndex &gt; fLines-&gt;NumLines() || toOffset &lt; nextLine-&gt;offset) {</a>
<a name="ln3686">			// the new line comes before the old line start, add a line</a>
<a name="ln3687">			STELine newLine;</a>
<a name="ln3688">			newLine.offset = toOffset;</a>
<a name="ln3689">			newLine.origin = ceilf(curLine-&gt;origin + ascent + descent) + 1;</a>
<a name="ln3690">			newLine.ascent = 0;</a>
<a name="ln3691">			fLines-&gt;InsertLine(&amp;newLine, lineIndex);</a>
<a name="ln3692">		} else {</a>
<a name="ln3693">			// update the existing line</a>
<a name="ln3694">			nextLine-&gt;offset = toOffset;</a>
<a name="ln3695">			nextLine-&gt;origin = ceilf(curLine-&gt;origin + ascent + descent) + 1;</a>
<a name="ln3696"> </a>
<a name="ln3697">			// remove any lines that start before the current line</a>
<a name="ln3698">			while (lineIndex &lt; fLines-&gt;NumLines()</a>
<a name="ln3699">				&amp;&amp; toOffset &gt;= ((*fLines)[lineIndex] + 1)-&gt;offset) {</a>
<a name="ln3700">				fLines-&gt;RemoveLines(lineIndex + 1);</a>
<a name="ln3701">			}</a>
<a name="ln3702"> </a>
<a name="ln3703">			nextLine = (*fLines)[lineIndex];</a>
<a name="ln3704">			if (nextLine-&gt;offset == saveLine.offset) {</a>
<a name="ln3705">				if (nextLine-&gt;offset &gt;= recalThreshold) {</a>
<a name="ln3706">					if (nextLine-&gt;origin != saveLine.origin)</a>
<a name="ln3707">						fLines-&gt;BumpOrigin(nextLine-&gt;origin - saveLine.origin,</a>
<a name="ln3708">							lineIndex + 1);</a>
<a name="ln3709">					break;</a>
<a name="ln3710">				}</a>
<a name="ln3711">			} else {</a>
<a name="ln3712">				if (lineIndex &gt; 0 &amp;&amp; lineIndex == *startLine)</a>
<a name="ln3713">					*startLine = lineIndex - 1;</a>
<a name="ln3714">			}</a>
<a name="ln3715">		}</a>
<a name="ln3716"> </a>
<a name="ln3717">		curLine = (*fLines)[lineIndex];</a>
<a name="ln3718">		nextLine = curLine + 1;</a>
<a name="ln3719">	} while (curLine-&gt;offset &lt; textLength);</a>
<a name="ln3720"> </a>
<a name="ln3721">	// make sure that the sentinel line (which starts at the end of the buffer)</a>
<a name="ln3722">	// has always a width of 0</a>
<a name="ln3723">	(*fLines)[fLines-&gt;NumLines()]-&gt;width = 0;</a>
<a name="ln3724"> </a>
<a name="ln3725">	// update the text rect</a>
<a name="ln3726">	float newHeight = TextHeight(0, fLines-&gt;NumLines() - 1);</a>
<a name="ln3727">	fTextRect.bottom = fTextRect.top + newHeight;</a>
<a name="ln3728">	if (!fWrap) {</a>
<a name="ln3729">		fMinTextRectWidth = fLines-&gt;MaxWidth();</a>
<a name="ln3730">		fTextRect.right = ceilf(fTextRect.left + fMinTextRectWidth);</a>
<a name="ln3731">	}</a>
<a name="ln3732"> </a>
<a name="ln3733">	*endLine = lineIndex - 1;</a>
<a name="ln3734">	*startLine = min_c(*startLine, *endLine);</a>
<a name="ln3735">}</a>
<a name="ln3736"> </a>
<a name="ln3737"> </a>
<a name="ln3738">int32</a>
<a name="ln3739">BTextView::_FindLineBreak(int32 fromOffset, float* _ascent, float* _descent,</a>
<a name="ln3740">	float* inOutWidth)</a>
<a name="ln3741">{</a>
<a name="ln3742">	*_ascent = 0.0;</a>
<a name="ln3743">	*_descent = 0.0;</a>
<a name="ln3744"> </a>
<a name="ln3745">	const int32 limit = fText-&gt;Length();</a>
<a name="ln3746"> </a>
<a name="ln3747">	// is fromOffset at the end?</a>
<a name="ln3748">	if (fromOffset &gt;= limit) {</a>
<a name="ln3749">		// try to return valid height info anyway</a>
<a name="ln3750">		if (fStyles-&gt;NumRuns() &gt; 0) {</a>
<a name="ln3751">			fStyles-&gt;Iterate(fromOffset, 1, fInline, NULL, NULL, _ascent,</a>
<a name="ln3752">				_descent);</a>
<a name="ln3753">		} else {</a>
<a name="ln3754">			if (fStyles-&gt;IsValidNullStyle()) {</a>
<a name="ln3755">				const BFont* font = NULL;</a>
<a name="ln3756">				fStyles-&gt;GetNullStyle(&amp;font, NULL);</a>
<a name="ln3757"> </a>
<a name="ln3758">				font_height fh;</a>
<a name="ln3759">				font-&gt;GetHeight(&amp;fh);</a>
<a name="ln3760">				*_ascent = fh.ascent;</a>
<a name="ln3761">				*_descent = fh.descent + fh.leading;</a>
<a name="ln3762">			}</a>
<a name="ln3763">		}</a>
<a name="ln3764">		*inOutWidth = 0;</a>
<a name="ln3765"> </a>
<a name="ln3766">		return limit;</a>
<a name="ln3767">	}</a>
<a name="ln3768"> </a>
<a name="ln3769">	int32 offset = fromOffset;</a>
<a name="ln3770"> </a>
<a name="ln3771">	if (!fWrap) {</a>
<a name="ln3772">		// Text wrapping is turned off.</a>
<a name="ln3773">		// Just find the offset of the first \n character</a>
<a name="ln3774">		offset = limit - fromOffset;</a>
<a name="ln3775">		fText-&gt;FindChar(B_ENTER, fromOffset, &amp;offset);</a>
<a name="ln3776">		offset += fromOffset;</a>
<a name="ln3777">		int32 toOffset = (offset &lt; limit) ? offset : limit;</a>
<a name="ln3778"> </a>
<a name="ln3779">		*inOutWidth = _TabExpandedStyledWidth(fromOffset, toOffset - fromOffset,</a>
<a name="ln3780">			_ascent, _descent);</a>
<a name="ln3781"> </a>
<a name="ln3782">		return offset &lt; limit ? offset + 1 : limit;</a>
<a name="ln3783">	}</a>
<a name="ln3784"> </a>
<a name="ln3785">	bool done = false;</a>
<a name="ln3786">	float ascent = 0.0;</a>
<a name="ln3787">	float descent = 0.0;</a>
<a name="ln3788">	int32 delta = 0;</a>
<a name="ln3789">	float deltaWidth = 0.0;</a>
<a name="ln3790">	float strWidth = 0.0;</a>
<a name="ln3791">	uchar theChar;</a>
<a name="ln3792"> </a>
<a name="ln3793">	// wrap the text</a>
<a name="ln3794">	while (offset &lt; limit &amp;&amp; !done) {</a>
<a name="ln3795">		// find the next line break candidate</a>
<a name="ln3796">		for (; (offset + delta) &lt; limit; delta++) {</a>
<a name="ln3797">			if (CanEndLine(offset + delta)) {</a>
<a name="ln3798">				theChar = fText-&gt;RealCharAt(offset + delta);</a>
<a name="ln3799">				if (theChar != B_SPACE &amp;&amp; theChar != B_TAB</a>
<a name="ln3800">					&amp;&amp; theChar != B_ENTER) {</a>
<a name="ln3801">					// we are scanning for trailing whitespace below, so we</a>
<a name="ln3802">					// have to skip non-whitespace characters, that can end</a>
<a name="ln3803">					// the line, here</a>
<a name="ln3804">					delta++;</a>
<a name="ln3805">				}</a>
<a name="ln3806">				break;</a>
<a name="ln3807">			}</a>
<a name="ln3808">		}</a>
<a name="ln3809"> </a>
<a name="ln3810">		int32 deltaBeforeWhitespace = delta;</a>
<a name="ln3811">		// now skip over trailing whitespace, if any</a>
<a name="ln3812">		for (; (offset + delta) &lt; limit; delta++) {</a>
<a name="ln3813">			theChar = fText-&gt;RealCharAt(offset + delta);</a>
<a name="ln3814">			if (theChar == B_ENTER) {</a>
<a name="ln3815">				// found a newline, we're done!</a>
<a name="ln3816">				done = true;</a>
<a name="ln3817">				delta++;</a>
<a name="ln3818">				break;</a>
<a name="ln3819">			} else if (theChar != B_SPACE &amp;&amp; theChar != B_TAB) {</a>
<a name="ln3820">				// stop at anything else than trailing whitespace</a>
<a name="ln3821">				break;</a>
<a name="ln3822">			}</a>
<a name="ln3823">		}</a>
<a name="ln3824"> </a>
<a name="ln3825">		delta = max_c(delta, 1);</a>
<a name="ln3826"> </a>
<a name="ln3827">		// do not include B_ENTER-terminator into width &amp; height calculations</a>
<a name="ln3828">		deltaWidth = _TabExpandedStyledWidth(offset,</a>
<a name="ln3829">								done ? delta - 1 : delta, &amp;ascent, &amp;descent);</a>
<a name="ln3830">		strWidth += deltaWidth;</a>
<a name="ln3831"> </a>
<a name="ln3832">		if (strWidth &gt;= *inOutWidth) {</a>
<a name="ln3833">			// we've found where the line will wrap</a>
<a name="ln3834">			done = true;</a>
<a name="ln3835"> </a>
<a name="ln3836">			// we have included trailing whitespace in the width computation</a>
<a name="ln3837">			// above, but that is not being shown anyway, so we try again</a>
<a name="ln3838">			// without the trailing whitespace</a>
<a name="ln3839">			if (delta == deltaBeforeWhitespace) {</a>
<a name="ln3840">				// there is no trailing whitespace, no point in trying</a>
<a name="ln3841">				break;</a>
<a name="ln3842">			}</a>
<a name="ln3843"> </a>
<a name="ln3844">			// reset string width to start of current run ...</a>
<a name="ln3845">			strWidth -= deltaWidth;</a>
<a name="ln3846"> </a>
<a name="ln3847">			// ... and compute the resulting width (of visible characters)</a>
<a name="ln3848">			strWidth += _StyledWidth(offset, deltaBeforeWhitespace, NULL, NULL);</a>
<a name="ln3849">			if (strWidth &gt;= *inOutWidth) {</a>
<a name="ln3850">				// width of visible characters exceeds line, we need to wrap</a>
<a name="ln3851">				// before the current &quot;word&quot;</a>
<a name="ln3852">				break;</a>
<a name="ln3853">			}</a>
<a name="ln3854">		}</a>
<a name="ln3855"> </a>
<a name="ln3856">		*_ascent = max_c(ascent, *_ascent);</a>
<a name="ln3857">		*_descent = max_c(descent, *_descent);</a>
<a name="ln3858"> </a>
<a name="ln3859">		offset += delta;</a>
<a name="ln3860">		delta = 0;</a>
<a name="ln3861">	}</a>
<a name="ln3862"> </a>
<a name="ln3863">	if (offset - fromOffset &lt; 1) {</a>
<a name="ln3864">		// there weren't any words that fit entirely in this line</a>
<a name="ln3865">		// force a break in the middle of a word</a>
<a name="ln3866">		*_ascent = 0.0;</a>
<a name="ln3867">		*_descent = 0.0;</a>
<a name="ln3868">		strWidth = 0.0;</a>
<a name="ln3869"> </a>
<a name="ln3870">		int32 current = fromOffset;</a>
<a name="ln3871">		for (offset = _NextInitialByte(current); current &lt; limit;</a>
<a name="ln3872">				current = offset, offset = _NextInitialByte(offset)) {</a>
<a name="ln3873">			strWidth += _StyledWidth(current, offset - current, &amp;ascent,</a>
<a name="ln3874">				&amp;descent);</a>
<a name="ln3875">			if (strWidth &gt;= *inOutWidth) {</a>
<a name="ln3876">				offset = _PreviousInitialByte(offset);</a>
<a name="ln3877">				break;</a>
<a name="ln3878">			}</a>
<a name="ln3879"> </a>
<a name="ln3880">			*_ascent = max_c(ascent, *_ascent);</a>
<a name="ln3881">			*_descent = max_c(descent, *_descent);</a>
<a name="ln3882">		}</a>
<a name="ln3883">	}</a>
<a name="ln3884"> </a>
<a name="ln3885">	return min_c(offset, limit);</a>
<a name="ln3886">}</a>
<a name="ln3887"> </a>
<a name="ln3888"> </a>
<a name="ln3889">int32</a>
<a name="ln3890">BTextView::_PreviousLineStart(int32 offset)</a>
<a name="ln3891">{</a>
<a name="ln3892">	if (offset &lt;= 0)</a>
<a name="ln3893">		return 0;</a>
<a name="ln3894"> </a>
<a name="ln3895">	while (offset &gt; 0) {</a>
<a name="ln3896">		offset = _PreviousInitialByte(offset);</a>
<a name="ln3897">		if (_CharClassification(offset) == CHAR_CLASS_WHITESPACE</a>
<a name="ln3898">			&amp;&amp; ByteAt(offset) == B_ENTER) {</a>
<a name="ln3899">			return offset + 1;</a>
<a name="ln3900">		}</a>
<a name="ln3901">	}</a>
<a name="ln3902"> </a>
<a name="ln3903">	return offset;</a>
<a name="ln3904">}</a>
<a name="ln3905"> </a>
<a name="ln3906"> </a>
<a name="ln3907">int32</a>
<a name="ln3908">BTextView::_NextLineEnd(int32 offset)</a>
<a name="ln3909">{</a>
<a name="ln3910">	int32 textLen = fText-&gt;Length();</a>
<a name="ln3911">	if (offset &gt;= textLen)</a>
<a name="ln3912">		return textLen;</a>
<a name="ln3913"> </a>
<a name="ln3914">	while (offset &lt; textLen) {</a>
<a name="ln3915">		if (_CharClassification(offset) == CHAR_CLASS_WHITESPACE</a>
<a name="ln3916">			&amp;&amp; ByteAt(offset) == B_ENTER) {</a>
<a name="ln3917">			break;</a>
<a name="ln3918">		}</a>
<a name="ln3919">		offset = _NextInitialByte(offset);</a>
<a name="ln3920">	}</a>
<a name="ln3921"> </a>
<a name="ln3922">	return offset;</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925"> </a>
<a name="ln3926">int32</a>
<a name="ln3927">BTextView::_PreviousWordBoundary(int32 offset)</a>
<a name="ln3928">{</a>
<a name="ln3929">	uint32 charType = _CharClassification(offset);</a>
<a name="ln3930">	int32 previous;</a>
<a name="ln3931">	while (offset &gt; 0) {</a>
<a name="ln3932">		previous = _PreviousInitialByte(offset);</a>
<a name="ln3933">		if (_CharClassification(previous) != charType)</a>
<a name="ln3934">			break;</a>
<a name="ln3935">		offset = previous;</a>
<a name="ln3936">	}</a>
<a name="ln3937"> </a>
<a name="ln3938">	return offset;</a>
<a name="ln3939">}</a>
<a name="ln3940"> </a>
<a name="ln3941"> </a>
<a name="ln3942">int32</a>
<a name="ln3943">BTextView::_NextWordBoundary(int32 offset)</a>
<a name="ln3944">{</a>
<a name="ln3945">	int32 textLen = fText-&gt;Length();</a>
<a name="ln3946">	uint32 charType = _CharClassification(offset);</a>
<a name="ln3947">	while (offset &lt; textLen) {</a>
<a name="ln3948">		offset = _NextInitialByte(offset);</a>
<a name="ln3949">		if (_CharClassification(offset) != charType)</a>
<a name="ln3950">			break;</a>
<a name="ln3951">	}</a>
<a name="ln3952"> </a>
<a name="ln3953">	return offset;</a>
<a name="ln3954">}</a>
<a name="ln3955"> </a>
<a name="ln3956"> </a>
<a name="ln3957">int32</a>
<a name="ln3958">BTextView::_PreviousWordStart(int32 offset)</a>
<a name="ln3959">{</a>
<a name="ln3960">	if (offset &lt;= 1)</a>
<a name="ln3961">		return 0;</a>
<a name="ln3962"> </a>
<a name="ln3963">	--offset;</a>
<a name="ln3964">		// need to look at previous char</a>
<a name="ln3965">	if (_CharClassification(offset) != CHAR_CLASS_DEFAULT) {</a>
<a name="ln3966">		// skip non-word characters</a>
<a name="ln3967">		while (offset &gt; 0) {</a>
<a name="ln3968">			offset = _PreviousInitialByte(offset);</a>
<a name="ln3969">			if (_CharClassification(offset) == CHAR_CLASS_DEFAULT)</a>
<a name="ln3970">				break;</a>
<a name="ln3971">		}</a>
<a name="ln3972">	}</a>
<a name="ln3973">	while (offset &gt; 0) {</a>
<a name="ln3974">		// skip to start of word</a>
<a name="ln3975">		int32 previous = _PreviousInitialByte(offset);</a>
<a name="ln3976">		if (_CharClassification(previous) != CHAR_CLASS_DEFAULT)</a>
<a name="ln3977">			break;</a>
<a name="ln3978">		offset = previous;</a>
<a name="ln3979">	}</a>
<a name="ln3980"> </a>
<a name="ln3981">	return offset;</a>
<a name="ln3982">}</a>
<a name="ln3983"> </a>
<a name="ln3984"> </a>
<a name="ln3985">int32</a>
<a name="ln3986">BTextView::_NextWordEnd(int32 offset)</a>
<a name="ln3987">{</a>
<a name="ln3988">	int32 textLen = fText-&gt;Length();</a>
<a name="ln3989">	if (_CharClassification(offset) != CHAR_CLASS_DEFAULT) {</a>
<a name="ln3990">		// skip non-word characters</a>
<a name="ln3991">		while (offset &lt; textLen) {</a>
<a name="ln3992">			offset = _NextInitialByte(offset);</a>
<a name="ln3993">			if (_CharClassification(offset) == CHAR_CLASS_DEFAULT)</a>
<a name="ln3994">				break;</a>
<a name="ln3995">		}</a>
<a name="ln3996">	}</a>
<a name="ln3997">	while (offset &lt; textLen) {</a>
<a name="ln3998">		// skip to end of word</a>
<a name="ln3999">		offset = _NextInitialByte(offset);</a>
<a name="ln4000">		if (_CharClassification(offset) != CHAR_CLASS_DEFAULT)</a>
<a name="ln4001">			break;</a>
<a name="ln4002">	}</a>
<a name="ln4003"> </a>
<a name="ln4004">	return offset;</a>
<a name="ln4005">}</a>
<a name="ln4006"> </a>
<a name="ln4007"> </a>
<a name="ln4008">/*!	Returns the width used by the characters starting at the given</a>
<a name="ln4009">	offset with the given length, expanding all tab characters as needed.</a>
<a name="ln4010">*/</a>
<a name="ln4011">float</a>
<a name="ln4012">BTextView::_TabExpandedStyledWidth(int32 offset, int32 length, float* _ascent,</a>
<a name="ln4013">	float* _descent) const</a>
<a name="ln4014">{</a>
<a name="ln4015">	float ascent = 0.0;</a>
<a name="ln4016">	float descent = 0.0;</a>
<a name="ln4017">	float maxAscent = 0.0;</a>
<a name="ln4018">	float maxDescent = 0.0;</a>
<a name="ln4019"> </a>
<a name="ln4020">	float width = 0.0;</a>
<a name="ln4021">	int32 numBytes = length;</a>
<a name="ln4022">	bool foundTab = false;</a>
<a name="ln4023">	do {</a>
<a name="ln4024">		foundTab = fText-&gt;FindChar(B_TAB, offset, &amp;numBytes);</a>
<a name="ln4025">		width += _StyledWidth(offset, numBytes, &amp;ascent, &amp;descent);</a>
<a name="ln4026"> </a>
<a name="ln4027">		if (maxAscent &lt; ascent)</a>
<a name="ln4028">			maxAscent = ascent;</a>
<a name="ln4029">		if (maxDescent &lt; descent)</a>
<a name="ln4030">			maxDescent = descent;</a>
<a name="ln4031"> </a>
<a name="ln4032">		if (foundTab) {</a>
<a name="ln4033">			width += _ActualTabWidth(width);</a>
<a name="ln4034">			numBytes++;</a>
<a name="ln4035">		}</a>
<a name="ln4036"> </a>
<a name="ln4037">		offset += numBytes;</a>
<a name="ln4038">		length -= numBytes;</a>
<a name="ln4039">		numBytes = length;</a>
<a name="ln4040">	} while (foundTab &amp;&amp; length &gt; 0);</a>
<a name="ln4041"> </a>
<a name="ln4042">	if (_ascent != NULL)</a>
<a name="ln4043">		*_ascent = maxAscent;</a>
<a name="ln4044">	if (_descent != NULL)</a>
<a name="ln4045">		*_descent = maxDescent;</a>
<a name="ln4046"> </a>
<a name="ln4047">	return width;</a>
<a name="ln4048">}</a>
<a name="ln4049"> </a>
<a name="ln4050"> </a>
<a name="ln4051">/*!	Calculate the width of the text within the given limits.</a>
<a name="ln4052"> </a>
<a name="ln4053">	\param fromOffset The offset where to start.</a>
<a name="ln4054">	\param length The length of the text to examine.</a>
<a name="ln4055">	\param _ascent A pointer to a float which will contain the maximum ascent.</a>
<a name="ln4056">	\param _descent A pointer to a float which will contain the maximum descent.</a>
<a name="ln4057"> </a>
<a name="ln4058">	\return The width for the text within the given limits.</a>
<a name="ln4059">*/</a>
<a name="ln4060">float</a>
<a name="ln4061">BTextView::_StyledWidth(int32 fromOffset, int32 length, float* _ascent,</a>
<a name="ln4062">	float* _descent) const</a>
<a name="ln4063">{</a>
<a name="ln4064">	if (length == 0) {</a>
<a name="ln4065">		// determine height of char at given offset, but return empty width</a>
<a name="ln4066">		fStyles-&gt;Iterate(fromOffset, 1, fInline, NULL, NULL, _ascent,</a>
<a name="ln4067">			_descent);</a>
<a name="ln4068">		return 0.0;</a>
<a name="ln4069">	}</a>
<a name="ln4070"> </a>
<a name="ln4071">	float result = 0.0;</a>
<a name="ln4072">	float ascent = 0.0;</a>
<a name="ln4073">	float descent = 0.0;</a>
<a name="ln4074">	float maxAscent = 0.0;</a>
<a name="ln4075">	float maxDescent = 0.0;</a>
<a name="ln4076"> </a>
<a name="ln4077">	// iterate through the style runs</a>
<a name="ln4078">	const BFont* font = NULL;</a>
<a name="ln4079">	int32 numBytes;</a>
<a name="ln4080">	while ((numBytes = fStyles-&gt;Iterate(fromOffset, length, fInline, &amp;font,</a>
<a name="ln4081">			NULL, &amp;ascent, &amp;descent)) != 0) {</a>
<a name="ln4082">		maxAscent = max_c(ascent, maxAscent);</a>
<a name="ln4083">		maxDescent = max_c(descent, maxDescent);</a>
<a name="ln4084"> </a>
<a name="ln4085">#if USE_WIDTHBUFFER</a>
<a name="ln4086">		// Use _BWidthBuffer_ if possible</a>
<a name="ln4087">		if (BPrivate::gWidthBuffer != NULL) {</a>
<a name="ln4088">			result += BPrivate::gWidthBuffer-&gt;StringWidth(*fText, fromOffset,</a>
<a name="ln4089">				numBytes, font);</a>
<a name="ln4090">		} else {</a>
<a name="ln4091">#endif</a>
<a name="ln4092">			const char* text = fText-&gt;GetString(fromOffset, &amp;numBytes);</a>
<a name="ln4093">			result += font-&gt;StringWidth(text, numBytes);</a>
<a name="ln4094"> </a>
<a name="ln4095">#if USE_WIDTHBUFFER</a>
<a name="ln4096">		}</a>
<a name="ln4097">#endif</a>
<a name="ln4098"> </a>
<a name="ln4099">		fromOffset += numBytes;</a>
<a name="ln4100">		length -= numBytes;</a>
<a name="ln4101">	}</a>
<a name="ln4102"> </a>
<a name="ln4103">	if (_ascent != NULL)</a>
<a name="ln4104">		*_ascent = maxAscent;</a>
<a name="ln4105">	if (_descent != NULL)</a>
<a name="ln4106">		*_descent = maxDescent;</a>
<a name="ln4107"> </a>
<a name="ln4108">	return result;</a>
<a name="ln4109">}</a>
<a name="ln4110"> </a>
<a name="ln4111"> </a>
<a name="ln4112">//!	Calculate the actual tab width for the given location.</a>
<a name="ln4113">float</a>
<a name="ln4114">BTextView::_ActualTabWidth(float location) const</a>
<a name="ln4115">{</a>
<a name="ln4116">	float tabWidth = fTabWidth - fmod(location, fTabWidth);</a>
<a name="ln4117">	if (round(tabWidth) == 0)</a>
<a name="ln4118">		tabWidth = fTabWidth;</a>
<a name="ln4119"> </a>
<a name="ln4120">	return tabWidth;</a>
<a name="ln4121">}</a>
<a name="ln4122"> </a>
<a name="ln4123"> </a>
<a name="ln4124">void</a>
<a name="ln4125">BTextView::_DoInsertText(const char* text, int32 length, int32 offset,</a>
<a name="ln4126">	const text_run_array* runs)</a>
<a name="ln4127">{</a>
<a name="ln4128">	_CancelInputMethod();</a>
<a name="ln4129"> </a>
<a name="ln4130">	if (TextLength() + length &gt; MaxBytes())</a>
<a name="ln4131">		return;</a>
<a name="ln4132"> </a>
<a name="ln4133">	if (fSelStart != fSelEnd)</a>
<a name="ln4134">		Select(fSelStart, fSelStart);</a>
<a name="ln4135"> </a>
<a name="ln4136">	const int32 textLength = TextLength();</a>
<a name="ln4137">	if (offset &gt; textLength)</a>
<a name="ln4138">		offset = textLength;</a>
<a name="ln4139"> </a>
<a name="ln4140">	// copy data into buffer</a>
<a name="ln4141">	InsertText(text, length, offset, runs);</a>
<a name="ln4142"> </a>
<a name="ln4143">	// recalc line breaks and draw the text</a>
<a name="ln4144">	_Refresh(offset, offset + length, false);</a>
<a name="ln4145">}</a>
<a name="ln4146"> </a>
<a name="ln4147"> </a>
<a name="ln4148">void</a>
<a name="ln4149">BTextView::_DoDeleteText(int32 fromOffset, int32 toOffset)</a>
<a name="ln4150">{</a>
<a name="ln4151">	CALLED();</a>
<a name="ln4152">}</a>
<a name="ln4153"> </a>
<a name="ln4154"> </a>
<a name="ln4155">void</a>
<a name="ln4156">BTextView::_DrawLine(BView* view, const int32 &amp;lineNum,</a>
<a name="ln4157">	const int32 &amp;startOffset, const bool &amp;erase, BRect &amp;eraseRect,</a>
<a name="ln4158">	BRegion &amp;inputRegion)</a>
<a name="ln4159">{</a>
<a name="ln4160">	STELine* line = (*fLines)[lineNum];</a>
<a name="ln4161">	float startLeft = fTextRect.left;</a>
<a name="ln4162">	if (startOffset != -1) {</a>
<a name="ln4163">		if (ByteAt(startOffset) == B_ENTER) {</a>
<a name="ln4164">			// StartOffset is a newline</a>
<a name="ln4165">			startLeft = PointAt(line-&gt;offset).x;</a>
<a name="ln4166">		} else</a>
<a name="ln4167">			startLeft = PointAt(startOffset).x;</a>
<a name="ln4168">	}</a>
<a name="ln4169">	else if (fAlignment != B_ALIGN_LEFT) {</a>
<a name="ln4170">		float alignmentOffset = fTextRect.Width() - LineWidth(lineNum);</a>
<a name="ln4171">		if (fAlignment == B_ALIGN_CENTER)</a>
<a name="ln4172">			alignmentOffset /= 2;</a>
<a name="ln4173">		startLeft = fTextRect.left + alignmentOffset;</a>
<a name="ln4174">	}</a>
<a name="ln4175"> </a>
<a name="ln4176">	int32 length = (line + 1)-&gt;offset;</a>
<a name="ln4177">	if (startOffset != -1)</a>
<a name="ln4178">		length -= startOffset;</a>
<a name="ln4179">	else</a>
<a name="ln4180">		length -= line-&gt;offset;</a>
<a name="ln4181"> </a>
<a name="ln4182">	// DrawString() chokes if you draw a newline</a>
<a name="ln4183">	if (ByteAt((line + 1)-&gt;offset - 1) == B_ENTER)</a>
<a name="ln4184">		length--;</a>
<a name="ln4185"> </a>
<a name="ln4186">	view-&gt;MovePenTo(startLeft, line-&gt;origin + line-&gt;ascent + fTextRect.top + 1);</a>
<a name="ln4187"> </a>
<a name="ln4188">	if (erase) {</a>
<a name="ln4189">		eraseRect.top = line-&gt;origin + fTextRect.top;</a>
<a name="ln4190">		eraseRect.bottom = (line + 1)-&gt;origin + fTextRect.top;</a>
<a name="ln4191">		view-&gt;FillRect(eraseRect, B_SOLID_LOW);</a>
<a name="ln4192">	}</a>
<a name="ln4193"> </a>
<a name="ln4194">	// do we have any text to draw?</a>
<a name="ln4195">	if (length &lt;= 0)</a>
<a name="ln4196">		return;</a>
<a name="ln4197"> </a>
<a name="ln4198">	bool foundTab = false;</a>
<a name="ln4199">	int32 tabChars = 0;</a>
<a name="ln4200">	int32 numTabs = 0;</a>
<a name="ln4201">	int32 offset = startOffset != -1 ? startOffset : line-&gt;offset;</a>
<a name="ln4202">	const BFont* font = NULL;</a>
<a name="ln4203">	const rgb_color* color = NULL;</a>
<a name="ln4204">	int32 numBytes;</a>
<a name="ln4205">	drawing_mode defaultTextRenderingMode = DrawingMode();</a>
<a name="ln4206">	// iterate through each style on this line</a>
<a name="ln4207">	while ((numBytes = fStyles-&gt;Iterate(offset, length, fInline, &amp;font,</a>
<a name="ln4208">			&amp;color)) != 0) {</a>
<a name="ln4209">		view-&gt;SetFont(font);</a>
<a name="ln4210">		view-&gt;SetHighColor(*color);</a>
<a name="ln4211"> </a>
<a name="ln4212">		tabChars = min_c(numBytes, length);</a>
<a name="ln4213">		do {</a>
<a name="ln4214">			foundTab = fText-&gt;FindChar(B_TAB, offset, &amp;tabChars);</a>
<a name="ln4215">			if (foundTab) {</a>
<a name="ln4216">				do {</a>
<a name="ln4217">					numTabs++;</a>
<a name="ln4218">					if (ByteAt(offset + tabChars + numTabs) != B_TAB)</a>
<a name="ln4219">						break;</a>
<a name="ln4220">				} while ((tabChars + numTabs) &lt; numBytes);</a>
<a name="ln4221">			}</a>
<a name="ln4222"> </a>
<a name="ln4223">			drawing_mode textRenderingMode = defaultTextRenderingMode;</a>
<a name="ln4224"> </a>
<a name="ln4225">			if (inputRegion.CountRects() &gt; 0</a>
<a name="ln4226">				&amp;&amp; ((offset &lt;= fInline-&gt;Offset()</a>
<a name="ln4227">					&amp;&amp; fInline-&gt;Offset() &lt; offset + tabChars)</a>
<a name="ln4228">				|| (fInline-&gt;Offset() &lt;= offset</a>
<a name="ln4229">					&amp;&amp; offset &lt; fInline-&gt;Offset() + fInline-&gt;Length()))) {</a>
<a name="ln4230"> </a>
<a name="ln4231">				textRenderingMode = B_OP_OVER;</a>
<a name="ln4232"> </a>
<a name="ln4233">				BRegion textRegion;</a>
<a name="ln4234">				GetTextRegion(offset, offset + length, &amp;textRegion);</a>
<a name="ln4235"> </a>
<a name="ln4236">				textRegion.IntersectWith(&amp;inputRegion);</a>
<a name="ln4237">				view-&gt;PushState();</a>
<a name="ln4238"> </a>
<a name="ln4239">				// Highlight in blue the inputted text</a>
<a name="ln4240">				view-&gt;SetHighColor(kBlueInputColor);</a>
<a name="ln4241">				view-&gt;FillRect(textRegion.Frame());</a>
<a name="ln4242"> </a>
<a name="ln4243">				// Highlight in red the selected part</a>
<a name="ln4244">				if (fInline-&gt;SelectionLength() &gt; 0) {</a>
<a name="ln4245">					BRegion selectedRegion;</a>
<a name="ln4246">					GetTextRegion(fInline-&gt;Offset()</a>
<a name="ln4247">						+ fInline-&gt;SelectionOffset(), fInline-&gt;Offset()</a>
<a name="ln4248">						+ fInline-&gt;SelectionOffset()</a>
<a name="ln4249">						+ fInline-&gt;SelectionLength(), &amp;selectedRegion);</a>
<a name="ln4250"> </a>
<a name="ln4251">					textRegion.IntersectWith(&amp;selectedRegion);</a>
<a name="ln4252"> </a>
<a name="ln4253">					view-&gt;SetHighColor(kRedInputColor);</a>
<a name="ln4254">					view-&gt;FillRect(textRegion.Frame());</a>
<a name="ln4255">				}</a>
<a name="ln4256"> </a>
<a name="ln4257">				view-&gt;PopState();</a>
<a name="ln4258">			}</a>
<a name="ln4259"> </a>
<a name="ln4260">			int32 returnedBytes = tabChars;</a>
<a name="ln4261">			const char* stringToDraw = fText-&gt;GetString(offset, &amp;returnedBytes);</a>
<a name="ln4262">			view-&gt;SetDrawingMode(textRenderingMode);</a>
<a name="ln4263">			view-&gt;DrawString(stringToDraw, returnedBytes);</a>
<a name="ln4264">			if (foundTab) {</a>
<a name="ln4265">				float penPos = PenLocation().x - fTextRect.left;</a>
<a name="ln4266">				float tabWidth = _ActualTabWidth(penPos);</a>
<a name="ln4267">				if (numTabs &gt; 1)</a>
<a name="ln4268">					tabWidth += ((numTabs - 1) * fTabWidth);</a>
<a name="ln4269"> </a>
<a name="ln4270">				view-&gt;MovePenBy(tabWidth, 0.0);</a>
<a name="ln4271">				tabChars += numTabs;</a>
<a name="ln4272">			}</a>
<a name="ln4273"> </a>
<a name="ln4274">			offset += tabChars;</a>
<a name="ln4275">			length -= tabChars;</a>
<a name="ln4276">			numBytes -= tabChars;</a>
<a name="ln4277">			tabChars = min_c(numBytes, length);</a>
<a name="ln4278">			numTabs = 0;</a>
<a name="ln4279">		} while (foundTab &amp;&amp; tabChars &gt; 0);</a>
<a name="ln4280">	}</a>
<a name="ln4281">}</a>
<a name="ln4282"> </a>
<a name="ln4283"> </a>
<a name="ln4284">void</a>
<a name="ln4285">BTextView::_DrawLines(int32 startLine, int32 endLine, int32 startOffset,</a>
<a name="ln4286">	bool erase)</a>
<a name="ln4287">{</a>
<a name="ln4288">	if (!Window())</a>
<a name="ln4289">		return;</a>
<a name="ln4290"> </a>
<a name="ln4291">	// clip the text</a>
<a name="ln4292">	BRect textRect(fTextRect);</a>
<a name="ln4293">	float minWidth</a>
<a name="ln4294">		= Bounds().Width() - fLayoutData-&gt;leftInset - fLayoutData-&gt;rightInset;</a>
<a name="ln4295">	if (textRect.Width() &lt; minWidth)</a>
<a name="ln4296">		textRect.right = textRect.left + minWidth;</a>
<a name="ln4297">	BRect clipRect = Bounds() &amp; textRect;</a>
<a name="ln4298">	clipRect.InsetBy(-1, -1);</a>
<a name="ln4299"> </a>
<a name="ln4300">	BRegion newClip;</a>
<a name="ln4301">	newClip.Set(clipRect);</a>
<a name="ln4302">	ConstrainClippingRegion(&amp;newClip);</a>
<a name="ln4303"> </a>
<a name="ln4304">	// set the low color to the view color so that</a>
<a name="ln4305">	// drawing to a non-white background will work</a>
<a name="ln4306">	SetLowColor(ViewColor());</a>
<a name="ln4307"> </a>
<a name="ln4308">	BView* view = NULL;</a>
<a name="ln4309">	if (fOffscreen == NULL)</a>
<a name="ln4310">		view = this;</a>
<a name="ln4311">	else {</a>
<a name="ln4312">		fOffscreen-&gt;Lock();</a>
<a name="ln4313">		view = fOffscreen-&gt;ChildAt(0);</a>
<a name="ln4314">		view-&gt;SetLowColor(ViewColor());</a>
<a name="ln4315">		view-&gt;FillRect(view-&gt;Bounds(), B_SOLID_LOW);</a>
<a name="ln4316">	}</a>
<a name="ln4317"> </a>
<a name="ln4318">	long maxLine = fLines-&gt;NumLines() - 1;</a>
<a name="ln4319">	if (startLine &lt; 0)</a>
<a name="ln4320">		startLine = 0;</a>
<a name="ln4321">	if (endLine &gt; maxLine)</a>
<a name="ln4322">		endLine = maxLine;</a>
<a name="ln4323"> </a>
<a name="ln4324">	// TODO: See if we can avoid this</a>
<a name="ln4325">	if (fAlignment != B_ALIGN_LEFT)</a>
<a name="ln4326">		erase = true;</a>
<a name="ln4327"> </a>
<a name="ln4328">	BRect eraseRect = clipRect;</a>
<a name="ln4329">	int32 startEraseLine = startLine;</a>
<a name="ln4330">	STELine* line = (*fLines)[startLine];</a>
<a name="ln4331"> </a>
<a name="ln4332">	if (erase &amp;&amp; startOffset != -1 &amp;&amp; fAlignment == B_ALIGN_LEFT) {</a>
<a name="ln4333">		// erase only to the right of startOffset</a>
<a name="ln4334">		startEraseLine++;</a>
<a name="ln4335">		int32 startErase = startOffset;</a>
<a name="ln4336"> </a>
<a name="ln4337">		BPoint erasePoint = PointAt(startErase);</a>
<a name="ln4338">		eraseRect.left = erasePoint.x;</a>
<a name="ln4339">		eraseRect.top = erasePoint.y;</a>
<a name="ln4340">		eraseRect.bottom = (line + 1)-&gt;origin + fTextRect.top;</a>
<a name="ln4341"> </a>
<a name="ln4342">		view-&gt;FillRect(eraseRect, B_SOLID_LOW);</a>
<a name="ln4343"> </a>
<a name="ln4344">		eraseRect = clipRect;</a>
<a name="ln4345">	}</a>
<a name="ln4346"> </a>
<a name="ln4347">	BRegion inputRegion;</a>
<a name="ln4348">	if (fInline != NULL &amp;&amp; fInline-&gt;IsActive()) {</a>
<a name="ln4349">		GetTextRegion(fInline-&gt;Offset(), fInline-&gt;Offset() + fInline-&gt;Length(),</a>
<a name="ln4350">			&amp;inputRegion);</a>
<a name="ln4351">	}</a>
<a name="ln4352"> </a>
<a name="ln4353">	//BPoint leftTop(startLeft, line-&gt;origin);</a>
<a name="ln4354">	for (int32 lineNum = startLine; lineNum &lt;= endLine; lineNum++) {</a>
<a name="ln4355">		const bool eraseThisLine = erase &amp;&amp; lineNum &gt;= startEraseLine;</a>
<a name="ln4356">		_DrawLine(view, lineNum, startOffset, eraseThisLine, eraseRect,</a>
<a name="ln4357">			inputRegion);</a>
<a name="ln4358">		startOffset = -1;</a>
<a name="ln4359">			// Set this to -1 so the next iteration will use the line offset</a>
<a name="ln4360">	}</a>
<a name="ln4361"> </a>
<a name="ln4362">	// draw the caret/hilite the selection</a>
<a name="ln4363">	if (fActive) {</a>
<a name="ln4364">		if (fSelStart != fSelEnd) {</a>
<a name="ln4365">			if (fSelectable)</a>
<a name="ln4366">				Highlight(fSelStart, fSelEnd);</a>
<a name="ln4367">		} else {</a>
<a name="ln4368">			if (fCaretVisible)</a>
<a name="ln4369">				_DrawCaret(fSelStart, true);</a>
<a name="ln4370">		}</a>
<a name="ln4371">	}</a>
<a name="ln4372"> </a>
<a name="ln4373">	if (fOffscreen != NULL) {</a>
<a name="ln4374">		view-&gt;Sync();</a>
<a name="ln4375">		/*BPoint penLocation = view-&gt;PenLocation();</a>
<a name="ln4376">		BRect drawRect(leftTop.x, leftTop.y, penLocation.x, penLocation.y);</a>
<a name="ln4377">		DrawBitmap(fOffscreen, drawRect, drawRect);*/</a>
<a name="ln4378">		fOffscreen-&gt;Unlock();</a>
<a name="ln4379">	}</a>
<a name="ln4380"> </a>
<a name="ln4381">	ConstrainClippingRegion(NULL);</a>
<a name="ln4382">}</a>
<a name="ln4383"> </a>
<a name="ln4384"> </a>
<a name="ln4385">void</a>
<a name="ln4386">BTextView::_RequestDrawLines(int32 startLine, int32 endLine)</a>
<a name="ln4387">{</a>
<a name="ln4388">	if (!Window())</a>
<a name="ln4389">		return;</a>
<a name="ln4390"> </a>
<a name="ln4391">	long maxLine = fLines-&gt;NumLines() - 1;</a>
<a name="ln4392"> </a>
<a name="ln4393">	STELine* from = (*fLines)[startLine];</a>
<a name="ln4394">	STELine* to = endLine == maxLine ? NULL : (*fLines)[endLine + 1];</a>
<a name="ln4395">	BRect invalidRect(Bounds().left, from-&gt;origin + fTextRect.top,</a>
<a name="ln4396">		Bounds().right,</a>
<a name="ln4397">		to != NULL ? to-&gt;origin + fTextRect.top : fTextRect.bottom);</a>
<a name="ln4398">	Invalidate(invalidRect);</a>
<a name="ln4399">	Window()-&gt;UpdateIfNeeded();</a>
<a name="ln4400">}</a>
<a name="ln4401"> </a>
<a name="ln4402"> </a>
<a name="ln4403">void</a>
<a name="ln4404">BTextView::_DrawCaret(int32 offset, bool visible)</a>
<a name="ln4405">{</a>
<a name="ln4406">	float lineHeight;</a>
<a name="ln4407">	BPoint caretPoint = PointAt(offset, &amp;lineHeight);</a>
<a name="ln4408">	caretPoint.x = min_c(caretPoint.x, fTextRect.right);</a>
<a name="ln4409"> </a>
<a name="ln4410">	BRect caretRect;</a>
<a name="ln4411">	caretRect.left = caretRect.right = caretPoint.x;</a>
<a name="ln4412">	caretRect.top = caretPoint.y;</a>
<a name="ln4413">	caretRect.bottom = caretPoint.y + lineHeight - 1;</a>
<a name="ln4414"> </a>
<a name="ln4415">	if (visible)</a>
<a name="ln4416">		InvertRect(caretRect);</a>
<a name="ln4417">	else</a>
<a name="ln4418">		Invalidate(caretRect);</a>
<a name="ln4419">}</a>
<a name="ln4420"> </a>
<a name="ln4421"> </a>
<a name="ln4422">inline void</a>
<a name="ln4423">BTextView::_ShowCaret()</a>
<a name="ln4424">{</a>
<a name="ln4425">	if (fActive &amp;&amp; !fCaretVisible &amp;&amp; fEditable &amp;&amp; fSelStart == fSelEnd)</a>
<a name="ln4426">		_InvertCaret();</a>
<a name="ln4427">}</a>
<a name="ln4428"> </a>
<a name="ln4429"> </a>
<a name="ln4430">inline void</a>
<a name="ln4431">BTextView::_HideCaret()</a>
<a name="ln4432">{</a>
<a name="ln4433">	if (fCaretVisible &amp;&amp; fSelStart == fSelEnd)</a>
<a name="ln4434">		_InvertCaret();</a>
<a name="ln4435">}</a>
<a name="ln4436"> </a>
<a name="ln4437"> </a>
<a name="ln4438">//!	Hides the caret if it is being shown, and if it's hidden, shows it.</a>
<a name="ln4439">void</a>
<a name="ln4440">BTextView::_InvertCaret()</a>
<a name="ln4441">{</a>
<a name="ln4442">	fCaretVisible = !fCaretVisible;</a>
<a name="ln4443">	_DrawCaret(fSelStart, fCaretVisible);</a>
<a name="ln4444">	fCaretTime = system_time();</a>
<a name="ln4445">}</a>
<a name="ln4446"> </a>
<a name="ln4447"> </a>
<a name="ln4448">/*!	Place the dragging caret at the given offset.</a>
<a name="ln4449"> </a>
<a name="ln4450">	\param offset The offset (zero based within the object's text) where to</a>
<a name="ln4451">	       place the dragging caret. If it's -1, hide the caret.</a>
<a name="ln4452">*/</a>
<a name="ln4453">void</a>
<a name="ln4454">BTextView::_DragCaret(int32 offset)</a>
<a name="ln4455">{</a>
<a name="ln4456">	// does the caret need to move?</a>
<a name="ln4457">	if (offset == fDragOffset)</a>
<a name="ln4458">		return;</a>
<a name="ln4459"> </a>
<a name="ln4460">	// hide the previous drag caret</a>
<a name="ln4461">	if (fDragOffset != -1)</a>
<a name="ln4462">		_DrawCaret(fDragOffset, false);</a>
<a name="ln4463"> </a>
<a name="ln4464">	// do we have a new location?</a>
<a name="ln4465">	if (offset != -1) {</a>
<a name="ln4466">		if (fActive) {</a>
<a name="ln4467">			// ignore if offset is within active selection</a>
<a name="ln4468">			if (offset &gt;= fSelStart &amp;&amp; offset &lt;= fSelEnd) {</a>
<a name="ln4469">				fDragOffset = -1;</a>
<a name="ln4470">				return;</a>
<a name="ln4471">			}</a>
<a name="ln4472">		}</a>
<a name="ln4473"> </a>
<a name="ln4474">		_DrawCaret(offset, true);</a>
<a name="ln4475">	}</a>
<a name="ln4476"> </a>
<a name="ln4477">	fDragOffset = offset;</a>
<a name="ln4478">}</a>
<a name="ln4479"> </a>
<a name="ln4480"> </a>
<a name="ln4481">void</a>
<a name="ln4482">BTextView::_StopMouseTracking()</a>
<a name="ln4483">{</a>
<a name="ln4484">	delete fTrackingMouse;</a>
<a name="ln4485">	fTrackingMouse = NULL;</a>
<a name="ln4486">}</a>
<a name="ln4487"> </a>
<a name="ln4488"> </a>
<a name="ln4489">bool</a>
<a name="ln4490">BTextView::_PerformMouseUp(BPoint where)</a>
<a name="ln4491">{</a>
<a name="ln4492">	if (fTrackingMouse == NULL)</a>
<a name="ln4493">		return false;</a>
<a name="ln4494"> </a>
<a name="ln4495">	if (fTrackingMouse-&gt;selectionRect.IsValid())</a>
<a name="ln4496">		Select(fTrackingMouse-&gt;clickOffset, fTrackingMouse-&gt;clickOffset);</a>
<a name="ln4497"> </a>
<a name="ln4498">	_StopMouseTracking();</a>
<a name="ln4499">	// adjust cursor if necessary</a>
<a name="ln4500">	_TrackMouse(where, NULL, true);</a>
<a name="ln4501"> </a>
<a name="ln4502">	return true;</a>
<a name="ln4503">}</a>
<a name="ln4504"> </a>
<a name="ln4505"> </a>
<a name="ln4506">bool</a>
<a name="ln4507">BTextView::_PerformMouseMoved(BPoint where, uint32 code)</a>
<a name="ln4508">{</a>
<a name="ln4509">	fWhere = where;</a>
<a name="ln4510"> </a>
<a name="ln4511">	if (fTrackingMouse == NULL)</a>
<a name="ln4512">		return false;</a>
<a name="ln4513"> </a>
<a name="ln4514">	int32 currentOffset = OffsetAt(where);</a>
<a name="ln4515">	if (fTrackingMouse-&gt;selectionRect.IsValid()) {</a>
<a name="ln4516">		// we are tracking the mouse for drag action, if the mouse has moved</a>
<a name="ln4517">		// to another index or more than three pixels from where it was clicked,</a>
<a name="ln4518">		// we initiate a drag now:</a>
<a name="ln4519">		if (currentOffset != fTrackingMouse-&gt;clickOffset</a>
<a name="ln4520">			|| fabs(fTrackingMouse-&gt;where.x - where.x) &gt; 3</a>
<a name="ln4521">			|| fabs(fTrackingMouse-&gt;where.y - where.y) &gt; 3) {</a>
<a name="ln4522">			_StopMouseTracking();</a>
<a name="ln4523">			_InitiateDrag();</a>
<a name="ln4524">			return true;</a>
<a name="ln4525">		}</a>
<a name="ln4526">		return false;</a>
<a name="ln4527">	}</a>
<a name="ln4528"> </a>
<a name="ln4529">	switch (fClickCount) {</a>
<a name="ln4530">		case 3:</a>
<a name="ln4531">			// triple click, extend selection linewise</a>
<a name="ln4532">			if (currentOffset &lt;= fTrackingMouse-&gt;anchor) {</a>
<a name="ln4533">				fTrackingMouse-&gt;selStart</a>
<a name="ln4534">					= (*fLines)[_LineAt(currentOffset)]-&gt;offset;</a>
<a name="ln4535">				fTrackingMouse-&gt;selEnd = fTrackingMouse-&gt;shiftDown</a>
<a name="ln4536">					? fSelEnd</a>
<a name="ln4537">					: (*fLines)[_LineAt(fTrackingMouse-&gt;anchor) + 1]-&gt;offset;</a>
<a name="ln4538">			} else {</a>
<a name="ln4539">				fTrackingMouse-&gt;selStart</a>
<a name="ln4540">					= fTrackingMouse-&gt;shiftDown</a>
<a name="ln4541">						? fSelStart</a>
<a name="ln4542">						: (*fLines)[_LineAt(fTrackingMouse-&gt;anchor)]-&gt;offset;</a>
<a name="ln4543">				fTrackingMouse-&gt;selEnd</a>
<a name="ln4544">					= (*fLines)[_LineAt(currentOffset) + 1]-&gt;offset;</a>
<a name="ln4545">			}</a>
<a name="ln4546">			break;</a>
<a name="ln4547"> </a>
<a name="ln4548">		case 2:</a>
<a name="ln4549">			// double click, extend selection wordwise</a>
<a name="ln4550">			if (currentOffset &lt;= fTrackingMouse-&gt;anchor) {</a>
<a name="ln4551">				fTrackingMouse-&gt;selStart = _PreviousWordBoundary(currentOffset);</a>
<a name="ln4552">				fTrackingMouse-&gt;selEnd</a>
<a name="ln4553">					= fTrackingMouse-&gt;shiftDown</a>
<a name="ln4554">						? fSelEnd</a>
<a name="ln4555">						: _NextWordBoundary(fTrackingMouse-&gt;anchor);</a>
<a name="ln4556">			} else {</a>
<a name="ln4557">				fTrackingMouse-&gt;selStart</a>
<a name="ln4558">					= fTrackingMouse-&gt;shiftDown</a>
<a name="ln4559">						? fSelStart</a>
<a name="ln4560">						: _PreviousWordBoundary(fTrackingMouse-&gt;anchor);</a>
<a name="ln4561">				fTrackingMouse-&gt;selEnd = _NextWordBoundary(currentOffset);</a>
<a name="ln4562">			}</a>
<a name="ln4563">			break;</a>
<a name="ln4564"> </a>
<a name="ln4565">		default:</a>
<a name="ln4566">			// new click, extend selection char by char</a>
<a name="ln4567">			if (currentOffset &lt;= fTrackingMouse-&gt;anchor) {</a>
<a name="ln4568">				fTrackingMouse-&gt;selStart = currentOffset;</a>
<a name="ln4569">				fTrackingMouse-&gt;selEnd</a>
<a name="ln4570">					= fTrackingMouse-&gt;shiftDown</a>
<a name="ln4571">						? fSelEnd : fTrackingMouse-&gt;anchor;</a>
<a name="ln4572">			} else {</a>
<a name="ln4573">				fTrackingMouse-&gt;selStart</a>
<a name="ln4574">					= fTrackingMouse-&gt;shiftDown</a>
<a name="ln4575">						? fSelStart : fTrackingMouse-&gt;anchor;</a>
<a name="ln4576">				fTrackingMouse-&gt;selEnd = currentOffset;</a>
<a name="ln4577">			}</a>
<a name="ln4578">			break;</a>
<a name="ln4579">	}</a>
<a name="ln4580"> </a>
<a name="ln4581">	// position caret to follow the direction of the selection</a>
<a name="ln4582">	if (fTrackingMouse-&gt;selEnd != fSelEnd)</a>
<a name="ln4583">		fCaretOffset = fTrackingMouse-&gt;selEnd;</a>
<a name="ln4584">	else if (fTrackingMouse-&gt;selStart != fSelStart)</a>
<a name="ln4585">		fCaretOffset = fTrackingMouse-&gt;selStart;</a>
<a name="ln4586"> </a>
<a name="ln4587">	Select(fTrackingMouse-&gt;selStart, fTrackingMouse-&gt;selEnd);</a>
<a name="ln4588">	_TrackMouse(where, NULL);</a>
<a name="ln4589"> </a>
<a name="ln4590">	return true;</a>
<a name="ln4591">}</a>
<a name="ln4592"> </a>
<a name="ln4593"> </a>
<a name="ln4594">/*!	Tracks the mouse position, doing special actions like changing the</a>
<a name="ln4595">	view cursor.</a>
<a name="ln4596"> </a>
<a name="ln4597">	\param where The point where the mouse has moved.</a>
<a name="ln4598">	\param message The dragging message, if there is any.</a>
<a name="ln4599">	\param force Passed as second parameter of SetViewCursor()</a>
<a name="ln4600">*/</a>
<a name="ln4601">void</a>
<a name="ln4602">BTextView::_TrackMouse(BPoint where, const BMessage* message, bool force)</a>
<a name="ln4603">{</a>
<a name="ln4604">	BRegion textRegion;</a>
<a name="ln4605">	GetTextRegion(fSelStart, fSelEnd, &amp;textRegion);</a>
<a name="ln4606"> </a>
<a name="ln4607">	if (message &amp;&amp; AcceptsDrop(message))</a>
<a name="ln4608">		_TrackDrag(where);</a>
<a name="ln4609">	else if ((fSelectable || fEditable)</a>
<a name="ln4610">		&amp;&amp; (fTrackingMouse != NULL || !textRegion.Contains(where))) {</a>
<a name="ln4611">		SetViewCursor(B_CURSOR_I_BEAM, force);</a>
<a name="ln4612">	} else</a>
<a name="ln4613">		SetViewCursor(B_CURSOR_SYSTEM_DEFAULT, force);</a>
<a name="ln4614">}</a>
<a name="ln4615"> </a>
<a name="ln4616"> </a>
<a name="ln4617">//!	Tracks the mouse position when the user is dragging some data.</a>
<a name="ln4618">void</a>
<a name="ln4619">BTextView::_TrackDrag(BPoint where)</a>
<a name="ln4620">{</a>
<a name="ln4621">	CALLED();</a>
<a name="ln4622">	if (Bounds().Contains(where))</a>
<a name="ln4623">		_DragCaret(OffsetAt(where));</a>
<a name="ln4624">}</a>
<a name="ln4625"> </a>
<a name="ln4626"> </a>
<a name="ln4627">//!	Initiates a drag operation.</a>
<a name="ln4628">void</a>
<a name="ln4629">BTextView::_InitiateDrag()</a>
<a name="ln4630">{</a>
<a name="ln4631">	BMessage dragMessage(B_MIME_DATA);</a>
<a name="ln4632">	BBitmap* dragBitmap = NULL;</a>
<a name="ln4633">	BPoint bitmapPoint;</a>
<a name="ln4634">	BHandler* dragHandler = NULL;</a>
<a name="ln4635"> </a>
<a name="ln4636">	GetDragParameters(&amp;dragMessage, &amp;dragBitmap, &amp;bitmapPoint, &amp;dragHandler);</a>
<a name="ln4637">	SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln4638"> </a>
<a name="ln4639">	if (dragBitmap != NULL)</a>
<a name="ln4640">		DragMessage(&amp;dragMessage, dragBitmap, bitmapPoint, dragHandler);</a>
<a name="ln4641">	else {</a>
<a name="ln4642">		BRegion region;</a>
<a name="ln4643">		GetTextRegion(fSelStart, fSelEnd, &amp;region);</a>
<a name="ln4644">		BRect bounds = Bounds();</a>
<a name="ln4645">		BRect dragRect = region.Frame();</a>
<a name="ln4646">		if (!bounds.Contains(dragRect))</a>
<a name="ln4647">			dragRect = bounds &amp; dragRect;</a>
<a name="ln4648"> </a>
<a name="ln4649">		DragMessage(&amp;dragMessage, dragRect, dragHandler);</a>
<a name="ln4650">	}</a>
<a name="ln4651"> </a>
<a name="ln4652">	BMessenger messenger(this);</a>
<a name="ln4653">	BMessage message(_DISPOSE_DRAG_);</a>
<a name="ln4654">	fDragRunner = new (nothrow) BMessageRunner(messenger, &amp;message, 100000);</a>
<a name="ln4655">}</a>
<a name="ln4656"> </a>
<a name="ln4657"> </a>
<a name="ln4658">//!	Handles when some data is dropped on the view.</a>
<a name="ln4659">bool</a>
<a name="ln4660">BTextView::_MessageDropped(BMessage* message, BPoint where, BPoint offset)</a>
<a name="ln4661">{</a>
<a name="ln4662">	ASSERT(message);</a>
<a name="ln4663"> </a>
<a name="ln4664">	void* from = NULL;</a>
<a name="ln4665">	bool internalDrop = false;</a>
<a name="ln4666">	if (message-&gt;FindPointer(&quot;be:originator&quot;, &amp;from) == B_OK</a>
<a name="ln4667">			&amp;&amp; from == this &amp;&amp; fSelEnd != fSelStart)</a>
<a name="ln4668">		internalDrop = true;</a>
<a name="ln4669"> </a>
<a name="ln4670">	_DragCaret(-1);</a>
<a name="ln4671"> </a>
<a name="ln4672">	delete fDragRunner;</a>
<a name="ln4673">	fDragRunner = NULL;</a>
<a name="ln4674"> </a>
<a name="ln4675">	_TrackMouse(where, NULL);</a>
<a name="ln4676"> </a>
<a name="ln4677">	// are we sure we like this message?</a>
<a name="ln4678">	if (!AcceptsDrop(message))</a>
<a name="ln4679">		return false;</a>
<a name="ln4680"> </a>
<a name="ln4681">	int32 dropOffset = OffsetAt(where);</a>
<a name="ln4682">	if (dropOffset &gt; TextLength())</a>
<a name="ln4683">		dropOffset = TextLength();</a>
<a name="ln4684"> </a>
<a name="ln4685">	// if this view initiated the drag, move instead of copy</a>
<a name="ln4686">	if (internalDrop) {</a>
<a name="ln4687">		// dropping onto itself?</a>
<a name="ln4688">		if (dropOffset &gt;= fSelStart &amp;&amp; dropOffset &lt;= fSelEnd)</a>
<a name="ln4689">			return true;</a>
<a name="ln4690">	}</a>
<a name="ln4691"> </a>
<a name="ln4692">	ssize_t dataLength = 0;</a>
<a name="ln4693">	const char* text = NULL;</a>
<a name="ln4694">	entry_ref ref;</a>
<a name="ln4695">	if (message-&gt;FindData(&quot;text/plain&quot;, B_MIME_TYPE, (const void**)&amp;text,</a>
<a name="ln4696">			&amp;dataLength) == B_OK) {</a>
<a name="ln4697">		text_run_array* runArray = NULL;</a>
<a name="ln4698">		ssize_t runLength = 0;</a>
<a name="ln4699">		if (fStylable) {</a>
<a name="ln4700">			message-&gt;FindData(&quot;application/x-vnd.Be-text_run_array&quot;,</a>
<a name="ln4701">				B_MIME_TYPE, (const void**)&amp;runArray, &amp;runLength);</a>
<a name="ln4702">		}</a>
<a name="ln4703"> </a>
<a name="ln4704">		_FilterDisallowedChars((char*)text, dataLength, runArray);</a>
<a name="ln4705"> </a>
<a name="ln4706">		if (dataLength &lt; 1) {</a>
<a name="ln4707">			beep();</a>
<a name="ln4708">			return true;</a>
<a name="ln4709">		}</a>
<a name="ln4710"> </a>
<a name="ln4711">		if (fUndo) {</a>
<a name="ln4712">			delete fUndo;</a>
<a name="ln4713">			fUndo = new DropUndoBuffer(this, text, dataLength, runArray,</a>
<a name="ln4714">				runLength, dropOffset, internalDrop);</a>
<a name="ln4715">		}</a>
<a name="ln4716"> </a>
<a name="ln4717">		if (internalDrop) {</a>
<a name="ln4718">			if (dropOffset &gt; fSelEnd)</a>
<a name="ln4719">				dropOffset -= dataLength;</a>
<a name="ln4720">			Delete();</a>
<a name="ln4721">		}</a>
<a name="ln4722"> </a>
<a name="ln4723">		Insert(dropOffset, text, dataLength, runArray);</a>
<a name="ln4724">	}</a>
<a name="ln4725"> </a>
<a name="ln4726">	return true;</a>
<a name="ln4727">}</a>
<a name="ln4728"> </a>
<a name="ln4729"> </a>
<a name="ln4730">void</a>
<a name="ln4731">BTextView::_PerformAutoScrolling()</a>
<a name="ln4732">{</a>
<a name="ln4733">	// Scroll the view a bit if mouse is outside the view bounds</a>
<a name="ln4734">	BRect bounds = Bounds();</a>
<a name="ln4735">	BPoint scrollBy(B_ORIGIN);</a>
<a name="ln4736"> </a>
<a name="ln4737">	// R5 does a pretty soft auto-scroll, we try to do the same by</a>
<a name="ln4738">	// simply scrolling the distance between cursor and border</a>
<a name="ln4739">	if (fWhere.x &gt; bounds.right) {</a>
<a name="ln4740">		scrollBy.x = fWhere.x - bounds.right;</a>
<a name="ln4741">	} else if (fWhere.x &lt; bounds.left) {</a>
<a name="ln4742">		scrollBy.x = fWhere.x - bounds.left; // negative value</a>
<a name="ln4743">	}</a>
<a name="ln4744"> </a>
<a name="ln4745">	// prevent from scrolling out of view</a>
<a name="ln4746">	if (scrollBy.x != 0.0) {</a>
<a name="ln4747">		float rightMax = floorf(fTextRect.right + fLayoutData-&gt;rightInset);</a>
<a name="ln4748">		if (bounds.right + scrollBy.x &gt; rightMax)</a>
<a name="ln4749">			scrollBy.x = rightMax - bounds.right;</a>
<a name="ln4750">		if (bounds.left + scrollBy.x &lt; 0)</a>
<a name="ln4751">			scrollBy.x = -bounds.left;</a>
<a name="ln4752">	}</a>
<a name="ln4753"> </a>
<a name="ln4754">	if (CountLines() &gt; 1) {</a>
<a name="ln4755">		// scroll in Y only if multiple lines!</a>
<a name="ln4756">		if (fWhere.y &gt; bounds.bottom) {</a>
<a name="ln4757">			scrollBy.y = fWhere.y - bounds.bottom;</a>
<a name="ln4758">		} else if (fWhere.y &lt; bounds.top) {</a>
<a name="ln4759">			scrollBy.y = fWhere.y - bounds.top; // negative value</a>
<a name="ln4760">		}</a>
<a name="ln4761"> </a>
<a name="ln4762">		// prevent from scrolling out of view</a>
<a name="ln4763">		if (scrollBy.y != 0.0) {</a>
<a name="ln4764">			float bottomMax = floorf(fTextRect.bottom</a>
<a name="ln4765">				+ fLayoutData-&gt;bottomInset);</a>
<a name="ln4766">			if (bounds.bottom + scrollBy.y &gt; bottomMax)</a>
<a name="ln4767">				scrollBy.y = bottomMax - bounds.bottom;</a>
<a name="ln4768">			if (bounds.top + scrollBy.y &lt; 0)</a>
<a name="ln4769">				scrollBy.y = -bounds.top;</a>
<a name="ln4770">		}</a>
<a name="ln4771">	}</a>
<a name="ln4772"> </a>
<a name="ln4773">	if (scrollBy != B_ORIGIN)</a>
<a name="ln4774">		ScrollBy(scrollBy.x, scrollBy.y);</a>
<a name="ln4775">}</a>
<a name="ln4776"> </a>
<a name="ln4777"> </a>
<a name="ln4778">//!	Updates the scrollbars associated with the object (if any).</a>
<a name="ln4779">void</a>
<a name="ln4780">BTextView::_UpdateScrollbars()</a>
<a name="ln4781">{</a>
<a name="ln4782">	BRect bounds(Bounds());</a>
<a name="ln4783">	BScrollBar* horizontalScrollBar = ScrollBar(B_HORIZONTAL);</a>
<a name="ln4784"> 	BScrollBar* verticalScrollBar = ScrollBar(B_VERTICAL);</a>
<a name="ln4785"> </a>
<a name="ln4786">	// do we have a horizontal scroll bar?</a>
<a name="ln4787">	if (horizontalScrollBar != NULL) {</a>
<a name="ln4788">		long viewWidth = bounds.IntegerWidth();</a>
<a name="ln4789">		long dataWidth = (long)ceilf(fTextRect.IntegerWidth()</a>
<a name="ln4790">			+ fLayoutData-&gt;leftInset + fLayoutData-&gt;rightInset);</a>
<a name="ln4791"> </a>
<a name="ln4792">		long maxRange = dataWidth - viewWidth;</a>
<a name="ln4793">		maxRange = max_c(maxRange, 0);</a>
<a name="ln4794"> </a>
<a name="ln4795">		horizontalScrollBar-&gt;SetRange(0, (float)maxRange);</a>
<a name="ln4796">		horizontalScrollBar-&gt;SetProportion((float)viewWidth / (float)dataWidth);</a>
<a name="ln4797">		horizontalScrollBar-&gt;SetSteps(kHorizontalScrollBarStep, dataWidth / 10);</a>
<a name="ln4798">	}</a>
<a name="ln4799"> </a>
<a name="ln4800">	// how about a vertical scroll bar?</a>
<a name="ln4801">	if (verticalScrollBar != NULL) {</a>
<a name="ln4802">		long viewHeight = bounds.IntegerHeight();</a>
<a name="ln4803">		long dataHeight = (long)ceilf(fTextRect.IntegerHeight()</a>
<a name="ln4804">			+ fLayoutData-&gt;topInset + fLayoutData-&gt;bottomInset);</a>
<a name="ln4805"> </a>
<a name="ln4806">		long maxRange = dataHeight - viewHeight;</a>
<a name="ln4807">		maxRange = max_c(maxRange, 0);</a>
<a name="ln4808"> </a>
<a name="ln4809">		verticalScrollBar-&gt;SetRange(0, maxRange);</a>
<a name="ln4810">		verticalScrollBar-&gt;SetProportion((float)viewHeight / (float)dataHeight);</a>
<a name="ln4811">		verticalScrollBar-&gt;SetSteps(kVerticalScrollBarStep, viewHeight);</a>
<a name="ln4812">	}</a>
<a name="ln4813">}</a>
<a name="ln4814"> </a>
<a name="ln4815"> </a>
<a name="ln4816">//!	Scrolls by the given offsets</a>
<a name="ln4817">void</a>
<a name="ln4818">BTextView::_ScrollBy(float horizontal, float vertical)</a>
<a name="ln4819">{</a>
<a name="ln4820">	BRect bounds = Bounds();</a>
<a name="ln4821">	_ScrollTo(bounds.left + horizontal, bounds.top + vertical);</a>
<a name="ln4822">}</a>
<a name="ln4823"> </a>
<a name="ln4824"> </a>
<a name="ln4825">//!	Scrolls to the given position, making sure not to scroll out of bounds.</a>
<a name="ln4826">void</a>
<a name="ln4827">BTextView::_ScrollTo(float x, float y)</a>
<a name="ln4828">{</a>
<a name="ln4829">	BRect bounds = Bounds();</a>
<a name="ln4830">	long viewWidth = bounds.IntegerWidth();</a>
<a name="ln4831">	long viewHeight = bounds.IntegerHeight();</a>
<a name="ln4832"> </a>
<a name="ln4833">	if (x &gt; fTextRect.right - viewWidth)</a>
<a name="ln4834">		x = fTextRect.right - viewWidth;</a>
<a name="ln4835">	if (x &lt; 0.0)</a>
<a name="ln4836">		x = 0.0;</a>
<a name="ln4837"> </a>
<a name="ln4838">	if (y &gt; fTextRect.bottom + fLayoutData-&gt;bottomInset - viewHeight)</a>
<a name="ln4839">		y = fTextRect.bottom + fLayoutData-&gt;bottomInset - viewHeight;</a>
<a name="ln4840">	if (y &lt; 0.0)</a>
<a name="ln4841">		y = 0.0;</a>
<a name="ln4842"> </a>
<a name="ln4843">	ScrollTo(x, y);</a>
<a name="ln4844">}</a>
<a name="ln4845"> </a>
<a name="ln4846"> </a>
<a name="ln4847">//!	Autoresizes the view to fit the contained text.</a>
<a name="ln4848">void</a>
<a name="ln4849">BTextView::_AutoResize(bool redraw)</a>
<a name="ln4850">{</a>
<a name="ln4851">	if (!fResizable)</a>
<a name="ln4852">		return;</a>
<a name="ln4853"> </a>
<a name="ln4854">	BRect bounds = Bounds();</a>
<a name="ln4855">	float oldWidth = bounds.Width();</a>
<a name="ln4856">	float newWidth = ceilf(fLayoutData-&gt;leftInset + fTextRect.Width()</a>
<a name="ln4857">		+ fLayoutData-&gt;rightInset);</a>
<a name="ln4858"> </a>
<a name="ln4859">	if (fContainerView != NULL) {</a>
<a name="ln4860">		// NOTE: This container view thing is only used by Tracker.</a>
<a name="ln4861">		// move container view if not left aligned</a>
<a name="ln4862">		if (fAlignment == B_ALIGN_CENTER) {</a>
<a name="ln4863">			if (fmod(ceilf(newWidth - oldWidth), 2.0) != 0.0)</a>
<a name="ln4864">				newWidth += 1;</a>
<a name="ln4865">			fContainerView-&gt;MoveBy(ceilf(oldWidth - newWidth) / 2, 0);</a>
<a name="ln4866">		} else if (fAlignment == B_ALIGN_RIGHT) {</a>
<a name="ln4867">			fContainerView-&gt;MoveBy(ceilf(oldWidth - newWidth), 0);</a>
<a name="ln4868">		}</a>
<a name="ln4869">		// resize container view</a>
<a name="ln4870">		fContainerView-&gt;ResizeBy(ceilf(newWidth - oldWidth), 0);</a>
<a name="ln4871">	}</a>
<a name="ln4872"> </a>
<a name="ln4873"> </a>
<a name="ln4874">	if (redraw)</a>
<a name="ln4875">		_RequestDrawLines(0, 0);</a>
<a name="ln4876"> </a>
<a name="ln4877">	// erase any potential left over outside the text rect</a>
<a name="ln4878">	// (can only be on right hand side)</a>
<a name="ln4879">	BRect dirty(fTextRect.right + 1, fTextRect.top, bounds.right,</a>
<a name="ln4880">		fTextRect.bottom);</a>
<a name="ln4881">	if (dirty.IsValid()) {</a>
<a name="ln4882">		SetLowColor(ViewColor());</a>
<a name="ln4883">		FillRect(dirty, B_SOLID_LOW);</a>
<a name="ln4884">	}</a>
<a name="ln4885">}</a>
<a name="ln4886"> </a>
<a name="ln4887"> </a>
<a name="ln4888">//!	Creates a new offscreen BBitmap with an associated BView.</a>
<a name="ln4889">void</a>
<a name="ln4890">BTextView::_NewOffscreen(float padding)</a>
<a name="ln4891">{</a>
<a name="ln4892">	if (fOffscreen != NULL)</a>
<a name="ln4893">		_DeleteOffscreen();</a>
<a name="ln4894"> </a>
<a name="ln4895">#if USE_DOUBLEBUFFERING</a>
<a name="ln4896">	BRect bitmapRect(0, 0, fTextRect.Width() + padding, fTextRect.Height());</a>
<a name="ln4897">	fOffscreen = new BBitmap(bitmapRect, fColorSpace, true, false);</a>
<a name="ln4898">	if (fOffscreen != NULL &amp;&amp; fOffscreen-&gt;Lock()) {</a>
<a name="ln4899">		BView* bufferView = new BView(bitmapRect, &quot;drawing view&quot;, 0, 0);</a>
<a name="ln4900">		fOffscreen-&gt;AddChild(bufferView);</a>
<a name="ln4901">		fOffscreen-&gt;Unlock();</a>
<a name="ln4902">	}</a>
<a name="ln4903">#endif</a>
<a name="ln4904">}</a>
<a name="ln4905"> </a>
<a name="ln4906"> </a>
<a name="ln4907">//!	Deletes the textview's offscreen bitmap, if any.</a>
<a name="ln4908">void</a>
<a name="ln4909">BTextView::_DeleteOffscreen()</a>
<a name="ln4910">{</a>
<a name="ln4911">	if (fOffscreen != NULL &amp;&amp; fOffscreen-&gt;Lock()) {</a>
<a name="ln4912">		delete fOffscreen;</a>
<a name="ln4913">		fOffscreen = NULL;</a>
<a name="ln4914">	}</a>
<a name="ln4915">}</a>
<a name="ln4916"> </a>
<a name="ln4917"> </a>
<a name="ln4918">/*!	Creates a new offscreen bitmap, highlight the selection, and set the</a>
<a name="ln4919">	cursor to \c B_CURSOR_I_BEAM.</a>
<a name="ln4920">*/</a>
<a name="ln4921">void</a>
<a name="ln4922">BTextView::_Activate()</a>
<a name="ln4923">{</a>
<a name="ln4924">	fActive = true;</a>
<a name="ln4925"> </a>
<a name="ln4926">	// Create a new offscreen BBitmap</a>
<a name="ln4927">	_NewOffscreen();</a>
<a name="ln4928"> </a>
<a name="ln4929">	if (fSelStart != fSelEnd) {</a>
<a name="ln4930">		if (fSelectable)</a>
<a name="ln4931">			Highlight(fSelStart, fSelEnd);</a>
<a name="ln4932">	} else</a>
<a name="ln4933">		_ShowCaret();</a>
<a name="ln4934"> </a>
<a name="ln4935">	BPoint where;</a>
<a name="ln4936">	uint32 buttons;</a>
<a name="ln4937">	GetMouse(&amp;where, &amp;buttons, false);</a>
<a name="ln4938">	if (Bounds().Contains(where))</a>
<a name="ln4939">		_TrackMouse(where, NULL);</a>
<a name="ln4940"> </a>
<a name="ln4941">	if (Window() != NULL) {</a>
<a name="ln4942">		BMessage* message;</a>
<a name="ln4943"> </a>
<a name="ln4944">		if (!Window()-&gt;HasShortcut(B_LEFT_ARROW, B_COMMAND_KEY)</a>
<a name="ln4945">			&amp;&amp; !Window()-&gt;HasShortcut(B_RIGHT_ARROW, B_COMMAND_KEY)) {</a>
<a name="ln4946">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln4947">			message-&gt;AddInt32(&quot;key&quot;, B_LEFT_ARROW);</a>
<a name="ln4948">			message-&gt;AddInt32(&quot;modifiers&quot;, B_COMMAND_KEY);</a>
<a name="ln4949">			Window()-&gt;AddShortcut(B_LEFT_ARROW, B_COMMAND_KEY, message, this);</a>
<a name="ln4950"> </a>
<a name="ln4951">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln4952">			message-&gt;AddInt32(&quot;key&quot;, B_RIGHT_ARROW);</a>
<a name="ln4953">			message-&gt;AddInt32(&quot;modifiers&quot;, B_COMMAND_KEY);</a>
<a name="ln4954">			Window()-&gt;AddShortcut(B_RIGHT_ARROW, B_COMMAND_KEY, message, this);</a>
<a name="ln4955"> </a>
<a name="ln4956">			fInstalledNavigateCommandWordwiseShortcuts = true;</a>
<a name="ln4957">		}</a>
<a name="ln4958">		if (!Window()-&gt;HasShortcut(B_LEFT_ARROW, B_COMMAND_KEY | B_SHIFT_KEY)</a>
<a name="ln4959">			&amp;&amp; !Window()-&gt;HasShortcut(B_RIGHT_ARROW,</a>
<a name="ln4960">				B_COMMAND_KEY | B_SHIFT_KEY)) {</a>
<a name="ln4961">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln4962">			message-&gt;AddInt32(&quot;key&quot;, B_LEFT_ARROW);</a>
<a name="ln4963">			message-&gt;AddInt32(&quot;modifiers&quot;, B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln4964">			Window()-&gt;AddShortcut(B_LEFT_ARROW, B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln4965">				message, this);</a>
<a name="ln4966"> </a>
<a name="ln4967">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln4968">			message-&gt;AddInt32(&quot;key&quot;, B_RIGHT_ARROW);</a>
<a name="ln4969">			message-&gt;AddInt32(&quot;modifiers&quot;, B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln4970">			Window()-&gt;AddShortcut(B_RIGHT_ARROW, B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln4971">				message, this);</a>
<a name="ln4972"> </a>
<a name="ln4973">			fInstalledSelectCommandWordwiseShortcuts = true;</a>
<a name="ln4974">		}</a>
<a name="ln4975"> </a>
<a name="ln4976">		if (!Window()-&gt;HasShortcut(B_LEFT_ARROW, B_OPTION_KEY)</a>
<a name="ln4977">			&amp;&amp; !Window()-&gt;HasShortcut(B_RIGHT_ARROW, B_OPTION_KEY)) {</a>
<a name="ln4978">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln4979">			message-&gt;AddInt32(&quot;key&quot;, B_LEFT_ARROW);</a>
<a name="ln4980">			message-&gt;AddInt32(&quot;modifiers&quot;, B_OPTION_KEY);</a>
<a name="ln4981">			Window()-&gt;AddShortcut(B_LEFT_ARROW, B_OPTION_KEY, message, this);</a>
<a name="ln4982"> </a>
<a name="ln4983">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln4984">			message-&gt;AddInt32(&quot;key&quot;, B_RIGHT_ARROW);</a>
<a name="ln4985">			message-&gt;AddInt32(&quot;modifiers&quot;, B_OPTION_KEY);</a>
<a name="ln4986">			Window()-&gt;AddShortcut(B_RIGHT_ARROW, B_OPTION_KEY, message, this);</a>
<a name="ln4987"> </a>
<a name="ln4988">			fInstalledNavigateOptionWordwiseShortcuts = true;</a>
<a name="ln4989">		}</a>
<a name="ln4990">		if (!Window()-&gt;HasShortcut(B_LEFT_ARROW, B_OPTION_KEY | B_SHIFT_KEY)</a>
<a name="ln4991">			&amp;&amp; !Window()-&gt;HasShortcut(B_RIGHT_ARROW,</a>
<a name="ln4992">				B_OPTION_KEY | B_SHIFT_KEY)) {</a>
<a name="ln4993">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln4994">			message-&gt;AddInt32(&quot;key&quot;, B_LEFT_ARROW);</a>
<a name="ln4995">			message-&gt;AddInt32(&quot;modifiers&quot;, B_OPTION_KEY | B_SHIFT_KEY);</a>
<a name="ln4996">			Window()-&gt;AddShortcut(B_LEFT_ARROW, B_OPTION_KEY | B_SHIFT_KEY,</a>
<a name="ln4997">				message, this);</a>
<a name="ln4998"> </a>
<a name="ln4999">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln5000">			message-&gt;AddInt32(&quot;key&quot;, B_RIGHT_ARROW);</a>
<a name="ln5001">			message-&gt;AddInt32(&quot;modifiers&quot;, B_OPTION_KEY | B_SHIFT_KEY);</a>
<a name="ln5002">			Window()-&gt;AddShortcut(B_RIGHT_ARROW, B_OPTION_KEY | B_SHIFT_KEY,</a>
<a name="ln5003">				message, this);</a>
<a name="ln5004"> </a>
<a name="ln5005">			fInstalledSelectOptionWordwiseShortcuts = true;</a>
<a name="ln5006">		}</a>
<a name="ln5007"> </a>
<a name="ln5008">		if (!Window()-&gt;HasShortcut(B_UP_ARROW, B_OPTION_KEY)</a>
<a name="ln5009">			&amp;&amp; !Window()-&gt;HasShortcut(B_DOWN_ARROW, B_OPTION_KEY)) {</a>
<a name="ln5010">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln5011">			message-&gt;AddInt32(&quot;key&quot;, B_UP_ARROW);</a>
<a name="ln5012">			message-&gt;AddInt32(&quot;modifiers&quot;, B_OPTION_KEY);</a>
<a name="ln5013">			Window()-&gt;AddShortcut(B_UP_ARROW, B_OPTION_KEY, message, this);</a>
<a name="ln5014"> </a>
<a name="ln5015">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln5016">			message-&gt;AddInt32(&quot;key&quot;, B_DOWN_ARROW);</a>
<a name="ln5017">			message-&gt;AddInt32(&quot;modifiers&quot;, B_OPTION_KEY);</a>
<a name="ln5018">			Window()-&gt;AddShortcut(B_DOWN_ARROW, B_OPTION_KEY, message, this);</a>
<a name="ln5019"> </a>
<a name="ln5020">			fInstalledNavigateOptionLinewiseShortcuts = true;</a>
<a name="ln5021">		}</a>
<a name="ln5022">		if (!Window()-&gt;HasShortcut(B_UP_ARROW, B_OPTION_KEY | B_SHIFT_KEY)</a>
<a name="ln5023">			&amp;&amp; !Window()-&gt;HasShortcut(B_DOWN_ARROW,</a>
<a name="ln5024">				B_OPTION_KEY | B_SHIFT_KEY)) {</a>
<a name="ln5025">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln5026">			message-&gt;AddInt32(&quot;key&quot;, B_UP_ARROW);</a>
<a name="ln5027">			message-&gt;AddInt32(&quot;modifiers&quot;, B_OPTION_KEY | B_SHIFT_KEY);</a>
<a name="ln5028">			Window()-&gt;AddShortcut(B_UP_ARROW, B_OPTION_KEY | B_SHIFT_KEY,</a>
<a name="ln5029">				message, this);</a>
<a name="ln5030"> </a>
<a name="ln5031">			message = new BMessage(kMsgNavigateArrow);</a>
<a name="ln5032">			message-&gt;AddInt32(&quot;key&quot;, B_DOWN_ARROW);</a>
<a name="ln5033">			message-&gt;AddInt32(&quot;modifiers&quot;, B_OPTION_KEY | B_SHIFT_KEY);</a>
<a name="ln5034">			Window()-&gt;AddShortcut(B_DOWN_ARROW, B_OPTION_KEY | B_SHIFT_KEY,</a>
<a name="ln5035">				message, this);</a>
<a name="ln5036"> </a>
<a name="ln5037">			fInstalledSelectOptionLinewiseShortcuts = true;</a>
<a name="ln5038">		}</a>
<a name="ln5039"> </a>
<a name="ln5040">		if (!Window()-&gt;HasShortcut(B_HOME, B_COMMAND_KEY)</a>
<a name="ln5041">			&amp;&amp; !Window()-&gt;HasShortcut(B_END, B_COMMAND_KEY)) {</a>
<a name="ln5042">			message = new BMessage(kMsgNavigatePage);</a>
<a name="ln5043">			message-&gt;AddInt32(&quot;key&quot;, B_HOME);</a>
<a name="ln5044">			message-&gt;AddInt32(&quot;modifiers&quot;, B_COMMAND_KEY);</a>
<a name="ln5045">			Window()-&gt;AddShortcut(B_HOME, B_COMMAND_KEY, message, this);</a>
<a name="ln5046"> </a>
<a name="ln5047">			message = new BMessage(kMsgNavigatePage);</a>
<a name="ln5048">			message-&gt;AddInt32(&quot;key&quot;, B_END);</a>
<a name="ln5049">			message-&gt;AddInt32(&quot;modifiers&quot;, B_COMMAND_KEY);</a>
<a name="ln5050">			Window()-&gt;AddShortcut(B_END, B_COMMAND_KEY, message, this);</a>
<a name="ln5051"> </a>
<a name="ln5052">			fInstalledNavigateHomeEndDocwiseShortcuts = true;</a>
<a name="ln5053">		}</a>
<a name="ln5054">		if (!Window()-&gt;HasShortcut(B_HOME, B_COMMAND_KEY | B_SHIFT_KEY)</a>
<a name="ln5055">			&amp;&amp; !Window()-&gt;HasShortcut(B_END, B_COMMAND_KEY | B_SHIFT_KEY)) {</a>
<a name="ln5056">			message = new BMessage(kMsgNavigatePage);</a>
<a name="ln5057">			message-&gt;AddInt32(&quot;key&quot;, B_HOME);</a>
<a name="ln5058">			message-&gt;AddInt32(&quot;modifiers&quot;, B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln5059">			Window()-&gt;AddShortcut(B_HOME, B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln5060">				message, this);</a>
<a name="ln5061"> </a>
<a name="ln5062">			message = new BMessage(kMsgNavigatePage);</a>
<a name="ln5063">			message-&gt;AddInt32(&quot;key&quot;, B_END);</a>
<a name="ln5064">			message-&gt;AddInt32(&quot;modifiers&quot;, B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln5065">			Window()-&gt;AddShortcut(B_END, B_COMMAND_KEY | B_SHIFT_KEY,</a>
<a name="ln5066">				message, this);</a>
<a name="ln5067"> </a>
<a name="ln5068">			fInstalledSelectHomeEndDocwiseShortcuts = true;</a>
<a name="ln5069">		}</a>
<a name="ln5070">	}</a>
<a name="ln5071">}</a>
<a name="ln5072"> </a>
<a name="ln5073"> </a>
<a name="ln5074">//!	Unhilights the selection, set the cursor to \c B_CURSOR_SYSTEM_DEFAULT.</a>
<a name="ln5075">void</a>
<a name="ln5076">BTextView::_Deactivate()</a>
<a name="ln5077">{</a>
<a name="ln5078">	fActive = false;</a>
<a name="ln5079"> </a>
<a name="ln5080">	_CancelInputMethod();</a>
<a name="ln5081">	_DeleteOffscreen();</a>
<a name="ln5082"> </a>
<a name="ln5083">	if (fSelStart != fSelEnd) {</a>
<a name="ln5084">		if (fSelectable)</a>
<a name="ln5085">			Highlight(fSelStart, fSelEnd);</a>
<a name="ln5086">	} else</a>
<a name="ln5087">		_HideCaret();</a>
<a name="ln5088"> </a>
<a name="ln5089">	if (Window() != NULL) {</a>
<a name="ln5090">		if (fInstalledNavigateCommandWordwiseShortcuts) {</a>
<a name="ln5091">			Window()-&gt;RemoveShortcut(B_LEFT_ARROW, B_COMMAND_KEY);</a>
<a name="ln5092">			Window()-&gt;RemoveShortcut(B_RIGHT_ARROW, B_COMMAND_KEY);</a>
<a name="ln5093">			fInstalledNavigateCommandWordwiseShortcuts = false;</a>
<a name="ln5094">		}</a>
<a name="ln5095">		if (fInstalledSelectCommandWordwiseShortcuts) {</a>
<a name="ln5096">			Window()-&gt;RemoveShortcut(B_LEFT_ARROW, B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln5097">			Window()-&gt;RemoveShortcut(B_RIGHT_ARROW,</a>
<a name="ln5098">				B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln5099">			fInstalledSelectCommandWordwiseShortcuts = false;</a>
<a name="ln5100">		}</a>
<a name="ln5101"> </a>
<a name="ln5102">		if (fInstalledNavigateOptionWordwiseShortcuts) {</a>
<a name="ln5103">			Window()-&gt;RemoveShortcut(B_LEFT_ARROW, B_OPTION_KEY);</a>
<a name="ln5104">			Window()-&gt;RemoveShortcut(B_RIGHT_ARROW, B_OPTION_KEY);</a>
<a name="ln5105">			fInstalledNavigateOptionWordwiseShortcuts = false;</a>
<a name="ln5106">		}</a>
<a name="ln5107">		if (fInstalledSelectOptionWordwiseShortcuts) {</a>
<a name="ln5108">			Window()-&gt;RemoveShortcut(B_LEFT_ARROW, B_OPTION_KEY | B_SHIFT_KEY);</a>
<a name="ln5109">			Window()-&gt;RemoveShortcut(B_RIGHT_ARROW, B_OPTION_KEY | B_SHIFT_KEY);</a>
<a name="ln5110">			fInstalledSelectOptionWordwiseShortcuts = false;</a>
<a name="ln5111">		}</a>
<a name="ln5112"> </a>
<a name="ln5113">		if (fInstalledNavigateOptionLinewiseShortcuts) {</a>
<a name="ln5114">			Window()-&gt;RemoveShortcut(B_UP_ARROW, B_OPTION_KEY);</a>
<a name="ln5115">			Window()-&gt;RemoveShortcut(B_DOWN_ARROW, B_OPTION_KEY);</a>
<a name="ln5116">			fInstalledNavigateOptionLinewiseShortcuts = false;</a>
<a name="ln5117">		}</a>
<a name="ln5118">		if (fInstalledSelectOptionLinewiseShortcuts) {</a>
<a name="ln5119">			Window()-&gt;RemoveShortcut(B_UP_ARROW, B_OPTION_KEY | B_SHIFT_KEY);</a>
<a name="ln5120">			Window()-&gt;RemoveShortcut(B_DOWN_ARROW, B_OPTION_KEY | B_SHIFT_KEY);</a>
<a name="ln5121">			fInstalledSelectOptionLinewiseShortcuts = false;</a>
<a name="ln5122">		}</a>
<a name="ln5123"> </a>
<a name="ln5124">		if (fInstalledNavigateHomeEndDocwiseShortcuts) {</a>
<a name="ln5125">			Window()-&gt;RemoveShortcut(B_HOME, B_COMMAND_KEY);</a>
<a name="ln5126">			Window()-&gt;RemoveShortcut(B_END, B_COMMAND_KEY);</a>
<a name="ln5127">			fInstalledNavigateHomeEndDocwiseShortcuts = false;</a>
<a name="ln5128">		}</a>
<a name="ln5129">		if (fInstalledSelectHomeEndDocwiseShortcuts) {</a>
<a name="ln5130">			Window()-&gt;RemoveShortcut(B_HOME, B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln5131">			Window()-&gt;RemoveShortcut(B_END, B_COMMAND_KEY | B_SHIFT_KEY);</a>
<a name="ln5132">			fInstalledSelectHomeEndDocwiseShortcuts = false;</a>
<a name="ln5133">		}</a>
<a name="ln5134">	}</a>
<a name="ln5135">}</a>
<a name="ln5136"> </a>
<a name="ln5137"> </a>
<a name="ln5138">/*!	Changes the passed in font to be displayable by the object.</a>
<a name="ln5139"> </a>
<a name="ln5140">	Set font rotation to 0, removes any font flag, set font spacing</a>
<a name="ln5141">	to \c B_BITMAP_SPACING and font encoding to \c B_UNICODE_UTF8.</a>
<a name="ln5142">*/</a>
<a name="ln5143">void</a>
<a name="ln5144">BTextView::_NormalizeFont(BFont* font)</a>
<a name="ln5145">{</a>
<a name="ln5146">	if (font) {</a>
<a name="ln5147">		font-&gt;SetRotation(0.0f);</a>
<a name="ln5148">		font-&gt;SetFlags(0);</a>
<a name="ln5149">		font-&gt;SetSpacing(B_BITMAP_SPACING);</a>
<a name="ln5150">		font-&gt;SetEncoding(B_UNICODE_UTF8);</a>
<a name="ln5151">	}</a>
<a name="ln5152">}</a>
<a name="ln5153"> </a>
<a name="ln5154"> </a>
<a name="ln5155">void</a>
<a name="ln5156">BTextView::_SetRunArray(int32 startOffset, int32 endOffset,</a>
<a name="ln5157">	const text_run_array* runs)</a>
<a name="ln5158">{</a>
<a name="ln5159">	const int32 numStyles = runs-&gt;count;</a>
<a name="ln5160">	if (numStyles &gt; 0) {</a>
<a name="ln5161">		const text_run* theRun = &amp;runs-&gt;runs[0];</a>
<a name="ln5162">		for (int32 index = 0; index &lt; numStyles; index++) {</a>
<a name="ln5163">			int32 fromOffset = theRun-&gt;offset + startOffset;</a>
<a name="ln5164">			int32 toOffset = endOffset;</a>
<a name="ln5165">			if (index + 1 &lt; numStyles) {</a>
<a name="ln5166">				toOffset = (theRun + 1)-&gt;offset + startOffset;</a>
<a name="ln5167">				toOffset = (toOffset &gt; endOffset) ? endOffset : toOffset;</a>
<a name="ln5168">			}</a>
<a name="ln5169"> </a>
<a name="ln5170">			_ApplyStyleRange(fromOffset, toOffset, B_FONT_ALL, &amp;theRun-&gt;font,</a>
<a name="ln5171">				&amp;theRun-&gt;color, false);</a>
<a name="ln5172"> </a>
<a name="ln5173">			theRun++;</a>
<a name="ln5174">		}</a>
<a name="ln5175">		fStyles-&gt;InvalidateNullStyle();</a>
<a name="ln5176">	}</a>
<a name="ln5177">}</a>
<a name="ln5178"> </a>
<a name="ln5179"> </a>
<a name="ln5180">/*!	Returns the character class of the character at the given offset.</a>
<a name="ln5181"> </a>
<a name="ln5182">	\param offset The offset where the wanted character can be found.</a>
<a name="ln5183"> </a>
<a name="ln5184">	\return A value which represents the character's classification.</a>
<a name="ln5185">*/</a>
<a name="ln5186">uint32</a>
<a name="ln5187">BTextView::_CharClassification(int32 offset) const</a>
<a name="ln5188">{</a>
<a name="ln5189">	// TODO: Should check against a list of characters containing also</a>
<a name="ln5190">	// japanese word breakers.</a>
<a name="ln5191">	// And what about other languages ? Isn't there a better way to check</a>
<a name="ln5192">	// for separator characters ?</a>
<a name="ln5193">	// Andrew suggested to have a look at UnicodeBlockObject.h</a>
<a name="ln5194">	switch (fText-&gt;RealCharAt(offset)) {</a>
<a name="ln5195">		case '\0':</a>
<a name="ln5196">			return CHAR_CLASS_END_OF_TEXT;</a>
<a name="ln5197"> </a>
<a name="ln5198">		case B_SPACE:</a>
<a name="ln5199">		case B_TAB:</a>
<a name="ln5200">		case B_ENTER:</a>
<a name="ln5201">			return CHAR_CLASS_WHITESPACE;</a>
<a name="ln5202"> </a>
<a name="ln5203">		case '=':</a>
<a name="ln5204">		case '+':</a>
<a name="ln5205">		case '@':</a>
<a name="ln5206">		case '#':</a>
<a name="ln5207">		case '$':</a>
<a name="ln5208">		case '%':</a>
<a name="ln5209">		case '^':</a>
<a name="ln5210">		case '&amp;':</a>
<a name="ln5211">		case '*':</a>
<a name="ln5212">		case '\\':</a>
<a name="ln5213">		case '|':</a>
<a name="ln5214">		case '&lt;':</a>
<a name="ln5215">		case '&gt;':</a>
<a name="ln5216">		case '/':</a>
<a name="ln5217">		case '~':</a>
<a name="ln5218">			return CHAR_CLASS_GRAPHICAL;</a>
<a name="ln5219"> </a>
<a name="ln5220">		case '\'':</a>
<a name="ln5221">		case '&quot;':</a>
<a name="ln5222">			return CHAR_CLASS_QUOTE;</a>
<a name="ln5223"> </a>
<a name="ln5224">		case ',':</a>
<a name="ln5225">		case '.':</a>
<a name="ln5226">		case '?':</a>
<a name="ln5227">		case '!':</a>
<a name="ln5228">		case ';':</a>
<a name="ln5229">		case ':':</a>
<a name="ln5230">		case '-':</a>
<a name="ln5231">			return CHAR_CLASS_PUNCTUATION;</a>
<a name="ln5232"> </a>
<a name="ln5233">		case '(':</a>
<a name="ln5234">		case '[':</a>
<a name="ln5235">		case '{':</a>
<a name="ln5236">			return CHAR_CLASS_PARENS_OPEN;</a>
<a name="ln5237"> </a>
<a name="ln5238">		case ')':</a>
<a name="ln5239">		case ']':</a>
<a name="ln5240">		case '}':</a>
<a name="ln5241">			return CHAR_CLASS_PARENS_CLOSE;</a>
<a name="ln5242"> </a>
<a name="ln5243">		default:</a>
<a name="ln5244">			return CHAR_CLASS_DEFAULT;</a>
<a name="ln5245">	}</a>
<a name="ln5246">}</a>
<a name="ln5247"> </a>
<a name="ln5248"> </a>
<a name="ln5249">/*!	Returns the offset of the next UTF-8 character.</a>
<a name="ln5250"> </a>
<a name="ln5251">	\param offset The offset where to start looking.</a>
<a name="ln5252"> </a>
<a name="ln5253">	\return The offset of the next UTF-8 character.</a>
<a name="ln5254">*/</a>
<a name="ln5255">int32</a>
<a name="ln5256">BTextView::_NextInitialByte(int32 offset) const</a>
<a name="ln5257">{</a>
<a name="ln5258">	if (offset &gt;= fText-&gt;Length())</a>
<a name="ln5259">		return offset;</a>
<a name="ln5260"> </a>
<a name="ln5261">	for (++offset; (ByteAt(offset) &amp; 0xC0) == 0x80; ++offset)</a>
<a name="ln5262">		;</a>
<a name="ln5263"> </a>
<a name="ln5264">	return offset;</a>
<a name="ln5265">}</a>
<a name="ln5266"> </a>
<a name="ln5267"> </a>
<a name="ln5268">/*!	Returns the offset of the previous UTF-8 character.</a>
<a name="ln5269"> </a>
<a name="ln5270">	\param offset The offset where to start looking.</a>
<a name="ln5271"> </a>
<a name="ln5272">	\return The offset of the previous UTF-8 character.</a>
<a name="ln5273">*/</a>
<a name="ln5274">int32</a>
<a name="ln5275">BTextView::_PreviousInitialByte(int32 offset) const</a>
<a name="ln5276">{</a>
<a name="ln5277">	if (offset &lt;= 0)</a>
<a name="ln5278">		return 0;</a>
<a name="ln5279"> </a>
<a name="ln5280">	int32 count = 6;</a>
<a name="ln5281"> </a>
<a name="ln5282">	for (--offset; offset &gt; 0 &amp;&amp; count; --offset, --count) {</a>
<a name="ln5283">		if ((ByteAt(offset) &amp; 0xC0) != 0x80)</a>
<a name="ln5284">			break;</a>
<a name="ln5285">	}</a>
<a name="ln5286"> </a>
<a name="ln5287">	return count ? offset : 0;</a>
<a name="ln5288">}</a>
<a name="ln5289"> </a>
<a name="ln5290"> </a>
<a name="ln5291">bool</a>
<a name="ln5292">BTextView::_GetProperty(BMessage* specifier, int32 form, const char* property,</a>
<a name="ln5293">	BMessage* reply)</a>
<a name="ln5294">{</a>
<a name="ln5295">	CALLED();</a>
<a name="ln5296">	if (strcmp(property, &quot;selection&quot;) == 0) {</a>
<a name="ln5297">		reply-&gt;what = B_REPLY;</a>
<a name="ln5298">		reply-&gt;AddInt32(&quot;result&quot;, fSelStart);</a>
<a name="ln5299">		reply-&gt;AddInt32(&quot;result&quot;, fSelEnd);</a>
<a name="ln5300">		reply-&gt;AddInt32(&quot;error&quot;, B_OK);</a>
<a name="ln5301"> </a>
<a name="ln5302">		return true;</a>
<a name="ln5303">	} else if (strcmp(property, &quot;Text&quot;) == 0) {</a>
<a name="ln5304">		if (IsTypingHidden()) {</a>
<a name="ln5305">			// Do not allow stealing passwords via scripting</a>
<a name="ln5306">			beep();</a>
<a name="ln5307">			return false;</a>
<a name="ln5308">		}</a>
<a name="ln5309"> </a>
<a name="ln5310">		int32 index, range;</a>
<a name="ln5311">		specifier-&gt;FindInt32(&quot;index&quot;, &amp;index);</a>
<a name="ln5312">		specifier-&gt;FindInt32(&quot;range&quot;, &amp;range);</a>
<a name="ln5313"> </a>
<a name="ln5314">		char* buffer = new char[range + 1];</a>
<a name="ln5315">		GetText(index, range, buffer);</a>
<a name="ln5316"> </a>
<a name="ln5317">		reply-&gt;what = B_REPLY;</a>
<a name="ln5318">		reply-&gt;AddString(&quot;result&quot;, buffer);</a>
<a name="ln5319">		reply-&gt;AddInt32(&quot;error&quot;, B_OK);</a>
<a name="ln5320"> </a>
<a name="ln5321">		delete[] buffer;</a>
<a name="ln5322"> </a>
<a name="ln5323">		return true;</a>
<a name="ln5324">	} else if (strcmp(property, &quot;text_run_array&quot;) == 0)</a>
<a name="ln5325">		return false;</a>
<a name="ln5326"> </a>
<a name="ln5327">	return false;</a>
<a name="ln5328">}</a>
<a name="ln5329"> </a>
<a name="ln5330"> </a>
<a name="ln5331">bool</a>
<a name="ln5332">BTextView::_SetProperty(BMessage* specifier, int32 form, const char* property,</a>
<a name="ln5333">	BMessage* reply)</a>
<a name="ln5334">{</a>
<a name="ln5335">	CALLED();</a>
<a name="ln5336">	if (strcmp(property, &quot;selection&quot;) == 0) {</a>
<a name="ln5337">		int32 index, range;</a>
<a name="ln5338"> </a>
<a name="ln5339">		specifier-&gt;FindInt32(&quot;index&quot;, &amp;index);</a>
<a name="ln5340">		specifier-&gt;FindInt32(&quot;range&quot;, &amp;range);</a>
<a name="ln5341"> </a>
<a name="ln5342">		Select(index, index + range);</a>
<a name="ln5343"> </a>
<a name="ln5344">		reply-&gt;what = B_REPLY;</a>
<a name="ln5345">		reply-&gt;AddInt32(&quot;error&quot;, B_OK);</a>
<a name="ln5346"> </a>
<a name="ln5347">		return true;</a>
<a name="ln5348">	} else if (strcmp(property, &quot;Text&quot;) == 0) {</a>
<a name="ln5349">		int32 index, range;</a>
<a name="ln5350">		specifier-&gt;FindInt32(&quot;index&quot;, &amp;index);</a>
<a name="ln5351">		specifier-&gt;FindInt32(&quot;range&quot;, &amp;range);</a>
<a name="ln5352"> </a>
<a name="ln5353">		const char* buffer = NULL;</a>
<a name="ln5354">		if (specifier-&gt;FindString(&quot;data&quot;, &amp;buffer) == B_OK)</a>
<a name="ln5355">			InsertText(buffer, range, index, NULL);</a>
<a name="ln5356">		else</a>
<a name="ln5357">			DeleteText(index, range);</a>
<a name="ln5358"> </a>
<a name="ln5359">		reply-&gt;what = B_REPLY;</a>
<a name="ln5360">		reply-&gt;AddInt32(&quot;error&quot;, B_OK);</a>
<a name="ln5361"> </a>
<a name="ln5362">		return true;</a>
<a name="ln5363">	} else if (strcmp(property, &quot;text_run_array&quot;) == 0)</a>
<a name="ln5364">		return false;</a>
<a name="ln5365"> </a>
<a name="ln5366">	return false;</a>
<a name="ln5367">}</a>
<a name="ln5368"> </a>
<a name="ln5369"> </a>
<a name="ln5370">bool</a>
<a name="ln5371">BTextView::_CountProperties(BMessage* specifier, int32 form,</a>
<a name="ln5372">	const char* property, BMessage* reply)</a>
<a name="ln5373">{</a>
<a name="ln5374">	CALLED();</a>
<a name="ln5375">	if (strcmp(property, &quot;Text&quot;) == 0) {</a>
<a name="ln5376">		reply-&gt;what = B_REPLY;</a>
<a name="ln5377">		reply-&gt;AddInt32(&quot;result&quot;, TextLength());</a>
<a name="ln5378">		reply-&gt;AddInt32(&quot;error&quot;, B_OK);</a>
<a name="ln5379">		return true;</a>
<a name="ln5380">	}</a>
<a name="ln5381"> </a>
<a name="ln5382">	return false;</a>
<a name="ln5383">}</a>
<a name="ln5384"> </a>
<a name="ln5385"> </a>
<a name="ln5386">//!	Called when the object receives a \c B_INPUT_METHOD_CHANGED message.</a>
<a name="ln5387">void</a>
<a name="ln5388">BTextView::_HandleInputMethodChanged(BMessage* message)</a>
<a name="ln5389">{</a>
<a name="ln5390">	// TODO: block input if not editable (Andrew)</a>
<a name="ln5391">	ASSERT(fInline != NULL);</a>
<a name="ln5392"> </a>
<a name="ln5393">	const char* string = NULL;</a>
<a name="ln5394">	if (message-&gt;FindString(&quot;be:string&quot;, &amp;string) &lt; B_OK || string == NULL)</a>
<a name="ln5395">		return;</a>
<a name="ln5396"> </a>
<a name="ln5397">	_HideCaret();</a>
<a name="ln5398"> </a>
<a name="ln5399">	if (IsFocus())</a>
<a name="ln5400">		be_app-&gt;ObscureCursor();</a>
<a name="ln5401"> </a>
<a name="ln5402">	// If we find the &quot;be:confirmed&quot; boolean (and the boolean is true),</a>
<a name="ln5403">	// it means it's over for now, so the current InlineInput object</a>
<a name="ln5404">	// should become inactive. We will probably receive a</a>
<a name="ln5405">	// B_INPUT_METHOD_STOPPED message after this one.</a>
<a name="ln5406">	bool confirmed;</a>
<a name="ln5407">	if (message-&gt;FindBool(&quot;be:confirmed&quot;, &amp;confirmed) != B_OK)</a>
<a name="ln5408">		confirmed = false;</a>
<a name="ln5409"> </a>
<a name="ln5410">	// Delete the previously inserted text (if any)</a>
<a name="ln5411">	if (fInline-&gt;IsActive()) {</a>
<a name="ln5412">		const int32 oldOffset = fInline-&gt;Offset();</a>
<a name="ln5413">		DeleteText(oldOffset, oldOffset + fInline-&gt;Length());</a>
<a name="ln5414">		if (confirmed)</a>
<a name="ln5415">			fInline-&gt;SetActive(false);</a>
<a name="ln5416">		fCaretOffset = fSelStart = fSelEnd = oldOffset;</a>
<a name="ln5417">	}</a>
<a name="ln5418"> </a>
<a name="ln5419">	const int32 stringLen = strlen(string);</a>
<a name="ln5420"> </a>
<a name="ln5421">	fInline-&gt;SetOffset(fSelStart);</a>
<a name="ln5422">	fInline-&gt;SetLength(stringLen);</a>
<a name="ln5423">	fInline-&gt;ResetClauses();</a>
<a name="ln5424"> </a>
<a name="ln5425">	if (!confirmed &amp;&amp; !fInline-&gt;IsActive())</a>
<a name="ln5426">		fInline-&gt;SetActive(true);</a>
<a name="ln5427"> </a>
<a name="ln5428">	// Get the clauses, and pass them to the InlineInput object</a>
<a name="ln5429">	// TODO: Find out if what we did it's ok, currently we don't consider</a>
<a name="ln5430">	// clauses at all, while the bebook says we should; though the visual</a>
<a name="ln5431">	// effect we obtained seems correct. Weird.</a>
<a name="ln5432">	int32 clauseCount = 0;</a>
<a name="ln5433">	int32 clauseStart;</a>
<a name="ln5434">	int32 clauseEnd;</a>
<a name="ln5435">	while (message-&gt;FindInt32(&quot;be:clause_start&quot;, clauseCount, &amp;clauseStart)</a>
<a name="ln5436">			== B_OK</a>
<a name="ln5437">		&amp;&amp; message-&gt;FindInt32(&quot;be:clause_end&quot;, clauseCount, &amp;clauseEnd)</a>
<a name="ln5438">			== B_OK) {</a>
<a name="ln5439">		if (!fInline-&gt;AddClause(clauseStart, clauseEnd))</a>
<a name="ln5440">			break;</a>
<a name="ln5441">		clauseCount++;</a>
<a name="ln5442">	}</a>
<a name="ln5443"> </a>
<a name="ln5444">	if (confirmed) {</a>
<a name="ln5445">		_Refresh(fSelStart, fSelEnd, true);</a>
<a name="ln5446">		_ShowCaret();</a>
<a name="ln5447"> </a>
<a name="ln5448">		// now we need to feed ourselves the individual characters as if the</a>
<a name="ln5449">		// user would have pressed them now - this lets KeyDown() pick out all</a>
<a name="ln5450">		// the special characters like B_BACKSPACE, cursor keys and the like:</a>
<a name="ln5451">		const char* currPos = string;</a>
<a name="ln5452">		const char* prevPos = currPos;</a>
<a name="ln5453">		while (*currPos != '\0') {</a>
<a name="ln5454">			if ((*currPos &amp; 0xC0) == 0xC0) {</a>
<a name="ln5455">				// found the start of an UTF-8 char, we collect while it lasts</a>
<a name="ln5456">				++currPos;</a>
<a name="ln5457">				while ((*currPos &amp; 0xC0) == 0x80)</a>
<a name="ln5458">					++currPos;</a>
<a name="ln5459">			} else if ((*currPos &amp; 0xC0) == 0x80) {</a>
<a name="ln5460">				// illegal: character starts with utf-8 intermediate byte,</a>
<a name="ln5461">				// skip it</a>
<a name="ln5462">				prevPos = ++currPos;</a>
<a name="ln5463">			} else {</a>
<a name="ln5464">				// single byte character/code, just feed that</a>
<a name="ln5465">				++currPos;</a>
<a name="ln5466">			}</a>
<a name="ln5467">			KeyDown(prevPos, currPos - prevPos);</a>
<a name="ln5468">			prevPos = currPos;</a>
<a name="ln5469">		}</a>
<a name="ln5470"> </a>
<a name="ln5471">		_Refresh(fSelStart, fSelEnd, true);</a>
<a name="ln5472">	} else {</a>
<a name="ln5473">		// temporarily show transient state of inline input</a>
<a name="ln5474">		int32 selectionStart = 0;</a>
<a name="ln5475">		int32 selectionEnd = 0;</a>
<a name="ln5476">		message-&gt;FindInt32(&quot;be:selection&quot;, 0, &amp;selectionStart);</a>
<a name="ln5477">		message-&gt;FindInt32(&quot;be:selection&quot;, 1, &amp;selectionEnd);</a>
<a name="ln5478"> </a>
<a name="ln5479">		fInline-&gt;SetSelectionOffset(selectionStart);</a>
<a name="ln5480">		fInline-&gt;SetSelectionLength(selectionEnd - selectionStart);</a>
<a name="ln5481"> </a>
<a name="ln5482">		const int32 inlineOffset = fInline-&gt;Offset();</a>
<a name="ln5483">		InsertText(string, stringLen, fSelStart, NULL);</a>
<a name="ln5484"> </a>
<a name="ln5485">		_Refresh(inlineOffset, fSelEnd, true);</a>
<a name="ln5486">		_ShowCaret();</a>
<a name="ln5487">	}</a>
<a name="ln5488"> </a>
<a name="ln5489">}</a>
<a name="ln5490"> </a>
<a name="ln5491"> </a>
<a name="ln5492">/*!	Called when the object receives a \c B_INPUT_METHOD_LOCATION_REQUEST</a>
<a name="ln5493">	message.</a>
<a name="ln5494">*/</a>
<a name="ln5495">void</a>
<a name="ln5496">BTextView::_HandleInputMethodLocationRequest()</a>
<a name="ln5497">{</a>
<a name="ln5498">	ASSERT(fInline != NULL);</a>
<a name="ln5499"> </a>
<a name="ln5500">	int32 offset = fInline-&gt;Offset();</a>
<a name="ln5501">	const int32 limit = offset + fInline-&gt;Length();</a>
<a name="ln5502"> </a>
<a name="ln5503">	BMessage message(B_INPUT_METHOD_EVENT);</a>
<a name="ln5504">	message.AddInt32(&quot;be:opcode&quot;, B_INPUT_METHOD_LOCATION_REQUEST);</a>
<a name="ln5505"> </a>
<a name="ln5506">	// Add the location of the UTF8 characters</a>
<a name="ln5507">	while (offset &lt; limit) {</a>
<a name="ln5508">		float height;</a>
<a name="ln5509">		BPoint where = PointAt(offset, &amp;height);</a>
<a name="ln5510">		ConvertToScreen(&amp;where);</a>
<a name="ln5511"> </a>
<a name="ln5512">		message.AddPoint(&quot;be:location_reply&quot;, where);</a>
<a name="ln5513">		message.AddFloat(&quot;be:height_reply&quot;, height);</a>
<a name="ln5514"> </a>
<a name="ln5515">		offset = _NextInitialByte(offset);</a>
<a name="ln5516">	}</a>
<a name="ln5517"> </a>
<a name="ln5518">	fInline-&gt;Method()-&gt;SendMessage(&amp;message);</a>
<a name="ln5519">}</a>
<a name="ln5520"> </a>
<a name="ln5521"> </a>
<a name="ln5522">//!	Tells the Input Server method add-on to stop the current transaction.</a>
<a name="ln5523">void</a>
<a name="ln5524">BTextView::_CancelInputMethod()</a>
<a name="ln5525">{</a>
<a name="ln5526">	if (!fInline)</a>
<a name="ln5527">		return;</a>
<a name="ln5528"> </a>
<a name="ln5529">	InlineInput* inlineInput = fInline;</a>
<a name="ln5530">	fInline = NULL;</a>
<a name="ln5531"> </a>
<a name="ln5532">	if (inlineInput-&gt;IsActive() &amp;&amp; Window()) {</a>
<a name="ln5533">		_Refresh(inlineInput-&gt;Offset(), fText-&gt;Length() - inlineInput-&gt;Offset(),</a>
<a name="ln5534">			false);</a>
<a name="ln5535"> </a>
<a name="ln5536">		BMessage message(B_INPUT_METHOD_EVENT);</a>
<a name="ln5537">		message.AddInt32(&quot;be:opcode&quot;, B_INPUT_METHOD_STOPPED);</a>
<a name="ln5538">		inlineInput-&gt;Method()-&gt;SendMessage(&amp;message);</a>
<a name="ln5539">	}</a>
<a name="ln5540"> </a>
<a name="ln5541">	delete inlineInput;</a>
<a name="ln5542">}</a>
<a name="ln5543"> </a>
<a name="ln5544"> </a>
<a name="ln5545">/*!	Returns the line number of the character at the given \a offset.</a>
<a name="ln5546"> </a>
<a name="ln5547">	\note This will never return the last line (use LineAt() if you</a>
<a name="ln5548">	      need to be correct about that.) N.B.</a>
<a name="ln5549"> </a>
<a name="ln5550">	\param offset The offset of the wanted character.</a>
<a name="ln5551"> </a>
<a name="ln5552">	\return The line number of the character at the given \a offset as an int32.</a>
<a name="ln5553">*/</a>
<a name="ln5554">int32</a>
<a name="ln5555">BTextView::_LineAt(int32 offset) const</a>
<a name="ln5556">{</a>
<a name="ln5557">	return fLines-&gt;OffsetToLine(offset);</a>
<a name="ln5558">}</a>
<a name="ln5559"> </a>
<a name="ln5560"> </a>
<a name="ln5561">/*!	Returns the line number that the given \a point is on.</a>
<a name="ln5562"> </a>
<a name="ln5563">	\note This will never return the last line (use LineAt() if you</a>
<a name="ln5564">	      need to be correct about that.) N.B.</a>
<a name="ln5565"> </a>
<a name="ln5566">	\param point The \a point the get the line number of.</a>
<a name="ln5567"> </a>
<a name="ln5568">	\return The line number of the given \a point as an int32.</a>
<a name="ln5569">*/</a>
<a name="ln5570">int32</a>
<a name="ln5571">BTextView::_LineAt(const BPoint&amp; point) const</a>
<a name="ln5572">{</a>
<a name="ln5573">	return fLines-&gt;PixelToLine(point.y - fTextRect.top);</a>
<a name="ln5574">}</a>
<a name="ln5575"> </a>
<a name="ln5576"> </a>
<a name="ln5577">/*!	Returns whether or not the given \a offset is on the empty line at the end</a>
<a name="ln5578">	of the buffer.</a>
<a name="ln5579">*/</a>
<a name="ln5580">bool</a>
<a name="ln5581">BTextView::_IsOnEmptyLastLine(int32 offset) const</a>
<a name="ln5582">{</a>
<a name="ln5583">	return (offset == TextLength() &amp;&amp; offset &gt; 0</a>
<a name="ln5584">		&amp;&amp; fText-&gt;RealCharAt(offset - 1) == B_ENTER);</a>
<a name="ln5585">}</a>
<a name="ln5586"> </a>
<a name="ln5587"> </a>
<a name="ln5588">void</a>
<a name="ln5589">BTextView::_ApplyStyleRange(int32 fromOffset, int32 toOffset, uint32 mode,</a>
<a name="ln5590">	const BFont* font, const rgb_color* color, bool syncNullStyle)</a>
<a name="ln5591">{</a>
<a name="ln5592">	if (font != NULL) {</a>
<a name="ln5593">		// if a font has been given, normalize it</a>
<a name="ln5594">		BFont normalized = *font;</a>
<a name="ln5595">		_NormalizeFont(&amp;normalized);</a>
<a name="ln5596">		font = &amp;normalized;</a>
<a name="ln5597">	}</a>
<a name="ln5598"> </a>
<a name="ln5599">	if (!fStylable) {</a>
<a name="ln5600">		// always apply font and color to full range for non-stylable textviews</a>
<a name="ln5601">		fromOffset = 0;</a>
<a name="ln5602">		toOffset = fText-&gt;Length();</a>
<a name="ln5603">	}</a>
<a name="ln5604"> </a>
<a name="ln5605">	if (syncNullStyle)</a>
<a name="ln5606">		fStyles-&gt;SyncNullStyle(fromOffset);</a>
<a name="ln5607"> </a>
<a name="ln5608">	fStyles-&gt;SetStyleRange(fromOffset, toOffset, fText-&gt;Length(), mode,</a>
<a name="ln5609">		font, color);</a>
<a name="ln5610">}</a>
<a name="ln5611"> </a>
<a name="ln5612"> </a>
<a name="ln5613">float</a>
<a name="ln5614">BTextView::_NullStyleHeight() const</a>
<a name="ln5615">{</a>
<a name="ln5616">	const BFont* font = NULL;</a>
<a name="ln5617">	fStyles-&gt;GetNullStyle(&amp;font, NULL);</a>
<a name="ln5618"> </a>
<a name="ln5619">	font_height fontHeight;</a>
<a name="ln5620">	font-&gt;GetHeight(&amp;fontHeight);</a>
<a name="ln5621">	return ceilf(fontHeight.ascent + fontHeight.descent + 1);</a>
<a name="ln5622">}</a>
<a name="ln5623"> </a>
<a name="ln5624"> </a>
<a name="ln5625">void</a>
<a name="ln5626">BTextView::_ShowContextMenu(BPoint where)</a>
<a name="ln5627">{</a>
<a name="ln5628">	bool isRedo;</a>
<a name="ln5629">	undo_state state = UndoState(&amp;isRedo);</a>
<a name="ln5630">	bool isUndo = state != B_UNDO_UNAVAILABLE &amp;&amp; !isRedo;</a>
<a name="ln5631"> </a>
<a name="ln5632">	int32 start;</a>
<a name="ln5633">	int32 finish;</a>
<a name="ln5634">	GetSelection(&amp;start, &amp;finish);</a>
<a name="ln5635"> </a>
<a name="ln5636">	bool canEdit = IsEditable();</a>
<a name="ln5637">	int32 length = TextLength();</a>
<a name="ln5638"> </a>
<a name="ln5639">	BPopUpMenu* menu = new BPopUpMenu(B_EMPTY_STRING, false, false);</a>
<a name="ln5640"> </a>
<a name="ln5641">	BLayoutBuilder::Menu&lt;&gt;(menu)</a>
<a name="ln5642">		.AddItem(TRANSLATE(&quot;Undo&quot;), B_UNDO/*, 'Z'*/)</a>
<a name="ln5643">			.SetEnabled(canEdit &amp;&amp; isUndo)</a>
<a name="ln5644">		.AddItem(TRANSLATE(&quot;Redo&quot;), B_UNDO/*, 'Z', B_SHIFT_KEY*/)</a>
<a name="ln5645">			.SetEnabled(canEdit &amp;&amp; isRedo)</a>
<a name="ln5646">		.AddSeparator()</a>
<a name="ln5647">		.AddItem(TRANSLATE(&quot;Cut&quot;), B_CUT, 'X')</a>
<a name="ln5648">			.SetEnabled(canEdit &amp;&amp; start != finish)</a>
<a name="ln5649">		.AddItem(TRANSLATE(&quot;Copy&quot;), B_COPY, 'C')</a>
<a name="ln5650">			.SetEnabled(start != finish)</a>
<a name="ln5651">		.AddItem(TRANSLATE(&quot;Paste&quot;), B_PASTE, 'V')</a>
<a name="ln5652">			.SetEnabled(canEdit &amp;&amp; be_clipboard-&gt;SystemCount() &gt; 0)</a>
<a name="ln5653">		.AddSeparator()</a>
<a name="ln5654">		.AddItem(TRANSLATE(&quot;Select all&quot;), B_SELECT_ALL, 'A')</a>
<a name="ln5655">			.SetEnabled(!(start == 0 &amp;&amp; finish == length))</a>
<a name="ln5656">	;</a>
<a name="ln5657"> </a>
<a name="ln5658">	menu-&gt;SetTargetForItems(this);</a>
<a name="ln5659">	ConvertToScreen(&amp;where);</a>
<a name="ln5660">	menu-&gt;Go(where, true, true,	true);</a>
<a name="ln5661">}</a>
<a name="ln5662"> </a>
<a name="ln5663"> </a>
<a name="ln5664">void</a>
<a name="ln5665">BTextView::_FilterDisallowedChars(char* text, ssize_t&amp; length,</a>
<a name="ln5666">	text_run_array* runArray)</a>
<a name="ln5667">{</a>
<a name="ln5668">	if (!fDisallowedChars)</a>
<a name="ln5669">		return;</a>
<a name="ln5670"> </a>
<a name="ln5671">	if (fDisallowedChars-&gt;IsEmpty() || !text)</a>
<a name="ln5672">		return;</a>
<a name="ln5673"> </a>
<a name="ln5674">	ssize_t stringIndex = 0;</a>
<a name="ln5675">	if (runArray) {</a>
<a name="ln5676">		ssize_t remNext = 0;</a>
<a name="ln5677"> </a>
<a name="ln5678">		for (int i = 0; i &lt; runArray-&gt;count; i++) {</a>
<a name="ln5679">			runArray-&gt;runs[i].offset -= remNext;</a>
<a name="ln5680">			while (stringIndex &lt; runArray-&gt;runs[i].offset</a>
<a name="ln5681">				&amp;&amp; stringIndex &lt; length) {</a>
<a name="ln5682">				if (fDisallowedChars-&gt;HasItem(</a>
<a name="ln5683">					reinterpret_cast&lt;void*&gt;(text[stringIndex]))) {</a>
<a name="ln5684">					memmove(text + stringIndex, text + stringIndex + 1,</a>
<a name="ln5685">						length - stringIndex - 1);</a>
<a name="ln5686">					length--;</a>
<a name="ln5687">					runArray-&gt;runs[i].offset--;</a>
<a name="ln5688">					remNext++;</a>
<a name="ln5689">				} else</a>
<a name="ln5690">					stringIndex++;</a>
<a name="ln5691">			}</a>
<a name="ln5692">		}</a>
<a name="ln5693">	}</a>
<a name="ln5694"> </a>
<a name="ln5695">	while (stringIndex &lt; length) {</a>
<a name="ln5696">		if (fDisallowedChars-&gt;HasItem(</a>
<a name="ln5697">			reinterpret_cast&lt;void*&gt;(text[stringIndex]))) {</a>
<a name="ln5698">			memmove(text + stringIndex, text + stringIndex + 1,</a>
<a name="ln5699">				length - stringIndex - 1);</a>
<a name="ln5700">			length--;</a>
<a name="ln5701">		} else</a>
<a name="ln5702">			stringIndex++;</a>
<a name="ln5703">	}</a>
<a name="ln5704">}</a>
<a name="ln5705"> </a>
<a name="ln5706"> </a>
<a name="ln5707">// #pragma mark - BTextView::TextTrackState</a>
<a name="ln5708"> </a>
<a name="ln5709"> </a>
<a name="ln5710">BTextView::TextTrackState::TextTrackState(BMessenger messenger)</a>
<a name="ln5711">	:</a>
<a name="ln5712">	clickOffset(0),</a>
<a name="ln5713">	shiftDown(false),</a>
<a name="ln5714">	anchor(0),</a>
<a name="ln5715">	selStart(0),</a>
<a name="ln5716">	selEnd(0),</a>
<a name="ln5717">	fRunner(NULL)</a>
<a name="ln5718">{</a>
<a name="ln5719">	BMessage message(_PING_);</a>
<a name="ln5720">	const bigtime_t scrollSpeed = 25 * 1000;	// 40 scroll steps per second</a>
<a name="ln5721">	fRunner = new (nothrow) BMessageRunner(messenger, &amp;message, scrollSpeed);</a>
<a name="ln5722">}</a>
<a name="ln5723"> </a>
<a name="ln5724"> </a>
<a name="ln5725">BTextView::TextTrackState::~TextTrackState()</a>
<a name="ln5726">{</a>
<a name="ln5727">	delete fRunner;</a>
<a name="ln5728">}</a>
<a name="ln5729"> </a>
<a name="ln5730"> </a>
<a name="ln5731">void</a>
<a name="ln5732">BTextView::TextTrackState::SimulateMouseMovement(BTextView* textView)</a>
<a name="ln5733">{</a>
<a name="ln5734">	BPoint where;</a>
<a name="ln5735">	uint32 buttons;</a>
<a name="ln5736">	// When the mouse cursor is still and outside the textview,</a>
<a name="ln5737">	// no B_MOUSE_MOVED message are sent, obviously. But scrolling</a>
<a name="ln5738">	// has to work neverthless, so we &quot;fake&quot; a MouseMoved() call here.</a>
<a name="ln5739">	textView-&gt;GetMouse(&amp;where, &amp;buttons);</a>
<a name="ln5740">	textView-&gt;_PerformMouseMoved(where, B_INSIDE_VIEW);</a>
<a name="ln5741">}</a>
<a name="ln5742"> </a>
<a name="ln5743"> </a>
<a name="ln5744">// #pragma mark - Binary ABI compat</a>
<a name="ln5745"> </a>
<a name="ln5746"> </a>
<a name="ln5747">extern &quot;C&quot; void</a>
<a name="ln5748">B_IF_GCC_2(InvalidateLayout__9BTextViewb,  _ZN9BTextView16InvalidateLayoutEb)(</a>
<a name="ln5749">	BTextView* view, bool descendants)</a>
<a name="ln5750">{</a>
<a name="ln5751">	perform_data_layout_invalidated data;</a>
<a name="ln5752">	data.descendants = descendants;</a>
<a name="ln5753"> </a>
<a name="ln5754">	view-&gt;Perform(PERFORM_CODE_LAYOUT_INVALIDATED, &amp;data);</a>
<a name="ln5755">}</a>

</code></pre>
<div class="balloon" rel="5596"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v506/" target="_blank">V506</a> Pointer to local variable 'normalized' is stored outside the scope of this variable. Such a pointer will become invalid.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
