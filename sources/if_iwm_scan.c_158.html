
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_iwm_scan.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$OpenBSD: if_iwm.c,v 1.39 2015/03/23 00:35:19 jsg Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*</a>
<a name="ln4"> * Copyright (c) 2014 genua mbh &lt;info@genua.de&gt;</a>
<a name="ln5"> * Copyright (c) 2014 Fixup Software Ltd.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln12"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln13"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln14"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln15"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln16"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln17"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> */</a>
<a name="ln19"> </a>
<a name="ln20">/*-</a>
<a name="ln21"> * Based on BSD-licensed source modules in the Linux iwlwifi driver,</a>
<a name="ln22"> * which were used as the reference documentation for this implementation.</a>
<a name="ln23"> *</a>
<a name="ln24"> * Driver version we are currently based off of is</a>
<a name="ln25"> * Linux 3.14.3 (tag id a2df521e42b1d9a23f620ac79dbfe8655a8391dd)</a>
<a name="ln26"> *</a>
<a name="ln27"> ***********************************************************************</a>
<a name="ln28"> *</a>
<a name="ln29"> * This file is provided under a dual BSD/GPLv2 license.  When using or</a>
<a name="ln30"> * redistributing this file, you may do so under either license.</a>
<a name="ln31"> *</a>
<a name="ln32"> * GPL LICENSE SUMMARY</a>
<a name="ln33"> *</a>
<a name="ln34"> * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.</a>
<a name="ln35"> *</a>
<a name="ln36"> * This program is free software; you can redistribute it and/or modify</a>
<a name="ln37"> * it under the terms of version 2 of the GNU General Public License as</a>
<a name="ln38"> * published by the Free Software Foundation.</a>
<a name="ln39"> *</a>
<a name="ln40"> * This program is distributed in the hope that it will be useful, but</a>
<a name="ln41"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln42"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln43"> * General Public License for more details.</a>
<a name="ln44"> *</a>
<a name="ln45"> * You should have received a copy of the GNU General Public License</a>
<a name="ln46"> * along with this program; if not, write to the Free Software</a>
<a name="ln47"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</a>
<a name="ln48"> * USA</a>
<a name="ln49"> *</a>
<a name="ln50"> * The full GNU General Public License is included in this distribution</a>
<a name="ln51"> * in the file called COPYING.</a>
<a name="ln52"> *</a>
<a name="ln53"> * Contact Information:</a>
<a name="ln54"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</a>
<a name="ln55"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</a>
<a name="ln56"> *</a>
<a name="ln57"> *</a>
<a name="ln58"> * BSD LICENSE</a>
<a name="ln59"> *</a>
<a name="ln60"> * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.</a>
<a name="ln61"> * All rights reserved.</a>
<a name="ln62"> *</a>
<a name="ln63"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln64"> * modification, are permitted provided that the following conditions</a>
<a name="ln65"> * are met:</a>
<a name="ln66"> *</a>
<a name="ln67"> *  * Redistributions of source code must retain the above copyright</a>
<a name="ln68"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln69"> *  * Redistributions in binary form must reproduce the above copyright</a>
<a name="ln70"> *    notice, this list of conditions and the following disclaimer in</a>
<a name="ln71"> *    the documentation and/or other materials provided with the</a>
<a name="ln72"> *    distribution.</a>
<a name="ln73"> *  * Neither the name Intel Corporation nor the names of its</a>
<a name="ln74"> *    contributors may be used to endorse or promote products derived</a>
<a name="ln75"> *    from this software without specific prior written permission.</a>
<a name="ln76"> *</a>
<a name="ln77"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln78"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln79"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln80"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln81"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln82"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln83"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln84"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln85"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln86"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln87"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln88"> */</a>
<a name="ln89"> </a>
<a name="ln90">/*-</a>
<a name="ln91"> * Copyright (c) 2007-2010 Damien Bergamini &lt;damien.bergamini@free.fr&gt;</a>
<a name="ln92"> *</a>
<a name="ln93"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln94"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln95"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln96"> *</a>
<a name="ln97"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln98"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln99"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln100"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln101"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln102"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln103"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln104"> */</a>
<a name="ln105">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln106">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/iwm/if_iwm_scan.c 321507 2017-07-26 05:26:01Z adrian $&quot;);</a>
<a name="ln107"> </a>
<a name="ln108">#include &quot;opt_wlan.h&quot;</a>
<a name="ln109">#include &quot;opt_iwm.h&quot;</a>
<a name="ln110"> </a>
<a name="ln111">#include &lt;sys/param.h&gt;</a>
<a name="ln112">#include &lt;sys/bus.h&gt;</a>
<a name="ln113">#include &lt;sys/conf.h&gt;</a>
<a name="ln114">#include &lt;sys/endian.h&gt;</a>
<a name="ln115">#include &lt;sys/firmware.h&gt;</a>
<a name="ln116">#include &lt;sys/kernel.h&gt;</a>
<a name="ln117">#include &lt;sys/malloc.h&gt;</a>
<a name="ln118">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln119">#include &lt;sys/mutex.h&gt;</a>
<a name="ln120">#include &lt;sys/module.h&gt;</a>
<a name="ln121">#include &lt;sys/proc.h&gt;</a>
<a name="ln122">#include &lt;sys/rman.h&gt;</a>
<a name="ln123">#include &lt;sys/socket.h&gt;</a>
<a name="ln124">#include &lt;sys/sockio.h&gt;</a>
<a name="ln125">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln126">#include &lt;sys/linker.h&gt;</a>
<a name="ln127"> </a>
<a name="ln128">#include &lt;machine/bus.h&gt;</a>
<a name="ln129">#include &lt;machine/endian.h&gt;</a>
<a name="ln130">#include &lt;machine/resource.h&gt;</a>
<a name="ln131"> </a>
<a name="ln132">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln133">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln134"> </a>
<a name="ln135">#include &lt;net/bpf.h&gt;</a>
<a name="ln136"> </a>
<a name="ln137">#include &lt;net/if.h&gt;</a>
<a name="ln138">#include &lt;net/if_var.h&gt;</a>
<a name="ln139">#include &lt;net/if_arp.h&gt;</a>
<a name="ln140">#include &lt;net/if_dl.h&gt;</a>
<a name="ln141">#include &lt;net/if_media.h&gt;</a>
<a name="ln142">#include &lt;net/if_types.h&gt;</a>
<a name="ln143"> </a>
<a name="ln144">#include &lt;netinet/in.h&gt;</a>
<a name="ln145">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln146">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln147">#include &lt;netinet/ip.h&gt;</a>
<a name="ln148"> </a>
<a name="ln149">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln150">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln151">#include &lt;net80211/ieee80211_ratectl.h&gt;</a>
<a name="ln152">#include &lt;net80211/ieee80211_radiotap.h&gt;</a>
<a name="ln153"> </a>
<a name="ln154">#include &lt;dev/iwm/if_iwmreg.h&gt;</a>
<a name="ln155">#include &lt;dev/iwm/if_iwmvar.h&gt;</a>
<a name="ln156">#include &lt;dev/iwm/if_iwm_debug.h&gt;</a>
<a name="ln157">#include &lt;dev/iwm/if_iwm_notif_wait.h&gt;</a>
<a name="ln158">#include &lt;dev/iwm/if_iwm_util.h&gt;</a>
<a name="ln159">#include &lt;dev/iwm/if_iwm_scan.h&gt;</a>
<a name="ln160"> </a>
<a name="ln161">/*</a>
<a name="ln162"> * BEGIN mvm/scan.c</a>
<a name="ln163"> */</a>
<a name="ln164"> </a>
<a name="ln165">#define IWM_DENSE_EBS_SCAN_RATIO 5</a>
<a name="ln166">#define IWM_SPARSE_EBS_SCAN_RATIO 1</a>
<a name="ln167"> </a>
<a name="ln168">static uint16_t</a>
<a name="ln169">iwm_mvm_scan_rx_chain(struct iwm_softc *sc)</a>
<a name="ln170">{</a>
<a name="ln171">	uint16_t rx_chain;</a>
<a name="ln172">	uint8_t rx_ant;</a>
<a name="ln173"> </a>
<a name="ln174">	rx_ant = iwm_mvm_get_valid_rx_ant(sc);</a>
<a name="ln175">	rx_chain = rx_ant &lt;&lt; IWM_PHY_RX_CHAIN_VALID_POS;</a>
<a name="ln176">	rx_chain |= rx_ant &lt;&lt; IWM_PHY_RX_CHAIN_FORCE_MIMO_SEL_POS;</a>
<a name="ln177">	rx_chain |= rx_ant &lt;&lt; IWM_PHY_RX_CHAIN_FORCE_SEL_POS;</a>
<a name="ln178">	rx_chain |= 0x1 &lt;&lt; IWM_PHY_RX_CHAIN_DRIVER_FORCE_POS;</a>
<a name="ln179">	return htole16(rx_chain);</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static uint32_t</a>
<a name="ln183">iwm_mvm_scan_rxon_flags(struct ieee80211_channel *c)</a>
<a name="ln184">{</a>
<a name="ln185">	if (IEEE80211_IS_CHAN_2GHZ(c))</a>
<a name="ln186">		return htole32(IWM_PHY_BAND_24);</a>
<a name="ln187">	else</a>
<a name="ln188">		return htole32(IWM_PHY_BAND_5);</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">static uint32_t</a>
<a name="ln192">iwm_mvm_scan_rate_n_flags(struct iwm_softc *sc, int flags, int no_cck)</a>
<a name="ln193">{</a>
<a name="ln194">	uint32_t tx_ant;</a>
<a name="ln195">	int i, ind;</a>
<a name="ln196"> </a>
<a name="ln197">	for (i = 0, ind = sc-&gt;sc_scan_last_antenna;</a>
<a name="ln198">	    i &lt; IWM_RATE_MCS_ANT_NUM; i++) {</a>
<a name="ln199">		ind = (ind + 1) % IWM_RATE_MCS_ANT_NUM;</a>
<a name="ln200">		if (iwm_mvm_get_valid_tx_ant(sc) &amp; (1 &lt;&lt; ind)) {</a>
<a name="ln201">			sc-&gt;sc_scan_last_antenna = ind;</a>
<a name="ln202">			break;</a>
<a name="ln203">		}</a>
<a name="ln204">	}</a>
<a name="ln205">	tx_ant = (1 &lt;&lt; sc-&gt;sc_scan_last_antenna) &lt;&lt; IWM_RATE_MCS_ANT_POS;</a>
<a name="ln206"> </a>
<a name="ln207">	if ((flags &amp; IEEE80211_CHAN_2GHZ) &amp;&amp; !no_cck)</a>
<a name="ln208">		return htole32(IWM_RATE_1M_PLCP | IWM_RATE_MCS_CCK_MSK |</a>
<a name="ln209">				   tx_ant);</a>
<a name="ln210">	else</a>
<a name="ln211">		return htole32(IWM_RATE_6M_PLCP | tx_ant);</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">static inline boolean_t</a>
<a name="ln215">iwm_mvm_rrm_scan_needed(struct iwm_softc *sc)</a>
<a name="ln216">{</a>
<a name="ln217">	/* require rrm scan whenever the fw supports it */</a>
<a name="ln218">	return fw_has_capa(&amp;sc-&gt;sc_fw.ucode_capa,</a>
<a name="ln219">			   IWM_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT);</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">#ifdef IWM_DEBUG</a>
<a name="ln223">static const char *</a>
<a name="ln224">iwm_mvm_ebs_status_str(enum iwm_scan_ebs_status status)</a>
<a name="ln225">{</a>
<a name="ln226">	switch (status) {</a>
<a name="ln227">	case IWM_SCAN_EBS_SUCCESS:</a>
<a name="ln228">		return &quot;successful&quot;;</a>
<a name="ln229">	case IWM_SCAN_EBS_INACTIVE:</a>
<a name="ln230">		return &quot;inactive&quot;;</a>
<a name="ln231">	case IWM_SCAN_EBS_FAILED:</a>
<a name="ln232">	case IWM_SCAN_EBS_CHAN_NOT_FOUND:</a>
<a name="ln233">	default:</a>
<a name="ln234">		return &quot;failed&quot;;</a>
<a name="ln235">	}</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">static const char *</a>
<a name="ln239">iwm_mvm_offload_status_str(enum iwm_scan_offload_complete_status status)</a>
<a name="ln240">{</a>
<a name="ln241">	return (status == IWM_SCAN_OFFLOAD_ABORTED) ? &quot;aborted&quot; : &quot;completed&quot;;</a>
<a name="ln242">}</a>
<a name="ln243">#endif</a>
<a name="ln244"> </a>
<a name="ln245">void</a>
<a name="ln246">iwm_mvm_rx_lmac_scan_complete_notif(struct iwm_softc *sc,</a>
<a name="ln247">    struct iwm_rx_packet *pkt)</a>
<a name="ln248">{</a>
<a name="ln249">	struct iwm_periodic_scan_complete *scan_notif = (void *)pkt-&gt;data;</a>
<a name="ln250"> </a>
<a name="ln251">	/* If this happens, the firmware has mistakenly sent an LMAC</a>
<a name="ln252">	 * notification during UMAC scans -- warn and ignore it.</a>
<a name="ln253">	 */</a>
<a name="ln254">	if (fw_has_capa(&amp;sc-&gt;sc_fw.ucode_capa, IWM_UCODE_TLV_CAPA_UMAC_SCAN)) {</a>
<a name="ln255">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln256">		    &quot;%s: Mistakenly got LMAC notification during UMAC scan\n&quot;,</a>
<a name="ln257">		    __func__);</a>
<a name="ln258">		return;</a>
<a name="ln259">	}</a>
<a name="ln260"> </a>
<a name="ln261">	IWM_DPRINTF(sc, IWM_DEBUG_SCAN, &quot;Regular scan %s, EBS status %s (FW)\n&quot;,</a>
<a name="ln262">	    iwm_mvm_offload_status_str(scan_notif-&gt;status),</a>
<a name="ln263">	    iwm_mvm_ebs_status_str(scan_notif-&gt;ebs_status));</a>
<a name="ln264"> </a>
<a name="ln265">	sc-&gt;last_ebs_successful =</a>
<a name="ln266">			scan_notif-&gt;ebs_status == IWM_SCAN_EBS_SUCCESS ||</a>
<a name="ln267">			scan_notif-&gt;ebs_status == IWM_SCAN_EBS_INACTIVE;</a>
<a name="ln268"> </a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">void</a>
<a name="ln272">iwm_mvm_rx_umac_scan_complete_notif(struct iwm_softc *sc,</a>
<a name="ln273">    struct iwm_rx_packet *pkt)</a>
<a name="ln274">{</a>
<a name="ln275">	struct iwm_umac_scan_complete *notif = (void *)pkt-&gt;data;</a>
<a name="ln276"> </a>
<a name="ln277">	IWM_DPRINTF(sc, IWM_DEBUG_SCAN,</a>
<a name="ln278">	    &quot;Scan completed, uid %u, status %s, EBS status %s\n&quot;,</a>
<a name="ln279">	    le32toh(notif-&gt;uid),</a>
<a name="ln280">	    iwm_mvm_offload_status_str(notif-&gt;status),</a>
<a name="ln281">	    iwm_mvm_ebs_status_str(notif-&gt;ebs_status));</a>
<a name="ln282"> </a>
<a name="ln283">	if (notif-&gt;ebs_status != IWM_SCAN_EBS_SUCCESS &amp;&amp;</a>
<a name="ln284">	    notif-&gt;ebs_status != IWM_SCAN_EBS_INACTIVE)</a>
<a name="ln285">		sc-&gt;last_ebs_successful = FALSE;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">static int</a>
<a name="ln289">iwm_mvm_scan_skip_channel(struct ieee80211_channel *c)</a>
<a name="ln290">{</a>
<a name="ln291">	if (IEEE80211_IS_CHAN_2GHZ(c) &amp;&amp; IEEE80211_IS_CHAN_B(c))</a>
<a name="ln292">		return 0;</a>
<a name="ln293">	else if (IEEE80211_IS_CHAN_5GHZ(c) &amp;&amp; IEEE80211_IS_CHAN_A(c))</a>
<a name="ln294">		return 0;</a>
<a name="ln295">	else</a>
<a name="ln296">		return 1;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">static uint8_t</a>
<a name="ln300">iwm_mvm_lmac_scan_fill_channels(struct iwm_softc *sc,</a>
<a name="ln301">    struct iwm_scan_channel_cfg_lmac *chan, int n_ssids)</a>
<a name="ln302">{</a>
<a name="ln303">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln304">	struct ieee80211_scan_state *ss = ic-&gt;ic_scan;</a>
<a name="ln305">	struct ieee80211_channel *c;</a>
<a name="ln306">	uint8_t nchan;</a>
<a name="ln307">	int j;</a>
<a name="ln308"> </a>
<a name="ln309">	for (nchan = j = 0;</a>
<a name="ln310">	    j &lt; ss-&gt;ss_last &amp;&amp; nchan &lt; sc-&gt;sc_fw.ucode_capa.n_scan_channels;</a>
<a name="ln311">	    j++) {</a>
<a name="ln312">		c = ss-&gt;ss_chans[j];</a>
<a name="ln313">		/*</a>
<a name="ln314">		 * Catch other channels, in case we have 900MHz channels or</a>
<a name="ln315">		 * something in the chanlist.</a>
<a name="ln316">		 */</a>
<a name="ln317">		if (!IEEE80211_IS_CHAN_2GHZ(c) &amp;&amp; !IEEE80211_IS_CHAN_5GHZ(c)) {</a>
<a name="ln318">			IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_EEPROM,</a>
<a name="ln319">			    &quot;%s: skipping channel (freq=%d, ieee=%d, flags=0x%08x)\n&quot;,</a>
<a name="ln320">			    __func__, c-&gt;ic_freq, c-&gt;ic_ieee, c-&gt;ic_flags);</a>
<a name="ln321">			continue;</a>
<a name="ln322">		}</a>
<a name="ln323"> </a>
<a name="ln324">		IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_EEPROM,</a>
<a name="ln325">		    &quot;Adding channel %d (%d Mhz) to the list\n&quot;,</a>
<a name="ln326">		    nchan, c-&gt;ic_freq);</a>
<a name="ln327">		chan-&gt;channel_num = htole16(ieee80211_mhz2ieee(c-&gt;ic_freq, 0));</a>
<a name="ln328">		chan-&gt;iter_count = htole16(1);</a>
<a name="ln329">		chan-&gt;iter_interval = htole32(0);</a>
<a name="ln330">		chan-&gt;flags = htole32(IWM_UNIFIED_SCAN_CHANNEL_PARTIAL);</a>
<a name="ln331">		chan-&gt;flags |= htole32(IWM_SCAN_CHANNEL_NSSIDS(n_ssids));</a>
<a name="ln332">		/* XXX IEEE80211_SCAN_NOBCAST flag is never set. */</a>
<a name="ln333">		if (!IEEE80211_IS_CHAN_PASSIVE(c) &amp;&amp;</a>
<a name="ln334">		    (!(ss-&gt;ss_flags &amp; IEEE80211_SCAN_NOBCAST) || n_ssids != 0))</a>
<a name="ln335">			chan-&gt;flags |= htole32(IWM_SCAN_CHANNEL_TYPE_ACTIVE);</a>
<a name="ln336">		chan++;</a>
<a name="ln337">		nchan++;</a>
<a name="ln338">	}</a>
<a name="ln339"> </a>
<a name="ln340">	return nchan;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">static uint8_t</a>
<a name="ln344">iwm_mvm_umac_scan_fill_channels(struct iwm_softc *sc,</a>
<a name="ln345">    struct iwm_scan_channel_cfg_umac *chan, int n_ssids)</a>
<a name="ln346">{</a>
<a name="ln347">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln348">	struct ieee80211_scan_state *ss = ic-&gt;ic_scan;</a>
<a name="ln349">	struct ieee80211_channel *c;</a>
<a name="ln350">	uint8_t nchan;</a>
<a name="ln351">	int j;</a>
<a name="ln352"> </a>
<a name="ln353">	for (nchan = j = 0;</a>
<a name="ln354">	    j &lt; ss-&gt;ss_last &amp;&amp; nchan &lt; sc-&gt;sc_fw.ucode_capa.n_scan_channels;</a>
<a name="ln355">	    j++) {</a>
<a name="ln356">		c = ss-&gt;ss_chans[j];</a>
<a name="ln357">		/*</a>
<a name="ln358">		 * Catch other channels, in case we have 900MHz channels or</a>
<a name="ln359">		 * something in the chanlist.</a>
<a name="ln360">		 */</a>
<a name="ln361">		if (!IEEE80211_IS_CHAN_2GHZ(c) &amp;&amp; !IEEE80211_IS_CHAN_5GHZ(c)) {</a>
<a name="ln362">			IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_EEPROM,</a>
<a name="ln363">			    &quot;%s: skipping channel (freq=%d, ieee=%d, flags=0x%08x)\n&quot;,</a>
<a name="ln364">			    __func__, c-&gt;ic_freq, c-&gt;ic_ieee, c-&gt;ic_flags);</a>
<a name="ln365">			continue;</a>
<a name="ln366">		}</a>
<a name="ln367"> </a>
<a name="ln368">		IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_EEPROM,</a>
<a name="ln369">		    &quot;Adding channel %d (%d Mhz) to the list\n&quot;,</a>
<a name="ln370">		    nchan, c-&gt;ic_freq);</a>
<a name="ln371">		chan-&gt;channel_num = ieee80211_mhz2ieee(c-&gt;ic_freq, 0);</a>
<a name="ln372">		chan-&gt;iter_count = 1;</a>
<a name="ln373">		chan-&gt;iter_interval = htole16(0);</a>
<a name="ln374">		chan-&gt;flags = htole32(IWM_SCAN_CHANNEL_UMAC_NSSIDS(n_ssids));</a>
<a name="ln375">		chan++;</a>
<a name="ln376">		nchan++;</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	return nchan;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">static int</a>
<a name="ln383">iwm_mvm_fill_probe_req(struct iwm_softc *sc, struct iwm_scan_probe_req *preq)</a>
<a name="ln384">{</a>
<a name="ln385">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln386">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln387">	struct ieee80211_frame *wh = (struct ieee80211_frame *)preq-&gt;buf;</a>
<a name="ln388">	struct ieee80211_rateset *rs;</a>
<a name="ln389">	size_t remain = sizeof(preq-&gt;buf);</a>
<a name="ln390">	uint8_t *frm, *pos;</a>
<a name="ln391"> </a>
<a name="ln392">	memset(preq, 0, sizeof(*preq));</a>
<a name="ln393"> </a>
<a name="ln394">	/* Ensure enough space for header and SSID IE. */</a>
<a name="ln395">	if (remain &lt; sizeof(*wh) + 2)</a>
<a name="ln396">		return ENOBUFS;</a>
<a name="ln397"> </a>
<a name="ln398">	/*</a>
<a name="ln399">	 * Build a probe request frame.  Most of the following code is a</a>
<a name="ln400">	 * copy &amp; paste of what is done in net80211.</a>
<a name="ln401">	 */</a>
<a name="ln402">	wh-&gt;i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |</a>
<a name="ln403">	    IEEE80211_FC0_SUBTYPE_PROBE_REQ;</a>
<a name="ln404">	wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_NODS;</a>
<a name="ln405">	IEEE80211_ADDR_COPY(wh-&gt;i_addr1, ieee80211broadcastaddr);</a>
<a name="ln406">	IEEE80211_ADDR_COPY(wh-&gt;i_addr2, vap ? vap-&gt;iv_myaddr : ic-&gt;ic_macaddr);</a>
<a name="ln407">	IEEE80211_ADDR_COPY(wh-&gt;i_addr3, ieee80211broadcastaddr);</a>
<a name="ln408">	*(uint16_t *)&amp;wh-&gt;i_dur[0] = 0; /* filled by HW */</a>
<a name="ln409">	*(uint16_t *)&amp;wh-&gt;i_seq[0] = 0; /* filled by HW */</a>
<a name="ln410"> </a>
<a name="ln411">	frm = (uint8_t *)(wh + 1);</a>
<a name="ln412">	frm = ieee80211_add_ssid(frm, NULL, 0);</a>
<a name="ln413"> </a>
<a name="ln414">	/* Tell the firmware where the MAC header is. */</a>
<a name="ln415">	preq-&gt;mac_header.offset = 0;</a>
<a name="ln416">	preq-&gt;mac_header.len = htole16(frm - (uint8_t *)wh);</a>
<a name="ln417">	remain -= frm - (uint8_t *)wh;</a>
<a name="ln418"> </a>
<a name="ln419">	/* Fill in 2GHz IEs and tell firmware where they are. */</a>
<a name="ln420">	rs = &amp;ic-&gt;ic_sup_rates[IEEE80211_MODE_11G];</a>
<a name="ln421">	if (rs-&gt;rs_nrates &gt; IEEE80211_RATE_SIZE) {</a>
<a name="ln422">		if (remain &lt; 4 + rs-&gt;rs_nrates)</a>
<a name="ln423">			return ENOBUFS;</a>
<a name="ln424">	} else if (remain &lt; 2 + rs-&gt;rs_nrates) {</a>
<a name="ln425">		return ENOBUFS;</a>
<a name="ln426">	}</a>
<a name="ln427">	preq-&gt;band_data[0].offset = htole16(frm - (uint8_t *)wh);</a>
<a name="ln428">	pos = frm;</a>
<a name="ln429">	frm = ieee80211_add_rates(frm, rs);</a>
<a name="ln430">	if (rs-&gt;rs_nrates &gt; IEEE80211_RATE_SIZE)</a>
<a name="ln431">		frm = ieee80211_add_xrates(frm, rs);</a>
<a name="ln432">	preq-&gt;band_data[0].len = htole16(frm - pos);</a>
<a name="ln433">	remain -= frm - pos;</a>
<a name="ln434"> </a>
<a name="ln435">	if (iwm_mvm_rrm_scan_needed(sc)) {</a>
<a name="ln436">		if (remain &lt; 3)</a>
<a name="ln437">			return ENOBUFS;</a>
<a name="ln438">		*frm++ = IEEE80211_ELEMID_DSPARMS;</a>
<a name="ln439">		*frm++ = 1;</a>
<a name="ln440">		*frm++ = 0;</a>
<a name="ln441">		remain -= 3;</a>
<a name="ln442">	}</a>
<a name="ln443"> </a>
<a name="ln444">	if (sc-&gt;nvm_data-&gt;sku_cap_band_52GHz_enable) {</a>
<a name="ln445">		/* Fill in 5GHz IEs. */</a>
<a name="ln446">		rs = &amp;ic-&gt;ic_sup_rates[IEEE80211_MODE_11A];</a>
<a name="ln447">		if (rs-&gt;rs_nrates &gt; IEEE80211_RATE_SIZE) {</a>
<a name="ln448">			if (remain &lt; 4 + rs-&gt;rs_nrates)</a>
<a name="ln449">				return ENOBUFS;</a>
<a name="ln450">		} else if (remain &lt; 2 + rs-&gt;rs_nrates) {</a>
<a name="ln451">			return ENOBUFS;</a>
<a name="ln452">		}</a>
<a name="ln453">		preq-&gt;band_data[1].offset = htole16(frm - (uint8_t *)wh);</a>
<a name="ln454">		pos = frm;</a>
<a name="ln455">		frm = ieee80211_add_rates(frm, rs);</a>
<a name="ln456">		if (rs-&gt;rs_nrates &gt; IEEE80211_RATE_SIZE)</a>
<a name="ln457">			frm = ieee80211_add_xrates(frm, rs);</a>
<a name="ln458">		preq-&gt;band_data[1].len = htole16(frm - pos);</a>
<a name="ln459">		remain -= frm - pos;</a>
<a name="ln460">	}</a>
<a name="ln461"> </a>
<a name="ln462">	/* Send 11n IEs on both 2GHz and 5GHz bands. */</a>
<a name="ln463">	preq-&gt;common_data.offset = htole16(frm - (uint8_t *)wh);</a>
<a name="ln464">	pos = frm;</a>
<a name="ln465">#if 0</a>
<a name="ln466">	if (ic-&gt;ic_flags &amp; IEEE80211_F_HTON) {</a>
<a name="ln467">		if (remain &lt; 28)</a>
<a name="ln468">			return ENOBUFS;</a>
<a name="ln469">		frm = ieee80211_add_htcaps(frm, ic);</a>
<a name="ln470">		/* XXX add WME info? */</a>
<a name="ln471">	}</a>
<a name="ln472">#endif</a>
<a name="ln473">	preq-&gt;common_data.len = htole16(frm - pos);</a>
<a name="ln474"> </a>
<a name="ln475">	return 0;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">int</a>
<a name="ln479">iwm_mvm_config_umac_scan(struct iwm_softc *sc)</a>
<a name="ln480">{</a>
<a name="ln481">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln482">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln483"> </a>
<a name="ln484">	struct iwm_scan_config *scan_config;</a>
<a name="ln485">	int ret, j, nchan;</a>
<a name="ln486">	size_t cmd_size;</a>
<a name="ln487">	struct ieee80211_channel *c;</a>
<a name="ln488">	struct iwm_host_cmd hcmd = {</a>
<a name="ln489">		.id = iwm_cmd_id(IWM_SCAN_CFG_CMD, IWM_ALWAYS_LONG_GROUP, 0),</a>
<a name="ln490">		.flags = IWM_CMD_SYNC,</a>
<a name="ln491">	};</a>
<a name="ln492">	static const uint32_t rates = (IWM_SCAN_CONFIG_RATE_1M |</a>
<a name="ln493">	    IWM_SCAN_CONFIG_RATE_2M | IWM_SCAN_CONFIG_RATE_5M |</a>
<a name="ln494">	    IWM_SCAN_CONFIG_RATE_11M | IWM_SCAN_CONFIG_RATE_6M |</a>
<a name="ln495">	    IWM_SCAN_CONFIG_RATE_9M | IWM_SCAN_CONFIG_RATE_12M |</a>
<a name="ln496">	    IWM_SCAN_CONFIG_RATE_18M | IWM_SCAN_CONFIG_RATE_24M |</a>
<a name="ln497">	    IWM_SCAN_CONFIG_RATE_36M | IWM_SCAN_CONFIG_RATE_48M |</a>
<a name="ln498">	    IWM_SCAN_CONFIG_RATE_54M);</a>
<a name="ln499"> </a>
<a name="ln500">	cmd_size = sizeof(*scan_config) + sc-&gt;sc_fw.ucode_capa.n_scan_channels;</a>
<a name="ln501"> </a>
<a name="ln502">	scan_config = malloc(cmd_size, M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln503">	if (scan_config == NULL)</a>
<a name="ln504">		return ENOMEM;</a>
<a name="ln505"> </a>
<a name="ln506">	scan_config-&gt;tx_chains = htole32(iwm_mvm_get_valid_tx_ant(sc));</a>
<a name="ln507">	scan_config-&gt;rx_chains = htole32(iwm_mvm_get_valid_rx_ant(sc));</a>
<a name="ln508">	scan_config-&gt;legacy_rates = htole32(rates |</a>
<a name="ln509">	    IWM_SCAN_CONFIG_SUPPORTED_RATE(rates));</a>
<a name="ln510"> </a>
<a name="ln511">	/* These timings correspond to iwlwifi's UNASSOC scan. */</a>
<a name="ln512">	scan_config-&gt;dwell_active = 10;</a>
<a name="ln513">	scan_config-&gt;dwell_passive = 110;</a>
<a name="ln514">	scan_config-&gt;dwell_fragmented = 44;</a>
<a name="ln515">	scan_config-&gt;dwell_extended = 90;</a>
<a name="ln516">	scan_config-&gt;out_of_channel_time = htole32(0);</a>
<a name="ln517">	scan_config-&gt;suspend_time = htole32(0);</a>
<a name="ln518"> </a>
<a name="ln519">	IEEE80211_ADDR_COPY(scan_config-&gt;mac_addr,</a>
<a name="ln520">	    vap ? vap-&gt;iv_myaddr : ic-&gt;ic_macaddr);</a>
<a name="ln521"> </a>
<a name="ln522">	scan_config-&gt;bcast_sta_id = sc-&gt;sc_aux_sta.sta_id;</a>
<a name="ln523">	scan_config-&gt;channel_flags = IWM_CHANNEL_FLAG_EBS |</a>
<a name="ln524">	    IWM_CHANNEL_FLAG_ACCURATE_EBS | IWM_CHANNEL_FLAG_EBS_ADD |</a>
<a name="ln525">	    IWM_CHANNEL_FLAG_PRE_SCAN_PASSIVE2ACTIVE;</a>
<a name="ln526"> </a>
<a name="ln527">	for (nchan = j = 0;</a>
<a name="ln528">	    j &lt; ic-&gt;ic_nchans &amp;&amp; nchan &lt; sc-&gt;sc_fw.ucode_capa.n_scan_channels;</a>
<a name="ln529">	    j++) {</a>
<a name="ln530">		c = &amp;ic-&gt;ic_channels[j];</a>
<a name="ln531">		/* For 2GHz, only populate 11b channels */</a>
<a name="ln532">		/* For 5GHz, only populate 11a channels */</a>
<a name="ln533">		/*</a>
<a name="ln534">		 * Catch other channels, in case we have 900MHz channels or</a>
<a name="ln535">		 * something in the chanlist.</a>
<a name="ln536">		 */</a>
<a name="ln537">		if (iwm_mvm_scan_skip_channel(c))</a>
<a name="ln538">			continue;</a>
<a name="ln539">		scan_config-&gt;channel_array[nchan++] =</a>
<a name="ln540">		    ieee80211_mhz2ieee(c-&gt;ic_freq, 0);</a>
<a name="ln541">	}</a>
<a name="ln542"> </a>
<a name="ln543">	scan_config-&gt;flags = htole32(IWM_SCAN_CONFIG_FLAG_ACTIVATE |</a>
<a name="ln544">	    IWM_SCAN_CONFIG_FLAG_ALLOW_CHUB_REQS |</a>
<a name="ln545">	    IWM_SCAN_CONFIG_FLAG_SET_TX_CHAINS |</a>
<a name="ln546">	    IWM_SCAN_CONFIG_FLAG_SET_RX_CHAINS |</a>
<a name="ln547">	    IWM_SCAN_CONFIG_FLAG_SET_AUX_STA_ID |</a>
<a name="ln548">	    IWM_SCAN_CONFIG_FLAG_SET_ALL_TIMES |</a>
<a name="ln549">	    IWM_SCAN_CONFIG_FLAG_SET_LEGACY_RATES |</a>
<a name="ln550">	    IWM_SCAN_CONFIG_FLAG_SET_MAC_ADDR |</a>
<a name="ln551">	    IWM_SCAN_CONFIG_FLAG_SET_CHANNEL_FLAGS|</a>
<a name="ln552">	    IWM_SCAN_CONFIG_N_CHANNELS(nchan) |</a>
<a name="ln553">	    IWM_SCAN_CONFIG_FLAG_CLEAR_FRAGMENTED);</a>
<a name="ln554"> </a>
<a name="ln555">	hcmd.data[0] = scan_config;</a>
<a name="ln556">	hcmd.len[0] = cmd_size;</a>
<a name="ln557"> </a>
<a name="ln558">	IWM_DPRINTF(sc, IWM_DEBUG_SCAN, &quot;Sending UMAC scan config\n&quot;);</a>
<a name="ln559"> </a>
<a name="ln560">	ret = iwm_send_cmd(sc, &amp;hcmd);</a>
<a name="ln561">	if (!ret)</a>
<a name="ln562">		IWM_DPRINTF(sc, IWM_DEBUG_SCAN,</a>
<a name="ln563">		    &quot;UMAC scan config was sent successfully\n&quot;);</a>
<a name="ln564"> </a>
<a name="ln565">	free(scan_config, M_DEVBUF);</a>
<a name="ln566">	return ret;</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">static boolean_t</a>
<a name="ln570">iwm_mvm_scan_use_ebs(struct iwm_softc *sc)</a>
<a name="ln571">{</a>
<a name="ln572">	const struct iwm_ucode_capabilities *capa = &amp;sc-&gt;sc_fw.ucode_capa;</a>
<a name="ln573"> </a>
<a name="ln574">	/* We can only use EBS if:</a>
<a name="ln575">	 *	1. the feature is supported;</a>
<a name="ln576">	 *	2. the last EBS was successful;</a>
<a name="ln577">	 *	3. if only single scan, the single scan EBS API is supported;</a>
<a name="ln578">	 *	4. it's not a p2p find operation.</a>
<a name="ln579">	 */</a>
<a name="ln580">	return ((capa-&gt;flags &amp; IWM_UCODE_TLV_FLAGS_EBS_SUPPORT) &amp;&amp;</a>
<a name="ln581">		sc-&gt;last_ebs_successful);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">int</a>
<a name="ln585">iwm_mvm_umac_scan(struct iwm_softc *sc)</a>
<a name="ln586">{</a>
<a name="ln587">	struct iwm_host_cmd hcmd = {</a>
<a name="ln588">		.id = iwm_cmd_id(IWM_SCAN_REQ_UMAC, IWM_ALWAYS_LONG_GROUP, 0),</a>
<a name="ln589">		.len = { 0, },</a>
<a name="ln590">		.data = { NULL, },</a>
<a name="ln591">		.flags = IWM_CMD_SYNC,</a>
<a name="ln592">	};</a>
<a name="ln593">	struct ieee80211_scan_state *ss = sc-&gt;sc_ic.ic_scan;</a>
<a name="ln594">	struct iwm_scan_req_umac *req;</a>
<a name="ln595">	struct iwm_scan_req_umac_tail *tail;</a>
<a name="ln596">	size_t req_len;</a>
<a name="ln597">	uint8_t i, nssid;</a>
<a name="ln598">	int ret;</a>
<a name="ln599"> </a>
<a name="ln600">	req_len = sizeof(struct iwm_scan_req_umac) +</a>
<a name="ln601">	    (sizeof(struct iwm_scan_channel_cfg_umac) *</a>
<a name="ln602">	    sc-&gt;sc_fw.ucode_capa.n_scan_channels) +</a>
<a name="ln603">	    sizeof(struct iwm_scan_req_umac_tail);</a>
<a name="ln604">	if (req_len &gt; IWM_MAX_CMD_PAYLOAD_SIZE)</a>
<a name="ln605">		return ENOMEM;</a>
<a name="ln606">	req = malloc(req_len, M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln607">	if (req == NULL)</a>
<a name="ln608">		return ENOMEM;</a>
<a name="ln609"> </a>
<a name="ln610">	hcmd.len[0] = (uint16_t)req_len;</a>
<a name="ln611">	hcmd.data[0] = (void *)req;</a>
<a name="ln612"> </a>
<a name="ln613">	IWM_DPRINTF(sc, IWM_DEBUG_SCAN, &quot;Handling ieee80211 scan request\n&quot;);</a>
<a name="ln614"> </a>
<a name="ln615">	/* These timings correspond to iwlwifi's UNASSOC scan. */</a>
<a name="ln616">	req-&gt;active_dwell = 10;</a>
<a name="ln617">	req-&gt;passive_dwell = 110;</a>
<a name="ln618">	req-&gt;fragmented_dwell = 44;</a>
<a name="ln619">	req-&gt;extended_dwell = 90;</a>
<a name="ln620">	req-&gt;max_out_time = 0;</a>
<a name="ln621">	req-&gt;suspend_time = 0;</a>
<a name="ln622"> </a>
<a name="ln623">	req-&gt;scan_priority = htole32(IWM_SCAN_PRIORITY_HIGH);</a>
<a name="ln624">	req-&gt;ooc_priority = htole32(IWM_SCAN_PRIORITY_HIGH);</a>
<a name="ln625"> </a>
<a name="ln626">	nssid = MIN(ss-&gt;ss_nssid, IWM_PROBE_OPTION_MAX);</a>
<a name="ln627">	req-&gt;n_channels = iwm_mvm_umac_scan_fill_channels(sc,</a>
<a name="ln628">	    (struct iwm_scan_channel_cfg_umac *)req-&gt;data, nssid);</a>
<a name="ln629"> </a>
<a name="ln630">	req-&gt;general_flags = htole32(IWM_UMAC_SCAN_GEN_FLAGS_PASS_ALL |</a>
<a name="ln631">	    IWM_UMAC_SCAN_GEN_FLAGS_ITER_COMPLETE |</a>
<a name="ln632">	    IWM_UMAC_SCAN_GEN_FLAGS_EXTENDED_DWELL);</a>
<a name="ln633"> </a>
<a name="ln634">	tail = (void *)((char *)&amp;req-&gt;data +</a>
<a name="ln635">		sizeof(struct iwm_scan_channel_cfg_umac) *</a>
<a name="ln636">			sc-&gt;sc_fw.ucode_capa.n_scan_channels);</a>
<a name="ln637"> </a>
<a name="ln638">	/* Check if we're doing an active directed scan. */</a>
<a name="ln639">	for (i = 0; i &lt; nssid; i++) {</a>
<a name="ln640">		tail-&gt;direct_scan[i].id = IEEE80211_ELEMID_SSID;</a>
<a name="ln641">		tail-&gt;direct_scan[i].len = MIN(ss-&gt;ss_ssid[i].len,</a>
<a name="ln642">		    IEEE80211_NWID_LEN);</a>
<a name="ln643">		memcpy(tail-&gt;direct_scan[i].ssid, ss-&gt;ss_ssid[i].ssid,</a>
<a name="ln644">		    tail-&gt;direct_scan[i].len);</a>
<a name="ln645">		/* XXX debug */</a>
<a name="ln646">	}</a>
<a name="ln647">	if (nssid != 0) {</a>
<a name="ln648">		req-&gt;general_flags |=</a>
<a name="ln649">		    htole32(IWM_UMAC_SCAN_GEN_FLAGS_PRE_CONNECT);</a>
<a name="ln650">	} else</a>
<a name="ln651">		req-&gt;general_flags |= htole32(IWM_UMAC_SCAN_GEN_FLAGS_PASSIVE);</a>
<a name="ln652"> </a>
<a name="ln653">	if (iwm_mvm_scan_use_ebs(sc))</a>
<a name="ln654">		req-&gt;channel_flags = IWM_SCAN_CHANNEL_FLAG_EBS |</a>
<a name="ln655">				     IWM_SCAN_CHANNEL_FLAG_EBS_ACCURATE |</a>
<a name="ln656">				     IWM_SCAN_CHANNEL_FLAG_CACHE_ADD;</a>
<a name="ln657"> </a>
<a name="ln658">	if (iwm_mvm_rrm_scan_needed(sc))</a>
<a name="ln659">		req-&gt;general_flags |=</a>
<a name="ln660">		    htole32(IWM_UMAC_SCAN_GEN_FLAGS_RRM_ENABLED);</a>
<a name="ln661"> </a>
<a name="ln662">	ret = iwm_mvm_fill_probe_req(sc, &amp;tail-&gt;preq);</a>
<a name="ln663">	if (ret) {</a>
<a name="ln664">		free(req, M_DEVBUF);</a>
<a name="ln665">		return ret;</a>
<a name="ln666">	}</a>
<a name="ln667"> </a>
<a name="ln668">	/* Specify the scan plan: We'll do one iteration. */</a>
<a name="ln669">	tail-&gt;schedule[0].interval = 0;</a>
<a name="ln670">	tail-&gt;schedule[0].iter_count = 1;</a>
<a name="ln671"> </a>
<a name="ln672">	ret = iwm_send_cmd(sc, &amp;hcmd);</a>
<a name="ln673">	if (!ret)</a>
<a name="ln674">		IWM_DPRINTF(sc, IWM_DEBUG_SCAN,</a>
<a name="ln675">		    &quot;Scan request was sent successfully\n&quot;);</a>
<a name="ln676">	free(req, M_DEVBUF);</a>
<a name="ln677">	return ret;</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">int</a>
<a name="ln681">iwm_mvm_lmac_scan(struct iwm_softc *sc)</a>
<a name="ln682">{</a>
<a name="ln683">	struct iwm_host_cmd hcmd = {</a>
<a name="ln684">		.id = IWM_SCAN_OFFLOAD_REQUEST_CMD,</a>
<a name="ln685">		.len = { 0, },</a>
<a name="ln686">		.data = { NULL, },</a>
<a name="ln687">		.flags = IWM_CMD_SYNC,</a>
<a name="ln688">	};</a>
<a name="ln689">	struct ieee80211_scan_state *ss = sc-&gt;sc_ic.ic_scan;</a>
<a name="ln690">	struct iwm_scan_req_lmac *req;</a>
<a name="ln691">	size_t req_len;</a>
<a name="ln692">	uint8_t i, nssid;</a>
<a name="ln693">	int ret;</a>
<a name="ln694"> </a>
<a name="ln695">	IWM_DPRINTF(sc, IWM_DEBUG_SCAN,</a>
<a name="ln696">	    &quot;Handling ieee80211 scan request\n&quot;);</a>
<a name="ln697"> </a>
<a name="ln698">	req_len = sizeof(struct iwm_scan_req_lmac) +</a>
<a name="ln699">	    (sizeof(struct iwm_scan_channel_cfg_lmac) *</a>
<a name="ln700">	    sc-&gt;sc_fw.ucode_capa.n_scan_channels) + sizeof(struct iwm_scan_probe_req);</a>
<a name="ln701">	if (req_len &gt; IWM_MAX_CMD_PAYLOAD_SIZE)</a>
<a name="ln702">		return ENOMEM;</a>
<a name="ln703">	req = malloc(req_len, M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln704">	if (req == NULL)</a>
<a name="ln705">		return ENOMEM;</a>
<a name="ln706"> </a>
<a name="ln707">	hcmd.len[0] = (uint16_t)req_len;</a>
<a name="ln708">	hcmd.data[0] = (void *)req;</a>
<a name="ln709"> </a>
<a name="ln710">	/* These timings correspond to iwlwifi's UNASSOC scan. */</a>
<a name="ln711">	req-&gt;active_dwell = 10;</a>
<a name="ln712">	req-&gt;passive_dwell = 110;</a>
<a name="ln713">	req-&gt;fragmented_dwell = 44;</a>
<a name="ln714">	req-&gt;extended_dwell = 90;</a>
<a name="ln715">	req-&gt;max_out_time = 0;</a>
<a name="ln716">	req-&gt;suspend_time = 0;</a>
<a name="ln717"> </a>
<a name="ln718">	req-&gt;scan_prio = htole32(IWM_SCAN_PRIORITY_HIGH);</a>
<a name="ln719">	req-&gt;rx_chain_select = iwm_mvm_scan_rx_chain(sc);</a>
<a name="ln720">	req-&gt;iter_num = htole32(1);</a>
<a name="ln721">	req-&gt;delay = 0;</a>
<a name="ln722"> </a>
<a name="ln723">	req-&gt;scan_flags = htole32(IWM_MVM_LMAC_SCAN_FLAG_PASS_ALL |</a>
<a name="ln724">	    IWM_MVM_LMAC_SCAN_FLAG_ITER_COMPLETE |</a>
<a name="ln725">	    IWM_MVM_LMAC_SCAN_FLAG_EXTENDED_DWELL);</a>
<a name="ln726">	if (iwm_mvm_rrm_scan_needed(sc))</a>
<a name="ln727">		req-&gt;scan_flags |= htole32(IWM_MVM_LMAC_SCAN_FLAGS_RRM_ENABLED);</a>
<a name="ln728"> </a>
<a name="ln729">	req-&gt;flags = iwm_mvm_scan_rxon_flags(sc-&gt;sc_ic.ic_scan-&gt;ss_chans[0]);</a>
<a name="ln730"> </a>
<a name="ln731">	req-&gt;filter_flags =</a>
<a name="ln732">	    htole32(IWM_MAC_FILTER_ACCEPT_GRP | IWM_MAC_FILTER_IN_BEACON);</a>
<a name="ln733"> </a>
<a name="ln734">	/* Tx flags 2 GHz. */</a>
<a name="ln735">	req-&gt;tx_cmd[0].tx_flags = htole32(IWM_TX_CMD_FLG_SEQ_CTL |</a>
<a name="ln736">	    IWM_TX_CMD_FLG_BT_DIS);</a>
<a name="ln737">	req-&gt;tx_cmd[0].rate_n_flags =</a>
<a name="ln738">	    iwm_mvm_scan_rate_n_flags(sc, IEEE80211_CHAN_2GHZ, 1/*XXX*/);</a>
<a name="ln739">	req-&gt;tx_cmd[0].sta_id = sc-&gt;sc_aux_sta.sta_id;</a>
<a name="ln740"> </a>
<a name="ln741">	/* Tx flags 5 GHz. */</a>
<a name="ln742">	req-&gt;tx_cmd[1].tx_flags = htole32(IWM_TX_CMD_FLG_SEQ_CTL |</a>
<a name="ln743">	    IWM_TX_CMD_FLG_BT_DIS);</a>
<a name="ln744">	req-&gt;tx_cmd[1].rate_n_flags =</a>
<a name="ln745">	    iwm_mvm_scan_rate_n_flags(sc, IEEE80211_CHAN_5GHZ, 1/*XXX*/);</a>
<a name="ln746">	req-&gt;tx_cmd[1].sta_id = sc-&gt;sc_aux_sta.sta_id;</a>
<a name="ln747"> </a>
<a name="ln748">	/* Check if we're doing an active directed scan. */</a>
<a name="ln749">	nssid = MIN(ss-&gt;ss_nssid, IWM_PROBE_OPTION_MAX);</a>
<a name="ln750">	for (i = 0; i &lt; nssid; i++) {</a>
<a name="ln751">		req-&gt;direct_scan[i].id = IEEE80211_ELEMID_SSID;</a>
<a name="ln752">		req-&gt;direct_scan[i].len = MIN(ss-&gt;ss_ssid[i].len,</a>
<a name="ln753">		    IEEE80211_NWID_LEN);</a>
<a name="ln754">		memcpy(req-&gt;direct_scan[i].ssid, ss-&gt;ss_ssid[i].ssid,</a>
<a name="ln755">		    req-&gt;direct_scan[i].len);</a>
<a name="ln756">		/* XXX debug */</a>
<a name="ln757">	}</a>
<a name="ln758">	if (nssid != 0) {</a>
<a name="ln759">		req-&gt;scan_flags |=</a>
<a name="ln760">		    htole32(IWM_MVM_LMAC_SCAN_FLAG_PRE_CONNECTION);</a>
<a name="ln761">	} else</a>
<a name="ln762">		req-&gt;scan_flags |= htole32(IWM_MVM_LMAC_SCAN_FLAG_PASSIVE);</a>
<a name="ln763"> </a>
<a name="ln764">	req-&gt;n_channels = iwm_mvm_lmac_scan_fill_channels(sc,</a>
<a name="ln765">	    (struct iwm_scan_channel_cfg_lmac *)req-&gt;data, nssid);</a>
<a name="ln766"> </a>
<a name="ln767">	ret = iwm_mvm_fill_probe_req(sc,</a>
<a name="ln768">			    (struct iwm_scan_probe_req *)(req-&gt;data +</a>
<a name="ln769">			    (sizeof(struct iwm_scan_channel_cfg_lmac) *</a>
<a name="ln770">			    sc-&gt;sc_fw.ucode_capa.n_scan_channels)));</a>
<a name="ln771">	if (ret) {</a>
<a name="ln772">		free(req, M_DEVBUF);</a>
<a name="ln773">		return ret;</a>
<a name="ln774">	}</a>
<a name="ln775"> </a>
<a name="ln776">	/* Specify the scan plan: We'll do one iteration. */</a>
<a name="ln777">	req-&gt;schedule[0].iterations = 1;</a>
<a name="ln778">	req-&gt;schedule[0].full_scan_mul = 1;</a>
<a name="ln779"> </a>
<a name="ln780">	if (iwm_mvm_scan_use_ebs(sc)) {</a>
<a name="ln781">		req-&gt;channel_opt[0].flags =</a>
<a name="ln782">			htole16(IWM_SCAN_CHANNEL_FLAG_EBS |</a>
<a name="ln783">				IWM_SCAN_CHANNEL_FLAG_EBS_ACCURATE |</a>
<a name="ln784">				IWM_SCAN_CHANNEL_FLAG_CACHE_ADD);</a>
<a name="ln785">		req-&gt;channel_opt[0].non_ebs_ratio =</a>
<a name="ln786">			htole16(IWM_DENSE_EBS_SCAN_RATIO);</a>
<a name="ln787">		req-&gt;channel_opt[1].flags =</a>
<a name="ln788">			htole16(IWM_SCAN_CHANNEL_FLAG_EBS |</a>
<a name="ln789">				IWM_SCAN_CHANNEL_FLAG_EBS_ACCURATE |</a>
<a name="ln790">				IWM_SCAN_CHANNEL_FLAG_CACHE_ADD);</a>
<a name="ln791">		req-&gt;channel_opt[1].non_ebs_ratio =</a>
<a name="ln792">			htole16(IWM_SPARSE_EBS_SCAN_RATIO);</a>
<a name="ln793">	}</a>
<a name="ln794"> </a>
<a name="ln795">	ret = iwm_send_cmd(sc, &amp;hcmd);</a>
<a name="ln796">	if (!ret) {</a>
<a name="ln797">		IWM_DPRINTF(sc, IWM_DEBUG_SCAN,</a>
<a name="ln798">		    &quot;Scan request was sent successfully\n&quot;);</a>
<a name="ln799">	}</a>
<a name="ln800">	free(req, M_DEVBUF);</a>
<a name="ln801">	return ret;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">static int</a>
<a name="ln805">iwm_mvm_lmac_scan_abort(struct iwm_softc *sc)</a>
<a name="ln806">{</a>
<a name="ln807">	int ret;</a>
<a name="ln808">	struct iwm_host_cmd hcmd = {</a>
<a name="ln809">		.id = IWM_SCAN_OFFLOAD_ABORT_CMD,</a>
<a name="ln810">		.len = { 0, },</a>
<a name="ln811">		.data = { NULL, },</a>
<a name="ln812">		.flags = IWM_CMD_SYNC,</a>
<a name="ln813">	};</a>
<a name="ln814">	uint32_t status;</a>
<a name="ln815"> </a>
<a name="ln816">	ret = iwm_mvm_send_cmd_status(sc, &amp;hcmd, &amp;status);</a>
<a name="ln817">	if (ret)</a>
<a name="ln818">		return ret;</a>
<a name="ln819"> </a>
<a name="ln820">	if (status != IWM_CAN_ABORT_STATUS) {</a>
<a name="ln821">		/*</a>
<a name="ln822">		 * The scan abort will return 1 for success or</a>
<a name="ln823">		 * 2 for &quot;failure&quot;.  A failure condition can be</a>
<a name="ln824">		 * due to simply not being in an active scan which</a>
<a name="ln825">		 * can occur if we send the scan abort before the</a>
<a name="ln826">		 * microcode has notified us that a scan is completed.</a>
<a name="ln827">		 */</a>
<a name="ln828">		IWM_DPRINTF(sc, IWM_DEBUG_SCAN,</a>
<a name="ln829">		    &quot;SCAN OFFLOAD ABORT ret %d.\n&quot;, status);</a>
<a name="ln830">		ret = ENOENT;</a>
<a name="ln831">	}</a>
<a name="ln832"> </a>
<a name="ln833">	return ret;</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">static int</a>
<a name="ln837">iwm_mvm_umac_scan_abort(struct iwm_softc *sc)</a>
<a name="ln838">{</a>
<a name="ln839">	struct iwm_umac_scan_abort cmd = {};</a>
<a name="ln840">	int uid, ret;</a>
<a name="ln841"> </a>
<a name="ln842">	uid = 0;</a>
<a name="ln843">	cmd.uid = htole32(uid);</a>
<a name="ln844"> </a>
<a name="ln845">	IWM_DPRINTF(sc, IWM_DEBUG_SCAN, &quot;Sending scan abort, uid %u\n&quot;, uid);</a>
<a name="ln846"> </a>
<a name="ln847">	ret = iwm_mvm_send_cmd_pdu(sc,</a>
<a name="ln848">				   iwm_cmd_id(IWM_SCAN_ABORT_UMAC,</a>
<a name="ln849">					      IWM_ALWAYS_LONG_GROUP, 0),</a>
<a name="ln850">				   0, sizeof(cmd), &amp;cmd);</a>
<a name="ln851"> </a>
<a name="ln852">	return ret;</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">int</a>
<a name="ln856">iwm_mvm_scan_stop_wait(struct iwm_softc *sc)</a>
<a name="ln857">{</a>
<a name="ln858">	struct iwm_notification_wait wait_scan_done;</a>
<a name="ln859">	static const uint16_t scan_done_notif[] = { IWM_SCAN_COMPLETE_UMAC,</a>
<a name="ln860">						   IWM_SCAN_OFFLOAD_COMPLETE, };</a>
<a name="ln861">	int ret;</a>
<a name="ln862"> </a>
<a name="ln863">	iwm_init_notification_wait(sc-&gt;sc_notif_wait, &amp;wait_scan_done,</a>
<a name="ln864">				   scan_done_notif, nitems(scan_done_notif),</a>
<a name="ln865">				   NULL, NULL);</a>
<a name="ln866"> </a>
<a name="ln867">	IWM_DPRINTF(sc, IWM_DEBUG_SCAN, &quot;Preparing to stop scan\n&quot;);</a>
<a name="ln868"> </a>
<a name="ln869">	if (fw_has_capa(&amp;sc-&gt;sc_fw.ucode_capa, IWM_UCODE_TLV_CAPA_UMAC_SCAN))</a>
<a name="ln870">		ret = iwm_mvm_umac_scan_abort(sc);</a>
<a name="ln871">	else</a>
<a name="ln872">		ret = iwm_mvm_lmac_scan_abort(sc);</a>
<a name="ln873"> </a>
<a name="ln874">	if (ret) {</a>
<a name="ln875">		IWM_DPRINTF(sc, IWM_DEBUG_SCAN, &quot;couldn't stop scan\n&quot;);</a>
<a name="ln876">		iwm_remove_notification(sc-&gt;sc_notif_wait, &amp;wait_scan_done);</a>
<a name="ln877">		return ret;</a>
<a name="ln878">	}</a>
<a name="ln879"> </a>
<a name="ln880">	IWM_UNLOCK(sc);</a>
<a name="ln881">	ret = iwm_wait_notification(sc-&gt;sc_notif_wait, &amp;wait_scan_done, hz);</a>
<a name="ln882">	IWM_LOCK(sc);</a>
<a name="ln883"> </a>
<a name="ln884">	return ret;</a>
<a name="ln885">}</a>

</code></pre>
<div class="balloon" rel="395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'remain < sizeof (* wh) + 2' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
