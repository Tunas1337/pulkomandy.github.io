
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>util.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: util.c,v 1.123 2005/05/14 18:56:45 dsl Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*-</a>
<a name="ln4"> * Copyright (c) 1997-2005 The NetBSD Foundation, Inc.</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This code is derived from software contributed to The NetBSD Foundation</a>
<a name="ln8"> * by Luke Mewburn.</a>
<a name="ln9"> *</a>
<a name="ln10"> * This code is derived from software contributed to The NetBSD Foundation</a>
<a name="ln11"> * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,</a>
<a name="ln12"> * NASA Ames Research Center.</a>
<a name="ln13"> *</a>
<a name="ln14"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln15"> * modification, are permitted provided that the following conditions</a>
<a name="ln16"> * are met:</a>
<a name="ln17"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln18"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln19"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln20"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln21"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln22"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln23"> *    must display the following acknowledgement:</a>
<a name="ln24"> *	This product includes software developed by the NetBSD</a>
<a name="ln25"> *	Foundation, Inc. and its contributors.</a>
<a name="ln26"> * 4. Neither the name of The NetBSD Foundation nor the names of its</a>
<a name="ln27"> *    contributors may be used to endorse or promote products derived</a>
<a name="ln28"> *    from this software without specific prior written permission.</a>
<a name="ln29"> *</a>
<a name="ln30"> * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS</a>
<a name="ln31"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</a>
<a name="ln32"> * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln33"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS</a>
<a name="ln34"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln35"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln36"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln37"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln38"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln39"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln40"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln41"> */</a>
<a name="ln42"> </a>
<a name="ln43">/*</a>
<a name="ln44"> * Copyright (c) 1985, 1989, 1993, 1994</a>
<a name="ln45"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln46"> *</a>
<a name="ln47"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln48"> * modification, are permitted provided that the following conditions</a>
<a name="ln49"> * are met:</a>
<a name="ln50"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln51"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln52"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln53"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln54"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln55"> * 3. Neither the name of the University nor the names of its contributors</a>
<a name="ln56"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln57"> *    without specific prior written permission.</a>
<a name="ln58"> *</a>
<a name="ln59"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln60"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln61"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln62"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln63"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln64"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln65"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln66"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln67"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln68"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln69"> * SUCH DAMAGE.</a>
<a name="ln70"> */</a>
<a name="ln71"> </a>
<a name="ln72">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln73"> </a>
<a name="ln74">/*</a>
<a name="ln75"> * FTP User Program -- Misc support routines</a>
<a name="ln76"> */</a>
<a name="ln77">#include &lt;sys/param.h&gt;</a>
<a name="ln78">#include &lt;sys/socket.h&gt;</a>
<a name="ln79">#include &lt;sys/ioctl.h&gt;</a>
<a name="ln80">#include &lt;sys/time.h&gt;</a>
<a name="ln81">#include &lt;netinet/in.h&gt;</a>
<a name="ln82">#include &lt;arpa/ftp.h&gt;</a>
<a name="ln83"> </a>
<a name="ln84">#include &lt;ctype.h&gt;</a>
<a name="ln85">#include &lt;err.h&gt;</a>
<a name="ln86">#include &lt;errno.h&gt;</a>
<a name="ln87">#include &lt;fcntl.h&gt;</a>
<a name="ln88">#include &lt;glob.h&gt;</a>
<a name="ln89">#include &lt;signal.h&gt;</a>
<a name="ln90">#include &lt;limits.h&gt;</a>
<a name="ln91">#include &lt;netdb.h&gt;</a>
<a name="ln92">#include &lt;stdio.h&gt;</a>
<a name="ln93">#include &lt;stdlib.h&gt;</a>
<a name="ln94">#include &lt;string.h&gt;</a>
<a name="ln95">#include &lt;termios.h&gt;</a>
<a name="ln96">#include &lt;time.h&gt;</a>
<a name="ln97">#include &lt;unistd.h&gt;</a>
<a name="ln98"> </a>
<a name="ln99">#include &quot;ftp_var.h&quot;</a>
<a name="ln100"> </a>
<a name="ln101">#define TM_YEAR_BASE	1900</a>
<a name="ln102"> </a>
<a name="ln103">/*</a>
<a name="ln104"> * Connect to peer server and auto-login, if possible.</a>
<a name="ln105"> */</a>
<a name="ln106">void</a>
<a name="ln107">setpeer(int argc, char *argv[])</a>
<a name="ln108">{</a>
<a name="ln109">	char *host;</a>
<a name="ln110">	char *port;</a>
<a name="ln111"> </a>
<a name="ln112">	if (argc == 0)</a>
<a name="ln113">		goto usage;</a>
<a name="ln114">	if (connected) {</a>
<a name="ln115">		fprintf(ttyout, &quot;Already connected to %s, use close first.\n&quot;,</a>
<a name="ln116">		    hostname);</a>
<a name="ln117">		code = -1;</a>
<a name="ln118">		return;</a>
<a name="ln119">	}</a>
<a name="ln120">	if (argc &lt; 2)</a>
<a name="ln121">		(void)another(&amp;argc, &amp;argv, &quot;to&quot;);</a>
<a name="ln122">	if (argc &lt; 2 || argc &gt; 3) {</a>
<a name="ln123"> usage:</a>
<a name="ln124">		fprintf(ttyout, &quot;usage: %s host-name [port]\n&quot;, argv[0]);</a>
<a name="ln125">		code = -1;</a>
<a name="ln126">		return;</a>
<a name="ln127">	}</a>
<a name="ln128">	if (gatemode)</a>
<a name="ln129">		port = gateport;</a>
<a name="ln130">	else</a>
<a name="ln131">		port = ftpport;</a>
<a name="ln132">	if (argc &gt; 2)</a>
<a name="ln133">		port = argv[2];</a>
<a name="ln134"> </a>
<a name="ln135">	if (gatemode) {</a>
<a name="ln136">		if (gateserver == NULL || *gateserver == '\0')</a>
<a name="ln137">			errx(1, &quot;gateserver not defined (shouldn't happen)&quot;);</a>
<a name="ln138">		host = hookup(gateserver, port);</a>
<a name="ln139">	} else</a>
<a name="ln140">		host = hookup(argv[1], port);</a>
<a name="ln141"> </a>
<a name="ln142">	if (host) {</a>
<a name="ln143">		if (gatemode &amp;&amp; verbose) {</a>
<a name="ln144">			fprintf(ttyout,</a>
<a name="ln145">			    &quot;Connecting via pass-through server %s\n&quot;,</a>
<a name="ln146">			    gateserver);</a>
<a name="ln147">		}</a>
<a name="ln148"> </a>
<a name="ln149">		connected = 1;</a>
<a name="ln150">		/*</a>
<a name="ln151">		 * Set up defaults for FTP.</a>
<a name="ln152">		 */</a>
<a name="ln153">		(void)strlcpy(typename, &quot;ascii&quot;, sizeof(typename));</a>
<a name="ln154">		type = TYPE_A;</a>
<a name="ln155">		curtype = TYPE_A;</a>
<a name="ln156">		(void)strlcpy(formname, &quot;non-print&quot;, sizeof(formname));</a>
<a name="ln157">		form = FORM_N;</a>
<a name="ln158">		(void)strlcpy(modename, &quot;stream&quot;, sizeof(modename));</a>
<a name="ln159">		mode = MODE_S;</a>
<a name="ln160">		(void)strlcpy(structname, &quot;file&quot;, sizeof(structname));</a>
<a name="ln161">		stru = STRU_F;</a>
<a name="ln162">		(void)strlcpy(bytename, &quot;8&quot;, sizeof(bytename));</a>
<a name="ln163">		bytesize = 8;</a>
<a name="ln164">		if (autologin)</a>
<a name="ln165">			(void)ftp_login(argv[1], NULL, NULL);</a>
<a name="ln166">	}</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">static void</a>
<a name="ln170">parse_feat(const char *line)</a>
<a name="ln171">{</a>
<a name="ln172"> </a>
<a name="ln173">			/*</a>
<a name="ln174">			 * work-around broken ProFTPd servers that can't</a>
<a name="ln175">			 * even obey RFC 2389.</a>
<a name="ln176">			 */</a>
<a name="ln177">	while (*line &amp;&amp; isspace((int)*line))</a>
<a name="ln178">		line++;</a>
<a name="ln179"> </a>
<a name="ln180">	if (strcasecmp(line, &quot;MDTM&quot;) == 0)</a>
<a name="ln181">		features[FEAT_MDTM] = 1;</a>
<a name="ln182">	else if (strncasecmp(line, &quot;MLST&quot;, sizeof(&quot;MLST&quot;) - 1) == 0) {</a>
<a name="ln183">		features[FEAT_MLST] = 1;</a>
<a name="ln184">	} else if (strcasecmp(line, &quot;REST STREAM&quot;) == 0)</a>
<a name="ln185">		features[FEAT_REST_STREAM] = 1;</a>
<a name="ln186">	else if (strcasecmp(line, &quot;SIZE&quot;) == 0)</a>
<a name="ln187">		features[FEAT_SIZE] = 1;</a>
<a name="ln188">	else if (strcasecmp(line, &quot;TVFS&quot;) == 0)</a>
<a name="ln189">		features[FEAT_TVFS] = 1;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">/*</a>
<a name="ln193"> * Determine the remote system type (SYST) and features (FEAT).</a>
<a name="ln194"> * Call after a successful login (i.e, connected = -1)</a>
<a name="ln195"> */</a>
<a name="ln196">void</a>
<a name="ln197">getremoteinfo(void)</a>
<a name="ln198">{</a>
<a name="ln199">	int overbose, i;</a>
<a name="ln200"> </a>
<a name="ln201">	overbose = verbose;</a>
<a name="ln202">	if (debug == 0)</a>
<a name="ln203">		verbose = -1;</a>
<a name="ln204"> </a>
<a name="ln205">			/* determine remote system type */</a>
<a name="ln206">	if (command(&quot;SYST&quot;) == COMPLETE) {</a>
<a name="ln207">		if (overbose) {</a>
<a name="ln208">			char *cp, c;</a>
<a name="ln209"> </a>
<a name="ln210">			c = 0;</a>
<a name="ln211">			cp = strchr(reply_string + 4, ' ');</a>
<a name="ln212">			if (cp == NULL)</a>
<a name="ln213">				cp = strchr(reply_string + 4, '\r');</a>
<a name="ln214">			if (cp) {</a>
<a name="ln215">				if (cp[-1] == '.')</a>
<a name="ln216">					cp--;</a>
<a name="ln217">				c = *cp;</a>
<a name="ln218">				*cp = '\0';</a>
<a name="ln219">			}</a>
<a name="ln220"> </a>
<a name="ln221">			fprintf(ttyout, &quot;Remote system type is %s.\n&quot;,</a>
<a name="ln222">			    reply_string + 4);</a>
<a name="ln223">			if (cp)</a>
<a name="ln224">				*cp = c;</a>
<a name="ln225">		}</a>
<a name="ln226">		if (!strncmp(reply_string, &quot;215 UNIX Type: L8&quot;, 17)) {</a>
<a name="ln227">			if (proxy)</a>
<a name="ln228">				unix_proxy = 1;</a>
<a name="ln229">			else</a>
<a name="ln230">				unix_server = 1;</a>
<a name="ln231">			/*</a>
<a name="ln232">			 * Set type to 0 (not specified by user),</a>
<a name="ln233">			 * meaning binary by default, but don't bother</a>
<a name="ln234">			 * telling server.  We can use binary</a>
<a name="ln235">			 * for text files unless changed by the user.</a>
<a name="ln236">			 */</a>
<a name="ln237">			type = 0;</a>
<a name="ln238">			(void)strlcpy(typename, &quot;binary&quot;, sizeof(typename));</a>
<a name="ln239">			if (overbose)</a>
<a name="ln240">			    fprintf(ttyout,</a>
<a name="ln241">				&quot;Using %s mode to transfer files.\n&quot;,</a>
<a name="ln242">				typename);</a>
<a name="ln243">		} else {</a>
<a name="ln244">			if (proxy)</a>
<a name="ln245">				unix_proxy = 0;</a>
<a name="ln246">			else</a>
<a name="ln247">				unix_server = 0;</a>
<a name="ln248">			if (overbose &amp;&amp;</a>
<a name="ln249">			    !strncmp(reply_string, &quot;215 TOPS20&quot;, 10))</a>
<a name="ln250">				fputs(</a>
<a name="ln251">&quot;Remember to set tenex mode when transferring binary files from this machine.\n&quot;,</a>
<a name="ln252">				    ttyout);</a>
<a name="ln253">		}</a>
<a name="ln254">	}</a>
<a name="ln255"> </a>
<a name="ln256">			/* determine features (if any) */</a>
<a name="ln257">	for (i = 0; i &lt; FEAT_max; i++)</a>
<a name="ln258">		features[i] = -1;</a>
<a name="ln259">	reply_callback = parse_feat;</a>
<a name="ln260">	if (command(&quot;FEAT&quot;) == COMPLETE) {</a>
<a name="ln261">		for (i = 0; i &lt; FEAT_max; i++) {</a>
<a name="ln262">			if (features[i] == -1)</a>
<a name="ln263">				features[i] = 0;</a>
<a name="ln264">		}</a>
<a name="ln265">		features[FEAT_FEAT] = 1;</a>
<a name="ln266">	} else</a>
<a name="ln267">		features[FEAT_FEAT] = 0;</a>
<a name="ln268">	if (debug) {</a>
<a name="ln269">#define DEBUG_FEAT(x) fprintf(ttyout, &quot;features[&quot; #x &quot;] = %d\n&quot;, features[(x)])</a>
<a name="ln270">		DEBUG_FEAT(FEAT_FEAT);</a>
<a name="ln271">		DEBUG_FEAT(FEAT_MDTM);</a>
<a name="ln272">		DEBUG_FEAT(FEAT_MLST);</a>
<a name="ln273">		DEBUG_FEAT(FEAT_REST_STREAM);</a>
<a name="ln274">		DEBUG_FEAT(FEAT_SIZE);</a>
<a name="ln275">		DEBUG_FEAT(FEAT_TVFS);</a>
<a name="ln276">#undef DEBUG_FEAT</a>
<a name="ln277">	}</a>
<a name="ln278">	reply_callback = NULL;</a>
<a name="ln279"> </a>
<a name="ln280">	verbose = overbose;</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">/*</a>
<a name="ln284"> * Reset the various variables that indicate connection state back to</a>
<a name="ln285"> * disconnected settings.</a>
<a name="ln286"> * The caller is responsible for issuing any commands to the remote server</a>
<a name="ln287"> * to perform a clean shutdown before this is invoked.</a>
<a name="ln288"> */</a>
<a name="ln289">void</a>
<a name="ln290">cleanuppeer(void)</a>
<a name="ln291">{</a>
<a name="ln292"> </a>
<a name="ln293">	if (cout)</a>
<a name="ln294">		(void)fclose(cout);</a>
<a name="ln295">	cout = NULL;</a>
<a name="ln296">	connected = 0;</a>
<a name="ln297">	unix_server = 0;</a>
<a name="ln298">	unix_proxy = 0;</a>
<a name="ln299">			/*</a>
<a name="ln300">			 * determine if anonftp was specifically set with -a</a>
<a name="ln301">			 * (1), or implicitly set by auto_fetch() (2). in the</a>
<a name="ln302">			 * latter case, disable after the current xfer</a>
<a name="ln303">			 */</a>
<a name="ln304">	if (anonftp == 2)</a>
<a name="ln305">		anonftp = 0;</a>
<a name="ln306">	data = -1;</a>
<a name="ln307">	epsv4bad = 0;</a>
<a name="ln308">	if (username)</a>
<a name="ln309">		free(username);</a>
<a name="ln310">	username = NULL;</a>
<a name="ln311">	if (!proxy)</a>
<a name="ln312">		macnum = 0;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">/*</a>
<a name="ln316"> * Top-level signal handler for interrupted commands.</a>
<a name="ln317"> */</a>
<a name="ln318">void</a>
<a name="ln319">intr(int signo)</a>
<a name="ln320">{</a>
<a name="ln321"> </a>
<a name="ln322">	sigint_raised = 1;</a>
<a name="ln323">	alarmtimer(0);</a>
<a name="ln324">	if (fromatty)</a>
<a name="ln325">		write(fileno(ttyout), &quot;\n&quot;, 1);</a>
<a name="ln326">	siglongjmp(toplevel, 1);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">/*</a>
<a name="ln330"> * Signal handler for lost connections; cleanup various elements of</a>
<a name="ln331"> * the connection state, and call cleanuppeer() to finish it off.</a>
<a name="ln332"> */</a>
<a name="ln333">void</a>
<a name="ln334">lostpeer(int dummy)</a>
<a name="ln335">{</a>
<a name="ln336">	int oerrno = errno;</a>
<a name="ln337"> </a>
<a name="ln338">	alarmtimer(0);</a>
<a name="ln339">	if (connected) {</a>
<a name="ln340">		if (cout != NULL) {</a>
<a name="ln341">			(void)shutdown(fileno(cout), 1+1);</a>
<a name="ln342">			(void)fclose(cout);</a>
<a name="ln343">			cout = NULL;</a>
<a name="ln344">		}</a>
<a name="ln345">		if (data &gt;= 0) {</a>
<a name="ln346">			(void)shutdown(data, 1+1);</a>
<a name="ln347">			(void)close(data);</a>
<a name="ln348">			data = -1;</a>
<a name="ln349">		}</a>
<a name="ln350">		connected = 0;</a>
<a name="ln351">	}</a>
<a name="ln352">	pswitch(1);</a>
<a name="ln353">	if (connected) {</a>
<a name="ln354">		if (cout != NULL) {</a>
<a name="ln355">			(void)shutdown(fileno(cout), 1+1);</a>
<a name="ln356">			(void)fclose(cout);</a>
<a name="ln357">			cout = NULL;</a>
<a name="ln358">		}</a>
<a name="ln359">		connected = 0;</a>
<a name="ln360">	}</a>
<a name="ln361">	proxflag = 0;</a>
<a name="ln362">	pswitch(0);</a>
<a name="ln363">	cleanuppeer();</a>
<a name="ln364">	errno = oerrno;</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368">/*</a>
<a name="ln369"> * Login to remote host, using given username &amp; password if supplied.</a>
<a name="ln370"> * Return non-zero if successful.</a>
<a name="ln371"> */</a>
<a name="ln372">int</a>
<a name="ln373">ftp_login(const char *host, const char *user, const char *pass)</a>
<a name="ln374">{</a>
<a name="ln375">	char tmp[80];</a>
<a name="ln376">	const char *acct;</a>
<a name="ln377">	int n, aflag, rval, freeuser, freepass, freeacct;</a>
<a name="ln378"> </a>
<a name="ln379">	acct = NULL;</a>
<a name="ln380">	aflag = rval = freeuser = freepass = freeacct = 0;</a>
<a name="ln381"> </a>
<a name="ln382">	if (debug)</a>
<a name="ln383">		fprintf(ttyout, &quot;ftp_login: user `%s' pass `%s' host `%s'\n&quot;,</a>
<a name="ln384">		    user ? user : &quot;&lt;null&gt;&quot;, pass ? pass : &quot;&lt;null&gt;&quot;,</a>
<a name="ln385">		    host ? host : &quot;&lt;null&gt;&quot;);</a>
<a name="ln386"> </a>
<a name="ln387"> </a>
<a name="ln388">	/*</a>
<a name="ln389">	 * Set up arguments for an anonymous FTP session, if necessary.</a>
<a name="ln390">	 */</a>
<a name="ln391">	if (anonftp) {</a>
<a name="ln392">		user = &quot;anonymous&quot;;	/* as per RFC 1635 */</a>
<a name="ln393">		pass = getoptionvalue(&quot;anonpass&quot;);</a>
<a name="ln394">	}</a>
<a name="ln395"> </a>
<a name="ln396">	if (user == NULL)</a>
<a name="ln397">		freeuser = 1;</a>
<a name="ln398">	if (pass == NULL)</a>
<a name="ln399">		freepass = 1;</a>
<a name="ln400">	freeacct = 1;</a>
<a name="ln401">	if (ruserpass(host, &amp;user, &amp;pass, &amp;acct) &lt; 0) {</a>
<a name="ln402">		code = -1;</a>
<a name="ln403">		goto cleanup_ftp_login;</a>
<a name="ln404">	}</a>
<a name="ln405"> </a>
<a name="ln406">	while (user == NULL) {</a>
<a name="ln407">		if (localname)</a>
<a name="ln408">			fprintf(ttyout, &quot;Name (%s:%s): &quot;, host, localname);</a>
<a name="ln409">		else</a>
<a name="ln410">			fprintf(ttyout, &quot;Name (%s): &quot;, host);</a>
<a name="ln411">		*tmp = '\0';</a>
<a name="ln412">		if (fgets(tmp, sizeof(tmp) - 1, stdin) == NULL) {</a>
<a name="ln413">			fprintf(ttyout, &quot;\nEOF received; login aborted.\n&quot;);</a>
<a name="ln414">			clearerr(stdin);</a>
<a name="ln415">			code = -1;</a>
<a name="ln416">			goto cleanup_ftp_login;</a>
<a name="ln417">		}</a>
<a name="ln418">		tmp[strlen(tmp) - 1] = '\0';</a>
<a name="ln419">		freeuser = 0;</a>
<a name="ln420">		if (*tmp == '\0')</a>
<a name="ln421">			user = localname;</a>
<a name="ln422">		else</a>
<a name="ln423">			user = tmp;</a>
<a name="ln424">	}</a>
<a name="ln425"> </a>
<a name="ln426">	if (gatemode) {</a>
<a name="ln427">		char *nuser;</a>
<a name="ln428">		int len;</a>
<a name="ln429"> </a>
<a name="ln430">		len = strlen(user) + 1 + strlen(host) + 1;</a>
<a name="ln431">		nuser = xmalloc(len);</a>
<a name="ln432">		(void)strlcpy(nuser, user, len);</a>
<a name="ln433">		(void)strlcat(nuser, &quot;@&quot;,  len);</a>
<a name="ln434">		(void)strlcat(nuser, host, len);</a>
<a name="ln435">		freeuser = 1;</a>
<a name="ln436">		user = nuser;</a>
<a name="ln437">	}</a>
<a name="ln438"> </a>
<a name="ln439">	n = command(&quot;USER %s&quot;, user);</a>
<a name="ln440">	if (n == CONTINUE) {</a>
<a name="ln441">		if (pass == NULL) {</a>
<a name="ln442">			freepass = 0;</a>
<a name="ln443">			pass = getpass(&quot;Password:&quot;);</a>
<a name="ln444">		}</a>
<a name="ln445">		n = command(&quot;PASS %s&quot;, pass);</a>
<a name="ln446">	}</a>
<a name="ln447">	if (n == CONTINUE) {</a>
<a name="ln448">		aflag++;</a>
<a name="ln449">		if (acct == NULL) {</a>
<a name="ln450">			freeacct = 0;</a>
<a name="ln451">			acct = getpass(&quot;Account:&quot;);</a>
<a name="ln452">		}</a>
<a name="ln453">		if (acct[0] == '\0') {</a>
<a name="ln454">			warnx(&quot;Login failed.&quot;);</a>
<a name="ln455">			goto cleanup_ftp_login;</a>
<a name="ln456">		}</a>
<a name="ln457">		n = command(&quot;ACCT %s&quot;, acct);</a>
<a name="ln458">	}</a>
<a name="ln459">	if ((n != COMPLETE) ||</a>
<a name="ln460">	    (!aflag &amp;&amp; acct != NULL &amp;&amp; command(&quot;ACCT %s&quot;, acct) != COMPLETE)) {</a>
<a name="ln461">		warnx(&quot;Login failed.&quot;);</a>
<a name="ln462">		goto cleanup_ftp_login;</a>
<a name="ln463">	}</a>
<a name="ln464">	rval = 1;</a>
<a name="ln465">	username = xstrdup(user);</a>
<a name="ln466">	if (proxy)</a>
<a name="ln467">		goto cleanup_ftp_login;</a>
<a name="ln468"> </a>
<a name="ln469">	connected = -1;</a>
<a name="ln470">	getremoteinfo();</a>
<a name="ln471">	for (n = 0; n &lt; macnum; ++n) {</a>
<a name="ln472">		if (!strcmp(&quot;init&quot;, macros[n].mac_name)) {</a>
<a name="ln473">			(void)strlcpy(line, &quot;$init&quot;, sizeof(line));</a>
<a name="ln474">			makeargv();</a>
<a name="ln475">			domacro(margc, margv);</a>
<a name="ln476">			break;</a>
<a name="ln477">		}</a>
<a name="ln478">	}</a>
<a name="ln479">	updatelocalcwd();</a>
<a name="ln480">	updateremotecwd();</a>
<a name="ln481"> </a>
<a name="ln482"> cleanup_ftp_login:</a>
<a name="ln483">	if (user != NULL &amp;&amp; freeuser)</a>
<a name="ln484">		free((char *)user);</a>
<a name="ln485">	if (pass != NULL &amp;&amp; freepass)</a>
<a name="ln486">		free((char *)pass);</a>
<a name="ln487">	if (acct != NULL &amp;&amp; freeacct)</a>
<a name="ln488">		free((char *)acct);</a>
<a name="ln489">	return (rval);</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">/*</a>
<a name="ln493"> * `another' gets another argument, and stores the new argc and argv.</a>
<a name="ln494"> * It reverts to the top level (via intr()) on EOF/error.</a>
<a name="ln495"> *</a>
<a name="ln496"> * Returns false if no new arguments have been added.</a>
<a name="ln497"> */</a>
<a name="ln498">int</a>
<a name="ln499">another(int *pargc, char ***pargv, const char *prompt)</a>
<a name="ln500">{</a>
<a name="ln501">	int len = strlen(line), ret;</a>
<a name="ln502"> </a>
<a name="ln503">	if (len &gt;= sizeof(line) - 3) {</a>
<a name="ln504">		fputs(&quot;sorry, arguments too long.\n&quot;, ttyout);</a>
<a name="ln505">		intr(0);</a>
<a name="ln506">	}</a>
<a name="ln507">	fprintf(ttyout, &quot;(%s) &quot;, prompt);</a>
<a name="ln508">	line[len++] = ' ';</a>
<a name="ln509">	if (fgets(&amp;line[len], sizeof(line) - len, stdin) == NULL) {</a>
<a name="ln510">		clearerr(stdin);</a>
<a name="ln511">		intr(0);</a>
<a name="ln512">	}</a>
<a name="ln513">	len += strlen(&amp;line[len]);</a>
<a name="ln514">	if (len &gt; 0 &amp;&amp; line[len - 1] == '\n')</a>
<a name="ln515">		line[len - 1] = '\0';</a>
<a name="ln516">	makeargv();</a>
<a name="ln517">	ret = margc &gt; *pargc;</a>
<a name="ln518">	*pargc = margc;</a>
<a name="ln519">	*pargv = margv;</a>
<a name="ln520">	return (ret);</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">/*</a>
<a name="ln524"> * glob files given in argv[] from the remote server.</a>
<a name="ln525"> * if errbuf isn't NULL, store error messages there instead</a>
<a name="ln526"> * of writing to the screen.</a>
<a name="ln527"> */</a>
<a name="ln528">char *</a>
<a name="ln529">remglob(char *argv[], int doswitch, char **errbuf)</a>
<a name="ln530">{</a>
<a name="ln531">        char temp[MAXPATHLEN];</a>
<a name="ln532">        static char buf[MAXPATHLEN];</a>
<a name="ln533">        static FILE *ftemp = NULL;</a>
<a name="ln534">        static char **args;</a>
<a name="ln535">        int oldverbose, oldhash, oldprogress, fd, len;</a>
<a name="ln536">        char *cp, *mode;</a>
<a name="ln537"> </a>
<a name="ln538">        if (!mflag || !connected) {</a>
<a name="ln539">                if (!doglob)</a>
<a name="ln540">                        args = NULL;</a>
<a name="ln541">                else {</a>
<a name="ln542">                        if (ftemp) {</a>
<a name="ln543">                                (void)fclose(ftemp);</a>
<a name="ln544">                                ftemp = NULL;</a>
<a name="ln545">                        }</a>
<a name="ln546">                }</a>
<a name="ln547">                return (NULL);</a>
<a name="ln548">        }</a>
<a name="ln549">        if (!doglob) {</a>
<a name="ln550">                if (args == NULL)</a>
<a name="ln551">                        args = argv;</a>
<a name="ln552">                if ((cp = *++args) == NULL)</a>
<a name="ln553">                        args = NULL;</a>
<a name="ln554">                return (cp);</a>
<a name="ln555">        }</a>
<a name="ln556">        if (ftemp == NULL) {</a>
<a name="ln557">		len = strlcpy(temp, tmpdir, sizeof(temp));</a>
<a name="ln558">		if (temp[len - 1] != '/')</a>
<a name="ln559">			(void)strlcat(temp, &quot;/&quot;, sizeof(temp));</a>
<a name="ln560">		(void)strlcat(temp, TMPFILE, sizeof(temp));</a>
<a name="ln561">                if ((fd = mkstemp(temp)) &lt; 0) {</a>
<a name="ln562">                        warn(&quot;unable to create temporary file %s&quot;, temp);</a>
<a name="ln563">                        return (NULL);</a>
<a name="ln564">                }</a>
<a name="ln565">                close(fd);</a>
<a name="ln566">                oldverbose = verbose;</a>
<a name="ln567">		verbose = (errbuf != NULL) ? -1 : 0;</a>
<a name="ln568">                oldhash = hash;</a>
<a name="ln569">		oldprogress = progress;</a>
<a name="ln570">                hash = 0;</a>
<a name="ln571">		progress = 0;</a>
<a name="ln572">                if (doswitch)</a>
<a name="ln573">                        pswitch(!proxy);</a>
<a name="ln574">                for (mode = &quot;w&quot;; *++argv != NULL; mode = &quot;a&quot;)</a>
<a name="ln575">                        recvrequest(&quot;NLST&quot;, temp, *argv, mode, 0, 0);</a>
<a name="ln576">		if ((code / 100) != COMPLETE) {</a>
<a name="ln577">			if (errbuf != NULL)</a>
<a name="ln578">				*errbuf = reply_string;</a>
<a name="ln579">		}</a>
<a name="ln580">                if (doswitch)</a>
<a name="ln581">                        pswitch(!proxy);</a>
<a name="ln582">                verbose = oldverbose;</a>
<a name="ln583">		hash = oldhash;</a>
<a name="ln584">		progress = oldprogress;</a>
<a name="ln585">                ftemp = fopen(temp, &quot;r&quot;);</a>
<a name="ln586">                (void)unlink(temp);</a>
<a name="ln587">                if (ftemp == NULL) {</a>
<a name="ln588">			if (errbuf == NULL)</a>
<a name="ln589">				fputs(</a>
<a name="ln590">				    &quot;can't find list of remote files, oops.\n&quot;,</a>
<a name="ln591">				    ttyout);</a>
<a name="ln592">			else</a>
<a name="ln593">				*errbuf =</a>
<a name="ln594">				    &quot;can't find list of remote files, oops.&quot;;</a>
<a name="ln595">                        return (NULL);</a>
<a name="ln596">                }</a>
<a name="ln597">        }</a>
<a name="ln598">        if (fgets(buf, sizeof(buf), ftemp) == NULL) {</a>
<a name="ln599">                (void)fclose(ftemp);</a>
<a name="ln600">		ftemp = NULL;</a>
<a name="ln601">                return (NULL);</a>
<a name="ln602">        }</a>
<a name="ln603">        if ((cp = strchr(buf, '\n')) != NULL)</a>
<a name="ln604">                *cp = '\0';</a>
<a name="ln605">        return (buf);</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">/*</a>
<a name="ln609"> * Glob a local file name specification with the expectation of a single</a>
<a name="ln610"> * return value. Can't control multiple values being expanded from the</a>
<a name="ln611"> * expression, we return only the first.</a>
<a name="ln612"> * Returns NULL on error, or a pointer to a buffer containing the filename</a>
<a name="ln613"> * that's the caller's responsiblity to free(3) when finished with.</a>
<a name="ln614"> */</a>
<a name="ln615">char *</a>
<a name="ln616">globulize(const char *pattern)</a>
<a name="ln617">{</a>
<a name="ln618">	glob_t gl;</a>
<a name="ln619">	int flags;</a>
<a name="ln620">	char *p;</a>
<a name="ln621"> </a>
<a name="ln622">	if (!doglob)</a>
<a name="ln623">		return (xstrdup(pattern));</a>
<a name="ln624"> </a>
<a name="ln625">	flags = GLOB_BRACE|GLOB_NOCHECK|GLOB_TILDE;</a>
<a name="ln626">	memset(&amp;gl, 0, sizeof(gl));</a>
<a name="ln627">	if (glob(pattern, flags, NULL, &amp;gl) || gl.gl_pathc == 0) {</a>
<a name="ln628">		warnx(&quot;%s: not found&quot;, pattern);</a>
<a name="ln629">		globfree(&amp;gl);</a>
<a name="ln630">		return (NULL);</a>
<a name="ln631">	}</a>
<a name="ln632">	p = xstrdup(gl.gl_pathv[0]);</a>
<a name="ln633">	globfree(&amp;gl);</a>
<a name="ln634">	return (p);</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">/*</a>
<a name="ln638"> * determine size of remote file</a>
<a name="ln639"> */</a>
<a name="ln640">off_t</a>
<a name="ln641">remotesize(const char *file, int noisy)</a>
<a name="ln642">{</a>
<a name="ln643">	int overbose, r;</a>
<a name="ln644">	off_t size;</a>
<a name="ln645"> </a>
<a name="ln646">	overbose = verbose;</a>
<a name="ln647">	size = -1;</a>
<a name="ln648">	if (debug == 0)</a>
<a name="ln649">		verbose = -1;</a>
<a name="ln650">	if (! features[FEAT_SIZE]) {</a>
<a name="ln651">		if (noisy)</a>
<a name="ln652">			fprintf(ttyout,</a>
<a name="ln653">			    &quot;SIZE is not supported by remote server.\n&quot;);</a>
<a name="ln654">		goto cleanup_remotesize;</a>
<a name="ln655">	}</a>
<a name="ln656">	r = command(&quot;SIZE %s&quot;, file);</a>
<a name="ln657">	if (r == COMPLETE) {</a>
<a name="ln658">		char *cp, *ep;</a>
<a name="ln659"> </a>
<a name="ln660">		cp = strchr(reply_string, ' ');</a>
<a name="ln661">		if (cp != NULL) {</a>
<a name="ln662">			cp++;</a>
<a name="ln663">			size = STRTOLL(cp, &amp;ep, 10);</a>
<a name="ln664">			if (*ep != '\0' &amp;&amp; !isspace((unsigned char)*ep))</a>
<a name="ln665">				size = -1;</a>
<a name="ln666">		}</a>
<a name="ln667">	} else {</a>
<a name="ln668">		if (r == ERROR &amp;&amp; code == 500 &amp;&amp; features[FEAT_SIZE] == -1)</a>
<a name="ln669">			features[FEAT_SIZE] = 0;</a>
<a name="ln670">		if (noisy &amp;&amp; debug == 0) {</a>
<a name="ln671">			fputs(reply_string, ttyout);</a>
<a name="ln672">			putc('\n', ttyout);</a>
<a name="ln673">		}</a>
<a name="ln674">	}</a>
<a name="ln675"> cleanup_remotesize:</a>
<a name="ln676">	verbose = overbose;</a>
<a name="ln677">	return (size);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">/*</a>
<a name="ln681"> * determine last modification time (in GMT) of remote file</a>
<a name="ln682"> */</a>
<a name="ln683">time_t</a>
<a name="ln684">remotemodtime(const char *file, int noisy)</a>
<a name="ln685">{</a>
<a name="ln686">	int	overbose, ocode, r;</a>
<a name="ln687">	time_t	rtime;</a>
<a name="ln688"> </a>
<a name="ln689">	overbose = verbose;</a>
<a name="ln690">	ocode = code;</a>
<a name="ln691">	rtime = -1;</a>
<a name="ln692">	if (debug == 0)</a>
<a name="ln693">		verbose = -1;</a>
<a name="ln694">	if (! features[FEAT_MDTM]) {</a>
<a name="ln695">		if (noisy)</a>
<a name="ln696">			fprintf(ttyout,</a>
<a name="ln697">			    &quot;MDTM is not supported by remote server.\n&quot;);</a>
<a name="ln698">		goto cleanup_parse_time;</a>
<a name="ln699">	}</a>
<a name="ln700">	r = command(&quot;MDTM %s&quot;, file);</a>
<a name="ln701">	if (r == COMPLETE) {</a>
<a name="ln702">		struct tm timebuf;</a>
<a name="ln703">		char *timestr, *frac;</a>
<a name="ln704">		int yy, mo, day, hour, min, sec;</a>
<a name="ln705"> </a>
<a name="ln706">		/*</a>
<a name="ln707">		 * time-val = 14DIGIT [ &quot;.&quot; 1*DIGIT ]</a>
<a name="ln708">		 *		YYYYMMDDHHMMSS[.sss]</a>
<a name="ln709">		 * mdtm-response = &quot;213&quot; SP time-val CRLF / error-response</a>
<a name="ln710">		 */</a>
<a name="ln711">		timestr = reply_string + 4;</a>
<a name="ln712"> </a>
<a name="ln713">					/*</a>
<a name="ln714">					 * parse fraction.</a>
<a name="ln715">					 * XXX: ignored for now</a>
<a name="ln716">					 */</a>
<a name="ln717">		frac = strchr(timestr, '\r');</a>
<a name="ln718">		if (frac != NULL)</a>
<a name="ln719">			*frac = '\0';</a>
<a name="ln720">		frac = strchr(timestr, '.');</a>
<a name="ln721">		if (frac != NULL)</a>
<a name="ln722">			*frac++ = '\0';</a>
<a name="ln723">		if (strlen(timestr) == 15 &amp;&amp; strncmp(timestr, &quot;191&quot;, 3) == 0) {</a>
<a name="ln724">			/*</a>
<a name="ln725">			 * XXX:	Workaround for lame ftpd's that return</a>
<a name="ln726">			 *	`19100' instead of `2000'</a>
<a name="ln727">			 */</a>
<a name="ln728">			fprintf(ttyout,</a>
<a name="ln729">	    &quot;Y2K warning! Incorrect time-val `%s' received from server.\n&quot;,</a>
<a name="ln730">			    timestr);</a>
<a name="ln731">			timestr++;</a>
<a name="ln732">			timestr[0] = '2';</a>
<a name="ln733">			timestr[1] = '0';</a>
<a name="ln734">			fprintf(ttyout, &quot;Converted to `%s'\n&quot;, timestr);</a>
<a name="ln735">		}</a>
<a name="ln736">		if (strlen(timestr) != 14 ||</a>
<a name="ln737">		    sscanf(timestr, &quot;%04d%02d%02d%02d%02d%02d&quot;,</a>
<a name="ln738">			&amp;yy, &amp;mo, &amp;day, &amp;hour, &amp;min, &amp;sec) != 6) {</a>
<a name="ln739"> bad_parse_time:</a>
<a name="ln740">			fprintf(ttyout, &quot;Can't parse time `%s'.\n&quot;, timestr);</a>
<a name="ln741">			goto cleanup_parse_time;</a>
<a name="ln742">		}</a>
<a name="ln743">		memset(&amp;timebuf, 0, sizeof(timebuf));</a>
<a name="ln744">		timebuf.tm_sec = sec;</a>
<a name="ln745">		timebuf.tm_min = min;</a>
<a name="ln746">		timebuf.tm_hour = hour;</a>
<a name="ln747">		timebuf.tm_mday = day;</a>
<a name="ln748">		timebuf.tm_mon = mo - 1;</a>
<a name="ln749">		timebuf.tm_year = yy - TM_YEAR_BASE;</a>
<a name="ln750">		timebuf.tm_isdst = -1;</a>
<a name="ln751">		rtime = timegm(&amp;timebuf);</a>
<a name="ln752">		if (rtime == -1) {</a>
<a name="ln753">			if (noisy || debug != 0)</a>
<a name="ln754">				goto bad_parse_time;</a>
<a name="ln755">			else</a>
<a name="ln756">				goto cleanup_parse_time;</a>
<a name="ln757">		} else if (debug)</a>
<a name="ln758">			fprintf(ttyout, &quot;parsed date as: %s&quot;, ctime(&amp;rtime));</a>
<a name="ln759">	} else {</a>
<a name="ln760">		if (r == ERROR &amp;&amp; code == 500 &amp;&amp; features[FEAT_MDTM] == -1)</a>
<a name="ln761">			features[FEAT_MDTM] = 0;</a>
<a name="ln762">		if (noisy &amp;&amp; debug == 0) {</a>
<a name="ln763">			fputs(reply_string, ttyout);</a>
<a name="ln764">			putc('\n', ttyout);</a>
<a name="ln765">		}</a>
<a name="ln766">	}</a>
<a name="ln767"> cleanup_parse_time:</a>
<a name="ln768">	verbose = overbose;</a>
<a name="ln769">	if (rtime == -1)</a>
<a name="ln770">		code = ocode;</a>
<a name="ln771">	return (rtime);</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">/*</a>
<a name="ln775"> * Update global `localcwd', which contains the state of the local cwd</a>
<a name="ln776"> */</a>
<a name="ln777">void</a>
<a name="ln778">updatelocalcwd(void)</a>
<a name="ln779">{</a>
<a name="ln780"> </a>
<a name="ln781">	if (getcwd(localcwd, sizeof(localcwd)) == NULL)</a>
<a name="ln782">		localcwd[0] = '\0';</a>
<a name="ln783">	if (debug)</a>
<a name="ln784">		fprintf(ttyout, &quot;got localcwd as `%s'\n&quot;, localcwd);</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">/*</a>
<a name="ln788"> * Update global `remotecwd', which contains the state of the remote cwd</a>
<a name="ln789"> */</a>
<a name="ln790">void</a>
<a name="ln791">updateremotecwd(void)</a>
<a name="ln792">{</a>
<a name="ln793">	int	 overbose, ocode, i;</a>
<a name="ln794">	char	*cp;</a>
<a name="ln795"> </a>
<a name="ln796">	overbose = verbose;</a>
<a name="ln797">	ocode = code;</a>
<a name="ln798">	if (debug == 0)</a>
<a name="ln799">		verbose = -1;</a>
<a name="ln800">	if (command(&quot;PWD&quot;) != COMPLETE)</a>
<a name="ln801">		goto badremotecwd;</a>
<a name="ln802">	cp = strchr(reply_string, ' ');</a>
<a name="ln803">	if (cp == NULL || cp[0] == '\0' || cp[1] != '&quot;')</a>
<a name="ln804">		goto badremotecwd;</a>
<a name="ln805">	cp += 2;</a>
<a name="ln806">	for (i = 0; *cp &amp;&amp; i &lt; sizeof(remotecwd) - 1; i++, cp++) {</a>
<a name="ln807">		if (cp[0] == '&quot;') {</a>
<a name="ln808">			if (cp[1] == '&quot;')</a>
<a name="ln809">				cp++;</a>
<a name="ln810">			else</a>
<a name="ln811">				break;</a>
<a name="ln812">		}</a>
<a name="ln813">		remotecwd[i] = *cp;</a>
<a name="ln814">	}</a>
<a name="ln815">	remotecwd[i] = '\0';</a>
<a name="ln816">	if (debug)</a>
<a name="ln817">		fprintf(ttyout, &quot;got remotecwd as `%s'\n&quot;, remotecwd);</a>
<a name="ln818">	goto cleanupremotecwd;</a>
<a name="ln819"> badremotecwd:</a>
<a name="ln820">	remotecwd[0]='\0';</a>
<a name="ln821"> cleanupremotecwd:</a>
<a name="ln822">	verbose = overbose;</a>
<a name="ln823">	code = ocode;</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">/*</a>
<a name="ln827"> * Ensure file is in or under dir.</a>
<a name="ln828"> * Returns 1 if so, 0 if not (or an error occurred).</a>
<a name="ln829"> */</a>
<a name="ln830">int</a>
<a name="ln831">fileindir(const char *file, const char *dir)</a>
<a name="ln832">{</a>
<a name="ln833">	char	realfile[PATH_MAX+1];</a>
<a name="ln834">	size_t	dirlen;</a>
<a name="ln835"> </a>
<a name="ln836">	if (realpath(file, realfile) == NULL) {</a>
<a name="ln837">		int error = 1;</a>
<a name="ln838"> </a>
<a name="ln839">		if (errno == ENOENT) {</a>
<a name="ln840">			/* Check if the parent directory exist which is all we need */</a>
<a name="ln841">			const char* last = strrchr(file, '/');</a>
<a name="ln842">			if (last != NULL) {</a>
<a name="ln843">				char parent[PATH_MAX+1];</a>
<a name="ln844">				strlcpy(parent, file, last - file);</a>
<a name="ln845"> </a>
<a name="ln846">				if (realpath(parent, realfile) != NULL) {</a>
<a name="ln847">					strlcat(realfile, last, sizeof(realfile));</a>
<a name="ln848">					error = 0;</a>
<a name="ln849">				}</a>
<a name="ln850">			} else {</a>
<a name="ln851">				/* This already is the last component */</a>
<a name="ln852">				strlcpy(realfile, file, sizeof(realfile));</a>
<a name="ln853">				error = 0;</a>
<a name="ln854">			}</a>
<a name="ln855">		}</a>
<a name="ln856"> </a>
<a name="ln857">		if (error) {</a>
<a name="ln858">			warn(&quot;Unable to determine real path of `%s'&quot;, file);</a>
<a name="ln859">			return 0;</a>
<a name="ln860">		}</a>
<a name="ln861">	}</a>
<a name="ln862">	if (realfile[0] != '/')		/* relative result */</a>
<a name="ln863">		return 1;</a>
<a name="ln864">	dirlen = strlen(dir);</a>
<a name="ln865">#if 0</a>
<a name="ln866">printf(&quot;file %s realfile %s dir %s [%d]\n&quot;, file, realfile, dir, dirlen);</a>
<a name="ln867">#endif</a>
<a name="ln868">	if (strncmp(realfile, dir, dirlen) == 0 &amp;&amp; realfile[dirlen] == '/')</a>
<a name="ln869">		return 1;</a>
<a name="ln870">	return 0;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/*</a>
<a name="ln874"> * List words in stringlist, vertically arranged</a>
<a name="ln875"> */</a>
<a name="ln876">void</a>
<a name="ln877">list_vertical(StringList *sl)</a>
<a name="ln878">{</a>
<a name="ln879">	int i, j, w;</a>
<a name="ln880">	int columns, width, lines;</a>
<a name="ln881">	char *p;</a>
<a name="ln882"> </a>
<a name="ln883">	width = 0;</a>
<a name="ln884"> </a>
<a name="ln885">	for (i = 0 ; i &lt; sl-&gt;sl_cur ; i++) {</a>
<a name="ln886">		w = strlen(sl-&gt;sl_str[i]);</a>
<a name="ln887">		if (w &gt; width)</a>
<a name="ln888">			width = w;</a>
<a name="ln889">	}</a>
<a name="ln890">	width = (width + 8) &amp;~ 7;</a>
<a name="ln891"> </a>
<a name="ln892">	columns = ttywidth / width;</a>
<a name="ln893">	if (columns == 0)</a>
<a name="ln894">		columns = 1;</a>
<a name="ln895">	lines = (sl-&gt;sl_cur + columns - 1) / columns;</a>
<a name="ln896">	for (i = 0; i &lt; lines; i++) {</a>
<a name="ln897">		for (j = 0; j &lt; columns; j++) {</a>
<a name="ln898">			p = sl-&gt;sl_str[j * lines + i];</a>
<a name="ln899">			if (p)</a>
<a name="ln900">				fputs(p, ttyout);</a>
<a name="ln901">			if (j * lines + i + lines &gt;= sl-&gt;sl_cur) {</a>
<a name="ln902">				putc('\n', ttyout);</a>
<a name="ln903">				break;</a>
<a name="ln904">			}</a>
<a name="ln905">			w = strlen(p);</a>
<a name="ln906">			while (w &lt; width) {</a>
<a name="ln907">				w = (w + 8) &amp;~ 7;</a>
<a name="ln908">				(void)putc('\t', ttyout);</a>
<a name="ln909">			}</a>
<a name="ln910">		}</a>
<a name="ln911">	}</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">/*</a>
<a name="ln915"> * Update the global ttywidth value, using TIOCGWINSZ.</a>
<a name="ln916"> */</a>
<a name="ln917">void</a>
<a name="ln918">setttywidth(int a)</a>
<a name="ln919">{</a>
<a name="ln920">	struct winsize winsize;</a>
<a name="ln921">	int oerrno = errno;</a>
<a name="ln922"> </a>
<a name="ln923">	if (ioctl(fileno(ttyout), TIOCGWINSZ, &amp;winsize) != -1 &amp;&amp;</a>
<a name="ln924">	    winsize.ws_col != 0)</a>
<a name="ln925">		ttywidth = winsize.ws_col;</a>
<a name="ln926">	else</a>
<a name="ln927">		ttywidth = 80;</a>
<a name="ln928">	errno = oerrno;</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">/*</a>
<a name="ln932"> * Change the rate limit up (SIGUSR1) or down (SIGUSR2)</a>
<a name="ln933"> */</a>
<a name="ln934">void</a>
<a name="ln935">crankrate(int sig)</a>
<a name="ln936">{</a>
<a name="ln937"> </a>
<a name="ln938">	switch (sig) {</a>
<a name="ln939">	case SIGUSR1:</a>
<a name="ln940">		if (rate_get)</a>
<a name="ln941">			rate_get += rate_get_incr;</a>
<a name="ln942">		if (rate_put)</a>
<a name="ln943">			rate_put += rate_put_incr;</a>
<a name="ln944">		break;</a>
<a name="ln945">	case SIGUSR2:</a>
<a name="ln946">		if (rate_get &amp;&amp; rate_get &gt; rate_get_incr)</a>
<a name="ln947">			rate_get -= rate_get_incr;</a>
<a name="ln948">		if (rate_put &amp;&amp; rate_put &gt; rate_put_incr)</a>
<a name="ln949">			rate_put -= rate_put_incr;</a>
<a name="ln950">		break;</a>
<a name="ln951">	default:</a>
<a name="ln952">		err(1, &quot;crankrate invoked with unknown signal: %d&quot;, sig);</a>
<a name="ln953">	}</a>
<a name="ln954">}</a>
<a name="ln955"> </a>
<a name="ln956"> </a>
<a name="ln957">/*</a>
<a name="ln958"> * Setup or cleanup EditLine structures</a>
<a name="ln959"> */</a>
<a name="ln960">#ifndef NO_EDITCOMPLETE</a>
<a name="ln961">void</a>
<a name="ln962">controlediting(void)</a>
<a name="ln963">{</a>
<a name="ln964">	if (editing &amp;&amp; el == NULL &amp;&amp; hist == NULL) {</a>
<a name="ln965">		HistEvent ev;</a>
<a name="ln966">		int editmode;</a>
<a name="ln967"> </a>
<a name="ln968">		el = el_init(getprogname(), stdin, ttyout, stderr);</a>
<a name="ln969">		/* init editline */</a>
<a name="ln970">		hist = history_init();		/* init the builtin history */</a>
<a name="ln971">		history(hist, &amp;ev, H_SETSIZE, 100);/* remember 100 events */</a>
<a name="ln972">		el_set(el, EL_HIST, history, hist);	/* use history */</a>
<a name="ln973"> </a>
<a name="ln974">		el_set(el, EL_EDITOR, &quot;emacs&quot;);	/* default editor is emacs */</a>
<a name="ln975">		el_set(el, EL_PROMPT, prompt);	/* set the prompt functions */</a>
<a name="ln976">		el_set(el, EL_RPROMPT, rprompt);</a>
<a name="ln977"> </a>
<a name="ln978">		/* add local file completion, bind to TAB */</a>
<a name="ln979">		el_set(el, EL_ADDFN, &quot;ftp-complete&quot;,</a>
<a name="ln980">		    &quot;Context sensitive argument completion&quot;,</a>
<a name="ln981">		    complete);</a>
<a name="ln982">		el_set(el, EL_BIND, &quot;^I&quot;, &quot;ftp-complete&quot;, NULL);</a>
<a name="ln983">		el_source(el, NULL);	/* read ~/.editrc */</a>
<a name="ln984">		if ((el_get(el, EL_EDITMODE, &amp;editmode) != -1) &amp;&amp; editmode == 0)</a>
<a name="ln985">			editing = 0;	/* the user doesn't want editing,</a>
<a name="ln986">					 * so disable, and let statement</a>
<a name="ln987">					 * below cleanup */</a>
<a name="ln988">		else</a>
<a name="ln989">			el_set(el, EL_SIGNAL, 1);</a>
<a name="ln990">	}</a>
<a name="ln991">	if (!editing) {</a>
<a name="ln992">		if (hist) {</a>
<a name="ln993">			history_end(hist);</a>
<a name="ln994">			hist = NULL;</a>
<a name="ln995">		}</a>
<a name="ln996">		if (el) {</a>
<a name="ln997">			el_end(el);</a>
<a name="ln998">			el = NULL;</a>
<a name="ln999">		}</a>
<a name="ln1000">	}</a>
<a name="ln1001">}</a>
<a name="ln1002">#endif /* !NO_EDITCOMPLETE */</a>
<a name="ln1003"> </a>
<a name="ln1004">/*</a>
<a name="ln1005"> * Convert the string `arg' to an int, which may have an optional SI suffix</a>
<a name="ln1006"> * (`b', `k', `m', `g'). Returns the number for success, -1 otherwise.</a>
<a name="ln1007"> */</a>
<a name="ln1008">int</a>
<a name="ln1009">strsuftoi(const char *arg)</a>
<a name="ln1010">{</a>
<a name="ln1011">	char *cp;</a>
<a name="ln1012">	long val;</a>
<a name="ln1013"> </a>
<a name="ln1014">	if (!isdigit((unsigned char)arg[0]))</a>
<a name="ln1015">		return (-1);</a>
<a name="ln1016"> </a>
<a name="ln1017">	val = strtol(arg, &amp;cp, 10);</a>
<a name="ln1018">	if (cp != NULL) {</a>
<a name="ln1019">		if (cp[0] != '\0' &amp;&amp; cp[1] != '\0')</a>
<a name="ln1020">			 return (-1);</a>
<a name="ln1021">		switch (tolower((unsigned char)cp[0])) {</a>
<a name="ln1022">		case '\0':</a>
<a name="ln1023">		case 'b':</a>
<a name="ln1024">			break;</a>
<a name="ln1025">		case 'k':</a>
<a name="ln1026">			val &lt;&lt;= 10;</a>
<a name="ln1027">			break;</a>
<a name="ln1028">		case 'm':</a>
<a name="ln1029">			val &lt;&lt;= 20;</a>
<a name="ln1030">			break;</a>
<a name="ln1031">		case 'g':</a>
<a name="ln1032">			val &lt;&lt;= 30;</a>
<a name="ln1033">			break;</a>
<a name="ln1034">		default:</a>
<a name="ln1035">			return (-1);</a>
<a name="ln1036">		}</a>
<a name="ln1037">	}</a>
<a name="ln1038">	if (val &lt; 0 || val &gt; INT_MAX)</a>
<a name="ln1039">		return (-1);</a>
<a name="ln1040"> </a>
<a name="ln1041">	return (val);</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">/*</a>
<a name="ln1045"> * Set up socket buffer sizes before a connection is made.</a>
<a name="ln1046"> */</a>
<a name="ln1047">void</a>
<a name="ln1048">setupsockbufsize(int sock)</a>
<a name="ln1049">{</a>
<a name="ln1050"> </a>
<a name="ln1051">	if (setsockopt(sock, SOL_SOCKET, SO_SNDBUF,</a>
<a name="ln1052">	    (void *)&amp;sndbuf_size, sizeof(sndbuf_size)) == -1)</a>
<a name="ln1053">		warn(&quot;unable to set sndbuf size %d&quot;, sndbuf_size);</a>
<a name="ln1054"> </a>
<a name="ln1055">	if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,</a>
<a name="ln1056">	    (void *)&amp;rcvbuf_size, sizeof(rcvbuf_size)) == -1)</a>
<a name="ln1057">		warn(&quot;unable to set rcvbuf size %d&quot;, rcvbuf_size);</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">/*</a>
<a name="ln1061"> * Copy characters from src into dst, \ quoting characters that require it</a>
<a name="ln1062"> */</a>
<a name="ln1063">void</a>
<a name="ln1064">ftpvis(char *dst, size_t dstlen, const char *src, size_t srclen)</a>
<a name="ln1065">{</a>
<a name="ln1066">	int	di, si;</a>
<a name="ln1067"> </a>
<a name="ln1068">	for (di = si = 0;</a>
<a name="ln1069">	    src[si] != '\0' &amp;&amp; di &lt; dstlen &amp;&amp; si &lt; srclen;</a>
<a name="ln1070">	    di++, si++) {</a>
<a name="ln1071">		switch (src[si]) {</a>
<a name="ln1072">		case '\\':</a>
<a name="ln1073">		case ' ':</a>
<a name="ln1074">		case '\t':</a>
<a name="ln1075">		case '\r':</a>
<a name="ln1076">		case '\n':</a>
<a name="ln1077">		case '&quot;':</a>
<a name="ln1078">			dst[di++] = '\\';</a>
<a name="ln1079">			if (di &gt;= dstlen)</a>
<a name="ln1080">				break;</a>
<a name="ln1081">			/* FALLTHROUGH */</a>
<a name="ln1082">		default:</a>
<a name="ln1083">			dst[di] = src[si];</a>
<a name="ln1084">		}</a>
<a name="ln1085">	}</a>
<a name="ln1086">	dst[di] = '\0';</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">/*</a>
<a name="ln1090"> * Copy src into buf (which is len bytes long), expanding % sequences.</a>
<a name="ln1091"> */</a>
<a name="ln1092">void</a>
<a name="ln1093">formatbuf(char *buf, size_t len, const char *src)</a>
<a name="ln1094">{</a>
<a name="ln1095">	const char	*p;</a>
<a name="ln1096">	char		*p2, *q;</a>
<a name="ln1097">	int		 i, op, updirs, pdirs;</a>
<a name="ln1098"> </a>
<a name="ln1099">#define ADDBUF(x) do { \</a>
<a name="ln1100">		if (i &gt;= len - 1) \</a>
<a name="ln1101">			goto endbuf; \</a>
<a name="ln1102">		buf[i++] = (x); \</a>
<a name="ln1103">	} while (0)</a>
<a name="ln1104"> </a>
<a name="ln1105">	p = src;</a>
<a name="ln1106">	for (i = 0; *p; p++) {</a>
<a name="ln1107">		if (*p != '%') {</a>
<a name="ln1108">			ADDBUF(*p);</a>
<a name="ln1109">			continue;</a>
<a name="ln1110">		}</a>
<a name="ln1111">		p++;</a>
<a name="ln1112"> </a>
<a name="ln1113">		switch (op = *p) {</a>
<a name="ln1114"> </a>
<a name="ln1115">		case '/':</a>
<a name="ln1116">		case '.':</a>
<a name="ln1117">		case 'c':</a>
<a name="ln1118">			p2 = connected ? remotecwd : &quot;&quot;;</a>
<a name="ln1119">			updirs = pdirs = 0;</a>
<a name="ln1120"> </a>
<a name="ln1121">			/* option to determine fixed # of dirs from path */</a>
<a name="ln1122">			if (op == '.' || op == 'c') {</a>
<a name="ln1123">				int skip;</a>
<a name="ln1124"> </a>
<a name="ln1125">				q = p2;</a>
<a name="ln1126">				while (*p2)		/* calc # of /'s */</a>
<a name="ln1127">					if (*p2++ == '/')</a>
<a name="ln1128">						updirs++;</a>
<a name="ln1129">				if (p[1] == '0') {	/* print &lt;x&gt; or ... */</a>
<a name="ln1130">					pdirs = 1;</a>
<a name="ln1131">					p++;</a>
<a name="ln1132">				}</a>
<a name="ln1133">				if (p[1] &gt;= '1' &amp;&amp; p[1] &lt;= '9') {</a>
<a name="ln1134">							/* calc # to skip  */</a>
<a name="ln1135">					skip = p[1] - '0';</a>
<a name="ln1136">					p++;</a>
<a name="ln1137">				} else</a>
<a name="ln1138">					skip = 1;</a>
<a name="ln1139"> </a>
<a name="ln1140">				updirs -= skip;</a>
<a name="ln1141">				while (skip-- &gt; 0) {</a>
<a name="ln1142">					while ((p2 &gt; q) &amp;&amp; (*p2 != '/'))</a>
<a name="ln1143">						p2--;	/* back up */</a>
<a name="ln1144">					if (skip &amp;&amp; p2 &gt; q)</a>
<a name="ln1145">						p2--;</a>
<a name="ln1146">				}</a>
<a name="ln1147">				if (*p2 == '/' &amp;&amp; p2 != q)</a>
<a name="ln1148">					p2++;</a>
<a name="ln1149">			}</a>
<a name="ln1150"> </a>
<a name="ln1151">			if (updirs &gt; 0 &amp;&amp; pdirs) {</a>
<a name="ln1152">				if (i &gt;= len - 5)</a>
<a name="ln1153">					break;</a>
<a name="ln1154">				if (op == '.') {</a>
<a name="ln1155">					ADDBUF('.');</a>
<a name="ln1156">					ADDBUF('.');</a>
<a name="ln1157">					ADDBUF('.');</a>
<a name="ln1158">				} else {</a>
<a name="ln1159">					ADDBUF('/');</a>
<a name="ln1160">					ADDBUF('&lt;');</a>
<a name="ln1161">					if (updirs &gt; 9) {</a>
<a name="ln1162">						ADDBUF('9');</a>
<a name="ln1163">						ADDBUF('+');</a>
<a name="ln1164">					} else</a>
<a name="ln1165">						ADDBUF('0' + updirs);</a>
<a name="ln1166">					ADDBUF('&gt;');</a>
<a name="ln1167">				}</a>
<a name="ln1168">			}</a>
<a name="ln1169">			for (; *p2; p2++)</a>
<a name="ln1170">				ADDBUF(*p2);</a>
<a name="ln1171">			break;</a>
<a name="ln1172"> </a>
<a name="ln1173">		case 'M':</a>
<a name="ln1174">		case 'm':</a>
<a name="ln1175">			for (p2 = connected &amp;&amp; username ? username : &quot;-&quot;;</a>
<a name="ln1176">			    *p2 ; p2++) {</a>
<a name="ln1177">				if (op == 'm' &amp;&amp; *p2 == '.')</a>
<a name="ln1178">					break;</a>
<a name="ln1179">				ADDBUF(*p2);</a>
<a name="ln1180">			}</a>
<a name="ln1181">			break;</a>
<a name="ln1182"> </a>
<a name="ln1183">		case 'n':</a>
<a name="ln1184">			for (p2 = connected ? username : &quot;-&quot;; *p2 ; p2++)</a>
<a name="ln1185">				ADDBUF(*p2);</a>
<a name="ln1186">			break;</a>
<a name="ln1187"> </a>
<a name="ln1188">		case '%':</a>
<a name="ln1189">			ADDBUF('%');</a>
<a name="ln1190">			break;</a>
<a name="ln1191"> </a>
<a name="ln1192">		default:		/* display unknown codes literally */</a>
<a name="ln1193">			ADDBUF('%');</a>
<a name="ln1194">			ADDBUF(op);</a>
<a name="ln1195">			break;</a>
<a name="ln1196"> </a>
<a name="ln1197">		}</a>
<a name="ln1198">	}</a>
<a name="ln1199"> endbuf:</a>
<a name="ln1200">	buf[i] = '\0';</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">/*</a>
<a name="ln1204"> * Parse `port' into a TCP port number, defaulting to `defport' if `port' is</a>
<a name="ln1205"> * an unknown service name. If defport != -1, print a warning upon bad parse.</a>
<a name="ln1206"> */</a>
<a name="ln1207">int</a>
<a name="ln1208">parseport(const char *port, int defport)</a>
<a name="ln1209">{</a>
<a name="ln1210">	int	 rv;</a>
<a name="ln1211">	long	 nport;</a>
<a name="ln1212">	char	*p, *ep;</a>
<a name="ln1213"> </a>
<a name="ln1214">	p = xstrdup(port);</a>
<a name="ln1215">	nport = strtol(p, &amp;ep, 10);</a>
<a name="ln1216">	if (*ep != '\0' &amp;&amp; ep == p) {</a>
<a name="ln1217">		struct servent	*svp;</a>
<a name="ln1218"> </a>
<a name="ln1219">		svp = getservbyname(port, &quot;tcp&quot;);</a>
<a name="ln1220">		if (svp == NULL) {</a>
<a name="ln1221"> badparseport:</a>
<a name="ln1222">			if (defport != -1)</a>
<a name="ln1223">				warnx(&quot;Unknown port `%s', using port %d&quot;,</a>
<a name="ln1224">				    port, defport);</a>
<a name="ln1225">			rv = defport;</a>
<a name="ln1226">		} else</a>
<a name="ln1227">			rv = ntohs(svp-&gt;s_port);</a>
<a name="ln1228">	} else if (nport &lt; 1 || nport &gt; MAX_IN_PORT_T || *ep != '\0')</a>
<a name="ln1229">		goto badparseport;</a>
<a name="ln1230">	else</a>
<a name="ln1231">		rv = nport;</a>
<a name="ln1232">	free(p);</a>
<a name="ln1233">	return (rv);</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">/*</a>
<a name="ln1237"> * Determine if given string is an IPv6 address or not.</a>
<a name="ln1238"> * Return 1 for yes, 0 for no</a>
<a name="ln1239"> */</a>
<a name="ln1240">int</a>
<a name="ln1241">isipv6addr(const char *addr)</a>
<a name="ln1242">{</a>
<a name="ln1243">	int rv = 0;</a>
<a name="ln1244">#ifdef INET6</a>
<a name="ln1245">	struct addrinfo hints, *res;</a>
<a name="ln1246"> </a>
<a name="ln1247">	memset(&amp;hints, 0, sizeof(hints));</a>
<a name="ln1248">	hints.ai_family = PF_INET6;</a>
<a name="ln1249">	hints.ai_socktype = SOCK_DGRAM;	/*dummy*/</a>
<a name="ln1250">	hints.ai_flags = AI_NUMERICHOST;</a>
<a name="ln1251">	if (getaddrinfo(addr, &quot;0&quot;, &amp;hints, &amp;res) != 0)</a>
<a name="ln1252">		rv = 0;</a>
<a name="ln1253">	else {</a>
<a name="ln1254">		rv = 1;</a>
<a name="ln1255">		freeaddrinfo(res);</a>
<a name="ln1256">	}</a>
<a name="ln1257">	if (debug)</a>
<a name="ln1258">		fprintf(ttyout, &quot;isipv6addr: got %d for %s\n&quot;, rv, addr);</a>
<a name="ln1259">#endif</a>
<a name="ln1260">	return (rv == 1) ? 1 : 0;</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263"> </a>
<a name="ln1264">/*</a>
<a name="ln1265"> * Internal version of connect(2); sets socket buffer sizes first and</a>
<a name="ln1266"> * supports a connection timeout using a non-blocking connect(2) with</a>
<a name="ln1267"> * a poll(2).</a>
<a name="ln1268"> * Socket fcntl flags are temporarily updated to include O_NONBLOCK;</a>
<a name="ln1269"> * these will not be reverted on connection failure.</a>
<a name="ln1270"> * Returns -1 upon failure (with errno set to the problem), or 0 on success.</a>
<a name="ln1271"> */</a>
<a name="ln1272">int</a>
<a name="ln1273">xconnect(int sock, const struct sockaddr *name, socklen_t namelen)</a>
<a name="ln1274">{</a>
<a name="ln1275">	int		flags, rv, timeout, error;</a>
<a name="ln1276">	socklen_t	slen;</a>
<a name="ln1277">	struct timeval	endtime, now, td;</a>
<a name="ln1278">	struct pollfd	pfd[1];</a>
<a name="ln1279"> </a>
<a name="ln1280">	setupsockbufsize(sock);</a>
<a name="ln1281"> </a>
<a name="ln1282">	if ((flags = fcntl(sock, F_GETFL, 0)) == -1)</a>
<a name="ln1283">		return -1;			/* get current socket flags  */</a>
<a name="ln1284">	if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) == -1)</a>
<a name="ln1285">		return -1;			/* set non-blocking connect */</a>
<a name="ln1286"> </a>
<a name="ln1287">	/* NOTE: we now must restore socket flags on successful exit */</a>
<a name="ln1288"> </a>
<a name="ln1289">	pfd[0].fd = sock;</a>
<a name="ln1290">	pfd[0].events = POLLIN|POLLOUT;</a>
<a name="ln1291"> </a>
<a name="ln1292">	if (quit_time &gt; 0) {			/* want a non default timeout */</a>
<a name="ln1293">		(void)gettimeofday(&amp;endtime, NULL);</a>
<a name="ln1294">		endtime.tv_sec += quit_time;	/* determine end time */</a>
<a name="ln1295">	}</a>
<a name="ln1296"> </a>
<a name="ln1297">	rv = connect(sock, name, namelen);	/* inititate the connection */</a>
<a name="ln1298">	if (rv == -1) {				/* connection error */</a>
<a name="ln1299">		if (errno != EINPROGRESS)	/* error isn't &quot;please wait&quot; */</a>
<a name="ln1300">			return -1;</a>
<a name="ln1301"> </a>
<a name="ln1302">						/* connect EINPROGRESS; wait */</a>
<a name="ln1303">		do {</a>
<a name="ln1304">			if (quit_time &gt; 0) {	/* determine timeout */</a>
<a name="ln1305">				(void)gettimeofday(&amp;now, NULL);</a>
<a name="ln1306">				timersub(&amp;endtime, &amp;now, &amp;td);</a>
<a name="ln1307">				timeout = td.tv_sec * 1000 + td.tv_usec/1000;</a>
<a name="ln1308">				if (timeout &lt; 0)</a>
<a name="ln1309">					timeout = 0;</a>
<a name="ln1310">			} else {</a>
<a name="ln1311">				timeout = INFTIM;</a>
<a name="ln1312">			}</a>
<a name="ln1313">			pfd[0].revents = 0;</a>
<a name="ln1314">			rv = xpoll(pfd, 1, timeout);</a>
<a name="ln1315">						/* loop until poll ! EINTR */</a>
<a name="ln1316">		} while (rv == -1 &amp;&amp; errno == EINTR);</a>
<a name="ln1317"> </a>
<a name="ln1318">		if (rv == 0) {			/* poll (connect) timed out */</a>
<a name="ln1319">			errno = ETIMEDOUT;</a>
<a name="ln1320">			return -1;</a>
<a name="ln1321">		}</a>
<a name="ln1322"> </a>
<a name="ln1323">		if (rv == -1) {			/* poll error */</a>
<a name="ln1324">			return -1;</a>
<a name="ln1325">		} else if (pfd[0].revents &amp; (POLLIN|POLLOUT)) {</a>
<a name="ln1326">			slen = sizeof(error);	/* OK, or pending error */</a>
<a name="ln1327">			if (getsockopt(sock, SOL_SOCKET, SO_ERROR,</a>
<a name="ln1328">			    &amp;error, &amp;slen) == -1)</a>
<a name="ln1329">				return -1;	/* Solaris pending error */</a>
<a name="ln1330">			if (error != 0) {</a>
<a name="ln1331">				errno = error;	/* BSD pending error */</a>
<a name="ln1332">				return -1;</a>
<a name="ln1333">			}</a>
<a name="ln1334">		} else {</a>
<a name="ln1335">			errno = EBADF;		/* this shouldn't happen ... */</a>
<a name="ln1336">			return -1;</a>
<a name="ln1337">		}</a>
<a name="ln1338">	}</a>
<a name="ln1339"> </a>
<a name="ln1340">	if (fcntl(sock, F_SETFL, flags) == -1)	/* restore socket flags */</a>
<a name="ln1341">		return -1;</a>
<a name="ln1342">	return 0;</a>
<a name="ln1343">}</a>
<a name="ln1344"> </a>
<a name="ln1345">/*</a>
<a name="ln1346"> * Internal version of listen(2); sets socket buffer sizes first.</a>
<a name="ln1347"> */</a>
<a name="ln1348">int</a>
<a name="ln1349">xlisten(int sock, int backlog)</a>
<a name="ln1350">{</a>
<a name="ln1351"> </a>
<a name="ln1352">	setupsockbufsize(sock);</a>
<a name="ln1353">	return (listen(sock, backlog));</a>
<a name="ln1354">}</a>
<a name="ln1355"> </a>
<a name="ln1356">/*</a>
<a name="ln1357"> * Internal version of poll(2), to allow reimplementation by select(2)</a>
<a name="ln1358"> * on platforms without the former.</a>
<a name="ln1359"> */</a>
<a name="ln1360">int</a>
<a name="ln1361">xpoll(struct pollfd *fds, int nfds, int timeout)</a>
<a name="ln1362">{</a>
<a name="ln1363">	return poll(fds, nfds, timeout);</a>
<a name="ln1364">}</a>
<a name="ln1365"> </a>
<a name="ln1366">/*</a>
<a name="ln1367"> * malloc() with inbuilt error checking</a>
<a name="ln1368"> */</a>
<a name="ln1369">void *</a>
<a name="ln1370">xmalloc(size_t size)</a>
<a name="ln1371">{</a>
<a name="ln1372">	void *p;</a>
<a name="ln1373"> </a>
<a name="ln1374">	p = malloc(size);</a>
<a name="ln1375">	if (p == NULL)</a>
<a name="ln1376">		err(1, &quot;Unable to allocate %ld bytes of memory&quot;, (long)size);</a>
<a name="ln1377">	return (p);</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">/*</a>
<a name="ln1381"> * sl_init() with inbuilt error checking</a>
<a name="ln1382"> */</a>
<a name="ln1383">StringList *</a>
<a name="ln1384">xsl_init(void)</a>
<a name="ln1385">{</a>
<a name="ln1386">	StringList *p;</a>
<a name="ln1387"> </a>
<a name="ln1388">	p = sl_init();</a>
<a name="ln1389">	if (p == NULL)</a>
<a name="ln1390">		err(1, &quot;Unable to allocate memory for stringlist&quot;);</a>
<a name="ln1391">	return (p);</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394">/*</a>
<a name="ln1395"> * sl_add() with inbuilt error checking</a>
<a name="ln1396"> */</a>
<a name="ln1397">void</a>
<a name="ln1398">xsl_add(StringList *sl, char *i)</a>
<a name="ln1399">{</a>
<a name="ln1400"> </a>
<a name="ln1401">	if (sl_add(sl, i) == -1)</a>
<a name="ln1402">		err(1, &quot;Unable to add `%s' to stringlist&quot;, i);</a>
<a name="ln1403">}</a>
<a name="ln1404"> </a>
<a name="ln1405">/*</a>
<a name="ln1406"> * strdup() with inbuilt error checking</a>
<a name="ln1407"> */</a>
<a name="ln1408">char *</a>
<a name="ln1409">xstrdup(const char *str)</a>
<a name="ln1410">{</a>
<a name="ln1411">	char *s;</a>
<a name="ln1412"> </a>
<a name="ln1413">	if (str == NULL)</a>
<a name="ln1414">		errx(1, &quot;xstrdup() called with NULL argument&quot;);</a>
<a name="ln1415">	s = strdup(str);</a>
<a name="ln1416">	if (s == NULL)</a>
<a name="ln1417">		err(1, &quot;Unable to allocate memory for string copy&quot;);</a>
<a name="ln1418">	return (s);</a>
<a name="ln1419">}</a>

</code></pre>
<div class="balloon" rel="418"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in index: 'strlen(tmp)'.</p></div>
<div class="balloon" rel="1260"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'rv == 1' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
