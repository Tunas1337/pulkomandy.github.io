
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>dswexec.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/******************************************************************************</a>
<a name="ln2"> *</a>
<a name="ln3"> * Module Name: dswexec - Dispatcher method execution callbacks;</a>
<a name="ln4"> *                        dispatch to interpreter.</a>
<a name="ln5"> *</a>
<a name="ln6"> *****************************************************************************/</a>
<a name="ln7"> </a>
<a name="ln8">/******************************************************************************</a>
<a name="ln9"> *</a>
<a name="ln10"> * 1. Copyright Notice</a>
<a name="ln11"> *</a>
<a name="ln12"> * Some or all of this work - Copyright (c) 1999 - 2018, Intel Corp.</a>
<a name="ln13"> * All rights reserved.</a>
<a name="ln14"> *</a>
<a name="ln15"> * 2. License</a>
<a name="ln16"> *</a>
<a name="ln17"> * 2.1. This is your license from Intel Corp. under its intellectual property</a>
<a name="ln18"> * rights. You may have additional license terms from the party that provided</a>
<a name="ln19"> * you this software, covering your right to use that party's intellectual</a>
<a name="ln20"> * property rights.</a>
<a name="ln21"> *</a>
<a name="ln22"> * 2.2. Intel grants, free of charge, to any person (&quot;Licensee&quot;) obtaining a</a>
<a name="ln23"> * copy of the source code appearing in this file (&quot;Covered Code&quot;) an</a>
<a name="ln24"> * irrevocable, perpetual, worldwide license under Intel's copyrights in the</a>
<a name="ln25"> * base code distributed originally by Intel (&quot;Original Intel Code&quot;) to copy,</a>
<a name="ln26"> * make derivatives, distribute, use and display any portion of the Covered</a>
<a name="ln27"> * Code in any form, with the right to sublicense such rights; and</a>
<a name="ln28"> *</a>
<a name="ln29"> * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent</a>
<a name="ln30"> * license (with the right to sublicense), under only those claims of Intel</a>
<a name="ln31"> * patents that are infringed by the Original Intel Code, to make, use, sell,</a>
<a name="ln32"> * offer to sell, and import the Covered Code and derivative works thereof</a>
<a name="ln33"> * solely to the minimum extent necessary to exercise the above copyright</a>
<a name="ln34"> * license, and in no event shall the patent license extend to any additions</a>
<a name="ln35"> * to or modifications of the Original Intel Code. No other license or right</a>
<a name="ln36"> * is granted directly or by implication, estoppel or otherwise;</a>
<a name="ln37"> *</a>
<a name="ln38"> * The above copyright and patent license is granted only if the following</a>
<a name="ln39"> * conditions are met:</a>
<a name="ln40"> *</a>
<a name="ln41"> * 3. Conditions</a>
<a name="ln42"> *</a>
<a name="ln43"> * 3.1. Redistribution of Source with Rights to Further Distribute Source.</a>
<a name="ln44"> * Redistribution of source code of any substantial portion of the Covered</a>
<a name="ln45"> * Code or modification with rights to further distribute source must include</a>
<a name="ln46"> * the above Copyright Notice, the above License, this list of Conditions,</a>
<a name="ln47"> * and the following Disclaimer and Export Compliance provision. In addition,</a>
<a name="ln48"> * Licensee must cause all Covered Code to which Licensee contributes to</a>
<a name="ln49"> * contain a file documenting the changes Licensee made to create that Covered</a>
<a name="ln50"> * Code and the date of any change. Licensee must include in that file the</a>
<a name="ln51"> * documentation of any changes made by any predecessor Licensee. Licensee</a>
<a name="ln52"> * must include a prominent statement that the modification is derived,</a>
<a name="ln53"> * directly or indirectly, from Original Intel Code.</a>
<a name="ln54"> *</a>
<a name="ln55"> * 3.2. Redistribution of Source with no Rights to Further Distribute Source.</a>
<a name="ln56"> * Redistribution of source code of any substantial portion of the Covered</a>
<a name="ln57"> * Code or modification without rights to further distribute source must</a>
<a name="ln58"> * include the following Disclaimer and Export Compliance provision in the</a>
<a name="ln59"> * documentation and/or other materials provided with distribution. In</a>
<a name="ln60"> * addition, Licensee may not authorize further sublicense of source of any</a>
<a name="ln61"> * portion of the Covered Code, and must include terms to the effect that the</a>
<a name="ln62"> * license from Licensee to its licensee is limited to the intellectual</a>
<a name="ln63"> * property embodied in the software Licensee provides to its licensee, and</a>
<a name="ln64"> * not to intellectual property embodied in modifications its licensee may</a>
<a name="ln65"> * make.</a>
<a name="ln66"> *</a>
<a name="ln67"> * 3.3. Redistribution of Executable. Redistribution in executable form of any</a>
<a name="ln68"> * substantial portion of the Covered Code or modification must reproduce the</a>
<a name="ln69"> * above Copyright Notice, and the following Disclaimer and Export Compliance</a>
<a name="ln70"> * provision in the documentation and/or other materials provided with the</a>
<a name="ln71"> * distribution.</a>
<a name="ln72"> *</a>
<a name="ln73"> * 3.4. Intel retains all right, title, and interest in and to the Original</a>
<a name="ln74"> * Intel Code.</a>
<a name="ln75"> *</a>
<a name="ln76"> * 3.5. Neither the name Intel nor any other trademark owned or controlled by</a>
<a name="ln77"> * Intel shall be used in advertising or otherwise to promote the sale, use or</a>
<a name="ln78"> * other dealings in products derived from or relating to the Covered Code</a>
<a name="ln79"> * without prior written authorization from Intel.</a>
<a name="ln80"> *</a>
<a name="ln81"> * 4. Disclaimer and Export Compliance</a>
<a name="ln82"> *</a>
<a name="ln83"> * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED</a>
<a name="ln84"> * HERE. ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE</a>
<a name="ln85"> * IS PROVIDED &quot;AS IS,&quot; AND INTEL WILL NOT PROVIDE ANY SUPPORT, ASSISTANCE,</a>
<a name="ln86"> * INSTALLATION, TRAINING OR OTHER SERVICES. INTEL WILL NOT PROVIDE ANY</a>
<a name="ln87"> * UPDATES, ENHANCEMENTS OR EXTENSIONS. INTEL SPECIFICALLY DISCLAIMS ANY</a>
<a name="ln88"> * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A</a>
<a name="ln89"> * PARTICULAR PURPOSE.</a>
<a name="ln90"> *</a>
<a name="ln91"> * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES</a>
<a name="ln92"> * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR</a>
<a name="ln93"> * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,</a>
<a name="ln94"> * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY</a>
<a name="ln95"> * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL</a>
<a name="ln96"> * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES. THESE LIMITATIONS</a>
<a name="ln97"> * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY</a>
<a name="ln98"> * LIMITED REMEDY.</a>
<a name="ln99"> *</a>
<a name="ln100"> * 4.3. Licensee shall not export, either directly or indirectly, any of this</a>
<a name="ln101"> * software or system incorporating such software without first obtaining any</a>
<a name="ln102"> * required license or other approval from the U. S. Department of Commerce or</a>
<a name="ln103"> * any other agency or department of the United States Government. In the</a>
<a name="ln104"> * event Licensee exports any such software from the United States or</a>
<a name="ln105"> * re-exports any such software from a foreign destination, Licensee shall</a>
<a name="ln106"> * ensure that the distribution and export/re-export of the software is in</a>
<a name="ln107"> * compliance with all laws, regulations, orders, or other restrictions of the</a>
<a name="ln108"> * U.S. Export Administration Regulations. Licensee agrees that neither it nor</a>
<a name="ln109"> * any of its subsidiaries will export/re-export any technical data, process,</a>
<a name="ln110"> * software, or service, directly or indirectly, to any country for which the</a>
<a name="ln111"> * United States government or any agency thereof requires an export license,</a>
<a name="ln112"> * other governmental approval, or letter of assurance, without first obtaining</a>
<a name="ln113"> * such license, approval or letter.</a>
<a name="ln114"> *</a>
<a name="ln115"> *****************************************************************************</a>
<a name="ln116"> *</a>
<a name="ln117"> * Alternatively, you may choose to be licensed under the terms of the</a>
<a name="ln118"> * following license:</a>
<a name="ln119"> *</a>
<a name="ln120"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln121"> * modification, are permitted provided that the following conditions</a>
<a name="ln122"> * are met:</a>
<a name="ln123"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln124"> *    notice, this list of conditions, and the following disclaimer,</a>
<a name="ln125"> *    without modification.</a>
<a name="ln126"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</a>
<a name="ln127"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</a>
<a name="ln128"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</a>
<a name="ln129"> *    including a substantially similar Disclaimer requirement for further</a>
<a name="ln130"> *    binary redistribution.</a>
<a name="ln131"> * 3. Neither the names of the above-listed copyright holders nor the names</a>
<a name="ln132"> *    of any contributors may be used to endorse or promote products derived</a>
<a name="ln133"> *    from this software without specific prior written permission.</a>
<a name="ln134"> *</a>
<a name="ln135"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln136"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln137"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln138"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln139"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln140"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln141"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln142"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln143"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln144"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln145"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln146"> *</a>
<a name="ln147"> * Alternatively, you may choose to be licensed under the terms of the</a>
<a name="ln148"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</a>
<a name="ln149"> * Software Foundation.</a>
<a name="ln150"> *</a>
<a name="ln151"> *****************************************************************************/</a>
<a name="ln152"> </a>
<a name="ln153">#include &quot;acpi.h&quot;</a>
<a name="ln154">#include &quot;accommon.h&quot;</a>
<a name="ln155">#include &quot;acparser.h&quot;</a>
<a name="ln156">#include &quot;amlcode.h&quot;</a>
<a name="ln157">#include &quot;acdispat.h&quot;</a>
<a name="ln158">#include &quot;acinterp.h&quot;</a>
<a name="ln159">#include &quot;acnamesp.h&quot;</a>
<a name="ln160">#include &quot;acdebug.h&quot;</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">#define _COMPONENT          ACPI_DISPATCHER</a>
<a name="ln164">        ACPI_MODULE_NAME    (&quot;dswexec&quot;)</a>
<a name="ln165"> </a>
<a name="ln166">/*</a>
<a name="ln167"> * Dispatch table for opcode classes</a>
<a name="ln168"> */</a>
<a name="ln169">static ACPI_EXECUTE_OP      AcpiGbl_OpTypeDispatch [] =</a>
<a name="ln170">{</a>
<a name="ln171">    AcpiExOpcode_0A_0T_1R,</a>
<a name="ln172">    AcpiExOpcode_1A_0T_0R,</a>
<a name="ln173">    AcpiExOpcode_1A_0T_1R,</a>
<a name="ln174">    AcpiExOpcode_1A_1T_0R,</a>
<a name="ln175">    AcpiExOpcode_1A_1T_1R,</a>
<a name="ln176">    AcpiExOpcode_2A_0T_0R,</a>
<a name="ln177">    AcpiExOpcode_2A_0T_1R,</a>
<a name="ln178">    AcpiExOpcode_2A_1T_1R,</a>
<a name="ln179">    AcpiExOpcode_2A_2T_1R,</a>
<a name="ln180">    AcpiExOpcode_3A_0T_0R,</a>
<a name="ln181">    AcpiExOpcode_3A_1T_1R,</a>
<a name="ln182">    AcpiExOpcode_6A_0T_1R</a>
<a name="ln183">};</a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186">/*****************************************************************************</a>
<a name="ln187"> *</a>
<a name="ln188"> * FUNCTION:    AcpiDsGetPredicateValue</a>
<a name="ln189"> *</a>
<a name="ln190"> * PARAMETERS:  WalkState       - Current state of the parse tree walk</a>
<a name="ln191"> *              ResultObj       - if non-zero, pop result from result stack</a>
<a name="ln192"> *</a>
<a name="ln193"> * RETURN:      Status</a>
<a name="ln194"> *</a>
<a name="ln195"> * DESCRIPTION: Get the result of a predicate evaluation</a>
<a name="ln196"> *</a>
<a name="ln197"> ****************************************************************************/</a>
<a name="ln198"> </a>
<a name="ln199">ACPI_STATUS</a>
<a name="ln200">AcpiDsGetPredicateValue (</a>
<a name="ln201">    ACPI_WALK_STATE         *WalkState,</a>
<a name="ln202">    ACPI_OPERAND_OBJECT     *ResultObj)</a>
<a name="ln203">{</a>
<a name="ln204">    ACPI_STATUS             Status = AE_OK;</a>
<a name="ln205">    ACPI_OPERAND_OBJECT     *ObjDesc;</a>
<a name="ln206">    ACPI_OPERAND_OBJECT     *LocalObjDesc = NULL;</a>
<a name="ln207"> </a>
<a name="ln208"> </a>
<a name="ln209">    ACPI_FUNCTION_TRACE_PTR (DsGetPredicateValue, WalkState);</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">    WalkState-&gt;ControlState-&gt;Common.State = 0;</a>
<a name="ln213"> </a>
<a name="ln214">    if (ResultObj)</a>
<a name="ln215">    {</a>
<a name="ln216">        Status = AcpiDsResultPop (&amp;ObjDesc, WalkState);</a>
<a name="ln217">        if (ACPI_FAILURE (Status))</a>
<a name="ln218">        {</a>
<a name="ln219">            ACPI_EXCEPTION ((AE_INFO, Status,</a>
<a name="ln220">                &quot;Could not get result from predicate evaluation&quot;));</a>
<a name="ln221"> </a>
<a name="ln222">            return_ACPI_STATUS (Status);</a>
<a name="ln223">        }</a>
<a name="ln224">    }</a>
<a name="ln225">    else</a>
<a name="ln226">    {</a>
<a name="ln227">        Status = AcpiDsCreateOperand (WalkState, WalkState-&gt;Op, 0);</a>
<a name="ln228">        if (ACPI_FAILURE (Status))</a>
<a name="ln229">        {</a>
<a name="ln230">            return_ACPI_STATUS (Status);</a>
<a name="ln231">        }</a>
<a name="ln232"> </a>
<a name="ln233">        Status = AcpiExResolveToValue (&amp;WalkState-&gt;Operands [0], WalkState);</a>
<a name="ln234">        if (ACPI_FAILURE (Status))</a>
<a name="ln235">        {</a>
<a name="ln236">            return_ACPI_STATUS (Status);</a>
<a name="ln237">        }</a>
<a name="ln238"> </a>
<a name="ln239">        ObjDesc = WalkState-&gt;Operands [0];</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    if (!ObjDesc)</a>
<a name="ln243">    {</a>
<a name="ln244">        ACPI_ERROR ((AE_INFO,</a>
<a name="ln245">            &quot;No predicate ObjDesc=%p State=%p&quot;,</a>
<a name="ln246">            ObjDesc, WalkState));</a>
<a name="ln247"> </a>
<a name="ln248">        return_ACPI_STATUS (AE_AML_NO_OPERAND);</a>
<a name="ln249">    }</a>
<a name="ln250"> </a>
<a name="ln251">    /*</a>
<a name="ln252">     * Result of predicate evaluation must be an Integer</a>
<a name="ln253">     * object. Implicitly convert the argument if necessary.</a>
<a name="ln254">     */</a>
<a name="ln255">    Status = AcpiExConvertToInteger (ObjDesc, &amp;LocalObjDesc,</a>
<a name="ln256">        ACPI_IMPLICIT_CONVERSION);</a>
<a name="ln257">    if (ACPI_FAILURE (Status))</a>
<a name="ln258">    {</a>
<a name="ln259">        goto Cleanup;</a>
<a name="ln260">    }</a>
<a name="ln261"> </a>
<a name="ln262">    if (LocalObjDesc-&gt;Common.Type != ACPI_TYPE_INTEGER)</a>
<a name="ln263">    {</a>
<a name="ln264">        ACPI_ERROR ((AE_INFO,</a>
<a name="ln265">            &quot;Bad predicate (not an integer) ObjDesc=%p State=%p Type=0x%X&quot;,</a>
<a name="ln266">            ObjDesc, WalkState, ObjDesc-&gt;Common.Type));</a>
<a name="ln267"> </a>
<a name="ln268">        Status = AE_AML_OPERAND_TYPE;</a>
<a name="ln269">        goto Cleanup;</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">    /* Truncate the predicate to 32-bits if necessary */</a>
<a name="ln273"> </a>
<a name="ln274">    (void) AcpiExTruncateFor32bitTable (LocalObjDesc);</a>
<a name="ln275"> </a>
<a name="ln276">    /*</a>
<a name="ln277">     * Save the result of the predicate evaluation on</a>
<a name="ln278">     * the control stack</a>
<a name="ln279">     */</a>
<a name="ln280">    if (LocalObjDesc-&gt;Integer.Value)</a>
<a name="ln281">    {</a>
<a name="ln282">        WalkState-&gt;ControlState-&gt;Common.Value = TRUE;</a>
<a name="ln283">    }</a>
<a name="ln284">    else</a>
<a name="ln285">    {</a>
<a name="ln286">        /*</a>
<a name="ln287">         * Predicate is FALSE, we will just toss the</a>
<a name="ln288">         * rest of the package</a>
<a name="ln289">         */</a>
<a name="ln290">        WalkState-&gt;ControlState-&gt;Common.Value = FALSE;</a>
<a name="ln291">        Status = AE_CTRL_FALSE;</a>
<a name="ln292">    }</a>
<a name="ln293"> </a>
<a name="ln294">    /* Predicate can be used for an implicit return value */</a>
<a name="ln295"> </a>
<a name="ln296">    (void) AcpiDsDoImplicitReturn (LocalObjDesc, WalkState, TRUE);</a>
<a name="ln297"> </a>
<a name="ln298"> </a>
<a name="ln299">Cleanup:</a>
<a name="ln300"> </a>
<a name="ln301">    ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,</a>
<a name="ln302">        &quot;Completed a predicate eval=%X Op=%p\n&quot;,</a>
<a name="ln303">        WalkState-&gt;ControlState-&gt;Common.Value, WalkState-&gt;Op));</a>
<a name="ln304"> </a>
<a name="ln305">    /* Break to debugger to display result */</a>
<a name="ln306"> </a>
<a name="ln307">    AcpiDbDisplayResultObject (LocalObjDesc, WalkState);</a>
<a name="ln308"> </a>
<a name="ln309">    /*</a>
<a name="ln310">     * Delete the predicate result object (we know that</a>
<a name="ln311">     * we don't need it anymore)</a>
<a name="ln312">     */</a>
<a name="ln313">    if (LocalObjDesc != ObjDesc)</a>
<a name="ln314">    {</a>
<a name="ln315">        AcpiUtRemoveReference (LocalObjDesc);</a>
<a name="ln316">    }</a>
<a name="ln317">    AcpiUtRemoveReference (ObjDesc);</a>
<a name="ln318"> </a>
<a name="ln319">    WalkState-&gt;ControlState-&gt;Common.State = ACPI_CONTROL_NORMAL;</a>
<a name="ln320">    return_ACPI_STATUS (Status);</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323"> </a>
<a name="ln324">/*****************************************************************************</a>
<a name="ln325"> *</a>
<a name="ln326"> * FUNCTION:    AcpiDsExecBeginOp</a>
<a name="ln327"> *</a>
<a name="ln328"> * PARAMETERS:  WalkState       - Current state of the parse tree walk</a>
<a name="ln329"> *              OutOp           - Where to return op if a new one is created</a>
<a name="ln330"> *</a>
<a name="ln331"> * RETURN:      Status</a>
<a name="ln332"> *</a>
<a name="ln333"> * DESCRIPTION: Descending callback used during the execution of control</a>
<a name="ln334"> *              methods. This is where most operators and operands are</a>
<a name="ln335"> *              dispatched to the interpreter.</a>
<a name="ln336"> *</a>
<a name="ln337"> ****************************************************************************/</a>
<a name="ln338"> </a>
<a name="ln339">ACPI_STATUS</a>
<a name="ln340">AcpiDsExecBeginOp (</a>
<a name="ln341">    ACPI_WALK_STATE         *WalkState,</a>
<a name="ln342">    ACPI_PARSE_OBJECT       **OutOp)</a>
<a name="ln343">{</a>
<a name="ln344">    ACPI_PARSE_OBJECT       *Op;</a>
<a name="ln345">    ACPI_STATUS             Status = AE_OK;</a>
<a name="ln346">    UINT32                  OpcodeClass;</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">    ACPI_FUNCTION_TRACE_PTR (DsExecBeginOp, WalkState);</a>
<a name="ln350"> </a>
<a name="ln351"> </a>
<a name="ln352">    Op = WalkState-&gt;Op;</a>
<a name="ln353">    if (!Op)</a>
<a name="ln354">    {</a>
<a name="ln355">        Status = AcpiDsLoad2BeginOp (WalkState, OutOp);</a>
<a name="ln356">        if (ACPI_FAILURE (Status))</a>
<a name="ln357">        {</a>
<a name="ln358">            goto ErrorExit;</a>
<a name="ln359">        }</a>
<a name="ln360"> </a>
<a name="ln361">        Op = *OutOp;</a>
<a name="ln362">        WalkState-&gt;Op = Op;</a>
<a name="ln363">        WalkState-&gt;Opcode = Op-&gt;Common.AmlOpcode;</a>
<a name="ln364">        WalkState-&gt;OpInfo = AcpiPsGetOpcodeInfo (Op-&gt;Common.AmlOpcode);</a>
<a name="ln365"> </a>
<a name="ln366">        if (AcpiNsOpensScope (WalkState-&gt;OpInfo-&gt;ObjectType))</a>
<a name="ln367">        {</a>
<a name="ln368">            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,</a>
<a name="ln369">                &quot;(%s) Popping scope for Op %p\n&quot;,</a>
<a name="ln370">                AcpiUtGetTypeName (WalkState-&gt;OpInfo-&gt;ObjectType), Op));</a>
<a name="ln371"> </a>
<a name="ln372">            Status = AcpiDsScopeStackPop (WalkState);</a>
<a name="ln373">            if (ACPI_FAILURE (Status))</a>
<a name="ln374">            {</a>
<a name="ln375">                goto ErrorExit;</a>
<a name="ln376">            }</a>
<a name="ln377">        }</a>
<a name="ln378">    }</a>
<a name="ln379"> </a>
<a name="ln380">    if (Op == WalkState-&gt;Origin)</a>
<a name="ln381">    {</a>
<a name="ln382">        if (OutOp)</a>
<a name="ln383">        {</a>
<a name="ln384">            *OutOp = Op;</a>
<a name="ln385">        }</a>
<a name="ln386"> </a>
<a name="ln387">        return_ACPI_STATUS (AE_OK);</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    /*</a>
<a name="ln391">     * If the previous opcode was a conditional, this opcode</a>
<a name="ln392">     * must be the beginning of the associated predicate.</a>
<a name="ln393">     * Save this knowledge in the current scope descriptor</a>
<a name="ln394">     */</a>
<a name="ln395">    if ((WalkState-&gt;ControlState) &amp;&amp;</a>
<a name="ln396">        (WalkState-&gt;ControlState-&gt;Common.State ==</a>
<a name="ln397">            ACPI_CONTROL_CONDITIONAL_EXECUTING))</a>
<a name="ln398">    {</a>
<a name="ln399">        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,</a>
<a name="ln400">            &quot;Exec predicate Op=%p State=%p\n&quot;,</a>
<a name="ln401">            Op, WalkState));</a>
<a name="ln402"> </a>
<a name="ln403">        WalkState-&gt;ControlState-&gt;Common.State =</a>
<a name="ln404">            ACPI_CONTROL_PREDICATE_EXECUTING;</a>
<a name="ln405"> </a>
<a name="ln406">        /* Save start of predicate */</a>
<a name="ln407"> </a>
<a name="ln408">        WalkState-&gt;ControlState-&gt;Control.PredicateOp = Op;</a>
<a name="ln409">    }</a>
<a name="ln410"> </a>
<a name="ln411"> </a>
<a name="ln412">    OpcodeClass = WalkState-&gt;OpInfo-&gt;Class;</a>
<a name="ln413"> </a>
<a name="ln414">    /* We want to send namepaths to the load code */</a>
<a name="ln415"> </a>
<a name="ln416">    if (Op-&gt;Common.AmlOpcode == AML_INT_NAMEPATH_OP)</a>
<a name="ln417">    {</a>
<a name="ln418">        OpcodeClass = AML_CLASS_NAMED_OBJECT;</a>
<a name="ln419">    }</a>
<a name="ln420"> </a>
<a name="ln421">    /*</a>
<a name="ln422">     * Handle the opcode based upon the opcode type</a>
<a name="ln423">     */</a>
<a name="ln424">    switch (OpcodeClass)</a>
<a name="ln425">    {</a>
<a name="ln426">    case AML_CLASS_CONTROL:</a>
<a name="ln427"> </a>
<a name="ln428">        Status = AcpiDsExecBeginControlOp (WalkState, Op);</a>
<a name="ln429">        break;</a>
<a name="ln430"> </a>
<a name="ln431">    case AML_CLASS_NAMED_OBJECT:</a>
<a name="ln432"> </a>
<a name="ln433">        if (WalkState-&gt;WalkType &amp; ACPI_WALK_METHOD)</a>
<a name="ln434">        {</a>
<a name="ln435">            /*</a>
<a name="ln436">             * Found a named object declaration during method execution;</a>
<a name="ln437">             * we must enter this object into the namespace. The created</a>
<a name="ln438">             * object is temporary and will be deleted upon completion of</a>
<a name="ln439">             * the execution of this method.</a>
<a name="ln440">             *</a>
<a name="ln441">             * Note 10/2010: Except for the Scope() op. This opcode does</a>
<a name="ln442">             * not actually create a new object, it refers to an existing</a>
<a name="ln443">             * object. However, for Scope(), we want to indeed open a</a>
<a name="ln444">             * new scope.</a>
<a name="ln445">             */</a>
<a name="ln446">            if (Op-&gt;Common.AmlOpcode != AML_SCOPE_OP)</a>
<a name="ln447">            {</a>
<a name="ln448">                Status = AcpiDsLoad2BeginOp (WalkState, NULL);</a>
<a name="ln449">            }</a>
<a name="ln450">            else</a>
<a name="ln451">            {</a>
<a name="ln452">                Status = AcpiDsScopeStackPush (</a>
<a name="ln453">                    Op-&gt;Named.Node, Op-&gt;Named.Node-&gt;Type, WalkState);</a>
<a name="ln454">                if (ACPI_FAILURE (Status))</a>
<a name="ln455">                {</a>
<a name="ln456">                    return_ACPI_STATUS (Status);</a>
<a name="ln457">                }</a>
<a name="ln458">            }</a>
<a name="ln459">        }</a>
<a name="ln460">        break;</a>
<a name="ln461"> </a>
<a name="ln462">    case AML_CLASS_EXECUTE:</a>
<a name="ln463">    case AML_CLASS_CREATE:</a>
<a name="ln464"> </a>
<a name="ln465">        break;</a>
<a name="ln466"> </a>
<a name="ln467">    default:</a>
<a name="ln468"> </a>
<a name="ln469">        break;</a>
<a name="ln470">    }</a>
<a name="ln471"> </a>
<a name="ln472">    /* Nothing to do here during method execution */</a>
<a name="ln473"> </a>
<a name="ln474">    return_ACPI_STATUS (Status);</a>
<a name="ln475"> </a>
<a name="ln476"> </a>
<a name="ln477">ErrorExit:</a>
<a name="ln478">    Status = AcpiDsMethodError (Status, WalkState);</a>
<a name="ln479">    return_ACPI_STATUS (Status);</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483">/*****************************************************************************</a>
<a name="ln484"> *</a>
<a name="ln485"> * FUNCTION:    AcpiDsExecEndOp</a>
<a name="ln486"> *</a>
<a name="ln487"> * PARAMETERS:  WalkState       - Current state of the parse tree walk</a>
<a name="ln488"> *</a>
<a name="ln489"> * RETURN:      Status</a>
<a name="ln490"> *</a>
<a name="ln491"> * DESCRIPTION: Ascending callback used during the execution of control</a>
<a name="ln492"> *              methods. The only thing we really need to do here is to</a>
<a name="ln493"> *              notice the beginning of IF, ELSE, and WHILE blocks.</a>
<a name="ln494"> *</a>
<a name="ln495"> ****************************************************************************/</a>
<a name="ln496"> </a>
<a name="ln497">ACPI_STATUS</a>
<a name="ln498">AcpiDsExecEndOp (</a>
<a name="ln499">    ACPI_WALK_STATE         *WalkState)</a>
<a name="ln500">{</a>
<a name="ln501">    ACPI_PARSE_OBJECT       *Op;</a>
<a name="ln502">    ACPI_STATUS             Status = AE_OK;</a>
<a name="ln503">    UINT32                  OpType;</a>
<a name="ln504">    UINT32                  OpClass;</a>
<a name="ln505">    ACPI_PARSE_OBJECT       *NextOp;</a>
<a name="ln506">    ACPI_PARSE_OBJECT       *FirstArg;</a>
<a name="ln507"> </a>
<a name="ln508"> </a>
<a name="ln509">    ACPI_FUNCTION_TRACE_PTR (DsExecEndOp, WalkState);</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">    Op = WalkState-&gt;Op;</a>
<a name="ln513">    OpType = WalkState-&gt;OpInfo-&gt;Type;</a>
<a name="ln514">    OpClass = WalkState-&gt;OpInfo-&gt;Class;</a>
<a name="ln515"> </a>
<a name="ln516">    if (OpClass == AML_CLASS_UNKNOWN)</a>
<a name="ln517">    {</a>
<a name="ln518">        ACPI_ERROR ((AE_INFO, &quot;Unknown opcode 0x%X&quot;, Op-&gt;Common.AmlOpcode));</a>
<a name="ln519">        return_ACPI_STATUS (AE_NOT_IMPLEMENTED);</a>
<a name="ln520">    }</a>
<a name="ln521"> </a>
<a name="ln522">    FirstArg = Op-&gt;Common.Value.Arg;</a>
<a name="ln523"> </a>
<a name="ln524">    /* Init the walk state */</a>
<a name="ln525"> </a>
<a name="ln526">    WalkState-&gt;NumOperands = 0;</a>
<a name="ln527">    WalkState-&gt;OperandIndex = 0;</a>
<a name="ln528">    WalkState-&gt;ReturnDesc = NULL;</a>
<a name="ln529">    WalkState-&gt;ResultObj = NULL;</a>
<a name="ln530"> </a>
<a name="ln531">    /* Call debugger for single step support (DEBUG build only) */</a>
<a name="ln532"> </a>
<a name="ln533">    Status = AcpiDbSingleStep (WalkState, Op, OpClass);</a>
<a name="ln534">    if (ACPI_FAILURE (Status))</a>
<a name="ln535">    {</a>
<a name="ln536">        return_ACPI_STATUS (Status);</a>
<a name="ln537">    }</a>
<a name="ln538"> </a>
<a name="ln539">    /* Decode the Opcode Class */</a>
<a name="ln540"> </a>
<a name="ln541">    switch (OpClass)</a>
<a name="ln542">    {</a>
<a name="ln543">    case AML_CLASS_ARGUMENT:    /* Constants, literals, etc. */</a>
<a name="ln544"> </a>
<a name="ln545">        if (WalkState-&gt;Opcode == AML_INT_NAMEPATH_OP)</a>
<a name="ln546">        {</a>
<a name="ln547">            Status = AcpiDsEvaluateNamePath (WalkState);</a>
<a name="ln548">            if (ACPI_FAILURE (Status))</a>
<a name="ln549">            {</a>
<a name="ln550">                goto Cleanup;</a>
<a name="ln551">            }</a>
<a name="ln552">        }</a>
<a name="ln553">        break;</a>
<a name="ln554"> </a>
<a name="ln555">    case AML_CLASS_EXECUTE:     /* Most operators with arguments */</a>
<a name="ln556"> </a>
<a name="ln557">        /* Build resolved operand stack */</a>
<a name="ln558"> </a>
<a name="ln559">        Status = AcpiDsCreateOperands (WalkState, FirstArg);</a>
<a name="ln560">        if (ACPI_FAILURE (Status))</a>
<a name="ln561">        {</a>
<a name="ln562">            goto Cleanup;</a>
<a name="ln563">        }</a>
<a name="ln564"> </a>
<a name="ln565">        /*</a>
<a name="ln566">         * All opcodes require operand resolution, with the only exceptions</a>
<a name="ln567">         * being the ObjectType and SizeOf operators.</a>
<a name="ln568">         */</a>
<a name="ln569">        if (!(WalkState-&gt;OpInfo-&gt;Flags &amp; AML_NO_OPERAND_RESOLVE))</a>
<a name="ln570">        {</a>
<a name="ln571">            /* Resolve all operands */</a>
<a name="ln572"> </a>
<a name="ln573">            Status = AcpiExResolveOperands (WalkState-&gt;Opcode,</a>
<a name="ln574">                &amp;(WalkState-&gt;Operands [WalkState-&gt;NumOperands -1]),</a>
<a name="ln575">                WalkState);</a>
<a name="ln576">        }</a>
<a name="ln577"> </a>
<a name="ln578">        if (ACPI_SUCCESS (Status))</a>
<a name="ln579">        {</a>
<a name="ln580">            /*</a>
<a name="ln581">             * Dispatch the request to the appropriate interpreter handler</a>
<a name="ln582">             * routine. There is one routine per opcode &quot;type&quot; based upon the</a>
<a name="ln583">             * number of opcode arguments and return type.</a>
<a name="ln584">             */</a>
<a name="ln585">            Status = AcpiGbl_OpTypeDispatch[OpType] (WalkState);</a>
<a name="ln586">        }</a>
<a name="ln587">        else</a>
<a name="ln588">        {</a>
<a name="ln589">            /*</a>
<a name="ln590">             * Treat constructs of the form &quot;Store(LocalX,LocalX)&quot; as noops when the</a>
<a name="ln591">             * Local is uninitialized.</a>
<a name="ln592">             */</a>
<a name="ln593">            if  ((Status == AE_AML_UNINITIALIZED_LOCAL) &amp;&amp;</a>
<a name="ln594">                (WalkState-&gt;Opcode == AML_STORE_OP) &amp;&amp;</a>
<a name="ln595">                (WalkState-&gt;Operands[0]-&gt;Common.Type == ACPI_TYPE_LOCAL_REFERENCE) &amp;&amp;</a>
<a name="ln596">                (WalkState-&gt;Operands[1]-&gt;Common.Type == ACPI_TYPE_LOCAL_REFERENCE) &amp;&amp;</a>
<a name="ln597">                (WalkState-&gt;Operands[0]-&gt;Reference.Class ==</a>
<a name="ln598">                 WalkState-&gt;Operands[1]-&gt;Reference.Class) &amp;&amp;</a>
<a name="ln599">                (WalkState-&gt;Operands[0]-&gt;Reference.Value ==</a>
<a name="ln600">                 WalkState-&gt;Operands[1]-&gt;Reference.Value))</a>
<a name="ln601">            {</a>
<a name="ln602">                Status = AE_OK;</a>
<a name="ln603">            }</a>
<a name="ln604">            else</a>
<a name="ln605">            {</a>
<a name="ln606">                ACPI_EXCEPTION ((AE_INFO, Status,</a>
<a name="ln607">                    &quot;While resolving operands for [%s]&quot;,</a>
<a name="ln608">                    AcpiPsGetOpcodeName (WalkState-&gt;Opcode)));</a>
<a name="ln609">            }</a>
<a name="ln610">        }</a>
<a name="ln611"> </a>
<a name="ln612">        /* Always delete the argument objects and clear the operand stack */</a>
<a name="ln613"> </a>
<a name="ln614">        AcpiDsClearOperands (WalkState);</a>
<a name="ln615"> </a>
<a name="ln616">        /*</a>
<a name="ln617">         * If a result object was returned from above, push it on the</a>
<a name="ln618">         * current result stack</a>
<a name="ln619">         */</a>
<a name="ln620">        if (ACPI_SUCCESS (Status) &amp;&amp;</a>
<a name="ln621">            WalkState-&gt;ResultObj)</a>
<a name="ln622">        {</a>
<a name="ln623">            Status = AcpiDsResultPush (WalkState-&gt;ResultObj, WalkState);</a>
<a name="ln624">        }</a>
<a name="ln625">        break;</a>
<a name="ln626"> </a>
<a name="ln627">    default:</a>
<a name="ln628"> </a>
<a name="ln629">        switch (OpType)</a>
<a name="ln630">        {</a>
<a name="ln631">        case AML_TYPE_CONTROL:    /* Type 1 opcode, IF/ELSE/WHILE/NOOP */</a>
<a name="ln632"> </a>
<a name="ln633">            /* 1 Operand, 0 ExternalResult, 0 InternalResult */</a>
<a name="ln634"> </a>
<a name="ln635">            Status = AcpiDsExecEndControlOp (WalkState, Op);</a>
<a name="ln636"> </a>
<a name="ln637">            break;</a>
<a name="ln638"> </a>
<a name="ln639">        case AML_TYPE_METHOD_CALL:</a>
<a name="ln640">            /*</a>
<a name="ln641">             * If the method is referenced from within a package</a>
<a name="ln642">             * declaration, it is not a invocation of the method, just</a>
<a name="ln643">             * a reference to it.</a>
<a name="ln644">             */</a>
<a name="ln645">            if ((Op-&gt;Asl.Parent) &amp;&amp;</a>
<a name="ln646">               ((Op-&gt;Asl.Parent-&gt;Asl.AmlOpcode == AML_PACKAGE_OP) ||</a>
<a name="ln647">                (Op-&gt;Asl.Parent-&gt;Asl.AmlOpcode == AML_VARIABLE_PACKAGE_OP)))</a>
<a name="ln648">            {</a>
<a name="ln649">                ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,</a>
<a name="ln650">                    &quot;Method Reference in a Package, Op=%p\n&quot;, Op));</a>
<a name="ln651"> </a>
<a name="ln652">                Op-&gt;Common.Node = (ACPI_NAMESPACE_NODE *)</a>
<a name="ln653">                    Op-&gt;Asl.Value.Arg-&gt;Asl.Node;</a>
<a name="ln654">                AcpiUtAddReference (Op-&gt;Asl.Value.Arg-&gt;Asl.Node-&gt;Object);</a>
<a name="ln655">                return_ACPI_STATUS (AE_OK);</a>
<a name="ln656">            }</a>
<a name="ln657"> </a>
<a name="ln658">            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,</a>
<a name="ln659">                &quot;Method invocation, Op=%p\n&quot;, Op));</a>
<a name="ln660"> </a>
<a name="ln661">            /*</a>
<a name="ln662">             * (AML_METHODCALL) Op-&gt;Asl.Value.Arg-&gt;Asl.Node contains</a>
<a name="ln663">             * the method Node pointer</a>
<a name="ln664">             */</a>
<a name="ln665">            /* NextOp points to the op that holds the method name */</a>
<a name="ln666"> </a>
<a name="ln667">            NextOp = FirstArg;</a>
<a name="ln668"> </a>
<a name="ln669">            /* NextOp points to first argument op */</a>
<a name="ln670"> </a>
<a name="ln671">            NextOp = NextOp-&gt;Common.Next;</a>
<a name="ln672"> </a>
<a name="ln673">            /*</a>
<a name="ln674">             * Get the method's arguments and put them on the operand stack</a>
<a name="ln675">             */</a>
<a name="ln676">            Status = AcpiDsCreateOperands (WalkState, NextOp);</a>
<a name="ln677">            if (ACPI_FAILURE (Status))</a>
<a name="ln678">            {</a>
<a name="ln679">                break;</a>
<a name="ln680">            }</a>
<a name="ln681"> </a>
<a name="ln682">            /*</a>
<a name="ln683">             * Since the operands will be passed to another control method,</a>
<a name="ln684">             * we must resolve all local references here (Local variables,</a>
<a name="ln685">             * arguments to *this* method, etc.)</a>
<a name="ln686">             */</a>
<a name="ln687">            Status = AcpiDsResolveOperands (WalkState);</a>
<a name="ln688">            if (ACPI_FAILURE (Status))</a>
<a name="ln689">            {</a>
<a name="ln690">                /* On error, clear all resolved operands */</a>
<a name="ln691"> </a>
<a name="ln692">                AcpiDsClearOperands (WalkState);</a>
<a name="ln693">                break;</a>
<a name="ln694">            }</a>
<a name="ln695"> </a>
<a name="ln696">            /*</a>
<a name="ln697">             * Tell the walk loop to preempt this running method and</a>
<a name="ln698">             * execute the new method</a>
<a name="ln699">             */</a>
<a name="ln700">            Status = AE_CTRL_TRANSFER;</a>
<a name="ln701"> </a>
<a name="ln702">            /*</a>
<a name="ln703">             * Return now; we don't want to disturb anything,</a>
<a name="ln704">             * especially the operand count!</a>
<a name="ln705">             */</a>
<a name="ln706">            return_ACPI_STATUS (Status);</a>
<a name="ln707"> </a>
<a name="ln708">        case AML_TYPE_CREATE_FIELD:</a>
<a name="ln709"> </a>
<a name="ln710">            ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,</a>
<a name="ln711">                &quot;Executing CreateField Buffer/Index Op=%p\n&quot;, Op));</a>
<a name="ln712"> </a>
<a name="ln713">            Status = AcpiDsLoad2EndOp (WalkState);</a>
<a name="ln714">            if (ACPI_FAILURE (Status))</a>
<a name="ln715">            {</a>
<a name="ln716">                break;</a>
<a name="ln717">            }</a>
<a name="ln718"> </a>
<a name="ln719">            Status = AcpiDsEvalBufferFieldOperands (WalkState, Op);</a>
<a name="ln720">            break;</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">        case AML_TYPE_CREATE_OBJECT:</a>
<a name="ln724"> </a>
<a name="ln725">            ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,</a>
<a name="ln726">                &quot;Executing CreateObject (Buffer/Package) Op=%p Child=%p ParentOpcode=%4.4X\n&quot;,</a>
<a name="ln727">                Op, Op-&gt;Named.Value.Arg, Op-&gt;Common.Parent-&gt;Common.AmlOpcode));</a>
<a name="ln728"> </a>
<a name="ln729">            switch (Op-&gt;Common.Parent-&gt;Common.AmlOpcode)</a>
<a name="ln730">            {</a>
<a name="ln731">            case AML_NAME_OP:</a>
<a name="ln732">                /*</a>
<a name="ln733">                 * Put the Node on the object stack (Contains the ACPI Name</a>
<a name="ln734">                 * of this object)</a>
<a name="ln735">                 */</a>
<a name="ln736">                WalkState-&gt;Operands[0] = (void *)</a>
<a name="ln737">                    Op-&gt;Common.Parent-&gt;Common.Node;</a>
<a name="ln738">                WalkState-&gt;NumOperands = 1;</a>
<a name="ln739"> </a>
<a name="ln740">                Status = AcpiDsCreateNode (WalkState,</a>
<a name="ln741">                    Op-&gt;Common.Parent-&gt;Common.Node, Op-&gt;Common.Parent);</a>
<a name="ln742">                if (ACPI_FAILURE (Status))</a>
<a name="ln743">                {</a>
<a name="ln744">                    break;</a>
<a name="ln745">                }</a>
<a name="ln746"> </a>
<a name="ln747">                /* Fall through */</a>
<a name="ln748">                /*lint -fallthrough */</a>
<a name="ln749"> </a>
<a name="ln750">            case AML_INT_EVAL_SUBTREE_OP:</a>
<a name="ln751"> </a>
<a name="ln752">                Status = AcpiDsEvalDataObjectOperands (WalkState, Op,</a>
<a name="ln753">                    AcpiNsGetAttachedObject (Op-&gt;Common.Parent-&gt;Common.Node));</a>
<a name="ln754">                break;</a>
<a name="ln755"> </a>
<a name="ln756">            default:</a>
<a name="ln757"> </a>
<a name="ln758">                Status = AcpiDsEvalDataObjectOperands (WalkState, Op, NULL);</a>
<a name="ln759">                break;</a>
<a name="ln760">            }</a>
<a name="ln761"> </a>
<a name="ln762">            /*</a>
<a name="ln763">             * If a result object was returned from above, push it on the</a>
<a name="ln764">             * current result stack</a>
<a name="ln765">             */</a>
<a name="ln766">            if (WalkState-&gt;ResultObj)</a>
<a name="ln767">            {</a>
<a name="ln768">                Status = AcpiDsResultPush (WalkState-&gt;ResultObj, WalkState);</a>
<a name="ln769">            }</a>
<a name="ln770">            break;</a>
<a name="ln771"> </a>
<a name="ln772">        case AML_TYPE_NAMED_FIELD:</a>
<a name="ln773">        case AML_TYPE_NAMED_COMPLEX:</a>
<a name="ln774">        case AML_TYPE_NAMED_SIMPLE:</a>
<a name="ln775">        case AML_TYPE_NAMED_NO_OBJ:</a>
<a name="ln776"> </a>
<a name="ln777">            Status = AcpiDsLoad2EndOp (WalkState);</a>
<a name="ln778">            if (ACPI_FAILURE (Status))</a>
<a name="ln779">            {</a>
<a name="ln780">                break;</a>
<a name="ln781">            }</a>
<a name="ln782"> </a>
<a name="ln783">            if (Op-&gt;Common.AmlOpcode == AML_REGION_OP)</a>
<a name="ln784">            {</a>
<a name="ln785">                ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,</a>
<a name="ln786">                    &quot;Executing OpRegion Address/Length Op=%p\n&quot;, Op));</a>
<a name="ln787"> </a>
<a name="ln788">                Status = AcpiDsEvalRegionOperands (WalkState, Op);</a>
<a name="ln789">                if (ACPI_FAILURE (Status))</a>
<a name="ln790">                {</a>
<a name="ln791">                    break;</a>
<a name="ln792">                }</a>
<a name="ln793">            }</a>
<a name="ln794">            else if (Op-&gt;Common.AmlOpcode == AML_DATA_REGION_OP)</a>
<a name="ln795">            {</a>
<a name="ln796">                ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,</a>
<a name="ln797">                    &quot;Executing DataTableRegion Strings Op=%p\n&quot;, Op));</a>
<a name="ln798"> </a>
<a name="ln799">                Status = AcpiDsEvalTableRegionOperands (WalkState, Op);</a>
<a name="ln800">                if (ACPI_FAILURE (Status))</a>
<a name="ln801">                {</a>
<a name="ln802">                    break;</a>
<a name="ln803">                }</a>
<a name="ln804">            }</a>
<a name="ln805">            else if (Op-&gt;Common.AmlOpcode == AML_BANK_FIELD_OP)</a>
<a name="ln806">            {</a>
<a name="ln807">                ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,</a>
<a name="ln808">                    &quot;Executing BankField Op=%p\n&quot;, Op));</a>
<a name="ln809"> </a>
<a name="ln810">                Status = AcpiDsEvalBankFieldOperands (WalkState, Op);</a>
<a name="ln811">                if (ACPI_FAILURE (Status))</a>
<a name="ln812">                {</a>
<a name="ln813">                    break;</a>
<a name="ln814">                }</a>
<a name="ln815">            }</a>
<a name="ln816">            break;</a>
<a name="ln817"> </a>
<a name="ln818">        case AML_TYPE_UNDEFINED:</a>
<a name="ln819"> </a>
<a name="ln820">            ACPI_ERROR ((AE_INFO,</a>
<a name="ln821">                &quot;Undefined opcode type Op=%p&quot;, Op));</a>
<a name="ln822">            return_ACPI_STATUS (AE_NOT_IMPLEMENTED);</a>
<a name="ln823"> </a>
<a name="ln824">        case AML_TYPE_BOGUS:</a>
<a name="ln825"> </a>
<a name="ln826">            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,</a>
<a name="ln827">                &quot;Internal opcode=%X type Op=%p\n&quot;,</a>
<a name="ln828">                WalkState-&gt;Opcode, Op));</a>
<a name="ln829">            break;</a>
<a name="ln830"> </a>
<a name="ln831">        default:</a>
<a name="ln832"> </a>
<a name="ln833">            ACPI_ERROR ((AE_INFO,</a>
<a name="ln834">                &quot;Unimplemented opcode, class=0x%X &quot;</a>
<a name="ln835">                &quot;type=0x%X Opcode=0x%X Op=%p&quot;,</a>
<a name="ln836">                OpClass, OpType, Op-&gt;Common.AmlOpcode, Op));</a>
<a name="ln837"> </a>
<a name="ln838">            Status = AE_NOT_IMPLEMENTED;</a>
<a name="ln839">            break;</a>
<a name="ln840">        }</a>
<a name="ln841">    }</a>
<a name="ln842"> </a>
<a name="ln843">    /*</a>
<a name="ln844">     * ACPI 2.0 support for 64-bit integers: Truncate numeric</a>
<a name="ln845">     * result value if we are executing from a 32-bit ACPI table</a>
<a name="ln846">     */</a>
<a name="ln847">    (void) AcpiExTruncateFor32bitTable (WalkState-&gt;ResultObj);</a>
<a name="ln848"> </a>
<a name="ln849">    /*</a>
<a name="ln850">     * Check if we just completed the evaluation of a</a>
<a name="ln851">     * conditional predicate</a>
<a name="ln852">     */</a>
<a name="ln853">    if ((ACPI_SUCCESS (Status)) &amp;&amp;</a>
<a name="ln854">        (WalkState-&gt;ControlState) &amp;&amp;</a>
<a name="ln855">        (WalkState-&gt;ControlState-&gt;Common.State ==</a>
<a name="ln856">            ACPI_CONTROL_PREDICATE_EXECUTING) &amp;&amp;</a>
<a name="ln857">        (WalkState-&gt;ControlState-&gt;Control.PredicateOp == Op))</a>
<a name="ln858">    {</a>
<a name="ln859">        Status = AcpiDsGetPredicateValue (WalkState, WalkState-&gt;ResultObj);</a>
<a name="ln860">        WalkState-&gt;ResultObj = NULL;</a>
<a name="ln861">    }</a>
<a name="ln862"> </a>
<a name="ln863"> </a>
<a name="ln864">Cleanup:</a>
<a name="ln865"> </a>
<a name="ln866">    if (WalkState-&gt;ResultObj)</a>
<a name="ln867">    {</a>
<a name="ln868">        /* Break to debugger to display result */</a>
<a name="ln869"> </a>
<a name="ln870">        AcpiDbDisplayResultObject (WalkState-&gt;ResultObj,WalkState);</a>
<a name="ln871"> </a>
<a name="ln872">        /*</a>
<a name="ln873">         * Delete the result op if and only if:</a>
<a name="ln874">         * Parent will not use the result -- such as any</a>
<a name="ln875">         * non-nested type2 op in a method (parent will be method)</a>
<a name="ln876">         */</a>
<a name="ln877">        AcpiDsDeleteResultIfNotUsed (Op, WalkState-&gt;ResultObj, WalkState);</a>
<a name="ln878">    }</a>
<a name="ln879"> </a>
<a name="ln880">#ifdef _UNDER_DEVELOPMENT</a>
<a name="ln881"> </a>
<a name="ln882">    if (WalkState-&gt;ParserState.Aml == WalkState-&gt;ParserState.AmlEnd)</a>
<a name="ln883">    {</a>
<a name="ln884">        AcpiDbMethodEnd (WalkState);</a>
<a name="ln885">    }</a>
<a name="ln886">#endif</a>
<a name="ln887"> </a>
<a name="ln888">    /* Invoke exception handler on error */</a>
<a name="ln889"> </a>
<a name="ln890">    if (ACPI_FAILURE (Status))</a>
<a name="ln891">    {</a>
<a name="ln892">        Status = AcpiDsMethodError (Status, WalkState);</a>
<a name="ln893">    }</a>
<a name="ln894"> </a>
<a name="ln895">    /* Always clear the object stack */</a>
<a name="ln896"> </a>
<a name="ln897">    WalkState-&gt;NumOperands = 0;</a>
<a name="ln898">    return_ACPI_STATUS (Status);</a>
<a name="ln899">}</a>

</code></pre>
<div class="balloon" rel="361"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'OutOp' pointer was utilized before it was verified against nullptr. Check lines: 361, 382.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
