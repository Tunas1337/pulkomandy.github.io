
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Device.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2003-2014, Haiku Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Michael Lotz &lt;mmlr@mlotz.ch&gt;</a>
<a name="ln7"> *		Niels S. Reedijk</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;usb_private.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">Device::Device(Object* parent, int8 hubAddress, uint8 hubPort,</a>
<a name="ln15">	usb_device_descriptor&amp; desc, int8 deviceAddress, usb_speed speed,</a>
<a name="ln16">	bool isRootHub, void* controllerCookie)</a>
<a name="ln17">	:</a>
<a name="ln18">	Object(parent),</a>
<a name="ln19">	fDeviceDescriptor(desc),</a>
<a name="ln20">	fInitOK(false),</a>
<a name="ln21">	fAvailable(true),</a>
<a name="ln22">	fIsRootHub(isRootHub),</a>
<a name="ln23">	fConfigurations(NULL),</a>
<a name="ln24">	fCurrentConfiguration(NULL),</a>
<a name="ln25">	fSpeed(speed),</a>
<a name="ln26">	fDeviceAddress(deviceAddress),</a>
<a name="ln27">	fHubAddress(hubAddress),</a>
<a name="ln28">	fHubPort(hubPort),</a>
<a name="ln29">	fControllerCookie(controllerCookie)</a>
<a name="ln30">{</a>
<a name="ln31">	TRACE(&quot;creating device\n&quot;);</a>
<a name="ln32"> </a>
<a name="ln33">	fDefaultPipe = new(std::nothrow) ControlPipe(this);</a>
<a name="ln34">	if (fDefaultPipe == NULL) {</a>
<a name="ln35">		TRACE_ERROR(&quot;could not allocate default pipe\n&quot;);</a>
<a name="ln36">		return;</a>
<a name="ln37">	}</a>
<a name="ln38"> </a>
<a name="ln39">	fDefaultPipe-&gt;InitCommon(fDeviceAddress, 0, fSpeed, Pipe::Default,</a>
<a name="ln40">		fDeviceDescriptor.max_packet_size_0, 0, fHubAddress, fHubPort);</a>
<a name="ln41"> </a>
<a name="ln42">	// Get the device descriptor</a>
<a name="ln43">	// We already have a part of it, but we want it all</a>
<a name="ln44">	size_t actualLength;</a>
<a name="ln45">	status_t status = GetDescriptor(USB_DESCRIPTOR_DEVICE, 0, 0,</a>
<a name="ln46">		(void*)&amp;fDeviceDescriptor, sizeof(fDeviceDescriptor), &amp;actualLength);</a>
<a name="ln47"> </a>
<a name="ln48">	if (status &lt; B_OK || actualLength != sizeof(fDeviceDescriptor)) {</a>
<a name="ln49">		TRACE_ERROR(&quot;error while getting the device descriptor\n&quot;);</a>
<a name="ln50">		return;</a>
<a name="ln51">	}</a>
<a name="ln52"> </a>
<a name="ln53">	TRACE(&quot;full device descriptor for device %d:\n&quot;, fDeviceAddress);</a>
<a name="ln54">	TRACE(&quot;\tlength:..............%d\n&quot;, fDeviceDescriptor.length);</a>
<a name="ln55">	TRACE(&quot;\tdescriptor_type:.....0x%04x\n&quot;, fDeviceDescriptor.descriptor_type);</a>
<a name="ln56">	TRACE(&quot;\tusb_version:.........0x%04x\n&quot;, fDeviceDescriptor.usb_version);</a>
<a name="ln57">	TRACE(&quot;\tdevice_class:........0x%02x\n&quot;, fDeviceDescriptor.device_class);</a>
<a name="ln58">	TRACE(&quot;\tdevice_subclass:.....0x%02x\n&quot;, fDeviceDescriptor.device_subclass);</a>
<a name="ln59">	TRACE(&quot;\tdevice_protocol:.....0x%02x\n&quot;, fDeviceDescriptor.device_protocol);</a>
<a name="ln60">	TRACE(&quot;\tmax_packet_size_0:...%d\n&quot;, fDeviceDescriptor.max_packet_size_0);</a>
<a name="ln61">	TRACE(&quot;\tvendor_id:...........0x%04x\n&quot;, fDeviceDescriptor.vendor_id);</a>
<a name="ln62">	TRACE(&quot;\tproduct_id:..........0x%04x\n&quot;, fDeviceDescriptor.product_id);</a>
<a name="ln63">	TRACE(&quot;\tdevice_version:......0x%04x\n&quot;, fDeviceDescriptor.device_version);</a>
<a name="ln64">	TRACE(&quot;\tmanufacturer:........0x%02x\n&quot;, fDeviceDescriptor.manufacturer);</a>
<a name="ln65">	TRACE(&quot;\tproduct:.............0x%02x\n&quot;, fDeviceDescriptor.product);</a>
<a name="ln66">	TRACE(&quot;\tserial_number:.......0x%02x\n&quot;, fDeviceDescriptor.serial_number);</a>
<a name="ln67">	TRACE(&quot;\tnum_configurations:..%d\n&quot;, fDeviceDescriptor.num_configurations);</a>
<a name="ln68"> </a>
<a name="ln69">	// Get the configurations</a>
<a name="ln70">	fConfigurations = (usb_configuration_info*)malloc(</a>
<a name="ln71">		fDeviceDescriptor.num_configurations * sizeof(usb_configuration_info));</a>
<a name="ln72">	if (fConfigurations == NULL) {</a>
<a name="ln73">		TRACE_ERROR(&quot;out of memory during config creations!\n&quot;);</a>
<a name="ln74">		return;</a>
<a name="ln75">	}</a>
<a name="ln76"> </a>
<a name="ln77">	memset(fConfigurations, 0, fDeviceDescriptor.num_configurations</a>
<a name="ln78">		* sizeof(usb_configuration_info));</a>
<a name="ln79">	for (int32 i = 0; i &lt; fDeviceDescriptor.num_configurations; i++) {</a>
<a name="ln80">		usb_configuration_descriptor configDescriptor;</a>
<a name="ln81">		status = GetDescriptor(USB_DESCRIPTOR_CONFIGURATION, i, 0,</a>
<a name="ln82">			(void*)&amp;configDescriptor, sizeof(usb_configuration_descriptor),</a>
<a name="ln83">			&amp;actualLength);</a>
<a name="ln84"> </a>
<a name="ln85">		if (status &lt; B_OK</a>
<a name="ln86">			|| actualLength != sizeof(usb_configuration_descriptor)) {</a>
<a name="ln87">			TRACE_ERROR(&quot;error fetching configuration %&quot; B_PRId32 &quot;\n&quot;, i);</a>
<a name="ln88">			return;</a>
<a name="ln89">		}</a>
<a name="ln90"> </a>
<a name="ln91">		TRACE(&quot;configuration %&quot; B_PRId32 &quot;\n&quot;, i);</a>
<a name="ln92">		TRACE(&quot;\tlength:..............%d\n&quot;, configDescriptor.length);</a>
<a name="ln93">		TRACE(&quot;\tdescriptor_type:.....0x%02x\n&quot;,</a>
<a name="ln94">			configDescriptor.descriptor_type);</a>
<a name="ln95">		TRACE(&quot;\ttotal_length:........%d\n&quot;, configDescriptor.total_length);</a>
<a name="ln96">		TRACE(&quot;\tnumber_interfaces:...%d\n&quot;,</a>
<a name="ln97">			configDescriptor.number_interfaces);</a>
<a name="ln98">		TRACE(&quot;\tconfiguration_value:.0x%02x\n&quot;,</a>
<a name="ln99">			configDescriptor.configuration_value);</a>
<a name="ln100">		TRACE(&quot;\tconfiguration:.......0x%02x\n&quot;,</a>
<a name="ln101">			configDescriptor.configuration);</a>
<a name="ln102">		TRACE(&quot;\tattributes:..........0x%02x\n&quot;, configDescriptor.attributes);</a>
<a name="ln103">		TRACE(&quot;\tmax_power:...........%d\n&quot;, configDescriptor.max_power);</a>
<a name="ln104"> </a>
<a name="ln105">		uint8* configData = (uint8*)malloc(configDescriptor.total_length);</a>
<a name="ln106">		if (configData == NULL) {</a>
<a name="ln107">			TRACE_ERROR(&quot;out of memory when reading config\n&quot;);</a>
<a name="ln108">			return;</a>
<a name="ln109">		}</a>
<a name="ln110"> </a>
<a name="ln111">		status = GetDescriptor(USB_DESCRIPTOR_CONFIGURATION, i, 0,</a>
<a name="ln112">			(void*)configData, configDescriptor.total_length, &amp;actualLength);</a>
<a name="ln113"> </a>
<a name="ln114">		if (status &lt; B_OK || actualLength != configDescriptor.total_length) {</a>
<a name="ln115">			TRACE_ERROR(&quot;error fetching full configuration&quot;</a>
<a name="ln116">				&quot; descriptor %&quot; B_PRId32 &quot; got %&quot; B_PRIuSIZE &quot; expected %&quot;</a>
<a name="ln117">				B_PRIu16 &quot;\n&quot;, i, actualLength, configDescriptor.total_length);</a>
<a name="ln118">			free(configData);</a>
<a name="ln119">			return;</a>
<a name="ln120">		}</a>
<a name="ln121"> </a>
<a name="ln122">		usb_configuration_descriptor* configuration</a>
<a name="ln123">			= (usb_configuration_descriptor*)configData;</a>
<a name="ln124">		fConfigurations[i].descr = configuration;</a>
<a name="ln125">		fConfigurations[i].interface_count = configuration-&gt;number_interfaces;</a>
<a name="ln126">		fConfigurations[i].interface = (usb_interface_list*)malloc(</a>
<a name="ln127">			configuration-&gt;number_interfaces * sizeof(usb_interface_list));</a>
<a name="ln128">		if (fConfigurations[i].interface == NULL) {</a>
<a name="ln129">			TRACE_ERROR(&quot;out of memory when creating interfaces\n&quot;);</a>
<a name="ln130">			return;</a>
<a name="ln131">		}</a>
<a name="ln132"> </a>
<a name="ln133">		memset(fConfigurations[i].interface, 0,</a>
<a name="ln134">			configuration-&gt;number_interfaces * sizeof(usb_interface_list));</a>
<a name="ln135"> </a>
<a name="ln136">		usb_interface_info* currentInterface = NULL;</a>
<a name="ln137">		uint32 descriptorStart = sizeof(usb_configuration_descriptor);</a>
<a name="ln138">		while (descriptorStart &lt; actualLength) {</a>
<a name="ln139">			switch (configData[descriptorStart + 1]) {</a>
<a name="ln140">				case USB_DESCRIPTOR_INTERFACE:</a>
<a name="ln141">				{</a>
<a name="ln142">					TRACE(&quot;got interface descriptor\n&quot;);</a>
<a name="ln143">					usb_interface_descriptor* interfaceDescriptor</a>
<a name="ln144">						= (usb_interface_descriptor*)&amp;configData[</a>
<a name="ln145">							descriptorStart];</a>
<a name="ln146">					TRACE(&quot;\tlength:.............%d\n&quot;,</a>
<a name="ln147">						interfaceDescriptor-&gt;length);</a>
<a name="ln148">					TRACE(&quot;\tdescriptor_type:....0x%02x\n&quot;,</a>
<a name="ln149">						interfaceDescriptor-&gt;descriptor_type);</a>
<a name="ln150">					TRACE(&quot;\tinterface_number:...%d\n&quot;,</a>
<a name="ln151">						interfaceDescriptor-&gt;interface_number);</a>
<a name="ln152">					TRACE(&quot;\talternate_setting:..%d\n&quot;,</a>
<a name="ln153">						interfaceDescriptor-&gt;alternate_setting);</a>
<a name="ln154">					TRACE(&quot;\tnum_endpoints:......%d\n&quot;,</a>
<a name="ln155">						interfaceDescriptor-&gt;num_endpoints);</a>
<a name="ln156">					TRACE(&quot;\tinterface_class:....0x%02x\n&quot;,</a>
<a name="ln157">						interfaceDescriptor-&gt;interface_class);</a>
<a name="ln158">					TRACE(&quot;\tinterface_subclass:.0x%02x\n&quot;,</a>
<a name="ln159">						interfaceDescriptor-&gt;interface_subclass);</a>
<a name="ln160">					TRACE(&quot;\tinterface_protocol:.0x%02x\n&quot;,</a>
<a name="ln161">						interfaceDescriptor-&gt;interface_protocol);</a>
<a name="ln162">					TRACE(&quot;\tinterface:..........%d\n&quot;,</a>
<a name="ln163">						interfaceDescriptor-&gt;interface);</a>
<a name="ln164"> </a>
<a name="ln165">					if (interfaceDescriptor-&gt;interface_number</a>
<a name="ln166">							&gt;= fConfigurations[i].interface_count) {</a>
<a name="ln167">						interfaceDescriptor-&gt;interface_number</a>
<a name="ln168">							= fConfigurations[i].interface_count - 1;</a>
<a name="ln169">						TRACE_ERROR(&quot;Corrected invalid interface_number!\n&quot;);</a>
<a name="ln170">					}</a>
<a name="ln171"> </a>
<a name="ln172">					usb_interface_list* interfaceList = &amp;fConfigurations[i]</a>
<a name="ln173">						.interface[interfaceDescriptor-&gt;interface_number];</a>
<a name="ln174"> </a>
<a name="ln175">					// Allocate this alternate</a>
<a name="ln176">					interfaceList-&gt;alt_count++;</a>
<a name="ln177">					usb_interface_info* newAlternates</a>
<a name="ln178">						= (usb_interface_info*)realloc(interfaceList-&gt;alt,</a>
<a name="ln179">						interfaceList-&gt;alt_count * sizeof(usb_interface_info));</a>
<a name="ln180">					if (newAlternates == NULL) {</a>
<a name="ln181">						TRACE_ERROR(&quot;out of memory allocating&quot;</a>
<a name="ln182">							&quot; alternate interface\n&quot;);</a>
<a name="ln183">						interfaceList-&gt;alt_count--;</a>
<a name="ln184">						return;</a>
<a name="ln185">					}</a>
<a name="ln186"> </a>
<a name="ln187">					interfaceList-&gt;alt = newAlternates;</a>
<a name="ln188"> </a>
<a name="ln189">					// Set active interface always to the first one</a>
<a name="ln190">					interfaceList-&gt;active = interfaceList-&gt;alt;</a>
<a name="ln191"> </a>
<a name="ln192">					// Setup this alternate</a>
<a name="ln193">					usb_interface_info* interfaceInfo</a>
<a name="ln194">						= &amp;interfaceList-&gt;alt[interfaceList-&gt;alt_count - 1];</a>
<a name="ln195">					interfaceInfo-&gt;descr = interfaceDescriptor;</a>
<a name="ln196">					interfaceInfo-&gt;endpoint_count = 0;</a>
<a name="ln197">					interfaceInfo-&gt;endpoint = NULL;</a>
<a name="ln198">					interfaceInfo-&gt;generic_count = 0;</a>
<a name="ln199">					interfaceInfo-&gt;generic = NULL;</a>
<a name="ln200"> </a>
<a name="ln201">					Interface* interface = new(std::nothrow) Interface(this,</a>
<a name="ln202">						interfaceDescriptor-&gt;interface_number);</a>
<a name="ln203">					if (interface == NULL) {</a>
<a name="ln204">						TRACE_ERROR(&quot;failed to allocate&quot;</a>
<a name="ln205">							&quot; interface object\n&quot;);</a>
<a name="ln206">						return;</a>
<a name="ln207">					}</a>
<a name="ln208"> </a>
<a name="ln209">					interfaceInfo-&gt;handle = interface-&gt;USBID();</a>
<a name="ln210">					currentInterface = interfaceInfo;</a>
<a name="ln211">					break;</a>
<a name="ln212">				}</a>
<a name="ln213"> </a>
<a name="ln214">				case USB_DESCRIPTOR_ENDPOINT:</a>
<a name="ln215">				{</a>
<a name="ln216">					TRACE(&quot;got endpoint descriptor\n&quot;);</a>
<a name="ln217">					usb_endpoint_descriptor* endpointDescriptor</a>
<a name="ln218">						= (usb_endpoint_descriptor*)&amp;configData[descriptorStart];</a>
<a name="ln219">					TRACE(&quot;\tlength:.............%d\n&quot;,</a>
<a name="ln220">						endpointDescriptor-&gt;length);</a>
<a name="ln221">					TRACE(&quot;\tdescriptor_type:....0x%02x\n&quot;,</a>
<a name="ln222">						endpointDescriptor-&gt;descriptor_type);</a>
<a name="ln223">					TRACE(&quot;\tendpoint_address:...0x%02x\n&quot;,</a>
<a name="ln224">						endpointDescriptor-&gt;endpoint_address);</a>
<a name="ln225">					TRACE(&quot;\tattributes:.........0x%02x\n&quot;,</a>
<a name="ln226">						endpointDescriptor-&gt;attributes);</a>
<a name="ln227">					TRACE(&quot;\tmax_packet_size:....%d\n&quot;,</a>
<a name="ln228">						endpointDescriptor-&gt;max_packet_size);</a>
<a name="ln229">					TRACE(&quot;\tinterval:...........%d\n&quot;,</a>
<a name="ln230">						endpointDescriptor-&gt;interval);</a>
<a name="ln231"> </a>
<a name="ln232">					if (currentInterface == NULL)</a>
<a name="ln233">						break;</a>
<a name="ln234"> </a>
<a name="ln235">					// Allocate this endpoint</a>
<a name="ln236">					currentInterface-&gt;endpoint_count++;</a>
<a name="ln237">					usb_endpoint_info* newEndpoints = (usb_endpoint_info*)</a>
<a name="ln238">						realloc(currentInterface-&gt;endpoint,</a>
<a name="ln239">							currentInterface-&gt;endpoint_count</a>
<a name="ln240">								* sizeof(usb_endpoint_info));</a>
<a name="ln241">					if (newEndpoints == NULL) {</a>
<a name="ln242">						TRACE_ERROR(&quot;out of memory allocating new endpoint\n&quot;);</a>
<a name="ln243">						currentInterface-&gt;endpoint_count--;</a>
<a name="ln244">						return;</a>
<a name="ln245">					}</a>
<a name="ln246"> </a>
<a name="ln247">					currentInterface-&gt;endpoint = newEndpoints;</a>
<a name="ln248"> </a>
<a name="ln249">					// Setup this endpoint</a>
<a name="ln250">					usb_endpoint_info* endpointInfo = &amp;currentInterface</a>
<a name="ln251">						-&gt;endpoint[currentInterface-&gt;endpoint_count - 1];</a>
<a name="ln252">					endpointInfo-&gt;descr = endpointDescriptor;</a>
<a name="ln253">					endpointInfo-&gt;handle = 0;</a>
<a name="ln254">					break;</a>
<a name="ln255">				}</a>
<a name="ln256"> </a>
<a name="ln257">				case USB_DESCRIPTOR_ENDPOINT_COMPANION: {</a>
<a name="ln258">					usb_endpoint_descriptor* desc = currentInterface</a>
<a name="ln259">						-&gt;endpoint[currentInterface-&gt;endpoint_count - 1].descr;</a>
<a name="ln260">					if ((uint8*)desc != (&amp;configData[descriptorStart</a>
<a name="ln261">							- desc-&gt;length])) {</a>
<a name="ln262">						TRACE_ERROR(&quot;found endpoint companion descriptor not immediately &quot;</a>
<a name="ln263">							&quot;following endpoint descriptor, ignoring!\n&quot;);</a>
<a name="ln264">						break;</a>
<a name="ln265">					}</a>
<a name="ln266">					// TODO: It'd be nicer if we could store the endpoint companion</a>
<a name="ln267">					// descriptor along with the endpoint descriptor, but as the</a>
<a name="ln268">					// interface struct is public API, that would be an ABI break.</a>
<a name="ln269"> </a>
<a name="ln270">					// fall through</a>
<a name="ln271">				}</a>
<a name="ln272"> </a>
<a name="ln273">				default:</a>
<a name="ln274">					TRACE(&quot;got generic descriptor\n&quot;);</a>
<a name="ln275">					usb_generic_descriptor* genericDescriptor</a>
<a name="ln276">						= (usb_generic_descriptor*)&amp;configData[descriptorStart];</a>
<a name="ln277">					TRACE(&quot;\tlength:.............%d\n&quot;,</a>
<a name="ln278">						genericDescriptor-&gt;length);</a>
<a name="ln279">					TRACE(&quot;\tdescriptor_type:....0x%02x\n&quot;,</a>
<a name="ln280">						genericDescriptor-&gt;descriptor_type);</a>
<a name="ln281"> </a>
<a name="ln282">					if (currentInterface == NULL)</a>
<a name="ln283">						break;</a>
<a name="ln284"> </a>
<a name="ln285">					// Allocate this descriptor</a>
<a name="ln286">					currentInterface-&gt;generic_count++;</a>
<a name="ln287">					usb_descriptor** newGenerics = (usb_descriptor**)realloc(</a>
<a name="ln288">						currentInterface-&gt;generic,</a>
<a name="ln289">						currentInterface-&gt;generic_count</a>
<a name="ln290">							* sizeof(usb_descriptor*));</a>
<a name="ln291">					if (newGenerics == NULL) {</a>
<a name="ln292">						TRACE_ERROR(&quot;out of memory allocating&quot;</a>
<a name="ln293">							&quot; generic descriptor\n&quot;);</a>
<a name="ln294">						currentInterface-&gt;generic_count--;</a>
<a name="ln295">						return;</a>
<a name="ln296">					}</a>
<a name="ln297"> </a>
<a name="ln298">					currentInterface-&gt;generic = newGenerics;</a>
<a name="ln299"> </a>
<a name="ln300">					// Add this descriptor</a>
<a name="ln301">					currentInterface-&gt;generic[</a>
<a name="ln302">						currentInterface-&gt;generic_count - 1]</a>
<a name="ln303">							= (usb_descriptor*)genericDescriptor;</a>
<a name="ln304">					break;</a>
<a name="ln305">			}</a>
<a name="ln306"> </a>
<a name="ln307">			descriptorStart += configData[descriptorStart];</a>
<a name="ln308">		}</a>
<a name="ln309">	}</a>
<a name="ln310"> </a>
<a name="ln311">	// Set default configuration</a>
<a name="ln312">	TRACE(&quot;setting default configuration\n&quot;);</a>
<a name="ln313">	if (SetConfigurationAt(0) != B_OK) {</a>
<a name="ln314">		TRACE_ERROR(&quot;failed to set default configuration\n&quot;);</a>
<a name="ln315">		return;</a>
<a name="ln316">	}</a>
<a name="ln317"> </a>
<a name="ln318">	fInitOK = true;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321"> </a>
<a name="ln322">Device::~Device()</a>
<a name="ln323">{</a>
<a name="ln324">	// Unset fInitOK to indicate we are tearing down.</a>
<a name="ln325">	fInitOK = false;</a>
<a name="ln326"> </a>
<a name="ln327">	delete fDefaultPipe;</a>
<a name="ln328"> </a>
<a name="ln329">	if (fConfigurations == NULL) {</a>
<a name="ln330">		// we didn't get far in device setup, so everything below is unneeded</a>
<a name="ln331">		return;</a>
<a name="ln332">	}</a>
<a name="ln333"> </a>
<a name="ln334">	// Destroy open endpoints. Do not send a device request to unconfigure</a>
<a name="ln335">	// though, since we may be deleted because the device was unplugged</a>
<a name="ln336">	// already.</a>
<a name="ln337">	Unconfigure(false);</a>
<a name="ln338"> </a>
<a name="ln339">	// Free all allocated resources</a>
<a name="ln340">	for (int32 i = 0; i &lt; fDeviceDescriptor.num_configurations; i++) {</a>
<a name="ln341">		usb_configuration_info* configuration = &amp;fConfigurations[i];</a>
<a name="ln342">		if (configuration == NULL)</a>
<a name="ln343">			continue;</a>
<a name="ln344"> </a>
<a name="ln345">		free(configuration-&gt;descr);</a>
<a name="ln346">		if (configuration-&gt;interface == NULL)</a>
<a name="ln347">			continue;</a>
<a name="ln348"> </a>
<a name="ln349">		for (size_t j = 0; j &lt; configuration-&gt;interface_count; j++) {</a>
<a name="ln350">			usb_interface_list* interfaceList = &amp;configuration-&gt;interface[j];</a>
<a name="ln351">			if (interfaceList-&gt;alt == NULL)</a>
<a name="ln352">				continue;</a>
<a name="ln353"> </a>
<a name="ln354">			for (size_t k = 0; k &lt; interfaceList-&gt;alt_count; k++) {</a>
<a name="ln355">				usb_interface_info* interface = &amp;interfaceList-&gt;alt[k];</a>
<a name="ln356">				delete (Interface*)GetStack()-&gt;GetObject(interface-&gt;handle);</a>
<a name="ln357">				free(interface-&gt;endpoint);</a>
<a name="ln358">				free(interface-&gt;generic);</a>
<a name="ln359">			}</a>
<a name="ln360"> </a>
<a name="ln361">			free(interfaceList-&gt;alt);</a>
<a name="ln362">		}</a>
<a name="ln363"> </a>
<a name="ln364">		free(configuration-&gt;interface);</a>
<a name="ln365">	}</a>
<a name="ln366"> </a>
<a name="ln367">	free(fConfigurations);</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">status_t</a>
<a name="ln372">Device::InitCheck()</a>
<a name="ln373">{</a>
<a name="ln374">	if (fInitOK)</a>
<a name="ln375">		return B_OK;</a>
<a name="ln376"> </a>
<a name="ln377">	return B_ERROR;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">status_t</a>
<a name="ln382">Device::Changed(change_item** changeList, bool added)</a>
<a name="ln383">{</a>
<a name="ln384">	fAvailable = added;</a>
<a name="ln385">	change_item* changeItem = new(std::nothrow) change_item;</a>
<a name="ln386">	if (changeItem == NULL)</a>
<a name="ln387">		return B_NO_MEMORY;</a>
<a name="ln388"> </a>
<a name="ln389">	changeItem-&gt;added = added;</a>
<a name="ln390">	changeItem-&gt;device = this;</a>
<a name="ln391">	changeItem-&gt;link = *changeList;</a>
<a name="ln392">	*changeList = changeItem;</a>
<a name="ln393">	return B_OK;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396"> </a>
<a name="ln397">status_t</a>
<a name="ln398">Device::GetDescriptor(uint8 descriptorType, uint8 index, uint16 languageID,</a>
<a name="ln399">	void* data, size_t dataLength, size_t* actualLength)</a>
<a name="ln400">{</a>
<a name="ln401">	if (!fAvailable)</a>
<a name="ln402">		return B_ERROR;</a>
<a name="ln403"> </a>
<a name="ln404">	return fDefaultPipe-&gt;SendRequest(</a>
<a name="ln405">		USB_REQTYPE_DEVICE_IN | USB_REQTYPE_STANDARD,</a>
<a name="ln406">		USB_REQUEST_GET_DESCRIPTOR, (descriptorType &lt;&lt; 8) | index,</a>
<a name="ln407">		languageID, dataLength, data, dataLength, actualLength);</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410"> </a>
<a name="ln411">const usb_configuration_info*</a>
<a name="ln412">Device::Configuration() const</a>
<a name="ln413">{</a>
<a name="ln414">	return fCurrentConfiguration;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417"> </a>
<a name="ln418">const usb_configuration_info*</a>
<a name="ln419">Device::ConfigurationAt(uint8 index) const</a>
<a name="ln420">{</a>
<a name="ln421">	if (index &gt;= fDeviceDescriptor.num_configurations)</a>
<a name="ln422">		return NULL;</a>
<a name="ln423"> </a>
<a name="ln424">	return &amp;fConfigurations[index];</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427"> </a>
<a name="ln428">status_t</a>
<a name="ln429">Device::SetConfiguration(const usb_configuration_info* configuration)</a>
<a name="ln430">{</a>
<a name="ln431">	if (!configuration)</a>
<a name="ln432">		return Unconfigure(true);</a>
<a name="ln433"> </a>
<a name="ln434">	for (uint8 i = 0; i &lt; fDeviceDescriptor.num_configurations; i++) {</a>
<a name="ln435">		if (configuration-&gt;descr-&gt;configuration_value</a>
<a name="ln436">				== fConfigurations[i].descr-&gt;configuration_value)</a>
<a name="ln437">			return SetConfigurationAt(i);</a>
<a name="ln438">	}</a>
<a name="ln439"> </a>
<a name="ln440">	return B_BAD_VALUE;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">status_t</a>
<a name="ln445">Device::SetConfigurationAt(uint8 index)</a>
<a name="ln446">{</a>
<a name="ln447">	if (!fAvailable)</a>
<a name="ln448">		return B_ERROR;</a>
<a name="ln449">	if (index &gt;= fDeviceDescriptor.num_configurations)</a>
<a name="ln450">		return B_BAD_VALUE;</a>
<a name="ln451">	if (&amp;fConfigurations[index] == fCurrentConfiguration)</a>
<a name="ln452">		return B_OK;</a>
<a name="ln453"> </a>
<a name="ln454">	// Destroy our open endpoints</a>
<a name="ln455">	Unconfigure(false);</a>
<a name="ln456"> </a>
<a name="ln457">	// Tell the device to set the configuration</a>
<a name="ln458">	status_t result = fDefaultPipe-&gt;SendRequest(</a>
<a name="ln459">		USB_REQTYPE_DEVICE_OUT | USB_REQTYPE_STANDARD,</a>
<a name="ln460">		USB_REQUEST_SET_CONFIGURATION,</a>
<a name="ln461">		fConfigurations[index].descr-&gt;configuration_value, 0, 0, NULL, 0, NULL);</a>
<a name="ln462">	if (result &lt; B_OK)</a>
<a name="ln463">		return result;</a>
<a name="ln464"> </a>
<a name="ln465">	// Set current configuration</a>
<a name="ln466">	fCurrentConfiguration = &amp;fConfigurations[index];</a>
<a name="ln467"> </a>
<a name="ln468">	// Initialize all the endpoints that are now active</a>
<a name="ln469">	InitEndpoints(-1);</a>
<a name="ln470"> </a>
<a name="ln471">	// Wait some for the configuration being finished</a>
<a name="ln472">	if (!fIsRootHub)</a>
<a name="ln473">		snooze(USB_DELAY_SET_CONFIGURATION);</a>
<a name="ln474">	return B_OK;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477"> </a>
<a name="ln478">void</a>
<a name="ln479">Device::InitEndpoints(int32 interfaceIndex)</a>
<a name="ln480">{</a>
<a name="ln481">	for (size_t j = 0; j &lt; fCurrentConfiguration-&gt;interface_count; j++) {</a>
<a name="ln482">		if (interfaceIndex &gt;= 0 &amp;&amp; j != (size_t)interfaceIndex)</a>
<a name="ln483">			continue;</a>
<a name="ln484"> </a>
<a name="ln485">		usb_interface_info* interfaceInfo</a>
<a name="ln486">			= fCurrentConfiguration-&gt;interface[j].active;</a>
<a name="ln487">		if (interfaceInfo == NULL)</a>
<a name="ln488">			continue;</a>
<a name="ln489"> </a>
<a name="ln490">		for (size_t i = 0; i &lt; interfaceInfo-&gt;endpoint_count; i++) {</a>
<a name="ln491">			usb_endpoint_info* endpoint = &amp;interfaceInfo-&gt;endpoint[i];</a>
<a name="ln492">			Pipe* pipe = NULL;</a>
<a name="ln493"> </a>
<a name="ln494">			usb_endpoint_companion_descriptor* comp_descr = NULL;</a>
<a name="ln495">			if (fSpeed == USB_SPEED_SUPER) {</a>
<a name="ln496">				// We should have a companion descriptor for this device.</a>
<a name="ln497">				// Let's find it: it'll be the &quot;i&quot;th one.</a>
<a name="ln498">				size_t k = 0;</a>
<a name="ln499">				for (size_t j = 0; j &lt; interfaceInfo-&gt;generic_count; j++) {</a>
<a name="ln500">					usb_descriptor* desc = interfaceInfo-&gt;generic[j];</a>
<a name="ln501">					if (desc-&gt;endpoint.descriptor_type</a>
<a name="ln502">							!= USB_DESCRIPTOR_ENDPOINT_COMPANION) {</a>
<a name="ln503">						continue;</a>
<a name="ln504">					}</a>
<a name="ln505">					if (k == i) {</a>
<a name="ln506">						comp_descr = (usb_endpoint_companion_descriptor*)desc;</a>
<a name="ln507">						break;</a>
<a name="ln508">					}</a>
<a name="ln509">					k++;</a>
<a name="ln510">				}</a>
<a name="ln511">				if (comp_descr == NULL) {</a>
<a name="ln512">					TRACE_ERROR(&quot;SuperSpeed device without an endpoint companion &quot;</a>
<a name="ln513">						&quot;descriptor!&quot;);</a>
<a name="ln514">				}</a>
<a name="ln515">			}</a>
<a name="ln516"> </a>
<a name="ln517">			Pipe::pipeDirection direction = Pipe::Out;</a>
<a name="ln518">			if ((endpoint-&gt;descr-&gt;endpoint_address &amp; 0x80) != 0)</a>
<a name="ln519">				direction = Pipe::In;</a>
<a name="ln520"> </a>
<a name="ln521">			switch (endpoint-&gt;descr-&gt;attributes &amp; 0x03) {</a>
<a name="ln522">				case USB_ENDPOINT_ATTR_CONTROL:		// Control Endpoint</a>
<a name="ln523">					pipe = new(std::nothrow) ControlPipe(this);</a>
<a name="ln524">					direction = Pipe::Default;</a>
<a name="ln525">					break;</a>
<a name="ln526"> </a>
<a name="ln527">				case USB_ENDPOINT_ATTR_ISOCHRONOUS:	// Isochronous Endpoint</a>
<a name="ln528">					pipe = new(std::nothrow) IsochronousPipe(this);</a>
<a name="ln529">					break;</a>
<a name="ln530"> </a>
<a name="ln531">				case USB_ENDPOINT_ATTR_BULK:		// Bulk Endpoint</a>
<a name="ln532">					pipe = new(std::nothrow) BulkPipe(this);</a>
<a name="ln533">					break;</a>
<a name="ln534"> </a>
<a name="ln535">				case USB_ENDPOINT_ATTR_INTERRUPT:	// Interrupt Endpoint</a>
<a name="ln536">					pipe = new(std::nothrow) InterruptPipe(this);</a>
<a name="ln537">					break;</a>
<a name="ln538">			}</a>
<a name="ln539"> </a>
<a name="ln540">			if (pipe == NULL) {</a>
<a name="ln541">				TRACE_ERROR(&quot;failed to allocate pipe\n&quot;);</a>
<a name="ln542">				endpoint-&gt;handle = 0;</a>
<a name="ln543">				continue;</a>
<a name="ln544">			}</a>
<a name="ln545"> </a>
<a name="ln546">			pipe-&gt;InitCommon(fDeviceAddress,</a>
<a name="ln547">				endpoint-&gt;descr-&gt;endpoint_address &amp; 0x0f,</a>
<a name="ln548">				fSpeed, direction, endpoint-&gt;descr-&gt;max_packet_size,</a>
<a name="ln549">				endpoint-&gt;descr-&gt;interval, fHubAddress, fHubPort);</a>
<a name="ln550">			if (comp_descr != NULL) {</a>
<a name="ln551">				pipe-&gt;InitSuperSpeed(comp_descr-&gt;max_burst,</a>
<a name="ln552">					comp_descr-&gt;bytes_per_interval);</a>
<a name="ln553">			}</a>
<a name="ln554">			endpoint-&gt;handle = pipe-&gt;USBID();</a>
<a name="ln555">		}</a>
<a name="ln556">	}</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559"> </a>
<a name="ln560">status_t</a>
<a name="ln561">Device::Unconfigure(bool atDeviceLevel)</a>
<a name="ln562">{</a>
<a name="ln563">	// If we only want to destroy our open pipes before setting</a>
<a name="ln564">	// another configuration unconfigure will be called with</a>
<a name="ln565">	// atDevice = false. otherwise we explicitly want to unconfigure</a>
<a name="ln566">	// the device and have to send it the corresponding request.</a>
<a name="ln567">	if (atDeviceLevel &amp;&amp; fAvailable) {</a>
<a name="ln568">		status_t result = fDefaultPipe-&gt;SendRequest(</a>
<a name="ln569">			USB_REQTYPE_DEVICE_OUT | USB_REQTYPE_STANDARD,</a>
<a name="ln570">			USB_REQUEST_SET_CONFIGURATION, 0, 0, 0, NULL, 0, NULL);</a>
<a name="ln571">		if (result &lt; B_OK)</a>
<a name="ln572">			return result;</a>
<a name="ln573"> </a>
<a name="ln574">		snooze(USB_DELAY_SET_CONFIGURATION);</a>
<a name="ln575">	}</a>
<a name="ln576"> </a>
<a name="ln577">	if (!fCurrentConfiguration)</a>
<a name="ln578">		return B_OK;</a>
<a name="ln579"> </a>
<a name="ln580">	ClearEndpoints(-1);</a>
<a name="ln581">	fCurrentConfiguration = NULL;</a>
<a name="ln582">	return B_OK;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585"> </a>
<a name="ln586">void</a>
<a name="ln587">Device::ClearEndpoints(int32 interfaceIndex)</a>
<a name="ln588">{</a>
<a name="ln589">	if (fCurrentConfiguration == NULL</a>
<a name="ln590">		|| fCurrentConfiguration-&gt;interface == NULL)</a>
<a name="ln591">		return;</a>
<a name="ln592"> </a>
<a name="ln593">	for (size_t j = 0; j &lt; fCurrentConfiguration-&gt;interface_count; j++) {</a>
<a name="ln594">		if (interfaceIndex &gt;= 0 &amp;&amp; j != (size_t)interfaceIndex)</a>
<a name="ln595">			continue;</a>
<a name="ln596"> </a>
<a name="ln597">		usb_interface_info* interfaceInfo</a>
<a name="ln598">			= fCurrentConfiguration-&gt;interface[j].active;</a>
<a name="ln599">		if (interfaceInfo == NULL || interfaceInfo-&gt;endpoint == NULL)</a>
<a name="ln600">			continue;</a>
<a name="ln601"> </a>
<a name="ln602">		for (size_t i = 0; i &lt; interfaceInfo-&gt;endpoint_count; i++) {</a>
<a name="ln603">			usb_endpoint_info* endpoint = &amp;interfaceInfo-&gt;endpoint[i];</a>
<a name="ln604">			delete (Pipe*)GetStack()-&gt;GetObject(endpoint-&gt;handle);</a>
<a name="ln605">			endpoint-&gt;handle = 0;</a>
<a name="ln606">		}</a>
<a name="ln607">	}</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">status_t</a>
<a name="ln612">Device::SetAltInterface(const usb_interface_info* interface)</a>
<a name="ln613">{</a>
<a name="ln614">	uint8 interfaceNumber = interface-&gt;descr-&gt;interface_number;</a>
<a name="ln615">	// Tell the device to set the alternate settings</a>
<a name="ln616">	status_t result = fDefaultPipe-&gt;SendRequest(</a>
<a name="ln617">		USB_REQTYPE_INTERFACE_OUT | USB_REQTYPE_STANDARD,</a>
<a name="ln618">		USB_REQUEST_SET_INTERFACE,</a>
<a name="ln619">		interface-&gt;descr-&gt;alternate_setting, interfaceNumber, 0, NULL, 0, NULL);</a>
<a name="ln620">	if (result &lt; B_OK)</a>
<a name="ln621">		return result;</a>
<a name="ln622"> </a>
<a name="ln623">	// Clear the no longer active endpoints</a>
<a name="ln624">	ClearEndpoints(interfaceNumber);</a>
<a name="ln625"> </a>
<a name="ln626">	// Update the active pointer of the interface list</a>
<a name="ln627">	usb_interface_list* interfaceList</a>
<a name="ln628">		= &amp;fCurrentConfiguration-&gt;interface[interfaceNumber];</a>
<a name="ln629">	interfaceList-&gt;active</a>
<a name="ln630">		= &amp;interfaceList-&gt;alt[interface-&gt;descr-&gt;alternate_setting];</a>
<a name="ln631"> </a>
<a name="ln632">	// Initialize the new endpoints</a>
<a name="ln633">	InitEndpoints(interfaceNumber);</a>
<a name="ln634">	return result;</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637"> </a>
<a name="ln638">const usb_device_descriptor*</a>
<a name="ln639">Device::DeviceDescriptor() const</a>
<a name="ln640">{</a>
<a name="ln641">	return &amp;fDeviceDescriptor;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644"> </a>
<a name="ln645">status_t</a>
<a name="ln646">Device::ReportDevice(usb_support_descriptor* supportDescriptors,</a>
<a name="ln647">	uint32 supportDescriptorCount, const usb_notify_hooks* hooks,</a>
<a name="ln648">	usb_driver_cookie** cookies, bool added, bool recursive)</a>
<a name="ln649">{</a>
<a name="ln650">	TRACE(&quot;reporting device\n&quot;);</a>
<a name="ln651">	bool supported = false;</a>
<a name="ln652">	if (supportDescriptorCount == 0 || supportDescriptors == NULL)</a>
<a name="ln653">		supported = true;</a>
<a name="ln654"> </a>
<a name="ln655">	for (uint32 i = 0; !supported &amp;&amp; i &lt; supportDescriptorCount; i++) {</a>
<a name="ln656">		if ((supportDescriptors[i].vendor != 0</a>
<a name="ln657">				&amp;&amp; fDeviceDescriptor.vendor_id != supportDescriptors[i].vendor)</a>
<a name="ln658">			|| (supportDescriptors[i].product != 0</a>
<a name="ln659">				&amp;&amp; fDeviceDescriptor.product_id</a>
<a name="ln660">					!= supportDescriptors[i].product))</a>
<a name="ln661">			continue;</a>
<a name="ln662"> </a>
<a name="ln663">		if ((supportDescriptors[i].dev_class == 0</a>
<a name="ln664">				|| fDeviceDescriptor.device_class</a>
<a name="ln665">					== supportDescriptors[i].dev_class)</a>
<a name="ln666">			&amp;&amp; (supportDescriptors[i].dev_subclass == 0</a>
<a name="ln667">				|| fDeviceDescriptor.device_subclass</a>
<a name="ln668">					== supportDescriptors[i].dev_subclass)</a>
<a name="ln669">			&amp;&amp; (supportDescriptors[i].dev_protocol == 0</a>
<a name="ln670">				|| fDeviceDescriptor.device_protocol</a>
<a name="ln671">					== supportDescriptors[i].dev_protocol)) {</a>
<a name="ln672">			supported = true;</a>
<a name="ln673">		}</a>
<a name="ln674"> </a>
<a name="ln675">		// we have to check all interfaces for matching class/subclass/protocol</a>
<a name="ln676">		for (uint32 j = 0;</a>
<a name="ln677">				!supported &amp;&amp; j &lt; fDeviceDescriptor.num_configurations; j++) {</a>
<a name="ln678">			for (uint32 k = 0;</a>
<a name="ln679">					!supported &amp;&amp; k &lt; fConfigurations[j].interface_count; k++) {</a>
<a name="ln680">				for (uint32 l = 0; !supported</a>
<a name="ln681">					&amp;&amp; l &lt; fConfigurations[j].interface[k].alt_count; l++) {</a>
<a name="ln682">					usb_interface_descriptor* descriptor</a>
<a name="ln683">						= fConfigurations[j].interface[k].alt[l].descr;</a>
<a name="ln684">					if ((supportDescriptors[i].dev_class == 0</a>
<a name="ln685">							|| descriptor-&gt;interface_class</a>
<a name="ln686">								== supportDescriptors[i].dev_class)</a>
<a name="ln687">						&amp;&amp; (supportDescriptors[i].dev_subclass == 0</a>
<a name="ln688">							|| descriptor-&gt;interface_subclass</a>
<a name="ln689">								== supportDescriptors[i].dev_subclass)</a>
<a name="ln690">						&amp;&amp; (supportDescriptors[i].dev_protocol == 0</a>
<a name="ln691">							|| descriptor-&gt;interface_protocol</a>
<a name="ln692">								== supportDescriptors[i].dev_protocol)) {</a>
<a name="ln693">						supported = true;</a>
<a name="ln694">					}</a>
<a name="ln695">				}</a>
<a name="ln696">			}</a>
<a name="ln697">		}</a>
<a name="ln698">	}</a>
<a name="ln699"> </a>
<a name="ln700">	if (!supported)</a>
<a name="ln701">		return B_UNSUPPORTED;</a>
<a name="ln702"> </a>
<a name="ln703">	if ((added &amp;&amp; hooks-&gt;device_added == NULL)</a>
<a name="ln704">		|| (!added &amp;&amp; hooks-&gt;device_removed == NULL)) {</a>
<a name="ln705">		// hooks are not installed, but report success to indicate that</a>
<a name="ln706">		// the driver supports the device</a>
<a name="ln707">		return B_OK;</a>
<a name="ln708">	}</a>
<a name="ln709"> </a>
<a name="ln710">	usb_id id = USBID();</a>
<a name="ln711">	if (added) {</a>
<a name="ln712">		usb_driver_cookie* cookie = new(std::nothrow) usb_driver_cookie;</a>
<a name="ln713">		if (hooks-&gt;device_added(id, &amp;cookie-&gt;cookie) &gt;= B_OK) {</a>
<a name="ln714">			cookie-&gt;device = id;</a>
<a name="ln715">			cookie-&gt;link = *cookies;</a>
<a name="ln716">			*cookies = cookie;</a>
<a name="ln717">		} else</a>
<a name="ln718">			delete cookie;</a>
<a name="ln719">	} else {</a>
<a name="ln720">		usb_driver_cookie** pointer = cookies;</a>
<a name="ln721">		usb_driver_cookie* cookie = *cookies;</a>
<a name="ln722">		while (cookie != NULL) {</a>
<a name="ln723">			if (cookie-&gt;device == id)</a>
<a name="ln724">				break;</a>
<a name="ln725">			pointer = &amp;cookie-&gt;link;</a>
<a name="ln726">			cookie = cookie-&gt;link;</a>
<a name="ln727">		}</a>
<a name="ln728"> </a>
<a name="ln729">		if (cookie == NULL) {</a>
<a name="ln730">			// the device is supported, but there is no cookie. this most</a>
<a name="ln731">			// probably means that the device_added hook above failed.</a>
<a name="ln732">			return B_OK;</a>
<a name="ln733">		}</a>
<a name="ln734"> </a>
<a name="ln735">		hooks-&gt;device_removed(cookie-&gt;cookie);</a>
<a name="ln736">		*pointer = cookie-&gt;link;</a>
<a name="ln737">		delete cookie;</a>
<a name="ln738">	}</a>
<a name="ln739"> </a>
<a name="ln740">	return B_OK;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743"> </a>
<a name="ln744">status_t</a>
<a name="ln745">Device::BuildDeviceName(char* string, uint32* index, size_t bufferSize,</a>
<a name="ln746">	Device* device)</a>
<a name="ln747">{</a>
<a name="ln748">	if (!Parent() || (Parent()-&gt;Type() &amp; USB_OBJECT_HUB) == 0)</a>
<a name="ln749">		return B_ERROR;</a>
<a name="ln750"> </a>
<a name="ln751">	((Hub*)Parent())-&gt;BuildDeviceName(string, index, bufferSize, this);</a>
<a name="ln752">	return B_OK;</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">status_t</a>
<a name="ln757">Device::SetFeature(uint16 selector)</a>
<a name="ln758">{</a>
<a name="ln759">	if (!fAvailable)</a>
<a name="ln760">		return B_ERROR;</a>
<a name="ln761"> </a>
<a name="ln762">	TRACE(&quot;set feature %u\n&quot;, selector);</a>
<a name="ln763">	return fDefaultPipe-&gt;SendRequest(</a>
<a name="ln764">		USB_REQTYPE_STANDARD | USB_REQTYPE_DEVICE_OUT,</a>
<a name="ln765">		USB_REQUEST_SET_FEATURE, selector, 0, 0, NULL, 0, NULL);</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">status_t</a>
<a name="ln770">Device::ClearFeature(uint16 selector)</a>
<a name="ln771">{</a>
<a name="ln772">	if (!fAvailable)</a>
<a name="ln773">		return B_ERROR;</a>
<a name="ln774"> </a>
<a name="ln775">	TRACE(&quot;clear feature %u\n&quot;, selector);</a>
<a name="ln776">	return fDefaultPipe-&gt;SendRequest(</a>
<a name="ln777">		USB_REQTYPE_STANDARD | USB_REQTYPE_DEVICE_OUT,</a>
<a name="ln778">		USB_REQUEST_CLEAR_FEATURE, selector, 0, 0, NULL, 0, NULL);</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781"> </a>
<a name="ln782">status_t</a>
<a name="ln783">Device::GetStatus(uint16* status)</a>
<a name="ln784">{</a>
<a name="ln785">	if (!fAvailable)</a>
<a name="ln786">		return B_ERROR;</a>
<a name="ln787"> </a>
<a name="ln788">	TRACE(&quot;get status\n&quot;);</a>
<a name="ln789">	return fDefaultPipe-&gt;SendRequest(</a>
<a name="ln790">		USB_REQTYPE_STANDARD | USB_REQTYPE_DEVICE_IN,</a>
<a name="ln791">		USB_REQUEST_GET_STATUS, 0, 0, 2, (void*)status, 2, NULL);</a>
<a name="ln792">}</a>

</code></pre>
<div class="balloon" rel="258"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'currentInterface' might take place.</p></div>
<div class="balloon" rel="555"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'pipe' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
