
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>command_extract.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2013, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;fcntl.h&gt;</a>
<a name="ln9">#include &lt;errno.h&gt;</a>
<a name="ln10">#include &lt;getopt.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14">#include &lt;sys/stat.h&gt;</a>
<a name="ln15">#include &lt;unistd.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;algorithm&gt;</a>
<a name="ln18">#include &lt;new&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;fs_attr.h&gt;</a>
<a name="ln21">#include &lt;String.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln24">#include &lt;HashString.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;util/OpenHashTable.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;package/hpkg/BlockBufferPoolNoLock.h&gt;</a>
<a name="ln29">#include &lt;package/hpkg/PackageContentHandler.h&gt;</a>
<a name="ln30">#include &lt;package/hpkg/PackageDataReader.h&gt;</a>
<a name="ln31">#include &lt;package/hpkg/PackageEntry.h&gt;</a>
<a name="ln32">#include &lt;package/hpkg/PackageEntryAttribute.h&gt;</a>
<a name="ln33">#include &lt;package/hpkg/PackageReader.h&gt;</a>
<a name="ln34">#include &lt;package/hpkg/StandardErrorOutput.h&gt;</a>
<a name="ln35">#include &lt;package/hpkg/v1/PackageContentHandler.h&gt;</a>
<a name="ln36">#include &lt;package/hpkg/v1/PackageDataReader.h&gt;</a>
<a name="ln37">#include &lt;package/hpkg/v1/PackageEntry.h&gt;</a>
<a name="ln38">#include &lt;package/hpkg/v1/PackageEntryAttribute.h&gt;</a>
<a name="ln39">#include &lt;package/hpkg/v1//PackageReader.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;package.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">using BPackageKit::BHPKG::BAbstractBufferedDataReader;</a>
<a name="ln45">using BPackageKit::BHPKG::BBlockBufferPoolNoLock;</a>
<a name="ln46">using BPackageKit::BHPKG::BBufferDataReader;</a>
<a name="ln47">using BPackageKit::BHPKG::BBufferPool;</a>
<a name="ln48">using BPackageKit::BHPKG::BDataReader;</a>
<a name="ln49">using BPackageKit::BHPKG::BErrorOutput;</a>
<a name="ln50">using BPackageKit::BHPKG::BFDDataReader;</a>
<a name="ln51">using BPackageKit::BHPKG::BPackageInfoAttributeValue;</a>
<a name="ln52">using BPackageKit::BHPKG::BStandardErrorOutput;</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">struct VersionPolicyV1 {</a>
<a name="ln56">	typedef BPackageKit::BHPKG::V1::BPackageContentHandler</a>
<a name="ln57">		PackageContentHandler;</a>
<a name="ln58">	typedef BPackageKit::BHPKG::V1::BPackageData PackageData;</a>
<a name="ln59">	typedef BPackageKit::BHPKG::V1::BPackageEntry PackageEntry;</a>
<a name="ln60">	typedef BPackageKit::BHPKG::V1::BPackageEntryAttribute</a>
<a name="ln61">		PackageEntryAttribute;</a>
<a name="ln62">	typedef BPackageKit::BHPKG::V1::BPackageReader PackageReader;</a>
<a name="ln63">	typedef BDataReader HeapReaderBase;</a>
<a name="ln64"> </a>
<a name="ln65">	static inline size_t BufferSize()</a>
<a name="ln66">	{</a>
<a name="ln67">		return BPackageKit::BHPKG::V1::B_HPKG_DEFAULT_DATA_CHUNK_SIZE_ZLIB;</a>
<a name="ln68">	}</a>
<a name="ln69"> </a>
<a name="ln70">	static inline const char* PackageInfoFileName()</a>
<a name="ln71">	{</a>
<a name="ln72">		return BPackageKit::BHPKG::V1::B_HPKG_PACKAGE_INFO_FILE_NAME;</a>
<a name="ln73">	}</a>
<a name="ln74"> </a>
<a name="ln75">	static inline uint64 PackageDataCompressedSize(const PackageData&amp; data)</a>
<a name="ln76">	{</a>
<a name="ln77">		return data.CompressedSize();</a>
<a name="ln78">	}</a>
<a name="ln79"> </a>
<a name="ln80">	static inline uint64 PackageDataUncompressedSize(const PackageData&amp; data)</a>
<a name="ln81">	{</a>
<a name="ln82">		return data.UncompressedSize();</a>
<a name="ln83">	}</a>
<a name="ln84"> </a>
<a name="ln85">	static inline status_t InitReader(PackageReader&amp; packageReader,</a>
<a name="ln86">		const char* fileName)</a>
<a name="ln87">	{</a>
<a name="ln88">		return packageReader.Init(fileName);</a>
<a name="ln89">	}</a>
<a name="ln90"> </a>
<a name="ln91">	static status_t GetHeapReader(PackageReader&amp; packageReader,</a>
<a name="ln92">		HeapReaderBase*&amp; _heapReader, bool&amp; _mustDelete)</a>
<a name="ln93">	{</a>
<a name="ln94">		_heapReader = new(std::nothrow) BFDDataReader(</a>
<a name="ln95">			packageReader.PackageFileFD());</a>
<a name="ln96">		_mustDelete = false;</a>
<a name="ln97">		return _heapReader != NULL ? B_OK : B_NO_MEMORY;</a>
<a name="ln98">	}</a>
<a name="ln99"> </a>
<a name="ln100">	static status_t CreatePackageDataReader(BBufferPool* bufferPool,</a>
<a name="ln101">		HeapReaderBase* heapReader, const PackageData&amp; data,</a>
<a name="ln102">		BAbstractBufferedDataReader*&amp; _reader)</a>
<a name="ln103">	{</a>
<a name="ln104">		return BPackageKit::BHPKG::V1::BPackageDataReaderFactory(bufferPool)</a>
<a name="ln105">			.CreatePackageDataReader(heapReader, data, _reader);</a>
<a name="ln106">	}</a>
<a name="ln107">};</a>
<a name="ln108"> </a>
<a name="ln109">struct VersionPolicyV2 {</a>
<a name="ln110">	typedef BPackageKit::BHPKG::BPackageContentHandler PackageContentHandler;</a>
<a name="ln111">	typedef BPackageKit::BHPKG::BPackageData PackageData;</a>
<a name="ln112">	typedef BPackageKit::BHPKG::BPackageEntry PackageEntry;</a>
<a name="ln113">	typedef BPackageKit::BHPKG::BPackageEntryAttribute PackageEntryAttribute;</a>
<a name="ln114">	typedef BPackageKit::BHPKG::BPackageReader PackageReader;</a>
<a name="ln115">	typedef BAbstractBufferedDataReader HeapReaderBase;</a>
<a name="ln116"> </a>
<a name="ln117">	static inline size_t BufferSize()</a>
<a name="ln118">	{</a>
<a name="ln119">		return 64 * 1024;</a>
<a name="ln120">	}</a>
<a name="ln121"> </a>
<a name="ln122">	static inline const char* PackageInfoFileName()</a>
<a name="ln123">	{</a>
<a name="ln124">		return BPackageKit::BHPKG::B_HPKG_PACKAGE_INFO_FILE_NAME;</a>
<a name="ln125">	}</a>
<a name="ln126"> </a>
<a name="ln127">	static inline uint64 PackageDataCompressedSize(const PackageData&amp; data)</a>
<a name="ln128">	{</a>
<a name="ln129">		return data.Size();</a>
<a name="ln130">	}</a>
<a name="ln131"> </a>
<a name="ln132">	static inline uint64 PackageDataUncompressedSize(const PackageData&amp; data)</a>
<a name="ln133">	{</a>
<a name="ln134">		return data.Size();</a>
<a name="ln135">	}</a>
<a name="ln136"> </a>
<a name="ln137">	static inline status_t InitReader(PackageReader&amp; packageReader,</a>
<a name="ln138">		const char* fileName)</a>
<a name="ln139">	{</a>
<a name="ln140">		return packageReader.Init(fileName,</a>
<a name="ln141">			BPackageKit::BHPKG</a>
<a name="ln142">				::B_HPKG_READER_DONT_PRINT_VERSION_MISMATCH_MESSAGE);</a>
<a name="ln143">	}</a>
<a name="ln144"> </a>
<a name="ln145">	static status_t GetHeapReader(PackageReader&amp; packageReader,</a>
<a name="ln146">		HeapReaderBase*&amp; _heapReader, bool&amp; _mustDelete)</a>
<a name="ln147">	{</a>
<a name="ln148">		_heapReader = packageReader.HeapReader();</a>
<a name="ln149">		_mustDelete = false;</a>
<a name="ln150">		return B_OK;</a>
<a name="ln151">	}</a>
<a name="ln152"> </a>
<a name="ln153">	static status_t CreatePackageDataReader(BBufferPool* bufferPool,</a>
<a name="ln154">		HeapReaderBase* heapReader, const PackageData&amp; data,</a>
<a name="ln155">		BAbstractBufferedDataReader*&amp; _reader)</a>
<a name="ln156">	{</a>
<a name="ln157">		return BPackageKit::BHPKG::BPackageDataReaderFactory()</a>
<a name="ln158">			.CreatePackageDataReader(heapReader, data, _reader);</a>
<a name="ln159">	}</a>
<a name="ln160">};</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">struct Entry {</a>
<a name="ln164">	Entry(Entry* parent, char* name, bool implicit)</a>
<a name="ln165">		:</a>
<a name="ln166">		fParent(parent),</a>
<a name="ln167">		fName(name),</a>
<a name="ln168">		fImplicit(implicit),</a>
<a name="ln169">		fSeen(false)</a>
<a name="ln170">	{</a>
<a name="ln171">	}</a>
<a name="ln172"> </a>
<a name="ln173">	~Entry()</a>
<a name="ln174">	{</a>
<a name="ln175">		_DeleteChildren();</a>
<a name="ln176"> </a>
<a name="ln177">		free(fName);</a>
<a name="ln178">	}</a>
<a name="ln179"> </a>
<a name="ln180">	status_t Init()</a>
<a name="ln181">	{</a>
<a name="ln182">		return fChildren.Init();</a>
<a name="ln183">	}</a>
<a name="ln184"> </a>
<a name="ln185">	static status_t Create(Entry* parent, const char* name, bool implicit,</a>
<a name="ln186">		Entry*&amp; _entry)</a>
<a name="ln187">	{</a>
<a name="ln188">		if (parent != NULL) {</a>
<a name="ln189">			Entry* entryInParent = parent-&gt;FindChild(name);</a>
<a name="ln190">			if (entryInParent != NULL) {</a>
<a name="ln191">				_entry = entryInParent;</a>
<a name="ln192">				return B_OK;</a>
<a name="ln193">			}</a>
<a name="ln194">		}</a>
<a name="ln195"> </a>
<a name="ln196">		char* clonedName = strdup(name);</a>
<a name="ln197">		if (clonedName == NULL)</a>
<a name="ln198">			return B_NO_MEMORY;</a>
<a name="ln199"> </a>
<a name="ln200">		Entry* entry = new(std::nothrow) Entry(parent, clonedName, implicit);</a>
<a name="ln201">		if (entry == NULL) {</a>
<a name="ln202">			free(clonedName);</a>
<a name="ln203">			return B_NO_MEMORY;</a>
<a name="ln204">		}</a>
<a name="ln205"> </a>
<a name="ln206">		status_t error = entry-&gt;Init();</a>
<a name="ln207">		if (error != B_OK) {</a>
<a name="ln208">			delete entry;</a>
<a name="ln209">			return error;</a>
<a name="ln210">		}</a>
<a name="ln211"> </a>
<a name="ln212">		if (parent != NULL)</a>
<a name="ln213">			parent-&gt;fChildren.Insert(entry);</a>
<a name="ln214"> </a>
<a name="ln215">		_entry = entry;</a>
<a name="ln216">		return B_OK;</a>
<a name="ln217">	}</a>
<a name="ln218"> </a>
<a name="ln219">	Entry* Parent() const</a>
<a name="ln220">	{</a>
<a name="ln221">		return fParent;</a>
<a name="ln222">	}</a>
<a name="ln223"> </a>
<a name="ln224">	const char* Name() const</a>
<a name="ln225">	{</a>
<a name="ln226">		return fName;</a>
<a name="ln227">	}</a>
<a name="ln228"> </a>
<a name="ln229">	bool IsImplicit() const</a>
<a name="ln230">	{</a>
<a name="ln231">		return fImplicit;</a>
<a name="ln232">	}</a>
<a name="ln233"> </a>
<a name="ln234">	void SetExplicit()</a>
<a name="ln235">	{</a>
<a name="ln236">		// remove all children and set this entry non-implicit</a>
<a name="ln237">		_DeleteChildren();</a>
<a name="ln238">		fImplicit = false;</a>
<a name="ln239">	}</a>
<a name="ln240"> </a>
<a name="ln241">	void SetSeen()</a>
<a name="ln242">	{</a>
<a name="ln243">		fSeen = true;</a>
<a name="ln244">	}</a>
<a name="ln245"> </a>
<a name="ln246">	bool Seen() const</a>
<a name="ln247">	{</a>
<a name="ln248">		return fSeen;</a>
<a name="ln249">	}</a>
<a name="ln250"> </a>
<a name="ln251">	Entry* FindChild(const char* name) const</a>
<a name="ln252">	{</a>
<a name="ln253">		return fChildren.Lookup(name);</a>
<a name="ln254">	}</a>
<a name="ln255"> </a>
<a name="ln256">private:</a>
<a name="ln257">	struct ChildHashDefinition {</a>
<a name="ln258">		typedef const char*		KeyType;</a>
<a name="ln259">		typedef	Entry			ValueType;</a>
<a name="ln260"> </a>
<a name="ln261">		size_t HashKey(const char* key) const</a>
<a name="ln262">		{</a>
<a name="ln263">			return string_hash(key);</a>
<a name="ln264">		}</a>
<a name="ln265"> </a>
<a name="ln266">		size_t Hash(const Entry* value) const</a>
<a name="ln267">		{</a>
<a name="ln268">			return HashKey(value-&gt;Name());</a>
<a name="ln269">		}</a>
<a name="ln270"> </a>
<a name="ln271">		bool Compare(const char* key, const Entry* value) const</a>
<a name="ln272">		{</a>
<a name="ln273">			return strcmp(value-&gt;Name(), key) == 0;</a>
<a name="ln274">		}</a>
<a name="ln275"> </a>
<a name="ln276">		Entry*&amp; GetLink(Entry* value) const</a>
<a name="ln277">		{</a>
<a name="ln278">			return value-&gt;fHashTableNext;</a>
<a name="ln279">		}</a>
<a name="ln280">	};</a>
<a name="ln281"> </a>
<a name="ln282">	typedef BOpenHashTable&lt;ChildHashDefinition&gt; ChildTable;</a>
<a name="ln283"> </a>
<a name="ln284">private:</a>
<a name="ln285">	void _DeleteChildren()</a>
<a name="ln286">	{</a>
<a name="ln287">		Entry* child = fChildren.Clear(true);</a>
<a name="ln288">		while (child != NULL) {</a>
<a name="ln289">			Entry* next = child-&gt;fHashTableNext;</a>
<a name="ln290">			delete child;</a>
<a name="ln291">			child = next;</a>
<a name="ln292">		}</a>
<a name="ln293">	}</a>
<a name="ln294"> </a>
<a name="ln295">public:</a>
<a name="ln296">	Entry*		fHashTableNext;</a>
<a name="ln297"> </a>
<a name="ln298">private:</a>
<a name="ln299">	Entry*		fParent;</a>
<a name="ln300">	char*		fName;</a>
<a name="ln301">	bool		fImplicit;</a>
<a name="ln302">	bool		fSeen;</a>
<a name="ln303">	ChildTable	fChildren;</a>
<a name="ln304">};</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">template&lt;typename VersionPolicy&gt;</a>
<a name="ln308">struct PackageContentExtractHandler : VersionPolicy::PackageContentHandler {</a>
<a name="ln309">	PackageContentExtractHandler(BBufferPool* bufferPool,</a>
<a name="ln310">	typename VersionPolicy::HeapReaderBase* heapReader)</a>
<a name="ln311">		:</a>
<a name="ln312">		fBufferPool(bufferPool),</a>
<a name="ln313">		fPackageFileReader(heapReader),</a>
<a name="ln314">		fDataBuffer(NULL),</a>
<a name="ln315">		fDataBufferSize(0),</a>
<a name="ln316">		fRootFilterEntry(NULL, NULL, true),</a>
<a name="ln317">		fBaseDirectory(AT_FDCWD),</a>
<a name="ln318">		fInfoFileName(NULL),</a>
<a name="ln319">		fErrorOccurred(false)</a>
<a name="ln320">	{</a>
<a name="ln321">	}</a>
<a name="ln322"> </a>
<a name="ln323">	~PackageContentExtractHandler()</a>
<a name="ln324">	{</a>
<a name="ln325">		free(fDataBuffer);</a>
<a name="ln326">	}</a>
<a name="ln327"> </a>
<a name="ln328">	status_t Init()</a>
<a name="ln329">	{</a>
<a name="ln330">		status_t error = fRootFilterEntry.Init();</a>
<a name="ln331">		if (error != B_OK)</a>
<a name="ln332">			return error;</a>
<a name="ln333"> </a>
<a name="ln334">		fDataBufferSize = 64 * 1024;</a>
<a name="ln335">		fDataBuffer = malloc(fDataBufferSize);</a>
<a name="ln336">		if (fDataBuffer == NULL)</a>
<a name="ln337">			return B_NO_MEMORY;</a>
<a name="ln338"> </a>
<a name="ln339">		return B_OK;</a>
<a name="ln340">	}</a>
<a name="ln341"> </a>
<a name="ln342">	void SetBaseDirectory(int fd)</a>
<a name="ln343">	{</a>
<a name="ln344">		fBaseDirectory = fd;</a>
<a name="ln345">	}</a>
<a name="ln346"> </a>
<a name="ln347">	void SetPackageInfoFile(const char* infoFileName)</a>
<a name="ln348">	{</a>
<a name="ln349">		fInfoFileName = infoFileName;</a>
<a name="ln350">	}</a>
<a name="ln351"> </a>
<a name="ln352">	void SetExtractAll()</a>
<a name="ln353">	{</a>
<a name="ln354">		fRootFilterEntry.SetExplicit();</a>
<a name="ln355">	}</a>
<a name="ln356"> </a>
<a name="ln357">	status_t AddFilterEntry(const char* fileName)</a>
<a name="ln358">	{</a>
<a name="ln359">		// add all components of the path</a>
<a name="ln360">		Entry* entry = &amp;fRootFilterEntry;</a>
<a name="ln361">		while (*fileName != 0) {</a>
<a name="ln362">			const char* nextSlash = strchr(fileName, '/');</a>
<a name="ln363">			// no slash, just add the file name</a>
<a name="ln364">			if (nextSlash == NULL) {</a>
<a name="ln365">				return _AddFilterEntry(entry, fileName, strlen(fileName),</a>
<a name="ln366">					false, entry);</a>
<a name="ln367">			}</a>
<a name="ln368"> </a>
<a name="ln369">			// find the start of the next component, skipping slashes</a>
<a name="ln370">			const char* nextComponent = nextSlash + 1;</a>
<a name="ln371">			while (*nextComponent == '/')</a>
<a name="ln372">				nextComponent++;</a>
<a name="ln373"> </a>
<a name="ln374">			status_t error = _AddFilterEntry(entry, fileName,</a>
<a name="ln375">				nextSlash - fileName, *nextComponent != '\0', entry);</a>
<a name="ln376">			if (error != B_OK)</a>
<a name="ln377">				return error;</a>
<a name="ln378"> </a>
<a name="ln379">			fileName = nextComponent;</a>
<a name="ln380">		}</a>
<a name="ln381"> </a>
<a name="ln382">		return B_OK;</a>
<a name="ln383">	}</a>
<a name="ln384"> </a>
<a name="ln385">	Entry* FindFilterEntry(const char* fileName)</a>
<a name="ln386">	{</a>
<a name="ln387">		// add all components of the path</a>
<a name="ln388">		Entry* entry = &amp;fRootFilterEntry;</a>
<a name="ln389">		while (entry != NULL &amp;&amp; *fileName != 0) {</a>
<a name="ln390">			const char* nextSlash = strchr(fileName, '/');</a>
<a name="ln391">			// no slash, just add the file name</a>
<a name="ln392">			if (nextSlash == NULL)</a>
<a name="ln393">				return entry-&gt;FindChild(fileName);</a>
<a name="ln394"> </a>
<a name="ln395">			// find the start of the next component, skipping slashes</a>
<a name="ln396">			const char* nextComponent = nextSlash + 1;</a>
<a name="ln397">			while (*nextComponent == '/')</a>
<a name="ln398">				nextComponent++;</a>
<a name="ln399"> </a>
<a name="ln400">			BString componentName(fileName, nextSlash - fileName);</a>
<a name="ln401">			entry = entry-&gt;FindChild(componentName);</a>
<a name="ln402"> </a>
<a name="ln403">			fileName = nextComponent;</a>
<a name="ln404">		}</a>
<a name="ln405"> </a>
<a name="ln406">		return entry;</a>
<a name="ln407">	}</a>
<a name="ln408"> </a>
<a name="ln409">	virtual status_t HandleEntry(typename VersionPolicy::PackageEntry* entry)</a>
<a name="ln410">	{</a>
<a name="ln411">		// create a token</a>
<a name="ln412">		Token* token = new(std::nothrow) Token;</a>
<a name="ln413">		if (token == NULL)</a>
<a name="ln414">			return B_NO_MEMORY;</a>
<a name="ln415">		ObjectDeleter&lt;Token&gt; tokenDeleter(token);</a>
<a name="ln416"> </a>
<a name="ln417">		// check whether this entry shall be ignored or is implicit</a>
<a name="ln418">		Entry* parentFilterEntry;</a>
<a name="ln419">		bool implicit;</a>
<a name="ln420">		if (entry-&gt;Parent() != NULL) {</a>
<a name="ln421">			Token* parentToken = (Token*)entry-&gt;Parent()-&gt;UserToken();</a>
<a name="ln422">			if (parentToken == NULL) {</a>
<a name="ln423">				// parent is ignored, so ignore this entry, too</a>
<a name="ln424">				return B_OK;</a>
<a name="ln425">			}</a>
<a name="ln426"> </a>
<a name="ln427">			parentFilterEntry = parentToken-&gt;filterEntry;</a>
<a name="ln428">			implicit = parentToken-&gt;implicit;</a>
<a name="ln429">		} else {</a>
<a name="ln430">			parentFilterEntry = &amp;fRootFilterEntry;</a>
<a name="ln431">			implicit = fRootFilterEntry.IsImplicit();</a>
<a name="ln432">		}</a>
<a name="ln433"> </a>
<a name="ln434">		Entry* filterEntry = parentFilterEntry != NULL</a>
<a name="ln435">			? parentFilterEntry-&gt;FindChild(entry-&gt;Name()) : NULL;</a>
<a name="ln436"> </a>
<a name="ln437">		if (implicit &amp;&amp; filterEntry == NULL) {</a>
<a name="ln438">			// parent is implicit and the filter doesn't include this entry</a>
<a name="ln439">			// -- ignore it</a>
<a name="ln440">			return B_OK;</a>
<a name="ln441">		}</a>
<a name="ln442"> </a>
<a name="ln443">		// If the entry is in the filter, get its implicit flag.</a>
<a name="ln444">		if (filterEntry != NULL) {</a>
<a name="ln445">			implicit = filterEntry-&gt;IsImplicit();</a>
<a name="ln446">			filterEntry-&gt;SetSeen();</a>
<a name="ln447">		}</a>
<a name="ln448"> </a>
<a name="ln449">		token-&gt;filterEntry = filterEntry;</a>
<a name="ln450">		token-&gt;implicit = implicit;</a>
<a name="ln451"> </a>
<a name="ln452">		// get parent FD and the entry name</a>
<a name="ln453">		int parentFD;</a>
<a name="ln454">		const char* entryName;</a>
<a name="ln455">		_GetParentFDAndEntryName(entry, parentFD, entryName);</a>
<a name="ln456"> </a>
<a name="ln457">		// check whether something is in the way</a>
<a name="ln458">		struct stat st;</a>
<a name="ln459">		bool entryExists = fstatat(parentFD, entryName, &amp;st,</a>
<a name="ln460">			AT_SYMLINK_NOFOLLOW) == 0;</a>
<a name="ln461">		if (entryExists) {</a>
<a name="ln462">			if (S_ISREG(entry-&gt;Mode()) || S_ISLNK(entry-&gt;Mode())) {</a>
<a name="ln463">				// If the entry in the way is a regular file or a symlink,</a>
<a name="ln464">				// remove it, otherwise fail.</a>
<a name="ln465">				if (!S_ISREG(st.st_mode) &amp;&amp; !S_ISLNK(st.st_mode)) {</a>
<a name="ln466">					fprintf(stderr, &quot;Error: Can't create entry \&quot;%s\&quot;, since &quot;</a>
<a name="ln467">						&quot;something is in the way\n&quot;,</a>
<a name="ln468">						_EntryPath(entry).String());</a>
<a name="ln469">					return B_FILE_EXISTS;</a>
<a name="ln470">				}</a>
<a name="ln471"> </a>
<a name="ln472">				if (unlinkat(parentFD, entryName, 0) != 0) {</a>
<a name="ln473">					fprintf(stderr, &quot;Error: Failed to unlink entry \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln474">						_EntryPath(entry).String(), strerror(errno));</a>
<a name="ln475">					return errno;</a>
<a name="ln476">				}</a>
<a name="ln477"> </a>
<a name="ln478">				entryExists = false;</a>
<a name="ln479">			} else if (S_ISDIR(entry-&gt;Mode())) {</a>
<a name="ln480">				// If the entry in the way is a directory, merge, otherwise</a>
<a name="ln481">				// fail.</a>
<a name="ln482">				if (!S_ISDIR(st.st_mode)) {</a>
<a name="ln483">					fprintf(stderr, &quot;Error: Can't create directory \&quot;%s\&quot;, &quot;</a>
<a name="ln484">						&quot;since something is in the way\n&quot;,</a>
<a name="ln485">						_EntryPath(entry).String());</a>
<a name="ln486">					return B_FILE_EXISTS;</a>
<a name="ln487">				}</a>
<a name="ln488">			}</a>
<a name="ln489">		}</a>
<a name="ln490"> </a>
<a name="ln491">		// create the entry</a>
<a name="ln492">		int fd = -1;</a>
<a name="ln493">		if (S_ISREG(entry-&gt;Mode())) {</a>
<a name="ln494">			if (implicit) {</a>
<a name="ln495">				fprintf(stderr, &quot;Error: File \&quot;%s\&quot; was specified as a &quot;</a>
<a name="ln496">					&quot;path directory component.\n&quot;, _EntryPath(entry).String());</a>
<a name="ln497">				return B_BAD_VALUE;</a>
<a name="ln498">			}</a>
<a name="ln499"> </a>
<a name="ln500">			// create the file</a>
<a name="ln501">			fd = openat(parentFD, entryName, O_RDWR | O_CREAT | O_EXCL,</a>
<a name="ln502">				S_IRUSR | S_IWUSR);</a>
<a name="ln503">				// Note: We use read+write user permissions now -- so write</a>
<a name="ln504">				// operations (e.g. attributes) won't fail, but set them to the</a>
<a name="ln505">				// desired ones in HandleEntryDone().</a>
<a name="ln506">			if (fd &lt; 0) {</a>
<a name="ln507">				fprintf(stderr, &quot;Error: Failed to create file \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln508">					_EntryPath(entry).String(), strerror(errno));</a>
<a name="ln509">				return errno;</a>
<a name="ln510">			}</a>
<a name="ln511"> </a>
<a name="ln512">			// write data</a>
<a name="ln513">			status_t error = _ExtractFileData(fPackageFileReader, entry-&gt;Data(),</a>
<a name="ln514">				fd);</a>
<a name="ln515">			if (error != B_OK)</a>
<a name="ln516">				return error;</a>
<a name="ln517">		} else if (S_ISLNK(entry-&gt;Mode())) {</a>
<a name="ln518">			if (implicit) {</a>
<a name="ln519">				fprintf(stderr, &quot;Error: Symlink \&quot;%s\&quot; was specified as a &quot;</a>
<a name="ln520">					&quot;path directory component.\n&quot;, _EntryPath(entry).String());</a>
<a name="ln521">				return B_BAD_VALUE;</a>
<a name="ln522">			}</a>
<a name="ln523"> </a>
<a name="ln524">			// create the symlink</a>
<a name="ln525">			const char* symlinkPath = entry-&gt;SymlinkPath();</a>
<a name="ln526">			if (symlinkat(symlinkPath != NULL ? symlinkPath : &quot;&quot;, parentFD,</a>
<a name="ln527">					entryName) != 0) {</a>
<a name="ln528">				fprintf(stderr, &quot;Error: Failed to create symlink \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln529">					_EntryPath(entry).String(), strerror(errno));</a>
<a name="ln530">				return errno;</a>
<a name="ln531">			}</a>
<a name="ln532">// TODO: Set symlink permissions?</a>
<a name="ln533"> 		} else if (S_ISDIR(entry-&gt;Mode())) {</a>
<a name="ln534">			// create the directory, if necessary</a>
<a name="ln535">			if (!entryExists</a>
<a name="ln536">				&amp;&amp; mkdirat(parentFD, entryName, S_IRWXU) != 0) {</a>
<a name="ln537">				// Note: We use read+write+exec user permissions now -- so write</a>
<a name="ln538">				// operations (e.g. attributes) won't fail, but set them to the</a>
<a name="ln539">				// desired ones in HandleEntryDone().</a>
<a name="ln540">				fprintf(stderr, &quot;Error: Failed to create directory \&quot;%s\&quot;: &quot;</a>
<a name="ln541">					&quot;%s\n&quot;, _EntryPath(entry).String(), strerror(errno));</a>
<a name="ln542">				return errno;</a>
<a name="ln543">			}</a>
<a name="ln544">		} else {</a>
<a name="ln545">			fprintf(stderr, &quot;Error: Invalid file type for entry \&quot;%s\&quot;\n&quot;,</a>
<a name="ln546">				_EntryPath(entry).String());</a>
<a name="ln547">			return B_BAD_DATA;</a>
<a name="ln548">		}</a>
<a name="ln549"> </a>
<a name="ln550">		// If not done yet (symlink, dir), open the node -- we need the FD.</a>
<a name="ln551">		if (fd &lt; 0 &amp;&amp; (!implicit || S_ISDIR(entry-&gt;Mode()))) {</a>
<a name="ln552">			fd = openat(parentFD, entryName, O_RDONLY | O_NOTRAVERSE);</a>
<a name="ln553">			if (fd &lt; 0) {</a>
<a name="ln554">				fprintf(stderr, &quot;Error: Failed to open entry \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln555">					_EntryPath(entry).String(), strerror(errno));</a>
<a name="ln556">				return errno;</a>
<a name="ln557">			}</a>
<a name="ln558">		}</a>
<a name="ln559">		token-&gt;fd = fd;</a>
<a name="ln560"> </a>
<a name="ln561">		// set the file times</a>
<a name="ln562">		if (!entryExists &amp;&amp; !implicit) {</a>
<a name="ln563">			timespec times[2] = {entry-&gt;AccessTime(), entry-&gt;ModifiedTime()};</a>
<a name="ln564">			futimens(fd, times);</a>
<a name="ln565"> </a>
<a name="ln566">			// set user/group</a>
<a name="ln567">			// TODO:...</a>
<a name="ln568">		}</a>
<a name="ln569"> </a>
<a name="ln570">		entry-&gt;SetUserToken(tokenDeleter.Detach());</a>
<a name="ln571">		return B_OK;</a>
<a name="ln572">	}</a>
<a name="ln573"> </a>
<a name="ln574">	virtual status_t HandleEntryAttribute(</a>
<a name="ln575">		typename VersionPolicy::PackageEntry* entry,</a>
<a name="ln576">		typename VersionPolicy::PackageEntryAttribute* attribute)</a>
<a name="ln577">	{</a>
<a name="ln578">		// don't write attributes of ignored or implicit entries</a>
<a name="ln579">		Token* token = (Token*)entry-&gt;UserToken();</a>
<a name="ln580">		if (token == NULL || token-&gt;implicit)</a>
<a name="ln581">			return B_OK;</a>
<a name="ln582"> </a>
<a name="ln583">		int entryFD = token-&gt;fd;</a>
<a name="ln584"> </a>
<a name="ln585">		// create the attribute</a>
<a name="ln586">		int fd = fs_fopen_attr(entryFD, attribute-&gt;Name(), attribute-&gt;Type(),</a>
<a name="ln587">			O_WRONLY | O_CREAT | O_TRUNC);</a>
<a name="ln588">		if (fd &lt; 0) {</a>
<a name="ln589">			int parentFD;</a>
<a name="ln590">			const char* entryName;</a>
<a name="ln591">			_GetParentFDAndEntryName(entry, parentFD, entryName);</a>
<a name="ln592"> </a>
<a name="ln593">			fprintf(stderr, &quot;Error: Failed to create attribute \&quot;%s\&quot; of &quot;</a>
<a name="ln594">				&quot;file \&quot;%s\&quot;: %s\n&quot;, attribute-&gt;Name(),</a>
<a name="ln595">				_EntryPath(entry).String(), strerror(errno));</a>
<a name="ln596">			return errno;</a>
<a name="ln597">		}</a>
<a name="ln598"> </a>
<a name="ln599">		// write data</a>
<a name="ln600">		status_t error = _ExtractFileData(fPackageFileReader, attribute-&gt;Data(),</a>
<a name="ln601">			fd);</a>
<a name="ln602"> </a>
<a name="ln603">		fs_close_attr(fd);</a>
<a name="ln604"> </a>
<a name="ln605">		return error;</a>
<a name="ln606">	}</a>
<a name="ln607"> </a>
<a name="ln608">	virtual status_t HandleEntryDone(</a>
<a name="ln609">		typename VersionPolicy::PackageEntry* entry)</a>
<a name="ln610">	{</a>
<a name="ln611">		Token* token = (Token*)entry-&gt;UserToken();</a>
<a name="ln612"> </a>
<a name="ln613">		// set the node permissions for non-symlinks</a>
<a name="ln614">		if (token != NULL &amp;&amp; !S_ISLNK(entry-&gt;Mode())) {</a>
<a name="ln615">			// get parent FD and entry name</a>
<a name="ln616">			int parentFD;</a>
<a name="ln617">			const char* entryName;</a>
<a name="ln618">			_GetParentFDAndEntryName(entry, parentFD, entryName);</a>
<a name="ln619"> </a>
<a name="ln620">			if (fchmodat(parentFD, entryName, entry-&gt;Mode() &amp; ALLPERMS,</a>
<a name="ln621">					/*AT_SYMLINK_NOFOLLOW*/0) != 0) {</a>
<a name="ln622">				fprintf(stderr, &quot;Warning: Failed to set permissions of file &quot;</a>
<a name="ln623">					&quot;\&quot;%s\&quot;: %s\n&quot;, _EntryPath(entry).String(),</a>
<a name="ln624">					strerror(errno));</a>
<a name="ln625">			}</a>
<a name="ln626">		}</a>
<a name="ln627"> </a>
<a name="ln628">		if (token != NULL) {</a>
<a name="ln629">			delete token;</a>
<a name="ln630">			entry-&gt;SetUserToken(NULL);</a>
<a name="ln631">		}</a>
<a name="ln632"> </a>
<a name="ln633">		return B_OK;</a>
<a name="ln634">	}</a>
<a name="ln635"> </a>
<a name="ln636">	virtual status_t HandlePackageAttribute(</a>
<a name="ln637">		const BPackageInfoAttributeValue&amp; value)</a>
<a name="ln638">	{</a>
<a name="ln639">		return B_OK;</a>
<a name="ln640">	}</a>
<a name="ln641"> </a>
<a name="ln642">	virtual void HandleErrorOccurred()</a>
<a name="ln643">	{</a>
<a name="ln644">		fErrorOccurred = true;</a>
<a name="ln645">	}</a>
<a name="ln646"> </a>
<a name="ln647">private:</a>
<a name="ln648">	struct Token {</a>
<a name="ln649">		Entry*	filterEntry;</a>
<a name="ln650">		int		fd;</a>
<a name="ln651">		bool	implicit;</a>
<a name="ln652"> </a>
<a name="ln653">		Token()</a>
<a name="ln654">			:</a>
<a name="ln655">			filterEntry(NULL),</a>
<a name="ln656">			fd(-1),</a>
<a name="ln657">			implicit(true)</a>
<a name="ln658">		{</a>
<a name="ln659">		}</a>
<a name="ln660"> </a>
<a name="ln661">		~Token()</a>
<a name="ln662">		{</a>
<a name="ln663">			if (fd &gt;= 0)</a>
<a name="ln664">				close(fd);</a>
<a name="ln665">		}</a>
<a name="ln666">	};</a>
<a name="ln667"> </a>
<a name="ln668">private:</a>
<a name="ln669">	status_t _AddFilterEntry(Entry* parentEntry, const char* _name,</a>
<a name="ln670">		size_t nameLength, bool implicit, Entry*&amp; _entry)</a>
<a name="ln671">	{</a>
<a name="ln672">		BString name(_name, nameLength);</a>
<a name="ln673">		if (name.IsEmpty())</a>
<a name="ln674">			return B_NO_MEMORY;</a>
<a name="ln675"> </a>
<a name="ln676">		return Entry::Create(parentEntry, name.String(), implicit, _entry);</a>
<a name="ln677">	}</a>
<a name="ln678"> </a>
<a name="ln679">	void _GetParentFDAndEntryName(typename VersionPolicy::PackageEntry* entry,</a>
<a name="ln680">		int&amp; _parentFD, const char*&amp; _entryName)</a>
<a name="ln681">	{</a>
<a name="ln682">		_entryName = entry-&gt;Name();</a>
<a name="ln683"> </a>
<a name="ln684">		if (fInfoFileName != NULL</a>
<a name="ln685">			&amp;&amp; strcmp(_entryName, VersionPolicy::PackageInfoFileName()) == 0) {</a>
<a name="ln686">			_parentFD = AT_FDCWD;</a>
<a name="ln687">			_entryName = fInfoFileName;</a>
<a name="ln688">		} else {</a>
<a name="ln689">			_parentFD = entry-&gt;Parent() != NULL</a>
<a name="ln690">				? ((Token*)entry-&gt;Parent()-&gt;UserToken())-&gt;fd : fBaseDirectory;</a>
<a name="ln691">		}</a>
<a name="ln692">	}</a>
<a name="ln693"> </a>
<a name="ln694">	BString _EntryPath(const typename VersionPolicy::PackageEntry* entry)</a>
<a name="ln695">	{</a>
<a name="ln696">		BString path;</a>
<a name="ln697"> </a>
<a name="ln698">		if (const typename VersionPolicy::PackageEntry* parent</a>
<a name="ln699">				= entry-&gt;Parent()) {</a>
<a name="ln700">			path = _EntryPath(parent);</a>
<a name="ln701">			path &lt;&lt; '/';</a>
<a name="ln702">		}</a>
<a name="ln703"> </a>
<a name="ln704">		path &lt;&lt; entry-&gt;Name();</a>
<a name="ln705">		return path;</a>
<a name="ln706">	}</a>
<a name="ln707"> </a>
<a name="ln708">	status_t _ExtractFileData(</a>
<a name="ln709">		typename VersionPolicy::HeapReaderBase* dataReader,</a>
<a name="ln710">		const typename VersionPolicy::PackageData&amp; data, int fd)</a>
<a name="ln711">	{</a>
<a name="ln712">		// create a PackageDataReader</a>
<a name="ln713">		BAbstractBufferedDataReader* reader;</a>
<a name="ln714">		status_t error = VersionPolicy::CreatePackageDataReader(fBufferPool,</a>
<a name="ln715">			dataReader, data, reader);</a>
<a name="ln716">		if (error != B_OK)</a>
<a name="ln717">			return error;</a>
<a name="ln718">		ObjectDeleter&lt;BAbstractBufferedDataReader&gt; readerDeleter(reader);</a>
<a name="ln719"> </a>
<a name="ln720">		// write the data</a>
<a name="ln721">		off_t bytesRemaining = VersionPolicy::PackageDataUncompressedSize(data);</a>
<a name="ln722">		off_t offset = 0;</a>
<a name="ln723">		while (bytesRemaining &gt; 0) {</a>
<a name="ln724">			// read</a>
<a name="ln725">			size_t toCopy = std::min((off_t)fDataBufferSize, bytesRemaining);</a>
<a name="ln726">			error = reader-&gt;ReadData(offset, fDataBuffer, toCopy);</a>
<a name="ln727">			if (error != B_OK) {</a>
<a name="ln728">				fprintf(stderr, &quot;Error: Failed to read data: %s\n&quot;,</a>
<a name="ln729">					strerror(error));</a>
<a name="ln730">				return error;</a>
<a name="ln731">			}</a>
<a name="ln732"> </a>
<a name="ln733">			// write</a>
<a name="ln734">			ssize_t bytesWritten = write_pos(fd, offset, fDataBuffer, toCopy);</a>
<a name="ln735">			if (bytesWritten &lt; 0) {</a>
<a name="ln736">				fprintf(stderr, &quot;Error: Failed to write data: %s\n&quot;,</a>
<a name="ln737">					strerror(errno));</a>
<a name="ln738">				return errno;</a>
<a name="ln739">			}</a>
<a name="ln740">			if ((size_t)bytesWritten != toCopy) {</a>
<a name="ln741">				fprintf(stderr, &quot;Error: Failed to write all data (%zd of &quot;</a>
<a name="ln742">					&quot;%zu)\n&quot;, bytesWritten, toCopy);</a>
<a name="ln743">				return B_ERROR;</a>
<a name="ln744">			}</a>
<a name="ln745"> </a>
<a name="ln746">			offset += toCopy;</a>
<a name="ln747">			bytesRemaining -= toCopy;</a>
<a name="ln748">		}</a>
<a name="ln749"> </a>
<a name="ln750">		return B_OK;</a>
<a name="ln751">	}</a>
<a name="ln752"> </a>
<a name="ln753">private:</a>
<a name="ln754">	BBufferPool*							fBufferPool;</a>
<a name="ln755">	typename VersionPolicy::HeapReaderBase*	fPackageFileReader;</a>
<a name="ln756">	void*									fDataBuffer;</a>
<a name="ln757">	size_t									fDataBufferSize;</a>
<a name="ln758">	Entry									fRootFilterEntry;</a>
<a name="ln759">	int										fBaseDirectory;</a>
<a name="ln760">	const char*								fInfoFileName;</a>
<a name="ln761">	bool									fErrorOccurred;</a>
<a name="ln762">};</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">template&lt;typename VersionPolicy&gt;</a>
<a name="ln766">static void</a>
<a name="ln767">do_extract(const char* packageFileName, const char* changeToDirectory,</a>
<a name="ln768">	const char* packageInfoFileName, const char* const* explicitEntries,</a>
<a name="ln769">	int explicitEntryCount, bool ignoreVersionError)</a>
<a name="ln770">{</a>
<a name="ln771">	// open package</a>
<a name="ln772">	BStandardErrorOutput errorOutput;</a>
<a name="ln773">	BBlockBufferPoolNoLock bufferPool(VersionPolicy::BufferSize(), 2);</a>
<a name="ln774">	if (bufferPool.Init() != B_OK) {</a>
<a name="ln775">		errorOutput.PrintError(&quot;Error: Out of memory!\n&quot;);</a>
<a name="ln776">		exit(1);</a>
<a name="ln777">	}</a>
<a name="ln778"> </a>
<a name="ln779">	typename VersionPolicy::PackageReader packageReader(&amp;errorOutput);</a>
<a name="ln780">	status_t error = VersionPolicy::InitReader(packageReader, packageFileName);</a>
<a name="ln781">	if (error != B_OK) {</a>
<a name="ln782">		if (ignoreVersionError &amp;&amp; error == B_MISMATCHED_VALUES)</a>
<a name="ln783">			return;</a>
<a name="ln784">		exit(1);</a>
<a name="ln785">	}</a>
<a name="ln786"> </a>
<a name="ln787">	typename VersionPolicy::HeapReaderBase* heapReader;</a>
<a name="ln788">	bool mustDeleteHeapReader;</a>
<a name="ln789">	error = VersionPolicy::GetHeapReader(packageReader, heapReader,</a>
<a name="ln790">		mustDeleteHeapReader);</a>
<a name="ln791">	if (error != B_OK) {</a>
<a name="ln792">		fprintf(stderr, &quot;Error: Failed to create heap reader: \&quot;%s\&quot;\n&quot;,</a>
<a name="ln793">			strerror(error));</a>
<a name="ln794">		exit(1);</a>
<a name="ln795">	}</a>
<a name="ln796">	ObjectDeleter&lt;BDataReader&gt; heapReaderDeleter(</a>
<a name="ln797">		mustDeleteHeapReader ? heapReader : NULL);</a>
<a name="ln798"> </a>
<a name="ln799">	PackageContentExtractHandler&lt;VersionPolicy&gt; handler(&amp;bufferPool,</a>
<a name="ln800">		heapReader);</a>
<a name="ln801">	error = handler.Init();</a>
<a name="ln802">	if (error != B_OK)</a>
<a name="ln803">		exit(1);</a>
<a name="ln804"> </a>
<a name="ln805">	// If entries to extract have been specified explicitly, add those to the</a>
<a name="ln806">	// filtered ones.</a>
<a name="ln807">	if (explicitEntryCount &gt; 0) {</a>
<a name="ln808">		for (int i = 0; i &lt; explicitEntryCount; i++) {</a>
<a name="ln809">			const char* entryName = explicitEntries[i];</a>
<a name="ln810">			if (entryName[0] == '\0' || entryName[0] == '/') {</a>
<a name="ln811">				fprintf(stderr, &quot;Error: Invalid entry name: \&quot;%s\&quot;\n&quot;,</a>
<a name="ln812">					entryName);</a>
<a name="ln813">				exit(1);</a>
<a name="ln814">			}</a>
<a name="ln815">			if (handler.AddFilterEntry(entryName) != B_OK)</a>
<a name="ln816">				exit(1);</a>
<a name="ln817">		}</a>
<a name="ln818">	} else</a>
<a name="ln819">		handler.SetExtractAll();</a>
<a name="ln820"> </a>
<a name="ln821">	// get the target directory, if requested</a>
<a name="ln822">	if (changeToDirectory != NULL) {</a>
<a name="ln823">		int currentDirFD = open(changeToDirectory, O_RDONLY);</a>
<a name="ln824">		if (currentDirFD &lt; 0) {</a>
<a name="ln825">			fprintf(stderr, &quot;Error: Failed to change the current working &quot;</a>
<a name="ln826">				&quot;directory to \&quot;%s\&quot;: %s\n&quot;, changeToDirectory,</a>
<a name="ln827">				strerror(errno));</a>
<a name="ln828">			exit(1);</a>
<a name="ln829">		}</a>
<a name="ln830"> </a>
<a name="ln831">		handler.SetBaseDirectory(currentDirFD);</a>
<a name="ln832">	}</a>
<a name="ln833"> </a>
<a name="ln834">	// If a package info file name is given, set it.</a>
<a name="ln835">	if (packageInfoFileName != NULL)</a>
<a name="ln836">		handler.SetPackageInfoFile(packageInfoFileName);</a>
<a name="ln837"> </a>
<a name="ln838">	// extract</a>
<a name="ln839">	error = packageReader.ParseContent(&amp;handler);</a>
<a name="ln840">	if (error != B_OK)</a>
<a name="ln841">		exit(1);</a>
<a name="ln842"> </a>
<a name="ln843">	// check whether all explicitly specified entries have been extracted</a>
<a name="ln844">	if (explicitEntryCount &gt; 0) {</a>
<a name="ln845">		for (int i = 0; i &lt; explicitEntryCount; i++) {</a>
<a name="ln846">			if (Entry* entry = handler.FindFilterEntry(explicitEntries[i])) {</a>
<a name="ln847">				if (!entry-&gt;Seen()) {</a>
<a name="ln848">					fprintf(stderr, &quot;Warning: Entry \&quot;%s\&quot; not found.\n&quot;,</a>
<a name="ln849">						explicitEntries[i]);</a>
<a name="ln850">				}</a>
<a name="ln851">			}</a>
<a name="ln852">		}</a>
<a name="ln853">	}</a>
<a name="ln854"> </a>
<a name="ln855">	exit(0);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858"> </a>
<a name="ln859">int</a>
<a name="ln860">command_extract(int argc, const char* const* argv)</a>
<a name="ln861">{</a>
<a name="ln862">	const char* changeToDirectory = NULL;</a>
<a name="ln863">	const char* packageInfoFileName = NULL;</a>
<a name="ln864"> </a>
<a name="ln865">	while (true) {</a>
<a name="ln866">		static struct option sLongOptions[] = {</a>
<a name="ln867">			{ &quot;help&quot;, no_argument, 0, 'h' },</a>
<a name="ln868">			{ 0, 0, 0, 0 }</a>
<a name="ln869">		};</a>
<a name="ln870"> </a>
<a name="ln871">		opterr = 0; // don't print errors</a>
<a name="ln872">		int c = getopt_long(argc, (char**)argv, &quot;+C:hi:&quot;, sLongOptions, NULL);</a>
<a name="ln873">		if (c == -1)</a>
<a name="ln874">			break;</a>
<a name="ln875"> </a>
<a name="ln876">		switch (c) {</a>
<a name="ln877">			case 'C':</a>
<a name="ln878">				changeToDirectory = optarg;</a>
<a name="ln879">				break;</a>
<a name="ln880"> </a>
<a name="ln881">			case 'h':</a>
<a name="ln882">				print_usage_and_exit(false);</a>
<a name="ln883">				break;</a>
<a name="ln884"> </a>
<a name="ln885">			case 'i':</a>
<a name="ln886">				packageInfoFileName = optarg;</a>
<a name="ln887">				break;</a>
<a name="ln888"> </a>
<a name="ln889">			default:</a>
<a name="ln890">				print_usage_and_exit(true);</a>
<a name="ln891">				break;</a>
<a name="ln892">		}</a>
<a name="ln893">	}</a>
<a name="ln894"> </a>
<a name="ln895">	// At least one argument should remain -- the package file name. Any further</a>
<a name="ln896">	// arguments are the names of the entries to extract.</a>
<a name="ln897">	if (optind + 1 &gt; argc)</a>
<a name="ln898">		print_usage_and_exit(true);</a>
<a name="ln899"> </a>
<a name="ln900">	const char* packageFileName = argv[optind++];</a>
<a name="ln901">	const char* const* explicitEntries = argv + optind;</a>
<a name="ln902">	int explicitEntryCount = argc - optind;</a>
<a name="ln903">	do_extract&lt;VersionPolicyV2&gt;(packageFileName, changeToDirectory,</a>
<a name="ln904">		packageInfoFileName, explicitEntries, explicitEntryCount, true);</a>
<a name="ln905">	do_extract&lt;VersionPolicyV1&gt;(packageFileName, changeToDirectory,</a>
<a name="ln906">		packageInfoFileName, explicitEntries, explicitEntryCount, false);</a>
<a name="ln907"> </a>
<a name="ln908">	return 0;</a>
<a name="ln909">}</a>

</code></pre>
<div class="balloon" rel="164"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fHashTableNext.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
