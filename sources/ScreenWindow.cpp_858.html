
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ScreenWindow.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2015 Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan Aßmus, superstippi@gmx.de</a>
<a name="ln7"> *		Andrew Bachmann</a>
<a name="ln8"> *		Stefano Ceccherini, burton666@libero.it</a>
<a name="ln9"> *		Alexandre Deckner, alex@zappotek.com</a>
<a name="ln10"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln11"> *		Rene Gollent, rene@gollent.com</a>
<a name="ln12"> *		Thomas Kurschel</a>
<a name="ln13"> *		Rafael Romo</a>
<a name="ln14"> *		John Scipione, jscipione@gmail.com</a>
<a name="ln15"> */</a>
<a name="ln16"> </a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;ScreenWindow.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;stdio.h&gt;</a>
<a name="ln21">#include &lt;stdlib.h&gt;</a>
<a name="ln22">#include &lt;strings.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;Alert.h&gt;</a>
<a name="ln25">#include &lt;Application.h&gt;</a>
<a name="ln26">#include &lt;Box.h&gt;</a>
<a name="ln27">#include &lt;Button.h&gt;</a>
<a name="ln28">#include &lt;Catalog.h&gt;</a>
<a name="ln29">#include &lt;ControlLook.h&gt;</a>
<a name="ln30">#include &lt;Directory.h&gt;</a>
<a name="ln31">#include &lt;File.h&gt;</a>
<a name="ln32">#include &lt;FindDirectory.h&gt;</a>
<a name="ln33">#include &lt;InterfaceDefs.h&gt;</a>
<a name="ln34">#include &lt;LayoutBuilder.h&gt;</a>
<a name="ln35">#include &lt;MenuBar.h&gt;</a>
<a name="ln36">#include &lt;MenuItem.h&gt;</a>
<a name="ln37">#include &lt;MenuField.h&gt;</a>
<a name="ln38">#include &lt;Messenger.h&gt;</a>
<a name="ln39">#include &lt;Path.h&gt;</a>
<a name="ln40">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln41">#include &lt;Screen.h&gt;</a>
<a name="ln42">#include &lt;SpaceLayoutItem.h&gt;</a>
<a name="ln43">#include &lt;Spinner.h&gt;</a>
<a name="ln44">#include &lt;String.h&gt;</a>
<a name="ln45">#include &lt;StringView.h&gt;</a>
<a name="ln46">#include &lt;Roster.h&gt;</a>
<a name="ln47">#include &lt;Window.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;InterfacePrivate.h&gt;</a>
<a name="ln50"> </a>
<a name="ln51">#include &quot;AlertWindow.h&quot;</a>
<a name="ln52">#include &quot;Constants.h&quot;</a>
<a name="ln53">#include &quot;RefreshWindow.h&quot;</a>
<a name="ln54">#include &quot;MonitorView.h&quot;</a>
<a name="ln55">#include &quot;ScreenSettings.h&quot;</a>
<a name="ln56">#include &quot;Utility.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">/* Note, this headers defines a *private* interface to the Radeon accelerant.</a>
<a name="ln59"> * It's a solution that works with the current BeOS interface that Haiku</a>
<a name="ln60"> * adopted.</a>
<a name="ln61"> * However, it's not a nice and clean solution. Don't use this header in any</a>
<a name="ln62"> * application if you can avoid it. No other driver is using this, or should</a>
<a name="ln63"> * be using this.</a>
<a name="ln64"> * It will be replaced as soon as we introduce an updated accelerant interface</a>
<a name="ln65"> * which may even happen before R1 hits the streets.</a>
<a name="ln66"> */</a>
<a name="ln67">#include &quot;multimon.h&quot;	// the usual: DANGER WILL, ROBINSON!</a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln71">#define B_TRANSLATION_CONTEXT &quot;Screen&quot;</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">const char* kBackgroundsSignature = &quot;application/x-vnd.Haiku-Backgrounds&quot;;</a>
<a name="ln75"> </a>
<a name="ln76">// list of officially supported colour spaces</a>
<a name="ln77">static const struct {</a>
<a name="ln78">	color_space	space;</a>
<a name="ln79">	int32		bits_per_pixel;</a>
<a name="ln80">	const char*	label;</a>
<a name="ln81">} kColorSpaces[] = {</a>
<a name="ln82">	{ B_CMAP8, 8, B_TRANSLATE(&quot;8 bits/pixel, 256 colors&quot;) },</a>
<a name="ln83">	{ B_RGB15, 15, B_TRANSLATE(&quot;15 bits/pixel, 32768 colors&quot;) },</a>
<a name="ln84">	{ B_RGB16, 16, B_TRANSLATE(&quot;16 bits/pixel, 65536 colors&quot;) },</a>
<a name="ln85">	{ B_RGB24, 24, B_TRANSLATE(&quot;24 bits/pixel, 16 Million colors&quot;) },</a>
<a name="ln86">	{ B_RGB32, 32, B_TRANSLATE(&quot;32 bits/pixel, 16 Million colors&quot;) }</a>
<a name="ln87">};</a>
<a name="ln88">static const int32 kColorSpaceCount</a>
<a name="ln89">	= sizeof(kColorSpaces) / sizeof(kColorSpaces[0]);</a>
<a name="ln90"> </a>
<a name="ln91">// list of standard refresh rates</a>
<a name="ln92">static const int32 kRefreshRates[] = { 60, 70, 72, 75, 80, 85, 95, 100 };</a>
<a name="ln93">static const int32 kRefreshRateCount</a>
<a name="ln94">	= sizeof(kRefreshRates) / sizeof(kRefreshRates[0]);</a>
<a name="ln95"> </a>
<a name="ln96">// list of combine modes</a>
<a name="ln97">static const struct {</a>
<a name="ln98">	combine_mode	mode;</a>
<a name="ln99">	const char		*name;</a>
<a name="ln100">} kCombineModes[] = {</a>
<a name="ln101">	{ kCombineDisable, B_TRANSLATE(&quot;disable&quot;) },</a>
<a name="ln102">	{ kCombineHorizontally, B_TRANSLATE(&quot;horizontally&quot;) },</a>
<a name="ln103">	{ kCombineVertically, B_TRANSLATE(&quot;vertically&quot;) }</a>
<a name="ln104">};</a>
<a name="ln105">static const int32 kCombineModeCount</a>
<a name="ln106">	= sizeof(kCombineModes) / sizeof(kCombineModes[0]);</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">static BString</a>
<a name="ln110">tv_standard_to_string(uint32 mode)</a>
<a name="ln111">{</a>
<a name="ln112">	switch (mode) {</a>
<a name="ln113">		case 0:		return &quot;disabled&quot;;</a>
<a name="ln114">		case 1:		return &quot;NTSC&quot;;</a>
<a name="ln115">		case 2:		return &quot;NTSC Japan&quot;;</a>
<a name="ln116">		case 3:		return &quot;PAL BDGHI&quot;;</a>
<a name="ln117">		case 4:		return &quot;PAL M&quot;;</a>
<a name="ln118">		case 5:		return &quot;PAL N&quot;;</a>
<a name="ln119">		case 6:		return &quot;SECAM&quot;;</a>
<a name="ln120">		case 101:	return &quot;NTSC 443&quot;;</a>
<a name="ln121">		case 102:	return &quot;PAL 60&quot;;</a>
<a name="ln122">		case 103:	return &quot;PAL NC&quot;;</a>
<a name="ln123">		default:</a>
<a name="ln124">		{</a>
<a name="ln125">			BString name;</a>
<a name="ln126">			name &lt;&lt; &quot;??? (&quot; &lt;&lt; mode &lt;&lt; &quot;)&quot;;</a>
<a name="ln127"> </a>
<a name="ln128">			return name;</a>
<a name="ln129">		}</a>
<a name="ln130">	}</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">static void</a>
<a name="ln135">resolution_to_string(screen_mode&amp; mode, BString &amp;string)</a>
<a name="ln136">{</a>
<a name="ln137">	string &lt;&lt; mode.width &lt;&lt; &quot; x &quot; &lt;&lt; mode.height;</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140"> </a>
<a name="ln141">static void</a>
<a name="ln142">refresh_rate_to_string(float refresh, BString &amp;string,</a>
<a name="ln143">	bool appendUnit = true, bool alwaysWithFraction = false)</a>
<a name="ln144">{</a>
<a name="ln145">	snprintf(string.LockBuffer(32), 32, &quot;%.*g&quot;, refresh &gt;= 100.0 ? 4 : 3,</a>
<a name="ln146">		refresh);</a>
<a name="ln147">	string.UnlockBuffer();</a>
<a name="ln148"> </a>
<a name="ln149">	if (appendUnit)</a>
<a name="ln150">		string &lt;&lt; &quot; &quot; &lt;&lt; B_TRANSLATE(&quot;Hz&quot;);</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">static const char*</a>
<a name="ln155">screen_errors(status_t status)</a>
<a name="ln156">{</a>
<a name="ln157">	switch (status) {</a>
<a name="ln158">		case B_ENTRY_NOT_FOUND:</a>
<a name="ln159">			return B_TRANSLATE(&quot;Unknown mode&quot;);</a>
<a name="ln160">		// TODO: add more?</a>
<a name="ln161"> </a>
<a name="ln162">		default:</a>
<a name="ln163">			return strerror(status);</a>
<a name="ln164">	}</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">//	#pragma mark - ScreenWindow</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">ScreenWindow::ScreenWindow(ScreenSettings* settings)</a>
<a name="ln172">	:</a>
<a name="ln173">	BWindow(settings-&gt;WindowFrame(), B_TRANSLATE_SYSTEM_NAME(&quot;Screen&quot;),</a>
<a name="ln174">		B_TITLED_WINDOW, B_NOT_RESIZABLE | B_NOT_ZOOMABLE</a>
<a name="ln175">			| B_AUTO_UPDATE_SIZE_LIMITS, B_ALL_WORKSPACES),</a>
<a name="ln176">	fIsVesa(false),</a>
<a name="ln177">	fBootWorkspaceApplied(false),</a>
<a name="ln178">	fOtherRefresh(NULL),</a>
<a name="ln179">	fScreenMode(this),</a>
<a name="ln180">	fUndoScreenMode(this),</a>
<a name="ln181">	fModified(false)</a>
<a name="ln182">{</a>
<a name="ln183">	BScreen screen(this);</a>
<a name="ln184"> </a>
<a name="ln185">	accelerant_device_info info;</a>
<a name="ln186">	if (screen.GetDeviceInfo(&amp;info) == B_OK</a>
<a name="ln187">		&amp;&amp; !strcasecmp(info.chipset, &quot;VESA&quot;))</a>
<a name="ln188">		fIsVesa = true;</a>
<a name="ln189"> </a>
<a name="ln190">	_UpdateOriginal();</a>
<a name="ln191">	_BuildSupportedColorSpaces();</a>
<a name="ln192">	fActive = fSelected = fOriginal;</a>
<a name="ln193"> </a>
<a name="ln194">	fSettings = settings;</a>
<a name="ln195"> </a>
<a name="ln196">	// we need the &quot;Current Workspace&quot; first to get its height</a>
<a name="ln197"> </a>
<a name="ln198">	BPopUpMenu* popUpMenu = new BPopUpMenu(B_TRANSLATE(&quot;Current workspace&quot;),</a>
<a name="ln199">		true, true);</a>
<a name="ln200">	fAllWorkspacesItem = new BMenuItem(B_TRANSLATE(&quot;All workspaces&quot;),</a>
<a name="ln201">		new BMessage(WORKSPACE_CHECK_MSG));</a>
<a name="ln202">	popUpMenu-&gt;AddItem(fAllWorkspacesItem);</a>
<a name="ln203">	BMenuItem *item = new BMenuItem(B_TRANSLATE(&quot;Current workspace&quot;),</a>
<a name="ln204">		new BMessage(WORKSPACE_CHECK_MSG));</a>
<a name="ln205"> </a>
<a name="ln206">	popUpMenu-&gt;AddItem(item);</a>
<a name="ln207">	fAllWorkspacesItem-&gt;SetMarked(true);</a>
<a name="ln208"> </a>
<a name="ln209">	BMenuField* workspaceMenuField = new BMenuField(&quot;WorkspaceMenu&quot;, NULL,</a>
<a name="ln210">		popUpMenu);</a>
<a name="ln211">	workspaceMenuField-&gt;ResizeToPreferred();</a>
<a name="ln212"> </a>
<a name="ln213">	// box on the left with workspace count and monitor view</a>
<a name="ln214"> </a>
<a name="ln215">	BBox* screenBox = new BBox(&quot;screen box&quot;);</a>
<a name="ln216">	BGroupLayout* layout = new BGroupLayout(B_VERTICAL, B_USE_SMALL_SPACING);</a>
<a name="ln217">	layout-&gt;SetInsets(B_USE_DEFAULT_SPACING, B_USE_DEFAULT_SPACING,</a>
<a name="ln218">		B_USE_DEFAULT_SPACING, B_USE_DEFAULT_SPACING);</a>
<a name="ln219">	screenBox-&gt;SetLayout(layout);</a>
<a name="ln220"> </a>
<a name="ln221">	fMonitorInfo = new BStringView(&quot;monitor info&quot;, &quot;&quot;);</a>
<a name="ln222">	fMonitorInfo-&gt;SetAlignment(B_ALIGN_CENTER);</a>
<a name="ln223">	screenBox-&gt;AddChild(fMonitorInfo);</a>
<a name="ln224"> </a>
<a name="ln225">	fDeviceInfo = new BStringView(&quot;monitor info&quot;, &quot;&quot;);</a>
<a name="ln226">	fDeviceInfo-&gt;SetAlignment(B_ALIGN_CENTER);</a>
<a name="ln227">	screenBox-&gt;AddChild(fDeviceInfo);</a>
<a name="ln228"> </a>
<a name="ln229">	float scaling = std::max(1.0f, be_plain_font-&gt;Size() / 12.0f);</a>
<a name="ln230">	fMonitorView = new MonitorView(BRect(0.0, 0.0, 80.0 * scaling,</a>
<a name="ln231">			80.0 * scaling), &quot;monitor&quot;, screen.Frame().IntegerWidth() + 1,</a>
<a name="ln232">		screen.Frame().IntegerHeight() + 1);</a>
<a name="ln233">	screenBox-&gt;AddChild(fMonitorView);</a>
<a name="ln234"> </a>
<a name="ln235">	BStringView* workspaces = new BStringView(&quot;workspaces&quot;,</a>
<a name="ln236">		B_TRANSLATE(&quot;Workspaces&quot;));</a>
<a name="ln237">	workspaces-&gt;SetAlignment(B_ALIGN_CENTER);</a>
<a name="ln238"> </a>
<a name="ln239">	fColumnsControl = new BSpinner(&quot;columns&quot;, B_TRANSLATE(&quot;Columns:&quot;),</a>
<a name="ln240">		new BMessage(kMsgWorkspaceColumnsChanged));</a>
<a name="ln241">	fColumnsControl-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln242">	fColumnsControl-&gt;SetRange(1, 32);</a>
<a name="ln243"> </a>
<a name="ln244">	fRowsControl = new BSpinner(&quot;rows&quot;, B_TRANSLATE(&quot;Rows:&quot;),</a>
<a name="ln245">		new BMessage(kMsgWorkspaceRowsChanged));</a>
<a name="ln246">	fRowsControl-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln247">	fRowsControl-&gt;SetRange(1, 32);</a>
<a name="ln248"> </a>
<a name="ln249">	uint32 columns;</a>
<a name="ln250">	uint32 rows;</a>
<a name="ln251">	BPrivate::get_workspaces_layout(&amp;columns, &amp;rows);</a>
<a name="ln252">	fColumnsControl-&gt;SetValue(columns);</a>
<a name="ln253">	fRowsControl-&gt;SetValue(rows);</a>
<a name="ln254"> </a>
<a name="ln255">	screenBox-&gt;AddChild(BLayoutBuilder::Group&lt;&gt;()</a>
<a name="ln256">		.AddGroup(B_VERTICAL, B_USE_SMALL_SPACING)</a>
<a name="ln257">			.Add(workspaces)</a>
<a name="ln258">			.AddGrid(B_USE_DEFAULT_SPACING, B_USE_SMALL_SPACING)</a>
<a name="ln259">				// columns</a>
<a name="ln260">				.Add(fColumnsControl-&gt;CreateLabelLayoutItem(), 0, 0)</a>
<a name="ln261">				.Add(fColumnsControl-&gt;CreateTextViewLayoutItem(), 1, 0)</a>
<a name="ln262">				// rows</a>
<a name="ln263">				.Add(fRowsControl-&gt;CreateLabelLayoutItem(), 0, 1)</a>
<a name="ln264">				.Add(fRowsControl-&gt;CreateTextViewLayoutItem(), 1, 1)</a>
<a name="ln265">				.End()</a>
<a name="ln266">			.End()</a>
<a name="ln267">		.View());</a>
<a name="ln268"> </a>
<a name="ln269">	fBackgroundsButton = new BButton(&quot;BackgroundsButton&quot;,</a>
<a name="ln270">		B_TRANSLATE(&quot;Set background&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln271">		new BMessage(BUTTON_LAUNCH_BACKGROUNDS_MSG));</a>
<a name="ln272">	fBackgroundsButton-&gt;SetFontSize(be_plain_font-&gt;Size() * 0.9);</a>
<a name="ln273">	screenBox-&gt;AddChild(fBackgroundsButton);</a>
<a name="ln274"> </a>
<a name="ln275">	// box on the right with screen resolution, etc.</a>
<a name="ln276"> </a>
<a name="ln277">	BBox* controlsBox = new BBox(&quot;controls box&quot;);</a>
<a name="ln278">	controlsBox-&gt;SetLabel(workspaceMenuField);</a>
<a name="ln279">	BGroupView* outerControlsView = new BGroupView(B_VERTICAL);</a>
<a name="ln280">	outerControlsView-&gt;GroupLayout()-&gt;SetInsets(B_USE_DEFAULT_SPACING,</a>
<a name="ln281">		B_USE_DEFAULT_SPACING, B_USE_DEFAULT_SPACING, B_USE_DEFAULT_SPACING);</a>
<a name="ln282">	controlsBox-&gt;AddChild(outerControlsView);</a>
<a name="ln283"> </a>
<a name="ln284">	fResolutionMenu = new BPopUpMenu(&quot;resolution&quot;, true, true);</a>
<a name="ln285"> </a>
<a name="ln286">	uint16 maxWidth = 0;</a>
<a name="ln287">	uint16 maxHeight = 0;</a>
<a name="ln288">	uint16 previousWidth = 0;</a>
<a name="ln289">	uint16 previousHeight = 0;</a>
<a name="ln290">	for (int32 i = 0; i &lt; fScreenMode.CountModes(); i++) {</a>
<a name="ln291">		screen_mode mode = fScreenMode.ModeAt(i);</a>
<a name="ln292"> </a>
<a name="ln293">		if (mode.width == previousWidth &amp;&amp; mode.height == previousHeight)</a>
<a name="ln294">			continue;</a>
<a name="ln295"> </a>
<a name="ln296">		previousWidth = mode.width;</a>
<a name="ln297">		previousHeight = mode.height;</a>
<a name="ln298">		if (maxWidth &lt; mode.width)</a>
<a name="ln299">			maxWidth = mode.width;</a>
<a name="ln300">		if (maxHeight &lt; mode.height)</a>
<a name="ln301">			maxHeight = mode.height;</a>
<a name="ln302"> </a>
<a name="ln303">		BMessage* message = new BMessage(POP_RESOLUTION_MSG);</a>
<a name="ln304">		message-&gt;AddInt32(&quot;width&quot;, mode.width);</a>
<a name="ln305">		message-&gt;AddInt32(&quot;height&quot;, mode.height);</a>
<a name="ln306"> </a>
<a name="ln307">		BString name;</a>
<a name="ln308">		name &lt;&lt; mode.width &lt;&lt; &quot; x &quot; &lt;&lt; mode.height;</a>
<a name="ln309"> </a>
<a name="ln310">		fResolutionMenu-&gt;AddItem(new BMenuItem(name.String(), message));</a>
<a name="ln311">	}</a>
<a name="ln312"> </a>
<a name="ln313">	fMonitorView-&gt;SetMaxResolution(maxWidth, maxHeight);</a>
<a name="ln314"> </a>
<a name="ln315">	fResolutionField = new BMenuField(&quot;ResolutionMenu&quot;,</a>
<a name="ln316">		B_TRANSLATE(&quot;Resolution:&quot;), fResolutionMenu);</a>
<a name="ln317">	fResolutionField-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln318"> </a>
<a name="ln319">	fColorsMenu = new BPopUpMenu(&quot;colors&quot;, true, false);</a>
<a name="ln320"> </a>
<a name="ln321">	for (int32 i = 0; i &lt; kColorSpaceCount; i++) {</a>
<a name="ln322">		if ((fSupportedColorSpaces &amp; (1 &lt;&lt; i)) == 0)</a>
<a name="ln323">			continue;</a>
<a name="ln324"> </a>
<a name="ln325">		BMessage* message = new BMessage(POP_COLORS_MSG);</a>
<a name="ln326">		message-&gt;AddInt32(&quot;bits_per_pixel&quot;, kColorSpaces[i].bits_per_pixel);</a>
<a name="ln327">		message-&gt;AddInt32(&quot;space&quot;, kColorSpaces[i].space);</a>
<a name="ln328"> </a>
<a name="ln329">		BMenuItem* item = new BMenuItem(kColorSpaces[i].label, message);</a>
<a name="ln330">		if (kColorSpaces[i].space == screen.ColorSpace())</a>
<a name="ln331">			fUserSelectedColorSpace = item;</a>
<a name="ln332"> </a>
<a name="ln333">		fColorsMenu-&gt;AddItem(item);</a>
<a name="ln334">	}</a>
<a name="ln335"> </a>
<a name="ln336">	fColorsField = new BMenuField(&quot;ColorsMenu&quot;, B_TRANSLATE(&quot;Colors:&quot;),</a>
<a name="ln337">		fColorsMenu);</a>
<a name="ln338">	fColorsField-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln339"> </a>
<a name="ln340">	fRefreshMenu = new BPopUpMenu(&quot;refresh rate&quot;, true, true);</a>
<a name="ln341"> </a>
<a name="ln342">	float min, max;</a>
<a name="ln343">	if (fScreenMode.GetRefreshLimits(fActive, min, max) != B_OK) {</a>
<a name="ln344">		// if we couldn't obtain the refresh limits, reset to the default</a>
<a name="ln345">		// range. Constraints from detected monitors will fine-tune this</a>
<a name="ln346">		// later.</a>
<a name="ln347">		min = kRefreshRates[0];</a>
<a name="ln348">		max = kRefreshRates[kRefreshRateCount - 1];</a>
<a name="ln349">	}</a>
<a name="ln350"> </a>
<a name="ln351">	if (min == max) {</a>
<a name="ln352">		// This is a special case for drivers that only support a single</a>
<a name="ln353">		// frequency, like the VESA driver</a>
<a name="ln354">		BString name;</a>
<a name="ln355">		refresh_rate_to_string(min, name);</a>
<a name="ln356">		BMessage *message = new BMessage(POP_REFRESH_MSG);</a>
<a name="ln357">		message-&gt;AddFloat(&quot;refresh&quot;, min);</a>
<a name="ln358">		BMenuItem *item = new BMenuItem(name.String(), message);</a>
<a name="ln359">		fRefreshMenu-&gt;AddItem(item);</a>
<a name="ln360">		item-&gt;SetEnabled(false);</a>
<a name="ln361">	} else {</a>
<a name="ln362">		monitor_info info;</a>
<a name="ln363">		if (fScreenMode.GetMonitorInfo(info) == B_OK) {</a>
<a name="ln364">			min = max_c(info.min_vertical_frequency, min);</a>
<a name="ln365">			max = min_c(info.max_vertical_frequency, max);</a>
<a name="ln366">		}</a>
<a name="ln367"> </a>
<a name="ln368">		for (int32 i = 0; i &lt; kRefreshRateCount; ++i) {</a>
<a name="ln369">			if (kRefreshRates[i] &lt; min || kRefreshRates[i] &gt; max)</a>
<a name="ln370">				continue;</a>
<a name="ln371"> </a>
<a name="ln372">			BString name;</a>
<a name="ln373">			name &lt;&lt; kRefreshRates[i] &lt;&lt; &quot; &quot; &lt;&lt; B_TRANSLATE(&quot;Hz&quot;);</a>
<a name="ln374"> </a>
<a name="ln375">			BMessage *message = new BMessage(POP_REFRESH_MSG);</a>
<a name="ln376">			message-&gt;AddFloat(&quot;refresh&quot;, kRefreshRates[i]);</a>
<a name="ln377"> </a>
<a name="ln378">			fRefreshMenu-&gt;AddItem(new BMenuItem(name.String(), message));</a>
<a name="ln379">		}</a>
<a name="ln380"> </a>
<a name="ln381">		fOtherRefresh = new BMenuItem(B_TRANSLATE(&quot;Other&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln382">			new BMessage(POP_OTHER_REFRESH_MSG));</a>
<a name="ln383">		fRefreshMenu-&gt;AddItem(fOtherRefresh);</a>
<a name="ln384">	}</a>
<a name="ln385"> </a>
<a name="ln386">	fRefreshField = new BMenuField(&quot;RefreshMenu&quot;, B_TRANSLATE(&quot;Refresh rate:&quot;),</a>
<a name="ln387">		fRefreshMenu);</a>
<a name="ln388">	fRefreshField-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln389"> </a>
<a name="ln390">	if (_IsVesa())</a>
<a name="ln391">		fRefreshField-&gt;Hide();</a>
<a name="ln392"> </a>
<a name="ln393">	// enlarged area for multi-monitor settings</a>
<a name="ln394">	{</a>
<a name="ln395">		bool dummy;</a>
<a name="ln396">		uint32 dummy32;</a>
<a name="ln397">		bool multiMonSupport;</a>
<a name="ln398">		bool useLaptopPanelSupport;</a>
<a name="ln399">		bool tvStandardSupport;</a>
<a name="ln400"> </a>
<a name="ln401">		multiMonSupport = TestMultiMonSupport(&amp;screen) == B_OK;</a>
<a name="ln402">		useLaptopPanelSupport = GetUseLaptopPanel(&amp;screen, &amp;dummy) == B_OK;</a>
<a name="ln403">		tvStandardSupport = GetTVStandard(&amp;screen, &amp;dummy32) == B_OK;</a>
<a name="ln404"> </a>
<a name="ln405">		// even if there is no support, we still create all controls</a>
<a name="ln406">		// to make sure we don't access NULL pointers later on</a>
<a name="ln407"> </a>
<a name="ln408">		fCombineMenu = new BPopUpMenu(&quot;CombineDisplays&quot;,</a>
<a name="ln409">			true, true);</a>
<a name="ln410"> </a>
<a name="ln411">		for (int32 i = 0; i &lt; kCombineModeCount; i++) {</a>
<a name="ln412">			BMessage *message = new BMessage(POP_COMBINE_DISPLAYS_MSG);</a>
<a name="ln413">			message-&gt;AddInt32(&quot;mode&quot;, kCombineModes[i].mode);</a>
<a name="ln414"> </a>
<a name="ln415">			fCombineMenu-&gt;AddItem(new BMenuItem(kCombineModes[i].name,</a>
<a name="ln416">				message));</a>
<a name="ln417">		}</a>
<a name="ln418"> </a>
<a name="ln419">		fCombineField = new BMenuField(&quot;CombineMenu&quot;,</a>
<a name="ln420">			B_TRANSLATE(&quot;Combine displays:&quot;), fCombineMenu);</a>
<a name="ln421">		fCombineField-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln422"> </a>
<a name="ln423">		if (!multiMonSupport)</a>
<a name="ln424">			fCombineField-&gt;Hide();</a>
<a name="ln425"> </a>
<a name="ln426">		fSwapDisplaysMenu = new BPopUpMenu(&quot;SwapDisplays&quot;,</a>
<a name="ln427">			true, true);</a>
<a name="ln428"> </a>
<a name="ln429">		// !order is important - we rely that boolean value == idx</a>
<a name="ln430">		BMessage *message = new BMessage(POP_SWAP_DISPLAYS_MSG);</a>
<a name="ln431">		message-&gt;AddBool(&quot;swap&quot;, false);</a>
<a name="ln432">		fSwapDisplaysMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;no&quot;), message));</a>
<a name="ln433"> </a>
<a name="ln434">		message = new BMessage(POP_SWAP_DISPLAYS_MSG);</a>
<a name="ln435">		message-&gt;AddBool(&quot;swap&quot;, true);</a>
<a name="ln436">		fSwapDisplaysMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;yes&quot;), message));</a>
<a name="ln437"> </a>
<a name="ln438">		fSwapDisplaysField = new BMenuField(&quot;SwapMenu&quot;,</a>
<a name="ln439">			B_TRANSLATE(&quot;Swap displays:&quot;), fSwapDisplaysMenu);</a>
<a name="ln440">		fSwapDisplaysField-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln441"> </a>
<a name="ln442">		if (!multiMonSupport)</a>
<a name="ln443">			fSwapDisplaysField-&gt;Hide();</a>
<a name="ln444"> </a>
<a name="ln445">		fUseLaptopPanelMenu = new BPopUpMenu(&quot;UseLaptopPanel&quot;,</a>
<a name="ln446">			true, true);</a>
<a name="ln447"> </a>
<a name="ln448">		// !order is important - we rely that boolean value == idx</a>
<a name="ln449">		message = new BMessage(POP_USE_LAPTOP_PANEL_MSG);</a>
<a name="ln450">		message-&gt;AddBool(&quot;use&quot;, false);</a>
<a name="ln451">		fUseLaptopPanelMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;if needed&quot;),</a>
<a name="ln452">			message));</a>
<a name="ln453"> </a>
<a name="ln454">		message = new BMessage(POP_USE_LAPTOP_PANEL_MSG);</a>
<a name="ln455">		message-&gt;AddBool(&quot;use&quot;, true);</a>
<a name="ln456">		fUseLaptopPanelMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;always&quot;),</a>
<a name="ln457">			message));</a>
<a name="ln458"> </a>
<a name="ln459">		fUseLaptopPanelField = new BMenuField(&quot;UseLaptopPanel&quot;,</a>
<a name="ln460">			B_TRANSLATE(&quot;Use laptop panel:&quot;), fUseLaptopPanelMenu);</a>
<a name="ln461">		fUseLaptopPanelField-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln462"> </a>
<a name="ln463">		if (!useLaptopPanelSupport)</a>
<a name="ln464">			fUseLaptopPanelField-&gt;Hide();</a>
<a name="ln465"> </a>
<a name="ln466">		fTVStandardMenu = new BPopUpMenu(&quot;TVStandard&quot;, true, true);</a>
<a name="ln467"> </a>
<a name="ln468">		// arbitrary limit</a>
<a name="ln469">		uint32 i;</a>
<a name="ln470">		for (i = 0; i &lt; 100; ++i) {</a>
<a name="ln471">			uint32 mode;</a>
<a name="ln472">			if (GetNthSupportedTVStandard(&amp;screen, i, &amp;mode) != B_OK)</a>
<a name="ln473">				break;</a>
<a name="ln474"> </a>
<a name="ln475">			BString name = tv_standard_to_string(mode);</a>
<a name="ln476"> </a>
<a name="ln477">			message = new BMessage(POP_TV_STANDARD_MSG);</a>
<a name="ln478">			message-&gt;AddInt32(&quot;tv_standard&quot;, mode);</a>
<a name="ln479"> </a>
<a name="ln480">			fTVStandardMenu-&gt;AddItem(new BMenuItem(name.String(), message));</a>
<a name="ln481">		}</a>
<a name="ln482"> </a>
<a name="ln483">		fTVStandardField = new BMenuField(&quot;tv standard&quot;,</a>
<a name="ln484">			B_TRANSLATE(&quot;Video format:&quot;), fTVStandardMenu);</a>
<a name="ln485">		fTVStandardField-&gt;SetAlignment(B_ALIGN_RIGHT);</a>
<a name="ln486"> </a>
<a name="ln487">		if (!tvStandardSupport || i == 0)</a>
<a name="ln488">			fTVStandardField-&gt;Hide();</a>
<a name="ln489">	}</a>
<a name="ln490"> </a>
<a name="ln491">	BLayoutBuilder::Group&lt;&gt;(outerControlsView)</a>
<a name="ln492">		.AddGrid(B_USE_DEFAULT_SPACING, B_USE_SMALL_SPACING)</a>
<a name="ln493">			.Add(fResolutionField-&gt;CreateLabelLayoutItem(), 0, 0)</a>
<a name="ln494">			.Add(fResolutionField-&gt;CreateMenuBarLayoutItem(), 1, 0)</a>
<a name="ln495">			.Add(fColorsField-&gt;CreateLabelLayoutItem(), 0, 1)</a>
<a name="ln496">			.Add(fColorsField-&gt;CreateMenuBarLayoutItem(), 1, 1)</a>
<a name="ln497">			.Add(fRefreshField-&gt;CreateLabelLayoutItem(), 0, 2)</a>
<a name="ln498">			.Add(fRefreshField-&gt;CreateMenuBarLayoutItem(), 1, 2)</a>
<a name="ln499">			.Add(fCombineField-&gt;CreateLabelLayoutItem(), 0, 3)</a>
<a name="ln500">			.Add(fCombineField-&gt;CreateMenuBarLayoutItem(), 1, 3)</a>
<a name="ln501">			.Add(fSwapDisplaysField-&gt;CreateLabelLayoutItem(), 0, 4)</a>
<a name="ln502">			.Add(fSwapDisplaysField-&gt;CreateMenuBarLayoutItem(), 1, 4)</a>
<a name="ln503">			.Add(fUseLaptopPanelField-&gt;CreateLabelLayoutItem(), 0, 5)</a>
<a name="ln504">			.Add(fUseLaptopPanelField-&gt;CreateMenuBarLayoutItem(), 1, 5)</a>
<a name="ln505">			.Add(fTVStandardField-&gt;CreateLabelLayoutItem(), 0, 6)</a>
<a name="ln506">			.Add(fTVStandardField-&gt;CreateMenuBarLayoutItem(), 1, 6)</a>
<a name="ln507">		.End();</a>
<a name="ln508"> </a>
<a name="ln509">	fBrightnessSlider = new BSlider(&quot;brightness&quot;, &quot;Brightness&quot;,</a>
<a name="ln510">		NULL, 0, 255, B_HORIZONTAL);</a>
<a name="ln511"> </a>
<a name="ln512">	status_t result = screen.GetBrightness(&amp;fOriginalBrightness);</a>
<a name="ln513">	if (result == B_OK) {</a>
<a name="ln514">		fBrightnessSlider-&gt;SetModificationMessage(</a>
<a name="ln515">			new BMessage(SLIDER_BRIGHTNESS_MSG));</a>
<a name="ln516">		fBrightnessSlider-&gt;SetValue(fOriginalBrightness * 255);</a>
<a name="ln517">	} else {</a>
<a name="ln518">		// The driver does not support changing the brightness,</a>
<a name="ln519">		// so hide the slider</a>
<a name="ln520">		fBrightnessSlider-&gt;Hide();</a>
<a name="ln521"> </a>
<a name="ln522">		fOriginalBrightness = -1;</a>
<a name="ln523">	}</a>
<a name="ln524"> </a>
<a name="ln525">	// TODO: we don't support getting the screen's preferred settings</a>
<a name="ln526">	/* fDefaultsButton = new BButton(buttonRect, &quot;DefaultsButton&quot;, &quot;Defaults&quot;,</a>
<a name="ln527">		new BMessage(BUTTON_DEFAULTS_MSG));*/</a>
<a name="ln528"> </a>
<a name="ln529">	fApplyButton = new BButton(&quot;ApplyButton&quot;, B_TRANSLATE(&quot;Apply&quot;),</a>
<a name="ln530">		new BMessage(BUTTON_APPLY_MSG));</a>
<a name="ln531">	fApplyButton-&gt;SetEnabled(false);</a>
<a name="ln532">	BLayoutBuilder::Group&lt;&gt;(outerControlsView)</a>
<a name="ln533">		.AddGlue()</a>
<a name="ln534">		.AddGroup(B_HORIZONTAL)</a>
<a name="ln535">			.AddGlue()</a>
<a name="ln536">			.Add(fApplyButton);</a>
<a name="ln537"> </a>
<a name="ln538">	fRevertButton = new BButton(&quot;RevertButton&quot;, B_TRANSLATE(&quot;Revert&quot;),</a>
<a name="ln539">		new BMessage(BUTTON_REVERT_MSG));</a>
<a name="ln540">	fRevertButton-&gt;SetEnabled(false);</a>
<a name="ln541"> </a>
<a name="ln542">	BLayoutBuilder::Group&lt;&gt;(this, B_VERTICAL, B_USE_DEFAULT_SPACING)</a>
<a name="ln543">		.AddGroup(B_HORIZONTAL)</a>
<a name="ln544">			.AddGroup(B_VERTICAL, 0, 1)</a>
<a name="ln545">				.AddStrut(floorf(controlsBox-&gt;TopBorderOffset()) - 1)</a>
<a name="ln546">				.Add(screenBox)</a>
<a name="ln547">				.End()</a>
<a name="ln548">			.AddGroup(B_VERTICAL, 0, 1)</a>
<a name="ln549">				.Add(controlsBox, 2)</a>
<a name="ln550">				.Add(fBrightnessSlider)</a>
<a name="ln551">				.End()</a>
<a name="ln552">			.End()</a>
<a name="ln553">		.AddGroup(B_HORIZONTAL, B_USE_DEFAULT_SPACING)</a>
<a name="ln554">			.Add(fRevertButton)</a>
<a name="ln555">			.AddGlue()</a>
<a name="ln556">			.End()</a>
<a name="ln557">		.SetInsets(B_USE_WINDOW_SPACING);</a>
<a name="ln558"> </a>
<a name="ln559">	_UpdateControls();</a>
<a name="ln560">	_UpdateMonitor();</a>
<a name="ln561"> </a>
<a name="ln562">	MoveOnScreen();</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565"> </a>
<a name="ln566">ScreenWindow::~ScreenWindow()</a>
<a name="ln567">{</a>
<a name="ln568">	delete fSettings;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572">bool</a>
<a name="ln573">ScreenWindow::QuitRequested()</a>
<a name="ln574">{</a>
<a name="ln575">	fSettings-&gt;SetWindowFrame(Frame());</a>
<a name="ln576"> </a>
<a name="ln577">	// Write mode of workspace 0 (the boot workspace) to the vesa settings file</a>
<a name="ln578">	screen_mode vesaMode;</a>
<a name="ln579">	if (fBootWorkspaceApplied &amp;&amp; fScreenMode.Get(vesaMode, 0) == B_OK) {</a>
<a name="ln580">		status_t status = _WriteVesaModeFile(vesaMode);</a>
<a name="ln581">		if (status &lt; B_OK) {</a>
<a name="ln582">			BString warning = B_TRANSLATE(&quot;Could not write VESA mode settings&quot;</a>
<a name="ln583">				&quot; file:\n\t&quot;);</a>
<a name="ln584">			warning &lt;&lt; strerror(status);</a>
<a name="ln585">			BAlert* alert = new BAlert(B_TRANSLATE(&quot;Warning&quot;),</a>
<a name="ln586">				warning.String(), B_TRANSLATE(&quot;OK&quot;), NULL,</a>
<a name="ln587">				NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln588">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln589">			alert-&gt;Go();</a>
<a name="ln590">		}</a>
<a name="ln591">	}</a>
<a name="ln592"> </a>
<a name="ln593">	be_app-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln594"> </a>
<a name="ln595">	return BWindow::QuitRequested();</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598"> </a>
<a name="ln599">/*!	Update resolution list according to combine mode</a>
<a name="ln600">	(some resolutions may not be combinable due to memory restrictions).</a>
<a name="ln601">*/</a>
<a name="ln602">void</a>
<a name="ln603">ScreenWindow::_CheckResolutionMenu()</a>
<a name="ln604">{</a>
<a name="ln605">	for (int32 i = 0; i &lt; fResolutionMenu-&gt;CountItems(); i++)</a>
<a name="ln606">		fResolutionMenu-&gt;ItemAt(i)-&gt;SetEnabled(false);</a>
<a name="ln607"> </a>
<a name="ln608">	for (int32 i = 0; i &lt; fScreenMode.CountModes(); i++) {</a>
<a name="ln609">		screen_mode mode = fScreenMode.ModeAt(i);</a>
<a name="ln610">		if (mode.combine != fSelected.combine)</a>
<a name="ln611">			continue;</a>
<a name="ln612"> </a>
<a name="ln613">		BString name;</a>
<a name="ln614">		name &lt;&lt; mode.width &lt;&lt; &quot; x &quot; &lt;&lt; mode.height;</a>
<a name="ln615"> </a>
<a name="ln616">		BMenuItem *item = fResolutionMenu-&gt;FindItem(name.String());</a>
<a name="ln617">		if (item != NULL)</a>
<a name="ln618">			item-&gt;SetEnabled(true);</a>
<a name="ln619">	}</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622"> </a>
<a name="ln623">/*!	Update color and refresh options according to current mode</a>
<a name="ln624">	(a color space is made active if there is any mode with</a>
<a name="ln625">	given resolution and this colour space; same applies for</a>
<a name="ln626">	refresh rate, though &quot;Other…&quot; is always possible)</a>
<a name="ln627">*/</a>
<a name="ln628">void</a>
<a name="ln629">ScreenWindow::_CheckColorMenu()</a>
<a name="ln630">{</a>
<a name="ln631">	int32 supportsAnything = false;</a>
<a name="ln632">	int32 index = 0;</a>
<a name="ln633"> </a>
<a name="ln634">	for (int32 i = 0; i &lt; kColorSpaceCount; i++) {</a>
<a name="ln635">		if ((fSupportedColorSpaces &amp; (1 &lt;&lt; i)) == 0)</a>
<a name="ln636">			continue;</a>
<a name="ln637"> </a>
<a name="ln638">		bool supported = false;</a>
<a name="ln639"> </a>
<a name="ln640">		for (int32 j = 0; j &lt; fScreenMode.CountModes(); j++) {</a>
<a name="ln641">			screen_mode mode = fScreenMode.ModeAt(j);</a>
<a name="ln642"> </a>
<a name="ln643">			if (fSelected.width == mode.width</a>
<a name="ln644">				&amp;&amp; fSelected.height == mode.height</a>
<a name="ln645">				&amp;&amp; kColorSpaces[i].space == mode.space</a>
<a name="ln646">				&amp;&amp; fSelected.combine == mode.combine) {</a>
<a name="ln647">				supportsAnything = true;</a>
<a name="ln648">				supported = true;</a>
<a name="ln649">				break;</a>
<a name="ln650">			}</a>
<a name="ln651">		}</a>
<a name="ln652"> </a>
<a name="ln653">		BMenuItem* item = fColorsMenu-&gt;ItemAt(index++);</a>
<a name="ln654">		if (item)</a>
<a name="ln655">			item-&gt;SetEnabled(supported);</a>
<a name="ln656">	}</a>
<a name="ln657"> </a>
<a name="ln658">	fColorsField-&gt;SetEnabled(supportsAnything);</a>
<a name="ln659"> </a>
<a name="ln660">	if (!supportsAnything)</a>
<a name="ln661">		return;</a>
<a name="ln662"> </a>
<a name="ln663">	// Make sure a valid item is selected</a>
<a name="ln664"> </a>
<a name="ln665">	BMenuItem* item = fColorsMenu-&gt;FindMarked();</a>
<a name="ln666">	bool changed = false;</a>
<a name="ln667"> </a>
<a name="ln668">	if (item != fUserSelectedColorSpace) {</a>
<a name="ln669">		if (fUserSelectedColorSpace != NULL</a>
<a name="ln670">			&amp;&amp; fUserSelectedColorSpace-&gt;IsEnabled()) {</a>
<a name="ln671">			fUserSelectedColorSpace-&gt;SetMarked(true);</a>
<a name="ln672">			item = fUserSelectedColorSpace;</a>
<a name="ln673">			changed = true;</a>
<a name="ln674">		}</a>
<a name="ln675">	}</a>
<a name="ln676">	if (item != NULL &amp;&amp; !item-&gt;IsEnabled()) {</a>
<a name="ln677">		// find the next best item</a>
<a name="ln678">		int32 index = fColorsMenu-&gt;IndexOf(item);</a>
<a name="ln679">		bool found = false;</a>
<a name="ln680"> </a>
<a name="ln681">		for (int32 i = index + 1; i &lt; fColorsMenu-&gt;CountItems(); i++) {</a>
<a name="ln682">			item = fColorsMenu-&gt;ItemAt(i);</a>
<a name="ln683">			if (item-&gt;IsEnabled()) {</a>
<a name="ln684">				found = true;</a>
<a name="ln685">				break;</a>
<a name="ln686">			}</a>
<a name="ln687">		}</a>
<a name="ln688">		if (!found) {</a>
<a name="ln689">			// search backwards as well</a>
<a name="ln690">			for (int32 i = index - 1; i &gt;= 0; i--) {</a>
<a name="ln691">				item = fColorsMenu-&gt;ItemAt(i);</a>
<a name="ln692">				if (item-&gt;IsEnabled())</a>
<a name="ln693">					break;</a>
<a name="ln694">			}</a>
<a name="ln695">		}</a>
<a name="ln696"> </a>
<a name="ln697">		item-&gt;SetMarked(true);</a>
<a name="ln698">		changed = true;</a>
<a name="ln699">	}</a>
<a name="ln700"> </a>
<a name="ln701">	if (changed) {</a>
<a name="ln702">		// Update selected space</a>
<a name="ln703"> </a>
<a name="ln704">		BMessage* message = item-&gt;Message();</a>
<a name="ln705">		int32 space;</a>
<a name="ln706">		if (message-&gt;FindInt32(&quot;space&quot;, &amp;space) == B_OK) {</a>
<a name="ln707">			fSelected.space = (color_space)space;</a>
<a name="ln708">			_UpdateColorLabel();</a>
<a name="ln709">		}</a>
<a name="ln710">	}</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">/*!	Enable/disable refresh options according to current mode. */</a>
<a name="ln715">void</a>
<a name="ln716">ScreenWindow::_CheckRefreshMenu()</a>
<a name="ln717">{</a>
<a name="ln718">	float min, max;</a>
<a name="ln719">	if (fScreenMode.GetRefreshLimits(fSelected, min, max) != B_OK || min == max)</a>
<a name="ln720">		return;</a>
<a name="ln721"> </a>
<a name="ln722">	for (int32 i = fRefreshMenu-&gt;CountItems(); i-- &gt; 0;) {</a>
<a name="ln723">		BMenuItem* item = fRefreshMenu-&gt;ItemAt(i);</a>
<a name="ln724">		BMessage* message = item-&gt;Message();</a>
<a name="ln725">		float refresh;</a>
<a name="ln726">		if (message != NULL &amp;&amp; message-&gt;FindFloat(&quot;refresh&quot;, &amp;refresh) == B_OK)</a>
<a name="ln727">			item-&gt;SetEnabled(refresh &gt;= min &amp;&amp; refresh &lt;= max);</a>
<a name="ln728">	}</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731"> </a>
<a name="ln732">/*!	Activate appropriate menu item according to selected refresh rate */</a>
<a name="ln733">void</a>
<a name="ln734">ScreenWindow::_UpdateRefreshControl()</a>
<a name="ln735">{</a>
<a name="ln736">	for (int32 i = 0; i &lt; fRefreshMenu-&gt;CountItems(); i++) {</a>
<a name="ln737">		BMenuItem* item = fRefreshMenu-&gt;ItemAt(i);</a>
<a name="ln738">		if (item-&gt;Message()-&gt;FindFloat(&quot;refresh&quot;) == fSelected.refresh) {</a>
<a name="ln739">			item-&gt;SetMarked(true);</a>
<a name="ln740">			// &quot;Other&quot; items only contains a refresh rate when active</a>
<a name="ln741">			fOtherRefresh-&gt;SetLabel(B_TRANSLATE(&quot;Other&quot; B_UTF8_ELLIPSIS));</a>
<a name="ln742">			return;</a>
<a name="ln743">		}</a>
<a name="ln744">	}</a>
<a name="ln745"> </a>
<a name="ln746">	// this is a non-standard refresh rate</a>
<a name="ln747">	if (fOtherRefresh != NULL) {</a>
<a name="ln748">		fOtherRefresh-&gt;Message()-&gt;ReplaceFloat(&quot;refresh&quot;, fSelected.refresh);</a>
<a name="ln749">		fOtherRefresh-&gt;SetMarked(true);</a>
<a name="ln750"> </a>
<a name="ln751">		BString string;</a>
<a name="ln752">		refresh_rate_to_string(fSelected.refresh, string);</a>
<a name="ln753">		fRefreshMenu-&gt;Superitem()-&gt;SetLabel(string.String());</a>
<a name="ln754"> </a>
<a name="ln755">		string.Append(B_TRANSLATE(&quot;/other&quot; B_UTF8_ELLIPSIS));</a>
<a name="ln756">		fOtherRefresh-&gt;SetLabel(string.String());</a>
<a name="ln757">	}</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760"> </a>
<a name="ln761">void</a>
<a name="ln762">ScreenWindow::_UpdateMonitorView()</a>
<a name="ln763">{</a>
<a name="ln764">	BMessage updateMessage(UPDATE_DESKTOP_MSG);</a>
<a name="ln765">	updateMessage.AddInt32(&quot;width&quot;, fSelected.width);</a>
<a name="ln766">	updateMessage.AddInt32(&quot;height&quot;, fSelected.height);</a>
<a name="ln767"> </a>
<a name="ln768">	PostMessage(&amp;updateMessage, fMonitorView);</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771"> </a>
<a name="ln772">void</a>
<a name="ln773">ScreenWindow::_UpdateControls()</a>
<a name="ln774">{</a>
<a name="ln775">	_UpdateWorkspaceButtons();</a>
<a name="ln776"> </a>
<a name="ln777">	BMenuItem* item = fSwapDisplaysMenu-&gt;ItemAt((int32)fSelected.swap_displays);</a>
<a name="ln778">	if (item != NULL &amp;&amp; !item-&gt;IsMarked())</a>
<a name="ln779">		item-&gt;SetMarked(true);</a>
<a name="ln780"> </a>
<a name="ln781">	item = fUseLaptopPanelMenu-&gt;ItemAt((int32)fSelected.use_laptop_panel);</a>
<a name="ln782">	if (item != NULL &amp;&amp; !item-&gt;IsMarked())</a>
<a name="ln783">		item-&gt;SetMarked(true);</a>
<a name="ln784"> </a>
<a name="ln785">	for (int32 i = 0; i &lt; fTVStandardMenu-&gt;CountItems(); i++) {</a>
<a name="ln786">		item = fTVStandardMenu-&gt;ItemAt(i);</a>
<a name="ln787"> </a>
<a name="ln788">		uint32 tvStandard;</a>
<a name="ln789">		item-&gt;Message()-&gt;FindInt32(&quot;tv_standard&quot;, (int32 *)&amp;tvStandard);</a>
<a name="ln790">		if (tvStandard == fSelected.tv_standard) {</a>
<a name="ln791">			if (!item-&gt;IsMarked())</a>
<a name="ln792">				item-&gt;SetMarked(true);</a>
<a name="ln793">			break;</a>
<a name="ln794">		}</a>
<a name="ln795">	}</a>
<a name="ln796"> </a>
<a name="ln797">	_CheckResolutionMenu();</a>
<a name="ln798">	_CheckColorMenu();</a>
<a name="ln799">	_CheckRefreshMenu();</a>
<a name="ln800"> </a>
<a name="ln801">	BString string;</a>
<a name="ln802">	resolution_to_string(fSelected, string);</a>
<a name="ln803">	item = fResolutionMenu-&gt;FindItem(string.String());</a>
<a name="ln804"> </a>
<a name="ln805">	if (item != NULL) {</a>
<a name="ln806">		if (!item-&gt;IsMarked())</a>
<a name="ln807">			item-&gt;SetMarked(true);</a>
<a name="ln808">	} else {</a>
<a name="ln809">		// this is bad luck - if mode has been set via screen references,</a>
<a name="ln810">		// this case cannot occur; there are three possible solutions:</a>
<a name="ln811">		// 1. add a new resolution to list</a>
<a name="ln812">		//    - we had to remove it as soon as a &quot;valid&quot; one is selected</a>
<a name="ln813">		//    - we don't know which frequencies/bit depths are supported</a>
<a name="ln814">		//    - as long as we haven't the GMT formula to create</a>
<a name="ln815">		//      parameters for any resolution given, we cannot</a>
<a name="ln816">		//      really set current mode - it's just not in the list</a>
<a name="ln817">		// 2. choose nearest resolution</a>
<a name="ln818">		//    - probably a good idea, but implies coding and testing</a>
<a name="ln819">		// 3. choose lowest resolution</a>
<a name="ln820">		//    - do you really think we are so lazy? yes, we are</a>
<a name="ln821">		item = fResolutionMenu-&gt;ItemAt(0);</a>
<a name="ln822">		if (item)</a>
<a name="ln823">			item-&gt;SetMarked(true);</a>
<a name="ln824"> </a>
<a name="ln825">		// okay - at least we set menu label to active resolution</a>
<a name="ln826">		fResolutionMenu-&gt;Superitem()-&gt;SetLabel(string.String());</a>
<a name="ln827">	}</a>
<a name="ln828"> </a>
<a name="ln829">	// mark active combine mode</a>
<a name="ln830">	for (int32 i = 0; i &lt; kCombineModeCount; i++) {</a>
<a name="ln831">		if (kCombineModes[i].mode == fSelected.combine) {</a>
<a name="ln832">			item = fCombineMenu-&gt;ItemAt(i);</a>
<a name="ln833">			if (item != NULL &amp;&amp; !item-&gt;IsMarked())</a>
<a name="ln834">				item-&gt;SetMarked(true);</a>
<a name="ln835">			break;</a>
<a name="ln836">		}</a>
<a name="ln837">	}</a>
<a name="ln838"> </a>
<a name="ln839">	item = fColorsMenu-&gt;ItemAt(0);</a>
<a name="ln840"> </a>
<a name="ln841">	for (int32 i = 0, index = 0; i &lt;  kColorSpaceCount; i++) {</a>
<a name="ln842">		if ((fSupportedColorSpaces &amp; (1 &lt;&lt; i)) == 0)</a>
<a name="ln843">			continue;</a>
<a name="ln844"> </a>
<a name="ln845">		if (kColorSpaces[i].space == fSelected.space) {</a>
<a name="ln846">			item = fColorsMenu-&gt;ItemAt(index);</a>
<a name="ln847">			break;</a>
<a name="ln848">		}</a>
<a name="ln849"> </a>
<a name="ln850">		index++;</a>
<a name="ln851">	}</a>
<a name="ln852"> </a>
<a name="ln853">	if (item != NULL &amp;&amp; !item-&gt;IsMarked())</a>
<a name="ln854">		item-&gt;SetMarked(true);</a>
<a name="ln855"> </a>
<a name="ln856">	_UpdateColorLabel();</a>
<a name="ln857">	_UpdateMonitorView();</a>
<a name="ln858">	_UpdateRefreshControl();</a>
<a name="ln859"> </a>
<a name="ln860">	_CheckApplyEnabled();</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863"> </a>
<a name="ln864">/*! Reflect active mode in chosen settings */</a>
<a name="ln865">void</a>
<a name="ln866">ScreenWindow::_UpdateActiveMode()</a>
<a name="ln867">{</a>
<a name="ln868">	_UpdateActiveMode(current_workspace());</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871"> </a>
<a name="ln872">void</a>
<a name="ln873">ScreenWindow::_UpdateActiveMode(int32 workspace)</a>
<a name="ln874">{</a>
<a name="ln875">	// Usually, this function gets called after a mode</a>
<a name="ln876">	// has been set manually; still, as the graphics driver</a>
<a name="ln877">	// is free to fiddle with mode passed, we better ask</a>
<a name="ln878">	// what kind of mode we actually got</a>
<a name="ln879">	if (fScreenMode.Get(fActive, workspace) == B_OK) {</a>
<a name="ln880">		fSelected = fActive;</a>
<a name="ln881"> </a>
<a name="ln882">		_UpdateMonitor();</a>
<a name="ln883">		_BuildSupportedColorSpaces();</a>
<a name="ln884">		_UpdateControls();</a>
<a name="ln885">	}</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888"> </a>
<a name="ln889">void</a>
<a name="ln890">ScreenWindow::_UpdateWorkspaceButtons()</a>
<a name="ln891">{</a>
<a name="ln892">	uint32 columns;</a>
<a name="ln893">	uint32 rows;</a>
<a name="ln894">	BPrivate::get_workspaces_layout(&amp;columns, &amp;rows);</a>
<a name="ln895"> </a>
<a name="ln896">	// Set the max values enabling/disabling the up/down arrows</a>
<a name="ln897"> </a>
<a name="ln898">	if (rows == 1)</a>
<a name="ln899">		fColumnsControl-&gt;SetMaxValue(32);</a>
<a name="ln900">	else if (rows == 2)</a>
<a name="ln901">		fColumnsControl-&gt;SetMaxValue(16);</a>
<a name="ln902">	else if (rows &lt;= 4)</a>
<a name="ln903">		fColumnsControl-&gt;SetMaxValue(8);</a>
<a name="ln904">	else if (rows &lt;= 8)</a>
<a name="ln905">		fColumnsControl-&gt;SetMaxValue(4);</a>
<a name="ln906">	else if (rows &lt;= 16)</a>
<a name="ln907">		fColumnsControl-&gt;SetMaxValue(2);</a>
<a name="ln908">	else if (rows &lt;= 32)</a>
<a name="ln909">		fColumnsControl-&gt;SetMaxValue(1);</a>
<a name="ln910"> </a>
<a name="ln911">	if (columns == 1)</a>
<a name="ln912">		fRowsControl-&gt;SetMaxValue(32);</a>
<a name="ln913">	else if (columns == 2)</a>
<a name="ln914">		fRowsControl-&gt;SetMaxValue(16);</a>
<a name="ln915">	else if (columns &lt;= 4)</a>
<a name="ln916">		fRowsControl-&gt;SetMaxValue(8);</a>
<a name="ln917">	else if (columns &lt;= 8)</a>
<a name="ln918">		fRowsControl-&gt;SetMaxValue(4);</a>
<a name="ln919">	else if (columns &lt;= 16)</a>
<a name="ln920">		fRowsControl-&gt;SetMaxValue(2);</a>
<a name="ln921">	else if (columns &lt;= 32)</a>
<a name="ln922">		fRowsControl-&gt;SetMaxValue(1);</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925"> </a>
<a name="ln926">void</a>
<a name="ln927">ScreenWindow::ScreenChanged(BRect frame, color_space mode)</a>
<a name="ln928">{</a>
<a name="ln929">	// move window on screen, if necessary</a>
<a name="ln930">	if (frame.right &lt;= Frame().right</a>
<a name="ln931">		&amp;&amp; frame.bottom &lt;= Frame().bottom) {</a>
<a name="ln932">		MoveTo((frame.Width() - Frame().Width()) / 2,</a>
<a name="ln933">			(frame.Height() - Frame().Height()) / 2);</a>
<a name="ln934">	}</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937"> </a>
<a name="ln938">void</a>
<a name="ln939">ScreenWindow::WorkspaceActivated(int32 workspace, bool state)</a>
<a name="ln940">{</a>
<a name="ln941">	if (fScreenMode.GetOriginalMode(fOriginal, workspace) == B_OK) {</a>
<a name="ln942">		_UpdateActiveMode(workspace);</a>
<a name="ln943"> </a>
<a name="ln944">		BMessage message(UPDATE_DESKTOP_COLOR_MSG);</a>
<a name="ln945">		PostMessage(&amp;message, fMonitorView);</a>
<a name="ln946">	}</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949"> </a>
<a name="ln950">void</a>
<a name="ln951">ScreenWindow::MessageReceived(BMessage* message)</a>
<a name="ln952">{</a>
<a name="ln953">	switch (message-&gt;what) {</a>
<a name="ln954">		case WORKSPACE_CHECK_MSG:</a>
<a name="ln955">			_CheckApplyEnabled();</a>
<a name="ln956">			break;</a>
<a name="ln957"> </a>
<a name="ln958">		case kMsgWorkspaceColumnsChanged:</a>
<a name="ln959">		{</a>
<a name="ln960">			uint32 newColumns = (uint32)fColumnsControl-&gt;Value();</a>
<a name="ln961"> </a>
<a name="ln962">			uint32 rows;</a>
<a name="ln963">			BPrivate::get_workspaces_layout(NULL, &amp;rows);</a>
<a name="ln964">			BPrivate::set_workspaces_layout(newColumns, rows);</a>
<a name="ln965"> </a>
<a name="ln966">			_UpdateWorkspaceButtons();</a>
<a name="ln967">			fRowsControl-&gt;SetValue(rows);</a>
<a name="ln968">				// enables/disables up/down arrows</a>
<a name="ln969">			_CheckApplyEnabled();</a>
<a name="ln970"> </a>
<a name="ln971">			break;</a>
<a name="ln972">		}</a>
<a name="ln973"> </a>
<a name="ln974">		case kMsgWorkspaceRowsChanged:</a>
<a name="ln975">		{</a>
<a name="ln976">			uint32 newRows = (uint32)fRowsControl-&gt;Value();</a>
<a name="ln977"> </a>
<a name="ln978">			uint32 columns;</a>
<a name="ln979">			BPrivate::get_workspaces_layout(&amp;columns, NULL);</a>
<a name="ln980">			BPrivate::set_workspaces_layout(columns, newRows);</a>
<a name="ln981"> </a>
<a name="ln982">			_UpdateWorkspaceButtons();</a>
<a name="ln983">			fColumnsControl-&gt;SetValue(columns);</a>
<a name="ln984">				// enables/disables up/down arrows</a>
<a name="ln985">			_CheckApplyEnabled();</a>
<a name="ln986">			break;</a>
<a name="ln987">		}</a>
<a name="ln988"> </a>
<a name="ln989">		case POP_RESOLUTION_MSG:</a>
<a name="ln990">		{</a>
<a name="ln991">			message-&gt;FindInt32(&quot;width&quot;, &amp;fSelected.width);</a>
<a name="ln992">			message-&gt;FindInt32(&quot;height&quot;, &amp;fSelected.height);</a>
<a name="ln993"> </a>
<a name="ln994">			_CheckColorMenu();</a>
<a name="ln995">			_CheckRefreshMenu();</a>
<a name="ln996"> </a>
<a name="ln997">			_UpdateMonitorView();</a>
<a name="ln998">			_UpdateRefreshControl();</a>
<a name="ln999"> </a>
<a name="ln1000">			_CheckApplyEnabled();</a>
<a name="ln1001">			break;</a>
<a name="ln1002">		}</a>
<a name="ln1003"> </a>
<a name="ln1004">		case POP_COLORS_MSG:</a>
<a name="ln1005">		{</a>
<a name="ln1006">			int32 space;</a>
<a name="ln1007">			if (message-&gt;FindInt32(&quot;space&quot;, &amp;space) != B_OK)</a>
<a name="ln1008">				break;</a>
<a name="ln1009"> </a>
<a name="ln1010">			int32 index;</a>
<a name="ln1011">			if (message-&gt;FindInt32(&quot;index&quot;, &amp;index) == B_OK</a>
<a name="ln1012">				&amp;&amp; fColorsMenu-&gt;ItemAt(index) != NULL)</a>
<a name="ln1013">				fUserSelectedColorSpace = fColorsMenu-&gt;ItemAt(index);</a>
<a name="ln1014"> </a>
<a name="ln1015">			fSelected.space = (color_space)space;</a>
<a name="ln1016">			_UpdateColorLabel();</a>
<a name="ln1017"> </a>
<a name="ln1018">			_CheckApplyEnabled();</a>
<a name="ln1019">			break;</a>
<a name="ln1020">		}</a>
<a name="ln1021"> </a>
<a name="ln1022">		case POP_REFRESH_MSG:</a>
<a name="ln1023">		{</a>
<a name="ln1024">			message-&gt;FindFloat(&quot;refresh&quot;, &amp;fSelected.refresh);</a>
<a name="ln1025">			fOtherRefresh-&gt;SetLabel(B_TRANSLATE(&quot;Other&quot; B_UTF8_ELLIPSIS));</a>
<a name="ln1026">				// revert &quot;Other…&quot; label - it might have a refresh rate prefix</a>
<a name="ln1027"> </a>
<a name="ln1028">			_CheckApplyEnabled();</a>
<a name="ln1029">			break;</a>
<a name="ln1030">		}</a>
<a name="ln1031"> </a>
<a name="ln1032">		case POP_OTHER_REFRESH_MSG:</a>
<a name="ln1033">		{</a>
<a name="ln1034">			// make sure menu shows something useful</a>
<a name="ln1035">			_UpdateRefreshControl();</a>
<a name="ln1036"> </a>
<a name="ln1037">			float min = 0, max = 999;</a>
<a name="ln1038">			fScreenMode.GetRefreshLimits(fSelected, min, max);</a>
<a name="ln1039">			if (min &lt; gMinRefresh)</a>
<a name="ln1040">				min = gMinRefresh;</a>
<a name="ln1041">			if (max &gt; gMaxRefresh)</a>
<a name="ln1042">				max = gMaxRefresh;</a>
<a name="ln1043"> </a>
<a name="ln1044">			monitor_info info;</a>
<a name="ln1045">			if (fScreenMode.GetMonitorInfo(info) == B_OK) {</a>
<a name="ln1046">				min = max_c(info.min_vertical_frequency, min);</a>
<a name="ln1047">				max = min_c(info.max_vertical_frequency, max);</a>
<a name="ln1048">			}</a>
<a name="ln1049"> </a>
<a name="ln1050">			RefreshWindow *fRefreshWindow = new RefreshWindow(</a>
<a name="ln1051">				fRefreshField-&gt;ConvertToScreen(B_ORIGIN), fSelected.refresh,</a>
<a name="ln1052">				min, max);</a>
<a name="ln1053">			fRefreshWindow-&gt;Show();</a>
<a name="ln1054">			break;</a>
<a name="ln1055">		}</a>
<a name="ln1056"> </a>
<a name="ln1057">		case SET_CUSTOM_REFRESH_MSG:</a>
<a name="ln1058">		{</a>
<a name="ln1059">			// user pressed &quot;done&quot; in &quot;Other…&quot; refresh dialog;</a>
<a name="ln1060">			// select the refresh rate chosen</a>
<a name="ln1061">			message-&gt;FindFloat(&quot;refresh&quot;, &amp;fSelected.refresh);</a>
<a name="ln1062"> </a>
<a name="ln1063">			_UpdateRefreshControl();</a>
<a name="ln1064">			_CheckApplyEnabled();</a>
<a name="ln1065">			break;</a>
<a name="ln1066">		}</a>
<a name="ln1067"> </a>
<a name="ln1068">		case POP_COMBINE_DISPLAYS_MSG:</a>
<a name="ln1069">		{</a>
<a name="ln1070">			// new combine mode has bee chosen</a>
<a name="ln1071">			int32 mode;</a>
<a name="ln1072">			if (message-&gt;FindInt32(&quot;mode&quot;, &amp;mode) == B_OK)</a>
<a name="ln1073">				fSelected.combine = (combine_mode)mode;</a>
<a name="ln1074"> </a>
<a name="ln1075">			_CheckResolutionMenu();</a>
<a name="ln1076">			_CheckApplyEnabled();</a>
<a name="ln1077">			break;</a>
<a name="ln1078">		}</a>
<a name="ln1079"> </a>
<a name="ln1080">		case POP_SWAP_DISPLAYS_MSG:</a>
<a name="ln1081">			message-&gt;FindBool(&quot;swap&quot;, &amp;fSelected.swap_displays);</a>
<a name="ln1082">			_CheckApplyEnabled();</a>
<a name="ln1083">			break;</a>
<a name="ln1084"> </a>
<a name="ln1085">		case POP_USE_LAPTOP_PANEL_MSG:</a>
<a name="ln1086">			message-&gt;FindBool(&quot;use&quot;, &amp;fSelected.use_laptop_panel);</a>
<a name="ln1087">			_CheckApplyEnabled();</a>
<a name="ln1088">			break;</a>
<a name="ln1089"> </a>
<a name="ln1090">		case POP_TV_STANDARD_MSG:</a>
<a name="ln1091">			message-&gt;FindInt32(&quot;tv_standard&quot;, (int32 *)&amp;fSelected.tv_standard);</a>
<a name="ln1092">			_CheckApplyEnabled();</a>
<a name="ln1093">			break;</a>
<a name="ln1094"> </a>
<a name="ln1095">		case BUTTON_LAUNCH_BACKGROUNDS_MSG:</a>
<a name="ln1096">			if (be_roster-&gt;Launch(kBackgroundsSignature) == B_ALREADY_RUNNING) {</a>
<a name="ln1097">				app_info info;</a>
<a name="ln1098">				be_roster-&gt;GetAppInfo(kBackgroundsSignature, &amp;info);</a>
<a name="ln1099">				be_roster-&gt;ActivateApp(info.team);</a>
<a name="ln1100">			}</a>
<a name="ln1101">			break;</a>
<a name="ln1102"> </a>
<a name="ln1103">		case BUTTON_DEFAULTS_MSG:</a>
<a name="ln1104">		{</a>
<a name="ln1105">			// TODO: get preferred settings of screen</a>
<a name="ln1106">			fSelected.width = 640;</a>
<a name="ln1107">			fSelected.height = 480;</a>
<a name="ln1108">			fSelected.space = B_CMAP8;</a>
<a name="ln1109">			fSelected.refresh = 60.0;</a>
<a name="ln1110">			fSelected.combine = kCombineDisable;</a>
<a name="ln1111">			fSelected.swap_displays = false;</a>
<a name="ln1112">			fSelected.use_laptop_panel = false;</a>
<a name="ln1113">			fSelected.tv_standard = 0;</a>
<a name="ln1114"> </a>
<a name="ln1115">			// TODO: workspace defaults</a>
<a name="ln1116"> </a>
<a name="ln1117">			_UpdateControls();</a>
<a name="ln1118">			break;</a>
<a name="ln1119">		}</a>
<a name="ln1120"> </a>
<a name="ln1121">		case BUTTON_UNDO_MSG:</a>
<a name="ln1122">			fUndoScreenMode.Revert();</a>
<a name="ln1123">			_UpdateActiveMode();</a>
<a name="ln1124">			break;</a>
<a name="ln1125"> </a>
<a name="ln1126">		case BUTTON_REVERT_MSG:</a>
<a name="ln1127">		{</a>
<a name="ln1128">			fModified = false;</a>
<a name="ln1129">			fBootWorkspaceApplied = false;</a>
<a name="ln1130"> </a>
<a name="ln1131">			// ScreenMode::Revert() assumes that we first set the correct</a>
<a name="ln1132">			// number of workspaces</a>
<a name="ln1133"> </a>
<a name="ln1134">			BPrivate::set_workspaces_layout(fOriginalWorkspacesColumns,</a>
<a name="ln1135">				fOriginalWorkspacesRows);</a>
<a name="ln1136">			_UpdateWorkspaceButtons();</a>
<a name="ln1137"> </a>
<a name="ln1138">			fScreenMode.Revert();</a>
<a name="ln1139">			_UpdateActiveMode();</a>
<a name="ln1140"> </a>
<a name="ln1141">			BScreen screen(this);</a>
<a name="ln1142">			screen.SetBrightness(fOriginalBrightness);</a>
<a name="ln1143">			fBrightnessSlider-&gt;SetValue(fOriginalBrightness * 255);</a>
<a name="ln1144">			break;</a>
<a name="ln1145">		}</a>
<a name="ln1146"> </a>
<a name="ln1147">		case BUTTON_APPLY_MSG:</a>
<a name="ln1148">			_Apply();</a>
<a name="ln1149">			break;</a>
<a name="ln1150"> </a>
<a name="ln1151">		case MAKE_INITIAL_MSG:</a>
<a name="ln1152">			// user pressed &quot;keep&quot; in confirmation dialog</a>
<a name="ln1153">			fModified = true;</a>
<a name="ln1154">			_UpdateActiveMode();</a>
<a name="ln1155">			break;</a>
<a name="ln1156"> </a>
<a name="ln1157">		case UPDATE_DESKTOP_COLOR_MSG:</a>
<a name="ln1158">			PostMessage(message, fMonitorView);</a>
<a name="ln1159">			break;</a>
<a name="ln1160"> </a>
<a name="ln1161">		case SLIDER_BRIGHTNESS_MSG:</a>
<a name="ln1162">		{</a>
<a name="ln1163">			BScreen screen(this);</a>
<a name="ln1164">			screen.SetBrightness(message-&gt;FindInt32(&quot;be:value&quot;) / 255.f);</a>
<a name="ln1165">			_CheckApplyEnabled();</a>
<a name="ln1166">			break;</a>
<a name="ln1167">		}</a>
<a name="ln1168"> </a>
<a name="ln1169">		default:</a>
<a name="ln1170">			BWindow::MessageReceived(message);</a>
<a name="ln1171">	}</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174"> </a>
<a name="ln1175">status_t</a>
<a name="ln1176">ScreenWindow::_WriteVesaModeFile(const screen_mode&amp; mode) const</a>
<a name="ln1177">{</a>
<a name="ln1178">	BPath path;</a>
<a name="ln1179">	status_t status = find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path, true);</a>
<a name="ln1180">	if (status &lt; B_OK)</a>
<a name="ln1181">		return status;</a>
<a name="ln1182"> </a>
<a name="ln1183">	path.Append(&quot;kernel/drivers&quot;);</a>
<a name="ln1184">	status = create_directory(path.Path(), 0755);</a>
<a name="ln1185">	if (status &lt; B_OK)</a>
<a name="ln1186">		return status;</a>
<a name="ln1187"> </a>
<a name="ln1188">	path.Append(&quot;vesa&quot;);</a>
<a name="ln1189">	BFile file;</a>
<a name="ln1190">	status = file.SetTo(path.Path(), B_CREATE_FILE | B_WRITE_ONLY | B_ERASE_FILE);</a>
<a name="ln1191">	if (status &lt; B_OK)</a>
<a name="ln1192">		return status;</a>
<a name="ln1193"> </a>
<a name="ln1194">	char buffer[256];</a>
<a name="ln1195">	snprintf(buffer, sizeof(buffer), &quot;mode %&quot; B_PRId32 &quot; %&quot; B_PRId32 &quot; %&quot;</a>
<a name="ln1196">		B_PRId32 &quot;\n&quot;, mode.width, mode.height, mode.BitsPerPixel());</a>
<a name="ln1197"> </a>
<a name="ln1198">	ssize_t bytesWritten = file.Write(buffer, strlen(buffer));</a>
<a name="ln1199">	if (bytesWritten &lt; B_OK)</a>
<a name="ln1200">		return bytesWritten;</a>
<a name="ln1201"> </a>
<a name="ln1202">	return B_OK;</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205"> </a>
<a name="ln1206">void</a>
<a name="ln1207">ScreenWindow::_BuildSupportedColorSpaces()</a>
<a name="ln1208">{</a>
<a name="ln1209">	fSupportedColorSpaces = 0;</a>
<a name="ln1210"> </a>
<a name="ln1211">	for (int32 i = 0; i &lt; kColorSpaceCount; i++) {</a>
<a name="ln1212">		for (int32 j = 0; j &lt; fScreenMode.CountModes(); j++) {</a>
<a name="ln1213">			if (fScreenMode.ModeAt(j).space == kColorSpaces[i].space) {</a>
<a name="ln1214">				fSupportedColorSpaces |= 1 &lt;&lt; i;</a>
<a name="ln1215">				break;</a>
<a name="ln1216">			}</a>
<a name="ln1217">		}</a>
<a name="ln1218">	}</a>
<a name="ln1219">}</a>
<a name="ln1220"> </a>
<a name="ln1221"> </a>
<a name="ln1222">void</a>
<a name="ln1223">ScreenWindow::_CheckApplyEnabled()</a>
<a name="ln1224">{</a>
<a name="ln1225">	bool applyEnabled = true;</a>
<a name="ln1226"> </a>
<a name="ln1227">	if (fSelected == fActive) {</a>
<a name="ln1228">		applyEnabled = false;</a>
<a name="ln1229">		if (fAllWorkspacesItem-&gt;IsMarked()) {</a>
<a name="ln1230">			screen_mode screenMode;</a>
<a name="ln1231">			const int32 workspaceCount = count_workspaces();</a>
<a name="ln1232">			for (int32 i = 0; i &lt; workspaceCount; i++) {</a>
<a name="ln1233">				fScreenMode.Get(screenMode, i);</a>
<a name="ln1234">				if (screenMode != fSelected) {</a>
<a name="ln1235">					applyEnabled = true;</a>
<a name="ln1236">					break;</a>
<a name="ln1237">				}</a>
<a name="ln1238">			}</a>
<a name="ln1239">		}</a>
<a name="ln1240">	}</a>
<a name="ln1241"> </a>
<a name="ln1242">	fApplyButton-&gt;SetEnabled(applyEnabled);</a>
<a name="ln1243"> </a>
<a name="ln1244">	uint32 columns;</a>
<a name="ln1245">	uint32 rows;</a>
<a name="ln1246">	BPrivate::get_workspaces_layout(&amp;columns, &amp;rows);</a>
<a name="ln1247"> </a>
<a name="ln1248">	BScreen screen(this);</a>
<a name="ln1249">	float brightness = -1;</a>
<a name="ln1250">	screen.GetBrightness(&amp;brightness);</a>
<a name="ln1251"> </a>
<a name="ln1252">	fRevertButton-&gt;SetEnabled(columns != fOriginalWorkspacesColumns</a>
<a name="ln1253">		|| rows != fOriginalWorkspacesRows</a>
<a name="ln1254">		|| brightness != fOriginalBrightness</a>
<a name="ln1255">		|| fSelected != fOriginal);</a>
<a name="ln1256">}</a>
<a name="ln1257"> </a>
<a name="ln1258"> </a>
<a name="ln1259">void</a>
<a name="ln1260">ScreenWindow::_UpdateOriginal()</a>
<a name="ln1261">{</a>
<a name="ln1262">	BPrivate::get_workspaces_layout(&amp;fOriginalWorkspacesColumns,</a>
<a name="ln1263">		&amp;fOriginalWorkspacesRows);</a>
<a name="ln1264"> </a>
<a name="ln1265">	fScreenMode.Get(fOriginal);</a>
<a name="ln1266">	fScreenMode.UpdateOriginalModes();</a>
<a name="ln1267">}</a>
<a name="ln1268"> </a>
<a name="ln1269"> </a>
<a name="ln1270">void</a>
<a name="ln1271">ScreenWindow::_UpdateMonitor()</a>
<a name="ln1272">{</a>
<a name="ln1273">	monitor_info info;</a>
<a name="ln1274">	float diagonalInches;</a>
<a name="ln1275">	status_t status = fScreenMode.GetMonitorInfo(info, &amp;diagonalInches);</a>
<a name="ln1276">	if (status == B_OK) {</a>
<a name="ln1277">		char text[512];</a>
<a name="ln1278">		snprintf(text, sizeof(text), &quot;%s%s%s %g\&quot;&quot;, info.vendor,</a>
<a name="ln1279">			info.name[0] ? &quot; &quot; : &quot;&quot;, info.name, diagonalInches);</a>
<a name="ln1280"> </a>
<a name="ln1281">		fMonitorInfo-&gt;SetText(text);</a>
<a name="ln1282"> </a>
<a name="ln1283">		if (fMonitorInfo-&gt;IsHidden(fMonitorInfo))</a>
<a name="ln1284">			fMonitorInfo-&gt;Show();</a>
<a name="ln1285">	} else {</a>
<a name="ln1286">		if (!fMonitorInfo-&gt;IsHidden(fMonitorInfo))</a>
<a name="ln1287">			fMonitorInfo-&gt;Hide();</a>
<a name="ln1288">	}</a>
<a name="ln1289"> </a>
<a name="ln1290">	// Add info about the graphics device</a>
<a name="ln1291"> </a>
<a name="ln1292">	accelerant_device_info deviceInfo;</a>
<a name="ln1293"> </a>
<a name="ln1294">	if (fScreenMode.GetDeviceInfo(deviceInfo) == B_OK) {</a>
<a name="ln1295">		BString deviceString;</a>
<a name="ln1296"> </a>
<a name="ln1297">		if (deviceInfo.name[0] &amp;&amp; deviceInfo.chipset[0]) {</a>
<a name="ln1298">			deviceString.SetToFormat(&quot;%s (%s)&quot;, deviceInfo.name,</a>
<a name="ln1299">				deviceInfo.chipset);</a>
<a name="ln1300">		} else if (deviceInfo.name[0] || deviceInfo.chipset[0]) {</a>
<a name="ln1301">			deviceString</a>
<a name="ln1302">				= deviceInfo.name[0] ? deviceInfo.name : deviceInfo.chipset;</a>
<a name="ln1303">		}</a>
<a name="ln1304"> </a>
<a name="ln1305">		fDeviceInfo-&gt;SetText(deviceString);</a>
<a name="ln1306">	}</a>
<a name="ln1307"> </a>
<a name="ln1308"> </a>
<a name="ln1309">	char text[512];</a>
<a name="ln1310">	size_t length = 0;</a>
<a name="ln1311">	text[0] = 0;</a>
<a name="ln1312"> </a>
<a name="ln1313">	if (status == B_OK) {</a>
<a name="ln1314">		if (info.min_horizontal_frequency != 0</a>
<a name="ln1315">			&amp;&amp; info.min_vertical_frequency != 0</a>
<a name="ln1316">			&amp;&amp; info.max_pixel_clock != 0) {</a>
<a name="ln1317">			length = snprintf(text, sizeof(text),</a>
<a name="ln1318">				B_TRANSLATE(&quot;Horizonal frequency:\t%lu - %lu kHz\n&quot;</a>
<a name="ln1319">				&quot;Vertical frequency:\t%lu - %lu Hz\n\n&quot;</a>
<a name="ln1320">				&quot;Maximum pixel clock:\t%g MHz&quot;),</a>
<a name="ln1321">				info.min_horizontal_frequency, info.max_horizontal_frequency,</a>
<a name="ln1322">				info.min_vertical_frequency, info.max_vertical_frequency,</a>
<a name="ln1323">				info.max_pixel_clock / 1000.0);</a>
<a name="ln1324">		}</a>
<a name="ln1325">		if (info.serial_number[0] &amp;&amp; length &lt; sizeof(text)) {</a>
<a name="ln1326">			length += snprintf(text + length, sizeof(text) - length,</a>
<a name="ln1327">				B_TRANSLATE(&quot;%sSerial no.: %s&quot;), length ? &quot;\n\n&quot; : &quot;&quot;,</a>
<a name="ln1328">				info.serial_number);</a>
<a name="ln1329">			if (info.produced.week != 0 &amp;&amp; info.produced.year != 0</a>
<a name="ln1330">				&amp;&amp; length &lt; sizeof(text)) {</a>
<a name="ln1331">				length += snprintf(text + length, sizeof(text) - length,</a>
<a name="ln1332">					&quot; (%u/%u)&quot;, info.produced.week, info.produced.year);</a>
<a name="ln1333">			}</a>
<a name="ln1334">		}</a>
<a name="ln1335">	}</a>
<a name="ln1336"> </a>
<a name="ln1337">	if (text[0])</a>
<a name="ln1338">		fMonitorView-&gt;SetToolTip(text);</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341"> </a>
<a name="ln1342">void</a>
<a name="ln1343">ScreenWindow::_UpdateColorLabel()</a>
<a name="ln1344">{</a>
<a name="ln1345">	BString string;</a>
<a name="ln1346">	string &lt;&lt; fSelected.BitsPerPixel() &lt;&lt; &quot; &quot; &lt;&lt; B_TRANSLATE(&quot;bits/pixel&quot;);</a>
<a name="ln1347">	fColorsMenu-&gt;Superitem()-&gt;SetLabel(string.String());</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350"> </a>
<a name="ln1351">void</a>
<a name="ln1352">ScreenWindow::_Apply()</a>
<a name="ln1353">{</a>
<a name="ln1354">	// make checkpoint, so we can undo these changes</a>
<a name="ln1355">	fUndoScreenMode.UpdateOriginalModes();</a>
<a name="ln1356"> </a>
<a name="ln1357">	status_t status = fScreenMode.Set(fSelected);</a>
<a name="ln1358">	if (status == B_OK) {</a>
<a name="ln1359">		// use the mode that has eventually been set and</a>
<a name="ln1360">		// thus we know to be working; it can differ from</a>
<a name="ln1361">		// the mode selected by user due to hardware limitation</a>
<a name="ln1362">		display_mode newMode;</a>
<a name="ln1363">		BScreen screen(this);</a>
<a name="ln1364">		screen.GetMode(&amp;newMode);</a>
<a name="ln1365"> </a>
<a name="ln1366">		if (fAllWorkspacesItem-&gt;IsMarked()) {</a>
<a name="ln1367">			int32 originatingWorkspace = current_workspace();</a>
<a name="ln1368">			const int32 workspaceCount = count_workspaces();</a>
<a name="ln1369">			for (int32 i = 0; i &lt; workspaceCount; i++) {</a>
<a name="ln1370">				if (i != originatingWorkspace)</a>
<a name="ln1371">					screen.SetMode(i, &amp;newMode, true);</a>
<a name="ln1372">			}</a>
<a name="ln1373">			fBootWorkspaceApplied = true;</a>
<a name="ln1374">		} else {</a>
<a name="ln1375">			if (current_workspace() == 0)</a>
<a name="ln1376">				fBootWorkspaceApplied = true;</a>
<a name="ln1377">		}</a>
<a name="ln1378"> </a>
<a name="ln1379">		fActive = fSelected;</a>
<a name="ln1380"> </a>
<a name="ln1381">		// TODO: only show alert when this is an unknown mode</a>
<a name="ln1382">		BAlert* window = new AlertWindow(this);</a>
<a name="ln1383">		window-&gt;Go(NULL);</a>
<a name="ln1384">	} else {</a>
<a name="ln1385">		char message[256];</a>
<a name="ln1386">		snprintf(message, sizeof(message),</a>
<a name="ln1387">			B_TRANSLATE(&quot;The screen mode could not be set:\n\t%s\n&quot;),</a>
<a name="ln1388">			screen_errors(status));</a>
<a name="ln1389">		BAlert* alert = new BAlert(B_TRANSLATE(&quot;Warning&quot;), message,</a>
<a name="ln1390">			B_TRANSLATE(&quot;OK&quot;), NULL, NULL,</a>
<a name="ln1391">			B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1392">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1393">		alert-&gt;Go();</a>
<a name="ln1394">	}</a>
<a name="ln1395">}</a>

</code></pre>
<div class="balloon" rel="590"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1384"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'window' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1394"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="741"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'fOtherRefresh' pointer was utilized before it was verified against nullptr. Check lines: 741, 747.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
