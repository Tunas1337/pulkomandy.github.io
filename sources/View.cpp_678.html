
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>View.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2017 Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan Aßmus, superstippi@gmx.de</a>
<a name="ln7"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln8"> *		Adrian Oanca, adioanca@cotty.iren.ro</a>
<a name="ln9"> *		Ingo Weinhold. ingo_weinhold@gmx.de</a>
<a name="ln10"> *		Julian Harnath, julian.harnath@rwth-aachen.de</a>
<a name="ln11"> *		Joseph Groover, looncraz@looncraz.net</a>
<a name="ln12"> */</a>
<a name="ln13"> </a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;View.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;algorithm&gt;</a>
<a name="ln18">#include &lt;new&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;math.h&gt;</a>
<a name="ln21">#include &lt;stdio.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;Application.h&gt;</a>
<a name="ln24">#include &lt;Bitmap.h&gt;</a>
<a name="ln25">#include &lt;Button.h&gt;</a>
<a name="ln26">#include &lt;Cursor.h&gt;</a>
<a name="ln27">#include &lt;File.h&gt;</a>
<a name="ln28">#include &lt;GradientLinear.h&gt;</a>
<a name="ln29">#include &lt;GradientRadial.h&gt;</a>
<a name="ln30">#include &lt;GradientRadialFocus.h&gt;</a>
<a name="ln31">#include &lt;GradientDiamond.h&gt;</a>
<a name="ln32">#include &lt;GradientConic.h&gt;</a>
<a name="ln33">#include &lt;InterfaceDefs.h&gt;</a>
<a name="ln34">#include &lt;Layout.h&gt;</a>
<a name="ln35">#include &lt;LayoutContext.h&gt;</a>
<a name="ln36">#include &lt;LayoutUtils.h&gt;</a>
<a name="ln37">#include &lt;MenuBar.h&gt;</a>
<a name="ln38">#include &lt;Message.h&gt;</a>
<a name="ln39">#include &lt;MessageQueue.h&gt;</a>
<a name="ln40">#include &lt;ObjectList.h&gt;</a>
<a name="ln41">#include &lt;Picture.h&gt;</a>
<a name="ln42">#include &lt;Point.h&gt;</a>
<a name="ln43">#include &lt;Polygon.h&gt;</a>
<a name="ln44">#include &lt;PropertyInfo.h&gt;</a>
<a name="ln45">#include &lt;Region.h&gt;</a>
<a name="ln46">#include &lt;ScrollBar.h&gt;</a>
<a name="ln47">#include &lt;Shape.h&gt;</a>
<a name="ln48">#include &lt;Shelf.h&gt;</a>
<a name="ln49">#include &lt;String.h&gt;</a>
<a name="ln50">#include &lt;Window.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;AppMisc.h&gt;</a>
<a name="ln53">#include &lt;AppServerLink.h&gt;</a>
<a name="ln54">#include &lt;binary_compatibility/Interface.h&gt;</a>
<a name="ln55">#include &lt;binary_compatibility/Support.h&gt;</a>
<a name="ln56">#include &lt;MessagePrivate.h&gt;</a>
<a name="ln57">#include &lt;MessageUtils.h&gt;</a>
<a name="ln58">#include &lt;PortLink.h&gt;</a>
<a name="ln59">#include &lt;ServerProtocol.h&gt;</a>
<a name="ln60">#include &lt;ServerProtocolStructs.h&gt;</a>
<a name="ln61">#include &lt;ShapePrivate.h&gt;</a>
<a name="ln62">#include &lt;ToolTip.h&gt;</a>
<a name="ln63">#include &lt;ToolTipManager.h&gt;</a>
<a name="ln64">#include &lt;TokenSpace.h&gt;</a>
<a name="ln65">#include &lt;ViewPrivate.h&gt;</a>
<a name="ln66"> </a>
<a name="ln67">using std::nothrow;</a>
<a name="ln68"> </a>
<a name="ln69">//#define DEBUG_BVIEW</a>
<a name="ln70">#ifdef DEBUG_BVIEW</a>
<a name="ln71">#	include &lt;stdio.h&gt;</a>
<a name="ln72">#	define STRACE(x) printf x</a>
<a name="ln73">#	define BVTRACE _PrintToStream()</a>
<a name="ln74">#else</a>
<a name="ln75">#	define STRACE(x) ;</a>
<a name="ln76">#	define BVTRACE ;</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79"> </a>
<a name="ln80">static property_info sViewPropInfo[] = {</a>
<a name="ln81">	{ &quot;Frame&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln82">		{ B_DIRECT_SPECIFIER, 0 }, &quot;The view's frame rectangle.&quot;, 0,</a>
<a name="ln83">		{ B_RECT_TYPE }</a>
<a name="ln84">	},</a>
<a name="ln85">	{ &quot;Hidden&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln86">		{ B_DIRECT_SPECIFIER, 0 }, &quot;Whether or not the view is hidden.&quot;,</a>
<a name="ln87">		0, { B_BOOL_TYPE }</a>
<a name="ln88">	},</a>
<a name="ln89">	{ &quot;Shelf&quot;, { 0 },</a>
<a name="ln90">		{ B_DIRECT_SPECIFIER, 0 }, &quot;Directs the scripting message to the &quot;</a>
<a name="ln91">			&quot;shelf.&quot;, 0</a>
<a name="ln92">	},</a>
<a name="ln93">	{ &quot;View&quot;, { B_COUNT_PROPERTIES, 0 },</a>
<a name="ln94">		{ B_DIRECT_SPECIFIER, 0 }, &quot;Returns the number of child views.&quot;, 0,</a>
<a name="ln95">		{ B_INT32_TYPE }</a>
<a name="ln96">	},</a>
<a name="ln97">	{ &quot;View&quot;, { 0 },</a>
<a name="ln98">		{ B_INDEX_SPECIFIER, B_REVERSE_INDEX_SPECIFIER, B_NAME_SPECIFIER, 0 },</a>
<a name="ln99">		&quot;Directs the scripting message to the specified view.&quot;, 0</a>
<a name="ln100">	},</a>
<a name="ln101"> </a>
<a name="ln102">	{ 0 }</a>
<a name="ln103">};</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">//	#pragma mark -</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">static inline uint32</a>
<a name="ln110">get_uint32_color(rgb_color color)</a>
<a name="ln111">{</a>
<a name="ln112">	return B_BENDIAN_TO_HOST_INT32(*(uint32*)&amp;color);</a>
<a name="ln113">		// rgb_color is always in rgba format, no matter what endian;</a>
<a name="ln114">		// we always return the int32 value in host endian.</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117"> </a>
<a name="ln118">static inline rgb_color</a>
<a name="ln119">get_rgb_color(uint32 value)</a>
<a name="ln120">{</a>
<a name="ln121">	value = B_HOST_TO_BENDIAN_INT32(value);</a>
<a name="ln122">	return *(rgb_color*)&amp;value;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">//	#pragma mark -</a>
<a name="ln127"> </a>
<a name="ln128"> </a>
<a name="ln129">namespace BPrivate {</a>
<a name="ln130"> </a>
<a name="ln131">ViewState::ViewState()</a>
<a name="ln132">{</a>
<a name="ln133">	pen_location.Set(0, 0);</a>
<a name="ln134">	pen_size = 1.0;</a>
<a name="ln135"> </a>
<a name="ln136">	// NOTE: the clipping_region is empty</a>
<a name="ln137">	// on construction but it is not used yet,</a>
<a name="ln138">	// we avoid having to keep track of it via</a>
<a name="ln139">	// this flag</a>
<a name="ln140">	clipping_region_used = false;</a>
<a name="ln141"> </a>
<a name="ln142">	high_color = (rgb_color){ 0, 0, 0, 255 };</a>
<a name="ln143">	low_color = (rgb_color){ 255, 255, 255, 255 };</a>
<a name="ln144">	view_color = low_color;</a>
<a name="ln145">	which_view_color = B_NO_COLOR;</a>
<a name="ln146">	which_view_color_tint = B_NO_TINT;</a>
<a name="ln147"> </a>
<a name="ln148">	which_high_color = B_NO_COLOR;</a>
<a name="ln149">	which_high_color_tint = B_NO_TINT;</a>
<a name="ln150"> </a>
<a name="ln151">	which_low_color = B_NO_COLOR;</a>
<a name="ln152">	which_low_color_tint = B_NO_TINT;</a>
<a name="ln153"> </a>
<a name="ln154">	pattern = B_SOLID_HIGH;</a>
<a name="ln155">	drawing_mode = B_OP_COPY;</a>
<a name="ln156"> </a>
<a name="ln157">	origin.Set(0, 0);</a>
<a name="ln158"> </a>
<a name="ln159">	line_join = B_MITER_JOIN;</a>
<a name="ln160">	line_cap = B_BUTT_CAP;</a>
<a name="ln161">	miter_limit = B_DEFAULT_MITER_LIMIT;</a>
<a name="ln162">	fill_rule = B_NONZERO;</a>
<a name="ln163"> </a>
<a name="ln164">	alpha_source_mode = B_PIXEL_ALPHA;</a>
<a name="ln165">	alpha_function_mode = B_ALPHA_OVERLAY;</a>
<a name="ln166"> </a>
<a name="ln167">	scale = 1.0;</a>
<a name="ln168"> </a>
<a name="ln169">	font = *be_plain_font;</a>
<a name="ln170">	font_flags = font.Flags();</a>
<a name="ln171">	font_aliasing = false;</a>
<a name="ln172"> </a>
<a name="ln173">	// We only keep the B_VIEW_CLIP_REGION_BIT flag invalidated,</a>
<a name="ln174">	// because we should get the clipping region from app_server.</a>
<a name="ln175">	// The other flags do not need to be included because the data they</a>
<a name="ln176">	// represent is already in sync with app_server - app_server uses the</a>
<a name="ln177">	// same init (default) values.</a>
<a name="ln178">	valid_flags = ~B_VIEW_CLIP_REGION_BIT;</a>
<a name="ln179"> </a>
<a name="ln180">	archiving_flags = B_VIEW_FRAME_BIT | B_VIEW_RESIZE_BIT;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183"> </a>
<a name="ln184">void</a>
<a name="ln185">ViewState::UpdateServerFontState(BPrivate::PortLink &amp;link)</a>
<a name="ln186">{</a>
<a name="ln187">	link.StartMessage(AS_VIEW_SET_FONT_STATE);</a>
<a name="ln188">	link.Attach&lt;uint16&gt;(font_flags);</a>
<a name="ln189">		// always present</a>
<a name="ln190"> </a>
<a name="ln191">	if (font_flags &amp; B_FONT_FAMILY_AND_STYLE)</a>
<a name="ln192">		link.Attach&lt;uint32&gt;(font.FamilyAndStyle());</a>
<a name="ln193"> </a>
<a name="ln194">	if (font_flags &amp; B_FONT_SIZE)</a>
<a name="ln195">		link.Attach&lt;float&gt;(font.Size());</a>
<a name="ln196"> </a>
<a name="ln197">	if (font_flags &amp; B_FONT_SHEAR)</a>
<a name="ln198">		link.Attach&lt;float&gt;(font.Shear());</a>
<a name="ln199"> </a>
<a name="ln200">	if (font_flags &amp; B_FONT_ROTATION)</a>
<a name="ln201">		link.Attach&lt;float&gt;(font.Rotation());</a>
<a name="ln202"> </a>
<a name="ln203">	if (font_flags &amp; B_FONT_FALSE_BOLD_WIDTH)</a>
<a name="ln204">		link.Attach&lt;float&gt;(font.FalseBoldWidth());</a>
<a name="ln205"> </a>
<a name="ln206">	if (font_flags &amp; B_FONT_SPACING)</a>
<a name="ln207">		link.Attach&lt;uint8&gt;(font.Spacing());</a>
<a name="ln208"> </a>
<a name="ln209">	if (font_flags &amp; B_FONT_ENCODING)</a>
<a name="ln210">		link.Attach&lt;uint8&gt;(font.Encoding());</a>
<a name="ln211"> </a>
<a name="ln212">	if (font_flags &amp; B_FONT_FACE)</a>
<a name="ln213">		link.Attach&lt;uint16&gt;(font.Face());</a>
<a name="ln214"> </a>
<a name="ln215">	if (font_flags &amp; B_FONT_FLAGS)</a>
<a name="ln216">		link.Attach&lt;uint32&gt;(font.Flags());</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">void</a>
<a name="ln221">ViewState::UpdateServerState(BPrivate::PortLink &amp;link)</a>
<a name="ln222">{</a>
<a name="ln223">	UpdateServerFontState(link);</a>
<a name="ln224"> </a>
<a name="ln225">	link.StartMessage(AS_VIEW_SET_STATE);</a>
<a name="ln226"> </a>
<a name="ln227">	ViewSetStateInfo info;</a>
<a name="ln228">	info.penLocation = pen_location;</a>
<a name="ln229">	info.penSize = pen_size;</a>
<a name="ln230">	info.highColor = high_color;</a>
<a name="ln231">	info.lowColor = low_color;</a>
<a name="ln232">	info.whichHighColor = which_high_color;</a>
<a name="ln233">	info.whichLowColor = which_low_color;</a>
<a name="ln234">	info.whichHighColorTint = which_high_color_tint;</a>
<a name="ln235">	info.whichLowColorTint = which_low_color_tint;</a>
<a name="ln236">	info.pattern = pattern;</a>
<a name="ln237">	info.drawingMode = drawing_mode;</a>
<a name="ln238">	info.origin = origin;</a>
<a name="ln239">	info.scale = scale;</a>
<a name="ln240">	info.lineJoin = line_join;</a>
<a name="ln241">	info.lineCap = line_cap;</a>
<a name="ln242">	info.miterLimit = miter_limit;</a>
<a name="ln243">	info.fillRule = fill_rule;</a>
<a name="ln244">	info.alphaSourceMode = alpha_source_mode;</a>
<a name="ln245">	info.alphaFunctionMode = alpha_function_mode;</a>
<a name="ln246">	info.fontAntialiasing = font_aliasing;</a>
<a name="ln247">	link.Attach&lt;ViewSetStateInfo&gt;(info);</a>
<a name="ln248"> </a>
<a name="ln249">	// BAffineTransform is transmitted as a double array</a>
<a name="ln250">	double _transform[6];</a>
<a name="ln251">	if (transform.Flatten(_transform, sizeof(_transform)) != B_OK)</a>
<a name="ln252">		return;</a>
<a name="ln253">	link.Attach&lt;double[6]&gt;(_transform);</a>
<a name="ln254"> </a>
<a name="ln255">	// we send the 'local' clipping region... if we have one...</a>
<a name="ln256">	// TODO: Could be optimized, but is low prio, since most views won't</a>
<a name="ln257">	// have a custom clipping region.</a>
<a name="ln258">	if (clipping_region_used) {</a>
<a name="ln259">		int32 count = clipping_region.CountRects();</a>
<a name="ln260">		link.Attach&lt;int32&gt;(count);</a>
<a name="ln261">		for (int32 i = 0; i &lt; count; i++)</a>
<a name="ln262">			link.Attach&lt;BRect&gt;(clipping_region.RectAt(i));</a>
<a name="ln263">	} else {</a>
<a name="ln264">		// no clipping region</a>
<a name="ln265">		link.Attach&lt;int32&gt;(-1);</a>
<a name="ln266">	}</a>
<a name="ln267"> </a>
<a name="ln268">	// Although we might have a 'local' clipping region, when we call</a>
<a name="ln269">	// BView::GetClippingRegion() we ask for the 'global' one and it</a>
<a name="ln270">	// is kept on server, so we must invalidate B_VIEW_CLIP_REGION_BIT flag</a>
<a name="ln271"> </a>
<a name="ln272">	valid_flags = ~B_VIEW_CLIP_REGION_BIT;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275"> </a>
<a name="ln276">void</a>
<a name="ln277">ViewState::UpdateFrom(BPrivate::PortLink &amp;link)</a>
<a name="ln278">{</a>
<a name="ln279">	link.StartMessage(AS_VIEW_GET_STATE);</a>
<a name="ln280"> </a>
<a name="ln281">	int32 code;</a>
<a name="ln282">	if (link.FlushWithReply(code) != B_OK</a>
<a name="ln283">		|| code != B_OK)</a>
<a name="ln284">		return;</a>
<a name="ln285"> </a>
<a name="ln286">	ViewGetStateInfo info;</a>
<a name="ln287">	link.Read&lt;ViewGetStateInfo&gt;(&amp;info);</a>
<a name="ln288"> </a>
<a name="ln289">	// set view's font state</a>
<a name="ln290">	font_flags = B_FONT_ALL;</a>
<a name="ln291">	font.SetFamilyAndStyle(info.fontID);</a>
<a name="ln292">	font.SetSize(info.fontSize);</a>
<a name="ln293">	font.SetShear(info.fontShear);</a>
<a name="ln294">	font.SetRotation(info.fontRotation);</a>
<a name="ln295">	font.SetFalseBoldWidth(info.fontFalseBoldWidth);</a>
<a name="ln296">	font.SetSpacing(info.fontSpacing);</a>
<a name="ln297">	font.SetEncoding(info.fontEncoding);</a>
<a name="ln298">	font.SetFace(info.fontFace);</a>
<a name="ln299">	font.SetFlags(info.fontFlags);</a>
<a name="ln300"> </a>
<a name="ln301">	// set view's state</a>
<a name="ln302">	pen_location = info.viewStateInfo.penLocation;</a>
<a name="ln303">	pen_size = info.viewStateInfo.penSize;</a>
<a name="ln304">	high_color = info.viewStateInfo.highColor;</a>
<a name="ln305">	low_color = info.viewStateInfo.lowColor;</a>
<a name="ln306">	pattern = info.viewStateInfo.pattern;</a>
<a name="ln307">	drawing_mode = info.viewStateInfo.drawingMode;</a>
<a name="ln308">	origin = info.viewStateInfo.origin;</a>
<a name="ln309">	scale = info.viewStateInfo.scale;</a>
<a name="ln310">	line_join = info.viewStateInfo.lineJoin;</a>
<a name="ln311">	line_cap = info.viewStateInfo.lineCap;</a>
<a name="ln312">	miter_limit = info.viewStateInfo.miterLimit;</a>
<a name="ln313">	fill_rule = info.viewStateInfo.fillRule;</a>
<a name="ln314">	alpha_source_mode = info.viewStateInfo.alphaSourceMode;</a>
<a name="ln315">	alpha_function_mode = info.viewStateInfo.alphaFunctionMode;</a>
<a name="ln316">	font_aliasing = info.viewStateInfo.fontAntialiasing;</a>
<a name="ln317"> </a>
<a name="ln318">	// BAffineTransform is transmitted as a double array</a>
<a name="ln319">	double _transform[6];</a>
<a name="ln320">	link.Read&lt;double[6]&gt;(&amp;_transform);</a>
<a name="ln321">	if (transform.Unflatten(B_AFFINE_TRANSFORM_TYPE, _transform,</a>
<a name="ln322">		sizeof(_transform)) != B_OK) {</a>
<a name="ln323">		return;</a>
<a name="ln324">	}</a>
<a name="ln325"> </a>
<a name="ln326">	// read the user clipping</a>
<a name="ln327">	// (that's NOT the current View visible clipping but the additional</a>
<a name="ln328">	// user specified clipping!)</a>
<a name="ln329">	int32 clippingRectCount;</a>
<a name="ln330">	link.Read&lt;int32&gt;(&amp;clippingRectCount);</a>
<a name="ln331">	if (clippingRectCount &gt;= 0) {</a>
<a name="ln332">		clipping_region.MakeEmpty();</a>
<a name="ln333">		for (int32 i = 0; i &lt; clippingRectCount; i++) {</a>
<a name="ln334">			BRect rect;</a>
<a name="ln335">			link.Read&lt;BRect&gt;(&amp;rect);</a>
<a name="ln336">			clipping_region.Include(rect);</a>
<a name="ln337">		}</a>
<a name="ln338">	} else {</a>
<a name="ln339">		// no user clipping used</a>
<a name="ln340">		clipping_region_used = false;</a>
<a name="ln341">	}</a>
<a name="ln342"> </a>
<a name="ln343">	valid_flags = ~B_VIEW_CLIP_REGION_BIT;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">}	// namespace BPrivate</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">//	#pragma mark -</a>
<a name="ln350"> </a>
<a name="ln351"> </a>
<a name="ln352">// archiving constants</a>
<a name="ln353">namespace {</a>
<a name="ln354">	const char* const kSizesField = &quot;BView:sizes&quot;;</a>
<a name="ln355">		// kSizesField = {min, max, pref}</a>
<a name="ln356">	const char* const kAlignmentField = &quot;BView:alignment&quot;;</a>
<a name="ln357">	const char* const kLayoutField = &quot;BView:layout&quot;;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360"> </a>
<a name="ln361">struct BView::LayoutData {</a>
<a name="ln362">	LayoutData()</a>
<a name="ln363">		:</a>
<a name="ln364">		fMinSize(),</a>
<a name="ln365">		fMaxSize(),</a>
<a name="ln366">		fPreferredSize(),</a>
<a name="ln367">		fAlignment(),</a>
<a name="ln368">		fLayoutInvalidationDisabled(0),</a>
<a name="ln369">		fLayout(NULL),</a>
<a name="ln370">		fLayoutContext(NULL),</a>
<a name="ln371">		fLayoutItems(5, false),</a>
<a name="ln372">		fLayoutValid(true),		// TODO: Rethink these initial values!</a>
<a name="ln373">		fMinMaxValid(true),		//</a>
<a name="ln374">		fLayoutInProgress(false),</a>
<a name="ln375">		fNeedsRelayout(true)</a>
<a name="ln376">	{</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	status_t</a>
<a name="ln380">	AddDataToArchive(BMessage* archive)</a>
<a name="ln381">	{</a>
<a name="ln382">		status_t err = archive-&gt;AddSize(kSizesField, fMinSize);</a>
<a name="ln383"> </a>
<a name="ln384">		if (err == B_OK)</a>
<a name="ln385">			err = archive-&gt;AddSize(kSizesField, fMaxSize);</a>
<a name="ln386"> </a>
<a name="ln387">		if (err == B_OK)</a>
<a name="ln388">			err = archive-&gt;AddSize(kSizesField, fPreferredSize);</a>
<a name="ln389"> </a>
<a name="ln390">		if (err == B_OK)</a>
<a name="ln391">			err = archive-&gt;AddAlignment(kAlignmentField, fAlignment);</a>
<a name="ln392"> </a>
<a name="ln393">		return err;</a>
<a name="ln394">	}</a>
<a name="ln395"> </a>
<a name="ln396">	void</a>
<a name="ln397">	PopulateFromArchive(BMessage* archive)</a>
<a name="ln398">	{</a>
<a name="ln399">		archive-&gt;FindSize(kSizesField, 0, &amp;fMinSize);</a>
<a name="ln400">		archive-&gt;FindSize(kSizesField, 1, &amp;fMaxSize);</a>
<a name="ln401">		archive-&gt;FindSize(kSizesField, 2, &amp;fPreferredSize);</a>
<a name="ln402">		archive-&gt;FindAlignment(kAlignmentField, &amp;fAlignment);</a>
<a name="ln403">	}</a>
<a name="ln404"> </a>
<a name="ln405">	BSize			fMinSize;</a>
<a name="ln406">	BSize			fMaxSize;</a>
<a name="ln407">	BSize			fPreferredSize;</a>
<a name="ln408">	BAlignment		fAlignment;</a>
<a name="ln409">	int				fLayoutInvalidationDisabled;</a>
<a name="ln410">	BLayout*		fLayout;</a>
<a name="ln411">	BLayoutContext*	fLayoutContext;</a>
<a name="ln412">	BObjectList&lt;BLayoutItem&gt; fLayoutItems;</a>
<a name="ln413">	bool			fLayoutValid;</a>
<a name="ln414">	bool			fMinMaxValid;</a>
<a name="ln415">	bool			fLayoutInProgress;</a>
<a name="ln416">	bool			fNeedsRelayout;</a>
<a name="ln417">};</a>
<a name="ln418"> </a>
<a name="ln419"> </a>
<a name="ln420">BView::BView(const char* name, uint32 flags, BLayout* layout)</a>
<a name="ln421">	:</a>
<a name="ln422">	BHandler(name)</a>
<a name="ln423">{</a>
<a name="ln424">	_InitData(BRect(0, 0, -1, -1), name, B_FOLLOW_NONE,</a>
<a name="ln425">		flags | B_SUPPORTS_LAYOUT);</a>
<a name="ln426">	SetLayout(layout);</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">BView::BView(BRect frame, const char* name, uint32 resizingMode, uint32 flags)</a>
<a name="ln431">	:</a>
<a name="ln432">	BHandler(name)</a>
<a name="ln433">{</a>
<a name="ln434">	_InitData(frame, name, resizingMode, flags);</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">BView::BView(BMessage* archive)</a>
<a name="ln439">	:</a>
<a name="ln440">	BHandler(BUnarchiver::PrepareArchive(archive))</a>
<a name="ln441">{</a>
<a name="ln442">	BUnarchiver unarchiver(archive);</a>
<a name="ln443">	if (!archive)</a>
<a name="ln444">		debugger(&quot;BView cannot be constructed from a NULL archive.&quot;);</a>
<a name="ln445"> </a>
<a name="ln446">	BRect frame;</a>
<a name="ln447">	archive-&gt;FindRect(&quot;_frame&quot;, &amp;frame);</a>
<a name="ln448"> </a>
<a name="ln449">	uint32 resizingMode;</a>
<a name="ln450">	if (archive-&gt;FindInt32(&quot;_resize_mode&quot;, (int32*)&amp;resizingMode) != B_OK)</a>
<a name="ln451">		resizingMode = 0;</a>
<a name="ln452"> </a>
<a name="ln453">	uint32 flags;</a>
<a name="ln454">	if (archive-&gt;FindInt32(&quot;_flags&quot;, (int32*)&amp;flags) != B_OK)</a>
<a name="ln455">		flags = 0;</a>
<a name="ln456"> </a>
<a name="ln457">	_InitData(frame, Name(), resizingMode, flags);</a>
<a name="ln458"> </a>
<a name="ln459">	font_family family;</a>
<a name="ln460">	font_style style;</a>
<a name="ln461">	if (archive-&gt;FindString(&quot;_fname&quot;, 0, (const char**)&amp;family) == B_OK</a>
<a name="ln462">		&amp;&amp; archive-&gt;FindString(&quot;_fname&quot;, 1, (const char**)&amp;style) == B_OK) {</a>
<a name="ln463">		BFont font;</a>
<a name="ln464">		font.SetFamilyAndStyle(family, style);</a>
<a name="ln465"> </a>
<a name="ln466">		float size;</a>
<a name="ln467">		if (archive-&gt;FindFloat(&quot;_fflt&quot;, 0, &amp;size) == B_OK)</a>
<a name="ln468">			font.SetSize(size);</a>
<a name="ln469"> </a>
<a name="ln470">		float shear;</a>
<a name="ln471">		if (archive-&gt;FindFloat(&quot;_fflt&quot;, 1, &amp;shear) == B_OK</a>
<a name="ln472">			&amp;&amp; shear &gt;= 45.0 &amp;&amp; shear &lt;= 135.0)</a>
<a name="ln473">			font.SetShear(shear);</a>
<a name="ln474"> </a>
<a name="ln475">		float rotation;</a>
<a name="ln476">		if (archive-&gt;FindFloat(&quot;_fflt&quot;, 2, &amp;rotation) == B_OK</a>
<a name="ln477">			&amp;&amp; rotation &gt;=0 &amp;&amp; rotation &lt;= 360)</a>
<a name="ln478">			font.SetRotation(rotation);</a>
<a name="ln479"> </a>
<a name="ln480">		SetFont(&amp;font, B_FONT_FAMILY_AND_STYLE | B_FONT_SIZE</a>
<a name="ln481">			| B_FONT_SHEAR | B_FONT_ROTATION);</a>
<a name="ln482">	}</a>
<a name="ln483"> </a>
<a name="ln484">	int32 color = 0;</a>
<a name="ln485">	if (archive-&gt;FindInt32(&quot;_color&quot;, 0, &amp;color) == B_OK)</a>
<a name="ln486">		SetHighColor(get_rgb_color(color));</a>
<a name="ln487">	if (archive-&gt;FindInt32(&quot;_color&quot;, 1, &amp;color) == B_OK)</a>
<a name="ln488">		SetLowColor(get_rgb_color(color));</a>
<a name="ln489">	if (archive-&gt;FindInt32(&quot;_color&quot;, 2, &amp;color) == B_OK)</a>
<a name="ln490">		SetViewColor(get_rgb_color(color));</a>
<a name="ln491"> </a>
<a name="ln492">	float tint = B_NO_TINT;</a>
<a name="ln493">	if (archive-&gt;FindInt32(&quot;_uicolor&quot;, 0, &amp;color) == B_OK</a>
<a name="ln494">		&amp;&amp; color != B_NO_COLOR) {</a>
<a name="ln495">		if (archive-&gt;FindFloat(&quot;_uitint&quot;, 0, &amp;tint) != B_OK)</a>
<a name="ln496">			tint = B_NO_TINT;</a>
<a name="ln497"> </a>
<a name="ln498">		SetHighUIColor((color_which)color, tint);</a>
<a name="ln499">	}</a>
<a name="ln500">	if (archive-&gt;FindInt32(&quot;_uicolor&quot;, 1, &amp;color) == B_OK</a>
<a name="ln501">		&amp;&amp; color != B_NO_COLOR) {</a>
<a name="ln502">		if (archive-&gt;FindFloat(&quot;_uitint&quot;, 1, &amp;tint) != B_OK)</a>
<a name="ln503">			tint = B_NO_TINT;</a>
<a name="ln504"> </a>
<a name="ln505">		SetLowUIColor((color_which)color, tint);</a>
<a name="ln506">	}</a>
<a name="ln507">	if (archive-&gt;FindInt32(&quot;_uicolor&quot;, 2, &amp;color) == B_OK</a>
<a name="ln508">		&amp;&amp; color != B_NO_COLOR) {</a>
<a name="ln509">		if (archive-&gt;FindFloat(&quot;_uitint&quot;, 2, &amp;tint) != B_OK)</a>
<a name="ln510">			tint = B_NO_TINT;</a>
<a name="ln511"> </a>
<a name="ln512">		SetViewUIColor((color_which)color, tint);</a>
<a name="ln513">	}</a>
<a name="ln514"> </a>
<a name="ln515">	uint32 evMask;</a>
<a name="ln516">	uint32 options;</a>
<a name="ln517">	if (archive-&gt;FindInt32(&quot;_evmask&quot;, 0, (int32*)&amp;evMask) == B_OK</a>
<a name="ln518">		&amp;&amp; archive-&gt;FindInt32(&quot;_evmask&quot;, 1, (int32*)&amp;options) == B_OK)</a>
<a name="ln519">		SetEventMask(evMask, options);</a>
<a name="ln520"> </a>
<a name="ln521">	BPoint origin;</a>
<a name="ln522">	if (archive-&gt;FindPoint(&quot;_origin&quot;, &amp;origin) == B_OK)</a>
<a name="ln523">		SetOrigin(origin);</a>
<a name="ln524"> </a>
<a name="ln525">	float scale;</a>
<a name="ln526">	if (archive-&gt;FindFloat(&quot;_scale&quot;, &amp;scale) == B_OK)</a>
<a name="ln527">		SetScale(scale);</a>
<a name="ln528"> </a>
<a name="ln529">	BAffineTransform transform;</a>
<a name="ln530">	if (archive-&gt;FindFlat(&quot;_transform&quot;, &amp;transform) == B_OK)</a>
<a name="ln531">		SetTransform(transform);</a>
<a name="ln532"> </a>
<a name="ln533">	float penSize;</a>
<a name="ln534">	if (archive-&gt;FindFloat(&quot;_psize&quot;, &amp;penSize) == B_OK)</a>
<a name="ln535">		SetPenSize(penSize);</a>
<a name="ln536"> </a>
<a name="ln537">	BPoint penLocation;</a>
<a name="ln538">	if (archive-&gt;FindPoint(&quot;_ploc&quot;, &amp;penLocation) == B_OK)</a>
<a name="ln539">		MovePenTo(penLocation);</a>
<a name="ln540"> </a>
<a name="ln541">	int16 lineCap;</a>
<a name="ln542">	int16 lineJoin;</a>
<a name="ln543">	float lineMiter;</a>
<a name="ln544">	if (archive-&gt;FindInt16(&quot;_lmcapjoin&quot;, 0, &amp;lineCap) == B_OK</a>
<a name="ln545">		&amp;&amp; archive-&gt;FindInt16(&quot;_lmcapjoin&quot;, 1, &amp;lineJoin) == B_OK</a>
<a name="ln546">		&amp;&amp; archive-&gt;FindFloat(&quot;_lmmiter&quot;, &amp;lineMiter) == B_OK)</a>
<a name="ln547">		SetLineMode((cap_mode)lineCap, (join_mode)lineJoin, lineMiter);</a>
<a name="ln548"> </a>
<a name="ln549">	int16 fillRule;</a>
<a name="ln550">	if (archive-&gt;FindInt16(&quot;_fillrule&quot;, &amp;fillRule) == B_OK)</a>
<a name="ln551">		SetFillRule(fillRule);</a>
<a name="ln552"> </a>
<a name="ln553">	int16 alphaBlend;</a>
<a name="ln554">	int16 modeBlend;</a>
<a name="ln555">	if (archive-&gt;FindInt16(&quot;_blend&quot;, 0, &amp;alphaBlend) == B_OK</a>
<a name="ln556">		&amp;&amp; archive-&gt;FindInt16(&quot;_blend&quot;, 1, &amp;modeBlend) == B_OK)</a>
<a name="ln557">		SetBlendingMode( (source_alpha)alphaBlend, (alpha_function)modeBlend);</a>
<a name="ln558"> </a>
<a name="ln559">	uint32 drawingMode;</a>
<a name="ln560">	if (archive-&gt;FindInt32(&quot;_dmod&quot;, (int32*)&amp;drawingMode) == B_OK)</a>
<a name="ln561">		SetDrawingMode((drawing_mode)drawingMode);</a>
<a name="ln562"> </a>
<a name="ln563">	fLayoutData-&gt;PopulateFromArchive(archive);</a>
<a name="ln564"> </a>
<a name="ln565">	if (archive-&gt;FindInt16(&quot;_show&quot;, &amp;fShowLevel) != B_OK)</a>
<a name="ln566">		fShowLevel = 0;</a>
<a name="ln567"> </a>
<a name="ln568">	if (BUnarchiver::IsArchiveManaged(archive)) {</a>
<a name="ln569">		int32 i = 0;</a>
<a name="ln570">		while (unarchiver.EnsureUnarchived(&quot;_views&quot;, i++) == B_OK)</a>
<a name="ln571">				;</a>
<a name="ln572">		unarchiver.EnsureUnarchived(kLayoutField);</a>
<a name="ln573"> </a>
<a name="ln574">	} else {</a>
<a name="ln575">		BMessage msg;</a>
<a name="ln576">		for (int32 i = 0; archive-&gt;FindMessage(&quot;_views&quot;, i, &amp;msg) == B_OK;</a>
<a name="ln577">			i++) {</a>
<a name="ln578">			BArchivable* object = instantiate_object(&amp;msg);</a>
<a name="ln579">			if (BView* child = dynamic_cast&lt;BView*&gt;(object))</a>
<a name="ln580">				AddChild(child);</a>
<a name="ln581">		}</a>
<a name="ln582">	}</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585"> </a>
<a name="ln586">BArchivable*</a>
<a name="ln587">BView::Instantiate(BMessage* data)</a>
<a name="ln588">{</a>
<a name="ln589">	if (!validate_instantiation(data , &quot;BView&quot;))</a>
<a name="ln590">		return NULL;</a>
<a name="ln591"> </a>
<a name="ln592">	return new(std::nothrow) BView(data);</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595"> </a>
<a name="ln596">status_t</a>
<a name="ln597">BView::Archive(BMessage* data, bool deep) const</a>
<a name="ln598">{</a>
<a name="ln599">	BArchiver archiver(data);</a>
<a name="ln600">	status_t ret = BHandler::Archive(data, deep);</a>
<a name="ln601"> </a>
<a name="ln602">	if (ret != B_OK)</a>
<a name="ln603">		return ret;</a>
<a name="ln604"> </a>
<a name="ln605">	if ((fState-&gt;archiving_flags &amp; B_VIEW_FRAME_BIT) != 0)</a>
<a name="ln606">		ret = data-&gt;AddRect(&quot;_frame&quot;, Bounds().OffsetToCopy(fParentOffset));</a>
<a name="ln607"> </a>
<a name="ln608">	if (ret == B_OK)</a>
<a name="ln609">		ret = data-&gt;AddInt32(&quot;_resize_mode&quot;, ResizingMode());</a>
<a name="ln610"> </a>
<a name="ln611">	if (ret == B_OK)</a>
<a name="ln612">		ret = data-&gt;AddInt32(&quot;_flags&quot;, Flags());</a>
<a name="ln613"> </a>
<a name="ln614">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_EVENT_MASK_BIT) != 0) {</a>
<a name="ln615">		ret = data-&gt;AddInt32(&quot;_evmask&quot;, fEventMask);</a>
<a name="ln616">		if (ret == B_OK)</a>
<a name="ln617">			ret = data-&gt;AddInt32(&quot;_evmask&quot;, fEventOptions);</a>
<a name="ln618">	}</a>
<a name="ln619"> </a>
<a name="ln620">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_FONT_BIT) != 0) {</a>
<a name="ln621">		BFont font;</a>
<a name="ln622">		GetFont(&amp;font);</a>
<a name="ln623"> </a>
<a name="ln624">		font_family family;</a>
<a name="ln625">		font_style style;</a>
<a name="ln626">		font.GetFamilyAndStyle(&amp;family, &amp;style);</a>
<a name="ln627">		ret = data-&gt;AddString(&quot;_fname&quot;, family);</a>
<a name="ln628">		if (ret == B_OK)</a>
<a name="ln629">			ret = data-&gt;AddString(&quot;_fname&quot;, style);</a>
<a name="ln630">		if (ret == B_OK)</a>
<a name="ln631">			ret = data-&gt;AddFloat(&quot;_fflt&quot;, font.Size());</a>
<a name="ln632">		if (ret == B_OK)</a>
<a name="ln633">			ret = data-&gt;AddFloat(&quot;_fflt&quot;, font.Shear());</a>
<a name="ln634">		if (ret == B_OK)</a>
<a name="ln635">			ret = data-&gt;AddFloat(&quot;_fflt&quot;, font.Rotation());</a>
<a name="ln636">	}</a>
<a name="ln637"> </a>
<a name="ln638">	// colors</a>
<a name="ln639">	if (ret == B_OK)</a>
<a name="ln640">		ret = data-&gt;AddInt32(&quot;_color&quot;, get_uint32_color(HighColor()));</a>
<a name="ln641">	if (ret == B_OK)</a>
<a name="ln642">		ret = data-&gt;AddInt32(&quot;_color&quot;, get_uint32_color(LowColor()));</a>
<a name="ln643">	if (ret == B_OK)</a>
<a name="ln644">		ret = data-&gt;AddInt32(&quot;_color&quot;, get_uint32_color(ViewColor()));</a>
<a name="ln645"> </a>
<a name="ln646">	if (ret == B_OK)</a>
<a name="ln647">		ret = data-&gt;AddInt32(&quot;_uicolor&quot;, (int32)HighUIColor());</a>
<a name="ln648">	if (ret == B_OK)</a>
<a name="ln649">		ret = data-&gt;AddInt32(&quot;_uicolor&quot;, (int32)LowUIColor());</a>
<a name="ln650">	if (ret == B_OK)</a>
<a name="ln651">		ret = data-&gt;AddInt32(&quot;_uicolor&quot;, (int32)ViewUIColor());</a>
<a name="ln652"> </a>
<a name="ln653">	if (ret == B_OK)</a>
<a name="ln654">		ret = data-&gt;AddFloat(&quot;_uitint&quot;, fState-&gt;which_high_color_tint);</a>
<a name="ln655">	if (ret == B_OK)</a>
<a name="ln656">		ret = data-&gt;AddFloat(&quot;_uitint&quot;, fState-&gt;which_low_color_tint);</a>
<a name="ln657">	if (ret == B_OK)</a>
<a name="ln658">		ret = data-&gt;AddFloat(&quot;_uitint&quot;, fState-&gt;which_view_color_tint);</a>
<a name="ln659"> </a>
<a name="ln660">//	NOTE: we do not use this flag any more</a>
<a name="ln661">//	if ( 1 ){</a>
<a name="ln662">//		ret = data-&gt;AddInt32(&quot;_dbuf&quot;, 1);</a>
<a name="ln663">//	}</a>
<a name="ln664"> </a>
<a name="ln665">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_ORIGIN_BIT) != 0)</a>
<a name="ln666">		ret = data-&gt;AddPoint(&quot;_origin&quot;, Origin());</a>
<a name="ln667"> </a>
<a name="ln668">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_SCALE_BIT) != 0)</a>
<a name="ln669">		ret = data-&gt;AddFloat(&quot;_scale&quot;, Scale());</a>
<a name="ln670"> </a>
<a name="ln671">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_TRANSFORM_BIT) != 0) {</a>
<a name="ln672">		BAffineTransform transform = Transform();</a>
<a name="ln673">		ret = data-&gt;AddFlat(&quot;_transform&quot;, &amp;transform);</a>
<a name="ln674">	}</a>
<a name="ln675"> </a>
<a name="ln676">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_PEN_SIZE_BIT) != 0)</a>
<a name="ln677">		ret = data-&gt;AddFloat(&quot;_psize&quot;, PenSize());</a>
<a name="ln678"> </a>
<a name="ln679">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_PEN_LOCATION_BIT) != 0)</a>
<a name="ln680">		ret = data-&gt;AddPoint(&quot;_ploc&quot;, PenLocation());</a>
<a name="ln681"> </a>
<a name="ln682">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_LINE_MODES_BIT) != 0) {</a>
<a name="ln683">		ret = data-&gt;AddInt16(&quot;_lmcapjoin&quot;, (int16)LineCapMode());</a>
<a name="ln684">		if (ret == B_OK)</a>
<a name="ln685">			ret = data-&gt;AddInt16(&quot;_lmcapjoin&quot;, (int16)LineJoinMode());</a>
<a name="ln686">		if (ret == B_OK)</a>
<a name="ln687">			ret = data-&gt;AddFloat(&quot;_lmmiter&quot;, LineMiterLimit());</a>
<a name="ln688">	}</a>
<a name="ln689"> </a>
<a name="ln690">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_FILL_RULE_BIT) != 0)</a>
<a name="ln691">		ret = data-&gt;AddInt16(&quot;_fillrule&quot;, (int16)FillRule());</a>
<a name="ln692"> </a>
<a name="ln693">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_BLENDING_BIT) != 0) {</a>
<a name="ln694">		source_alpha alphaSourceMode;</a>
<a name="ln695">		alpha_function alphaFunctionMode;</a>
<a name="ln696">		GetBlendingMode(&amp;alphaSourceMode, &amp;alphaFunctionMode);</a>
<a name="ln697"> </a>
<a name="ln698">		ret = data-&gt;AddInt16(&quot;_blend&quot;, (int16)alphaSourceMode);</a>
<a name="ln699">		if (ret == B_OK)</a>
<a name="ln700">			ret = data-&gt;AddInt16(&quot;_blend&quot;, (int16)alphaFunctionMode);</a>
<a name="ln701">	}</a>
<a name="ln702"> </a>
<a name="ln703">	if (ret == B_OK &amp;&amp; (fState-&gt;archiving_flags &amp; B_VIEW_DRAWING_MODE_BIT) != 0)</a>
<a name="ln704">		ret = data-&gt;AddInt32(&quot;_dmod&quot;, DrawingMode());</a>
<a name="ln705"> </a>
<a name="ln706">	if (ret == B_OK)</a>
<a name="ln707">		ret = fLayoutData-&gt;AddDataToArchive(data);</a>
<a name="ln708"> </a>
<a name="ln709">	if (ret == B_OK)</a>
<a name="ln710">		ret = data-&gt;AddInt16(&quot;_show&quot;, fShowLevel);</a>
<a name="ln711"> </a>
<a name="ln712">	if (deep &amp;&amp; ret == B_OK) {</a>
<a name="ln713">		for (BView* child = fFirstChild; child != NULL &amp;&amp; ret == B_OK;</a>
<a name="ln714">			child = child-&gt;fNextSibling)</a>
<a name="ln715">			ret = archiver.AddArchivable(&quot;_views&quot;, child, deep);</a>
<a name="ln716"> </a>
<a name="ln717">		if (ret == B_OK)</a>
<a name="ln718">			ret = archiver.AddArchivable(kLayoutField, GetLayout(), deep);</a>
<a name="ln719">	}</a>
<a name="ln720"> </a>
<a name="ln721">	return archiver.Finish(ret);</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724"> </a>
<a name="ln725">status_t</a>
<a name="ln726">BView::AllUnarchived(const BMessage* from)</a>
<a name="ln727">{</a>
<a name="ln728">	BUnarchiver unarchiver(from);</a>
<a name="ln729">	status_t err = B_OK;</a>
<a name="ln730"> </a>
<a name="ln731">	int32 count;</a>
<a name="ln732">	from-&gt;GetInfo(&quot;_views&quot;, NULL, &amp;count);</a>
<a name="ln733"> </a>
<a name="ln734">	for (int32 i = 0; err == B_OK &amp;&amp; i &lt; count; i++) {</a>
<a name="ln735">		BView* child;</a>
<a name="ln736">		err = unarchiver.FindObject&lt;BView&gt;(&quot;_views&quot;, i, child);</a>
<a name="ln737">		if (err == B_OK)</a>
<a name="ln738">			err = _AddChild(child, NULL) ? B_OK : B_ERROR;</a>
<a name="ln739">	}</a>
<a name="ln740"> </a>
<a name="ln741">	if (err == B_OK) {</a>
<a name="ln742">		BLayout*&amp; layout = fLayoutData-&gt;fLayout;</a>
<a name="ln743">		err = unarchiver.FindObject(kLayoutField, layout);</a>
<a name="ln744">		if (err == B_OK &amp;&amp; layout) {</a>
<a name="ln745">			fFlags |= B_SUPPORTS_LAYOUT;</a>
<a name="ln746">			fLayoutData-&gt;fLayout-&gt;SetOwner(this);</a>
<a name="ln747">		}</a>
<a name="ln748">	}</a>
<a name="ln749"> </a>
<a name="ln750">	return err;</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753"> </a>
<a name="ln754">status_t</a>
<a name="ln755">BView::AllArchived(BMessage* into) const</a>
<a name="ln756">{</a>
<a name="ln757">	return BHandler::AllArchived(into);</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760"> </a>
<a name="ln761">BView::~BView()</a>
<a name="ln762">{</a>
<a name="ln763">	STRACE((&quot;BView(%s)::~BView()\n&quot;, this-&gt;Name()));</a>
<a name="ln764"> </a>
<a name="ln765">	if (fOwner != NULL) {</a>
<a name="ln766">		debugger(&quot;Trying to delete a view that belongs to a window. &quot;</a>
<a name="ln767">			&quot;Call RemoveSelf first.&quot;);</a>
<a name="ln768">	}</a>
<a name="ln769"> </a>
<a name="ln770">	// we also delete all our children</a>
<a name="ln771"> </a>
<a name="ln772">	BView* child = fFirstChild;</a>
<a name="ln773">	while (child) {</a>
<a name="ln774">		BView* nextChild = child-&gt;fNextSibling;</a>
<a name="ln775"> </a>
<a name="ln776">		delete child;</a>
<a name="ln777">		child = nextChild;</a>
<a name="ln778">	}</a>
<a name="ln779"> </a>
<a name="ln780">	SetLayout(NULL);</a>
<a name="ln781">	_RemoveLayoutItemsFromLayout(true);</a>
<a name="ln782"> </a>
<a name="ln783">	delete fLayoutData;</a>
<a name="ln784"> </a>
<a name="ln785">	_RemoveSelf();</a>
<a name="ln786"> </a>
<a name="ln787">	if (fToolTip != NULL)</a>
<a name="ln788">		fToolTip-&gt;ReleaseReference();</a>
<a name="ln789"> </a>
<a name="ln790">	if (fVerScroller != NULL)</a>
<a name="ln791">		fVerScroller-&gt;SetTarget((BView*)NULL);</a>
<a name="ln792">	if (fHorScroller != NULL)</a>
<a name="ln793">		fHorScroller-&gt;SetTarget((BView*)NULL);</a>
<a name="ln794"> </a>
<a name="ln795">	SetName(NULL);</a>
<a name="ln796"> </a>
<a name="ln797">	_RemoveCommArray();</a>
<a name="ln798">	delete fState;</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801"> </a>
<a name="ln802">BRect</a>
<a name="ln803">BView::Bounds() const</a>
<a name="ln804">{</a>
<a name="ln805">	_CheckLock();</a>
<a name="ln806"> </a>
<a name="ln807">	if (fIsPrinting)</a>
<a name="ln808">		return fState-&gt;print_rect;</a>
<a name="ln809"> </a>
<a name="ln810">	return fBounds;</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">void</a>
<a name="ln815">BView::_ConvertToParent(BPoint* point, bool checkLock) const</a>
<a name="ln816">{</a>
<a name="ln817">	if (!fParent)</a>
<a name="ln818">		return;</a>
<a name="ln819"> </a>
<a name="ln820">	if (checkLock)</a>
<a name="ln821">		_CheckLock();</a>
<a name="ln822"> </a>
<a name="ln823">	// - our scrolling offset</a>
<a name="ln824">	// + our bounds location within the parent</a>
<a name="ln825">	point-&gt;x += -fBounds.left + fParentOffset.x;</a>
<a name="ln826">	point-&gt;y += -fBounds.top + fParentOffset.y;</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829"> </a>
<a name="ln830">void</a>
<a name="ln831">BView::ConvertToParent(BPoint* point) const</a>
<a name="ln832">{</a>
<a name="ln833">	_ConvertToParent(point, true);</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836"> </a>
<a name="ln837">BPoint</a>
<a name="ln838">BView::ConvertToParent(BPoint point) const</a>
<a name="ln839">{</a>
<a name="ln840">	ConvertToParent(&amp;point);</a>
<a name="ln841"> </a>
<a name="ln842">	return point;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845"> </a>
<a name="ln846">void</a>
<a name="ln847">BView::_ConvertFromParent(BPoint* point, bool checkLock) const</a>
<a name="ln848">{</a>
<a name="ln849">	if (!fParent)</a>
<a name="ln850">		return;</a>
<a name="ln851"> </a>
<a name="ln852">	if (checkLock)</a>
<a name="ln853">		_CheckLock();</a>
<a name="ln854"> </a>
<a name="ln855">	// - our bounds location within the parent</a>
<a name="ln856">	// + our scrolling offset</a>
<a name="ln857">	point-&gt;x += -fParentOffset.x + fBounds.left;</a>
<a name="ln858">	point-&gt;y += -fParentOffset.y + fBounds.top;</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861"> </a>
<a name="ln862">void</a>
<a name="ln863">BView::ConvertFromParent(BPoint* point) const</a>
<a name="ln864">{</a>
<a name="ln865">	_ConvertFromParent(point, true);</a>
<a name="ln866">}</a>
<a name="ln867"> </a>
<a name="ln868"> </a>
<a name="ln869">BPoint</a>
<a name="ln870">BView::ConvertFromParent(BPoint point) const</a>
<a name="ln871">{</a>
<a name="ln872">	ConvertFromParent(&amp;point);</a>
<a name="ln873"> </a>
<a name="ln874">	return point;</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877"> </a>
<a name="ln878">void</a>
<a name="ln879">BView::ConvertToParent(BRect* rect) const</a>
<a name="ln880">{</a>
<a name="ln881">	if (!fParent)</a>
<a name="ln882">		return;</a>
<a name="ln883"> </a>
<a name="ln884">	_CheckLock();</a>
<a name="ln885"> </a>
<a name="ln886">	// - our scrolling offset</a>
<a name="ln887">	// + our bounds location within the parent</a>
<a name="ln888">	rect-&gt;OffsetBy(-fBounds.left + fParentOffset.x,</a>
<a name="ln889">		-fBounds.top + fParentOffset.y);</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892"> </a>
<a name="ln893">BRect</a>
<a name="ln894">BView::ConvertToParent(BRect rect) const</a>
<a name="ln895">{</a>
<a name="ln896">	ConvertToParent(&amp;rect);</a>
<a name="ln897"> </a>
<a name="ln898">	return rect;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901"> </a>
<a name="ln902">void</a>
<a name="ln903">BView::ConvertFromParent(BRect* rect) const</a>
<a name="ln904">{</a>
<a name="ln905">	if (!fParent)</a>
<a name="ln906">		return;</a>
<a name="ln907"> </a>
<a name="ln908">	_CheckLock();</a>
<a name="ln909"> </a>
<a name="ln910">	// - our bounds location within the parent</a>
<a name="ln911">	// + our scrolling offset</a>
<a name="ln912">	rect-&gt;OffsetBy(-fParentOffset.x + fBounds.left,</a>
<a name="ln913">		-fParentOffset.y + fBounds.top);</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">BRect</a>
<a name="ln918">BView::ConvertFromParent(BRect rect) const</a>
<a name="ln919">{</a>
<a name="ln920">	ConvertFromParent(&amp;rect);</a>
<a name="ln921"> </a>
<a name="ln922">	return rect;</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925"> </a>
<a name="ln926">void</a>
<a name="ln927">BView::_ConvertToScreen(BPoint* point, bool checkLock) const</a>
<a name="ln928">{</a>
<a name="ln929">	if (!fParent) {</a>
<a name="ln930">		if (fOwner)</a>
<a name="ln931">			fOwner-&gt;ConvertToScreen(point);</a>
<a name="ln932"> </a>
<a name="ln933">		return;</a>
<a name="ln934">	}</a>
<a name="ln935"> </a>
<a name="ln936">	if (checkLock)</a>
<a name="ln937">		_CheckOwnerLock();</a>
<a name="ln938"> </a>
<a name="ln939">	_ConvertToParent(point, false);</a>
<a name="ln940">	fParent-&gt;_ConvertToScreen(point, false);</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943"> </a>
<a name="ln944">void</a>
<a name="ln945">BView::ConvertToScreen(BPoint* point) const</a>
<a name="ln946">{</a>
<a name="ln947">	_ConvertToScreen(point, true);</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950"> </a>
<a name="ln951">BPoint</a>
<a name="ln952">BView::ConvertToScreen(BPoint point) const</a>
<a name="ln953">{</a>
<a name="ln954">	ConvertToScreen(&amp;point);</a>
<a name="ln955"> </a>
<a name="ln956">	return point;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959"> </a>
<a name="ln960">void</a>
<a name="ln961">BView::_ConvertFromScreen(BPoint* point, bool checkLock) const</a>
<a name="ln962">{</a>
<a name="ln963">	if (!fParent) {</a>
<a name="ln964">		if (fOwner)</a>
<a name="ln965">			fOwner-&gt;ConvertFromScreen(point);</a>
<a name="ln966"> </a>
<a name="ln967">		return;</a>
<a name="ln968">	}</a>
<a name="ln969"> </a>
<a name="ln970">	if (checkLock)</a>
<a name="ln971">		_CheckOwnerLock();</a>
<a name="ln972"> </a>
<a name="ln973">	_ConvertFromParent(point, false);</a>
<a name="ln974">	fParent-&gt;_ConvertFromScreen(point, false);</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977"> </a>
<a name="ln978">void</a>
<a name="ln979">BView::ConvertFromScreen(BPoint* point) const</a>
<a name="ln980">{</a>
<a name="ln981">	_ConvertFromScreen(point, true);</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984"> </a>
<a name="ln985">BPoint</a>
<a name="ln986">BView::ConvertFromScreen(BPoint point) const</a>
<a name="ln987">{</a>
<a name="ln988">	ConvertFromScreen(&amp;point);</a>
<a name="ln989"> </a>
<a name="ln990">	return point;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">void</a>
<a name="ln995">BView::ConvertToScreen(BRect* rect) const</a>
<a name="ln996">{</a>
<a name="ln997">	BPoint offset(0.0, 0.0);</a>
<a name="ln998">	ConvertToScreen(&amp;offset);</a>
<a name="ln999">	rect-&gt;OffsetBy(offset);</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002"> </a>
<a name="ln1003">BRect</a>
<a name="ln1004">BView::ConvertToScreen(BRect rect) const</a>
<a name="ln1005">{</a>
<a name="ln1006">	ConvertToScreen(&amp;rect);</a>
<a name="ln1007"> </a>
<a name="ln1008">	return rect;</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011"> </a>
<a name="ln1012">void</a>
<a name="ln1013">BView::ConvertFromScreen(BRect* rect) const</a>
<a name="ln1014">{</a>
<a name="ln1015">	BPoint offset(0.0, 0.0);</a>
<a name="ln1016">	ConvertFromScreen(&amp;offset);</a>
<a name="ln1017">	rect-&gt;OffsetBy(offset);</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020"> </a>
<a name="ln1021">BRect</a>
<a name="ln1022">BView::ConvertFromScreen(BRect rect) const</a>
<a name="ln1023">{</a>
<a name="ln1024">	ConvertFromScreen(&amp;rect);</a>
<a name="ln1025"> </a>
<a name="ln1026">	return rect;</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029"> </a>
<a name="ln1030">uint32</a>
<a name="ln1031">BView::Flags() const</a>
<a name="ln1032">{</a>
<a name="ln1033">	_CheckLock();</a>
<a name="ln1034">	return fFlags &amp; ~_RESIZE_MASK_;</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037"> </a>
<a name="ln1038">void</a>
<a name="ln1039">BView::SetFlags(uint32 flags)</a>
<a name="ln1040">{</a>
<a name="ln1041">	if (Flags() == flags)</a>
<a name="ln1042">		return;</a>
<a name="ln1043"> </a>
<a name="ln1044">	if (fOwner) {</a>
<a name="ln1045">		if (flags &amp; B_PULSE_NEEDED) {</a>
<a name="ln1046">			_CheckLock();</a>
<a name="ln1047">			if (fOwner-&gt;fPulseRunner == NULL)</a>
<a name="ln1048">				fOwner-&gt;SetPulseRate(fOwner-&gt;PulseRate());</a>
<a name="ln1049">		}</a>
<a name="ln1050"> </a>
<a name="ln1051">		uint32 changesFlags = flags ^ fFlags;</a>
<a name="ln1052">		if (changesFlags &amp; (B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE</a>
<a name="ln1053">				| B_FRAME_EVENTS | B_SUBPIXEL_PRECISE)) {</a>
<a name="ln1054">			_CheckLockAndSwitchCurrent();</a>
<a name="ln1055"> </a>
<a name="ln1056">			fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_FLAGS);</a>
<a name="ln1057">			fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(flags);</a>
<a name="ln1058">			fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln1059">		}</a>
<a name="ln1060">	}</a>
<a name="ln1061"> </a>
<a name="ln1062">	/* Some useful info:</a>
<a name="ln1063">		fFlags is a unsigned long (32 bits)</a>
<a name="ln1064">		* bits 1-16 are used for BView's flags</a>
<a name="ln1065">		* bits 17-32 are used for BView' resize mask</a>
<a name="ln1066">		* _RESIZE_MASK_ is used for that. Look into View.h to see how</a>
<a name="ln1067">			it's defined</a>
<a name="ln1068">	*/</a>
<a name="ln1069">	fFlags = (flags &amp; ~_RESIZE_MASK_) | (fFlags &amp; _RESIZE_MASK_);</a>
<a name="ln1070"> </a>
<a name="ln1071">	fState-&gt;archiving_flags |= B_VIEW_FLAGS_BIT;</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074"> </a>
<a name="ln1075">BRect</a>
<a name="ln1076">BView::Frame() const</a>
<a name="ln1077">{</a>
<a name="ln1078">	return Bounds().OffsetToCopy(fParentOffset.x, fParentOffset.y);</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081"> </a>
<a name="ln1082">void</a>
<a name="ln1083">BView::Hide()</a>
<a name="ln1084">{</a>
<a name="ln1085">	if (fOwner &amp;&amp; fShowLevel == 0) {</a>
<a name="ln1086">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1087">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_HIDE);</a>
<a name="ln1088">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln1089">	}</a>
<a name="ln1090">	fShowLevel++;</a>
<a name="ln1091"> </a>
<a name="ln1092">	if (fShowLevel == 1)</a>
<a name="ln1093">		_InvalidateParentLayout();</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096"> </a>
<a name="ln1097">void</a>
<a name="ln1098">BView::Show()</a>
<a name="ln1099">{</a>
<a name="ln1100">	fShowLevel--;</a>
<a name="ln1101">	if (fOwner &amp;&amp; fShowLevel == 0) {</a>
<a name="ln1102">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1103">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SHOW);</a>
<a name="ln1104">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln1105">	}</a>
<a name="ln1106"> </a>
<a name="ln1107">	if (fShowLevel == 0)</a>
<a name="ln1108">		_InvalidateParentLayout();</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111"> </a>
<a name="ln1112">bool</a>
<a name="ln1113">BView::IsFocus() const</a>
<a name="ln1114">{</a>
<a name="ln1115">	if (fOwner) {</a>
<a name="ln1116">		_CheckLock();</a>
<a name="ln1117">		return fOwner-&gt;CurrentFocus() == this;</a>
<a name="ln1118">	} else</a>
<a name="ln1119">		return false;</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122"> </a>
<a name="ln1123">bool</a>
<a name="ln1124">BView::IsHidden(const BView* lookingFrom) const</a>
<a name="ln1125">{</a>
<a name="ln1126">	if (fShowLevel &gt; 0)</a>
<a name="ln1127">		return true;</a>
<a name="ln1128"> </a>
<a name="ln1129">	// may we be egocentric?</a>
<a name="ln1130">	if (lookingFrom == this)</a>
<a name="ln1131">		return false;</a>
<a name="ln1132"> </a>
<a name="ln1133">	// we have the same visibility state as our</a>
<a name="ln1134">	// parent, if there is one</a>
<a name="ln1135">	if (fParent)</a>
<a name="ln1136">		return fParent-&gt;IsHidden(lookingFrom);</a>
<a name="ln1137"> </a>
<a name="ln1138">	// if we're the top view, and we're interested</a>
<a name="ln1139">	// in the &quot;global&quot; view, we're inheriting the</a>
<a name="ln1140">	// state of the window's visibility</a>
<a name="ln1141">	if (fOwner &amp;&amp; lookingFrom == NULL)</a>
<a name="ln1142">		return fOwner-&gt;IsHidden();</a>
<a name="ln1143"> </a>
<a name="ln1144">	return false;</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147"> </a>
<a name="ln1148">bool</a>
<a name="ln1149">BView::IsHidden() const</a>
<a name="ln1150">{</a>
<a name="ln1151">	return IsHidden(NULL);</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154"> </a>
<a name="ln1155">bool</a>
<a name="ln1156">BView::IsPrinting() const</a>
<a name="ln1157">{</a>
<a name="ln1158">	return fIsPrinting;</a>
<a name="ln1159">}</a>
<a name="ln1160"> </a>
<a name="ln1161"> </a>
<a name="ln1162">BPoint</a>
<a name="ln1163">BView::LeftTop() const</a>
<a name="ln1164">{</a>
<a name="ln1165">	return Bounds().LeftTop();</a>
<a name="ln1166">}</a>
<a name="ln1167"> </a>
<a name="ln1168"> </a>
<a name="ln1169">void</a>
<a name="ln1170">BView::SetResizingMode(uint32 mode)</a>
<a name="ln1171">{</a>
<a name="ln1172">	if (fOwner) {</a>
<a name="ln1173">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1174"> </a>
<a name="ln1175">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_RESIZE_MODE);</a>
<a name="ln1176">		fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(mode);</a>
<a name="ln1177">	}</a>
<a name="ln1178"> </a>
<a name="ln1179">	// look at SetFlags() for more info on the below line</a>
<a name="ln1180">	fFlags = (fFlags &amp; ~_RESIZE_MASK_) | (mode &amp; _RESIZE_MASK_);</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183"> </a>
<a name="ln1184">uint32</a>
<a name="ln1185">BView::ResizingMode() const</a>
<a name="ln1186">{</a>
<a name="ln1187">	return fFlags &amp; _RESIZE_MASK_;</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>
<a name="ln1190"> </a>
<a name="ln1191">void</a>
<a name="ln1192">BView::SetViewCursor(const BCursor* cursor, bool sync)</a>
<a name="ln1193">{</a>
<a name="ln1194">	if (cursor == NULL || fOwner == NULL)</a>
<a name="ln1195">		return;</a>
<a name="ln1196"> </a>
<a name="ln1197">	_CheckLock();</a>
<a name="ln1198"> </a>
<a name="ln1199">	ViewSetViewCursorInfo info;</a>
<a name="ln1200">	info.cursorToken = cursor-&gt;fServerToken;</a>
<a name="ln1201">	info.viewToken = _get_object_token_(this);</a>
<a name="ln1202">	info.sync = sync;</a>
<a name="ln1203"> </a>
<a name="ln1204">	BPrivate::AppServerLink link;</a>
<a name="ln1205">	link.StartMessage(AS_SET_VIEW_CURSOR);</a>
<a name="ln1206">	link.Attach&lt;ViewSetViewCursorInfo&gt;(info);</a>
<a name="ln1207"> </a>
<a name="ln1208">	if (sync) {</a>
<a name="ln1209">		// Make sure the server has processed the message.</a>
<a name="ln1210">		int32 code;</a>
<a name="ln1211">		link.FlushWithReply(code);</a>
<a name="ln1212">	}</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215"> </a>
<a name="ln1216">void</a>
<a name="ln1217">BView::Flush() const</a>
<a name="ln1218">{</a>
<a name="ln1219">	if (fOwner)</a>
<a name="ln1220">		fOwner-&gt;Flush();</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223"> </a>
<a name="ln1224">void</a>
<a name="ln1225">BView::Sync() const</a>
<a name="ln1226">{</a>
<a name="ln1227">	_CheckOwnerLock();</a>
<a name="ln1228">	if (fOwner)</a>
<a name="ln1229">		fOwner-&gt;Sync();</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232"> </a>
<a name="ln1233">BWindow*</a>
<a name="ln1234">BView::Window() const</a>
<a name="ln1235">{</a>
<a name="ln1236">	return fOwner;</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239"> </a>
<a name="ln1240">//	#pragma mark - Hook Functions</a>
<a name="ln1241"> </a>
<a name="ln1242"> </a>
<a name="ln1243">void</a>
<a name="ln1244">BView::AttachedToWindow()</a>
<a name="ln1245">{</a>
<a name="ln1246">	// Hook function</a>
<a name="ln1247">	STRACE((&quot;\tHOOK: BView(%s)::AttachedToWindow()\n&quot;, Name()));</a>
<a name="ln1248">}</a>
<a name="ln1249"> </a>
<a name="ln1250"> </a>
<a name="ln1251">void</a>
<a name="ln1252">BView::AllAttached()</a>
<a name="ln1253">{</a>
<a name="ln1254">	// Hook function</a>
<a name="ln1255">	STRACE((&quot;\tHOOK: BView(%s)::AllAttached()\n&quot;, Name()));</a>
<a name="ln1256">}</a>
<a name="ln1257"> </a>
<a name="ln1258"> </a>
<a name="ln1259">void</a>
<a name="ln1260">BView::DetachedFromWindow()</a>
<a name="ln1261">{</a>
<a name="ln1262">	// Hook function</a>
<a name="ln1263">	STRACE((&quot;\tHOOK: BView(%s)::DetachedFromWindow()\n&quot;, Name()));</a>
<a name="ln1264">}</a>
<a name="ln1265"> </a>
<a name="ln1266"> </a>
<a name="ln1267">void</a>
<a name="ln1268">BView::AllDetached()</a>
<a name="ln1269">{</a>
<a name="ln1270">	// Hook function</a>
<a name="ln1271">	STRACE((&quot;\tHOOK: BView(%s)::AllDetached()\n&quot;, Name()));</a>
<a name="ln1272">}</a>
<a name="ln1273"> </a>
<a name="ln1274"> </a>
<a name="ln1275">void</a>
<a name="ln1276">BView::Draw(BRect updateRect)</a>
<a name="ln1277">{</a>
<a name="ln1278">	// Hook function</a>
<a name="ln1279">	STRACE((&quot;\tHOOK: BView(%s)::Draw()\n&quot;, Name()));</a>
<a name="ln1280">}</a>
<a name="ln1281"> </a>
<a name="ln1282"> </a>
<a name="ln1283">void</a>
<a name="ln1284">BView::DrawAfterChildren(BRect updateRect)</a>
<a name="ln1285">{</a>
<a name="ln1286">	// Hook function</a>
<a name="ln1287">	STRACE((&quot;\tHOOK: BView(%s)::DrawAfterChildren()\n&quot;, Name()));</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290"> </a>
<a name="ln1291">void</a>
<a name="ln1292">BView::FrameMoved(BPoint newPosition)</a>
<a name="ln1293">{</a>
<a name="ln1294">	// Hook function</a>
<a name="ln1295">	STRACE((&quot;\tHOOK: BView(%s)::FrameMoved()\n&quot;, Name()));</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298"> </a>
<a name="ln1299">void</a>
<a name="ln1300">BView::FrameResized(float newWidth, float newHeight)</a>
<a name="ln1301">{</a>
<a name="ln1302">	// Hook function</a>
<a name="ln1303">	STRACE((&quot;\tHOOK: BView(%s)::FrameResized()\n&quot;, Name()));</a>
<a name="ln1304">}</a>
<a name="ln1305"> </a>
<a name="ln1306"> </a>
<a name="ln1307">void</a>
<a name="ln1308">BView::GetPreferredSize(float* _width, float* _height)</a>
<a name="ln1309">{</a>
<a name="ln1310">	STRACE((&quot;\tHOOK: BView(%s)::GetPreferredSize()\n&quot;, Name()));</a>
<a name="ln1311"> </a>
<a name="ln1312">	if (_width != NULL)</a>
<a name="ln1313">		*_width = fBounds.Width();</a>
<a name="ln1314">	if (_height != NULL)</a>
<a name="ln1315">		*_height = fBounds.Height();</a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318"> </a>
<a name="ln1319">void</a>
<a name="ln1320">BView::ResizeToPreferred()</a>
<a name="ln1321">{</a>
<a name="ln1322">	STRACE((&quot;\tHOOK: BView(%s)::ResizeToPreferred()\n&quot;, Name()));</a>
<a name="ln1323"> </a>
<a name="ln1324">	float width;</a>
<a name="ln1325">	float height;</a>
<a name="ln1326">	GetPreferredSize(&amp;width, &amp;height);</a>
<a name="ln1327"> </a>
<a name="ln1328">	ResizeTo(width, height);</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331"> </a>
<a name="ln1332">void</a>
<a name="ln1333">BView::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln1334">{</a>
<a name="ln1335">	// Hook function</a>
<a name="ln1336">	STRACE((&quot;\tHOOK: BView(%s)::KeyDown()\n&quot;, Name()));</a>
<a name="ln1337"> </a>
<a name="ln1338">	if (Window())</a>
<a name="ln1339">		Window()-&gt;_KeyboardNavigation();</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342"> </a>
<a name="ln1343">void</a>
<a name="ln1344">BView::KeyUp(const char* bytes, int32 numBytes)</a>
<a name="ln1345">{</a>
<a name="ln1346">	// Hook function</a>
<a name="ln1347">	STRACE((&quot;\tHOOK: BView(%s)::KeyUp()\n&quot;, Name()));</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350"> </a>
<a name="ln1351">void</a>
<a name="ln1352">BView::MouseDown(BPoint where)</a>
<a name="ln1353">{</a>
<a name="ln1354">	// Hook function</a>
<a name="ln1355">	STRACE((&quot;\tHOOK: BView(%s)::MouseDown()\n&quot;, Name()));</a>
<a name="ln1356">}</a>
<a name="ln1357"> </a>
<a name="ln1358"> </a>
<a name="ln1359">void</a>
<a name="ln1360">BView::MouseUp(BPoint where)</a>
<a name="ln1361">{</a>
<a name="ln1362">	// Hook function</a>
<a name="ln1363">	STRACE((&quot;\tHOOK: BView(%s)::MouseUp()\n&quot;, Name()));</a>
<a name="ln1364">}</a>
<a name="ln1365"> </a>
<a name="ln1366"> </a>
<a name="ln1367">void</a>
<a name="ln1368">BView::MouseMoved(BPoint where, uint32 code, const BMessage* dragMessage)</a>
<a name="ln1369">{</a>
<a name="ln1370">	// Hook function</a>
<a name="ln1371">	STRACE((&quot;\tHOOK: BView(%s)::MouseMoved()\n&quot;, Name()));</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374"> </a>
<a name="ln1375">void</a>
<a name="ln1376">BView::Pulse()</a>
<a name="ln1377">{</a>
<a name="ln1378">	// Hook function</a>
<a name="ln1379">	STRACE((&quot;\tHOOK: BView(%s)::Pulse()\n&quot;, Name()));</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382"> </a>
<a name="ln1383">void</a>
<a name="ln1384">BView::TargetedByScrollView(BScrollView* scroll_view)</a>
<a name="ln1385">{</a>
<a name="ln1386">	// Hook function</a>
<a name="ln1387">	STRACE((&quot;\tHOOK: BView(%s)::TargetedByScrollView()\n&quot;, Name()));</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390"> </a>
<a name="ln1391">void</a>
<a name="ln1392">BView::WindowActivated(bool active)</a>
<a name="ln1393">{</a>
<a name="ln1394">	// Hook function</a>
<a name="ln1395">	STRACE((&quot;\tHOOK: BView(%s)::WindowActivated()\n&quot;, Name()));</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398"> </a>
<a name="ln1399">//	#pragma mark - Input Functions</a>
<a name="ln1400"> </a>
<a name="ln1401"> </a>
<a name="ln1402">void</a>
<a name="ln1403">BView::BeginRectTracking(BRect startRect, uint32 style)</a>
<a name="ln1404">{</a>
<a name="ln1405">	if (_CheckOwnerLockAndSwitchCurrent()) {</a>
<a name="ln1406">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_BEGIN_RECT_TRACK);</a>
<a name="ln1407">		fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(startRect);</a>
<a name="ln1408">		fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(style);</a>
<a name="ln1409">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln1410">	}</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413"> </a>
<a name="ln1414">void</a>
<a name="ln1415">BView::EndRectTracking()</a>
<a name="ln1416">{</a>
<a name="ln1417">	if (_CheckOwnerLockAndSwitchCurrent()) {</a>
<a name="ln1418">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_END_RECT_TRACK);</a>
<a name="ln1419">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln1420">	}</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423"> </a>
<a name="ln1424">void</a>
<a name="ln1425">BView::DragMessage(BMessage* message, BRect dragRect, BHandler* replyTo)</a>
<a name="ln1426">{</a>
<a name="ln1427">	if (!message)</a>
<a name="ln1428">		return;</a>
<a name="ln1429"> </a>
<a name="ln1430">	_CheckOwnerLock();</a>
<a name="ln1431"> </a>
<a name="ln1432">	// calculate the offset</a>
<a name="ln1433">	BPoint offset;</a>
<a name="ln1434">	uint32 buttons;</a>
<a name="ln1435">	BMessage* current = fOwner-&gt;CurrentMessage();</a>
<a name="ln1436">	if (!current || current-&gt;FindPoint(&quot;be:view_where&quot;, &amp;offset) != B_OK)</a>
<a name="ln1437">		GetMouse(&amp;offset, &amp;buttons, false);</a>
<a name="ln1438">	offset -= dragRect.LeftTop();</a>
<a name="ln1439"> </a>
<a name="ln1440">	if (!dragRect.IsValid()) {</a>
<a name="ln1441">		DragMessage(message, NULL, B_OP_BLEND, offset, replyTo);</a>
<a name="ln1442">		return;</a>
<a name="ln1443">	}</a>
<a name="ln1444"> </a>
<a name="ln1445">	// TODO: that's not really what should happen - the app_server should take</a>
<a name="ln1446">	// the chance *NOT* to need to drag a whole bitmap around but just a frame.</a>
<a name="ln1447"> </a>
<a name="ln1448">	// create a drag bitmap for the rect</a>
<a name="ln1449">	BBitmap* bitmap = new(std::nothrow) BBitmap(dragRect, B_RGBA32);</a>
<a name="ln1450">	if (bitmap == NULL)</a>
<a name="ln1451">		return;</a>
<a name="ln1452"> </a>
<a name="ln1453">	uint32* bits = (uint32*)bitmap-&gt;Bits();</a>
<a name="ln1454">	uint32 bytesPerRow = bitmap-&gt;BytesPerRow();</a>
<a name="ln1455">	uint32 width = dragRect.IntegerWidth() + 1;</a>
<a name="ln1456">	uint32 height = dragRect.IntegerHeight() + 1;</a>
<a name="ln1457">	uint32 lastRow = (height - 1) * width;</a>
<a name="ln1458"> </a>
<a name="ln1459">	memset(bits, 0x00, height * bytesPerRow);</a>
<a name="ln1460"> </a>
<a name="ln1461">	// top</a>
<a name="ln1462">	for (uint32 i = 0; i &lt; width; i += 2)</a>
<a name="ln1463">		bits[i] = 0xff000000;</a>
<a name="ln1464"> </a>
<a name="ln1465">	// bottom</a>
<a name="ln1466">	for (uint32 i = (height % 2 == 0 ? 1 : 0); i &lt; width; i += 2)</a>
<a name="ln1467">		bits[lastRow + i] = 0xff000000;</a>
<a name="ln1468"> </a>
<a name="ln1469">	// left</a>
<a name="ln1470">	for (uint32 i = 0; i &lt; lastRow; i += width * 2)</a>
<a name="ln1471">		bits[i] = 0xff000000;</a>
<a name="ln1472"> </a>
<a name="ln1473">	// right</a>
<a name="ln1474">	for (uint32 i = (width % 2 == 0 ? width : 0); i &lt; lastRow; i += width * 2)</a>
<a name="ln1475">		bits[width - 1 + i] = 0xff000000;</a>
<a name="ln1476"> </a>
<a name="ln1477">	DragMessage(message, bitmap, B_OP_BLEND, offset, replyTo);</a>
<a name="ln1478">}</a>
<a name="ln1479"> </a>
<a name="ln1480"> </a>
<a name="ln1481">void</a>
<a name="ln1482">BView::DragMessage(BMessage* message, BBitmap* image, BPoint offset,</a>
<a name="ln1483">	BHandler* replyTo)</a>
<a name="ln1484">{</a>
<a name="ln1485">	DragMessage(message, image, B_OP_COPY, offset, replyTo);</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488"> </a>
<a name="ln1489">void</a>
<a name="ln1490">BView::DragMessage(BMessage* message, BBitmap* image,</a>
<a name="ln1491">	drawing_mode dragMode, BPoint offset, BHandler* replyTo)</a>
<a name="ln1492">{</a>
<a name="ln1493">	if (message == NULL)</a>
<a name="ln1494">		return;</a>
<a name="ln1495"> </a>
<a name="ln1496">	if (image == NULL) {</a>
<a name="ln1497">		// TODO: workaround for drags without a bitmap - should not be necessary if</a>
<a name="ln1498">		//	we move the rectangle dragging into the app_server</a>
<a name="ln1499">		image = new(std::nothrow) BBitmap(BRect(0, 0, 0, 0), B_RGBA32);</a>
<a name="ln1500">		if (image == NULL)</a>
<a name="ln1501">			return;</a>
<a name="ln1502">	}</a>
<a name="ln1503"> </a>
<a name="ln1504">	if (replyTo == NULL)</a>
<a name="ln1505">		replyTo = this;</a>
<a name="ln1506"> </a>
<a name="ln1507">	if (replyTo-&gt;Looper() == NULL)</a>
<a name="ln1508">		debugger(&quot;DragMessage: warning - the Handler needs a looper&quot;);</a>
<a name="ln1509"> </a>
<a name="ln1510">	_CheckOwnerLock();</a>
<a name="ln1511"> </a>
<a name="ln1512">	if (!message-&gt;HasInt32(&quot;buttons&quot;)) {</a>
<a name="ln1513">		BMessage* msg = fOwner-&gt;CurrentMessage();</a>
<a name="ln1514">		uint32 buttons;</a>
<a name="ln1515"> </a>
<a name="ln1516">		if (msg == NULL</a>
<a name="ln1517">			|| msg-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons) != B_OK) {</a>
<a name="ln1518">			BPoint point;</a>
<a name="ln1519">			GetMouse(&amp;point, &amp;buttons, false);</a>
<a name="ln1520">		}</a>
<a name="ln1521"> </a>
<a name="ln1522">		message-&gt;AddInt32(&quot;buttons&quot;, buttons);</a>
<a name="ln1523">	}</a>
<a name="ln1524"> </a>
<a name="ln1525">	BMessage::Private privateMessage(message);</a>
<a name="ln1526">	privateMessage.SetReply(BMessenger(replyTo, replyTo-&gt;Looper()));</a>
<a name="ln1527"> </a>
<a name="ln1528">	int32 bufferSize = message-&gt;FlattenedSize();</a>
<a name="ln1529">	char* buffer = new(std::nothrow) char[bufferSize];</a>
<a name="ln1530">	if (buffer != NULL) {</a>
<a name="ln1531">		message-&gt;Flatten(buffer, bufferSize);</a>
<a name="ln1532"> </a>
<a name="ln1533">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_DRAG_IMAGE);</a>
<a name="ln1534">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(image-&gt;_ServerToken());</a>
<a name="ln1535">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;((int32)dragMode);</a>
<a name="ln1536">		fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(offset);</a>
<a name="ln1537">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(bufferSize);</a>
<a name="ln1538">		fOwner-&gt;fLink-&gt;Attach(buffer, bufferSize);</a>
<a name="ln1539"> </a>
<a name="ln1540">		// we need to wait for the server</a>
<a name="ln1541">		// to actually process this message</a>
<a name="ln1542">		// before we can delete the bitmap</a>
<a name="ln1543">		int32 code;</a>
<a name="ln1544">		fOwner-&gt;fLink-&gt;FlushWithReply(code);</a>
<a name="ln1545"> </a>
<a name="ln1546">		delete [] buffer;</a>
<a name="ln1547">	} else {</a>
<a name="ln1548">		fprintf(stderr, &quot;BView::DragMessage() - no memory to flatten drag &quot;</a>
<a name="ln1549">			&quot;message\n&quot;);</a>
<a name="ln1550">	}</a>
<a name="ln1551"> </a>
<a name="ln1552">	delete image;</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555"> </a>
<a name="ln1556">void</a>
<a name="ln1557">BView::GetMouse(BPoint* _location, uint32* _buttons, bool checkMessageQueue)</a>
<a name="ln1558">{</a>
<a name="ln1559">	if (_location == NULL &amp;&amp; _buttons == NULL)</a>
<a name="ln1560">		return;</a>
<a name="ln1561"> </a>
<a name="ln1562">	_CheckOwnerLockAndSwitchCurrent();</a>
<a name="ln1563"> </a>
<a name="ln1564">	uint32 eventOptions = fEventOptions | fMouseEventOptions;</a>
<a name="ln1565">	bool noHistory = eventOptions &amp; B_NO_POINTER_HISTORY;</a>
<a name="ln1566">	bool fullHistory = eventOptions &amp; B_FULL_POINTER_HISTORY;</a>
<a name="ln1567"> </a>
<a name="ln1568">	if (checkMessageQueue &amp;&amp; !noHistory) {</a>
<a name="ln1569">		Window()-&gt;UpdateIfNeeded();</a>
<a name="ln1570">		BMessageQueue* queue = Window()-&gt;MessageQueue();</a>
<a name="ln1571">		queue-&gt;Lock();</a>
<a name="ln1572"> </a>
<a name="ln1573">		// Look out for mouse update messages</a>
<a name="ln1574"> </a>
<a name="ln1575">		BMessage* message;</a>
<a name="ln1576">		for (int32 i = 0; (message = queue-&gt;FindMessage(i)) != NULL; i++) {</a>
<a name="ln1577">			switch (message-&gt;what) {</a>
<a name="ln1578">				case B_MOUSE_MOVED:</a>
<a name="ln1579">				case B_MOUSE_UP:</a>
<a name="ln1580">				case B_MOUSE_DOWN:</a>
<a name="ln1581">					bool deleteMessage;</a>
<a name="ln1582">					if (!Window()-&gt;_StealMouseMessage(message, deleteMessage))</a>
<a name="ln1583">						continue;</a>
<a name="ln1584"> </a>
<a name="ln1585">					if (!fullHistory &amp;&amp; message-&gt;what == B_MOUSE_MOVED) {</a>
<a name="ln1586">						// Check if the message is too old. Some applications</a>
<a name="ln1587">						// check the message queue in such a way that mouse</a>
<a name="ln1588">						// messages *must* pile up. This check makes them work</a>
<a name="ln1589">						// as intended, although these applications could simply</a>
<a name="ln1590">						// use the version of BView::GetMouse() that does not</a>
<a name="ln1591">						// check the history. Also note that it isn't a problem</a>
<a name="ln1592">						// to delete the message in case there is not a newer</a>
<a name="ln1593">						// one. If we don't find a message in the queue, we will</a>
<a name="ln1594">						// just fall back to asking the app_sever directly. So</a>
<a name="ln1595">						// the imposed delay will not be a problem on slower</a>
<a name="ln1596">						// computers. This check also prevents another problem,</a>
<a name="ln1597">						// when the message that we use is *not* removed from</a>
<a name="ln1598">						// the queue. Subsequent calls to GetMouse() would find</a>
<a name="ln1599">						// this message over and over!</a>
<a name="ln1600">						bigtime_t eventTime;</a>
<a name="ln1601">						if (message-&gt;FindInt64(&quot;when&quot;, &amp;eventTime) == B_OK</a>
<a name="ln1602">							&amp;&amp; system_time() - eventTime &gt; 10000) {</a>
<a name="ln1603">							// just discard the message</a>
<a name="ln1604">							if (deleteMessage)</a>
<a name="ln1605">								delete message;</a>
<a name="ln1606">							continue;</a>
<a name="ln1607">						}</a>
<a name="ln1608">					}</a>
<a name="ln1609">					if (_location != NULL)</a>
<a name="ln1610">						message-&gt;FindPoint(&quot;screen_where&quot;, _location);</a>
<a name="ln1611">					if (_buttons != NULL)</a>
<a name="ln1612">						message-&gt;FindInt32(&quot;buttons&quot;, (int32*)_buttons);</a>
<a name="ln1613">					queue-&gt;Unlock();</a>
<a name="ln1614">						// we need to hold the queue lock until here, because</a>
<a name="ln1615">						// the message might still be used for something else</a>
<a name="ln1616"> </a>
<a name="ln1617">					if (_location != NULL)</a>
<a name="ln1618">						ConvertFromScreen(_location);</a>
<a name="ln1619"> </a>
<a name="ln1620">					if (deleteMessage)</a>
<a name="ln1621">						delete message;</a>
<a name="ln1622"> </a>
<a name="ln1623">					return;</a>
<a name="ln1624">			}</a>
<a name="ln1625">		}</a>
<a name="ln1626">		queue-&gt;Unlock();</a>
<a name="ln1627">	}</a>
<a name="ln1628"> </a>
<a name="ln1629">	// If no mouse update message has been found in the message queue,</a>
<a name="ln1630">	// we get the current mouse location and buttons from the app_server</a>
<a name="ln1631"> </a>
<a name="ln1632">	fOwner-&gt;fLink-&gt;StartMessage(AS_GET_MOUSE);</a>
<a name="ln1633"> </a>
<a name="ln1634">	int32 code;</a>
<a name="ln1635">	if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln1636">		&amp;&amp; code == B_OK) {</a>
<a name="ln1637">		BPoint location;</a>
<a name="ln1638">		uint32 buttons;</a>
<a name="ln1639">		fOwner-&gt;fLink-&gt;Read&lt;BPoint&gt;(&amp;location);</a>
<a name="ln1640">		fOwner-&gt;fLink-&gt;Read&lt;uint32&gt;(&amp;buttons);</a>
<a name="ln1641">			// TODO: ServerWindow replies with an int32 here</a>
<a name="ln1642"> </a>
<a name="ln1643">		ConvertFromScreen(&amp;location);</a>
<a name="ln1644">			// TODO: in beos R5, location is already converted to the view</a>
<a name="ln1645">			// local coordinate system, so if an app checks the window message</a>
<a name="ln1646">			// queue by itself, it might not find what it expects.</a>
<a name="ln1647">			// NOTE: the fact that we have mouse coords in screen space in our</a>
<a name="ln1648">			// queue avoids the problem that messages already in the queue will</a>
<a name="ln1649">			// be outdated as soon as a window or even the view moves. The</a>
<a name="ln1650">			// second situation being quite common actually, also with regards</a>
<a name="ln1651">			// to scrolling. An app reading these messages would have to know</a>
<a name="ln1652">			// the locations of the window and view for each message...</a>
<a name="ln1653">			// otherwise it is potentially broken anyways.</a>
<a name="ln1654">		if (_location != NULL)</a>
<a name="ln1655">			*_location = location;</a>
<a name="ln1656">		if (_buttons != NULL)</a>
<a name="ln1657">			*_buttons = buttons;</a>
<a name="ln1658">	} else {</a>
<a name="ln1659">		if (_location != NULL)</a>
<a name="ln1660">			_location-&gt;Set(0, 0);</a>
<a name="ln1661">		if (_buttons != NULL)</a>
<a name="ln1662">			*_buttons = 0;</a>
<a name="ln1663">	}</a>
<a name="ln1664">}</a>
<a name="ln1665"> </a>
<a name="ln1666"> </a>
<a name="ln1667">void</a>
<a name="ln1668">BView::MakeFocus(bool focus)</a>
<a name="ln1669">{</a>
<a name="ln1670">	if (fOwner == NULL)</a>
<a name="ln1671">		return;</a>
<a name="ln1672"> </a>
<a name="ln1673">	// TODO: If this view has focus and focus == false,</a>
<a name="ln1674">	// will there really be no other view with focus? No</a>
<a name="ln1675">	// cycling to the next one?</a>
<a name="ln1676">	BView* focusView = fOwner-&gt;CurrentFocus();</a>
<a name="ln1677">	if (focus) {</a>
<a name="ln1678">		// Unfocus a previous focus view</a>
<a name="ln1679">		if (focusView != NULL &amp;&amp; focusView != this)</a>
<a name="ln1680">			focusView-&gt;MakeFocus(false);</a>
<a name="ln1681"> </a>
<a name="ln1682">		// if we want to make this view the current focus view</a>
<a name="ln1683">		fOwner-&gt;_SetFocus(this, true);</a>
<a name="ln1684">	} else {</a>
<a name="ln1685">		// we want to unfocus this view, but only if it actually has focus</a>
<a name="ln1686">		if (focusView == this)</a>
<a name="ln1687">			fOwner-&gt;_SetFocus(NULL, true);</a>
<a name="ln1688">	}</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691"> </a>
<a name="ln1692">BScrollBar*</a>
<a name="ln1693">BView::ScrollBar(orientation direction) const</a>
<a name="ln1694">{</a>
<a name="ln1695">	switch (direction) {</a>
<a name="ln1696">		case B_VERTICAL:</a>
<a name="ln1697">			return fVerScroller;</a>
<a name="ln1698"> </a>
<a name="ln1699">		case B_HORIZONTAL:</a>
<a name="ln1700">			return fHorScroller;</a>
<a name="ln1701"> </a>
<a name="ln1702">		default:</a>
<a name="ln1703">			return NULL;</a>
<a name="ln1704">	}</a>
<a name="ln1705">}</a>
<a name="ln1706"> </a>
<a name="ln1707"> </a>
<a name="ln1708">void</a>
<a name="ln1709">BView::ScrollBy(float deltaX, float deltaY)</a>
<a name="ln1710">{</a>
<a name="ln1711">	ScrollTo(BPoint(fBounds.left + deltaX, fBounds.top + deltaY));</a>
<a name="ln1712">}</a>
<a name="ln1713"> </a>
<a name="ln1714"> </a>
<a name="ln1715">void</a>
<a name="ln1716">BView::ScrollTo(BPoint where)</a>
<a name="ln1717">{</a>
<a name="ln1718">	// scrolling by fractional values is not supported</a>
<a name="ln1719">	where.x = roundf(where.x);</a>
<a name="ln1720">	where.y = roundf(where.y);</a>
<a name="ln1721"> </a>
<a name="ln1722">	// no reason to process this further if no scroll is intended.</a>
<a name="ln1723">	if (where.x == fBounds.left &amp;&amp; where.y == fBounds.top)</a>
<a name="ln1724">		return;</a>
<a name="ln1725"> </a>
<a name="ln1726">	// make sure scrolling is within valid bounds</a>
<a name="ln1727">	if (fHorScroller) {</a>
<a name="ln1728">		float min, max;</a>
<a name="ln1729">		fHorScroller-&gt;GetRange(&amp;min, &amp;max);</a>
<a name="ln1730"> </a>
<a name="ln1731">		if (where.x &lt; min)</a>
<a name="ln1732">			where.x = min;</a>
<a name="ln1733">		else if (where.x &gt; max)</a>
<a name="ln1734">			where.x = max;</a>
<a name="ln1735">	}</a>
<a name="ln1736">	if (fVerScroller) {</a>
<a name="ln1737">		float min, max;</a>
<a name="ln1738">		fVerScroller-&gt;GetRange(&amp;min, &amp;max);</a>
<a name="ln1739"> </a>
<a name="ln1740">		if (where.y &lt; min)</a>
<a name="ln1741">			where.y = min;</a>
<a name="ln1742">		else if (where.y &gt; max)</a>
<a name="ln1743">			where.y = max;</a>
<a name="ln1744">	}</a>
<a name="ln1745"> </a>
<a name="ln1746">	_CheckLockAndSwitchCurrent();</a>
<a name="ln1747"> </a>
<a name="ln1748">	float xDiff = where.x - fBounds.left;</a>
<a name="ln1749">	float yDiff = where.y - fBounds.top;</a>
<a name="ln1750"> </a>
<a name="ln1751">	// if we're attached to a window tell app_server about this change</a>
<a name="ln1752">	if (fOwner) {</a>
<a name="ln1753">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SCROLL);</a>
<a name="ln1754">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(xDiff);</a>
<a name="ln1755">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(yDiff);</a>
<a name="ln1756"> </a>
<a name="ln1757">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln1758"> </a>
<a name="ln1759">//		fState-&gt;valid_flags &amp;= ~B_VIEW_FRAME_BIT;</a>
<a name="ln1760">	}</a>
<a name="ln1761"> </a>
<a name="ln1762">	// we modify our bounds rectangle by deltaX/deltaY coord units hor/ver.</a>
<a name="ln1763">	fBounds.OffsetTo(where.x, where.y);</a>
<a name="ln1764"> </a>
<a name="ln1765">	// then set the new values of the scrollbars</a>
<a name="ln1766">	if (fHorScroller &amp;&amp; xDiff != 0.0)</a>
<a name="ln1767">		fHorScroller-&gt;SetValue(fBounds.left);</a>
<a name="ln1768">	if (fVerScroller &amp;&amp; yDiff != 0.0)</a>
<a name="ln1769">		fVerScroller-&gt;SetValue(fBounds.top);</a>
<a name="ln1770"> </a>
<a name="ln1771">}</a>
<a name="ln1772"> </a>
<a name="ln1773"> </a>
<a name="ln1774">status_t</a>
<a name="ln1775">BView::SetEventMask(uint32 mask, uint32 options)</a>
<a name="ln1776">{</a>
<a name="ln1777">	if (fEventMask == mask &amp;&amp; fEventOptions == options)</a>
<a name="ln1778">		return B_OK;</a>
<a name="ln1779"> </a>
<a name="ln1780">	// don't change the mask if it's zero and we've got options</a>
<a name="ln1781">	if (mask != 0 || options == 0)</a>
<a name="ln1782">		fEventMask = mask | (fEventMask &amp; 0xffff0000);</a>
<a name="ln1783">	fEventOptions = options;</a>
<a name="ln1784"> </a>
<a name="ln1785">	fState-&gt;archiving_flags |= B_VIEW_EVENT_MASK_BIT;</a>
<a name="ln1786"> </a>
<a name="ln1787">	if (fOwner) {</a>
<a name="ln1788">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1789"> </a>
<a name="ln1790">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_EVENT_MASK);</a>
<a name="ln1791">		fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(mask);</a>
<a name="ln1792">		fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(options);</a>
<a name="ln1793">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln1794">	}</a>
<a name="ln1795"> </a>
<a name="ln1796">	return B_OK;</a>
<a name="ln1797">}</a>
<a name="ln1798"> </a>
<a name="ln1799"> </a>
<a name="ln1800">uint32</a>
<a name="ln1801">BView::EventMask()</a>
<a name="ln1802">{</a>
<a name="ln1803">	return fEventMask;</a>
<a name="ln1804">}</a>
<a name="ln1805"> </a>
<a name="ln1806"> </a>
<a name="ln1807">status_t</a>
<a name="ln1808">BView::SetMouseEventMask(uint32 mask, uint32 options)</a>
<a name="ln1809">{</a>
<a name="ln1810">	// Just don't do anything if the view is not yet attached</a>
<a name="ln1811">	// or we were called outside of BView::MouseDown()</a>
<a name="ln1812">	if (fOwner != NULL</a>
<a name="ln1813">		&amp;&amp; fOwner-&gt;CurrentMessage() != NULL</a>
<a name="ln1814">		&amp;&amp; fOwner-&gt;CurrentMessage()-&gt;what == B_MOUSE_DOWN) {</a>
<a name="ln1815">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1816">		fMouseEventOptions = options;</a>
<a name="ln1817"> </a>
<a name="ln1818">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_MOUSE_EVENT_MASK);</a>
<a name="ln1819">		fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(mask);</a>
<a name="ln1820">		fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(options);</a>
<a name="ln1821">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln1822">		return B_OK;</a>
<a name="ln1823">	}</a>
<a name="ln1824"> </a>
<a name="ln1825">	return B_ERROR;</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828"> </a>
<a name="ln1829">//	#pragma mark - Graphic State Functions</a>
<a name="ln1830"> </a>
<a name="ln1831"> </a>
<a name="ln1832">void</a>
<a name="ln1833">BView::PushState()</a>
<a name="ln1834">{</a>
<a name="ln1835">	_CheckOwnerLockAndSwitchCurrent();</a>
<a name="ln1836"> </a>
<a name="ln1837">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_PUSH_STATE);</a>
<a name="ln1838"> </a>
<a name="ln1839">	// initialize origin, scale and transform, new states start &quot;clean&quot;.</a>
<a name="ln1840">	fState-&gt;valid_flags |= B_VIEW_SCALE_BIT | B_VIEW_ORIGIN_BIT</a>
<a name="ln1841">		| B_VIEW_TRANSFORM_BIT;</a>
<a name="ln1842">	fState-&gt;scale = 1.0f;</a>
<a name="ln1843">	fState-&gt;origin.Set(0, 0);</a>
<a name="ln1844">	fState-&gt;transform.Reset();</a>
<a name="ln1845">}</a>
<a name="ln1846"> </a>
<a name="ln1847"> </a>
<a name="ln1848">void</a>
<a name="ln1849">BView::PopState()</a>
<a name="ln1850">{</a>
<a name="ln1851">	_CheckOwnerLockAndSwitchCurrent();</a>
<a name="ln1852"> </a>
<a name="ln1853">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_POP_STATE);</a>
<a name="ln1854">	_FlushIfNotInTransaction();</a>
<a name="ln1855"> </a>
<a name="ln1856">	// invalidate all flags (except those that are not part of pop/push)</a>
<a name="ln1857">	fState-&gt;valid_flags = B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln1858">}</a>
<a name="ln1859"> </a>
<a name="ln1860"> </a>
<a name="ln1861">void</a>
<a name="ln1862">BView::SetOrigin(BPoint where)</a>
<a name="ln1863">{</a>
<a name="ln1864">	SetOrigin(where.x, where.y);</a>
<a name="ln1865">}</a>
<a name="ln1866"> </a>
<a name="ln1867"> </a>
<a name="ln1868">void</a>
<a name="ln1869">BView::SetOrigin(float x, float y)</a>
<a name="ln1870">{</a>
<a name="ln1871">	if (fState-&gt;IsValid(B_VIEW_ORIGIN_BIT)</a>
<a name="ln1872">		&amp;&amp; x == fState-&gt;origin.x &amp;&amp; y == fState-&gt;origin.y)</a>
<a name="ln1873">		return;</a>
<a name="ln1874"> </a>
<a name="ln1875">	fState-&gt;origin.x = x;</a>
<a name="ln1876">	fState-&gt;origin.y = y;</a>
<a name="ln1877"> </a>
<a name="ln1878">	if (_CheckOwnerLockAndSwitchCurrent()) {</a>
<a name="ln1879">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_ORIGIN);</a>
<a name="ln1880">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(x);</a>
<a name="ln1881">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(y);</a>
<a name="ln1882"> </a>
<a name="ln1883">		fState-&gt;valid_flags |= B_VIEW_ORIGIN_BIT;</a>
<a name="ln1884">	}</a>
<a name="ln1885"> </a>
<a name="ln1886">	// our local coord system origin has changed, so when archiving we'll add</a>
<a name="ln1887">	// this too</a>
<a name="ln1888">	fState-&gt;archiving_flags |= B_VIEW_ORIGIN_BIT;</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891"> </a>
<a name="ln1892">BPoint</a>
<a name="ln1893">BView::Origin() const</a>
<a name="ln1894">{</a>
<a name="ln1895">	if (!fState-&gt;IsValid(B_VIEW_ORIGIN_BIT)) {</a>
<a name="ln1896">		// we don't keep graphics state information, therefor</a>
<a name="ln1897">		// we need to ask the server for the origin after PopState()</a>
<a name="ln1898">		_CheckOwnerLockAndSwitchCurrent();</a>
<a name="ln1899"> </a>
<a name="ln1900">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_ORIGIN);</a>
<a name="ln1901"> </a>
<a name="ln1902">		int32 code;</a>
<a name="ln1903">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK &amp;&amp; code == B_OK)</a>
<a name="ln1904">			fOwner-&gt;fLink-&gt;Read&lt;BPoint&gt;(&amp;fState-&gt;origin);</a>
<a name="ln1905"> </a>
<a name="ln1906">		fState-&gt;valid_flags |= B_VIEW_ORIGIN_BIT;</a>
<a name="ln1907">	}</a>
<a name="ln1908"> </a>
<a name="ln1909">	return fState-&gt;origin;</a>
<a name="ln1910">}</a>
<a name="ln1911"> </a>
<a name="ln1912"> </a>
<a name="ln1913">void</a>
<a name="ln1914">BView::SetScale(float scale) const</a>
<a name="ln1915">{</a>
<a name="ln1916">	if (fState-&gt;IsValid(B_VIEW_SCALE_BIT) &amp;&amp; scale == fState-&gt;scale)</a>
<a name="ln1917">		return;</a>
<a name="ln1918"> </a>
<a name="ln1919">	if (fOwner) {</a>
<a name="ln1920">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1921"> </a>
<a name="ln1922">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_SCALE);</a>
<a name="ln1923">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(scale);</a>
<a name="ln1924"> </a>
<a name="ln1925">		fState-&gt;valid_flags |= B_VIEW_SCALE_BIT;</a>
<a name="ln1926">	}</a>
<a name="ln1927"> </a>
<a name="ln1928">	fState-&gt;scale = scale;</a>
<a name="ln1929">	fState-&gt;archiving_flags |= B_VIEW_SCALE_BIT;</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932"> </a>
<a name="ln1933">float</a>
<a name="ln1934">BView::Scale() const</a>
<a name="ln1935">{</a>
<a name="ln1936">	if (!fState-&gt;IsValid(B_VIEW_SCALE_BIT) &amp;&amp; fOwner) {</a>
<a name="ln1937">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1938"> </a>
<a name="ln1939">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_SCALE);</a>
<a name="ln1940"> </a>
<a name="ln1941"> 		int32 code;</a>
<a name="ln1942">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK &amp;&amp; code == B_OK)</a>
<a name="ln1943">			fOwner-&gt;fLink-&gt;Read&lt;float&gt;(&amp;fState-&gt;scale);</a>
<a name="ln1944"> </a>
<a name="ln1945">		fState-&gt;valid_flags |= B_VIEW_SCALE_BIT;</a>
<a name="ln1946">	}</a>
<a name="ln1947"> </a>
<a name="ln1948">	return fState-&gt;scale;</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951"> </a>
<a name="ln1952">void</a>
<a name="ln1953">BView::SetTransform(BAffineTransform transform)</a>
<a name="ln1954">{</a>
<a name="ln1955">	if (fState-&gt;IsValid(B_VIEW_TRANSFORM_BIT) &amp;&amp; transform == fState-&gt;transform)</a>
<a name="ln1956">		return;</a>
<a name="ln1957"> </a>
<a name="ln1958">	if (fOwner != NULL) {</a>
<a name="ln1959">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1960"> </a>
<a name="ln1961">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_TRANSFORM);</a>
<a name="ln1962">		fOwner-&gt;fLink-&gt;Attach&lt;BAffineTransform&gt;(transform);</a>
<a name="ln1963"> </a>
<a name="ln1964">		fState-&gt;valid_flags |= B_VIEW_TRANSFORM_BIT;</a>
<a name="ln1965">	}</a>
<a name="ln1966"> </a>
<a name="ln1967">	fState-&gt;transform = transform;</a>
<a name="ln1968">	fState-&gt;archiving_flags |= B_VIEW_TRANSFORM_BIT;</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971"> </a>
<a name="ln1972">BAffineTransform</a>
<a name="ln1973">BView::Transform() const</a>
<a name="ln1974">{</a>
<a name="ln1975">	if (!fState-&gt;IsValid(B_VIEW_TRANSFORM_BIT) &amp;&amp; fOwner != NULL) {</a>
<a name="ln1976">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1977"> </a>
<a name="ln1978">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_TRANSFORM);</a>
<a name="ln1979"> </a>
<a name="ln1980"> 		int32 code;</a>
<a name="ln1981">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK &amp;&amp; code == B_OK)</a>
<a name="ln1982">			fOwner-&gt;fLink-&gt;Read&lt;BAffineTransform&gt;(&amp;fState-&gt;transform);</a>
<a name="ln1983"> </a>
<a name="ln1984">		fState-&gt;valid_flags |= B_VIEW_TRANSFORM_BIT;</a>
<a name="ln1985">	}</a>
<a name="ln1986"> </a>
<a name="ln1987">	return fState-&gt;transform;</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990"> </a>
<a name="ln1991">void</a>
<a name="ln1992">BView::TranslateBy(double x, double y)</a>
<a name="ln1993">{</a>
<a name="ln1994">	if (fOwner != NULL) {</a>
<a name="ln1995">		_CheckLockAndSwitchCurrent();</a>
<a name="ln1996"> </a>
<a name="ln1997">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_AFFINE_TRANSLATE);</a>
<a name="ln1998">		fOwner-&gt;fLink-&gt;Attach&lt;double&gt;(x);</a>
<a name="ln1999">		fOwner-&gt;fLink-&gt;Attach&lt;double&gt;(y);</a>
<a name="ln2000"> </a>
<a name="ln2001">		fState-&gt;valid_flags &amp;= ~B_VIEW_TRANSFORM_BIT;</a>
<a name="ln2002">	}</a>
<a name="ln2003"> </a>
<a name="ln2004">	fState-&gt;archiving_flags |= B_VIEW_TRANSFORM_BIT;</a>
<a name="ln2005">}</a>
<a name="ln2006"> </a>
<a name="ln2007"> </a>
<a name="ln2008">void</a>
<a name="ln2009">BView::ScaleBy(double x, double y)</a>
<a name="ln2010">{</a>
<a name="ln2011">	if (fOwner != NULL) {</a>
<a name="ln2012">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2013"> </a>
<a name="ln2014">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_AFFINE_SCALE);</a>
<a name="ln2015">		fOwner-&gt;fLink-&gt;Attach&lt;double&gt;(x);</a>
<a name="ln2016">		fOwner-&gt;fLink-&gt;Attach&lt;double&gt;(y);</a>
<a name="ln2017"> </a>
<a name="ln2018">		fState-&gt;valid_flags &amp;= ~B_VIEW_TRANSFORM_BIT;</a>
<a name="ln2019">	}</a>
<a name="ln2020"> </a>
<a name="ln2021">	fState-&gt;archiving_flags |= B_VIEW_TRANSFORM_BIT;</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024"> </a>
<a name="ln2025">void</a>
<a name="ln2026">BView::RotateBy(double angleRadians)</a>
<a name="ln2027">{</a>
<a name="ln2028">	if (fOwner != NULL) {</a>
<a name="ln2029">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2030"> </a>
<a name="ln2031">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_AFFINE_ROTATE);</a>
<a name="ln2032">		fOwner-&gt;fLink-&gt;Attach&lt;double&gt;(angleRadians);</a>
<a name="ln2033"> </a>
<a name="ln2034">		fState-&gt;valid_flags &amp;= ~B_VIEW_TRANSFORM_BIT;</a>
<a name="ln2035">	}</a>
<a name="ln2036"> </a>
<a name="ln2037">	fState-&gt;archiving_flags |= B_VIEW_TRANSFORM_BIT;</a>
<a name="ln2038">}</a>
<a name="ln2039"> </a>
<a name="ln2040"> </a>
<a name="ln2041">void</a>
<a name="ln2042">BView::SetLineMode(cap_mode lineCap, join_mode lineJoin, float miterLimit)</a>
<a name="ln2043">{</a>
<a name="ln2044">	if (fState-&gt;IsValid(B_VIEW_LINE_MODES_BIT)</a>
<a name="ln2045">		&amp;&amp; lineCap == fState-&gt;line_cap &amp;&amp; lineJoin == fState-&gt;line_join</a>
<a name="ln2046">		&amp;&amp; miterLimit == fState-&gt;miter_limit)</a>
<a name="ln2047">		return;</a>
<a name="ln2048"> </a>
<a name="ln2049">	if (fOwner) {</a>
<a name="ln2050">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2051"> </a>
<a name="ln2052">		ViewSetLineModeInfo info;</a>
<a name="ln2053">		info.lineJoin = lineJoin;</a>
<a name="ln2054">		info.lineCap = lineCap;</a>
<a name="ln2055">		info.miterLimit = miterLimit;</a>
<a name="ln2056"> </a>
<a name="ln2057">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_LINE_MODE);</a>
<a name="ln2058">		fOwner-&gt;fLink-&gt;Attach&lt;ViewSetLineModeInfo&gt;(info);</a>
<a name="ln2059"> </a>
<a name="ln2060">		fState-&gt;valid_flags |= B_VIEW_LINE_MODES_BIT;</a>
<a name="ln2061">	}</a>
<a name="ln2062"> </a>
<a name="ln2063">	fState-&gt;line_cap = lineCap;</a>
<a name="ln2064">	fState-&gt;line_join = lineJoin;</a>
<a name="ln2065">	fState-&gt;miter_limit = miterLimit;</a>
<a name="ln2066"> </a>
<a name="ln2067">	fState-&gt;archiving_flags |= B_VIEW_LINE_MODES_BIT;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070"> </a>
<a name="ln2071">join_mode</a>
<a name="ln2072">BView::LineJoinMode() const</a>
<a name="ln2073">{</a>
<a name="ln2074">	// This will update the current state, if necessary</a>
<a name="ln2075">	if (!fState-&gt;IsValid(B_VIEW_LINE_MODES_BIT))</a>
<a name="ln2076">		LineMiterLimit();</a>
<a name="ln2077"> </a>
<a name="ln2078">	return fState-&gt;line_join;</a>
<a name="ln2079">}</a>
<a name="ln2080"> </a>
<a name="ln2081"> </a>
<a name="ln2082">cap_mode</a>
<a name="ln2083">BView::LineCapMode() const</a>
<a name="ln2084">{</a>
<a name="ln2085">	// This will update the current state, if necessary</a>
<a name="ln2086">	if (!fState-&gt;IsValid(B_VIEW_LINE_MODES_BIT))</a>
<a name="ln2087">		LineMiterLimit();</a>
<a name="ln2088"> </a>
<a name="ln2089">	return fState-&gt;line_cap;</a>
<a name="ln2090">}</a>
<a name="ln2091"> </a>
<a name="ln2092"> </a>
<a name="ln2093">float</a>
<a name="ln2094">BView::LineMiterLimit() const</a>
<a name="ln2095">{</a>
<a name="ln2096">	if (!fState-&gt;IsValid(B_VIEW_LINE_MODES_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2097">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2098"> </a>
<a name="ln2099">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_LINE_MODE);</a>
<a name="ln2100"> </a>
<a name="ln2101">		int32 code;</a>
<a name="ln2102">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK &amp;&amp; code == B_OK) {</a>
<a name="ln2103"> </a>
<a name="ln2104">			ViewSetLineModeInfo info;</a>
<a name="ln2105">			fOwner-&gt;fLink-&gt;Read&lt;ViewSetLineModeInfo&gt;(&amp;info);</a>
<a name="ln2106"> </a>
<a name="ln2107">			fState-&gt;line_cap = info.lineCap;</a>
<a name="ln2108">			fState-&gt;line_join = info.lineJoin;</a>
<a name="ln2109">			fState-&gt;miter_limit = info.miterLimit;</a>
<a name="ln2110">		}</a>
<a name="ln2111"> </a>
<a name="ln2112">		fState-&gt;valid_flags |= B_VIEW_LINE_MODES_BIT;</a>
<a name="ln2113">	}</a>
<a name="ln2114"> </a>
<a name="ln2115">	return fState-&gt;miter_limit;</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118"> </a>
<a name="ln2119">void</a>
<a name="ln2120">BView::SetFillRule(int32 fillRule)</a>
<a name="ln2121">{</a>
<a name="ln2122">	if (fState-&gt;IsValid(B_VIEW_FILL_RULE_BIT) &amp;&amp; fillRule == fState-&gt;fill_rule)</a>
<a name="ln2123">		return;</a>
<a name="ln2124"> </a>
<a name="ln2125">	if (fOwner) {</a>
<a name="ln2126">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2127"> </a>
<a name="ln2128">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_FILL_RULE);</a>
<a name="ln2129">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(fillRule);</a>
<a name="ln2130"> </a>
<a name="ln2131">		fState-&gt;valid_flags |= B_VIEW_FILL_RULE_BIT;</a>
<a name="ln2132">	}</a>
<a name="ln2133"> </a>
<a name="ln2134">	fState-&gt;fill_rule = fillRule;</a>
<a name="ln2135"> </a>
<a name="ln2136">	fState-&gt;archiving_flags |= B_VIEW_FILL_RULE_BIT;</a>
<a name="ln2137">}</a>
<a name="ln2138"> </a>
<a name="ln2139"> </a>
<a name="ln2140">int32</a>
<a name="ln2141">BView::FillRule() const</a>
<a name="ln2142">{</a>
<a name="ln2143">	if (!fState-&gt;IsValid(B_VIEW_FILL_RULE_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2144">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2145"> </a>
<a name="ln2146">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_FILL_RULE);</a>
<a name="ln2147"> </a>
<a name="ln2148">		int32 code;</a>
<a name="ln2149">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK &amp;&amp; code == B_OK) {</a>
<a name="ln2150"> </a>
<a name="ln2151">			int32 fillRule;</a>
<a name="ln2152">			fOwner-&gt;fLink-&gt;Read&lt;int32&gt;(&amp;fillRule);</a>
<a name="ln2153"> </a>
<a name="ln2154">			fState-&gt;fill_rule = fillRule;</a>
<a name="ln2155">		}</a>
<a name="ln2156"> </a>
<a name="ln2157">		fState-&gt;valid_flags |= B_VIEW_FILL_RULE_BIT;</a>
<a name="ln2158">	}</a>
<a name="ln2159"> </a>
<a name="ln2160">	return fState-&gt;fill_rule;</a>
<a name="ln2161">}</a>
<a name="ln2162"> </a>
<a name="ln2163"> </a>
<a name="ln2164">void</a>
<a name="ln2165">BView::SetDrawingMode(drawing_mode mode)</a>
<a name="ln2166">{</a>
<a name="ln2167">	if (fState-&gt;IsValid(B_VIEW_DRAWING_MODE_BIT)</a>
<a name="ln2168">		&amp;&amp; mode == fState-&gt;drawing_mode)</a>
<a name="ln2169">		return;</a>
<a name="ln2170"> </a>
<a name="ln2171">	if (fOwner) {</a>
<a name="ln2172">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2173"> </a>
<a name="ln2174">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_DRAWING_MODE);</a>
<a name="ln2175">		fOwner-&gt;fLink-&gt;Attach&lt;int8&gt;((int8)mode);</a>
<a name="ln2176"> </a>
<a name="ln2177">		fState-&gt;valid_flags |= B_VIEW_DRAWING_MODE_BIT;</a>
<a name="ln2178">	}</a>
<a name="ln2179"> </a>
<a name="ln2180">	fState-&gt;drawing_mode = mode;</a>
<a name="ln2181">	fState-&gt;archiving_flags |= B_VIEW_DRAWING_MODE_BIT;</a>
<a name="ln2182">}</a>
<a name="ln2183"> </a>
<a name="ln2184"> </a>
<a name="ln2185">drawing_mode</a>
<a name="ln2186">BView::DrawingMode() const</a>
<a name="ln2187">{</a>
<a name="ln2188">	if (!fState-&gt;IsValid(B_VIEW_DRAWING_MODE_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2189">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2190"> </a>
<a name="ln2191">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_DRAWING_MODE);</a>
<a name="ln2192"> </a>
<a name="ln2193">		int32 code;</a>
<a name="ln2194">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2195">			&amp;&amp; code == B_OK) {</a>
<a name="ln2196">			int8 drawingMode;</a>
<a name="ln2197">			fOwner-&gt;fLink-&gt;Read&lt;int8&gt;(&amp;drawingMode);</a>
<a name="ln2198"> </a>
<a name="ln2199">			fState-&gt;drawing_mode = (drawing_mode)drawingMode;</a>
<a name="ln2200">			fState-&gt;valid_flags |= B_VIEW_DRAWING_MODE_BIT;</a>
<a name="ln2201">		}</a>
<a name="ln2202">	}</a>
<a name="ln2203"> </a>
<a name="ln2204">	return fState-&gt;drawing_mode;</a>
<a name="ln2205">}</a>
<a name="ln2206"> </a>
<a name="ln2207"> </a>
<a name="ln2208">void</a>
<a name="ln2209">BView::SetBlendingMode(source_alpha sourceAlpha, alpha_function alphaFunction)</a>
<a name="ln2210">{</a>
<a name="ln2211">	if (fState-&gt;IsValid(B_VIEW_BLENDING_BIT)</a>
<a name="ln2212">		&amp;&amp; sourceAlpha == fState-&gt;alpha_source_mode</a>
<a name="ln2213">		&amp;&amp; alphaFunction == fState-&gt;alpha_function_mode)</a>
<a name="ln2214">		return;</a>
<a name="ln2215"> </a>
<a name="ln2216">	if (fOwner) {</a>
<a name="ln2217">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2218"> </a>
<a name="ln2219">		ViewBlendingModeInfo info;</a>
<a name="ln2220">		info.sourceAlpha = sourceAlpha;</a>
<a name="ln2221">		info.alphaFunction = alphaFunction;</a>
<a name="ln2222"> </a>
<a name="ln2223">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_BLENDING_MODE);</a>
<a name="ln2224">		fOwner-&gt;fLink-&gt;Attach&lt;ViewBlendingModeInfo&gt;(info);</a>
<a name="ln2225"> </a>
<a name="ln2226">		fState-&gt;valid_flags |= B_VIEW_BLENDING_BIT;</a>
<a name="ln2227">	}</a>
<a name="ln2228"> </a>
<a name="ln2229">	fState-&gt;alpha_source_mode = sourceAlpha;</a>
<a name="ln2230">	fState-&gt;alpha_function_mode = alphaFunction;</a>
<a name="ln2231"> </a>
<a name="ln2232">	fState-&gt;archiving_flags |= B_VIEW_BLENDING_BIT;</a>
<a name="ln2233">}</a>
<a name="ln2234"> </a>
<a name="ln2235"> </a>
<a name="ln2236">void</a>
<a name="ln2237">BView::GetBlendingMode(source_alpha* _sourceAlpha,</a>
<a name="ln2238">	alpha_function* _alphaFunction) const</a>
<a name="ln2239">{</a>
<a name="ln2240">	if (!fState-&gt;IsValid(B_VIEW_BLENDING_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2241">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2242"> </a>
<a name="ln2243">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_BLENDING_MODE);</a>
<a name="ln2244"> </a>
<a name="ln2245">		int32 code;</a>
<a name="ln2246"> 		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK &amp;&amp; code == B_OK) {</a>
<a name="ln2247"> 			ViewBlendingModeInfo info;</a>
<a name="ln2248">			fOwner-&gt;fLink-&gt;Read&lt;ViewBlendingModeInfo&gt;(&amp;info);</a>
<a name="ln2249"> </a>
<a name="ln2250">			fState-&gt;alpha_source_mode = info.sourceAlpha;</a>
<a name="ln2251">			fState-&gt;alpha_function_mode = info.alphaFunction;</a>
<a name="ln2252"> </a>
<a name="ln2253">			fState-&gt;valid_flags |= B_VIEW_BLENDING_BIT;</a>
<a name="ln2254">		}</a>
<a name="ln2255">	}</a>
<a name="ln2256"> </a>
<a name="ln2257">	if (_sourceAlpha)</a>
<a name="ln2258">		*_sourceAlpha = fState-&gt;alpha_source_mode;</a>
<a name="ln2259"> </a>
<a name="ln2260">	if (_alphaFunction)</a>
<a name="ln2261">		*_alphaFunction = fState-&gt;alpha_function_mode;</a>
<a name="ln2262">}</a>
<a name="ln2263"> </a>
<a name="ln2264"> </a>
<a name="ln2265">void</a>
<a name="ln2266">BView::MovePenTo(BPoint point)</a>
<a name="ln2267">{</a>
<a name="ln2268">	MovePenTo(point.x, point.y);</a>
<a name="ln2269">}</a>
<a name="ln2270"> </a>
<a name="ln2271"> </a>
<a name="ln2272">void</a>
<a name="ln2273">BView::MovePenTo(float x, float y)</a>
<a name="ln2274">{</a>
<a name="ln2275">	if (fState-&gt;IsValid(B_VIEW_PEN_LOCATION_BIT)</a>
<a name="ln2276">		&amp;&amp; x == fState-&gt;pen_location.x &amp;&amp; y == fState-&gt;pen_location.y)</a>
<a name="ln2277">		return;</a>
<a name="ln2278"> </a>
<a name="ln2279">	if (fOwner) {</a>
<a name="ln2280">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2281"> </a>
<a name="ln2282">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_PEN_LOC);</a>
<a name="ln2283">		fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(BPoint(x, y));</a>
<a name="ln2284"> </a>
<a name="ln2285">		fState-&gt;valid_flags |= B_VIEW_PEN_LOCATION_BIT;</a>
<a name="ln2286">	}</a>
<a name="ln2287"> </a>
<a name="ln2288">	fState-&gt;pen_location.x = x;</a>
<a name="ln2289">	fState-&gt;pen_location.y = y;</a>
<a name="ln2290"> </a>
<a name="ln2291">	fState-&gt;archiving_flags |= B_VIEW_PEN_LOCATION_BIT;</a>
<a name="ln2292">}</a>
<a name="ln2293"> </a>
<a name="ln2294"> </a>
<a name="ln2295">void</a>
<a name="ln2296">BView::MovePenBy(float x, float y)</a>
<a name="ln2297">{</a>
<a name="ln2298">	// this will update the pen location if necessary</a>
<a name="ln2299">	if (!fState-&gt;IsValid(B_VIEW_PEN_LOCATION_BIT))</a>
<a name="ln2300">		PenLocation();</a>
<a name="ln2301"> </a>
<a name="ln2302">	MovePenTo(fState-&gt;pen_location.x + x, fState-&gt;pen_location.y + y);</a>
<a name="ln2303">}</a>
<a name="ln2304"> </a>
<a name="ln2305"> </a>
<a name="ln2306">BPoint</a>
<a name="ln2307">BView::PenLocation() const</a>
<a name="ln2308">{</a>
<a name="ln2309">	if (!fState-&gt;IsValid(B_VIEW_PEN_LOCATION_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2310">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2311"> </a>
<a name="ln2312">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_PEN_LOC);</a>
<a name="ln2313"> </a>
<a name="ln2314">		int32 code;</a>
<a name="ln2315">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2316">			&amp;&amp; code == B_OK) {</a>
<a name="ln2317">			fOwner-&gt;fLink-&gt;Read&lt;BPoint&gt;(&amp;fState-&gt;pen_location);</a>
<a name="ln2318"> </a>
<a name="ln2319">			fState-&gt;valid_flags |= B_VIEW_PEN_LOCATION_BIT;</a>
<a name="ln2320">		}</a>
<a name="ln2321">	}</a>
<a name="ln2322"> </a>
<a name="ln2323">	return fState-&gt;pen_location;</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326"> </a>
<a name="ln2327">void</a>
<a name="ln2328">BView::SetPenSize(float size)</a>
<a name="ln2329">{</a>
<a name="ln2330">	if (fState-&gt;IsValid(B_VIEW_PEN_SIZE_BIT) &amp;&amp; size == fState-&gt;pen_size)</a>
<a name="ln2331">		return;</a>
<a name="ln2332"> </a>
<a name="ln2333">	if (fOwner) {</a>
<a name="ln2334">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2335"> </a>
<a name="ln2336">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_PEN_SIZE);</a>
<a name="ln2337">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(size);</a>
<a name="ln2338"> </a>
<a name="ln2339">		fState-&gt;valid_flags |= B_VIEW_PEN_SIZE_BIT;</a>
<a name="ln2340">	}</a>
<a name="ln2341"> </a>
<a name="ln2342">	fState-&gt;pen_size = size;</a>
<a name="ln2343">	fState-&gt;archiving_flags	|= B_VIEW_PEN_SIZE_BIT;</a>
<a name="ln2344">}</a>
<a name="ln2345"> </a>
<a name="ln2346"> </a>
<a name="ln2347">float</a>
<a name="ln2348">BView::PenSize() const</a>
<a name="ln2349">{</a>
<a name="ln2350">	if (!fState-&gt;IsValid(B_VIEW_PEN_SIZE_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2351">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2352"> </a>
<a name="ln2353">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_PEN_SIZE);</a>
<a name="ln2354"> </a>
<a name="ln2355">		int32 code;</a>
<a name="ln2356">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2357">			&amp;&amp; code == B_OK) {</a>
<a name="ln2358">			fOwner-&gt;fLink-&gt;Read&lt;float&gt;(&amp;fState-&gt;pen_size);</a>
<a name="ln2359"> </a>
<a name="ln2360">			fState-&gt;valid_flags |= B_VIEW_PEN_SIZE_BIT;</a>
<a name="ln2361">		}</a>
<a name="ln2362">	}</a>
<a name="ln2363"> </a>
<a name="ln2364">	return fState-&gt;pen_size;</a>
<a name="ln2365">}</a>
<a name="ln2366"> </a>
<a name="ln2367"> </a>
<a name="ln2368">void</a>
<a name="ln2369">BView::SetHighColor(rgb_color color)</a>
<a name="ln2370">{</a>
<a name="ln2371">	SetHighUIColor(B_NO_COLOR);</a>
<a name="ln2372"> </a>
<a name="ln2373">	// are we up-to-date already?</a>
<a name="ln2374">	if (fState-&gt;IsValid(B_VIEW_HIGH_COLOR_BIT)</a>
<a name="ln2375">		&amp;&amp; fState-&gt;high_color == color)</a>
<a name="ln2376">		return;</a>
<a name="ln2377"> </a>
<a name="ln2378">	if (fOwner) {</a>
<a name="ln2379">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2380"> </a>
<a name="ln2381">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_HIGH_COLOR);</a>
<a name="ln2382">		fOwner-&gt;fLink-&gt;Attach&lt;rgb_color&gt;(color);</a>
<a name="ln2383"> </a>
<a name="ln2384">		fState-&gt;valid_flags |= B_VIEW_HIGH_COLOR_BIT;</a>
<a name="ln2385">	}</a>
<a name="ln2386"> </a>
<a name="ln2387">	fState-&gt;high_color = color;</a>
<a name="ln2388"> </a>
<a name="ln2389">	fState-&gt;archiving_flags |= B_VIEW_HIGH_COLOR_BIT;</a>
<a name="ln2390">}</a>
<a name="ln2391"> </a>
<a name="ln2392"> </a>
<a name="ln2393">rgb_color</a>
<a name="ln2394">BView::HighColor() const</a>
<a name="ln2395">{</a>
<a name="ln2396">	if (!fState-&gt;IsValid(B_VIEW_HIGH_COLOR_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2397">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2398"> </a>
<a name="ln2399">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_HIGH_COLOR);</a>
<a name="ln2400"> </a>
<a name="ln2401">		int32 code;</a>
<a name="ln2402">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2403">			&amp;&amp; code == B_OK) {</a>
<a name="ln2404">			fOwner-&gt;fLink-&gt;Read&lt;rgb_color&gt;(&amp;fState-&gt;high_color);</a>
<a name="ln2405"> </a>
<a name="ln2406">			fState-&gt;valid_flags |= B_VIEW_HIGH_COLOR_BIT;</a>
<a name="ln2407">		}</a>
<a name="ln2408">	}</a>
<a name="ln2409"> </a>
<a name="ln2410">	return fState-&gt;high_color;</a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413"> </a>
<a name="ln2414">void</a>
<a name="ln2415">BView::SetHighUIColor(color_which which, float tint)</a>
<a name="ln2416">{</a>
<a name="ln2417">	if (fState-&gt;IsValid(B_VIEW_WHICH_HIGH_COLOR_BIT)</a>
<a name="ln2418">		&amp;&amp; fState-&gt;which_high_color == which</a>
<a name="ln2419">		&amp;&amp; fState-&gt;which_high_color_tint == tint)</a>
<a name="ln2420">		return;</a>
<a name="ln2421"> </a>
<a name="ln2422">	if (fOwner != NULL) {</a>
<a name="ln2423">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2424"> </a>
<a name="ln2425">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_HIGH_UI_COLOR);</a>
<a name="ln2426">		fOwner-&gt;fLink-&gt;Attach&lt;color_which&gt;(which);</a>
<a name="ln2427">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(tint);</a>
<a name="ln2428"> </a>
<a name="ln2429">		fState-&gt;valid_flags |= B_VIEW_WHICH_HIGH_COLOR_BIT;</a>
<a name="ln2430">	}</a>
<a name="ln2431"> </a>
<a name="ln2432">	fState-&gt;which_high_color = which;</a>
<a name="ln2433">	fState-&gt;which_high_color_tint = tint;</a>
<a name="ln2434"> </a>
<a name="ln2435">	if (which != B_NO_COLOR) {</a>
<a name="ln2436">		fState-&gt;archiving_flags |= B_VIEW_WHICH_HIGH_COLOR_BIT;</a>
<a name="ln2437">		fState-&gt;archiving_flags &amp;= ~B_VIEW_HIGH_COLOR_BIT;</a>
<a name="ln2438">		fState-&gt;valid_flags |= B_VIEW_HIGH_COLOR_BIT;</a>
<a name="ln2439"> </a>
<a name="ln2440">		fState-&gt;high_color = tint_color(ui_color(which), tint);</a>
<a name="ln2441">	} else {</a>
<a name="ln2442">		fState-&gt;valid_flags &amp;= ~B_VIEW_HIGH_COLOR_BIT;</a>
<a name="ln2443">		fState-&gt;archiving_flags &amp;= ~B_VIEW_WHICH_HIGH_COLOR_BIT;</a>
<a name="ln2444">	}</a>
<a name="ln2445">}</a>
<a name="ln2446"> </a>
<a name="ln2447"> </a>
<a name="ln2448">color_which</a>
<a name="ln2449">BView::HighUIColor(float* tint) const</a>
<a name="ln2450">{</a>
<a name="ln2451">	if (!fState-&gt;IsValid(B_VIEW_WHICH_HIGH_COLOR_BIT)</a>
<a name="ln2452">		&amp;&amp; fOwner != NULL) {</a>
<a name="ln2453">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2454"> </a>
<a name="ln2455">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_HIGH_UI_COLOR);</a>
<a name="ln2456"> </a>
<a name="ln2457">		int32 code;</a>
<a name="ln2458">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2459">			&amp;&amp; code == B_OK) {</a>
<a name="ln2460">			fOwner-&gt;fLink-&gt;Read&lt;color_which&gt;(&amp;fState-&gt;which_high_color);</a>
<a name="ln2461">			fOwner-&gt;fLink-&gt;Read&lt;float&gt;(&amp;fState-&gt;which_high_color_tint);</a>
<a name="ln2462">			fOwner-&gt;fLink-&gt;Read&lt;rgb_color&gt;(&amp;fState-&gt;high_color);</a>
<a name="ln2463"> </a>
<a name="ln2464">			fState-&gt;valid_flags |= B_VIEW_WHICH_HIGH_COLOR_BIT;</a>
<a name="ln2465">			fState-&gt;valid_flags |= B_VIEW_HIGH_COLOR_BIT;</a>
<a name="ln2466">		}</a>
<a name="ln2467">	}</a>
<a name="ln2468"> </a>
<a name="ln2469">	if (tint != NULL)</a>
<a name="ln2470">		*tint = fState-&gt;which_high_color_tint;</a>
<a name="ln2471"> </a>
<a name="ln2472">	return fState-&gt;which_high_color;</a>
<a name="ln2473">}</a>
<a name="ln2474"> </a>
<a name="ln2475"> </a>
<a name="ln2476">void</a>
<a name="ln2477">BView::SetLowColor(rgb_color color)</a>
<a name="ln2478">{</a>
<a name="ln2479">	SetLowUIColor(B_NO_COLOR);</a>
<a name="ln2480"> </a>
<a name="ln2481">	if (fState-&gt;IsValid(B_VIEW_LOW_COLOR_BIT)</a>
<a name="ln2482">		&amp;&amp; fState-&gt;low_color == color)</a>
<a name="ln2483">		return;</a>
<a name="ln2484"> </a>
<a name="ln2485">	if (fOwner) {</a>
<a name="ln2486">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2487"> </a>
<a name="ln2488">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_LOW_COLOR);</a>
<a name="ln2489">		fOwner-&gt;fLink-&gt;Attach&lt;rgb_color&gt;(color);</a>
<a name="ln2490"> </a>
<a name="ln2491">		fState-&gt;valid_flags |= B_VIEW_LOW_COLOR_BIT;</a>
<a name="ln2492">	}</a>
<a name="ln2493"> </a>
<a name="ln2494">	fState-&gt;low_color = color;</a>
<a name="ln2495"> </a>
<a name="ln2496">	fState-&gt;archiving_flags |= B_VIEW_LOW_COLOR_BIT;</a>
<a name="ln2497">}</a>
<a name="ln2498"> </a>
<a name="ln2499"> </a>
<a name="ln2500">rgb_color</a>
<a name="ln2501">BView::LowColor() const</a>
<a name="ln2502">{</a>
<a name="ln2503">	if (!fState-&gt;IsValid(B_VIEW_LOW_COLOR_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2504">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2505"> </a>
<a name="ln2506">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_LOW_COLOR);</a>
<a name="ln2507"> </a>
<a name="ln2508">		int32 code;</a>
<a name="ln2509">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2510">			&amp;&amp; code == B_OK) {</a>
<a name="ln2511">			fOwner-&gt;fLink-&gt;Read&lt;rgb_color&gt;(&amp;fState-&gt;low_color);</a>
<a name="ln2512"> </a>
<a name="ln2513">			fState-&gt;valid_flags |= B_VIEW_LOW_COLOR_BIT;</a>
<a name="ln2514">		}</a>
<a name="ln2515">	}</a>
<a name="ln2516"> </a>
<a name="ln2517">	return fState-&gt;low_color;</a>
<a name="ln2518">}</a>
<a name="ln2519"> </a>
<a name="ln2520"> </a>
<a name="ln2521">void</a>
<a name="ln2522">BView::SetLowUIColor(color_which which, float tint)</a>
<a name="ln2523">{</a>
<a name="ln2524">	if (fState-&gt;IsValid(B_VIEW_WHICH_LOW_COLOR_BIT)</a>
<a name="ln2525">		&amp;&amp; fState-&gt;which_low_color == which</a>
<a name="ln2526">		&amp;&amp; fState-&gt;which_low_color_tint == tint)</a>
<a name="ln2527">		return;</a>
<a name="ln2528"> </a>
<a name="ln2529">	if (fOwner != NULL) {</a>
<a name="ln2530">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2531"> </a>
<a name="ln2532">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_LOW_UI_COLOR);</a>
<a name="ln2533">		fOwner-&gt;fLink-&gt;Attach&lt;color_which&gt;(which);</a>
<a name="ln2534">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(tint);</a>
<a name="ln2535"> </a>
<a name="ln2536">		fState-&gt;valid_flags |= B_VIEW_WHICH_LOW_COLOR_BIT;</a>
<a name="ln2537">	}</a>
<a name="ln2538"> </a>
<a name="ln2539">	fState-&gt;which_low_color = which;</a>
<a name="ln2540">	fState-&gt;which_low_color_tint = tint;</a>
<a name="ln2541"> </a>
<a name="ln2542">	if (which != B_NO_COLOR) {</a>
<a name="ln2543">		fState-&gt;archiving_flags |= B_VIEW_WHICH_LOW_COLOR_BIT;</a>
<a name="ln2544">		fState-&gt;archiving_flags &amp;= ~B_VIEW_LOW_COLOR_BIT;</a>
<a name="ln2545">		fState-&gt;valid_flags |= B_VIEW_LOW_COLOR_BIT;</a>
<a name="ln2546"> </a>
<a name="ln2547">		fState-&gt;low_color = tint_color(ui_color(which), tint);</a>
<a name="ln2548">	} else {</a>
<a name="ln2549">		fState-&gt;valid_flags &amp;= ~B_VIEW_LOW_COLOR_BIT;</a>
<a name="ln2550">		fState-&gt;archiving_flags &amp;= ~B_VIEW_WHICH_LOW_COLOR_BIT;</a>
<a name="ln2551">	}</a>
<a name="ln2552">}</a>
<a name="ln2553"> </a>
<a name="ln2554"> </a>
<a name="ln2555">color_which</a>
<a name="ln2556">BView::LowUIColor(float* tint) const</a>
<a name="ln2557">{</a>
<a name="ln2558">	if (!fState-&gt;IsValid(B_VIEW_WHICH_LOW_COLOR_BIT)</a>
<a name="ln2559">		&amp;&amp; fOwner != NULL) {</a>
<a name="ln2560">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2561"> </a>
<a name="ln2562">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_LOW_UI_COLOR);</a>
<a name="ln2563"> </a>
<a name="ln2564">		int32 code;</a>
<a name="ln2565">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2566">			&amp;&amp; code == B_OK) {</a>
<a name="ln2567">			fOwner-&gt;fLink-&gt;Read&lt;color_which&gt;(&amp;fState-&gt;which_low_color);</a>
<a name="ln2568">			fOwner-&gt;fLink-&gt;Read&lt;float&gt;(&amp;fState-&gt;which_low_color_tint);</a>
<a name="ln2569">			fOwner-&gt;fLink-&gt;Read&lt;rgb_color&gt;(&amp;fState-&gt;low_color);</a>
<a name="ln2570"> </a>
<a name="ln2571">			fState-&gt;valid_flags |= B_VIEW_WHICH_LOW_COLOR_BIT;</a>
<a name="ln2572">			fState-&gt;valid_flags |= B_VIEW_LOW_COLOR_BIT;</a>
<a name="ln2573">		}</a>
<a name="ln2574">	}</a>
<a name="ln2575"> </a>
<a name="ln2576">	if (tint != NULL)</a>
<a name="ln2577">		*tint = fState-&gt;which_low_color_tint;</a>
<a name="ln2578"> </a>
<a name="ln2579">	return fState-&gt;which_low_color;</a>
<a name="ln2580">}</a>
<a name="ln2581"> </a>
<a name="ln2582"> </a>
<a name="ln2583">bool</a>
<a name="ln2584">BView::HasDefaultColors() const</a>
<a name="ln2585">{</a>
<a name="ln2586">	// If we don't have any of these flags, then we have default colors</a>
<a name="ln2587">	uint32 testMask = B_VIEW_VIEW_COLOR_BIT | B_VIEW_HIGH_COLOR_BIT</a>
<a name="ln2588">		| B_VIEW_LOW_COLOR_BIT | B_VIEW_WHICH_VIEW_COLOR_BIT</a>
<a name="ln2589">		| B_VIEW_WHICH_HIGH_COLOR_BIT | B_VIEW_WHICH_LOW_COLOR_BIT;</a>
<a name="ln2590"> </a>
<a name="ln2591">	return (fState-&gt;archiving_flags &amp; testMask) == 0;</a>
<a name="ln2592">}</a>
<a name="ln2593"> </a>
<a name="ln2594"> </a>
<a name="ln2595">bool</a>
<a name="ln2596">BView::HasSystemColors() const</a>
<a name="ln2597">{</a>
<a name="ln2598">	return fState-&gt;which_view_color == B_PANEL_BACKGROUND_COLOR</a>
<a name="ln2599">		&amp;&amp; fState-&gt;which_high_color == B_PANEL_TEXT_COLOR</a>
<a name="ln2600">		&amp;&amp; fState-&gt;which_low_color == B_PANEL_BACKGROUND_COLOR</a>
<a name="ln2601">		&amp;&amp; fState-&gt;which_view_color_tint == B_NO_TINT</a>
<a name="ln2602">		&amp;&amp; fState-&gt;which_high_color_tint == B_NO_TINT</a>
<a name="ln2603">		&amp;&amp; fState-&gt;which_low_color_tint == B_NO_TINT;</a>
<a name="ln2604">}</a>
<a name="ln2605"> </a>
<a name="ln2606"> </a>
<a name="ln2607">void</a>
<a name="ln2608">BView::AdoptParentColors()</a>
<a name="ln2609">{</a>
<a name="ln2610">	AdoptViewColors(Parent());</a>
<a name="ln2611">}</a>
<a name="ln2612"> </a>
<a name="ln2613"> </a>
<a name="ln2614">void</a>
<a name="ln2615">BView::AdoptSystemColors()</a>
<a name="ln2616">{</a>
<a name="ln2617">	SetViewUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln2618">	SetLowUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln2619">	SetHighUIColor(B_PANEL_TEXT_COLOR);</a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622"> </a>
<a name="ln2623">void</a>
<a name="ln2624">BView::AdoptViewColors(BView* view)</a>
<a name="ln2625">{</a>
<a name="ln2626">	if (view == NULL || (view-&gt;Window() != NULL &amp;&amp; !view-&gt;LockLooper()))</a>
<a name="ln2627">		return;</a>
<a name="ln2628"> </a>
<a name="ln2629">	float tint = B_NO_TINT;</a>
<a name="ln2630">	float viewTint = tint;</a>
<a name="ln2631">	color_which viewWhich = view-&gt;ViewUIColor(&amp;viewTint);</a>
<a name="ln2632"> </a>
<a name="ln2633">	// View color</a>
<a name="ln2634">	if (viewWhich != B_NO_COLOR)</a>
<a name="ln2635">		SetViewUIColor(viewWhich, viewTint);</a>
<a name="ln2636">	else</a>
<a name="ln2637">		SetViewColor(view-&gt;ViewColor());</a>
<a name="ln2638"> </a>
<a name="ln2639">	// Low color</a>
<a name="ln2640">	color_which which = view-&gt;LowUIColor(&amp;tint);</a>
<a name="ln2641">	if (which != B_NO_COLOR)</a>
<a name="ln2642">		SetLowUIColor(which, tint);</a>
<a name="ln2643">	else if (viewWhich != B_NO_COLOR)</a>
<a name="ln2644">		SetLowUIColor(viewWhich, viewTint);</a>
<a name="ln2645">	else</a>
<a name="ln2646">		SetLowColor(view-&gt;LowColor());</a>
<a name="ln2647"> </a>
<a name="ln2648">	// High color</a>
<a name="ln2649">	which = view-&gt;HighUIColor(&amp;tint);</a>
<a name="ln2650">	if (which != B_NO_COLOR)</a>
<a name="ln2651">		SetHighUIColor(which, tint);</a>
<a name="ln2652">	else</a>
<a name="ln2653">		SetHighColor(view-&gt;HighColor());</a>
<a name="ln2654"> </a>
<a name="ln2655">	if (view-&gt;Window() != NULL)</a>
<a name="ln2656">		view-&gt;UnlockLooper();</a>
<a name="ln2657">}</a>
<a name="ln2658"> </a>
<a name="ln2659"> </a>
<a name="ln2660">void</a>
<a name="ln2661">BView::SetViewColor(rgb_color color)</a>
<a name="ln2662">{</a>
<a name="ln2663">	SetViewUIColor(B_NO_COLOR);</a>
<a name="ln2664"> </a>
<a name="ln2665">	if (fState-&gt;IsValid(B_VIEW_VIEW_COLOR_BIT)</a>
<a name="ln2666">		&amp;&amp; fState-&gt;view_color == color)</a>
<a name="ln2667">		return;</a>
<a name="ln2668"> </a>
<a name="ln2669">	if (fOwner) {</a>
<a name="ln2670">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2671"> </a>
<a name="ln2672">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_VIEW_COLOR);</a>
<a name="ln2673">		fOwner-&gt;fLink-&gt;Attach&lt;rgb_color&gt;(color);</a>
<a name="ln2674">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln2675"> </a>
<a name="ln2676">		fState-&gt;valid_flags |= B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln2677">	}</a>
<a name="ln2678"> </a>
<a name="ln2679">	fState-&gt;view_color = color;</a>
<a name="ln2680"> </a>
<a name="ln2681">	fState-&gt;archiving_flags |= B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln2682">}</a>
<a name="ln2683"> </a>
<a name="ln2684"> </a>
<a name="ln2685">rgb_color</a>
<a name="ln2686">BView::ViewColor() const</a>
<a name="ln2687">{</a>
<a name="ln2688">	if (!fState-&gt;IsValid(B_VIEW_VIEW_COLOR_BIT) &amp;&amp; fOwner) {</a>
<a name="ln2689">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2690"> </a>
<a name="ln2691">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_VIEW_COLOR);</a>
<a name="ln2692"> </a>
<a name="ln2693">		int32 code;</a>
<a name="ln2694">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2695">			&amp;&amp; code == B_OK) {</a>
<a name="ln2696">			fOwner-&gt;fLink-&gt;Read&lt;rgb_color&gt;(&amp;fState-&gt;view_color);</a>
<a name="ln2697"> </a>
<a name="ln2698">			fState-&gt;valid_flags |= B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln2699">		}</a>
<a name="ln2700">	}</a>
<a name="ln2701"> </a>
<a name="ln2702">	return fState-&gt;view_color;</a>
<a name="ln2703">}</a>
<a name="ln2704"> </a>
<a name="ln2705"> </a>
<a name="ln2706">void</a>
<a name="ln2707">BView::SetViewUIColor(color_which which, float tint)</a>
<a name="ln2708">{</a>
<a name="ln2709">	if (fState-&gt;IsValid(B_VIEW_WHICH_VIEW_COLOR_BIT)</a>
<a name="ln2710">		&amp;&amp; fState-&gt;which_view_color == which</a>
<a name="ln2711">		&amp;&amp; fState-&gt;which_view_color_tint == tint)</a>
<a name="ln2712">		return;</a>
<a name="ln2713"> </a>
<a name="ln2714">	if (fOwner != NULL) {</a>
<a name="ln2715">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2716"> </a>
<a name="ln2717">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_VIEW_UI_COLOR);</a>
<a name="ln2718">		fOwner-&gt;fLink-&gt;Attach&lt;color_which&gt;(which);</a>
<a name="ln2719">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(tint);</a>
<a name="ln2720"> </a>
<a name="ln2721">		fState-&gt;valid_flags |= B_VIEW_WHICH_VIEW_COLOR_BIT;</a>
<a name="ln2722">	}</a>
<a name="ln2723"> </a>
<a name="ln2724">	fState-&gt;which_view_color = which;</a>
<a name="ln2725">	fState-&gt;which_view_color_tint = tint;</a>
<a name="ln2726"> </a>
<a name="ln2727">	if (which != B_NO_COLOR) {</a>
<a name="ln2728">		fState-&gt;archiving_flags |= B_VIEW_WHICH_VIEW_COLOR_BIT;</a>
<a name="ln2729">		fState-&gt;archiving_flags &amp;= ~B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln2730">		fState-&gt;valid_flags |= B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln2731"> </a>
<a name="ln2732">		fState-&gt;view_color = tint_color(ui_color(which), tint);</a>
<a name="ln2733">	} else {</a>
<a name="ln2734">		fState-&gt;valid_flags &amp;= ~B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln2735">		fState-&gt;archiving_flags &amp;= ~B_VIEW_WHICH_VIEW_COLOR_BIT;</a>
<a name="ln2736">	}</a>
<a name="ln2737"> </a>
<a name="ln2738">	if (!fState-&gt;IsValid(B_VIEW_WHICH_LOW_COLOR_BIT))</a>
<a name="ln2739">		SetLowUIColor(which, tint);</a>
<a name="ln2740">}</a>
<a name="ln2741"> </a>
<a name="ln2742"> </a>
<a name="ln2743">color_which</a>
<a name="ln2744">BView::ViewUIColor(float* tint) const</a>
<a name="ln2745">{</a>
<a name="ln2746">	if (!fState-&gt;IsValid(B_VIEW_WHICH_VIEW_COLOR_BIT)</a>
<a name="ln2747">		&amp;&amp; fOwner != NULL) {</a>
<a name="ln2748">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2749"> </a>
<a name="ln2750">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_VIEW_UI_COLOR);</a>
<a name="ln2751"> </a>
<a name="ln2752">		int32 code;</a>
<a name="ln2753">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2754">			&amp;&amp; code == B_OK) {</a>
<a name="ln2755">			fOwner-&gt;fLink-&gt;Read&lt;color_which&gt;(&amp;fState-&gt;which_view_color);</a>
<a name="ln2756">			fOwner-&gt;fLink-&gt;Read&lt;float&gt;(&amp;fState-&gt;which_view_color_tint);</a>
<a name="ln2757">			fOwner-&gt;fLink-&gt;Read&lt;rgb_color&gt;(&amp;fState-&gt;view_color);</a>
<a name="ln2758"> </a>
<a name="ln2759">			fState-&gt;valid_flags |= B_VIEW_WHICH_VIEW_COLOR_BIT;</a>
<a name="ln2760">			fState-&gt;valid_flags |= B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln2761">		}</a>
<a name="ln2762">	}</a>
<a name="ln2763"> </a>
<a name="ln2764">	if (tint != NULL)</a>
<a name="ln2765">		*tint = fState-&gt;which_view_color_tint;</a>
<a name="ln2766"> </a>
<a name="ln2767">	return fState-&gt;which_view_color;</a>
<a name="ln2768">}</a>
<a name="ln2769"> </a>
<a name="ln2770"> </a>
<a name="ln2771">void</a>
<a name="ln2772">BView::ForceFontAliasing(bool enable)</a>
<a name="ln2773">{</a>
<a name="ln2774">	if (fState-&gt;IsValid(B_VIEW_FONT_ALIASING_BIT)</a>
<a name="ln2775">		&amp;&amp; enable == fState-&gt;font_aliasing)</a>
<a name="ln2776">		return;</a>
<a name="ln2777"> </a>
<a name="ln2778">	if (fOwner) {</a>
<a name="ln2779">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2780"> </a>
<a name="ln2781">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_PRINT_ALIASING);</a>
<a name="ln2782">		fOwner-&gt;fLink-&gt;Attach&lt;bool&gt;(enable);</a>
<a name="ln2783"> </a>
<a name="ln2784">		fState-&gt;valid_flags |= B_VIEW_FONT_ALIASING_BIT;</a>
<a name="ln2785">	}</a>
<a name="ln2786"> </a>
<a name="ln2787">	fState-&gt;font_aliasing = enable;</a>
<a name="ln2788">	fState-&gt;archiving_flags |= B_VIEW_FONT_ALIASING_BIT;</a>
<a name="ln2789">}</a>
<a name="ln2790"> </a>
<a name="ln2791"> </a>
<a name="ln2792">void</a>
<a name="ln2793">BView::SetFont(const BFont* font, uint32 mask)</a>
<a name="ln2794">{</a>
<a name="ln2795">	if (!font || mask == 0)</a>
<a name="ln2796">		return;</a>
<a name="ln2797"> </a>
<a name="ln2798">	if (mask == B_FONT_ALL) {</a>
<a name="ln2799">		fState-&gt;font = *font;</a>
<a name="ln2800">	} else {</a>
<a name="ln2801">		// TODO: move this into a BFont method</a>
<a name="ln2802">		if (mask &amp; B_FONT_FAMILY_AND_STYLE)</a>
<a name="ln2803">			fState-&gt;font.SetFamilyAndStyle(font-&gt;FamilyAndStyle());</a>
<a name="ln2804"> </a>
<a name="ln2805">		if (mask &amp; B_FONT_SIZE)</a>
<a name="ln2806">			fState-&gt;font.SetSize(font-&gt;Size());</a>
<a name="ln2807"> </a>
<a name="ln2808">		if (mask &amp; B_FONT_SHEAR)</a>
<a name="ln2809">			fState-&gt;font.SetShear(font-&gt;Shear());</a>
<a name="ln2810"> </a>
<a name="ln2811">		if (mask &amp; B_FONT_ROTATION)</a>
<a name="ln2812">			fState-&gt;font.SetRotation(font-&gt;Rotation());</a>
<a name="ln2813"> </a>
<a name="ln2814">		if (mask &amp; B_FONT_FALSE_BOLD_WIDTH)</a>
<a name="ln2815">			fState-&gt;font.SetFalseBoldWidth(font-&gt;FalseBoldWidth());</a>
<a name="ln2816"> </a>
<a name="ln2817">		if (mask &amp; B_FONT_SPACING)</a>
<a name="ln2818">			fState-&gt;font.SetSpacing(font-&gt;Spacing());</a>
<a name="ln2819"> </a>
<a name="ln2820">		if (mask &amp; B_FONT_ENCODING)</a>
<a name="ln2821">			fState-&gt;font.SetEncoding(font-&gt;Encoding());</a>
<a name="ln2822"> </a>
<a name="ln2823">		if (mask &amp; B_FONT_FACE)</a>
<a name="ln2824">			fState-&gt;font.SetFace(font-&gt;Face());</a>
<a name="ln2825"> </a>
<a name="ln2826">		if (mask &amp; B_FONT_FLAGS)</a>
<a name="ln2827">			fState-&gt;font.SetFlags(font-&gt;Flags());</a>
<a name="ln2828">	}</a>
<a name="ln2829"> </a>
<a name="ln2830">	fState-&gt;font_flags |= mask;</a>
<a name="ln2831"> </a>
<a name="ln2832">	if (fOwner) {</a>
<a name="ln2833">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2834"> </a>
<a name="ln2835">		fState-&gt;UpdateServerFontState(*fOwner-&gt;fLink);</a>
<a name="ln2836">		fState-&gt;valid_flags |= B_VIEW_FONT_BIT;</a>
<a name="ln2837">	}</a>
<a name="ln2838"> </a>
<a name="ln2839">	fState-&gt;archiving_flags |= B_VIEW_FONT_BIT;</a>
<a name="ln2840">	// TODO: InvalidateLayout() here for convenience?</a>
<a name="ln2841">}</a>
<a name="ln2842"> </a>
<a name="ln2843"> </a>
<a name="ln2844">void</a>
<a name="ln2845">BView::GetFont(BFont* font) const</a>
<a name="ln2846">{</a>
<a name="ln2847">	if (!fState-&gt;IsValid(B_VIEW_FONT_BIT)) {</a>
<a name="ln2848">		// we don't keep graphics state information, therefor</a>
<a name="ln2849">		// we need to ask the server for the origin after PopState()</a>
<a name="ln2850">		_CheckOwnerLockAndSwitchCurrent();</a>
<a name="ln2851"> </a>
<a name="ln2852">		// TODO: add a font getter!</a>
<a name="ln2853">		fState-&gt;UpdateFrom(*fOwner-&gt;fLink);</a>
<a name="ln2854">	}</a>
<a name="ln2855"> </a>
<a name="ln2856">	*font = fState-&gt;font;</a>
<a name="ln2857">}</a>
<a name="ln2858"> </a>
<a name="ln2859"> </a>
<a name="ln2860">void</a>
<a name="ln2861">BView::GetFontHeight(font_height* height) const</a>
<a name="ln2862">{</a>
<a name="ln2863">	fState-&gt;font.GetHeight(height);</a>
<a name="ln2864">}</a>
<a name="ln2865"> </a>
<a name="ln2866"> </a>
<a name="ln2867">void</a>
<a name="ln2868">BView::SetFontSize(float size)</a>
<a name="ln2869">{</a>
<a name="ln2870">	BFont font;</a>
<a name="ln2871">	font.SetSize(size);</a>
<a name="ln2872"> </a>
<a name="ln2873">	SetFont(&amp;font, B_FONT_SIZE);</a>
<a name="ln2874">}</a>
<a name="ln2875"> </a>
<a name="ln2876"> </a>
<a name="ln2877">float</a>
<a name="ln2878">BView::StringWidth(const char* string) const</a>
<a name="ln2879">{</a>
<a name="ln2880">	return fState-&gt;font.StringWidth(string);</a>
<a name="ln2881">}</a>
<a name="ln2882"> </a>
<a name="ln2883"> </a>
<a name="ln2884">float</a>
<a name="ln2885">BView::StringWidth(const char* string, int32 length) const</a>
<a name="ln2886">{</a>
<a name="ln2887">	return fState-&gt;font.StringWidth(string, length);</a>
<a name="ln2888">}</a>
<a name="ln2889"> </a>
<a name="ln2890"> </a>
<a name="ln2891">void</a>
<a name="ln2892">BView::GetStringWidths(char* stringArray[], int32 lengthArray[],</a>
<a name="ln2893">	int32 numStrings, float widthArray[]) const</a>
<a name="ln2894">{</a>
<a name="ln2895">	fState-&gt;font.GetStringWidths(const_cast&lt;const char**&gt;(stringArray),</a>
<a name="ln2896">		const_cast&lt;const int32*&gt;(lengthArray), numStrings, widthArray);</a>
<a name="ln2897">}</a>
<a name="ln2898"> </a>
<a name="ln2899"> </a>
<a name="ln2900">void</a>
<a name="ln2901">BView::TruncateString(BString* string, uint32 mode, float width) const</a>
<a name="ln2902">{</a>
<a name="ln2903">	fState-&gt;font.TruncateString(string, mode, width);</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906"> </a>
<a name="ln2907">void</a>
<a name="ln2908">BView::ClipToPicture(BPicture* picture, BPoint where, bool sync)</a>
<a name="ln2909">{</a>
<a name="ln2910">	_ClipToPicture(picture, where, false, sync);</a>
<a name="ln2911">}</a>
<a name="ln2912"> </a>
<a name="ln2913"> </a>
<a name="ln2914">void</a>
<a name="ln2915">BView::ClipToInversePicture(BPicture* picture, BPoint where, bool sync)</a>
<a name="ln2916">{</a>
<a name="ln2917">	_ClipToPicture(picture, where, true, sync);</a>
<a name="ln2918">}</a>
<a name="ln2919"> </a>
<a name="ln2920"> </a>
<a name="ln2921">void</a>
<a name="ln2922">BView::GetClippingRegion(BRegion* region) const</a>
<a name="ln2923">{</a>
<a name="ln2924">	if (!region)</a>
<a name="ln2925">		return;</a>
<a name="ln2926"> </a>
<a name="ln2927">	// NOTE: the client has no idea when the clipping in the server</a>
<a name="ln2928">	// changed, so it is always read from the server</a>
<a name="ln2929">	region-&gt;MakeEmpty();</a>
<a name="ln2930"> </a>
<a name="ln2931"> </a>
<a name="ln2932">	if (fOwner) {</a>
<a name="ln2933">		if (fIsPrinting &amp;&amp; _CheckOwnerLock()) {</a>
<a name="ln2934">			region-&gt;Set(fState-&gt;print_rect);</a>
<a name="ln2935">			return;</a>
<a name="ln2936">		}</a>
<a name="ln2937"> </a>
<a name="ln2938">		_CheckLockAndSwitchCurrent();</a>
<a name="ln2939">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_CLIP_REGION);</a>
<a name="ln2940"> </a>
<a name="ln2941"> 		int32 code;</a>
<a name="ln2942"> 		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln2943"> 			&amp;&amp; code == B_OK) {</a>
<a name="ln2944">			fOwner-&gt;fLink-&gt;ReadRegion(region);</a>
<a name="ln2945">			fState-&gt;valid_flags |= B_VIEW_CLIP_REGION_BIT;</a>
<a name="ln2946">		}</a>
<a name="ln2947">	}</a>
<a name="ln2948">}</a>
<a name="ln2949"> </a>
<a name="ln2950"> </a>
<a name="ln2951">void</a>
<a name="ln2952">BView::ConstrainClippingRegion(BRegion* region)</a>
<a name="ln2953">{</a>
<a name="ln2954">	if (_CheckOwnerLockAndSwitchCurrent()) {</a>
<a name="ln2955">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_CLIP_REGION);</a>
<a name="ln2956"> </a>
<a name="ln2957">		if (region) {</a>
<a name="ln2958">			int32 count = region-&gt;CountRects();</a>
<a name="ln2959">			fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(count);</a>
<a name="ln2960">			if (count &gt; 0)</a>
<a name="ln2961">				fOwner-&gt;fLink-&gt;AttachRegion(*region);</a>
<a name="ln2962">		} else {</a>
<a name="ln2963">			fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(-1);</a>
<a name="ln2964">			// '-1' means that in the app_server, there won't be any 'local'</a>
<a name="ln2965">			// clipping region (it will be NULL)</a>
<a name="ln2966">		}</a>
<a name="ln2967"> </a>
<a name="ln2968">		_FlushIfNotInTransaction();</a>
<a name="ln2969"> </a>
<a name="ln2970">		fState-&gt;valid_flags &amp;= ~B_VIEW_CLIP_REGION_BIT;</a>
<a name="ln2971">		fState-&gt;archiving_flags |= B_VIEW_CLIP_REGION_BIT;</a>
<a name="ln2972">	}</a>
<a name="ln2973">}</a>
<a name="ln2974"> </a>
<a name="ln2975"> </a>
<a name="ln2976">void</a>
<a name="ln2977">BView::ClipToRect(BRect rect)</a>
<a name="ln2978">{</a>
<a name="ln2979">	_ClipToRect(rect, false);</a>
<a name="ln2980">}</a>
<a name="ln2981"> </a>
<a name="ln2982"> </a>
<a name="ln2983">void</a>
<a name="ln2984">BView::ClipToInverseRect(BRect rect)</a>
<a name="ln2985">{</a>
<a name="ln2986">	_ClipToRect(rect, true);</a>
<a name="ln2987">}</a>
<a name="ln2988"> </a>
<a name="ln2989"> </a>
<a name="ln2990">void</a>
<a name="ln2991">BView::ClipToShape(BShape* shape)</a>
<a name="ln2992">{</a>
<a name="ln2993">	_ClipToShape(shape, false);</a>
<a name="ln2994">}</a>
<a name="ln2995"> </a>
<a name="ln2996"> </a>
<a name="ln2997">void</a>
<a name="ln2998">BView::ClipToInverseShape(BShape* shape)</a>
<a name="ln2999">{</a>
<a name="ln3000">	_ClipToShape(shape, true);</a>
<a name="ln3001">}</a>
<a name="ln3002"> </a>
<a name="ln3003"> </a>
<a name="ln3004">//	#pragma mark - Drawing Functions</a>
<a name="ln3005"> </a>
<a name="ln3006"> </a>
<a name="ln3007">void</a>
<a name="ln3008">BView::DrawBitmapAsync(const BBitmap* bitmap, BRect bitmapRect, BRect viewRect,</a>
<a name="ln3009">	uint32 options)</a>
<a name="ln3010">{</a>
<a name="ln3011">	if (bitmap == NULL || fOwner == NULL</a>
<a name="ln3012">		|| !bitmapRect.IsValid() || !viewRect.IsValid())</a>
<a name="ln3013">		return;</a>
<a name="ln3014"> </a>
<a name="ln3015">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3016"> </a>
<a name="ln3017">	ViewDrawBitmapInfo info;</a>
<a name="ln3018">	info.bitmapToken = bitmap-&gt;_ServerToken();</a>
<a name="ln3019">	info.options = options;</a>
<a name="ln3020">	info.viewRect = viewRect;</a>
<a name="ln3021">	info.bitmapRect = bitmapRect;</a>
<a name="ln3022"> </a>
<a name="ln3023">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_DRAW_BITMAP);</a>
<a name="ln3024">	fOwner-&gt;fLink-&gt;Attach&lt;ViewDrawBitmapInfo&gt;(info);</a>
<a name="ln3025"> </a>
<a name="ln3026">	_FlushIfNotInTransaction();</a>
<a name="ln3027">}</a>
<a name="ln3028"> </a>
<a name="ln3029"> </a>
<a name="ln3030">void</a>
<a name="ln3031">BView::DrawBitmapAsync(const BBitmap* bitmap, BRect bitmapRect, BRect viewRect)</a>
<a name="ln3032">{</a>
<a name="ln3033">	DrawBitmapAsync(bitmap, bitmapRect, viewRect, 0);</a>
<a name="ln3034">}</a>
<a name="ln3035"> </a>
<a name="ln3036"> </a>
<a name="ln3037">void</a>
<a name="ln3038">BView::DrawBitmapAsync(const BBitmap* bitmap, BRect viewRect)</a>
<a name="ln3039">{</a>
<a name="ln3040">	if (bitmap &amp;&amp; fOwner) {</a>
<a name="ln3041">		DrawBitmapAsync(bitmap, bitmap-&gt;Bounds().OffsetToCopy(B_ORIGIN),</a>
<a name="ln3042">			viewRect, 0);</a>
<a name="ln3043">	}</a>
<a name="ln3044">}</a>
<a name="ln3045"> </a>
<a name="ln3046"> </a>
<a name="ln3047">void</a>
<a name="ln3048">BView::DrawBitmapAsync(const BBitmap* bitmap, BPoint where)</a>
<a name="ln3049">{</a>
<a name="ln3050">	if (bitmap == NULL || fOwner == NULL)</a>
<a name="ln3051">		return;</a>
<a name="ln3052"> </a>
<a name="ln3053">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3054"> </a>
<a name="ln3055">	ViewDrawBitmapInfo info;</a>
<a name="ln3056">	info.bitmapToken = bitmap-&gt;_ServerToken();</a>
<a name="ln3057">	info.options = 0;</a>
<a name="ln3058">	info.bitmapRect = bitmap-&gt;Bounds().OffsetToCopy(B_ORIGIN);</a>
<a name="ln3059">	info.viewRect = info.bitmapRect.OffsetToCopy(where);</a>
<a name="ln3060"> </a>
<a name="ln3061">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_DRAW_BITMAP);</a>
<a name="ln3062">	fOwner-&gt;fLink-&gt;Attach&lt;ViewDrawBitmapInfo&gt;(info);</a>
<a name="ln3063"> </a>
<a name="ln3064">	_FlushIfNotInTransaction();</a>
<a name="ln3065">}</a>
<a name="ln3066"> </a>
<a name="ln3067"> </a>
<a name="ln3068">void</a>
<a name="ln3069">BView::DrawBitmapAsync(const BBitmap* bitmap)</a>
<a name="ln3070">{</a>
<a name="ln3071">	DrawBitmapAsync(bitmap, PenLocation());</a>
<a name="ln3072">}</a>
<a name="ln3073"> </a>
<a name="ln3074"> </a>
<a name="ln3075">void</a>
<a name="ln3076">BView::DrawBitmap(const BBitmap* bitmap, BRect bitmapRect, BRect viewRect,</a>
<a name="ln3077">	uint32 options)</a>
<a name="ln3078">{</a>
<a name="ln3079">	if (fOwner) {</a>
<a name="ln3080">		DrawBitmapAsync(bitmap, bitmapRect, viewRect, options);</a>
<a name="ln3081">		Sync();</a>
<a name="ln3082">	}</a>
<a name="ln3083">}</a>
<a name="ln3084"> </a>
<a name="ln3085"> </a>
<a name="ln3086">void</a>
<a name="ln3087">BView::DrawBitmap(const BBitmap* bitmap, BRect bitmapRect, BRect viewRect)</a>
<a name="ln3088">{</a>
<a name="ln3089">	if (fOwner) {</a>
<a name="ln3090">		DrawBitmapAsync(bitmap, bitmapRect, viewRect, 0);</a>
<a name="ln3091">		Sync();</a>
<a name="ln3092">	}</a>
<a name="ln3093">}</a>
<a name="ln3094"> </a>
<a name="ln3095"> </a>
<a name="ln3096">void</a>
<a name="ln3097">BView::DrawBitmap(const BBitmap* bitmap, BRect viewRect)</a>
<a name="ln3098">{</a>
<a name="ln3099">	if (bitmap &amp;&amp; fOwner) {</a>
<a name="ln3100">		DrawBitmap(bitmap, bitmap-&gt;Bounds().OffsetToCopy(B_ORIGIN), viewRect,</a>
<a name="ln3101">			0);</a>
<a name="ln3102">	}</a>
<a name="ln3103">}</a>
<a name="ln3104"> </a>
<a name="ln3105"> </a>
<a name="ln3106">void</a>
<a name="ln3107">BView::DrawBitmap(const BBitmap* bitmap, BPoint where)</a>
<a name="ln3108">{</a>
<a name="ln3109">	if (fOwner) {</a>
<a name="ln3110">		DrawBitmapAsync(bitmap, where);</a>
<a name="ln3111">		Sync();</a>
<a name="ln3112">	}</a>
<a name="ln3113">}</a>
<a name="ln3114"> </a>
<a name="ln3115"> </a>
<a name="ln3116">void</a>
<a name="ln3117">BView::DrawBitmap(const BBitmap* bitmap)</a>
<a name="ln3118">{</a>
<a name="ln3119">	DrawBitmap(bitmap, PenLocation());</a>
<a name="ln3120">}</a>
<a name="ln3121"> </a>
<a name="ln3122"> </a>
<a name="ln3123">void</a>
<a name="ln3124">BView::DrawChar(char c)</a>
<a name="ln3125">{</a>
<a name="ln3126">	DrawString(&amp;c, 1, PenLocation());</a>
<a name="ln3127">}</a>
<a name="ln3128"> </a>
<a name="ln3129"> </a>
<a name="ln3130">void</a>
<a name="ln3131">BView::DrawChar(char c, BPoint location)</a>
<a name="ln3132">{</a>
<a name="ln3133">	DrawString(&amp;c, 1, location);</a>
<a name="ln3134">}</a>
<a name="ln3135"> </a>
<a name="ln3136"> </a>
<a name="ln3137">void</a>
<a name="ln3138">BView::DrawString(const char* string, escapement_delta* delta)</a>
<a name="ln3139">{</a>
<a name="ln3140">	if (string == NULL)</a>
<a name="ln3141">		return;</a>
<a name="ln3142"> </a>
<a name="ln3143">	DrawString(string, strlen(string), PenLocation(), delta);</a>
<a name="ln3144">}</a>
<a name="ln3145"> </a>
<a name="ln3146"> </a>
<a name="ln3147">void</a>
<a name="ln3148">BView::DrawString(const char* string, BPoint location, escapement_delta* delta)</a>
<a name="ln3149">{</a>
<a name="ln3150">	if (string == NULL)</a>
<a name="ln3151">		return;</a>
<a name="ln3152"> </a>
<a name="ln3153">	DrawString(string, strlen(string), location, delta);</a>
<a name="ln3154">}</a>
<a name="ln3155"> </a>
<a name="ln3156"> </a>
<a name="ln3157">void</a>
<a name="ln3158">BView::DrawString(const char* string, int32 length, escapement_delta* delta)</a>
<a name="ln3159">{</a>
<a name="ln3160">	DrawString(string, length, PenLocation(), delta);</a>
<a name="ln3161">}</a>
<a name="ln3162"> </a>
<a name="ln3163"> </a>
<a name="ln3164">void</a>
<a name="ln3165">BView::DrawString(const char* string, int32 length, BPoint location,</a>
<a name="ln3166">	escapement_delta* delta)</a>
<a name="ln3167">{</a>
<a name="ln3168">	if (fOwner == NULL || string == NULL || length &lt; 1)</a>
<a name="ln3169">		return;</a>
<a name="ln3170"> </a>
<a name="ln3171">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3172"> </a>
<a name="ln3173">	ViewDrawStringInfo info;</a>
<a name="ln3174">	info.stringLength = length;</a>
<a name="ln3175">	info.location = location;</a>
<a name="ln3176">	if (delta != NULL)</a>
<a name="ln3177">		info.delta = *delta;</a>
<a name="ln3178"> </a>
<a name="ln3179">	// quite often delta will be NULL</a>
<a name="ln3180">	if (delta)</a>
<a name="ln3181">		fOwner-&gt;fLink-&gt;StartMessage(AS_DRAW_STRING_WITH_DELTA);</a>
<a name="ln3182">	else</a>
<a name="ln3183">		fOwner-&gt;fLink-&gt;StartMessage(AS_DRAW_STRING);</a>
<a name="ln3184"> </a>
<a name="ln3185">	fOwner-&gt;fLink-&gt;Attach&lt;ViewDrawStringInfo&gt;(info);</a>
<a name="ln3186">	fOwner-&gt;fLink-&gt;Attach(string, length);</a>
<a name="ln3187"> </a>
<a name="ln3188">	_FlushIfNotInTransaction();</a>
<a name="ln3189"> </a>
<a name="ln3190">	// this modifies our pen location, so we invalidate the flag.</a>
<a name="ln3191">	fState-&gt;valid_flags &amp;= ~B_VIEW_PEN_LOCATION_BIT;</a>
<a name="ln3192">}</a>
<a name="ln3193"> </a>
<a name="ln3194"> </a>
<a name="ln3195">void</a>
<a name="ln3196">BView::DrawString(const char* string, const BPoint* locations,</a>
<a name="ln3197">	int32 locationCount)</a>
<a name="ln3198">{</a>
<a name="ln3199">	if (string == NULL)</a>
<a name="ln3200">		return;</a>
<a name="ln3201"> </a>
<a name="ln3202">	DrawString(string, strlen(string), locations, locationCount);</a>
<a name="ln3203">}</a>
<a name="ln3204"> </a>
<a name="ln3205"> </a>
<a name="ln3206">void</a>
<a name="ln3207">BView::DrawString(const char* string, int32 length, const BPoint* locations,</a>
<a name="ln3208">	int32 locationCount)</a>
<a name="ln3209">{</a>
<a name="ln3210">	if (fOwner == NULL || string == NULL || length &lt; 1 || locations == NULL)</a>
<a name="ln3211">		return;</a>
<a name="ln3212"> </a>
<a name="ln3213">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3214"> </a>
<a name="ln3215">	fOwner-&gt;fLink-&gt;StartMessage(AS_DRAW_STRING_WITH_OFFSETS);</a>
<a name="ln3216"> </a>
<a name="ln3217">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(length);</a>
<a name="ln3218">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(locationCount);</a>
<a name="ln3219">	fOwner-&gt;fLink-&gt;Attach(string, length);</a>
<a name="ln3220">	fOwner-&gt;fLink-&gt;Attach(locations, locationCount * sizeof(BPoint));</a>
<a name="ln3221"> </a>
<a name="ln3222">	_FlushIfNotInTransaction();</a>
<a name="ln3223"> </a>
<a name="ln3224">	// this modifies our pen location, so we invalidate the flag.</a>
<a name="ln3225">	fState-&gt;valid_flags &amp;= ~B_VIEW_PEN_LOCATION_BIT;</a>
<a name="ln3226">}</a>
<a name="ln3227"> </a>
<a name="ln3228"> </a>
<a name="ln3229">void</a>
<a name="ln3230">BView::StrokeEllipse(BPoint center, float xRadius, float yRadius,</a>
<a name="ln3231">	::pattern pattern)</a>
<a name="ln3232">{</a>
<a name="ln3233">	StrokeEllipse(BRect(center.x - xRadius, center.y - yRadius,</a>
<a name="ln3234">		center.x + xRadius, center.y + yRadius), pattern);</a>
<a name="ln3235">}</a>
<a name="ln3236"> </a>
<a name="ln3237"> </a>
<a name="ln3238">void</a>
<a name="ln3239">BView::StrokeEllipse(BRect rect, ::pattern pattern)</a>
<a name="ln3240">{</a>
<a name="ln3241">	if (fOwner == NULL)</a>
<a name="ln3242">		return;</a>
<a name="ln3243"> </a>
<a name="ln3244">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3245">	_UpdatePattern(pattern);</a>
<a name="ln3246"> </a>
<a name="ln3247">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_ELLIPSE);</a>
<a name="ln3248">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3249"> </a>
<a name="ln3250">	_FlushIfNotInTransaction();</a>
<a name="ln3251">}</a>
<a name="ln3252"> </a>
<a name="ln3253"> </a>
<a name="ln3254">void</a>
<a name="ln3255">BView::FillEllipse(BPoint center, float xRadius, float yRadius,</a>
<a name="ln3256">	::pattern pattern)</a>
<a name="ln3257">{</a>
<a name="ln3258">	FillEllipse(BRect(center.x - xRadius, center.y - yRadius,</a>
<a name="ln3259">		center.x + xRadius, center.y + yRadius), pattern);</a>
<a name="ln3260">}</a>
<a name="ln3261"> </a>
<a name="ln3262"> </a>
<a name="ln3263">void</a>
<a name="ln3264">BView::FillEllipse(BPoint center, float xRadius, float yRadius,</a>
<a name="ln3265">	const BGradient&amp; gradient)</a>
<a name="ln3266">{</a>
<a name="ln3267">	FillEllipse(BRect(center.x - xRadius, center.y - yRadius,</a>
<a name="ln3268">		center.x + xRadius, center.y + yRadius), gradient);</a>
<a name="ln3269">}</a>
<a name="ln3270"> </a>
<a name="ln3271"> </a>
<a name="ln3272">void</a>
<a name="ln3273">BView::FillEllipse(BRect rect, ::pattern pattern)</a>
<a name="ln3274">{</a>
<a name="ln3275">	if (fOwner == NULL)</a>
<a name="ln3276">		return;</a>
<a name="ln3277"> </a>
<a name="ln3278">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3279">	_UpdatePattern(pattern);</a>
<a name="ln3280"> </a>
<a name="ln3281">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_ELLIPSE);</a>
<a name="ln3282">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3283"> </a>
<a name="ln3284">	_FlushIfNotInTransaction();</a>
<a name="ln3285">}</a>
<a name="ln3286"> </a>
<a name="ln3287"> </a>
<a name="ln3288">void</a>
<a name="ln3289">BView::FillEllipse(BRect rect, const BGradient&amp; gradient)</a>
<a name="ln3290">{</a>
<a name="ln3291">	if (fOwner == NULL)</a>
<a name="ln3292">		return;</a>
<a name="ln3293"> </a>
<a name="ln3294">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3295"> </a>
<a name="ln3296">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_ELLIPSE_GRADIENT);</a>
<a name="ln3297">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3298">	fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln3299"> </a>
<a name="ln3300">	_FlushIfNotInTransaction();</a>
<a name="ln3301">}</a>
<a name="ln3302"> </a>
<a name="ln3303"> </a>
<a name="ln3304">void</a>
<a name="ln3305">BView::StrokeArc(BPoint center, float xRadius, float yRadius, float startAngle,</a>
<a name="ln3306">	float arcAngle, ::pattern pattern)</a>
<a name="ln3307">{</a>
<a name="ln3308">	StrokeArc(BRect(center.x - xRadius, center.y - yRadius, center.x + xRadius,</a>
<a name="ln3309">		center.y + yRadius), startAngle, arcAngle, pattern);</a>
<a name="ln3310">}</a>
<a name="ln3311"> </a>
<a name="ln3312"> </a>
<a name="ln3313">void</a>
<a name="ln3314">BView::StrokeArc(BRect rect, float startAngle, float arcAngle,</a>
<a name="ln3315">	::pattern pattern)</a>
<a name="ln3316">{</a>
<a name="ln3317">	if (fOwner == NULL)</a>
<a name="ln3318">		return;</a>
<a name="ln3319"> </a>
<a name="ln3320">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3321">	_UpdatePattern(pattern);</a>
<a name="ln3322"> </a>
<a name="ln3323">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_ARC);</a>
<a name="ln3324">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3325">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(startAngle);</a>
<a name="ln3326">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(arcAngle);</a>
<a name="ln3327"> </a>
<a name="ln3328">	_FlushIfNotInTransaction();</a>
<a name="ln3329">}</a>
<a name="ln3330"> </a>
<a name="ln3331"> </a>
<a name="ln3332">void</a>
<a name="ln3333">BView::FillArc(BPoint center,float xRadius, float yRadius, float startAngle,</a>
<a name="ln3334">	float arcAngle, ::pattern pattern)</a>
<a name="ln3335">{</a>
<a name="ln3336">	FillArc(BRect(center.x - xRadius, center.y - yRadius, center.x + xRadius,</a>
<a name="ln3337">		center.y + yRadius), startAngle, arcAngle, pattern);</a>
<a name="ln3338">}</a>
<a name="ln3339"> </a>
<a name="ln3340"> </a>
<a name="ln3341">void</a>
<a name="ln3342">BView::FillArc(BPoint center,float xRadius, float yRadius, float startAngle,</a>
<a name="ln3343">	float arcAngle, const BGradient&amp; gradient)</a>
<a name="ln3344">{</a>
<a name="ln3345">	FillArc(BRect(center.x - xRadius, center.y - yRadius, center.x + xRadius,</a>
<a name="ln3346">		center.y + yRadius), startAngle, arcAngle, gradient);</a>
<a name="ln3347">}</a>
<a name="ln3348"> </a>
<a name="ln3349"> </a>
<a name="ln3350">void</a>
<a name="ln3351">BView::FillArc(BRect rect, float startAngle, float arcAngle,</a>
<a name="ln3352">	::pattern pattern)</a>
<a name="ln3353">{</a>
<a name="ln3354">	if (fOwner == NULL)</a>
<a name="ln3355">		return;</a>
<a name="ln3356"> </a>
<a name="ln3357">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3358">	_UpdatePattern(pattern);</a>
<a name="ln3359"> </a>
<a name="ln3360">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_ARC);</a>
<a name="ln3361">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3362">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(startAngle);</a>
<a name="ln3363">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(arcAngle);</a>
<a name="ln3364"> </a>
<a name="ln3365">	_FlushIfNotInTransaction();</a>
<a name="ln3366">}</a>
<a name="ln3367"> </a>
<a name="ln3368"> </a>
<a name="ln3369">void</a>
<a name="ln3370">BView::FillArc(BRect rect, float startAngle, float arcAngle,</a>
<a name="ln3371">	const BGradient&amp; gradient)</a>
<a name="ln3372">{</a>
<a name="ln3373">	if (fOwner == NULL)</a>
<a name="ln3374">		return;</a>
<a name="ln3375"> </a>
<a name="ln3376">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3377"> </a>
<a name="ln3378">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_ARC_GRADIENT);</a>
<a name="ln3379">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3380">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(startAngle);</a>
<a name="ln3381">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(arcAngle);</a>
<a name="ln3382">	fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln3383"> </a>
<a name="ln3384">	_FlushIfNotInTransaction();</a>
<a name="ln3385">}</a>
<a name="ln3386"> </a>
<a name="ln3387"> </a>
<a name="ln3388">void</a>
<a name="ln3389">BView::StrokeBezier(BPoint* controlPoints, ::pattern pattern)</a>
<a name="ln3390">{</a>
<a name="ln3391">	if (fOwner == NULL)</a>
<a name="ln3392">		return;</a>
<a name="ln3393"> </a>
<a name="ln3394">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3395">	_UpdatePattern(pattern);</a>
<a name="ln3396"> </a>
<a name="ln3397">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_BEZIER);</a>
<a name="ln3398">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[0]);</a>
<a name="ln3399">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[1]);</a>
<a name="ln3400">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[2]);</a>
<a name="ln3401">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[3]);</a>
<a name="ln3402"> </a>
<a name="ln3403">	_FlushIfNotInTransaction();</a>
<a name="ln3404">}</a>
<a name="ln3405"> </a>
<a name="ln3406"> </a>
<a name="ln3407">void</a>
<a name="ln3408">BView::FillBezier(BPoint* controlPoints, ::pattern pattern)</a>
<a name="ln3409">{</a>
<a name="ln3410">	if (fOwner == NULL)</a>
<a name="ln3411">		return;</a>
<a name="ln3412"> </a>
<a name="ln3413">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3414">	_UpdatePattern(pattern);</a>
<a name="ln3415"> </a>
<a name="ln3416">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_BEZIER);</a>
<a name="ln3417">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[0]);</a>
<a name="ln3418">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[1]);</a>
<a name="ln3419">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[2]);</a>
<a name="ln3420">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[3]);</a>
<a name="ln3421"> </a>
<a name="ln3422">	_FlushIfNotInTransaction();</a>
<a name="ln3423">}</a>
<a name="ln3424"> </a>
<a name="ln3425"> </a>
<a name="ln3426">void</a>
<a name="ln3427">BView::FillBezier(BPoint* controlPoints, const BGradient&amp; gradient)</a>
<a name="ln3428">{</a>
<a name="ln3429">	if (fOwner == NULL)</a>
<a name="ln3430">		return;</a>
<a name="ln3431"> </a>
<a name="ln3432">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3433"> </a>
<a name="ln3434">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_BEZIER_GRADIENT);</a>
<a name="ln3435">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[0]);</a>
<a name="ln3436">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[1]);</a>
<a name="ln3437">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[2]);</a>
<a name="ln3438">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(controlPoints[3]);</a>
<a name="ln3439">	fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln3440"> </a>
<a name="ln3441">	_FlushIfNotInTransaction();</a>
<a name="ln3442">}</a>
<a name="ln3443"> </a>
<a name="ln3444"> </a>
<a name="ln3445">void</a>
<a name="ln3446">BView::StrokePolygon(const BPolygon* polygon, bool closed, ::pattern pattern)</a>
<a name="ln3447">{</a>
<a name="ln3448">	if (polygon == NULL)</a>
<a name="ln3449">		return;</a>
<a name="ln3450"> </a>
<a name="ln3451">	StrokePolygon(polygon-&gt;fPoints, polygon-&gt;fCount, polygon-&gt;Frame(), closed,</a>
<a name="ln3452">		pattern);</a>
<a name="ln3453">}</a>
<a name="ln3454"> </a>
<a name="ln3455"> </a>
<a name="ln3456">void</a>
<a name="ln3457">BView::StrokePolygon(const BPoint* pointArray, int32 numPoints, bool closed,</a>
<a name="ln3458">	::pattern pattern)</a>
<a name="ln3459">{</a>
<a name="ln3460">	BPolygon polygon(pointArray, numPoints);</a>
<a name="ln3461"> </a>
<a name="ln3462">	StrokePolygon(polygon.fPoints, polygon.fCount, polygon.Frame(), closed,</a>
<a name="ln3463">		pattern);</a>
<a name="ln3464">}</a>
<a name="ln3465"> </a>
<a name="ln3466"> </a>
<a name="ln3467">void</a>
<a name="ln3468">BView::StrokePolygon(const BPoint* pointArray, int32 numPoints, BRect bounds,</a>
<a name="ln3469">	bool closed, ::pattern pattern)</a>
<a name="ln3470">{</a>
<a name="ln3471">	if (pointArray == NULL</a>
<a name="ln3472">		|| numPoints &lt;= 1</a>
<a name="ln3473">		|| fOwner == NULL)</a>
<a name="ln3474">		return;</a>
<a name="ln3475"> </a>
<a name="ln3476">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3477">	_UpdatePattern(pattern);</a>
<a name="ln3478"> </a>
<a name="ln3479">	BPolygon polygon(pointArray, numPoints);</a>
<a name="ln3480">	polygon.MapTo(polygon.Frame(), bounds);</a>
<a name="ln3481"> </a>
<a name="ln3482">	if (fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_POLYGON,</a>
<a name="ln3483">			polygon.fCount * sizeof(BPoint) + sizeof(BRect) + sizeof(bool)</a>
<a name="ln3484">				+ sizeof(int32)) == B_OK) {</a>
<a name="ln3485">		fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(polygon.Frame());</a>
<a name="ln3486">		fOwner-&gt;fLink-&gt;Attach&lt;bool&gt;(closed);</a>
<a name="ln3487">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(polygon.fCount);</a>
<a name="ln3488">		fOwner-&gt;fLink-&gt;Attach(polygon.fPoints, polygon.fCount * sizeof(BPoint));</a>
<a name="ln3489"> </a>
<a name="ln3490">		_FlushIfNotInTransaction();</a>
<a name="ln3491">	} else {</a>
<a name="ln3492">		fprintf(stderr, &quot;ERROR: Can't send polygon to app_server!\n&quot;);</a>
<a name="ln3493">	}</a>
<a name="ln3494">}</a>
<a name="ln3495"> </a>
<a name="ln3496"> </a>
<a name="ln3497">void</a>
<a name="ln3498">BView::FillPolygon(const BPolygon* polygon, ::pattern pattern)</a>
<a name="ln3499">{</a>
<a name="ln3500">	if (polygon == NULL</a>
<a name="ln3501">		|| polygon-&gt;fCount &lt;= 2</a>
<a name="ln3502">		|| fOwner == NULL)</a>
<a name="ln3503">		return;</a>
<a name="ln3504"> </a>
<a name="ln3505">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3506">	_UpdatePattern(pattern);</a>
<a name="ln3507"> </a>
<a name="ln3508">	if (fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_POLYGON,</a>
<a name="ln3509">			polygon-&gt;fCount * sizeof(BPoint) + sizeof(BRect) + sizeof(int32))</a>
<a name="ln3510">				== B_OK) {</a>
<a name="ln3511">		fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(polygon-&gt;Frame());</a>
<a name="ln3512">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(polygon-&gt;fCount);</a>
<a name="ln3513">		fOwner-&gt;fLink-&gt;Attach(polygon-&gt;fPoints,</a>
<a name="ln3514">			polygon-&gt;fCount * sizeof(BPoint));</a>
<a name="ln3515"> </a>
<a name="ln3516">		_FlushIfNotInTransaction();</a>
<a name="ln3517">	} else {</a>
<a name="ln3518">		fprintf(stderr, &quot;ERROR: Can't send polygon to app_server!\n&quot;);</a>
<a name="ln3519">	}</a>
<a name="ln3520">}</a>
<a name="ln3521"> </a>
<a name="ln3522"> </a>
<a name="ln3523">void</a>
<a name="ln3524">BView::FillPolygon(const BPolygon* polygon, const BGradient&amp; gradient)</a>
<a name="ln3525">{</a>
<a name="ln3526">	if (polygon == NULL</a>
<a name="ln3527">		|| polygon-&gt;fCount &lt;= 2</a>
<a name="ln3528">		|| fOwner == NULL)</a>
<a name="ln3529">		return;</a>
<a name="ln3530"> </a>
<a name="ln3531">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3532"> </a>
<a name="ln3533">	if (fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_POLYGON_GRADIENT,</a>
<a name="ln3534">			polygon-&gt;fCount * sizeof(BPoint) + sizeof(BRect) + sizeof(int32))</a>
<a name="ln3535">				== B_OK) {</a>
<a name="ln3536">		fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(polygon-&gt;Frame());</a>
<a name="ln3537">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(polygon-&gt;fCount);</a>
<a name="ln3538">		fOwner-&gt;fLink-&gt;Attach(polygon-&gt;fPoints,</a>
<a name="ln3539">			polygon-&gt;fCount * sizeof(BPoint));</a>
<a name="ln3540">		fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln3541"> </a>
<a name="ln3542">		_FlushIfNotInTransaction();</a>
<a name="ln3543">	} else {</a>
<a name="ln3544">		fprintf(stderr, &quot;ERROR: Can't send polygon to app_server!\n&quot;);</a>
<a name="ln3545">	}</a>
<a name="ln3546">}</a>
<a name="ln3547"> </a>
<a name="ln3548"> </a>
<a name="ln3549">void</a>
<a name="ln3550">BView::FillPolygon(const BPoint* pointArray, int32 numPoints, ::pattern pattern)</a>
<a name="ln3551">{</a>
<a name="ln3552">	if (pointArray == NULL)</a>
<a name="ln3553">		return;</a>
<a name="ln3554"> </a>
<a name="ln3555">	BPolygon polygon(pointArray, numPoints);</a>
<a name="ln3556">	FillPolygon(&amp;polygon, pattern);</a>
<a name="ln3557">}</a>
<a name="ln3558"> </a>
<a name="ln3559"> </a>
<a name="ln3560">void</a>
<a name="ln3561">BView::FillPolygon(const BPoint* pointArray, int32 numPoints,</a>
<a name="ln3562">	const BGradient&amp; gradient)</a>
<a name="ln3563">{</a>
<a name="ln3564">	if (pointArray == NULL)</a>
<a name="ln3565">		return;</a>
<a name="ln3566"> </a>
<a name="ln3567">	BPolygon polygon(pointArray, numPoints);</a>
<a name="ln3568">	FillPolygon(&amp;polygon, gradient);</a>
<a name="ln3569">}</a>
<a name="ln3570"> </a>
<a name="ln3571"> </a>
<a name="ln3572">void</a>
<a name="ln3573">BView::FillPolygon(const BPoint* pointArray, int32 numPoints, BRect bounds,</a>
<a name="ln3574">	::pattern pattern)</a>
<a name="ln3575">{</a>
<a name="ln3576">	if (pointArray == NULL)</a>
<a name="ln3577">		return;</a>
<a name="ln3578"> </a>
<a name="ln3579">	BPolygon polygon(pointArray, numPoints);</a>
<a name="ln3580"> </a>
<a name="ln3581">	polygon.MapTo(polygon.Frame(), bounds);</a>
<a name="ln3582">	FillPolygon(&amp;polygon, pattern);</a>
<a name="ln3583">}</a>
<a name="ln3584"> </a>
<a name="ln3585"> </a>
<a name="ln3586">void</a>
<a name="ln3587">BView::FillPolygon(const BPoint* pointArray, int32 numPoints, BRect bounds,</a>
<a name="ln3588">	const BGradient&amp; gradient)</a>
<a name="ln3589">{</a>
<a name="ln3590">	if (pointArray == NULL)</a>
<a name="ln3591">		return;</a>
<a name="ln3592"> </a>
<a name="ln3593">	BPolygon polygon(pointArray, numPoints);</a>
<a name="ln3594"> </a>
<a name="ln3595">	polygon.MapTo(polygon.Frame(), bounds);</a>
<a name="ln3596">	FillPolygon(&amp;polygon, gradient);</a>
<a name="ln3597">}</a>
<a name="ln3598"> </a>
<a name="ln3599"> </a>
<a name="ln3600">void</a>
<a name="ln3601">BView::StrokeRect(BRect rect, ::pattern pattern)</a>
<a name="ln3602">{</a>
<a name="ln3603">	if (fOwner == NULL)</a>
<a name="ln3604">		return;</a>
<a name="ln3605"> </a>
<a name="ln3606">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3607">	_UpdatePattern(pattern);</a>
<a name="ln3608"> </a>
<a name="ln3609">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_RECT);</a>
<a name="ln3610">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3611"> </a>
<a name="ln3612">	_FlushIfNotInTransaction();</a>
<a name="ln3613">}</a>
<a name="ln3614"> </a>
<a name="ln3615"> </a>
<a name="ln3616">void</a>
<a name="ln3617">BView::FillRect(BRect rect, ::pattern pattern)</a>
<a name="ln3618">{</a>
<a name="ln3619">	if (fOwner == NULL)</a>
<a name="ln3620">		return;</a>
<a name="ln3621"> </a>
<a name="ln3622">	// NOTE: ensuring compatibility with R5,</a>
<a name="ln3623">	// invalid rects are not filled, they are stroked though!</a>
<a name="ln3624">	if (!rect.IsValid())</a>
<a name="ln3625">		return;</a>
<a name="ln3626"> </a>
<a name="ln3627">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3628">	_UpdatePattern(pattern);</a>
<a name="ln3629"> </a>
<a name="ln3630">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_RECT);</a>
<a name="ln3631">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3632"> </a>
<a name="ln3633">	_FlushIfNotInTransaction();</a>
<a name="ln3634">}</a>
<a name="ln3635"> </a>
<a name="ln3636"> </a>
<a name="ln3637">void</a>
<a name="ln3638">BView::FillRect(BRect rect, const BGradient&amp; gradient)</a>
<a name="ln3639">{</a>
<a name="ln3640">	if (fOwner == NULL)</a>
<a name="ln3641">		return;</a>
<a name="ln3642"> </a>
<a name="ln3643">	// NOTE: ensuring compatibility with R5,</a>
<a name="ln3644">	// invalid rects are not filled, they are stroked though!</a>
<a name="ln3645">	if (!rect.IsValid())</a>
<a name="ln3646">		return;</a>
<a name="ln3647"> </a>
<a name="ln3648">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3649"> </a>
<a name="ln3650">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_RECT_GRADIENT);</a>
<a name="ln3651">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3652">	fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln3653"> </a>
<a name="ln3654">	_FlushIfNotInTransaction();</a>
<a name="ln3655">}</a>
<a name="ln3656"> </a>
<a name="ln3657"> </a>
<a name="ln3658">void</a>
<a name="ln3659">BView::StrokeRoundRect(BRect rect, float xRadius, float yRadius,</a>
<a name="ln3660">	::pattern pattern)</a>
<a name="ln3661">{</a>
<a name="ln3662">	if (fOwner == NULL)</a>
<a name="ln3663">		return;</a>
<a name="ln3664"> </a>
<a name="ln3665">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3666">	_UpdatePattern(pattern);</a>
<a name="ln3667"> </a>
<a name="ln3668">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_ROUNDRECT);</a>
<a name="ln3669">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3670">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(xRadius);</a>
<a name="ln3671">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(yRadius);</a>
<a name="ln3672"> </a>
<a name="ln3673">	_FlushIfNotInTransaction();</a>
<a name="ln3674">}</a>
<a name="ln3675"> </a>
<a name="ln3676"> </a>
<a name="ln3677">void</a>
<a name="ln3678">BView::FillRoundRect(BRect rect, float xRadius, float yRadius,</a>
<a name="ln3679">	::pattern pattern)</a>
<a name="ln3680">{</a>
<a name="ln3681">	if (fOwner == NULL)</a>
<a name="ln3682">		return;</a>
<a name="ln3683"> </a>
<a name="ln3684">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3685"> </a>
<a name="ln3686">	_UpdatePattern(pattern);</a>
<a name="ln3687"> </a>
<a name="ln3688">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_ROUNDRECT);</a>
<a name="ln3689">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3690">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(xRadius);</a>
<a name="ln3691">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(yRadius);</a>
<a name="ln3692"> </a>
<a name="ln3693">	_FlushIfNotInTransaction();</a>
<a name="ln3694">}</a>
<a name="ln3695"> </a>
<a name="ln3696"> </a>
<a name="ln3697">void</a>
<a name="ln3698">BView::FillRoundRect(BRect rect, float xRadius, float yRadius,</a>
<a name="ln3699">	const BGradient&amp; gradient)</a>
<a name="ln3700">{</a>
<a name="ln3701">	if (fOwner == NULL)</a>
<a name="ln3702">		return;</a>
<a name="ln3703"> </a>
<a name="ln3704">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3705"> </a>
<a name="ln3706">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_ROUNDRECT_GRADIENT);</a>
<a name="ln3707">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln3708">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(xRadius);</a>
<a name="ln3709">	fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(yRadius);</a>
<a name="ln3710">	fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln3711"> </a>
<a name="ln3712">	_FlushIfNotInTransaction();</a>
<a name="ln3713">}</a>
<a name="ln3714"> </a>
<a name="ln3715"> </a>
<a name="ln3716">void</a>
<a name="ln3717">BView::FillRegion(BRegion* region, ::pattern pattern)</a>
<a name="ln3718">{</a>
<a name="ln3719">	if (region == NULL || fOwner == NULL)</a>
<a name="ln3720">		return;</a>
<a name="ln3721"> </a>
<a name="ln3722">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3723"> </a>
<a name="ln3724">	_UpdatePattern(pattern);</a>
<a name="ln3725"> </a>
<a name="ln3726">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_REGION);</a>
<a name="ln3727">	fOwner-&gt;fLink-&gt;AttachRegion(*region);</a>
<a name="ln3728"> </a>
<a name="ln3729">	_FlushIfNotInTransaction();</a>
<a name="ln3730">}</a>
<a name="ln3731"> </a>
<a name="ln3732"> </a>
<a name="ln3733">void</a>
<a name="ln3734">BView::FillRegion(BRegion* region, const BGradient&amp; gradient)</a>
<a name="ln3735">{</a>
<a name="ln3736">	if (region == NULL || fOwner == NULL)</a>
<a name="ln3737">		return;</a>
<a name="ln3738"> </a>
<a name="ln3739">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3740"> </a>
<a name="ln3741">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_REGION_GRADIENT);</a>
<a name="ln3742">	fOwner-&gt;fLink-&gt;AttachRegion(*region);</a>
<a name="ln3743">	fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln3744"> </a>
<a name="ln3745">	_FlushIfNotInTransaction();</a>
<a name="ln3746">}</a>
<a name="ln3747"> </a>
<a name="ln3748"> </a>
<a name="ln3749">void</a>
<a name="ln3750">BView::StrokeTriangle(BPoint point1, BPoint point2, BPoint point3, BRect bounds,</a>
<a name="ln3751">	::pattern pattern)</a>
<a name="ln3752">{</a>
<a name="ln3753">	if (fOwner == NULL)</a>
<a name="ln3754">		return;</a>
<a name="ln3755"> </a>
<a name="ln3756">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3757"> </a>
<a name="ln3758">	_UpdatePattern(pattern);</a>
<a name="ln3759"> </a>
<a name="ln3760">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_TRIANGLE);</a>
<a name="ln3761">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point1);</a>
<a name="ln3762">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point2);</a>
<a name="ln3763">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point3);</a>
<a name="ln3764">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(bounds);</a>
<a name="ln3765"> </a>
<a name="ln3766">	_FlushIfNotInTransaction();</a>
<a name="ln3767">}</a>
<a name="ln3768"> </a>
<a name="ln3769"> </a>
<a name="ln3770">void</a>
<a name="ln3771">BView::StrokeTriangle(BPoint point1, BPoint point2, BPoint point3,</a>
<a name="ln3772">	::pattern pattern)</a>
<a name="ln3773">{</a>
<a name="ln3774">	if (fOwner) {</a>
<a name="ln3775">		// we construct the smallest rectangle that contains the 3 points</a>
<a name="ln3776">		// for the 1st point</a>
<a name="ln3777">		BRect bounds(point1, point1);</a>
<a name="ln3778"> </a>
<a name="ln3779">		// for the 2nd point</a>
<a name="ln3780">		if (point2.x &lt; bounds.left)</a>
<a name="ln3781">			bounds.left = point2.x;</a>
<a name="ln3782"> </a>
<a name="ln3783">		if (point2.y &lt; bounds.top)</a>
<a name="ln3784">			bounds.top = point2.y;</a>
<a name="ln3785"> </a>
<a name="ln3786">		if (point2.x &gt; bounds.right)</a>
<a name="ln3787">			bounds.right = point2.x;</a>
<a name="ln3788"> </a>
<a name="ln3789">		if (point2.y &gt; bounds.bottom)</a>
<a name="ln3790">			bounds.bottom = point2.y;</a>
<a name="ln3791"> </a>
<a name="ln3792">		// for the 3rd point</a>
<a name="ln3793">		if (point3.x &lt; bounds.left)</a>
<a name="ln3794">			bounds.left = point3.x;</a>
<a name="ln3795"> </a>
<a name="ln3796">		if (point3.y &lt; bounds.top)</a>
<a name="ln3797">			bounds.top = point3.y;</a>
<a name="ln3798"> </a>
<a name="ln3799">		if (point3.x &gt; bounds.right)</a>
<a name="ln3800">			bounds.right = point3.x;</a>
<a name="ln3801"> </a>
<a name="ln3802">		if (point3.y &gt; bounds.bottom)</a>
<a name="ln3803">			bounds.bottom = point3.y;</a>
<a name="ln3804"> </a>
<a name="ln3805">		StrokeTriangle(point1, point2, point3, bounds, pattern);</a>
<a name="ln3806">	}</a>
<a name="ln3807">}</a>
<a name="ln3808"> </a>
<a name="ln3809"> </a>
<a name="ln3810">void</a>
<a name="ln3811">BView::FillTriangle(BPoint point1, BPoint point2, BPoint point3,</a>
<a name="ln3812">	::pattern pattern)</a>
<a name="ln3813">{</a>
<a name="ln3814">	if (fOwner) {</a>
<a name="ln3815">		// we construct the smallest rectangle that contains the 3 points</a>
<a name="ln3816">		// for the 1st point</a>
<a name="ln3817">		BRect bounds(point1, point1);</a>
<a name="ln3818"> </a>
<a name="ln3819">		// for the 2nd point</a>
<a name="ln3820">		if (point2.x &lt; bounds.left)</a>
<a name="ln3821">			bounds.left = point2.x;</a>
<a name="ln3822"> </a>
<a name="ln3823">		if (point2.y &lt; bounds.top)</a>
<a name="ln3824">			bounds.top = point2.y;</a>
<a name="ln3825"> </a>
<a name="ln3826">		if (point2.x &gt; bounds.right)</a>
<a name="ln3827">			bounds.right = point2.x;</a>
<a name="ln3828"> </a>
<a name="ln3829">		if (point2.y &gt; bounds.bottom)</a>
<a name="ln3830">			bounds.bottom = point2.y;</a>
<a name="ln3831"> </a>
<a name="ln3832">		// for the 3rd point</a>
<a name="ln3833">		if (point3.x &lt; bounds.left)</a>
<a name="ln3834">			bounds.left = point3.x;</a>
<a name="ln3835"> </a>
<a name="ln3836">		if (point3.y &lt; bounds.top)</a>
<a name="ln3837">			bounds.top = point3.y;</a>
<a name="ln3838"> </a>
<a name="ln3839">		if (point3.x &gt; bounds.right)</a>
<a name="ln3840">			bounds.right = point3.x;</a>
<a name="ln3841"> </a>
<a name="ln3842">		if (point3.y &gt; bounds.bottom)</a>
<a name="ln3843">			bounds.bottom = point3.y;</a>
<a name="ln3844"> </a>
<a name="ln3845">		FillTriangle(point1, point2, point3, bounds, pattern);</a>
<a name="ln3846">	}</a>
<a name="ln3847">}</a>
<a name="ln3848"> </a>
<a name="ln3849"> </a>
<a name="ln3850">void</a>
<a name="ln3851">BView::FillTriangle(BPoint point1, BPoint point2, BPoint point3,</a>
<a name="ln3852">	const BGradient&amp; gradient)</a>
<a name="ln3853">{</a>
<a name="ln3854">	if (fOwner) {</a>
<a name="ln3855">		// we construct the smallest rectangle that contains the 3 points</a>
<a name="ln3856">		// for the 1st point</a>
<a name="ln3857">		BRect bounds(point1, point1);</a>
<a name="ln3858"> </a>
<a name="ln3859">		// for the 2nd point</a>
<a name="ln3860">		if (point2.x &lt; bounds.left)</a>
<a name="ln3861">			bounds.left = point2.x;</a>
<a name="ln3862"> </a>
<a name="ln3863">		if (point2.y &lt; bounds.top)</a>
<a name="ln3864">			bounds.top = point2.y;</a>
<a name="ln3865"> </a>
<a name="ln3866">		if (point2.x &gt; bounds.right)</a>
<a name="ln3867">			bounds.right = point2.x;</a>
<a name="ln3868"> </a>
<a name="ln3869">		if (point2.y &gt; bounds.bottom)</a>
<a name="ln3870">			bounds.bottom = point2.y;</a>
<a name="ln3871"> </a>
<a name="ln3872">		// for the 3rd point</a>
<a name="ln3873">		if (point3.x &lt; bounds.left)</a>
<a name="ln3874">			bounds.left = point3.x;</a>
<a name="ln3875"> </a>
<a name="ln3876">		if (point3.y &lt; bounds.top)</a>
<a name="ln3877">			bounds.top = point3.y;</a>
<a name="ln3878"> </a>
<a name="ln3879">		if (point3.x &gt; bounds.right)</a>
<a name="ln3880">			bounds.right = point3.x;</a>
<a name="ln3881"> </a>
<a name="ln3882">		if (point3.y &gt; bounds.bottom)</a>
<a name="ln3883">			bounds.bottom = point3.y;</a>
<a name="ln3884"> </a>
<a name="ln3885">		FillTriangle(point1, point2, point3, bounds, gradient);</a>
<a name="ln3886">	}</a>
<a name="ln3887">}</a>
<a name="ln3888"> </a>
<a name="ln3889"> </a>
<a name="ln3890">void</a>
<a name="ln3891">BView::FillTriangle(BPoint point1, BPoint point2, BPoint point3,</a>
<a name="ln3892">	BRect bounds, ::pattern pattern)</a>
<a name="ln3893">{</a>
<a name="ln3894">	if (fOwner == NULL)</a>
<a name="ln3895">		return;</a>
<a name="ln3896"> </a>
<a name="ln3897">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3898">	_UpdatePattern(pattern);</a>
<a name="ln3899"> </a>
<a name="ln3900">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_TRIANGLE);</a>
<a name="ln3901">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point1);</a>
<a name="ln3902">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point2);</a>
<a name="ln3903">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point3);</a>
<a name="ln3904">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(bounds);</a>
<a name="ln3905"> </a>
<a name="ln3906">	_FlushIfNotInTransaction();</a>
<a name="ln3907">}</a>
<a name="ln3908"> </a>
<a name="ln3909"> </a>
<a name="ln3910">void</a>
<a name="ln3911">BView::FillTriangle(BPoint point1, BPoint point2, BPoint point3, BRect bounds,</a>
<a name="ln3912">	const BGradient&amp; gradient)</a>
<a name="ln3913">{</a>
<a name="ln3914">	if (fOwner == NULL)</a>
<a name="ln3915">		return;</a>
<a name="ln3916"> </a>
<a name="ln3917">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3918">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_TRIANGLE_GRADIENT);</a>
<a name="ln3919">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point1);</a>
<a name="ln3920">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point2);</a>
<a name="ln3921">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(point3);</a>
<a name="ln3922">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(bounds);</a>
<a name="ln3923">	fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln3924"> </a>
<a name="ln3925">	_FlushIfNotInTransaction();</a>
<a name="ln3926">}</a>
<a name="ln3927"> </a>
<a name="ln3928"> </a>
<a name="ln3929">void</a>
<a name="ln3930">BView::StrokeLine(BPoint toPoint, ::pattern pattern)</a>
<a name="ln3931">{</a>
<a name="ln3932">	StrokeLine(PenLocation(), toPoint, pattern);</a>
<a name="ln3933">}</a>
<a name="ln3934"> </a>
<a name="ln3935"> </a>
<a name="ln3936">void</a>
<a name="ln3937">BView::StrokeLine(BPoint start, BPoint end, ::pattern pattern)</a>
<a name="ln3938">{</a>
<a name="ln3939">	if (fOwner == NULL)</a>
<a name="ln3940">		return;</a>
<a name="ln3941"> </a>
<a name="ln3942">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3943">	_UpdatePattern(pattern);</a>
<a name="ln3944"> </a>
<a name="ln3945">	ViewStrokeLineInfo info;</a>
<a name="ln3946">	info.startPoint = start;</a>
<a name="ln3947">	info.endPoint = end;</a>
<a name="ln3948"> </a>
<a name="ln3949">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_LINE);</a>
<a name="ln3950">	fOwner-&gt;fLink-&gt;Attach&lt;ViewStrokeLineInfo&gt;(info);</a>
<a name="ln3951"> </a>
<a name="ln3952">	_FlushIfNotInTransaction();</a>
<a name="ln3953"> </a>
<a name="ln3954">	// this modifies our pen location, so we invalidate the flag.</a>
<a name="ln3955">	fState-&gt;valid_flags &amp;= ~B_VIEW_PEN_LOCATION_BIT;</a>
<a name="ln3956">}</a>
<a name="ln3957"> </a>
<a name="ln3958"> </a>
<a name="ln3959">void</a>
<a name="ln3960">BView::StrokeShape(BShape* shape, ::pattern pattern)</a>
<a name="ln3961">{</a>
<a name="ln3962">	if (shape == NULL || fOwner == NULL)</a>
<a name="ln3963">		return;</a>
<a name="ln3964"> </a>
<a name="ln3965">	shape_data* sd = (shape_data*)shape-&gt;fPrivateData;</a>
<a name="ln3966">	if (sd-&gt;opCount == 0 || sd-&gt;ptCount == 0)</a>
<a name="ln3967">		return;</a>
<a name="ln3968"> </a>
<a name="ln3969">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3970">	_UpdatePattern(pattern);</a>
<a name="ln3971"> </a>
<a name="ln3972">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_SHAPE);</a>
<a name="ln3973">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(shape-&gt;Bounds());</a>
<a name="ln3974">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(sd-&gt;opCount);</a>
<a name="ln3975">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(sd-&gt;ptCount);</a>
<a name="ln3976">	fOwner-&gt;fLink-&gt;Attach(sd-&gt;opList, sd-&gt;opCount * sizeof(uint32));</a>
<a name="ln3977">	fOwner-&gt;fLink-&gt;Attach(sd-&gt;ptList, sd-&gt;ptCount * sizeof(BPoint));</a>
<a name="ln3978"> </a>
<a name="ln3979">	_FlushIfNotInTransaction();</a>
<a name="ln3980">}</a>
<a name="ln3981"> </a>
<a name="ln3982"> </a>
<a name="ln3983">void</a>
<a name="ln3984">BView::FillShape(BShape* shape, ::pattern pattern)</a>
<a name="ln3985">{</a>
<a name="ln3986">	if (shape == NULL || fOwner == NULL)</a>
<a name="ln3987">		return;</a>
<a name="ln3988"> </a>
<a name="ln3989">	shape_data* sd = (shape_data*)(shape-&gt;fPrivateData);</a>
<a name="ln3990">	if (sd-&gt;opCount == 0 || sd-&gt;ptCount == 0)</a>
<a name="ln3991">		return;</a>
<a name="ln3992"> </a>
<a name="ln3993">	_CheckLockAndSwitchCurrent();</a>
<a name="ln3994">	_UpdatePattern(pattern);</a>
<a name="ln3995"> </a>
<a name="ln3996">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_SHAPE);</a>
<a name="ln3997">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(shape-&gt;Bounds());</a>
<a name="ln3998">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(sd-&gt;opCount);</a>
<a name="ln3999">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(sd-&gt;ptCount);</a>
<a name="ln4000">	fOwner-&gt;fLink-&gt;Attach(sd-&gt;opList, sd-&gt;opCount * sizeof(int32));</a>
<a name="ln4001">	fOwner-&gt;fLink-&gt;Attach(sd-&gt;ptList, sd-&gt;ptCount * sizeof(BPoint));</a>
<a name="ln4002"> </a>
<a name="ln4003">	_FlushIfNotInTransaction();</a>
<a name="ln4004">}</a>
<a name="ln4005"> </a>
<a name="ln4006"> </a>
<a name="ln4007">void</a>
<a name="ln4008">BView::FillShape(BShape* shape, const BGradient&amp; gradient)</a>
<a name="ln4009">{</a>
<a name="ln4010">	if (shape == NULL || fOwner == NULL)</a>
<a name="ln4011">		return;</a>
<a name="ln4012"> </a>
<a name="ln4013">	shape_data* sd = (shape_data*)(shape-&gt;fPrivateData);</a>
<a name="ln4014">	if (sd-&gt;opCount == 0 || sd-&gt;ptCount == 0)</a>
<a name="ln4015">		return;</a>
<a name="ln4016"> </a>
<a name="ln4017">	_CheckLockAndSwitchCurrent();</a>
<a name="ln4018"> </a>
<a name="ln4019">	fOwner-&gt;fLink-&gt;StartMessage(AS_FILL_SHAPE_GRADIENT);</a>
<a name="ln4020">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(shape-&gt;Bounds());</a>
<a name="ln4021">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(sd-&gt;opCount);</a>
<a name="ln4022">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(sd-&gt;ptCount);</a>
<a name="ln4023">	fOwner-&gt;fLink-&gt;Attach(sd-&gt;opList, sd-&gt;opCount * sizeof(int32));</a>
<a name="ln4024">	fOwner-&gt;fLink-&gt;Attach(sd-&gt;ptList, sd-&gt;ptCount * sizeof(BPoint));</a>
<a name="ln4025">	fOwner-&gt;fLink-&gt;AttachGradient(gradient);</a>
<a name="ln4026"> </a>
<a name="ln4027">	_FlushIfNotInTransaction();</a>
<a name="ln4028">}</a>
<a name="ln4029"> </a>
<a name="ln4030"> </a>
<a name="ln4031">void</a>
<a name="ln4032">BView::BeginLineArray(int32 count)</a>
<a name="ln4033">{</a>
<a name="ln4034">	if (fOwner == NULL)</a>
<a name="ln4035">		return;</a>
<a name="ln4036"> </a>
<a name="ln4037">	if (count &lt;= 0)</a>
<a name="ln4038">		debugger(&quot;Calling BeginLineArray with a count &lt;= 0&quot;);</a>
<a name="ln4039"> </a>
<a name="ln4040">	_CheckLock();</a>
<a name="ln4041"> </a>
<a name="ln4042">	if (fCommArray) {</a>
<a name="ln4043">		debugger(&quot;Can't nest BeginLineArray calls&quot;);</a>
<a name="ln4044">			// not fatal, but it helps during</a>
<a name="ln4045">			// development of your app and is in</a>
<a name="ln4046">			// line with R5...</a>
<a name="ln4047">		delete[] fCommArray-&gt;array;</a>
<a name="ln4048">		delete fCommArray;</a>
<a name="ln4049">	}</a>
<a name="ln4050"> </a>
<a name="ln4051">	// TODO: since this method cannot return failure, and further AddLine()</a>
<a name="ln4052">	//	calls with a NULL fCommArray would drop into the debugger anyway,</a>
<a name="ln4053">	//	we allow the possible std::bad_alloc exceptions here...</a>
<a name="ln4054">	fCommArray = new _array_data_;</a>
<a name="ln4055">	fCommArray-&gt;count = 0;</a>
<a name="ln4056"> </a>
<a name="ln4057">	// Make sure the fCommArray is initialized to reasonable values in cases of</a>
<a name="ln4058">	// bad_alloc. At least the exception can be caught and EndLineArray won't</a>
<a name="ln4059">	// crash.</a>
<a name="ln4060">	fCommArray-&gt;array = NULL;</a>
<a name="ln4061">	fCommArray-&gt;maxCount = 0;</a>
<a name="ln4062"> </a>
<a name="ln4063">	fCommArray-&gt;array = new ViewLineArrayInfo[count];</a>
<a name="ln4064">	fCommArray-&gt;maxCount = count;</a>
<a name="ln4065">}</a>
<a name="ln4066"> </a>
<a name="ln4067"> </a>
<a name="ln4068">void</a>
<a name="ln4069">BView::AddLine(BPoint start, BPoint end, rgb_color color)</a>
<a name="ln4070">{</a>
<a name="ln4071">	if (fOwner == NULL)</a>
<a name="ln4072">		return;</a>
<a name="ln4073"> </a>
<a name="ln4074">	if (!fCommArray)</a>
<a name="ln4075">		debugger(&quot;BeginLineArray must be called before using AddLine&quot;);</a>
<a name="ln4076"> </a>
<a name="ln4077">	_CheckLock();</a>
<a name="ln4078"> </a>
<a name="ln4079">	const uint32 &amp;arrayCount = fCommArray-&gt;count;</a>
<a name="ln4080">	if (arrayCount &lt; fCommArray-&gt;maxCount) {</a>
<a name="ln4081">		fCommArray-&gt;array[arrayCount].startPoint = start;</a>
<a name="ln4082">		fCommArray-&gt;array[arrayCount].endPoint = end;</a>
<a name="ln4083">		fCommArray-&gt;array[arrayCount].color = color;</a>
<a name="ln4084"> </a>
<a name="ln4085">		fCommArray-&gt;count++;</a>
<a name="ln4086">	}</a>
<a name="ln4087">}</a>
<a name="ln4088"> </a>
<a name="ln4089"> </a>
<a name="ln4090">void</a>
<a name="ln4091">BView::EndLineArray()</a>
<a name="ln4092">{</a>
<a name="ln4093">	if (fOwner == NULL)</a>
<a name="ln4094">		return;</a>
<a name="ln4095"> </a>
<a name="ln4096">	if (fCommArray == NULL)</a>
<a name="ln4097">		debugger(&quot;Can't call EndLineArray before BeginLineArray&quot;);</a>
<a name="ln4098"> </a>
<a name="ln4099">	_CheckLockAndSwitchCurrent();</a>
<a name="ln4100"> </a>
<a name="ln4101">	fOwner-&gt;fLink-&gt;StartMessage(AS_STROKE_LINEARRAY);</a>
<a name="ln4102">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(fCommArray-&gt;count);</a>
<a name="ln4103">	fOwner-&gt;fLink-&gt;Attach(fCommArray-&gt;array,</a>
<a name="ln4104">		fCommArray-&gt;count * sizeof(ViewLineArrayInfo));</a>
<a name="ln4105"> </a>
<a name="ln4106">	_FlushIfNotInTransaction();</a>
<a name="ln4107"> </a>
<a name="ln4108">	_RemoveCommArray();</a>
<a name="ln4109">}</a>
<a name="ln4110"> </a>
<a name="ln4111"> </a>
<a name="ln4112">void</a>
<a name="ln4113">BView::SetDiskMode(char* filename, long offset)</a>
<a name="ln4114">{</a>
<a name="ln4115">	// TODO: implement</a>
<a name="ln4116">	// One BeBook version has this to say about SetDiskMode():</a>
<a name="ln4117">	//</a>
<a name="ln4118">	// &quot;Begins recording a picture to the file with the given filename</a>
<a name="ln4119">	// at the given offset. Subsequent drawing commands sent to the view</a>
<a name="ln4120">	// will be written to the file until EndPicture() is called. The</a>
<a name="ln4121">	// stored commands may be played from the file with DrawPicture().&quot;</a>
<a name="ln4122">}</a>
<a name="ln4123"> </a>
<a name="ln4124"> </a>
<a name="ln4125">void</a>
<a name="ln4126">BView::BeginPicture(BPicture* picture)</a>
<a name="ln4127">{</a>
<a name="ln4128">	if (_CheckOwnerLockAndSwitchCurrent()</a>
<a name="ln4129">		&amp;&amp; picture &amp;&amp; picture-&gt;fUsurped == NULL) {</a>
<a name="ln4130">		picture-&gt;Usurp(fCurrentPicture);</a>
<a name="ln4131">		fCurrentPicture = picture;</a>
<a name="ln4132"> </a>
<a name="ln4133">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_BEGIN_PICTURE);</a>
<a name="ln4134">	}</a>
<a name="ln4135">}</a>
<a name="ln4136"> </a>
<a name="ln4137"> </a>
<a name="ln4138">void</a>
<a name="ln4139">BView::AppendToPicture(BPicture* picture)</a>
<a name="ln4140">{</a>
<a name="ln4141">	_CheckLockAndSwitchCurrent();</a>
<a name="ln4142"> </a>
<a name="ln4143">	if (picture &amp;&amp; picture-&gt;fUsurped == NULL) {</a>
<a name="ln4144">		int32 token = picture-&gt;Token();</a>
<a name="ln4145"> </a>
<a name="ln4146">		if (token == -1) {</a>
<a name="ln4147">			BeginPicture(picture);</a>
<a name="ln4148">		} else {</a>
<a name="ln4149">			picture-&gt;SetToken(-1);</a>
<a name="ln4150">			picture-&gt;Usurp(fCurrentPicture);</a>
<a name="ln4151">			fCurrentPicture = picture;</a>
<a name="ln4152">			fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_APPEND_TO_PICTURE);</a>
<a name="ln4153">			fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(token);</a>
<a name="ln4154">		}</a>
<a name="ln4155">	}</a>
<a name="ln4156">}</a>
<a name="ln4157"> </a>
<a name="ln4158"> </a>
<a name="ln4159">BPicture*</a>
<a name="ln4160">BView::EndPicture()</a>
<a name="ln4161">{</a>
<a name="ln4162">	if (_CheckOwnerLockAndSwitchCurrent() &amp;&amp; fCurrentPicture) {</a>
<a name="ln4163">		int32 token;</a>
<a name="ln4164"> </a>
<a name="ln4165">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_END_PICTURE);</a>
<a name="ln4166"> </a>
<a name="ln4167">		int32 code;</a>
<a name="ln4168">		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln4169">			&amp;&amp; code == B_OK</a>
<a name="ln4170">			&amp;&amp; fOwner-&gt;fLink-&gt;Read&lt;int32&gt;(&amp;token) == B_OK) {</a>
<a name="ln4171">			BPicture* picture = fCurrentPicture;</a>
<a name="ln4172">			fCurrentPicture = picture-&gt;StepDown();</a>
<a name="ln4173">			picture-&gt;SetToken(token);</a>
<a name="ln4174"> </a>
<a name="ln4175">			// TODO do this more efficient e.g. use a shared area and let the</a>
<a name="ln4176">			// client write into it</a>
<a name="ln4177">			picture-&gt;_Download();</a>
<a name="ln4178">			return picture;</a>
<a name="ln4179">		}</a>
<a name="ln4180">	}</a>
<a name="ln4181"> </a>
<a name="ln4182">	return NULL;</a>
<a name="ln4183">}</a>
<a name="ln4184"> </a>
<a name="ln4185"> </a>
<a name="ln4186">void</a>
<a name="ln4187">BView::SetViewBitmap(const BBitmap* bitmap, BRect srcRect, BRect dstRect,</a>
<a name="ln4188">	uint32 followFlags, uint32 options)</a>
<a name="ln4189">{</a>
<a name="ln4190">	_SetViewBitmap(bitmap, srcRect, dstRect, followFlags, options);</a>
<a name="ln4191">}</a>
<a name="ln4192"> </a>
<a name="ln4193"> </a>
<a name="ln4194">void</a>
<a name="ln4195">BView::SetViewBitmap(const BBitmap* bitmap, uint32 followFlags, uint32 options)</a>
<a name="ln4196">{</a>
<a name="ln4197">	BRect rect;</a>
<a name="ln4198"> 	if (bitmap)</a>
<a name="ln4199">		rect = bitmap-&gt;Bounds();</a>
<a name="ln4200"> </a>
<a name="ln4201"> 	rect.OffsetTo(B_ORIGIN);</a>
<a name="ln4202"> </a>
<a name="ln4203">	_SetViewBitmap(bitmap, rect, rect, followFlags, options);</a>
<a name="ln4204">}</a>
<a name="ln4205"> </a>
<a name="ln4206"> </a>
<a name="ln4207">void</a>
<a name="ln4208">BView::ClearViewBitmap()</a>
<a name="ln4209">{</a>
<a name="ln4210">	_SetViewBitmap(NULL, BRect(), BRect(), 0, 0);</a>
<a name="ln4211">}</a>
<a name="ln4212"> </a>
<a name="ln4213"> </a>
<a name="ln4214">status_t</a>
<a name="ln4215">BView::SetViewOverlay(const BBitmap* overlay, BRect srcRect, BRect dstRect,</a>
<a name="ln4216">	rgb_color* colorKey, uint32 followFlags, uint32 options)</a>
<a name="ln4217">{</a>
<a name="ln4218">	if (overlay == NULL || (overlay-&gt;fFlags &amp; B_BITMAP_WILL_OVERLAY) == 0)</a>
<a name="ln4219">		return B_BAD_VALUE;</a>
<a name="ln4220"> </a>
<a name="ln4221">	status_t status = _SetViewBitmap(overlay, srcRect, dstRect, followFlags,</a>
<a name="ln4222">		options | AS_REQUEST_COLOR_KEY);</a>
<a name="ln4223">	if (status == B_OK) {</a>
<a name="ln4224">		// read the color that will be treated as transparent</a>
<a name="ln4225">		fOwner-&gt;fLink-&gt;Read&lt;rgb_color&gt;(colorKey);</a>
<a name="ln4226">	}</a>
<a name="ln4227"> </a>
<a name="ln4228">	return status;</a>
<a name="ln4229">}</a>
<a name="ln4230"> </a>
<a name="ln4231"> </a>
<a name="ln4232">status_t</a>
<a name="ln4233">BView::SetViewOverlay(const BBitmap* overlay, rgb_color* colorKey,</a>
<a name="ln4234">	uint32 followFlags, uint32 options)</a>
<a name="ln4235">{</a>
<a name="ln4236">	if (overlay == NULL)</a>
<a name="ln4237">		return B_BAD_VALUE;</a>
<a name="ln4238"> </a>
<a name="ln4239">	BRect rect = overlay-&gt;Bounds();</a>
<a name="ln4240"> 	rect.OffsetTo(B_ORIGIN);</a>
<a name="ln4241"> </a>
<a name="ln4242">	return SetViewOverlay(overlay, rect, rect, colorKey, followFlags, options);</a>
<a name="ln4243">}</a>
<a name="ln4244"> </a>
<a name="ln4245"> </a>
<a name="ln4246">void</a>
<a name="ln4247">BView::ClearViewOverlay()</a>
<a name="ln4248">{</a>
<a name="ln4249">	_SetViewBitmap(NULL, BRect(), BRect(), 0, 0);</a>
<a name="ln4250">}</a>
<a name="ln4251"> </a>
<a name="ln4252"> </a>
<a name="ln4253">void</a>
<a name="ln4254">BView::CopyBits(BRect src, BRect dst)</a>
<a name="ln4255">{</a>
<a name="ln4256">	if (fOwner == NULL)</a>
<a name="ln4257">		return;</a>
<a name="ln4258"> </a>
<a name="ln4259">	if (!src.IsValid() || !dst.IsValid())</a>
<a name="ln4260">		return;</a>
<a name="ln4261"> </a>
<a name="ln4262">	_CheckLockAndSwitchCurrent();</a>
<a name="ln4263"> </a>
<a name="ln4264">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_COPY_BITS);</a>
<a name="ln4265">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(src);</a>
<a name="ln4266">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(dst);</a>
<a name="ln4267"> </a>
<a name="ln4268">	_FlushIfNotInTransaction();</a>
<a name="ln4269">}</a>
<a name="ln4270"> </a>
<a name="ln4271"> </a>
<a name="ln4272">void</a>
<a name="ln4273">BView::DrawPicture(const BPicture* picture)</a>
<a name="ln4274">{</a>
<a name="ln4275">	if (picture == NULL)</a>
<a name="ln4276">		return;</a>
<a name="ln4277"> </a>
<a name="ln4278">	DrawPictureAsync(picture, PenLocation());</a>
<a name="ln4279">	Sync();</a>
<a name="ln4280">}</a>
<a name="ln4281"> </a>
<a name="ln4282"> </a>
<a name="ln4283">void</a>
<a name="ln4284">BView::DrawPicture(const BPicture* picture, BPoint where)</a>
<a name="ln4285">{</a>
<a name="ln4286">	if (picture == NULL)</a>
<a name="ln4287">		return;</a>
<a name="ln4288"> </a>
<a name="ln4289">	DrawPictureAsync(picture, where);</a>
<a name="ln4290">	Sync();</a>
<a name="ln4291">}</a>
<a name="ln4292"> </a>
<a name="ln4293"> </a>
<a name="ln4294">void</a>
<a name="ln4295">BView::DrawPicture(const char* filename, long offset, BPoint where)</a>
<a name="ln4296">{</a>
<a name="ln4297">	if (!filename)</a>
<a name="ln4298">		return;</a>
<a name="ln4299"> </a>
<a name="ln4300">	DrawPictureAsync(filename, offset, where);</a>
<a name="ln4301">	Sync();</a>
<a name="ln4302">}</a>
<a name="ln4303"> </a>
<a name="ln4304"> </a>
<a name="ln4305">void</a>
<a name="ln4306">BView::DrawPictureAsync(const BPicture* picture)</a>
<a name="ln4307">{</a>
<a name="ln4308">	if (picture == NULL)</a>
<a name="ln4309">		return;</a>
<a name="ln4310"> </a>
<a name="ln4311">	DrawPictureAsync(picture, PenLocation());</a>
<a name="ln4312">}</a>
<a name="ln4313"> </a>
<a name="ln4314"> </a>
<a name="ln4315">void</a>
<a name="ln4316">BView::DrawPictureAsync(const BPicture* picture, BPoint where)</a>
<a name="ln4317">{</a>
<a name="ln4318">	if (picture == NULL)</a>
<a name="ln4319">		return;</a>
<a name="ln4320"> </a>
<a name="ln4321">	if (_CheckOwnerLockAndSwitchCurrent() &amp;&amp; picture-&gt;Token() &gt; 0) {</a>
<a name="ln4322">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_DRAW_PICTURE);</a>
<a name="ln4323">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(picture-&gt;Token());</a>
<a name="ln4324">		fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(where);</a>
<a name="ln4325"> </a>
<a name="ln4326">		_FlushIfNotInTransaction();</a>
<a name="ln4327">	}</a>
<a name="ln4328">}</a>
<a name="ln4329"> </a>
<a name="ln4330"> </a>
<a name="ln4331">void</a>
<a name="ln4332">BView::DrawPictureAsync(const char* filename, long offset, BPoint where)</a>
<a name="ln4333">{</a>
<a name="ln4334">	if (!filename)</a>
<a name="ln4335">		return;</a>
<a name="ln4336"> </a>
<a name="ln4337">	// TODO: Test</a>
<a name="ln4338">	BFile file(filename, B_READ_ONLY);</a>
<a name="ln4339">	if (file.InitCheck() &lt; B_OK)</a>
<a name="ln4340">		return;</a>
<a name="ln4341"> </a>
<a name="ln4342">	file.Seek(offset, SEEK_SET);</a>
<a name="ln4343"> </a>
<a name="ln4344">	BPicture picture;</a>
<a name="ln4345">	if (picture.Unflatten(&amp;file) &lt; B_OK)</a>
<a name="ln4346">		return;</a>
<a name="ln4347"> </a>
<a name="ln4348">	DrawPictureAsync(&amp;picture, where);</a>
<a name="ln4349">}</a>
<a name="ln4350"> </a>
<a name="ln4351"> </a>
<a name="ln4352">void</a>
<a name="ln4353">BView::BeginLayer(uint8 opacity)</a>
<a name="ln4354">{</a>
<a name="ln4355">	if (_CheckOwnerLockAndSwitchCurrent()) {</a>
<a name="ln4356">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_BEGIN_LAYER);</a>
<a name="ln4357">		fOwner-&gt;fLink-&gt;Attach&lt;uint8&gt;(opacity);</a>
<a name="ln4358">		_FlushIfNotInTransaction();</a>
<a name="ln4359">	}</a>
<a name="ln4360">}</a>
<a name="ln4361"> </a>
<a name="ln4362"> </a>
<a name="ln4363">void</a>
<a name="ln4364">BView::EndLayer()</a>
<a name="ln4365">{</a>
<a name="ln4366">	if (_CheckOwnerLockAndSwitchCurrent()) {</a>
<a name="ln4367">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_END_LAYER);</a>
<a name="ln4368">		_FlushIfNotInTransaction();</a>
<a name="ln4369">	}</a>
<a name="ln4370">}</a>
<a name="ln4371"> </a>
<a name="ln4372"> </a>
<a name="ln4373">void</a>
<a name="ln4374">BView::Invalidate(BRect invalRect)</a>
<a name="ln4375">{</a>
<a name="ln4376">	if (fOwner == NULL)</a>
<a name="ln4377">		return;</a>
<a name="ln4378"> </a>
<a name="ln4379">	// NOTE: This rounding of the invalid rect is to stay compatible with BeOS.</a>
<a name="ln4380">	// On the server side, the invalid rect will be converted to a BRegion,</a>
<a name="ln4381">	// which rounds in a different manner, so that it really includes the</a>
<a name="ln4382">	// fractional coordinates of a BRect (ie ceilf(rect.right) &amp;</a>
<a name="ln4383">	// ceilf(rect.bottom)), which is also what BeOS does. So we have to do the</a>
<a name="ln4384">	// different rounding here to stay compatible in both ways.</a>
<a name="ln4385">	invalRect.left = (int)invalRect.left;</a>
<a name="ln4386">	invalRect.top = (int)invalRect.top;</a>
<a name="ln4387">	invalRect.right = (int)invalRect.right;</a>
<a name="ln4388">	invalRect.bottom = (int)invalRect.bottom;</a>
<a name="ln4389">	if (!invalRect.IsValid())</a>
<a name="ln4390">		return;</a>
<a name="ln4391"> </a>
<a name="ln4392">	_CheckLockAndSwitchCurrent();</a>
<a name="ln4393"> </a>
<a name="ln4394">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_INVALIDATE_RECT);</a>
<a name="ln4395">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(invalRect);</a>
<a name="ln4396"> </a>
<a name="ln4397">// TODO: determine why this check isn't working correctly.</a>
<a name="ln4398">#if 0</a>
<a name="ln4399">	if (!fOwner-&gt;fUpdateRequested) {</a>
<a name="ln4400">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln4401">		fOwner-&gt;fUpdateRequested = true;</a>
<a name="ln4402">	}</a>
<a name="ln4403">#else</a>
<a name="ln4404">	fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln4405">#endif</a>
<a name="ln4406">}</a>
<a name="ln4407"> </a>
<a name="ln4408"> </a>
<a name="ln4409">void</a>
<a name="ln4410">BView::Invalidate(const BRegion* region)</a>
<a name="ln4411">{</a>
<a name="ln4412">	if (region == NULL || fOwner == NULL)</a>
<a name="ln4413">		return;</a>
<a name="ln4414"> </a>
<a name="ln4415">	_CheckLockAndSwitchCurrent();</a>
<a name="ln4416"> </a>
<a name="ln4417">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_INVALIDATE_REGION);</a>
<a name="ln4418">	fOwner-&gt;fLink-&gt;AttachRegion(*region);</a>
<a name="ln4419"> </a>
<a name="ln4420">// TODO: See above.</a>
<a name="ln4421">#if 0</a>
<a name="ln4422">	if (!fOwner-&gt;fUpdateRequested) {</a>
<a name="ln4423">		fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln4424">		fOwner-&gt;fUpdateRequested = true;</a>
<a name="ln4425">	}</a>
<a name="ln4426">#else</a>
<a name="ln4427">	fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln4428">#endif</a>
<a name="ln4429">}</a>
<a name="ln4430"> </a>
<a name="ln4431"> </a>
<a name="ln4432">void</a>
<a name="ln4433">BView::Invalidate()</a>
<a name="ln4434">{</a>
<a name="ln4435">	Invalidate(Bounds());</a>
<a name="ln4436">}</a>
<a name="ln4437"> </a>
<a name="ln4438"> </a>
<a name="ln4439">void</a>
<a name="ln4440">BView::DelayedInvalidate(bigtime_t delay)</a>
<a name="ln4441">{</a>
<a name="ln4442">	DelayedInvalidate(delay, Bounds());</a>
<a name="ln4443">}</a>
<a name="ln4444"> </a>
<a name="ln4445"> </a>
<a name="ln4446">void</a>
<a name="ln4447">BView::DelayedInvalidate(bigtime_t delay, BRect invalRect)</a>
<a name="ln4448">{</a>
<a name="ln4449">	if (fOwner == NULL)</a>
<a name="ln4450">		return;</a>
<a name="ln4451"> </a>
<a name="ln4452">	invalRect.left = (int)invalRect.left;</a>
<a name="ln4453">	invalRect.top = (int)invalRect.top;</a>
<a name="ln4454">	invalRect.right = (int)invalRect.right;</a>
<a name="ln4455">	invalRect.bottom = (int)invalRect.bottom;</a>
<a name="ln4456">	if (!invalRect.IsValid())</a>
<a name="ln4457">		return;</a>
<a name="ln4458"> </a>
<a name="ln4459">	_CheckLockAndSwitchCurrent();</a>
<a name="ln4460"> </a>
<a name="ln4461">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_DELAYED_INVALIDATE_RECT);</a>
<a name="ln4462">	fOwner-&gt;fLink-&gt;Attach&lt;bigtime_t&gt;(system_time() + delay);</a>
<a name="ln4463">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(invalRect);</a>
<a name="ln4464">	fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln4465">}</a>
<a name="ln4466"> </a>
<a name="ln4467"> </a>
<a name="ln4468">void</a>
<a name="ln4469">BView::InvertRect(BRect rect)</a>
<a name="ln4470">{</a>
<a name="ln4471">	if (fOwner) {</a>
<a name="ln4472">		_CheckLockAndSwitchCurrent();</a>
<a name="ln4473"> </a>
<a name="ln4474">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_INVERT_RECT);</a>
<a name="ln4475">		fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln4476"> </a>
<a name="ln4477">		_FlushIfNotInTransaction();</a>
<a name="ln4478">	}</a>
<a name="ln4479">}</a>
<a name="ln4480"> </a>
<a name="ln4481"> </a>
<a name="ln4482">//	#pragma mark - View Hierarchy Functions</a>
<a name="ln4483"> </a>
<a name="ln4484"> </a>
<a name="ln4485">void</a>
<a name="ln4486">BView::AddChild(BView* child, BView* before)</a>
<a name="ln4487">{</a>
<a name="ln4488">	STRACE((&quot;BView(%s)::AddChild(child '%s', before '%s')\n&quot;,</a>
<a name="ln4489">		this-&gt;Name(),</a>
<a name="ln4490">		child != NULL &amp;&amp; child-&gt;Name() ? child-&gt;Name() : &quot;NULL&quot;,</a>
<a name="ln4491">		before != NULL &amp;&amp; before-&gt;Name() ? before-&gt;Name() : &quot;NULL&quot;));</a>
<a name="ln4492"> </a>
<a name="ln4493">	if (!_AddChild(child, before))</a>
<a name="ln4494">		return;</a>
<a name="ln4495"> </a>
<a name="ln4496">	if (fLayoutData-&gt;fLayout)</a>
<a name="ln4497">		fLayoutData-&gt;fLayout-&gt;AddView(child);</a>
<a name="ln4498">}</a>
<a name="ln4499"> </a>
<a name="ln4500"> </a>
<a name="ln4501">bool</a>
<a name="ln4502">BView::AddChild(BLayoutItem* child)</a>
<a name="ln4503">{</a>
<a name="ln4504">	if (!fLayoutData-&gt;fLayout)</a>
<a name="ln4505">		return false;</a>
<a name="ln4506">	return fLayoutData-&gt;fLayout-&gt;AddItem(child);</a>
<a name="ln4507">}</a>
<a name="ln4508"> </a>
<a name="ln4509"> </a>
<a name="ln4510">bool</a>
<a name="ln4511">BView::_AddChild(BView* child, BView* before)</a>
<a name="ln4512">{</a>
<a name="ln4513">	if (!child)</a>
<a name="ln4514">		return false;</a>
<a name="ln4515"> </a>
<a name="ln4516">	if (child-&gt;fParent != NULL) {</a>
<a name="ln4517">		debugger(&quot;AddChild failed - the view already has a parent.&quot;);</a>
<a name="ln4518">		return false;</a>
<a name="ln4519">	}</a>
<a name="ln4520"> </a>
<a name="ln4521">	if (child == this) {</a>
<a name="ln4522">		debugger(&quot;AddChild failed - cannot add a view to itself.&quot;);</a>
<a name="ln4523">		return false;</a>
<a name="ln4524">	}</a>
<a name="ln4525"> </a>
<a name="ln4526">	bool lockedOwner = false;</a>
<a name="ln4527">	if (fOwner &amp;&amp; !fOwner-&gt;IsLocked()) {</a>
<a name="ln4528">		fOwner-&gt;Lock();</a>
<a name="ln4529">		lockedOwner = true;</a>
<a name="ln4530">	}</a>
<a name="ln4531"> </a>
<a name="ln4532">	if (!_AddChildToList(child, before)) {</a>
<a name="ln4533">		debugger(&quot;AddChild failed!&quot;);</a>
<a name="ln4534">		if (lockedOwner)</a>
<a name="ln4535">			fOwner-&gt;Unlock();</a>
<a name="ln4536">		return false;</a>
<a name="ln4537">	}</a>
<a name="ln4538"> </a>
<a name="ln4539">	if (fOwner) {</a>
<a name="ln4540">		_CheckLockAndSwitchCurrent();</a>
<a name="ln4541"> </a>
<a name="ln4542">		child-&gt;_SetOwner(fOwner);</a>
<a name="ln4543">		child-&gt;_CreateSelf();</a>
<a name="ln4544">		child-&gt;_Attach();</a>
<a name="ln4545"> </a>
<a name="ln4546">		if (lockedOwner)</a>
<a name="ln4547">			fOwner-&gt;Unlock();</a>
<a name="ln4548">	}</a>
<a name="ln4549"> </a>
<a name="ln4550">	InvalidateLayout();</a>
<a name="ln4551"> </a>
<a name="ln4552">	return true;</a>
<a name="ln4553">}</a>
<a name="ln4554"> </a>
<a name="ln4555"> </a>
<a name="ln4556">bool</a>
<a name="ln4557">BView::RemoveChild(BView* child)</a>
<a name="ln4558">{</a>
<a name="ln4559">	STRACE((&quot;BView(%s)::RemoveChild(%s)\n&quot;, Name(), child-&gt;Name()));</a>
<a name="ln4560"> </a>
<a name="ln4561">	if (!child)</a>
<a name="ln4562">		return false;</a>
<a name="ln4563"> </a>
<a name="ln4564">	if (child-&gt;fParent != this)</a>
<a name="ln4565">		return false;</a>
<a name="ln4566"> </a>
<a name="ln4567">	return child-&gt;RemoveSelf();</a>
<a name="ln4568">}</a>
<a name="ln4569"> </a>
<a name="ln4570"> </a>
<a name="ln4571">int32</a>
<a name="ln4572">BView::CountChildren() const</a>
<a name="ln4573">{</a>
<a name="ln4574">	_CheckLock();</a>
<a name="ln4575"> </a>
<a name="ln4576">	uint32 count = 0;</a>
<a name="ln4577">	BView* child = fFirstChild;</a>
<a name="ln4578"> </a>
<a name="ln4579">	while (child != NULL) {</a>
<a name="ln4580">		count++;</a>
<a name="ln4581">		child = child-&gt;fNextSibling;</a>
<a name="ln4582">	}</a>
<a name="ln4583"> </a>
<a name="ln4584">	return count;</a>
<a name="ln4585">}</a>
<a name="ln4586"> </a>
<a name="ln4587"> </a>
<a name="ln4588">BView*</a>
<a name="ln4589">BView::ChildAt(int32 index) const</a>
<a name="ln4590">{</a>
<a name="ln4591">	_CheckLock();</a>
<a name="ln4592"> </a>
<a name="ln4593">	BView* child = fFirstChild;</a>
<a name="ln4594">	while (child != NULL &amp;&amp; index-- &gt; 0) {</a>
<a name="ln4595">		child = child-&gt;fNextSibling;</a>
<a name="ln4596">	}</a>
<a name="ln4597"> </a>
<a name="ln4598">	return child;</a>
<a name="ln4599">}</a>
<a name="ln4600"> </a>
<a name="ln4601"> </a>
<a name="ln4602">BView*</a>
<a name="ln4603">BView::NextSibling() const</a>
<a name="ln4604">{</a>
<a name="ln4605">	return fNextSibling;</a>
<a name="ln4606">}</a>
<a name="ln4607"> </a>
<a name="ln4608"> </a>
<a name="ln4609">BView*</a>
<a name="ln4610">BView::PreviousSibling() const</a>
<a name="ln4611">{</a>
<a name="ln4612">	return fPreviousSibling;</a>
<a name="ln4613">}</a>
<a name="ln4614"> </a>
<a name="ln4615"> </a>
<a name="ln4616">bool</a>
<a name="ln4617">BView::RemoveSelf()</a>
<a name="ln4618">{</a>
<a name="ln4619">	_RemoveLayoutItemsFromLayout(false);</a>
<a name="ln4620"> </a>
<a name="ln4621">	return _RemoveSelf();</a>
<a name="ln4622">}</a>
<a name="ln4623"> </a>
<a name="ln4624"> </a>
<a name="ln4625">bool</a>
<a name="ln4626">BView::_RemoveSelf()</a>
<a name="ln4627">{</a>
<a name="ln4628">	STRACE((&quot;BView(%s)::_RemoveSelf()\n&quot;, Name()));</a>
<a name="ln4629"> </a>
<a name="ln4630">	// Remove this child from its parent</a>
<a name="ln4631"> </a>
<a name="ln4632">	BWindow* owner = fOwner;</a>
<a name="ln4633">	_CheckLock();</a>
<a name="ln4634"> </a>
<a name="ln4635">	if (owner != NULL) {</a>
<a name="ln4636">		_UpdateStateForRemove();</a>
<a name="ln4637">		_Detach();</a>
<a name="ln4638">	}</a>
<a name="ln4639"> </a>
<a name="ln4640">	BView* parent = fParent;</a>
<a name="ln4641">	if (!parent || !parent-&gt;_RemoveChildFromList(this))</a>
<a name="ln4642">		return false;</a>
<a name="ln4643"> </a>
<a name="ln4644">	if (owner != NULL &amp;&amp; !fTopLevelView) {</a>
<a name="ln4645">		// the top level view is deleted by the app_server automatically</a>
<a name="ln4646">		owner-&gt;fLink-&gt;StartMessage(AS_VIEW_DELETE);</a>
<a name="ln4647">		owner-&gt;fLink-&gt;Attach&lt;int32&gt;(_get_object_token_(this));</a>
<a name="ln4648">	}</a>
<a name="ln4649"> </a>
<a name="ln4650">	parent-&gt;InvalidateLayout();</a>
<a name="ln4651"> </a>
<a name="ln4652">	STRACE((&quot;DONE: BView(%s)::_RemoveSelf()\n&quot;, Name()));</a>
<a name="ln4653"> </a>
<a name="ln4654">	return true;</a>
<a name="ln4655">}</a>
<a name="ln4656"> </a>
<a name="ln4657"> </a>
<a name="ln4658">void</a>
<a name="ln4659">BView::_RemoveLayoutItemsFromLayout(bool deleteItems)</a>
<a name="ln4660">{</a>
<a name="ln4661">	if (fParent == NULL || fParent-&gt;fLayoutData-&gt;fLayout == NULL)</a>
<a name="ln4662">		return;</a>
<a name="ln4663"> </a>
<a name="ln4664">	int32 index = fLayoutData-&gt;fLayoutItems.CountItems();</a>
<a name="ln4665">	while (index-- &gt; 0) {</a>
<a name="ln4666">		BLayoutItem* item = fLayoutData-&gt;fLayoutItems.ItemAt(index);</a>
<a name="ln4667">		item-&gt;RemoveSelf();</a>
<a name="ln4668">			// Removes item from fLayoutItems list</a>
<a name="ln4669">		if (deleteItems)</a>
<a name="ln4670">			delete item;</a>
<a name="ln4671">	}</a>
<a name="ln4672">}</a>
<a name="ln4673"> </a>
<a name="ln4674"> </a>
<a name="ln4675">BView*</a>
<a name="ln4676">BView::Parent() const</a>
<a name="ln4677">{</a>
<a name="ln4678">	if (fParent &amp;&amp; fParent-&gt;fTopLevelView)</a>
<a name="ln4679">		return NULL;</a>
<a name="ln4680"> </a>
<a name="ln4681">	return fParent;</a>
<a name="ln4682">}</a>
<a name="ln4683"> </a>
<a name="ln4684"> </a>
<a name="ln4685">BView*</a>
<a name="ln4686">BView::FindView(const char* name) const</a>
<a name="ln4687">{</a>
<a name="ln4688">	if (name == NULL)</a>
<a name="ln4689">		return NULL;</a>
<a name="ln4690"> </a>
<a name="ln4691">	if (Name() != NULL &amp;&amp; !strcmp(Name(), name))</a>
<a name="ln4692">		return const_cast&lt;BView*&gt;(this);</a>
<a name="ln4693"> </a>
<a name="ln4694">	BView* child = fFirstChild;</a>
<a name="ln4695">	while (child != NULL) {</a>
<a name="ln4696">		BView* view = child-&gt;FindView(name);</a>
<a name="ln4697">		if (view != NULL)</a>
<a name="ln4698">			return view;</a>
<a name="ln4699"> </a>
<a name="ln4700">		child = child-&gt;fNextSibling;</a>
<a name="ln4701">	}</a>
<a name="ln4702"> </a>
<a name="ln4703">	return NULL;</a>
<a name="ln4704">}</a>
<a name="ln4705"> </a>
<a name="ln4706"> </a>
<a name="ln4707">void</a>
<a name="ln4708">BView::MoveBy(float deltaX, float deltaY)</a>
<a name="ln4709">{</a>
<a name="ln4710">	MoveTo(fParentOffset.x + roundf(deltaX), fParentOffset.y + roundf(deltaY));</a>
<a name="ln4711">}</a>
<a name="ln4712"> </a>
<a name="ln4713"> </a>
<a name="ln4714">void</a>
<a name="ln4715">BView::MoveTo(BPoint where)</a>
<a name="ln4716">{</a>
<a name="ln4717">	MoveTo(where.x, where.y);</a>
<a name="ln4718">}</a>
<a name="ln4719"> </a>
<a name="ln4720"> </a>
<a name="ln4721">void</a>
<a name="ln4722">BView::MoveTo(float x, float y)</a>
<a name="ln4723">{</a>
<a name="ln4724">	if (x == fParentOffset.x &amp;&amp; y == fParentOffset.y)</a>
<a name="ln4725">		return;</a>
<a name="ln4726"> </a>
<a name="ln4727">	// BeBook says we should do this. And it makes sense.</a>
<a name="ln4728">	x = roundf(x);</a>
<a name="ln4729">	y = roundf(y);</a>
<a name="ln4730"> </a>
<a name="ln4731">	if (fOwner) {</a>
<a name="ln4732">		_CheckLockAndSwitchCurrent();</a>
<a name="ln4733">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_MOVE_TO);</a>
<a name="ln4734">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(x);</a>
<a name="ln4735">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(y);</a>
<a name="ln4736"> </a>
<a name="ln4737">//		fState-&gt;valid_flags |= B_VIEW_FRAME_BIT;</a>
<a name="ln4738"> </a>
<a name="ln4739">		_FlushIfNotInTransaction();</a>
<a name="ln4740">	}</a>
<a name="ln4741"> </a>
<a name="ln4742">	_MoveTo((int32)x, (int32)y);</a>
<a name="ln4743">}</a>
<a name="ln4744"> </a>
<a name="ln4745"> </a>
<a name="ln4746">void</a>
<a name="ln4747">BView::ResizeBy(float deltaWidth, float deltaHeight)</a>
<a name="ln4748">{</a>
<a name="ln4749">	// BeBook says we should do this. And it makes sense.</a>
<a name="ln4750">	deltaWidth = roundf(deltaWidth);</a>
<a name="ln4751">	deltaHeight = roundf(deltaHeight);</a>
<a name="ln4752"> </a>
<a name="ln4753">	if (deltaWidth == 0 &amp;&amp; deltaHeight == 0)</a>
<a name="ln4754">		return;</a>
<a name="ln4755"> </a>
<a name="ln4756">	if (fOwner) {</a>
<a name="ln4757">		_CheckLockAndSwitchCurrent();</a>
<a name="ln4758">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_RESIZE_TO);</a>
<a name="ln4759"> </a>
<a name="ln4760">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(fBounds.Width() + deltaWidth);</a>
<a name="ln4761">		fOwner-&gt;fLink-&gt;Attach&lt;float&gt;(fBounds.Height() + deltaHeight);</a>
<a name="ln4762"> </a>
<a name="ln4763">//		fState-&gt;valid_flags |= B_VIEW_FRAME_BIT;</a>
<a name="ln4764"> </a>
<a name="ln4765">		_FlushIfNotInTransaction();</a>
<a name="ln4766">	}</a>
<a name="ln4767"> </a>
<a name="ln4768">	_ResizeBy((int32)deltaWidth, (int32)deltaHeight);</a>
<a name="ln4769">}</a>
<a name="ln4770"> </a>
<a name="ln4771"> </a>
<a name="ln4772">void</a>
<a name="ln4773">BView::ResizeTo(float width, float height)</a>
<a name="ln4774">{</a>
<a name="ln4775">	ResizeBy(width - fBounds.Width(), height - fBounds.Height());</a>
<a name="ln4776">}</a>
<a name="ln4777"> </a>
<a name="ln4778"> </a>
<a name="ln4779">void</a>
<a name="ln4780">BView::ResizeTo(BSize size)</a>
<a name="ln4781">{</a>
<a name="ln4782">	ResizeBy(size.width - fBounds.Width(), size.height - fBounds.Height());</a>
<a name="ln4783">}</a>
<a name="ln4784"> </a>
<a name="ln4785"> </a>
<a name="ln4786">//	#pragma mark - Inherited Methods (from BHandler)</a>
<a name="ln4787"> </a>
<a name="ln4788"> </a>
<a name="ln4789">status_t</a>
<a name="ln4790">BView::GetSupportedSuites(BMessage* data)</a>
<a name="ln4791">{</a>
<a name="ln4792">	if (data == NULL)</a>
<a name="ln4793">		return B_BAD_VALUE;</a>
<a name="ln4794"> </a>
<a name="ln4795">	status_t status = data-&gt;AddString(&quot;suites&quot;, &quot;suite/vnd.Be-view&quot;);</a>
<a name="ln4796">	BPropertyInfo propertyInfo(sViewPropInfo);</a>
<a name="ln4797">	if (status == B_OK)</a>
<a name="ln4798">		status = data-&gt;AddFlat(&quot;messages&quot;, &amp;propertyInfo);</a>
<a name="ln4799">	if (status == B_OK)</a>
<a name="ln4800">		return BHandler::GetSupportedSuites(data);</a>
<a name="ln4801">	return status;</a>
<a name="ln4802">}</a>
<a name="ln4803"> </a>
<a name="ln4804"> </a>
<a name="ln4805">BHandler*</a>
<a name="ln4806">BView::ResolveSpecifier(BMessage* message, int32 index, BMessage* specifier,</a>
<a name="ln4807">	int32 what, const char* property)</a>
<a name="ln4808">{</a>
<a name="ln4809">	if (message-&gt;what == B_WINDOW_MOVE_BY</a>
<a name="ln4810">		|| message-&gt;what == B_WINDOW_MOVE_TO) {</a>
<a name="ln4811">		return this;</a>
<a name="ln4812">	}</a>
<a name="ln4813"> </a>
<a name="ln4814">	BPropertyInfo propertyInfo(sViewPropInfo);</a>
<a name="ln4815">	status_t err = B_BAD_SCRIPT_SYNTAX;</a>
<a name="ln4816">	BMessage replyMsg(B_REPLY);</a>
<a name="ln4817"> </a>
<a name="ln4818">	switch (propertyInfo.FindMatch(message, index, specifier, what, property)) {</a>
<a name="ln4819">		case 0:</a>
<a name="ln4820">		case 1:</a>
<a name="ln4821">		case 3:</a>
<a name="ln4822">			return this;</a>
<a name="ln4823"> </a>
<a name="ln4824">		case 2:</a>
<a name="ln4825">			if (fShelf) {</a>
<a name="ln4826">				message-&gt;PopSpecifier();</a>
<a name="ln4827">				return fShelf;</a>
<a name="ln4828">			}</a>
<a name="ln4829"> </a>
<a name="ln4830">			err = B_NAME_NOT_FOUND;</a>
<a name="ln4831">			replyMsg.AddString(&quot;message&quot;, &quot;This window doesn't have a shelf&quot;);</a>
<a name="ln4832">			break;</a>
<a name="ln4833"> </a>
<a name="ln4834">		case 4:</a>
<a name="ln4835">		{</a>
<a name="ln4836">			if (!fFirstChild) {</a>
<a name="ln4837">				err = B_NAME_NOT_FOUND;</a>
<a name="ln4838">				replyMsg.AddString(&quot;message&quot;, &quot;This window doesn't have &quot;</a>
<a name="ln4839">					&quot;children.&quot;);</a>
<a name="ln4840">				break;</a>
<a name="ln4841">			}</a>
<a name="ln4842">			BView* child = NULL;</a>
<a name="ln4843">			switch (what) {</a>
<a name="ln4844">				case B_INDEX_SPECIFIER:</a>
<a name="ln4845">				{</a>
<a name="ln4846">					int32 index;</a>
<a name="ln4847">					err = specifier-&gt;FindInt32(&quot;index&quot;, &amp;index);</a>
<a name="ln4848">					if (err == B_OK)</a>
<a name="ln4849">						child = ChildAt(index);</a>
<a name="ln4850">					break;</a>
<a name="ln4851">				}</a>
<a name="ln4852">				case B_REVERSE_INDEX_SPECIFIER:</a>
<a name="ln4853">				{</a>
<a name="ln4854">					int32 rindex;</a>
<a name="ln4855">					err = specifier-&gt;FindInt32(&quot;index&quot;, &amp;rindex);</a>
<a name="ln4856">					if (err == B_OK)</a>
<a name="ln4857">						child = ChildAt(CountChildren() - rindex);</a>
<a name="ln4858">					break;</a>
<a name="ln4859">				}</a>
<a name="ln4860">				case B_NAME_SPECIFIER:</a>
<a name="ln4861">				{</a>
<a name="ln4862">					const char* name;</a>
<a name="ln4863">					err = specifier-&gt;FindString(&quot;name&quot;, &amp;name);</a>
<a name="ln4864">					if (err == B_OK)</a>
<a name="ln4865">						child = FindView(name);</a>
<a name="ln4866">					break;</a>
<a name="ln4867">				}</a>
<a name="ln4868">			}</a>
<a name="ln4869"> </a>
<a name="ln4870">			if (child != NULL) {</a>
<a name="ln4871">				message-&gt;PopSpecifier();</a>
<a name="ln4872">				return child;</a>
<a name="ln4873">			}</a>
<a name="ln4874"> </a>
<a name="ln4875">			if (err == B_OK)</a>
<a name="ln4876">				err = B_BAD_INDEX;</a>
<a name="ln4877"> </a>
<a name="ln4878">			replyMsg.AddString(&quot;message&quot;,</a>
<a name="ln4879">				&quot;Cannot find view at/with specified index/name.&quot;);</a>
<a name="ln4880">			break;</a>
<a name="ln4881">		}</a>
<a name="ln4882"> </a>
<a name="ln4883">		default:</a>
<a name="ln4884">			return BHandler::ResolveSpecifier(message, index, specifier, what,</a>
<a name="ln4885">				property);</a>
<a name="ln4886">	}</a>
<a name="ln4887"> </a>
<a name="ln4888">	if (err &lt; B_OK) {</a>
<a name="ln4889">		replyMsg.what = B_MESSAGE_NOT_UNDERSTOOD;</a>
<a name="ln4890"> </a>
<a name="ln4891">		if (err == B_BAD_SCRIPT_SYNTAX)</a>
<a name="ln4892">			replyMsg.AddString(&quot;message&quot;, &quot;Didn't understand the specifier(s)&quot;);</a>
<a name="ln4893">		else</a>
<a name="ln4894">			replyMsg.AddString(&quot;message&quot;, strerror(err));</a>
<a name="ln4895">	}</a>
<a name="ln4896"> </a>
<a name="ln4897">	replyMsg.AddInt32(&quot;error&quot;, err);</a>
<a name="ln4898">	message-&gt;SendReply(&amp;replyMsg);</a>
<a name="ln4899">	return NULL;</a>
<a name="ln4900">}</a>
<a name="ln4901"> </a>
<a name="ln4902"> </a>
<a name="ln4903">void</a>
<a name="ln4904">BView::MessageReceived(BMessage* message)</a>
<a name="ln4905">{</a>
<a name="ln4906">	if (!message-&gt;HasSpecifiers()) {</a>
<a name="ln4907">		switch (message-&gt;what) {</a>
<a name="ln4908">			case B_VIEW_RESIZED:</a>
<a name="ln4909">				FrameResized(message-&gt;GetInt32(&quot;width&quot;, 0),</a>
<a name="ln4910">					message-&gt;GetInt32(&quot;height&quot;, 0));</a>
<a name="ln4911">				break;</a>
<a name="ln4912"> </a>
<a name="ln4913">			case B_VIEW_MOVED:</a>
<a name="ln4914">				FrameMoved(fParentOffset);</a>
<a name="ln4915">				break;</a>
<a name="ln4916"> </a>
<a name="ln4917">			case B_MOUSE_IDLE:</a>
<a name="ln4918">			{</a>
<a name="ln4919">				BPoint where;</a>
<a name="ln4920">				if (message-&gt;FindPoint(&quot;be:view_where&quot;, &amp;where) != B_OK)</a>
<a name="ln4921">					break;</a>
<a name="ln4922"> </a>
<a name="ln4923">				BToolTip* tip;</a>
<a name="ln4924">				if (GetToolTipAt(where, &amp;tip))</a>
<a name="ln4925">					ShowToolTip(tip);</a>
<a name="ln4926">				else</a>
<a name="ln4927">					BHandler::MessageReceived(message);</a>
<a name="ln4928">				break;</a>
<a name="ln4929">			}</a>
<a name="ln4930"> </a>
<a name="ln4931">			case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln4932">			{</a>
<a name="ln4933">				BScrollBar* horizontal = ScrollBar(B_HORIZONTAL);</a>
<a name="ln4934">				BScrollBar* vertical = ScrollBar(B_VERTICAL);</a>
<a name="ln4935">				if (horizontal == NULL &amp;&amp; vertical == NULL) {</a>
<a name="ln4936">					// Pass the message to the next handler</a>
<a name="ln4937">					BHandler::MessageReceived(message);</a>
<a name="ln4938">					break;</a>
<a name="ln4939">				}</a>
<a name="ln4940"> </a>
<a name="ln4941">				float deltaX = 0.0f;</a>
<a name="ln4942">				float deltaY = 0.0f;</a>
<a name="ln4943"> </a>
<a name="ln4944">				if (horizontal != NULL)</a>
<a name="ln4945">					message-&gt;FindFloat(&quot;be:wheel_delta_x&quot;, &amp;deltaX);</a>
<a name="ln4946"> </a>
<a name="ln4947">				if (vertical != NULL)</a>
<a name="ln4948">					message-&gt;FindFloat(&quot;be:wheel_delta_y&quot;, &amp;deltaY);</a>
<a name="ln4949"> </a>
<a name="ln4950">				if (deltaX == 0.0f &amp;&amp; deltaY == 0.0f)</a>
<a name="ln4951">					break;</a>
<a name="ln4952"> </a>
<a name="ln4953">				if ((modifiers() &amp; B_CONTROL_KEY) != 0)</a>
<a name="ln4954">					std::swap(horizontal, vertical);</a>
<a name="ln4955"> </a>
<a name="ln4956">				if (horizontal != NULL &amp;&amp; deltaX != 0.0f)</a>
<a name="ln4957">					ScrollWithMouseWheelDelta(horizontal, deltaX);</a>
<a name="ln4958"> </a>
<a name="ln4959">				if (vertical != NULL &amp;&amp; deltaY != 0.0f)</a>
<a name="ln4960">					ScrollWithMouseWheelDelta(vertical, deltaY);</a>
<a name="ln4961"> </a>
<a name="ln4962">				break;</a>
<a name="ln4963">			}</a>
<a name="ln4964"> </a>
<a name="ln4965">			// prevent message repeats</a>
<a name="ln4966">			case B_COLORS_UPDATED:</a>
<a name="ln4967">			case B_FONTS_UPDATED:</a>
<a name="ln4968">				break;</a>
<a name="ln4969"> </a>
<a name="ln4970">			case B_SCREEN_CHANGED:</a>
<a name="ln4971">			{</a>
<a name="ln4972">				// propegate message to child views</a>
<a name="ln4973">				int32 childCount = CountChildren();</a>
<a name="ln4974">				for (int32 i = 0; i &lt; childCount; i++) {</a>
<a name="ln4975">					BView* view = ChildAt(i);</a>
<a name="ln4976">					if (view != NULL)</a>
<a name="ln4977">						view-&gt;MessageReceived(message);</a>
<a name="ln4978">				}</a>
<a name="ln4979">				break;</a>
<a name="ln4980">			}</a>
<a name="ln4981"> </a>
<a name="ln4982">			default:</a>
<a name="ln4983">				BHandler::MessageReceived(message);</a>
<a name="ln4984">				break;</a>
<a name="ln4985">		}</a>
<a name="ln4986"> </a>
<a name="ln4987">		return;</a>
<a name="ln4988">	}</a>
<a name="ln4989"> </a>
<a name="ln4990">	// Scripting message</a>
<a name="ln4991"> </a>
<a name="ln4992">	BMessage replyMsg(B_REPLY);</a>
<a name="ln4993">	status_t err = B_BAD_SCRIPT_SYNTAX;</a>
<a name="ln4994">	int32 index;</a>
<a name="ln4995">	BMessage specifier;</a>
<a name="ln4996">	int32 what;</a>
<a name="ln4997">	const char* property;</a>
<a name="ln4998"> </a>
<a name="ln4999">	if (message-&gt;GetCurrentSpecifier(&amp;index, &amp;specifier, &amp;what, &amp;property)</a>
<a name="ln5000">			!= B_OK) {</a>
<a name="ln5001">		return BHandler::MessageReceived(message);</a>
<a name="ln5002">	}</a>
<a name="ln5003"> </a>
<a name="ln5004">	BPropertyInfo propertyInfo(sViewPropInfo);</a>
<a name="ln5005">	switch (propertyInfo.FindMatch(message, index, &amp;specifier, what,</a>
<a name="ln5006">			property)) {</a>
<a name="ln5007">		case 0:</a>
<a name="ln5008">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln5009">				err = replyMsg.AddRect(&quot;result&quot;, Frame());</a>
<a name="ln5010">			} else if (message-&gt;what == B_SET_PROPERTY) {</a>
<a name="ln5011">				BRect newFrame;</a>
<a name="ln5012">				err = message-&gt;FindRect(&quot;data&quot;, &amp;newFrame);</a>
<a name="ln5013">				if (err == B_OK) {</a>
<a name="ln5014">					MoveTo(newFrame.LeftTop());</a>
<a name="ln5015">					ResizeTo(newFrame.Width(), newFrame.Height());</a>
<a name="ln5016">				}</a>
<a name="ln5017">			}</a>
<a name="ln5018">			break;</a>
<a name="ln5019">		case 1:</a>
<a name="ln5020">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln5021">				err = replyMsg.AddBool(&quot;result&quot;, IsHidden());</a>
<a name="ln5022">			} else if (message-&gt;what == B_SET_PROPERTY) {</a>
<a name="ln5023">				bool newHiddenState;</a>
<a name="ln5024">				err = message-&gt;FindBool(&quot;data&quot;, &amp;newHiddenState);</a>
<a name="ln5025">				if (err == B_OK) {</a>
<a name="ln5026">					if (newHiddenState == true)</a>
<a name="ln5027">						Hide();</a>
<a name="ln5028">					else</a>
<a name="ln5029">						Show();</a>
<a name="ln5030">				}</a>
<a name="ln5031">			}</a>
<a name="ln5032">			break;</a>
<a name="ln5033">		case 3:</a>
<a name="ln5034">			err = replyMsg.AddInt32(&quot;result&quot;, CountChildren());</a>
<a name="ln5035">			break;</a>
<a name="ln5036">		default:</a>
<a name="ln5037">			return BHandler::MessageReceived(message);</a>
<a name="ln5038">	}</a>
<a name="ln5039"> </a>
<a name="ln5040">	if (err != B_OK) {</a>
<a name="ln5041">		replyMsg.what = B_MESSAGE_NOT_UNDERSTOOD;</a>
<a name="ln5042"> </a>
<a name="ln5043">		if (err == B_BAD_SCRIPT_SYNTAX)</a>
<a name="ln5044">			replyMsg.AddString(&quot;message&quot;, &quot;Didn't understand the specifier(s)&quot;);</a>
<a name="ln5045">		else</a>
<a name="ln5046">			replyMsg.AddString(&quot;message&quot;, strerror(err));</a>
<a name="ln5047"> </a>
<a name="ln5048">		replyMsg.AddInt32(&quot;error&quot;, err);</a>
<a name="ln5049">	}</a>
<a name="ln5050"> </a>
<a name="ln5051">	message-&gt;SendReply(&amp;replyMsg);</a>
<a name="ln5052">}</a>
<a name="ln5053"> </a>
<a name="ln5054"> </a>
<a name="ln5055">status_t</a>
<a name="ln5056">BView::Perform(perform_code code, void* _data)</a>
<a name="ln5057">{</a>
<a name="ln5058">	switch (code) {</a>
<a name="ln5059">		case PERFORM_CODE_MIN_SIZE:</a>
<a name="ln5060">			((perform_data_min_size*)_data)-&gt;return_value</a>
<a name="ln5061">				= BView::MinSize();</a>
<a name="ln5062">			return B_OK;</a>
<a name="ln5063">		case PERFORM_CODE_MAX_SIZE:</a>
<a name="ln5064">			((perform_data_max_size*)_data)-&gt;return_value</a>
<a name="ln5065">				= BView::MaxSize();</a>
<a name="ln5066">			return B_OK;</a>
<a name="ln5067">		case PERFORM_CODE_PREFERRED_SIZE:</a>
<a name="ln5068">			((perform_data_preferred_size*)_data)-&gt;return_value</a>
<a name="ln5069">				= BView::PreferredSize();</a>
<a name="ln5070">			return B_OK;</a>
<a name="ln5071">		case PERFORM_CODE_LAYOUT_ALIGNMENT:</a>
<a name="ln5072">			((perform_data_layout_alignment*)_data)-&gt;return_value</a>
<a name="ln5073">				= BView::LayoutAlignment();</a>
<a name="ln5074">			return B_OK;</a>
<a name="ln5075">		case PERFORM_CODE_HAS_HEIGHT_FOR_WIDTH:</a>
<a name="ln5076">			((perform_data_has_height_for_width*)_data)-&gt;return_value</a>
<a name="ln5077">				= BView::HasHeightForWidth();</a>
<a name="ln5078">			return B_OK;</a>
<a name="ln5079">		case PERFORM_CODE_GET_HEIGHT_FOR_WIDTH:</a>
<a name="ln5080">		{</a>
<a name="ln5081">			perform_data_get_height_for_width* data</a>
<a name="ln5082">				= (perform_data_get_height_for_width*)_data;</a>
<a name="ln5083">			BView::GetHeightForWidth(data-&gt;width, &amp;data-&gt;min, &amp;data-&gt;max,</a>
<a name="ln5084">				&amp;data-&gt;preferred);</a>
<a name="ln5085">			return B_OK;</a>
<a name="ln5086">		}</a>
<a name="ln5087">		case PERFORM_CODE_SET_LAYOUT:</a>
<a name="ln5088">		{</a>
<a name="ln5089">			perform_data_set_layout* data = (perform_data_set_layout*)_data;</a>
<a name="ln5090">			BView::SetLayout(data-&gt;layout);</a>
<a name="ln5091">			return B_OK;</a>
<a name="ln5092">		}</a>
<a name="ln5093">		case PERFORM_CODE_LAYOUT_INVALIDATED:</a>
<a name="ln5094">		{</a>
<a name="ln5095">			perform_data_layout_invalidated* data</a>
<a name="ln5096">				= (perform_data_layout_invalidated*)_data;</a>
<a name="ln5097">			BView::LayoutInvalidated(data-&gt;descendants);</a>
<a name="ln5098">			return B_OK;</a>
<a name="ln5099">		}</a>
<a name="ln5100">		case PERFORM_CODE_DO_LAYOUT:</a>
<a name="ln5101">		{</a>
<a name="ln5102">			BView::DoLayout();</a>
<a name="ln5103">			return B_OK;</a>
<a name="ln5104">		}</a>
<a name="ln5105">		case PERFORM_CODE_LAYOUT_CHANGED:</a>
<a name="ln5106">		{</a>
<a name="ln5107">			BView::LayoutChanged();</a>
<a name="ln5108">			return B_OK;</a>
<a name="ln5109">		}</a>
<a name="ln5110">		case PERFORM_CODE_GET_TOOL_TIP_AT:</a>
<a name="ln5111">		{</a>
<a name="ln5112">			perform_data_get_tool_tip_at* data</a>
<a name="ln5113">				= (perform_data_get_tool_tip_at*)_data;</a>
<a name="ln5114">			data-&gt;return_value</a>
<a name="ln5115">				= BView::GetToolTipAt(data-&gt;point, data-&gt;tool_tip);</a>
<a name="ln5116">			return B_OK;</a>
<a name="ln5117">		}</a>
<a name="ln5118">		case PERFORM_CODE_ALL_UNARCHIVED:</a>
<a name="ln5119">		{</a>
<a name="ln5120">			perform_data_all_unarchived* data =</a>
<a name="ln5121">				(perform_data_all_unarchived*)_data;</a>
<a name="ln5122"> </a>
<a name="ln5123">			data-&gt;return_value = BView::AllUnarchived(data-&gt;archive);</a>
<a name="ln5124">			return B_OK;</a>
<a name="ln5125">		}</a>
<a name="ln5126">		case PERFORM_CODE_ALL_ARCHIVED:</a>
<a name="ln5127">		{</a>
<a name="ln5128">			perform_data_all_archived* data =</a>
<a name="ln5129">				(perform_data_all_archived*)_data;</a>
<a name="ln5130"> </a>
<a name="ln5131">			data-&gt;return_value = BView::AllArchived(data-&gt;archive);</a>
<a name="ln5132">			return B_OK;</a>
<a name="ln5133">		}</a>
<a name="ln5134">	}</a>
<a name="ln5135"> </a>
<a name="ln5136">	return BHandler::Perform(code, _data);</a>
<a name="ln5137">}</a>
<a name="ln5138"> </a>
<a name="ln5139"> </a>
<a name="ln5140">// #pragma mark - Layout Functions</a>
<a name="ln5141"> </a>
<a name="ln5142"> </a>
<a name="ln5143">BSize</a>
<a name="ln5144">BView::MinSize()</a>
<a name="ln5145">{</a>
<a name="ln5146">	// TODO: make sure this works correctly when some methods are overridden</a>
<a name="ln5147">	float width, height;</a>
<a name="ln5148">	GetPreferredSize(&amp;width, &amp;height);</a>
<a name="ln5149"> </a>
<a name="ln5150">	return BLayoutUtils::ComposeSize(fLayoutData-&gt;fMinSize,</a>
<a name="ln5151">		(fLayoutData-&gt;fLayout ? fLayoutData-&gt;fLayout-&gt;MinSize()</a>
<a name="ln5152">			: BSize(width, height)));</a>
<a name="ln5153">}</a>
<a name="ln5154"> </a>
<a name="ln5155"> </a>
<a name="ln5156">BSize</a>
<a name="ln5157">BView::MaxSize()</a>
<a name="ln5158">{</a>
<a name="ln5159">	return BLayoutUtils::ComposeSize(fLayoutData-&gt;fMaxSize,</a>
<a name="ln5160">		(fLayoutData-&gt;fLayout ? fLayoutData-&gt;fLayout-&gt;MaxSize()</a>
<a name="ln5161">			: BSize(B_SIZE_UNLIMITED, B_SIZE_UNLIMITED)));</a>
<a name="ln5162">}</a>
<a name="ln5163"> </a>
<a name="ln5164"> </a>
<a name="ln5165">BSize</a>
<a name="ln5166">BView::PreferredSize()</a>
<a name="ln5167">{</a>
<a name="ln5168">	// TODO: make sure this works correctly when some methods are overridden</a>
<a name="ln5169">	float width, height;</a>
<a name="ln5170">	GetPreferredSize(&amp;width, &amp;height);</a>
<a name="ln5171"> </a>
<a name="ln5172">	return BLayoutUtils::ComposeSize(fLayoutData-&gt;fPreferredSize,</a>
<a name="ln5173">		(fLayoutData-&gt;fLayout ? fLayoutData-&gt;fLayout-&gt;PreferredSize()</a>
<a name="ln5174">			: BSize(width, height)));</a>
<a name="ln5175">}</a>
<a name="ln5176"> </a>
<a name="ln5177"> </a>
<a name="ln5178">BAlignment</a>
<a name="ln5179">BView::LayoutAlignment()</a>
<a name="ln5180">{</a>
<a name="ln5181">	return BLayoutUtils::ComposeAlignment(fLayoutData-&gt;fAlignment,</a>
<a name="ln5182">		(fLayoutData-&gt;fLayout ? fLayoutData-&gt;fLayout-&gt;Alignment()</a>
<a name="ln5183">			: BAlignment(B_ALIGN_HORIZONTAL_CENTER, B_ALIGN_VERTICAL_CENTER)));</a>
<a name="ln5184">}</a>
<a name="ln5185"> </a>
<a name="ln5186"> </a>
<a name="ln5187">void</a>
<a name="ln5188">BView::SetExplicitMinSize(BSize size)</a>
<a name="ln5189">{</a>
<a name="ln5190">	fLayoutData-&gt;fMinSize = size;</a>
<a name="ln5191">	InvalidateLayout();</a>
<a name="ln5192">}</a>
<a name="ln5193"> </a>
<a name="ln5194"> </a>
<a name="ln5195">void</a>
<a name="ln5196">BView::SetExplicitMaxSize(BSize size)</a>
<a name="ln5197">{</a>
<a name="ln5198">	fLayoutData-&gt;fMaxSize = size;</a>
<a name="ln5199">	InvalidateLayout();</a>
<a name="ln5200">}</a>
<a name="ln5201"> </a>
<a name="ln5202"> </a>
<a name="ln5203">void</a>
<a name="ln5204">BView::SetExplicitPreferredSize(BSize size)</a>
<a name="ln5205">{</a>
<a name="ln5206">	fLayoutData-&gt;fPreferredSize = size;</a>
<a name="ln5207">	InvalidateLayout();</a>
<a name="ln5208">}</a>
<a name="ln5209"> </a>
<a name="ln5210"> </a>
<a name="ln5211">void</a>
<a name="ln5212">BView::SetExplicitSize(BSize size)</a>
<a name="ln5213">{</a>
<a name="ln5214">	fLayoutData-&gt;fMinSize = size;</a>
<a name="ln5215">	fLayoutData-&gt;fMaxSize = size;</a>
<a name="ln5216">	fLayoutData-&gt;fPreferredSize = size;</a>
<a name="ln5217">	InvalidateLayout();</a>
<a name="ln5218">}</a>
<a name="ln5219"> </a>
<a name="ln5220"> </a>
<a name="ln5221">void</a>
<a name="ln5222">BView::SetExplicitAlignment(BAlignment alignment)</a>
<a name="ln5223">{</a>
<a name="ln5224">	fLayoutData-&gt;fAlignment = alignment;</a>
<a name="ln5225">	InvalidateLayout();</a>
<a name="ln5226">}</a>
<a name="ln5227"> </a>
<a name="ln5228"> </a>
<a name="ln5229">BSize</a>
<a name="ln5230">BView::ExplicitMinSize() const</a>
<a name="ln5231">{</a>
<a name="ln5232">	return fLayoutData-&gt;fMinSize;</a>
<a name="ln5233">}</a>
<a name="ln5234"> </a>
<a name="ln5235"> </a>
<a name="ln5236">BSize</a>
<a name="ln5237">BView::ExplicitMaxSize() const</a>
<a name="ln5238">{</a>
<a name="ln5239">	return fLayoutData-&gt;fMaxSize;</a>
<a name="ln5240">}</a>
<a name="ln5241"> </a>
<a name="ln5242"> </a>
<a name="ln5243">BSize</a>
<a name="ln5244">BView::ExplicitPreferredSize() const</a>
<a name="ln5245">{</a>
<a name="ln5246">	return fLayoutData-&gt;fPreferredSize;</a>
<a name="ln5247">}</a>
<a name="ln5248"> </a>
<a name="ln5249"> </a>
<a name="ln5250">BAlignment</a>
<a name="ln5251">BView::ExplicitAlignment() const</a>
<a name="ln5252">{</a>
<a name="ln5253">	return fLayoutData-&gt;fAlignment;</a>
<a name="ln5254">}</a>
<a name="ln5255"> </a>
<a name="ln5256"> </a>
<a name="ln5257">bool</a>
<a name="ln5258">BView::HasHeightForWidth()</a>
<a name="ln5259">{</a>
<a name="ln5260">	return (fLayoutData-&gt;fLayout</a>
<a name="ln5261">		? fLayoutData-&gt;fLayout-&gt;HasHeightForWidth() : false);</a>
<a name="ln5262">}</a>
<a name="ln5263"> </a>
<a name="ln5264"> </a>
<a name="ln5265">void</a>
<a name="ln5266">BView::GetHeightForWidth(float width, float* min, float* max, float* preferred)</a>
<a name="ln5267">{</a>
<a name="ln5268">	if (fLayoutData-&gt;fLayout)</a>
<a name="ln5269">		fLayoutData-&gt;fLayout-&gt;GetHeightForWidth(width, min, max, preferred);</a>
<a name="ln5270">}</a>
<a name="ln5271"> </a>
<a name="ln5272"> </a>
<a name="ln5273">void</a>
<a name="ln5274">BView::SetLayout(BLayout* layout)</a>
<a name="ln5275">{</a>
<a name="ln5276">	if (layout == fLayoutData-&gt;fLayout)</a>
<a name="ln5277">		return;</a>
<a name="ln5278"> </a>
<a name="ln5279">	if (layout &amp;&amp; layout-&gt;Layout())</a>
<a name="ln5280">		debugger(&quot;BView::SetLayout() failed, layout is already in use.&quot;);</a>
<a name="ln5281"> </a>
<a name="ln5282">	fFlags |= B_SUPPORTS_LAYOUT;</a>
<a name="ln5283"> </a>
<a name="ln5284">	// unset and delete the old layout</a>
<a name="ln5285">	if (fLayoutData-&gt;fLayout) {</a>
<a name="ln5286">		fLayoutData-&gt;fLayout-&gt;RemoveSelf();</a>
<a name="ln5287">		fLayoutData-&gt;fLayout-&gt;SetOwner(NULL);</a>
<a name="ln5288">		delete fLayoutData-&gt;fLayout;</a>
<a name="ln5289">	}</a>
<a name="ln5290"> </a>
<a name="ln5291">	fLayoutData-&gt;fLayout = layout;</a>
<a name="ln5292"> </a>
<a name="ln5293">	if (fLayoutData-&gt;fLayout) {</a>
<a name="ln5294">		fLayoutData-&gt;fLayout-&gt;SetOwner(this);</a>
<a name="ln5295"> </a>
<a name="ln5296">		// add all children</a>
<a name="ln5297">		int count = CountChildren();</a>
<a name="ln5298">		for (int i = 0; i &lt; count; i++)</a>
<a name="ln5299">			fLayoutData-&gt;fLayout-&gt;AddView(ChildAt(i));</a>
<a name="ln5300">	}</a>
<a name="ln5301"> </a>
<a name="ln5302">	InvalidateLayout();</a>
<a name="ln5303">}</a>
<a name="ln5304"> </a>
<a name="ln5305"> </a>
<a name="ln5306">BLayout*</a>
<a name="ln5307">BView::GetLayout() const</a>
<a name="ln5308">{</a>
<a name="ln5309">	return fLayoutData-&gt;fLayout;</a>
<a name="ln5310">}</a>
<a name="ln5311"> </a>
<a name="ln5312"> </a>
<a name="ln5313">void</a>
<a name="ln5314">BView::InvalidateLayout(bool descendants)</a>
<a name="ln5315">{</a>
<a name="ln5316">	// printf(&quot;BView(%p)::InvalidateLayout(%i), valid: %i, inProgress: %i\n&quot;,</a>
<a name="ln5317">	//	this, descendants, fLayoutData-&gt;fLayoutValid,</a>
<a name="ln5318">	//	fLayoutData-&gt;fLayoutInProgress);</a>
<a name="ln5319"> </a>
<a name="ln5320">	if (!fLayoutData-&gt;fMinMaxValid || fLayoutData-&gt;fLayoutInProgress</a>
<a name="ln5321"> 			|| fLayoutData-&gt;fLayoutInvalidationDisabled &gt; 0) {</a>
<a name="ln5322">		return;</a>
<a name="ln5323">	}</a>
<a name="ln5324">	fLayoutData-&gt;fLayoutValid = false;</a>
<a name="ln5325">	fLayoutData-&gt;fMinMaxValid = false;</a>
<a name="ln5326">	LayoutInvalidated(descendants);</a>
<a name="ln5327"> </a>
<a name="ln5328">	if (descendants) {</a>
<a name="ln5329">		for (BView* child = fFirstChild;</a>
<a name="ln5330">			child; child = child-&gt;fNextSibling) {</a>
<a name="ln5331">			child-&gt;InvalidateLayout(descendants);</a>
<a name="ln5332">		}</a>
<a name="ln5333">	}</a>
<a name="ln5334"> </a>
<a name="ln5335">	if (fLayoutData-&gt;fLayout)</a>
<a name="ln5336">		fLayoutData-&gt;fLayout-&gt;InvalidateLayout(descendants);</a>
<a name="ln5337">	else</a>
<a name="ln5338">		_InvalidateParentLayout();</a>
<a name="ln5339"> </a>
<a name="ln5340">	if (fTopLevelView</a>
<a name="ln5341">		&amp;&amp; fOwner != NULL)</a>
<a name="ln5342">		fOwner-&gt;PostMessage(B_LAYOUT_WINDOW);</a>
<a name="ln5343">}</a>
<a name="ln5344"> </a>
<a name="ln5345"> </a>
<a name="ln5346">void</a>
<a name="ln5347">BView::EnableLayoutInvalidation()</a>
<a name="ln5348">{</a>
<a name="ln5349">	if (fLayoutData-&gt;fLayoutInvalidationDisabled &gt; 0)</a>
<a name="ln5350">		fLayoutData-&gt;fLayoutInvalidationDisabled--;</a>
<a name="ln5351">}</a>
<a name="ln5352"> </a>
<a name="ln5353"> </a>
<a name="ln5354">void</a>
<a name="ln5355">BView::DisableLayoutInvalidation()</a>
<a name="ln5356">{</a>
<a name="ln5357">	fLayoutData-&gt;fLayoutInvalidationDisabled++;</a>
<a name="ln5358">}</a>
<a name="ln5359"> </a>
<a name="ln5360"> </a>
<a name="ln5361">bool</a>
<a name="ln5362">BView::IsLayoutInvalidationDisabled()</a>
<a name="ln5363">{</a>
<a name="ln5364">	if (fLayoutData-&gt;fLayoutInvalidationDisabled &gt; 0)</a>
<a name="ln5365">		return true;</a>
<a name="ln5366">	return false;</a>
<a name="ln5367">}</a>
<a name="ln5368"> </a>
<a name="ln5369"> </a>
<a name="ln5370">bool</a>
<a name="ln5371">BView::IsLayoutValid() const</a>
<a name="ln5372">{</a>
<a name="ln5373">	return fLayoutData-&gt;fLayoutValid;</a>
<a name="ln5374">}</a>
<a name="ln5375"> </a>
<a name="ln5376"> </a>
<a name="ln5377">void</a>
<a name="ln5378">BView::ResetLayoutInvalidation()</a>
<a name="ln5379">{</a>
<a name="ln5380">	fLayoutData-&gt;fMinMaxValid = true;</a>
<a name="ln5381">}</a>
<a name="ln5382"> </a>
<a name="ln5383"> </a>
<a name="ln5384">BLayoutContext*</a>
<a name="ln5385">BView::LayoutContext() const</a>
<a name="ln5386">{</a>
<a name="ln5387">	return fLayoutData-&gt;fLayoutContext;</a>
<a name="ln5388">}</a>
<a name="ln5389"> </a>
<a name="ln5390"> </a>
<a name="ln5391">void</a>
<a name="ln5392">BView::Layout(bool force)</a>
<a name="ln5393">{</a>
<a name="ln5394">	BLayoutContext context;</a>
<a name="ln5395">	_Layout(force, &amp;context);</a>
<a name="ln5396">}</a>
<a name="ln5397"> </a>
<a name="ln5398"> </a>
<a name="ln5399">void</a>
<a name="ln5400">BView::Relayout()</a>
<a name="ln5401">{</a>
<a name="ln5402">	if (fLayoutData-&gt;fLayoutValid &amp;&amp; !fLayoutData-&gt;fLayoutInProgress) {</a>
<a name="ln5403">		fLayoutData-&gt;fNeedsRelayout = true;</a>
<a name="ln5404">		if (fLayoutData-&gt;fLayout)</a>
<a name="ln5405">			fLayoutData-&gt;fLayout-&gt;RequireLayout();</a>
<a name="ln5406"> </a>
<a name="ln5407">		// Layout() is recursive, that is if the parent view is currently laid</a>
<a name="ln5408">		// out, we don't call layout() on this view, but wait for the parent's</a>
<a name="ln5409">		// Layout() to do that for us.</a>
<a name="ln5410">		if (!fParent || !fParent-&gt;fLayoutData-&gt;fLayoutInProgress)</a>
<a name="ln5411">			Layout(false);</a>
<a name="ln5412">	}</a>
<a name="ln5413">}</a>
<a name="ln5414"> </a>
<a name="ln5415"> </a>
<a name="ln5416">void</a>
<a name="ln5417">BView::LayoutInvalidated(bool descendants)</a>
<a name="ln5418">{</a>
<a name="ln5419">	// hook method</a>
<a name="ln5420">}</a>
<a name="ln5421"> </a>
<a name="ln5422"> </a>
<a name="ln5423">void</a>
<a name="ln5424">BView::DoLayout()</a>
<a name="ln5425">{</a>
<a name="ln5426">	if (fLayoutData-&gt;fLayout)</a>
<a name="ln5427">		fLayoutData-&gt;fLayout-&gt;_LayoutWithinContext(false, LayoutContext());</a>
<a name="ln5428">}</a>
<a name="ln5429"> </a>
<a name="ln5430"> </a>
<a name="ln5431">void</a>
<a name="ln5432">BView::SetToolTip(const char* text)</a>
<a name="ln5433">{</a>
<a name="ln5434">	if (text == NULL || text[0] == '\0') {</a>
<a name="ln5435">		SetToolTip((BToolTip*)NULL);</a>
<a name="ln5436">		return;</a>
<a name="ln5437">	}</a>
<a name="ln5438"> </a>
<a name="ln5439">	if (BTextToolTip* tip = dynamic_cast&lt;BTextToolTip*&gt;(fToolTip))</a>
<a name="ln5440">		tip-&gt;SetText(text);</a>
<a name="ln5441">	else</a>
<a name="ln5442">		SetToolTip(new BTextToolTip(text));</a>
<a name="ln5443">}</a>
<a name="ln5444"> </a>
<a name="ln5445"> </a>
<a name="ln5446">void</a>
<a name="ln5447">BView::SetToolTip(BToolTip* tip)</a>
<a name="ln5448">{</a>
<a name="ln5449">	if (fToolTip == tip)</a>
<a name="ln5450">		return;</a>
<a name="ln5451">	else if (tip == NULL)</a>
<a name="ln5452">		HideToolTip();</a>
<a name="ln5453"> </a>
<a name="ln5454">	if (fToolTip != NULL)</a>
<a name="ln5455">		fToolTip-&gt;ReleaseReference();</a>
<a name="ln5456"> </a>
<a name="ln5457">	fToolTip = tip;</a>
<a name="ln5458"> </a>
<a name="ln5459">	if (fToolTip != NULL)</a>
<a name="ln5460">		fToolTip-&gt;AcquireReference();</a>
<a name="ln5461">}</a>
<a name="ln5462"> </a>
<a name="ln5463"> </a>
<a name="ln5464">BToolTip*</a>
<a name="ln5465">BView::ToolTip() const</a>
<a name="ln5466">{</a>
<a name="ln5467">	return fToolTip;</a>
<a name="ln5468">}</a>
<a name="ln5469"> </a>
<a name="ln5470"> </a>
<a name="ln5471">void</a>
<a name="ln5472">BView::ShowToolTip(BToolTip* tip)</a>
<a name="ln5473">{</a>
<a name="ln5474">	if (tip == NULL)</a>
<a name="ln5475">		return;</a>
<a name="ln5476"> </a>
<a name="ln5477">	BPoint where;</a>
<a name="ln5478">	GetMouse(&amp;where, NULL, false);</a>
<a name="ln5479"> </a>
<a name="ln5480">	BToolTipManager::Manager()-&gt;ShowTip(tip, ConvertToScreen(where), this);</a>
<a name="ln5481">}</a>
<a name="ln5482"> </a>
<a name="ln5483"> </a>
<a name="ln5484">void</a>
<a name="ln5485">BView::HideToolTip()</a>
<a name="ln5486">{</a>
<a name="ln5487">	BToolTipManager::Manager()-&gt;HideTip();</a>
<a name="ln5488">}</a>
<a name="ln5489"> </a>
<a name="ln5490"> </a>
<a name="ln5491">bool</a>
<a name="ln5492">BView::GetToolTipAt(BPoint point, BToolTip** _tip)</a>
<a name="ln5493">{</a>
<a name="ln5494">	if (fToolTip != NULL) {</a>
<a name="ln5495">		*_tip = fToolTip;</a>
<a name="ln5496">		return true;</a>
<a name="ln5497">	}</a>
<a name="ln5498"> </a>
<a name="ln5499">	*_tip = NULL;</a>
<a name="ln5500">	return false;</a>
<a name="ln5501">}</a>
<a name="ln5502"> </a>
<a name="ln5503"> </a>
<a name="ln5504">void</a>
<a name="ln5505">BView::LayoutChanged()</a>
<a name="ln5506">{</a>
<a name="ln5507">	// hook method</a>
<a name="ln5508">}</a>
<a name="ln5509"> </a>
<a name="ln5510"> </a>
<a name="ln5511">void</a>
<a name="ln5512">BView::_Layout(bool force, BLayoutContext* context)</a>
<a name="ln5513">{</a>
<a name="ln5514">//printf(&quot;%p-&gt;BView::_Layout(%d, %p)\n&quot;, this, force, context);</a>
<a name="ln5515">//printf(&quot;  fNeedsRelayout: %d, fLayoutValid: %d, fLayoutInProgress: %d\n&quot;,</a>
<a name="ln5516">//fLayoutData-&gt;fNeedsRelayout, fLayoutData-&gt;fLayoutValid,</a>
<a name="ln5517">//fLayoutData-&gt;fLayoutInProgress);</a>
<a name="ln5518">	if (fLayoutData-&gt;fNeedsRelayout || !fLayoutData-&gt;fLayoutValid || force) {</a>
<a name="ln5519">		fLayoutData-&gt;fLayoutValid = false;</a>
<a name="ln5520"> </a>
<a name="ln5521">		if (fLayoutData-&gt;fLayoutInProgress)</a>
<a name="ln5522">			return;</a>
<a name="ln5523"> </a>
<a name="ln5524">		BLayoutContext* oldContext = fLayoutData-&gt;fLayoutContext;</a>
<a name="ln5525">		fLayoutData-&gt;fLayoutContext = context;</a>
<a name="ln5526"> </a>
<a name="ln5527">		fLayoutData-&gt;fLayoutInProgress = true;</a>
<a name="ln5528">		DoLayout();</a>
<a name="ln5529">		fLayoutData-&gt;fLayoutInProgress = false;</a>
<a name="ln5530"> </a>
<a name="ln5531">		fLayoutData-&gt;fLayoutValid = true;</a>
<a name="ln5532">		fLayoutData-&gt;fMinMaxValid = true;</a>
<a name="ln5533">		fLayoutData-&gt;fNeedsRelayout = false;</a>
<a name="ln5534"> </a>
<a name="ln5535">		// layout children</a>
<a name="ln5536">		for(BView* child = fFirstChild; child; child = child-&gt;fNextSibling) {</a>
<a name="ln5537">			if (!child-&gt;IsHidden(child))</a>
<a name="ln5538">				child-&gt;_Layout(force, context);</a>
<a name="ln5539">		}</a>
<a name="ln5540"> </a>
<a name="ln5541">		LayoutChanged();</a>
<a name="ln5542"> </a>
<a name="ln5543">		fLayoutData-&gt;fLayoutContext = oldContext;</a>
<a name="ln5544"> </a>
<a name="ln5545">		// invalidate the drawn content, if requested</a>
<a name="ln5546">		if (fFlags &amp; B_INVALIDATE_AFTER_LAYOUT)</a>
<a name="ln5547">			Invalidate();</a>
<a name="ln5548">	}</a>
<a name="ln5549">}</a>
<a name="ln5550"> </a>
<a name="ln5551"> </a>
<a name="ln5552">void</a>
<a name="ln5553">BView::_LayoutLeft(BLayout* deleted)</a>
<a name="ln5554">{</a>
<a name="ln5555">	// If our layout is added to another layout (via BLayout::AddItem())</a>
<a name="ln5556">	// then we share ownership of our layout. In the event that our layout gets</a>
<a name="ln5557">	// deleted by the layout it has been added to, this method is called so</a>
<a name="ln5558">	// that we don't double-delete our layout.</a>
<a name="ln5559">	if (fLayoutData-&gt;fLayout == deleted)</a>
<a name="ln5560">		fLayoutData-&gt;fLayout = NULL;</a>
<a name="ln5561">	InvalidateLayout();</a>
<a name="ln5562">}</a>
<a name="ln5563"> </a>
<a name="ln5564"> </a>
<a name="ln5565">void</a>
<a name="ln5566">BView::_InvalidateParentLayout()</a>
<a name="ln5567">{</a>
<a name="ln5568">	if (!fParent)</a>
<a name="ln5569">		return;</a>
<a name="ln5570"> </a>
<a name="ln5571">	BLayout* layout = fLayoutData-&gt;fLayout;</a>
<a name="ln5572">	BLayout* layoutParent = layout ? layout-&gt;Layout() : NULL;</a>
<a name="ln5573">	if (layoutParent) {</a>
<a name="ln5574">		layoutParent-&gt;InvalidateLayout();</a>
<a name="ln5575">	} else if (fLayoutData-&gt;fLayoutItems.CountItems() &gt; 0) {</a>
<a name="ln5576">		int32 count = fLayoutData-&gt;fLayoutItems.CountItems();</a>
<a name="ln5577">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln5578">			fLayoutData-&gt;fLayoutItems.ItemAt(i)-&gt;Layout()-&gt;InvalidateLayout();</a>
<a name="ln5579">		}</a>
<a name="ln5580">	} else {</a>
<a name="ln5581">		fParent-&gt;InvalidateLayout();</a>
<a name="ln5582">	}</a>
<a name="ln5583">}</a>
<a name="ln5584"> </a>
<a name="ln5585"> </a>
<a name="ln5586">//	#pragma mark - Private Functions</a>
<a name="ln5587"> </a>
<a name="ln5588"> </a>
<a name="ln5589">void</a>
<a name="ln5590">BView::_InitData(BRect frame, const char* name, uint32 resizingMode,</a>
<a name="ln5591">	uint32 flags)</a>
<a name="ln5592">{</a>
<a name="ln5593">	// Info: The name of the view is set by BHandler constructor</a>
<a name="ln5594"> </a>
<a name="ln5595">	STRACE((&quot;BView::_InitData: enter\n&quot;));</a>
<a name="ln5596"> </a>
<a name="ln5597">	// initialize members</a>
<a name="ln5598">	if ((resizingMode &amp; ~_RESIZE_MASK_) || (flags &amp; _RESIZE_MASK_))</a>
<a name="ln5599">		printf(&quot;%s BView::_InitData(): resizing mode or flags swapped\n&quot;, name);</a>
<a name="ln5600"> </a>
<a name="ln5601">	// There are applications that swap the resize mask and the flags in the</a>
<a name="ln5602">	// BView constructor. This does not cause problems under BeOS as it just</a>
<a name="ln5603">	// ors the two fields to one 32bit flag.</a>
<a name="ln5604">	// For now we do the same but print the above warning message.</a>
<a name="ln5605">	// TODO: this should be removed at some point and the original</a>
<a name="ln5606">	// version restored:</a>
<a name="ln5607">	// fFlags = (resizingMode &amp; _RESIZE_MASK_) | (flags &amp; ~_RESIZE_MASK_);</a>
<a name="ln5608">	fFlags = resizingMode | flags;</a>
<a name="ln5609"> </a>
<a name="ln5610">	// handle rounding</a>
<a name="ln5611">	frame.left = roundf(frame.left);</a>
<a name="ln5612">	frame.top = roundf(frame.top);</a>
<a name="ln5613">	frame.right = roundf(frame.right);</a>
<a name="ln5614">	frame.bottom = roundf(frame.bottom);</a>
<a name="ln5615"> </a>
<a name="ln5616">	fParentOffset.Set(frame.left, frame.top);</a>
<a name="ln5617"> </a>
<a name="ln5618">	fOwner = NULL;</a>
<a name="ln5619">	fParent = NULL;</a>
<a name="ln5620">	fNextSibling = NULL;</a>
<a name="ln5621">	fPreviousSibling = NULL;</a>
<a name="ln5622">	fFirstChild = NULL;</a>
<a name="ln5623"> </a>
<a name="ln5624">	fShowLevel = 0;</a>
<a name="ln5625">	fTopLevelView = false;</a>
<a name="ln5626"> </a>
<a name="ln5627">	fCurrentPicture = NULL;</a>
<a name="ln5628">	fCommArray = NULL;</a>
<a name="ln5629"> </a>
<a name="ln5630">	fVerScroller = NULL;</a>
<a name="ln5631">	fHorScroller = NULL;</a>
<a name="ln5632"> </a>
<a name="ln5633">	fIsPrinting = false;</a>
<a name="ln5634">	fAttached = false;</a>
<a name="ln5635"> </a>
<a name="ln5636">	// TODO: Since we cannot communicate failure, we don't use std::nothrow here</a>
<a name="ln5637">	// TODO: Maybe we could auto-delete those views on AddChild() instead?</a>
<a name="ln5638">	fState = new BPrivate::ViewState;</a>
<a name="ln5639"> </a>
<a name="ln5640">	fBounds = frame.OffsetToCopy(B_ORIGIN);</a>
<a name="ln5641">	fShelf = NULL;</a>
<a name="ln5642"> </a>
<a name="ln5643">	fEventMask = 0;</a>
<a name="ln5644">	fEventOptions = 0;</a>
<a name="ln5645">	fMouseEventOptions = 0;</a>
<a name="ln5646"> </a>
<a name="ln5647">	fLayoutData = new LayoutData;</a>
<a name="ln5648"> </a>
<a name="ln5649">	fToolTip = NULL;</a>
<a name="ln5650"> </a>
<a name="ln5651">	if ((flags &amp; B_SUPPORTS_LAYOUT) != 0) {</a>
<a name="ln5652">		SetViewUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln5653">		SetLowUIColor(ViewUIColor());</a>
<a name="ln5654">		SetHighUIColor(B_PANEL_TEXT_COLOR);</a>
<a name="ln5655">	}</a>
<a name="ln5656">}</a>
<a name="ln5657"> </a>
<a name="ln5658"> </a>
<a name="ln5659">void</a>
<a name="ln5660">BView::_RemoveCommArray()</a>
<a name="ln5661">{</a>
<a name="ln5662">	if (fCommArray) {</a>
<a name="ln5663">		delete [] fCommArray-&gt;array;</a>
<a name="ln5664">		delete fCommArray;</a>
<a name="ln5665">		fCommArray = NULL;</a>
<a name="ln5666">	}</a>
<a name="ln5667">}</a>
<a name="ln5668"> </a>
<a name="ln5669"> </a>
<a name="ln5670">void</a>
<a name="ln5671">BView::_SetOwner(BWindow* newOwner)</a>
<a name="ln5672">{</a>
<a name="ln5673">	if (!newOwner)</a>
<a name="ln5674">		_RemoveCommArray();</a>
<a name="ln5675"> </a>
<a name="ln5676">	if (fOwner != newOwner &amp;&amp; fOwner) {</a>
<a name="ln5677">		if (fOwner-&gt;fFocus == this)</a>
<a name="ln5678">			MakeFocus(false);</a>
<a name="ln5679"> </a>
<a name="ln5680">		if (fOwner-&gt;fLastMouseMovedView == this)</a>
<a name="ln5681">			fOwner-&gt;fLastMouseMovedView = NULL;</a>
<a name="ln5682"> </a>
<a name="ln5683">		fOwner-&gt;RemoveHandler(this);</a>
<a name="ln5684">		if (fShelf)</a>
<a name="ln5685">			fOwner-&gt;RemoveHandler(fShelf);</a>
<a name="ln5686">	}</a>
<a name="ln5687"> </a>
<a name="ln5688">	if (newOwner &amp;&amp; newOwner != fOwner) {</a>
<a name="ln5689">		newOwner-&gt;AddHandler(this);</a>
<a name="ln5690">		if (fShelf)</a>
<a name="ln5691">			newOwner-&gt;AddHandler(fShelf);</a>
<a name="ln5692"> </a>
<a name="ln5693">		if (fTopLevelView)</a>
<a name="ln5694">			SetNextHandler(newOwner);</a>
<a name="ln5695">		else</a>
<a name="ln5696">			SetNextHandler(fParent);</a>
<a name="ln5697">	}</a>
<a name="ln5698"> </a>
<a name="ln5699">	fOwner = newOwner;</a>
<a name="ln5700"> </a>
<a name="ln5701">	for (BView* child = fFirstChild; child != NULL; child = child-&gt;fNextSibling)</a>
<a name="ln5702">		child-&gt;_SetOwner(newOwner);</a>
<a name="ln5703">}</a>
<a name="ln5704"> </a>
<a name="ln5705"> </a>
<a name="ln5706">void</a>
<a name="ln5707">BView::_ClipToPicture(BPicture* picture, BPoint where, bool invert, bool sync)</a>
<a name="ln5708">{</a>
<a name="ln5709">	if (!_CheckOwnerLockAndSwitchCurrent())</a>
<a name="ln5710">		return;</a>
<a name="ln5711"> </a>
<a name="ln5712">	if (picture == NULL) {</a>
<a name="ln5713">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_CLIP_TO_PICTURE);</a>
<a name="ln5714">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(-1);</a>
<a name="ln5715"> </a>
<a name="ln5716">		// NOTE: No need to sync here, since the -1 token cannot</a>
<a name="ln5717">		// become invalid on the server.</a>
<a name="ln5718">	} else {</a>
<a name="ln5719">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_CLIP_TO_PICTURE);</a>
<a name="ln5720">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(picture-&gt;Token());</a>
<a name="ln5721">		fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(where);</a>
<a name="ln5722">		fOwner-&gt;fLink-&gt;Attach&lt;bool&gt;(invert);</a>
<a name="ln5723"> </a>
<a name="ln5724">		// NOTE: &quot;sync&quot; defaults to true in public methods. If you know what</a>
<a name="ln5725">		// you are doing, i.e. if you know your BPicture stays valid, you</a>
<a name="ln5726">		// can avoid the performance impact of syncing. In a use-case where</a>
<a name="ln5727">		// the client creates BPictures on the stack, these BPictures may</a>
<a name="ln5728">		// have issued a AS_DELETE_PICTURE command to the ServerApp when Draw()</a>
<a name="ln5729">		// goes out of scope, and the command is processed earlier in the</a>
<a name="ln5730">		// ServerApp thread than the AS_VIEW_CLIP_TO_PICTURE command in the</a>
<a name="ln5731">		// ServerWindow thread, which will then have the result that no</a>
<a name="ln5732">		// ServerPicture is found of the token.</a>
<a name="ln5733">		if (sync)</a>
<a name="ln5734">			Sync();</a>
<a name="ln5735">	}</a>
<a name="ln5736">}</a>
<a name="ln5737"> </a>
<a name="ln5738"> </a>
<a name="ln5739">void</a>
<a name="ln5740">BView::_ClipToRect(BRect rect, bool inverse)</a>
<a name="ln5741">{</a>
<a name="ln5742">	if (_CheckOwnerLockAndSwitchCurrent()) {</a>
<a name="ln5743">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_CLIP_TO_RECT);</a>
<a name="ln5744">		fOwner-&gt;fLink-&gt;Attach&lt;bool&gt;(inverse);</a>
<a name="ln5745">		fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(rect);</a>
<a name="ln5746">		_FlushIfNotInTransaction();</a>
<a name="ln5747">	}</a>
<a name="ln5748">}</a>
<a name="ln5749"> </a>
<a name="ln5750"> </a>
<a name="ln5751">void</a>
<a name="ln5752">BView::_ClipToShape(BShape* shape, bool inverse)</a>
<a name="ln5753">{</a>
<a name="ln5754">	if (shape == NULL)</a>
<a name="ln5755">		return;</a>
<a name="ln5756"> </a>
<a name="ln5757">	shape_data* sd = (shape_data*)shape-&gt;fPrivateData;</a>
<a name="ln5758">	if (sd-&gt;opCount == 0 || sd-&gt;ptCount == 0)</a>
<a name="ln5759">		return;</a>
<a name="ln5760"> </a>
<a name="ln5761">	if (_CheckOwnerLockAndSwitchCurrent()) {</a>
<a name="ln5762">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_CLIP_TO_SHAPE);</a>
<a name="ln5763">		fOwner-&gt;fLink-&gt;Attach&lt;bool&gt;(inverse);</a>
<a name="ln5764">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(sd-&gt;opCount);</a>
<a name="ln5765">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(sd-&gt;ptCount);</a>
<a name="ln5766">		fOwner-&gt;fLink-&gt;Attach(sd-&gt;opList, sd-&gt;opCount * sizeof(uint32));</a>
<a name="ln5767">		fOwner-&gt;fLink-&gt;Attach(sd-&gt;ptList, sd-&gt;ptCount * sizeof(BPoint));</a>
<a name="ln5768">		_FlushIfNotInTransaction();</a>
<a name="ln5769">	}</a>
<a name="ln5770">}</a>
<a name="ln5771"> </a>
<a name="ln5772"> </a>
<a name="ln5773">bool</a>
<a name="ln5774">BView::_RemoveChildFromList(BView* child)</a>
<a name="ln5775">{</a>
<a name="ln5776">	if (child-&gt;fParent != this)</a>
<a name="ln5777">		return false;</a>
<a name="ln5778"> </a>
<a name="ln5779">	if (fFirstChild == child) {</a>
<a name="ln5780">		// it's the first view in the list</a>
<a name="ln5781">		fFirstChild = child-&gt;fNextSibling;</a>
<a name="ln5782">	} else {</a>
<a name="ln5783">		// there must be a previous sibling</a>
<a name="ln5784">		child-&gt;fPreviousSibling-&gt;fNextSibling = child-&gt;fNextSibling;</a>
<a name="ln5785">	}</a>
<a name="ln5786"> </a>
<a name="ln5787">	if (child-&gt;fNextSibling)</a>
<a name="ln5788">		child-&gt;fNextSibling-&gt;fPreviousSibling = child-&gt;fPreviousSibling;</a>
<a name="ln5789"> </a>
<a name="ln5790">	child-&gt;fParent = NULL;</a>
<a name="ln5791">	child-&gt;fNextSibling = NULL;</a>
<a name="ln5792">	child-&gt;fPreviousSibling = NULL;</a>
<a name="ln5793"> </a>
<a name="ln5794">	return true;</a>
<a name="ln5795">}</a>
<a name="ln5796"> </a>
<a name="ln5797"> </a>
<a name="ln5798">bool</a>
<a name="ln5799">BView::_AddChildToList(BView* child, BView* before)</a>
<a name="ln5800">{</a>
<a name="ln5801">	if (!child)</a>
<a name="ln5802">		return false;</a>
<a name="ln5803">	if (child-&gt;fParent != NULL) {</a>
<a name="ln5804">		debugger(&quot;View already belongs to someone else&quot;);</a>
<a name="ln5805">		return false;</a>
<a name="ln5806">	}</a>
<a name="ln5807">	if (before != NULL &amp;&amp; before-&gt;fParent != this) {</a>
<a name="ln5808">		debugger(&quot;Invalid before view&quot;);</a>
<a name="ln5809">		return false;</a>
<a name="ln5810">	}</a>
<a name="ln5811"> </a>
<a name="ln5812">	if (before != NULL) {</a>
<a name="ln5813">		// add view before this one</a>
<a name="ln5814">		child-&gt;fNextSibling = before;</a>
<a name="ln5815">		child-&gt;fPreviousSibling = before-&gt;fPreviousSibling;</a>
<a name="ln5816">		if (child-&gt;fPreviousSibling != NULL)</a>
<a name="ln5817">			child-&gt;fPreviousSibling-&gt;fNextSibling = child;</a>
<a name="ln5818"> </a>
<a name="ln5819">		before-&gt;fPreviousSibling = child;</a>
<a name="ln5820">		if (fFirstChild == before)</a>
<a name="ln5821">			fFirstChild = child;</a>
<a name="ln5822">	} else {</a>
<a name="ln5823">		// add view to the end of the list</a>
<a name="ln5824">		BView* last = fFirstChild;</a>
<a name="ln5825">		while (last != NULL &amp;&amp; last-&gt;fNextSibling != NULL) {</a>
<a name="ln5826">			last = last-&gt;fNextSibling;</a>
<a name="ln5827">		}</a>
<a name="ln5828"> </a>
<a name="ln5829">		if (last != NULL) {</a>
<a name="ln5830">			last-&gt;fNextSibling = child;</a>
<a name="ln5831">			child-&gt;fPreviousSibling = last;</a>
<a name="ln5832">		} else {</a>
<a name="ln5833">			fFirstChild = child;</a>
<a name="ln5834">			child-&gt;fPreviousSibling = NULL;</a>
<a name="ln5835">		}</a>
<a name="ln5836"> </a>
<a name="ln5837">		child-&gt;fNextSibling = NULL;</a>
<a name="ln5838">	}</a>
<a name="ln5839"> </a>
<a name="ln5840">	child-&gt;fParent = this;</a>
<a name="ln5841">	return true;</a>
<a name="ln5842">}</a>
<a name="ln5843"> </a>
<a name="ln5844"> </a>
<a name="ln5845">/*!	\brief Creates the server counterpart of this view.</a>
<a name="ln5846">	This is only done for views that are part of the view hierarchy, ie. when</a>
<a name="ln5847">	they are attached to a window.</a>
<a name="ln5848">	RemoveSelf() deletes the server object again.</a>
<a name="ln5849">*/</a>
<a name="ln5850">bool</a>
<a name="ln5851">BView::_CreateSelf()</a>
<a name="ln5852">{</a>
<a name="ln5853">	// AS_VIEW_CREATE &amp; AS_VIEW_CREATE_ROOT do not use the</a>
<a name="ln5854">	// current view mechanism via _CheckLockAndSwitchCurrent() - the token</a>
<a name="ln5855">	// of the view and its parent are both send to the server.</a>
<a name="ln5856"> </a>
<a name="ln5857">	if (fTopLevelView)</a>
<a name="ln5858">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_CREATE_ROOT);</a>
<a name="ln5859">	else</a>
<a name="ln5860"> 		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_CREATE);</a>
<a name="ln5861"> </a>
<a name="ln5862">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(_get_object_token_(this));</a>
<a name="ln5863">	fOwner-&gt;fLink-&gt;AttachString(Name());</a>
<a name="ln5864">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(Frame());</a>
<a name="ln5865">	fOwner-&gt;fLink-&gt;Attach&lt;BPoint&gt;(LeftTop());</a>
<a name="ln5866">	fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(ResizingMode());</a>
<a name="ln5867">	fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(fEventMask);</a>
<a name="ln5868">	fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(fEventOptions);</a>
<a name="ln5869">	fOwner-&gt;fLink-&gt;Attach&lt;uint32&gt;(Flags());</a>
<a name="ln5870">	fOwner-&gt;fLink-&gt;Attach&lt;bool&gt;(IsHidden(this));</a>
<a name="ln5871">	fOwner-&gt;fLink-&gt;Attach&lt;rgb_color&gt;(fState-&gt;view_color);</a>
<a name="ln5872">	if (fTopLevelView)</a>
<a name="ln5873">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(B_NULL_TOKEN);</a>
<a name="ln5874">	else</a>
<a name="ln5875">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(_get_object_token_(fParent));</a>
<a name="ln5876">	fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln5877"> </a>
<a name="ln5878">	_CheckOwnerLockAndSwitchCurrent();</a>
<a name="ln5879">	fState-&gt;UpdateServerState(*fOwner-&gt;fLink);</a>
<a name="ln5880"> </a>
<a name="ln5881">	// we create all its children, too</a>
<a name="ln5882"> </a>
<a name="ln5883">	for (BView* child = fFirstChild; child != NULL;</a>
<a name="ln5884">			child = child-&gt;fNextSibling) {</a>
<a name="ln5885">		child-&gt;_CreateSelf();</a>
<a name="ln5886">	}</a>
<a name="ln5887"> </a>
<a name="ln5888">	fOwner-&gt;fLink-&gt;Flush();</a>
<a name="ln5889">	return true;</a>
<a name="ln5890">}</a>
<a name="ln5891"> </a>
<a name="ln5892"> </a>
<a name="ln5893">/*!	Sets the new view position.</a>
<a name="ln5894">	It doesn't contact the server, though - the only case where this</a>
<a name="ln5895">	is called outside of MoveTo() is as reaction of moving a view</a>
<a name="ln5896">	in the server (a.k.a. B_WINDOW_RESIZED).</a>
<a name="ln5897">	It also calls the BView's FrameMoved() hook.</a>
<a name="ln5898">*/</a>
<a name="ln5899">void</a>
<a name="ln5900">BView::_MoveTo(int32 x, int32 y)</a>
<a name="ln5901">{</a>
<a name="ln5902">	fParentOffset.Set(x, y);</a>
<a name="ln5903"> </a>
<a name="ln5904">	if (Window() != NULL &amp;&amp; fFlags &amp; B_FRAME_EVENTS) {</a>
<a name="ln5905">		BMessage moved(B_VIEW_MOVED);</a>
<a name="ln5906">		moved.AddInt64(&quot;when&quot;, system_time());</a>
<a name="ln5907">		moved.AddPoint(&quot;where&quot;, BPoint(x, y));</a>
<a name="ln5908"> </a>
<a name="ln5909">		BMessenger target(this);</a>
<a name="ln5910">		target.SendMessage(&amp;moved);</a>
<a name="ln5911">	}</a>
<a name="ln5912">}</a>
<a name="ln5913"> </a>
<a name="ln5914"> </a>
<a name="ln5915">/*!	Computes the actual new frame size and recalculates the size of</a>
<a name="ln5916">	the children as well.</a>
<a name="ln5917">	It doesn't contact the server, though - the only case where this</a>
<a name="ln5918">	is called outside of ResizeBy() is as reaction of resizing a view</a>
<a name="ln5919">	in the server (a.k.a. B_WINDOW_RESIZED).</a>
<a name="ln5920">	It also calls the BView's FrameResized() hook.</a>
<a name="ln5921">*/</a>
<a name="ln5922">void</a>
<a name="ln5923">BView::_ResizeBy(int32 deltaWidth, int32 deltaHeight)</a>
<a name="ln5924">{</a>
<a name="ln5925">	fBounds.right += deltaWidth;</a>
<a name="ln5926">	fBounds.bottom += deltaHeight;</a>
<a name="ln5927"> </a>
<a name="ln5928">	if (Window() == NULL) {</a>
<a name="ln5929">		// we're not supposed to exercise the resizing code in case</a>
<a name="ln5930">		// we haven't been attached to a window yet</a>
<a name="ln5931">		return;</a>
<a name="ln5932">	}</a>
<a name="ln5933"> </a>
<a name="ln5934">	// layout the children</a>
<a name="ln5935">	if ((fFlags &amp; B_SUPPORTS_LAYOUT) != 0) {</a>
<a name="ln5936">		Relayout();</a>
<a name="ln5937">	} else {</a>
<a name="ln5938">		for (BView* child = fFirstChild; child; child = child-&gt;fNextSibling)</a>
<a name="ln5939">			child-&gt;_ParentResizedBy(deltaWidth, deltaHeight);</a>
<a name="ln5940">	}</a>
<a name="ln5941"> </a>
<a name="ln5942">	if (fFlags &amp; B_FRAME_EVENTS) {</a>
<a name="ln5943">		BMessage resized(B_VIEW_RESIZED);</a>
<a name="ln5944">		resized.AddInt64(&quot;when&quot;, system_time());</a>
<a name="ln5945">		resized.AddInt32(&quot;width&quot;, fBounds.IntegerWidth());</a>
<a name="ln5946">		resized.AddInt32(&quot;height&quot;, fBounds.IntegerHeight());</a>
<a name="ln5947"> </a>
<a name="ln5948">		BMessenger target(this);</a>
<a name="ln5949">		target.SendMessage(&amp;resized);</a>
<a name="ln5950">	}</a>
<a name="ln5951">}</a>
<a name="ln5952"> </a>
<a name="ln5953"> </a>
<a name="ln5954">/*!	Relayouts the view according to its resizing mode. */</a>
<a name="ln5955">void</a>
<a name="ln5956">BView::_ParentResizedBy(int32 x, int32 y)</a>
<a name="ln5957">{</a>
<a name="ln5958">	uint32 resizingMode = fFlags &amp; _RESIZE_MASK_;</a>
<a name="ln5959">	BRect newFrame = Frame();</a>
<a name="ln5960"> </a>
<a name="ln5961">	// follow with left side</a>
<a name="ln5962">	if ((resizingMode &amp; 0x0F00U) == _VIEW_RIGHT_ &lt;&lt; 8)</a>
<a name="ln5963">		newFrame.left += x;</a>
<a name="ln5964">	else if ((resizingMode &amp; 0x0F00U) == _VIEW_CENTER_ &lt;&lt; 8)</a>
<a name="ln5965">		newFrame.left += x / 2;</a>
<a name="ln5966"> </a>
<a name="ln5967">	// follow with right side</a>
<a name="ln5968">	if ((resizingMode &amp; 0x000FU) == _VIEW_RIGHT_)</a>
<a name="ln5969">		newFrame.right += x;</a>
<a name="ln5970">	else if ((resizingMode &amp; 0x000FU) == _VIEW_CENTER_)</a>
<a name="ln5971">		newFrame.right += x / 2;</a>
<a name="ln5972"> </a>
<a name="ln5973">	// follow with top side</a>
<a name="ln5974">	if ((resizingMode &amp; 0xF000U) == _VIEW_BOTTOM_ &lt;&lt; 12)</a>
<a name="ln5975">		newFrame.top += y;</a>
<a name="ln5976">	else if ((resizingMode &amp; 0xF000U) == _VIEW_CENTER_ &lt;&lt; 12)</a>
<a name="ln5977">		newFrame.top += y / 2;</a>
<a name="ln5978"> </a>
<a name="ln5979">	// follow with bottom side</a>
<a name="ln5980">	if ((resizingMode &amp; 0x00F0U) == _VIEW_BOTTOM_ &lt;&lt; 4)</a>
<a name="ln5981">		newFrame.bottom += y;</a>
<a name="ln5982">	else if ((resizingMode &amp; 0x00F0U) == _VIEW_CENTER_ &lt;&lt; 4)</a>
<a name="ln5983">		newFrame.bottom += y / 2;</a>
<a name="ln5984"> </a>
<a name="ln5985">	if (newFrame.LeftTop() != fParentOffset) {</a>
<a name="ln5986">		// move view</a>
<a name="ln5987">		_MoveTo((int32)roundf(newFrame.left), (int32)roundf(newFrame.top));</a>
<a name="ln5988">	}</a>
<a name="ln5989"> </a>
<a name="ln5990">	if (newFrame != Frame()) {</a>
<a name="ln5991">		// resize view</a>
<a name="ln5992">		int32 widthDiff = (int32)(newFrame.Width() - fBounds.Width());</a>
<a name="ln5993">		int32 heightDiff = (int32)(newFrame.Height() - fBounds.Height());</a>
<a name="ln5994">		_ResizeBy(widthDiff, heightDiff);</a>
<a name="ln5995">	}</a>
<a name="ln5996">}</a>
<a name="ln5997"> </a>
<a name="ln5998"> </a>
<a name="ln5999">void</a>
<a name="ln6000">BView::_Activate(bool active)</a>
<a name="ln6001">{</a>
<a name="ln6002">	WindowActivated(active);</a>
<a name="ln6003"> </a>
<a name="ln6004">	for (BView* child = fFirstChild; child != NULL;</a>
<a name="ln6005">			child = child-&gt;fNextSibling) {</a>
<a name="ln6006">		child-&gt;_Activate(active);</a>
<a name="ln6007">	}</a>
<a name="ln6008">}</a>
<a name="ln6009"> </a>
<a name="ln6010"> </a>
<a name="ln6011">void</a>
<a name="ln6012">BView::_Attach()</a>
<a name="ln6013">{</a>
<a name="ln6014">	if (fOwner != NULL) {</a>
<a name="ln6015">		// unmask state flags to force [re]syncing with the app_server</a>
<a name="ln6016">		fState-&gt;valid_flags &amp;= ~(B_VIEW_WHICH_VIEW_COLOR_BIT</a>
<a name="ln6017">			| B_VIEW_WHICH_LOW_COLOR_BIT | B_VIEW_WHICH_HIGH_COLOR_BIT);</a>
<a name="ln6018"> </a>
<a name="ln6019">		if (fState-&gt;which_view_color != B_NO_COLOR)</a>
<a name="ln6020">			SetViewUIColor(fState-&gt;which_view_color,</a>
<a name="ln6021">				fState-&gt;which_view_color_tint);</a>
<a name="ln6022"> </a>
<a name="ln6023">		if (fState-&gt;which_high_color != B_NO_COLOR)</a>
<a name="ln6024">			SetHighUIColor(fState-&gt;which_high_color,</a>
<a name="ln6025">				fState-&gt;which_high_color_tint);</a>
<a name="ln6026"> </a>
<a name="ln6027">		if (fState-&gt;which_low_color != B_NO_COLOR)</a>
<a name="ln6028">			SetLowUIColor(fState-&gt;which_low_color,</a>
<a name="ln6029">				fState-&gt;which_low_color_tint);</a>
<a name="ln6030">	}</a>
<a name="ln6031"> </a>
<a name="ln6032">	AttachedToWindow();</a>
<a name="ln6033"> </a>
<a name="ln6034">	fAttached = true;</a>
<a name="ln6035"> </a>
<a name="ln6036">	// after giving the view a chance to do this itself,</a>
<a name="ln6037">	// check for the B_PULSE_NEEDED flag and make sure the</a>
<a name="ln6038">	// window set's up the pulse messaging</a>
<a name="ln6039">	if (fOwner) {</a>
<a name="ln6040">		if (fFlags &amp; B_PULSE_NEEDED) {</a>
<a name="ln6041">			_CheckLock();</a>
<a name="ln6042">			if (fOwner-&gt;fPulseRunner == NULL)</a>
<a name="ln6043">				fOwner-&gt;SetPulseRate(fOwner-&gt;PulseRate());</a>
<a name="ln6044">		}</a>
<a name="ln6045"> </a>
<a name="ln6046">		if (!fOwner-&gt;IsHidden())</a>
<a name="ln6047">			Invalidate();</a>
<a name="ln6048">	}</a>
<a name="ln6049"> </a>
<a name="ln6050">	for (BView* child = fFirstChild; child != NULL;</a>
<a name="ln6051">			child = child-&gt;fNextSibling) {</a>
<a name="ln6052">		// we need to check for fAttached as new views could have been</a>
<a name="ln6053">		// added in AttachedToWindow() - and those are already attached</a>
<a name="ln6054">		if (!child-&gt;fAttached)</a>
<a name="ln6055">			child-&gt;_Attach();</a>
<a name="ln6056">	}</a>
<a name="ln6057"> </a>
<a name="ln6058">	AllAttached();</a>
<a name="ln6059">}</a>
<a name="ln6060"> </a>
<a name="ln6061"> </a>
<a name="ln6062">void</a>
<a name="ln6063">BView::_ColorsUpdated(BMessage* message)</a>
<a name="ln6064">{</a>
<a name="ln6065">	if (fTopLevelView</a>
<a name="ln6066">		&amp;&amp; fLayoutData-&gt;fLayout != NULL</a>
<a name="ln6067">		&amp;&amp; !fState-&gt;IsValid(B_VIEW_WHICH_VIEW_COLOR_BIT)) {</a>
<a name="ln6068">		SetViewUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln6069">		SetHighUIColor(B_PANEL_TEXT_COLOR);</a>
<a name="ln6070">	}</a>
<a name="ln6071"> </a>
<a name="ln6072">	rgb_color color;</a>
<a name="ln6073"> </a>
<a name="ln6074">	const char* colorName = ui_color_name(fState-&gt;which_view_color);</a>
<a name="ln6075">	if (colorName != NULL &amp;&amp; message-&gt;FindColor(colorName, &amp;color) == B_OK) {</a>
<a name="ln6076">		fState-&gt;view_color = tint_color(color, fState-&gt;which_view_color_tint);</a>
<a name="ln6077">		fState-&gt;valid_flags |= B_VIEW_VIEW_COLOR_BIT;</a>
<a name="ln6078">	}</a>
<a name="ln6079"> </a>
<a name="ln6080">	colorName = ui_color_name(fState-&gt;which_low_color);</a>
<a name="ln6081">	if (colorName != NULL &amp;&amp; message-&gt;FindColor(colorName, &amp;color) == B_OK) {</a>
<a name="ln6082">		fState-&gt;low_color = tint_color(color, fState-&gt;which_low_color_tint);</a>
<a name="ln6083">		fState-&gt;valid_flags |= B_VIEW_LOW_COLOR_BIT;</a>
<a name="ln6084">	}</a>
<a name="ln6085"> </a>
<a name="ln6086">	colorName = ui_color_name(fState-&gt;which_high_color);</a>
<a name="ln6087">	if (colorName != NULL &amp;&amp; message-&gt;FindColor(colorName, &amp;color) == B_OK) {</a>
<a name="ln6088">		fState-&gt;high_color = tint_color(color, fState-&gt;which_high_color_tint);</a>
<a name="ln6089">		fState-&gt;valid_flags |= B_VIEW_HIGH_COLOR_BIT;</a>
<a name="ln6090">	}</a>
<a name="ln6091"> </a>
<a name="ln6092">	MessageReceived(message);</a>
<a name="ln6093"> </a>
<a name="ln6094">	for (BView* child = fFirstChild; child != NULL;</a>
<a name="ln6095">			child = child-&gt;fNextSibling)</a>
<a name="ln6096">		child-&gt;_ColorsUpdated(message);</a>
<a name="ln6097"> </a>
<a name="ln6098">	Invalidate();</a>
<a name="ln6099">}</a>
<a name="ln6100"> </a>
<a name="ln6101"> </a>
<a name="ln6102">void</a>
<a name="ln6103">BView::_Detach()</a>
<a name="ln6104">{</a>
<a name="ln6105">	DetachedFromWindow();</a>
<a name="ln6106">	fAttached = false;</a>
<a name="ln6107"> </a>
<a name="ln6108">	for (BView* child = fFirstChild; child != NULL;</a>
<a name="ln6109">			child = child-&gt;fNextSibling) {</a>
<a name="ln6110">		child-&gt;_Detach();</a>
<a name="ln6111">	}</a>
<a name="ln6112"> </a>
<a name="ln6113">	AllDetached();</a>
<a name="ln6114"> </a>
<a name="ln6115">	if (fOwner) {</a>
<a name="ln6116">		_CheckLock();</a>
<a name="ln6117"> </a>
<a name="ln6118">		if (!fOwner-&gt;IsHidden())</a>
<a name="ln6119">			Invalidate();</a>
<a name="ln6120"> </a>
<a name="ln6121">		// make sure our owner doesn't need us anymore</a>
<a name="ln6122"> </a>
<a name="ln6123">		if (fOwner-&gt;CurrentFocus() == this) {</a>
<a name="ln6124">			MakeFocus(false);</a>
<a name="ln6125">			// MakeFocus() is virtual and might not be</a>
<a name="ln6126">			// passing through to the BView version,</a>
<a name="ln6127">			// but we need to make sure at this point</a>
<a name="ln6128">			// that we are not the focus view anymore.</a>
<a name="ln6129">			if (fOwner-&gt;CurrentFocus() == this)</a>
<a name="ln6130">				fOwner-&gt;_SetFocus(NULL, true);</a>
<a name="ln6131">		}</a>
<a name="ln6132"> </a>
<a name="ln6133">		if (fOwner-&gt;fDefaultButton == this)</a>
<a name="ln6134">			fOwner-&gt;SetDefaultButton(NULL);</a>
<a name="ln6135"> </a>
<a name="ln6136">		if (fOwner-&gt;fKeyMenuBar == this)</a>
<a name="ln6137">			fOwner-&gt;fKeyMenuBar = NULL;</a>
<a name="ln6138"> </a>
<a name="ln6139">		if (fOwner-&gt;fLastMouseMovedView == this)</a>
<a name="ln6140">			fOwner-&gt;fLastMouseMovedView = NULL;</a>
<a name="ln6141"> </a>
<a name="ln6142">		if (fOwner-&gt;fLastViewToken == _get_object_token_(this))</a>
<a name="ln6143">			fOwner-&gt;fLastViewToken = B_NULL_TOKEN;</a>
<a name="ln6144"> </a>
<a name="ln6145">		_SetOwner(NULL);</a>
<a name="ln6146">	}</a>
<a name="ln6147">}</a>
<a name="ln6148"> </a>
<a name="ln6149"> </a>
<a name="ln6150">void</a>
<a name="ln6151">BView::_Draw(BRect updateRect)</a>
<a name="ln6152">{</a>
<a name="ln6153">	if (IsHidden(this) || !(Flags() &amp; B_WILL_DRAW))</a>
<a name="ln6154">		return;</a>
<a name="ln6155"> </a>
<a name="ln6156">	// NOTE: if ViewColor() == B_TRANSPARENT_COLOR and no B_WILL_DRAW</a>
<a name="ln6157">	// -&gt; View is simply not drawn at all</a>
<a name="ln6158"> </a>
<a name="ln6159">	_SwitchServerCurrentView();</a>
<a name="ln6160"> </a>
<a name="ln6161">	ConvertFromScreen(&amp;updateRect);</a>
<a name="ln6162"> </a>
<a name="ln6163">	// TODO: make states robust (the hook implementation could</a>
<a name="ln6164">	// mess things up if it uses non-matching Push- and PopState(),</a>
<a name="ln6165">	// we would not be guaranteed to still have the same state on</a>
<a name="ln6166">	// the stack after having called Draw())</a>
<a name="ln6167">	PushState();</a>
<a name="ln6168">	Draw(updateRect);</a>
<a name="ln6169">	PopState();</a>
<a name="ln6170">	Flush();</a>
<a name="ln6171">}</a>
<a name="ln6172"> </a>
<a name="ln6173"> </a>
<a name="ln6174">void</a>
<a name="ln6175">BView::_DrawAfterChildren(BRect updateRect)</a>
<a name="ln6176">{</a>
<a name="ln6177">	if (IsHidden(this) || !(Flags() &amp; B_WILL_DRAW)</a>
<a name="ln6178">		|| !(Flags() &amp; B_DRAW_ON_CHILDREN))</a>
<a name="ln6179">		return;</a>
<a name="ln6180"> </a>
<a name="ln6181">	_SwitchServerCurrentView();</a>
<a name="ln6182"> </a>
<a name="ln6183">	ConvertFromScreen(&amp;updateRect);</a>
<a name="ln6184"> </a>
<a name="ln6185">	// TODO: make states robust (see above)</a>
<a name="ln6186">	PushState();</a>
<a name="ln6187">	DrawAfterChildren(updateRect);</a>
<a name="ln6188">	PopState();</a>
<a name="ln6189">	Flush();</a>
<a name="ln6190">}</a>
<a name="ln6191"> </a>
<a name="ln6192"> </a>
<a name="ln6193">void</a>
<a name="ln6194">BView::_FontsUpdated(BMessage* message)</a>
<a name="ln6195">{</a>
<a name="ln6196">	MessageReceived(message);</a>
<a name="ln6197"> </a>
<a name="ln6198">	for (BView* child = fFirstChild; child != NULL;</a>
<a name="ln6199">			child = child-&gt;fNextSibling) {</a>
<a name="ln6200">		child-&gt;_FontsUpdated(message);</a>
<a name="ln6201">	}</a>
<a name="ln6202">}</a>
<a name="ln6203"> </a>
<a name="ln6204"> </a>
<a name="ln6205">void</a>
<a name="ln6206">BView::_Pulse()</a>
<a name="ln6207">{</a>
<a name="ln6208">	if ((Flags() &amp; B_PULSE_NEEDED) != 0)</a>
<a name="ln6209">		Pulse();</a>
<a name="ln6210"> </a>
<a name="ln6211">	for (BView* child = fFirstChild; child != NULL;</a>
<a name="ln6212">			child = child-&gt;fNextSibling) {</a>
<a name="ln6213">		child-&gt;_Pulse();</a>
<a name="ln6214">	}</a>
<a name="ln6215">}</a>
<a name="ln6216"> </a>
<a name="ln6217"> </a>
<a name="ln6218">void</a>
<a name="ln6219">BView::_UpdateStateForRemove()</a>
<a name="ln6220">{</a>
<a name="ln6221">	// TODO: _CheckLockAndSwitchCurrent() would be good enough, no?</a>
<a name="ln6222">	if (!_CheckOwnerLockAndSwitchCurrent())</a>
<a name="ln6223">		return;</a>
<a name="ln6224"> </a>
<a name="ln6225">	fState-&gt;UpdateFrom(*fOwner-&gt;fLink);</a>
<a name="ln6226">//	if (!fState-&gt;IsValid(B_VIEW_FRAME_BIT)) {</a>
<a name="ln6227">//		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_GET_COORD);</a>
<a name="ln6228">//</a>
<a name="ln6229">//		status_t code;</a>
<a name="ln6230">//		if (fOwner-&gt;fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln6231">//			&amp;&amp; code == B_OK) {</a>
<a name="ln6232">//			fOwner-&gt;fLink-&gt;Read&lt;BPoint&gt;(&amp;fParentOffset);</a>
<a name="ln6233">//			fOwner-&gt;fLink-&gt;Read&lt;BRect&gt;(&amp;fBounds);</a>
<a name="ln6234">//			fState-&gt;valid_flags |= B_VIEW_FRAME_BIT;</a>
<a name="ln6235">//		}</a>
<a name="ln6236">//	}</a>
<a name="ln6237"> </a>
<a name="ln6238">	// update children as well</a>
<a name="ln6239"> </a>
<a name="ln6240">	for (BView* child = fFirstChild; child != NULL;</a>
<a name="ln6241">			child = child-&gt;fNextSibling) {</a>
<a name="ln6242">		if (child-&gt;fOwner)</a>
<a name="ln6243">			child-&gt;_UpdateStateForRemove();</a>
<a name="ln6244">	}</a>
<a name="ln6245">}</a>
<a name="ln6246"> </a>
<a name="ln6247"> </a>
<a name="ln6248">inline void</a>
<a name="ln6249">BView::_UpdatePattern(::pattern pattern)</a>
<a name="ln6250">{</a>
<a name="ln6251">	if (fState-&gt;IsValid(B_VIEW_PATTERN_BIT) &amp;&amp; pattern == fState-&gt;pattern)</a>
<a name="ln6252">		return;</a>
<a name="ln6253"> </a>
<a name="ln6254">	if (fOwner) {</a>
<a name="ln6255">		_CheckLockAndSwitchCurrent();</a>
<a name="ln6256"> </a>
<a name="ln6257">		fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_PATTERN);</a>
<a name="ln6258">		fOwner-&gt;fLink-&gt;Attach&lt; ::pattern&gt;(pattern);</a>
<a name="ln6259"> </a>
<a name="ln6260">		fState-&gt;valid_flags |= B_VIEW_PATTERN_BIT;</a>
<a name="ln6261">	}</a>
<a name="ln6262"> </a>
<a name="ln6263">	fState-&gt;pattern = pattern;</a>
<a name="ln6264">}</a>
<a name="ln6265"> </a>
<a name="ln6266"> </a>
<a name="ln6267">void</a>
<a name="ln6268">BView::_FlushIfNotInTransaction()</a>
<a name="ln6269">{</a>
<a name="ln6270">	if (!fOwner-&gt;fInTransaction) {</a>
<a name="ln6271">		fOwner-&gt;Flush();</a>
<a name="ln6272">	}</a>
<a name="ln6273">}</a>
<a name="ln6274"> </a>
<a name="ln6275"> </a>
<a name="ln6276">BShelf*</a>
<a name="ln6277">BView::_Shelf() const</a>
<a name="ln6278">{</a>
<a name="ln6279">	return fShelf;</a>
<a name="ln6280">}</a>
<a name="ln6281"> </a>
<a name="ln6282"> </a>
<a name="ln6283">void</a>
<a name="ln6284">BView::_SetShelf(BShelf* shelf)</a>
<a name="ln6285">{</a>
<a name="ln6286">	if (fShelf != NULL &amp;&amp; fOwner != NULL)</a>
<a name="ln6287">		fOwner-&gt;RemoveHandler(fShelf);</a>
<a name="ln6288"> </a>
<a name="ln6289">	fShelf = shelf;</a>
<a name="ln6290"> </a>
<a name="ln6291">	if (fShelf != NULL &amp;&amp; fOwner != NULL)</a>
<a name="ln6292">		fOwner-&gt;AddHandler(fShelf);</a>
<a name="ln6293">}</a>
<a name="ln6294"> </a>
<a name="ln6295"> </a>
<a name="ln6296">status_t</a>
<a name="ln6297">BView::_SetViewBitmap(const BBitmap* bitmap, BRect srcRect, BRect dstRect,</a>
<a name="ln6298">	uint32 followFlags, uint32 options)</a>
<a name="ln6299">{</a>
<a name="ln6300">	if (!_CheckOwnerLockAndSwitchCurrent())</a>
<a name="ln6301">		return B_ERROR;</a>
<a name="ln6302"> </a>
<a name="ln6303">	int32 serverToken = bitmap ? bitmap-&gt;_ServerToken() : -1;</a>
<a name="ln6304"> </a>
<a name="ln6305">	fOwner-&gt;fLink-&gt;StartMessage(AS_VIEW_SET_VIEW_BITMAP);</a>
<a name="ln6306">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(serverToken);</a>
<a name="ln6307">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(srcRect);</a>
<a name="ln6308">	fOwner-&gt;fLink-&gt;Attach&lt;BRect&gt;(dstRect);</a>
<a name="ln6309">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(followFlags);</a>
<a name="ln6310">	fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(options);</a>
<a name="ln6311"> </a>
<a name="ln6312">	status_t status = B_ERROR;</a>
<a name="ln6313">	fOwner-&gt;fLink-&gt;FlushWithReply(status);</a>
<a name="ln6314"> </a>
<a name="ln6315">	return status;</a>
<a name="ln6316">}</a>
<a name="ln6317"> </a>
<a name="ln6318"> </a>
<a name="ln6319">bool</a>
<a name="ln6320">BView::_CheckOwnerLockAndSwitchCurrent() const</a>
<a name="ln6321">{</a>
<a name="ln6322">	STRACE((&quot;BView(%s)::_CheckOwnerLockAndSwitchCurrent()\n&quot;, Name()));</a>
<a name="ln6323"> </a>
<a name="ln6324">	if (fOwner == NULL) {</a>
<a name="ln6325">		debugger(&quot;View method requires owner and doesn't have one.&quot;);</a>
<a name="ln6326">		return false;</a>
<a name="ln6327">	}</a>
<a name="ln6328"> </a>
<a name="ln6329">	_CheckLockAndSwitchCurrent();</a>
<a name="ln6330"> </a>
<a name="ln6331">	return true;</a>
<a name="ln6332">}</a>
<a name="ln6333"> </a>
<a name="ln6334"> </a>
<a name="ln6335">bool</a>
<a name="ln6336">BView::_CheckOwnerLock() const</a>
<a name="ln6337">{</a>
<a name="ln6338">	if (fOwner) {</a>
<a name="ln6339">		fOwner-&gt;check_lock();</a>
<a name="ln6340">		return true;</a>
<a name="ln6341">	} else {</a>
<a name="ln6342">		debugger(&quot;View method requires owner and doesn't have one.&quot;);</a>
<a name="ln6343">		return false;</a>
<a name="ln6344">	}</a>
<a name="ln6345">}</a>
<a name="ln6346"> </a>
<a name="ln6347"> </a>
<a name="ln6348">void</a>
<a name="ln6349">BView::_CheckLockAndSwitchCurrent() const</a>
<a name="ln6350">{</a>
<a name="ln6351">	STRACE((&quot;BView(%s)::_CheckLockAndSwitchCurrent()\n&quot;, Name()));</a>
<a name="ln6352"> </a>
<a name="ln6353">	if (!fOwner)</a>
<a name="ln6354">		return;</a>
<a name="ln6355"> </a>
<a name="ln6356">	fOwner-&gt;check_lock();</a>
<a name="ln6357"> </a>
<a name="ln6358">	_SwitchServerCurrentView();</a>
<a name="ln6359">}</a>
<a name="ln6360"> </a>
<a name="ln6361"> </a>
<a name="ln6362">void</a>
<a name="ln6363">BView::_CheckLock() const</a>
<a name="ln6364">{</a>
<a name="ln6365">	if (fOwner)</a>
<a name="ln6366">		fOwner-&gt;check_lock();</a>
<a name="ln6367">}</a>
<a name="ln6368"> </a>
<a name="ln6369"> </a>
<a name="ln6370">void</a>
<a name="ln6371">BView::_SwitchServerCurrentView() const</a>
<a name="ln6372">{</a>
<a name="ln6373">	int32 serverToken = _get_object_token_(this);</a>
<a name="ln6374"> </a>
<a name="ln6375">	if (fOwner-&gt;fLastViewToken != serverToken) {</a>
<a name="ln6376">		STRACE((&quot;contacting app_server... sending token: %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln6377">			serverToken));</a>
<a name="ln6378">		fOwner-&gt;fLink-&gt;StartMessage(AS_SET_CURRENT_VIEW);</a>
<a name="ln6379">		fOwner-&gt;fLink-&gt;Attach&lt;int32&gt;(serverToken);</a>
<a name="ln6380"> </a>
<a name="ln6381">		fOwner-&gt;fLastViewToken = serverToken;</a>
<a name="ln6382">	}</a>
<a name="ln6383">}</a>
<a name="ln6384"> </a>
<a name="ln6385"> </a>
<a name="ln6386">status_t</a>
<a name="ln6387">BView::ScrollWithMouseWheelDelta(BScrollBar* scrollBar, float delta)</a>
<a name="ln6388">{</a>
<a name="ln6389">	if (scrollBar == NULL || delta == 0.0f)</a>
<a name="ln6390">		return B_BAD_VALUE;</a>
<a name="ln6391"> </a>
<a name="ln6392">	float smallStep;</a>
<a name="ln6393">	float largeStep;</a>
<a name="ln6394">	scrollBar-&gt;GetSteps(&amp;smallStep, &amp;largeStep);</a>
<a name="ln6395"> </a>
<a name="ln6396">	// pressing the shift key scrolls faster (following the pseudo-standard set</a>
<a name="ln6397">	// by other desktop environments).</a>
<a name="ln6398">	if ((modifiers() &amp; B_SHIFT_KEY) != 0)</a>
<a name="ln6399">		delta *= largeStep;</a>
<a name="ln6400">	else</a>
<a name="ln6401">		delta *= smallStep * 3;</a>
<a name="ln6402"> </a>
<a name="ln6403">	scrollBar-&gt;SetValue(scrollBar-&gt;Value() + delta);</a>
<a name="ln6404"> </a>
<a name="ln6405">	return B_OK;</a>
<a name="ln6406">}</a>
<a name="ln6407"> </a>
<a name="ln6408"> </a>
<a name="ln6409">#if __GNUC__ == 2</a>
<a name="ln6410"> </a>
<a name="ln6411"> </a>
<a name="ln6412">extern &quot;C&quot; void</a>
<a name="ln6413">_ReservedView1__5BView(BView* view, BRect rect)</a>
<a name="ln6414">{</a>
<a name="ln6415">	view-&gt;BView::DrawAfterChildren(rect);</a>
<a name="ln6416">}</a>
<a name="ln6417"> </a>
<a name="ln6418"> </a>
<a name="ln6419">extern &quot;C&quot; void</a>
<a name="ln6420">_ReservedView2__5BView(BView* view)</a>
<a name="ln6421">{</a>
<a name="ln6422">	// MinSize()</a>
<a name="ln6423">	perform_data_min_size data;</a>
<a name="ln6424">	view-&gt;Perform(PERFORM_CODE_MIN_SIZE, &amp;data);</a>
<a name="ln6425">}</a>
<a name="ln6426"> </a>
<a name="ln6427"> </a>
<a name="ln6428">extern &quot;C&quot; void</a>
<a name="ln6429">_ReservedView3__5BView(BView* view)</a>
<a name="ln6430">{</a>
<a name="ln6431">	// MaxSize()</a>
<a name="ln6432">	perform_data_max_size data;</a>
<a name="ln6433">	view-&gt;Perform(PERFORM_CODE_MAX_SIZE, &amp;data);</a>
<a name="ln6434">}</a>
<a name="ln6435"> </a>
<a name="ln6436"> </a>
<a name="ln6437">extern &quot;C&quot; BSize</a>
<a name="ln6438">_ReservedView4__5BView(BView* view)</a>
<a name="ln6439">{</a>
<a name="ln6440">	// PreferredSize()</a>
<a name="ln6441">	perform_data_preferred_size data;</a>
<a name="ln6442">	view-&gt;Perform(PERFORM_CODE_PREFERRED_SIZE, &amp;data);</a>
<a name="ln6443">	return data.return_value;</a>
<a name="ln6444">}</a>
<a name="ln6445"> </a>
<a name="ln6446"> </a>
<a name="ln6447">extern &quot;C&quot; BAlignment</a>
<a name="ln6448">_ReservedView5__5BView(BView* view)</a>
<a name="ln6449">{</a>
<a name="ln6450">	// LayoutAlignment()</a>
<a name="ln6451">	perform_data_layout_alignment data;</a>
<a name="ln6452">	view-&gt;Perform(PERFORM_CODE_LAYOUT_ALIGNMENT, &amp;data);</a>
<a name="ln6453">	return data.return_value;</a>
<a name="ln6454">}</a>
<a name="ln6455"> </a>
<a name="ln6456"> </a>
<a name="ln6457">extern &quot;C&quot; bool</a>
<a name="ln6458">_ReservedView6__5BView(BView* view)</a>
<a name="ln6459">{</a>
<a name="ln6460">	// HasHeightForWidth()</a>
<a name="ln6461">	perform_data_has_height_for_width data;</a>
<a name="ln6462">	view-&gt;Perform(PERFORM_CODE_HAS_HEIGHT_FOR_WIDTH, &amp;data);</a>
<a name="ln6463">	return data.return_value;</a>
<a name="ln6464">}</a>
<a name="ln6465"> </a>
<a name="ln6466"> </a>
<a name="ln6467">extern &quot;C&quot; void</a>
<a name="ln6468">_ReservedView7__5BView(BView* view, float width, float* min, float* max,</a>
<a name="ln6469">	float* preferred)</a>
<a name="ln6470">{</a>
<a name="ln6471">	// GetHeightForWidth()</a>
<a name="ln6472">	perform_data_get_height_for_width data;</a>
<a name="ln6473">	data.width = width;</a>
<a name="ln6474">	view-&gt;Perform(PERFORM_CODE_GET_HEIGHT_FOR_WIDTH, &amp;data);</a>
<a name="ln6475">	if (min != NULL)</a>
<a name="ln6476">		*min = data.min;</a>
<a name="ln6477">	if (max != NULL)</a>
<a name="ln6478">		*max = data.max;</a>
<a name="ln6479">	if (preferred != NULL)</a>
<a name="ln6480">		*preferred = data.preferred;</a>
<a name="ln6481">}</a>
<a name="ln6482"> </a>
<a name="ln6483"> </a>
<a name="ln6484">extern &quot;C&quot; void</a>
<a name="ln6485">_ReservedView8__5BView(BView* view, BLayout* layout)</a>
<a name="ln6486">{</a>
<a name="ln6487">	// SetLayout()</a>
<a name="ln6488">	perform_data_set_layout data;</a>
<a name="ln6489">	data.layout = layout;</a>
<a name="ln6490">	view-&gt;Perform(PERFORM_CODE_SET_LAYOUT, &amp;data);</a>
<a name="ln6491">}</a>
<a name="ln6492"> </a>
<a name="ln6493"> </a>
<a name="ln6494">extern &quot;C&quot; void</a>
<a name="ln6495">_ReservedView9__5BView(BView* view, bool descendants)</a>
<a name="ln6496">{</a>
<a name="ln6497">	// LayoutInvalidated()</a>
<a name="ln6498">	perform_data_layout_invalidated data;</a>
<a name="ln6499">	data.descendants = descendants;</a>
<a name="ln6500">	view-&gt;Perform(PERFORM_CODE_LAYOUT_INVALIDATED, &amp;data);</a>
<a name="ln6501">}</a>
<a name="ln6502"> </a>
<a name="ln6503"> </a>
<a name="ln6504">extern &quot;C&quot; void</a>
<a name="ln6505">_ReservedView10__5BView(BView* view)</a>
<a name="ln6506">{</a>
<a name="ln6507">	// DoLayout()</a>
<a name="ln6508">	view-&gt;Perform(PERFORM_CODE_DO_LAYOUT, NULL);</a>
<a name="ln6509">}</a>
<a name="ln6510"> </a>
<a name="ln6511"> </a>
<a name="ln6512">#endif	// __GNUC__ == 2</a>
<a name="ln6513"> </a>
<a name="ln6514"> </a>
<a name="ln6515">extern &quot;C&quot; bool</a>
<a name="ln6516">B_IF_GCC_2(_ReservedView11__5BView, _ZN5BView15_ReservedView11Ev)(</a>
<a name="ln6517">	BView* view, BPoint point, BToolTip** _toolTip)</a>
<a name="ln6518">{</a>
<a name="ln6519">	// GetToolTipAt()</a>
<a name="ln6520">	perform_data_get_tool_tip_at data;</a>
<a name="ln6521">	data.point = point;</a>
<a name="ln6522">	data.tool_tip = _toolTip;</a>
<a name="ln6523">	view-&gt;Perform(PERFORM_CODE_GET_TOOL_TIP_AT, &amp;data);</a>
<a name="ln6524">	return data.return_value;</a>
<a name="ln6525">}</a>
<a name="ln6526"> </a>
<a name="ln6527"> </a>
<a name="ln6528">extern &quot;C&quot; void</a>
<a name="ln6529">B_IF_GCC_2(_ReservedView12__5BView, _ZN5BView15_ReservedView12Ev)(</a>
<a name="ln6530">	BView* view)</a>
<a name="ln6531">{</a>
<a name="ln6532">	// LayoutChanged();</a>
<a name="ln6533">	view-&gt;Perform(PERFORM_CODE_LAYOUT_CHANGED, NULL);</a>
<a name="ln6534">}</a>
<a name="ln6535"> </a>
<a name="ln6536"> </a>
<a name="ln6537">void BView::_ReservedView13() {}</a>
<a name="ln6538">void BView::_ReservedView14() {}</a>
<a name="ln6539">void BView::_ReservedView15() {}</a>
<a name="ln6540">void BView::_ReservedView16() {}</a>
<a name="ln6541"> </a>
<a name="ln6542"> </a>
<a name="ln6543">BView::BView(const BView&amp; other)</a>
<a name="ln6544">	:</a>
<a name="ln6545">	BHandler()</a>
<a name="ln6546">{</a>
<a name="ln6547">	// this is private and not functional, but exported</a>
<a name="ln6548">}</a>
<a name="ln6549"> </a>
<a name="ln6550"> </a>
<a name="ln6551">BView&amp;</a>
<a name="ln6552">BView::operator=(const BView&amp; other)</a>
<a name="ln6553">{</a>
<a name="ln6554">	// this is private and not functional, but exported</a>
<a name="ln6555">	return *this;</a>
<a name="ln6556">}</a>
<a name="ln6557"> </a>
<a name="ln6558"> </a>
<a name="ln6559">void</a>
<a name="ln6560">BView::_PrintToStream()</a>
<a name="ln6561">{</a>
<a name="ln6562">	printf(&quot;BView::_PrintToStream()\n&quot;);</a>
<a name="ln6563">	printf(&quot;\tName: %s\n&quot;</a>
<a name="ln6564">		&quot;\tParent: %s\n&quot;</a>
<a name="ln6565">		&quot;\tFirstChild: %s\n&quot;</a>
<a name="ln6566">		&quot;\tNextSibling: %s\n&quot;</a>
<a name="ln6567">		&quot;\tPrevSibling: %s\n&quot;</a>
<a name="ln6568">		&quot;\tOwner(Window): %s\n&quot;</a>
<a name="ln6569">		&quot;\tToken: %&quot; B_PRId32 &quot;\n&quot;</a>
<a name="ln6570">		&quot;\tFlags: %&quot; B_PRId32 &quot;\n&quot;</a>
<a name="ln6571">		&quot;\tView origin: (%f,%f)\n&quot;</a>
<a name="ln6572">		&quot;\tView Bounds rectangle: (%f,%f,%f,%f)\n&quot;</a>
<a name="ln6573">		&quot;\tShow level: %d\n&quot;</a>
<a name="ln6574">		&quot;\tTopView?: %s\n&quot;</a>
<a name="ln6575">		&quot;\tBPicture: %s\n&quot;</a>
<a name="ln6576">		&quot;\tVertical Scrollbar %s\n&quot;</a>
<a name="ln6577">		&quot;\tHorizontal Scrollbar %s\n&quot;</a>
<a name="ln6578">		&quot;\tIs Printing?: %s\n&quot;</a>
<a name="ln6579">		&quot;\tShelf?: %s\n&quot;</a>
<a name="ln6580">		&quot;\tEventMask: %&quot; B_PRId32 &quot;\n&quot;</a>
<a name="ln6581">		&quot;\tEventOptions: %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln6582">	Name(),</a>
<a name="ln6583">	fParent ? fParent-&gt;Name() : &quot;NULL&quot;,</a>
<a name="ln6584">	fFirstChild ? fFirstChild-&gt;Name() : &quot;NULL&quot;,</a>
<a name="ln6585">	fNextSibling ? fNextSibling-&gt;Name() : &quot;NULL&quot;,</a>
<a name="ln6586">	fPreviousSibling ? fPreviousSibling-&gt;Name() : &quot;NULL&quot;,</a>
<a name="ln6587">	fOwner ? fOwner-&gt;Name() : &quot;NULL&quot;,</a>
<a name="ln6588">	_get_object_token_(this),</a>
<a name="ln6589">	fFlags,</a>
<a name="ln6590">	fParentOffset.x, fParentOffset.y,</a>
<a name="ln6591">	fBounds.left, fBounds.top, fBounds.right, fBounds.bottom,</a>
<a name="ln6592">	fShowLevel,</a>
<a name="ln6593">	fTopLevelView ? &quot;YES&quot; : &quot;NO&quot;,</a>
<a name="ln6594">	fCurrentPicture? &quot;YES&quot; : &quot;NULL&quot;,</a>
<a name="ln6595">	fVerScroller? &quot;YES&quot; : &quot;NULL&quot;,</a>
<a name="ln6596">	fHorScroller? &quot;YES&quot; : &quot;NULL&quot;,</a>
<a name="ln6597">	fIsPrinting? &quot;YES&quot; : &quot;NO&quot;,</a>
<a name="ln6598">	fShelf? &quot;YES&quot; : &quot;NO&quot;,</a>
<a name="ln6599">	fEventMask,</a>
<a name="ln6600">	fEventOptions);</a>
<a name="ln6601"> </a>
<a name="ln6602">	printf(&quot;\tState status:\n&quot;</a>
<a name="ln6603">		&quot;\t\tLocalCoordianteSystem: (%f,%f)\n&quot;</a>
<a name="ln6604">		&quot;\t\tPenLocation: (%f,%f)\n&quot;</a>
<a name="ln6605">		&quot;\t\tPenSize: %f\n&quot;</a>
<a name="ln6606">		&quot;\t\tHighColor: [%d,%d,%d,%d]\n&quot;</a>
<a name="ln6607">		&quot;\t\tLowColor: [%d,%d,%d,%d]\n&quot;</a>
<a name="ln6608">		&quot;\t\tViewColor: [%d,%d,%d,%d]\n&quot;</a>
<a name="ln6609">		&quot;\t\tPattern: %&quot; B_PRIx64 &quot;\n&quot;</a>
<a name="ln6610">		&quot;\t\tDrawingMode: %d\n&quot;</a>
<a name="ln6611">		&quot;\t\tLineJoinMode: %d\n&quot;</a>
<a name="ln6612">		&quot;\t\tLineCapMode: %d\n&quot;</a>
<a name="ln6613">		&quot;\t\tMiterLimit: %f\n&quot;</a>
<a name="ln6614">		&quot;\t\tAlphaSource: %d\n&quot;</a>
<a name="ln6615">		&quot;\t\tAlphaFuntion: %d\n&quot;</a>
<a name="ln6616">		&quot;\t\tScale: %f\n&quot;</a>
<a name="ln6617">		&quot;\t\t(Print)FontAliasing: %s\n&quot;</a>
<a name="ln6618">		&quot;\t\tFont Info:\n&quot;,</a>
<a name="ln6619">	fState-&gt;origin.x, fState-&gt;origin.y,</a>
<a name="ln6620">	fState-&gt;pen_location.x, fState-&gt;pen_location.y,</a>
<a name="ln6621">	fState-&gt;pen_size,</a>
<a name="ln6622">	fState-&gt;high_color.red, fState-&gt;high_color.blue, fState-&gt;high_color.green, fState-&gt;high_color.alpha,</a>
<a name="ln6623">	fState-&gt;low_color.red, fState-&gt;low_color.blue, fState-&gt;low_color.green, fState-&gt;low_color.alpha,</a>
<a name="ln6624">	fState-&gt;view_color.red, fState-&gt;view_color.blue, fState-&gt;view_color.green, fState-&gt;view_color.alpha,</a>
<a name="ln6625">	*((uint64*)&amp;(fState-&gt;pattern)),</a>
<a name="ln6626">	fState-&gt;drawing_mode,</a>
<a name="ln6627">	fState-&gt;line_join,</a>
<a name="ln6628">	fState-&gt;line_cap,</a>
<a name="ln6629">	fState-&gt;miter_limit,</a>
<a name="ln6630">	fState-&gt;alpha_source_mode,</a>
<a name="ln6631">	fState-&gt;alpha_function_mode,</a>
<a name="ln6632">	fState-&gt;scale,</a>
<a name="ln6633">	fState-&gt;font_aliasing? &quot;YES&quot; : &quot;NO&quot;);</a>
<a name="ln6634"> </a>
<a name="ln6635">	fState-&gt;font.PrintToStream();</a>
<a name="ln6636"> </a>
<a name="ln6637">	// TODO: also print the line array.</a>
<a name="ln6638">}</a>
<a name="ln6639"> </a>
<a name="ln6640"> </a>
<a name="ln6641">void</a>
<a name="ln6642">BView::_PrintTree()</a>
<a name="ln6643">{</a>
<a name="ln6644">	int32 spaces = 2;</a>
<a name="ln6645">	BView* c = fFirstChild; //c = short for: current</a>
<a name="ln6646">	printf( &quot;'%s'\n&quot;, Name() );</a>
<a name="ln6647">	if (c != NULL) {</a>
<a name="ln6648">		while(true) {</a>
<a name="ln6649">			// action block</a>
<a name="ln6650">			{</a>
<a name="ln6651">				for (int i = 0; i &lt; spaces; i++)</a>
<a name="ln6652">					printf(&quot; &quot;);</a>
<a name="ln6653"> </a>
<a name="ln6654">				printf( &quot;'%s'\n&quot;, c-&gt;Name() );</a>
<a name="ln6655">			}</a>
<a name="ln6656"> </a>
<a name="ln6657">			// go deep</a>
<a name="ln6658">			if (c-&gt;fFirstChild) {</a>
<a name="ln6659">				c = c-&gt;fFirstChild;</a>
<a name="ln6660">				spaces += 2;</a>
<a name="ln6661">			} else {</a>
<a name="ln6662">				// go right</a>
<a name="ln6663">				if (c-&gt;fNextSibling) {</a>
<a name="ln6664">					c = c-&gt;fNextSibling;</a>
<a name="ln6665">				} else {</a>
<a name="ln6666">					// go up</a>
<a name="ln6667">					while (!c-&gt;fParent-&gt;fNextSibling &amp;&amp; c-&gt;fParent != this) {</a>
<a name="ln6668">						c = c-&gt;fParent;</a>
<a name="ln6669">						spaces -= 2;</a>
<a name="ln6670">					}</a>
<a name="ln6671"> </a>
<a name="ln6672">					// that enough! We've reached this view.</a>
<a name="ln6673">					if (c-&gt;fParent == this)</a>
<a name="ln6674">						break;</a>
<a name="ln6675"> </a>
<a name="ln6676">					c = c-&gt;fParent-&gt;fNextSibling;</a>
<a name="ln6677">					spaces -= 2;</a>
<a name="ln6678">				}</a>
<a name="ln6679">			}</a>
<a name="ln6680">		}</a>
<a name="ln6681">	}</a>
<a name="ln6682">}</a>
<a name="ln6683"> </a>
<a name="ln6684"> </a>
<a name="ln6685">// #pragma mark -</a>
<a name="ln6686"> </a>
<a name="ln6687"> </a>
<a name="ln6688">BLayoutItem*</a>
<a name="ln6689">BView::Private::LayoutItemAt(int32 index)</a>
<a name="ln6690">{</a>
<a name="ln6691">	return fView-&gt;fLayoutData-&gt;fLayoutItems.ItemAt(index);</a>
<a name="ln6692">}</a>
<a name="ln6693"> </a>
<a name="ln6694"> </a>
<a name="ln6695">int32</a>
<a name="ln6696">BView::Private::CountLayoutItems()</a>
<a name="ln6697">{</a>
<a name="ln6698">	return fView-&gt;fLayoutData-&gt;fLayoutItems.CountItems();</a>
<a name="ln6699">}</a>
<a name="ln6700"> </a>
<a name="ln6701"> </a>
<a name="ln6702">void</a>
<a name="ln6703">BView::Private::RegisterLayoutItem(BLayoutItem* item)</a>
<a name="ln6704">{</a>
<a name="ln6705">	fView-&gt;fLayoutData-&gt;fLayoutItems.AddItem(item);</a>
<a name="ln6706">}</a>
<a name="ln6707"> </a>
<a name="ln6708"> </a>
<a name="ln6709">void</a>
<a name="ln6710">BView::Private::DeregisterLayoutItem(BLayoutItem* item)</a>
<a name="ln6711">{</a>
<a name="ln6712">	fView-&gt;fLayoutData-&gt;fLayoutItems.RemoveItem(item);</a>
<a name="ln6713">}</a>
<a name="ln6714"> </a>
<a name="ln6715"> </a>
<a name="ln6716">bool</a>
<a name="ln6717">BView::Private::MinMaxValid()</a>
<a name="ln6718">{</a>
<a name="ln6719">	return fView-&gt;fLayoutData-&gt;fMinMaxValid;</a>
<a name="ln6720">}</a>
<a name="ln6721"> </a>
<a name="ln6722"> </a>
<a name="ln6723">bool</a>
<a name="ln6724">BView::Private::WillLayout()</a>
<a name="ln6725">{</a>
<a name="ln6726">	BView::LayoutData* data = fView-&gt;fLayoutData;</a>
<a name="ln6727">	if (data-&gt;fLayoutInProgress)</a>
<a name="ln6728">		return false;</a>
<a name="ln6729">	if (data-&gt;fNeedsRelayout || !data-&gt;fLayoutValid || !data-&gt;fMinMaxValid)</a>
<a name="ln6730">		return true;</a>
<a name="ln6731">	return false;</a>
<a name="ln6732">}</a>

</code></pre>
<div class="balloon" rel="4535"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'fOwner' pointer was utilized before it was verified against nullptr. Check lines: 4535, 4539.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
