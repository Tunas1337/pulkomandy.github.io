
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>BPlusTree.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BPlusTree - BFS B+Tree implementation</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright 2001-2002 pinc Software. All Rights Reserved.</a>
<a name="ln4">** Released under the terms of the MIT license.</a>
<a name="ln5">*/</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;BPlusTree.h&quot;</a>
<a name="ln9">#include &quot;Inode.h&quot;</a>
<a name="ln10">#include &quot;Stack.h&quot;</a>
<a name="ln11">#include &quot;dump.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;Debug.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16">#include &lt;stdlib.h&gt;</a>
<a name="ln17">#include &lt;stdio.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19"> </a>
<a name="ln20">#define MAX_NODES_IN_CACHE 20</a>
<a name="ln21"> </a>
<a name="ln22">class CacheableNode : public NodeCache::Cacheable</a>
<a name="ln23">{</a>
<a name="ln24">	public:</a>
<a name="ln25">		CacheableNode(off_t offset,bplustree_node *node)</a>
<a name="ln26">			:</a>
<a name="ln27">			fOffset(offset),</a>
<a name="ln28">			fNode(node)</a>
<a name="ln29">		{</a>
<a name="ln30">		}</a>
<a name="ln31"> </a>
<a name="ln32">		virtual ~CacheableNode()</a>
<a name="ln33">		{</a>
<a name="ln34">			if (fNode)</a>
<a name="ln35">				free(fNode);</a>
<a name="ln36">		}</a>
<a name="ln37"> </a>
<a name="ln38">		virtual bool Equals(off_t offset)</a>
<a name="ln39">		{</a>
<a name="ln40">			return offset == fOffset;</a>
<a name="ln41">		}</a>
<a name="ln42"> </a>
<a name="ln43">		off_t			fOffset;</a>
<a name="ln44">		bplustree_node	*fNode;</a>
<a name="ln45">};</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">NodeCache::NodeCache(BPlusTree *tree)</a>
<a name="ln49">	:	Cache&lt;off_t&gt;(),</a>
<a name="ln50">	fTree(tree)</a>
<a name="ln51">{</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54"> </a>
<a name="ln55">Cache&lt;off_t&gt;::Cacheable *</a>
<a name="ln56">NodeCache::NewCacheable(off_t offset)</a>
<a name="ln57">{</a>
<a name="ln58">	return new CacheableNode(offset,fTree-&gt;Node(offset,false));</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">bplustree_node *</a>
<a name="ln63">NodeCache::Get(off_t offset)</a>
<a name="ln64">{</a>
<a name="ln65">	CacheableNode *node = (CacheableNode *)Cache&lt;off_t&gt;::Get(offset);</a>
<a name="ln66">	return node-&gt;fNode;</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">//	#pragma mark -</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">BPlusTree::BPlusTree(int32 keyType,int32 nodeSize,bool allowDuplicates)</a>
<a name="ln74">	:</a>
<a name="ln75">	fStream(NULL),</a>
<a name="ln76">	fHeader(NULL),</a>
<a name="ln77">	fCache(this),</a>
<a name="ln78">	fCurrentNodeOffset(BPLUSTREE_NULL)</a>
<a name="ln79">{</a>
<a name="ln80">	SetTo(keyType,nodeSize,allowDuplicates);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">BPlusTree::BPlusTree(BPositionIO *stream,bool allowDuplicates)</a>
<a name="ln85">	:</a>
<a name="ln86">	fStream(NULL),</a>
<a name="ln87">	fHeader(NULL),</a>
<a name="ln88">	fCache(this),</a>
<a name="ln89">	fCurrentNodeOffset(BPLUSTREE_NULL)</a>
<a name="ln90">{</a>
<a name="ln91">	SetTo(stream,allowDuplicates);</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">BPlusTree::BPlusTree()</a>
<a name="ln96">	:</a>
<a name="ln97">	fStream(NULL),</a>
<a name="ln98">	fHeader(NULL),</a>
<a name="ln99">	fNodeSize(BPLUSTREE_NODE_SIZE),</a>
<a name="ln100">	fAllowDuplicates(true),</a>
<a name="ln101">	fStatus(B_NO_INIT),</a>
<a name="ln102">	fCache(this),</a>
<a name="ln103">	fCurrentNodeOffset(BPLUSTREE_NULL)</a>
<a name="ln104">{</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">BPlusTree::~BPlusTree()</a>
<a name="ln109">{</a>
<a name="ln110">	fCache.Clear();</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113"> </a>
<a name="ln114">void BPlusTree::Initialize(int32 nodeSize)</a>
<a name="ln115">{</a>
<a name="ln116">	// free old data</a>
<a name="ln117">	fCache.Clear(0,true);</a>
<a name="ln118"> </a>
<a name="ln119">	if (fHeader)</a>
<a name="ln120">		free(fHeader);</a>
<a name="ln121"> </a>
<a name="ln122">	fStream = NULL;</a>
<a name="ln123"> </a>
<a name="ln124">	fNodeSize = nodeSize;</a>
<a name="ln125">	fHeader = (bplustree_header *)malloc(fNodeSize);</a>
<a name="ln126"> 	memset(fHeader,0,fNodeSize);</a>
<a name="ln127"> 	</a>
<a name="ln128"> 	fCurrentNodeOffset = BPLUSTREE_NULL;</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131"> </a>
<a name="ln132">status_t BPlusTree::SetTo(int32 keyType,int32 nodeSize,bool allowDuplicates)</a>
<a name="ln133">{</a>
<a name="ln134">	// initializes in-memory B+Tree</a>
<a name="ln135"> </a>
<a name="ln136">	Initialize(nodeSize);</a>
<a name="ln137"> </a>
<a name="ln138">	fAllowDuplicates = allowDuplicates;</a>
<a name="ln139">	fCache.SetHoldChanges(true);</a>
<a name="ln140"> </a>
<a name="ln141">	// initialize b+tree header</a>
<a name="ln142"> 	fHeader-&gt;magic = BPLUSTREE_MAGIC;</a>
<a name="ln143"> 	fHeader-&gt;node_size = fNodeSize;</a>
<a name="ln144"> 	fHeader-&gt;max_number_of_levels = 1;</a>
<a name="ln145"> 	fHeader-&gt;data_type = keyType;</a>
<a name="ln146"> 	fHeader-&gt;root_node_pointer = fNodeSize;</a>
<a name="ln147"> 	fHeader-&gt;free_node_pointer = BPLUSTREE_NULL;</a>
<a name="ln148"> 	fHeader-&gt;maximum_size = fNodeSize * 2;</a>
<a name="ln149"> 	</a>
<a name="ln150">	return fStatus = B_OK;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">status_t BPlusTree::SetTo(BPositionIO *stream,bool allowDuplicates)</a>
<a name="ln155">{</a>
<a name="ln156">	// initializes on-disk B+Tree</a>
<a name="ln157"> </a>
<a name="ln158">	bplustree_header header;</a>
<a name="ln159">	ssize_t read = stream-&gt;ReadAt(0,&amp;header,sizeof(bplustree_header));</a>
<a name="ln160">	if (read &lt; 0)</a>
<a name="ln161">		return fStatus = read;</a>
<a name="ln162"> </a>
<a name="ln163">	// is header valid?</a>
<a name="ln164">	</a>
<a name="ln165">	stream-&gt;Seek(0,SEEK_END);</a>
<a name="ln166">	off_t size = stream-&gt;Position();</a>
<a name="ln167">	stream-&gt;Seek(0,SEEK_SET);</a>
<a name="ln168"> </a>
<a name="ln169">	//dump_bplustree_header(&amp;header);</a>
<a name="ln170"> </a>
<a name="ln171">	if (header.magic != BPLUSTREE_MAGIC</a>
<a name="ln172">		|| header.maximum_size != size</a>
<a name="ln173">		|| (header.root_node_pointer % header.node_size) != 0</a>
<a name="ln174">		|| !header.IsValidLink(header.root_node_pointer)</a>
<a name="ln175">		|| !header.IsValidLink(header.free_node_pointer))</a>
<a name="ln176">		return fStatus = B_BAD_DATA;</a>
<a name="ln177"> </a>
<a name="ln178">	fAllowDuplicates = allowDuplicates;</a>
<a name="ln179"> </a>
<a name="ln180">	if (DataStream *dataStream = dynamic_cast&lt;DataStream *&gt;(stream))</a>
<a name="ln181">	{</a>
<a name="ln182">		uint32 toMode[] = {S_STR_INDEX, S_INT_INDEX, S_UINT_INDEX, S_LONG_LONG_INDEX,</a>
<a name="ln183">						   S_ULONG_LONG_INDEX, S_FLOAT_INDEX, S_DOUBLE_INDEX};</a>
<a name="ln184">		uint32 mode = dataStream-&gt;Mode() &amp; (S_STR_INDEX | S_INT_INDEX | S_UINT_INDEX | S_LONG_LONG_INDEX</a>
<a name="ln185">						   | S_ULONG_LONG_INDEX | S_FLOAT_INDEX | S_DOUBLE_INDEX);</a>
<a name="ln186">	</a>
<a name="ln187">		if (header.data_type &gt; BPLUSTREE_DOUBLE_TYPE</a>
<a name="ln188">			|| (dataStream-&gt;Mode() &amp; S_INDEX_DIR) &amp;&amp; toMode[header.data_type] != mode</a>
<a name="ln189">			|| !dataStream-&gt;IsDirectory())</a>
<a name="ln190">			return fStatus = B_BAD_TYPE;</a>
<a name="ln191"> </a>
<a name="ln192">		 // although it's in stat.h, the S_ALLOW_DUPS flag is obviously unused</a>
<a name="ln193">		fAllowDuplicates = (dataStream-&gt;Mode() &amp; (S_INDEX_DIR | 0777)) == S_INDEX_DIR;</a>
<a name="ln194"> </a>
<a name="ln195">		//printf(&quot;allows duplicates? %s\n&quot;,fAllowDuplicates ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln196">	}</a>
<a name="ln197"> </a>
<a name="ln198">	Initialize(header.node_size);</a>
<a name="ln199"> </a>
<a name="ln200">	memcpy(fHeader,&amp;header,sizeof(bplustree_header));</a>
<a name="ln201"> </a>
<a name="ln202">	fStream = stream;</a>
<a name="ln203"> </a>
<a name="ln204">	bplustree_node *node = fCache.Get(header.root_node_pointer);</a>
<a name="ln205">	//if (node)</a>
<a name="ln206">	//	dump_bplustree_node(node);</a>
<a name="ln207"> </a>
<a name="ln208">	return fStatus = node &amp;&amp; CheckNode(node) ? B_OK : B_BAD_DATA;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">status_t BPlusTree::InitCheck()</a>
<a name="ln213">{</a>
<a name="ln214">	return fStatus;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">struct validate_info {</a>
<a name="ln219">	off_t	offset;</a>
<a name="ln220">	off_t	from;</a>
<a name="ln221">	bool	free;</a>
<a name="ln222">};</a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225">status_t</a>
<a name="ln226">BPlusTree::Validate(bool verbose)</a>
<a name="ln227">{</a>
<a name="ln228">	// validates the on-disk b+tree</a>
<a name="ln229">	// (for now only the node integrity is checked)</a>
<a name="ln230"> </a>
<a name="ln231">	if (!fStream)</a>
<a name="ln232">		return B_OK;</a>
<a name="ln233"> </a>
<a name="ln234">	struct validate_info info;</a>
<a name="ln235"> </a>
<a name="ln236">	Stack&lt;validate_info&gt; stack;</a>
<a name="ln237">	info.offset = fHeader-&gt;root_node_pointer;</a>
<a name="ln238">	info.from = BPLUSTREE_NULL;</a>
<a name="ln239">	info.free = false;</a>
<a name="ln240">	stack.Push(info);</a>
<a name="ln241"> </a>
<a name="ln242">	if (fHeader-&gt;free_node_pointer != BPLUSTREE_NULL) {</a>
<a name="ln243">		info.offset = fHeader-&gt;free_node_pointer;</a>
<a name="ln244">		info.free = true;</a>
<a name="ln245">		stack.Push(info);</a>
<a name="ln246">	}</a>
<a name="ln247"> </a>
<a name="ln248">	char escape[3] = {0x1b, '[', 0};</a>
<a name="ln249">	int32 count = 0,freeCount = 0;</a>
<a name="ln250"> </a>
<a name="ln251">	while (true) {</a>
<a name="ln252">		if (!stack.Pop(&amp;info)) {</a>
<a name="ln253">			if (verbose) {</a>
<a name="ln254">				printf(&quot;  %&quot; B_PRId32 &quot; B+tree node(s) processed (%&quot; B_PRId32</a>
<a name="ln255">					&quot; free node(s)).\n&quot;, count, freeCount);</a>
<a name="ln256">			}</a>
<a name="ln257">			return B_OK;</a>
<a name="ln258">		}</a>
<a name="ln259"> </a>
<a name="ln260">		if (!info.free &amp;&amp; verbose &amp;&amp; ++count % 10 == 0)</a>
<a name="ln261">			printf(&quot;  %&quot; B_PRId32 &quot;%s1A\n&quot;, count, escape);</a>
<a name="ln262">		else if (info.free)</a>
<a name="ln263">			freeCount++;</a>
<a name="ln264"> </a>
<a name="ln265">		bplustree_node *node;</a>
<a name="ln266">		if ((node = fCache.Get(info.offset)) == NULL</a>
<a name="ln267">			|| !info.free &amp;&amp; !CheckNode(node)) {</a>
<a name="ln268">			if (verbose) {</a>
<a name="ln269">				fprintf(stderr,&quot;  B+Tree: Could not get data at position %&quot;</a>
<a name="ln270">					B_PRIdOFF &quot; (referenced by node at %&quot; B_PRIdOFF &quot;)\n&quot;,</a>
<a name="ln271">					info.offset, info.from);</a>
<a name="ln272">				if ((node = fCache.Get(info.from)) != NULL)</a>
<a name="ln273">					dump_bplustree_node(node,fHeader);</a>
<a name="ln274">			}</a>
<a name="ln275">			return B_BAD_DATA;</a>
<a name="ln276">		}</a>
<a name="ln277"> </a>
<a name="ln278">		info.from = info.offset;</a>
<a name="ln279"> </a>
<a name="ln280">		if (node-&gt;overflow_link != BPLUSTREE_NULL &amp;&amp; !info.free) {</a>
<a name="ln281">			info.offset = node-&gt;overflow_link;</a>
<a name="ln282">			stack.Push(info);</a>
<a name="ln283"> </a>
<a name="ln284">			//dump_bplustree_node(node,fHeader);</a>
<a name="ln285">			off_t *values = node-&gt;Values();</a>
<a name="ln286">			for (int32 i = 0;i &lt; node-&gt;all_key_count;i++) {</a>
<a name="ln287">				info.offset = values[i];</a>
<a name="ln288">				stack.Push(info);</a>
<a name="ln289">			}</a>
<a name="ln290">		} else if (node-&gt;left_link != BPLUSTREE_NULL &amp;&amp; info.free) {</a>
<a name="ln291">			info.offset = node-&gt;left_link;</a>
<a name="ln292">			stack.Push(info);</a>
<a name="ln293">		}</a>
<a name="ln294">	}</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297"> </a>
<a name="ln298">status_t</a>
<a name="ln299">BPlusTree::WriteTo(BPositionIO *stream)</a>
<a name="ln300">{</a>
<a name="ln301">	ssize_t written = stream-&gt;WriteAt(0,fHeader,fNodeSize);</a>
<a name="ln302">	if (written &lt; fNodeSize)</a>
<a name="ln303">		return written &lt; B_OK ? written : B_IO_ERROR;</a>
<a name="ln304"> </a>
<a name="ln305">	for (off_t offset = fNodeSize;offset &lt; fHeader-&gt;maximum_size;offset += fNodeSize)</a>
<a name="ln306">	{</a>
<a name="ln307">		bplustree_node *node = fCache.Get(offset);</a>
<a name="ln308">		if (node == NULL)</a>
<a name="ln309">			return B_ERROR;</a>
<a name="ln310"> </a>
<a name="ln311">		written = stream-&gt;WriteAt(offset,node,fNodeSize);</a>
<a name="ln312">		if (written &lt; fNodeSize)</a>
<a name="ln313">			return written &lt; B_OK ? written : B_IO_ERROR;</a>
<a name="ln314">	}</a>
<a name="ln315">	return stream-&gt;SetSize(fHeader-&gt;maximum_size);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">//	#pragma mark -</a>
<a name="ln320"> </a>
<a name="ln321"> </a>
<a name="ln322">void BPlusTree::SetCurrentNode(bplustree_node *node,off_t offset,int8 to)</a>
<a name="ln323">{</a>
<a name="ln324">	fCurrentNodeOffset = offset;</a>
<a name="ln325">	fCurrentKey = to == BPLUSTREE_BEGIN ? -1 : node-&gt;all_key_count;</a>
<a name="ln326">	fDuplicateNode = BPLUSTREE_NULL;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">status_t BPlusTree::Goto(int8 to)</a>
<a name="ln331">{</a>
<a name="ln332">	if (fHeader == NULL)</a>
<a name="ln333">		return B_BAD_VALUE;</a>
<a name="ln334"> </a>
<a name="ln335">	Stack&lt;off_t&gt; stack;</a>
<a name="ln336">	if (stack.Push(fHeader-&gt;root_node_pointer) &lt; B_OK)</a>
<a name="ln337">		return B_NO_MEMORY;</a>
<a name="ln338"> </a>
<a name="ln339">	bplustree_node *node;</a>
<a name="ln340">	off_t pos;</a>
<a name="ln341">	while (stack.Pop(&amp;pos) &amp;&amp; (node = fCache.Get(pos)) != NULL &amp;&amp; CheckNode(node))</a>
<a name="ln342">	{</a>
<a name="ln343">		// is the node a leaf node?</a>
<a name="ln344">		if (node-&gt;overflow_link == BPLUSTREE_NULL)</a>
<a name="ln345">		{</a>
<a name="ln346">			SetCurrentNode(node,pos,to);</a>
<a name="ln347"> </a>
<a name="ln348">			return B_OK;</a>
<a name="ln349">		}</a>
<a name="ln350"> </a>
<a name="ln351">		if (to == BPLUSTREE_END || node-&gt;all_key_count == 0)</a>
<a name="ln352">			pos = node-&gt;overflow_link;</a>
<a name="ln353">		else</a>
<a name="ln354">		{</a>
<a name="ln355">			if (node-&gt;all_key_length &gt; fNodeSize</a>
<a name="ln356">				|| (addr_t)node-&gt;Values() &gt; (addr_t)node + fNodeSize</a>
<a name="ln357">					- 8 * node-&gt;all_key_count)</a>
<a name="ln358">				return B_ERROR;</a>
<a name="ln359">			</a>
<a name="ln360">			pos = *node-&gt;Values();</a>
<a name="ln361">		}</a>
<a name="ln362"> </a>
<a name="ln363">		if (stack.Push(pos) &lt; B_OK)</a>
<a name="ln364">			break;</a>
<a name="ln365">	}</a>
<a name="ln366">	return B_ERROR;</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369"> </a>
<a name="ln370">status_t BPlusTree::Traverse(int8 direction,void *key,uint16 *keyLength,uint16 maxLength,off_t *value)</a>
<a name="ln371">{</a>
<a name="ln372">	if (fCurrentNodeOffset == BPLUSTREE_NULL</a>
<a name="ln373">		&amp;&amp; Goto(direction == BPLUSTREE_FORWARD ? BPLUSTREE_BEGIN : BPLUSTREE_END) &lt; B_OK) </a>
<a name="ln374">		return B_ERROR;</a>
<a name="ln375"> </a>
<a name="ln376">	bplustree_node *node;</a>
<a name="ln377"> </a>
<a name="ln378">	if (fDuplicateNode != BPLUSTREE_NULL)</a>
<a name="ln379">	{</a>
<a name="ln380">		// regardless of traverse direction the duplicates are always presented in</a>
<a name="ln381">		// the same order; since they are all considered as equal, this shouldn't</a>
<a name="ln382">		// cause any problems</a>
<a name="ln383"> </a>
<a name="ln384">		if (!fIsFragment || fDuplicate &lt; fNumDuplicates)</a>
<a name="ln385">			node = fCache.Get(bplustree_node::FragmentOffset(fDuplicateNode));</a>
<a name="ln386">		else</a>
<a name="ln387">			node = NULL;</a>
<a name="ln388"> </a>
<a name="ln389">		if (node != NULL)</a>
<a name="ln390">		{</a>
<a name="ln391">			if (!fIsFragment &amp;&amp; fDuplicate &gt;= fNumDuplicates)</a>
<a name="ln392">			{</a>
<a name="ln393">				// if the node is out of duplicates, we go directly to the next one</a>
<a name="ln394">				fDuplicateNode = node-&gt;right_link;</a>
<a name="ln395">				if (fDuplicateNode != BPLUSTREE_NULL</a>
<a name="ln396">					&amp;&amp; (node = fCache.Get(fDuplicateNode)) != NULL)</a>
<a name="ln397">				{</a>
<a name="ln398">					fNumDuplicates = node-&gt;CountDuplicates(fDuplicateNode,false);</a>
<a name="ln399">					fDuplicate = 0;</a>
<a name="ln400">				}</a>
<a name="ln401">			}</a>
<a name="ln402">			if (fDuplicate &lt; fNumDuplicates)</a>
<a name="ln403">			{</a>
<a name="ln404">				*value = node-&gt;DuplicateAt(fDuplicateNode,fIsFragment,fDuplicate++);</a>
<a name="ln405">				return B_OK;</a>
<a name="ln406">			}</a>
<a name="ln407">		}</a>
<a name="ln408">		fDuplicateNode = BPLUSTREE_NULL;</a>
<a name="ln409">	}</a>
<a name="ln410"> </a>
<a name="ln411">	off_t savedNodeOffset = fCurrentNodeOffset;</a>
<a name="ln412">	if ((node = fCache.Get(fCurrentNodeOffset)) == NULL || !CheckNode(node))</a>
<a name="ln413">		return B_ERROR;</a>
<a name="ln414"> </a>
<a name="ln415">	fCurrentKey += direction;</a>
<a name="ln416">	</a>
<a name="ln417">	// is the current key in the current node?</a>
<a name="ln418">	while ((direction == BPLUSTREE_FORWARD &amp;&amp; fCurrentKey &gt;= node-&gt;all_key_count)</a>
<a name="ln419">		   || (direction == BPLUSTREE_BACKWARD &amp;&amp; fCurrentKey &lt; 0))</a>
<a name="ln420">	{</a>
<a name="ln421">		fCurrentNodeOffset = direction == BPLUSTREE_FORWARD ? node-&gt;right_link : node-&gt;left_link;</a>
<a name="ln422"> </a>
<a name="ln423">		// are there any more nodes?</a>
<a name="ln424">		if (fCurrentNodeOffset != BPLUSTREE_NULL)</a>
<a name="ln425">		{</a>
<a name="ln426">			node = fCache.Get(fCurrentNodeOffset);</a>
<a name="ln427">			if (!node || !CheckNode(node))</a>
<a name="ln428">				return B_ERROR;</a>
<a name="ln429"> </a>
<a name="ln430">			// reset current key</a>
<a name="ln431">			fCurrentKey = direction == BPLUSTREE_FORWARD ? 0 : node-&gt;all_key_count;</a>
<a name="ln432">		}</a>
<a name="ln433">		else</a>
<a name="ln434">		{</a>
<a name="ln435">			// there are no nodes left, so turn back to the last key</a>
<a name="ln436">			fCurrentNodeOffset = savedNodeOffset;</a>
<a name="ln437">			fCurrentKey = direction == BPLUSTREE_FORWARD ? node-&gt;all_key_count : -1;</a>
<a name="ln438"> </a>
<a name="ln439">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln440">		}</a>
<a name="ln441">	}</a>
<a name="ln442"> </a>
<a name="ln443">	if (node-&gt;all_key_count == 0)</a>
<a name="ln444">		return B_ERROR; //B_ENTRY_NOT_FOUND;</a>
<a name="ln445"> </a>
<a name="ln446">	uint16 length;</a>
<a name="ln447">	uint8 *keyStart = node-&gt;KeyAt(fCurrentKey,&amp;length);</a>
<a name="ln448"> </a>
<a name="ln449">	length = min_c(length,maxLength);</a>
<a name="ln450">	memcpy(key,keyStart,length);</a>
<a name="ln451">	</a>
<a name="ln452">	if (fHeader-&gt;data_type == BPLUSTREE_STRING_TYPE)	// terminate string type</a>
<a name="ln453">	{</a>
<a name="ln454">		if (length == maxLength)</a>
<a name="ln455">			length--;</a>
<a name="ln456">		((char *)key)[length] = '\0';</a>
<a name="ln457">	}</a>
<a name="ln458">	*keyLength = length;</a>
<a name="ln459"> </a>
<a name="ln460">	off_t offset = node-&gt;Values()[fCurrentKey];</a>
<a name="ln461">	</a>
<a name="ln462">	// duplicate fragments?</a>
<a name="ln463">	uint8 type = bplustree_node::LinkType(offset);</a>
<a name="ln464">	if (type == BPLUSTREE_DUPLICATE_FRAGMENT || type == BPLUSTREE_DUPLICATE_NODE)</a>
<a name="ln465">	{</a>
<a name="ln466">		fDuplicateNode = offset;</a>
<a name="ln467"> </a>
<a name="ln468">		node = fCache.Get(bplustree_node::FragmentOffset(fDuplicateNode));</a>
<a name="ln469">		if (node == NULL)</a>
<a name="ln470">			return B_ERROR;</a>
<a name="ln471"> </a>
<a name="ln472">		fIsFragment = type == BPLUSTREE_DUPLICATE_FRAGMENT;</a>
<a name="ln473"> </a>
<a name="ln474">		fNumDuplicates = node-&gt;CountDuplicates(offset,fIsFragment);</a>
<a name="ln475">		if (fNumDuplicates)</a>
<a name="ln476">		{</a>
<a name="ln477">			// give back first duplicate</a>
<a name="ln478">			fDuplicate = 1;</a>
<a name="ln479">			offset = node-&gt;DuplicateAt(offset,fIsFragment,0);</a>
<a name="ln480">		}</a>
<a name="ln481">		else</a>
<a name="ln482">		{</a>
<a name="ln483">			// shouldn't happen, but we're dealing here with corrupt disks...</a>
<a name="ln484">			fDuplicateNode = BPLUSTREE_NULL;</a>
<a name="ln485">			offset = 0;</a>
<a name="ln486">		}</a>
<a name="ln487">	}</a>
<a name="ln488">	*value = offset;</a>
<a name="ln489"> </a>
<a name="ln490">	return B_OK;</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493"> </a>
<a name="ln494">int32 BPlusTree::CompareKeys(const void *key1, int keyLength1, const void *key2, int keyLength2)</a>
<a name="ln495">{</a>
<a name="ln496">	switch (fHeader-&gt;data_type)</a>
<a name="ln497">	{</a>
<a name="ln498">	    case BPLUSTREE_STRING_TYPE:</a>
<a name="ln499">    	{</a>
<a name="ln500">			int len = min_c(keyLength1,keyLength2);</a>
<a name="ln501">			int result = strncmp((const char *)key1,(const char *)key2,len);</a>
<a name="ln502">			</a>
<a name="ln503">			if (result == 0)</a>
<a name="ln504">				result = keyLength1 - keyLength2;</a>
<a name="ln505"> </a>
<a name="ln506">			return result;</a>
<a name="ln507">		}</a>
<a name="ln508"> </a>
<a name="ln509">		case BPLUSTREE_INT32_TYPE:</a>
<a name="ln510">			return *(int32 *)key1 - *(int32 *)key2;</a>
<a name="ln511">			</a>
<a name="ln512">		case BPLUSTREE_UINT32_TYPE:</a>
<a name="ln513">		{</a>
<a name="ln514">			if (*(uint32 *)key1 == *(uint32 *)key2)</a>
<a name="ln515">				return 0;</a>
<a name="ln516">			else if (*(uint32 *)key1 &gt; *(uint32 *)key2)</a>
<a name="ln517">				return 1;</a>
<a name="ln518"> </a>
<a name="ln519">			return -1;</a>
<a name="ln520">		}</a>
<a name="ln521">			</a>
<a name="ln522">		case BPLUSTREE_INT64_TYPE:</a>
<a name="ln523">		{</a>
<a name="ln524">			if (*(int64 *)key1 == *(int64 *)key2)</a>
<a name="ln525">				return 0;</a>
<a name="ln526">			else if (*(int64 *)key1 &gt; *(int64 *)key2)</a>
<a name="ln527">				return 1;</a>
<a name="ln528"> </a>
<a name="ln529">			return -1;</a>
<a name="ln530">		}</a>
<a name="ln531"> </a>
<a name="ln532">		case BPLUSTREE_UINT64_TYPE:</a>
<a name="ln533">		{</a>
<a name="ln534">			if (*(uint64 *)key1 == *(uint64 *)key2)</a>
<a name="ln535">				return 0;</a>
<a name="ln536">			else if (*(uint64 *)key1 &gt; *(uint64 *)key2)</a>
<a name="ln537">				return 1;</a>
<a name="ln538"> </a>
<a name="ln539">			return -1;</a>
<a name="ln540">		}</a>
<a name="ln541"> </a>
<a name="ln542">		case BPLUSTREE_FLOAT_TYPE:</a>
<a name="ln543">		{</a>
<a name="ln544">			float result = *(float *)key1 - *(float *)key2;</a>
<a name="ln545">			if (result == 0.0f)</a>
<a name="ln546">				return 0;</a>
<a name="ln547"> </a>
<a name="ln548">			return (result &lt; 0.0f) ? -1 : 1;</a>
<a name="ln549">		}</a>
<a name="ln550"> </a>
<a name="ln551">		case BPLUSTREE_DOUBLE_TYPE:</a>
<a name="ln552">		{</a>
<a name="ln553">			double result = *(double *)key1 - *(double *)key2;</a>
<a name="ln554">			if (result == 0.0)</a>
<a name="ln555">				return 0;</a>
<a name="ln556"> </a>
<a name="ln557">			return (result &lt; 0.0) ? -1 : 1;</a>
<a name="ln558">		}</a>
<a name="ln559">	}</a>
<a name="ln560">	return 0;</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563"> </a>
<a name="ln564">status_t BPlusTree::FindKey(bplustree_node *node,uint8 *key,uint16 keyLength,uint16 *index,off_t *next)</a>
<a name="ln565">{</a>
<a name="ln566">	if (node-&gt;all_key_count == 0)</a>
<a name="ln567">	{</a>
<a name="ln568">		if (index)</a>
<a name="ln569">			*index = 0;</a>
<a name="ln570">		if (next)</a>
<a name="ln571">			*next = node-&gt;overflow_link;</a>
<a name="ln572">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln573">	}</a>
<a name="ln574"> </a>
<a name="ln575">	off_t *values = node-&gt;Values();</a>
<a name="ln576">	int16 saveIndex = 0;</a>
<a name="ln577"> </a>
<a name="ln578">	// binary search in the key array</a>
<a name="ln579">	for (int16 first = 0,last = node-&gt;all_key_count - 1;first &lt;= last;)</a>
<a name="ln580">	{</a>
<a name="ln581">		uint16 i = (first + last) &gt;&gt; 1;</a>
<a name="ln582"> </a>
<a name="ln583">		uint16 searchLength;</a>
<a name="ln584">		uint8 *searchKey = node-&gt;KeyAt(i,&amp;searchLength);</a>
<a name="ln585">		</a>
<a name="ln586">		int32 cmp = CompareKeys(key,keyLength,searchKey,searchLength);</a>
<a name="ln587">		if (cmp &lt; 0)</a>
<a name="ln588">		{</a>
<a name="ln589">			last = i - 1;</a>
<a name="ln590">			saveIndex = i;</a>
<a name="ln591">		}</a>
<a name="ln592">		else if (cmp &gt; 0)</a>
<a name="ln593">		{</a>
<a name="ln594">			saveIndex = first = i + 1;</a>
<a name="ln595">		}</a>
<a name="ln596">		else</a>
<a name="ln597">		{</a>
<a name="ln598">			if (index)</a>
<a name="ln599">				*index = i;</a>
<a name="ln600">			if (next)</a>
<a name="ln601">				*next = values[i];</a>
<a name="ln602">			return B_OK;</a>
<a name="ln603">		}</a>
<a name="ln604">	}</a>
<a name="ln605"> </a>
<a name="ln606">	if (index)</a>
<a name="ln607">		*index = saveIndex;</a>
<a name="ln608">	if (next)</a>
<a name="ln609">	{</a>
<a name="ln610">		if (saveIndex == node-&gt;all_key_count)</a>
<a name="ln611">			*next = node-&gt;overflow_link;</a>
<a name="ln612">		else</a>
<a name="ln613">			*next = values[saveIndex];</a>
<a name="ln614">	}</a>
<a name="ln615">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">status_t BPlusTree::SeekDown(Stack&lt;node_and_key&gt; &amp;stack,uint8 *key,uint16 keyLength)</a>
<a name="ln620">{</a>
<a name="ln621">	node_and_key nodeAndKey;</a>
<a name="ln622">	nodeAndKey.nodeOffset = fHeader-&gt;root_node_pointer;</a>
<a name="ln623">	nodeAndKey.keyIndex = 0;</a>
<a name="ln624"> </a>
<a name="ln625">	bplustree_node *node;</a>
<a name="ln626">	while ((node = fCache.Get(nodeAndKey.nodeOffset)) != NULL &amp;&amp; CheckNode(node)) {</a>
<a name="ln627">		// if we are already on leaf level, we're done</a>
<a name="ln628">		if (node-&gt;overflow_link == BPLUSTREE_NULL) {</a>
<a name="ln629">			// put the node on the stack</a>
<a name="ln630">			// node that the keyIndex is not properly set here!</a>
<a name="ln631">			nodeAndKey.keyIndex = 0;</a>
<a name="ln632">			stack.Push(nodeAndKey);</a>
<a name="ln633">			return B_OK;</a>
<a name="ln634">		}</a>
<a name="ln635"> </a>
<a name="ln636">		off_t nextOffset;</a>
<a name="ln637">		status_t status = FindKey(node,key,keyLength,&amp;nodeAndKey.keyIndex,&amp;nextOffset);</a>
<a name="ln638"> </a>
<a name="ln639">		if (status == B_ENTRY_NOT_FOUND &amp;&amp; nextOffset == nodeAndKey.nodeOffset)</a>
<a name="ln640">			return B_ERROR;</a>
<a name="ln641"> </a>
<a name="ln642">		// put the node &amp; the correct keyIndex on the stack</a>
<a name="ln643">		stack.Push(nodeAndKey);</a>
<a name="ln644"> </a>
<a name="ln645">		nodeAndKey.nodeOffset = nextOffset;</a>
<a name="ln646">	}</a>
<a name="ln647">	return B_ERROR;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650"> </a>
<a name="ln651">void BPlusTree::InsertKey(bplustree_node *node,uint8 *key,uint16 keyLength,off_t value,uint16 index)</a>
<a name="ln652">{</a>
<a name="ln653">	// should never happen, but who knows?</a>
<a name="ln654">	if (index &gt; node-&gt;all_key_count)</a>
<a name="ln655">		return;</a>
<a name="ln656"> </a>
<a name="ln657">	off_t *values = node-&gt;Values();</a>
<a name="ln658">	uint16 *keyLengths = node-&gt;KeyLengths();</a>
<a name="ln659">	uint8 *keys = node-&gt;Keys();</a>
<a name="ln660"> </a>
<a name="ln661">	node-&gt;all_key_count++;</a>
<a name="ln662">	node-&gt;all_key_length += keyLength;</a>
<a name="ln663"> </a>
<a name="ln664">	off_t *newValues = node-&gt;Values();</a>
<a name="ln665">	uint16 *newKeyLengths = node-&gt;KeyLengths();</a>
<a name="ln666"> </a>
<a name="ln667">	// move values and copy new value into them</a>
<a name="ln668">	memmove(newValues + index + 1,values + index,sizeof(off_t) * (node-&gt;all_key_count - 1 - index));</a>
<a name="ln669">	memmove(newValues,values,sizeof(off_t) * index);</a>
<a name="ln670"> </a>
<a name="ln671">	newValues[index] = value;</a>
<a name="ln672"> </a>
<a name="ln673">	// move and update key length index</a>
<a name="ln674">	for (uint16 i = node-&gt;all_key_count;i-- &gt; index + 1;)</a>
<a name="ln675">		newKeyLengths[i] = keyLengths[i - 1] + keyLength;</a>
<a name="ln676">	memmove(newKeyLengths,keyLengths,sizeof(uint16) * index);</a>
<a name="ln677"> </a>
<a name="ln678">	int32 keyStart;</a>
<a name="ln679">	newKeyLengths[index] = keyLength + (keyStart = index &gt; 0 ? newKeyLengths[index - 1] : 0);</a>
<a name="ln680"> </a>
<a name="ln681">	// move keys and copy new key into them</a>
<a name="ln682">	int32 size = node-&gt;all_key_length - newKeyLengths[index];</a>
<a name="ln683">	if (size &gt; 0)</a>
<a name="ln684">		memmove(keys + newKeyLengths[index],keys + newKeyLengths[index] - keyLength,size);</a>
<a name="ln685"> </a>
<a name="ln686">	memcpy(keys + keyStart,key,keyLength);</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689"> </a>
<a name="ln690">status_t BPlusTree::InsertDuplicate(bplustree_node */*node*/,uint16 /*index*/)</a>
<a name="ln691">{</a>
<a name="ln692">	printf(&quot;DUPLICATE ENTRY!!\n&quot;);</a>
<a name="ln693"> </a>
<a name="ln694">//		/* handle dup keys */</a>
<a name="ln695">//		if (dupflg == 0)</a>
<a name="ln696">//		{</a>
<a name="ln697">//			bt_errno(b) = BT_DUPKEY;</a>
<a name="ln698">//			goto bombout;</a>
<a name="ln699">//		}</a>
<a name="ln700">//		else</a>
<a name="ln701">//		{</a>
<a name="ln702">//			/* paste new data ptr in page */</a>
<a name="ln703">//			/* and write it out again. */</a>
<a name="ln704">//			off_t	*p;</a>
<a name="ln705">//			p = (off_t *)KEYCLD(op-&gt;p);</a>
<a name="ln706">//			*(p + keyat) = rrn;</a>
<a name="ln707">//			op-&gt;flags = BT_CHE_DIRTY;</a>
<a name="ln708">//			if(bt_wpage(b,op) == BT_ERR ||</a>
<a name="ln709">//				bt_wpage(b,kp) == BT_ERR)</a>
<a name="ln710">//				return(BT_ERR);</a>
<a name="ln711">//</a>
<a name="ln712">//			/* mark all as well with tree */</a>
<a name="ln713">//			bt_clearerr(b);</a>
<a name="ln714">//			return(BT_OK);</a>
<a name="ln715">//		}</a>
<a name="ln716"> </a>
<a name="ln717">	return B_OK;</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720"> </a>
<a name="ln721">status_t BPlusTree::SplitNode(bplustree_node *node,off_t nodeOffset,uint16 *_keyIndex,uint8 *key,uint16 *_keyLength,off_t *_value)</a>
<a name="ln722">{</a>
<a name="ln723">	if (*_keyIndex &gt; node-&gt;all_key_count + 1)</a>
<a name="ln724">		return B_BAD_VALUE;</a>
<a name="ln725"> </a>
<a name="ln726">	//printf(&quot;before (insert \&quot;%s\&quot; (%d bytes) at %d):\n\n&quot;,key,*_keyLength,*_keyIndex);</a>
<a name="ln727">	//dump_bplustree_node(node,fHeader);</a>
<a name="ln728">	//hexdump(node,fNodeSize);</a>
<a name="ln729"> </a>
<a name="ln730">	off_t otherOffset;</a>
<a name="ln731">	bplustree_node *other = fCache.Get(otherOffset = fHeader-&gt;maximum_size); //Node(otherOffset = fHeader-&gt;maximum_size/*,false*/);</a>
<a name="ln732">	if (other == NULL)</a>
<a name="ln733">		return B_NO_MEMORY;</a>
<a name="ln734"> </a>
<a name="ln735">	uint16 *inKeyLengths = node-&gt;KeyLengths();</a>
<a name="ln736">	off_t *inKeyValues = node-&gt;Values();</a>
<a name="ln737">	uint8 *inKeys = node-&gt;Keys();</a>
<a name="ln738">	uint8 *outKeys = other-&gt;Keys();</a>
<a name="ln739">	uint16 keyIndex = *_keyIndex;</a>
<a name="ln740"> </a>
<a name="ln741">	// how many keys will fit in one (half) page?</a>
<a name="ln742"> </a>
<a name="ln743">	// &quot;bytes&quot; is the number of bytes written for the new key,</a>
<a name="ln744">	// &quot;bytesBefore&quot; are the bytes before that key</a>
<a name="ln745">	// &quot;bytesAfter&quot; are the bytes after the new key, if any</a>
<a name="ln746">	int32 bytes = 0,bytesBefore = 0,bytesAfter = 0;</a>
<a name="ln747"> </a>
<a name="ln748">	size_t size = fNodeSize &gt;&gt; 1;</a>
<a name="ln749">	int32 out,in;</a>
<a name="ln750">	for (in = out = 0;in &lt; node-&gt;all_key_count + 1;) {</a>
<a name="ln751">		if (!bytes)</a>
<a name="ln752">			bytesBefore = in &gt; 0 ? inKeyLengths[in - 1] : 0;</a>
<a name="ln753">		if (in == keyIndex &amp;&amp; !bytes) {</a>
<a name="ln754">			bytes = *_keyLength;</a>
<a name="ln755">		} else {</a>
<a name="ln756">			if (keyIndex &lt; out) {</a>
<a name="ln757">				bytesAfter = inKeyLengths[in] - bytesBefore;</a>
<a name="ln758">				// fix the key lengths for the new node</a>
<a name="ln759">				inKeyLengths[in] = bytesAfter + bytesBefore + bytes;</a>
<a name="ln760">			} //else</a>
<a name="ln761">			in++;</a>
<a name="ln762">		}</a>
<a name="ln763">		out++;</a>
<a name="ln764"> </a>
<a name="ln765">		if (round_up(sizeof(bplustree_node) + bytesBefore + bytesAfter + bytes) +</a>
<a name="ln766">						out * (sizeof(uint16) + sizeof(off_t)) &gt;= size) {</a>
<a name="ln767">			// we have found the number of keys in the new node!</a>
<a name="ln768">			break;</a>
<a name="ln769">		}</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	// if the new key was not inserted, set the length of the keys</a>
<a name="ln773">	// that can be copied directly</a>
<a name="ln774">	if (keyIndex &gt;= out &amp;&amp; in &gt; 0)</a>
<a name="ln775">		bytesBefore = inKeyLengths[in - 1];</a>
<a name="ln776"> </a>
<a name="ln777">	if (bytesBefore &lt; 0 || bytesAfter &lt; 0)</a>
<a name="ln778">		return B_BAD_DATA;</a>
<a name="ln779"> </a>
<a name="ln780">	//printf(&quot;put %ld keys in the other node (%ld, %ld, %ld) (in = %ld)\n&quot;,out,bytesBefore,bytes,bytesAfter,in);</a>
<a name="ln781"> </a>
<a name="ln782">	other-&gt;left_link = node-&gt;left_link;</a>
<a name="ln783">	other-&gt;right_link = nodeOffset;</a>
<a name="ln784">	other-&gt;all_key_length = bytes + bytesBefore + bytesAfter;</a>
<a name="ln785">	other-&gt;all_key_count = out;</a>
<a name="ln786">	//printf(&quot;-&gt; used = %ld (bplustree_node = %ld bytes)\n&quot;,other-&gt;Used(),sizeof(bplustree_node));</a>
<a name="ln787"> </a>
<a name="ln788">	uint16 *outKeyLengths = other-&gt;KeyLengths();</a>
<a name="ln789">	off_t *outKeyValues = other-&gt;Values();</a>
<a name="ln790">	int32 keys = out &gt; keyIndex ? keyIndex : out;</a>
<a name="ln791"> </a>
<a name="ln792">	if (bytesBefore) {</a>
<a name="ln793">		// copy the keys</a>
<a name="ln794">		memcpy(outKeys,inKeys,bytesBefore);</a>
<a name="ln795">		memcpy(outKeyLengths,inKeyLengths,keys * sizeof(uint16));</a>
<a name="ln796">		memcpy(outKeyValues,inKeyValues,keys * sizeof(off_t));</a>
<a name="ln797">	}</a>
<a name="ln798">	if (bytes) {</a>
<a name="ln799">		// copy the newly inserted key</a>
<a name="ln800">		memcpy(outKeys + bytesBefore,key,bytes);</a>
<a name="ln801">		outKeyLengths[keyIndex] = bytes + bytesBefore;</a>
<a name="ln802">		outKeyValues[keyIndex] = *_value;</a>
<a name="ln803"> </a>
<a name="ln804">		if (bytesAfter) {</a>
<a name="ln805">			// copy the keys after the new key</a>
<a name="ln806">			memcpy(outKeys + bytesBefore + bytes,inKeys + bytesBefore,bytesAfter);</a>
<a name="ln807">			keys = out - keyIndex - 1;</a>
<a name="ln808">			memcpy(outKeyLengths + keyIndex + 1,inKeyLengths + keyIndex,keys * sizeof(uint16));</a>
<a name="ln809">			memcpy(outKeyValues + keyIndex + 1,inKeyValues + keyIndex,keys * sizeof(off_t));</a>
<a name="ln810">		}</a>
<a name="ln811">	}</a>
<a name="ln812"> </a>
<a name="ln813">	// if the new key was already inserted, we shouldn't use it again</a>
<a name="ln814">	if (in != out)</a>
<a name="ln815">		keyIndex--;</a>
<a name="ln816"> </a>
<a name="ln817">	int32 total = bytesBefore + bytesAfter;</a>
<a name="ln818"> </a>
<a name="ln819">	// if we have split an index node, we have to drop the first key</a>
<a name="ln820">	// of the next node (which can also be the new key to insert)</a>
<a name="ln821">	if (node-&gt;overflow_link != BPLUSTREE_NULL) {</a>
<a name="ln822">		if (in == keyIndex) {</a>
<a name="ln823">			other-&gt;overflow_link = *_value;</a>
<a name="ln824">			keyIndex--;</a>
<a name="ln825">		} else {</a>
<a name="ln826">			other-&gt;overflow_link = inKeyValues[in];</a>
<a name="ln827">			total = inKeyLengths[in++];</a>
<a name="ln828">		}</a>
<a name="ln829">	}</a>
<a name="ln830"> </a>
<a name="ln831">	// and now the same game for the other page and the rest of the keys</a>
<a name="ln832">	// (but with memmove() instead of memcpy(), because they may overlap)</a>
<a name="ln833"> </a>
<a name="ln834">	bytesBefore = bytesAfter = bytes = 0;</a>
<a name="ln835">	out = 0;</a>
<a name="ln836">	int32 skip = in;</a>
<a name="ln837">	while (in &lt; node-&gt;all_key_count + 1) {</a>
<a name="ln838">		//printf(&quot;in = %ld, keyIndex = %d, bytes = %ld\n&quot;,in,keyIndex,bytes);</a>
<a name="ln839">		if (in == keyIndex &amp;&amp; !bytes) {</a>
<a name="ln840">			bytesBefore = in &gt; skip ? inKeyLengths[in - 1] : 0;</a>
<a name="ln841">			//printf(&quot;bytesBefore = %ld\n&quot;,bytesBefore);</a>
<a name="ln842">			bytes = *_keyLength;</a>
<a name="ln843">		} else if (in &lt; node-&gt;all_key_count) {</a>
<a name="ln844">			//printf(&quot;1.inKeyLength[%ld] = %u\n&quot;,in,inKeyLengths[in]);</a>
<a name="ln845">			inKeyLengths[in] -= total;</a>
<a name="ln846">			if (bytes) {</a>
<a name="ln847">				inKeyLengths[in] += bytes;</a>
<a name="ln848">				bytesAfter = inKeyLengths[in] - bytesBefore - bytes;</a>
<a name="ln849">				//printf(&quot;2.inKeyLength[%ld] = %u, bytesAfter = %ld, bytesBefore = %ld\n&quot;,in,inKeyLengths[in],bytesAfter,bytesBefore);</a>
<a name="ln850">			}</a>
<a name="ln851">			</a>
<a name="ln852">			in++;</a>
<a name="ln853">		} else</a>
<a name="ln854">			in++;</a>
<a name="ln855"> </a>
<a name="ln856">		out++;</a>
<a name="ln857"> </a>
<a name="ln858">		//printf(&quot;-&gt; out = %ld, keylen = %ld, %ld bytes total\n&quot;,out,bytesBefore,round_up(sizeof(bplustree_node) + bytesBefore + bytesAfter + bytes) +</a>
<a name="ln859">		//				out * (sizeof(uint16) + sizeof(off_t)));</a>
<a name="ln860">		if (in &gt; node-&gt;all_key_count &amp;&amp; keyIndex &lt; in)</a>
<a name="ln861">			break;</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	//printf(&quot;bytes = (%ld, %ld, %ld), in = %ld, total = %ld\n&quot;,bytesBefore,bytes,bytesAfter,in,total);</a>
<a name="ln865"> </a>
<a name="ln866">	if (keyIndex &gt;= in &amp;&amp; keyIndex - skip &lt; out) {</a>
<a name="ln867">		bytesAfter = inKeyLengths[in] - bytesBefore - total;</a>
<a name="ln868">	} else if (keyIndex &lt; skip)</a>
<a name="ln869">		bytesBefore = node-&gt;all_key_length - total;</a>
<a name="ln870"> </a>
<a name="ln871">	//printf(&quot;bytes = (%ld, %ld, %ld), in = %ld, total = %ld\n&quot;,bytesBefore,bytes,bytesAfter,in,total);</a>
<a name="ln872"> </a>
<a name="ln873">	if (bytesBefore &lt; 0 || bytesAfter &lt; 0)</a>
<a name="ln874">		return B_BAD_DATA;</a>
<a name="ln875"> </a>
<a name="ln876">	node-&gt;left_link = otherOffset;</a>
<a name="ln877">		// right link, and overflow link can stay the same</a>
<a name="ln878">	node-&gt;all_key_length = bytes + bytesBefore + bytesAfter;</a>
<a name="ln879">	node-&gt;all_key_count = out - 1;</a>
<a name="ln880"> </a>
<a name="ln881">	// array positions have changed</a>
<a name="ln882">	outKeyLengths = node-&gt;KeyLengths();</a>
<a name="ln883">	outKeyValues = node-&gt;Values();</a>
<a name="ln884"> </a>
<a name="ln885">	//printf(&quot;put %ld keys in the first node (%ld, %ld, %ld) (in = %ld)\n&quot;,out,bytesBefore,bytes,bytesAfter,in);</a>
<a name="ln886"> </a>
<a name="ln887">	// move the keys in the old node: the order is important here,</a>
<a name="ln888">	// because we don't want to overwrite any contents</a>
<a name="ln889"> </a>
<a name="ln890">	keys = keyIndex &lt;= skip ? out : keyIndex - skip;</a>
<a name="ln891">	keyIndex -= skip;</a>
<a name="ln892"> </a>
<a name="ln893">	if (bytesBefore)</a>
<a name="ln894">		memmove(inKeys,inKeys + total,bytesBefore);</a>
<a name="ln895">	if (bytesAfter)</a>
<a name="ln896">		memmove(inKeys + bytesBefore + bytes,inKeys + total + bytesBefore,bytesAfter);</a>
<a name="ln897"> </a>
<a name="ln898">	if (bytesBefore)</a>
<a name="ln899">		memmove(outKeyLengths,inKeyLengths + skip,keys * sizeof(uint16));</a>
<a name="ln900">	in = out - keyIndex - 1;</a>
<a name="ln901">	if (bytesAfter)</a>
<a name="ln902">		memmove(outKeyLengths + keyIndex + 1,inKeyLengths + skip + keyIndex,in * sizeof(uint16));</a>
<a name="ln903"> </a>
<a name="ln904">	if (bytesBefore)</a>
<a name="ln905">		memmove(outKeyValues,inKeyValues + skip,keys * sizeof(off_t));</a>
<a name="ln906">	if (bytesAfter)</a>
<a name="ln907">		memmove(outKeyValues + keyIndex + 1,inKeyValues + skip + keyIndex,in * sizeof(off_t));</a>
<a name="ln908"> </a>
<a name="ln909">	if (bytes) {</a>
<a name="ln910">		// finally, copy the newly inserted key (don't overwrite anything)</a>
<a name="ln911">		memcpy(inKeys + bytesBefore,key,bytes);</a>
<a name="ln912">		outKeyLengths[keyIndex] = bytes + bytesBefore;</a>
<a name="ln913">		outKeyValues[keyIndex] = *_value;</a>
<a name="ln914">	}</a>
<a name="ln915"> </a>
<a name="ln916">	//puts(&quot;\n!!!!!!!!!!!!!!! after: !!!!!!!!!!!!!!!\n&quot;);</a>
<a name="ln917">	//dump_bplustree_node(other,fHeader);</a>
<a name="ln918">	//hexdump(other,fNodeSize);</a>
<a name="ln919">	//puts(&quot;\n&quot;);</a>
<a name="ln920">	//dump_bplustree_node(node,fHeader);</a>
<a name="ln921">	//hexdump(node,fNodeSize);</a>
<a name="ln922"> </a>
<a name="ln923">	// write the updated nodes back</a>
<a name="ln924">	</a>
<a name="ln925">	fCache.SetDirty(otherOffset,true);</a>
<a name="ln926">	fCache.SetDirty(nodeOffset,true);</a>
<a name="ln927"> </a>
<a name="ln928">	// update the right link of the node in the left of the new node</a>
<a name="ln929">	if (other-&gt;left_link != BPLUSTREE_NULL) {</a>
<a name="ln930">		bplustree_node *left = fCache.Get(other-&gt;left_link);</a>
<a name="ln931">		if (left != NULL) {</a>
<a name="ln932">			left-&gt;right_link = otherOffset;</a>
<a name="ln933">			fCache.SetDirty(other-&gt;left_link,true);</a>
<a name="ln934">		}</a>
<a name="ln935">	}</a>
<a name="ln936"> </a>
<a name="ln937">	// prepare key to insert in the parent node</a>
<a name="ln938">	</a>
<a name="ln939">	//printf(&quot;skip: %ld, count-1: %u\n&quot;,skip,other-&gt;all_key_count - 1);</a>
<a name="ln940">	uint16 length;</a>
<a name="ln941">	uint8 *lastKey = other-&gt;KeyAt(other-&gt;all_key_count - 1,&amp;length);</a>
<a name="ln942">	memcpy(key,lastKey,length);</a>
<a name="ln943">	*_keyLength = length;</a>
<a name="ln944">	*_value = otherOffset;</a>
<a name="ln945"> </a>
<a name="ln946">	return B_OK;</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949"> </a>
<a name="ln950">status_t BPlusTree::Insert(uint8 *key,uint16 keyLength,off_t value)</a>
<a name="ln951">{</a>
<a name="ln952">	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH || keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH)</a>
<a name="ln953">		return B_BAD_VALUE;</a>
<a name="ln954"> </a>
<a name="ln955">	Stack&lt;node_and_key&gt; stack;</a>
<a name="ln956">	if (SeekDown(stack,key,keyLength) != B_OK)</a>
<a name="ln957">		return B_ERROR;</a>
<a name="ln958"> </a>
<a name="ln959">	uint8 keyBuffer[BPLUSTREE_MAX_KEY_LENGTH + 1];</a>
<a name="ln960"> </a>
<a name="ln961">	memcpy(keyBuffer,key,keyLength);</a>
<a name="ln962">	keyBuffer[keyLength] = 0;</a>
<a name="ln963"> </a>
<a name="ln964">	off_t valueToInsert = value;</a>
<a name="ln965"> </a>
<a name="ln966">	fCurrentNodeOffset = BPLUSTREE_NULL;</a>
<a name="ln967"> </a>
<a name="ln968">	node_and_key nodeAndKey;</a>
<a name="ln969">	bplustree_node *node;</a>
<a name="ln970">	uint32 count = 0;</a>
<a name="ln971"> </a>
<a name="ln972">	while (stack.Pop(&amp;nodeAndKey) &amp;&amp; (node = fCache.Get(nodeAndKey.nodeOffset)) != NULL &amp;&amp; CheckNode(node))</a>
<a name="ln973">	{</a>
<a name="ln974">		if (count++ == 0)	// first round, check for duplicate entries</a>
<a name="ln975">		{</a>
<a name="ln976">			status_t status = FindKey(node,key,keyLength,&amp;nodeAndKey.keyIndex);</a>
<a name="ln977">			if (status == B_ERROR)</a>
<a name="ln978">				return B_ERROR;</a>
<a name="ln979"> </a>
<a name="ln980">			// is this a duplicate entry?</a>
<a name="ln981">			if (status == B_OK &amp;&amp; node-&gt;overflow_link == BPLUSTREE_NULL)</a>
<a name="ln982">			{</a>
<a name="ln983">				if (fAllowDuplicates)</a>
<a name="ln984">					return InsertDuplicate(node,nodeAndKey.keyIndex);</a>
<a name="ln985">				else</a>
<a name="ln986">					return B_NAME_IN_USE;</a>
<a name="ln987">			}</a>
<a name="ln988">		}</a>
<a name="ln989"> </a>
<a name="ln990">		// is the node big enough to hold the pair?</a>
<a name="ln991">		if (int32(round_up(sizeof(bplustree_node) + node-&gt;all_key_length + keyLength)</a>
<a name="ln992">			+ (node-&gt;all_key_count + 1) * (sizeof(uint16) + sizeof(off_t))) &lt; fNodeSize)</a>
<a name="ln993">		{</a>
<a name="ln994">			InsertKey(node,keyBuffer,keyLength,valueToInsert,nodeAndKey.keyIndex);</a>
<a name="ln995">			fCache.SetDirty(nodeAndKey.nodeOffset,true);</a>
<a name="ln996"> </a>
<a name="ln997">			return B_OK;</a>
<a name="ln998">		}</a>
<a name="ln999">		else</a>
<a name="ln1000">		{</a>
<a name="ln1001">			// do we need to allocate a new root node? if so, then do</a>
<a name="ln1002">			// it now</a>
<a name="ln1003">			bplustree_node *rootNode = NULL;</a>
<a name="ln1004">			off_t newRoot = BPLUSTREE_NULL;</a>
<a name="ln1005">			if (nodeAndKey.nodeOffset == fHeader-&gt;root_node_pointer) {</a>
<a name="ln1006">				rootNode = fCache.Get(newRoot = fHeader-&gt;maximum_size);</a>
<a name="ln1007">				if (rootNode == NULL) {</a>
<a name="ln1008">					// the tree is most likely dead</a>
<a name="ln1009">					return B_NO_MEMORY;</a>
<a name="ln1010">				}</a>
<a name="ln1011">			}</a>
<a name="ln1012"> </a>
<a name="ln1013">			if (SplitNode(node,nodeAndKey.nodeOffset,&amp;nodeAndKey.keyIndex,keyBuffer,&amp;keyLength,&amp;valueToInsert) &lt; B_OK) {</a>
<a name="ln1014">				if (newRoot != BPLUSTREE_NULL) {</a>
<a name="ln1015">					// free root node</a>
<a name="ln1016">				}</a>
<a name="ln1017">				return B_ERROR;</a>
<a name="ln1018">			}</a>
<a name="ln1019"> </a>
<a name="ln1020">			if (newRoot != BPLUSTREE_NULL) {</a>
<a name="ln1021">				rootNode-&gt;overflow_link = nodeAndKey.nodeOffset;</a>
<a name="ln1022">				</a>
<a name="ln1023">				InsertKey(rootNode,keyBuffer,keyLength,node-&gt;left_link,0);</a>
<a name="ln1024"> </a>
<a name="ln1025">				fHeader-&gt;root_node_pointer = newRoot;</a>
<a name="ln1026">				fHeader-&gt;max_number_of_levels++;</a>
<a name="ln1027">				// write header</a>
<a name="ln1028">				</a>
<a name="ln1029">				fCache.SetDirty(newRoot,true);</a>
<a name="ln1030"> </a>
<a name="ln1031">				return B_OK;</a>
<a name="ln1032">			}</a>
<a name="ln1033">		}</a>
<a name="ln1034">	}</a>
<a name="ln1035"> </a>
<a name="ln1036">	return B_ERROR;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">status_t BPlusTree::Find(uint8 *key,uint16 keyLength,off_t *value)</a>
<a name="ln1041">{</a>
<a name="ln1042">	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH || keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH)</a>
<a name="ln1043">		return B_BAD_VALUE;</a>
<a name="ln1044"> </a>
<a name="ln1045">	Stack&lt;node_and_key&gt; stack;</a>
<a name="ln1046">	if (SeekDown(stack,key,keyLength) != B_OK)</a>
<a name="ln1047">		return B_ERROR;</a>
<a name="ln1048"> </a>
<a name="ln1049">	fCurrentNodeOffset = BPLUSTREE_NULL;</a>
<a name="ln1050"> </a>
<a name="ln1051">	node_and_key nodeAndKey;</a>
<a name="ln1052">	bplustree_node *node;</a>
<a name="ln1053"> </a>
<a name="ln1054">	if (stack.Pop(&amp;nodeAndKey) &amp;&amp; (node = fCache.Get(nodeAndKey.nodeOffset)) != NULL &amp;&amp; CheckNode(node))</a>
<a name="ln1055">	{</a>
<a name="ln1056">		status_t status = FindKey(node,key,keyLength,&amp;nodeAndKey.keyIndex);</a>
<a name="ln1057">		if (status == B_ERROR)</a>
<a name="ln1058">			return B_ERROR;</a>
<a name="ln1059">		</a>
<a name="ln1060">		SetCurrentNode(node,nodeAndKey.nodeOffset);</a>
<a name="ln1061"> </a>
<a name="ln1062">		if (status == B_OK &amp;&amp; node-&gt;overflow_link == BPLUSTREE_NULL)</a>
<a name="ln1063">		{</a>
<a name="ln1064">			*value = node-&gt;Values()[nodeAndKey.keyIndex];</a>
<a name="ln1065">			return B_OK;</a>
<a name="ln1066">		}</a>
<a name="ln1067">	}</a>
<a name="ln1068">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071"> </a>
<a name="ln1072">//	#pragma mark -</a>
<a name="ln1073"> </a>
<a name="ln1074"> </a>
<a name="ln1075">bool</a>
<a name="ln1076">BPlusTree::CheckNode(bplustree_node *node)</a>
<a name="ln1077">{</a>
<a name="ln1078">	if (!fHeader-&gt;IsValidLink(node-&gt;left_link)</a>
<a name="ln1079">		|| !fHeader-&gt;IsValidLink(node-&gt;right_link)</a>
<a name="ln1080">		|| !fHeader-&gt;IsValidLink(node-&gt;overflow_link)</a>
<a name="ln1081">		|| (int8 *)node-&gt;Values() + node-&gt;all_key_count * sizeof(off_t) &gt; (int8 *)node + fNodeSize)</a>
<a name="ln1082">		return false;</a>
<a name="ln1083"> </a>
<a name="ln1084">	return true;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087"> </a>
<a name="ln1088">bplustree_node *BPlusTree::Node(off_t nodeOffset,bool check)</a>
<a name="ln1089">{</a>
<a name="ln1090">/*printf(&quot;1: %d,%d,%d\n&quot;,</a>
<a name="ln1091">	nodeOffset &gt; fHeader-&gt;maximum_size - fNodeSize,</a>
<a name="ln1092">	nodeOffset &lt; 0 &amp;&amp; nodeOffset != BPLUSTREE_NULL,</a>
<a name="ln1093">	(nodeOffset % fNodeSize) != 0);</a>
<a name="ln1094">*/</a>
<a name="ln1095">	// the super node is always in memory, and shouldn't</a>
<a name="ln1096">	// never be taken out of the cache</a>
<a name="ln1097">	if (nodeOffset &gt; fHeader-&gt;maximum_size /*- fNodeSize*/</a>
<a name="ln1098">		|| nodeOffset &lt;= 0 &amp;&amp; nodeOffset != BPLUSTREE_NULL</a>
<a name="ln1099">		|| (nodeOffset % fNodeSize) != 0)</a>
<a name="ln1100">		return NULL;</a>
<a name="ln1101"> </a>
<a name="ln1102">	bplustree_node *node = (bplustree_node *)malloc(fNodeSize);</a>
<a name="ln1103">	if (node == NULL)</a>
<a name="ln1104">		return NULL;</a>
<a name="ln1105"> </a>
<a name="ln1106">	if (nodeOffset == BPLUSTREE_NULL || !fStream)</a>
<a name="ln1107">	{</a>
<a name="ln1108">	 	node-&gt;left_link = BPLUSTREE_NULL;</a>
<a name="ln1109">	 	node-&gt;right_link = BPLUSTREE_NULL;</a>
<a name="ln1110">	 	node-&gt;overflow_link = BPLUSTREE_NULL;</a>
<a name="ln1111">	 	node-&gt;all_key_count = 0;</a>
<a name="ln1112">	 	node-&gt;all_key_length = 0;</a>
<a name="ln1113">	}</a>
<a name="ln1114">	else if (fStream &amp;&amp; fStream-&gt;ReadAt(nodeOffset,node,fNodeSize) &lt; fNodeSize)</a>
<a name="ln1115">	{</a>
<a name="ln1116">		free(node);</a>
<a name="ln1117">		return NULL;</a>
<a name="ln1118">	}</a>
<a name="ln1119"> </a>
<a name="ln1120">	if (check &amp;&amp; node != NULL)</a>
<a name="ln1121">	{</a>
<a name="ln1122">		// sanity checks (links, all_key_count)</a>
<a name="ln1123">		if (!fHeader-&gt;IsValidLink(node-&gt;left_link)</a>
<a name="ln1124">			|| !fHeader-&gt;IsValidLink(node-&gt;right_link)</a>
<a name="ln1125">			|| !fHeader-&gt;IsValidLink(node-&gt;overflow_link)</a>
<a name="ln1126">			|| (int8 *)node-&gt;Values() + node-&gt;all_key_count * sizeof(off_t) &gt; (int8 *)node + fNodeSize)</a>
<a name="ln1127">			return NULL;</a>
<a name="ln1128">	}</a>
<a name="ln1129"> </a>
<a name="ln1130">	if (!fStream &amp;&amp; nodeOffset &gt; fHeader-&gt;maximum_size - fNodeSize) {</a>
<a name="ln1131">		// do some hacks here</a>
<a name="ln1132">		fHeader-&gt;maximum_size += fNodeSize;</a>
<a name="ln1133">	}</a>
<a name="ln1134"> </a>
<a name="ln1135">	return node;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138"> </a>
<a name="ln1139">void BPlusTree::SetHoldChanges(bool hold)</a>
<a name="ln1140">{</a>
<a name="ln1141">	fCache.SetHoldChanges(hold);</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144"> </a>
<a name="ln1145">//	#pragma mark -</a>
<a name="ln1146"> </a>
<a name="ln1147"> </a>
<a name="ln1148">uint8 *bplustree_node::KeyAt(int32 index,uint16 *keyLength) const</a>
<a name="ln1149">{</a>
<a name="ln1150">	if (index &lt; 0 || index &gt; all_key_count)</a>
<a name="ln1151">		return NULL;</a>
<a name="ln1152"> </a>
<a name="ln1153">	uint8 *keyStart = Keys();</a>
<a name="ln1154">	uint16 *keyLengths = KeyLengths();</a>
<a name="ln1155"> </a>
<a name="ln1156">	*keyLength = keyLengths[index] - (index != 0 ? keyLengths[index - 1] : 0);</a>
<a name="ln1157">	if (index &gt; 0)</a>
<a name="ln1158">		keyStart += keyLengths[index - 1];</a>
<a name="ln1159">	</a>
<a name="ln1160">	return keyStart;</a>
<a name="ln1161">}</a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164">uint8 bplustree_node::CountDuplicates(off_t offset,bool isFragment) const</a>
<a name="ln1165">{</a>
<a name="ln1166">	// the duplicate fragment handling is currently hard-coded to a node size</a>
<a name="ln1167">	// of 1024 bytes - with future versions of BFS, this may be a problem</a>
<a name="ln1168"> </a>
<a name="ln1169">	if (isFragment)</a>
<a name="ln1170">	{</a>
<a name="ln1171">		uint32 fragment = 8 * ((uint64)offset &amp; 0x3ff);</a>
<a name="ln1172">	</a>
<a name="ln1173">		return ((off_t *)this)[fragment];</a>
<a name="ln1174">	}</a>
<a name="ln1175">	return overflow_link;</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178"> </a>
<a name="ln1179">off_t bplustree_node::DuplicateAt(off_t offset,bool isFragment,int8 index) const</a>
<a name="ln1180">{</a>
<a name="ln1181">	uint32 start;</a>
<a name="ln1182">	if (isFragment)</a>
<a name="ln1183">		start = 8 * ((uint64)offset &amp; 0x3ff);</a>
<a name="ln1184">	else</a>
<a name="ln1185">		start = 2;</a>
<a name="ln1186"> </a>
<a name="ln1187">	return ((off_t *)this)[start + 1 + index];</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>

</code></pre>
<div class="balloon" rel="95"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fCurrentKey, fDuplicateNode, fDuplicate, fNumDuplicates, fIsFragment.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
