
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ifconfig.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2015, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> *		Oliver Tappe, zooey@hirschkaefer.de</a>
<a name="ln8"> *		Atis Elsts, the.kfx@gmail.com</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;errno.h&gt;</a>
<a name="ln13">#include &lt;net/if_media.h&gt;</a>
<a name="ln14">#include &lt;net/if_types.h&gt;</a>
<a name="ln15">#include &lt;stdio.h&gt;</a>
<a name="ln16">#include &lt;stdlib.h&gt;</a>
<a name="ln17">#include &lt;string.h&gt;</a>
<a name="ln18">#include &lt;sys/sockio.h&gt;</a>
<a name="ln19">#include &lt;unistd.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;Message.h&gt;</a>
<a name="ln22">#include &lt;Messenger.h&gt;</a>
<a name="ln23">#include &lt;NetworkDevice.h&gt;</a>
<a name="ln24">#include &lt;NetworkInterface.h&gt;</a>
<a name="ln25">#include &lt;NetworkRoster.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;NetServer.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">extern &quot;C&quot; {</a>
<a name="ln30">#	include &lt;freebsd_network/compat/sys/cdefs.h&gt;</a>
<a name="ln31">#	include &lt;freebsd_network/compat/sys/ioccom.h&gt;</a>
<a name="ln32">#	include &lt;net80211/ieee80211_ioctl.h&gt;</a>
<a name="ln33">}</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;MediaTypes.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">extern const char* __progname;</a>
<a name="ln39">const char* kProgramName = __progname;</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">enum preferred_output_format {</a>
<a name="ln43">	PREFER_OUTPUT_MASK,</a>
<a name="ln44">	PREFER_OUTPUT_PREFIX_LENGTH,</a>
<a name="ln45">};</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">struct address_family {</a>
<a name="ln49">	int			family;</a>
<a name="ln50">	const char*	name;</a>
<a name="ln51">	const char*	identifiers[4];</a>
<a name="ln52">	preferred_output_format	preferred_format;</a>
<a name="ln53">};</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">static const address_family kFamilies[] = {</a>
<a name="ln57">	{</a>
<a name="ln58">		AF_INET,</a>
<a name="ln59">		&quot;inet&quot;,</a>
<a name="ln60">		{&quot;AF_INET&quot;, &quot;inet&quot;, &quot;ipv4&quot;, NULL},</a>
<a name="ln61">		PREFER_OUTPUT_MASK</a>
<a name="ln62">	},</a>
<a name="ln63">	{</a>
<a name="ln64">		AF_INET6,</a>
<a name="ln65">		&quot;inet6&quot;,</a>
<a name="ln66">		{&quot;AF_INET6&quot;, &quot;inet6&quot;, &quot;ipv6&quot;, NULL},</a>
<a name="ln67">		PREFER_OUTPUT_PREFIX_LENGTH</a>
<a name="ln68">	},</a>
<a name="ln69">	{ -1, NULL, {NULL}, PREFER_OUTPUT_MASK }</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">static void</a>
<a name="ln74">usage(int status)</a>
<a name="ln75">{</a>
<a name="ln76">	printf(&quot;usage: %s [&lt;interface&gt; [&lt;address family&gt;] [&lt;address&gt; [&lt;mask&gt;] | &quot;</a>
<a name="ln77">			&quot;auto-config] [&lt;option/flags&gt;...]]\n&quot;</a>
<a name="ln78">		&quot;       %s --delete &lt;interface&gt; [...]\n&quot;</a>
<a name="ln79">		&quot;       %s &lt;interface&gt; [scan|join|leave] [&lt;network&gt; &quot;</a>
<a name="ln80">			&quot;[&lt;password&gt;]]\n\n&quot;</a>
<a name="ln81">		&quot;Where &lt;option&gt; can be the following:\n&quot;</a>
<a name="ln82">		&quot;  netmask &lt;addr&gt;     - networking subnet mask\n&quot;</a>
<a name="ln83">		&quot;  prefixlen &lt;number&gt; - subnet mask length in bits\n&quot;</a>
<a name="ln84">		&quot;  broadcast &lt;addr&gt;   - set broadcast address\n&quot;</a>
<a name="ln85">		&quot;  peer &lt;addr&gt;        - ppp-peer address\n&quot;</a>
<a name="ln86">		&quot;  mtu &lt;bytes&gt;        - maximal transfer unit\n&quot;</a>
<a name="ln87">		&quot;  metric &lt;number&gt;    - metric number to use (defaults to 0)\n&quot;</a>
<a name="ln88">		&quot;  media &lt;media&gt;      - media type to use (defaults to auto)\n&quot;,</a>
<a name="ln89">		kProgramName, kProgramName, kProgramName);</a>
<a name="ln90"> </a>
<a name="ln91">	for (int32 i = 0; const char* type = get_media_type_name(i); i++) {</a>
<a name="ln92">		printf(&quot;For %s &lt;media&gt; can be one of: &quot;, type);</a>
<a name="ln93">		for (int32 j = 0; const char* subType = get_media_subtype_name(i, j);</a>
<a name="ln94">				j++) {</a>
<a name="ln95">			printf(&quot;%s &quot;, subType);</a>
<a name="ln96">		}</a>
<a name="ln97">		printf(&quot;\n&quot;);</a>
<a name="ln98">	}</a>
<a name="ln99">	printf(&quot;And &lt;flags&gt; can be: up, down, [-]promisc, [-]allmulti, [-]bcast, &quot;</a>
<a name="ln100">			&quot;[-]ht, loopback\n&quot;</a>
<a name="ln101">		&quot;If you specify \&quot;auto-config\&quot; instead of an address, it will be &quot;</a>
<a name="ln102">			&quot;configured automatically.\n\n&quot;</a>
<a name="ln103">		&quot;Example:\n&quot;</a>
<a name="ln104">		&quot;\t%s loop 127.0.0.1 255.0.0.0 up\n&quot;,</a>
<a name="ln105">		kProgramName);</a>
<a name="ln106"> </a>
<a name="ln107">	exit(status);</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">int</a>
<a name="ln112">get_address_family(const char* argument)</a>
<a name="ln113">{</a>
<a name="ln114">	for (int32 i = 0; kFamilies[i].family &gt;= 0; i++) {</a>
<a name="ln115">		for (int32 j = 0; kFamilies[i].identifiers[j]; j++) {</a>
<a name="ln116">			if (!strcmp(argument, kFamilies[i].identifiers[j])) {</a>
<a name="ln117">				// found a match</a>
<a name="ln118">				return kFamilies[i].family;</a>
<a name="ln119">			}</a>
<a name="ln120">		}</a>
<a name="ln121">	}</a>
<a name="ln122"> </a>
<a name="ln123">	return AF_UNSPEC;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">static const address_family*</a>
<a name="ln128">address_family_for(int family)</a>
<a name="ln129">{</a>
<a name="ln130">	for (int32 i = 0; kFamilies[i].family &gt;= 0; i++) {</a>
<a name="ln131">		if (kFamilies[i].family == family)</a>
<a name="ln132">			return &amp;kFamilies[i];</a>
<a name="ln133">	}</a>
<a name="ln134"> </a>
<a name="ln135">	// defaults to AF_INET</a>
<a name="ln136">	return &amp;kFamilies[0];</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">/*!	Parses the \a argument as network \a address for the specified \a family.</a>
<a name="ln141">	If \a family is \c AF_UNSPEC, \a family will be overwritten with the family</a>
<a name="ln142">	of the successfully parsed address.</a>
<a name="ln143">*/</a>
<a name="ln144">bool</a>
<a name="ln145">parse_address(int&amp; family, const char* argument, BNetworkAddress&amp; address)</a>
<a name="ln146">{</a>
<a name="ln147">	if (argument == NULL)</a>
<a name="ln148">		return false;</a>
<a name="ln149"> </a>
<a name="ln150">	status_t status = address.SetTo(family, argument, (uint16)0,</a>
<a name="ln151">		B_NO_ADDRESS_RESOLUTION);</a>
<a name="ln152">	if (status != B_OK)</a>
<a name="ln153">		return false;</a>
<a name="ln154"> </a>
<a name="ln155">	if (family == AF_UNSPEC) {</a>
<a name="ln156">		// Test if we support the resulting address family</a>
<a name="ln157">		bool supported = false;</a>
<a name="ln158"> </a>
<a name="ln159">		for (int32 i = 0; kFamilies[i].family &gt;= 0; i++) {</a>
<a name="ln160">			if (kFamilies[i].family == address.Family()) {</a>
<a name="ln161">				supported = true;</a>
<a name="ln162">				break;</a>
<a name="ln163">			}</a>
<a name="ln164">		}</a>
<a name="ln165">		if (!supported)</a>
<a name="ln166">			return false;</a>
<a name="ln167"> </a>
<a name="ln168">		// Take over family from address</a>
<a name="ln169">		family = address.Family();</a>
<a name="ln170">	}</a>
<a name="ln171"> </a>
<a name="ln172">	return true;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">bool</a>
<a name="ln177">prefix_length_to_mask(int family, const char* argument, BNetworkAddress&amp; mask)</a>
<a name="ln178">{</a>
<a name="ln179">	char *end;</a>
<a name="ln180">	uint32 prefixLength = strtoul(argument, &amp;end, 10);</a>
<a name="ln181">	if (end == argument)</a>
<a name="ln182">		return false;</a>
<a name="ln183"> </a>
<a name="ln184">	return mask.SetToMask(family, prefixLength) == B_OK;</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187"> </a>
<a name="ln188">BString</a>
<a name="ln189">to_string(const BNetworkAddress&amp; address)</a>
<a name="ln190">{</a>
<a name="ln191">	if (address.IsEmpty())</a>
<a name="ln192">		return &quot;--&quot;;</a>
<a name="ln193"> </a>
<a name="ln194">	return address.ToString();</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197"> </a>
<a name="ln198">//	#pragma mark - wireless support</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">const char*</a>
<a name="ln202">get_key_mode(uint32 mode)</a>
<a name="ln203">{</a>
<a name="ln204">	if ((mode &amp; B_KEY_MODE_WPS) != 0)</a>
<a name="ln205">		return &quot;WPS&quot;;</a>
<a name="ln206">	if ((mode &amp; B_KEY_MODE_PSK_SHA256) != 0)</a>
<a name="ln207">		return &quot;PSK-SHA256&quot;;</a>
<a name="ln208">	if ((mode &amp; B_KEY_MODE_IEEE802_1X_SHA256) != 0)</a>
<a name="ln209">		return &quot;IEEE 802.1x-SHA256&quot;;</a>
<a name="ln210">	if ((mode &amp; B_KEY_MODE_FT_PSK) != 0)</a>
<a name="ln211">		return &quot;FT-PSK&quot;;</a>
<a name="ln212">	if ((mode &amp; B_KEY_MODE_FT_IEEE802_1X) != 0)</a>
<a name="ln213">		return &quot;FT-IEEE 802.1x&quot;;</a>
<a name="ln214">	if ((mode &amp; B_KEY_MODE_NONE) != 0)</a>
<a name="ln215">		return &quot;-&quot;;</a>
<a name="ln216">	if ((mode &amp; B_KEY_MODE_PSK) != 0)</a>
<a name="ln217">		return &quot;PSK&quot;;</a>
<a name="ln218">	if ((mode &amp; B_KEY_MODE_IEEE802_1X) != 0)</a>
<a name="ln219">		return &quot;IEEE 802.1x&quot;;</a>
<a name="ln220"> </a>
<a name="ln221">	return &quot;&quot;;</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225">const char*</a>
<a name="ln226">get_cipher(uint32 cipher)</a>
<a name="ln227">{</a>
<a name="ln228">	if ((cipher &amp; B_NETWORK_CIPHER_AES_128_CMAC) != 0)</a>
<a name="ln229">		return &quot;AES-128-CMAC&quot;;</a>
<a name="ln230">	if ((cipher &amp; B_NETWORK_CIPHER_CCMP) != 0)</a>
<a name="ln231">		return &quot;CCMP&quot;;</a>
<a name="ln232">	if ((cipher &amp; B_NETWORK_CIPHER_TKIP) != 0)</a>
<a name="ln233">		return &quot;TKIP&quot;;</a>
<a name="ln234">	if ((cipher &amp; B_NETWORK_CIPHER_WEP_104) != 0)</a>
<a name="ln235">		return &quot;WEP-104&quot;;</a>
<a name="ln236">	if ((cipher &amp; B_NETWORK_CIPHER_WEP_40) != 0)</a>
<a name="ln237">		return &quot;WEP-40&quot;;</a>
<a name="ln238"> </a>
<a name="ln239">	return &quot;&quot;;</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242"> </a>
<a name="ln243">const char*</a>
<a name="ln244">get_authentication_mode(uint32 mode, uint32 flags)</a>
<a name="ln245">{</a>
<a name="ln246">	switch (mode) {</a>
<a name="ln247">		default:</a>
<a name="ln248">		case B_NETWORK_AUTHENTICATION_NONE:</a>
<a name="ln249">			if ((flags &amp; B_NETWORK_IS_ENCRYPTED) != 0)</a>
<a name="ln250">				return &quot;(encrypted)&quot;;</a>
<a name="ln251">			return &quot;-&quot;;</a>
<a name="ln252">		case B_NETWORK_AUTHENTICATION_WEP:</a>
<a name="ln253">			return &quot;WEP&quot;;</a>
<a name="ln254">		case B_NETWORK_AUTHENTICATION_WPA:</a>
<a name="ln255">			return &quot;WPA&quot;;</a>
<a name="ln256">		case B_NETWORK_AUTHENTICATION_WPA2:</a>
<a name="ln257">			return &quot;WPA2&quot;;</a>
<a name="ln258">	}</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">void</a>
<a name="ln263">show_wireless_network_header(bool verbose)</a>
<a name="ln264">{</a>
<a name="ln265">	printf(&quot;%-32s %-20s %s  %s\n&quot;, &quot;name&quot;, &quot;address&quot;, &quot;signal&quot;, &quot;auth&quot;);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">void</a>
<a name="ln270">show_wireless_network(const wireless_network&amp; network, bool verbose)</a>
<a name="ln271">{</a>
<a name="ln272">	printf(&quot;%-32s %-20s %6u  %s\n&quot;, network.name,</a>
<a name="ln273">		network.address.ToString().String(),</a>
<a name="ln274">		network.signal_strength / 2,</a>
<a name="ln275">		get_authentication_mode(network.authentication_mode, network.flags));</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278"> </a>
<a name="ln279">bool</a>
<a name="ln280">configure_wireless(const char* name, char* const* args, int32 argCount)</a>
<a name="ln281">{</a>
<a name="ln282">	enum {</a>
<a name="ln283">		NONE,</a>
<a name="ln284">		SCAN,</a>
<a name="ln285">		LIST,</a>
<a name="ln286">		JOIN,</a>
<a name="ln287">		LEAVE,</a>
<a name="ln288">		CONTROL</a>
<a name="ln289">	} mode = NONE;</a>
<a name="ln290"> </a>
<a name="ln291">	int controlOption = -1;</a>
<a name="ln292">	int controlValue = -1;</a>
<a name="ln293"> </a>
<a name="ln294">	if (!strcmp(args[0], &quot;scan&quot;))</a>
<a name="ln295">		mode = SCAN;</a>
<a name="ln296">	else if (!strcmp(args[0], &quot;list&quot;))</a>
<a name="ln297">		mode = LIST;</a>
<a name="ln298">	else if (!strcmp(args[0], &quot;join&quot;))</a>
<a name="ln299">		mode = JOIN;</a>
<a name="ln300">	else if (!strcmp(args[0], &quot;leave&quot;))</a>
<a name="ln301">		mode = LEAVE;</a>
<a name="ln302">	else if (!strcmp(args[0], &quot;ht&quot;)) {</a>
<a name="ln303">		mode = CONTROL;</a>
<a name="ln304">		controlOption = IEEE80211_IOC_HTCONF;</a>
<a name="ln305">		controlValue = 3;</a>
<a name="ln306">	} else if (!strcmp(args[0], &quot;-ht&quot;)) {</a>
<a name="ln307">		mode = CONTROL;</a>
<a name="ln308">		controlOption = IEEE80211_IOC_HTCONF;</a>
<a name="ln309">		controlValue = 0;</a>
<a name="ln310">	}</a>
<a name="ln311"> </a>
<a name="ln312">	if (mode == NONE)</a>
<a name="ln313">		return false;</a>
<a name="ln314"> </a>
<a name="ln315">	BNetworkDevice device(name);</a>
<a name="ln316">	if (!device.Exists()) {</a>
<a name="ln317">		fprintf(stderr, &quot;%s: \&quot;%s\&quot; does not exist!\n&quot;, kProgramName, name);</a>
<a name="ln318">		exit(1);</a>
<a name="ln319">	}</a>
<a name="ln320">	if (!device.IsWireless()) {</a>
<a name="ln321">		fprintf(stderr, &quot;%s: \&quot;%s\&quot; is not a WLAN device!\n&quot;, kProgramName,</a>
<a name="ln322">			name);</a>
<a name="ln323">		exit(1);</a>
<a name="ln324">	}</a>
<a name="ln325"> </a>
<a name="ln326">	args++;</a>
<a name="ln327">	argCount--;</a>
<a name="ln328"> </a>
<a name="ln329">	switch (mode) {</a>
<a name="ln330">		case SCAN:</a>
<a name="ln331">		{</a>
<a name="ln332">			status_t status = device.Scan(true, true);</a>
<a name="ln333">			if (status != B_OK) {</a>
<a name="ln334">				fprintf(stderr, &quot;%s: Scan on \&quot;%s\&quot; failed: %s\n&quot;, kProgramName,</a>
<a name="ln335">					name, strerror(status));</a>
<a name="ln336">				exit(1);</a>
<a name="ln337">			}</a>
<a name="ln338">			// fall through</a>
<a name="ln339">		}</a>
<a name="ln340">		case LIST:</a>
<a name="ln341">		{</a>
<a name="ln342">			// list wireless network(s)</a>
<a name="ln343"> </a>
<a name="ln344">			bool verbose = false;</a>
<a name="ln345">			if (argCount &gt; 0 &amp;&amp; !strcmp(args[0], &quot;-v&quot;)) {</a>
<a name="ln346">				verbose = true;</a>
<a name="ln347">				args++;</a>
<a name="ln348">				argCount--;</a>
<a name="ln349">			}</a>
<a name="ln350">			show_wireless_network_header(verbose);</a>
<a name="ln351"> </a>
<a name="ln352">			if (argCount &gt; 0) {</a>
<a name="ln353">				// list the named entries</a>
<a name="ln354">				for (int32 i = 0; i &lt; argCount; i++) {</a>
<a name="ln355">					wireless_network network;</a>
<a name="ln356">					BNetworkAddress link;</a>
<a name="ln357">					status_t status;</a>
<a name="ln358">					if (link.SetTo(AF_LINK, args[i]) == B_OK)</a>
<a name="ln359">						status = device.GetNetwork(link, network);</a>
<a name="ln360">					else</a>
<a name="ln361">						status = device.GetNetwork(args[i], network);</a>
<a name="ln362">					if (status != B_OK) {</a>
<a name="ln363">						fprintf(stderr, &quot;%s: Getting network failed: %s\n&quot;,</a>
<a name="ln364">							kProgramName, strerror(status));</a>
<a name="ln365">					} else</a>
<a name="ln366">						show_wireless_network(network, verbose);</a>
<a name="ln367">				}</a>
<a name="ln368">			} else {</a>
<a name="ln369">				// list them all</a>
<a name="ln370">				wireless_network network;</a>
<a name="ln371">				uint32 cookie = 0;</a>
<a name="ln372">				while (device.GetNextNetwork(cookie, network) == B_OK)</a>
<a name="ln373">					show_wireless_network(network, verbose);</a>
<a name="ln374">			}</a>
<a name="ln375">			break;</a>
<a name="ln376">		}</a>
<a name="ln377"> </a>
<a name="ln378">		case JOIN:</a>
<a name="ln379">		{</a>
<a name="ln380">			// join a wireless network</a>
<a name="ln381">			if (argCount &gt; 2) {</a>
<a name="ln382">				fprintf(stderr, &quot;usage: %s %s join &lt;network&gt; [&lt;password&gt;]\n&quot;,</a>
<a name="ln383">					kProgramName, name);</a>
<a name="ln384">				exit(1);</a>
<a name="ln385">			}</a>
<a name="ln386"> </a>
<a name="ln387">			const char* password = NULL;</a>
<a name="ln388">			if (argCount == 2)</a>
<a name="ln389">				password = args[1];</a>
<a name="ln390"> </a>
<a name="ln391">			BNetworkAddress link;</a>
<a name="ln392">			status_t status;</a>
<a name="ln393">			if (link.SetTo(AF_LINK, args[0]) == B_OK)</a>
<a name="ln394">				status = device.JoinNetwork(link, password);</a>
<a name="ln395">			else</a>
<a name="ln396">				status = device.JoinNetwork(args[0], password);</a>
<a name="ln397">			if (status != B_OK) {</a>
<a name="ln398">				fprintf(stderr, &quot;%s: Joining network failed: %s\n&quot;,</a>
<a name="ln399">					kProgramName, strerror(status));</a>
<a name="ln400">				exit(1);</a>
<a name="ln401">			}</a>
<a name="ln402">			break;</a>
<a name="ln403">		}</a>
<a name="ln404"> </a>
<a name="ln405">		case LEAVE:</a>
<a name="ln406">		{</a>
<a name="ln407">			// leave a wireless network</a>
<a name="ln408">			if (argCount != 1) {</a>
<a name="ln409">				fprintf(stderr, &quot;usage: %s %s leave &lt;network&gt;\n&quot;, kProgramName,</a>
<a name="ln410">					name);</a>
<a name="ln411">				exit(1);</a>
<a name="ln412">			}</a>
<a name="ln413"> </a>
<a name="ln414">			BNetworkAddress link;</a>
<a name="ln415">			status_t status;</a>
<a name="ln416">			if (link.SetTo(AF_LINK, args[0]) == B_OK)</a>
<a name="ln417">				status = device.LeaveNetwork(link);</a>
<a name="ln418">			else</a>
<a name="ln419">				status = device.LeaveNetwork(args[0]);</a>
<a name="ln420">			if (status != B_OK) {</a>
<a name="ln421">				fprintf(stderr, &quot;%s: Leaving network failed: %s\n&quot;,</a>
<a name="ln422">					kProgramName, strerror(status));</a>
<a name="ln423">				exit(1);</a>
<a name="ln424">			}</a>
<a name="ln425">			break;</a>
<a name="ln426">		}</a>
<a name="ln427"> </a>
<a name="ln428">		case CONTROL:</a>
<a name="ln429">		{</a>
<a name="ln430">			ieee80211req request;</a>
<a name="ln431">			memset(&amp;request, 0, sizeof(request));</a>
<a name="ln432">			request.i_type = controlOption;</a>
<a name="ln433">			request.i_val = controlValue;</a>
<a name="ln434">			status_t status = device.Control(SIOCS80211, &amp;request);</a>
<a name="ln435">			if (status != B_OK) {</a>
<a name="ln436">				fprintf(stderr, &quot;%s: Control failed: %s\n&quot;, kProgramName,</a>
<a name="ln437">					strerror(status));</a>
<a name="ln438">				exit(1);</a>
<a name="ln439">			}</a>
<a name="ln440">			break;</a>
<a name="ln441">		}</a>
<a name="ln442"> </a>
<a name="ln443">		case NONE:</a>
<a name="ln444">			break;</a>
<a name="ln445">	}</a>
<a name="ln446"> </a>
<a name="ln447">	return true;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450"> </a>
<a name="ln451">//	#pragma mark -</a>
<a name="ln452"> </a>
<a name="ln453"> </a>
<a name="ln454">void</a>
<a name="ln455">list_interface_addresses(BNetworkInterface&amp; interface, uint32 flags)</a>
<a name="ln456">{</a>
<a name="ln457">	int32 count = interface.CountAddresses();</a>
<a name="ln458">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln459">		BNetworkInterfaceAddress address;</a>
<a name="ln460">		if (interface.GetAddressAt(i, address) != B_OK)</a>
<a name="ln461">			break;</a>
<a name="ln462"> </a>
<a name="ln463">		const address_family* family</a>
<a name="ln464">			= address_family_for(address.Address().Family());</a>
<a name="ln465"> </a>
<a name="ln466">		printf(&quot;\t%s addr: %s&quot;, family-&gt;name,</a>
<a name="ln467">			to_string(address.Address()).String());</a>
<a name="ln468"> </a>
<a name="ln469">		if ((flags &amp; IFF_BROADCAST) != 0)</a>
<a name="ln470">			printf(&quot;, Bcast: %s&quot;, to_string(address.Broadcast()).String());</a>
<a name="ln471"> </a>
<a name="ln472">		switch (family-&gt;preferred_format) {</a>
<a name="ln473">			case PREFER_OUTPUT_MASK:</a>
<a name="ln474">				printf(&quot;, Mask: %s&quot;, to_string(address.Mask()).String());</a>
<a name="ln475">				break;</a>
<a name="ln476">			case PREFER_OUTPUT_PREFIX_LENGTH:</a>
<a name="ln477">				printf(&quot;, Prefix Length: %zu&quot;, address.Mask().PrefixLength());</a>
<a name="ln478">				break;</a>
<a name="ln479">		}</a>
<a name="ln480"> </a>
<a name="ln481">		putchar('\n');</a>
<a name="ln482">	}</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485"> </a>
<a name="ln486">bool</a>
<a name="ln487">list_interface(const char* name)</a>
<a name="ln488">{</a>
<a name="ln489">	printf(&quot;%s&quot;, name);</a>
<a name="ln490">	size_t length = strlen(name);</a>
<a name="ln491">	if (length &lt; 8)</a>
<a name="ln492">		putchar('\t');</a>
<a name="ln493">	else</a>
<a name="ln494">		printf(&quot;\n\t&quot;);</a>
<a name="ln495"> </a>
<a name="ln496">	// get link level interface for this interface</a>
<a name="ln497"> </a>
<a name="ln498">	BNetworkInterface interface(name);</a>
<a name="ln499">	if (!interface.Exists()) {</a>
<a name="ln500">		printf(&quot;Interface not found!\n&quot;);</a>
<a name="ln501">		return false;</a>
<a name="ln502">	}</a>
<a name="ln503"> </a>
<a name="ln504">	BNetworkAddress linkAddress;</a>
<a name="ln505">	status_t status = interface.GetHardwareAddress(linkAddress);</a>
<a name="ln506">	if (status == B_OK) {</a>
<a name="ln507">		const char *type = &quot;unknown&quot;;</a>
<a name="ln508">		switch (linkAddress.LinkLevelType()) {</a>
<a name="ln509">			case IFT_ETHER:</a>
<a name="ln510">				type = &quot;Ethernet&quot;;</a>
<a name="ln511">				break;</a>
<a name="ln512">			case IFT_LOOP:</a>
<a name="ln513">				type = &quot;Local Loopback&quot;;</a>
<a name="ln514">				break;</a>
<a name="ln515">			case IFT_MODEM:</a>
<a name="ln516">				type = &quot;Modem&quot;;</a>
<a name="ln517">				break;</a>
<a name="ln518">		}</a>
<a name="ln519"> </a>
<a name="ln520">		BString address = linkAddress.ToString();</a>
<a name="ln521">		if (address.Length() == 0)</a>
<a name="ln522">			address = &quot;none&quot;;</a>
<a name="ln523"> </a>
<a name="ln524">		printf(&quot;Hardware type: %s, Address: %s\n&quot;, type, address.String());</a>
<a name="ln525">	} else</a>
<a name="ln526">		printf(&quot;No link level: %s\n&quot;, strerror(status));</a>
<a name="ln527"> </a>
<a name="ln528">	int media = interface.Media();</a>
<a name="ln529">	if ((media &amp; IFM_ACTIVE) != 0) {</a>
<a name="ln530">		// dump media state in case we're linked</a>
<a name="ln531">		const char* type = media_type_to_string(media);</a>
<a name="ln532">		if (type != NULL)</a>
<a name="ln533">			printf(&quot;\tMedia type: %s\n&quot;, type);</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	// Print associated wireless network(s)</a>
<a name="ln537"> </a>
<a name="ln538">	BNetworkDevice device(name);</a>
<a name="ln539">	if (device.IsWireless()) {</a>
<a name="ln540">		wireless_network network;</a>
<a name="ln541">		bool first = true;</a>
<a name="ln542">		uint32 cookie = 0;</a>
<a name="ln543">		while (device.GetNextAssociatedNetwork(cookie, network) == B_OK) {</a>
<a name="ln544">			if (first) {</a>
<a name="ln545">				printf(&quot;\tNetwork: &quot;);</a>
<a name="ln546">				first = false;</a>
<a name="ln547">			} else</a>
<a name="ln548">				printf(&quot;\t\t&quot;);</a>
<a name="ln549"> </a>
<a name="ln550">			printf(&quot;%s, Address: %s, %s&quot;, network.name,</a>
<a name="ln551">				network.address.ToString().String(),</a>
<a name="ln552">				get_authentication_mode(network.authentication_mode,</a>
<a name="ln553">					network.flags));</a>
<a name="ln554">			const char* keyMode = get_key_mode(network.key_mode);</a>
<a name="ln555">			if (keyMode != NULL)</a>
<a name="ln556">				printf(&quot;, %s/%s&quot;, keyMode, get_cipher(network.cipher));</a>
<a name="ln557">			putchar('\n');</a>
<a name="ln558">		}</a>
<a name="ln559">	}</a>
<a name="ln560"> </a>
<a name="ln561">	uint32 flags = interface.Flags();</a>
<a name="ln562"> </a>
<a name="ln563">	list_interface_addresses(interface, flags);</a>
<a name="ln564"> </a>
<a name="ln565">	// Print MTU, metric, flags</a>
<a name="ln566"> </a>
<a name="ln567">	printf(&quot;\tMTU: %&quot; B_PRId32 &quot;, Metric: %&quot; B_PRId32, interface.MTU(),</a>
<a name="ln568">		interface.Metric());</a>
<a name="ln569"> </a>
<a name="ln570">	if (flags != 0) {</a>
<a name="ln571">		const struct {</a>
<a name="ln572">			int			value;</a>
<a name="ln573">			const char	*name;</a>
<a name="ln574">		} kFlags[] = {</a>
<a name="ln575">			{IFF_UP, &quot;up&quot;},</a>
<a name="ln576">			{IFF_NOARP, &quot;noarp&quot;},</a>
<a name="ln577">			{IFF_BROADCAST, &quot;broadcast&quot;},</a>
<a name="ln578">			{IFF_LOOPBACK, &quot;loopback&quot;},</a>
<a name="ln579">			{IFF_PROMISC, &quot;promiscuous&quot;},</a>
<a name="ln580">			{IFF_ALLMULTI, &quot;allmulti&quot;},</a>
<a name="ln581">			{IFF_AUTOUP, &quot;autoup&quot;},</a>
<a name="ln582">			{IFF_LINK, &quot;link&quot;},</a>
<a name="ln583">			{IFF_AUTO_CONFIGURED, &quot;auto-configured&quot;},</a>
<a name="ln584">			{IFF_CONFIGURING, &quot;configuring&quot;},</a>
<a name="ln585">		};</a>
<a name="ln586">		bool first = true;</a>
<a name="ln587"> </a>
<a name="ln588">		for (uint32 i = 0; i &lt; sizeof(kFlags) / sizeof(kFlags[0]); i++) {</a>
<a name="ln589">			if ((flags &amp; kFlags[i].value) != 0) {</a>
<a name="ln590">				if (first) {</a>
<a name="ln591">					printf(&quot;,&quot;);</a>
<a name="ln592">					first = false;</a>
<a name="ln593">				}</a>
<a name="ln594">				putchar(' ');</a>
<a name="ln595">				printf(kFlags[i].name);</a>
<a name="ln596">			}</a>
<a name="ln597">		}</a>
<a name="ln598">	}</a>
<a name="ln599"> </a>
<a name="ln600">	putchar('\n');</a>
<a name="ln601"> </a>
<a name="ln602">	// Print statistics</a>
<a name="ln603"> </a>
<a name="ln604">	ifreq_stats stats;</a>
<a name="ln605">	if (interface.GetStats(stats) == B_OK) {</a>
<a name="ln606">		printf(&quot;\tReceive: %d packets, %d errors, %Ld bytes, %d mcasts, %d &quot;</a>
<a name="ln607">			&quot;dropped\n&quot;, stats.receive.packets, stats.receive.errors,</a>
<a name="ln608">			stats.receive.bytes, stats.receive.multicast_packets,</a>
<a name="ln609">			stats.receive.dropped);</a>
<a name="ln610">		printf(&quot;\tTransmit: %d packets, %d errors, %Ld bytes, %d mcasts, %d &quot;</a>
<a name="ln611">			&quot;dropped\n&quot;, stats.send.packets, stats.send.errors,</a>
<a name="ln612">			stats.send.bytes, stats.send.multicast_packets, stats.send.dropped);</a>
<a name="ln613">		printf(&quot;\tCollisions: %d\n&quot;, stats.collisions);</a>
<a name="ln614">	}</a>
<a name="ln615"> </a>
<a name="ln616">	putchar('\n');</a>
<a name="ln617">	return true;</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">void</a>
<a name="ln622">list_interfaces(const char* name)</a>
<a name="ln623">{</a>
<a name="ln624">	if (name != NULL) {</a>
<a name="ln625">		list_interface(name);</a>
<a name="ln626">		return;</a>
<a name="ln627">	}</a>
<a name="ln628"> </a>
<a name="ln629">	// get a list of all interfaces</a>
<a name="ln630"> </a>
<a name="ln631">	BNetworkRoster&amp; roster = BNetworkRoster::Default();</a>
<a name="ln632"> </a>
<a name="ln633">	BNetworkInterface interface;</a>
<a name="ln634">	uint32 cookie = 0;</a>
<a name="ln635"> </a>
<a name="ln636">	while (roster.GetNextInterface(&amp;cookie, interface) == B_OK) {</a>
<a name="ln637">		list_interface(interface.Name());</a>
<a name="ln638">	}</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641"> </a>
<a name="ln642">/*!	If there are any arguments given, this will remove only the specified</a>
<a name="ln643">	addresses from the interface named \a name.</a>
<a name="ln644">	If there are no arguments, it will remove the complete interface with all</a>
<a name="ln645">	of its addresses.</a>
<a name="ln646">*/</a>
<a name="ln647">void</a>
<a name="ln648">delete_interface(const char* name, char* const* args, int32 argCount)</a>
<a name="ln649">{</a>
<a name="ln650">	BNetworkInterface interface(name);</a>
<a name="ln651"> </a>
<a name="ln652">	for (int32 i = 0; i &lt; argCount; i++) {</a>
<a name="ln653">		int family = get_address_family(args[i]);</a>
<a name="ln654">		if (family != AF_UNSPEC)</a>
<a name="ln655">			i++;</a>
<a name="ln656"> </a>
<a name="ln657">		BNetworkAddress address;</a>
<a name="ln658">		if (!parse_address(family, args[i], address)) {</a>
<a name="ln659">			fprintf(stderr, &quot;%s: Could not parse address \&quot;%s\&quot;.\n&quot;,</a>
<a name="ln660">				kProgramName, args[i]);</a>
<a name="ln661">			exit(1);</a>
<a name="ln662">		}</a>
<a name="ln663"> </a>
<a name="ln664">		status_t status = interface.RemoveAddress(address);</a>
<a name="ln665">		if (status != B_OK) {</a>
<a name="ln666">			fprintf(stderr, &quot;%s: Could not delete address %s from interface %s:&quot;</a>
<a name="ln667">				&quot; %s\n&quot;, kProgramName, args[i], name, strerror(status));</a>
<a name="ln668">		}</a>
<a name="ln669">	}</a>
<a name="ln670"> </a>
<a name="ln671">	if (argCount == 0) {</a>
<a name="ln672">		// Delete interface</a>
<a name="ln673">		BNetworkRoster&amp; roster = BNetworkRoster::Default();</a>
<a name="ln674"> </a>
<a name="ln675">		status_t status = roster.RemoveInterface(interface);</a>
<a name="ln676">		if (status != B_OK) {</a>
<a name="ln677">			fprintf(stderr, &quot;%s: Could not delete interface %s: %s\n&quot;,</a>
<a name="ln678">				kProgramName, name, strerror(errno));</a>
<a name="ln679">		}</a>
<a name="ln680">	}</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683"> </a>
<a name="ln684">void</a>
<a name="ln685">configure_interface(const char* name, char* const* args, int32 argCount)</a>
<a name="ln686">{</a>
<a name="ln687">	// try to parse address family</a>
<a name="ln688"> </a>
<a name="ln689">	int32 i = 0;</a>
<a name="ln690">	int family = get_address_family(args[i]);</a>
<a name="ln691">	if (family != AF_UNSPEC)</a>
<a name="ln692">		i++;</a>
<a name="ln693"> </a>
<a name="ln694">	// try to parse address</a>
<a name="ln695"> </a>
<a name="ln696">	BNetworkAddress address;</a>
<a name="ln697">	BNetworkAddress mask;</a>
<a name="ln698"> </a>
<a name="ln699">	if (parse_address(family, args[i], address)) {</a>
<a name="ln700">		i++;</a>
<a name="ln701"> </a>
<a name="ln702">		if (parse_address(family, args[i], mask))</a>
<a name="ln703">			i++;</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">	BNetworkInterface interface(name);</a>
<a name="ln707">	if (!interface.Exists()) {</a>
<a name="ln708">		// the interface does not exist yet, we have to add it first</a>
<a name="ln709">		BNetworkRoster&amp; roster = BNetworkRoster::Default();</a>
<a name="ln710"> </a>
<a name="ln711">		status_t status = roster.AddInterface(interface);</a>
<a name="ln712">		if (status != B_OK) {</a>
<a name="ln713">			fprintf(stderr, &quot;%s: Could not add interface: %s\n&quot;, kProgramName,</a>
<a name="ln714">				strerror(status));</a>
<a name="ln715">			exit(1);</a>
<a name="ln716">		}</a>
<a name="ln717">	}</a>
<a name="ln718"> </a>
<a name="ln719">	BNetworkAddress broadcast;</a>
<a name="ln720">	BNetworkAddress peer;</a>
<a name="ln721">	int mtu = -1, metric = -1, media = -1;</a>
<a name="ln722">	int addFlags = 0, currentFlags = 0, removeFlags = 0;</a>
<a name="ln723">	bool doAutoConfig = false;</a>
<a name="ln724"> </a>
<a name="ln725">	// parse parameters and flags</a>
<a name="ln726"> </a>
<a name="ln727">	while (i &lt; argCount) {</a>
<a name="ln728">		if (!strcmp(args[i], &quot;peer&quot;)) {</a>
<a name="ln729">			if (!parse_address(family, args[i + 1], peer)) {</a>
<a name="ln730">				fprintf(stderr, &quot;%s: Option 'peer' needs valid address &quot;</a>
<a name="ln731">					&quot;parameter\n&quot;, kProgramName);</a>
<a name="ln732">				exit(1);</a>
<a name="ln733">			}</a>
<a name="ln734">			i++;</a>
<a name="ln735">		} else if (!strcmp(args[i], &quot;nm&quot;) || !strcmp(args[i], &quot;netmask&quot;)) {</a>
<a name="ln736">			if (!mask.IsEmpty()) {</a>
<a name="ln737">				fprintf(stderr, &quot;%s: Netmask or prefix length is specified &quot;</a>
<a name="ln738">					&quot;twice\n&quot;, kProgramName);</a>
<a name="ln739">				exit(1);</a>
<a name="ln740">			}</a>
<a name="ln741">			if (!parse_address(family, args[i + 1], mask)) {</a>
<a name="ln742">				fprintf(stderr, &quot;%s: Option 'netmask' needs valid address &quot;</a>
<a name="ln743">					&quot;parameter\n&quot;, kProgramName);</a>
<a name="ln744">				exit(1);</a>
<a name="ln745">			}</a>
<a name="ln746">			i++;</a>
<a name="ln747">		} else if (!strcmp(args[i], &quot;prefixlen&quot;) || !strcmp(args[i], &quot;plen&quot;)</a>
<a name="ln748">			|| !strcmp(args[i], &quot;prefix-length&quot;)) {</a>
<a name="ln749">			if (!mask.IsEmpty()) {</a>
<a name="ln750">				fprintf(stderr, &quot;%s: Netmask or prefix length is specified &quot;</a>
<a name="ln751">					&quot;twice\n&quot;, kProgramName);</a>
<a name="ln752">				exit(1);</a>
<a name="ln753">			}</a>
<a name="ln754"> </a>
<a name="ln755">			// default to AF_INET if no address family has been specified yet</a>
<a name="ln756">			if (family == AF_UNSPEC)</a>
<a name="ln757">				family = AF_INET;</a>
<a name="ln758"> </a>
<a name="ln759">			if (!prefix_length_to_mask(family, args[i + 1], mask)) {</a>
<a name="ln760">				fprintf(stderr, &quot;%s: Option 'prefix-length %s' is invalid for &quot;</a>
<a name="ln761">					&quot;this address family\n&quot;, kProgramName, args[i + 1]);</a>
<a name="ln762">				exit(1);</a>
<a name="ln763">			}</a>
<a name="ln764">			i++;</a>
<a name="ln765">		} else if (!strcmp(args[i], &quot;bc&quot;) || !strcmp(args[i], &quot;broadcast&quot;)) {</a>
<a name="ln766">			if (!broadcast.IsEmpty()) {</a>
<a name="ln767">				fprintf(stderr, &quot;%s: broadcast address is specified twice\n&quot;,</a>
<a name="ln768">					kProgramName);</a>
<a name="ln769">				exit(1);</a>
<a name="ln770">			}</a>
<a name="ln771">			if (!parse_address(family, args[i + 1], broadcast)) {</a>
<a name="ln772">				fprintf(stderr, &quot;%s: Option 'broadcast' needs valid address &quot;</a>
<a name="ln773">					&quot;parameter\n&quot;, kProgramName);</a>
<a name="ln774">				exit(1);</a>
<a name="ln775">			}</a>
<a name="ln776">			addFlags |= IFF_BROADCAST;</a>
<a name="ln777">			i++;</a>
<a name="ln778">		} else if (!strcmp(args[i], &quot;mtu&quot;)) {</a>
<a name="ln779">			mtu = args[i + 1] ? strtol(args[i + 1], NULL, 0) : 0;</a>
<a name="ln780">			if (mtu &lt;= 500) {</a>
<a name="ln781">				fprintf(stderr, &quot;%s: Option 'mtu' expected valid max transfer &quot;</a>
<a name="ln782">					&quot;unit size\n&quot;, kProgramName);</a>
<a name="ln783">				exit(1);</a>
<a name="ln784">			}</a>
<a name="ln785">			i++;</a>
<a name="ln786">		} else if (!strcmp(args[i], &quot;metric&quot;)) {</a>
<a name="ln787">			if (i + 1 &gt;= argCount) {</a>
<a name="ln788">				fprintf(stderr, &quot;%s: Option 'metric' expected parameter\n&quot;,</a>
<a name="ln789">					kProgramName);</a>
<a name="ln790">				exit(1);</a>
<a name="ln791">			}</a>
<a name="ln792">			metric = strtol(args[i + 1], NULL, 0);</a>
<a name="ln793">			i++;</a>
<a name="ln794">		} else if (!strcmp(args[i], &quot;media&quot;)) {</a>
<a name="ln795">			media = interface.Media();</a>
<a name="ln796">			if (media &lt; 0) {</a>
<a name="ln797">				fprintf(stderr, &quot;%s: Unable to detect media type\n&quot;,</a>
<a name="ln798">					kProgramName);</a>
<a name="ln799">				exit(1);</a>
<a name="ln800">			}</a>
<a name="ln801">			if (i + 1 &gt;= argCount) {</a>
<a name="ln802">				fprintf(stderr, &quot;%s: Option 'media' expected parameter\n&quot;,</a>
<a name="ln803">					kProgramName);</a>
<a name="ln804">				exit(1);</a>
<a name="ln805">			}</a>
<a name="ln806">			if (!media_parse_subtype(args[i + 1], IFM_TYPE(media), &amp;media)) {</a>
<a name="ln807">				fprintf(stderr, &quot;%s: Invalid parameter for option 'media': &quot;</a>
<a name="ln808">					&quot;'%s'\n&quot;, kProgramName, args[i + 1]);</a>
<a name="ln809">				exit(1);</a>
<a name="ln810">			}</a>
<a name="ln811">			i++;</a>
<a name="ln812">		} else if (!strcmp(args[i], &quot;up&quot;) || !strcmp(args[i], &quot;-down&quot;)) {</a>
<a name="ln813">			addFlags |= IFF_UP;</a>
<a name="ln814">		} else if (!strcmp(args[i], &quot;down&quot;) || !strcmp(args[i], &quot;-up&quot;)) {</a>
<a name="ln815">			removeFlags |= IFF_UP;</a>
<a name="ln816">		} else if (!strcmp(args[i], &quot;bcast&quot;)) {</a>
<a name="ln817">			addFlags |= IFF_BROADCAST;</a>
<a name="ln818">		} else if (!strcmp(args[i], &quot;-bcast&quot;)) {</a>
<a name="ln819">			removeFlags |= IFF_BROADCAST;</a>
<a name="ln820">		} else if (!strcmp(args[i], &quot;promisc&quot;)) {</a>
<a name="ln821">			addFlags |= IFF_PROMISC;</a>
<a name="ln822">		} else if (!strcmp(args[i], &quot;-promisc&quot;)) {</a>
<a name="ln823">			removeFlags |= IFF_PROMISC;</a>
<a name="ln824">		} else if (!strcmp(args[i], &quot;allmulti&quot;)) {</a>
<a name="ln825">			addFlags |= IFF_ALLMULTI;</a>
<a name="ln826">		} else if (!strcmp(args[i], &quot;-allmulti&quot;)) {</a>
<a name="ln827">			removeFlags |= IFF_ALLMULTI;</a>
<a name="ln828">		} else if (!strcmp(args[i], &quot;loopback&quot;)) {</a>
<a name="ln829">			addFlags |= IFF_LOOPBACK;</a>
<a name="ln830">		} else if (!strcmp(args[i], &quot;auto-config&quot;)) {</a>
<a name="ln831">			doAutoConfig = true;</a>
<a name="ln832">		} else</a>
<a name="ln833">			usage(1);</a>
<a name="ln834"> </a>
<a name="ln835">		i++;</a>
<a name="ln836">	}</a>
<a name="ln837"> </a>
<a name="ln838">	if ((addFlags &amp; removeFlags) != 0) {</a>
<a name="ln839">		fprintf(stderr, &quot;%s: Contradicting flags specified\n&quot;, kProgramName);</a>
<a name="ln840">		exit(1);</a>
<a name="ln841">	}</a>
<a name="ln842"> </a>
<a name="ln843">	if (doAutoConfig &amp;&amp; (!address.IsEmpty() || !mask.IsEmpty()</a>
<a name="ln844">			|| !broadcast.IsEmpty() || !peer.IsEmpty())) {</a>
<a name="ln845">		fprintf(stderr, &quot;%s: Contradicting changes specified\n&quot;, kProgramName);</a>
<a name="ln846">		exit(1);</a>
<a name="ln847">	}</a>
<a name="ln848"> </a>
<a name="ln849">	// set address/mask/broadcast/peer</a>
<a name="ln850"> </a>
<a name="ln851">	if (!address.IsEmpty() || !mask.IsEmpty() || !broadcast.IsEmpty()) {</a>
<a name="ln852">		BNetworkInterfaceAddress interfaceAddress;</a>
<a name="ln853">		interfaceAddress.SetAddress(address);</a>
<a name="ln854">		interfaceAddress.SetMask(mask);</a>
<a name="ln855">		if (!broadcast.IsEmpty())</a>
<a name="ln856">			interfaceAddress.SetBroadcast(broadcast);</a>
<a name="ln857">		else if (!peer.IsEmpty())</a>
<a name="ln858">			interfaceAddress.SetDestination(peer);</a>
<a name="ln859"> </a>
<a name="ln860">		status_t status = interface.SetAddress(interfaceAddress);</a>
<a name="ln861">		if (status != B_OK) {</a>
<a name="ln862">			fprintf(stderr, &quot;%s: Setting address failed: %s\n&quot;, kProgramName,</a>
<a name="ln863">				strerror(status));</a>
<a name="ln864">			exit(1);</a>
<a name="ln865">		}</a>
<a name="ln866">	}</a>
<a name="ln867"> </a>
<a name="ln868">	currentFlags = interface.Flags();</a>
<a name="ln869"> </a>
<a name="ln870">	// set flags</a>
<a name="ln871"> </a>
<a name="ln872">	if (!address.IsEmpty() || !mask.IsEmpty() || !broadcast.IsEmpty()</a>
<a name="ln873">		|| !peer.IsEmpty())</a>
<a name="ln874">		removeFlags = IFF_AUTO_CONFIGURED | IFF_CONFIGURING;</a>
<a name="ln875"> </a>
<a name="ln876">	if (addFlags || removeFlags) {</a>
<a name="ln877">		status_t status</a>
<a name="ln878">			= interface.SetFlags((currentFlags &amp; ~removeFlags) | addFlags);</a>
<a name="ln879">		if (status != B_OK) {</a>
<a name="ln880">			fprintf(stderr, &quot;%s: Setting flags failed: %s\n&quot;, kProgramName,</a>
<a name="ln881">				strerror(status));</a>
<a name="ln882">		}</a>
<a name="ln883">	}</a>
<a name="ln884"> </a>
<a name="ln885">	// set options</a>
<a name="ln886"> </a>
<a name="ln887">	if (mtu != -1) {</a>
<a name="ln888">		status_t status = interface.SetMTU(mtu);</a>
<a name="ln889">		if (status != B_OK) {</a>
<a name="ln890">			fprintf(stderr, &quot;%s: Setting MTU failed: %s\n&quot;, kProgramName,</a>
<a name="ln891">				strerror(status));</a>
<a name="ln892">		}</a>
<a name="ln893">	}</a>
<a name="ln894"> </a>
<a name="ln895">	if (metric != -1) {</a>
<a name="ln896">		status_t status = interface.SetMetric(metric);</a>
<a name="ln897">		if (status != B_OK) {</a>
<a name="ln898">			fprintf(stderr, &quot;%s: Setting metric failed: %s\n&quot;, kProgramName,</a>
<a name="ln899">				strerror(status));</a>
<a name="ln900">		}</a>
<a name="ln901">	}</a>
<a name="ln902"> </a>
<a name="ln903">	if (media != -1) {</a>
<a name="ln904">		status_t status = interface.SetMedia(media);</a>
<a name="ln905">		if (status != B_OK) {</a>
<a name="ln906">			fprintf(stderr, &quot;%s: Setting media failed: %s\n&quot;, kProgramName,</a>
<a name="ln907">				strerror(status));</a>
<a name="ln908">		}</a>
<a name="ln909">	}</a>
<a name="ln910"> </a>
<a name="ln911">	// start auto configuration, if asked for</a>
<a name="ln912"> </a>
<a name="ln913">	if (doAutoConfig) {</a>
<a name="ln914">		status_t status = interface.AutoConfigure(family);</a>
<a name="ln915">		if (status == B_BAD_PORT_ID) {</a>
<a name="ln916">			fprintf(stderr, &quot;%s: The net_server needs to run for the auto &quot;</a>
<a name="ln917">				&quot;configuration!\n&quot;, kProgramName);</a>
<a name="ln918">		} else if (status != B_OK) {</a>
<a name="ln919">			fprintf(stderr, &quot;%s: Auto-configuring failed: %s\n&quot;, kProgramName,</a>
<a name="ln920">				strerror(status));</a>
<a name="ln921">		}</a>
<a name="ln922">	}</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925"> </a>
<a name="ln926">//	#pragma mark -</a>
<a name="ln927"> </a>
<a name="ln928"> </a>
<a name="ln929">int</a>
<a name="ln930">main(int argc, char** argv)</a>
<a name="ln931">{</a>
<a name="ln932">	if (argc &gt; 1 &amp;&amp; (!strcmp(argv[1], &quot;--help&quot;) || !strcmp(argv[1], &quot;-h&quot;)))</a>
<a name="ln933">		usage(0);</a>
<a name="ln934"> </a>
<a name="ln935">	int socket = ::socket(AF_LINK, SOCK_DGRAM, 0);</a>
<a name="ln936">	if (socket &lt; 0) {</a>
<a name="ln937">		fprintf(stderr, &quot;%s: The networking stack doesn't seem to be &quot;</a>
<a name="ln938">			&quot;available.\n&quot;, kProgramName);</a>
<a name="ln939">		return 1;</a>
<a name="ln940">	}</a>
<a name="ln941">	close(socket);</a>
<a name="ln942"> </a>
<a name="ln943">	if (argc &gt; 1</a>
<a name="ln944">		&amp;&amp; (!strcmp(argv[1], &quot;--delete&quot;)</a>
<a name="ln945">			|| !strcmp(argv[1], &quot;--del&quot;)</a>
<a name="ln946">			|| !strcmp(argv[1], &quot;-d&quot;)</a>
<a name="ln947">			|| !strcmp(argv[1], &quot;del&quot;)</a>
<a name="ln948">			|| !strcmp(argv[1], &quot;delete&quot;))) {</a>
<a name="ln949">		// Delete interface (addresses)</a>
<a name="ln950"> </a>
<a name="ln951">		if (argc &lt; 3)</a>
<a name="ln952">			usage(1);</a>
<a name="ln953"> </a>
<a name="ln954">		const char* name = argv[2];</a>
<a name="ln955">		delete_interface(name, argv + 3, argc - 3);</a>
<a name="ln956">		return 0;</a>
<a name="ln957">	}</a>
<a name="ln958"> </a>
<a name="ln959">	if (argc &gt; 1 &amp;&amp; !strcmp(argv[1], &quot;-a&quot;)) {</a>
<a name="ln960">		// Accept an optional &quot;-a&quot; option to list all interfaces for those</a>
<a name="ln961">		// that are used to it from other platforms.</a>
<a name="ln962"> </a>
<a name="ln963">		if (argc &gt; 2)</a>
<a name="ln964">			usage(1);</a>
<a name="ln965"> </a>
<a name="ln966">		list_interfaces(NULL);</a>
<a name="ln967">		return 0;</a>
<a name="ln968">	}</a>
<a name="ln969"> </a>
<a name="ln970">	const char* name = argv[1];</a>
<a name="ln971">	if (argc &gt; 2) {</a>
<a name="ln972">		if (configure_wireless(name, argv + 2, argc - 2))</a>
<a name="ln973">			return 0;</a>
<a name="ln974"> </a>
<a name="ln975">		// Add or configure an interface</a>
<a name="ln976"> </a>
<a name="ln977">		configure_interface(name, argv + 2, argc - 2);</a>
<a name="ln978">		return 0;</a>
<a name="ln979">	}</a>
<a name="ln980"> </a>
<a name="ln981">	// list interfaces</a>
<a name="ln982"> </a>
<a name="ln983">	list_interfaces(name);</a>
<a name="ln984">	return 0;</a>
<a name="ln985">}</a>

</code></pre>
<div class="balloon" rel="610"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'printf' function. Prefix 'L' is not applicable to conversion specifier 'd'.</p></div>
<div class="balloon" rel="606"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'printf' function. Prefix 'L' is not applicable to conversion specifier 'd'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
