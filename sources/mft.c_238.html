
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mft.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * mft.c - Mft record handling code. Originated from the Linux-NTFS project.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2000-2004 Anton Altaparmakov</a>
<a name="ln5"> * Copyright (c) 2004-2005 Richard Russon</a>
<a name="ln6"> * Copyright (c) 2004-2008 Szabolcs Szakacsits</a>
<a name="ln7"> * Copyright (c)      2005 Yura Pakhuchiy</a>
<a name="ln8"> * Copyright (c) 2014-2015 Jean-Pierre Andre</a>
<a name="ln9"> *</a>
<a name="ln10"> * This program/include file is free software; you can redistribute it and/or</a>
<a name="ln11"> * modify it under the terms of the GNU General Public License as published</a>
<a name="ln12"> * by the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln13"> * (at your option) any later version.</a>
<a name="ln14"> *</a>
<a name="ln15"> * This program/include file is distributed in the hope that it will be</a>
<a name="ln16"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</a>
<a name="ln17"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln18"> * GNU General Public License for more details.</a>
<a name="ln19"> *</a>
<a name="ln20"> * You should have received a copy of the GNU General Public License</a>
<a name="ln21"> * along with this program (in the main directory of the NTFS-3G</a>
<a name="ln22"> * distribution in the file COPYING); if not, write to the Free Software</a>
<a name="ln23"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln24"> */</a>
<a name="ln25"> </a>
<a name="ln26">#ifdef HAVE_CONFIG_H</a>
<a name="ln27">#include &quot;config.h&quot;</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#ifdef HAVE_STDLIB_H</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32">#endif</a>
<a name="ln33">#ifdef HAVE_STDIO_H</a>
<a name="ln34">#include &lt;stdio.h&gt;</a>
<a name="ln35">#endif</a>
<a name="ln36">#ifdef HAVE_ERRNO_H</a>
<a name="ln37">#include &lt;errno.h&gt;</a>
<a name="ln38">#endif</a>
<a name="ln39">#ifdef HAVE_STRING_H</a>
<a name="ln40">#include &lt;string.h&gt;</a>
<a name="ln41">#endif</a>
<a name="ln42">#ifdef HAVE_LIMITS_H</a>
<a name="ln43">#include &lt;limits.h&gt;</a>
<a name="ln44">#endif</a>
<a name="ln45">#include &lt;time.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;compat.h&quot;</a>
<a name="ln48">#include &quot;types.h&quot;</a>
<a name="ln49">#include &quot;device.h&quot;</a>
<a name="ln50">#include &quot;debug.h&quot;</a>
<a name="ln51">#include &quot;bitmap.h&quot;</a>
<a name="ln52">#include &quot;attrib.h&quot;</a>
<a name="ln53">#include &quot;inode.h&quot;</a>
<a name="ln54">#include &quot;volume.h&quot;</a>
<a name="ln55">#include &quot;layout.h&quot;</a>
<a name="ln56">#include &quot;lcnalloc.h&quot;</a>
<a name="ln57">#include &quot;mft.h&quot;</a>
<a name="ln58">#include &quot;logging.h&quot;</a>
<a name="ln59">#include &quot;misc.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61">/**</a>
<a name="ln62"> * ntfs_mft_records_read - read records from the mft from disk</a>
<a name="ln63"> * @vol:	volume to read from</a>
<a name="ln64"> * @mref:	starting mft record number to read</a>
<a name="ln65"> * @count:	number of mft records to read</a>
<a name="ln66"> * @b:		output data buffer</a>
<a name="ln67"> *</a>
<a name="ln68"> * Read @count mft records starting at @mref from volume @vol into buffer</a>
<a name="ln69"> * @b. Return 0 on success or -1 on error, with errno set to the error</a>
<a name="ln70"> * code.</a>
<a name="ln71"> *</a>
<a name="ln72"> * If any of the records exceed the initialized size of the $MFT/$DATA</a>
<a name="ln73"> * attribute, i.e. they cannot possibly be allocated mft records, assume this</a>
<a name="ln74"> * is a bug and return error code ESPIPE.</a>
<a name="ln75"> *</a>
<a name="ln76"> * The read mft records are mst deprotected and are hence ready to use. The</a>
<a name="ln77"> * caller should check each record with is_baad_record() in case mst</a>
<a name="ln78"> * deprotection failed.</a>
<a name="ln79"> *</a>
<a name="ln80"> * NOTE: @b has to be at least of size @count * vol-&gt;mft_record_size.</a>
<a name="ln81"> */</a>
<a name="ln82">int ntfs_mft_records_read(const ntfs_volume *vol, const MFT_REF mref,</a>
<a name="ln83">		const s64 count, MFT_RECORD *b)</a>
<a name="ln84">{</a>
<a name="ln85">	s64 br;</a>
<a name="ln86">	VCN m;</a>
<a name="ln87"> </a>
<a name="ln88">	ntfs_log_trace(&quot;inode %llu\n&quot;, (unsigned long long)MREF(mref));</a>
<a name="ln89">	</a>
<a name="ln90">	if (!vol || !vol-&gt;mft_na || !b || count &lt; 0) {</a>
<a name="ln91">		errno = EINVAL;</a>
<a name="ln92">		ntfs_log_perror(&quot;%s: b=%p  count=%lld  mft=%llu&quot;, __FUNCTION__,</a>
<a name="ln93">			b, (long long)count, (unsigned long long)MREF(mref));</a>
<a name="ln94">		return -1;</a>
<a name="ln95">	}</a>
<a name="ln96">	m = MREF(mref);</a>
<a name="ln97">	/* Refuse to read non-allocated mft records. */</a>
<a name="ln98">	if (m + count &gt; vol-&gt;mft_na-&gt;initialized_size &gt;&gt;</a>
<a name="ln99">			vol-&gt;mft_record_size_bits) {</a>
<a name="ln100">		errno = ESPIPE;</a>
<a name="ln101">		ntfs_log_perror(&quot;Trying to read non-allocated mft records &quot;</a>
<a name="ln102">				&quot;(%lld &gt; %lld)&quot;, (long long)m + count,</a>
<a name="ln103">				(long long)vol-&gt;mft_na-&gt;initialized_size &gt;&gt;</a>
<a name="ln104">				vol-&gt;mft_record_size_bits);</a>
<a name="ln105">		return -1;</a>
<a name="ln106">	}</a>
<a name="ln107">	br = ntfs_attr_mst_pread(vol-&gt;mft_na, m &lt;&lt; vol-&gt;mft_record_size_bits,</a>
<a name="ln108">			count, vol-&gt;mft_record_size, b);</a>
<a name="ln109">	if (br != count) {</a>
<a name="ln110">		if (br != -1)</a>
<a name="ln111">			errno = EIO;</a>
<a name="ln112">		ntfs_log_perror(&quot;Failed to read of MFT, mft=%llu count=%lld &quot;</a>
<a name="ln113">				&quot;br=%lld&quot;, (long long)m, (long long)count,</a>
<a name="ln114">				(long long)br);</a>
<a name="ln115">		return -1;</a>
<a name="ln116">	}</a>
<a name="ln117">	return 0;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">/**</a>
<a name="ln121"> * ntfs_mft_records_write - write mft records to disk</a>
<a name="ln122"> * @vol:	volume to write to</a>
<a name="ln123"> * @mref:	starting mft record number to write</a>
<a name="ln124"> * @count:	number of mft records to write</a>
<a name="ln125"> * @b:		data buffer containing the mft records to write</a>
<a name="ln126"> *</a>
<a name="ln127"> * Write @count mft records starting at @mref from data buffer @b to volume</a>
<a name="ln128"> * @vol. Return 0 on success or -1 on error, with errno set to the error code.</a>
<a name="ln129"> *</a>
<a name="ln130"> * If any of the records exceed the initialized size of the $MFT/$DATA</a>
<a name="ln131"> * attribute, i.e. they cannot possibly be allocated mft records, assume this</a>
<a name="ln132"> * is a bug and return error code ESPIPE.</a>
<a name="ln133"> *</a>
<a name="ln134"> * Before the mft records are written, they are mst protected. After the write,</a>
<a name="ln135"> * they are deprotected again, thus resulting in an increase in the update</a>
<a name="ln136"> * sequence number inside the data buffer @b.</a>
<a name="ln137"> *</a>
<a name="ln138"> * If any mft records are written which are also represented in the mft mirror</a>
<a name="ln139"> * $MFTMirr, we make a copy of the relevant parts of the data buffer @b into a</a>
<a name="ln140"> * temporary buffer before we do the actual write. Then if at least one mft</a>
<a name="ln141"> * record was successfully written, we write the appropriate mft records from</a>
<a name="ln142"> * the copied buffer to the mft mirror, too.</a>
<a name="ln143"> */</a>
<a name="ln144">int ntfs_mft_records_write(const ntfs_volume *vol, const MFT_REF mref,</a>
<a name="ln145">		const s64 count, MFT_RECORD *b)</a>
<a name="ln146">{</a>
<a name="ln147">	s64 bw;</a>
<a name="ln148">	VCN m;</a>
<a name="ln149">	void *bmirr = NULL;</a>
<a name="ln150">	int cnt = 0, res = 0;</a>
<a name="ln151"> </a>
<a name="ln152">	if (!vol || !vol-&gt;mft_na || vol-&gt;mftmirr_size &lt;= 0 || !b || count &lt; 0) {</a>
<a name="ln153">		errno = EINVAL;</a>
<a name="ln154">		return -1;</a>
<a name="ln155">	}</a>
<a name="ln156">	m = MREF(mref);</a>
<a name="ln157">	/* Refuse to write non-allocated mft records. */</a>
<a name="ln158">	if (m + count &gt; vol-&gt;mft_na-&gt;initialized_size &gt;&gt;</a>
<a name="ln159">			vol-&gt;mft_record_size_bits) {</a>
<a name="ln160">		errno = ESPIPE;</a>
<a name="ln161">		ntfs_log_perror(&quot;Trying to write non-allocated mft records &quot;</a>
<a name="ln162">				&quot;(%lld &gt; %lld)&quot;, (long long)m + count,</a>
<a name="ln163">				(long long)vol-&gt;mft_na-&gt;initialized_size &gt;&gt;</a>
<a name="ln164">				vol-&gt;mft_record_size_bits);</a>
<a name="ln165">		return -1;</a>
<a name="ln166">	}</a>
<a name="ln167">	if (m &lt; vol-&gt;mftmirr_size) {</a>
<a name="ln168">		if (!vol-&gt;mftmirr_na) {</a>
<a name="ln169">			errno = EINVAL;</a>
<a name="ln170">			return -1;</a>
<a name="ln171">		}</a>
<a name="ln172">		cnt = vol-&gt;mftmirr_size - m;</a>
<a name="ln173">		if (cnt &gt; count)</a>
<a name="ln174">			cnt = count;</a>
<a name="ln175">		bmirr = ntfs_malloc(cnt * vol-&gt;mft_record_size);</a>
<a name="ln176">		if (!bmirr)</a>
<a name="ln177">			return -1;</a>
<a name="ln178">		memcpy(bmirr, b, cnt * vol-&gt;mft_record_size);</a>
<a name="ln179">	}</a>
<a name="ln180">	bw = ntfs_attr_mst_pwrite(vol-&gt;mft_na, m &lt;&lt; vol-&gt;mft_record_size_bits,</a>
<a name="ln181">			count, vol-&gt;mft_record_size, b);</a>
<a name="ln182">	if (bw != count) {</a>
<a name="ln183">		if (bw != -1)</a>
<a name="ln184">			errno = EIO;</a>
<a name="ln185">		if (bw &gt;= 0)</a>
<a name="ln186">			ntfs_log_debug(&quot;Error: partial write while writing $Mft &quot;</a>
<a name="ln187">					&quot;record(s)!\n&quot;);</a>
<a name="ln188">		else</a>
<a name="ln189">			ntfs_log_perror(&quot;Error writing $Mft record(s)&quot;);</a>
<a name="ln190">		res = errno;</a>
<a name="ln191">	}</a>
<a name="ln192">	if (bmirr &amp;&amp; bw &gt; 0) {</a>
<a name="ln193">		if (bw &lt; cnt)</a>
<a name="ln194">			cnt = bw;</a>
<a name="ln195">		bw = ntfs_attr_mst_pwrite(vol-&gt;mftmirr_na,</a>
<a name="ln196">				m &lt;&lt; vol-&gt;mft_record_size_bits, cnt,</a>
<a name="ln197">				vol-&gt;mft_record_size, bmirr);</a>
<a name="ln198">		if (bw != cnt) {</a>
<a name="ln199">			if (bw != -1)</a>
<a name="ln200">				errno = EIO;</a>
<a name="ln201">			ntfs_log_debug(&quot;Error: failed to sync $MFTMirr! Run &quot;</a>
<a name="ln202">					&quot;chkdsk.\n&quot;);</a>
<a name="ln203">			res = errno;</a>
<a name="ln204">		}</a>
<a name="ln205">	}</a>
<a name="ln206">	free(bmirr);</a>
<a name="ln207">	if (!res)</a>
<a name="ln208">		return res;</a>
<a name="ln209">	errno = res;</a>
<a name="ln210">	return -1;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">int ntfs_mft_record_check(const ntfs_volume *vol, const MFT_REF mref, </a>
<a name="ln214">			  MFT_RECORD *m)</a>
<a name="ln215">{			  </a>
<a name="ln216">	ATTR_RECORD *a;</a>
<a name="ln217">	int ret = -1;</a>
<a name="ln218">	</a>
<a name="ln219">	if (!ntfs_is_file_record(m-&gt;magic)) {</a>
<a name="ln220">		if (!NVolNoFixupWarn(vol))</a>
<a name="ln221">			ntfs_log_error(&quot;Record %llu has no FILE magic (0x%x)\n&quot;,</a>
<a name="ln222">				(unsigned long long)MREF(mref),</a>
<a name="ln223">				(int)le32_to_cpu(*(le32*)m));</a>
<a name="ln224">		goto err_out;</a>
<a name="ln225">	}</a>
<a name="ln226">	</a>
<a name="ln227">	if (le32_to_cpu(m-&gt;bytes_allocated) != vol-&gt;mft_record_size) {</a>
<a name="ln228">		ntfs_log_error(&quot;Record %llu has corrupt allocation size &quot;</a>
<a name="ln229">			       &quot;(%u &lt;&gt; %u)\n&quot;, (unsigned long long)MREF(mref),</a>
<a name="ln230">			       vol-&gt;mft_record_size,</a>
<a name="ln231">			       le32_to_cpu(m-&gt;bytes_allocated));</a>
<a name="ln232">		goto err_out;</a>
<a name="ln233">	}</a>
<a name="ln234">	</a>
<a name="ln235">	a = (ATTR_RECORD *)((char *)m + le16_to_cpu(m-&gt;attrs_offset));</a>
<a name="ln236">	if (p2n(a) &lt; p2n(m) || (char *)a &gt; (char *)m + vol-&gt;mft_record_size) {</a>
<a name="ln237">		ntfs_log_error(&quot;Record %llu is corrupt\n&quot;,</a>
<a name="ln238">			       (unsigned long long)MREF(mref));</a>
<a name="ln239">		goto err_out;</a>
<a name="ln240">	}</a>
<a name="ln241">	</a>
<a name="ln242">	ret = 0;</a>
<a name="ln243">err_out:</a>
<a name="ln244">	if (ret)</a>
<a name="ln245">		errno = EIO;</a>
<a name="ln246">	return ret;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">/**</a>
<a name="ln250"> * ntfs_file_record_read - read a FILE record from the mft from disk</a>
<a name="ln251"> * @vol:	volume to read from</a>
<a name="ln252"> * @mref:	mft reference specifying mft record to read</a>
<a name="ln253"> * @mrec:	address of pointer in which to return the mft record</a>
<a name="ln254"> * @attr:	address of pointer in which to return the first attribute</a>
<a name="ln255"> *</a>
<a name="ln256"> * Read a FILE record from the mft of @vol from the storage medium. @mref</a>
<a name="ln257"> * specifies the mft record to read, including the sequence number, which can</a>
<a name="ln258"> * be 0 if no sequence number checking is to be performed.</a>
<a name="ln259"> *</a>
<a name="ln260"> * The function allocates a buffer large enough to hold the mft record and</a>
<a name="ln261"> * reads the record into the buffer (mst deprotecting it in the process).</a>
<a name="ln262"> * *@mrec is then set to point to the buffer.</a>
<a name="ln263"> *</a>
<a name="ln264"> * If @attr is not NULL, *@attr is set to point to the first attribute in the</a>
<a name="ln265"> * mft record, i.e. *@attr is a pointer into *@mrec.</a>
<a name="ln266"> *</a>
<a name="ln267"> * Return 0 on success, or -1 on error, with errno set to the error code.</a>
<a name="ln268"> *</a>
<a name="ln269"> * The read mft record is checked for having the magic FILE,</a>
<a name="ln270"> * and for having a matching sequence number (if MSEQNO(*@mref) != 0).</a>
<a name="ln271"> * If either of these fails, -1 is returned and errno is set to EIO. If you get</a>
<a name="ln272"> * this, but you still want to read the mft record (e.g. in order to correct</a>
<a name="ln273"> * it), use ntfs_mft_record_read() directly.</a>
<a name="ln274"> *</a>
<a name="ln275"> * Note: Caller has to free *@mrec when finished.</a>
<a name="ln276"> *</a>
<a name="ln277"> * Note: We do not check if the mft record is flagged in use. The caller can</a>
<a name="ln278"> *	 check if desired.</a>
<a name="ln279"> */</a>
<a name="ln280">int ntfs_file_record_read(const ntfs_volume *vol, const MFT_REF mref,</a>
<a name="ln281">		MFT_RECORD **mrec, ATTR_RECORD **attr)</a>
<a name="ln282">{</a>
<a name="ln283">	MFT_RECORD *m;</a>
<a name="ln284"> </a>
<a name="ln285">	if (!vol || !mrec) {</a>
<a name="ln286">		errno = EINVAL;</a>
<a name="ln287">		ntfs_log_perror(&quot;%s: mrec=%p&quot;, __FUNCTION__, mrec);</a>
<a name="ln288">		return -1;</a>
<a name="ln289">	}</a>
<a name="ln290">	</a>
<a name="ln291">	m = *mrec;</a>
<a name="ln292">	if (!m) {</a>
<a name="ln293">		m = ntfs_malloc(vol-&gt;mft_record_size);</a>
<a name="ln294">		if (!m)</a>
<a name="ln295">			return -1;</a>
<a name="ln296">	}</a>
<a name="ln297">	if (ntfs_mft_record_read(vol, mref, m))</a>
<a name="ln298">		goto err_out;</a>
<a name="ln299"> </a>
<a name="ln300">	if (ntfs_mft_record_check(vol, mref, m))</a>
<a name="ln301">		goto err_out;</a>
<a name="ln302">	</a>
<a name="ln303">	if (MSEQNO(mref) &amp;&amp; MSEQNO(mref) != le16_to_cpu(m-&gt;sequence_number)) {</a>
<a name="ln304">		ntfs_log_error(&quot;Record %llu has wrong SeqNo (%d &lt;&gt; %d)\n&quot;,</a>
<a name="ln305">			       (unsigned long long)MREF(mref), MSEQNO(mref),</a>
<a name="ln306">			       le16_to_cpu(m-&gt;sequence_number));</a>
<a name="ln307">		errno = EIO;</a>
<a name="ln308">		goto err_out;</a>
<a name="ln309">	}</a>
<a name="ln310">	*mrec = m;</a>
<a name="ln311">	if (attr)</a>
<a name="ln312">		*attr = (ATTR_RECORD*)((char*)m + le16_to_cpu(m-&gt;attrs_offset));</a>
<a name="ln313">	return 0;</a>
<a name="ln314">err_out:</a>
<a name="ln315">	if (m != *mrec)</a>
<a name="ln316">		free(m);</a>
<a name="ln317">	return -1;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">/**</a>
<a name="ln321"> * ntfs_mft_record_layout - layout an mft record into a memory buffer</a>
<a name="ln322"> * @vol:	volume to which the mft record will belong</a>
<a name="ln323"> * @mref:	mft reference specifying the mft record number</a>
<a name="ln324"> * @mrec:	destination buffer of size &gt;= @vol-&gt;mft_record_size bytes</a>
<a name="ln325"> *</a>
<a name="ln326"> * Layout an empty, unused mft record with the mft reference @mref into the</a>
<a name="ln327"> * buffer @m.  The volume @vol is needed because the mft record structure was</a>
<a name="ln328"> * modified in NTFS 3.1 so we need to know which volume version this mft record</a>
<a name="ln329"> * will be used on.</a>
<a name="ln330"> *</a>
<a name="ln331"> * On success return 0 and on error return -1 with errno set to the error code.</a>
<a name="ln332"> */</a>
<a name="ln333">int ntfs_mft_record_layout(const ntfs_volume *vol, const MFT_REF mref,</a>
<a name="ln334">		MFT_RECORD *mrec)</a>
<a name="ln335">{</a>
<a name="ln336">	ATTR_RECORD *a;</a>
<a name="ln337"> </a>
<a name="ln338">	if (!vol || !mrec) {</a>
<a name="ln339">		errno = EINVAL;</a>
<a name="ln340">		ntfs_log_perror(&quot;%s: mrec=%p&quot;, __FUNCTION__, mrec);</a>
<a name="ln341">		return -1;</a>
<a name="ln342">	}</a>
<a name="ln343">	/* Aligned to 2-byte boundary. */</a>
<a name="ln344">	if (vol-&gt;major_ver &lt; 3 || (vol-&gt;major_ver == 3 &amp;&amp; !vol-&gt;minor_ver))</a>
<a name="ln345">		mrec-&gt;usa_ofs = cpu_to_le16((sizeof(MFT_RECORD_OLD) + 1) &amp; ~1);</a>
<a name="ln346">	else {</a>
<a name="ln347">		/* Abort if mref is &gt; 32 bits. */</a>
<a name="ln348">		if (MREF(mref) &amp; 0x0000ffff00000000ull) {</a>
<a name="ln349">			errno = ERANGE;</a>
<a name="ln350">			ntfs_log_perror(&quot;Mft reference exceeds 32 bits&quot;);</a>
<a name="ln351">			return -1;</a>
<a name="ln352">		}</a>
<a name="ln353">		mrec-&gt;usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) &amp; ~1);</a>
<a name="ln354">		/*</a>
<a name="ln355">		 * Set the NTFS 3.1+ specific fields while we know that the</a>
<a name="ln356">		 * volume version is 3.1+.</a>
<a name="ln357">		 */</a>
<a name="ln358">		mrec-&gt;reserved = const_cpu_to_le16(0);</a>
<a name="ln359">		mrec-&gt;mft_record_number = cpu_to_le32(MREF(mref));</a>
<a name="ln360">	}</a>
<a name="ln361">	mrec-&gt;magic = magic_FILE;</a>
<a name="ln362">	if (vol-&gt;mft_record_size &gt;= NTFS_BLOCK_SIZE)</a>
<a name="ln363">		mrec-&gt;usa_count = cpu_to_le16(vol-&gt;mft_record_size /</a>
<a name="ln364">				NTFS_BLOCK_SIZE + 1);</a>
<a name="ln365">	else {</a>
<a name="ln366">		mrec-&gt;usa_count = const_cpu_to_le16(1);</a>
<a name="ln367">		ntfs_log_error(&quot;Sector size is bigger than MFT record size.  &quot;</a>
<a name="ln368">				&quot;Setting usa_count to 1.  If Windows chkdsk &quot;</a>
<a name="ln369">				&quot;reports this as corruption, please email %s &quot;</a>
<a name="ln370">				&quot;stating that you saw this message and that &quot;</a>
<a name="ln371">				&quot;the file system created was corrupt.  &quot;</a>
<a name="ln372">				&quot;Thank you.\n&quot;, NTFS_DEV_LIST);</a>
<a name="ln373">	}</a>
<a name="ln374">	/* Set the update sequence number to 1. */</a>
<a name="ln375">	*(le16*)((u8*)mrec + le16_to_cpu(mrec-&gt;usa_ofs)) = const_cpu_to_le16(1);</a>
<a name="ln376">	mrec-&gt;lsn = const_cpu_to_sle64(0ll);</a>
<a name="ln377">	mrec-&gt;sequence_number = const_cpu_to_le16(1);</a>
<a name="ln378">	mrec-&gt;link_count = const_cpu_to_le16(0);</a>
<a name="ln379">	/* Aligned to 8-byte boundary. */</a>
<a name="ln380">	mrec-&gt;attrs_offset = cpu_to_le16((le16_to_cpu(mrec-&gt;usa_ofs) +</a>
<a name="ln381">			(le16_to_cpu(mrec-&gt;usa_count) &lt;&lt; 1) + 7) &amp; ~7);</a>
<a name="ln382">	mrec-&gt;flags = const_cpu_to_le16(0);</a>
<a name="ln383">	/*</a>
<a name="ln384">	 * Using attrs_offset plus eight bytes (for the termination attribute),</a>
<a name="ln385">	 * aligned to 8-byte boundary.</a>
<a name="ln386">	 */</a>
<a name="ln387">	mrec-&gt;bytes_in_use = cpu_to_le32((le16_to_cpu(mrec-&gt;attrs_offset) + 8 +</a>
<a name="ln388">			7) &amp; ~7);</a>
<a name="ln389">	mrec-&gt;bytes_allocated = cpu_to_le32(vol-&gt;mft_record_size);</a>
<a name="ln390">	mrec-&gt;base_mft_record = const_cpu_to_le64((MFT_REF)0);</a>
<a name="ln391">	mrec-&gt;next_attr_instance = const_cpu_to_le16(0);</a>
<a name="ln392">	a = (ATTR_RECORD*)((u8*)mrec + le16_to_cpu(mrec-&gt;attrs_offset));</a>
<a name="ln393">	a-&gt;type = AT_END;</a>
<a name="ln394">	a-&gt;length = const_cpu_to_le32(0);</a>
<a name="ln395">	/* Finally, clear the unused part of the mft record. */</a>
<a name="ln396">	memset((u8*)a + 8, 0, vol-&gt;mft_record_size - ((u8*)a + 8 - (u8*)mrec));</a>
<a name="ln397">	return 0;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/**</a>
<a name="ln401"> * ntfs_mft_record_format - format an mft record on an ntfs volume</a>
<a name="ln402"> * @vol:	volume on which to format the mft record</a>
<a name="ln403"> * @mref:	mft reference specifying mft record to format</a>
<a name="ln404"> *</a>
<a name="ln405"> * Format the mft record with the mft reference @mref in $MFT/$DATA, i.e. lay</a>
<a name="ln406"> * out an empty, unused mft record in memory and write it to the volume @vol.</a>
<a name="ln407"> *</a>
<a name="ln408"> * On success return 0 and on error return -1 with errno set to the error code.</a>
<a name="ln409"> */</a>
<a name="ln410">int ntfs_mft_record_format(const ntfs_volume *vol, const MFT_REF mref)</a>
<a name="ln411">{</a>
<a name="ln412">	MFT_RECORD *m;</a>
<a name="ln413">	int ret = -1;</a>
<a name="ln414"> </a>
<a name="ln415">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln416">	</a>
<a name="ln417">	m = ntfs_calloc(vol-&gt;mft_record_size);</a>
<a name="ln418">	if (!m)</a>
<a name="ln419">		goto out;</a>
<a name="ln420">	</a>
<a name="ln421">	if (ntfs_mft_record_layout(vol, mref, m))</a>
<a name="ln422">		goto free_m;</a>
<a name="ln423">	</a>
<a name="ln424">	if (ntfs_mft_record_write(vol, mref, m))</a>
<a name="ln425">		goto free_m;</a>
<a name="ln426">	</a>
<a name="ln427">	ret = 0;</a>
<a name="ln428">free_m:</a>
<a name="ln429">	free(m);</a>
<a name="ln430">out:	</a>
<a name="ln431">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln432">	return ret;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">static const char *es = &quot;  Leaving inconsistent metadata.  Run chkdsk.&quot;;</a>
<a name="ln436"> </a>
<a name="ln437">/**</a>
<a name="ln438"> * ntfs_ffz - Find the first unset (zero) bit in a word</a>
<a name="ln439"> * @word:</a>
<a name="ln440"> *</a>
<a name="ln441"> * Description...</a>
<a name="ln442"> *</a>
<a name="ln443"> * Returns:</a>
<a name="ln444"> */</a>
<a name="ln445">static inline unsigned int ntfs_ffz(unsigned int word)</a>
<a name="ln446">{</a>
<a name="ln447">	return ffs(~word) - 1;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">static int ntfs_is_mft(ntfs_inode *ni)</a>
<a name="ln451">{</a>
<a name="ln452">	if (ni &amp;&amp; ni-&gt;mft_no == FILE_MFT)</a>
<a name="ln453">		return 1;</a>
<a name="ln454">	return 0;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">#ifndef PAGE_SIZE</a>
<a name="ln458">#define PAGE_SIZE 4096</a>
<a name="ln459">#endif</a>
<a name="ln460"> </a>
<a name="ln461">#define RESERVED_MFT_RECORDS   64</a>
<a name="ln462"> </a>
<a name="ln463">/**</a>
<a name="ln464"> * ntfs_mft_bitmap_find_free_rec - find a free mft record in the mft bitmap</a>
<a name="ln465"> * @vol:	volume on which to search for a free mft record</a>
<a name="ln466"> * @base_ni:	open base inode if allocating an extent mft record or NULL</a>
<a name="ln467"> *</a>
<a name="ln468"> * Search for a free mft record in the mft bitmap attribute on the ntfs volume</a>
<a name="ln469"> * @vol.</a>
<a name="ln470"> *</a>
<a name="ln471"> * If @base_ni is NULL start the search at the default allocator position.</a>
<a name="ln472"> *</a>
<a name="ln473"> * If @base_ni is not NULL start the search at the mft record after the base</a>
<a name="ln474"> * mft record @base_ni.</a>
<a name="ln475"> *</a>
<a name="ln476"> * Return the free mft record on success and -1 on error with errno set to the</a>
<a name="ln477"> * error code.  An error code of ENOSPC means that there are no free mft</a>
<a name="ln478"> * records in the currently initialized mft bitmap.</a>
<a name="ln479"> */</a>
<a name="ln480">static int ntfs_mft_bitmap_find_free_rec(ntfs_volume *vol, ntfs_inode *base_ni)</a>
<a name="ln481">{</a>
<a name="ln482">	s64 pass_end, ll, data_pos, pass_start, ofs, bit;</a>
<a name="ln483">	ntfs_attr *mftbmp_na;</a>
<a name="ln484">	u8 *buf, *byte;</a>
<a name="ln485">	unsigned int size;</a>
<a name="ln486">	u8 pass, b;</a>
<a name="ln487">	int ret = -1;</a>
<a name="ln488"> </a>
<a name="ln489">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln490">	</a>
<a name="ln491">	mftbmp_na = vol-&gt;mftbmp_na;</a>
<a name="ln492">	/*</a>
<a name="ln493">	 * Set the end of the pass making sure we do not overflow the mft</a>
<a name="ln494">	 * bitmap.</a>
<a name="ln495">	 */</a>
<a name="ln496">	size = PAGE_SIZE;</a>
<a name="ln497">	pass_end = vol-&gt;mft_na-&gt;allocated_size &gt;&gt; vol-&gt;mft_record_size_bits;</a>
<a name="ln498">	ll = mftbmp_na-&gt;initialized_size &lt;&lt; 3;</a>
<a name="ln499">	if (pass_end &gt; ll)</a>
<a name="ln500">		pass_end = ll;</a>
<a name="ln501">	pass = 1;</a>
<a name="ln502">	if (!base_ni)</a>
<a name="ln503">		data_pos = vol-&gt;mft_data_pos;</a>
<a name="ln504">	else</a>
<a name="ln505">		data_pos = base_ni-&gt;mft_no + 1;</a>
<a name="ln506">	if (data_pos &lt; RESERVED_MFT_RECORDS)</a>
<a name="ln507">		data_pos = RESERVED_MFT_RECORDS;</a>
<a name="ln508">	if (data_pos &gt;= pass_end) {</a>
<a name="ln509">		data_pos = RESERVED_MFT_RECORDS;</a>
<a name="ln510">		pass = 2;</a>
<a name="ln511">		/* This happens on a freshly formatted volume. */</a>
<a name="ln512">		if (data_pos &gt;= pass_end) {</a>
<a name="ln513">			errno = ENOSPC;</a>
<a name="ln514">			goto leave;</a>
<a name="ln515">		}</a>
<a name="ln516">	}</a>
<a name="ln517">	if (ntfs_is_mft(base_ni)) {</a>
<a name="ln518">		data_pos = 0;</a>
<a name="ln519">		pass = 2;</a>
<a name="ln520">	}</a>
<a name="ln521">	pass_start = data_pos;</a>
<a name="ln522">	buf = ntfs_malloc(PAGE_SIZE);</a>
<a name="ln523">	if (!buf)</a>
<a name="ln524">		goto leave;</a>
<a name="ln525">	</a>
<a name="ln526">	ntfs_log_debug(&quot;Starting bitmap search: pass %u, pass_start 0x%llx, &quot;</a>
<a name="ln527">			&quot;pass_end 0x%llx, data_pos 0x%llx.\n&quot;, pass,</a>
<a name="ln528">			(long long)pass_start, (long long)pass_end,</a>
<a name="ln529">			(long long)data_pos);</a>
<a name="ln530">#ifdef DEBUG</a>
<a name="ln531">	byte = NULL;</a>
<a name="ln532">	b = 0;</a>
<a name="ln533">#endif</a>
<a name="ln534">	/* Loop until a free mft record is found. */</a>
<a name="ln535">	for (; pass &lt;= 2; size = PAGE_SIZE) {</a>
<a name="ln536">		/* Cap size to pass_end. */</a>
<a name="ln537">		ofs = data_pos &gt;&gt; 3;</a>
<a name="ln538">		ll = ((pass_end + 7) &gt;&gt; 3) - ofs;</a>
<a name="ln539">		if (size &gt; ll)</a>
<a name="ln540">			size = ll;</a>
<a name="ln541">		ll = ntfs_attr_pread(mftbmp_na, ofs, size, buf);</a>
<a name="ln542">		if (ll &lt; 0) {</a>
<a name="ln543">			ntfs_log_perror(&quot;Failed to read $MFT bitmap&quot;);</a>
<a name="ln544">			free(buf);</a>
<a name="ln545">			goto leave;</a>
<a name="ln546">		}</a>
<a name="ln547">		ntfs_log_debug(&quot;Read 0x%llx bytes.\n&quot;, (long long)ll);</a>
<a name="ln548">		/* If we read at least one byte, search @buf for a zero bit. */</a>
<a name="ln549">		if (ll) {</a>
<a name="ln550">			size = ll &lt;&lt; 3;</a>
<a name="ln551">			bit = data_pos &amp; 7;</a>
<a name="ln552">			data_pos &amp;= ~7ull;</a>
<a name="ln553">			ntfs_log_debug(&quot;Before inner for loop: size 0x%x, &quot;</a>
<a name="ln554">					&quot;data_pos 0x%llx, bit 0x%llx, &quot;</a>
<a name="ln555">					&quot;*byte 0x%hhx, b %u.\n&quot;, size,</a>
<a name="ln556">					(long long)data_pos, (long long)bit,</a>
<a name="ln557">					(u8) (byte ? *byte : -1), b);</a>
<a name="ln558">			for (; bit &lt; size &amp;&amp; data_pos + bit &lt; pass_end;</a>
<a name="ln559">					bit &amp;= ~7ull, bit += 8) {</a>
<a name="ln560">				/* </a>
<a name="ln561">				 * If we're extending $MFT and running out of the first</a>
<a name="ln562">				 * mft record (base record) then give up searching since</a>
<a name="ln563">				 * no guarantee that the found record will be accessible.</a>
<a name="ln564">				 */</a>
<a name="ln565">				if (ntfs_is_mft(base_ni) &amp;&amp; bit &gt; 400)</a>
<a name="ln566">					goto out;</a>
<a name="ln567">				</a>
<a name="ln568">				byte = buf + (bit &gt;&gt; 3);</a>
<a name="ln569">				if (*byte == 0xff)</a>
<a name="ln570">					continue;</a>
<a name="ln571">				</a>
<a name="ln572">				/* Note: ffz() result must be zero based. */</a>
<a name="ln573">				b = ntfs_ffz((unsigned long)*byte);</a>
<a name="ln574">				if (b &lt; 8 &amp;&amp; b &gt;= (bit &amp; 7)) {</a>
<a name="ln575">					free(buf);</a>
<a name="ln576">					ret = data_pos + (bit &amp; ~7ull) + b;</a>
<a name="ln577">					goto leave;</a>
<a name="ln578">				}</a>
<a name="ln579">			}</a>
<a name="ln580">			ntfs_log_debug(&quot;After inner for loop: size 0x%x, &quot;</a>
<a name="ln581">					&quot;data_pos 0x%llx, bit 0x%llx, &quot;</a>
<a name="ln582">					&quot;*byte 0x%hhx, b %u.\n&quot;, size,</a>
<a name="ln583">					(long long)data_pos, (long long)bit,</a>
<a name="ln584">					(u8) (byte ? *byte : -1), b);</a>
<a name="ln585">			data_pos += size;</a>
<a name="ln586">			/*</a>
<a name="ln587">			 * If the end of the pass has not been reached yet,</a>
<a name="ln588">			 * continue searching the mft bitmap for a zero bit.</a>
<a name="ln589">			 */</a>
<a name="ln590">			if (data_pos &lt; pass_end)</a>
<a name="ln591">				continue;</a>
<a name="ln592">		}</a>
<a name="ln593">		/* Do the next pass. */</a>
<a name="ln594">		pass++;</a>
<a name="ln595">		if (pass == 2) {</a>
<a name="ln596">			/*</a>
<a name="ln597">			 * Starting the second pass, in which we scan the first</a>
<a name="ln598">			 * part of the zone which we omitted earlier.</a>
<a name="ln599">			 */</a>
<a name="ln600">			pass_end = pass_start;</a>
<a name="ln601">			data_pos = pass_start = RESERVED_MFT_RECORDS;</a>
<a name="ln602">			ntfs_log_debug(&quot;pass %i, pass_start 0x%llx, pass_end &quot;</a>
<a name="ln603">					&quot;0x%llx.\n&quot;, pass, (long long)pass_start,</a>
<a name="ln604">					(long long)pass_end);</a>
<a name="ln605">			if (data_pos &gt;= pass_end)</a>
<a name="ln606">				break;</a>
<a name="ln607">		}</a>
<a name="ln608">	}</a>
<a name="ln609">	/* No free mft records in currently initialized mft bitmap. */</a>
<a name="ln610">out:	</a>
<a name="ln611">	free(buf);</a>
<a name="ln612">	errno = ENOSPC;</a>
<a name="ln613">leave:</a>
<a name="ln614">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln615">	return ret;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">static int ntfs_mft_attr_extend(ntfs_attr *na)</a>
<a name="ln619">{</a>
<a name="ln620">	int ret = STATUS_ERROR;</a>
<a name="ln621">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln622"> </a>
<a name="ln623">	if (!NInoAttrList(na-&gt;ni)) {</a>
<a name="ln624">		if (ntfs_inode_add_attrlist(na-&gt;ni)) {</a>
<a name="ln625">			ntfs_log_perror(&quot;%s: Can not add attrlist #3&quot;, __FUNCTION__);</a>
<a name="ln626">			goto out;</a>
<a name="ln627">		}</a>
<a name="ln628">		/* We can't sync the $MFT inode since its runlist is bogus. */</a>
<a name="ln629">		ret = STATUS_KEEP_SEARCHING;</a>
<a name="ln630">		goto out;</a>
<a name="ln631">	}</a>
<a name="ln632"> </a>
<a name="ln633">	if (ntfs_attr_update_mapping_pairs(na, 0)) {</a>
<a name="ln634">		ntfs_log_perror(&quot;%s: MP update failed&quot;, __FUNCTION__);</a>
<a name="ln635">		goto out;</a>
<a name="ln636">	}</a>
<a name="ln637">	</a>
<a name="ln638">	ret = STATUS_OK;</a>
<a name="ln639">out:	</a>
<a name="ln640">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln641">	return ret;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">/**</a>
<a name="ln645"> * ntfs_mft_bitmap_extend_allocation_i - see ntfs_mft_bitmap_extend_allocation</a>
<a name="ln646"> */</a>
<a name="ln647">static int ntfs_mft_bitmap_extend_allocation_i(ntfs_volume *vol)</a>
<a name="ln648">{</a>
<a name="ln649">	LCN lcn;</a>
<a name="ln650">	s64 ll = 0; /* silence compiler warning */</a>
<a name="ln651">	ntfs_attr *mftbmp_na;</a>
<a name="ln652">	runlist_element *rl, *rl2 = NULL; /* silence compiler warning */</a>
<a name="ln653">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln654">	MFT_RECORD *m = NULL; /* silence compiler warning */</a>
<a name="ln655">	ATTR_RECORD *a = NULL; /* silence compiler warning */</a>
<a name="ln656">	int err, mp_size;</a>
<a name="ln657">	int ret = STATUS_ERROR;</a>
<a name="ln658">	u32 old_alen = 0; /* silence compiler warning */</a>
<a name="ln659">	BOOL mp_rebuilt = FALSE;</a>
<a name="ln660">	BOOL update_mp = FALSE;</a>
<a name="ln661"> </a>
<a name="ln662">	mftbmp_na = vol-&gt;mftbmp_na;</a>
<a name="ln663">	/*</a>
<a name="ln664">	 * Determine the last lcn of the mft bitmap.  The allocated size of the</a>
<a name="ln665">	 * mft bitmap cannot be zero so we are ok to do this.</a>
<a name="ln666">	 */</a>
<a name="ln667">	rl = ntfs_attr_find_vcn(mftbmp_na, (mftbmp_na-&gt;allocated_size - 1) &gt;&gt;</a>
<a name="ln668">			vol-&gt;cluster_size_bits);</a>
<a name="ln669">	if (!rl || !rl-&gt;length || rl-&gt;lcn &lt; 0) {</a>
<a name="ln670">		ntfs_log_error(&quot;Failed to determine last allocated &quot;</a>
<a name="ln671">				&quot;cluster of mft bitmap attribute.\n&quot;);</a>
<a name="ln672">		if (rl)</a>
<a name="ln673">			errno = EIO;</a>
<a name="ln674">		return STATUS_ERROR;</a>
<a name="ln675">	}</a>
<a name="ln676">	lcn = rl-&gt;lcn + rl-&gt;length;</a>
<a name="ln677">	</a>
<a name="ln678">	rl2 = ntfs_cluster_alloc(vol, rl[1].vcn, 1, lcn, DATA_ZONE);</a>
<a name="ln679">	if (!rl2) {</a>
<a name="ln680">		ntfs_log_error(&quot;Failed to allocate a cluster for &quot;</a>
<a name="ln681">				&quot;the mft bitmap.\n&quot;);</a>
<a name="ln682">		return STATUS_ERROR;</a>
<a name="ln683">	}</a>
<a name="ln684">	rl = ntfs_runlists_merge(mftbmp_na-&gt;rl, rl2);</a>
<a name="ln685">	if (!rl) {</a>
<a name="ln686">		err = errno;</a>
<a name="ln687">		ntfs_log_error(&quot;Failed to merge runlists for mft &quot;</a>
<a name="ln688">				&quot;bitmap.\n&quot;);</a>
<a name="ln689">		if (ntfs_cluster_free_from_rl(vol, rl2))</a>
<a name="ln690">			ntfs_log_error(&quot;Failed to deallocate &quot;</a>
<a name="ln691">					&quot;cluster.%s\n&quot;, es);</a>
<a name="ln692">		free(rl2);</a>
<a name="ln693">		errno = err;</a>
<a name="ln694">		return STATUS_ERROR;</a>
<a name="ln695">	}</a>
<a name="ln696">	mftbmp_na-&gt;rl = rl;</a>
<a name="ln697">	ntfs_log_debug(&quot;Adding one run to mft bitmap.\n&quot;);</a>
<a name="ln698">	/* Find the last run in the new runlist. */</a>
<a name="ln699">	for (; rl[1].length; rl++)</a>
<a name="ln700">		;</a>
<a name="ln701">	/*</a>
<a name="ln702">	 * Update the attribute record as well.  Note: @rl is the last</a>
<a name="ln703">	 * (non-terminator) runlist element of mft bitmap.</a>
<a name="ln704">	 */</a>
<a name="ln705">	ctx = ntfs_attr_get_search_ctx(mftbmp_na-&gt;ni, NULL);</a>
<a name="ln706">	if (!ctx)</a>
<a name="ln707">		goto undo_alloc;</a>
<a name="ln708"> </a>
<a name="ln709">	if (ntfs_attr_lookup(mftbmp_na-&gt;type, mftbmp_na-&gt;name,</a>
<a name="ln710">			mftbmp_na-&gt;name_len, 0, rl[1].vcn, NULL, 0, ctx)) {</a>
<a name="ln711">		ntfs_log_error(&quot;Failed to find last attribute extent of &quot;</a>
<a name="ln712">				&quot;mft bitmap attribute.\n&quot;);</a>
<a name="ln713">		goto undo_alloc;</a>
<a name="ln714">	}</a>
<a name="ln715">	m = ctx-&gt;mrec;</a>
<a name="ln716">	a = ctx-&gt;attr;</a>
<a name="ln717">	ll = sle64_to_cpu(a-&gt;lowest_vcn);</a>
<a name="ln718">	rl2 = ntfs_attr_find_vcn(mftbmp_na, ll);</a>
<a name="ln719">	if (!rl2 || !rl2-&gt;length) {</a>
<a name="ln720">		ntfs_log_error(&quot;Failed to determine previous last &quot;</a>
<a name="ln721">				&quot;allocated cluster of mft bitmap attribute.\n&quot;);</a>
<a name="ln722">		if (rl2)</a>
<a name="ln723">			errno = EIO;</a>
<a name="ln724">		goto undo_alloc;</a>
<a name="ln725">	}</a>
<a name="ln726">	/* Get the size for the new mapping pairs array for this extent. */</a>
<a name="ln727">	mp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, INT_MAX);</a>
<a name="ln728">	if (mp_size &lt;= 0) {</a>
<a name="ln729">		ntfs_log_error(&quot;Get size for mapping pairs failed for &quot;</a>
<a name="ln730">				&quot;mft bitmap attribute extent.\n&quot;);</a>
<a name="ln731">		goto undo_alloc;</a>
<a name="ln732">	}</a>
<a name="ln733">	/* Expand the attribute record if necessary. */</a>
<a name="ln734">	old_alen = le32_to_cpu(a-&gt;length);</a>
<a name="ln735">	if (ntfs_attr_record_resize(m, a, mp_size +</a>
<a name="ln736">			le16_to_cpu(a-&gt;mapping_pairs_offset))) {</a>
<a name="ln737">		ntfs_log_info(&quot;extending $MFT bitmap\n&quot;);</a>
<a name="ln738">		ret = ntfs_mft_attr_extend(vol-&gt;mftbmp_na);</a>
<a name="ln739">		if (ret == STATUS_OK)</a>
<a name="ln740">			goto ok;</a>
<a name="ln741">		if (ret == STATUS_ERROR) {</a>
<a name="ln742">			ntfs_log_perror(&quot;%s: ntfs_mft_attr_extend failed&quot;, __FUNCTION__);</a>
<a name="ln743">			update_mp = TRUE;</a>
<a name="ln744">		}</a>
<a name="ln745">		goto undo_alloc;</a>
<a name="ln746">	}</a>
<a name="ln747">	mp_rebuilt = TRUE;</a>
<a name="ln748">	/* Generate the mapping pairs array directly into the attr record. */</a>
<a name="ln749">	if (ntfs_mapping_pairs_build(vol, (u8*)a +</a>
<a name="ln750">			le16_to_cpu(a-&gt;mapping_pairs_offset), mp_size, rl2, ll,</a>
<a name="ln751">			NULL)) {</a>
<a name="ln752">		ntfs_log_error(&quot;Failed to build mapping pairs array for &quot;</a>
<a name="ln753">				&quot;mft bitmap attribute.\n&quot;);</a>
<a name="ln754">		errno = EIO;</a>
<a name="ln755">		goto undo_alloc;</a>
<a name="ln756">	}</a>
<a name="ln757">	/* Update the highest_vcn. */</a>
<a name="ln758">	a-&gt;highest_vcn = cpu_to_sle64(rl[1].vcn - 1);</a>
<a name="ln759">	/*</a>
<a name="ln760">	 * We now have extended the mft bitmap allocated_size by one cluster.</a>
<a name="ln761">	 * Reflect this in the ntfs_attr structure and the attribute record.</a>
<a name="ln762">	 */</a>
<a name="ln763">	if (a-&gt;lowest_vcn) {</a>
<a name="ln764">		/*</a>
<a name="ln765">		 * We are not in the first attribute extent, switch to it, but</a>
<a name="ln766">		 * first ensure the changes will make it to disk later.</a>
<a name="ln767">		 */</a>
<a name="ln768">		ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln769">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln770">		if (ntfs_attr_lookup(mftbmp_na-&gt;type, mftbmp_na-&gt;name,</a>
<a name="ln771">				mftbmp_na-&gt;name_len, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln772">			ntfs_log_error(&quot;Failed to find first attribute &quot;</a>
<a name="ln773">					&quot;extent of mft bitmap attribute.\n&quot;);</a>
<a name="ln774">			goto restore_undo_alloc;</a>
<a name="ln775">		}</a>
<a name="ln776">		a = ctx-&gt;attr;</a>
<a name="ln777">	}</a>
<a name="ln778">ok:</a>
<a name="ln779">	mftbmp_na-&gt;allocated_size += vol-&gt;cluster_size;</a>
<a name="ln780">	a-&gt;allocated_size = cpu_to_sle64(mftbmp_na-&gt;allocated_size);</a>
<a name="ln781">	/* Ensure the changes make it to disk. */</a>
<a name="ln782">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln783">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln784">	return STATUS_OK;</a>
<a name="ln785"> </a>
<a name="ln786">restore_undo_alloc:</a>
<a name="ln787">	err = errno;</a>
<a name="ln788">	ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln789">	if (ntfs_attr_lookup(mftbmp_na-&gt;type, mftbmp_na-&gt;name,</a>
<a name="ln790">			mftbmp_na-&gt;name_len, 0, rl[1].vcn, NULL, 0, ctx)) {</a>
<a name="ln791">		ntfs_log_error(&quot;Failed to find last attribute extent of &quot;</a>
<a name="ln792">				&quot;mft bitmap attribute.%s\n&quot;, es);</a>
<a name="ln793">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln794">		mftbmp_na-&gt;allocated_size += vol-&gt;cluster_size;</a>
<a name="ln795">		/*</a>
<a name="ln796">		 * The only thing that is now wrong is -&gt;allocated_size of the</a>
<a name="ln797">		 * base attribute extent which chkdsk should be able to fix.</a>
<a name="ln798">		 */</a>
<a name="ln799">		errno = err;</a>
<a name="ln800">		return STATUS_ERROR;</a>
<a name="ln801">	}</a>
<a name="ln802">	m = ctx-&gt;mrec;</a>
<a name="ln803">	a = ctx-&gt;attr;</a>
<a name="ln804">	a-&gt;highest_vcn = cpu_to_sle64(rl[1].vcn - 2);</a>
<a name="ln805">	errno = err;</a>
<a name="ln806">undo_alloc:</a>
<a name="ln807">	err = errno;</a>
<a name="ln808"> </a>
<a name="ln809">	/* Remove the last run from the runlist. */</a>
<a name="ln810">	lcn = rl-&gt;lcn;</a>
<a name="ln811">	rl-&gt;lcn = rl[1].lcn;</a>
<a name="ln812">	rl-&gt;length = 0;</a>
<a name="ln813">	</a>
<a name="ln814">	/* FIXME: use an ntfs_cluster_free_* function */</a>
<a name="ln815">	if (ntfs_bitmap_clear_bit(vol-&gt;lcnbmp_na, lcn))</a>
<a name="ln816">		ntfs_log_error(&quot;Failed to free cluster.%s\n&quot;, es);</a>
<a name="ln817">	else</a>
<a name="ln818">		vol-&gt;free_clusters++;</a>
<a name="ln819">	if (mp_rebuilt) {</a>
<a name="ln820">		if (ntfs_mapping_pairs_build(vol, (u8*)a +</a>
<a name="ln821">				le16_to_cpu(a-&gt;mapping_pairs_offset),</a>
<a name="ln822">				old_alen - le16_to_cpu(a-&gt;mapping_pairs_offset),</a>
<a name="ln823">				rl2, ll, NULL))</a>
<a name="ln824">			ntfs_log_error(&quot;Failed to restore mapping &quot;</a>
<a name="ln825">					&quot;pairs array.%s\n&quot;, es);</a>
<a name="ln826">		if (ntfs_attr_record_resize(m, a, old_alen))</a>
<a name="ln827">			ntfs_log_error(&quot;Failed to restore attribute &quot;</a>
<a name="ln828">					&quot;record.%s\n&quot;, es);</a>
<a name="ln829">		ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln830">	}</a>
<a name="ln831">	if (update_mp) {</a>
<a name="ln832">		if (ntfs_attr_update_mapping_pairs(vol-&gt;mftbmp_na, 0))</a>
<a name="ln833">			ntfs_log_perror(&quot;%s: MP update failed&quot;, __FUNCTION__);</a>
<a name="ln834">	}</a>
<a name="ln835">	if (ctx)</a>
<a name="ln836">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln837">	errno = err;</a>
<a name="ln838">	return ret;</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">/**</a>
<a name="ln842"> * ntfs_mft_bitmap_extend_allocation - extend mft bitmap attribute by a cluster</a>
<a name="ln843"> * @vol:	volume on which to extend the mft bitmap attribute</a>
<a name="ln844"> *</a>
<a name="ln845"> * Extend the mft bitmap attribute on the ntfs volume @vol by one cluster.</a>
<a name="ln846"> *</a>
<a name="ln847"> * Note:  Only changes allocated_size, i.e. does not touch initialized_size or</a>
<a name="ln848"> * data_size.</a>
<a name="ln849"> *</a>
<a name="ln850"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln851"> */</a>
<a name="ln852">static int ntfs_mft_bitmap_extend_allocation(ntfs_volume *vol)</a>
<a name="ln853">{</a>
<a name="ln854">	int ret;</a>
<a name="ln855">	</a>
<a name="ln856">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln857">	ret = ntfs_mft_bitmap_extend_allocation_i(vol);</a>
<a name="ln858">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln859">	return ret;</a>
<a name="ln860">}</a>
<a name="ln861">/**</a>
<a name="ln862"> * ntfs_mft_bitmap_extend_initialized - extend mft bitmap initialized data</a>
<a name="ln863"> * @vol:	volume on which to extend the mft bitmap attribute</a>
<a name="ln864"> *</a>
<a name="ln865"> * Extend the initialized portion of the mft bitmap attribute on the ntfs</a>
<a name="ln866"> * volume @vol by 8 bytes.</a>
<a name="ln867"> *</a>
<a name="ln868"> * Note:  Only changes initialized_size and data_size, i.e. requires that</a>
<a name="ln869"> * allocated_size is big enough to fit the new initialized_size.</a>
<a name="ln870"> *</a>
<a name="ln871"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln872"> */</a>
<a name="ln873">static int ntfs_mft_bitmap_extend_initialized(ntfs_volume *vol)</a>
<a name="ln874">{</a>
<a name="ln875">	s64 old_data_size, old_initialized_size, ll;</a>
<a name="ln876">	ntfs_attr *mftbmp_na;</a>
<a name="ln877">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln878">	ATTR_RECORD *a;</a>
<a name="ln879">	int err;</a>
<a name="ln880">	int ret = -1;</a>
<a name="ln881"> </a>
<a name="ln882">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln883">	</a>
<a name="ln884">	mftbmp_na = vol-&gt;mftbmp_na;</a>
<a name="ln885">	ctx = ntfs_attr_get_search_ctx(mftbmp_na-&gt;ni, NULL);</a>
<a name="ln886">	if (!ctx)</a>
<a name="ln887">		goto out;</a>
<a name="ln888"> </a>
<a name="ln889">	if (ntfs_attr_lookup(mftbmp_na-&gt;type, mftbmp_na-&gt;name,</a>
<a name="ln890">			mftbmp_na-&gt;name_len, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln891">		ntfs_log_error(&quot;Failed to find first attribute extent of &quot;</a>
<a name="ln892">				&quot;mft bitmap attribute.\n&quot;);</a>
<a name="ln893">		err = errno;</a>
<a name="ln894">		goto put_err_out;</a>
<a name="ln895">	}</a>
<a name="ln896">	a = ctx-&gt;attr;</a>
<a name="ln897">	old_data_size = mftbmp_na-&gt;data_size;</a>
<a name="ln898">	old_initialized_size = mftbmp_na-&gt;initialized_size;</a>
<a name="ln899">	mftbmp_na-&gt;initialized_size += 8;</a>
<a name="ln900">	a-&gt;initialized_size = cpu_to_sle64(mftbmp_na-&gt;initialized_size);</a>
<a name="ln901">	if (mftbmp_na-&gt;initialized_size &gt; mftbmp_na-&gt;data_size) {</a>
<a name="ln902">		mftbmp_na-&gt;data_size = mftbmp_na-&gt;initialized_size;</a>
<a name="ln903">		a-&gt;data_size = cpu_to_sle64(mftbmp_na-&gt;data_size);</a>
<a name="ln904">	}</a>
<a name="ln905">	/* Ensure the changes make it to disk. */</a>
<a name="ln906">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln907">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln908">	/* Initialize the mft bitmap attribute value with zeroes. */</a>
<a name="ln909">	ll = 0;</a>
<a name="ln910">	ll = ntfs_attr_pwrite(mftbmp_na, old_initialized_size, 8, &amp;ll);</a>
<a name="ln911">	if (ll == 8) {</a>
<a name="ln912">		ntfs_log_debug(&quot;Wrote eight initialized bytes to mft bitmap.\n&quot;);</a>
<a name="ln913">		vol-&gt;free_mft_records += (8 * 8); </a>
<a name="ln914">		ret = 0;</a>
<a name="ln915">		goto out;</a>
<a name="ln916">	}</a>
<a name="ln917">	ntfs_log_error(&quot;Failed to write to mft bitmap.\n&quot;);</a>
<a name="ln918">	err = errno;</a>
<a name="ln919">	if (ll &gt;= 0)</a>
<a name="ln920">		err = EIO;</a>
<a name="ln921">	/* Try to recover from the error. */</a>
<a name="ln922">	ctx = ntfs_attr_get_search_ctx(mftbmp_na-&gt;ni, NULL);</a>
<a name="ln923">	if (!ctx)</a>
<a name="ln924">		goto err_out;</a>
<a name="ln925"> </a>
<a name="ln926">	if (ntfs_attr_lookup(mftbmp_na-&gt;type, mftbmp_na-&gt;name,</a>
<a name="ln927">			mftbmp_na-&gt;name_len, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln928">		ntfs_log_error(&quot;Failed to find first attribute extent of &quot;</a>
<a name="ln929">				&quot;mft bitmap attribute.%s\n&quot;, es);</a>
<a name="ln930">put_err_out:</a>
<a name="ln931">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln932">		goto err_out;</a>
<a name="ln933">	}</a>
<a name="ln934">	a = ctx-&gt;attr;</a>
<a name="ln935">	mftbmp_na-&gt;initialized_size = old_initialized_size;</a>
<a name="ln936">	a-&gt;initialized_size = cpu_to_sle64(old_initialized_size);</a>
<a name="ln937">	if (mftbmp_na-&gt;data_size != old_data_size) {</a>
<a name="ln938">		mftbmp_na-&gt;data_size = old_data_size;</a>
<a name="ln939">		a-&gt;data_size = cpu_to_sle64(old_data_size);</a>
<a name="ln940">	}</a>
<a name="ln941">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln942">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln943">	ntfs_log_debug(&quot;Restored status of mftbmp: allocated_size 0x%llx, &quot;</a>
<a name="ln944">			&quot;data_size 0x%llx, initialized_size 0x%llx.\n&quot;,</a>
<a name="ln945">			(long long)mftbmp_na-&gt;allocated_size,</a>
<a name="ln946">			(long long)mftbmp_na-&gt;data_size,</a>
<a name="ln947">			(long long)mftbmp_na-&gt;initialized_size);</a>
<a name="ln948">err_out:</a>
<a name="ln949">	errno = err;</a>
<a name="ln950">out:</a>
<a name="ln951">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln952">	return ret;</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955">/**</a>
<a name="ln956"> * ntfs_mft_data_extend_allocation - extend mft data attribute</a>
<a name="ln957"> * @vol:	volume on which to extend the mft data attribute</a>
<a name="ln958"> *</a>
<a name="ln959"> * Extend the mft data attribute on the ntfs volume @vol by 16 mft records</a>
<a name="ln960"> * worth of clusters or if not enough space for this by one mft record worth</a>
<a name="ln961"> * of clusters.</a>
<a name="ln962"> *</a>
<a name="ln963"> * Note:  Only changes allocated_size, i.e. does not touch initialized_size or</a>
<a name="ln964"> * data_size.</a>
<a name="ln965"> *</a>
<a name="ln966"> * Return 0 on success and -1 on error with errno set to the error code.</a>
<a name="ln967"> */</a>
<a name="ln968">static int ntfs_mft_data_extend_allocation(ntfs_volume *vol)</a>
<a name="ln969">{</a>
<a name="ln970">	LCN lcn;</a>
<a name="ln971">	VCN old_last_vcn;</a>
<a name="ln972">	s64 min_nr, nr, ll = 0; /* silence compiler warning */</a>
<a name="ln973">	ntfs_attr *mft_na;</a>
<a name="ln974">	runlist_element *rl, *rl2;</a>
<a name="ln975">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln976">	MFT_RECORD *m = NULL; /* silence compiler warning */</a>
<a name="ln977">	ATTR_RECORD *a = NULL; /* silence compiler warning */</a>
<a name="ln978">	int err, mp_size;</a>
<a name="ln979">	int ret = STATUS_ERROR;</a>
<a name="ln980">	u32 old_alen = 0; /* silence compiler warning */</a>
<a name="ln981">	BOOL mp_rebuilt = FALSE;</a>
<a name="ln982">	BOOL update_mp = FALSE;</a>
<a name="ln983"> </a>
<a name="ln984">	ntfs_log_enter(&quot;Extending mft data allocation.\n&quot;);</a>
<a name="ln985">	</a>
<a name="ln986">	mft_na = vol-&gt;mft_na;</a>
<a name="ln987">	/*</a>
<a name="ln988">	 * Determine the preferred allocation location, i.e. the last lcn of</a>
<a name="ln989">	 * the mft data attribute.  The allocated size of the mft data</a>
<a name="ln990">	 * attribute cannot be zero so we are ok to do this.</a>
<a name="ln991">	 */</a>
<a name="ln992">	rl = ntfs_attr_find_vcn(mft_na,</a>
<a name="ln993">			(mft_na-&gt;allocated_size - 1) &gt;&gt; vol-&gt;cluster_size_bits);</a>
<a name="ln994">	</a>
<a name="ln995">	if (!rl || !rl-&gt;length || rl-&gt;lcn &lt; 0) {</a>
<a name="ln996">		ntfs_log_error(&quot;Failed to determine last allocated &quot;</a>
<a name="ln997">				&quot;cluster of mft data attribute.\n&quot;);</a>
<a name="ln998">		if (rl)</a>
<a name="ln999">			errno = EIO;</a>
<a name="ln1000">		goto out;</a>
<a name="ln1001">	}</a>
<a name="ln1002">	</a>
<a name="ln1003">	lcn = rl-&gt;lcn + rl-&gt;length;</a>
<a name="ln1004">	ntfs_log_debug(&quot;Last lcn of mft data attribute is 0x%llx.\n&quot;, (long long)lcn);</a>
<a name="ln1005">	/* Minimum allocation is one mft record worth of clusters. */</a>
<a name="ln1006">	min_nr = vol-&gt;mft_record_size &gt;&gt; vol-&gt;cluster_size_bits;</a>
<a name="ln1007">	if (!min_nr)</a>
<a name="ln1008">		min_nr = 1;</a>
<a name="ln1009">	/* Want to allocate 16 mft records worth of clusters. */</a>
<a name="ln1010">	nr = vol-&gt;mft_record_size &lt;&lt; 4 &gt;&gt; vol-&gt;cluster_size_bits;</a>
<a name="ln1011">	if (!nr)</a>
<a name="ln1012">		nr = min_nr;</a>
<a name="ln1013">	</a>
<a name="ln1014">	old_last_vcn = rl[1].vcn;</a>
<a name="ln1015">	do {</a>
<a name="ln1016">		rl2 = ntfs_cluster_alloc(vol, old_last_vcn, nr, lcn, MFT_ZONE);</a>
<a name="ln1017">		if (rl2)</a>
<a name="ln1018">			break;</a>
<a name="ln1019">		if (errno != ENOSPC || nr == min_nr) {</a>
<a name="ln1020">			ntfs_log_perror(&quot;Failed to allocate (%lld) clusters &quot;</a>
<a name="ln1021">					&quot;for $MFT&quot;, (long long)nr);</a>
<a name="ln1022">			goto out;</a>
<a name="ln1023">		}</a>
<a name="ln1024">		/*</a>
<a name="ln1025">		 * There is not enough space to do the allocation, but there</a>
<a name="ln1026">		 * might be enough space to do a minimal allocation so try that</a>
<a name="ln1027">		 * before failing.</a>
<a name="ln1028">		 */</a>
<a name="ln1029">		nr = min_nr;</a>
<a name="ln1030">		ntfs_log_debug(&quot;Retrying mft data allocation with minimal cluster &quot;</a>
<a name="ln1031">				&quot;count %lli.\n&quot;, (long long)nr);</a>
<a name="ln1032">	} while (1);</a>
<a name="ln1033">	</a>
<a name="ln1034">	ntfs_log_debug(&quot;Allocated %lld clusters.\n&quot;, (long long)nr);</a>
<a name="ln1035">	</a>
<a name="ln1036">	rl = ntfs_runlists_merge(mft_na-&gt;rl, rl2);</a>
<a name="ln1037">	if (!rl) {</a>
<a name="ln1038">		err = errno;</a>
<a name="ln1039">		ntfs_log_error(&quot;Failed to merge runlists for mft data &quot;</a>
<a name="ln1040">				&quot;attribute.\n&quot;);</a>
<a name="ln1041">		if (ntfs_cluster_free_from_rl(vol, rl2))</a>
<a name="ln1042">			ntfs_log_error(&quot;Failed to deallocate clusters &quot;</a>
<a name="ln1043">					&quot;from the mft data attribute.%s\n&quot;, es);</a>
<a name="ln1044">		free(rl2);</a>
<a name="ln1045">		errno = err;</a>
<a name="ln1046">		goto out;</a>
<a name="ln1047">	}</a>
<a name="ln1048">	mft_na-&gt;rl = rl;</a>
<a name="ln1049">	</a>
<a name="ln1050">	/* Find the last run in the new runlist. */</a>
<a name="ln1051">	for (; rl[1].length; rl++)</a>
<a name="ln1052">		;</a>
<a name="ln1053">	/* Update the attribute record as well. */</a>
<a name="ln1054">	ctx = ntfs_attr_get_search_ctx(mft_na-&gt;ni, NULL);</a>
<a name="ln1055">	if (!ctx)</a>
<a name="ln1056">		goto undo_alloc;</a>
<a name="ln1057"> </a>
<a name="ln1058">	if (ntfs_attr_lookup(mft_na-&gt;type, mft_na-&gt;name, mft_na-&gt;name_len, 0,</a>
<a name="ln1059">			rl[1].vcn, NULL, 0, ctx)) {</a>
<a name="ln1060">		ntfs_log_error(&quot;Failed to find last attribute extent of &quot;</a>
<a name="ln1061">				&quot;mft data attribute.\n&quot;);</a>
<a name="ln1062">		goto undo_alloc;</a>
<a name="ln1063">	}</a>
<a name="ln1064">	m = ctx-&gt;mrec;</a>
<a name="ln1065">	a = ctx-&gt;attr;</a>
<a name="ln1066">	ll = sle64_to_cpu(a-&gt;lowest_vcn);</a>
<a name="ln1067">	rl2 = ntfs_attr_find_vcn(mft_na, ll);</a>
<a name="ln1068">	if (!rl2 || !rl2-&gt;length) {</a>
<a name="ln1069">		ntfs_log_error(&quot;Failed to determine previous last &quot;</a>
<a name="ln1070">				&quot;allocated cluster of mft data attribute.\n&quot;);</a>
<a name="ln1071">		if (rl2)</a>
<a name="ln1072">			errno = EIO;</a>
<a name="ln1073">		goto undo_alloc;</a>
<a name="ln1074">	}</a>
<a name="ln1075">	/* Get the size for the new mapping pairs array for this extent. */</a>
<a name="ln1076">	mp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, INT_MAX);</a>
<a name="ln1077">	if (mp_size &lt;= 0) {</a>
<a name="ln1078">		ntfs_log_error(&quot;Get size for mapping pairs failed for &quot;</a>
<a name="ln1079">				&quot;mft data attribute extent.\n&quot;);</a>
<a name="ln1080">		goto undo_alloc;</a>
<a name="ln1081">	}</a>
<a name="ln1082">	/* Expand the attribute record if necessary. */</a>
<a name="ln1083">	old_alen = le32_to_cpu(a-&gt;length);</a>
<a name="ln1084">	if (ntfs_attr_record_resize(m, a,</a>
<a name="ln1085">			mp_size + le16_to_cpu(a-&gt;mapping_pairs_offset))) {</a>
<a name="ln1086">		ret = ntfs_mft_attr_extend(vol-&gt;mft_na);</a>
<a name="ln1087">		if (ret == STATUS_OK)</a>
<a name="ln1088">			goto ok;</a>
<a name="ln1089">		if (ret == STATUS_ERROR) {</a>
<a name="ln1090">			ntfs_log_perror(&quot;%s: ntfs_mft_attr_extend failed&quot;, __FUNCTION__);</a>
<a name="ln1091">			update_mp = TRUE;</a>
<a name="ln1092">		}</a>
<a name="ln1093">		goto undo_alloc;</a>
<a name="ln1094">	}</a>
<a name="ln1095">	mp_rebuilt = TRUE;</a>
<a name="ln1096">	/*</a>
<a name="ln1097">	 * Generate the mapping pairs array directly into the attribute record.</a>
<a name="ln1098">	 */</a>
<a name="ln1099">	if (ntfs_mapping_pairs_build(vol,</a>
<a name="ln1100">			(u8*)a + le16_to_cpu(a-&gt;mapping_pairs_offset), mp_size,</a>
<a name="ln1101">			rl2, ll, NULL)) {</a>
<a name="ln1102">		ntfs_log_error(&quot;Failed to build mapping pairs array of &quot;</a>
<a name="ln1103">				&quot;mft data attribute.\n&quot;);</a>
<a name="ln1104">		errno = EIO;</a>
<a name="ln1105">		goto undo_alloc;</a>
<a name="ln1106">	}</a>
<a name="ln1107">	/* Update the highest_vcn. */</a>
<a name="ln1108">	a-&gt;highest_vcn = cpu_to_sle64(rl[1].vcn - 1);</a>
<a name="ln1109">	/*</a>
<a name="ln1110">	 * We now have extended the mft data allocated_size by nr clusters.</a>
<a name="ln1111">	 * Reflect this in the ntfs_attr structure and the attribute record.</a>
<a name="ln1112">	 * @rl is the last (non-terminator) runlist element of mft data</a>
<a name="ln1113">	 * attribute.</a>
<a name="ln1114">	 */</a>
<a name="ln1115">	if (a-&gt;lowest_vcn) {</a>
<a name="ln1116">		/*</a>
<a name="ln1117">		 * We are not in the first attribute extent, switch to it, but</a>
<a name="ln1118">		 * first ensure the changes will make it to disk later.</a>
<a name="ln1119">		 */</a>
<a name="ln1120">		ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln1121">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln1122">		if (ntfs_attr_lookup(mft_na-&gt;type, mft_na-&gt;name,</a>
<a name="ln1123">				mft_na-&gt;name_len, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln1124">			ntfs_log_error(&quot;Failed to find first attribute &quot;</a>
<a name="ln1125">					&quot;extent of mft data attribute.\n&quot;);</a>
<a name="ln1126">			goto restore_undo_alloc;</a>
<a name="ln1127">		}</a>
<a name="ln1128">		a = ctx-&gt;attr;</a>
<a name="ln1129">	}</a>
<a name="ln1130">ok:</a>
<a name="ln1131">	mft_na-&gt;allocated_size += nr &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln1132">	a-&gt;allocated_size = cpu_to_sle64(mft_na-&gt;allocated_size);</a>
<a name="ln1133">	/* Ensure the changes make it to disk. */</a>
<a name="ln1134">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln1135">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1136">	ret = STATUS_OK;</a>
<a name="ln1137">out:</a>
<a name="ln1138">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln1139">	return ret;</a>
<a name="ln1140"> </a>
<a name="ln1141">restore_undo_alloc:</a>
<a name="ln1142">	err = errno;</a>
<a name="ln1143">	ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln1144">	if (ntfs_attr_lookup(mft_na-&gt;type, mft_na-&gt;name, mft_na-&gt;name_len, 0,</a>
<a name="ln1145">			rl[1].vcn, NULL, 0, ctx)) {</a>
<a name="ln1146">		ntfs_log_error(&quot;Failed to find last attribute extent of &quot;</a>
<a name="ln1147">				&quot;mft data attribute.%s\n&quot;, es);</a>
<a name="ln1148">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1149">		mft_na-&gt;allocated_size += nr &lt;&lt; vol-&gt;cluster_size_bits;</a>
<a name="ln1150">		/*</a>
<a name="ln1151">		 * The only thing that is now wrong is -&gt;allocated_size of the</a>
<a name="ln1152">		 * base attribute extent which chkdsk should be able to fix.</a>
<a name="ln1153">		 */</a>
<a name="ln1154">		errno = err;</a>
<a name="ln1155">		ret = STATUS_ERROR;</a>
<a name="ln1156">		goto out;</a>
<a name="ln1157">	}</a>
<a name="ln1158">	m = ctx-&gt;mrec;</a>
<a name="ln1159">	a = ctx-&gt;attr;</a>
<a name="ln1160">	a-&gt;highest_vcn = cpu_to_sle64(old_last_vcn - 1);</a>
<a name="ln1161">	errno = err;</a>
<a name="ln1162">undo_alloc:</a>
<a name="ln1163">	err = errno;</a>
<a name="ln1164">	if (ntfs_cluster_free(vol, mft_na, old_last_vcn, -1) &lt; 0)</a>
<a name="ln1165">		ntfs_log_error(&quot;Failed to free clusters from mft data &quot;</a>
<a name="ln1166">				&quot;attribute.%s\n&quot;, es);</a>
<a name="ln1167">	if (ntfs_rl_truncate(&amp;mft_na-&gt;rl, old_last_vcn))</a>
<a name="ln1168">		ntfs_log_error(&quot;Failed to truncate mft data attribute &quot;</a>
<a name="ln1169">				&quot;runlist.%s\n&quot;, es);</a>
<a name="ln1170">	if (mp_rebuilt) {</a>
<a name="ln1171">		if (ntfs_mapping_pairs_build(vol, (u8*)a +</a>
<a name="ln1172">				le16_to_cpu(a-&gt;mapping_pairs_offset),</a>
<a name="ln1173">				old_alen - le16_to_cpu(a-&gt;mapping_pairs_offset),</a>
<a name="ln1174">				rl2, ll, NULL))</a>
<a name="ln1175">			ntfs_log_error(&quot;Failed to restore mapping pairs &quot;</a>
<a name="ln1176">					&quot;array.%s\n&quot;, es);</a>
<a name="ln1177">		if (ntfs_attr_record_resize(m, a, old_alen))</a>
<a name="ln1178">			ntfs_log_error(&quot;Failed to restore attribute &quot;</a>
<a name="ln1179">					&quot;record.%s\n&quot;, es);</a>
<a name="ln1180">		ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln1181">	}</a>
<a name="ln1182">	if (update_mp) {</a>
<a name="ln1183">		if (ntfs_attr_update_mapping_pairs(vol-&gt;mft_na, 0))</a>
<a name="ln1184">			ntfs_log_perror(&quot;%s: MP update failed&quot;, __FUNCTION__);</a>
<a name="ln1185">	}</a>
<a name="ln1186">	if (ctx)</a>
<a name="ln1187">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1188">	errno = err;</a>
<a name="ln1189">	goto out;</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192"> </a>
<a name="ln1193">static int ntfs_mft_record_init(ntfs_volume *vol, s64 size)</a>
<a name="ln1194">{</a>
<a name="ln1195">	int ret = -1;</a>
<a name="ln1196">	ntfs_attr *mft_na;</a>
<a name="ln1197">	s64 old_data_initialized, old_data_size;</a>
<a name="ln1198">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1199">	</a>
<a name="ln1200">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln1201">	</a>
<a name="ln1202">	/* NOTE: Caller must sanity check vol, vol-&gt;mft_na and vol-&gt;mftbmp_na */</a>
<a name="ln1203">	</a>
<a name="ln1204">	mft_na = vol-&gt;mft_na;</a>
<a name="ln1205">	</a>
<a name="ln1206">	/*</a>
<a name="ln1207">	 * The mft record is outside the initialized data. Extend the mft data</a>
<a name="ln1208">	 * attribute until it covers the allocated record. The loop is only</a>
<a name="ln1209">	 * actually traversed more than once when a freshly formatted volume</a>
<a name="ln1210">	 * is first written to so it optimizes away nicely in the common case.</a>
<a name="ln1211">	 */</a>
<a name="ln1212">	ntfs_log_debug(&quot;Status of mft data before extension: &quot;</a>
<a name="ln1213">			&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;</a>
<a name="ln1214">			&quot;initialized_size 0x%llx.\n&quot;,</a>
<a name="ln1215">			(long long)mft_na-&gt;allocated_size,</a>
<a name="ln1216">			(long long)mft_na-&gt;data_size,</a>
<a name="ln1217">			(long long)mft_na-&gt;initialized_size);</a>
<a name="ln1218">	while (size &gt; mft_na-&gt;allocated_size) {</a>
<a name="ln1219">		if (ntfs_mft_data_extend_allocation(vol) == STATUS_ERROR)</a>
<a name="ln1220">			goto out;</a>
<a name="ln1221">		ntfs_log_debug(&quot;Status of mft data after allocation extension: &quot;</a>
<a name="ln1222">				&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;</a>
<a name="ln1223">				&quot;initialized_size 0x%llx.\n&quot;,</a>
<a name="ln1224">				(long long)mft_na-&gt;allocated_size,</a>
<a name="ln1225">				(long long)mft_na-&gt;data_size,</a>
<a name="ln1226">				(long long)mft_na-&gt;initialized_size);</a>
<a name="ln1227">	}</a>
<a name="ln1228">	</a>
<a name="ln1229">	old_data_initialized = mft_na-&gt;initialized_size;</a>
<a name="ln1230">	old_data_size = mft_na-&gt;data_size;</a>
<a name="ln1231">	</a>
<a name="ln1232">	/*</a>
<a name="ln1233">	 * Extend mft data initialized size (and data size of course) to reach</a>
<a name="ln1234">	 * the allocated mft record, formatting the mft records along the way.</a>
<a name="ln1235">	 * Note: We only modify the ntfs_attr structure as that is all that is</a>
<a name="ln1236">	 * needed by ntfs_mft_record_format().  We will update the attribute</a>
<a name="ln1237">	 * record itself in one fell swoop later on.</a>
<a name="ln1238">	 */</a>
<a name="ln1239">	while (size &gt; mft_na-&gt;initialized_size) {</a>
<a name="ln1240">		s64 ll2 = mft_na-&gt;initialized_size &gt;&gt; vol-&gt;mft_record_size_bits;</a>
<a name="ln1241">		mft_na-&gt;initialized_size += vol-&gt;mft_record_size;</a>
<a name="ln1242">		if (mft_na-&gt;initialized_size &gt; mft_na-&gt;data_size)</a>
<a name="ln1243">			mft_na-&gt;data_size = mft_na-&gt;initialized_size;</a>
<a name="ln1244">		ntfs_log_debug(&quot;Initializing mft record 0x%llx.\n&quot;, (long long)ll2);</a>
<a name="ln1245">		if (ntfs_mft_record_format(vol, ll2) &lt; 0) {</a>
<a name="ln1246">			ntfs_log_perror(&quot;Failed to format mft record&quot;);</a>
<a name="ln1247">			goto undo_data_init;</a>
<a name="ln1248">		}</a>
<a name="ln1249">	}</a>
<a name="ln1250">	</a>
<a name="ln1251">	/* Update the mft data attribute record to reflect the new sizes. */</a>
<a name="ln1252">	ctx = ntfs_attr_get_search_ctx(mft_na-&gt;ni, NULL);</a>
<a name="ln1253">	if (!ctx)</a>
<a name="ln1254">		goto undo_data_init;</a>
<a name="ln1255"> </a>
<a name="ln1256">	if (ntfs_attr_lookup(mft_na-&gt;type, mft_na-&gt;name, mft_na-&gt;name_len, 0,</a>
<a name="ln1257">			0, NULL, 0, ctx)) {</a>
<a name="ln1258">		ntfs_log_error(&quot;Failed to find first attribute extent of &quot;</a>
<a name="ln1259">				&quot;mft data attribute.\n&quot;);</a>
<a name="ln1260">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1261">		goto undo_data_init;</a>
<a name="ln1262">	}</a>
<a name="ln1263">	ctx-&gt;attr-&gt;initialized_size = cpu_to_sle64(mft_na-&gt;initialized_size);</a>
<a name="ln1264">	ctx-&gt;attr-&gt;data_size = cpu_to_sle64(mft_na-&gt;data_size);</a>
<a name="ln1265">	ctx-&gt;attr-&gt;allocated_size = cpu_to_sle64(mft_na-&gt;allocated_size);</a>
<a name="ln1266">	</a>
<a name="ln1267">	/* Ensure the changes make it to disk. */</a>
<a name="ln1268">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln1269">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1270">	ntfs_log_debug(&quot;Status of mft data after mft record initialization: &quot;</a>
<a name="ln1271">			&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;</a>
<a name="ln1272">			&quot;initialized_size 0x%llx.\n&quot;,</a>
<a name="ln1273">			(long long)mft_na-&gt;allocated_size,</a>
<a name="ln1274">			(long long)mft_na-&gt;data_size,</a>
<a name="ln1275">			(long long)mft_na-&gt;initialized_size);</a>
<a name="ln1276">	</a>
<a name="ln1277">	/* Sanity checks. */</a>
<a name="ln1278">	if (mft_na-&gt;data_size &gt; mft_na-&gt;allocated_size ||</a>
<a name="ln1279">	    mft_na-&gt;initialized_size &gt; mft_na-&gt;data_size)</a>
<a name="ln1280">		NTFS_BUG(&quot;mft_na sanity checks failed&quot;);</a>
<a name="ln1281">	</a>
<a name="ln1282">	/* Sync MFT to minimize data loss if there won't be clean unmount. */</a>
<a name="ln1283">	if (ntfs_inode_sync(mft_na-&gt;ni))</a>
<a name="ln1284">		goto undo_data_init;</a>
<a name="ln1285">	</a>
<a name="ln1286">	ret = 0;</a>
<a name="ln1287">out:	</a>
<a name="ln1288">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln1289">	return ret;</a>
<a name="ln1290">	</a>
<a name="ln1291">undo_data_init:</a>
<a name="ln1292">	mft_na-&gt;initialized_size = old_data_initialized;</a>
<a name="ln1293">	mft_na-&gt;data_size = old_data_size;</a>
<a name="ln1294">	goto out;</a>
<a name="ln1295">}</a>
<a name="ln1296"> </a>
<a name="ln1297">static int ntfs_mft_rec_init(ntfs_volume *vol, s64 size)</a>
<a name="ln1298">{</a>
<a name="ln1299">	int ret = -1;</a>
<a name="ln1300">	ntfs_attr *mft_na;</a>
<a name="ln1301">	s64 old_data_initialized, old_data_size;</a>
<a name="ln1302">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1303">	</a>
<a name="ln1304">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln1305">	</a>
<a name="ln1306">	mft_na = vol-&gt;mft_na;</a>
<a name="ln1307">	</a>
<a name="ln1308">	if (size &gt; mft_na-&gt;allocated_size || size &gt; mft_na-&gt;initialized_size) {</a>
<a name="ln1309">		errno = EIO;</a>
<a name="ln1310">		ntfs_log_perror(&quot;%s: unexpected $MFT sizes, see below&quot;, __FUNCTION__);</a>
<a name="ln1311">		ntfs_log_error(&quot;$MFT: size=%lld  allocated_size=%lld  &quot;</a>
<a name="ln1312">			       &quot;data_size=%lld  initialized_size=%lld\n&quot;,</a>
<a name="ln1313">			       (long long)size,</a>
<a name="ln1314">			       (long long)mft_na-&gt;allocated_size,</a>
<a name="ln1315">			       (long long)mft_na-&gt;data_size,</a>
<a name="ln1316">			       (long long)mft_na-&gt;initialized_size);</a>
<a name="ln1317">		goto out;</a>
<a name="ln1318">	}</a>
<a name="ln1319">	</a>
<a name="ln1320">	old_data_initialized = mft_na-&gt;initialized_size;</a>
<a name="ln1321">	old_data_size = mft_na-&gt;data_size;</a>
<a name="ln1322">	</a>
<a name="ln1323">	/* Update the mft data attribute record to reflect the new sizes. */</a>
<a name="ln1324">	ctx = ntfs_attr_get_search_ctx(mft_na-&gt;ni, NULL);</a>
<a name="ln1325">	if (!ctx)</a>
<a name="ln1326">		goto undo_data_init;</a>
<a name="ln1327"> </a>
<a name="ln1328">	if (ntfs_attr_lookup(mft_na-&gt;type, mft_na-&gt;name, mft_na-&gt;name_len, 0,</a>
<a name="ln1329">			0, NULL, 0, ctx)) {</a>
<a name="ln1330">		ntfs_log_error(&quot;Failed to find first attribute extent of &quot;</a>
<a name="ln1331">				&quot;mft data attribute.\n&quot;);</a>
<a name="ln1332">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1333">		goto undo_data_init;</a>
<a name="ln1334">	}</a>
<a name="ln1335">	ctx-&gt;attr-&gt;initialized_size = cpu_to_sle64(mft_na-&gt;initialized_size);</a>
<a name="ln1336">	ctx-&gt;attr-&gt;data_size = cpu_to_sle64(mft_na-&gt;data_size);</a>
<a name="ln1337"> </a>
<a name="ln1338">	/* CHECKME: ctx-&gt;attr-&gt;allocation_size is already ok? */</a>
<a name="ln1339">	</a>
<a name="ln1340">	/* Ensure the changes make it to disk. */</a>
<a name="ln1341">	ntfs_inode_mark_dirty(ctx-&gt;ntfs_ino);</a>
<a name="ln1342">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1343">	</a>
<a name="ln1344">	/* Sanity checks. */</a>
<a name="ln1345">	if (mft_na-&gt;data_size &gt; mft_na-&gt;allocated_size ||</a>
<a name="ln1346">	    mft_na-&gt;initialized_size &gt; mft_na-&gt;data_size)</a>
<a name="ln1347">		NTFS_BUG(&quot;mft_na sanity checks failed&quot;);</a>
<a name="ln1348">out:	</a>
<a name="ln1349">	ntfs_log_leave(&quot;\n&quot;);</a>
<a name="ln1350">	return ret;</a>
<a name="ln1351">	</a>
<a name="ln1352">undo_data_init:</a>
<a name="ln1353">	mft_na-&gt;initialized_size = old_data_initialized;</a>
<a name="ln1354">	mft_na-&gt;data_size = old_data_size;</a>
<a name="ln1355">	goto out;</a>
<a name="ln1356">}</a>
<a name="ln1357"> </a>
<a name="ln1358">ntfs_inode *ntfs_mft_rec_alloc(ntfs_volume *vol, BOOL mft_data)</a>
<a name="ln1359">{</a>
<a name="ln1360">	s64 ll, bit;</a>
<a name="ln1361">	ntfs_attr *mft_na, *mftbmp_na;</a>
<a name="ln1362">	MFT_RECORD *m;</a>
<a name="ln1363">	ntfs_inode *ni = NULL;</a>
<a name="ln1364">	ntfs_inode *base_ni;</a>
<a name="ln1365">	int err;</a>
<a name="ln1366">	le16 seq_no, usn;</a>
<a name="ln1367">	BOOL forced_mft_data;</a>
<a name="ln1368"> </a>
<a name="ln1369">	ntfs_log_enter(&quot;Entering\n&quot;);</a>
<a name="ln1370"> </a>
<a name="ln1371">	mft_na = vol-&gt;mft_na;</a>
<a name="ln1372">	mftbmp_na = vol-&gt;mftbmp_na;</a>
<a name="ln1373"> </a>
<a name="ln1374">	base_ni = mft_na-&gt;ni;</a>
<a name="ln1375"> </a>
<a name="ln1376">	/*</a>
<a name="ln1377">	 * The first extent containing $MFT:$AT_DATA is better located</a>
<a name="ln1378">	 * in record 15 to make sure it can be read at mount time.</a>
<a name="ln1379">	 * The record 15 is prereserved as a base inode with no</a>
<a name="ln1380">	 * extents and no name, and it is marked in use.</a>
<a name="ln1381">	 */</a>
<a name="ln1382">	forced_mft_data = FALSE;</a>
<a name="ln1383">	if (mft_data) {</a>
<a name="ln1384">		ntfs_inode *ext_ni = ntfs_inode_open(vol, FILE_mft_data);</a>
<a name="ln1385">			/*</a>
<a name="ln1386">			 * If record 15 cannot be opened, it is probably in</a>
<a name="ln1387">			 * use as an extent. Apply standard procedure for</a>
<a name="ln1388">			 * further extents.</a>
<a name="ln1389">			 */</a>
<a name="ln1390">		if (ext_ni) {</a>
<a name="ln1391">			/*</a>
<a name="ln1392">			 * Make sure record 15 is a base extent and has</a>
<a name="ln1393">			 * no extents.</a>
<a name="ln1394">			 * Also make sure it has no name : a base inode with</a>
<a name="ln1395">			 * no extents and no name cannot be in use.</a>
<a name="ln1396">			 * Otherwise apply standard procedure.</a>
<a name="ln1397">			 */</a>
<a name="ln1398">   			if (!ext_ni-&gt;mrec-&gt;base_mft_record</a>
<a name="ln1399">			    &amp;&amp; !ext_ni-&gt;nr_extents)</a>
<a name="ln1400">				forced_mft_data = TRUE;</a>
<a name="ln1401">			ntfs_inode_close(ext_ni);</a>
<a name="ln1402">		}</a>
<a name="ln1403">	}</a>
<a name="ln1404">	if (forced_mft_data)</a>
<a name="ln1405">		bit = FILE_mft_data;</a>
<a name="ln1406">	else</a>
<a name="ln1407">		bit = ntfs_mft_bitmap_find_free_rec(vol, base_ni);</a>
<a name="ln1408">	if (bit &gt;= 0)</a>
<a name="ln1409">		goto found_free_rec;</a>
<a name="ln1410"> </a>
<a name="ln1411">	if (errno != ENOSPC)</a>
<a name="ln1412">		goto out;</a>
<a name="ln1413">	</a>
<a name="ln1414">	errno = ENOSPC;</a>
<a name="ln1415">	/* strerror() is intentionally used below, we want to log this error. */</a>
<a name="ln1416">	ntfs_log_error(&quot;No free mft record for $MFT: %s\n&quot;, strerror(errno));</a>
<a name="ln1417">	goto err_out;</a>
<a name="ln1418"> </a>
<a name="ln1419">found_free_rec:</a>
<a name="ln1420">	if (ntfs_bitmap_set_bit(mftbmp_na, bit)) {</a>
<a name="ln1421">		ntfs_log_error(&quot;Failed to allocate bit in mft bitmap #2\n&quot;);</a>
<a name="ln1422">		goto err_out;</a>
<a name="ln1423">	}</a>
<a name="ln1424">	</a>
<a name="ln1425">	ll = (bit + 1) &lt;&lt; vol-&gt;mft_record_size_bits;</a>
<a name="ln1426">	if (ll &gt; mft_na-&gt;initialized_size)</a>
<a name="ln1427">		if (ntfs_mft_rec_init(vol, ll) &lt; 0)</a>
<a name="ln1428">			goto undo_mftbmp_alloc;</a>
<a name="ln1429">	/*</a>
<a name="ln1430">	 * We now have allocated and initialized the mft record.  Need to read</a>
<a name="ln1431">	 * it from disk and re-format it, preserving the sequence number if it</a>
<a name="ln1432">	 * is not zero as well as the update sequence number if it is not zero</a>
<a name="ln1433">	 * or -1 (0xffff).</a>
<a name="ln1434">	 */</a>
<a name="ln1435">	m = ntfs_malloc(vol-&gt;mft_record_size);</a>
<a name="ln1436">	if (!m)</a>
<a name="ln1437">		goto undo_mftbmp_alloc;</a>
<a name="ln1438">	</a>
<a name="ln1439">	if (ntfs_mft_record_read(vol, bit, m)) {</a>
<a name="ln1440">		free(m);</a>
<a name="ln1441">		goto undo_mftbmp_alloc;</a>
<a name="ln1442">	}</a>
<a name="ln1443">	/* Sanity check that the mft record is really not in use. */</a>
<a name="ln1444">	if (!forced_mft_data</a>
<a name="ln1445">	    &amp;&amp; (ntfs_is_file_record(m-&gt;magic)</a>
<a name="ln1446">	    &amp;&amp; (m-&gt;flags &amp; MFT_RECORD_IN_USE))) {</a>
<a name="ln1447">		ntfs_log_error(&quot;Inode %lld is used but it wasn't marked in &quot;</a>
<a name="ln1448">			       &quot;$MFT bitmap. Fixed.\n&quot;, (long long)bit);</a>
<a name="ln1449">		free(m);</a>
<a name="ln1450">		goto undo_mftbmp_alloc;</a>
<a name="ln1451">	}</a>
<a name="ln1452"> </a>
<a name="ln1453">	seq_no = m-&gt;sequence_number;</a>
<a name="ln1454">	usn = *(le16*)((u8*)m + le16_to_cpu(m-&gt;usa_ofs));</a>
<a name="ln1455">	if (ntfs_mft_record_layout(vol, bit, m)) {</a>
<a name="ln1456">		ntfs_log_error(&quot;Failed to re-format mft record.\n&quot;);</a>
<a name="ln1457">		free(m);</a>
<a name="ln1458">		goto undo_mftbmp_alloc;</a>
<a name="ln1459">	}</a>
<a name="ln1460">	if (seq_no)</a>
<a name="ln1461">		m-&gt;sequence_number = seq_no;</a>
<a name="ln1462">	seq_no = usn;</a>
<a name="ln1463">	if (seq_no &amp;&amp; seq_no != const_cpu_to_le16(0xffff))</a>
<a name="ln1464">		*(le16*)((u8*)m + le16_to_cpu(m-&gt;usa_ofs)) = usn;</a>
<a name="ln1465">	/* Set the mft record itself in use. */</a>
<a name="ln1466">	m-&gt;flags |= MFT_RECORD_IN_USE;</a>
<a name="ln1467">	/* Now need to open an ntfs inode for the mft record. */</a>
<a name="ln1468">	ni = ntfs_inode_allocate(vol);</a>
<a name="ln1469">	if (!ni) {</a>
<a name="ln1470">		ntfs_log_error(&quot;Failed to allocate buffer for inode.\n&quot;);</a>
<a name="ln1471">		free(m);</a>
<a name="ln1472">		goto undo_mftbmp_alloc;</a>
<a name="ln1473">	}</a>
<a name="ln1474">	ni-&gt;mft_no = bit;</a>
<a name="ln1475">	ni-&gt;mrec = m;</a>
<a name="ln1476">	/*</a>
<a name="ln1477">	 * If we are allocating an extent mft record, make the opened inode an</a>
<a name="ln1478">	 * extent inode and attach it to the base inode.  Also, set the base</a>
<a name="ln1479">	 * mft record reference in the extent inode.</a>
<a name="ln1480">	 */</a>
<a name="ln1481">	ni-&gt;nr_extents = -1;</a>
<a name="ln1482">	ni-&gt;base_ni = base_ni;</a>
<a name="ln1483">	m-&gt;base_mft_record = MK_LE_MREF(base_ni-&gt;mft_no,</a>
<a name="ln1484">					le16_to_cpu(base_ni-&gt;mrec-&gt;sequence_number));</a>
<a name="ln1485">	/*</a>
<a name="ln1486">	 * Attach the extent inode to the base inode, reallocating</a>
<a name="ln1487">	 * memory if needed.</a>
<a name="ln1488">	 */</a>
<a name="ln1489">	if (!(base_ni-&gt;nr_extents &amp; 3)) {</a>
<a name="ln1490">		ntfs_inode **extent_nis;</a>
<a name="ln1491">		int i;</a>
<a name="ln1492"> </a>
<a name="ln1493">		i = (base_ni-&gt;nr_extents + 4) * sizeof(ntfs_inode *);</a>
<a name="ln1494">		extent_nis = ntfs_malloc(i);</a>
<a name="ln1495">		if (!extent_nis) {</a>
<a name="ln1496">			free(m);</a>
<a name="ln1497">			free(ni);</a>
<a name="ln1498">			goto undo_mftbmp_alloc;</a>
<a name="ln1499">		}</a>
<a name="ln1500">		if (base_ni-&gt;nr_extents) {</a>
<a name="ln1501">			memcpy(extent_nis, base_ni-&gt;extent_nis,</a>
<a name="ln1502">					i - 4 * sizeof(ntfs_inode *));</a>
<a name="ln1503">			free(base_ni-&gt;extent_nis);</a>
<a name="ln1504">		}</a>
<a name="ln1505">		base_ni-&gt;extent_nis = extent_nis;</a>
<a name="ln1506">	}</a>
<a name="ln1507">	base_ni-&gt;extent_nis[base_ni-&gt;nr_extents++] = ni;</a>
<a name="ln1508">	</a>
<a name="ln1509">	/* Make sure the allocated inode is written out to disk later. */</a>
<a name="ln1510">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln1511">	/* Initialize time, allocated and data size in ntfs_inode struct. */</a>
<a name="ln1512">	ni-&gt;data_size = ni-&gt;allocated_size = 0;</a>
<a name="ln1513">	ni-&gt;flags = const_cpu_to_le32(0);</a>
<a name="ln1514">	ni-&gt;creation_time = ni-&gt;last_data_change_time =</a>
<a name="ln1515">			ni-&gt;last_mft_change_time =</a>
<a name="ln1516">			ni-&gt;last_access_time = ntfs_current_time();</a>
<a name="ln1517">	/* Update the default mft allocation position if it was used. */</a>
<a name="ln1518">	if (!base_ni)</a>
<a name="ln1519">		vol-&gt;mft_data_pos = bit + 1;</a>
<a name="ln1520">	/* Return the opened, allocated inode of the allocated mft record. */</a>
<a name="ln1521">	ntfs_log_error(&quot;allocated %sinode %lld\n&quot;,</a>
<a name="ln1522">			base_ni ? &quot;extent &quot; : &quot;&quot;, (long long)bit);</a>
<a name="ln1523">out:</a>
<a name="ln1524">	ntfs_log_leave(&quot;\n&quot;);	</a>
<a name="ln1525">	return ni;</a>
<a name="ln1526"> </a>
<a name="ln1527">undo_mftbmp_alloc:</a>
<a name="ln1528">	err = errno;</a>
<a name="ln1529">	if (ntfs_bitmap_clear_bit(mftbmp_na, bit))</a>
<a name="ln1530">		ntfs_log_error(&quot;Failed to clear bit in mft bitmap.%s\n&quot;, es);</a>
<a name="ln1531">	errno = err;</a>
<a name="ln1532">err_out:</a>
<a name="ln1533">	if (!errno)</a>
<a name="ln1534">		errno = EIO;</a>
<a name="ln1535">	ni = NULL;</a>
<a name="ln1536">	goto out;	</a>
<a name="ln1537">}</a>
<a name="ln1538"> </a>
<a name="ln1539">/**</a>
<a name="ln1540"> * ntfs_mft_record_alloc - allocate an mft record on an ntfs volume</a>
<a name="ln1541"> * @vol:	volume on which to allocate the mft record</a>
<a name="ln1542"> * @base_ni:	open base inode if allocating an extent mft record or NULL</a>
<a name="ln1543"> *</a>
<a name="ln1544"> * Allocate an mft record in $MFT/$DATA of an open ntfs volume @vol.</a>
<a name="ln1545"> *</a>
<a name="ln1546"> * If @base_ni is NULL make the mft record a base mft record and allocate it at</a>
<a name="ln1547"> * the default allocator position.</a>
<a name="ln1548"> *</a>
<a name="ln1549"> * If @base_ni is not NULL make the allocated mft record an extent record,</a>
<a name="ln1550"> * allocate it starting at the mft record after the base mft record and attach</a>
<a name="ln1551"> * the allocated and opened ntfs inode to the base inode @base_ni.</a>
<a name="ln1552"> *</a>
<a name="ln1553"> * On success return the now opened ntfs (extent) inode of the mft record.</a>
<a name="ln1554"> *</a>
<a name="ln1555"> * On error return NULL with errno set to the error code.</a>
<a name="ln1556"> *</a>
<a name="ln1557"> * To find a free mft record, we scan the mft bitmap for a zero bit.  To</a>
<a name="ln1558"> * optimize this we start scanning at the place specified by @base_ni or if</a>
<a name="ln1559"> * @base_ni is NULL we start where we last stopped and we perform wrap around</a>
<a name="ln1560"> * when we reach the end.  Note, we do not try to allocate mft records below</a>
<a name="ln1561"> * number 24 because numbers 0 to 15 are the defined system files anyway and 16</a>
<a name="ln1562"> * to 24 are used for storing extension mft records or used by chkdsk to store</a>
<a name="ln1563"> * its log. However the record number 15 is dedicated to the first extent to</a>
<a name="ln1564"> * the $DATA attribute of $MFT.  This is required to avoid the possibility</a>
<a name="ln1565"> * of creating a run list with a circular dependence which once written to disk</a>
<a name="ln1566"> * can never be read in again.  Windows will only use records 16 to 24 for</a>
<a name="ln1567"> * normal files if the volume is completely out of space.  We never use them</a>
<a name="ln1568"> * which means that when the volume is really out of space we cannot create any</a>
<a name="ln1569"> * more files while Windows can still create up to 8 small files.  We can start</a>
<a name="ln1570"> * doing this at some later time, it does not matter much for now.</a>
<a name="ln1571"> *</a>
<a name="ln1572"> * When scanning the mft bitmap, we only search up to the last allocated mft</a>
<a name="ln1573"> * record.  If there are no free records left in the range 24 to number of</a>
<a name="ln1574"> * allocated mft records, then we extend the $MFT/$DATA attribute in order to</a>
<a name="ln1575"> * create free mft records.  We extend the allocated size of $MFT/$DATA by 16</a>
<a name="ln1576"> * records at a time or one cluster, if cluster size is above 16kiB.  If there</a>
<a name="ln1577"> * is not sufficient space to do this, we try to extend by a single mft record</a>
<a name="ln1578"> * or one cluster, if cluster size is above the mft record size, but we only do</a>
<a name="ln1579"> * this if there is enough free space, which we know from the values returned</a>
<a name="ln1580"> * by the failed cluster allocation function when we tried to do the first</a>
<a name="ln1581"> * allocation.</a>
<a name="ln1582"> *</a>
<a name="ln1583"> * No matter how many mft records we allocate, we initialize only the first</a>
<a name="ln1584"> * allocated mft record, incrementing mft data size and initialized size</a>
<a name="ln1585"> * accordingly, open an ntfs_inode for it and return it to the caller, unless</a>
<a name="ln1586"> * there are less than 24 mft records, in which case we allocate and initialize</a>
<a name="ln1587"> * mft records until we reach record 24 which we consider as the first free mft</a>
<a name="ln1588"> * record for use by normal files.</a>
<a name="ln1589"> *</a>
<a name="ln1590"> * If during any stage we overflow the initialized data in the mft bitmap, we</a>
<a name="ln1591"> * extend the initialized size (and data size) by 8 bytes, allocating another</a>
<a name="ln1592"> * cluster if required.  The bitmap data size has to be at least equal to the</a>
<a name="ln1593"> * number of mft records in the mft, but it can be bigger, in which case the</a>
<a name="ln1594"> * superfluous bits are padded with zeroes.</a>
<a name="ln1595"> *</a>
<a name="ln1596"> * Thus, when we return successfully (return value non-zero), we will have:</a>
<a name="ln1597"> *	- initialized / extended the mft bitmap if necessary,</a>
<a name="ln1598"> *	- initialized / extended the mft data if necessary,</a>
<a name="ln1599"> *	- set the bit corresponding to the mft record being allocated in the</a>
<a name="ln1600"> *	  mft bitmap,</a>
<a name="ln1601"> *	- open an ntfs_inode for the allocated mft record, and we will</a>
<a name="ln1602"> *	- return the ntfs_inode.</a>
<a name="ln1603"> *</a>
<a name="ln1604"> * On error (return value zero), nothing will have changed.  If we had changed</a>
<a name="ln1605"> * anything before the error occurred, we will have reverted back to the</a>
<a name="ln1606"> * starting state before returning to the caller.  Thus, except for bugs, we</a>
<a name="ln1607"> * should always leave the volume in a consistent state when returning from</a>
<a name="ln1608"> * this function.</a>
<a name="ln1609"> *</a>
<a name="ln1610"> * Note, this function cannot make use of most of the normal functions, like</a>
<a name="ln1611"> * for example for attribute resizing, etc, because when the run list overflows</a>
<a name="ln1612"> * the base mft record and an attribute list is used, it is very important that</a>
<a name="ln1613"> * the extension mft records used to store the $DATA attribute of $MFT can be</a>
<a name="ln1614"> * reached without having to read the information contained inside them, as</a>
<a name="ln1615"> * this would make it impossible to find them in the first place after the</a>
<a name="ln1616"> * volume is dismounted.  $MFT/$BITMAP probably does not need to follow this</a>
<a name="ln1617"> * rule because the bitmap is not essential for finding the mft records, but on</a>
<a name="ln1618"> * the other hand, handling the bitmap in this special way would make life</a>
<a name="ln1619"> * easier because otherwise there might be circular invocations of functions</a>
<a name="ln1620"> * when reading the bitmap but if we are careful, we should be able to avoid</a>
<a name="ln1621"> * all problems.</a>
<a name="ln1622"> */</a>
<a name="ln1623">ntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, ntfs_inode *base_ni)</a>
<a name="ln1624">{</a>
<a name="ln1625">	s64 ll, bit;</a>
<a name="ln1626">	ntfs_attr *mft_na, *mftbmp_na;</a>
<a name="ln1627">	MFT_RECORD *m;</a>
<a name="ln1628">	ntfs_inode *ni = NULL;</a>
<a name="ln1629">	int err;</a>
<a name="ln1630">	u32 usa_ofs;</a>
<a name="ln1631">	le16 seq_no, usn;</a>
<a name="ln1632">	BOOL oldwarn;</a>
<a name="ln1633"> </a>
<a name="ln1634">	if (base_ni)</a>
<a name="ln1635">		ntfs_log_enter(&quot;Entering (allocating an extent mft record for &quot;</a>
<a name="ln1636">			       &quot;base mft record %lld).\n&quot;, </a>
<a name="ln1637">			       (long long)base_ni-&gt;mft_no);</a>
<a name="ln1638">	else</a>
<a name="ln1639">		ntfs_log_enter(&quot;Entering (allocating a base mft record)\n&quot;);</a>
<a name="ln1640">	if (!vol || !vol-&gt;mft_na || !vol-&gt;mftbmp_na) {</a>
<a name="ln1641">		errno = EINVAL;</a>
<a name="ln1642">		goto out;</a>
<a name="ln1643">	}</a>
<a name="ln1644">	</a>
<a name="ln1645">	if (ntfs_is_mft(base_ni)) {</a>
<a name="ln1646">		ni = ntfs_mft_rec_alloc(vol, FALSE);</a>
<a name="ln1647">		goto out;</a>
<a name="ln1648">	}</a>
<a name="ln1649"> </a>
<a name="ln1650">	mft_na = vol-&gt;mft_na;</a>
<a name="ln1651">	mftbmp_na = vol-&gt;mftbmp_na;</a>
<a name="ln1652">retry:	</a>
<a name="ln1653">	bit = ntfs_mft_bitmap_find_free_rec(vol, base_ni);</a>
<a name="ln1654">	if (bit &gt;= 0) {</a>
<a name="ln1655">		ntfs_log_debug(&quot;found free record (#1) at %lld\n&quot;,</a>
<a name="ln1656">				(long long)bit);</a>
<a name="ln1657">		goto found_free_rec;</a>
<a name="ln1658">	}</a>
<a name="ln1659">	if (errno != ENOSPC)</a>
<a name="ln1660">		goto out;</a>
<a name="ln1661">	/*</a>
<a name="ln1662">	 * No free mft records left.  If the mft bitmap already covers more</a>
<a name="ln1663">	 * than the currently used mft records, the next records are all free,</a>
<a name="ln1664">	 * so we can simply allocate the first unused mft record.</a>
<a name="ln1665">	 * Note: We also have to make sure that the mft bitmap at least covers</a>
<a name="ln1666">	 * the first 24 mft records as they are special and whilst they may not</a>
<a name="ln1667">	 * be in use, we do not allocate from them.</a>
<a name="ln1668">	 */</a>
<a name="ln1669">	ll = mft_na-&gt;initialized_size &gt;&gt; vol-&gt;mft_record_size_bits;</a>
<a name="ln1670">	if (mftbmp_na-&gt;initialized_size &lt;&lt; 3 &gt; ll &amp;&amp;</a>
<a name="ln1671">			mftbmp_na-&gt;initialized_size &gt; RESERVED_MFT_RECORDS / 8) {</a>
<a name="ln1672">		bit = ll;</a>
<a name="ln1673">		if (bit &lt; RESERVED_MFT_RECORDS)</a>
<a name="ln1674">			bit = RESERVED_MFT_RECORDS;</a>
<a name="ln1675">		ntfs_log_debug(&quot;found free record (#2) at %lld\n&quot;,</a>
<a name="ln1676">				(long long)bit);</a>
<a name="ln1677">		goto found_free_rec;</a>
<a name="ln1678">	}</a>
<a name="ln1679">	/*</a>
<a name="ln1680">	 * The mft bitmap needs to be expanded until it covers the first unused</a>
<a name="ln1681">	 * mft record that we can allocate.</a>
<a name="ln1682">	 * Note: The smallest mft record we allocate is mft record 24.</a>
<a name="ln1683">	 */</a>
<a name="ln1684">	ntfs_log_debug(&quot;Status of mftbmp before extension: allocated_size 0x%llx, &quot;</a>
<a name="ln1685">			&quot;data_size 0x%llx, initialized_size 0x%llx.\n&quot;,</a>
<a name="ln1686">			(long long)mftbmp_na-&gt;allocated_size,</a>
<a name="ln1687">			(long long)mftbmp_na-&gt;data_size,</a>
<a name="ln1688">			(long long)mftbmp_na-&gt;initialized_size);</a>
<a name="ln1689">	if (mftbmp_na-&gt;initialized_size + 8 &gt; mftbmp_na-&gt;allocated_size) {</a>
<a name="ln1690"> </a>
<a name="ln1691">		int ret = ntfs_mft_bitmap_extend_allocation(vol);</a>
<a name="ln1692"> </a>
<a name="ln1693">		if (ret == STATUS_ERROR)</a>
<a name="ln1694">			goto err_out;</a>
<a name="ln1695">		if (ret == STATUS_KEEP_SEARCHING) {</a>
<a name="ln1696">			ret = ntfs_mft_bitmap_extend_allocation(vol);</a>
<a name="ln1697">			if (ret != STATUS_OK)</a>
<a name="ln1698">				goto err_out;</a>
<a name="ln1699">		}</a>
<a name="ln1700"> </a>
<a name="ln1701">		ntfs_log_debug(&quot;Status of mftbmp after allocation extension: &quot;</a>
<a name="ln1702">				&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;</a>
<a name="ln1703">				&quot;initialized_size 0x%llx.\n&quot;,</a>
<a name="ln1704">				(long long)mftbmp_na-&gt;allocated_size,</a>
<a name="ln1705">				(long long)mftbmp_na-&gt;data_size,</a>
<a name="ln1706">				(long long)mftbmp_na-&gt;initialized_size);</a>
<a name="ln1707">	}</a>
<a name="ln1708">	/*</a>
<a name="ln1709">	 * We now have sufficient allocated space, extend the initialized_size</a>
<a name="ln1710">	 * as well as the data_size if necessary and fill the new space with</a>
<a name="ln1711">	 * zeroes.</a>
<a name="ln1712">	 */</a>
<a name="ln1713">	bit = mftbmp_na-&gt;initialized_size &lt;&lt; 3;</a>
<a name="ln1714">	if (ntfs_mft_bitmap_extend_initialized(vol))</a>
<a name="ln1715">		goto err_out;</a>
<a name="ln1716">	ntfs_log_debug(&quot;Status of mftbmp after initialized extension: &quot;</a>
<a name="ln1717">			&quot;allocated_size 0x%llx, data_size 0x%llx, &quot;</a>
<a name="ln1718">			&quot;initialized_size 0x%llx.\n&quot;,</a>
<a name="ln1719">			(long long)mftbmp_na-&gt;allocated_size,</a>
<a name="ln1720">			(long long)mftbmp_na-&gt;data_size,</a>
<a name="ln1721">			(long long)mftbmp_na-&gt;initialized_size);</a>
<a name="ln1722">	ntfs_log_debug(&quot;found free record (#3) at %lld\n&quot;, (long long)bit);</a>
<a name="ln1723">found_free_rec:</a>
<a name="ln1724">	/* @bit is the found free mft record, allocate it in the mft bitmap. */</a>
<a name="ln1725">	if (ntfs_bitmap_set_bit(mftbmp_na, bit)) {</a>
<a name="ln1726">		ntfs_log_error(&quot;Failed to allocate bit in mft bitmap.\n&quot;);</a>
<a name="ln1727">		goto err_out;</a>
<a name="ln1728">	}</a>
<a name="ln1729">	</a>
<a name="ln1730">	/* The mft bitmap is now uptodate.  Deal with mft data attribute now. */</a>
<a name="ln1731">	ll = (bit + 1) &lt;&lt; vol-&gt;mft_record_size_bits;</a>
<a name="ln1732">	if (ll &gt; mft_na-&gt;initialized_size)</a>
<a name="ln1733">		if (ntfs_mft_record_init(vol, ll) &lt; 0)</a>
<a name="ln1734">			goto undo_mftbmp_alloc;</a>
<a name="ln1735"> </a>
<a name="ln1736">	/*</a>
<a name="ln1737">	 * We now have allocated and initialized the mft record.  Need to read</a>
<a name="ln1738">	 * it from disk and re-format it, preserving the sequence number if it</a>
<a name="ln1739">	 * is not zero as well as the update sequence number if it is not zero</a>
<a name="ln1740">	 * or -1 (0xffff).</a>
<a name="ln1741">	 */</a>
<a name="ln1742">	m = ntfs_malloc(vol-&gt;mft_record_size);</a>
<a name="ln1743">	if (!m)</a>
<a name="ln1744">		goto undo_mftbmp_alloc;</a>
<a name="ln1745">	</a>
<a name="ln1746">	/*</a>
<a name="ln1747">	 * As this is allocating a new record, do not expect it to have</a>
<a name="ln1748">	 * been initialized previously, so do not warn over bad fixups</a>
<a name="ln1749">	 * (hence avoid warn flooding when an NTFS partition has been wiped).</a>
<a name="ln1750">	 */</a>
<a name="ln1751">	oldwarn = !NVolNoFixupWarn(vol);</a>
<a name="ln1752">	NVolSetNoFixupWarn(vol);</a>
<a name="ln1753">	if (ntfs_mft_record_read(vol, bit, m)) {</a>
<a name="ln1754">		if (oldwarn)</a>
<a name="ln1755">			NVolClearNoFixupWarn(vol);</a>
<a name="ln1756">		free(m);</a>
<a name="ln1757">		goto undo_mftbmp_alloc;</a>
<a name="ln1758">	}</a>
<a name="ln1759">	if (oldwarn)</a>
<a name="ln1760">		NVolClearNoFixupWarn(vol);</a>
<a name="ln1761"> </a>
<a name="ln1762">	/* Sanity check that the mft record is really not in use. */</a>
<a name="ln1763">	if (ntfs_is_file_record(m-&gt;magic) &amp;&amp; (m-&gt;flags &amp; MFT_RECORD_IN_USE)) {</a>
<a name="ln1764">		ntfs_log_error(&quot;Inode %lld is used but it wasn't marked in &quot;</a>
<a name="ln1765">			       &quot;$MFT bitmap. Fixed.\n&quot;, (long long)bit);</a>
<a name="ln1766">		free(m);</a>
<a name="ln1767">		goto retry;</a>
<a name="ln1768">	}</a>
<a name="ln1769">	seq_no = m-&gt;sequence_number;</a>
<a name="ln1770">		/*</a>
<a name="ln1771">		 * As ntfs_mft_record_read() returns what has been read</a>
<a name="ln1772">		 * even when the fixups have been found bad, we have to</a>
<a name="ln1773">		 * check where we fetch the initial usn from.</a>
<a name="ln1774">		 */</a>
<a name="ln1775">	usa_ofs = le16_to_cpu(m-&gt;usa_ofs);</a>
<a name="ln1776">	if (!(usa_ofs &amp; 1) &amp;&amp; (usa_ofs &lt; NTFS_BLOCK_SIZE)) {</a>
<a name="ln1777">		usn = *(le16*)((u8*)m + usa_ofs);</a>
<a name="ln1778">	} else</a>
<a name="ln1779">		usn = const_cpu_to_le16(1);</a>
<a name="ln1780">	if (ntfs_mft_record_layout(vol, bit, m)) {</a>
<a name="ln1781">		ntfs_log_error(&quot;Failed to re-format mft record.\n&quot;);</a>
<a name="ln1782">		free(m);</a>
<a name="ln1783">		goto undo_mftbmp_alloc;</a>
<a name="ln1784">	}</a>
<a name="ln1785">	if (seq_no)</a>
<a name="ln1786">		m-&gt;sequence_number = seq_no;</a>
<a name="ln1787">	seq_no = usn;</a>
<a name="ln1788">	if (seq_no &amp;&amp; seq_no != const_cpu_to_le16(0xffff))</a>
<a name="ln1789">		*(le16*)((u8*)m + le16_to_cpu(m-&gt;usa_ofs)) = usn;</a>
<a name="ln1790">	/* Set the mft record itself in use. */</a>
<a name="ln1791">	m-&gt;flags |= MFT_RECORD_IN_USE;</a>
<a name="ln1792">	/* Now need to open an ntfs inode for the mft record. */</a>
<a name="ln1793">	ni = ntfs_inode_allocate(vol);</a>
<a name="ln1794">	if (!ni) {</a>
<a name="ln1795">		ntfs_log_error(&quot;Failed to allocate buffer for inode.\n&quot;);</a>
<a name="ln1796">		free(m);</a>
<a name="ln1797">		goto undo_mftbmp_alloc;</a>
<a name="ln1798">	}</a>
<a name="ln1799">	ni-&gt;mft_no = bit;</a>
<a name="ln1800">	ni-&gt;mrec = m;</a>
<a name="ln1801">	/*</a>
<a name="ln1802">	 * If we are allocating an extent mft record, make the opened inode an</a>
<a name="ln1803">	 * extent inode and attach it to the base inode.  Also, set the base</a>
<a name="ln1804">	 * mft record reference in the extent inode.</a>
<a name="ln1805">	 */</a>
<a name="ln1806">	if (base_ni) {</a>
<a name="ln1807">		ni-&gt;nr_extents = -1;</a>
<a name="ln1808">		ni-&gt;base_ni = base_ni;</a>
<a name="ln1809">		m-&gt;base_mft_record = MK_LE_MREF(base_ni-&gt;mft_no,</a>
<a name="ln1810">				le16_to_cpu(base_ni-&gt;mrec-&gt;sequence_number));</a>
<a name="ln1811">		/*</a>
<a name="ln1812">		 * Attach the extent inode to the base inode, reallocating</a>
<a name="ln1813">		 * memory if needed.</a>
<a name="ln1814">		 */</a>
<a name="ln1815">		if (!(base_ni-&gt;nr_extents &amp; 3)) {</a>
<a name="ln1816">			ntfs_inode **extent_nis;</a>
<a name="ln1817">			int i;</a>
<a name="ln1818"> </a>
<a name="ln1819">			i = (base_ni-&gt;nr_extents + 4) * sizeof(ntfs_inode *);</a>
<a name="ln1820">			extent_nis = ntfs_malloc(i);</a>
<a name="ln1821">			if (!extent_nis) {</a>
<a name="ln1822">				free(m);</a>
<a name="ln1823">				free(ni);</a>
<a name="ln1824">				goto undo_mftbmp_alloc;</a>
<a name="ln1825">			}</a>
<a name="ln1826">			if (base_ni-&gt;nr_extents) {</a>
<a name="ln1827">				memcpy(extent_nis, base_ni-&gt;extent_nis,</a>
<a name="ln1828">						i - 4 * sizeof(ntfs_inode *));</a>
<a name="ln1829">				free(base_ni-&gt;extent_nis);</a>
<a name="ln1830">			}</a>
<a name="ln1831">			base_ni-&gt;extent_nis = extent_nis;</a>
<a name="ln1832">		}</a>
<a name="ln1833">		base_ni-&gt;extent_nis[base_ni-&gt;nr_extents++] = ni;</a>
<a name="ln1834">	}</a>
<a name="ln1835">	/* Make sure the allocated inode is written out to disk later. */</a>
<a name="ln1836">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln1837">	/* Initialize time, allocated and data size in ntfs_inode struct. */</a>
<a name="ln1838">	ni-&gt;data_size = ni-&gt;allocated_size = 0;</a>
<a name="ln1839">	ni-&gt;flags = const_cpu_to_le32(0);</a>
<a name="ln1840">	ni-&gt;creation_time = ni-&gt;last_data_change_time =</a>
<a name="ln1841">			ni-&gt;last_mft_change_time =</a>
<a name="ln1842">			ni-&gt;last_access_time = ntfs_current_time();</a>
<a name="ln1843">	/* Update the default mft allocation position if it was used. */</a>
<a name="ln1844">	if (!base_ni)</a>
<a name="ln1845">		vol-&gt;mft_data_pos = bit + 1;</a>
<a name="ln1846">	/* Return the opened, allocated inode of the allocated mft record. */</a>
<a name="ln1847">	ntfs_log_debug(&quot;allocated %sinode 0x%llx.\n&quot;,</a>
<a name="ln1848">			base_ni ? &quot;extent &quot; : &quot;&quot;, (long long)bit);</a>
<a name="ln1849">	vol-&gt;free_mft_records--; </a>
<a name="ln1850">out:</a>
<a name="ln1851">	ntfs_log_leave(&quot;\n&quot;);	</a>
<a name="ln1852">	return ni;</a>
<a name="ln1853"> </a>
<a name="ln1854">undo_mftbmp_alloc:</a>
<a name="ln1855">	err = errno;</a>
<a name="ln1856">	if (ntfs_bitmap_clear_bit(mftbmp_na, bit))</a>
<a name="ln1857">		ntfs_log_error(&quot;Failed to clear bit in mft bitmap.%s\n&quot;, es);</a>
<a name="ln1858">	errno = err;</a>
<a name="ln1859">err_out:</a>
<a name="ln1860">	if (!errno)</a>
<a name="ln1861">		errno = EIO;</a>
<a name="ln1862">	ni = NULL;</a>
<a name="ln1863">	goto out;	</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866">/**</a>
<a name="ln1867"> * ntfs_mft_record_free - free an mft record on an ntfs volume</a>
<a name="ln1868"> * @vol:	volume on which to free the mft record</a>
<a name="ln1869"> * @ni:		open ntfs inode of the mft record to free</a>
<a name="ln1870"> *</a>
<a name="ln1871"> * Free the mft record of the open inode @ni on the mounted ntfs volume @vol.</a>
<a name="ln1872"> * Note that this function calls ntfs_inode_close() internally and hence you</a>
<a name="ln1873"> * cannot use the pointer @ni any more after this function returns success.</a>
<a name="ln1874"> *</a>
<a name="ln1875"> * On success return 0 and on error return -1 with errno set to the error code.</a>
<a name="ln1876"> */</a>
<a name="ln1877">int ntfs_mft_record_free(ntfs_volume *vol, ntfs_inode *ni)</a>
<a name="ln1878">{</a>
<a name="ln1879">	u64 mft_no;</a>
<a name="ln1880">	int err;</a>
<a name="ln1881">	u16 seq_no;</a>
<a name="ln1882">	le16 old_seq_no;</a>
<a name="ln1883"> </a>
<a name="ln1884">	ntfs_log_trace(&quot;Entering for inode 0x%llx.\n&quot;, (long long) ni-&gt;mft_no);</a>
<a name="ln1885"> </a>
<a name="ln1886">	if (!vol || !vol-&gt;mftbmp_na || !ni) {</a>
<a name="ln1887">		errno = EINVAL;</a>
<a name="ln1888">		return -1;</a>
<a name="ln1889">	}</a>
<a name="ln1890"> </a>
<a name="ln1891">	/* Cache the mft reference for later. */</a>
<a name="ln1892">	mft_no = ni-&gt;mft_no;</a>
<a name="ln1893"> </a>
<a name="ln1894">	/* Mark the mft record as not in use. */</a>
<a name="ln1895">	ni-&gt;mrec-&gt;flags &amp;= ~MFT_RECORD_IN_USE;</a>
<a name="ln1896"> </a>
<a name="ln1897">	/* Increment the sequence number, skipping zero, if it is not zero. */</a>
<a name="ln1898">	old_seq_no = ni-&gt;mrec-&gt;sequence_number;</a>
<a name="ln1899">	seq_no = le16_to_cpu(old_seq_no);</a>
<a name="ln1900">	if (seq_no == 0xffff)</a>
<a name="ln1901">		seq_no = 1;</a>
<a name="ln1902">	else if (seq_no)</a>
<a name="ln1903">		seq_no++;</a>
<a name="ln1904">	ni-&gt;mrec-&gt;sequence_number = cpu_to_le16(seq_no);</a>
<a name="ln1905"> </a>
<a name="ln1906">	/* Set the inode dirty and write it out. */</a>
<a name="ln1907">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln1908">	if (ntfs_inode_sync(ni)) {</a>
<a name="ln1909">		err = errno;</a>
<a name="ln1910">		goto sync_rollback;</a>
<a name="ln1911">	}</a>
<a name="ln1912"> </a>
<a name="ln1913">	/* Clear the bit in the $MFT/$BITMAP corresponding to this record. */</a>
<a name="ln1914">	if (ntfs_bitmap_clear_bit(vol-&gt;mftbmp_na, mft_no)) {</a>
<a name="ln1915">		err = errno;</a>
<a name="ln1916">		// FIXME: If ntfs_bitmap_clear_run() guarantees rollback on</a>
<a name="ln1917">		//	  error, this could be changed to goto sync_rollback;</a>
<a name="ln1918">		goto bitmap_rollback;</a>
<a name="ln1919">	}</a>
<a name="ln1920"> </a>
<a name="ln1921">	/* Throw away the now freed inode. */</a>
<a name="ln1922">#if CACHE_NIDATA_SIZE</a>
<a name="ln1923">	if (!ntfs_inode_real_close(ni)) {</a>
<a name="ln1924">#else</a>
<a name="ln1925">	if (!ntfs_inode_close(ni)) {</a>
<a name="ln1926">#endif</a>
<a name="ln1927">		vol-&gt;free_mft_records++; </a>
<a name="ln1928">		return 0;</a>
<a name="ln1929">	}</a>
<a name="ln1930">	err = errno;</a>
<a name="ln1931"> </a>
<a name="ln1932">	/* Rollback what we did... */</a>
<a name="ln1933">bitmap_rollback:</a>
<a name="ln1934">	if (ntfs_bitmap_set_bit(vol-&gt;mftbmp_na, mft_no))</a>
<a name="ln1935">		ntfs_log_debug(&quot;Eeek! Rollback failed in ntfs_mft_record_free().  &quot;</a>
<a name="ln1936">				&quot;Leaving inconsistent metadata!\n&quot;);</a>
<a name="ln1937">sync_rollback:</a>
<a name="ln1938">	ni-&gt;mrec-&gt;flags |= MFT_RECORD_IN_USE;</a>
<a name="ln1939">	ni-&gt;mrec-&gt;sequence_number = old_seq_no;</a>
<a name="ln1940">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln1941">	errno = err;</a>
<a name="ln1942">	return -1;</a>
<a name="ln1943">}</a>
<a name="ln1944"> </a>
<a name="ln1945">/**</a>
<a name="ln1946"> * ntfs_mft_usn_dec - Decrement USN by one</a>
<a name="ln1947"> * @mrec:	pointer to an mft record</a>
<a name="ln1948"> *</a>
<a name="ln1949"> * On success return 0 and on error return -1 with errno set.</a>
<a name="ln1950"> */</a>
<a name="ln1951">int ntfs_mft_usn_dec(MFT_RECORD *mrec)</a>
<a name="ln1952">{</a>
<a name="ln1953">	u16 usn;</a>
<a name="ln1954">	le16 *usnp;</a>
<a name="ln1955"> </a>
<a name="ln1956">	if (!mrec) {</a>
<a name="ln1957">		errno = EINVAL;</a>
<a name="ln1958">		return -1;</a>
<a name="ln1959">	}</a>
<a name="ln1960">	usnp = (le16*)((char*)mrec + le16_to_cpu(mrec-&gt;usa_ofs));</a>
<a name="ln1961">	usn = le16_to_cpup(usnp);</a>
<a name="ln1962">	if (usn-- &lt;= 1)</a>
<a name="ln1963">		usn = 0xfffe;</a>
<a name="ln1964">	*usnp = cpu_to_le16(usn);</a>
<a name="ln1965"> </a>
<a name="ln1966">	return 0;</a>
<a name="ln1967">}</a>
<a name="ln1968"> </a>

</code></pre>
<div class="balloon" rel="1010"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the 'vol->mft_record_size << 4' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="1180"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ctx' pointer was utilized before it was verified against nullptr. Check lines: 1180, 1186.</p></div>
<div class="balloon" rel="829"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ctx' pointer was utilized before it was verified against nullptr. Check lines: 829, 835.</p></div>
<div class="balloon" rel="1505"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'base_ni' pointer was utilized before it was verified against nullptr. Check lines: 1505, 1518.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
