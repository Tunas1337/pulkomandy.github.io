
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>if.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009, Colin Günther, coling@gmx.de.</a>
<a name="ln3"> * Copyright 2007-2009, Axel Dörfler, axeld@pinc-software.de.</a>
<a name="ln4"> * Copyright 2007, Hugo Santos. All Rights Reserved.</a>
<a name="ln5"> * Copyright 2004, Marcus Overhagen. All Rights Reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Distributed under the terms of the MIT License.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;device.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;stdio.h&gt;</a>
<a name="ln14">#include &lt;net/if_types.h&gt;</a>
<a name="ln15">#include &lt;sys/sockio.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;compat/sys/bus.h&gt;</a>
<a name="ln18">#include &lt;compat/sys/kernel.h&gt;</a>
<a name="ln19">#include &lt;compat/sys/taskqueue.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;compat/net/bpf.h&gt;</a>
<a name="ln22">#include &lt;compat/net/ethernet.h&gt;</a>
<a name="ln23">#include &lt;compat/net/if.h&gt;</a>
<a name="ln24">#include &lt;compat/net/if_arp.h&gt;</a>
<a name="ln25">#include &lt;compat/net/if_media.h&gt;</a>
<a name="ln26">#include &lt;compat/net/if_var.h&gt;</a>
<a name="ln27">#include &lt;compat/net/if_vlan_var.h&gt;</a>
<a name="ln28">#include &lt;compat/sys/malloc.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">int ifqmaxlen = IFQ_MAXLEN;</a>
<a name="ln33"> </a>
<a name="ln34">static void	if_input_default(struct ifnet *, struct mbuf *);</a>
<a name="ln35">static int	if_requestencap_default(struct ifnet *, struct if_encap_req *);</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">#define IFNET_HOLD (void *)(uintptr_t)(-1)</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">static void</a>
<a name="ln43">insert_into_device_name_list(struct ifnet * ifp)</a>
<a name="ln44">{</a>
<a name="ln45">	int i;</a>
<a name="ln46">	for (i = 0; i &lt; MAX_DEVICES; i++) {</a>
<a name="ln47">		if (gDeviceNameList[i] == NULL) {</a>
<a name="ln48">			gDeviceNameList[i] = ifp-&gt;device_name;</a>
<a name="ln49">			return;</a>
<a name="ln50">		}</a>
<a name="ln51">	}</a>
<a name="ln52"> </a>
<a name="ln53">	panic(&quot;too many devices&quot;);</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">static void</a>
<a name="ln58">remove_from_device_name_list(struct ifnet * ifp)</a>
<a name="ln59">{</a>
<a name="ln60">	int i;</a>
<a name="ln61">	for (i = 0; i &lt; MAX_DEVICES; i++) {</a>
<a name="ln62">		if (ifp-&gt;device_name == gDeviceNameList[i]) {</a>
<a name="ln63">			int last;</a>
<a name="ln64">			for (last = i + 1; last &lt; MAX_DEVICES; last++) {</a>
<a name="ln65">				if (gDeviceNameList[last] == NULL)</a>
<a name="ln66">					break;</a>
<a name="ln67">			}</a>
<a name="ln68">			last--;</a>
<a name="ln69"> </a>
<a name="ln70">			if (i == last)</a>
<a name="ln71">				gDeviceNameList[i] = NULL;</a>
<a name="ln72">			else {</a>
<a name="ln73">				// switch positions with the last entry</a>
<a name="ln74">				gDeviceNameList[i] = gDeviceNameList[last];</a>
<a name="ln75">				gDeviceNameList[last] = NULL;</a>
<a name="ln76">			}</a>
<a name="ln77">			break;</a>
<a name="ln78">		}</a>
<a name="ln79">	}</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">struct ifnet *</a>
<a name="ln84">ifnet_byindex(u_short idx)</a>
<a name="ln85">{</a>
<a name="ln86">	struct ifnet *ifp;</a>
<a name="ln87"> </a>
<a name="ln88">	IFNET_RLOCK_NOSLEEP();</a>
<a name="ln89">	ifp = ifnet_byindex_locked(idx);</a>
<a name="ln90">	IFNET_RUNLOCK_NOSLEEP();</a>
<a name="ln91"> </a>
<a name="ln92">	return (ifp);</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">struct ifnet *</a>
<a name="ln97">ifnet_byindex_locked(u_short idx)</a>
<a name="ln98">{</a>
<a name="ln99">	struct ifnet *ifp;</a>
<a name="ln100"> </a>
<a name="ln101">	ifp = gDevices[idx];</a>
<a name="ln102"> </a>
<a name="ln103">	return (ifp);</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">static void</a>
<a name="ln108">ifnet_setbyindex_locked(u_short idx, struct ifnet *ifp)</a>
<a name="ln109">{</a>
<a name="ln110">	gDevices[idx] = ifp;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113"> </a>
<a name="ln114">static void</a>
<a name="ln115">ifnet_setbyindex(u_short idx, struct ifnet *ifp)</a>
<a name="ln116">{</a>
<a name="ln117">	IFNET_WLOCK();</a>
<a name="ln118">	ifnet_setbyindex_locked(idx, ifp);</a>
<a name="ln119">	IFNET_WUNLOCK();</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122"> </a>
<a name="ln123">static int</a>
<a name="ln124">ifindex_alloc_locked(u_short *idxp)</a>
<a name="ln125">{</a>
<a name="ln126">	u_short index;</a>
<a name="ln127"> </a>
<a name="ln128">	for (index = 0; index &lt; MAX_DEVICES; index++) {</a>
<a name="ln129">		if (gDevices[index] == NULL) {</a>
<a name="ln130">			break;</a>
<a name="ln131">		}</a>
<a name="ln132">	}</a>
<a name="ln133"> </a>
<a name="ln134">	if (index == MAX_DEVICES)</a>
<a name="ln135">		return ENOSPC;</a>
<a name="ln136"> </a>
<a name="ln137">	gDeviceCount++;</a>
<a name="ln138">	*idxp = index;</a>
<a name="ln139"> </a>
<a name="ln140">	return ENOERR;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143"> </a>
<a name="ln144">static void</a>
<a name="ln145">ifindex_free_locked(u_short idx)</a>
<a name="ln146">{</a>
<a name="ln147">	gDevices[idx] = NULL;</a>
<a name="ln148">	gDeviceCount--;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">struct ifnet *</a>
<a name="ln153">if_alloc(u_char type)</a>
<a name="ln154">{</a>
<a name="ln155">	char semName[64];</a>
<a name="ln156">	u_short index;</a>
<a name="ln157"> </a>
<a name="ln158">	struct ifnet *ifp = _kernel_malloc(sizeof(struct ifnet), M_ZERO);</a>
<a name="ln159">	if (ifp == NULL)</a>
<a name="ln160">		return NULL;</a>
<a name="ln161"> </a>
<a name="ln162">	snprintf(semName, sizeof(semName), &quot;%s receive&quot;, gDriverName);</a>
<a name="ln163"> </a>
<a name="ln164">	ifp-&gt;receive_sem = create_sem(0, semName);</a>
<a name="ln165">	if (ifp-&gt;receive_sem &lt; B_OK)</a>
<a name="ln166">		goto err1;</a>
<a name="ln167"> </a>
<a name="ln168">	switch (type) {</a>
<a name="ln169">		case IFT_ETHER:</a>
<a name="ln170">		{</a>
<a name="ln171">			ifp-&gt;if_l2com = _kernel_malloc(sizeof(struct arpcom), M_ZERO);</a>
<a name="ln172">			if (ifp-&gt;if_l2com == NULL)</a>
<a name="ln173">				goto err2;</a>
<a name="ln174">			IFP2AC(ifp)-&gt;ac_ifp = ifp;</a>
<a name="ln175">			break;</a>
<a name="ln176">		}</a>
<a name="ln177">	}</a>
<a name="ln178"> </a>
<a name="ln179">	ifp-&gt;link_state_sem = -1;</a>
<a name="ln180">	ifp-&gt;open_count = 0;</a>
<a name="ln181">	ifp-&gt;flags = 0;</a>
<a name="ln182">	ifp-&gt;if_type = type;</a>
<a name="ln183">	ifq_init(&amp;ifp-&gt;receive_queue, semName);</a>
<a name="ln184"> </a>
<a name="ln185">	ifp-&gt;scan_done_sem = -1;</a>
<a name="ln186">		// WLAN specific, doesn't hurt when initilized for other devices</a>
<a name="ln187"> </a>
<a name="ln188">	// Search for the first free device slot, and use that one</a>
<a name="ln189">	IFNET_WLOCK();</a>
<a name="ln190">	if (ifindex_alloc_locked(&amp;index) != ENOERR) {</a>
<a name="ln191">		IFNET_WUNLOCK();</a>
<a name="ln192">		panic(&quot;too many devices&quot;);</a>
<a name="ln193">		goto err3;</a>
<a name="ln194">	}</a>
<a name="ln195">	ifnet_setbyindex_locked(index, IFNET_HOLD);</a>
<a name="ln196">	IFNET_WUNLOCK();</a>
<a name="ln197"> </a>
<a name="ln198">	ifp-&gt;if_index = index;</a>
<a name="ln199">	ifnet_setbyindex(ifp-&gt;if_index, ifp);</a>
<a name="ln200"> </a>
<a name="ln201">	IF_ADDR_LOCK_INIT(ifp);</a>
<a name="ln202">	return ifp;</a>
<a name="ln203"> </a>
<a name="ln204">err3:</a>
<a name="ln205">	switch (type) {</a>
<a name="ln206">		case IFT_ETHER:</a>
<a name="ln207">			_kernel_free(ifp-&gt;if_l2com);</a>
<a name="ln208">			break;</a>
<a name="ln209">	}</a>
<a name="ln210"> </a>
<a name="ln211">err2:</a>
<a name="ln212">	delete_sem(ifp-&gt;receive_sem);</a>
<a name="ln213"> </a>
<a name="ln214">err1:</a>
<a name="ln215">	_kernel_free(ifp);</a>
<a name="ln216">	return NULL;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">void</a>
<a name="ln221">if_free(struct ifnet *ifp)</a>
<a name="ln222">{</a>
<a name="ln223">	// IEEE80211 devices won't be in this list,</a>
<a name="ln224">	// so don't try to remove them.</a>
<a name="ln225">	if (ifp-&gt;if_type == IFT_ETHER)</a>
<a name="ln226">		remove_from_device_name_list(ifp);</a>
<a name="ln227"> </a>
<a name="ln228">	IFNET_WLOCK();</a>
<a name="ln229">	ifindex_free_locked(ifp-&gt;if_index);</a>
<a name="ln230">	IFNET_WUNLOCK();</a>
<a name="ln231"> </a>
<a name="ln232">	IF_ADDR_LOCK_DESTROY(ifp);</a>
<a name="ln233">	switch (ifp-&gt;if_type) {</a>
<a name="ln234">		case IFT_ETHER:</a>
<a name="ln235">			_kernel_free(ifp-&gt;if_l2com);</a>
<a name="ln236">			break;</a>
<a name="ln237">	}</a>
<a name="ln238"> </a>
<a name="ln239">	delete_sem(ifp-&gt;receive_sem);</a>
<a name="ln240">	ifq_uninit(&amp;ifp-&gt;receive_queue);</a>
<a name="ln241"> </a>
<a name="ln242">	_kernel_free(ifp);</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">void</a>
<a name="ln247">if_initname(struct ifnet *ifp, const char *name, int unit)</a>
<a name="ln248">{</a>
<a name="ln249">	dprintf(&quot;if_initname(%p, %s, %d)\n&quot;, ifp, name, unit);</a>
<a name="ln250"> </a>
<a name="ln251">	if (name == NULL || name[0] == '\0')</a>
<a name="ln252">		panic(&quot;interface goes unnamed&quot;);</a>
<a name="ln253"> </a>
<a name="ln254">	ifp-&gt;if_dname = name;</a>
<a name="ln255">	ifp-&gt;if_dunit = unit;</a>
<a name="ln256"> </a>
<a name="ln257">	strlcpy(ifp-&gt;if_xname, name, sizeof(ifp-&gt;if_xname));</a>
<a name="ln258"> </a>
<a name="ln259">	snprintf(ifp-&gt;device_name, sizeof(ifp-&gt;device_name), &quot;net/%s/%i&quot;,</a>
<a name="ln260">		gDriverName, ifp-&gt;if_index);</a>
<a name="ln261"> </a>
<a name="ln262">	driver_printf(&quot;%s: /dev/%s\n&quot;, gDriverName, ifp-&gt;device_name);</a>
<a name="ln263">	insert_into_device_name_list(ifp);</a>
<a name="ln264"> </a>
<a name="ln265">	ifp-&gt;root_device = find_root_device(unit);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">void</a>
<a name="ln270">ifq_init(struct ifqueue *ifq, const char *name)</a>
<a name="ln271">{</a>
<a name="ln272">	ifq-&gt;ifq_head = NULL;</a>
<a name="ln273">	ifq-&gt;ifq_tail = NULL;</a>
<a name="ln274">	ifq-&gt;ifq_len = 0;</a>
<a name="ln275">	ifq-&gt;ifq_maxlen = IFQ_MAXLEN;</a>
<a name="ln276">	ifq-&gt;ifq_drops = 0;</a>
<a name="ln277"> </a>
<a name="ln278">	mtx_init(&amp;ifq-&gt;ifq_mtx, name, NULL, MTX_DEF);</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">void</a>
<a name="ln283">ifq_uninit(struct ifqueue *ifq)</a>
<a name="ln284">{</a>
<a name="ln285">	mtx_destroy(&amp;ifq-&gt;ifq_mtx);</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288"> </a>
<a name="ln289">static int</a>
<a name="ln290">if_transmit(struct ifnet *ifp, struct mbuf *m)</a>
<a name="ln291">{</a>
<a name="ln292">	int error;</a>
<a name="ln293"> </a>
<a name="ln294">	IFQ_HANDOFF(ifp, m, error);</a>
<a name="ln295">	return (error);</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298"> </a>
<a name="ln299">static void</a>
<a name="ln300">if_input_default(struct ifnet *ifp __unused, struct mbuf *m)</a>
<a name="ln301">{</a>
<a name="ln302"> </a>
<a name="ln303">	m_freem(m);</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">/*</a>
<a name="ln308"> * Flush an interface queue.</a>
<a name="ln309"> */</a>
<a name="ln310">void</a>
<a name="ln311">if_qflush(struct ifnet *ifp)</a>
<a name="ln312">{</a>
<a name="ln313">	struct mbuf *m, *n;</a>
<a name="ln314">	struct ifaltq *ifq;</a>
<a name="ln315"> </a>
<a name="ln316">	ifq = &amp;ifp-&gt;if_snd;</a>
<a name="ln317">	IFQ_LOCK(ifq);</a>
<a name="ln318">#ifdef ALTQ</a>
<a name="ln319">	if (ALTQ_IS_ENABLED(ifq))</a>
<a name="ln320">		ALTQ_PURGE(ifq);</a>
<a name="ln321">#endif</a>
<a name="ln322">	n = ifq-&gt;ifq_head;</a>
<a name="ln323">	while ((m = n) != NULL) {</a>
<a name="ln324">		n = m-&gt;m_nextpkt;</a>
<a name="ln325">		m_freem(m);</a>
<a name="ln326">	}</a>
<a name="ln327">	ifq-&gt;ifq_head = 0;</a>
<a name="ln328">	ifq-&gt;ifq_tail = 0;</a>
<a name="ln329">	ifq-&gt;ifq_len = 0;</a>
<a name="ln330">	IFQ_UNLOCK(ifq);</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333"> </a>
<a name="ln334">void</a>
<a name="ln335">if_attach(struct ifnet *ifp)</a>
<a name="ln336">{</a>
<a name="ln337">	unsigned socksize, ifasize;</a>
<a name="ln338">	int namelen, masklen;</a>
<a name="ln339">	struct sockaddr_dl *sdl;</a>
<a name="ln340">	struct ifaddr *ifa;</a>
<a name="ln341"> </a>
<a name="ln342">	TAILQ_INIT(&amp;ifp-&gt;if_addrhead);</a>
<a name="ln343">	TAILQ_INIT(&amp;ifp-&gt;if_prefixhead);</a>
<a name="ln344">	TAILQ_INIT(&amp;ifp-&gt;if_multiaddrs);</a>
<a name="ln345"> </a>
<a name="ln346">	IF_ADDR_LOCK_INIT(ifp);</a>
<a name="ln347"> </a>
<a name="ln348">	ifp-&gt;if_lladdr.sdl_family = AF_LINK;</a>
<a name="ln349"> </a>
<a name="ln350">	ifq_init((struct ifqueue *) &amp;ifp-&gt;if_snd, ifp-&gt;if_xname);</a>
<a name="ln351"> </a>
<a name="ln352">	if (ifp-&gt;if_transmit == NULL) {</a>
<a name="ln353">		ifp-&gt;if_transmit = if_transmit;</a>
<a name="ln354">		ifp-&gt;if_qflush = if_qflush;</a>
<a name="ln355">	}</a>
<a name="ln356">	if (ifp-&gt;if_input == NULL)</a>
<a name="ln357">		ifp-&gt;if_input = if_input_default;</a>
<a name="ln358"> </a>
<a name="ln359">	if (ifp-&gt;if_requestencap == NULL)</a>
<a name="ln360">		ifp-&gt;if_requestencap = if_requestencap_default;</a>
<a name="ln361"> </a>
<a name="ln362">	/*</a>
<a name="ln363">	 * Create a Link Level name for this device.</a>
<a name="ln364">	 */</a>
<a name="ln365">	namelen = strlen(ifp-&gt;if_xname);</a>
<a name="ln366">	/*</a>
<a name="ln367">	 * Always save enough space for any possiable name so we</a>
<a name="ln368">	 * can do a rename in place later.</a>
<a name="ln369">	 */</a>
<a name="ln370">	masklen = offsetof(struct sockaddr_dl, sdl_data[0]) + IFNAMSIZ;</a>
<a name="ln371">	socksize = masklen + ifp-&gt;if_addrlen;</a>
<a name="ln372">	if (socksize &lt; sizeof(*sdl))</a>
<a name="ln373">		socksize = sizeof(*sdl);</a>
<a name="ln374">	socksize = roundup2(socksize, sizeof(long));</a>
<a name="ln375">	ifasize = sizeof(*ifa) + 2 * socksize;</a>
<a name="ln376">	ifa = ifa_alloc(ifasize, M_WAITOK);</a>
<a name="ln377">	sdl = (struct sockaddr_dl *)(ifa + 1);</a>
<a name="ln378">	sdl-&gt;sdl_len = socksize;</a>
<a name="ln379">	sdl-&gt;sdl_family = AF_LINK;</a>
<a name="ln380">	bcopy(ifp-&gt;if_xname, sdl-&gt;sdl_data, namelen);</a>
<a name="ln381">	sdl-&gt;sdl_nlen = namelen;</a>
<a name="ln382">	sdl-&gt;sdl_index = ifp-&gt;if_index;</a>
<a name="ln383">	sdl-&gt;sdl_type = ifp-&gt;if_type;</a>
<a name="ln384">	ifp-&gt;if_addr = ifa;</a>
<a name="ln385">	ifa-&gt;ifa_ifp = ifp;</a>
<a name="ln386">	//ifa-&gt;ifa_rtrequest = link_rtrequest;</a>
<a name="ln387">	ifa-&gt;ifa_addr = (struct sockaddr *)sdl;</a>
<a name="ln388">	sdl = (struct sockaddr_dl *)(socksize + (caddr_t)sdl);</a>
<a name="ln389">	ifa-&gt;ifa_netmask = (struct sockaddr *)sdl;</a>
<a name="ln390">	sdl-&gt;sdl_len = masklen;</a>
<a name="ln391">	while (namelen != 0)</a>
<a name="ln392">		sdl-&gt;sdl_data[--namelen] = 0xff;</a>
<a name="ln393">	dprintf(&quot;if_attach %p\n&quot;, ifa-&gt;ifa_addr);</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396"> </a>
<a name="ln397">void</a>
<a name="ln398">if_detach(struct ifnet *ifp)</a>
<a name="ln399">{</a>
<a name="ln400">	if (HAIKU_DRIVER_REQUIRES(FBSD_SWI_TASKQUEUE))</a>
<a name="ln401">		taskqueue_drain(taskqueue_swi, &amp;ifp-&gt;if_linktask);</a>
<a name="ln402"> </a>
<a name="ln403">	IF_ADDR_LOCK_DESTROY(ifp);</a>
<a name="ln404">	ifq_uninit((struct ifqueue *) &amp;ifp-&gt;if_snd);</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">void</a>
<a name="ln409">if_start(struct ifnet *ifp)</a>
<a name="ln410">{</a>
<a name="ln411">#ifdef IFF_NEEDSGIANT</a>
<a name="ln412">	if (ifp-&gt;if_flags &amp; IFF_NEEDSGIANT)</a>
<a name="ln413">	panic(&quot;freebsd compat.: unsupported giant requirement&quot;);</a>
<a name="ln414">#endif</a>
<a name="ln415">	ifp-&gt;if_start(ifp);</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418"> </a>
<a name="ln419">int</a>
<a name="ln420">if_printf(struct ifnet *ifp, const char *format, ...)</a>
<a name="ln421">{</a>
<a name="ln422">	char buf[256];</a>
<a name="ln423">	va_list vl;</a>
<a name="ln424">	va_start(vl, format);</a>
<a name="ln425">	vsnprintf(buf, sizeof(buf), format, vl);</a>
<a name="ln426">	va_end(vl);</a>
<a name="ln427"> </a>
<a name="ln428">	dprintf(&quot;[%s] %s&quot;, ifp-&gt;device_name, buf);</a>
<a name="ln429">	return 0;</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432"> </a>
<a name="ln433">/*</a>
<a name="ln434"> * Compat function for handling basic encapsulation requests.</a>
<a name="ln435"> * Not converted stacks (FDDI, IB, ..) supports traditional</a>
<a name="ln436"> * output model: ARP (and other similar L2 protocols) are handled</a>
<a name="ln437"> * inside output routine, arpresolve/nd6_resolve() returns MAC</a>
<a name="ln438"> * address instead of full prepend.</a>
<a name="ln439"> *</a>
<a name="ln440"> * This function creates calculated header==MAC for IPv4/IPv6 and</a>
<a name="ln441"> * returns EAFNOSUPPORT (which is then handled in ARP code) for other</a>
<a name="ln442"> * address families.</a>
<a name="ln443"> */</a>
<a name="ln444">static int</a>
<a name="ln445">if_requestencap_default(struct ifnet *ifp, struct if_encap_req *req)</a>
<a name="ln446">{</a>
<a name="ln447"> </a>
<a name="ln448">	if (req-&gt;rtype != IFENCAP_LL)</a>
<a name="ln449">		return (EOPNOTSUPP);</a>
<a name="ln450"> </a>
<a name="ln451">	if (req-&gt;bufsize &lt; req-&gt;lladdr_len)</a>
<a name="ln452">		return (ENOMEM);</a>
<a name="ln453"> </a>
<a name="ln454">	switch (req-&gt;family) {</a>
<a name="ln455">	case AF_INET:</a>
<a name="ln456">	case AF_INET6:</a>
<a name="ln457">		break;</a>
<a name="ln458">	default:</a>
<a name="ln459">		return (EAFNOSUPPORT);</a>
<a name="ln460">	}</a>
<a name="ln461"> </a>
<a name="ln462">	/* Copy lladdr to storage as is */</a>
<a name="ln463">	memmove(req-&gt;buf, req-&gt;lladdr, req-&gt;lladdr_len);</a>
<a name="ln464">	req-&gt;bufsize = req-&gt;lladdr_len;</a>
<a name="ln465">	req-&gt;lladdr_off = 0;</a>
<a name="ln466"> </a>
<a name="ln467">	return (0);</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">void</a>
<a name="ln472">if_link_state_change(struct ifnet *ifp, int linkState)</a>
<a name="ln473">{</a>
<a name="ln474">	if (ifp-&gt;if_link_state == linkState)</a>
<a name="ln475">		return;</a>
<a name="ln476"> </a>
<a name="ln477">	ifp-&gt;if_link_state = linkState;</a>
<a name="ln478">	release_sem_etc(ifp-&gt;link_state_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">static struct ifmultiaddr *</a>
<a name="ln482">if_findmulti(struct ifnet *ifp, struct sockaddr *_address)</a>
<a name="ln483">{</a>
<a name="ln484">	struct sockaddr_dl *address = (struct sockaddr_dl *) _address;</a>
<a name="ln485">	struct ifmultiaddr *ifma;</a>
<a name="ln486"> </a>
<a name="ln487">	TAILQ_FOREACH (ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln488">		if (memcmp(LLADDR(address),</a>
<a name="ln489">			LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr), ETHER_ADDR_LEN) == 0)</a>
<a name="ln490">			return ifma;</a>
<a name="ln491">	}</a>
<a name="ln492"> </a>
<a name="ln493">	return NULL;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496"> </a>
<a name="ln497">/*</a>
<a name="ln498"> * if_freemulti: free ifmultiaddr structure and possibly attached related</a>
<a name="ln499"> * addresses.  The caller is responsible for implementing reference</a>
<a name="ln500"> * counting, notifying the driver, handling routing messages, and releasing</a>
<a name="ln501"> * any dependent link layer state.</a>
<a name="ln502"> */</a>
<a name="ln503">static void</a>
<a name="ln504">if_freemulti(struct ifmultiaddr *ifma)</a>
<a name="ln505">{</a>
<a name="ln506"> </a>
<a name="ln507">	KASSERT(ifma-&gt;ifma_refcount == 0, (&quot;if_freemulti: refcount %d&quot;,</a>
<a name="ln508">	    ifma-&gt;ifma_refcount));</a>
<a name="ln509">	KASSERT(ifma-&gt;ifma_protospec == NULL,</a>
<a name="ln510">	    (&quot;if_freemulti: protospec not NULL&quot;));</a>
<a name="ln511"> </a>
<a name="ln512">	if (ifma-&gt;ifma_lladdr != NULL)</a>
<a name="ln513">		free(ifma-&gt;ifma_lladdr);</a>
<a name="ln514"> </a>
<a name="ln515">	// Haiku note: We use a field in the ifmultiaddr struct (ifma_addr_storage)</a>
<a name="ln516">	// to store the address and let ifma_addr point to that. We therefore do not</a>
<a name="ln517">	// free it here, as it will be freed as part of freeing the if_multiaddr.</a>
<a name="ln518">	//free(ifma-&gt;ifma_addr);</a>
<a name="ln519"> </a>
<a name="ln520">	free(ifma);</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523"> </a>
<a name="ln524">static struct ifmultiaddr *</a>
<a name="ln525">_if_addmulti(struct ifnet *ifp, struct sockaddr *address)</a>
<a name="ln526">{</a>
<a name="ln527">	struct ifmultiaddr *addr = if_findmulti(ifp, address);</a>
<a name="ln528"> </a>
<a name="ln529">	if (addr != NULL) {</a>
<a name="ln530">		addr-&gt;ifma_refcount++;</a>
<a name="ln531">		return addr;</a>
<a name="ln532">	}</a>
<a name="ln533"> </a>
<a name="ln534">	addr = (struct ifmultiaddr *) malloc(sizeof(struct ifmultiaddr));</a>
<a name="ln535">	if (addr == NULL)</a>
<a name="ln536">		return NULL;</a>
<a name="ln537"> </a>
<a name="ln538">	addr-&gt;ifma_lladdr = NULL;</a>
<a name="ln539">	addr-&gt;ifma_ifp = ifp;</a>
<a name="ln540">	addr-&gt;ifma_protospec = NULL;</a>
<a name="ln541"> </a>
<a name="ln542">	memcpy(&amp;addr-&gt;ifma_addr_storage, address, sizeof(struct sockaddr_dl));</a>
<a name="ln543">	addr-&gt;ifma_addr = (struct sockaddr *) &amp;addr-&gt;ifma_addr_storage;</a>
<a name="ln544"> </a>
<a name="ln545">	addr-&gt;ifma_refcount = 1;</a>
<a name="ln546"> </a>
<a name="ln547">	TAILQ_INSERT_HEAD(&amp;ifp-&gt;if_multiaddrs, addr, ifma_link);</a>
<a name="ln548"> </a>
<a name="ln549">	return addr;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552"> </a>
<a name="ln553">int</a>
<a name="ln554">if_addmulti(struct ifnet *ifp, struct sockaddr *address,</a>
<a name="ln555">	struct ifmultiaddr **out)</a>
<a name="ln556">{</a>
<a name="ln557">	struct ifmultiaddr *result;</a>
<a name="ln558">	int refcount = 0;</a>
<a name="ln559"> </a>
<a name="ln560">	IF_ADDR_LOCK(ifp);</a>
<a name="ln561">	result = _if_addmulti(ifp, address);</a>
<a name="ln562">	if (result)</a>
<a name="ln563">		refcount = result-&gt;ifma_refcount;</a>
<a name="ln564">	IF_ADDR_UNLOCK(ifp);</a>
<a name="ln565"> </a>
<a name="ln566">	if (result == NULL)</a>
<a name="ln567">		return ENOBUFS;</a>
<a name="ln568"> </a>
<a name="ln569">	if (refcount == 1 &amp;&amp; ifp-&gt;if_ioctl != NULL)</a>
<a name="ln570">		ifp-&gt;if_ioctl(ifp, SIOCADDMULTI, NULL);</a>
<a name="ln571"> </a>
<a name="ln572">	if (out)</a>
<a name="ln573">		(*out) = result;</a>
<a name="ln574"> </a>
<a name="ln575">	return 0;</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578"> </a>
<a name="ln579">static int</a>
<a name="ln580">if_delmulti_locked(struct ifnet *ifp, struct ifmultiaddr *ifma, int detaching)</a>
<a name="ln581">{</a>
<a name="ln582">	struct ifmultiaddr *ll_ifma;</a>
<a name="ln583"> </a>
<a name="ln584">	if (ifp != NULL &amp;&amp; ifma-&gt;ifma_ifp != NULL) {</a>
<a name="ln585">		KASSERT(ifma-&gt;ifma_ifp == ifp,</a>
<a name="ln586">		    (&quot;%s: inconsistent ifp %p&quot;, __func__, ifp));</a>
<a name="ln587">		IF_ADDR_LOCK_ASSERT(ifp);</a>
<a name="ln588">	}</a>
<a name="ln589"> </a>
<a name="ln590">	ifp = ifma-&gt;ifma_ifp;</a>
<a name="ln591"> </a>
<a name="ln592">	/*</a>
<a name="ln593">	 * If the ifnet is detaching, null out references to ifnet,</a>
<a name="ln594">	 * so that upper protocol layers will notice, and not attempt</a>
<a name="ln595">	 * to obtain locks for an ifnet which no longer exists. The</a>
<a name="ln596">	 * routing socket announcement must happen before the ifnet</a>
<a name="ln597">	 * instance is detached from the system.</a>
<a name="ln598">	 */</a>
<a name="ln599">	if (detaching) {</a>
<a name="ln600">#ifdef DIAGNOSTIC</a>
<a name="ln601">		printf(&quot;%s: detaching ifnet instance %p\n&quot;, __func__, ifp);</a>
<a name="ln602">#endif</a>
<a name="ln603">		/*</a>
<a name="ln604">		 * ifp may already be nulled out if we are being reentered</a>
<a name="ln605">		 * to delete the ll_ifma.</a>
<a name="ln606">		 */</a>
<a name="ln607">		if (ifp != NULL) {</a>
<a name="ln608">#ifndef __HAIKU__</a>
<a name="ln609">			rt_newmaddrmsg(RTM_DELMADDR, ifma);</a>
<a name="ln610">#endif</a>
<a name="ln611">			ifma-&gt;ifma_ifp = NULL;</a>
<a name="ln612">		}</a>
<a name="ln613">	}</a>
<a name="ln614"> </a>
<a name="ln615">	if (--ifma-&gt;ifma_refcount &gt; 0)</a>
<a name="ln616">		return 0;</a>
<a name="ln617"> </a>
<a name="ln618">#ifndef __HAIKU__</a>
<a name="ln619">	/*</a>
<a name="ln620">	 * If this ifma is a network-layer ifma, a link-layer ifma may</a>
<a name="ln621">	 * have been associated with it. Release it first if so.</a>
<a name="ln622">	 */</a>
<a name="ln623">	ll_ifma = ifma-&gt;ifma_llifma;</a>
<a name="ln624">	if (ll_ifma != NULL) {</a>
<a name="ln625">		KASSERT(ifma-&gt;ifma_lladdr != NULL,</a>
<a name="ln626">		    (&quot;%s: llifma w/o lladdr&quot;, __func__));</a>
<a name="ln627">		if (detaching)</a>
<a name="ln628">			ll_ifma-&gt;ifma_ifp = NULL;	/* XXX */</a>
<a name="ln629">		if (--ll_ifma-&gt;ifma_refcount == 0) {</a>
<a name="ln630">			if (ifp != NULL) {</a>
<a name="ln631">				TAILQ_REMOVE(&amp;ifp-&gt;if_multiaddrs, ll_ifma,</a>
<a name="ln632">				    ifma_link);</a>
<a name="ln633">			}</a>
<a name="ln634">			if_freemulti(ll_ifma);</a>
<a name="ln635">		}</a>
<a name="ln636">	}</a>
<a name="ln637">#endif</a>
<a name="ln638"> </a>
<a name="ln639">	if (ifp != NULL)</a>
<a name="ln640">		TAILQ_REMOVE(&amp;ifp-&gt;if_multiaddrs, ifma, ifma_link);</a>
<a name="ln641"> </a>
<a name="ln642">	if_freemulti(ifma);</a>
<a name="ln643"> </a>
<a name="ln644">	/*</a>
<a name="ln645">	 * The last reference to this instance of struct ifmultiaddr</a>
<a name="ln646">	 * was released; the hardware should be notified of this change.</a>
<a name="ln647">	 */</a>
<a name="ln648">	return 1;</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651"> </a>
<a name="ln652">/*</a>
<a name="ln653"> * Delete all multicast group membership for an interface.</a>
<a name="ln654"> * Should be used to quickly flush all multicast filters.</a>
<a name="ln655"> */</a>
<a name="ln656">void</a>
<a name="ln657">if_delallmulti(struct ifnet *ifp)</a>
<a name="ln658">{</a>
<a name="ln659">	struct ifmultiaddr *ifma;</a>
<a name="ln660">	struct ifmultiaddr *next;</a>
<a name="ln661"> </a>
<a name="ln662">	IF_ADDR_LOCK(ifp);</a>
<a name="ln663">	TAILQ_FOREACH_SAFE(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link, next)</a>
<a name="ln664">		if_delmulti_locked(ifp, ifma, 0);</a>
<a name="ln665">	IF_ADDR_UNLOCK(ifp);</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668"> </a>
<a name="ln669">static void</a>
<a name="ln670">if_delete_multiaddr(struct ifnet *ifp, struct ifmultiaddr *ifma)</a>
<a name="ln671">{</a>
<a name="ln672">	TAILQ_REMOVE(&amp;ifp-&gt;if_multiaddrs, ifma, ifma_link);</a>
<a name="ln673">	free(ifma);</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676"> </a>
<a name="ln677">int</a>
<a name="ln678">if_delmulti(struct ifnet *ifp, struct sockaddr *sa)</a>
<a name="ln679">{</a>
<a name="ln680">	struct ifmultiaddr *ifma;</a>
<a name="ln681">	int lastref;</a>
<a name="ln682">#if 0 /* def INVARIANTS */</a>
<a name="ln683">	struct ifnet *oifp;</a>
<a name="ln684"> </a>
<a name="ln685">	IFNET_RLOCK_NOSLEEP();</a>
<a name="ln686">	TAILQ_FOREACH(oifp, &amp;V_ifnet, if_link)</a>
<a name="ln687">		if (ifp == oifp)</a>
<a name="ln688">			break;</a>
<a name="ln689">	if (ifp != oifp)</a>
<a name="ln690">		ifp = NULL;</a>
<a name="ln691">	IFNET_RUNLOCK_NOSLEEP();</a>
<a name="ln692"> </a>
<a name="ln693">	KASSERT(ifp != NULL, (&quot;%s: ifnet went away&quot;, __func__));</a>
<a name="ln694">#endif</a>
<a name="ln695">	if (ifp == NULL)</a>
<a name="ln696">		return (ENOENT);</a>
<a name="ln697"> </a>
<a name="ln698">	IF_ADDR_LOCK(ifp);</a>
<a name="ln699">	lastref = 0;</a>
<a name="ln700">	ifma = if_findmulti(ifp, sa);</a>
<a name="ln701">	if (ifma != NULL)</a>
<a name="ln702">		lastref = if_delmulti_locked(ifp, ifma, 0);</a>
<a name="ln703">	IF_ADDR_UNLOCK(ifp);</a>
<a name="ln704"> </a>
<a name="ln705">	if (ifma == NULL)</a>
<a name="ln706">		return (ENOENT);</a>
<a name="ln707"> </a>
<a name="ln708">	if (lastref &amp;&amp; ifp-&gt;if_ioctl != NULL) {</a>
<a name="ln709">		(void)(*ifp-&gt;if_ioctl)(ifp, SIOCDELMULTI, 0);</a>
<a name="ln710">	}</a>
<a name="ln711"> </a>
<a name="ln712">	return (0);</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715"> </a>
<a name="ln716">void</a>
<a name="ln717">if_purgemaddrs(struct ifnet *ifp)</a>
<a name="ln718">{</a>
<a name="ln719">	struct ifmultiaddr *ifma;</a>
<a name="ln720">	struct ifmultiaddr *next;</a>
<a name="ln721"> </a>
<a name="ln722">	IF_ADDR_LOCK(ifp);</a>
<a name="ln723">	TAILQ_FOREACH_SAFE(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link, next)</a>
<a name="ln724">		if_delmulti_locked(ifp, ifma, 1);</a>
<a name="ln725">	IF_ADDR_UNLOCK(ifp);</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">/*</a>
<a name="ln729"> * Return counter values from counter(9)s stored in ifnet.</a>
<a name="ln730"> */</a>
<a name="ln731">uint64_t</a>
<a name="ln732">if_get_counter_default(struct ifnet *ifp, ift_counter cnt)</a>
<a name="ln733">{</a>
<a name="ln734"> </a>
<a name="ln735">	KASSERT(cnt &lt; IFCOUNTERS, (&quot;%s: invalid cnt %d&quot;, __func__, cnt));</a>
<a name="ln736"> </a>
<a name="ln737">	switch (cnt) {</a>
<a name="ln738">		case IFCOUNTER_IPACKETS:</a>
<a name="ln739">			return atomic_get64((int64 *)&amp;ifp-&gt;if_ipackets);</a>
<a name="ln740">		case IFCOUNTER_IERRORS:</a>
<a name="ln741">			return atomic_get64((int64 *)&amp;ifp-&gt;if_ierrors);</a>
<a name="ln742">		case IFCOUNTER_OPACKETS:</a>
<a name="ln743">			return atomic_get64((int64 *)&amp;ifp-&gt;if_opackets);</a>
<a name="ln744">		case IFCOUNTER_OERRORS:</a>
<a name="ln745">			return atomic_get64((int64 *)&amp;ifp-&gt;if_oerrors);</a>
<a name="ln746">		case IFCOUNTER_COLLISIONS:</a>
<a name="ln747">			return atomic_get64((int64 *)&amp;ifp-&gt;if_collisions);</a>
<a name="ln748">		case IFCOUNTER_IBYTES:</a>
<a name="ln749">			return atomic_get64((int64 *)&amp;ifp-&gt;if_ibytes);</a>
<a name="ln750">		case IFCOUNTER_OBYTES:</a>
<a name="ln751">			return atomic_get64((int64 *)&amp;ifp-&gt;if_obytes);</a>
<a name="ln752">		case IFCOUNTER_IMCASTS:</a>
<a name="ln753">			return atomic_get64((int64 *)&amp;ifp-&gt;if_imcasts);</a>
<a name="ln754">		case IFCOUNTER_OMCASTS:</a>
<a name="ln755">			return atomic_get64((int64 *)&amp;ifp-&gt;if_omcasts);</a>
<a name="ln756">		case IFCOUNTER_IQDROPS:</a>
<a name="ln757">			return atomic_get64((int64 *)&amp;ifp-&gt;if_iqdrops);</a>
<a name="ln758">		case IFCOUNTER_OQDROPS:</a>
<a name="ln759">			return atomic_get64((int64 *)&amp;ifp-&gt;if_oqdrops);</a>
<a name="ln760">		case IFCOUNTER_NOPROTO:</a>
<a name="ln761">			return atomic_get64((int64 *)&amp;ifp-&gt;if_noproto);</a>
<a name="ln762">		case IFCOUNTERS:</a>
<a name="ln763">			KASSERT(cnt &lt; IFCOUNTERS, (&quot;%s: invalid cnt %d&quot;, __func__, cnt));</a>
<a name="ln764">	}</a>
<a name="ln765">	return 0;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">void</a>
<a name="ln769">if_addr_rlock(struct ifnet *ifp)</a>
<a name="ln770">{</a>
<a name="ln771">	IF_ADDR_LOCK(ifp);</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774"> </a>
<a name="ln775">void</a>
<a name="ln776">if_addr_runlock(struct ifnet *ifp)</a>
<a name="ln777">{</a>
<a name="ln778">	IF_ADDR_UNLOCK(ifp);</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781"> </a>
<a name="ln782">void</a>
<a name="ln783">if_maddr_rlock(struct ifnet *ifp)</a>
<a name="ln784">{</a>
<a name="ln785">	IF_ADDR_LOCK(ifp);</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">void</a>
<a name="ln790">if_maddr_runlock(struct ifnet *ifp)</a>
<a name="ln791">{</a>
<a name="ln792">	IF_ADDR_UNLOCK(ifp);</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795"> </a>
<a name="ln796">int</a>
<a name="ln797">ether_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,</a>
<a name="ln798">	struct route *ro)</a>
<a name="ln799">{</a>
<a name="ln800">	int error = 0;</a>
<a name="ln801">	IFQ_HANDOFF(ifp, m, error);</a>
<a name="ln802">	return error;</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806">static void ether_input(struct ifnet *ifp, struct mbuf *m)</a>
<a name="ln807">{</a>
<a name="ln808">	IF_ENQUEUE(&amp;ifp-&gt;receive_queue, m);</a>
<a name="ln809">	release_sem_etc(ifp-&gt;receive_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813">void</a>
<a name="ln814">ether_ifattach(struct ifnet *ifp, const uint8_t *lla)</a>
<a name="ln815">{</a>
<a name="ln816">	struct ifaddr *ifa;</a>
<a name="ln817">	struct sockaddr_dl *sdl;</a>
<a name="ln818"> </a>
<a name="ln819">	ifp-&gt;if_addrlen = ETHER_ADDR_LEN;</a>
<a name="ln820">	ifp-&gt;if_hdrlen = ETHER_HDR_LEN;</a>
<a name="ln821">	if_attach(ifp);</a>
<a name="ln822">	ifp-&gt;if_mtu = ETHERMTU;</a>
<a name="ln823">	ifp-&gt;if_output = ether_output;</a>
<a name="ln824">	ifp-&gt;if_input = ether_input;</a>
<a name="ln825">	ifp-&gt;if_resolvemulti = NULL; // done in the stack</a>
<a name="ln826">	ifp-&gt;if_get_counter = NULL;</a>
<a name="ln827">	ifp-&gt;if_broadcastaddr = etherbroadcastaddr;</a>
<a name="ln828"> </a>
<a name="ln829">	ifa = ifp-&gt;if_addr;</a>
<a name="ln830">	sdl = (struct sockaddr_dl *)ifa-&gt;ifa_addr;</a>
<a name="ln831">	sdl-&gt;sdl_type = IFT_ETHER;</a>
<a name="ln832">	sdl-&gt;sdl_alen = ifp-&gt;if_addrlen;</a>
<a name="ln833">	bcopy(lla, LLADDR(sdl), ifp-&gt;if_addrlen);</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836"> </a>
<a name="ln837">void</a>
<a name="ln838">ether_ifdetach(struct ifnet *ifp)</a>
<a name="ln839">{</a>
<a name="ln840">	if_detach(ifp);</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843"> </a>
<a name="ln844">int</a>
<a name="ln845">ether_ioctl(struct ifnet *ifp, u_long command, caddr_t data)</a>
<a name="ln846">{</a>
<a name="ln847">	struct ifreq *ifr = (struct ifreq *) data;</a>
<a name="ln848"> </a>
<a name="ln849">	switch (command) {</a>
<a name="ln850">		case SIOCSIFMTU:</a>
<a name="ln851">			if (ifr-&gt;ifr_mtu &gt; ETHERMTU)</a>
<a name="ln852">				return EINVAL;</a>
<a name="ln853">			else</a>
<a name="ln854">				;</a>
<a name="ln855">			// need to fix our ifreq to work with C...</a>
<a name="ln856">			// ifp-&gt;ifr_mtu = ifr-&gt;ifr_mtu;</a>
<a name="ln857">			break;</a>
<a name="ln858"> </a>
<a name="ln859">		default:</a>
<a name="ln860">			return EINVAL;</a>
<a name="ln861">	}</a>
<a name="ln862"> </a>
<a name="ln863">	return 0;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866"> </a>
<a name="ln867">/*</a>
<a name="ln868"> * Initialization, destruction and refcounting functions for ifaddrs.</a>
<a name="ln869"> */</a>
<a name="ln870">struct ifaddr *</a>
<a name="ln871">ifa_alloc(size_t size, int flags)</a>
<a name="ln872">{</a>
<a name="ln873">	struct ifaddr *ifa;</a>
<a name="ln874"> </a>
<a name="ln875">	KASSERT(size &gt;= sizeof(struct ifaddr),</a>
<a name="ln876">	    (&quot;%s: invalid size %zu&quot;, __func__, size));</a>
<a name="ln877"> </a>
<a name="ln878">	ifa = _kernel_malloc(size, M_ZERO | flags);</a>
<a name="ln879">	if (ifa == NULL)</a>
<a name="ln880">		return (NULL);</a>
<a name="ln881"> </a>
<a name="ln882">	//refcount_init(&amp;ifa-&gt;ifa_refcnt, 1);</a>
<a name="ln883"> </a>
<a name="ln884">	return (ifa);</a>
<a name="ln885"> </a>
<a name="ln886">fail:</a>
<a name="ln887">	/* free(NULL) is okay */</a>
<a name="ln888">	free(ifa);</a>
<a name="ln889"> </a>
<a name="ln890">	return (NULL);</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">void</a>
<a name="ln894">ifa_ref(struct ifaddr *ifa)</a>
<a name="ln895">{</a>
<a name="ln896">	//refcount_acquire(&amp;ifa-&gt;ifa_refcnt);</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899">void</a>
<a name="ln900">ifa_free(struct ifaddr *ifa)</a>
<a name="ln901">{</a>
<a name="ln902"> </a>
<a name="ln903">	//if (refcount_release(&amp;ifa-&gt;ifa_refcnt)) {</a>
<a name="ln904">	//	free(ifa);</a>
<a name="ln905">	//}</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908">void</a>
<a name="ln909">if_inc_counter(struct ifnet *ifp, ift_counter cnt, int64_t inc)</a>
<a name="ln910">{</a>
<a name="ln911">	switch (cnt) {</a>
<a name="ln912">		case IFCOUNTER_IPACKETS:</a>
<a name="ln913">			atomic_add64((int64 *)&amp;ifp-&gt;if_ipackets, inc);</a>
<a name="ln914">			break;</a>
<a name="ln915">		case IFCOUNTER_IERRORS:</a>
<a name="ln916">			atomic_add64((int64 *)&amp;ifp-&gt;if_ierrors, inc);</a>
<a name="ln917">			break;</a>
<a name="ln918">		case IFCOUNTER_OPACKETS:</a>
<a name="ln919">			atomic_add64((int64 *)&amp;ifp-&gt;if_opackets, inc);</a>
<a name="ln920">			break;</a>
<a name="ln921">		case IFCOUNTER_OERRORS:</a>
<a name="ln922">			atomic_add64((int64 *)&amp;ifp-&gt;if_oerrors, inc);</a>
<a name="ln923">			break;</a>
<a name="ln924">		case IFCOUNTER_COLLISIONS:</a>
<a name="ln925">			atomic_add64((int64 *)&amp;ifp-&gt;if_collisions, inc);</a>
<a name="ln926">			break;</a>
<a name="ln927">		case IFCOUNTER_IBYTES:</a>
<a name="ln928">			atomic_add64((int64 *)&amp;ifp-&gt;if_ibytes, inc);</a>
<a name="ln929">			break;</a>
<a name="ln930">		case IFCOUNTER_OBYTES:</a>
<a name="ln931">			atomic_add64((int64 *)&amp;ifp-&gt;if_obytes, inc);</a>
<a name="ln932">			break;</a>
<a name="ln933">		case IFCOUNTER_IMCASTS:</a>
<a name="ln934">			atomic_add64((int64 *)&amp;ifp-&gt;if_imcasts, inc);</a>
<a name="ln935">			break;</a>
<a name="ln936">		case IFCOUNTER_OMCASTS:</a>
<a name="ln937">			atomic_add64((int64 *)&amp;ifp-&gt;if_omcasts, inc);</a>
<a name="ln938">			break;</a>
<a name="ln939">		case IFCOUNTER_IQDROPS:</a>
<a name="ln940">			atomic_add64((int64 *)&amp;ifp-&gt;if_iqdrops, inc);</a>
<a name="ln941">			break;</a>
<a name="ln942">		case IFCOUNTER_OQDROPS:</a>
<a name="ln943">			atomic_add64((int64 *)&amp;ifp-&gt;if_oqdrops, inc);</a>
<a name="ln944">			break;</a>
<a name="ln945">		case IFCOUNTER_NOPROTO:</a>
<a name="ln946">			atomic_add64((int64 *)&amp;ifp-&gt;if_noproto, inc);</a>
<a name="ln947">			break;</a>
<a name="ln948">		case IFCOUNTERS:</a>
<a name="ln949">			KASSERT(cnt &lt; IFCOUNTERS, (&quot;%s: invalid cnt %d&quot;, __func__, cnt));</a>
<a name="ln950">	}</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">/* API for driver access to network stack owned ifnet.*/</a>
<a name="ln955">uint64_t</a>
<a name="ln956">if_setbaudrate(struct ifnet *ifp, uint64_t baudrate)</a>
<a name="ln957">{</a>
<a name="ln958">	uint64_t oldbrate;</a>
<a name="ln959"> </a>
<a name="ln960">	oldbrate = ifp-&gt;if_baudrate;</a>
<a name="ln961">	ifp-&gt;if_baudrate = baudrate;</a>
<a name="ln962">	return (oldbrate);</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965">uint64_t</a>
<a name="ln966">if_getbaudrate(if_t ifp)</a>
<a name="ln967">{</a>
<a name="ln968"> </a>
<a name="ln969">	return (((struct ifnet *)ifp)-&gt;if_baudrate);</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972">int</a>
<a name="ln973">if_setcapabilities(if_t ifp, int capabilities)</a>
<a name="ln974">{</a>
<a name="ln975">	((struct ifnet *)ifp)-&gt;if_capabilities = capabilities;</a>
<a name="ln976">	return (0);</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979">int</a>
<a name="ln980">if_setcapabilitiesbit(if_t ifp, int setbit, int clearbit)</a>
<a name="ln981">{</a>
<a name="ln982">	((struct ifnet *)ifp)-&gt;if_capabilities |= setbit;</a>
<a name="ln983">	((struct ifnet *)ifp)-&gt;if_capabilities &amp;= ~clearbit;</a>
<a name="ln984"> </a>
<a name="ln985">	return (0);</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">int</a>
<a name="ln989">if_getcapabilities(if_t ifp)</a>
<a name="ln990">{</a>
<a name="ln991">	return ((struct ifnet *)ifp)-&gt;if_capabilities;</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994">int</a>
<a name="ln995">if_setcapenable(if_t ifp, int capabilities)</a>
<a name="ln996">{</a>
<a name="ln997">	((struct ifnet *)ifp)-&gt;if_capenable = capabilities;</a>
<a name="ln998">	return (0);</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001">int</a>
<a name="ln1002">if_setcapenablebit(if_t ifp, int setcap, int clearcap)</a>
<a name="ln1003">{</a>
<a name="ln1004">	if(setcap)</a>
<a name="ln1005">		((struct ifnet *)ifp)-&gt;if_capenable |= setcap;</a>
<a name="ln1006">	if(clearcap)</a>
<a name="ln1007">		((struct ifnet *)ifp)-&gt;if_capenable &amp;= ~clearcap;</a>
<a name="ln1008"> </a>
<a name="ln1009">	return (0);</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">const char *</a>
<a name="ln1013">if_getdname(if_t ifp)</a>
<a name="ln1014">{</a>
<a name="ln1015">	return ((struct ifnet *)ifp)-&gt;if_dname;</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018">int</a>
<a name="ln1019">if_togglecapenable(if_t ifp, int togglecap)</a>
<a name="ln1020">{</a>
<a name="ln1021">	((struct ifnet *)ifp)-&gt;if_capenable ^= togglecap;</a>
<a name="ln1022">	return (0);</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">int</a>
<a name="ln1026">if_getcapenable(if_t ifp)</a>
<a name="ln1027">{</a>
<a name="ln1028">	return ((struct ifnet *)ifp)-&gt;if_capenable;</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">/*</a>
<a name="ln1032"> * This is largely undesirable because it ties ifnet to a device, but does</a>
<a name="ln1033"> * provide flexiblity for an embedded product vendor. Should be used with</a>
<a name="ln1034"> * the understanding that it violates the interface boundaries, and should be</a>
<a name="ln1035"> * a last resort only.</a>
<a name="ln1036"> */</a>
<a name="ln1037">int</a>
<a name="ln1038">if_setdev(if_t ifp, void *dev)</a>
<a name="ln1039">{</a>
<a name="ln1040">	return (0);</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">int</a>
<a name="ln1044">if_setdrvflagbits(if_t ifp, int set_flags, int clear_flags)</a>
<a name="ln1045">{</a>
<a name="ln1046">	((struct ifnet *)ifp)-&gt;if_drv_flags |= set_flags;</a>
<a name="ln1047">	((struct ifnet *)ifp)-&gt;if_drv_flags &amp;= ~clear_flags;</a>
<a name="ln1048"> </a>
<a name="ln1049">	return (0);</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">int</a>
<a name="ln1053">if_getdrvflags(if_t ifp)</a>
<a name="ln1054">{</a>
<a name="ln1055">	if ((struct ifnet *)ifp == NULL)</a>
<a name="ln1056">		return 0;</a>
<a name="ln1057">	return ((struct ifnet *)ifp)-&gt;if_drv_flags;</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">int</a>
<a name="ln1061">if_setdrvflags(if_t ifp, int flags)</a>
<a name="ln1062">{</a>
<a name="ln1063">	((struct ifnet *)ifp)-&gt;if_drv_flags = flags;</a>
<a name="ln1064">	return (0);</a>
<a name="ln1065">}</a>
<a name="ln1066"> </a>
<a name="ln1067"> </a>
<a name="ln1068">int</a>
<a name="ln1069">if_setflags(if_t ifp, int flags)</a>
<a name="ln1070">{</a>
<a name="ln1071">	((struct ifnet *)ifp)-&gt;if_flags = flags;</a>
<a name="ln1072">	return (0);</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">int</a>
<a name="ln1076">if_setflagbits(if_t ifp, int set, int clear)</a>
<a name="ln1077">{</a>
<a name="ln1078">	((struct ifnet *)ifp)-&gt;if_flags |= set;</a>
<a name="ln1079">	((struct ifnet *)ifp)-&gt;if_flags &amp;= ~clear;</a>
<a name="ln1080"> </a>
<a name="ln1081">	return (0);</a>
<a name="ln1082">}</a>
<a name="ln1083"> </a>
<a name="ln1084">int</a>
<a name="ln1085">if_getflags(if_t ifp)</a>
<a name="ln1086">{</a>
<a name="ln1087">	return ((struct ifnet *)ifp)-&gt;if_flags;</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090">int</a>
<a name="ln1091">if_clearhwassist(if_t ifp)</a>
<a name="ln1092">{</a>
<a name="ln1093">	((struct ifnet *)ifp)-&gt;if_hwassist = 0;</a>
<a name="ln1094">	return (0);</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">int</a>
<a name="ln1098">if_sethwassistbits(if_t ifp, int toset, int toclear)</a>
<a name="ln1099">{</a>
<a name="ln1100">	((struct ifnet *)ifp)-&gt;if_hwassist |= toset;</a>
<a name="ln1101">	((struct ifnet *)ifp)-&gt;if_hwassist &amp;= ~toclear;</a>
<a name="ln1102"> </a>
<a name="ln1103">	return (0);</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106">int</a>
<a name="ln1107">if_sethwassist(if_t ifp, int hwassist_bit)</a>
<a name="ln1108">{</a>
<a name="ln1109">	((struct ifnet *)ifp)-&gt;if_hwassist = hwassist_bit;</a>
<a name="ln1110">	return (0);</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">int</a>
<a name="ln1114">if_gethwassist(if_t ifp)</a>
<a name="ln1115">{</a>
<a name="ln1116">	return ((struct ifnet *)ifp)-&gt;if_hwassist;</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119">int</a>
<a name="ln1120">if_setmtu(if_t ifp, int mtu)</a>
<a name="ln1121">{</a>
<a name="ln1122">	((struct ifnet *)ifp)-&gt;if_mtu = mtu;</a>
<a name="ln1123">	return (0);</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">int</a>
<a name="ln1127">if_getmtu(if_t ifp)</a>
<a name="ln1128">{</a>
<a name="ln1129">	return ((struct ifnet *)ifp)-&gt;if_mtu;</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132">int</a>
<a name="ln1133">if_setsoftc(if_t ifp, void *softc)</a>
<a name="ln1134">{</a>
<a name="ln1135">	((struct ifnet *)ifp)-&gt;if_softc = softc;</a>
<a name="ln1136">	return (0);</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139">void *</a>
<a name="ln1140">if_getsoftc(if_t ifp)</a>
<a name="ln1141">{</a>
<a name="ln1142">	return ((struct ifnet *)ifp)-&gt;if_softc;</a>
<a name="ln1143">}</a>
<a name="ln1144"> </a>
<a name="ln1145">void</a>
<a name="ln1146">if_setrcvif(struct mbuf *m, if_t ifp)</a>
<a name="ln1147">{</a>
<a name="ln1148">	m-&gt;m_pkthdr.rcvif = (struct ifnet *)ifp;</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">void</a>
<a name="ln1152">if_setvtag(struct mbuf *m, uint16_t tag)</a>
<a name="ln1153">{</a>
<a name="ln1154">	m-&gt;m_pkthdr.ether_vtag = tag;</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">uint16_t</a>
<a name="ln1158">if_getvtag(struct mbuf *m)</a>
<a name="ln1159">{</a>
<a name="ln1160"> </a>
<a name="ln1161">	return (m-&gt;m_pkthdr.ether_vtag);</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">int</a>
<a name="ln1165">if_sendq_empty(if_t ifp)</a>
<a name="ln1166">{</a>
<a name="ln1167">	return IFQ_DRV_IS_EMPTY(&amp;((struct ifnet *)ifp)-&gt;if_snd);</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170">int</a>
<a name="ln1171">if_getamcount(if_t ifp)</a>
<a name="ln1172">{</a>
<a name="ln1173">	return ((struct ifnet *)ifp)-&gt;if_amcount;</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176"> </a>
<a name="ln1177">int</a>
<a name="ln1178">if_setsendqready(if_t ifp)</a>
<a name="ln1179">{</a>
<a name="ln1180">	IFQ_SET_READY(&amp;((struct ifnet *)ifp)-&gt;if_snd);</a>
<a name="ln1181">	return (0);</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">int</a>
<a name="ln1185">if_setsendqlen(if_t ifp, int tx_desc_count)</a>
<a name="ln1186">{</a>
<a name="ln1187">	IFQ_SET_MAXLEN(&amp;((struct ifnet *)ifp)-&gt;if_snd, tx_desc_count);</a>
<a name="ln1188">	((struct ifnet *)ifp)-&gt;if_snd.ifq_drv_maxlen = tx_desc_count;</a>
<a name="ln1189"> </a>
<a name="ln1190">	return (0);</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">int</a>
<a name="ln1194">if_vlantrunkinuse(if_t ifp)</a>
<a name="ln1195">{</a>
<a name="ln1196">	return ((struct ifnet *)ifp)-&gt;if_vlantrunk != NULL?1:0;</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199">int</a>
<a name="ln1200">if_input(if_t ifp, struct mbuf* sendmp)</a>
<a name="ln1201">{</a>
<a name="ln1202">	(*((struct ifnet *)ifp)-&gt;if_input)((struct ifnet *)ifp, sendmp);</a>
<a name="ln1203">	return (0);</a>
<a name="ln1204"> </a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207">/* XXX */</a>
<a name="ln1208">#ifndef ETH_ADDR_LEN</a>
<a name="ln1209">#define ETH_ADDR_LEN 6</a>
<a name="ln1210">#endif</a>
<a name="ln1211"> </a>
<a name="ln1212">int</a>
<a name="ln1213">if_setupmultiaddr(if_t ifp, void *mta, int *cnt, int max)</a>
<a name="ln1214">{</a>
<a name="ln1215">	struct ifmultiaddr *ifma;</a>
<a name="ln1216">	uint8_t *lmta = (uint8_t *)mta;</a>
<a name="ln1217">	int mcnt = 0;</a>
<a name="ln1218"> </a>
<a name="ln1219">	TAILQ_FOREACH(ifma, &amp;((struct ifnet *)ifp)-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1220">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1221">			continue;</a>
<a name="ln1222"> </a>
<a name="ln1223">		if (mcnt == max)</a>
<a name="ln1224">			break;</a>
<a name="ln1225"> </a>
<a name="ln1226">		bcopy(LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr),</a>
<a name="ln1227">		    &amp;lmta[mcnt * ETH_ADDR_LEN], ETH_ADDR_LEN);</a>
<a name="ln1228">		mcnt++;</a>
<a name="ln1229">	}</a>
<a name="ln1230">	*cnt = mcnt;</a>
<a name="ln1231"> </a>
<a name="ln1232">	return (0);</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">int</a>
<a name="ln1236">if_multiaddr_array(if_t ifp, void *mta, int *cnt, int max)</a>
<a name="ln1237">{</a>
<a name="ln1238">	int error;</a>
<a name="ln1239"> </a>
<a name="ln1240">	if_maddr_rlock(ifp);</a>
<a name="ln1241">	error = if_setupmultiaddr(ifp, mta, cnt, max);</a>
<a name="ln1242">	if_maddr_runlock(ifp);</a>
<a name="ln1243">	return (error);</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246">int</a>
<a name="ln1247">if_multiaddr_count(if_t ifp, int max)</a>
<a name="ln1248">{</a>
<a name="ln1249">	struct ifmultiaddr *ifma;</a>
<a name="ln1250">	int count;</a>
<a name="ln1251"> </a>
<a name="ln1252">	count = 0;</a>
<a name="ln1253">	if_maddr_rlock(ifp);</a>
<a name="ln1254">	TAILQ_FOREACH(ifma, &amp;((struct ifnet *)ifp)-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1255">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1256">			continue;</a>
<a name="ln1257">		count++;</a>
<a name="ln1258">		if (count == max)</a>
<a name="ln1259">			break;</a>
<a name="ln1260">	}</a>
<a name="ln1261">	if_maddr_runlock(ifp);</a>
<a name="ln1262">	return (count);</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">struct mbuf *</a>
<a name="ln1266">if_dequeue(if_t ifp)</a>
<a name="ln1267">{</a>
<a name="ln1268">	struct mbuf *m;</a>
<a name="ln1269">	IFQ_DRV_DEQUEUE(&amp;((struct ifnet *)ifp)-&gt;if_snd, m);</a>
<a name="ln1270"> </a>
<a name="ln1271">	return (m);</a>
<a name="ln1272">}</a>
<a name="ln1273"> </a>
<a name="ln1274">int</a>
<a name="ln1275">if_sendq_prepend(if_t ifp, struct mbuf *m)</a>
<a name="ln1276">{</a>
<a name="ln1277">	IFQ_DRV_PREPEND(&amp;((struct ifnet *)ifp)-&gt;if_snd, m);</a>
<a name="ln1278">	return (0);</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281">int</a>
<a name="ln1282">if_setifheaderlen(if_t ifp, int len)</a>
<a name="ln1283">{</a>
<a name="ln1284">	((struct ifnet *)ifp)-&gt;if_hdrlen = len;</a>
<a name="ln1285">	return (0);</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">caddr_t</a>
<a name="ln1289">if_getlladdr(if_t ifp)</a>
<a name="ln1290">{</a>
<a name="ln1291">	return (IF_LLADDR((struct ifnet *)ifp));</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">void *</a>
<a name="ln1295">if_gethandle(u_char type)</a>
<a name="ln1296">{</a>
<a name="ln1297">	return (if_alloc(type));</a>
<a name="ln1298">}</a>
<a name="ln1299"> </a>
<a name="ln1300">void</a>
<a name="ln1301">if_bpfmtap(if_t ifh, struct mbuf *m)</a>
<a name="ln1302">{</a>
<a name="ln1303">	struct ifnet *ifp = (struct ifnet *)ifh;</a>
<a name="ln1304"> </a>
<a name="ln1305">	BPF_MTAP(ifp, m);</a>
<a name="ln1306">}</a>
<a name="ln1307"> </a>
<a name="ln1308">void</a>
<a name="ln1309">if_etherbpfmtap(if_t ifh, struct mbuf *m)</a>
<a name="ln1310">{</a>
<a name="ln1311">	struct ifnet *ifp = (struct ifnet *)ifh;</a>
<a name="ln1312"> </a>
<a name="ln1313">	ETHER_BPF_MTAP(ifp, m);</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">void</a>
<a name="ln1317">if_vlancap(if_t ifh)</a>
<a name="ln1318">{</a>
<a name="ln1319">	struct ifnet *ifp = (struct ifnet *)ifh;</a>
<a name="ln1320">	VLAN_CAPABILITIES(ifp);</a>
<a name="ln1321">}</a>
<a name="ln1322"> </a>
<a name="ln1323">void</a>
<a name="ln1324">if_setinitfn(if_t ifp, void (*init_fn)(void *))</a>
<a name="ln1325">{</a>
<a name="ln1326">	((struct ifnet *)ifp)-&gt;if_init = init_fn;</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">void</a>
<a name="ln1330">if_setioctlfn(if_t ifp, int (*ioctl_fn)(if_t, u_long, caddr_t))</a>
<a name="ln1331">{</a>
<a name="ln1332">	((struct ifnet *)ifp)-&gt;if_ioctl = (void *)ioctl_fn;</a>
<a name="ln1333">}</a>
<a name="ln1334"> </a>
<a name="ln1335">void</a>
<a name="ln1336">if_setstartfn(if_t ifp, void (*start_fn)(if_t))</a>
<a name="ln1337">{</a>
<a name="ln1338">	((struct ifnet *)ifp)-&gt;if_start = (void *)start_fn;</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">void</a>
<a name="ln1342">if_settransmitfn(if_t ifp, if_transmit_fn_t start_fn)</a>
<a name="ln1343">{</a>
<a name="ln1344">	((struct ifnet *)ifp)-&gt;if_transmit = start_fn;</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">void if_setqflushfn(if_t ifp, if_qflush_fn_t flush_fn)</a>
<a name="ln1348">{</a>
<a name="ln1349">	((struct ifnet *)ifp)-&gt;if_qflush = flush_fn;</a>
<a name="ln1350">}</a>
<a name="ln1351"> </a>
<a name="ln1352">void</a>
<a name="ln1353">if_setgetcounterfn(if_t ifp, if_get_counter_t fn)</a>
<a name="ln1354">{</a>
<a name="ln1355"> </a>
<a name="ln1356">	ifp-&gt;if_get_counter = fn;</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>

</code></pre>
<div class="balloon" rel="1101"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v784/" target="_blank">V784</a> The size of the bit mask is less than the size of the first operand. This will cause the loss of higher bits.</p></div>
<div class="balloon" rel="542"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to the 'address' buffer becoming out of range.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
