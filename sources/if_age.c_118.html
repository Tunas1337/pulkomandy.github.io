
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_age.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2008, Pyun YongHyeon &lt;yongari@FreeBSD.org&gt;</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice unmodified, this list of conditions, and the following</a>
<a name="ln12"> *    disclaimer.</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln15"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln16"> *</a>
<a name="ln17"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln18"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln19"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln20"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln21"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln22"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln23"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln24"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln25"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln26"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln27"> * SUCH DAMAGE.</a>
<a name="ln28"> */</a>
<a name="ln29"> </a>
<a name="ln30">/* Driver for Attansic Technology Corp. L1 Gigabit Ethernet. */</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln33">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/age/if_age.c 338948 2018-09-26 17:12:14Z imp $&quot;);</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;sys/param.h&gt;</a>
<a name="ln36">#include &lt;sys/systm.h&gt;</a>
<a name="ln37">#include &lt;sys/bus.h&gt;</a>
<a name="ln38">#include &lt;sys/endian.h&gt;</a>
<a name="ln39">#include &lt;sys/kernel.h&gt;</a>
<a name="ln40">#include &lt;sys/malloc.h&gt;</a>
<a name="ln41">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln42">#include &lt;sys/rman.h&gt;</a>
<a name="ln43">#include &lt;sys/module.h&gt;</a>
<a name="ln44">#include &lt;sys/queue.h&gt;</a>
<a name="ln45">#include &lt;sys/socket.h&gt;</a>
<a name="ln46">#include &lt;sys/sockio.h&gt;</a>
<a name="ln47">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln48">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;net/bpf.h&gt;</a>
<a name="ln51">#include &lt;net/if.h&gt;</a>
<a name="ln52">#include &lt;net/if_var.h&gt;</a>
<a name="ln53">#include &lt;net/if_arp.h&gt;</a>
<a name="ln54">#include &lt;net/ethernet.h&gt;</a>
<a name="ln55">#include &lt;net/if_dl.h&gt;</a>
<a name="ln56">#include &lt;net/if_media.h&gt;</a>
<a name="ln57">#include &lt;net/if_types.h&gt;</a>
<a name="ln58">#include &lt;net/if_vlan_var.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;netinet/in.h&gt;</a>
<a name="ln61">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln62">#include &lt;netinet/ip.h&gt;</a>
<a name="ln63">#include &lt;netinet/tcp.h&gt;</a>
<a name="ln64"> </a>
<a name="ln65">#include &lt;dev/mii/mii.h&gt;</a>
<a name="ln66">#include &lt;dev/mii/miivar.h&gt;</a>
<a name="ln67"> </a>
<a name="ln68">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln69">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln70"> </a>
<a name="ln71">#include &lt;machine/bus.h&gt;</a>
<a name="ln72">#include &lt;machine/in_cksum.h&gt;</a>
<a name="ln73"> </a>
<a name="ln74">#include &lt;dev/age/if_agereg.h&gt;</a>
<a name="ln75">#include &lt;dev/age/if_agevar.h&gt;</a>
<a name="ln76"> </a>
<a name="ln77">/* &quot;device miibus&quot; required.  See GENERIC if you get errors here. */</a>
<a name="ln78">#include &quot;miibus_if.h&quot;</a>
<a name="ln79"> </a>
<a name="ln80">#define	AGE_CSUM_FEATURES	(CSUM_TCP | CSUM_UDP)</a>
<a name="ln81"> </a>
<a name="ln82">MODULE_DEPEND(age, pci, 1, 1, 1);</a>
<a name="ln83">MODULE_DEPEND(age, ether, 1, 1, 1);</a>
<a name="ln84">MODULE_DEPEND(age, miibus, 1, 1, 1);</a>
<a name="ln85"> </a>
<a name="ln86">/* Tunables. */</a>
<a name="ln87">static int msi_disable = 0;</a>
<a name="ln88">static int msix_disable = 0;</a>
<a name="ln89">TUNABLE_INT(&quot;hw.age.msi_disable&quot;, &amp;msi_disable);</a>
<a name="ln90">TUNABLE_INT(&quot;hw.age.msix_disable&quot;, &amp;msix_disable);</a>
<a name="ln91"> </a>
<a name="ln92">/*</a>
<a name="ln93"> * Devices supported by this driver.</a>
<a name="ln94"> */</a>
<a name="ln95">static struct age_dev {</a>
<a name="ln96">	uint16_t	age_vendorid;</a>
<a name="ln97">	uint16_t	age_deviceid;</a>
<a name="ln98">	const char	*age_name;</a>
<a name="ln99">} age_devs[] = {</a>
<a name="ln100">	{ VENDORID_ATTANSIC, DEVICEID_ATTANSIC_L1,</a>
<a name="ln101">	    &quot;Attansic Technology Corp, L1 Gigabit Ethernet&quot; },</a>
<a name="ln102">};</a>
<a name="ln103"> </a>
<a name="ln104">static int age_miibus_readreg(device_t, int, int);</a>
<a name="ln105">static int age_miibus_writereg(device_t, int, int, int);</a>
<a name="ln106">static void age_miibus_statchg(device_t);</a>
<a name="ln107">static void age_mediastatus(struct ifnet *, struct ifmediareq *);</a>
<a name="ln108">static int age_mediachange(struct ifnet *);</a>
<a name="ln109">static int age_probe(device_t);</a>
<a name="ln110">static void age_get_macaddr(struct age_softc *);</a>
<a name="ln111">static void age_phy_reset(struct age_softc *);</a>
<a name="ln112">static int age_attach(device_t);</a>
<a name="ln113">static int age_detach(device_t);</a>
<a name="ln114">static void age_sysctl_node(struct age_softc *);</a>
<a name="ln115">static void age_dmamap_cb(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln116">static int age_check_boundary(struct age_softc *);</a>
<a name="ln117">static int age_dma_alloc(struct age_softc *);</a>
<a name="ln118">static void age_dma_free(struct age_softc *);</a>
<a name="ln119">static int age_shutdown(device_t);</a>
<a name="ln120">static void age_setwol(struct age_softc *);</a>
<a name="ln121">static int age_suspend(device_t);</a>
<a name="ln122">static int age_resume(device_t);</a>
<a name="ln123">static int age_encap(struct age_softc *, struct mbuf **);</a>
<a name="ln124">static void age_start(struct ifnet *);</a>
<a name="ln125">static void age_start_locked(struct ifnet *);</a>
<a name="ln126">static void age_watchdog(struct age_softc *);</a>
<a name="ln127">static int age_ioctl(struct ifnet *, u_long, caddr_t);</a>
<a name="ln128">static void age_mac_config(struct age_softc *);</a>
<a name="ln129">static void age_link_task(void *, int);</a>
<a name="ln130">static void age_stats_update(struct age_softc *);</a>
<a name="ln131">static int age_intr(void *);</a>
<a name="ln132">static void age_int_task(void *, int);</a>
<a name="ln133">static void age_txintr(struct age_softc *, int);</a>
<a name="ln134">static void age_rxeof(struct age_softc *sc, struct rx_rdesc *);</a>
<a name="ln135">static int age_rxintr(struct age_softc *, int, int);</a>
<a name="ln136">static void age_tick(void *);</a>
<a name="ln137">static void age_reset(struct age_softc *);</a>
<a name="ln138">static void age_init(void *);</a>
<a name="ln139">static void age_init_locked(struct age_softc *);</a>
<a name="ln140">static void age_stop(struct age_softc *);</a>
<a name="ln141">static void age_stop_txmac(struct age_softc *);</a>
<a name="ln142">static void age_stop_rxmac(struct age_softc *);</a>
<a name="ln143">static void age_init_tx_ring(struct age_softc *);</a>
<a name="ln144">static int age_init_rx_ring(struct age_softc *);</a>
<a name="ln145">static void age_init_rr_ring(struct age_softc *);</a>
<a name="ln146">static void age_init_cmb_block(struct age_softc *);</a>
<a name="ln147">static void age_init_smb_block(struct age_softc *);</a>
<a name="ln148">#ifndef __NO_STRICT_ALIGNMENT</a>
<a name="ln149">static struct mbuf *age_fixup_rx(struct ifnet *, struct mbuf *);</a>
<a name="ln150">#endif</a>
<a name="ln151">static int age_newbuf(struct age_softc *, struct age_rxdesc *);</a>
<a name="ln152">static void age_rxvlan(struct age_softc *);</a>
<a name="ln153">static void age_rxfilter(struct age_softc *);</a>
<a name="ln154">static int sysctl_age_stats(SYSCTL_HANDLER_ARGS);</a>
<a name="ln155">static int sysctl_int_range(SYSCTL_HANDLER_ARGS, int, int);</a>
<a name="ln156">static int sysctl_hw_age_proc_limit(SYSCTL_HANDLER_ARGS);</a>
<a name="ln157">static int sysctl_hw_age_int_mod(SYSCTL_HANDLER_ARGS);</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">static device_method_t age_methods[] = {</a>
<a name="ln161">	/* Device interface. */</a>
<a name="ln162">	DEVMETHOD(device_probe,		age_probe),</a>
<a name="ln163">	DEVMETHOD(device_attach,	age_attach),</a>
<a name="ln164">	DEVMETHOD(device_detach,	age_detach),</a>
<a name="ln165">	DEVMETHOD(device_shutdown,	age_shutdown),</a>
<a name="ln166">	DEVMETHOD(device_suspend,	age_suspend),</a>
<a name="ln167">	DEVMETHOD(device_resume,	age_resume),</a>
<a name="ln168"> </a>
<a name="ln169">	/* MII interface. */</a>
<a name="ln170">	DEVMETHOD(miibus_readreg,	age_miibus_readreg),</a>
<a name="ln171">	DEVMETHOD(miibus_writereg,	age_miibus_writereg),</a>
<a name="ln172">	DEVMETHOD(miibus_statchg,	age_miibus_statchg),</a>
<a name="ln173"> </a>
<a name="ln174">	{ NULL, NULL }</a>
<a name="ln175">};</a>
<a name="ln176"> </a>
<a name="ln177">static driver_t age_driver = {</a>
<a name="ln178">	&quot;age&quot;,</a>
<a name="ln179">	age_methods,</a>
<a name="ln180">	sizeof(struct age_softc)</a>
<a name="ln181">};</a>
<a name="ln182"> </a>
<a name="ln183">static devclass_t age_devclass;</a>
<a name="ln184"> </a>
<a name="ln185">DRIVER_MODULE(age, pci, age_driver, age_devclass, 0, 0);</a>
<a name="ln186">MODULE_PNP_INFO(&quot;U16:vendor;U16:device;D:#&quot;, pci, age, age_devs,</a>
<a name="ln187">    nitems(age_devs));</a>
<a name="ln188">DRIVER_MODULE(miibus, age, miibus_driver, miibus_devclass, 0, 0);</a>
<a name="ln189"> </a>
<a name="ln190">static struct resource_spec age_res_spec_mem[] = {</a>
<a name="ln191">	{ SYS_RES_MEMORY,	PCIR_BAR(0),	RF_ACTIVE },</a>
<a name="ln192">	{ -1,			0,		0 }</a>
<a name="ln193">};</a>
<a name="ln194"> </a>
<a name="ln195">static struct resource_spec age_irq_spec_legacy[] = {</a>
<a name="ln196">	{ SYS_RES_IRQ,		0,		RF_ACTIVE | RF_SHAREABLE },</a>
<a name="ln197">	{ -1,			0,		0 }</a>
<a name="ln198">};</a>
<a name="ln199"> </a>
<a name="ln200">static struct resource_spec age_irq_spec_msi[] = {</a>
<a name="ln201">	{ SYS_RES_IRQ,		1,		RF_ACTIVE },</a>
<a name="ln202">	{ -1,			0,		0 }</a>
<a name="ln203">};</a>
<a name="ln204"> </a>
<a name="ln205">static struct resource_spec age_irq_spec_msix[] = {</a>
<a name="ln206">	{ SYS_RES_IRQ,		1,		RF_ACTIVE },</a>
<a name="ln207">	{ -1,			0,		0 }</a>
<a name="ln208">};</a>
<a name="ln209"> </a>
<a name="ln210">/*</a>
<a name="ln211"> *	Read a PHY register on the MII of the L1.</a>
<a name="ln212"> */</a>
<a name="ln213">static int</a>
<a name="ln214">age_miibus_readreg(device_t dev, int phy, int reg)</a>
<a name="ln215">{</a>
<a name="ln216">	struct age_softc *sc;</a>
<a name="ln217">	uint32_t v;</a>
<a name="ln218">	int i;</a>
<a name="ln219"> </a>
<a name="ln220">	sc = device_get_softc(dev);</a>
<a name="ln221"> </a>
<a name="ln222">	CSR_WRITE_4(sc, AGE_MDIO, MDIO_OP_EXECUTE | MDIO_OP_READ |</a>
<a name="ln223">	    MDIO_SUP_PREAMBLE | MDIO_CLK_25_4 | MDIO_REG_ADDR(reg));</a>
<a name="ln224">	for (i = AGE_PHY_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln225">		DELAY(1);</a>
<a name="ln226">		v = CSR_READ_4(sc, AGE_MDIO);</a>
<a name="ln227">		if ((v &amp; (MDIO_OP_EXECUTE | MDIO_OP_BUSY)) == 0)</a>
<a name="ln228">			break;</a>
<a name="ln229">	}</a>
<a name="ln230"> </a>
<a name="ln231">	if (i == 0) {</a>
<a name="ln232">		device_printf(sc-&gt;age_dev, &quot;phy read timeout : %d\n&quot;, reg);</a>
<a name="ln233">		return (0);</a>
<a name="ln234">	}</a>
<a name="ln235"> </a>
<a name="ln236">	return ((v &amp; MDIO_DATA_MASK) &gt;&gt; MDIO_DATA_SHIFT);</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">/*</a>
<a name="ln240"> *	Write a PHY register on the MII of the L1.</a>
<a name="ln241"> */</a>
<a name="ln242">static int</a>
<a name="ln243">age_miibus_writereg(device_t dev, int phy, int reg, int val)</a>
<a name="ln244">{</a>
<a name="ln245">	struct age_softc *sc;</a>
<a name="ln246">	uint32_t v;</a>
<a name="ln247">	int i;</a>
<a name="ln248"> </a>
<a name="ln249">	sc = device_get_softc(dev);</a>
<a name="ln250"> </a>
<a name="ln251">	CSR_WRITE_4(sc, AGE_MDIO, MDIO_OP_EXECUTE | MDIO_OP_WRITE |</a>
<a name="ln252">	    (val &amp; MDIO_DATA_MASK) &lt;&lt; MDIO_DATA_SHIFT |</a>
<a name="ln253">	    MDIO_SUP_PREAMBLE | MDIO_CLK_25_4 | MDIO_REG_ADDR(reg));</a>
<a name="ln254">	for (i = AGE_PHY_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln255">		DELAY(1);</a>
<a name="ln256">		v = CSR_READ_4(sc, AGE_MDIO);</a>
<a name="ln257">		if ((v &amp; (MDIO_OP_EXECUTE | MDIO_OP_BUSY)) == 0)</a>
<a name="ln258">			break;</a>
<a name="ln259">	}</a>
<a name="ln260"> </a>
<a name="ln261">	if (i == 0)</a>
<a name="ln262">		device_printf(sc-&gt;age_dev, &quot;phy write timeout : %d\n&quot;, reg);</a>
<a name="ln263"> </a>
<a name="ln264">	return (0);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">/*</a>
<a name="ln268"> *	Callback from MII layer when media changes.</a>
<a name="ln269"> */</a>
<a name="ln270">static void</a>
<a name="ln271">age_miibus_statchg(device_t dev)</a>
<a name="ln272">{</a>
<a name="ln273">	struct age_softc *sc;</a>
<a name="ln274"> </a>
<a name="ln275">	sc = device_get_softc(dev);</a>
<a name="ln276">	taskqueue_enqueue(taskqueue_swi, &amp;sc-&gt;age_link_task);</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">/*</a>
<a name="ln280"> *	Get the current interface media status.</a>
<a name="ln281"> */</a>
<a name="ln282">static void</a>
<a name="ln283">age_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)</a>
<a name="ln284">{</a>
<a name="ln285">	struct age_softc *sc;</a>
<a name="ln286">	struct mii_data *mii;</a>
<a name="ln287"> </a>
<a name="ln288">	sc = ifp-&gt;if_softc;</a>
<a name="ln289">	AGE_LOCK(sc);</a>
<a name="ln290">	mii = device_get_softc(sc-&gt;age_miibus);</a>
<a name="ln291"> </a>
<a name="ln292">	mii_pollstat(mii);</a>
<a name="ln293">	ifmr-&gt;ifm_status = mii-&gt;mii_media_status;</a>
<a name="ln294">	ifmr-&gt;ifm_active = mii-&gt;mii_media_active;</a>
<a name="ln295">	AGE_UNLOCK(sc);</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">/*</a>
<a name="ln299"> *	Set hardware to newly-selected media.</a>
<a name="ln300"> */</a>
<a name="ln301">static int</a>
<a name="ln302">age_mediachange(struct ifnet *ifp)</a>
<a name="ln303">{</a>
<a name="ln304">	struct age_softc *sc;</a>
<a name="ln305">	struct mii_data *mii;</a>
<a name="ln306">	struct mii_softc *miisc;</a>
<a name="ln307">	int error;</a>
<a name="ln308"> </a>
<a name="ln309">	sc = ifp-&gt;if_softc;</a>
<a name="ln310">	AGE_LOCK(sc);</a>
<a name="ln311">	mii = device_get_softc(sc-&gt;age_miibus);</a>
<a name="ln312">	LIST_FOREACH(miisc, &amp;mii-&gt;mii_phys, mii_list)</a>
<a name="ln313">		PHY_RESET(miisc);</a>
<a name="ln314">	error = mii_mediachg(mii);</a>
<a name="ln315">	AGE_UNLOCK(sc);</a>
<a name="ln316"> </a>
<a name="ln317">	return (error);</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">static int</a>
<a name="ln321">age_probe(device_t dev)</a>
<a name="ln322">{</a>
<a name="ln323">	struct age_dev *sp;</a>
<a name="ln324">	int i;</a>
<a name="ln325">	uint16_t vendor, devid;</a>
<a name="ln326"> </a>
<a name="ln327">	vendor = pci_get_vendor(dev);</a>
<a name="ln328">	devid = pci_get_device(dev);</a>
<a name="ln329">	sp = age_devs;</a>
<a name="ln330">	for (i = 0; i &lt; nitems(age_devs); i++, sp++) {</a>
<a name="ln331">		if (vendor == sp-&gt;age_vendorid &amp;&amp;</a>
<a name="ln332">		    devid == sp-&gt;age_deviceid) {</a>
<a name="ln333">			device_set_desc(dev, sp-&gt;age_name);</a>
<a name="ln334">			return (BUS_PROBE_DEFAULT);</a>
<a name="ln335">		}</a>
<a name="ln336">	}</a>
<a name="ln337"> </a>
<a name="ln338">	return (ENXIO);</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">static void</a>
<a name="ln342">age_get_macaddr(struct age_softc *sc)</a>
<a name="ln343">{</a>
<a name="ln344">	uint32_t ea[2], reg;</a>
<a name="ln345">	int i, vpdc;</a>
<a name="ln346"> </a>
<a name="ln347">	reg = CSR_READ_4(sc, AGE_SPI_CTRL);</a>
<a name="ln348">	if ((reg &amp; SPI_VPD_ENB) != 0) {</a>
<a name="ln349">		/* Get VPD stored in TWSI EEPROM. */</a>
<a name="ln350">		reg &amp;= ~SPI_VPD_ENB;</a>
<a name="ln351">		CSR_WRITE_4(sc, AGE_SPI_CTRL, reg);</a>
<a name="ln352">	}</a>
<a name="ln353"> </a>
<a name="ln354">	if (pci_find_cap(sc-&gt;age_dev, PCIY_VPD, &amp;vpdc) == 0) {</a>
<a name="ln355">		/*</a>
<a name="ln356">		 * PCI VPD capability found, let TWSI reload EEPROM.</a>
<a name="ln357">		 * This will set ethernet address of controller.</a>
<a name="ln358">		 */</a>
<a name="ln359">		CSR_WRITE_4(sc, AGE_TWSI_CTRL, CSR_READ_4(sc, AGE_TWSI_CTRL) |</a>
<a name="ln360">		    TWSI_CTRL_SW_LD_START);</a>
<a name="ln361">		for (i = 100; i &gt; 0; i--) {</a>
<a name="ln362">			DELAY(1000);</a>
<a name="ln363">			reg = CSR_READ_4(sc, AGE_TWSI_CTRL);</a>
<a name="ln364">			if ((reg &amp; TWSI_CTRL_SW_LD_START) == 0)</a>
<a name="ln365">				break;</a>
<a name="ln366">		}</a>
<a name="ln367">		if (i == 0)</a>
<a name="ln368">			device_printf(sc-&gt;age_dev,</a>
<a name="ln369">			    &quot;reloading EEPROM timeout!\n&quot;);</a>
<a name="ln370">	} else {</a>
<a name="ln371">		if (bootverbose)</a>
<a name="ln372">			device_printf(sc-&gt;age_dev,</a>
<a name="ln373">			    &quot;PCI VPD capability not found!\n&quot;);</a>
<a name="ln374">	}</a>
<a name="ln375"> </a>
<a name="ln376">	ea[0] = CSR_READ_4(sc, AGE_PAR0);</a>
<a name="ln377">	ea[1] = CSR_READ_4(sc, AGE_PAR1);</a>
<a name="ln378">	sc-&gt;age_eaddr[0] = (ea[1] &gt;&gt; 8) &amp; 0xFF;</a>
<a name="ln379">	sc-&gt;age_eaddr[1] = (ea[1] &gt;&gt; 0) &amp; 0xFF;</a>
<a name="ln380">	sc-&gt;age_eaddr[2] = (ea[0] &gt;&gt; 24) &amp; 0xFF;</a>
<a name="ln381">	sc-&gt;age_eaddr[3] = (ea[0] &gt;&gt; 16) &amp; 0xFF;</a>
<a name="ln382">	sc-&gt;age_eaddr[4] = (ea[0] &gt;&gt; 8) &amp; 0xFF;</a>
<a name="ln383">	sc-&gt;age_eaddr[5] = (ea[0] &gt;&gt; 0) &amp; 0xFF;</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">static void</a>
<a name="ln387">age_phy_reset(struct age_softc *sc)</a>
<a name="ln388">{</a>
<a name="ln389">	uint16_t reg, pn;</a>
<a name="ln390">	int i, linkup;</a>
<a name="ln391"> </a>
<a name="ln392">	/* Reset PHY. */</a>
<a name="ln393">	CSR_WRITE_4(sc, AGE_GPHY_CTRL, GPHY_CTRL_RST);</a>
<a name="ln394">	DELAY(2000);</a>
<a name="ln395">	CSR_WRITE_4(sc, AGE_GPHY_CTRL, GPHY_CTRL_CLR);</a>
<a name="ln396">	DELAY(2000);</a>
<a name="ln397"> </a>
<a name="ln398">#define	ATPHY_DBG_ADDR		0x1D</a>
<a name="ln399">#define	ATPHY_DBG_DATA		0x1E</a>
<a name="ln400">#define	ATPHY_CDTC		0x16</a>
<a name="ln401">#define	PHY_CDTC_ENB		0x0001</a>
<a name="ln402">#define	PHY_CDTC_POFF		8</a>
<a name="ln403">#define	ATPHY_CDTS		0x1C</a>
<a name="ln404">#define	PHY_CDTS_STAT_OK	0x0000</a>
<a name="ln405">#define	PHY_CDTS_STAT_SHORT	0x0100</a>
<a name="ln406">#define	PHY_CDTS_STAT_OPEN	0x0200</a>
<a name="ln407">#define	PHY_CDTS_STAT_INVAL	0x0300</a>
<a name="ln408">#define	PHY_CDTS_STAT_MASK	0x0300</a>
<a name="ln409"> </a>
<a name="ln410">	/* Check power saving mode. Magic from Linux. */</a>
<a name="ln411">	age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr, MII_BMCR, BMCR_RESET);</a>
<a name="ln412">	for (linkup = 0, pn = 0; pn &lt; 4; pn++) {</a>
<a name="ln413">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr, ATPHY_CDTC,</a>
<a name="ln414">		    (pn &lt;&lt; PHY_CDTC_POFF) | PHY_CDTC_ENB);</a>
<a name="ln415">		for (i = 200; i &gt; 0; i--) {</a>
<a name="ln416">			DELAY(1000);</a>
<a name="ln417">			reg = age_miibus_readreg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln418">			    ATPHY_CDTC);</a>
<a name="ln419">			if ((reg &amp; PHY_CDTC_ENB) == 0)</a>
<a name="ln420">				break;</a>
<a name="ln421">		}</a>
<a name="ln422">		DELAY(1000);</a>
<a name="ln423">		reg = age_miibus_readreg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln424">		    ATPHY_CDTS);</a>
<a name="ln425">		if ((reg &amp; PHY_CDTS_STAT_MASK) != PHY_CDTS_STAT_OPEN) {</a>
<a name="ln426">			linkup++;</a>
<a name="ln427">			break;</a>
<a name="ln428">		}</a>
<a name="ln429">	}</a>
<a name="ln430">	age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr, MII_BMCR,</a>
<a name="ln431">	    BMCR_RESET | BMCR_AUTOEN | BMCR_STARTNEG);</a>
<a name="ln432">	if (linkup == 0) {</a>
<a name="ln433">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln434">		    ATPHY_DBG_ADDR, 0);</a>
<a name="ln435">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln436">		    ATPHY_DBG_DATA, 0x124E);</a>
<a name="ln437">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln438">		    ATPHY_DBG_ADDR, 1);</a>
<a name="ln439">		reg = age_miibus_readreg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln440">		    ATPHY_DBG_DATA);</a>
<a name="ln441">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln442">		    ATPHY_DBG_DATA, reg | 0x03);</a>
<a name="ln443">		/* XXX */</a>
<a name="ln444">		DELAY(1500 * 1000);</a>
<a name="ln445">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln446">		    ATPHY_DBG_ADDR, 0);</a>
<a name="ln447">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln448">		    ATPHY_DBG_DATA, 0x024E);</a>
<a name="ln449">    }</a>
<a name="ln450"> </a>
<a name="ln451">#undef	ATPHY_DBG_ADDR</a>
<a name="ln452">#undef	ATPHY_DBG_DATA</a>
<a name="ln453">#undef	ATPHY_CDTC</a>
<a name="ln454">#undef	PHY_CDTC_ENB</a>
<a name="ln455">#undef	PHY_CDTC_POFF</a>
<a name="ln456">#undef	ATPHY_CDTS</a>
<a name="ln457">#undef	PHY_CDTS_STAT_OK</a>
<a name="ln458">#undef	PHY_CDTS_STAT_SHORT</a>
<a name="ln459">#undef	PHY_CDTS_STAT_OPEN</a>
<a name="ln460">#undef	PHY_CDTS_STAT_INVAL</a>
<a name="ln461">#undef	PHY_CDTS_STAT_MASK</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">static int</a>
<a name="ln465">age_attach(device_t dev)</a>
<a name="ln466">{</a>
<a name="ln467">	struct age_softc *sc;</a>
<a name="ln468">	struct ifnet *ifp;</a>
<a name="ln469">	uint16_t burst;</a>
<a name="ln470">	int error, i, msic, msixc, pmc;</a>
<a name="ln471"> </a>
<a name="ln472">	error = 0;</a>
<a name="ln473">	sc = device_get_softc(dev);</a>
<a name="ln474">	sc-&gt;age_dev = dev;</a>
<a name="ln475"> </a>
<a name="ln476">	mtx_init(&amp;sc-&gt;age_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln477">	    MTX_DEF);</a>
<a name="ln478">	callout_init_mtx(&amp;sc-&gt;age_tick_ch, &amp;sc-&gt;age_mtx, 0);</a>
<a name="ln479">	TASK_INIT(&amp;sc-&gt;age_int_task, 0, age_int_task, sc);</a>
<a name="ln480">	TASK_INIT(&amp;sc-&gt;age_link_task, 0, age_link_task, sc);</a>
<a name="ln481"> </a>
<a name="ln482">	/* Map the device. */</a>
<a name="ln483">	pci_enable_busmaster(dev);</a>
<a name="ln484">	sc-&gt;age_res_spec = age_res_spec_mem;</a>
<a name="ln485">	sc-&gt;age_irq_spec = age_irq_spec_legacy;</a>
<a name="ln486">	error = bus_alloc_resources(dev, sc-&gt;age_res_spec, sc-&gt;age_res);</a>
<a name="ln487">	if (error != 0) {</a>
<a name="ln488">		device_printf(dev, &quot;cannot allocate memory resources.\n&quot;);</a>
<a name="ln489">		goto fail;</a>
<a name="ln490">	}</a>
<a name="ln491"> </a>
<a name="ln492">	/* Set PHY address. */</a>
<a name="ln493">	sc-&gt;age_phyaddr = AGE_PHY_ADDR;</a>
<a name="ln494"> </a>
<a name="ln495">	/* Reset PHY. */</a>
<a name="ln496">	age_phy_reset(sc);</a>
<a name="ln497"> </a>
<a name="ln498">	/* Reset the ethernet controller. */</a>
<a name="ln499">	age_reset(sc);</a>
<a name="ln500"> </a>
<a name="ln501">	/* Get PCI and chip id/revision. */</a>
<a name="ln502">	sc-&gt;age_rev = pci_get_revid(dev);</a>
<a name="ln503">	sc-&gt;age_chip_rev = CSR_READ_4(sc, AGE_MASTER_CFG) &gt;&gt;</a>
<a name="ln504">	    MASTER_CHIP_REV_SHIFT;</a>
<a name="ln505">	if (bootverbose) {</a>
<a name="ln506">		device_printf(dev, &quot;PCI device revision : 0x%04x\n&quot;,</a>
<a name="ln507">		    sc-&gt;age_rev);</a>
<a name="ln508">		device_printf(dev, &quot;Chip id/revision : 0x%04x\n&quot;,</a>
<a name="ln509">		    sc-&gt;age_chip_rev);</a>
<a name="ln510">	}</a>
<a name="ln511"> </a>
<a name="ln512">	/*</a>
<a name="ln513">	 * XXX</a>
<a name="ln514">	 * Unintialized hardware returns an invalid chip id/revision</a>
<a name="ln515">	 * as well as 0xFFFFFFFF for Tx/Rx fifo length. It seems that</a>
<a name="ln516">	 * unplugged cable results in putting hardware into automatic</a>
<a name="ln517">	 * power down mode which in turn returns invalld chip revision.</a>
<a name="ln518">	 */</a>
<a name="ln519">	if (sc-&gt;age_chip_rev == 0xFFFF) {</a>
<a name="ln520">		device_printf(dev,&quot;invalid chip revision : 0x%04x -- &quot;</a>
<a name="ln521">		    &quot;not initialized?\n&quot;, sc-&gt;age_chip_rev);</a>
<a name="ln522">		error = ENXIO;</a>
<a name="ln523">		goto fail;</a>
<a name="ln524">	}</a>
<a name="ln525"> </a>
<a name="ln526">	device_printf(dev, &quot;%d Tx FIFO, %d Rx FIFO\n&quot;,</a>
<a name="ln527">	    CSR_READ_4(sc, AGE_SRAM_TX_FIFO_LEN),</a>
<a name="ln528">	    CSR_READ_4(sc, AGE_SRAM_RX_FIFO_LEN));</a>
<a name="ln529"> </a>
<a name="ln530">	/* Allocate IRQ resources. */</a>
<a name="ln531">	msixc = pci_msix_count(dev);</a>
<a name="ln532">	msic = pci_msi_count(dev);</a>
<a name="ln533">	if (bootverbose) {</a>
<a name="ln534">		device_printf(dev, &quot;MSIX count : %d\n&quot;, msixc);</a>
<a name="ln535">		device_printf(dev, &quot;MSI count : %d\n&quot;, msic);</a>
<a name="ln536">	}</a>
<a name="ln537"> </a>
<a name="ln538">	/* Prefer MSIX over MSI. */</a>
<a name="ln539">	if (msix_disable == 0 || msi_disable == 0) {</a>
<a name="ln540">		if (msix_disable == 0 &amp;&amp; msixc == AGE_MSIX_MESSAGES &amp;&amp;</a>
<a name="ln541">		    pci_alloc_msix(dev, &amp;msixc) == 0) {</a>
<a name="ln542">			if (msic == AGE_MSIX_MESSAGES) {</a>
<a name="ln543">				device_printf(dev, &quot;Using %d MSIX messages.\n&quot;,</a>
<a name="ln544">				    msixc);</a>
<a name="ln545">				sc-&gt;age_flags |= AGE_FLAG_MSIX;</a>
<a name="ln546">				sc-&gt;age_irq_spec = age_irq_spec_msix;</a>
<a name="ln547">			} else</a>
<a name="ln548">				pci_release_msi(dev);</a>
<a name="ln549">		}</a>
<a name="ln550">		if (msi_disable == 0 &amp;&amp; (sc-&gt;age_flags &amp; AGE_FLAG_MSIX) == 0 &amp;&amp;</a>
<a name="ln551">		    msic == AGE_MSI_MESSAGES &amp;&amp;</a>
<a name="ln552">		    pci_alloc_msi(dev, &amp;msic) == 0) {</a>
<a name="ln553">			if (msic == AGE_MSI_MESSAGES) {</a>
<a name="ln554">				device_printf(dev, &quot;Using %d MSI messages.\n&quot;,</a>
<a name="ln555">				    msic);</a>
<a name="ln556">				sc-&gt;age_flags |= AGE_FLAG_MSI;</a>
<a name="ln557">				sc-&gt;age_irq_spec = age_irq_spec_msi;</a>
<a name="ln558">			} else</a>
<a name="ln559">				pci_release_msi(dev);</a>
<a name="ln560">		}</a>
<a name="ln561">	}</a>
<a name="ln562"> </a>
<a name="ln563">	error = bus_alloc_resources(dev, sc-&gt;age_irq_spec, sc-&gt;age_irq);</a>
<a name="ln564">	if (error != 0) {</a>
<a name="ln565">		device_printf(dev, &quot;cannot allocate IRQ resources.\n&quot;);</a>
<a name="ln566">		goto fail;</a>
<a name="ln567">	}</a>
<a name="ln568"> </a>
<a name="ln569"> </a>
<a name="ln570">	/* Get DMA parameters from PCIe device control register. */</a>
<a name="ln571">	if (pci_find_cap(dev, PCIY_EXPRESS, &amp;i) == 0) {</a>
<a name="ln572">		sc-&gt;age_flags |= AGE_FLAG_PCIE;</a>
<a name="ln573">		burst = pci_read_config(dev, i + 0x08, 2);</a>
<a name="ln574">		/* Max read request size. */</a>
<a name="ln575">		sc-&gt;age_dma_rd_burst = ((burst &gt;&gt; 12) &amp; 0x07) &lt;&lt;</a>
<a name="ln576">		    DMA_CFG_RD_BURST_SHIFT;</a>
<a name="ln577">		/* Max payload size. */</a>
<a name="ln578">		sc-&gt;age_dma_wr_burst = ((burst &gt;&gt; 5) &amp; 0x07) &lt;&lt;</a>
<a name="ln579">		    DMA_CFG_WR_BURST_SHIFT;</a>
<a name="ln580">		if (bootverbose) {</a>
<a name="ln581">			device_printf(dev, &quot;Read request size : %d bytes.\n&quot;,</a>
<a name="ln582">			    128 &lt;&lt; ((burst &gt;&gt; 12) &amp; 0x07));</a>
<a name="ln583">			device_printf(dev, &quot;TLP payload size : %d bytes.\n&quot;,</a>
<a name="ln584">			    128 &lt;&lt; ((burst &gt;&gt; 5) &amp; 0x07));</a>
<a name="ln585">		}</a>
<a name="ln586">	} else {</a>
<a name="ln587">		sc-&gt;age_dma_rd_burst = DMA_CFG_RD_BURST_128;</a>
<a name="ln588">		sc-&gt;age_dma_wr_burst = DMA_CFG_WR_BURST_128;</a>
<a name="ln589">	}</a>
<a name="ln590"> </a>
<a name="ln591">	/* Create device sysctl node. */</a>
<a name="ln592">	age_sysctl_node(sc);</a>
<a name="ln593"> </a>
<a name="ln594">	if ((error = age_dma_alloc(sc)) != 0)</a>
<a name="ln595">		goto fail;</a>
<a name="ln596"> </a>
<a name="ln597">	/* Load station address. */</a>
<a name="ln598">	age_get_macaddr(sc);</a>
<a name="ln599"> </a>
<a name="ln600">	ifp = sc-&gt;age_ifp = if_alloc(IFT_ETHER);</a>
<a name="ln601">	if (ifp == NULL) {</a>
<a name="ln602">		device_printf(dev, &quot;cannot allocate ifnet structure.\n&quot;);</a>
<a name="ln603">		error = ENXIO;</a>
<a name="ln604">		goto fail;</a>
<a name="ln605">	}</a>
<a name="ln606"> </a>
<a name="ln607">	ifp-&gt;if_softc = sc;</a>
<a name="ln608">	if_initname(ifp, device_get_name(dev), device_get_unit(dev));</a>
<a name="ln609">	ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;</a>
<a name="ln610">	ifp-&gt;if_ioctl = age_ioctl;</a>
<a name="ln611">	ifp-&gt;if_start = age_start;</a>
<a name="ln612">	ifp-&gt;if_init = age_init;</a>
<a name="ln613">	ifp-&gt;if_snd.ifq_drv_maxlen = AGE_TX_RING_CNT - 1;</a>
<a name="ln614">	IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, ifp-&gt;if_snd.ifq_drv_maxlen);</a>
<a name="ln615">	IFQ_SET_READY(&amp;ifp-&gt;if_snd);</a>
<a name="ln616">	ifp-&gt;if_capabilities = IFCAP_HWCSUM | IFCAP_TSO4;</a>
<a name="ln617">	ifp-&gt;if_hwassist = AGE_CSUM_FEATURES | CSUM_TSO;</a>
<a name="ln618">	if (pci_find_cap(dev, PCIY_PMG, &amp;pmc) == 0) {</a>
<a name="ln619">		sc-&gt;age_flags |= AGE_FLAG_PMCAP;</a>
<a name="ln620">		ifp-&gt;if_capabilities |= IFCAP_WOL_MAGIC | IFCAP_WOL_MCAST;</a>
<a name="ln621">	}</a>
<a name="ln622">	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;</a>
<a name="ln623"> </a>
<a name="ln624">	/* Set up MII bus. */</a>
<a name="ln625">	error = mii_attach(dev, &amp;sc-&gt;age_miibus, ifp, age_mediachange,</a>
<a name="ln626">	    age_mediastatus, BMSR_DEFCAPMASK, sc-&gt;age_phyaddr, MII_OFFSET_ANY,</a>
<a name="ln627">	    0);</a>
<a name="ln628">	if (error != 0) {</a>
<a name="ln629">		device_printf(dev, &quot;attaching PHYs failed\n&quot;);</a>
<a name="ln630">		goto fail;</a>
<a name="ln631">	}</a>
<a name="ln632"> </a>
<a name="ln633">	ether_ifattach(ifp, sc-&gt;age_eaddr);</a>
<a name="ln634"> </a>
<a name="ln635">	/* VLAN capability setup. */</a>
<a name="ln636">	ifp-&gt;if_capabilities |= IFCAP_VLAN_MTU | IFCAP_VLAN_HWTAGGING |</a>
<a name="ln637">	    IFCAP_VLAN_HWCSUM | IFCAP_VLAN_HWTSO;</a>
<a name="ln638">	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;</a>
<a name="ln639"> </a>
<a name="ln640">	/* Tell the upper layer(s) we support long frames. */</a>
<a name="ln641">	ifp-&gt;if_hdrlen = sizeof(struct ether_vlan_header);</a>
<a name="ln642"> </a>
<a name="ln643">	/* Create local taskq. */</a>
<a name="ln644">	sc-&gt;age_tq = taskqueue_create_fast(&quot;age_taskq&quot;, M_WAITOK,</a>
<a name="ln645">	    taskqueue_thread_enqueue, &amp;sc-&gt;age_tq);</a>
<a name="ln646">	if (sc-&gt;age_tq == NULL) {</a>
<a name="ln647">		device_printf(dev, &quot;could not create taskqueue.\n&quot;);</a>
<a name="ln648">		ether_ifdetach(ifp);</a>
<a name="ln649">		error = ENXIO;</a>
<a name="ln650">		goto fail;</a>
<a name="ln651">	}</a>
<a name="ln652">	taskqueue_start_threads(&amp;sc-&gt;age_tq, 1, PI_NET, &quot;%s taskq&quot;,</a>
<a name="ln653">	    device_get_nameunit(sc-&gt;age_dev));</a>
<a name="ln654"> </a>
<a name="ln655">	if ((sc-&gt;age_flags &amp; AGE_FLAG_MSIX) != 0)</a>
<a name="ln656">		msic = AGE_MSIX_MESSAGES;</a>
<a name="ln657">	else if ((sc-&gt;age_flags &amp; AGE_FLAG_MSI) != 0)</a>
<a name="ln658">		msic = AGE_MSI_MESSAGES;</a>
<a name="ln659">	else</a>
<a name="ln660">		msic = 1;</a>
<a name="ln661">	for (i = 0; i &lt; msic; i++) {</a>
<a name="ln662">		error = bus_setup_intr(dev, sc-&gt;age_irq[i],</a>
<a name="ln663">		    INTR_TYPE_NET | INTR_MPSAFE, age_intr, NULL, sc,</a>
<a name="ln664">		    &amp;sc-&gt;age_intrhand[i]);</a>
<a name="ln665">		if (error != 0)</a>
<a name="ln666">			break;</a>
<a name="ln667">	}</a>
<a name="ln668">	if (error != 0) {</a>
<a name="ln669">		device_printf(dev, &quot;could not set up interrupt handler.\n&quot;);</a>
<a name="ln670">		taskqueue_free(sc-&gt;age_tq);</a>
<a name="ln671">		sc-&gt;age_tq = NULL;</a>
<a name="ln672">		ether_ifdetach(ifp);</a>
<a name="ln673">		goto fail;</a>
<a name="ln674">	}</a>
<a name="ln675"> </a>
<a name="ln676">fail:</a>
<a name="ln677">	if (error != 0)</a>
<a name="ln678">		age_detach(dev);</a>
<a name="ln679"> </a>
<a name="ln680">	return (error);</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">static int</a>
<a name="ln684">age_detach(device_t dev)</a>
<a name="ln685">{</a>
<a name="ln686">	struct age_softc *sc;</a>
<a name="ln687">	struct ifnet *ifp;</a>
<a name="ln688">	int i, msic;</a>
<a name="ln689"> </a>
<a name="ln690">	sc = device_get_softc(dev);</a>
<a name="ln691"> </a>
<a name="ln692">	ifp = sc-&gt;age_ifp;</a>
<a name="ln693">	if (device_is_attached(dev)) {</a>
<a name="ln694">		AGE_LOCK(sc);</a>
<a name="ln695">		sc-&gt;age_flags |= AGE_FLAG_DETACH;</a>
<a name="ln696">		age_stop(sc);</a>
<a name="ln697">		AGE_UNLOCK(sc);</a>
<a name="ln698">		callout_drain(&amp;sc-&gt;age_tick_ch);</a>
<a name="ln699">		taskqueue_drain(sc-&gt;age_tq, &amp;sc-&gt;age_int_task);</a>
<a name="ln700">		taskqueue_drain(taskqueue_swi, &amp;sc-&gt;age_link_task);</a>
<a name="ln701">		ether_ifdetach(ifp);</a>
<a name="ln702">	}</a>
<a name="ln703"> </a>
<a name="ln704">	if (sc-&gt;age_tq != NULL) {</a>
<a name="ln705">		taskqueue_drain(sc-&gt;age_tq, &amp;sc-&gt;age_int_task);</a>
<a name="ln706">		taskqueue_free(sc-&gt;age_tq);</a>
<a name="ln707">		sc-&gt;age_tq = NULL;</a>
<a name="ln708">	}</a>
<a name="ln709"> </a>
<a name="ln710">	if (sc-&gt;age_miibus != NULL) {</a>
<a name="ln711">		device_delete_child(dev, sc-&gt;age_miibus);</a>
<a name="ln712">		sc-&gt;age_miibus = NULL;</a>
<a name="ln713">	}</a>
<a name="ln714">	bus_generic_detach(dev);</a>
<a name="ln715">	age_dma_free(sc);</a>
<a name="ln716"> </a>
<a name="ln717">	if (ifp != NULL) {</a>
<a name="ln718">		if_free(ifp);</a>
<a name="ln719">		sc-&gt;age_ifp = NULL;</a>
<a name="ln720">	}</a>
<a name="ln721"> </a>
<a name="ln722">	if ((sc-&gt;age_flags &amp; AGE_FLAG_MSIX) != 0)</a>
<a name="ln723">		msic = AGE_MSIX_MESSAGES;</a>
<a name="ln724">	else if ((sc-&gt;age_flags &amp; AGE_FLAG_MSI) != 0)</a>
<a name="ln725">		msic = AGE_MSI_MESSAGES;</a>
<a name="ln726">	else</a>
<a name="ln727">		msic = 1;</a>
<a name="ln728">	for (i = 0; i &lt; msic; i++) {</a>
<a name="ln729">		if (sc-&gt;age_intrhand[i] != NULL) {</a>
<a name="ln730">			bus_teardown_intr(dev, sc-&gt;age_irq[i],</a>
<a name="ln731">			    sc-&gt;age_intrhand[i]);</a>
<a name="ln732">			sc-&gt;age_intrhand[i] = NULL;</a>
<a name="ln733">		}</a>
<a name="ln734">	}</a>
<a name="ln735"> </a>
<a name="ln736">	bus_release_resources(dev, sc-&gt;age_irq_spec, sc-&gt;age_irq);</a>
<a name="ln737">	if ((sc-&gt;age_flags &amp; (AGE_FLAG_MSI | AGE_FLAG_MSIX)) != 0)</a>
<a name="ln738">		pci_release_msi(dev);</a>
<a name="ln739">	bus_release_resources(dev, sc-&gt;age_res_spec, sc-&gt;age_res);</a>
<a name="ln740">	mtx_destroy(&amp;sc-&gt;age_mtx);</a>
<a name="ln741"> </a>
<a name="ln742">	return (0);</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">static void</a>
<a name="ln746">age_sysctl_node(struct age_softc *sc)</a>
<a name="ln747">{</a>
<a name="ln748">	int error;</a>
<a name="ln749"> </a>
<a name="ln750">	SYSCTL_ADD_PROC(device_get_sysctl_ctx(sc-&gt;age_dev),</a>
<a name="ln751">	    SYSCTL_CHILDREN(device_get_sysctl_tree(sc-&gt;age_dev)), OID_AUTO,</a>
<a name="ln752">	    &quot;stats&quot;, CTLTYPE_INT | CTLFLAG_RW, sc, 0, sysctl_age_stats,</a>
<a name="ln753">	    &quot;I&quot;, &quot;Statistics&quot;);</a>
<a name="ln754"> </a>
<a name="ln755">	SYSCTL_ADD_PROC(device_get_sysctl_ctx(sc-&gt;age_dev),</a>
<a name="ln756">	    SYSCTL_CHILDREN(device_get_sysctl_tree(sc-&gt;age_dev)), OID_AUTO,</a>
<a name="ln757">	    &quot;int_mod&quot;, CTLTYPE_INT | CTLFLAG_RW, &amp;sc-&gt;age_int_mod, 0,</a>
<a name="ln758">	    sysctl_hw_age_int_mod, &quot;I&quot;, &quot;age interrupt moderation&quot;);</a>
<a name="ln759"> </a>
<a name="ln760">	/* Pull in device tunables. */</a>
<a name="ln761">	sc-&gt;age_int_mod = AGE_IM_TIMER_DEFAULT;</a>
<a name="ln762">	error = resource_int_value(device_get_name(sc-&gt;age_dev),</a>
<a name="ln763">	    device_get_unit(sc-&gt;age_dev), &quot;int_mod&quot;, &amp;sc-&gt;age_int_mod);</a>
<a name="ln764">	if (error == 0) {</a>
<a name="ln765">		if (sc-&gt;age_int_mod &lt; AGE_IM_TIMER_MIN ||</a>
<a name="ln766">		    sc-&gt;age_int_mod &gt; AGE_IM_TIMER_MAX) {</a>
<a name="ln767">			device_printf(sc-&gt;age_dev,</a>
<a name="ln768">			    &quot;int_mod value out of range; using default: %d\n&quot;,</a>
<a name="ln769">			    AGE_IM_TIMER_DEFAULT);</a>
<a name="ln770">			sc-&gt;age_int_mod = AGE_IM_TIMER_DEFAULT;</a>
<a name="ln771">		}</a>
<a name="ln772">	}</a>
<a name="ln773"> </a>
<a name="ln774">	SYSCTL_ADD_PROC(device_get_sysctl_ctx(sc-&gt;age_dev),</a>
<a name="ln775">	    SYSCTL_CHILDREN(device_get_sysctl_tree(sc-&gt;age_dev)), OID_AUTO,</a>
<a name="ln776">	    &quot;process_limit&quot;, CTLTYPE_INT | CTLFLAG_RW, &amp;sc-&gt;age_process_limit,</a>
<a name="ln777">	    0, sysctl_hw_age_proc_limit, &quot;I&quot;,</a>
<a name="ln778">	    &quot;max number of Rx events to process&quot;);</a>
<a name="ln779"> </a>
<a name="ln780">	/* Pull in device tunables. */</a>
<a name="ln781">	sc-&gt;age_process_limit = AGE_PROC_DEFAULT;</a>
<a name="ln782">	error = resource_int_value(device_get_name(sc-&gt;age_dev),</a>
<a name="ln783">	    device_get_unit(sc-&gt;age_dev), &quot;process_limit&quot;,</a>
<a name="ln784">	    &amp;sc-&gt;age_process_limit);</a>
<a name="ln785">	if (error == 0) {</a>
<a name="ln786">		if (sc-&gt;age_process_limit &lt; AGE_PROC_MIN ||</a>
<a name="ln787">		    sc-&gt;age_process_limit &gt; AGE_PROC_MAX) {</a>
<a name="ln788">			device_printf(sc-&gt;age_dev,</a>
<a name="ln789">			    &quot;process_limit value out of range; &quot;</a>
<a name="ln790">			    &quot;using default: %d\n&quot;, AGE_PROC_DEFAULT);</a>
<a name="ln791">			sc-&gt;age_process_limit = AGE_PROC_DEFAULT;</a>
<a name="ln792">		}</a>
<a name="ln793">	}</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">struct age_dmamap_arg {</a>
<a name="ln797">	bus_addr_t	age_busaddr;</a>
<a name="ln798">};</a>
<a name="ln799"> </a>
<a name="ln800">static void</a>
<a name="ln801">age_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nsegs, int error)</a>
<a name="ln802">{</a>
<a name="ln803">	struct age_dmamap_arg *ctx;</a>
<a name="ln804"> </a>
<a name="ln805">	if (error != 0)</a>
<a name="ln806">		return;</a>
<a name="ln807"> </a>
<a name="ln808">	KASSERT(nsegs == 1, (&quot;%s: %d segments returned!&quot;, __func__, nsegs));</a>
<a name="ln809"> </a>
<a name="ln810">	ctx = (struct age_dmamap_arg *)arg;</a>
<a name="ln811">	ctx-&gt;age_busaddr = segs[0].ds_addr;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">/*</a>
<a name="ln815"> * Attansic L1 controller have single register to specify high</a>
<a name="ln816"> * address part of DMA blocks. So all descriptor structures and</a>
<a name="ln817"> * DMA memory blocks should have the same high address of given</a>
<a name="ln818"> * 4GB address space(i.e. crossing 4GB boundary is not allowed).</a>
<a name="ln819"> */</a>
<a name="ln820">static int</a>
<a name="ln821">age_check_boundary(struct age_softc *sc)</a>
<a name="ln822">{</a>
<a name="ln823">	bus_addr_t rx_ring_end, rr_ring_end, tx_ring_end;</a>
<a name="ln824">	bus_addr_t cmb_block_end, smb_block_end;</a>
<a name="ln825"> </a>
<a name="ln826">	/* Tx/Rx descriptor queue should reside within 4GB boundary. */</a>
<a name="ln827">	tx_ring_end = sc-&gt;age_rdata.age_tx_ring_paddr + AGE_TX_RING_SZ;</a>
<a name="ln828">	rx_ring_end = sc-&gt;age_rdata.age_rx_ring_paddr + AGE_RX_RING_SZ;</a>
<a name="ln829">	rr_ring_end = sc-&gt;age_rdata.age_rr_ring_paddr + AGE_RR_RING_SZ;</a>
<a name="ln830">	cmb_block_end = sc-&gt;age_rdata.age_cmb_block_paddr + AGE_CMB_BLOCK_SZ;</a>
<a name="ln831">	smb_block_end = sc-&gt;age_rdata.age_smb_block_paddr + AGE_SMB_BLOCK_SZ;</a>
<a name="ln832"> </a>
<a name="ln833">	if ((AGE_ADDR_HI(tx_ring_end) !=</a>
<a name="ln834">	    AGE_ADDR_HI(sc-&gt;age_rdata.age_tx_ring_paddr)) ||</a>
<a name="ln835">	    (AGE_ADDR_HI(rx_ring_end) !=</a>
<a name="ln836">	    AGE_ADDR_HI(sc-&gt;age_rdata.age_rx_ring_paddr)) ||</a>
<a name="ln837">	    (AGE_ADDR_HI(rr_ring_end) !=</a>
<a name="ln838">	    AGE_ADDR_HI(sc-&gt;age_rdata.age_rr_ring_paddr)) ||</a>
<a name="ln839">	    (AGE_ADDR_HI(cmb_block_end) !=</a>
<a name="ln840">	    AGE_ADDR_HI(sc-&gt;age_rdata.age_cmb_block_paddr)) ||</a>
<a name="ln841">	    (AGE_ADDR_HI(smb_block_end) !=</a>
<a name="ln842">	    AGE_ADDR_HI(sc-&gt;age_rdata.age_smb_block_paddr)))</a>
<a name="ln843">		return (EFBIG);</a>
<a name="ln844"> </a>
<a name="ln845">	if ((AGE_ADDR_HI(tx_ring_end) != AGE_ADDR_HI(rx_ring_end)) ||</a>
<a name="ln846">	    (AGE_ADDR_HI(tx_ring_end) != AGE_ADDR_HI(rr_ring_end)) ||</a>
<a name="ln847">	    (AGE_ADDR_HI(tx_ring_end) != AGE_ADDR_HI(cmb_block_end)) ||</a>
<a name="ln848">	    (AGE_ADDR_HI(tx_ring_end) != AGE_ADDR_HI(smb_block_end)))</a>
<a name="ln849">		return (EFBIG);</a>
<a name="ln850"> </a>
<a name="ln851">	return (0);</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">static int</a>
<a name="ln855">age_dma_alloc(struct age_softc *sc)</a>
<a name="ln856">{</a>
<a name="ln857">	struct age_txdesc *txd;</a>
<a name="ln858">	struct age_rxdesc *rxd;</a>
<a name="ln859">	bus_addr_t lowaddr;</a>
<a name="ln860">	struct age_dmamap_arg ctx;</a>
<a name="ln861">	int error, i;</a>
<a name="ln862"> </a>
<a name="ln863">	lowaddr = BUS_SPACE_MAXADDR;</a>
<a name="ln864"> </a>
<a name="ln865">again:</a>
<a name="ln866">	/* Create parent ring/DMA block tag. */</a>
<a name="ln867">	error = bus_dma_tag_create(</a>
<a name="ln868">	    bus_get_dma_tag(sc-&gt;age_dev), /* parent */</a>
<a name="ln869">	    1, 0,			/* alignment, boundary */</a>
<a name="ln870">	    lowaddr,			/* lowaddr */</a>
<a name="ln871">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln872">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln873">	    BUS_SPACE_MAXSIZE_32BIT,	/* maxsize */</a>
<a name="ln874">	    0,				/* nsegments */</a>
<a name="ln875">	    BUS_SPACE_MAXSIZE_32BIT,	/* maxsegsize */</a>
<a name="ln876">	    0,				/* flags */</a>
<a name="ln877">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln878">	    &amp;sc-&gt;age_cdata.age_parent_tag);</a>
<a name="ln879">	if (error != 0) {</a>
<a name="ln880">		device_printf(sc-&gt;age_dev,</a>
<a name="ln881">		    &quot;could not create parent DMA tag.\n&quot;);</a>
<a name="ln882">		goto fail;</a>
<a name="ln883">	}</a>
<a name="ln884"> </a>
<a name="ln885">	/* Create tag for Tx ring. */</a>
<a name="ln886">	error = bus_dma_tag_create(</a>
<a name="ln887">	    sc-&gt;age_cdata.age_parent_tag, /* parent */</a>
<a name="ln888">	    AGE_TX_RING_ALIGN, 0,	/* alignment, boundary */</a>
<a name="ln889">	    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln890">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln891">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln892">	    AGE_TX_RING_SZ,		/* maxsize */</a>
<a name="ln893">	    1,				/* nsegments */</a>
<a name="ln894">	    AGE_TX_RING_SZ,		/* maxsegsize */</a>
<a name="ln895">	    0,				/* flags */</a>
<a name="ln896">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln897">	    &amp;sc-&gt;age_cdata.age_tx_ring_tag);</a>
<a name="ln898">	if (error != 0) {</a>
<a name="ln899">		device_printf(sc-&gt;age_dev,</a>
<a name="ln900">		    &quot;could not create Tx ring DMA tag.\n&quot;);</a>
<a name="ln901">		goto fail;</a>
<a name="ln902">	}</a>
<a name="ln903"> </a>
<a name="ln904">	/* Create tag for Rx ring. */</a>
<a name="ln905">	error = bus_dma_tag_create(</a>
<a name="ln906">	    sc-&gt;age_cdata.age_parent_tag, /* parent */</a>
<a name="ln907">	    AGE_RX_RING_ALIGN, 0,	/* alignment, boundary */</a>
<a name="ln908">	    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln909">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln910">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln911">	    AGE_RX_RING_SZ,		/* maxsize */</a>
<a name="ln912">	    1,				/* nsegments */</a>
<a name="ln913">	    AGE_RX_RING_SZ,		/* maxsegsize */</a>
<a name="ln914">	    0,				/* flags */</a>
<a name="ln915">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln916">	    &amp;sc-&gt;age_cdata.age_rx_ring_tag);</a>
<a name="ln917">	if (error != 0) {</a>
<a name="ln918">		device_printf(sc-&gt;age_dev,</a>
<a name="ln919">		    &quot;could not create Rx ring DMA tag.\n&quot;);</a>
<a name="ln920">		goto fail;</a>
<a name="ln921">	}</a>
<a name="ln922"> </a>
<a name="ln923">	/* Create tag for Rx return ring. */</a>
<a name="ln924">	error = bus_dma_tag_create(</a>
<a name="ln925">	    sc-&gt;age_cdata.age_parent_tag, /* parent */</a>
<a name="ln926">	    AGE_RR_RING_ALIGN, 0,	/* alignment, boundary */</a>
<a name="ln927">	    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln928">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln929">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln930">	    AGE_RR_RING_SZ,		/* maxsize */</a>
<a name="ln931">	    1,				/* nsegments */</a>
<a name="ln932">	    AGE_RR_RING_SZ,		/* maxsegsize */</a>
<a name="ln933">	    0,				/* flags */</a>
<a name="ln934">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln935">	    &amp;sc-&gt;age_cdata.age_rr_ring_tag);</a>
<a name="ln936">	if (error != 0) {</a>
<a name="ln937">		device_printf(sc-&gt;age_dev,</a>
<a name="ln938">		    &quot;could not create Rx return ring DMA tag.\n&quot;);</a>
<a name="ln939">		goto fail;</a>
<a name="ln940">	}</a>
<a name="ln941"> </a>
<a name="ln942">	/* Create tag for coalesing message block. */</a>
<a name="ln943">	error = bus_dma_tag_create(</a>
<a name="ln944">	    sc-&gt;age_cdata.age_parent_tag, /* parent */</a>
<a name="ln945">	    AGE_CMB_ALIGN, 0,		/* alignment, boundary */</a>
<a name="ln946">	    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln947">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln948">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln949">	    AGE_CMB_BLOCK_SZ,		/* maxsize */</a>
<a name="ln950">	    1,				/* nsegments */</a>
<a name="ln951">	    AGE_CMB_BLOCK_SZ,		/* maxsegsize */</a>
<a name="ln952">	    0,				/* flags */</a>
<a name="ln953">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln954">	    &amp;sc-&gt;age_cdata.age_cmb_block_tag);</a>
<a name="ln955">	if (error != 0) {</a>
<a name="ln956">		device_printf(sc-&gt;age_dev,</a>
<a name="ln957">		    &quot;could not create CMB DMA tag.\n&quot;);</a>
<a name="ln958">		goto fail;</a>
<a name="ln959">	}</a>
<a name="ln960"> </a>
<a name="ln961">	/* Create tag for statistics message block. */</a>
<a name="ln962">	error = bus_dma_tag_create(</a>
<a name="ln963">	    sc-&gt;age_cdata.age_parent_tag, /* parent */</a>
<a name="ln964">	    AGE_SMB_ALIGN, 0,		/* alignment, boundary */</a>
<a name="ln965">	    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln966">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln967">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln968">	    AGE_SMB_BLOCK_SZ,		/* maxsize */</a>
<a name="ln969">	    1,				/* nsegments */</a>
<a name="ln970">	    AGE_SMB_BLOCK_SZ,		/* maxsegsize */</a>
<a name="ln971">	    0,				/* flags */</a>
<a name="ln972">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln973">	    &amp;sc-&gt;age_cdata.age_smb_block_tag);</a>
<a name="ln974">	if (error != 0) {</a>
<a name="ln975">		device_printf(sc-&gt;age_dev,</a>
<a name="ln976">		    &quot;could not create SMB DMA tag.\n&quot;);</a>
<a name="ln977">		goto fail;</a>
<a name="ln978">	}</a>
<a name="ln979"> </a>
<a name="ln980">	/* Allocate DMA'able memory and load the DMA map. */</a>
<a name="ln981">	error = bus_dmamem_alloc(sc-&gt;age_cdata.age_tx_ring_tag,</a>
<a name="ln982">	    (void **)&amp;sc-&gt;age_rdata.age_tx_ring,</a>
<a name="ln983">	    BUS_DMA_WAITOK | BUS_DMA_ZERO | BUS_DMA_COHERENT,</a>
<a name="ln984">	    &amp;sc-&gt;age_cdata.age_tx_ring_map);</a>
<a name="ln985">	if (error != 0) {</a>
<a name="ln986">		device_printf(sc-&gt;age_dev,</a>
<a name="ln987">		    &quot;could not allocate DMA'able memory for Tx ring.\n&quot;);</a>
<a name="ln988">		goto fail;</a>
<a name="ln989">	}</a>
<a name="ln990">	ctx.age_busaddr = 0;</a>
<a name="ln991">	error = bus_dmamap_load(sc-&gt;age_cdata.age_tx_ring_tag,</a>
<a name="ln992">	    sc-&gt;age_cdata.age_tx_ring_map, sc-&gt;age_rdata.age_tx_ring,</a>
<a name="ln993">	    AGE_TX_RING_SZ, age_dmamap_cb, &amp;ctx, 0);</a>
<a name="ln994">	if (error != 0 || ctx.age_busaddr == 0) {</a>
<a name="ln995">		device_printf(sc-&gt;age_dev,</a>
<a name="ln996">		    &quot;could not load DMA'able memory for Tx ring.\n&quot;);</a>
<a name="ln997">		goto fail;</a>
<a name="ln998">	}</a>
<a name="ln999">	sc-&gt;age_rdata.age_tx_ring_paddr = ctx.age_busaddr;</a>
<a name="ln1000">	/* Rx ring */</a>
<a name="ln1001">	error = bus_dmamem_alloc(sc-&gt;age_cdata.age_rx_ring_tag,</a>
<a name="ln1002">	    (void **)&amp;sc-&gt;age_rdata.age_rx_ring,</a>
<a name="ln1003">	    BUS_DMA_WAITOK | BUS_DMA_ZERO | BUS_DMA_COHERENT,</a>
<a name="ln1004">	    &amp;sc-&gt;age_cdata.age_rx_ring_map);</a>
<a name="ln1005">	if (error != 0) {</a>
<a name="ln1006">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1007">		    &quot;could not allocate DMA'able memory for Rx ring.\n&quot;);</a>
<a name="ln1008">		goto fail;</a>
<a name="ln1009">	}</a>
<a name="ln1010">	ctx.age_busaddr = 0;</a>
<a name="ln1011">	error = bus_dmamap_load(sc-&gt;age_cdata.age_rx_ring_tag,</a>
<a name="ln1012">	    sc-&gt;age_cdata.age_rx_ring_map, sc-&gt;age_rdata.age_rx_ring,</a>
<a name="ln1013">	    AGE_RX_RING_SZ, age_dmamap_cb, &amp;ctx, 0);</a>
<a name="ln1014">	if (error != 0 || ctx.age_busaddr == 0) {</a>
<a name="ln1015">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1016">		    &quot;could not load DMA'able memory for Rx ring.\n&quot;);</a>
<a name="ln1017">		goto fail;</a>
<a name="ln1018">	}</a>
<a name="ln1019">	sc-&gt;age_rdata.age_rx_ring_paddr = ctx.age_busaddr;</a>
<a name="ln1020">	/* Rx return ring */</a>
<a name="ln1021">	error = bus_dmamem_alloc(sc-&gt;age_cdata.age_rr_ring_tag,</a>
<a name="ln1022">	    (void **)&amp;sc-&gt;age_rdata.age_rr_ring,</a>
<a name="ln1023">	    BUS_DMA_WAITOK | BUS_DMA_ZERO | BUS_DMA_COHERENT,</a>
<a name="ln1024">	    &amp;sc-&gt;age_cdata.age_rr_ring_map);</a>
<a name="ln1025">	if (error != 0) {</a>
<a name="ln1026">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1027">		    &quot;could not allocate DMA'able memory for Rx return ring.\n&quot;);</a>
<a name="ln1028">		goto fail;</a>
<a name="ln1029">	}</a>
<a name="ln1030">	ctx.age_busaddr = 0;</a>
<a name="ln1031">	error = bus_dmamap_load(sc-&gt;age_cdata.age_rr_ring_tag,</a>
<a name="ln1032">	    sc-&gt;age_cdata.age_rr_ring_map, sc-&gt;age_rdata.age_rr_ring,</a>
<a name="ln1033">	    AGE_RR_RING_SZ, age_dmamap_cb,</a>
<a name="ln1034">	    &amp;ctx, 0);</a>
<a name="ln1035">	if (error != 0 || ctx.age_busaddr == 0) {</a>
<a name="ln1036">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1037">		    &quot;could not load DMA'able memory for Rx return ring.\n&quot;);</a>
<a name="ln1038">		goto fail;</a>
<a name="ln1039">	}</a>
<a name="ln1040">	sc-&gt;age_rdata.age_rr_ring_paddr = ctx.age_busaddr;</a>
<a name="ln1041">	/* CMB block */</a>
<a name="ln1042">	error = bus_dmamem_alloc(sc-&gt;age_cdata.age_cmb_block_tag,</a>
<a name="ln1043">	    (void **)&amp;sc-&gt;age_rdata.age_cmb_block,</a>
<a name="ln1044">	    BUS_DMA_WAITOK | BUS_DMA_ZERO | BUS_DMA_COHERENT,</a>
<a name="ln1045">	    &amp;sc-&gt;age_cdata.age_cmb_block_map);</a>
<a name="ln1046">	if (error != 0) {</a>
<a name="ln1047">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1048">		    &quot;could not allocate DMA'able memory for CMB block.\n&quot;);</a>
<a name="ln1049">		goto fail;</a>
<a name="ln1050">	}</a>
<a name="ln1051">	ctx.age_busaddr = 0;</a>
<a name="ln1052">	error = bus_dmamap_load(sc-&gt;age_cdata.age_cmb_block_tag,</a>
<a name="ln1053">	    sc-&gt;age_cdata.age_cmb_block_map, sc-&gt;age_rdata.age_cmb_block,</a>
<a name="ln1054">	    AGE_CMB_BLOCK_SZ, age_dmamap_cb, &amp;ctx, 0);</a>
<a name="ln1055">	if (error != 0 || ctx.age_busaddr == 0) {</a>
<a name="ln1056">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1057">		    &quot;could not load DMA'able memory for CMB block.\n&quot;);</a>
<a name="ln1058">		goto fail;</a>
<a name="ln1059">	}</a>
<a name="ln1060">	sc-&gt;age_rdata.age_cmb_block_paddr = ctx.age_busaddr;</a>
<a name="ln1061">	/* SMB block */</a>
<a name="ln1062">	error = bus_dmamem_alloc(sc-&gt;age_cdata.age_smb_block_tag,</a>
<a name="ln1063">	    (void **)&amp;sc-&gt;age_rdata.age_smb_block,</a>
<a name="ln1064">	    BUS_DMA_WAITOK | BUS_DMA_ZERO | BUS_DMA_COHERENT,</a>
<a name="ln1065">	    &amp;sc-&gt;age_cdata.age_smb_block_map);</a>
<a name="ln1066">	if (error != 0) {</a>
<a name="ln1067">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1068">		    &quot;could not allocate DMA'able memory for SMB block.\n&quot;);</a>
<a name="ln1069">		goto fail;</a>
<a name="ln1070">	}</a>
<a name="ln1071">	ctx.age_busaddr = 0;</a>
<a name="ln1072">	error = bus_dmamap_load(sc-&gt;age_cdata.age_smb_block_tag,</a>
<a name="ln1073">	    sc-&gt;age_cdata.age_smb_block_map, sc-&gt;age_rdata.age_smb_block,</a>
<a name="ln1074">	    AGE_SMB_BLOCK_SZ, age_dmamap_cb, &amp;ctx, 0);</a>
<a name="ln1075">	if (error != 0 || ctx.age_busaddr == 0) {</a>
<a name="ln1076">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1077">		    &quot;could not load DMA'able memory for SMB block.\n&quot;);</a>
<a name="ln1078">		goto fail;</a>
<a name="ln1079">	}</a>
<a name="ln1080">	sc-&gt;age_rdata.age_smb_block_paddr = ctx.age_busaddr;</a>
<a name="ln1081"> </a>
<a name="ln1082">	/*</a>
<a name="ln1083">	 * All ring buffer and DMA blocks should have the same</a>
<a name="ln1084">	 * high address part of 64bit DMA address space.</a>
<a name="ln1085">	 */</a>
<a name="ln1086">	if (lowaddr != BUS_SPACE_MAXADDR_32BIT &amp;&amp;</a>
<a name="ln1087">	    (error = age_check_boundary(sc)) != 0) {</a>
<a name="ln1088">		device_printf(sc-&gt;age_dev, &quot;4GB boundary crossed, &quot;</a>
<a name="ln1089">		    &quot;switching to 32bit DMA addressing mode.\n&quot;);</a>
<a name="ln1090">		age_dma_free(sc);</a>
<a name="ln1091">		/* Limit DMA address space to 32bit and try again. */</a>
<a name="ln1092">		lowaddr = BUS_SPACE_MAXADDR_32BIT;</a>
<a name="ln1093">		goto again;</a>
<a name="ln1094">	}</a>
<a name="ln1095"> </a>
<a name="ln1096">	/*</a>
<a name="ln1097">	 * Create Tx/Rx buffer parent tag.</a>
<a name="ln1098">	 * L1 supports full 64bit DMA addressing in Tx/Rx buffers</a>
<a name="ln1099">	 * so it needs separate parent DMA tag.</a>
<a name="ln1100">	 * XXX</a>
<a name="ln1101">	 * It seems enabling 64bit DMA causes data corruption. Limit</a>
<a name="ln1102">	 * DMA address space to 32bit.</a>
<a name="ln1103">	 */</a>
<a name="ln1104">	error = bus_dma_tag_create(</a>
<a name="ln1105">	    bus_get_dma_tag(sc-&gt;age_dev), /* parent */</a>
<a name="ln1106">	    1, 0,			/* alignment, boundary */</a>
<a name="ln1107">	    BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln1108">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln1109">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln1110">	    BUS_SPACE_MAXSIZE_32BIT,	/* maxsize */</a>
<a name="ln1111">	    0,				/* nsegments */</a>
<a name="ln1112">	    BUS_SPACE_MAXSIZE_32BIT,	/* maxsegsize */</a>
<a name="ln1113">	    0,				/* flags */</a>
<a name="ln1114">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln1115">	    &amp;sc-&gt;age_cdata.age_buffer_tag);</a>
<a name="ln1116">	if (error != 0) {</a>
<a name="ln1117">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1118">		    &quot;could not create parent buffer DMA tag.\n&quot;);</a>
<a name="ln1119">		goto fail;</a>
<a name="ln1120">	}</a>
<a name="ln1121"> </a>
<a name="ln1122">	/* Create tag for Tx buffers. */</a>
<a name="ln1123">	error = bus_dma_tag_create(</a>
<a name="ln1124">	    sc-&gt;age_cdata.age_buffer_tag, /* parent */</a>
<a name="ln1125">	    1, 0,			/* alignment, boundary */</a>
<a name="ln1126">	    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln1127">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln1128">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln1129">	    AGE_TSO_MAXSIZE,		/* maxsize */</a>
<a name="ln1130">	    AGE_MAXTXSEGS,		/* nsegments */</a>
<a name="ln1131">	    AGE_TSO_MAXSEGSIZE,		/* maxsegsize */</a>
<a name="ln1132">	    0,				/* flags */</a>
<a name="ln1133">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln1134">	    &amp;sc-&gt;age_cdata.age_tx_tag);</a>
<a name="ln1135">	if (error != 0) {</a>
<a name="ln1136">		device_printf(sc-&gt;age_dev, &quot;could not create Tx DMA tag.\n&quot;);</a>
<a name="ln1137">		goto fail;</a>
<a name="ln1138">	}</a>
<a name="ln1139"> </a>
<a name="ln1140">	/* Create tag for Rx buffers. */</a>
<a name="ln1141">	error = bus_dma_tag_create(</a>
<a name="ln1142">	    sc-&gt;age_cdata.age_buffer_tag, /* parent */</a>
<a name="ln1143">	    AGE_RX_BUF_ALIGN, 0,	/* alignment, boundary */</a>
<a name="ln1144">	    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln1145">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln1146">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln1147">	    MCLBYTES,			/* maxsize */</a>
<a name="ln1148">	    1,				/* nsegments */</a>
<a name="ln1149">	    MCLBYTES,			/* maxsegsize */</a>
<a name="ln1150">	    0,				/* flags */</a>
<a name="ln1151">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln1152">	    &amp;sc-&gt;age_cdata.age_rx_tag);</a>
<a name="ln1153">	if (error != 0) {</a>
<a name="ln1154">		device_printf(sc-&gt;age_dev, &quot;could not create Rx DMA tag.\n&quot;);</a>
<a name="ln1155">		goto fail;</a>
<a name="ln1156">	}</a>
<a name="ln1157"> </a>
<a name="ln1158">	/* Create DMA maps for Tx buffers. */</a>
<a name="ln1159">	for (i = 0; i &lt; AGE_TX_RING_CNT; i++) {</a>
<a name="ln1160">		txd = &amp;sc-&gt;age_cdata.age_txdesc[i];</a>
<a name="ln1161">		txd-&gt;tx_m = NULL;</a>
<a name="ln1162">		txd-&gt;tx_dmamap = NULL;</a>
<a name="ln1163">		error = bus_dmamap_create(sc-&gt;age_cdata.age_tx_tag, 0,</a>
<a name="ln1164">		    &amp;txd-&gt;tx_dmamap);</a>
<a name="ln1165">		if (error != 0) {</a>
<a name="ln1166">			device_printf(sc-&gt;age_dev,</a>
<a name="ln1167">			    &quot;could not create Tx dmamap.\n&quot;);</a>
<a name="ln1168">			goto fail;</a>
<a name="ln1169">		}</a>
<a name="ln1170">	}</a>
<a name="ln1171">	/* Create DMA maps for Rx buffers. */</a>
<a name="ln1172">	if ((error = bus_dmamap_create(sc-&gt;age_cdata.age_rx_tag, 0,</a>
<a name="ln1173">	    &amp;sc-&gt;age_cdata.age_rx_sparemap)) != 0) {</a>
<a name="ln1174">		device_printf(sc-&gt;age_dev,</a>
<a name="ln1175">		    &quot;could not create spare Rx dmamap.\n&quot;);</a>
<a name="ln1176">		goto fail;</a>
<a name="ln1177">	}</a>
<a name="ln1178">	for (i = 0; i &lt; AGE_RX_RING_CNT; i++) {</a>
<a name="ln1179">		rxd = &amp;sc-&gt;age_cdata.age_rxdesc[i];</a>
<a name="ln1180">		rxd-&gt;rx_m = NULL;</a>
<a name="ln1181">		rxd-&gt;rx_dmamap = NULL;</a>
<a name="ln1182">		error = bus_dmamap_create(sc-&gt;age_cdata.age_rx_tag, 0,</a>
<a name="ln1183">		    &amp;rxd-&gt;rx_dmamap);</a>
<a name="ln1184">		if (error != 0) {</a>
<a name="ln1185">			device_printf(sc-&gt;age_dev,</a>
<a name="ln1186">			    &quot;could not create Rx dmamap.\n&quot;);</a>
<a name="ln1187">			goto fail;</a>
<a name="ln1188">		}</a>
<a name="ln1189">	}</a>
<a name="ln1190"> </a>
<a name="ln1191">fail:</a>
<a name="ln1192">	return (error);</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195">static void</a>
<a name="ln1196">age_dma_free(struct age_softc *sc)</a>
<a name="ln1197">{</a>
<a name="ln1198">	struct age_txdesc *txd;</a>
<a name="ln1199">	struct age_rxdesc *rxd;</a>
<a name="ln1200">	int i;</a>
<a name="ln1201"> </a>
<a name="ln1202">	/* Tx buffers */</a>
<a name="ln1203">	if (sc-&gt;age_cdata.age_tx_tag != NULL) {</a>
<a name="ln1204">		for (i = 0; i &lt; AGE_TX_RING_CNT; i++) {</a>
<a name="ln1205">			txd = &amp;sc-&gt;age_cdata.age_txdesc[i];</a>
<a name="ln1206">			if (txd-&gt;tx_dmamap != NULL) {</a>
<a name="ln1207">				bus_dmamap_destroy(sc-&gt;age_cdata.age_tx_tag,</a>
<a name="ln1208">				    txd-&gt;tx_dmamap);</a>
<a name="ln1209">				txd-&gt;tx_dmamap = NULL;</a>
<a name="ln1210">			}</a>
<a name="ln1211">		}</a>
<a name="ln1212">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_tx_tag);</a>
<a name="ln1213">		sc-&gt;age_cdata.age_tx_tag = NULL;</a>
<a name="ln1214">	}</a>
<a name="ln1215">	/* Rx buffers */</a>
<a name="ln1216">	if (sc-&gt;age_cdata.age_rx_tag != NULL) {</a>
<a name="ln1217">		for (i = 0; i &lt; AGE_RX_RING_CNT; i++) {</a>
<a name="ln1218">			rxd = &amp;sc-&gt;age_cdata.age_rxdesc[i];</a>
<a name="ln1219">			if (rxd-&gt;rx_dmamap != NULL) {</a>
<a name="ln1220">				bus_dmamap_destroy(sc-&gt;age_cdata.age_rx_tag,</a>
<a name="ln1221">				    rxd-&gt;rx_dmamap);</a>
<a name="ln1222">				rxd-&gt;rx_dmamap = NULL;</a>
<a name="ln1223">			}</a>
<a name="ln1224">		}</a>
<a name="ln1225">		if (sc-&gt;age_cdata.age_rx_sparemap != NULL) {</a>
<a name="ln1226">			bus_dmamap_destroy(sc-&gt;age_cdata.age_rx_tag,</a>
<a name="ln1227">			    sc-&gt;age_cdata.age_rx_sparemap);</a>
<a name="ln1228">			sc-&gt;age_cdata.age_rx_sparemap = NULL;</a>
<a name="ln1229">		}</a>
<a name="ln1230">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_rx_tag);</a>
<a name="ln1231">		sc-&gt;age_cdata.age_rx_tag = NULL;</a>
<a name="ln1232">	}</a>
<a name="ln1233">	/* Tx ring. */</a>
<a name="ln1234">	if (sc-&gt;age_cdata.age_tx_ring_tag != NULL) {</a>
<a name="ln1235">		if (sc-&gt;age_rdata.age_tx_ring_paddr != 0)</a>
<a name="ln1236">			bus_dmamap_unload(sc-&gt;age_cdata.age_tx_ring_tag,</a>
<a name="ln1237">			    sc-&gt;age_cdata.age_tx_ring_map);</a>
<a name="ln1238">		if (sc-&gt;age_rdata.age_tx_ring != NULL)</a>
<a name="ln1239">			bus_dmamem_free(sc-&gt;age_cdata.age_tx_ring_tag,</a>
<a name="ln1240">			    sc-&gt;age_rdata.age_tx_ring,</a>
<a name="ln1241">			    sc-&gt;age_cdata.age_tx_ring_map);</a>
<a name="ln1242">		sc-&gt;age_rdata.age_tx_ring_paddr = 0;</a>
<a name="ln1243">		sc-&gt;age_rdata.age_tx_ring = NULL;</a>
<a name="ln1244">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_tx_ring_tag);</a>
<a name="ln1245">		sc-&gt;age_cdata.age_tx_ring_tag = NULL;</a>
<a name="ln1246">	}</a>
<a name="ln1247">	/* Rx ring. */</a>
<a name="ln1248">	if (sc-&gt;age_cdata.age_rx_ring_tag != NULL) {</a>
<a name="ln1249">		if (sc-&gt;age_rdata.age_rx_ring_paddr != 0)</a>
<a name="ln1250">			bus_dmamap_unload(sc-&gt;age_cdata.age_rx_ring_tag,</a>
<a name="ln1251">			    sc-&gt;age_cdata.age_rx_ring_map);</a>
<a name="ln1252">		if (sc-&gt;age_rdata.age_rx_ring != NULL)</a>
<a name="ln1253">			bus_dmamem_free(sc-&gt;age_cdata.age_rx_ring_tag,</a>
<a name="ln1254">			    sc-&gt;age_rdata.age_rx_ring,</a>
<a name="ln1255">			    sc-&gt;age_cdata.age_rx_ring_map);</a>
<a name="ln1256">		sc-&gt;age_rdata.age_rx_ring_paddr = 0;</a>
<a name="ln1257">		sc-&gt;age_rdata.age_rx_ring = NULL;</a>
<a name="ln1258">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_rx_ring_tag);</a>
<a name="ln1259">		sc-&gt;age_cdata.age_rx_ring_tag = NULL;</a>
<a name="ln1260">	}</a>
<a name="ln1261">	/* Rx return ring. */</a>
<a name="ln1262">	if (sc-&gt;age_cdata.age_rr_ring_tag != NULL) {</a>
<a name="ln1263">		if (sc-&gt;age_rdata.age_rr_ring_paddr != 0)</a>
<a name="ln1264">			bus_dmamap_unload(sc-&gt;age_cdata.age_rr_ring_tag,</a>
<a name="ln1265">			    sc-&gt;age_cdata.age_rr_ring_map);</a>
<a name="ln1266">		if (sc-&gt;age_rdata.age_rr_ring != NULL)</a>
<a name="ln1267">			bus_dmamem_free(sc-&gt;age_cdata.age_rr_ring_tag,</a>
<a name="ln1268">			    sc-&gt;age_rdata.age_rr_ring,</a>
<a name="ln1269">			    sc-&gt;age_cdata.age_rr_ring_map);</a>
<a name="ln1270">		sc-&gt;age_rdata.age_rr_ring_paddr = 0;</a>
<a name="ln1271">		sc-&gt;age_rdata.age_rr_ring = NULL;</a>
<a name="ln1272">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_rr_ring_tag);</a>
<a name="ln1273">		sc-&gt;age_cdata.age_rr_ring_tag = NULL;</a>
<a name="ln1274">	}</a>
<a name="ln1275">	/* CMB block */</a>
<a name="ln1276">	if (sc-&gt;age_cdata.age_cmb_block_tag != NULL) {</a>
<a name="ln1277">		if (sc-&gt;age_rdata.age_cmb_block_paddr != 0)</a>
<a name="ln1278">			bus_dmamap_unload(sc-&gt;age_cdata.age_cmb_block_tag,</a>
<a name="ln1279">			    sc-&gt;age_cdata.age_cmb_block_map);</a>
<a name="ln1280">		if (sc-&gt;age_rdata.age_cmb_block != NULL)</a>
<a name="ln1281">			bus_dmamem_free(sc-&gt;age_cdata.age_cmb_block_tag,</a>
<a name="ln1282">			    sc-&gt;age_rdata.age_cmb_block,</a>
<a name="ln1283">			    sc-&gt;age_cdata.age_cmb_block_map);</a>
<a name="ln1284">		sc-&gt;age_rdata.age_cmb_block_paddr = 0;</a>
<a name="ln1285">		sc-&gt;age_rdata.age_cmb_block = NULL;</a>
<a name="ln1286">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_cmb_block_tag);</a>
<a name="ln1287">		sc-&gt;age_cdata.age_cmb_block_tag = NULL;</a>
<a name="ln1288">	}</a>
<a name="ln1289">	/* SMB block */</a>
<a name="ln1290">	if (sc-&gt;age_cdata.age_smb_block_tag != NULL) {</a>
<a name="ln1291">		if (sc-&gt;age_rdata.age_smb_block_paddr != 0)</a>
<a name="ln1292">			bus_dmamap_unload(sc-&gt;age_cdata.age_smb_block_tag,</a>
<a name="ln1293">			    sc-&gt;age_cdata.age_smb_block_map);</a>
<a name="ln1294">		if (sc-&gt;age_rdata.age_smb_block != NULL)</a>
<a name="ln1295">			bus_dmamem_free(sc-&gt;age_cdata.age_smb_block_tag,</a>
<a name="ln1296">			    sc-&gt;age_rdata.age_smb_block,</a>
<a name="ln1297">			    sc-&gt;age_cdata.age_smb_block_map);</a>
<a name="ln1298">		sc-&gt;age_rdata.age_smb_block_paddr = 0;</a>
<a name="ln1299">		sc-&gt;age_rdata.age_smb_block = NULL;</a>
<a name="ln1300">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_smb_block_tag);</a>
<a name="ln1301">		sc-&gt;age_cdata.age_smb_block_tag = NULL;</a>
<a name="ln1302">	}</a>
<a name="ln1303"> </a>
<a name="ln1304">	if (sc-&gt;age_cdata.age_buffer_tag != NULL) {</a>
<a name="ln1305">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_buffer_tag);</a>
<a name="ln1306">		sc-&gt;age_cdata.age_buffer_tag = NULL;</a>
<a name="ln1307">	}</a>
<a name="ln1308">	if (sc-&gt;age_cdata.age_parent_tag != NULL) {</a>
<a name="ln1309">		bus_dma_tag_destroy(sc-&gt;age_cdata.age_parent_tag);</a>
<a name="ln1310">		sc-&gt;age_cdata.age_parent_tag = NULL;</a>
<a name="ln1311">	}</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314">/*</a>
<a name="ln1315"> *	Make sure the interface is stopped at reboot time.</a>
<a name="ln1316"> */</a>
<a name="ln1317">static int</a>
<a name="ln1318">age_shutdown(device_t dev)</a>
<a name="ln1319">{</a>
<a name="ln1320"> </a>
<a name="ln1321">	return (age_suspend(dev));</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324">static void</a>
<a name="ln1325">age_setwol(struct age_softc *sc)</a>
<a name="ln1326">{</a>
<a name="ln1327">	struct ifnet *ifp;</a>
<a name="ln1328">	struct mii_data *mii;</a>
<a name="ln1329">	uint32_t reg, pmcs;</a>
<a name="ln1330">	uint16_t pmstat;</a>
<a name="ln1331">	int aneg, i, pmc;</a>
<a name="ln1332"> </a>
<a name="ln1333">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln1334"> </a>
<a name="ln1335">	if (pci_find_cap(sc-&gt;age_dev, PCIY_PMG, &amp;pmc) != 0) {</a>
<a name="ln1336">		CSR_WRITE_4(sc, AGE_WOL_CFG, 0);</a>
<a name="ln1337">		/*</a>
<a name="ln1338">		 * No PME capability, PHY power down.</a>
<a name="ln1339">		 * XXX</a>
<a name="ln1340">		 * Due to an unknown reason powering down PHY resulted</a>
<a name="ln1341">		 * in unexpected results such as inaccessbility of</a>
<a name="ln1342">		 * hardware of freshly rebooted system. Disable</a>
<a name="ln1343">		 * powering down PHY until I got more information for</a>
<a name="ln1344">		 * Attansic/Atheros PHY hardwares.</a>
<a name="ln1345">		 */</a>
<a name="ln1346">#ifdef notyet</a>
<a name="ln1347">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln1348">		    MII_BMCR, BMCR_PDOWN);</a>
<a name="ln1349">#endif</a>
<a name="ln1350">		return;</a>
<a name="ln1351">	}</a>
<a name="ln1352"> </a>
<a name="ln1353">	ifp = sc-&gt;age_ifp;</a>
<a name="ln1354">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) != 0) {</a>
<a name="ln1355">		/*</a>
<a name="ln1356">		 * Note, this driver resets the link speed to 10/100Mbps with</a>
<a name="ln1357">		 * auto-negotiation but we don't know whether that operation</a>
<a name="ln1358">		 * would succeed or not as it have no control after powering</a>
<a name="ln1359">		 * off. If the renegotiation fail WOL may not work. Running</a>
<a name="ln1360">		 * at 1Gbps will draw more power than 375mA at 3.3V which is</a>
<a name="ln1361">		 * specified in PCI specification and that would result in</a>
<a name="ln1362">		 * complete shutdowning power to ethernet controller.</a>
<a name="ln1363">		 *</a>
<a name="ln1364">		 * TODO</a>
<a name="ln1365">		 *  Save current negotiated media speed/duplex/flow-control</a>
<a name="ln1366">		 *  to softc and restore the same link again after resuming.</a>
<a name="ln1367">		 *  PHY handling such as power down/resetting to 100Mbps</a>
<a name="ln1368">		 *  may be better handled in suspend method in phy driver.</a>
<a name="ln1369">		 */</a>
<a name="ln1370">		mii = device_get_softc(sc-&gt;age_miibus);</a>
<a name="ln1371">		mii_pollstat(mii);</a>
<a name="ln1372">		aneg = 0;</a>
<a name="ln1373">		if ((mii-&gt;mii_media_status &amp; IFM_AVALID) != 0) {</a>
<a name="ln1374">			switch IFM_SUBTYPE(mii-&gt;mii_media_active) {</a>
<a name="ln1375">			case IFM_10_T:</a>
<a name="ln1376">			case IFM_100_TX:</a>
<a name="ln1377">				goto got_link;</a>
<a name="ln1378">			case IFM_1000_T:</a>
<a name="ln1379">				aneg++;</a>
<a name="ln1380">			default:</a>
<a name="ln1381">				break;</a>
<a name="ln1382">			}</a>
<a name="ln1383">		}</a>
<a name="ln1384">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln1385">		    MII_100T2CR, 0);</a>
<a name="ln1386">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln1387">		    MII_ANAR, ANAR_TX_FD | ANAR_TX | ANAR_10_FD |</a>
<a name="ln1388">		    ANAR_10 | ANAR_CSMA);</a>
<a name="ln1389">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln1390">		    MII_BMCR, BMCR_RESET | BMCR_AUTOEN | BMCR_STARTNEG);</a>
<a name="ln1391">		DELAY(1000);</a>
<a name="ln1392">		if (aneg != 0) {</a>
<a name="ln1393">			/* Poll link state until age(4) get a 10/100 link. */</a>
<a name="ln1394">			for (i = 0; i &lt; MII_ANEGTICKS_GIGE; i++) {</a>
<a name="ln1395">				mii_pollstat(mii);</a>
<a name="ln1396">				if ((mii-&gt;mii_media_status &amp; IFM_AVALID) != 0) {</a>
<a name="ln1397">					switch (IFM_SUBTYPE(</a>
<a name="ln1398">					    mii-&gt;mii_media_active)) {</a>
<a name="ln1399">					case IFM_10_T:</a>
<a name="ln1400">					case IFM_100_TX:</a>
<a name="ln1401">						age_mac_config(sc);</a>
<a name="ln1402">						goto got_link;</a>
<a name="ln1403">					default:</a>
<a name="ln1404">						break;</a>
<a name="ln1405">					}</a>
<a name="ln1406">				}</a>
<a name="ln1407">				AGE_UNLOCK(sc);</a>
<a name="ln1408">				pause(&quot;agelnk&quot;, hz);</a>
<a name="ln1409">				AGE_LOCK(sc);</a>
<a name="ln1410">			}</a>
<a name="ln1411">			if (i == MII_ANEGTICKS_GIGE)</a>
<a name="ln1412">				device_printf(sc-&gt;age_dev,</a>
<a name="ln1413">				    &quot;establishing link failed, &quot;</a>
<a name="ln1414">				    &quot;WOL may not work!&quot;);</a>
<a name="ln1415">		}</a>
<a name="ln1416">		/*</a>
<a name="ln1417">		 * No link, force MAC to have 100Mbps, full-duplex link.</a>
<a name="ln1418">		 * This is the last resort and may/may not work.</a>
<a name="ln1419">		 */</a>
<a name="ln1420">		mii-&gt;mii_media_status = IFM_AVALID | IFM_ACTIVE;</a>
<a name="ln1421">		mii-&gt;mii_media_active = IFM_ETHER | IFM_100_TX | IFM_FDX;</a>
<a name="ln1422">		age_mac_config(sc);</a>
<a name="ln1423">	}</a>
<a name="ln1424"> </a>
<a name="ln1425">got_link:</a>
<a name="ln1426">	pmcs = 0;</a>
<a name="ln1427">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL_MAGIC) != 0)</a>
<a name="ln1428">		pmcs |= WOL_CFG_MAGIC | WOL_CFG_MAGIC_ENB;</a>
<a name="ln1429">	CSR_WRITE_4(sc, AGE_WOL_CFG, pmcs);</a>
<a name="ln1430">	reg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln1431">	reg &amp;= ~(MAC_CFG_DBG | MAC_CFG_PROMISC);</a>
<a name="ln1432">	reg &amp;= ~(MAC_CFG_ALLMULTI | MAC_CFG_BCAST);</a>
<a name="ln1433">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL_MCAST) != 0)</a>
<a name="ln1434">		reg |= MAC_CFG_ALLMULTI | MAC_CFG_BCAST;</a>
<a name="ln1435">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) != 0) {</a>
<a name="ln1436">		reg |= MAC_CFG_RX_ENB;</a>
<a name="ln1437">		CSR_WRITE_4(sc, AGE_MAC_CFG, reg);</a>
<a name="ln1438">	}</a>
<a name="ln1439"> </a>
<a name="ln1440">	/* Request PME. */</a>
<a name="ln1441">	pmstat = pci_read_config(sc-&gt;age_dev, pmc + PCIR_POWER_STATUS, 2);</a>
<a name="ln1442">	pmstat &amp;= ~(PCIM_PSTAT_PME | PCIM_PSTAT_PMEENABLE);</a>
<a name="ln1443">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) != 0)</a>
<a name="ln1444">		pmstat |= PCIM_PSTAT_PME | PCIM_PSTAT_PMEENABLE;</a>
<a name="ln1445">	pci_write_config(sc-&gt;age_dev, pmc + PCIR_POWER_STATUS, pmstat, 2);</a>
<a name="ln1446">#ifdef notyet</a>
<a name="ln1447">	/* See above for powering down PHY issues. */</a>
<a name="ln1448">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) == 0) {</a>
<a name="ln1449">		/* No WOL, PHY power down. */</a>
<a name="ln1450">		age_miibus_writereg(sc-&gt;age_dev, sc-&gt;age_phyaddr,</a>
<a name="ln1451">		    MII_BMCR, BMCR_PDOWN);</a>
<a name="ln1452">	}</a>
<a name="ln1453">#endif</a>
<a name="ln1454">}</a>
<a name="ln1455"> </a>
<a name="ln1456">static int</a>
<a name="ln1457">age_suspend(device_t dev)</a>
<a name="ln1458">{</a>
<a name="ln1459">	struct age_softc *sc;</a>
<a name="ln1460"> </a>
<a name="ln1461">	sc = device_get_softc(dev);</a>
<a name="ln1462"> </a>
<a name="ln1463">	AGE_LOCK(sc);</a>
<a name="ln1464">	age_stop(sc);</a>
<a name="ln1465">	age_setwol(sc);</a>
<a name="ln1466">	AGE_UNLOCK(sc);</a>
<a name="ln1467"> </a>
<a name="ln1468">	return (0);</a>
<a name="ln1469">}</a>
<a name="ln1470"> </a>
<a name="ln1471">static int</a>
<a name="ln1472">age_resume(device_t dev)</a>
<a name="ln1473">{</a>
<a name="ln1474">	struct age_softc *sc;</a>
<a name="ln1475">	struct ifnet *ifp;</a>
<a name="ln1476"> </a>
<a name="ln1477">	sc = device_get_softc(dev);</a>
<a name="ln1478"> </a>
<a name="ln1479">	AGE_LOCK(sc);</a>
<a name="ln1480">	age_phy_reset(sc);</a>
<a name="ln1481">	ifp = sc-&gt;age_ifp;</a>
<a name="ln1482">	if ((ifp-&gt;if_flags &amp; IFF_UP) != 0)</a>
<a name="ln1483">		age_init_locked(sc);</a>
<a name="ln1484"> </a>
<a name="ln1485">	AGE_UNLOCK(sc);</a>
<a name="ln1486"> </a>
<a name="ln1487">	return (0);</a>
<a name="ln1488">}</a>
<a name="ln1489"> </a>
<a name="ln1490">static int</a>
<a name="ln1491">age_encap(struct age_softc *sc, struct mbuf **m_head)</a>
<a name="ln1492">{</a>
<a name="ln1493">	struct age_txdesc *txd, *txd_last;</a>
<a name="ln1494">	struct tx_desc *desc;</a>
<a name="ln1495">	struct mbuf *m;</a>
<a name="ln1496">	struct ip *ip;</a>
<a name="ln1497">	struct tcphdr *tcp;</a>
<a name="ln1498">	bus_dma_segment_t txsegs[AGE_MAXTXSEGS];</a>
<a name="ln1499">	bus_dmamap_t map;</a>
<a name="ln1500">	uint32_t cflags, hdrlen, ip_off, poff, vtag;</a>
<a name="ln1501">	int error, i, nsegs, prod, si;</a>
<a name="ln1502"> </a>
<a name="ln1503">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln1504"> </a>
<a name="ln1505">	M_ASSERTPKTHDR((*m_head));</a>
<a name="ln1506"> </a>
<a name="ln1507">	m = *m_head;</a>
<a name="ln1508">	ip = NULL;</a>
<a name="ln1509">	tcp = NULL;</a>
<a name="ln1510">	cflags = vtag = 0;</a>
<a name="ln1511">	ip_off = poff = 0;</a>
<a name="ln1512">	if ((m-&gt;m_pkthdr.csum_flags &amp; (AGE_CSUM_FEATURES | CSUM_TSO)) != 0) {</a>
<a name="ln1513">		/*</a>
<a name="ln1514">		 * L1 requires offset of TCP/UDP payload in its Tx</a>
<a name="ln1515">		 * descriptor to perform hardware Tx checksum offload.</a>
<a name="ln1516">		 * Additionally, TSO requires IP/TCP header size and</a>
<a name="ln1517">		 * modification of IP/TCP header in order to make TSO</a>
<a name="ln1518">		 * engine work. This kind of operation takes many CPU</a>
<a name="ln1519">		 * cycles on FreeBSD so fast host CPU is needed to get</a>
<a name="ln1520">		 * smooth TSO performance.</a>
<a name="ln1521">		 */</a>
<a name="ln1522">		struct ether_header *eh;</a>
<a name="ln1523"> </a>
<a name="ln1524">		if (M_WRITABLE(m) == 0) {</a>
<a name="ln1525">			/* Get a writable copy. */</a>
<a name="ln1526">			m = m_dup(*m_head, M_NOWAIT);</a>
<a name="ln1527">			/* Release original mbufs. */</a>
<a name="ln1528">			m_freem(*m_head);</a>
<a name="ln1529">			if (m == NULL) {</a>
<a name="ln1530">				*m_head = NULL;</a>
<a name="ln1531">				return (ENOBUFS);</a>
<a name="ln1532">			}</a>
<a name="ln1533">			*m_head = m;</a>
<a name="ln1534">		}</a>
<a name="ln1535">		ip_off = sizeof(struct ether_header);</a>
<a name="ln1536">		m = m_pullup(m, ip_off);</a>
<a name="ln1537">		if (m == NULL) {</a>
<a name="ln1538">			*m_head = NULL;</a>
<a name="ln1539">			return (ENOBUFS);</a>
<a name="ln1540">		}</a>
<a name="ln1541">		eh = mtod(m, struct ether_header *);</a>
<a name="ln1542">		/*</a>
<a name="ln1543">		 * Check if hardware VLAN insertion is off.</a>
<a name="ln1544">		 * Additional check for LLC/SNAP frame?</a>
<a name="ln1545">		 */</a>
<a name="ln1546">		if (eh-&gt;ether_type == htons(ETHERTYPE_VLAN)) {</a>
<a name="ln1547">			ip_off = sizeof(struct ether_vlan_header);</a>
<a name="ln1548">			m = m_pullup(m, ip_off);</a>
<a name="ln1549">			if (m == NULL) {</a>
<a name="ln1550">				*m_head = NULL;</a>
<a name="ln1551">				return (ENOBUFS);</a>
<a name="ln1552">			}</a>
<a name="ln1553">		}</a>
<a name="ln1554">		m = m_pullup(m, ip_off + sizeof(struct ip));</a>
<a name="ln1555">		if (m == NULL) {</a>
<a name="ln1556">			*m_head = NULL;</a>
<a name="ln1557">			return (ENOBUFS);</a>
<a name="ln1558">		}</a>
<a name="ln1559">		ip = (struct ip *)(mtod(m, char *) + ip_off);</a>
<a name="ln1560">		poff = ip_off + (ip-&gt;ip_hl &lt;&lt; 2);</a>
<a name="ln1561">		if ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) != 0) {</a>
<a name="ln1562">			m = m_pullup(m, poff + sizeof(struct tcphdr));</a>
<a name="ln1563">			if (m == NULL) {</a>
<a name="ln1564">				*m_head = NULL;</a>
<a name="ln1565">				return (ENOBUFS);</a>
<a name="ln1566">			}</a>
<a name="ln1567">			tcp = (struct tcphdr *)(mtod(m, char *) + poff);</a>
<a name="ln1568">			m = m_pullup(m, poff + (tcp-&gt;th_off &lt;&lt; 2));</a>
<a name="ln1569">			if (m == NULL) {</a>
<a name="ln1570">				*m_head = NULL;</a>
<a name="ln1571">				return (ENOBUFS);</a>
<a name="ln1572">			}</a>
<a name="ln1573">			/*</a>
<a name="ln1574">			 * L1 requires IP/TCP header size and offset as</a>
<a name="ln1575">			 * well as TCP pseudo checksum which complicates</a>
<a name="ln1576">			 * TSO configuration. I guess this comes from the</a>
<a name="ln1577">			 * adherence to Microsoft NDIS Large Send</a>
<a name="ln1578">			 * specification which requires insertion of</a>
<a name="ln1579">			 * pseudo checksum by upper stack. The pseudo</a>
<a name="ln1580">			 * checksum that NDIS refers to doesn't include</a>
<a name="ln1581">			 * TCP payload length so age(4) should recompute</a>
<a name="ln1582">			 * the pseudo checksum here. Hopefully this wouldn't</a>
<a name="ln1583">			 * be much burden on modern CPUs.</a>
<a name="ln1584">			 * Reset IP checksum and recompute TCP pseudo</a>
<a name="ln1585">			 * checksum as NDIS specification said.</a>
<a name="ln1586">			 */</a>
<a name="ln1587">			ip = (struct ip *)(mtod(m, char *) + ip_off);</a>
<a name="ln1588">			tcp = (struct tcphdr *)(mtod(m, char *) + poff);</a>
<a name="ln1589">			ip-&gt;ip_sum = 0;</a>
<a name="ln1590">			tcp-&gt;th_sum = in_pseudo(ip-&gt;ip_src.s_addr,</a>
<a name="ln1591">			    ip-&gt;ip_dst.s_addr, htons(IPPROTO_TCP));</a>
<a name="ln1592">		}</a>
<a name="ln1593">		*m_head = m;</a>
<a name="ln1594">	}</a>
<a name="ln1595"> </a>
<a name="ln1596">	si = prod = sc-&gt;age_cdata.age_tx_prod;</a>
<a name="ln1597">	txd = &amp;sc-&gt;age_cdata.age_txdesc[prod];</a>
<a name="ln1598">	txd_last = txd;</a>
<a name="ln1599">	map = txd-&gt;tx_dmamap;</a>
<a name="ln1600"> </a>
<a name="ln1601">	error =  bus_dmamap_load_mbuf_sg(sc-&gt;age_cdata.age_tx_tag, map,</a>
<a name="ln1602">	    *m_head, txsegs, &amp;nsegs, 0);</a>
<a name="ln1603">	if (error == EFBIG) {</a>
<a name="ln1604">		m = m_collapse(*m_head, M_NOWAIT, AGE_MAXTXSEGS);</a>
<a name="ln1605">		if (m == NULL) {</a>
<a name="ln1606">			m_freem(*m_head);</a>
<a name="ln1607">			*m_head = NULL;</a>
<a name="ln1608">			return (ENOMEM);</a>
<a name="ln1609">		}</a>
<a name="ln1610">		*m_head = m;</a>
<a name="ln1611">		error = bus_dmamap_load_mbuf_sg(sc-&gt;age_cdata.age_tx_tag, map,</a>
<a name="ln1612">		    *m_head, txsegs, &amp;nsegs, 0);</a>
<a name="ln1613">		if (error != 0) {</a>
<a name="ln1614">			m_freem(*m_head);</a>
<a name="ln1615">			*m_head = NULL;</a>
<a name="ln1616">			return (error);</a>
<a name="ln1617">		}</a>
<a name="ln1618">	} else if (error != 0)</a>
<a name="ln1619">		return (error);</a>
<a name="ln1620">	if (nsegs == 0) {</a>
<a name="ln1621">		m_freem(*m_head);</a>
<a name="ln1622">		*m_head = NULL;</a>
<a name="ln1623">		return (EIO);</a>
<a name="ln1624">	}</a>
<a name="ln1625"> </a>
<a name="ln1626">	/* Check descriptor overrun. */</a>
<a name="ln1627">	if (sc-&gt;age_cdata.age_tx_cnt + nsegs &gt;= AGE_TX_RING_CNT - 2) {</a>
<a name="ln1628">		bus_dmamap_unload(sc-&gt;age_cdata.age_tx_tag, map);</a>
<a name="ln1629">		return (ENOBUFS);</a>
<a name="ln1630">	}</a>
<a name="ln1631"> </a>
<a name="ln1632">	m = *m_head;</a>
<a name="ln1633">	/* Configure VLAN hardware tag insertion. */</a>
<a name="ln1634">	if ((m-&gt;m_flags &amp; M_VLANTAG) != 0) {</a>
<a name="ln1635">		vtag = AGE_TX_VLAN_TAG(m-&gt;m_pkthdr.ether_vtag);</a>
<a name="ln1636">		vtag = ((vtag &lt;&lt; AGE_TD_VLAN_SHIFT) &amp; AGE_TD_VLAN_MASK);</a>
<a name="ln1637">		cflags |= AGE_TD_INSERT_VLAN_TAG;</a>
<a name="ln1638">	}</a>
<a name="ln1639"> </a>
<a name="ln1640">	desc = NULL;</a>
<a name="ln1641">	i = 0;</a>
<a name="ln1642">	if ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) != 0) {</a>
<a name="ln1643">		/* Request TSO and set MSS. */</a>
<a name="ln1644">		cflags |= AGE_TD_TSO_IPV4;</a>
<a name="ln1645">		cflags |= AGE_TD_IPCSUM | AGE_TD_TCPCSUM;</a>
<a name="ln1646">		cflags |= ((uint32_t)m-&gt;m_pkthdr.tso_segsz &lt;&lt;</a>
<a name="ln1647">		    AGE_TD_TSO_MSS_SHIFT);</a>
<a name="ln1648">		/* Set IP/TCP header size. */</a>
<a name="ln1649">		cflags |= ip-&gt;ip_hl &lt;&lt; AGE_TD_IPHDR_LEN_SHIFT;</a>
<a name="ln1650">		cflags |= tcp-&gt;th_off &lt;&lt; AGE_TD_TSO_TCPHDR_LEN_SHIFT;</a>
<a name="ln1651">		/*</a>
<a name="ln1652">		 * L1 requires the first buffer should only hold IP/TCP</a>
<a name="ln1653">		 * header data. TCP payload should be handled in other</a>
<a name="ln1654">		 * descriptors.</a>
<a name="ln1655">		 */</a>
<a name="ln1656">		hdrlen = poff + (tcp-&gt;th_off &lt;&lt; 2);</a>
<a name="ln1657">		desc = &amp;sc-&gt;age_rdata.age_tx_ring[prod];</a>
<a name="ln1658">		desc-&gt;addr = htole64(txsegs[0].ds_addr);</a>
<a name="ln1659">		desc-&gt;len = htole32(AGE_TX_BYTES(hdrlen) | vtag);</a>
<a name="ln1660">		desc-&gt;flags = htole32(cflags);</a>
<a name="ln1661">		sc-&gt;age_cdata.age_tx_cnt++;</a>
<a name="ln1662">		AGE_DESC_INC(prod, AGE_TX_RING_CNT);</a>
<a name="ln1663">		if (m-&gt;m_len - hdrlen &gt; 0) {</a>
<a name="ln1664">			/* Handle remaining payload of the 1st fragment. */</a>
<a name="ln1665">			desc = &amp;sc-&gt;age_rdata.age_tx_ring[prod];</a>
<a name="ln1666">			desc-&gt;addr = htole64(txsegs[0].ds_addr + hdrlen);</a>
<a name="ln1667">			desc-&gt;len = htole32(AGE_TX_BYTES(m-&gt;m_len - hdrlen) |</a>
<a name="ln1668">			    vtag);</a>
<a name="ln1669">			desc-&gt;flags = htole32(cflags);</a>
<a name="ln1670">			sc-&gt;age_cdata.age_tx_cnt++;</a>
<a name="ln1671">			AGE_DESC_INC(prod, AGE_TX_RING_CNT);</a>
<a name="ln1672">		}</a>
<a name="ln1673">		/* Handle remaining fragments. */</a>
<a name="ln1674">		i = 1;</a>
<a name="ln1675">	} else if ((m-&gt;m_pkthdr.csum_flags &amp; AGE_CSUM_FEATURES) != 0) {</a>
<a name="ln1676">		/* Configure Tx IP/TCP/UDP checksum offload. */</a>
<a name="ln1677">		cflags |= AGE_TD_CSUM;</a>
<a name="ln1678">		if ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_TCP) != 0)</a>
<a name="ln1679">			cflags |= AGE_TD_TCPCSUM;</a>
<a name="ln1680">		if ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_UDP) != 0)</a>
<a name="ln1681">			cflags |= AGE_TD_UDPCSUM;</a>
<a name="ln1682">		/* Set checksum start offset. */</a>
<a name="ln1683">		cflags |= (poff &lt;&lt; AGE_TD_CSUM_PLOADOFFSET_SHIFT);</a>
<a name="ln1684">		/* Set checksum insertion position of TCP/UDP. */</a>
<a name="ln1685">		cflags |= ((poff + m-&gt;m_pkthdr.csum_data) &lt;&lt;</a>
<a name="ln1686">		    AGE_TD_CSUM_XSUMOFFSET_SHIFT);</a>
<a name="ln1687">	}</a>
<a name="ln1688">	for (; i &lt; nsegs; i++) {</a>
<a name="ln1689">		desc = &amp;sc-&gt;age_rdata.age_tx_ring[prod];</a>
<a name="ln1690">		desc-&gt;addr = htole64(txsegs[i].ds_addr);</a>
<a name="ln1691">		desc-&gt;len = htole32(AGE_TX_BYTES(txsegs[i].ds_len) | vtag);</a>
<a name="ln1692">		desc-&gt;flags = htole32(cflags);</a>
<a name="ln1693">		sc-&gt;age_cdata.age_tx_cnt++;</a>
<a name="ln1694">		AGE_DESC_INC(prod, AGE_TX_RING_CNT);</a>
<a name="ln1695">	}</a>
<a name="ln1696">	/* Update producer index. */</a>
<a name="ln1697">	sc-&gt;age_cdata.age_tx_prod = prod;</a>
<a name="ln1698"> </a>
<a name="ln1699">	/* Set EOP on the last descriptor. */</a>
<a name="ln1700">	prod = (prod + AGE_TX_RING_CNT - 1) % AGE_TX_RING_CNT;</a>
<a name="ln1701">	desc = &amp;sc-&gt;age_rdata.age_tx_ring[prod];</a>
<a name="ln1702">	desc-&gt;flags |= htole32(AGE_TD_EOP);</a>
<a name="ln1703"> </a>
<a name="ln1704">	/* Lastly set TSO header and modify IP/TCP header for TSO operation. */</a>
<a name="ln1705">	if ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) != 0) {</a>
<a name="ln1706">		desc = &amp;sc-&gt;age_rdata.age_tx_ring[si];</a>
<a name="ln1707">		desc-&gt;flags |= htole32(AGE_TD_TSO_HDR);</a>
<a name="ln1708">	}</a>
<a name="ln1709"> </a>
<a name="ln1710">	/* Swap dmamap of the first and the last. */</a>
<a name="ln1711">	txd = &amp;sc-&gt;age_cdata.age_txdesc[prod];</a>
<a name="ln1712">	map = txd_last-&gt;tx_dmamap;</a>
<a name="ln1713">	txd_last-&gt;tx_dmamap = txd-&gt;tx_dmamap;</a>
<a name="ln1714">	txd-&gt;tx_dmamap = map;</a>
<a name="ln1715">	txd-&gt;tx_m = m;</a>
<a name="ln1716"> </a>
<a name="ln1717">	/* Sync descriptors. */</a>
<a name="ln1718">	bus_dmamap_sync(sc-&gt;age_cdata.age_tx_tag, map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1719">	bus_dmamap_sync(sc-&gt;age_cdata.age_tx_ring_tag,</a>
<a name="ln1720">	    sc-&gt;age_cdata.age_tx_ring_map,</a>
<a name="ln1721">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln1722"> </a>
<a name="ln1723">	return (0);</a>
<a name="ln1724">}</a>
<a name="ln1725"> </a>
<a name="ln1726">static void</a>
<a name="ln1727">age_start(struct ifnet *ifp)</a>
<a name="ln1728">{</a>
<a name="ln1729">        struct age_softc *sc;</a>
<a name="ln1730"> </a>
<a name="ln1731">	sc = ifp-&gt;if_softc;</a>
<a name="ln1732">	AGE_LOCK(sc);</a>
<a name="ln1733">	age_start_locked(ifp);</a>
<a name="ln1734">	AGE_UNLOCK(sc);</a>
<a name="ln1735">}</a>
<a name="ln1736"> </a>
<a name="ln1737">static void</a>
<a name="ln1738">age_start_locked(struct ifnet *ifp)</a>
<a name="ln1739">{</a>
<a name="ln1740">        struct age_softc *sc;</a>
<a name="ln1741">        struct mbuf *m_head;</a>
<a name="ln1742">	int enq;</a>
<a name="ln1743"> </a>
<a name="ln1744">	sc = ifp-&gt;if_softc;</a>
<a name="ln1745"> </a>
<a name="ln1746">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln1747"> </a>
<a name="ln1748">	if ((ifp-&gt;if_drv_flags &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln1749">	    IFF_DRV_RUNNING || (sc-&gt;age_flags &amp; AGE_FLAG_LINK) == 0)</a>
<a name="ln1750">		return;</a>
<a name="ln1751"> </a>
<a name="ln1752">	for (enq = 0; !IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd); ) {</a>
<a name="ln1753">		IFQ_DRV_DEQUEUE(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln1754">		if (m_head == NULL)</a>
<a name="ln1755">			break;</a>
<a name="ln1756">		/*</a>
<a name="ln1757">		 * Pack the data into the transmit ring. If we</a>
<a name="ln1758">		 * don't have room, set the OACTIVE flag and wait</a>
<a name="ln1759">		 * for the NIC to drain the ring.</a>
<a name="ln1760">		 */</a>
<a name="ln1761">		if (age_encap(sc, &amp;m_head)) {</a>
<a name="ln1762">			if (m_head == NULL)</a>
<a name="ln1763">				break;</a>
<a name="ln1764">			IFQ_DRV_PREPEND(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln1765">			ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln1766">			break;</a>
<a name="ln1767">		}</a>
<a name="ln1768"> </a>
<a name="ln1769">		enq++;</a>
<a name="ln1770">		/*</a>
<a name="ln1771">		 * If there's a BPF listener, bounce a copy of this frame</a>
<a name="ln1772">		 * to him.</a>
<a name="ln1773">		 */</a>
<a name="ln1774">		ETHER_BPF_MTAP(ifp, m_head);</a>
<a name="ln1775">	}</a>
<a name="ln1776"> </a>
<a name="ln1777">	if (enq &gt; 0) {</a>
<a name="ln1778">		/* Update mbox. */</a>
<a name="ln1779">		AGE_COMMIT_MBOX(sc);</a>
<a name="ln1780">		/* Set a timeout in case the chip goes out to lunch. */</a>
<a name="ln1781">		sc-&gt;age_watchdog_timer = AGE_TX_TIMEOUT;</a>
<a name="ln1782">	}</a>
<a name="ln1783">}</a>
<a name="ln1784"> </a>
<a name="ln1785">static void</a>
<a name="ln1786">age_watchdog(struct age_softc *sc)</a>
<a name="ln1787">{</a>
<a name="ln1788">	struct ifnet *ifp;</a>
<a name="ln1789"> </a>
<a name="ln1790">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln1791"> </a>
<a name="ln1792">	if (sc-&gt;age_watchdog_timer == 0 || --sc-&gt;age_watchdog_timer)</a>
<a name="ln1793">		return;</a>
<a name="ln1794"> </a>
<a name="ln1795">	ifp = sc-&gt;age_ifp;</a>
<a name="ln1796">	if ((sc-&gt;age_flags &amp; AGE_FLAG_LINK) == 0) {</a>
<a name="ln1797">		if_printf(sc-&gt;age_ifp, &quot;watchdog timeout (missed link)\n&quot;);</a>
<a name="ln1798">		if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln1799">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln1800">		age_init_locked(sc);</a>
<a name="ln1801">		return;</a>
<a name="ln1802">	}</a>
<a name="ln1803">	if (sc-&gt;age_cdata.age_tx_cnt == 0) {</a>
<a name="ln1804">		if_printf(sc-&gt;age_ifp,</a>
<a name="ln1805">		    &quot;watchdog timeout (missed Tx interrupts) -- recovering\n&quot;);</a>
<a name="ln1806">		if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln1807">			age_start_locked(ifp);</a>
<a name="ln1808">		return;</a>
<a name="ln1809">	}</a>
<a name="ln1810">	if_printf(sc-&gt;age_ifp, &quot;watchdog timeout\n&quot;);</a>
<a name="ln1811">	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln1812">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln1813">	age_init_locked(sc);</a>
<a name="ln1814">	if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln1815">		age_start_locked(ifp);</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818">static int</a>
<a name="ln1819">age_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)</a>
<a name="ln1820">{</a>
<a name="ln1821">	struct age_softc *sc;</a>
<a name="ln1822">	struct ifreq *ifr;</a>
<a name="ln1823">	struct mii_data *mii;</a>
<a name="ln1824">	uint32_t reg;</a>
<a name="ln1825">	int error, mask;</a>
<a name="ln1826"> </a>
<a name="ln1827">	sc = ifp-&gt;if_softc;</a>
<a name="ln1828">	ifr = (struct ifreq *)data;</a>
<a name="ln1829">	error = 0;</a>
<a name="ln1830">	switch (cmd) {</a>
<a name="ln1831">	case SIOCSIFMTU:</a>
<a name="ln1832">		if (ifr-&gt;ifr_mtu &lt; ETHERMIN || ifr-&gt;ifr_mtu &gt; AGE_JUMBO_MTU)</a>
<a name="ln1833">			error = EINVAL;</a>
<a name="ln1834">		else if (ifp-&gt;if_mtu != ifr-&gt;ifr_mtu) {</a>
<a name="ln1835">			AGE_LOCK(sc);</a>
<a name="ln1836">			ifp-&gt;if_mtu = ifr-&gt;ifr_mtu;</a>
<a name="ln1837">			if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln1838">				ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln1839">				age_init_locked(sc);</a>
<a name="ln1840">			}</a>
<a name="ln1841">			AGE_UNLOCK(sc);</a>
<a name="ln1842">		}</a>
<a name="ln1843">		break;</a>
<a name="ln1844">	case SIOCSIFFLAGS:</a>
<a name="ln1845">		AGE_LOCK(sc);</a>
<a name="ln1846">		if ((ifp-&gt;if_flags &amp; IFF_UP) != 0) {</a>
<a name="ln1847">			if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln1848">				if (((ifp-&gt;if_flags ^ sc-&gt;age_if_flags)</a>
<a name="ln1849">				    &amp; (IFF_PROMISC | IFF_ALLMULTI)) != 0)</a>
<a name="ln1850">					age_rxfilter(sc);</a>
<a name="ln1851">			} else {</a>
<a name="ln1852">				if ((sc-&gt;age_flags &amp; AGE_FLAG_DETACH) == 0)</a>
<a name="ln1853">					age_init_locked(sc);</a>
<a name="ln1854">			}</a>
<a name="ln1855">		} else {</a>
<a name="ln1856">			if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln1857">				age_stop(sc);</a>
<a name="ln1858">		}</a>
<a name="ln1859">		sc-&gt;age_if_flags = ifp-&gt;if_flags;</a>
<a name="ln1860">		AGE_UNLOCK(sc);</a>
<a name="ln1861">		break;</a>
<a name="ln1862">	case SIOCADDMULTI:</a>
<a name="ln1863">	case SIOCDELMULTI:</a>
<a name="ln1864">		AGE_LOCK(sc);</a>
<a name="ln1865">		if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln1866">			age_rxfilter(sc);</a>
<a name="ln1867">		AGE_UNLOCK(sc);</a>
<a name="ln1868">		break;</a>
<a name="ln1869">	case SIOCSIFMEDIA:</a>
<a name="ln1870">	case SIOCGIFMEDIA:</a>
<a name="ln1871">		mii = device_get_softc(sc-&gt;age_miibus);</a>
<a name="ln1872">		error = ifmedia_ioctl(ifp, ifr, &amp;mii-&gt;mii_media, cmd);</a>
<a name="ln1873">		break;</a>
<a name="ln1874">	case SIOCSIFCAP:</a>
<a name="ln1875">		AGE_LOCK(sc);</a>
<a name="ln1876">		mask = ifr-&gt;ifr_reqcap ^ ifp-&gt;if_capenable;</a>
<a name="ln1877">		if ((mask &amp; IFCAP_TXCSUM) != 0 &amp;&amp;</a>
<a name="ln1878">		    (ifp-&gt;if_capabilities &amp; IFCAP_TXCSUM) != 0) {</a>
<a name="ln1879">			ifp-&gt;if_capenable ^= IFCAP_TXCSUM;</a>
<a name="ln1880">			if ((ifp-&gt;if_capenable &amp; IFCAP_TXCSUM) != 0)</a>
<a name="ln1881">				ifp-&gt;if_hwassist |= AGE_CSUM_FEATURES;</a>
<a name="ln1882">			else</a>
<a name="ln1883">				ifp-&gt;if_hwassist &amp;= ~AGE_CSUM_FEATURES;</a>
<a name="ln1884">		}</a>
<a name="ln1885">		if ((mask &amp; IFCAP_RXCSUM) != 0 &amp;&amp;</a>
<a name="ln1886">		    (ifp-&gt;if_capabilities &amp; IFCAP_RXCSUM) != 0) {</a>
<a name="ln1887">			ifp-&gt;if_capenable ^= IFCAP_RXCSUM;</a>
<a name="ln1888">			reg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln1889">			reg &amp;= ~MAC_CFG_RXCSUM_ENB;</a>
<a name="ln1890">			if ((ifp-&gt;if_capenable &amp; IFCAP_RXCSUM) != 0)</a>
<a name="ln1891">				reg |= MAC_CFG_RXCSUM_ENB;</a>
<a name="ln1892">			CSR_WRITE_4(sc, AGE_MAC_CFG, reg);</a>
<a name="ln1893">		}</a>
<a name="ln1894">		if ((mask &amp; IFCAP_TSO4) != 0 &amp;&amp;</a>
<a name="ln1895">		    (ifp-&gt;if_capabilities &amp; IFCAP_TSO4) != 0) {</a>
<a name="ln1896">			ifp-&gt;if_capenable ^= IFCAP_TSO4;</a>
<a name="ln1897">			if ((ifp-&gt;if_capenable &amp; IFCAP_TSO4) != 0)</a>
<a name="ln1898">				ifp-&gt;if_hwassist |= CSUM_TSO;</a>
<a name="ln1899">			else</a>
<a name="ln1900">				ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln1901">		}</a>
<a name="ln1902"> </a>
<a name="ln1903">		if ((mask &amp; IFCAP_WOL_MCAST) != 0 &amp;&amp;</a>
<a name="ln1904">		    (ifp-&gt;if_capabilities &amp; IFCAP_WOL_MCAST) != 0)</a>
<a name="ln1905">			ifp-&gt;if_capenable ^= IFCAP_WOL_MCAST;</a>
<a name="ln1906">		if ((mask &amp; IFCAP_WOL_MAGIC) != 0 &amp;&amp;</a>
<a name="ln1907">		    (ifp-&gt;if_capabilities &amp; IFCAP_WOL_MAGIC) != 0)</a>
<a name="ln1908">			ifp-&gt;if_capenable ^= IFCAP_WOL_MAGIC;</a>
<a name="ln1909">		if ((mask &amp; IFCAP_VLAN_HWCSUM) != 0 &amp;&amp;</a>
<a name="ln1910">		    (ifp-&gt;if_capabilities &amp; IFCAP_VLAN_HWCSUM) != 0)</a>
<a name="ln1911">			ifp-&gt;if_capenable ^= IFCAP_VLAN_HWCSUM;</a>
<a name="ln1912">		if ((mask &amp; IFCAP_VLAN_HWTSO) != 0 &amp;&amp;</a>
<a name="ln1913">		    (ifp-&gt;if_capabilities &amp; IFCAP_VLAN_HWTSO) != 0)</a>
<a name="ln1914">			ifp-&gt;if_capenable ^= IFCAP_VLAN_HWTSO;</a>
<a name="ln1915">		if ((mask &amp; IFCAP_VLAN_HWTAGGING) != 0 &amp;&amp;</a>
<a name="ln1916">		    (ifp-&gt;if_capabilities &amp; IFCAP_VLAN_HWTAGGING) != 0) {</a>
<a name="ln1917">			ifp-&gt;if_capenable ^= IFCAP_VLAN_HWTAGGING;</a>
<a name="ln1918">			if ((ifp-&gt;if_capenable &amp; IFCAP_VLAN_HWTAGGING) == 0)</a>
<a name="ln1919">				ifp-&gt;if_capenable &amp;= ~IFCAP_VLAN_HWTSO;</a>
<a name="ln1920">			age_rxvlan(sc);</a>
<a name="ln1921">		}</a>
<a name="ln1922">		AGE_UNLOCK(sc);</a>
<a name="ln1923">		VLAN_CAPABILITIES(ifp);</a>
<a name="ln1924">		break;</a>
<a name="ln1925">	default:</a>
<a name="ln1926">		error = ether_ioctl(ifp, cmd, data);</a>
<a name="ln1927">		break;</a>
<a name="ln1928">	}</a>
<a name="ln1929"> </a>
<a name="ln1930">	return (error);</a>
<a name="ln1931">}</a>
<a name="ln1932"> </a>
<a name="ln1933">static void</a>
<a name="ln1934">age_mac_config(struct age_softc *sc)</a>
<a name="ln1935">{</a>
<a name="ln1936">	struct mii_data *mii;</a>
<a name="ln1937">	uint32_t reg;</a>
<a name="ln1938"> </a>
<a name="ln1939">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln1940"> </a>
<a name="ln1941">	mii = device_get_softc(sc-&gt;age_miibus);</a>
<a name="ln1942">	reg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln1943">	reg &amp;= ~MAC_CFG_FULL_DUPLEX;</a>
<a name="ln1944">	reg &amp;= ~(MAC_CFG_TX_FC | MAC_CFG_RX_FC);</a>
<a name="ln1945">	reg &amp;= ~MAC_CFG_SPEED_MASK;</a>
<a name="ln1946">	/* Reprogram MAC with resolved speed/duplex. */</a>
<a name="ln1947">	switch (IFM_SUBTYPE(mii-&gt;mii_media_active)) {</a>
<a name="ln1948">	case IFM_10_T:</a>
<a name="ln1949">	case IFM_100_TX:</a>
<a name="ln1950">		reg |= MAC_CFG_SPEED_10_100;</a>
<a name="ln1951">		break;</a>
<a name="ln1952">	case IFM_1000_T:</a>
<a name="ln1953">		reg |= MAC_CFG_SPEED_1000;</a>
<a name="ln1954">		break;</a>
<a name="ln1955">	}</a>
<a name="ln1956">	if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp; IFM_FDX) != 0) {</a>
<a name="ln1957">		reg |= MAC_CFG_FULL_DUPLEX;</a>
<a name="ln1958">#ifdef notyet</a>
<a name="ln1959">		if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp; IFM_ETH_TXPAUSE) != 0)</a>
<a name="ln1960">			reg |= MAC_CFG_TX_FC;</a>
<a name="ln1961">		if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp; IFM_ETH_RXPAUSE) != 0)</a>
<a name="ln1962">			reg |= MAC_CFG_RX_FC;</a>
<a name="ln1963">#endif</a>
<a name="ln1964">	}</a>
<a name="ln1965"> </a>
<a name="ln1966">	CSR_WRITE_4(sc, AGE_MAC_CFG, reg);</a>
<a name="ln1967">}</a>
<a name="ln1968"> </a>
<a name="ln1969">static void</a>
<a name="ln1970">age_link_task(void *arg, int pending)</a>
<a name="ln1971">{</a>
<a name="ln1972">	struct age_softc *sc;</a>
<a name="ln1973">	struct mii_data *mii;</a>
<a name="ln1974">	struct ifnet *ifp;</a>
<a name="ln1975">	uint32_t reg;</a>
<a name="ln1976"> </a>
<a name="ln1977">	sc = (struct age_softc *)arg;</a>
<a name="ln1978"> </a>
<a name="ln1979">	AGE_LOCK(sc);</a>
<a name="ln1980">	mii = device_get_softc(sc-&gt;age_miibus);</a>
<a name="ln1981">	ifp = sc-&gt;age_ifp;</a>
<a name="ln1982">	if (mii == NULL || ifp == NULL ||</a>
<a name="ln1983">	    (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0) {</a>
<a name="ln1984">		AGE_UNLOCK(sc);</a>
<a name="ln1985">		return;</a>
<a name="ln1986">	}</a>
<a name="ln1987"> </a>
<a name="ln1988">	sc-&gt;age_flags &amp;= ~AGE_FLAG_LINK;</a>
<a name="ln1989">	if ((mii-&gt;mii_media_status &amp; IFM_AVALID) != 0) {</a>
<a name="ln1990">		switch (IFM_SUBTYPE(mii-&gt;mii_media_active)) {</a>
<a name="ln1991">		case IFM_10_T:</a>
<a name="ln1992">		case IFM_100_TX:</a>
<a name="ln1993">		case IFM_1000_T:</a>
<a name="ln1994">			sc-&gt;age_flags |= AGE_FLAG_LINK;</a>
<a name="ln1995">			break;</a>
<a name="ln1996">		default:</a>
<a name="ln1997">			break;</a>
<a name="ln1998">		}</a>
<a name="ln1999">	}</a>
<a name="ln2000"> </a>
<a name="ln2001">	/* Stop Rx/Tx MACs. */</a>
<a name="ln2002">	age_stop_rxmac(sc);</a>
<a name="ln2003">	age_stop_txmac(sc);</a>
<a name="ln2004"> </a>
<a name="ln2005">	/* Program MACs with resolved speed/duplex/flow-control. */</a>
<a name="ln2006">	if ((sc-&gt;age_flags &amp; AGE_FLAG_LINK) != 0) {</a>
<a name="ln2007">		age_mac_config(sc);</a>
<a name="ln2008">		reg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln2009">		/* Restart DMA engine and Tx/Rx MAC. */</a>
<a name="ln2010">		CSR_WRITE_4(sc, AGE_DMA_CFG, CSR_READ_4(sc, AGE_DMA_CFG) |</a>
<a name="ln2011">		    DMA_CFG_RD_ENB | DMA_CFG_WR_ENB);</a>
<a name="ln2012">		reg |= MAC_CFG_TX_ENB | MAC_CFG_RX_ENB;</a>
<a name="ln2013">		CSR_WRITE_4(sc, AGE_MAC_CFG, reg);</a>
<a name="ln2014">	}</a>
<a name="ln2015"> </a>
<a name="ln2016">	AGE_UNLOCK(sc);</a>
<a name="ln2017">}</a>
<a name="ln2018"> </a>
<a name="ln2019">static void</a>
<a name="ln2020">age_stats_update(struct age_softc *sc)</a>
<a name="ln2021">{</a>
<a name="ln2022">	struct age_stats *stat;</a>
<a name="ln2023">	struct smb *smb;</a>
<a name="ln2024">	struct ifnet *ifp;</a>
<a name="ln2025"> </a>
<a name="ln2026">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2027"> </a>
<a name="ln2028">	stat = &amp;sc-&gt;age_stat;</a>
<a name="ln2029"> </a>
<a name="ln2030">	bus_dmamap_sync(sc-&gt;age_cdata.age_smb_block_tag,</a>
<a name="ln2031">	    sc-&gt;age_cdata.age_smb_block_map,</a>
<a name="ln2032">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2033"> </a>
<a name="ln2034">	smb = sc-&gt;age_rdata.age_smb_block;</a>
<a name="ln2035">	if (smb-&gt;updated == 0)</a>
<a name="ln2036">		return;</a>
<a name="ln2037"> </a>
<a name="ln2038">	ifp = sc-&gt;age_ifp;</a>
<a name="ln2039">	/* Rx stats. */</a>
<a name="ln2040">	stat-&gt;rx_frames += smb-&gt;rx_frames;</a>
<a name="ln2041">	stat-&gt;rx_bcast_frames += smb-&gt;rx_bcast_frames;</a>
<a name="ln2042">	stat-&gt;rx_mcast_frames += smb-&gt;rx_mcast_frames;</a>
<a name="ln2043">	stat-&gt;rx_pause_frames += smb-&gt;rx_pause_frames;</a>
<a name="ln2044">	stat-&gt;rx_control_frames += smb-&gt;rx_control_frames;</a>
<a name="ln2045">	stat-&gt;rx_crcerrs += smb-&gt;rx_crcerrs;</a>
<a name="ln2046">	stat-&gt;rx_lenerrs += smb-&gt;rx_lenerrs;</a>
<a name="ln2047">	stat-&gt;rx_bytes += smb-&gt;rx_bytes;</a>
<a name="ln2048">	stat-&gt;rx_runts += smb-&gt;rx_runts;</a>
<a name="ln2049">	stat-&gt;rx_fragments += smb-&gt;rx_fragments;</a>
<a name="ln2050">	stat-&gt;rx_pkts_64 += smb-&gt;rx_pkts_64;</a>
<a name="ln2051">	stat-&gt;rx_pkts_65_127 += smb-&gt;rx_pkts_65_127;</a>
<a name="ln2052">	stat-&gt;rx_pkts_128_255 += smb-&gt;rx_pkts_128_255;</a>
<a name="ln2053">	stat-&gt;rx_pkts_256_511 += smb-&gt;rx_pkts_256_511;</a>
<a name="ln2054">	stat-&gt;rx_pkts_512_1023 += smb-&gt;rx_pkts_512_1023;</a>
<a name="ln2055">	stat-&gt;rx_pkts_1024_1518 += smb-&gt;rx_pkts_1024_1518;</a>
<a name="ln2056">	stat-&gt;rx_pkts_1519_max += smb-&gt;rx_pkts_1519_max;</a>
<a name="ln2057">	stat-&gt;rx_pkts_truncated += smb-&gt;rx_pkts_truncated;</a>
<a name="ln2058">	stat-&gt;rx_fifo_oflows += smb-&gt;rx_fifo_oflows;</a>
<a name="ln2059">	stat-&gt;rx_desc_oflows += smb-&gt;rx_desc_oflows;</a>
<a name="ln2060">	stat-&gt;rx_alignerrs += smb-&gt;rx_alignerrs;</a>
<a name="ln2061">	stat-&gt;rx_bcast_bytes += smb-&gt;rx_bcast_bytes;</a>
<a name="ln2062">	stat-&gt;rx_mcast_bytes += smb-&gt;rx_mcast_bytes;</a>
<a name="ln2063">	stat-&gt;rx_pkts_filtered += smb-&gt;rx_pkts_filtered;</a>
<a name="ln2064"> </a>
<a name="ln2065">	/* Tx stats. */</a>
<a name="ln2066">	stat-&gt;tx_frames += smb-&gt;tx_frames;</a>
<a name="ln2067">	stat-&gt;tx_bcast_frames += smb-&gt;tx_bcast_frames;</a>
<a name="ln2068">	stat-&gt;tx_mcast_frames += smb-&gt;tx_mcast_frames;</a>
<a name="ln2069">	stat-&gt;tx_pause_frames += smb-&gt;tx_pause_frames;</a>
<a name="ln2070">	stat-&gt;tx_excess_defer += smb-&gt;tx_excess_defer;</a>
<a name="ln2071">	stat-&gt;tx_control_frames += smb-&gt;tx_control_frames;</a>
<a name="ln2072">	stat-&gt;tx_deferred += smb-&gt;tx_deferred;</a>
<a name="ln2073">	stat-&gt;tx_bytes += smb-&gt;tx_bytes;</a>
<a name="ln2074">	stat-&gt;tx_pkts_64 += smb-&gt;tx_pkts_64;</a>
<a name="ln2075">	stat-&gt;tx_pkts_65_127 += smb-&gt;tx_pkts_65_127;</a>
<a name="ln2076">	stat-&gt;tx_pkts_128_255 += smb-&gt;tx_pkts_128_255;</a>
<a name="ln2077">	stat-&gt;tx_pkts_256_511 += smb-&gt;tx_pkts_256_511;</a>
<a name="ln2078">	stat-&gt;tx_pkts_512_1023 += smb-&gt;tx_pkts_512_1023;</a>
<a name="ln2079">	stat-&gt;tx_pkts_1024_1518 += smb-&gt;tx_pkts_1024_1518;</a>
<a name="ln2080">	stat-&gt;tx_pkts_1519_max += smb-&gt;tx_pkts_1519_max;</a>
<a name="ln2081">	stat-&gt;tx_single_colls += smb-&gt;tx_single_colls;</a>
<a name="ln2082">	stat-&gt;tx_multi_colls += smb-&gt;tx_multi_colls;</a>
<a name="ln2083">	stat-&gt;tx_late_colls += smb-&gt;tx_late_colls;</a>
<a name="ln2084">	stat-&gt;tx_excess_colls += smb-&gt;tx_excess_colls;</a>
<a name="ln2085">	stat-&gt;tx_underrun += smb-&gt;tx_underrun;</a>
<a name="ln2086">	stat-&gt;tx_desc_underrun += smb-&gt;tx_desc_underrun;</a>
<a name="ln2087">	stat-&gt;tx_lenerrs += smb-&gt;tx_lenerrs;</a>
<a name="ln2088">	stat-&gt;tx_pkts_truncated += smb-&gt;tx_pkts_truncated;</a>
<a name="ln2089">	stat-&gt;tx_bcast_bytes += smb-&gt;tx_bcast_bytes;</a>
<a name="ln2090">	stat-&gt;tx_mcast_bytes += smb-&gt;tx_mcast_bytes;</a>
<a name="ln2091"> </a>
<a name="ln2092">	/* Update counters in ifnet. */</a>
<a name="ln2093">	if_inc_counter(ifp, IFCOUNTER_OPACKETS, smb-&gt;tx_frames);</a>
<a name="ln2094"> </a>
<a name="ln2095">	if_inc_counter(ifp, IFCOUNTER_COLLISIONS, smb-&gt;tx_single_colls +</a>
<a name="ln2096">	    smb-&gt;tx_multi_colls + smb-&gt;tx_late_colls +</a>
<a name="ln2097">	    smb-&gt;tx_excess_colls * HDPX_CFG_RETRY_DEFAULT);</a>
<a name="ln2098"> </a>
<a name="ln2099">	if_inc_counter(ifp, IFCOUNTER_OERRORS, smb-&gt;tx_excess_colls +</a>
<a name="ln2100">	    smb-&gt;tx_late_colls + smb-&gt;tx_underrun +</a>
<a name="ln2101">	    smb-&gt;tx_pkts_truncated);</a>
<a name="ln2102"> </a>
<a name="ln2103">	if_inc_counter(ifp, IFCOUNTER_IPACKETS, smb-&gt;rx_frames);</a>
<a name="ln2104"> </a>
<a name="ln2105">	if_inc_counter(ifp, IFCOUNTER_IERRORS, smb-&gt;rx_crcerrs +</a>
<a name="ln2106">	    smb-&gt;rx_lenerrs + smb-&gt;rx_runts + smb-&gt;rx_pkts_truncated +</a>
<a name="ln2107">	    smb-&gt;rx_fifo_oflows + smb-&gt;rx_desc_oflows +</a>
<a name="ln2108">	    smb-&gt;rx_alignerrs);</a>
<a name="ln2109"> </a>
<a name="ln2110">	/* Update done, clear. */</a>
<a name="ln2111">	smb-&gt;updated = 0;</a>
<a name="ln2112"> </a>
<a name="ln2113">	bus_dmamap_sync(sc-&gt;age_cdata.age_smb_block_tag,</a>
<a name="ln2114">	    sc-&gt;age_cdata.age_smb_block_map,</a>
<a name="ln2115">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118">static int</a>
<a name="ln2119">age_intr(void *arg)</a>
<a name="ln2120">{</a>
<a name="ln2121">	struct age_softc *sc;</a>
<a name="ln2122">	uint32_t status;</a>
<a name="ln2123"> </a>
<a name="ln2124">	sc = (struct age_softc *)arg;</a>
<a name="ln2125"> </a>
<a name="ln2126">	status = CSR_READ_4(sc, AGE_INTR_STATUS);</a>
<a name="ln2127">	if (status == 0 || (status &amp; AGE_INTRS) == 0)</a>
<a name="ln2128">		return (FILTER_STRAY);</a>
<a name="ln2129">	/* Disable interrupts. */</a>
<a name="ln2130">	CSR_WRITE_4(sc, AGE_INTR_STATUS, status | INTR_DIS_INT);</a>
<a name="ln2131">	taskqueue_enqueue(sc-&gt;age_tq, &amp;sc-&gt;age_int_task);</a>
<a name="ln2132"> </a>
<a name="ln2133">	return (FILTER_HANDLED);</a>
<a name="ln2134">}</a>
<a name="ln2135"> </a>
<a name="ln2136">static void</a>
<a name="ln2137">age_int_task(void *arg, int pending)</a>
<a name="ln2138">{</a>
<a name="ln2139">	struct age_softc *sc;</a>
<a name="ln2140">	struct ifnet *ifp;</a>
<a name="ln2141">	struct cmb *cmb;</a>
<a name="ln2142">	uint32_t status;</a>
<a name="ln2143"> </a>
<a name="ln2144">	sc = (struct age_softc *)arg;</a>
<a name="ln2145"> </a>
<a name="ln2146">	AGE_LOCK(sc);</a>
<a name="ln2147"> </a>
<a name="ln2148">	bus_dmamap_sync(sc-&gt;age_cdata.age_cmb_block_tag,</a>
<a name="ln2149">	    sc-&gt;age_cdata.age_cmb_block_map,</a>
<a name="ln2150">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2151">	cmb = sc-&gt;age_rdata.age_cmb_block;</a>
<a name="ln2152">	status = le32toh(cmb-&gt;intr_status);</a>
<a name="ln2153">	if (sc-&gt;age_morework != 0)</a>
<a name="ln2154">		status |= INTR_CMB_RX;</a>
<a name="ln2155">	if ((status &amp; AGE_INTRS) == 0)</a>
<a name="ln2156">		goto done;</a>
<a name="ln2157"> </a>
<a name="ln2158">	sc-&gt;age_tpd_cons = (le32toh(cmb-&gt;tpd_cons) &amp; TPD_CONS_MASK) &gt;&gt;</a>
<a name="ln2159">	    TPD_CONS_SHIFT;</a>
<a name="ln2160">	sc-&gt;age_rr_prod = (le32toh(cmb-&gt;rprod_cons) &amp; RRD_PROD_MASK) &gt;&gt;</a>
<a name="ln2161">	    RRD_PROD_SHIFT;</a>
<a name="ln2162">	/* Let hardware know CMB was served. */</a>
<a name="ln2163">	cmb-&gt;intr_status = 0;</a>
<a name="ln2164">	bus_dmamap_sync(sc-&gt;age_cdata.age_cmb_block_tag,</a>
<a name="ln2165">	    sc-&gt;age_cdata.age_cmb_block_map,</a>
<a name="ln2166">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2167"> </a>
<a name="ln2168">	ifp = sc-&gt;age_ifp;</a>
<a name="ln2169">	if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln2170">		if ((status &amp; INTR_CMB_RX) != 0)</a>
<a name="ln2171">			sc-&gt;age_morework = age_rxintr(sc, sc-&gt;age_rr_prod,</a>
<a name="ln2172">			    sc-&gt;age_process_limit);</a>
<a name="ln2173">		if ((status &amp; INTR_CMB_TX) != 0)</a>
<a name="ln2174">			age_txintr(sc, sc-&gt;age_tpd_cons);</a>
<a name="ln2175">		if ((status &amp; (INTR_DMA_RD_TO_RST | INTR_DMA_WR_TO_RST)) != 0) {</a>
<a name="ln2176">			if ((status &amp; INTR_DMA_RD_TO_RST) != 0)</a>
<a name="ln2177">				device_printf(sc-&gt;age_dev,</a>
<a name="ln2178">				    &quot;DMA read error! -- resetting\n&quot;);</a>
<a name="ln2179">			if ((status &amp; INTR_DMA_WR_TO_RST) != 0)</a>
<a name="ln2180">				device_printf(sc-&gt;age_dev,</a>
<a name="ln2181">				    &quot;DMA write error! -- resetting\n&quot;);</a>
<a name="ln2182">			ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln2183">			age_init_locked(sc);</a>
<a name="ln2184">		}</a>
<a name="ln2185">		if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln2186">			age_start_locked(ifp);</a>
<a name="ln2187">		if ((status &amp; INTR_SMB) != 0)</a>
<a name="ln2188">			age_stats_update(sc);</a>
<a name="ln2189">	}</a>
<a name="ln2190"> </a>
<a name="ln2191">	/* Check whether CMB was updated while serving Tx/Rx/SMB handler. */</a>
<a name="ln2192">	bus_dmamap_sync(sc-&gt;age_cdata.age_cmb_block_tag,</a>
<a name="ln2193">	    sc-&gt;age_cdata.age_cmb_block_map,</a>
<a name="ln2194">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2195">	status = le32toh(cmb-&gt;intr_status);</a>
<a name="ln2196">	if (sc-&gt;age_morework != 0 || (status &amp; AGE_INTRS) != 0) {</a>
<a name="ln2197">		taskqueue_enqueue(sc-&gt;age_tq, &amp;sc-&gt;age_int_task);</a>
<a name="ln2198">		AGE_UNLOCK(sc);</a>
<a name="ln2199">		return;</a>
<a name="ln2200">	}</a>
<a name="ln2201"> </a>
<a name="ln2202">done:</a>
<a name="ln2203">	/* Re-enable interrupts. */</a>
<a name="ln2204">	CSR_WRITE_4(sc, AGE_INTR_STATUS, 0);</a>
<a name="ln2205">	AGE_UNLOCK(sc);</a>
<a name="ln2206">}</a>
<a name="ln2207"> </a>
<a name="ln2208">static void</a>
<a name="ln2209">age_txintr(struct age_softc *sc, int tpd_cons)</a>
<a name="ln2210">{</a>
<a name="ln2211">	struct ifnet *ifp;</a>
<a name="ln2212">	struct age_txdesc *txd;</a>
<a name="ln2213">	int cons, prog;</a>
<a name="ln2214"> </a>
<a name="ln2215">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2216"> </a>
<a name="ln2217">	ifp = sc-&gt;age_ifp;</a>
<a name="ln2218"> </a>
<a name="ln2219">	bus_dmamap_sync(sc-&gt;age_cdata.age_tx_ring_tag,</a>
<a name="ln2220">	    sc-&gt;age_cdata.age_tx_ring_map,</a>
<a name="ln2221">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2222"> </a>
<a name="ln2223">	/*</a>
<a name="ln2224">	 * Go through our Tx list and free mbufs for those</a>
<a name="ln2225">	 * frames which have been transmitted.</a>
<a name="ln2226">	 */</a>
<a name="ln2227">	cons = sc-&gt;age_cdata.age_tx_cons;</a>
<a name="ln2228">	for (prog = 0; cons != tpd_cons; AGE_DESC_INC(cons, AGE_TX_RING_CNT)) {</a>
<a name="ln2229">		if (sc-&gt;age_cdata.age_tx_cnt &lt;= 0)</a>
<a name="ln2230">			break;</a>
<a name="ln2231">		prog++;</a>
<a name="ln2232">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln2233">		sc-&gt;age_cdata.age_tx_cnt--;</a>
<a name="ln2234">		txd = &amp;sc-&gt;age_cdata.age_txdesc[cons];</a>
<a name="ln2235">		/*</a>
<a name="ln2236">		 * Clear Tx descriptors, it's not required but would</a>
<a name="ln2237">		 * help debugging in case of Tx issues.</a>
<a name="ln2238">		 */</a>
<a name="ln2239">		txd-&gt;tx_desc-&gt;addr = 0;</a>
<a name="ln2240">		txd-&gt;tx_desc-&gt;len = 0;</a>
<a name="ln2241">		txd-&gt;tx_desc-&gt;flags = 0;</a>
<a name="ln2242"> </a>
<a name="ln2243">		if (txd-&gt;tx_m == NULL)</a>
<a name="ln2244">			continue;</a>
<a name="ln2245">		/* Reclaim transmitted mbufs. */</a>
<a name="ln2246">		bus_dmamap_sync(sc-&gt;age_cdata.age_tx_tag, txd-&gt;tx_dmamap,</a>
<a name="ln2247">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2248">		bus_dmamap_unload(sc-&gt;age_cdata.age_tx_tag, txd-&gt;tx_dmamap);</a>
<a name="ln2249">		m_freem(txd-&gt;tx_m);</a>
<a name="ln2250">		txd-&gt;tx_m = NULL;</a>
<a name="ln2251">	}</a>
<a name="ln2252"> </a>
<a name="ln2253">	if (prog &gt; 0) {</a>
<a name="ln2254">		sc-&gt;age_cdata.age_tx_cons = cons;</a>
<a name="ln2255"> </a>
<a name="ln2256">		/*</a>
<a name="ln2257">		 * Unarm watchdog timer only when there are no pending</a>
<a name="ln2258">		 * Tx descriptors in queue.</a>
<a name="ln2259">		 */</a>
<a name="ln2260">		if (sc-&gt;age_cdata.age_tx_cnt == 0)</a>
<a name="ln2261">			sc-&gt;age_watchdog_timer = 0;</a>
<a name="ln2262">		bus_dmamap_sync(sc-&gt;age_cdata.age_tx_ring_tag,</a>
<a name="ln2263">		    sc-&gt;age_cdata.age_tx_ring_map,</a>
<a name="ln2264">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2265">	}</a>
<a name="ln2266">}</a>
<a name="ln2267"> </a>
<a name="ln2268">#ifndef __NO_STRICT_ALIGNMENT</a>
<a name="ln2269">static struct mbuf *</a>
<a name="ln2270">age_fixup_rx(struct ifnet *ifp, struct mbuf *m)</a>
<a name="ln2271">{</a>
<a name="ln2272">	struct mbuf *n;</a>
<a name="ln2273">        int i;</a>
<a name="ln2274">        uint16_t *src, *dst;</a>
<a name="ln2275"> </a>
<a name="ln2276">	src = mtod(m, uint16_t *);</a>
<a name="ln2277">	dst = src - 3;</a>
<a name="ln2278"> </a>
<a name="ln2279">	if (m-&gt;m_next == NULL) {</a>
<a name="ln2280">		for (i = 0; i &lt; (m-&gt;m_len / sizeof(uint16_t) + 1); i++)</a>
<a name="ln2281">			*dst++ = *src++;</a>
<a name="ln2282">		m-&gt;m_data -= 6;</a>
<a name="ln2283">		return (m);</a>
<a name="ln2284">	}</a>
<a name="ln2285">	/*</a>
<a name="ln2286">	 * Append a new mbuf to received mbuf chain and copy ethernet</a>
<a name="ln2287">	 * header from the mbuf chain. This can save lots of CPU</a>
<a name="ln2288">	 * cycles for jumbo frame.</a>
<a name="ln2289">	 */</a>
<a name="ln2290">	MGETHDR(n, M_NOWAIT, MT_DATA);</a>
<a name="ln2291">	if (n == NULL) {</a>
<a name="ln2292">		if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln2293">		m_freem(m);</a>
<a name="ln2294">		return (NULL);</a>
<a name="ln2295">	}</a>
<a name="ln2296">	bcopy(m-&gt;m_data, n-&gt;m_data, ETHER_HDR_LEN);</a>
<a name="ln2297">	m-&gt;m_data += ETHER_HDR_LEN;</a>
<a name="ln2298">	m-&gt;m_len -= ETHER_HDR_LEN;</a>
<a name="ln2299">	n-&gt;m_len = ETHER_HDR_LEN;</a>
<a name="ln2300">	M_MOVE_PKTHDR(n, m);</a>
<a name="ln2301">	n-&gt;m_next = m;</a>
<a name="ln2302">	return (n);</a>
<a name="ln2303">}</a>
<a name="ln2304">#endif</a>
<a name="ln2305"> </a>
<a name="ln2306">/* Receive a frame. */</a>
<a name="ln2307">static void</a>
<a name="ln2308">age_rxeof(struct age_softc *sc, struct rx_rdesc *rxrd)</a>
<a name="ln2309">{</a>
<a name="ln2310">	struct age_rxdesc *rxd;</a>
<a name="ln2311">	struct ifnet *ifp;</a>
<a name="ln2312">	struct mbuf *mp, *m;</a>
<a name="ln2313">	uint32_t status, index, vtag;</a>
<a name="ln2314">	int count, nsegs;</a>
<a name="ln2315">	int rx_cons;</a>
<a name="ln2316"> </a>
<a name="ln2317">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2318"> </a>
<a name="ln2319">	ifp = sc-&gt;age_ifp;</a>
<a name="ln2320">	status = le32toh(rxrd-&gt;flags);</a>
<a name="ln2321">	index = le32toh(rxrd-&gt;index);</a>
<a name="ln2322">	rx_cons = AGE_RX_CONS(index);</a>
<a name="ln2323">	nsegs = AGE_RX_NSEGS(index);</a>
<a name="ln2324"> </a>
<a name="ln2325">	sc-&gt;age_cdata.age_rxlen = AGE_RX_BYTES(le32toh(rxrd-&gt;len));</a>
<a name="ln2326">	if ((status &amp; (AGE_RRD_ERROR | AGE_RRD_LENGTH_NOK)) != 0) {</a>
<a name="ln2327">		/*</a>
<a name="ln2328">		 * We want to pass the following frames to upper</a>
<a name="ln2329">		 * layer regardless of error status of Rx return</a>
<a name="ln2330">		 * ring.</a>
<a name="ln2331">		 *</a>
<a name="ln2332">		 *  o IP/TCP/UDP checksum is bad.</a>
<a name="ln2333">		 *  o frame length and protocol specific length</a>
<a name="ln2334">		 *     does not match.</a>
<a name="ln2335">		 */</a>
<a name="ln2336">		status |= AGE_RRD_IPCSUM_NOK | AGE_RRD_TCP_UDPCSUM_NOK;</a>
<a name="ln2337">		if ((status &amp; (AGE_RRD_CRC | AGE_RRD_CODE | AGE_RRD_DRIBBLE |</a>
<a name="ln2338">		    AGE_RRD_RUNT | AGE_RRD_OFLOW | AGE_RRD_TRUNC)) != 0)</a>
<a name="ln2339">			return;</a>
<a name="ln2340">	}</a>
<a name="ln2341"> </a>
<a name="ln2342">	for (count = 0; count &lt; nsegs; count++,</a>
<a name="ln2343">	    AGE_DESC_INC(rx_cons, AGE_RX_RING_CNT)) {</a>
<a name="ln2344">		rxd = &amp;sc-&gt;age_cdata.age_rxdesc[rx_cons];</a>
<a name="ln2345">		mp = rxd-&gt;rx_m;</a>
<a name="ln2346">		/* Add a new receive buffer to the ring. */</a>
<a name="ln2347">		if (age_newbuf(sc, rxd) != 0) {</a>
<a name="ln2348">			if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln2349">			/* Reuse Rx buffers. */</a>
<a name="ln2350">			if (sc-&gt;age_cdata.age_rxhead != NULL)</a>
<a name="ln2351">				m_freem(sc-&gt;age_cdata.age_rxhead);</a>
<a name="ln2352">			break;</a>
<a name="ln2353">		}</a>
<a name="ln2354"> </a>
<a name="ln2355">		/*</a>
<a name="ln2356">		 * Assume we've received a full sized frame.</a>
<a name="ln2357">		 * Actual size is fixed when we encounter the end of</a>
<a name="ln2358">		 * multi-segmented frame.</a>
<a name="ln2359">		 */</a>
<a name="ln2360">		mp-&gt;m_len = AGE_RX_BUF_SIZE;</a>
<a name="ln2361"> </a>
<a name="ln2362">		/* Chain received mbufs. */</a>
<a name="ln2363">		if (sc-&gt;age_cdata.age_rxhead == NULL) {</a>
<a name="ln2364">			sc-&gt;age_cdata.age_rxhead = mp;</a>
<a name="ln2365">			sc-&gt;age_cdata.age_rxtail = mp;</a>
<a name="ln2366">		} else {</a>
<a name="ln2367">			mp-&gt;m_flags &amp;= ~M_PKTHDR;</a>
<a name="ln2368">			sc-&gt;age_cdata.age_rxprev_tail =</a>
<a name="ln2369">			    sc-&gt;age_cdata.age_rxtail;</a>
<a name="ln2370">			sc-&gt;age_cdata.age_rxtail-&gt;m_next = mp;</a>
<a name="ln2371">			sc-&gt;age_cdata.age_rxtail = mp;</a>
<a name="ln2372">		}</a>
<a name="ln2373"> </a>
<a name="ln2374">		if (count == nsegs - 1) {</a>
<a name="ln2375">			/* Last desc. for this frame. */</a>
<a name="ln2376">			m = sc-&gt;age_cdata.age_rxhead;</a>
<a name="ln2377">			m-&gt;m_flags |= M_PKTHDR;</a>
<a name="ln2378">			/*</a>
<a name="ln2379">			 * It seems that L1 controller has no way</a>
<a name="ln2380">			 * to tell hardware to strip CRC bytes.</a>
<a name="ln2381">			 */</a>
<a name="ln2382">			m-&gt;m_pkthdr.len = sc-&gt;age_cdata.age_rxlen -</a>
<a name="ln2383">			    ETHER_CRC_LEN;</a>
<a name="ln2384">			if (nsegs &gt; 1) {</a>
<a name="ln2385">				/* Set last mbuf size. */</a>
<a name="ln2386">				mp-&gt;m_len = sc-&gt;age_cdata.age_rxlen -</a>
<a name="ln2387">				    ((nsegs - 1) * AGE_RX_BUF_SIZE);</a>
<a name="ln2388">				/* Remove the CRC bytes in chained mbufs. */</a>
<a name="ln2389">				if (mp-&gt;m_len &lt;= ETHER_CRC_LEN) {</a>
<a name="ln2390">					sc-&gt;age_cdata.age_rxtail =</a>
<a name="ln2391">					    sc-&gt;age_cdata.age_rxprev_tail;</a>
<a name="ln2392">					sc-&gt;age_cdata.age_rxtail-&gt;m_len -=</a>
<a name="ln2393">					    (ETHER_CRC_LEN - mp-&gt;m_len);</a>
<a name="ln2394">					sc-&gt;age_cdata.age_rxtail-&gt;m_next = NULL;</a>
<a name="ln2395">					m_freem(mp);</a>
<a name="ln2396">				} else {</a>
<a name="ln2397">					mp-&gt;m_len -= ETHER_CRC_LEN;</a>
<a name="ln2398">				}</a>
<a name="ln2399">			} else</a>
<a name="ln2400">				m-&gt;m_len = m-&gt;m_pkthdr.len;</a>
<a name="ln2401">			m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln2402">			/*</a>
<a name="ln2403">			 * Set checksum information.</a>
<a name="ln2404">			 * It seems that L1 controller can compute partial</a>
<a name="ln2405">			 * checksum. The partial checksum value can be used</a>
<a name="ln2406">			 * to accelerate checksum computation for fragmented</a>
<a name="ln2407">			 * TCP/UDP packets. Upper network stack already</a>
<a name="ln2408">			 * takes advantage of the partial checksum value in</a>
<a name="ln2409">			 * IP reassembly stage. But I'm not sure the</a>
<a name="ln2410">			 * correctness of the partial hardware checksum</a>
<a name="ln2411">			 * assistance due to lack of data sheet. If it is</a>
<a name="ln2412">			 * proven to work on L1 I'll enable it.</a>
<a name="ln2413">			 */</a>
<a name="ln2414">			if ((ifp-&gt;if_capenable &amp; IFCAP_RXCSUM) != 0 &amp;&amp;</a>
<a name="ln2415">			    (status &amp; AGE_RRD_IPV4) != 0) {</a>
<a name="ln2416">				if ((status &amp; AGE_RRD_IPCSUM_NOK) == 0)</a>
<a name="ln2417">					m-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln2418">					    CSUM_IP_CHECKED | CSUM_IP_VALID;</a>
<a name="ln2419">				if ((status &amp; (AGE_RRD_TCP | AGE_RRD_UDP)) &amp;&amp;</a>
<a name="ln2420">				    (status &amp; AGE_RRD_TCP_UDPCSUM_NOK) == 0) {</a>
<a name="ln2421">					m-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln2422">					    CSUM_DATA_VALID | CSUM_PSEUDO_HDR;</a>
<a name="ln2423">					m-&gt;m_pkthdr.csum_data = 0xffff;</a>
<a name="ln2424">				}</a>
<a name="ln2425">				/*</a>
<a name="ln2426">				 * Don't mark bad checksum for TCP/UDP frames</a>
<a name="ln2427">				 * as fragmented frames may always have set</a>
<a name="ln2428">				 * bad checksummed bit of descriptor status.</a>
<a name="ln2429">				 */</a>
<a name="ln2430">			}</a>
<a name="ln2431"> </a>
<a name="ln2432">			/* Check for VLAN tagged frames. */</a>
<a name="ln2433">			if ((ifp-&gt;if_capenable &amp; IFCAP_VLAN_HWTAGGING) != 0 &amp;&amp;</a>
<a name="ln2434">			    (status &amp; AGE_RRD_VLAN) != 0) {</a>
<a name="ln2435">				vtag = AGE_RX_VLAN(le32toh(rxrd-&gt;vtags));</a>
<a name="ln2436">				m-&gt;m_pkthdr.ether_vtag = AGE_RX_VLAN_TAG(vtag);</a>
<a name="ln2437">				m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln2438">			}</a>
<a name="ln2439">#ifndef __NO_STRICT_ALIGNMENT</a>
<a name="ln2440">			m = age_fixup_rx(ifp, m);</a>
<a name="ln2441">			if (m != NULL)</a>
<a name="ln2442">#endif</a>
<a name="ln2443">			{</a>
<a name="ln2444">			/* Pass it on. */</a>
<a name="ln2445">			AGE_UNLOCK(sc);</a>
<a name="ln2446">			(*ifp-&gt;if_input)(ifp, m);</a>
<a name="ln2447">			AGE_LOCK(sc);</a>
<a name="ln2448">			}</a>
<a name="ln2449">		}</a>
<a name="ln2450">	}</a>
<a name="ln2451"> </a>
<a name="ln2452">	/* Reset mbuf chains. */</a>
<a name="ln2453">	AGE_RXCHAIN_RESET(sc);</a>
<a name="ln2454">}</a>
<a name="ln2455"> </a>
<a name="ln2456">static int</a>
<a name="ln2457">age_rxintr(struct age_softc *sc, int rr_prod, int count)</a>
<a name="ln2458">{</a>
<a name="ln2459">	struct rx_rdesc *rxrd;</a>
<a name="ln2460">	int rr_cons, nsegs, pktlen, prog;</a>
<a name="ln2461"> </a>
<a name="ln2462">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2463"> </a>
<a name="ln2464">	rr_cons = sc-&gt;age_cdata.age_rr_cons;</a>
<a name="ln2465">	if (rr_cons == rr_prod)</a>
<a name="ln2466">		return (0);</a>
<a name="ln2467"> </a>
<a name="ln2468">	bus_dmamap_sync(sc-&gt;age_cdata.age_rr_ring_tag,</a>
<a name="ln2469">	    sc-&gt;age_cdata.age_rr_ring_map,</a>
<a name="ln2470">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2471">	bus_dmamap_sync(sc-&gt;age_cdata.age_rx_ring_tag,</a>
<a name="ln2472">	    sc-&gt;age_cdata.age_rx_ring_map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2473"> </a>
<a name="ln2474">	for (prog = 0; rr_cons != rr_prod; prog++) {</a>
<a name="ln2475">		if (count-- &lt;= 0)</a>
<a name="ln2476">			break;</a>
<a name="ln2477">		rxrd = &amp;sc-&gt;age_rdata.age_rr_ring[rr_cons];</a>
<a name="ln2478">		nsegs = AGE_RX_NSEGS(le32toh(rxrd-&gt;index));</a>
<a name="ln2479">		if (nsegs == 0)</a>
<a name="ln2480">			break;</a>
<a name="ln2481">		/*</a>
<a name="ln2482">		 * Check number of segments against received bytes.</a>
<a name="ln2483">		 * Non-matching value would indicate that hardware</a>
<a name="ln2484">		 * is still trying to update Rx return descriptors.</a>
<a name="ln2485">		 * I'm not sure whether this check is really needed.</a>
<a name="ln2486">		 */</a>
<a name="ln2487">		pktlen = AGE_RX_BYTES(le32toh(rxrd-&gt;len));</a>
<a name="ln2488">		if (nsegs != howmany(pktlen, AGE_RX_BUF_SIZE))</a>
<a name="ln2489">			break;</a>
<a name="ln2490"> </a>
<a name="ln2491">		/* Received a frame. */</a>
<a name="ln2492">		age_rxeof(sc, rxrd);</a>
<a name="ln2493">		/* Clear return ring. */</a>
<a name="ln2494">		rxrd-&gt;index = 0;</a>
<a name="ln2495">		AGE_DESC_INC(rr_cons, AGE_RR_RING_CNT);</a>
<a name="ln2496">		sc-&gt;age_cdata.age_rx_cons += nsegs;</a>
<a name="ln2497">		sc-&gt;age_cdata.age_rx_cons %= AGE_RX_RING_CNT;</a>
<a name="ln2498">	}</a>
<a name="ln2499"> </a>
<a name="ln2500">	if (prog &gt; 0) {</a>
<a name="ln2501">		/* Update the consumer index. */</a>
<a name="ln2502">		sc-&gt;age_cdata.age_rr_cons = rr_cons;</a>
<a name="ln2503"> </a>
<a name="ln2504">		bus_dmamap_sync(sc-&gt;age_cdata.age_rx_ring_tag,</a>
<a name="ln2505">		    sc-&gt;age_cdata.age_rx_ring_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln2506">		/* Sync descriptors. */</a>
<a name="ln2507">		bus_dmamap_sync(sc-&gt;age_cdata.age_rr_ring_tag,</a>
<a name="ln2508">		    sc-&gt;age_cdata.age_rr_ring_map,</a>
<a name="ln2509">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2510"> </a>
<a name="ln2511">		/* Notify hardware availability of new Rx buffers. */</a>
<a name="ln2512">		AGE_COMMIT_MBOX(sc);</a>
<a name="ln2513">	}</a>
<a name="ln2514"> </a>
<a name="ln2515">	return (count &gt; 0 ? 0 : EAGAIN);</a>
<a name="ln2516">}</a>
<a name="ln2517"> </a>
<a name="ln2518">static void</a>
<a name="ln2519">age_tick(void *arg)</a>
<a name="ln2520">{</a>
<a name="ln2521">	struct age_softc *sc;</a>
<a name="ln2522">	struct mii_data *mii;</a>
<a name="ln2523"> </a>
<a name="ln2524">	sc = (struct age_softc *)arg;</a>
<a name="ln2525"> </a>
<a name="ln2526">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2527"> </a>
<a name="ln2528">	mii = device_get_softc(sc-&gt;age_miibus);</a>
<a name="ln2529">	mii_tick(mii);</a>
<a name="ln2530">	age_watchdog(sc);</a>
<a name="ln2531">	callout_reset(&amp;sc-&gt;age_tick_ch, hz, age_tick, sc);</a>
<a name="ln2532">}</a>
<a name="ln2533"> </a>
<a name="ln2534">static void</a>
<a name="ln2535">age_reset(struct age_softc *sc)</a>
<a name="ln2536">{</a>
<a name="ln2537">	uint32_t reg;</a>
<a name="ln2538">	int i;</a>
<a name="ln2539"> </a>
<a name="ln2540">	CSR_WRITE_4(sc, AGE_MASTER_CFG, MASTER_RESET);</a>
<a name="ln2541">	CSR_READ_4(sc, AGE_MASTER_CFG);</a>
<a name="ln2542">	DELAY(1000);</a>
<a name="ln2543">	for (i = AGE_RESET_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln2544">		if ((reg = CSR_READ_4(sc, AGE_IDLE_STATUS)) == 0)</a>
<a name="ln2545">			break;</a>
<a name="ln2546">		DELAY(10);</a>
<a name="ln2547">	}</a>
<a name="ln2548"> </a>
<a name="ln2549">	if (i == 0)</a>
<a name="ln2550">		device_printf(sc-&gt;age_dev, &quot;reset timeout(0x%08x)!\n&quot;, reg);</a>
<a name="ln2551">	/* Initialize PCIe module. From Linux. */</a>
<a name="ln2552">	CSR_WRITE_4(sc, 0x12FC, 0x6500);</a>
<a name="ln2553">	CSR_WRITE_4(sc, 0x1008, CSR_READ_4(sc, 0x1008) | 0x8000);</a>
<a name="ln2554">}</a>
<a name="ln2555"> </a>
<a name="ln2556">static void</a>
<a name="ln2557">age_init(void *xsc)</a>
<a name="ln2558">{</a>
<a name="ln2559">	struct age_softc *sc;</a>
<a name="ln2560"> </a>
<a name="ln2561">	sc = (struct age_softc *)xsc;</a>
<a name="ln2562">	AGE_LOCK(sc);</a>
<a name="ln2563">	age_init_locked(sc);</a>
<a name="ln2564">	AGE_UNLOCK(sc);</a>
<a name="ln2565">}</a>
<a name="ln2566"> </a>
<a name="ln2567">static void</a>
<a name="ln2568">age_init_locked(struct age_softc *sc)</a>
<a name="ln2569">{</a>
<a name="ln2570">	struct ifnet *ifp;</a>
<a name="ln2571">	struct mii_data *mii;</a>
<a name="ln2572">	uint8_t eaddr[ETHER_ADDR_LEN];</a>
<a name="ln2573">	bus_addr_t paddr;</a>
<a name="ln2574">	uint32_t reg, fsize;</a>
<a name="ln2575">	uint32_t rxf_hi, rxf_lo, rrd_hi, rrd_lo;</a>
<a name="ln2576">	int error;</a>
<a name="ln2577"> </a>
<a name="ln2578">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2579"> </a>
<a name="ln2580">	ifp = sc-&gt;age_ifp;</a>
<a name="ln2581">	mii = device_get_softc(sc-&gt;age_miibus);</a>
<a name="ln2582"> </a>
<a name="ln2583">	if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln2584">		return;</a>
<a name="ln2585"> </a>
<a name="ln2586">	/*</a>
<a name="ln2587">	 * Cancel any pending I/O.</a>
<a name="ln2588">	 */</a>
<a name="ln2589">	age_stop(sc);</a>
<a name="ln2590"> </a>
<a name="ln2591">	/*</a>
<a name="ln2592">	 * Reset the chip to a known state.</a>
<a name="ln2593">	 */</a>
<a name="ln2594">	age_reset(sc);</a>
<a name="ln2595"> </a>
<a name="ln2596">	/* Initialize descriptors. */</a>
<a name="ln2597">	error = age_init_rx_ring(sc);</a>
<a name="ln2598">        if (error != 0) {</a>
<a name="ln2599">                device_printf(sc-&gt;age_dev, &quot;no memory for Rx buffers.\n&quot;);</a>
<a name="ln2600">                age_stop(sc);</a>
<a name="ln2601">		return;</a>
<a name="ln2602">        }</a>
<a name="ln2603">	age_init_rr_ring(sc);</a>
<a name="ln2604">	age_init_tx_ring(sc);</a>
<a name="ln2605">	age_init_cmb_block(sc);</a>
<a name="ln2606">	age_init_smb_block(sc);</a>
<a name="ln2607"> </a>
<a name="ln2608">	/* Reprogram the station address. */</a>
<a name="ln2609">	bcopy(IF_LLADDR(ifp), eaddr, ETHER_ADDR_LEN);</a>
<a name="ln2610">	CSR_WRITE_4(sc, AGE_PAR0,</a>
<a name="ln2611">	    eaddr[2] &lt;&lt; 24 | eaddr[3] &lt;&lt; 16 | eaddr[4] &lt;&lt; 8 | eaddr[5]);</a>
<a name="ln2612">	CSR_WRITE_4(sc, AGE_PAR1, eaddr[0] &lt;&lt; 8 | eaddr[1]);</a>
<a name="ln2613"> </a>
<a name="ln2614">	/* Set descriptor base addresses. */</a>
<a name="ln2615">	paddr = sc-&gt;age_rdata.age_tx_ring_paddr;</a>
<a name="ln2616">	CSR_WRITE_4(sc, AGE_DESC_ADDR_HI, AGE_ADDR_HI(paddr));</a>
<a name="ln2617">	paddr = sc-&gt;age_rdata.age_rx_ring_paddr;</a>
<a name="ln2618">	CSR_WRITE_4(sc, AGE_DESC_RD_ADDR_LO, AGE_ADDR_LO(paddr));</a>
<a name="ln2619">	paddr = sc-&gt;age_rdata.age_rr_ring_paddr;</a>
<a name="ln2620">	CSR_WRITE_4(sc, AGE_DESC_RRD_ADDR_LO, AGE_ADDR_LO(paddr));</a>
<a name="ln2621">	paddr = sc-&gt;age_rdata.age_tx_ring_paddr;</a>
<a name="ln2622">	CSR_WRITE_4(sc, AGE_DESC_TPD_ADDR_LO, AGE_ADDR_LO(paddr));</a>
<a name="ln2623">	paddr = sc-&gt;age_rdata.age_cmb_block_paddr;</a>
<a name="ln2624">	CSR_WRITE_4(sc, AGE_DESC_CMB_ADDR_LO, AGE_ADDR_LO(paddr));</a>
<a name="ln2625">	paddr = sc-&gt;age_rdata.age_smb_block_paddr;</a>
<a name="ln2626">	CSR_WRITE_4(sc, AGE_DESC_SMB_ADDR_LO, AGE_ADDR_LO(paddr));</a>
<a name="ln2627">	/* Set Rx/Rx return descriptor counter. */</a>
<a name="ln2628">	CSR_WRITE_4(sc, AGE_DESC_RRD_RD_CNT,</a>
<a name="ln2629">	    ((AGE_RR_RING_CNT &lt;&lt; DESC_RRD_CNT_SHIFT) &amp;</a>
<a name="ln2630">	    DESC_RRD_CNT_MASK) |</a>
<a name="ln2631">	    ((AGE_RX_RING_CNT &lt;&lt; DESC_RD_CNT_SHIFT) &amp; DESC_RD_CNT_MASK));</a>
<a name="ln2632">	/* Set Tx descriptor counter. */</a>
<a name="ln2633">	CSR_WRITE_4(sc, AGE_DESC_TPD_CNT,</a>
<a name="ln2634">	    (AGE_TX_RING_CNT &lt;&lt; DESC_TPD_CNT_SHIFT) &amp; DESC_TPD_CNT_MASK);</a>
<a name="ln2635"> </a>
<a name="ln2636">	/* Tell hardware that we're ready to load descriptors. */</a>
<a name="ln2637">	CSR_WRITE_4(sc, AGE_DMA_BLOCK, DMA_BLOCK_LOAD);</a>
<a name="ln2638"> </a>
<a name="ln2639">	/*</a>
<a name="ln2640">	 * Initialize mailbox register.</a>
<a name="ln2641">	 * Updated producer/consumer index information is exchanged</a>
<a name="ln2642">	 * through this mailbox register. However Tx producer and</a>
<a name="ln2643">	 * Rx return consumer/Rx producer are all shared such that</a>
<a name="ln2644">	 * it's hard to separate code path between Tx and Rx without</a>
<a name="ln2645">	 * locking. If L1 hardware have a separate mail box register</a>
<a name="ln2646">	 * for Tx and Rx consumer/producer management we could have</a>
<a name="ln2647">	 * indepent Tx/Rx handler which in turn Rx handler could have</a>
<a name="ln2648">	 * been run without any locking.</a>
<a name="ln2649">	 */</a>
<a name="ln2650">	AGE_COMMIT_MBOX(sc);</a>
<a name="ln2651"> </a>
<a name="ln2652">	/* Configure IPG/IFG parameters. */</a>
<a name="ln2653">	CSR_WRITE_4(sc, AGE_IPG_IFG_CFG,</a>
<a name="ln2654">	    ((IPG_IFG_IPG2_DEFAULT &lt;&lt; IPG_IFG_IPG2_SHIFT) &amp; IPG_IFG_IPG2_MASK) |</a>
<a name="ln2655">	    ((IPG_IFG_IPG1_DEFAULT &lt;&lt; IPG_IFG_IPG1_SHIFT) &amp; IPG_IFG_IPG1_MASK) |</a>
<a name="ln2656">	    ((IPG_IFG_MIFG_DEFAULT &lt;&lt; IPG_IFG_MIFG_SHIFT) &amp; IPG_IFG_MIFG_MASK) |</a>
<a name="ln2657">	    ((IPG_IFG_IPGT_DEFAULT &lt;&lt; IPG_IFG_IPGT_SHIFT) &amp; IPG_IFG_IPGT_MASK));</a>
<a name="ln2658"> </a>
<a name="ln2659">	/* Set parameters for half-duplex media. */</a>
<a name="ln2660">	CSR_WRITE_4(sc, AGE_HDPX_CFG,</a>
<a name="ln2661">	    ((HDPX_CFG_LCOL_DEFAULT &lt;&lt; HDPX_CFG_LCOL_SHIFT) &amp;</a>
<a name="ln2662">	    HDPX_CFG_LCOL_MASK) |</a>
<a name="ln2663">	    ((HDPX_CFG_RETRY_DEFAULT &lt;&lt; HDPX_CFG_RETRY_SHIFT) &amp;</a>
<a name="ln2664">	    HDPX_CFG_RETRY_MASK) | HDPX_CFG_EXC_DEF_EN |</a>
<a name="ln2665">	    ((HDPX_CFG_ABEBT_DEFAULT &lt;&lt; HDPX_CFG_ABEBT_SHIFT) &amp;</a>
<a name="ln2666">	    HDPX_CFG_ABEBT_MASK) |</a>
<a name="ln2667">	    ((HDPX_CFG_JAMIPG_DEFAULT &lt;&lt; HDPX_CFG_JAMIPG_SHIFT) &amp;</a>
<a name="ln2668">	    HDPX_CFG_JAMIPG_MASK));</a>
<a name="ln2669"> </a>
<a name="ln2670">	/* Configure interrupt moderation timer. */</a>
<a name="ln2671">	CSR_WRITE_2(sc, AGE_IM_TIMER, AGE_USECS(sc-&gt;age_int_mod));</a>
<a name="ln2672">	reg = CSR_READ_4(sc, AGE_MASTER_CFG);</a>
<a name="ln2673">	reg &amp;= ~MASTER_MTIMER_ENB;</a>
<a name="ln2674">	if (AGE_USECS(sc-&gt;age_int_mod) == 0)</a>
<a name="ln2675">		reg &amp;= ~MASTER_ITIMER_ENB;</a>
<a name="ln2676">	else</a>
<a name="ln2677">		reg |= MASTER_ITIMER_ENB;</a>
<a name="ln2678">	CSR_WRITE_4(sc, AGE_MASTER_CFG, reg);</a>
<a name="ln2679">	if (bootverbose)</a>
<a name="ln2680">		device_printf(sc-&gt;age_dev, &quot;interrupt moderation is %d us.\n&quot;,</a>
<a name="ln2681">		    sc-&gt;age_int_mod);</a>
<a name="ln2682">	CSR_WRITE_2(sc, AGE_INTR_CLR_TIMER, AGE_USECS(1000));</a>
<a name="ln2683"> </a>
<a name="ln2684">	/* Set Maximum frame size but don't let MTU be lass than ETHER_MTU. */</a>
<a name="ln2685">	if (ifp-&gt;if_mtu &lt; ETHERMTU)</a>
<a name="ln2686">		sc-&gt;age_max_frame_size = ETHERMTU;</a>
<a name="ln2687">	else</a>
<a name="ln2688">		sc-&gt;age_max_frame_size = ifp-&gt;if_mtu;</a>
<a name="ln2689">	sc-&gt;age_max_frame_size += ETHER_HDR_LEN +</a>
<a name="ln2690">	    sizeof(struct ether_vlan_header) + ETHER_CRC_LEN;</a>
<a name="ln2691">	CSR_WRITE_4(sc, AGE_FRAME_SIZE, sc-&gt;age_max_frame_size);</a>
<a name="ln2692">	/* Configure jumbo frame. */</a>
<a name="ln2693">	fsize = roundup(sc-&gt;age_max_frame_size, sizeof(uint64_t));</a>
<a name="ln2694">	CSR_WRITE_4(sc, AGE_RXQ_JUMBO_CFG,</a>
<a name="ln2695">	    (((fsize / sizeof(uint64_t)) &lt;&lt;</a>
<a name="ln2696">	    RXQ_JUMBO_CFG_SZ_THRESH_SHIFT) &amp; RXQ_JUMBO_CFG_SZ_THRESH_MASK) |</a>
<a name="ln2697">	    ((RXQ_JUMBO_CFG_LKAH_DEFAULT &lt;&lt;</a>
<a name="ln2698">	    RXQ_JUMBO_CFG_LKAH_SHIFT) &amp; RXQ_JUMBO_CFG_LKAH_MASK) |</a>
<a name="ln2699">	    ((AGE_USECS(8) &lt;&lt; RXQ_JUMBO_CFG_RRD_TIMER_SHIFT) &amp;</a>
<a name="ln2700">	    RXQ_JUMBO_CFG_RRD_TIMER_MASK));</a>
<a name="ln2701"> </a>
<a name="ln2702">	/* Configure flow-control parameters. From Linux. */</a>
<a name="ln2703">	if ((sc-&gt;age_flags &amp; AGE_FLAG_PCIE) != 0) {</a>
<a name="ln2704">		/*</a>
<a name="ln2705">		 * Magic workaround for old-L1.</a>
<a name="ln2706">		 * Don't know which hw revision requires this magic.</a>
<a name="ln2707">		 */</a>
<a name="ln2708">		CSR_WRITE_4(sc, 0x12FC, 0x6500);</a>
<a name="ln2709">		/*</a>
<a name="ln2710">		 * Another magic workaround for flow-control mode</a>
<a name="ln2711">		 * change. From Linux.</a>
<a name="ln2712">		 */</a>
<a name="ln2713">		CSR_WRITE_4(sc, 0x1008, CSR_READ_4(sc, 0x1008) | 0x8000);</a>
<a name="ln2714">	}</a>
<a name="ln2715">	/*</a>
<a name="ln2716">	 * TODO</a>
<a name="ln2717">	 *  Should understand pause parameter relationships between FIFO</a>
<a name="ln2718">	 *  size and number of Rx descriptors and Rx return descriptors.</a>
<a name="ln2719">	 *</a>
<a name="ln2720">	 *  Magic parameters came from Linux.</a>
<a name="ln2721">	 */</a>
<a name="ln2722">	switch (sc-&gt;age_chip_rev) {</a>
<a name="ln2723">	case 0x8001:</a>
<a name="ln2724">	case 0x9001:</a>
<a name="ln2725">	case 0x9002:</a>
<a name="ln2726">	case 0x9003:</a>
<a name="ln2727">		rxf_hi = AGE_RX_RING_CNT / 16;</a>
<a name="ln2728">		rxf_lo = (AGE_RX_RING_CNT * 7) / 8;</a>
<a name="ln2729">		rrd_hi = (AGE_RR_RING_CNT * 7) / 8;</a>
<a name="ln2730">		rrd_lo = AGE_RR_RING_CNT / 16;</a>
<a name="ln2731">		break;</a>
<a name="ln2732">	default:</a>
<a name="ln2733">		reg = CSR_READ_4(sc, AGE_SRAM_RX_FIFO_LEN);</a>
<a name="ln2734">		rxf_lo = reg / 16;</a>
<a name="ln2735">		if (rxf_lo &lt; 192)</a>
<a name="ln2736">			rxf_lo = 192;</a>
<a name="ln2737">		rxf_hi = (reg * 7) / 8;</a>
<a name="ln2738">		if (rxf_hi &lt; rxf_lo)</a>
<a name="ln2739">			rxf_hi = rxf_lo + 16;</a>
<a name="ln2740">		reg = CSR_READ_4(sc, AGE_SRAM_RRD_LEN);</a>
<a name="ln2741">		rrd_lo = reg / 8;</a>
<a name="ln2742">		rrd_hi = (reg * 7) / 8;</a>
<a name="ln2743">		if (rrd_lo &lt; 2)</a>
<a name="ln2744">			rrd_lo = 2;</a>
<a name="ln2745">		if (rrd_hi &lt; rrd_lo)</a>
<a name="ln2746">			rrd_hi = rrd_lo + 3;</a>
<a name="ln2747">		break;</a>
<a name="ln2748">	}</a>
<a name="ln2749">	CSR_WRITE_4(sc, AGE_RXQ_FIFO_PAUSE_THRESH,</a>
<a name="ln2750">	    ((rxf_lo &lt;&lt; RXQ_FIFO_PAUSE_THRESH_LO_SHIFT) &amp;</a>
<a name="ln2751">	    RXQ_FIFO_PAUSE_THRESH_LO_MASK) |</a>
<a name="ln2752">	    ((rxf_hi &lt;&lt; RXQ_FIFO_PAUSE_THRESH_HI_SHIFT) &amp;</a>
<a name="ln2753">	    RXQ_FIFO_PAUSE_THRESH_HI_MASK));</a>
<a name="ln2754">	CSR_WRITE_4(sc, AGE_RXQ_RRD_PAUSE_THRESH,</a>
<a name="ln2755">	    ((rrd_lo &lt;&lt; RXQ_RRD_PAUSE_THRESH_LO_SHIFT) &amp;</a>
<a name="ln2756">	    RXQ_RRD_PAUSE_THRESH_LO_MASK) |</a>
<a name="ln2757">	    ((rrd_hi &lt;&lt; RXQ_RRD_PAUSE_THRESH_HI_SHIFT) &amp;</a>
<a name="ln2758">	    RXQ_RRD_PAUSE_THRESH_HI_MASK));</a>
<a name="ln2759"> </a>
<a name="ln2760">	/* Configure RxQ. */</a>
<a name="ln2761">	CSR_WRITE_4(sc, AGE_RXQ_CFG,</a>
<a name="ln2762">	    ((RXQ_CFG_RD_BURST_DEFAULT &lt;&lt; RXQ_CFG_RD_BURST_SHIFT) &amp;</a>
<a name="ln2763">	    RXQ_CFG_RD_BURST_MASK) |</a>
<a name="ln2764">	    ((RXQ_CFG_RRD_BURST_THRESH_DEFAULT &lt;&lt;</a>
<a name="ln2765">	    RXQ_CFG_RRD_BURST_THRESH_SHIFT) &amp; RXQ_CFG_RRD_BURST_THRESH_MASK) |</a>
<a name="ln2766">	    ((RXQ_CFG_RD_PREF_MIN_IPG_DEFAULT &lt;&lt;</a>
<a name="ln2767">	    RXQ_CFG_RD_PREF_MIN_IPG_SHIFT) &amp; RXQ_CFG_RD_PREF_MIN_IPG_MASK) |</a>
<a name="ln2768">	    RXQ_CFG_CUT_THROUGH_ENB | RXQ_CFG_ENB);</a>
<a name="ln2769"> </a>
<a name="ln2770">	/* Configure TxQ. */</a>
<a name="ln2771">	CSR_WRITE_4(sc, AGE_TXQ_CFG,</a>
<a name="ln2772">	    ((TXQ_CFG_TPD_BURST_DEFAULT &lt;&lt; TXQ_CFG_TPD_BURST_SHIFT) &amp;</a>
<a name="ln2773">	    TXQ_CFG_TPD_BURST_MASK) |</a>
<a name="ln2774">	    ((TXQ_CFG_TX_FIFO_BURST_DEFAULT &lt;&lt; TXQ_CFG_TX_FIFO_BURST_SHIFT) &amp;</a>
<a name="ln2775">	    TXQ_CFG_TX_FIFO_BURST_MASK) |</a>
<a name="ln2776">	    ((TXQ_CFG_TPD_FETCH_DEFAULT &lt;&lt;</a>
<a name="ln2777">	    TXQ_CFG_TPD_FETCH_THRESH_SHIFT) &amp; TXQ_CFG_TPD_FETCH_THRESH_MASK) |</a>
<a name="ln2778">	    TXQ_CFG_ENB);</a>
<a name="ln2779"> </a>
<a name="ln2780">	CSR_WRITE_4(sc, AGE_TX_JUMBO_TPD_TH_IPG,</a>
<a name="ln2781">	    (((fsize / sizeof(uint64_t) &lt;&lt; TX_JUMBO_TPD_TH_SHIFT)) &amp;</a>
<a name="ln2782">	    TX_JUMBO_TPD_TH_MASK) |</a>
<a name="ln2783">	    ((TX_JUMBO_TPD_IPG_DEFAULT &lt;&lt; TX_JUMBO_TPD_IPG_SHIFT) &amp;</a>
<a name="ln2784">	    TX_JUMBO_TPD_IPG_MASK));</a>
<a name="ln2785">	/* Configure DMA parameters. */</a>
<a name="ln2786">	CSR_WRITE_4(sc, AGE_DMA_CFG,</a>
<a name="ln2787">	    DMA_CFG_ENH_ORDER | DMA_CFG_RCB_64 |</a>
<a name="ln2788">	    sc-&gt;age_dma_rd_burst | DMA_CFG_RD_ENB |</a>
<a name="ln2789">	    sc-&gt;age_dma_wr_burst | DMA_CFG_WR_ENB);</a>
<a name="ln2790"> </a>
<a name="ln2791">	/* Configure CMB DMA write threshold. */</a>
<a name="ln2792">	CSR_WRITE_4(sc, AGE_CMB_WR_THRESH,</a>
<a name="ln2793">	    ((CMB_WR_THRESH_RRD_DEFAULT &lt;&lt; CMB_WR_THRESH_RRD_SHIFT) &amp;</a>
<a name="ln2794">	    CMB_WR_THRESH_RRD_MASK) |</a>
<a name="ln2795">	    ((CMB_WR_THRESH_TPD_DEFAULT &lt;&lt; CMB_WR_THRESH_TPD_SHIFT) &amp;</a>
<a name="ln2796">	    CMB_WR_THRESH_TPD_MASK));</a>
<a name="ln2797"> </a>
<a name="ln2798">	/* Set CMB/SMB timer and enable them. */</a>
<a name="ln2799">	CSR_WRITE_4(sc, AGE_CMB_WR_TIMER,</a>
<a name="ln2800">	    ((AGE_USECS(2) &lt;&lt; CMB_WR_TIMER_TX_SHIFT) &amp; CMB_WR_TIMER_TX_MASK) |</a>
<a name="ln2801">	    ((AGE_USECS(2) &lt;&lt; CMB_WR_TIMER_RX_SHIFT) &amp; CMB_WR_TIMER_RX_MASK));</a>
<a name="ln2802">	/* Request SMB updates for every seconds. */</a>
<a name="ln2803">	CSR_WRITE_4(sc, AGE_SMB_TIMER, AGE_USECS(1000 * 1000));</a>
<a name="ln2804">	CSR_WRITE_4(sc, AGE_CSMB_CTRL, CSMB_CTRL_SMB_ENB | CSMB_CTRL_CMB_ENB);</a>
<a name="ln2805"> </a>
<a name="ln2806">	/*</a>
<a name="ln2807">	 * Disable all WOL bits as WOL can interfere normal Rx</a>
<a name="ln2808">	 * operation.</a>
<a name="ln2809">	 */</a>
<a name="ln2810">	CSR_WRITE_4(sc, AGE_WOL_CFG, 0);</a>
<a name="ln2811"> </a>
<a name="ln2812">	/*</a>
<a name="ln2813">	 * Configure Tx/Rx MACs.</a>
<a name="ln2814">	 *  - Auto-padding for short frames.</a>
<a name="ln2815">	 *  - Enable CRC generation.</a>
<a name="ln2816">	 *  Start with full-duplex/1000Mbps media. Actual reconfiguration</a>
<a name="ln2817">	 *  of MAC is followed after link establishment.</a>
<a name="ln2818">	 */</a>
<a name="ln2819">	CSR_WRITE_4(sc, AGE_MAC_CFG,</a>
<a name="ln2820">	    MAC_CFG_TX_CRC_ENB | MAC_CFG_TX_AUTO_PAD |</a>
<a name="ln2821">	    MAC_CFG_FULL_DUPLEX | MAC_CFG_SPEED_1000 |</a>
<a name="ln2822">	    ((MAC_CFG_PREAMBLE_DEFAULT &lt;&lt; MAC_CFG_PREAMBLE_SHIFT) &amp;</a>
<a name="ln2823">	    MAC_CFG_PREAMBLE_MASK));</a>
<a name="ln2824">	/* Set up the receive filter. */</a>
<a name="ln2825">	age_rxfilter(sc);</a>
<a name="ln2826">	age_rxvlan(sc);</a>
<a name="ln2827"> </a>
<a name="ln2828">	reg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln2829">	if ((ifp-&gt;if_capenable &amp; IFCAP_RXCSUM) != 0)</a>
<a name="ln2830">		reg |= MAC_CFG_RXCSUM_ENB;</a>
<a name="ln2831"> </a>
<a name="ln2832">	/* Ack all pending interrupts and clear it. */</a>
<a name="ln2833">	CSR_WRITE_4(sc, AGE_INTR_STATUS, 0);</a>
<a name="ln2834">	CSR_WRITE_4(sc, AGE_INTR_MASK, AGE_INTRS);</a>
<a name="ln2835"> </a>
<a name="ln2836">	/* Finally enable Tx/Rx MAC. */</a>
<a name="ln2837">	CSR_WRITE_4(sc, AGE_MAC_CFG, reg | MAC_CFG_TX_ENB | MAC_CFG_RX_ENB);</a>
<a name="ln2838"> </a>
<a name="ln2839">	sc-&gt;age_flags &amp;= ~AGE_FLAG_LINK;</a>
<a name="ln2840">	/* Switch to the current media. */</a>
<a name="ln2841">	mii_mediachg(mii);</a>
<a name="ln2842"> </a>
<a name="ln2843">	callout_reset(&amp;sc-&gt;age_tick_ch, hz, age_tick, sc);</a>
<a name="ln2844"> </a>
<a name="ln2845">	ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</a>
<a name="ln2846">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln2847">}</a>
<a name="ln2848"> </a>
<a name="ln2849">static void</a>
<a name="ln2850">age_stop(struct age_softc *sc)</a>
<a name="ln2851">{</a>
<a name="ln2852">	struct ifnet *ifp;</a>
<a name="ln2853">	struct age_txdesc *txd;</a>
<a name="ln2854">	struct age_rxdesc *rxd;</a>
<a name="ln2855">	uint32_t reg;</a>
<a name="ln2856">	int i;</a>
<a name="ln2857"> </a>
<a name="ln2858">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2859">	/*</a>
<a name="ln2860">	 * Mark the interface down and cancel the watchdog timer.</a>
<a name="ln2861">	 */</a>
<a name="ln2862">	ifp = sc-&gt;age_ifp;</a>
<a name="ln2863">	ifp-&gt;if_drv_flags &amp;= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);</a>
<a name="ln2864">	sc-&gt;age_flags &amp;= ~AGE_FLAG_LINK;</a>
<a name="ln2865">	callout_stop(&amp;sc-&gt;age_tick_ch);</a>
<a name="ln2866">	sc-&gt;age_watchdog_timer = 0;</a>
<a name="ln2867"> </a>
<a name="ln2868">	/*</a>
<a name="ln2869">	 * Disable interrupts.</a>
<a name="ln2870">	 */</a>
<a name="ln2871">	CSR_WRITE_4(sc, AGE_INTR_MASK, 0);</a>
<a name="ln2872">	CSR_WRITE_4(sc, AGE_INTR_STATUS, 0xFFFFFFFF);</a>
<a name="ln2873">	/* Stop CMB/SMB updates. */</a>
<a name="ln2874">	CSR_WRITE_4(sc, AGE_CSMB_CTRL, 0);</a>
<a name="ln2875">	/* Stop Rx/Tx MAC. */</a>
<a name="ln2876">	age_stop_rxmac(sc);</a>
<a name="ln2877">	age_stop_txmac(sc);</a>
<a name="ln2878">	/* Stop DMA. */</a>
<a name="ln2879">	CSR_WRITE_4(sc, AGE_DMA_CFG,</a>
<a name="ln2880">	    CSR_READ_4(sc, AGE_DMA_CFG) &amp; ~(DMA_CFG_RD_ENB | DMA_CFG_WR_ENB));</a>
<a name="ln2881">	/* Stop TxQ/RxQ. */</a>
<a name="ln2882">	CSR_WRITE_4(sc, AGE_TXQ_CFG,</a>
<a name="ln2883">	    CSR_READ_4(sc, AGE_TXQ_CFG) &amp; ~TXQ_CFG_ENB);</a>
<a name="ln2884">	CSR_WRITE_4(sc, AGE_RXQ_CFG,</a>
<a name="ln2885">	    CSR_READ_4(sc, AGE_RXQ_CFG) &amp; ~RXQ_CFG_ENB);</a>
<a name="ln2886">	for (i = AGE_RESET_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln2887">		if ((reg = CSR_READ_4(sc, AGE_IDLE_STATUS)) == 0)</a>
<a name="ln2888">			break;</a>
<a name="ln2889">		DELAY(10);</a>
<a name="ln2890">	}</a>
<a name="ln2891">	if (i == 0)</a>
<a name="ln2892">		device_printf(sc-&gt;age_dev,</a>
<a name="ln2893">		    &quot;stopping Rx/Tx MACs timed out(0x%08x)!\n&quot;, reg);</a>
<a name="ln2894"> </a>
<a name="ln2895">	 /* Reclaim Rx buffers that have been processed. */</a>
<a name="ln2896">	if (sc-&gt;age_cdata.age_rxhead != NULL)</a>
<a name="ln2897">		m_freem(sc-&gt;age_cdata.age_rxhead);</a>
<a name="ln2898">	AGE_RXCHAIN_RESET(sc);</a>
<a name="ln2899">	/*</a>
<a name="ln2900">	 * Free RX and TX mbufs still in the queues.</a>
<a name="ln2901">	 */</a>
<a name="ln2902">	for (i = 0; i &lt; AGE_RX_RING_CNT; i++) {</a>
<a name="ln2903">		rxd = &amp;sc-&gt;age_cdata.age_rxdesc[i];</a>
<a name="ln2904">		if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln2905">			bus_dmamap_sync(sc-&gt;age_cdata.age_rx_tag,</a>
<a name="ln2906">			    rxd-&gt;rx_dmamap, BUS_DMASYNC_POSTREAD);</a>
<a name="ln2907">			bus_dmamap_unload(sc-&gt;age_cdata.age_rx_tag,</a>
<a name="ln2908">			    rxd-&gt;rx_dmamap);</a>
<a name="ln2909">			m_freem(rxd-&gt;rx_m);</a>
<a name="ln2910">			rxd-&gt;rx_m = NULL;</a>
<a name="ln2911">		}</a>
<a name="ln2912">        }</a>
<a name="ln2913">	for (i = 0; i &lt; AGE_TX_RING_CNT; i++) {</a>
<a name="ln2914">		txd = &amp;sc-&gt;age_cdata.age_txdesc[i];</a>
<a name="ln2915">		if (txd-&gt;tx_m != NULL) {</a>
<a name="ln2916">			bus_dmamap_sync(sc-&gt;age_cdata.age_tx_tag,</a>
<a name="ln2917">			    txd-&gt;tx_dmamap, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2918">			bus_dmamap_unload(sc-&gt;age_cdata.age_tx_tag,</a>
<a name="ln2919">			    txd-&gt;tx_dmamap);</a>
<a name="ln2920">			m_freem(txd-&gt;tx_m);</a>
<a name="ln2921">			txd-&gt;tx_m = NULL;</a>
<a name="ln2922">		}</a>
<a name="ln2923">        }</a>
<a name="ln2924">}</a>
<a name="ln2925"> </a>
<a name="ln2926">static void</a>
<a name="ln2927">age_stop_txmac(struct age_softc *sc)</a>
<a name="ln2928">{</a>
<a name="ln2929">	uint32_t reg;</a>
<a name="ln2930">	int i;</a>
<a name="ln2931"> </a>
<a name="ln2932">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2933"> </a>
<a name="ln2934">	reg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln2935">	if ((reg &amp; MAC_CFG_TX_ENB) != 0) {</a>
<a name="ln2936">		reg &amp;= ~MAC_CFG_TX_ENB;</a>
<a name="ln2937">		CSR_WRITE_4(sc, AGE_MAC_CFG, reg);</a>
<a name="ln2938">	}</a>
<a name="ln2939">	/* Stop Tx DMA engine. */</a>
<a name="ln2940">	reg = CSR_READ_4(sc, AGE_DMA_CFG);</a>
<a name="ln2941">	if ((reg &amp; DMA_CFG_RD_ENB) != 0) {</a>
<a name="ln2942">		reg &amp;= ~DMA_CFG_RD_ENB;</a>
<a name="ln2943">		CSR_WRITE_4(sc, AGE_DMA_CFG, reg);</a>
<a name="ln2944">	}</a>
<a name="ln2945">	for (i = AGE_RESET_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln2946">		if ((CSR_READ_4(sc, AGE_IDLE_STATUS) &amp;</a>
<a name="ln2947">		    (IDLE_STATUS_TXMAC | IDLE_STATUS_DMARD)) == 0)</a>
<a name="ln2948">			break;</a>
<a name="ln2949">		DELAY(10);</a>
<a name="ln2950">	}</a>
<a name="ln2951">	if (i == 0)</a>
<a name="ln2952">		device_printf(sc-&gt;age_dev, &quot;stopping TxMAC timeout!\n&quot;);</a>
<a name="ln2953">}</a>
<a name="ln2954"> </a>
<a name="ln2955">static void</a>
<a name="ln2956">age_stop_rxmac(struct age_softc *sc)</a>
<a name="ln2957">{</a>
<a name="ln2958">	uint32_t reg;</a>
<a name="ln2959">	int i;</a>
<a name="ln2960"> </a>
<a name="ln2961">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2962"> </a>
<a name="ln2963">	reg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln2964">	if ((reg &amp; MAC_CFG_RX_ENB) != 0) {</a>
<a name="ln2965">		reg &amp;= ~MAC_CFG_RX_ENB;</a>
<a name="ln2966">		CSR_WRITE_4(sc, AGE_MAC_CFG, reg);</a>
<a name="ln2967">	}</a>
<a name="ln2968">	/* Stop Rx DMA engine. */</a>
<a name="ln2969">	reg = CSR_READ_4(sc, AGE_DMA_CFG);</a>
<a name="ln2970">	if ((reg &amp; DMA_CFG_WR_ENB) != 0) {</a>
<a name="ln2971">		reg &amp;= ~DMA_CFG_WR_ENB;</a>
<a name="ln2972">		CSR_WRITE_4(sc, AGE_DMA_CFG, reg);</a>
<a name="ln2973">	}</a>
<a name="ln2974">	for (i = AGE_RESET_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln2975">		if ((CSR_READ_4(sc, AGE_IDLE_STATUS) &amp;</a>
<a name="ln2976">		    (IDLE_STATUS_RXMAC | IDLE_STATUS_DMAWR)) == 0)</a>
<a name="ln2977">			break;</a>
<a name="ln2978">		DELAY(10);</a>
<a name="ln2979">	}</a>
<a name="ln2980">	if (i == 0)</a>
<a name="ln2981">		device_printf(sc-&gt;age_dev, &quot;stopping RxMAC timeout!\n&quot;);</a>
<a name="ln2982">}</a>
<a name="ln2983"> </a>
<a name="ln2984">static void</a>
<a name="ln2985">age_init_tx_ring(struct age_softc *sc)</a>
<a name="ln2986">{</a>
<a name="ln2987">	struct age_ring_data *rd;</a>
<a name="ln2988">	struct age_txdesc *txd;</a>
<a name="ln2989">	int i;</a>
<a name="ln2990"> </a>
<a name="ln2991">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln2992"> </a>
<a name="ln2993">	sc-&gt;age_cdata.age_tx_prod = 0;</a>
<a name="ln2994">	sc-&gt;age_cdata.age_tx_cons = 0;</a>
<a name="ln2995">	sc-&gt;age_cdata.age_tx_cnt = 0;</a>
<a name="ln2996"> </a>
<a name="ln2997">	rd = &amp;sc-&gt;age_rdata;</a>
<a name="ln2998">	bzero(rd-&gt;age_tx_ring, AGE_TX_RING_SZ);</a>
<a name="ln2999">	for (i = 0; i &lt; AGE_TX_RING_CNT; i++) {</a>
<a name="ln3000">		txd = &amp;sc-&gt;age_cdata.age_txdesc[i];</a>
<a name="ln3001">		txd-&gt;tx_desc = &amp;rd-&gt;age_tx_ring[i];</a>
<a name="ln3002">		txd-&gt;tx_m = NULL;</a>
<a name="ln3003">	}</a>
<a name="ln3004"> </a>
<a name="ln3005">	bus_dmamap_sync(sc-&gt;age_cdata.age_tx_ring_tag,</a>
<a name="ln3006">	    sc-&gt;age_cdata.age_tx_ring_map,</a>
<a name="ln3007">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3008">}</a>
<a name="ln3009"> </a>
<a name="ln3010">static int</a>
<a name="ln3011">age_init_rx_ring(struct age_softc *sc)</a>
<a name="ln3012">{</a>
<a name="ln3013">	struct age_ring_data *rd;</a>
<a name="ln3014">	struct age_rxdesc *rxd;</a>
<a name="ln3015">	int i;</a>
<a name="ln3016"> </a>
<a name="ln3017">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln3018"> </a>
<a name="ln3019">	sc-&gt;age_cdata.age_rx_cons = AGE_RX_RING_CNT - 1;</a>
<a name="ln3020">	sc-&gt;age_morework = 0;</a>
<a name="ln3021">	rd = &amp;sc-&gt;age_rdata;</a>
<a name="ln3022">	bzero(rd-&gt;age_rx_ring, AGE_RX_RING_SZ);</a>
<a name="ln3023">	for (i = 0; i &lt; AGE_RX_RING_CNT; i++) {</a>
<a name="ln3024">		rxd = &amp;sc-&gt;age_cdata.age_rxdesc[i];</a>
<a name="ln3025">		rxd-&gt;rx_m = NULL;</a>
<a name="ln3026">		rxd-&gt;rx_desc = &amp;rd-&gt;age_rx_ring[i];</a>
<a name="ln3027">		if (age_newbuf(sc, rxd) != 0)</a>
<a name="ln3028">			return (ENOBUFS);</a>
<a name="ln3029">	}</a>
<a name="ln3030"> </a>
<a name="ln3031">	bus_dmamap_sync(sc-&gt;age_cdata.age_rx_ring_tag,</a>
<a name="ln3032">	    sc-&gt;age_cdata.age_rx_ring_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln3033"> </a>
<a name="ln3034">	return (0);</a>
<a name="ln3035">}</a>
<a name="ln3036"> </a>
<a name="ln3037">static void</a>
<a name="ln3038">age_init_rr_ring(struct age_softc *sc)</a>
<a name="ln3039">{</a>
<a name="ln3040">	struct age_ring_data *rd;</a>
<a name="ln3041"> </a>
<a name="ln3042">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln3043"> </a>
<a name="ln3044">	sc-&gt;age_cdata.age_rr_cons = 0;</a>
<a name="ln3045">	AGE_RXCHAIN_RESET(sc);</a>
<a name="ln3046"> </a>
<a name="ln3047">	rd = &amp;sc-&gt;age_rdata;</a>
<a name="ln3048">	bzero(rd-&gt;age_rr_ring, AGE_RR_RING_SZ);</a>
<a name="ln3049">	bus_dmamap_sync(sc-&gt;age_cdata.age_rr_ring_tag,</a>
<a name="ln3050">	    sc-&gt;age_cdata.age_rr_ring_map,</a>
<a name="ln3051">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3052">}</a>
<a name="ln3053"> </a>
<a name="ln3054">static void</a>
<a name="ln3055">age_init_cmb_block(struct age_softc *sc)</a>
<a name="ln3056">{</a>
<a name="ln3057">	struct age_ring_data *rd;</a>
<a name="ln3058"> </a>
<a name="ln3059">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln3060"> </a>
<a name="ln3061">	rd = &amp;sc-&gt;age_rdata;</a>
<a name="ln3062">	bzero(rd-&gt;age_cmb_block, AGE_CMB_BLOCK_SZ);</a>
<a name="ln3063">	bus_dmamap_sync(sc-&gt;age_cdata.age_cmb_block_tag,</a>
<a name="ln3064">	    sc-&gt;age_cdata.age_cmb_block_map,</a>
<a name="ln3065">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3066">}</a>
<a name="ln3067"> </a>
<a name="ln3068">static void</a>
<a name="ln3069">age_init_smb_block(struct age_softc *sc)</a>
<a name="ln3070">{</a>
<a name="ln3071">	struct age_ring_data *rd;</a>
<a name="ln3072"> </a>
<a name="ln3073">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln3074"> </a>
<a name="ln3075">	rd = &amp;sc-&gt;age_rdata;</a>
<a name="ln3076">	bzero(rd-&gt;age_smb_block, AGE_SMB_BLOCK_SZ);</a>
<a name="ln3077">	bus_dmamap_sync(sc-&gt;age_cdata.age_smb_block_tag,</a>
<a name="ln3078">	    sc-&gt;age_cdata.age_smb_block_map,</a>
<a name="ln3079">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3080">}</a>
<a name="ln3081"> </a>
<a name="ln3082">static int</a>
<a name="ln3083">age_newbuf(struct age_softc *sc, struct age_rxdesc *rxd)</a>
<a name="ln3084">{</a>
<a name="ln3085">	struct rx_desc *desc;</a>
<a name="ln3086">	struct mbuf *m;</a>
<a name="ln3087">	bus_dma_segment_t segs[1];</a>
<a name="ln3088">	bus_dmamap_t map;</a>
<a name="ln3089">	int nsegs;</a>
<a name="ln3090"> </a>
<a name="ln3091">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln3092"> </a>
<a name="ln3093">	m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln3094">	if (m == NULL)</a>
<a name="ln3095">		return (ENOBUFS);</a>
<a name="ln3096">	m-&gt;m_len = m-&gt;m_pkthdr.len = MCLBYTES;</a>
<a name="ln3097">#ifndef __NO_STRICT_ALIGNMENT</a>
<a name="ln3098">	m_adj(m, AGE_RX_BUF_ALIGN);</a>
<a name="ln3099">#endif</a>
<a name="ln3100"> </a>
<a name="ln3101">	if (bus_dmamap_load_mbuf_sg(sc-&gt;age_cdata.age_rx_tag,</a>
<a name="ln3102">	    sc-&gt;age_cdata.age_rx_sparemap, m, segs, &amp;nsegs, 0) != 0) {</a>
<a name="ln3103">		m_freem(m);</a>
<a name="ln3104">		return (ENOBUFS);</a>
<a name="ln3105">	}</a>
<a name="ln3106">	KASSERT(nsegs == 1, (&quot;%s: %d segments returned!&quot;, __func__, nsegs));</a>
<a name="ln3107"> </a>
<a name="ln3108">	if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln3109">		bus_dmamap_sync(sc-&gt;age_cdata.age_rx_tag, rxd-&gt;rx_dmamap,</a>
<a name="ln3110">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln3111">		bus_dmamap_unload(sc-&gt;age_cdata.age_rx_tag, rxd-&gt;rx_dmamap);</a>
<a name="ln3112">	}</a>
<a name="ln3113">	map = rxd-&gt;rx_dmamap;</a>
<a name="ln3114">	rxd-&gt;rx_dmamap = sc-&gt;age_cdata.age_rx_sparemap;</a>
<a name="ln3115">	sc-&gt;age_cdata.age_rx_sparemap = map;</a>
<a name="ln3116">	bus_dmamap_sync(sc-&gt;age_cdata.age_rx_tag, rxd-&gt;rx_dmamap,</a>
<a name="ln3117">	    BUS_DMASYNC_PREREAD);</a>
<a name="ln3118">	rxd-&gt;rx_m = m;</a>
<a name="ln3119"> </a>
<a name="ln3120">	desc = rxd-&gt;rx_desc;</a>
<a name="ln3121">	desc-&gt;addr = htole64(segs[0].ds_addr);</a>
<a name="ln3122">	desc-&gt;len = htole32((segs[0].ds_len &amp; AGE_RD_LEN_MASK) &lt;&lt;</a>
<a name="ln3123">	    AGE_RD_LEN_SHIFT);</a>
<a name="ln3124">	return (0);</a>
<a name="ln3125">}</a>
<a name="ln3126"> </a>
<a name="ln3127">static void</a>
<a name="ln3128">age_rxvlan(struct age_softc *sc)</a>
<a name="ln3129">{</a>
<a name="ln3130">	struct ifnet *ifp;</a>
<a name="ln3131">	uint32_t reg;</a>
<a name="ln3132"> </a>
<a name="ln3133">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln3134"> </a>
<a name="ln3135">	ifp = sc-&gt;age_ifp;</a>
<a name="ln3136">	reg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln3137">	reg &amp;= ~MAC_CFG_VLAN_TAG_STRIP;</a>
<a name="ln3138">	if ((ifp-&gt;if_capenable &amp; IFCAP_VLAN_HWTAGGING) != 0)</a>
<a name="ln3139">		reg |= MAC_CFG_VLAN_TAG_STRIP;</a>
<a name="ln3140">	CSR_WRITE_4(sc, AGE_MAC_CFG, reg);</a>
<a name="ln3141">}</a>
<a name="ln3142"> </a>
<a name="ln3143">static void</a>
<a name="ln3144">age_rxfilter(struct age_softc *sc)</a>
<a name="ln3145">{</a>
<a name="ln3146">	struct ifnet *ifp;</a>
<a name="ln3147">	struct ifmultiaddr *ifma;</a>
<a name="ln3148">	uint32_t crc;</a>
<a name="ln3149">	uint32_t mchash[2];</a>
<a name="ln3150">	uint32_t rxcfg;</a>
<a name="ln3151"> </a>
<a name="ln3152">	AGE_LOCK_ASSERT(sc);</a>
<a name="ln3153"> </a>
<a name="ln3154">	ifp = sc-&gt;age_ifp;</a>
<a name="ln3155"> </a>
<a name="ln3156">	rxcfg = CSR_READ_4(sc, AGE_MAC_CFG);</a>
<a name="ln3157">	rxcfg &amp;= ~(MAC_CFG_ALLMULTI | MAC_CFG_BCAST | MAC_CFG_PROMISC);</a>
<a name="ln3158">	if ((ifp-&gt;if_flags &amp; IFF_BROADCAST) != 0)</a>
<a name="ln3159">		rxcfg |= MAC_CFG_BCAST;</a>
<a name="ln3160">	if ((ifp-&gt;if_flags &amp; (IFF_PROMISC | IFF_ALLMULTI)) != 0) {</a>
<a name="ln3161">		if ((ifp-&gt;if_flags &amp; IFF_PROMISC) != 0)</a>
<a name="ln3162">			rxcfg |= MAC_CFG_PROMISC;</a>
<a name="ln3163">		if ((ifp-&gt;if_flags &amp; IFF_ALLMULTI) != 0)</a>
<a name="ln3164">			rxcfg |= MAC_CFG_ALLMULTI;</a>
<a name="ln3165">		CSR_WRITE_4(sc, AGE_MAR0, 0xFFFFFFFF);</a>
<a name="ln3166">		CSR_WRITE_4(sc, AGE_MAR1, 0xFFFFFFFF);</a>
<a name="ln3167">		CSR_WRITE_4(sc, AGE_MAC_CFG, rxcfg);</a>
<a name="ln3168">		return;</a>
<a name="ln3169">	}</a>
<a name="ln3170"> </a>
<a name="ln3171">	/* Program new filter. */</a>
<a name="ln3172">	bzero(mchash, sizeof(mchash));</a>
<a name="ln3173"> </a>
<a name="ln3174">	if_maddr_rlock(ifp);</a>
<a name="ln3175">	TAILQ_FOREACH(ifma, &amp;sc-&gt;age_ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln3176">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln3177">			continue;</a>
<a name="ln3178">		crc = ether_crc32_be(LLADDR((struct sockaddr_dl *)</a>
<a name="ln3179">		    ifma-&gt;ifma_addr), ETHER_ADDR_LEN);</a>
<a name="ln3180">		mchash[crc &gt;&gt; 31] |= 1 &lt;&lt; ((crc &gt;&gt; 26) &amp; 0x1f);</a>
<a name="ln3181">	}</a>
<a name="ln3182">	if_maddr_runlock(ifp);</a>
<a name="ln3183"> </a>
<a name="ln3184">	CSR_WRITE_4(sc, AGE_MAR0, mchash[0]);</a>
<a name="ln3185">	CSR_WRITE_4(sc, AGE_MAR1, mchash[1]);</a>
<a name="ln3186">	CSR_WRITE_4(sc, AGE_MAC_CFG, rxcfg);</a>
<a name="ln3187">}</a>
<a name="ln3188"> </a>
<a name="ln3189">static int</a>
<a name="ln3190">sysctl_age_stats(SYSCTL_HANDLER_ARGS)</a>
<a name="ln3191">{</a>
<a name="ln3192">	struct age_softc *sc;</a>
<a name="ln3193">	struct age_stats *stats;</a>
<a name="ln3194">	int error, result;</a>
<a name="ln3195"> </a>
<a name="ln3196">	result = -1;</a>
<a name="ln3197">	error = sysctl_handle_int(oidp, &amp;result, 0, req);</a>
<a name="ln3198"> </a>
<a name="ln3199">	if (error != 0 || req-&gt;newptr == NULL)</a>
<a name="ln3200">		return (error);</a>
<a name="ln3201"> </a>
<a name="ln3202">	if (result != 1)</a>
<a name="ln3203">		return (error);</a>
<a name="ln3204"> </a>
<a name="ln3205">	sc = (struct age_softc *)arg1;</a>
<a name="ln3206">	stats = &amp;sc-&gt;age_stat;</a>
<a name="ln3207">	printf(&quot;%s statistics:\n&quot;, device_get_nameunit(sc-&gt;age_dev));</a>
<a name="ln3208">	printf(&quot;Transmit good frames : %ju\n&quot;,</a>
<a name="ln3209">	    (uintmax_t)stats-&gt;tx_frames);</a>
<a name="ln3210">	printf(&quot;Transmit good broadcast frames : %ju\n&quot;,</a>
<a name="ln3211">	    (uintmax_t)stats-&gt;tx_bcast_frames);</a>
<a name="ln3212">	printf(&quot;Transmit good multicast frames : %ju\n&quot;,</a>
<a name="ln3213">	    (uintmax_t)stats-&gt;tx_mcast_frames);</a>
<a name="ln3214">	printf(&quot;Transmit pause control frames : %u\n&quot;,</a>
<a name="ln3215">	    stats-&gt;tx_pause_frames);</a>
<a name="ln3216">	printf(&quot;Transmit control frames : %u\n&quot;,</a>
<a name="ln3217">	    stats-&gt;tx_control_frames);</a>
<a name="ln3218">	printf(&quot;Transmit frames with excessive deferrals : %u\n&quot;,</a>
<a name="ln3219">	    stats-&gt;tx_excess_defer);</a>
<a name="ln3220">	printf(&quot;Transmit deferrals : %u\n&quot;,</a>
<a name="ln3221">	    stats-&gt;tx_deferred);</a>
<a name="ln3222">	printf(&quot;Transmit good octets : %ju\n&quot;,</a>
<a name="ln3223">	    (uintmax_t)stats-&gt;tx_bytes);</a>
<a name="ln3224">	printf(&quot;Transmit good broadcast octets : %ju\n&quot;,</a>
<a name="ln3225">	    (uintmax_t)stats-&gt;tx_bcast_bytes);</a>
<a name="ln3226">	printf(&quot;Transmit good multicast octets : %ju\n&quot;,</a>
<a name="ln3227">	    (uintmax_t)stats-&gt;tx_mcast_bytes);</a>
<a name="ln3228">	printf(&quot;Transmit frames 64 bytes : %ju\n&quot;,</a>
<a name="ln3229">	    (uintmax_t)stats-&gt;tx_pkts_64);</a>
<a name="ln3230">	printf(&quot;Transmit frames 65 to 127 bytes : %ju\n&quot;,</a>
<a name="ln3231">	    (uintmax_t)stats-&gt;tx_pkts_65_127);</a>
<a name="ln3232">	printf(&quot;Transmit frames 128 to 255 bytes : %ju\n&quot;,</a>
<a name="ln3233">	    (uintmax_t)stats-&gt;tx_pkts_128_255);</a>
<a name="ln3234">	printf(&quot;Transmit frames 256 to 511 bytes : %ju\n&quot;,</a>
<a name="ln3235">	    (uintmax_t)stats-&gt;tx_pkts_256_511);</a>
<a name="ln3236">	printf(&quot;Transmit frames 512 to 1024 bytes : %ju\n&quot;,</a>
<a name="ln3237">	    (uintmax_t)stats-&gt;tx_pkts_512_1023);</a>
<a name="ln3238">	printf(&quot;Transmit frames 1024 to 1518 bytes : %ju\n&quot;,</a>
<a name="ln3239">	    (uintmax_t)stats-&gt;tx_pkts_1024_1518);</a>
<a name="ln3240">	printf(&quot;Transmit frames 1519 to MTU bytes : %ju\n&quot;,</a>
<a name="ln3241">	    (uintmax_t)stats-&gt;tx_pkts_1519_max);</a>
<a name="ln3242">	printf(&quot;Transmit single collisions : %u\n&quot;,</a>
<a name="ln3243">	    stats-&gt;tx_single_colls);</a>
<a name="ln3244">	printf(&quot;Transmit multiple collisions : %u\n&quot;,</a>
<a name="ln3245">	    stats-&gt;tx_multi_colls);</a>
<a name="ln3246">	printf(&quot;Transmit late collisions : %u\n&quot;,</a>
<a name="ln3247">	    stats-&gt;tx_late_colls);</a>
<a name="ln3248">	printf(&quot;Transmit abort due to excessive collisions : %u\n&quot;,</a>
<a name="ln3249">	    stats-&gt;tx_excess_colls);</a>
<a name="ln3250">	printf(&quot;Transmit underruns due to FIFO underruns : %u\n&quot;,</a>
<a name="ln3251">	    stats-&gt;tx_underrun);</a>
<a name="ln3252">	printf(&quot;Transmit descriptor write-back errors : %u\n&quot;,</a>
<a name="ln3253">	    stats-&gt;tx_desc_underrun);</a>
<a name="ln3254">	printf(&quot;Transmit frames with length mismatched frame size : %u\n&quot;,</a>
<a name="ln3255">	    stats-&gt;tx_lenerrs);</a>
<a name="ln3256">	printf(&quot;Transmit frames with truncated due to MTU size : %u\n&quot;,</a>
<a name="ln3257">	    stats-&gt;tx_lenerrs);</a>
<a name="ln3258"> </a>
<a name="ln3259">	printf(&quot;Receive good frames : %ju\n&quot;,</a>
<a name="ln3260">	    (uintmax_t)stats-&gt;rx_frames);</a>
<a name="ln3261">	printf(&quot;Receive good broadcast frames : %ju\n&quot;,</a>
<a name="ln3262">	    (uintmax_t)stats-&gt;rx_bcast_frames);</a>
<a name="ln3263">	printf(&quot;Receive good multicast frames : %ju\n&quot;,</a>
<a name="ln3264">	    (uintmax_t)stats-&gt;rx_mcast_frames);</a>
<a name="ln3265">	printf(&quot;Receive pause control frames : %u\n&quot;,</a>
<a name="ln3266">	    stats-&gt;rx_pause_frames);</a>
<a name="ln3267">	printf(&quot;Receive control frames : %u\n&quot;,</a>
<a name="ln3268">	    stats-&gt;rx_control_frames);</a>
<a name="ln3269">	printf(&quot;Receive CRC errors : %u\n&quot;,</a>
<a name="ln3270">	    stats-&gt;rx_crcerrs);</a>
<a name="ln3271">	printf(&quot;Receive frames with length errors : %u\n&quot;,</a>
<a name="ln3272">	    stats-&gt;rx_lenerrs);</a>
<a name="ln3273">	printf(&quot;Receive good octets : %ju\n&quot;,</a>
<a name="ln3274">	    (uintmax_t)stats-&gt;rx_bytes);</a>
<a name="ln3275">	printf(&quot;Receive good broadcast octets : %ju\n&quot;,</a>
<a name="ln3276">	    (uintmax_t)stats-&gt;rx_bcast_bytes);</a>
<a name="ln3277">	printf(&quot;Receive good multicast octets : %ju\n&quot;,</a>
<a name="ln3278">	    (uintmax_t)stats-&gt;rx_mcast_bytes);</a>
<a name="ln3279">	printf(&quot;Receive frames too short : %u\n&quot;,</a>
<a name="ln3280">	    stats-&gt;rx_runts);</a>
<a name="ln3281">	printf(&quot;Receive fragmented frames : %ju\n&quot;,</a>
<a name="ln3282">	    (uintmax_t)stats-&gt;rx_fragments);</a>
<a name="ln3283">	printf(&quot;Receive frames 64 bytes : %ju\n&quot;,</a>
<a name="ln3284">	    (uintmax_t)stats-&gt;rx_pkts_64);</a>
<a name="ln3285">	printf(&quot;Receive frames 65 to 127 bytes : %ju\n&quot;,</a>
<a name="ln3286">	    (uintmax_t)stats-&gt;rx_pkts_65_127);</a>
<a name="ln3287">	printf(&quot;Receive frames 128 to 255 bytes : %ju\n&quot;,</a>
<a name="ln3288">	    (uintmax_t)stats-&gt;rx_pkts_128_255);</a>
<a name="ln3289">	printf(&quot;Receive frames 256 to 511 bytes : %ju\n&quot;,</a>
<a name="ln3290">	    (uintmax_t)stats-&gt;rx_pkts_256_511);</a>
<a name="ln3291">	printf(&quot;Receive frames 512 to 1024 bytes : %ju\n&quot;,</a>
<a name="ln3292">	    (uintmax_t)stats-&gt;rx_pkts_512_1023);</a>
<a name="ln3293">	printf(&quot;Receive frames 1024 to 1518 bytes : %ju\n&quot;,</a>
<a name="ln3294">	    (uintmax_t)stats-&gt;rx_pkts_1024_1518);</a>
<a name="ln3295">	printf(&quot;Receive frames 1519 to MTU bytes : %ju\n&quot;,</a>
<a name="ln3296">	    (uintmax_t)stats-&gt;rx_pkts_1519_max);</a>
<a name="ln3297">	printf(&quot;Receive frames too long : %ju\n&quot;,</a>
<a name="ln3298">	    (uint64_t)stats-&gt;rx_pkts_truncated);</a>
<a name="ln3299">	printf(&quot;Receive frames with FIFO overflow : %u\n&quot;,</a>
<a name="ln3300">	    stats-&gt;rx_fifo_oflows);</a>
<a name="ln3301">	printf(&quot;Receive frames with return descriptor overflow : %u\n&quot;,</a>
<a name="ln3302">	    stats-&gt;rx_desc_oflows);</a>
<a name="ln3303">	printf(&quot;Receive frames with alignment errors : %u\n&quot;,</a>
<a name="ln3304">	    stats-&gt;rx_alignerrs);</a>
<a name="ln3305">	printf(&quot;Receive frames dropped due to address filtering : %ju\n&quot;,</a>
<a name="ln3306">	    (uint64_t)stats-&gt;rx_pkts_filtered);</a>
<a name="ln3307"> </a>
<a name="ln3308">	return (error);</a>
<a name="ln3309">}</a>
<a name="ln3310"> </a>
<a name="ln3311">static int</a>
<a name="ln3312">sysctl_int_range(SYSCTL_HANDLER_ARGS, int low, int high)</a>
<a name="ln3313">{</a>
<a name="ln3314">	int error, value;</a>
<a name="ln3315"> </a>
<a name="ln3316">	if (arg1 == NULL)</a>
<a name="ln3317">		return (EINVAL);</a>
<a name="ln3318">	value = *(int *)arg1;</a>
<a name="ln3319">	error = sysctl_handle_int(oidp, &amp;value, 0, req);</a>
<a name="ln3320">	if (error || req-&gt;newptr == NULL)</a>
<a name="ln3321">		return (error);</a>
<a name="ln3322">	if (value &lt; low || value &gt; high)</a>
<a name="ln3323">		return (EINVAL);</a>
<a name="ln3324">        *(int *)arg1 = value;</a>
<a name="ln3325"> </a>
<a name="ln3326">        return (0);</a>
<a name="ln3327">}</a>
<a name="ln3328"> </a>
<a name="ln3329">static int</a>
<a name="ln3330">sysctl_hw_age_proc_limit(SYSCTL_HANDLER_ARGS)</a>
<a name="ln3331">{</a>
<a name="ln3332">	return (sysctl_int_range(oidp, arg1, arg2, req,</a>
<a name="ln3333">	    AGE_PROC_MIN, AGE_PROC_MAX));</a>
<a name="ln3334">}</a>
<a name="ln3335"> </a>
<a name="ln3336">static int</a>
<a name="ln3337">sysctl_hw_age_int_mod(SYSCTL_HANDLER_ARGS)</a>
<a name="ln3338">{</a>
<a name="ln3339"> </a>
<a name="ln3340">	return (sysctl_int_range(oidp, arg1, arg2, req, AGE_IM_TIMER_MIN,</a>
<a name="ln3341">	    AGE_IM_TIMER_MAX));</a>
<a name="ln3342">}</a>

</code></pre>
<div class="balloon" rel="3305"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="3297"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
