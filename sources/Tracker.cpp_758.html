
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Tracker.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;Tracker.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;errno.h&gt;</a>
<a name="ln38">#include &lt;fs_attr.h&gt;</a>
<a name="ln39">#include &lt;fs_info.h&gt;</a>
<a name="ln40">#include &lt;image.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;strings.h&gt;</a>
<a name="ln43">#include &lt;sys/resource.h&gt;</a>
<a name="ln44">#include &lt;unistd.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;Alert.h&gt;</a>
<a name="ln47">#include &lt;Autolock.h&gt;</a>
<a name="ln48">#include &lt;Catalog.h&gt;</a>
<a name="ln49">#include &lt;Debug.h&gt;</a>
<a name="ln50">#include &lt;FindDirectory.h&gt;</a>
<a name="ln51">#include &lt;Locale.h&gt;</a>
<a name="ln52">#include &lt;MenuItem.h&gt;</a>
<a name="ln53">#include &lt;NodeInfo.h&gt;</a>
<a name="ln54">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln55">#include &lt;Path.h&gt;</a>
<a name="ln56">#include &lt;PathMonitor.h&gt;</a>
<a name="ln57">#include &lt;Roster.h&gt;</a>
<a name="ln58">#include &lt;StopWatch.h&gt;</a>
<a name="ln59">#include &lt;Volume.h&gt;</a>
<a name="ln60">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;Attributes.h&quot;</a>
<a name="ln63">#include &quot;AutoLock.h&quot;</a>
<a name="ln64">#include &quot;BackgroundImage.h&quot;</a>
<a name="ln65">#include &quot;Bitmaps.h&quot;</a>
<a name="ln66">#include &quot;Commands.h&quot;</a>
<a name="ln67">#include &quot;ContainerWindow.h&quot;</a>
<a name="ln68">#include &quot;DeskWindow.h&quot;</a>
<a name="ln69">#include &quot;FindPanel.h&quot;</a>
<a name="ln70">#include &quot;FunctionObject.h&quot;</a>
<a name="ln71">#include &quot;FSClipboard.h&quot;</a>
<a name="ln72">#include &quot;FSUtils.h&quot;</a>
<a name="ln73">#include &quot;InfoWindow.h&quot;</a>
<a name="ln74">#include &quot;MimeTypes.h&quot;</a>
<a name="ln75">#include &quot;MimeTypeList.h&quot;</a>
<a name="ln76">#include &quot;NodePreloader.h&quot;</a>
<a name="ln77">#include &quot;OpenWithWindow.h&quot;</a>
<a name="ln78">#include &quot;PoseView.h&quot;</a>
<a name="ln79">#include &quot;QueryContainerWindow.h&quot;</a>
<a name="ln80">#include &quot;StatusWindow.h&quot;</a>
<a name="ln81">#include &quot;TaskLoop.h&quot;</a>
<a name="ln82">#include &quot;Thread.h&quot;</a>
<a name="ln83">#include &quot;TrackerSettings.h&quot;</a>
<a name="ln84">#include &quot;TrackerSettingsWindow.h&quot;</a>
<a name="ln85">#include &quot;TrackerString.h&quot;</a>
<a name="ln86">#include &quot;TrashWatcher.h&quot;</a>
<a name="ln87">#include &quot;VirtualDirectoryWindow.h&quot;</a>
<a name="ln88"> </a>
<a name="ln89"> </a>
<a name="ln90">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln91">#define B_TRANSLATION_CONTEXT &quot;Tracker&quot;</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">// prototypes for some private kernel calls that will some day be public</a>
<a name="ln95">#ifndef _IMPEXP_ROOT</a>
<a name="ln96">#	define _IMPEXP_ROOT</a>
<a name="ln97">#endif</a>
<a name="ln98"> </a>
<a name="ln99"> </a>
<a name="ln100">const int32 DEFAULT_MON_NUM = 4096;</a>
<a name="ln101">	// copied from fsil.c</a>
<a name="ln102"> </a>
<a name="ln103">const int8 kOpenWindowNoFlags = 0;</a>
<a name="ln104">const int8 kOpenWindowMinimized = 1;</a>
<a name="ln105">const int8 kOpenWindowHasState = 2;</a>
<a name="ln106"> </a>
<a name="ln107">const uint32 PSV_MAKE_PRINTER_ACTIVE_QUIETLY = 'pmaq';</a>
<a name="ln108">	// from pr_server.h</a>
<a name="ln109"> </a>
<a name="ln110">const int32 kNodeMonitorBumpValue = 512;</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">namespace BPrivate {</a>
<a name="ln114"> </a>
<a name="ln115">NodePreloader* gPreloader = NULL;</a>
<a name="ln116"> </a>
<a name="ln117"> </a>
<a name="ln118">class LaunchLooper : public BLooper {</a>
<a name="ln119">public:</a>
<a name="ln120">	LaunchLooper()</a>
<a name="ln121">		:</a>
<a name="ln122">		BLooper(&quot;launch looper&quot;)</a>
<a name="ln123">	{</a>
<a name="ln124">	}</a>
<a name="ln125"> </a>
<a name="ln126">	virtual void</a>
<a name="ln127">	MessageReceived(BMessage* message)</a>
<a name="ln128">	{</a>
<a name="ln129">		void (*function)(const entry_ref*, const BMessage*, bool);</a>
<a name="ln130">		BMessage refs;</a>
<a name="ln131">		bool openWithOK;</a>
<a name="ln132">		entry_ref appRef;</a>
<a name="ln133"> </a>
<a name="ln134">		if (message-&gt;FindPointer(&quot;function&quot;, (void**)&amp;function) != B_OK</a>
<a name="ln135">			|| message-&gt;FindMessage(&quot;refs&quot;, &amp;refs) != B_OK</a>
<a name="ln136">			|| message-&gt;FindBool(&quot;openWithOK&quot;, &amp;openWithOK) != B_OK) {</a>
<a name="ln137">			printf(&quot;incomplete launch message\n&quot;);</a>
<a name="ln138">			return;</a>
<a name="ln139">		}</a>
<a name="ln140"> </a>
<a name="ln141">		if (message-&gt;FindRef(&quot;appRef&quot;, &amp;appRef) == B_OK)</a>
<a name="ln142">			function(&amp;appRef, &amp;refs, openWithOK);</a>
<a name="ln143">		else</a>
<a name="ln144">			function(NULL, &amp;refs, openWithOK);</a>
<a name="ln145">	}</a>
<a name="ln146">};</a>
<a name="ln147"> </a>
<a name="ln148">BLooper* gLaunchLooper = NULL;</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">// #pragma mark - functions</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">void</a>
<a name="ln155">InitIconPreloader()</a>
<a name="ln156">{</a>
<a name="ln157">	static int32 lock = 0;</a>
<a name="ln158"> </a>
<a name="ln159">	if (atomic_add(&amp;lock, 1) != 0) {</a>
<a name="ln160">		// Just wait for the icon cache to be instantiated</a>
<a name="ln161">		int32 tries = 20;</a>
<a name="ln162">		while (IconCache::sIconCache == NULL &amp;&amp; tries-- &gt; 0)</a>
<a name="ln163">			snooze(10000);</a>
<a name="ln164">		return;</a>
<a name="ln165">	}</a>
<a name="ln166"> </a>
<a name="ln167">	if (IconCache::sIconCache != NULL)</a>
<a name="ln168">		return;</a>
<a name="ln169"> </a>
<a name="ln170">	// only start the node preloader if its Tracker or the Deskbar itself,</a>
<a name="ln171">	// don't start it for file panels</a>
<a name="ln172"> </a>
<a name="ln173">	bool preload = dynamic_cast&lt;TTracker*&gt;(be_app) != NULL;</a>
<a name="ln174">	if (!preload) {</a>
<a name="ln175">		// check for deskbar</a>
<a name="ln176">		app_info info;</a>
<a name="ln177">		if (be_app-&gt;GetAppInfo(&amp;info) == B_OK</a>
<a name="ln178">			&amp;&amp; !strcmp(info.signature, kDeskbarSignature))</a>
<a name="ln179">			preload = true;</a>
<a name="ln180">	}</a>
<a name="ln181"> </a>
<a name="ln182">	if (preload) {</a>
<a name="ln183">		gPreloader = NodePreloader::InstallNodePreloader(&quot;NodePreloader&quot;,</a>
<a name="ln184">			be_app);</a>
<a name="ln185">	}</a>
<a name="ln186"> </a>
<a name="ln187">	IconCache::sIconCache = new IconCache();</a>
<a name="ln188"> </a>
<a name="ln189">	atomic_add(&amp;lock, -1);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">}	// namespace BPrivate</a>
<a name="ln193"> </a>
<a name="ln194"> </a>
<a name="ln195">uint32</a>
<a name="ln196">GetVolumeFlags(Model* model)</a>
<a name="ln197">{</a>
<a name="ln198">	fs_info info;</a>
<a name="ln199">	if (model-&gt;IsVolume()) {</a>
<a name="ln200">		// search for the correct volume</a>
<a name="ln201">		int32 cookie = 0;</a>
<a name="ln202">		dev_t device;</a>
<a name="ln203">		while ((device = next_dev(&amp;cookie)) &gt;= B_OK) {</a>
<a name="ln204">			if (fs_stat_dev(device,&amp;info))</a>
<a name="ln205">				continue;</a>
<a name="ln206"> </a>
<a name="ln207">			if (!strcmp(info.volume_name,model-&gt;Name()))</a>
<a name="ln208">				return info.flags;</a>
<a name="ln209">		}</a>
<a name="ln210">		return B_FS_HAS_ATTR;</a>
<a name="ln211">	}</a>
<a name="ln212">	if (!fs_stat_dev(model-&gt;NodeRef()-&gt;device,&amp;info))</a>
<a name="ln213">		return info.flags;</a>
<a name="ln214"> </a>
<a name="ln215">	return B_FS_HAS_ATTR;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">//	#pragma mark - WatchingInterface</a>
<a name="ln220"> </a>
<a name="ln221"> </a>
<a name="ln222">class TTracker::WatchingInterface : public BPathMonitor::BWatchingInterface {</a>
<a name="ln223">public:</a>
<a name="ln224">	virtual status_t WatchNode(const node_ref* node, uint32 flags,</a>
<a name="ln225">		const BMessenger&amp; target)</a>
<a name="ln226">	{</a>
<a name="ln227">		return TTracker::WatchNode(node, flags, target);</a>
<a name="ln228">	}</a>
<a name="ln229"> </a>
<a name="ln230">	virtual status_t WatchNode(const node_ref* node, uint32 flags,</a>
<a name="ln231">		const BHandler* handler, const BLooper* looper = NULL)</a>
<a name="ln232">	{</a>
<a name="ln233">		return TTracker::WatchNode(node, flags, BMessenger(handler, looper));</a>
<a name="ln234">	}</a>
<a name="ln235">};</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">//	#pragma mark - TTracker</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">TTracker::TTracker()</a>
<a name="ln242">	:</a>
<a name="ln243">	BApplication(kTrackerSignature),</a>
<a name="ln244">	fMimeTypeList(NULL),</a>
<a name="ln245">	fClipboardRefsWatcher(NULL),</a>
<a name="ln246">	fTrashWatcher(NULL),</a>
<a name="ln247">	fTaskLoop(NULL),</a>
<a name="ln248">	fNodeMonitorCount(-1),</a>
<a name="ln249">	fWatchingInterface(new WatchingInterface),</a>
<a name="ln250">	fSettingsWindow(NULL)</a>
<a name="ln251">{</a>
<a name="ln252">	BPathMonitor::SetWatchingInterface(fWatchingInterface);</a>
<a name="ln253"> </a>
<a name="ln254">	// set the cwd to /boot/home, anything that's launched</a>
<a name="ln255">	// from Tracker will automatically inherit this</a>
<a name="ln256">	BPath homePath;</a>
<a name="ln257"> </a>
<a name="ln258">	if (find_directory(B_USER_DIRECTORY, &amp;homePath) == B_OK)</a>
<a name="ln259">		chdir(homePath.Path());</a>
<a name="ln260"> </a>
<a name="ln261">	// ask for a bunch more file descriptors so that nested copying works well</a>
<a name="ln262">	struct rlimit rl;</a>
<a name="ln263">	rl.rlim_cur = 512;</a>
<a name="ln264">	rl.rlim_max = RLIM_SAVED_MAX;</a>
<a name="ln265">	setrlimit(RLIMIT_NOFILE, &amp;rl);</a>
<a name="ln266"> </a>
<a name="ln267">	fNodeMonitorCount = DEFAULT_MON_NUM;</a>
<a name="ln268"> </a>
<a name="ln269">	gLocalizedNamePreferred</a>
<a name="ln270">		= BLocaleRoster::Default()-&gt;IsFilesystemTranslationPreferred();</a>
<a name="ln271"> </a>
<a name="ln272">#ifdef CHECK_OPEN_MODEL_LEAKS</a>
<a name="ln273">	InitOpenModelDumping();</a>
<a name="ln274">#endif</a>
<a name="ln275"> </a>
<a name="ln276">	InitIconPreloader();</a>
<a name="ln277"> </a>
<a name="ln278">#ifdef LEAK_CHECKING</a>
<a name="ln279">	SetNewLeakChecking(true);</a>
<a name="ln280">	SetMallocLeakChecking(true);</a>
<a name="ln281">#endif</a>
<a name="ln282"> </a>
<a name="ln283">	// This is how often it should update the free space bar on the</a>
<a name="ln284">	// volume icons</a>
<a name="ln285">	SetPulseRate(1000000);</a>
<a name="ln286"> </a>
<a name="ln287">	gLaunchLooper = new LaunchLooper();</a>
<a name="ln288">	gLaunchLooper-&gt;Run();</a>
<a name="ln289"> </a>
<a name="ln290">	// open desktop window</a>
<a name="ln291">	BContainerWindow* deskWindow = NULL;</a>
<a name="ln292">	BDirectory deskDir;</a>
<a name="ln293">	if (FSGetDeskDir(&amp;deskDir) == B_OK) {</a>
<a name="ln294">		// create desktop</a>
<a name="ln295">		BEntry entry;</a>
<a name="ln296">		deskDir.GetEntry(&amp;entry);</a>
<a name="ln297">		Model* model = new Model(&amp;entry, true);</a>
<a name="ln298">		if (model-&gt;InitCheck() == B_OK) {</a>
<a name="ln299">			AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln300">			deskWindow = new BDeskWindow(&amp;fWindowList);</a>
<a name="ln301">			AutoLock&lt;BWindow&gt; windowLock(deskWindow);</a>
<a name="ln302">			deskWindow-&gt;CreatePoseView(model);</a>
<a name="ln303">			deskWindow-&gt;Init();</a>
<a name="ln304"> </a>
<a name="ln305">			if (TrackerSettings().ShowDisksIcon()) {</a>
<a name="ln306">				// create model for root of everything</a>
<a name="ln307">				BEntry entry(&quot;/&quot;);</a>
<a name="ln308">				Model model(&amp;entry);</a>
<a name="ln309">				if (model.InitCheck() == B_OK) {</a>
<a name="ln310">					// add the root icon to desktop window</a>
<a name="ln311">					BMessage message;</a>
<a name="ln312">					message.what = B_NODE_MONITOR;</a>
<a name="ln313">					message.AddInt32(&quot;opcode&quot;, B_ENTRY_CREATED);</a>
<a name="ln314">					message.AddInt32(&quot;device&quot;, model.NodeRef()-&gt;device);</a>
<a name="ln315">					message.AddInt64(&quot;node&quot;, model.NodeRef()-&gt;node);</a>
<a name="ln316">					message.AddInt64(&quot;directory&quot;,</a>
<a name="ln317">						model.EntryRef()-&gt;directory);</a>
<a name="ln318">					message.AddString(&quot;name&quot;, model.EntryRef()-&gt;name);</a>
<a name="ln319">					deskWindow-&gt;PostMessage(&amp;message, deskWindow-&gt;PoseView());</a>
<a name="ln320">				}</a>
<a name="ln321">			}</a>
<a name="ln322">		} else</a>
<a name="ln323">			delete model;</a>
<a name="ln324">	}</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">TTracker::~TTracker()</a>
<a name="ln329">{</a>
<a name="ln330">	gLaunchLooper-&gt;Lock();</a>
<a name="ln331">	gLaunchLooper-&gt;Quit();</a>
<a name="ln332"> </a>
<a name="ln333">	BPathMonitor::SetWatchingInterface(NULL);</a>
<a name="ln334">	delete fWatchingInterface;</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">bool</a>
<a name="ln339">TTracker::QuitRequested()</a>
<a name="ln340">{</a>
<a name="ln341">	// don't allow user quitting</a>
<a name="ln342">	if (CurrentMessage() != NULL &amp;&amp; CurrentMessage()-&gt;FindBool(&quot;shortcut&quot;)) {</a>
<a name="ln343">		// but allow quitting to hide fSettingsWindow</a>
<a name="ln344">		int32 index = 0;</a>
<a name="ln345">		BWindow* window = NULL;</a>
<a name="ln346">		while ((window = WindowAt(index++)) != NULL) {</a>
<a name="ln347">			if (window == fSettingsWindow) {</a>
<a name="ln348">				if (fSettingsWindow-&gt;Lock()) {</a>
<a name="ln349">					if (!fSettingsWindow-&gt;IsHidden()</a>
<a name="ln350">						&amp;&amp; fSettingsWindow-&gt;IsActive()) {</a>
<a name="ln351">						fSettingsWindow-&gt;Hide();</a>
<a name="ln352">					}</a>
<a name="ln353">					fSettingsWindow-&gt;Unlock();</a>
<a name="ln354">				}</a>
<a name="ln355">				break;</a>
<a name="ln356">			}</a>
<a name="ln357">		}</a>
<a name="ln358"> </a>
<a name="ln359">		return false;</a>
<a name="ln360">	}</a>
<a name="ln361"> </a>
<a name="ln362">	gStatusWindow-&gt;AttemptToQuit();</a>
<a name="ln363">		// try quitting the copy/move/empty trash threads</a>
<a name="ln364"> </a>
<a name="ln365">	BMessage message;</a>
<a name="ln366">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln367">	// save open windows in a message inside an attribute of the desktop</a>
<a name="ln368">	int32 count = fWindowList.CountItems();</a>
<a name="ln369">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln370">		BContainerWindow* window</a>
<a name="ln371">			= dynamic_cast&lt;BContainerWindow*&gt;(fWindowList.ItemAt(i));</a>
<a name="ln372"> </a>
<a name="ln373">		if (window != NULL &amp;&amp; window-&gt;Lock()) {</a>
<a name="ln374">			if (window-&gt;TargetModel() != NULL</a>
<a name="ln375">				&amp;&amp; !window-&gt;PoseView()-&gt;IsDesktopWindow()) {</a>
<a name="ln376">				if (window-&gt;TargetModel()-&gt;IsRoot())</a>
<a name="ln377">					message.AddBool(&quot;open_disks_window&quot;, true);</a>
<a name="ln378">				else {</a>
<a name="ln379">					BEntry entry;</a>
<a name="ln380">					BPath path;</a>
<a name="ln381">					const entry_ref* ref = window-&gt;TargetModel()-&gt;EntryRef();</a>
<a name="ln382">					if (entry.SetTo(ref) == B_OK</a>
<a name="ln383">						&amp;&amp; entry.GetPath(&amp;path) == B_OK) {</a>
<a name="ln384">						int8 flags = window-&gt;IsMinimized()</a>
<a name="ln385">							? kOpenWindowMinimized : kOpenWindowNoFlags;</a>
<a name="ln386">						uint32 deviceFlags</a>
<a name="ln387">							= GetVolumeFlags(window-&gt;TargetModel());</a>
<a name="ln388"> </a>
<a name="ln389">						// save state for every window which is</a>
<a name="ln390">						//	a) already open on another workspace</a>
<a name="ln391">						//	b) on a volume not capable of writing attributes</a>
<a name="ln392">						if (window != FindContainerWindow(ref)</a>
<a name="ln393">							|| (deviceFlags</a>
<a name="ln394">								&amp; (B_FS_HAS_ATTR | B_FS_IS_READONLY))</a>
<a name="ln395">									!= B_FS_HAS_ATTR) {</a>
<a name="ln396">							BMessage stateMessage;</a>
<a name="ln397">							window-&gt;SaveState(stateMessage);</a>
<a name="ln398">							window-&gt;SetSaveStateEnabled(false);</a>
<a name="ln399">								// This is to prevent its state to be saved</a>
<a name="ln400">								// to the node when closed.</a>
<a name="ln401">							message.AddMessage(&quot;window state&quot;, &amp;stateMessage);</a>
<a name="ln402">							flags |= kOpenWindowHasState;</a>
<a name="ln403">						}</a>
<a name="ln404">						const char* target;</a>
<a name="ln405">						bool pathAlreadyExists = false;</a>
<a name="ln406">						for (int32 index = 0;</a>
<a name="ln407">								message.FindString(&quot;paths&quot;, index, &amp;target)</a>
<a name="ln408">									== B_OK; index++) {</a>
<a name="ln409">							if (!strcmp(target,path.Path())) {</a>
<a name="ln410">								pathAlreadyExists = true;</a>
<a name="ln411">								break;</a>
<a name="ln412">							}</a>
<a name="ln413">						}</a>
<a name="ln414">						if (!pathAlreadyExists)</a>
<a name="ln415">							message.AddString(&quot;paths&quot;, path.Path());</a>
<a name="ln416"> </a>
<a name="ln417">						message.AddInt8(path.Path(), flags);</a>
<a name="ln418">					}</a>
<a name="ln419">				}</a>
<a name="ln420">			}</a>
<a name="ln421">			window-&gt;Unlock();</a>
<a name="ln422">		}</a>
<a name="ln423">	}</a>
<a name="ln424">	lock.Unlock();</a>
<a name="ln425"> </a>
<a name="ln426">	// write windows to open on disk</a>
<a name="ln427">	BDirectory deskDir;</a>
<a name="ln428">	if (!BootedInSafeMode() &amp;&amp; FSGetDeskDir(&amp;deskDir) == B_OK) {</a>
<a name="ln429">		// if message is empty, delete the corresponding attribute</a>
<a name="ln430">		if (message.CountNames(B_ANY_TYPE)) {</a>
<a name="ln431">			ssize_t size = message.FlattenedSize();</a>
<a name="ln432">			if (size &gt; 0) {</a>
<a name="ln433">				char* buffer = new char[size];</a>
<a name="ln434">				message.Flatten(buffer, size);</a>
<a name="ln435">				deskDir.WriteAttr(kAttrOpenWindows, B_MESSAGE_TYPE, 0, buffer,</a>
<a name="ln436">					size);</a>
<a name="ln437">				delete[] buffer;</a>
<a name="ln438">			}</a>
<a name="ln439">		} else</a>
<a name="ln440">			deskDir.RemoveAttr(kAttrOpenWindows);</a>
<a name="ln441">	}</a>
<a name="ln442"> </a>
<a name="ln443">	for (int32 count = 0; count &lt; 50; count++) {</a>
<a name="ln444">		// wait 5 seconds for the copiing/moving to quit</a>
<a name="ln445">		if (gStatusWindow-&gt;AttemptToQuit())</a>
<a name="ln446">			break;</a>
<a name="ln447"> </a>
<a name="ln448">		snooze(100000);</a>
<a name="ln449">	}</a>
<a name="ln450"> </a>
<a name="ln451">	return _inherited::QuitRequested();</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454"> </a>
<a name="ln455">void</a>
<a name="ln456">TTracker::Quit()</a>
<a name="ln457">{</a>
<a name="ln458">	TrackerSettings().SaveSettings(false);</a>
<a name="ln459"> </a>
<a name="ln460">	fClipboardRefsWatcher-&gt;Lock();</a>
<a name="ln461">	fClipboardRefsWatcher-&gt;Quit();</a>
<a name="ln462"> </a>
<a name="ln463">	fTrashWatcher-&gt;Lock();</a>
<a name="ln464">	fTrashWatcher-&gt;Quit();</a>
<a name="ln465"> </a>
<a name="ln466">	WellKnowEntryList::Quit();</a>
<a name="ln467"> </a>
<a name="ln468">	delete gPreloader;</a>
<a name="ln469">	delete fTaskLoop;</a>
<a name="ln470">	delete IconCache::sIconCache;</a>
<a name="ln471"> </a>
<a name="ln472">	_inherited::Quit();</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">void</a>
<a name="ln477">TTracker::MessageReceived(BMessage* message)</a>
<a name="ln478">{</a>
<a name="ln479">	if (HandleScriptingMessage(message))</a>
<a name="ln480">		return;</a>
<a name="ln481"> </a>
<a name="ln482">	switch (message-&gt;what) {</a>
<a name="ln483">		case kGetInfo:</a>
<a name="ln484">			OpenInfoWindows(message);</a>
<a name="ln485">			break;</a>
<a name="ln486"> </a>
<a name="ln487">		case kMoveToTrash:</a>
<a name="ln488">			MoveRefsToTrash(message);</a>
<a name="ln489">			break;</a>
<a name="ln490"> </a>
<a name="ln491">		case kSelect:</a>
<a name="ln492">			SelectRefs(message);</a>
<a name="ln493">			break;</a>
<a name="ln494"> </a>
<a name="ln495">		case kCloseWindowAndChildren:</a>
<a name="ln496">		{</a>
<a name="ln497">			const node_ref* itemNode;</a>
<a name="ln498">			ssize_t bytes;</a>
<a name="ln499">			if (message-&gt;FindData(&quot;node_ref&quot;, B_RAW_TYPE,</a>
<a name="ln500">					(const void**)&amp;itemNode, &amp;bytes) == B_OK) {</a>
<a name="ln501">				CloseWindowAndChildren(itemNode);</a>
<a name="ln502">			}</a>
<a name="ln503">			break;</a>
<a name="ln504">		}</a>
<a name="ln505"> </a>
<a name="ln506">		case kCloseAllWindows:</a>
<a name="ln507">			CloseAllWindows();</a>
<a name="ln508">			break;</a>
<a name="ln509"> </a>
<a name="ln510">		case kCloseAllInWorkspace:</a>
<a name="ln511">			CloseAllInWorkspace();</a>
<a name="ln512">			break;</a>
<a name="ln513"> </a>
<a name="ln514">		case kFindButton:</a>
<a name="ln515">			(new FindWindow())-&gt;Show();</a>
<a name="ln516">			break;</a>
<a name="ln517"> </a>
<a name="ln518">		case kEditQuery:</a>
<a name="ln519">			EditQueries(message);</a>
<a name="ln520">			break;</a>
<a name="ln521"> </a>
<a name="ln522">		case kShowSplash:</a>
<a name="ln523">			run_be_about();</a>
<a name="ln524">			break;</a>
<a name="ln525"> </a>
<a name="ln526">		case kAddPrinter:</a>
<a name="ln527">			// show the addprinter window</a>
<a name="ln528">			run_add_printer_panel();</a>
<a name="ln529">			break;</a>
<a name="ln530"> </a>
<a name="ln531">		case kMakeActivePrinter:</a>
<a name="ln532">			// get the current selection</a>
<a name="ln533">			SetDefaultPrinter(message);</a>
<a name="ln534">			break;</a>
<a name="ln535"> </a>
<a name="ln536">#ifdef MOUNT_MENU_IN_DESKBAR</a>
<a name="ln537">		case 'gmtv':</a>
<a name="ln538">		{</a>
<a name="ln539">			// Someone (probably the deskbar) has requested a list of</a>
<a name="ln540">			// mountable volumes.</a>
<a name="ln541">			BMessage reply;</a>
<a name="ln542">			AutoMounterLoop()-&gt;EachMountableItemAndFloppy(</a>
<a name="ln543">				&amp;AddMountableItemToMessage, &amp;reply);</a>
<a name="ln544">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln545">			break;</a>
<a name="ln546">		}</a>
<a name="ln547">#endif</a>
<a name="ln548"> </a>
<a name="ln549">		case kUnmountVolume:</a>
<a name="ln550">			// When the user attempts to unmount a volume from the mount</a>
<a name="ln551">			// context menu, this is where the message gets received.</a>
<a name="ln552">			// Save pose locations and forward this to the automounter</a>
<a name="ln553">			SaveAllPoseLocations();</a>
<a name="ln554">			// Fall through...</a>
<a name="ln555">		case kMountVolume:</a>
<a name="ln556">		case kMountAllNow:</a>
<a name="ln557">			MountServer().SendMessage(message);</a>
<a name="ln558">			break;</a>
<a name="ln559"> </a>
<a name="ln560"> </a>
<a name="ln561">		case kRestoreBackgroundImage:</a>
<a name="ln562">		{</a>
<a name="ln563">			BDeskWindow* desktop = GetDeskWindow();</a>
<a name="ln564">			AutoLock&lt;BWindow&gt; lock(desktop);</a>
<a name="ln565">			desktop-&gt;UpdateDesktopBackgroundImages();</a>
<a name="ln566">			break;</a>
<a name="ln567">		}</a>
<a name="ln568"> </a>
<a name="ln569">		case kRunAutomounterSettings:</a>
<a name="ln570">			ShowSettingsWindow();</a>
<a name="ln571">			fSettingsWindow-&gt;ShowPage(</a>
<a name="ln572">				TrackerSettingsWindow::kAutomountSettings);</a>
<a name="ln573">			break;</a>
<a name="ln574"> </a>
<a name="ln575">		case kShowSettingsWindow:</a>
<a name="ln576">			ShowSettingsWindow();</a>
<a name="ln577">			break;</a>
<a name="ln578"> </a>
<a name="ln579">		case kFavoriteCountChangedExternally:</a>
<a name="ln580">			SendNotices(kFavoriteCountChangedExternally, message);</a>
<a name="ln581">			break;</a>
<a name="ln582"> </a>
<a name="ln583">		case kStartWatchClipboardRefs:</a>
<a name="ln584">		{</a>
<a name="ln585">			BMessenger messenger;</a>
<a name="ln586">			message-&gt;FindMessenger(&quot;target&quot;, &amp;messenger);</a>
<a name="ln587">			if (messenger.IsValid())</a>
<a name="ln588">				fClipboardRefsWatcher-&gt;AddToNotifyList(messenger);</a>
<a name="ln589">			break;</a>
<a name="ln590">		}</a>
<a name="ln591"> </a>
<a name="ln592">		case kStopWatchClipboardRefs:</a>
<a name="ln593">		{</a>
<a name="ln594">			BMessenger messenger;</a>
<a name="ln595">			if (message-&gt;FindMessenger(&quot;target&quot;, &amp;messenger) == B_OK</a>
<a name="ln596">				&amp;&amp; messenger.IsValid()) {</a>
<a name="ln597">				fClipboardRefsWatcher-&gt;RemoveFromNotifyList(messenger);</a>
<a name="ln598">			}</a>
<a name="ln599">			break;</a>
<a name="ln600">		}</a>
<a name="ln601"> </a>
<a name="ln602">		case kFSClipboardChanges:</a>
<a name="ln603">			fClipboardRefsWatcher-&gt;UpdatePoseViews(message);</a>
<a name="ln604">			break;</a>
<a name="ln605"> </a>
<a name="ln606">		case kShowVolumeSpaceBar:</a>
<a name="ln607">		case kSpaceBarColorChanged:</a>
<a name="ln608">			gPeriodicUpdatePoses.DoPeriodicUpdate(true);</a>
<a name="ln609">			break;</a>
<a name="ln610"> </a>
<a name="ln611">		case B_LOCALE_CHANGED:</a>
<a name="ln612">		{</a>
<a name="ln613">			BLocaleRoster::Default()-&gt;Refresh();</a>
<a name="ln614">			bool localize;</a>
<a name="ln615">			if (message-&gt;FindBool(&quot;filesys&quot;, &amp;localize) == B_OK)</a>
<a name="ln616">				gLocalizedNamePreferred = localize;</a>
<a name="ln617">			break;</a>
<a name="ln618">		}</a>
<a name="ln619"> </a>
<a name="ln620">		default:</a>
<a name="ln621">			_inherited::MessageReceived(message);</a>
<a name="ln622">			break;</a>
<a name="ln623">	}</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626"> </a>
<a name="ln627">void</a>
<a name="ln628">TTracker::Pulse()</a>
<a name="ln629">{</a>
<a name="ln630">	if (!TrackerSettings().ShowVolumeSpaceBar())</a>
<a name="ln631">		return;</a>
<a name="ln632"> </a>
<a name="ln633">	// update the volume icon's free space bars</a>
<a name="ln634">	gPeriodicUpdatePoses.DoPeriodicUpdate(false);</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637"> </a>
<a name="ln638">void</a>
<a name="ln639">TTracker::SetDefaultPrinter(const BMessage* message)</a>
<a name="ln640">{</a>
<a name="ln641">	// get the first item selected</a>
<a name="ln642">	int32 count = 0;</a>
<a name="ln643">	uint32 type = 0;</a>
<a name="ln644">	message-&gt;GetInfo(&quot;refs&quot;, &amp;type, &amp;count);</a>
<a name="ln645"> </a>
<a name="ln646">	if (count &lt;= 0)</a>
<a name="ln647">		return;</a>
<a name="ln648"> </a>
<a name="ln649">	// will make the first item the default printer, disregards any</a>
<a name="ln650">	// other files</a>
<a name="ln651">	entry_ref ref;</a>
<a name="ln652">	ASSERT(message-&gt;FindRef(&quot;refs&quot;, 0, &amp;ref) == B_OK);</a>
<a name="ln653">	if (message-&gt;FindRef(&quot;refs&quot;, 0, &amp;ref) != B_OK)</a>
<a name="ln654">		return;</a>
<a name="ln655"> </a>
<a name="ln656">#if B_BEOS_VERSION_DANO</a>
<a name="ln657">	set_default_printer(ref.name);</a>
<a name="ln658">#else</a>
<a name="ln659">	// 	create a message for the print server</a>
<a name="ln660">	BMessenger messenger(&quot;application/x-vnd.Be-PSRV&quot;, -1);</a>
<a name="ln661">	if (!messenger.IsValid())</a>
<a name="ln662">		return;</a>
<a name="ln663"> </a>
<a name="ln664">	//	send the selection to the print server</a>
<a name="ln665">	BMessage makeActiveMessage(PSV_MAKE_PRINTER_ACTIVE_QUIETLY);</a>
<a name="ln666">	makeActiveMessage.AddString(&quot;printer&quot;, ref.name);</a>
<a name="ln667"> </a>
<a name="ln668">	BMessage reply;</a>
<a name="ln669">	messenger.SendMessage(&amp;makeActiveMessage, &amp;reply);</a>
<a name="ln670">#endif</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673"> </a>
<a name="ln674">void</a>
<a name="ln675">TTracker::MoveRefsToTrash(const BMessage* message)</a>
<a name="ln676">{</a>
<a name="ln677">	int32 count;</a>
<a name="ln678">	uint32 type;</a>
<a name="ln679">	message-&gt;GetInfo(&quot;refs&quot;, &amp;type, &amp;count);</a>
<a name="ln680"> </a>
<a name="ln681">	if (count &lt;= 0)</a>
<a name="ln682">		return;</a>
<a name="ln683"> </a>
<a name="ln684">	BObjectList&lt;entry_ref&gt;* srcList = new BObjectList&lt;entry_ref&gt;(count, true);</a>
<a name="ln685"> </a>
<a name="ln686">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln687">		entry_ref ref;</a>
<a name="ln688">		ASSERT(message-&gt;FindRef(&quot;refs&quot;, index, &amp;ref) == B_OK);</a>
<a name="ln689">		if (message-&gt;FindRef(&quot;refs&quot;, index, &amp;ref) != B_OK)</a>
<a name="ln690">			continue;</a>
<a name="ln691"> </a>
<a name="ln692">		AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln693">		BContainerWindow* window = FindParentContainerWindow(&amp;ref);</a>
<a name="ln694">		if (window != NULL) {</a>
<a name="ln695">			// if we have a window open for this entry, ask the pose to</a>
<a name="ln696">			// delete it, this will select the next entry</a>
<a name="ln697">			window-&gt;PoseView()-&gt;MoveEntryToTrash(&amp;ref);</a>
<a name="ln698">		} else {</a>
<a name="ln699">			// add all others to a list that gets deleted separately</a>
<a name="ln700">			srcList-&gt;AddItem(new entry_ref(ref));</a>
<a name="ln701">		}</a>
<a name="ln702">	}</a>
<a name="ln703"> </a>
<a name="ln704">	// async move to trash</a>
<a name="ln705">	FSMoveToTrash(srcList);</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">void</a>
<a name="ln710">TTracker::SelectRefs(const BMessage* message)</a>
<a name="ln711">{</a>
<a name="ln712">	uint32 type = 0;</a>
<a name="ln713">	int32 count = 0;</a>
<a name="ln714">	message-&gt;GetInfo(&quot;refs&quot;, &amp;type, &amp;count);</a>
<a name="ln715"> </a>
<a name="ln716">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln717">		entry_ref ref;</a>
<a name="ln718">		message-&gt;FindRef(&quot;refs&quot;, index, &amp;ref);</a>
<a name="ln719">		BEntry entry(&amp;ref, true);</a>
<a name="ln720">		if (entry.InitCheck() != B_OK || !entry.Exists())</a>
<a name="ln721">			continue;</a>
<a name="ln722"> </a>
<a name="ln723">		AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln724">		BContainerWindow* window = FindParentContainerWindow(&amp;ref);</a>
<a name="ln725">		if (window == NULL)</a>
<a name="ln726">			continue;</a>
<a name="ln727"> </a>
<a name="ln728">		char name[B_FILE_NAME_LENGTH];</a>
<a name="ln729">		if (entry.GetName(name) != B_OK)</a>
<a name="ln730">			continue;</a>
<a name="ln731"> </a>
<a name="ln732">		BString expression;</a>
<a name="ln733">		expression &lt;&lt; &quot;^&quot;;</a>
<a name="ln734">		expression &lt;&lt; name;</a>
<a name="ln735">		expression &lt;&lt; &quot;$&quot;;</a>
<a name="ln736"> </a>
<a name="ln737">		BMessage* selectMessage = new BMessage(kSelectMatchingEntries);</a>
<a name="ln738">		selectMessage-&gt;AddInt32(&quot;ExpressionType&quot;, kRegexpMatch);</a>
<a name="ln739">		selectMessage-&gt;AddString(&quot;Expression&quot;, expression);</a>
<a name="ln740">		selectMessage-&gt;AddBool(&quot;InvertSelection&quot;, false);</a>
<a name="ln741">		selectMessage-&gt;AddBool(&quot;IgnoreCase&quot;, false);</a>
<a name="ln742"> </a>
<a name="ln743">		window-&gt;Activate();</a>
<a name="ln744">			// must be activated to populate the pose list</a>
<a name="ln745"> </a>
<a name="ln746">		snooze(100000);</a>
<a name="ln747">			// wait a bit for the pose list to be populated</a>
<a name="ln748">			// ToDo: figure out why this is necessary</a>
<a name="ln749"> </a>
<a name="ln750">		window-&gt;PostMessage(selectMessage);</a>
<a name="ln751">	}</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">template &lt;class T, class FT&gt;</a>
<a name="ln756">class EntryAndNodeDoSoonWithMessageFunctor : public</a>
<a name="ln757">	FunctionObjectWithResult&lt;bool&gt; {</a>
<a name="ln758">public:</a>
<a name="ln759">	EntryAndNodeDoSoonWithMessageFunctor(FT func, T* target,</a>
<a name="ln760">		const entry_ref* child, const node_ref* parent,</a>
<a name="ln761">		const BMessage* message)</a>
<a name="ln762">		:</a>
<a name="ln763">		fFunc(func),</a>
<a name="ln764">		fTarget(target),</a>
<a name="ln765">		fNode(*parent),</a>
<a name="ln766">		fEntry(*child)</a>
<a name="ln767">	{</a>
<a name="ln768">		fSendMessage = message != NULL;</a>
<a name="ln769">		if (message != NULL)</a>
<a name="ln770">			fMessage = *message;</a>
<a name="ln771">	}</a>
<a name="ln772"> </a>
<a name="ln773">	virtual ~EntryAndNodeDoSoonWithMessageFunctor() {}</a>
<a name="ln774">	virtual void operator()()</a>
<a name="ln775">	{</a>
<a name="ln776">		result = (fTarget-&gt;*fFunc)(&amp;fEntry, &amp;fNode,</a>
<a name="ln777">			fSendMessage ? &amp;fMessage : NULL);</a>
<a name="ln778">	}</a>
<a name="ln779"> </a>
<a name="ln780">protected:</a>
<a name="ln781">	FT fFunc;</a>
<a name="ln782">	T* fTarget;</a>
<a name="ln783">	node_ref fNode;</a>
<a name="ln784">	entry_ref fEntry;</a>
<a name="ln785">	BMessage fMessage;</a>
<a name="ln786">	bool fSendMessage;</a>
<a name="ln787">};</a>
<a name="ln788"> </a>
<a name="ln789"> </a>
<a name="ln790">bool</a>
<a name="ln791">TTracker::LaunchAndCloseParentIfOK(const entry_ref* launchThis,</a>
<a name="ln792">	const node_ref* closeThis, const BMessage* messageToBundle)</a>
<a name="ln793">{</a>
<a name="ln794">	BMessage refsReceived(B_REFS_RECEIVED);</a>
<a name="ln795">	if (messageToBundle != NULL) {</a>
<a name="ln796">		refsReceived = *messageToBundle;</a>
<a name="ln797">		refsReceived.what = B_REFS_RECEIVED;</a>
<a name="ln798">	}</a>
<a name="ln799">	refsReceived.AddRef(&quot;refs&quot;, launchThis);</a>
<a name="ln800">	// synchronous launch, we are already in our own thread</a>
<a name="ln801">	if (TrackerLaunch(&amp;refsReceived, false) == B_OK) {</a>
<a name="ln802">		// if launched fine, close parent window in a bit</a>
<a name="ln803">		fTaskLoop-&gt;RunLater(NewMemberFunctionObject(&amp;TTracker::CloseParent,</a>
<a name="ln804">			this, *closeThis), 1000000);</a>
<a name="ln805">	}</a>
<a name="ln806"> </a>
<a name="ln807">	return false;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810"> </a>
<a name="ln811">status_t</a>
<a name="ln812">TTracker::OpenRef(const entry_ref* ref, const node_ref* nodeToClose,</a>
<a name="ln813">	const node_ref* nodeToSelect, OpenSelector selector,</a>
<a name="ln814">	const BMessage* messageToBundle)</a>
<a name="ln815">{</a>
<a name="ln816">	Model* model = NULL;</a>
<a name="ln817">	BEntry entry(ref, true);</a>
<a name="ln818">	status_t result = entry.InitCheck();</a>
<a name="ln819"> </a>
<a name="ln820">	if (result != B_OK) {</a>
<a name="ln821">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln822">			B_TRANSLATE(&quot;There was an error resolving the link.&quot;),</a>
<a name="ln823">			B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL,</a>
<a name="ln824">				B_WARNING_ALERT);</a>
<a name="ln825">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln826">		alert-&gt;Go();</a>
<a name="ln827"> </a>
<a name="ln828">		return result;</a>
<a name="ln829">	} else</a>
<a name="ln830">		model = new Model(&amp;entry);</a>
<a name="ln831"> </a>
<a name="ln832">	result = model-&gt;InitCheck();</a>
<a name="ln833">	if (result != B_OK) {</a>
<a name="ln834">		delete model;</a>
<a name="ln835">		return result;</a>
<a name="ln836">	}</a>
<a name="ln837"> </a>
<a name="ln838">	bool openAsContainer = model-&gt;IsContainer();</a>
<a name="ln839"> </a>
<a name="ln840">	if (openAsContainer &amp;&amp; selector != kOpenWith) {</a>
<a name="ln841">		// if folder or query has a preferred handler and it's not the</a>
<a name="ln842">		// Tracker, open it by sending refs to the handling app</a>
<a name="ln843"> </a>
<a name="ln844">		// if we are responding to the final open of OpenWith, just</a>
<a name="ln845">		// skip this and proceed to opening the container with Tracker</a>
<a name="ln846">		model-&gt;OpenNode();</a>
<a name="ln847">		BNodeInfo nodeInfo(model-&gt;Node());</a>
<a name="ln848">		char preferredApp[B_MIME_TYPE_LENGTH];</a>
<a name="ln849">		if (nodeInfo.GetPreferredApp(preferredApp) == B_OK</a>
<a name="ln850">			&amp;&amp; strcasecmp(preferredApp, kTrackerSignature) != 0) {</a>
<a name="ln851">			openAsContainer = false;</a>
<a name="ln852">		}</a>
<a name="ln853">		model-&gt;CloseNode();</a>
<a name="ln854">	}</a>
<a name="ln855"> </a>
<a name="ln856">	if (openAsContainer || selector == kRunOpenWithWindow) {</a>
<a name="ln857">		// special case opening plain folders, queries or using open with</a>
<a name="ln858">		OpenContainerWindow(model, NULL, selector, kRestoreDecor);</a>
<a name="ln859">			// window adopts model</a>
<a name="ln860">		if (nodeToClose)</a>
<a name="ln861">			CloseParentWaitingForChildSoon(ref, nodeToClose);</a>
<a name="ln862">	} else if (model-&gt;IsQueryTemplate()) {</a>
<a name="ln863">		// query template - open new find window</a>
<a name="ln864">		(new FindWindow(model-&gt;EntryRef()))-&gt;Show();</a>
<a name="ln865"> </a>
<a name="ln866">		delete model;</a>
<a name="ln867">		if (nodeToClose)</a>
<a name="ln868">			CloseParentWaitingForChildSoon(ref, nodeToClose);</a>
<a name="ln869">	} else {</a>
<a name="ln870">		delete model;</a>
<a name="ln871">		// run Launch in a separate thread and close parent if successful</a>
<a name="ln872">		if (nodeToClose) {</a>
<a name="ln873">			Thread::Launch(new EntryAndNodeDoSoonWithMessageFunctor&lt;TTracker,</a>
<a name="ln874">				bool (TTracker::*)(const entry_ref*, const node_ref*,</a>
<a name="ln875">				const BMessage*)&gt;(&amp;TTracker::LaunchAndCloseParentIfOK, this,</a>
<a name="ln876">				ref, nodeToClose, messageToBundle));</a>
<a name="ln877">		} else {</a>
<a name="ln878">			BMessage refsReceived(B_REFS_RECEIVED);</a>
<a name="ln879">			if (messageToBundle) {</a>
<a name="ln880">				refsReceived = *messageToBundle;</a>
<a name="ln881">				refsReceived.what = B_REFS_RECEIVED;</a>
<a name="ln882">			}</a>
<a name="ln883">			refsReceived.AddRef(&quot;refs&quot;, ref);</a>
<a name="ln884">			TrackerLaunch(&amp;refsReceived, true);</a>
<a name="ln885">		}</a>
<a name="ln886">	}</a>
<a name="ln887"> </a>
<a name="ln888">	if (nodeToSelect)</a>
<a name="ln889">		SelectChildInParentSoon(ref, nodeToSelect);</a>
<a name="ln890"> </a>
<a name="ln891">	return B_OK;</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894"> </a>
<a name="ln895">void</a>
<a name="ln896">TTracker::RefsReceived(BMessage* message)</a>
<a name="ln897">{</a>
<a name="ln898">	OpenSelector selector = kOpen;</a>
<a name="ln899">	if (message-&gt;HasInt32(&quot;launchUsingSelector&quot;))</a>
<a name="ln900">		selector = kRunOpenWithWindow;</a>
<a name="ln901"> </a>
<a name="ln902">	entry_ref handlingApp;</a>
<a name="ln903">	if (message-&gt;FindRef(&quot;handler&quot;, &amp;handlingApp) == B_OK)</a>
<a name="ln904">		selector = kOpenWith;</a>
<a name="ln905"> </a>
<a name="ln906">	int32 count;</a>
<a name="ln907">	uint32 type;</a>
<a name="ln908">	message-&gt;GetInfo(&quot;refs&quot;, &amp;type, &amp;count);</a>
<a name="ln909"> </a>
<a name="ln910">	switch (selector) {</a>
<a name="ln911">		case kRunOpenWithWindow:</a>
<a name="ln912">			OpenContainerWindow(NULL, message, selector);</a>
<a name="ln913">				// window adopts model</a>
<a name="ln914">			break;</a>
<a name="ln915"> </a>
<a name="ln916">		case kOpenWith:</a>
<a name="ln917">		{</a>
<a name="ln918">			// Open With resulted in passing refs and a handler,</a>
<a name="ln919">			// open the files with the handling app</a>
<a name="ln920">			message-&gt;RemoveName(&quot;handler&quot;);</a>
<a name="ln921"> </a>
<a name="ln922">			// have to find out if handling app is the Tracker</a>
<a name="ln923">			// if it is, just pass it to the active Tracker,</a>
<a name="ln924">			// no matter which Tracker was chosen to handle the refs</a>
<a name="ln925">			char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln926">			signature[0] = '\0';</a>
<a name="ln927">			{</a>
<a name="ln928">				BFile handlingNode(&amp;handlingApp, O_RDONLY);</a>
<a name="ln929">				BAppFileInfo appInfo(&amp;handlingNode);</a>
<a name="ln930">				appInfo.GetSignature(signature);</a>
<a name="ln931">			}</a>
<a name="ln932"> </a>
<a name="ln933">			if (strcasecmp(signature, kTrackerSignature) != 0) {</a>
<a name="ln934">				// handling app not Tracker, pass entries to the apps</a>
<a name="ln935">				// RefsReceived</a>
<a name="ln936">				TrackerLaunch(&amp;handlingApp, message, true);</a>
<a name="ln937">				break;</a>
<a name="ln938">			}</a>
<a name="ln939">		}</a>
<a name="ln940">		// fall thru, opening refs by the Tracker as if they were</a>
<a name="ln941">		// double-clicked</a>
<a name="ln942">		case kOpen:</a>
<a name="ln943">		{</a>
<a name="ln944">			// copy over &quot;Poses&quot; messenger so that refs received</a>
<a name="ln945">			// recipients know where the open came from</a>
<a name="ln946">			BMessage* bundleThis = NULL;</a>
<a name="ln947">			BMessage stackBundleThis;</a>
<a name="ln948">			BMessenger messenger;</a>
<a name="ln949">			if (message-&gt;FindMessenger(&quot;TrackerViewToken&quot;, &amp;messenger)</a>
<a name="ln950">					== B_OK) {</a>
<a name="ln951">				bundleThis = &amp;stackBundleThis;</a>
<a name="ln952">				bundleThis-&gt;AddMessenger(&quot;TrackerViewToken&quot;, messenger);</a>
<a name="ln953">			} else {</a>
<a name="ln954">				// copy over any &quot;be:*&quot; fields -- e.g. /bin/open may include</a>
<a name="ln955">				// &quot;be:line&quot; and &quot;be:column&quot;</a>
<a name="ln956">				for (int32 i = 0;; i++) {</a>
<a name="ln957">					char* name;</a>
<a name="ln958">					type_code type;</a>
<a name="ln959">					int32 count;</a>
<a name="ln960">					status_t error = message-&gt;GetInfo(B_ANY_TYPE, i, &amp;name,</a>
<a name="ln961">						&amp;type, &amp;count);</a>
<a name="ln962">					if (error != B_OK)</a>
<a name="ln963">						break;</a>
<a name="ln964"> </a>
<a name="ln965">					if (strncmp(name, &quot;be:&quot;, 3) != 0)</a>
<a name="ln966">						continue;</a>
<a name="ln967"> </a>
<a name="ln968">					for (int32 k = 0; k &lt; count; k++) {</a>
<a name="ln969">						const void* data;</a>
<a name="ln970">						ssize_t size;</a>
<a name="ln971">						if (message-&gt;FindData(name, type, k, &amp;data, &amp;size)</a>
<a name="ln972">								!= B_OK) {</a>
<a name="ln973">							break;</a>
<a name="ln974">						}</a>
<a name="ln975">						if (stackBundleThis.AddData(name, type, data, size)</a>
<a name="ln976">								!= B_OK) {</a>
<a name="ln977">							break;</a>
<a name="ln978">						}</a>
<a name="ln979">						bundleThis = &amp;stackBundleThis;</a>
<a name="ln980">					}</a>
<a name="ln981">				}</a>
<a name="ln982">			}</a>
<a name="ln983"> </a>
<a name="ln984">			for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln985">				entry_ref ref;</a>
<a name="ln986">				message-&gt;FindRef(&quot;refs&quot;, index, &amp;ref);</a>
<a name="ln987"> </a>
<a name="ln988">				const node_ref* nodeToClose = NULL;</a>
<a name="ln989">				const node_ref* nodeToSelect = NULL;</a>
<a name="ln990">				ssize_t numBytes;</a>
<a name="ln991"> </a>
<a name="ln992">				message-&gt;FindData(&quot;nodeRefsToClose&quot;, B_RAW_TYPE, index,</a>
<a name="ln993">					(const void**)&amp;nodeToClose, &amp;numBytes);</a>
<a name="ln994">				message-&gt;FindData(&quot;nodeRefToSelect&quot;, B_RAW_TYPE, index,</a>
<a name="ln995">					(const void**)&amp;nodeToSelect, &amp;numBytes);</a>
<a name="ln996"> </a>
<a name="ln997">				OpenRef(&amp;ref, nodeToClose, nodeToSelect, selector,</a>
<a name="ln998">					bundleThis);</a>
<a name="ln999">			}</a>
<a name="ln1000"> </a>
<a name="ln1001">			break;</a>
<a name="ln1002">		}</a>
<a name="ln1003">	}</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006"> </a>
<a name="ln1007">void</a>
<a name="ln1008">TTracker::ArgvReceived(int32 argc, char** argv)</a>
<a name="ln1009">{</a>
<a name="ln1010">	BMessage* message = CurrentMessage();</a>
<a name="ln1011">	const char* currentWorkingDirectoryPath = NULL;</a>
<a name="ln1012">	entry_ref ref;</a>
<a name="ln1013"> </a>
<a name="ln1014">	if (message-&gt;FindString(&quot;cwd&quot;, &amp;currentWorkingDirectoryPath) == B_OK) {</a>
<a name="ln1015">		BDirectory workingDirectory(currentWorkingDirectoryPath);</a>
<a name="ln1016">		for (int32 index = 1; index &lt; argc; index++) {</a>
<a name="ln1017">			BEntry entry;</a>
<a name="ln1018">			if (entry.SetTo(&amp;workingDirectory, argv[index]) == B_OK</a>
<a name="ln1019">				&amp;&amp; entry.GetRef(&amp;ref) == B_OK) {</a>
<a name="ln1020">				OpenRef(&amp;ref);</a>
<a name="ln1021">			} else if (get_ref_for_path(argv[index], &amp;ref) == B_OK)</a>
<a name="ln1022">				OpenRef(&amp;ref);</a>
<a name="ln1023">		}</a>
<a name="ln1024">	}</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027"> </a>
<a name="ln1028">void</a>
<a name="ln1029">TTracker::OpenContainerWindow(Model* model, BMessage* originalRefsList,</a>
<a name="ln1030">	OpenSelector openSelector, uint32 openFlags, bool checkAlreadyOpen,</a>
<a name="ln1031">	const BMessage* stateMessage)</a>
<a name="ln1032">{</a>
<a name="ln1033">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1034">	BContainerWindow* window = NULL;</a>
<a name="ln1035">	const node_ref* modelNodeRef = model-&gt;NodeRef();</a>
<a name="ln1036">	if (checkAlreadyOpen &amp;&amp; openSelector != kRunOpenWithWindow) {</a>
<a name="ln1037">		// find out if window already open</a>
<a name="ln1038">		window = FindContainerWindow(modelNodeRef);</a>
<a name="ln1039">	}</a>
<a name="ln1040"> </a>
<a name="ln1041">	bool someWindowActivated = false;</a>
<a name="ln1042"> </a>
<a name="ln1043">	uint32 workspace = (uint32)(1 &lt;&lt; current_workspace());</a>
<a name="ln1044">	int32 windowCount = 0;</a>
<a name="ln1045">	while (window != NULL) {</a>
<a name="ln1046">		if ((window-&gt;Workspaces() &amp; workspace) != 0</a>
<a name="ln1047">			&amp;&amp; (dynamic_cast&lt;BDeskWindow*&gt;(window) == NULL</a>
<a name="ln1048">				|| !TrackerSettings().SingleWindowBrowse())) {</a>
<a name="ln1049">			// We found at least one window that is open and is not Desktop</a>
<a name="ln1050">			// or we're in spatial mode, activate it and make sure we don't</a>
<a name="ln1051">			// jerk the workspaces around.</a>
<a name="ln1052">			window-&gt;Activate();</a>
<a name="ln1053">			someWindowActivated = true;</a>
<a name="ln1054">		}</a>
<a name="ln1055">		window = FindContainerWindow(model-&gt;NodeRef(), ++windowCount);</a>
<a name="ln1056">	}</a>
<a name="ln1057"> </a>
<a name="ln1058">	if (someWindowActivated) {</a>
<a name="ln1059">		delete model;</a>
<a name="ln1060">		return;</a>
<a name="ln1061">	}</a>
<a name="ln1062"> </a>
<a name="ln1063">	// If no window was activated (none in the current workspace),</a>
<a name="ln1064">	// we open a new one.</a>
<a name="ln1065"> </a>
<a name="ln1066">	if (openSelector == kRunOpenWithWindow) {</a>
<a name="ln1067">		BMessage* refList = NULL;</a>
<a name="ln1068">		if (originalRefsList == NULL) {</a>
<a name="ln1069">			// when passing just a single model, stuff it's entry in a single</a>
<a name="ln1070">			// element list anyway</a>
<a name="ln1071">			ASSERT(model != NULL);</a>
<a name="ln1072">			refList = new BMessage;</a>
<a name="ln1073">			refList-&gt;AddRef(&quot;refs&quot;, model-&gt;EntryRef());</a>
<a name="ln1074">			delete model;</a>
<a name="ln1075">			model = NULL;</a>
<a name="ln1076">		} else {</a>
<a name="ln1077">			// clone the message, window adopts it for it's own use</a>
<a name="ln1078">			refList = new BMessage(*originalRefsList);</a>
<a name="ln1079">		}</a>
<a name="ln1080">		window = new OpenWithContainerWindow(refList, &amp;fWindowList);</a>
<a name="ln1081">	} else if (model-&gt;IsQuery()) {</a>
<a name="ln1082">		// window will adopt the model</a>
<a name="ln1083">		window = new BQueryContainerWindow(&amp;fWindowList, openFlags);</a>
<a name="ln1084">	} else if (model-&gt;IsVirtualDirectory()) {</a>
<a name="ln1085">		// window will adopt the model</a>
<a name="ln1086">		window = new VirtualDirectoryWindow(&amp;fWindowList, openFlags);</a>
<a name="ln1087">	} else {</a>
<a name="ln1088">		// window will adopt the model</a>
<a name="ln1089">		window = new BContainerWindow(&amp;fWindowList, openFlags);</a>
<a name="ln1090">	}</a>
<a name="ln1091"> </a>
<a name="ln1092">	if (model != NULL &amp;&amp; window-&gt;LockLooper()) {</a>
<a name="ln1093">		window-&gt;CreatePoseView(model);</a>
<a name="ln1094">		if (window-&gt;PoseView() == NULL) {</a>
<a name="ln1095">			// Failed initialization.</a>
<a name="ln1096">			window-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1097">			window-&gt;UnlockLooper();</a>
<a name="ln1098">			return;</a>
<a name="ln1099">		}</a>
<a name="ln1100">		window-&gt;UnlockLooper();</a>
<a name="ln1101">	}</a>
<a name="ln1102"> </a>
<a name="ln1103">	BMessage restoreStateMessage(kRestoreState);</a>
<a name="ln1104"> </a>
<a name="ln1105">	if (stateMessage != NULL)</a>
<a name="ln1106">		restoreStateMessage.AddMessage(&quot;state&quot;, stateMessage);</a>
<a name="ln1107"> </a>
<a name="ln1108">	window-&gt;PostMessage(&amp;restoreStateMessage);</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111"> </a>
<a name="ln1112">void</a>
<a name="ln1113">TTracker::EditQueries(const BMessage* message)</a>
<a name="ln1114">{</a>
<a name="ln1115">	bool editOnlyIfTemplate;</a>
<a name="ln1116">	if (message-&gt;FindBool(&quot;editQueryOnPose&quot;, &amp;editOnlyIfTemplate) != B_OK)</a>
<a name="ln1117">		editOnlyIfTemplate = false;</a>
<a name="ln1118"> </a>
<a name="ln1119">	type_code type;</a>
<a name="ln1120">	int32 count;</a>
<a name="ln1121">	message-&gt;GetInfo(&quot;refs&quot;, &amp;type, &amp;count);</a>
<a name="ln1122">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1123">		entry_ref ref;</a>
<a name="ln1124">		message-&gt;FindRef(&quot;refs&quot;, index, &amp;ref);</a>
<a name="ln1125">		BEntry entry(&amp;ref, true);</a>
<a name="ln1126">		if (entry.InitCheck() == B_OK &amp;&amp; entry.Exists())</a>
<a name="ln1127">			(new FindWindow(&amp;ref, editOnlyIfTemplate))-&gt;Show();</a>
<a name="ln1128">	}</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131"> </a>
<a name="ln1132">void</a>
<a name="ln1133">TTracker::OpenInfoWindows(BMessage* message)</a>
<a name="ln1134">{</a>
<a name="ln1135">	type_code type;</a>
<a name="ln1136">	int32 count;</a>
<a name="ln1137">	message-&gt;GetInfo(&quot;refs&quot;, &amp;type, &amp;count);</a>
<a name="ln1138"> </a>
<a name="ln1139">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1140">		entry_ref ref;</a>
<a name="ln1141">		message-&gt;FindRef(&quot;refs&quot;, index, &amp;ref);</a>
<a name="ln1142">		BEntry entry;</a>
<a name="ln1143">		if (entry.SetTo(&amp;ref) == B_OK) {</a>
<a name="ln1144">			Model* model = new Model(&amp;entry);</a>
<a name="ln1145">			if (model-&gt;InitCheck() != B_OK) {</a>
<a name="ln1146">				delete model;</a>
<a name="ln1147">				continue;</a>
<a name="ln1148">			}</a>
<a name="ln1149"> </a>
<a name="ln1150">			AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1151">			BInfoWindow* wind = FindInfoWindow(model-&gt;NodeRef());</a>
<a name="ln1152"> </a>
<a name="ln1153">			if (wind) {</a>
<a name="ln1154">				wind-&gt;Activate();</a>
<a name="ln1155">				delete model;</a>
<a name="ln1156">			} else {</a>
<a name="ln1157">				wind = new BInfoWindow(model, index, &amp;fWindowList);</a>
<a name="ln1158">				wind-&gt;PostMessage(kRestoreState);</a>
<a name="ln1159">			}</a>
<a name="ln1160">		}</a>
<a name="ln1161">	}</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164"> </a>
<a name="ln1165">BDeskWindow*</a>
<a name="ln1166">TTracker::GetDeskWindow() const</a>
<a name="ln1167">{</a>
<a name="ln1168">	int32 count = fWindowList.CountItems();</a>
<a name="ln1169">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1170">		BDeskWindow* window = dynamic_cast&lt;BDeskWindow*&gt;(</a>
<a name="ln1171">			fWindowList.ItemAt(index));</a>
<a name="ln1172">		if (window != NULL)</a>
<a name="ln1173">			return window;</a>
<a name="ln1174">	}</a>
<a name="ln1175">	TRESPASS();</a>
<a name="ln1176"> </a>
<a name="ln1177">	return NULL;</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180"> </a>
<a name="ln1181">BContainerWindow*</a>
<a name="ln1182">TTracker::FindContainerWindow(const node_ref* node, int32 number) const</a>
<a name="ln1183">{</a>
<a name="ln1184">	ASSERT(fWindowList.IsLocked());</a>
<a name="ln1185"> </a>
<a name="ln1186">	int32 count = fWindowList.CountItems();</a>
<a name="ln1187">	int32 windowsFound = 0;</a>
<a name="ln1188">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1189">		BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(</a>
<a name="ln1190">			fWindowList.ItemAt(index));</a>
<a name="ln1191"> </a>
<a name="ln1192">		if (window != NULL &amp;&amp; window-&gt;IsShowing(node)</a>
<a name="ln1193">			&amp;&amp; number == windowsFound++) {</a>
<a name="ln1194">			return window;</a>
<a name="ln1195">		}</a>
<a name="ln1196">	}</a>
<a name="ln1197"> </a>
<a name="ln1198">	return NULL;</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201"> </a>
<a name="ln1202">BContainerWindow*</a>
<a name="ln1203">TTracker::FindContainerWindow(const entry_ref* entry, int32 number) const</a>
<a name="ln1204">{</a>
<a name="ln1205">	ASSERT(fWindowList.IsLocked());</a>
<a name="ln1206"> </a>
<a name="ln1207">	int32 count = fWindowList.CountItems();</a>
<a name="ln1208"> </a>
<a name="ln1209">	int32 windowsFound = 0;</a>
<a name="ln1210"> </a>
<a name="ln1211">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1212">		BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;</a>
<a name="ln1213">			(fWindowList.ItemAt(index));</a>
<a name="ln1214"> </a>
<a name="ln1215">		if (window &amp;&amp; window-&gt;IsShowing(entry) &amp;&amp; number == windowsFound++)</a>
<a name="ln1216">			return window;</a>
<a name="ln1217">	}</a>
<a name="ln1218"> </a>
<a name="ln1219">	return NULL;</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222"> </a>
<a name="ln1223">bool</a>
<a name="ln1224">TTracker::EntryHasWindowOpen(const entry_ref* entry)</a>
<a name="ln1225">{</a>
<a name="ln1226">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1227">	return FindContainerWindow(entry) != NULL;</a>
<a name="ln1228">}</a>
<a name="ln1229"> </a>
<a name="ln1230"> </a>
<a name="ln1231">BContainerWindow*</a>
<a name="ln1232">TTracker::FindParentContainerWindow(const entry_ref* ref) const</a>
<a name="ln1233">{</a>
<a name="ln1234">	BEntry entry(ref);</a>
<a name="ln1235">	BEntry parent;</a>
<a name="ln1236"> </a>
<a name="ln1237">	if (entry.GetParent(&amp;parent) != B_OK)</a>
<a name="ln1238">		return NULL;</a>
<a name="ln1239"> </a>
<a name="ln1240">	entry_ref parentRef;</a>
<a name="ln1241">	parent.GetRef(&amp;parentRef);</a>
<a name="ln1242"> </a>
<a name="ln1243">	ASSERT(fWindowList.IsLocked());</a>
<a name="ln1244"> </a>
<a name="ln1245">	int32 count = fWindowList.CountItems();</a>
<a name="ln1246">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1247">		BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(</a>
<a name="ln1248">			fWindowList.ItemAt(index));</a>
<a name="ln1249">		if (window != NULL &amp;&amp; window-&gt;IsShowing(&amp;parentRef))</a>
<a name="ln1250">			return window;</a>
<a name="ln1251">	}</a>
<a name="ln1252"> </a>
<a name="ln1253">	return NULL;</a>
<a name="ln1254">}</a>
<a name="ln1255"> </a>
<a name="ln1256"> </a>
<a name="ln1257">BInfoWindow*</a>
<a name="ln1258">TTracker::FindInfoWindow(const node_ref* node) const</a>
<a name="ln1259">{</a>
<a name="ln1260">	ASSERT(fWindowList.IsLocked());</a>
<a name="ln1261"> </a>
<a name="ln1262">	int32 count = fWindowList.CountItems();</a>
<a name="ln1263">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1264">		BInfoWindow* window = dynamic_cast&lt;BInfoWindow*&gt;(</a>
<a name="ln1265">			fWindowList.ItemAt(index));</a>
<a name="ln1266">		if (window != NULL &amp;&amp; window-&gt;IsShowing(node))</a>
<a name="ln1267">			return window;</a>
<a name="ln1268">	}</a>
<a name="ln1269"> </a>
<a name="ln1270">	return NULL;</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273"> </a>
<a name="ln1274">bool</a>
<a name="ln1275">TTracker::QueryActiveForDevice(dev_t device)</a>
<a name="ln1276">{</a>
<a name="ln1277">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1278">	int32 count = fWindowList.CountItems();</a>
<a name="ln1279">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1280">		BQueryContainerWindow* window = dynamic_cast&lt;BQueryContainerWindow*&gt;(</a>
<a name="ln1281">			fWindowList.ItemAt(index));</a>
<a name="ln1282">		if (window != NULL) {</a>
<a name="ln1283">			AutoLock&lt;BWindow&gt; lock(window);</a>
<a name="ln1284">			if (window-&gt;ActiveOnDevice(device))</a>
<a name="ln1285">				return true;</a>
<a name="ln1286">		}</a>
<a name="ln1287">	}</a>
<a name="ln1288"> </a>
<a name="ln1289">	return false;</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292"> </a>
<a name="ln1293">void</a>
<a name="ln1294">TTracker::CloseActiveQueryWindows(dev_t device)</a>
<a name="ln1295">{</a>
<a name="ln1296">	// used when trying to unmount a volume - an active query would prevent</a>
<a name="ln1297">	// that from happening</a>
<a name="ln1298">	bool closed = false;</a>
<a name="ln1299">	AutoLock&lt;WindowList&gt; lock(fWindowList);</a>
<a name="ln1300">	for (int32 index = fWindowList.CountItems(); index &gt;= 0; index--) {</a>
<a name="ln1301">		BQueryContainerWindow* window</a>
<a name="ln1302">			= dynamic_cast&lt;BQueryContainerWindow*&gt;(fWindowList.ItemAt(index));</a>
<a name="ln1303">		if (window != NULL) {</a>
<a name="ln1304">			AutoLock&lt;BWindow&gt; lock(window);</a>
<a name="ln1305">			if (window-&gt;ActiveOnDevice(device)) {</a>
<a name="ln1306">				window-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1307">				closed = true;</a>
<a name="ln1308">			}</a>
<a name="ln1309">		}</a>
<a name="ln1310">	}</a>
<a name="ln1311"> </a>
<a name="ln1312">	lock.Unlock();</a>
<a name="ln1313"> </a>
<a name="ln1314">	if (closed) {</a>
<a name="ln1315">		for (int32 timeout = 30; timeout; timeout--) {</a>
<a name="ln1316">			// wait a bit for windows to fully close</a>
<a name="ln1317">			if (!QueryActiveForDevice(device))</a>
<a name="ln1318">				return;</a>
<a name="ln1319"> </a>
<a name="ln1320">			snooze(100000);</a>
<a name="ln1321">		}</a>
<a name="ln1322">	}</a>
<a name="ln1323">}</a>
<a name="ln1324"> </a>
<a name="ln1325"> </a>
<a name="ln1326">void</a>
<a name="ln1327">TTracker::SaveAllPoseLocations()</a>
<a name="ln1328">{</a>
<a name="ln1329">	int32 numWindows = fWindowList.CountItems();</a>
<a name="ln1330">	for (int32 windowIndex = 0; windowIndex &lt; numWindows; windowIndex++) {</a>
<a name="ln1331">		BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(</a>
<a name="ln1332">			fWindowList.ItemAt(windowIndex));</a>
<a name="ln1333">		if (window != NULL) {</a>
<a name="ln1334">			AutoLock&lt;BWindow&gt; lock(window);</a>
<a name="ln1335">			BDeskWindow* deskWindow = dynamic_cast&lt;BDeskWindow*&gt;(window);</a>
<a name="ln1336">			if (deskWindow != NULL)</a>
<a name="ln1337">				deskWindow-&gt;SaveDesktopPoseLocations();</a>
<a name="ln1338">			else</a>
<a name="ln1339">				window-&gt;PoseView()-&gt;SavePoseLocations();</a>
<a name="ln1340">		}</a>
<a name="ln1341">	}</a>
<a name="ln1342">}</a>
<a name="ln1343"> </a>
<a name="ln1344"> </a>
<a name="ln1345">void</a>
<a name="ln1346">TTracker::CloseWindowAndChildren(const node_ref* node)</a>
<a name="ln1347">{</a>
<a name="ln1348">	BDirectory dir(node);</a>
<a name="ln1349">	if (dir.InitCheck() != B_OK)</a>
<a name="ln1350">		return;</a>
<a name="ln1351"> </a>
<a name="ln1352">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1353">	BObjectList&lt;BContainerWindow&gt; closeList;</a>
<a name="ln1354"> </a>
<a name="ln1355">	// make a list of all windows to be closed</a>
<a name="ln1356">	// count from end to beginning so we can remove items safely</a>
<a name="ln1357">	for (int32 index = fWindowList.CountItems() - 1; index &gt;= 0; index--) {</a>
<a name="ln1358">		BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(</a>
<a name="ln1359">			fWindowList.ItemAt(index));</a>
<a name="ln1360">		if (window &amp;&amp; window-&gt;TargetModel()) {</a>
<a name="ln1361">			BEntry wind_entry;</a>
<a name="ln1362">			wind_entry.SetTo(window-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln1363"> </a>
<a name="ln1364">			if ((*window-&gt;TargetModel()-&gt;NodeRef() == *node)</a>
<a name="ln1365">				|| dir.Contains(&amp;wind_entry)) {</a>
<a name="ln1366"> </a>
<a name="ln1367">				// ToDo:</a>
<a name="ln1368">				// get rid of the Remove here, BContainerWindow::Quit does it</a>
<a name="ln1369">				fWindowList.RemoveItemAt(index);</a>
<a name="ln1370">				closeList.AddItem(window);</a>
<a name="ln1371">			}</a>
<a name="ln1372">		}</a>
<a name="ln1373">	}</a>
<a name="ln1374"> </a>
<a name="ln1375">	// now really close the windows</a>
<a name="ln1376">	int32 numItems = closeList.CountItems();</a>
<a name="ln1377">	for (int32 index = 0; index &lt; numItems; index++) {</a>
<a name="ln1378">		BContainerWindow* window = closeList.ItemAt(index);</a>
<a name="ln1379">		window-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1380">	}</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383"> </a>
<a name="ln1384">void</a>
<a name="ln1385">TTracker::CloseAllInWorkspace()</a>
<a name="ln1386">{</a>
<a name="ln1387">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1388"> </a>
<a name="ln1389">	int32 currentWorkspace = 1 &lt;&lt; current_workspace();</a>
<a name="ln1390">	// count from end to beginning so we can remove items safely</a>
<a name="ln1391">	for (int32 index = fWindowList.CountItems() - 1; index &gt;= 0; index--) {</a>
<a name="ln1392">		BWindow* window = fWindowList.ItemAt(index);</a>
<a name="ln1393">		if (window != NULL &amp;&amp; (window-&gt;Workspaces() &amp; currentWorkspace) != 0) {</a>
<a name="ln1394">			// avoid the desktop</a>
<a name="ln1395">			if (dynamic_cast&lt;BDeskWindow*&gt;(window) == NULL</a>
<a name="ln1396">				&amp;&amp; dynamic_cast&lt;BStatusWindow*&gt;(window) == NULL) {</a>
<a name="ln1397">				window-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1398">			}</a>
<a name="ln1399">		}</a>
<a name="ln1400">	}</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403"> </a>
<a name="ln1404">void</a>
<a name="ln1405">TTracker::CloseAllWindows()</a>
<a name="ln1406">{</a>
<a name="ln1407">	// this is a response to the DeskBar sending us a B_QUIT, when it really</a>
<a name="ln1408">	// means to say close all your windows. It might be better to have it</a>
<a name="ln1409">	// send a kCloseAllWindows message and have windowless apps stay running,</a>
<a name="ln1410">	// which is what we will do for the Tracker</a>
<a name="ln1411">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1412"> </a>
<a name="ln1413">	int32 count = CountWindows();</a>
<a name="ln1414">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln1415">		BWindow* window = WindowAt(index);</a>
<a name="ln1416">		// avoid the desktop</a>
<a name="ln1417">		if (dynamic_cast&lt;BDeskWindow*&gt;(window) == NULL</a>
<a name="ln1418">			&amp;&amp; dynamic_cast&lt;BStatusWindow*&gt;(window) == NULL) {</a>
<a name="ln1419">			window-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1420">		}</a>
<a name="ln1421">	}</a>
<a name="ln1422"> </a>
<a name="ln1423">	// count from end to beginning so we can remove items safely</a>
<a name="ln1424">	for (int32 index = fWindowList.CountItems() - 1; index &gt;= 0; index--) {</a>
<a name="ln1425">		BWindow* window = fWindowList.ItemAt(index);</a>
<a name="ln1426">		if (dynamic_cast&lt;BDeskWindow*&gt;(window) == NULL</a>
<a name="ln1427">			&amp;&amp; dynamic_cast&lt;BStatusWindow*&gt;(window) == NULL) {</a>
<a name="ln1428">			// ToDo: get rid of the Remove here, BContainerWindow::Quit()</a>
<a name="ln1429">			// does it</a>
<a name="ln1430">			fWindowList.RemoveItemAt(index);</a>
<a name="ln1431">		}</a>
<a name="ln1432">	}</a>
<a name="ln1433">}</a>
<a name="ln1434"> </a>
<a name="ln1435"> </a>
<a name="ln1436">void</a>
<a name="ln1437">TTracker::_OpenPreviouslyOpenedWindows(const char* pathFilter)</a>
<a name="ln1438">{</a>
<a name="ln1439">	size_t filterLength = 0;</a>
<a name="ln1440">	if (pathFilter != NULL)</a>
<a name="ln1441">		filterLength = strlen(pathFilter);</a>
<a name="ln1442"> </a>
<a name="ln1443">	BDirectory deskDir;</a>
<a name="ln1444">	attr_info attrInfo;</a>
<a name="ln1445">	if (FSGetDeskDir(&amp;deskDir) != B_OK</a>
<a name="ln1446">		|| deskDir.GetAttrInfo(kAttrOpenWindows, &amp;attrInfo) != B_OK) {</a>
<a name="ln1447">		return;</a>
<a name="ln1448">	}</a>
<a name="ln1449"> </a>
<a name="ln1450">	char* buffer = (char*)malloc((size_t)attrInfo.size);</a>
<a name="ln1451">	BMessage message;</a>
<a name="ln1452">	if (deskDir.ReadAttr(kAttrOpenWindows, B_MESSAGE_TYPE, 0, buffer,</a>
<a name="ln1453">			(size_t)attrInfo.size) != attrInfo.size</a>
<a name="ln1454">		|| message.Unflatten(buffer) != B_OK) {</a>
<a name="ln1455">		free(buffer);</a>
<a name="ln1456">		return;</a>
<a name="ln1457">	}</a>
<a name="ln1458"> </a>
<a name="ln1459">	free(buffer);</a>
<a name="ln1460"> </a>
<a name="ln1461">	node_ref nodeRef;</a>
<a name="ln1462">	deskDir.GetNodeRef(&amp;nodeRef);</a>
<a name="ln1463"> </a>
<a name="ln1464">	int32 stateMessageCounter = 0;</a>
<a name="ln1465">	const char* path;</a>
<a name="ln1466">	for (int32 i = 0; message.FindString(&quot;paths&quot;, i, &amp;path) == B_OK; i++) {</a>
<a name="ln1467">		if (strncmp(path, pathFilter, filterLength) != 0)</a>
<a name="ln1468">			continue;</a>
<a name="ln1469"> </a>
<a name="ln1470">		BEntry entry(path, true);</a>
<a name="ln1471">		if (entry.InitCheck() != B_OK)</a>
<a name="ln1472">			continue;</a>
<a name="ln1473"> </a>
<a name="ln1474">		int8 flags = 0;</a>
<a name="ln1475">		for (int32 j = 0; message.FindInt8(path, j, &amp;flags) == B_OK; j++) {</a>
<a name="ln1476">			Model* model = new Model(&amp;entry);</a>
<a name="ln1477">			if (model-&gt;InitCheck() == B_OK &amp;&amp; model-&gt;IsContainer()) {</a>
<a name="ln1478">				BMessage state;</a>
<a name="ln1479">				bool restoreStateFromMessage = false;</a>
<a name="ln1480">				if ((flags &amp; kOpenWindowHasState) != 0</a>
<a name="ln1481">					&amp;&amp; message.FindMessage(&quot;window state&quot;,</a>
<a name="ln1482">						stateMessageCounter++, &amp;state) == B_OK) {</a>
<a name="ln1483">					restoreStateFromMessage = true;</a>
<a name="ln1484">				}</a>
<a name="ln1485"> </a>
<a name="ln1486">				if (restoreStateFromMessage) {</a>
<a name="ln1487">					OpenContainerWindow(model, 0, kOpen, kRestoreWorkspace</a>
<a name="ln1488">						| (flags &amp; kOpenWindowMinimized ? kIsHidden : 0U)</a>
<a name="ln1489">						| kRestoreDecor, false, &amp;state);</a>
<a name="ln1490">				} else {</a>
<a name="ln1491">					OpenContainerWindow(model, 0, kOpen, kRestoreWorkspace</a>
<a name="ln1492">						| (flags &amp; kOpenWindowMinimized ? kIsHidden : 0U)</a>
<a name="ln1493">						| kRestoreDecor);</a>
<a name="ln1494">				}</a>
<a name="ln1495">			} else</a>
<a name="ln1496">				delete model;</a>
<a name="ln1497">		}</a>
<a name="ln1498">	}</a>
<a name="ln1499"> </a>
<a name="ln1500">	// open disks window if needed</a>
<a name="ln1501"> </a>
<a name="ln1502">	if (pathFilter == NULL &amp;&amp; TrackerSettings().ShowDisksIcon()</a>
<a name="ln1503">		&amp;&amp; message.HasBool(&quot;open_disks_window&quot;)) {</a>
<a name="ln1504">		BEntry entry(&quot;/&quot;);</a>
<a name="ln1505">		Model* model = new Model(&amp;entry);</a>
<a name="ln1506">		if (model-&gt;InitCheck() == B_OK)</a>
<a name="ln1507">			OpenContainerWindow(model, 0, kOpen, kRestoreWorkspace);</a>
<a name="ln1508">		else</a>
<a name="ln1509">			delete model;</a>
<a name="ln1510">	}</a>
<a name="ln1511">}</a>
<a name="ln1512"> </a>
<a name="ln1513"> </a>
<a name="ln1514">void</a>
<a name="ln1515">TTracker::ReadyToRun()</a>
<a name="ln1516">{</a>
<a name="ln1517">	gStatusWindow = new BStatusWindow();</a>
<a name="ln1518">	InitMimeTypes();</a>
<a name="ln1519">	InstallDefaultTemplates();</a>
<a name="ln1520">	InstallIndices();</a>
<a name="ln1521">	InstallTemporaryBackgroundImages();</a>
<a name="ln1522"> </a>
<a name="ln1523">	fTrashWatcher = new BTrashWatcher();</a>
<a name="ln1524">	fTrashWatcher-&gt;Run();</a>
<a name="ln1525"> </a>
<a name="ln1526">	fClipboardRefsWatcher = new BClipboardRefsWatcher();</a>
<a name="ln1527">	fClipboardRefsWatcher-&gt;Run();</a>
<a name="ln1528"> </a>
<a name="ln1529">	fTaskLoop = new StandAloneTaskLoop(true);</a>
<a name="ln1530"> </a>
<a name="ln1531">	// kick off building the mime type list for find panels, etc.</a>
<a name="ln1532">	fMimeTypeList = new MimeTypeList();</a>
<a name="ln1533"> </a>
<a name="ln1534">	if (!BootedInSafeMode()) {</a>
<a name="ln1535">		// kick of transient query killer</a>
<a name="ln1536">		DeleteTransientQueriesTask::StartUpTransientQueryCleaner();</a>
<a name="ln1537">		// the mount_server will have mounted the previous volumes already.</a>
<a name="ln1538">		_OpenPreviouslyOpenedWindows();</a>
<a name="ln1539">	}</a>
<a name="ln1540">}</a>
<a name="ln1541"> </a>
<a name="ln1542"> </a>
<a name="ln1543">MimeTypeList*</a>
<a name="ln1544">TTracker::MimeTypes() const</a>
<a name="ln1545">{</a>
<a name="ln1546">	return fMimeTypeList;</a>
<a name="ln1547">}</a>
<a name="ln1548"> </a>
<a name="ln1549"> </a>
<a name="ln1550">void</a>
<a name="ln1551">TTracker::SelectChildInParentSoon(const entry_ref* parent,</a>
<a name="ln1552">	const node_ref* child)</a>
<a name="ln1553">{</a>
<a name="ln1554">	fTaskLoop-&gt;RunLater(NewMemberFunctionObjectWithResult</a>
<a name="ln1555">		(&amp;TTracker::SelectChildInParent, this, parent, child),</a>
<a name="ln1556">		100000, 200000, 5000000);</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559"> </a>
<a name="ln1560">void</a>
<a name="ln1561">TTracker::CloseParentWaitingForChildSoon(const entry_ref* child,</a>
<a name="ln1562">	const node_ref* parent)</a>
<a name="ln1563">{</a>
<a name="ln1564">	fTaskLoop-&gt;RunLater(NewMemberFunctionObjectWithResult</a>
<a name="ln1565">		(&amp;TTracker::CloseParentWaitingForChild, this, child, parent),</a>
<a name="ln1566">		200000, 100000, 5000000);</a>
<a name="ln1567">}</a>
<a name="ln1568"> </a>
<a name="ln1569"> </a>
<a name="ln1570">void</a>
<a name="ln1571">TTracker::SelectPoseAtLocationSoon(node_ref parent, BPoint pointInPose)</a>
<a name="ln1572">{</a>
<a name="ln1573">	fTaskLoop-&gt;RunLater(NewMemberFunctionObject</a>
<a name="ln1574">		(&amp;TTracker::SelectPoseAtLocationInParent, this, parent, pointInPose),</a>
<a name="ln1575">		100000);</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578"> </a>
<a name="ln1579">void</a>
<a name="ln1580">TTracker::SelectPoseAtLocationInParent(node_ref parent, BPoint pointInPose)</a>
<a name="ln1581">{</a>
<a name="ln1582">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1583">	BContainerWindow* parentWindow = FindContainerWindow(&amp;parent);</a>
<a name="ln1584">	if (parentWindow != NULL) {</a>
<a name="ln1585">		AutoLock&lt;BWindow&gt; lock(parentWindow);</a>
<a name="ln1586">		parentWindow-&gt;PoseView()-&gt;SelectPoseAtLocation(pointInPose);</a>
<a name="ln1587">	}</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590"> </a>
<a name="ln1591">bool</a>
<a name="ln1592">TTracker::CloseParentWaitingForChild(const entry_ref* child,</a>
<a name="ln1593">	const node_ref* parent)</a>
<a name="ln1594">{</a>
<a name="ln1595">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1596"> </a>
<a name="ln1597">	BContainerWindow* parentWindow = FindContainerWindow(parent);</a>
<a name="ln1598">	if (parentWindow == NULL) {</a>
<a name="ln1599">		// parent window already closed, give up</a>
<a name="ln1600">		return true;</a>
<a name="ln1601">	}</a>
<a name="ln1602"> </a>
<a name="ln1603">	// If child is a symbolic link, dereference it, so that</a>
<a name="ln1604">	// FindContainerWindow will succeed.</a>
<a name="ln1605">	BEntry entry(child, true);</a>
<a name="ln1606">	entry_ref resolvedChild;</a>
<a name="ln1607">	if (entry.GetRef(&amp;resolvedChild) != B_OK)</a>
<a name="ln1608">		resolvedChild = *child;</a>
<a name="ln1609"> </a>
<a name="ln1610">	BContainerWindow* window = FindContainerWindow(&amp;resolvedChild);</a>
<a name="ln1611">	if (window != NULL) {</a>
<a name="ln1612">		AutoLock&lt;BWindow&gt; lock(window);</a>
<a name="ln1613">		if (!window-&gt;IsHidden())</a>
<a name="ln1614">			return CloseParentWindowCommon(parentWindow);</a>
<a name="ln1615">	}</a>
<a name="ln1616"> </a>
<a name="ln1617">	return false;</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620"> </a>
<a name="ln1621">void</a>
<a name="ln1622">TTracker::CloseParent(node_ref parent)</a>
<a name="ln1623">{</a>
<a name="ln1624">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1625">	if (!lock)</a>
<a name="ln1626">		return;</a>
<a name="ln1627"> </a>
<a name="ln1628">	CloseParentWindowCommon(FindContainerWindow(&amp;parent));</a>
<a name="ln1629">}</a>
<a name="ln1630"> </a>
<a name="ln1631"> </a>
<a name="ln1632">void</a>
<a name="ln1633">TTracker::ShowSettingsWindow()</a>
<a name="ln1634">{</a>
<a name="ln1635">	if (fSettingsWindow == NULL) {</a>
<a name="ln1636">		fSettingsWindow = new TrackerSettingsWindow();</a>
<a name="ln1637">		fSettingsWindow-&gt;Show();</a>
<a name="ln1638">	} else {</a>
<a name="ln1639">		if (fSettingsWindow-&gt;Lock()) {</a>
<a name="ln1640">			if (fSettingsWindow-&gt;IsHidden())</a>
<a name="ln1641">				fSettingsWindow-&gt;Show();</a>
<a name="ln1642">			else</a>
<a name="ln1643">				fSettingsWindow-&gt;Activate();</a>
<a name="ln1644"> </a>
<a name="ln1645">			fSettingsWindow-&gt;Unlock();</a>
<a name="ln1646">		}</a>
<a name="ln1647">	}</a>
<a name="ln1648">}</a>
<a name="ln1649"> </a>
<a name="ln1650"> </a>
<a name="ln1651">bool</a>
<a name="ln1652">TTracker::CloseParentWindowCommon(BContainerWindow* window)</a>
<a name="ln1653">{</a>
<a name="ln1654">	ASSERT(fWindowList.IsLocked());</a>
<a name="ln1655"> </a>
<a name="ln1656">	if (dynamic_cast&lt;BDeskWindow*&gt;(window) != NULL) {</a>
<a name="ln1657">		// don't close the desktop</a>
<a name="ln1658">		return false;</a>
<a name="ln1659">	}</a>
<a name="ln1660"> </a>
<a name="ln1661">	window-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1662">	return true;</a>
<a name="ln1663">}</a>
<a name="ln1664"> </a>
<a name="ln1665"> </a>
<a name="ln1666">bool</a>
<a name="ln1667">TTracker::SelectChildInParent(const entry_ref* parent, const node_ref* child)</a>
<a name="ln1668">{</a>
<a name="ln1669">	AutoLock&lt;WindowList&gt; lock(&amp;fWindowList);</a>
<a name="ln1670"> </a>
<a name="ln1671">	BContainerWindow* window = FindContainerWindow(parent);</a>
<a name="ln1672">	if (window == NULL) {</a>
<a name="ln1673">		// parent window already closed, give up</a>
<a name="ln1674">		return false;</a>
<a name="ln1675">	}</a>
<a name="ln1676"> </a>
<a name="ln1677">	AutoLock&lt;BWindow&gt; windowLock(window);</a>
<a name="ln1678">	if (windowLock.IsLocked()) {</a>
<a name="ln1679">		BPoseView* view = window-&gt;PoseView();</a>
<a name="ln1680">		int32 index;</a>
<a name="ln1681">		BPose* pose = view-&gt;FindPose(child, &amp;index);</a>
<a name="ln1682">		if (pose != NULL) {</a>
<a name="ln1683">			view-&gt;SelectPose(pose, index);</a>
<a name="ln1684">			return true;</a>
<a name="ln1685">		}</a>
<a name="ln1686">	}</a>
<a name="ln1687"> </a>
<a name="ln1688">	return false;</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691"> </a>
<a name="ln1692">status_t</a>
<a name="ln1693">TTracker::NeedMoreNodeMonitors()</a>
<a name="ln1694">{</a>
<a name="ln1695">	fNodeMonitorCount += kNodeMonitorBumpValue;</a>
<a name="ln1696">	PRINT((&quot;bumping nodeMonitorCount to %&quot; B_PRId32 &quot;\n&quot;, fNodeMonitorCount));</a>
<a name="ln1697"> </a>
<a name="ln1698">	struct rlimit rl;</a>
<a name="ln1699">	rl.rlim_cur = fNodeMonitorCount;</a>
<a name="ln1700">	rl.rlim_max = RLIM_SAVED_MAX;</a>
<a name="ln1701">	if (setrlimit(RLIMIT_NOVMON, &amp;rl) &lt; 0) {</a>
<a name="ln1702">		fNodeMonitorCount -= kNodeMonitorBumpValue;</a>
<a name="ln1703">		return errno;</a>
<a name="ln1704">	}</a>
<a name="ln1705"> </a>
<a name="ln1706">	return B_OK;</a>
<a name="ln1707">}</a>
<a name="ln1708"> </a>
<a name="ln1709"> </a>
<a name="ln1710">status_t</a>
<a name="ln1711">TTracker::WatchNode(const node_ref* node, uint32 flags, BMessenger target)</a>
<a name="ln1712">{</a>
<a name="ln1713">	status_t result = watch_node(node, flags, target);</a>
<a name="ln1714">	if (result == B_OK || result != B_NO_MEMORY) {</a>
<a name="ln1715">		// need to make sure this uses the same error value as</a>
<a name="ln1716">		// the node monitor code</a>
<a name="ln1717">		return result;</a>
<a name="ln1718">	}</a>
<a name="ln1719"> </a>
<a name="ln1720">	PRINT((&quot;failed to start monitoring, trying to allocate more &quot;</a>
<a name="ln1721">		&quot;node monitors\n&quot;));</a>
<a name="ln1722"> </a>
<a name="ln1723">	TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln1724">	if (tracker == NULL) {</a>
<a name="ln1725">		// we are the file panel only, just fail</a>
<a name="ln1726">		return result;</a>
<a name="ln1727">	}</a>
<a name="ln1728"> </a>
<a name="ln1729">	result = tracker-&gt;NeedMoreNodeMonitors();</a>
<a name="ln1730"> </a>
<a name="ln1731">	if (result != B_OK) {</a>
<a name="ln1732">		PRINT((&quot;failed to allocate more node monitors, %s\n&quot;,</a>
<a name="ln1733">			strerror(result)));</a>
<a name="ln1734">		return result;</a>
<a name="ln1735">	}</a>
<a name="ln1736"> </a>
<a name="ln1737">	// try again, this time with more node monitors</a>
<a name="ln1738">	return watch_node(node, flags, target);</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741"> </a>
<a name="ln1742">BMessenger</a>
<a name="ln1743">TTracker::MountServer() const</a>
<a name="ln1744">{</a>
<a name="ln1745">	return BMessenger(kMountServerSignature);</a>
<a name="ln1746">}</a>
<a name="ln1747"> </a>
<a name="ln1748"> </a>
<a name="ln1749">bool</a>
<a name="ln1750">TTracker::TrashFull() const</a>
<a name="ln1751">{</a>
<a name="ln1752">	return fTrashWatcher-&gt;CheckTrashDirs();</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755"> </a>
<a name="ln1756">bool</a>
<a name="ln1757">TTracker::IsTrashNode(const node_ref* node) const</a>
<a name="ln1758">{</a>
<a name="ln1759">	return fTrashWatcher-&gt;IsTrashNode(node);</a>
<a name="ln1760">}</a>
<a name="ln1761"> </a>
<a name="ln1762">bool</a>
<a name="ln1763">TTracker::InTrashNode(const entry_ref* ref) const</a>
<a name="ln1764">{</a>
<a name="ln1765">	return FSInTrashDir(ref);</a>
<a name="ln1766">}</a>

</code></pre>
<div class="balloon" rel="1714"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting this expression. The expression is excessive or contains a misprint.</p></div>
<div class="balloon" rel="828"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
