
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>SGIImage.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*****************************************************************************/</a>
<a name="ln2">// SGITranslator</a>
<a name="ln3">// Written by Stephan AÃŸmus &lt;stippi@yellowbites.com&gt;</a>
<a name="ln4">// derived from GIMP SGI plugin by Michael Sweet</a>
<a name="ln5">//</a>
<a name="ln6">// SGIImage.cpp</a>
<a name="ln7">//</a>
<a name="ln8">// SGI image file format library routines.</a>
<a name="ln9">//</a>
<a name="ln10">// Formed into a class SGIImage, adopted to Be API and modified to use</a>
<a name="ln11">// BPositionIO, optimizations for buffered reading.</a>
<a name="ln12">//</a>
<a name="ln13">//</a>
<a name="ln14">// Copyright (c) 2003 OpenBeOS Project</a>
<a name="ln15">// Portions Copyright 1997-1998 Michael Sweet (mike@easysw.com)</a>
<a name="ln16">//</a>
<a name="ln17">// Permission is hereby granted, free of charge, to any person obtaining a</a>
<a name="ln18">// copy of this software and associated documentation files (the &quot;Software&quot;),</a>
<a name="ln19">// to deal in the Software without restriction, including without limitation</a>
<a name="ln20">// the rights to use, copy, modify, merge, publish, distribute, sublicense, </a>
<a name="ln21">// and/or sell copies of the Software, and to permit persons to whom the </a>
<a name="ln22">// Software is furnished to do so, subject to the following conditions:</a>
<a name="ln23">//</a>
<a name="ln24">// The above copyright notice and this permission notice shall be included </a>
<a name="ln25">// in all copies or substantial portions of the Software.</a>
<a name="ln26">//</a>
<a name="ln27">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</a>
<a name="ln28">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</a>
<a name="ln29">// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL </a>
<a name="ln30">// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</a>
<a name="ln31">// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING </a>
<a name="ln32">// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</a>
<a name="ln33">// DEALINGS IN THE SOFTWARE.</a>
<a name="ln34">/*****************************************************************************/</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;malloc.h&gt;</a>
<a name="ln37">#include &lt;stdio.h&gt;</a>
<a name="ln38">#include &lt;string.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;ByteOrder.h&gt;</a>
<a name="ln41">#include &lt;DataIO.h&gt;</a>
<a name="ln42">#include &lt;TranslationErrors.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;SGIImage.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">const char kSGICopyright[] = &quot;&quot; B_UTF8_COPYRIGHT &quot; 1997-1998 Michael Sweet &quot;</a>
<a name="ln47">	&quot;&lt;mike@easysw.com&gt;&quot;;</a>
<a name="ln48"> </a>
<a name="ln49">// constructor</a>
<a name="ln50">SGIImage::SGIImage()</a>
<a name="ln51">	: fStream(NULL),</a>
<a name="ln52">	  fMode(0),</a>
<a name="ln53">	  fBytesPerChannel(0),</a>
<a name="ln54">	  fCompression(0),</a>
<a name="ln55">	  fWidth(0),</a>
<a name="ln56">	  fHeight(0),</a>
<a name="ln57">	  fChannelCount(0),</a>
<a name="ln58">	  fFirstRowOffset(0),</a>
<a name="ln59">	  fNextRowOffset(0),</a>
<a name="ln60">	  fOffsetTable(NULL),</a>
<a name="ln61">	  fLengthTable(NULL),</a>
<a name="ln62">	  fARLERow(NULL),</a>
<a name="ln63">	  fARLEOffset(0),</a>
<a name="ln64">	  fARLELength(0)</a>
<a name="ln65">{</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">// destructor</a>
<a name="ln69">SGIImage::~SGIImage()</a>
<a name="ln70">{</a>
<a name="ln71">	Unset();</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">// InitCheck</a>
<a name="ln75">status_t</a>
<a name="ln76">SGIImage::InitCheck() const</a>
<a name="ln77">{</a>
<a name="ln78">	if (fStream)</a>
<a name="ln79">		return B_OK;</a>
<a name="ln80">	return B_NO_INIT;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">// SetTo</a>
<a name="ln84">// open an SGI image file for reading</a>
<a name="ln85">//</a>
<a name="ln86">// stream	the input stream</a>
<a name="ln87">status_t</a>
<a name="ln88">SGIImage::SetTo(BPositionIO* stream)</a>
<a name="ln89">{</a>
<a name="ln90">	if (!stream)</a>
<a name="ln91">		return B_BAD_VALUE;</a>
<a name="ln92"> </a>
<a name="ln93">	fStream = stream;</a>
<a name="ln94">	stream-&gt;Seek(0, SEEK_SET);</a>
<a name="ln95"> </a>
<a name="ln96">	int16 magic = _ReadShort();</a>
<a name="ln97">	if (magic != SGI_MAGIC) {</a>
<a name="ln98">		fStream = NULL;</a>
<a name="ln99">		return B_NO_TRANSLATOR;</a>
<a name="ln100">	}</a>
<a name="ln101"> </a>
<a name="ln102">	fMode = SGI_READ;</a>
<a name="ln103"> </a>
<a name="ln104">	fCompression = _ReadChar();</a>
<a name="ln105">	fBytesPerChannel = _ReadChar();</a>
<a name="ln106">	_ReadShort();	// Dimensions</a>
<a name="ln107">	fWidth = _ReadShort();</a>
<a name="ln108">	fHeight = _ReadShort();</a>
<a name="ln109">	fChannelCount = _ReadShort();</a>
<a name="ln110">//	_ReadLong();	// Minimum pixel</a>
<a name="ln111">//	_ReadLong();	// Maximum pixel</a>
<a name="ln112"> </a>
<a name="ln113">	if (fCompression) {</a>
<a name="ln114">		// this stream is compressed; read the scanline tables...</a>
<a name="ln115"> </a>
<a name="ln116">		fStream-&gt;Seek(512, SEEK_SET);</a>
<a name="ln117"> </a>
<a name="ln118">		fOffsetTable	= (int32**)calloc(fChannelCount, sizeof(int32*));</a>
<a name="ln119">		fOffsetTable[0] = (int32*)calloc(fHeight * fChannelCount, sizeof(int32));</a>
<a name="ln120">		for (uint32 i = 1; i &lt; fChannelCount; i++)</a>
<a name="ln121">			fOffsetTable[i] = fOffsetTable[0] + i * fHeight;</a>
<a name="ln122"> </a>
<a name="ln123">		for (uint32 i = 0; i &lt; fChannelCount; i++)</a>
<a name="ln124">			for (uint16 j = 0; j &lt; fHeight; j++)</a>
<a name="ln125">				fOffsetTable[i][j] = _ReadLong();</a>
<a name="ln126"> </a>
<a name="ln127">		fLengthTable	= (int32**)calloc(fChannelCount, sizeof(int32*));</a>
<a name="ln128">		fLengthTable[0] = (int32*)calloc(fHeight * fChannelCount, sizeof(int32));</a>
<a name="ln129"> </a>
<a name="ln130">		for (int32 i = 1; i &lt; fChannelCount; i ++)</a>
<a name="ln131">			fLengthTable[i] = fLengthTable[0] + i * fHeight;</a>
<a name="ln132"> </a>
<a name="ln133">		for (uint32 i = 0; i &lt; fChannelCount; i++)</a>
<a name="ln134">			for (uint16 j = 0; j &lt; fHeight; j++)</a>
<a name="ln135">				fLengthTable[i][j] = _ReadLong();</a>
<a name="ln136"> </a>
<a name="ln137">	}</a>
<a name="ln138">	return B_OK;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">// SetTo</a>
<a name="ln142">// open an SGI image file for writing</a>
<a name="ln143">//</a>
<a name="ln144">// stream			the output stream</a>
<a name="ln145">// width			number of pixels in a row</a>
<a name="ln146">// height			number of rows</a>
<a name="ln147">// channels			number of channels per pixel</a>
<a name="ln148">// bytesPerChannel	number of bytes per channel</a>
<a name="ln149">// compression		compression mode</a>
<a name="ln150">status_t</a>
<a name="ln151">SGIImage::SetTo(BPositionIO* stream,</a>
<a name="ln152">				uint16 width, uint16 height,</a>
<a name="ln153">				uint16 channels, uint32 bytesPerChannel,</a>
<a name="ln154">				uint32 compression)</a>
<a name="ln155">{</a>
<a name="ln156">	// sanity checks</a>
<a name="ln157">	if (!stream ||</a>
<a name="ln158">		width &lt; 1 || height &lt; 1 || channels &lt; 1 ||</a>
<a name="ln159">		bytesPerChannel &lt; 1 || bytesPerChannel &gt; 2 ||</a>
<a name="ln160">		compression &lt; SGI_COMP_NONE || compression &gt; SGI_COMP_ARLE)</a>
<a name="ln161">		return B_BAD_VALUE;</a>
<a name="ln162"> </a>
<a name="ln163">	fStream = stream;</a>
<a name="ln164">	fMode = SGI_WRITE;</a>
<a name="ln165"> </a>
<a name="ln166">	_WriteShort(SGI_MAGIC);</a>
<a name="ln167">	_WriteChar((fCompression = compression) != 0);</a>
<a name="ln168">	_WriteChar(fBytesPerChannel = bytesPerChannel);</a>
<a name="ln169">	_WriteShort(3);		// Dimensions</a>
<a name="ln170">	_WriteShort(fWidth = width);</a>
<a name="ln171">	_WriteShort(fHeight = height);</a>
<a name="ln172">	_WriteShort(fChannelCount = channels);</a>
<a name="ln173"> </a>
<a name="ln174">	if (fBytesPerChannel == 1) {</a>
<a name="ln175">		_WriteLong(0);		// Minimum pixel</a>
<a name="ln176">		_WriteLong(255);	// Maximum pixel</a>
<a name="ln177">	} else {</a>
<a name="ln178">		_WriteLong(-32768);	// Minimum pixel</a>
<a name="ln179">		_WriteLong(32767);	// Maximum pixel</a>
<a name="ln180">	}</a>
<a name="ln181">	_WriteLong(0);			// Reserved</a>
<a name="ln182"> </a>
<a name="ln183">	char name[80];	// Name of file in image header</a>
<a name="ln184">	memset(name, 0, sizeof(name));</a>
<a name="ln185">	sprintf(name, &quot;Haiku SGITranslator&quot;);</a>
<a name="ln186">	fStream-&gt;Write(name, sizeof(name));</a>
<a name="ln187"> </a>
<a name="ln188">	// fill the rest of the image header with zeros</a>
<a name="ln189">	for (int32 i = 0; i &lt; 102; i++)</a>
<a name="ln190">		_WriteLong(0);</a>
<a name="ln191"> </a>
<a name="ln192">	switch (fCompression) {</a>
<a name="ln193">		case SGI_COMP_NONE : // No compression</a>
<a name="ln194">			// This file is uncompressed.  To avoid problems with</a>
<a name="ln195">			// sparse files, we need to write blank pixels for the</a>
<a name="ln196">			// entire image...</a>
<a name="ln197"> </a>
<a name="ln198">/*			if (fBytesPerChannel == 1) {</a>
<a name="ln199">				for (int32 i = fWidth * fHeight * fChannelCount; i &gt; 0; i --)</a>
<a name="ln200">					_WriteChar(0);</a>
<a name="ln201">			} else {</a>
<a name="ln202">				for (int32 i = fWidth * fHeight * fChannelCount; i &gt; 0; i --)</a>
<a name="ln203">					_WriteShort(0);</a>
<a name="ln204">			}*/</a>
<a name="ln205">			break;</a>
<a name="ln206"> </a>
<a name="ln207">		case SGI_COMP_ARLE: // Aggressive RLE</a>
<a name="ln208">			fARLERow	= (uint16*)calloc(fWidth, sizeof(uint16));</a>
<a name="ln209">			fARLEOffset = 0;</a>
<a name="ln210">			// FALL THROUGH</a>
<a name="ln211">		case SGI_COMP_RLE : // Run-Length Encoding</a>
<a name="ln212">			// This file is compressed; write the (blank) scanline tables...</a>
<a name="ln213"> </a>
<a name="ln214">//			for (int32 i = 2 * fHeight * fChannelCount; i &gt; 0; i--)</a>
<a name="ln215">//				_WriteLong(0);</a>
<a name="ln216">fStream-&gt;Seek(2 * fHeight * fChannelCount * sizeof(int32), SEEK_CUR);</a>
<a name="ln217"> </a>
<a name="ln218">			fFirstRowOffset = fStream-&gt;Position();</a>
<a name="ln219">			fNextRowOffset  = fStream-&gt;Position();</a>
<a name="ln220"> </a>
<a name="ln221">			// allocate and read offset table</a>
<a name="ln222">			fOffsetTable	= (int32**)calloc(fChannelCount, sizeof(int32*));</a>
<a name="ln223">			fOffsetTable[0] = (int32*)calloc(fHeight * fChannelCount, sizeof(int32));</a>
<a name="ln224"> </a>
<a name="ln225">			for (int32 i = 1; i &lt; fChannelCount; i ++)</a>
<a name="ln226">				fOffsetTable[i] = fOffsetTable[0] + i * fHeight;</a>
<a name="ln227"> </a>
<a name="ln228">			// allocate and read length table</a>
<a name="ln229">			fLengthTable	= (int32**)calloc(fChannelCount, sizeof(int32*));</a>
<a name="ln230">			fLengthTable[0] = (int32*)calloc(fHeight * fChannelCount, sizeof(int32));</a>
<a name="ln231"> </a>
<a name="ln232">			for (int32 i = 1; i &lt; fChannelCount; i ++)</a>
<a name="ln233">				fLengthTable[i] = fLengthTable[0] + i * fHeight;</a>
<a name="ln234">			break;</a>
<a name="ln235">	}</a>
<a name="ln236">	return B_OK;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">// Unset</a>
<a name="ln240">//</a>
<a name="ln241">// if in write mode, writes final information to the stream</a>
<a name="ln242">status_t</a>
<a name="ln243">SGIImage::Unset()</a>
<a name="ln244">{</a>
<a name="ln245">	status_t ret = InitCheck(); // return status</a>
<a name="ln246">	if (ret &gt;= B_OK) {</a>
<a name="ln247"> </a>
<a name="ln248">		if (fMode == SGI_WRITE &amp;&amp; fCompression != SGI_COMP_NONE) {</a>
<a name="ln249">			// write the scanline offset table to the file...</a>
<a name="ln250">		</a>
<a name="ln251">			fStream-&gt;Seek(512, SEEK_SET);</a>
<a name="ln252"> </a>
<a name="ln253">/*			off_t* offset = fOffsetTable[0];</a>
<a name="ln254">			for (int32 i = fHeight * fChannelCount; i &gt; 0; i--) {</a>
<a name="ln255">				if ((ret = _WriteLong(offset[0])) &lt; B_OK)</a>
<a name="ln256">					break;</a>
<a name="ln257">				offset++;</a>
<a name="ln258">			}*/</a>
<a name="ln259"> </a>
<a name="ln260">int32 size = fHeight * fChannelCount * sizeof(int32);</a>
<a name="ln261">swap_data(B_INT32_TYPE, fOffsetTable[0], size, B_SWAP_HOST_TO_BENDIAN);</a>
<a name="ln262">ret = fStream-&gt;Write(fOffsetTable[0], size);</a>
<a name="ln263"> </a>
<a name="ln264">			if (ret &gt;= B_OK) {</a>
<a name="ln265"> </a>
<a name="ln266">/*				int32* length = fLengthTable[0];</a>
<a name="ln267">				for (int32 i = fHeight * fChannelCount; i &gt; 0; i--) {</a>
<a name="ln268">					if ((ret = _WriteLong(length[0])) &lt; B_OK)</a>
<a name="ln269">						break;</a>
<a name="ln270">					length++;</a>
<a name="ln271">				}*/</a>
<a name="ln272"> </a>
<a name="ln273">swap_data(B_INT32_TYPE, fLengthTable[0], size, B_SWAP_HOST_TO_BENDIAN);</a>
<a name="ln274">ret = fStream-&gt;Write(fLengthTable[0], size);</a>
<a name="ln275"> </a>
<a name="ln276">			}</a>
<a name="ln277">		}</a>
<a name="ln278">		</a>
<a name="ln279">		if (fOffsetTable != NULL) {</a>
<a name="ln280">			free(fOffsetTable[0]);</a>
<a name="ln281">			free(fOffsetTable);</a>
<a name="ln282">			fOffsetTable = NULL;</a>
<a name="ln283">		}</a>
<a name="ln284">		</a>
<a name="ln285">		if (fLengthTable != NULL) {</a>
<a name="ln286">			free(fLengthTable[0]);</a>
<a name="ln287">			free(fLengthTable);</a>
<a name="ln288">			fLengthTable = NULL;</a>
<a name="ln289">		}</a>
<a name="ln290">		</a>
<a name="ln291">		if (fARLERow) {</a>
<a name="ln292">			free(fARLERow);</a>
<a name="ln293">			fARLERow = NULL;</a>
<a name="ln294">		}</a>
<a name="ln295"> </a>
<a name="ln296">		fStream = NULL;</a>
<a name="ln297">	}</a>
<a name="ln298">	return ret;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">// ReadRow</a>
<a name="ln302">//</a>
<a name="ln303">// reads a row of image data from the stream</a>
<a name="ln304">//</a>
<a name="ln305">// row			pointer to buffer (row of pixels) to read</a>
<a name="ln306">// y			index (line number) of this row</a>
<a name="ln307">// z			which channel to read</a>
<a name="ln308">status_t</a>
<a name="ln309">SGIImage::ReadRow(void* row, int32 y, int32 z)</a>
<a name="ln310">{</a>
<a name="ln311">	// sanitiy checks</a>
<a name="ln312">	if (row == NULL ||</a>
<a name="ln313">		y &lt; 0 || y &gt;= fHeight ||</a>
<a name="ln314">		z &lt; 0 || z &gt;= fChannelCount)</a>
<a name="ln315">		return B_BAD_VALUE;</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">	status_t ret = B_ERROR;</a>
<a name="ln319"> </a>
<a name="ln320">	switch (fCompression) {</a>
<a name="ln321">		case SGI_COMP_NONE: {</a>
<a name="ln322">			// seek to the image row</a>
<a name="ln323">			// optimize buffering by only seeking if necessary...</a>
<a name="ln324"> </a>
<a name="ln325">			off_t offset = 512 + (y + z * fHeight) * fWidth * fBytesPerChannel;</a>
<a name="ln326">			fStream-&gt;Seek(offset, SEEK_SET);</a>
<a name="ln327"> </a>
<a name="ln328">			uint32 bytes = fWidth * fBytesPerChannel;</a>
<a name="ln329">//printf(&quot;reading %ld bytes 8 Bit uncompressed row: %ld, channel: %ld\n&quot;, bytes, y, z);</a>
<a name="ln330">			ret = fStream-&gt;Read(row, bytes);</a>
<a name="ln331"> </a>
<a name="ln332">			break;</a>
<a name="ln333">		}</a>
<a name="ln334">		case SGI_COMP_RLE: {</a>
<a name="ln335">			int32 offset = fOffsetTable[z][y];</a>
<a name="ln336">			int32 rleLength = fLengthTable[z][y];</a>
<a name="ln337">			fStream-&gt;Seek(offset, SEEK_SET);</a>
<a name="ln338">			uint8* rleBuffer = new uint8[rleLength];</a>
<a name="ln339">			fStream-&gt;Read(rleBuffer, rleLength);</a>
<a name="ln340"> </a>
<a name="ln341">			if (fBytesPerChannel == 1) {</a>
<a name="ln342">//printf(&quot;reading 8 Bit RLE compressed row: %ld, channel: %ld\n&quot;, y, z);</a>
<a name="ln343">//				ret = _ReadRLE8((uint8*)row, fWidth);</a>
<a name="ln344">				ret = _ReadRLE8((uint8*)row, rleBuffer, fWidth);</a>
<a name="ln345">			} else {</a>
<a name="ln346">//printf(&quot;reading 16 Bit RLE compressed row: %ld, channel: %ld\n&quot;, y, z);</a>
<a name="ln347">//				ret = _ReadRLE16((uint16*)row, fWidth);</a>
<a name="ln348">				if ((ret = swap_data(B_INT16_TYPE, rleBuffer, rleLength, B_SWAP_BENDIAN_TO_HOST)) &gt;= B_OK)</a>
<a name="ln349">					ret = _ReadRLE16((uint16*)row, (uint16*)rleBuffer, fWidth);</a>
<a name="ln350">			}</a>
<a name="ln351">			delete[] rleBuffer;</a>
<a name="ln352">			break;</a>
<a name="ln353">		}</a>
<a name="ln354">	}</a>
<a name="ln355">	return ret;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">// WriteRow</a>
<a name="ln359">//</a>
<a name="ln360">// writes a row of image data to the stream</a>
<a name="ln361">//</a>
<a name="ln362">// row			pointer to buffer (row of pixels) to write</a>
<a name="ln363">// y			index (line number) of this row</a>
<a name="ln364">// z			which channel to write</a>
<a name="ln365">status_t</a>
<a name="ln366">SGIImage::WriteRow(void* row, int32 y, int32 z)</a>
<a name="ln367">{</a>
<a name="ln368">	// sanitiy checks</a>
<a name="ln369">	if (row == NULL ||</a>
<a name="ln370">		y &lt; 0 || y &gt;= fHeight ||</a>
<a name="ln371">		z &lt; 0 || z &gt;= fChannelCount)</a>
<a name="ln372">		return B_BAD_VALUE;</a>
<a name="ln373"> </a>
<a name="ln374">	int32 x;		// x coordinate</a>
<a name="ln375">	int32 offset;	// stream offset</a>
<a name="ln376"> </a>
<a name="ln377">	status_t ret = B_ERROR;</a>
<a name="ln378"> </a>
<a name="ln379">	switch (fCompression) {</a>
<a name="ln380">		case SGI_COMP_NONE: {</a>
<a name="ln381">			// Seek to the image row</a>
<a name="ln382"> </a>
<a name="ln383">			offset = 512 + (y + z * fHeight) * fWidth * fBytesPerChannel;</a>
<a name="ln384">			fStream-&gt;Seek(offset, SEEK_SET);</a>
<a name="ln385"> </a>
<a name="ln386">			uint32 bytes = fWidth * fBytesPerChannel;</a>
<a name="ln387">//printf(&quot;writing %ld bytes %ld byte/channel uncompressed row: %ld, channel: %ld\n&quot;, bytes, fBytesPerChannel, y, z);</a>
<a name="ln388">			ret = fStream-&gt;Write(row, bytes);</a>
<a name="ln389">/*			if (fBytesPerChannel == 1) {</a>
<a name="ln390">				for (x = fWidth; x &gt; 0; x--) {</a>
<a name="ln391">					_WriteChar(*row);</a>
<a name="ln392">					row++;</a>
<a name="ln393">				}</a>
<a name="ln394">			} else {</a>
<a name="ln395">				for (x = fWidth; x &gt; 0; x--) {</a>
<a name="ln396">					_WriteShort(*row);</a>
<a name="ln397">					row++;</a>
<a name="ln398">				}</a>
<a name="ln399">			}*/</a>
<a name="ln400">			break;</a>
<a name="ln401">		}</a>
<a name="ln402">		case SGI_COMP_ARLE:</a>
<a name="ln403">			if (fOffsetTable[z][y] != 0)</a>
<a name="ln404">				return B_ERROR;</a>
<a name="ln405"> </a>
<a name="ln406">			// First check the last row written...</a>
<a name="ln407"> </a>
<a name="ln408">			if (fARLEOffset &gt; 0) {</a>
<a name="ln409">				if (fBytesPerChannel == 1) {</a>
<a name="ln410">					uint8* arleRow = (uint8*)fARLERow;</a>
<a name="ln411">					uint8* src = (uint8*)row;</a>
<a name="ln412">					for (x = 0; x &lt; fWidth; x++)</a>
<a name="ln413">						if (*src++ != *arleRow++)</a>
<a name="ln414">							break;</a>
<a name="ln415">				} else {</a>
<a name="ln416">					uint16* arleRow = (uint16*)fARLERow;</a>
<a name="ln417">					uint16* src = (uint16*)row;</a>
<a name="ln418">					for (x = 0; x &lt; fWidth; x++)</a>
<a name="ln419">						if (*src++ != *arleRow++)</a>
<a name="ln420">							break;</a>
<a name="ln421">				}</a>
<a name="ln422"> </a>
<a name="ln423">				if (x == fWidth) {</a>
<a name="ln424">					fOffsetTable[z][y] = fARLEOffset;</a>
<a name="ln425">					fLengthTable[z][y] = fARLELength;</a>
<a name="ln426">					return B_OK;</a>
<a name="ln427">				}</a>
<a name="ln428">			}</a>
<a name="ln429"> </a>
<a name="ln430">			// If that didn't match, search all the previous rows...</a>
<a name="ln431"> </a>
<a name="ln432">			fStream-&gt;Seek(fFirstRowOffset, SEEK_SET);</a>
<a name="ln433"> </a>
<a name="ln434">			if (fBytesPerChannel == 1) {</a>
<a name="ln435">				do {</a>
<a name="ln436">					fARLEOffset = fStream-&gt;Position();</a>
<a name="ln437"> </a>
<a name="ln438">					uint8* arleRow = (uint8*)fARLERow;</a>
<a name="ln439">					if ((fARLELength = _ReadRLE8(arleRow, fWidth)) &lt; B_OK) {</a>
<a name="ln440">						x = 0;</a>
<a name="ln441">						break;</a>
<a name="ln442">					}</a>
<a name="ln443"> </a>
<a name="ln444">					uint8* src = (uint8*)row;</a>
<a name="ln445">					for (x = 0; x &lt; fWidth; x++)</a>
<a name="ln446">						if (*src++ != *arleRow++)</a>
<a name="ln447">							break;</a>
<a name="ln448">				} while (x &lt; fWidth);</a>
<a name="ln449">			} else {</a>
<a name="ln450">				do {</a>
<a name="ln451">					fARLEOffset = fStream-&gt;Position();</a>
<a name="ln452"> </a>
<a name="ln453">					uint16* arleRow = (uint16*)fARLERow;</a>
<a name="ln454">					if ((fARLELength = _ReadRLE16(arleRow, fWidth)) &lt; B_OK) {</a>
<a name="ln455">						x = 0;</a>
<a name="ln456">						break;</a>
<a name="ln457">					}</a>
<a name="ln458"> </a>
<a name="ln459">					uint16* src = (uint16*)row;</a>
<a name="ln460">					for (x = 0; x &lt; fWidth; x++)</a>
<a name="ln461">						if (*src++ != *arleRow++)</a>
<a name="ln462">							break;</a>
<a name="ln463">				} while (x &lt; fWidth);</a>
<a name="ln464">			}</a>
<a name="ln465"> </a>
<a name="ln466">			if (x == fWidth) {</a>
<a name="ln467">				fOffsetTable[z][y] = fARLEOffset;</a>
<a name="ln468">				fLengthTable[z][y] = fARLELength;</a>
<a name="ln469">				return B_OK;</a>
<a name="ln470">			} else</a>
<a name="ln471">				fStream-&gt;Seek(0, SEEK_END);	// seek to end of stream</a>
<a name="ln472">			// FALL THROUGH!</a>
<a name="ln473">		case SGI_COMP_RLE :</a>
<a name="ln474">			if (fOffsetTable[z][y] != 0)</a>
<a name="ln475">				return B_ERROR;</a>
<a name="ln476"> </a>
<a name="ln477">			offset = fOffsetTable[z][y] = fNextRowOffset;</a>
<a name="ln478"> </a>
<a name="ln479">			if (offset != fStream-&gt;Position())</a>
<a name="ln480">				fStream-&gt;Seek(offset, SEEK_SET);</a>
<a name="ln481"> </a>
<a name="ln482">//printf(&quot;writing %d pixels %ld byte/channel RLE row: %ld, channel: %ld\n&quot;, fWidth, fBytesPerChannel, y, z);</a>
<a name="ln483"> </a>
<a name="ln484">			if (fBytesPerChannel == 1)</a>
<a name="ln485">				x = _WriteRLE8((uint8*)row, fWidth);</a>
<a name="ln486">			else</a>
<a name="ln487">				x = _WriteRLE16((uint16*)row, fWidth);</a>
<a name="ln488"> </a>
<a name="ln489">			if (fCompression == SGI_COMP_ARLE) {</a>
<a name="ln490">				fARLEOffset = offset;</a>
<a name="ln491">				fARLELength = x;</a>
<a name="ln492">				memcpy(fARLERow, row, fWidth * fBytesPerChannel);</a>
<a name="ln493">			}</a>
<a name="ln494"> </a>
<a name="ln495">			fNextRowOffset = fStream-&gt;Position();</a>
<a name="ln496">			fLengthTable[z][y] = x;</a>
<a name="ln497"> </a>
<a name="ln498">			return x;</a>
<a name="ln499">		default:</a>
<a name="ln500">			break;</a>
<a name="ln501">	}</a>
<a name="ln502"> </a>
<a name="ln503">	return ret;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">// _ReadLong</a>
<a name="ln507">//</a>
<a name="ln508">// reads 4 bytes from the stream and</a>
<a name="ln509">// returns a 32-bit big-endian integer</a>
<a name="ln510">int32</a>
<a name="ln511">SGIImage::_ReadLong() const</a>
<a name="ln512">{</a>
<a name="ln513">	int32 n;</a>
<a name="ln514">	if (fStream-&gt;Read(&amp;n, 4) == 4) {</a>
<a name="ln515">		return B_BENDIAN_TO_HOST_INT32(n);</a>
<a name="ln516">	} else</a>
<a name="ln517">		return 0;</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">// _ReadShort</a>
<a name="ln521">//</a>
<a name="ln522">// reads 2 bytes from the stream and</a>
<a name="ln523">// returns a 16-bit big-endian integer</a>
<a name="ln524">int16</a>
<a name="ln525">SGIImage::_ReadShort() const</a>
<a name="ln526">{</a>
<a name="ln527">	int16 n;</a>
<a name="ln528">	if (fStream-&gt;Read(&amp;n, 2) == 2) {</a>
<a name="ln529">		return B_BENDIAN_TO_HOST_INT16(n);</a>
<a name="ln530">	} else</a>
<a name="ln531">		return 0;</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">// _ReadChar</a>
<a name="ln535">//</a>
<a name="ln536">// reads 1 byte from the stream and</a>
<a name="ln537">// returns it</a>
<a name="ln538">int8</a>
<a name="ln539">SGIImage::_ReadChar() const</a>
<a name="ln540">{</a>
<a name="ln541">	int8 b;</a>
<a name="ln542">	ssize_t read = fStream-&gt;Read(&amp;b, 1);</a>
<a name="ln543">	if (read == 1)</a>
<a name="ln544">		return b;</a>
<a name="ln545">	else if (read &lt; B_OK)</a>
<a name="ln546">		return (int8)read;</a>
<a name="ln547">	return (int8)B_ERROR;</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">// _WriteLong</a>
<a name="ln551">//</a>
<a name="ln552">// writes a 32-bit big-endian integer to the stream</a>
<a name="ln553">status_t</a>
<a name="ln554">SGIImage::_WriteLong(int32 n) const</a>
<a name="ln555">{</a>
<a name="ln556">	int32 bigN = B_HOST_TO_BENDIAN_INT32(n);</a>
<a name="ln557">	ssize_t written = fStream-&gt;Write(&amp;bigN, sizeof(int32));</a>
<a name="ln558">	if (written == sizeof(int32))</a>
<a name="ln559">		return B_OK;</a>
<a name="ln560">	if (written &lt; B_OK)</a>
<a name="ln561">		return written;</a>
<a name="ln562">	return B_ERROR;</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">// _WriteShort</a>
<a name="ln566">//</a>
<a name="ln567">// writes a 16-bit big-endian integer to the stream</a>
<a name="ln568">status_t</a>
<a name="ln569">SGIImage::_WriteShort(uint16 n) const</a>
<a name="ln570">{</a>
<a name="ln571">	uint16 bigN = B_HOST_TO_BENDIAN_INT16(n);</a>
<a name="ln572">	ssize_t written = fStream-&gt;Write(&amp;bigN, sizeof(uint16));</a>
<a name="ln573">	if (written == sizeof(uint16))</a>
<a name="ln574">		return B_OK;</a>
<a name="ln575">	if (written &lt; B_OK)</a>
<a name="ln576">		return written;</a>
<a name="ln577">	return B_ERROR;</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">// _WriteChar</a>
<a name="ln581">//</a>
<a name="ln582">// writes one byte to the stream</a>
<a name="ln583">status_t</a>
<a name="ln584">SGIImage::_WriteChar(int8 n) const</a>
<a name="ln585">{</a>
<a name="ln586">	ssize_t written = fStream-&gt;Write(&amp;n, sizeof(int8));</a>
<a name="ln587">	if (written == sizeof(int8))</a>
<a name="ln588">		return B_OK;</a>
<a name="ln589">	if (written &lt; B_OK)</a>
<a name="ln590">		return written;</a>
<a name="ln591">	return B_ERROR;</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">// _ReadRLE8</a>
<a name="ln595">//</a>
<a name="ln596">// reads 8-bit RLE data into provided buffer</a>
<a name="ln597">//</a>
<a name="ln598">// row			pointer to buffer for one row</a>
<a name="ln599">// numPixels	number of pixels that fit into row buffer</a>
<a name="ln600">ssize_t</a>
<a name="ln601">SGIImage::_ReadRLE8(uint8* row, int32 numPixels) const</a>
<a name="ln602">{</a>
<a name="ln603">	int32 ch;			// current charater</a>
<a name="ln604">	uint32 count;		// RLE count</a>
<a name="ln605">	uint32 length = 0;	// number of bytes read</a>
<a name="ln606"> </a>
<a name="ln607">	uint32 bufferSize = 1024;</a>
<a name="ln608">	uint8* buffer = new uint8[bufferSize];</a>
<a name="ln609">	uint32 bufferPos = bufferSize;</a>
<a name="ln610"> </a>
<a name="ln611">	status_t ret = B_OK;</a>
<a name="ln612"> </a>
<a name="ln613">	while (numPixels &gt; 0) {</a>
<a name="ln614"> </a>
<a name="ln615">		// fetch another buffer if we need to</a>
<a name="ln616">		if (bufferPos &gt;= bufferSize) {</a>
<a name="ln617">			ret = fStream-&gt;Read(buffer, bufferSize);</a>
<a name="ln618">			if (ret &lt; B_OK)</a>
<a name="ln619">				break;</a>
<a name="ln620">			else</a>
<a name="ln621">				bufferPos = 0;</a>
<a name="ln622">		}</a>
<a name="ln623"> </a>
<a name="ln624">		ch = buffer[bufferPos ++];</a>
<a name="ln625">		length ++;</a>
<a name="ln626"> </a>
<a name="ln627">		count = ch &amp; 127;</a>
<a name="ln628">		if (count == 0)</a>
<a name="ln629">			break;</a>
<a name="ln630"> </a>
<a name="ln631">		if (ch &amp; 128) {</a>
<a name="ln632">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln633"> </a>
<a name="ln634">				// fetch another buffer if we need to</a>
<a name="ln635">				if (bufferPos &gt;= bufferSize) {</a>
<a name="ln636">					ret = fStream-&gt;Read(buffer, bufferSize);</a>
<a name="ln637">					if (ret &lt; B_OK) {</a>
<a name="ln638">						delete[] buffer;</a>
<a name="ln639">						return ret;</a>
<a name="ln640">					} else</a>
<a name="ln641">						bufferPos = 0;</a>
<a name="ln642">				}</a>
<a name="ln643"> </a>
<a name="ln644">				*row = buffer[bufferPos ++];</a>
<a name="ln645">				row ++;</a>
<a name="ln646">				numPixels --;</a>
<a name="ln647">				length ++;</a>
<a name="ln648">			}</a>
<a name="ln649">		} else {</a>
<a name="ln650"> </a>
<a name="ln651">			// fetch another buffer if we need to</a>
<a name="ln652">			if (bufferPos &gt;= bufferSize) {</a>
<a name="ln653">				ret = fStream-&gt;Read(buffer, bufferSize);</a>
<a name="ln654">				if (ret &lt; B_OK) {</a>
<a name="ln655">					delete[] buffer;</a>
<a name="ln656">					return ret;</a>
<a name="ln657">				} else</a>
<a name="ln658">					bufferPos = 0;</a>
<a name="ln659">			}</a>
<a name="ln660"> </a>
<a name="ln661">			ch = buffer[bufferPos ++];</a>
<a name="ln662">			length ++;</a>
<a name="ln663">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln664">				*row = ch;</a>
<a name="ln665">				row ++;</a>
<a name="ln666">				numPixels --;</a>
<a name="ln667">			}</a>
<a name="ln668">		}</a>
<a name="ln669">	}</a>
<a name="ln670">	delete[] buffer;</a>
<a name="ln671"> </a>
<a name="ln672">	return (numPixels &gt; 0 ? ret : length);</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">// _ReadRLE8</a>
<a name="ln676">//</a>
<a name="ln677">// reads 8-bit RLE data into provided buffer</a>
<a name="ln678">//</a>
<a name="ln679">// row			pointer to buffer for one row</a>
<a name="ln680">// numPixels	number of pixels that fit into row buffer</a>
<a name="ln681">ssize_t</a>
<a name="ln682">SGIImage::_ReadRLE8(uint8* row, uint8* rleBuffer, int32 numPixels) const</a>
<a name="ln683">{</a>
<a name="ln684">	int32 ch;			// current charater</a>
<a name="ln685">	uint32 count;		// RLE count</a>
<a name="ln686">	uint32 length = 0;	// number of bytes read</a>
<a name="ln687"> </a>
<a name="ln688">	if (numPixels &lt;= 0)</a>
<a name="ln689">		return B_ERROR;</a>
<a name="ln690"> </a>
<a name="ln691">	while (numPixels &gt; 0) {</a>
<a name="ln692"> </a>
<a name="ln693">		ch = *rleBuffer ++;</a>
<a name="ln694">		length ++;</a>
<a name="ln695"> </a>
<a name="ln696">		count = ch &amp; 127;</a>
<a name="ln697">		if (count == 0)</a>
<a name="ln698">			break;</a>
<a name="ln699"> </a>
<a name="ln700">		if (ch &amp; 128) {</a>
<a name="ln701">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln702"> </a>
<a name="ln703">				*row = *rleBuffer ++;</a>
<a name="ln704">				row ++;</a>
<a name="ln705">				numPixels --;</a>
<a name="ln706">				length ++;</a>
<a name="ln707">			}</a>
<a name="ln708">		} else {</a>
<a name="ln709"> </a>
<a name="ln710">			ch = *rleBuffer ++;</a>
<a name="ln711">			length ++;</a>
<a name="ln712">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln713">				*row = ch;</a>
<a name="ln714">				row ++;</a>
<a name="ln715">				numPixels --;</a>
<a name="ln716">			}</a>
<a name="ln717">		}</a>
<a name="ln718">	}</a>
<a name="ln719"> </a>
<a name="ln720">	return length;</a>
<a name="ln721">}</a>
<a name="ln722">/*ssize_t</a>
<a name="ln723">SGIImage::_ReadRLE8(uint8* row, int32 numPixels) const</a>
<a name="ln724">{</a>
<a name="ln725">	int32 ch;			// current charater</a>
<a name="ln726">	uint32 count;		// RLE count</a>
<a name="ln727">	uint32 length = 0;	// number of bytes read</a>
<a name="ln728"> </a>
<a name="ln729">	while (numPixels &gt; 0) {</a>
<a name="ln730">		ch = _ReadChar();</a>
<a name="ln731">		length ++;</a>
<a name="ln732"> </a>
<a name="ln733">		count = ch &amp; 127;</a>
<a name="ln734">		if (count == 0)</a>
<a name="ln735">			break;</a>
<a name="ln736"> </a>
<a name="ln737">		if (ch &amp; 128) {</a>
<a name="ln738">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln739">				*row = _ReadChar();</a>
<a name="ln740">				row ++;</a>
<a name="ln741">				numPixels --;</a>
<a name="ln742">				length ++;</a>
<a name="ln743">			}</a>
<a name="ln744">		} else {</a>
<a name="ln745">			ch = _ReadChar();</a>
<a name="ln746">			length ++;</a>
<a name="ln747">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln748">				*row = ch;</a>
<a name="ln749">				row ++;</a>
<a name="ln750">				numPixels --;</a>
<a name="ln751">			}</a>
<a name="ln752">		}</a>
<a name="ln753">	}</a>
<a name="ln754">	return (numPixels &gt; 0 ? B_ERROR : length);</a>
<a name="ln755">}*/</a>
<a name="ln756"> </a>
<a name="ln757">// read_and_swap</a>
<a name="ln758">status_t</a>
<a name="ln759">read_and_swap(BPositionIO* stream, int16* buffer, uint32 size)</a>
<a name="ln760">{</a>
<a name="ln761">	status_t ret = stream-&gt;Read(buffer, size);</a>
<a name="ln762">	if (ret &gt;= B_OK)</a>
<a name="ln763">		return swap_data(B_INT16_TYPE, buffer, ret, B_SWAP_BENDIAN_TO_HOST);</a>
<a name="ln764">	return ret;</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767">// _ReadRLE16</a>
<a name="ln768">//</a>
<a name="ln769">// reads 16-bit RLE data into provided buffer</a>
<a name="ln770">//</a>
<a name="ln771">// row			pointer to buffer for one row</a>
<a name="ln772">// numPixels	number of pixels that fit into row buffer</a>
<a name="ln773">ssize_t</a>
<a name="ln774">SGIImage::_ReadRLE16(uint16* row, int32 numPixels) const</a>
<a name="ln775">{</a>
<a name="ln776">	int32 ch;			// current character</a>
<a name="ln777">	uint32 count;		// RLE count</a>
<a name="ln778">	uint32 length = 0;	// number of bytes read...</a>
<a name="ln779"> </a>
<a name="ln780">	uint32 bufferSize = 1024;</a>
<a name="ln781">	int16* buffer = new int16[bufferSize];</a>
<a name="ln782">	uint32 bufferPos = bufferSize;</a>
<a name="ln783">	status_t ret = B_OK;</a>
<a name="ln784"> </a>
<a name="ln785">	while (numPixels &gt; 0) {</a>
<a name="ln786"> </a>
<a name="ln787">		// fetch another buffer if we need to</a>
<a name="ln788">		if (bufferPos &gt;= bufferSize) {</a>
<a name="ln789">			ret = read_and_swap(fStream, buffer, bufferSize * 2);</a>
<a name="ln790">			if (ret &lt; B_OK)</a>
<a name="ln791">				break;</a>
<a name="ln792">			bufferPos = 0;</a>
<a name="ln793">		}</a>
<a name="ln794"> </a>
<a name="ln795">		ch = buffer[bufferPos ++];</a>
<a name="ln796">		length ++;</a>
<a name="ln797"> </a>
<a name="ln798">		count = ch &amp; 127;</a>
<a name="ln799">		if (count == 0)</a>
<a name="ln800">			break;</a>
<a name="ln801"> </a>
<a name="ln802">		if (ch &amp; 128) {</a>
<a name="ln803">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln804"> </a>
<a name="ln805">				// fetch another buffer if we need to</a>
<a name="ln806">				if (bufferPos &gt;= bufferSize) {</a>
<a name="ln807">					ret = read_and_swap(fStream, buffer, bufferSize * 2);</a>
<a name="ln808">					if (ret &lt; B_OK) {</a>
<a name="ln809">						delete[] buffer;</a>
<a name="ln810">						return ret;</a>
<a name="ln811">					} else</a>
<a name="ln812">						bufferPos = 0;</a>
<a name="ln813">				}</a>
<a name="ln814"> </a>
<a name="ln815">				*row = B_HOST_TO_BENDIAN_INT16(buffer[bufferPos ++]);</a>
<a name="ln816">				row++;</a>
<a name="ln817">				numPixels--;</a>
<a name="ln818">				length++;</a>
<a name="ln819">			}</a>
<a name="ln820">		} else {</a>
<a name="ln821"> </a>
<a name="ln822">			// fetch another buffer if we need to</a>
<a name="ln823">			if (bufferPos &gt;= bufferSize) {</a>
<a name="ln824">				ret = read_and_swap(fStream, buffer, bufferSize * 2);</a>
<a name="ln825">				if (ret &lt; B_OK) {</a>
<a name="ln826">					delete[] buffer;</a>
<a name="ln827">					return ret;</a>
<a name="ln828">				} else</a>
<a name="ln829">					bufferPos = 0;</a>
<a name="ln830">			}</a>
<a name="ln831"> </a>
<a name="ln832">			ch = B_HOST_TO_BENDIAN_INT16(buffer[bufferPos ++]);</a>
<a name="ln833">			length ++;</a>
<a name="ln834">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln835">				*row = ch;</a>
<a name="ln836">				row++;</a>
<a name="ln837">				numPixels--;</a>
<a name="ln838">			}</a>
<a name="ln839">		}</a>
<a name="ln840">	}</a>
<a name="ln841">	delete[] buffer;</a>
<a name="ln842">	return (numPixels &gt; 0 ? ret : length * 2);</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">// _ReadRLE16</a>
<a name="ln846">//</a>
<a name="ln847">// reads 16-bit RLE data into provided buffer</a>
<a name="ln848">//</a>
<a name="ln849">// row			pointer to buffer for one row</a>
<a name="ln850">// numPixels	number of pixels that fit into row buffer</a>
<a name="ln851">ssize_t</a>
<a name="ln852">SGIImage::_ReadRLE16(uint16* row, uint16* rleBuffer, int32 numPixels) const</a>
<a name="ln853">{</a>
<a name="ln854">	int32 ch;			// current character</a>
<a name="ln855">	uint32 count;		// RLE count</a>
<a name="ln856">	uint32 length = 0;	// number of bytes read...</a>
<a name="ln857"> </a>
<a name="ln858">	if (numPixels &lt;= 0)</a>
<a name="ln859">		return B_ERROR;</a>
<a name="ln860"> </a>
<a name="ln861">	while (numPixels &gt; 0) {</a>
<a name="ln862"> </a>
<a name="ln863">		ch = *rleBuffer ++;</a>
<a name="ln864">		length ++;</a>
<a name="ln865"> </a>
<a name="ln866">		count = ch &amp; 127;</a>
<a name="ln867">		if (count == 0)</a>
<a name="ln868">			break;</a>
<a name="ln869"> </a>
<a name="ln870">		if (ch &amp; 128) {</a>
<a name="ln871">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln872"> </a>
<a name="ln873">				*row = B_HOST_TO_BENDIAN_INT16(*rleBuffer ++);</a>
<a name="ln874">				row++;</a>
<a name="ln875">				numPixels--;</a>
<a name="ln876">				length++;</a>
<a name="ln877">			}</a>
<a name="ln878">		} else {</a>
<a name="ln879"> </a>
<a name="ln880">			ch = B_HOST_TO_BENDIAN_INT16(*rleBuffer ++);</a>
<a name="ln881">			length ++;</a>
<a name="ln882">			for (uint32 i = 0; i &lt; count; i++) {</a>
<a name="ln883">				*row = ch;</a>
<a name="ln884">				row++;</a>
<a name="ln885">				numPixels--;</a>
<a name="ln886">			}</a>
<a name="ln887">		}</a>
<a name="ln888">	}</a>
<a name="ln889">	return length * 2;</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">// _WriteRLE8</a>
<a name="ln893">//</a>
<a name="ln894">// writes 8-bit RLE data into the stream</a>
<a name="ln895">//</a>
<a name="ln896">// row			pointer to buffer for one row</a>
<a name="ln897">// numPixels	number of pixels that fit into row buffer</a>
<a name="ln898">ssize_t</a>
<a name="ln899">SGIImage::_WriteRLE8(uint8* row, int32 numPixels) const</a>
<a name="ln900">{</a>
<a name="ln901">	int32 length = 0;	// length of output line</a>
<a name="ln902">	int32 count;		// number of repeated/non-repeated pixels</a>
<a name="ln903">	int32 i;			// looping var</a>
<a name="ln904">	uint8* start;		// start of sequence</a>
<a name="ln905">	uint16 repeat;		// repeated pixel</a>
<a name="ln906"> </a>
<a name="ln907"> </a>
<a name="ln908">	for (int32 x = numPixels; x &gt; 0;) {</a>
<a name="ln909">		start = row;</a>
<a name="ln910">		row   += 2;</a>
<a name="ln911">		x	 -= 2;</a>
<a name="ln912"> </a>
<a name="ln913">		while (x &gt; 0 &amp;&amp; (row[-2] != row[-1] || row[-1] != row[0])) {</a>
<a name="ln914">			row++;</a>
<a name="ln915">			x--;</a>
<a name="ln916">		}</a>
<a name="ln917"> </a>
<a name="ln918">		row -= 2;</a>
<a name="ln919">		x   += 2;</a>
<a name="ln920"> </a>
<a name="ln921">		count = row - start;</a>
<a name="ln922">		while (count &gt; 0) {</a>
<a name="ln923">			i	 = count &gt; 126 ? 126 : count;</a>
<a name="ln924">			count -= i;</a>
<a name="ln925"> </a>
<a name="ln926">			if (_WriteChar(128 | i) == EOF)</a>
<a name="ln927">				return EOF;</a>
<a name="ln928">			length ++;</a>
<a name="ln929"> </a>
<a name="ln930">			while (i &gt; 0) {</a>
<a name="ln931">				if (_WriteChar(*start) == EOF)</a>
<a name="ln932">					return EOF;</a>
<a name="ln933">				start ++;</a>
<a name="ln934">				i --;</a>
<a name="ln935">				length ++;</a>
<a name="ln936">			}</a>
<a name="ln937">		}</a>
<a name="ln938"> </a>
<a name="ln939">		if (x &lt;= 0)</a>
<a name="ln940">			break;</a>
<a name="ln941"> </a>
<a name="ln942">		start  = row;</a>
<a name="ln943">		repeat = row[0];</a>
<a name="ln944"> </a>
<a name="ln945">		row ++;</a>
<a name="ln946">		x --;</a>
<a name="ln947"> </a>
<a name="ln948">		while (x &gt; 0 &amp;&amp; *row == repeat) {</a>
<a name="ln949">			row ++;</a>
<a name="ln950">			x --;</a>
<a name="ln951">		}</a>
<a name="ln952"> </a>
<a name="ln953">		count = row - start;</a>
<a name="ln954">		while (count &gt; 0) {</a>
<a name="ln955">			i	 = count &gt; 126 ? 126 : count;</a>
<a name="ln956">			count -= i;</a>
<a name="ln957"> </a>
<a name="ln958">			if (_WriteChar(i) == EOF)</a>
<a name="ln959">				return EOF;</a>
<a name="ln960">			length ++;</a>
<a name="ln961">	</a>
<a name="ln962">			if (_WriteChar(repeat) == EOF)</a>
<a name="ln963">				return (-1);</a>
<a name="ln964">			length ++;</a>
<a name="ln965">		}</a>
<a name="ln966">	}</a>
<a name="ln967"> </a>
<a name="ln968">	length ++;</a>
<a name="ln969"> </a>
<a name="ln970">	if (_WriteChar(0) == EOF)</a>
<a name="ln971">		return EOF;</a>
<a name="ln972">	else</a>
<a name="ln973">		return length;</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976"> </a>
<a name="ln977">// _WriteRLE16</a>
<a name="ln978">//</a>
<a name="ln979">// writes 16-bit RLE data into the stream</a>
<a name="ln980">//</a>
<a name="ln981">// row			pointer to buffer for one row</a>
<a name="ln982">// numPixels	number of pixels that fit into row buffer</a>
<a name="ln983">ssize_t</a>
<a name="ln984">SGIImage::_WriteRLE16(uint16* row, int32 numPixels) const</a>
<a name="ln985">{</a>
<a name="ln986">	int32 length = 0;	// length of output line</a>
<a name="ln987">	int32 count;		// number of repeated/non-repeated pixels</a>
<a name="ln988">	int32 i;			// looping var</a>
<a name="ln989">	int32 x;			// looping var</a>
<a name="ln990">	uint16* start;		// start of sequence</a>
<a name="ln991">	uint16 repeat;		// repeated pixel</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">	for (x = numPixels; x &gt; 0;) {</a>
<a name="ln995">		start = row;</a>
<a name="ln996">		row   += 2;</a>
<a name="ln997">		x	 -= 2;</a>
<a name="ln998"> </a>
<a name="ln999">		while (x &gt; 0 &amp;&amp; (row[-2] != row[-1] || row[-1] != row[0])) {</a>
<a name="ln1000">			row ++;</a>
<a name="ln1001">			x --;</a>
<a name="ln1002">		}</a>
<a name="ln1003"> </a>
<a name="ln1004">		row -= 2;</a>
<a name="ln1005">		x   += 2;</a>
<a name="ln1006"> </a>
<a name="ln1007">		count = row - start;</a>
<a name="ln1008">		while (count &gt; 0) {</a>
<a name="ln1009">			i	 = count &gt; 126 ? 126 : count;</a>
<a name="ln1010">			count -= i;</a>
<a name="ln1011"> </a>
<a name="ln1012">			if (_WriteShort(128 | i) == EOF)</a>
<a name="ln1013">				return EOF;</a>
<a name="ln1014">			length ++;</a>
<a name="ln1015">	</a>
<a name="ln1016">			while (i &gt; 0) {</a>
<a name="ln1017">				if (_WriteShort(*start) == EOF)</a>
<a name="ln1018">					return EOF;</a>
<a name="ln1019">				start ++;</a>
<a name="ln1020">				i --;</a>
<a name="ln1021">				length ++;</a>
<a name="ln1022">			}</a>
<a name="ln1023">		}</a>
<a name="ln1024"> </a>
<a name="ln1025">		if (x &lt;= 0)</a>
<a name="ln1026">			break;</a>
<a name="ln1027"> </a>
<a name="ln1028">		start  = row;</a>
<a name="ln1029">		repeat = row[0];</a>
<a name="ln1030"> </a>
<a name="ln1031">		row ++;</a>
<a name="ln1032">		x --;</a>
<a name="ln1033"> </a>
<a name="ln1034">		while (x &gt; 0 &amp;&amp; *row == repeat) {</a>
<a name="ln1035">			row ++;</a>
<a name="ln1036">			x --;</a>
<a name="ln1037">		}</a>
<a name="ln1038"> </a>
<a name="ln1039">		count = row - start;</a>
<a name="ln1040">		while (count &gt; 0) {</a>
<a name="ln1041">			i	 = count &gt; 126 ? 126 : count;</a>
<a name="ln1042">			count -= i;</a>
<a name="ln1043"> </a>
<a name="ln1044">			if (_WriteShort(i) == EOF)</a>
<a name="ln1045">				return EOF;</a>
<a name="ln1046">			length ++;</a>
<a name="ln1047"> </a>
<a name="ln1048">			if (_WriteShort(repeat) == EOF)</a>
<a name="ln1049">				return EOF;</a>
<a name="ln1050">			length ++;</a>
<a name="ln1051">		}</a>
<a name="ln1052">	}</a>
<a name="ln1053"> </a>
<a name="ln1054">	length ++;</a>
<a name="ln1055"> </a>
<a name="ln1056">	if (_WriteShort(0) == EOF)</a>
<a name="ln1057">		return EOF;</a>
<a name="ln1058">	else</a>
<a name="ln1059">		return (2 * length);</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062"> </a>

</code></pre>
<div class="balloon" rel="262"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'fOffsetTable' pointer was utilized before it was verified against nullptr. Check lines: 262, 279.</p></div>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'fLengthTable' pointer was utilized before it was verified against nullptr. Check lines: 274, 285.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
