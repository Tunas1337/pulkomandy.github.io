
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>extract.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  Copyright (c) 1990-2002 Info-ZIP.  All rights reserved.</a>
<a name="ln3"> </a>
<a name="ln4">  See the accompanying file LICENSE, version 2000-Apr-09 or later</a>
<a name="ln5">  (the contents of which are also included in unzip.h) for terms of use.</a>
<a name="ln6">  If, for some reason, all these files are missing, the Info-ZIP license</a>
<a name="ln7">  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html</a>
<a name="ln8">*/</a>
<a name="ln9">/*---------------------------------------------------------------------------</a>
<a name="ln10"> </a>
<a name="ln11">  extract.c</a>
<a name="ln12"> </a>
<a name="ln13">  This file contains the high-level routines (&quot;driver routines&quot;) for extrac-</a>
<a name="ln14">  ting and testing zipfile members.  It calls the low-level routines in files</a>
<a name="ln15">  explode.c, inflate.c, unreduce.c and unshrink.c.</a>
<a name="ln16"> </a>
<a name="ln17">  Contains:  extract_or_test_files()</a>
<a name="ln18">             store_info()</a>
<a name="ln19">             extract_or_test_entrylist()</a>
<a name="ln20">             extract_or_test_member()</a>
<a name="ln21">             TestExtraField()</a>
<a name="ln22">             test_compr_eb()</a>
<a name="ln23">             memextract()</a>
<a name="ln24">             memflush()</a>
<a name="ln25">             extract_izvms_block()    (VMS or VMS_TEXT_CONV)</a>
<a name="ln26">             fnfilter()</a>
<a name="ln27"> </a>
<a name="ln28">  ---------------------------------------------------------------------------*/</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">#define __EXTRACT_C     /* identifies this source module */</a>
<a name="ln32">#define UNZIP_INTERNAL</a>
<a name="ln33">#include &quot;unzip.h&quot;</a>
<a name="ln34">#ifdef WINDLL</a>
<a name="ln35">#  ifdef POCKET_UNZIP</a>
<a name="ln36">#    include &quot;wince/intrface.h&quot;</a>
<a name="ln37">#  else</a>
<a name="ln38">#    include &quot;windll/windll.h&quot;</a>
<a name="ln39">#  endif</a>
<a name="ln40">#endif</a>
<a name="ln41">#include &quot;crypt.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#define GRRDUMP(buf,len) { \</a>
<a name="ln44">    int i, j; \</a>
<a name="ln45"> \</a>
<a name="ln46">    for (j = 0;  j &lt; (len)/16;  ++j) { \</a>
<a name="ln47">        printf(&quot;        &quot;); \</a>
<a name="ln48">        for (i = 0;  i &lt; 16;  ++i) \</a>
<a name="ln49">            printf(&quot;%02x &quot;, (uch)(buf)[i+(j&lt;&lt;4)]); \</a>
<a name="ln50">        printf(&quot;\n        &quot;); \</a>
<a name="ln51">        for (i = 0;  i &lt; 16;  ++i) { \</a>
<a name="ln52">            char c = (char)(buf)[i+(j&lt;&lt;4)]; \</a>
<a name="ln53"> \</a>
<a name="ln54">            if (c == '\n') \</a>
<a name="ln55">                printf(&quot;\\n &quot;); \</a>
<a name="ln56">            else if (c == '\r') \</a>
<a name="ln57">                printf(&quot;\\r &quot;); \</a>
<a name="ln58">            else \</a>
<a name="ln59">                printf(&quot; %c &quot;, c); \</a>
<a name="ln60">        } \</a>
<a name="ln61">        printf(&quot;\n&quot;); \</a>
<a name="ln62">    } \</a>
<a name="ln63">    if ((len) % 16) { \</a>
<a name="ln64">        printf(&quot;        &quot;); \</a>
<a name="ln65">        for (i = j&lt;&lt;4;  i &lt; (len);  ++i) \</a>
<a name="ln66">            printf(&quot;%02x &quot;, (uch)(buf)[i]); \</a>
<a name="ln67">        printf(&quot;\n        &quot;); \</a>
<a name="ln68">        for (i = j&lt;&lt;4;  i &lt; (len);  ++i) { \</a>
<a name="ln69">            char c = (char)(buf)[i]; \</a>
<a name="ln70"> \</a>
<a name="ln71">            if (c == '\n') \</a>
<a name="ln72">                printf(&quot;\\n &quot;); \</a>
<a name="ln73">            else if (c == '\r') \</a>
<a name="ln74">                printf(&quot;\\r &quot;); \</a>
<a name="ln75">            else \</a>
<a name="ln76">                printf(&quot; %c &quot;, c); \</a>
<a name="ln77">        } \</a>
<a name="ln78">        printf(&quot;\n&quot;); \</a>
<a name="ln79">    } \</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">static int store_info OF((__GPRO));</a>
<a name="ln83">#ifdef SET_DIR_ATTRIB</a>
<a name="ln84">static int extract_or_test_entrylist OF((__GPRO__ unsigned numchunk,</a>
<a name="ln85">                ulg *pfilnum, ulg *pnum_bad_pwd, LONGINT *pold_extra_bytes,</a>
<a name="ln86">                unsigned *pnum_dirs, dirtime **pdirlist,</a>
<a name="ln87">                int error_in_archive));</a>
<a name="ln88">#else</a>
<a name="ln89">static int extract_or_test_entrylist OF((__GPRO__ unsigned numchunk,</a>
<a name="ln90">                ulg *pfilnum, ulg *pnum_bad_pwd, LONGINT *pold_extra_bytes,</a>
<a name="ln91">                int error_in_archive));</a>
<a name="ln92">#endif</a>
<a name="ln93">static int extract_or_test_member OF((__GPRO));</a>
<a name="ln94">#ifndef SFX</a>
<a name="ln95">   static int TestExtraField OF((__GPRO__ uch *ef, unsigned ef_len));</a>
<a name="ln96">   static int test_compr_eb OF((__GPRO__ uch *eb, unsigned eb_size,</a>
<a name="ln97">        unsigned compr_offset,</a>
<a name="ln98">        int (*test_uc_ebdata)(__GPRO__ uch *eb, unsigned eb_size,</a>
<a name="ln99">                              uch *eb_ucptr, ulg eb_ucsize)));</a>
<a name="ln100">#endif</a>
<a name="ln101">#if (defined(VMS) || defined(VMS_TEXT_CONV))</a>
<a name="ln102">   static void decompress_bits OF((uch *outptr, unsigned needlen,</a>
<a name="ln103">                                   ZCONST uch *bitptr));</a>
<a name="ln104">#endif</a>
<a name="ln105">#ifdef SET_DIR_ATTRIB</a>
<a name="ln106">   static int dircomp OF((ZCONST zvoid *a, ZCONST zvoid *b));</a>
<a name="ln107">#endif</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">/*******************************/</a>
<a name="ln112">/*  Strings used in extract.c  */</a>
<a name="ln113">/*******************************/</a>
<a name="ln114"> </a>
<a name="ln115">static ZCONST char Far VersionMsg[] =</a>
<a name="ln116">  &quot;   skipping: %-22s  need %s compat. v%u.%u (can do v%u.%u)\n&quot;;</a>
<a name="ln117">static ZCONST char Far ComprMsgNum[] =</a>
<a name="ln118">  &quot;   skipping: %-22s  unsupported compression method %u\n&quot;;</a>
<a name="ln119">#ifndef SFX</a>
<a name="ln120">   static ZCONST char Far ComprMsgName[] =</a>
<a name="ln121">     &quot;   skipping: %-22s  `%s' method not supported\n&quot;;</a>
<a name="ln122">   static ZCONST char Far CmprNone[]       = &quot;store&quot;;</a>
<a name="ln123">   static ZCONST char Far CmprShrink[]     = &quot;shrink&quot;;</a>
<a name="ln124">   static ZCONST char Far CmprReduce[]     = &quot;reduce&quot;;</a>
<a name="ln125">   static ZCONST char Far CmprImplode[]    = &quot;implode&quot;;</a>
<a name="ln126">   static ZCONST char Far CmprTokenize[]   = &quot;tokenize&quot;;</a>
<a name="ln127">   static ZCONST char Far CmprDeflate[]    = &quot;deflate&quot;;</a>
<a name="ln128">   static ZCONST char Far CmprDeflat64[]   = &quot;deflate64&quot;;</a>
<a name="ln129">   static ZCONST char Far CmprDCLImplode[] = &quot;DCL implode&quot;;</a>
<a name="ln130">   static ZCONST char Far *ComprNames[NUM_METHODS] = {</a>
<a name="ln131">     CmprNone, CmprShrink, CmprReduce, CmprReduce, CmprReduce, CmprReduce,</a>
<a name="ln132">     CmprImplode, CmprTokenize, CmprDeflate, CmprDeflat64, CmprDCLImplode</a>
<a name="ln133">   };</a>
<a name="ln134">#endif /* !SFX */</a>
<a name="ln135">static ZCONST char Far FilNamMsg[] =</a>
<a name="ln136">  &quot;%s:  bad filename length (%s)\n&quot;;</a>
<a name="ln137">static ZCONST char Far ExtFieldMsg[] =</a>
<a name="ln138">  &quot;%s:  bad extra field length (%s)\n&quot;;</a>
<a name="ln139">static ZCONST char Far OffsetMsg[] =</a>
<a name="ln140">  &quot;file #%lu:  bad zipfile offset (%s):  %ld\n&quot;;</a>
<a name="ln141">static ZCONST char Far ExtractMsg[] =</a>
<a name="ln142">  &quot;%8sing: %-22s  %s%s&quot;;</a>
<a name="ln143">#ifndef SFX</a>
<a name="ln144">   static ZCONST char Far LengthMsg[] =</a>
<a name="ln145">     &quot;%s  %s:  %ld bytes required to uncompress to %lu bytes;\n    %s\</a>
<a name="ln146">      supposed to require %lu bytes%s%s%s\n&quot;;</a>
<a name="ln147">#endif</a>
<a name="ln148"> </a>
<a name="ln149">static ZCONST char Far BadFileCommLength[] = &quot;%s:  bad file comment length\n&quot;;</a>
<a name="ln150">static ZCONST char Far LocalHdrSig[] = &quot;local header sig&quot;;</a>
<a name="ln151">static ZCONST char Far BadLocalHdr[] = &quot;file #%lu:  bad local header\n&quot;;</a>
<a name="ln152">static ZCONST char Far AttemptRecompensate[] =</a>
<a name="ln153">  &quot;  (attempting to re-compensate)\n&quot;;</a>
<a name="ln154">#ifndef SFX</a>
<a name="ln155">   static ZCONST char Far BackslashPathSep[] =</a>
<a name="ln156">     &quot;warning:  %s appears to use backslashes as path separators\n&quot;;</a>
<a name="ln157">#endif</a>
<a name="ln158">static ZCONST char Far AbsolutePathWarning[] =</a>
<a name="ln159">  &quot;warning:  stripped absolute path spec from %s\n&quot;;</a>
<a name="ln160">static ZCONST char Far SkipVolumeLabel[] =</a>
<a name="ln161">  &quot;   skipping: %-22s  %svolume label\n&quot;;</a>
<a name="ln162"> </a>
<a name="ln163">#ifdef SET_DIR_ATTRIB  /* messages of code for setting directory attributes */</a>
<a name="ln164">   static ZCONST char Far DirlistEntryNoMem[] =</a>
<a name="ln165">     &quot;warning:  cannot alloc memory for dir times/permissions/UID/GID\n&quot;;</a>
<a name="ln166">   static ZCONST char Far DirlistSortNoMem[] =</a>
<a name="ln167">     &quot;warning:  cannot alloc memory to sort dir times/perms/etc.\n&quot;;</a>
<a name="ln168">   static ZCONST char Far DirlistSetAttrFailed[] =</a>
<a name="ln169">     &quot;warning:  set times/attribs failed for %s\n&quot;;</a>
<a name="ln170">#endif</a>
<a name="ln171"> </a>
<a name="ln172">#ifndef WINDLL</a>
<a name="ln173">   static ZCONST char Far ReplaceQuery[] =</a>
<a name="ln174">     &quot;replace %s? [y]es, [n]o, [A]ll, [N]one, [r]ename: &quot;;</a>
<a name="ln175">   static ZCONST char Far AssumeNone[] = &quot; NULL\n(assuming [N]one)\n&quot;;</a>
<a name="ln176">   static ZCONST char Far NewNameQuery[] = &quot;new name: &quot;;</a>
<a name="ln177">   static ZCONST char Far InvalidResponse[] = &quot;error:  invalid response [%c]\n&quot;;</a>
<a name="ln178">#endif /* !WINDLL */</a>
<a name="ln179"> </a>
<a name="ln180">static ZCONST char Far ErrorInArchive[] =</a>
<a name="ln181">  &quot;At least one %serror was detected in %s.\n&quot;;</a>
<a name="ln182">static ZCONST char Far ZeroFilesTested[] =</a>
<a name="ln183">  &quot;Caution:  zero files tested in %s.\n&quot;;</a>
<a name="ln184"> </a>
<a name="ln185">#ifndef VMS</a>
<a name="ln186">   static ZCONST char Far VMSFormatQuery[] =</a>
<a name="ln187">     &quot;\n%s:  stored in VMS format.  Extract anyway? (y/n) &quot;;</a>
<a name="ln188">#endif</a>
<a name="ln189"> </a>
<a name="ln190">#if CRYPT</a>
<a name="ln191">   static ZCONST char Far SkipCannotGetPasswd[] =</a>
<a name="ln192">     &quot;   skipping: %-22s  unable to get password\n&quot;;</a>
<a name="ln193">   static ZCONST char Far SkipIncorrectPasswd[] =</a>
<a name="ln194">     &quot;   skipping: %-22s  incorrect password\n&quot;;</a>
<a name="ln195">   static ZCONST char Far FilesSkipBadPasswd[] =</a>
<a name="ln196">     &quot;%lu file%s skipped because of incorrect password.\n&quot;;</a>
<a name="ln197">   static ZCONST char Far MaybeBadPasswd[] =</a>
<a name="ln198">     &quot;    (may instead be incorrect password)\n&quot;;</a>
<a name="ln199">#else</a>
<a name="ln200">   static ZCONST char Far SkipEncrypted[] =</a>
<a name="ln201">     &quot;   skipping: %-22s  encrypted (not supported)\n&quot;;</a>
<a name="ln202">#endif</a>
<a name="ln203"> </a>
<a name="ln204">static ZCONST char Far NoErrInCompData[] =</a>
<a name="ln205">  &quot;No errors detected in compressed data of %s.\n&quot;;</a>
<a name="ln206">static ZCONST char Far NoErrInTestedFiles[] =</a>
<a name="ln207">  &quot;No errors detected in %s for the %lu file%s tested.\n&quot;;</a>
<a name="ln208">static ZCONST char Far FilesSkipped[] =</a>
<a name="ln209">  &quot;%lu file%s skipped because of unsupported compression or encoding.\n&quot;;</a>
<a name="ln210"> </a>
<a name="ln211">static ZCONST char Far ErrUnzipFile[] = &quot;  error:  %s%s %s\n&quot;;</a>
<a name="ln212">static ZCONST char Far ErrUnzipNoFile[] = &quot;\n  error:  %s%s\n&quot;;</a>
<a name="ln213">static ZCONST char Far NotEnoughMem[] = &quot;not enough memory to &quot;;</a>
<a name="ln214">static ZCONST char Far InvalidComprData[] = &quot;invalid compressed data to &quot;;</a>
<a name="ln215">static ZCONST char Far Inflate[] = &quot;inflate&quot;;</a>
<a name="ln216"> </a>
<a name="ln217">#ifndef SFX</a>
<a name="ln218">   static ZCONST char Far Explode[] = &quot;explode&quot;;</a>
<a name="ln219">#ifndef LZW_CLEAN</a>
<a name="ln220">   static ZCONST char Far Unshrink[] = &quot;unshrink&quot;;</a>
<a name="ln221">#endif</a>
<a name="ln222">#endif</a>
<a name="ln223"> </a>
<a name="ln224">#if (!defined(DELETE_IF_FULL) || !defined(HAVE_UNLINK))</a>
<a name="ln225">   static ZCONST char Far FileTruncated[] =</a>
<a name="ln226">     &quot;warning:  %s is probably truncated\n&quot;;</a>
<a name="ln227">#endif</a>
<a name="ln228"> </a>
<a name="ln229">static ZCONST char Far FileUnknownCompMethod[] =</a>
<a name="ln230">  &quot;%s:  unknown compression method\n&quot;;</a>
<a name="ln231">static ZCONST char Far BadCRC[] = &quot; bad CRC %08lx  (should be %08lx)\n&quot;;</a>
<a name="ln232"> </a>
<a name="ln233">      /* TruncEAs[] also used in OS/2 mapname(), close_outfile() */</a>
<a name="ln234">char ZCONST Far TruncEAs[] = &quot; compressed EA data missing (%d bytes)%s&quot;;</a>
<a name="ln235">char ZCONST Far TruncNTSD[] =</a>
<a name="ln236">  &quot; compressed WinNT security data missing (%d bytes)%s&quot;;</a>
<a name="ln237"> </a>
<a name="ln238">#ifndef SFX</a>
<a name="ln239">   static ZCONST char Far InconsistEFlength[] = &quot;bad extra-field entry:\n \</a>
<a name="ln240">     EF block length (%u bytes) exceeds remaining EF data (%u bytes)\n&quot;;</a>
<a name="ln241">   static ZCONST char Far InvalidComprDataEAs[] =</a>
<a name="ln242">     &quot; invalid compressed data for EAs\n&quot;;</a>
<a name="ln243">#  if (defined(WIN32) &amp;&amp; defined(NTSD_EAS))</a>
<a name="ln244">     static ZCONST char Far InvalidSecurityEAs[] =</a>
<a name="ln245">       &quot; EAs fail security check\n&quot;;</a>
<a name="ln246">#  endif</a>
<a name="ln247">   static ZCONST char Far UnsuppNTSDVersEAs[] =</a>
<a name="ln248">     &quot; unsupported NTSD EAs version %d\n&quot;;</a>
<a name="ln249">   static ZCONST char Far BadCRC_EAs[] = &quot; bad CRC for extended attributes\n&quot;;</a>
<a name="ln250">   static ZCONST char Far UnknComprMethodEAs[] =</a>
<a name="ln251">     &quot; unknown compression method for EAs (%u)\n&quot;;</a>
<a name="ln252">   static ZCONST char Far NotEnoughMemEAs[] =</a>
<a name="ln253">     &quot; out of memory while inflating EAs\n&quot;;</a>
<a name="ln254">   static ZCONST char Far UnknErrorEAs[] =</a>
<a name="ln255">     &quot; unknown error on extended attributes\n&quot;;</a>
<a name="ln256">#endif /* !SFX */</a>
<a name="ln257"> </a>
<a name="ln258">static ZCONST char Far UnsupportedExtraField[] =</a>
<a name="ln259">  &quot;\nerror:  unsupported extra-field compression type (%u)--skipping\n&quot;;</a>
<a name="ln260">static ZCONST char Far BadExtraFieldCRC[] =</a>
<a name="ln261">  &quot;error [%s]:  bad extra-field CRC %08lx (should be %08lx)\n&quot;;</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">/**************************************/</a>
<a name="ln268">/*  Function extract_or_test_files()  */</a>
<a name="ln269">/**************************************/</a>
<a name="ln270"> </a>
<a name="ln271">int extract_or_test_files(__G)    /* return PK-type error code */</a>
<a name="ln272">     __GDEF</a>
<a name="ln273">{</a>
<a name="ln274">    unsigned i, j;</a>
<a name="ln275">    long cd_bufstart;</a>
<a name="ln276">    uch *cd_inptr;</a>
<a name="ln277">    int cd_incnt;</a>
<a name="ln278">    ulg filnum=0L, blknum=0L;</a>
<a name="ln279">    int reached_end, no_endsig_found;</a>
<a name="ln280">    int error, error_in_archive=PK_COOL;</a>
<a name="ln281">    int *fn_matched=NULL, *xn_matched=NULL;</a>
<a name="ln282">    unsigned members_processed;</a>
<a name="ln283">    ulg num_skipped=0L, num_bad_pwd=0L;</a>
<a name="ln284">    LONGINT old_extra_bytes = 0L;</a>
<a name="ln285">#ifdef SET_DIR_ATTRIB</a>
<a name="ln286">    unsigned num_dirs=0;</a>
<a name="ln287">    dirtime *dirlist=(dirtime *)NULL, **sorted_dirlist=(dirtime **)NULL;</a>
<a name="ln288">#endif</a>
<a name="ln289"> </a>
<a name="ln290">/*---------------------------------------------------------------------------</a>
<a name="ln291">    The basic idea of this function is as follows.  Since the central di-</a>
<a name="ln292">    rectory lies at the end of the zipfile and the member files lie at the</a>
<a name="ln293">    beginning or middle or wherever, it is not very desirable to simply</a>
<a name="ln294">    read a central directory entry, jump to the member and extract it, and</a>
<a name="ln295">    then jump back to the central directory.  In the case of a large zipfile</a>
<a name="ln296">    this would lead to a whole lot of disk-grinding, especially if each mem-</a>
<a name="ln297">    ber file is small.  Instead, we read from the central directory the per-</a>
<a name="ln298">    tinent information for a block of files, then go extract/test the whole</a>
<a name="ln299">    block.  Thus this routine contains two small(er) loops within a very</a>
<a name="ln300">    large outer loop:  the first of the small ones reads a block of files</a>
<a name="ln301">    from the central directory; the second extracts or tests each file; and</a>
<a name="ln302">    the outer one loops over blocks.  There's some file-pointer positioning</a>
<a name="ln303">    stuff in between, but that's about it.  Btw, it's because of this jump-</a>
<a name="ln304">    ing around that we can afford to be lenient if an error occurs in one of</a>
<a name="ln305">    the member files:  we should still be able to go find the other members,</a>
<a name="ln306">    since we know the offset of each from the beginning of the zipfile.</a>
<a name="ln307">  ---------------------------------------------------------------------------*/</a>
<a name="ln308"> </a>
<a name="ln309">    G.pInfo = G.info;</a>
<a name="ln310"> </a>
<a name="ln311">#if CRYPT</a>
<a name="ln312">    G.newzip = TRUE;</a>
<a name="ln313">#endif</a>
<a name="ln314">#ifndef SFX</a>
<a name="ln315">    G.reported_backslash = FALSE;</a>
<a name="ln316">#endif</a>
<a name="ln317"> </a>
<a name="ln318">    /* malloc space for check on unmatched filespecs (OK if one or both NULL) */</a>
<a name="ln319">    if (G.filespecs &gt; 0  &amp;&amp;</a>
<a name="ln320">        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != (int *)NULL)</a>
<a name="ln321">        for (i = 0;  i &lt; G.filespecs;  ++i)</a>
<a name="ln322">            fn_matched[i] = FALSE;</a>
<a name="ln323">    if (G.xfilespecs &gt; 0  &amp;&amp;</a>
<a name="ln324">        (xn_matched=(int *)malloc(G.xfilespecs*sizeof(int))) != (int *)NULL)</a>
<a name="ln325">        for (i = 0;  i &lt; G.xfilespecs;  ++i)</a>
<a name="ln326">            xn_matched[i] = FALSE;</a>
<a name="ln327"> </a>
<a name="ln328">/*---------------------------------------------------------------------------</a>
<a name="ln329">    Begin main loop over blocks of member files.  We know the entire central</a>
<a name="ln330">    directory is on this disk:  we would not have any of this information un-</a>
<a name="ln331">    less the end-of-central-directory record was on this disk, and we would</a>
<a name="ln332">    not have gotten to this routine unless this is also the disk on which</a>
<a name="ln333">    the central directory starts.  In practice, this had better be the ONLY</a>
<a name="ln334">    disk in the archive, but we'll add multi-disk support soon.</a>
<a name="ln335">  ---------------------------------------------------------------------------*/</a>
<a name="ln336"> </a>
<a name="ln337">    members_processed = 0;</a>
<a name="ln338">    no_endsig_found = FALSE;</a>
<a name="ln339">    reached_end = FALSE;</a>
<a name="ln340">    while (!reached_end) {</a>
<a name="ln341">        j = 0;</a>
<a name="ln342">#ifdef AMIGA</a>
<a name="ln343">        memzero(G.filenotes, DIR_BLKSIZ * sizeof(char *));</a>
<a name="ln344">#endif</a>
<a name="ln345"> </a>
<a name="ln346">        /*</a>
<a name="ln347">         * Loop through files in central directory, storing offsets, file</a>
<a name="ln348">         * attributes, case-conversion and text-conversion flags until block</a>
<a name="ln349">         * size is reached.</a>
<a name="ln350">         */</a>
<a name="ln351"> </a>
<a name="ln352">        while ((j &lt; DIR_BLKSIZ)) {</a>
<a name="ln353">            G.pInfo = &amp;G.info[j];</a>
<a name="ln354"> </a>
<a name="ln355">            if (readbuf(__G__ G.sig, 4) == 0) {</a>
<a name="ln356">                error_in_archive = PK_EOF;</a>
<a name="ln357">                reached_end = TRUE;     /* ...so no more left to do */</a>
<a name="ln358">                break;</a>
<a name="ln359">            }</a>
<a name="ln360">            if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a new entry? */</a>
<a name="ln361">                /* no new central directory entry</a>
<a name="ln362">                 * -&gt; is the number of processed entries compatible with the</a>
<a name="ln363">                 *    number of entries as stored in the end_central record?</a>
<a name="ln364">                 */</a>
<a name="ln365">                if ((members_processed &amp; (unsigned)0xFFFF) ==</a>
<a name="ln366">                    (unsigned)G.ecrec.total_entries_central_dir) {</a>
<a name="ln367">                    /* yes, so look if we ARE back at the end_central record</a>
<a name="ln368">                     */</a>
<a name="ln369">                    no_endsig_found =</a>
<a name="ln370">                      (strncmp(G.sig, end_central_sig, 4) != 0);</a>
<a name="ln371">                } else {</a>
<a name="ln372">                    /* no; we have found an error in the central directory</a>
<a name="ln373">                     * -&gt; report it and stop searching for more Zip entries</a>
<a name="ln374">                     */</a>
<a name="ln375">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln376">                      LoadFarString(CentSigMsg), j + blknum*DIR_BLKSIZ + 1));</a>
<a name="ln377">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln378">                      LoadFarString(ReportMsg)));</a>
<a name="ln379">                    error_in_archive = PK_BADERR;</a>
<a name="ln380">                }</a>
<a name="ln381">                reached_end = TRUE;     /* ...so no more left to do */</a>
<a name="ln382">                break;</a>
<a name="ln383">            }</a>
<a name="ln384">            /* process_cdir_file_hdr() sets pInfo-&gt;hostnum, pInfo-&gt;lcflag */</a>
<a name="ln385">            if ((error = process_cdir_file_hdr(__G)) != PK_COOL) {</a>
<a name="ln386">                error_in_archive = error;   /* only PK_EOF defined */</a>
<a name="ln387">                reached_end = TRUE;     /* ...so no more left to do */</a>
<a name="ln388">                break;</a>
<a name="ln389">            }</a>
<a name="ln390">            if ((error = do_string(__G__ G.crec.filename_length, DS_FN)) !=</a>
<a name="ln391">                 PK_COOL)</a>
<a name="ln392">            {</a>
<a name="ln393">                if (error &gt; error_in_archive)</a>
<a name="ln394">                    error_in_archive = error;</a>
<a name="ln395">                if (error &gt; PK_WARN) {  /* fatal:  no more left to do */</a>
<a name="ln396">                    Info(slide, 0x401, ((char *)slide, LoadFarString(FilNamMsg),</a>
<a name="ln397">                      FnFilter1(G.filename), &quot;central&quot;));</a>
<a name="ln398">                    reached_end = TRUE;</a>
<a name="ln399">                    break;</a>
<a name="ln400">                }</a>
<a name="ln401">            }</a>
<a name="ln402">            if ((error = do_string(__G__ G.crec.extra_field_length,</a>
<a name="ln403">                EXTRA_FIELD)) != 0)</a>
<a name="ln404">            {</a>
<a name="ln405">                if (error &gt; error_in_archive)</a>
<a name="ln406">                    error_in_archive = error;</a>
<a name="ln407">                if (error &gt; PK_WARN) {  /* fatal */</a>
<a name="ln408">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln409">                      LoadFarString(ExtFieldMsg),</a>
<a name="ln410">                      FnFilter1(G.filename), &quot;central&quot;));</a>
<a name="ln411">                    reached_end = TRUE;</a>
<a name="ln412">                    break;</a>
<a name="ln413">                }</a>
<a name="ln414">            }</a>
<a name="ln415">#ifdef AMIGA</a>
<a name="ln416">            G.filenote_slot = j;</a>
<a name="ln417">            if ((error = do_string(__G__ G.crec.file_comment_length,</a>
<a name="ln418">                                   uO.N_flag ? FILENOTE : SKIP)) != PK_COOL)</a>
<a name="ln419">#else</a>
<a name="ln420">            if ((error = do_string(__G__ G.crec.file_comment_length, SKIP))</a>
<a name="ln421">                != PK_COOL)</a>
<a name="ln422">#endif</a>
<a name="ln423">            {</a>
<a name="ln424">                if (error &gt; error_in_archive)</a>
<a name="ln425">                    error_in_archive = error;</a>
<a name="ln426">                if (error &gt; PK_WARN) {  /* fatal */</a>
<a name="ln427">                    Info(slide, 0x421, ((char *)slide,</a>
<a name="ln428">                      LoadFarString(BadFileCommLength),</a>
<a name="ln429">                      FnFilter1(G.filename)));</a>
<a name="ln430">                    reached_end = TRUE;</a>
<a name="ln431">                    break;</a>
<a name="ln432">                }</a>
<a name="ln433">            }</a>
<a name="ln434">            if (G.process_all_files) {</a>
<a name="ln435">                if (store_info(__G))</a>
<a name="ln436">                    ++j;  /* file is OK; info[] stored; continue with next */</a>
<a name="ln437">                else</a>
<a name="ln438">                    ++num_skipped;</a>
<a name="ln439">            } else {</a>
<a name="ln440">                int   do_this_file;</a>
<a name="ln441"> </a>
<a name="ln442">                if (G.filespecs == 0)</a>
<a name="ln443">                    do_this_file = TRUE;</a>
<a name="ln444">                else {  /* check if this entry matches an `include' argument */</a>
<a name="ln445">                    do_this_file = FALSE;</a>
<a name="ln446">                    for (i = 0; i &lt; G.filespecs; i++)</a>
<a name="ln447">                        if (match(G.filename, G.pfnames[i], uO.C_flag)) {</a>
<a name="ln448">                            do_this_file = TRUE;  /* ^-- ignore case or not? */</a>
<a name="ln449">                            if (fn_matched)</a>
<a name="ln450">                                fn_matched[i] = TRUE;</a>
<a name="ln451">                            break;       /* found match, so stop looping */</a>
<a name="ln452">                        }</a>
<a name="ln453">                }</a>
<a name="ln454">                if (do_this_file) {  /* check if this is an excluded file */</a>
<a name="ln455">                    for (i = 0; i &lt; G.xfilespecs; i++)</a>
<a name="ln456">                        if (match(G.filename, G.pxnames[i], uO.C_flag)) {</a>
<a name="ln457">                            do_this_file = FALSE; /* ^-- ignore case or not? */</a>
<a name="ln458">                            if (xn_matched)</a>
<a name="ln459">                                xn_matched[i] = TRUE;</a>
<a name="ln460">                            break;</a>
<a name="ln461">                        }</a>
<a name="ln462">                }</a>
<a name="ln463">                if (do_this_file) {</a>
<a name="ln464">                    if (store_info(__G))</a>
<a name="ln465">                        ++j;            /* file is OK */</a>
<a name="ln466">                    else</a>
<a name="ln467">                        ++num_skipped;  /* unsupp. compression or encryption */</a>
<a name="ln468">                }</a>
<a name="ln469">            } /* end if (process_all_files) */</a>
<a name="ln470"> </a>
<a name="ln471">            members_processed++;</a>
<a name="ln472"> </a>
<a name="ln473">        } /* end while-loop (adding files to current block) */</a>
<a name="ln474"> </a>
<a name="ln475">        /* save position in central directory so can come back later */</a>
<a name="ln476">        cd_bufstart = G.cur_zipfile_bufstart;</a>
<a name="ln477">        cd_inptr = G.inptr;</a>
<a name="ln478">        cd_incnt = G.incnt;</a>
<a name="ln479"> </a>
<a name="ln480">    /*-----------------------------------------------------------------------</a>
<a name="ln481">        Second loop:  process files in current block, extracting or testing</a>
<a name="ln482">        each one.</a>
<a name="ln483">      -----------------------------------------------------------------------*/</a>
<a name="ln484"> </a>
<a name="ln485">        error = extract_or_test_entrylist(__G__ j,</a>
<a name="ln486">                        &amp;filnum, &amp;num_bad_pwd, &amp;old_extra_bytes,</a>
<a name="ln487">#ifdef SET_DIR_ATTRIB</a>
<a name="ln488">                        &amp;num_dirs, &amp;dirlist,</a>
<a name="ln489">#endif</a>
<a name="ln490">                        error_in_archive);</a>
<a name="ln491">        if (error != PK_COOL) {</a>
<a name="ln492">            if (error &gt; error_in_archive)</a>
<a name="ln493">                error_in_archive = error;       /* ...and keep going */</a>
<a name="ln494">            if (G.disk_full &gt; 1 || error_in_archive == IZ_CTRLC) {</a>
<a name="ln495">                if (fn_matched)</a>
<a name="ln496">                    free((zvoid *)fn_matched);</a>
<a name="ln497">                if (xn_matched)</a>
<a name="ln498">                    free((zvoid *)xn_matched);</a>
<a name="ln499">                return error_in_archive;        /* (unless disk full) */</a>
<a name="ln500">            }</a>
<a name="ln501">        }</a>
<a name="ln502"> </a>
<a name="ln503"> </a>
<a name="ln504">        /*</a>
<a name="ln505">         * Jump back to where we were in the central directory, then go and do</a>
<a name="ln506">         * the next batch of files.</a>
<a name="ln507">         */</a>
<a name="ln508"> </a>
<a name="ln509">#ifdef USE_STRM_INPUT</a>
<a name="ln510">        fseek((FILE *)G.zipfd, (LONGINT)cd_bufstart, SEEK_SET);</a>
<a name="ln511">        G.cur_zipfile_bufstart = ftell((FILE *)G.zipfd);</a>
<a name="ln512">#else /* !USE_STRM_INPUT */</a>
<a name="ln513">        G.cur_zipfile_bufstart =</a>
<a name="ln514">          lseek(G.zipfd, (LONGINT)cd_bufstart, SEEK_SET);</a>
<a name="ln515">#endif /* ?USE_STRM_INPUT */</a>
<a name="ln516">        read(G.zipfd, (char *)G.inbuf, INBUFSIZ);  /* been here before... */</a>
<a name="ln517">        G.inptr = cd_inptr;</a>
<a name="ln518">        G.incnt = cd_incnt;</a>
<a name="ln519">        ++blknum;</a>
<a name="ln520"> </a>
<a name="ln521">#ifdef TEST</a>
<a name="ln522">        printf(&quot;\ncd_bufstart = %ld (%.8lXh)\n&quot;, cd_bufstart, cd_bufstart);</a>
<a name="ln523">        printf(&quot;cur_zipfile_bufstart = %ld (%.8lXh)\n&quot;, cur_zipfile_bufstart,</a>
<a name="ln524">          cur_zipfile_bufstart);</a>
<a name="ln525">        printf(&quot;inptr-inbuf = %d\n&quot;, G.inptr-G.inbuf);</a>
<a name="ln526">        printf(&quot;incnt = %d\n\n&quot;, G.incnt);</a>
<a name="ln527">#endif</a>
<a name="ln528"> </a>
<a name="ln529">    } /* end while-loop (blocks of files in central directory) */</a>
<a name="ln530"> </a>
<a name="ln531">/*---------------------------------------------------------------------------</a>
<a name="ln532">    Go back through saved list of directories, sort and set times/perms/UIDs</a>
<a name="ln533">    and GIDs from the deepest level on up.</a>
<a name="ln534">  ---------------------------------------------------------------------------*/</a>
<a name="ln535"> </a>
<a name="ln536">#ifdef SET_DIR_ATTRIB</a>
<a name="ln537">    if (num_dirs &gt; 0) {</a>
<a name="ln538">        sorted_dirlist = (dirtime **)malloc(num_dirs*sizeof(dirtime *));</a>
<a name="ln539">        if (sorted_dirlist == (dirtime **)NULL) {</a>
<a name="ln540">            Info(slide, 0x401, ((char *)slide,</a>
<a name="ln541">              LoadFarString(DirlistSortNoMem)));</a>
<a name="ln542">            while (dirlist != (dirtime *)NULL) {</a>
<a name="ln543">                dirtime *d = dirlist;</a>
<a name="ln544"> </a>
<a name="ln545">                dirlist = dirlist-&gt;next;</a>
<a name="ln546">                free(d);</a>
<a name="ln547">            }</a>
<a name="ln548">        } else {</a>
<a name="ln549">            if (num_dirs == 1)</a>
<a name="ln550">                sorted_dirlist[0] = dirlist;</a>
<a name="ln551">            else {</a>
<a name="ln552">                for (i = 0;  i &lt; num_dirs;  ++i) {</a>
<a name="ln553">                    sorted_dirlist[i] = dirlist;</a>
<a name="ln554">                    dirlist = dirlist-&gt;next;</a>
<a name="ln555">                }</a>
<a name="ln556">                qsort((char *)sorted_dirlist, num_dirs, sizeof(dirtime *),</a>
<a name="ln557">                  dircomp);</a>
<a name="ln558">            }</a>
<a name="ln559"> </a>
<a name="ln560">            Trace((stderr, &quot;setting directory times/perms/attributes\n&quot;));</a>
<a name="ln561">            for (i = 0;  i &lt; num_dirs;  ++i) {</a>
<a name="ln562">                dirtime *d = sorted_dirlist[i];</a>
<a name="ln563"> </a>
<a name="ln564">                Trace((stderr, &quot;dir = %s\n&quot;, d-&gt;fn));</a>
<a name="ln565">                if ((error = set_direc_attribs(__G__ d)) != PK_OK) {</a>
<a name="ln566">                    Info(slide, 0x201, ((char *)slide,</a>
<a name="ln567">                      LoadFarString(DirlistSetAttrFailed), d-&gt;fn));</a>
<a name="ln568">                    if (!error_in_archive)</a>
<a name="ln569">                        error_in_archive = error;</a>
<a name="ln570">                }</a>
<a name="ln571">                free(d-&gt;fn);</a>
<a name="ln572">                free(d);</a>
<a name="ln573">            }</a>
<a name="ln574">            free(sorted_dirlist);</a>
<a name="ln575">        }</a>
<a name="ln576">    }</a>
<a name="ln577">#endif /* SET_DIR_ATTRIB */</a>
<a name="ln578"> </a>
<a name="ln579">#if (defined(WIN32) &amp;&amp; defined(NTSD_EAS))</a>
<a name="ln580">    process_defer_NT(__G);  /* process any deferred items for this .zip file */</a>
<a name="ln581">#endif</a>
<a name="ln582"> </a>
<a name="ln583">/*---------------------------------------------------------------------------</a>
<a name="ln584">    Check for unmatched filespecs on command line and print warning if any</a>
<a name="ln585">    found.  Free allocated memory.</a>
<a name="ln586">  ---------------------------------------------------------------------------*/</a>
<a name="ln587"> </a>
<a name="ln588">    if (fn_matched) {</a>
<a name="ln589">        for (i = 0;  i &lt; G.filespecs;  ++i)</a>
<a name="ln590">            if (!fn_matched[i]) {</a>
<a name="ln591">#ifdef DLL</a>
<a name="ln592">                if (!G.redirect_data &amp;&amp; !G.redirect_text)</a>
<a name="ln593">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln594">                      LoadFarString(FilenameNotMatched), G.pfnames[i]));</a>
<a name="ln595">                else</a>
<a name="ln596">                    setFileNotFound(__G);</a>
<a name="ln597">#else</a>
<a name="ln598">                Info(slide, 1, ((char *)slide,</a>
<a name="ln599">                  LoadFarString(FilenameNotMatched), G.pfnames[i]));</a>
<a name="ln600">#endif</a>
<a name="ln601">                if (error_in_archive &lt;= PK_WARN)</a>
<a name="ln602">                    error_in_archive = PK_FIND;   /* some files not found */</a>
<a name="ln603">            }</a>
<a name="ln604">        free((zvoid *)fn_matched);</a>
<a name="ln605">    }</a>
<a name="ln606">    if (xn_matched) {</a>
<a name="ln607">        for (i = 0;  i &lt; G.xfilespecs;  ++i)</a>
<a name="ln608">            if (!xn_matched[i])</a>
<a name="ln609">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln610">                  LoadFarString(ExclFilenameNotMatched), G.pxnames[i]));</a>
<a name="ln611">        free((zvoid *)xn_matched);</a>
<a name="ln612">    }</a>
<a name="ln613"> </a>
<a name="ln614">/*---------------------------------------------------------------------------</a>
<a name="ln615">    Double-check that we're back at the end-of-central-directory record, and</a>
<a name="ln616">    print quick summary of results, if we were just testing the archive.  We</a>
<a name="ln617">    send the summary to stdout so that people doing the testing in the back-</a>
<a name="ln618">    ground and redirecting to a file can just do a &quot;tail&quot; on the output file.</a>
<a name="ln619">  ---------------------------------------------------------------------------*/</a>
<a name="ln620"> </a>
<a name="ln621">#ifndef SFX</a>
<a name="ln622">    if (no_endsig_found) {                      /* just to make sure */</a>
<a name="ln623">        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));</a>
<a name="ln624">        Info(slide, 0x401, ((char *)slide, LoadFarString(ReportMsg)));</a>
<a name="ln625">        if (!error_in_archive)       /* don't overwrite stronger error */</a>
<a name="ln626">            error_in_archive = PK_WARN;</a>
<a name="ln627">    }</a>
<a name="ln628">#endif /* !SFX */</a>
<a name="ln629">    if (uO.tflag) {</a>
<a name="ln630">        ulg num = filnum - num_bad_pwd;</a>
<a name="ln631"> </a>
<a name="ln632">        if (uO.qflag &lt; 2) {        /* GRR 930710:  was (uO.qflag == 1) */</a>
<a name="ln633">            if (error_in_archive)</a>
<a name="ln634">                Info(slide, 0, ((char *)slide, LoadFarString(ErrorInArchive),</a>
<a name="ln635">                  (error_in_archive == PK_WARN)? &quot;warning-&quot; : &quot;&quot;, G.zipfn));</a>
<a name="ln636">            else if (num == 0L)</a>
<a name="ln637">                Info(slide, 0, ((char *)slide, LoadFarString(ZeroFilesTested),</a>
<a name="ln638">                  G.zipfn));</a>
<a name="ln639">            else if (G.process_all_files &amp;&amp; (num_skipped+num_bad_pwd == 0L))</a>
<a name="ln640">                Info(slide, 0, ((char *)slide, LoadFarString(NoErrInCompData),</a>
<a name="ln641">                  G.zipfn));</a>
<a name="ln642">            else</a>
<a name="ln643">                Info(slide, 0, ((char *)slide, LoadFarString(NoErrInTestedFiles)</a>
<a name="ln644">                  , G.zipfn, num, (num==1L)? &quot;&quot;:&quot;s&quot;));</a>
<a name="ln645">            if (num_skipped &gt; 0L)</a>
<a name="ln646">                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipped),</a>
<a name="ln647">                  num_skipped, (num_skipped==1L)? &quot;&quot;:&quot;s&quot;));</a>
<a name="ln648">#if CRYPT</a>
<a name="ln649">            if (num_bad_pwd &gt; 0L)</a>
<a name="ln650">                Info(slide, 0, ((char *)slide, LoadFarString(FilesSkipBadPasswd)</a>
<a name="ln651">                  , num_bad_pwd, (num_bad_pwd==1L)? &quot;&quot;:&quot;s&quot;));</a>
<a name="ln652">#endif /* CRYPT */</a>
<a name="ln653">        } else if ((uO.qflag == 0) &amp;&amp; !error_in_archive &amp;&amp; (num == 0))</a>
<a name="ln654">            Info(slide, 0, ((char *)slide, LoadFarString(ZeroFilesTested),</a>
<a name="ln655">              G.zipfn));</a>
<a name="ln656">    }</a>
<a name="ln657"> </a>
<a name="ln658">    /* give warning if files not tested or extracted (first condition can still</a>
<a name="ln659">     * happen if zipfile is empty and no files specified on command line) */</a>
<a name="ln660"> </a>
<a name="ln661">    if ((filnum == 0) &amp;&amp; error_in_archive &lt;= PK_WARN) {</a>
<a name="ln662">        if (num_skipped &gt; 0L)</a>
<a name="ln663">            error_in_archive = IZ_UNSUP; /* unsupport. compression/encryption */</a>
<a name="ln664">        else</a>
<a name="ln665">            error_in_archive = PK_FIND;  /* no files found at all */</a>
<a name="ln666">    }</a>
<a name="ln667">#if CRYPT</a>
<a name="ln668">    else if ((filnum == num_bad_pwd) &amp;&amp; error_in_archive &lt;= PK_WARN)</a>
<a name="ln669">        error_in_archive = IZ_BADPWD;    /* bad passwd =&gt; all files skipped */</a>
<a name="ln670">#endif</a>
<a name="ln671">    else if ((num_skipped &gt; 0L) &amp;&amp; error_in_archive &lt;= PK_WARN)</a>
<a name="ln672">        error_in_archive = IZ_UNSUP;     /* was PK_WARN; Jean-loup complained */</a>
<a name="ln673">#if CRYPT</a>
<a name="ln674">    else if ((num_bad_pwd &gt; 0L) &amp;&amp; !error_in_archive)</a>
<a name="ln675">        error_in_archive = PK_WARN;</a>
<a name="ln676">#endif</a>
<a name="ln677"> </a>
<a name="ln678">    return error_in_archive;</a>
<a name="ln679"> </a>
<a name="ln680">} /* end function extract_or_test_files() */</a>
<a name="ln681"> </a>
<a name="ln682"> </a>
<a name="ln683"> </a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">/***************************/</a>
<a name="ln687">/*  Function store_info()  */</a>
<a name="ln688">/***************************/</a>
<a name="ln689"> </a>
<a name="ln690">static int store_info(__G)   /* return 0 if skipping, 1 if OK */</a>
<a name="ln691">    __GDEF</a>
<a name="ln692">{</a>
<a name="ln693">#ifdef SFX</a>
<a name="ln694">#  ifdef USE_DEFLATE64</a>
<a name="ln695">#    define UNKN_COMPR \</a>
<a name="ln696">     (G.crec.compression_method!=STORED &amp;&amp; G.crec.compression_method&lt;DEFLATED \</a>
<a name="ln697">      &amp;&amp; G.crec.compression_method&gt;ENHDEFLATED)</a>
<a name="ln698">#  else</a>
<a name="ln699">#    define UNKN_COMPR \</a>
<a name="ln700">     (G.crec.compression_method!=STORED &amp;&amp; G.crec.compression_method!=DEFLATED)</a>
<a name="ln701">#  endif</a>
<a name="ln702">#else</a>
<a name="ln703">#  ifdef COPYRIGHT_CLEAN  /* no reduced files */</a>
<a name="ln704">#    define UNKN_RED (G.crec.compression_method &gt;= REDUCED1 &amp;&amp; \</a>
<a name="ln705">                      G.crec.compression_method &lt;= REDUCED4)</a>
<a name="ln706">#  else</a>
<a name="ln707">#    define UNKN_RED  FALSE  /* reducing not unknown */</a>
<a name="ln708">#  endif</a>
<a name="ln709">#  ifdef LZW_CLEAN  /* no shrunk files */</a>
<a name="ln710">#    define UNKN_SHR (G.crec.compression_method == SHRUNK)</a>
<a name="ln711">#  else</a>
<a name="ln712">#    define UNKN_SHR  FALSE  /* unshrinking not unknown */</a>
<a name="ln713">#  endif</a>
<a name="ln714">#  ifdef USE_DEFLATE64</a>
<a name="ln715">#    define UNKN_COMPR (UNKN_RED || UNKN_SHR || \</a>
<a name="ln716">     G.crec.compression_method==TOKENIZED || \</a>
<a name="ln717">     G.crec.compression_method&gt;ENHDEFLATED)</a>
<a name="ln718">#  else</a>
<a name="ln719">#    define UNKN_COMPR (UNKN_RED || UNKN_SHR || \</a>
<a name="ln720">     G.crec.compression_method==TOKENIZED || \</a>
<a name="ln721">     G.crec.compression_method&gt;DEFLATED)</a>
<a name="ln722">#  endif</a>
<a name="ln723">#endif</a>
<a name="ln724"> </a>
<a name="ln725">/*---------------------------------------------------------------------------</a>
<a name="ln726">    Check central directory info for version/compatibility requirements.</a>
<a name="ln727">  ---------------------------------------------------------------------------*/</a>
<a name="ln728"> </a>
<a name="ln729">    G.pInfo-&gt;encrypted = G.crec.general_purpose_bit_flag &amp; 1;   /* bit field */</a>
<a name="ln730">    G.pInfo-&gt;ExtLocHdr = (G.crec.general_purpose_bit_flag &amp; 8) == 8;  /* bit */</a>
<a name="ln731">    G.pInfo-&gt;textfile = G.crec.internal_file_attributes &amp; 1;    /* bit field */</a>
<a name="ln732">    G.pInfo-&gt;crc = G.crec.crc32;</a>
<a name="ln733">    G.pInfo-&gt;compr_size = G.crec.csize;</a>
<a name="ln734">    G.pInfo-&gt;uncompr_size = G.crec.ucsize;</a>
<a name="ln735"> </a>
<a name="ln736">    switch (uO.aflag) {</a>
<a name="ln737">        case 0:</a>
<a name="ln738">            G.pInfo-&gt;textmode = FALSE;   /* bit field */</a>
<a name="ln739">            break;</a>
<a name="ln740">        case 1:</a>
<a name="ln741">            G.pInfo-&gt;textmode = G.pInfo-&gt;textfile;   /* auto-convert mode */</a>
<a name="ln742">            break;</a>
<a name="ln743">        default:  /* case 2: */</a>
<a name="ln744">            G.pInfo-&gt;textmode = TRUE;</a>
<a name="ln745">            break;</a>
<a name="ln746">    }</a>
<a name="ln747"> </a>
<a name="ln748">    if (G.crec.version_needed_to_extract[1] == VMS_) {</a>
<a name="ln749">        if (G.crec.version_needed_to_extract[0] &gt; VMS_UNZIP_VERSION) {</a>
<a name="ln750">            if (!((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2)))</a>
<a name="ln751">                Info(slide, 0x401, ((char *)slide, LoadFarString(VersionMsg),</a>
<a name="ln752">                  FnFilter1(G.filename), &quot;VMS&quot;,</a>
<a name="ln753">                  G.crec.version_needed_to_extract[0] / 10,</a>
<a name="ln754">                  G.crec.version_needed_to_extract[0] % 10,</a>
<a name="ln755">                  VMS_UNZIP_VERSION / 10, VMS_UNZIP_VERSION % 10));</a>
<a name="ln756">            return 0;</a>
<a name="ln757">        }</a>
<a name="ln758">#ifndef VMS   /* won't be able to use extra field, but still have data */</a>
<a name="ln759">        else if (!uO.tflag &amp;&amp; !IS_OVERWRT_ALL) { /* if -o, extract anyway */</a>
<a name="ln760">            Info(slide, 0x481, ((char *)slide, LoadFarString(VMSFormatQuery),</a>
<a name="ln761">              FnFilter1(G.filename)));</a>
<a name="ln762">            fgets(G.answerbuf, 9, stdin);</a>
<a name="ln763">            if ((*G.answerbuf != 'y') &amp;&amp; (*G.answerbuf != 'Y'))</a>
<a name="ln764">                return 0;</a>
<a name="ln765">        }</a>
<a name="ln766">#endif /* !VMS */</a>
<a name="ln767">    /* usual file type:  don't need VMS to extract */</a>
<a name="ln768">    } else if (G.crec.version_needed_to_extract[0] &gt; UNZIP_VERSION) {</a>
<a name="ln769">        if (!((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2)))</a>
<a name="ln770">            Info(slide, 0x401, ((char *)slide, LoadFarString(VersionMsg),</a>
<a name="ln771">              FnFilter1(G.filename), &quot;PK&quot;,</a>
<a name="ln772">              G.crec.version_needed_to_extract[0] / 10,</a>
<a name="ln773">              G.crec.version_needed_to_extract[0] % 10,</a>
<a name="ln774">              UNZIP_VERSION / 10, UNZIP_VERSION % 10));</a>
<a name="ln775">        return 0;</a>
<a name="ln776">    }</a>
<a name="ln777"> </a>
<a name="ln778">    if UNKN_COMPR {</a>
<a name="ln779">        if (!((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2))) {</a>
<a name="ln780">#ifndef SFX</a>
<a name="ln781">            if (G.crec.compression_method &lt; NUM_METHODS)</a>
<a name="ln782">                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgName),</a>
<a name="ln783">                  FnFilter1(G.filename),</a>
<a name="ln784">                  LoadFarStringSmall(ComprNames[G.crec.compression_method])));</a>
<a name="ln785">            else</a>
<a name="ln786">#endif</a>
<a name="ln787">                Info(slide, 0x401, ((char *)slide, LoadFarString(ComprMsgNum),</a>
<a name="ln788">                  FnFilter1(G.filename),</a>
<a name="ln789">                  G.crec.compression_method));</a>
<a name="ln790">        }</a>
<a name="ln791">        return 0;</a>
<a name="ln792">    }</a>
<a name="ln793">#if (!CRYPT)</a>
<a name="ln794">    if (G.pInfo-&gt;encrypted) {</a>
<a name="ln795">        if (!((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2)))</a>
<a name="ln796">            Info(slide, 0x401, ((char *)slide, LoadFarString(SkipEncrypted),</a>
<a name="ln797">              FnFilter1(G.filename)));</a>
<a name="ln798">        return 0;</a>
<a name="ln799">    }</a>
<a name="ln800">#endif /* !CRYPT */</a>
<a name="ln801"> </a>
<a name="ln802">    /* map whatever file attributes we have into the local format */</a>
<a name="ln803">    mapattr(__G);   /* GRR:  worry about return value later */</a>
<a name="ln804"> </a>
<a name="ln805">    G.pInfo-&gt;diskstart = G.crec.disk_number_start;</a>
<a name="ln806">    G.pInfo-&gt;offset = (long)G.crec.relative_offset_local_header;</a>
<a name="ln807">    return 1;</a>
<a name="ln808"> </a>
<a name="ln809">} /* end function store_info() */</a>
<a name="ln810"> </a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814"> </a>
<a name="ln815">/******************************************/</a>
<a name="ln816">/*  Function extract_or_test_entrylist()  */</a>
<a name="ln817">/******************************************/</a>
<a name="ln818"> </a>
<a name="ln819">static int extract_or_test_entrylist(__G__ numchunk,</a>
<a name="ln820">                pfilnum, pnum_bad_pwd, pold_extra_bytes,</a>
<a name="ln821">#ifdef SET_DIR_ATTRIB</a>
<a name="ln822">                pnum_dirs, pdirlist,</a>
<a name="ln823">#endif</a>
<a name="ln824">                error_in_archive)    /* return PK-type error code */</a>
<a name="ln825">    __GDEF</a>
<a name="ln826">    unsigned numchunk;</a>
<a name="ln827">    ulg *pfilnum;</a>
<a name="ln828">    ulg *pnum_bad_pwd;</a>
<a name="ln829">    LONGINT *pold_extra_bytes;</a>
<a name="ln830">#ifdef SET_DIR_ATTRIB</a>
<a name="ln831">    unsigned *pnum_dirs;</a>
<a name="ln832">    dirtime **pdirlist;</a>
<a name="ln833">#endif</a>
<a name="ln834">    int error_in_archive;</a>
<a name="ln835">{</a>
<a name="ln836">    unsigned i;</a>
<a name="ln837">    int renamed, query;</a>
<a name="ln838">    int skip_entry;</a>
<a name="ln839">    long bufstart, inbuf_offset, request;</a>
<a name="ln840">    int error, errcode;</a>
<a name="ln841"> </a>
<a name="ln842">/* possible values for local skip_entry flag: */</a>
<a name="ln843">#define SKIP_NO         0       /* do not skip this entry */</a>
<a name="ln844">#define SKIP_Y_EXISTING 1       /* skip this entry, do not overwrite file */</a>
<a name="ln845">#define SKIP_Y_NONEXIST 2       /* skip this entry, do not create new file */</a>
<a name="ln846"> </a>
<a name="ln847">    /*-----------------------------------------------------------------------</a>
<a name="ln848">        Second loop:  process files in current block, extracting or testing</a>
<a name="ln849">        each one.</a>
<a name="ln850">      -----------------------------------------------------------------------*/</a>
<a name="ln851"> </a>
<a name="ln852">    for (i = 0; i &lt; numchunk; ++i) {</a>
<a name="ln853">        (*pfilnum)++;   /* *pfilnum = i + blknum*DIR_BLKSIZ + 1; */</a>
<a name="ln854">        G.pInfo = &amp;G.info[i];</a>
<a name="ln855">#ifdef NOVELL_BUG_FAILSAFE</a>
<a name="ln856">        G.dne = FALSE;  /* assume file exists until stat() says otherwise */</a>
<a name="ln857">#endif</a>
<a name="ln858"> </a>
<a name="ln859">        /* if the target position is not within the current input buffer</a>
<a name="ln860">         * (either haven't yet read far enough, or (maybe) skipping back-</a>
<a name="ln861">         * ward), skip to the target position and reset readbuf(). */</a>
<a name="ln862"> </a>
<a name="ln863">        /* seek_zipf(__G__ pInfo-&gt;offset);  */</a>
<a name="ln864">        request = G.pInfo-&gt;offset + G.extra_bytes;</a>
<a name="ln865">        inbuf_offset = request % INBUFSIZ;</a>
<a name="ln866">        bufstart = request - inbuf_offset;</a>
<a name="ln867"> </a>
<a name="ln868">        Trace((stderr, &quot;\ndebug: request = %ld, inbuf_offset = %ld\n&quot;,</a>
<a name="ln869">          request, inbuf_offset));</a>
<a name="ln870">        Trace((stderr,</a>
<a name="ln871">          &quot;debug: bufstart = %ld, cur_zipfile_bufstart = %ld\n&quot;,</a>
<a name="ln872">          bufstart, G.cur_zipfile_bufstart));</a>
<a name="ln873">        if (request &lt; 0) {</a>
<a name="ln874">            Info(slide, 0x401, ((char *)slide, LoadFarStringSmall(SeekMsg),</a>
<a name="ln875">              G.zipfn, LoadFarString(ReportMsg)));</a>
<a name="ln876">            error_in_archive = PK_ERR;</a>
<a name="ln877">            if (*pfilnum == 1 &amp;&amp; G.extra_bytes != 0L) {</a>
<a name="ln878">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln879">                  LoadFarString(AttemptRecompensate)));</a>
<a name="ln880">                *pold_extra_bytes = G.extra_bytes;</a>
<a name="ln881">                G.extra_bytes = 0L;</a>
<a name="ln882">                request = G.pInfo-&gt;offset;  /* could also check if != 0 */</a>
<a name="ln883">                inbuf_offset = request % INBUFSIZ;</a>
<a name="ln884">                bufstart = request - inbuf_offset;</a>
<a name="ln885">                Trace((stderr, &quot;debug: request = %ld, inbuf_offset = %ld\n&quot;,</a>
<a name="ln886">                  request, inbuf_offset));</a>
<a name="ln887">                Trace((stderr,</a>
<a name="ln888">                  &quot;debug: bufstart = %ld, cur_zipfile_bufstart = %ld\n&quot;,</a>
<a name="ln889">                  bufstart, G.cur_zipfile_bufstart));</a>
<a name="ln890">                /* try again */</a>
<a name="ln891">                if (request &lt; 0) {</a>
<a name="ln892">                    Trace((stderr,</a>
<a name="ln893">                      &quot;debug: recompensated request still &lt; 0\n&quot;));</a>
<a name="ln894">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln895">                      LoadFarStringSmall(SeekMsg),</a>
<a name="ln896">                      G.zipfn, LoadFarString(ReportMsg)));</a>
<a name="ln897">                    error_in_archive = PK_BADERR;</a>
<a name="ln898">                    continue;</a>
<a name="ln899">                }</a>
<a name="ln900">            } else {</a>
<a name="ln901">                error_in_archive = PK_BADERR;</a>
<a name="ln902">                continue;  /* this one hosed; try next */</a>
<a name="ln903">            }</a>
<a name="ln904">        }</a>
<a name="ln905"> </a>
<a name="ln906">        if (bufstart != G.cur_zipfile_bufstart) {</a>
<a name="ln907">            Trace((stderr, &quot;debug: bufstart != cur_zipfile_bufstart\n&quot;));</a>
<a name="ln908">#ifdef USE_STRM_INPUT</a>
<a name="ln909">            fseek((FILE *)G.zipfd, (LONGINT)bufstart, SEEK_SET);</a>
<a name="ln910">            G.cur_zipfile_bufstart = ftell((FILE *)G.zipfd);</a>
<a name="ln911">#else /* !USE_STRM_INPUT */</a>
<a name="ln912">            G.cur_zipfile_bufstart =</a>
<a name="ln913">              lseek(G.zipfd, (LONGINT)bufstart, SEEK_SET);</a>
<a name="ln914">#endif /* ?USE_STRM_INPUT */</a>
<a name="ln915">            if ((G.incnt = read(G.zipfd,(char *)G.inbuf,INBUFSIZ)) &lt;= 0)</a>
<a name="ln916">            {</a>
<a name="ln917">                Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),</a>
<a name="ln918">                  *pfilnum, &quot;lseek&quot;, bufstart));</a>
<a name="ln919">                error_in_archive = PK_BADERR;</a>
<a name="ln920">                continue;   /* can still do next file */</a>
<a name="ln921">            }</a>
<a name="ln922">            G.inptr = G.inbuf + (int)inbuf_offset;</a>
<a name="ln923">            G.incnt -= (int)inbuf_offset;</a>
<a name="ln924">        } else {</a>
<a name="ln925">            G.incnt += (int)(G.inptr-G.inbuf) - (int)inbuf_offset;</a>
<a name="ln926">            G.inptr = G.inbuf + (int)inbuf_offset;</a>
<a name="ln927">        }</a>
<a name="ln928"> </a>
<a name="ln929">        /* should be in proper position now, so check for sig */</a>
<a name="ln930">        if (readbuf(__G__ G.sig, 4) == 0) {  /* bad offset */</a>
<a name="ln931">            Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),</a>
<a name="ln932">              *pfilnum, &quot;EOF&quot;, request));</a>
<a name="ln933">            error_in_archive = PK_BADERR;</a>
<a name="ln934">            continue;   /* but can still try next one */</a>
<a name="ln935">        }</a>
<a name="ln936">        if (strncmp(G.sig, local_hdr_sig, 4)) {</a>
<a name="ln937">            Info(slide, 0x401, ((char *)slide, LoadFarString(OffsetMsg),</a>
<a name="ln938">              *pfilnum, LoadFarStringSmall(LocalHdrSig), request));</a>
<a name="ln939">            /*</a>
<a name="ln940">                GRRDUMP(G.sig, 4)</a>
<a name="ln941">                GRRDUMP(local_hdr_sig, 4)</a>
<a name="ln942">             */</a>
<a name="ln943">            error_in_archive = PK_ERR;</a>
<a name="ln944">            if ((*pfilnum == 1 &amp;&amp; G.extra_bytes != 0L) ||</a>
<a name="ln945">                (G.extra_bytes == 0L &amp;&amp; *pold_extra_bytes != 0L)) {</a>
<a name="ln946">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln947">                  LoadFarString(AttemptRecompensate)));</a>
<a name="ln948">                if (G.extra_bytes) {</a>
<a name="ln949">                    *pold_extra_bytes = G.extra_bytes;</a>
<a name="ln950">                    G.extra_bytes = 0L;</a>
<a name="ln951">                } else</a>
<a name="ln952">                    G.extra_bytes = *pold_extra_bytes; /* third attempt */</a>
<a name="ln953">                if (((error = seek_zipf(__G__ G.pInfo-&gt;offset)) != PK_OK) ||</a>
<a name="ln954">                    (readbuf(__G__ G.sig, 4) == 0)) {  /* bad offset */</a>
<a name="ln955">                    if (error != PK_BADERR)</a>
<a name="ln956">                      Info(slide, 0x401, ((char *)slide,</a>
<a name="ln957">                        LoadFarString(OffsetMsg), *pfilnum, &quot;EOF&quot;, request));</a>
<a name="ln958">                    error_in_archive = PK_BADERR;</a>
<a name="ln959">                    continue;   /* but can still try next one */</a>
<a name="ln960">                }</a>
<a name="ln961">                if (strncmp(G.sig, local_hdr_sig, 4)) {</a>
<a name="ln962">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln963">                      LoadFarString(OffsetMsg), *pfilnum,</a>
<a name="ln964">                      LoadFarStringSmall(LocalHdrSig), request));</a>
<a name="ln965">                    error_in_archive = PK_BADERR;</a>
<a name="ln966">                    continue;</a>
<a name="ln967">                }</a>
<a name="ln968">            } else</a>
<a name="ln969">                continue;  /* this one hosed; try next */</a>
<a name="ln970">        }</a>
<a name="ln971">        if ((error = process_local_file_hdr(__G)) != PK_COOL) {</a>
<a name="ln972">            Info(slide, 0x421, ((char *)slide, LoadFarString(BadLocalHdr),</a>
<a name="ln973">              *pfilnum));</a>
<a name="ln974">            error_in_archive = error;   /* only PK_EOF defined */</a>
<a name="ln975">            continue;   /* can still try next one */</a>
<a name="ln976">        }</a>
<a name="ln977">        if ((error = do_string(__G__ G.lrec.filename_length, DS_FN_L)) !=</a>
<a name="ln978">             PK_COOL)</a>
<a name="ln979">        {</a>
<a name="ln980">            if (error &gt; error_in_archive)</a>
<a name="ln981">                error_in_archive = error;</a>
<a name="ln982">            if (error &gt; PK_WARN) {</a>
<a name="ln983">                Info(slide, 0x401, ((char *)slide, LoadFarString(FilNamMsg),</a>
<a name="ln984">                  FnFilter1(G.filename), &quot;local&quot;));</a>
<a name="ln985">                continue;   /* go on to next one */</a>
<a name="ln986">            }</a>
<a name="ln987">        }</a>
<a name="ln988">        if (G.extra_field != (uch *)NULL) {</a>
<a name="ln989">            free(G.extra_field);</a>
<a name="ln990">            G.extra_field = (uch *)NULL;</a>
<a name="ln991">        }</a>
<a name="ln992">        if ((error =</a>
<a name="ln993">             do_string(__G__ G.lrec.extra_field_length, EXTRA_FIELD)) != 0)</a>
<a name="ln994">        {</a>
<a name="ln995">            if (error &gt; error_in_archive)</a>
<a name="ln996">                error_in_archive = error;</a>
<a name="ln997">            if (error &gt; PK_WARN) {</a>
<a name="ln998">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln999">                  LoadFarString(ExtFieldMsg),</a>
<a name="ln1000">                  FnFilter1(G.filename), &quot;local&quot;));</a>
<a name="ln1001">                continue;   /* go on */</a>
<a name="ln1002">            }</a>
<a name="ln1003">        }</a>
<a name="ln1004"> </a>
<a name="ln1005">#if CRYPT</a>
<a name="ln1006">        if (G.pInfo-&gt;encrypted &amp;&amp;</a>
<a name="ln1007">            (error = decrypt(__G__ uO.pwdarg)) != PK_COOL) {</a>
<a name="ln1008">            if (error == PK_WARN) {</a>
<a name="ln1009">                if (!((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2)))</a>
<a name="ln1010">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1011">                      LoadFarString(SkipIncorrectPasswd),</a>
<a name="ln1012">                      FnFilter1(G.filename)));</a>
<a name="ln1013">                ++(*pnum_bad_pwd);</a>
<a name="ln1014">            } else {  /* (error &gt; PK_WARN) */</a>
<a name="ln1015">                if (error &gt; error_in_archive)</a>
<a name="ln1016">                    error_in_archive = error;</a>
<a name="ln1017">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1018">                  LoadFarString(SkipCannotGetPasswd),</a>
<a name="ln1019">                  FnFilter1(G.filename)));</a>
<a name="ln1020">            }</a>
<a name="ln1021">            continue;   /* go on to next file */</a>
<a name="ln1022">        }</a>
<a name="ln1023">#endif /* CRYPT */</a>
<a name="ln1024"> </a>
<a name="ln1025">        /*</a>
<a name="ln1026">         * just about to extract file:  if extracting to disk, check if</a>
<a name="ln1027">         * already exists, and if so, take appropriate action according to</a>
<a name="ln1028">         * fflag/uflag/overwrite_all/etc. (we couldn't do this in upper</a>
<a name="ln1029">         * loop because we don't store the possibly renamed filename[] in</a>
<a name="ln1030">         * info[])</a>
<a name="ln1031">         */</a>
<a name="ln1032">#ifdef DLL</a>
<a name="ln1033">        if (!uO.tflag &amp;&amp; !uO.cflag &amp;&amp; !G.redirect_data)</a>
<a name="ln1034">#else</a>
<a name="ln1035">        if (!uO.tflag &amp;&amp; !uO.cflag)</a>
<a name="ln1036">#endif</a>
<a name="ln1037">        {</a>
<a name="ln1038">            renamed = FALSE;   /* user hasn't renamed output file yet */</a>
<a name="ln1039"> </a>
<a name="ln1040">startover:</a>
<a name="ln1041">            query = FALSE;</a>
<a name="ln1042">            skip_entry = SKIP_NO;</a>
<a name="ln1043">            /* for files from DOS FAT, check for use of backslash instead</a>
<a name="ln1044">             *  of slash as directory separator (bug in some zipper(s); so</a>
<a name="ln1045">             *  far, not a problem in HPFS, NTFS or VFAT systems)</a>
<a name="ln1046">             */</a>
<a name="ln1047">#ifndef SFX</a>
<a name="ln1048">            if (G.pInfo-&gt;hostnum == FS_FAT_ &amp;&amp; !MBSCHR(G.filename, '/')) {</a>
<a name="ln1049">                char *p=G.filename;</a>
<a name="ln1050"> </a>
<a name="ln1051">                if (*p) do {</a>
<a name="ln1052">                    if (*p == '\\') {</a>
<a name="ln1053">                        if (!G.reported_backslash) {</a>
<a name="ln1054">                            Info(slide, 0x21, ((char *)slide,</a>
<a name="ln1055">                              LoadFarString(BackslashPathSep), G.zipfn));</a>
<a name="ln1056">                            G.reported_backslash = TRUE;</a>
<a name="ln1057">                            if (!error_in_archive)</a>
<a name="ln1058">                                error_in_archive = PK_WARN;</a>
<a name="ln1059">                        }</a>
<a name="ln1060">                        *p = '/';</a>
<a name="ln1061">                    }</a>
<a name="ln1062">                } while (*PREINCSTR(p));</a>
<a name="ln1063">            }</a>
<a name="ln1064">#endif /* !SFX */</a>
<a name="ln1065"> </a>
<a name="ln1066">            if (!renamed) {</a>
<a name="ln1067">               /* remove absolute path specs */</a>
<a name="ln1068">               if (G.filename[0] == '/') {</a>
<a name="ln1069">                   Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1070">                        LoadFarString(AbsolutePathWarning),</a>
<a name="ln1071">                        FnFilter1(G.filename)));</a>
<a name="ln1072">                   if (!error_in_archive)</a>
<a name="ln1073">                       error_in_archive = PK_WARN;</a>
<a name="ln1074">                   do {</a>
<a name="ln1075">                       char *p = G.filename + 1;</a>
<a name="ln1076">                       do {</a>
<a name="ln1077">                           *(p-1) = *p;</a>
<a name="ln1078">                       } while (*p++ != '\0');</a>
<a name="ln1079">                   } while (G.filename[0] == '/');</a>
<a name="ln1080">               }</a>
<a name="ln1081">            }</a>
<a name="ln1082"> </a>
<a name="ln1083">            /* mapname can create dirs if not freshening or if renamed */</a>
<a name="ln1084">            error = mapname(__G__ renamed);</a>
<a name="ln1085">            if ((errcode = error &amp; ~MPN_MASK) != PK_OK &amp;&amp;</a>
<a name="ln1086">                error_in_archive &lt; errcode)</a>
<a name="ln1087">                error_in_archive = errcode;</a>
<a name="ln1088">            if ((errcode = error &amp; MPN_MASK) &gt; MPN_INF_TRUNC) {</a>
<a name="ln1089">                if (errcode == MPN_CREATED_DIR) {</a>
<a name="ln1090">#ifdef SET_DIR_ATTRIB</a>
<a name="ln1091">                    dirtime *d_entry;</a>
<a name="ln1092"> </a>
<a name="ln1093">                    d_entry = (dirtime *)malloc(sizeof(dirtime));</a>
<a name="ln1094">                    if (d_entry == (dirtime *)NULL) {</a>
<a name="ln1095">                        Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1096">                             LoadFarString(DirlistEntryNoMem)));</a>
<a name="ln1097">                    } else {</a>
<a name="ln1098">                        unsigned eb_izux_flg;</a>
<a name="ln1099"> </a>
<a name="ln1100">                        d_entry-&gt;next = (*pdirlist);</a>
<a name="ln1101">                        (*pdirlist) = d_entry;</a>
<a name="ln1102">                        (*pdirlist)-&gt;fn =</a>
<a name="ln1103">                          (char *)malloc(strlen(G.filename) + 1);</a>
<a name="ln1104">                        if ((*pdirlist)-&gt;fn == (char *)NULL) {</a>
<a name="ln1105">                            Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1106">                              LoadFarString(DirlistEntryNoMem)));</a>
<a name="ln1107">                            (*pdirlist) = d_entry-&gt;next;</a>
<a name="ln1108">                            free(d_entry);</a>
<a name="ln1109">                            if (!error_in_archive)</a>
<a name="ln1110">                                error_in_archive = PK_WARN;</a>
<a name="ln1111">                            continue;</a>
<a name="ln1112">                        }</a>
<a name="ln1113">                        strcpy((*pdirlist)-&gt;fn, G.filename);</a>
<a name="ln1114">                        (*pdirlist)-&gt;perms = G.pInfo-&gt;file_attr;</a>
<a name="ln1115">#ifdef USE_EF_UT_TIME</a>
<a name="ln1116">                        eb_izux_flg = G.extra_field? ef_scan_for_izux(</a>
<a name="ln1117">                          G.extra_field, G.lrec.extra_field_length, 0,</a>
<a name="ln1118">                          G.lrec.last_mod_dos_datetime,</a>
<a name="ln1119">#ifdef IZ_CHECK_TZ</a>
<a name="ln1120">                          (G.tz_is_valid ? &amp;((*pdirlist)-&gt;u.t3) : NULL),</a>
<a name="ln1121">#else</a>
<a name="ln1122">                          &amp;((*pdirlist)-&gt;u.t3),</a>
<a name="ln1123">#endif</a>
<a name="ln1124">                          (*pdirlist)-&gt;uidgid)</a>
<a name="ln1125">                          : 0;</a>
<a name="ln1126">#else /* !USE_EF_UT_TIME */</a>
<a name="ln1127">                        eb_izux_flg = 0;</a>
<a name="ln1128">#endif /* ?USE_EF_UT_TIME */</a>
<a name="ln1129">                        if (eb_izux_flg &amp; EB_UT_FL_MTIME) {</a>
<a name="ln1130">                            TTrace((stderr,</a>
<a name="ln1131">                              &quot;\nextract:  Unix dir e.f. modtime = %ld\n&quot;,</a>
<a name="ln1132">                              (*pdirlist)-&gt;u.t3.mtime));</a>
<a name="ln1133">                        } else {</a>
<a name="ln1134">                            (*pdirlist)-&gt;u.t3.mtime = dos_to_unix_time(</a>
<a name="ln1135">                              G.lrec.last_mod_dos_datetime);</a>
<a name="ln1136">                        }</a>
<a name="ln1137">                        if (eb_izux_flg &amp; EB_UT_FL_ATIME) {</a>
<a name="ln1138">                            TTrace((stderr,</a>
<a name="ln1139">                              &quot;\nextract:  Unix dir e.f. actime = %ld\n&quot;,</a>
<a name="ln1140">                              (*pdirlist)-&gt;u.t3.atime));</a>
<a name="ln1141">                        } else {</a>
<a name="ln1142">                            (*pdirlist)-&gt;u.t3.atime =</a>
<a name="ln1143">                              (*pdirlist)-&gt;u.t3.mtime;</a>
<a name="ln1144">                        }</a>
<a name="ln1145">                        (*pdirlist)-&gt;have_uidgid =</a>
<a name="ln1146">#ifdef RESTORE_UIDGID</a>
<a name="ln1147">                            (uO.X_flag &amp;&amp; (eb_izux_flg &amp; EB_UX2_VALID));</a>
<a name="ln1148">#else</a>
<a name="ln1149">                            0;</a>
<a name="ln1150">#endif</a>
<a name="ln1151">                        ++(*pnum_dirs);</a>
<a name="ln1152">                    }</a>
<a name="ln1153">#endif /* SET_DIR_ATTRIB */</a>
<a name="ln1154">                } else if (errcode == MPN_VOL_LABEL) {</a>
<a name="ln1155">#ifdef DOS_OS2_W32</a>
<a name="ln1156">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1157">                      LoadFarString(SkipVolumeLabel),</a>
<a name="ln1158">                      FnFilter1(G.filename),</a>
<a name="ln1159">                      uO.volflag? &quot;hard disk &quot; : &quot;&quot;));</a>
<a name="ln1160">#else</a>
<a name="ln1161">                    Info(slide, 1, ((char *)slide,</a>
<a name="ln1162">                      LoadFarString(SkipVolumeLabel),</a>
<a name="ln1163">                      FnFilter1(G.filename), &quot;&quot;));</a>
<a name="ln1164">#endif</a>
<a name="ln1165">                } else if (errcode &gt; MPN_INF_SKIP &amp;&amp;</a>
<a name="ln1166">                           error_in_archive &lt; PK_ERR)</a>
<a name="ln1167">                    error_in_archive = PK_ERR;</a>
<a name="ln1168">                Trace((stderr, &quot;mapname(%s) returns error code = %d\n&quot;,</a>
<a name="ln1169">                  FnFilter1(G.filename), error));</a>
<a name="ln1170">                continue;   /* go on to next file */</a>
<a name="ln1171">            }</a>
<a name="ln1172"> </a>
<a name="ln1173">#ifdef QDOS</a>
<a name="ln1174">            QFilename(__G__ G.filename);</a>
<a name="ln1175">#endif</a>
<a name="ln1176">            switch (check_for_newer(__G__ G.filename)) {</a>
<a name="ln1177">                case DOES_NOT_EXIST:</a>
<a name="ln1178">#ifdef NOVELL_BUG_FAILSAFE</a>
<a name="ln1179">                    G.dne = TRUE;   /* stat() says file DOES NOT EXIST */</a>
<a name="ln1180">#endif</a>
<a name="ln1181">                    /* freshen (no new files): skip unless just renamed */</a>
<a name="ln1182">                    if (uO.fflag &amp;&amp; !renamed)</a>
<a name="ln1183">                        skip_entry = SKIP_Y_NONEXIST;</a>
<a name="ln1184">                    break;</a>
<a name="ln1185">                case EXISTS_AND_OLDER:</a>
<a name="ln1186">#ifdef UNIXBACKUP</a>
<a name="ln1187">                    if (!uO.B_flag)</a>
<a name="ln1188">#endif</a>
<a name="ln1189">                    {</a>
<a name="ln1190">                        if (IS_OVERWRT_NONE)</a>
<a name="ln1191">                            /* never overwrite:  skip file */</a>
<a name="ln1192">                            skip_entry = SKIP_Y_EXISTING;</a>
<a name="ln1193">                        else if (!IS_OVERWRT_ALL)</a>
<a name="ln1194">                            query = TRUE;</a>
<a name="ln1195">                    }</a>
<a name="ln1196">                    break;</a>
<a name="ln1197">                case EXISTS_AND_NEWER:             /* (or equal) */</a>
<a name="ln1198">#ifdef UNIXBACKUP</a>
<a name="ln1199">                    if ((!uO.B_flag &amp;&amp; IS_OVERWRT_NONE) ||</a>
<a name="ln1200">#else</a>
<a name="ln1201">                    if (IS_OVERWRT_NONE ||</a>
<a name="ln1202">#endif</a>
<a name="ln1203">                        (uO.uflag &amp;&amp; !renamed)) {</a>
<a name="ln1204">                        /* skip if update/freshen &amp; orig name */</a>
<a name="ln1205">                        skip_entry = SKIP_Y_EXISTING;</a>
<a name="ln1206">                    } else {</a>
<a name="ln1207">#ifdef UNIXBACKUP</a>
<a name="ln1208">                        if (!IS_OVERWRT_ALL &amp;&amp; !uO.B_flag)</a>
<a name="ln1209">#else</a>
<a name="ln1210">                        if (!IS_OVERWRT_ALL)</a>
<a name="ln1211">#endif</a>
<a name="ln1212">                            query = TRUE;</a>
<a name="ln1213">                    }</a>
<a name="ln1214">                    break;</a>
<a name="ln1215">                }</a>
<a name="ln1216">            if (query) {</a>
<a name="ln1217">#ifdef WINDLL</a>
<a name="ln1218">                switch (G.lpUserFunctions-&gt;replace != NULL ?</a>
<a name="ln1219">                        (*G.lpUserFunctions-&gt;replace)(G.filename) :</a>
<a name="ln1220">                        IDM_REPLACE_NONE) {</a>
<a name="ln1221">                    case IDM_REPLACE_RENAME:</a>
<a name="ln1222">                        _ISO_INTERN(G.filename);</a>
<a name="ln1223">                        renamed = TRUE;</a>
<a name="ln1224">                        goto startover;</a>
<a name="ln1225">                    case IDM_REPLACE_ALL:</a>
<a name="ln1226">                        G.overwrite_mode = OVERWRT_ALWAYS;</a>
<a name="ln1227">                        /* FALL THROUGH, extract */</a>
<a name="ln1228">                    case IDM_REPLACE_YES:</a>
<a name="ln1229">                        break;</a>
<a name="ln1230">                    case IDM_REPLACE_NONE:</a>
<a name="ln1231">                        G.overwrite_mode = OVERWRT_NEVER;</a>
<a name="ln1232">                        /* FALL THROUGH, skip */</a>
<a name="ln1233">                    case IDM_REPLACE_NO:</a>
<a name="ln1234">                        skip_entry = SKIP_Y_EXISTING;</a>
<a name="ln1235">                        break;</a>
<a name="ln1236">                }</a>
<a name="ln1237">#else /* !WINDLL */</a>
<a name="ln1238">                extent fnlen;</a>
<a name="ln1239">reprompt:</a>
<a name="ln1240">                Info(slide, 0x81, ((char *)slide,</a>
<a name="ln1241">                  LoadFarString(ReplaceQuery),</a>
<a name="ln1242">                  FnFilter1(G.filename)));</a>
<a name="ln1243">                if (fgets(G.answerbuf, 9, stdin) == (char *)NULL) {</a>
<a name="ln1244">                    Info(slide, 1, ((char *)slide,</a>
<a name="ln1245">                      LoadFarString(AssumeNone)));</a>
<a name="ln1246">                    *G.answerbuf = 'N';</a>
<a name="ln1247">                    if (!error_in_archive)</a>
<a name="ln1248">                        error_in_archive = 1;  /* not extracted:  warning */</a>
<a name="ln1249">                }</a>
<a name="ln1250">                switch (*G.answerbuf) {</a>
<a name="ln1251">                    case 'r':</a>
<a name="ln1252">                    case 'R':</a>
<a name="ln1253">                        do {</a>
<a name="ln1254">                            Info(slide, 0x81, ((char *)slide,</a>
<a name="ln1255">                              LoadFarString(NewNameQuery)));</a>
<a name="ln1256">                            fgets(G.filename, FILNAMSIZ, stdin);</a>
<a name="ln1257">                            /* usually get \n here:  better check for it */</a>
<a name="ln1258">                            fnlen = strlen(G.filename);</a>
<a name="ln1259">                            if (lastchar(G.filename, fnlen) == '\n')</a>
<a name="ln1260">                                G.filename[--fnlen] = '\0';</a>
<a name="ln1261">                        } while (fnlen == 0);</a>
<a name="ln1262">#ifdef WIN32  /* WIN32 fgets( ... , stdin) returns OEM coded strings */</a>
<a name="ln1263">                        _OEM_INTERN(G.filename);</a>
<a name="ln1264">#endif</a>
<a name="ln1265">                        renamed = TRUE;</a>
<a name="ln1266">                        goto startover;   /* sorry for a goto */</a>
<a name="ln1267">                    case 'A':   /* dangerous option:  force caps */</a>
<a name="ln1268">                        G.overwrite_mode = OVERWRT_ALWAYS;</a>
<a name="ln1269">                        /* FALL THROUGH, extract */</a>
<a name="ln1270">                    case 'y':</a>
<a name="ln1271">                    case 'Y':</a>
<a name="ln1272">                        break;</a>
<a name="ln1273">                    case 'N':</a>
<a name="ln1274">                        G.overwrite_mode = OVERWRT_NEVER;</a>
<a name="ln1275">                        /* FALL THROUGH, skip */</a>
<a name="ln1276">                    case 'n':</a>
<a name="ln1277">                        /* skip file */</a>
<a name="ln1278">                        skip_entry = SKIP_Y_EXISTING;</a>
<a name="ln1279">                        break;</a>
<a name="ln1280">                    default:</a>
<a name="ln1281">                        Info(slide, 1, ((char *)slide,</a>
<a name="ln1282">                          LoadFarString(InvalidResponse), *G.answerbuf));</a>
<a name="ln1283">                        goto reprompt;   /* yet another goto? */</a>
<a name="ln1284">                } /* end switch (*answerbuf) */</a>
<a name="ln1285">#endif /* ?WINDLL */</a>
<a name="ln1286">            } /* end if (query) */</a>
<a name="ln1287">            if (skip_entry != SKIP_NO) {</a>
<a name="ln1288">#ifdef WINDLL</a>
<a name="ln1289">                if (skip_entry == SKIP_Y_EXISTING) {</a>
<a name="ln1290">                    /* report skipping of an existing entry */</a>
<a name="ln1291">                    Info(slide, 0, ((char *)slide,</a>
<a name="ln1292">                      ((IS_OVERWRT_NONE || !uO.uflag || renamed) ?</a>
<a name="ln1293">                       &quot;Target file exists.\nSkipping %s\n&quot; :</a>
<a name="ln1294">                       &quot;Target file newer.\nSkipping %s\n&quot;),</a>
<a name="ln1295">                      FnFilter1(G.filename)));</a>
<a name="ln1296">                }</a>
<a name="ln1297">#endif /* WINDLL */</a>
<a name="ln1298">                continue;</a>
<a name="ln1299">            }</a>
<a name="ln1300">        } /* end if (extracting to disk) */</a>
<a name="ln1301"> </a>
<a name="ln1302">#ifdef DLL</a>
<a name="ln1303">        if ((G.statreportcb != NULL) &amp;&amp;</a>
<a name="ln1304">            (*G.statreportcb)(__G__ UZ_ST_START_EXTRACT, G.zipfn,</a>
<a name="ln1305">                              G.filename, NULL)) {</a>
<a name="ln1306">            return IZ_CTRLC;        /* cancel operation by user request */</a>
<a name="ln1307">        }</a>
<a name="ln1308">#endif</a>
<a name="ln1309">#ifdef MACOS  /* MacOS is no preemptive OS, thus call event-handling by hand */</a>
<a name="ln1310">        UserStop();</a>
<a name="ln1311">#endif</a>
<a name="ln1312">#ifdef AMIGA</a>
<a name="ln1313">        G.filenote_slot = i;</a>
<a name="ln1314">#endif</a>
<a name="ln1315">        G.disk_full = 0;</a>
<a name="ln1316">        if ((error = extract_or_test_member(__G)) != PK_COOL) {</a>
<a name="ln1317">            if (error &gt; error_in_archive)</a>
<a name="ln1318">                error_in_archive = error;       /* ...and keep going */</a>
<a name="ln1319">#ifdef DLL</a>
<a name="ln1320">            if (G.disk_full &gt; 1 || error_in_archive == IZ_CTRLC) {</a>
<a name="ln1321">#else</a>
<a name="ln1322">            if (G.disk_full &gt; 1) {</a>
<a name="ln1323">#endif</a>
<a name="ln1324">                return error_in_archive;        /* (unless disk full) */</a>
<a name="ln1325">            }</a>
<a name="ln1326">        }</a>
<a name="ln1327">#ifdef DLL</a>
<a name="ln1328">        if ((G.statreportcb != NULL) &amp;&amp;</a>
<a name="ln1329">            (*G.statreportcb)(__G__ UZ_ST_FINISH_MEMBER, G.zipfn,</a>
<a name="ln1330">                              G.filename, (zvoid *)&amp;G.lrec.ucsize)) {</a>
<a name="ln1331">            return IZ_CTRLC;        /* cancel operation by user request */</a>
<a name="ln1332">        }</a>
<a name="ln1333">#endif</a>
<a name="ln1334">#ifdef MACOS  /* MacOS is no preemptive OS, thus call event-handling by hand */</a>
<a name="ln1335">        UserStop();</a>
<a name="ln1336">#endif</a>
<a name="ln1337">    } /* end for-loop (i:  files in current block) */</a>
<a name="ln1338"> </a>
<a name="ln1339">    return error_in_archive;</a>
<a name="ln1340"> </a>
<a name="ln1341">} /* end function extract_or_test_entrylist() */</a>
<a name="ln1342"> </a>
<a name="ln1343"> </a>
<a name="ln1344"> </a>
<a name="ln1345"> </a>
<a name="ln1346"> </a>
<a name="ln1347">/***************************************/</a>
<a name="ln1348">/*  Function extract_or_test_member()  */</a>
<a name="ln1349">/***************************************/</a>
<a name="ln1350"> </a>
<a name="ln1351">static int extract_or_test_member(__G)    /* return PK-type error code */</a>
<a name="ln1352">     __GDEF</a>
<a name="ln1353">{</a>
<a name="ln1354">    char *nul=&quot;[empty] &quot;, *txt=&quot;[text]  &quot;, *bin=&quot;[binary]&quot;;</a>
<a name="ln1355">#ifdef CMS_MVS</a>
<a name="ln1356">    char *ebc=&quot;[ebcdic]&quot;;</a>
<a name="ln1357">#endif</a>
<a name="ln1358">    register int b;</a>
<a name="ln1359">    int r, error=PK_COOL;</a>
<a name="ln1360">#if (defined(DLL) &amp;&amp; !defined(NO_SLIDE_REDIR))</a>
<a name="ln1361">    ulg wsize;</a>
<a name="ln1362">#else</a>
<a name="ln1363">#   define wsize WSIZE</a>
<a name="ln1364">#endif</a>
<a name="ln1365"> </a>
<a name="ln1366"> </a>
<a name="ln1367">/*---------------------------------------------------------------------------</a>
<a name="ln1368">    Initialize variables, buffers, etc.</a>
<a name="ln1369">  ---------------------------------------------------------------------------*/</a>
<a name="ln1370"> </a>
<a name="ln1371">    G.bits_left = 0;</a>
<a name="ln1372">    G.bitbuf = 0L;       /* unreduce and unshrink only */</a>
<a name="ln1373">    G.zipeof = 0;</a>
<a name="ln1374">    G.newfile = TRUE;</a>
<a name="ln1375">    G.crc32val = CRCVAL_INITIAL;</a>
<a name="ln1376"> </a>
<a name="ln1377">#ifdef SYMLINKS</a>
<a name="ln1378">    /* if file came from Unix and is a symbolic link and we are extracting</a>
<a name="ln1379">     * to disk, prepare to restore the link */</a>
<a name="ln1380">    if (S_ISLNK(G.pInfo-&gt;file_attr) &amp;&amp;</a>
<a name="ln1381">        (G.pInfo-&gt;hostnum == UNIX_ || G.pInfo-&gt;hostnum == ATARI_ ||</a>
<a name="ln1382">         G.pInfo-&gt;hostnum == BEOS_) &amp;&amp;</a>
<a name="ln1383">        !uO.tflag &amp;&amp; !uO.cflag &amp;&amp; (G.lrec.ucsize &gt; 0))</a>
<a name="ln1384">        G.symlnk = TRUE;</a>
<a name="ln1385">    else</a>
<a name="ln1386">        G.symlnk = FALSE;</a>
<a name="ln1387">#endif /* SYMLINKS */</a>
<a name="ln1388"> </a>
<a name="ln1389">    if (uO.tflag) {</a>
<a name="ln1390">        if (!uO.qflag)</a>
<a name="ln1391">            Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg), &quot;test&quot;,</a>
<a name="ln1392">              FnFilter1(G.filename), &quot;&quot;, &quot;&quot;));</a>
<a name="ln1393">    } else {</a>
<a name="ln1394">#ifdef DLL</a>
<a name="ln1395">        if (uO.cflag &amp;&amp; !G.redirect_data)</a>
<a name="ln1396">#else</a>
<a name="ln1397">        if (uO.cflag)</a>
<a name="ln1398">#endif</a>
<a name="ln1399">        {</a>
<a name="ln1400">#if (defined(OS2) &amp;&amp; defined(__IBMC__) &amp;&amp; (__IBMC__ &gt;= 200))</a>
<a name="ln1401">            G.outfile = freopen(&quot;&quot;, &quot;wb&quot;, stdout);   /* VAC++ ignores setmode */</a>
<a name="ln1402">#else</a>
<a name="ln1403">            G.outfile = stdout;</a>
<a name="ln1404">#endif</a>
<a name="ln1405">#ifdef DOS_FLX_NLM_OS2_W32</a>
<a name="ln1406">#if (defined(__HIGHC__) &amp;&amp; !defined(FLEXOS))</a>
<a name="ln1407">            setmode(G.outfile, _BINARY);</a>
<a name="ln1408">#else /* !(defined(__HIGHC__) &amp;&amp; !defined(FLEXOS)) */</a>
<a name="ln1409">            setmode(fileno(G.outfile), O_BINARY);</a>
<a name="ln1410">#endif /* ?(defined(__HIGHC__) &amp;&amp; !defined(FLEXOS)) */</a>
<a name="ln1411">#           define NEWLINE &quot;\r\n&quot;</a>
<a name="ln1412">#else /* !DOS_FLX_NLM_OS2_W32 */</a>
<a name="ln1413">#           define NEWLINE &quot;\n&quot;</a>
<a name="ln1414">#endif /* ?DOS_FLX_NLM_OS2_W32 */</a>
<a name="ln1415">#ifdef VMS</a>
<a name="ln1416">            if (open_outfile(__G))   /* VMS:  required even for stdout! */</a>
<a name="ln1417">                return PK_DISK;</a>
<a name="ln1418">#endif</a>
<a name="ln1419">        } else if (open_outfile(__G))</a>
<a name="ln1420">            return PK_DISK;</a>
<a name="ln1421">    }</a>
<a name="ln1422"> </a>
<a name="ln1423">/*---------------------------------------------------------------------------</a>
<a name="ln1424">    Unpack the file.</a>
<a name="ln1425">  ---------------------------------------------------------------------------*/</a>
<a name="ln1426"> </a>
<a name="ln1427">    defer_leftover_input(__G);    /* so NEXTBYTE bounds check will work */</a>
<a name="ln1428">    switch (G.lrec.compression_method) {</a>
<a name="ln1429">        case STORED:</a>
<a name="ln1430">            if (!uO.tflag &amp;&amp; QCOND2) {</a>
<a name="ln1431">#ifdef SYMLINKS</a>
<a name="ln1432">                if (G.symlnk)   /* can also be deflated, but rarer... */</a>
<a name="ln1433">                    Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),</a>
<a name="ln1434">                      &quot;link&quot;, FnFilter1(G.filename), &quot;&quot;, &quot;&quot;));</a>
<a name="ln1435">                else</a>
<a name="ln1436">#endif /* SYMLINKS */</a>
<a name="ln1437">                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),</a>
<a name="ln1438">                  &quot;extract&quot;, FnFilter1(G.filename),</a>
<a name="ln1439">                  (uO.aflag != 1 /* &amp;&amp; G.pInfo-&gt;textfile==G.pInfo-&gt;textmode */)?</a>
<a name="ln1440">                  &quot;&quot; : (G.lrec.ucsize == 0L? nul : (G.pInfo-&gt;textfile? txt :</a>
<a name="ln1441">                  bin)), uO.cflag? NEWLINE : &quot;&quot;));</a>
<a name="ln1442">            }</a>
<a name="ln1443">#if (defined(DLL) &amp;&amp; !defined(NO_SLIDE_REDIR))</a>
<a name="ln1444">            if (G.redirect_slide) {</a>
<a name="ln1445">                wsize = G.redirect_size; redirSlide = G.redirect_buffer;</a>
<a name="ln1446">            } else {</a>
<a name="ln1447">                wsize = WSIZE; redirSlide = slide;</a>
<a name="ln1448">            }</a>
<a name="ln1449">#endif</a>
<a name="ln1450">            G.outptr = redirSlide;</a>
<a name="ln1451">            G.outcnt = 0L;</a>
<a name="ln1452">            while ((b = NEXTBYTE) != EOF) {</a>
<a name="ln1453">                *G.outptr++ = (uch)b;</a>
<a name="ln1454">                if (++G.outcnt == wsize) {</a>
<a name="ln1455">                    error = flush(__G__ redirSlide, G.outcnt, 0);</a>
<a name="ln1456">                    G.outptr = redirSlide;</a>
<a name="ln1457">                    G.outcnt = 0L;</a>
<a name="ln1458">                    if (error != PK_COOL || G.disk_full) break;</a>
<a name="ln1459">                }</a>
<a name="ln1460">            }</a>
<a name="ln1461">            if (G.outcnt)          /* flush final (partial) buffer */</a>
<a name="ln1462">                flush(__G__ redirSlide, G.outcnt, 0);</a>
<a name="ln1463">            break;</a>
<a name="ln1464"> </a>
<a name="ln1465">#ifndef SFX</a>
<a name="ln1466">#ifndef LZW_CLEAN</a>
<a name="ln1467">        case SHRUNK:</a>
<a name="ln1468">            if (!uO.tflag &amp;&amp; QCOND2) {</a>
<a name="ln1469">                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),</a>
<a name="ln1470">                  LoadFarStringSmall(Unshrink), FnFilter1(G.filename),</a>
<a name="ln1471">                  (uO.aflag != 1 /* &amp;&amp; G.pInfo-&gt;textfile==G.pInfo-&gt;textmode */)?</a>
<a name="ln1472">                  &quot;&quot; : (G.pInfo-&gt;textfile? txt : bin), uO.cflag? NEWLINE : &quot;&quot;));</a>
<a name="ln1473">            }</a>
<a name="ln1474">            if ((r = unshrink(__G)) != PK_COOL) {</a>
<a name="ln1475">                if (r &lt; PK_DISK) {</a>
<a name="ln1476">                    if ((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2))</a>
<a name="ln1477">                        Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1478">                          LoadFarStringSmall(ErrUnzipFile),</a>
<a name="ln1479">                          LoadFarString(NotEnoughMem),</a>
<a name="ln1480">                          LoadFarStringSmall2(Unshrink),</a>
<a name="ln1481">                          FnFilter1(G.filename)));</a>
<a name="ln1482">                    else</a>
<a name="ln1483">                        Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1484">                          LoadFarStringSmall(ErrUnzipNoFile),</a>
<a name="ln1485">                          LoadFarString(NotEnoughMem),</a>
<a name="ln1486">                          LoadFarStringSmall2(Unshrink)));</a>
<a name="ln1487">                }</a>
<a name="ln1488">                error = r;</a>
<a name="ln1489">            }</a>
<a name="ln1490">            break;</a>
<a name="ln1491">#endif /* !LZW_CLEAN */</a>
<a name="ln1492"> </a>
<a name="ln1493">#ifndef COPYRIGHT_CLEAN</a>
<a name="ln1494">        case REDUCED1:</a>
<a name="ln1495">        case REDUCED2:</a>
<a name="ln1496">        case REDUCED3:</a>
<a name="ln1497">        case REDUCED4:</a>
<a name="ln1498">            if (!uO.tflag &amp;&amp; QCOND2) {</a>
<a name="ln1499">                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),</a>
<a name="ln1500">                  &quot;unreduc&quot;, FnFilter1(G.filename),</a>
<a name="ln1501">                  (uO.aflag != 1 /* &amp;&amp; G.pInfo-&gt;textfile==G.pInfo-&gt;textmode */)?</a>
<a name="ln1502">                  &quot;&quot; : (G.pInfo-&gt;textfile? txt : bin), uO.cflag? NEWLINE : &quot;&quot;));</a>
<a name="ln1503">            }</a>
<a name="ln1504">            if ((r = unreduce(__G)) != PK_COOL) {</a>
<a name="ln1505">                /* unreduce() returns only PK_COOL, PK_DISK, or IZ_CTRLC */</a>
<a name="ln1506">                error = r;</a>
<a name="ln1507">            }</a>
<a name="ln1508">            break;</a>
<a name="ln1509">#endif /* !COPYRIGHT_CLEAN */</a>
<a name="ln1510"> </a>
<a name="ln1511">        case IMPLODED:</a>
<a name="ln1512">            if (!uO.tflag &amp;&amp; QCOND2) {</a>
<a name="ln1513">                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),</a>
<a name="ln1514">                  &quot;explod&quot;, FnFilter1(G.filename),</a>
<a name="ln1515">                  (uO.aflag != 1 /* &amp;&amp; G.pInfo-&gt;textfile==G.pInfo-&gt;textmode */)?</a>
<a name="ln1516">                  &quot;&quot; : (G.pInfo-&gt;textfile? txt : bin), uO.cflag? NEWLINE : &quot;&quot;));</a>
<a name="ln1517">            }</a>
<a name="ln1518">            if (((r = explode(__G)) != 0) &amp;&amp; (r != 5)) { /* treat 5 specially */</a>
<a name="ln1519">                if (r &lt; PK_DISK) {</a>
<a name="ln1520">                    if ((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2))</a>
<a name="ln1521">                        Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1522">                          LoadFarStringSmall(ErrUnzipFile), r == 3?</a>
<a name="ln1523">                          LoadFarString(NotEnoughMem) :</a>
<a name="ln1524">                          LoadFarString(InvalidComprData),</a>
<a name="ln1525">                          LoadFarStringSmall2(Explode),</a>
<a name="ln1526">                          FnFilter1(G.filename)));</a>
<a name="ln1527">                    else</a>
<a name="ln1528">                        Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1529">                          LoadFarStringSmall(ErrUnzipNoFile), r == 3?</a>
<a name="ln1530">                          LoadFarString(NotEnoughMem) :</a>
<a name="ln1531">                          LoadFarString(InvalidComprData),</a>
<a name="ln1532">                          LoadFarStringSmall2(Explode)));</a>
<a name="ln1533">                    error = (r == 3)? PK_MEM3 : PK_ERR;</a>
<a name="ln1534">                } else {</a>
<a name="ln1535">                    error = r;</a>
<a name="ln1536">                }</a>
<a name="ln1537">            }</a>
<a name="ln1538">            if (r == 5) {</a>
<a name="ln1539">                int warning = ((ulg)G.used_csize &lt;= G.lrec.csize);</a>
<a name="ln1540"> </a>
<a name="ln1541">                if ((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2))</a>
<a name="ln1542">                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),</a>
<a name="ln1543">                      &quot;&quot;, warning?  &quot;warning&quot; : &quot;error&quot;, G.used_csize,</a>
<a name="ln1544">                      G.lrec.ucsize, warning?  &quot;  &quot; : &quot;&quot;, G.lrec.csize,</a>
<a name="ln1545">                      &quot; [&quot;, FnFilter1(G.filename), &quot;]&quot;));</a>
<a name="ln1546">                else</a>
<a name="ln1547">                    Info(slide, 0x401, ((char *)slide, LoadFarString(LengthMsg),</a>
<a name="ln1548">                      &quot;\n&quot;, warning? &quot;warning&quot; : &quot;error&quot;, G.used_csize,</a>
<a name="ln1549">                      G.lrec.ucsize, warning? &quot;  &quot;:&quot;&quot;, G.lrec.csize,</a>
<a name="ln1550">                      &quot;&quot;, &quot;&quot;, &quot;.&quot;));</a>
<a name="ln1551">                error = warning? PK_WARN : PK_ERR;</a>
<a name="ln1552">            }</a>
<a name="ln1553">            break;</a>
<a name="ln1554">#endif /* !SFX */</a>
<a name="ln1555"> </a>
<a name="ln1556">        case DEFLATED:</a>
<a name="ln1557">#ifdef USE_DEFLATE64</a>
<a name="ln1558">        case ENHDEFLATED:</a>
<a name="ln1559">#endif</a>
<a name="ln1560">            if (!uO.tflag &amp;&amp; QCOND2) {</a>
<a name="ln1561">                Info(slide, 0, ((char *)slide, LoadFarString(ExtractMsg),</a>
<a name="ln1562">                  &quot;inflat&quot;, FnFilter1(G.filename),</a>
<a name="ln1563">                  (uO.aflag != 1 /* &amp;&amp; G.pInfo-&gt;textfile==G.pInfo-&gt;textmode */)?</a>
<a name="ln1564">                  &quot;&quot; : (G.pInfo-&gt;textfile? txt : bin), uO.cflag? NEWLINE : &quot;&quot;));</a>
<a name="ln1565">            }</a>
<a name="ln1566">#ifndef USE_ZLIB  /* zlib's function is called inflate(), too */</a>
<a name="ln1567">#  define UZinflate inflate</a>
<a name="ln1568">#endif</a>
<a name="ln1569">            if ((r = UZinflate(__G__</a>
<a name="ln1570">                               (G.lrec.compression_method == ENHDEFLATED)))</a>
<a name="ln1571">                != 0) {</a>
<a name="ln1572">                if (r &lt; PK_DISK) {</a>
<a name="ln1573">                    if ((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2))</a>
<a name="ln1574">                        Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1575">                          LoadFarStringSmall(ErrUnzipFile), r == 3?</a>
<a name="ln1576">                          LoadFarString(NotEnoughMem) :</a>
<a name="ln1577">                          LoadFarString(InvalidComprData),</a>
<a name="ln1578">                          LoadFarStringSmall2(Inflate),</a>
<a name="ln1579">                          FnFilter1(G.filename)));</a>
<a name="ln1580">                    else</a>
<a name="ln1581">                        Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1582">                          LoadFarStringSmall(ErrUnzipNoFile), r == 3?</a>
<a name="ln1583">                          LoadFarString(NotEnoughMem) :</a>
<a name="ln1584">                          LoadFarString(InvalidComprData),</a>
<a name="ln1585">                          LoadFarStringSmall2(Inflate)));</a>
<a name="ln1586">                    error = (r == 3)? PK_MEM3 : PK_ERR;</a>
<a name="ln1587">                } else {</a>
<a name="ln1588">                    error = r;</a>
<a name="ln1589">                }</a>
<a name="ln1590">            }</a>
<a name="ln1591">            break;</a>
<a name="ln1592"> </a>
<a name="ln1593">        default:   /* should never get to this point */</a>
<a name="ln1594">            Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1595">              LoadFarString(FileUnknownCompMethod), FnFilter1(G.filename)));</a>
<a name="ln1596">            /* close and delete file before return? */</a>
<a name="ln1597">            undefer_input(__G);</a>
<a name="ln1598">            return PK_WARN;</a>
<a name="ln1599"> </a>
<a name="ln1600">    } /* end switch (compression method) */</a>
<a name="ln1601"> </a>
<a name="ln1602">/*---------------------------------------------------------------------------</a>
<a name="ln1603">    Close the file and set its date and time (not necessarily in that order),</a>
<a name="ln1604">    and make sure the CRC checked out OK.  Logical-AND the CRC for 64-bit</a>
<a name="ln1605">    machines (redundant on 32-bit machines).</a>
<a name="ln1606">  ---------------------------------------------------------------------------*/</a>
<a name="ln1607"> </a>
<a name="ln1608">#ifdef VMS                  /* VMS:  required even for stdout! (final flush) */</a>
<a name="ln1609">    if (!uO.tflag)           /* don't close NULL file */</a>
<a name="ln1610">        close_outfile(__G);</a>
<a name="ln1611">#else</a>
<a name="ln1612">#ifdef DLL</a>
<a name="ln1613">    if (!uO.tflag &amp;&amp; (!uO.cflag || G.redirect_data)) {</a>
<a name="ln1614">        if (G.redirect_data)</a>
<a name="ln1615">            FINISH_REDIRECT();</a>
<a name="ln1616">        else</a>
<a name="ln1617">            close_outfile(__G);</a>
<a name="ln1618">    }</a>
<a name="ln1619">#else</a>
<a name="ln1620">    if (!uO.tflag &amp;&amp; !uO.cflag)   /* don't close NULL file or stdout */</a>
<a name="ln1621">        close_outfile(__G);</a>
<a name="ln1622">#endif</a>
<a name="ln1623">#endif /* VMS */</a>
<a name="ln1624"> </a>
<a name="ln1625">            /* GRR: CONVERT close_outfile() TO NON-VOID:  CHECK FOR ERRORS! */</a>
<a name="ln1626"> </a>
<a name="ln1627"> </a>
<a name="ln1628">    if (G.disk_full) {            /* set by flush() */</a>
<a name="ln1629">        if (G.disk_full &gt; 1) {</a>
<a name="ln1630">#if (defined(DELETE_IF_FULL) &amp;&amp; defined(HAVE_UNLINK))</a>
<a name="ln1631">            /* delete the incomplete file if we can */</a>
<a name="ln1632">            if (unlink(G.filename) != 0)</a>
<a name="ln1633">                Trace((stderr, &quot;extract.c:  could not delete %s\n&quot;,</a>
<a name="ln1634">                  FnFilter1(G.filename)));</a>
<a name="ln1635">#else</a>
<a name="ln1636">            /* warn user about the incomplete file */</a>
<a name="ln1637">            Info(slide, 0x421, ((char *)slide, LoadFarString(FileTruncated),</a>
<a name="ln1638">              FnFilter1(G.filename)));</a>
<a name="ln1639">#endif</a>
<a name="ln1640">            error = PK_DISK;</a>
<a name="ln1641">        } else {</a>
<a name="ln1642">            error = PK_WARN;</a>
<a name="ln1643">        }</a>
<a name="ln1644">    }</a>
<a name="ln1645"> </a>
<a name="ln1646">    if (error &gt; PK_WARN) {/* don't print redundant CRC error if error already */</a>
<a name="ln1647">        undefer_input(__G);</a>
<a name="ln1648">        return error;</a>
<a name="ln1649">    }</a>
<a name="ln1650">    if (G.crc32val != G.lrec.crc32) {</a>
<a name="ln1651">        /* if quiet enough, we haven't output the filename yet:  do it */</a>
<a name="ln1652">        if ((uO.tflag &amp;&amp; uO.qflag) || (!uO.tflag &amp;&amp; !QCOND2))</a>
<a name="ln1653">            Info(slide, 0x401, ((char *)slide, &quot;%-22s &quot;,</a>
<a name="ln1654">              FnFilter1(G.filename)));</a>
<a name="ln1655">        Info(slide, 0x401, ((char *)slide, LoadFarString(BadCRC), G.crc32val,</a>
<a name="ln1656">          G.lrec.crc32));</a>
<a name="ln1657">#if CRYPT</a>
<a name="ln1658">        if (G.pInfo-&gt;encrypted)</a>
<a name="ln1659">            Info(slide, 0x401, ((char *)slide, LoadFarString(MaybeBadPasswd)));</a>
<a name="ln1660">#endif</a>
<a name="ln1661">        error = PK_ERR;</a>
<a name="ln1662">    } else if (uO.tflag) {</a>
<a name="ln1663">#ifndef SFX</a>
<a name="ln1664">        if (G.extra_field) {</a>
<a name="ln1665">            if ((r = TestExtraField(__G__ G.extra_field,</a>
<a name="ln1666">                                    G.lrec.extra_field_length)) &gt; error)</a>
<a name="ln1667">                error = r;</a>
<a name="ln1668">        } else</a>
<a name="ln1669">#endif /* !SFX */</a>
<a name="ln1670">        if (!uO.qflag)</a>
<a name="ln1671">            Info(slide, 0, ((char *)slide, &quot; OK\n&quot;));</a>
<a name="ln1672">    } else {</a>
<a name="ln1673">        if (QCOND2 &amp;&amp; !error)   /* GRR:  is stdout reset to text mode yet? */</a>
<a name="ln1674">            Info(slide, 0, ((char *)slide, &quot;\n&quot;));</a>
<a name="ln1675">    }</a>
<a name="ln1676"> </a>
<a name="ln1677">    undefer_input(__G);</a>
<a name="ln1678">    return error;</a>
<a name="ln1679"> </a>
<a name="ln1680">} /* end function extract_or_test_member() */</a>
<a name="ln1681"> </a>
<a name="ln1682"> </a>
<a name="ln1683"> </a>
<a name="ln1684"> </a>
<a name="ln1685"> </a>
<a name="ln1686">#ifndef SFX</a>
<a name="ln1687"> </a>
<a name="ln1688">/*******************************/</a>
<a name="ln1689">/*  Function TestExtraField()  */</a>
<a name="ln1690">/*******************************/</a>
<a name="ln1691"> </a>
<a name="ln1692">static int TestExtraField(__G__ ef, ef_len)</a>
<a name="ln1693">    __GDEF</a>
<a name="ln1694">    uch *ef;</a>
<a name="ln1695">    unsigned ef_len;</a>
<a name="ln1696">{</a>
<a name="ln1697">    ush ebID;</a>
<a name="ln1698">    unsigned ebLen;</a>
<a name="ln1699">    unsigned eb_cmpr_offs = 0;</a>
<a name="ln1700">    int r;</a>
<a name="ln1701"> </a>
<a name="ln1702">    /* we know the regular compressed file data tested out OK, or else we</a>
<a name="ln1703">     * wouldn't be here ==&gt; print filename if any extra-field errors found</a>
<a name="ln1704">     */</a>
<a name="ln1705">    while (ef_len &gt;= EB_HEADSIZE) {</a>
<a name="ln1706">        ebID = makeword(ef);</a>
<a name="ln1707">        ebLen = (unsigned)makeword(ef+EB_LEN);</a>
<a name="ln1708"> </a>
<a name="ln1709">        if (ebLen &gt; (ef_len - EB_HEADSIZE)) {</a>
<a name="ln1710">           /* Discovered some extra field inconsistency! */</a>
<a name="ln1711">            if (uO.qflag)</a>
<a name="ln1712">                Info(slide, 1, ((char *)slide, &quot;%-22s &quot;,</a>
<a name="ln1713">                  FnFilter1(G.filename)));</a>
<a name="ln1714">            Info(slide, 1, ((char *)slide, LoadFarString(InconsistEFlength),</a>
<a name="ln1715">              ebLen, (ef_len - EB_HEADSIZE)));</a>
<a name="ln1716">            return PK_ERR;</a>
<a name="ln1717">        }</a>
<a name="ln1718"> </a>
<a name="ln1719">        switch (ebID) {</a>
<a name="ln1720">            case EF_OS2:</a>
<a name="ln1721">            case EF_ACL:</a>
<a name="ln1722">            case EF_MAC3:</a>
<a name="ln1723">            case EF_BEOS:</a>
<a name="ln1724">                switch (ebID) {</a>
<a name="ln1725">                  case EF_OS2:</a>
<a name="ln1726">                  case EF_ACL:</a>
<a name="ln1727">                    eb_cmpr_offs = EB_OS2_HLEN;</a>
<a name="ln1728">                    break;</a>
<a name="ln1729">                  case EF_MAC3:</a>
<a name="ln1730">                    if (ebLen &gt;= EB_MAC3_HLEN &amp;&amp;</a>
<a name="ln1731">                        (makeword(ef+(EB_HEADSIZE+EB_FLGS_OFFS))</a>
<a name="ln1732">                         &amp; EB_M3_FL_UNCMPR) &amp;&amp;</a>
<a name="ln1733">                        (makelong(ef+EB_HEADSIZE) == ebLen - EB_MAC3_HLEN))</a>
<a name="ln1734">                        eb_cmpr_offs = 0;</a>
<a name="ln1735">                    else</a>
<a name="ln1736">                        eb_cmpr_offs = EB_MAC3_HLEN;</a>
<a name="ln1737">                    break;</a>
<a name="ln1738">                  case EF_BEOS:</a>
<a name="ln1739">                    if (ebLen &gt;= EB_BEOS_HLEN &amp;&amp;</a>
<a name="ln1740">                        (*(ef+(EB_HEADSIZE+EB_FLGS_OFFS)) &amp; EB_BE_FL_UNCMPR) &amp;&amp;</a>
<a name="ln1741">                        (makelong(ef+EB_HEADSIZE) == ebLen - EB_BEOS_HLEN))</a>
<a name="ln1742">                        eb_cmpr_offs = 0;</a>
<a name="ln1743">                    else</a>
<a name="ln1744">                        eb_cmpr_offs = EB_BEOS_HLEN;</a>
<a name="ln1745">                    break;</a>
<a name="ln1746">                }</a>
<a name="ln1747">                if ((r = test_compr_eb(__G__ ef, ebLen, eb_cmpr_offs, NULL))</a>
<a name="ln1748">                    != PK_OK) {</a>
<a name="ln1749">                    if (uO.qflag)</a>
<a name="ln1750">                        Info(slide, 1, ((char *)slide, &quot;%-22s &quot;,</a>
<a name="ln1751">                          FnFilter1(G.filename)));</a>
<a name="ln1752">                    switch (r) {</a>
<a name="ln1753">                        case IZ_EF_TRUNC:</a>
<a name="ln1754">                            Info(slide, 1, ((char *)slide,</a>
<a name="ln1755">                              LoadFarString(TruncEAs),</a>
<a name="ln1756">                              ebLen-(eb_cmpr_offs+EB_CMPRHEADLEN), &quot;\n&quot;));</a>
<a name="ln1757">                            break;</a>
<a name="ln1758">                        case PK_ERR:</a>
<a name="ln1759">                            Info(slide, 1, ((char *)slide,</a>
<a name="ln1760">                              LoadFarString(InvalidComprDataEAs)));</a>
<a name="ln1761">                            break;</a>
<a name="ln1762">                        case PK_MEM3:</a>
<a name="ln1763">                        case PK_MEM4:</a>
<a name="ln1764">                            Info(slide, 1, ((char *)slide,</a>
<a name="ln1765">                              LoadFarString(NotEnoughMemEAs)));</a>
<a name="ln1766">                            break;</a>
<a name="ln1767">                        default:</a>
<a name="ln1768">                            if ((r &amp; 0xff) != PK_ERR)</a>
<a name="ln1769">                                Info(slide, 1, ((char *)slide,</a>
<a name="ln1770">                                  LoadFarString(UnknErrorEAs)));</a>
<a name="ln1771">                            else {</a>
<a name="ln1772">                                ush m = (ush)(r &gt;&gt; 8);</a>
<a name="ln1773">                                if (m == DEFLATED)            /* GRR KLUDGE! */</a>
<a name="ln1774">                                    Info(slide, 1, ((char *)slide,</a>
<a name="ln1775">                                      LoadFarString(BadCRC_EAs)));</a>
<a name="ln1776">                                else</a>
<a name="ln1777">                                    Info(slide, 1, ((char *)slide,</a>
<a name="ln1778">                                      LoadFarString(UnknComprMethodEAs), m));</a>
<a name="ln1779">                            }</a>
<a name="ln1780">                            break;</a>
<a name="ln1781">                    }</a>
<a name="ln1782">                    return r;</a>
<a name="ln1783">                }</a>
<a name="ln1784">                break;</a>
<a name="ln1785"> </a>
<a name="ln1786">            case EF_NTSD:</a>
<a name="ln1787">                Trace((stderr, &quot;ebID: %i / ebLen: %u\n&quot;, ebID, ebLen));</a>
<a name="ln1788">                r = ebLen &lt; EB_NTSD_L_LEN ? IZ_EF_TRUNC :</a>
<a name="ln1789">                    ((ef[EB_HEADSIZE+EB_NTSD_VERSION] &gt; EB_NTSD_MAX_VER) ?</a>
<a name="ln1790">                     (PK_WARN | 0x4000) :</a>
<a name="ln1791">                     test_compr_eb(__G__ ef, ebLen, EB_NTSD_L_LEN, TEST_NTSD));</a>
<a name="ln1792">                if (r != PK_OK) {</a>
<a name="ln1793">                    if (uO.qflag)</a>
<a name="ln1794">                        Info(slide, 1, ((char *)slide, &quot;%-22s &quot;,</a>
<a name="ln1795">                          FnFilter1(G.filename)));</a>
<a name="ln1796">                    switch (r) {</a>
<a name="ln1797">                        case IZ_EF_TRUNC:</a>
<a name="ln1798">                            Info(slide, 1, ((char *)slide,</a>
<a name="ln1799">                              LoadFarString(TruncNTSD),</a>
<a name="ln1800">                              ebLen-(EB_NTSD_L_LEN+EB_CMPRHEADLEN), &quot;\n&quot;));</a>
<a name="ln1801">                            break;</a>
<a name="ln1802">#if (defined(WIN32) &amp;&amp; defined(NTSD_EAS))</a>
<a name="ln1803">                        case PK_WARN:</a>
<a name="ln1804">                            Info(slide, 1, ((char *)slide,</a>
<a name="ln1805">                              LoadFarString(InvalidSecurityEAs)));</a>
<a name="ln1806">                            break;</a>
<a name="ln1807">#endif</a>
<a name="ln1808">                        case PK_ERR:</a>
<a name="ln1809">                            Info(slide, 1, ((char *)slide,</a>
<a name="ln1810">                              LoadFarString(InvalidComprDataEAs)));</a>
<a name="ln1811">                            break;</a>
<a name="ln1812">                        case PK_MEM3:</a>
<a name="ln1813">                        case PK_MEM4:</a>
<a name="ln1814">                            Info(slide, 1, ((char *)slide,</a>
<a name="ln1815">                              LoadFarString(NotEnoughMemEAs)));</a>
<a name="ln1816">                            break;</a>
<a name="ln1817">                        case (PK_WARN | 0x4000):</a>
<a name="ln1818">                            Info(slide, 1, ((char *)slide,</a>
<a name="ln1819">                              LoadFarString(UnsuppNTSDVersEAs),</a>
<a name="ln1820">                              (int)ef[EB_HEADSIZE+EB_NTSD_VERSION]));</a>
<a name="ln1821">                            r = PK_WARN;</a>
<a name="ln1822">                            break;</a>
<a name="ln1823">                        default:</a>
<a name="ln1824">                            if ((r &amp; 0xff) != PK_ERR)</a>
<a name="ln1825">                                Info(slide, 1, ((char *)slide,</a>
<a name="ln1826">                                  LoadFarString(UnknErrorEAs)));</a>
<a name="ln1827">                            else {</a>
<a name="ln1828">                                ush m = (ush)(r &gt;&gt; 8);</a>
<a name="ln1829">                                if (m == DEFLATED)            /* GRR KLUDGE! */</a>
<a name="ln1830">                                    Info(slide, 1, ((char *)slide,</a>
<a name="ln1831">                                      LoadFarString(BadCRC_EAs)));</a>
<a name="ln1832">                                else</a>
<a name="ln1833">                                    Info(slide, 1, ((char *)slide,</a>
<a name="ln1834">                                      LoadFarString(UnknComprMethodEAs), m));</a>
<a name="ln1835">                            }</a>
<a name="ln1836">                            break;</a>
<a name="ln1837">                    }</a>
<a name="ln1838">                    return r;</a>
<a name="ln1839">                }</a>
<a name="ln1840">                break;</a>
<a name="ln1841">            case EF_PKVMS:</a>
<a name="ln1842">                if (makelong(ef+EB_HEADSIZE) !=</a>
<a name="ln1843">                    crc32(CRCVAL_INITIAL, ef+(EB_HEADSIZE+4),</a>
<a name="ln1844">                          (extent)(ebLen-4)))</a>
<a name="ln1845">                    Info(slide, 1, ((char *)slide,</a>
<a name="ln1846">                      LoadFarString(BadCRC_EAs)));</a>
<a name="ln1847">                break;</a>
<a name="ln1848">            case EF_PKW32:</a>
<a name="ln1849">            case EF_PKUNIX:</a>
<a name="ln1850">            case EF_ASIUNIX:</a>
<a name="ln1851">            case EF_IZVMS:</a>
<a name="ln1852">            case EF_IZUNIX:</a>
<a name="ln1853">            case EF_VMCMS:</a>
<a name="ln1854">            case EF_MVS:</a>
<a name="ln1855">            case EF_SPARK:</a>
<a name="ln1856">            case EF_TANDEM:</a>
<a name="ln1857">            case EF_THEOS:</a>
<a name="ln1858">            case EF_AV:</a>
<a name="ln1859">            default:</a>
<a name="ln1860">                break;</a>
<a name="ln1861">        }</a>
<a name="ln1862">        ef_len -= (ebLen + EB_HEADSIZE);</a>
<a name="ln1863">        ef += (ebLen + EB_HEADSIZE);</a>
<a name="ln1864">    }</a>
<a name="ln1865"> </a>
<a name="ln1866">    if (!uO.qflag)</a>
<a name="ln1867">        Info(slide, 0, ((char *)slide, &quot; OK\n&quot;));</a>
<a name="ln1868"> </a>
<a name="ln1869">    return PK_COOL;</a>
<a name="ln1870"> </a>
<a name="ln1871">} /* end function TestExtraField() */</a>
<a name="ln1872"> </a>
<a name="ln1873"> </a>
<a name="ln1874"> </a>
<a name="ln1875"> </a>
<a name="ln1876"> </a>
<a name="ln1877">/******************************/</a>
<a name="ln1878">/*  Function test_compr_eb()  */</a>
<a name="ln1879">/******************************/</a>
<a name="ln1880"> </a>
<a name="ln1881">#ifdef PROTO</a>
<a name="ln1882">static int test_compr_eb(</a>
<a name="ln1883">    __GPRO__</a>
<a name="ln1884">    uch *eb,</a>
<a name="ln1885">    unsigned eb_size,</a>
<a name="ln1886">    unsigned compr_offset,</a>
<a name="ln1887">    int (*test_uc_ebdata)(__GPRO__ uch *eb, unsigned eb_size,</a>
<a name="ln1888">                          uch *eb_ucptr, ulg eb_ucsize))</a>
<a name="ln1889">#else /* !PROTO */</a>
<a name="ln1890">static int test_compr_eb(__G__ eb, eb_size, compr_offset, test_uc_ebdata)</a>
<a name="ln1891">    __GDEF</a>
<a name="ln1892">    uch *eb;</a>
<a name="ln1893">    unsigned eb_size;</a>
<a name="ln1894">    unsigned compr_offset;</a>
<a name="ln1895">    int (*test_uc_ebdata)();</a>
<a name="ln1896">#endif /* ?PROTO */</a>
<a name="ln1897">{</a>
<a name="ln1898">    ulg eb_ucsize;</a>
<a name="ln1899">    uch *eb_ucptr;</a>
<a name="ln1900">    int r;</a>
<a name="ln1901"> </a>
<a name="ln1902">    if (compr_offset &lt; 4)                /* field is not compressed: */</a>
<a name="ln1903">        return PK_OK;                    /* do nothing and signal OK */</a>
<a name="ln1904"> </a>
<a name="ln1905">    if ((eb_size &lt; (EB_UCSIZE_P + 4)) ||</a>
<a name="ln1906">        ((eb_ucsize = makelong(eb+(EB_HEADSIZE+EB_UCSIZE_P))) &gt; 0L &amp;&amp;</a>
<a name="ln1907">         eb_size &lt;= (compr_offset + EB_CMPRHEADLEN)))</a>
<a name="ln1908">        return IZ_EF_TRUNC;               /* no compressed data! */</a>
<a name="ln1909"> </a>
<a name="ln1910">    if ((eb_ucptr = (uch *)malloc((extent)eb_ucsize)) == (uch *)NULL)</a>
<a name="ln1911">        return PK_MEM4;</a>
<a name="ln1912"> </a>
<a name="ln1913">    r = memextract(__G__ eb_ucptr, eb_ucsize,</a>
<a name="ln1914">                   eb + (EB_HEADSIZE + compr_offset),</a>
<a name="ln1915">                   (ulg)(eb_size - compr_offset));</a>
<a name="ln1916"> </a>
<a name="ln1917">    if (r == PK_OK &amp;&amp; test_uc_ebdata != NULL)</a>
<a name="ln1918">        r = (*test_uc_ebdata)(__G__ eb, eb_size, eb_ucptr, eb_ucsize);</a>
<a name="ln1919"> </a>
<a name="ln1920">    free(eb_ucptr);</a>
<a name="ln1921">    return r;</a>
<a name="ln1922"> </a>
<a name="ln1923">} /* end function test_compr_eb() */</a>
<a name="ln1924"> </a>
<a name="ln1925">#endif /* !SFX */</a>
<a name="ln1926"> </a>
<a name="ln1927"> </a>
<a name="ln1928"> </a>
<a name="ln1929"> </a>
<a name="ln1930"> </a>
<a name="ln1931">/***************************/</a>
<a name="ln1932">/*  Function memextract()  */</a>
<a name="ln1933">/***************************/</a>
<a name="ln1934"> </a>
<a name="ln1935">int memextract(__G__ tgt, tgtsize, src, srcsize)  /* extract compressed */</a>
<a name="ln1936">    __GDEF                                        /*  extra field block; */</a>
<a name="ln1937">    uch *tgt;                                     /*  return PK-type error */</a>
<a name="ln1938">    ulg tgtsize;                                  /*  level */</a>
<a name="ln1939">    ZCONST uch *src;</a>
<a name="ln1940">    ulg srcsize;</a>
<a name="ln1941">{</a>
<a name="ln1942">    long old_csize=G.csize;</a>
<a name="ln1943">    uch *old_inptr=G.inptr;</a>
<a name="ln1944">    int  old_incnt=G.incnt;</a>
<a name="ln1945">    int  r, error=PK_OK;</a>
<a name="ln1946">    ush  method;</a>
<a name="ln1947">    ulg  extra_field_crc;</a>
<a name="ln1948"> </a>
<a name="ln1949"> </a>
<a name="ln1950">    method = makeword(src);</a>
<a name="ln1951">    extra_field_crc = makelong(src+2);</a>
<a name="ln1952"> </a>
<a name="ln1953">    /* compressed extra field exists completely in memory at this location: */</a>
<a name="ln1954">    G.inptr = (uch *)src + (2 + 4);     /* method and extra_field_crc */</a>
<a name="ln1955">    G.incnt = (int)(G.csize = (long)(srcsize - (2 + 4)));</a>
<a name="ln1956">    G.mem_mode = TRUE;</a>
<a name="ln1957">    G.outbufptr = tgt;</a>
<a name="ln1958">    G.outsize = tgtsize;</a>
<a name="ln1959"> </a>
<a name="ln1960">    switch (method) {</a>
<a name="ln1961">        case STORED:</a>
<a name="ln1962">            memcpy((char *)tgt, (char *)G.inptr, (extent)G.incnt);</a>
<a name="ln1963">            G.outcnt = G.csize;   /* for CRC calculation */</a>
<a name="ln1964">            break;</a>
<a name="ln1965">        case DEFLATED:</a>
<a name="ln1966">#ifdef USE_DEFLATE64</a>
<a name="ln1967">        case ENHDEFLATED:</a>
<a name="ln1968">#endif</a>
<a name="ln1969">            G.outcnt = 0L;</a>
<a name="ln1970">            if ((r = UZinflate(__G__ (method == ENHDEFLATED))) != 0) {</a>
<a name="ln1971">                if (!uO.tflag)</a>
<a name="ln1972">                    Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1973">                      LoadFarStringSmall(ErrUnzipNoFile), r == 3?</a>
<a name="ln1974">                      LoadFarString(NotEnoughMem) :</a>
<a name="ln1975">                      LoadFarString(InvalidComprData),</a>
<a name="ln1976">                      LoadFarStringSmall2(Inflate)));</a>
<a name="ln1977">                error = (r == 3)? PK_MEM3 : PK_ERR;</a>
<a name="ln1978">            }</a>
<a name="ln1979">            if (G.outcnt == 0L)   /* inflate's final FLUSH sets outcnt */</a>
<a name="ln1980">                break;</a>
<a name="ln1981">            break;</a>
<a name="ln1982">        default:</a>
<a name="ln1983">            if (uO.tflag)</a>
<a name="ln1984">                error = PK_ERR | ((int)method &lt;&lt; 8);</a>
<a name="ln1985">            else {</a>
<a name="ln1986">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln1987">                  LoadFarString(UnsupportedExtraField), method));</a>
<a name="ln1988">                error = PK_ERR;  /* GRR:  should be passed on up via SetEAs() */</a>
<a name="ln1989">            }</a>
<a name="ln1990">            break;</a>
<a name="ln1991">    }</a>
<a name="ln1992"> </a>
<a name="ln1993">    G.inptr = old_inptr;</a>
<a name="ln1994">    G.incnt = old_incnt;</a>
<a name="ln1995">    G.csize = old_csize;</a>
<a name="ln1996">    G.mem_mode = FALSE;</a>
<a name="ln1997"> </a>
<a name="ln1998">    if (!error) {</a>
<a name="ln1999">        register ulg crcval = crc32(CRCVAL_INITIAL, tgt, (extent)G.outcnt);</a>
<a name="ln2000"> </a>
<a name="ln2001">        if (crcval != extra_field_crc) {</a>
<a name="ln2002">            if (uO.tflag)</a>
<a name="ln2003">                error = PK_ERR | (DEFLATED &lt;&lt; 8);  /* kludge for now */</a>
<a name="ln2004">            else {</a>
<a name="ln2005">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln2006">                  LoadFarString(BadExtraFieldCRC), G.zipfn, crcval,</a>
<a name="ln2007">                  extra_field_crc));</a>
<a name="ln2008">                error = PK_ERR;</a>
<a name="ln2009">            }</a>
<a name="ln2010">        }</a>
<a name="ln2011">    }</a>
<a name="ln2012">    return error;</a>
<a name="ln2013"> </a>
<a name="ln2014">} /* end function memextract() */</a>
<a name="ln2015"> </a>
<a name="ln2016"> </a>
<a name="ln2017"> </a>
<a name="ln2018"> </a>
<a name="ln2019"> </a>
<a name="ln2020">/*************************/</a>
<a name="ln2021">/*  Function memflush()  */</a>
<a name="ln2022">/*************************/</a>
<a name="ln2023"> </a>
<a name="ln2024">int memflush(__G__ rawbuf, size)</a>
<a name="ln2025">    __GDEF</a>
<a name="ln2026">    ZCONST uch *rawbuf;</a>
<a name="ln2027">    ulg size;</a>
<a name="ln2028">{</a>
<a name="ln2029">    if (size &gt; G.outsize)</a>
<a name="ln2030">        /* Here, PK_DISK is a bit off-topic, but in the sense of marking</a>
<a name="ln2031">           &quot;overflow of output space&quot;, its use may be tolerated. */</a>
<a name="ln2032">        return PK_DISK;   /* more data than output buffer can hold */</a>
<a name="ln2033"> </a>
<a name="ln2034"> </a>
<a name="ln2035"> </a>
<a name="ln2036">    memcpy((char *)G.outbufptr, (char *)rawbuf, (extent)size);</a>
<a name="ln2037">    G.outbufptr += (unsigned int)size;</a>
<a name="ln2038">    G.outsize -= size;</a>
<a name="ln2039">    G.outcnt += size;</a>
<a name="ln2040"> </a>
<a name="ln2041">    return 0;</a>
<a name="ln2042"> </a>
<a name="ln2043">} /* end function memflush() */</a>
<a name="ln2044"> </a>
<a name="ln2045"> </a>
<a name="ln2046"> </a>
<a name="ln2047"> </a>
<a name="ln2048"> </a>
<a name="ln2049">#if (defined(VMS) || defined(VMS_TEXT_CONV))</a>
<a name="ln2050"> </a>
<a name="ln2051">/************************************/</a>
<a name="ln2052">/*  Function extract_izvms_block()  */</a>
<a name="ln2053">/************************************/</a>
<a name="ln2054"> </a>
<a name="ln2055">/*</a>
<a name="ln2056"> * Extracts block from p. If resulting length is less then needed, fill</a>
<a name="ln2057"> * extra space with corresponding bytes from 'init'.</a>
<a name="ln2058"> * Currently understands 3 formats of block compression:</a>
<a name="ln2059"> * - Simple storing</a>
<a name="ln2060"> * - Compression of zero bytes to zero bits</a>
<a name="ln2061"> * - Deflation (see memextract())</a>
<a name="ln2062"> * The IZVMS block data is returned in malloc'd space.</a>
<a name="ln2063"> */</a>
<a name="ln2064">uch *extract_izvms_block(__G__ ebdata, size, retlen, init, needlen)</a>
<a name="ln2065">    __GDEF</a>
<a name="ln2066">    ZCONST uch *ebdata;</a>
<a name="ln2067">    unsigned size;</a>
<a name="ln2068">    unsigned *retlen;</a>
<a name="ln2069">    ZCONST uch *init;</a>
<a name="ln2070">    unsigned needlen;</a>
<a name="ln2071">{</a>
<a name="ln2072">    uch *ucdata;       /* Pointer to block allocated */</a>
<a name="ln2073">    int cmptype;</a>
<a name="ln2074">    unsigned usiz, csiz;</a>
<a name="ln2075"> </a>
<a name="ln2076">    cmptype = (makeword(ebdata+EB_IZVMS_FLGS) &amp; EB_IZVMS_BCMASK);</a>
<a name="ln2077">    csiz = size - EB_IZVMS_HLEN;</a>
<a name="ln2078">    usiz = (cmptype == EB_IZVMS_BCSTOR ?</a>
<a name="ln2079">            csiz : makeword(ebdata+EB_IZVMS_UCSIZ));</a>
<a name="ln2080"> </a>
<a name="ln2081">    if (retlen)</a>
<a name="ln2082">        *retlen = usiz;</a>
<a name="ln2083"> </a>
<a name="ln2084">    if ((ucdata = (uch *)malloc(MAX(needlen, usiz))) == NULL)</a>
<a name="ln2085">        return NULL;</a>
<a name="ln2086"> </a>
<a name="ln2087">    if (init &amp;&amp; (usiz &lt; needlen))</a>
<a name="ln2088">        memcpy((char *)ucdata, (ZCONST char *)init, needlen);</a>
<a name="ln2089"> </a>
<a name="ln2090">    switch (cmptype)</a>
<a name="ln2091">    {</a>
<a name="ln2092">        case EB_IZVMS_BCSTOR: /* The simplest case */</a>
<a name="ln2093">            memcpy(ucdata, ebdata+EB_IZVMS_HLEN, usiz);</a>
<a name="ln2094">            break;</a>
<a name="ln2095">        case EB_IZVMS_BC00:</a>
<a name="ln2096">            decompress_bits(ucdata, usiz, ebdata+EB_IZVMS_HLEN);</a>
<a name="ln2097">            break;</a>
<a name="ln2098">        case EB_IZVMS_BCDEFL:</a>
<a name="ln2099">            memextract(__G__ ucdata, (ulg)usiz,</a>
<a name="ln2100">                       ebdata+EB_IZVMS_HLEN, (ulg)csiz);</a>
<a name="ln2101">            break;</a>
<a name="ln2102">        default:</a>
<a name="ln2103">            free(ucdata);</a>
<a name="ln2104">            ucdata = NULL;</a>
<a name="ln2105">    }</a>
<a name="ln2106">    return ucdata;</a>
<a name="ln2107"> </a>
<a name="ln2108">} /* end of extract_izvms_block */</a>
<a name="ln2109"> </a>
<a name="ln2110"> </a>
<a name="ln2111"> </a>
<a name="ln2112"> </a>
<a name="ln2113"> </a>
<a name="ln2114">/********************************/</a>
<a name="ln2115">/*  Function decompress_bits()  */</a>
<a name="ln2116">/********************************/</a>
<a name="ln2117">/*</a>
<a name="ln2118"> *  Simple uncompression routine. The compression uses bit stream.</a>
<a name="ln2119"> *  Compression scheme:</a>
<a name="ln2120"> *</a>
<a name="ln2121"> *  if (byte!=0)</a>
<a name="ln2122"> *      putbit(1),putbyte(byte)</a>
<a name="ln2123"> *  else</a>
<a name="ln2124"> *      putbit(0)</a>
<a name="ln2125"> */</a>
<a name="ln2126">static void decompress_bits(outptr, needlen, bitptr)</a>
<a name="ln2127">    uch *outptr;        /* Pointer into output block */</a>
<a name="ln2128">    unsigned needlen;   /* Size of uncompressed block */</a>
<a name="ln2129">    ZCONST uch *bitptr; /* Pointer into compressed data */</a>
<a name="ln2130">{</a>
<a name="ln2131">    ulg bitbuf = 0;</a>
<a name="ln2132">    int bitcnt = 0;</a>
<a name="ln2133"> </a>
<a name="ln2134">#define _FILL   {       bitbuf |= (*bitptr++) &lt;&lt; bitcnt;\</a>
<a name="ln2135">                        bitcnt += 8;                    \</a>
<a name="ln2136">                }</a>
<a name="ln2137"> </a>
<a name="ln2138">    while (needlen--)</a>
<a name="ln2139">    {</a>
<a name="ln2140">        if (bitcnt &lt;= 0)</a>
<a name="ln2141">            _FILL;</a>
<a name="ln2142"> </a>
<a name="ln2143">        if (bitbuf &amp; 1)</a>
<a name="ln2144">        {</a>
<a name="ln2145">            bitbuf &gt;&gt;= 1;</a>
<a name="ln2146">            if ((bitcnt -= 1) &lt; 8)</a>
<a name="ln2147">                _FILL;</a>
<a name="ln2148">            *outptr++ = (uch)bitbuf;</a>
<a name="ln2149">            bitcnt -= 8;</a>
<a name="ln2150">            bitbuf &gt;&gt;= 8;</a>
<a name="ln2151">        }</a>
<a name="ln2152">        else</a>
<a name="ln2153">        {</a>
<a name="ln2154">            *outptr++ = '\0';</a>
<a name="ln2155">            bitcnt -= 1;</a>
<a name="ln2156">            bitbuf &gt;&gt;= 1;</a>
<a name="ln2157">        }</a>
<a name="ln2158">    }</a>
<a name="ln2159">} /* end function decompress_bits() */</a>
<a name="ln2160"> </a>
<a name="ln2161">#endif /* VMS || VMS_TEXT_CONV */</a>
<a name="ln2162"> </a>
<a name="ln2163"> </a>
<a name="ln2164"> </a>
<a name="ln2165"> </a>
<a name="ln2166"> </a>
<a name="ln2167">/*************************/</a>
<a name="ln2168">/*  Function fnfilter()  */        /* here instead of in list.c for SFX */</a>
<a name="ln2169">/*************************/</a>
<a name="ln2170"> </a>
<a name="ln2171">char *fnfilter(raw, space)         /* convert name to safely printable form */</a>
<a name="ln2172">    ZCONST char *raw;</a>
<a name="ln2173">    uch *space;</a>
<a name="ln2174">{</a>
<a name="ln2175">#ifndef NATIVE   /* ASCII:  filter ANSI escape codes, etc. */</a>
<a name="ln2176">    ZCONST uch *r=(ZCONST uch *)raw;</a>
<a name="ln2177">    uch *s=space;</a>
<a name="ln2178"> </a>
<a name="ln2179">    while (*r) {</a>
<a name="ln2180">#ifdef QDOS</a>
<a name="ln2181">        if (qlflag &amp; 2) {</a>
<a name="ln2182">            if (*r == '/' || *r == '.') {</a>
<a name="ln2183">                ++r;</a>
<a name="ln2184">                *s++ = '_';</a>
<a name="ln2185">                continue;</a>
<a name="ln2186">            }</a>
<a name="ln2187">        } else</a>
<a name="ln2188">#endif</a>
<a name="ln2189">        if (*r &lt; 32) {</a>
<a name="ln2190">            *s++ = '^', *s++ = (uch)(64 + *r++);</a>
<a name="ln2191">        } else {</a>
<a name="ln2192">#ifdef _MBCS</a>
<a name="ln2193">            unsigned i;</a>
<a name="ln2194">            for (i = CLEN(r); i &gt; 0; i--)</a>
<a name="ln2195">                *s++ = *r++;</a>
<a name="ln2196">#else</a>
<a name="ln2197">            *s++ = *r++;</a>
<a name="ln2198">#endif</a>
<a name="ln2199">         }</a>
<a name="ln2200">    }</a>
<a name="ln2201">    *s = '\0';</a>
<a name="ln2202"> </a>
<a name="ln2203">#ifdef WINDLL</a>
<a name="ln2204">    INTERN_TO_ISO((char *)space, (char *)space);  /* translate to ANSI */</a>
<a name="ln2205">#else</a>
<a name="ln2206">#ifdef WIN32</a>
<a name="ln2207">    /* Win9x console always uses OEM character coding, and</a>
<a name="ln2208">       WinNT console is set to OEM charset by default, too */</a>
<a name="ln2209">    INTERN_TO_OEM((char *)space, (char *)space);</a>
<a name="ln2210">#endif /* WIN32 */</a>
<a name="ln2211">#endif /* ?WINDLL */</a>
<a name="ln2212"> </a>
<a name="ln2213">    return (char *)space;</a>
<a name="ln2214"> </a>
<a name="ln2215">#else /* NATIVE:  EBCDIC or whatever */</a>
<a name="ln2216">    return (char *)raw;</a>
<a name="ln2217">#endif</a>
<a name="ln2218"> </a>
<a name="ln2219">} /* end function fnfilter() */</a>
<a name="ln2220"> </a>
<a name="ln2221"> </a>
<a name="ln2222"> </a>
<a name="ln2223"> </a>
<a name="ln2224"> </a>
<a name="ln2225">#ifdef SET_DIR_ATTRIB</a>
<a name="ln2226">/* must sort saved directories so can set perms from bottom up */</a>
<a name="ln2227"> </a>
<a name="ln2228">/************************/</a>
<a name="ln2229">/*  Function dircomp()  */</a>
<a name="ln2230">/************************/</a>
<a name="ln2231"> </a>
<a name="ln2232">static int dircomp(a, b)   /* used by qsort(); swiped from Zip */</a>
<a name="ln2233">    ZCONST zvoid *a, *b;</a>
<a name="ln2234">{</a>
<a name="ln2235">    /* order is significant:  this sorts in reverse order (deepest first) */</a>
<a name="ln2236">    return strcmp((*(dirtime **)b)-&gt;fn, (*(dirtime **)a)-&gt;fn);</a>
<a name="ln2237"> /* return namecmp((*(dirtime **)b)-&gt;fn, (*(dirtime **)a)-&gt;fn); */</a>
<a name="ln2238">}</a>
<a name="ln2239"> </a>
<a name="ln2240"> </a>
<a name="ln2241"> </a>
<a name="ln2242">#if 0   /* not used in Unix, but maybe for future OSes? */</a>
<a name="ln2243"> </a>
<a name="ln2244">/************************/</a>
<a name="ln2245">/*  Function namecmp()  */</a>
<a name="ln2246">/************************/</a>
<a name="ln2247"> </a>
<a name="ln2248">static int namecmp(s1, s2)   /* [not] used by dircomp(); swiped from Zip */</a>
<a name="ln2249">    ZCONST char *s1, *s2;</a>
<a name="ln2250">{</a>
<a name="ln2251">    int d;</a>
<a name="ln2252"> </a>
<a name="ln2253">    for (;;) {</a>
<a name="ln2254">        d = (int)(uch)case_map(*s1)</a>
<a name="ln2255">          - (int)(uch)case_map(*s2);</a>
<a name="ln2256"> </a>
<a name="ln2257">        if (d || *s1 == 0 || *s2 == 0)</a>
<a name="ln2258">            return d;</a>
<a name="ln2259"> </a>
<a name="ln2260">        s1++;</a>
<a name="ln2261">        s2++;</a>
<a name="ln2262">    }</a>
<a name="ln2263">}</a>
<a name="ln2264"> </a>
<a name="ln2265">#endif /* 0 */</a>
<a name="ln2266">#endif /* SET_DIR_ATTRIB */</a>

</code></pre>
<div class="balloon" rel="1259"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in index: 'fnlen'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
