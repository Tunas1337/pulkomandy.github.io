
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>PartitionMap.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2003-2011, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Ingo Weinhold, bonefish@cs.tu-berlin.de</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">/*!	\file PartitionMap.cpp</a>
<a name="ln11">	\brief Definitions for &quot;intel&quot; style partitions and implementation</a>
<a name="ln12">		   of related classes.</a>
<a name="ln13">*/</a>
<a name="ln14"> </a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;stdio.h&gt;</a>
<a name="ln17">#include &lt;stdlib.h&gt;</a>
<a name="ln18">#include &lt;string.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#ifndef _USER_MODE</a>
<a name="ln21">#	include &lt;util/kernel_cpp.h&gt;</a>
<a name="ln22">#	include &lt;KernelExport.h&gt;</a>
<a name="ln23">#else</a>
<a name="ln24">#	include &lt;new&gt;</a>
<a name="ln25">#endif</a>
<a name="ln26">#ifndef _BOOT_MODE</a>
<a name="ln27">#	include &lt;DiskDeviceTypes.h&gt;</a>
<a name="ln28">#else</a>
<a name="ln29">#	include &lt;boot/partitions.h&gt;</a>
<a name="ln30">#endif</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;PartitionMap.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">//#define TRACE_ENABLED</a>
<a name="ln36">#ifdef TRACE_ENABLED</a>
<a name="ln37">#	ifdef _USER_MODE</a>
<a name="ln38">#		define TRACE(x) printf x</a>
<a name="ln39">#	else</a>
<a name="ln40">#		define TRACE(x) dprintf x</a>
<a name="ln41">#	endif</a>
<a name="ln42">#else</a>
<a name="ln43">#	define TRACE(x) ;</a>
<a name="ln44">#endif</a>
<a name="ln45"> </a>
<a name="ln46">using std::nothrow;</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">static const char* const kUnrecognizedTypeString = &quot;Unrecognized Type &quot;;</a>
<a name="ln50">static const size_t kUnrecognizedTypeStringLength = 18;</a>
<a name="ln51"> </a>
<a name="ln52">static const struct partition_type kPartitionTypes[] = {</a>
<a name="ln53">    // Can be created (in display order)</a>
<a name="ln54">    { 0x00, &quot;empty&quot;, true },</a>
<a name="ln55">    { 0x0f, INTEL_EXTENDED_PARTITION_NAME, true }, </a>
<a name="ln56">    { 0x0c, &quot;FAT 32-bit, LBA-mapped&quot;, true }, </a>
<a name="ln57">    { 0x82, &quot;Linux swap&quot;, true }, </a>
<a name="ln58">    { 0x83, &quot;Linux native&quot;, true }, </a>
<a name="ln59">    { 0xa5, &quot;FreeBSD&quot;, true }, </a>
<a name="ln60">    { 0xa6, &quot;OpenBSD&quot;, true }, </a>
<a name="ln61">    { 0xa9, &quot;NetBSD&quot;, true }, </a>
<a name="ln62">    { 0xa8, &quot;MacOS X&quot;, true }, </a>
<a name="ln63">    { 0xab, &quot;MacOS X boot&quot;, true }, </a>
<a name="ln64">    { 0xaf, &quot;MacOS X HFS/HFS+&quot;, true }, </a>
<a name="ln65">    { 0x4d, &quot;QNX 4&quot;, true }, </a>
<a name="ln66">    { 0xb3, &quot;QNX 6&quot;, true }, </a>
<a name="ln67">    { 0xeb, BFS_NAME, true }, </a>
<a name="ln68">    // Known file system types</a>
<a name="ln69">    { 0x01, &quot;FAT 12-bit&quot;, false},</a>
<a name="ln70">    { 0x02, &quot;Xenix root&quot;, false },</a>
<a name="ln71">    { 0x03, &quot;Xenix user&quot;, false },</a>
<a name="ln72">    { 0x04, &quot;FAT 16-bit (dos 3.0)&quot;, false },</a>
<a name="ln73">    { 0x05, INTEL_EXTENDED_PARTITION_NAME, false },</a>
<a name="ln74">    { 0x06, &quot;FAT 16-bit (dos 3.31)&quot;, false },</a>
<a name="ln75">    { 0x07, &quot;Windows NT, OS/2 IFS, Advanced Unix&quot;, false },</a>
<a name="ln76">    { 0x08, &quot;AIX&quot;, false }, </a>
<a name="ln77">    { 0x09, &quot;AIX bootable&quot;, false }, </a>
<a name="ln78">    { 0x0a, &quot;OS/2 Boot Manager&quot;, false },</a>
<a name="ln79">    { 0x0b, &quot;FAT 32-bit&quot;, false },</a>
<a name="ln80">    { 0x0e, &quot;FAT 16-bit, LBA-mapped&quot;, false }, </a>
<a name="ln81">    { 0x10, &quot;OPUS&quot;, false }, </a>
<a name="ln82">    { 0x11, &quot;Hidden FAT 12-bit&quot;, false }, </a>
<a name="ln83">    { 0x12, &quot;Compaq diagnostic&quot;, false }, </a>
<a name="ln84">    { 0x14, &quot;Hidden FAT 16-bit&quot;, false }, </a>
<a name="ln85">    { 0x16, &quot;Hidden FAT 16-bit&quot;, false }, </a>
<a name="ln86">    { 0x17, &quot;Hidden HPFS/NTFS&quot;, false }, </a>
<a name="ln87">    { 0x18, &quot;AST SmartSleep&quot;, false }, </a>
<a name="ln88">    { 0x1b, &quot;Hidden W95 FAT 32-bit&quot;, false }, </a>
<a name="ln89">    { 0x1c, &quot;Hidden W95 FAT 32-bit&quot;, false }, </a>
<a name="ln90">    { 0x1e, &quot;Hidden W95 FAT 16-bit&quot;, false }, </a>
<a name="ln91">    { 0x24, &quot;NEC DOS&quot;, false }, </a>
<a name="ln92">    { 0x39, &quot;Plan 9&quot;, false }, </a>
<a name="ln93">    { 0x3c, &quot;PartitionMagic&quot;, false }, </a>
<a name="ln94">    { 0x40, &quot;Venix 80286&quot;, false }, </a>
<a name="ln95">    { 0x41, &quot;PPC PReP Boot&quot;, false }, </a>
<a name="ln96">    { 0x42, &quot;Windows 2000 marker (proprietary extended)&quot;,</a>
<a name="ln97">    false },</a>
<a name="ln98">    { 0x4e, &quot;QNX 4 2nd part&quot;, false },</a>
<a name="ln99">    { 0x4f, &quot;QNX 4 3rd part&quot;, false },</a>
<a name="ln100">    { 0x50, &quot;OnTrack DM&quot;, false }, </a>
<a name="ln101">    { 0x51, &quot;OnTrack DM6 Aux&quot;, false }, </a>
<a name="ln102">    { 0x52, &quot;CP/M&quot;, false }, </a>
<a name="ln103">    { 0x53, &quot;OnTrack DM6 Aux&quot;, false }, </a>
<a name="ln104">    { 0x54, &quot;OnTrack DM6&quot;, false }, </a>
<a name="ln105">    { 0x55, &quot;EZ-Drive&quot;, false }, </a>
<a name="ln106">    { 0x56, &quot;Golden Bow&quot;, false }, </a>
<a name="ln107">    { 0x5c, &quot;Priam Edisk&quot;, false }, </a>
<a name="ln108">    { 0x61, &quot;SpeedStor&quot;, false }, </a>
<a name="ln109">    { 0x63, &quot;GNU HURD&quot;, false }, </a>
<a name="ln110">    { 0x64, &quot;Novell Netware&quot;, false }, </a>
<a name="ln111">    { 0x65, &quot;Novell Netware&quot;, false }, </a>
<a name="ln112">    { 0x70, &quot;DiskSecure Mult&quot;, false }, </a>
<a name="ln113">    { 0x75, &quot;PC/IX&quot;, false },</a>
<a name="ln114">    { 0x78, &quot;XOSL boot loader&quot;, false },</a>
<a name="ln115">    { 0x80, &quot;Old Minix&quot;, false }, </a>
<a name="ln116">    { 0x81, &quot;Minix&quot;, false }, </a>
<a name="ln117">    { 0x84, &quot;OS/2 hidden&quot;, false },</a>
<a name="ln118">    { 0x85, /*&quot;Linux extendend partition&quot;*/INTEL_EXTENDED_PARTITION_NAME,</a>
<a name="ln119">    false },</a>
<a name="ln120">    { 0x86, &quot;NTFS volume set&quot;, false }, </a>
<a name="ln121">    { 0x87, &quot;NTFS volume set&quot;, true }, </a>
<a name="ln122">    { 0x88, &quot;Linux plaintext&quot;, false }, </a>
<a name="ln123">    { 0x8e, &quot;Linux LVM&quot;, false }, </a>
<a name="ln124">    { 0x93, &quot;Amoeba&quot;, false }, </a>
<a name="ln125">    { 0x94, &quot;Amoeba BBT&quot;, false }, </a>
<a name="ln126">    { 0x9f, &quot;BSD/OS&quot;, false }, </a>
<a name="ln127">    { 0xa0, &quot;IBM Hibernation&quot;, false },</a>
<a name="ln128">    { 0xa7, &quot;NextSTEP&quot;, false },</a>
<a name="ln129">    { 0xb1, &quot;QNX 6&quot;, false}, </a>
<a name="ln130">    { 0xb2, &quot;QNX 6&quot;, false}, </a>
<a name="ln131">    { 0xb7, &quot;BSDI fs&quot;, false }, </a>
<a name="ln132">    { 0xb8, &quot;BSDI swap&quot;, false },</a>
<a name="ln133">    { 0xbe, &quot;Solaris 8 boot&quot;, false },</a>
<a name="ln134">    { 0xbf, &quot;Solaris 10&quot;, false },</a>
<a name="ln135">    { 0xc1, &quot;DR-DOS FAT&quot;, false }, </a>
<a name="ln136">    { 0xc4, &quot;DR-DOS FAT&quot;, false }, </a>
<a name="ln137">    { 0xc6, &quot;DR-DOS FAT&quot;, false }, </a>
<a name="ln138">    { 0xc7, &quot;Syrinx&quot;, false }, </a>
<a name="ln139">    { 0xe4, &quot;SpeedStor&quot;, false }, </a>
<a name="ln140">    { 0xee, &quot;GPT&quot;, false }, </a>
<a name="ln141">    { 0xef, &quot;EFI&quot;, false }, </a>
<a name="ln142">    { 0xfb, &quot;VMware VMFS&quot;, false },</a>
<a name="ln143">    { 0xfc, &quot;VMware VMKCORE&quot;, false },</a>
<a name="ln144">    { 0xfd, &quot;Linux raid auto&quot;, false },</a>
<a name="ln145">    { 0, NULL, false }</a>
<a name="ln146">};</a>
<a name="ln147"> </a>
<a name="ln148">static const struct partition_type kPartitionContentTypes[] = {</a>
<a name="ln149">#ifndef _USER_MODE</a>
<a name="ln150">	{ 0x01, kPartitionTypeFAT12 },</a>
<a name="ln151">	{ 0x07, kPartitionTypeEXFAT },</a>
<a name="ln152">	{ 0x0c, kPartitionTypeFAT32 },</a>
<a name="ln153">	{ 0x0f, kPartitionTypeIntelExtended },</a>
<a name="ln154">	{ 0x83, kPartitionTypeBTRFS },</a>
<a name="ln155">	{ 0x83, kPartitionTypeEXT2 },</a>
<a name="ln156">	{ 0x83, kPartitionTypeEXT3 },</a>
<a name="ln157">	{ 0x83, kPartitionTypeReiser },</a>
<a name="ln158">	{ 0xaf, kPartitionTypeHFS },</a>
<a name="ln159">	{ 0xaf, kPartitionTypeHFSPlus },</a>
<a name="ln160">	{ 0xeb, kPartitionTypeBFS },</a>
<a name="ln161">#endif</a>
<a name="ln162">	{ 0, NULL }</a>
<a name="ln163">};</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">static const char*</a>
<a name="ln167">partition_type_string(uint8 type)</a>
<a name="ln168">{</a>
<a name="ln169">	int32 i;</a>
<a name="ln170">	for (i = 0; kPartitionTypes[i].name ; i++) {</a>
<a name="ln171">		if (type == kPartitionTypes[i].type)</a>
<a name="ln172">			return kPartitionTypes[i].name;</a>
<a name="ln173">	}</a>
<a name="ln174">	return NULL;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">void</a>
<a name="ln179">get_partition_type_string(uint8 type, char* buffer)</a>
<a name="ln180">{</a>
<a name="ln181">	if (buffer) {</a>
<a name="ln182">		if (const char* typeString = partition_type_string(type))</a>
<a name="ln183">			strcpy(buffer, typeString);</a>
<a name="ln184">		else</a>
<a name="ln185">			sprintf(buffer, &quot;%s0x%x&quot;, kUnrecognizedTypeString, type);</a>
<a name="ln186">	}</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">static int</a>
<a name="ln191">cmp_partition_offset(const void* p1, const void* p2)</a>
<a name="ln192">{</a>
<a name="ln193">	const Partition* partition1 = *(const Partition**)p1;</a>
<a name="ln194">	const Partition* partition2 = *(const Partition**)p2;</a>
<a name="ln195"> </a>
<a name="ln196">	if (partition1-&gt;Offset() &lt; partition2-&gt;Offset())</a>
<a name="ln197">		return -1;</a>
<a name="ln198">	if (partition1-&gt;Offset() &gt; partition2-&gt;Offset())</a>
<a name="ln199">		return 1;</a>
<a name="ln200"> </a>
<a name="ln201">	return 0;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204"> </a>
<a name="ln205">static int</a>
<a name="ln206">cmp_offset(const void* o1, const void* o2)</a>
<a name="ln207">{</a>
<a name="ln208">	off_t offset1 = *static_cast&lt;const off_t*&gt;(o1);</a>
<a name="ln209">	off_t offset2 = *static_cast&lt;const off_t*&gt;(o2);</a>
<a name="ln210"> </a>
<a name="ln211">	if (offset1 &lt; offset2)</a>
<a name="ln212">		return -1;</a>
<a name="ln213">	if (offset1 &gt; offset2)</a>
<a name="ln214">		return 1;</a>
<a name="ln215"> </a>
<a name="ln216">	return 0;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">static bool</a>
<a name="ln221">is_inside_partitions(off_t location, const Partition** partitions, int32 count)</a>
<a name="ln222">{</a>
<a name="ln223">	bool result = false;</a>
<a name="ln224">	if (count &gt; 0) {</a>
<a name="ln225">		// binary search</a>
<a name="ln226">		int32 lower = 0;</a>
<a name="ln227">		int32 upper = count - 1;</a>
<a name="ln228">		while (lower &lt; upper) {</a>
<a name="ln229">			int32 mid = (lower + upper) / 2;</a>
<a name="ln230">			const Partition* midPartition = partitions[mid];</a>
<a name="ln231">			if (location &gt;= midPartition-&gt;Offset() + midPartition-&gt;Size())</a>
<a name="ln232">				lower = mid + 1;</a>
<a name="ln233">			else</a>
<a name="ln234">				upper = mid;</a>
<a name="ln235">		}</a>
<a name="ln236">		const Partition* partition = partitions[lower];</a>
<a name="ln237">		result = (location &gt;= partition-&gt;Offset() &amp;&amp;</a>
<a name="ln238">				  location &lt; partition-&gt;Offset() + partition-&gt;Size());</a>
<a name="ln239">	}</a>
<a name="ln240">	return result;</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243"> </a>
<a name="ln244">//	#pragma mark - PartitionType</a>
<a name="ln245"> </a>
<a name="ln246"> </a>
<a name="ln247">PartitionType::PartitionType()</a>
<a name="ln248">	:</a>
<a name="ln249">	fType(0),</a>
<a name="ln250">	fValid(false)</a>
<a name="ln251">{</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254"> </a>
<a name="ln255">/*!	\brief Sets the \a type via its ID.</a>
<a name="ln256">	\param type ID of the partition type, it is in the range [0..255].</a>
<a name="ln257">*/</a>
<a name="ln258">bool</a>
<a name="ln259">PartitionType::SetType(uint8 type)</a>
<a name="ln260">{</a>
<a name="ln261">	fType = type;</a>
<a name="ln262">	fValid = partition_type_string(type);</a>
<a name="ln263">	return fValid;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">/*!	\brief Sets the type via its string name.</a>
<a name="ln268">	\param typeName Name of the partition type.</a>
<a name="ln269">*/</a>
<a name="ln270">bool</a>
<a name="ln271">PartitionType::SetType(const char* typeName)</a>
<a name="ln272">{</a>
<a name="ln273">	for (int32 i = 0; kPartitionTypes[i].name ; i++) {</a>
<a name="ln274">		if (!strcmp(typeName, kPartitionTypes[i].name)) {</a>
<a name="ln275">			fType = kPartitionTypes[i].type;</a>
<a name="ln276">			fValid = true;</a>
<a name="ln277">			return fValid;</a>
<a name="ln278">		}</a>
<a name="ln279">	}</a>
<a name="ln280"> </a>
<a name="ln281">	// If this is an unrecognized type, parse the type number.</a>
<a name="ln282">	if (strncmp(typeName, kUnrecognizedTypeString,</a>
<a name="ln283">			kUnrecognizedTypeStringLength) == 0) {</a>
<a name="ln284">		long type = strtol(typeName + kUnrecognizedTypeStringLength, NULL, 0);</a>
<a name="ln285">		if (type != 0 &amp;&amp; type &lt;= 255) {</a>
<a name="ln286">			fType = type;</a>
<a name="ln287">			fValid = true;</a>
<a name="ln288">			return fValid;</a>
<a name="ln289">		}</a>
<a name="ln290">	}</a>
<a name="ln291"> </a>
<a name="ln292">	fValid = false;</a>
<a name="ln293">	return fValid;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296"> </a>
<a name="ln297">/*!	\brief Converts content type to the partition type that fits best.</a>
<a name="ln298">	\param content_type Name of the content type, it is standardized by system.</a>
<a name="ln299">*/</a>
<a name="ln300">bool</a>
<a name="ln301">PartitionType::SetContentType(const char* contentType)</a>
<a name="ln302">{</a>
<a name="ln303">	for (int32 i = 0; kPartitionContentTypes[i].name ; i++) {</a>
<a name="ln304">		if (!strcmp(contentType, kPartitionContentTypes[i].name)) {</a>
<a name="ln305">			fType = kPartitionContentTypes[i].type;</a>
<a name="ln306">			fValid = true;</a>
<a name="ln307">			return fValid;</a>
<a name="ln308">		}</a>
<a name="ln309">	}</a>
<a name="ln310">	fValid = false;</a>
<a name="ln311">	return fValid;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314"> </a>
<a name="ln315">/*!	\brief Finds next supported partition.</a>
<a name="ln316">*/</a>
<a name="ln317">bool</a>
<a name="ln318">PartitionType::FindNext()</a>
<a name="ln319">{</a>
<a name="ln320">	for (int32 i = 0; kPartitionTypes[i].name; i++) {</a>
<a name="ln321">		if (fType &lt; kPartitionTypes[i].type) {</a>
<a name="ln322">			fType = kPartitionTypes[i].type;</a>
<a name="ln323">			fValid = true;</a>
<a name="ln324">			return true;</a>
<a name="ln325">		}</a>
<a name="ln326">	}</a>
<a name="ln327">	fValid = false;</a>
<a name="ln328">	return false;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331"> </a>
<a name="ln332">/*!	\fn bool PartitionType::IsValid() const</a>
<a name="ln333">	\brief Check whether the current type is valid.</a>
<a name="ln334">*/</a>
<a name="ln335"> </a>
<a name="ln336">/*!	\fn bool PartitionType::IsEmpty() const</a>
<a name="ln337">	\brief Check whether the current type describes empty type.</a>
<a name="ln338">*/</a>
<a name="ln339"> </a>
<a name="ln340">/*!	\fn bool PartitionType::IsExtended() const</a>
<a name="ln341">	\brief Check whether the current type describes extended partition type.</a>
<a name="ln342">*/</a>
<a name="ln343"> </a>
<a name="ln344">/*!	\fn uint8 PartitionType::Type() const</a>
<a name="ln345">	\brief Returns ID of the current type.</a>
<a name="ln346">*/</a>
<a name="ln347"> </a>
<a name="ln348">/*!	\fn void PartitionType::GetTypeString(char *buffer) const</a>
<a name="ln349">	\brief Returns string name of the current type.</a>
<a name="ln350">	\param buffer Buffer where the name is stored, has to be allocated with</a>
<a name="ln351">	sufficient length.</a>
<a name="ln352">*/</a>
<a name="ln353"> </a>
<a name="ln354"> </a>
<a name="ln355">//	#pragma mark - Partition</a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358">Partition::Partition()</a>
<a name="ln359">	:</a>
<a name="ln360">	fPartitionTableOffset(0),</a>
<a name="ln361">	fOffset(0),</a>
<a name="ln362">	fSize(0),</a>
<a name="ln363">	fType(0),</a>
<a name="ln364">	fActive(false)</a>
<a name="ln365">{</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368"> </a>
<a name="ln369">Partition::Partition(const partition_descriptor* descriptor, off_t tableOffset,</a>
<a name="ln370">		off_t baseOffset, uint32 blockSize)</a>
<a name="ln371">	:</a>
<a name="ln372">	fPartitionTableOffset(0),</a>
<a name="ln373">	fOffset(0),</a>
<a name="ln374">	fSize(0),</a>
<a name="ln375">	fType(0),</a>
<a name="ln376">	fActive(false)</a>
<a name="ln377">{</a>
<a name="ln378">	SetTo(descriptor, tableOffset, baseOffset, blockSize);</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381"> </a>
<a name="ln382">void</a>
<a name="ln383">Partition::SetTo(const partition_descriptor* descriptor, off_t tableOffset,</a>
<a name="ln384">	off_t baseOffset, uint32 blockSize)</a>
<a name="ln385">{</a>
<a name="ln386">	TRACE((&quot;Partition::SetTo(): active: %x\n&quot;, descriptor-&gt;active));</a>
<a name="ln387">	SetTo(baseOffset + (off_t)descriptor-&gt;start * blockSize,</a>
<a name="ln388">		(off_t)descriptor-&gt;size * blockSize, descriptor-&gt;type,</a>
<a name="ln389">		descriptor-&gt;active, tableOffset, blockSize);</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392"> </a>
<a name="ln393">void</a>
<a name="ln394">Partition::SetTo(off_t offset, off_t size, uint8 type, bool active,</a>
<a name="ln395">	off_t tableOffset, uint32 blockSize)</a>
<a name="ln396">{</a>
<a name="ln397">	fPartitionTableOffset = tableOffset;</a>
<a name="ln398">	fOffset = offset;</a>
<a name="ln399">	fSize = size;</a>
<a name="ln400">	fType = type;</a>
<a name="ln401">	fActive = active;</a>
<a name="ln402">	fBlockSize = blockSize;</a>
<a name="ln403"> </a>
<a name="ln404">	if (fSize == 0)</a>
<a name="ln405">		Unset();</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408"> </a>
<a name="ln409">void</a>
<a name="ln410">Partition::Unset()</a>
<a name="ln411">{</a>
<a name="ln412">	fPartitionTableOffset = 0;</a>
<a name="ln413">	fOffset = 0;</a>
<a name="ln414">	fSize = 0;</a>
<a name="ln415">	fType = 0;</a>
<a name="ln416">	fActive = false;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419"> </a>
<a name="ln420">bool</a>
<a name="ln421">Partition::CheckLocation(off_t sessionSize) const</a>
<a name="ln422">{</a>
<a name="ln423">	if (fBlockSize == 0)</a>
<a name="ln424">		return false;</a>
<a name="ln425">	// offsets and size must be block aligned, partition table and partition must</a>
<a name="ln426">	// lie within the session</a>
<a name="ln427">	if (fPartitionTableOffset % fBlockSize != 0) {</a>
<a name="ln428">		TRACE((&quot;Partition::CheckLocation() - bad partition table offset: %lld &quot;</a>
<a name="ln429">			&quot;(session: %lld), (fBlockSize: %ld)\n&quot;, fPartitionTableOffset,</a>
<a name="ln430">			sessionSize, fBlockSize));</a>
<a name="ln431">		return false;</a>
<a name="ln432">	}</a>
<a name="ln433">	if (fOffset % fBlockSize != 0) {</a>
<a name="ln434">		TRACE((&quot;Partition::CheckLocation() - bad offset: %lld &quot;</a>
<a name="ln435">			&quot;(session: %lld)\n&quot;, fOffset, sessionSize));</a>
<a name="ln436">		return false;</a>
<a name="ln437">	}</a>
<a name="ln438">	if (fSize % fBlockSize != 0) {</a>
<a name="ln439">		TRACE((&quot;Partition::CheckLocation() - bad size: %lld &quot;</a>
<a name="ln440">			&quot;(session: %lld)\n&quot;, fSize, sessionSize));</a>
<a name="ln441">		return false;</a>
<a name="ln442">	}</a>
<a name="ln443">	if (fPartitionTableOffset &lt; 0 || fPartitionTableOffset &gt;= sessionSize) {</a>
<a name="ln444">		TRACE((&quot;Partition::CheckLocation() - partition table offset outside &quot;</a>
<a name="ln445">			&quot;session: %lld (session size: %lld)\n&quot;, fPartitionTableOffset,</a>
<a name="ln446">			sessionSize));</a>
<a name="ln447">		return false;</a>
<a name="ln448">	}</a>
<a name="ln449">	if (fOffset &lt; 0) {</a>
<a name="ln450">		TRACE((&quot;Partition::CheckLocation() - offset before session: %lld &quot;</a>
<a name="ln451">			&quot;(session: %lld)\n&quot;, fOffset, sessionSize));</a>
<a name="ln452">		return false;</a>
<a name="ln453">	}</a>
<a name="ln454">	if (fOffset + fSize &gt; sessionSize) {</a>
<a name="ln455">		TRACE((&quot;Partition::CheckLocation() - end after session: %lld &quot;</a>
<a name="ln456">			&quot;(session: %lld)\n&quot;, fOffset + fSize, sessionSize));</a>
<a name="ln457">		return false;</a>
<a name="ln458">	}</a>
<a name="ln459">	return true;</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462"> </a>
<a name="ln463">bool</a>
<a name="ln464">Partition::FitSizeToSession(off_t sessionSize)</a>
<a name="ln465">{</a>
<a name="ln466">	// To work around buggy (or older) BIOS, we shrink the partition size to</a>
<a name="ln467">	// always fit into its session - this should improve detection of boot</a>
<a name="ln468">	// partitions (see bug #238 for more information).</a>
<a name="ln469">	// Also, the drive size is obviously reported differently sometimes; this</a>
<a name="ln470">	// should let us read problematic drives - let the file system figure out</a>
<a name="ln471">	// if something is wrong.</a>
<a name="ln472">	if (sessionSize &lt; fOffset + fSize &amp;&amp; sessionSize &gt; fOffset) {</a>
<a name="ln473">		fSize = sessionSize - fOffset;</a>
<a name="ln474">		return true;</a>
<a name="ln475">	}</a>
<a name="ln476"> </a>
<a name="ln477">	return false;</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480"> </a>
<a name="ln481">//	#pragma mark - PrimaryPartition</a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">PrimaryPartition::PrimaryPartition()</a>
<a name="ln485">	:</a>
<a name="ln486">	Partition(),</a>
<a name="ln487">	fHead(NULL),</a>
<a name="ln488">	fTail(NULL),</a>
<a name="ln489">	fLogicalPartitionCount(0)</a>
<a name="ln490">{</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493"> </a>
<a name="ln494">void</a>
<a name="ln495">PrimaryPartition::SetTo(const partition_descriptor* descriptor,</a>
<a name="ln496">	off_t tableOffset, uint32 blockSize)</a>
<a name="ln497">{</a>
<a name="ln498">	Unset();</a>
<a name="ln499">	Partition::SetTo(descriptor, tableOffset, 0, blockSize);</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">void</a>
<a name="ln504">PrimaryPartition::SetTo(off_t offset, off_t size, uint8 type, bool active,</a>
<a name="ln505">	uint32 blockSize)</a>
<a name="ln506">{</a>
<a name="ln507">	Unset();</a>
<a name="ln508">	Partition::SetTo(offset, size, type, active, 0, blockSize);</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">void</a>
<a name="ln513">PrimaryPartition::Unset()</a>
<a name="ln514">{</a>
<a name="ln515">	while (LogicalPartition* partition = fHead) {</a>
<a name="ln516">		fHead = partition-&gt;Next();</a>
<a name="ln517">		delete partition;</a>
<a name="ln518">	}</a>
<a name="ln519">	fHead = NULL;</a>
<a name="ln520">	fTail = NULL;</a>
<a name="ln521">	fLogicalPartitionCount = 0;</a>
<a name="ln522">	Partition::Unset();</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">status_t</a>
<a name="ln527">PrimaryPartition::Assign(const PrimaryPartition&amp; other)</a>
<a name="ln528">{</a>
<a name="ln529">	partition_descriptor descriptor;</a>
<a name="ln530">	other.GetPartitionDescriptor(&amp;descriptor);</a>
<a name="ln531">	SetTo(&amp;descriptor, 0, other.BlockSize());</a>
<a name="ln532"> </a>
<a name="ln533">	const LogicalPartition* otherLogical = other.fHead;</a>
<a name="ln534">	while (otherLogical) {</a>
<a name="ln535">		off_t tableOffset = otherLogical-&gt;PartitionTableOffset();</a>
<a name="ln536">		otherLogical-&gt;GetPartitionDescriptor(&amp;descriptor);</a>
<a name="ln537"> </a>
<a name="ln538">		LogicalPartition* logical = new(nothrow) LogicalPartition(</a>
<a name="ln539">			&amp;descriptor, tableOffset, this);</a>
<a name="ln540">		if (!logical)</a>
<a name="ln541">			return B_NO_MEMORY;</a>
<a name="ln542"> </a>
<a name="ln543">		AddLogicalPartition(logical);</a>
<a name="ln544"> </a>
<a name="ln545">		otherLogical = otherLogical-&gt;Next();</a>
<a name="ln546">	}</a>
<a name="ln547"> </a>
<a name="ln548">	return B_OK;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551"> </a>
<a name="ln552">void</a>
<a name="ln553">PrimaryPartition::GetPartitionDescriptor(partition_descriptor* descriptor) const</a>
<a name="ln554">{</a>
<a name="ln555">	if (IsEmpty()) {</a>
<a name="ln556">		memset(descriptor, 0, sizeof(partition_descriptor));</a>
<a name="ln557">	} else {</a>
<a name="ln558">		descriptor-&gt;start = Offset() / BlockSize();</a>
<a name="ln559">		descriptor-&gt;size = Size() / BlockSize();</a>
<a name="ln560">		descriptor-&gt;type = Type();</a>
<a name="ln561">		descriptor-&gt;active = Active() ? 0x80 : 0x00;</a>
<a name="ln562">		descriptor-&gt;begin.SetUnused();</a>
<a name="ln563">		descriptor-&gt;end.SetUnused();</a>
<a name="ln564">	}</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567"> </a>
<a name="ln568">LogicalPartition*</a>
<a name="ln569">PrimaryPartition::LogicalPartitionAt(int32 index) const</a>
<a name="ln570">{</a>
<a name="ln571">	LogicalPartition* partition = NULL;</a>
<a name="ln572">	if (index &gt;= 0 &amp;&amp; index &lt; fLogicalPartitionCount) {</a>
<a name="ln573">		for (partition = fHead; index &gt; 0; index--)</a>
<a name="ln574">			partition = partition-&gt;Next();</a>
<a name="ln575">	}</a>
<a name="ln576">	return partition;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579"> </a>
<a name="ln580">void</a>
<a name="ln581">PrimaryPartition::AddLogicalPartition(LogicalPartition* partition)</a>
<a name="ln582">{</a>
<a name="ln583">	if (!partition)</a>
<a name="ln584">		return;</a>
<a name="ln585"> </a>
<a name="ln586">	partition-&gt;SetPrimaryPartition(this);</a>
<a name="ln587">	partition-&gt;SetPrevious(fTail);</a>
<a name="ln588">	if (fTail) {</a>
<a name="ln589">		fTail-&gt;SetNext(partition);</a>
<a name="ln590">		fTail = partition;</a>
<a name="ln591">	} else</a>
<a name="ln592">		fHead = fTail = partition;</a>
<a name="ln593"> </a>
<a name="ln594">	partition-&gt;SetNext(NULL);</a>
<a name="ln595"> </a>
<a name="ln596">	fLogicalPartitionCount++;</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599"> </a>
<a name="ln600">void</a>
<a name="ln601">PrimaryPartition::RemoveLogicalPartition(LogicalPartition* partition)</a>
<a name="ln602">{</a>
<a name="ln603">	if (!partition || partition-&gt;GetPrimaryPartition() != this)</a>
<a name="ln604">		return;</a>
<a name="ln605"> </a>
<a name="ln606">	LogicalPartition* prev = partition-&gt;Previous();</a>
<a name="ln607">	LogicalPartition* next = partition-&gt;Next();</a>
<a name="ln608"> </a>
<a name="ln609">	if (prev)</a>
<a name="ln610">		prev-&gt;SetNext(next);</a>
<a name="ln611">	else</a>
<a name="ln612">		fHead = next;</a>
<a name="ln613">	if (next)</a>
<a name="ln614">		next-&gt;SetPrevious(prev);</a>
<a name="ln615">	else</a>
<a name="ln616">		fTail = prev;</a>
<a name="ln617"> </a>
<a name="ln618">	fLogicalPartitionCount--;</a>
<a name="ln619"> </a>
<a name="ln620">	partition-&gt;SetNext(NULL);</a>
<a name="ln621">	partition-&gt;SetPrevious(NULL);</a>
<a name="ln622">	partition-&gt;SetPrimaryPartition(NULL);</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625"> </a>
<a name="ln626">//	#pragma mark - LogicalPartition</a>
<a name="ln627"> </a>
<a name="ln628"> </a>
<a name="ln629">LogicalPartition::LogicalPartition()</a>
<a name="ln630">	:</a>
<a name="ln631">	Partition(),</a>
<a name="ln632">	fPrimary(NULL),</a>
<a name="ln633">	fNext(NULL),</a>
<a name="ln634">	fPrevious(NULL)</a>
<a name="ln635">{</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638"> </a>
<a name="ln639">LogicalPartition::LogicalPartition(const partition_descriptor* descriptor,</a>
<a name="ln640">		off_t tableOffset, PrimaryPartition* primary)</a>
<a name="ln641">	:</a>
<a name="ln642">	Partition(),</a>
<a name="ln643">	fPrimary(NULL),</a>
<a name="ln644">	fNext(NULL),</a>
<a name="ln645">	fPrevious(NULL)</a>
<a name="ln646">{</a>
<a name="ln647">	SetTo(descriptor, tableOffset, primary);</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650"> </a>
<a name="ln651">void</a>
<a name="ln652">LogicalPartition::SetTo(const partition_descriptor* descriptor,</a>
<a name="ln653">	off_t tableOffset, PrimaryPartition* primary)</a>
<a name="ln654">{</a>
<a name="ln655">	Unset();</a>
<a name="ln656">	if (descriptor &amp;&amp; primary) {</a>
<a name="ln657">		// There are two types of LogicalPartitions. There are so called</a>
<a name="ln658">		// &quot;inner extended&quot; partitions and the &quot;real&quot; logical partitions</a>
<a name="ln659">		// which contain data. The &quot;inner extended&quot; partitions don't contain</a>
<a name="ln660">		// data and are only used to point to the next partition table in the</a>
<a name="ln661">		// linked list of logical partitions. For &quot;inner extended&quot; partitions,</a>
<a name="ln662">		// the baseOffset is in relation to the (first sector of the)</a>
<a name="ln663">		// &quot;primary extended&quot; partition, in another words, all inner extended</a>
<a name="ln664">		// partitions use the same base offset for reference.</a>
<a name="ln665">		// The data containing, real logical partitions use the offset of the</a>
<a name="ln666">		// partition table that contains their partition descriptor as their</a>
<a name="ln667">		// baseOffset.</a>
<a name="ln668">		off_t baseOffset = descriptor-&gt;is_extended()</a>
<a name="ln669">			? primary-&gt;Offset() : tableOffset;</a>
<a name="ln670">		Partition::SetTo(descriptor, tableOffset, baseOffset,</a>
<a name="ln671">			primary-&gt;BlockSize());</a>
<a name="ln672">		fPrimary = primary;</a>
<a name="ln673">	}</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676"> </a>
<a name="ln677">void</a>
<a name="ln678">LogicalPartition::SetTo(off_t offset, off_t size, uint8 type, bool active,</a>
<a name="ln679">	off_t tableOffset, PrimaryPartition* primary)</a>
<a name="ln680">{</a>
<a name="ln681">	Unset();</a>
<a name="ln682">	if (primary) {</a>
<a name="ln683">		Partition::SetTo(offset, size, type, active, tableOffset,</a>
<a name="ln684">			primary-&gt;BlockSize());</a>
<a name="ln685">		fPrimary = primary;</a>
<a name="ln686">	}</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689"> </a>
<a name="ln690">void</a>
<a name="ln691">LogicalPartition::Unset()</a>
<a name="ln692">{</a>
<a name="ln693">	fPrimary = NULL;</a>
<a name="ln694">	fNext = NULL;</a>
<a name="ln695">	fPrevious = NULL;</a>
<a name="ln696">	Partition::Unset();</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699"> </a>
<a name="ln700">void</a>
<a name="ln701">LogicalPartition::GetPartitionDescriptor(partition_descriptor* descriptor,</a>
<a name="ln702">	bool inner) const</a>
<a name="ln703">{</a>
<a name="ln704">	PrimaryPartition* primary = GetPrimaryPartition();</a>
<a name="ln705">	if (inner) {</a>
<a name="ln706">		descriptor-&gt;start = (PartitionTableOffset() - primary-&gt;Offset())</a>
<a name="ln707">			/ BlockSize();</a>
<a name="ln708">		descriptor-&gt;type = primary-&gt;Type();</a>
<a name="ln709">	} else {</a>
<a name="ln710">		descriptor-&gt;start = (Offset() - PartitionTableOffset()) / BlockSize();</a>
<a name="ln711">		descriptor-&gt;type = Type();</a>
<a name="ln712">	}</a>
<a name="ln713"> </a>
<a name="ln714">	descriptor-&gt;size = Size() / BlockSize();</a>
<a name="ln715">	descriptor-&gt;active = 0x00;</a>
<a name="ln716">	descriptor-&gt;begin.SetUnused();</a>
<a name="ln717">	descriptor-&gt;end.SetUnused();</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720"> </a>
<a name="ln721">//	#pragma mark - PartitionMap</a>
<a name="ln722"> </a>
<a name="ln723"> </a>
<a name="ln724">PartitionMap::PartitionMap()</a>
<a name="ln725">{</a>
<a name="ln726">	for (int32 i = 0; i &lt; 4; i++)</a>
<a name="ln727">		fPrimaries[i].SetIndex(i);</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730"> </a>
<a name="ln731">PartitionMap::~PartitionMap()</a>
<a name="ln732">{</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735"> </a>
<a name="ln736">void</a>
<a name="ln737">PartitionMap::Unset()</a>
<a name="ln738">{</a>
<a name="ln739">	for (int32 i = 0; i &lt; 4; i++)</a>
<a name="ln740">		fPrimaries[i].Unset();</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743"> </a>
<a name="ln744">status_t</a>
<a name="ln745">PartitionMap::Assign(const PartitionMap&amp; other)</a>
<a name="ln746">{</a>
<a name="ln747">	for (int32 i = 0; i &lt; 4; i++) {</a>
<a name="ln748">		status_t error = fPrimaries[i].Assign(other.fPrimaries[i]);</a>
<a name="ln749">		if (error != B_OK)</a>
<a name="ln750">			return error;</a>
<a name="ln751">	}</a>
<a name="ln752"> </a>
<a name="ln753">	return B_OK;</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756"> </a>
<a name="ln757">PrimaryPartition*</a>
<a name="ln758">PartitionMap::PrimaryPartitionAt(int32 index)</a>
<a name="ln759">{</a>
<a name="ln760">	PrimaryPartition* partition = NULL;</a>
<a name="ln761">	if (index &gt;= 0 &amp;&amp; index &lt; 4)</a>
<a name="ln762">		partition = fPrimaries + index;</a>
<a name="ln763">	return partition;</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766"> </a>
<a name="ln767">const PrimaryPartition*</a>
<a name="ln768">PartitionMap::PrimaryPartitionAt(int32 index) const</a>
<a name="ln769">{</a>
<a name="ln770">	const PrimaryPartition* partition = NULL;</a>
<a name="ln771">	if (index &gt;= 0 &amp;&amp; index &lt; 4)</a>
<a name="ln772">		partition = fPrimaries + index;</a>
<a name="ln773">	return partition;</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777">int32</a>
<a name="ln778">PartitionMap::CountNonEmptyPrimaryPartitions() const</a>
<a name="ln779">{</a>
<a name="ln780">	int32 count = 0;</a>
<a name="ln781">	for (int32 i = 0; i &lt; 4; i++) {</a>
<a name="ln782">		if (!fPrimaries[i].IsEmpty())</a>
<a name="ln783">			count++;</a>
<a name="ln784">	}</a>
<a name="ln785"> </a>
<a name="ln786">	return count;</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789"> </a>
<a name="ln790">int32</a>
<a name="ln791">PartitionMap::ExtendedPartitionIndex() const</a>
<a name="ln792">{</a>
<a name="ln793">	for (int32 i = 0; i &lt; 4; i++) {</a>
<a name="ln794">		if (fPrimaries[i].IsExtended())</a>
<a name="ln795">			return i;</a>
<a name="ln796">	}</a>
<a name="ln797"> </a>
<a name="ln798">	return -1;</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801"> </a>
<a name="ln802">int32</a>
<a name="ln803">PartitionMap::CountPartitions() const</a>
<a name="ln804">{</a>
<a name="ln805">	int32 count = 4;</a>
<a name="ln806">	for (int32 i = 0; i &lt; 4; i++)</a>
<a name="ln807">		count += fPrimaries[i].CountLogicalPartitions();</a>
<a name="ln808">	return count;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811"> </a>
<a name="ln812">int32</a>
<a name="ln813">PartitionMap::CountNonEmptyPartitions() const</a>
<a name="ln814">{</a>
<a name="ln815">	int32 count = 0;</a>
<a name="ln816">	for (int32 i = CountPartitions() - 1; i &gt;= 0; i--) {</a>
<a name="ln817">		if (!PartitionAt(i)-&gt;IsEmpty())</a>
<a name="ln818">			count++;</a>
<a name="ln819">	}</a>
<a name="ln820"> </a>
<a name="ln821">	return count;</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">Partition*</a>
<a name="ln826">PartitionMap::PartitionAt(int32 index)</a>
<a name="ln827">{</a>
<a name="ln828">	Partition* partition = NULL;</a>
<a name="ln829">	int32 count = CountPartitions();</a>
<a name="ln830">	if (index &gt;= 0 &amp;&amp; index &lt; count) {</a>
<a name="ln831">		if (index &lt; 4)</a>
<a name="ln832">			partition  = fPrimaries + index;</a>
<a name="ln833">		else {</a>
<a name="ln834">			index -= 4;</a>
<a name="ln835">			int32 primary = 0;</a>
<a name="ln836">			while (index &gt;= fPrimaries[primary].CountLogicalPartitions()) {</a>
<a name="ln837">				index -= fPrimaries[primary].CountLogicalPartitions();</a>
<a name="ln838">				primary++;</a>
<a name="ln839">			}</a>
<a name="ln840">			partition = fPrimaries[primary].LogicalPartitionAt(index);</a>
<a name="ln841">		}</a>
<a name="ln842">	}</a>
<a name="ln843">	return partition;</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846"> </a>
<a name="ln847">const Partition*</a>
<a name="ln848">PartitionMap::PartitionAt(int32 index) const</a>
<a name="ln849">{</a>
<a name="ln850">	return const_cast&lt;PartitionMap*&gt;(this)-&gt;PartitionAt(index);</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853"> </a>
<a name="ln854">bool</a>
<a name="ln855">PartitionMap::Check(off_t sessionSize) const</a>
<a name="ln856">{</a>
<a name="ln857">	int32 partitionCount = CountPartitions();</a>
<a name="ln858"> </a>
<a name="ln859">	// 1. check partition locations</a>
<a name="ln860">	for (int32 i = 0; i &lt; partitionCount; i++) {</a>
<a name="ln861">		if (!PartitionAt(i)-&gt;CheckLocation(sessionSize))</a>
<a name="ln862">			return false;</a>
<a name="ln863">	}</a>
<a name="ln864"> </a>
<a name="ln865">	// 2. check overlapping of partitions and location of partition tables</a>
<a name="ln866">	bool result = true;</a>
<a name="ln867">	Partition** byOffset = new(nothrow) Partition*[partitionCount];</a>
<a name="ln868">	off_t* tableOffsets = new(nothrow) off_t[partitionCount - 3];</a>
<a name="ln869">	if (byOffset &amp;&amp; tableOffsets) {</a>
<a name="ln870">		// fill the arrays</a>
<a name="ln871">		int32 byOffsetCount = 0;</a>
<a name="ln872">		int32 tableOffsetCount = 1;	// primary partition table</a>
<a name="ln873">		tableOffsets[0] = 0;</a>
<a name="ln874">		for (int32 i = 0; i &lt; partitionCount; i++) {</a>
<a name="ln875">			Partition* partition = (Partition*)PartitionAt(i);</a>
<a name="ln876">			if (!partition-&gt;IsExtended())</a>
<a name="ln877">				byOffset[byOffsetCount++] = partition;</a>
<a name="ln878"> </a>
<a name="ln879">			// add only logical partition partition table locations</a>
<a name="ln880">			if (i &gt;= 4) {</a>
<a name="ln881">				tableOffsets[tableOffsetCount++]</a>
<a name="ln882">					= partition-&gt;PartitionTableOffset();</a>
<a name="ln883">			}</a>
<a name="ln884">		}</a>
<a name="ln885"> </a>
<a name="ln886">		// sort the arrays</a>
<a name="ln887">		qsort(byOffset, byOffsetCount, sizeof(Partition*),</a>
<a name="ln888">			cmp_partition_offset);</a>
<a name="ln889">		qsort(tableOffsets, tableOffsetCount, sizeof(off_t), cmp_offset);</a>
<a name="ln890"> </a>
<a name="ln891">		// check for overlappings</a>
<a name="ln892">		off_t nextOffset = 0;</a>
<a name="ln893">		for (int32 i = 0; i &lt; byOffsetCount; i++) {</a>
<a name="ln894">			Partition* partition = byOffset[i];</a>
<a name="ln895">			if (partition-&gt;Offset() &lt; nextOffset &amp;&amp; i &gt; 0) {</a>
<a name="ln896">				Partition* previousPartition = byOffset[i - 1];</a>
<a name="ln897">				off_t previousSize = previousPartition-&gt;Size()</a>
<a name="ln898">					- (nextOffset - partition-&gt;Offset());</a>
<a name="ln899">				TRACE((&quot;intel: PartitionMap::Check(): &quot;));</a>
<a name="ln900">				if (previousSize == 0) {</a>
<a name="ln901">					previousPartition-&gt;Unset();</a>
<a name="ln902">					TRACE((&quot;partition offset hides previous partition.&quot;</a>
<a name="ln903">						&quot; Removing previous partition from disk layout.\n&quot;));</a>
<a name="ln904">				} else {</a>
<a name="ln905">					TRACE((&quot;overlapping partitions! Setting partition %ld &quot;</a>
<a name="ln906">						&quot;size to %lld\n&quot;, i - 1, previousSize));</a>
<a name="ln907">					previousPartition-&gt;SetSize(previousSize);</a>
<a name="ln908">				}</a>
<a name="ln909">			}</a>
<a name="ln910">			nextOffset = partition-&gt;Offset() + partition-&gt;Size();</a>
<a name="ln911">		}</a>
<a name="ln912"> </a>
<a name="ln913">		// check uniqueness of partition table offsets and whether they lie</a>
<a name="ln914">		// outside of the non-extended partitions</a>
<a name="ln915">		if (result) {</a>
<a name="ln916">			for (int32 i = 0; i &lt; tableOffsetCount; i++) {</a>
<a name="ln917">				if (i &gt; 0 &amp;&amp; tableOffsets[i] == tableOffsets[i - 1]) {</a>
<a name="ln918">					TRACE((&quot;intel: PartitionMap::Check(): same partition table &quot;</a>
<a name="ln919">						&quot;for different extended partitions!\n&quot;));</a>
<a name="ln920">					result = false;</a>
<a name="ln921">					break;</a>
<a name="ln922">				} else if (is_inside_partitions(tableOffsets[i],</a>
<a name="ln923">						(const Partition**)byOffset, byOffsetCount)) {</a>
<a name="ln924">					TRACE((&quot;intel: PartitionMap::Check(): a partition table &quot;</a>
<a name="ln925">						&quot;lies inside a non-extended partition!\n&quot;));</a>
<a name="ln926">					result = false;</a>
<a name="ln927">					break;</a>
<a name="ln928">				}</a>
<a name="ln929">			}</a>
<a name="ln930">		}</a>
<a name="ln931">	} else</a>
<a name="ln932">		result = false;		// no memory: assume failure</a>
<a name="ln933"> </a>
<a name="ln934">	// cleanup</a>
<a name="ln935">	delete[] byOffset;</a>
<a name="ln936">	delete[] tableOffsets;</a>
<a name="ln937"> </a>
<a name="ln938">	return result;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941"> </a>
<a name="ln942">const partition_type*</a>
<a name="ln943">PartitionMap::GetNextSupportedPartitionType(uint32 index)</a>
<a name="ln944">{</a>
<a name="ln945">	if (index &gt; (sizeof(kPartitionTypes) / sizeof(partition_type) - 2))</a>
<a name="ln946">		return NULL;</a>
<a name="ln947"> </a>
<a name="ln948">	return kPartitionTypes + index;</a>
<a name="ln949">}</a>

</code></pre>
<div class="balloon" rel="358"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fBlockSize.</p></div>
<div class="balloon" rel="484"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fIndex.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
