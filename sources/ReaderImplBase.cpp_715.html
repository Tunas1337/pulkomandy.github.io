
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ReaderImplBase.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2014, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2011, Oliver Tappe &lt;zooey@hirschkaefer.de&gt;</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;package/hpkg/ReaderImplBase.h&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;errno.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14">#include &lt;unistd.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;algorithm&gt;</a>
<a name="ln17">#include &lt;new&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;ByteOrder.h&gt;</a>
<a name="ln20">#include &lt;DataIO.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;ZlibCompressionAlgorithm.h&gt;</a>
<a name="ln23">#ifdef ZSTD_ENABLED</a>
<a name="ln24">#include &lt;ZstdCompressionAlgorithm.h&gt;</a>
<a name="ln25">#endif</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;package/hpkg/HPKGDefsPrivate.h&gt;</a>
<a name="ln28">#include &lt;package/hpkg/PackageFileHeapReader.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">namespace BPackageKit {</a>
<a name="ln32"> </a>
<a name="ln33">namespace BHPKG {</a>
<a name="ln34"> </a>
<a name="ln35">namespace BPrivate {</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">static const uint16 kAttributeTypes[B_HPKG_ATTRIBUTE_ID_ENUM_COUNT] = {</a>
<a name="ln39">	#define B_DEFINE_HPKG_ATTRIBUTE(id, type, name, constant)	\</a>
<a name="ln40">		B_HPKG_ATTRIBUTE_TYPE_##type,</a>
<a name="ln41">	#include &lt;package/hpkg/PackageAttributes.h&gt;</a>
<a name="ln42">	#undef B_DEFINE_HPKG_ATTRIBUTE</a>
<a name="ln43">};</a>
<a name="ln44"> </a>
<a name="ln45">// #pragma mark - AttributeHandlerContext</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">ReaderImplBase::AttributeHandlerContext::AttributeHandlerContext(</a>
<a name="ln49">	BErrorOutput* errorOutput, BPackageContentHandler* packageContentHandler,</a>
<a name="ln50">	BHPKGPackageSectionID section, bool ignoreUnknownAttributes)</a>
<a name="ln51">	:</a>
<a name="ln52">	errorOutput(errorOutput),</a>
<a name="ln53">	packageContentHandler(packageContentHandler),</a>
<a name="ln54">	hasLowLevelHandler(false),</a>
<a name="ln55">	ignoreUnknownAttributes(ignoreUnknownAttributes),</a>
<a name="ln56">	section(section)</a>
<a name="ln57">{</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">ReaderImplBase::AttributeHandlerContext::AttributeHandlerContext(</a>
<a name="ln62">	BErrorOutput* errorOutput, BLowLevelPackageContentHandler* lowLevelHandler,</a>
<a name="ln63">	BHPKGPackageSectionID section, bool ignoreUnknownAttributes)</a>
<a name="ln64">	:</a>
<a name="ln65">	errorOutput(errorOutput),</a>
<a name="ln66">	lowLevelHandler(lowLevelHandler),</a>
<a name="ln67">	hasLowLevelHandler(true),</a>
<a name="ln68">	ignoreUnknownAttributes(ignoreUnknownAttributes),</a>
<a name="ln69">	section(section)</a>
<a name="ln70">{</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">void</a>
<a name="ln75">ReaderImplBase::AttributeHandlerContext::ErrorOccurred()</a>
<a name="ln76">{</a>
<a name="ln77">	if (hasLowLevelHandler)</a>
<a name="ln78">		lowLevelHandler-&gt;HandleErrorOccurred();</a>
<a name="ln79">	else</a>
<a name="ln80">		packageContentHandler-&gt;HandleErrorOccurred();</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">// #pragma mark - AttributeHandler</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">ReaderImplBase::AttributeHandler::~AttributeHandler()</a>
<a name="ln88">{</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">void</a>
<a name="ln93">ReaderImplBase::AttributeHandler::SetLevel(int level)</a>
<a name="ln94">{</a>
<a name="ln95">	fLevel = level;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">status_t</a>
<a name="ln100">ReaderImplBase::AttributeHandler::HandleAttribute(</a>
<a name="ln101">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln102">	AttributeHandler** _handler)</a>
<a name="ln103">{</a>
<a name="ln104">	return B_OK;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">status_t</a>
<a name="ln109">ReaderImplBase::AttributeHandler::NotifyDone(</a>
<a name="ln110">	AttributeHandlerContext* context)</a>
<a name="ln111">{</a>
<a name="ln112">	return B_OK;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116">status_t</a>
<a name="ln117">ReaderImplBase::AttributeHandler::Delete(AttributeHandlerContext* context)</a>
<a name="ln118">{</a>
<a name="ln119">	delete this;</a>
<a name="ln120">	return B_OK;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123"> </a>
<a name="ln124">// #pragma mark - PackageInfoAttributeHandlerBase</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">ReaderImplBase::PackageInfoAttributeHandlerBase</a>
<a name="ln128">	::PackageInfoAttributeHandlerBase(</a>
<a name="ln129">		BPackageInfoAttributeValue&amp; packageInfoValue)</a>
<a name="ln130">	:</a>
<a name="ln131">	fPackageInfoValue(packageInfoValue)</a>
<a name="ln132">{</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135"> </a>
<a name="ln136">status_t</a>
<a name="ln137">ReaderImplBase::PackageInfoAttributeHandlerBase::NotifyDone(</a>
<a name="ln138">	AttributeHandlerContext* context)</a>
<a name="ln139">{</a>
<a name="ln140">	status_t error = context-&gt;packageContentHandler-&gt;HandlePackageAttribute(</a>
<a name="ln141">		fPackageInfoValue);</a>
<a name="ln142">	fPackageInfoValue.Clear();</a>
<a name="ln143">	return error;</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146"> </a>
<a name="ln147">// #pragma mark - PackageVersionAttributeHandler</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150">ReaderImplBase::PackageVersionAttributeHandler::PackageVersionAttributeHandler(</a>
<a name="ln151">	BPackageInfoAttributeValue&amp; packageInfoValue,</a>
<a name="ln152">	BPackageVersionData&amp; versionData, bool notify)</a>
<a name="ln153">	:</a>
<a name="ln154">	super(packageInfoValue),</a>
<a name="ln155">	fPackageVersionData(versionData),</a>
<a name="ln156">	fNotify(notify)</a>
<a name="ln157">{</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">status_t</a>
<a name="ln162">ReaderImplBase::PackageVersionAttributeHandler::HandleAttribute(</a>
<a name="ln163">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln164">	AttributeHandler** _handler)</a>
<a name="ln165">{</a>
<a name="ln166">	switch (id) {</a>
<a name="ln167">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MINOR:</a>
<a name="ln168">			fPackageVersionData.minor = value.string;</a>
<a name="ln169">			break;</a>
<a name="ln170"> </a>
<a name="ln171">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MICRO:</a>
<a name="ln172">			fPackageVersionData.micro = value.string;</a>
<a name="ln173">			break;</a>
<a name="ln174"> </a>
<a name="ln175">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_PRE_RELEASE:</a>
<a name="ln176">			fPackageVersionData.preRelease = value.string;</a>
<a name="ln177">			break;</a>
<a name="ln178"> </a>
<a name="ln179">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_REVISION:</a>
<a name="ln180">			fPackageVersionData.revision = value.unsignedInt;</a>
<a name="ln181">			break;</a>
<a name="ln182"> </a>
<a name="ln183">		default:</a>
<a name="ln184">			if (context-&gt;ignoreUnknownAttributes)</a>
<a name="ln185">				break;</a>
<a name="ln186"> </a>
<a name="ln187">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln188">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln189">				&quot;encountered when parsing package version\n&quot;, id);</a>
<a name="ln190">			return B_BAD_DATA;</a>
<a name="ln191">	}</a>
<a name="ln192"> </a>
<a name="ln193">	return B_OK;</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">status_t</a>
<a name="ln198">ReaderImplBase::PackageVersionAttributeHandler::NotifyDone(</a>
<a name="ln199">	AttributeHandlerContext* context)</a>
<a name="ln200">{</a>
<a name="ln201">	if (!fNotify)</a>
<a name="ln202">		return B_OK;</a>
<a name="ln203"> </a>
<a name="ln204">	fPackageInfoValue.attributeID = B_PACKAGE_INFO_VERSION;</a>
<a name="ln205">	return super::NotifyDone(context);</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208"> </a>
<a name="ln209">// #pragma mark - PackageResolvableAttributeHandler</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">ReaderImplBase::PackageResolvableAttributeHandler</a>
<a name="ln213">	::PackageResolvableAttributeHandler(</a>
<a name="ln214">		BPackageInfoAttributeValue&amp; packageInfoValue)</a>
<a name="ln215">	:</a>
<a name="ln216">	super(packageInfoValue)</a>
<a name="ln217">{</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220"> </a>
<a name="ln221">status_t</a>
<a name="ln222">ReaderImplBase::PackageResolvableAttributeHandler::HandleAttribute(</a>
<a name="ln223">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln224">	AttributeHandler** _handler)</a>
<a name="ln225">{</a>
<a name="ln226">	switch (id) {</a>
<a name="ln227">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MAJOR:</a>
<a name="ln228">			fPackageInfoValue.resolvable.haveVersion = true;</a>
<a name="ln229">			fPackageInfoValue.resolvable.version.major = value.string;</a>
<a name="ln230">			if (_handler != NULL) {</a>
<a name="ln231">				*_handler</a>
<a name="ln232">					= new(std::nothrow) PackageVersionAttributeHandler(</a>
<a name="ln233">						fPackageInfoValue,</a>
<a name="ln234">						fPackageInfoValue.resolvable.version, false);</a>
<a name="ln235">				if (*_handler == NULL)</a>
<a name="ln236">					return B_NO_MEMORY;</a>
<a name="ln237">			}</a>
<a name="ln238">			break;</a>
<a name="ln239"> </a>
<a name="ln240">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_PROVIDES_COMPATIBLE:</a>
<a name="ln241">			fPackageInfoValue.resolvable.haveCompatibleVersion = true;</a>
<a name="ln242">			fPackageInfoValue.resolvable.compatibleVersion.major = value.string;</a>
<a name="ln243">			if (_handler != NULL) {</a>
<a name="ln244">				*_handler</a>
<a name="ln245">					= new(std::nothrow) PackageVersionAttributeHandler(</a>
<a name="ln246">						fPackageInfoValue,</a>
<a name="ln247">						fPackageInfoValue.resolvable.compatibleVersion, false);</a>
<a name="ln248">				if (*_handler == NULL)</a>
<a name="ln249">					return B_NO_MEMORY;</a>
<a name="ln250">			}</a>
<a name="ln251">			break;</a>
<a name="ln252"> </a>
<a name="ln253">		default:</a>
<a name="ln254">			if (context-&gt;ignoreUnknownAttributes)</a>
<a name="ln255">				break;</a>
<a name="ln256"> </a>
<a name="ln257">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln258">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln259">				&quot;encountered when parsing package resolvable\n&quot;, id);</a>
<a name="ln260">			return B_BAD_DATA;</a>
<a name="ln261">	}</a>
<a name="ln262"> </a>
<a name="ln263">	return B_OK;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">// #pragma mark - PackageResolvableExpressionAttributeHandler</a>
<a name="ln268"> </a>
<a name="ln269"> </a>
<a name="ln270">ReaderImplBase::PackageResolvableExpressionAttributeHandler</a>
<a name="ln271">	::PackageResolvableExpressionAttributeHandler(</a>
<a name="ln272">		BPackageInfoAttributeValue&amp; packageInfoValue)</a>
<a name="ln273">	:</a>
<a name="ln274">	super(packageInfoValue)</a>
<a name="ln275">{</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278"> </a>
<a name="ln279">status_t</a>
<a name="ln280">ReaderImplBase::PackageResolvableExpressionAttributeHandler::HandleAttribute(</a>
<a name="ln281">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln282">	AttributeHandler** _handler)</a>
<a name="ln283">{</a>
<a name="ln284">	switch (id) {</a>
<a name="ln285">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_RESOLVABLE_OPERATOR:</a>
<a name="ln286">			if (value.unsignedInt &gt;= B_PACKAGE_RESOLVABLE_OP_ENUM_COUNT) {</a>
<a name="ln287">				context-&gt;errorOutput-&gt;PrintError(</a>
<a name="ln288">					&quot;Error: Invalid package attribute section: invalid &quot;</a>
<a name="ln289">					&quot;package resolvable operator %lld encountered\n&quot;,</a>
<a name="ln290">					value.unsignedInt);</a>
<a name="ln291">				return B_BAD_DATA;</a>
<a name="ln292">			}</a>
<a name="ln293">			fPackageInfoValue.resolvableExpression.op</a>
<a name="ln294">				= (BPackageResolvableOperator)value.unsignedInt;</a>
<a name="ln295">			break;</a>
<a name="ln296"> </a>
<a name="ln297">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MAJOR:</a>
<a name="ln298">			fPackageInfoValue.resolvableExpression.haveOpAndVersion = true;</a>
<a name="ln299">			fPackageInfoValue.resolvableExpression.version.major</a>
<a name="ln300">				= value.string;</a>
<a name="ln301">			if (_handler != NULL) {</a>
<a name="ln302">				*_handler</a>
<a name="ln303">					= new(std::nothrow) PackageVersionAttributeHandler(</a>
<a name="ln304">						fPackageInfoValue,</a>
<a name="ln305">						fPackageInfoValue.resolvableExpression.version,</a>
<a name="ln306">						false);</a>
<a name="ln307">				if (*_handler == NULL)</a>
<a name="ln308">					return B_NO_MEMORY;</a>
<a name="ln309">			}</a>
<a name="ln310">			return B_OK;</a>
<a name="ln311"> </a>
<a name="ln312">		default:</a>
<a name="ln313">			if (context-&gt;ignoreUnknownAttributes)</a>
<a name="ln314">				break;</a>
<a name="ln315"> </a>
<a name="ln316">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln317">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln318">				&quot;encountered when parsing package resolvable-expression\n&quot;,</a>
<a name="ln319">				id);</a>
<a name="ln320">			return B_BAD_DATA;</a>
<a name="ln321">	}</a>
<a name="ln322"> </a>
<a name="ln323">	return B_OK;</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326"> </a>
<a name="ln327">// #pragma mark - GlobalWritableFileInfoAttributeHandler</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">ReaderImplBase::GlobalWritableFileInfoAttributeHandler</a>
<a name="ln331">	::GlobalWritableFileInfoAttributeHandler(</a>
<a name="ln332">		BPackageInfoAttributeValue&amp; packageInfoValue)</a>
<a name="ln333">	:</a>
<a name="ln334">	super(packageInfoValue)</a>
<a name="ln335">{</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338"> </a>
<a name="ln339">status_t</a>
<a name="ln340">ReaderImplBase::GlobalWritableFileInfoAttributeHandler::HandleAttribute(</a>
<a name="ln341">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln342">	AttributeHandler** _handler)</a>
<a name="ln343">{</a>
<a name="ln344">	switch (id) {</a>
<a name="ln345">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_WRITABLE_FILE_UPDATE_TYPE:</a>
<a name="ln346">			if (value.unsignedInt &gt;= B_WRITABLE_FILE_UPDATE_TYPE_ENUM_COUNT) {</a>
<a name="ln347">				context-&gt;errorOutput-&gt;PrintError(</a>
<a name="ln348">					&quot;Error: Invalid package attribute section: invalid &quot;</a>
<a name="ln349">					&quot;global settings file update type %&quot; B_PRIu64</a>
<a name="ln350">					&quot; encountered\n&quot;, value.unsignedInt);</a>
<a name="ln351">				return B_BAD_DATA;</a>
<a name="ln352">			}</a>
<a name="ln353">			fPackageInfoValue.globalWritableFileInfo.updateType</a>
<a name="ln354">				= (BWritableFileUpdateType)value.unsignedInt;</a>
<a name="ln355">			break;</a>
<a name="ln356"> </a>
<a name="ln357">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_IS_WRITABLE_DIRECTORY:</a>
<a name="ln358">			fPackageInfoValue.globalWritableFileInfo.isDirectory</a>
<a name="ln359">				= value.unsignedInt != 0;</a>
<a name="ln360">			break;</a>
<a name="ln361"> </a>
<a name="ln362">		default:</a>
<a name="ln363">			if (context-&gt;ignoreUnknownAttributes)</a>
<a name="ln364">				break;</a>
<a name="ln365"> </a>
<a name="ln366">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln367">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln368">				&quot;encountered when parsing global settings file info\n&quot;,</a>
<a name="ln369">				id);</a>
<a name="ln370">			return B_BAD_DATA;</a>
<a name="ln371">	}</a>
<a name="ln372"> </a>
<a name="ln373">	return B_OK;</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376"> </a>
<a name="ln377">// #pragma mark - UserSettingsFileInfoAttributeHandler</a>
<a name="ln378"> </a>
<a name="ln379"> </a>
<a name="ln380">ReaderImplBase::UserSettingsFileInfoAttributeHandler</a>
<a name="ln381">	::UserSettingsFileInfoAttributeHandler(</a>
<a name="ln382">		BPackageInfoAttributeValue&amp; packageInfoValue)</a>
<a name="ln383">	:</a>
<a name="ln384">	super(packageInfoValue)</a>
<a name="ln385">{</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388"> </a>
<a name="ln389">status_t</a>
<a name="ln390">ReaderImplBase::UserSettingsFileInfoAttributeHandler::HandleAttribute(</a>
<a name="ln391">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln392">	AttributeHandler** _handler)</a>
<a name="ln393">{</a>
<a name="ln394">	switch (id) {</a>
<a name="ln395">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_SETTINGS_FILE_TEMPLATE:</a>
<a name="ln396">			fPackageInfoValue.userSettingsFileInfo.templatePath = value.string;</a>
<a name="ln397">			break;</a>
<a name="ln398"> </a>
<a name="ln399">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_IS_WRITABLE_DIRECTORY:</a>
<a name="ln400">			fPackageInfoValue.userSettingsFileInfo.isDirectory</a>
<a name="ln401">				= value.unsignedInt != 0;</a>
<a name="ln402">			break;</a>
<a name="ln403"> </a>
<a name="ln404">		default:</a>
<a name="ln405">			if (context-&gt;ignoreUnknownAttributes)</a>
<a name="ln406">				break;</a>
<a name="ln407"> </a>
<a name="ln408">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln409">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln410">				&quot;encountered when parsing user settings file info\n&quot;,</a>
<a name="ln411">				id);</a>
<a name="ln412">			return B_BAD_DATA;</a>
<a name="ln413">	}</a>
<a name="ln414"> </a>
<a name="ln415">	return B_OK;</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418"> </a>
<a name="ln419">// #pragma mark - UserAttributeHandler</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">ReaderImplBase::UserAttributeHandler::UserAttributeHandler(</a>
<a name="ln423">		BPackageInfoAttributeValue&amp; packageInfoValue)</a>
<a name="ln424">	:</a>
<a name="ln425">	super(packageInfoValue),</a>
<a name="ln426">	fGroups()</a>
<a name="ln427">{</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430"> </a>
<a name="ln431">status_t</a>
<a name="ln432">ReaderImplBase::UserAttributeHandler::HandleAttribute(</a>
<a name="ln433">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln434">	AttributeHandler** _handler)</a>
<a name="ln435">{</a>
<a name="ln436">	switch (id) {</a>
<a name="ln437">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_USER_REAL_NAME:</a>
<a name="ln438">			fPackageInfoValue.user.realName = value.string;</a>
<a name="ln439">			break;</a>
<a name="ln440"> </a>
<a name="ln441">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_USER_HOME:</a>
<a name="ln442">			fPackageInfoValue.user.home = value.string;</a>
<a name="ln443">			break;</a>
<a name="ln444"> </a>
<a name="ln445">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_USER_SHELL:</a>
<a name="ln446">			fPackageInfoValue.user.shell = value.string;</a>
<a name="ln447">			break;</a>
<a name="ln448"> </a>
<a name="ln449">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_USER_GROUP:</a>
<a name="ln450">			if (!fGroups.Add(value.string))</a>
<a name="ln451">				return B_NO_MEMORY;</a>
<a name="ln452">			break;</a>
<a name="ln453"> </a>
<a name="ln454">		default:</a>
<a name="ln455">			if (context-&gt;ignoreUnknownAttributes)</a>
<a name="ln456">				break;</a>
<a name="ln457"> </a>
<a name="ln458">			context-&gt;errorOutput-&gt;PrintError(&quot;Error: Invalid package &quot;</a>
<a name="ln459">				&quot;attribute section: unexpected package attribute id %d &quot;</a>
<a name="ln460">				&quot;encountered when parsing user settings file info\n&quot;,</a>
<a name="ln461">				id);</a>
<a name="ln462">			return B_BAD_DATA;</a>
<a name="ln463">	}</a>
<a name="ln464"> </a>
<a name="ln465">	return B_OK;</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468"> </a>
<a name="ln469">status_t</a>
<a name="ln470">ReaderImplBase::UserAttributeHandler::NotifyDone(</a>
<a name="ln471">	AttributeHandlerContext* context)</a>
<a name="ln472">{</a>
<a name="ln473">	if (!fGroups.IsEmpty()) {</a>
<a name="ln474">		fPackageInfoValue.user.groups = fGroups.Elements();</a>
<a name="ln475">		fPackageInfoValue.user.groupCount = fGroups.Count();</a>
<a name="ln476">	}</a>
<a name="ln477"> </a>
<a name="ln478">	return super::NotifyDone(context);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481"> </a>
<a name="ln482">// #pragma mark - PackageAttributeHandler</a>
<a name="ln483"> </a>
<a name="ln484"> </a>
<a name="ln485">status_t</a>
<a name="ln486">ReaderImplBase::PackageAttributeHandler::HandleAttribute(</a>
<a name="ln487">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln488">	AttributeHandler** _handler)</a>
<a name="ln489">{</a>
<a name="ln490">	switch (id) {</a>
<a name="ln491">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_NAME:</a>
<a name="ln492">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_NAME, value.string);</a>
<a name="ln493">			break;</a>
<a name="ln494"> </a>
<a name="ln495">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_SUMMARY:</a>
<a name="ln496">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_SUMMARY, value.string);</a>
<a name="ln497">			break;</a>
<a name="ln498"> </a>
<a name="ln499">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_DESCRIPTION:</a>
<a name="ln500">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_DESCRIPTION,</a>
<a name="ln501">				value.string);</a>
<a name="ln502">			break;</a>
<a name="ln503"> </a>
<a name="ln504">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VENDOR:</a>
<a name="ln505">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_VENDOR, value.string);</a>
<a name="ln506">			break;</a>
<a name="ln507"> </a>
<a name="ln508">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_PACKAGER:</a>
<a name="ln509">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_PACKAGER, value.string);</a>
<a name="ln510">			break;</a>
<a name="ln511"> </a>
<a name="ln512">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_BASE_PACKAGE:</a>
<a name="ln513">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_BASE_PACKAGE, value.string);</a>
<a name="ln514">			break;</a>
<a name="ln515"> </a>
<a name="ln516">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_FLAGS:</a>
<a name="ln517">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_FLAGS,</a>
<a name="ln518">				(uint32)value.unsignedInt);</a>
<a name="ln519">			break;</a>
<a name="ln520"> </a>
<a name="ln521">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_ARCHITECTURE:</a>
<a name="ln522">			if (value.unsignedInt</a>
<a name="ln523">					&gt;= B_PACKAGE_ARCHITECTURE_ENUM_COUNT) {</a>
<a name="ln524">				context-&gt;errorOutput-&gt;PrintError(</a>
<a name="ln525">					&quot;Error: Invalid package attribute section: &quot;</a>
<a name="ln526">					&quot;Invalid package architecture %lld encountered\n&quot;,</a>
<a name="ln527">					value.unsignedInt);</a>
<a name="ln528">				return B_BAD_DATA;</a>
<a name="ln529">			}</a>
<a name="ln530">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_ARCHITECTURE,</a>
<a name="ln531">				(uint8)value.unsignedInt);</a>
<a name="ln532">			break;</a>
<a name="ln533"> </a>
<a name="ln534">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_VERSION_MAJOR:</a>
<a name="ln535">			fPackageInfoValue.attributeID = B_PACKAGE_INFO_VERSION;</a>
<a name="ln536">			fPackageInfoValue.version.major = value.string;</a>
<a name="ln537">			if (_handler != NULL) {</a>
<a name="ln538">				*_handler</a>
<a name="ln539">					= new(std::nothrow) PackageVersionAttributeHandler(</a>
<a name="ln540">						fPackageInfoValue, fPackageInfoValue.version, true);</a>
<a name="ln541">				if (*_handler == NULL)</a>
<a name="ln542">					return B_NO_MEMORY;</a>
<a name="ln543">			}</a>
<a name="ln544">			break;</a>
<a name="ln545"> </a>
<a name="ln546">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_COPYRIGHT:</a>
<a name="ln547">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_COPYRIGHTS,</a>
<a name="ln548">				value.string);</a>
<a name="ln549">			break;</a>
<a name="ln550"> </a>
<a name="ln551">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_LICENSE:</a>
<a name="ln552">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_LICENSES,</a>
<a name="ln553">				value.string);</a>
<a name="ln554">			break;</a>
<a name="ln555"> </a>
<a name="ln556">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_URL:</a>
<a name="ln557">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_URLS, value.string);</a>
<a name="ln558">			break;</a>
<a name="ln559"> </a>
<a name="ln560">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_SOURCE_URL:</a>
<a name="ln561">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_SOURCE_URLS, value.string);</a>
<a name="ln562">			break;</a>
<a name="ln563"> </a>
<a name="ln564">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_PROVIDES:</a>
<a name="ln565">			fPackageInfoValue.resolvable.name = value.string;</a>
<a name="ln566">			fPackageInfoValue.attributeID = B_PACKAGE_INFO_PROVIDES;</a>
<a name="ln567">			if (_handler != NULL) {</a>
<a name="ln568">				*_handler</a>
<a name="ln569">					= new(std::nothrow) PackageResolvableAttributeHandler(</a>
<a name="ln570">						fPackageInfoValue);</a>
<a name="ln571">				if (*_handler == NULL)</a>
<a name="ln572">					return B_NO_MEMORY;</a>
<a name="ln573">			}</a>
<a name="ln574">			break;</a>
<a name="ln575"> </a>
<a name="ln576">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_REQUIRES:</a>
<a name="ln577">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_SUPPLEMENTS:</a>
<a name="ln578">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_CONFLICTS:</a>
<a name="ln579">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_FRESHENS:</a>
<a name="ln580">			fPackageInfoValue.resolvableExpression.name = value.string;</a>
<a name="ln581">			switch (id) {</a>
<a name="ln582">				case B_HPKG_ATTRIBUTE_ID_PACKAGE_REQUIRES:</a>
<a name="ln583">					fPackageInfoValue.attributeID = B_PACKAGE_INFO_REQUIRES;</a>
<a name="ln584">					break;</a>
<a name="ln585"> </a>
<a name="ln586">				case B_HPKG_ATTRIBUTE_ID_PACKAGE_SUPPLEMENTS:</a>
<a name="ln587">					fPackageInfoValue.attributeID</a>
<a name="ln588">						= B_PACKAGE_INFO_SUPPLEMENTS;</a>
<a name="ln589">					break;</a>
<a name="ln590"> </a>
<a name="ln591">				case B_HPKG_ATTRIBUTE_ID_PACKAGE_CONFLICTS:</a>
<a name="ln592">					fPackageInfoValue.attributeID</a>
<a name="ln593">						= B_PACKAGE_INFO_CONFLICTS;</a>
<a name="ln594">					break;</a>
<a name="ln595"> </a>
<a name="ln596">				case B_HPKG_ATTRIBUTE_ID_PACKAGE_FRESHENS:</a>
<a name="ln597">					fPackageInfoValue.attributeID = B_PACKAGE_INFO_FRESHENS;</a>
<a name="ln598">					break;</a>
<a name="ln599">			}</a>
<a name="ln600">			if (_handler != NULL) {</a>
<a name="ln601">				*_handler = new(std::nothrow)</a>
<a name="ln602">					PackageResolvableExpressionAttributeHandler(</a>
<a name="ln603">						fPackageInfoValue);</a>
<a name="ln604">				if (*_handler == NULL)</a>
<a name="ln605">					return B_NO_MEMORY;</a>
<a name="ln606">			}</a>
<a name="ln607">			break;</a>
<a name="ln608"> </a>
<a name="ln609">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_REPLACES:</a>
<a name="ln610">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_REPLACES, value.string);</a>
<a name="ln611">			break;</a>
<a name="ln612"> </a>
<a name="ln613">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_CHECKSUM:</a>
<a name="ln614">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_CHECKSUM, value.string);</a>
<a name="ln615">			break;</a>
<a name="ln616"> </a>
<a name="ln617">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_INSTALL_PATH:</a>
<a name="ln618">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_INSTALL_PATH, value.string);</a>
<a name="ln619">			break;</a>
<a name="ln620"> </a>
<a name="ln621">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_GLOBAL_WRITABLE_FILE:</a>
<a name="ln622">			fPackageInfoValue.globalWritableFileInfo.path = value.string;</a>
<a name="ln623">			fPackageInfoValue.globalWritableFileInfo.updateType</a>
<a name="ln624">				= B_WRITABLE_FILE_UPDATE_TYPE_ENUM_COUNT;</a>
<a name="ln625">			fPackageInfoValue.attributeID</a>
<a name="ln626">				= B_PACKAGE_INFO_GLOBAL_WRITABLE_FILES;</a>
<a name="ln627">			if (_handler != NULL) {</a>
<a name="ln628">				*_handler</a>
<a name="ln629">					= new(std::nothrow) GlobalWritableFileInfoAttributeHandler(</a>
<a name="ln630">						fPackageInfoValue);</a>
<a name="ln631">				if (*_handler == NULL)</a>
<a name="ln632">					return B_NO_MEMORY;</a>
<a name="ln633">			}</a>
<a name="ln634">			break;</a>
<a name="ln635"> </a>
<a name="ln636">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_USER_SETTINGS_FILE:</a>
<a name="ln637">			fPackageInfoValue.userSettingsFileInfo.path = value.string;</a>
<a name="ln638">			fPackageInfoValue.attributeID</a>
<a name="ln639">				= B_PACKAGE_INFO_USER_SETTINGS_FILES;</a>
<a name="ln640">			if (_handler != NULL) {</a>
<a name="ln641">				*_handler</a>
<a name="ln642">					= new(std::nothrow) UserSettingsFileInfoAttributeHandler(</a>
<a name="ln643">						fPackageInfoValue);</a>
<a name="ln644">				if (*_handler == NULL)</a>
<a name="ln645">					return B_NO_MEMORY;</a>
<a name="ln646">			}</a>
<a name="ln647">			break;</a>
<a name="ln648"> </a>
<a name="ln649">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_USER:</a>
<a name="ln650">			fPackageInfoValue.user.name = value.string;</a>
<a name="ln651">			fPackageInfoValue.attributeID = B_PACKAGE_INFO_USERS;</a>
<a name="ln652">			if (_handler != NULL) {</a>
<a name="ln653">				*_handler = new(std::nothrow) UserAttributeHandler(</a>
<a name="ln654">					fPackageInfoValue);</a>
<a name="ln655">				if (*_handler == NULL)</a>
<a name="ln656">					return B_NO_MEMORY;</a>
<a name="ln657">			}</a>
<a name="ln658">			break;</a>
<a name="ln659"> </a>
<a name="ln660">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_GROUP:</a>
<a name="ln661">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_GROUPS, value.string);</a>
<a name="ln662">			break;</a>
<a name="ln663"> </a>
<a name="ln664">		case B_HPKG_ATTRIBUTE_ID_PACKAGE_POST_INSTALL_SCRIPT:</a>
<a name="ln665">			fPackageInfoValue.SetTo(B_PACKAGE_INFO_POST_INSTALL_SCRIPTS,</a>
<a name="ln666">				value.string);</a>
<a name="ln667">			break;</a>
<a name="ln668"> </a>
<a name="ln669">		default:</a>
<a name="ln670">			if (context-&gt;ignoreUnknownAttributes)</a>
<a name="ln671">				break;</a>
<a name="ln672"> </a>
<a name="ln673">			context-&gt;errorOutput-&gt;PrintError(</a>
<a name="ln674">				&quot;Error: Invalid package attribute section: unexpected &quot;</a>
<a name="ln675">				&quot;package attribute id %d encountered\n&quot;, id);</a>
<a name="ln676">			return B_BAD_DATA;</a>
<a name="ln677">	}</a>
<a name="ln678"> </a>
<a name="ln679">	// notify unless the current attribute has children, in which case</a>
<a name="ln680">	// the child-handler will notify when it's done</a>
<a name="ln681">	if (_handler == NULL) {</a>
<a name="ln682">		status_t error = context-&gt;packageContentHandler</a>
<a name="ln683">			-&gt;HandlePackageAttribute(fPackageInfoValue);</a>
<a name="ln684">		fPackageInfoValue.Clear();</a>
<a name="ln685">		if (error != B_OK)</a>
<a name="ln686">			return error;</a>
<a name="ln687">	}</a>
<a name="ln688"> </a>
<a name="ln689">	return B_OK;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">// #pragma mark - LowLevelAttributeHandler</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">ReaderImplBase::LowLevelAttributeHandler::LowLevelAttributeHandler()</a>
<a name="ln697">	:</a>
<a name="ln698">	fParentToken(NULL),</a>
<a name="ln699">	fToken(NULL),</a>
<a name="ln700">	fID(B_HPKG_ATTRIBUTE_ID_ENUM_COUNT)</a>
<a name="ln701">{</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">ReaderImplBase::LowLevelAttributeHandler::LowLevelAttributeHandler(uint8 id,</a>
<a name="ln706">	const BPackageAttributeValue&amp; value, void* parentToken, void* token)</a>
<a name="ln707">	:</a>
<a name="ln708">	fParentToken(NULL),</a>
<a name="ln709">	fToken(token),</a>
<a name="ln710">	fID(id),</a>
<a name="ln711">	fValue(value)</a>
<a name="ln712">{</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715"> </a>
<a name="ln716">status_t</a>
<a name="ln717">ReaderImplBase::LowLevelAttributeHandler::HandleAttribute(</a>
<a name="ln718">	AttributeHandlerContext* context, uint8 id, const AttributeValue&amp; value,</a>
<a name="ln719">	AttributeHandler** _handler)</a>
<a name="ln720">{</a>
<a name="ln721">	// notify the content handler</a>
<a name="ln722">	void* token;</a>
<a name="ln723">	status_t error = context-&gt;lowLevelHandler-&gt;HandleAttribute(</a>
<a name="ln724">		(BHPKGAttributeID)id, value, fToken, token);</a>
<a name="ln725">	if (error != B_OK)</a>
<a name="ln726">		return error;</a>
<a name="ln727"> </a>
<a name="ln728">	// create a subhandler for the attribute, if it has children</a>
<a name="ln729">	if (_handler != NULL) {</a>
<a name="ln730">		*_handler = new(std::nothrow) LowLevelAttributeHandler(id, value,</a>
<a name="ln731">			fToken, token);</a>
<a name="ln732">		if (*_handler == NULL) {</a>
<a name="ln733">			context-&gt;lowLevelHandler-&gt;HandleAttributeDone((BHPKGAttributeID)id,</a>
<a name="ln734">				value, fToken, token);</a>
<a name="ln735">			return B_NO_MEMORY;</a>
<a name="ln736">		}</a>
<a name="ln737">		return B_OK;</a>
<a name="ln738">	}</a>
<a name="ln739"> </a>
<a name="ln740">	// no children -- just call the done hook</a>
<a name="ln741">	return context-&gt;lowLevelHandler-&gt;HandleAttributeDone((BHPKGAttributeID)id,</a>
<a name="ln742">		value, fToken, token);</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745"> </a>
<a name="ln746">status_t</a>
<a name="ln747">ReaderImplBase::LowLevelAttributeHandler::NotifyDone(</a>
<a name="ln748">	AttributeHandlerContext* context)</a>
<a name="ln749">{</a>
<a name="ln750">	if (fID != B_HPKG_ATTRIBUTE_ID_ENUM_COUNT) {</a>
<a name="ln751">		status_t error = context-&gt;lowLevelHandler-&gt;HandleAttributeDone(</a>
<a name="ln752">			(BHPKGAttributeID)fID, fValue, fParentToken, fToken);</a>
<a name="ln753">		if (error != B_OK)</a>
<a name="ln754">			return error;</a>
<a name="ln755">	}</a>
<a name="ln756">	return super::NotifyDone(context);</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759"> </a>
<a name="ln760">// #pragma mark - ReaderImplBase</a>
<a name="ln761"> </a>
<a name="ln762"> </a>
<a name="ln763">ReaderImplBase::ReaderImplBase(const char* fileType, BErrorOutput* errorOutput)</a>
<a name="ln764">	:</a>
<a name="ln765">	fPackageAttributesSection(&quot;package attributes&quot;),</a>
<a name="ln766">	fFileType(fileType),</a>
<a name="ln767">	fErrorOutput(errorOutput),</a>
<a name="ln768">	fFile(NULL),</a>
<a name="ln769">	fOwnsFile(false),</a>
<a name="ln770">	fRawHeapReader(NULL),</a>
<a name="ln771">	fHeapReader(NULL),</a>
<a name="ln772">	fCurrentSection(NULL)</a>
<a name="ln773">{</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777">ReaderImplBase::~ReaderImplBase()</a>
<a name="ln778">{</a>
<a name="ln779">	delete fHeapReader;</a>
<a name="ln780">	if (fRawHeapReader != fHeapReader)</a>
<a name="ln781">		delete fRawHeapReader;</a>
<a name="ln782"> </a>
<a name="ln783">	if (fOwnsFile)</a>
<a name="ln784">		delete fFile;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787"> </a>
<a name="ln788">uint64</a>
<a name="ln789">ReaderImplBase::UncompressedHeapSize() const</a>
<a name="ln790">{</a>
<a name="ln791">	return fRawHeapReader-&gt;UncompressedHeapSize();</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">BAbstractBufferedDataReader*</a>
<a name="ln796">ReaderImplBase::DetachHeapReader(PackageFileHeapReader*&amp; _rawHeapReader)</a>
<a name="ln797">{</a>
<a name="ln798">	BAbstractBufferedDataReader* heapReader = fHeapReader;</a>
<a name="ln799">	_rawHeapReader = fRawHeapReader;</a>
<a name="ln800">	fHeapReader = NULL;</a>
<a name="ln801">	fRawHeapReader = NULL;</a>
<a name="ln802"> </a>
<a name="ln803">	return heapReader;</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806"> </a>
<a name="ln807">status_t</a>
<a name="ln808">ReaderImplBase::InitHeapReader(uint32 compression, uint32 chunkSize,</a>
<a name="ln809">	off_t offset, uint64 compressedSize, uint64 uncompressedSize)</a>
<a name="ln810">{</a>
<a name="ln811">	DecompressionAlgorithmOwner* decompressionAlgorithm = NULL;</a>
<a name="ln812">	BReference&lt;DecompressionAlgorithmOwner&gt; decompressionAlgorithmReference;</a>
<a name="ln813"> </a>
<a name="ln814">	switch (compression) {</a>
<a name="ln815">		case B_HPKG_COMPRESSION_NONE:</a>
<a name="ln816">			break;</a>
<a name="ln817">		case B_HPKG_COMPRESSION_ZLIB:</a>
<a name="ln818">			decompressionAlgorithm = DecompressionAlgorithmOwner::Create(</a>
<a name="ln819">				new(std::nothrow) BZlibCompressionAlgorithm,</a>
<a name="ln820">				new(std::nothrow) BZlibDecompressionParameters);</a>
<a name="ln821">			decompressionAlgorithmReference.SetTo(decompressionAlgorithm, true);</a>
<a name="ln822">			if (decompressionAlgorithm == NULL</a>
<a name="ln823">				|| decompressionAlgorithm-&gt;algorithm == NULL</a>
<a name="ln824">				|| decompressionAlgorithm-&gt;parameters == NULL) {</a>
<a name="ln825">				return B_NO_MEMORY;</a>
<a name="ln826">			}</a>
<a name="ln827">			break;</a>
<a name="ln828">#ifdef ZSTD_ENABLED</a>
<a name="ln829">		case B_HPKG_COMPRESSION_ZSTD:</a>
<a name="ln830">			decompressionAlgorithm = DecompressionAlgorithmOwner::Create(</a>
<a name="ln831">				new(std::nothrow) BZstdCompressionAlgorithm,</a>
<a name="ln832">				new(std::nothrow) BZstdDecompressionParameters);</a>
<a name="ln833">			decompressionAlgorithmReference.SetTo(decompressionAlgorithm, true);</a>
<a name="ln834">			if (decompressionAlgorithm == NULL</a>
<a name="ln835">				|| decompressionAlgorithm-&gt;algorithm == NULL</a>
<a name="ln836">				|| decompressionAlgorithm-&gt;parameters == NULL) {</a>
<a name="ln837">				return B_NO_MEMORY;</a>
<a name="ln838">			}</a>
<a name="ln839">			break;</a>
<a name="ln840">#endif</a>
<a name="ln841">		default:</a>
<a name="ln842">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid heap compression\n&quot;);</a>
<a name="ln843">			return B_BAD_DATA;</a>
<a name="ln844">	}</a>
<a name="ln845"> </a>
<a name="ln846">	fRawHeapReader = new(std::nothrow) PackageFileHeapReader(fErrorOutput,</a>
<a name="ln847">		fFile, offset, compressedSize, uncompressedSize,</a>
<a name="ln848">		decompressionAlgorithm);</a>
<a name="ln849">	if (fRawHeapReader == NULL)</a>
<a name="ln850">		return B_NO_MEMORY;</a>
<a name="ln851"> </a>
<a name="ln852">	status_t error = fRawHeapReader-&gt;Init();</a>
<a name="ln853">	if (error != B_OK)</a>
<a name="ln854">		return error;</a>
<a name="ln855"> </a>
<a name="ln856">	error = CreateCachedHeapReader(fRawHeapReader, fHeapReader);</a>
<a name="ln857">	if (error != B_OK) {</a>
<a name="ln858">		if (error != B_NOT_SUPPORTED)</a>
<a name="ln859">			return error;</a>
<a name="ln860"> </a>
<a name="ln861">		fHeapReader = fRawHeapReader;</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	return B_OK;</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867"> </a>
<a name="ln868">status_t</a>
<a name="ln869">ReaderImplBase::CreateCachedHeapReader(PackageFileHeapReader* heapReader,</a>
<a name="ln870">	BAbstractBufferedDataReader*&amp; _cachedReader)</a>
<a name="ln871">{</a>
<a name="ln872">	return B_NOT_SUPPORTED;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">status_t</a>
<a name="ln877">ReaderImplBase::InitSection(PackageFileSection&amp; section, uint64 endOffset,</a>
<a name="ln878">	uint64 length, uint64 maxSaneLength, uint64 stringsLength,</a>
<a name="ln879">	uint64 stringsCount)</a>
<a name="ln880">{</a>
<a name="ln881">	// check length vs. endOffset</a>
<a name="ln882">	if (length &gt; endOffset) {</a>
<a name="ln883">		ErrorOutput()-&gt;PrintError(&quot;Error: %s file %s section size is %&quot;</a>
<a name="ln884">			B_PRIu64 &quot; bytes. This is greater than the available space\n&quot;,</a>
<a name="ln885">			fFileType, section.name, length);</a>
<a name="ln886">		return B_BAD_DATA;</a>
<a name="ln887">	}</a>
<a name="ln888"> </a>
<a name="ln889">	// check sanity length</a>
<a name="ln890">	if (maxSaneLength &gt; 0 &amp;&amp; length &gt; maxSaneLength) {</a>
<a name="ln891">		ErrorOutput()-&gt;PrintError(&quot;Error: %s file %s section size is %&quot;</a>
<a name="ln892">			B_PRIu64 &quot; bytes. This is beyond the reader's sanity limit\n&quot;,</a>
<a name="ln893">			fFileType, section.name, length);</a>
<a name="ln894">		return B_NOT_SUPPORTED;</a>
<a name="ln895">	}</a>
<a name="ln896"> </a>
<a name="ln897">	// check strings subsection size/count</a>
<a name="ln898">	if ((stringsLength &lt;= 1) != (stringsCount == 0) || stringsLength &gt; length) {</a>
<a name="ln899">		ErrorOutput()-&gt;PrintError(&quot;Error: strings subsection description of %s &quot;</a>
<a name="ln900">			&quot;file %s section is invalid (%&quot; B_PRIu64 &quot; strings, length: %&quot;</a>
<a name="ln901">			B_PRIu64 &quot;, section length: %&quot; B_PRIu64 &quot;)\n&quot;,</a>
<a name="ln902">			fFileType, section.name, stringsCount, stringsLength, length);</a>
<a name="ln903">		return B_BAD_DATA;</a>
<a name="ln904">	}</a>
<a name="ln905"> </a>
<a name="ln906">	section.uncompressedLength = length;</a>
<a name="ln907">	section.offset = endOffset - length;</a>
<a name="ln908">	section.currentOffset = 0;</a>
<a name="ln909">	section.stringsLength = stringsLength;</a>
<a name="ln910">	section.stringsCount = stringsCount;</a>
<a name="ln911"> </a>
<a name="ln912">	return B_OK;</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915"> </a>
<a name="ln916">status_t</a>
<a name="ln917">ReaderImplBase::PrepareSection(PackageFileSection&amp; section)</a>
<a name="ln918">{</a>
<a name="ln919">	// allocate memory for the section data and read it in</a>
<a name="ln920">	section.data = new(std::nothrow) uint8[section.uncompressedLength];</a>
<a name="ln921">	if (section.data == NULL) {</a>
<a name="ln922">		ErrorOutput()-&gt;PrintError(&quot;Error: Out of memory!\n&quot;);</a>
<a name="ln923">		return B_NO_MEMORY;</a>
<a name="ln924">	}</a>
<a name="ln925"> </a>
<a name="ln926">	status_t error = ReadSection(section);</a>
<a name="ln927">	if (error != B_OK)</a>
<a name="ln928">		return error;</a>
<a name="ln929"> </a>
<a name="ln930">	// parse the section strings</a>
<a name="ln931">	section.currentOffset = 0;</a>
<a name="ln932">	SetCurrentSection(&amp;section);</a>
<a name="ln933"> </a>
<a name="ln934">	error = ParseStrings();</a>
<a name="ln935">	if (error != B_OK)</a>
<a name="ln936">		return error;</a>
<a name="ln937"> </a>
<a name="ln938">	return B_OK;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941"> </a>
<a name="ln942">status_t</a>
<a name="ln943">ReaderImplBase::ParseStrings()</a>
<a name="ln944">{</a>
<a name="ln945">	// allocate table, if there are any strings</a>
<a name="ln946">	if (fCurrentSection-&gt;stringsCount == 0) {</a>
<a name="ln947">		fCurrentSection-&gt;currentOffset += fCurrentSection-&gt;stringsLength;</a>
<a name="ln948">		return B_OK;</a>
<a name="ln949">	}</a>
<a name="ln950"> </a>
<a name="ln951">	fCurrentSection-&gt;strings</a>
<a name="ln952">		= new(std::nothrow) char*[fCurrentSection-&gt;stringsCount];</a>
<a name="ln953">	if (fCurrentSection-&gt;strings == NULL) {</a>
<a name="ln954">		fErrorOutput-&gt;PrintError(&quot;Error: Out of memory!\n&quot;);</a>
<a name="ln955">		return B_NO_MEMORY;</a>
<a name="ln956">	}</a>
<a name="ln957"> </a>
<a name="ln958">	// parse the section and fill the table</a>
<a name="ln959">	char* position</a>
<a name="ln960">		= (char*)fCurrentSection-&gt;data + fCurrentSection-&gt;currentOffset;</a>
<a name="ln961">	char* sectionEnd = position + fCurrentSection-&gt;stringsLength;</a>
<a name="ln962">	uint32 index = 0;</a>
<a name="ln963">	while (true) {</a>
<a name="ln964">		if (position &gt;= sectionEnd) {</a>
<a name="ln965">			fErrorOutput-&gt;PrintError(&quot;Error: Malformed %s strings section\n&quot;,</a>
<a name="ln966">				fCurrentSection-&gt;name);</a>
<a name="ln967">			return B_BAD_DATA;</a>
<a name="ln968">		}</a>
<a name="ln969"> </a>
<a name="ln970">		size_t stringLength = strnlen(position, (char*)sectionEnd - position);</a>
<a name="ln971"> </a>
<a name="ln972">		if (stringLength == 0) {</a>
<a name="ln973">			if (position + 1 != sectionEnd) {</a>
<a name="ln974">				fErrorOutput-&gt;PrintError(</a>
<a name="ln975">					&quot;Error: %ld excess bytes in %s strings section\n&quot;,</a>
<a name="ln976">					sectionEnd - (position + 1), fCurrentSection-&gt;name);</a>
<a name="ln977">				return B_BAD_DATA;</a>
<a name="ln978">			}</a>
<a name="ln979"> </a>
<a name="ln980">			if (index != fCurrentSection-&gt;stringsCount) {</a>
<a name="ln981">				fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s strings section: &quot;</a>
<a name="ln982">					&quot;Less strings (%lld) than specified in the header (%lld)\n&quot;,</a>
<a name="ln983">					fCurrentSection-&gt;name, index,</a>
<a name="ln984">					fCurrentSection-&gt;stringsCount);</a>
<a name="ln985">				return B_BAD_DATA;</a>
<a name="ln986">			}</a>
<a name="ln987"> </a>
<a name="ln988">			fCurrentSection-&gt;currentOffset += fCurrentSection-&gt;stringsLength;</a>
<a name="ln989"> </a>
<a name="ln990">			return B_OK;</a>
<a name="ln991">		}</a>
<a name="ln992"> </a>
<a name="ln993">		if (index &gt;= fCurrentSection-&gt;stringsCount) {</a>
<a name="ln994">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s strings section: &quot;</a>
<a name="ln995">				&quot;More strings (%lld) than specified in the header (%lld)\n&quot;,</a>
<a name="ln996">				fCurrentSection-&gt;name, index, fCurrentSection-&gt;stringsCount);</a>
<a name="ln997">			return B_BAD_DATA;</a>
<a name="ln998">		}</a>
<a name="ln999"> </a>
<a name="ln1000">		fCurrentSection-&gt;strings[index++] = position;</a>
<a name="ln1001">		position += stringLength + 1;</a>
<a name="ln1002">	}</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005"> </a>
<a name="ln1006">status_t</a>
<a name="ln1007">ReaderImplBase::ParsePackageAttributesSection(</a>
<a name="ln1008">	AttributeHandlerContext* context, AttributeHandler* rootAttributeHandler)</a>
<a name="ln1009">{</a>
<a name="ln1010">	// parse package attributes</a>
<a name="ln1011">	SetCurrentSection(&amp;fPackageAttributesSection);</a>
<a name="ln1012"> </a>
<a name="ln1013">	// init the attribute handler stack</a>
<a name="ln1014">	rootAttributeHandler-&gt;SetLevel(0);</a>
<a name="ln1015">	ClearAttributeHandlerStack();</a>
<a name="ln1016">	PushAttributeHandler(rootAttributeHandler);</a>
<a name="ln1017"> </a>
<a name="ln1018">	bool sectionHandled;</a>
<a name="ln1019">	status_t error = ParseAttributeTree(context, sectionHandled);</a>
<a name="ln1020">	if (error == B_OK &amp;&amp; sectionHandled) {</a>
<a name="ln1021">		if (fPackageAttributesSection.currentOffset</a>
<a name="ln1022">				&lt; fPackageAttributesSection.uncompressedLength) {</a>
<a name="ln1023">			fErrorOutput-&gt;PrintError(&quot;Error: %llu excess byte(s) in package &quot;</a>
<a name="ln1024">				&quot;attributes section\n&quot;,</a>
<a name="ln1025">				fPackageAttributesSection.uncompressedLength</a>
<a name="ln1026">					- fPackageAttributesSection.currentOffset);</a>
<a name="ln1027">			error = B_BAD_DATA;</a>
<a name="ln1028">		}</a>
<a name="ln1029">	}</a>
<a name="ln1030"> </a>
<a name="ln1031">	SetCurrentSection(NULL);</a>
<a name="ln1032"> </a>
<a name="ln1033">	// clean up on error</a>
<a name="ln1034">	if (error != B_OK) {</a>
<a name="ln1035">		context-&gt;ErrorOccurred();</a>
<a name="ln1036">		while (AttributeHandler* handler = PopAttributeHandler()) {</a>
<a name="ln1037">			if (handler != rootAttributeHandler)</a>
<a name="ln1038">				handler-&gt;Delete(context);</a>
<a name="ln1039">		}</a>
<a name="ln1040">		return error;</a>
<a name="ln1041">	}</a>
<a name="ln1042"> </a>
<a name="ln1043">	return B_OK;</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046"> </a>
<a name="ln1047">status_t</a>
<a name="ln1048">ReaderImplBase::ParseAttributeTree(AttributeHandlerContext* context,</a>
<a name="ln1049">	bool&amp; _sectionHandled)</a>
<a name="ln1050">{</a>
<a name="ln1051">	if (context-&gt;hasLowLevelHandler) {</a>
<a name="ln1052">		bool handleSection = false;</a>
<a name="ln1053">		status_t error = context-&gt;lowLevelHandler-&gt;HandleSectionStart(</a>
<a name="ln1054">			context-&gt;section, handleSection);</a>
<a name="ln1055">		if (error != B_OK)</a>
<a name="ln1056">			return error;</a>
<a name="ln1057"> </a>
<a name="ln1058">		if (!handleSection) {</a>
<a name="ln1059">			_sectionHandled = false;</a>
<a name="ln1060">			return B_OK;</a>
<a name="ln1061">		}</a>
<a name="ln1062">	}</a>
<a name="ln1063"> </a>
<a name="ln1064">	status_t error = _ParseAttributeTree(context);</a>
<a name="ln1065"> </a>
<a name="ln1066">	if (context-&gt;hasLowLevelHandler) {</a>
<a name="ln1067">		status_t endError = context-&gt;lowLevelHandler-&gt;HandleSectionEnd(</a>
<a name="ln1068">			context-&gt;section);</a>
<a name="ln1069">		if (error == B_OK)</a>
<a name="ln1070">			error = endError;</a>
<a name="ln1071">	}</a>
<a name="ln1072"> </a>
<a name="ln1073">	_sectionHandled = true;</a>
<a name="ln1074">	return error;</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077"> </a>
<a name="ln1078">status_t</a>
<a name="ln1079">ReaderImplBase::_Init(BPositionIO* file, bool keepFile)</a>
<a name="ln1080">{</a>
<a name="ln1081">	fFile = file;</a>
<a name="ln1082">	fOwnsFile = keepFile;</a>
<a name="ln1083">	return fFile != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086"> </a>
<a name="ln1087">status_t</a>
<a name="ln1088">ReaderImplBase::_ParseAttributeTree(AttributeHandlerContext* context)</a>
<a name="ln1089">{</a>
<a name="ln1090">	int level = 0;</a>
<a name="ln1091"> </a>
<a name="ln1092">	while (true) {</a>
<a name="ln1093">		uint8 id;</a>
<a name="ln1094">		AttributeValue value;</a>
<a name="ln1095">		bool hasChildren;</a>
<a name="ln1096">		uint64 tag;</a>
<a name="ln1097"> </a>
<a name="ln1098">		status_t error = _ReadAttribute(id, value, &amp;hasChildren, &amp;tag);</a>
<a name="ln1099">		if (error != B_OK)</a>
<a name="ln1100">			return error;</a>
<a name="ln1101"> </a>
<a name="ln1102">		if (tag == 0) {</a>
<a name="ln1103">			AttributeHandler* handler = PopAttributeHandler();</a>
<a name="ln1104">			error = handler-&gt;NotifyDone(context);</a>
<a name="ln1105">			if (error != B_OK)</a>
<a name="ln1106">				return error;</a>
<a name="ln1107">			if (level-- == 0)</a>
<a name="ln1108">				return B_OK;</a>
<a name="ln1109"> </a>
<a name="ln1110">			error = handler-&gt;Delete(context);</a>
<a name="ln1111">			if (error != B_OK)</a>
<a name="ln1112">				return error;</a>
<a name="ln1113"> </a>
<a name="ln1114">			continue;</a>
<a name="ln1115">		}</a>
<a name="ln1116"> </a>
<a name="ln1117">		AttributeHandler* childHandler = NULL;</a>
<a name="ln1118">		error = CurrentAttributeHandler()-&gt;HandleAttribute(context, id, value,</a>
<a name="ln1119">			hasChildren ? &amp;childHandler : NULL);</a>
<a name="ln1120">		if (error != B_OK)</a>
<a name="ln1121">			return error;</a>
<a name="ln1122"> </a>
<a name="ln1123">		// parse children</a>
<a name="ln1124">		if (hasChildren) {</a>
<a name="ln1125">			// create an ignore handler, if necessary</a>
<a name="ln1126">			if (childHandler == NULL) {</a>
<a name="ln1127">				childHandler = new(std::nothrow) IgnoreAttributeHandler;</a>
<a name="ln1128">				if (childHandler == NULL) {</a>
<a name="ln1129">					fErrorOutput-&gt;PrintError(&quot;Error: Out of memory!\n&quot;);</a>
<a name="ln1130">					return B_NO_MEMORY;</a>
<a name="ln1131">				}</a>
<a name="ln1132">			}</a>
<a name="ln1133"> </a>
<a name="ln1134">			childHandler-&gt;SetLevel(++level);</a>
<a name="ln1135">			PushAttributeHandler(childHandler);</a>
<a name="ln1136">		}</a>
<a name="ln1137">	}</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140"> </a>
<a name="ln1141">status_t</a>
<a name="ln1142">ReaderImplBase::_ReadAttribute(uint8&amp; _id, AttributeValue&amp; _value,</a>
<a name="ln1143">	bool* _hasChildren, uint64* _tag)</a>
<a name="ln1144">{</a>
<a name="ln1145">	uint64 tag;</a>
<a name="ln1146">	status_t error = ReadUnsignedLEB128(tag);</a>
<a name="ln1147">	if (error != B_OK)</a>
<a name="ln1148">		return error;</a>
<a name="ln1149"> </a>
<a name="ln1150">	if (tag != 0) {</a>
<a name="ln1151">		// get the type</a>
<a name="ln1152">		uint16 type = attribute_tag_type(tag);</a>
<a name="ln1153">		if (type &gt;= B_HPKG_ATTRIBUTE_TYPE_ENUM_COUNT) {</a>
<a name="ln1154">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: attribute &quot;</a>
<a name="ln1155">				&quot;type %d not supported!\n&quot;, fCurrentSection-&gt;name, type);</a>
<a name="ln1156">			return B_BAD_DATA;</a>
<a name="ln1157">		}</a>
<a name="ln1158"> </a>
<a name="ln1159">		// get the ID</a>
<a name="ln1160">		_id = attribute_tag_id(tag);</a>
<a name="ln1161">		if (_id &lt; B_HPKG_ATTRIBUTE_ID_ENUM_COUNT) {</a>
<a name="ln1162">			if (type != kAttributeTypes[_id]) {</a>
<a name="ln1163">				fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: &quot;</a>
<a name="ln1164">					&quot;unexpected type %d for attribute id %d (expected %d)!\n&quot;,</a>
<a name="ln1165">					fCurrentSection-&gt;name, type, _id, kAttributeTypes[_id]);</a>
<a name="ln1166">				return B_BAD_DATA;</a>
<a name="ln1167">			}</a>
<a name="ln1168">		} else if (fMinorFormatVersion &lt;= fCurrentMinorFormatVersion) {</a>
<a name="ln1169">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: &quot;</a>
<a name="ln1170">				&quot;attribute id %d not supported!\n&quot;, fCurrentSection-&gt;name, _id);</a>
<a name="ln1171">			return B_BAD_DATA;</a>
<a name="ln1172">		}</a>
<a name="ln1173"> </a>
<a name="ln1174">		// get the value</a>
<a name="ln1175">		error = ReadAttributeValue(type, attribute_tag_encoding(tag),</a>
<a name="ln1176">			_value);</a>
<a name="ln1177">		if (error != B_OK)</a>
<a name="ln1178">			return error;</a>
<a name="ln1179">	}</a>
<a name="ln1180"> </a>
<a name="ln1181">	if (_hasChildren != NULL)</a>
<a name="ln1182">		*_hasChildren = attribute_tag_has_children(tag);</a>
<a name="ln1183">	if (_tag != NULL)</a>
<a name="ln1184">		*_tag = tag;</a>
<a name="ln1185"> </a>
<a name="ln1186">	return B_OK;</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189"> </a>
<a name="ln1190">status_t</a>
<a name="ln1191">ReaderImplBase::ReadAttributeValue(uint8 type, uint8 encoding,</a>
<a name="ln1192">	AttributeValue&amp; _value)</a>
<a name="ln1193">{</a>
<a name="ln1194">	switch (type) {</a>
<a name="ln1195">		case B_HPKG_ATTRIBUTE_TYPE_INT:</a>
<a name="ln1196">		case B_HPKG_ATTRIBUTE_TYPE_UINT:</a>
<a name="ln1197">		{</a>
<a name="ln1198">			uint64 intValue;</a>
<a name="ln1199">			status_t error;</a>
<a name="ln1200"> </a>
<a name="ln1201">			switch (encoding) {</a>
<a name="ln1202">				case B_HPKG_ATTRIBUTE_ENCODING_INT_8_BIT:</a>
<a name="ln1203">				{</a>
<a name="ln1204">					uint8 value;</a>
<a name="ln1205">					error = _Read(value);</a>
<a name="ln1206">					intValue = value;</a>
<a name="ln1207">					break;</a>
<a name="ln1208">				}</a>
<a name="ln1209">				case B_HPKG_ATTRIBUTE_ENCODING_INT_16_BIT:</a>
<a name="ln1210">				{</a>
<a name="ln1211">					uint16 value;</a>
<a name="ln1212">					error = _Read(value);</a>
<a name="ln1213">					intValue = B_BENDIAN_TO_HOST_INT16(value);</a>
<a name="ln1214">					break;</a>
<a name="ln1215">				}</a>
<a name="ln1216">				case B_HPKG_ATTRIBUTE_ENCODING_INT_32_BIT:</a>
<a name="ln1217">				{</a>
<a name="ln1218">					uint32 value;</a>
<a name="ln1219">					error = _Read(value);</a>
<a name="ln1220">					intValue = B_BENDIAN_TO_HOST_INT32(value);</a>
<a name="ln1221">					break;</a>
<a name="ln1222">				}</a>
<a name="ln1223">				case B_HPKG_ATTRIBUTE_ENCODING_INT_64_BIT:</a>
<a name="ln1224">				{</a>
<a name="ln1225">					uint64 value;</a>
<a name="ln1226">					error = _Read(value);</a>
<a name="ln1227">					intValue = B_BENDIAN_TO_HOST_INT64(value);</a>
<a name="ln1228">					break;</a>
<a name="ln1229">				}</a>
<a name="ln1230">				default:</a>
<a name="ln1231">				{</a>
<a name="ln1232">					fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: &quot;</a>
<a name="ln1233">						&quot;invalid encoding %d for int value type %d\n&quot;,</a>
<a name="ln1234">						fCurrentSection-&gt;name, encoding, type);</a>
<a name="ln1235">					return B_BAD_VALUE;</a>
<a name="ln1236">				}</a>
<a name="ln1237">			}</a>
<a name="ln1238"> </a>
<a name="ln1239">			if (error != B_OK)</a>
<a name="ln1240">				return error;</a>
<a name="ln1241"> </a>
<a name="ln1242">			if (type == B_HPKG_ATTRIBUTE_TYPE_INT)</a>
<a name="ln1243">				_value.SetTo((int64)intValue);</a>
<a name="ln1244">			else</a>
<a name="ln1245">				_value.SetTo(intValue);</a>
<a name="ln1246"> </a>
<a name="ln1247">			return B_OK;</a>
<a name="ln1248">		}</a>
<a name="ln1249"> </a>
<a name="ln1250">		case B_HPKG_ATTRIBUTE_TYPE_STRING:</a>
<a name="ln1251">		{</a>
<a name="ln1252">			if (encoding == B_HPKG_ATTRIBUTE_ENCODING_STRING_TABLE) {</a>
<a name="ln1253">				uint64 index;</a>
<a name="ln1254">				status_t error = ReadUnsignedLEB128(index);</a>
<a name="ln1255">				if (error != B_OK)</a>
<a name="ln1256">					return error;</a>
<a name="ln1257"> </a>
<a name="ln1258">				if (index &gt; fCurrentSection-&gt;stringsCount) {</a>
<a name="ln1259">					fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: &quot;</a>
<a name="ln1260">						&quot;string reference (%lld) out of bounds (%lld)\n&quot;,</a>
<a name="ln1261">						fCurrentSection-&gt;name, index,</a>
<a name="ln1262">						fCurrentSection-&gt;stringsCount);</a>
<a name="ln1263">					return B_BAD_DATA;</a>
<a name="ln1264">				}</a>
<a name="ln1265"> </a>
<a name="ln1266">				_value.SetTo(fCurrentSection-&gt;strings[index]);</a>
<a name="ln1267">			} else if (encoding == B_HPKG_ATTRIBUTE_ENCODING_STRING_INLINE) {</a>
<a name="ln1268">				const char* string;</a>
<a name="ln1269">				status_t error = _ReadString(string);</a>
<a name="ln1270">				if (error != B_OK)</a>
<a name="ln1271">					return error;</a>
<a name="ln1272"> </a>
<a name="ln1273">				_value.SetTo(string);</a>
<a name="ln1274">			} else {</a>
<a name="ln1275">				fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: invalid &quot;</a>
<a name="ln1276">					&quot;string encoding (%u)\n&quot;, fCurrentSection-&gt;name, encoding);</a>
<a name="ln1277">				return B_BAD_DATA;</a>
<a name="ln1278">			}</a>
<a name="ln1279"> </a>
<a name="ln1280">			return B_OK;</a>
<a name="ln1281">		}</a>
<a name="ln1282"> </a>
<a name="ln1283">		default:</a>
<a name="ln1284">			fErrorOutput-&gt;PrintError(&quot;Error: Invalid %s section: invalid &quot;</a>
<a name="ln1285">				&quot;value type: %d\n&quot;, fCurrentSection-&gt;name, type);</a>
<a name="ln1286">			return B_BAD_DATA;</a>
<a name="ln1287">	}</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290"> </a>
<a name="ln1291">status_t</a>
<a name="ln1292">ReaderImplBase::ReadUnsignedLEB128(uint64&amp; _value)</a>
<a name="ln1293">{</a>
<a name="ln1294">	uint64 result = 0;</a>
<a name="ln1295">	int shift = 0;</a>
<a name="ln1296">	while (true) {</a>
<a name="ln1297">		uint8 byte;</a>
<a name="ln1298">		status_t error = _Read(byte);</a>
<a name="ln1299">		if (error != B_OK)</a>
<a name="ln1300">			return error;</a>
<a name="ln1301"> </a>
<a name="ln1302">		result |= uint64(byte &amp; 0x7f) &lt;&lt; shift;</a>
<a name="ln1303">		if ((byte &amp; 0x80) == 0)</a>
<a name="ln1304">			break;</a>
<a name="ln1305">		shift += 7;</a>
<a name="ln1306">	}</a>
<a name="ln1307"> </a>
<a name="ln1308">	_value = result;</a>
<a name="ln1309">	return B_OK;</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312"> </a>
<a name="ln1313">status_t</a>
<a name="ln1314">ReaderImplBase::_ReadString(const char*&amp; _string, size_t* _stringLength)</a>
<a name="ln1315">{</a>
<a name="ln1316">	const char* string</a>
<a name="ln1317">		= (const char*)fCurrentSection-&gt;data + fCurrentSection-&gt;currentOffset;</a>
<a name="ln1318">	size_t stringLength = strnlen(string,</a>
<a name="ln1319">		fCurrentSection-&gt;uncompressedLength - fCurrentSection-&gt;currentOffset);</a>
<a name="ln1320"> </a>
<a name="ln1321">	if (stringLength</a>
<a name="ln1322">		== fCurrentSection-&gt;uncompressedLength</a>
<a name="ln1323">			- fCurrentSection-&gt;currentOffset) {</a>
<a name="ln1324">		fErrorOutput-&gt;PrintError(</a>
<a name="ln1325">			&quot;_ReadString(): string extends beyond %s end\n&quot;,</a>
<a name="ln1326">			fCurrentSection-&gt;name);</a>
<a name="ln1327">		return B_BAD_DATA;</a>
<a name="ln1328">	}</a>
<a name="ln1329"> </a>
<a name="ln1330">	_string = string;</a>
<a name="ln1331">	if (_stringLength != NULL)</a>
<a name="ln1332">		*_stringLength = stringLength;</a>
<a name="ln1333"> </a>
<a name="ln1334">	fCurrentSection-&gt;currentOffset += stringLength + 1;</a>
<a name="ln1335">	return B_OK;</a>
<a name="ln1336">}</a>
<a name="ln1337"> </a>
<a name="ln1338"> </a>
<a name="ln1339">status_t</a>
<a name="ln1340">ReaderImplBase::_ReadSectionBuffer(void* buffer, size_t size)</a>
<a name="ln1341">{</a>
<a name="ln1342">	if (size &gt; fCurrentSection-&gt;uncompressedLength</a>
<a name="ln1343">			- fCurrentSection-&gt;currentOffset) {</a>
<a name="ln1344">		fErrorOutput-&gt;PrintError(</a>
<a name="ln1345">			&quot;_ReadSectionBuffer(%lu): read beyond %s end\n&quot;, size,</a>
<a name="ln1346">			fCurrentSection-&gt;name);</a>
<a name="ln1347">		return B_BAD_DATA;</a>
<a name="ln1348">	}</a>
<a name="ln1349"> </a>
<a name="ln1350">	memcpy(buffer, fCurrentSection-&gt;data + fCurrentSection-&gt;currentOffset,</a>
<a name="ln1351">		size);</a>
<a name="ln1352">	fCurrentSection-&gt;currentOffset += size;</a>
<a name="ln1353">	return B_OK;</a>
<a name="ln1354">}</a>
<a name="ln1355"> </a>
<a name="ln1356"> </a>
<a name="ln1357">status_t</a>
<a name="ln1358">ReaderImplBase::ReadBuffer(off_t offset, void* buffer, size_t size)</a>
<a name="ln1359">{</a>
<a name="ln1360">	status_t error = fFile-&gt;ReadAtExactly(offset, buffer, size);</a>
<a name="ln1361">	if (error != B_OK) {</a>
<a name="ln1362">		fErrorOutput-&gt;PrintError(&quot;_ReadBuffer(%p, %lu) failed to read data: &quot;</a>
<a name="ln1363">			&quot;%s\n&quot;, buffer, size, strerror(error));</a>
<a name="ln1364">		return error;</a>
<a name="ln1365">	}</a>
<a name="ln1366"> </a>
<a name="ln1367">	return B_OK;</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370"> </a>
<a name="ln1371">status_t</a>
<a name="ln1372">ReaderImplBase::ReadSection(const PackageFileSection&amp; section)</a>
<a name="ln1373">{</a>
<a name="ln1374">	return fHeapReader-&gt;ReadData(section.offset,</a>
<a name="ln1375">		section.data, section.uncompressedLength);</a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378"> </a>
<a name="ln1379">}	// namespace BPrivate</a>
<a name="ln1380"> </a>
<a name="ln1381">}	// namespace BHPKG</a>
<a name="ln1382"> </a>
<a name="ln1383">}	// namespace BPackageKit</a>

</code></pre>
<div class="balloon" rel="763"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fMinorFormatVersion, fCurrentMinorFormatVersion.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
