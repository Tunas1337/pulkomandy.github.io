
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>LayoutOptimizer.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007, Ingo Weinhold &lt;bonefish@cs.tu-berlin.de&gt;.</a>
<a name="ln3"> * All rights reserved. Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;LayoutOptimizer.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;stdio.h&gt;</a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;new&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15"> </a>
<a name="ln16">//#define TRACE_LAYOUT_OPTIMIZER	1</a>
<a name="ln17">#if TRACE_LAYOUT_OPTIMIZER</a>
<a name="ln18">#	define TRACE(format...)	printf(format)</a>
<a name="ln19">#	define TRACE_ONLY(x)	x</a>
<a name="ln20">#else</a>
<a name="ln21">#	define TRACE(format...)</a>
<a name="ln22">#	define TRACE_ONLY(x)</a>
<a name="ln23">#endif</a>
<a name="ln24">#define TRACE_ERROR(format...)	fprintf(stderr, format)</a>
<a name="ln25"> </a>
<a name="ln26">using std::nothrow;</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">/*!	\class BPrivate::Layout::LayoutOptimizer</a>
<a name="ln30"> </a>
<a name="ln31">	Given a set of layout constraints, a feasible solution, and a desired</a>
<a name="ln32">	(non-)solution this class finds an optimal solution. The optimization</a>
<a name="ln33">	criterion is to minimize the norm of the difference to the desired</a>
<a name="ln34">	(non-)solution.</a>
<a name="ln35"> </a>
<a name="ln36">	It does so by implementing an active set method algorithm. The basic idea</a>
<a name="ln37">	is to start with the subset of the constraints that are barely satisfied by</a>
<a name="ln38">	the feasible solution, i.e. including all equality constraints and those</a>
<a name="ln39">	inequality constraints that are still satisfied, if restricted to equality</a>
<a name="ln40">	constraints. This set is called active set, the contained constraints active</a>
<a name="ln41">	constraints.</a>
<a name="ln42"> </a>
<a name="ln43">	Considering all of the active constraints equality constraints a new</a>
<a name="ln44">	solution is computed, which still satisfies all those equality constraints</a>
<a name="ln45">	and is optimal with respect to the optimization criterion.</a>
<a name="ln46"> </a>
<a name="ln47">	If the new solution equals the previous one, we find the inequality</a>
<a name="ln48">	constraint that, by keeping it in the active set, prevents us most from</a>
<a name="ln49">	further optimizing the solution. If none really does, we're done, having</a>
<a name="ln50">	found the globally optimal solution. Otherwise we remove the found</a>
<a name="ln51">	constraint from the active set and try again.</a>
<a name="ln52"> </a>
<a name="ln53">	If the new solution does not equal the previous one, it might violate one</a>
<a name="ln54">	or more of the inactive constraints. If that is the case, we add the</a>
<a name="ln55">	most-violated constraint to the active set and adjust the new solution such</a>
<a name="ln56">	that barely satisfies that constraint. Otherwise, we don't adjust the</a>
<a name="ln57">	computed solution. With the adjusted respectively unadjusted solution</a>
<a name="ln58">	we enter the next iteration, i.e. by computing a new optimal solution with</a>
<a name="ln59">	respect to the active set.</a>
<a name="ln60">*/</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">// #pragma mark - vector and matrix operations</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">// is_zero</a>
<a name="ln67">static inline bool</a>
<a name="ln68">is_zero(double* x, int n)</a>
<a name="ln69">{</a>
<a name="ln70">	for (int i = 0; i &lt; n; i++) {</a>
<a name="ln71">		if (!fuzzy_equals(x[i], 0))</a>
<a name="ln72">			return false;</a>
<a name="ln73">	}</a>
<a name="ln74"> </a>
<a name="ln75">	return true;</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">// add_vectors</a>
<a name="ln80">static inline void</a>
<a name="ln81">add_vectors(double* x, const double* y, int n)</a>
<a name="ln82">{</a>
<a name="ln83">	for (int i = 0; i &lt; n; i++)</a>
<a name="ln84">		x[i] += y[i];</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87"> </a>
<a name="ln88">// add_vectors_scaled</a>
<a name="ln89">static inline void</a>
<a name="ln90">add_vectors_scaled(double* x, const double* y, double scalar, int n)</a>
<a name="ln91">{</a>
<a name="ln92">	for (int i = 0; i &lt; n; i++)</a>
<a name="ln93">		x[i] += y[i] * scalar;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">// negate_vector</a>
<a name="ln98">static inline void</a>
<a name="ln99">negate_vector(double* x, int n)</a>
<a name="ln100">{</a>
<a name="ln101">	for (int i = 0; i &lt; n; i++)</a>
<a name="ln102">		x[i] = -x[i];</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">// allocate_matrix</a>
<a name="ln107">static double**</a>
<a name="ln108">allocate_matrix(int m, int n)</a>
<a name="ln109">{</a>
<a name="ln110">	double** matrix = new(nothrow) double*[m];</a>
<a name="ln111">	if (!matrix)</a>
<a name="ln112">		return NULL;</a>
<a name="ln113"> </a>
<a name="ln114">	double* values = new(nothrow) double[m * n];</a>
<a name="ln115">	if (!values) {</a>
<a name="ln116">		delete[] matrix;</a>
<a name="ln117">		return NULL;</a>
<a name="ln118">	}</a>
<a name="ln119"> </a>
<a name="ln120">	double* row = values;</a>
<a name="ln121">	for (int i = 0; i &lt; m; i++, row += n)</a>
<a name="ln122">		matrix[i] = row;</a>
<a name="ln123"> </a>
<a name="ln124">	return matrix;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127"> </a>
<a name="ln128">// free_matrix</a>
<a name="ln129">static void</a>
<a name="ln130">free_matrix(double** matrix)</a>
<a name="ln131">{</a>
<a name="ln132">	if (matrix) {</a>
<a name="ln133">		delete[] *matrix;</a>
<a name="ln134">		delete[] matrix;</a>
<a name="ln135">	}</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">// multiply_matrix_vector</a>
<a name="ln140">/*!	y = Ax</a>
<a name="ln141">	A: m x n matrix</a>
<a name="ln142">*/</a>
<a name="ln143">static inline void</a>
<a name="ln144">multiply_matrix_vector(const double* const* A, const double* x, int m, int n,</a>
<a name="ln145">	double* y)</a>
<a name="ln146">{</a>
<a name="ln147">	for (int i = 0; i &lt; m; i++) {</a>
<a name="ln148">		double sum = 0;</a>
<a name="ln149">		for (int k = 0; k &lt; n; k++)</a>
<a name="ln150">			sum += A[i][k] * x[k];</a>
<a name="ln151">		y[i] = sum;</a>
<a name="ln152">	}</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155"> </a>
<a name="ln156">// multiply_matrices</a>
<a name="ln157">/*!	c = a*b</a>
<a name="ln158">*/</a>
<a name="ln159">static void</a>
<a name="ln160">multiply_matrices(const double* const* a, const double* const* b, double** c,</a>
<a name="ln161">	int m, int n, int l)</a>
<a name="ln162">{</a>
<a name="ln163">	for (int i = 0; i &lt; m; i++) {</a>
<a name="ln164">		for (int j = 0; j &lt; l; j++) {</a>
<a name="ln165">			double sum = 0;</a>
<a name="ln166">			for (int k = 0; k &lt; n; k++)</a>
<a name="ln167">				sum += a[i][k] * b[k][j];</a>
<a name="ln168">			c[i][j] = sum;</a>
<a name="ln169">		}	</a>
<a name="ln170">	}</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">// transpose_matrix</a>
<a name="ln175">static inline void</a>
<a name="ln176">transpose_matrix(const double* const* A, double** Atrans, int m, int n)</a>
<a name="ln177">{</a>
<a name="ln178">	for (int i = 0; i &lt; m; i++) {</a>
<a name="ln179">		for (int k = 0; k &lt; n; k++)</a>
<a name="ln180">			Atrans[k][i] = A[i][k];</a>
<a name="ln181">	}</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">// zero_matrix</a>
<a name="ln186">static inline void</a>
<a name="ln187">zero_matrix(double** A, int m, int n)</a>
<a name="ln188">{</a>
<a name="ln189">	for (int i = 0; i &lt; m; i++) {</a>
<a name="ln190">		for (int k = 0; k &lt; n; k++)</a>
<a name="ln191">			A[i][k] = 0;</a>
<a name="ln192">	}</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196">// copy_matrix</a>
<a name="ln197">static inline void</a>
<a name="ln198">copy_matrix(const double* const* A, double** B, int m, int n)</a>
<a name="ln199">{</a>
<a name="ln200">	for (int i = 0; i &lt; m; i++) {</a>
<a name="ln201">		for (int k = 0; k &lt; n; k++)</a>
<a name="ln202">			B[i][k] = A[i][k];</a>
<a name="ln203">	}</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206"> </a>
<a name="ln207">static inline void</a>
<a name="ln208">multiply_optimization_matrix_vector(const double* x, int n, double* y)</a>
<a name="ln209">{</a>
<a name="ln210">	// The matrix has the form:</a>
<a name="ln211">	//  2 -1  0     ...   0  0</a>
<a name="ln212">	// -1  2 -1  0  ...   .  .</a>
<a name="ln213">	//  0 -1  2           .  .</a>
<a name="ln214">	//  .  0     .        .  .</a>
<a name="ln215">	//  .           .     0  0</a>
<a name="ln216">	//  .              . -1  0</a>
<a name="ln217">	//  0    ...    0 -1  2 -1</a>
<a name="ln218">	//  0    ...         -1  1</a>
<a name="ln219">	if (n == 1) {</a>
<a name="ln220">		y[0] = x[0];</a>
<a name="ln221">		return;</a>
<a name="ln222">	}</a>
<a name="ln223"> </a>
<a name="ln224">	y[0] = 2 * x[0] - x[1];</a>
<a name="ln225">	for (int i = 1; i &lt; n - 1; i++)</a>
<a name="ln226">		y[i] = 2 * x[i] - x[i - 1] - x[i + 1];</a>
<a name="ln227">	y[n - 1] = x[n - 1] - x[n - 2];</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">static inline void</a>
<a name="ln232">multiply_optimization_matrix_matrix(const double* const* A, int m, int n,</a>
<a name="ln233">	double** B)</a>
<a name="ln234">{</a>
<a name="ln235">	if (m == 1) {</a>
<a name="ln236">		memcpy(B[0], A[0], n * sizeof(double));</a>
<a name="ln237">		return;</a>
<a name="ln238">	}</a>
<a name="ln239"> </a>
<a name="ln240">	for (int k = 0; k &lt; n; k++) {</a>
<a name="ln241">		B[0][k] = 2 * A[0][k] - A[1][k];</a>
<a name="ln242">		for (int i = 1; i &lt; m - 1; i++)</a>
<a name="ln243">			B[i][k] = 2 * A[i][k] - A[i - 1][k] - A[i + 1][k];</a>
<a name="ln244">		B[m - 1][k] = A[m - 1][k] - A[m - 2][k];</a>
<a name="ln245">	}</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248"> </a>
<a name="ln249">template&lt;typename Type&gt;</a>
<a name="ln250">static inline void</a>
<a name="ln251">swap(Type&amp; a, Type&amp; b)</a>
<a name="ln252">{</a>
<a name="ln253">	Type c = a;</a>
<a name="ln254">	a = b;</a>
<a name="ln255">	b = c;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">// #pragma mark - algorithms</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">bool</a>
<a name="ln263">solve(double** a, int n, double* b)</a>
<a name="ln264">{</a>
<a name="ln265">	// index array for row permutation</a>
<a name="ln266">	// Note: We could eliminate it, if we would permutate the row pointers of a.</a>
<a name="ln267">	int indices[n];</a>
<a name="ln268">	for (int i = 0; i &lt; n; i++)</a>
<a name="ln269">		indices[i] = i;</a>
<a name="ln270"> </a>
<a name="ln271">	// forward elimination</a>
<a name="ln272">	for (int i = 0; i &lt; n - 1; i++) {</a>
<a name="ln273">		// find pivot</a>
<a name="ln274">		int pivot = i;</a>
<a name="ln275">		double pivotValue = fabs(a[indices[i]][i]);</a>
<a name="ln276">		for (int j = i + 1; j &lt; n; j++) {</a>
<a name="ln277">			int index = indices[j];</a>
<a name="ln278">			double value = fabs(a[index][i]);</a>
<a name="ln279">			if (value &gt; pivotValue) {</a>
<a name="ln280">				pivot = j;</a>
<a name="ln281">				pivotValue = value;</a>
<a name="ln282">			}</a>
<a name="ln283">		}</a>
<a name="ln284"> </a>
<a name="ln285">		if (fuzzy_equals(pivotValue, 0)) {</a>
<a name="ln286">			TRACE_ERROR(&quot;solve(): matrix is not regular\n&quot;);</a>
<a name="ln287">			return false;</a>
<a name="ln288">		}</a>
<a name="ln289"> </a>
<a name="ln290">		if (pivot != i) {</a>
<a name="ln291">			swap(indices[i], indices[pivot]);</a>
<a name="ln292">			swap(b[i], b[pivot]);</a>
<a name="ln293">		}</a>
<a name="ln294">		pivot = indices[i];</a>
<a name="ln295"> </a>
<a name="ln296">		// eliminate</a>
<a name="ln297">		for (int j = i + 1; j &lt; n; j++) {</a>
<a name="ln298">			int index = indices[j];</a>
<a name="ln299">			double q = -a[index][i] / a[pivot][i];</a>
<a name="ln300">			a[index][i] = 0;</a>
<a name="ln301">			for (int k = i + 1; k &lt; n; k++)</a>
<a name="ln302">				a[index][k] += a[pivot][k] * q;</a>
<a name="ln303">			b[j] += b[i] * q;</a>
<a name="ln304">		}</a>
<a name="ln305">	}</a>
<a name="ln306"> </a>
<a name="ln307">	// backwards substitution</a>
<a name="ln308">	for (int i = n - 1; i &gt;= 0; i--) {</a>
<a name="ln309">		int index = indices[i];</a>
<a name="ln310">		double sum = b[i];</a>
<a name="ln311">		for (int j = i + 1; j &lt; n; j++)</a>
<a name="ln312">			sum -= a[index][j] * b[j];</a>
<a name="ln313"> </a>
<a name="ln314">		b[i] = sum / a[index][i];</a>
<a name="ln315">	}</a>
<a name="ln316"> </a>
<a name="ln317">	return true;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">int</a>
<a name="ln322">compute_dependencies(double** a, int m, int n, bool* independent)</a>
<a name="ln323">{</a>
<a name="ln324">	// index array for row permutation</a>
<a name="ln325">	// Note: We could eliminate it, if we would permutate the row pointers of a.</a>
<a name="ln326">	int indices[m];</a>
<a name="ln327">	for (int i = 0; i &lt; m; i++)</a>
<a name="ln328">		indices[i] = i;</a>
<a name="ln329"> </a>
<a name="ln330">	// forward elimination</a>
<a name="ln331">	int iterations = (m &gt; n ? n : m);</a>
<a name="ln332">	int i = 0;</a>
<a name="ln333">	int column = 0;</a>
<a name="ln334">	for (; i &lt; iterations &amp;&amp; column &lt; n; i++) {</a>
<a name="ln335">		// find next pivot</a>
<a name="ln336">		int pivot = i;</a>
<a name="ln337">		do {</a>
<a name="ln338">			double pivotValue = fabs(a[indices[i]][column]);</a>
<a name="ln339">			for (int j = i + 1; j &lt; m; j++) {</a>
<a name="ln340">				int index = indices[j];</a>
<a name="ln341">				double value = fabs(a[index][column]);</a>
<a name="ln342">				if (value &gt; pivotValue) {</a>
<a name="ln343">					pivot = j;</a>
<a name="ln344">					pivotValue = value;</a>
<a name="ln345">				}</a>
<a name="ln346">			}</a>
<a name="ln347"> </a>
<a name="ln348">			if (!fuzzy_equals(pivotValue, 0))</a>
<a name="ln349">				break;</a>
<a name="ln350"> </a>
<a name="ln351">			column++;</a>
<a name="ln352">		} while (column &lt; n);</a>
<a name="ln353"> </a>
<a name="ln354">		if (column == n)</a>
<a name="ln355">			break;</a>
<a name="ln356"> </a>
<a name="ln357">		if (pivot != i)</a>
<a name="ln358">			swap(indices[i], indices[pivot]);</a>
<a name="ln359">		pivot = indices[i];</a>
<a name="ln360"> </a>
<a name="ln361">		independent[pivot] = true;</a>
<a name="ln362"> </a>
<a name="ln363">		// eliminate</a>
<a name="ln364">		for (int j = i + 1; j &lt; m; j++) {</a>
<a name="ln365">			int index = indices[j];</a>
<a name="ln366">			double q = -a[index][column] / a[pivot][column];</a>
<a name="ln367">			a[index][column] = 0;</a>
<a name="ln368">			for (int k = column + 1; k &lt; n; k++)</a>
<a name="ln369">				a[index][k] += a[pivot][k] * q;</a>
<a name="ln370">		}</a>
<a name="ln371"> </a>
<a name="ln372">		column++;</a>
<a name="ln373">	}</a>
<a name="ln374"> </a>
<a name="ln375">	for (int j = i; j &lt; m; j++)</a>
<a name="ln376">		independent[indices[j]] = false;</a>
<a name="ln377"> </a>
<a name="ln378">	return i;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381"> </a>
<a name="ln382">// remove_linearly_dependent_rows</a>
<a name="ln383">static int</a>
<a name="ln384">remove_linearly_dependent_rows(double** A, double** temp, bool* independentRows,</a>
<a name="ln385">	int m, int n)</a>
<a name="ln386">{</a>
<a name="ln387">	// copy to temp</a>
<a name="ln388">	copy_matrix(A, temp, m, n);</a>
<a name="ln389"> </a>
<a name="ln390">	int count = compute_dependencies(temp, m, n, independentRows);</a>
<a name="ln391">	if (count == m)</a>
<a name="ln392">		return count;</a>
<a name="ln393"> </a>
<a name="ln394">	// remove the rows</a>
<a name="ln395">	int index = 0;</a>
<a name="ln396">	for (int i = 0; i &lt; m; i++) {</a>
<a name="ln397">		if (independentRows[i]) {</a>
<a name="ln398">			if (index &lt; i) {</a>
<a name="ln399">				for (int k = 0; k &lt; n; k++)</a>
<a name="ln400">					A[index][k] = A[i][k];</a>
<a name="ln401">			}</a>
<a name="ln402">			index++;</a>
<a name="ln403">		}</a>
<a name="ln404">	}</a>
<a name="ln405"> </a>
<a name="ln406">	return count;</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409"> </a>
<a name="ln410">/*!	QR decomposition using Householder transformations.</a>
<a name="ln411">*/</a>
<a name="ln412">bool</a>
<a name="ln413">qr_decomposition(double** a, int m, int n, double* d, double** q)</a>
<a name="ln414">{</a>
<a name="ln415">	if (m &lt; n)</a>
<a name="ln416">		return false;</a>
<a name="ln417"> </a>
<a name="ln418">	for (int j = 0; j &lt; n; j++) {</a>
<a name="ln419">		// inner product of the first vector x of the (j,j) minor</a>
<a name="ln420">		double innerProductU = 0;</a>
<a name="ln421">		for (int i = j + 1; i &lt; m; i++)</a>
<a name="ln422">			innerProductU = innerProductU + a[i][j] * a[i][j];</a>
<a name="ln423">		double innerProduct = innerProductU + a[j][j] * a[j][j];</a>
<a name="ln424">		if (fuzzy_equals(innerProduct, 0)) {</a>
<a name="ln425">			TRACE_ERROR(&quot;qr_decomposition(): 0 column %d\n&quot;, j);</a>
<a name="ln426">			return false;</a>
<a name="ln427">		}</a>
<a name="ln428"> </a>
<a name="ln429">		// alpha (norm of x with opposite signedness of x_1) and thus r_{j,j}</a>
<a name="ln430">		double alpha = (a[j][j] &lt; 0 ? sqrt(innerProduct) : -sqrt(innerProduct));</a>
<a name="ln431">		d[j] = alpha;</a>
<a name="ln432"> </a>
<a name="ln433">		double beta = 1 / (alpha * a[j][j] - innerProduct);</a>
<a name="ln434"> </a>
<a name="ln435">		// u = x - alpha * e_1</a>
<a name="ln436">		// (u is a[j..n][j])</a>
<a name="ln437">		a[j][j] -= alpha;</a>
<a name="ln438"> </a>
<a name="ln439">		// left-multiply A_k with Q_k, thus obtaining a row of R and the A_{k+1}</a>
<a name="ln440">		// for the next iteration</a>
<a name="ln441">		for (int k = j + 1; k &lt; n; k++) {</a>
<a name="ln442">			double sum = 0;</a>
<a name="ln443">			for (int i = j; i &lt; m; i++)</a>
<a name="ln444">				sum += a[i][j] * a[i][k];</a>
<a name="ln445">			sum *= beta;</a>
<a name="ln446"> </a>
<a name="ln447">			for (int i = j; i &lt; m; i++)</a>
<a name="ln448">				a[i][k] += a[i][j] * sum;</a>
<a name="ln449">		}</a>
<a name="ln450"> </a>
<a name="ln451">		// v = u/|u|</a>
<a name="ln452">		innerProductU += a[j][j] * a[j][j];</a>
<a name="ln453">		double beta2 = -2 / innerProductU;</a>
<a name="ln454"> </a>
<a name="ln455">		// right-multiply Q with Q_k</a>
<a name="ln456">		// Q_k = I - 2vv^T</a>
<a name="ln457">		// Q * Q_k = Q - 2 * Q * vv^T</a>
<a name="ln458">		if (j == 0) {</a>
<a name="ln459">			for (int k = 0; k &lt; m; k++) {</a>
<a name="ln460">				for (int i = 0; i &lt; m; i++)</a>
<a name="ln461">					q[k][i] = beta2 * a[k][0] * a[i][0];</a>
<a name="ln462"> </a>
<a name="ln463">				q[k][k] += 1;</a>
<a name="ln464">			}</a>
<a name="ln465">		} else {</a>
<a name="ln466">			for (int k = 0; k &lt; m; k++) {</a>
<a name="ln467">				double sum = 0;</a>
<a name="ln468">				for (int i = j; i &lt; m; i++)</a>
<a name="ln469">					sum += q[k][i] * a[i][j];</a>
<a name="ln470">				sum *= beta2;</a>
<a name="ln471">	</a>
<a name="ln472">				for (int i = j; i &lt; m; i++)</a>
<a name="ln473">					q[k][i] += sum * a[i][j];</a>
<a name="ln474">			}</a>
<a name="ln475">		}</a>
<a name="ln476">	}</a>
<a name="ln477"> </a>
<a name="ln478">	return true;</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481"> </a>
<a name="ln482">// MatrixDeleter</a>
<a name="ln483">struct MatrixDelete {</a>
<a name="ln484">	inline void operator()(double** matrix)</a>
<a name="ln485">	{</a>
<a name="ln486">		free_matrix(matrix);</a>
<a name="ln487">	}</a>
<a name="ln488">};</a>
<a name="ln489">typedef BPrivate::AutoDeleter&lt;double*, MatrixDelete&gt; MatrixDeleter;</a>
<a name="ln490"> </a>
<a name="ln491"> </a>
<a name="ln492">// Constraint</a>
<a name="ln493">struct LayoutOptimizer::Constraint {</a>
<a name="ln494">	Constraint(int32 left, int32 right, double value, bool equality,</a>
<a name="ln495">			int32 index)</a>
<a name="ln496">		: left(left),</a>
<a name="ln497">		  right(right),</a>
<a name="ln498">		  value(value),</a>
<a name="ln499">		  index(index),</a>
<a name="ln500">		  equality(equality)</a>
<a name="ln501">	{</a>
<a name="ln502">	}</a>
<a name="ln503"> </a>
<a name="ln504">	double ActualValue(double* values) const</a>
<a name="ln505">	{</a>
<a name="ln506">		double result = 0;</a>
<a name="ln507">		if (right &gt;= 0)</a>
<a name="ln508">			result = values[right];</a>
<a name="ln509">		if (left &gt;= 0)</a>
<a name="ln510">			result -= values[left];</a>
<a name="ln511">		return result;</a>
<a name="ln512">	}</a>
<a name="ln513"> </a>
<a name="ln514">	void Print() const</a>
<a name="ln515">	{</a>
<a name="ln516">		TRACE(&quot;c[%2ld] - c[%2ld] %2s %4d\n&quot;, right, left,</a>
<a name="ln517">			(equality ? &quot;=&quot; : &quot;&gt;=&quot;), (int)value);</a>
<a name="ln518">	}</a>
<a name="ln519"> </a>
<a name="ln520">	int32	left;</a>
<a name="ln521">	int32	right;</a>
<a name="ln522">	double	value;</a>
<a name="ln523">	int32	index;</a>
<a name="ln524">	bool	equality;</a>
<a name="ln525">};</a>
<a name="ln526"> </a>
<a name="ln527"> </a>
<a name="ln528">// #pragma mark - LayoutOptimizer</a>
<a name="ln529"> </a>
<a name="ln530"> </a>
<a name="ln531">// constructor</a>
<a name="ln532">LayoutOptimizer::LayoutOptimizer(int32 variableCount)</a>
<a name="ln533">	: fVariableCount(variableCount),</a>
<a name="ln534">	  fConstraints(),</a>
<a name="ln535">	  fVariables(new (nothrow) double[variableCount])</a>
<a name="ln536">{</a>
<a name="ln537">	fTemp1 = allocate_matrix(fVariableCount, fVariableCount);</a>
<a name="ln538">	fTemp2 = allocate_matrix(fVariableCount, fVariableCount);</a>
<a name="ln539">	fZtrans = allocate_matrix(fVariableCount, fVariableCount);</a>
<a name="ln540">	fQ = allocate_matrix(fVariableCount, fVariableCount);</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543"> </a>
<a name="ln544">// destructor</a>
<a name="ln545">LayoutOptimizer::~LayoutOptimizer()</a>
<a name="ln546">{</a>
<a name="ln547">	free_matrix(fTemp1);</a>
<a name="ln548">	free_matrix(fTemp2);</a>
<a name="ln549">	free_matrix(fZtrans);</a>
<a name="ln550">	free_matrix(fQ);</a>
<a name="ln551"> </a>
<a name="ln552">	delete[] fVariables;</a>
<a name="ln553"> </a>
<a name="ln554">	for (int32 i = 0;</a>
<a name="ln555">		 Constraint* constraint = (Constraint*)fConstraints.ItemAt(i);</a>
<a name="ln556">		 i++) {</a>
<a name="ln557">		delete constraint;</a>
<a name="ln558">	}</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561"> </a>
<a name="ln562">// InitCheck</a>
<a name="ln563">status_t</a>
<a name="ln564">LayoutOptimizer::InitCheck() const</a>
<a name="ln565">{</a>
<a name="ln566">	if (!fVariables || !fTemp1 || !fTemp2 || !fZtrans || !fQ)</a>
<a name="ln567">		return B_NO_MEMORY;</a>
<a name="ln568">	return B_OK;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572">// Clone</a>
<a name="ln573">LayoutOptimizer*</a>
<a name="ln574">LayoutOptimizer::Clone() const</a>
<a name="ln575">{</a>
<a name="ln576">	LayoutOptimizer* clone = new(nothrow) LayoutOptimizer(fVariableCount);</a>
<a name="ln577">	ObjectDeleter&lt;LayoutOptimizer&gt; cloneDeleter(clone);</a>
<a name="ln578">	if (!clone || clone-&gt;InitCheck() != B_OK</a>
<a name="ln579">		|| !clone-&gt;AddConstraintsFrom(this)) {</a>
<a name="ln580">		return NULL;</a>
<a name="ln581">	}</a>
<a name="ln582"> </a>
<a name="ln583">	return cloneDeleter.Detach();</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586"> </a>
<a name="ln587">// AddConstraint</a>
<a name="ln588">/*!	Adds a constraint of the form</a>
<a name="ln589">	  \sum_{i=left+1}^{right} x_i &gt;=/= value, if left &lt; right</a>
<a name="ln590">	  -\sum_{i=right+1}^{left} x_i &gt;=/= value, if left &gt; right</a>
<a name="ln591">	If \a equality is \c true, the constraint is an equality constraint.</a>
<a name="ln592">*/</a>
<a name="ln593">bool</a>
<a name="ln594">LayoutOptimizer::AddConstraint(int32 left, int32 right, double value,</a>
<a name="ln595">	bool equality)</a>
<a name="ln596">{</a>
<a name="ln597">	Constraint* constraint = new(nothrow) Constraint(left, right, value,</a>
<a name="ln598">		equality, fConstraints.CountItems());</a>
<a name="ln599">	if (constraint == NULL)</a>
<a name="ln600">		return false;</a>
<a name="ln601"> </a>
<a name="ln602">	if (!fConstraints.AddItem(constraint)) {</a>
<a name="ln603">		delete constraint;</a>
<a name="ln604">		return false;</a>
<a name="ln605">	}</a>
<a name="ln606"> </a>
<a name="ln607">	return true;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">// AddConstraintsFrom</a>
<a name="ln612">bool</a>
<a name="ln613">LayoutOptimizer::AddConstraintsFrom(const LayoutOptimizer* other)</a>
<a name="ln614">{</a>
<a name="ln615">	if (!other || other-&gt;fVariableCount != fVariableCount)</a>
<a name="ln616">		return false;</a>
<a name="ln617"> </a>
<a name="ln618">	int32 count = fConstraints.CountItems();</a>
<a name="ln619">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln620">		Constraint* constraint = (Constraint*)other-&gt;fConstraints.ItemAt(i);</a>
<a name="ln621">		if (!AddConstraint(constraint-&gt;left, constraint-&gt;right,</a>
<a name="ln622">				constraint-&gt;value, constraint-&gt;equality)) {</a>
<a name="ln623">			return false;</a>
<a name="ln624">		}</a>
<a name="ln625">	}</a>
<a name="ln626"> </a>
<a name="ln627">	return true;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">// RemoveAllConstraints</a>
<a name="ln632">void</a>
<a name="ln633">LayoutOptimizer::RemoveAllConstraints()</a>
<a name="ln634">{</a>
<a name="ln635">	int32 count = fConstraints.CountItems();</a>
<a name="ln636">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln637">		Constraint* constraint = (Constraint*)fConstraints.ItemAt(i);</a>
<a name="ln638">		delete constraint;</a>
<a name="ln639">	}</a>
<a name="ln640">	fConstraints.MakeEmpty();</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643"> </a>
<a name="ln644">// Solve</a>
<a name="ln645">/*!	Solves the quadratic program (QP) given by the constraints added via</a>
<a name="ln646">	AddConstraint(), the additional constraint \sum_{i=0}^{n-1} x_i = size,</a>
<a name="ln647">	and the optimization criterion to minimize</a>
<a name="ln648">	\sum_{i=0}^{n-1} (x_i - desired[i])^2.</a>
<a name="ln649">	The \a values array must contain a feasible solution when called and will</a>
<a name="ln650">	be overwritten with the optimial solution the method computes.</a>
<a name="ln651">*/</a>
<a name="ln652">bool</a>
<a name="ln653">LayoutOptimizer::Solve(const double* desired, double size, double* values)</a>
<a name="ln654">{</a>
<a name="ln655">	if (fVariables == NULL || desired == NULL|| values == NULL)</a>
<a name="ln656">		return false;</a>
<a name="ln657"> </a>
<a name="ln658">	int32 constraintCount = fConstraints.CountItems() + 1;</a>
<a name="ln659"> </a>
<a name="ln660">	// allocate the active constraint matrix and its transposed matrix</a>
<a name="ln661">	fActiveMatrix = allocate_matrix(constraintCount, fVariableCount);</a>
<a name="ln662">	fActiveMatrixTemp = allocate_matrix(constraintCount, fVariableCount);</a>
<a name="ln663">	MatrixDeleter _(fActiveMatrix);</a>
<a name="ln664">	MatrixDeleter _2(fActiveMatrixTemp);</a>
<a name="ln665">	if (!fActiveMatrix || !fActiveMatrixTemp)</a>
<a name="ln666">		return false;</a>
<a name="ln667"> </a>
<a name="ln668">	// add sum constraint</a>
<a name="ln669">	if (!AddConstraint(-1, fVariableCount - 1, size, true))</a>
<a name="ln670">		return false;</a>
<a name="ln671"> </a>
<a name="ln672">	bool success = _Solve(desired, values);</a>
<a name="ln673"> </a>
<a name="ln674">	// remove sum constraint</a>
<a name="ln675">	Constraint* constraint = (Constraint*)fConstraints.RemoveItem(</a>
<a name="ln676">		constraintCount - 1);</a>
<a name="ln677">	delete constraint;</a>
<a name="ln678"> </a>
<a name="ln679">	return success;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682"> </a>
<a name="ln683">// _Solve</a>
<a name="ln684">bool</a>
<a name="ln685">LayoutOptimizer::_Solve(const double* desired, double* values)</a>
<a name="ln686">{</a>
<a name="ln687">	int32 constraintCount = fConstraints.CountItems();</a>
<a name="ln688"> </a>
<a name="ln689">TRACE_ONLY(</a>
<a name="ln690">	TRACE(&quot;constraints:\n&quot;);</a>
<a name="ln691">	for (int32 i = 0; i &lt; constraintCount; i++) {</a>
<a name="ln692">		TRACE(&quot; %-2ld:  &quot;, i);</a>
<a name="ln693">		((Constraint*)fConstraints.ItemAt(i))-&gt;Print();</a>
<a name="ln694">	}</a>
<a name="ln695">)</a>
<a name="ln696"> </a>
<a name="ln697">	// our QP is supposed to be in this form:</a>
<a name="ln698">	//   min_x 1/2x^TGx + x^Td</a>
<a name="ln699">	//   s.t. a_i^Tx = b_i,  i \in E</a>
<a name="ln700">	//        a_i^Tx &gt;= b_i, i \in I</a>
<a name="ln701"> </a>
<a name="ln702">	// init our initial x</a>
<a name="ln703">	double x[fVariableCount];</a>
<a name="ln704">	x[0] = values[0];</a>
<a name="ln705">	for (int i = 1; i &lt; fVariableCount; i++)</a>
<a name="ln706">		x[i] = values[i] + x[i - 1];</a>
<a name="ln707"> </a>
<a name="ln708">	// init d</a>
<a name="ln709">	// Note that the values of d and of G result from rewriting the</a>
<a name="ln710">	// ||x - desired|| we actually want to minimize.</a>
<a name="ln711">	double d[fVariableCount];</a>
<a name="ln712">	for (int i = 0; i &lt; fVariableCount - 1; i++)</a>
<a name="ln713">		d[i] = desired[i + 1] - desired[i];</a>
<a name="ln714">	d[fVariableCount - 1] = -desired[fVariableCount - 1];</a>
<a name="ln715"> </a>
<a name="ln716">	// init active set</a>
<a name="ln717">	BList activeConstraints(constraintCount);</a>
<a name="ln718"> </a>
<a name="ln719">	for (int32 i = 0; i &lt; constraintCount; i++) {</a>
<a name="ln720">		Constraint* constraint = (Constraint*)fConstraints.ItemAt(i);</a>
<a name="ln721">		double actualValue = constraint-&gt;ActualValue(x);</a>
<a name="ln722">		TRACE(&quot;constraint %ld: actual: %f  constraint: %f\n&quot;, i, actualValue,</a>
<a name="ln723">			constraint-&gt;value);</a>
<a name="ln724">		if (fuzzy_equals(actualValue, constraint-&gt;value))</a>
<a name="ln725">			activeConstraints.AddItem(constraint);</a>
<a name="ln726">	}</a>
<a name="ln727"> </a>
<a name="ln728">	// The main loop: Each iteration we try to get closer to the optimum</a>
<a name="ln729">	// solution. We compute a vector p that brings our x closer to the optimum.</a>
<a name="ln730">	// We do that by computing the QP resulting from our active constraint set,</a>
<a name="ln731">	// W^k. Afterward each iteration we adjust the active set.</a>
<a name="ln732">TRACE_ONLY(int iteration = 0;)</a>
<a name="ln733">	while (true) {</a>
<a name="ln734">TRACE_ONLY(</a>
<a name="ln735">		TRACE(&quot;\n[iteration %d]\n&quot;, iteration++);</a>
<a name="ln736">		TRACE(&quot;active set:\n&quot;);</a>
<a name="ln737">		for (int32 i = 0; i &lt; activeConstraints.CountItems(); i++) {</a>
<a name="ln738">			TRACE(&quot;  &quot;);</a>
<a name="ln739">			((Constraint*)activeConstraints.ItemAt(i))-&gt;Print();</a>
<a name="ln740">		}</a>
<a name="ln741">)</a>
<a name="ln742"> </a>
<a name="ln743">		// solve the QP:</a>
<a name="ln744">		//   min_p 1/2p^TGp + g_k^Tp</a>
<a name="ln745">		//   s.t. a_i^Tp = 0</a>
<a name="ln746">		//   with a_i \in activeConstraints</a>
<a name="ln747">		//        g_k = Gx_k + d</a>
<a name="ln748">		//        p = x - x_k</a>
<a name="ln749"> </a>
<a name="ln750">		int32 activeCount = activeConstraints.CountItems();</a>
<a name="ln751">		if (activeCount == 0) {</a>
<a name="ln752">			TRACE_ERROR(&quot;Solve(): Error: No more active constraints!\n&quot;);</a>
<a name="ln753">			return false;</a>
<a name="ln754">		}</a>
<a name="ln755"> </a>
<a name="ln756">		// construct a matrix from the active constraints</a>
<a name="ln757">		int am = activeCount;</a>
<a name="ln758">		const int an = fVariableCount;</a>
<a name="ln759">		bool independentRows[activeCount];</a>
<a name="ln760">		zero_matrix(fActiveMatrix, am, an);</a>
<a name="ln761"> </a>
<a name="ln762">		for (int32 i = 0; i &lt; activeCount; i++) {</a>
<a name="ln763">			Constraint* constraint = (Constraint*)activeConstraints.ItemAt(i);</a>
<a name="ln764">			if (constraint-&gt;right &gt;= 0)</a>
<a name="ln765">				fActiveMatrix[i][constraint-&gt;right] = 1;</a>
<a name="ln766">			if (constraint-&gt;left &gt;= 0)</a>
<a name="ln767">				fActiveMatrix[i][constraint-&gt;left] = -1;</a>
<a name="ln768">		}</a>
<a name="ln769"> </a>
<a name="ln770">// TODO: The fActiveMatrix is sparse (max 2 entries per row). There should be</a>
<a name="ln771">// some room for optimization.</a>
<a name="ln772">		am = remove_linearly_dependent_rows(fActiveMatrix, fActiveMatrixTemp,</a>
<a name="ln773">			independentRows, am, an);</a>
<a name="ln774"> </a>
<a name="ln775">		// gxd = G * x + d</a>
<a name="ln776">		double gxd[fVariableCount];</a>
<a name="ln777">		multiply_optimization_matrix_vector(x, fVariableCount, gxd);</a>
<a name="ln778">		add_vectors(gxd, d, fVariableCount);</a>
<a name="ln779"> </a>
<a name="ln780">		double p[fVariableCount];</a>
<a name="ln781">		if (!_SolveSubProblem(gxd, am, p))</a>
<a name="ln782">			return false;</a>
<a name="ln783"> </a>
<a name="ln784">		if (is_zero(p, fVariableCount)) {</a>
<a name="ln785">			// compute Lagrange multipliers lambda_i</a>
<a name="ln786">			// if lambda_i &gt;= 0 for all i \in W^k \union inequality constraints,</a>
<a name="ln787">			// then we're done.</a>
<a name="ln788">			// Otherwise remove the constraint with the smallest lambda_i</a>
<a name="ln789">			// from the active set.</a>
<a name="ln790">			// The derivation of the Lagrangian yields:</a>
<a name="ln791">			//   \sum_{i \in W^k}(lambda_ia_i) = Gx_k + d</a>
<a name="ln792">			// Which is an system we can solve:</a>
<a name="ln793">			//   A^Tlambda = Gx_k + d</a>
<a name="ln794"> </a>
<a name="ln795">			// A^T is over-determined, hence we need to reduce the number of</a>
<a name="ln796">			// rows before we can solve it.</a>
<a name="ln797">			bool independentColumns[an];</a>
<a name="ln798">			double** aa = fTemp1;</a>
<a name="ln799">			transpose_matrix(fActiveMatrix, aa, am, an);</a>
<a name="ln800">			const int aam = remove_linearly_dependent_rows(aa, fTemp2,</a>
<a name="ln801">				independentColumns, an, am);</a>
<a name="ln802">			const int aan = am;</a>
<a name="ln803">			if (aam != aan) {</a>
<a name="ln804">				// This should not happen, since A has full row rank.</a>
<a name="ln805">				TRACE_ERROR(&quot;Solve(): Transposed A has less linear independent &quot;</a>
<a name="ln806">					&quot;rows than it has columns!\n&quot;);</a>
<a name="ln807">				return false;</a>
<a name="ln808">			}</a>
<a name="ln809"> </a>
<a name="ln810">			// also reduce the number of rows on the right hand side</a>
<a name="ln811">			double lambda[aam];</a>
<a name="ln812">			int index = 0;</a>
<a name="ln813">			for (int i = 0; i &lt; an; i++) {</a>
<a name="ln814">				if (independentColumns[i])</a>
<a name="ln815">					lambda[index++] = gxd[i];</a>
<a name="ln816">			}</a>
<a name="ln817"> </a>
<a name="ln818">			bool success = solve(aa, aam, lambda);</a>
<a name="ln819">			if (!success) {</a>
<a name="ln820">				// Impossible, since we've removed all linearly dependent rows.</a>
<a name="ln821">				TRACE_ERROR(&quot;Solve(): Failed to compute lambda!\n&quot;);</a>
<a name="ln822">				return false;</a>
<a name="ln823">			}</a>
<a name="ln824"> </a>
<a name="ln825">			// find min lambda_i (only, if it's &lt; 0, though)</a>
<a name="ln826">			double minLambda = 0;</a>
<a name="ln827">			int minIndex = -1;</a>
<a name="ln828">			index = 0;</a>
<a name="ln829">			for (int i = 0; i &lt; activeCount; i++) {</a>
<a name="ln830">				if (independentRows[i]) {</a>
<a name="ln831">					Constraint* constraint</a>
<a name="ln832">						= (Constraint*)activeConstraints.ItemAt(i);</a>
<a name="ln833">					if (!constraint-&gt;equality) {</a>
<a name="ln834">						if (lambda[index] &lt; minLambda) {</a>
<a name="ln835">							minLambda = lambda[index];</a>
<a name="ln836">							minIndex = i;</a>
<a name="ln837">						}</a>
<a name="ln838">					}</a>
<a name="ln839"> </a>
<a name="ln840">					index++;</a>
<a name="ln841">				}</a>
<a name="ln842">			}</a>
<a name="ln843"> </a>
<a name="ln844">			// if the min lambda is &gt;= 0, we're done</a>
<a name="ln845">			if (minIndex &lt; 0 || fuzzy_equals(minLambda, 0)) {</a>
<a name="ln846">				_SetResult(x, values);</a>
<a name="ln847">				return true;</a>
<a name="ln848">			}</a>
<a name="ln849"> </a>
<a name="ln850">			// remove i from the active set</a>
<a name="ln851">			activeConstraints.RemoveItem(minIndex);</a>
<a name="ln852"> </a>
<a name="ln853">		} else {</a>
<a name="ln854">			// compute alpha_k</a>
<a name="ln855">			double alpha = 1;</a>
<a name="ln856">			int barrier = -1;</a>
<a name="ln857">			// if alpha_k &lt; 1, add a barrier constraint to W^k</a>
<a name="ln858">			for (int32 i = 0; i &lt; constraintCount; i++) {</a>
<a name="ln859">				Constraint* constraint = (Constraint*)fConstraints.ItemAt(i);</a>
<a name="ln860">				if (activeConstraints.HasItem(constraint))</a>
<a name="ln861">					continue;</a>
<a name="ln862"> </a>
<a name="ln863">				double divider = constraint-&gt;ActualValue(p);</a>
<a name="ln864">				if (divider &gt; 0 || fuzzy_equals(divider, 0))</a>
<a name="ln865">					continue;</a>
<a name="ln866"> </a>
<a name="ln867">				// (b_i - a_i^Tx_k) / a_i^Tp_k</a>
<a name="ln868">				double alphaI = constraint-&gt;value</a>
<a name="ln869">					- constraint-&gt;ActualValue(x);</a>
<a name="ln870">				alphaI /= divider;</a>
<a name="ln871">				if (alphaI &lt; alpha) {</a>
<a name="ln872">					alpha = alphaI;</a>
<a name="ln873">					barrier = i;</a>
<a name="ln874">				}</a>
<a name="ln875">			}</a>
<a name="ln876">			TRACE(&quot;alpha: %f, barrier: %d\n&quot;, alpha, barrier);</a>
<a name="ln877"> </a>
<a name="ln878">			if (alpha &lt; 1)</a>
<a name="ln879">				activeConstraints.AddItem(fConstraints.ItemAt(barrier));</a>
<a name="ln880"> </a>
<a name="ln881">			// x += p * alpha;</a>
<a name="ln882">			add_vectors_scaled(x, p, alpha, fVariableCount);</a>
<a name="ln883">		}</a>
<a name="ln884">	}</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887"> </a>
<a name="ln888">bool</a>
<a name="ln889">LayoutOptimizer::_SolveSubProblem(const double* d, int am, double* p)</a>
<a name="ln890">{</a>
<a name="ln891">	// We have to solve the QP subproblem:</a>
<a name="ln892">	//   min_p 1/2p^TGp + d^Tp</a>
<a name="ln893">	//   s.t. a_i^Tp = 0</a>
<a name="ln894">	//   with a_i \in activeConstraints</a>
<a name="ln895">	//</a>
<a name="ln896">	// We use the null space method, i.e. we find matrices Y and Z, such that</a>
<a name="ln897">	// AZ = 0 and [Y Z] is regular. Then with</a>
<a name="ln898">	//   p = Yp_Y + Zp_z</a>
<a name="ln899">	// we get</a>
<a name="ln900">	//   p_Y = 0</a>
<a name="ln901">	// and</a>
<a name="ln902">	//  (Z^TGZ)p_Z = -(Z^TYp_Y + Z^Tg) = -Z^Td</a>
<a name="ln903">	// which is a linear equation system, which we can solve.</a>
<a name="ln904"> </a>
<a name="ln905">	const int an = fVariableCount;</a>
<a name="ln906"> </a>
<a name="ln907">	// we get Y and Z by QR decomposition of A^T</a>
<a name="ln908">	double tempD[am];</a>
<a name="ln909">	double** const Q = fQ;</a>
<a name="ln910">	transpose_matrix(fActiveMatrix, fTemp1, am, an);</a>
<a name="ln911">	bool success = qr_decomposition(fTemp1, an, am, tempD, Q);</a>
<a name="ln912">	if (!success) {</a>
<a name="ln913">		TRACE_ERROR(&quot;Solve(): QR decomposition failed!\n&quot;);</a>
<a name="ln914">		return false;</a>
<a name="ln915">	}</a>
<a name="ln916"> </a>
<a name="ln917">	// Z is the (1, m + 1) minor of Q</a>
<a name="ln918">	const int zm = an;</a>
<a name="ln919">	const int zn = an - am;</a>
<a name="ln920">	double* Z[zm];</a>
<a name="ln921">	for (int i = 0; i &lt; zm; i++)</a>
<a name="ln922">		Z[i] = Q[i] + am;</a>
<a name="ln923"> </a>
<a name="ln924">	// solve (Z^TGZ)p_Z = -Z^Td</a>
<a name="ln925"> </a>
<a name="ln926">	// Z^T</a>
<a name="ln927">	transpose_matrix(Z, fZtrans, zm, zn);</a>
<a name="ln928">	// rhs: -Z^T * d;</a>
<a name="ln929">	double pz[zm];</a>
<a name="ln930">	multiply_matrix_vector(fZtrans, d, zn, zm, pz);</a>
<a name="ln931">	negate_vector(pz, zn);</a>
<a name="ln932"> </a>
<a name="ln933">	// fTemp2 = Ztrans * G * Z</a>
<a name="ln934">	multiply_optimization_matrix_matrix(Z, an, zn, fTemp1);</a>
<a name="ln935">	multiply_matrices(fZtrans, fTemp1, fTemp2, zn, zm, zn);</a>
<a name="ln936"> </a>
<a name="ln937">	success = solve(fTemp2, zn, pz);</a>
<a name="ln938">	if (!success) {</a>
<a name="ln939">		TRACE_ERROR(&quot;Solve(): Failed to solve() system for p_Z\n&quot;);</a>
<a name="ln940">		return false;</a>
<a name="ln941">	}</a>
<a name="ln942"> </a>
<a name="ln943">	// p = Z * pz;</a>
<a name="ln944">	multiply_matrix_vector(Z, pz, zm, zn, p);</a>
<a name="ln945"> </a>
<a name="ln946">	return true;</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949"> </a>
<a name="ln950">// _SetResult</a>
<a name="ln951">void</a>
<a name="ln952">LayoutOptimizer::_SetResult(const double* x, double* values)</a>
<a name="ln953">{</a>
<a name="ln954">	values[0] = x[0];</a>
<a name="ln955">	for (int i = 1; i &lt; fVariableCount; i++)</a>
<a name="ln956">		values[i] = x[i] - x[i - 1];</a>
<a name="ln957">}</a>

</code></pre>
<div class="balloon" rel="532"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fActiveMatrix, fActiveMatrixTemp.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
