
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>PoseView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;PoseView.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;algorithm&gt;</a>
<a name="ln39">#include &lt;functional&gt;</a>
<a name="ln40">#include &lt;map&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;ctype.h&gt;</a>
<a name="ln43">#include &lt;errno.h&gt;</a>
<a name="ln44">#include &lt;float.h&gt;</a>
<a name="ln45">#include &lt;stdlib.h&gt;</a>
<a name="ln46">#include &lt;strings.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;compat/sys/stat.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;Alert.h&gt;</a>
<a name="ln51">#include &lt;Application.h&gt;</a>
<a name="ln52">#include &lt;Catalog.h&gt;</a>
<a name="ln53">#include &lt;Clipboard.h&gt;</a>
<a name="ln54">#include &lt;Debug.h&gt;</a>
<a name="ln55">#include &lt;Dragger.h&gt;</a>
<a name="ln56">#include &lt;fs_attr.h&gt;</a>
<a name="ln57">#include &lt;fs_info.h&gt;</a>
<a name="ln58">#include &lt;Screen.h&gt;</a>
<a name="ln59">#include &lt;Query.h&gt;</a>
<a name="ln60">#include &lt;List.h&gt;</a>
<a name="ln61">#include &lt;Locale.h&gt;</a>
<a name="ln62">#include &lt;LongAndDragTrackingFilter.h&gt;</a>
<a name="ln63">#include &lt;MenuItem.h&gt;</a>
<a name="ln64">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln65">#include &lt;Path.h&gt;</a>
<a name="ln66">#include &lt;StopWatch.h&gt;</a>
<a name="ln67">#include &lt;String.h&gt;</a>
<a name="ln68">#include &lt;SymLink.h&gt;</a>
<a name="ln69">#include &lt;TextView.h&gt;</a>
<a name="ln70">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln71">#include &lt;Volume.h&gt;</a>
<a name="ln72">#include &lt;Window.h&gt;</a>
<a name="ln73"> </a>
<a name="ln74">#include &lt;ObjectListPrivate.h&gt;</a>
<a name="ln75">#include &lt;PathMonitor.h&gt;</a>
<a name="ln76"> </a>
<a name="ln77">#include &quot;Attributes.h&quot;</a>
<a name="ln78">#include &quot;AutoLock.h&quot;</a>
<a name="ln79">#include &quot;BackgroundImage.h&quot;</a>
<a name="ln80">#include &quot;Bitmaps.h&quot;</a>
<a name="ln81">#include &quot;Commands.h&quot;</a>
<a name="ln82">#include &quot;CountView.h&quot;</a>
<a name="ln83">#include &quot;DeskWindow.h&quot;</a>
<a name="ln84">#include &quot;DesktopPoseView.h&quot;</a>
<a name="ln85">#include &quot;FilePanelPriv.h&quot;</a>
<a name="ln86">#include &quot;FSClipboard.h&quot;</a>
<a name="ln87">#include &quot;FSUtils.h&quot;</a>
<a name="ln88">#include &quot;FunctionObject.h&quot;</a>
<a name="ln89">#include &quot;MimeTypes.h&quot;</a>
<a name="ln90">#include &quot;Navigator.h&quot;</a>
<a name="ln91">#include &quot;Pose.h&quot;</a>
<a name="ln92">#include &quot;InfoWindow.h&quot;</a>
<a name="ln93">#include &quot;Tests.h&quot;</a>
<a name="ln94">#include &quot;Thread.h&quot;</a>
<a name="ln95">#include &quot;Tracker.h&quot;</a>
<a name="ln96">#include &quot;TrackerString.h&quot;</a>
<a name="ln97">#include &quot;WidgetAttributeText.h&quot;</a>
<a name="ln98">#include &quot;WidthBuffer.h&quot;</a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln102">#define B_TRANSLATION_CONTEXT &quot;PoseView&quot;</a>
<a name="ln103"> </a>
<a name="ln104"> </a>
<a name="ln105">const float kDoubleClickTresh = 6;</a>
<a name="ln106"> </a>
<a name="ln107">const uint32 kAddNewPoses = 'Tanp';</a>
<a name="ln108">const uint32 kAddPosesCompleted = 'Tapc';</a>
<a name="ln109">const int32 kMaxAddPosesChunk = 50;</a>
<a name="ln110">const uint32 kMsgMouseDragged = 'Mdrg';</a>
<a name="ln111">const uint32 kMsgMouseLongDown = 'Mold';</a>
<a name="ln112"> </a>
<a name="ln113">const int32 kRoomForLine = 2;</a>
<a name="ln114"> </a>
<a name="ln115">const int32 kMenuTrackMargin = 20;</a>
<a name="ln116"> </a>
<a name="ln117">const float kSlowScrollBucket = 30;</a>
<a name="ln118">const float kBorderHeight = 20;</a>
<a name="ln119"> </a>
<a name="ln120">enum {</a>
<a name="ln121">	kAutoScrollOff,</a>
<a name="ln122">	kWaitForTransition,</a>
<a name="ln123">	kDelayAutoScroll,</a>
<a name="ln124">	kAutoScrollOn</a>
<a name="ln125">};</a>
<a name="ln126"> </a>
<a name="ln127">enum {</a>
<a name="ln128">	kWasDragged,</a>
<a name="ln129">	kContextMenuShown,</a>
<a name="ln130">	kNotDragged</a>
<a name="ln131">};</a>
<a name="ln132"> </a>
<a name="ln133">enum {</a>
<a name="ln134">	kInsertAtFront,</a>
<a name="ln135">	kInsertAfter</a>
<a name="ln136">};</a>
<a name="ln137"> </a>
<a name="ln138">const BPoint kTransparentDragThreshold(256, 192);</a>
<a name="ln139">	// maximum size of the transparent drag bitmap, use a drag rect</a>
<a name="ln140">	// if larger in any direction</a>
<a name="ln141"> </a>
<a name="ln142">struct attr_column_relation {</a>
<a name="ln143">	uint32	attrHash;</a>
<a name="ln144">	int32	fieldMask;</a>
<a name="ln145">};</a>
<a name="ln146"> </a>
<a name="ln147">static struct attr_column_relation sAttrColumnMap[] = {</a>
<a name="ln148">	{ AttrHashString(kAttrStatModified, B_TIME_TYPE),</a>
<a name="ln149">		B_STAT_MODIFICATION_TIME },</a>
<a name="ln150">	{ AttrHashString(kAttrStatSize, B_OFF_T_TYPE),</a>
<a name="ln151">		B_STAT_SIZE },</a>
<a name="ln152">	{ AttrHashString(kAttrStatCreated, B_TIME_TYPE),</a>
<a name="ln153">		B_STAT_CREATION_TIME },</a>
<a name="ln154">	{ AttrHashString(kAttrStatMode, B_STRING_TYPE),</a>
<a name="ln155">		B_STAT_MODE }</a>
<a name="ln156">};</a>
<a name="ln157"> </a>
<a name="ln158">struct AddPosesResult {</a>
<a name="ln159">	~AddPosesResult();</a>
<a name="ln160">	void ReleaseModels();</a>
<a name="ln161"> </a>
<a name="ln162">	Model* fModels[kMaxAddPosesChunk];</a>
<a name="ln163">	PoseInfo fPoseInfos[kMaxAddPosesChunk];</a>
<a name="ln164">	int32 fCount;</a>
<a name="ln165">};</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">AddPosesResult::~AddPosesResult(void)</a>
<a name="ln169">{</a>
<a name="ln170">	for (int32 i = 0; i &lt; fCount; i++)</a>
<a name="ln171">		delete fModels[i];</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174"> </a>
<a name="ln175">void</a>
<a name="ln176">AddPosesResult::ReleaseModels(void)</a>
<a name="ln177">{</a>
<a name="ln178">	for (int32 i = 0; i &lt; kMaxAddPosesChunk; i++)</a>
<a name="ln179">		fModels[i] = NULL;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">static BPose*</a>
<a name="ln184">BSearch(PoseList* table, const BPose* key, BPoseView* view,</a>
<a name="ln185">	int (*cmp)(const BPose*, const BPose*, BPoseView*),</a>
<a name="ln186">	bool returnClosest = true);</a>
<a name="ln187"> </a>
<a name="ln188">static int</a>
<a name="ln189">PoseCompareAddWidget(const BPose* p1, const BPose* p2, BPoseView* view);</a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192">static bool</a>
<a name="ln193">OneMatches(BPose* pose, BPoseView*, void* castToPose)</a>
<a name="ln194">{</a>
<a name="ln195">	return pose == (const BPose*)castToPose;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198"> </a>
<a name="ln199">static void</a>
<a name="ln200">CopySelectionListToEntryRefList(const PoseList* original,</a>
<a name="ln201">	BObjectList&lt;entry_ref&gt;* copy)</a>
<a name="ln202">{</a>
<a name="ln203">	int32 count = original-&gt;CountItems();</a>
<a name="ln204">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln205">		copy-&gt;AddItem(new entry_ref(*(original-&gt;ItemAt(</a>
<a name="ln206">			index)-&gt;TargetModel()-&gt;EntryRef())));</a>
<a name="ln207">	}</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210"> </a>
<a name="ln211">//	#pragma mark - BPoseView</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">BPoseView::BPoseView(Model* model, uint32 viewMode)</a>
<a name="ln215">	:</a>
<a name="ln216">	BView(&quot;PoseView&quot;, B_WILL_DRAW | B_PULSE_NEEDED),</a>
<a name="ln217">	fIsDrawingSelectionRect(false),</a>
<a name="ln218">	fHScrollBar(NULL),</a>
<a name="ln219">	fVScrollBar(NULL),</a>
<a name="ln220">	fModel(model),</a>
<a name="ln221">	fActivePose(NULL),</a>
<a name="ln222">	fExtent(INT32_MAX, INT32_MAX, INT32_MIN, INT32_MIN),</a>
<a name="ln223">	fPoseList(new PoseList(40, true)),</a>
<a name="ln224">	fFilteredPoseList(new PoseList()),</a>
<a name="ln225">	fVSPoseList(new PoseList()),</a>
<a name="ln226">	fSelectionList(new PoseList()),</a>
<a name="ln227">	fMimeTypesInSelectionCache(20, true),</a>
<a name="ln228">	fZombieList(new BObjectList&lt;Model&gt;(10, true)),</a>
<a name="ln229">	fColumnList(new BObjectList&lt;BColumn&gt;(4, true)),</a>
<a name="ln230">	fMimeTypeList(new BObjectList&lt;BString&gt;(10, true)),</a>
<a name="ln231">	fBrokenLinks(new BObjectList&lt;Model&gt;(10, false)),</a>
<a name="ln232">	fMimeTypeListIsDirty(false),</a>
<a name="ln233">	fViewState(new BViewState),</a>
<a name="ln234">	fStateNeedsSaving(false),</a>
<a name="ln235">	fCountView(NULL),</a>
<a name="ln236">	fListElemHeight(0.0f),</a>
<a name="ln237">	fIconPoseHeight(0.0f),</a>
<a name="ln238">	fDropTarget(NULL),</a>
<a name="ln239">	fAlreadySelectedDropTarget(NULL),</a>
<a name="ln240">	fSelectionHandler(be_app),</a>
<a name="ln241">	fLastClickPoint(INT32_MAX, INT32_MAX),</a>
<a name="ln242">	fLastClickButtons(0),</a>
<a name="ln243">	fLastClickedPose(NULL),</a>
<a name="ln244">	fLastExtent(INT32_MAX, INT32_MAX, INT32_MIN, INT32_MIN),</a>
<a name="ln245">	fTitleView(NULL),</a>
<a name="ln246">	fRefFilter(NULL),</a>
<a name="ln247">	fAutoScrollInc(20),</a>
<a name="ln248">	fAutoScrollState(kAutoScrollOff),</a>
<a name="ln249">	fWidgetTextOutline(false),</a>
<a name="ln250">	fSelectionPivotPose(NULL),</a>
<a name="ln251">	fRealPivotPose(NULL),</a>
<a name="ln252">	fKeyRunner(NULL),</a>
<a name="ln253">	fTrackRightMouseUp(false),</a>
<a name="ln254">	fSelectionVisible(true),</a>
<a name="ln255">	fMultipleSelection(true),</a>
<a name="ln256">	fDragEnabled(true),</a>
<a name="ln257">	fDropEnabled(true),</a>
<a name="ln258">	fSelectionRectEnabled(true),</a>
<a name="ln259">	fAlwaysAutoPlace(false),</a>
<a name="ln260">	fAllowPoseEditing(true),</a>
<a name="ln261">	fSelectionChangedHook(false),</a>
<a name="ln262">	fSavePoseLocations(true),</a>
<a name="ln263">	fShowHideSelection(true),</a>
<a name="ln264">	fOkToMapIcons(false),</a>
<a name="ln265">	fEnsurePosesVisible(false),</a>
<a name="ln266">	fShouldAutoScroll(true),</a>
<a name="ln267">	fIsDesktopWindow(false),</a>
<a name="ln268">	fIsWatchingDateFormatChange(false),</a>
<a name="ln269">	fHasPosesInClipboard(false),</a>
<a name="ln270">	fCursorCheck(false),</a>
<a name="ln271">	fFiltering(false),</a>
<a name="ln272">	fFilterStrings(4, true),</a>
<a name="ln273">	fLastFilterStringCount(1),</a>
<a name="ln274">	fLastFilterStringLength(0),</a>
<a name="ln275">	fLastKeyTime(0),</a>
<a name="ln276">	fLastDeskbarFrameCheckTime(LONGLONG_MIN),</a>
<a name="ln277">	fDeskbarFrame(0, 0, -1, -1),</a>
<a name="ln278">	fTextWidgetToCheck(NULL)</a>
<a name="ln279">{</a>
<a name="ln280">	fListElemHeight = std::fmax(ListIconSize(),</a>
<a name="ln281">		ceilf(sFontHeight) &lt; 20 ? 20 : ceilf(sFontHeight * 1.1f));</a>
<a name="ln282"> </a>
<a name="ln283">	fViewState-&gt;SetViewMode(viewMode);</a>
<a name="ln284">	fShowSelectionWhenInactive</a>
<a name="ln285">		= TrackerSettings().ShowSelectionWhenInactive();</a>
<a name="ln286">	fTransparentSelection = TrackerSettings().TransparentSelection();</a>
<a name="ln287">	fFilterStrings.AddItem(new BString(&quot;&quot;));</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290"> </a>
<a name="ln291">BPoseView::~BPoseView()</a>
<a name="ln292">{</a>
<a name="ln293">	delete fPoseList;</a>
<a name="ln294">	delete fFilteredPoseList;</a>
<a name="ln295">	delete fVSPoseList;</a>
<a name="ln296">	delete fColumnList;</a>
<a name="ln297">	delete fSelectionList;</a>
<a name="ln298">	delete fMimeTypeList;</a>
<a name="ln299">	delete fZombieList;</a>
<a name="ln300">	delete fViewState;</a>
<a name="ln301">	delete fModel;</a>
<a name="ln302">	delete fKeyRunner;</a>
<a name="ln303">	delete fBrokenLinks;</a>
<a name="ln304"> </a>
<a name="ln305">	IconCache::sIconCache-&gt;Deleting(this);</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308"> </a>
<a name="ln309">void</a>
<a name="ln310">BPoseView::Init(AttributeStreamNode* node)</a>
<a name="ln311">{</a>
<a name="ln312">	RestoreState(node);</a>
<a name="ln313">	InitCommon();</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316"> </a>
<a name="ln317">void</a>
<a name="ln318">BPoseView::Init(const BMessage &amp;message)</a>
<a name="ln319">{</a>
<a name="ln320">	RestoreState(message);</a>
<a name="ln321">	InitCommon();</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324"> </a>
<a name="ln325">void</a>
<a name="ln326">BPoseView::InitCommon()</a>
<a name="ln327">{</a>
<a name="ln328">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln329"> </a>
<a name="ln330">	// Create the TitleView and CountView</a>
<a name="ln331">	fTitleView = new BTitleView(this);</a>
<a name="ln332">	if (ViewMode() != kListMode)</a>
<a name="ln333">		fTitleView-&gt;Hide();</a>
<a name="ln334">	if (fHScrollBar != NULL)</a>
<a name="ln335">		fHScrollBar-&gt;SetTitleView(fTitleView);</a>
<a name="ln336"> </a>
<a name="ln337">	fCountView = new BCountView(this);</a>
<a name="ln338"> </a>
<a name="ln339">	BPoint origin;</a>
<a name="ln340">	if (ViewMode() == kListMode)</a>
<a name="ln341">		origin = fViewState-&gt;ListOrigin();</a>
<a name="ln342">	else</a>
<a name="ln343">		origin = fViewState-&gt;IconOrigin();</a>
<a name="ln344"> </a>
<a name="ln345">	PinPointToValidRange(origin);</a>
<a name="ln346"> </a>
<a name="ln347">	// init things related to laying out items</a>
<a name="ln348">	SetIconPoseHeight();</a>
<a name="ln349">	GetLayoutInfo(ViewMode(), &amp;fGrid, &amp;fOffset);</a>
<a name="ln350">	ResetPosePlacementHint();</a>
<a name="ln351"> </a>
<a name="ln352">	DisableScrollBars();</a>
<a name="ln353">	ScrollTo(origin);</a>
<a name="ln354">	UpdateScrollRange();</a>
<a name="ln355">	SetScrollBarsTo(origin);</a>
<a name="ln356">	EnableScrollBars();</a>
<a name="ln357"> </a>
<a name="ln358">	StartWatching();</a>
<a name="ln359">		// turn on volume node monitor, metamime monitor, etc.</a>
<a name="ln360"> </a>
<a name="ln361">	// populate the window</a>
<a name="ln362">	if (window != NULL &amp;&amp; window-&gt;IsTrash())</a>
<a name="ln363">		AddTrashPoses();</a>
<a name="ln364">	else</a>
<a name="ln365">		AddPoses(TargetModel());</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368"> </a>
<a name="ln369">static int</a>
<a name="ln370">CompareColumns(const BColumn* c1, const BColumn* c2)</a>
<a name="ln371">{</a>
<a name="ln372">	if (c1-&gt;Offset() &gt; c2-&gt;Offset())</a>
<a name="ln373">		return 1;</a>
<a name="ln374">	else if (c1-&gt;Offset() &lt; c2-&gt;Offset())</a>
<a name="ln375">		return -1;</a>
<a name="ln376"> </a>
<a name="ln377">	return 0;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">void</a>
<a name="ln382">BPoseView::RestoreColumnState(AttributeStreamNode* node)</a>
<a name="ln383">{</a>
<a name="ln384">	fColumnList-&gt;MakeEmpty();</a>
<a name="ln385">	if (node != NULL) {</a>
<a name="ln386">		const char* columnsAttr;</a>
<a name="ln387">		const char* columnsAttrForeign;</a>
<a name="ln388">		if (TargetModel() &amp;&amp; TargetModel()-&gt;IsRoot()) {</a>
<a name="ln389">			columnsAttr = kAttrDisksColumns;</a>
<a name="ln390">			columnsAttrForeign = kAttrDisksColumnsForeign;</a>
<a name="ln391">		} else {</a>
<a name="ln392">			columnsAttr = kAttrColumns;</a>
<a name="ln393">			columnsAttrForeign = kAttrColumnsForeign;</a>
<a name="ln394">		}</a>
<a name="ln395"> </a>
<a name="ln396">		bool wrongEndianness = false;</a>
<a name="ln397">		const char* name = columnsAttr;</a>
<a name="ln398">		size_t size = (size_t)node-&gt;Contains(name, B_RAW_TYPE);</a>
<a name="ln399">		if (size == 0) {</a>
<a name="ln400">			name = columnsAttrForeign;</a>
<a name="ln401">			wrongEndianness = true;</a>
<a name="ln402">			size = (size_t)node-&gt;Contains(name, B_RAW_TYPE);</a>
<a name="ln403">		}</a>
<a name="ln404"> </a>
<a name="ln405">		if (size &gt; 0 &amp;&amp; size &lt; 10000) {</a>
<a name="ln406">			// check for invalid sizes here to protect against</a>
<a name="ln407">			// munged attributes</a>
<a name="ln408">			char* buffer = new char[size];</a>
<a name="ln409">			off_t result = node-&gt;Read(name, 0, B_RAW_TYPE, size, buffer);</a>
<a name="ln410">			if (result) {</a>
<a name="ln411">				BMallocIO stream;</a>
<a name="ln412">				stream.WriteAt(0, buffer, size);</a>
<a name="ln413">				stream.Seek(0, SEEK_SET);</a>
<a name="ln414"> </a>
<a name="ln415">				// Clear old column list if neccessary</a>
<a name="ln416"> </a>
<a name="ln417">				// Put items in the list in order so they can be checked</a>
<a name="ln418">				// for overlaps below.</a>
<a name="ln419">				BObjectList&lt;BColumn&gt; tempSortedList;</a>
<a name="ln420">				for (;;) {</a>
<a name="ln421">					BColumn* column = BColumn::InstantiateFromStream(&amp;stream,</a>
<a name="ln422">						wrongEndianness);</a>
<a name="ln423">					if (column == NULL)</a>
<a name="ln424">						break;</a>
<a name="ln425">					tempSortedList.AddItem(column);</a>
<a name="ln426">				}</a>
<a name="ln427">				AddColumnList(&amp;tempSortedList);</a>
<a name="ln428">			}</a>
<a name="ln429">			delete[] buffer;</a>
<a name="ln430">		}</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433">	_ResetStartOffset();</a>
<a name="ln434">	SetUpDefaultColumnsIfNeeded();</a>
<a name="ln435">	if (!ColumnFor(PrimarySort())) {</a>
<a name="ln436">		fViewState-&gt;SetPrimarySort(FirstColumn()-&gt;AttrHash());</a>
<a name="ln437">		fViewState-&gt;SetPrimarySortType(FirstColumn()-&gt;AttrType());</a>
<a name="ln438">	}</a>
<a name="ln439"> </a>
<a name="ln440">	if (PrimarySort() == SecondarySort())</a>
<a name="ln441">		fViewState-&gt;SetSecondarySort(0);</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">void</a>
<a name="ln446">BPoseView::RestoreColumnState(const BMessage &amp;message)</a>
<a name="ln447">{</a>
<a name="ln448">	fColumnList-&gt;MakeEmpty();</a>
<a name="ln449"> </a>
<a name="ln450">	BObjectList&lt;BColumn&gt; tempSortedList;</a>
<a name="ln451">	for (int32 index = 0; ; index++) {</a>
<a name="ln452">		BColumn* column = BColumn::InstantiateFromMessage(message, index);</a>
<a name="ln453">		if (column == NULL)</a>
<a name="ln454">			break;</a>
<a name="ln455"> </a>
<a name="ln456">		tempSortedList.AddItem(column);</a>
<a name="ln457">	}</a>
<a name="ln458"> </a>
<a name="ln459">	AddColumnList(&amp;tempSortedList);</a>
<a name="ln460"> </a>
<a name="ln461">	_ResetStartOffset();</a>
<a name="ln462">	SetUpDefaultColumnsIfNeeded();</a>
<a name="ln463">	if (!ColumnFor(PrimarySort())) {</a>
<a name="ln464">		fViewState-&gt;SetPrimarySort(FirstColumn()-&gt;AttrHash());</a>
<a name="ln465">		fViewState-&gt;SetPrimarySortType(FirstColumn()-&gt;AttrType());</a>
<a name="ln466">	}</a>
<a name="ln467"> </a>
<a name="ln468">	if (PrimarySort() == SecondarySort())</a>
<a name="ln469">		fViewState-&gt;SetSecondarySort(0);</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472"> </a>
<a name="ln473">void</a>
<a name="ln474">BPoseView::AddColumnList(BObjectList&lt;BColumn&gt;* list)</a>
<a name="ln475">{</a>
<a name="ln476">	list-&gt;SortItems(&amp;CompareColumns);</a>
<a name="ln477"> </a>
<a name="ln478">	float nextLeftEdge = 0;</a>
<a name="ln479">	for (int32 columIndex = 0; columIndex &lt; list-&gt;CountItems();</a>
<a name="ln480">			columIndex++) {</a>
<a name="ln481">		BColumn* column = list-&gt;ItemAt(columIndex);</a>
<a name="ln482"> </a>
<a name="ln483">		// Make sure that columns don't overlap</a>
<a name="ln484">		if (column-&gt;Offset() &lt; nextLeftEdge) {</a>
<a name="ln485">			PRINT((&quot;\t**Overlapped columns in archived column state\n&quot;));</a>
<a name="ln486">			column-&gt;SetOffset(nextLeftEdge);</a>
<a name="ln487">		}</a>
<a name="ln488"> </a>
<a name="ln489">		nextLeftEdge = column-&gt;Offset() + column-&gt;Width()</a>
<a name="ln490">			- kRoomForLine / 2.0f + kTitleColumnExtraMargin;</a>
<a name="ln491">		fColumnList-&gt;AddItem(column);</a>
<a name="ln492"> </a>
<a name="ln493">		if (!IsWatchingDateFormatChange()</a>
<a name="ln494">			&amp;&amp; column-&gt;AttrType() == B_TIME_TYPE) {</a>
<a name="ln495">			StartWatchDateFormatChange();</a>
<a name="ln496">		}</a>
<a name="ln497">	}</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500"> </a>
<a name="ln501">void</a>
<a name="ln502">BPoseView::RestoreState(AttributeStreamNode* node)</a>
<a name="ln503">{</a>
<a name="ln504">	RestoreColumnState(node);</a>
<a name="ln505"> </a>
<a name="ln506">	if (node != NULL) {</a>
<a name="ln507">		const char* viewStateAttr;</a>
<a name="ln508">		const char* viewStateAttrForeign;</a>
<a name="ln509"> </a>
<a name="ln510">		if (TargetModel() &amp;&amp; TargetModel()-&gt;IsRoot()) {</a>
<a name="ln511">			viewStateAttr = kAttrDisksViewState;</a>
<a name="ln512">			viewStateAttrForeign = kAttrDisksViewStateForeign;</a>
<a name="ln513">		} else {</a>
<a name="ln514">			viewStateAttr = ViewStateAttributeName();</a>
<a name="ln515">			viewStateAttrForeign = ForeignViewStateAttributeName();</a>
<a name="ln516">		}</a>
<a name="ln517"> </a>
<a name="ln518">		bool wrongEndianness = false;</a>
<a name="ln519">		const char* name = viewStateAttr;</a>
<a name="ln520">		size_t size = (size_t)node-&gt;Contains(name, B_RAW_TYPE);</a>
<a name="ln521">		if (!size) {</a>
<a name="ln522">			name = viewStateAttrForeign;</a>
<a name="ln523">			wrongEndianness = true;</a>
<a name="ln524">			size = (size_t)node-&gt;Contains(name, B_RAW_TYPE);</a>
<a name="ln525">		}</a>
<a name="ln526"> </a>
<a name="ln527">		if (size &gt; 0 &amp;&amp; size &lt; 10000) {</a>
<a name="ln528">			// check for invalid sizes here to protect against</a>
<a name="ln529">			// munged attributes</a>
<a name="ln530">			char* buffer = new char[size];</a>
<a name="ln531">			off_t result = node-&gt;Read(name, 0, B_RAW_TYPE, size, buffer);</a>
<a name="ln532">			if (result) {</a>
<a name="ln533">				BMallocIO stream;</a>
<a name="ln534">				stream.WriteAt(0, buffer, size);</a>
<a name="ln535">				stream.Seek(0, SEEK_SET);</a>
<a name="ln536">				BViewState* viewstate</a>
<a name="ln537">					= BViewState::InstantiateFromStream(&amp;stream,</a>
<a name="ln538">						wrongEndianness);</a>
<a name="ln539">				if (viewstate) {</a>
<a name="ln540">					delete fViewState;</a>
<a name="ln541">					fViewState = viewstate;</a>
<a name="ln542">				}</a>
<a name="ln543">			}</a>
<a name="ln544">			delete[] buffer;</a>
<a name="ln545">		}</a>
<a name="ln546">	}</a>
<a name="ln547"> </a>
<a name="ln548">	if (IsDesktopWindow() &amp;&amp; ViewMode() == kListMode) {</a>
<a name="ln549">		// recover if desktop window view state set wrong</a>
<a name="ln550">		fViewState-&gt;SetViewMode(kIconMode);</a>
<a name="ln551">	}</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554"> </a>
<a name="ln555">void</a>
<a name="ln556">BPoseView::RestoreState(const BMessage &amp;message)</a>
<a name="ln557">{</a>
<a name="ln558">	RestoreColumnState(message);</a>
<a name="ln559"> </a>
<a name="ln560">	BViewState* viewstate = BViewState::InstantiateFromMessage(message);</a>
<a name="ln561">	if (viewstate != NULL) {</a>
<a name="ln562">		delete fViewState;</a>
<a name="ln563">		fViewState = viewstate;</a>
<a name="ln564">	}</a>
<a name="ln565"> </a>
<a name="ln566">	if (IsDesktopWindow() &amp;&amp; ViewMode() == kListMode) {</a>
<a name="ln567">		// recover if desktop window view state set wrong</a>
<a name="ln568">		fViewState-&gt;SetViewMode(kIconMode);</a>
<a name="ln569">	}</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">namespace BPrivate {</a>
<a name="ln574"> </a>
<a name="ln575">bool</a>
<a name="ln576">ClearViewOriginOne(const char* DEBUG_ONLY(name), uint32 type, off_t size,</a>
<a name="ln577">	void* viewStateArchive, void*)</a>
<a name="ln578">{</a>
<a name="ln579">	ASSERT(strcmp(name, kAttrViewState) == 0);</a>
<a name="ln580"> </a>
<a name="ln581">	if (viewStateArchive == NULL)</a>
<a name="ln582">		return false;</a>
<a name="ln583"> </a>
<a name="ln584">	if (type != B_RAW_TYPE)</a>
<a name="ln585">		return false;</a>
<a name="ln586"> </a>
<a name="ln587">	BMallocIO stream;</a>
<a name="ln588">	stream.WriteAt(0, viewStateArchive, (size_t)size);</a>
<a name="ln589">	stream.Seek(0, SEEK_SET);</a>
<a name="ln590">	BViewState* viewstate = BViewState::InstantiateFromStream(&amp;stream, false);</a>
<a name="ln591">	if (!viewstate)</a>
<a name="ln592">		return false;</a>
<a name="ln593"> </a>
<a name="ln594">	// this is why we are here - zero out</a>
<a name="ln595">	viewstate-&gt;SetListOrigin(BPoint(0, 0));</a>
<a name="ln596">	viewstate-&gt;SetIconOrigin(BPoint(0, 0));</a>
<a name="ln597"> </a>
<a name="ln598">	stream.Seek(0, SEEK_SET);</a>
<a name="ln599">	viewstate-&gt;ArchiveToStream(&amp;stream);</a>
<a name="ln600">	stream.ReadAt(0, viewStateArchive, (size_t)size);</a>
<a name="ln601"> </a>
<a name="ln602">	return true;</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">}	// namespace BPrivate</a>
<a name="ln606"> </a>
<a name="ln607"> </a>
<a name="ln608">void</a>
<a name="ln609">BPoseView::SetUpDefaultColumnsIfNeeded()</a>
<a name="ln610">{</a>
<a name="ln611">	// in case there were errors getting some columns</a>
<a name="ln612">	if (fColumnList-&gt;CountItems() != 0)</a>
<a name="ln613">		return;</a>
<a name="ln614"> </a>
<a name="ln615">	fColumnList-&gt;AddItem(new BColumn(B_TRANSLATE(&quot;Name&quot;), StartOffset(), 145,</a>
<a name="ln616">		B_ALIGN_LEFT, kAttrStatName, B_STRING_TYPE, true, true));</a>
<a name="ln617">	fColumnList-&gt;AddItem(new BColumn(B_TRANSLATE(&quot;Size&quot;), 200, 80,</a>
<a name="ln618">		B_ALIGN_RIGHT, kAttrStatSize, B_OFF_T_TYPE, true, false));</a>
<a name="ln619">	fColumnList-&gt;AddItem(new BColumn(B_TRANSLATE(&quot;Modified&quot;), 295, 150,</a>
<a name="ln620">		B_ALIGN_LEFT, kAttrStatModified, B_TIME_TYPE, true, false));</a>
<a name="ln621"> </a>
<a name="ln622">	if (!IsWatchingDateFormatChange())</a>
<a name="ln623">		StartWatchDateFormatChange();</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626"> </a>
<a name="ln627">const char*</a>
<a name="ln628">BPoseView::ViewStateAttributeName() const</a>
<a name="ln629">{</a>
<a name="ln630">	return IsDesktopView() ? kAttrDesktopViewState : kAttrViewState;</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633"> </a>
<a name="ln634">const char*</a>
<a name="ln635">BPoseView::ForeignViewStateAttributeName() const</a>
<a name="ln636">{</a>
<a name="ln637">	return IsDesktopView() ? kAttrDesktopViewStateForeign</a>
<a name="ln638">		: kAttrViewStateForeign;</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641"> </a>
<a name="ln642">void</a>
<a name="ln643">BPoseView::SaveColumnState(AttributeStreamNode* node)</a>
<a name="ln644">{</a>
<a name="ln645">	BMallocIO stream;</a>
<a name="ln646">	for (int32 index = 0; ; index++) {</a>
<a name="ln647">		const BColumn* column = ColumnAt(index);</a>
<a name="ln648">		if (column == NULL)</a>
<a name="ln649">			break;</a>
<a name="ln650">		column-&gt;ArchiveToStream(&amp;stream);</a>
<a name="ln651">	}</a>
<a name="ln652"> </a>
<a name="ln653">	const char* columnsAttr;</a>
<a name="ln654">	const char* columnsAttrForeign;</a>
<a name="ln655">	if (TargetModel() &amp;&amp; TargetModel()-&gt;IsRoot()) {</a>
<a name="ln656">		columnsAttr = kAttrDisksColumns;</a>
<a name="ln657">		columnsAttrForeign = kAttrDisksColumnsForeign;</a>
<a name="ln658">	} else {</a>
<a name="ln659">		columnsAttr = kAttrColumns;</a>
<a name="ln660">		columnsAttrForeign = kAttrColumnsForeign;</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	node-&gt;Write(columnsAttr, columnsAttrForeign, B_RAW_TYPE,</a>
<a name="ln664">		stream.Position(), stream.Buffer());</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667"> </a>
<a name="ln668">void</a>
<a name="ln669">BPoseView::SaveColumnState(BMessage&amp; message) const</a>
<a name="ln670">{</a>
<a name="ln671">	for (int32 index = 0; ; index++) {</a>
<a name="ln672">		const BColumn* column = ColumnAt(index);</a>
<a name="ln673">		if (column == NULL)</a>
<a name="ln674">			break;</a>
<a name="ln675"> </a>
<a name="ln676">		column-&gt;ArchiveToMessage(message);</a>
<a name="ln677">	}</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680"> </a>
<a name="ln681">void</a>
<a name="ln682">BPoseView::SaveState(AttributeStreamNode* node)</a>
<a name="ln683">{</a>
<a name="ln684">	SaveColumnState(node);</a>
<a name="ln685"> </a>
<a name="ln686">	// save view state into object</a>
<a name="ln687">	BMallocIO stream;</a>
<a name="ln688"> </a>
<a name="ln689">	stream.Seek(0, SEEK_SET);</a>
<a name="ln690">	fViewState-&gt;ArchiveToStream(&amp;stream);</a>
<a name="ln691"> </a>
<a name="ln692">	const char* viewStateAttr;</a>
<a name="ln693">	const char* viewStateAttrForeign;</a>
<a name="ln694">	if (TargetModel() != NULL &amp;&amp; TargetModel()-&gt;IsRoot()) {</a>
<a name="ln695">		viewStateAttr = kAttrDisksViewState;</a>
<a name="ln696">		viewStateAttrForeign = kAttrDisksViewStateForeign;</a>
<a name="ln697">	} else {</a>
<a name="ln698">		viewStateAttr = ViewStateAttributeName();</a>
<a name="ln699">		viewStateAttrForeign = ForeignViewStateAttributeName();</a>
<a name="ln700">	}</a>
<a name="ln701"> </a>
<a name="ln702">	node-&gt;Write(viewStateAttr, viewStateAttrForeign, B_RAW_TYPE,</a>
<a name="ln703">		stream.Position(), stream.Buffer());</a>
<a name="ln704"> </a>
<a name="ln705">	fStateNeedsSaving = false;</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">void</a>
<a name="ln710">BPoseView::SaveState(BMessage&amp; message) const</a>
<a name="ln711">{</a>
<a name="ln712">	SaveColumnState(message);</a>
<a name="ln713">	fViewState-&gt;ArchiveToMessage(message);</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">float</a>
<a name="ln718">BPoseView::StringWidth(const char* str) const</a>
<a name="ln719">{</a>
<a name="ln720">	return BPrivate::gWidthBuffer-&gt;StringWidth(str, 0, (int32)strlen(str),</a>
<a name="ln721">		&amp;sCurrentFont);</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724"> </a>
<a name="ln725">float</a>
<a name="ln726">BPoseView::StringWidth(const char* str, int32 len) const</a>
<a name="ln727">{</a>
<a name="ln728">	ASSERT(strlen(str) == (uint32)len);</a>
<a name="ln729"> </a>
<a name="ln730">	return BPrivate::gWidthBuffer-&gt;StringWidth(str, 0, len, &amp;sCurrentFont);</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733"> </a>
<a name="ln734">void</a>
<a name="ln735">BPoseView::SavePoseLocations(BRect* frameIfDesktop)</a>
<a name="ln736">{</a>
<a name="ln737">	PoseInfo poseInfo;</a>
<a name="ln738"> </a>
<a name="ln739">	if (!fSavePoseLocations)</a>
<a name="ln740">		return;</a>
<a name="ln741"> </a>
<a name="ln742">	ASSERT(Window()-&gt;IsLocked());</a>
<a name="ln743"> </a>
<a name="ln744">	Model* targetModel = TargetModel();</a>
<a name="ln745">	ThrowOnAssert(targetModel != NULL);</a>
<a name="ln746"> </a>
<a name="ln747">	BVolume volume(TargetModel()-&gt;NodeRef()-&gt;device);</a>
<a name="ln748">	if (volume.InitCheck() != B_OK)</a>
<a name="ln749">		return;</a>
<a name="ln750"> </a>
<a name="ln751">	if (!targetModel-&gt;IsRoot()</a>
<a name="ln752">		&amp;&amp; (volume.IsReadOnly() || !volume.KnowsAttr())) {</a>
<a name="ln753">		// check that we can write out attrs; Root should always work</a>
<a name="ln754">		// because it gets saved on the boot disk but the above checks</a>
<a name="ln755">		// will fail</a>
<a name="ln756">		return;</a>
<a name="ln757">	}</a>
<a name="ln758"> </a>
<a name="ln759">	bool isDesktop = IsDesktopWindow() &amp;&amp; (frameIfDesktop != NULL);</a>
<a name="ln760"> </a>
<a name="ln761">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln762">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln763">		BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln764">		if (pose-&gt;NeedsSaveLocation() &amp;&amp; pose-&gt;HasLocation()) {</a>
<a name="ln765">			Model* model = pose-&gt;TargetModel();</a>
<a name="ln766">			poseInfo.fInvisible = false;</a>
<a name="ln767"> </a>
<a name="ln768">			if (model-&gt;IsRoot())</a>
<a name="ln769">				poseInfo.fInitedDirectory = targetModel-&gt;NodeRef()-&gt;node;</a>
<a name="ln770">			else</a>
<a name="ln771">				poseInfo.fInitedDirectory = model-&gt;EntryRef()-&gt;directory;</a>
<a name="ln772"> </a>
<a name="ln773">			poseInfo.fLocation = pose-&gt;Location(this);</a>
<a name="ln774"> </a>
<a name="ln775">			ExtendedPoseInfo* extendedPoseInfo = NULL;</a>
<a name="ln776">			size_t extendedPoseInfoSize = 0;</a>
<a name="ln777">			ModelNodeLazyOpener opener(model, true);</a>
<a name="ln778"> </a>
<a name="ln779">			if (isDesktop) {</a>
<a name="ln780">				opener.OpenNode(true);</a>
<a name="ln781">				// if saving desktop icons, save an extended pose info too</a>
<a name="ln782">				extendedPoseInfo = ReadExtendedPoseInfo(model);</a>
<a name="ln783">					// read the pre-existing one</a>
<a name="ln784"> </a>
<a name="ln785">				if (!extendedPoseInfo) {</a>
<a name="ln786">					// don't have one yet, allocate one</a>
<a name="ln787">					size_t size = ExtendedPoseInfo::Size(1);</a>
<a name="ln788">					extendedPoseInfo = (ExtendedPoseInfo*)</a>
<a name="ln789">						new char [size];</a>
<a name="ln790"> </a>
<a name="ln791">					memset((void*)extendedPoseInfo, 0, size);</a>
<a name="ln792">					extendedPoseInfo-&gt;fWorkspaces = 0xffffffff;</a>
<a name="ln793">					extendedPoseInfo-&gt;fInvisible = false;</a>
<a name="ln794">					extendedPoseInfo-&gt;fShowFromBootOnly = false;</a>
<a name="ln795">					extendedPoseInfo-&gt;fNumFrames = 0;</a>
<a name="ln796">				}</a>
<a name="ln797">				ASSERT(extendedPoseInfo);</a>
<a name="ln798"> </a>
<a name="ln799">				extendedPoseInfo-&gt;SetLocationForFrame(pose-&gt;Location(this),</a>
<a name="ln800">					*frameIfDesktop);</a>
<a name="ln801">				extendedPoseInfoSize = extendedPoseInfo-&gt;Size();</a>
<a name="ln802">			}</a>
<a name="ln803"> </a>
<a name="ln804">			if (model-&gt;InitCheck() != B_OK) {</a>
<a name="ln805">				delete[] (char*)extendedPoseInfo;</a>
<a name="ln806">				continue;</a>
<a name="ln807">			}</a>
<a name="ln808"> </a>
<a name="ln809">			ASSERT(model);</a>
<a name="ln810">			ASSERT(model-&gt;InitCheck() == B_OK);</a>
<a name="ln811">			// special handling for &quot;root&quot; disks icon</a>
<a name="ln812">			// and Trash pose on Desktop directory</a>
<a name="ln813">			bool isTrash = model-&gt;IsTrash() &amp;&amp; IsDesktopView();</a>
<a name="ln814">			if (model-&gt;IsRoot() || isTrash) {</a>
<a name="ln815">				BDirectory deskDir;</a>
<a name="ln816">				if (FSGetDeskDir(&amp;deskDir) == B_OK) {</a>
<a name="ln817">					const char* poseInfoAttr = isTrash ? kAttrTrashPoseInfo</a>
<a name="ln818">						: kAttrDisksPoseInfo;</a>
<a name="ln819">					const char* poseInfoAttrForeign = isTrash</a>
<a name="ln820">						? kAttrTrashPoseInfoForeign</a>
<a name="ln821">						: kAttrDisksPoseInfoForeign;</a>
<a name="ln822">					if (deskDir.WriteAttr(poseInfoAttr, B_RAW_TYPE, 0,</a>
<a name="ln823">						&amp;poseInfo, sizeof(poseInfo)) == sizeof(poseInfo)) {</a>
<a name="ln824">						// nuke opposite endianness</a>
<a name="ln825">						deskDir.RemoveAttr(poseInfoAttrForeign);</a>
<a name="ln826">					}</a>
<a name="ln827"> </a>
<a name="ln828">					if (!isTrash &amp;&amp; isDesktop</a>
<a name="ln829">						&amp;&amp; deskDir.WriteAttr(kAttrExtendedDisksPoseInfo,</a>
<a name="ln830">						B_RAW_TYPE, 0, extendedPoseInfo, extendedPoseInfoSize)</a>
<a name="ln831">							== (ssize_t)extendedPoseInfoSize) {</a>
<a name="ln832">						// nuke opposite endianness</a>
<a name="ln833">						deskDir.RemoveAttr(kAttrExtendedDisksPoseInfoForegin);</a>
<a name="ln834">					}</a>
<a name="ln835">				}</a>
<a name="ln836">			} else {</a>
<a name="ln837">				model-&gt;WriteAttrKillForeign(kAttrPoseInfo,</a>
<a name="ln838">					kAttrPoseInfoForeign, B_RAW_TYPE, 0, &amp;poseInfo,</a>
<a name="ln839">					sizeof(poseInfo));</a>
<a name="ln840"> </a>
<a name="ln841">				if (isDesktop) {</a>
<a name="ln842">					model-&gt;WriteAttrKillForeign(kAttrExtendedPoseInfo,</a>
<a name="ln843">						kAttrExtendedPoseInfoForegin,</a>
<a name="ln844">						B_RAW_TYPE, 0, extendedPoseInfo,</a>
<a name="ln845">						extendedPoseInfoSize);</a>
<a name="ln846">				}</a>
<a name="ln847">			}</a>
<a name="ln848"> </a>
<a name="ln849">			delete[] (char*)extendedPoseInfo;</a>
<a name="ln850">				// TODO: fix up this mess</a>
<a name="ln851">		}</a>
<a name="ln852">	}</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855"> </a>
<a name="ln856">void</a>
<a name="ln857">BPoseView::StartWatching()</a>
<a name="ln858">{</a>
<a name="ln859">	// watch volumes</a>
<a name="ln860">	TTracker::WatchNode(NULL, B_WATCH_MOUNT, this);</a>
<a name="ln861"> </a>
<a name="ln862">	Model* targetModel = TargetModel();</a>
<a name="ln863">	if (targetModel != NULL)</a>
<a name="ln864">		TTracker::WatchNode(targetModel-&gt;NodeRef(), B_WATCH_ATTR, this);</a>
<a name="ln865"> </a>
<a name="ln866">	BMimeType::StartWatching(BMessenger(this));</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869"> </a>
<a name="ln870">void</a>
<a name="ln871">BPoseView::StopWatching()</a>
<a name="ln872">{</a>
<a name="ln873">	stop_watching(this);</a>
<a name="ln874">	BMimeType::StopWatching(BMessenger(this));</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877"> </a>
<a name="ln878">void</a>
<a name="ln879">BPoseView::DetachedFromWindow()</a>
<a name="ln880">{</a>
<a name="ln881">	if (fTitleView &amp;&amp; !fTitleView-&gt;Window())</a>
<a name="ln882">		delete fTitleView;</a>
<a name="ln883"> </a>
<a name="ln884">	TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln885">	if (tracker != NULL &amp;&amp; tracker-&gt;Lock()) {</a>
<a name="ln886">		tracker-&gt;StopWatching(this, kShowSelectionWhenInactiveChanged);</a>
<a name="ln887">		tracker-&gt;StopWatching(this, kTransparentSelectionChanged);</a>
<a name="ln888">		tracker-&gt;StopWatching(this, kSortFolderNamesFirstChanged);</a>
<a name="ln889">		tracker-&gt;StopWatching(this, kHideDotFilesChanged);</a>
<a name="ln890">		tracker-&gt;StopWatching(this, kTypeAheadFilteringChanged);</a>
<a name="ln891">		tracker-&gt;Unlock();</a>
<a name="ln892">	}</a>
<a name="ln893"> </a>
<a name="ln894">	std::set&lt;thread_id&gt; addPosesThreads(fAddPosesThreads);</a>
<a name="ln895">	fAddPosesThreads.clear();</a>
<a name="ln896">		// The threads check periodically if they are still valid,</a>
<a name="ln897">		// and clearing the list makes them all &quot;invalid.&quot;</a>
<a name="ln898">	std::set&lt;thread_id&gt;::iterator it;</a>
<a name="ln899">	for (it = addPosesThreads.begin(); it != addPosesThreads.end(); it++) {</a>
<a name="ln900">		UnlockLooper();</a>
<a name="ln901">		wait_for_thread(*it, NULL);</a>
<a name="ln902">		LockLooper();</a>
<a name="ln903">	}</a>
<a name="ln904"> </a>
<a name="ln905">	StopWatching();</a>
<a name="ln906">	CommitActivePose();</a>
<a name="ln907">	SavePoseLocations();</a>
<a name="ln908"> </a>
<a name="ln909">	FSClipboardStopWatch(this);</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912"> </a>
<a name="ln913">void</a>
<a name="ln914">BPoseView::Pulse()</a>
<a name="ln915">{</a>
<a name="ln916">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln917">	if (window == NULL)</a>
<a name="ln918">		return;</a>
<a name="ln919"> </a>
<a name="ln920">	window-&gt;PulseTaskLoop();</a>
<a name="ln921">		// make sure task loop gets pulsed properly, if installed</a>
<a name="ln922"> </a>
<a name="ln923">	// update item count view in window if necessary</a>
<a name="ln924">	UpdateCount();</a>
<a name="ln925"> </a>
<a name="ln926">	if (fAutoScrollState != kAutoScrollOff)</a>
<a name="ln927">		HandleAutoScroll();</a>
<a name="ln928"> </a>
<a name="ln929">	// do we need to update scrollbars?</a>
<a name="ln930">	BRect extent = Extent();</a>
<a name="ln931">	if ((fLastExtent != extent) || (fLastLeftTop != LeftTop())) {</a>
<a name="ln932">		uint32 buttons;</a>
<a name="ln933">		BPoint mouse;</a>
<a name="ln934">		GetMouse(&amp;mouse, &amp;buttons);</a>
<a name="ln935">		if (buttons == 0) {</a>
<a name="ln936">			UpdateScrollRange();</a>
<a name="ln937">			fLastExtent = extent;</a>
<a name="ln938">			fLastLeftTop = LeftTop();</a>
<a name="ln939">		}</a>
<a name="ln940">	}</a>
<a name="ln941"> </a>
<a name="ln942">	// do we have a TextWidget waiting for expiracy of its double-click</a>
<a name="ln943">	// check?</a>
<a name="ln944">	if (fTextWidgetToCheck != NULL)</a>
<a name="ln945">		fTextWidgetToCheck-&gt;CheckExpiration();</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948"> </a>
<a name="ln949">void</a>
<a name="ln950">BPoseView::ScrollTo(BPoint where)</a>
<a name="ln951">{</a>
<a name="ln952">	_inherited::ScrollTo(where);</a>
<a name="ln953"> </a>
<a name="ln954">	// keep the view state in sync</a>
<a name="ln955">	if (ViewMode() == kListMode)</a>
<a name="ln956">		fViewState-&gt;SetListOrigin(LeftTop());</a>
<a name="ln957">	else</a>
<a name="ln958">		fViewState-&gt;SetIconOrigin(LeftTop());</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961"> </a>
<a name="ln962">void</a>
<a name="ln963">BPoseView::AttachedToWindow()</a>
<a name="ln964">{</a>
<a name="ln965">	fIsDesktopWindow = dynamic_cast&lt;BDeskWindow*&gt;(Window()) != NULL;</a>
<a name="ln966">	if (fIsDesktopWindow)</a>
<a name="ln967">		AddFilter(new TPoseViewFilter(this));</a>
<a name="ln968">	else {</a>
<a name="ln969">		SetViewUIColor(B_DOCUMENT_BACKGROUND_COLOR);</a>
<a name="ln970">		SetLowUIColor(ViewUIColor());</a>
<a name="ln971">	}</a>
<a name="ln972"> </a>
<a name="ln973">	AddFilter(new ShortcutFilter(B_RETURN, B_OPTION_KEY, kOpenSelection,</a>
<a name="ln974">		this));</a>
<a name="ln975">		// add Option-Return as a shortcut filter because AddShortcut</a>
<a name="ln976">		// doesn't allow us to have shortcuts without Command yet</a>
<a name="ln977">	AddFilter(new ShortcutFilter(B_ESCAPE, 0, B_CANCEL, this));</a>
<a name="ln978">		// Escape key, used to abort an on-going clipboard cut or filtering</a>
<a name="ln979">	AddFilter(new ShortcutFilter(B_ESCAPE, B_SHIFT_KEY,</a>
<a name="ln980">		kCancelSelectionToClipboard, this));</a>
<a name="ln981">		// Escape + SHIFT will remove current selection from clipboard,</a>
<a name="ln982">		// or all poses from current folder if 0 selected</a>
<a name="ln983"> </a>
<a name="ln984">	AddFilter(new LongAndDragTrackingFilter(kMsgMouseLongDown,</a>
<a name="ln985">		kMsgMouseDragged));</a>
<a name="ln986"> </a>
<a name="ln987">	fLastLeftTop = LeftTop();</a>
<a name="ln988">	BFont font(be_plain_font);</a>
<a name="ln989">	font.SetSpacing(B_BITMAP_SPACING);</a>
<a name="ln990">	SetFont(&amp;font);</a>
<a name="ln991">	GetFont(&amp;sCurrentFont);</a>
<a name="ln992"> </a>
<a name="ln993">	// static - init just once</a>
<a name="ln994">	if (sFontHeight == -1) {</a>
<a name="ln995">		font.GetHeight(&amp;sFontInfo);</a>
<a name="ln996">		sFontHeight = sFontInfo.ascent + sFontInfo.descent</a>
<a name="ln997">			+ sFontInfo.leading;</a>
<a name="ln998">	}</a>
<a name="ln999"> </a>
<a name="ln1000">	TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln1001">	if (tracker != NULL &amp;&amp; tracker-&gt;Lock()) {</a>
<a name="ln1002">		tracker-&gt;StartWatching(this, kShowSelectionWhenInactiveChanged);</a>
<a name="ln1003">		tracker-&gt;StartWatching(this, kTransparentSelectionChanged);</a>
<a name="ln1004">		tracker-&gt;StartWatching(this, kSortFolderNamesFirstChanged);</a>
<a name="ln1005">		tracker-&gt;StartWatching(this, kHideDotFilesChanged);</a>
<a name="ln1006">		tracker-&gt;StartWatching(this, kTypeAheadFilteringChanged);</a>
<a name="ln1007">		tracker-&gt;Unlock();</a>
<a name="ln1008">	}</a>
<a name="ln1009"> </a>
<a name="ln1010">	FSClipboardStartWatch(this);</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013"> </a>
<a name="ln1014">void</a>
<a name="ln1015">BPoseView::SetIconPoseHeight()</a>
<a name="ln1016">{</a>
<a name="ln1017">	switch (ViewMode()) {</a>
<a name="ln1018">		case kIconMode:</a>
<a name="ln1019">			// IconSize should already be set in MessageReceived()</a>
<a name="ln1020">			fIconPoseHeight = ceilf(IconSizeInt() + sFontHeight + 1);</a>
<a name="ln1021">			break;</a>
<a name="ln1022"> </a>
<a name="ln1023">		case kMiniIconMode:</a>
<a name="ln1024">			fViewState-&gt;SetIconSize(B_MINI_ICON);</a>
<a name="ln1025">			fIconPoseHeight = ceilf(sFontHeight &lt;</a>
<a name="ln1026">				IconSizeInt() ? IconSizeInt() : sFontHeight + 1);</a>
<a name="ln1027">			break;</a>
<a name="ln1028"> </a>
<a name="ln1029">		case kListMode:</a>
<a name="ln1030">		default:</a>
<a name="ln1031">		{</a>
<a name="ln1032">			fViewState-&gt;SetIconSize(ListIconSize());</a>
<a name="ln1033">			fIconPoseHeight = fListElemHeight;</a>
<a name="ln1034">			break;</a>
<a name="ln1035">		}</a>
<a name="ln1036">	}</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">void</a>
<a name="ln1041">BPoseView::GetLayoutInfo(uint32 mode, BPoint* grid, BPoint* offset) const</a>
<a name="ln1042">{</a>
<a name="ln1043">	switch (mode) {</a>
<a name="ln1044">		case kMiniIconMode:</a>
<a name="ln1045">			grid-&gt;Set(96, 20);</a>
<a name="ln1046">			offset-&gt;Set(10, 5);</a>
<a name="ln1047">			break;</a>
<a name="ln1048"> </a>
<a name="ln1049">		case kIconMode:</a>
<a name="ln1050">			grid-&gt;Set(IconSizeInt() + 28, IconSizeInt() + 28);</a>
<a name="ln1051">			offset-&gt;Set(20, 20);</a>
<a name="ln1052">			break;</a>
<a name="ln1053"> </a>
<a name="ln1054">		default:</a>
<a name="ln1055">			grid-&gt;Set(0, 0);</a>
<a name="ln1056">			offset-&gt;Set(5, 5);</a>
<a name="ln1057">			break;</a>
<a name="ln1058">	}</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061"> </a>
<a name="ln1062">void</a>
<a name="ln1063">BPoseView::ScrollView(int32 type)</a>
<a name="ln1064">{</a>
<a name="ln1065">	if (fVScrollBar == NULL)</a>
<a name="ln1066">		return;</a>
<a name="ln1067"> </a>
<a name="ln1068">	float max, min;</a>
<a name="ln1069">	fVScrollBar-&gt;GetSteps(&amp;min, &amp;max);</a>
<a name="ln1070"> </a>
<a name="ln1071">	switch (type) {</a>
<a name="ln1072">		case B_HOME:</a>
<a name="ln1073">			fVScrollBar-&gt;SetValue(0);</a>
<a name="ln1074">			break;</a>
<a name="ln1075">		case B_END:</a>
<a name="ln1076">			fVScrollBar-&gt;SetValue(max);</a>
<a name="ln1077">			break;</a>
<a name="ln1078">		case B_PAGE_UP:</a>
<a name="ln1079">			fVScrollBar-&gt;SetValue(fVScrollBar-&gt;Value() - max);</a>
<a name="ln1080">			break;</a>
<a name="ln1081">		case B_PAGE_DOWN:</a>
<a name="ln1082">			fVScrollBar-&gt;SetValue(fVScrollBar-&gt;Value() + max);</a>
<a name="ln1083">			break;</a>
<a name="ln1084">	}</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087"> </a>
<a name="ln1088">void</a>
<a name="ln1089">BPoseView::MakeFocus(bool focused)</a>
<a name="ln1090">{</a>
<a name="ln1091">	bool invalidate = false;</a>
<a name="ln1092">	if (focused != IsFocus())</a>
<a name="ln1093">		invalidate = true;</a>
<a name="ln1094"> </a>
<a name="ln1095">	_inherited::MakeFocus(focused);</a>
<a name="ln1096"> </a>
<a name="ln1097">	if (invalidate) {</a>
<a name="ln1098">		BorderedView* view = dynamic_cast&lt;BorderedView*&gt;(Parent());</a>
<a name="ln1099">		if (view != NULL)</a>
<a name="ln1100">			view-&gt;PoseViewFocused(focused);</a>
<a name="ln1101">	}</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104"> </a>
<a name="ln1105">BSize</a>
<a name="ln1106">BPoseView::MinSize()</a>
<a name="ln1107">{</a>
<a name="ln1108">	// Between the BTitleView, BCountView, and scrollbars,</a>
<a name="ln1109">	// we don't need any extra room.</a>
<a name="ln1110">	return BSize(0, 0);</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113"> </a>
<a name="ln1114">void</a>
<a name="ln1115">BPoseView::WindowActivated(bool active)</a>
<a name="ln1116">{</a>
<a name="ln1117">	if (!active)</a>
<a name="ln1118">		CommitActivePose();</a>
<a name="ln1119"> </a>
<a name="ln1120">	if (fShowHideSelection)</a>
<a name="ln1121">		ShowSelection(active);</a>
<a name="ln1122"> </a>
<a name="ln1123">	if (active &amp;&amp; ActivePose() == NULL &amp;&amp; !IsFilePanel())</a>
<a name="ln1124">		MakeFocus();</a>
<a name="ln1125">}</a>
<a name="ln1126"> </a>
<a name="ln1127"> </a>
<a name="ln1128">void</a>
<a name="ln1129">BPoseView::SetActivePose(BPose* pose)</a>
<a name="ln1130">{</a>
<a name="ln1131">	if (pose != ActivePose()) {</a>
<a name="ln1132">		CommitActivePose();</a>
<a name="ln1133">		fActivePose = pose;</a>
<a name="ln1134">	}</a>
<a name="ln1135">}</a>
<a name="ln1136"> </a>
<a name="ln1137"> </a>
<a name="ln1138">void</a>
<a name="ln1139">BPoseView::CommitActivePose(bool saveChanges)</a>
<a name="ln1140">{</a>
<a name="ln1141">	BPose* activePose = ActivePose();</a>
<a name="ln1142">	if (activePose != NULL) {</a>
<a name="ln1143">		int32 index = fPoseList-&gt;IndexOf(ActivePose());</a>
<a name="ln1144">		if (fFiltering)</a>
<a name="ln1145">			index = fFilteredPoseList-&gt;IndexOf(ActivePose());</a>
<a name="ln1146"> </a>
<a name="ln1147">		BPoint loc(0, index * fListElemHeight);</a>
<a name="ln1148">		if (ViewMode() != kListMode)</a>
<a name="ln1149">			loc = ActivePose()-&gt;Location(this);</a>
<a name="ln1150"> </a>
<a name="ln1151">		activePose-&gt;Commit(saveChanges, loc, this, index);</a>
<a name="ln1152">		BPose* pose = fActivePose;</a>
<a name="ln1153">		fActivePose = NULL;</a>
<a name="ln1154">		if (fFiltering &amp;&amp; !FilterPose(pose))</a>
<a name="ln1155">			RemoveFilteredPose(pose, index);</a>
<a name="ln1156">	}</a>
<a name="ln1157">}</a>
<a name="ln1158"> </a>
<a name="ln1159"> </a>
<a name="ln1160">EntryListBase*</a>
<a name="ln1161">BPoseView::InitDirentIterator(const entry_ref* ref)</a>
<a name="ln1162">{</a>
<a name="ln1163">	// set up a directory iteration</a>
<a name="ln1164">	Model sourceModel(ref, false, true);</a>
<a name="ln1165">	if (sourceModel.InitCheck() != B_OK)</a>
<a name="ln1166">		return NULL;</a>
<a name="ln1167"> </a>
<a name="ln1168">	ASSERT(!sourceModel.IsQuery());</a>
<a name="ln1169">	ASSERT(!sourceModel.IsVirtualDirectory());</a>
<a name="ln1170">	ASSERT(sourceModel.Node() != NULL);</a>
<a name="ln1171"> </a>
<a name="ln1172">	BDirectory* directory = dynamic_cast&lt;BDirectory*&gt;(sourceModel.Node());</a>
<a name="ln1173"> </a>
<a name="ln1174">	ASSERT(directory != NULL);</a>
<a name="ln1175"> </a>
<a name="ln1176">	if (directory == NULL) {</a>
<a name="ln1177">		HideBarberPole();</a>
<a name="ln1178">		return NULL;</a>
<a name="ln1179">	}</a>
<a name="ln1180"> </a>
<a name="ln1181">	EntryListBase* entryList = new CachedDirectoryEntryList(*directory);</a>
<a name="ln1182">	if (entryList-&gt;Rewind() != B_OK) {</a>
<a name="ln1183">		delete entryList;</a>
<a name="ln1184">		HideBarberPole();</a>
<a name="ln1185">		return NULL;</a>
<a name="ln1186">	}</a>
<a name="ln1187"> </a>
<a name="ln1188">	TTracker::WatchNode(sourceModel.NodeRef(), B_WATCH_DIRECTORY</a>
<a name="ln1189">		| B_WATCH_NAME | B_WATCH_STAT | B_WATCH_ATTR, this);</a>
<a name="ln1190"> </a>
<a name="ln1191">	return entryList;</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194"> </a>
<a name="ln1195">void</a>
<a name="ln1196">BPoseView::ReturnDirentIterator(EntryListBase* iterator)</a>
<a name="ln1197">{</a>
<a name="ln1198">	delete iterator;</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201"> </a>
<a name="ln1202">uint32</a>
<a name="ln1203">BPoseView::WatchNewNodeMask()</a>
<a name="ln1204">{</a>
<a name="ln1205">	return B_WATCH_STAT | B_WATCH_INTERIM_STAT | B_WATCH_ATTR;</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208"> </a>
<a name="ln1209">status_t</a>
<a name="ln1210">BPoseView::WatchNewNode(const node_ref* item)</a>
<a name="ln1211">{</a>
<a name="ln1212">	return WatchNewNode(item, WatchNewNodeMask(), BMessenger(this));</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215"> </a>
<a name="ln1216">status_t</a>
<a name="ln1217">BPoseView::WatchNewNode(const node_ref* item, uint32 mask, BMessenger messenger)</a>
<a name="ln1218">{</a>
<a name="ln1219">	status_t result = TTracker::WatchNode(item, mask, messenger);</a>
<a name="ln1220"> </a>
<a name="ln1221">#if DEBUG</a>
<a name="ln1222">	if (result != B_OK)</a>
<a name="ln1223">		PRINT((&quot;failed to watch node %s\n&quot;, strerror(result)));</a>
<a name="ln1224">#endif</a>
<a name="ln1225"> </a>
<a name="ln1226">	return result;</a>
<a name="ln1227">}</a>
<a name="ln1228"> </a>
<a name="ln1229"> </a>
<a name="ln1230">struct AddPosesParams {</a>
<a name="ln1231">	BMessenger target;</a>
<a name="ln1232">	entry_ref ref;</a>
<a name="ln1233">};</a>
<a name="ln1234"> </a>
<a name="ln1235"> </a>
<a name="ln1236">bool</a>
<a name="ln1237">BPoseView::IsValidAddPosesThread(thread_id currentThread) const</a>
<a name="ln1238">{</a>
<a name="ln1239">	return fAddPosesThreads.find(currentThread) != fAddPosesThreads.end();</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242"> </a>
<a name="ln1243">void</a>
<a name="ln1244">BPoseView::AddPoses(Model* model)</a>
<a name="ln1245">{</a>
<a name="ln1246">	// if model is zero, PoseView has other means of iterating through all</a>
<a name="ln1247">	// the entries that it adds</a>
<a name="ln1248">	if (model != NULL) {</a>
<a name="ln1249">		TrackerSettings settings;</a>
<a name="ln1250">		if (model-&gt;IsRoot()) {</a>
<a name="ln1251">			AddRootPoses(true, settings.MountSharedVolumesOntoDesktop());</a>
<a name="ln1252">			return;</a>
<a name="ln1253">		} else if (IsDesktopView()</a>
<a name="ln1254">			&amp;&amp; (settings.MountVolumesOntoDesktop() || settings.ShowDisksIcon()</a>
<a name="ln1255">				|| (IsFilePanel() &amp;&amp; settings.DesktopFilePanelRoot())))</a>
<a name="ln1256">			AddRootPoses(true, settings.MountSharedVolumesOntoDesktop());</a>
<a name="ln1257">	}</a>
<a name="ln1258"> </a>
<a name="ln1259">	ShowBarberPole();</a>
<a name="ln1260"> </a>
<a name="ln1261">	AddPosesParams* params = new AddPosesParams();</a>
<a name="ln1262">	BMessenger tmp(this);</a>
<a name="ln1263">	params-&gt;target = tmp;</a>
<a name="ln1264"> </a>
<a name="ln1265">	if (model != NULL)</a>
<a name="ln1266">		params-&gt;ref = *model-&gt;EntryRef();</a>
<a name="ln1267"> </a>
<a name="ln1268">	thread_id addPosesThread = spawn_thread(&amp;BPoseView::AddPosesTask,</a>
<a name="ln1269">		&quot;add poses&quot;, B_DISPLAY_PRIORITY, params);</a>
<a name="ln1270"> </a>
<a name="ln1271">	if (addPosesThread &gt;= B_OK) {</a>
<a name="ln1272">		fAddPosesThreads.insert(addPosesThread);</a>
<a name="ln1273">		resume_thread(addPosesThread);</a>
<a name="ln1274">	} else</a>
<a name="ln1275">		delete params;</a>
<a name="ln1276">}</a>
<a name="ln1277"> </a>
<a name="ln1278"> </a>
<a name="ln1279">class AutoLockingMessenger {</a>
<a name="ln1280">	// Note:</a>
<a name="ln1281">	// this locker requires that you lock/unlock the messenger and associated</a>
<a name="ln1282">	// looper only through the autolocker interface, otherwise the hasLock</a>
<a name="ln1283">	// flag gets out of sync</a>
<a name="ln1284">	//</a>
<a name="ln1285">	// Also, this class represents the entire BMessenger, not just it's</a>
<a name="ln1286">	// autolocker (unlike MessengerAutoLocker)</a>
<a name="ln1287">	public:</a>
<a name="ln1288">		AutoLockingMessenger(const BMessenger &amp;target, bool lockLater = false)</a>
<a name="ln1289">			:</a>
<a name="ln1290">			messenger(target),</a>
<a name="ln1291">			hasLock(false)</a>
<a name="ln1292">		{</a>
<a name="ln1293">			if (!lockLater)</a>
<a name="ln1294">				hasLock = messenger.LockTarget();</a>
<a name="ln1295">		}</a>
<a name="ln1296"> </a>
<a name="ln1297">		~AutoLockingMessenger()</a>
<a name="ln1298">		{</a>
<a name="ln1299">			if (hasLock) {</a>
<a name="ln1300">				BLooper* looper;</a>
<a name="ln1301">				messenger.Target(&amp;looper);</a>
<a name="ln1302">				ASSERT(looper-&gt;IsLocked());</a>
<a name="ln1303">				looper-&gt;Unlock();</a>
<a name="ln1304">			}</a>
<a name="ln1305">		}</a>
<a name="ln1306"> </a>
<a name="ln1307">		bool Lock()</a>
<a name="ln1308">		{</a>
<a name="ln1309">			if (!hasLock)</a>
<a name="ln1310">				hasLock = messenger.LockTarget();</a>
<a name="ln1311"> </a>
<a name="ln1312">			return hasLock;</a>
<a name="ln1313">		}</a>
<a name="ln1314"> </a>
<a name="ln1315">		bool IsLocked() const</a>
<a name="ln1316">		{</a>
<a name="ln1317">			return hasLock;</a>
<a name="ln1318">		}</a>
<a name="ln1319"> </a>
<a name="ln1320">		void Unlock()</a>
<a name="ln1321">		{</a>
<a name="ln1322">			if (hasLock) {</a>
<a name="ln1323">				BLooper* looper;</a>
<a name="ln1324">				messenger.Target(&amp;looper);</a>
<a name="ln1325">				ASSERT(looper);</a>
<a name="ln1326">				looper-&gt;Unlock();</a>
<a name="ln1327">				hasLock = false;</a>
<a name="ln1328">			}</a>
<a name="ln1329">		}</a>
<a name="ln1330"> </a>
<a name="ln1331">		BLooper* Looper() const</a>
<a name="ln1332">		{</a>
<a name="ln1333">			BLooper* looper;</a>
<a name="ln1334">			messenger.Target(&amp;looper);</a>
<a name="ln1335">			return looper;</a>
<a name="ln1336">		}</a>
<a name="ln1337"> </a>
<a name="ln1338">		BHandler* Handler() const</a>
<a name="ln1339">		{</a>
<a name="ln1340">			ASSERT(hasLock);</a>
<a name="ln1341">			return messenger.Target(0);</a>
<a name="ln1342">		}</a>
<a name="ln1343"> </a>
<a name="ln1344">		BMessenger Target() const</a>
<a name="ln1345">		{</a>
<a name="ln1346">			return messenger;</a>
<a name="ln1347">		}</a>
<a name="ln1348"> </a>
<a name="ln1349">	private:</a>
<a name="ln1350">		BMessenger messenger;</a>
<a name="ln1351">		bool hasLock;</a>
<a name="ln1352">};</a>
<a name="ln1353"> </a>
<a name="ln1354"> </a>
<a name="ln1355">class failToLock { /* exception in AddPoses */ };</a>
<a name="ln1356"> </a>
<a name="ln1357"> </a>
<a name="ln1358">status_t</a>
<a name="ln1359">BPoseView::AddPosesTask(void* castToParams)</a>
<a name="ln1360">{</a>
<a name="ln1361">	// AddPosesTask reads a bunch of models and passes them off to</a>
<a name="ln1362">	// the pose placing and drawing routine.</a>
<a name="ln1363"> </a>
<a name="ln1364">	AddPosesParams* params = (AddPosesParams*)castToParams;</a>
<a name="ln1365">	BMessenger target(params-&gt;target);</a>
<a name="ln1366">	entry_ref ref(params-&gt;ref);</a>
<a name="ln1367"> </a>
<a name="ln1368">	delete params;</a>
<a name="ln1369"> </a>
<a name="ln1370">	AutoLockingMessenger lock(target);</a>
<a name="ln1371"> </a>
<a name="ln1372">	if (!lock.IsLocked())</a>
<a name="ln1373">		return B_ERROR;</a>
<a name="ln1374"> </a>
<a name="ln1375">	thread_id threadID = find_thread(NULL);</a>
<a name="ln1376"> </a>
<a name="ln1377">	BPoseView* view = dynamic_cast&lt;BPoseView*&gt;(lock.Handler());</a>
<a name="ln1378">	ThrowOnAssert(view != NULL);</a>
<a name="ln1379"> </a>
<a name="ln1380">	BWindow* window = dynamic_cast&lt;BWindow*&gt;(lock.Looper());</a>
<a name="ln1381">	ThrowOnAssert(window != NULL);</a>
<a name="ln1382"> </a>
<a name="ln1383">	// allocate the iterator we will use for adding poses; this</a>
<a name="ln1384">	// can be a directory or any other collection of entry_refs, such</a>
<a name="ln1385">	// as results of a query; subclasses override this to provide</a>
<a name="ln1386">	// other than standard directory iterations</a>
<a name="ln1387">	EntryListBase* container = view-&gt;InitDirentIterator(&amp;ref);</a>
<a name="ln1388">	if (container == NULL) {</a>
<a name="ln1389">		view-&gt;HideBarberPole();</a>
<a name="ln1390">		return B_ERROR;</a>
<a name="ln1391">	}</a>
<a name="ln1392"> </a>
<a name="ln1393">	AddPosesResult* posesResult = new AddPosesResult;</a>
<a name="ln1394">	posesResult-&gt;fCount = 0;</a>
<a name="ln1395">	int32 modelChunkIndex = -1;</a>
<a name="ln1396">	bigtime_t nextChunkTime = 0;</a>
<a name="ln1397">	uint32 watchMask = view-&gt;WatchNewNodeMask();</a>
<a name="ln1398"> </a>
<a name="ln1399">	bool hideDotFiles = TrackerSettings().HideDotFiles();</a>
<a name="ln1400">#if DEBUG</a>
<a name="ln1401">	for (int32 index = 0; index &lt; kMaxAddPosesChunk; index++)</a>
<a name="ln1402">		posesResult-&gt;fModels[index] = (Model*)0xdeadbeef;</a>
<a name="ln1403">#endif</a>
<a name="ln1404"> </a>
<a name="ln1405">	try {</a>
<a name="ln1406">		for (;;) {</a>
<a name="ln1407">			lock.Unlock();</a>
<a name="ln1408"> </a>
<a name="ln1409">			status_t result = B_OK;</a>
<a name="ln1410">			char entBuf[1024];</a>
<a name="ln1411">			dirent* eptr = (dirent*)entBuf;</a>
<a name="ln1412">			Model* model = 0;</a>
<a name="ln1413">			node_ref dirNode;</a>
<a name="ln1414">			node_ref itemNode;</a>
<a name="ln1415"> </a>
<a name="ln1416">			int32 count = container-&gt;GetNextDirents(eptr, 1024, 1);</a>
<a name="ln1417">			if (count &lt;= 0 &amp;&amp; modelChunkIndex == -1)</a>
<a name="ln1418">				break;</a>
<a name="ln1419"> </a>
<a name="ln1420">			if (count &gt; 0) {</a>
<a name="ln1421">				ASSERT(count == 1);</a>
<a name="ln1422"> </a>
<a name="ln1423">				if ((!hideDotFiles &amp;&amp; (!strcmp(eptr-&gt;d_name, &quot;.&quot;)</a>
<a name="ln1424">					|| !strcmp(eptr-&gt;d_name, &quot;..&quot;)))</a>
<a name="ln1425">					|| (hideDotFiles &amp;&amp; eptr-&gt;d_name[0] == '.')) {</a>
<a name="ln1426">					continue;</a>
<a name="ln1427">				}</a>
<a name="ln1428"> </a>
<a name="ln1429">				dirNode.device = eptr-&gt;d_pdev;</a>
<a name="ln1430">				dirNode.node = eptr-&gt;d_pino;</a>
<a name="ln1431">				itemNode.device = eptr-&gt;d_dev;</a>
<a name="ln1432">				itemNode.node = eptr-&gt;d_ino;</a>
<a name="ln1433"> </a>
<a name="ln1434">				BPoseView::WatchNewNode(&amp;itemNode, watchMask, lock.Target());</a>
<a name="ln1435">					// have to node monitor ahead of time because Model will</a>
<a name="ln1436">					// cache up the file type and preferred app</a>
<a name="ln1437">					// OK to call when poseView is not locked</a>
<a name="ln1438">				model = new Model(&amp;dirNode, &amp;itemNode, eptr-&gt;d_name, false);</a>
<a name="ln1439">				result = model-&gt;InitCheck();</a>
<a name="ln1440">				modelChunkIndex++;</a>
<a name="ln1441">				posesResult-&gt;fModels[modelChunkIndex] = model;</a>
<a name="ln1442">			}</a>
<a name="ln1443"> </a>
<a name="ln1444">			// before we access the pose view, lock down the window</a>
<a name="ln1445"> </a>
<a name="ln1446">			if (!lock.Lock()) {</a>
<a name="ln1447">				PRINT((&quot;failed to lock\n&quot;));</a>
<a name="ln1448">				posesResult-&gt;fCount = modelChunkIndex + 1;</a>
<a name="ln1449">				throw failToLock();</a>
<a name="ln1450">			}</a>
<a name="ln1451"> </a>
<a name="ln1452">			if (!view-&gt;IsValidAddPosesThread(threadID)) {</a>
<a name="ln1453">				// this handles the case of a file panel when the directory is</a>
<a name="ln1454">				// switched and an old AddPosesTask needs to die.</a>
<a name="ln1455">				// we might no longer be the current async thread</a>
<a name="ln1456">				// for this view - if not then we're done</a>
<a name="ln1457">				view-&gt;HideBarberPole();</a>
<a name="ln1458"> </a>
<a name="ln1459">				view-&gt;ReturnDirentIterator(container);</a>
<a name="ln1460">				container = NULL;</a>
<a name="ln1461"> </a>
<a name="ln1462">				// for now use the same cleanup as failToLock does</a>
<a name="ln1463">				posesResult-&gt;fCount = modelChunkIndex + 1;</a>
<a name="ln1464">				throw failToLock();</a>
<a name="ln1465">			}</a>
<a name="ln1466"> </a>
<a name="ln1467">			if (count &gt; 0) {</a>
<a name="ln1468">				// try to watch the model, no matter what</a>
<a name="ln1469"> </a>
<a name="ln1470">				if (result != B_OK) {</a>
<a name="ln1471">					// failed to init pose, model is a zombie, add to zombie</a>
<a name="ln1472">					// list</a>
<a name="ln1473">					PRINT((&quot;1 adding model %s to zombie list, error %s\n&quot;,</a>
<a name="ln1474">						model-&gt;Name(), strerror(model-&gt;InitCheck())));</a>
<a name="ln1475">					view-&gt;fZombieList-&gt;AddItem(model);</a>
<a name="ln1476">					modelChunkIndex--;</a>
<a name="ln1477">					continue;</a>
<a name="ln1478">				}</a>
<a name="ln1479"> </a>
<a name="ln1480">				view-&gt;ReadPoseInfo(model,</a>
<a name="ln1481">					&amp;posesResult-&gt;fPoseInfos[modelChunkIndex]);</a>
<a name="ln1482"> </a>
<a name="ln1483">				if (!PoseVisible(model,</a>
<a name="ln1484">					&amp;posesResult-&gt;fPoseInfos[modelChunkIndex])) {</a>
<a name="ln1485">					modelChunkIndex--;</a>
<a name="ln1486">					continue;</a>
<a name="ln1487">				}</a>
<a name="ln1488"> </a>
<a name="ln1489">				if (model-&gt;IsSymLink())</a>
<a name="ln1490">					view-&gt;CreateSymlinkPoseTarget(model);</a>
<a name="ln1491">			}</a>
<a name="ln1492"> </a>
<a name="ln1493">			bigtime_t now = system_time();</a>
<a name="ln1494"> </a>
<a name="ln1495">			if (count &lt;= 0 || modelChunkIndex &gt;= kMaxAddPosesChunk - 1</a>
<a name="ln1496">				|| now &gt; nextChunkTime) {</a>
<a name="ln1497">				// keep getting models until we get &lt;kMaxAddPosesChunk&gt; of them</a>
<a name="ln1498">				// or until 300000 runs out</a>
<a name="ln1499"> </a>
<a name="ln1500">				ASSERT(modelChunkIndex &gt;= 0);</a>
<a name="ln1501"> </a>
<a name="ln1502">				// send of the created poses</a>
<a name="ln1503"> </a>
<a name="ln1504">				posesResult-&gt;fCount = modelChunkIndex + 1;</a>
<a name="ln1505">				BMessage creationData(kAddNewPoses);</a>
<a name="ln1506">				creationData.AddPointer(&quot;currentPoses&quot;, posesResult);</a>
<a name="ln1507">				creationData.AddRef(&quot;ref&quot;, &amp;ref);</a>
<a name="ln1508"> </a>
<a name="ln1509">				lock.Target().SendMessage(&amp;creationData);</a>
<a name="ln1510"> </a>
<a name="ln1511">				modelChunkIndex = -1;</a>
<a name="ln1512">				nextChunkTime = now + 300000;</a>
<a name="ln1513"> </a>
<a name="ln1514">				posesResult = new AddPosesResult;</a>
<a name="ln1515">				posesResult-&gt;fCount = 0;</a>
<a name="ln1516"> </a>
<a name="ln1517">				snooze(500);</a>
<a name="ln1518">					// be nice</a>
<a name="ln1519">			}</a>
<a name="ln1520"> </a>
<a name="ln1521">			if (count &lt;= 0)</a>
<a name="ln1522">				break;</a>
<a name="ln1523">		}</a>
<a name="ln1524"> </a>
<a name="ln1525">		BMessage finishedSending(kAddPosesCompleted);</a>
<a name="ln1526">		lock.Target().SendMessage(&amp;finishedSending);</a>
<a name="ln1527"> </a>
<a name="ln1528">	} catch (failToLock) {</a>
<a name="ln1529">		// we are here because the window got closed or otherwise failed to</a>
<a name="ln1530">		// lock</a>
<a name="ln1531"> </a>
<a name="ln1532">		PRINT((&quot;add_poses cleanup \n&quot;));</a>
<a name="ln1533">		// failed to lock window, bail</a>
<a name="ln1534">		delete posesResult;</a>
<a name="ln1535">		delete container;</a>
<a name="ln1536"> </a>
<a name="ln1537">		return B_ERROR;</a>
<a name="ln1538">	}</a>
<a name="ln1539"> </a>
<a name="ln1540">	ASSERT(modelChunkIndex == -1);</a>
<a name="ln1541"> </a>
<a name="ln1542">	delete posesResult;</a>
<a name="ln1543"> </a>
<a name="ln1544">	if (lock.Lock()) {</a>
<a name="ln1545">		view-&gt;ReturnDirentIterator(container);</a>
<a name="ln1546">		view-&gt;fAddPosesThreads.erase(threadID);</a>
<a name="ln1547">	} else</a>
<a name="ln1548">		delete container;</a>
<a name="ln1549"> </a>
<a name="ln1550">	return B_OK;</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553"> </a>
<a name="ln1554">void</a>
<a name="ln1555">BPoseView::AddRootPoses(bool watchIndividually, bool mountShared)</a>
<a name="ln1556">{</a>
<a name="ln1557">	BVolumeRoster roster;</a>
<a name="ln1558">	roster.Rewind();</a>
<a name="ln1559">	BVolume volume;</a>
<a name="ln1560"> </a>
<a name="ln1561">	if (TrackerSettings().ShowDisksIcon() &amp;&amp; !TargetModel()-&gt;IsRoot()) {</a>
<a name="ln1562">		BEntry entry(&quot;/&quot;);</a>
<a name="ln1563">		Model model(&amp;entry);</a>
<a name="ln1564">		if (model.InitCheck() == B_OK) {</a>
<a name="ln1565">			BMessage monitorMsg;</a>
<a name="ln1566">			monitorMsg.what = B_NODE_MONITOR;</a>
<a name="ln1567"> </a>
<a name="ln1568">			monitorMsg.AddInt32(&quot;opcode&quot;, B_ENTRY_CREATED);</a>
<a name="ln1569"> </a>
<a name="ln1570">			monitorMsg.AddInt32(&quot;device&quot;, model.NodeRef()-&gt;device);</a>
<a name="ln1571">			monitorMsg.AddInt64(&quot;node&quot;, model.NodeRef()-&gt;node);</a>
<a name="ln1572">			monitorMsg.AddInt64(&quot;directory&quot;, model.EntryRef()-&gt;directory);</a>
<a name="ln1573">			monitorMsg.AddString(&quot;name&quot;, model.EntryRef()-&gt;name);</a>
<a name="ln1574">			if (Window())</a>
<a name="ln1575">				Window()-&gt;PostMessage(&amp;monitorMsg, this);</a>
<a name="ln1576">		}</a>
<a name="ln1577">	} else {</a>
<a name="ln1578">		while (roster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln1579">			if (!volume.IsPersistent())</a>
<a name="ln1580">				continue;</a>
<a name="ln1581"> </a>
<a name="ln1582">	 		if (volume.IsShared() &amp;&amp; !mountShared)</a>
<a name="ln1583">				continue;</a>
<a name="ln1584"> </a>
<a name="ln1585">			CreateVolumePose(&amp;volume, watchIndividually);</a>
<a name="ln1586">		}</a>
<a name="ln1587">	}</a>
<a name="ln1588"> </a>
<a name="ln1589">	SortPoses();</a>
<a name="ln1590">	UpdateCount();</a>
<a name="ln1591">	Invalidate();</a>
<a name="ln1592">}</a>
<a name="ln1593"> </a>
<a name="ln1594"> </a>
<a name="ln1595">void</a>
<a name="ln1596">BPoseView::RemoveRootPoses()</a>
<a name="ln1597">{</a>
<a name="ln1598">	int32 index;</a>
<a name="ln1599">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln1600">	for (index = 0; index &lt; count;) {</a>
<a name="ln1601">		BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln1602">		if (pose != NULL) {</a>
<a name="ln1603">			Model* model = pose-&gt;TargetModel();</a>
<a name="ln1604">			if (model != NULL) {</a>
<a name="ln1605">				if (model-&gt;IsVolume()) {</a>
<a name="ln1606">					DeletePose(model-&gt;NodeRef());</a>
<a name="ln1607">					count--;</a>
<a name="ln1608">				} else</a>
<a name="ln1609">					index++;</a>
<a name="ln1610">			}</a>
<a name="ln1611">		}</a>
<a name="ln1612">	}</a>
<a name="ln1613"> </a>
<a name="ln1614">	SortPoses();</a>
<a name="ln1615">	UpdateCount();</a>
<a name="ln1616">	Invalidate();</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619"> </a>
<a name="ln1620">void</a>
<a name="ln1621">BPoseView::AddTrashPoses()</a>
<a name="ln1622">{</a>
<a name="ln1623">	// the trash window needs to display a union of all the</a>
<a name="ln1624">	// trash folders from all the mounted volumes</a>
<a name="ln1625">	BVolumeRoster volRoster;</a>
<a name="ln1626">	volRoster.Rewind();</a>
<a name="ln1627">	BVolume volume;</a>
<a name="ln1628">	while (volRoster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln1629">		if (!volume.IsPersistent())</a>
<a name="ln1630">			continue;</a>
<a name="ln1631"> </a>
<a name="ln1632">		BDirectory trashDir;</a>
<a name="ln1633">		BEntry entry;</a>
<a name="ln1634">		if (FSGetTrashDir(&amp;trashDir, volume.Device()) == B_OK</a>
<a name="ln1635">			&amp;&amp; trashDir.GetEntry(&amp;entry) == B_OK) {</a>
<a name="ln1636">			Model model(&amp;entry);</a>
<a name="ln1637">			if (model.InitCheck() == B_OK)</a>
<a name="ln1638">				AddPoses(&amp;model);</a>
<a name="ln1639">		}</a>
<a name="ln1640">	}</a>
<a name="ln1641">}</a>
<a name="ln1642"> </a>
<a name="ln1643"> </a>
<a name="ln1644">void</a>
<a name="ln1645">BPoseView::AddPosesCompleted()</a>
<a name="ln1646">{</a>
<a name="ln1647">	BContainerWindow* containerWindow = ContainerWindow();</a>
<a name="ln1648">	if (containerWindow != NULL)</a>
<a name="ln1649">		containerWindow-&gt;AddMimeTypesToMenu();</a>
<a name="ln1650"> </a>
<a name="ln1651">	// if we're not in icon mode then we need to check for poses that</a>
<a name="ln1652">	// were &quot;auto&quot; placed to see if they overlap with other icons</a>
<a name="ln1653">	if (ViewMode() != kListMode)</a>
<a name="ln1654">		CheckAutoPlacedPoses();</a>
<a name="ln1655"> </a>
<a name="ln1656">	UpdateScrollRange();</a>
<a name="ln1657">	HideBarberPole();</a>
<a name="ln1658"> </a>
<a name="ln1659">	// make sure that the last item in the list is not placed</a>
<a name="ln1660">	// above the top of the view (leaving you with an empty window)</a>
<a name="ln1661">	if (ViewMode() == kListMode) {</a>
<a name="ln1662">		BRect bounds(Bounds());</a>
<a name="ln1663">		float lastItemTop = (CurrentPoseList()-&gt;CountItems() - 1)</a>
<a name="ln1664">			* fListElemHeight;</a>
<a name="ln1665">		if (bounds.top &gt; lastItemTop)</a>
<a name="ln1666">			BView::ScrollTo(bounds.left, std::max(lastItemTop, 0.0f));</a>
<a name="ln1667">	}</a>
<a name="ln1668">}</a>
<a name="ln1669"> </a>
<a name="ln1670"> </a>
<a name="ln1671">void</a>
<a name="ln1672">BPoseView::CreateVolumePose(BVolume* volume, bool watchIndividually)</a>
<a name="ln1673">{</a>
<a name="ln1674">	if (volume-&gt;InitCheck() != B_OK || !volume-&gt;IsPersistent()) {</a>
<a name="ln1675">		// We never want to create poses for those volumes; the file</a>
<a name="ln1676">		// system root, /pipe, /dev, etc. are all non-persistent</a>
<a name="ln1677">		return;</a>
<a name="ln1678">	}</a>
<a name="ln1679"> </a>
<a name="ln1680">	BDirectory root;</a>
<a name="ln1681">	if (volume-&gt;GetRootDirectory(&amp;root) != B_OK)</a>
<a name="ln1682">		return;</a>
<a name="ln1683"> </a>
<a name="ln1684">	BEntry entry;</a>
<a name="ln1685">	root.GetEntry(&amp;entry);</a>
<a name="ln1686"> </a>
<a name="ln1687">	entry_ref ref;</a>
<a name="ln1688">	entry.GetRef(&amp;ref);</a>
<a name="ln1689"> </a>
<a name="ln1690">	// If the volume is mounted at a directory of a persistent volume, we don't</a>
<a name="ln1691">	// want it on the desktop or in the disks window.</a>
<a name="ln1692">	BVolume parentVolume(ref.device);</a>
<a name="ln1693">	if (parentVolume.InitCheck() == B_OK &amp;&amp; parentVolume.IsPersistent())</a>
<a name="ln1694">		return;</a>
<a name="ln1695"> </a>
<a name="ln1696">	node_ref itemNode;</a>
<a name="ln1697">	root.GetNodeRef(&amp;itemNode);</a>
<a name="ln1698"> </a>
<a name="ln1699">	node_ref dirNode;</a>
<a name="ln1700">	dirNode.device = ref.device;</a>
<a name="ln1701">	dirNode.node = ref.directory;</a>
<a name="ln1702"> </a>
<a name="ln1703">	BPose* pose = EntryCreated(&amp;dirNode, &amp;itemNode, ref.name, 0);</a>
<a name="ln1704">	if (pose != NULL &amp;&amp; watchIndividually) {</a>
<a name="ln1705">		// make sure volume names still get watched, even though</a>
<a name="ln1706">		// they are on the desktop which is not their physical parent</a>
<a name="ln1707">		pose-&gt;TargetModel()-&gt;WatchVolumeAndMountPoint(B_WATCH_NAME</a>
<a name="ln1708">			| B_WATCH_STAT | B_WATCH_ATTR, this);</a>
<a name="ln1709">	}</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712"> </a>
<a name="ln1713">void</a>
<a name="ln1714">BPoseView::CreateTrashPose()</a>
<a name="ln1715">{</a>
<a name="ln1716">	BVolume volume;</a>
<a name="ln1717">	if (BVolumeRoster().GetBootVolume(&amp;volume) == B_OK) {</a>
<a name="ln1718">		BDirectory trash;</a>
<a name="ln1719">		BEntry entry;</a>
<a name="ln1720">		node_ref ref;</a>
<a name="ln1721">		if (FSGetTrashDir(&amp;trash, volume.Device()) == B_OK</a>
<a name="ln1722">			&amp;&amp; trash.GetEntry(&amp;entry) == B_OK</a>
<a name="ln1723">			&amp;&amp; entry.GetNodeRef(&amp;ref) == B_OK) {</a>
<a name="ln1724">			WatchNewNode(&amp;ref);</a>
<a name="ln1725">			Model* model = new Model(&amp;entry);</a>
<a name="ln1726">			PoseInfo info;</a>
<a name="ln1727">			ReadPoseInfo(model, &amp;info);</a>
<a name="ln1728">			CreatePose(model, &amp;info, false, NULL, NULL, true);</a>
<a name="ln1729">		}</a>
<a name="ln1730">	}</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733"> </a>
<a name="ln1734">BPose*</a>
<a name="ln1735">BPoseView::CreatePose(Model* model, PoseInfo* poseInfo, bool insertionSort,</a>
<a name="ln1736">	int32* indexPtr, BRect* boundsPointer, bool forceDraw)</a>
<a name="ln1737">{</a>
<a name="ln1738">	BPose* result;</a>
<a name="ln1739">	CreatePoses(&amp;model, poseInfo, 1, &amp;result, insertionSort, indexPtr,</a>
<a name="ln1740">		boundsPointer, forceDraw);</a>
<a name="ln1741"> </a>
<a name="ln1742">	return result;</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745"> </a>
<a name="ln1746">void</a>
<a name="ln1747">BPoseView::FinishPendingScroll(float &amp;listViewScrollBy, BRect srcRect)</a>
<a name="ln1748">{</a>
<a name="ln1749">	if (listViewScrollBy == 0.0)</a>
<a name="ln1750">		return;</a>
<a name="ln1751"> </a>
<a name="ln1752">	// copy top contents to bottom and</a>
<a name="ln1753">	// redraw from top to top of part that could be copied</a>
<a name="ln1754"> </a>
<a name="ln1755">	if (srcRect.Width() &gt; listViewScrollBy) {</a>
<a name="ln1756">		BRect dstRect = srcRect;</a>
<a name="ln1757">		srcRect.bottom -= listViewScrollBy;</a>
<a name="ln1758">		dstRect.top += listViewScrollBy;</a>
<a name="ln1759">		CopyBits(srcRect, dstRect);</a>
<a name="ln1760">		listViewScrollBy = 0;</a>
<a name="ln1761">		srcRect.bottom = dstRect.top;</a>
<a name="ln1762">	}</a>
<a name="ln1763">	SynchronousUpdate(srcRect);</a>
<a name="ln1764">}</a>
<a name="ln1765"> </a>
<a name="ln1766"> </a>
<a name="ln1767">bool</a>
<a name="ln1768">BPoseView::AddPosesThreadValid(const entry_ref* ref) const</a>
<a name="ln1769">{</a>
<a name="ln1770">	return *(TargetModel()-&gt;EntryRef()) == *ref || ContainerWindow()-&gt;IsTrash();</a>
<a name="ln1771">}</a>
<a name="ln1772"> </a>
<a name="ln1773"> </a>
<a name="ln1774">void</a>
<a name="ln1775">BPoseView::AddPoseToList(PoseList* list, bool visibleList, bool insertionSort,</a>
<a name="ln1776">	BPose* pose, BRect &amp;viewBounds, float &amp;listViewScrollBy, bool forceDraw,</a>
<a name="ln1777">	int32* indexPtr)</a>
<a name="ln1778">{</a>
<a name="ln1779">	int32 poseIndex = list-&gt;CountItems();</a>
<a name="ln1780"> </a>
<a name="ln1781">	BRect poseBounds;</a>
<a name="ln1782">	bool havePoseBounds = false;</a>
<a name="ln1783">	bool addedItem = false;</a>
<a name="ln1784">	bool needToDraw = true;</a>
<a name="ln1785"> </a>
<a name="ln1786">	if (insertionSort &amp;&amp; list-&gt;CountItems() &gt; 0) {</a>
<a name="ln1787">		int32 orientation = BSearchList(list, pose, &amp;poseIndex, 0);</a>
<a name="ln1788"> </a>
<a name="ln1789">		if (orientation == kInsertAfter)</a>
<a name="ln1790">			poseIndex++;</a>
<a name="ln1791"> </a>
<a name="ln1792">		if (visibleList) {</a>
<a name="ln1793">			// we only care about the positions if this is a visible list</a>
<a name="ln1794">			poseBounds = CalcPoseRectList(pose, poseIndex);</a>
<a name="ln1795">			havePoseBounds = true;</a>
<a name="ln1796"> </a>
<a name="ln1797">			BRect srcRect(Extent());</a>
<a name="ln1798">			srcRect.top = poseBounds.top;</a>
<a name="ln1799">			srcRect = srcRect &amp; viewBounds;</a>
<a name="ln1800">			BRect destRect(srcRect);</a>
<a name="ln1801">			destRect.OffsetBy(0, fListElemHeight);</a>
<a name="ln1802"> </a>
<a name="ln1803">			// special case the addition of a pose that scrolls</a>
<a name="ln1804">			// the extent into the view for the first time:</a>
<a name="ln1805">			if (destRect.bottom &gt; viewBounds.top</a>
<a name="ln1806">				&amp;&amp; destRect.top &gt; destRect.bottom) {</a>
<a name="ln1807">				// make destRect valid</a>
<a name="ln1808">				destRect.top = viewBounds.top;</a>
<a name="ln1809">			}</a>
<a name="ln1810"> </a>
<a name="ln1811">			if (srcRect.Intersects(viewBounds)</a>
<a name="ln1812">				|| destRect.Intersects(viewBounds)) {</a>
<a name="ln1813">				// The visual area is affected by the insertion.</a>
<a name="ln1814">				// If items have been added above the visual area,</a>
<a name="ln1815">				// delay the scrolling. srcRect.bottom holds the</a>
<a name="ln1816">				// current Extent(). So if the bottom is still above</a>
<a name="ln1817">				// the viewBounds top, it means the view is scrolled</a>
<a name="ln1818">				// to show the area below the items that have already</a>
<a name="ln1819">				// been added.</a>
<a name="ln1820">				if (srcRect.top == viewBounds.top</a>
<a name="ln1821">					&amp;&amp; srcRect.bottom &gt;= viewBounds.top</a>
<a name="ln1822">					&amp;&amp; poseIndex != 0) {</a>
<a name="ln1823">					// if new pose above current view bounds, cache up</a>
<a name="ln1824">					// the draw and do it later</a>
<a name="ln1825">					listViewScrollBy += fListElemHeight;</a>
<a name="ln1826">					needToDraw = false;</a>
<a name="ln1827">				} else {</a>
<a name="ln1828">					FinishPendingScroll(listViewScrollBy, viewBounds);</a>
<a name="ln1829">					list-&gt;AddItem(pose, poseIndex);</a>
<a name="ln1830"> </a>
<a name="ln1831">					fMimeTypeListIsDirty = true;</a>
<a name="ln1832">					addedItem = true;</a>
<a name="ln1833">					if (srcRect.IsValid()) {</a>
<a name="ln1834">						CopyBits(srcRect, destRect);</a>
<a name="ln1835">						srcRect.bottom = destRect.top;</a>
<a name="ln1836">						SynchronousUpdate(srcRect);</a>
<a name="ln1837">					} else {</a>
<a name="ln1838">						SynchronousUpdate(destRect);</a>
<a name="ln1839">					}</a>
<a name="ln1840">					needToDraw = false;</a>
<a name="ln1841">				}</a>
<a name="ln1842">			}</a>
<a name="ln1843">		}</a>
<a name="ln1844">	}</a>
<a name="ln1845"> </a>
<a name="ln1846">	if (!addedItem) {</a>
<a name="ln1847">		list-&gt;AddItem(pose, poseIndex);</a>
<a name="ln1848">		fMimeTypeListIsDirty = true;</a>
<a name="ln1849">	}</a>
<a name="ln1850"> </a>
<a name="ln1851">	if (visibleList &amp;&amp; needToDraw &amp;&amp; forceDraw) {</a>
<a name="ln1852">		if (!havePoseBounds)</a>
<a name="ln1853">			poseBounds = CalcPoseRectList(pose, poseIndex);</a>
<a name="ln1854"> </a>
<a name="ln1855">		if (viewBounds.Intersects(poseBounds))</a>
<a name="ln1856"> 			SynchronousUpdate(poseBounds);</a>
<a name="ln1857">	}</a>
<a name="ln1858"> </a>
<a name="ln1859">	if (indexPtr)</a>
<a name="ln1860">		*indexPtr = poseIndex;</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863"> </a>
<a name="ln1864">void</a>
<a name="ln1865">BPoseView::CreatePoses(Model** models, PoseInfo* poseInfoArray, int32 count,</a>
<a name="ln1866">	BPose** resultingPoses, bool insertionSort, int32* lastPoseIndexPointer,</a>
<a name="ln1867">	BRect* boundsPointer, bool forceDraw)</a>
<a name="ln1868">{</a>
<a name="ln1869">	// were we passed the bounds of the view?</a>
<a name="ln1870">	BRect viewBounds;</a>
<a name="ln1871">	if (boundsPointer != NULL)</a>
<a name="ln1872">		viewBounds = *boundsPointer;</a>
<a name="ln1873">	else</a>
<a name="ln1874">		viewBounds = Bounds();</a>
<a name="ln1875"> </a>
<a name="ln1876">	bool clipboardLocked = be_clipboard-&gt;Lock();</a>
<a name="ln1877"> </a>
<a name="ln1878">	int32 poseIndex = 0;</a>
<a name="ln1879">	uint32 clipboardMode = 0;</a>
<a name="ln1880">	float listViewScrollBy = 0;</a>
<a name="ln1881">	for (int32 modelIndex = 0; modelIndex &lt; count; modelIndex++) {</a>
<a name="ln1882">		Model* model = models[modelIndex];</a>
<a name="ln1883"> </a>
<a name="ln1884">		// pose adopts model and deletes it when done</a>
<a name="ln1885">		if (fInsertedNodes.find(*(model-&gt;NodeRef())) != fInsertedNodes.end()</a>
<a name="ln1886">			|| FindZombie(model-&gt;NodeRef())) {</a>
<a name="ln1887">			watch_node(model-&gt;NodeRef(), B_STOP_WATCHING, this);</a>
<a name="ln1888">			delete model;</a>
<a name="ln1889">			if (resultingPoses)</a>
<a name="ln1890">				resultingPoses[modelIndex] = NULL;</a>
<a name="ln1891"> </a>
<a name="ln1892">			continue;</a>
<a name="ln1893">		} else</a>
<a name="ln1894">			fInsertedNodes.insert(*(model-&gt;NodeRef()));</a>
<a name="ln1895"> </a>
<a name="ln1896">		if ((clipboardMode = FSClipboardFindNodeMode(model, !clipboardLocked,</a>
<a name="ln1897">				true)) != 0 &amp;&amp; !HasPosesInClipboard()) {</a>
<a name="ln1898">			SetHasPosesInClipboard(true);</a>
<a name="ln1899">		}</a>
<a name="ln1900"> </a>
<a name="ln1901">		model-&gt;OpenNode();</a>
<a name="ln1902">		ASSERT(model-&gt;IsNodeOpen());</a>
<a name="ln1903">		PoseInfo* poseInfo = &amp;poseInfoArray[modelIndex];</a>
<a name="ln1904">		BPose* pose = new BPose(model, this, clipboardMode);</a>
<a name="ln1905"> </a>
<a name="ln1906">		if (resultingPoses)</a>
<a name="ln1907">			resultingPoses[modelIndex] = pose;</a>
<a name="ln1908"> </a>
<a name="ln1909">		// set location from poseinfo if saved loc was for this dir</a>
<a name="ln1910">		if (poseInfo-&gt;fInitedDirectory != -1LL) {</a>
<a name="ln1911">			PinPointToValidRange(poseInfo-&gt;fLocation);</a>
<a name="ln1912">			pose-&gt;SetLocation(poseInfo-&gt;fLocation, this);</a>
<a name="ln1913">			AddToVSList(pose);</a>
<a name="ln1914">		}</a>
<a name="ln1915"> </a>
<a name="ln1916">		BRect poseBounds;</a>
<a name="ln1917"> </a>
<a name="ln1918">		switch (ViewMode()) {</a>
<a name="ln1919">			case kListMode:</a>
<a name="ln1920">			{</a>
<a name="ln1921">				AddPoseToList(fPoseList, !fFiltering, insertionSort, pose,</a>
<a name="ln1922">					viewBounds, listViewScrollBy, forceDraw, &amp;poseIndex);</a>
<a name="ln1923"> </a>
<a name="ln1924">				if (fFiltering &amp;&amp; FilterPose(pose)) {</a>
<a name="ln1925">					AddPoseToList(fFilteredPoseList, true, insertionSort, pose,</a>
<a name="ln1926">						viewBounds, listViewScrollBy, forceDraw, &amp;poseIndex);</a>
<a name="ln1927">				}</a>
<a name="ln1928"> </a>
<a name="ln1929">				break;</a>
<a name="ln1930">			}</a>
<a name="ln1931"> </a>
<a name="ln1932">			case kIconMode:</a>
<a name="ln1933">			case kMiniIconMode:</a>
<a name="ln1934">				if (poseInfo-&gt;fInitedDirectory == -1LL || fAlwaysAutoPlace) {</a>
<a name="ln1935">					if (pose-&gt;HasLocation())</a>
<a name="ln1936">						RemoveFromVSList(pose);</a>
<a name="ln1937"> </a>
<a name="ln1938">					PlacePose(pose, viewBounds);</a>
<a name="ln1939"> </a>
<a name="ln1940">					// we set a flag in the pose here to signify that we were</a>
<a name="ln1941">					// auto placed - after adding all poses to window, we're</a>
<a name="ln1942">					// going to go back and make sure that the auto placed poses</a>
<a name="ln1943">					// don't overlap previously positioned icons. If so, we'll</a>
<a name="ln1944">					// move them to new positions.</a>
<a name="ln1945">					if (!fAlwaysAutoPlace)</a>
<a name="ln1946">						pose-&gt;SetAutoPlaced(true);</a>
<a name="ln1947"> </a>
<a name="ln1948">					AddToVSList(pose);</a>
<a name="ln1949">				}</a>
<a name="ln1950"> </a>
<a name="ln1951">				// add item to list and draw if necessary</a>
<a name="ln1952">				fPoseList-&gt;AddItem(pose);</a>
<a name="ln1953">				fMimeTypeListIsDirty = true;</a>
<a name="ln1954"> </a>
<a name="ln1955">				poseBounds = pose-&gt;CalcRect(this);</a>
<a name="ln1956"> </a>
<a name="ln1957">				if (fEnsurePosesVisible &amp;&amp; !viewBounds.Intersects(poseBounds)) {</a>
<a name="ln1958">					viewBounds.InsetBy(20, 20);</a>
<a name="ln1959">					RemoveFromVSList(pose);</a>
<a name="ln1960">					BPoint loc(pose-&gt;Location(this));</a>
<a name="ln1961">					loc.ConstrainTo(viewBounds);</a>
<a name="ln1962">					pose-&gt;SetLocation(loc, this);</a>
<a name="ln1963">					pose-&gt;SetSaveLocation();</a>
<a name="ln1964">					AddToVSList(pose);</a>
<a name="ln1965">					poseBounds = pose-&gt;CalcRect(this);</a>
<a name="ln1966">					viewBounds.InsetBy(-20, -20);</a>
<a name="ln1967">				}</a>
<a name="ln1968"> </a>
<a name="ln1969">				if (forceDraw &amp;&amp; viewBounds.Intersects(poseBounds))</a>
<a name="ln1970">					Invalidate(poseBounds);</a>
<a name="ln1971"> </a>
<a name="ln1972">				// if this is the first item then we set extent here</a>
<a name="ln1973">				if (!fExtent.IsValid())</a>
<a name="ln1974">					fExtent = poseBounds;</a>
<a name="ln1975">				else</a>
<a name="ln1976">					AddToExtent(poseBounds);</a>
<a name="ln1977"> </a>
<a name="ln1978">				break;</a>
<a name="ln1979">		}</a>
<a name="ln1980">		if (model-&gt;IsSymLink())</a>
<a name="ln1981">			model-&gt;ResolveIfLink()-&gt;CloseNode();</a>
<a name="ln1982"> </a>
<a name="ln1983">		model-&gt;CloseNode();</a>
<a name="ln1984">	}</a>
<a name="ln1985"> </a>
<a name="ln1986">	if (clipboardLocked)</a>
<a name="ln1987">		be_clipboard-&gt;Unlock();</a>
<a name="ln1988"> </a>
<a name="ln1989">	FinishPendingScroll(listViewScrollBy, viewBounds);</a>
<a name="ln1990"> </a>
<a name="ln1991">	if (lastPoseIndexPointer != NULL)</a>
<a name="ln1992">		*lastPoseIndexPointer = poseIndex;</a>
<a name="ln1993">}</a>
<a name="ln1994"> </a>
<a name="ln1995"> </a>
<a name="ln1996">bool</a>
<a name="ln1997">BPoseView::PoseVisible(const Model* model, const PoseInfo* poseInfo)</a>
<a name="ln1998">{</a>
<a name="ln1999">	return !poseInfo-&gt;fInvisible;</a>
<a name="ln2000">}</a>
<a name="ln2001"> </a>
<a name="ln2002"> </a>
<a name="ln2003">bool</a>
<a name="ln2004">BPoseView::ShouldShowPose(const Model* model, const PoseInfo* poseInfo)</a>
<a name="ln2005">{</a>
<a name="ln2006">	if (!PoseVisible(model, poseInfo))</a>
<a name="ln2007">		return false;</a>
<a name="ln2008"> </a>
<a name="ln2009">	// check filter before adding item</a>
<a name="ln2010">	if (!fRefFilter)</a>
<a name="ln2011">		return true;</a>
<a name="ln2012"> </a>
<a name="ln2013">	struct stat_beos stat;</a>
<a name="ln2014">	convert_to_stat_beos(model-&gt;StatBuf(), &amp;stat);</a>
<a name="ln2015"> </a>
<a name="ln2016">	return fRefFilter-&gt;Filter(model-&gt;EntryRef(), model-&gt;Node(), &amp;stat,</a>
<a name="ln2017">		model-&gt;MimeType());</a>
<a name="ln2018">}</a>
<a name="ln2019"> </a>
<a name="ln2020"> </a>
<a name="ln2021">const char*</a>
<a name="ln2022">BPoseView::MimeTypeAt(int32 index)</a>
<a name="ln2023">{</a>
<a name="ln2024">	if (fMimeTypeListIsDirty)</a>
<a name="ln2025">		RefreshMimeTypeList();</a>
<a name="ln2026"> </a>
<a name="ln2027">	return fMimeTypeList-&gt;ItemAt(index)-&gt;String();</a>
<a name="ln2028">}</a>
<a name="ln2029"> </a>
<a name="ln2030"> </a>
<a name="ln2031">int32</a>
<a name="ln2032">BPoseView::CountMimeTypes()</a>
<a name="ln2033">{</a>
<a name="ln2034">	if (fMimeTypeListIsDirty)</a>
<a name="ln2035">		RefreshMimeTypeList();</a>
<a name="ln2036"> </a>
<a name="ln2037">	return fMimeTypeList-&gt;CountItems();</a>
<a name="ln2038">}</a>
<a name="ln2039"> </a>
<a name="ln2040"> </a>
<a name="ln2041">void</a>
<a name="ln2042">BPoseView::AddMimeType(const char* mimeType)</a>
<a name="ln2043">{</a>
<a name="ln2044">	int32 count = fMimeTypeList-&gt;CountItems();</a>
<a name="ln2045">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln2046">		if (*fMimeTypeList-&gt;ItemAt(index) == mimeType)</a>
<a name="ln2047">			return;</a>
<a name="ln2048">	}</a>
<a name="ln2049"> </a>
<a name="ln2050">	fMimeTypeList-&gt;AddItem(new BString(mimeType));</a>
<a name="ln2051">}</a>
<a name="ln2052"> </a>
<a name="ln2053"> </a>
<a name="ln2054">void</a>
<a name="ln2055">BPoseView::RefreshMimeTypeList()</a>
<a name="ln2056">{</a>
<a name="ln2057">	fMimeTypeList-&gt;MakeEmpty();</a>
<a name="ln2058">	fMimeTypeListIsDirty = false;</a>
<a name="ln2059"> </a>
<a name="ln2060">	for (int32 index = 0;; index++) {</a>
<a name="ln2061">		BPose* pose = PoseAtIndex(index);</a>
<a name="ln2062">		if (pose == NULL)</a>
<a name="ln2063">			break;</a>
<a name="ln2064"> </a>
<a name="ln2065">		Model* targetModel = pose-&gt;TargetModel();</a>
<a name="ln2066">		if (targetModel != NULL)</a>
<a name="ln2067">			AddMimeType(targetModel-&gt;MimeType());</a>
<a name="ln2068">	}</a>
<a name="ln2069">}</a>
<a name="ln2070"> </a>
<a name="ln2071"> </a>
<a name="ln2072">void</a>
<a name="ln2073">BPoseView::InsertPoseAfter(BPose* pose, int32* index, int32 orientation,</a>
<a name="ln2074">	BRect* invalidRect)</a>
<a name="ln2075">{</a>
<a name="ln2076">	if (orientation == kInsertAfter) {</a>
<a name="ln2077">		// TODO: get rid of this</a>
<a name="ln2078">		(*index)++;</a>
<a name="ln2079">	}</a>
<a name="ln2080"> </a>
<a name="ln2081">	BRect bounds(Bounds());</a>
<a name="ln2082">	// copy the good bits in the list</a>
<a name="ln2083">	BRect srcRect(Extent());</a>
<a name="ln2084">	srcRect.top = CalcPoseRectList(pose, *index).top;</a>
<a name="ln2085">	srcRect = srcRect &amp; bounds;</a>
<a name="ln2086">	BRect destRect(srcRect);</a>
<a name="ln2087">	destRect.OffsetBy(0, fListElemHeight);</a>
<a name="ln2088"> </a>
<a name="ln2089">	if (srcRect.Intersects(bounds) || destRect.Intersects(bounds))</a>
<a name="ln2090">		CopyBits(srcRect, destRect);</a>
<a name="ln2091"> </a>
<a name="ln2092">	// this is the invalid rectangle</a>
<a name="ln2093">	srcRect.bottom = destRect.top;</a>
<a name="ln2094">	*invalidRect = srcRect;</a>
<a name="ln2095">}</a>
<a name="ln2096"> </a>
<a name="ln2097"> </a>
<a name="ln2098">void</a>
<a name="ln2099">BPoseView::DisableScrollBars()</a>
<a name="ln2100">{</a>
<a name="ln2101">	if (fHScrollBar != NULL)</a>
<a name="ln2102">		fHScrollBar-&gt;SetTarget((BView*)NULL);</a>
<a name="ln2103"> </a>
<a name="ln2104">	if (fVScrollBar != NULL)</a>
<a name="ln2105">		fVScrollBar-&gt;SetTarget((BView*)NULL);</a>
<a name="ln2106">}</a>
<a name="ln2107"> </a>
<a name="ln2108"> </a>
<a name="ln2109">void</a>
<a name="ln2110">BPoseView::EnableScrollBars()</a>
<a name="ln2111">{</a>
<a name="ln2112">	if (fHScrollBar != NULL)</a>
<a name="ln2113">		fHScrollBar-&gt;SetTarget(this);</a>
<a name="ln2114"> </a>
<a name="ln2115">	if (fVScrollBar != NULL)</a>
<a name="ln2116">		fVScrollBar-&gt;SetTarget(this);</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119"> </a>
<a name="ln2120">void</a>
<a name="ln2121">BPoseView::AddScrollBars()</a>
<a name="ln2122">{</a>
<a name="ln2123">	fHScrollBar = new TScrollBar(&quot;HScrollBar&quot;, this, 0, 100);</a>
<a name="ln2124">	fVScrollBar = new BScrollBar(&quot;VScrollBar&quot;, this, 0, 100, B_VERTICAL);</a>
<a name="ln2125">}</a>
<a name="ln2126"> </a>
<a name="ln2127"> </a>
<a name="ln2128">void</a>
<a name="ln2129">BPoseView::UpdateCount()</a>
<a name="ln2130">{</a>
<a name="ln2131">	if (fCountView != NULL)</a>
<a name="ln2132">		fCountView-&gt;CheckCount();</a>
<a name="ln2133">}</a>
<a name="ln2134"> </a>
<a name="ln2135"> </a>
<a name="ln2136">void</a>
<a name="ln2137">BPoseView::MessageReceived(BMessage* message)</a>
<a name="ln2138">{</a>
<a name="ln2139">	if (message-&gt;WasDropped() &amp;&amp; HandleMessageDropped(message))</a>
<a name="ln2140">		return;</a>
<a name="ln2141"> </a>
<a name="ln2142">	if (HandleScriptingMessage(message))</a>
<a name="ln2143">		return;</a>
<a name="ln2144"> </a>
<a name="ln2145">	switch (message-&gt;what) {</a>
<a name="ln2146">		case kAddNewPoses:</a>
<a name="ln2147">		{</a>
<a name="ln2148">			AddPosesResult* currentPoses;</a>
<a name="ln2149">			entry_ref ref;</a>
<a name="ln2150">			if (message-&gt;FindPointer(&quot;currentPoses&quot;,</a>
<a name="ln2151">					reinterpret_cast&lt;void**&gt;(&amp;currentPoses)) == B_OK</a>
<a name="ln2152">				&amp;&amp; message-&gt;FindRef(&quot;ref&quot;, &amp;ref) == B_OK) {</a>
<a name="ln2153">				// check if CreatePoses should be called</a>
<a name="ln2154">				// (abort if dir has been switched under normal</a>
<a name="ln2155">				// circumstances, ignore in several special cases)</a>
<a name="ln2156">				if (AddPosesThreadValid(&amp;ref)) {</a>
<a name="ln2157">					CreatePoses(currentPoses-&gt;fModels,</a>
<a name="ln2158">						currentPoses-&gt;fPoseInfos,</a>
<a name="ln2159">						currentPoses-&gt;fCount, NULL, true, 0, 0, true);</a>
<a name="ln2160">					currentPoses-&gt;ReleaseModels();</a>
<a name="ln2161">				}</a>
<a name="ln2162">				delete currentPoses;</a>
<a name="ln2163">			}</a>
<a name="ln2164">			break;</a>
<a name="ln2165">		}</a>
<a name="ln2166"> </a>
<a name="ln2167">		case kAddPosesCompleted:</a>
<a name="ln2168">			AddPosesCompleted();</a>
<a name="ln2169">			break;</a>
<a name="ln2170"> </a>
<a name="ln2171">		case kRestoreBackgroundImage:</a>
<a name="ln2172">			ContainerWindow()-&gt;UpdateBackgroundImage();</a>
<a name="ln2173">			break;</a>
<a name="ln2174"> </a>
<a name="ln2175">		case B_META_MIME_CHANGED:</a>
<a name="ln2176">			NoticeMetaMimeChanged(message);</a>
<a name="ln2177">			break;</a>
<a name="ln2178"> </a>
<a name="ln2179">		case B_NODE_MONITOR:</a>
<a name="ln2180">		case B_PATH_MONITOR:</a>
<a name="ln2181">		case B_QUERY_UPDATE:</a>
<a name="ln2182">			if (!FSNotification(message))</a>
<a name="ln2183">				pendingNodeMonitorCache.Add(message);</a>
<a name="ln2184">			break;</a>
<a name="ln2185"> </a>
<a name="ln2186">		case kIconMode: {</a>
<a name="ln2187">			int32 size;</a>
<a name="ln2188">			int32 scale;</a>
<a name="ln2189">			if (message-&gt;FindInt32(&quot;size&quot;, &amp;size) == B_OK) {</a>
<a name="ln2190">				if (size != (int32)IconSizeInt())</a>
<a name="ln2191">					fViewState-&gt;SetIconSize(size);</a>
<a name="ln2192">			} else if (message-&gt;FindInt32(&quot;scale&quot;, &amp;scale) == B_OK</a>
<a name="ln2193">				&amp;&amp; fViewState-&gt;ViewMode() == kIconMode) {</a>
<a name="ln2194">				if (scale == 0 &amp;&amp; (int32)IconSizeInt() != 32) {</a>
<a name="ln2195">					switch ((int32)IconSizeInt()) {</a>
<a name="ln2196">						case 40:</a>
<a name="ln2197">							fViewState-&gt;SetIconSize(32);</a>
<a name="ln2198">							break;</a>
<a name="ln2199"> </a>
<a name="ln2200">						case 48:</a>
<a name="ln2201">							fViewState-&gt;SetIconSize(40);</a>
<a name="ln2202">							break;</a>
<a name="ln2203"> </a>
<a name="ln2204">						case 64:</a>
<a name="ln2205">							fViewState-&gt;SetIconSize(48);</a>
<a name="ln2206">							break;</a>
<a name="ln2207"> </a>
<a name="ln2208">						case 96:</a>
<a name="ln2209">							fViewState-&gt;SetIconSize(64);</a>
<a name="ln2210">							break;</a>
<a name="ln2211"> </a>
<a name="ln2212">						case 128:</a>
<a name="ln2213">							fViewState-&gt;SetIconSize(96);</a>
<a name="ln2214">							break;</a>
<a name="ln2215">					}</a>
<a name="ln2216">				} else if (scale == 1 &amp;&amp; (int32)IconSizeInt() != 128) {</a>
<a name="ln2217">					switch ((int32)IconSizeInt()) {</a>
<a name="ln2218">						case 32:</a>
<a name="ln2219">							fViewState-&gt;SetIconSize(40);</a>
<a name="ln2220">							break;</a>
<a name="ln2221"> </a>
<a name="ln2222">						case 40:</a>
<a name="ln2223">							fViewState-&gt;SetIconSize(48);</a>
<a name="ln2224">							break;</a>
<a name="ln2225"> </a>
<a name="ln2226">						case 48:</a>
<a name="ln2227">							fViewState-&gt;SetIconSize(64);</a>
<a name="ln2228">							break;</a>
<a name="ln2229"> </a>
<a name="ln2230">						case 64:</a>
<a name="ln2231">							fViewState-&gt;SetIconSize(96);</a>
<a name="ln2232">							break;</a>
<a name="ln2233"> </a>
<a name="ln2234">						case 96:</a>
<a name="ln2235">							fViewState-&gt;SetIconSize(128);</a>
<a name="ln2236">							break;</a>
<a name="ln2237">					}</a>
<a name="ln2238">				}</a>
<a name="ln2239">			} else {</a>
<a name="ln2240">				int32 iconSize = fViewState-&gt;LastIconSize();</a>
<a name="ln2241">				if (iconSize &lt; 32 || iconSize &gt; 128) {</a>
<a name="ln2242">					// uninitialized last icon size?</a>
<a name="ln2243">					iconSize = 32;</a>
<a name="ln2244">				}</a>
<a name="ln2245">				fViewState-&gt;SetIconSize(iconSize);</a>
<a name="ln2246">			}</a>
<a name="ln2247">			SetViewMode(message-&gt;what);</a>
<a name="ln2248">			break;</a>
<a name="ln2249">		}</a>
<a name="ln2250"> </a>
<a name="ln2251">		case kListMode:</a>
<a name="ln2252">		case kMiniIconMode:</a>
<a name="ln2253">			SetViewMode(message-&gt;what);</a>
<a name="ln2254">			break;</a>
<a name="ln2255"> </a>
<a name="ln2256">		case kMsgMouseDragged:</a>
<a name="ln2257">			MouseDragged(message);</a>
<a name="ln2258">			break;</a>
<a name="ln2259"> </a>
<a name="ln2260">		case kMsgMouseLongDown:</a>
<a name="ln2261">			MouseLongDown(message);</a>
<a name="ln2262">			break;</a>
<a name="ln2263"> </a>
<a name="ln2264">		case B_MOUSE_IDLE:</a>
<a name="ln2265">			MouseIdle(message);</a>
<a name="ln2266">			break;</a>
<a name="ln2267"> </a>
<a name="ln2268">		case B_SELECT_ALL:</a>
<a name="ln2269">		{</a>
<a name="ln2270">			// Select widget if there is an active one</a>
<a name="ln2271">			BTextWidget* widget;</a>
<a name="ln2272">			if (ActivePose() &amp;&amp; ((widget = ActivePose()-&gt;ActiveWidget())) != 0)</a>
<a name="ln2273">				widget-&gt;SelectAll(this);</a>
<a name="ln2274">			else</a>
<a name="ln2275">				SelectAll();</a>
<a name="ln2276">			break;</a>
<a name="ln2277">		}</a>
<a name="ln2278"> </a>
<a name="ln2279">		case B_CUT:</a>
<a name="ln2280">		{</a>
<a name="ln2281">			Model* targetModel = TargetModel();</a>
<a name="ln2282">			if (targetModel != NULL) {</a>
<a name="ln2283">				FSClipboardAddPoses(targetModel-&gt;NodeRef(), fSelectionList,</a>
<a name="ln2284">					kMoveSelectionTo, true);</a>
<a name="ln2285">			}</a>
<a name="ln2286">			break;</a>
<a name="ln2287">		}</a>
<a name="ln2288"> </a>
<a name="ln2289">		case kCutMoreSelectionToClipboard:</a>
<a name="ln2290">		{</a>
<a name="ln2291">			Model* targetModel = TargetModel();</a>
<a name="ln2292">			if (targetModel != NULL) {</a>
<a name="ln2293">				FSClipboardAddPoses(targetModel-&gt;NodeRef(), fSelectionList,</a>
<a name="ln2294">					kMoveSelectionTo, false);</a>
<a name="ln2295">			}</a>
<a name="ln2296">			break;</a>
<a name="ln2297">		}</a>
<a name="ln2298"> </a>
<a name="ln2299">		case B_COPY:</a>
<a name="ln2300">		{</a>
<a name="ln2301">			Model* targetModel = TargetModel();</a>
<a name="ln2302">			if (targetModel != NULL) {</a>
<a name="ln2303">				FSClipboardAddPoses(targetModel-&gt;NodeRef(), fSelectionList,</a>
<a name="ln2304">					kCopySelectionTo, true);</a>
<a name="ln2305">			}</a>
<a name="ln2306">			break;</a>
<a name="ln2307">		}</a>
<a name="ln2308"> </a>
<a name="ln2309">		case kCopyMoreSelectionToClipboard:</a>
<a name="ln2310">		{</a>
<a name="ln2311">			Model* targetModel = TargetModel();</a>
<a name="ln2312">			if (targetModel != NULL) {</a>
<a name="ln2313">				FSClipboardAddPoses(targetModel-&gt;NodeRef(), fSelectionList,</a>
<a name="ln2314">					kCopySelectionTo, false);</a>
<a name="ln2315">			}</a>
<a name="ln2316">			break;</a>
<a name="ln2317">		}</a>
<a name="ln2318"> </a>
<a name="ln2319">		case B_PASTE:</a>
<a name="ln2320">			FSClipboardPaste(TargetModel());</a>
<a name="ln2321">			break;</a>
<a name="ln2322"> </a>
<a name="ln2323">		case kPasteLinksFromClipboard:</a>
<a name="ln2324">			FSClipboardPaste(TargetModel(), kCreateLink);</a>
<a name="ln2325">			break;</a>
<a name="ln2326"> </a>
<a name="ln2327">		case B_CANCEL:</a>
<a name="ln2328">			if (FSClipboardHasRefs())</a>
<a name="ln2329">				FSClipboardClear();</a>
<a name="ln2330">			else if (fFiltering)</a>
<a name="ln2331">				StopFiltering();</a>
<a name="ln2332">			break;</a>
<a name="ln2333"> </a>
<a name="ln2334">		case kCancelSelectionToClipboard:</a>
<a name="ln2335">		{</a>
<a name="ln2336">			Model* targetModel = TargetModel();</a>
<a name="ln2337">			if (targetModel != NULL) {</a>
<a name="ln2338">				FSClipboardRemovePoses(targetModel-&gt;NodeRef(),</a>
<a name="ln2339">					fSelectionList != NULL &amp;&amp; fSelectionList-&gt;CountItems() &gt; 0</a>
<a name="ln2340">						? fSelectionList : fPoseList);</a>
<a name="ln2341">			}</a>
<a name="ln2342">			break;</a>
<a name="ln2343">		}</a>
<a name="ln2344"> </a>
<a name="ln2345">		case kFSClipboardChanges:</a>
<a name="ln2346">		{</a>
<a name="ln2347">			node_ref node;</a>
<a name="ln2348">			message-&gt;FindInt32(&quot;device&quot;, &amp;node.device);</a>
<a name="ln2349">			message-&gt;FindInt64(&quot;directory&quot;, &amp;node.node);</a>
<a name="ln2350"> </a>
<a name="ln2351">			Model* targetModel = TargetModel();</a>
<a name="ln2352">			if (targetModel != NULL &amp;&amp; *targetModel-&gt;NodeRef() == node)</a>
<a name="ln2353">				UpdatePosesClipboardModeFromClipboard(message);</a>
<a name="ln2354">			else if (message-&gt;FindBool(&quot;clearClipboard&quot;)</a>
<a name="ln2355">				&amp;&amp; HasPosesInClipboard()) {</a>
<a name="ln2356">				// just remove all poses from clipboard</a>
<a name="ln2357">				SetHasPosesInClipboard(false);</a>
<a name="ln2358">				SetPosesClipboardMode(0);</a>
<a name="ln2359">			}</a>
<a name="ln2360">			break;</a>
<a name="ln2361">		}</a>
<a name="ln2362"> </a>
<a name="ln2363">		case kInvertSelection:</a>
<a name="ln2364">			InvertSelection();</a>
<a name="ln2365">			break;</a>
<a name="ln2366"> </a>
<a name="ln2367">		case kShowSelectionWindow:</a>
<a name="ln2368">			ShowSelectionWindow();</a>
<a name="ln2369">			break;</a>
<a name="ln2370"> </a>
<a name="ln2371">		case kDuplicateSelection:</a>
<a name="ln2372">			DuplicateSelection();</a>
<a name="ln2373">			break;</a>
<a name="ln2374"> </a>
<a name="ln2375">		case kOpenSelection:</a>
<a name="ln2376">			OpenSelection();</a>
<a name="ln2377">			break;</a>
<a name="ln2378"> </a>
<a name="ln2379">		case kOpenSelectionWith:</a>
<a name="ln2380">			OpenSelectionUsing();</a>
<a name="ln2381">			break;</a>
<a name="ln2382"> </a>
<a name="ln2383">		case kRestoreFromTrash:</a>
<a name="ln2384">			RestoreSelectionFromTrash();</a>
<a name="ln2385">			break;</a>
<a name="ln2386"> </a>
<a name="ln2387">		case kDelete:</a>
<a name="ln2388">			ExcludeTrashFromSelection();</a>
<a name="ln2389">			if (ContainerWindow()-&gt;IsTrash())</a>
<a name="ln2390">				// if trash delete instantly</a>
<a name="ln2391">				DeleteSelection(true, false);</a>
<a name="ln2392">			else</a>
<a name="ln2393">				DeleteSelection();</a>
<a name="ln2394">			break;</a>
<a name="ln2395"> </a>
<a name="ln2396">		case kMoveToTrash:</a>
<a name="ln2397">		{</a>
<a name="ln2398">			ExcludeTrashFromSelection();</a>
<a name="ln2399">			TrackerSettings settings;</a>
<a name="ln2400"> </a>
<a name="ln2401">			if ((modifiers() &amp; B_SHIFT_KEY) != 0</a>
<a name="ln2402">				|| settings.DontMoveFilesToTrash()) {</a>
<a name="ln2403">				DeleteSelection(true, settings.AskBeforeDeleteFile());</a>
<a name="ln2404">			} else</a>
<a name="ln2405">				MoveSelectionToTrash();</a>
<a name="ln2406"> </a>
<a name="ln2407">			break;</a>
<a name="ln2408">		}</a>
<a name="ln2409"> </a>
<a name="ln2410">		case kCleanupAll:</a>
<a name="ln2411">			Cleanup(true);</a>
<a name="ln2412">			break;</a>
<a name="ln2413"> </a>
<a name="ln2414">		case kCleanup:</a>
<a name="ln2415">			Cleanup();</a>
<a name="ln2416">			break;</a>
<a name="ln2417"> </a>
<a name="ln2418">		case kEditQuery:</a>
<a name="ln2419">			EditQueries();</a>
<a name="ln2420">			break;</a>
<a name="ln2421"> </a>
<a name="ln2422">		case kRunAutomounterSettings:</a>
<a name="ln2423">			be_app-&gt;PostMessage(message);</a>
<a name="ln2424">			break;</a>
<a name="ln2425"> </a>
<a name="ln2426">		case kNewEntryFromTemplate:</a>
<a name="ln2427">			if (message-&gt;HasRef(&quot;refs_template&quot;))</a>
<a name="ln2428">				NewFileFromTemplate(message);</a>
<a name="ln2429">			break;</a>
<a name="ln2430"> </a>
<a name="ln2431">		case kNewFolder:</a>
<a name="ln2432">			NewFolder(message);</a>
<a name="ln2433">			break;</a>
<a name="ln2434"> </a>
<a name="ln2435">		case kUnmountVolume:</a>
<a name="ln2436">			UnmountSelectedVolumes();</a>
<a name="ln2437">			break;</a>
<a name="ln2438"> </a>
<a name="ln2439">		case kEmptyTrash:</a>
<a name="ln2440">			FSEmptyTrash();</a>
<a name="ln2441">			break;</a>
<a name="ln2442"> </a>
<a name="ln2443">		case kGetInfo:</a>
<a name="ln2444">			OpenInfoWindows();</a>
<a name="ln2445">			break;</a>
<a name="ln2446"> </a>
<a name="ln2447">		case kIdentifyEntry:</a>
<a name="ln2448">		{</a>
<a name="ln2449">			bool force;</a>
<a name="ln2450">			if (message-&gt;FindBool(&quot;force&quot;, &amp;force) != B_OK)</a>
<a name="ln2451">				force = false;</a>
<a name="ln2452"> </a>
<a name="ln2453">			IdentifySelection(force);</a>
<a name="ln2454">			break;</a>
<a name="ln2455">		}</a>
<a name="ln2456"> </a>
<a name="ln2457">		case kEditItem:</a>
<a name="ln2458">		{</a>
<a name="ln2459">			if (ActivePose())</a>
<a name="ln2460">				break;</a>
<a name="ln2461"> </a>
<a name="ln2462">			BPose* pose = fSelectionList-&gt;FirstItem();</a>
<a name="ln2463">			if (pose != NULL) {</a>
<a name="ln2464">				BPoint where(0,</a>
<a name="ln2465">					CurrentPoseList()-&gt;IndexOf(pose) * fListElemHeight);</a>
<a name="ln2466">				pose-&gt;EditFirstWidget(where, this);</a>
<a name="ln2467">			}</a>
<a name="ln2468">			break;</a>
<a name="ln2469">		}</a>
<a name="ln2470"> </a>
<a name="ln2471">		case kOpenParentDir:</a>
<a name="ln2472">			OpenParent();</a>
<a name="ln2473">			break;</a>
<a name="ln2474"> </a>
<a name="ln2475">		case kCopyAttributes:</a>
<a name="ln2476">			if (be_clipboard-&gt;Lock()) {</a>
<a name="ln2477">				be_clipboard-&gt;Clear();</a>
<a name="ln2478">				BMessage* data = be_clipboard-&gt;Data();</a>
<a name="ln2479">				if (data != NULL) {</a>
<a name="ln2480">					// copy attributes to the clipboard</a>
<a name="ln2481">					BMessage state;</a>
<a name="ln2482">					SaveState(state);</a>
<a name="ln2483"> </a>
<a name="ln2484">					BMallocIO stream;</a>
<a name="ln2485">					ssize_t size;</a>
<a name="ln2486">					if (state.Flatten(&amp;stream, &amp;size) == B_OK) {</a>
<a name="ln2487">						data-&gt;AddData(&quot;application/tracker-columns&quot;,</a>
<a name="ln2488">							B_MIME_TYPE, stream.Buffer(), size);</a>
<a name="ln2489">						be_clipboard-&gt;Commit();</a>
<a name="ln2490">					}</a>
<a name="ln2491">				}</a>
<a name="ln2492">				be_clipboard-&gt;Unlock();</a>
<a name="ln2493">			}</a>
<a name="ln2494">			break;</a>
<a name="ln2495"> </a>
<a name="ln2496">		case kPasteAttributes:</a>
<a name="ln2497">			if (be_clipboard-&gt;Lock()) {</a>
<a name="ln2498">				BMessage* data = be_clipboard-&gt;Data();</a>
<a name="ln2499">				if (data != NULL) {</a>
<a name="ln2500">					// find the attributes in the clipboard</a>
<a name="ln2501">					const void* buffer;</a>
<a name="ln2502">					ssize_t size;</a>
<a name="ln2503">					if (data-&gt;FindData(&quot;application/tracker-columns&quot;,</a>
<a name="ln2504">							B_MIME_TYPE, &amp;buffer, &amp;size) == B_OK) {</a>
<a name="ln2505">						BMessage state;</a>
<a name="ln2506">						if (state.Unflatten((const char*)buffer) == B_OK) {</a>
<a name="ln2507">							// remove all current columns (one always stays)</a>
<a name="ln2508">							BColumn* old;</a>
<a name="ln2509">							while ((old = ColumnAt(0)) != NULL) {</a>
<a name="ln2510">								if (!RemoveColumn(old, false))</a>
<a name="ln2511">									break;</a>
<a name="ln2512">							}</a>
<a name="ln2513"> </a>
<a name="ln2514">							// add new columns</a>
<a name="ln2515">							for (int32 index = 0; ; index++) {</a>
<a name="ln2516">								BColumn* column</a>
<a name="ln2517">									= BColumn::InstantiateFromMessage(state,</a>
<a name="ln2518">										index);</a>
<a name="ln2519">								if (column == NULL)</a>
<a name="ln2520">									break;</a>
<a name="ln2521"> </a>
<a name="ln2522">								AddColumn(column);</a>
<a name="ln2523">							}</a>
<a name="ln2524"> </a>
<a name="ln2525">							// remove the last old one</a>
<a name="ln2526">							RemoveColumn(old, false);</a>
<a name="ln2527"> </a>
<a name="ln2528">							// set sorting mode</a>
<a name="ln2529">							BViewState* viewState</a>
<a name="ln2530">								= BViewState::InstantiateFromMessage(state);</a>
<a name="ln2531">							if (viewState != NULL) {</a>
<a name="ln2532">								SetPrimarySort(viewState-&gt;PrimarySort());</a>
<a name="ln2533">								SetSecondarySort(viewState-&gt;SecondarySort());</a>
<a name="ln2534">								SetReverseSort(viewState-&gt;ReverseSort());</a>
<a name="ln2535"> </a>
<a name="ln2536">								SortPoses();</a>
<a name="ln2537">								Invalidate();</a>
<a name="ln2538">							}</a>
<a name="ln2539">						}</a>
<a name="ln2540">					}</a>
<a name="ln2541">				}</a>
<a name="ln2542">				be_clipboard-&gt;Unlock();</a>
<a name="ln2543">			}</a>
<a name="ln2544">			break;</a>
<a name="ln2545"> </a>
<a name="ln2546">		case kArrangeBy:</a>
<a name="ln2547">		{</a>
<a name="ln2548">			uint32 attrHash;</a>
<a name="ln2549">			if (message-&gt;FindInt32(&quot;attr_hash&quot;, (int32*)&amp;attrHash) == B_OK) {</a>
<a name="ln2550">				if (ColumnFor(attrHash) == NULL)</a>
<a name="ln2551">					HandleAttrMenuItemSelected(message);</a>
<a name="ln2552"> </a>
<a name="ln2553">				if (PrimarySort() == attrHash)</a>
<a name="ln2554">					attrHash = 0;</a>
<a name="ln2555"> </a>
<a name="ln2556">				SetPrimarySort(attrHash);</a>
<a name="ln2557">				SetSecondarySort(0);</a>
<a name="ln2558">				Cleanup(true);</a>
<a name="ln2559">			}</a>
<a name="ln2560">			break;</a>
<a name="ln2561">		}</a>
<a name="ln2562"> </a>
<a name="ln2563">		case kArrangeReverseOrder:</a>
<a name="ln2564">			SetReverseSort(!fViewState-&gt;ReverseSort());</a>
<a name="ln2565">			Cleanup(true);</a>
<a name="ln2566">			break;</a>
<a name="ln2567"> </a>
<a name="ln2568">		case kAttributeItem:</a>
<a name="ln2569">			HandleAttrMenuItemSelected(message);</a>
<a name="ln2570">			break;</a>
<a name="ln2571"> </a>
<a name="ln2572">		case kAddPrinter:</a>
<a name="ln2573">			be_app-&gt;PostMessage(message);</a>
<a name="ln2574">			break;</a>
<a name="ln2575"> </a>
<a name="ln2576">		case kMakeActivePrinter:</a>
<a name="ln2577">			SetDefaultPrinter();</a>
<a name="ln2578">			break;</a>
<a name="ln2579"> </a>
<a name="ln2580">#if DEBUG</a>
<a name="ln2581">		case kTestIconCache:</a>
<a name="ln2582">			RunIconCacheTests();</a>
<a name="ln2583">			break;</a>
<a name="ln2584"> </a>
<a name="ln2585">		case 'dbug':</a>
<a name="ln2586">		{</a>
<a name="ln2587">			int32 count = fSelectionList-&gt;CountItems();</a>
<a name="ln2588">			for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln2589">				fSelectionList-&gt;ItemAt(index)-&gt;PrintToStream();</a>
<a name="ln2590"> </a>
<a name="ln2591">			break;</a>
<a name="ln2592">		}</a>
<a name="ln2593">#ifdef CHECK_OPEN_MODEL_LEAKS</a>
<a name="ln2594">		case 'dpfl':</a>
<a name="ln2595">			DumpOpenModels(false);</a>
<a name="ln2596">			break;</a>
<a name="ln2597"> </a>
<a name="ln2598">		case 'dpfL':</a>
<a name="ln2599">			DumpOpenModels(true);</a>
<a name="ln2600">			break;</a>
<a name="ln2601">#endif</a>
<a name="ln2602">#endif</a>
<a name="ln2603"> </a>
<a name="ln2604">		case kCheckTypeahead:</a>
<a name="ln2605">		{</a>
<a name="ln2606">			bigtime_t doubleClickSpeed;</a>
<a name="ln2607">			get_click_speed(&amp;doubleClickSpeed);</a>
<a name="ln2608">			if (system_time() - fLastKeyTime &gt; (doubleClickSpeed * 2)) {</a>
<a name="ln2609">				fCountView-&gt;SetTypeAhead(&quot;&quot;);</a>
<a name="ln2610">				delete fKeyRunner;</a>
<a name="ln2611">				fKeyRunner = NULL;</a>
<a name="ln2612">			}</a>
<a name="ln2613">			break;</a>
<a name="ln2614">		}</a>
<a name="ln2615"> </a>
<a name="ln2616">		case B_OBSERVER_NOTICE_CHANGE:</a>
<a name="ln2617">		{</a>
<a name="ln2618">			int32 observerWhat;</a>
<a name="ln2619">			if (message-&gt;FindInt32(&quot;be:observe_change_what&quot;, &amp;observerWhat)</a>
<a name="ln2620">					== B_OK) {</a>
<a name="ln2621">				switch (observerWhat) {</a>
<a name="ln2622">					case kDateFormatChanged:</a>
<a name="ln2623">						UpdateDateColumns(message);</a>
<a name="ln2624">						break;</a>
<a name="ln2625"> </a>
<a name="ln2626">					case kVolumesOnDesktopChanged:</a>
<a name="ln2627">						AdaptToVolumeChange(message);</a>
<a name="ln2628">						break;</a>
<a name="ln2629"> </a>
<a name="ln2630">					case kDesktopIntegrationChanged:</a>
<a name="ln2631">						AdaptToDesktopIntegrationChange(message);</a>
<a name="ln2632">						break;</a>
<a name="ln2633"> </a>
<a name="ln2634">					case kShowSelectionWhenInactiveChanged:</a>
<a name="ln2635">					{</a>
<a name="ln2636">						// Updating the settings here will propagate</a>
<a name="ln2637">						// setting changed from Tracker to all open</a>
<a name="ln2638">						// file panels as well</a>
<a name="ln2639">						bool showSelection;</a>
<a name="ln2640">						if (message-&gt;FindBool(&quot;ShowSelectionWhenInactive&quot;,</a>
<a name="ln2641">								&amp;showSelection) == B_OK) {</a>
<a name="ln2642">							fShowSelectionWhenInactive = showSelection;</a>
<a name="ln2643">							TrackerSettings().SetShowSelectionWhenInactive(</a>
<a name="ln2644">								fShowSelectionWhenInactive);</a>
<a name="ln2645">						}</a>
<a name="ln2646">						Invalidate();</a>
<a name="ln2647">						break;</a>
<a name="ln2648">					}</a>
<a name="ln2649"> </a>
<a name="ln2650">					case kTransparentSelectionChanged:</a>
<a name="ln2651">					{</a>
<a name="ln2652">						bool transparentSelection;</a>
<a name="ln2653">						if (message-&gt;FindBool(&quot;TransparentSelection&quot;,</a>
<a name="ln2654">								&amp;transparentSelection) == B_OK) {</a>
<a name="ln2655">							fTransparentSelection = transparentSelection;</a>
<a name="ln2656">							TrackerSettings().SetTransparentSelection(</a>
<a name="ln2657">								fTransparentSelection);</a>
<a name="ln2658">						}</a>
<a name="ln2659">						break;</a>
<a name="ln2660">					}</a>
<a name="ln2661"> </a>
<a name="ln2662">					case kSortFolderNamesFirstChanged:</a>
<a name="ln2663">						if (ViewMode() == kListMode) {</a>
<a name="ln2664">							TrackerSettings settings;</a>
<a name="ln2665">							bool sortFolderNamesFirst;</a>
<a name="ln2666">							if (message-&gt;FindBool(&quot;SortFolderNamesFirst&quot;,</a>
<a name="ln2667">								&amp;sortFolderNamesFirst) == B_OK) {</a>
<a name="ln2668">								settings.SetSortFolderNamesFirst(</a>
<a name="ln2669">									sortFolderNamesFirst);</a>
<a name="ln2670">							}</a>
<a name="ln2671">							NameAttributeText::SetSortFolderNamesFirst(</a>
<a name="ln2672">								settings.SortFolderNamesFirst());</a>
<a name="ln2673">							RealNameAttributeText::SetSortFolderNamesFirst(</a>
<a name="ln2674">								settings.SortFolderNamesFirst());</a>
<a name="ln2675">							SortPoses();</a>
<a name="ln2676">							Invalidate();</a>
<a name="ln2677">						}</a>
<a name="ln2678">						break;</a>
<a name="ln2679"> </a>
<a name="ln2680">					case kHideDotFilesChanged:</a>
<a name="ln2681">					{</a>
<a name="ln2682">						TrackerSettings settings;</a>
<a name="ln2683">						bool hideDotFiles;</a>
<a name="ln2684">						if (message-&gt;FindBool(&quot;HideDotFiles&quot;,</a>
<a name="ln2685">								&amp;hideDotFiles) == B_OK) {</a>
<a name="ln2686">							settings.SetHideDotFiles(hideDotFiles);</a>
<a name="ln2687">						}</a>
<a name="ln2688"> </a>
<a name="ln2689">						Refresh();</a>
<a name="ln2690">						break;</a>
<a name="ln2691">					}</a>
<a name="ln2692"> </a>
<a name="ln2693">					case kTypeAheadFilteringChanged:</a>
<a name="ln2694">					{</a>
<a name="ln2695">						TrackerSettings settings;</a>
<a name="ln2696">						bool typeAheadFiltering;</a>
<a name="ln2697">						if (message-&gt;FindBool(&quot;TypeAheadFiltering&quot;,</a>
<a name="ln2698">								&amp;typeAheadFiltering) == B_OK) {</a>
<a name="ln2699">							settings.SetTypeAheadFiltering(typeAheadFiltering);</a>
<a name="ln2700">						}</a>
<a name="ln2701"> </a>
<a name="ln2702">						if (fFiltering &amp;&amp; !typeAheadFiltering)</a>
<a name="ln2703">							StopFiltering();</a>
<a name="ln2704">						break;</a>
<a name="ln2705">					}</a>
<a name="ln2706">				}</a>
<a name="ln2707">			}</a>
<a name="ln2708">			break;</a>
<a name="ln2709">		}</a>
<a name="ln2710"> </a>
<a name="ln2711">		default:</a>
<a name="ln2712">			_inherited::MessageReceived(message);</a>
<a name="ln2713">			break;</a>
<a name="ln2714">	}</a>
<a name="ln2715">}</a>
<a name="ln2716"> </a>
<a name="ln2717"> </a>
<a name="ln2718">bool</a>
<a name="ln2719">BPoseView::RemoveColumn(BColumn* columnToRemove, bool runAlert)</a>
<a name="ln2720">{</a>
<a name="ln2721">	// make sure last column is not removed</a>
<a name="ln2722">	if (CountColumns() == 1) {</a>
<a name="ln2723">		if (runAlert) {</a>
<a name="ln2724">			BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln2725">				B_TRANSLATE(&quot;You must have at least one attribute showing.&quot;),</a>
<a name="ln2726">				B_TRANSLATE(&quot;Cancel&quot;), 0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln2727">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln2728">			alert-&gt;Go();</a>
<a name="ln2729">		}</a>
<a name="ln2730"> </a>
<a name="ln2731">		return false;</a>
<a name="ln2732">	}</a>
<a name="ln2733"> </a>
<a name="ln2734">	// column exists so remove it from list</a>
<a name="ln2735">	int32 columnIndex = IndexOfColumn(columnToRemove);</a>
<a name="ln2736">	float offset = columnToRemove-&gt;Offset();</a>
<a name="ln2737"> </a>
<a name="ln2738">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln2739">	for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln2740">		fPoseList-&gt;ItemAt(index)-&gt;RemoveWidget(this, columnToRemove);</a>
<a name="ln2741"> </a>
<a name="ln2742">	fColumnList-&gt;RemoveItem(columnToRemove, false);</a>
<a name="ln2743">	fTitleView-&gt;RemoveTitle(columnToRemove);</a>
<a name="ln2744"> </a>
<a name="ln2745">	float attrWidth = columnToRemove-&gt;Width();</a>
<a name="ln2746">	delete columnToRemove;</a>
<a name="ln2747"> </a>
<a name="ln2748">	count = CountColumns();</a>
<a name="ln2749">	for (int32 index = columnIndex; index &lt; count; index++) {</a>
<a name="ln2750">		BColumn* column = ColumnAt(index);</a>
<a name="ln2751">		column-&gt;SetOffset(column-&gt;Offset()</a>
<a name="ln2752">			- (attrWidth + kTitleColumnExtraMargin));</a>
<a name="ln2753">	}</a>
<a name="ln2754"> </a>
<a name="ln2755">	BRect rect(Bounds());</a>
<a name="ln2756">	rect.left = offset;</a>
<a name="ln2757">	Invalidate(rect);</a>
<a name="ln2758"> </a>
<a name="ln2759">	ContainerWindow()-&gt;MarkAttributeMenu();</a>
<a name="ln2760"> </a>
<a name="ln2761">	if (IsWatchingDateFormatChange()) {</a>
<a name="ln2762">		int32 columnCount = CountColumns();</a>
<a name="ln2763">		bool anyDateAttributesLeft = false;</a>
<a name="ln2764"> </a>
<a name="ln2765">		for (int32 i = 0; i &lt; columnCount; i++) {</a>
<a name="ln2766">			BColumn* column = ColumnAt(i);</a>
<a name="ln2767">			if (column-&gt;AttrType() == B_TIME_TYPE)</a>
<a name="ln2768">				anyDateAttributesLeft = true;</a>
<a name="ln2769"> </a>
<a name="ln2770">			if (anyDateAttributesLeft)</a>
<a name="ln2771">				break;</a>
<a name="ln2772">		}</a>
<a name="ln2773"> </a>
<a name="ln2774">		if (!anyDateAttributesLeft)</a>
<a name="ln2775">			StopWatchDateFormatChange();</a>
<a name="ln2776">	}</a>
<a name="ln2777"> </a>
<a name="ln2778">	fStateNeedsSaving = true;</a>
<a name="ln2779"> </a>
<a name="ln2780">	if (fFiltering) {</a>
<a name="ln2781">		// the column we removed might just be the one that was used to filter</a>
<a name="ln2782">		int32 count = fFilteredPoseList-&gt;CountItems();</a>
<a name="ln2783">		for (int32 i = count - 1; i &gt;= 0; i--) {</a>
<a name="ln2784">			BPose* pose = fFilteredPoseList-&gt;ItemAt(i);</a>
<a name="ln2785">			if (!FilterPose(pose))</a>
<a name="ln2786">				RemoveFilteredPose(pose, i);</a>
<a name="ln2787">		}</a>
<a name="ln2788">	}</a>
<a name="ln2789"> </a>
<a name="ln2790">	return true;</a>
<a name="ln2791">}</a>
<a name="ln2792"> </a>
<a name="ln2793"> </a>
<a name="ln2794">bool</a>
<a name="ln2795">BPoseView::AddColumn(BColumn* newColumn, const BColumn* after)</a>
<a name="ln2796">{</a>
<a name="ln2797">	if (after == NULL)</a>
<a name="ln2798">		after = LastColumn();</a>
<a name="ln2799"> </a>
<a name="ln2800">	// add new column after last column</a>
<a name="ln2801">	float offset;</a>
<a name="ln2802">	int32 afterColumnIndex;</a>
<a name="ln2803">	if (after != NULL) {</a>
<a name="ln2804">		offset = after-&gt;Offset() + after-&gt;Width() + kTitleColumnExtraMargin;</a>
<a name="ln2805">		afterColumnIndex = IndexOfColumn(after);</a>
<a name="ln2806">	} else {</a>
<a name="ln2807">		offset = StartOffset();</a>
<a name="ln2808">		afterColumnIndex = CountColumns() - 1;</a>
<a name="ln2809">	}</a>
<a name="ln2810"> </a>
<a name="ln2811">	// add the new column</a>
<a name="ln2812">	fColumnList-&gt;AddItem(newColumn, afterColumnIndex + 1);</a>
<a name="ln2813">	fTitleView-&gt;AddTitle(newColumn);</a>
<a name="ln2814"> </a>
<a name="ln2815">	BRect rect(Bounds());</a>
<a name="ln2816"> </a>
<a name="ln2817">	// add widget for all visible poses</a>
<a name="ln2818">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln2819">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln2820">	int32 startIndex = (int32)(rect.top / fListElemHeight);</a>
<a name="ln2821">	BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln2822"> </a>
<a name="ln2823">	for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln2824">		BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln2825">		if (pose-&gt;WidgetFor(newColumn-&gt;AttrHash()) == NULL)</a>
<a name="ln2826">			pose-&gt;AddWidget(this, newColumn);</a>
<a name="ln2827"> </a>
<a name="ln2828">		loc.y += fListElemHeight;</a>
<a name="ln2829">		if (loc.y &gt; rect.bottom)</a>
<a name="ln2830">			break;</a>
<a name="ln2831">	}</a>
<a name="ln2832"> </a>
<a name="ln2833">	// rearrange column titles to fit new column</a>
<a name="ln2834">	newColumn-&gt;SetOffset(offset);</a>
<a name="ln2835">	float attrWidth = newColumn-&gt;Width();</a>
<a name="ln2836"> </a>
<a name="ln2837">	count = CountColumns();</a>
<a name="ln2838">	for (int32 index = afterColumnIndex + 2; index &lt; count; index++) {</a>
<a name="ln2839">		BColumn* column = ColumnAt(index);</a>
<a name="ln2840">		ASSERT(newColumn != column);</a>
<a name="ln2841">		column-&gt;SetOffset(column-&gt;Offset() + (attrWidth</a>
<a name="ln2842">			+ kTitleColumnExtraMargin));</a>
<a name="ln2843">	}</a>
<a name="ln2844"> </a>
<a name="ln2845">	rect.left = offset;</a>
<a name="ln2846">	Invalidate(rect);</a>
<a name="ln2847">	ContainerWindow()-&gt;MarkAttributeMenu();</a>
<a name="ln2848"> </a>
<a name="ln2849">	// Check if this is a time attribute and if so,</a>
<a name="ln2850">	// start watching for changed in time/date format:</a>
<a name="ln2851">	if (!IsWatchingDateFormatChange() &amp;&amp; newColumn-&gt;AttrType() == B_TIME_TYPE)</a>
<a name="ln2852">		StartWatchDateFormatChange();</a>
<a name="ln2853"> </a>
<a name="ln2854">	fStateNeedsSaving =  true;</a>
<a name="ln2855"> </a>
<a name="ln2856">	if (fFiltering) {</a>
<a name="ln2857">		// the column we added might just add new poses to be showed</a>
<a name="ln2858">		fFilteredPoseList-&gt;MakeEmpty();</a>
<a name="ln2859">		fFiltering = false;</a>
<a name="ln2860">		StartFiltering();</a>
<a name="ln2861">	}</a>
<a name="ln2862"> </a>
<a name="ln2863">	return true;</a>
<a name="ln2864">}</a>
<a name="ln2865"> </a>
<a name="ln2866"> </a>
<a name="ln2867">void</a>
<a name="ln2868">BPoseView::HandleAttrMenuItemSelected(BMessage* message)</a>
<a name="ln2869">{</a>
<a name="ln2870">	// see if source was a menu item</a>
<a name="ln2871">	BMenuItem* item;</a>
<a name="ln2872">	if (message-&gt;FindPointer(&quot;source&quot;, (void**)&amp;item) != B_OK)</a>
<a name="ln2873">		item = NULL;</a>
<a name="ln2874"> </a>
<a name="ln2875">	// find out which column was selected</a>
<a name="ln2876">	uint32 attrHash;</a>
<a name="ln2877">	if (message-&gt;FindInt32(&quot;attr_hash&quot;, (int32*)&amp;attrHash) != B_OK)</a>
<a name="ln2878">		return;</a>
<a name="ln2879"> </a>
<a name="ln2880">	BColumn* column = ColumnFor(attrHash);</a>
<a name="ln2881">	if (column != NULL) {</a>
<a name="ln2882">		RemoveColumn(column, true);</a>
<a name="ln2883">		return;</a>
<a name="ln2884">	} else {</a>
<a name="ln2885">		// collect info about selected attribute</a>
<a name="ln2886">		const char* attrName;</a>
<a name="ln2887">		if (message-&gt;FindString(&quot;attr_name&quot;, &amp;attrName) != B_OK)</a>
<a name="ln2888">			return;</a>
<a name="ln2889"> </a>
<a name="ln2890">		uint32 attrType;</a>
<a name="ln2891">		if (message-&gt;FindInt32(&quot;attr_type&quot;, (int32*)&amp;attrType) != B_OK)</a>
<a name="ln2892">			return;</a>
<a name="ln2893"> </a>
<a name="ln2894">		float attrWidth;</a>
<a name="ln2895">		if (message-&gt;FindFloat(&quot;attr_width&quot;, &amp;attrWidth) != B_OK)</a>
<a name="ln2896">			return;</a>
<a name="ln2897"> </a>
<a name="ln2898">		alignment attrAlign;</a>
<a name="ln2899">		if (message-&gt;FindInt32(&quot;attr_align&quot;, (int32*)&amp;attrAlign) != B_OK)</a>
<a name="ln2900">			return;</a>
<a name="ln2901"> </a>
<a name="ln2902">		bool isEditable;</a>
<a name="ln2903">		if (message-&gt;FindBool(&quot;attr_editable&quot;, &amp;isEditable) != B_OK)</a>
<a name="ln2904">			return;</a>
<a name="ln2905"> </a>
<a name="ln2906">		bool isStatfield;</a>
<a name="ln2907">		if (message-&gt;FindBool(&quot;attr_statfield&quot;, &amp;isStatfield) != B_OK)</a>
<a name="ln2908">			return;</a>
<a name="ln2909"> </a>
<a name="ln2910">		const char* displayAs;</a>
<a name="ln2911">		message-&gt;FindString(&quot;attr_display_as&quot;, &amp;displayAs);</a>
<a name="ln2912"> </a>
<a name="ln2913">		column = new BColumn(item-&gt;Label(), 0, attrWidth, attrAlign,</a>
<a name="ln2914">			attrName, attrType, displayAs, isStatfield, isEditable);</a>
<a name="ln2915">		AddColumn(column);</a>
<a name="ln2916">		if (item-&gt;Menu()-&gt;Supermenu() == NULL)</a>
<a name="ln2917">			delete item-&gt;Menu();</a>
<a name="ln2918">	}</a>
<a name="ln2919">}</a>
<a name="ln2920"> </a>
<a name="ln2921"> </a>
<a name="ln2922">const int32 kSanePoseLocation = 50000;</a>
<a name="ln2923"> </a>
<a name="ln2924"> </a>
<a name="ln2925">void</a>
<a name="ln2926">BPoseView::ReadPoseInfo(Model* model, PoseInfo* poseInfo)</a>
<a name="ln2927">{</a>
<a name="ln2928">	BModelOpener opener(model);</a>
<a name="ln2929">	if (model-&gt;Node() == NULL)</a>
<a name="ln2930">		return;</a>
<a name="ln2931"> </a>
<a name="ln2932">	ReadAttrResult result = kReadAttrFailed;</a>
<a name="ln2933">	BEntry entry;</a>
<a name="ln2934">	model-&gt;GetEntry(&amp;entry);</a>
<a name="ln2935">	bool isTrash = model-&gt;IsTrash() &amp;&amp; IsDesktopView();</a>
<a name="ln2936"> </a>
<a name="ln2937">	// special case the &quot;root&quot; disks icon</a>
<a name="ln2938">	// as well as the trash on desktop</a>
<a name="ln2939">	if (model-&gt;IsRoot() || isTrash) {</a>
<a name="ln2940">		BDirectory dir;</a>
<a name="ln2941">		if (FSGetDeskDir(&amp;dir) == B_OK) {</a>
<a name="ln2942">			const char* poseInfoAttr = isTrash</a>
<a name="ln2943">				? kAttrTrashPoseInfo</a>
<a name="ln2944">				: kAttrDisksPoseInfo;</a>
<a name="ln2945">			const char* poseInfoAttrForeign = isTrash</a>
<a name="ln2946">				? kAttrTrashPoseInfoForeign</a>
<a name="ln2947">				: kAttrDisksPoseInfoForeign;</a>
<a name="ln2948">			result = ReadAttr(&amp;dir, poseInfoAttr, poseInfoAttrForeign,</a>
<a name="ln2949">				B_RAW_TYPE, 0, poseInfo, sizeof(*poseInfo),</a>
<a name="ln2950">				&amp;PoseInfo::EndianSwap);</a>
<a name="ln2951">		}</a>
<a name="ln2952">	} else {</a>
<a name="ln2953">		ASSERT(model-&gt;IsNodeOpen());</a>
<a name="ln2954">		time_t now = time(NULL);</a>
<a name="ln2955"> </a>
<a name="ln2956">		for (int32 count = 10; count &gt;= 0; count--) {</a>
<a name="ln2957">			if (model-&gt;Node() == NULL)</a>
<a name="ln2958">				break;</a>
<a name="ln2959"> </a>
<a name="ln2960">			result = ReadAttr(model-&gt;Node(), kAttrPoseInfo,</a>
<a name="ln2961">				kAttrPoseInfoForeign, B_RAW_TYPE, 0, poseInfo,</a>
<a name="ln2962">				sizeof(*poseInfo), &amp;PoseInfo::EndianSwap);</a>
<a name="ln2963"> </a>
<a name="ln2964">			if (result != kReadAttrFailed) {</a>
<a name="ln2965">				// got it, bail</a>
<a name="ln2966">				break;</a>
<a name="ln2967">			}</a>
<a name="ln2968"> </a>
<a name="ln2969">			// if we're in one of the icon modes and it's a newly created item</a>
<a name="ln2970">			// then we're going to retry a few times to see if we can get some</a>
<a name="ln2971">			// pose info to properly place the icon</a>
<a name="ln2972">			if (ViewMode() == kListMode)</a>
<a name="ln2973">				break;</a>
<a name="ln2974"> </a>
<a name="ln2975">			const StatStruct* stat = model-&gt;StatBuf();</a>
<a name="ln2976">			if (stat-&gt;st_crtime &lt; now - 5 || stat-&gt;st_crtime &gt; now)</a>
<a name="ln2977">				break;</a>
<a name="ln2978"> </a>
<a name="ln2979">			//PRINT((&quot;retrying to read pose info for %s, %d\n&quot;,</a>
<a name="ln2980">			//	model-&gt;Name(), count));</a>
<a name="ln2981"> </a>
<a name="ln2982">			snooze(10000);</a>
<a name="ln2983">		}</a>
<a name="ln2984">	}</a>
<a name="ln2985"> </a>
<a name="ln2986">	if (result == kReadAttrFailed) {</a>
<a name="ln2987">		poseInfo-&gt;fInitedDirectory = -1LL;</a>
<a name="ln2988">		poseInfo-&gt;fInvisible = false;</a>
<a name="ln2989">	} else if (TargetModel() == NULL</a>
<a name="ln2990">		|| (poseInfo-&gt;fInitedDirectory != model-&gt;EntryRef()-&gt;directory</a>
<a name="ln2991">			&amp;&amp; (poseInfo-&gt;fInitedDirectory</a>
<a name="ln2992">				!= TargetModel()-&gt;NodeRef()-&gt;node))) {</a>
<a name="ln2993">		// info was read properly but it's not for this directory</a>
<a name="ln2994">		poseInfo-&gt;fInitedDirectory = -1LL;</a>
<a name="ln2995">	} else if (poseInfo-&gt;fLocation.x &lt; -kSanePoseLocation</a>
<a name="ln2996">		|| poseInfo-&gt;fLocation.x &gt; kSanePoseLocation</a>
<a name="ln2997">		|| poseInfo-&gt;fLocation.y &lt; -kSanePoseLocation</a>
<a name="ln2998">		|| poseInfo-&gt;fLocation.y &gt; kSanePoseLocation) {</a>
<a name="ln2999">		// location values not realistic, probably screwed up, force reset</a>
<a name="ln3000">		poseInfo-&gt;fInitedDirectory = -1LL;</a>
<a name="ln3001">	}</a>
<a name="ln3002">}</a>
<a name="ln3003"> </a>
<a name="ln3004"> </a>
<a name="ln3005">ExtendedPoseInfo*</a>
<a name="ln3006">BPoseView::ReadExtendedPoseInfo(Model* model)</a>
<a name="ln3007">{</a>
<a name="ln3008">	BModelOpener opener(model);</a>
<a name="ln3009">	if (model-&gt;Node() == NULL)</a>
<a name="ln3010">		return NULL;</a>
<a name="ln3011"> </a>
<a name="ln3012">	ReadAttrResult result = kReadAttrFailed;</a>
<a name="ln3013"> </a>
<a name="ln3014">	const char* extendedPoseInfoAttrName;</a>
<a name="ln3015">	const char* extendedPoseInfoAttrForeignName;</a>
<a name="ln3016"> </a>
<a name="ln3017">	// special case the &quot;root&quot; disks icon</a>
<a name="ln3018">	if (model-&gt;IsRoot()) {</a>
<a name="ln3019">		BDirectory dir;</a>
<a name="ln3020">		if (FSGetDeskDir(&amp;dir) == B_OK) {</a>
<a name="ln3021">			extendedPoseInfoAttrName = kAttrExtendedDisksPoseInfo;</a>
<a name="ln3022">			extendedPoseInfoAttrForeignName = kAttrExtendedDisksPoseInfoForegin;</a>
<a name="ln3023">		} else</a>
<a name="ln3024">			return NULL;</a>
<a name="ln3025">	} else {</a>
<a name="ln3026">		extendedPoseInfoAttrName = kAttrExtendedPoseInfo;</a>
<a name="ln3027">		extendedPoseInfoAttrForeignName = kAttrExtendedPoseInfoForegin;</a>
<a name="ln3028">	}</a>
<a name="ln3029"> </a>
<a name="ln3030">	type_code type;</a>
<a name="ln3031">	size_t size;</a>
<a name="ln3032">	result = GetAttrInfo(model-&gt;Node(), extendedPoseInfoAttrName,</a>
<a name="ln3033">		extendedPoseInfoAttrForeignName, &amp;type, &amp;size);</a>
<a name="ln3034"> </a>
<a name="ln3035">	if (result == kReadAttrFailed)</a>
<a name="ln3036">		return NULL;</a>
<a name="ln3037"> </a>
<a name="ln3038">	char* buffer = new char[ExtendedPoseInfo::SizeWithHeadroom(size)];</a>
<a name="ln3039">	ExtendedPoseInfo* poseInfo = reinterpret_cast&lt;ExtendedPoseInfo*&gt;(buffer);</a>
<a name="ln3040">	result = ReadAttr(model-&gt;Node(), extendedPoseInfoAttrName,</a>
<a name="ln3041">		extendedPoseInfoAttrForeignName,</a>
<a name="ln3042">		B_RAW_TYPE, 0, buffer, size, &amp;ExtendedPoseInfo::EndianSwap);</a>
<a name="ln3043"> </a>
<a name="ln3044">	// check that read worked, and data is sane</a>
<a name="ln3045">	if (result == kReadAttrFailed</a>
<a name="ln3046">		|| size &gt; poseInfo-&gt;SizeWithHeadroom()</a>
<a name="ln3047">		|| size &lt; poseInfo-&gt;Size()) {</a>
<a name="ln3048">		delete[] buffer;</a>
<a name="ln3049">		return NULL;</a>
<a name="ln3050">	}</a>
<a name="ln3051"> </a>
<a name="ln3052">	return poseInfo;</a>
<a name="ln3053">}</a>
<a name="ln3054"> </a>
<a name="ln3055"> </a>
<a name="ln3056">void</a>
<a name="ln3057">BPoseView::SetViewMode(uint32 newMode)</a>
<a name="ln3058">{</a>
<a name="ln3059">	uint32 oldMode = ViewMode();</a>
<a name="ln3060">	uint32 lastIconSize = fViewState-&gt;LastIconSize();</a>
<a name="ln3061"> </a>
<a name="ln3062">	if (newMode == oldMode</a>
<a name="ln3063">		&amp;&amp; (newMode != kIconMode || lastIconSize == fViewState-&gt;IconSize())) {</a>
<a name="ln3064">		return;</a>
<a name="ln3065">	}</a>
<a name="ln3066"> </a>
<a name="ln3067">	ASSERT(!IsFilePanel());</a>
<a name="ln3068"> </a>
<a name="ln3069">	uint32 lastIconMode = fViewState-&gt;LastIconMode();</a>
<a name="ln3070">	if (newMode != kListMode) {</a>
<a name="ln3071">		fViewState-&gt;SetLastIconMode(newMode);</a>
<a name="ln3072">		if (oldMode == kIconMode)</a>
<a name="ln3073">			fViewState-&gt;SetLastIconSize(fViewState-&gt;IconSize());</a>
<a name="ln3074">	}</a>
<a name="ln3075"> </a>
<a name="ln3076">	fViewState-&gt;SetViewMode(newMode);</a>
<a name="ln3077"> </a>
<a name="ln3078">	// Try to lock the center of the pose view when scaling icons, but not</a>
<a name="ln3079">	// if we are the desktop.</a>
<a name="ln3080">	BPoint scaleOffset(0, 0);</a>
<a name="ln3081">	bool iconSizeChanged = newMode == kIconMode &amp;&amp; oldMode == kIconMode;</a>
<a name="ln3082">	if (!IsDesktopWindow() &amp;&amp; iconSizeChanged) {</a>
<a name="ln3083">		// definitely changing the icon size, so we will need to scroll</a>
<a name="ln3084">		BRect bounds(Bounds());</a>
<a name="ln3085">		BPoint center(bounds.LeftTop());</a>
<a name="ln3086">		center.x += bounds.Width() / 2.0;</a>
<a name="ln3087">		center.y += bounds.Height() / 2.0;</a>
<a name="ln3088">		// convert the center into &quot;unscaled icon placement&quot; space</a>
<a name="ln3089">		float oldScale = lastIconSize / 32.0;</a>
<a name="ln3090">		BPoint unscaledCenter(center.x / oldScale, center.y / oldScale);</a>
<a name="ln3091">		// get the new center in &quot;scaled icon placement&quot; place</a>
<a name="ln3092">		float newScale = fViewState-&gt;IconSize() / 32.0;</a>
<a name="ln3093">		BPoint newCenter(unscaledCenter.x * newScale,</a>
<a name="ln3094">			unscaledCenter.y * newScale);</a>
<a name="ln3095">		scaleOffset = newCenter - center;</a>
<a name="ln3096">	}</a>
<a name="ln3097"> </a>
<a name="ln3098">	// toggle view layout between listmode and non-listmode, if necessary</a>
<a name="ln3099">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln3100">	if (oldMode == kListMode) {</a>
<a name="ln3101">		if (fFiltering)</a>
<a name="ln3102">			ClearFilter();</a>
<a name="ln3103"> </a>
<a name="ln3104">		if (window != NULL)</a>
<a name="ln3105">			window-&gt;HideAttributeMenu();</a>
<a name="ln3106"> </a>
<a name="ln3107">		fTitleView-&gt;Hide();</a>
<a name="ln3108">	} else if (newMode == kListMode) {</a>
<a name="ln3109">		if (window != NULL)</a>
<a name="ln3110">			window-&gt;ShowAttributeMenu();</a>
<a name="ln3111"> </a>
<a name="ln3112">		fTitleView-&gt;Show();</a>
<a name="ln3113">	}</a>
<a name="ln3114"> </a>
<a name="ln3115">	CommitActivePose();</a>
<a name="ln3116">	SetIconPoseHeight();</a>
<a name="ln3117">	GetLayoutInfo(newMode, &amp;fGrid, &amp;fOffset);</a>
<a name="ln3118"> </a>
<a name="ln3119">	// see if we need to map icons into new mode</a>
<a name="ln3120">	bool mapIcons = false;</a>
<a name="ln3121">	if (fOkToMapIcons) {</a>
<a name="ln3122">		mapIcons = (newMode != kListMode) &amp;&amp; (newMode != lastIconMode</a>
<a name="ln3123">			|| fViewState-&gt;IconSize() != lastIconSize);</a>
<a name="ln3124">	}</a>
<a name="ln3125"> </a>
<a name="ln3126">	// check if we need to re-place poses when they are out of view</a>
<a name="ln3127">	bool checkLocations = IsDesktopWindow() &amp;&amp; iconSizeChanged;</a>
<a name="ln3128"> </a>
<a name="ln3129">	BPoint oldOffset;</a>
<a name="ln3130">	BPoint oldGrid;</a>
<a name="ln3131">	if (mapIcons)</a>
<a name="ln3132">		GetLayoutInfo(lastIconMode, &amp;oldGrid, &amp;oldOffset);</a>
<a name="ln3133"> </a>
<a name="ln3134">	BRect bounds(Bounds());</a>
<a name="ln3135">	PoseList newPoseList(30);</a>
<a name="ln3136"> </a>
<a name="ln3137">	if (newMode != kListMode) {</a>
<a name="ln3138">		int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln3139">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3140">			BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln3141">			if (pose-&gt;HasLocation() == false) {</a>
<a name="ln3142">				newPoseList.AddItem(pose);</a>
<a name="ln3143">			} else if (checkLocations &amp;&amp; !IsValidLocation(pose)) {</a>
<a name="ln3144">				// this icon has a location, but needs to be remapped, because</a>
<a name="ln3145">				// it is going out of view for example</a>
<a name="ln3146">				RemoveFromVSList(pose);</a>
<a name="ln3147">				newPoseList.AddItem(pose);</a>
<a name="ln3148">			} else if (iconSizeChanged) {</a>
<a name="ln3149">				// The pose location is still changed in view coordinates,</a>
<a name="ln3150">				// so it needs to be changed anyways!</a>
<a name="ln3151">				pose-&gt;SetSaveLocation();</a>
<a name="ln3152">			} else if (mapIcons) {</a>
<a name="ln3153">				MapToNewIconMode(pose, oldGrid, oldOffset);</a>
<a name="ln3154">			}</a>
<a name="ln3155">		}</a>
<a name="ln3156">	}</a>
<a name="ln3157"> </a>
<a name="ln3158">	// invalidate before anything else to avoid flickering, especially when</a>
<a name="ln3159">	// scrolling is also performed (invalidating before scrolling will cause</a>
<a name="ln3160">	// app_server to scroll silently, ie not visibly)</a>
<a name="ln3161">	Invalidate();</a>
<a name="ln3162"> </a>
<a name="ln3163">	// update origin in case of a list &lt;-&gt; icon mode transition</a>
<a name="ln3164">	BPoint newOrigin;</a>
<a name="ln3165">	if (newMode == kListMode)</a>
<a name="ln3166">		newOrigin = fViewState-&gt;ListOrigin();</a>
<a name="ln3167">	else</a>
<a name="ln3168">		newOrigin = fViewState-&gt;IconOrigin() + scaleOffset;</a>
<a name="ln3169"> </a>
<a name="ln3170">	PinPointToValidRange(newOrigin);</a>
<a name="ln3171"> </a>
<a name="ln3172">	DisableScrollBars();</a>
<a name="ln3173">	ScrollTo(newOrigin);</a>
<a name="ln3174"> </a>
<a name="ln3175">	// reset hint and arrange poses which DO NOT have a location yet</a>
<a name="ln3176">	ResetPosePlacementHint();</a>
<a name="ln3177">	int32 count = newPoseList.CountItems();</a>
<a name="ln3178">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3179">		BPose* pose = newPoseList.ItemAt(index);</a>
<a name="ln3180">		PlacePose(pose, bounds);</a>
<a name="ln3181">		AddToVSList(pose);</a>
<a name="ln3182">	}</a>
<a name="ln3183"> </a>
<a name="ln3184">	SortPoses();</a>
<a name="ln3185">	if (newMode != kListMode)</a>
<a name="ln3186">		RecalcExtent();</a>
<a name="ln3187"> </a>
<a name="ln3188">	UpdateScrollRange();</a>
<a name="ln3189">	SetScrollBarsTo(newOrigin);</a>
<a name="ln3190">	EnableScrollBars();</a>
<a name="ln3191">	ContainerWindow()-&gt;ViewModeChanged(oldMode, newMode);</a>
<a name="ln3192">}</a>
<a name="ln3193"> </a>
<a name="ln3194"> </a>
<a name="ln3195">void</a>
<a name="ln3196">BPoseView::MapToNewIconMode(BPose* pose, BPoint oldGrid, BPoint oldOffset)</a>
<a name="ln3197">{</a>
<a name="ln3198">	BPoint delta;</a>
<a name="ln3199">	BPoint poseLoc;</a>
<a name="ln3200"> </a>
<a name="ln3201">	poseLoc = PinToGrid(pose-&gt;Location(this), oldGrid, oldOffset);</a>
<a name="ln3202">	delta = pose-&gt;Location(this) - poseLoc;</a>
<a name="ln3203">	poseLoc -= oldOffset;</a>
<a name="ln3204"> </a>
<a name="ln3205">	if (poseLoc.x &gt;= 0)</a>
<a name="ln3206">		poseLoc.x = floorf(poseLoc.x / oldGrid.x) * fGrid.x;</a>
<a name="ln3207">	else</a>
<a name="ln3208">		poseLoc.x = ceilf(poseLoc.x / oldGrid.x) * fGrid.x;</a>
<a name="ln3209"> </a>
<a name="ln3210">	if (poseLoc.y &gt;= 0)</a>
<a name="ln3211">		poseLoc.y = floorf(poseLoc.y / oldGrid.y) * fGrid.y;</a>
<a name="ln3212">	else</a>
<a name="ln3213">		poseLoc.y = ceilf(poseLoc.y / oldGrid.y) * fGrid.y;</a>
<a name="ln3214"> </a>
<a name="ln3215">	if ((delta.x != 0) || (delta.y != 0)) {</a>
<a name="ln3216">		if (delta.x &gt;= 0)</a>
<a name="ln3217">			delta.x = fGrid.x * floorf(delta.x / oldGrid.x);</a>
<a name="ln3218">		else</a>
<a name="ln3219">			delta.x = fGrid.x * ceilf(delta.x / oldGrid.x);</a>
<a name="ln3220"> </a>
<a name="ln3221">		if (delta.y &gt;= 0)</a>
<a name="ln3222">			delta.y = fGrid.y * floorf(delta.y / oldGrid.y);</a>
<a name="ln3223">		else</a>
<a name="ln3224">			delta.y = fGrid.y * ceilf(delta.y / oldGrid.y);</a>
<a name="ln3225"> </a>
<a name="ln3226">		poseLoc += delta;</a>
<a name="ln3227">	}</a>
<a name="ln3228"> </a>
<a name="ln3229">	poseLoc += fOffset;</a>
<a name="ln3230">	pose-&gt;SetLocation(poseLoc, this);</a>
<a name="ln3231">	pose-&gt;SetSaveLocation();</a>
<a name="ln3232">}</a>
<a name="ln3233"> </a>
<a name="ln3234"> </a>
<a name="ln3235">void</a>
<a name="ln3236">BPoseView::SetPosesClipboardMode(uint32 clipboardMode)</a>
<a name="ln3237">{</a>
<a name="ln3238">	if (ViewMode() == kListMode) {</a>
<a name="ln3239">		PoseList* poseList = CurrentPoseList();</a>
<a name="ln3240">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln3241"> </a>
<a name="ln3242">		BPoint loc(0,0);</a>
<a name="ln3243">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3244">			BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln3245">			if (pose-&gt;ClipboardMode() != clipboardMode) {</a>
<a name="ln3246">				pose-&gt;SetClipboardMode(clipboardMode);</a>
<a name="ln3247">				Invalidate(pose-&gt;CalcRect(loc, this, false));</a>
<a name="ln3248">			}</a>
<a name="ln3249">			loc.y += fListElemHeight;</a>
<a name="ln3250">		}</a>
<a name="ln3251">	} else {</a>
<a name="ln3252">		int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln3253">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3254">			BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln3255">			if (pose-&gt;ClipboardMode() != clipboardMode) {</a>
<a name="ln3256">				pose-&gt;SetClipboardMode(clipboardMode);</a>
<a name="ln3257">				BRect poseRect(pose-&gt;CalcRect(this));</a>
<a name="ln3258">				Invalidate(poseRect);</a>
<a name="ln3259">			}</a>
<a name="ln3260">		}</a>
<a name="ln3261">	}</a>
<a name="ln3262">}</a>
<a name="ln3263"> </a>
<a name="ln3264"> </a>
<a name="ln3265">void</a>
<a name="ln3266">BPoseView::UpdatePosesClipboardModeFromClipboard(BMessage* clipboardReport)</a>
<a name="ln3267">{</a>
<a name="ln3268">	CommitActivePose();</a>
<a name="ln3269">	fSelectionPivotPose = NULL;</a>
<a name="ln3270">	fRealPivotPose = NULL;</a>
<a name="ln3271">	bool fullInvalidateNeeded = false;</a>
<a name="ln3272"> </a>
<a name="ln3273">	node_ref node;</a>
<a name="ln3274">	clipboardReport-&gt;FindInt32(&quot;device&quot;, &amp;node.device);</a>
<a name="ln3275">	clipboardReport-&gt;FindInt64(&quot;directory&quot;, &amp;node.node);</a>
<a name="ln3276"> </a>
<a name="ln3277">	bool clearClipboard = false;</a>
<a name="ln3278">	clipboardReport-&gt;FindBool(&quot;clearClipboard&quot;, &amp;clearClipboard);</a>
<a name="ln3279"> </a>
<a name="ln3280">	if (clearClipboard &amp;&amp; fHasPosesInClipboard) {</a>
<a name="ln3281">		// clear all poses</a>
<a name="ln3282">		int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln3283">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3284">			BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln3285">			pose-&gt;Select(false);</a>
<a name="ln3286">			pose-&gt;SetClipboardMode(0);</a>
<a name="ln3287">		}</a>
<a name="ln3288">		SetHasPosesInClipboard(false);</a>
<a name="ln3289">		fullInvalidateNeeded = true;</a>
<a name="ln3290">		fHasPosesInClipboard = false;</a>
<a name="ln3291">	}</a>
<a name="ln3292"> </a>
<a name="ln3293">	BRect bounds(Bounds());</a>
<a name="ln3294">	BPoint loc(0, 0);</a>
<a name="ln3295">	bool hasPosesInClipboard = false;</a>
<a name="ln3296">	int32 foundNodeIndex = 0;</a>
<a name="ln3297"> </a>
<a name="ln3298">	TClipboardNodeRef* clipNode = NULL;</a>
<a name="ln3299">	ssize_t size;</a>
<a name="ln3300">	for (int32 index = 0; clipboardReport-&gt;FindData(&quot;tcnode&quot;, T_CLIPBOARD_NODE,</a>
<a name="ln3301">			index, (const void**)&amp;clipNode, &amp;size) == B_OK; index++) {</a>
<a name="ln3302">		BPose* pose = fPoseList-&gt;FindPose(&amp;clipNode-&gt;node, &amp;foundNodeIndex);</a>
<a name="ln3303">		if (pose == NULL)</a>
<a name="ln3304">			continue;</a>
<a name="ln3305"> </a>
<a name="ln3306">		if (clipNode-&gt;moveMode != pose-&gt;ClipboardMode() || pose-&gt;IsSelected()) {</a>
<a name="ln3307">			pose-&gt;SetClipboardMode(clipNode-&gt;moveMode);</a>
<a name="ln3308">			pose-&gt;Select(false);</a>
<a name="ln3309"> </a>
<a name="ln3310">			if (!fullInvalidateNeeded) {</a>
<a name="ln3311">				if (ViewMode() == kListMode) {</a>
<a name="ln3312">					if (fFiltering) {</a>
<a name="ln3313">						pose = fFilteredPoseList-&gt;FindPose(&amp;clipNode-&gt;node,</a>
<a name="ln3314">							&amp;foundNodeIndex);</a>
<a name="ln3315">					}</a>
<a name="ln3316"> </a>
<a name="ln3317">					if (pose != NULL) {</a>
<a name="ln3318">						loc.y = foundNodeIndex * fListElemHeight;</a>
<a name="ln3319">						if (loc.y &lt;= bounds.bottom &amp;&amp; loc.y &gt;= bounds.top)</a>
<a name="ln3320">							Invalidate(pose-&gt;CalcRect(loc, this, false));</a>
<a name="ln3321">					}</a>
<a name="ln3322">				} else {</a>
<a name="ln3323">					BRect poseRect(pose-&gt;CalcRect(this));</a>
<a name="ln3324">					if (bounds.Contains(poseRect.LeftTop())</a>
<a name="ln3325">						|| bounds.Contains(poseRect.LeftBottom())</a>
<a name="ln3326">						|| bounds.Contains(poseRect.RightBottom())</a>
<a name="ln3327">						|| bounds.Contains(poseRect.RightTop())) {</a>
<a name="ln3328">						Invalidate(poseRect);</a>
<a name="ln3329">					}</a>
<a name="ln3330">				}</a>
<a name="ln3331">			}</a>
<a name="ln3332">			if (clipNode-&gt;moveMode)</a>
<a name="ln3333">				hasPosesInClipboard = true;</a>
<a name="ln3334">		}</a>
<a name="ln3335">	}</a>
<a name="ln3336"> </a>
<a name="ln3337">	fSelectionList-&gt;MakeEmpty();</a>
<a name="ln3338">	fMimeTypesInSelectionCache.MakeEmpty();</a>
<a name="ln3339"> </a>
<a name="ln3340">	SetHasPosesInClipboard(hasPosesInClipboard || fHasPosesInClipboard);</a>
<a name="ln3341"> </a>
<a name="ln3342">	if (fullInvalidateNeeded)</a>
<a name="ln3343">		Invalidate();</a>
<a name="ln3344">}</a>
<a name="ln3345"> </a>
<a name="ln3346"> </a>
<a name="ln3347">void</a>
<a name="ln3348">BPoseView::PlaceFolder(const entry_ref* ref, const BMessage* message)</a>
<a name="ln3349">{</a>
<a name="ln3350">	BNode node(ref);</a>
<a name="ln3351">	BPoint location;</a>
<a name="ln3352">	bool setPosition = false;</a>
<a name="ln3353"> </a>
<a name="ln3354">	if (message-&gt;FindPoint(&quot;be:invoke_origin&quot;, &amp;location) == B_OK) {</a>
<a name="ln3355">		// new folder created from popup, place on click point</a>
<a name="ln3356">		setPosition = true;</a>
<a name="ln3357">		location = ConvertFromScreen(location);</a>
<a name="ln3358">	} else if (ViewMode() != kListMode) {</a>
<a name="ln3359">		// new folder created by keyboard shortcut</a>
<a name="ln3360">		uint32 buttons;</a>
<a name="ln3361">		GetMouse(&amp;location, &amp;buttons);</a>
<a name="ln3362">		BPoint globalLocation(location);</a>
<a name="ln3363">		ConvertToScreen(&amp;globalLocation);</a>
<a name="ln3364">		// check if mouse over window</a>
<a name="ln3365">		if (Window()-&gt;Frame().Contains(globalLocation))</a>
<a name="ln3366">			// create folder under mouse</a>
<a name="ln3367">			setPosition = true;</a>
<a name="ln3368">	}</a>
<a name="ln3369"> </a>
<a name="ln3370">	if (setPosition) {</a>
<a name="ln3371">		Model* targetModel = TargetModel();</a>
<a name="ln3372">		if (targetModel != NULL &amp;&amp; targetModel-&gt;NodeRef() != NULL) {</a>
<a name="ln3373">			FSSetPoseLocation(targetModel-&gt;NodeRef()-&gt;node, &amp;node,</a>
<a name="ln3374">				location);</a>
<a name="ln3375">		}</a>
<a name="ln3376">	}</a>
<a name="ln3377">}</a>
<a name="ln3378"> </a>
<a name="ln3379"> </a>
<a name="ln3380">void</a>
<a name="ln3381">BPoseView::NewFileFromTemplate(const BMessage* message)</a>
<a name="ln3382">{</a>
<a name="ln3383">	Model* targetModel = TargetModel();</a>
<a name="ln3384">	ThrowOnAssert(targetModel != NULL);</a>
<a name="ln3385"> </a>
<a name="ln3386">	entry_ref destEntryRef;</a>
<a name="ln3387">	node_ref destNodeRef;</a>
<a name="ln3388"> </a>
<a name="ln3389">	BDirectory destDir(targetModel-&gt;NodeRef());</a>
<a name="ln3390">	if (destDir.InitCheck() != B_OK)</a>
<a name="ln3391">		return;</a>
<a name="ln3392"> </a>
<a name="ln3393">	// TODO: Localise this</a>
<a name="ln3394">	char fileName[B_FILE_NAME_LENGTH] = &quot;New &quot;;</a>
<a name="ln3395">	strlcat(fileName, message-&gt;FindString(&quot;name&quot;), sizeof(fileName));</a>
<a name="ln3396">	FSMakeOriginalName(fileName, &amp;destDir, &quot; copy&quot;);</a>
<a name="ln3397"> </a>
<a name="ln3398">	entry_ref srcRef;</a>
<a name="ln3399">	message-&gt;FindRef(&quot;refs_template&quot;, &amp;srcRef);</a>
<a name="ln3400"> </a>
<a name="ln3401">	BDirectory dir(&amp;srcRef);</a>
<a name="ln3402"> </a>
<a name="ln3403">	if (dir.InitCheck() == B_OK) {</a>
<a name="ln3404">		// special handling of directories</a>
<a name="ln3405">		if (FSCreateNewFolderIn(targetModel-&gt;NodeRef(), &amp;destEntryRef,</a>
<a name="ln3406">				&amp;destNodeRef) == B_OK) {</a>
<a name="ln3407">			BEntry destEntry(&amp;destEntryRef);</a>
<a name="ln3408">			destEntry.Rename(fileName);</a>
<a name="ln3409">		}</a>
<a name="ln3410">	} else {</a>
<a name="ln3411">		BFile srcFile(&amp;srcRef, B_READ_ONLY);</a>
<a name="ln3412">		BFile destFile(&amp;destDir, fileName, B_READ_WRITE | B_CREATE_FILE);</a>
<a name="ln3413"> </a>
<a name="ln3414">		// copy the data from the template file</a>
<a name="ln3415">		char* buffer = new char[1024];</a>
<a name="ln3416">		ssize_t result;</a>
<a name="ln3417">		do {</a>
<a name="ln3418">			result = srcFile.Read(buffer, 1024);</a>
<a name="ln3419"> </a>
<a name="ln3420">			if (result &gt; 0) {</a>
<a name="ln3421">				ssize_t written = destFile.Write(buffer, (size_t)result);</a>
<a name="ln3422">				if (written != result)</a>
<a name="ln3423">					result = written &lt; B_OK ? written : B_ERROR;</a>
<a name="ln3424">			}</a>
<a name="ln3425">		} while (result &gt; 0);</a>
<a name="ln3426">		delete[] buffer;</a>
<a name="ln3427">	}</a>
<a name="ln3428"> </a>
<a name="ln3429">	// todo: create an UndoItem</a>
<a name="ln3430"> </a>
<a name="ln3431">	// copy the attributes from the template file</a>
<a name="ln3432">	BNode srcNode(&amp;srcRef);</a>
<a name="ln3433">	BNode destNode(&amp;destDir, fileName);</a>
<a name="ln3434">	FSCopyAttributesAndStats(&amp;srcNode, &amp;destNode, false);</a>
<a name="ln3435"> </a>
<a name="ln3436">	BEntry entry(&amp;destDir, fileName);</a>
<a name="ln3437">	entry.GetRef(&amp;destEntryRef);</a>
<a name="ln3438"> </a>
<a name="ln3439">	// try to place new item at click point or under mouse if possible</a>
<a name="ln3440">	PlaceFolder(&amp;destEntryRef, message);</a>
<a name="ln3441"> </a>
<a name="ln3442">	// start renaming the entry</a>
<a name="ln3443">	int32 index;</a>
<a name="ln3444">	BPose* pose = EntryCreated(targetModel-&gt;NodeRef(), &amp;destNodeRef,</a>
<a name="ln3445">		destEntryRef.name, &amp;index);</a>
<a name="ln3446"> </a>
<a name="ln3447">	if (pose != NULL) {</a>
<a name="ln3448">		WatchNewNode(pose-&gt;TargetModel()-&gt;NodeRef());</a>
<a name="ln3449">		UpdateScrollRange();</a>
<a name="ln3450">		CommitActivePose();</a>
<a name="ln3451">		SelectPose(pose, index);</a>
<a name="ln3452">		pose-&gt;EditFirstWidget(BPoint(0, index * fListElemHeight), this);</a>
<a name="ln3453">	}</a>
<a name="ln3454">}</a>
<a name="ln3455"> </a>
<a name="ln3456"> </a>
<a name="ln3457">void</a>
<a name="ln3458">BPoseView::NewFolder(const BMessage* message)</a>
<a name="ln3459">{</a>
<a name="ln3460">	Model* targetModel = TargetModel();</a>
<a name="ln3461">	ThrowOnAssert(targetModel != NULL);</a>
<a name="ln3462"> </a>
<a name="ln3463">	entry_ref ref;</a>
<a name="ln3464">	node_ref nodeRef;</a>
<a name="ln3465"> </a>
<a name="ln3466">	if (FSCreateNewFolderIn(targetModel-&gt;NodeRef(), &amp;ref, &amp;nodeRef) == B_OK) {</a>
<a name="ln3467">		// try to place new folder at click point or under mouse if possible</a>
<a name="ln3468"> </a>
<a name="ln3469">		PlaceFolder(&amp;ref, message);</a>
<a name="ln3470"> </a>
<a name="ln3471">		int32 index;</a>
<a name="ln3472">		BPose* pose = EntryCreated(targetModel-&gt;NodeRef(), &amp;nodeRef, ref.name,</a>
<a name="ln3473">			&amp;index);</a>
<a name="ln3474"> </a>
<a name="ln3475">		if (fFiltering) {</a>
<a name="ln3476">			if (fFilteredPoseList-&gt;FindPose(&amp;nodeRef, &amp;index) == NULL) {</a>
<a name="ln3477">				float scrollBy = 0;</a>
<a name="ln3478">				BRect bounds = Bounds();</a>
<a name="ln3479">				AddPoseToList(fFilteredPoseList, true, true, pose, bounds,</a>
<a name="ln3480">					scrollBy, true, &amp;index);</a>
<a name="ln3481">			}</a>
<a name="ln3482">		}</a>
<a name="ln3483"> </a>
<a name="ln3484">		if (pose != NULL) {</a>
<a name="ln3485">			UpdateScrollRange();</a>
<a name="ln3486">			CommitActivePose();</a>
<a name="ln3487">			SelectPose(pose, index);</a>
<a name="ln3488">			pose-&gt;EditFirstWidget(BPoint(0, index * fListElemHeight), this);</a>
<a name="ln3489">		}</a>
<a name="ln3490">	}</a>
<a name="ln3491">}</a>
<a name="ln3492"> </a>
<a name="ln3493"> </a>
<a name="ln3494">void</a>
<a name="ln3495">BPoseView::Cleanup(bool doAll)</a>
<a name="ln3496">{</a>
<a name="ln3497">	if (ViewMode() == kListMode)</a>
<a name="ln3498">		return;</a>
<a name="ln3499"> </a>
<a name="ln3500">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln3501">	if (window == NULL)</a>
<a name="ln3502">		return;</a>
<a name="ln3503"> </a>
<a name="ln3504">	// replace all icons from the top</a>
<a name="ln3505">	if (doAll) {</a>
<a name="ln3506">		// sort by sort field</a>
<a name="ln3507">		SortPoses();</a>
<a name="ln3508"> </a>
<a name="ln3509">		DisableScrollBars();</a>
<a name="ln3510">		ClearExtent();</a>
<a name="ln3511">		ClearSelection();</a>
<a name="ln3512">		ScrollTo(B_ORIGIN);</a>
<a name="ln3513">		UpdateScrollRange();</a>
<a name="ln3514">		SetScrollBarsTo(B_ORIGIN);</a>
<a name="ln3515">		ResetPosePlacementHint();</a>
<a name="ln3516"> </a>
<a name="ln3517">		BRect viewBounds(Bounds());</a>
<a name="ln3518"> </a>
<a name="ln3519">		// relocate all poses in list (reset vs list)</a>
<a name="ln3520">		fVSPoseList-&gt;MakeEmpty();</a>
<a name="ln3521">		int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln3522">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3523">			BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln3524">			PlacePose(pose, viewBounds);</a>
<a name="ln3525">			AddToVSList(pose);</a>
<a name="ln3526">		}</a>
<a name="ln3527"> </a>
<a name="ln3528">		RecalcExtent();</a>
<a name="ln3529"> </a>
<a name="ln3530">		// scroll icons into view so that leftmost icon is &quot;fOffset&quot; from left</a>
<a name="ln3531">		UpdateScrollRange();</a>
<a name="ln3532">		EnableScrollBars();</a>
<a name="ln3533"> </a>
<a name="ln3534">		if (HScrollBar()) {</a>
<a name="ln3535">			float min;</a>
<a name="ln3536">			float max;</a>
<a name="ln3537">			HScrollBar()-&gt;GetRange(&amp;min, &amp;max);</a>
<a name="ln3538">			HScrollBar()-&gt;SetValue(min);</a>
<a name="ln3539">		}</a>
<a name="ln3540"> </a>
<a name="ln3541">		UpdateScrollRange();</a>
<a name="ln3542">		Invalidate(viewBounds);</a>
<a name="ln3543">	} else {</a>
<a name="ln3544">		// clean up items to nearest locations</a>
<a name="ln3545">		BRect viewBounds(Bounds());</a>
<a name="ln3546">		int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln3547">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3548">			BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln3549">			BPoint location(pose-&gt;Location(this));</a>
<a name="ln3550">			BPoint newLocation(PinToGrid(location, fGrid, fOffset));</a>
<a name="ln3551"> </a>
<a name="ln3552">			bool intersectsDesktopElements = !IsValidLocation(pose);</a>
<a name="ln3553"> </a>
<a name="ln3554">			// do we need to move pose to a grid location?</a>
<a name="ln3555">			if (newLocation != location || intersectsDesktopElements) {</a>
<a name="ln3556">				// remove pose from VSlist so it doesn't &quot;bump&quot; into itself</a>
<a name="ln3557">				RemoveFromVSList(pose);</a>
<a name="ln3558"> </a>
<a name="ln3559">				// try new grid location</a>
<a name="ln3560">				BRect oldBounds(pose-&gt;CalcRect(this));</a>
<a name="ln3561">				BRect poseBounds(oldBounds);</a>
<a name="ln3562">				pose-&gt;MoveTo(newLocation, this);</a>
<a name="ln3563">				if (SlotOccupied(oldBounds, viewBounds)</a>
<a name="ln3564">					|| intersectsDesktopElements) {</a>
<a name="ln3565">					ResetPosePlacementHint();</a>
<a name="ln3566">					PlacePose(pose, viewBounds);</a>
<a name="ln3567">					poseBounds = pose-&gt;CalcRect(this);</a>
<a name="ln3568">				}</a>
<a name="ln3569"> </a>
<a name="ln3570">				AddToVSList(pose);</a>
<a name="ln3571">				AddToExtent(poseBounds);</a>
<a name="ln3572"> </a>
<a name="ln3573"> 				if (viewBounds.Intersects(poseBounds))</a>
<a name="ln3574">					Invalidate(poseBounds);</a>
<a name="ln3575"> 				if (viewBounds.Intersects(oldBounds))</a>
<a name="ln3576">					Invalidate(oldBounds);</a>
<a name="ln3577">			}</a>
<a name="ln3578">		}</a>
<a name="ln3579">	}</a>
<a name="ln3580">}</a>
<a name="ln3581"> </a>
<a name="ln3582"> </a>
<a name="ln3583">void</a>
<a name="ln3584">BPoseView::PlacePose(BPose* pose, BRect &amp;viewBounds)</a>
<a name="ln3585">{</a>
<a name="ln3586">	// move pose to probable location</a>
<a name="ln3587">	pose-&gt;SetLocation(fHintLocation, this);</a>
<a name="ln3588">	BRect rect(pose-&gt;CalcRect(this));</a>
<a name="ln3589">	BPoint deltaFromBounds(fHintLocation - rect.LeftTop());</a>
<a name="ln3590"> </a>
<a name="ln3591">	// make pose rect a little bigger to ensure space between poses</a>
<a name="ln3592">	rect.InsetBy(-3, 0);</a>
<a name="ln3593"> </a>
<a name="ln3594">	bool checkValidLocation = IsDesktopWindow();</a>
<a name="ln3595"> </a>
<a name="ln3596">	// find an empty slot to put pose into</a>
<a name="ln3597">	while (SlotOccupied(rect, viewBounds)</a>
<a name="ln3598">		// check good location on the desktop</a>
<a name="ln3599">		|| (checkValidLocation &amp;&amp; !IsValidLocation(rect))) {</a>
<a name="ln3600">		NextSlot(pose, rect, viewBounds);</a>
<a name="ln3601">		// we've scanned the entire desktop without finding an available</a>
<a name="ln3602">		// position, give up and simply place it towards the top left.</a>
<a name="ln3603">		if (checkValidLocation &amp;&amp; !rect.Intersects(viewBounds)) {</a>
<a name="ln3604">			fHintLocation = PinToGrid(BPoint(0.0, 0.0), fGrid, fOffset);</a>
<a name="ln3605">			pose-&gt;SetLocation(fHintLocation, this);</a>
<a name="ln3606">			rect = pose-&gt;CalcRect(this);</a>
<a name="ln3607">			break;</a>
<a name="ln3608">		}</a>
<a name="ln3609">	}</a>
<a name="ln3610"> </a>
<a name="ln3611">	rect.InsetBy(3, 0);</a>
<a name="ln3612"> </a>
<a name="ln3613">	fHintLocation = pose-&gt;Location(this) + BPoint(fGrid.x, 0);</a>
<a name="ln3614"> </a>
<a name="ln3615">	pose-&gt;SetLocation(rect.LeftTop() + deltaFromBounds, this);</a>
<a name="ln3616">	pose-&gt;SetSaveLocation();</a>
<a name="ln3617">}</a>
<a name="ln3618"> </a>
<a name="ln3619"> </a>
<a name="ln3620">bool</a>
<a name="ln3621">BPoseView::IsValidLocation(const BPose* pose)</a>
<a name="ln3622">{</a>
<a name="ln3623">	if (!IsDesktopWindow())</a>
<a name="ln3624">		return true;</a>
<a name="ln3625"> </a>
<a name="ln3626">	BRect rect(pose-&gt;CalcRect(this));</a>
<a name="ln3627">	rect.InsetBy(-3, 0);</a>
<a name="ln3628">	return IsValidLocation(rect);</a>
<a name="ln3629">}</a>
<a name="ln3630"> </a>
<a name="ln3631"> </a>
<a name="ln3632">bool</a>
<a name="ln3633">BPoseView::IsValidLocation(const BRect&amp; rect)</a>
<a name="ln3634">{</a>
<a name="ln3635">	if (!IsDesktopWindow())</a>
<a name="ln3636">		return true;</a>
<a name="ln3637"> </a>
<a name="ln3638">	// on the desktop, don't allow icons outside of the view bounds</a>
<a name="ln3639">	if (!Bounds().Contains(rect))</a>
<a name="ln3640">		return false;</a>
<a name="ln3641"> </a>
<a name="ln3642">	// also check the deskbar frame</a>
<a name="ln3643">	BRect deskbarFrame;</a>
<a name="ln3644">	if (GetDeskbarFrame(&amp;deskbarFrame) == B_OK) {</a>
<a name="ln3645">		deskbarFrame.InsetBy(-10, -10);</a>
<a name="ln3646">		if (deskbarFrame.Intersects(rect))</a>
<a name="ln3647">			return false;</a>
<a name="ln3648">	}</a>
<a name="ln3649"> </a>
<a name="ln3650">	// check replicants</a>
<a name="ln3651">	for (int32 i = 0; BView* child = ChildAt(i); i++) {</a>
<a name="ln3652">		BRect childFrame = child-&gt;Frame();</a>
<a name="ln3653">		childFrame.InsetBy(-5, -5);</a>
<a name="ln3654">		if (childFrame.Intersects(rect))</a>
<a name="ln3655">			return false;</a>
<a name="ln3656">	}</a>
<a name="ln3657"> </a>
<a name="ln3658">	// location is ok</a>
<a name="ln3659">	return true;</a>
<a name="ln3660">}</a>
<a name="ln3661"> </a>
<a name="ln3662"> </a>
<a name="ln3663">status_t</a>
<a name="ln3664">BPoseView::GetDeskbarFrame(BRect* frame)</a>
<a name="ln3665">{</a>
<a name="ln3666">	// only really check the Deskbar frame every half a second,</a>
<a name="ln3667">	// use a cached value otherwise</a>
<a name="ln3668">	status_t result = B_OK;</a>
<a name="ln3669">	bigtime_t now = system_time();</a>
<a name="ln3670">	if (fLastDeskbarFrameCheckTime + 500000 &lt; now) {</a>
<a name="ln3671">		// it's time to check the Deskbar frame again</a>
<a name="ln3672">		result = get_deskbar_frame(&amp;fDeskbarFrame);</a>
<a name="ln3673">		fLastDeskbarFrameCheckTime = now;</a>
<a name="ln3674">	}</a>
<a name="ln3675">	*frame = fDeskbarFrame;</a>
<a name="ln3676"> </a>
<a name="ln3677">	return result;</a>
<a name="ln3678">}</a>
<a name="ln3679"> </a>
<a name="ln3680"> </a>
<a name="ln3681">void</a>
<a name="ln3682">BPoseView::CheckAutoPlacedPoses()</a>
<a name="ln3683">{</a>
<a name="ln3684">	if (ViewMode() == kListMode)</a>
<a name="ln3685">		return;</a>
<a name="ln3686"> </a>
<a name="ln3687">	BRect viewBounds(Bounds());</a>
<a name="ln3688"> </a>
<a name="ln3689">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln3690">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3691">		BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln3692">		if (pose-&gt;WasAutoPlaced()) {</a>
<a name="ln3693">			RemoveFromVSList(pose);</a>
<a name="ln3694">			fHintLocation = pose-&gt;Location(this);</a>
<a name="ln3695">			BRect oldBounds(pose-&gt;CalcRect(this));</a>
<a name="ln3696">			PlacePose(pose, viewBounds);</a>
<a name="ln3697"> </a>
<a name="ln3698">			BRect newBounds(pose-&gt;CalcRect(this));</a>
<a name="ln3699">			AddToVSList(pose);</a>
<a name="ln3700">			pose-&gt;SetAutoPlaced(false);</a>
<a name="ln3701">			AddToExtent(newBounds);</a>
<a name="ln3702"> </a>
<a name="ln3703">			Invalidate(oldBounds);</a>
<a name="ln3704">			Invalidate(newBounds);</a>
<a name="ln3705">		}</a>
<a name="ln3706">	}</a>
<a name="ln3707">}</a>
<a name="ln3708"> </a>
<a name="ln3709"> </a>
<a name="ln3710">void</a>
<a name="ln3711">BPoseView::CheckPoseVisibility(BRect* newFrame)</a>
<a name="ln3712">{</a>
<a name="ln3713">	bool desktop = IsDesktopWindow() &amp;&amp; newFrame != 0;</a>
<a name="ln3714"> </a>
<a name="ln3715">	BRect deskFrame;</a>
<a name="ln3716">	if (desktop) {</a>
<a name="ln3717">		ASSERT(newFrame);</a>
<a name="ln3718">		deskFrame = *newFrame;</a>
<a name="ln3719">	}</a>
<a name="ln3720"> </a>
<a name="ln3721">	ASSERT(ViewMode() != kListMode);</a>
<a name="ln3722"> </a>
<a name="ln3723">	BRect bounds(Bounds());</a>
<a name="ln3724">	bounds.InsetBy(20, 20);</a>
<a name="ln3725"> </a>
<a name="ln3726">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln3727">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln3728">		BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln3729">		BPoint newLocation(pose-&gt;Location(this));</a>
<a name="ln3730">		bool locationNeedsUpdating = false;</a>
<a name="ln3731"> </a>
<a name="ln3732">		if (desktop) {</a>
<a name="ln3733">			// we just switched screen resolution, pick up the right</a>
<a name="ln3734">			// icon locations for the new resolution</a>
<a name="ln3735">			Model* model = pose-&gt;TargetModel();</a>
<a name="ln3736">			ExtendedPoseInfo* info = ReadExtendedPoseInfo(model);</a>
<a name="ln3737">			if (info &amp;&amp; info-&gt;HasLocationForFrame(deskFrame)) {</a>
<a name="ln3738">				BPoint locationForFrame = info-&gt;LocationForFrame(deskFrame);</a>
<a name="ln3739">				if (locationForFrame != newLocation) {</a>
<a name="ln3740">					// found one and it is different from the current</a>
<a name="ln3741">					newLocation = locationForFrame;</a>
<a name="ln3742">					locationNeedsUpdating = true;</a>
<a name="ln3743">					Invalidate(pose-&gt;CalcRect(this));</a>
<a name="ln3744">						// make sure the old icon gets erased</a>
<a name="ln3745">					RemoveFromVSList(pose);</a>
<a name="ln3746">					pose-&gt;SetLocation(newLocation, this);</a>
<a name="ln3747">						// set the new location</a>
<a name="ln3748">				}</a>
<a name="ln3749">			}</a>
<a name="ln3750">			delete[] (char*)info;</a>
<a name="ln3751">				// TODO: fix up this mess</a>
<a name="ln3752">		}</a>
<a name="ln3753"> </a>
<a name="ln3754">		BRect rect(pose-&gt;CalcRect(this));</a>
<a name="ln3755">		if (!rect.Intersects(bounds)) {</a>
<a name="ln3756">			// pose doesn't fit on screen</a>
<a name="ln3757">			if (!locationNeedsUpdating) {</a>
<a name="ln3758">				// didn't already invalidate and remove in the desktop case</a>
<a name="ln3759">				Invalidate(rect);</a>
<a name="ln3760">				RemoveFromVSList(pose);</a>
<a name="ln3761">			}</a>
<a name="ln3762">			BPoint loc(pose-&gt;Location(this));</a>
<a name="ln3763">			loc.ConstrainTo(bounds);</a>
<a name="ln3764">				// place it onscreen</a>
<a name="ln3765"> </a>
<a name="ln3766">			pose-&gt;SetLocation(loc, this);</a>
<a name="ln3767">				// set the new location</a>
<a name="ln3768">			locationNeedsUpdating = true;</a>
<a name="ln3769">		}</a>
<a name="ln3770"> </a>
<a name="ln3771">		if (locationNeedsUpdating) {</a>
<a name="ln3772">			// pose got reposition by one or both of the above</a>
<a name="ln3773">			pose-&gt;SetSaveLocation();</a>
<a name="ln3774">			AddToVSList(pose);</a>
<a name="ln3775">				// add it at the new location</a>
<a name="ln3776">			Invalidate(pose-&gt;CalcRect(this));</a>
<a name="ln3777">				// make sure the new pose location updates properly</a>
<a name="ln3778">		}</a>
<a name="ln3779">	}</a>
<a name="ln3780">}</a>
<a name="ln3781"> </a>
<a name="ln3782"> </a>
<a name="ln3783">bool</a>
<a name="ln3784">BPoseView::SlotOccupied(BRect poseRect, BRect viewBounds) const</a>
<a name="ln3785">{</a>
<a name="ln3786">	if (fVSPoseList-&gt;IsEmpty())</a>
<a name="ln3787">		return false;</a>
<a name="ln3788"> </a>
<a name="ln3789">	// ## be sure to keep this code in sync with calls to NextSlot</a>
<a name="ln3790">	// ## in terms of the comparison of fHintLocation and PinToGrid</a>
<a name="ln3791">	if (poseRect.right &gt;= viewBounds.right) {</a>
<a name="ln3792">		BPoint point(viewBounds.left + fOffset.x, 0);</a>
<a name="ln3793">		point = PinToGrid(point, fGrid, fOffset);</a>
<a name="ln3794">		if (fHintLocation.x != point.x)</a>
<a name="ln3795">			return true;</a>
<a name="ln3796">	}</a>
<a name="ln3797"> </a>
<a name="ln3798">	// search only nearby poses (vertically)</a>
<a name="ln3799">	int32 index = FirstIndexAtOrBelow((int32)(poseRect.top - IconPoseHeight()));</a>
<a name="ln3800">	int32 numPoses = fVSPoseList-&gt;CountItems();</a>
<a name="ln3801"> </a>
<a name="ln3802">	while (index &lt; numPoses &amp;&amp; fVSPoseList-&gt;ItemAt(index)-&gt;Location(this).y</a>
<a name="ln3803">			&lt; poseRect.bottom) {</a>
<a name="ln3804">		BRect rect(fVSPoseList-&gt;ItemAt(index)-&gt;CalcRect(this));</a>
<a name="ln3805">		if (poseRect.Intersects(rect))</a>
<a name="ln3806">			return true;</a>
<a name="ln3807"> </a>
<a name="ln3808">		index++;</a>
<a name="ln3809">	}</a>
<a name="ln3810"> </a>
<a name="ln3811">	return false;</a>
<a name="ln3812">}</a>
<a name="ln3813"> </a>
<a name="ln3814"> </a>
<a name="ln3815">void</a>
<a name="ln3816">BPoseView::NextSlot(BPose* pose, BRect &amp;poseRect, BRect viewBounds)</a>
<a name="ln3817">{</a>
<a name="ln3818">	// move to next slot</a>
<a name="ln3819">	poseRect.OffsetBy(fGrid.x, 0);</a>
<a name="ln3820"> </a>
<a name="ln3821">	// if we reached the end of row go down to next row</a>
<a name="ln3822">	if (poseRect.right &gt; viewBounds.right) {</a>
<a name="ln3823">		fHintLocation.y += fGrid.y;</a>
<a name="ln3824">		fHintLocation.x = viewBounds.left + fOffset.x;</a>
<a name="ln3825">		fHintLocation = PinToGrid(fHintLocation, fGrid, fOffset);</a>
<a name="ln3826">		pose-&gt;SetLocation(fHintLocation, this);</a>
<a name="ln3827">		poseRect = pose-&gt;CalcRect(this);</a>
<a name="ln3828">		poseRect.InsetBy(-3, 0);</a>
<a name="ln3829">	}</a>
<a name="ln3830">}</a>
<a name="ln3831"> </a>
<a name="ln3832"> </a>
<a name="ln3833">int32</a>
<a name="ln3834">BPoseView::FirstIndexAtOrBelow(int32 y, bool constrainIndex) const</a>
<a name="ln3835">{</a>
<a name="ln3836">// This method performs a binary search on the vertically sorted pose list</a>
<a name="ln3837">// and returns either the index of the first pose at a given y location or</a>
<a name="ln3838">// the proper index to insert a new pose into the list.</a>
<a name="ln3839"> </a>
<a name="ln3840">	int32 index = 0;</a>
<a name="ln3841">	int32 l = 0;</a>
<a name="ln3842">	int32 r = fVSPoseList-&gt;CountItems() - 1;</a>
<a name="ln3843"> </a>
<a name="ln3844">	while (l &lt;= r) {</a>
<a name="ln3845">		index = (l + r) &gt;&gt; 1;</a>
<a name="ln3846">		int32 result</a>
<a name="ln3847">			= (int32)(y - fVSPoseList-&gt;ItemAt(index)-&gt;Location(this).y);</a>
<a name="ln3848"> </a>
<a name="ln3849">		if (result &lt; 0)</a>
<a name="ln3850">			r = index - 1;</a>
<a name="ln3851">		else if (result &gt; 0)</a>
<a name="ln3852">			l = index + 1;</a>
<a name="ln3853">		else {</a>
<a name="ln3854">			// compare turned out equal, find first pose</a>
<a name="ln3855">			while (index &gt; 0</a>
<a name="ln3856">				&amp;&amp; y == fVSPoseList-&gt;ItemAt(index - 1)-&gt;Location(this).y)</a>
<a name="ln3857">				index--;</a>
<a name="ln3858">			return index;</a>
<a name="ln3859">		}</a>
<a name="ln3860">	}</a>
<a name="ln3861"> </a>
<a name="ln3862">	// didn't find pose AT location y - bump index to proper insert point</a>
<a name="ln3863">	while (index &lt; fVSPoseList-&gt;CountItems()</a>
<a name="ln3864">		&amp;&amp; fVSPoseList-&gt;ItemAt(index)-&gt;Location(this).y &lt;= y) {</a>
<a name="ln3865">		index++;</a>
<a name="ln3866">	}</a>
<a name="ln3867"> </a>
<a name="ln3868">	// if flag is true then constrain index to legal value since this</a>
<a name="ln3869">	// method returns the proper insertion point which could be outside</a>
<a name="ln3870">	// the current bounds of the list</a>
<a name="ln3871">	if (constrainIndex &amp;&amp; index &gt;= fVSPoseList-&gt;CountItems())</a>
<a name="ln3872">		index = fVSPoseList-&gt;CountItems() - 1;</a>
<a name="ln3873"> </a>
<a name="ln3874">	return index;</a>
<a name="ln3875">}</a>
<a name="ln3876"> </a>
<a name="ln3877"> </a>
<a name="ln3878">void</a>
<a name="ln3879">BPoseView::AddToVSList(BPose* pose)</a>
<a name="ln3880">{</a>
<a name="ln3881">	int32 index = FirstIndexAtOrBelow((int32)pose-&gt;Location(this).y, false);</a>
<a name="ln3882">	fVSPoseList-&gt;AddItem(pose, index);</a>
<a name="ln3883">}</a>
<a name="ln3884"> </a>
<a name="ln3885"> </a>
<a name="ln3886">int32</a>
<a name="ln3887">BPoseView::RemoveFromVSList(const BPose* pose)</a>
<a name="ln3888">{</a>
<a name="ln3889">	//int32 index = FirstIndexAtOrBelow((int32)pose-&gt;Location(this).y);</a>
<a name="ln3890">		// This optimisation is buggy and the index returned can be greater</a>
<a name="ln3891">		// than the actual index of the pose we search, thus missing it</a>
<a name="ln3892">		// and failing to remove it. This having severe implications</a>
<a name="ln3893">		// everywhere in the code as it is asserted that it must be always</a>
<a name="ln3894">		// in sync with fPoseList. See ticket #4322.</a>
<a name="ln3895">	int32 index = 0;</a>
<a name="ln3896"> </a>
<a name="ln3897">	int32 count = fVSPoseList-&gt;CountItems();</a>
<a name="ln3898">	for (; index &lt; count; index++) {</a>
<a name="ln3899">		BPose* matchingPose = fVSPoseList-&gt;ItemAt(index);</a>
<a name="ln3900">		ASSERT(matchingPose);</a>
<a name="ln3901">		if (!matchingPose)</a>
<a name="ln3902">			return -1;</a>
<a name="ln3903"> </a>
<a name="ln3904">		if (pose == matchingPose) {</a>
<a name="ln3905">			fVSPoseList-&gt;RemoveItemAt(index);</a>
<a name="ln3906">			return index;</a>
<a name="ln3907">		}</a>
<a name="ln3908">	}</a>
<a name="ln3909"> </a>
<a name="ln3910">	return -1;</a>
<a name="ln3911">}</a>
<a name="ln3912"> </a>
<a name="ln3913"> </a>
<a name="ln3914">BPoint</a>
<a name="ln3915">BPoseView::PinToGrid(BPoint point, BPoint grid, BPoint offset) const</a>
<a name="ln3916">{</a>
<a name="ln3917">	if (grid.x == 0 || grid.y == 0)</a>
<a name="ln3918">		return point;</a>
<a name="ln3919"> </a>
<a name="ln3920">	point -= offset;</a>
<a name="ln3921">	BPoint	gridLoc(point);</a>
<a name="ln3922"> </a>
<a name="ln3923">	if (point.x &gt;= 0)</a>
<a name="ln3924">		gridLoc.x = floorf((point.x / grid.x) + 0.5f) * grid.x;</a>
<a name="ln3925">	else</a>
<a name="ln3926">		gridLoc.x = ceilf((point.x / grid.x) - 0.5f) * grid.x;</a>
<a name="ln3927"> </a>
<a name="ln3928">	if (point.y &gt;= 0)</a>
<a name="ln3929">		gridLoc.y = floorf((point.y / grid.y) + 0.5f) * grid.y;</a>
<a name="ln3930">	else</a>
<a name="ln3931">		gridLoc.y = ceilf((point.y / grid.y) - 0.5f) * grid.y;</a>
<a name="ln3932"> </a>
<a name="ln3933">	gridLoc += offset;</a>
<a name="ln3934"> </a>
<a name="ln3935">	return gridLoc;</a>
<a name="ln3936">}</a>
<a name="ln3937"> </a>
<a name="ln3938"> </a>
<a name="ln3939">void</a>
<a name="ln3940">BPoseView::ResetPosePlacementHint()</a>
<a name="ln3941">{</a>
<a name="ln3942">	fHintLocation = PinToGrid(BPoint(LeftTop().x + fOffset.x,</a>
<a name="ln3943">		LeftTop().y + fOffset.y), fGrid, fOffset);</a>
<a name="ln3944">}</a>
<a name="ln3945"> </a>
<a name="ln3946"> </a>
<a name="ln3947">void</a>
<a name="ln3948">BPoseView::SelectPoses(int32 start, int32 end)</a>
<a name="ln3949">{</a>
<a name="ln3950">	// clear selection list</a>
<a name="ln3951">	fSelectionList-&gt;MakeEmpty();</a>
<a name="ln3952">	fMimeTypesInSelectionCache.MakeEmpty();</a>
<a name="ln3953">	fSelectionPivotPose = NULL;</a>
<a name="ln3954">	fRealPivotPose = NULL;</a>
<a name="ln3955"> </a>
<a name="ln3956">	bool iconMode = ViewMode() != kListMode;</a>
<a name="ln3957">	BPoint loc(0, start * fListElemHeight);</a>
<a name="ln3958">	BRect bounds(Bounds());</a>
<a name="ln3959"> </a>
<a name="ln3960">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln3961">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln3962">	for (int32 index = start; index &lt; end &amp;&amp; index &lt; count; index++) {</a>
<a name="ln3963">		BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln3964">		fSelectionList-&gt;AddItem(pose);</a>
<a name="ln3965">		if (index == start)</a>
<a name="ln3966">			fSelectionPivotPose = pose;</a>
<a name="ln3967">		if (!pose-&gt;IsSelected()) {</a>
<a name="ln3968">			pose-&gt;Select(true);</a>
<a name="ln3969">			BRect poseRect;</a>
<a name="ln3970">			if (iconMode)</a>
<a name="ln3971">				poseRect = pose-&gt;CalcRect(this);</a>
<a name="ln3972">			else</a>
<a name="ln3973">				poseRect = pose-&gt;CalcRect(loc, this, false);</a>
<a name="ln3974"> </a>
<a name="ln3975">			if (bounds.Intersects(poseRect)) {</a>
<a name="ln3976">				Invalidate(poseRect);</a>
<a name="ln3977">			}</a>
<a name="ln3978">		}</a>
<a name="ln3979"> </a>
<a name="ln3980">		loc.y += fListElemHeight;</a>
<a name="ln3981">	}</a>
<a name="ln3982">}</a>
<a name="ln3983"> </a>
<a name="ln3984"> </a>
<a name="ln3985">void</a>
<a name="ln3986">BPoseView::MoveOrChangePoseSelection(int32 to)</a>
<a name="ln3987">{</a>
<a name="ln3988">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln3989">	BPose* first = fSelectionList-&gt;FirstItem();</a>
<a name="ln3990"> </a>
<a name="ln3991">	if (first != NULL &amp;&amp; fMultipleSelection</a>
<a name="ln3992">		&amp;&amp; (modifiers() &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln3993">		// Extend selection</a>
<a name="ln3994">		BPose* target = poseList-&gt;ItemAt(to);</a>
<a name="ln3995">		BPose* last = fSelectionList-&gt;LastItem();</a>
<a name="ln3996">		int32 firstIndex = poseList-&gt;IndexOf(first);</a>
<a name="ln3997">		int32 lastIndex = poseList-&gt;IndexOf(last);</a>
<a name="ln3998"> </a>
<a name="ln3999">		int32 from = to &lt; firstIndex ? firstIndex : lastIndex;</a>
<a name="ln4000">		int32 step = from &lt; to ? 1 : -1;</a>
<a name="ln4001"> </a>
<a name="ln4002">		// TODO: shrink selection depending on anchor</a>
<a name="ln4003">		bool select = true;</a>
<a name="ln4004"> </a>
<a name="ln4005">		for (int32 index = from; step &gt; 0 ? index &lt;= to : index &gt;= to;</a>
<a name="ln4006">				index += step) {</a>
<a name="ln4007">			BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln4008">			if (pose != NULL &amp;&amp; pose-&gt;IsSelected() != select)</a>
<a name="ln4009">				AddRemovePoseFromSelection(pose, index, select);</a>
<a name="ln4010">		}</a>
<a name="ln4011">		if (target != NULL)</a>
<a name="ln4012">			ScrollIntoView(target, to);</a>
<a name="ln4013">	} else {</a>
<a name="ln4014">		SelectPose(poseList-&gt;ItemAt(to), to);</a>
<a name="ln4015">	}</a>
<a name="ln4016">}</a>
<a name="ln4017"> </a>
<a name="ln4018"> </a>
<a name="ln4019">void</a>
<a name="ln4020">BPoseView::ScrollIntoView(BPose* pose, int32 index)</a>
<a name="ln4021">{</a>
<a name="ln4022">	ScrollIntoView(CalcPoseRect(pose, index, true));</a>
<a name="ln4023">}</a>
<a name="ln4024"> </a>
<a name="ln4025"> </a>
<a name="ln4026">void</a>
<a name="ln4027">BPoseView::ScrollIntoView(BRect poseRect)</a>
<a name="ln4028">{</a>
<a name="ln4029">	if (IsDesktopWindow())</a>
<a name="ln4030">		return;</a>
<a name="ln4031"> </a>
<a name="ln4032">	if (ViewMode() == kListMode) {</a>
<a name="ln4033">		// if we're in list view then we only care that the entire</a>
<a name="ln4034">		// pose is visible vertically, not horizontally</a>
<a name="ln4035">		poseRect.left = 0;</a>
<a name="ln4036">		poseRect.right = poseRect.left + 1;</a>
<a name="ln4037">	}</a>
<a name="ln4038"> </a>
<a name="ln4039">	if (!Bounds().Contains(poseRect))</a>
<a name="ln4040">		SetScrollBarsTo(poseRect.LeftTop());</a>
<a name="ln4041">}</a>
<a name="ln4042"> </a>
<a name="ln4043"> </a>
<a name="ln4044">void</a>
<a name="ln4045">BPoseView::SelectPose(BPose* pose, int32 index, bool scrollIntoView)</a>
<a name="ln4046">{</a>
<a name="ln4047">	if (pose == NULL || fSelectionList-&gt;CountItems() &gt; 1 || !pose-&gt;IsSelected())</a>
<a name="ln4048">		ClearSelection();</a>
<a name="ln4049"> </a>
<a name="ln4050">	AddPoseToSelection(pose, index, scrollIntoView);</a>
<a name="ln4051"> </a>
<a name="ln4052">	if (pose != NULL)</a>
<a name="ln4053">		fSelectionPivotPose = pose;</a>
<a name="ln4054">}</a>
<a name="ln4055"> </a>
<a name="ln4056"> </a>
<a name="ln4057">void</a>
<a name="ln4058">BPoseView::AddPoseToSelection(BPose* pose, int32 index, bool scrollIntoView)</a>
<a name="ln4059">{</a>
<a name="ln4060">	// TODO: need to check if pose is member of selection list</a>
<a name="ln4061">	if (pose != NULL &amp;&amp; !pose-&gt;IsSelected()) {</a>
<a name="ln4062">		pose-&gt;Select(true);</a>
<a name="ln4063">		fSelectionList-&gt;AddItem(pose);</a>
<a name="ln4064"> </a>
<a name="ln4065">		BRect poseRect = CalcPoseRect(pose, index);</a>
<a name="ln4066">		Invalidate(poseRect);</a>
<a name="ln4067"> </a>
<a name="ln4068">		if (scrollIntoView)</a>
<a name="ln4069">			ScrollIntoView(poseRect);</a>
<a name="ln4070"> </a>
<a name="ln4071">		if (fSelectionChangedHook)</a>
<a name="ln4072">			ContainerWindow()-&gt;SelectionChanged();</a>
<a name="ln4073">	}</a>
<a name="ln4074">}</a>
<a name="ln4075"> </a>
<a name="ln4076"> </a>
<a name="ln4077">void</a>
<a name="ln4078">BPoseView::RemovePoseFromSelection(BPose* pose)</a>
<a name="ln4079">{</a>
<a name="ln4080">	if (fSelectionPivotPose == pose)</a>
<a name="ln4081">		fSelectionPivotPose = NULL;</a>
<a name="ln4082"> </a>
<a name="ln4083">	if (fRealPivotPose == pose)</a>
<a name="ln4084">		fRealPivotPose = NULL;</a>
<a name="ln4085"> </a>
<a name="ln4086">	if (!fSelectionList-&gt;RemoveItem(pose)) {</a>
<a name="ln4087">		// wasn't selected to begin with</a>
<a name="ln4088">		return;</a>
<a name="ln4089">	}</a>
<a name="ln4090"> </a>
<a name="ln4091">	pose-&gt;Select(false);</a>
<a name="ln4092">	if (ViewMode() == kListMode) {</a>
<a name="ln4093">		// TODO: need a simple call to CalcRect that works both in listView and</a>
<a name="ln4094">		// icon view modes without the need for an index/pos</a>
<a name="ln4095">		PoseList* poseList = CurrentPoseList();</a>
<a name="ln4096">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln4097">		BPoint loc(0, 0);</a>
<a name="ln4098">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln4099">			if (pose == poseList-&gt;ItemAt(index)) {</a>
<a name="ln4100">				Invalidate(pose-&gt;CalcRect(loc, this));</a>
<a name="ln4101">				break;</a>
<a name="ln4102">			}</a>
<a name="ln4103">			loc.y += fListElemHeight;</a>
<a name="ln4104">		}</a>
<a name="ln4105">	} else</a>
<a name="ln4106">		Invalidate(pose-&gt;CalcRect(this));</a>
<a name="ln4107"> </a>
<a name="ln4108">	if (fSelectionChangedHook)</a>
<a name="ln4109">		ContainerWindow()-&gt;SelectionChanged();</a>
<a name="ln4110">}</a>
<a name="ln4111"> </a>
<a name="ln4112"> </a>
<a name="ln4113">bool</a>
<a name="ln4114">BPoseView::EachItemInDraggedSelection(const BMessage* message,</a>
<a name="ln4115">	bool (*func)(BPose*, BPoseView*, void*), BPoseView* poseView,</a>
<a name="ln4116">	void* passThru)</a>
<a name="ln4117">{</a>
<a name="ln4118">	BContainerWindow* srcWindow;</a>
<a name="ln4119">	if (message-&gt;FindPointer(&quot;src_window&quot;, (void**)&amp;srcWindow) != B_OK)</a>
<a name="ln4120">		return false;</a>
<a name="ln4121"> </a>
<a name="ln4122">	AutoLock&lt;BWindow&gt; lock(srcWindow);</a>
<a name="ln4123">	if (!lock)</a>
<a name="ln4124">		return false;</a>
<a name="ln4125"> </a>
<a name="ln4126">	PoseList* selectionList = srcWindow-&gt;PoseView()-&gt;SelectionList();</a>
<a name="ln4127">	int32 count = selectionList-&gt;CountItems();</a>
<a name="ln4128"> </a>
<a name="ln4129">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln4130">		BPose* pose = selectionList-&gt;ItemAt(index);</a>
<a name="ln4131">		if (func(pose, poseView, passThru))</a>
<a name="ln4132">			// early iteration termination</a>
<a name="ln4133">			return true;</a>
<a name="ln4134">	}</a>
<a name="ln4135"> </a>
<a name="ln4136">	return false;</a>
<a name="ln4137">}</a>
<a name="ln4138"> </a>
<a name="ln4139"> </a>
<a name="ln4140">static bool</a>
<a name="ln4141">ContainsOne(BString* string, const char* matchString)</a>
<a name="ln4142">{</a>
<a name="ln4143">	return strcmp(string-&gt;String(), matchString) == 0;</a>
<a name="ln4144">}</a>
<a name="ln4145"> </a>
<a name="ln4146"> </a>
<a name="ln4147">bool</a>
<a name="ln4148">BPoseView::FindDragNDropAction(const BMessage* dragMessage, bool &amp;canCopy,</a>
<a name="ln4149">	bool &amp;canMove, bool &amp;canLink, bool &amp;canErase)</a>
<a name="ln4150">{</a>
<a name="ln4151">	canCopy = false;</a>
<a name="ln4152">	canMove = false;</a>
<a name="ln4153">	canErase = false;</a>
<a name="ln4154">	canLink = false;</a>
<a name="ln4155">	if (!dragMessage-&gt;HasInt32(&quot;be:actions&quot;))</a>
<a name="ln4156">		return false;</a>
<a name="ln4157"> </a>
<a name="ln4158">	int32 action;</a>
<a name="ln4159">	for (int32 index = 0;</a>
<a name="ln4160">			dragMessage-&gt;FindInt32(&quot;be:actions&quot;, index, &amp;action) == B_OK;</a>
<a name="ln4161">			index++) {</a>
<a name="ln4162">		switch (action) {</a>
<a name="ln4163">			case B_MOVE_TARGET:</a>
<a name="ln4164">				canMove = true;</a>
<a name="ln4165">				break;</a>
<a name="ln4166"> </a>
<a name="ln4167">			case B_COPY_TARGET:</a>
<a name="ln4168">				canCopy = true;</a>
<a name="ln4169">				break;</a>
<a name="ln4170"> </a>
<a name="ln4171">			case B_TRASH_TARGET:</a>
<a name="ln4172">				canErase = true;</a>
<a name="ln4173">				break;</a>
<a name="ln4174"> </a>
<a name="ln4175">			case B_LINK_TARGET:</a>
<a name="ln4176">				canLink = true;</a>
<a name="ln4177">				break;</a>
<a name="ln4178">		}</a>
<a name="ln4179">	}</a>
<a name="ln4180"> </a>
<a name="ln4181">	return canCopy || canMove || canErase || canLink;</a>
<a name="ln4182">}</a>
<a name="ln4183"> </a>
<a name="ln4184"> </a>
<a name="ln4185">bool</a>
<a name="ln4186">BPoseView::CanTrashForeignDrag(const Model* targetModel)</a>
<a name="ln4187">{</a>
<a name="ln4188">	return targetModel-&gt;IsTrash();</a>
<a name="ln4189">}</a>
<a name="ln4190"> </a>
<a name="ln4191"> </a>
<a name="ln4192">bool</a>
<a name="ln4193">BPoseView::CanCopyOrMoveForeignDrag(const Model* targetModel,</a>
<a name="ln4194">	const BMessage* dragMessage)</a>
<a name="ln4195">{</a>
<a name="ln4196">	if (!targetModel-&gt;IsDirectory())</a>
<a name="ln4197">		return false;</a>
<a name="ln4198"> </a>
<a name="ln4199">	// in order to handle a clipping file, the drag initiator must be able</a>
<a name="ln4200">	// do deal with B_FILE_MIME_TYPE</a>
<a name="ln4201">	for (int32 index = 0; ; index++) {</a>
<a name="ln4202">		const char* type;</a>
<a name="ln4203">		if (dragMessage-&gt;FindString(&quot;be:types&quot;, index, &amp;type) != B_OK)</a>
<a name="ln4204">			break;</a>
<a name="ln4205"> </a>
<a name="ln4206">		if (strcasecmp(type, B_FILE_MIME_TYPE) == 0)</a>
<a name="ln4207">			return true;</a>
<a name="ln4208">	}</a>
<a name="ln4209"> </a>
<a name="ln4210">	return false;</a>
<a name="ln4211">}</a>
<a name="ln4212"> </a>
<a name="ln4213"> </a>
<a name="ln4214">bool</a>
<a name="ln4215">BPoseView::CanHandleDragSelection(const Model* target,</a>
<a name="ln4216">	const BMessage* dragMessage, bool ignoreTypes)</a>
<a name="ln4217">{</a>
<a name="ln4218">	if (ignoreTypes)</a>
<a name="ln4219">		return target-&gt;IsDropTarget();</a>
<a name="ln4220"> </a>
<a name="ln4221">	ASSERT(dragMessage != NULL);</a>
<a name="ln4222"> </a>
<a name="ln4223">	BContainerWindow* srcWindow;</a>
<a name="ln4224">	status_t result = dragMessage-&gt;FindPointer(&quot;src_window&quot;, (void**)&amp;srcWindow);</a>
<a name="ln4225">	if (result != B_OK || srcWindow == NULL) {</a>
<a name="ln4226">		// handle a foreign drag</a>
<a name="ln4227">		bool canCopy;</a>
<a name="ln4228">		bool canMove;</a>
<a name="ln4229">		bool canErase;</a>
<a name="ln4230">		bool canLink;</a>
<a name="ln4231">		FindDragNDropAction(dragMessage, canCopy, canMove, canLink, canErase);</a>
<a name="ln4232">		if (canErase &amp;&amp; CanTrashForeignDrag(target))</a>
<a name="ln4233">			return true;</a>
<a name="ln4234"> </a>
<a name="ln4235">		if (canCopy || canMove) {</a>
<a name="ln4236">			if (CanCopyOrMoveForeignDrag(target, dragMessage))</a>
<a name="ln4237">				return true;</a>
<a name="ln4238"> </a>
<a name="ln4239">			// TODO: collect all mime types here and pass into</a>
<a name="ln4240">			// target-&gt;IsDropTargetForList(mimeTypeList);</a>
<a name="ln4241">		}</a>
<a name="ln4242"> </a>
<a name="ln4243">		// handle an old style entry_refs only darg message</a>
<a name="ln4244">		if (dragMessage-&gt;HasRef(&quot;refs&quot;) &amp;&amp; target-&gt;IsDirectory())</a>
<a name="ln4245">			return true;</a>
<a name="ln4246"> </a>
<a name="ln4247">		// handle simple text clipping drag&amp;drop message</a>
<a name="ln4248">		if (dragMessage-&gt;HasData(kPlainTextMimeType, B_MIME_TYPE)</a>
<a name="ln4249">			&amp;&amp; target-&gt;IsDirectory()) {</a>
<a name="ln4250">			return true;</a>
<a name="ln4251">		}</a>
<a name="ln4252"> </a>
<a name="ln4253">		// handle simple bitmap clipping drag&amp;drop message</a>
<a name="ln4254">		if (target-&gt;IsDirectory()</a>
<a name="ln4255">			&amp;&amp; (dragMessage-&gt;HasData(kBitmapMimeType, B_MESSAGE_TYPE)</a>
<a name="ln4256">				|| dragMessage-&gt;HasData(kLargeIconType, B_MESSAGE_TYPE)</a>
<a name="ln4257">				|| dragMessage-&gt;HasData(kMiniIconType, B_MESSAGE_TYPE))) {</a>
<a name="ln4258">			return true;</a>
<a name="ln4259">		}</a>
<a name="ln4260"> </a>
<a name="ln4261">		// TODO: check for a drag message full of refs, feed a list of their</a>
<a name="ln4262">		// types to target-&gt;IsDropTargetForList(mimeTypeList);</a>
<a name="ln4263">		return false;</a>
<a name="ln4264">	}</a>
<a name="ln4265"> </a>
<a name="ln4266">	ASSERT(srcWindow != NULL);</a>
<a name="ln4267"> </a>
<a name="ln4268">	AutoLock&lt;BWindow&gt; lock(srcWindow);</a>
<a name="ln4269">	if (!lock)</a>
<a name="ln4270">		return false;</a>
<a name="ln4271"> </a>
<a name="ln4272">	BObjectList&lt;BString&gt;* mimeTypeList</a>
<a name="ln4273">		= srcWindow-&gt;PoseView()-&gt;MimeTypesInSelection();</a>
<a name="ln4274">	if (mimeTypeList-&gt;IsEmpty()) {</a>
<a name="ln4275">		PoseList* selectionList = srcWindow-&gt;PoseView()-&gt;SelectionList();</a>
<a name="ln4276">		if (!selectionList-&gt;IsEmpty()) {</a>
<a name="ln4277">			// no cached data yet, build the cache</a>
<a name="ln4278">			int32 count = selectionList-&gt;CountItems();</a>
<a name="ln4279"> </a>
<a name="ln4280">			for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln4281">				// get the mime type of the model, following a possible symlink</a>
<a name="ln4282">				BEntry entry(selectionList-&gt;ItemAt(</a>
<a name="ln4283">					index)-&gt;TargetModel()-&gt;EntryRef(), true);</a>
<a name="ln4284">				if (entry.InitCheck() != B_OK)</a>
<a name="ln4285">					continue;</a>
<a name="ln4286"> </a>
<a name="ln4287"> 				BFile file(&amp;entry, O_RDONLY);</a>
<a name="ln4288">				BNodeInfo mime(&amp;file);</a>
<a name="ln4289"> </a>
<a name="ln4290">				if (mime.InitCheck() != B_OK)</a>
<a name="ln4291">					continue;</a>
<a name="ln4292"> </a>
<a name="ln4293">				char mimeType[B_MIME_TYPE_LENGTH];</a>
<a name="ln4294">				mime.GetType(mimeType);</a>
<a name="ln4295"> </a>
<a name="ln4296">				// add unique type string</a>
<a name="ln4297">				if (!WhileEachListItem(mimeTypeList, ContainsOne,</a>
<a name="ln4298">						(const char*)mimeType)) {</a>
<a name="ln4299">					BString* newMimeString = new BString(mimeType);</a>
<a name="ln4300">					mimeTypeList-&gt;AddItem(newMimeString);</a>
<a name="ln4301">				}</a>
<a name="ln4302">			}</a>
<a name="ln4303">		}</a>
<a name="ln4304">	}</a>
<a name="ln4305"> </a>
<a name="ln4306">	return target-&gt;IsDropTargetForList(mimeTypeList);</a>
<a name="ln4307">}</a>
<a name="ln4308"> </a>
<a name="ln4309"> </a>
<a name="ln4310">void</a>
<a name="ln4311">BPoseView::TrySettingPoseLocation(BNode* node, BPoint point)</a>
<a name="ln4312">{</a>
<a name="ln4313">	if (ViewMode() == kListMode)</a>
<a name="ln4314">		return;</a>
<a name="ln4315"> </a>
<a name="ln4316">	if ((modifiers() &amp; B_COMMAND_KEY) != 0) {</a>
<a name="ln4317">		// align to grid if needed</a>
<a name="ln4318">		point = PinToGrid(point, fGrid, fOffset);</a>
<a name="ln4319">	}</a>
<a name="ln4320"> </a>
<a name="ln4321">	Model* targetModel = TargetModel();</a>
<a name="ln4322">	ASSERT(targetModel != NULL);</a>
<a name="ln4323"> </a>
<a name="ln4324">	if (targetModel != NULL &amp;&amp; targetModel-&gt;NodeRef() != NULL</a>
<a name="ln4325">		&amp;&amp; FSSetPoseLocation(targetModel-&gt;NodeRef()-&gt;node, node, point)</a>
<a name="ln4326">			== B_OK) {</a>
<a name="ln4327">		// get rid of opposite endianness attribute</a>
<a name="ln4328">		node-&gt;RemoveAttr(kAttrPoseInfoForeign);</a>
<a name="ln4329">	}</a>
<a name="ln4330">}</a>
<a name="ln4331"> </a>
<a name="ln4332"> </a>
<a name="ln4333">status_t</a>
<a name="ln4334">BPoseView::CreateClippingFile(BPoseView* poseView, BFile &amp;result,</a>
<a name="ln4335">	char* resultingName, BDirectory* directory, BMessage* message,</a>
<a name="ln4336">	const char* fallbackName, bool setLocation, BPoint dropPoint)</a>
<a name="ln4337">{</a>
<a name="ln4338">	// build a file name</a>
<a name="ln4339">	// try picking it up from the message</a>
<a name="ln4340">	const char* suggestedName;</a>
<a name="ln4341">	if (message &amp;&amp; message-&gt;FindString(&quot;be:clip_name&quot;, &amp;suggestedName) == B_OK)</a>
<a name="ln4342">		strncpy(resultingName, suggestedName, B_FILE_NAME_LENGTH - 1);</a>
<a name="ln4343">	else</a>
<a name="ln4344">		strcpy(resultingName, fallbackName);</a>
<a name="ln4345"> </a>
<a name="ln4346">	FSMakeOriginalName(resultingName, directory, &quot;&quot;);</a>
<a name="ln4347"> </a>
<a name="ln4348">	// create a clipping file</a>
<a name="ln4349">	status_t error = directory-&gt;CreateFile(resultingName, &amp;result, true);</a>
<a name="ln4350">	if (error != B_OK)</a>
<a name="ln4351">		return error;</a>
<a name="ln4352"> </a>
<a name="ln4353">	if (setLocation &amp;&amp; poseView != NULL)</a>
<a name="ln4354">		poseView-&gt;TrySettingPoseLocation(&amp;result, dropPoint);</a>
<a name="ln4355"> </a>
<a name="ln4356">	return B_OK;</a>
<a name="ln4357">}</a>
<a name="ln4358"> </a>
<a name="ln4359"> </a>
<a name="ln4360">static int32</a>
<a name="ln4361">RunMimeTypeDestinationMenu(const char* actionText,</a>
<a name="ln4362">	const BObjectList&lt;BString&gt;* types,</a>
<a name="ln4363">	const BObjectList&lt;BString&gt;* specificItems, BPoint where)</a>
<a name="ln4364">{</a>
<a name="ln4365">	int32 count;</a>
<a name="ln4366">	if (types != NULL)</a>
<a name="ln4367">		count = types-&gt;CountItems();</a>
<a name="ln4368">	else</a>
<a name="ln4369">		count = specificItems-&gt;CountItems();</a>
<a name="ln4370"> </a>
<a name="ln4371">	if (count == 0)</a>
<a name="ln4372">		return 0;</a>
<a name="ln4373"> </a>
<a name="ln4374">	BPopUpMenu* menu = new BPopUpMenu(&quot;create clipping&quot;);</a>
<a name="ln4375">	menu-&gt;SetFont(be_plain_font);</a>
<a name="ln4376"> </a>
<a name="ln4377">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln4378">		const char* embedTypeAs = NULL;</a>
<a name="ln4379">		char buffer[256];</a>
<a name="ln4380">		if (types) {</a>
<a name="ln4381">			types-&gt;ItemAt(index)-&gt;String();</a>
<a name="ln4382">			BMimeType mimeType(embedTypeAs);</a>
<a name="ln4383"> </a>
<a name="ln4384">			if (mimeType.GetShortDescription(buffer) == B_OK)</a>
<a name="ln4385">				embedTypeAs = buffer;</a>
<a name="ln4386">		}</a>
<a name="ln4387"> </a>
<a name="ln4388">		BString description;</a>
<a name="ln4389">		if (specificItems-&gt;ItemAt(index)-&gt;Length()) {</a>
<a name="ln4390">			description &lt;&lt; (const BString &amp;)(*specificItems-&gt;ItemAt(index));</a>
<a name="ln4391"> </a>
<a name="ln4392">			if (embedTypeAs)</a>
<a name="ln4393">				description &lt;&lt; &quot; (&quot; &lt;&lt; embedTypeAs &lt;&lt; &quot;)&quot;;</a>
<a name="ln4394"> </a>
<a name="ln4395">		} else if (types)</a>
<a name="ln4396">			description = embedTypeAs;</a>
<a name="ln4397"> </a>
<a name="ln4398">		BString labelText;</a>
<a name="ln4399">		if (actionText) {</a>
<a name="ln4400">			int32 length = 1024 - 1 - (int32)strlen(actionText);</a>
<a name="ln4401">			if (length &gt; 0) {</a>
<a name="ln4402">				description.Truncate(length);</a>
<a name="ln4403">				labelText.SetTo(actionText);</a>
<a name="ln4404">				labelText.ReplaceFirst(&quot;%s&quot;, description.String());</a>
<a name="ln4405">			} else</a>
<a name="ln4406">				labelText.SetTo(B_TRANSLATE(&quot;label too long&quot;));</a>
<a name="ln4407">		} else</a>
<a name="ln4408">			labelText = description;</a>
<a name="ln4409"> </a>
<a name="ln4410">		menu-&gt;AddItem(new BMenuItem(labelText.String(), 0));</a>
<a name="ln4411">	}</a>
<a name="ln4412"> </a>
<a name="ln4413">	menu-&gt;AddSeparatorItem();</a>
<a name="ln4414">	menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Cancel&quot;), 0));</a>
<a name="ln4415"> </a>
<a name="ln4416">	int32 result = -1;</a>
<a name="ln4417">	BMenuItem* resultingItem = menu-&gt;Go(where, false, true);</a>
<a name="ln4418">	if (resultingItem) {</a>
<a name="ln4419">		int32 index = menu-&gt;IndexOf(resultingItem);</a>
<a name="ln4420">		if (index &lt; count)</a>
<a name="ln4421">			result = index;</a>
<a name="ln4422">	}</a>
<a name="ln4423"> </a>
<a name="ln4424">	delete menu;</a>
<a name="ln4425"> </a>
<a name="ln4426">	return result;</a>
<a name="ln4427">}</a>
<a name="ln4428"> </a>
<a name="ln4429"> </a>
<a name="ln4430">bool</a>
<a name="ln4431">BPoseView::HandleMessageDropped(BMessage* message)</a>
<a name="ln4432">{</a>
<a name="ln4433">	ASSERT(message-&gt;WasDropped());</a>
<a name="ln4434"> </a>
<a name="ln4435">	// reset system cursor in case it was altered by drag and drop</a>
<a name="ln4436">	SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln4437">	fCursorCheck = false;</a>
<a name="ln4438"> </a>
<a name="ln4439">	if (!fDropEnabled)</a>
<a name="ln4440">		return false;</a>
<a name="ln4441"> </a>
<a name="ln4442">	BContainerWindow* window = dynamic_cast&lt;BContainerWindow*&gt;(Window());</a>
<a name="ln4443">	if (window != NULL &amp;&amp; message-&gt;HasData(&quot;RGBColor&quot;, 'RGBC')) {</a>
<a name="ln4444"> 		// do not handle roColor-style drops here, pass them on to the desktop</a>
<a name="ln4445">		BMessenger((BHandler*)window).SendMessage(message);</a>
<a name="ln4446"> </a>
<a name="ln4447">		return true;</a>
<a name="ln4448"> 	}</a>
<a name="ln4449"> </a>
<a name="ln4450">	if (fDropTarget &amp;&amp; !DragSelectionContains(fDropTarget, message))</a>
<a name="ln4451">		HiliteDropTarget(false);</a>
<a name="ln4452"> </a>
<a name="ln4453">	fDropTarget = NULL;</a>
<a name="ln4454"> </a>
<a name="ln4455">	ASSERT(TargetModel() != NULL);</a>
<a name="ln4456">	BPoint offset;</a>
<a name="ln4457">	BPoint dropPoint(message-&gt;DropPoint(&amp;offset));</a>
<a name="ln4458">	ConvertFromScreen(&amp;dropPoint);</a>
<a name="ln4459"> </a>
<a name="ln4460">	// tenatively figure out the pose we dropped the file onto</a>
<a name="ln4461">	int32 index;</a>
<a name="ln4462">	BPose* targetPose = FindPose(dropPoint, &amp;index);</a>
<a name="ln4463">	Model tmpTarget;</a>
<a name="ln4464">	Model* targetModel = NULL;</a>
<a name="ln4465">	if (targetPose != NULL) {</a>
<a name="ln4466">		targetModel = targetPose-&gt;TargetModel();</a>
<a name="ln4467">		if (targetModel-&gt;IsSymLink()</a>
<a name="ln4468">			&amp;&amp; tmpTarget.SetTo(targetPose-&gt;TargetModel()-&gt;EntryRef(),</a>
<a name="ln4469">				true, true) == B_OK) {</a>
<a name="ln4470">			targetModel = &amp;tmpTarget;</a>
<a name="ln4471">		}</a>
<a name="ln4472">	}</a>
<a name="ln4473"> </a>
<a name="ln4474">	return HandleDropCommon(message, targetModel, targetPose, this, dropPoint);</a>
<a name="ln4475">}</a>
<a name="ln4476"> </a>
<a name="ln4477"> </a>
<a name="ln4478">bool</a>
<a name="ln4479">BPoseView::HandleDropCommon(BMessage* message, Model* targetModel,</a>
<a name="ln4480">	BPose* targetPose, BView* view, BPoint dropPoint)</a>
<a name="ln4481">{</a>
<a name="ln4482">	uint32 buttons = (uint32)message-&gt;FindInt32(&quot;buttons&quot;);</a>
<a name="ln4483"> </a>
<a name="ln4484">	BContainerWindow* containerWindow = NULL;</a>
<a name="ln4485">	BPoseView* poseView = dynamic_cast&lt;BPoseView*&gt;(view);</a>
<a name="ln4486">	if (poseView != NULL)</a>
<a name="ln4487">		containerWindow = poseView-&gt;ContainerWindow();</a>
<a name="ln4488"> </a>
<a name="ln4489">	// look for srcWindow to determine whether drag was initiated in tracker</a>
<a name="ln4490">	BContainerWindow* srcWindow = NULL;</a>
<a name="ln4491">	status_t result = message-&gt;FindPointer(&quot;src_window&quot;, (void**)&amp;srcWindow);</a>
<a name="ln4492">	if (result != B_OK || srcWindow == NULL) {</a>
<a name="ln4493">		// drag was from another app</a>
<a name="ln4494"> </a>
<a name="ln4495">		if (targetModel == NULL &amp;&amp; poseView != NULL)</a>
<a name="ln4496">			targetModel = poseView-&gt;TargetModel();</a>
<a name="ln4497"> </a>
<a name="ln4498">		// figure out if we dropped a file onto a directory and set</a>
<a name="ln4499">		// the targetDirectory to it, else set it to this pose view</a>
<a name="ln4500">		BDirectory targetDirectory;</a>
<a name="ln4501">		if (targetModel != NULL &amp;&amp; targetModel-&gt;IsDirectory())</a>
<a name="ln4502">			targetDirectory.SetTo(targetModel-&gt;EntryRef());</a>
<a name="ln4503"> </a>
<a name="ln4504">		if (targetModel != NULL &amp;&amp; targetModel-&gt;IsRoot()) {</a>
<a name="ln4505">			// don't drop anything into the root disk</a>
<a name="ln4506">			return false;</a>
<a name="ln4507">		}</a>
<a name="ln4508"> </a>
<a name="ln4509">		bool canCopy;</a>
<a name="ln4510">		bool canMove;</a>
<a name="ln4511">		bool canErase;</a>
<a name="ln4512">		bool canLink;</a>
<a name="ln4513">		if (FindDragNDropAction(message, canCopy, canMove, canLink, canErase)) {</a>
<a name="ln4514">			// new D&amp;D protocol</a>
<a name="ln4515">			// what action can the drag initiator do?</a>
<a name="ln4516">			if (canErase &amp;&amp; CanTrashForeignDrag(targetModel)) {</a>
<a name="ln4517">				BMessage reply(B_TRASH_TARGET);</a>
<a name="ln4518">				message-&gt;SendReply(&amp;reply);</a>
<a name="ln4519">				return true;</a>
<a name="ln4520">			}</a>
<a name="ln4521"> </a>
<a name="ln4522">			if ((canCopy || canMove)</a>
<a name="ln4523">				&amp;&amp; CanCopyOrMoveForeignDrag(targetModel, message)) {</a>
<a name="ln4524">				// handle the promise style drag&amp;drop</a>
<a name="ln4525"> </a>
<a name="ln4526">				// fish for specification of specialized menu items</a>
<a name="ln4527">				BObjectList&lt;BString&gt; actionSpecifiers(10, true);</a>
<a name="ln4528">				for (int32 index = 0; ; index++) {</a>
<a name="ln4529">					const char* string;</a>
<a name="ln4530">					if (message-&gt;FindString(&quot;be:actionspecifier&quot;, index,</a>
<a name="ln4531">							&amp;string) != B_OK) {</a>
<a name="ln4532">						break;</a>
<a name="ln4533">					}</a>
<a name="ln4534"> </a>
<a name="ln4535">					ASSERT(string != NULL);</a>
<a name="ln4536">					actionSpecifiers.AddItem(new BString(string));</a>
<a name="ln4537">				}</a>
<a name="ln4538"> </a>
<a name="ln4539">				// build the list of types the drag originator offers</a>
<a name="ln4540">				BObjectList&lt;BString&gt; types(10, true);</a>
<a name="ln4541">				BObjectList&lt;BString&gt; typeNames(10, true);</a>
<a name="ln4542">				for (int32 index = 0; ; index++) {</a>
<a name="ln4543">					const char* string;</a>
<a name="ln4544">					if (message-&gt;FindString(&quot;be:filetypes&quot;, index, &amp;string)</a>
<a name="ln4545">							!= B_OK) {</a>
<a name="ln4546">						break;</a>
<a name="ln4547">					}</a>
<a name="ln4548"> </a>
<a name="ln4549">					ASSERT(string != NULL);</a>
<a name="ln4550">					types.AddItem(new BString(string));</a>
<a name="ln4551"> </a>
<a name="ln4552">					const char* typeName = &quot;&quot;;</a>
<a name="ln4553">					message-&gt;FindString(&quot;be:type_descriptions&quot;, index,</a>
<a name="ln4554">						&amp;typeName);</a>
<a name="ln4555">					typeNames.AddItem(new BString(typeName));</a>
<a name="ln4556">				}</a>
<a name="ln4557"> </a>
<a name="ln4558">				int32 specificTypeIndex = -1;</a>
<a name="ln4559">				int32 specificActionIndex = -1;</a>
<a name="ln4560"> </a>
<a name="ln4561">				// if control down, run a popup menu</a>
<a name="ln4562">				if (canCopy</a>
<a name="ln4563">					&amp;&amp; SecondaryMouseButtonDown(modifiers(), buttons)) {</a>
<a name="ln4564">					if (actionSpecifiers.CountItems() &gt; 0) {</a>
<a name="ln4565">						specificActionIndex = RunMimeTypeDestinationMenu(NULL,</a>
<a name="ln4566">							NULL, &amp;actionSpecifiers,</a>
<a name="ln4567">							view-&gt;ConvertToScreen(dropPoint));</a>
<a name="ln4568"> </a>
<a name="ln4569">						if (specificActionIndex == -1)</a>
<a name="ln4570">							return false;</a>
<a name="ln4571">					} else if (types.CountItems() &gt; 0) {</a>
<a name="ln4572">						specificTypeIndex = RunMimeTypeDestinationMenu(</a>
<a name="ln4573">							B_TRANSLATE(&quot;Create %s clipping&quot;),</a>
<a name="ln4574">							&amp;types, &amp;typeNames,</a>
<a name="ln4575">							view-&gt;ConvertToScreen(dropPoint));</a>
<a name="ln4576"> </a>
<a name="ln4577">						if (specificTypeIndex == -1)</a>
<a name="ln4578">							return false;</a>
<a name="ln4579">					}</a>
<a name="ln4580">				}</a>
<a name="ln4581"> </a>
<a name="ln4582">				char name[B_FILE_NAME_LENGTH];</a>
<a name="ln4583">				BFile file;</a>
<a name="ln4584">				if (CreateClippingFile(poseView, file, name, &amp;targetDirectory,</a>
<a name="ln4585">						message, B_TRANSLATE(&quot;Untitled clipping&quot;),</a>
<a name="ln4586">						targetPose == NULL, dropPoint) != B_OK) {</a>
<a name="ln4587">					return false;</a>
<a name="ln4588">				}</a>
<a name="ln4589"> </a>
<a name="ln4590">				// here is a file for the drag initiator, it is up to it now</a>
<a name="ln4591">				// to stuff it with the goods</a>
<a name="ln4592"> </a>
<a name="ln4593">				// build the reply message</a>
<a name="ln4594">				BMessage reply(canCopy ? B_COPY_TARGET : B_MOVE_TARGET);</a>
<a name="ln4595">				reply.AddString(&quot;be:types&quot;, B_FILE_MIME_TYPE);</a>
<a name="ln4596">				if (specificTypeIndex != -1) {</a>
<a name="ln4597">					// we had the user pick a specific type from a menu, use it</a>
<a name="ln4598">					reply.AddString(&quot;be:filetypes&quot;,</a>
<a name="ln4599">						types.ItemAt(specificTypeIndex)-&gt;String());</a>
<a name="ln4600"> </a>
<a name="ln4601">					if (typeNames.ItemAt(specificTypeIndex)-&gt;Length()) {</a>
<a name="ln4602">						reply.AddString(&quot;be:type_descriptions&quot;,</a>
<a name="ln4603">							typeNames.ItemAt(specificTypeIndex)-&gt;String());</a>
<a name="ln4604">					}</a>
<a name="ln4605">				}</a>
<a name="ln4606"> </a>
<a name="ln4607">				if (specificActionIndex != -1) {</a>
<a name="ln4608">					// we had the user pick a specific type from a menu, use it</a>
<a name="ln4609">					reply.AddString(&quot;be:actionspecifier&quot;,</a>
<a name="ln4610">						actionSpecifiers.ItemAt(specificActionIndex)-&gt;String());</a>
<a name="ln4611">				}</a>
<a name="ln4612"> </a>
<a name="ln4613">				reply.AddRef(&quot;directory&quot;, targetModel-&gt;EntryRef());</a>
<a name="ln4614">				reply.AddString(&quot;name&quot;, name);</a>
<a name="ln4615"> </a>
<a name="ln4616">				// Attach any data the originator may have tagged on</a>
<a name="ln4617">				BMessage data;</a>
<a name="ln4618">				if (message-&gt;FindMessage(&quot;be:originator-data&quot;, &amp;data) == B_OK)</a>
<a name="ln4619">					reply.AddMessage(&quot;be:originator-data&quot;, &amp;data);</a>
<a name="ln4620"> </a>
<a name="ln4621">				// copy over all the file types the drag initiator claimed to</a>
<a name="ln4622">				// support</a>
<a name="ln4623">				for (int32 index = 0; ; index++) {</a>
<a name="ln4624">					const char* type;</a>
<a name="ln4625">					if (message-&gt;FindString(&quot;be:filetypes&quot;, index, &amp;type)</a>
<a name="ln4626">							!= B_OK) {</a>
<a name="ln4627">						break;</a>
<a name="ln4628">					}</a>
<a name="ln4629">					reply.AddString(&quot;be:filetypes&quot;, type);</a>
<a name="ln4630">				}</a>
<a name="ln4631"> </a>
<a name="ln4632">				message-&gt;SendReply(&amp;reply);</a>
<a name="ln4633">				return true;</a>
<a name="ln4634">			}</a>
<a name="ln4635">		}</a>
<a name="ln4636"> </a>
<a name="ln4637">		if (message-&gt;HasRef(&quot;refs&quot;)) {</a>
<a name="ln4638">			// TODO: decide here on copy, move or create symlink</a>
<a name="ln4639">			// look for specific command or bring up popup</a>
<a name="ln4640">			// Unify this with local drag&amp;drop</a>
<a name="ln4641"> </a>
<a name="ln4642">			if (!targetModel-&gt;IsDirectory()) {</a>
<a name="ln4643">				// bail if we are not a directory</a>
<a name="ln4644">				return false;</a>
<a name="ln4645">			}</a>
<a name="ln4646"> </a>
<a name="ln4647">			bool canRelativeLink = false;</a>
<a name="ln4648">			if (!canCopy &amp;&amp; !canMove &amp;&amp; !canLink &amp;&amp; containerWindow) {</a>
<a name="ln4649">				if (SecondaryMouseButtonDown(modifiers(), buttons)) {</a>
<a name="ln4650">					switch (containerWindow-&gt;ShowDropContextMenu(dropPoint)) {</a>
<a name="ln4651">						case kCreateRelativeLink:</a>
<a name="ln4652">							canRelativeLink = true;</a>
<a name="ln4653">							break;</a>
<a name="ln4654"> </a>
<a name="ln4655">						case kCreateLink:</a>
<a name="ln4656">							canLink = true;</a>
<a name="ln4657">							break;</a>
<a name="ln4658"> </a>
<a name="ln4659">						case kMoveSelectionTo:</a>
<a name="ln4660">							canMove = true;</a>
<a name="ln4661">							break;</a>
<a name="ln4662"> </a>
<a name="ln4663">						case kCopySelectionTo:</a>
<a name="ln4664">							canCopy = true;</a>
<a name="ln4665">							break;</a>
<a name="ln4666"> </a>
<a name="ln4667">						case kCancelButton:</a>
<a name="ln4668">						default:</a>
<a name="ln4669">							// user canceled context menu</a>
<a name="ln4670">							return true;</a>
<a name="ln4671">					}</a>
<a name="ln4672">				} else</a>
<a name="ln4673">					canCopy = true;</a>
<a name="ln4674">			}</a>
<a name="ln4675"> </a>
<a name="ln4676">			uint32 moveMode;</a>
<a name="ln4677">			if (canCopy)</a>
<a name="ln4678">				moveMode = kCopySelectionTo;</a>
<a name="ln4679">			else if (canMove)</a>
<a name="ln4680">				moveMode = kMoveSelectionTo;</a>
<a name="ln4681">			else if (canLink)</a>
<a name="ln4682">				moveMode = kCreateLink;</a>
<a name="ln4683">			else if (canRelativeLink)</a>
<a name="ln4684">				moveMode = kCreateRelativeLink;</a>
<a name="ln4685">			else {</a>
<a name="ln4686">				TRESPASS();</a>
<a name="ln4687">				return true;</a>
<a name="ln4688">			}</a>
<a name="ln4689"> </a>
<a name="ln4690">			// handle refs by performing a copy</a>
<a name="ln4691">			BObjectList&lt;entry_ref&gt;* entryList</a>
<a name="ln4692">				= new BObjectList&lt;entry_ref&gt;(10, true);</a>
<a name="ln4693"> </a>
<a name="ln4694">			for (int32 index = 0; ; index++) {</a>
<a name="ln4695">				// copy all enclosed refs into a list</a>
<a name="ln4696">				entry_ref ref;</a>
<a name="ln4697">				if (message-&gt;FindRef(&quot;refs&quot;, index, &amp;ref) != B_OK)</a>
<a name="ln4698">					break;</a>
<a name="ln4699">				entryList-&gt;AddItem(new entry_ref(ref));</a>
<a name="ln4700">			}</a>
<a name="ln4701"> </a>
<a name="ln4702">			int32 count = entryList-&gt;CountItems();</a>
<a name="ln4703">			if (count != 0) {</a>
<a name="ln4704">				BList* pointList = 0;</a>
<a name="ln4705">				if (poseView != NULL &amp;&amp; targetPose != NULL) {</a>
<a name="ln4706">					// calculate a pointList to make the icons land</a>
<a name="ln4707">					// were we dropped them</a>
<a name="ln4708">					pointList = new BList(count);</a>
<a name="ln4709">					// force the the icons to lay out in 5 columns</a>
<a name="ln4710">					for (int32 index = 0; count; index++) {</a>
<a name="ln4711">						for (int32 j = 0; count &amp;&amp; j &lt; 4; j++, count--) {</a>
<a name="ln4712">							BPoint point(</a>
<a name="ln4713">								dropPoint + BPoint(j * poseView-&gt;fGrid.x,</a>
<a name="ln4714">								index * poseView-&gt;fGrid.y));</a>
<a name="ln4715">							pointList-&gt;AddItem(</a>
<a name="ln4716">								new BPoint(poseView-&gt;PinToGrid(point,</a>
<a name="ln4717">								poseView-&gt;fGrid, poseView-&gt;fOffset)));</a>
<a name="ln4718">						}</a>
<a name="ln4719">					}</a>
<a name="ln4720">				}</a>
<a name="ln4721"> </a>
<a name="ln4722">				// perform asynchronous copy</a>
<a name="ln4723">				FSMoveToFolder(entryList, new BEntry(targetModel-&gt;EntryRef()),</a>
<a name="ln4724">					moveMode, pointList);</a>
<a name="ln4725"> </a>
<a name="ln4726">				return true;</a>
<a name="ln4727">			}</a>
<a name="ln4728"> </a>
<a name="ln4729">			// nothing to copy, list doesn't get consumed</a>
<a name="ln4730">			delete entryList;</a>
<a name="ln4731">			return true;</a>
<a name="ln4732">		}</a>
<a name="ln4733">		if (message-&gt;HasData(kPlainTextMimeType, B_MIME_TYPE)) {</a>
<a name="ln4734">			// text dropped, make into a clipping file</a>
<a name="ln4735">			if (!targetModel-&gt;IsDirectory()) {</a>
<a name="ln4736">				// bail if we are not a directory</a>
<a name="ln4737">				return false;</a>
<a name="ln4738">			}</a>
<a name="ln4739"> </a>
<a name="ln4740">			// find the text</a>
<a name="ln4741">			ssize_t textLength;</a>
<a name="ln4742">			const char* text;</a>
<a name="ln4743">			if (message-&gt;FindData(kPlainTextMimeType, B_MIME_TYPE,</a>
<a name="ln4744">				(const void**)&amp;text, &amp;textLength) != B_OK) {</a>
<a name="ln4745">				return false;</a>
<a name="ln4746">			}</a>
<a name="ln4747"> </a>
<a name="ln4748">			char name[B_FILE_NAME_LENGTH];</a>
<a name="ln4749">			BFile file;</a>
<a name="ln4750">			if (CreateClippingFile(poseView, file, name, &amp;targetDirectory,</a>
<a name="ln4751">					message, B_TRANSLATE(&quot;Untitled clipping&quot;), !targetPose,</a>
<a name="ln4752">					dropPoint) != B_OK) {</a>
<a name="ln4753">				return false;</a>
<a name="ln4754">			}</a>
<a name="ln4755"> </a>
<a name="ln4756">			// write out the file</a>
<a name="ln4757">			if (file.Seek(0, SEEK_SET) == B_ERROR</a>
<a name="ln4758">				|| file.Write(text, (size_t)textLength) &lt; 0</a>
<a name="ln4759">				|| file.SetSize(textLength) != B_OK) {</a>
<a name="ln4760">				// failed to write file, remove file and bail</a>
<a name="ln4761">				file.Unset();</a>
<a name="ln4762">				BEntry entry(&amp;targetDirectory, name);</a>
<a name="ln4763">				entry.Remove();</a>
<a name="ln4764">				PRINT((&quot;error writing text into file %s\n&quot;, name));</a>
<a name="ln4765">			}</a>
<a name="ln4766"> </a>
<a name="ln4767">			// pick up TextView styles if available and save them with the file</a>
<a name="ln4768">			const text_run_array* textRuns = NULL;</a>
<a name="ln4769">			ssize_t dataSize = 0;</a>
<a name="ln4770">			if (message-&gt;FindData(&quot;application/x-vnd.Be-text_run_array&quot;,</a>
<a name="ln4771">					B_MIME_TYPE, (const void**)&amp;textRuns, &amp;dataSize) == B_OK</a>
<a name="ln4772">					&amp;&amp; textRuns &amp;&amp; dataSize) {</a>
<a name="ln4773">				// save styles the same way StyledEdit does</a>
<a name="ln4774">				int32 tmpSize = dataSize;</a>
<a name="ln4775">				void* data = BTextView::FlattenRunArray(textRuns, &amp;tmpSize);</a>
<a name="ln4776">				file.WriteAttr(&quot;styles&quot;, B_RAW_TYPE, 0, data, (size_t)tmpSize);</a>
<a name="ln4777">				free(data);</a>
<a name="ln4778">			}</a>
<a name="ln4779"> </a>
<a name="ln4780">			// mark as a clipping file</a>
<a name="ln4781">			int32 tmp;</a>
<a name="ln4782">			file.WriteAttr(kAttrClippingFile, B_RAW_TYPE, 0, &amp;tmp,</a>
<a name="ln4783">				sizeof(int32));</a>
<a name="ln4784"> </a>
<a name="ln4785">			// set the file type</a>
<a name="ln4786">			BNodeInfo info(&amp;file);</a>
<a name="ln4787">			info.SetType(kPlainTextMimeType);</a>
<a name="ln4788"> </a>
<a name="ln4789">			return true;</a>
<a name="ln4790">		}</a>
<a name="ln4791"> </a>
<a name="ln4792">		if (message-&gt;HasData(kBitmapMimeType, B_MESSAGE_TYPE)</a>
<a name="ln4793">			|| message-&gt;HasData(kLargeIconType, B_MESSAGE_TYPE)</a>
<a name="ln4794">			|| message-&gt;HasData(kMiniIconType, B_MESSAGE_TYPE)) {</a>
<a name="ln4795">			// bitmap, make into a clipping file</a>
<a name="ln4796">			if (!targetModel-&gt;IsDirectory()) {</a>
<a name="ln4797">				// bail if we are not a directory</a>
<a name="ln4798">				return false;</a>
<a name="ln4799">			}</a>
<a name="ln4800"> </a>
<a name="ln4801">			BMessage embeddedBitmap;</a>
<a name="ln4802">			if (message-&gt;FindMessage(kBitmapMimeType, &amp;embeddedBitmap)</a>
<a name="ln4803">					!= B_OK</a>
<a name="ln4804">				&amp;&amp; message-&gt;FindMessage(kLargeIconType, &amp;embeddedBitmap)</a>
<a name="ln4805">					!= B_OK</a>
<a name="ln4806">				&amp;&amp; message-&gt;FindMessage(kMiniIconType, &amp;embeddedBitmap)</a>
<a name="ln4807">					!= B_OK) {</a>
<a name="ln4808">				return false;</a>
<a name="ln4809">			}</a>
<a name="ln4810"> </a>
<a name="ln4811">			char name[B_FILE_NAME_LENGTH];</a>
<a name="ln4812"> </a>
<a name="ln4813">			BFile file;</a>
<a name="ln4814">			if (CreateClippingFile(poseView, file, name, &amp;targetDirectory,</a>
<a name="ln4815">					message, B_TRANSLATE(&quot;Untitled bitmap&quot;), targetPose == NULL,</a>
<a name="ln4816">					dropPoint) != B_OK) {</a>
<a name="ln4817">				return false;</a>
<a name="ln4818">			}</a>
<a name="ln4819"> </a>
<a name="ln4820">			int32 size = embeddedBitmap.FlattenedSize();</a>
<a name="ln4821">			if (size &gt; 1024 * 1024) {</a>
<a name="ln4822">				// bail if too large</a>
<a name="ln4823">				return false;</a>
<a name="ln4824">			}</a>
<a name="ln4825"> </a>
<a name="ln4826">			char* buffer = new char [size];</a>
<a name="ln4827">			embeddedBitmap.Flatten(buffer, size);</a>
<a name="ln4828"> </a>
<a name="ln4829">			// write out the file</a>
<a name="ln4830">			if (file.Seek(0, SEEK_SET) == B_ERROR</a>
<a name="ln4831">				|| file.Write(buffer, (size_t)size) &lt; 0</a>
<a name="ln4832">				|| file.SetSize(size) != B_OK) {</a>
<a name="ln4833">				// failed to write file, remove file and bail</a>
<a name="ln4834">				file.Unset();</a>
<a name="ln4835">				BEntry entry(&amp;targetDirectory, name);</a>
<a name="ln4836">				entry.Remove();</a>
<a name="ln4837">				PRINT((&quot;error writing bitmap into file %s\n&quot;, name));</a>
<a name="ln4838">			}</a>
<a name="ln4839"> </a>
<a name="ln4840">			// mark as a clipping file</a>
<a name="ln4841">			int32 tmp;</a>
<a name="ln4842">			file.WriteAttr(kAttrClippingFile, B_RAW_TYPE, 0, &amp;tmp,</a>
<a name="ln4843">				sizeof(int32));</a>
<a name="ln4844"> </a>
<a name="ln4845">			// set the file type</a>
<a name="ln4846">			BNodeInfo info(&amp;file);</a>
<a name="ln4847">			info.SetType(kBitmapMimeType);</a>
<a name="ln4848"> </a>
<a name="ln4849">			return true;</a>
<a name="ln4850">		}</a>
<a name="ln4851"> </a>
<a name="ln4852">		return false;</a>
<a name="ln4853">	}</a>
<a name="ln4854"> </a>
<a name="ln4855">	ASSERT(srcWindow != NULL);</a>
<a name="ln4856"> </a>
<a name="ln4857">	if (srcWindow == containerWindow) {</a>
<a name="ln4858">		// drag started in this window</a>
<a name="ln4859">		containerWindow-&gt;Activate();</a>
<a name="ln4860">		containerWindow-&gt;UpdateIfNeeded();</a>
<a name="ln4861">		poseView-&gt;ResetPosePlacementHint();</a>
<a name="ln4862"> </a>
<a name="ln4863">		if (DragSelectionContains(targetPose, message)) {</a>
<a name="ln4864">			// drop on self</a>
<a name="ln4865">			targetModel = NULL;</a>
<a name="ln4866">		}</a>
<a name="ln4867">	}</a>
<a name="ln4868"> </a>
<a name="ln4869">	bool wasHandled = false;</a>
<a name="ln4870">	bool ignoreTypes = (modifiers() &amp; B_CONTROL_KEY) != 0;</a>
<a name="ln4871"> </a>
<a name="ln4872">	if (targetModel != NULL &amp;&amp; containerWindow != NULL) {</a>
<a name="ln4873">		// TODO: pick files to drop/launch on a case by case basis</a>
<a name="ln4874">		if (targetModel-&gt;IsDirectory()) {</a>
<a name="ln4875">			MoveSelectionInto(targetModel, srcWindow, containerWindow,</a>
<a name="ln4876">				buttons, dropPoint, false);</a>
<a name="ln4877">			wasHandled = true;</a>
<a name="ln4878">		} else if (CanHandleDragSelection(targetModel, message, ignoreTypes)) {</a>
<a name="ln4879">			LaunchAppWithSelection(targetModel, message, !ignoreTypes);</a>
<a name="ln4880">			wasHandled = true;</a>
<a name="ln4881">		}</a>
<a name="ln4882">	}</a>
<a name="ln4883"> </a>
<a name="ln4884">	if (poseView != NULL &amp;&amp; !wasHandled) {</a>
<a name="ln4885">		BPoint clickPoint = message-&gt;FindPoint(&quot;click_pt&quot;);</a>
<a name="ln4886">		// TODO: removed check for root here need to do that, possibly at a</a>
<a name="ln4887">		// different level</a>
<a name="ln4888">		poseView-&gt;MoveSelectionTo(dropPoint, clickPoint, srcWindow);</a>
<a name="ln4889">	}</a>
<a name="ln4890"> </a>
<a name="ln4891">	if (poseView != NULL &amp;&amp; poseView-&gt;fEnsurePosesVisible)</a>
<a name="ln4892">		poseView-&gt;CheckPoseVisibility();</a>
<a name="ln4893"> </a>
<a name="ln4894">	return true;</a>
<a name="ln4895">}</a>
<a name="ln4896"> </a>
<a name="ln4897"> </a>
<a name="ln4898">struct LaunchParams {</a>
<a name="ln4899">	Model* app;</a>
<a name="ln4900">	bool checkTypes;</a>
<a name="ln4901">	BMessage* refsMessage;</a>
<a name="ln4902">};</a>
<a name="ln4903"> </a>
<a name="ln4904"> </a>
<a name="ln4905">static bool</a>
<a name="ln4906">AddOneToLaunchMessage(BPose* pose, BPoseView*, void* castToParams)</a>
<a name="ln4907">{</a>
<a name="ln4908">	LaunchParams* params = (LaunchParams*)castToParams;</a>
<a name="ln4909">	ThrowOnAssert(params != NULL);</a>
<a name="ln4910">	ThrowOnAssert(pose != NULL);</a>
<a name="ln4911">	ThrowOnAssert(pose-&gt;TargetModel() != NULL);</a>
<a name="ln4912"> </a>
<a name="ln4913">	if (params-&gt;app-&gt;IsDropTarget(params-&gt;checkTypes</a>
<a name="ln4914">			? pose-&gt;TargetModel() : NULL, true)) {</a>
<a name="ln4915">		params-&gt;refsMessage-&gt;AddRef(&quot;refs&quot;, pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln4916">	}</a>
<a name="ln4917"> </a>
<a name="ln4918">	return false;</a>
<a name="ln4919">}</a>
<a name="ln4920"> </a>
<a name="ln4921"> </a>
<a name="ln4922">void</a>
<a name="ln4923">BPoseView::LaunchAppWithSelection(Model* appModel, const BMessage* dragMessage,</a>
<a name="ln4924">	bool checkTypes)</a>
<a name="ln4925">{</a>
<a name="ln4926">	// launch items from the current selection with &lt;appModel&gt;; only pass</a>
<a name="ln4927">	// the same files that we previously decided can be handled by &lt;appModel&gt;</a>
<a name="ln4928">	BMessage refs(B_REFS_RECEIVED);</a>
<a name="ln4929">	LaunchParams params;</a>
<a name="ln4930">	params.app = appModel;</a>
<a name="ln4931">	params.checkTypes = checkTypes;</a>
<a name="ln4932">	params.refsMessage = &amp;refs;</a>
<a name="ln4933"> </a>
<a name="ln4934">	// add Tracker token so that refs received recipients can script us</a>
<a name="ln4935">	BContainerWindow* srcWindow;</a>
<a name="ln4936">	if (dragMessage-&gt;FindPointer(&quot;src_window&quot;, (void**)&amp;srcWindow) == B_OK</a>
<a name="ln4937">		&amp;&amp; srcWindow != NULL) {</a>
<a name="ln4938">		params.refsMessage-&gt;AddMessenger(&quot;TrackerViewToken&quot;,</a>
<a name="ln4939">			BMessenger(srcWindow-&gt;PoseView()));</a>
<a name="ln4940">	}</a>
<a name="ln4941"> </a>
<a name="ln4942">	EachItemInDraggedSelection(dragMessage, AddOneToLaunchMessage, 0, &amp;params);</a>
<a name="ln4943">	if (params.refsMessage-&gt;HasRef(&quot;refs&quot;))</a>
<a name="ln4944">		TrackerLaunch(appModel-&gt;EntryRef(), params.refsMessage, true);</a>
<a name="ln4945">}</a>
<a name="ln4946"> </a>
<a name="ln4947"> </a>
<a name="ln4948">bool</a>
<a name="ln4949">BPoseView::DragSelectionContains(const BPose* target,</a>
<a name="ln4950">	const BMessage* dragMessage)</a>
<a name="ln4951">{</a>
<a name="ln4952">	return EachItemInDraggedSelection(dragMessage, OneMatches, 0,</a>
<a name="ln4953">		(void*)target);</a>
<a name="ln4954">}</a>
<a name="ln4955"> </a>
<a name="ln4956"> </a>
<a name="ln4957">void</a>
<a name="ln4958">BPoseView::MoveSelectionInto(Model* destFolder, BContainerWindow* srcWindow,</a>
<a name="ln4959">	bool forceCopy, bool forceMove, bool createLink, bool relativeLink)</a>
<a name="ln4960">{</a>
<a name="ln4961">	uint32 buttons;</a>
<a name="ln4962">	BPoint loc;</a>
<a name="ln4963">	GetMouse(&amp;loc, &amp;buttons);</a>
<a name="ln4964">	MoveSelectionInto(destFolder, srcWindow,</a>
<a name="ln4965">		dynamic_cast&lt;BContainerWindow*&gt;(Window()), buttons, loc, forceCopy,</a>
<a name="ln4966">		forceMove, createLink, relativeLink);</a>
<a name="ln4967">}</a>
<a name="ln4968"> </a>
<a name="ln4969"> </a>
<a name="ln4970">void</a>
<a name="ln4971">BPoseView::MoveSelectionInto(Model* destFolder, BContainerWindow* srcWindow,</a>
<a name="ln4972">	BContainerWindow* destWindow, uint32 buttons, BPoint loc, bool forceCopy,</a>
<a name="ln4973">	bool forceMove, bool createLink, bool relativeLink, BPoint clickPoint,</a>
<a name="ln4974">	bool dropOnGrid)</a>
<a name="ln4975">{</a>
<a name="ln4976">	AutoLock&lt;BWindow&gt; lock(srcWindow);</a>
<a name="ln4977">	if (!lock)</a>
<a name="ln4978">		return;</a>
<a name="ln4979"> </a>
<a name="ln4980">	ASSERT(srcWindow-&gt;PoseView()-&gt;TargetModel() != NULL);</a>
<a name="ln4981"> </a>
<a name="ln4982">	if (srcWindow-&gt;PoseView()-&gt;SelectionList()-&gt;CountItems() == 0)</a>
<a name="ln4983">		return;</a>
<a name="ln4984"> </a>
<a name="ln4985">	bool createRelativeLink = relativeLink;</a>
<a name="ln4986">	if (SecondaryMouseButtonDown(modifiers(), buttons)</a>
<a name="ln4987">		&amp;&amp; destWindow != NULL) {</a>
<a name="ln4988">		switch (destWindow-&gt;ShowDropContextMenu(loc)) {</a>
<a name="ln4989">			case kCreateRelativeLink:</a>
<a name="ln4990">				createRelativeLink = true;</a>
<a name="ln4991">				break;</a>
<a name="ln4992"> </a>
<a name="ln4993">			case kCreateLink:</a>
<a name="ln4994">				createLink = true;</a>
<a name="ln4995">				break;</a>
<a name="ln4996"> </a>
<a name="ln4997">			case kMoveSelectionTo:</a>
<a name="ln4998">				forceMove = true;</a>
<a name="ln4999">				break;</a>
<a name="ln5000"> </a>
<a name="ln5001">			case kCopySelectionTo:</a>
<a name="ln5002">				forceCopy = true;</a>
<a name="ln5003">				break;</a>
<a name="ln5004"> </a>
<a name="ln5005">			case kCancelButton:</a>
<a name="ln5006">			default:</a>
<a name="ln5007">				// user canceled context menu</a>
<a name="ln5008">				return;</a>
<a name="ln5009">		}</a>
<a name="ln5010">	}</a>
<a name="ln5011"> </a>
<a name="ln5012">	// make sure source and destination folders are different</a>
<a name="ln5013">	if (!createLink &amp;&amp; !createRelativeLink</a>
<a name="ln5014">		&amp;&amp; (*srcWindow-&gt;PoseView()-&gt;TargetModel()-&gt;NodeRef()</a>
<a name="ln5015">			== *destFolder-&gt;NodeRef())) {</a>
<a name="ln5016">		BPoseView* targetView = srcWindow-&gt;PoseView();</a>
<a name="ln5017">		if (forceCopy) {</a>
<a name="ln5018">			targetView-&gt;DuplicateSelection(&amp;clickPoint, &amp;loc);</a>
<a name="ln5019">			return;</a>
<a name="ln5020">		}</a>
<a name="ln5021"> </a>
<a name="ln5022">		if (targetView-&gt;ViewMode() == kListMode) {</a>
<a name="ln5023">			// can't move in list view</a>
<a name="ln5024">			return;</a>
<a name="ln5025">		}</a>
<a name="ln5026"> </a>
<a name="ln5027">		BPoint delta = loc - clickPoint;</a>
<a name="ln5028">		int32 count = targetView-&gt;fSelectionList-&gt;CountItems();</a>
<a name="ln5029">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln5030">			BPose* pose = targetView-&gt;fSelectionList-&gt;ItemAt(index);</a>
<a name="ln5031"> </a>
<a name="ln5032">			// remove pose from VSlist before changing location</a>
<a name="ln5033">			// so that we &quot;find&quot; the correct pose to remove</a>
<a name="ln5034">			// need to do this because bsearch uses top of pose</a>
<a name="ln5035">			// to locate pose to remove</a>
<a name="ln5036">			targetView-&gt;RemoveFromVSList(pose);</a>
<a name="ln5037">			BPoint location (pose-&gt;Location(targetView) + delta);</a>
<a name="ln5038">			BRect oldBounds(pose-&gt;CalcRect(targetView));</a>
<a name="ln5039">			if (dropOnGrid) {</a>
<a name="ln5040">				location = targetView-&gt;PinToGrid(location, targetView-&gt;fGrid,</a>
<a name="ln5041">					targetView-&gt;fOffset);</a>
<a name="ln5042">			}</a>
<a name="ln5043"> </a>
<a name="ln5044">			// TODO: don't drop poses under desktop elements</a>
<a name="ln5045">			//		 ie: replicants, deskbar</a>
<a name="ln5046">			pose-&gt;MoveTo(location, targetView);</a>
<a name="ln5047"> </a>
<a name="ln5048">			targetView-&gt;RemoveFromExtent(oldBounds);</a>
<a name="ln5049">			targetView-&gt;AddToExtent(pose-&gt;CalcRect(targetView));</a>
<a name="ln5050"> </a>
<a name="ln5051">			// remove and reinsert pose to keep VSlist sorted</a>
<a name="ln5052">			targetView-&gt;AddToVSList(pose);</a>
<a name="ln5053">		}</a>
<a name="ln5054"> </a>
<a name="ln5055">		return;</a>
<a name="ln5056">	}</a>
<a name="ln5057"> </a>
<a name="ln5058">	BEntry* destEntry = new BEntry(destFolder-&gt;EntryRef());</a>
<a name="ln5059">	bool destIsTrash = destFolder-&gt;IsTrash();</a>
<a name="ln5060"> </a>
<a name="ln5061">	// perform asynchronous copy/move</a>
<a name="ln5062">	forceCopy = forceCopy || (modifiers() &amp; B_OPTION_KEY) != 0;</a>
<a name="ln5063"> </a>
<a name="ln5064">	bool okToMove = true;</a>
<a name="ln5065"> </a>
<a name="ln5066">	if (destFolder-&gt;IsRoot()) {</a>
<a name="ln5067">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln5068">			B_TRANSLATE(&quot;You must drop items on one of the disk icons &quot;</a>
<a name="ln5069">			&quot;in the \&quot;Disks\&quot; window.&quot;), B_TRANSLATE(&quot;Cancel&quot;), NULL, NULL,</a>
<a name="ln5070">			B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln5071">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln5072">		alert-&gt;Go();</a>
<a name="ln5073">		okToMove = false;</a>
<a name="ln5074">	}</a>
<a name="ln5075"> </a>
<a name="ln5076">	// can't copy items into the trash</a>
<a name="ln5077">	if (forceCopy &amp;&amp; destIsTrash) {</a>
<a name="ln5078">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln5079">			B_TRANSLATE(&quot;Sorry, you can't copy items to the Trash.&quot;),</a>
<a name="ln5080">			B_TRANSLATE(&quot;Cancel&quot;), NULL, NULL, B_WIDTH_AS_USUAL,</a>
<a name="ln5081">			B_WARNING_ALERT);</a>
<a name="ln5082">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln5083">		alert-&gt;Go();</a>
<a name="ln5084">		okToMove = false;</a>
<a name="ln5085">	}</a>
<a name="ln5086"> </a>
<a name="ln5087">	// can't create symlinks into the trash</a>
<a name="ln5088">	if (createLink &amp;&amp; destIsTrash) {</a>
<a name="ln5089">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln5090">			B_TRANSLATE(&quot;Sorry, you can't create links in the Trash.&quot;),</a>
<a name="ln5091">			B_TRANSLATE(&quot;Cancel&quot;), NULL, NULL, B_WIDTH_AS_USUAL,</a>
<a name="ln5092">			B_WARNING_ALERT);</a>
<a name="ln5093">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln5094">		alert-&gt;Go();</a>
<a name="ln5095">		okToMove = false;</a>
<a name="ln5096">	}</a>
<a name="ln5097"> </a>
<a name="ln5098">	// prompt user if drag was from a query</a>
<a name="ln5099">	if (srcWindow-&gt;TargetModel()-&gt;IsQuery()</a>
<a name="ln5100">		&amp;&amp; !forceCopy &amp;&amp; !destIsTrash &amp;&amp; !createLink) {</a>
<a name="ln5101">		srcWindow-&gt;UpdateIfNeeded();</a>
<a name="ln5102">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln5103">			B_TRANSLATE(&quot;Are you sure you want to move or copy the selected &quot;</a>
<a name="ln5104">			&quot;item(s) to this folder?&quot;), B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln5105">			B_TRANSLATE(&quot;Move&quot;), NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln5106">		alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln5107">		okToMove = alert-&gt;Go() == 1;</a>
<a name="ln5108">	}</a>
<a name="ln5109"> </a>
<a name="ln5110">	if (okToMove) {</a>
<a name="ln5111">		PoseList* selectionList = srcWindow-&gt;PoseView()-&gt;SelectionList();</a>
<a name="ln5112">		BList* pointList = destWindow-&gt;PoseView()-&gt;GetDropPointList(clickPoint,</a>
<a name="ln5113">			loc, selectionList, srcWindow-&gt;PoseView()-&gt;ViewMode() == kListMode,</a>
<a name="ln5114">			dropOnGrid);</a>
<a name="ln5115">		int32 selectionSize = selectionList-&gt;CountItems();</a>
<a name="ln5116">		BObjectList&lt;entry_ref&gt;* srcList</a>
<a name="ln5117">			= new BObjectList&lt;entry_ref&gt;(selectionSize, true);</a>
<a name="ln5118"> </a>
<a name="ln5119">		if (srcWindow-&gt;TargetModel()-&gt;IsVirtualDirectory()) {</a>
<a name="ln5120">			// resolve symlink and add the resulting entry_ref to the list</a>
<a name="ln5121">			for (int32 i = 0; i &lt; selectionSize; i++) {</a>
<a name="ln5122">				Model* model = selectionList-&gt;ItemAt(i)-&gt;ResolvedModel();</a>
<a name="ln5123">				if (model != NULL)</a>
<a name="ln5124">					srcList-&gt;AddItem(new entry_ref(*(model-&gt;EntryRef())));</a>
<a name="ln5125">			}</a>
<a name="ln5126">		} else</a>
<a name="ln5127">			CopySelectionListToEntryRefList(selectionList, srcList);</a>
<a name="ln5128"> </a>
<a name="ln5129">		uint32 moveMode;</a>
<a name="ln5130">		if (forceCopy)</a>
<a name="ln5131">			moveMode = kCopySelectionTo;</a>
<a name="ln5132">		else if (forceMove)</a>
<a name="ln5133">			moveMode = kMoveSelectionTo;</a>
<a name="ln5134">		else if (createRelativeLink)</a>
<a name="ln5135">			moveMode = kCreateRelativeLink;</a>
<a name="ln5136">		else if (createLink)</a>
<a name="ln5137">			moveMode = kCreateLink;</a>
<a name="ln5138">		else if (!CheckDevicesEqual(srcList-&gt;ItemAt(0), destFolder))</a>
<a name="ln5139">			moveMode = kCopySelectionTo;</a>
<a name="ln5140">		else</a>
<a name="ln5141">			moveMode = kMoveSelectionTo;</a>
<a name="ln5142"> </a>
<a name="ln5143">		FSMoveToFolder(srcList, destEntry, moveMode, pointList);</a>
<a name="ln5144">		return;</a>
<a name="ln5145">	}</a>
<a name="ln5146"> </a>
<a name="ln5147">	delete destEntry;</a>
<a name="ln5148">}</a>
<a name="ln5149"> </a>
<a name="ln5150"> </a>
<a name="ln5151">void</a>
<a name="ln5152">BPoseView::MoveSelectionTo(BPoint dropPoint, BPoint clickPoint,</a>
<a name="ln5153">	BContainerWindow* srcWindow)</a>
<a name="ln5154">{</a>
<a name="ln5155">	// Moves selection from srcWindow into this window, copying if necessary.</a>
<a name="ln5156"> </a>
<a name="ln5157">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln5158">	if (window == NULL)</a>
<a name="ln5159">		return;</a>
<a name="ln5160"> </a>
<a name="ln5161">	ASSERT(window-&gt;PoseView() != NULL);</a>
<a name="ln5162">	ASSERT(TargetModel() != NULL);</a>
<a name="ln5163"> </a>
<a name="ln5164">	// make sure this window is a legal drop target</a>
<a name="ln5165">	if (srcWindow != window &amp;&amp; !TargetModel()-&gt;IsDropTarget())</a>
<a name="ln5166">		return;</a>
<a name="ln5167"> </a>
<a name="ln5168">	uint32 buttons = (uint32)window-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;);</a>
<a name="ln5169">	bool pinToGrid = (modifiers() &amp; B_COMMAND_KEY) != 0;</a>
<a name="ln5170">	MoveSelectionInto(TargetModel(), srcWindow, window, buttons, dropPoint,</a>
<a name="ln5171">		false, false, false, false, clickPoint, pinToGrid);</a>
<a name="ln5172">}</a>
<a name="ln5173"> </a>
<a name="ln5174"> </a>
<a name="ln5175">inline void</a>
<a name="ln5176">UpdateWasBrokenSymlinkBinder(BPose* pose, Model* model, int32 index,</a>
<a name="ln5177">	BPoseView* poseView, BObjectList&lt;Model&gt;* fBrokenLinks)</a>
<a name="ln5178">{</a>
<a name="ln5179">	if (!model-&gt;IsSymLink())</a>
<a name="ln5180">		return;</a>
<a name="ln5181"> </a>
<a name="ln5182">	BPoint loc(0, index * poseView-&gt;ListElemHeight());</a>
<a name="ln5183">	pose-&gt;UpdateWasBrokenSymlink(loc, poseView);</a>
<a name="ln5184">	if (model-&gt;LinkTo() != NULL)</a>
<a name="ln5185">		fBrokenLinks-&gt;RemoveItem(model);</a>
<a name="ln5186">}</a>
<a name="ln5187"> </a>
<a name="ln5188"> </a>
<a name="ln5189">void</a>
<a name="ln5190">BPoseView::TryUpdatingBrokenLinks()</a>
<a name="ln5191">{</a>
<a name="ln5192">	AutoLock&lt;BWindow&gt; lock(Window());</a>
<a name="ln5193">	if (!lock)</a>
<a name="ln5194">		return;</a>
<a name="ln5195"> </a>
<a name="ln5196">	BObjectList&lt;Model&gt;* brokenLinksCopy = new BObjectList&lt;Model&gt;(*fBrokenLinks);</a>
<a name="ln5197"> </a>
<a name="ln5198">	// try fixing broken symlinks, and detecting broken ones.</a>
<a name="ln5199">	EachPoseAndModel(fPoseList, &amp;UpdateWasBrokenSymlinkBinder, this,</a>
<a name="ln5200">		fBrokenLinks);</a>
<a name="ln5201"> </a>
<a name="ln5202">	for (int i = brokenLinksCopy-&gt;CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln5203">		if (!fBrokenLinks-&gt;HasItem(brokenLinksCopy-&gt;ItemAt(i)))</a>
<a name="ln5204">			StopWatchingParentsOf(brokenLinksCopy-&gt;ItemAt(i)-&gt;EntryRef());</a>
<a name="ln5205">	}</a>
<a name="ln5206"> </a>
<a name="ln5207">	delete brokenLinksCopy;</a>
<a name="ln5208">}</a>
<a name="ln5209"> </a>
<a name="ln5210"> </a>
<a name="ln5211">void</a>
<a name="ln5212">BPoseView::PoseHandleDeviceUnmounted(BPose* pose, Model* model, int32 index,</a>
<a name="ln5213">	BPoseView* poseView, dev_t device)</a>
<a name="ln5214">{</a>
<a name="ln5215">	if (model-&gt;NodeRef()-&gt;device == device)</a>
<a name="ln5216">		poseView-&gt;DeletePose(model-&gt;NodeRef());</a>
<a name="ln5217">	else if (model-&gt;IsSymLink() &amp;&amp; model-&gt;LinkTo() != NULL</a>
<a name="ln5218">		&amp;&amp; model-&gt;LinkTo()-&gt;NodeRef()-&gt;device == device) {</a>
<a name="ln5219">		poseView-&gt;DeleteSymLinkPoseTarget(model-&gt;LinkTo()-&gt;NodeRef(),</a>
<a name="ln5220">			pose, index);</a>
<a name="ln5221">	}</a>
<a name="ln5222">}</a>
<a name="ln5223"> </a>
<a name="ln5224"> </a>
<a name="ln5225">static void</a>
<a name="ln5226">OneMetaMimeChanged(BPose* pose, Model* model, int32 index,</a>
<a name="ln5227">	BPoseView* poseView, const char* type)</a>
<a name="ln5228">{</a>
<a name="ln5229">	ASSERT(model != NULL);</a>
<a name="ln5230"> </a>
<a name="ln5231">	if (model-&gt;IconFrom() != kNode</a>
<a name="ln5232">		&amp;&amp; model-&gt;IconFrom() != kUnknownSource</a>
<a name="ln5233">		&amp;&amp; model-&gt;IconFrom() != kUnknownNotFromNode</a>
<a name="ln5234">		// TODO: add supertype compare</a>
<a name="ln5235">		&amp;&amp; strcasecmp(model-&gt;MimeType(), type) == 0) {</a>
<a name="ln5236">		// metamime change very likely affected the documents icon</a>
<a name="ln5237">		BPoint poseLoc(0, index * poseView-&gt;ListElemHeight());</a>
<a name="ln5238">		pose-&gt;UpdateIcon(poseLoc, poseView);</a>
<a name="ln5239">	}</a>
<a name="ln5240">}</a>
<a name="ln5241"> </a>
<a name="ln5242"> </a>
<a name="ln5243">void</a>
<a name="ln5244">BPoseView::MetaMimeChanged(const char* type, const char* preferredApp)</a>
<a name="ln5245">{</a>
<a name="ln5246">	IconCache::sIconCache-&gt;IconChanged(type, preferredApp);</a>
<a name="ln5247">	// wait for other windows to do the same before we start</a>
<a name="ln5248">	// updating poses which causes icon recaching</a>
<a name="ln5249">	// TODO: this is a design problem that should be solved differently</a>
<a name="ln5250">	snooze(10000);</a>
<a name="ln5251">	Window()-&gt;UpdateIfNeeded();</a>
<a name="ln5252"> </a>
<a name="ln5253">	EachPoseAndResolvedModel(fPoseList, &amp;OneMetaMimeChanged, this, type);</a>
<a name="ln5254">}</a>
<a name="ln5255"> </a>
<a name="ln5256"> </a>
<a name="ln5257">class MetaMimeChangedAccumulator : public AccumulatingFunctionObject {</a>
<a name="ln5258">// pools up matching metamime change notices, executing them as a single</a>
<a name="ln5259">// update</a>
<a name="ln5260">public:</a>
<a name="ln5261">	MetaMimeChangedAccumulator(void (BPoseView::*func)(const char* type,</a>
<a name="ln5262">		const char* preferredApp),</a>
<a name="ln5263">		BContainerWindow* window, const char* type, const char* preferredApp)</a>
<a name="ln5264">		:</a>
<a name="ln5265">		fCallOnThis(window),</a>
<a name="ln5266">		fFunc(func),</a>
<a name="ln5267">		fType(type),</a>
<a name="ln5268">		fPreferredApp(preferredApp)</a>
<a name="ln5269">	{</a>
<a name="ln5270">	}</a>
<a name="ln5271"> </a>
<a name="ln5272">	virtual bool CanAccumulate(const AccumulatingFunctionObject* functor) const</a>
<a name="ln5273">	{</a>
<a name="ln5274">		const MetaMimeChangedAccumulator* accumulator</a>
<a name="ln5275">			= dynamic_cast&lt;const MetaMimeChangedAccumulator*&gt;(functor);</a>
<a name="ln5276">		if (accumulator == NULL)</a>
<a name="ln5277">			return false;</a>
<a name="ln5278"> </a>
<a name="ln5279">		return accumulator &amp;&amp; accumulator-&gt;fType == fType</a>
<a name="ln5280">			&amp;&amp; accumulator-&gt;fPreferredApp == fPreferredApp;</a>
<a name="ln5281">	}</a>
<a name="ln5282"> </a>
<a name="ln5283">	virtual void Accumulate(AccumulatingFunctionObject* DEBUG_ONLY(functor))</a>
<a name="ln5284">	{</a>
<a name="ln5285">		ASSERT(CanAccumulate(functor));</a>
<a name="ln5286">		// do nothing, no further accumulating needed</a>
<a name="ln5287">	}</a>
<a name="ln5288"> </a>
<a name="ln5289">protected:</a>
<a name="ln5290">	virtual void operator()()</a>
<a name="ln5291">	{</a>
<a name="ln5292">		AutoLock&lt;BWindow&gt; lock(fCallOnThis);</a>
<a name="ln5293">		if (!lock)</a>
<a name="ln5294">			return;</a>
<a name="ln5295"> </a>
<a name="ln5296">		(fCallOnThis-&gt;PoseView()-&gt;*fFunc)(fType.String(),</a>
<a name="ln5297">			fPreferredApp.String());</a>
<a name="ln5298">	}</a>
<a name="ln5299"> </a>
<a name="ln5300">	virtual ulong Size() const</a>
<a name="ln5301">	{</a>
<a name="ln5302">		return sizeof (*this);</a>
<a name="ln5303">	}</a>
<a name="ln5304"> </a>
<a name="ln5305">private:</a>
<a name="ln5306">	BContainerWindow* fCallOnThis;</a>
<a name="ln5307">	void (BPoseView::*fFunc)(const char* type, const char* preferredApp);</a>
<a name="ln5308">	BString fType;</a>
<a name="ln5309">	BString fPreferredApp;</a>
<a name="ln5310">};</a>
<a name="ln5311"> </a>
<a name="ln5312"> </a>
<a name="ln5313">bool</a>
<a name="ln5314">BPoseView::NoticeMetaMimeChanged(const BMessage* message)</a>
<a name="ln5315">{</a>
<a name="ln5316">	int32 change;</a>
<a name="ln5317">	if (message-&gt;FindInt32(&quot;be:which&quot;, &amp;change) != B_OK)</a>
<a name="ln5318">		return true;</a>
<a name="ln5319"> </a>
<a name="ln5320">	bool iconChanged = (change &amp; B_ICON_CHANGED) != 0;</a>
<a name="ln5321">	bool iconForTypeChanged = (change &amp; B_ICON_FOR_TYPE_CHANGED) != 0;</a>
<a name="ln5322">	bool preferredAppChanged = (change &amp; B_APP_HINT_CHANGED)</a>
<a name="ln5323">		|| (change &amp; B_PREFERRED_APP_CHANGED);</a>
<a name="ln5324"> </a>
<a name="ln5325">	const char* type = NULL;</a>
<a name="ln5326">	const char* preferredApp = NULL;</a>
<a name="ln5327"> </a>
<a name="ln5328">	if (iconChanged || preferredAppChanged)</a>
<a name="ln5329">		message-&gt;FindString(&quot;be:type&quot;, &amp;type);</a>
<a name="ln5330"> </a>
<a name="ln5331">	if (iconForTypeChanged) {</a>
<a name="ln5332">		message-&gt;FindString(&quot;be:extra_type&quot;, &amp;type);</a>
<a name="ln5333">		message-&gt;FindString(&quot;be:type&quot;, &amp;preferredApp);</a>
<a name="ln5334">	}</a>
<a name="ln5335"> </a>
<a name="ln5336">	if (iconChanged || preferredAppChanged || iconForTypeChanged) {</a>
<a name="ln5337">		TaskLoop* taskLoop = ContainerWindow()-&gt;DelayedTaskLoop();</a>
<a name="ln5338">		ASSERT(taskLoop != NULL);</a>
<a name="ln5339">		taskLoop-&gt;AccumulatedRunLater(new MetaMimeChangedAccumulator(</a>
<a name="ln5340">			&amp;BPoseView::MetaMimeChanged, ContainerWindow(), type, preferredApp),</a>
<a name="ln5341">			200000, 5000000);</a>
<a name="ln5342">	}</a>
<a name="ln5343"> </a>
<a name="ln5344">	return true;</a>
<a name="ln5345">}</a>
<a name="ln5346"> </a>
<a name="ln5347"> </a>
<a name="ln5348">bool</a>
<a name="ln5349">BPoseView::FSNotification(const BMessage* message)</a>
<a name="ln5350">{</a>
<a name="ln5351">	node_ref itemNode;</a>
<a name="ln5352">	dev_t device;</a>
<a name="ln5353">	Model* targetModel = TargetModel();</a>
<a name="ln5354"> </a>
<a name="ln5355">	switch (message-&gt;FindInt32(&quot;opcode&quot;)) {</a>
<a name="ln5356">		case B_ENTRY_CREATED:</a>
<a name="ln5357">		{</a>
<a name="ln5358">			ASSERT(targetModel != NULL);</a>
<a name="ln5359"> </a>
<a name="ln5360">			message-&gt;FindInt32(&quot;device&quot;, &amp;itemNode.device);</a>
<a name="ln5361">			node_ref dirNode;</a>
<a name="ln5362">			dirNode.device = itemNode.device;</a>
<a name="ln5363">			message-&gt;FindInt64(&quot;directory&quot;, (int64*)&amp;dirNode.node);</a>
<a name="ln5364">			message-&gt;FindInt64(&quot;node&quot;, (int64*)&amp;itemNode.node);</a>
<a name="ln5365"> </a>
<a name="ln5366">			int32 count = fBrokenLinks-&gt;CountItems();</a>
<a name="ln5367">			bool createPose = true;</a>
<a name="ln5368">			// Query windows can get notices on different dirNodes</a>
<a name="ln5369">			// The Disks window can too</a>
<a name="ln5370">			// So can the Desktop, as long as the integrate flag is on</a>
<a name="ln5371">			TrackerSettings settings;</a>
<a name="ln5372">			if (targetModel != NULL &amp;&amp; dirNode != *targetModel-&gt;NodeRef()</a>
<a name="ln5373">				&amp;&amp; !targetModel-&gt;IsQuery()</a>
<a name="ln5374">				&amp;&amp; !targetModel-&gt;IsVirtualDirectory()</a>
<a name="ln5375">				&amp;&amp; !targetModel-&gt;IsRoot()</a>
<a name="ln5376">				&amp;&amp; (!settings.ShowDisksIcon() || !IsDesktopView())) {</a>
<a name="ln5377">				if (count == 0)</a>
<a name="ln5378">					break;</a>
<a name="ln5379">				createPose = false;</a>
<a name="ln5380">			}</a>
<a name="ln5381"> </a>
<a name="ln5382">			const char* name;</a>
<a name="ln5383">			if (message-&gt;FindString(&quot;name&quot;, &amp;name) != B_OK) {</a>
<a name="ln5384">#if DEBUG</a>
<a name="ln5385">				SERIAL_PRINT((&quot;no name in entry creation message\n&quot;));</a>
<a name="ln5386">#endif</a>
<a name="ln5387">				break;</a>
<a name="ln5388">			}</a>
<a name="ln5389">			if (count != 0) {</a>
<a name="ln5390">				// basically, let's say we have a broken link :</a>
<a name="ln5391">				// ./a_link -&gt; ./some_folder/another_folder/a_target</a>
<a name="ln5392">				// and that both some_folder and another_folder didn't</a>
<a name="ln5393">				// exist yet. We are looking if the just created folder</a>
<a name="ln5394">				// is 'some_folder' and watch it, expecting the creation of</a>
<a name="ln5395">				// 'another_folder' later and then report the link as fixed.</a>
<a name="ln5396">				Model* model = new Model(&amp;dirNode, &amp;itemNode, name);</a>
<a name="ln5397">				if (model-&gt;IsDirectory()) {</a>
<a name="ln5398">					BString createdPath(BPath(model-&gt;EntryRef()).Path());</a>
<a name="ln5399">					BDirectory currentDir(targetModel-&gt;EntryRef());</a>
<a name="ln5400">					BPath createdDir(model-&gt;EntryRef());</a>
<a name="ln5401">					for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln5402">						BSymLink link(fBrokenLinks-&gt;ItemAt(i)-&gt;EntryRef());</a>
<a name="ln5403">						BPath path;</a>
<a name="ln5404">						link.MakeLinkedPath(&amp;currentDir, &amp;path);</a>
<a name="ln5405">						BString pathStr(path.Path());</a>
<a name="ln5406">						pathStr.Append(&quot;/&quot;);</a>
<a name="ln5407">						if (pathStr.Compare(createdPath,</a>
<a name="ln5408">							createdPath.Length()) == 0) {</a>
<a name="ln5409">							if (pathStr[createdPath.Length()] != '/')</a>
<a name="ln5410">								break;</a>
<a name="ln5411">							StopWatchingParentsOf(fBrokenLinks-&gt;ItemAt(i)</a>
<a name="ln5412">								-&gt;EntryRef());</a>
<a name="ln5413">							watch_node(&amp;itemNode, B_WATCH_DIRECTORY, this);</a>
<a name="ln5414">							break;</a>
<a name="ln5415">						}</a>
<a name="ln5416">					}</a>
<a name="ln5417">				}</a>
<a name="ln5418">				delete model;</a>
<a name="ln5419">			}</a>
<a name="ln5420">			if (createPose)</a>
<a name="ln5421">				EntryCreated(&amp;dirNode, &amp;itemNode, name);</a>
<a name="ln5422"> </a>
<a name="ln5423">			TryUpdatingBrokenLinks();</a>
<a name="ln5424">			break;</a>
<a name="ln5425">		}</a>
<a name="ln5426"> </a>
<a name="ln5427">		case B_ENTRY_MOVED:</a>
<a name="ln5428">			return EntryMoved(message);</a>
<a name="ln5429">			break;</a>
<a name="ln5430"> </a>
<a name="ln5431">		case B_ENTRY_REMOVED:</a>
<a name="ln5432">			message-&gt;FindInt32(&quot;device&quot;, &amp;itemNode.device);</a>
<a name="ln5433">			message-&gt;FindInt64(&quot;node&quot;, (int64*)&amp;itemNode.node);</a>
<a name="ln5434"> </a>
<a name="ln5435">			// our window itself may be deleted</a>
<a name="ln5436">			// we must check to see if this comes as a query</a>
<a name="ln5437">			// notification or a node monitor notification because</a>
<a name="ln5438">			// if it's a query notification then we're just being told we</a>
<a name="ln5439">			// no longer match the query, so we don't want to close the window</a>
<a name="ln5440">			// but it's a node monitor notification then that means our query</a>
<a name="ln5441">			// file has been deleted so we close the window</a>
<a name="ln5442"> </a>
<a name="ln5443">			if (message-&gt;what == B_NODE_MONITOR &amp;&amp; targetModel != NULL</a>
<a name="ln5444">				&amp;&amp; *(targetModel-&gt;NodeRef()) == itemNode) {</a>
<a name="ln5445">				if (!targetModel-&gt;IsRoot()) {</a>
<a name="ln5446">					// it is impossible to watch for ENTRY_REMOVED in</a>
<a name="ln5447">					// &quot;/&quot; because the notification is ambiguous - the vnode</a>
<a name="ln5448">					// is that of the volume but the device is of the parent</a>
<a name="ln5449">					// not the same as the device of the volume that way we</a>
<a name="ln5450">					// may get aliasing for volumes with vnodes of 1</a>
<a name="ln5451">					// (currently the case for iso9660)</a>
<a name="ln5452">					DisableSaveLocation();</a>
<a name="ln5453">					Window()-&gt;Close();</a>
<a name="ln5454">				}</a>
<a name="ln5455">			} else {</a>
<a name="ln5456">				int32 index;</a>
<a name="ln5457">				BPose* pose = fPoseList-&gt;FindPose(&amp;itemNode, &amp;index);</a>
<a name="ln5458">				if (pose == NULL) {</a>
<a name="ln5459">					// couldn't find pose, first check if the node might be</a>
<a name="ln5460">					// target of a symlink pose;</a>
<a name="ln5461">					//</a>
<a name="ln5462">					// What happens when a node and a symlink to it are in the</a>
<a name="ln5463">					// same window?</a>
<a name="ln5464">					// They get monitored twice, we get two notifications; the</a>
<a name="ln5465">					// first one will get caught by the first FindPose, the</a>
<a name="ln5466">					// second one by the DeepFindPose</a>
<a name="ln5467">					//</a>
<a name="ln5468">					pose = fPoseList-&gt;DeepFindPose(&amp;itemNode, &amp;index);</a>
<a name="ln5469">					if (pose != NULL) {</a>
<a name="ln5470">						DeleteSymLinkPoseTarget(&amp;itemNode, pose, index);</a>
<a name="ln5471">						break;</a>
<a name="ln5472">					}</a>
<a name="ln5473">				}</a>
<a name="ln5474"> </a>
<a name="ln5475">			 	DeletePose(&amp;itemNode);</a>
<a name="ln5476">				TryUpdatingBrokenLinks();</a>
<a name="ln5477">			}</a>
<a name="ln5478">			break;</a>
<a name="ln5479"> </a>
<a name="ln5480">		case B_DEVICE_MOUNTED:</a>
<a name="ln5481">		{</a>
<a name="ln5482">			if (message-&gt;FindInt32(&quot;new device&quot;, &amp;device) != B_OK)</a>
<a name="ln5483">				break;</a>
<a name="ln5484"> </a>
<a name="ln5485">			if (targetModel != NULL &amp;&amp; targetModel-&gt;IsRoot()) {</a>
<a name="ln5486">				BVolume volume(device);</a>
<a name="ln5487">				if (volume.InitCheck() == B_OK)</a>
<a name="ln5488">					CreateVolumePose(&amp;volume, false);</a>
<a name="ln5489">			} else if (ContainerWindow()-&gt;IsTrash()) {</a>
<a name="ln5490">				// add trash items from newly mounted volume</a>
<a name="ln5491"> </a>
<a name="ln5492">				BDirectory trashDir;</a>
<a name="ln5493">				BEntry entry;</a>
<a name="ln5494">				BVolume volume(device);</a>
<a name="ln5495">				if (FSGetTrashDir(&amp;trashDir, volume.Device()) == B_OK</a>
<a name="ln5496">					&amp;&amp; trashDir.GetEntry(&amp;entry) == B_OK) {</a>
<a name="ln5497">					Model model(&amp;entry);</a>
<a name="ln5498">					if (model.InitCheck() == B_OK)</a>
<a name="ln5499">						AddPoses(&amp;model);</a>
<a name="ln5500">				}</a>
<a name="ln5501">			}</a>
<a name="ln5502">			TaskLoop* taskLoop = ContainerWindow()-&gt;DelayedTaskLoop();</a>
<a name="ln5503">			ASSERT(taskLoop);</a>
<a name="ln5504">			taskLoop-&gt;RunLater(NewMemberFunctionObject(</a>
<a name="ln5505">				&amp;BPoseView::TryUpdatingBrokenLinks, this), 500000);</a>
<a name="ln5506">				// delay of 500000: wait for volumes to properly finish mounting</a>
<a name="ln5507">				// without this in the Model::FinishSettingUpType a symlink</a>
<a name="ln5508">				// to a volume would get initialized as a symlink to a directory</a>
<a name="ln5509">				// because IsRootDirectory looks like returns false. Either</a>
<a name="ln5510">				// there is a race condition or I was doing something wrong.</a>
<a name="ln5511">			break;</a>
<a name="ln5512">		}</a>
<a name="ln5513"> </a>
<a name="ln5514">		case B_DEVICE_UNMOUNTED:</a>
<a name="ln5515">			if (message-&gt;FindInt32(&quot;device&quot;, &amp;device) == B_OK) {</a>
<a name="ln5516">				if (targetModel != NULL</a>
<a name="ln5517">					&amp;&amp; targetModel-&gt;NodeRef()-&gt;device == device) {</a>
<a name="ln5518">					// close the window from a volume that is gone</a>
<a name="ln5519">					DisableSaveLocation();</a>
<a name="ln5520">					Window()-&gt;Close();</a>
<a name="ln5521">				} else if (targetModel != NULL) {</a>
<a name="ln5522">					EachPoseAndModel(fPoseList, &amp;PoseHandleDeviceUnmounted,</a>
<a name="ln5523">						this, device);</a>
<a name="ln5524">				}</a>
<a name="ln5525">			}</a>
<a name="ln5526">			break;</a>
<a name="ln5527"> </a>
<a name="ln5528">		case B_STAT_CHANGED:</a>
<a name="ln5529">		case B_ATTR_CHANGED:</a>
<a name="ln5530">			return AttributeChanged(message);</a>
<a name="ln5531">	}</a>
<a name="ln5532"> </a>
<a name="ln5533">	return true;</a>
<a name="ln5534">}</a>
<a name="ln5535"> </a>
<a name="ln5536"> </a>
<a name="ln5537">bool</a>
<a name="ln5538">BPoseView::CreateSymlinkPoseTarget(Model* symlink)</a>
<a name="ln5539">{</a>
<a name="ln5540">	Model* newResolvedModel = NULL;</a>
<a name="ln5541">	Model* result = symlink-&gt;LinkTo();</a>
<a name="ln5542"> </a>
<a name="ln5543">	if (result == NULL) {</a>
<a name="ln5544">		BEntry entry(symlink-&gt;EntryRef(), true);</a>
<a name="ln5545">		if (entry.InitCheck() == B_OK) {</a>
<a name="ln5546">			node_ref nref;</a>
<a name="ln5547">			entry_ref eref;</a>
<a name="ln5548">			entry.GetNodeRef(&amp;nref);</a>
<a name="ln5549">			entry.GetRef(&amp;eref);</a>
<a name="ln5550">			if (eref.directory != TargetModel()-&gt;NodeRef()-&gt;node)</a>
<a name="ln5551">				WatchNewNode(&amp;nref, B_WATCH_STAT | B_WATCH_ATTR | B_WATCH_NAME</a>
<a name="ln5552">					| B_WATCH_INTERIM_STAT, this);</a>
<a name="ln5553">			newResolvedModel = new Model(&amp;entry, true);</a>
<a name="ln5554">		} else {</a>
<a name="ln5555">			fBrokenLinks-&gt;AddItem(symlink);</a>
<a name="ln5556">			WatchParentOf(symlink-&gt;EntryRef());</a>
<a name="ln5557">			return true;</a>
<a name="ln5558">		}</a>
<a name="ln5559">		result = newResolvedModel;</a>
<a name="ln5560">	}</a>
<a name="ln5561">	symlink-&gt;SetLinkTo(result);</a>
<a name="ln5562"> </a>
<a name="ln5563">	return true;</a>
<a name="ln5564">}</a>
<a name="ln5565"> </a>
<a name="ln5566"> </a>
<a name="ln5567">BPose*</a>
<a name="ln5568">BPoseView::EntryCreated(const node_ref* dirNode, const node_ref* itemNode,</a>
<a name="ln5569">	const char* name, int32* indexPtr)</a>
<a name="ln5570">{</a>
<a name="ln5571">	// reject notification if pose already exists</a>
<a name="ln5572">	if (fPoseList-&gt;FindPose(itemNode) || FindZombie(itemNode))</a>
<a name="ln5573">		return NULL;</a>
<a name="ln5574"> </a>
<a name="ln5575">	BPoseView::WatchNewNode(itemNode);</a>
<a name="ln5576">		// have to node monitor ahead of time because Model will</a>
<a name="ln5577">		// cache up the file type and preferred app</a>
<a name="ln5578">	Model* model = new Model(dirNode, itemNode, name, true);</a>
<a name="ln5579"> </a>
<a name="ln5580">	if (model-&gt;InitCheck() != B_OK) {</a>
<a name="ln5581">		// if we have trouble setting up model then we stuff it into</a>
<a name="ln5582">		// a zombie list in a half-alive state until we can properly awaken it</a>
<a name="ln5583">		PRINT((&quot;2 adding model %s to zombie list, error %s\n&quot;, model-&gt;Name(),</a>
<a name="ln5584">			strerror(model-&gt;InitCheck())));</a>
<a name="ln5585">		fZombieList-&gt;AddItem(model);</a>
<a name="ln5586">		return NULL;</a>
<a name="ln5587">	}</a>
<a name="ln5588"> </a>
<a name="ln5589">	PoseInfo poseInfo;</a>
<a name="ln5590">	ReadPoseInfo(model, &amp;poseInfo);</a>
<a name="ln5591"> </a>
<a name="ln5592">	if (!PoseVisible(model, &amp;poseInfo)) {</a>
<a name="ln5593">		watch_node(model-&gt;NodeRef(), B_STOP_WATCHING, this);</a>
<a name="ln5594">		delete model;</a>
<a name="ln5595">		return NULL;</a>
<a name="ln5596">	}</a>
<a name="ln5597"> </a>
<a name="ln5598">	// model is a symlink, cache up the symlink target or scrap</a>
<a name="ln5599">	// everything if target is invisible</a>
<a name="ln5600">	if (model-&gt;IsSymLink() &amp;&amp; !CreateSymlinkPoseTarget(model)) {</a>
<a name="ln5601">		watch_node(model-&gt;NodeRef(), B_STOP_WATCHING, this);</a>
<a name="ln5602">		delete model;</a>
<a name="ln5603">		return NULL;</a>
<a name="ln5604">	}</a>
<a name="ln5605"> </a>
<a name="ln5606">	return CreatePose(model, &amp;poseInfo, true, indexPtr);</a>
<a name="ln5607">}</a>
<a name="ln5608"> </a>
<a name="ln5609"> </a>
<a name="ln5610">bool</a>
<a name="ln5611">BPoseView::EntryMoved(const BMessage* message)</a>
<a name="ln5612">{</a>
<a name="ln5613">	ino_t oldDir;</a>
<a name="ln5614">	node_ref dirNode;</a>
<a name="ln5615">	node_ref itemNode;</a>
<a name="ln5616"> </a>
<a name="ln5617">	message-&gt;FindInt32(&quot;device&quot;, &amp;dirNode.device);</a>
<a name="ln5618">	itemNode.device = dirNode.device;</a>
<a name="ln5619">	message-&gt;FindInt64(&quot;to directory&quot;, (int64*)&amp;dirNode.node);</a>
<a name="ln5620">	message-&gt;FindInt64(&quot;node&quot;, (int64*)&amp;itemNode.node);</a>
<a name="ln5621">	message-&gt;FindInt64(&quot;from directory&quot;, (int64*)&amp;oldDir);</a>
<a name="ln5622"> </a>
<a name="ln5623">	const char* name;</a>
<a name="ln5624">	if (message-&gt;FindString(&quot;name&quot;, &amp;name) != B_OK)</a>
<a name="ln5625">		return true;</a>
<a name="ln5626"> </a>
<a name="ln5627">	// handle special case of notifying a name change for a volume</a>
<a name="ln5628">	// - the notification is not enough, because the volume's device</a>
<a name="ln5629">	// is different than that of the root directory; we have to do a</a>
<a name="ln5630">	// lookup using the new volume name and get the volume device from there</a>
<a name="ln5631">	StatStruct st;</a>
<a name="ln5632">	// get the inode of the root and check if we got a notification on it</a>
<a name="ln5633">	if (stat(&quot;/&quot;, &amp;st) &gt;= 0</a>
<a name="ln5634">		&amp;&amp; st.st_dev == dirNode.device</a>
<a name="ln5635">		&amp;&amp; st.st_ino == dirNode.node) {</a>
<a name="ln5636">		BString buffer;</a>
<a name="ln5637">		buffer &lt;&lt; &quot;/&quot; &lt;&lt; name;</a>
<a name="ln5638">		if (stat(buffer.String(), &amp;st) &gt;= 0) {</a>
<a name="ln5639">			// point the dirNode to the actual volume</a>
<a name="ln5640">			itemNode.node = st.st_ino;</a>
<a name="ln5641">			itemNode.device = st.st_dev;</a>
<a name="ln5642">		}</a>
<a name="ln5643">	}</a>
<a name="ln5644"> </a>
<a name="ln5645">	Model* targetModel = TargetModel();</a>
<a name="ln5646">	ThrowOnAssert(targetModel != NULL);</a>
<a name="ln5647"> </a>
<a name="ln5648">	node_ref thisDirNode;</a>
<a name="ln5649">	if (ContainerWindow()-&gt;IsTrash()) {</a>
<a name="ln5650">		BDirectory trashDir;</a>
<a name="ln5651">		if (FSGetTrashDir(&amp;trashDir, itemNode.device) != B_OK)</a>
<a name="ln5652">			return true;</a>
<a name="ln5653"> </a>
<a name="ln5654">		trashDir.GetNodeRef(&amp;thisDirNode);</a>
<a name="ln5655">	} else</a>
<a name="ln5656">		thisDirNode = *targetModel-&gt;NodeRef();</a>
<a name="ln5657"> </a>
<a name="ln5658">	// see if we need to update window title (and folder itself)</a>
<a name="ln5659">	if (thisDirNode == itemNode) {</a>
<a name="ln5660">		targetModel-&gt;UpdateEntryRef(&amp;dirNode, name);</a>
<a name="ln5661">		assert_cast&lt;BContainerWindow*&gt;(Window())-&gt;UpdateTitle();</a>
<a name="ln5662">	}</a>
<a name="ln5663"> </a>
<a name="ln5664">	if (oldDir == dirNode.node || targetModel-&gt;IsQuery()</a>
<a name="ln5665">		|| targetModel-&gt;IsVirtualDirectory()) {</a>
<a name="ln5666">		// rename or move of entry in this directory (or query)</a>
<a name="ln5667"> </a>
<a name="ln5668">		int32 index;</a>
<a name="ln5669">		BPose* pose = fPoseList-&gt;FindPose(&amp;itemNode, &amp;index);</a>
<a name="ln5670">		int32 poseListIndex = index;</a>
<a name="ln5671">		bool visible = true;</a>
<a name="ln5672">		if (fFiltering)</a>
<a name="ln5673">			visible = fFilteredPoseList-&gt;FindPose(&amp;itemNode, &amp;index) != NULL;</a>
<a name="ln5674"> </a>
<a name="ln5675">		if (pose != NULL) {</a>
<a name="ln5676">			Model* poseModel = pose-&gt;TargetModel();</a>
<a name="ln5677">			ASSERT(poseModel != NULL);</a>
<a name="ln5678">			poseModel-&gt;UpdateEntryRef(&amp;dirNode, name);</a>
<a name="ln5679">			// for queries we check for move to trash and remove item if so</a>
<a name="ln5680">			if (targetModel-&gt;IsQuery()) {</a>
<a name="ln5681">				PoseInfo poseInfo;</a>
<a name="ln5682">				ReadPoseInfo(poseModel, &amp;poseInfo);</a>
<a name="ln5683">				if (!ShouldShowPose(poseModel, &amp;poseInfo))</a>
<a name="ln5684">					return DeletePose(&amp;itemNode, pose, index);</a>
<a name="ln5685">				return true;</a>
<a name="ln5686">			}</a>
<a name="ln5687"> </a>
<a name="ln5688">			BPoint loc(0, index * fListElemHeight);</a>
<a name="ln5689">			// if we get a rename then we need to assume that we might</a>
<a name="ln5690">			// have missed some other attr changed notifications so we</a>
<a name="ln5691">			// recheck all widgets</a>
<a name="ln5692">			if (poseModel-&gt;OpenNode() == B_OK) {</a>
<a name="ln5693">				pose-&gt;UpdateAllWidgets(index, loc, this);</a>
<a name="ln5694">				poseModel-&gt;CloseNode();</a>
<a name="ln5695">				_CheckPoseSortOrder(fPoseList, pose, poseListIndex);</a>
<a name="ln5696">				if (fFiltering) {</a>
<a name="ln5697">					if (!visible &amp;&amp; FilterPose(pose)) {</a>
<a name="ln5698">						BRect bounds = Bounds();</a>
<a name="ln5699">						float scrollBy = 0;</a>
<a name="ln5700">						AddPoseToList(fFilteredPoseList, true, true, pose,</a>
<a name="ln5701">							bounds, scrollBy, true);</a>
<a name="ln5702">					} else if (visible &amp;&amp; !FilterPose(pose))</a>
<a name="ln5703">						RemoveFilteredPose(pose, index);</a>
<a name="ln5704">					else if (visible)</a>
<a name="ln5705">						_CheckPoseSortOrder(fFilteredPoseList, pose, index);</a>
<a name="ln5706">				}</a>
<a name="ln5707">			}</a>
<a name="ln5708">		} else {</a>
<a name="ln5709">			// also must watch for renames on zombies</a>
<a name="ln5710">			Model* zombie = FindZombie(&amp;itemNode, &amp;index);</a>
<a name="ln5711">			if (zombie) {</a>
<a name="ln5712">				PRINT((&quot;converting model %s from a zombie\n&quot;, zombie-&gt;Name()));</a>
<a name="ln5713">				zombie-&gt;UpdateEntryRef(&amp;dirNode, name);</a>
<a name="ln5714">				pose = ConvertZombieToPose(zombie, index);</a>
<a name="ln5715">			} else</a>
<a name="ln5716">				return false;</a>
<a name="ln5717">		}</a>
<a name="ln5718">		if (pose != NULL)</a>
<a name="ln5719">			pendingNodeMonitorCache.PoseCreatedOrMoved(this, pose);</a>
<a name="ln5720">	} else if (oldDir == thisDirNode.node)</a>
<a name="ln5721">		DeletePose(&amp;itemNode);</a>
<a name="ln5722">	else if (dirNode.node == thisDirNode.node)</a>
<a name="ln5723">		EntryCreated(&amp;dirNode, &amp;itemNode, name);</a>
<a name="ln5724"> </a>
<a name="ln5725">	TryUpdatingBrokenLinks();</a>
<a name="ln5726"> </a>
<a name="ln5727">	return true;</a>
<a name="ln5728">}</a>
<a name="ln5729"> </a>
<a name="ln5730"> </a>
<a name="ln5731">void</a>
<a name="ln5732">BPoseView::WatchParentOf(const entry_ref* ref)</a>
<a name="ln5733">{</a>
<a name="ln5734">	BPath currentDir(ref);</a>
<a name="ln5735">	currentDir.GetParent(&amp;currentDir);</a>
<a name="ln5736">	BSymLink symlink(ref);</a>
<a name="ln5737">	BPath path;</a>
<a name="ln5738"> </a>
<a name="ln5739">	symlink.MakeLinkedPath(currentDir.Path(), &amp;path);</a>
<a name="ln5740">	status_t status = path.GetParent(&amp;path);</a>
<a name="ln5741"> </a>
<a name="ln5742">	while (status == B_BAD_VALUE)</a>
<a name="ln5743">		status = path.GetParent(&amp;path);</a>
<a name="ln5744"> </a>
<a name="ln5745">	if (status == B_ENTRY_NOT_FOUND)</a>
<a name="ln5746">		return;</a>
<a name="ln5747"> </a>
<a name="ln5748">	node_ref nref;</a>
<a name="ln5749">	BNode(path.Path()).GetNodeRef(&amp;nref);</a>
<a name="ln5750"> </a>
<a name="ln5751">	if (nref != *TargetModel()-&gt;NodeRef())</a>
<a name="ln5752">		watch_node(&amp;nref, B_WATCH_DIRECTORY, this);</a>
<a name="ln5753">}</a>
<a name="ln5754"> </a>
<a name="ln5755"> </a>
<a name="ln5756">void</a>
<a name="ln5757">BPoseView::StopWatchingParentsOf(const entry_ref* ref)</a>
<a name="ln5758">{</a>
<a name="ln5759">	BPath path;</a>
<a name="ln5760">	BSymLink symlink(ref);</a>
<a name="ln5761">	BPath currentDir(ref);</a>
<a name="ln5762">	currentDir.GetParent(&amp;currentDir);</a>
<a name="ln5763">	symlink.MakeLinkedPath(currentDir.Path(), &amp;path);</a>
<a name="ln5764"> </a>
<a name="ln5765">	if (path.InitCheck() != B_OK)</a>
<a name="ln5766">		return;</a>
<a name="ln5767"> </a>
<a name="ln5768">	BObjectList&lt;Model&gt;* brokenLinksCopy = new BObjectList&lt;Model&gt;(*fBrokenLinks);</a>
<a name="ln5769">	int32 count = brokenLinksCopy-&gt;CountItems();</a>
<a name="ln5770"> </a>
<a name="ln5771">	while (path.GetParent(&amp;path) == B_OK) {</a>
<a name="ln5772">		if (strcmp(path.Path(), &quot;/&quot;) == 0)</a>
<a name="ln5773">			break;</a>
<a name="ln5774"> </a>
<a name="ln5775">		BNode dir(path.Path());</a>
<a name="ln5776">		node_ref dirNode;</a>
<a name="ln5777">		dir.GetNodeRef(&amp;dirNode);</a>
<a name="ln5778"> </a>
<a name="ln5779">		// don't stop watching yourself.</a>
<a name="ln5780">		if (dirNode == *TargetModel()-&gt;NodeRef())</a>
<a name="ln5781">			continue;</a>
<a name="ln5782"> </a>
<a name="ln5783">		// make sure we don't have another broken links that still requires</a>
<a name="ln5784">		// to watch this directory</a>
<a name="ln5785">		bool keep = false;</a>
<a name="ln5786">		for (int32 i = count - 1; i &gt;= 0; i--) {</a>
<a name="ln5787">			BSymLink link(brokenLinksCopy-&gt;ItemAt(i)-&gt;EntryRef());</a>
<a name="ln5788">			BPath absolutePath;</a>
<a name="ln5789">			link.MakeLinkedPath(currentDir.Path(), &amp;absolutePath);</a>
<a name="ln5790">			if (BString(absolutePath.Path()).Compare(path.Path(),</a>
<a name="ln5791">					strlen(path.Path())) == 0) {</a>
<a name="ln5792">				// a broken link still needs to watch this folder, but</a>
<a name="ln5793">				// don't let that same link also watch a deeper parent.</a>
<a name="ln5794">				brokenLinksCopy-&gt;RemoveItemAt(i);</a>
<a name="ln5795">				count--;</a>
<a name="ln5796">				keep = true;</a>
<a name="ln5797">			}</a>
<a name="ln5798">		}</a>
<a name="ln5799">		if (!keep)</a>
<a name="ln5800">			watch_node(&amp;dirNode, B_STOP_WATCHING, this);</a>
<a name="ln5801">	}</a>
<a name="ln5802">	delete brokenLinksCopy;</a>
<a name="ln5803">}</a>
<a name="ln5804"> </a>
<a name="ln5805"> </a>
<a name="ln5806">bool</a>
<a name="ln5807">BPoseView::AttributeChanged(const BMessage* message)</a>
<a name="ln5808">{</a>
<a name="ln5809">	node_ref itemNode;</a>
<a name="ln5810">	message-&gt;FindInt32(&quot;device&quot;, &amp;itemNode.device);</a>
<a name="ln5811">	message-&gt;FindInt64(&quot;node&quot;, (int64*)&amp;itemNode.node);</a>
<a name="ln5812"> </a>
<a name="ln5813">	const char* attrName;</a>
<a name="ln5814">	if (message-&gt;FindString(&quot;attr&quot;, &amp;attrName) != B_OK)</a>
<a name="ln5815">		attrName = NULL;</a>
<a name="ln5816"> </a>
<a name="ln5817">	Model* targetModel = TargetModel();</a>
<a name="ln5818">	if (targetModel != NULL &amp;&amp; *targetModel-&gt;NodeRef() == itemNode</a>
<a name="ln5819">		&amp;&amp; targetModel-&gt;IsNodeOpen()</a>
<a name="ln5820">		&amp;&amp; targetModel-&gt;AttrChanged(attrName)) {</a>
<a name="ln5821">		// the icon of our target has changed, update drag icon</a>
<a name="ln5822">		// TODO: make this simpler (i.e. store the icon with the window)</a>
<a name="ln5823">		BView* view = Window()-&gt;FindView(&quot;MenuBar&quot;);</a>
<a name="ln5824">		if (view != NULL) {</a>
<a name="ln5825">			view = view-&gt;FindView(&quot;ThisContainer&quot;);</a>
<a name="ln5826">			if (view != NULL) {</a>
<a name="ln5827">				IconCache::sIconCache-&gt;IconChanged(targetModel);</a>
<a name="ln5828">				view-&gt;Invalidate();</a>
<a name="ln5829">			}</a>
<a name="ln5830">		}</a>
<a name="ln5831">	}</a>
<a name="ln5832"> </a>
<a name="ln5833">	int32 index;</a>
<a name="ln5834">	attr_info info;</a>
<a name="ln5835">	PoseList* posesFound = fPoseList-&gt;FindAllPoses(&amp;itemNode);</a>
<a name="ln5836">	int32 posesCount = posesFound-&gt;CountItems();</a>
<a name="ln5837">	for (int i = 0; i &lt; posesCount; i++) {</a>
<a name="ln5838">		BPose* pose = posesFound-&gt;ItemAt(i);</a>
<a name="ln5839">		Model* poseModel = pose-&gt;TargetModel();</a>
<a name="ln5840">		if (poseModel-&gt;IsSymLink() &amp;&amp; *(poseModel-&gt;NodeRef()) != itemNode) {</a>
<a name="ln5841">			// change happened on symlink's target</a>
<a name="ln5842">			poseModel = poseModel-&gt;ResolveIfLink();</a>
<a name="ln5843">		}</a>
<a name="ln5844">		ASSERT(poseModel != NULL);</a>
<a name="ln5845"> </a>
<a name="ln5846">		status_t result = B_OK;</a>
<a name="ln5847">		for (int32 count = 0; count &lt; 100; count++) {</a>
<a name="ln5848">			// if node is busy, wait a little, it may be in the</a>
<a name="ln5849">			// middle of mimeset and we wan't to pick up the changes</a>
<a name="ln5850">			result = poseModel-&gt;OpenNode();</a>
<a name="ln5851">			if (result == B_OK || result != B_BUSY)</a>
<a name="ln5852">				break;</a>
<a name="ln5853"> </a>
<a name="ln5854">			PRINT((&quot;poseModel %s busy, retrying in a bit\n&quot;,</a>
<a name="ln5855">				poseModel-&gt;Name()));</a>
<a name="ln5856">			snooze(10000);</a>
<a name="ln5857">		}</a>
<a name="ln5858">		if (result != B_OK) {</a>
<a name="ln5859">			PRINT((&quot;Cache Error %s\n&quot;, strerror(result)));</a>
<a name="ln5860">			continue;</a>
<a name="ln5861">		}</a>
<a name="ln5862"> </a>
<a name="ln5863">		bool visible = fPoseList-&gt;FindPose(poseModel-&gt;NodeRef(),</a>
<a name="ln5864">			&amp;index) != NULL;</a>
<a name="ln5865">		int32 poseListIndex = index;</a>
<a name="ln5866"> </a>
<a name="ln5867">		if (fFiltering) {</a>
<a name="ln5868">			visible = fFilteredPoseList-&gt;FindPose(</a>
<a name="ln5869">				poseModel-&gt;NodeRef(), &amp;index) != NULL;</a>
<a name="ln5870">		}</a>
<a name="ln5871"> </a>
<a name="ln5872">		BPoint loc(0, index * fListElemHeight);</a>
<a name="ln5873">		if (attrName != NULL &amp;&amp; poseModel-&gt;Node() != NULL) {</a>
<a name="ln5874">			memset(&amp;info, 0, sizeof(attr_info));</a>
<a name="ln5875">			// the call below might fail if the attribute has been removed</a>
<a name="ln5876">			poseModel-&gt;Node()-&gt;GetAttrInfo(attrName, &amp;info);</a>
<a name="ln5877">			pose-&gt;UpdateWidgetAndModel(poseModel, attrName, info.type, index,</a>
<a name="ln5878">				loc, this, visible);</a>
<a name="ln5879">			if (strcmp(attrName, kAttrMIMEType) == 0)</a>
<a name="ln5880">				RefreshMimeTypeList();</a>
<a name="ln5881">		} else {</a>
<a name="ln5882">			pose-&gt;UpdateWidgetAndModel(poseModel, 0, 0, index, loc, this,</a>
<a name="ln5883">				visible);</a>
<a name="ln5884">		}</a>
<a name="ln5885">		poseModel-&gt;CloseNode();</a>
<a name="ln5886">		if (fFiltering) {</a>
<a name="ln5887">			if (!visible &amp;&amp; FilterPose(pose)) {</a>
<a name="ln5888">				visible = true;</a>
<a name="ln5889">				float scrollBy = 0;</a>
<a name="ln5890">				BRect bounds = Bounds();</a>
<a name="ln5891">				AddPoseToList(fFilteredPoseList, true, true, pose, bounds,</a>
<a name="ln5892">					scrollBy, true);</a>
<a name="ln5893">				continue;</a>
<a name="ln5894">			} else if (visible &amp;&amp; !FilterPose(pose)) {</a>
<a name="ln5895">				RemoveFilteredPose(pose, index);</a>
<a name="ln5896">				continue;</a>
<a name="ln5897">			}</a>
<a name="ln5898">		}</a>
<a name="ln5899"> </a>
<a name="ln5900">		if (attrName != NULL) {</a>
<a name="ln5901">			// note: the following code is wrong, because this sort of hashing</a>
<a name="ln5902">			// may overlap and we get aliasing</a>
<a name="ln5903">			uint32 attrHash = AttrHashString(attrName, info.type);</a>
<a name="ln5904">			if (attrHash == PrimarySort() || attrHash == SecondarySort()) {</a>
<a name="ln5905">				_CheckPoseSortOrder(fPoseList, pose, poseListIndex);</a>
<a name="ln5906">				if (fFiltering &amp;&amp; visible)</a>
<a name="ln5907">					_CheckPoseSortOrder(fFilteredPoseList, pose, index);</a>
<a name="ln5908">			}</a>
<a name="ln5909">		} else {</a>
<a name="ln5910">			int32 fields;</a>
<a name="ln5911">			if (message-&gt;FindInt32(&quot;fields&quot;, &amp;fields) != B_OK)</a>
<a name="ln5912">				continue;</a>
<a name="ln5913"> </a>
<a name="ln5914">			for (int i = sizeof(sAttrColumnMap) / sizeof(attr_column_relation);</a>
<a name="ln5915">					i--;) {</a>
<a name="ln5916">				if (sAttrColumnMap[i].attrHash == PrimarySort()</a>
<a name="ln5917">					|| sAttrColumnMap[i].attrHash == SecondarySort()) {</a>
<a name="ln5918">					if ((fields &amp; sAttrColumnMap[i].fieldMask) != 0) {</a>
<a name="ln5919">						_CheckPoseSortOrder(fPoseList, pose, poseListIndex);</a>
<a name="ln5920">						if (fFiltering &amp;&amp; visible)</a>
<a name="ln5921">							_CheckPoseSortOrder(fFilteredPoseList, pose, index);</a>
<a name="ln5922">						break;</a>
<a name="ln5923">					}</a>
<a name="ln5924">				}</a>
<a name="ln5925">			}</a>
<a name="ln5926">		}</a>
<a name="ln5927">	}</a>
<a name="ln5928">	delete posesFound;</a>
<a name="ln5929">	if (posesCount == 0) {</a>
<a name="ln5930">		// we received an attr changed notification for a zombie model, it means</a>
<a name="ln5931">		// that although we couldn't open the node the first time, it seems</a>
<a name="ln5932">		// to be fine now since we're receiving notifications about it, it might</a>
<a name="ln5933">		// be a good time to convert it to a non-zombie state. cf. test in #4130</a>
<a name="ln5934">		Model* zombie = FindZombie(&amp;itemNode, &amp;index);</a>
<a name="ln5935">		if (zombie != NULL) {</a>
<a name="ln5936">			PRINT((&quot;converting model %s from a zombie\n&quot;, zombie-&gt;Name()));</a>
<a name="ln5937">			return ConvertZombieToPose(zombie, index) != NULL;</a>
<a name="ln5938">		} else {</a>
<a name="ln5939">			PRINT((&quot;model has no pose but is not a zombie either!\n&quot;));</a>
<a name="ln5940">			return false;</a>
<a name="ln5941">		}</a>
<a name="ln5942">	}</a>
<a name="ln5943"> </a>
<a name="ln5944">	return true;</a>
<a name="ln5945">}</a>
<a name="ln5946"> </a>
<a name="ln5947"> </a>
<a name="ln5948">void</a>
<a name="ln5949">BPoseView::UpdateIcon(BPose* pose)</a>
<a name="ln5950">{</a>
<a name="ln5951">	BPoint location;</a>
<a name="ln5952">	if (ViewMode() == kListMode) {</a>
<a name="ln5953">		// need to find the index of the pose in the pose list</a>
<a name="ln5954">		bool found = false;</a>
<a name="ln5955">		PoseList* poseList = CurrentPoseList();</a>
<a name="ln5956">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln5957">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln5958">			if (poseList-&gt;ItemAt(index) == pose) {</a>
<a name="ln5959">				location.Set(0, index * fListElemHeight);</a>
<a name="ln5960">				found = true;</a>
<a name="ln5961">				break;</a>
<a name="ln5962">			}</a>
<a name="ln5963">		}</a>
<a name="ln5964"> </a>
<a name="ln5965">		if (!found)</a>
<a name="ln5966">			return;</a>
<a name="ln5967">	}</a>
<a name="ln5968"> </a>
<a name="ln5969">	pose-&gt;UpdateIcon(location, this);</a>
<a name="ln5970">}</a>
<a name="ln5971"> </a>
<a name="ln5972"> </a>
<a name="ln5973">BPose*</a>
<a name="ln5974">BPoseView::ConvertZombieToPose(Model* zombie, int32 index)</a>
<a name="ln5975">{</a>
<a name="ln5976">	if (zombie-&gt;UpdateStatAndOpenNode() != B_OK)</a>
<a name="ln5977">		return NULL;</a>
<a name="ln5978"> </a>
<a name="ln5979">	fZombieList-&gt;RemoveItemAt(index);</a>
<a name="ln5980"> </a>
<a name="ln5981">	PoseInfo poseInfo;</a>
<a name="ln5982">	ReadPoseInfo(zombie, &amp;poseInfo);</a>
<a name="ln5983"> </a>
<a name="ln5984">	if (ShouldShowPose(zombie, &amp;poseInfo)) {</a>
<a name="ln5985">		// TODO: handle symlinks here</a>
<a name="ln5986">		return CreatePose(zombie, &amp;poseInfo);</a>
<a name="ln5987">	}</a>
<a name="ln5988"> </a>
<a name="ln5989">	delete zombie;</a>
<a name="ln5990"> </a>
<a name="ln5991">	return NULL;</a>
<a name="ln5992">}</a>
<a name="ln5993"> </a>
<a name="ln5994"> </a>
<a name="ln5995">BList*</a>
<a name="ln5996">BPoseView::GetDropPointList(BPoint dropStart, BPoint dropEnd, const PoseList* poses,</a>
<a name="ln5997">	bool sourceInListMode, bool dropOnGrid) const</a>
<a name="ln5998">{</a>
<a name="ln5999">	if (ViewMode() == kListMode)</a>
<a name="ln6000">		return NULL;</a>
<a name="ln6001"> </a>
<a name="ln6002">	int32 count = poses-&gt;CountItems();</a>
<a name="ln6003">	BList* pointList = new BList(count);</a>
<a name="ln6004">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln6005">		BPose* pose = poses-&gt;ItemAt(index);</a>
<a name="ln6006">		BPoint poseLoc;</a>
<a name="ln6007">		if (sourceInListMode)</a>
<a name="ln6008">			poseLoc = dropEnd + BPoint(0, index * (IconPoseHeight() + 3));</a>
<a name="ln6009">		else</a>
<a name="ln6010">			poseLoc = dropEnd + (pose-&gt;Location(this) - dropStart);</a>
<a name="ln6011"> </a>
<a name="ln6012">		if (dropOnGrid)</a>
<a name="ln6013">			poseLoc = PinToGrid(poseLoc, fGrid, fOffset);</a>
<a name="ln6014"> </a>
<a name="ln6015">		pointList-&gt;AddItem(new BPoint(poseLoc));</a>
<a name="ln6016">	}</a>
<a name="ln6017"> </a>
<a name="ln6018">	return pointList;</a>
<a name="ln6019">}</a>
<a name="ln6020"> </a>
<a name="ln6021"> </a>
<a name="ln6022">void</a>
<a name="ln6023">BPoseView::DuplicateSelection(BPoint* dropStart, BPoint* dropEnd)</a>
<a name="ln6024">{</a>
<a name="ln6025">	// If there is a volume or trash folder, remove them from the list</a>
<a name="ln6026">	// because they cannot get copied</a>
<a name="ln6027">	int32 selectionSize = fSelectionList-&gt;CountItems();</a>
<a name="ln6028">	for (int32 index = 0; index &lt; selectionSize; index++) {</a>
<a name="ln6029">		BPose* pose = (BPose*)fSelectionList-&gt;ItemAt(index);</a>
<a name="ln6030">		Model* poseModel = pose-&gt;TargetModel();</a>
<a name="ln6031"> </a>
<a name="ln6032">		// can't duplicate a volume or the trash</a>
<a name="ln6033">		if (poseModel-&gt;IsTrash() || poseModel-&gt;IsVolume()) {</a>
<a name="ln6034">			fSelectionList-&gt;RemoveItemAt(index);</a>
<a name="ln6035">			index--;</a>
<a name="ln6036">			selectionSize--;</a>
<a name="ln6037">			if (fSelectionPivotPose == pose)</a>
<a name="ln6038">				fSelectionPivotPose = NULL;</a>
<a name="ln6039"> </a>
<a name="ln6040">			if (fRealPivotPose == pose)</a>
<a name="ln6041">				fRealPivotPose = NULL;</a>
<a name="ln6042"> </a>
<a name="ln6043">			continue;</a>
<a name="ln6044">		}</a>
<a name="ln6045">	}</a>
<a name="ln6046"> </a>
<a name="ln6047">	// create entry_ref list from selection</a>
<a name="ln6048">	if (!fSelectionList-&gt;IsEmpty()) {</a>
<a name="ln6049">		BObjectList&lt;entry_ref&gt;* srcList = new BObjectList&lt;entry_ref&gt;(</a>
<a name="ln6050">			fSelectionList-&gt;CountItems(), true);</a>
<a name="ln6051">		CopySelectionListToEntryRefList(fSelectionList, srcList);</a>
<a name="ln6052"> </a>
<a name="ln6053">		BList* dropPoints;</a>
<a name="ln6054">		if (dropStart) {</a>
<a name="ln6055">			dropPoints = GetDropPointList(*dropStart, *dropEnd, fSelectionList,</a>
<a name="ln6056">				ViewMode() == kListMode, (modifiers() &amp; B_COMMAND_KEY) != 0);</a>
<a name="ln6057">		} else</a>
<a name="ln6058">			dropPoints = NULL;</a>
<a name="ln6059"> </a>
<a name="ln6060">		// perform asynchronous duplicate</a>
<a name="ln6061">		FSDuplicate(srcList, dropPoints);</a>
<a name="ln6062">	}</a>
<a name="ln6063">}</a>
<a name="ln6064"> </a>
<a name="ln6065"> </a>
<a name="ln6066">void</a>
<a name="ln6067">BPoseView::SelectPoseAtLocation(BPoint point)</a>
<a name="ln6068">{</a>
<a name="ln6069">	int32 index;</a>
<a name="ln6070">	BPose* pose = FindPose(point, &amp;index);</a>
<a name="ln6071">	if (pose != NULL)</a>
<a name="ln6072">		SelectPose(pose, index);</a>
<a name="ln6073">}</a>
<a name="ln6074"> </a>
<a name="ln6075"> </a>
<a name="ln6076">void</a>
<a name="ln6077">BPoseView::MoveListToTrash(BObjectList&lt;entry_ref&gt;* list, bool selectNext,</a>
<a name="ln6078">	bool deleteDirectly)</a>
<a name="ln6079">{</a>
<a name="ln6080">	if (!list-&gt;CountItems())</a>
<a name="ln6081">		return;</a>
<a name="ln6082"> </a>
<a name="ln6083">	BObjectList&lt;FunctionObject&gt;* taskList =</a>
<a name="ln6084">		new BObjectList&lt;FunctionObject&gt;(2, true);</a>
<a name="ln6085">		// new owning list of tasks</a>
<a name="ln6086"> </a>
<a name="ln6087">	// first move selection to trash,</a>
<a name="ln6088">	if (deleteDirectly) {</a>
<a name="ln6089">		taskList-&gt;AddItem(NewFunctionObject(FSDeleteRefList, list,</a>
<a name="ln6090">			false, true));</a>
<a name="ln6091">	} else {</a>
<a name="ln6092">		taskList-&gt;AddItem(NewFunctionObject(FSMoveToTrash, list,</a>
<a name="ln6093">			(BList*)NULL, false));</a>
<a name="ln6094">	}</a>
<a name="ln6095"> </a>
<a name="ln6096">	if (selectNext &amp;&amp; ViewMode() == kListMode) {</a>
<a name="ln6097">		// next, if in list view mode try selecting the next item after</a>
<a name="ln6098">		BPose* pose = fSelectionList-&gt;ItemAt(0);</a>
<a name="ln6099"> </a>
<a name="ln6100">		// find a point in the pose</a>
<a name="ln6101">		BPoint pointInPose(kListOffset + 5, 5);</a>
<a name="ln6102">		int32 index = IndexOfPose(pose);</a>
<a name="ln6103">		pointInPose.y += fListElemHeight * index;</a>
<a name="ln6104"> </a>
<a name="ln6105">		TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln6106">		if (tracker != NULL) {</a>
<a name="ln6107">			ThrowOnAssert(TargetModel() != NULL);</a>
<a name="ln6108"> </a>
<a name="ln6109">			// add a function object to the list of tasks to run</a>
<a name="ln6110">			// that will select the next item after the one we just</a>
<a name="ln6111">			// deleted</a>
<a name="ln6112">			taskList-&gt;AddItem(NewMemberFunctionObject(</a>
<a name="ln6113">				&amp;TTracker::SelectPoseAtLocationSoon, tracker,</a>
<a name="ln6114">				*TargetModel()-&gt;NodeRef(), pointInPose));</a>
<a name="ln6115">		}</a>
<a name="ln6116">	}</a>
<a name="ln6117">	// execute the two tasks in order</a>
<a name="ln6118">	ThreadSequence::Launch(taskList, true);</a>
<a name="ln6119">}</a>
<a name="ln6120"> </a>
<a name="ln6121"> </a>
<a name="ln6122">inline void</a>
<a name="ln6123">CopyOneTrashedRefAsEntry(const entry_ref* ref, BObjectList&lt;entry_ref&gt;* trashList,</a>
<a name="ln6124">	BObjectList&lt;entry_ref&gt;* noTrashList, std::map&lt;int32, bool&gt;* deviceHasTrash)</a>
<a name="ln6125">{</a>
<a name="ln6126">	std::map&lt;int32, bool&gt; &amp;deviceHasTrashTmp = *deviceHasTrash;</a>
<a name="ln6127">		// work around stupid binding problems with EachListItem</a>
<a name="ln6128"> </a>
<a name="ln6129">	BDirectory entryDir(ref);</a>
<a name="ln6130">	bool isVolume = entryDir.IsRootDirectory();</a>
<a name="ln6131">		// volumes will get unmounted</a>
<a name="ln6132"> </a>
<a name="ln6133">	// see if pose's device has a trash</a>
<a name="ln6134">	int32 device = ref-&gt;device;</a>
<a name="ln6135">	BDirectory trashDir;</a>
<a name="ln6136"> </a>
<a name="ln6137">	// cache up the result in a map so that we don't have to keep calling</a>
<a name="ln6138">	// FSGetTrashDir over and over</a>
<a name="ln6139">	if (!isVolume</a>
<a name="ln6140">		&amp;&amp; deviceHasTrashTmp.find(device) == deviceHasTrashTmp.end()) {</a>
<a name="ln6141">		deviceHasTrashTmp[device] = FSGetTrashDir(&amp;trashDir, device) == B_OK;</a>
<a name="ln6142">	}</a>
<a name="ln6143"> </a>
<a name="ln6144">	if (isVolume || deviceHasTrashTmp[device])</a>
<a name="ln6145">		trashList-&gt;AddItem(new entry_ref(*ref));</a>
<a name="ln6146">	else</a>
<a name="ln6147">		noTrashList-&gt;AddItem(new entry_ref(*ref));</a>
<a name="ln6148">}</a>
<a name="ln6149"> </a>
<a name="ln6150"> </a>
<a name="ln6151">static void</a>
<a name="ln6152">CopyPoseOneAsEntry(BPose* pose, BObjectList&lt;entry_ref&gt;* trashList,</a>
<a name="ln6153">	BObjectList&lt;entry_ref&gt;* noTrashList, std::map&lt;int32, bool&gt;* deviceHasTrash)</a>
<a name="ln6154">{</a>
<a name="ln6155">	CopyOneTrashedRefAsEntry(pose-&gt;TargetModel()-&gt;EntryRef(), trashList,</a>
<a name="ln6156">		noTrashList, deviceHasTrash);</a>
<a name="ln6157">}</a>
<a name="ln6158"> </a>
<a name="ln6159"> </a>
<a name="ln6160">static bool</a>
<a name="ln6161">CheckVolumeReadOnly(const entry_ref* ref)</a>
<a name="ln6162">{</a>
<a name="ln6163">	BVolume volume (ref-&gt;device);</a>
<a name="ln6164">	if (volume.IsReadOnly()) {</a>
<a name="ln6165">		BAlert* alert = new BAlert (&quot;&quot;,</a>
<a name="ln6166">			B_TRANSLATE(&quot;Files cannot be moved or deleted from a read-only &quot;</a>
<a name="ln6167">			&quot;volume.&quot;), B_TRANSLATE(&quot;Cancel&quot;), NULL, NULL, B_WIDTH_AS_USUAL,</a>
<a name="ln6168">			B_STOP_ALERT);</a>
<a name="ln6169">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln6170">		alert-&gt;Go();</a>
<a name="ln6171">		return false;</a>
<a name="ln6172">	}</a>
<a name="ln6173"> </a>
<a name="ln6174">	return true;</a>
<a name="ln6175">}</a>
<a name="ln6176"> </a>
<a name="ln6177"> </a>
<a name="ln6178">void</a>
<a name="ln6179">BPoseView::MoveSelectionOrEntryToTrash(const entry_ref* ref, bool selectNext)</a>
<a name="ln6180">{</a>
<a name="ln6181">	BObjectList&lt;entry_ref&gt;* entriesToTrash = new</a>
<a name="ln6182">		BObjectList&lt;entry_ref&gt;(fSelectionList-&gt;CountItems());</a>
<a name="ln6183">	BObjectList&lt;entry_ref&gt;* entriesToDeleteOnTheSpot = new</a>
<a name="ln6184">		BObjectList&lt;entry_ref&gt;(20, true);</a>
<a name="ln6185">	std::map&lt;int32, bool&gt; deviceHasTrash;</a>
<a name="ln6186"> </a>
<a name="ln6187">	if (ref != NULL) {</a>
<a name="ln6188">		if (!CheckVolumeReadOnly(ref)) {</a>
<a name="ln6189">			delete entriesToTrash;</a>
<a name="ln6190">			delete entriesToDeleteOnTheSpot;</a>
<a name="ln6191">			return;</a>
<a name="ln6192">		}</a>
<a name="ln6193">		CopyOneTrashedRefAsEntry(ref, entriesToTrash, entriesToDeleteOnTheSpot,</a>
<a name="ln6194">			&amp;deviceHasTrash);</a>
<a name="ln6195">	} else {</a>
<a name="ln6196">		if (!CheckVolumeReadOnly(</a>
<a name="ln6197">				fSelectionList-&gt;ItemAt(0)-&gt;TargetModel()-&gt;EntryRef())) {</a>
<a name="ln6198">			delete entriesToTrash;</a>
<a name="ln6199">			delete entriesToDeleteOnTheSpot;</a>
<a name="ln6200">			return;</a>
<a name="ln6201">		}</a>
<a name="ln6202">		EachListItem(fSelectionList, CopyPoseOneAsEntry, entriesToTrash,</a>
<a name="ln6203">			entriesToDeleteOnTheSpot, &amp;deviceHasTrash);</a>
<a name="ln6204">	}</a>
<a name="ln6205"> </a>
<a name="ln6206">	if (entriesToDeleteOnTheSpot-&gt;CountItems()) {</a>
<a name="ln6207">		BString alertText;</a>
<a name="ln6208">		if (ref != NULL) {</a>
<a name="ln6209">			alertText.SetTo(B_TRANSLATE(&quot;The selected item cannot be moved to &quot;</a>
<a name="ln6210">				&quot;the Trash. Would you like to delete it instead? &quot;</a>
<a name="ln6211">				&quot;(This operation cannot be reverted.)&quot;));</a>
<a name="ln6212">		} else {</a>
<a name="ln6213">			alertText.SetTo(B_TRANSLATE(&quot;Some of the selected items cannot be &quot;</a>
<a name="ln6214">				&quot;moved to the Trash. Would you like to delete them instead? &quot;</a>
<a name="ln6215">				&quot;(This operation cannot be reverted.)&quot;));</a>
<a name="ln6216">		}</a>
<a name="ln6217"> </a>
<a name="ln6218">		BAlert* alert = new BAlert(&quot;&quot;, alertText.String(),</a>
<a name="ln6219">			B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Delete&quot;));</a>
<a name="ln6220">		alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln6221">		if (alert-&gt;Go() == 0)</a>
<a name="ln6222">			return;</a>
<a name="ln6223">	}</a>
<a name="ln6224"> </a>
<a name="ln6225">	MoveListToTrash(entriesToTrash, selectNext, false);</a>
<a name="ln6226">	MoveListToTrash(entriesToDeleteOnTheSpot, selectNext, true);</a>
<a name="ln6227">}</a>
<a name="ln6228"> </a>
<a name="ln6229"> </a>
<a name="ln6230">void</a>
<a name="ln6231">BPoseView::MoveSelectionToTrash(bool selectNext)</a>
<a name="ln6232">{</a>
<a name="ln6233">	if (fSelectionList-&gt;IsEmpty())</a>
<a name="ln6234">		return;</a>
<a name="ln6235"> </a>
<a name="ln6236">	// create entry_ref list from selection</a>
<a name="ln6237">	// separate items that can be trashed from ones that cannot</a>
<a name="ln6238"> </a>
<a name="ln6239">	MoveSelectionOrEntryToTrash(0, selectNext);</a>
<a name="ln6240">}</a>
<a name="ln6241"> </a>
<a name="ln6242"> </a>
<a name="ln6243">void</a>
<a name="ln6244">BPoseView::MoveEntryToTrash(const entry_ref* ref, bool selectNext)</a>
<a name="ln6245">{</a>
<a name="ln6246">	MoveSelectionOrEntryToTrash(ref, selectNext);</a>
<a name="ln6247">}</a>
<a name="ln6248"> </a>
<a name="ln6249"> </a>
<a name="ln6250">void</a>
<a name="ln6251">BPoseView::DeleteSelection(bool selectNext, bool askUser)</a>
<a name="ln6252">{</a>
<a name="ln6253">	int32 count = fSelectionList-&gt;CountItems();</a>
<a name="ln6254">	if (count &lt;= 0)</a>
<a name="ln6255">		return;</a>
<a name="ln6256"> </a>
<a name="ln6257">	if (!CheckVolumeReadOnly(</a>
<a name="ln6258">			fSelectionList-&gt;ItemAt(0)-&gt;TargetModel()-&gt;EntryRef())) {</a>
<a name="ln6259">		return;</a>
<a name="ln6260">	}</a>
<a name="ln6261"> </a>
<a name="ln6262">	BObjectList&lt;entry_ref&gt;* entriesToDelete</a>
<a name="ln6263">		= new BObjectList&lt;entry_ref&gt;(count, true);</a>
<a name="ln6264"> </a>
<a name="ln6265">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln6266">		entriesToDelete-&gt;AddItem(new entry_ref(</a>
<a name="ln6267">			*fSelectionList-&gt;ItemAt(index)-&gt;TargetModel()-&gt;EntryRef()));</a>
<a name="ln6268">	}</a>
<a name="ln6269"> </a>
<a name="ln6270">	Delete(entriesToDelete, selectNext, askUser);</a>
<a name="ln6271">}</a>
<a name="ln6272"> </a>
<a name="ln6273"> </a>
<a name="ln6274">void</a>
<a name="ln6275">BPoseView::RestoreSelectionFromTrash(bool selectNext)</a>
<a name="ln6276">{</a>
<a name="ln6277">	int32 count = fSelectionList -&gt; CountItems();</a>
<a name="ln6278">	if (count &lt;= 0)</a>
<a name="ln6279">		return;</a>
<a name="ln6280"> </a>
<a name="ln6281">	BObjectList&lt;entry_ref&gt;* entriesToRestore</a>
<a name="ln6282">		= new BObjectList&lt;entry_ref&gt;(count, true);</a>
<a name="ln6283"> </a>
<a name="ln6284">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln6285">		entriesToRestore-&gt;AddItem(new entry_ref(</a>
<a name="ln6286">			*fSelectionList-&gt;ItemAt(index)-&gt;TargetModel()-&gt;EntryRef()));</a>
<a name="ln6287">	}</a>
<a name="ln6288"> </a>
<a name="ln6289">	RestoreItemsFromTrash(entriesToRestore, selectNext);</a>
<a name="ln6290">}</a>
<a name="ln6291"> </a>
<a name="ln6292"> </a>
<a name="ln6293">void</a>
<a name="ln6294">BPoseView::Delete(const entry_ref &amp;ref, bool selectNext, bool askUser)</a>
<a name="ln6295">{</a>
<a name="ln6296">	BObjectList&lt;entry_ref&gt;* entriesToDelete</a>
<a name="ln6297">		= new BObjectList&lt;entry_ref&gt;(1, true);</a>
<a name="ln6298">	entriesToDelete-&gt;AddItem(new entry_ref(ref));</a>
<a name="ln6299"> </a>
<a name="ln6300">	Delete(entriesToDelete, selectNext, askUser);</a>
<a name="ln6301">}</a>
<a name="ln6302"> </a>
<a name="ln6303"> </a>
<a name="ln6304">void</a>
<a name="ln6305">BPoseView::Delete(BObjectList&lt;entry_ref&gt;* list, bool selectNext, bool askUser)</a>
<a name="ln6306">{</a>
<a name="ln6307">	if (list-&gt;CountItems() == 0) {</a>
<a name="ln6308">		delete list;</a>
<a name="ln6309">		return;</a>
<a name="ln6310">	}</a>
<a name="ln6311"> </a>
<a name="ln6312">	BObjectList&lt;FunctionObject&gt;* taskList =</a>
<a name="ln6313">		new BObjectList&lt;FunctionObject&gt;(2, true);</a>
<a name="ln6314"> </a>
<a name="ln6315">	// first move selection to trash,</a>
<a name="ln6316">	taskList-&gt;AddItem(NewFunctionObject(FSDeleteRefList, list, false, askUser));</a>
<a name="ln6317"> </a>
<a name="ln6318">	if (selectNext &amp;&amp; ViewMode() == kListMode) {</a>
<a name="ln6319">		// next, if in list view mode try selecting the next item after</a>
<a name="ln6320">		BPose* pose = fSelectionList-&gt;ItemAt(0);</a>
<a name="ln6321"> </a>
<a name="ln6322">		// find a point in the pose</a>
<a name="ln6323">		BPoint pointInPose(kListOffset + 5, 5);</a>
<a name="ln6324">		int32 index = IndexOfPose(pose);</a>
<a name="ln6325">		pointInPose.y += fListElemHeight * index;</a>
<a name="ln6326"> </a>
<a name="ln6327">		TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln6328">		if (tracker != NULL) {</a>
<a name="ln6329">			ThrowOnAssert(TargetModel() != NULL);</a>
<a name="ln6330"> </a>
<a name="ln6331">			// add a function object to the list of tasks to run</a>
<a name="ln6332">			// that will select the next item after the one we just</a>
<a name="ln6333">			// deleted</a>
<a name="ln6334">			Model* targetModel = TargetModel();</a>
<a name="ln6335">			ASSERT(targetModel != NULL);</a>
<a name="ln6336">			taskList-&gt;AddItem(NewMemberFunctionObject(</a>
<a name="ln6337">				&amp;TTracker::SelectPoseAtLocationSoon, tracker,</a>
<a name="ln6338">				*targetModel-&gt;NodeRef(), pointInPose));</a>
<a name="ln6339">		}</a>
<a name="ln6340">	}</a>
<a name="ln6341"> </a>
<a name="ln6342">	// execute the two tasks in order</a>
<a name="ln6343">	ThreadSequence::Launch(taskList, true);</a>
<a name="ln6344">}</a>
<a name="ln6345"> </a>
<a name="ln6346"> </a>
<a name="ln6347">void</a>
<a name="ln6348">BPoseView::RestoreItemsFromTrash(BObjectList&lt;entry_ref&gt;* list, bool selectNext)</a>
<a name="ln6349">{</a>
<a name="ln6350">	if (list-&gt;CountItems() == 0) {</a>
<a name="ln6351">		delete list;</a>
<a name="ln6352">		return;</a>
<a name="ln6353">	}</a>
<a name="ln6354"> </a>
<a name="ln6355">	BObjectList&lt;FunctionObject&gt;* taskList =</a>
<a name="ln6356">		new BObjectList&lt;FunctionObject&gt;(2, true);</a>
<a name="ln6357"> </a>
<a name="ln6358">	// first restoree selection</a>
<a name="ln6359">	taskList-&gt;AddItem(NewFunctionObject(FSRestoreRefList, list, false));</a>
<a name="ln6360"> </a>
<a name="ln6361">	if (selectNext &amp;&amp; ViewMode() == kListMode) {</a>
<a name="ln6362">		// next, if in list view mode try selecting the next item after</a>
<a name="ln6363">		BPose* pose = fSelectionList-&gt;ItemAt(0);</a>
<a name="ln6364"> </a>
<a name="ln6365">		// find a point in the pose</a>
<a name="ln6366">		BPoint pointInPose(kListOffset + 5, 5);</a>
<a name="ln6367">		int32 index = IndexOfPose(pose);</a>
<a name="ln6368">		pointInPose.y += fListElemHeight * index;</a>
<a name="ln6369"> </a>
<a name="ln6370">		TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln6371">		if (tracker != NULL) {</a>
<a name="ln6372">			ThrowOnAssert(TargetModel() != NULL);</a>
<a name="ln6373"> </a>
<a name="ln6374">			// add a function object to the list of tasks to run</a>
<a name="ln6375">			// that will select the next item after the one we just</a>
<a name="ln6376">			// restored</a>
<a name="ln6377">			Model* targetModel = TargetModel();</a>
<a name="ln6378">			ASSERT(targetModel != NULL);</a>
<a name="ln6379">			taskList-&gt;AddItem(NewMemberFunctionObject(</a>
<a name="ln6380">				&amp;TTracker::SelectPoseAtLocationSoon, tracker,</a>
<a name="ln6381">				*targetModel-&gt;NodeRef(), pointInPose));</a>
<a name="ln6382">		}</a>
<a name="ln6383">	}</a>
<a name="ln6384"> </a>
<a name="ln6385">	// execute the two tasks in order</a>
<a name="ln6386">	ThreadSequence::Launch(taskList, true);</a>
<a name="ln6387">}</a>
<a name="ln6388"> </a>
<a name="ln6389"> </a>
<a name="ln6390">void</a>
<a name="ln6391">BPoseView::SelectAll()</a>
<a name="ln6392">{</a>
<a name="ln6393">	BRect bounds(Bounds());</a>
<a name="ln6394"> </a>
<a name="ln6395">	// clear selection list</a>
<a name="ln6396">	fSelectionList-&gt;MakeEmpty();</a>
<a name="ln6397">	fMimeTypesInSelectionCache.MakeEmpty();</a>
<a name="ln6398">	fSelectionPivotPose = NULL;</a>
<a name="ln6399">	fRealPivotPose = NULL;</a>
<a name="ln6400"> </a>
<a name="ln6401">	int32 startIndex = 0;</a>
<a name="ln6402">	BPoint loc(0, fListElemHeight * startIndex);</a>
<a name="ln6403"> </a>
<a name="ln6404">	bool iconMode = ViewMode() != kListMode;</a>
<a name="ln6405"> </a>
<a name="ln6406">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln6407">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln6408">	for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln6409">		BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln6410">		fSelectionList-&gt;AddItem(pose);</a>
<a name="ln6411">		if (index == startIndex)</a>
<a name="ln6412">			fSelectionPivotPose = pose;</a>
<a name="ln6413"> </a>
<a name="ln6414">		if (!pose-&gt;IsSelected()) {</a>
<a name="ln6415">			pose-&gt;Select(true);</a>
<a name="ln6416"> </a>
<a name="ln6417">			BRect poseRect;</a>
<a name="ln6418">			if (iconMode)</a>
<a name="ln6419">				poseRect = pose-&gt;CalcRect(this);</a>
<a name="ln6420">			else</a>
<a name="ln6421">				poseRect = pose-&gt;CalcRect(loc, this);</a>
<a name="ln6422"> </a>
<a name="ln6423">			if (bounds.Intersects(poseRect)) {</a>
<a name="ln6424">				pose-&gt;Draw(poseRect, bounds, this, false);</a>
<a name="ln6425">				Flush();</a>
<a name="ln6426">			}</a>
<a name="ln6427">		}</a>
<a name="ln6428"> </a>
<a name="ln6429">		loc.y += fListElemHeight;</a>
<a name="ln6430">	}</a>
<a name="ln6431"> </a>
<a name="ln6432">	if (fSelectionChangedHook)</a>
<a name="ln6433">		ContainerWindow()-&gt;SelectionChanged();</a>
<a name="ln6434">}</a>
<a name="ln6435"> </a>
<a name="ln6436"> </a>
<a name="ln6437">void</a>
<a name="ln6438">BPoseView::InvertSelection()</a>
<a name="ln6439">{</a>
<a name="ln6440">	// Since this function shares most code with</a>
<a name="ln6441">	// SelectAll(), we could make SelectAll() empty the selection,</a>
<a name="ln6442">	// then call InvertSelection()</a>
<a name="ln6443"> </a>
<a name="ln6444">	BRect bounds(Bounds());</a>
<a name="ln6445"> </a>
<a name="ln6446">	int32 startIndex = 0;</a>
<a name="ln6447">	BPoint loc(0, fListElemHeight * startIndex);</a>
<a name="ln6448"> </a>
<a name="ln6449">	fMimeTypesInSelectionCache.MakeEmpty();</a>
<a name="ln6450">	fSelectionPivotPose = NULL;</a>
<a name="ln6451">	fRealPivotPose = NULL;</a>
<a name="ln6452"> </a>
<a name="ln6453">	bool iconMode = ViewMode() != kListMode;</a>
<a name="ln6454"> </a>
<a name="ln6455">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln6456">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln6457">	for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln6458">		BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln6459"> </a>
<a name="ln6460">		if (pose-&gt;IsSelected()) {</a>
<a name="ln6461">			fSelectionList-&gt;RemoveItem(pose);</a>
<a name="ln6462">			pose-&gt;Select(false);</a>
<a name="ln6463">		} else {</a>
<a name="ln6464">			if (index == startIndex)</a>
<a name="ln6465">				fSelectionPivotPose = pose;</a>
<a name="ln6466"> </a>
<a name="ln6467">			fSelectionList-&gt;AddItem(pose);</a>
<a name="ln6468">			pose-&gt;Select(true);</a>
<a name="ln6469">		}</a>
<a name="ln6470"> </a>
<a name="ln6471">		BRect poseRect;</a>
<a name="ln6472">		if (iconMode)</a>
<a name="ln6473">			poseRect = pose-&gt;CalcRect(this);</a>
<a name="ln6474">		else</a>
<a name="ln6475">			poseRect = pose-&gt;CalcRect(loc, this);</a>
<a name="ln6476"> </a>
<a name="ln6477">		if (bounds.Intersects(poseRect))</a>
<a name="ln6478">			Invalidate();</a>
<a name="ln6479"> </a>
<a name="ln6480">		loc.y += fListElemHeight;</a>
<a name="ln6481">	}</a>
<a name="ln6482"> </a>
<a name="ln6483">	if (fSelectionChangedHook)</a>
<a name="ln6484">		ContainerWindow()-&gt;SelectionChanged();</a>
<a name="ln6485">}</a>
<a name="ln6486"> </a>
<a name="ln6487"> </a>
<a name="ln6488">int32</a>
<a name="ln6489">BPoseView::SelectMatchingEntries(const BMessage* message)</a>
<a name="ln6490">{</a>
<a name="ln6491">	int32 matchCount = 0;</a>
<a name="ln6492">	SetMultipleSelection(true);</a>
<a name="ln6493"> </a>
<a name="ln6494">	ClearSelection();</a>
<a name="ln6495"> </a>
<a name="ln6496">	TrackerStringExpressionType expressionType;</a>
<a name="ln6497">	BString expression;</a>
<a name="ln6498">	const char* expressionPointer;</a>
<a name="ln6499">	bool invertSelection;</a>
<a name="ln6500">	bool ignoreCase;</a>
<a name="ln6501"> </a>
<a name="ln6502">	message-&gt;FindInt32(&quot;ExpressionType&quot;, (int32*)&amp;expressionType);</a>
<a name="ln6503">	message-&gt;FindString(&quot;Expression&quot;, &amp;expressionPointer);</a>
<a name="ln6504">	message-&gt;FindBool(&quot;InvertSelection&quot;, &amp;invertSelection);</a>
<a name="ln6505">	message-&gt;FindBool(&quot;IgnoreCase&quot;, &amp;ignoreCase);</a>
<a name="ln6506"> </a>
<a name="ln6507">	expression = expressionPointer;</a>
<a name="ln6508"> </a>
<a name="ln6509">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln6510">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln6511">	TrackerString name;</a>
<a name="ln6512"> </a>
<a name="ln6513">	RegExp regExpression;</a>
<a name="ln6514"> </a>
<a name="ln6515">	// Make sure we don't have any errors in the expression</a>
<a name="ln6516">	// before we match the names:</a>
<a name="ln6517">	if (expressionType == kRegexpMatch) {</a>
<a name="ln6518">		regExpression.SetTo(expression);</a>
<a name="ln6519"> </a>
<a name="ln6520">		if (regExpression.InitCheck() != B_OK) {</a>
<a name="ln6521">			BString message(</a>
<a name="ln6522">				B_TRANSLATE(&quot;Error in regular expression:\n\n'%errstring'&quot;));</a>
<a name="ln6523">			message.ReplaceFirst(&quot;%errstring&quot;, regExpression.ErrorString());</a>
<a name="ln6524">			BAlert* alert = new BAlert(&quot;&quot;, message.String(), B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln6525">				NULL, NULL,	B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln6526">			alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln6527">			alert-&gt;Go();</a>
<a name="ln6528">			return 0;</a>
<a name="ln6529">		}</a>
<a name="ln6530">	}</a>
<a name="ln6531"> </a>
<a name="ln6532">	// There is room for optimizations here: If regexp-type match, the Matches()</a>
<a name="ln6533">	// function compiles the expression for every entry. One could use</a>
<a name="ln6534">	// TrackerString::CompileRegExp and reuse the expression. However, then we</a>
<a name="ln6535">	// have to take care of the case sensitivity ourselves.</a>
<a name="ln6536">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln6537">		BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln6538">		name = pose-&gt;TargetModel()-&gt;Name();</a>
<a name="ln6539">		if (name.Matches(expression.String(), !ignoreCase, expressionType)</a>
<a name="ln6540">				^ invertSelection) {</a>
<a name="ln6541">			matchCount++;</a>
<a name="ln6542">			AddPoseToSelection(pose, index);</a>
<a name="ln6543">		}</a>
<a name="ln6544">	}</a>
<a name="ln6545"> </a>
<a name="ln6546">	Window()-&gt;Activate();</a>
<a name="ln6547">		// Make sure the window is activated for</a>
<a name="ln6548">		// subsequent manipulations. Esp. needed</a>
<a name="ln6549">		// for the Desktop window.</a>
<a name="ln6550"> </a>
<a name="ln6551">	return matchCount;</a>
<a name="ln6552">}</a>
<a name="ln6553"> </a>
<a name="ln6554"> </a>
<a name="ln6555">void</a>
<a name="ln6556">BPoseView::ShowSelectionWindow()</a>
<a name="ln6557">{</a>
<a name="ln6558">	Window()-&gt;PostMessage(kShowSelectionWindow);</a>
<a name="ln6559">}</a>
<a name="ln6560"> </a>
<a name="ln6561"> </a>
<a name="ln6562">void</a>
<a name="ln6563">BPoseView::KeyDown(const char* bytes, int32 count)</a>
<a name="ln6564">{</a>
<a name="ln6565">	char key = bytes[0];</a>
<a name="ln6566"> </a>
<a name="ln6567">	switch (key) {</a>
<a name="ln6568">		case B_LEFT_ARROW:</a>
<a name="ln6569">		case B_RIGHT_ARROW:</a>
<a name="ln6570">		case B_UP_ARROW:</a>
<a name="ln6571">		case B_DOWN_ARROW:</a>
<a name="ln6572">		{</a>
<a name="ln6573">			int32 index;</a>
<a name="ln6574">			BPose* pose = FindNearbyPose(key, &amp;index);</a>
<a name="ln6575">			if (pose == NULL)</a>
<a name="ln6576">				break;</a>
<a name="ln6577"> </a>
<a name="ln6578">			if (fMultipleSelection &amp;&amp; (modifiers() &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln6579">				if (pose-&gt;IsSelected()) {</a>
<a name="ln6580">					RemovePoseFromSelection(fSelectionList-&gt;LastItem());</a>
<a name="ln6581">					fSelectionPivotPose = pose;</a>
<a name="ln6582">					ScrollIntoView(pose, index);</a>
<a name="ln6583">				} else</a>
<a name="ln6584">					AddPoseToSelection(pose, index, true);</a>
<a name="ln6585">			} else</a>
<a name="ln6586">				SelectPose(pose, index);</a>
<a name="ln6587"> </a>
<a name="ln6588">			break;</a>
<a name="ln6589">		}</a>
<a name="ln6590"> </a>
<a name="ln6591">		case B_RETURN:</a>
<a name="ln6592">			if (fFiltering &amp;&amp; fSelectionList-&gt;CountItems() == 0)</a>
<a name="ln6593">				SelectPose(fFilteredPoseList-&gt;FirstItem(), 0);</a>
<a name="ln6594"> </a>
<a name="ln6595">			OpenSelection();</a>
<a name="ln6596"> </a>
<a name="ln6597">			if (fFiltering &amp;&amp; (modifiers() &amp; B_SHIFT_KEY) != 0)</a>
<a name="ln6598">				StopFiltering();</a>
<a name="ln6599"> </a>
<a name="ln6600">			break;</a>
<a name="ln6601"> </a>
<a name="ln6602">		case B_HOME:</a>
<a name="ln6603">			// select the first entry (if in listview mode), and</a>
<a name="ln6604">			// scroll to the top of the view</a>
<a name="ln6605">			if (ViewMode() == kListMode)</a>
<a name="ln6606">				MoveOrChangePoseSelection(0);</a>
<a name="ln6607">			else</a>
<a name="ln6608">				ScrollView(B_HOME);</a>
<a name="ln6609">			break;</a>
<a name="ln6610"> </a>
<a name="ln6611">		case B_END:</a>
<a name="ln6612">			// select the last entry (if in listview mode), and</a>
<a name="ln6613">			// scroll to the bottom of the view</a>
<a name="ln6614">			if (ViewMode() == kListMode)</a>
<a name="ln6615">				MoveOrChangePoseSelection(CurrentPoseList()-&gt;CountItems() - 1);</a>
<a name="ln6616">			else</a>
<a name="ln6617">				ScrollView(B_END);</a>
<a name="ln6618">			break;</a>
<a name="ln6619"> </a>
<a name="ln6620">		case B_PAGE_UP:</a>
<a name="ln6621">			if (ViewMode() == kListMode) {</a>
<a name="ln6622">				// Select first visible pose</a>
<a name="ln6623">				int32 firstIndex = CurrentPoseList()-&gt;IndexOf(</a>
<a name="ln6624">					fSelectionList-&gt;FirstItem());</a>
<a name="ln6625">				int32 index;</a>
<a name="ln6626">				BPose* first = FirstVisiblePose(&amp;index);</a>
<a name="ln6627">				if (first != NULL) {</a>
<a name="ln6628">					if (index == firstIndex) {</a>
<a name="ln6629">						ScrollView(B_PAGE_UP);</a>
<a name="ln6630">						first = FirstVisiblePose(&amp;index);</a>
<a name="ln6631">					}</a>
<a name="ln6632">					MoveOrChangePoseSelection(index);</a>
<a name="ln6633">				}</a>
<a name="ln6634">			} else</a>
<a name="ln6635">				ScrollView(B_PAGE_UP);</a>
<a name="ln6636">			break;</a>
<a name="ln6637"> </a>
<a name="ln6638">		case B_PAGE_DOWN:</a>
<a name="ln6639">			if (ViewMode() == kListMode) {</a>
<a name="ln6640">				// Select last visible pose</a>
<a name="ln6641">				int32 lastIndex = CurrentPoseList()-&gt;IndexOf(</a>
<a name="ln6642">					fSelectionList-&gt;LastItem());</a>
<a name="ln6643">				int32 index;</a>
<a name="ln6644">				BPose* last = LastVisiblePose(&amp;index);</a>
<a name="ln6645">				if (last != NULL) {</a>
<a name="ln6646">					if (index == lastIndex) {</a>
<a name="ln6647">						ScrollView(B_PAGE_DOWN);</a>
<a name="ln6648">						last = LastVisiblePose(&amp;index);</a>
<a name="ln6649">					}</a>
<a name="ln6650">					MoveOrChangePoseSelection(index);</a>
<a name="ln6651">				}</a>
<a name="ln6652">			} else</a>
<a name="ln6653">				ScrollView(B_PAGE_DOWN);</a>
<a name="ln6654">			break;</a>
<a name="ln6655"> </a>
<a name="ln6656">		case B_TAB:</a>
<a name="ln6657">			if (IsFilePanel())</a>
<a name="ln6658">				_inherited::KeyDown(bytes, count);</a>
<a name="ln6659">			else {</a>
<a name="ln6660">				if (ViewMode() == kListMode</a>
<a name="ln6661">					&amp;&amp; TrackerSettings().TypeAheadFiltering()) {</a>
<a name="ln6662">					break;</a>
<a name="ln6663">				}</a>
<a name="ln6664"> </a>
<a name="ln6665">				if (fSelectionList-&gt;IsEmpty())</a>
<a name="ln6666">					sMatchString.Truncate(0);</a>
<a name="ln6667">				else {</a>
<a name="ln6668">					BPose* pose = fSelectionList-&gt;FirstItem();</a>
<a name="ln6669">					sMatchString.SetTo(pose-&gt;TargetModel()-&gt;Name());</a>
<a name="ln6670">				}</a>
<a name="ln6671"> </a>
<a name="ln6672">				bool reverse</a>
<a name="ln6673">					= (Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;modifiers&quot;)</a>
<a name="ln6674">						&amp; B_SHIFT_KEY) != 0;</a>
<a name="ln6675">				int32 index;</a>
<a name="ln6676">				BPose* pose = FindNextMatch(&amp;index, reverse);</a>
<a name="ln6677">				if (pose == NULL) {</a>
<a name="ln6678">					// wrap around</a>
<a name="ln6679">					if (reverse)</a>
<a name="ln6680">						sMatchString.SetTo(0x7f, 1);</a>
<a name="ln6681">					else</a>
<a name="ln6682">						sMatchString.Truncate(0);</a>
<a name="ln6683"> </a>
<a name="ln6684">					pose = FindNextMatch(&amp;index, reverse);</a>
<a name="ln6685">				}</a>
<a name="ln6686"> </a>
<a name="ln6687">				SelectPose(pose, index);</a>
<a name="ln6688">			}</a>
<a name="ln6689">			break;</a>
<a name="ln6690"> </a>
<a name="ln6691">		case B_DELETE:</a>
<a name="ln6692">		{</a>
<a name="ln6693">			ExcludeTrashFromSelection();</a>
<a name="ln6694">			if (TargetModel() == NULL) {</a>
<a name="ln6695">				// Happens if called from within OpenWith window, for example</a>
<a name="ln6696">				break;</a>
<a name="ln6697">			}</a>
<a name="ln6698">			// Make sure user can't trash something already in the trash.</a>
<a name="ln6699">			if (TargetModel()-&gt;IsTrash()) {</a>
<a name="ln6700">				// Delete without asking from the trash</a>
<a name="ln6701">				DeleteSelection(true, false);</a>
<a name="ln6702">			} else {</a>
<a name="ln6703">				TrackerSettings settings;</a>
<a name="ln6704"> </a>
<a name="ln6705">				if ((modifiers() &amp; B_SHIFT_KEY) != 0</a>
<a name="ln6706">					|| settings.DontMoveFilesToTrash()) {</a>
<a name="ln6707">					DeleteSelection(true, settings.AskBeforeDeleteFile());</a>
<a name="ln6708">				} else</a>
<a name="ln6709">					MoveSelectionToTrash();</a>
<a name="ln6710">			}</a>
<a name="ln6711">			break;</a>
<a name="ln6712">		}</a>
<a name="ln6713"> </a>
<a name="ln6714">		case B_BACKSPACE:</a>
<a name="ln6715">		{</a>
<a name="ln6716">			if (fFiltering) {</a>
<a name="ln6717">				BString* lastString = fFilterStrings.LastItem();</a>
<a name="ln6718">				if (lastString-&gt;Length() == 0) {</a>
<a name="ln6719">					int32 stringCount = fFilterStrings.CountItems();</a>
<a name="ln6720">					if (stringCount &gt; 1)</a>
<a name="ln6721">						delete fFilterStrings.RemoveItemAt(stringCount - 1);</a>
<a name="ln6722">					else</a>
<a name="ln6723">						break;</a>
<a name="ln6724">				} else</a>
<a name="ln6725">					lastString-&gt;TruncateChars(lastString-&gt;CountChars() - 1);</a>
<a name="ln6726"> </a>
<a name="ln6727">				fCountView-&gt;RemoveFilterCharacter();</a>
<a name="ln6728">				FilterChanged();</a>
<a name="ln6729">				break;</a>
<a name="ln6730">			}</a>
<a name="ln6731"> </a>
<a name="ln6732">			if (sMatchString.Length() == 0)</a>
<a name="ln6733">				break;</a>
<a name="ln6734"> </a>
<a name="ln6735">			// remove last char from the typeahead buffer</a>
<a name="ln6736">			sMatchString.TruncateChars(sMatchString.CountChars() - 1);</a>
<a name="ln6737"> </a>
<a name="ln6738">			fLastKeyTime = system_time();</a>
<a name="ln6739"> </a>
<a name="ln6740">			fCountView-&gt;SetTypeAhead(sMatchString.String());</a>
<a name="ln6741"> </a>
<a name="ln6742">			// select our new string</a>
<a name="ln6743">			int32 index;</a>
<a name="ln6744">			BPose* pose = FindBestMatch(&amp;index);</a>
<a name="ln6745">			if (pose == NULL)</a>
<a name="ln6746">				break;</a>
<a name="ln6747"> </a>
<a name="ln6748">			SelectPose(pose, index);</a>
<a name="ln6749">			break;</a>
<a name="ln6750">		}</a>
<a name="ln6751"> </a>
<a name="ln6752">		case B_FUNCTION_KEY:</a>
<a name="ln6753">		{</a>
<a name="ln6754">			BMessage* message = Window()-&gt;CurrentMessage();</a>
<a name="ln6755">			if (message != NULL) {</a>
<a name="ln6756">				int32 key;</a>
<a name="ln6757">				if (message-&gt;FindInt32(&quot;key&quot;, &amp;key) == B_OK &amp;&amp; key == B_F2_KEY)</a>
<a name="ln6758">					Window()-&gt;PostMessage(kEditItem, this);</a>
<a name="ln6759">			}</a>
<a name="ln6760">			break;</a>
<a name="ln6761">		}</a>
<a name="ln6762"> </a>
<a name="ln6763">		case B_INSERT:</a>
<a name="ln6764">			break;</a>
<a name="ln6765"> </a>
<a name="ln6766">		default:</a>
<a name="ln6767">		{</a>
<a name="ln6768">			// handle typeahead selection / filtering</a>
<a name="ln6769"> </a>
<a name="ln6770">			if (ViewMode() == kListMode</a>
<a name="ln6771">				&amp;&amp; TrackerSettings().TypeAheadFiltering()) {</a>
<a name="ln6772">				if (key == ' ' &amp;&amp; modifiers() &amp; B_SHIFT_KEY) {</a>
<a name="ln6773">					if (fFilterStrings.LastItem()-&gt;Length() == 0)</a>
<a name="ln6774">						break;</a>
<a name="ln6775"> </a>
<a name="ln6776">					fFilterStrings.AddItem(new BString());</a>
<a name="ln6777">					fCountView-&gt;AddFilterCharacter(&quot;|&quot;);</a>
<a name="ln6778">					break;</a>
<a name="ln6779">				}</a>
<a name="ln6780"> </a>
<a name="ln6781">				fFilterStrings.LastItem()-&gt;AppendChars(bytes, 1);</a>
<a name="ln6782">				fCountView-&gt;AddFilterCharacter(bytes);</a>
<a name="ln6783">				FilterChanged();</a>
<a name="ln6784">				break;</a>
<a name="ln6785">			}</a>
<a name="ln6786"> </a>
<a name="ln6787">			bigtime_t doubleClickSpeed;</a>
<a name="ln6788">			get_click_speed(&amp;doubleClickSpeed);</a>
<a name="ln6789"> </a>
<a name="ln6790">			// start watching</a>
<a name="ln6791">			if (fKeyRunner == NULL) {</a>
<a name="ln6792">				fKeyRunner = new BMessageRunner(this,</a>
<a name="ln6793">					new BMessage(kCheckTypeahead), doubleClickSpeed);</a>
<a name="ln6794">				if (fKeyRunner-&gt;InitCheck() != B_OK)</a>
<a name="ln6795">					return;</a>
<a name="ln6796">			}</a>
<a name="ln6797"> </a>
<a name="ln6798">			// figure out the time at which the keypress happened</a>
<a name="ln6799">			bigtime_t eventTime;</a>
<a name="ln6800">			BMessage* message = Window()-&gt;CurrentMessage();</a>
<a name="ln6801">			if (message == NULL</a>
<a name="ln6802">				|| message-&gt;FindInt64(&quot;when&quot;, &amp;eventTime) &lt; B_OK) {</a>
<a name="ln6803">				eventTime = system_time();</a>
<a name="ln6804">			}</a>
<a name="ln6805"> </a>
<a name="ln6806">			// add char to existing matchString or start new match string</a>
<a name="ln6807">			if (eventTime - fLastKeyTime &lt; (doubleClickSpeed * 2))</a>
<a name="ln6808">				sMatchString.AppendChars(bytes, 1);</a>
<a name="ln6809">			else</a>
<a name="ln6810">				sMatchString.SetToChars(bytes, 1);</a>
<a name="ln6811"> </a>
<a name="ln6812">			fLastKeyTime = eventTime;</a>
<a name="ln6813"> </a>
<a name="ln6814">			fCountView-&gt;SetTypeAhead(sMatchString.String());</a>
<a name="ln6815"> </a>
<a name="ln6816">			int32 index;</a>
<a name="ln6817">			BPose* pose = FindBestMatch(&amp;index);</a>
<a name="ln6818">			if (pose == NULL)</a>
<a name="ln6819">				break;</a>
<a name="ln6820"> </a>
<a name="ln6821">			SelectPose(pose, index);</a>
<a name="ln6822">			break;</a>
<a name="ln6823">		}</a>
<a name="ln6824">	}</a>
<a name="ln6825">}</a>
<a name="ln6826"> </a>
<a name="ln6827"> </a>
<a name="ln6828">BPose*</a>
<a name="ln6829">BPoseView::FindNextMatch(int32* matchingIndex, bool reverse)</a>
<a name="ln6830">{</a>
<a name="ln6831">	char bestSoFar[B_FILE_NAME_LENGTH] = { 0 };</a>
<a name="ln6832">	BPose* poseToSelect = NULL;</a>
<a name="ln6833"> </a>
<a name="ln6834">	// loop through all poses to find match</a>
<a name="ln6835">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln6836">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln6837">		BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln6838"> </a>
<a name="ln6839">		if (reverse) {</a>
<a name="ln6840">			if (sMatchString.ICompare(pose-&gt;TargetModel()-&gt;Name()) &gt; 0) {</a>
<a name="ln6841">				if (strcasecmp(pose-&gt;TargetModel()-&gt;Name(), bestSoFar) &gt;= 0</a>
<a name="ln6842">					|| !bestSoFar[0]) {</a>
<a name="ln6843">					strlcpy(bestSoFar, pose-&gt;TargetModel()-&gt;Name(),</a>
<a name="ln6844">						sizeof(bestSoFar));</a>
<a name="ln6845">					poseToSelect = pose;</a>
<a name="ln6846">					*matchingIndex = index;</a>
<a name="ln6847">				}</a>
<a name="ln6848">			}</a>
<a name="ln6849">		} else if (sMatchString.ICompare(pose-&gt;TargetModel()-&gt;Name()) &lt; 0) {</a>
<a name="ln6850">			if (strcasecmp(pose-&gt;TargetModel()-&gt;Name(), bestSoFar) &lt;= 0</a>
<a name="ln6851">				|| !bestSoFar[0]) {</a>
<a name="ln6852">				strlcpy(bestSoFar, pose-&gt;TargetModel()-&gt;Name(),</a>
<a name="ln6853">					sizeof(bestSoFar));</a>
<a name="ln6854">				poseToSelect = pose;</a>
<a name="ln6855">				*matchingIndex = index;</a>
<a name="ln6856">			}</a>
<a name="ln6857">		}</a>
<a name="ln6858">	}</a>
<a name="ln6859"> </a>
<a name="ln6860">	return poseToSelect;</a>
<a name="ln6861">}</a>
<a name="ln6862"> </a>
<a name="ln6863"> </a>
<a name="ln6864">BPose*</a>
<a name="ln6865">BPoseView::FindBestMatch(int32* index)</a>
<a name="ln6866">{</a>
<a name="ln6867">	BPose* poseToSelect = NULL;</a>
<a name="ln6868">	float bestScore = -1;</a>
<a name="ln6869">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln6870"> </a>
<a name="ln6871">	// loop through all poses to find match</a>
<a name="ln6872">	for (int32 j = 0; j &lt; CountColumns(); j++) {</a>
<a name="ln6873">		BColumn* column = ColumnAt(j);</a>
<a name="ln6874"> </a>
<a name="ln6875">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln6876">			BPose* pose = fPoseList-&gt;ItemAt(i);</a>
<a name="ln6877">			float score = -1;</a>
<a name="ln6878"> </a>
<a name="ln6879">			if (ViewMode() == kListMode) {</a>
<a name="ln6880">				ModelNodeLazyOpener modelOpener(pose-&gt;TargetModel());</a>
<a name="ln6881">				BTextWidget* widget = pose-&gt;WidgetFor(column, this,</a>
<a name="ln6882">					modelOpener);</a>
<a name="ln6883">				const char* text = NULL;</a>
<a name="ln6884">				if (widget != NULL)</a>
<a name="ln6885">					text = widget-&gt;Text(this);</a>
<a name="ln6886"> </a>
<a name="ln6887">				if (text != NULL)</a>
<a name="ln6888">					score = ComputeTypeAheadScore(text, sMatchString.String());</a>
<a name="ln6889">			} else {</a>
<a name="ln6890">				score = ComputeTypeAheadScore(pose-&gt;TargetModel()-&gt;Name(),</a>
<a name="ln6891">					sMatchString.String());</a>
<a name="ln6892">			}</a>
<a name="ln6893"> </a>
<a name="ln6894">			if (score &gt; bestScore) {</a>
<a name="ln6895">				poseToSelect = pose;</a>
<a name="ln6896">				bestScore = score;</a>
<a name="ln6897">				*index = i;</a>
<a name="ln6898">			}</a>
<a name="ln6899">			if (score == kExactMatchScore)</a>
<a name="ln6900">				break;</a>
<a name="ln6901">		}</a>
<a name="ln6902"> </a>
<a name="ln6903">		// TODO: we might want to change this to make it always work</a>
<a name="ln6904">		// over all columns, but this would require some more changes</a>
<a name="ln6905">		// to how Tracker represents data (for example we could filter</a>
<a name="ln6906">		// the results out).</a>
<a name="ln6907">		if (bestScore &gt; 0 || ViewMode() != kListMode)</a>
<a name="ln6908">			break;</a>
<a name="ln6909">	}</a>
<a name="ln6910"> </a>
<a name="ln6911">	return poseToSelect;</a>
<a name="ln6912">}</a>
<a name="ln6913"> </a>
<a name="ln6914"> </a>
<a name="ln6915">static bool</a>
<a name="ln6916">LinesIntersect(float s1, float e1, float s2, float e2)</a>
<a name="ln6917">{</a>
<a name="ln6918">	return std::max(s1, s2) &lt; std::min(e1, e2);</a>
<a name="ln6919">}</a>
<a name="ln6920"> </a>
<a name="ln6921"> </a>
<a name="ln6922">BPose*</a>
<a name="ln6923">BPoseView::FindNearbyPose(char arrowKey, int32* poseIndex)</a>
<a name="ln6924">{</a>
<a name="ln6925">	int32 resultingIndex = -1;</a>
<a name="ln6926">	BPose* poseToSelect = NULL;</a>
<a name="ln6927">	BPose* selectedPose = fSelectionList-&gt;LastItem();</a>
<a name="ln6928"> </a>
<a name="ln6929">	if (ViewMode() == kListMode) {</a>
<a name="ln6930">		PoseList* poseList = CurrentPoseList();</a>
<a name="ln6931"> </a>
<a name="ln6932">		switch (arrowKey) {</a>
<a name="ln6933">			case B_UP_ARROW:</a>
<a name="ln6934">			case B_LEFT_ARROW:</a>
<a name="ln6935">				if (selectedPose) {</a>
<a name="ln6936">					resultingIndex = poseList-&gt;IndexOf(selectedPose) - 1;</a>
<a name="ln6937">					poseToSelect = poseList-&gt;ItemAt(resultingIndex);</a>
<a name="ln6938">					if (poseToSelect == NULL &amp;&amp; arrowKey == B_LEFT_ARROW) {</a>
<a name="ln6939">						resultingIndex = poseList-&gt;CountItems() - 1;</a>
<a name="ln6940">						poseToSelect = poseList-&gt;LastItem();</a>
<a name="ln6941">					}</a>
<a name="ln6942">				} else {</a>
<a name="ln6943">					resultingIndex = poseList-&gt;CountItems() - 1;</a>
<a name="ln6944">					poseToSelect = poseList-&gt;LastItem();</a>
<a name="ln6945">				}</a>
<a name="ln6946">				break;</a>
<a name="ln6947"> </a>
<a name="ln6948">			case B_DOWN_ARROW:</a>
<a name="ln6949">			case B_RIGHT_ARROW:</a>
<a name="ln6950">				if (selectedPose) {</a>
<a name="ln6951">					resultingIndex = poseList-&gt;IndexOf(selectedPose) + 1;</a>
<a name="ln6952">					poseToSelect = poseList-&gt;ItemAt(resultingIndex);</a>
<a name="ln6953">					if (poseToSelect == NULL &amp;&amp; arrowKey == B_RIGHT_ARROW) {</a>
<a name="ln6954">						resultingIndex = 0;</a>
<a name="ln6955">						poseToSelect = poseList-&gt;FirstItem();</a>
<a name="ln6956">					}</a>
<a name="ln6957">				} else {</a>
<a name="ln6958">					resultingIndex = 0;</a>
<a name="ln6959">					poseToSelect = poseList-&gt;FirstItem();</a>
<a name="ln6960">				}</a>
<a name="ln6961">				break;</a>
<a name="ln6962">		}</a>
<a name="ln6963">		*poseIndex = resultingIndex;</a>
<a name="ln6964"> </a>
<a name="ln6965">		return poseToSelect;</a>
<a name="ln6966">	}</a>
<a name="ln6967"> </a>
<a name="ln6968">	// must be in one of the icon modes</a>
<a name="ln6969"> </a>
<a name="ln6970">	// handle case where there is no current selection</a>
<a name="ln6971">	if (fSelectionList-&gt;IsEmpty()) {</a>
<a name="ln6972">		// find the upper-left pose (I know it's ugly!)</a>
<a name="ln6973">		poseToSelect = fVSPoseList-&gt;FirstItem();</a>
<a name="ln6974">		for (int32 index = 0; ;index++) {</a>
<a name="ln6975">			BPose* pose = fVSPoseList-&gt;ItemAt(++index);</a>
<a name="ln6976">			if (pose == NULL)</a>
<a name="ln6977">				break;</a>
<a name="ln6978"> </a>
<a name="ln6979">			if (poseToSelect != NULL) {</a>
<a name="ln6980">				BRect selectedBounds;</a>
<a name="ln6981">				selectedBounds = poseToSelect-&gt;CalcRect(this);</a>
<a name="ln6982">				BRect poseRect(pose-&gt;CalcRect(this));</a>
<a name="ln6983"> </a>
<a name="ln6984">				if (poseRect.top &gt; selectedBounds.top)</a>
<a name="ln6985">					break;</a>
<a name="ln6986"> </a>
<a name="ln6987">				if (poseRect.left &lt; selectedBounds.left)</a>
<a name="ln6988">					poseToSelect = pose;</a>
<a name="ln6989">			}</a>
<a name="ln6990">		}</a>
<a name="ln6991"> </a>
<a name="ln6992">		return poseToSelect;</a>
<a name="ln6993">	}</a>
<a name="ln6994"> </a>
<a name="ln6995">	BRect selectionRect;</a>
<a name="ln6996">	if (selectedPose != NULL)</a>
<a name="ln6997">		selectionRect = selectedPose-&gt;CalcRect(this);</a>
<a name="ln6998"> </a>
<a name="ln6999">	BRect bestRect;</a>
<a name="ln7000"> </a>
<a name="ln7001">	// we're not in list mode so scan visually for pose to select</a>
<a name="ln7002">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln7003">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln7004">		BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln7005">		BRect poseRect(pose-&gt;CalcRect(this));</a>
<a name="ln7006"> </a>
<a name="ln7007">		switch (arrowKey) {</a>
<a name="ln7008">			case B_LEFT_ARROW:</a>
<a name="ln7009">				if (LinesIntersect(poseRect.top, poseRect.bottom,</a>
<a name="ln7010">						selectionRect.top, selectionRect.bottom)</a>
<a name="ln7011">					&amp;&amp; poseRect.left &lt; selectionRect.left</a>
<a name="ln7012">					&amp;&amp; (poseRect.left &gt; bestRect.left</a>
<a name="ln7013">						|| !bestRect.IsValid())) {</a>
<a name="ln7014">					bestRect = poseRect;</a>
<a name="ln7015">					poseToSelect = pose;</a>
<a name="ln7016">				}</a>
<a name="ln7017">				break;</a>
<a name="ln7018"> </a>
<a name="ln7019">			case B_RIGHT_ARROW:</a>
<a name="ln7020">				if (LinesIntersect(poseRect.top, poseRect.bottom,</a>
<a name="ln7021">						selectionRect.top, selectionRect.bottom)</a>
<a name="ln7022">					&amp;&amp; poseRect.right &gt; selectionRect.right</a>
<a name="ln7023">					&amp;&amp; (poseRect.right &lt; bestRect.right</a>
<a name="ln7024">							|| !bestRect.IsValid())) {</a>
<a name="ln7025">					bestRect = poseRect;</a>
<a name="ln7026">					poseToSelect = pose;</a>
<a name="ln7027">				}</a>
<a name="ln7028">				break;</a>
<a name="ln7029"> </a>
<a name="ln7030">			case B_UP_ARROW:</a>
<a name="ln7031">				if (LinesIntersect(poseRect.left, poseRect.right,</a>
<a name="ln7032">						selectionRect.left, selectionRect.right)</a>
<a name="ln7033">					&amp;&amp; poseRect.top &lt; selectionRect.top</a>
<a name="ln7034">					&amp;&amp; (poseRect.top &gt; bestRect.top</a>
<a name="ln7035">						|| !bestRect.IsValid())) {</a>
<a name="ln7036">					bestRect = poseRect;</a>
<a name="ln7037">					poseToSelect = pose;</a>
<a name="ln7038">				}</a>
<a name="ln7039">				break;</a>
<a name="ln7040"> </a>
<a name="ln7041">			case B_DOWN_ARROW:</a>
<a name="ln7042">				if (LinesIntersect(poseRect.left, poseRect.right,</a>
<a name="ln7043">						selectionRect.left, selectionRect.right)</a>
<a name="ln7044">					&amp;&amp; poseRect.bottom &gt; selectionRect.bottom</a>
<a name="ln7045">					&amp;&amp; (poseRect.bottom &lt; bestRect.bottom</a>
<a name="ln7046">						|| !bestRect.IsValid())) {</a>
<a name="ln7047">					bestRect = poseRect;</a>
<a name="ln7048">					poseToSelect = pose;</a>
<a name="ln7049">				}</a>
<a name="ln7050">				break;</a>
<a name="ln7051">		}</a>
<a name="ln7052">	}</a>
<a name="ln7053"> </a>
<a name="ln7054">	if (poseToSelect != NULL)</a>
<a name="ln7055">		return poseToSelect;</a>
<a name="ln7056"> </a>
<a name="ln7057">	return selectedPose;</a>
<a name="ln7058">}</a>
<a name="ln7059"> </a>
<a name="ln7060"> </a>
<a name="ln7061">void</a>
<a name="ln7062">BPoseView::ShowContextMenu(BPoint where)</a>
<a name="ln7063">{</a>
<a name="ln7064">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln7065">	if (window == NULL)</a>
<a name="ln7066">		return;</a>
<a name="ln7067"> </a>
<a name="ln7068">	// handle pose selection</a>
<a name="ln7069">	int32 index;</a>
<a name="ln7070">	BPose* pose = FindPose(where, &amp;index);</a>
<a name="ln7071">	if (pose != NULL) {</a>
<a name="ln7072">		if (!pose-&gt;IsSelected()) {</a>
<a name="ln7073">			ClearSelection();</a>
<a name="ln7074">			pose-&gt;Select(true);</a>
<a name="ln7075">			fSelectionList-&gt;AddItem(pose);</a>
<a name="ln7076">			DrawPose(pose, index, false);</a>
<a name="ln7077">		}</a>
<a name="ln7078">	} else</a>
<a name="ln7079">		ClearSelection();</a>
<a name="ln7080"> </a>
<a name="ln7081">	window-&gt;Activate();</a>
<a name="ln7082">	window-&gt;UpdateIfNeeded();</a>
<a name="ln7083">	window-&gt;ShowContextMenu(where,</a>
<a name="ln7084">		pose ? pose-&gt;TargetModel()-&gt;EntryRef() : 0, this);</a>
<a name="ln7085"> </a>
<a name="ln7086">	if (fSelectionChangedHook)</a>
<a name="ln7087">		window-&gt;SelectionChanged();</a>
<a name="ln7088">}</a>
<a name="ln7089"> </a>
<a name="ln7090"> </a>
<a name="ln7091">void</a>
<a name="ln7092">BPoseView::_BeginSelectionRect(const BPoint&amp; point, bool shouldExtend)</a>
<a name="ln7093">{</a>
<a name="ln7094">	// set initial empty selection rectangle</a>
<a name="ln7095">	fSelectionRectInfo.rect = BRect(point, point - BPoint(1, 1));</a>
<a name="ln7096"> </a>
<a name="ln7097">	if (!fTransparentSelection) {</a>
<a name="ln7098">		SetDrawingMode(B_OP_INVERT);</a>
<a name="ln7099">		StrokeRect(fSelectionRectInfo.rect, B_MIXED_COLORS);</a>
<a name="ln7100">		SetDrawingMode(B_OP_OVER);</a>
<a name="ln7101">	}</a>
<a name="ln7102"> </a>
<a name="ln7103">	fSelectionRectInfo.lastRect = fSelectionRectInfo.rect;</a>
<a name="ln7104">	fSelectionRectInfo.selection = new BList;</a>
<a name="ln7105">	fSelectionRectInfo.startPoint = point;</a>
<a name="ln7106">	fSelectionRectInfo.lastPoint = point;</a>
<a name="ln7107">	fSelectionRectInfo.isDragging = true;</a>
<a name="ln7108"> </a>
<a name="ln7109">	if (fAutoScrollState == kAutoScrollOff) {</a>
<a name="ln7110">		fAutoScrollState = kAutoScrollOn;</a>
<a name="ln7111">		Window()-&gt;SetPulseRate(20000);</a>
<a name="ln7112">	}</a>
<a name="ln7113">}</a>
<a name="ln7114"> </a>
<a name="ln7115"> </a>
<a name="ln7116">static void</a>
<a name="ln7117">AddIfPoseSelected(BPose* pose, PoseList* list)</a>
<a name="ln7118">{</a>
<a name="ln7119">	if (pose-&gt;IsSelected())</a>
<a name="ln7120">		list-&gt;AddItem(pose);</a>
<a name="ln7121">}</a>
<a name="ln7122"> </a>
<a name="ln7123"> </a>
<a name="ln7124">void</a>
<a name="ln7125">BPoseView::_UpdateSelectionRect(const BPoint&amp; point)</a>
<a name="ln7126">{</a>
<a name="ln7127">	if (point != fSelectionRectInfo.lastPoint) {</a>
<a name="ln7128">		fSelectionRectInfo.lastPoint = point;</a>
<a name="ln7129"> </a>
<a name="ln7130">		// erase last rect</a>
<a name="ln7131">		if (!fTransparentSelection) {</a>
<a name="ln7132">			SetDrawingMode(B_OP_INVERT);</a>
<a name="ln7133">			StrokeRect(fSelectionRectInfo.rect, B_MIXED_COLORS);</a>
<a name="ln7134">			SetDrawingMode(B_OP_OVER);</a>
<a name="ln7135">		}</a>
<a name="ln7136"> </a>
<a name="ln7137">		fSelectionRectInfo.rect.top = std::min(point.y,</a>
<a name="ln7138">			fSelectionRectInfo.startPoint.y);</a>
<a name="ln7139">		fSelectionRectInfo.rect.left = std::min(point.x,</a>
<a name="ln7140">			fSelectionRectInfo.startPoint.x);</a>
<a name="ln7141">		fSelectionRectInfo.rect.bottom = std::max(point.y,</a>
<a name="ln7142">			fSelectionRectInfo.startPoint.y);</a>
<a name="ln7143">		fSelectionRectInfo.rect.right = std::max(point.x,</a>
<a name="ln7144">			fSelectionRectInfo.startPoint.x);</a>
<a name="ln7145"> </a>
<a name="ln7146">		fIsDrawingSelectionRect = true;</a>
<a name="ln7147"> </a>
<a name="ln7148">		// use current selection rectangle to scan poses</a>
<a name="ln7149">		if (ViewMode() == kListMode) {</a>
<a name="ln7150">			SelectPosesListMode(fSelectionRectInfo.rect,</a>
<a name="ln7151">				&amp;fSelectionRectInfo.selection);</a>
<a name="ln7152">		} else {</a>
<a name="ln7153">			SelectPosesIconMode(fSelectionRectInfo.rect,</a>
<a name="ln7154">				&amp;fSelectionRectInfo.selection);</a>
<a name="ln7155">		}</a>
<a name="ln7156"> </a>
<a name="ln7157">		Window()-&gt;UpdateIfNeeded();</a>
<a name="ln7158"> </a>
<a name="ln7159">		// draw new rect</a>
<a name="ln7160">		if (!fTransparentSelection) {</a>
<a name="ln7161">			SetDrawingMode(B_OP_INVERT);</a>
<a name="ln7162">			StrokeRect(fSelectionRectInfo.rect, B_MIXED_COLORS);</a>
<a name="ln7163">			SetDrawingMode(B_OP_OVER);</a>
<a name="ln7164">		} else {</a>
<a name="ln7165">			BRegion updateRegion1;</a>
<a name="ln7166">			BRegion updateRegion2;</a>
<a name="ln7167"> </a>
<a name="ln7168">			bool sameWidth = fSelectionRectInfo.rect.Width()</a>
<a name="ln7169">				== fSelectionRectInfo.lastRect.Width();</a>
<a name="ln7170">			bool sameHeight = fSelectionRectInfo.rect.Height()</a>
<a name="ln7171">				== fSelectionRectInfo.lastRect.Height();</a>
<a name="ln7172"> </a>
<a name="ln7173">			updateRegion1.Include(fSelectionRectInfo.rect);</a>
<a name="ln7174">			updateRegion1.Exclude(fSelectionRectInfo.lastRect.InsetByCopy(</a>
<a name="ln7175">				sameWidth ? 0 : 1, sameHeight ? 0 : 1));</a>
<a name="ln7176">			updateRegion2.Include(fSelectionRectInfo.lastRect);</a>
<a name="ln7177">			updateRegion2.Exclude(fSelectionRectInfo.rect.InsetByCopy(</a>
<a name="ln7178">				sameWidth ? 0 : 1, sameHeight ? 0 : 1));</a>
<a name="ln7179">			updateRegion1.Include(&amp;updateRegion2);</a>
<a name="ln7180">			BRect unionRect = fSelectionRectInfo.rect</a>
<a name="ln7181">				&amp; fSelectionRectInfo.lastRect;</a>
<a name="ln7182">			updateRegion1.Exclude(unionRect</a>
<a name="ln7183">				&amp; BRect(-2000, fSelectionRectInfo.startPoint.y, 2000,</a>
<a name="ln7184">				fSelectionRectInfo.startPoint.y));</a>
<a name="ln7185">			updateRegion1.Exclude(unionRect</a>
<a name="ln7186">				&amp; BRect(fSelectionRectInfo.startPoint.x, -2000,</a>
<a name="ln7187">				fSelectionRectInfo.startPoint.x, 2000));</a>
<a name="ln7188"> </a>
<a name="ln7189">			fSelectionRectInfo.lastRect = fSelectionRectInfo.rect;</a>
<a name="ln7190"> </a>
<a name="ln7191">			Invalidate(&amp;updateRegion1);</a>
<a name="ln7192">			Window()-&gt;UpdateIfNeeded();</a>
<a name="ln7193">		}</a>
<a name="ln7194">		Flush();</a>
<a name="ln7195">	}</a>
<a name="ln7196">}</a>
<a name="ln7197"> </a>
<a name="ln7198"> </a>
<a name="ln7199">void</a>
<a name="ln7200">BPoseView::_EndSelectionRect()</a>
<a name="ln7201">{</a>
<a name="ln7202">	delete fSelectionRectInfo.selection;</a>
<a name="ln7203">	fSelectionRectInfo.selection = NULL;</a>
<a name="ln7204"> </a>
<a name="ln7205">	fSelectionRectInfo.isDragging = false;</a>
<a name="ln7206">	fIsDrawingSelectionRect = false;</a>
<a name="ln7207">		// TODO: remove BPose dependency?</a>
<a name="ln7208"> </a>
<a name="ln7209">	// do final erase of selection rect</a>
<a name="ln7210">	if (!fTransparentSelection) {</a>
<a name="ln7211">		SetDrawingMode(B_OP_INVERT);</a>
<a name="ln7212">		StrokeRect(fSelectionRectInfo.rect, B_MIXED_COLORS);</a>
<a name="ln7213">		SetDrawingMode(B_OP_COPY);</a>
<a name="ln7214">		fSelectionRectInfo.rect.Set(0, 0, -1, -1);</a>
<a name="ln7215">	} else {</a>
<a name="ln7216">		Invalidate(fSelectionRectInfo.rect);</a>
<a name="ln7217">		fSelectionRectInfo.rect.Set(0, 0, -1, -1);</a>
<a name="ln7218">		Window()-&gt;UpdateIfNeeded();</a>
<a name="ln7219">	}</a>
<a name="ln7220"> </a>
<a name="ln7221">	// we now need to update the pose view's selection list by clearing it</a>
<a name="ln7222">	// and then polling each pose for selection state and rebuilding list</a>
<a name="ln7223">	fSelectionList-&gt;MakeEmpty();</a>
<a name="ln7224">	fMimeTypesInSelectionCache.MakeEmpty();</a>
<a name="ln7225"> </a>
<a name="ln7226">	EachListItem(fPoseList, AddIfPoseSelected, fSelectionList);</a>
<a name="ln7227"> </a>
<a name="ln7228">	// and now make sure that the pivot point is in sync</a>
<a name="ln7229">	if (fSelectionPivotPose &amp;&amp; !fSelectionList-&gt;HasItem(fSelectionPivotPose))</a>
<a name="ln7230">		fSelectionPivotPose = NULL;</a>
<a name="ln7231">	if (fRealPivotPose &amp;&amp; !fSelectionList-&gt;HasItem(fRealPivotPose))</a>
<a name="ln7232">		fRealPivotPose = NULL;</a>
<a name="ln7233">}</a>
<a name="ln7234"> </a>
<a name="ln7235"> </a>
<a name="ln7236">void</a>
<a name="ln7237">BPoseView::MouseMoved(BPoint where, uint32 transit, const BMessage* dragMessage)</a>
<a name="ln7238">{</a>
<a name="ln7239">	if (fSelectionRectInfo.isDragging)</a>
<a name="ln7240">		_UpdateSelectionRect(where);</a>
<a name="ln7241"> </a>
<a name="ln7242">	if (!fDropEnabled || dragMessage == NULL)</a>
<a name="ln7243">		return;</a>
<a name="ln7244"> </a>
<a name="ln7245">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln7246">	if (window == NULL)</a>
<a name="ln7247">		return;</a>
<a name="ln7248"> </a>
<a name="ln7249">	if (!window-&gt;Dragging())</a>
<a name="ln7250">		window-&gt;DragStart(dragMessage);</a>
<a name="ln7251"> </a>
<a name="ln7252">	switch (transit) {</a>
<a name="ln7253">		case B_INSIDE_VIEW:</a>
<a name="ln7254">		case B_ENTERED_VIEW:</a>
<a name="ln7255">			UpdateDropTarget(where, dragMessage, window-&gt;ContextMenu());</a>
<a name="ln7256">			if (fAutoScrollState == kAutoScrollOff) {</a>
<a name="ln7257">				// turn on auto scrolling if it's not yet on</a>
<a name="ln7258">				fAutoScrollState = kWaitForTransition;</a>
<a name="ln7259">				window-&gt;SetPulseRate(100000);</a>
<a name="ln7260">			}</a>
<a name="ln7261">			break;</a>
<a name="ln7262"> </a>
<a name="ln7263">		case B_EXITED_VIEW:</a>
<a name="ln7264">			DragStop();</a>
<a name="ln7265">			// reset cursor in case we set it to the copy cursor</a>
<a name="ln7266">			// in UpdateDropTarget</a>
<a name="ln7267">			SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln7268">			fCursorCheck = false;</a>
<a name="ln7269">			// TODO: autoscroll here</a>
<a name="ln7270">			if (!window-&gt;ContextMenu()) {</a>
<a name="ln7271">				HiliteDropTarget(false);</a>
<a name="ln7272">				fDropTarget = NULL;</a>
<a name="ln7273">			}</a>
<a name="ln7274">			break;</a>
<a name="ln7275">	}</a>
<a name="ln7276">}</a>
<a name="ln7277"> </a>
<a name="ln7278"> </a>
<a name="ln7279">void</a>
<a name="ln7280">BPoseView::MouseDragged(const BMessage* message)</a>
<a name="ln7281">{</a>
<a name="ln7282">	if (fTextWidgetToCheck != NULL)</a>
<a name="ln7283">		fTextWidgetToCheck-&gt;CancelWait();</a>
<a name="ln7284"> </a>
<a name="ln7285">	fTrackRightMouseUp = false;</a>
<a name="ln7286"> </a>
<a name="ln7287">	BPoint where;</a>
<a name="ln7288">	uint32 buttons = 0;</a>
<a name="ln7289">	if (message-&gt;FindPoint(&quot;be:view_where&quot;, &amp;where) != B_OK</a>
<a name="ln7290">		|| message-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons) != B_OK) {</a>
<a name="ln7291">		return;</a>
<a name="ln7292">	}</a>
<a name="ln7293"> </a>
<a name="ln7294">	bool extendSelection = (modifiers() &amp; B_COMMAND_KEY) != 0</a>
<a name="ln7295">		&amp;&amp; fMultipleSelection;</a>
<a name="ln7296"> </a>
<a name="ln7297">	int32 index;</a>
<a name="ln7298">	BPose* pose = FindPose(where, &amp;index);</a>
<a name="ln7299">	if (pose != NULL)</a>
<a name="ln7300">		DragSelectedPoses(pose, where);</a>
<a name="ln7301">	else if (buttons == B_PRIMARY_MOUSE_BUTTON)</a>
<a name="ln7302">		_BeginSelectionRect(where, extendSelection);</a>
<a name="ln7303">}</a>
<a name="ln7304"> </a>
<a name="ln7305"> </a>
<a name="ln7306">void</a>
<a name="ln7307">BPoseView::MouseLongDown(const BMessage* message)</a>
<a name="ln7308">{</a>
<a name="ln7309">	fTrackRightMouseUp = false;</a>
<a name="ln7310"> </a>
<a name="ln7311">	BPoint where;</a>
<a name="ln7312">	if (message-&gt;FindPoint(&quot;where&quot;, &amp;where) != B_OK)</a>
<a name="ln7313">		return;</a>
<a name="ln7314"> </a>
<a name="ln7315">	ShowContextMenu(where);</a>
<a name="ln7316">}</a>
<a name="ln7317"> </a>
<a name="ln7318"> </a>
<a name="ln7319">void</a>
<a name="ln7320">BPoseView::MouseIdle(const BMessage* message)</a>
<a name="ln7321">{</a>
<a name="ln7322">	BPoint where;</a>
<a name="ln7323">	uint32 buttons = 0;</a>
<a name="ln7324">	GetMouse(&amp;where, &amp;buttons);</a>
<a name="ln7325">		// We could retrieve 'where' from the incoming</a>
<a name="ln7326">		// message but we need the buttons state anyway</a>
<a name="ln7327">		// and B_MOUSE_IDLE message doesn't pass it</a>
<a name="ln7328">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln7329"> </a>
<a name="ln7330">	if (buttons == 0 || window == NULL || !window-&gt;Dragging())</a>
<a name="ln7331">		return;</a>
<a name="ln7332"> </a>
<a name="ln7333">	if (fDropTarget != NULL) {</a>
<a name="ln7334">		FrameForPose(fDropTarget, true, &amp;fStartFrame);</a>
<a name="ln7335">		ShowContextMenu(where);</a>
<a name="ln7336">	} else</a>
<a name="ln7337">		window-&gt;Activate();</a>
<a name="ln7338">}</a>
<a name="ln7339"> </a>
<a name="ln7340"> </a>
<a name="ln7341">void</a>
<a name="ln7342">BPoseView::MouseDown(BPoint where)</a>
<a name="ln7343">{</a>
<a name="ln7344">	// handle disposing of drag data lazily</a>
<a name="ln7345">	DragStop();</a>
<a name="ln7346">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln7347">	if (window == NULL)</a>
<a name="ln7348">		return;</a>
<a name="ln7349"> </a>
<a name="ln7350">	if (IsDesktopWindow()) {</a>
<a name="ln7351">		BScreen screen(Window());</a>
<a name="ln7352">		rgb_color color = screen.DesktopColor();</a>
<a name="ln7353">		SetLowColor(color);</a>
<a name="ln7354">		SetViewColor(color);</a>
<a name="ln7355">	}</a>
<a name="ln7356"> </a>
<a name="ln7357">	MakeFocus();</a>
<a name="ln7358"> </a>
<a name="ln7359">	uint32 buttons = (uint32)window-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;);</a>
<a name="ln7360">	uint32 modifierKeys = modifiers();</a>
<a name="ln7361">	bool secondaryMouseButtonDown</a>
<a name="ln7362">		= SecondaryMouseButtonDown(modifierKeys, buttons);</a>
<a name="ln7363">	fTrackRightMouseUp = secondaryMouseButtonDown;</a>
<a name="ln7364">	bool extendSelection = (modifierKeys &amp; B_COMMAND_KEY) != 0</a>
<a name="ln7365">		&amp;&amp; fMultipleSelection;</a>
<a name="ln7366"> </a>
<a name="ln7367">	CommitActivePose();</a>
<a name="ln7368"> </a>
<a name="ln7369">	int32 index;</a>
<a name="ln7370">	BPose* pose = FindPose(where, &amp;index);</a>
<a name="ln7371">	if (pose != NULL) {</a>
<a name="ln7372">		if (!pose-&gt;IsSelected() || !secondaryMouseButtonDown)</a>
<a name="ln7373">			AddRemoveSelectionRange(where, extendSelection, pose);</a>
<a name="ln7374"> </a>
<a name="ln7375">		if (fTextWidgetToCheck != NULL</a>
<a name="ln7376">			&amp;&amp; (pose != fLastClickedPose || secondaryMouseButtonDown)) {</a>
<a name="ln7377">			fTextWidgetToCheck-&gt;CancelWait();</a>
<a name="ln7378">		}</a>
<a name="ln7379"> </a>
<a name="ln7380">		if (!extendSelection &amp;&amp; WasDoubleClick(pose, where, buttons)</a>
<a name="ln7381">			&amp;&amp; buttons == B_PRIMARY_MOUSE_BUTTON</a>
<a name="ln7382">			&amp;&amp; fLastClickButtons == B_PRIMARY_MOUSE_BUTTON</a>
<a name="ln7383">			&amp;&amp; (modifierKeys &amp; B_CONTROL_KEY) == 0) {</a>
<a name="ln7384">			// special handling for path field double-clicks</a>
<a name="ln7385">			if (!WasClickInPath(pose, index, where))</a>
<a name="ln7386">				OpenSelection(pose, &amp;index);</a>
<a name="ln7387">		}</a>
<a name="ln7388">	} else {</a>
<a name="ln7389">		// click was not in any pose</a>
<a name="ln7390">		fLastClickedPose = NULL;</a>
<a name="ln7391">		if (fTextWidgetToCheck != NULL)</a>
<a name="ln7392">			fTextWidgetToCheck-&gt;CancelWait();</a>
<a name="ln7393"> </a>
<a name="ln7394">		window-&gt;Activate();</a>
<a name="ln7395">		window-&gt;UpdateIfNeeded();</a>
<a name="ln7396"> </a>
<a name="ln7397">		// only clear selection if we are not extending it</a>
<a name="ln7398">		if (!extendSelection || !fSelectionRectEnabled || !fMultipleSelection)</a>
<a name="ln7399">			ClearSelection();</a>
<a name="ln7400"> </a>
<a name="ln7401">		// show desktop context menu</a>
<a name="ln7402">		if (SecondaryMouseButtonDown(modifierKeys, buttons))</a>
<a name="ln7403">			ShowContextMenu(where);</a>
<a name="ln7404">	}</a>
<a name="ln7405"> </a>
<a name="ln7406">	if (fSelectionChangedHook)</a>
<a name="ln7407">		window-&gt;SelectionChanged();</a>
<a name="ln7408">}</a>
<a name="ln7409"> </a>
<a name="ln7410"> </a>
<a name="ln7411">void</a>
<a name="ln7412">BPoseView::SetTextWidgetToCheck(BTextWidget* widget, BTextWidget* old)</a>
<a name="ln7413">{</a>
<a name="ln7414">	if (old == NULL || fTextWidgetToCheck == old)</a>
<a name="ln7415">		fTextWidgetToCheck = widget;</a>
<a name="ln7416">}</a>
<a name="ln7417"> </a>
<a name="ln7418"> </a>
<a name="ln7419">void</a>
<a name="ln7420">BPoseView::MouseUp(BPoint where)</a>
<a name="ln7421">{</a>
<a name="ln7422">	if (fSelectionRectInfo.isDragging)</a>
<a name="ln7423">		_EndSelectionRect();</a>
<a name="ln7424"> </a>
<a name="ln7425">	int32 index;</a>
<a name="ln7426">	BPose* pose = FindPose(where, &amp;index);</a>
<a name="ln7427">	uint32 lastButtons = Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;last_buttons&quot;);</a>
<a name="ln7428">	if (pose != NULL &amp;&amp; fLastClickedPose != NULL &amp;&amp; fAllowPoseEditing</a>
<a name="ln7429">		&amp;&amp; !fTrackRightMouseUp) {</a>
<a name="ln7430">		// This handy field has been added by the tracking filter.</a>
<a name="ln7431">		// we need lastButtons for right button mouse-up tracking,</a>
<a name="ln7432">		// because there's currently no way to know wich buttons were</a>
<a name="ln7433">		// released in BView::MouseUp (unlike BView::KeyUp)</a>
<a name="ln7434">		pose-&gt;MouseUp(BPoint(0, index * fListElemHeight), this, where, index);</a>
<a name="ln7435">	}</a>
<a name="ln7436"> </a>
<a name="ln7437">	// Showing the pose context menu is done on mouse up (or long click)</a>
<a name="ln7438">	// to make right button dragging possible</a>
<a name="ln7439">	if (pose != NULL &amp;&amp; fTrackRightMouseUp</a>
<a name="ln7440">		&amp;&amp; (SecondaryMouseButtonDown(modifiers(), lastButtons))) {</a>
<a name="ln7441">		if (!pose-&gt;IsSelected()) {</a>
<a name="ln7442">			ClearSelection();</a>
<a name="ln7443">			pose-&gt;Select(true);</a>
<a name="ln7444">			fSelectionList-&gt;AddItem(pose);</a>
<a name="ln7445">			DrawPose(pose, index, false);</a>
<a name="ln7446">		}</a>
<a name="ln7447">		ShowContextMenu(where);</a>
<a name="ln7448">	}</a>
<a name="ln7449">	fTrackRightMouseUp = false;</a>
<a name="ln7450">}</a>
<a name="ln7451"> </a>
<a name="ln7452"> </a>
<a name="ln7453">bool</a>
<a name="ln7454">BPoseView::WasClickInPath(const BPose* pose, int32 index,</a>
<a name="ln7455">	BPoint mouseLocation) const</a>
<a name="ln7456">{</a>
<a name="ln7457">	if (pose == NULL || (ViewMode() != kListMode))</a>
<a name="ln7458">		return false;</a>
<a name="ln7459"> </a>
<a name="ln7460">	BPoint loc(0, index * fListElemHeight);</a>
<a name="ln7461">	BTextWidget* widget;</a>
<a name="ln7462">	if (!pose-&gt;PointInPose(loc, this, mouseLocation, &amp;widget) || !widget)</a>
<a name="ln7463">		return false;</a>
<a name="ln7464"> </a>
<a name="ln7465">	// note: the following code is wrong, because this sort of hashing</a>
<a name="ln7466">	// may overlap and we get aliasing</a>
<a name="ln7467">	if (widget-&gt;AttrHash() != AttrHashString(kAttrPath, B_STRING_TYPE))</a>
<a name="ln7468">		return false;</a>
<a name="ln7469"> </a>
<a name="ln7470">	BEntry entry(widget-&gt;Text(this));</a>
<a name="ln7471">	if (entry.InitCheck() != B_OK)</a>
<a name="ln7472">		return false;</a>
<a name="ln7473"> </a>
<a name="ln7474">	entry_ref ref;</a>
<a name="ln7475">	if (entry.GetRef(&amp;ref) == B_OK) {</a>
<a name="ln7476">		BMessage message(B_REFS_RECEIVED);</a>
<a name="ln7477">		message.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln7478">		be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln7479">		return true;</a>
<a name="ln7480">	}</a>
<a name="ln7481"> </a>
<a name="ln7482">	return false;</a>
<a name="ln7483">}</a>
<a name="ln7484"> </a>
<a name="ln7485"> </a>
<a name="ln7486">bool</a>
<a name="ln7487">BPoseView::WasDoubleClick(const BPose* pose, BPoint point, int32 buttons)</a>
<a name="ln7488">{</a>
<a name="ln7489">	// check proximity</a>
<a name="ln7490">	BPoint delta = point - fLastClickPoint;</a>
<a name="ln7491">	int32 clicks = Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;clicks&quot;);</a>
<a name="ln7492"> </a>
<a name="ln7493">	if (clicks == 2</a>
<a name="ln7494">		&amp;&amp; fabs(delta.x) &lt; kDoubleClickTresh</a>
<a name="ln7495">		&amp;&amp; fabs(delta.y) &lt; kDoubleClickTresh</a>
<a name="ln7496">		&amp;&amp; pose == fLastClickedPose) {</a>
<a name="ln7497">		fLastClickPoint.Set(INT32_MAX, INT32_MAX);</a>
<a name="ln7498">		fLastClickedPose = NULL;</a>
<a name="ln7499">		if (fTextWidgetToCheck != NULL)</a>
<a name="ln7500">			fTextWidgetToCheck-&gt;CancelWait();</a>
<a name="ln7501"> </a>
<a name="ln7502">		return buttons == fLastClickButtons;</a>
<a name="ln7503">	}</a>
<a name="ln7504"> </a>
<a name="ln7505">	fLastClickPoint = point;</a>
<a name="ln7506">	fLastClickedPose = pose;</a>
<a name="ln7507">	fLastClickButtons = buttons;</a>
<a name="ln7508"> </a>
<a name="ln7509">	return false;</a>
<a name="ln7510">}</a>
<a name="ln7511"> </a>
<a name="ln7512"> </a>
<a name="ln7513">static void</a>
<a name="ln7514">AddPoseRefToMessage(Model* model, BMessage* message)</a>
<a name="ln7515">{</a>
<a name="ln7516">	// Make sure that every file added to the message has its</a>
<a name="ln7517">	// MIME type set.</a>
<a name="ln7518">	BNode node(model-&gt;EntryRef());</a>
<a name="ln7519">	if (node.InitCheck() == B_OK) {</a>
<a name="ln7520">		BNodeInfo info(&amp;node);</a>
<a name="ln7521">		char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln7522">		type[0] = '\0';</a>
<a name="ln7523">		if (info.GetType(type) != B_OK) {</a>
<a name="ln7524">			BPath path(model-&gt;EntryRef());</a>
<a name="ln7525">			if (path.InitCheck() == B_OK)</a>
<a name="ln7526">				update_mime_info(path.Path(), false, false, false);</a>
<a name="ln7527">		}</a>
<a name="ln7528">	}</a>
<a name="ln7529">	message-&gt;AddRef(&quot;refs&quot;, model-&gt;EntryRef());</a>
<a name="ln7530">}</a>
<a name="ln7531"> </a>
<a name="ln7532"> </a>
<a name="ln7533">void</a>
<a name="ln7534">BPoseView::DragSelectedPoses(const BPose* pose, BPoint clickPoint)</a>
<a name="ln7535">{</a>
<a name="ln7536">	if (!fDragEnabled)</a>
<a name="ln7537">		return;</a>
<a name="ln7538"> </a>
<a name="ln7539">	ASSERT(pose);</a>
<a name="ln7540"> </a>
<a name="ln7541">	// make sure pose is selected, it could have been deselected as part of</a>
<a name="ln7542">	// a click during selection extention</a>
<a name="ln7543">	if (!pose-&gt;IsSelected())</a>
<a name="ln7544">		return;</a>
<a name="ln7545"> </a>
<a name="ln7546">	// setup tracking rect by unioning all selected pose rects</a>
<a name="ln7547">	BMessage message(B_SIMPLE_DATA);</a>
<a name="ln7548">	message.AddPointer(&quot;src_window&quot;, Window());</a>
<a name="ln7549">	message.AddPoint(&quot;click_pt&quot;, clickPoint);</a>
<a name="ln7550"> </a>
<a name="ln7551">	// add Tracker token so that refs received recipients can script us</a>
<a name="ln7552">	message.AddMessenger(&quot;TrackerViewToken&quot;, BMessenger(this));</a>
<a name="ln7553"> </a>
<a name="ln7554">	// cannot use EachPoseAndModel here, because that iterates the selected</a>
<a name="ln7555">	// poses in reverse order</a>
<a name="ln7556">	for (int32 index = 0; index &lt; fSelectionList-&gt;CountItems(); index++) {</a>
<a name="ln7557">		AddPoseRefToMessage(fSelectionList-&gt;ItemAt(index)-&gt;TargetModel(),</a>
<a name="ln7558">			&amp;message);</a>
<a name="ln7559">	}</a>
<a name="ln7560"> </a>
<a name="ln7561">	// make sure button is still down</a>
<a name="ln7562">	uint32 buttons;</a>
<a name="ln7563">	BPoint tempLoc;</a>
<a name="ln7564">	GetMouse(&amp;tempLoc, &amp;buttons);</a>
<a name="ln7565">	if (buttons != 0) {</a>
<a name="ln7566">		int32 index = CurrentPoseList()-&gt;IndexOf(pose);</a>
<a name="ln7567">		message.AddInt32(&quot;buttons&quot;, (int32)buttons);</a>
<a name="ln7568">		BRect dragRect(GetDragRect(index));</a>
<a name="ln7569">		BBitmap* dragBitmap = NULL;</a>
<a name="ln7570">		BPoint offset;</a>
<a name="ln7571">#ifdef DRAG_FRAME</a>
<a name="ln7572">		if (dragRect.Width() &lt; kTransparentDragThreshold.x</a>
<a name="ln7573">			&amp;&amp; dragRect.Height() &lt; kTransparentDragThreshold.y) {</a>
<a name="ln7574">			dragBitmap = MakeDragBitmap(dragRect, clickPoint, index, offset);</a>
<a name="ln7575">		}</a>
<a name="ln7576">#else</a>
<a name="ln7577">		// The bitmap is now always created (if DRAG_FRAME is not defined)</a>
<a name="ln7578">		dragBitmap = MakeDragBitmap(dragRect, clickPoint, index, offset);</a>
<a name="ln7579">#endif</a>
<a name="ln7580">		if (dragBitmap != NULL) {</a>
<a name="ln7581">			DragMessage(&amp;message, dragBitmap, B_OP_ALPHA, offset);</a>
<a name="ln7582">				// this DragMessage supports alpha blending</a>
<a name="ln7583">		} else</a>
<a name="ln7584">			DragMessage(&amp;message, dragRect);</a>
<a name="ln7585"> </a>
<a name="ln7586">		// turn on auto scrolling</a>
<a name="ln7587">		fAutoScrollState = kWaitForTransition;</a>
<a name="ln7588">		Window()-&gt;SetPulseRate(100000);</a>
<a name="ln7589">	}</a>
<a name="ln7590">}</a>
<a name="ln7591"> </a>
<a name="ln7592"> </a>
<a name="ln7593">BBitmap*</a>
<a name="ln7594">BPoseView::MakeDragBitmap(BRect dragRect, BPoint clickedPoint,</a>
<a name="ln7595">	int32 clickedPoseIndex, BPoint &amp;offset)</a>
<a name="ln7596">{</a>
<a name="ln7597">	BRect inner(clickedPoint.x - kTransparentDragThreshold.x / 2,</a>
<a name="ln7598">		clickedPoint.y - kTransparentDragThreshold.y / 2,</a>
<a name="ln7599">		clickedPoint.x + kTransparentDragThreshold.x / 2,</a>
<a name="ln7600">		clickedPoint.y + kTransparentDragThreshold.y / 2);</a>
<a name="ln7601"> </a>
<a name="ln7602">	// (BRect &amp; BRect) doesn't work correctly if the rectangles don't intersect</a>
<a name="ln7603">	// this catches a bug that is produced somewhere before this function is</a>
<a name="ln7604">	// called</a>
<a name="ln7605">	if (!inner.Intersects(dragRect))</a>
<a name="ln7606">		return NULL;</a>
<a name="ln7607"> </a>
<a name="ln7608">	inner = inner &amp; dragRect;</a>
<a name="ln7609"> </a>
<a name="ln7610">	// If the selection is bigger than the specified limit, the</a>
<a name="ln7611">	// contents will fade out when they come near the borders</a>
<a name="ln7612">	bool fadeTop = false;</a>
<a name="ln7613">	bool fadeBottom = false;</a>
<a name="ln7614">	bool fadeLeft = false;</a>
<a name="ln7615">	bool fadeRight = false;</a>
<a name="ln7616">	bool fade = false;</a>
<a name="ln7617">	if (inner.left &gt; dragRect.left) {</a>
<a name="ln7618">		inner.left = std::max(inner.left - 32, dragRect.left);</a>
<a name="ln7619">		fade = fadeLeft = true;</a>
<a name="ln7620">	}</a>
<a name="ln7621">	if (inner.right &lt; dragRect.right) {</a>
<a name="ln7622">		inner.right = std::min(inner.right + 32, dragRect.right);</a>
<a name="ln7623">		fade = fadeRight = true;</a>
<a name="ln7624">	}</a>
<a name="ln7625">	if (inner.top &gt; dragRect.top) {</a>
<a name="ln7626">		inner.top = std::max(inner.top - 32, dragRect.top);</a>
<a name="ln7627">		fade = fadeTop = true;</a>
<a name="ln7628">	}</a>
<a name="ln7629">	if (inner.bottom &lt; dragRect.bottom) {</a>
<a name="ln7630">		inner.bottom = std::min(inner.bottom + 32, dragRect.bottom);</a>
<a name="ln7631">		fade = fadeBottom = true;</a>
<a name="ln7632">	}</a>
<a name="ln7633"> </a>
<a name="ln7634">	// set the offset for the dragged bitmap (for the BView::DragMessage() call)</a>
<a name="ln7635">	offset = clickedPoint - BPoint(2, 1) - inner.LeftTop();</a>
<a name="ln7636"> </a>
<a name="ln7637">	BRect rect(inner);</a>
<a name="ln7638">	rect.OffsetTo(B_ORIGIN);</a>
<a name="ln7639"> </a>
<a name="ln7640">	BBitmap* bitmap = new BBitmap(rect, B_RGBA32, true);</a>
<a name="ln7641">	bitmap-&gt;Lock();</a>
<a name="ln7642">	BView* view = new BView(bitmap-&gt;Bounds(), &quot;&quot;, B_FOLLOW_NONE, 0);</a>
<a name="ln7643">	bitmap-&gt;AddChild(view);</a>
<a name="ln7644"> </a>
<a name="ln7645">	view-&gt;SetOrigin(0, 0);</a>
<a name="ln7646"> </a>
<a name="ln7647">	BRect clipRect(view-&gt;Bounds());</a>
<a name="ln7648">	BRegion newClip;</a>
<a name="ln7649">	newClip.Set(clipRect);</a>
<a name="ln7650">	view-&gt;ConstrainClippingRegion(&amp;newClip);</a>
<a name="ln7651"> </a>
<a name="ln7652">	memset(bitmap-&gt;Bits(), 0, bitmap-&gt;BitsLength());</a>
<a name="ln7653"> </a>
<a name="ln7654">	view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln7655">	view-&gt;SetHighColor(0, 0, 0, uint8(fade ? 164 : 128));</a>
<a name="ln7656">		// set the level of transparency by value</a>
<a name="ln7657">	view-&gt;SetBlendingMode(B_CONSTANT_ALPHA, B_ALPHA_COMPOSITE);</a>
<a name="ln7658"> </a>
<a name="ln7659">	BRect bounds(Bounds());</a>
<a name="ln7660"> </a>
<a name="ln7661">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln7662">	if (ViewMode() == kListMode) {</a>
<a name="ln7663">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln7664">		int32 startIndex = (int32)(bounds.top / fListElemHeight);</a>
<a name="ln7665">		BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln7666"> </a>
<a name="ln7667">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln7668">			BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln7669">			if (pose-&gt;IsSelected()) {</a>
<a name="ln7670">				BRect poseRect(pose-&gt;CalcRect(loc, this, true));</a>
<a name="ln7671">				if (poseRect.Intersects(inner)) {</a>
<a name="ln7672">					BPoint offsetBy(-inner.LeftTop().x, -inner.LeftTop().y);</a>
<a name="ln7673">					pose-&gt;Draw(poseRect, poseRect, this, view, true, offsetBy,</a>
<a name="ln7674">						false);</a>
<a name="ln7675">				}</a>
<a name="ln7676">			}</a>
<a name="ln7677">			loc.y += fListElemHeight;</a>
<a name="ln7678">			if (loc.y &gt; bounds.bottom)</a>
<a name="ln7679">				break;</a>
<a name="ln7680">		}</a>
<a name="ln7681">	} else {</a>
<a name="ln7682">		// add rects for visible poses only (uses VSList!!)</a>
<a name="ln7683">		int32 startIndex</a>
<a name="ln7684">			= FirstIndexAtOrBelow((int32)(bounds.top - IconPoseHeight()));</a>
<a name="ln7685">		int32 count = fVSPoseList-&gt;CountItems();</a>
<a name="ln7686"> </a>
<a name="ln7687">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln7688">			BPose* pose = fVSPoseList-&gt;ItemAt(index);</a>
<a name="ln7689">			if (pose != NULL &amp;&amp; pose-&gt;IsSelected()) {</a>
<a name="ln7690">				BRect poseRect(pose-&gt;CalcRect(this));</a>
<a name="ln7691">				if (!poseRect.Intersects(inner))</a>
<a name="ln7692">					continue;</a>
<a name="ln7693"> </a>
<a name="ln7694">				BPoint offsetBy(-inner.LeftTop().x, -inner.LeftTop().y);</a>
<a name="ln7695">				pose-&gt;Draw(poseRect, poseRect, this, view, true, offsetBy,</a>
<a name="ln7696">					false);</a>
<a name="ln7697">			}</a>
<a name="ln7698">		}</a>
<a name="ln7699">	}</a>
<a name="ln7700"> </a>
<a name="ln7701">	view-&gt;Sync();</a>
<a name="ln7702"> </a>
<a name="ln7703">	// fade out the contents if necessary</a>
<a name="ln7704">	if (fade) {</a>
<a name="ln7705">		uint32* bits = (uint32*)bitmap-&gt;Bits();</a>
<a name="ln7706">		int32 width = bitmap-&gt;BytesPerRow() / 4;</a>
<a name="ln7707"> </a>
<a name="ln7708">		if (fadeLeft)</a>
<a name="ln7709">			FadeRGBA32Horizontal(bits, width, int32(rect.bottom), 0, 64);</a>
<a name="ln7710"> </a>
<a name="ln7711">		if (fadeRight) {</a>
<a name="ln7712">			FadeRGBA32Horizontal(bits, width, int32(rect.bottom),</a>
<a name="ln7713">				int32(rect.right), int32(rect.right) - 64);</a>
<a name="ln7714">		}</a>
<a name="ln7715"> </a>
<a name="ln7716">		if (fadeTop)</a>
<a name="ln7717">			FadeRGBA32Vertical(bits, width, int32(rect.bottom), 0, 64);</a>
<a name="ln7718"> </a>
<a name="ln7719">		if (fadeBottom) {</a>
<a name="ln7720">			FadeRGBA32Vertical(bits, width, int32(rect.bottom),</a>
<a name="ln7721">				int32(rect.bottom), int32(rect.bottom) - 64);</a>
<a name="ln7722">		}</a>
<a name="ln7723">	}</a>
<a name="ln7724"> </a>
<a name="ln7725">	bitmap-&gt;Unlock();</a>
<a name="ln7726">	return bitmap;</a>
<a name="ln7727">}</a>
<a name="ln7728"> </a>
<a name="ln7729"> </a>
<a name="ln7730">BRect</a>
<a name="ln7731">BPoseView::GetDragRect(int32 clickedPoseIndex)</a>
<a name="ln7732">{</a>
<a name="ln7733">	BRect result;</a>
<a name="ln7734">	BRect bounds(Bounds());</a>
<a name="ln7735"> </a>
<a name="ln7736">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln7737">	BPose* pose = poseList-&gt;ItemAt(clickedPoseIndex);</a>
<a name="ln7738">	if (ViewMode() == kListMode) {</a>
<a name="ln7739">		// get starting rect of clicked pose</a>
<a name="ln7740">		result = CalcPoseRectList(pose, clickedPoseIndex, true);</a>
<a name="ln7741"> </a>
<a name="ln7742">		// add rects for visible poses only</a>
<a name="ln7743">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln7744">		int32 startIndex = (int32)(bounds.top / fListElemHeight);</a>
<a name="ln7745">		BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln7746"> </a>
<a name="ln7747">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln7748">			pose = poseList-&gt;ItemAt(index);</a>
<a name="ln7749">			if (pose-&gt;IsSelected())</a>
<a name="ln7750">				result = result | pose-&gt;CalcRect(loc, this, true);</a>
<a name="ln7751"> </a>
<a name="ln7752">			loc.y += fListElemHeight;</a>
<a name="ln7753">			if (loc.y &gt; bounds.bottom)</a>
<a name="ln7754">				break;</a>
<a name="ln7755">		}</a>
<a name="ln7756">	} else {</a>
<a name="ln7757">		// get starting rect of clicked pose</a>
<a name="ln7758">		result = pose-&gt;CalcRect(this);</a>
<a name="ln7759"> </a>
<a name="ln7760">		// add rects for visible poses only (uses VSList!!)</a>
<a name="ln7761">		int32 count = fVSPoseList-&gt;CountItems();</a>
<a name="ln7762">		for (int32 index = FirstIndexAtOrBelow(</a>
<a name="ln7763">					(int32)(bounds.top - IconPoseHeight()));</a>
<a name="ln7764">				index &lt; count; index++) {</a>
<a name="ln7765">			BPose* pose = fVSPoseList-&gt;ItemAt(index);</a>
<a name="ln7766">			if (pose != NULL) {</a>
<a name="ln7767">				if (pose-&gt;IsSelected())</a>
<a name="ln7768">					result = result | pose-&gt;CalcRect(this);</a>
<a name="ln7769"> </a>
<a name="ln7770">				if (pose-&gt;Location(this).y &gt; bounds.bottom)</a>
<a name="ln7771">					break;</a>
<a name="ln7772">			}</a>
<a name="ln7773">		}</a>
<a name="ln7774">	}</a>
<a name="ln7775"> </a>
<a name="ln7776">	return result;</a>
<a name="ln7777">}</a>
<a name="ln7778"> </a>
<a name="ln7779"> </a>
<a name="ln7780">// TODO: SelectPosesListMode and SelectPosesIconMode are terrible and share</a>
<a name="ln7781">// most code</a>
<a name="ln7782">void</a>
<a name="ln7783">BPoseView::SelectPosesListMode(BRect selectionRect, BList** oldList)</a>
<a name="ln7784">{</a>
<a name="ln7785">	ASSERT(ViewMode() == kListMode);</a>
<a name="ln7786"> </a>
<a name="ln7787">	// collect all the poses which are enclosed inside the selection rect</a>
<a name="ln7788">	BList* newList = new BList;</a>
<a name="ln7789">	BRect bounds(Bounds());</a>
<a name="ln7790">	SetDrawingMode(B_OP_COPY);</a>
<a name="ln7791">		// TODO: I _think_ there is no more synchronous drawing here,</a>
<a name="ln7792">		// so this should be save to remove</a>
<a name="ln7793"> </a>
<a name="ln7794">	int32 startIndex = (int32)(selectionRect.top / fListElemHeight);</a>
<a name="ln7795">	if (startIndex &lt; 0)</a>
<a name="ln7796">		startIndex = 0;</a>
<a name="ln7797"> </a>
<a name="ln7798">	BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln7799"> </a>
<a name="ln7800">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln7801">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln7802">	for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln7803">		BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln7804">		BRect poseRect(pose-&gt;CalcRect(loc, this));</a>
<a name="ln7805"> </a>
<a name="ln7806">		if (selectionRect.Intersects(poseRect)) {</a>
<a name="ln7807">			bool selected = pose-&gt;IsSelected();</a>
<a name="ln7808">			pose-&gt;Select(!fSelectionList-&gt;HasItem(pose));</a>
<a name="ln7809">			newList-&gt;AddItem((void*)(addr_t)index);</a>
<a name="ln7810">				// this sucks, need to clean up using a vector class instead</a>
<a name="ln7811">				// of BList</a>
<a name="ln7812"> </a>
<a name="ln7813">			if ((selected != pose-&gt;IsSelected())</a>
<a name="ln7814">				&amp;&amp; poseRect.Intersects(bounds)) {</a>
<a name="ln7815">				Invalidate(poseRect);</a>
<a name="ln7816">			}</a>
<a name="ln7817"> </a>
<a name="ln7818">			// First Pose selected gets to be the pivot.</a>
<a name="ln7819">			if ((fSelectionPivotPose == NULL) &amp;&amp; (selected == false))</a>
<a name="ln7820">				fSelectionPivotPose = pose;</a>
<a name="ln7821">		}</a>
<a name="ln7822"> </a>
<a name="ln7823">		loc.y += fListElemHeight;</a>
<a name="ln7824">		if (loc.y &gt; selectionRect.bottom)</a>
<a name="ln7825">			break;</a>
<a name="ln7826">	}</a>
<a name="ln7827"> </a>
<a name="ln7828">	// take the old set of enclosed poses and invert selection state</a>
<a name="ln7829">	// on those which are no longer enclosed</a>
<a name="ln7830">	count = (*oldList)-&gt;CountItems();</a>
<a name="ln7831">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln7832">		int32 oldIndex = (addr_t)(*oldList)-&gt;ItemAt(index);</a>
<a name="ln7833"> </a>
<a name="ln7834">		if (!newList-&gt;HasItem((void*)(addr_t)oldIndex)) {</a>
<a name="ln7835">			BPose* pose = poseList-&gt;ItemAt(oldIndex);</a>
<a name="ln7836">			pose-&gt;Select(!pose-&gt;IsSelected());</a>
<a name="ln7837">			loc.Set(0, oldIndex * fListElemHeight);</a>
<a name="ln7838">			BRect poseRect(pose-&gt;CalcRect(loc, this));</a>
<a name="ln7839"> </a>
<a name="ln7840">			if (poseRect.Intersects(bounds))</a>
<a name="ln7841">				Invalidate(poseRect);</a>
<a name="ln7842">		}</a>
<a name="ln7843">	}</a>
<a name="ln7844"> </a>
<a name="ln7845">	delete* oldList;</a>
<a name="ln7846">	*oldList = newList;</a>
<a name="ln7847">}</a>
<a name="ln7848"> </a>
<a name="ln7849"> </a>
<a name="ln7850">void</a>
<a name="ln7851">BPoseView::SelectPosesIconMode(BRect selectionRect, BList** oldList)</a>
<a name="ln7852">{</a>
<a name="ln7853">	ASSERT(ViewMode() != kListMode);</a>
<a name="ln7854"> </a>
<a name="ln7855">	// collect all the poses which are enclosed inside the selection rect</a>
<a name="ln7856">	BList* newList = new BList;</a>
<a name="ln7857">	BRect bounds(Bounds());</a>
<a name="ln7858">	SetDrawingMode(B_OP_COPY);</a>
<a name="ln7859"> </a>
<a name="ln7860">	int32 startIndex = FirstIndexAtOrBelow(</a>
<a name="ln7861">		(int32)(selectionRect.top - IconPoseHeight()), true);</a>
<a name="ln7862">	if (startIndex &lt; 0)</a>
<a name="ln7863">		startIndex = 0;</a>
<a name="ln7864"> </a>
<a name="ln7865">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln7866">	for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln7867">		BPose* pose = fVSPoseList-&gt;ItemAt(index);</a>
<a name="ln7868">		if (pose != NULL) {</a>
<a name="ln7869">			BRect poseRect(pose-&gt;CalcRect(this));</a>
<a name="ln7870"> </a>
<a name="ln7871">			if (selectionRect.Intersects(poseRect)) {</a>
<a name="ln7872">				bool selected = pose-&gt;IsSelected();</a>
<a name="ln7873">				pose-&gt;Select(!fSelectionList-&gt;HasItem(pose));</a>
<a name="ln7874">				newList-&gt;AddItem((void*)(addr_t)index);</a>
<a name="ln7875"> </a>
<a name="ln7876">				if ((selected != pose-&gt;IsSelected())</a>
<a name="ln7877">					&amp;&amp; poseRect.Intersects(bounds)) {</a>
<a name="ln7878">					Invalidate(poseRect);</a>
<a name="ln7879">				}</a>
<a name="ln7880"> </a>
<a name="ln7881">				// first Pose selected gets to be the pivot</a>
<a name="ln7882">				if ((fSelectionPivotPose == NULL) &amp;&amp; (selected == false))</a>
<a name="ln7883">					fSelectionPivotPose = pose;</a>
<a name="ln7884">			}</a>
<a name="ln7885"> </a>
<a name="ln7886">			if (pose-&gt;Location(this).y &gt; selectionRect.bottom)</a>
<a name="ln7887">				break;</a>
<a name="ln7888">		}</a>
<a name="ln7889">	}</a>
<a name="ln7890"> </a>
<a name="ln7891">	// take the old set of enclosed poses and invert selection state</a>
<a name="ln7892">	// on those which are no longer enclosed</a>
<a name="ln7893">	count = (*oldList)-&gt;CountItems();</a>
<a name="ln7894">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln7895">		int32 oldIndex = (addr_t)(*oldList)-&gt;ItemAt(index);</a>
<a name="ln7896"> </a>
<a name="ln7897">		if (!newList-&gt;HasItem((void*)(addr_t)oldIndex)) {</a>
<a name="ln7898">			BPose* pose = fVSPoseList-&gt;ItemAt(oldIndex);</a>
<a name="ln7899">			pose-&gt;Select(!pose-&gt;IsSelected());</a>
<a name="ln7900">			BRect poseRect(pose-&gt;CalcRect(this));</a>
<a name="ln7901"> </a>
<a name="ln7902">			if (poseRect.Intersects(bounds))</a>
<a name="ln7903">				Invalidate(poseRect);</a>
<a name="ln7904">		}</a>
<a name="ln7905">	}</a>
<a name="ln7906"> </a>
<a name="ln7907">	delete* oldList;</a>
<a name="ln7908">	*oldList = newList;</a>
<a name="ln7909">}</a>
<a name="ln7910"> </a>
<a name="ln7911"> </a>
<a name="ln7912">void</a>
<a name="ln7913">BPoseView::AddRemoveSelectionRange(BPoint where, bool extendSelection,</a>
<a name="ln7914">	BPose* pose)</a>
<a name="ln7915">{</a>
<a name="ln7916">	ASSERT(pose != NULL);</a>
<a name="ln7917"> </a>
<a name="ln7918"> 	if (pose == fSelectionPivotPose &amp;&amp; !extendSelection)</a>
<a name="ln7919"> 		return;</a>
<a name="ln7920"> </a>
<a name="ln7921">	if (fMultipleSelection &amp;&amp; (modifiers() &amp; B_SHIFT_KEY) != 0 &amp;&amp; fSelectionPivotPose) {</a>
<a name="ln7922">		// multi pose extend/shrink current selection</a>
<a name="ln7923">		bool select = !pose-&gt;IsSelected() || !extendSelection;</a>
<a name="ln7924">			// This weird bit of logic causes the selection to always</a>
<a name="ln7925">			// center around the pivot point, unless you choose to hold</a>
<a name="ln7926">			// down COMMAND, which will unselect between the pivot and</a>
<a name="ln7927">			// the most recently selected Pose.</a>
<a name="ln7928"> </a>
<a name="ln7929">		if (!extendSelection) {</a>
<a name="ln7930">			// Remember fSelectionPivotPose because ClearSelection() NULLs it</a>
<a name="ln7931">			// and we need it to be preserved.</a>
<a name="ln7932">			const BPose* savedPivotPose = fSelectionPivotPose;</a>
<a name="ln7933"> 			ClearSelection();</a>
<a name="ln7934">	 		fSelectionPivotPose = savedPivotPose;</a>
<a name="ln7935">		}</a>
<a name="ln7936"> </a>
<a name="ln7937">		if (ViewMode() == kListMode) {</a>
<a name="ln7938">			PoseList* poseList = CurrentPoseList();</a>
<a name="ln7939">			int32 currentSelectedIndex = poseList-&gt;IndexOf(pose);</a>
<a name="ln7940">			int32 lastSelectedIndex = poseList-&gt;IndexOf(fSelectionPivotPose);</a>
<a name="ln7941"> </a>
<a name="ln7942">			int32 startRange;</a>
<a name="ln7943">			int32 endRange;</a>
<a name="ln7944"> </a>
<a name="ln7945">			if (lastSelectedIndex &lt; currentSelectedIndex) {</a>
<a name="ln7946">				startRange = lastSelectedIndex;</a>
<a name="ln7947">				endRange = currentSelectedIndex;</a>
<a name="ln7948">			} else {</a>
<a name="ln7949">				startRange = currentSelectedIndex;</a>
<a name="ln7950">				endRange = lastSelectedIndex;</a>
<a name="ln7951">			}</a>
<a name="ln7952"> </a>
<a name="ln7953">			for (int32 i = startRange; i &lt;= endRange; i++)</a>
<a name="ln7954">				AddRemovePoseFromSelection(poseList-&gt;ItemAt(i), i, select);</a>
<a name="ln7955">		} else {</a>
<a name="ln7956">			BRect selection(where, fSelectionPivotPose-&gt;Location(this));</a>
<a name="ln7957"> </a>
<a name="ln7958">			// Things will get odd if we don't 'fix' the selection rect.</a>
<a name="ln7959">			if (selection.left &gt; selection.right)</a>
<a name="ln7960">				std::swap(selection.left, selection.right);</a>
<a name="ln7961"> </a>
<a name="ln7962">			if (selection.top &gt; selection.bottom)</a>
<a name="ln7963">				std::swap(selection.top, selection.bottom);</a>
<a name="ln7964"> </a>
<a name="ln7965">			// If the selection rect is not at least 1 pixel high/wide, things</a>
<a name="ln7966">			// are also not going to work out.</a>
<a name="ln7967">			if (selection.IntegerWidth() &lt; 1)</a>
<a name="ln7968">				selection.right = selection.left + 1.0f;</a>
<a name="ln7969"> </a>
<a name="ln7970">			if (selection.IntegerHeight() &lt; 1)</a>
<a name="ln7971">				selection.bottom = selection.top + 1.0f;</a>
<a name="ln7972"> </a>
<a name="ln7973">			ASSERT(selection.IsValid());</a>
<a name="ln7974"> </a>
<a name="ln7975">			int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln7976">			for (int32 index = count - 1; index &gt;= 0; index--) {</a>
<a name="ln7977">				BPose* currPose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln7978">				// TODO: works only in non-list mode?</a>
<a name="ln7979">				if (selection.Intersects(currPose-&gt;CalcRect(this)))</a>
<a name="ln7980">					AddRemovePoseFromSelection(currPose, index, select);</a>
<a name="ln7981">			}</a>
<a name="ln7982">		}</a>
<a name="ln7983">	} else {</a>
<a name="ln7984">		int32 index = CurrentPoseList()-&gt;IndexOf(pose);</a>
<a name="ln7985">		if (!extendSelection) {</a>
<a name="ln7986">			if (!pose-&gt;IsSelected()) {</a>
<a name="ln7987">				// create new selection</a>
<a name="ln7988">				ClearSelection();</a>
<a name="ln7989">				AddRemovePoseFromSelection(pose, index, true);</a>
<a name="ln7990">				fSelectionPivotPose = pose;</a>
<a name="ln7991">			}</a>
<a name="ln7992">		} else {</a>
<a name="ln7993">			fMimeTypesInSelectionCache.MakeEmpty();</a>
<a name="ln7994">			AddRemovePoseFromSelection(pose, index, !pose-&gt;IsSelected());</a>
<a name="ln7995">		}</a>
<a name="ln7996">	}</a>
<a name="ln7997"> </a>
<a name="ln7998">	// If the list is empty, there cannot be a pivot pose,</a>
<a name="ln7999">	// however if the list is not empty there must be a pivot</a>
<a name="ln8000">	// pose.</a>
<a name="ln8001">	if (fSelectionList-&gt;IsEmpty()) {</a>
<a name="ln8002">		fSelectionPivotPose = NULL;</a>
<a name="ln8003">		fRealPivotPose = NULL;</a>
<a name="ln8004">	} else if (fSelectionPivotPose == NULL) {</a>
<a name="ln8005">		fSelectionPivotPose = pose;</a>
<a name="ln8006">		fRealPivotPose = pose;</a>
<a name="ln8007">	}</a>
<a name="ln8008">}</a>
<a name="ln8009"> </a>
<a name="ln8010"> </a>
<a name="ln8011">void</a>
<a name="ln8012">BPoseView::DeleteSymLinkPoseTarget(const node_ref* itemNode, BPose* pose,</a>
<a name="ln8013">	int32 index)</a>
<a name="ln8014">{</a>
<a name="ln8015">	ASSERT(pose-&gt;TargetModel()-&gt;IsSymLink());</a>
<a name="ln8016">	watch_node(itemNode, B_STOP_WATCHING, this);</a>
<a name="ln8017"> </a>
<a name="ln8018">	// watch the parent of the symlink, so that we know when the symlink</a>
<a name="ln8019">	// can be considered fixed.</a>
<a name="ln8020">	WatchParentOf(pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln8021"> </a>
<a name="ln8022">	BPoint loc(0, index * fListElemHeight);</a>
<a name="ln8023">	pose-&gt;TargetModel()-&gt;SetLinkTo(NULL);</a>
<a name="ln8024">	pose-&gt;UpdateBrokenSymLink(loc, this);</a>
<a name="ln8025">}</a>
<a name="ln8026"> </a>
<a name="ln8027"> </a>
<a name="ln8028">bool</a>
<a name="ln8029">BPoseView::DeletePose(const node_ref* itemNode, BPose* pose, int32 index)</a>
<a name="ln8030">{</a>
<a name="ln8031">	watch_node(itemNode, B_STOP_WATCHING, this);</a>
<a name="ln8032"> </a>
<a name="ln8033">	if (pose == NULL)</a>
<a name="ln8034">		pose = fPoseList-&gt;FindPose(itemNode, &amp;index);</a>
<a name="ln8035"> </a>
<a name="ln8036">	if (pose != NULL) {</a>
<a name="ln8037">		fInsertedNodes.erase(fInsertedNodes.find(*itemNode));</a>
<a name="ln8038">		if (pose-&gt;TargetModel()-&gt;IsSymLink()) {</a>
<a name="ln8039">			fBrokenLinks-&gt;RemoveItem(pose-&gt;TargetModel());</a>
<a name="ln8040">			StopWatchingParentsOf(pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln8041">			Model* target = pose-&gt;TargetModel()-&gt;LinkTo();</a>
<a name="ln8042">			if (target)</a>
<a name="ln8043">				watch_node(target-&gt;NodeRef(), B_STOP_WATCHING, this);</a>
<a name="ln8044">		}</a>
<a name="ln8045"> </a>
<a name="ln8046">		ASSERT(TargetModel());</a>
<a name="ln8047"> </a>
<a name="ln8048">		if (pose == fDropTarget)</a>
<a name="ln8049">			fDropTarget = NULL;</a>
<a name="ln8050"> </a>
<a name="ln8051">		if (pose == ActivePose())</a>
<a name="ln8052">			CommitActivePose();</a>
<a name="ln8053"> </a>
<a name="ln8054">		Window()-&gt;UpdateIfNeeded();</a>
<a name="ln8055"> </a>
<a name="ln8056">		// remove it from list no matter what since it might be in list</a>
<a name="ln8057">		// but not &quot;selected&quot; since selection is hidden</a>
<a name="ln8058">		fSelectionList-&gt;RemoveItem(pose);</a>
<a name="ln8059">		if (fSelectionPivotPose == pose)</a>
<a name="ln8060">			fSelectionPivotPose = NULL;</a>
<a name="ln8061">		if (fRealPivotPose == pose)</a>
<a name="ln8062">			fRealPivotPose = NULL;</a>
<a name="ln8063"> </a>
<a name="ln8064">		if (pose-&gt;IsSelected() &amp;&amp; fSelectionChangedHook)</a>
<a name="ln8065">			ContainerWindow()-&gt;SelectionChanged();</a>
<a name="ln8066"> </a>
<a name="ln8067">		fPoseList-&gt;RemoveItemAt(index);</a>
<a name="ln8068"> </a>
<a name="ln8069">		bool visible = true;</a>
<a name="ln8070">		if (fFiltering) {</a>
<a name="ln8071">			if (fFilteredPoseList-&gt;FindPose(itemNode, &amp;index) != NULL)</a>
<a name="ln8072">				fFilteredPoseList-&gt;RemoveItemAt(index);</a>
<a name="ln8073">			else</a>
<a name="ln8074">				visible = false;</a>
<a name="ln8075">		}</a>
<a name="ln8076"> </a>
<a name="ln8077">		fMimeTypeListIsDirty = true;</a>
<a name="ln8078"> </a>
<a name="ln8079">		if (pose-&gt;HasLocation())</a>
<a name="ln8080">			RemoveFromVSList(pose);</a>
<a name="ln8081"> </a>
<a name="ln8082">		if (visible) {</a>
<a name="ln8083">			BRect invalidRect;</a>
<a name="ln8084">			if (ViewMode() == kListMode)</a>
<a name="ln8085">				invalidRect = CalcPoseRectList(pose, index);</a>
<a name="ln8086">			else</a>
<a name="ln8087">				invalidRect = pose-&gt;CalcRect(this);</a>
<a name="ln8088"> </a>
<a name="ln8089">			if (ViewMode() == kListMode)</a>
<a name="ln8090">				CloseGapInList(&amp;invalidRect);</a>
<a name="ln8091">			else</a>
<a name="ln8092">				RemoveFromExtent(invalidRect);</a>
<a name="ln8093"> </a>
<a name="ln8094">			Invalidate(invalidRect);</a>
<a name="ln8095">			UpdateCount();</a>
<a name="ln8096">			UpdateScrollRange();</a>
<a name="ln8097">			ResetPosePlacementHint();</a>
<a name="ln8098"> </a>
<a name="ln8099">			if (ViewMode() == kListMode) {</a>
<a name="ln8100">				BRect bounds(Bounds());</a>
<a name="ln8101">				int32 index = (int32)(bounds.bottom / fListElemHeight);</a>
<a name="ln8102">				BPose* pose = CurrentPoseList()-&gt;ItemAt(index);</a>
<a name="ln8103"> </a>
<a name="ln8104">				if (pose == NULL &amp;&amp; bounds.top &gt; 0) {</a>
<a name="ln8105">					// scroll up a little</a>
<a name="ln8106">					BView::ScrollTo(bounds.left,</a>
<a name="ln8107">						std::max(bounds.top - fListElemHeight, 0.0f));</a>
<a name="ln8108">				}</a>
<a name="ln8109">			}</a>
<a name="ln8110">		}</a>
<a name="ln8111"> </a>
<a name="ln8112">		delete pose;</a>
<a name="ln8113">	} else {</a>
<a name="ln8114">		// we might be getting a delete for an item in the zombie list</a>
<a name="ln8115">		Model* zombie = FindZombie(itemNode, &amp;index);</a>
<a name="ln8116">		if (zombie) {</a>
<a name="ln8117">			PRINT((&quot;deleting zombie model %s\n&quot;, zombie-&gt;Name()));</a>
<a name="ln8118">			fZombieList-&gt;RemoveItemAt(index);</a>
<a name="ln8119">			delete zombie;</a>
<a name="ln8120">		} else</a>
<a name="ln8121">			return false;</a>
<a name="ln8122">	}</a>
<a name="ln8123"> </a>
<a name="ln8124">	return true;</a>
<a name="ln8125">}</a>
<a name="ln8126"> </a>
<a name="ln8127"> </a>
<a name="ln8128">Model*</a>
<a name="ln8129">BPoseView::FindZombie(const node_ref* itemNode, int32* resultingIndex)</a>
<a name="ln8130">{</a>
<a name="ln8131">	int32 count = fZombieList-&gt;CountItems();</a>
<a name="ln8132">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln8133">		Model* zombie = fZombieList-&gt;ItemAt(index);</a>
<a name="ln8134">		if (*zombie-&gt;NodeRef() == *itemNode) {</a>
<a name="ln8135">			if (resultingIndex)</a>
<a name="ln8136">				*resultingIndex = index;</a>
<a name="ln8137">			return zombie;</a>
<a name="ln8138">		}</a>
<a name="ln8139">	}</a>
<a name="ln8140"> </a>
<a name="ln8141">	return NULL;</a>
<a name="ln8142">}</a>
<a name="ln8143"> </a>
<a name="ln8144"> </a>
<a name="ln8145">// return pose at location h,v (search list starting from bottom so</a>
<a name="ln8146">// drawing and hit detection reflect the same pose ordering)</a>
<a name="ln8147">BPose*</a>
<a name="ln8148">BPoseView::FindPose(BPoint point, int32* poseIndex) const</a>
<a name="ln8149">{</a>
<a name="ln8150">	if (ViewMode() == kListMode) {</a>
<a name="ln8151">		int32 index = (int32)(point.y / fListElemHeight);</a>
<a name="ln8152">		if (poseIndex != NULL)</a>
<a name="ln8153">			*poseIndex = index;</a>
<a name="ln8154"> </a>
<a name="ln8155">		BPoint loc(0, index * fListElemHeight);</a>
<a name="ln8156">		BPose* pose = CurrentPoseList()-&gt;ItemAt(index);</a>
<a name="ln8157">		if (pose != NULL &amp;&amp; pose-&gt;PointInPose(loc, this, point))</a>
<a name="ln8158">			return pose;</a>
<a name="ln8159">	} else {</a>
<a name="ln8160">		int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln8161">		for (int32 index = count - 1; index &gt;= 0; index--) {</a>
<a name="ln8162">			BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln8163">			if (pose-&gt;PointInPose(this, point)) {</a>
<a name="ln8164">				if (poseIndex)</a>
<a name="ln8165">					*poseIndex = index;</a>
<a name="ln8166"> </a>
<a name="ln8167">				return pose;</a>
<a name="ln8168">			}</a>
<a name="ln8169">		}</a>
<a name="ln8170">	}</a>
<a name="ln8171"> </a>
<a name="ln8172">	return NULL;</a>
<a name="ln8173">}</a>
<a name="ln8174"> </a>
<a name="ln8175"> </a>
<a name="ln8176">BPose*</a>
<a name="ln8177">BPoseView::FirstVisiblePose(int32* _index) const</a>
<a name="ln8178">{</a>
<a name="ln8179">	ASSERT(ViewMode() == kListMode);</a>
<a name="ln8180">	return FindPose(BPoint(kListOffset,</a>
<a name="ln8181">		Bounds().top + fListElemHeight - 1), _index);</a>
<a name="ln8182">}</a>
<a name="ln8183"> </a>
<a name="ln8184"> </a>
<a name="ln8185">BPose*</a>
<a name="ln8186">BPoseView::LastVisiblePose(int32* _index) const</a>
<a name="ln8187">{</a>
<a name="ln8188">	ASSERT(ViewMode() == kListMode);</a>
<a name="ln8189">	BPose* pose = FindPose(BPoint(kListOffset, Bounds().top + Frame().Height()</a>
<a name="ln8190">		- fListElemHeight + 2), _index);</a>
<a name="ln8191">	if (pose == NULL) {</a>
<a name="ln8192">		// Just get the last one</a>
<a name="ln8193">		pose = CurrentPoseList()-&gt;LastItem();</a>
<a name="ln8194">		if (_index != NULL)</a>
<a name="ln8195">			*_index = CurrentPoseList()-&gt;CountItems() - 1;</a>
<a name="ln8196">	}</a>
<a name="ln8197">	return pose;</a>
<a name="ln8198">}</a>
<a name="ln8199"> </a>
<a name="ln8200"> </a>
<a name="ln8201">void</a>
<a name="ln8202">BPoseView::OpenSelection(BPose* clickedPose, int32* index)</a>
<a name="ln8203">{</a>
<a name="ln8204">	BPose* singleWindowBrowsePose = clickedPose;</a>
<a name="ln8205">	TrackerSettings settings;</a>
<a name="ln8206"> </a>
<a name="ln8207">	// get first selected pose in selection if none was clicked</a>
<a name="ln8208">	if (settings.SingleWindowBrowse()</a>
<a name="ln8209">		&amp;&amp; !singleWindowBrowsePose</a>
<a name="ln8210">		&amp;&amp; fSelectionList-&gt;CountItems() == 1</a>
<a name="ln8211">		&amp;&amp; !IsFilePanel()) {</a>
<a name="ln8212">		singleWindowBrowsePose = fSelectionList-&gt;ItemAt(0);</a>
<a name="ln8213">	}</a>
<a name="ln8214"> </a>
<a name="ln8215">	// check if we can use the single window mode</a>
<a name="ln8216">	if (settings.SingleWindowBrowse()</a>
<a name="ln8217">		&amp;&amp; !IsDesktopWindow()</a>
<a name="ln8218">		&amp;&amp; !IsFilePanel()</a>
<a name="ln8219">		&amp;&amp; (modifiers() &amp; B_OPTION_KEY) == 0</a>
<a name="ln8220">		&amp;&amp; TargetModel()-&gt;IsDirectory()</a>
<a name="ln8221">		&amp;&amp; singleWindowBrowsePose</a>
<a name="ln8222">		&amp;&amp; singleWindowBrowsePose-&gt;ResolvedModel()</a>
<a name="ln8223">		&amp;&amp; singleWindowBrowsePose-&gt;ResolvedModel()-&gt;IsDirectory()) {</a>
<a name="ln8224">		// Switch to new directory</a>
<a name="ln8225">		BMessage msg(kSwitchDirectory);</a>
<a name="ln8226">		msg.AddRef(&quot;refs&quot;, singleWindowBrowsePose-&gt;ResolvedModel()-&gt;EntryRef());</a>
<a name="ln8227">		Window()-&gt;PostMessage(&amp;msg);</a>
<a name="ln8228">	} else {</a>
<a name="ln8229">		// otherwise use standard method</a>
<a name="ln8230">		OpenSelectionCommon(clickedPose, index, false);</a>
<a name="ln8231">	}</a>
<a name="ln8232"> </a>
<a name="ln8233">}</a>
<a name="ln8234"> </a>
<a name="ln8235"> </a>
<a name="ln8236">void</a>
<a name="ln8237">BPoseView::OpenSelectionUsing(BPose* clickedPose, int32* index)</a>
<a name="ln8238">{</a>
<a name="ln8239">	OpenSelectionCommon(clickedPose, index, true);</a>
<a name="ln8240">}</a>
<a name="ln8241"> </a>
<a name="ln8242"> </a>
<a name="ln8243">void</a>
<a name="ln8244">BPoseView::OpenSelectionCommon(BPose* clickedPose, int32* poseIndex,</a>
<a name="ln8245">	bool openWith)</a>
<a name="ln8246">{</a>
<a name="ln8247">	int32 count = fSelectionList-&gt;CountItems();</a>
<a name="ln8248">	if (count == 0)</a>
<a name="ln8249">		return;</a>
<a name="ln8250"> </a>
<a name="ln8251">	BMessage message(B_REFS_RECEIVED);</a>
<a name="ln8252"> </a>
<a name="ln8253">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln8254">		BPose* pose = fSelectionList-&gt;ItemAt(index);</a>
<a name="ln8255">		message.AddRef(&quot;refs&quot;, pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln8256"> </a>
<a name="ln8257">		// close parent window if option down and we're not the desktop</a>
<a name="ln8258">		// and we're not in single window mode</a>
<a name="ln8259">		if (dynamic_cast&lt;TTracker*&gt;(be_app) == NULL</a>
<a name="ln8260">			|| (modifiers() &amp; B_OPTION_KEY) == 0</a>
<a name="ln8261">			|| IsFilePanel()</a>
<a name="ln8262">			|| IsDesktopWindow()</a>
<a name="ln8263">			|| TrackerSettings().SingleWindowBrowse()) {</a>
<a name="ln8264">			continue;</a>
<a name="ln8265">		}</a>
<a name="ln8266"> </a>
<a name="ln8267">		ASSERT(TargetModel());</a>
<a name="ln8268">		message.AddData(&quot;nodeRefsToClose&quot;, B_RAW_TYPE, TargetModel()-&gt;NodeRef(),</a>
<a name="ln8269">			sizeof (node_ref));</a>
<a name="ln8270">	}</a>
<a name="ln8271"> </a>
<a name="ln8272">	if (openWith)</a>
<a name="ln8273">		message.AddInt32(&quot;launchUsingSelector&quot;, 0);</a>
<a name="ln8274"> </a>
<a name="ln8275">	// add a messenger to the launch message that will be used to</a>
<a name="ln8276">	// dispatch scripting calls from apps to the PoseView</a>
<a name="ln8277">	message.AddMessenger(&quot;TrackerViewToken&quot;, BMessenger(this));</a>
<a name="ln8278"> </a>
<a name="ln8279">	if (fSelectionHandler)</a>
<a name="ln8280">		fSelectionHandler-&gt;PostMessage(&amp;message);</a>
<a name="ln8281"> </a>
<a name="ln8282">	if (clickedPose) {</a>
<a name="ln8283">		ASSERT(poseIndex);</a>
<a name="ln8284">		if (ViewMode() == kListMode)</a>
<a name="ln8285">			DrawOpenAnimation(CalcPoseRectList(clickedPose, *poseIndex, true));</a>
<a name="ln8286">		else</a>
<a name="ln8287">			DrawOpenAnimation(clickedPose-&gt;CalcRect(this));</a>
<a name="ln8288">	}</a>
<a name="ln8289">}</a>
<a name="ln8290"> </a>
<a name="ln8291"> </a>
<a name="ln8292">void</a>
<a name="ln8293">BPoseView::DrawOpenAnimation(BRect rect)</a>
<a name="ln8294">{</a>
<a name="ln8295">	SetDrawingMode(B_OP_INVERT);</a>
<a name="ln8296"> </a>
<a name="ln8297">	BRect box1(rect);</a>
<a name="ln8298">	box1.InsetBy(rect.Width() / 2 - 2, rect.Height() / 2 - 2);</a>
<a name="ln8299">	BRect box2(box1);</a>
<a name="ln8300"> </a>
<a name="ln8301">	for (int32 index = 0; index &lt; 7; index++) {</a>
<a name="ln8302">		box2 = box1;</a>
<a name="ln8303">		box2.InsetBy(-2, -2);</a>
<a name="ln8304">		StrokeRect(box1, B_MIXED_COLORS);</a>
<a name="ln8305">		Sync();</a>
<a name="ln8306">		StrokeRect(box2, B_MIXED_COLORS);</a>
<a name="ln8307">		Sync();</a>
<a name="ln8308">		snooze(10000);</a>
<a name="ln8309">		StrokeRect(box1, B_MIXED_COLORS);</a>
<a name="ln8310">		StrokeRect(box2, B_MIXED_COLORS);</a>
<a name="ln8311">		Sync();</a>
<a name="ln8312">		box1 = box2;</a>
<a name="ln8313">	}</a>
<a name="ln8314"> </a>
<a name="ln8315">	SetDrawingMode(B_OP_OVER);</a>
<a name="ln8316">}</a>
<a name="ln8317"> </a>
<a name="ln8318"> </a>
<a name="ln8319">void</a>
<a name="ln8320">BPoseView::UnmountSelectedVolumes()</a>
<a name="ln8321">{</a>
<a name="ln8322">	BVolume boot;</a>
<a name="ln8323">	BVolumeRoster().GetBootVolume(&amp;boot);</a>
<a name="ln8324"> </a>
<a name="ln8325">	int32 select_count = fSelectionList-&gt;CountItems();</a>
<a name="ln8326">	for (int32 index = 0; index &lt; select_count; index++) {</a>
<a name="ln8327">		BPose* pose = fSelectionList-&gt;ItemAt(index);</a>
<a name="ln8328">		if (pose == NULL)</a>
<a name="ln8329">			continue;</a>
<a name="ln8330"> </a>
<a name="ln8331">		Model* model = pose-&gt;TargetModel();</a>
<a name="ln8332">		if (model-&gt;IsVolume()) {</a>
<a name="ln8333">			BVolume volume(model-&gt;NodeRef()-&gt;device);</a>
<a name="ln8334">			if (volume != boot) {</a>
<a name="ln8335">				TTracker* tracker = dynamic_cast&lt;TTracker*&gt;(be_app);</a>
<a name="ln8336">				if (tracker != NULL)</a>
<a name="ln8337">					tracker-&gt;SaveAllPoseLocations();</a>
<a name="ln8338"> </a>
<a name="ln8339">				BMessage message(kUnmountVolume);</a>
<a name="ln8340">				message.AddInt32(&quot;device_id&quot;, volume.Device());</a>
<a name="ln8341">				be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln8342">			}</a>
<a name="ln8343">		}</a>
<a name="ln8344">	}</a>
<a name="ln8345">}</a>
<a name="ln8346"> </a>
<a name="ln8347"> </a>
<a name="ln8348">void</a>
<a name="ln8349">BPoseView::ClearPoses()</a>
<a name="ln8350">{</a>
<a name="ln8351">	CommitActivePose();</a>
<a name="ln8352">	SavePoseLocations();</a>
<a name="ln8353">	ClearFilter();</a>
<a name="ln8354"> </a>
<a name="ln8355">	// clear all pose lists</a>
<a name="ln8356">	fPoseList-&gt;MakeEmpty();</a>
<a name="ln8357">	fMimeTypeListIsDirty = true;</a>
<a name="ln8358">	fVSPoseList-&gt;MakeEmpty();</a>
<a name="ln8359">	fZombieList-&gt;MakeEmpty();</a>
<a name="ln8360">	fSelectionList-&gt;MakeEmpty();</a>
<a name="ln8361">	fSelectionPivotPose = NULL;</a>
<a name="ln8362">	fRealPivotPose = NULL;</a>
<a name="ln8363">	fMimeTypesInSelectionCache.MakeEmpty();</a>
<a name="ln8364">	fBrokenLinks-&gt;MakeEmpty();</a>
<a name="ln8365"> </a>
<a name="ln8366">	DisableScrollBars();</a>
<a name="ln8367">	ScrollTo(BPoint(0, 0));</a>
<a name="ln8368">	UpdateScrollRange();</a>
<a name="ln8369">	SetScrollBarsTo(BPoint(0, 0));</a>
<a name="ln8370">	EnableScrollBars();</a>
<a name="ln8371">	ResetPosePlacementHint();</a>
<a name="ln8372">	ClearExtent();</a>
<a name="ln8373"> </a>
<a name="ln8374">	if (fSelectionChangedHook)</a>
<a name="ln8375">		ContainerWindow()-&gt;SelectionChanged();</a>
<a name="ln8376">}</a>
<a name="ln8377"> </a>
<a name="ln8378"> </a>
<a name="ln8379">void</a>
<a name="ln8380">BPoseView::SwitchDir(const entry_ref* newDirRef, AttributeStreamNode* node)</a>
<a name="ln8381">{</a>
<a name="ln8382">	ASSERT(TargetModel());</a>
<a name="ln8383">	if (*newDirRef == *TargetModel()-&gt;EntryRef())</a>
<a name="ln8384">		// no change</a>
<a name="ln8385">		return;</a>
<a name="ln8386"> </a>
<a name="ln8387">	Model* model = new Model(newDirRef, true);</a>
<a name="ln8388">	if (model-&gt;InitCheck() != B_OK || !model-&gt;IsDirectory()) {</a>
<a name="ln8389">		delete model;</a>
<a name="ln8390">		return;</a>
<a name="ln8391">	}</a>
<a name="ln8392"> </a>
<a name="ln8393">	CommitActivePose();</a>
<a name="ln8394"> </a>
<a name="ln8395">	// before clearing and adding new poses, we reset &quot;blessed&quot; async</a>
<a name="ln8396">	// thread id to prevent old add_poses thread from adding any more icons</a>
<a name="ln8397">	// the new add_poses thread will then set fAddPosesThread to its ID and it</a>
<a name="ln8398">	// will be allowed to add icons</a>
<a name="ln8399">	fAddPosesThreads.clear();</a>
<a name="ln8400">	fInsertedNodes.clear();</a>
<a name="ln8401"> </a>
<a name="ln8402">	delete fModel;</a>
<a name="ln8403">	fModel = model;</a>
<a name="ln8404"> </a>
<a name="ln8405">	// check if model is a trash dir, if so</a>
<a name="ln8406">	// update ContainerWindow's fIsTrash, etc.</a>
<a name="ln8407">	// variables to indicate new state</a>
<a name="ln8408">	ContainerWindow()-&gt;UpdateIfTrash(model);</a>
<a name="ln8409"> </a>
<a name="ln8410">	StopWatching();</a>
<a name="ln8411">	ClearPoses();</a>
<a name="ln8412"> </a>
<a name="ln8413">	// Restore state, might fail if the state has never been saved for this node</a>
<a name="ln8414">	uint32 oldMode = ViewMode();</a>
<a name="ln8415">	bool viewStateRestored = false;</a>
<a name="ln8416">	if (node != NULL) {</a>
<a name="ln8417">		BViewState* previousState = fViewState;</a>
<a name="ln8418">		RestoreState(node);</a>
<a name="ln8419">		viewStateRestored = (fViewState != previousState);</a>
<a name="ln8420">	}</a>
<a name="ln8421"> </a>
<a name="ln8422">	// Make sure fTitleView is rebuilt, as fColumnList might have changed</a>
<a name="ln8423">	fTitleView-&gt;Reset();</a>
<a name="ln8424"> </a>
<a name="ln8425">	if (viewStateRestored) {</a>
<a name="ln8426">		if (ViewMode() == kListMode &amp;&amp; oldMode != kListMode) {</a>
<a name="ln8427">			if (ContainerWindow())</a>
<a name="ln8428">				ContainerWindow()-&gt;ShowAttributeMenu();</a>
<a name="ln8429"> </a>
<a name="ln8430">			fTitleView-&gt;Show();</a>
<a name="ln8431">		} else if (ViewMode() != kListMode &amp;&amp; oldMode == kListMode) {</a>
<a name="ln8432">			fTitleView-&gt;Hide();</a>
<a name="ln8433"> </a>
<a name="ln8434">			if (ContainerWindow())</a>
<a name="ln8435">				ContainerWindow()-&gt;HideAttributeMenu();</a>
<a name="ln8436">		} else if (ViewMode() == kListMode &amp;&amp; oldMode == kListMode)</a>
<a name="ln8437">			fTitleView-&gt;Invalidate();</a>
<a name="ln8438"> </a>
<a name="ln8439">		BPoint origin;</a>
<a name="ln8440">		if (ViewMode() == kListMode)</a>
<a name="ln8441">			origin = fViewState-&gt;ListOrigin();</a>
<a name="ln8442">		else</a>
<a name="ln8443">			origin = fViewState-&gt;IconOrigin();</a>
<a name="ln8444"> </a>
<a name="ln8445">		PinPointToValidRange(origin);</a>
<a name="ln8446"> </a>
<a name="ln8447">		SetIconPoseHeight();</a>
<a name="ln8448">		GetLayoutInfo(ViewMode(), &amp;fGrid, &amp;fOffset);</a>
<a name="ln8449">		ResetPosePlacementHint();</a>
<a name="ln8450"> </a>
<a name="ln8451">		DisableScrollBars();</a>
<a name="ln8452">		ScrollTo(origin);</a>
<a name="ln8453">		UpdateScrollRange();</a>
<a name="ln8454">		SetScrollBarsTo(origin);</a>
<a name="ln8455">		EnableScrollBars();</a>
<a name="ln8456">	} else {</a>
<a name="ln8457">		ResetOrigin();</a>
<a name="ln8458">		ResetPosePlacementHint();</a>
<a name="ln8459">	}</a>
<a name="ln8460"> </a>
<a name="ln8461">	StartWatching();</a>
<a name="ln8462"> </a>
<a name="ln8463">	// be sure this happens after origin is set and window is sized</a>
<a name="ln8464">	// properly for proper icon caching!</a>
<a name="ln8465"> </a>
<a name="ln8466">	if (ContainerWindow()-&gt;IsTrash())</a>
<a name="ln8467">		AddTrashPoses();</a>
<a name="ln8468">	else</a>
<a name="ln8469">		AddPoses(TargetModel());</a>
<a name="ln8470">	TargetModel()-&gt;CloseNode();</a>
<a name="ln8471"> </a>
<a name="ln8472">	Invalidate();</a>
<a name="ln8473"> </a>
<a name="ln8474">	fLastKeyTime = 0;</a>
<a name="ln8475">}</a>
<a name="ln8476"> </a>
<a name="ln8477"> </a>
<a name="ln8478">void</a>
<a name="ln8479">BPoseView::Refresh()</a>
<a name="ln8480">{</a>
<a name="ln8481">	BEntry entry;</a>
<a name="ln8482"> </a>
<a name="ln8483">	ASSERT(TargetModel());</a>
<a name="ln8484">	if (TargetModel()-&gt;OpenNode() != B_OK)</a>
<a name="ln8485">		return;</a>
<a name="ln8486"> </a>
<a name="ln8487">	StopWatching();</a>
<a name="ln8488">	fInsertedNodes.clear();</a>
<a name="ln8489">	ClearPoses();</a>
<a name="ln8490">	StartWatching();</a>
<a name="ln8491"> </a>
<a name="ln8492">	// be sure this happens after origin is set and window is sized</a>
<a name="ln8493">	// properly for proper icon caching!</a>
<a name="ln8494">	AddPoses(TargetModel());</a>
<a name="ln8495">	TargetModel()-&gt;CloseNode();</a>
<a name="ln8496"> </a>
<a name="ln8497">	if (fRefFilter != NULL) {</a>
<a name="ln8498">		fFiltering = false;</a>
<a name="ln8499">		StartFiltering();</a>
<a name="ln8500">	}</a>
<a name="ln8501"> </a>
<a name="ln8502">	Invalidate();</a>
<a name="ln8503">	ResetOrigin();</a>
<a name="ln8504">	ResetPosePlacementHint();</a>
<a name="ln8505">}</a>
<a name="ln8506"> </a>
<a name="ln8507"> </a>
<a name="ln8508">void</a>
<a name="ln8509">BPoseView::ResetOrigin()</a>
<a name="ln8510">{</a>
<a name="ln8511">	DisableScrollBars();</a>
<a name="ln8512">	ScrollTo(B_ORIGIN);</a>
<a name="ln8513">	UpdateScrollRange();</a>
<a name="ln8514">	SetScrollBarsTo(B_ORIGIN);</a>
<a name="ln8515">	EnableScrollBars();</a>
<a name="ln8516">}</a>
<a name="ln8517"> </a>
<a name="ln8518"> </a>
<a name="ln8519">void</a>
<a name="ln8520">BPoseView::EditQueries()</a>
<a name="ln8521">{</a>
<a name="ln8522">	// edit selected queries</a>
<a name="ln8523">	SendSelectionAsRefs(kEditQuery, true);</a>
<a name="ln8524">}</a>
<a name="ln8525"> </a>
<a name="ln8526"> </a>
<a name="ln8527">void</a>
<a name="ln8528">BPoseView::SendSelectionAsRefs(uint32 what, bool onlyQueries)</a>
<a name="ln8529">{</a>
<a name="ln8530">	// fix this by having a proper selection iterator</a>
<a name="ln8531"> </a>
<a name="ln8532">	int32 numItems = fSelectionList-&gt;CountItems();</a>
<a name="ln8533">	if (!numItems)</a>
<a name="ln8534">		return;</a>
<a name="ln8535"> </a>
<a name="ln8536">	bool haveRef = false;</a>
<a name="ln8537">	BMessage message;</a>
<a name="ln8538">	message.what = what;</a>
<a name="ln8539"> </a>
<a name="ln8540">	for (int32 index = 0; index &lt; numItems; index++) {</a>
<a name="ln8541">		BPose* pose = fSelectionList-&gt;ItemAt(index);</a>
<a name="ln8542">		if (onlyQueries) {</a>
<a name="ln8543">			// to check if pose is a query, follow any symlink first</a>
<a name="ln8544">			BEntry resolvedEntry(pose-&gt;TargetModel()-&gt;EntryRef(), true);</a>
<a name="ln8545">			if (resolvedEntry.InitCheck() != B_OK)</a>
<a name="ln8546">				continue;</a>
<a name="ln8547"> </a>
<a name="ln8548">			Model model(&amp;resolvedEntry);</a>
<a name="ln8549">			if (!model.IsQuery() &amp;&amp; !model.IsQueryTemplate())</a>
<a name="ln8550">				continue;</a>
<a name="ln8551">		}</a>
<a name="ln8552">		haveRef = true;</a>
<a name="ln8553">		message.AddRef(&quot;refs&quot;, pose-&gt;TargetModel()-&gt;EntryRef());</a>
<a name="ln8554">	}</a>
<a name="ln8555">	if (!haveRef)</a>
<a name="ln8556">		return;</a>
<a name="ln8557"> </a>
<a name="ln8558">	if (onlyQueries)</a>
<a name="ln8559">		// this is used to make query templates come up in a special edit window</a>
<a name="ln8560">		message.AddBool(&quot;editQueryOnPose&quot;, onlyQueries);</a>
<a name="ln8561"> </a>
<a name="ln8562">	BMessenger(kTrackerSignature).SendMessage(&amp;message);</a>
<a name="ln8563">}</a>
<a name="ln8564"> </a>
<a name="ln8565"> </a>
<a name="ln8566">void</a>
<a name="ln8567">BPoseView::OpenInfoWindows()</a>
<a name="ln8568">{</a>
<a name="ln8569">	BMessenger tracker(kTrackerSignature);</a>
<a name="ln8570">	if (!tracker.IsValid()) {</a>
<a name="ln8571">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln8572">			B_TRANSLATE(&quot;The Tracker must be running to see Info windows.&quot;),</a>
<a name="ln8573">			B_TRANSLATE(&quot;Cancel&quot;), NULL, NULL, B_WIDTH_AS_USUAL,</a>
<a name="ln8574">			B_WARNING_ALERT);</a>
<a name="ln8575">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln8576">		alert-&gt;Go();</a>
<a name="ln8577">		return;</a>
<a name="ln8578"> 	}</a>
<a name="ln8579">	SendSelectionAsRefs(kGetInfo);</a>
<a name="ln8580">}</a>
<a name="ln8581"> </a>
<a name="ln8582"> </a>
<a name="ln8583">void</a>
<a name="ln8584">BPoseView::SetDefaultPrinter()</a>
<a name="ln8585">{</a>
<a name="ln8586">	BMessenger trackerMessenger(kTrackerSignature);</a>
<a name="ln8587">	if (!trackerMessenger.IsValid()) {</a>
<a name="ln8588">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln8589">			B_TRANSLATE(&quot;The Tracker must be running to see set the default &quot;</a>
<a name="ln8590">			&quot;printer.&quot;), B_TRANSLATE(&quot;Cancel&quot;), NULL, NULL, B_WIDTH_AS_USUAL,</a>
<a name="ln8591">			B_WARNING_ALERT);</a>
<a name="ln8592">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln8593">		alert-&gt;Go();</a>
<a name="ln8594">		return;</a>
<a name="ln8595"> 	}</a>
<a name="ln8596">	SendSelectionAsRefs(kMakeActivePrinter);</a>
<a name="ln8597">}</a>
<a name="ln8598"> </a>
<a name="ln8599"> </a>
<a name="ln8600">void</a>
<a name="ln8601">BPoseView::OpenParent()</a>
<a name="ln8602">{</a>
<a name="ln8603">	if (!TargetModel() || TargetModel()-&gt;IsRoot() || IsDesktopWindow())</a>
<a name="ln8604">		return;</a>
<a name="ln8605"> </a>
<a name="ln8606">	BEntry entry(TargetModel()-&gt;EntryRef());</a>
<a name="ln8607">	entry_ref ref;</a>
<a name="ln8608"> </a>
<a name="ln8609">	if (FSGetParentVirtualDirectoryAware(entry, entry) != B_OK</a>
<a name="ln8610">		|| entry.GetRef(&amp;ref) != B_OK)</a>
<a name="ln8611">		return;</a>
<a name="ln8612"> </a>
<a name="ln8613">	BEntry root(&quot;/&quot;);</a>
<a name="ln8614">	if (!TrackerSettings().SingleWindowBrowse()</a>
<a name="ln8615">		&amp;&amp; !TrackerSettings().ShowNavigator()</a>
<a name="ln8616">		&amp;&amp; !TrackerSettings().ShowDisksIcon() &amp;&amp; entry == root</a>
<a name="ln8617">		&amp;&amp; (modifiers() &amp; B_CONTROL_KEY) == 0)</a>
<a name="ln8618">		return;</a>
<a name="ln8619"> </a>
<a name="ln8620">	Model parentModel(&amp;ref);</a>
<a name="ln8621"> </a>
<a name="ln8622">	BMessage message(B_REFS_RECEIVED);</a>
<a name="ln8623">	message.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln8624"> </a>
<a name="ln8625">	if (dynamic_cast&lt;TTracker*&gt;(be_app)) {</a>
<a name="ln8626">		// add information about the child, so that we can select it</a>
<a name="ln8627">		// in the parent view</a>
<a name="ln8628">		message.AddData(&quot;nodeRefToSelect&quot;, B_RAW_TYPE, TargetModel()-&gt;NodeRef(),</a>
<a name="ln8629">			sizeof (node_ref));</a>
<a name="ln8630"> </a>
<a name="ln8631">		if ((modifiers() &amp; B_OPTION_KEY) != 0 &amp;&amp; !IsFilePanel()) {</a>
<a name="ln8632">			// if option down, add instructions to close the parent</a>
<a name="ln8633">			message.AddData(&quot;nodeRefsToClose&quot;, B_RAW_TYPE,</a>
<a name="ln8634">				TargetModel()-&gt;NodeRef(), sizeof (node_ref));</a>
<a name="ln8635">		}</a>
<a name="ln8636">	}</a>
<a name="ln8637"> </a>
<a name="ln8638">	if (TrackerSettings().SingleWindowBrowse()) {</a>
<a name="ln8639">		BMessage msg(kSwitchDirectory);</a>
<a name="ln8640">		msg.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln8641">		Window()-&gt;PostMessage(&amp;msg);</a>
<a name="ln8642">	} else</a>
<a name="ln8643">		be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln8644">}</a>
<a name="ln8645"> </a>
<a name="ln8646"> </a>
<a name="ln8647">void</a>
<a name="ln8648">BPoseView::IdentifySelection(bool force)</a>
<a name="ln8649">{</a>
<a name="ln8650">	int32 count = fSelectionList-&gt;CountItems();</a>
<a name="ln8651">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln8652">		BPose* pose = fSelectionList-&gt;ItemAt(index);</a>
<a name="ln8653">		BEntry entry(pose-&gt;TargetModel()-&gt;ResolveIfLink()-&gt;EntryRef());</a>
<a name="ln8654">		if (entry.InitCheck() == B_OK) {</a>
<a name="ln8655">			BPath path;</a>
<a name="ln8656">			if (entry.GetPath(&amp;path) == B_OK)</a>
<a name="ln8657">				update_mime_info(path.Path(), true, false, force ? 2 : 1);</a>
<a name="ln8658">		}</a>
<a name="ln8659">	}</a>
<a name="ln8660">}</a>
<a name="ln8661"> </a>
<a name="ln8662"> </a>
<a name="ln8663">void</a>
<a name="ln8664">BPoseView::ClearSelection()</a>
<a name="ln8665">{</a>
<a name="ln8666">	CommitActivePose();</a>
<a name="ln8667">	fSelectionPivotPose = NULL;</a>
<a name="ln8668">	fRealPivotPose = NULL;</a>
<a name="ln8669"> </a>
<a name="ln8670">	if (fSelectionList-&gt;CountItems() &gt; 0) {</a>
<a name="ln8671">		// scan all visible poses first</a>
<a name="ln8672">		BRect bounds(Bounds());</a>
<a name="ln8673"> </a>
<a name="ln8674">		if (ViewMode() == kListMode) {</a>
<a name="ln8675">			int32 startIndex = (int32)(bounds.top / fListElemHeight);</a>
<a name="ln8676">			BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln8677"> </a>
<a name="ln8678">			PoseList* poseList = CurrentPoseList();</a>
<a name="ln8679">			int32 count = poseList-&gt;CountItems();</a>
<a name="ln8680">			for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln8681">				BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln8682">				if (pose-&gt;IsSelected()) {</a>
<a name="ln8683">					pose-&gt;Select(false);</a>
<a name="ln8684">					Invalidate(pose-&gt;CalcRect(loc, this, false));</a>
<a name="ln8685">				}</a>
<a name="ln8686"> </a>
<a name="ln8687">				loc.y += fListElemHeight;</a>
<a name="ln8688">				if (loc.y &gt; bounds.bottom)</a>
<a name="ln8689">					break;</a>
<a name="ln8690">			}</a>
<a name="ln8691">		} else {</a>
<a name="ln8692">			int32 startIndex = FirstIndexAtOrBelow(</a>
<a name="ln8693">				(int32)(bounds.top - IconPoseHeight()), true);</a>
<a name="ln8694">			int32 count = fVSPoseList-&gt;CountItems();</a>
<a name="ln8695">			for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln8696">				BPose* pose = fVSPoseList-&gt;ItemAt(index);</a>
<a name="ln8697">				if (pose != NULL) {</a>
<a name="ln8698">					if (pose-&gt;IsSelected()) {</a>
<a name="ln8699">						pose-&gt;Select(false);</a>
<a name="ln8700">						Invalidate(pose-&gt;CalcRect(this));</a>
<a name="ln8701">					}</a>
<a name="ln8702"> </a>
<a name="ln8703">					if (pose-&gt;Location(this).y &gt; bounds.bottom)</a>
<a name="ln8704">						break;</a>
<a name="ln8705">				}</a>
<a name="ln8706">			}</a>
<a name="ln8707">		}</a>
<a name="ln8708"> </a>
<a name="ln8709">		// clear selection state in all poses</a>
<a name="ln8710">		int32 count = fSelectionList-&gt;CountItems();</a>
<a name="ln8711">		for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln8712">			fSelectionList-&gt;ItemAt(index)-&gt;Select(false);</a>
<a name="ln8713"> </a>
<a name="ln8714">		fSelectionList-&gt;MakeEmpty();</a>
<a name="ln8715">	}</a>
<a name="ln8716"> </a>
<a name="ln8717">	fMimeTypesInSelectionCache.MakeEmpty();</a>
<a name="ln8718">}</a>
<a name="ln8719"> </a>
<a name="ln8720"> </a>
<a name="ln8721">void</a>
<a name="ln8722">BPoseView::ShowSelection(bool show)</a>
<a name="ln8723">{</a>
<a name="ln8724">	if (fSelectionVisible == show)</a>
<a name="ln8725">		return;</a>
<a name="ln8726"> </a>
<a name="ln8727">	fSelectionVisible = show;</a>
<a name="ln8728"> </a>
<a name="ln8729">	if (fSelectionList-&gt;CountItems() &lt;= 0)</a>
<a name="ln8730">		return;</a>
<a name="ln8731"> </a>
<a name="ln8732">	// scan all visible poses first</a>
<a name="ln8733">	BRect bounds(Bounds());</a>
<a name="ln8734"> </a>
<a name="ln8735">	if (ViewMode() == kListMode) {</a>
<a name="ln8736">		int32 startIndex = (int32)(bounds.top / fListElemHeight);</a>
<a name="ln8737">		BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln8738"> </a>
<a name="ln8739">		PoseList* poseList = CurrentPoseList();</a>
<a name="ln8740">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln8741">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln8742">			BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln8743">			if (fSelectionList-&gt;HasItem(pose))</a>
<a name="ln8744">				if (pose-&gt;IsSelected() != show</a>
<a name="ln8745">					|| fShowSelectionWhenInactive) {</a>
<a name="ln8746">					if (!fShowSelectionWhenInactive)</a>
<a name="ln8747">						pose-&gt;Select(show);</a>
<a name="ln8748"> </a>
<a name="ln8749">					pose-&gt;Draw(BRect(pose-&gt;CalcRect(loc, this, false)),</a>
<a name="ln8750">						bounds, this, false);</a>
<a name="ln8751">				}</a>
<a name="ln8752"> </a>
<a name="ln8753">			loc.y += fListElemHeight;</a>
<a name="ln8754">			if (loc.y &gt; bounds.bottom)</a>
<a name="ln8755">				break;</a>
<a name="ln8756">		}</a>
<a name="ln8757">	} else {</a>
<a name="ln8758">		int32 startIndex = FirstIndexAtOrBelow(</a>
<a name="ln8759">			(int32)(bounds.top - IconPoseHeight()), true);</a>
<a name="ln8760">		int32 count = fVSPoseList-&gt;CountItems();</a>
<a name="ln8761">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln8762">			BPose* pose = fVSPoseList-&gt;ItemAt(index);</a>
<a name="ln8763">			if (pose != NULL) {</a>
<a name="ln8764">				if (fSelectionList-&gt;HasItem(pose))</a>
<a name="ln8765">					if (pose-&gt;IsSelected() != show</a>
<a name="ln8766">						|| fShowSelectionWhenInactive) {</a>
<a name="ln8767">						if (!fShowSelectionWhenInactive)</a>
<a name="ln8768">							pose-&gt;Select(show);</a>
<a name="ln8769"> </a>
<a name="ln8770">						Invalidate(pose-&gt;CalcRect(this));</a>
<a name="ln8771">					}</a>
<a name="ln8772"> </a>
<a name="ln8773">				if (pose-&gt;Location(this).y &gt; bounds.bottom)</a>
<a name="ln8774">					break;</a>
<a name="ln8775">			}</a>
<a name="ln8776">		}</a>
<a name="ln8777">	}</a>
<a name="ln8778"> </a>
<a name="ln8779">	// now set all other poses</a>
<a name="ln8780">	int32 count = fSelectionList-&gt;CountItems();</a>
<a name="ln8781">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln8782">		BPose* pose = fSelectionList-&gt;ItemAt(index);</a>
<a name="ln8783">		if (pose-&gt;IsSelected() != show &amp;&amp; !fShowSelectionWhenInactive)</a>
<a name="ln8784">			pose-&gt;Select(show);</a>
<a name="ln8785">	}</a>
<a name="ln8786"> </a>
<a name="ln8787">	// finally update fRealPivotPose/fSelectionPivotPose</a>
<a name="ln8788">	if (!show) {</a>
<a name="ln8789">		fRealPivotPose = fSelectionPivotPose;</a>
<a name="ln8790">		fSelectionPivotPose = NULL;</a>
<a name="ln8791">	} else {</a>
<a name="ln8792">		if (fRealPivotPose)</a>
<a name="ln8793">			fSelectionPivotPose = fRealPivotPose;</a>
<a name="ln8794"> </a>
<a name="ln8795">		fRealPivotPose = NULL;</a>
<a name="ln8796">	}</a>
<a name="ln8797">}</a>
<a name="ln8798"> </a>
<a name="ln8799"> </a>
<a name="ln8800">void</a>
<a name="ln8801">BPoseView::AddRemovePoseFromSelection(BPose* pose, int32 index, bool select)</a>
<a name="ln8802">{</a>
<a name="ln8803">	// Do not allow double selection/deselection.</a>
<a name="ln8804">	if (select == pose-&gt;IsSelected())</a>
<a name="ln8805">		return;</a>
<a name="ln8806"> </a>
<a name="ln8807">	pose-&gt;Select(select);</a>
<a name="ln8808"> </a>
<a name="ln8809">	// update display</a>
<a name="ln8810">	if (ViewMode() == kListMode) {</a>
<a name="ln8811">		Invalidate(pose-&gt;CalcRect(BPoint(0, index * fListElemHeight),</a>
<a name="ln8812">			this, false));</a>
<a name="ln8813">	} else</a>
<a name="ln8814">		Invalidate(pose-&gt;CalcRect(this));</a>
<a name="ln8815"> </a>
<a name="ln8816">	if (select)</a>
<a name="ln8817">		fSelectionList-&gt;AddItem(pose);</a>
<a name="ln8818">	else {</a>
<a name="ln8819">		fSelectionList-&gt;RemoveItem(pose, false);</a>
<a name="ln8820">		if (fSelectionPivotPose == pose)</a>
<a name="ln8821">			fSelectionPivotPose = NULL;</a>
<a name="ln8822"> </a>
<a name="ln8823">		if (fRealPivotPose == pose)</a>
<a name="ln8824">			fRealPivotPose = NULL;</a>
<a name="ln8825">	}</a>
<a name="ln8826">}</a>
<a name="ln8827"> </a>
<a name="ln8828"> </a>
<a name="ln8829">void</a>
<a name="ln8830">BPoseView::RemoveFromExtent(const BRect &amp;rect)</a>
<a name="ln8831">{</a>
<a name="ln8832">	ASSERT(ViewMode() != kListMode);</a>
<a name="ln8833"> </a>
<a name="ln8834">	if (rect.left &lt;= fExtent.left || rect.right &gt;= fExtent.right</a>
<a name="ln8835">		|| rect.top &lt;= fExtent.top || rect.bottom &gt;= fExtent.bottom)</a>
<a name="ln8836">		RecalcExtent();</a>
<a name="ln8837">}</a>
<a name="ln8838"> </a>
<a name="ln8839"> </a>
<a name="ln8840">void</a>
<a name="ln8841">BPoseView::RecalcExtent()</a>
<a name="ln8842">{</a>
<a name="ln8843">	ASSERT(ViewMode() != kListMode);</a>
<a name="ln8844"> </a>
<a name="ln8845">	ClearExtent();</a>
<a name="ln8846">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln8847">	for (int32 index = 0; index &lt; count; index++)</a>
<a name="ln8848">		AddToExtent(fPoseList-&gt;ItemAt(index)-&gt;CalcRect(this));</a>
<a name="ln8849">}</a>
<a name="ln8850"> </a>
<a name="ln8851"> </a>
<a name="ln8852">BRect</a>
<a name="ln8853">BPoseView::Extent() const</a>
<a name="ln8854">{</a>
<a name="ln8855">	BRect rect;</a>
<a name="ln8856"> </a>
<a name="ln8857">	if (ViewMode() == kListMode) {</a>
<a name="ln8858">		BColumn* column = fColumnList-&gt;LastItem();</a>
<a name="ln8859">		if (column != NULL) {</a>
<a name="ln8860">			rect.left = rect.top = 0;</a>
<a name="ln8861">			rect.right = column-&gt;Offset() + column-&gt;Width()</a>
<a name="ln8862">				+ kTitleColumnRightExtraMargin - kRoomForLine / 2.0f;</a>
<a name="ln8863">			rect.bottom = fListElemHeight * CurrentPoseList()-&gt;CountItems();</a>
<a name="ln8864">		} else</a>
<a name="ln8865">			rect.Set(LeftTop().x, LeftTop().y, LeftTop().x, LeftTop().y);</a>
<a name="ln8866">	} else {</a>
<a name="ln8867">		rect = fExtent;</a>
<a name="ln8868">		rect.left -= fOffset.x;</a>
<a name="ln8869">		rect.top -= fOffset.y;</a>
<a name="ln8870">		rect.right += fOffset.x;</a>
<a name="ln8871">		rect.bottom += fOffset.y;</a>
<a name="ln8872">		if (!rect.IsValid())</a>
<a name="ln8873">			rect.Set(LeftTop().x, LeftTop().y, LeftTop().x, LeftTop().y);</a>
<a name="ln8874">	}</a>
<a name="ln8875"> </a>
<a name="ln8876">	return rect;</a>
<a name="ln8877">}</a>
<a name="ln8878"> </a>
<a name="ln8879"> </a>
<a name="ln8880">void</a>
<a name="ln8881">BPoseView::SetScrollBarsTo(BPoint point)</a>
<a name="ln8882">{</a>
<a name="ln8883">	if (fHScrollBar &amp;&amp; fVScrollBar) {</a>
<a name="ln8884">		fHScrollBar-&gt;SetValue(point.x);</a>
<a name="ln8885">		fVScrollBar-&gt;SetValue(point.y);</a>
<a name="ln8886">	} else {</a>
<a name="ln8887">		// TODO: I don't know what this was supposed to work around</a>
<a name="ln8888">		// (ie why it wasn't calling ScrollTo(point) simply). Although</a>
<a name="ln8889">		// it cannot have been tested, since it was broken before, I am</a>
<a name="ln8890">		// still leaving this, since I know there can be a subtle change in</a>
<a name="ln8891">		// behaviour (BView&lt;-&gt;BScrollBar feedback effects) when scrolling</a>
<a name="ln8892">		// both directions at once versus separately.</a>
<a name="ln8893">		BPoint origin = LeftTop();</a>
<a name="ln8894">		ScrollTo(BPoint(origin.x, point.y));</a>
<a name="ln8895">		ScrollTo(point);</a>
<a name="ln8896">	}</a>
<a name="ln8897">}</a>
<a name="ln8898"> </a>
<a name="ln8899"> </a>
<a name="ln8900">void</a>
<a name="ln8901">BPoseView::PinPointToValidRange(BPoint&amp; origin)</a>
<a name="ln8902">{</a>
<a name="ln8903">	// !NaN and valid range</a>
<a name="ln8904">	// the following checks are not broken even they look like they are</a>
<a name="ln8905">	if (!(origin.x &gt;= 0) &amp;&amp; !(origin.x &lt;= 0))</a>
<a name="ln8906">		origin.x = 0;</a>
<a name="ln8907">	else if (origin.x &lt; -40000.0 || origin.x &gt; 40000.0)</a>
<a name="ln8908">		origin.x = 0;</a>
<a name="ln8909"> </a>
<a name="ln8910">	if (!(origin.y &gt;= 0) &amp;&amp; !(origin.y &lt;= 0))</a>
<a name="ln8911">		origin.y = 0;</a>
<a name="ln8912">	else if (origin.y &lt; -40000.0 || origin.y &gt; 40000.0)</a>
<a name="ln8913">		origin.y = 0;</a>
<a name="ln8914">}</a>
<a name="ln8915"> </a>
<a name="ln8916"> </a>
<a name="ln8917">void</a>
<a name="ln8918">BPoseView::UpdateScrollRange()</a>
<a name="ln8919">{</a>
<a name="ln8920">	// TODO: some calls to UpdateScrollRange don't do the right thing because</a>
<a name="ln8921">	// Extent doesn't return the right value (too early in PoseView lifetime??)</a>
<a name="ln8922">	//</a>
<a name="ln8923">	// This happened most with file panels, when opening a parent - added</a>
<a name="ln8924">	// an extra call to UpdateScrollRange in SelectChildInParent to work</a>
<a name="ln8925">	// around this</a>
<a name="ln8926"> </a>
<a name="ln8927">	AutoLock&lt;BWindow&gt; lock(Window());</a>
<a name="ln8928">	if (!lock)</a>
<a name="ln8929">		return;</a>
<a name="ln8930"> </a>
<a name="ln8931">	BRect bounds(Bounds());</a>
<a name="ln8932"> </a>
<a name="ln8933">	BPoint origin(LeftTop());</a>
<a name="ln8934">	BRect extent(Extent());</a>
<a name="ln8935"> </a>
<a name="ln8936">	lock.Unlock();</a>
<a name="ln8937"> </a>
<a name="ln8938">	BPoint minVal(std::min(extent.left, origin.x),</a>
<a name="ln8939">		std::min(extent.top, origin.y));</a>
<a name="ln8940"> </a>
<a name="ln8941">	BPoint maxVal((extent.right - bounds.right) + origin.x,</a>
<a name="ln8942">		(extent.bottom - bounds.bottom) + origin.y);</a>
<a name="ln8943"> </a>
<a name="ln8944">	maxVal.x = std::max(maxVal.x, origin.x);</a>
<a name="ln8945">	maxVal.y = std::max(maxVal.y, origin.y);</a>
<a name="ln8946"> </a>
<a name="ln8947">	if (fHScrollBar) {</a>
<a name="ln8948">		float scrollMin;</a>
<a name="ln8949">		float scrollMax;</a>
<a name="ln8950">		fHScrollBar-&gt;GetRange(&amp;scrollMin, &amp;scrollMax);</a>
<a name="ln8951">		if (minVal.x != scrollMin || maxVal.x != scrollMax) {</a>
<a name="ln8952">			fHScrollBar-&gt;SetRange(minVal.x, maxVal.x);</a>
<a name="ln8953">			fHScrollBar-&gt;SetSteps(kSmallStep, bounds.Width());</a>
<a name="ln8954">		}</a>
<a name="ln8955">	}</a>
<a name="ln8956"> </a>
<a name="ln8957">	if (fVScrollBar) {</a>
<a name="ln8958">		float scrollMin;</a>
<a name="ln8959">		float scrollMax;</a>
<a name="ln8960">		fVScrollBar-&gt;GetRange(&amp;scrollMin, &amp;scrollMax);</a>
<a name="ln8961"> </a>
<a name="ln8962">		if (minVal.y != scrollMin || maxVal.y != scrollMax) {</a>
<a name="ln8963">			fVScrollBar-&gt;SetRange(minVal.y, maxVal.y);</a>
<a name="ln8964">			fVScrollBar-&gt;SetSteps(kSmallStep, bounds.Height());</a>
<a name="ln8965">		}</a>
<a name="ln8966">	}</a>
<a name="ln8967"> </a>
<a name="ln8968">	// set proportions for bars</a>
<a name="ln8969">	BRect totalExtent(extent | bounds);</a>
<a name="ln8970"> </a>
<a name="ln8971">	if (fHScrollBar &amp;&amp; totalExtent.Width() != 0.0) {</a>
<a name="ln8972">		float proportion = bounds.Width() / totalExtent.Width();</a>
<a name="ln8973">		if (fHScrollBar-&gt;Proportion() != proportion)</a>
<a name="ln8974">			fHScrollBar-&gt;SetProportion(proportion);</a>
<a name="ln8975">	}</a>
<a name="ln8976"> </a>
<a name="ln8977">	if (fVScrollBar &amp;&amp; totalExtent.Height() != 0.0) {</a>
<a name="ln8978">		float proportion = bounds.Height() / totalExtent.Height();</a>
<a name="ln8979">		if (fVScrollBar-&gt;Proportion() != proportion)</a>
<a name="ln8980">			fVScrollBar-&gt;SetProportion(proportion);</a>
<a name="ln8981">	}</a>
<a name="ln8982">}</a>
<a name="ln8983"> </a>
<a name="ln8984"> </a>
<a name="ln8985">void</a>
<a name="ln8986">BPoseView::DrawPose(BPose* pose, int32 index, bool fullDraw)</a>
<a name="ln8987">{</a>
<a name="ln8988">	BRect rect = CalcPoseRect(pose, index, fullDraw);</a>
<a name="ln8989"> </a>
<a name="ln8990">	if (TrackerSettings().ShowVolumeSpaceBar()</a>
<a name="ln8991">		&amp;&amp; pose-&gt;TargetModel()-&gt;IsVolume()) {</a>
<a name="ln8992">		Invalidate(rect);</a>
<a name="ln8993">	} else</a>
<a name="ln8994">		pose-&gt;Draw(rect, rect, this, fullDraw);</a>
<a name="ln8995">}</a>
<a name="ln8996"> </a>
<a name="ln8997"> </a>
<a name="ln8998">rgb_color</a>
<a name="ln8999">BPoseView::DeskTextColor() const</a>
<a name="ln9000">{</a>
<a name="ln9001">	rgb_color color = ViewColor();</a>
<a name="ln9002">	float thresh = color.red + (color.green * 1.25f) + (color.blue * 0.45f);</a>
<a name="ln9003"> </a>
<a name="ln9004">	if (thresh &gt;= 360) {</a>
<a name="ln9005">		color.red = 0;</a>
<a name="ln9006">		color.green = 0;</a>
<a name="ln9007">		color.blue = 0;</a>
<a name="ln9008"> 	} else {</a>
<a name="ln9009">		color.red = 255;</a>
<a name="ln9010">		color.green = 255;</a>
<a name="ln9011">		color.blue = 255;</a>
<a name="ln9012">	}</a>
<a name="ln9013"> </a>
<a name="ln9014">	return color;</a>
<a name="ln9015">}</a>
<a name="ln9016"> </a>
<a name="ln9017"> </a>
<a name="ln9018">rgb_color</a>
<a name="ln9019">BPoseView::DeskTextBackColor() const</a>
<a name="ln9020">{</a>
<a name="ln9021">	// returns black or white color depending on the desktop background</a>
<a name="ln9022">	int32 thresh = 0;</a>
<a name="ln9023">	rgb_color color = LowColor();</a>
<a name="ln9024"> </a>
<a name="ln9025">	if (color.red &gt; 150)</a>
<a name="ln9026">		thresh++;</a>
<a name="ln9027"> </a>
<a name="ln9028">	if (color.green &gt; 150)</a>
<a name="ln9029">		thresh++;</a>
<a name="ln9030"> </a>
<a name="ln9031">	if (color.blue &gt; 150)</a>
<a name="ln9032">		thresh++;</a>
<a name="ln9033"> </a>
<a name="ln9034">	if (thresh &gt; 1) {</a>
<a name="ln9035">		color.red = 255;</a>
<a name="ln9036">		color.green = 255;</a>
<a name="ln9037">		color.blue = 255;</a>
<a name="ln9038"> 	} else {</a>
<a name="ln9039">		color.red = 0;</a>
<a name="ln9040">		color.green = 0;</a>
<a name="ln9041">		color.blue = 0;</a>
<a name="ln9042">	}</a>
<a name="ln9043"> </a>
<a name="ln9044">	return color;</a>
<a name="ln9045">}</a>
<a name="ln9046"> </a>
<a name="ln9047"> </a>
<a name="ln9048">void</a>
<a name="ln9049">BPoseView::Draw(BRect updateRect)</a>
<a name="ln9050">{</a>
<a name="ln9051">	if (IsDesktopWindow()) {</a>
<a name="ln9052">		BScreen screen(Window());</a>
<a name="ln9053">		rgb_color color = screen.DesktopColor();</a>
<a name="ln9054">		SetLowColor(color);</a>
<a name="ln9055">		SetViewColor(color);</a>
<a name="ln9056">	}</a>
<a name="ln9057">	DrawViewCommon(updateRect);</a>
<a name="ln9058"> </a>
<a name="ln9059">	if ((Flags() &amp; B_DRAW_ON_CHILDREN) == 0)</a>
<a name="ln9060">		DrawAfterChildren(updateRect);</a>
<a name="ln9061">}</a>
<a name="ln9062"> </a>
<a name="ln9063"> </a>
<a name="ln9064">void</a>
<a name="ln9065">BPoseView::DrawAfterChildren(BRect updateRect)</a>
<a name="ln9066">{</a>
<a name="ln9067">	if (fTransparentSelection &amp;&amp; fSelectionRectInfo.rect.IsValid()) {</a>
<a name="ln9068">		SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln9069">		rgb_color color = ui_color(B_NAVIGATION_BASE_COLOR);</a>
<a name="ln9070">		color.alpha = 128;</a>
<a name="ln9071">		SetHighColor(color);</a>
<a name="ln9072">		if (fSelectionRectInfo.rect.Width() == 0</a>
<a name="ln9073">			|| fSelectionRectInfo.rect.Height() == 0) {</a>
<a name="ln9074">			StrokeLine(fSelectionRectInfo.rect.LeftTop(),</a>
<a name="ln9075">				fSelectionRectInfo.rect.RightBottom());</a>
<a name="ln9076">		} else {</a>
<a name="ln9077">			StrokeRect(fSelectionRectInfo.rect);</a>
<a name="ln9078">			BRect interior = fSelectionRectInfo.rect;</a>
<a name="ln9079">			interior.InsetBy(1, 1);</a>
<a name="ln9080">			if (interior.IsValid()) {</a>
<a name="ln9081">				color = ui_color(B_CONTROL_HIGHLIGHT_COLOR);</a>
<a name="ln9082">				color.alpha = 90;</a>
<a name="ln9083">				SetHighColor(color);</a>
<a name="ln9084">				FillRect(interior);</a>
<a name="ln9085">			}</a>
<a name="ln9086">		}</a>
<a name="ln9087">		SetDrawingMode(B_OP_OVER);</a>
<a name="ln9088">	}</a>
<a name="ln9089">}</a>
<a name="ln9090"> </a>
<a name="ln9091"> </a>
<a name="ln9092">void</a>
<a name="ln9093">BPoseView::SynchronousUpdate(BRect updateRect, bool clip)</a>
<a name="ln9094">{</a>
<a name="ln9095">	if (clip) {</a>
<a name="ln9096">		BRegion updateRegion;</a>
<a name="ln9097">		updateRegion.Set(updateRect);</a>
<a name="ln9098">		ConstrainClippingRegion(&amp;updateRegion);</a>
<a name="ln9099">	}</a>
<a name="ln9100"> </a>
<a name="ln9101">	Invalidate(updateRect);</a>
<a name="ln9102">	Window()-&gt;UpdateIfNeeded();</a>
<a name="ln9103"> </a>
<a name="ln9104">	if (clip)</a>
<a name="ln9105">		ConstrainClippingRegion(NULL);</a>
<a name="ln9106">}</a>
<a name="ln9107"> </a>
<a name="ln9108"> </a>
<a name="ln9109">void</a>
<a name="ln9110">BPoseView::DrawViewCommon(const BRect&amp; updateRect)</a>
<a name="ln9111">{</a>
<a name="ln9112">	if (ViewMode() == kListMode) {</a>
<a name="ln9113">		PoseList* poseList = CurrentPoseList();</a>
<a name="ln9114">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln9115">		int32 startIndex</a>
<a name="ln9116">			= (int32)((updateRect.top - fListElemHeight) / fListElemHeight);</a>
<a name="ln9117"> </a>
<a name="ln9118">		if (startIndex &lt; 0)</a>
<a name="ln9119">			startIndex = 0;</a>
<a name="ln9120"> </a>
<a name="ln9121">		BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln9122"> </a>
<a name="ln9123">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln9124">			BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln9125">			BRect poseRect(pose-&gt;CalcRect(loc, this, true));</a>
<a name="ln9126">			pose-&gt;Draw(poseRect, updateRect, this, true);</a>
<a name="ln9127">			loc.y += fListElemHeight;</a>
<a name="ln9128">			if (loc.y &gt;= updateRect.bottom)</a>
<a name="ln9129">				break;</a>
<a name="ln9130">		}</a>
<a name="ln9131">	} else {</a>
<a name="ln9132">		int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln9133">		for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln9134">			BPose* pose = fPoseList-&gt;ItemAt(index);</a>
<a name="ln9135">			BRect poseRect(pose-&gt;CalcRect(this));</a>
<a name="ln9136">			if (updateRect.Intersects(poseRect))</a>
<a name="ln9137">				pose-&gt;Draw(poseRect, updateRect, this, true);</a>
<a name="ln9138">		}</a>
<a name="ln9139">	}</a>
<a name="ln9140">}</a>
<a name="ln9141"> </a>
<a name="ln9142"> </a>
<a name="ln9143">void</a>
<a name="ln9144">BPoseView::ColumnRedraw(BRect updateRect)</a>
<a name="ln9145">{</a>
<a name="ln9146">	// used for dynamic column resizing using an offscreen draw buffer</a>
<a name="ln9147">	ASSERT(ViewMode() == kListMode);</a>
<a name="ln9148"> </a>
<a name="ln9149">	if (IsDesktopWindow()) {</a>
<a name="ln9150">		BScreen	screen(Window());</a>
<a name="ln9151">		rgb_color d = screen.DesktopColor();</a>
<a name="ln9152">		SetLowColor(d);</a>
<a name="ln9153">		SetViewColor(d);</a>
<a name="ln9154">	}</a>
<a name="ln9155"> </a>
<a name="ln9156">	int32 startIndex</a>
<a name="ln9157">		= (int32)((updateRect.top - fListElemHeight) / fListElemHeight);</a>
<a name="ln9158">	if (startIndex &lt; 0)</a>
<a name="ln9159">		startIndex = 0;</a>
<a name="ln9160"> </a>
<a name="ln9161">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln9162">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln9163">	if (!count)</a>
<a name="ln9164">		return;</a>
<a name="ln9165"> </a>
<a name="ln9166">	BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln9167">	BRect srcRect = poseList-&gt;ItemAt(0)-&gt;CalcRect(BPoint(0, 0), this, false);</a>
<a name="ln9168">	srcRect.right += 1024;	// need this to erase correctly</a>
<a name="ln9169">	sOffscreen-&gt;BeginUsing(srcRect);</a>
<a name="ln9170">	BView* offscreenView = sOffscreen-&gt;View();</a>
<a name="ln9171"> </a>
<a name="ln9172">	BRegion updateRegion;</a>
<a name="ln9173">	updateRegion.Set(updateRect);</a>
<a name="ln9174">	ConstrainClippingRegion(&amp;updateRegion);</a>
<a name="ln9175"> </a>
<a name="ln9176">	for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln9177">		BPose* pose = poseList-&gt;ItemAt(index);</a>
<a name="ln9178"> </a>
<a name="ln9179">		offscreenView-&gt;SetDrawingMode(B_OP_COPY);</a>
<a name="ln9180">		offscreenView-&gt;SetLowColor(LowColor());</a>
<a name="ln9181">		offscreenView-&gt;FillRect(offscreenView-&gt;Bounds(), B_SOLID_LOW);</a>
<a name="ln9182"> </a>
<a name="ln9183">		BRect dstRect = srcRect;</a>
<a name="ln9184">		dstRect.OffsetTo(loc);</a>
<a name="ln9185"> </a>
<a name="ln9186">		BPoint offsetBy(0, -(index * ListElemHeight()));</a>
<a name="ln9187">		pose-&gt;Draw(dstRect, updateRect, this, offscreenView, true,</a>
<a name="ln9188">			offsetBy, pose-&gt;IsSelected());</a>
<a name="ln9189"> </a>
<a name="ln9190">		offscreenView-&gt;Sync();</a>
<a name="ln9191">		SetDrawingMode(B_OP_COPY);</a>
<a name="ln9192">		DrawBitmap(sOffscreen-&gt;Bitmap(), srcRect, dstRect);</a>
<a name="ln9193">		loc.y += fListElemHeight;</a>
<a name="ln9194">		if (loc.y &gt; updateRect.bottom)</a>
<a name="ln9195">			break;</a>
<a name="ln9196">	}</a>
<a name="ln9197">	sOffscreen-&gt;DoneUsing();</a>
<a name="ln9198">	ConstrainClippingRegion(0);</a>
<a name="ln9199">}</a>
<a name="ln9200"> </a>
<a name="ln9201"> </a>
<a name="ln9202">void</a>
<a name="ln9203">BPoseView::CloseGapInList(BRect* invalidRect)</a>
<a name="ln9204">{</a>
<a name="ln9205">	(*invalidRect).bottom = Extent().bottom + fListElemHeight;</a>
<a name="ln9206">	BRect bounds(Bounds());</a>
<a name="ln9207"> </a>
<a name="ln9208">	if (bounds.Intersects(*invalidRect)) {</a>
<a name="ln9209">		BRect destRect(*invalidRect);</a>
<a name="ln9210">		destRect = destRect &amp; bounds;</a>
<a name="ln9211">		destRect.bottom -= fListElemHeight;</a>
<a name="ln9212"> </a>
<a name="ln9213">		BRect srcRect(destRect);</a>
<a name="ln9214">		srcRect.OffsetBy(0, fListElemHeight);</a>
<a name="ln9215"> </a>
<a name="ln9216">		if (srcRect.Intersects(bounds) || destRect.Intersects(bounds))</a>
<a name="ln9217">			CopyBits(srcRect, destRect);</a>
<a name="ln9218"> </a>
<a name="ln9219">		*invalidRect = srcRect;</a>
<a name="ln9220">		(*invalidRect).top = destRect.bottom;</a>
<a name="ln9221">	}</a>
<a name="ln9222">}</a>
<a name="ln9223"> </a>
<a name="ln9224"> </a>
<a name="ln9225">void</a>
<a name="ln9226">BPoseView::CheckPoseSortOrder(BPose* pose, int32 oldIndex)</a>
<a name="ln9227">{</a>
<a name="ln9228">	_CheckPoseSortOrder(CurrentPoseList(), pose, oldIndex);</a>
<a name="ln9229">}</a>
<a name="ln9230"> </a>
<a name="ln9231"> </a>
<a name="ln9232">void</a>
<a name="ln9233">BPoseView::_CheckPoseSortOrder(PoseList* poseList, BPose* pose, int32 oldIndex)</a>
<a name="ln9234">{</a>
<a name="ln9235">	if (ViewMode() != kListMode)</a>
<a name="ln9236">		return;</a>
<a name="ln9237"> </a>
<a name="ln9238">	Window()-&gt;UpdateIfNeeded();</a>
<a name="ln9239"> </a>
<a name="ln9240">	// take pose out of list for BSearch</a>
<a name="ln9241">	poseList-&gt;RemoveItemAt(oldIndex);</a>
<a name="ln9242">	int32 afterIndex;</a>
<a name="ln9243">	int32 orientation = BSearchList(poseList, pose, &amp;afterIndex, oldIndex);</a>
<a name="ln9244"> </a>
<a name="ln9245">	int32 newIndex;</a>
<a name="ln9246">	if (orientation == kInsertAtFront)</a>
<a name="ln9247">		newIndex = 0;</a>
<a name="ln9248">	else</a>
<a name="ln9249">		newIndex = afterIndex + 1;</a>
<a name="ln9250"> </a>
<a name="ln9251">	if (newIndex == oldIndex) {</a>
<a name="ln9252">		poseList-&gt;AddItem(pose, oldIndex);</a>
<a name="ln9253">		return;</a>
<a name="ln9254">	}</a>
<a name="ln9255"> </a>
<a name="ln9256">	if (fFiltering &amp;&amp; poseList != fFilteredPoseList) {</a>
<a name="ln9257">		poseList-&gt;AddItem(pose, newIndex);</a>
<a name="ln9258">		return;</a>
<a name="ln9259">	}</a>
<a name="ln9260"> </a>
<a name="ln9261">	BRect invalidRect(CalcPoseRectList(pose, oldIndex));</a>
<a name="ln9262">	CloseGapInList(&amp;invalidRect);</a>
<a name="ln9263">	Invalidate(invalidRect);</a>
<a name="ln9264">		// need to invalidate for the last item in the list</a>
<a name="ln9265">	InsertPoseAfter(pose, &amp;afterIndex, orientation, &amp;invalidRect);</a>
<a name="ln9266">	poseList-&gt;AddItem(pose, newIndex);</a>
<a name="ln9267">	Invalidate(invalidRect);</a>
<a name="ln9268">}</a>
<a name="ln9269"> </a>
<a name="ln9270"> </a>
<a name="ln9271">static int</a>
<a name="ln9272">PoseCompareAddWidget(const BPose* p1, const BPose* p2, BPoseView* view)</a>
<a name="ln9273">{</a>
<a name="ln9274">	// pose comparison and lazy text widget adding</a>
<a name="ln9275"> </a>
<a name="ln9276">	uint32 sort = view-&gt;PrimarySort();</a>
<a name="ln9277">	BColumn* column = view-&gt;ColumnFor(sort);</a>
<a name="ln9278">	if (column == NULL)</a>
<a name="ln9279">		return 0;</a>
<a name="ln9280"> </a>
<a name="ln9281">	BPose* primary;</a>
<a name="ln9282">	BPose* secondary;</a>
<a name="ln9283">	if (!view-&gt;ReverseSort()) {</a>
<a name="ln9284">		primary = const_cast&lt;BPose*&gt;(p1);</a>
<a name="ln9285">		secondary = const_cast&lt;BPose*&gt;(p2);</a>
<a name="ln9286">	} else {</a>
<a name="ln9287">		primary = const_cast&lt;BPose*&gt;(p2);</a>
<a name="ln9288">		secondary = const_cast&lt;BPose*&gt;(p1);</a>
<a name="ln9289">	}</a>
<a name="ln9290"> </a>
<a name="ln9291">	int32 result = 0;</a>
<a name="ln9292">	for (int32 count = 0; ; count++) {</a>
<a name="ln9293">		BTextWidget* widget1 = primary-&gt;WidgetFor(sort);</a>
<a name="ln9294">		if (widget1 == NULL)</a>
<a name="ln9295">			widget1 = primary-&gt;AddWidget(view, column);</a>
<a name="ln9296"> </a>
<a name="ln9297">		BTextWidget* widget2 = secondary-&gt;WidgetFor(sort);</a>
<a name="ln9298">		if (widget2 == NULL)</a>
<a name="ln9299">			widget2 = secondary-&gt;AddWidget(view, column);</a>
<a name="ln9300"> </a>
<a name="ln9301">		if (widget1 == NULL || widget2 == NULL)</a>
<a name="ln9302">			return result;</a>
<a name="ln9303"> </a>
<a name="ln9304">		result = widget1-&gt;Compare(*widget2, view);</a>
<a name="ln9305"> </a>
<a name="ln9306">		if (count != 0)</a>
<a name="ln9307">			return result;</a>
<a name="ln9308"> </a>
<a name="ln9309">		// do we need to sort by secondary attribute?</a>
<a name="ln9310">		if (result == 0) {</a>
<a name="ln9311">			sort = view-&gt;SecondarySort();</a>
<a name="ln9312">			if (!sort)</a>
<a name="ln9313">				return result;</a>
<a name="ln9314"> </a>
<a name="ln9315">			column = view-&gt;ColumnFor(sort);</a>
<a name="ln9316">			if (column == NULL)</a>
<a name="ln9317">				return result;</a>
<a name="ln9318">		}</a>
<a name="ln9319">	}</a>
<a name="ln9320"> </a>
<a name="ln9321">	return result;</a>
<a name="ln9322">}</a>
<a name="ln9323"> </a>
<a name="ln9324"> </a>
<a name="ln9325">static BPose*</a>
<a name="ln9326">BSearch(PoseList* table, const BPose* key, BPoseView* view,</a>
<a name="ln9327">	int (*cmp)(const BPose*, const BPose*, BPoseView*), bool returnClosest)</a>
<a name="ln9328">{</a>
<a name="ln9329">	int32 r = table-&gt;CountItems();</a>
<a name="ln9330">	BPose* result = 0;</a>
<a name="ln9331"> </a>
<a name="ln9332">	for (int32 l = 1; l &lt;= r;) {</a>
<a name="ln9333">		int32 m = (l + r) / 2;</a>
<a name="ln9334"> </a>
<a name="ln9335">		result = table-&gt;ItemAt(m - 1);</a>
<a name="ln9336">		int32 compareResult = (cmp)(result, key, view);</a>
<a name="ln9337">		if (compareResult == 0)</a>
<a name="ln9338">			return result;</a>
<a name="ln9339">		else if (compareResult &lt; 0)</a>
<a name="ln9340">			l = m + 1;</a>
<a name="ln9341">		else</a>
<a name="ln9342">			r = m - 1;</a>
<a name="ln9343">	}</a>
<a name="ln9344">	if (returnClosest)</a>
<a name="ln9345">		return result;</a>
<a name="ln9346"> </a>
<a name="ln9347">	return NULL;</a>
<a name="ln9348">}</a>
<a name="ln9349"> </a>
<a name="ln9350"> </a>
<a name="ln9351">int32</a>
<a name="ln9352">BPoseView::BSearchList(PoseList* poseList, const BPose* pose,</a>
<a name="ln9353">	int32* resultingIndex, int32 oldIndex)</a>
<a name="ln9354">{</a>
<a name="ln9355">	// check to see if insertion should be at beginning of list</a>
<a name="ln9356">	const BPose* firstPose = poseList-&gt;FirstItem();</a>
<a name="ln9357">	if (!firstPose)</a>
<a name="ln9358">		return kInsertAtFront;</a>
<a name="ln9359"> </a>
<a name="ln9360">	if (PoseCompareAddWidget(pose, firstPose, this) &lt; 0) {</a>
<a name="ln9361">		*resultingIndex = 0;</a>
<a name="ln9362">		return kInsertAtFront;</a>
<a name="ln9363">	}</a>
<a name="ln9364"> </a>
<a name="ln9365">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln9366"> </a>
<a name="ln9367">	// look if old position is still ok, by comparing to siblings</a>
<a name="ln9368">	bool valid = oldIndex &gt; 0 &amp;&amp; oldIndex &lt; count - 1;</a>
<a name="ln9369">	valid = valid &amp;&amp; PoseCompareAddWidget(pose,</a>
<a name="ln9370">		poseList-&gt;ItemAt(oldIndex - 1), this) &gt;= 0;</a>
<a name="ln9371">	// the current item is gone, so not oldIndex+1</a>
<a name="ln9372">	valid = valid &amp;&amp; PoseCompareAddWidget(pose,</a>
<a name="ln9373">		poseList-&gt;ItemAt(oldIndex), this) &lt;= 0;</a>
<a name="ln9374"> </a>
<a name="ln9375">	if (valid) {</a>
<a name="ln9376">		*resultingIndex = oldIndex - 1;</a>
<a name="ln9377">		return kInsertAfter;</a>
<a name="ln9378">	}</a>
<a name="ln9379"> </a>
<a name="ln9380">	*resultingIndex = count - 1;</a>
<a name="ln9381"> </a>
<a name="ln9382">	const BPose* searchResult = BSearch(poseList, pose, this,</a>
<a name="ln9383">		PoseCompareAddWidget);</a>
<a name="ln9384"> </a>
<a name="ln9385">	if (searchResult != NULL) {</a>
<a name="ln9386">		// what are we doing here??</a>
<a name="ln9387">		// looks like we are skipping poses with identical search results or</a>
<a name="ln9388">		// something</a>
<a name="ln9389">		int32 index = poseList-&gt;IndexOf(searchResult);</a>
<a name="ln9390">		for (; index &lt; count; index++) {</a>
<a name="ln9391">			int32 result = PoseCompareAddWidget(pose, poseList-&gt;ItemAt(index),</a>
<a name="ln9392">				this);</a>
<a name="ln9393">			if (result &lt;= 0) {</a>
<a name="ln9394">				--index;</a>
<a name="ln9395">				break;</a>
<a name="ln9396">			}</a>
<a name="ln9397">		}</a>
<a name="ln9398"> </a>
<a name="ln9399">		if (index != count)</a>
<a name="ln9400">			*resultingIndex = index;</a>
<a name="ln9401">	}</a>
<a name="ln9402"> </a>
<a name="ln9403">	return kInsertAfter;</a>
<a name="ln9404">}</a>
<a name="ln9405"> </a>
<a name="ln9406"> </a>
<a name="ln9407">void</a>
<a name="ln9408">BPoseView::SetPrimarySort(uint32 attrHash)</a>
<a name="ln9409">{</a>
<a name="ln9410">	BColumn* column = ColumnFor(attrHash);</a>
<a name="ln9411">	if (column != NULL) {</a>
<a name="ln9412">		fViewState-&gt;SetPrimarySort(attrHash);</a>
<a name="ln9413">		fViewState-&gt;SetPrimarySortType(column-&gt;AttrType());</a>
<a name="ln9414">	}</a>
<a name="ln9415">}</a>
<a name="ln9416"> </a>
<a name="ln9417"> </a>
<a name="ln9418">void</a>
<a name="ln9419">BPoseView::SetSecondarySort(uint32 attrHash)</a>
<a name="ln9420">{</a>
<a name="ln9421">	BColumn* column = ColumnFor(attrHash);</a>
<a name="ln9422">	if (column != NULL) {</a>
<a name="ln9423">		fViewState-&gt;SetSecondarySort(attrHash);</a>
<a name="ln9424">		fViewState-&gt;SetSecondarySortType(column-&gt;AttrType());</a>
<a name="ln9425">	} else {</a>
<a name="ln9426">		fViewState-&gt;SetSecondarySort(0);</a>
<a name="ln9427">		fViewState-&gt;SetSecondarySortType(0);</a>
<a name="ln9428">	}</a>
<a name="ln9429">}</a>
<a name="ln9430"> </a>
<a name="ln9431"> </a>
<a name="ln9432">void</a>
<a name="ln9433">BPoseView::SetReverseSort(bool reverse)</a>
<a name="ln9434">{</a>
<a name="ln9435">	fViewState-&gt;SetReverseSort(reverse);</a>
<a name="ln9436">}</a>
<a name="ln9437"> </a>
<a name="ln9438"> </a>
<a name="ln9439">inline int</a>
<a name="ln9440">PoseCompareAddWidgetBinder(const BPose* p1, const BPose* p2,</a>
<a name="ln9441">	void* castToPoseView)</a>
<a name="ln9442">{</a>
<a name="ln9443">	return PoseCompareAddWidget(p1, p2, (BPoseView*)castToPoseView);</a>
<a name="ln9444">}</a>
<a name="ln9445"> </a>
<a name="ln9446"> </a>
<a name="ln9447">struct PoseComparator : public std::binary_function&lt;const BPose*,</a>
<a name="ln9448">	const BPose*, bool&gt;</a>
<a name="ln9449">{</a>
<a name="ln9450">	PoseComparator(BPoseView* poseView): fPoseView(poseView) { }</a>
<a name="ln9451"> </a>
<a name="ln9452">	bool operator() (const BPose* p1, const BPose* p2)</a>
<a name="ln9453">	{</a>
<a name="ln9454">		return PoseCompareAddWidget(p1, p2, fPoseView) &lt; 0;</a>
<a name="ln9455">	}</a>
<a name="ln9456"> </a>
<a name="ln9457">	BPoseView* fPoseView;</a>
<a name="ln9458">};</a>
<a name="ln9459"> </a>
<a name="ln9460"> </a>
<a name="ln9461">#if xDEBUG</a>
<a name="ln9462">static BPose*</a>
<a name="ln9463">DumpOne(BPose* pose, void*)</a>
<a name="ln9464">{</a>
<a name="ln9465">	pose-&gt;TargetModel()-&gt;PrintToStream(0);</a>
<a name="ln9466">	return 0;</a>
<a name="ln9467">}</a>
<a name="ln9468">#endif</a>
<a name="ln9469"> </a>
<a name="ln9470"> </a>
<a name="ln9471">void</a>
<a name="ln9472">BPoseView::SortPoses()</a>
<a name="ln9473">{</a>
<a name="ln9474">	if (fTextWidgetToCheck != NULL)</a>
<a name="ln9475">		fTextWidgetToCheck-&gt;CancelWait();</a>
<a name="ln9476"> </a>
<a name="ln9477">	CommitActivePose();</a>
<a name="ln9478">	// PRINT((&quot;pose list count %d\n&quot;, fPoseList-&gt;CountItems()));</a>
<a name="ln9479">#if xDEBUG</a>
<a name="ln9480">	fPoseList-&gt;EachElement(DumpOne, 0);</a>
<a name="ln9481">	PRINT((&quot;===================\n&quot;));</a>
<a name="ln9482">#endif</a>
<a name="ln9483"> </a>
<a name="ln9484">	BPose** poses = reinterpret_cast&lt;BPose**&gt;(</a>
<a name="ln9485">		PoseList::Private(fPoseList).AsBList()-&gt;Items());</a>
<a name="ln9486">	std::stable_sort(poses, &amp;poses[fPoseList-&gt;CountItems()],</a>
<a name="ln9487">		PoseComparator(this));</a>
<a name="ln9488">	if (fFiltering) {</a>
<a name="ln9489">		poses = reinterpret_cast&lt;BPose**&gt;(</a>
<a name="ln9490">			PoseList::Private(fFilteredPoseList).AsBList()-&gt;Items());</a>
<a name="ln9491">		std::stable_sort(poses, &amp;poses[fFilteredPoseList-&gt;CountItems()],</a>
<a name="ln9492">			PoseComparator(this));</a>
<a name="ln9493">	}</a>
<a name="ln9494">}</a>
<a name="ln9495"> </a>
<a name="ln9496"> </a>
<a name="ln9497">BColumn*</a>
<a name="ln9498">BPoseView::ColumnFor(uint32 attr) const</a>
<a name="ln9499">{</a>
<a name="ln9500">	int32 count = fColumnList-&gt;CountItems();</a>
<a name="ln9501">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln9502">		BColumn* column = ColumnAt(index);</a>
<a name="ln9503">		if (column-&gt;AttrHash() == attr)</a>
<a name="ln9504">			return column;</a>
<a name="ln9505">	}</a>
<a name="ln9506"> </a>
<a name="ln9507">	return NULL;</a>
<a name="ln9508">}</a>
<a name="ln9509"> </a>
<a name="ln9510"> </a>
<a name="ln9511">bool</a>
<a name="ln9512">BPoseView::ResizeColumnToWidest(BColumn* column)</a>
<a name="ln9513">{</a>
<a name="ln9514">	ASSERT(ViewMode() == kListMode);</a>
<a name="ln9515"> </a>
<a name="ln9516">	// returns true if actually resized</a>
<a name="ln9517"> </a>
<a name="ln9518">	float maxWidth = kMinColumnWidth;</a>
<a name="ln9519"> </a>
<a name="ln9520">	PoseList* poseList = CurrentPoseList();</a>
<a name="ln9521">	int32 count = poseList-&gt;CountItems();</a>
<a name="ln9522">	for (int32 i = 0; i &lt; count; ++i) {</a>
<a name="ln9523">		BTextWidget* widget</a>
<a name="ln9524">			= poseList-&gt;ItemAt(i)-&gt;WidgetFor(column-&gt;AttrHash());</a>
<a name="ln9525">		if (widget != NULL) {</a>
<a name="ln9526">			float width = widget-&gt;PreferredWidth(this);</a>
<a name="ln9527">			if (width &gt; maxWidth)</a>
<a name="ln9528">				maxWidth = width;</a>
<a name="ln9529">		}</a>
<a name="ln9530">	}</a>
<a name="ln9531"> </a>
<a name="ln9532">	if (maxWidth &gt; kMinColumnWidth || maxWidth &lt; column-&gt;Width()) {</a>
<a name="ln9533">		ResizeColumn(column, maxWidth);</a>
<a name="ln9534">		return true;</a>
<a name="ln9535">	}</a>
<a name="ln9536"> </a>
<a name="ln9537">	return false;</a>
<a name="ln9538">}</a>
<a name="ln9539"> </a>
<a name="ln9540"> </a>
<a name="ln9541">BPoint</a>
<a name="ln9542">BPoseView::ResizeColumn(BColumn* column, float newSize,</a>
<a name="ln9543">	float* lastLineDrawPos,</a>
<a name="ln9544">	void (*drawLineFunc)(BPoseView*, BPoint, BPoint),</a>
<a name="ln9545">	void (*undrawLineFunc)(BPoseView*, BPoint, BPoint))</a>
<a name="ln9546">{</a>
<a name="ln9547">	BRect sourceRect(Bounds());</a>
<a name="ln9548">	BPoint result(sourceRect.RightBottom());</a>
<a name="ln9549"> </a>
<a name="ln9550">	BRect destRect(sourceRect);</a>
<a name="ln9551">		// we will use sourceRect and destRect for copyBits</a>
<a name="ln9552">	BRect invalidateRect(sourceRect);</a>
<a name="ln9553">		// this will serve to clean up after the invalidate</a>
<a name="ln9554">	BRect columnDrawRect(sourceRect);</a>
<a name="ln9555">		// we will use columnDrawRect to draw the actual resized column</a>
<a name="ln9556"> </a>
<a name="ln9557">	bool shrinking = newSize &lt; column-&gt;Width();</a>
<a name="ln9558">	columnDrawRect.left = column-&gt;Offset();</a>
<a name="ln9559">	columnDrawRect.right = column-&gt;Offset() + kTitleColumnRightExtraMargin</a>
<a name="ln9560">		- kRoomForLine + newSize;</a>
<a name="ln9561">	sourceRect.left = column-&gt;Offset() + kTitleColumnRightExtraMargin</a>
<a name="ln9562">		- kRoomForLine + column-&gt;Width();</a>
<a name="ln9563">	destRect.left = columnDrawRect.right;</a>
<a name="ln9564">	destRect.right = destRect.left + sourceRect.Width();</a>
<a name="ln9565">	invalidateRect.left = destRect.right;</a>
<a name="ln9566">	invalidateRect.right = sourceRect.right;</a>
<a name="ln9567"> </a>
<a name="ln9568">	column-&gt;SetWidth(newSize);</a>
<a name="ln9569"> </a>
<a name="ln9570">	float offset = StartOffset();</a>
<a name="ln9571">	int32 count = fColumnList-&gt;CountItems();</a>
<a name="ln9572">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln9573">		column = fColumnList-&gt;ItemAt(index);</a>
<a name="ln9574">		column-&gt;SetOffset(offset);</a>
<a name="ln9575">		BColumn* last = column;</a>
<a name="ln9576">		offset = last-&gt;Offset() + last-&gt;Width() + kTitleColumnExtraMargin;</a>
<a name="ln9577">	}</a>
<a name="ln9578"> </a>
<a name="ln9579">	if (shrinking) {</a>
<a name="ln9580">		ColumnRedraw(columnDrawRect);</a>
<a name="ln9581">		// dont have to undraw when shrinking</a>
<a name="ln9582">		CopyBits(sourceRect, destRect);</a>
<a name="ln9583">		if (drawLineFunc != NULL) {</a>
<a name="ln9584">			ASSERT(lastLineDrawPos != NULL);</a>
<a name="ln9585">			(drawLineFunc)(this, BPoint(destRect.left + kRoomForLine,</a>
<a name="ln9586">					destRect.top),</a>
<a name="ln9587">				BPoint(destRect.left + kRoomForLine, destRect.bottom));</a>
<a name="ln9588">			*lastLineDrawPos = destRect.left + kRoomForLine;</a>
<a name="ln9589">		}</a>
<a name="ln9590">	} else {</a>
<a name="ln9591">		CopyBits(sourceRect, destRect);</a>
<a name="ln9592">		if (undrawLineFunc != NULL) {</a>
<a name="ln9593">			ASSERT(lastLineDrawPos != NULL);</a>
<a name="ln9594">			(undrawLineFunc)(this, BPoint(*lastLineDrawPos, sourceRect.top),</a>
<a name="ln9595">				BPoint(*lastLineDrawPos, sourceRect.bottom));</a>
<a name="ln9596">		}</a>
<a name="ln9597">		if (drawLineFunc != NULL) {</a>
<a name="ln9598">			ASSERT(lastLineDrawPos);</a>
<a name="ln9599">			(drawLineFunc)(this, BPoint(destRect.left + kRoomForLine,</a>
<a name="ln9600">					destRect.top),</a>
<a name="ln9601">				BPoint(destRect.left + kRoomForLine, destRect.bottom));</a>
<a name="ln9602">			*lastLineDrawPos = destRect.left + kRoomForLine;</a>
<a name="ln9603">		}</a>
<a name="ln9604">		ColumnRedraw(columnDrawRect);</a>
<a name="ln9605">	}</a>
<a name="ln9606">	if (invalidateRect.left &lt; invalidateRect.right)</a>
<a name="ln9607">		SynchronousUpdate(invalidateRect, true);</a>
<a name="ln9608"> </a>
<a name="ln9609">	fStateNeedsSaving =  true;</a>
<a name="ln9610"> </a>
<a name="ln9611">	return result;</a>
<a name="ln9612">}</a>
<a name="ln9613"> </a>
<a name="ln9614"> </a>
<a name="ln9615">void</a>
<a name="ln9616">BPoseView::MoveColumnTo(BColumn* src, BColumn* dest)</a>
<a name="ln9617">{</a>
<a name="ln9618">	// find the leftmost boundary of columns we are about to reshuffle</a>
<a name="ln9619">	float miny = src-&gt;Offset();</a>
<a name="ln9620">	if (miny &gt; dest-&gt;Offset())</a>
<a name="ln9621">		miny = dest-&gt;Offset();</a>
<a name="ln9622"> </a>
<a name="ln9623">	// ensure columns are in proper order in list</a>
<a name="ln9624">	int32 index = fColumnList-&gt;IndexOf(dest);</a>
<a name="ln9625">	fColumnList-&gt;RemoveItem(src, false);</a>
<a name="ln9626">	fColumnList-&gt;AddItem(src, index);</a>
<a name="ln9627"> </a>
<a name="ln9628">	float offset = StartOffset();</a>
<a name="ln9629">	int32 count = fColumnList-&gt;CountItems();</a>
<a name="ln9630">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln9631">		BColumn* column = fColumnList-&gt;ItemAt(index);</a>
<a name="ln9632">		column-&gt;SetOffset(offset);</a>
<a name="ln9633">		BColumn* last = column;</a>
<a name="ln9634">		offset = last-&gt;Offset() + last-&gt;Width() + kTitleColumnExtraMargin</a>
<a name="ln9635">			- kRoomForLine / 2;</a>
<a name="ln9636">	}</a>
<a name="ln9637"> </a>
<a name="ln9638">	// invalidate everything to the right of miny</a>
<a name="ln9639">	BRect bounds(Bounds());</a>
<a name="ln9640">	bounds.left = miny;</a>
<a name="ln9641">	Invalidate(bounds);</a>
<a name="ln9642"> </a>
<a name="ln9643">	fStateNeedsSaving =  true;</a>
<a name="ln9644">}</a>
<a name="ln9645"> </a>
<a name="ln9646"> </a>
<a name="ln9647">bool</a>
<a name="ln9648">BPoseView::UpdateDropTarget(BPoint mouseLoc, const BMessage* dragMessage,</a>
<a name="ln9649">	bool trackingContextMenu)</a>
<a name="ln9650">{</a>
<a name="ln9651">	ASSERT(dragMessage != NULL);</a>
<a name="ln9652"> </a>
<a name="ln9653">	int32 index;</a>
<a name="ln9654">	BPose* targetPose = FindPose(mouseLoc, &amp;index);</a>
<a name="ln9655">	if (targetPose != NULL &amp;&amp; DragSelectionContains(targetPose, dragMessage))</a>
<a name="ln9656">		targetPose = NULL;</a>
<a name="ln9657"> </a>
<a name="ln9658">	if ((fCursorCheck &amp;&amp; targetPose == fDropTarget)</a>
<a name="ln9659">		|| (trackingContextMenu &amp;&amp; !targetPose)) {</a>
<a name="ln9660">		// no change</a>
<a name="ln9661">		return false;</a>
<a name="ln9662">	}</a>
<a name="ln9663"> </a>
<a name="ln9664">	fCursorCheck = true;</a>
<a name="ln9665">	if (fDropTarget &amp;&amp; !DragSelectionContains(fDropTarget, dragMessage))</a>
<a name="ln9666">		HiliteDropTarget(false);</a>
<a name="ln9667"> </a>
<a name="ln9668">	fDropTarget = targetPose;</a>
<a name="ln9669"> </a>
<a name="ln9670">	// dereference if symlink</a>
<a name="ln9671">	Model* targetModel = NULL;</a>
<a name="ln9672">	if (targetPose != NULL)</a>
<a name="ln9673">		targetModel = targetPose-&gt;TargetModel();</a>
<a name="ln9674"> </a>
<a name="ln9675">	Model tmpTarget;</a>
<a name="ln9676">	if (targetModel != NULL &amp;&amp; targetModel-&gt;IsSymLink()</a>
<a name="ln9677">		&amp;&amp; tmpTarget.SetTo(targetPose-&gt;TargetModel()-&gt;EntryRef(), true, true)</a>
<a name="ln9678">			== B_OK) {</a>
<a name="ln9679">		targetModel = &amp;tmpTarget;</a>
<a name="ln9680">	}</a>
<a name="ln9681"> </a>
<a name="ln9682">	bool ignoreTypes = (modifiers() &amp; B_CONTROL_KEY) != 0;</a>
<a name="ln9683">	if (targetPose != NULL) {</a>
<a name="ln9684">		if (targetModel != NULL</a>
<a name="ln9685">			&amp;&amp; CanHandleDragSelection(targetModel, dragMessage, ignoreTypes)) {</a>
<a name="ln9686">			// new target is valid, select it</a>
<a name="ln9687">			HiliteDropTarget(true);</a>
<a name="ln9688">		} else {</a>
<a name="ln9689">			fDropTarget = NULL;</a>
<a name="ln9690">			fCursorCheck = false;</a>
<a name="ln9691">		}</a>
<a name="ln9692">	}</a>
<a name="ln9693">	if (targetModel == NULL)</a>
<a name="ln9694">		targetModel = TargetModel();</a>
<a name="ln9695"> </a>
<a name="ln9696">	// if this is an OpenWith window, we'll have no target model</a>
<a name="ln9697">	if (targetModel == NULL)</a>
<a name="ln9698">		return false;</a>
<a name="ln9699"> </a>
<a name="ln9700">	entry_ref srcRef;</a>
<a name="ln9701">	if (targetModel-&gt;IsDirectory() &amp;&amp; dragMessage-&gt;HasRef(&quot;refs&quot;)</a>
<a name="ln9702">		&amp;&amp; dragMessage-&gt;FindRef(&quot;refs&quot;, &amp;srcRef) == B_OK) {</a>
<a name="ln9703">		Model srcModel(&amp;srcRef);</a>
<a name="ln9704">		if (!CheckDevicesEqual(&amp;srcRef, targetModel)</a>
<a name="ln9705">			&amp;&amp; !srcModel.IsVolume()</a>
<a name="ln9706">			&amp;&amp; !srcModel.IsRoot()) {</a>
<a name="ln9707">			BCursor copyCursor(B_CURSOR_ID_COPY);</a>
<a name="ln9708">			SetViewCursor(&amp;copyCursor);</a>
<a name="ln9709">			return true;</a>
<a name="ln9710">		}</a>
<a name="ln9711">	}</a>
<a name="ln9712"> </a>
<a name="ln9713">	SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln9714"> </a>
<a name="ln9715">	return true;</a>
<a name="ln9716">}</a>
<a name="ln9717"> </a>
<a name="ln9718"> </a>
<a name="ln9719">bool</a>
<a name="ln9720">BPoseView::FrameForPose(BPose* targetPose, bool convert, BRect* poseRect)</a>
<a name="ln9721">{</a>
<a name="ln9722">	bool frameIsValid = false;</a>
<a name="ln9723">	BRect bounds(Bounds());</a>
<a name="ln9724"> </a>
<a name="ln9725">	if (ViewMode() == kListMode) {</a>
<a name="ln9726">		PoseList* poseList = CurrentPoseList();</a>
<a name="ln9727">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln9728">		int32 startIndex = (int32)(bounds.top / fListElemHeight);</a>
<a name="ln9729"> </a>
<a name="ln9730">		BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln9731">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln9732">			if (targetPose == poseList-&gt;ItemAt(index)) {</a>
<a name="ln9733">				*poseRect = fDropTarget-&gt;CalcRect(loc, this, false);</a>
<a name="ln9734">				frameIsValid = true;</a>
<a name="ln9735">			}</a>
<a name="ln9736"> </a>
<a name="ln9737">			loc.y += fListElemHeight;</a>
<a name="ln9738">			if (loc.y &gt; bounds.bottom)</a>
<a name="ln9739">				frameIsValid = false;</a>
<a name="ln9740">		}</a>
<a name="ln9741">	} else {</a>
<a name="ln9742">		int32 startIndex = FirstIndexAtOrBelow((int32)(bounds.top</a>
<a name="ln9743">			- IconPoseHeight()), true);</a>
<a name="ln9744">		int32 count = fVSPoseList-&gt;CountItems();</a>
<a name="ln9745"> </a>
<a name="ln9746">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln9747">			BPose* pose = fVSPoseList-&gt;ItemAt(index);</a>
<a name="ln9748">			if (pose != NULL) {</a>
<a name="ln9749">				if (pose == fDropTarget) {</a>
<a name="ln9750">					*poseRect = pose-&gt;CalcRect(this);</a>
<a name="ln9751">					frameIsValid = true;</a>
<a name="ln9752">					break;</a>
<a name="ln9753">				}</a>
<a name="ln9754"> </a>
<a name="ln9755">				if (pose-&gt;Location(this).y &gt; bounds.bottom) {</a>
<a name="ln9756">					frameIsValid = false;</a>
<a name="ln9757">					break;</a>
<a name="ln9758">				}</a>
<a name="ln9759">			}</a>
<a name="ln9760">		}</a>
<a name="ln9761">	}</a>
<a name="ln9762"> </a>
<a name="ln9763">	if (convert)</a>
<a name="ln9764">		ConvertToScreen(poseRect);</a>
<a name="ln9765"> </a>
<a name="ln9766">	return frameIsValid;</a>
<a name="ln9767">}</a>
<a name="ln9768"> </a>
<a name="ln9769"> </a>
<a name="ln9770">bool</a>
<a name="ln9771">BPoseView::MenuTrackingHook(BMenu* menu, void*)</a>
<a name="ln9772">{</a>
<a name="ln9773">	// return true if the menu should go away</a>
<a name="ln9774">	if (!menu-&gt;LockLooper())</a>
<a name="ln9775">		return false;</a>
<a name="ln9776"> </a>
<a name="ln9777">	uint32 buttons;</a>
<a name="ln9778">	BPoint location;</a>
<a name="ln9779">	menu-&gt;GetMouse(&amp;location, &amp;buttons);</a>
<a name="ln9780"> </a>
<a name="ln9781">	bool mouseInMenu = true;</a>
<a name="ln9782">	// don't test for buttons up here and try to circumvent messaging</a>
<a name="ln9783">	// lest you miss an invoke that will happen after the window goes away</a>
<a name="ln9784"> </a>
<a name="ln9785">	BRect bounds(menu-&gt;Bounds());</a>
<a name="ln9786">	bounds.InsetBy(-kMenuTrackMargin, -kMenuTrackMargin);</a>
<a name="ln9787">	if (bounds.Contains(location)) {</a>
<a name="ln9788">		// still in menu</a>
<a name="ln9789">		mouseInMenu =  false;</a>
<a name="ln9790">	}</a>
<a name="ln9791"> </a>
<a name="ln9792">	if (mouseInMenu) {</a>
<a name="ln9793">		menu-&gt;ConvertToScreen(&amp;location);</a>
<a name="ln9794">		int32 count = menu-&gt;CountItems();</a>
<a name="ln9795">		for (int32 index = 0 ; index &lt; count; index++) {</a>
<a name="ln9796">			// iterate through all of the items in the menu</a>
<a name="ln9797">			// if the submenu is showing, see if the mouse is in the submenu</a>
<a name="ln9798">			BMenuItem* item = menu-&gt;ItemAt(index);</a>
<a name="ln9799">			if (item &amp;&amp; item-&gt;Submenu()) {</a>
<a name="ln9800">				BWindow* window = item-&gt;Submenu()-&gt;Window();</a>
<a name="ln9801">				bool inSubmenu = false;</a>
<a name="ln9802">				if (window &amp;&amp; window-&gt;Lock()) {</a>
<a name="ln9803">					if (!window-&gt;IsHidden()) {</a>
<a name="ln9804">						BRect frame(window-&gt;Frame());</a>
<a name="ln9805"> </a>
<a name="ln9806">						frame.InsetBy(-kMenuTrackMargin, -kMenuTrackMargin);</a>
<a name="ln9807">						inSubmenu = frame.Contains(location);</a>
<a name="ln9808">					}</a>
<a name="ln9809">					window-&gt;Unlock();</a>
<a name="ln9810">					if (inSubmenu) {</a>
<a name="ln9811">						// only one menu can have its window open bail now</a>
<a name="ln9812">						mouseInMenu = false;</a>
<a name="ln9813">						break;</a>
<a name="ln9814">					}</a>
<a name="ln9815">				}</a>
<a name="ln9816">			}</a>
<a name="ln9817">		}</a>
<a name="ln9818">	}</a>
<a name="ln9819"> </a>
<a name="ln9820">	menu-&gt;UnlockLooper();</a>
<a name="ln9821"> </a>
<a name="ln9822">	return mouseInMenu;</a>
<a name="ln9823">}</a>
<a name="ln9824"> </a>
<a name="ln9825"> </a>
<a name="ln9826">void</a>
<a name="ln9827">BPoseView::DragStop()</a>
<a name="ln9828">{</a>
<a name="ln9829">	fStartFrame.Set(0, 0, 0, 0);</a>
<a name="ln9830">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln9831">	if (window != NULL)</a>
<a name="ln9832">		window-&gt;DragStop();</a>
<a name="ln9833">}</a>
<a name="ln9834"> </a>
<a name="ln9835"> </a>
<a name="ln9836">void</a>
<a name="ln9837">BPoseView::HiliteDropTarget(bool hiliteState)</a>
<a name="ln9838">{</a>
<a name="ln9839">	// hilites current drop target while dragging, does not modify</a>
<a name="ln9840">	// selection list</a>
<a name="ln9841">	if (fDropTarget == NULL)</a>
<a name="ln9842">		return;</a>
<a name="ln9843"> </a>
<a name="ln9844">	// note: fAlreadySelectedDropTarget is a trick to avoid to really search</a>
<a name="ln9845">	// fSelectionList. Another solution would be to add Hilite/IsHilited just</a>
<a name="ln9846">	// like Select/IsSelected in BPose and let it handle this case internally</a>
<a name="ln9847"> </a>
<a name="ln9848">	// can happen when starting a new drag</a>
<a name="ln9849">	if (fAlreadySelectedDropTarget != fDropTarget)</a>
<a name="ln9850">		fAlreadySelectedDropTarget = NULL;</a>
<a name="ln9851"> </a>
<a name="ln9852">	// don't select, this droptarget was already part of a user selection</a>
<a name="ln9853">	if (fDropTarget-&gt;IsSelected() &amp;&amp; hiliteState) {</a>
<a name="ln9854">		fAlreadySelectedDropTarget = fDropTarget;</a>
<a name="ln9855">		return;</a>
<a name="ln9856">	}</a>
<a name="ln9857"> </a>
<a name="ln9858">	// don't unselect the fAlreadySelectedDropTarget</a>
<a name="ln9859">	if ((fAlreadySelectedDropTarget == fDropTarget) &amp;&amp; !hiliteState) {</a>
<a name="ln9860">		fAlreadySelectedDropTarget = NULL;</a>
<a name="ln9861">		return;</a>
<a name="ln9862">	}</a>
<a name="ln9863"> </a>
<a name="ln9864">	fDropTarget-&gt;Select(hiliteState);</a>
<a name="ln9865"> </a>
<a name="ln9866">	// scan all visible poses</a>
<a name="ln9867">	BRect bounds(Bounds());</a>
<a name="ln9868"> </a>
<a name="ln9869">	if (ViewMode() == kListMode) {</a>
<a name="ln9870">		PoseList* poseList = CurrentPoseList();</a>
<a name="ln9871">		int32 count = poseList-&gt;CountItems();</a>
<a name="ln9872">		int32 startIndex = (int32)(bounds.top / fListElemHeight);</a>
<a name="ln9873"> </a>
<a name="ln9874">		BPoint loc(0, startIndex * fListElemHeight);</a>
<a name="ln9875"> </a>
<a name="ln9876">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln9877">			if (fDropTarget == poseList-&gt;ItemAt(index)) {</a>
<a name="ln9878">				BRect poseRect = fDropTarget-&gt;CalcRect(loc, this, false);</a>
<a name="ln9879">				fDropTarget-&gt;Draw(poseRect, poseRect, this, false);</a>
<a name="ln9880">				break;</a>
<a name="ln9881">			}</a>
<a name="ln9882"> </a>
<a name="ln9883">			loc.y += fListElemHeight;</a>
<a name="ln9884">			if (loc.y &gt; bounds.bottom)</a>
<a name="ln9885">				break;</a>
<a name="ln9886">		}</a>
<a name="ln9887">	} else {</a>
<a name="ln9888">		int32 startIndex = FirstIndexAtOrBelow(</a>
<a name="ln9889">			(int32)(bounds.top - IconPoseHeight()), true);</a>
<a name="ln9890">		int32 count = fVSPoseList-&gt;CountItems();</a>
<a name="ln9891"> </a>
<a name="ln9892">		for (int32 index = startIndex; index &lt; count; index++) {</a>
<a name="ln9893">			BPose* pose = fVSPoseList-&gt;ItemAt(index);</a>
<a name="ln9894">			if (pose != NULL) {</a>
<a name="ln9895">				if (pose == fDropTarget) {</a>
<a name="ln9896">					BRect poseRect = pose-&gt;CalcRect(this);</a>
<a name="ln9897">					// TODO: maybe leave just the else part</a>
<a name="ln9898">					if (!hiliteState)</a>
<a name="ln9899">						// deselecting an icon with widget drawn over background</a>
<a name="ln9900">						// have to be a little tricky here - draw just the icon,</a>
<a name="ln9901">						// invalidate the widget</a>
<a name="ln9902">						pose-&gt;DeselectWithoutErasingBackground(poseRect, this);</a>
<a name="ln9903">					else</a>
<a name="ln9904">						pose-&gt;Draw(poseRect, poseRect, this, false);</a>
<a name="ln9905">					break;</a>
<a name="ln9906">				}</a>
<a name="ln9907"> </a>
<a name="ln9908">				if (pose-&gt;Location(this).y &gt; bounds.bottom)</a>
<a name="ln9909">					break;</a>
<a name="ln9910">			}</a>
<a name="ln9911">		}</a>
<a name="ln9912">	}</a>
<a name="ln9913">}</a>
<a name="ln9914"> </a>
<a name="ln9915"> </a>
<a name="ln9916">bool</a>
<a name="ln9917">BPoseView::CheckAutoScroll(BPoint mouseLoc, bool shouldScroll)</a>
<a name="ln9918">{</a>
<a name="ln9919">	if (!fShouldAutoScroll)</a>
<a name="ln9920">		return false;</a>
<a name="ln9921"> </a>
<a name="ln9922">	// make sure window is in front before attempting scrolling</a>
<a name="ln9923">	BContainerWindow* window = ContainerWindow();</a>
<a name="ln9924">	if (window == NULL)</a>
<a name="ln9925">		return false;</a>
<a name="ln9926"> </a>
<a name="ln9927">	BRect bounds(Bounds());</a>
<a name="ln9928">	BRect extent(Extent());</a>
<a name="ln9929"> </a>
<a name="ln9930">	bool wouldScroll = false;</a>
<a name="ln9931">	bool keepGoing;</a>
<a name="ln9932">	float scrollIncrement;</a>
<a name="ln9933"> </a>
<a name="ln9934">	BRect border(bounds);</a>
<a name="ln9935">	border.bottom = border.top;</a>
<a name="ln9936">	border.top -= kBorderHeight;</a>
<a name="ln9937">	if (ViewMode() == kListMode)</a>
<a name="ln9938">		border.top -= TitleView()-&gt;Bounds().Height();</a>
<a name="ln9939"> </a>
<a name="ln9940">	bool selectionScrolling = fSelectionRectInfo.isDragging;</a>
<a name="ln9941"> </a>
<a name="ln9942">	if (bounds.top &gt; extent.top) {</a>
<a name="ln9943">		if (selectionScrolling) {</a>
<a name="ln9944">			keepGoing = mouseLoc.y &lt; bounds.top;</a>
<a name="ln9945">			if (fabs(bounds.top - mouseLoc.y) &gt; kSlowScrollBucket)</a>
<a name="ln9946">				scrollIncrement = fAutoScrollInc / 1.5f;</a>
<a name="ln9947">			else</a>
<a name="ln9948">				scrollIncrement = fAutoScrollInc / 4;</a>
<a name="ln9949">		} else {</a>
<a name="ln9950">			keepGoing = border.Contains(mouseLoc);</a>
<a name="ln9951">			scrollIncrement = fAutoScrollInc;</a>
<a name="ln9952">		}</a>
<a name="ln9953"> </a>
<a name="ln9954">		if (keepGoing) {</a>
<a name="ln9955">			wouldScroll = true;</a>
<a name="ln9956">			if (shouldScroll) {</a>
<a name="ln9957">				if (fVScrollBar != NULL) {</a>
<a name="ln9958">					fVScrollBar-&gt;SetValue(</a>
<a name="ln9959">						fVScrollBar-&gt;Value() - scrollIncrement);</a>
<a name="ln9960">				} else</a>
<a name="ln9961">					ScrollBy(0, -scrollIncrement);</a>
<a name="ln9962">			}</a>
<a name="ln9963">		}</a>
<a name="ln9964">	}</a>
<a name="ln9965"> </a>
<a name="ln9966">	border = bounds;</a>
<a name="ln9967">	border.top = border.bottom;</a>
<a name="ln9968">	border.bottom += (float)B_H_SCROLL_BAR_HEIGHT;</a>
<a name="ln9969">	if (bounds.bottom &lt; extent.bottom) {</a>
<a name="ln9970">		if (selectionScrolling) {</a>
<a name="ln9971">			keepGoing = mouseLoc.y &gt; bounds.bottom;</a>
<a name="ln9972">			if (fabs(bounds.bottom - mouseLoc.y) &gt; kSlowScrollBucket)</a>
<a name="ln9973">				scrollIncrement = fAutoScrollInc / 1.5f;</a>
<a name="ln9974">			else</a>
<a name="ln9975">				scrollIncrement = fAutoScrollInc / 4;</a>
<a name="ln9976">		} else {</a>
<a name="ln9977">			keepGoing = border.Contains(mouseLoc);</a>
<a name="ln9978">			scrollIncrement = fAutoScrollInc;</a>
<a name="ln9979">		}</a>
<a name="ln9980"> </a>
<a name="ln9981">		if (keepGoing) {</a>
<a name="ln9982">			wouldScroll = true;</a>
<a name="ln9983">			if (shouldScroll) {</a>
<a name="ln9984">				if (fVScrollBar != NULL) {</a>
<a name="ln9985">					fVScrollBar-&gt;SetValue(</a>
<a name="ln9986">						fVScrollBar-&gt;Value() + scrollIncrement);</a>
<a name="ln9987">				} else</a>
<a name="ln9988">					ScrollBy(0, scrollIncrement);</a>
<a name="ln9989">			}</a>
<a name="ln9990">		}</a>
<a name="ln9991">	}</a>
<a name="ln9992"> </a>
<a name="ln9993">	border = bounds;</a>
<a name="ln9994">	border.right = border.left;</a>
<a name="ln9995">	border.left -= 6;</a>
<a name="ln9996">	if (bounds.left &gt; extent.left) {</a>
<a name="ln9997">		if (selectionScrolling) {</a>
<a name="ln9998">			keepGoing = mouseLoc.x &lt; bounds.left;</a>
<a name="ln9999">			if (fabs(bounds.left - mouseLoc.x) &gt; kSlowScrollBucket)</a>
<a name="ln10000">				scrollIncrement = fAutoScrollInc / 1.5f;</a>
<a name="ln10001">			else</a>
<a name="ln10002">				scrollIncrement = fAutoScrollInc / 4;</a>
<a name="ln10003">		} else {</a>
<a name="ln10004">			keepGoing = border.Contains(mouseLoc);</a>
<a name="ln10005">			scrollIncrement = fAutoScrollInc;</a>
<a name="ln10006">		}</a>
<a name="ln10007"> </a>
<a name="ln10008">		if (keepGoing) {</a>
<a name="ln10009">			wouldScroll = true;</a>
<a name="ln10010">			if (shouldScroll) {</a>
<a name="ln10011">				if (fHScrollBar != NULL) {</a>
<a name="ln10012">					fHScrollBar-&gt;SetValue(</a>
<a name="ln10013">						fHScrollBar-&gt;Value() - scrollIncrement);</a>
<a name="ln10014">				} else</a>
<a name="ln10015">					ScrollBy(-scrollIncrement, 0);</a>
<a name="ln10016">			}</a>
<a name="ln10017">		}</a>
<a name="ln10018">	}</a>
<a name="ln10019"> </a>
<a name="ln10020">	border = bounds;</a>
<a name="ln10021">	border.left = border.right;</a>
<a name="ln10022">	border.right += (float)B_V_SCROLL_BAR_WIDTH;</a>
<a name="ln10023">	if (bounds.right &lt; extent.right) {</a>
<a name="ln10024">		if (selectionScrolling) {</a>
<a name="ln10025">			keepGoing = mouseLoc.x &gt; bounds.right;</a>
<a name="ln10026">			if (fabs(bounds.right - mouseLoc.x) &gt; kSlowScrollBucket)</a>
<a name="ln10027">				scrollIncrement = fAutoScrollInc / 1.5f;</a>
<a name="ln10028">			else</a>
<a name="ln10029">				scrollIncrement = fAutoScrollInc / 4;</a>
<a name="ln10030">		} else {</a>
<a name="ln10031">			keepGoing = border.Contains(mouseLoc);</a>
<a name="ln10032">			scrollIncrement = fAutoScrollInc;</a>
<a name="ln10033">		}</a>
<a name="ln10034"> </a>
<a name="ln10035">		if (keepGoing) {</a>
<a name="ln10036">			wouldScroll = true;</a>
<a name="ln10037">			if (shouldScroll) {</a>
<a name="ln10038">				if (fHScrollBar != NULL) {</a>
<a name="ln10039">					fHScrollBar-&gt;SetValue(</a>
<a name="ln10040">						fHScrollBar-&gt;Value() + scrollIncrement);</a>
<a name="ln10041"> 				} else</a>
<a name="ln10042"> 					ScrollBy(scrollIncrement, 0);</a>
<a name="ln10043">			}</a>
<a name="ln10044">		}</a>
<a name="ln10045">	}</a>
<a name="ln10046"> </a>
<a name="ln10047">	// Force selection rect update to account for the new scrolled coords</a>
<a name="ln10048">	// without a mouse move</a>
<a name="ln10049">	if (selectionScrolling)</a>
<a name="ln10050">		_UpdateSelectionRect(mouseLoc);</a>
<a name="ln10051"> </a>
<a name="ln10052">	return wouldScroll;</a>
<a name="ln10053">}</a>
<a name="ln10054"> </a>
<a name="ln10055"> </a>
<a name="ln10056">void</a>
<a name="ln10057">BPoseView::HandleAutoScroll()</a>
<a name="ln10058">{</a>
<a name="ln10059">	if (!fShouldAutoScroll)</a>
<a name="ln10060">		return;</a>
<a name="ln10061"> </a>
<a name="ln10062">	uint32 buttons;</a>
<a name="ln10063">	BPoint mouseLoc;</a>
<a name="ln10064">	GetMouse(&amp;mouseLoc, &amp;buttons);</a>
<a name="ln10065"> </a>
<a name="ln10066">	if (buttons == 0) {</a>
<a name="ln10067">		fAutoScrollState = kAutoScrollOff;</a>
<a name="ln10068">		Window()-&gt;SetPulseRate(500000);</a>
<a name="ln10069">		return;</a>
<a name="ln10070">	}</a>
<a name="ln10071"> </a>
<a name="ln10072">	switch (fAutoScrollState) {</a>
<a name="ln10073">		case kWaitForTransition:</a>
<a name="ln10074">			if (CheckAutoScroll(mouseLoc, false) == false)</a>
<a name="ln10075">				fAutoScrollState = kDelayAutoScroll;</a>
<a name="ln10076">			break;</a>
<a name="ln10077"> </a>
<a name="ln10078">		case kDelayAutoScroll:</a>
<a name="ln10079">			if (CheckAutoScroll(mouseLoc, false) == true) {</a>
<a name="ln10080">				snooze(600000);</a>
<a name="ln10081">				GetMouse(&amp;mouseLoc, &amp;buttons);</a>
<a name="ln10082">				if (CheckAutoScroll(mouseLoc, false) == true)</a>
<a name="ln10083">					fAutoScrollState = kAutoScrollOn;</a>
<a name="ln10084">			}</a>
<a name="ln10085">			break;</a>
<a name="ln10086"> </a>
<a name="ln10087">		case kAutoScrollOn:</a>
<a name="ln10088">			CheckAutoScroll(mouseLoc, true);</a>
<a name="ln10089">			break;</a>
<a name="ln10090">	}</a>
<a name="ln10091">}</a>
<a name="ln10092"> </a>
<a name="ln10093"> </a>
<a name="ln10094">BRect</a>
<a name="ln10095">BPoseView::CalcPoseRect(const BPose* pose, int32 index,</a>
<a name="ln10096">	bool firstColumnOnly) const</a>
<a name="ln10097">{</a>
<a name="ln10098">	if (ViewMode() == kListMode)</a>
<a name="ln10099">		return CalcPoseRectList(pose, index, firstColumnOnly);</a>
<a name="ln10100">	else</a>
<a name="ln10101">		return CalcPoseRectIcon(pose);</a>
<a name="ln10102">}</a>
<a name="ln10103"> </a>
<a name="ln10104"> </a>
<a name="ln10105">BRect</a>
<a name="ln10106">BPoseView::CalcPoseRectIcon(const BPose* pose) const</a>
<a name="ln10107">{</a>
<a name="ln10108">	return pose-&gt;CalcRect(this);</a>
<a name="ln10109">}</a>
<a name="ln10110"> </a>
<a name="ln10111"> </a>
<a name="ln10112">BRect</a>
<a name="ln10113">BPoseView::CalcPoseRectList(const BPose* pose, int32 index,</a>
<a name="ln10114">	bool firstColumnOnly) const</a>
<a name="ln10115">{</a>
<a name="ln10116">	return pose-&gt;CalcRect(BPoint(0, index * fListElemHeight), this,</a>
<a name="ln10117">		firstColumnOnly);</a>
<a name="ln10118">}</a>
<a name="ln10119"> </a>
<a name="ln10120"> </a>
<a name="ln10121">bool</a>
<a name="ln10122">BPoseView::Represents(const node_ref* node) const</a>
<a name="ln10123">{</a>
<a name="ln10124">	return *(fModel-&gt;NodeRef()) == *node;</a>
<a name="ln10125">}</a>
<a name="ln10126"> </a>
<a name="ln10127"> </a>
<a name="ln10128">bool</a>
<a name="ln10129">BPoseView::Represents(const entry_ref* ref) const</a>
<a name="ln10130">{</a>
<a name="ln10131">	return *fModel-&gt;EntryRef() == *ref;</a>
<a name="ln10132">}</a>
<a name="ln10133"> </a>
<a name="ln10134"> </a>
<a name="ln10135">void</a>
<a name="ln10136">BPoseView::ShowBarberPole()</a>
<a name="ln10137">{</a>
<a name="ln10138">	if (fCountView) {</a>
<a name="ln10139">		AutoLock&lt;BWindow&gt; lock(Window());</a>
<a name="ln10140">		if (!lock)</a>
<a name="ln10141">			return;</a>
<a name="ln10142">		fCountView-&gt;StartBarberPole();</a>
<a name="ln10143">	}</a>
<a name="ln10144">}</a>
<a name="ln10145"> </a>
<a name="ln10146"> </a>
<a name="ln10147">void</a>
<a name="ln10148">BPoseView::HideBarberPole()</a>
<a name="ln10149">{</a>
<a name="ln10150">	if (fCountView != NULL) {</a>
<a name="ln10151">		AutoLock&lt;BWindow&gt; lock(Window());</a>
<a name="ln10152">		if (!lock)</a>
<a name="ln10153">			return;</a>
<a name="ln10154">		fCountView-&gt;EndBarberPole();</a>
<a name="ln10155">	}</a>
<a name="ln10156">}</a>
<a name="ln10157"> </a>
<a name="ln10158"> </a>
<a name="ln10159">bool</a>
<a name="ln10160">BPoseView::IsWatchingDateFormatChange()</a>
<a name="ln10161">{</a>
<a name="ln10162">	return fIsWatchingDateFormatChange;</a>
<a name="ln10163">}</a>
<a name="ln10164"> </a>
<a name="ln10165"> </a>
<a name="ln10166">void</a>
<a name="ln10167">BPoseView::StartWatchDateFormatChange()</a>
<a name="ln10168">{</a>
<a name="ln10169">	BMessenger trackerMessenger(kTrackerSignature);</a>
<a name="ln10170">	BHandler::StartWatching(trackerMessenger, kDateFormatChanged);</a>
<a name="ln10171">	fIsWatchingDateFormatChange = true;</a>
<a name="ln10172">}</a>
<a name="ln10173"> </a>
<a name="ln10174"> </a>
<a name="ln10175">void</a>
<a name="ln10176">BPoseView::StopWatchDateFormatChange()</a>
<a name="ln10177">{</a>
<a name="ln10178">	if (IsFilePanel()) {</a>
<a name="ln10179">		BMessenger trackerMessenger(kTrackerSignature);</a>
<a name="ln10180">		BHandler::StopWatching(trackerMessenger, kDateFormatChanged);</a>
<a name="ln10181">	} else if (be_app-&gt;LockLooper()) {</a>
<a name="ln10182">		be_app-&gt;StopWatching(this, kDateFormatChanged);</a>
<a name="ln10183">		be_app-&gt;UnlockLooper();</a>
<a name="ln10184">	}</a>
<a name="ln10185"> </a>
<a name="ln10186">	fIsWatchingDateFormatChange = false;</a>
<a name="ln10187">}</a>
<a name="ln10188"> </a>
<a name="ln10189"> </a>
<a name="ln10190">void</a>
<a name="ln10191">BPoseView::UpdateDateColumns(BMessage* message)</a>
<a name="ln10192">{</a>
<a name="ln10193">	int32 columnCount = CountColumns();</a>
<a name="ln10194">	BRect columnRect(Bounds());</a>
<a name="ln10195"> </a>
<a name="ln10196">	for (int32 i = 0; i &lt; columnCount; i++) {</a>
<a name="ln10197">		BColumn* col = ColumnAt(i);</a>
<a name="ln10198">		if (col &amp;&amp; col-&gt;AttrType() == B_TIME_TYPE) {</a>
<a name="ln10199">			columnRect.left = col-&gt;Offset();</a>
<a name="ln10200">			columnRect.right = columnRect.left + col-&gt;Width();</a>
<a name="ln10201">			Invalidate(columnRect);</a>
<a name="ln10202">		}</a>
<a name="ln10203">	}</a>
<a name="ln10204">}</a>
<a name="ln10205"> </a>
<a name="ln10206"> </a>
<a name="ln10207">void</a>
<a name="ln10208">BPoseView::AdaptToVolumeChange(BMessage*)</a>
<a name="ln10209">{</a>
<a name="ln10210">}</a>
<a name="ln10211"> </a>
<a name="ln10212"> </a>
<a name="ln10213">void</a>
<a name="ln10214">BPoseView::AdaptToDesktopIntegrationChange(BMessage*)</a>
<a name="ln10215">{</a>
<a name="ln10216">}</a>
<a name="ln10217"> </a>
<a name="ln10218"> </a>
<a name="ln10219">bool</a>
<a name="ln10220">BPoseView::WidgetTextOutline() const</a>
<a name="ln10221">{</a>
<a name="ln10222">	return fWidgetTextOutline;</a>
<a name="ln10223">}</a>
<a name="ln10224"> </a>
<a name="ln10225"> </a>
<a name="ln10226">void</a>
<a name="ln10227">BPoseView::SetWidgetTextOutline(bool on)</a>
<a name="ln10228">{</a>
<a name="ln10229">	fWidgetTextOutline = on;</a>
<a name="ln10230">}</a>
<a name="ln10231"> </a>
<a name="ln10232"> </a>
<a name="ln10233">void</a>
<a name="ln10234">BPoseView::EnsurePoseUnselected(BPose* pose)</a>
<a name="ln10235">{</a>
<a name="ln10236">	if (pose == fDropTarget)</a>
<a name="ln10237">		fDropTarget = NULL;</a>
<a name="ln10238"> </a>
<a name="ln10239">	if (pose == ActivePose())</a>
<a name="ln10240">		CommitActivePose();</a>
<a name="ln10241"> </a>
<a name="ln10242">	fSelectionList-&gt;RemoveItem(pose);</a>
<a name="ln10243">	if (fSelectionPivotPose == pose)</a>
<a name="ln10244">		fSelectionPivotPose = NULL;</a>
<a name="ln10245"> </a>
<a name="ln10246">	if (fRealPivotPose == pose)</a>
<a name="ln10247">		fRealPivotPose = NULL;</a>
<a name="ln10248"> </a>
<a name="ln10249">	if (pose-&gt;IsSelected()) {</a>
<a name="ln10250">		pose-&gt;Select(false);</a>
<a name="ln10251">		if (fSelectionChangedHook)</a>
<a name="ln10252">			ContainerWindow()-&gt;SelectionChanged();</a>
<a name="ln10253">	}</a>
<a name="ln10254">}</a>
<a name="ln10255"> </a>
<a name="ln10256"> </a>
<a name="ln10257">void</a>
<a name="ln10258">BPoseView::RemoveFilteredPose(BPose* pose, int32 index)</a>
<a name="ln10259">{</a>
<a name="ln10260">	EnsurePoseUnselected(pose);</a>
<a name="ln10261">	fFilteredPoseList-&gt;RemoveItemAt(index);</a>
<a name="ln10262"> </a>
<a name="ln10263">	BRect invalidRect = CalcPoseRectList(pose, index);</a>
<a name="ln10264">	CloseGapInList(&amp;invalidRect);</a>
<a name="ln10265"> </a>
<a name="ln10266">	Invalidate(invalidRect);</a>
<a name="ln10267">}</a>
<a name="ln10268"> </a>
<a name="ln10269"> </a>
<a name="ln10270">void</a>
<a name="ln10271">BPoseView::FilterChanged()</a>
<a name="ln10272">{</a>
<a name="ln10273">	if (ViewMode() != kListMode)</a>
<a name="ln10274">		return;</a>
<a name="ln10275"> </a>
<a name="ln10276">	int32 stringCount = fFilterStrings.CountItems();</a>
<a name="ln10277">	int32 length = fFilterStrings.LastItem()-&gt;CountChars();</a>
<a name="ln10278"> </a>
<a name="ln10279">	if (!fFiltering &amp;&amp; (length &gt; 0 || fRefFilter != NULL))</a>
<a name="ln10280">		StartFiltering();</a>
<a name="ln10281">	else if (fFiltering &amp;&amp; stringCount == 1 &amp;&amp; length == 0</a>
<a name="ln10282">		&amp;&amp; fRefFilter == NULL) {</a>
<a name="ln10283">		ClearFilter();</a>
<a name="ln10284">	} else {</a>
<a name="ln10285">		if (fLastFilterStringCount &gt; stringCount</a>
<a name="ln10286">			|| (fLastFilterStringCount == stringCount</a>
<a name="ln10287">				&amp;&amp; fLastFilterStringLength &gt; length)</a>
<a name="ln10288">			|| fRefFilter != NULL) {</a>
<a name="ln10289">			// something was removed, need to start over</a>
<a name="ln10290">			fFilteredPoseList-&gt;MakeEmpty();</a>
<a name="ln10291">			fFiltering = false;</a>
<a name="ln10292">			StartFiltering();</a>
<a name="ln10293">		} else {</a>
<a name="ln10294">			int32 count = fFilteredPoseList-&gt;CountItems();</a>
<a name="ln10295">			for (int32 i = count - 1; i &gt;= 0; i--) {</a>
<a name="ln10296">				BPose* pose = fFilteredPoseList-&gt;ItemAt(i);</a>
<a name="ln10297">				if (!FilterPose(pose))</a>
<a name="ln10298">					RemoveFilteredPose(pose, i);</a>
<a name="ln10299">			}</a>
<a name="ln10300">		}</a>
<a name="ln10301">	}</a>
<a name="ln10302"> </a>
<a name="ln10303">	fLastFilterStringCount = stringCount;</a>
<a name="ln10304">	fLastFilterStringLength = length;</a>
<a name="ln10305">	UpdateAfterFilterChange();</a>
<a name="ln10306">}</a>
<a name="ln10307"> </a>
<a name="ln10308"> </a>
<a name="ln10309">void</a>
<a name="ln10310">BPoseView::UpdateAfterFilterChange()</a>
<a name="ln10311">{</a>
<a name="ln10312">	UpdateCount();</a>
<a name="ln10313"> </a>
<a name="ln10314">	BPose* pose = fFilteredPoseList-&gt;LastItem();</a>
<a name="ln10315">	if (pose == NULL)</a>
<a name="ln10316">		BView::ScrollTo(0, 0);</a>
<a name="ln10317">	else {</a>
<a name="ln10318">		BRect bounds = Bounds();</a>
<a name="ln10319">		float height = fFilteredPoseList-&gt;CountItems() * fListElemHeight;</a>
<a name="ln10320">		if (bounds.top &gt; 0 &amp;&amp; bounds.bottom &gt; height)</a>
<a name="ln10321">			BView::ScrollTo(0, std::max(height - bounds.Height(), 0.0f));</a>
<a name="ln10322">	}</a>
<a name="ln10323"> </a>
<a name="ln10324">	UpdateScrollRange();</a>
<a name="ln10325">}</a>
<a name="ln10326"> </a>
<a name="ln10327"> </a>
<a name="ln10328">bool</a>
<a name="ln10329">BPoseView::FilterPose(BPose* pose)</a>
<a name="ln10330">{</a>
<a name="ln10331">	if (!fFiltering || pose == NULL)</a>
<a name="ln10332">		return false;</a>
<a name="ln10333"> </a>
<a name="ln10334">	if (fRefFilter != NULL) {</a>
<a name="ln10335">		PoseInfo poseInfo;</a>
<a name="ln10336">		ReadPoseInfo(pose-&gt;TargetModel(), &amp;poseInfo);</a>
<a name="ln10337">		pose-&gt;TargetModel()-&gt;OpenNode();</a>
<a name="ln10338">		if (!ShouldShowPose(pose-&gt;TargetModel(), &amp;poseInfo))</a>
<a name="ln10339">			return false;</a>
<a name="ln10340">	}</a>
<a name="ln10341"> </a>
<a name="ln10342">	int32 stringCount = fFilterStrings.CountItems();</a>
<a name="ln10343">	int32 matchesLeft = stringCount;</a>
<a name="ln10344"> </a>
<a name="ln10345">	bool found[stringCount];</a>
<a name="ln10346">	memset(found, 0, sizeof(found));</a>
<a name="ln10347"> </a>
<a name="ln10348">	ModelNodeLazyOpener modelOpener(pose-&gt;TargetModel());</a>
<a name="ln10349">	for (int32 i = 0; i &lt; CountColumns(); i++) {</a>
<a name="ln10350">		BTextWidget* widget = pose-&gt;WidgetFor(ColumnAt(i), this, modelOpener);</a>
<a name="ln10351">		const char* text = NULL;</a>
<a name="ln10352">		if (widget == NULL)</a>
<a name="ln10353">			continue;</a>
<a name="ln10354"> </a>
<a name="ln10355">		text = widget-&gt;Text(this);</a>
<a name="ln10356">		if (text == NULL)</a>
<a name="ln10357">			continue;</a>
<a name="ln10358"> </a>
<a name="ln10359">		for (int32 j = 0; j &lt; stringCount; j++) {</a>
<a name="ln10360">			if (found[j])</a>
<a name="ln10361">				continue;</a>
<a name="ln10362"> </a>
<a name="ln10363">			if (strcasestr(text, fFilterStrings.ItemAt(j)-&gt;String()) != NULL) {</a>
<a name="ln10364">				if (--matchesLeft == 0)</a>
<a name="ln10365">					return true;</a>
<a name="ln10366"> </a>
<a name="ln10367">				found[j] = true;</a>
<a name="ln10368">			}</a>
<a name="ln10369">		}</a>
<a name="ln10370">	}</a>
<a name="ln10371"> </a>
<a name="ln10372">	return false;</a>
<a name="ln10373">}</a>
<a name="ln10374"> </a>
<a name="ln10375"> </a>
<a name="ln10376">void</a>
<a name="ln10377">BPoseView::StartFiltering()</a>
<a name="ln10378">{</a>
<a name="ln10379">	if (fFiltering)</a>
<a name="ln10380">		return;</a>
<a name="ln10381"> </a>
<a name="ln10382">	fFiltering = true;</a>
<a name="ln10383">	int32 count = fPoseList-&gt;CountItems();</a>
<a name="ln10384">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln10385">		BPose* pose = fPoseList-&gt;ItemAt(i);</a>
<a name="ln10386">		if (FilterPose(pose))</a>
<a name="ln10387">			fFilteredPoseList-&gt;AddItem(pose);</a>
<a name="ln10388">		else</a>
<a name="ln10389">			EnsurePoseUnselected(pose);</a>
<a name="ln10390">	}</a>
<a name="ln10391"> </a>
<a name="ln10392">	Invalidate();</a>
<a name="ln10393">}</a>
<a name="ln10394"> </a>
<a name="ln10395"> </a>
<a name="ln10396">bool</a>
<a name="ln10397">BPoseView::IsFiltering() const</a>
<a name="ln10398">{</a>
<a name="ln10399">	return fFiltering;</a>
<a name="ln10400">}</a>
<a name="ln10401"> </a>
<a name="ln10402"> </a>
<a name="ln10403">void</a>
<a name="ln10404">BPoseView::StopFiltering()</a>
<a name="ln10405">{</a>
<a name="ln10406">	ClearFilter();</a>
<a name="ln10407">	UpdateAfterFilterChange();</a>
<a name="ln10408">}</a>
<a name="ln10409"> </a>
<a name="ln10410"> </a>
<a name="ln10411">void</a>
<a name="ln10412">BPoseView::ClearFilter()</a>
<a name="ln10413">{</a>
<a name="ln10414">	if (!fFiltering)</a>
<a name="ln10415">		return;</a>
<a name="ln10416"> </a>
<a name="ln10417">	fCountView-&gt;CancelFilter();</a>
<a name="ln10418"> </a>
<a name="ln10419">	int32 stringCount = fFilterStrings.CountItems();</a>
<a name="ln10420">	for (int32 i = stringCount - 1; i &gt; 0; i--)</a>
<a name="ln10421">		delete fFilterStrings.RemoveItemAt(i);</a>
<a name="ln10422"> </a>
<a name="ln10423">	fFilterStrings.LastItem()-&gt;Truncate(0);</a>
<a name="ln10424">	fLastFilterStringCount = 1;</a>
<a name="ln10425">	fLastFilterStringLength = 0;</a>
<a name="ln10426"> </a>
<a name="ln10427">	if (fRefFilter == NULL)</a>
<a name="ln10428">		fFiltering = false;</a>
<a name="ln10429"> </a>
<a name="ln10430">	fFilteredPoseList-&gt;MakeEmpty();</a>
<a name="ln10431"> </a>
<a name="ln10432">	Invalidate();</a>
<a name="ln10433">}</a>
<a name="ln10434"> </a>
<a name="ln10435"> </a>
<a name="ln10436">void</a>
<a name="ln10437">BPoseView::ExcludeTrashFromSelection()</a>
<a name="ln10438">{</a>
<a name="ln10439">	int32 count = fSelectionList-&gt;CountItems();</a>
<a name="ln10440">	for (int index = 0; index &lt; count; index++) {</a>
<a name="ln10441">		BPose* pose = fSelectionList-&gt;ItemAt(index);</a>
<a name="ln10442">		if (CanTrashForeignDrag(pose-&gt;TargetModel())) {</a>
<a name="ln10443">			RemovePoseFromSelection(pose);</a>
<a name="ln10444">			break;</a>
<a name="ln10445">		}</a>
<a name="ln10446">	}</a>
<a name="ln10447">}</a>
<a name="ln10448"> </a>
<a name="ln10449"> </a>
<a name="ln10450">/*!	Since the start offset of the first column is part of the stored</a>
<a name="ln10451">	column state, it has to be corrected to match the current offset</a>
<a name="ln10452">	(that depends on the font size).</a>
<a name="ln10453">*/</a>
<a name="ln10454">void</a>
<a name="ln10455">BPoseView::_ResetStartOffset()</a>
<a name="ln10456">{</a>
<a name="ln10457">	if (!fColumnList-&gt;IsEmpty())</a>
<a name="ln10458">		fColumnList-&gt;ItemAt(0)-&gt;SetOffset(StartOffset());</a>
<a name="ln10459">}</a>
<a name="ln10460"> </a>
<a name="ln10461"> </a>
<a name="ln10462">//	#pragma mark - TScrollBar</a>
<a name="ln10463"> </a>
<a name="ln10464"> </a>
<a name="ln10465">TScrollBar::TScrollBar(const char* name, BView* target, float min, float max)</a>
<a name="ln10466">	:</a>
<a name="ln10467">	BScrollBar(name, target, min, max, B_HORIZONTAL),</a>
<a name="ln10468">	fTitleView(NULL)</a>
<a name="ln10469">{</a>
<a name="ln10470">}</a>
<a name="ln10471"> </a>
<a name="ln10472"> </a>
<a name="ln10473">void</a>
<a name="ln10474">TScrollBar::ValueChanged(float value)</a>
<a name="ln10475">{</a>
<a name="ln10476">	if (fTitleView) {</a>
<a name="ln10477">		BPoint origin = fTitleView-&gt;LeftTop();</a>
<a name="ln10478">		fTitleView-&gt;ScrollTo(BPoint(value, origin.y));</a>
<a name="ln10479">	}</a>
<a name="ln10480"> </a>
<a name="ln10481">	_inherited::ValueChanged(value);</a>
<a name="ln10482">}</a>
<a name="ln10483"> </a>
<a name="ln10484"> </a>
<a name="ln10485">TPoseViewFilter::TPoseViewFilter(BPoseView* pose)</a>
<a name="ln10486">	:</a>
<a name="ln10487">	BMessageFilter(B_ANY_DELIVERY, B_ANY_SOURCE),</a>
<a name="ln10488">	fPoseView(pose)</a>
<a name="ln10489">{</a>
<a name="ln10490">}</a>
<a name="ln10491"> </a>
<a name="ln10492"> </a>
<a name="ln10493">TPoseViewFilter::~TPoseViewFilter()</a>
<a name="ln10494">{</a>
<a name="ln10495">}</a>
<a name="ln10496"> </a>
<a name="ln10497"> </a>
<a name="ln10498">filter_result</a>
<a name="ln10499">TPoseViewFilter::Filter(BMessage* message, BHandler**)</a>
<a name="ln10500">{</a>
<a name="ln10501">	filter_result result = B_DISPATCH_MESSAGE;</a>
<a name="ln10502"> </a>
<a name="ln10503">	switch (message-&gt;what) {</a>
<a name="ln10504">		case B_ARCHIVED_OBJECT:</a>
<a name="ln10505">			bool handled = fPoseView-&gt;HandleMessageDropped(message);</a>
<a name="ln10506">			if (handled)</a>
<a name="ln10507">				result = B_SKIP_MESSAGE;</a>
<a name="ln10508">			break;</a>
<a name="ln10509">	}</a>
<a name="ln10510"> </a>
<a name="ln10511">	return result;</a>
<a name="ln10512">}</a>
<a name="ln10513"> </a>
<a name="ln10514"> </a>
<a name="ln10515">//	#pragma mark - static member initializations</a>
<a name="ln10516"> </a>
<a name="ln10517">float BPoseView::sFontHeight = -1;</a>
<a name="ln10518">font_height BPoseView::sFontInfo = { 0, 0, 0 };</a>
<a name="ln10519">BFont BPoseView::sCurrentFont;</a>
<a name="ln10520">OffscreenBitmap* BPoseView::sOffscreen = new OffscreenBitmap;</a>
<a name="ln10521">BString BPoseView::sMatchString = &quot;&quot;;</a>

</code></pre>
<div class="balloon" rel="8408"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ContainerWindow()' pointer was utilized before it was verified against nullptr. Check lines: 8408, 8427.</p></div>
<div class="balloon" rel="5074"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="5851"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting this expression. The expression is excessive or contains a misprint.</p></div>
<div class="balloon" rel="2729"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="8594"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="9677"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'targetPose' pointer was utilized before it was verified against nullptr. Check lines: 9677, 9683.</p></div>
<div class="balloon" rel="8577"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="4842"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized variable 'tmp' used. Consider checking the fourth actual argument of the 'WriteAttr' function.</p></div>
<div class="balloon" rel="4782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized variable 'tmp' used. Consider checking the fourth actual argument of the 'WriteAttr' function.</p></div>
<div class="balloon" rel="6222"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="6171"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="5096"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="5085"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="4861"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'poseView' pointer was utilized before it was verified against nullptr. Check lines: 4861, 4884.</p></div>
<div class="balloon" rel="6528"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="5108"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
