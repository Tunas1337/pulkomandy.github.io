
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>KeyboardLayout.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;KeyboardLayout.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;ctype.h&gt;</a>
<a name="ln10">#include &lt;stdarg.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;vector&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;File.h&gt;</a>
<a name="ln16">#include &lt;InterfaceDefs.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#undef TRACE</a>
<a name="ln20"> </a>
<a name="ln21">//#define TRACE_LAYOUT</a>
<a name="ln22">#ifdef TRACE_LAYOUT</a>
<a name="ln23">#	define TRACE(x...) printf(x)</a>
<a name="ln24">#else</a>
<a name="ln25">#	define TRACE(x...)</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">KeyboardLayout::KeyboardLayout()</a>
<a name="ln30">	:</a>
<a name="ln31">	fKeys(NULL),</a>
<a name="ln32">	fKeyCount(0),</a>
<a name="ln33">	fKeyCapacity(0),</a>
<a name="ln34">	fIndicators(5, true),</a>
<a name="ln35">	fIsDefault(true)</a>
<a name="ln36">{</a>
<a name="ln37">	SetDefault();</a>
<a name="ln38">}</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">KeyboardLayout::~KeyboardLayout()</a>
<a name="ln42">{</a>
<a name="ln43">	free(fKeys);</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46"> </a>
<a name="ln47">const char*</a>
<a name="ln48">KeyboardLayout::Name()</a>
<a name="ln49">{</a>
<a name="ln50">	return fName.String();</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">int32</a>
<a name="ln55">KeyboardLayout::CountKeys()</a>
<a name="ln56">{</a>
<a name="ln57">	return fKeyCount;</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">Key*</a>
<a name="ln62">KeyboardLayout::KeyAt(int32 index)</a>
<a name="ln63">{</a>
<a name="ln64">	if (index &lt; 0 || index &gt;= fKeyCount)</a>
<a name="ln65">		return NULL;</a>
<a name="ln66"> </a>
<a name="ln67">	return &amp;fKeys[index];</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">int32</a>
<a name="ln72">KeyboardLayout::CountIndicators()</a>
<a name="ln73">{</a>
<a name="ln74">	return fIndicators.CountItems();</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">Indicator*</a>
<a name="ln79">KeyboardLayout::IndicatorAt(int32 index)</a>
<a name="ln80">{</a>
<a name="ln81">	return fIndicators.ItemAt(index);</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84"> </a>
<a name="ln85">BRect</a>
<a name="ln86">KeyboardLayout::Bounds()</a>
<a name="ln87">{</a>
<a name="ln88">	return fBounds;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">BSize</a>
<a name="ln93">KeyboardLayout::DefaultKeySize()</a>
<a name="ln94">{</a>
<a name="ln95">	return fDefaultKeySize;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">int32</a>
<a name="ln100">KeyboardLayout::IndexForModifier(int32 modifier)</a>
<a name="ln101">{</a>
<a name="ln102">	switch (modifier) {</a>
<a name="ln103">		case B_CAPS_LOCK:</a>
<a name="ln104">			return 58;</a>
<a name="ln105">		case B_NUM_LOCK:</a>
<a name="ln106">			return 33;</a>
<a name="ln107">		case B_SCROLL_LOCK:</a>
<a name="ln108">			return 14;</a>
<a name="ln109">		case B_LEFT_SHIFT_KEY:</a>
<a name="ln110">			return 74;</a>
<a name="ln111">		case B_RIGHT_SHIFT_KEY:</a>
<a name="ln112">			return 85;</a>
<a name="ln113">		case B_LEFT_CONTROL_KEY:</a>
<a name="ln114">			return 91;</a>
<a name="ln115">		case B_RIGHT_CONTROL_KEY:</a>
<a name="ln116">			return 98;</a>
<a name="ln117">		case B_LEFT_OPTION_KEY:</a>
<a name="ln118">			return 92;</a>
<a name="ln119">		case B_RIGHT_OPTION_KEY:</a>
<a name="ln120">			return 96;</a>
<a name="ln121">		case B_LEFT_COMMAND_KEY:</a>
<a name="ln122">			return 93;</a>
<a name="ln123">		case B_RIGHT_COMMAND_KEY:</a>
<a name="ln124">			return 95;</a>
<a name="ln125">		case B_MENU_KEY:</a>
<a name="ln126">			return 97;</a>
<a name="ln127">	}</a>
<a name="ln128"> </a>
<a name="ln129">	return 0;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132"> </a>
<a name="ln133">status_t</a>
<a name="ln134">KeyboardLayout::Load(const char* path)</a>
<a name="ln135">{</a>
<a name="ln136">	entry_ref ref;</a>
<a name="ln137">	get_ref_for_path(path, &amp;ref);</a>
<a name="ln138"> </a>
<a name="ln139">	return Load(ref);</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">status_t</a>
<a name="ln144">KeyboardLayout::Load(entry_ref&amp; ref)</a>
<a name="ln145">{</a>
<a name="ln146">	BFile file;</a>
<a name="ln147">	status_t status = file.SetTo(&amp;ref, B_READ_ONLY);</a>
<a name="ln148">	if (status != B_OK)</a>
<a name="ln149">		return status;</a>
<a name="ln150"> </a>
<a name="ln151">	off_t size;</a>
<a name="ln152">	status = file.GetSize(&amp;size);</a>
<a name="ln153">	if (status != B_OK)</a>
<a name="ln154">		return status;</a>
<a name="ln155"> </a>
<a name="ln156">	if (size &gt; 65536) {</a>
<a name="ln157">		// We don't accept files larger than this</a>
<a name="ln158">		return B_BAD_VALUE;</a>
<a name="ln159">	}</a>
<a name="ln160"> </a>
<a name="ln161">	char* data = (char*)malloc(size + 1);</a>
<a name="ln162">	if (data == NULL)</a>
<a name="ln163">		return B_NO_MEMORY;</a>
<a name="ln164"> </a>
<a name="ln165">	ssize_t bytesRead = file.Read(data, size);</a>
<a name="ln166">	if (bytesRead != size) {</a>
<a name="ln167">		free(data);</a>
<a name="ln168"> </a>
<a name="ln169">		if (bytesRead &lt; 0)</a>
<a name="ln170">			return bytesRead;</a>
<a name="ln171"> </a>
<a name="ln172">		return B_IO_ERROR;</a>
<a name="ln173">	}</a>
<a name="ln174"> </a>
<a name="ln175">	data[size] = '\0';</a>
<a name="ln176"> </a>
<a name="ln177">	status = _InitFrom(data);</a>
<a name="ln178">	if (status == B_OK)</a>
<a name="ln179">		fIsDefault = false;</a>
<a name="ln180"> </a>
<a name="ln181">	free(data);</a>
<a name="ln182"> </a>
<a name="ln183">	return status;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186"> </a>
<a name="ln187">void</a>
<a name="ln188">KeyboardLayout::SetDefault()</a>
<a name="ln189">{</a>
<a name="ln190">	// The keyboard layout description language defines the position,</a>
<a name="ln191">	// size, shape, and scancodes of the keys on the keyboard, row by</a>
<a name="ln192">	// row.</a>
<a name="ln193">	// You can define variables that are substituted in the row</a>
<a name="ln194">	// descriptions. Variables are always prefixed with a '$' symbol.</a>
<a name="ln195"> </a>
<a name="ln196">	// On top level, only two different terms are accepted: value pairs,</a>
<a name="ln197">	// and row descriptions.</a>
<a name="ln198">	// Value pairs are in the form &quot;&lt;name&gt; = &lt;value&gt;&quot;. There are only two</a>
<a name="ln199">	// predefined names at this moment &quot;name&quot; that specifies the name of</a>
<a name="ln200">	// a layout, and &quot;default-size&quot; that specifies the size of keys when</a>
<a name="ln201">	// no specific size is given. Also, variables can be specified this</a>
<a name="ln202">	// way.</a>
<a name="ln203"> </a>
<a name="ln204">	// Row descriptions are embedded in the '[' and ']' brackets.</a>
<a name="ln205">	// The first term within a row is the position of the row, written as</a>
<a name="ln206">	// &quot;&lt;x&gt;,&lt;y&gt;;&quot; - the delimiter between terms/keys is usually the</a>
<a name="ln207">	// semi-colon. After the initial position, key descriptions are expected</a>
<a name="ln208">	// until the row is closed with a ']'.</a>
<a name="ln209"> </a>
<a name="ln210">	// A key description is of the form &quot;&lt;shape&gt;:&lt;scancodes&gt;&quot;, where &lt;shape&gt;</a>
<a name="ln211">	// is combined of the shape of the character, and its size, written as</a>
<a name="ln212">	// &quot;&lt;kind&gt;&lt;width&gt;,&lt;height&gt;[,&lt;second-row-width&gt;]&quot;.</a>
<a name="ln213">	// The kind can either be 'r' (the default, can also be omitted) for</a>
<a name="ln214">	// rectangular keys, or 'l' for the enter key. Additionally, you can use</a>
<a name="ln215">	// the 'd' character to mark dark keys. The size can be omitted completely,</a>
<a name="ln216">	// in which case the defined &quot;default-size&quot; is used. The default size is</a>
<a name="ln217">	// also used to determine the height of the first row of the enter key;</a>
<a name="ln218">	// the &quot;&lt;second-row-width&gt;&quot; specifier is only valid for enter keys, too.</a>
<a name="ln219"> </a>
<a name="ln220">	// The scancodes can be written in different ways:</a>
<a name="ln221">	// 1) &quot;+&lt;count&gt;&quot;: adds &lt;count&gt; keys, the scancodes will be used relative</a>
<a name="ln222">	//    to the previous keys.</a>
<a name="ln223">	// 2) &quot;&lt;first&gt;-&lt;last&gt;&quot;: keys are added for scancode &lt;first&gt; to scancode</a>
<a name="ln224">	//    &lt;last&gt;.</a>
<a name="ln225">	// 3) &quot;&lt;first&gt;+&lt;count&gt;&quot;: one key with the &lt;first&gt; scancode is added, plus</a>
<a name="ln226">	//    &lt;count&gt; ones with relative scancode from that one.</a>
<a name="ln227"> </a>
<a name="ln228">	// Finally, you can also define LED indicator. Those can be made instead</a>
<a name="ln229">	// of a key, it accepts a size, but no shape modifiers. Also, instead of</a>
<a name="ln230">	// a scancode, the name of the modifer is given, currently only the</a>
<a name="ln231">	// following are allowed: &quot;led-num&quot;, &quot;led-caps&quot;, and &quot;led-scroll&quot;.</a>
<a name="ln232"> </a>
<a name="ln233">	// See for examples in the default layout below.</a>
<a name="ln234">#if 1</a>
<a name="ln235">	static const char* kDefaultLayout105 =</a>
<a name="ln236">		&quot;name = Generic 105-key International\n&quot;</a>
<a name="ln237">		// Size shortcuts</a>
<a name="ln238">		&quot;default-size = 10,10\n&quot;</a>
<a name="ln239">		&quot;$b = 5,10\n&quot;</a>
<a name="ln240">		&quot;$c = 20,10\n&quot;</a>
<a name="ln241">		&quot;$d = 15,10\n&quot;</a>
<a name="ln242">		&quot;$e = l15,20,9\n&quot;</a>
<a name="ln243">		&quot;$f = 10,20\n&quot;</a>
<a name="ln244">		&quot;$g = 13,10\n&quot;</a>
<a name="ln245">		// Key rows</a>
<a name="ln246">		&quot;[ 0,0; d:0x01; :-; :+4; $b:-; d:+4; $b:-; :+4; $b:-; d:+3; $b:-; &quot;</a>
<a name="ln247">			&quot;$g:led-num; $g:led-caps; $g:led-scroll ]\n&quot;</a>
<a name="ln248">		&quot;[ 0,20; :+13; d$c:+; $b:-; d:+3; $b:-; d:+4 ]\n&quot;</a>
<a name="ln249">		&quot;[ 0,30; d$d:0x26; :+12; d$e:0x47; $b:-; d:0x34-0x36; $b:-; :+3; &quot;</a>
<a name="ln250">			&quot;d$f:+1 ]\n&quot;</a>
<a name="ln251">		&quot;[ 0,40; d19,10:0x3b; :+11; :0x33; 51,10:-; :0x48-0x4a ]\n&quot;</a>
<a name="ln252">		&quot;[ 0,50; d$g:0x4b; :0x69; :0x4c+9; d27,10:+1; 15,10:-; d:+1; &quot;</a>
<a name="ln253">		&quot;	15,10:-; :+3; d$f:+1 ]\n&quot;</a>
<a name="ln254">		&quot;[ 0,60; d$g:0x5c; d$g:0x66; d$g:0x5d; 59,10:+1; d$g:+1; d$g:0x67+1; &quot;</a>
<a name="ln255">			&quot;d$g:0x60; $b:-; d:+3; $b:-; $c:+1; :+1 ]\n&quot;;</a>
<a name="ln256"> </a>
<a name="ln257">	_InitFrom(kDefaultLayout105);</a>
<a name="ln258">#endif</a>
<a name="ln259">#if 0</a>
<a name="ln260">	static const char* kDefaultLayout104 = &quot;name = Generic 104-key\n&quot;</a>
<a name="ln261">		// Size shortcuts</a>
<a name="ln262">		&quot;default-size = 10,10\n&quot;</a>
<a name="ln263">		&quot;$b = 5,10\n&quot;</a>
<a name="ln264">		&quot;$c = 20,10\n&quot;</a>
<a name="ln265">		&quot;$d = 15,10\n&quot;</a>
<a name="ln266">		&quot;$enter = d20,10\n&quot;</a>
<a name="ln267">		&quot;$f = 10,20\n&quot;</a>
<a name="ln268">		&quot;$g = 13,10\n&quot;</a>
<a name="ln269">		// Key rows</a>
<a name="ln270">		&quot;[ 0,0; d:0x01; :-; :+4; $b:-; d:+4; $b:-; :+4; $b:-; d:+3; $b:-; &quot;</a>
<a name="ln271">			&quot;$g:led-num; $g:led-caps; $g:led-scroll ]\n&quot;</a>
<a name="ln272">		&quot;[ 0,20; :+13; d$c:+; $b:-; d:+3; $b:-; d:+4 ]\n&quot;</a>
<a name="ln273">		&quot;[ 0,30; d$d:0x26; :+12; $d:+1; $b:-; d:+3; $b:-; :+3; &quot;</a>
<a name="ln274">			&quot;d$f:+1 ]\n&quot;</a>
<a name="ln275">		&quot;[ 0,40; d$c:0x3b; :+11; $enter:+1; 40,10:-; :+3 ]\n&quot;</a>
<a name="ln276">		&quot;[ 0,50; d24,10:0x4b; :+10; d26,10:+1; 15,10:-; d:+1; &quot;</a>
<a name="ln277">		&quot;	15,10:-; :+3; d$f:+1 ]\n&quot;</a>
<a name="ln278">		&quot;[ 0,60; d$g:0x5c; d$g:0x66; d$g:0x5d; 59,10:+1; d$g:+1; d$g:0x67+1; &quot;</a>
<a name="ln279">			&quot;d$g:0x60; $b:-; d:+3; $b:-; $c:+1; :+1 ]\n&quot;;</a>
<a name="ln280"> </a>
<a name="ln281">	_InitFrom(kDefaultLayout104);</a>
<a name="ln282">#endif</a>
<a name="ln283">#if 0</a>
<a name="ln284">	static const char* kIBMLaptop = &quot;name = IBM Laptop International\n&quot;</a>
<a name="ln285">		// Size shortcuts</a>
<a name="ln286">		&quot;default-size = 18,18\n&quot;</a>
<a name="ln287">		&quot;$s = 17,10\n&quot;</a>
<a name="ln288">		&quot;$gap = 6,10\n&quot;</a>
<a name="ln289">		&quot;$sgap = 5,10\n&quot;</a>
<a name="ln290">		&quot;$backspace = 38,18\n&quot;</a>
<a name="ln291">		&quot;$tab = 28,18\n&quot;</a>
<a name="ln292">		&quot;$caps = 32,18\n&quot;</a>
<a name="ln293">		&quot;$enter = l28,36,22\n&quot;</a>
<a name="ln294">		&quot;$l-shift-ctrl = 23,18\n&quot;</a>
<a name="ln295">		&quot;$r-shift = 51,18\n&quot;</a>
<a name="ln296">		&quot;$option = 13,18\n&quot;</a>
<a name="ln297">		&quot;$space = 95,18\n&quot;</a>
<a name="ln298">		// Key rows</a>
<a name="ln299">		&quot;[ 0,0; $s:0x01; 148,10:-; $s:0x0e+2; $sgap:-; $s:0x1f+2; ]\n&quot;</a>
<a name="ln300">		&quot;[ 0,10; $s:0x02+3; $gap:-; $s:+4; $gap:-; $s:+4; $sgap:-; &quot;</a>
<a name="ln301">			&quot;$s:0x34+2; ]\n&quot;</a>
<a name="ln302">		&quot;[ 0,20; :0x11+12; $backspace:+1 ]\n&quot;</a>
<a name="ln303">		&quot;[ 0,38; $tab:0x26; :+12; $enter:0x47; ]\n&quot;</a>
<a name="ln304">		&quot;[ 0,56; $caps:0x3b; :+11; :0x33 ]\n&quot;</a>
<a name="ln305">		&quot;[ 0,74; $l-shift-ctrl:0x4b; :0x69; :0x4c+9; $r-shift:+1 ]\n&quot;</a>
<a name="ln306">		&quot;[ 0,92; :0x99; $l-shift-ctrl:0x5c; $option:0x66; :0x5d; $space:+1; &quot;</a>
<a name="ln307">			&quot;:+1; :0x68; :0x60; $s:0x9a; $s:0x57; $s:0x9b ]\n&quot;</a>
<a name="ln308">		&quot;[ 221,102; $s:0x61+2; ]\n&quot;;</a>
<a name="ln309"> </a>
<a name="ln310">	_InitFrom(kIBMLaptop);</a>
<a name="ln311">#endif</a>
<a name="ln312">	fIsDefault = true;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">void</a>
<a name="ln317">KeyboardLayout::_FreeKeys()</a>
<a name="ln318">{</a>
<a name="ln319">	free(fKeys);</a>
<a name="ln320">	fKeys = NULL;</a>
<a name="ln321">	fKeyCount = 0;</a>
<a name="ln322">	fKeyCapacity = 0;</a>
<a name="ln323">	fBounds = BRect();</a>
<a name="ln324"> </a>
<a name="ln325">	fIndicators.MakeEmpty();</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328"> </a>
<a name="ln329">void</a>
<a name="ln330">KeyboardLayout::_Error(const parse_state&amp; state, const char* reason, ...)</a>
<a name="ln331">{</a>
<a name="ln332">	va_list args;</a>
<a name="ln333">	va_start(args, reason);</a>
<a name="ln334"> </a>
<a name="ln335">	fprintf(stderr, &quot;Syntax error in line %&quot; B_PRId32 &quot;: &quot;, state.line);</a>
<a name="ln336">	vfprintf(stderr, reason, args);</a>
<a name="ln337">	fprintf(stderr, &quot;\n&quot;);</a>
<a name="ln338"> </a>
<a name="ln339">	va_end(args);</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342"> </a>
<a name="ln343">void</a>
<a name="ln344">KeyboardLayout::_AddAlternateKeyCode(Key* key, int32 modifier, int32 code)</a>
<a name="ln345">{</a>
<a name="ln346">	if (key == NULL)</a>
<a name="ln347">		return;</a>
<a name="ln348"> </a>
<a name="ln349">	// TODO: search for free spot</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352"> </a>
<a name="ln353">bool</a>
<a name="ln354">KeyboardLayout::_AddKey(const Key&amp; key)</a>
<a name="ln355">{</a>
<a name="ln356">	TRACE(&quot;    add %ld (%g,%g)\n&quot;, key.code, key.frame.left, key.frame.top);</a>
<a name="ln357">	if (fKeyCount + 1 &gt; fKeyCapacity) {</a>
<a name="ln358">		// enlarge array</a>
<a name="ln359">		int32 newCapacity = fKeyCapacity + 32;</a>
<a name="ln360">		Key* newKeys = (Key*)realloc((void*)fKeys, newCapacity * sizeof(Key));</a>
<a name="ln361">		if (newKeys == NULL)</a>
<a name="ln362">			return false;</a>
<a name="ln363"> </a>
<a name="ln364">		fKeys = newKeys;</a>
<a name="ln365">		fKeyCapacity = newCapacity;</a>
<a name="ln366">	}</a>
<a name="ln367"> </a>
<a name="ln368">	fKeys[fKeyCount] = key;</a>
<a name="ln369">	fKeyCount++;</a>
<a name="ln370"> </a>
<a name="ln371">	fBounds = key.frame | fBounds;</a>
<a name="ln372"> </a>
<a name="ln373">	return true;</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376"> </a>
<a name="ln377">void</a>
<a name="ln378">KeyboardLayout::_SkipCommentsAndSpace(parse_state&amp; state, const char*&amp; data)</a>
<a name="ln379">{</a>
<a name="ln380">	while (data[0] != '\0') {</a>
<a name="ln381">		while (isspace(data[0])) {</a>
<a name="ln382">			if (data[0] == '\n')</a>
<a name="ln383">				state.line++;</a>
<a name="ln384">			data++;</a>
<a name="ln385">		}</a>
<a name="ln386"> </a>
<a name="ln387">		if (data[0] == '#') {</a>
<a name="ln388">			// skip comment</a>
<a name="ln389">			while (data[0] != '\0' &amp;&amp; data[0] != '\n') {</a>
<a name="ln390">				data++;</a>
<a name="ln391">			}</a>
<a name="ln392">		} else</a>
<a name="ln393">			break;</a>
<a name="ln394">	}</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397"> </a>
<a name="ln398">void</a>
<a name="ln399">KeyboardLayout::_Trim(BString&amp; string, bool stripComments)</a>
<a name="ln400">{</a>
<a name="ln401">	// Strip leading spaces</a>
<a name="ln402">	int32 i = 0;</a>
<a name="ln403">	while (isspace(string[i])) {</a>
<a name="ln404">		i++;</a>
<a name="ln405">	}</a>
<a name="ln406">	if (i &gt; 0)</a>
<a name="ln407">		string.Remove(0, i);</a>
<a name="ln408"> </a>
<a name="ln409">	// Remove comments</a>
<a name="ln410">	if (stripComments) {</a>
<a name="ln411">		i = string.FindFirst('#');</a>
<a name="ln412">		if (i &gt;= 0)</a>
<a name="ln413">			string.Truncate(i);</a>
<a name="ln414">	}</a>
<a name="ln415"> </a>
<a name="ln416">	// Strip trailing spaces</a>
<a name="ln417">	i = string.Length() - 1;</a>
<a name="ln418">	while (i &gt; 0 &amp;&amp; isspace(string[i])) {</a>
<a name="ln419">		i--;</a>
<a name="ln420">	}</a>
<a name="ln421">	string.Truncate(i + 1);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425">bool</a>
<a name="ln426">KeyboardLayout::_GetPair(const parse_state&amp; state, const char*&amp; data,</a>
<a name="ln427">	BString&amp; name, BString&amp; value)</a>
<a name="ln428">{</a>
<a name="ln429">	// Get name</a>
<a name="ln430">	name = &quot;&quot;;</a>
<a name="ln431">	while (data[0] != '\0' &amp;&amp; data[0] != '=') {</a>
<a name="ln432">		name += data[0];</a>
<a name="ln433">		data++;</a>
<a name="ln434">	}</a>
<a name="ln435"> </a>
<a name="ln436">	if (data[0] != '=') {</a>
<a name="ln437">		_Error(state, &quot;no valid pair&quot;);</a>
<a name="ln438">		return false;</a>
<a name="ln439">	}</a>
<a name="ln440"> </a>
<a name="ln441">	// Skip sign</a>
<a name="ln442">	data++;</a>
<a name="ln443"> </a>
<a name="ln444">	// Get value</a>
<a name="ln445">	value = &quot;&quot;;</a>
<a name="ln446">	while (data[0] != '\0' &amp;&amp; data[0] != '\n') {</a>
<a name="ln447">		value += data[0];</a>
<a name="ln448">		data++;</a>
<a name="ln449">	}</a>
<a name="ln450"> </a>
<a name="ln451">	_Trim(name, false);</a>
<a name="ln452">	_Trim(value, true);</a>
<a name="ln453"> </a>
<a name="ln454">	return true;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458">bool</a>
<a name="ln459">KeyboardLayout::_AddKeyCodes(const parse_state&amp; state, BPoint&amp; rowLeftTop,</a>
<a name="ln460">	Key&amp; key, const char* data, int32&amp; lastCount)</a>
<a name="ln461">{</a>
<a name="ln462">	if (data[0] == '-') {</a>
<a name="ln463">		// no key, just free space</a>
<a name="ln464">		int32 num = strtoul(data + 1, NULL, 0);</a>
<a name="ln465">		if (num &lt; 1)</a>
<a name="ln466">			num = 1;</a>
<a name="ln467">		else if (num &gt; 32) {</a>
<a name="ln468">			_Error(state, &quot;empty key count too large&quot;);</a>
<a name="ln469">			return false;</a>
<a name="ln470">		}</a>
<a name="ln471"> </a>
<a name="ln472">		key.frame.OffsetTo(rowLeftTop);</a>
<a name="ln473">		rowLeftTop.x = key.frame.left + key.frame.Width() * num;</a>
<a name="ln474">		return true;</a>
<a name="ln475">	}</a>
<a name="ln476"> </a>
<a name="ln477">	int32 modifier = 0;</a>
<a name="ln478"> </a>
<a name="ln479">	if (isalpha(data[0])) {</a>
<a name="ln480">		bool led = false;</a>
<a name="ln481">		if (!strcmp(&quot;led-caps&quot;, data)) {</a>
<a name="ln482">			modifier = B_CAPS_LOCK;</a>
<a name="ln483">			led = true;</a>
<a name="ln484">		} else if (!strcmp(&quot;led-num&quot;, data)) {</a>
<a name="ln485">			modifier = B_NUM_LOCK;</a>
<a name="ln486">			led = true;</a>
<a name="ln487">		} else if (!strcmp(&quot;led-scroll&quot;, data)) {</a>
<a name="ln488">			modifier = B_SCROLL_LOCK;</a>
<a name="ln489">			led = true;</a>
<a name="ln490">		} else {</a>
<a name="ln491">			// TODO: get modifier (ie. &quot;num&quot;)</a>
<a name="ln492">		}</a>
<a name="ln493"> </a>
<a name="ln494">		if (led) {</a>
<a name="ln495">			key.frame.OffsetTo(rowLeftTop);</a>
<a name="ln496">			rowLeftTop.x = key.frame.right;</a>
<a name="ln497">			fBounds = key.frame | fBounds;</a>
<a name="ln498"> </a>
<a name="ln499">			Indicator* indicator = new(std::nothrow) Indicator;</a>
<a name="ln500">			if (indicator != NULL) {</a>
<a name="ln501">				indicator-&gt;modifier = modifier;</a>
<a name="ln502">				indicator-&gt;frame = key.frame;</a>
<a name="ln503"> </a>
<a name="ln504">				fIndicators.AddItem(indicator);</a>
<a name="ln505">			}</a>
<a name="ln506">			return true;</a>
<a name="ln507">		}</a>
<a name="ln508">	}</a>
<a name="ln509"> </a>
<a name="ln510">	int32 first;</a>
<a name="ln511">	int32 last;</a>
<a name="ln512">	int32 num = 1;</a>
<a name="ln513"> </a>
<a name="ln514">	if (data[0] == '+') {</a>
<a name="ln515">		num = strtoul(data + 1, NULL, 0);</a>
<a name="ln516">		if (num &lt; 1)</a>
<a name="ln517">			num = 1;</a>
<a name="ln518">		else if (num &gt; 32) {</a>
<a name="ln519">			_Error(state, &quot;key count too large&quot;);</a>
<a name="ln520">			return false;</a>
<a name="ln521">		}</a>
<a name="ln522"> </a>
<a name="ln523">		if (fKeyCount &gt; 0)</a>
<a name="ln524">			first = fKeys[fKeyCount - 1].code + 1;</a>
<a name="ln525">		else</a>
<a name="ln526">			first = 1;</a>
<a name="ln527"> </a>
<a name="ln528">		last = first + num - 1;</a>
<a name="ln529">	} else {</a>
<a name="ln530">		char* end;</a>
<a name="ln531">		first = strtoul(data, &amp;end, 0);</a>
<a name="ln532">		last = first;</a>
<a name="ln533"> </a>
<a name="ln534">		if (end[0] == '-') {</a>
<a name="ln535">			last = strtoul(end + 1, NULL, 0);</a>
<a name="ln536">			if (first &gt; last) {</a>
<a name="ln537">				_Error(state, &quot;invalid key code specifier&quot;);</a>
<a name="ln538">				return false;</a>
<a name="ln539">			}</a>
<a name="ln540"> </a>
<a name="ln541">			num = last - first;</a>
<a name="ln542">		} else if (end[0] == '+') {</a>
<a name="ln543">			num = strtoul(end + 1, NULL, 0) + 1;</a>
<a name="ln544">			last = first + num - 1;</a>
<a name="ln545">		} else if (end[0] != '\0') {</a>
<a name="ln546">			_Error(state, &quot;invalid key range&quot;);</a>
<a name="ln547">			return false;</a>
<a name="ln548">		}</a>
<a name="ln549">	}</a>
<a name="ln550"> </a>
<a name="ln551">	if (lastCount != 0) {</a>
<a name="ln552">		// update existing keys</a>
<a name="ln553">		if (lastCount != num) {</a>
<a name="ln554">			_Error(state, &quot;modifier key mismatch&quot;);</a>
<a name="ln555">			return false;</a>
<a name="ln556">		}</a>
<a name="ln557"> </a>
<a name="ln558">		for (int32 i = fKeyCount - num; i &lt; fKeyCount; i++, first++) {</a>
<a name="ln559">			Key* key = KeyAt(i);</a>
<a name="ln560"> </a>
<a name="ln561">			_AddAlternateKeyCode(key, modifier, first);</a>
<a name="ln562">		}</a>
<a name="ln563">	} else {</a>
<a name="ln564">		// add new keys</a>
<a name="ln565">		for (int32 i = first; i &lt;= last; i++) {</a>
<a name="ln566">			key.code = i;</a>
<a name="ln567"> </a>
<a name="ln568">			// &quot;layout&quot;</a>
<a name="ln569">			key.frame.OffsetTo(rowLeftTop);</a>
<a name="ln570">			rowLeftTop.x = key.frame.right;</a>
<a name="ln571"> </a>
<a name="ln572">			_AddKey(key);</a>
<a name="ln573">		}</a>
<a name="ln574"> </a>
<a name="ln575">		lastCount = num;</a>
<a name="ln576">	}</a>
<a name="ln577"> </a>
<a name="ln578">	return true;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">bool</a>
<a name="ln583">KeyboardLayout::_GetSize(const parse_state&amp; state, const char* data,</a>
<a name="ln584">	float&amp; x, float&amp; y, float* _secondRow)</a>
<a name="ln585">{</a>
<a name="ln586">	if (data[0] == '\0') {</a>
<a name="ln587">		// default size</a>
<a name="ln588">		x = fDefaultKeySize.width;</a>
<a name="ln589">		y = fDefaultKeySize.height;</a>
<a name="ln590">		return true;</a>
<a name="ln591">	}</a>
<a name="ln592"> </a>
<a name="ln593">	float secondRow = 0;</a>
<a name="ln594">	int num = sscanf(data, &quot;%g,%g,%g&quot;, &amp;x, &amp;y, &amp;secondRow);</a>
<a name="ln595">	if (num &lt; 2) {</a>
<a name="ln596">		_Error(state, &quot;invalid size&quot;);</a>
<a name="ln597">		return false;</a>
<a name="ln598">	}</a>
<a name="ln599"> </a>
<a name="ln600">	if (_secondRow != NULL)</a>
<a name="ln601">		*_secondRow = secondRow;</a>
<a name="ln602">	return true;</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606">bool</a>
<a name="ln607">KeyboardLayout::_GetShape(const parse_state&amp; state, const char* data, Key&amp; key)</a>
<a name="ln608">{</a>
<a name="ln609">	// the default</a>
<a name="ln610">	key.shape = kRectangleKeyShape;</a>
<a name="ln611">	key.dark = false;</a>
<a name="ln612"> </a>
<a name="ln613">	while (isalpha(data[0])) {</a>
<a name="ln614">		switch (tolower(data[0])) {</a>
<a name="ln615">			case 'r':</a>
<a name="ln616">				key.shape = kRectangleKeyShape;</a>
<a name="ln617">				break;</a>
<a name="ln618">			case 'c':</a>
<a name="ln619">				key.shape = kCircleKeyShape;</a>
<a name="ln620">				break;</a>
<a name="ln621">			case 'l':</a>
<a name="ln622">				key.shape = kEnterKeyShape;</a>
<a name="ln623">				break;</a>
<a name="ln624">			case 'd':</a>
<a name="ln625">				key.dark = true;</a>
<a name="ln626">				break;</a>
<a name="ln627"> </a>
<a name="ln628">			default:</a>
<a name="ln629">				_Error(state, &quot;unknown shape specifier '%c'&quot;, data[0]);</a>
<a name="ln630">				return false;</a>
<a name="ln631">		}</a>
<a name="ln632"> </a>
<a name="ln633">		data++;</a>
<a name="ln634">	}</a>
<a name="ln635"> </a>
<a name="ln636">	float width, height;</a>
<a name="ln637">	if (!_GetSize(state, data, width, height, &amp;key.second_row))</a>
<a name="ln638">		return false;</a>
<a name="ln639"> </a>
<a name="ln640">	// don't accept second row with anything but kEnterKeyShape</a>
<a name="ln641">	if ((key.shape != kEnterKeyShape &amp;&amp; key.second_row != 0)</a>
<a name="ln642">		|| (key.shape == kEnterKeyShape &amp;&amp; key.second_row == 0)) {</a>
<a name="ln643">		_Error(state, &quot;shape size mismatch&quot;);</a>
<a name="ln644">		return false;</a>
<a name="ln645">	}</a>
<a name="ln646"> </a>
<a name="ln647">	key.frame.left = 0;</a>
<a name="ln648">	key.frame.top = 0;</a>
<a name="ln649">	key.frame.right = width;</a>
<a name="ln650">	key.frame.bottom = height;</a>
<a name="ln651"> </a>
<a name="ln652">	return true;</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655"> </a>
<a name="ln656">/*!	Returns the term delimiter expected in a certain parse mode. */</a>
<a name="ln657">const char*</a>
<a name="ln658">KeyboardLayout::_Delimiter(parse_mode mode)</a>
<a name="ln659">{</a>
<a name="ln660">	switch (mode) {</a>
<a name="ln661">		default:</a>
<a name="ln662">		case kSize:</a>
<a name="ln663">			return &quot;&quot;;</a>
<a name="ln664">		case kRowStart:</a>
<a name="ln665">			return &quot;;&quot;;</a>
<a name="ln666"> </a>
<a name="ln667">		case kKeyShape:</a>
<a name="ln668">			return &quot;:&quot;;</a>
<a name="ln669">		case kKeyCodes:</a>
<a name="ln670">			return &quot;;:&quot;;</a>
<a name="ln671">	}</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">bool</a>
<a name="ln676">KeyboardLayout::_GetTerm(const char*&amp; data, const char* delimiter,</a>
<a name="ln677">	BString&amp; term, bool closingBracketAllowed)</a>
<a name="ln678">{</a>
<a name="ln679">	// Get term</a>
<a name="ln680">	term = &quot;&quot;;</a>
<a name="ln681">	while (data[0] != '\0' &amp;&amp; strchr(delimiter, data[0]) == NULL</a>
<a name="ln682">		&amp;&amp; data[0] != '\n' &amp;&amp; data[0] != '#'</a>
<a name="ln683">		&amp;&amp; (!closingBracketAllowed || data[0] != ']')) {</a>
<a name="ln684">		term += data[0];</a>
<a name="ln685">		data++;</a>
<a name="ln686">	}</a>
<a name="ln687"> </a>
<a name="ln688">	if (data[0] == '\0' &amp;&amp; delimiter[0])</a>
<a name="ln689">		return false;</a>
<a name="ln690"> </a>
<a name="ln691">	_Trim(term, true);</a>
<a name="ln692">	return true;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">bool</a>
<a name="ln697">KeyboardLayout::_SubstituteVariables(BString&amp; term, VariableMap&amp; variables,</a>
<a name="ln698">	BString&amp; unknown)</a>
<a name="ln699">{</a>
<a name="ln700">	while (true) {</a>
<a name="ln701">		int32 index = term.FindFirst('$');</a>
<a name="ln702">		if (index &lt; 0)</a>
<a name="ln703">			break;</a>
<a name="ln704"> </a>
<a name="ln705">		// find variable name</a>
<a name="ln706"> </a>
<a name="ln707">		VariableMap::iterator iterator = variables.begin();</a>
<a name="ln708">		VariableMap::iterator best = variables.end();</a>
<a name="ln709">		int32 bestLength = 0;</a>
<a name="ln710"> </a>
<a name="ln711">		for (; iterator != variables.end(); iterator++) {</a>
<a name="ln712">			const BString&amp; name = iterator-&gt;first;</a>
<a name="ln713">			if (!term.CompareAt(index, name, name.Length())</a>
<a name="ln714">				&amp;&amp; name.Length() &gt; bestLength) {</a>
<a name="ln715">				best = iterator;</a>
<a name="ln716">				bestLength = name.Length();</a>
<a name="ln717">			}</a>
<a name="ln718">		}</a>
<a name="ln719"> </a>
<a name="ln720">		if (best != variables.end()) {</a>
<a name="ln721">			// got one, replace it</a>
<a name="ln722">			term.Remove(index, bestLength);</a>
<a name="ln723">			term.Insert(best-&gt;second.String(), index);</a>
<a name="ln724">		} else {</a>
<a name="ln725">			// variable has not been found</a>
<a name="ln726">			int32 length = 1;</a>
<a name="ln727">			while (isalpha(term[length + index])) {</a>
<a name="ln728">				length++;</a>
<a name="ln729">			}</a>
<a name="ln730">			term.Truncate(length + index);</a>
<a name="ln731">			return false;</a>
<a name="ln732">		}</a>
<a name="ln733">	}</a>
<a name="ln734"> </a>
<a name="ln735">	return true;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">bool</a>
<a name="ln740">KeyboardLayout::_ParseTerm(const parse_state&amp; state, const char*&amp; data,</a>
<a name="ln741">	BString&amp; term, VariableMap&amp; variables)</a>
<a name="ln742">{</a>
<a name="ln743">	if (!_GetTerm(data, _Delimiter(state.mode), term,</a>
<a name="ln744">			state.mode == kKeyCodes)) {</a>
<a name="ln745">		_Error(state, state.mode == kRowStart</a>
<a name="ln746">			? &quot;no valid row start&quot; : &quot;invalid term&quot;);</a>
<a name="ln747">		return false;</a>
<a name="ln748">	}</a>
<a name="ln749"> </a>
<a name="ln750">	BString unknown;</a>
<a name="ln751">	if (!_SubstituteVariables(term, variables, unknown)) {</a>
<a name="ln752">		_Error(state, &quot;Unknown variable \&quot;%s\&quot;&quot;, unknown.String());</a>
<a name="ln753">		return false;</a>
<a name="ln754">	}</a>
<a name="ln755"> </a>
<a name="ln756">	return true;</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759"> </a>
<a name="ln760">/*!	Initializes the keyboard layout from the data given.</a>
<a name="ln761">	The string has to be a valid keyboard layout description, otherwise</a>
<a name="ln762">	an error is returned.</a>
<a name="ln763">*/</a>
<a name="ln764">status_t</a>
<a name="ln765">KeyboardLayout::_InitFrom(const char* data)</a>
<a name="ln766">{</a>
<a name="ln767">	_FreeKeys();</a>
<a name="ln768"> </a>
<a name="ln769">	VariableMap variables;</a>
<a name="ln770">	BPoint rowLeftTop;</a>
<a name="ln771">	int32 lastKeyCount = 0;</a>
<a name="ln772">	Key key;</a>
<a name="ln773"> </a>
<a name="ln774">	parse_state state = {kPairs, 1};</a>
<a name="ln775"> </a>
<a name="ln776">	while (data[0] != '\0') {</a>
<a name="ln777">		_SkipCommentsAndSpace(state, data);</a>
<a name="ln778"> </a>
<a name="ln779">		if (data[0] == '[') {</a>
<a name="ln780">			state.mode = kRowStart;</a>
<a name="ln781"> </a>
<a name="ln782">			rowLeftTop = BPoint(0, 0);</a>
<a name="ln783">			data++;</a>
<a name="ln784">			continue;</a>
<a name="ln785">		} else if (data[0] == '\0')</a>
<a name="ln786">			break;</a>
<a name="ln787"> </a>
<a name="ln788">		switch (state.mode) {</a>
<a name="ln789">			case kPairs:</a>
<a name="ln790">			{</a>
<a name="ln791">				BString name;</a>
<a name="ln792">				BString value;</a>
<a name="ln793">				if (!_GetPair(state, data, name, value))</a>
<a name="ln794">					return B_BAD_VALUE;</a>
<a name="ln795"> </a>
<a name="ln796">				TRACE(&quot;&lt;%s&gt; = &lt;%s&gt;\n&quot;, name.String(), value.String());</a>
<a name="ln797">				if (name == &quot;name&quot;)</a>
<a name="ln798">					fName = value;</a>
<a name="ln799">				else if (name == &quot;default-size&quot;) {</a>
<a name="ln800">					const char* valueString = value.String();</a>
<a name="ln801">					parse_state tempState = {kSize, state.line};</a>
<a name="ln802">					BString term;</a>
<a name="ln803">					if (!_ParseTerm(tempState, valueString, term, variables))</a>
<a name="ln804">						return B_BAD_VALUE;</a>
<a name="ln805"> </a>
<a name="ln806">					TRACE(&quot;  size = %s\n&quot;, term.String());</a>
<a name="ln807">					if (!_GetSize(state, term.String(), fDefaultKeySize.width,</a>
<a name="ln808">							fDefaultKeySize.height))</a>
<a name="ln809">						return B_BAD_VALUE;</a>
<a name="ln810">				} else if (name[0] == '$')</a>
<a name="ln811">					variables[name] = value;</a>
<a name="ln812">				break;</a>
<a name="ln813">			}</a>
<a name="ln814"> </a>
<a name="ln815">			case kRowStart:</a>
<a name="ln816">			case kKeyShape:</a>
<a name="ln817">			case kKeyCodes:</a>
<a name="ln818">			{</a>
<a name="ln819">				if (data[0] == ']') {</a>
<a name="ln820">					if (state.mode == kKeyShape) {</a>
<a name="ln821">						state.mode = kPairs;</a>
<a name="ln822">						data++;</a>
<a name="ln823">						continue;</a>
<a name="ln824">					}</a>
<a name="ln825">					_Error(state, &quot;unexpected row closing bracket&quot;);</a>
<a name="ln826">					return B_BAD_VALUE;</a>
<a name="ln827">				}</a>
<a name="ln828"> </a>
<a name="ln829">				BString term;</a>
<a name="ln830">				if (!_ParseTerm(state, data, term, variables))</a>
<a name="ln831">					return B_BAD_VALUE;</a>
<a name="ln832"> </a>
<a name="ln833">				switch (state.mode) {</a>
<a name="ln834">					case kRowStart:</a>
<a name="ln835">						if (!_GetSize(state, term.String(), rowLeftTop.x,</a>
<a name="ln836">								rowLeftTop.y))</a>
<a name="ln837">							return B_BAD_VALUE;</a>
<a name="ln838"> </a>
<a name="ln839">						TRACE(&quot;row: %s (%g:%g)\n&quot;, term.String(), rowLeftTop.x,</a>
<a name="ln840">							rowLeftTop.y);</a>
<a name="ln841"> </a>
<a name="ln842">						state.mode = kKeyShape;</a>
<a name="ln843">						break;</a>
<a name="ln844">					case kKeyShape:</a>
<a name="ln845">						memset((void*)&amp;key, 0, sizeof(Key));</a>
<a name="ln846">						if (!_GetShape(state, term.String(), key))</a>
<a name="ln847">							return B_BAD_VALUE;</a>
<a name="ln848"> </a>
<a name="ln849">						TRACE(&quot;  shape: %s (%g:%g:%g)\n&quot;, term.String(),</a>
<a name="ln850">							key.frame.Width(), key.frame.Height(),</a>
<a name="ln851">							key.second_row);</a>
<a name="ln852"> </a>
<a name="ln853">						lastKeyCount = 0;</a>
<a name="ln854">						state.mode = kKeyCodes;</a>
<a name="ln855">						break;</a>
<a name="ln856">					case kKeyCodes:</a>
<a name="ln857">						TRACE(&quot;   raw key: %s\n&quot;, term.String());</a>
<a name="ln858"> </a>
<a name="ln859">						if (!_AddKeyCodes(state, rowLeftTop, key, term.String(),</a>
<a name="ln860">								lastKeyCount))</a>
<a name="ln861">							return B_BAD_VALUE;</a>
<a name="ln862"> </a>
<a name="ln863">						if (data[0] != ':')</a>
<a name="ln864">							state.mode = kKeyShape;</a>
<a name="ln865">						break;</a>
<a name="ln866"> </a>
<a name="ln867">					default:</a>
<a name="ln868">						break;</a>
<a name="ln869">				}</a>
<a name="ln870">				if (data[0] != ']' &amp;&amp; data[0] != '\0')</a>
<a name="ln871">					data++;</a>
<a name="ln872">				break;</a>
<a name="ln873">			}</a>
<a name="ln874"> </a>
<a name="ln875">			default:</a>
<a name="ln876">				return B_BAD_VALUE;</a>
<a name="ln877">		}</a>
<a name="ln878">	}</a>
<a name="ln879"> </a>
<a name="ln880">	return B_OK;</a>
<a name="ln881">}</a>
<a name="ln882"> </a>

</code></pre>
<div class="balloon" rel="360"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'realloc' function is used to allocate memory for an array of objects which are classes containing constructors.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
