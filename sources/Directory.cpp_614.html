
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Directory.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//----------------------------------------------------------------------</a>
<a name="ln2">//  This software is part of the OpenBeOS distribution and is covered </a>
<a name="ln3">//  by the MIT License.</a>
<a name="ln4">//---------------------------------------------------------------------</a>
<a name="ln5">/*!</a>
<a name="ln6">	\file Directory.cpp</a>
<a name="ln7">	BDirectory implementation.	</a>
<a name="ln8">*/</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;fcntl.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;Directory.h&gt;</a>
<a name="ln14">#include &lt;Entry.h&gt;</a>
<a name="ln15">#include &lt;File.h&gt;</a>
<a name="ln16">#include &lt;fs_info.h&gt;</a>
<a name="ln17">#include &lt;Path.h&gt;</a>
<a name="ln18">#include &lt;SymLink.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;syscalls.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;storage_support.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24">#ifdef USE_OPENBEOS_NAMESPACE</a>
<a name="ln25">namespace OpenBeOS {</a>
<a name="ln26">#endif</a>
<a name="ln27"> </a>
<a name="ln28">// constructor</a>
<a name="ln29">//! Creates an uninitialized BDirectory object.</a>
<a name="ln30">BDirectory::BDirectory()</a>
<a name="ln31">		  : BNode(),</a>
<a name="ln32">			BEntryList(),</a>
<a name="ln33">			fDirFd(-1)</a>
<a name="ln34">{</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">// copy constructor</a>
<a name="ln38">//! Creates a copy of the supplied BDirectory.</a>
<a name="ln39">/*!	\param dir the BDirectory object to be copied</a>
<a name="ln40">*/</a>
<a name="ln41">BDirectory::BDirectory(const BDirectory &amp;dir)</a>
<a name="ln42">		  : BNode(),</a>
<a name="ln43">			BEntryList(),</a>
<a name="ln44">			fDirFd(-1)</a>
<a name="ln45">{</a>
<a name="ln46">	*this = dir;</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">// constructor</a>
<a name="ln50">/*! \brief Creates a BDirectory and initializes it to the directory referred</a>
<a name="ln51">	to by the supplied entry_ref.</a>
<a name="ln52">	\param ref the entry_ref referring to the directory</a>
<a name="ln53">*/</a>
<a name="ln54">BDirectory::BDirectory(const entry_ref *ref)</a>
<a name="ln55">		  : BNode(),</a>
<a name="ln56">			BEntryList(),</a>
<a name="ln57">			fDirFd(-1)</a>
<a name="ln58">{</a>
<a name="ln59">	SetTo(ref);</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">// constructor</a>
<a name="ln63">/*! \brief Creates a BDirectory and initializes it to the directory referred</a>
<a name="ln64">	to by the supplied node_ref.</a>
<a name="ln65">	\param nref the node_ref referring to the directory</a>
<a name="ln66">*/</a>
<a name="ln67">BDirectory::BDirectory(const node_ref *nref)</a>
<a name="ln68">		  : BNode(),</a>
<a name="ln69">			BEntryList(),</a>
<a name="ln70">			fDirFd(-1)</a>
<a name="ln71">{</a>
<a name="ln72">	SetTo(nref);</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">// constructor</a>
<a name="ln76">/*! \brief Creates a BDirectory and initializes it to the directory referred</a>
<a name="ln77">	to by the supplied BEntry.</a>
<a name="ln78">	\param entry the BEntry referring to the directory</a>
<a name="ln79">*/</a>
<a name="ln80">BDirectory::BDirectory(const BEntry *entry)</a>
<a name="ln81">		  : BNode(),</a>
<a name="ln82">			BEntryList(),</a>
<a name="ln83">			fDirFd(-1)</a>
<a name="ln84">{</a>
<a name="ln85">	SetTo(entry);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">// constructor</a>
<a name="ln89">/*! \brief Creates a BDirectory and initializes it to the directory referred</a>
<a name="ln90">	to by the supplied path name.</a>
<a name="ln91">	\param path the directory's path name </a>
<a name="ln92">*/</a>
<a name="ln93">BDirectory::BDirectory(const char *path)</a>
<a name="ln94">		  : BNode(),</a>
<a name="ln95">			BEntryList(),</a>
<a name="ln96">			fDirFd(-1)</a>
<a name="ln97">{</a>
<a name="ln98">	SetTo(path);</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">// constructor</a>
<a name="ln102">/*! \brief Creates a BDirectory and initializes it to the directory referred</a>
<a name="ln103">	to by the supplied path name relative to the specified BDirectory.</a>
<a name="ln104">	\param dir the BDirectory, relative to which the directory's path name is</a>
<a name="ln105">		   given</a>
<a name="ln106">	\param path the directory's path name relative to \a dir</a>
<a name="ln107">*/</a>
<a name="ln108">BDirectory::BDirectory(const BDirectory *dir, const char *path)</a>
<a name="ln109">		  : BNode(),</a>
<a name="ln110">			BEntryList(),</a>
<a name="ln111">			fDirFd(-1)</a>
<a name="ln112">{</a>
<a name="ln113">	SetTo(dir, path);</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116">// destructor</a>
<a name="ln117">//! Frees all allocated resources.</a>
<a name="ln118">/*! If the BDirectory is properly initialized, the directory's file descriptor</a>
<a name="ln119">	is closed.</a>
<a name="ln120">*/</a>
<a name="ln121">BDirectory::~BDirectory()</a>
<a name="ln122">{</a>
<a name="ln123">	// Also called by the BNode destructor, but we rather try to avoid</a>
<a name="ln124">	// problems with calling virtual functions in the base class destructor.</a>
<a name="ln125">	// Depending on the compiler implementation an object may be degraded to</a>
<a name="ln126">	// an object of the base class after the destructor of the derived class</a>
<a name="ln127">	// has been executed.</a>
<a name="ln128">	close_fd();</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">// SetTo</a>
<a name="ln132">/*! \brief Re-initializes the BDirectory to the directory referred to by the</a>
<a name="ln133">	supplied entry_ref.</a>
<a name="ln134">	\param ref the entry_ref referring to the directory</a>
<a name="ln135">	\return</a>
<a name="ln136">	- \c B_OK: Everything went fine.</a>
<a name="ln137">	- \c B_BAD_VALUE: \c NULL \a ref.</a>
<a name="ln138">	- \c B_ENTRY_NOT_FOUND: Directory not found.</a>
<a name="ln139">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln140">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln141">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln142">	- \c B_BUSY: A node was busy.</a>
<a name="ln143">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln144">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln145">*/</a>
<a name="ln146">status_t</a>
<a name="ln147">BDirectory::SetTo(const entry_ref *ref)</a>
<a name="ln148">{</a>
<a name="ln149">	// open node</a>
<a name="ln150">	status_t error = _SetTo(ref, true);</a>
<a name="ln151">	if (error != B_OK)</a>
<a name="ln152">		return error;</a>
<a name="ln153"> </a>
<a name="ln154">	// open dir</a>
<a name="ln155">	error = set_dir_fd(_kern_open_dir_entry_ref(ref-&gt;device, ref-&gt;directory, ref-&gt;name));</a>
<a name="ln156">	if (error &lt; 0) {</a>
<a name="ln157">		Unset();</a>
<a name="ln158">		return (fCStatus = error);</a>
<a name="ln159">	}</a>
<a name="ln160"> </a>
<a name="ln161">	// set close on exec flag on dir FD</a>
<a name="ln162">	fcntl(fDirFd, F_SETFD, FD_CLOEXEC);</a>
<a name="ln163"> </a>
<a name="ln164">	return B_OK;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">// SetTo</a>
<a name="ln168">/*! \brief Re-initializes the BDirectory to the directory referred to by the</a>
<a name="ln169">	supplied node_ref.</a>
<a name="ln170">	\param nref the node_ref referring to the directory</a>
<a name="ln171">	\return</a>
<a name="ln172">	- \c B_OK: Everything went fine.</a>
<a name="ln173">	- \c B_BAD_VALUE: \c NULL \a nref.</a>
<a name="ln174">	- \c B_ENTRY_NOT_FOUND: Directory not found.</a>
<a name="ln175">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln176">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln177">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln178">	- \c B_BUSY: A node was busy.</a>
<a name="ln179">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln180">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln181">*/</a>
<a name="ln182">status_t</a>
<a name="ln183">BDirectory::SetTo(const node_ref *nref)</a>
<a name="ln184">{</a>
<a name="ln185">	Unset();	</a>
<a name="ln186">	status_t error = (nref ? B_OK : B_BAD_VALUE);</a>
<a name="ln187">	if (error == B_OK) {</a>
<a name="ln188">		entry_ref ref(nref-&gt;device, nref-&gt;node, &quot;.&quot;);</a>
<a name="ln189">		error = SetTo(&amp;ref);</a>
<a name="ln190">	}</a>
<a name="ln191">	set_status(error);</a>
<a name="ln192">	return error;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">// SetTo</a>
<a name="ln196">/*! \brief Re-initializes the BDirectory to the directory referred to by the</a>
<a name="ln197">	supplied BEntry.</a>
<a name="ln198">	\param entry the BEntry referring to the directory</a>
<a name="ln199">	\return</a>
<a name="ln200">	- \c B_OK: Everything went fine.</a>
<a name="ln201">	- \c B_BAD_VALUE: \c NULL \a entry.</a>
<a name="ln202">	- \c B_ENTRY_NOT_FOUND: Directory not found.</a>
<a name="ln203">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln204">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln205">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln206">	- \c B_BUSY: A node was busy.</a>
<a name="ln207">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln208">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln209">*/</a>
<a name="ln210">status_t</a>
<a name="ln211">BDirectory::SetTo(const BEntry *entry)</a>
<a name="ln212">{</a>
<a name="ln213">	if (!entry) {</a>
<a name="ln214">		Unset();</a>
<a name="ln215">		return (fCStatus = B_BAD_VALUE);</a>
<a name="ln216">	}</a>
<a name="ln217"> </a>
<a name="ln218">	// open node</a>
<a name="ln219">	status_t error = _SetTo(entry-&gt;fDirFd, entry-&gt;fName, true);</a>
<a name="ln220">	if (error != B_OK)</a>
<a name="ln221">		return error;</a>
<a name="ln222"> </a>
<a name="ln223">	// open dir</a>
<a name="ln224">	error = set_dir_fd(_kern_open_dir(entry-&gt;fDirFd, entry-&gt;fName));</a>
<a name="ln225">	if (error &lt; 0) {</a>
<a name="ln226">		Unset();</a>
<a name="ln227">		return (fCStatus = error);</a>
<a name="ln228">	}</a>
<a name="ln229"> </a>
<a name="ln230">	// set close on exec flag on dir FD</a>
<a name="ln231">	fcntl(fDirFd, F_SETFD, FD_CLOEXEC);</a>
<a name="ln232"> </a>
<a name="ln233">	return B_OK;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">// SetTo</a>
<a name="ln237">/*! \brief Re-initializes the BDirectory to the directory referred to by the</a>
<a name="ln238">	supplied path name.</a>
<a name="ln239">	\param path the directory's path name </a>
<a name="ln240">	\return</a>
<a name="ln241">	- \c B_OK: Everything went fine.</a>
<a name="ln242">	- \c B_BAD_VALUE: \c NULL \a path.</a>
<a name="ln243">	- \c B_ENTRY_NOT_FOUND: Directory not found.</a>
<a name="ln244">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln245">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln246">	- \c B_NAME_TOO_LONG: The supplied path name (\a path) is too long.</a>
<a name="ln247">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln248">	- \c B_BUSY: A node was busy.</a>
<a name="ln249">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln250">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln251">	- \c B_NOT_A_DIRECTORY: \a path includes a non-directory.</a>
<a name="ln252">*/</a>
<a name="ln253">status_t</a>
<a name="ln254">BDirectory::SetTo(const char *path)</a>
<a name="ln255">{</a>
<a name="ln256">	// open node</a>
<a name="ln257">	status_t error = _SetTo(-1, path, true);</a>
<a name="ln258">	if (error != B_OK)</a>
<a name="ln259">		return error;</a>
<a name="ln260"> </a>
<a name="ln261">	// open dir</a>
<a name="ln262">	error = set_dir_fd(_kern_open_dir(-1, path));</a>
<a name="ln263">	if (error &lt; 0) {</a>
<a name="ln264">		Unset();</a>
<a name="ln265">		return (fCStatus = error);</a>
<a name="ln266">	}</a>
<a name="ln267"> </a>
<a name="ln268">	// set close on exec flag on dir FD</a>
<a name="ln269">	fcntl(fDirFd, F_SETFD, FD_CLOEXEC);</a>
<a name="ln270"> </a>
<a name="ln271">	return B_OK;</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">// SetTo</a>
<a name="ln275">/*! \brief Re-initializes the BDirectory to the directory referred to by the</a>
<a name="ln276">	supplied path name relative to the specified BDirectory.</a>
<a name="ln277">	\param dir the BDirectory, relative to which the directory's path name is</a>
<a name="ln278">		   given</a>
<a name="ln279">	\param path the directory's path name relative to \a dir</a>
<a name="ln280">	\return</a>
<a name="ln281">	- \c B_OK: Everything went fine.</a>
<a name="ln282">	- \c B_BAD_VALUE: \c NULL \a dir or \a path, or \a path is absolute.</a>
<a name="ln283">	- \c B_ENTRY_NOT_FOUND: Directory not found.</a>
<a name="ln284">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln285">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln286">	- \c B_NAME_TOO_LONG: The supplied path name (\a path) is too long.</a>
<a name="ln287">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln288">	- \c B_BUSY: A node was busy.</a>
<a name="ln289">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln290">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln291">	- \c B_NOT_A_DIRECTORY: \a path includes a non-directory.</a>
<a name="ln292">*/</a>
<a name="ln293">status_t</a>
<a name="ln294">BDirectory::SetTo(const BDirectory *dir, const char *path)</a>
<a name="ln295">{</a>
<a name="ln296">	if (!dir || !path || BPrivate::Storage::is_absolute_path(path)) {</a>
<a name="ln297">		Unset();</a>
<a name="ln298">		return (fCStatus = B_BAD_VALUE);</a>
<a name="ln299">	}</a>
<a name="ln300"> </a>
<a name="ln301">	// open node</a>
<a name="ln302">	status_t error = _SetTo(dir-&gt;fDirFd, path, true);</a>
<a name="ln303">	if (error != B_OK)</a>
<a name="ln304">		return error;</a>
<a name="ln305"> </a>
<a name="ln306">	// open dir</a>
<a name="ln307">	error = set_dir_fd(_kern_open_dir(dir-&gt;fDirFd, path));</a>
<a name="ln308">	if (error &lt; 0) {</a>
<a name="ln309">		Unset();</a>
<a name="ln310">		return (fCStatus = error);</a>
<a name="ln311">	}</a>
<a name="ln312"> </a>
<a name="ln313">	// set close on exec flag on dir FD</a>
<a name="ln314">	fcntl(fDirFd, F_SETFD, FD_CLOEXEC);</a>
<a name="ln315"> </a>
<a name="ln316">	return B_OK;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">// GetEntry</a>
<a name="ln320">//! Returns a BEntry referring to the directory represented by this object.</a>
<a name="ln321">/*!	If the initialization of \a entry fails, it is Unset().</a>
<a name="ln322">	\param entry a pointer to the entry that shall be set to refer to the</a>
<a name="ln323">		   directory</a>
<a name="ln324">	\return</a>
<a name="ln325">	- \c B_OK: Everything went fine.</a>
<a name="ln326">	- \c B_BAD_VALUE: \c NULL \a entry.</a>
<a name="ln327">	- \c B_ENTRY_NOT_FOUND: Directory not found.</a>
<a name="ln328">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln329">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln330">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln331">	- \c B_BUSY: A node was busy.</a>
<a name="ln332">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln333">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln334">*/</a>
<a name="ln335">status_t</a>
<a name="ln336">BDirectory::GetEntry(BEntry *entry) const</a>
<a name="ln337">{</a>
<a name="ln338">	if (!entry)</a>
<a name="ln339">		return B_BAD_VALUE;</a>
<a name="ln340">	if (InitCheck() != B_OK)</a>
<a name="ln341">		return B_NO_INIT;</a>
<a name="ln342">	return entry-&gt;SetTo(this, &quot;.&quot;, false);</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">// FindEntry</a>
<a name="ln346">/*! \brief Finds an entry referred to by a path relative to the directory</a>
<a name="ln347">	represented by this BDirectory.</a>
<a name="ln348">	\a path may be absolute. If the BDirectory is not properly initialized,</a>
<a name="ln349">	the entry is search relative to the current directory.</a>
<a name="ln350">	If the entry couldn't be found, \a entry is Unset().</a>
<a name="ln351">	\param path the entry's path name. May be relative to this directory or</a>
<a name="ln352">		   absolute.</a>
<a name="ln353">	\param entry a pointer to a BEntry to be initialized with the found entry</a>
<a name="ln354">	\param traverse specifies whether to follow it, if the found entry</a>
<a name="ln355">		   is a symbolic link.</a>
<a name="ln356">	\return</a>
<a name="ln357">	- \c B_OK: Everything went fine.</a>
<a name="ln358">	- \c B_BAD_VALUE: \c NULL \a path or \a entry.</a>
<a name="ln359">	- \c B_ENTRY_NOT_FOUND: Entry not found.</a>
<a name="ln360">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln361">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln362">	- \c B_NAME_TOO_LONG: The supplied path name (\a path) is too long.</a>
<a name="ln363">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln364">	- \c B_BUSY: A node was busy.</a>
<a name="ln365">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln366">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln367">	- \c B_NOT_A_DIRECTORY: \a path includes a non-directory.</a>
<a name="ln368">	\note The functionality of this method differs from the one of</a>
<a name="ln369">		  BEntry::SetTo(BDirectory *, const char *, bool) in that the</a>
<a name="ln370">		  latter doesn't require the entry to be existent, whereas this</a>
<a name="ln371">		  function does.</a>
<a name="ln372">*/</a>
<a name="ln373">status_t</a>
<a name="ln374">BDirectory::FindEntry(const char *path, BEntry *entry, bool traverse) const</a>
<a name="ln375">{</a>
<a name="ln376">	status_t error = (path &amp;&amp; entry ? B_OK : B_BAD_VALUE);</a>
<a name="ln377">	if (entry)</a>
<a name="ln378">		entry-&gt;Unset();</a>
<a name="ln379">	if (error == B_OK) {</a>
<a name="ln380">		// init a potentially abstract entry</a>
<a name="ln381">		if (InitCheck() == B_OK)</a>
<a name="ln382">			error = entry-&gt;SetTo(this, path, traverse);</a>
<a name="ln383">		else</a>
<a name="ln384">			error = entry-&gt;SetTo(path, traverse);</a>
<a name="ln385">		// fail, if entry is abstract</a>
<a name="ln386">		if (error == B_OK &amp;&amp; !entry-&gt;Exists()) {</a>
<a name="ln387">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln388">			entry-&gt;Unset();</a>
<a name="ln389">		}</a>
<a name="ln390">	}</a>
<a name="ln391">	return error;</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">// Contains</a>
<a name="ln395">/*!	\brief Returns whether this directory or any of its subdirectories</a>
<a name="ln396">	at any level contain the entry referred to by the supplied path name.</a>
<a name="ln397">	Only entries that match the node flavor specified by \a nodeFlags are</a>
<a name="ln398">	considered.</a>
<a name="ln399">	If the BDirectory is not properly initialized, the method returns \c false.</a>
<a name="ln400">	A non-absolute path is considered relative to the current directory.</a>
<a name="ln401"> </a>
<a name="ln402">	\note R5's implementation always returns \c true given an absolute path or </a>
<a name="ln403">	an unitialized directory. This implementation is not compatible with that</a>
<a name="ln404">	behavior. Instead it converts the path into a BEntry and passes it to the</a>
<a name="ln405">	other version of Contains().</a>
<a name="ln406"> </a>
<a name="ln407">	\param path the entry's path name. May be relative to this directory or</a>
<a name="ln408">		   absolute.</a>
<a name="ln409">	\param nodeFlags Any of the following:</a>
<a name="ln410">		   - \c B_FILE_NODE: The entry must be a file.</a>
<a name="ln411">		   - \c B_DIRECTORY_NODE: The entry must be a directory.</a>
<a name="ln412">		   - \c B_SYMLINK_NODE: The entry must be a symbolic link.</a>
<a name="ln413">		   - \c B_ANY_NODE: The entry may be of any kind.</a>
<a name="ln414">	\return</a>
<a name="ln415">	- \c true, if the entry exists, its kind does match \nodeFlags and the</a>
<a name="ln416">	  BDirectory is properly initialized and does contain the entry at any</a>
<a name="ln417">	  level,</a>
<a name="ln418">	- \c false, otherwise</a>
<a name="ln419">*/</a>
<a name="ln420">bool</a>
<a name="ln421">BDirectory::Contains(const char *path, int32 nodeFlags) const</a>
<a name="ln422">{</a>
<a name="ln423">	// check initialization and parameters</a>
<a name="ln424">	if (InitCheck() != B_OK)</a>
<a name="ln425">		return false;</a>
<a name="ln426">	if (!path)</a>
<a name="ln427">		return true;	// mimic R5 behavior</a>
<a name="ln428">	// turn the path into a BEntry and let the other version do the work</a>
<a name="ln429">	BEntry entry;</a>
<a name="ln430">	if (BPrivate::Storage::is_absolute_path(path))</a>
<a name="ln431">		entry.SetTo(path);</a>
<a name="ln432">	else</a>
<a name="ln433">		entry.SetTo(this, path);</a>
<a name="ln434">	return Contains(&amp;entry, nodeFlags);</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">// Contains</a>
<a name="ln438">/*!	\brief Returns whether this directory or any of its subdirectories</a>
<a name="ln439">	at any level contain the entry referred to by the supplied BEntry.</a>
<a name="ln440">	Only entries that match the node flavor specified by \a nodeFlags are</a>
<a name="ln441">	considered.</a>
<a name="ln442">	\param entry a BEntry referring to the entry</a>
<a name="ln443">	\param nodeFlags Any of the following:</a>
<a name="ln444">		   - \c B_FILE_NODE: The entry must be a file.</a>
<a name="ln445">		   - \c B_DIRECTORY_NODE: The entry must be a directory.</a>
<a name="ln446">		   - \c B_SYMLINK_NODE: The entry must be a symbolic link.</a>
<a name="ln447">		   - \c B_ANY_NODE: The entry may be of any kind.</a>
<a name="ln448">	\return</a>
<a name="ln449">	- \c true, if the BDirectory is properly initialized and the entry of the</a>
<a name="ln450">	  matching kind could be found,</a>
<a name="ln451">	- \c false, otherwise</a>
<a name="ln452">*/</a>
<a name="ln453">bool</a>
<a name="ln454">BDirectory::Contains(const BEntry *entry, int32 nodeFlags) const</a>
<a name="ln455">{</a>
<a name="ln456">	bool result = (entry);</a>
<a name="ln457">	// check, if the entry exists at all</a>
<a name="ln458">	if (result)</a>
<a name="ln459">		result = entry-&gt;Exists();</a>
<a name="ln460">	// test the node kind</a>
<a name="ln461">	if (result) {</a>
<a name="ln462">		switch (nodeFlags) {</a>
<a name="ln463">			case B_FILE_NODE:</a>
<a name="ln464">				result = entry-&gt;IsFile();</a>
<a name="ln465">				break;</a>
<a name="ln466">			case B_DIRECTORY_NODE:</a>
<a name="ln467">				result = entry-&gt;IsDirectory();</a>
<a name="ln468">				break;</a>
<a name="ln469">			case B_SYMLINK_NODE:</a>
<a name="ln470">				result = entry-&gt;IsSymLink();</a>
<a name="ln471">				break;</a>
<a name="ln472">			case B_ANY_NODE:</a>
<a name="ln473">				break;</a>
<a name="ln474">			default:</a>
<a name="ln475">				result = false;</a>
<a name="ln476">				break;</a>
<a name="ln477">		}</a>
<a name="ln478">	}</a>
<a name="ln479">	// If the directory is initialized, get the canonical paths of the dir and</a>
<a name="ln480">	// the entry and check, if the latter is a prefix of the first one.</a>
<a name="ln481">	if (result &amp;&amp; InitCheck() == B_OK) {</a>
<a name="ln482">		BPath dirPath(this, &quot;.&quot;, true);</a>
<a name="ln483">		BPath entryPath(entry);</a>
<a name="ln484">		if (dirPath.InitCheck() == B_OK &amp;&amp; entryPath.InitCheck() == B_OK) {</a>
<a name="ln485">			result = !strncmp(dirPath.Path(), entryPath.Path(),</a>
<a name="ln486">				strlen(dirPath.Path()));</a>
<a name="ln487">		} else</a>
<a name="ln488">			result = false;</a>
<a name="ln489">	}</a>
<a name="ln490">	return result;</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">// GetStatFor</a>
<a name="ln494">/*!	\brief Returns the stat structure of the entry referred to by the supplied</a>
<a name="ln495">	path name.</a>
<a name="ln496">	\param path the entry's path name. May be relative to this directory or</a>
<a name="ln497">		   absolute, or \c NULL to get the directories stat info.</a>
<a name="ln498">	\param st a pointer to the stat structure to be filled in by this function</a>
<a name="ln499">	\return</a>
<a name="ln500">	- \c B_OK: Everything went fine.</a>
<a name="ln501">	- \c B_BAD_VALUE: \c NULL \a st.</a>
<a name="ln502">	- \c B_ENTRY_NOT_FOUND: Entry not found.</a>
<a name="ln503">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln504">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln505">	- \c B_NAME_TOO_LONG: The supplied path name (\a path) is too long.</a>
<a name="ln506">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln507">	- \c B_BUSY: A node was busy.</a>
<a name="ln508">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln509">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln510">	- \c B_NOT_A_DIRECTORY: \a path includes a non-directory.</a>
<a name="ln511">*/</a>
<a name="ln512">status_t</a>
<a name="ln513">BDirectory::GetStatFor(const char *path, struct stat *st) const</a>
<a name="ln514">{</a>
<a name="ln515">	if (!st)</a>
<a name="ln516">		return B_BAD_VALUE;</a>
<a name="ln517">	if (InitCheck() != B_OK)</a>
<a name="ln518">		return B_NO_INIT;</a>
<a name="ln519">	status_t error = B_OK;</a>
<a name="ln520">	if (path) {</a>
<a name="ln521">		if (strlen(path) == 0)</a>
<a name="ln522">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln523">		error = _kern_read_stat(fDirFd, path, false, st, sizeof(struct stat));</a>
<a name="ln524">	} else</a>
<a name="ln525">		error = GetStat(st);</a>
<a name="ln526">	return error;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529">// GetNextEntry</a>
<a name="ln530">//! Returns the BDirectory's next entry as a BEntry.</a>
<a name="ln531">/*!	Unlike GetNextDirents() this method ignores the entries &quot;.&quot; and &quot;..&quot;.</a>
<a name="ln532">	\param entry a pointer to a BEntry to be initialized to the found entry</a>
<a name="ln533">	\param traverse specifies whether to follow it, if the found entry</a>
<a name="ln534">		   is a symbolic link.</a>
<a name="ln535">	\note The iterator used by this method is the same one used by</a>
<a name="ln536">		  GetNextRef(), GetNextDirents(), Rewind() and CountEntries().</a>
<a name="ln537">	\return</a>
<a name="ln538">	- \c B_OK: Everything went fine.</a>
<a name="ln539">	- \c B_BAD_VALUE: \c NULL \a entry.</a>
<a name="ln540">	- \c B_ENTRY_NOT_FOUND: No more entries found.</a>
<a name="ln541">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln542">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln543">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln544">	- \c B_BUSY: A node was busy.</a>
<a name="ln545">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln546">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln547">*/</a>
<a name="ln548">status_t</a>
<a name="ln549">BDirectory::GetNextEntry(BEntry *entry, bool traverse)</a>
<a name="ln550">{</a>
<a name="ln551">	status_t error = (entry ? B_OK : B_BAD_VALUE);</a>
<a name="ln552">	if (error == B_OK) {</a>
<a name="ln553">		entry_ref ref;</a>
<a name="ln554">		error = GetNextRef(&amp;ref);</a>
<a name="ln555">		if (error == B_OK)</a>
<a name="ln556">			error = entry-&gt;SetTo(&amp;ref, traverse);</a>
<a name="ln557">	}</a>
<a name="ln558">	return error;</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">// GetNextRef</a>
<a name="ln562">//! Returns the BDirectory's next entry as an entry_ref.</a>
<a name="ln563">/*!	Unlike GetNextDirents() this method ignores the entries &quot;.&quot; and &quot;..&quot;.</a>
<a name="ln564">	\param ref a pointer to an entry_ref to be filled in with the data of the</a>
<a name="ln565">		   found entry</a>
<a name="ln566">	\param traverse specifies whether to follow it, if the found entry</a>
<a name="ln567">		   is a symbolic link.</a>
<a name="ln568">	\note The iterator used be this method is the same one used by</a>
<a name="ln569">		  GetNextEntry(), GetNextDirents(), Rewind() and CountEntries().</a>
<a name="ln570">	\return</a>
<a name="ln571">	- \c B_OK: Everything went fine.</a>
<a name="ln572">	- \c B_BAD_VALUE: \c NULL \a ref.</a>
<a name="ln573">	- \c B_ENTRY_NOT_FOUND: No more entries found.</a>
<a name="ln574">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln575">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln576">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln577">	- \c B_BUSY: A node was busy.</a>
<a name="ln578">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln579">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln580">*/</a>
<a name="ln581">status_t</a>
<a name="ln582">BDirectory::GetNextRef(entry_ref *ref)</a>
<a name="ln583">{</a>
<a name="ln584">	status_t error = (ref ? B_OK : B_BAD_VALUE);</a>
<a name="ln585">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln586">		error = B_FILE_ERROR;</a>
<a name="ln587">	if (error == B_OK) {</a>
<a name="ln588">		BPrivate::Storage::LongDirEntry entry;</a>
<a name="ln589">		bool next = true;</a>
<a name="ln590">		while (error == B_OK &amp;&amp; next) {</a>
<a name="ln591">			if (GetNextDirents(&amp;entry, sizeof(entry), 1) != 1) {</a>
<a name="ln592">				error = B_ENTRY_NOT_FOUND;</a>
<a name="ln593">			} else {</a>
<a name="ln594">				next = (!strcmp(entry.d_name, &quot;.&quot;)</a>
<a name="ln595">						|| !strcmp(entry.d_name, &quot;..&quot;));</a>
<a name="ln596">			}</a>
<a name="ln597">		}</a>
<a name="ln598">		if (error == B_OK) {</a>
<a name="ln599">			ref-&gt;device = fDirNodeRef.device;</a>
<a name="ln600">			ref-&gt;directory = fDirNodeRef.node;</a>
<a name="ln601">			error = ref-&gt;set_name(entry.d_name);</a>
<a name="ln602">		}</a>
<a name="ln603">	}</a>
<a name="ln604">	return error;</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">// GetNextDirents</a>
<a name="ln608">//! Returns the BDirectory's next entries as dirent structures.</a>
<a name="ln609">/*!	Unlike GetNextEntry() and GetNextRef(), this method returns also</a>
<a name="ln610">	the entries &quot;.&quot; and &quot;..&quot;.</a>
<a name="ln611">	\param buf a pointer to a buffer to be filled with dirent structures of</a>
<a name="ln612">		   the found entries</a>
<a name="ln613">	\param count the maximal number of entries to be returned.</a>
<a name="ln614">	\note The iterator used by this method is the same one used by</a>
<a name="ln615">		  GetNextEntry(), GetNextRef(), Rewind() and CountEntries().</a>
<a name="ln616">	\return</a>
<a name="ln617">	- The number of dirent structures stored in the buffer, 0 when there are</a>
<a name="ln618">	  no more entries to be returned.</a>
<a name="ln619">	- \c B_BAD_VALUE: \c NULL \a buf.</a>
<a name="ln620">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln621">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln622">	- \c B_NAME_TOO_LONG: The entry's name is too long for the buffer.</a>
<a name="ln623">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln624">	- \c B_BUSY: A node was busy.</a>
<a name="ln625">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln626">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln627">*/</a>
<a name="ln628">int32</a>
<a name="ln629">BDirectory::GetNextDirents(dirent *buf, size_t bufSize, int32 count)</a>
<a name="ln630">{</a>
<a name="ln631">	if (!buf)</a>
<a name="ln632">		return B_BAD_VALUE;</a>
<a name="ln633">	if (InitCheck() != B_OK)</a>
<a name="ln634">		return B_FILE_ERROR;</a>
<a name="ln635">	return _kern_read_dir(fDirFd, buf, bufSize, count);</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">// Rewind</a>
<a name="ln639">//!	Rewinds the directory iterator.</a>
<a name="ln640">/*!	\return</a>
<a name="ln641">	- \c B_OK: Everything went fine.</a>
<a name="ln642">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln643">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln644">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln645">	- \c B_BUSY: A node was busy.</a>
<a name="ln646">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln647">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln648">	\see GetNextEntry(), GetNextRef(), GetNextDirents(), CountEntries()</a>
<a name="ln649">*/</a>
<a name="ln650">status_t</a>
<a name="ln651">BDirectory::Rewind()</a>
<a name="ln652">{</a>
<a name="ln653">	if (InitCheck() != B_OK)</a>
<a name="ln654">		return B_FILE_ERROR;</a>
<a name="ln655">	return _kern_rewind_dir(fDirFd);</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">// CountEntries</a>
<a name="ln659">//!	Returns the number of entries in this directory.</a>
<a name="ln660">/*!	CountEntries() uses the directory iterator also used by GetNextEntry(),</a>
<a name="ln661">	GetNextRef() and GetNextDirents(). It does a Rewind(), iterates through</a>
<a name="ln662">	the entries and Rewind()s again. The entries &quot;.&quot; and &quot;..&quot; are not counted.</a>
<a name="ln663">	\return</a>
<a name="ln664">	- the number of entries in the directory (not counting &quot;.&quot; and &quot;..&quot;).</a>
<a name="ln665">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln666">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln667">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln668">	- \c B_BUSY: A node was busy.</a>
<a name="ln669">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln670">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln671">	\see GetNextEntry(), GetNextRef(), GetNextDirents(), Rewind()</a>
<a name="ln672">*/</a>
<a name="ln673">int32</a>
<a name="ln674">BDirectory::CountEntries()</a>
<a name="ln675">{</a>
<a name="ln676">	status_t error = Rewind();</a>
<a name="ln677">	if (error != B_OK)</a>
<a name="ln678">		return error;</a>
<a name="ln679">	int32 count = 0;</a>
<a name="ln680">	BPrivate::Storage::LongDirEntry entry;</a>
<a name="ln681">	while (error == B_OK) {</a>
<a name="ln682">		if (GetNextDirents(&amp;entry, sizeof(entry), 1) != 1)</a>
<a name="ln683">			break;</a>
<a name="ln684">		if (strcmp(entry.d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(entry.d_name, &quot;..&quot;) != 0)</a>
<a name="ln685">			count++;</a>
<a name="ln686">	}</a>
<a name="ln687">	Rewind();</a>
<a name="ln688">	return (error == B_OK ? count : error);</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">// CreateDirectory</a>
<a name="ln692">//! Creates a new directory.</a>
<a name="ln693">/*! If an entry with the supplied name does already exist, the method fails.</a>
<a name="ln694">	\param path the new directory's path name. May be relative to this</a>
<a name="ln695">		   directory or absolute.</a>
<a name="ln696">	\param dir a pointer to a BDirectory to be initialized to the newly</a>
<a name="ln697">		   created directory. May be \c NULL.</a>
<a name="ln698">	\return</a>
<a name="ln699">	- \c B_OK: Everything went fine.</a>
<a name="ln700">	- \c B_BAD_VALUE: \c NULL \a path.</a>
<a name="ln701">	- \c B_ENTRY_NOT_FOUND: \a path does not refer to a possible entry.</a>
<a name="ln702">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln703">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln704">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln705">	- \c B_BUSY: A node was busy.</a>
<a name="ln706">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln707">	- \c B_FILE_EXISTS: An entry with that name does already exist.</a>
<a name="ln708">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln709">*/</a>
<a name="ln710">status_t</a>
<a name="ln711">BDirectory::CreateDirectory(const char *path, BDirectory *dir)</a>
<a name="ln712">{</a>
<a name="ln713">	if (!path)</a>
<a name="ln714">		return B_BAD_VALUE;</a>
<a name="ln715">	// create the dir</a>
<a name="ln716">	status_t error = _kern_create_dir(fDirFd, path,</a>
<a name="ln717">		S_IRWXU | S_IRWXG | S_IRWXU);</a>
<a name="ln718">	if (error != B_OK)</a>
<a name="ln719">		return error;</a>
<a name="ln720">	if (!dir)</a>
<a name="ln721">		return B_OK;</a>
<a name="ln722">	// init the supplied BDirectory</a>
<a name="ln723">	if (InitCheck() != B_OK || BPrivate::Storage::is_absolute_path(path))</a>
<a name="ln724">		return dir-&gt;SetTo(path);</a>
<a name="ln725">	else</a>
<a name="ln726">		return dir-&gt;SetTo(this, path);</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729">// CreateFile</a>
<a name="ln730">//! Creates a new file.</a>
<a name="ln731">/*!	If a file with the supplied name does already exist, the method fails,</a>
<a name="ln732">	unless it is passed \c false to \a failIfExists -- in that case the file</a>
<a name="ln733">	is truncated to zero size. The new BFile will operate in \c B_READ_WRITE</a>
<a name="ln734">	mode.</a>
<a name="ln735">	\param path the new file's path name. May be relative to this</a>
<a name="ln736">		   directory or absolute.</a>
<a name="ln737">	\param file a pointer to a BFile to be initialized to the newly</a>
<a name="ln738">		   created file. May be \c NULL.</a>
<a name="ln739">	\param failIfExists \c true, if the method should fail when the file</a>
<a name="ln740">		   already exists, \c false otherwise</a>
<a name="ln741">	\return</a>
<a name="ln742">	- \c B_OK: Everything went fine.</a>
<a name="ln743">	- \c B_BAD_VALUE: \c NULL \a path.</a>
<a name="ln744">	- \c B_ENTRY_NOT_FOUND: \a path does not refer to a possible entry.</a>
<a name="ln745">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln746">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln747">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln748">	- \c B_BUSY: A node was busy.</a>
<a name="ln749">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln750">	- \c B_FILE_EXISTS: A file with that name does already exist and</a>
<a name="ln751">	  \c true has been passed for \a failIfExists.</a>
<a name="ln752">	- \c B_IS_A_DIRECTORY: A directory with the supplied name does already</a>
<a name="ln753">	  exist.</a>
<a name="ln754">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln755">*/</a>
<a name="ln756">status_t</a>
<a name="ln757">BDirectory::CreateFile(const char *path, BFile *file, bool failIfExists)</a>
<a name="ln758">{</a>
<a name="ln759">	if (!path)</a>
<a name="ln760">		return B_BAD_VALUE;</a>
<a name="ln761">	// Let BFile do the dirty job.</a>
<a name="ln762">	uint32 openMode = B_READ_WRITE | B_CREATE_FILE</a>
<a name="ln763">					  | (failIfExists ? B_FAIL_IF_EXISTS : 0);</a>
<a name="ln764">	BFile tmpFile;</a>
<a name="ln765">	BFile *realFile = (file ? file : &amp;tmpFile);</a>
<a name="ln766">	status_t error = B_OK;</a>
<a name="ln767">	if (InitCheck() == B_OK &amp;&amp; !BPrivate::Storage::is_absolute_path(path))</a>
<a name="ln768">		error = realFile-&gt;SetTo(this, path, openMode);</a>
<a name="ln769">	else</a>
<a name="ln770">		error = realFile-&gt;SetTo(path, openMode);</a>
<a name="ln771">	if (error != B_OK &amp;&amp; file) // mimic R5 behavior</a>
<a name="ln772">		file-&gt;Unset();</a>
<a name="ln773">	return error;</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">// CreateSymLink</a>
<a name="ln777">//! Creates a new symbolic link.</a>
<a name="ln778">/*! If an entry with the supplied name does already exist, the method fails.</a>
<a name="ln779">	\param path the new symbolic link's path name. May be relative to this</a>
<a name="ln780">		   directory or absolute.</a>
<a name="ln781">	\param linkToPath the path the symbolic link shall point to.</a>
<a name="ln782">	\param dir a pointer to a BSymLink to be initialized to the newly</a>
<a name="ln783">		   created symbolic link. May be \c NULL.</a>
<a name="ln784">	\return</a>
<a name="ln785">	- \c B_OK: Everything went fine.</a>
<a name="ln786">	- \c B_BAD_VALUE: \c NULL \a path or \a linkToPath.</a>
<a name="ln787">	- \c B_ENTRY_NOT_FOUND: \a path does not refer to a possible entry.</a>
<a name="ln788">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln789">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln790">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln791">	- \c B_BUSY: A node was busy.</a>
<a name="ln792">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln793">	- \c B_FILE_EXISTS: An entry with that name does already exist.</a>
<a name="ln794">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln795">*/</a>
<a name="ln796">status_t</a>
<a name="ln797">BDirectory::CreateSymLink(const char *path, const char *linkToPath,</a>
<a name="ln798">						  BSymLink *link)</a>
<a name="ln799">{</a>
<a name="ln800">	if (!path || !linkToPath)</a>
<a name="ln801">		return B_BAD_VALUE;</a>
<a name="ln802">	// create the symlink</a>
<a name="ln803">	status_t error = _kern_create_symlink(fDirFd, path, linkToPath,</a>
<a name="ln804">		S_IRWXU | S_IRWXG | S_IRWXU);</a>
<a name="ln805">	if (error != B_OK)</a>
<a name="ln806">		return error;</a>
<a name="ln807">	if (!link)</a>
<a name="ln808">		return B_OK;</a>
<a name="ln809">	// init the supplied BSymLink</a>
<a name="ln810">	if (InitCheck() != B_OK || BPrivate::Storage::is_absolute_path(path))</a>
<a name="ln811">		return link-&gt;SetTo(path);</a>
<a name="ln812">	else</a>
<a name="ln813">		return link-&gt;SetTo(this, path);</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">// =</a>
<a name="ln817">//! Assigns another BDirectory to this BDirectory.</a>
<a name="ln818">/*!	If the other BDirectory is uninitialized, this one wi'll be too. Otherwise</a>
<a name="ln819">	it will refer to the same directory, unless an error occurs.</a>
<a name="ln820">	\param dir the original BDirectory</a>
<a name="ln821">	\return a reference to this BDirectory</a>
<a name="ln822">*/</a>
<a name="ln823">BDirectory &amp;</a>
<a name="ln824">BDirectory::operator=(const BDirectory &amp;dir)</a>
<a name="ln825">{</a>
<a name="ln826">	if (&amp;dir != this) {	// no need to assign us to ourselves</a>
<a name="ln827">		Unset();</a>
<a name="ln828">		if (dir.InitCheck() == B_OK)</a>
<a name="ln829">			SetTo(&amp;dir, &quot;.&quot;);</a>
<a name="ln830">	}</a>
<a name="ln831">	return *this;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834"> </a>
<a name="ln835">// FBC</a>
<a name="ln836">void BDirectory::_ErectorDirectory1() {}</a>
<a name="ln837">void BDirectory::_ErectorDirectory2() {}</a>
<a name="ln838">void BDirectory::_ErectorDirectory3() {}</a>
<a name="ln839">void BDirectory::_ErectorDirectory4() {}</a>
<a name="ln840">void BDirectory::_ErectorDirectory5() {}</a>
<a name="ln841">void BDirectory::_ErectorDirectory6() {}</a>
<a name="ln842"> </a>
<a name="ln843">// close_fd</a>
<a name="ln844">//! Closes the BDirectory's file descriptor.</a>
<a name="ln845">void</a>
<a name="ln846">BDirectory::close_fd()</a>
<a name="ln847">{</a>
<a name="ln848">	if (fDirFd &gt;= 0) {</a>
<a name="ln849">		_kern_close(fDirFd);</a>
<a name="ln850">		fDirFd = -1;</a>
<a name="ln851">	}</a>
<a name="ln852">	BNode::close_fd();</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">//! Returns the BDirectory's file descriptor.</a>
<a name="ln856">/*!	To be used instead of accessing the BDirectory's private \c fDirFd member</a>
<a name="ln857">	directly.</a>
<a name="ln858">	\return the file descriptor, or -1, if not properly initialized.</a>
<a name="ln859">*/</a>
<a name="ln860">int</a>
<a name="ln861">BDirectory::get_fd() const</a>
<a name="ln862">{</a>
<a name="ln863">	return fDirFd;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">status_t</a>
<a name="ln867">BDirectory::set_dir_fd(int fd)</a>
<a name="ln868">{</a>
<a name="ln869">	if (fd &lt; 0)</a>
<a name="ln870">		return fd;</a>
<a name="ln871">	</a>
<a name="ln872">	fDirFd = fd;</a>
<a name="ln873">	</a>
<a name="ln874">	status_t error = GetNodeRef(&amp;fDirNodeRef);</a>
<a name="ln875">	if (error != B_OK)</a>
<a name="ln876">		close_fd();</a>
<a name="ln877"> </a>
<a name="ln878">	return error;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881"> </a>
<a name="ln882"> </a>
<a name="ln883">// C functions</a>
<a name="ln884"> </a>
<a name="ln885">// create_directory</a>
<a name="ln886">//! Creates all missing directories along a given path.</a>
<a name="ln887">/*!	\param path the directory path name.</a>
<a name="ln888">	\param mode a permission specification, which shall be used for the</a>
<a name="ln889">		   newly created directories.</a>
<a name="ln890">	\return</a>
<a name="ln891">	- \c B_OK: Everything went fine.</a>
<a name="ln892">	- \c B_BAD_VALUE: \c NULL \a path.</a>
<a name="ln893">	- \c B_ENTRY_NOT_FOUND: \a path does not refer to a possible entry.</a>
<a name="ln894">	- \c B_PERMISSION_DENIED: Directory permissions didn't allow operation.</a>
<a name="ln895">	- \c B_NO_MEMORY: Insufficient memory for operation.</a>
<a name="ln896">	- \c B_LINK_LIMIT: Indicates a cyclic loop within the file system.</a>
<a name="ln897">	- \c B_BUSY: A node was busy.</a>
<a name="ln898">	- \c B_FILE_ERROR: A general file error.</a>
<a name="ln899">	- \c B_NOT_A_DIRECTORY: An entry other than a directory with that name does</a>
<a name="ln900">	  already exist.</a>
<a name="ln901">	- \c B_NO_MORE_FDS: The application has run out of file descriptors.</a>
<a name="ln902">	\todo Check for efficency.</a>
<a name="ln903">*/</a>
<a name="ln904">status_t</a>
<a name="ln905">create_directory(const char *path, mode_t mode)</a>
<a name="ln906">{</a>
<a name="ln907">	if (!path)</a>
<a name="ln908">		return B_BAD_VALUE;</a>
<a name="ln909">	// That's the strategy: We start with the first component of the supplied</a>
<a name="ln910">	// path, create a BPath object from it and successively add the following</a>
<a name="ln911">	// components. Each time we get a new path, we check, if the entry it</a>
<a name="ln912">	// refers to exists and is a directory. If it doesn't exist, we try</a>
<a name="ln913">	// to create it. This goes on, until we're done with the input path or</a>
<a name="ln914">	// an error occurs.</a>
<a name="ln915">	BPath dirPath;</a>
<a name="ln916">	char *component;</a>
<a name="ln917">	int32 nextComponent;</a>
<a name="ln918">	do {</a>
<a name="ln919">		// get the next path component</a>
<a name="ln920">		status_t error = BPrivate::Storage::parse_first_path_component(path,</a>
<a name="ln921">			component, nextComponent);</a>
<a name="ln922">		if (error != B_OK)</a>
<a name="ln923">			return error;</a>
<a name="ln924">		// append it to the BPath</a>
<a name="ln925">		if (dirPath.InitCheck() == B_NO_INIT)	// first component</a>
<a name="ln926">			error = dirPath.SetTo(component);</a>
<a name="ln927">		else</a>
<a name="ln928">			error = dirPath.Append(component);</a>
<a name="ln929">		delete[] component;</a>
<a name="ln930">		if (error != B_OK)</a>
<a name="ln931">			return error;</a>
<a name="ln932">		path += nextComponent;</a>
<a name="ln933">		// create a BEntry from the BPath</a>
<a name="ln934">		BEntry entry;</a>
<a name="ln935">		error = entry.SetTo(dirPath.Path(), true);</a>
<a name="ln936">		if (error != B_OK)</a>
<a name="ln937">			return error;</a>
<a name="ln938">		// check, if it exists</a>
<a name="ln939">		if (entry.Exists()) {</a>
<a name="ln940">			// yep, it exists</a>
<a name="ln941">			if (!entry.IsDirectory())	// but is no directory</a>
<a name="ln942">				return B_NOT_A_DIRECTORY;</a>
<a name="ln943">		} else {</a>
<a name="ln944">			// it doesn't exist -- create it</a>
<a name="ln945">			error = _kern_create_dir(-1, dirPath.Path(), mode);</a>
<a name="ln946">			if (error != B_OK)</a>
<a name="ln947">				return error;</a>
<a name="ln948">		}</a>
<a name="ln949">	} while (nextComponent != 0);</a>
<a name="ln950">	return B_OK;</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">#ifdef USE_OPENBEOS_NAMESPACE</a>
<a name="ln955">};		// namespace OpenBeOS</a>
<a name="ln956">#endif</a>
<a name="ln957"> </a>

</code></pre>
<div class="balloon" rel="681"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'error == ((int) 0)' of loop is always true.</p></div>
<div class="balloon" rel="688"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
