
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>team.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2014, Paweł Dziepak, pdziepak@quarnos.org.</a>
<a name="ln3"> * Copyright 2008-2016, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln4"> * Copyright 2002-2010, Axel Dörfler, axeld@pinc-software.de.</a>
<a name="ln5"> * Distributed under the terms of the MIT License.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Copyright 2001-2002, Travis Geiselbrecht. All rights reserved.</a>
<a name="ln8"> * Distributed under the terms of the NewOS License.</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">/*!	Team functions */</a>
<a name="ln13"> </a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;team.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;errno.h&gt;</a>
<a name="ln18">#include &lt;stdio.h&gt;</a>
<a name="ln19">#include &lt;stdlib.h&gt;</a>
<a name="ln20">#include &lt;string.h&gt;</a>
<a name="ln21">#include &lt;sys/wait.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;OS.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln26">#include &lt;FindDirectory.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;extended_system_info_defs.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;commpage.h&gt;</a>
<a name="ln31">#include &lt;boot_device.h&gt;</a>
<a name="ln32">#include &lt;elf.h&gt;</a>
<a name="ln33">#include &lt;file_cache.h&gt;</a>
<a name="ln34">#include &lt;find_directory_private.h&gt;</a>
<a name="ln35">#include &lt;fs/KPath.h&gt;</a>
<a name="ln36">#include &lt;heap.h&gt;</a>
<a name="ln37">#include &lt;int.h&gt;</a>
<a name="ln38">#include &lt;kernel.h&gt;</a>
<a name="ln39">#include &lt;kimage.h&gt;</a>
<a name="ln40">#include &lt;kscheduler.h&gt;</a>
<a name="ln41">#include &lt;ksignal.h&gt;</a>
<a name="ln42">#include &lt;Notifications.h&gt;</a>
<a name="ln43">#include &lt;port.h&gt;</a>
<a name="ln44">#include &lt;posix/realtime_sem.h&gt;</a>
<a name="ln45">#include &lt;posix/xsi_semaphore.h&gt;</a>
<a name="ln46">#include &lt;safemode.h&gt;</a>
<a name="ln47">#include &lt;sem.h&gt;</a>
<a name="ln48">#include &lt;syscall_process_info.h&gt;</a>
<a name="ln49">#include &lt;syscall_load_image.h&gt;</a>
<a name="ln50">#include &lt;syscall_restart.h&gt;</a>
<a name="ln51">#include &lt;syscalls.h&gt;</a>
<a name="ln52">#include &lt;tls.h&gt;</a>
<a name="ln53">#include &lt;tracing.h&gt;</a>
<a name="ln54">#include &lt;user_runtime.h&gt;</a>
<a name="ln55">#include &lt;user_thread.h&gt;</a>
<a name="ln56">#include &lt;usergroup.h&gt;</a>
<a name="ln57">#include &lt;vfs.h&gt;</a>
<a name="ln58">#include &lt;vm/vm.h&gt;</a>
<a name="ln59">#include &lt;vm/VMAddressSpace.h&gt;</a>
<a name="ln60">#include &lt;util/AutoLock.h&gt;</a>
<a name="ln61"> </a>
<a name="ln62">#include &quot;TeamThreadTables.h&quot;</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">//#define TRACE_TEAM</a>
<a name="ln66">#ifdef TRACE_TEAM</a>
<a name="ln67">#	define TRACE(x) dprintf x</a>
<a name="ln68">#else</a>
<a name="ln69">#	define TRACE(x) ;</a>
<a name="ln70">#endif</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">struct team_key {</a>
<a name="ln74">	team_id id;</a>
<a name="ln75">};</a>
<a name="ln76"> </a>
<a name="ln77">struct team_arg {</a>
<a name="ln78">	char	*path;</a>
<a name="ln79">	char	**flat_args;</a>
<a name="ln80">	size_t	flat_args_size;</a>
<a name="ln81">	uint32	arg_count;</a>
<a name="ln82">	uint32	env_count;</a>
<a name="ln83">	mode_t	umask;</a>
<a name="ln84">	uint32	flags;</a>
<a name="ln85">	port_id	error_port;</a>
<a name="ln86">	uint32	error_token;</a>
<a name="ln87">};</a>
<a name="ln88"> </a>
<a name="ln89">#define TEAM_ARGS_FLAG_NO_ASLR	0x01</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">namespace {</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">class TeamNotificationService : public DefaultNotificationService {</a>
<a name="ln96">public:</a>
<a name="ln97">							TeamNotificationService();</a>
<a name="ln98"> </a>
<a name="ln99">			void			Notify(uint32 eventCode, Team* team);</a>
<a name="ln100">};</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">// #pragma mark - TeamTable</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">typedef BKernel::TeamThreadTable&lt;Team&gt; TeamTable;</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">// #pragma mark - ProcessGroupHashDefinition</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">struct ProcessGroupHashDefinition {</a>
<a name="ln113">	typedef pid_t			KeyType;</a>
<a name="ln114">	typedef	ProcessGroup	ValueType;</a>
<a name="ln115"> </a>
<a name="ln116">	size_t HashKey(pid_t key) const</a>
<a name="ln117">	{</a>
<a name="ln118">		return key;</a>
<a name="ln119">	}</a>
<a name="ln120"> </a>
<a name="ln121">	size_t Hash(ProcessGroup* value) const</a>
<a name="ln122">	{</a>
<a name="ln123">		return HashKey(value-&gt;id);</a>
<a name="ln124">	}</a>
<a name="ln125"> </a>
<a name="ln126">	bool Compare(pid_t key, ProcessGroup* value) const</a>
<a name="ln127">	{</a>
<a name="ln128">		return value-&gt;id == key;</a>
<a name="ln129">	}</a>
<a name="ln130"> </a>
<a name="ln131">	ProcessGroup*&amp; GetLink(ProcessGroup* value) const</a>
<a name="ln132">	{</a>
<a name="ln133">		return value-&gt;next;</a>
<a name="ln134">	}</a>
<a name="ln135">};</a>
<a name="ln136"> </a>
<a name="ln137">typedef BOpenHashTable&lt;ProcessGroupHashDefinition&gt; ProcessGroupHashTable;</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">}	// unnamed namespace</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">// #pragma mark -</a>
<a name="ln144"> </a>
<a name="ln145"> </a>
<a name="ln146">// the team_id -&gt; Team hash table and the lock protecting it</a>
<a name="ln147">static TeamTable sTeamHash;</a>
<a name="ln148">static rw_spinlock sTeamHashLock = B_RW_SPINLOCK_INITIALIZER;</a>
<a name="ln149"> </a>
<a name="ln150">// the pid_t -&gt; ProcessGroup hash table and the lock protecting it</a>
<a name="ln151">static ProcessGroupHashTable sGroupHash;</a>
<a name="ln152">static spinlock sGroupHashLock = B_SPINLOCK_INITIALIZER;</a>
<a name="ln153"> </a>
<a name="ln154">static Team* sKernelTeam = NULL;</a>
<a name="ln155">static bool sDisableUserAddOns = false;</a>
<a name="ln156"> </a>
<a name="ln157">// A list of process groups of children of dying session leaders that need to</a>
<a name="ln158">// be signalled, if they have become orphaned and contain stopped processes.</a>
<a name="ln159">static ProcessGroupList sOrphanedCheckProcessGroups;</a>
<a name="ln160">static mutex sOrphanedCheckLock</a>
<a name="ln161">	= MUTEX_INITIALIZER(&quot;orphaned process group check&quot;);</a>
<a name="ln162"> </a>
<a name="ln163">// some arbitrarily chosen limits -- should probably depend on the available</a>
<a name="ln164">// memory (the limit is not yet enforced)</a>
<a name="ln165">static int32 sMaxTeams = 2048;</a>
<a name="ln166">static int32 sUsedTeams = 1;</a>
<a name="ln167"> </a>
<a name="ln168">static TeamNotificationService sNotificationService;</a>
<a name="ln169"> </a>
<a name="ln170">static const size_t kTeamUserDataReservedSize	= 128 * B_PAGE_SIZE;</a>
<a name="ln171">static const size_t kTeamUserDataInitialSize	= 4 * B_PAGE_SIZE;</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">// #pragma mark - TeamListIterator</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">TeamListIterator::TeamListIterator()</a>
<a name="ln178">{</a>
<a name="ln179">	// queue the entry</a>
<a name="ln180">	InterruptsWriteSpinLocker locker(sTeamHashLock);</a>
<a name="ln181">	sTeamHash.InsertIteratorEntry(&amp;fEntry);</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">TeamListIterator::~TeamListIterator()</a>
<a name="ln186">{</a>
<a name="ln187">	// remove the entry</a>
<a name="ln188">	InterruptsWriteSpinLocker locker(sTeamHashLock);</a>
<a name="ln189">	sTeamHash.RemoveIteratorEntry(&amp;fEntry);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">Team*</a>
<a name="ln194">TeamListIterator::Next()</a>
<a name="ln195">{</a>
<a name="ln196">	// get the next team -- if there is one, get reference for it</a>
<a name="ln197">	InterruptsWriteSpinLocker locker(sTeamHashLock);</a>
<a name="ln198">	Team* team = sTeamHash.NextElement(&amp;fEntry);</a>
<a name="ln199">	if (team != NULL)</a>
<a name="ln200">		team-&gt;AcquireReference();</a>
<a name="ln201"> </a>
<a name="ln202">	return team;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">// #pragma mark - Tracing</a>
<a name="ln207"> </a>
<a name="ln208"> </a>
<a name="ln209">#if TEAM_TRACING</a>
<a name="ln210">namespace TeamTracing {</a>
<a name="ln211"> </a>
<a name="ln212">class TeamForked : public AbstractTraceEntry {</a>
<a name="ln213">public:</a>
<a name="ln214">	TeamForked(thread_id forkedThread)</a>
<a name="ln215">		:</a>
<a name="ln216">		fForkedThread(forkedThread)</a>
<a name="ln217">	{</a>
<a name="ln218">		Initialized();</a>
<a name="ln219">	}</a>
<a name="ln220"> </a>
<a name="ln221">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln222">	{</a>
<a name="ln223">		out.Print(&quot;team forked, new thread %&quot; B_PRId32, fForkedThread);</a>
<a name="ln224">	}</a>
<a name="ln225"> </a>
<a name="ln226">private:</a>
<a name="ln227">	thread_id			fForkedThread;</a>
<a name="ln228">};</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">class ExecTeam : public AbstractTraceEntry {</a>
<a name="ln232">public:</a>
<a name="ln233">	ExecTeam(const char* path, int32 argCount, const char* const* args,</a>
<a name="ln234">			int32 envCount, const char* const* env)</a>
<a name="ln235">		:</a>
<a name="ln236">		fArgCount(argCount),</a>
<a name="ln237">		fArgs(NULL)</a>
<a name="ln238">	{</a>
<a name="ln239">		fPath = alloc_tracing_buffer_strcpy(path, B_PATH_NAME_LENGTH,</a>
<a name="ln240">			false);</a>
<a name="ln241"> </a>
<a name="ln242">		// determine the buffer size we need for the args</a>
<a name="ln243">		size_t argBufferSize = 0;</a>
<a name="ln244">		for (int32 i = 0; i &lt; argCount; i++)</a>
<a name="ln245">			argBufferSize += strlen(args[i]) + 1;</a>
<a name="ln246"> </a>
<a name="ln247">		// allocate a buffer</a>
<a name="ln248">		fArgs = (char*)alloc_tracing_buffer(argBufferSize);</a>
<a name="ln249">		if (fArgs) {</a>
<a name="ln250">			char* buffer = fArgs;</a>
<a name="ln251">			for (int32 i = 0; i &lt; argCount; i++) {</a>
<a name="ln252">				size_t argSize = strlen(args[i]) + 1;</a>
<a name="ln253">				memcpy(buffer, args[i], argSize);</a>
<a name="ln254">				buffer += argSize;</a>
<a name="ln255">			}</a>
<a name="ln256">		}</a>
<a name="ln257"> </a>
<a name="ln258">		// ignore env for the time being</a>
<a name="ln259">		(void)envCount;</a>
<a name="ln260">		(void)env;</a>
<a name="ln261"> </a>
<a name="ln262">		Initialized();</a>
<a name="ln263">	}</a>
<a name="ln264"> </a>
<a name="ln265">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln266">	{</a>
<a name="ln267">		out.Print(&quot;team exec, \&quot;%p\&quot;, args:&quot;, fPath);</a>
<a name="ln268"> </a>
<a name="ln269">		if (fArgs != NULL) {</a>
<a name="ln270">			char* args = fArgs;</a>
<a name="ln271">			for (int32 i = 0; !out.IsFull() &amp;&amp; i &lt; fArgCount; i++) {</a>
<a name="ln272">				out.Print(&quot; \&quot;%s\&quot;&quot;, args);</a>
<a name="ln273">				args += strlen(args) + 1;</a>
<a name="ln274">			}</a>
<a name="ln275">		} else</a>
<a name="ln276">			out.Print(&quot; &lt;too long&gt;&quot;);</a>
<a name="ln277">	}</a>
<a name="ln278"> </a>
<a name="ln279">private:</a>
<a name="ln280">	char*	fPath;</a>
<a name="ln281">	int32	fArgCount;</a>
<a name="ln282">	char*	fArgs;</a>
<a name="ln283">};</a>
<a name="ln284"> </a>
<a name="ln285"> </a>
<a name="ln286">static const char*</a>
<a name="ln287">job_control_state_name(job_control_state state)</a>
<a name="ln288">{</a>
<a name="ln289">	switch (state) {</a>
<a name="ln290">		case JOB_CONTROL_STATE_NONE:</a>
<a name="ln291">			return &quot;none&quot;;</a>
<a name="ln292">		case JOB_CONTROL_STATE_STOPPED:</a>
<a name="ln293">			return &quot;stopped&quot;;</a>
<a name="ln294">		case JOB_CONTROL_STATE_CONTINUED:</a>
<a name="ln295">			return &quot;continued&quot;;</a>
<a name="ln296">		case JOB_CONTROL_STATE_DEAD:</a>
<a name="ln297">			return &quot;dead&quot;;</a>
<a name="ln298">		default:</a>
<a name="ln299">			return &quot;invalid&quot;;</a>
<a name="ln300">	}</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">class SetJobControlState : public AbstractTraceEntry {</a>
<a name="ln305">public:</a>
<a name="ln306">	SetJobControlState(team_id team, job_control_state newState, Signal* signal)</a>
<a name="ln307">		:</a>
<a name="ln308">		fTeam(team),</a>
<a name="ln309">		fNewState(newState),</a>
<a name="ln310">		fSignal(signal != NULL ? signal-&gt;Number() : 0)</a>
<a name="ln311">	{</a>
<a name="ln312">		Initialized();</a>
<a name="ln313">	}</a>
<a name="ln314"> </a>
<a name="ln315">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln316">	{</a>
<a name="ln317">		out.Print(&quot;team set job control state, team %&quot; B_PRId32 &quot;, &quot;</a>
<a name="ln318">			&quot;new state: %s, signal: %d&quot;,</a>
<a name="ln319">			fTeam, job_control_state_name(fNewState), fSignal);</a>
<a name="ln320">	}</a>
<a name="ln321"> </a>
<a name="ln322">private:</a>
<a name="ln323">	team_id				fTeam;</a>
<a name="ln324">	job_control_state	fNewState;</a>
<a name="ln325">	int					fSignal;</a>
<a name="ln326">};</a>
<a name="ln327"> </a>
<a name="ln328"> </a>
<a name="ln329">class WaitForChild : public AbstractTraceEntry {</a>
<a name="ln330">public:</a>
<a name="ln331">	WaitForChild(pid_t child, uint32 flags)</a>
<a name="ln332">		:</a>
<a name="ln333">		fChild(child),</a>
<a name="ln334">		fFlags(flags)</a>
<a name="ln335">	{</a>
<a name="ln336">		Initialized();</a>
<a name="ln337">	}</a>
<a name="ln338"> </a>
<a name="ln339">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln340">	{</a>
<a name="ln341">		out.Print(&quot;team wait for child, child: %&quot; B_PRId32 &quot;, &quot;</a>
<a name="ln342">			&quot;flags: %#&quot; B_PRIx32, fChild, fFlags);</a>
<a name="ln343">	}</a>
<a name="ln344"> </a>
<a name="ln345">private:</a>
<a name="ln346">	pid_t	fChild;</a>
<a name="ln347">	uint32	fFlags;</a>
<a name="ln348">};</a>
<a name="ln349"> </a>
<a name="ln350"> </a>
<a name="ln351">class WaitForChildDone : public AbstractTraceEntry {</a>
<a name="ln352">public:</a>
<a name="ln353">	WaitForChildDone(const job_control_entry&amp; entry)</a>
<a name="ln354">		:</a>
<a name="ln355">		fState(entry.state),</a>
<a name="ln356">		fTeam(entry.thread),</a>
<a name="ln357">		fStatus(entry.status),</a>
<a name="ln358">		fReason(entry.reason),</a>
<a name="ln359">		fSignal(entry.signal)</a>
<a name="ln360">	{</a>
<a name="ln361">		Initialized();</a>
<a name="ln362">	}</a>
<a name="ln363"> </a>
<a name="ln364">	WaitForChildDone(status_t error)</a>
<a name="ln365">		:</a>
<a name="ln366">		fTeam(error)</a>
<a name="ln367">	{</a>
<a name="ln368">		Initialized();</a>
<a name="ln369">	}</a>
<a name="ln370"> </a>
<a name="ln371">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln372">	{</a>
<a name="ln373">		if (fTeam &gt;= 0) {</a>
<a name="ln374">			out.Print(&quot;team wait for child done, team: %&quot; B_PRId32 &quot;, &quot;</a>
<a name="ln375">				&quot;state: %s, status: %#&quot; B_PRIx32 &quot;, reason: %#x, signal: %d\n&quot;,</a>
<a name="ln376">				fTeam, job_control_state_name(fState), fStatus, fReason,</a>
<a name="ln377">				fSignal);</a>
<a name="ln378">		} else {</a>
<a name="ln379">			out.Print(&quot;team wait for child failed, error: &quot;</a>
<a name="ln380">				&quot;%#&quot; B_PRIx32 &quot;, &quot;, fTeam);</a>
<a name="ln381">		}</a>
<a name="ln382">	}</a>
<a name="ln383"> </a>
<a name="ln384">private:</a>
<a name="ln385">	job_control_state	fState;</a>
<a name="ln386">	team_id				fTeam;</a>
<a name="ln387">	status_t			fStatus;</a>
<a name="ln388">	uint16				fReason;</a>
<a name="ln389">	uint16				fSignal;</a>
<a name="ln390">};</a>
<a name="ln391"> </a>
<a name="ln392">}	// namespace TeamTracing</a>
<a name="ln393"> </a>
<a name="ln394">#	define T(x) new(std::nothrow) TeamTracing::x;</a>
<a name="ln395">#else</a>
<a name="ln396">#	define T(x) ;</a>
<a name="ln397">#endif</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">//	#pragma mark - TeamNotificationService</a>
<a name="ln401"> </a>
<a name="ln402"> </a>
<a name="ln403">TeamNotificationService::TeamNotificationService()</a>
<a name="ln404">	: DefaultNotificationService(&quot;teams&quot;)</a>
<a name="ln405">{</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408"> </a>
<a name="ln409">void</a>
<a name="ln410">TeamNotificationService::Notify(uint32 eventCode, Team* team)</a>
<a name="ln411">{</a>
<a name="ln412">	char eventBuffer[128];</a>
<a name="ln413">	KMessage event;</a>
<a name="ln414">	event.SetTo(eventBuffer, sizeof(eventBuffer), TEAM_MONITOR);</a>
<a name="ln415">	event.AddInt32(&quot;event&quot;, eventCode);</a>
<a name="ln416">	event.AddInt32(&quot;team&quot;, team-&gt;id);</a>
<a name="ln417">	event.AddPointer(&quot;teamStruct&quot;, team);</a>
<a name="ln418"> </a>
<a name="ln419">	DefaultNotificationService::Notify(event, eventCode);</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">//	#pragma mark - Team</a>
<a name="ln424"> </a>
<a name="ln425"> </a>
<a name="ln426">Team::Team(team_id id, bool kernel)</a>
<a name="ln427">{</a>
<a name="ln428">	// allocate an ID</a>
<a name="ln429">	this-&gt;id = id;</a>
<a name="ln430">	visible = true;</a>
<a name="ln431">	serial_number = -1;</a>
<a name="ln432"> </a>
<a name="ln433">	// init mutex</a>
<a name="ln434">	if (kernel) {</a>
<a name="ln435">		mutex_init(&amp;fLock, &quot;Team:kernel&quot;);</a>
<a name="ln436">	} else {</a>
<a name="ln437">		char lockName[16];</a>
<a name="ln438">		snprintf(lockName, sizeof(lockName), &quot;Team:%&quot; B_PRId32, id);</a>
<a name="ln439">		mutex_init_etc(&amp;fLock, lockName, MUTEX_FLAG_CLONE_NAME);</a>
<a name="ln440">	}</a>
<a name="ln441"> </a>
<a name="ln442">	hash_next = siblings_next = children = parent = NULL;</a>
<a name="ln443">	fName[0] = '\0';</a>
<a name="ln444">	fArgs[0] = '\0';</a>
<a name="ln445">	num_threads = 0;</a>
<a name="ln446">	io_context = NULL;</a>
<a name="ln447">	address_space = NULL;</a>
<a name="ln448">	realtime_sem_context = NULL;</a>
<a name="ln449">	xsi_sem_context = NULL;</a>
<a name="ln450">	thread_list = NULL;</a>
<a name="ln451">	main_thread = NULL;</a>
<a name="ln452">	loading_info = NULL;</a>
<a name="ln453">	state = TEAM_STATE_BIRTH;</a>
<a name="ln454">	flags = 0;</a>
<a name="ln455">	death_entry = NULL;</a>
<a name="ln456">	user_data_area = -1;</a>
<a name="ln457">	user_data = 0;</a>
<a name="ln458">	used_user_data = 0;</a>
<a name="ln459">	user_data_size = 0;</a>
<a name="ln460">	free_user_threads = NULL;</a>
<a name="ln461"> </a>
<a name="ln462">	commpage_address = NULL;</a>
<a name="ln463"> </a>
<a name="ln464">	supplementary_groups = NULL;</a>
<a name="ln465">	supplementary_group_count = 0;</a>
<a name="ln466"> </a>
<a name="ln467">	dead_threads_kernel_time = 0;</a>
<a name="ln468">	dead_threads_user_time = 0;</a>
<a name="ln469">	cpu_clock_offset = 0;</a>
<a name="ln470"> </a>
<a name="ln471">	// dead threads</a>
<a name="ln472">	list_init(&amp;dead_threads);</a>
<a name="ln473">	dead_threads_count = 0;</a>
<a name="ln474"> </a>
<a name="ln475">	// dead children</a>
<a name="ln476">	dead_children.count = 0;</a>
<a name="ln477">	dead_children.kernel_time = 0;</a>
<a name="ln478">	dead_children.user_time = 0;</a>
<a name="ln479"> </a>
<a name="ln480">	// job control entry</a>
<a name="ln481">	job_control_entry = new(nothrow) ::job_control_entry;</a>
<a name="ln482">	if (job_control_entry != NULL) {</a>
<a name="ln483">		job_control_entry-&gt;state = JOB_CONTROL_STATE_NONE;</a>
<a name="ln484">		job_control_entry-&gt;thread = id;</a>
<a name="ln485">		job_control_entry-&gt;team = this;</a>
<a name="ln486">	}</a>
<a name="ln487"> </a>
<a name="ln488">	// exit status -- setting initialized to false suffices</a>
<a name="ln489">	exit.initialized = false;</a>
<a name="ln490"> </a>
<a name="ln491">	list_init(&amp;sem_list);</a>
<a name="ln492">	list_init_etc(&amp;port_list, port_team_link_offset());</a>
<a name="ln493">	list_init(&amp;image_list);</a>
<a name="ln494">	list_init(&amp;watcher_list);</a>
<a name="ln495"> </a>
<a name="ln496">	clear_team_debug_info(&amp;debug_info, true);</a>
<a name="ln497"> </a>
<a name="ln498">	// init dead/stopped/continued children condition vars</a>
<a name="ln499">	dead_children.condition_variable.Init(&amp;dead_children, &quot;team children&quot;);</a>
<a name="ln500"> </a>
<a name="ln501">	B_INITIALIZE_SPINLOCK(&amp;time_lock);</a>
<a name="ln502">	B_INITIALIZE_SPINLOCK(&amp;signal_lock);</a>
<a name="ln503"> </a>
<a name="ln504">	fQueuedSignalsCounter = new(std::nothrow) BKernel::QueuedSignalsCounter(</a>
<a name="ln505">		kernel ? -1 : MAX_QUEUED_SIGNALS);</a>
<a name="ln506">	memset(fSignalActions, 0, sizeof(fSignalActions));</a>
<a name="ln507"> </a>
<a name="ln508">	fUserDefinedTimerCount = 0;</a>
<a name="ln509"> </a>
<a name="ln510">	fCoreDumpCondition = NULL;</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513"> </a>
<a name="ln514">Team::~Team()</a>
<a name="ln515">{</a>
<a name="ln516">	// get rid of all associated data</a>
<a name="ln517">	PrepareForDeletion();</a>
<a name="ln518"> </a>
<a name="ln519">	if (io_context != NULL)</a>
<a name="ln520">		vfs_put_io_context(io_context);</a>
<a name="ln521">	delete_owned_ports(this);</a>
<a name="ln522">	sem_delete_owned_sems(this);</a>
<a name="ln523"> </a>
<a name="ln524">	DeleteUserTimers(false);</a>
<a name="ln525"> </a>
<a name="ln526">	fPendingSignals.Clear();</a>
<a name="ln527"> </a>
<a name="ln528">	if (fQueuedSignalsCounter != NULL)</a>
<a name="ln529">		fQueuedSignalsCounter-&gt;ReleaseReference();</a>
<a name="ln530"> </a>
<a name="ln531">	while (thread_death_entry* threadDeathEntry</a>
<a name="ln532">			= (thread_death_entry*)list_remove_head_item(&amp;dead_threads)) {</a>
<a name="ln533">		free(threadDeathEntry);</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	while (::job_control_entry* entry = dead_children.entries.RemoveHead())</a>
<a name="ln537">		delete entry;</a>
<a name="ln538"> </a>
<a name="ln539">	while (free_user_thread* entry = free_user_threads) {</a>
<a name="ln540">		free_user_threads = entry-&gt;next;</a>
<a name="ln541">		free(entry);</a>
<a name="ln542">	}</a>
<a name="ln543"> </a>
<a name="ln544">	malloc_referenced_release(supplementary_groups);</a>
<a name="ln545"> </a>
<a name="ln546">	delete job_control_entry;</a>
<a name="ln547">		// usually already NULL and transferred to the parent</a>
<a name="ln548"> </a>
<a name="ln549">	mutex_destroy(&amp;fLock);</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552"> </a>
<a name="ln553">/*static*/ Team*</a>
<a name="ln554">Team::Create(team_id id, const char* name, bool kernel)</a>
<a name="ln555">{</a>
<a name="ln556">	// create the team object</a>
<a name="ln557">	Team* team = new(std::nothrow) Team(id, kernel);</a>
<a name="ln558">	if (team == NULL)</a>
<a name="ln559">		return NULL;</a>
<a name="ln560">	ObjectDeleter&lt;Team&gt; teamDeleter(team);</a>
<a name="ln561"> </a>
<a name="ln562">	if (name != NULL)</a>
<a name="ln563">		team-&gt;SetName(name);</a>
<a name="ln564"> </a>
<a name="ln565">	// check initialization</a>
<a name="ln566">	if (team-&gt;job_control_entry == NULL || team-&gt;fQueuedSignalsCounter == NULL)</a>
<a name="ln567">		return NULL;</a>
<a name="ln568"> </a>
<a name="ln569">	// finish initialization (arch specifics)</a>
<a name="ln570">	if (arch_team_init_team_struct(team, kernel) != B_OK)</a>
<a name="ln571">		return NULL;</a>
<a name="ln572"> </a>
<a name="ln573">	if (!kernel) {</a>
<a name="ln574">		status_t error = user_timer_create_team_timers(team);</a>
<a name="ln575">		if (error != B_OK)</a>
<a name="ln576">			return NULL;</a>
<a name="ln577">	}</a>
<a name="ln578"> </a>
<a name="ln579">	// everything went fine</a>
<a name="ln580">	return teamDeleter.Detach();</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">/*!	\brief Returns the team with the given ID.</a>
<a name="ln585">	Returns a reference to the team.</a>
<a name="ln586">	Team and thread spinlock must not be held.</a>
<a name="ln587">*/</a>
<a name="ln588">/*static*/ Team*</a>
<a name="ln589">Team::Get(team_id id)</a>
<a name="ln590">{</a>
<a name="ln591">	if (id == B_CURRENT_TEAM) {</a>
<a name="ln592">		Team* team = thread_get_current_thread()-&gt;team;</a>
<a name="ln593">		team-&gt;AcquireReference();</a>
<a name="ln594">		return team;</a>
<a name="ln595">	}</a>
<a name="ln596"> </a>
<a name="ln597">	InterruptsReadSpinLocker locker(sTeamHashLock);</a>
<a name="ln598">	Team* team = sTeamHash.Lookup(id);</a>
<a name="ln599">	if (team != NULL)</a>
<a name="ln600">		team-&gt;AcquireReference();</a>
<a name="ln601">	return team;</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604"> </a>
<a name="ln605">/*!	\brief Returns the team with the given ID in a locked state.</a>
<a name="ln606">	Returns a reference to the team.</a>
<a name="ln607">	Team and thread spinlock must not be held.</a>
<a name="ln608">*/</a>
<a name="ln609">/*static*/ Team*</a>
<a name="ln610">Team::GetAndLock(team_id id)</a>
<a name="ln611">{</a>
<a name="ln612">	// get the team</a>
<a name="ln613">	Team* team = Get(id);</a>
<a name="ln614">	if (team == NULL)</a>
<a name="ln615">		return NULL;</a>
<a name="ln616"> </a>
<a name="ln617">	// lock it</a>
<a name="ln618">	team-&gt;Lock();</a>
<a name="ln619"> </a>
<a name="ln620">	// only return the team, when it isn't already dying</a>
<a name="ln621">	if (team-&gt;state &gt;= TEAM_STATE_SHUTDOWN) {</a>
<a name="ln622">		team-&gt;Unlock();</a>
<a name="ln623">		team-&gt;ReleaseReference();</a>
<a name="ln624">		return NULL;</a>
<a name="ln625">	}</a>
<a name="ln626"> </a>
<a name="ln627">	return team;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">/*!	Locks the team and its parent team (if any).</a>
<a name="ln632">	The caller must hold a reference to the team or otherwise make sure that</a>
<a name="ln633">	it won't be deleted.</a>
<a name="ln634">	If the team doesn't have a parent, only the team itself is locked. If the</a>
<a name="ln635">	team's parent is the kernel team and \a dontLockParentIfKernel is \c true,</a>
<a name="ln636">	only the team itself is locked.</a>
<a name="ln637"> </a>
<a name="ln638">	\param dontLockParentIfKernel If \c true, the team's parent team is only</a>
<a name="ln639">		locked, if it is not the kernel team.</a>
<a name="ln640">*/</a>
<a name="ln641">void</a>
<a name="ln642">Team::LockTeamAndParent(bool dontLockParentIfKernel)</a>
<a name="ln643">{</a>
<a name="ln644">	// The locking order is parent -&gt; child. Since the parent can change as long</a>
<a name="ln645">	// as we don't lock the team, we need to do a trial and error loop.</a>
<a name="ln646">	Lock();</a>
<a name="ln647"> </a>
<a name="ln648">	while (true) {</a>
<a name="ln649">		// If the team doesn't have a parent, we're done. Otherwise try to lock</a>
<a name="ln650">		// the parent.This will succeed in most cases, simplifying things.</a>
<a name="ln651">		Team* parent = this-&gt;parent;</a>
<a name="ln652">		if (parent == NULL || (dontLockParentIfKernel &amp;&amp; parent == sKernelTeam)</a>
<a name="ln653">			|| parent-&gt;TryLock()) {</a>
<a name="ln654">			return;</a>
<a name="ln655">		}</a>
<a name="ln656"> </a>
<a name="ln657">		// get a temporary reference to the parent, unlock this team, lock the</a>
<a name="ln658">		// parent, and re-lock this team</a>
<a name="ln659">		BReference&lt;Team&gt; parentReference(parent);</a>
<a name="ln660"> </a>
<a name="ln661">		Unlock();</a>
<a name="ln662">		parent-&gt;Lock();</a>
<a name="ln663">		Lock();</a>
<a name="ln664"> </a>
<a name="ln665">		// If the parent hasn't changed in the meantime, we're done.</a>
<a name="ln666">		if (this-&gt;parent == parent)</a>
<a name="ln667">			return;</a>
<a name="ln668"> </a>
<a name="ln669">		// The parent has changed -- unlock and retry.</a>
<a name="ln670">		parent-&gt;Unlock();</a>
<a name="ln671">	}</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">/*!	Unlocks the team and its parent team (if any).</a>
<a name="ln676">*/</a>
<a name="ln677">void</a>
<a name="ln678">Team::UnlockTeamAndParent()</a>
<a name="ln679">{</a>
<a name="ln680">	if (parent != NULL)</a>
<a name="ln681">		parent-&gt;Unlock();</a>
<a name="ln682"> </a>
<a name="ln683">	Unlock();</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686"> </a>
<a name="ln687">/*!	Locks the team, its parent team (if any), and the team's process group.</a>
<a name="ln688">	The caller must hold a reference to the team or otherwise make sure that</a>
<a name="ln689">	it won't be deleted.</a>
<a name="ln690">	If the team doesn't have a parent, only the team itself is locked.</a>
<a name="ln691">*/</a>
<a name="ln692">void</a>
<a name="ln693">Team::LockTeamParentAndProcessGroup()</a>
<a name="ln694">{</a>
<a name="ln695">	LockTeamAndProcessGroup();</a>
<a name="ln696"> </a>
<a name="ln697">	// We hold the group's and the team's lock, but not the parent team's lock.</a>
<a name="ln698">	// If we have a parent, try to lock it.</a>
<a name="ln699">	if (this-&gt;parent == NULL || this-&gt;parent-&gt;TryLock())</a>
<a name="ln700">		return;</a>
<a name="ln701"> </a>
<a name="ln702">	// No success -- unlock the team and let LockTeamAndParent() do the rest of</a>
<a name="ln703">	// the job.</a>
<a name="ln704">	Unlock();</a>
<a name="ln705">	LockTeamAndParent(false);</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">/*!	Unlocks the team, its parent team (if any), and the team's process group.</a>
<a name="ln710">*/</a>
<a name="ln711">void</a>
<a name="ln712">Team::UnlockTeamParentAndProcessGroup()</a>
<a name="ln713">{</a>
<a name="ln714">	group-&gt;Unlock();</a>
<a name="ln715"> </a>
<a name="ln716">	if (parent != NULL)</a>
<a name="ln717">		parent-&gt;Unlock();</a>
<a name="ln718"> </a>
<a name="ln719">	Unlock();</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">void</a>
<a name="ln724">Team::LockTeamAndProcessGroup()</a>
<a name="ln725">{</a>
<a name="ln726">	// The locking order is process group -&gt; child. Since the process group can</a>
<a name="ln727">	// change as long as we don't lock the team, we need to do a trial and error</a>
<a name="ln728">	// loop.</a>
<a name="ln729">	Lock();</a>
<a name="ln730"> </a>
<a name="ln731">	while (true) {</a>
<a name="ln732">		// Try to lock the group. This will succeed in most cases, simplifying</a>
<a name="ln733">		// things.</a>
<a name="ln734">		ProcessGroup* group = this-&gt;group;</a>
<a name="ln735">		if (group-&gt;TryLock())</a>
<a name="ln736">			return;</a>
<a name="ln737"> </a>
<a name="ln738">		// get a temporary reference to the group, unlock this team, lock the</a>
<a name="ln739">		// group, and re-lock this team</a>
<a name="ln740">		BReference&lt;ProcessGroup&gt; groupReference(group);</a>
<a name="ln741"> </a>
<a name="ln742">		Unlock();</a>
<a name="ln743">		group-&gt;Lock();</a>
<a name="ln744">		Lock();</a>
<a name="ln745"> </a>
<a name="ln746">		// If the group hasn't changed in the meantime, we're done.</a>
<a name="ln747">		if (this-&gt;group == group)</a>
<a name="ln748">			return;</a>
<a name="ln749"> </a>
<a name="ln750">		// The group has changed -- unlock and retry.</a>
<a name="ln751">		group-&gt;Unlock();</a>
<a name="ln752">	}</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">void</a>
<a name="ln757">Team::UnlockTeamAndProcessGroup()</a>
<a name="ln758">{</a>
<a name="ln759">	group-&gt;Unlock();</a>
<a name="ln760">	Unlock();</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763"> </a>
<a name="ln764">void</a>
<a name="ln765">Team::SetName(const char* name)</a>
<a name="ln766">{</a>
<a name="ln767">	if (const char* lastSlash = strrchr(name, '/'))</a>
<a name="ln768">		name = lastSlash + 1;</a>
<a name="ln769"> </a>
<a name="ln770">	strlcpy(fName, name, B_OS_NAME_LENGTH);</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773"> </a>
<a name="ln774">void</a>
<a name="ln775">Team::SetArgs(const char* args)</a>
<a name="ln776">{</a>
<a name="ln777">	strlcpy(fArgs, args, sizeof(fArgs));</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780"> </a>
<a name="ln781">void</a>
<a name="ln782">Team::SetArgs(const char* path, const char* const* otherArgs, int otherArgCount)</a>
<a name="ln783">{</a>
<a name="ln784">	fArgs[0] = '\0';</a>
<a name="ln785">	strlcpy(fArgs, path, sizeof(fArgs));</a>
<a name="ln786">	for (int i = 0; i &lt; otherArgCount; i++) {</a>
<a name="ln787">		strlcat(fArgs, &quot; &quot;, sizeof(fArgs));</a>
<a name="ln788">		strlcat(fArgs, otherArgs[i], sizeof(fArgs));</a>
<a name="ln789">	}</a>
<a name="ln790">}</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">void</a>
<a name="ln794">Team::ResetSignalsOnExec()</a>
<a name="ln795">{</a>
<a name="ln796">	// We are supposed to keep pending signals. Signal actions shall be reset</a>
<a name="ln797">	// partially: SIG_IGN and SIG_DFL dispositions shall be kept as they are</a>
<a name="ln798">	// (for SIGCHLD it's implementation-defined). Others shall be reset to</a>
<a name="ln799">	// SIG_DFL. SA_ONSTACK shall be cleared. There's no mention of the other</a>
<a name="ln800">	// flags, but since there aren't any handlers, they make little sense, so</a>
<a name="ln801">	// we clear them.</a>
<a name="ln802"> </a>
<a name="ln803">	for (uint32 i = 1; i &lt;= MAX_SIGNAL_NUMBER; i++) {</a>
<a name="ln804">		struct sigaction&amp; action = SignalActionFor(i);</a>
<a name="ln805">		if (action.sa_handler != SIG_IGN &amp;&amp; action.sa_handler != SIG_DFL)</a>
<a name="ln806">			action.sa_handler = SIG_DFL;</a>
<a name="ln807"> </a>
<a name="ln808">		action.sa_mask = 0;</a>
<a name="ln809">		action.sa_flags = 0;</a>
<a name="ln810">		action.sa_userdata = NULL;</a>
<a name="ln811">	}</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814"> </a>
<a name="ln815">void</a>
<a name="ln816">Team::InheritSignalActions(Team* parent)</a>
<a name="ln817">{</a>
<a name="ln818">	memcpy(fSignalActions, parent-&gt;fSignalActions, sizeof(fSignalActions));</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821"> </a>
<a name="ln822">/*!	Adds the given user timer to the team and, if user-defined, assigns it an</a>
<a name="ln823">	ID.</a>
<a name="ln824"> </a>
<a name="ln825">	The caller must hold the team's lock.</a>
<a name="ln826"> </a>
<a name="ln827">	\param timer The timer to be added. If it doesn't have an ID yet, it is</a>
<a name="ln828">		considered user-defined and will be assigned an ID.</a>
<a name="ln829">	\return \c B_OK, if the timer was added successfully, another error code</a>
<a name="ln830">		otherwise.</a>
<a name="ln831">*/</a>
<a name="ln832">status_t</a>
<a name="ln833">Team::AddUserTimer(UserTimer* timer)</a>
<a name="ln834">{</a>
<a name="ln835">	// don't allow addition of timers when already shutting the team down</a>
<a name="ln836">	if (state &gt;= TEAM_STATE_SHUTDOWN)</a>
<a name="ln837">		return B_BAD_TEAM_ID;</a>
<a name="ln838"> </a>
<a name="ln839">	// If the timer is user-defined, check timer limit and increment</a>
<a name="ln840">	// user-defined count.</a>
<a name="ln841">	if (timer-&gt;ID() &lt; 0 &amp;&amp; !CheckAddUserDefinedTimer())</a>
<a name="ln842">		return EAGAIN;</a>
<a name="ln843"> </a>
<a name="ln844">	fUserTimers.AddTimer(timer);</a>
<a name="ln845"> </a>
<a name="ln846">	return B_OK;</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849"> </a>
<a name="ln850">/*!	Removes the given user timer from the team.</a>
<a name="ln851"> </a>
<a name="ln852">	The caller must hold the team's lock.</a>
<a name="ln853"> </a>
<a name="ln854">	\param timer The timer to be removed.</a>
<a name="ln855"> </a>
<a name="ln856">*/</a>
<a name="ln857">void</a>
<a name="ln858">Team::RemoveUserTimer(UserTimer* timer)</a>
<a name="ln859">{</a>
<a name="ln860">	fUserTimers.RemoveTimer(timer);</a>
<a name="ln861"> </a>
<a name="ln862">	if (timer-&gt;ID() &gt;= USER_TIMER_FIRST_USER_DEFINED_ID)</a>
<a name="ln863">		UserDefinedTimersRemoved(1);</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866"> </a>
<a name="ln867">/*!	Deletes all (or all user-defined) user timers of the team.</a>
<a name="ln868"> </a>
<a name="ln869">	Timer's belonging to the team's threads are not affected.</a>
<a name="ln870">	The caller must hold the team's lock.</a>
<a name="ln871"> </a>
<a name="ln872">	\param userDefinedOnly If \c true, only the user-defined timers are deleted,</a>
<a name="ln873">		otherwise all timers are deleted.</a>
<a name="ln874">*/</a>
<a name="ln875">void</a>
<a name="ln876">Team::DeleteUserTimers(bool userDefinedOnly)</a>
<a name="ln877">{</a>
<a name="ln878">	int32 count = fUserTimers.DeleteTimers(userDefinedOnly);</a>
<a name="ln879">	UserDefinedTimersRemoved(count);</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882"> </a>
<a name="ln883">/*!	If not at the limit yet, increments the team's user-defined timer count.</a>
<a name="ln884">	\return \c true, if the limit wasn't reached yet, \c false otherwise.</a>
<a name="ln885">*/</a>
<a name="ln886">bool</a>
<a name="ln887">Team::CheckAddUserDefinedTimer()</a>
<a name="ln888">{</a>
<a name="ln889">	int32 oldCount = atomic_add(&amp;fUserDefinedTimerCount, 1);</a>
<a name="ln890">	if (oldCount &gt;= MAX_USER_TIMERS_PER_TEAM) {</a>
<a name="ln891">		atomic_add(&amp;fUserDefinedTimerCount, -1);</a>
<a name="ln892">		return false;</a>
<a name="ln893">	}</a>
<a name="ln894"> </a>
<a name="ln895">	return true;</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898"> </a>
<a name="ln899">/*!	Subtracts the given count for the team's user-defined timer count.</a>
<a name="ln900">	\param count The count to subtract.</a>
<a name="ln901">*/</a>
<a name="ln902">void</a>
<a name="ln903">Team::UserDefinedTimersRemoved(int32 count)</a>
<a name="ln904">{</a>
<a name="ln905">	atomic_add(&amp;fUserDefinedTimerCount, -count);</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908"> </a>
<a name="ln909">void</a>
<a name="ln910">Team::DeactivateCPUTimeUserTimers()</a>
<a name="ln911">{</a>
<a name="ln912">	while (TeamTimeUserTimer* timer = fCPUTimeUserTimers.Head())</a>
<a name="ln913">		timer-&gt;Deactivate();</a>
<a name="ln914"> </a>
<a name="ln915">	while (TeamUserTimeUserTimer* timer = fUserTimeUserTimers.Head())</a>
<a name="ln916">		timer-&gt;Deactivate();</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919"> </a>
<a name="ln920">/*!	Returns the team's current total CPU time (kernel + user + offset).</a>
<a name="ln921"> </a>
<a name="ln922">	The caller must hold \c time_lock.</a>
<a name="ln923"> </a>
<a name="ln924">	\param ignoreCurrentRun If \c true and the current thread is one team's</a>
<a name="ln925">		threads, don't add the time since the last time \c last_time was</a>
<a name="ln926">		updated. Should be used in &quot;thread unscheduled&quot; scheduler callbacks,</a>
<a name="ln927">		since although the thread is still running at that time, its time has</a>
<a name="ln928">		already been stopped.</a>
<a name="ln929">	\return The team's current total CPU time.</a>
<a name="ln930">*/</a>
<a name="ln931">bigtime_t</a>
<a name="ln932">Team::CPUTime(bool ignoreCurrentRun, Thread* lockedThread) const</a>
<a name="ln933">{</a>
<a name="ln934">	bigtime_t time = cpu_clock_offset + dead_threads_kernel_time</a>
<a name="ln935">		+ dead_threads_user_time;</a>
<a name="ln936"> </a>
<a name="ln937">	Thread* currentThread = thread_get_current_thread();</a>
<a name="ln938">	bigtime_t now = system_time();</a>
<a name="ln939"> </a>
<a name="ln940">	for (Thread* thread = thread_list; thread != NULL;</a>
<a name="ln941">			thread = thread-&gt;team_next) {</a>
<a name="ln942">		bool alreadyLocked = thread == lockedThread;</a>
<a name="ln943">		SpinLocker threadTimeLocker(thread-&gt;time_lock, alreadyLocked);</a>
<a name="ln944">		time += thread-&gt;kernel_time + thread-&gt;user_time;</a>
<a name="ln945"> </a>
<a name="ln946">		if (thread-&gt;last_time != 0) {</a>
<a name="ln947">			if (!ignoreCurrentRun || thread != currentThread)</a>
<a name="ln948">				time += now - thread-&gt;last_time;</a>
<a name="ln949">		}</a>
<a name="ln950"> </a>
<a name="ln951">		if (alreadyLocked)</a>
<a name="ln952">			threadTimeLocker.Detach();</a>
<a name="ln953">	}</a>
<a name="ln954"> </a>
<a name="ln955">	return time;</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958"> </a>
<a name="ln959">/*!	Returns the team's current user CPU time.</a>
<a name="ln960"> </a>
<a name="ln961">	The caller must hold \c time_lock.</a>
<a name="ln962"> </a>
<a name="ln963">	\return The team's current user CPU time.</a>
<a name="ln964">*/</a>
<a name="ln965">bigtime_t</a>
<a name="ln966">Team::UserCPUTime() const</a>
<a name="ln967">{</a>
<a name="ln968">	bigtime_t time = dead_threads_user_time;</a>
<a name="ln969"> </a>
<a name="ln970">	bigtime_t now = system_time();</a>
<a name="ln971"> </a>
<a name="ln972">	for (Thread* thread = thread_list; thread != NULL;</a>
<a name="ln973">			thread = thread-&gt;team_next) {</a>
<a name="ln974">		SpinLocker threadTimeLocker(thread-&gt;time_lock);</a>
<a name="ln975">		time += thread-&gt;user_time;</a>
<a name="ln976"> </a>
<a name="ln977">		if (thread-&gt;last_time != 0 &amp;&amp; !thread-&gt;in_kernel)</a>
<a name="ln978">			time += now - thread-&gt;last_time;</a>
<a name="ln979">	}</a>
<a name="ln980"> </a>
<a name="ln981">	return time;</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984"> </a>
<a name="ln985">//	#pragma mark - ProcessGroup</a>
<a name="ln986"> </a>
<a name="ln987"> </a>
<a name="ln988">ProcessGroup::ProcessGroup(pid_t id)</a>
<a name="ln989">	:</a>
<a name="ln990">	id(id),</a>
<a name="ln991">	teams(NULL),</a>
<a name="ln992">	fSession(NULL),</a>
<a name="ln993">	fInOrphanedCheckList(false)</a>
<a name="ln994">{</a>
<a name="ln995">	char lockName[32];</a>
<a name="ln996">	snprintf(lockName, sizeof(lockName), &quot;Group:%&quot; B_PRId32, id);</a>
<a name="ln997">	mutex_init_etc(&amp;fLock, lockName, MUTEX_FLAG_CLONE_NAME);</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000"> </a>
<a name="ln1001">ProcessGroup::~ProcessGroup()</a>
<a name="ln1002">{</a>
<a name="ln1003">	TRACE((&quot;ProcessGroup::~ProcessGroup(): id = %&quot; B_PRId32 &quot;\n&quot;, id));</a>
<a name="ln1004"> </a>
<a name="ln1005">	// If the group is in the orphaned check list, remove it.</a>
<a name="ln1006">	MutexLocker orphanedCheckLocker(sOrphanedCheckLock);</a>
<a name="ln1007"> </a>
<a name="ln1008">	if (fInOrphanedCheckList)</a>
<a name="ln1009">		sOrphanedCheckProcessGroups.Remove(this);</a>
<a name="ln1010"> </a>
<a name="ln1011">	orphanedCheckLocker.Unlock();</a>
<a name="ln1012"> </a>
<a name="ln1013">	// remove group from the hash table and from the session</a>
<a name="ln1014">	if (fSession != NULL) {</a>
<a name="ln1015">		InterruptsSpinLocker groupHashLocker(sGroupHashLock);</a>
<a name="ln1016">		sGroupHash.RemoveUnchecked(this);</a>
<a name="ln1017">		groupHashLocker.Unlock();</a>
<a name="ln1018"> </a>
<a name="ln1019">		fSession-&gt;ReleaseReference();</a>
<a name="ln1020">	}</a>
<a name="ln1021"> </a>
<a name="ln1022">	mutex_destroy(&amp;fLock);</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025"> </a>
<a name="ln1026">/*static*/ ProcessGroup*</a>
<a name="ln1027">ProcessGroup::Get(pid_t id)</a>
<a name="ln1028">{</a>
<a name="ln1029">	InterruptsSpinLocker groupHashLocker(sGroupHashLock);</a>
<a name="ln1030">	ProcessGroup* group = sGroupHash.Lookup(id);</a>
<a name="ln1031">	if (group != NULL)</a>
<a name="ln1032">		group-&gt;AcquireReference();</a>
<a name="ln1033">	return group;</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">/*!	Adds the group the given session and makes it publicly accessible.</a>
<a name="ln1038">	The caller must not hold the process group hash lock.</a>
<a name="ln1039">*/</a>
<a name="ln1040">void</a>
<a name="ln1041">ProcessGroup::Publish(ProcessSession* session)</a>
<a name="ln1042">{</a>
<a name="ln1043">	InterruptsSpinLocker groupHashLocker(sGroupHashLock);</a>
<a name="ln1044">	PublishLocked(session);</a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047"> </a>
<a name="ln1048">/*!	Adds the group to the given session and makes it publicly accessible.</a>
<a name="ln1049">	The caller must hold the process group hash lock.</a>
<a name="ln1050">*/</a>
<a name="ln1051">void</a>
<a name="ln1052">ProcessGroup::PublishLocked(ProcessSession* session)</a>
<a name="ln1053">{</a>
<a name="ln1054">	ASSERT(sGroupHash.Lookup(this-&gt;id) == NULL);</a>
<a name="ln1055"> </a>
<a name="ln1056">	fSession = session;</a>
<a name="ln1057">	fSession-&gt;AcquireReference();</a>
<a name="ln1058"> </a>
<a name="ln1059">	sGroupHash.InsertUnchecked(this);</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062"> </a>
<a name="ln1063">/*!	Checks whether the process group is orphaned.</a>
<a name="ln1064">	The caller must hold the group's lock.</a>
<a name="ln1065">	\return \c true, if the group is orphaned, \c false otherwise.</a>
<a name="ln1066">*/</a>
<a name="ln1067">bool</a>
<a name="ln1068">ProcessGroup::IsOrphaned() const</a>
<a name="ln1069">{</a>
<a name="ln1070">	// Orphaned Process Group: &quot;A process group in which the parent of every</a>
<a name="ln1071">	// member is either itself a member of the group or is not a member of the</a>
<a name="ln1072">	// group's session.&quot; (Open Group Base Specs Issue 7)</a>
<a name="ln1073">	bool orphaned = true;</a>
<a name="ln1074"> </a>
<a name="ln1075">	Team* team = teams;</a>
<a name="ln1076">	while (orphaned &amp;&amp; team != NULL) {</a>
<a name="ln1077">		team-&gt;LockTeamAndParent(false);</a>
<a name="ln1078"> </a>
<a name="ln1079">		Team* parent = team-&gt;parent;</a>
<a name="ln1080">		if (parent != NULL &amp;&amp; parent-&gt;group_id != id</a>
<a name="ln1081">			&amp;&amp; parent-&gt;session_id == fSession-&gt;id) {</a>
<a name="ln1082">			orphaned = false;</a>
<a name="ln1083">		}</a>
<a name="ln1084"> </a>
<a name="ln1085">		team-&gt;UnlockTeamAndParent();</a>
<a name="ln1086"> </a>
<a name="ln1087">		team = team-&gt;group_next;</a>
<a name="ln1088">	}</a>
<a name="ln1089"> </a>
<a name="ln1090">	return orphaned;</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093"> </a>
<a name="ln1094">void</a>
<a name="ln1095">ProcessGroup::ScheduleOrphanedCheck()</a>
<a name="ln1096">{</a>
<a name="ln1097">	MutexLocker orphanedCheckLocker(sOrphanedCheckLock);</a>
<a name="ln1098"> </a>
<a name="ln1099">	if (!fInOrphanedCheckList) {</a>
<a name="ln1100">		sOrphanedCheckProcessGroups.Add(this);</a>
<a name="ln1101">		fInOrphanedCheckList = true;</a>
<a name="ln1102">	}</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105"> </a>
<a name="ln1106">void</a>
<a name="ln1107">ProcessGroup::UnsetOrphanedCheck()</a>
<a name="ln1108">{</a>
<a name="ln1109">	fInOrphanedCheckList = false;</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112"> </a>
<a name="ln1113">//	#pragma mark - ProcessSession</a>
<a name="ln1114"> </a>
<a name="ln1115"> </a>
<a name="ln1116">ProcessSession::ProcessSession(pid_t id)</a>
<a name="ln1117">	:</a>
<a name="ln1118">	id(id),</a>
<a name="ln1119">	controlling_tty(-1),</a>
<a name="ln1120">	foreground_group(-1)</a>
<a name="ln1121">{</a>
<a name="ln1122">	char lockName[32];</a>
<a name="ln1123">	snprintf(lockName, sizeof(lockName), &quot;Session:%&quot; B_PRId32, id);</a>
<a name="ln1124">	mutex_init_etc(&amp;fLock, lockName, MUTEX_FLAG_CLONE_NAME);</a>
<a name="ln1125">}</a>
<a name="ln1126"> </a>
<a name="ln1127"> </a>
<a name="ln1128">ProcessSession::~ProcessSession()</a>
<a name="ln1129">{</a>
<a name="ln1130">	mutex_destroy(&amp;fLock);</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133"> </a>
<a name="ln1134">//	#pragma mark - KDL functions</a>
<a name="ln1135"> </a>
<a name="ln1136"> </a>
<a name="ln1137">static void</a>
<a name="ln1138">_dump_team_info(Team* team)</a>
<a name="ln1139">{</a>
<a name="ln1140">	kprintf(&quot;TEAM: %p\n&quot;, team);</a>
<a name="ln1141">	kprintf(&quot;id:               %&quot; B_PRId32 &quot; (%#&quot; B_PRIx32 &quot;)\n&quot;, team-&gt;id,</a>
<a name="ln1142">		team-&gt;id);</a>
<a name="ln1143">	kprintf(&quot;serial_number:    %&quot; B_PRId64 &quot;\n&quot;, team-&gt;serial_number);</a>
<a name="ln1144">	kprintf(&quot;name:             '%s'\n&quot;, team-&gt;Name());</a>
<a name="ln1145">	kprintf(&quot;args:             '%s'\n&quot;, team-&gt;Args());</a>
<a name="ln1146">	kprintf(&quot;hash_next:        %p\n&quot;, team-&gt;hash_next);</a>
<a name="ln1147">	kprintf(&quot;parent:           %p&quot;, team-&gt;parent);</a>
<a name="ln1148">	if (team-&gt;parent != NULL) {</a>
<a name="ln1149">		kprintf(&quot; (id = %&quot; B_PRId32 &quot;)\n&quot;, team-&gt;parent-&gt;id);</a>
<a name="ln1150">	} else</a>
<a name="ln1151">		kprintf(&quot;\n&quot;);</a>
<a name="ln1152"> </a>
<a name="ln1153">	kprintf(&quot;children:         %p\n&quot;, team-&gt;children);</a>
<a name="ln1154">	kprintf(&quot;num_threads:      %d\n&quot;, team-&gt;num_threads);</a>
<a name="ln1155">	kprintf(&quot;state:            %d\n&quot;, team-&gt;state);</a>
<a name="ln1156">	kprintf(&quot;flags:            0x%&quot; B_PRIx32 &quot;\n&quot;, team-&gt;flags);</a>
<a name="ln1157">	kprintf(&quot;io_context:       %p\n&quot;, team-&gt;io_context);</a>
<a name="ln1158">	if (team-&gt;address_space)</a>
<a name="ln1159">		kprintf(&quot;address_space:    %p\n&quot;, team-&gt;address_space);</a>
<a name="ln1160">	kprintf(&quot;user data:        %p (area %&quot; B_PRId32 &quot;)\n&quot;,</a>
<a name="ln1161">		(void*)team-&gt;user_data, team-&gt;user_data_area);</a>
<a name="ln1162">	kprintf(&quot;free user thread: %p\n&quot;, team-&gt;free_user_threads);</a>
<a name="ln1163">	kprintf(&quot;main_thread:      %p\n&quot;, team-&gt;main_thread);</a>
<a name="ln1164">	kprintf(&quot;thread_list:      %p\n&quot;, team-&gt;thread_list);</a>
<a name="ln1165">	kprintf(&quot;group_id:         %&quot; B_PRId32 &quot;\n&quot;, team-&gt;group_id);</a>
<a name="ln1166">	kprintf(&quot;session_id:       %&quot; B_PRId32 &quot;\n&quot;, team-&gt;session_id);</a>
<a name="ln1167">}</a>
<a name="ln1168"> </a>
<a name="ln1169"> </a>
<a name="ln1170">static int</a>
<a name="ln1171">dump_team_info(int argc, char** argv)</a>
<a name="ln1172">{</a>
<a name="ln1173">	ulong arg;</a>
<a name="ln1174">	bool found = false;</a>
<a name="ln1175"> </a>
<a name="ln1176">	if (argc &lt; 2) {</a>
<a name="ln1177">		Thread* thread = thread_get_current_thread();</a>
<a name="ln1178">		if (thread != NULL &amp;&amp; thread-&gt;team != NULL)</a>
<a name="ln1179">			_dump_team_info(thread-&gt;team);</a>
<a name="ln1180">		else</a>
<a name="ln1181">			kprintf(&quot;No current team!\n&quot;);</a>
<a name="ln1182">		return 0;</a>
<a name="ln1183">	}</a>
<a name="ln1184"> </a>
<a name="ln1185">	arg = strtoul(argv[1], NULL, 0);</a>
<a name="ln1186">	if (IS_KERNEL_ADDRESS(arg)) {</a>
<a name="ln1187">		// semi-hack</a>
<a name="ln1188">		_dump_team_info((Team*)arg);</a>
<a name="ln1189">		return 0;</a>
<a name="ln1190">	}</a>
<a name="ln1191"> </a>
<a name="ln1192">	// walk through the thread list, trying to match name or id</a>
<a name="ln1193">	for (TeamTable::Iterator it = sTeamHash.GetIterator();</a>
<a name="ln1194">		Team* team = it.Next();) {</a>
<a name="ln1195">		if ((team-&gt;Name() &amp;&amp; strcmp(argv[1], team-&gt;Name()) == 0)</a>
<a name="ln1196">			|| team-&gt;id == (team_id)arg) {</a>
<a name="ln1197">			_dump_team_info(team);</a>
<a name="ln1198">			found = true;</a>
<a name="ln1199">			break;</a>
<a name="ln1200">		}</a>
<a name="ln1201">	}</a>
<a name="ln1202"> </a>
<a name="ln1203">	if (!found)</a>
<a name="ln1204">		kprintf(&quot;team \&quot;%s\&quot; (%&quot; B_PRId32 &quot;) doesn't exist!\n&quot;, argv[1], (team_id)arg);</a>
<a name="ln1205">	return 0;</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208"> </a>
<a name="ln1209">static int</a>
<a name="ln1210">dump_teams(int argc, char** argv)</a>
<a name="ln1211">{</a>
<a name="ln1212">	kprintf(&quot;%-*s       id  %-*s    name\n&quot;, B_PRINTF_POINTER_WIDTH, &quot;team&quot;,</a>
<a name="ln1213">		B_PRINTF_POINTER_WIDTH, &quot;parent&quot;);</a>
<a name="ln1214"> </a>
<a name="ln1215">	for (TeamTable::Iterator it = sTeamHash.GetIterator();</a>
<a name="ln1216">		Team* team = it.Next();) {</a>
<a name="ln1217">		kprintf(&quot;%p%7&quot; B_PRId32 &quot;  %p  %s\n&quot;, team, team-&gt;id, team-&gt;parent, team-&gt;Name());</a>
<a name="ln1218">	}</a>
<a name="ln1219"> </a>
<a name="ln1220">	return 0;</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223"> </a>
<a name="ln1224">//	#pragma mark - Private functions</a>
<a name="ln1225"> </a>
<a name="ln1226"> </a>
<a name="ln1227">/*!	Inserts team \a team into the child list of team \a parent.</a>
<a name="ln1228"> </a>
<a name="ln1229">	The caller must hold the lock of both \a parent and \a team.</a>
<a name="ln1230"> </a>
<a name="ln1231">	\param parent The parent team.</a>
<a name="ln1232">	\param team The team to be inserted into \a parent's child list.</a>
<a name="ln1233">*/</a>
<a name="ln1234">static void</a>
<a name="ln1235">insert_team_into_parent(Team* parent, Team* team)</a>
<a name="ln1236">{</a>
<a name="ln1237">	ASSERT(parent != NULL);</a>
<a name="ln1238"> </a>
<a name="ln1239">	team-&gt;siblings_next = parent-&gt;children;</a>
<a name="ln1240">	parent-&gt;children = team;</a>
<a name="ln1241">	team-&gt;parent = parent;</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244"> </a>
<a name="ln1245">/*!	Removes team \a team from the child list of team \a parent.</a>
<a name="ln1246"> </a>
<a name="ln1247">	The caller must hold the lock of both \a parent and \a team.</a>
<a name="ln1248"> </a>
<a name="ln1249">	\param parent The parent team.</a>
<a name="ln1250">	\param team The team to be removed from \a parent's child list.</a>
<a name="ln1251">*/</a>
<a name="ln1252">static void</a>
<a name="ln1253">remove_team_from_parent(Team* parent, Team* team)</a>
<a name="ln1254">{</a>
<a name="ln1255">	Team* child;</a>
<a name="ln1256">	Team* last = NULL;</a>
<a name="ln1257"> </a>
<a name="ln1258">	for (child = parent-&gt;children; child != NULL;</a>
<a name="ln1259">			child = child-&gt;siblings_next) {</a>
<a name="ln1260">		if (child == team) {</a>
<a name="ln1261">			if (last == NULL)</a>
<a name="ln1262">				parent-&gt;children = child-&gt;siblings_next;</a>
<a name="ln1263">			else</a>
<a name="ln1264">				last-&gt;siblings_next = child-&gt;siblings_next;</a>
<a name="ln1265"> </a>
<a name="ln1266">			team-&gt;parent = NULL;</a>
<a name="ln1267">			break;</a>
<a name="ln1268">		}</a>
<a name="ln1269">		last = child;</a>
<a name="ln1270">	}</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273"> </a>
<a name="ln1274">/*!	Returns whether the given team is a session leader.</a>
<a name="ln1275">	The caller must hold the team's lock or its process group's lock.</a>
<a name="ln1276">*/</a>
<a name="ln1277">static bool</a>
<a name="ln1278">is_session_leader(Team* team)</a>
<a name="ln1279">{</a>
<a name="ln1280">	return team-&gt;session_id == team-&gt;id;</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283"> </a>
<a name="ln1284">/*!	Returns whether the given team is a process group leader.</a>
<a name="ln1285">	The caller must hold the team's lock or its process group's lock.</a>
<a name="ln1286">*/</a>
<a name="ln1287">static bool</a>
<a name="ln1288">is_process_group_leader(Team* team)</a>
<a name="ln1289">{</a>
<a name="ln1290">	return team-&gt;group_id == team-&gt;id;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293"> </a>
<a name="ln1294">/*!	Inserts the given team into the given process group.</a>
<a name="ln1295">	The caller must hold the process group's lock, the team's lock, and the</a>
<a name="ln1296">	team's parent's lock.</a>
<a name="ln1297">*/</a>
<a name="ln1298">static void</a>
<a name="ln1299">insert_team_into_group(ProcessGroup* group, Team* team)</a>
<a name="ln1300">{</a>
<a name="ln1301">	team-&gt;group = group;</a>
<a name="ln1302">	team-&gt;group_id = group-&gt;id;</a>
<a name="ln1303">	team-&gt;session_id = group-&gt;Session()-&gt;id;</a>
<a name="ln1304"> </a>
<a name="ln1305">	team-&gt;group_next = group-&gt;teams;</a>
<a name="ln1306">	group-&gt;teams = team;</a>
<a name="ln1307">	group-&gt;AcquireReference();</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">/*!	Removes the given team from its process group.</a>
<a name="ln1312"> </a>
<a name="ln1313">	The caller must hold the process group's lock, the team's lock, and the</a>
<a name="ln1314">	team's parent's lock. Interrupts must be enabled.</a>
<a name="ln1315"> </a>
<a name="ln1316">	\param team The team that'll be removed from its process group.</a>
<a name="ln1317">*/</a>
<a name="ln1318">static void</a>
<a name="ln1319">remove_team_from_group(Team* team)</a>
<a name="ln1320">{</a>
<a name="ln1321">	ProcessGroup* group = team-&gt;group;</a>
<a name="ln1322">	Team* current;</a>
<a name="ln1323">	Team* last = NULL;</a>
<a name="ln1324"> </a>
<a name="ln1325">	// the team must be in a process group to let this function have any effect</a>
<a name="ln1326">	if  (group == NULL)</a>
<a name="ln1327">		return;</a>
<a name="ln1328"> </a>
<a name="ln1329">	for (current = group-&gt;teams; current != NULL;</a>
<a name="ln1330">			current = current-&gt;group_next) {</a>
<a name="ln1331">		if (current == team) {</a>
<a name="ln1332">			if (last == NULL)</a>
<a name="ln1333">				group-&gt;teams = current-&gt;group_next;</a>
<a name="ln1334">			else</a>
<a name="ln1335">				last-&gt;group_next = current-&gt;group_next;</a>
<a name="ln1336"> </a>
<a name="ln1337">			team-&gt;group = NULL;</a>
<a name="ln1338">			break;</a>
<a name="ln1339">		}</a>
<a name="ln1340">		last = current;</a>
<a name="ln1341">	}</a>
<a name="ln1342"> </a>
<a name="ln1343">	team-&gt;group = NULL;</a>
<a name="ln1344">	team-&gt;group_next = NULL;</a>
<a name="ln1345"> </a>
<a name="ln1346">	group-&gt;ReleaseReference();</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349"> </a>
<a name="ln1350">static status_t</a>
<a name="ln1351">create_team_user_data(Team* team, void* exactAddress = NULL)</a>
<a name="ln1352">{</a>
<a name="ln1353">	void* address;</a>
<a name="ln1354">	uint32 addressSpec;</a>
<a name="ln1355"> </a>
<a name="ln1356">	if (exactAddress != NULL) {</a>
<a name="ln1357">		address = exactAddress;</a>
<a name="ln1358">		addressSpec = B_EXACT_ADDRESS;</a>
<a name="ln1359">	} else {</a>
<a name="ln1360">		address = (void*)KERNEL_USER_DATA_BASE;</a>
<a name="ln1361">		addressSpec = B_RANDOMIZED_BASE_ADDRESS;</a>
<a name="ln1362">	}</a>
<a name="ln1363"> </a>
<a name="ln1364">	status_t result = vm_reserve_address_range(team-&gt;id, &amp;address, addressSpec,</a>
<a name="ln1365">		kTeamUserDataReservedSize, RESERVED_AVOID_BASE);</a>
<a name="ln1366"> </a>
<a name="ln1367">	virtual_address_restrictions virtualRestrictions = {};</a>
<a name="ln1368">	if (result == B_OK || exactAddress != NULL) {</a>
<a name="ln1369">		if (exactAddress != NULL)</a>
<a name="ln1370">			virtualRestrictions.address = exactAddress;</a>
<a name="ln1371">		else</a>
<a name="ln1372">			virtualRestrictions.address = address;</a>
<a name="ln1373">		virtualRestrictions.address_specification = B_EXACT_ADDRESS;</a>
<a name="ln1374">	} else {</a>
<a name="ln1375">		virtualRestrictions.address = (void*)KERNEL_USER_DATA_BASE;</a>
<a name="ln1376">		virtualRestrictions.address_specification = B_RANDOMIZED_BASE_ADDRESS;</a>
<a name="ln1377">	}</a>
<a name="ln1378"> </a>
<a name="ln1379">	physical_address_restrictions physicalRestrictions = {};</a>
<a name="ln1380">	team-&gt;user_data_area = create_area_etc(team-&gt;id, &quot;user area&quot;,</a>
<a name="ln1381">		kTeamUserDataInitialSize, B_FULL_LOCK, B_READ_AREA | B_WRITE_AREA, 0, 0,</a>
<a name="ln1382">		&amp;virtualRestrictions, &amp;physicalRestrictions, &amp;address);</a>
<a name="ln1383">	if (team-&gt;user_data_area &lt; 0)</a>
<a name="ln1384">		return team-&gt;user_data_area;</a>
<a name="ln1385"> </a>
<a name="ln1386">	team-&gt;user_data = (addr_t)address;</a>
<a name="ln1387">	team-&gt;used_user_data = 0;</a>
<a name="ln1388">	team-&gt;user_data_size = kTeamUserDataInitialSize;</a>
<a name="ln1389">	team-&gt;free_user_threads = NULL;</a>
<a name="ln1390"> </a>
<a name="ln1391">	return B_OK;</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394"> </a>
<a name="ln1395">static void</a>
<a name="ln1396">delete_team_user_data(Team* team)</a>
<a name="ln1397">{</a>
<a name="ln1398">	if (team-&gt;user_data_area &gt;= 0) {</a>
<a name="ln1399">		vm_delete_area(team-&gt;id, team-&gt;user_data_area, true);</a>
<a name="ln1400">		vm_unreserve_address_range(team-&gt;id, (void*)team-&gt;user_data,</a>
<a name="ln1401">			kTeamUserDataReservedSize);</a>
<a name="ln1402"> </a>
<a name="ln1403">		team-&gt;user_data = 0;</a>
<a name="ln1404">		team-&gt;used_user_data = 0;</a>
<a name="ln1405">		team-&gt;user_data_size = 0;</a>
<a name="ln1406">		team-&gt;user_data_area = -1;</a>
<a name="ln1407">		while (free_user_thread* entry = team-&gt;free_user_threads) {</a>
<a name="ln1408">			team-&gt;free_user_threads = entry-&gt;next;</a>
<a name="ln1409">			free(entry);</a>
<a name="ln1410">		}</a>
<a name="ln1411">	}</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414"> </a>
<a name="ln1415">static status_t</a>
<a name="ln1416">copy_user_process_args(const char* const* userFlatArgs, size_t flatArgsSize,</a>
<a name="ln1417">	int32 argCount, int32 envCount, char**&amp; _flatArgs)</a>
<a name="ln1418">{</a>
<a name="ln1419">	if (argCount &lt; 0 || envCount &lt; 0)</a>
<a name="ln1420">		return B_BAD_VALUE;</a>
<a name="ln1421"> </a>
<a name="ln1422">	if (flatArgsSize &gt; MAX_PROCESS_ARGS_SIZE)</a>
<a name="ln1423">		return B_TOO_MANY_ARGS;</a>
<a name="ln1424">	if ((argCount + envCount + 2) * sizeof(char*) &gt; flatArgsSize)</a>
<a name="ln1425">		return B_BAD_VALUE;</a>
<a name="ln1426"> </a>
<a name="ln1427">	if (!IS_USER_ADDRESS(userFlatArgs))</a>
<a name="ln1428">		return B_BAD_ADDRESS;</a>
<a name="ln1429"> </a>
<a name="ln1430">	// allocate kernel memory</a>
<a name="ln1431">	char** flatArgs = (char**)malloc(_ALIGN(flatArgsSize));</a>
<a name="ln1432">	if (flatArgs == NULL)</a>
<a name="ln1433">		return B_NO_MEMORY;</a>
<a name="ln1434"> </a>
<a name="ln1435">	if (user_memcpy(flatArgs, userFlatArgs, flatArgsSize) != B_OK) {</a>
<a name="ln1436">		free(flatArgs);</a>
<a name="ln1437">		return B_BAD_ADDRESS;</a>
<a name="ln1438">	}</a>
<a name="ln1439"> </a>
<a name="ln1440">	// check and relocate the array</a>
<a name="ln1441">	status_t error = B_OK;</a>
<a name="ln1442">	const char* stringBase = (char*)flatArgs + argCount + envCount + 2;</a>
<a name="ln1443">	const char* stringEnd = (char*)flatArgs + flatArgsSize;</a>
<a name="ln1444">	for (int32 i = 0; i &lt; argCount + envCount + 2; i++) {</a>
<a name="ln1445">		if (i == argCount || i == argCount + envCount + 1) {</a>
<a name="ln1446">			// check array null termination</a>
<a name="ln1447">			if (flatArgs[i] != NULL) {</a>
<a name="ln1448">				error = B_BAD_VALUE;</a>
<a name="ln1449">				break;</a>
<a name="ln1450">			}</a>
<a name="ln1451">		} else {</a>
<a name="ln1452">			// check string</a>
<a name="ln1453">			char* arg = (char*)flatArgs + (flatArgs[i] - (char*)userFlatArgs);</a>
<a name="ln1454">			size_t maxLen = stringEnd - arg;</a>
<a name="ln1455">			if (arg &lt; stringBase || arg &gt;= stringEnd</a>
<a name="ln1456">					|| strnlen(arg, maxLen) == maxLen) {</a>
<a name="ln1457">				error = B_BAD_VALUE;</a>
<a name="ln1458">				break;</a>
<a name="ln1459">			}</a>
<a name="ln1460"> </a>
<a name="ln1461">			flatArgs[i] = arg;</a>
<a name="ln1462">		}</a>
<a name="ln1463">	}</a>
<a name="ln1464"> </a>
<a name="ln1465">	if (error == B_OK)</a>
<a name="ln1466">		_flatArgs = flatArgs;</a>
<a name="ln1467">	else</a>
<a name="ln1468">		free(flatArgs);</a>
<a name="ln1469"> </a>
<a name="ln1470">	return error;</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473"> </a>
<a name="ln1474">static void</a>
<a name="ln1475">free_team_arg(struct team_arg* teamArg)</a>
<a name="ln1476">{</a>
<a name="ln1477">	if (teamArg != NULL) {</a>
<a name="ln1478">		free(teamArg-&gt;flat_args);</a>
<a name="ln1479">		free(teamArg-&gt;path);</a>
<a name="ln1480">		free(teamArg);</a>
<a name="ln1481">	}</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484"> </a>
<a name="ln1485">static status_t</a>
<a name="ln1486">create_team_arg(struct team_arg** _teamArg, const char* path, char** flatArgs,</a>
<a name="ln1487">	size_t flatArgsSize, int32 argCount, int32 envCount, mode_t umask,</a>
<a name="ln1488">	port_id port, uint32 token)</a>
<a name="ln1489">{</a>
<a name="ln1490">	struct team_arg* teamArg = (struct team_arg*)malloc(sizeof(team_arg));</a>
<a name="ln1491">	if (teamArg == NULL)</a>
<a name="ln1492">		return B_NO_MEMORY;</a>
<a name="ln1493"> </a>
<a name="ln1494">	teamArg-&gt;path = strdup(path);</a>
<a name="ln1495">	if (teamArg-&gt;path == NULL) {</a>
<a name="ln1496">		free(teamArg);</a>
<a name="ln1497">		return B_NO_MEMORY;</a>
<a name="ln1498">	}</a>
<a name="ln1499"> </a>
<a name="ln1500">	// copy the args over</a>
<a name="ln1501">	teamArg-&gt;flat_args = flatArgs;</a>
<a name="ln1502">	teamArg-&gt;flat_args_size = flatArgsSize;</a>
<a name="ln1503">	teamArg-&gt;arg_count = argCount;</a>
<a name="ln1504">	teamArg-&gt;env_count = envCount;</a>
<a name="ln1505">	teamArg-&gt;flags = 0;</a>
<a name="ln1506">	teamArg-&gt;umask = umask;</a>
<a name="ln1507">	teamArg-&gt;error_port = port;</a>
<a name="ln1508">	teamArg-&gt;error_token = token;</a>
<a name="ln1509"> </a>
<a name="ln1510">	// determine the flags from the environment</a>
<a name="ln1511">	const char* const* env = flatArgs + argCount + 1;</a>
<a name="ln1512">	for (int32 i = 0; i &lt; envCount; i++) {</a>
<a name="ln1513">		if (strcmp(env[i], &quot;DISABLE_ASLR=1&quot;) == 0) {</a>
<a name="ln1514">			teamArg-&gt;flags |= TEAM_ARGS_FLAG_NO_ASLR;</a>
<a name="ln1515">			break;</a>
<a name="ln1516">		}</a>
<a name="ln1517">	}</a>
<a name="ln1518"> </a>
<a name="ln1519">	*_teamArg = teamArg;</a>
<a name="ln1520">	return B_OK;</a>
<a name="ln1521">}</a>
<a name="ln1522"> </a>
<a name="ln1523"> </a>
<a name="ln1524">static status_t</a>
<a name="ln1525">team_create_thread_start_internal(void* args)</a>
<a name="ln1526">{</a>
<a name="ln1527">	status_t err;</a>
<a name="ln1528">	Thread* thread;</a>
<a name="ln1529">	Team* team;</a>
<a name="ln1530">	struct team_arg* teamArgs = (struct team_arg*)args;</a>
<a name="ln1531">	const char* path;</a>
<a name="ln1532">	addr_t entry;</a>
<a name="ln1533">	char** userArgs;</a>
<a name="ln1534">	char** userEnv;</a>
<a name="ln1535">	struct user_space_program_args* programArgs;</a>
<a name="ln1536">	uint32 argCount, envCount;</a>
<a name="ln1537"> </a>
<a name="ln1538">	thread = thread_get_current_thread();</a>
<a name="ln1539">	team = thread-&gt;team;</a>
<a name="ln1540">	cache_node_launched(teamArgs-&gt;arg_count, teamArgs-&gt;flat_args);</a>
<a name="ln1541"> </a>
<a name="ln1542">	TRACE((&quot;team_create_thread_start: entry thread %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln1543">		thread-&gt;id));</a>
<a name="ln1544"> </a>
<a name="ln1545">	// Main stack area layout is currently as follows (starting from 0):</a>
<a name="ln1546">	//</a>
<a name="ln1547">	// size								| usage</a>
<a name="ln1548">	// ---------------------------------+--------------------------------</a>
<a name="ln1549">	// USER_MAIN_THREAD_STACK_SIZE		| actual stack</a>
<a name="ln1550">	// TLS_SIZE							| TLS data</a>
<a name="ln1551">	// sizeof(user_space_program_args)	| argument structure for the runtime</a>
<a name="ln1552">	//									| loader</a>
<a name="ln1553">	// flat arguments size				| flat process arguments and environment</a>
<a name="ln1554"> </a>
<a name="ln1555">	// TODO: ENV_SIZE is a) limited, and b) not used after libroot copied it to</a>
<a name="ln1556">	// the heap</a>
<a name="ln1557">	// TODO: we could reserve the whole USER_STACK_REGION upfront...</a>
<a name="ln1558"> </a>
<a name="ln1559">	argCount = teamArgs-&gt;arg_count;</a>
<a name="ln1560">	envCount = teamArgs-&gt;env_count;</a>
<a name="ln1561"> </a>
<a name="ln1562">	programArgs = (struct user_space_program_args*)(thread-&gt;user_stack_base</a>
<a name="ln1563">		+ thread-&gt;user_stack_size + TLS_SIZE);</a>
<a name="ln1564"> </a>
<a name="ln1565">	userArgs = (char**)(programArgs + 1);</a>
<a name="ln1566">	userEnv = userArgs + argCount + 1;</a>
<a name="ln1567">	path = teamArgs-&gt;path;</a>
<a name="ln1568"> </a>
<a name="ln1569">	if (user_strlcpy(programArgs-&gt;program_path, path,</a>
<a name="ln1570">				sizeof(programArgs-&gt;program_path)) &lt; B_OK</a>
<a name="ln1571">		|| user_memcpy(&amp;programArgs-&gt;arg_count, &amp;argCount, sizeof(int32)) &lt; B_OK</a>
<a name="ln1572">		|| user_memcpy(&amp;programArgs-&gt;args, &amp;userArgs, sizeof(char**)) &lt; B_OK</a>
<a name="ln1573">		|| user_memcpy(&amp;programArgs-&gt;env_count, &amp;envCount, sizeof(int32)) &lt; B_OK</a>
<a name="ln1574">		|| user_memcpy(&amp;programArgs-&gt;env, &amp;userEnv, sizeof(char**)) &lt; B_OK</a>
<a name="ln1575">		|| user_memcpy(&amp;programArgs-&gt;error_port, &amp;teamArgs-&gt;error_port,</a>
<a name="ln1576">				sizeof(port_id)) &lt; B_OK</a>
<a name="ln1577">		|| user_memcpy(&amp;programArgs-&gt;error_token, &amp;teamArgs-&gt;error_token,</a>
<a name="ln1578">				sizeof(uint32)) &lt; B_OK</a>
<a name="ln1579">		|| user_memcpy(&amp;programArgs-&gt;umask, &amp;teamArgs-&gt;umask, sizeof(mode_t)) &lt; B_OK</a>
<a name="ln1580">		|| user_memcpy(&amp;programArgs-&gt;disable_user_addons,</a>
<a name="ln1581">			&amp;sDisableUserAddOns, sizeof(bool)) &lt; B_OK</a>
<a name="ln1582">		|| user_memcpy(userArgs, teamArgs-&gt;flat_args,</a>
<a name="ln1583">				teamArgs-&gt;flat_args_size) &lt; B_OK) {</a>
<a name="ln1584">		// the team deletion process will clean this mess</a>
<a name="ln1585">		free_team_arg(teamArgs);</a>
<a name="ln1586">		return B_BAD_ADDRESS;</a>
<a name="ln1587">	}</a>
<a name="ln1588"> </a>
<a name="ln1589">	TRACE((&quot;team_create_thread_start: loading elf binary '%s'\n&quot;, path));</a>
<a name="ln1590"> </a>
<a name="ln1591">	// set team args and update state</a>
<a name="ln1592">	team-&gt;Lock();</a>
<a name="ln1593">	team-&gt;SetArgs(path, teamArgs-&gt;flat_args + 1, argCount - 1);</a>
<a name="ln1594">	team-&gt;state = TEAM_STATE_NORMAL;</a>
<a name="ln1595">	team-&gt;Unlock();</a>
<a name="ln1596"> </a>
<a name="ln1597">	free_team_arg(teamArgs);</a>
<a name="ln1598">		// the arguments are already on the user stack, we no longer need</a>
<a name="ln1599">		// them in this form</a>
<a name="ln1600"> </a>
<a name="ln1601">	// Clone commpage area</a>
<a name="ln1602">	area_id commPageArea = clone_commpage_area(team-&gt;id,</a>
<a name="ln1603">		&amp;team-&gt;commpage_address);</a>
<a name="ln1604">	if (commPageArea  &lt; B_OK) {</a>
<a name="ln1605">		TRACE((&quot;team_create_thread_start: clone_commpage_area() failed: %s\n&quot;,</a>
<a name="ln1606">			strerror(commPageArea)));</a>
<a name="ln1607">		return commPageArea;</a>
<a name="ln1608">	}</a>
<a name="ln1609"> </a>
<a name="ln1610">	// Register commpage image</a>
<a name="ln1611">	image_id commPageImage = get_commpage_image();</a>
<a name="ln1612">	extended_image_info imageInfo;</a>
<a name="ln1613">	err = get_image_info(commPageImage, &amp;imageInfo.basic_info);</a>
<a name="ln1614">	if (err != B_OK) {</a>
<a name="ln1615">		TRACE((&quot;team_create_thread_start: get_image_info() failed: %s\n&quot;,</a>
<a name="ln1616">			strerror(err)));</a>
<a name="ln1617">		return err;</a>
<a name="ln1618">	}</a>
<a name="ln1619">	imageInfo.basic_info.text = team-&gt;commpage_address;</a>
<a name="ln1620">	imageInfo.text_delta = (ssize_t)(addr_t)team-&gt;commpage_address;</a>
<a name="ln1621">	imageInfo.symbol_table = NULL;</a>
<a name="ln1622">	imageInfo.symbol_hash = NULL;</a>
<a name="ln1623">	imageInfo.string_table = NULL;</a>
<a name="ln1624">	image_id image = register_image(team, &amp;imageInfo, sizeof(imageInfo));</a>
<a name="ln1625">	if (image &lt; 0) {</a>
<a name="ln1626">		TRACE((&quot;team_create_thread_start: register_image() failed: %s\n&quot;,</a>
<a name="ln1627">			strerror(image)));</a>
<a name="ln1628">		return image;</a>
<a name="ln1629">	}</a>
<a name="ln1630"> </a>
<a name="ln1631">	// NOTE: Normally arch_thread_enter_userspace() never returns, that is</a>
<a name="ln1632">	// automatic variables with function scope will never be destroyed.</a>
<a name="ln1633">	{</a>
<a name="ln1634">		// find runtime_loader path</a>
<a name="ln1635">		KPath runtimeLoaderPath;</a>
<a name="ln1636">		err = __find_directory(B_SYSTEM_DIRECTORY, gBootDevice, false,</a>
<a name="ln1637">			runtimeLoaderPath.LockBuffer(), runtimeLoaderPath.BufferSize());</a>
<a name="ln1638">		if (err &lt; B_OK) {</a>
<a name="ln1639">			TRACE((&quot;team_create_thread_start: find_directory() failed: %s\n&quot;,</a>
<a name="ln1640">				strerror(err)));</a>
<a name="ln1641">			return err;</a>
<a name="ln1642">		}</a>
<a name="ln1643">		runtimeLoaderPath.UnlockBuffer();</a>
<a name="ln1644">		err = runtimeLoaderPath.Append(&quot;runtime_loader&quot;);</a>
<a name="ln1645"> </a>
<a name="ln1646">		if (err == B_OK) {</a>
<a name="ln1647">			err = elf_load_user_image(runtimeLoaderPath.Path(), team, 0,</a>
<a name="ln1648">				&amp;entry);</a>
<a name="ln1649">		}</a>
<a name="ln1650">	}</a>
<a name="ln1651"> </a>
<a name="ln1652">	if (err &lt; B_OK) {</a>
<a name="ln1653">		// Luckily, we don't have to clean up the mess we created - that's</a>
<a name="ln1654">		// done for us by the normal team deletion process</a>
<a name="ln1655">		TRACE((&quot;team_create_thread_start: elf_load_user_image() failed: &quot;</a>
<a name="ln1656">			&quot;%s\n&quot;, strerror(err)));</a>
<a name="ln1657">		return err;</a>
<a name="ln1658">	}</a>
<a name="ln1659"> </a>
<a name="ln1660">	TRACE((&quot;team_create_thread_start: loaded elf. entry = %#lx\n&quot;, entry));</a>
<a name="ln1661"> </a>
<a name="ln1662">	// enter userspace -- returns only in case of error</a>
<a name="ln1663">	return thread_enter_userspace_new_team(thread, (addr_t)entry,</a>
<a name="ln1664">		programArgs, team-&gt;commpage_address);</a>
<a name="ln1665">}</a>
<a name="ln1666"> </a>
<a name="ln1667"> </a>
<a name="ln1668">static status_t</a>
<a name="ln1669">team_create_thread_start(void* args)</a>
<a name="ln1670">{</a>
<a name="ln1671">	team_create_thread_start_internal(args);</a>
<a name="ln1672">	team_init_exit_info_on_error(thread_get_current_thread()-&gt;team);</a>
<a name="ln1673">	thread_exit();</a>
<a name="ln1674">		// does not return</a>
<a name="ln1675">	return B_OK;</a>
<a name="ln1676">}</a>
<a name="ln1677"> </a>
<a name="ln1678"> </a>
<a name="ln1679">static thread_id</a>
<a name="ln1680">load_image_internal(char**&amp; _flatArgs, size_t flatArgsSize, int32 argCount,</a>
<a name="ln1681">	int32 envCount, int32 priority, team_id parentID, uint32 flags,</a>
<a name="ln1682">	port_id errorPort, uint32 errorToken)</a>
<a name="ln1683">{</a>
<a name="ln1684">	char** flatArgs = _flatArgs;</a>
<a name="ln1685">	thread_id thread;</a>
<a name="ln1686">	status_t status;</a>
<a name="ln1687">	struct team_arg* teamArgs;</a>
<a name="ln1688">	struct team_loading_info loadingInfo;</a>
<a name="ln1689">	ConditionVariableEntry loadingWaitEntry;</a>
<a name="ln1690">	io_context* parentIOContext = NULL;</a>
<a name="ln1691">	team_id teamID;</a>
<a name="ln1692">	bool teamLimitReached = false;</a>
<a name="ln1693"> </a>
<a name="ln1694">	if (flatArgs == NULL || argCount == 0)</a>
<a name="ln1695">		return B_BAD_VALUE;</a>
<a name="ln1696"> </a>
<a name="ln1697">	const char* path = flatArgs[0];</a>
<a name="ln1698"> </a>
<a name="ln1699">	TRACE((&quot;load_image_internal: name '%s', args = %p, argCount = %&quot; B_PRId32</a>
<a name="ln1700">		&quot;\n&quot;, path, flatArgs, argCount));</a>
<a name="ln1701"> </a>
<a name="ln1702">	// cut the path from the main thread name</a>
<a name="ln1703">	const char* threadName = strrchr(path, '/');</a>
<a name="ln1704">	if (threadName != NULL)</a>
<a name="ln1705">		threadName++;</a>
<a name="ln1706">	else</a>
<a name="ln1707">		threadName = path;</a>
<a name="ln1708"> </a>
<a name="ln1709">	// create the main thread object</a>
<a name="ln1710">	Thread* mainThread;</a>
<a name="ln1711">	status = Thread::Create(threadName, mainThread);</a>
<a name="ln1712">	if (status != B_OK)</a>
<a name="ln1713">		return status;</a>
<a name="ln1714">	BReference&lt;Thread&gt; mainThreadReference(mainThread, true);</a>
<a name="ln1715"> </a>
<a name="ln1716">	// create team object</a>
<a name="ln1717">	Team* team = Team::Create(mainThread-&gt;id, path, false);</a>
<a name="ln1718">	if (team == NULL)</a>
<a name="ln1719">		return B_NO_MEMORY;</a>
<a name="ln1720">	BReference&lt;Team&gt; teamReference(team, true);</a>
<a name="ln1721"> </a>
<a name="ln1722">	if ((flags &amp; B_WAIT_TILL_LOADED) != 0) {</a>
<a name="ln1723">		loadingInfo.condition.Init(team, &quot;image load&quot;);</a>
<a name="ln1724">		loadingInfo.condition.Add(&amp;loadingWaitEntry);</a>
<a name="ln1725">		loadingInfo.result = B_ERROR;</a>
<a name="ln1726">		team-&gt;loading_info = &amp;loadingInfo;</a>
<a name="ln1727">	}</a>
<a name="ln1728"> </a>
<a name="ln1729">	// get the parent team</a>
<a name="ln1730">	Team* parent = Team::Get(parentID);</a>
<a name="ln1731">	if (parent == NULL)</a>
<a name="ln1732">		return B_BAD_TEAM_ID;</a>
<a name="ln1733">	BReference&lt;Team&gt; parentReference(parent, true);</a>
<a name="ln1734"> </a>
<a name="ln1735">	parent-&gt;LockTeamAndProcessGroup();</a>
<a name="ln1736">	team-&gt;Lock();</a>
<a name="ln1737"> </a>
<a name="ln1738">	// inherit the parent's user/group</a>
<a name="ln1739">	inherit_parent_user_and_group(team, parent);</a>
<a name="ln1740"> </a>
<a name="ln1741">	// get a reference to the parent's I/O context -- we need it to create ours</a>
<a name="ln1742">	parentIOContext = parent-&gt;io_context;</a>
<a name="ln1743">	vfs_get_io_context(parentIOContext);</a>
<a name="ln1744"> </a>
<a name="ln1745">	team-&gt;Unlock();</a>
<a name="ln1746">	parent-&gt;UnlockTeamAndProcessGroup();</a>
<a name="ln1747"> </a>
<a name="ln1748">	// check the executable's set-user/group-id permission</a>
<a name="ln1749">	update_set_id_user_and_group(team, path);</a>
<a name="ln1750"> </a>
<a name="ln1751">	status = create_team_arg(&amp;teamArgs, path, flatArgs, flatArgsSize, argCount,</a>
<a name="ln1752">		envCount, (mode_t)-1, errorPort, errorToken);</a>
<a name="ln1753">	if (status != B_OK)</a>
<a name="ln1754">		goto err1;</a>
<a name="ln1755"> </a>
<a name="ln1756">	_flatArgs = NULL;</a>
<a name="ln1757">		// args are owned by the team_arg structure now</a>
<a name="ln1758"> </a>
<a name="ln1759">	// create a new io_context for this team</a>
<a name="ln1760">	team-&gt;io_context = vfs_new_io_context(parentIOContext, true);</a>
<a name="ln1761">	if (!team-&gt;io_context) {</a>
<a name="ln1762">		status = B_NO_MEMORY;</a>
<a name="ln1763">		goto err2;</a>
<a name="ln1764">	}</a>
<a name="ln1765"> </a>
<a name="ln1766">	// We don't need the parent's I/O context any longer.</a>
<a name="ln1767">	vfs_put_io_context(parentIOContext);</a>
<a name="ln1768">	parentIOContext = NULL;</a>
<a name="ln1769"> </a>
<a name="ln1770">	// remove any fds that have the CLOEXEC flag set (emulating BeOS behaviour)</a>
<a name="ln1771">	vfs_exec_io_context(team-&gt;io_context);</a>
<a name="ln1772"> </a>
<a name="ln1773">	// create an address space for this team</a>
<a name="ln1774">	status = VMAddressSpace::Create(team-&gt;id, USER_BASE, USER_SIZE, false,</a>
<a name="ln1775">		&amp;team-&gt;address_space);</a>
<a name="ln1776">	if (status != B_OK)</a>
<a name="ln1777">		goto err2;</a>
<a name="ln1778"> </a>
<a name="ln1779">	team-&gt;address_space-&gt;SetRandomizingEnabled(</a>
<a name="ln1780">		(teamArgs-&gt;flags &amp; TEAM_ARGS_FLAG_NO_ASLR) == 0);</a>
<a name="ln1781"> </a>
<a name="ln1782">	// create the user data area</a>
<a name="ln1783">	status = create_team_user_data(team);</a>
<a name="ln1784">	if (status != B_OK)</a>
<a name="ln1785">		goto err4;</a>
<a name="ln1786"> </a>
<a name="ln1787">	// insert the team into its parent and the teams hash</a>
<a name="ln1788">	parent-&gt;LockTeamAndProcessGroup();</a>
<a name="ln1789">	team-&gt;Lock();</a>
<a name="ln1790"> </a>
<a name="ln1791">	{</a>
<a name="ln1792">		InterruptsWriteSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln1793"> </a>
<a name="ln1794">		sTeamHash.Insert(team);</a>
<a name="ln1795">		teamLimitReached = sUsedTeams &gt;= sMaxTeams;</a>
<a name="ln1796">		if (!teamLimitReached)</a>
<a name="ln1797">			sUsedTeams++;</a>
<a name="ln1798">	}</a>
<a name="ln1799"> </a>
<a name="ln1800">	insert_team_into_parent(parent, team);</a>
<a name="ln1801">	insert_team_into_group(parent-&gt;group, team);</a>
<a name="ln1802"> </a>
<a name="ln1803">	team-&gt;Unlock();</a>
<a name="ln1804">	parent-&gt;UnlockTeamAndProcessGroup();</a>
<a name="ln1805"> </a>
<a name="ln1806">	// notify team listeners</a>
<a name="ln1807">	sNotificationService.Notify(TEAM_ADDED, team);</a>
<a name="ln1808"> </a>
<a name="ln1809">	if (teamLimitReached) {</a>
<a name="ln1810">		status = B_NO_MORE_TEAMS;</a>
<a name="ln1811">		goto err6;</a>
<a name="ln1812">	}</a>
<a name="ln1813"> </a>
<a name="ln1814">	// In case we start the main thread, we shouldn't access the team object</a>
<a name="ln1815">	// afterwards, so cache the team's ID.</a>
<a name="ln1816">	teamID = team-&gt;id;</a>
<a name="ln1817"> </a>
<a name="ln1818">	// Create a kernel thread, but under the context of the new team</a>
<a name="ln1819">	// The new thread will take over ownership of teamArgs.</a>
<a name="ln1820">	{</a>
<a name="ln1821">		ThreadCreationAttributes threadAttributes(team_create_thread_start,</a>
<a name="ln1822">			threadName, B_NORMAL_PRIORITY, teamArgs, teamID, mainThread);</a>
<a name="ln1823">		threadAttributes.additional_stack_size = sizeof(user_space_program_args)</a>
<a name="ln1824">			+ teamArgs-&gt;flat_args_size;</a>
<a name="ln1825">		thread = thread_create_thread(threadAttributes, false);</a>
<a name="ln1826">		if (thread &lt; 0) {</a>
<a name="ln1827">			status = thread;</a>
<a name="ln1828">			goto err6;</a>
<a name="ln1829">		}</a>
<a name="ln1830">	}</a>
<a name="ln1831"> </a>
<a name="ln1832">	// The team has been created successfully, so we keep the reference. Or</a>
<a name="ln1833">	// more precisely: It's owned by the team's main thread, now.</a>
<a name="ln1834">	teamReference.Detach();</a>
<a name="ln1835"> </a>
<a name="ln1836">	// wait for the loader of the new team to finish its work</a>
<a name="ln1837">	if ((flags &amp; B_WAIT_TILL_LOADED) != 0) {</a>
<a name="ln1838">		if (mainThread != NULL) {</a>
<a name="ln1839">			// resume the team's main thread</a>
<a name="ln1840">			thread_continue(mainThread);</a>
<a name="ln1841">		}</a>
<a name="ln1842"> </a>
<a name="ln1843">		// Now wait until loading is finished. We will be woken either by the</a>
<a name="ln1844">		// thread, when it finished or aborted loading, or when the team is</a>
<a name="ln1845">		// going to die (e.g. is killed). In either case the one notifying is</a>
<a name="ln1846">		// responsible for unsetting `loading_info` in the team structure.</a>
<a name="ln1847">		loadingWaitEntry.Wait();</a>
<a name="ln1848"> </a>
<a name="ln1849">		if (loadingInfo.result &lt; B_OK)</a>
<a name="ln1850">			return loadingInfo.result;</a>
<a name="ln1851">	}</a>
<a name="ln1852"> </a>
<a name="ln1853">	// notify the debugger</a>
<a name="ln1854">	user_debug_team_created(teamID);</a>
<a name="ln1855"> </a>
<a name="ln1856">	return thread;</a>
<a name="ln1857"> </a>
<a name="ln1858">err6:</a>
<a name="ln1859">	// Remove the team structure from the process group, the parent team, and</a>
<a name="ln1860">	// the team hash table and delete the team structure.</a>
<a name="ln1861">	parent-&gt;LockTeamAndProcessGroup();</a>
<a name="ln1862">	team-&gt;Lock();</a>
<a name="ln1863"> </a>
<a name="ln1864">	remove_team_from_group(team);</a>
<a name="ln1865">	remove_team_from_parent(team-&gt;parent, team);</a>
<a name="ln1866"> </a>
<a name="ln1867">	team-&gt;Unlock();</a>
<a name="ln1868">	parent-&gt;UnlockTeamAndProcessGroup();</a>
<a name="ln1869"> </a>
<a name="ln1870">	{</a>
<a name="ln1871">		InterruptsWriteSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln1872">		sTeamHash.Remove(team);</a>
<a name="ln1873">		if (!teamLimitReached)</a>
<a name="ln1874">			sUsedTeams--;</a>
<a name="ln1875">	}</a>
<a name="ln1876"> </a>
<a name="ln1877">	sNotificationService.Notify(TEAM_REMOVED, team);</a>
<a name="ln1878"> </a>
<a name="ln1879">	delete_team_user_data(team);</a>
<a name="ln1880">err4:</a>
<a name="ln1881">	team-&gt;address_space-&gt;Put();</a>
<a name="ln1882">err2:</a>
<a name="ln1883">	free_team_arg(teamArgs);</a>
<a name="ln1884">err1:</a>
<a name="ln1885">	if (parentIOContext != NULL)</a>
<a name="ln1886">		vfs_put_io_context(parentIOContext);</a>
<a name="ln1887"> </a>
<a name="ln1888">	return status;</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891"> </a>
<a name="ln1892">/*!	Almost shuts down the current team and loads a new image into it.</a>
<a name="ln1893">	If successful, this function does not return and will takeover ownership of</a>
<a name="ln1894">	the arguments provided.</a>
<a name="ln1895">	This function may only be called in a userland team (caused by one of the</a>
<a name="ln1896">	exec*() syscalls).</a>
<a name="ln1897">*/</a>
<a name="ln1898">static status_t</a>
<a name="ln1899">exec_team(const char* path, char**&amp; _flatArgs, size_t flatArgsSize,</a>
<a name="ln1900">	int32 argCount, int32 envCount, mode_t umask)</a>
<a name="ln1901">{</a>
<a name="ln1902">	// NOTE: Since this function normally doesn't return, don't use automatic</a>
<a name="ln1903">	// variables that need destruction in the function scope.</a>
<a name="ln1904">	char** flatArgs = _flatArgs;</a>
<a name="ln1905">	Team* team = thread_get_current_thread()-&gt;team;</a>
<a name="ln1906">	struct team_arg* teamArgs;</a>
<a name="ln1907">	const char* threadName;</a>
<a name="ln1908">	thread_id nubThreadID = -1;</a>
<a name="ln1909"> </a>
<a name="ln1910">	TRACE((&quot;exec_team(path = \&quot;%s\&quot;, argc = %&quot; B_PRId32 &quot;, envCount = %&quot;</a>
<a name="ln1911">		B_PRId32 &quot;): team %&quot; B_PRId32 &quot;\n&quot;, path, argCount, envCount,</a>
<a name="ln1912">		team-&gt;id));</a>
<a name="ln1913"> </a>
<a name="ln1914">	T(ExecTeam(path, argCount, flatArgs, envCount, flatArgs + argCount + 1));</a>
<a name="ln1915"> </a>
<a name="ln1916">	// switching the kernel at run time is probably not a good idea :)</a>
<a name="ln1917">	if (team == team_get_kernel_team())</a>
<a name="ln1918">		return B_NOT_ALLOWED;</a>
<a name="ln1919"> </a>
<a name="ln1920">	// we currently need to be single threaded here</a>
<a name="ln1921">	// TODO: maybe we should just kill all other threads and</a>
<a name="ln1922">	//	make the current thread the team's main thread?</a>
<a name="ln1923">	Thread* currentThread = thread_get_current_thread();</a>
<a name="ln1924">	if (currentThread != team-&gt;main_thread)</a>
<a name="ln1925">		return B_NOT_ALLOWED;</a>
<a name="ln1926"> </a>
<a name="ln1927">	// The debug nub thread, a pure kernel thread, is allowed to survive.</a>
<a name="ln1928">	// We iterate through the thread list to make sure that there's no other</a>
<a name="ln1929">	// thread.</a>
<a name="ln1930">	TeamLocker teamLocker(team);</a>
<a name="ln1931">	InterruptsSpinLocker debugInfoLocker(team-&gt;debug_info.lock);</a>
<a name="ln1932"> </a>
<a name="ln1933">	if (team-&gt;debug_info.flags &amp; B_TEAM_DEBUG_DEBUGGER_INSTALLED)</a>
<a name="ln1934">		nubThreadID = team-&gt;debug_info.nub_thread;</a>
<a name="ln1935"> </a>
<a name="ln1936">	debugInfoLocker.Unlock();</a>
<a name="ln1937"> </a>
<a name="ln1938">	for (Thread* thread = team-&gt;thread_list; thread != NULL;</a>
<a name="ln1939">			thread = thread-&gt;team_next) {</a>
<a name="ln1940">		if (thread != team-&gt;main_thread &amp;&amp; thread-&gt;id != nubThreadID)</a>
<a name="ln1941">			return B_NOT_ALLOWED;</a>
<a name="ln1942">	}</a>
<a name="ln1943"> </a>
<a name="ln1944">	team-&gt;DeleteUserTimers(true);</a>
<a name="ln1945">	team-&gt;ResetSignalsOnExec();</a>
<a name="ln1946"> </a>
<a name="ln1947">	teamLocker.Unlock();</a>
<a name="ln1948"> </a>
<a name="ln1949">	status_t status = create_team_arg(&amp;teamArgs, path, flatArgs, flatArgsSize,</a>
<a name="ln1950">		argCount, envCount, umask, -1, 0);</a>
<a name="ln1951">	if (status != B_OK)</a>
<a name="ln1952">		return status;</a>
<a name="ln1953"> </a>
<a name="ln1954">	_flatArgs = NULL;</a>
<a name="ln1955">		// args are owned by the team_arg structure now</a>
<a name="ln1956"> </a>
<a name="ln1957">	// TODO: remove team resources if there are any left</a>
<a name="ln1958">	// thread_atkernel_exit() might not be called at all</a>
<a name="ln1959"> </a>
<a name="ln1960">	thread_reset_for_exec();</a>
<a name="ln1961"> </a>
<a name="ln1962">	user_debug_prepare_for_exec();</a>
<a name="ln1963"> </a>
<a name="ln1964">	delete_team_user_data(team);</a>
<a name="ln1965">	vm_delete_areas(team-&gt;address_space, false);</a>
<a name="ln1966">	xsi_sem_undo(team);</a>
<a name="ln1967">	delete_owned_ports(team);</a>
<a name="ln1968">	sem_delete_owned_sems(team);</a>
<a name="ln1969">	remove_images(team);</a>
<a name="ln1970">	vfs_exec_io_context(team-&gt;io_context);</a>
<a name="ln1971">	delete_realtime_sem_context(team-&gt;realtime_sem_context);</a>
<a name="ln1972">	team-&gt;realtime_sem_context = NULL;</a>
<a name="ln1973"> </a>
<a name="ln1974">	// update ASLR</a>
<a name="ln1975">	team-&gt;address_space-&gt;SetRandomizingEnabled(</a>
<a name="ln1976">		(teamArgs-&gt;flags &amp; TEAM_ARGS_FLAG_NO_ASLR) == 0);</a>
<a name="ln1977"> </a>
<a name="ln1978">	status = create_team_user_data(team);</a>
<a name="ln1979">	if (status != B_OK) {</a>
<a name="ln1980">		// creating the user data failed -- we're toast</a>
<a name="ln1981">		free_team_arg(teamArgs);</a>
<a name="ln1982">		exit_thread(status);</a>
<a name="ln1983">		return status;</a>
<a name="ln1984">	}</a>
<a name="ln1985"> </a>
<a name="ln1986">	user_debug_finish_after_exec();</a>
<a name="ln1987"> </a>
<a name="ln1988">	// rename the team</a>
<a name="ln1989"> </a>
<a name="ln1990">	team-&gt;Lock();</a>
<a name="ln1991">	team-&gt;SetName(path);</a>
<a name="ln1992">	team-&gt;Unlock();</a>
<a name="ln1993"> </a>
<a name="ln1994">	// cut the path from the team name and rename the main thread, too</a>
<a name="ln1995">	threadName = strrchr(path, '/');</a>
<a name="ln1996">	if (threadName != NULL)</a>
<a name="ln1997">		threadName++;</a>
<a name="ln1998">	else</a>
<a name="ln1999">		threadName = path;</a>
<a name="ln2000">	rename_thread(thread_get_current_thread_id(), threadName);</a>
<a name="ln2001"> </a>
<a name="ln2002">	atomic_or(&amp;team-&gt;flags, TEAM_FLAG_EXEC_DONE);</a>
<a name="ln2003"> </a>
<a name="ln2004">	// Update user/group according to the executable's set-user/group-id</a>
<a name="ln2005">	// permission.</a>
<a name="ln2006">	update_set_id_user_and_group(team, path);</a>
<a name="ln2007"> </a>
<a name="ln2008">	user_debug_team_exec();</a>
<a name="ln2009"> </a>
<a name="ln2010">	// notify team listeners</a>
<a name="ln2011">	sNotificationService.Notify(TEAM_EXEC, team);</a>
<a name="ln2012"> </a>
<a name="ln2013">	// get a user thread for the thread</a>
<a name="ln2014">	user_thread* userThread = team_allocate_user_thread(team);</a>
<a name="ln2015">		// cannot fail (the allocation for the team would have failed already)</a>
<a name="ln2016">	ThreadLocker currentThreadLocker(currentThread);</a>
<a name="ln2017">	currentThread-&gt;user_thread = userThread;</a>
<a name="ln2018">	currentThreadLocker.Unlock();</a>
<a name="ln2019"> </a>
<a name="ln2020">	// create the user stack for the thread</a>
<a name="ln2021">	status = thread_create_user_stack(currentThread-&gt;team, currentThread, NULL,</a>
<a name="ln2022">		0, sizeof(user_space_program_args) + teamArgs-&gt;flat_args_size);</a>
<a name="ln2023">	if (status == B_OK) {</a>
<a name="ln2024">		// prepare the stack, load the runtime loader, and enter userspace</a>
<a name="ln2025">		team_create_thread_start(teamArgs);</a>
<a name="ln2026">			// does never return</a>
<a name="ln2027">	} else</a>
<a name="ln2028">		free_team_arg(teamArgs);</a>
<a name="ln2029"> </a>
<a name="ln2030">	// Sorry, we have to kill ourselves, there is no way out anymore</a>
<a name="ln2031">	// (without any areas left and all that).</a>
<a name="ln2032">	exit_thread(status);</a>
<a name="ln2033"> </a>
<a name="ln2034">	// We return a status here since the signal that is sent by the</a>
<a name="ln2035">	// call above is not immediately handled.</a>
<a name="ln2036">	return B_ERROR;</a>
<a name="ln2037">}</a>
<a name="ln2038"> </a>
<a name="ln2039"> </a>
<a name="ln2040">static thread_id</a>
<a name="ln2041">fork_team(void)</a>
<a name="ln2042">{</a>
<a name="ln2043">	Thread* parentThread = thread_get_current_thread();</a>
<a name="ln2044">	Team* parentTeam = parentThread-&gt;team;</a>
<a name="ln2045">	Team* team;</a>
<a name="ln2046">	arch_fork_arg* forkArgs;</a>
<a name="ln2047">	struct area_info info;</a>
<a name="ln2048">	thread_id threadID;</a>
<a name="ln2049">	status_t status;</a>
<a name="ln2050">	ssize_t areaCookie;</a>
<a name="ln2051">	bool teamLimitReached = false;</a>
<a name="ln2052"> </a>
<a name="ln2053">	TRACE((&quot;fork_team(): team %&quot; B_PRId32 &quot;\n&quot;, parentTeam-&gt;id));</a>
<a name="ln2054"> </a>
<a name="ln2055">	if (parentTeam == team_get_kernel_team())</a>
<a name="ln2056">		return B_NOT_ALLOWED;</a>
<a name="ln2057"> </a>
<a name="ln2058">	// create a new team</a>
<a name="ln2059">	// TODO: this is very similar to load_image_internal() - maybe we can do</a>
<a name="ln2060">	// something about it :)</a>
<a name="ln2061"> </a>
<a name="ln2062">	// create the main thread object</a>
<a name="ln2063">	Thread* thread;</a>
<a name="ln2064">	status = Thread::Create(parentThread-&gt;name, thread);</a>
<a name="ln2065">	if (status != B_OK)</a>
<a name="ln2066">		return status;</a>
<a name="ln2067">	BReference&lt;Thread&gt; threadReference(thread, true);</a>
<a name="ln2068"> </a>
<a name="ln2069">	// create the team object</a>
<a name="ln2070">	team = Team::Create(thread-&gt;id, NULL, false);</a>
<a name="ln2071">	if (team == NULL)</a>
<a name="ln2072">		return B_NO_MEMORY;</a>
<a name="ln2073"> </a>
<a name="ln2074">	parentTeam-&gt;LockTeamAndProcessGroup();</a>
<a name="ln2075">	team-&gt;Lock();</a>
<a name="ln2076"> </a>
<a name="ln2077">	team-&gt;SetName(parentTeam-&gt;Name());</a>
<a name="ln2078">	team-&gt;SetArgs(parentTeam-&gt;Args());</a>
<a name="ln2079"> </a>
<a name="ln2080">	team-&gt;commpage_address = parentTeam-&gt;commpage_address;</a>
<a name="ln2081"> </a>
<a name="ln2082">	// Inherit the parent's user/group.</a>
<a name="ln2083">	inherit_parent_user_and_group(team, parentTeam);</a>
<a name="ln2084"> </a>
<a name="ln2085">	// inherit signal handlers</a>
<a name="ln2086">	team-&gt;InheritSignalActions(parentTeam);</a>
<a name="ln2087"> </a>
<a name="ln2088">	team-&gt;Unlock();</a>
<a name="ln2089">	parentTeam-&gt;UnlockTeamAndProcessGroup();</a>
<a name="ln2090"> </a>
<a name="ln2091">	// inherit some team debug flags</a>
<a name="ln2092">	team-&gt;debug_info.flags |= atomic_get(&amp;parentTeam-&gt;debug_info.flags)</a>
<a name="ln2093">		&amp; B_TEAM_DEBUG_INHERITED_FLAGS;</a>
<a name="ln2094"> </a>
<a name="ln2095">	forkArgs = (arch_fork_arg*)malloc(sizeof(arch_fork_arg));</a>
<a name="ln2096">	if (forkArgs == NULL) {</a>
<a name="ln2097">		status = B_NO_MEMORY;</a>
<a name="ln2098">		goto err1;</a>
<a name="ln2099">	}</a>
<a name="ln2100"> </a>
<a name="ln2101">	// create a new io_context for this team</a>
<a name="ln2102">	team-&gt;io_context = vfs_new_io_context(parentTeam-&gt;io_context, false);</a>
<a name="ln2103">	if (!team-&gt;io_context) {</a>
<a name="ln2104">		status = B_NO_MEMORY;</a>
<a name="ln2105">		goto err2;</a>
<a name="ln2106">	}</a>
<a name="ln2107"> </a>
<a name="ln2108">	// duplicate the realtime sem context</a>
<a name="ln2109">	if (parentTeam-&gt;realtime_sem_context) {</a>
<a name="ln2110">		team-&gt;realtime_sem_context = clone_realtime_sem_context(</a>
<a name="ln2111">			parentTeam-&gt;realtime_sem_context);</a>
<a name="ln2112">		if (team-&gt;realtime_sem_context == NULL) {</a>
<a name="ln2113">			status = B_NO_MEMORY;</a>
<a name="ln2114">			goto err2;</a>
<a name="ln2115">		}</a>
<a name="ln2116">	}</a>
<a name="ln2117"> </a>
<a name="ln2118">	// create an address space for this team</a>
<a name="ln2119">	status = VMAddressSpace::Create(team-&gt;id, USER_BASE, USER_SIZE, false,</a>
<a name="ln2120">		&amp;team-&gt;address_space);</a>
<a name="ln2121">	if (status &lt; B_OK)</a>
<a name="ln2122">		goto err3;</a>
<a name="ln2123"> </a>
<a name="ln2124">	// copy all areas of the team</a>
<a name="ln2125">	// TODO: should be able to handle stack areas differently (ie. don't have</a>
<a name="ln2126">	// them copy-on-write)</a>
<a name="ln2127"> </a>
<a name="ln2128">	areaCookie = 0;</a>
<a name="ln2129">	while (get_next_area_info(B_CURRENT_TEAM, &amp;areaCookie, &amp;info) == B_OK) {</a>
<a name="ln2130">		if (info.area == parentTeam-&gt;user_data_area) {</a>
<a name="ln2131">			// don't clone the user area; just create a new one</a>
<a name="ln2132">			status = create_team_user_data(team, info.address);</a>
<a name="ln2133">			if (status != B_OK)</a>
<a name="ln2134">				break;</a>
<a name="ln2135"> </a>
<a name="ln2136">			thread-&gt;user_thread = team_allocate_user_thread(team);</a>
<a name="ln2137">		} else {</a>
<a name="ln2138">			void* address;</a>
<a name="ln2139">			area_id area = vm_copy_area(team-&gt;address_space-&gt;ID(), info.name,</a>
<a name="ln2140">				&amp;address, B_CLONE_ADDRESS, info.protection, info.area);</a>
<a name="ln2141">			if (area &lt; B_OK) {</a>
<a name="ln2142">				status = area;</a>
<a name="ln2143">				break;</a>
<a name="ln2144">			}</a>
<a name="ln2145"> </a>
<a name="ln2146">			if (info.area == parentThread-&gt;user_stack_area)</a>
<a name="ln2147">				thread-&gt;user_stack_area = area;</a>
<a name="ln2148">		}</a>
<a name="ln2149">	}</a>
<a name="ln2150"> </a>
<a name="ln2151">	if (status &lt; B_OK)</a>
<a name="ln2152">		goto err4;</a>
<a name="ln2153"> </a>
<a name="ln2154">	if (thread-&gt;user_thread == NULL) {</a>
<a name="ln2155">#if KDEBUG</a>
<a name="ln2156">		panic(&quot;user data area not found, parent area is %&quot; B_PRId32,</a>
<a name="ln2157">			parentTeam-&gt;user_data_area);</a>
<a name="ln2158">#endif</a>
<a name="ln2159">		status = B_ERROR;</a>
<a name="ln2160">		goto err4;</a>
<a name="ln2161">	}</a>
<a name="ln2162"> </a>
<a name="ln2163">	thread-&gt;user_stack_base = parentThread-&gt;user_stack_base;</a>
<a name="ln2164">	thread-&gt;user_stack_size = parentThread-&gt;user_stack_size;</a>
<a name="ln2165">	thread-&gt;user_local_storage = parentThread-&gt;user_local_storage;</a>
<a name="ln2166">	thread-&gt;sig_block_mask = parentThread-&gt;sig_block_mask;</a>
<a name="ln2167">	thread-&gt;signal_stack_base = parentThread-&gt;signal_stack_base;</a>
<a name="ln2168">	thread-&gt;signal_stack_size = parentThread-&gt;signal_stack_size;</a>
<a name="ln2169">	thread-&gt;signal_stack_enabled = parentThread-&gt;signal_stack_enabled;</a>
<a name="ln2170"> </a>
<a name="ln2171">	arch_store_fork_frame(forkArgs);</a>
<a name="ln2172"> </a>
<a name="ln2173">	// copy image list</a>
<a name="ln2174">	if (copy_images(parentTeam-&gt;id, team) != B_OK)</a>
<a name="ln2175">		goto err5;</a>
<a name="ln2176"> </a>
<a name="ln2177">	// insert the team into its parent and the teams hash</a>
<a name="ln2178">	parentTeam-&gt;LockTeamAndProcessGroup();</a>
<a name="ln2179">	team-&gt;Lock();</a>
<a name="ln2180"> </a>
<a name="ln2181">	{</a>
<a name="ln2182">		InterruptsWriteSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln2183"> </a>
<a name="ln2184">		sTeamHash.Insert(team);</a>
<a name="ln2185">		teamLimitReached = sUsedTeams &gt;= sMaxTeams;</a>
<a name="ln2186">		if (!teamLimitReached)</a>
<a name="ln2187">			sUsedTeams++;</a>
<a name="ln2188">	}</a>
<a name="ln2189"> </a>
<a name="ln2190">	insert_team_into_parent(parentTeam, team);</a>
<a name="ln2191">	insert_team_into_group(parentTeam-&gt;group, team);</a>
<a name="ln2192"> </a>
<a name="ln2193">	team-&gt;Unlock();</a>
<a name="ln2194">	parentTeam-&gt;UnlockTeamAndProcessGroup();</a>
<a name="ln2195"> </a>
<a name="ln2196">	// notify team listeners</a>
<a name="ln2197">	sNotificationService.Notify(TEAM_ADDED, team);</a>
<a name="ln2198"> </a>
<a name="ln2199">	if (teamLimitReached) {</a>
<a name="ln2200">		status = B_NO_MORE_TEAMS;</a>
<a name="ln2201">		goto err6;</a>
<a name="ln2202">	}</a>
<a name="ln2203"> </a>
<a name="ln2204">	// create the main thread</a>
<a name="ln2205">	{</a>
<a name="ln2206">		ThreadCreationAttributes threadCreationAttributes(NULL,</a>
<a name="ln2207">			parentThread-&gt;name, parentThread-&gt;priority, NULL, team-&gt;id, thread);</a>
<a name="ln2208">		threadCreationAttributes.forkArgs = forkArgs;</a>
<a name="ln2209">		threadCreationAttributes.flags |= THREAD_CREATION_FLAG_DEFER_SIGNALS;</a>
<a name="ln2210">		threadID = thread_create_thread(threadCreationAttributes, false);</a>
<a name="ln2211">		if (threadID &lt; 0) {</a>
<a name="ln2212">			status = threadID;</a>
<a name="ln2213">			goto err6;</a>
<a name="ln2214">		}</a>
<a name="ln2215">	}</a>
<a name="ln2216"> </a>
<a name="ln2217">	// notify the debugger</a>
<a name="ln2218">	user_debug_team_created(team-&gt;id);</a>
<a name="ln2219"> </a>
<a name="ln2220">	T(TeamForked(threadID));</a>
<a name="ln2221"> </a>
<a name="ln2222">	resume_thread(threadID);</a>
<a name="ln2223">	return threadID;</a>
<a name="ln2224"> </a>
<a name="ln2225">err6:</a>
<a name="ln2226">	// Remove the team structure from the process group, the parent team, and</a>
<a name="ln2227">	// the team hash table and delete the team structure.</a>
<a name="ln2228">	parentTeam-&gt;LockTeamAndProcessGroup();</a>
<a name="ln2229">	team-&gt;Lock();</a>
<a name="ln2230"> </a>
<a name="ln2231">	remove_team_from_group(team);</a>
<a name="ln2232">	remove_team_from_parent(team-&gt;parent, team);</a>
<a name="ln2233"> </a>
<a name="ln2234">	team-&gt;Unlock();</a>
<a name="ln2235">	parentTeam-&gt;UnlockTeamAndProcessGroup();</a>
<a name="ln2236"> </a>
<a name="ln2237">	{</a>
<a name="ln2238">		InterruptsWriteSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln2239">		sTeamHash.Remove(team);</a>
<a name="ln2240">		if (!teamLimitReached)</a>
<a name="ln2241">			sUsedTeams--;</a>
<a name="ln2242">	}</a>
<a name="ln2243"> </a>
<a name="ln2244">	sNotificationService.Notify(TEAM_REMOVED, team);</a>
<a name="ln2245">err5:</a>
<a name="ln2246">	remove_images(team);</a>
<a name="ln2247">err4:</a>
<a name="ln2248">	team-&gt;address_space-&gt;RemoveAndPut();</a>
<a name="ln2249">err3:</a>
<a name="ln2250">	delete_realtime_sem_context(team-&gt;realtime_sem_context);</a>
<a name="ln2251">err2:</a>
<a name="ln2252">	free(forkArgs);</a>
<a name="ln2253">err1:</a>
<a name="ln2254">	team-&gt;ReleaseReference();</a>
<a name="ln2255"> </a>
<a name="ln2256">	return status;</a>
<a name="ln2257">}</a>
<a name="ln2258"> </a>
<a name="ln2259"> </a>
<a name="ln2260">/*!	Returns if the specified team \a parent has any children belonging to the</a>
<a name="ln2261">	process group with the specified ID \a groupID.</a>
<a name="ln2262">	The caller must hold \a parent's lock.</a>
<a name="ln2263">*/</a>
<a name="ln2264">static bool</a>
<a name="ln2265">has_children_in_group(Team* parent, pid_t groupID)</a>
<a name="ln2266">{</a>
<a name="ln2267">	for (Team* child = parent-&gt;children; child != NULL;</a>
<a name="ln2268">			child = child-&gt;siblings_next) {</a>
<a name="ln2269">		TeamLocker childLocker(child);</a>
<a name="ln2270">		if (child-&gt;group_id == groupID)</a>
<a name="ln2271">			return true;</a>
<a name="ln2272">	}</a>
<a name="ln2273"> </a>
<a name="ln2274">	return false;</a>
<a name="ln2275">}</a>
<a name="ln2276"> </a>
<a name="ln2277"> </a>
<a name="ln2278">/*!	Returns the first job control entry from \a children, which matches \a id.</a>
<a name="ln2279">	\a id can be:</a>
<a name="ln2280">	- \code &gt; 0 \endcode: Matching an entry with that team ID.</a>
<a name="ln2281">	- \code == -1 \endcode: Matching any entry.</a>
<a name="ln2282">	- \code &lt; -1 \endcode: Matching any entry with a process group ID of \c -id.</a>
<a name="ln2283">	\c 0 is an invalid value for \a id.</a>
<a name="ln2284"> </a>
<a name="ln2285">	The caller must hold the lock of the team that \a children belongs to.</a>
<a name="ln2286"> </a>
<a name="ln2287">	\param children The job control entry list to check.</a>
<a name="ln2288">	\param id The match criterion.</a>
<a name="ln2289">	\return The first matching entry or \c NULL, if none matches.</a>
<a name="ln2290">*/</a>
<a name="ln2291">static job_control_entry*</a>
<a name="ln2292">get_job_control_entry(team_job_control_children&amp; children, pid_t id)</a>
<a name="ln2293">{</a>
<a name="ln2294">	for (JobControlEntryList::Iterator it = children.entries.GetIterator();</a>
<a name="ln2295">		 job_control_entry* entry = it.Next();) {</a>
<a name="ln2296"> </a>
<a name="ln2297">		if (id &gt; 0) {</a>
<a name="ln2298">			if (entry-&gt;thread == id)</a>
<a name="ln2299">				return entry;</a>
<a name="ln2300">		} else if (id == -1) {</a>
<a name="ln2301">			return entry;</a>
<a name="ln2302">		} else {</a>
<a name="ln2303">			pid_t processGroup</a>
<a name="ln2304">				= (entry-&gt;team ? entry-&gt;team-&gt;group_id : entry-&gt;group_id);</a>
<a name="ln2305">			if (processGroup == -id)</a>
<a name="ln2306">				return entry;</a>
<a name="ln2307">		}</a>
<a name="ln2308">	}</a>
<a name="ln2309"> </a>
<a name="ln2310">	return NULL;</a>
<a name="ln2311">}</a>
<a name="ln2312"> </a>
<a name="ln2313"> </a>
<a name="ln2314">/*!	Returns the first job control entry from one of team's dead, continued, or</a>
<a name="ln2315">	stopped children which matches \a id.</a>
<a name="ln2316">	\a id can be:</a>
<a name="ln2317">	- \code &gt; 0 \endcode: Matching an entry with that team ID.</a>
<a name="ln2318">	- \code == -1 \endcode: Matching any entry.</a>
<a name="ln2319">	- \code &lt; -1 \endcode: Matching any entry with a process group ID of \c -id.</a>
<a name="ln2320">	\c 0 is an invalid value for \a id.</a>
<a name="ln2321"> </a>
<a name="ln2322">	The caller must hold \a team's lock.</a>
<a name="ln2323"> </a>
<a name="ln2324">	\param team The team whose dead, stopped, and continued child lists shall be</a>
<a name="ln2325">		checked.</a>
<a name="ln2326">	\param id The match criterion.</a>
<a name="ln2327">	\param flags Specifies which children shall be considered. Dead children</a>
<a name="ln2328">		are considered when \a flags is ORed bitwise with \c WEXITED, stopped</a>
<a name="ln2329">		children are considered when \a flags is ORed bitwise with \c WUNTRACED</a>
<a name="ln2330">		or \c WSTOPPED, continued children when \a flags is ORed bitwise with</a>
<a name="ln2331">		\c WCONTINUED.</a>
<a name="ln2332">	\return The first matching entry or \c NULL, if none matches.</a>
<a name="ln2333">*/</a>
<a name="ln2334">static job_control_entry*</a>
<a name="ln2335">get_job_control_entry(Team* team, pid_t id, uint32 flags)</a>
<a name="ln2336">{</a>
<a name="ln2337">	job_control_entry* entry = NULL;</a>
<a name="ln2338"> </a>
<a name="ln2339">	if ((flags &amp; WEXITED) != 0)</a>
<a name="ln2340">		entry = get_job_control_entry(team-&gt;dead_children, id);</a>
<a name="ln2341"> </a>
<a name="ln2342">	if (entry == NULL &amp;&amp; (flags &amp; WCONTINUED) != 0)</a>
<a name="ln2343">		entry = get_job_control_entry(team-&gt;continued_children, id);</a>
<a name="ln2344"> </a>
<a name="ln2345">	if (entry == NULL &amp;&amp; (flags &amp; (WUNTRACED | WSTOPPED)) != 0)</a>
<a name="ln2346">		entry = get_job_control_entry(team-&gt;stopped_children, id);</a>
<a name="ln2347"> </a>
<a name="ln2348">	return entry;</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351"> </a>
<a name="ln2352">job_control_entry::job_control_entry()</a>
<a name="ln2353">	:</a>
<a name="ln2354">	has_group_ref(false)</a>
<a name="ln2355">{</a>
<a name="ln2356">}</a>
<a name="ln2357"> </a>
<a name="ln2358"> </a>
<a name="ln2359">job_control_entry::~job_control_entry()</a>
<a name="ln2360">{</a>
<a name="ln2361">	if (has_group_ref) {</a>
<a name="ln2362">		InterruptsSpinLocker groupHashLocker(sGroupHashLock);</a>
<a name="ln2363"> </a>
<a name="ln2364">		ProcessGroup* group = sGroupHash.Lookup(group_id);</a>
<a name="ln2365">		if (group == NULL) {</a>
<a name="ln2366">			panic(&quot;job_control_entry::~job_control_entry(): unknown group &quot;</a>
<a name="ln2367">				&quot;ID: %&quot; B_PRId32, group_id);</a>
<a name="ln2368">			return;</a>
<a name="ln2369">		}</a>
<a name="ln2370"> </a>
<a name="ln2371">		groupHashLocker.Unlock();</a>
<a name="ln2372"> </a>
<a name="ln2373">		group-&gt;ReleaseReference();</a>
<a name="ln2374">	}</a>
<a name="ln2375">}</a>
<a name="ln2376"> </a>
<a name="ln2377"> </a>
<a name="ln2378">/*!	Invoked when the owning team is dying, initializing the entry according to</a>
<a name="ln2379">	the dead state.</a>
<a name="ln2380"> </a>
<a name="ln2381">	The caller must hold the owning team's lock and the scheduler lock.</a>
<a name="ln2382">*/</a>
<a name="ln2383">void</a>
<a name="ln2384">job_control_entry::InitDeadState()</a>
<a name="ln2385">{</a>
<a name="ln2386">	if (team != NULL) {</a>
<a name="ln2387">		ASSERT(team-&gt;exit.initialized);</a>
<a name="ln2388"> </a>
<a name="ln2389">		group_id = team-&gt;group_id;</a>
<a name="ln2390">		team-&gt;group-&gt;AcquireReference();</a>
<a name="ln2391">		has_group_ref = true;</a>
<a name="ln2392"> </a>
<a name="ln2393">		thread = team-&gt;id;</a>
<a name="ln2394">		status = team-&gt;exit.status;</a>
<a name="ln2395">		reason = team-&gt;exit.reason;</a>
<a name="ln2396">		signal = team-&gt;exit.signal;</a>
<a name="ln2397">		signaling_user = team-&gt;exit.signaling_user;</a>
<a name="ln2398">		user_time = team-&gt;dead_threads_user_time</a>
<a name="ln2399">			+ team-&gt;dead_children.user_time;</a>
<a name="ln2400">		kernel_time = team-&gt;dead_threads_kernel_time</a>
<a name="ln2401">			+ team-&gt;dead_children.kernel_time;</a>
<a name="ln2402"> </a>
<a name="ln2403">		team = NULL;</a>
<a name="ln2404">	}</a>
<a name="ln2405">}</a>
<a name="ln2406"> </a>
<a name="ln2407"> </a>
<a name="ln2408">job_control_entry&amp;</a>
<a name="ln2409">job_control_entry::operator=(const job_control_entry&amp; other)</a>
<a name="ln2410">{</a>
<a name="ln2411">	state = other.state;</a>
<a name="ln2412">	thread = other.thread;</a>
<a name="ln2413">	signal = other.signal;</a>
<a name="ln2414">	has_group_ref = false;</a>
<a name="ln2415">	signaling_user = other.signaling_user;</a>
<a name="ln2416">	team = other.team;</a>
<a name="ln2417">	group_id = other.group_id;</a>
<a name="ln2418">	status = other.status;</a>
<a name="ln2419">	reason = other.reason;</a>
<a name="ln2420">	user_time = other.user_time;</a>
<a name="ln2421">	kernel_time = other.kernel_time;</a>
<a name="ln2422"> </a>
<a name="ln2423">	return *this;</a>
<a name="ln2424">}</a>
<a name="ln2425"> </a>
<a name="ln2426"> </a>
<a name="ln2427">/*! This is the kernel backend for waitid().</a>
<a name="ln2428">*/</a>
<a name="ln2429">static thread_id</a>
<a name="ln2430">wait_for_child(pid_t child, uint32 flags, siginfo_t&amp; _info,</a>
<a name="ln2431">	team_usage_info&amp; _usage_info)</a>
<a name="ln2432">{</a>
<a name="ln2433">	Thread* thread = thread_get_current_thread();</a>
<a name="ln2434">	Team* team = thread-&gt;team;</a>
<a name="ln2435">	struct job_control_entry foundEntry;</a>
<a name="ln2436">	struct job_control_entry* freeDeathEntry = NULL;</a>
<a name="ln2437">	status_t status = B_OK;</a>
<a name="ln2438"> </a>
<a name="ln2439">	TRACE((&quot;wait_for_child(child = %&quot; B_PRId32 &quot;, flags = %&quot; B_PRId32 &quot;)\n&quot;,</a>
<a name="ln2440">		child, flags));</a>
<a name="ln2441"> </a>
<a name="ln2442">	T(WaitForChild(child, flags));</a>
<a name="ln2443"> </a>
<a name="ln2444">	if ((flags &amp; (WEXITED | WUNTRACED | WSTOPPED | WCONTINUED)) == 0) {</a>
<a name="ln2445">		T(WaitForChildDone(B_BAD_VALUE));</a>
<a name="ln2446">		return B_BAD_VALUE;</a>
<a name="ln2447">	}</a>
<a name="ln2448"> </a>
<a name="ln2449">	pid_t originalChild = child;</a>
<a name="ln2450"> </a>
<a name="ln2451">	bool ignoreFoundEntries = false;</a>
<a name="ln2452">	bool ignoreFoundEntriesChecked = false;</a>
<a name="ln2453"> </a>
<a name="ln2454">	while (true) {</a>
<a name="ln2455">		// lock the team</a>
<a name="ln2456">		TeamLocker teamLocker(team);</a>
<a name="ln2457"> </a>
<a name="ln2458">		// A 0 child argument means to wait for all children in the process</a>
<a name="ln2459">		// group of the calling team.</a>
<a name="ln2460">		child = originalChild == 0 ? -team-&gt;group_id : originalChild;</a>
<a name="ln2461"> </a>
<a name="ln2462">		// check whether any condition holds</a>
<a name="ln2463">		job_control_entry* entry = get_job_control_entry(team, child, flags);</a>
<a name="ln2464"> </a>
<a name="ln2465">		// If we don't have an entry yet, check whether there are any children</a>
<a name="ln2466">		// complying to the process group specification at all.</a>
<a name="ln2467">		if (entry == NULL) {</a>
<a name="ln2468">			// No success yet -- check whether there are any children complying</a>
<a name="ln2469">			// to the process group specification at all.</a>
<a name="ln2470">			bool childrenExist = false;</a>
<a name="ln2471">			if (child == -1) {</a>
<a name="ln2472">				childrenExist = team-&gt;children != NULL;</a>
<a name="ln2473">			} else if (child &lt; -1) {</a>
<a name="ln2474">				childrenExist = has_children_in_group(team, -child);</a>
<a name="ln2475">			} else if (child != team-&gt;id) {</a>
<a name="ln2476">				if (Team* childTeam = Team::Get(child)) {</a>
<a name="ln2477">					BReference&lt;Team&gt; childTeamReference(childTeam, true);</a>
<a name="ln2478">					TeamLocker childTeamLocker(childTeam);</a>
<a name="ln2479">					childrenExist = childTeam-&gt;parent == team;</a>
<a name="ln2480">				}</a>
<a name="ln2481">			}</a>
<a name="ln2482"> </a>
<a name="ln2483">			if (!childrenExist) {</a>
<a name="ln2484">				// there is no child we could wait for</a>
<a name="ln2485">				status = ECHILD;</a>
<a name="ln2486">			} else {</a>
<a name="ln2487">				// the children we're waiting for are still running</a>
<a name="ln2488">				status = B_WOULD_BLOCK;</a>
<a name="ln2489">			}</a>
<a name="ln2490">		} else {</a>
<a name="ln2491">			// got something</a>
<a name="ln2492">			foundEntry = *entry;</a>
<a name="ln2493"> </a>
<a name="ln2494">			// unless WNOWAIT has been specified, &quot;consume&quot; the wait state</a>
<a name="ln2495">			if ((flags &amp; WNOWAIT) == 0 || ignoreFoundEntries) {</a>
<a name="ln2496">				if (entry-&gt;state == JOB_CONTROL_STATE_DEAD) {</a>
<a name="ln2497">					// The child is dead. Reap its death entry.</a>
<a name="ln2498">					freeDeathEntry = entry;</a>
<a name="ln2499">					team-&gt;dead_children.entries.Remove(entry);</a>
<a name="ln2500">					team-&gt;dead_children.count--;</a>
<a name="ln2501">				} else {</a>
<a name="ln2502">					// The child is well. Reset its job control state.</a>
<a name="ln2503">					team_set_job_control_state(entry-&gt;team,</a>
<a name="ln2504">						JOB_CONTROL_STATE_NONE, NULL);</a>
<a name="ln2505">				}</a>
<a name="ln2506">			}</a>
<a name="ln2507">		}</a>
<a name="ln2508"> </a>
<a name="ln2509">		// If we haven't got anything yet, prepare for waiting for the</a>
<a name="ln2510">		// condition variable.</a>
<a name="ln2511">		ConditionVariableEntry deadWaitEntry;</a>
<a name="ln2512"> </a>
<a name="ln2513">		if (status == B_WOULD_BLOCK &amp;&amp; (flags &amp; WNOHANG) == 0)</a>
<a name="ln2514">			team-&gt;dead_children.condition_variable.Add(&amp;deadWaitEntry);</a>
<a name="ln2515"> </a>
<a name="ln2516">		teamLocker.Unlock();</a>
<a name="ln2517"> </a>
<a name="ln2518">		// we got our entry and can return to our caller</a>
<a name="ln2519">		if (status == B_OK) {</a>
<a name="ln2520">			if (ignoreFoundEntries) {</a>
<a name="ln2521">				// ... unless we shall ignore found entries</a>
<a name="ln2522">				delete freeDeathEntry;</a>
<a name="ln2523">				freeDeathEntry = NULL;</a>
<a name="ln2524">				continue;</a>
<a name="ln2525">			}</a>
<a name="ln2526"> </a>
<a name="ln2527">			break;</a>
<a name="ln2528">		}</a>
<a name="ln2529"> </a>
<a name="ln2530">		if (status != B_WOULD_BLOCK || (flags &amp; WNOHANG) != 0) {</a>
<a name="ln2531">			T(WaitForChildDone(status));</a>
<a name="ln2532">			return status;</a>
<a name="ln2533">		}</a>
<a name="ln2534"> </a>
<a name="ln2535">		status = deadWaitEntry.Wait(B_CAN_INTERRUPT);</a>
<a name="ln2536">		if (status == B_INTERRUPTED) {</a>
<a name="ln2537">			T(WaitForChildDone(status));</a>
<a name="ln2538">			return status;</a>
<a name="ln2539">		}</a>
<a name="ln2540"> </a>
<a name="ln2541">		// If SA_NOCLDWAIT is set or SIGCHLD is ignored, we shall wait until</a>
<a name="ln2542">		// all our children are dead and fail with ECHILD. We check the</a>
<a name="ln2543">		// condition at this point.</a>
<a name="ln2544">		if (!ignoreFoundEntriesChecked) {</a>
<a name="ln2545">			teamLocker.Lock();</a>
<a name="ln2546"> </a>
<a name="ln2547">			struct sigaction&amp; handler = team-&gt;SignalActionFor(SIGCHLD);</a>
<a name="ln2548">			if ((handler.sa_flags &amp; SA_NOCLDWAIT) != 0</a>
<a name="ln2549">				|| handler.sa_handler == SIG_IGN) {</a>
<a name="ln2550">				ignoreFoundEntries = true;</a>
<a name="ln2551">			}</a>
<a name="ln2552"> </a>
<a name="ln2553">			teamLocker.Unlock();</a>
<a name="ln2554"> </a>
<a name="ln2555">			ignoreFoundEntriesChecked = true;</a>
<a name="ln2556">		}</a>
<a name="ln2557">	}</a>
<a name="ln2558"> </a>
<a name="ln2559">	delete freeDeathEntry;</a>
<a name="ln2560"> </a>
<a name="ln2561">	// When we got here, we have a valid death entry, and already got</a>
<a name="ln2562">	// unregistered from the team or group. Fill in the returned info.</a>
<a name="ln2563">	memset(&amp;_info, 0, sizeof(_info));</a>
<a name="ln2564">	_info.si_signo = SIGCHLD;</a>
<a name="ln2565">	_info.si_pid = foundEntry.thread;</a>
<a name="ln2566">	_info.si_uid = foundEntry.signaling_user;</a>
<a name="ln2567">	// TODO: Fill in si_errno?</a>
<a name="ln2568"> </a>
<a name="ln2569">	switch (foundEntry.state) {</a>
<a name="ln2570">		case JOB_CONTROL_STATE_DEAD:</a>
<a name="ln2571">			_info.si_code = foundEntry.reason;</a>
<a name="ln2572">			_info.si_status = foundEntry.reason == CLD_EXITED</a>
<a name="ln2573">				? foundEntry.status : foundEntry.signal;</a>
<a name="ln2574">			_usage_info.user_time = foundEntry.user_time;</a>
<a name="ln2575">			_usage_info.kernel_time = foundEntry.kernel_time;</a>
<a name="ln2576">			break;</a>
<a name="ln2577">		case JOB_CONTROL_STATE_STOPPED:</a>
<a name="ln2578">			_info.si_code = CLD_STOPPED;</a>
<a name="ln2579">			_info.si_status = foundEntry.signal;</a>
<a name="ln2580">			break;</a>
<a name="ln2581">		case JOB_CONTROL_STATE_CONTINUED:</a>
<a name="ln2582">			_info.si_code = CLD_CONTINUED;</a>
<a name="ln2583">			_info.si_status = 0;</a>
<a name="ln2584">			break;</a>
<a name="ln2585">		case JOB_CONTROL_STATE_NONE:</a>
<a name="ln2586">			// can't happen</a>
<a name="ln2587">			break;</a>
<a name="ln2588">	}</a>
<a name="ln2589"> </a>
<a name="ln2590">	// If SIGCHLD is blocked, we shall clear pending SIGCHLDs, if no other child</a>
<a name="ln2591">	// status is available.</a>
<a name="ln2592">	TeamLocker teamLocker(team);</a>
<a name="ln2593">	InterruptsSpinLocker signalLocker(team-&gt;signal_lock);</a>
<a name="ln2594">	SpinLocker threadCreationLocker(gThreadCreationLock);</a>
<a name="ln2595"> </a>
<a name="ln2596">	if (is_team_signal_blocked(team, SIGCHLD)) {</a>
<a name="ln2597">		if (get_job_control_entry(team, child, flags) == NULL)</a>
<a name="ln2598">			team-&gt;RemovePendingSignals(SIGNAL_TO_MASK(SIGCHLD));</a>
<a name="ln2599">	}</a>
<a name="ln2600"> </a>
<a name="ln2601">	threadCreationLocker.Unlock();</a>
<a name="ln2602">	signalLocker.Unlock();</a>
<a name="ln2603">	teamLocker.Unlock();</a>
<a name="ln2604"> </a>
<a name="ln2605">	// When the team is dead, the main thread continues to live in the kernel</a>
<a name="ln2606">	// team for a very short time. To avoid surprises for the caller we rather</a>
<a name="ln2607">	// wait until the thread is really gone.</a>
<a name="ln2608">	if (foundEntry.state == JOB_CONTROL_STATE_DEAD)</a>
<a name="ln2609">		wait_for_thread(foundEntry.thread, NULL);</a>
<a name="ln2610"> </a>
<a name="ln2611">	T(WaitForChildDone(foundEntry));</a>
<a name="ln2612"> </a>
<a name="ln2613">	return foundEntry.thread;</a>
<a name="ln2614">}</a>
<a name="ln2615"> </a>
<a name="ln2616"> </a>
<a name="ln2617">/*! Fills the team_info structure with information from the specified team.</a>
<a name="ln2618">	Interrupts must be enabled. The team must not be locked.</a>
<a name="ln2619">*/</a>
<a name="ln2620">static status_t</a>
<a name="ln2621">fill_team_info(Team* team, team_info* info, size_t size)</a>
<a name="ln2622">{</a>
<a name="ln2623">	if (size != sizeof(team_info))</a>
<a name="ln2624">		return B_BAD_VALUE;</a>
<a name="ln2625"> </a>
<a name="ln2626">	// TODO: Set more informations for team_info</a>
<a name="ln2627">	memset(info, 0, size);</a>
<a name="ln2628"> </a>
<a name="ln2629">	info-&gt;team = team-&gt;id;</a>
<a name="ln2630">		// immutable</a>
<a name="ln2631">	info-&gt;image_count = count_images(team);</a>
<a name="ln2632">		// protected by sImageMutex</a>
<a name="ln2633"> </a>
<a name="ln2634">	TeamLocker teamLocker(team);</a>
<a name="ln2635">	InterruptsSpinLocker debugInfoLocker(team-&gt;debug_info.lock);</a>
<a name="ln2636"> </a>
<a name="ln2637">	info-&gt;thread_count = team-&gt;num_threads;</a>
<a name="ln2638">	//info-&gt;area_count =</a>
<a name="ln2639">	info-&gt;debugger_nub_thread = team-&gt;debug_info.nub_thread;</a>
<a name="ln2640">	info-&gt;debugger_nub_port = team-&gt;debug_info.nub_port;</a>
<a name="ln2641">	info-&gt;uid = team-&gt;effective_uid;</a>
<a name="ln2642">	info-&gt;gid = team-&gt;effective_gid;</a>
<a name="ln2643"> </a>
<a name="ln2644">	strlcpy(info-&gt;args, team-&gt;Args(), sizeof(info-&gt;args));</a>
<a name="ln2645">	info-&gt;argc = 1;</a>
<a name="ln2646"> </a>
<a name="ln2647">	return B_OK;</a>
<a name="ln2648">}</a>
<a name="ln2649"> </a>
<a name="ln2650"> </a>
<a name="ln2651">/*!	Returns whether the process group contains stopped processes.</a>
<a name="ln2652">	The caller must hold the process group's lock.</a>
<a name="ln2653">*/</a>
<a name="ln2654">static bool</a>
<a name="ln2655">process_group_has_stopped_processes(ProcessGroup* group)</a>
<a name="ln2656">{</a>
<a name="ln2657">	Team* team = group-&gt;teams;</a>
<a name="ln2658">	while (team != NULL) {</a>
<a name="ln2659">		// the parent team's lock guards the job control entry -- acquire it</a>
<a name="ln2660">		team-&gt;LockTeamAndParent(false);</a>
<a name="ln2661"> </a>
<a name="ln2662">		if (team-&gt;job_control_entry != NULL</a>
<a name="ln2663">			&amp;&amp; team-&gt;job_control_entry-&gt;state == JOB_CONTROL_STATE_STOPPED) {</a>
<a name="ln2664">			team-&gt;UnlockTeamAndParent();</a>
<a name="ln2665">			return true;</a>
<a name="ln2666">		}</a>
<a name="ln2667"> </a>
<a name="ln2668">		team-&gt;UnlockTeamAndParent();</a>
<a name="ln2669"> </a>
<a name="ln2670">		team = team-&gt;group_next;</a>
<a name="ln2671">	}</a>
<a name="ln2672"> </a>
<a name="ln2673">	return false;</a>
<a name="ln2674">}</a>
<a name="ln2675"> </a>
<a name="ln2676"> </a>
<a name="ln2677">/*!	Iterates through all process groups queued in team_remove_team() and signals</a>
<a name="ln2678">	those that are orphaned and have stopped processes.</a>
<a name="ln2679">	The caller must not hold any team or process group locks.</a>
<a name="ln2680">*/</a>
<a name="ln2681">static void</a>
<a name="ln2682">orphaned_process_group_check()</a>
<a name="ln2683">{</a>
<a name="ln2684">	// process as long as there are groups in the list</a>
<a name="ln2685">	while (true) {</a>
<a name="ln2686">		// remove the head from the list</a>
<a name="ln2687">		MutexLocker orphanedCheckLocker(sOrphanedCheckLock);</a>
<a name="ln2688"> </a>
<a name="ln2689">		ProcessGroup* group = sOrphanedCheckProcessGroups.RemoveHead();</a>
<a name="ln2690">		if (group == NULL)</a>
<a name="ln2691">			return;</a>
<a name="ln2692"> </a>
<a name="ln2693">		group-&gt;UnsetOrphanedCheck();</a>
<a name="ln2694">		BReference&lt;ProcessGroup&gt; groupReference(group);</a>
<a name="ln2695"> </a>
<a name="ln2696">		orphanedCheckLocker.Unlock();</a>
<a name="ln2697"> </a>
<a name="ln2698">		AutoLocker&lt;ProcessGroup&gt; groupLocker(group);</a>
<a name="ln2699"> </a>
<a name="ln2700">		// If the group is orphaned and contains stopped processes, we're</a>
<a name="ln2701">		// supposed to send SIGHUP + SIGCONT.</a>
<a name="ln2702">		if (group-&gt;IsOrphaned() &amp;&amp; process_group_has_stopped_processes(group)) {</a>
<a name="ln2703">			Thread* currentThread = thread_get_current_thread();</a>
<a name="ln2704"> </a>
<a name="ln2705">			Signal signal(SIGHUP, SI_USER, B_OK, currentThread-&gt;team-&gt;id);</a>
<a name="ln2706">			send_signal_to_process_group_locked(group, signal, 0);</a>
<a name="ln2707"> </a>
<a name="ln2708">			signal.SetNumber(SIGCONT);</a>
<a name="ln2709">			send_signal_to_process_group_locked(group, signal, 0);</a>
<a name="ln2710">		}</a>
<a name="ln2711">	}</a>
<a name="ln2712">}</a>
<a name="ln2713"> </a>
<a name="ln2714"> </a>
<a name="ln2715">static status_t</a>
<a name="ln2716">common_get_team_usage_info(team_id id, int32 who, team_usage_info* info,</a>
<a name="ln2717">	uint32 flags)</a>
<a name="ln2718">{</a>
<a name="ln2719">	if (who != B_TEAM_USAGE_SELF &amp;&amp; who != B_TEAM_USAGE_CHILDREN)</a>
<a name="ln2720">		return B_BAD_VALUE;</a>
<a name="ln2721"> </a>
<a name="ln2722">	// get the team</a>
<a name="ln2723">	Team* team = Team::GetAndLock(id);</a>
<a name="ln2724">	if (team == NULL)</a>
<a name="ln2725">		return B_BAD_TEAM_ID;</a>
<a name="ln2726">	BReference&lt;Team&gt; teamReference(team, true);</a>
<a name="ln2727">	TeamLocker teamLocker(team, true);</a>
<a name="ln2728"> </a>
<a name="ln2729">	if ((flags &amp; B_CHECK_PERMISSION) != 0) {</a>
<a name="ln2730">		uid_t uid = geteuid();</a>
<a name="ln2731">		if (uid != 0 &amp;&amp; uid != team-&gt;effective_uid)</a>
<a name="ln2732">			return B_NOT_ALLOWED;</a>
<a name="ln2733">	}</a>
<a name="ln2734"> </a>
<a name="ln2735">	bigtime_t kernelTime = 0;</a>
<a name="ln2736">	bigtime_t userTime = 0;</a>
<a name="ln2737"> </a>
<a name="ln2738">	switch (who) {</a>
<a name="ln2739">		case B_TEAM_USAGE_SELF:</a>
<a name="ln2740">		{</a>
<a name="ln2741">			Thread* thread = team-&gt;thread_list;</a>
<a name="ln2742"> </a>
<a name="ln2743">			for (; thread != NULL; thread = thread-&gt;team_next) {</a>
<a name="ln2744">				InterruptsSpinLocker threadTimeLocker(thread-&gt;time_lock);</a>
<a name="ln2745">				kernelTime += thread-&gt;kernel_time;</a>
<a name="ln2746">				userTime += thread-&gt;user_time;</a>
<a name="ln2747">			}</a>
<a name="ln2748"> </a>
<a name="ln2749">			kernelTime += team-&gt;dead_threads_kernel_time;</a>
<a name="ln2750">			userTime += team-&gt;dead_threads_user_time;</a>
<a name="ln2751">			break;</a>
<a name="ln2752">		}</a>
<a name="ln2753"> </a>
<a name="ln2754">		case B_TEAM_USAGE_CHILDREN:</a>
<a name="ln2755">		{</a>
<a name="ln2756">			Team* child = team-&gt;children;</a>
<a name="ln2757">			for (; child != NULL; child = child-&gt;siblings_next) {</a>
<a name="ln2758">				TeamLocker childLocker(child);</a>
<a name="ln2759"> </a>
<a name="ln2760">				Thread* thread = team-&gt;thread_list;</a>
<a name="ln2761"> </a>
<a name="ln2762">				for (; thread != NULL; thread = thread-&gt;team_next) {</a>
<a name="ln2763">					InterruptsSpinLocker threadTimeLocker(thread-&gt;time_lock);</a>
<a name="ln2764">					kernelTime += thread-&gt;kernel_time;</a>
<a name="ln2765">					userTime += thread-&gt;user_time;</a>
<a name="ln2766">				}</a>
<a name="ln2767"> </a>
<a name="ln2768">				kernelTime += child-&gt;dead_threads_kernel_time;</a>
<a name="ln2769">				userTime += child-&gt;dead_threads_user_time;</a>
<a name="ln2770">			}</a>
<a name="ln2771"> </a>
<a name="ln2772">			kernelTime += team-&gt;dead_children.kernel_time;</a>
<a name="ln2773">			userTime += team-&gt;dead_children.user_time;</a>
<a name="ln2774">			break;</a>
<a name="ln2775">		}</a>
<a name="ln2776">	}</a>
<a name="ln2777"> </a>
<a name="ln2778">	info-&gt;kernel_time = kernelTime;</a>
<a name="ln2779">	info-&gt;user_time = userTime;</a>
<a name="ln2780"> </a>
<a name="ln2781">	return B_OK;</a>
<a name="ln2782">}</a>
<a name="ln2783"> </a>
<a name="ln2784"> </a>
<a name="ln2785">//	#pragma mark - Private kernel API</a>
<a name="ln2786"> </a>
<a name="ln2787"> </a>
<a name="ln2788">status_t</a>
<a name="ln2789">team_init(kernel_args* args)</a>
<a name="ln2790">{</a>
<a name="ln2791">	// create the team hash table</a>
<a name="ln2792">	new(&amp;sTeamHash) TeamTable;</a>
<a name="ln2793">	if (sTeamHash.Init(64) != B_OK)</a>
<a name="ln2794">		panic(&quot;Failed to init team hash table!&quot;);</a>
<a name="ln2795"> </a>
<a name="ln2796">	new(&amp;sGroupHash) ProcessGroupHashTable;</a>
<a name="ln2797">	if (sGroupHash.Init() != B_OK)</a>
<a name="ln2798">		panic(&quot;Failed to init process group hash table!&quot;);</a>
<a name="ln2799"> </a>
<a name="ln2800">	// create initial session and process groups</a>
<a name="ln2801"> </a>
<a name="ln2802">	ProcessSession* session = new(std::nothrow) ProcessSession(1);</a>
<a name="ln2803">	if (session == NULL)</a>
<a name="ln2804">		panic(&quot;Could not create initial session.\n&quot;);</a>
<a name="ln2805">	BReference&lt;ProcessSession&gt; sessionReference(session, true);</a>
<a name="ln2806"> </a>
<a name="ln2807">	ProcessGroup* group = new(std::nothrow) ProcessGroup(1);</a>
<a name="ln2808">	if (group == NULL)</a>
<a name="ln2809">		panic(&quot;Could not create initial process group.\n&quot;);</a>
<a name="ln2810">	BReference&lt;ProcessGroup&gt; groupReference(group, true);</a>
<a name="ln2811"> </a>
<a name="ln2812">	group-&gt;Publish(session);</a>
<a name="ln2813"> </a>
<a name="ln2814">	// create the kernel team</a>
<a name="ln2815">	sKernelTeam = Team::Create(1, &quot;kernel_team&quot;, true);</a>
<a name="ln2816">	if (sKernelTeam == NULL)</a>
<a name="ln2817">		panic(&quot;could not create kernel team!\n&quot;);</a>
<a name="ln2818">	sKernelTeam-&gt;SetArgs(sKernelTeam-&gt;Name());</a>
<a name="ln2819">	sKernelTeam-&gt;state = TEAM_STATE_NORMAL;</a>
<a name="ln2820"> </a>
<a name="ln2821">	sKernelTeam-&gt;saved_set_uid = 0;</a>
<a name="ln2822">	sKernelTeam-&gt;real_uid = 0;</a>
<a name="ln2823">	sKernelTeam-&gt;effective_uid = 0;</a>
<a name="ln2824">	sKernelTeam-&gt;saved_set_gid = 0;</a>
<a name="ln2825">	sKernelTeam-&gt;real_gid = 0;</a>
<a name="ln2826">	sKernelTeam-&gt;effective_gid = 0;</a>
<a name="ln2827">	sKernelTeam-&gt;supplementary_groups = NULL;</a>
<a name="ln2828">	sKernelTeam-&gt;supplementary_group_count = 0;</a>
<a name="ln2829"> </a>
<a name="ln2830">	insert_team_into_group(group, sKernelTeam);</a>
<a name="ln2831"> </a>
<a name="ln2832">	sKernelTeam-&gt;io_context = vfs_new_io_context(NULL, false);</a>
<a name="ln2833">	if (sKernelTeam-&gt;io_context == NULL)</a>
<a name="ln2834">		panic(&quot;could not create io_context for kernel team!\n&quot;);</a>
<a name="ln2835"> </a>
<a name="ln2836">	if (vfs_resize_fd_table(sKernelTeam-&gt;io_context, 4096) != B_OK)</a>
<a name="ln2837">		dprintf(&quot;Failed to resize FD table for kernel team!\n&quot;);</a>
<a name="ln2838"> </a>
<a name="ln2839">	// stick it in the team hash</a>
<a name="ln2840">	sTeamHash.Insert(sKernelTeam);</a>
<a name="ln2841"> </a>
<a name="ln2842">	// check safe mode settings</a>
<a name="ln2843">	sDisableUserAddOns = get_safemode_boolean(B_SAFEMODE_DISABLE_USER_ADD_ONS,</a>
<a name="ln2844">		false);</a>
<a name="ln2845"> </a>
<a name="ln2846">	add_debugger_command_etc(&quot;team&quot;, &amp;dump_team_info,</a>
<a name="ln2847">		&quot;Dump info about a particular team&quot;,</a>
<a name="ln2848">		&quot;[ &lt;id&gt; | &lt;address&gt; | &lt;name&gt; ]\n&quot;</a>
<a name="ln2849">		&quot;Prints information about the specified team. If no argument is given\n&quot;</a>
<a name="ln2850">		&quot;the current team is selected.\n&quot;</a>
<a name="ln2851">		&quot;  &lt;id&gt;       - The ID of the team.\n&quot;</a>
<a name="ln2852">		&quot;  &lt;address&gt;  - The address of the team structure.\n&quot;</a>
<a name="ln2853">		&quot;  &lt;name&gt;     - The team's name.\n&quot;, 0);</a>
<a name="ln2854">	add_debugger_command_etc(&quot;teams&quot;, &amp;dump_teams, &quot;List all teams&quot;,</a>
<a name="ln2855">		&quot;\n&quot;</a>
<a name="ln2856">		&quot;Prints a list of all existing teams.\n&quot;, 0);</a>
<a name="ln2857"> </a>
<a name="ln2858">	new(&amp;sNotificationService) TeamNotificationService();</a>
<a name="ln2859"> </a>
<a name="ln2860">	sNotificationService.Register();</a>
<a name="ln2861"> </a>
<a name="ln2862">	return B_OK;</a>
<a name="ln2863">}</a>
<a name="ln2864"> </a>
<a name="ln2865"> </a>
<a name="ln2866">int32</a>
<a name="ln2867">team_max_teams(void)</a>
<a name="ln2868">{</a>
<a name="ln2869">	return sMaxTeams;</a>
<a name="ln2870">}</a>
<a name="ln2871"> </a>
<a name="ln2872"> </a>
<a name="ln2873">int32</a>
<a name="ln2874">team_used_teams(void)</a>
<a name="ln2875">{</a>
<a name="ln2876">	InterruptsReadSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln2877">	return sUsedTeams;</a>
<a name="ln2878">}</a>
<a name="ln2879"> </a>
<a name="ln2880"> </a>
<a name="ln2881">/*! Returns a death entry of a child team specified by ID (if any).</a>
<a name="ln2882">	The caller must hold the team's lock.</a>
<a name="ln2883"> </a>
<a name="ln2884">	\param team The team whose dead children list to check.</a>
<a name="ln2885">	\param child The ID of the child for whose death entry to lock. Must be &gt; 0.</a>
<a name="ln2886">	\param _deleteEntry Return variable, indicating whether the caller needs to</a>
<a name="ln2887">		delete the returned entry.</a>
<a name="ln2888">	\return The death entry of the matching team, or \c NULL, if no death entry</a>
<a name="ln2889">		for the team was found.</a>
<a name="ln2890">*/</a>
<a name="ln2891">job_control_entry*</a>
<a name="ln2892">team_get_death_entry(Team* team, thread_id child, bool* _deleteEntry)</a>
<a name="ln2893">{</a>
<a name="ln2894">	if (child &lt;= 0)</a>
<a name="ln2895">		return NULL;</a>
<a name="ln2896"> </a>
<a name="ln2897">	job_control_entry* entry = get_job_control_entry(team-&gt;dead_children,</a>
<a name="ln2898">		child);</a>
<a name="ln2899">	if (entry) {</a>
<a name="ln2900">		// remove the entry only, if the caller is the parent of the found team</a>
<a name="ln2901">		if (team_get_current_team_id() == entry-&gt;thread) {</a>
<a name="ln2902">			team-&gt;dead_children.entries.Remove(entry);</a>
<a name="ln2903">			team-&gt;dead_children.count--;</a>
<a name="ln2904">			*_deleteEntry = true;</a>
<a name="ln2905">		} else {</a>
<a name="ln2906">			*_deleteEntry = false;</a>
<a name="ln2907">		}</a>
<a name="ln2908">	}</a>
<a name="ln2909"> </a>
<a name="ln2910">	return entry;</a>
<a name="ln2911">}</a>
<a name="ln2912"> </a>
<a name="ln2913"> </a>
<a name="ln2914">/*! Quick check to see if we have a valid team ID. */</a>
<a name="ln2915">bool</a>
<a name="ln2916">team_is_valid(team_id id)</a>
<a name="ln2917">{</a>
<a name="ln2918">	if (id &lt;= 0)</a>
<a name="ln2919">		return false;</a>
<a name="ln2920"> </a>
<a name="ln2921">	InterruptsReadSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln2922"> </a>
<a name="ln2923">	return team_get_team_struct_locked(id) != NULL;</a>
<a name="ln2924">}</a>
<a name="ln2925"> </a>
<a name="ln2926"> </a>
<a name="ln2927">Team*</a>
<a name="ln2928">team_get_team_struct_locked(team_id id)</a>
<a name="ln2929">{</a>
<a name="ln2930">	return sTeamHash.Lookup(id);</a>
<a name="ln2931">}</a>
<a name="ln2932"> </a>
<a name="ln2933"> </a>
<a name="ln2934">void</a>
<a name="ln2935">team_set_controlling_tty(int32 ttyIndex)</a>
<a name="ln2936">{</a>
<a name="ln2937">	// lock the team, so its session won't change while we're playing with it</a>
<a name="ln2938">	Team* team = thread_get_current_thread()-&gt;team;</a>
<a name="ln2939">	TeamLocker teamLocker(team);</a>
<a name="ln2940"> </a>
<a name="ln2941">	// get and lock the session</a>
<a name="ln2942">	ProcessSession* session = team-&gt;group-&gt;Session();</a>
<a name="ln2943">	AutoLocker&lt;ProcessSession&gt; sessionLocker(session);</a>
<a name="ln2944"> </a>
<a name="ln2945">	// set the session's fields</a>
<a name="ln2946">	session-&gt;controlling_tty = ttyIndex;</a>
<a name="ln2947">	session-&gt;foreground_group = -1;</a>
<a name="ln2948">}</a>
<a name="ln2949"> </a>
<a name="ln2950"> </a>
<a name="ln2951">int32</a>
<a name="ln2952">team_get_controlling_tty()</a>
<a name="ln2953">{</a>
<a name="ln2954">	// lock the team, so its session won't change while we're playing with it</a>
<a name="ln2955">	Team* team = thread_get_current_thread()-&gt;team;</a>
<a name="ln2956">	TeamLocker teamLocker(team);</a>
<a name="ln2957"> </a>
<a name="ln2958">	// get and lock the session</a>
<a name="ln2959">	ProcessSession* session = team-&gt;group-&gt;Session();</a>
<a name="ln2960">	AutoLocker&lt;ProcessSession&gt; sessionLocker(session);</a>
<a name="ln2961"> </a>
<a name="ln2962">	// get the session's field</a>
<a name="ln2963">	return session-&gt;controlling_tty;</a>
<a name="ln2964">}</a>
<a name="ln2965"> </a>
<a name="ln2966"> </a>
<a name="ln2967">status_t</a>
<a name="ln2968">team_set_foreground_process_group(int32 ttyIndex, pid_t processGroupID)</a>
<a name="ln2969">{</a>
<a name="ln2970">	// lock the team, so its session won't change while we're playing with it</a>
<a name="ln2971">	Thread* thread = thread_get_current_thread();</a>
<a name="ln2972">	Team* team = thread-&gt;team;</a>
<a name="ln2973">	TeamLocker teamLocker(team);</a>
<a name="ln2974"> </a>
<a name="ln2975">	// get and lock the session</a>
<a name="ln2976">	ProcessSession* session = team-&gt;group-&gt;Session();</a>
<a name="ln2977">	AutoLocker&lt;ProcessSession&gt; sessionLocker(session);</a>
<a name="ln2978"> </a>
<a name="ln2979">	// check given TTY -- must be the controlling tty of the calling process</a>
<a name="ln2980">	if (session-&gt;controlling_tty != ttyIndex)</a>
<a name="ln2981">		return ENOTTY;</a>
<a name="ln2982"> </a>
<a name="ln2983">	// check given process group -- must belong to our session</a>
<a name="ln2984">	{</a>
<a name="ln2985">		InterruptsSpinLocker groupHashLocker(sGroupHashLock);</a>
<a name="ln2986">		ProcessGroup* group = sGroupHash.Lookup(processGroupID);</a>
<a name="ln2987">		if (group == NULL || group-&gt;Session() != session)</a>
<a name="ln2988">			return B_BAD_VALUE;</a>
<a name="ln2989">	}</a>
<a name="ln2990"> </a>
<a name="ln2991">	// If we are a background group, we can do that unharmed only when we</a>
<a name="ln2992">	// ignore or block SIGTTOU. Otherwise the group gets a SIGTTOU.</a>
<a name="ln2993">	if (session-&gt;foreground_group != -1</a>
<a name="ln2994">		&amp;&amp; session-&gt;foreground_group != team-&gt;group_id</a>
<a name="ln2995">		&amp;&amp; team-&gt;SignalActionFor(SIGTTOU).sa_handler != SIG_IGN</a>
<a name="ln2996">		&amp;&amp; (thread-&gt;sig_block_mask &amp; SIGNAL_TO_MASK(SIGTTOU)) == 0) {</a>
<a name="ln2997">		InterruptsSpinLocker signalLocker(team-&gt;signal_lock);</a>
<a name="ln2998"> </a>
<a name="ln2999">		if (!is_team_signal_blocked(team, SIGTTOU)) {</a>
<a name="ln3000">			pid_t groupID = team-&gt;group_id;</a>
<a name="ln3001"> </a>
<a name="ln3002">			signalLocker.Unlock();</a>
<a name="ln3003">			sessionLocker.Unlock();</a>
<a name="ln3004">			teamLocker.Unlock();</a>
<a name="ln3005"> </a>
<a name="ln3006">			Signal signal(SIGTTOU, SI_USER, B_OK, team-&gt;id);</a>
<a name="ln3007">			send_signal_to_process_group(groupID, signal, 0);</a>
<a name="ln3008">			return B_INTERRUPTED;</a>
<a name="ln3009">		}</a>
<a name="ln3010">	}</a>
<a name="ln3011"> </a>
<a name="ln3012">	session-&gt;foreground_group = processGroupID;</a>
<a name="ln3013"> </a>
<a name="ln3014">	return B_OK;</a>
<a name="ln3015">}</a>
<a name="ln3016"> </a>
<a name="ln3017"> </a>
<a name="ln3018">/*!	Removes the specified team from the global team hash, from its process</a>
<a name="ln3019">	group, and from its parent.</a>
<a name="ln3020">	It also moves all of its children to the kernel team.</a>
<a name="ln3021"> </a>
<a name="ln3022">	The caller must hold the following locks:</a>
<a name="ln3023">	- \a team's process group's lock,</a>
<a name="ln3024">	- the kernel team's lock,</a>
<a name="ln3025">	- \a team's parent team's lock (might be the kernel team), and</a>
<a name="ln3026">	- \a team's lock.</a>
<a name="ln3027">*/</a>
<a name="ln3028">void</a>
<a name="ln3029">team_remove_team(Team* team, pid_t&amp; _signalGroup)</a>
<a name="ln3030">{</a>
<a name="ln3031">	Team* parent = team-&gt;parent;</a>
<a name="ln3032"> </a>
<a name="ln3033">	// remember how long this team lasted</a>
<a name="ln3034">	parent-&gt;dead_children.kernel_time += team-&gt;dead_threads_kernel_time</a>
<a name="ln3035">		+ team-&gt;dead_children.kernel_time;</a>
<a name="ln3036">	parent-&gt;dead_children.user_time += team-&gt;dead_threads_user_time</a>
<a name="ln3037">		+ team-&gt;dead_children.user_time;</a>
<a name="ln3038"> </a>
<a name="ln3039">	// remove the team from the hash table</a>
<a name="ln3040">	InterruptsWriteSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln3041">	sTeamHash.Remove(team);</a>
<a name="ln3042">	sUsedTeams--;</a>
<a name="ln3043">	teamsLocker.Unlock();</a>
<a name="ln3044"> </a>
<a name="ln3045">	// The team can no longer be accessed by ID. Navigation to it is still</a>
<a name="ln3046">	// possible from its process group and its parent and children, but that</a>
<a name="ln3047">	// will be rectified shortly.</a>
<a name="ln3048">	team-&gt;state = TEAM_STATE_DEATH;</a>
<a name="ln3049"> </a>
<a name="ln3050">	// If we're a controlling process (i.e. a session leader with controlling</a>
<a name="ln3051">	// terminal), there's a bit of signalling we have to do. We can't do any of</a>
<a name="ln3052">	// the signaling here due to the bunch of locks we're holding, but we need</a>
<a name="ln3053">	// to determine, whom to signal.</a>
<a name="ln3054">	_signalGroup = -1;</a>
<a name="ln3055">	bool isSessionLeader = false;</a>
<a name="ln3056">	if (team-&gt;session_id == team-&gt;id</a>
<a name="ln3057">		&amp;&amp; team-&gt;group-&gt;Session()-&gt;controlling_tty &gt;= 0) {</a>
<a name="ln3058">		isSessionLeader = true;</a>
<a name="ln3059"> </a>
<a name="ln3060">		ProcessSession* session = team-&gt;group-&gt;Session();</a>
<a name="ln3061"> </a>
<a name="ln3062">		AutoLocker&lt;ProcessSession&gt; sessionLocker(session);</a>
<a name="ln3063"> </a>
<a name="ln3064">		session-&gt;controlling_tty = -1;</a>
<a name="ln3065">		_signalGroup = session-&gt;foreground_group;</a>
<a name="ln3066">	}</a>
<a name="ln3067"> </a>
<a name="ln3068">	// remove us from our process group</a>
<a name="ln3069">	remove_team_from_group(team);</a>
<a name="ln3070"> </a>
<a name="ln3071">	// move the team's children to the kernel team</a>
<a name="ln3072">	while (Team* child = team-&gt;children) {</a>
<a name="ln3073">		// remove the child from the current team and add it to the kernel team</a>
<a name="ln3074">		TeamLocker childLocker(child);</a>
<a name="ln3075"> </a>
<a name="ln3076">		remove_team_from_parent(team, child);</a>
<a name="ln3077">		insert_team_into_parent(sKernelTeam, child);</a>
<a name="ln3078"> </a>
<a name="ln3079">		// move job control entries too</a>
<a name="ln3080">		sKernelTeam-&gt;stopped_children.entries.MoveFrom(</a>
<a name="ln3081">			&amp;team-&gt;stopped_children.entries);</a>
<a name="ln3082">		sKernelTeam-&gt;continued_children.entries.MoveFrom(</a>
<a name="ln3083">			&amp;team-&gt;continued_children.entries);</a>
<a name="ln3084"> </a>
<a name="ln3085">		// If the team was a session leader with controlling terminal,</a>
<a name="ln3086">		// we need to send SIGHUP + SIGCONT to all newly-orphaned process</a>
<a name="ln3087">		// groups with stopped processes. Due to locking complications we can't</a>
<a name="ln3088">		// do that here, so we only check whether we were a reason for the</a>
<a name="ln3089">		// child's process group not being an orphan and, if so, schedule a</a>
<a name="ln3090">		// later check (cf. orphaned_process_group_check()).</a>
<a name="ln3091">		if (isSessionLeader) {</a>
<a name="ln3092">			ProcessGroup* childGroup = child-&gt;group;</a>
<a name="ln3093">			if (childGroup-&gt;Session()-&gt;id == team-&gt;session_id</a>
<a name="ln3094">				&amp;&amp; childGroup-&gt;id != team-&gt;group_id) {</a>
<a name="ln3095">				childGroup-&gt;ScheduleOrphanedCheck();</a>
<a name="ln3096">			}</a>
<a name="ln3097">		}</a>
<a name="ln3098"> </a>
<a name="ln3099">		// Note, we don't move the dead children entries. Those will be deleted</a>
<a name="ln3100">		// when the team structure is deleted.</a>
<a name="ln3101">	}</a>
<a name="ln3102"> </a>
<a name="ln3103">	// remove us from our parent</a>
<a name="ln3104">	remove_team_from_parent(parent, team);</a>
<a name="ln3105">}</a>
<a name="ln3106"> </a>
<a name="ln3107"> </a>
<a name="ln3108">/*!	Kills all threads but the main thread of the team and shuts down user</a>
<a name="ln3109">	debugging for it.</a>
<a name="ln3110">	To be called on exit of the team's main thread. No locks must be held.</a>
<a name="ln3111"> </a>
<a name="ln3112">	\param team The team in question.</a>
<a name="ln3113">	\return The port of the debugger for the team, -1 if none. To be passed to</a>
<a name="ln3114">		team_delete_team().</a>
<a name="ln3115">*/</a>
<a name="ln3116">port_id</a>
<a name="ln3117">team_shutdown_team(Team* team)</a>
<a name="ln3118">{</a>
<a name="ln3119">	ASSERT(thread_get_current_thread() == team-&gt;main_thread);</a>
<a name="ln3120"> </a>
<a name="ln3121">	TeamLocker teamLocker(team);</a>
<a name="ln3122"> </a>
<a name="ln3123">	// Make sure debugging changes won't happen anymore.</a>
<a name="ln3124">	port_id debuggerPort = -1;</a>
<a name="ln3125">	while (true) {</a>
<a name="ln3126">		// If a debugger change is in progress for the team, we'll have to</a>
<a name="ln3127">		// wait until it is done.</a>
<a name="ln3128">		ConditionVariableEntry waitForDebuggerEntry;</a>
<a name="ln3129">		bool waitForDebugger = false;</a>
<a name="ln3130"> </a>
<a name="ln3131">		InterruptsSpinLocker debugInfoLocker(team-&gt;debug_info.lock);</a>
<a name="ln3132"> </a>
<a name="ln3133">		if (team-&gt;debug_info.debugger_changed_condition != NULL) {</a>
<a name="ln3134">			team-&gt;debug_info.debugger_changed_condition-&gt;Add(</a>
<a name="ln3135">				&amp;waitForDebuggerEntry);</a>
<a name="ln3136">			waitForDebugger = true;</a>
<a name="ln3137">		} else if (team-&gt;debug_info.flags &amp; B_TEAM_DEBUG_DEBUGGER_INSTALLED) {</a>
<a name="ln3138">			// The team is being debugged. That will stop with the termination</a>
<a name="ln3139">			// of the nub thread. Since we set the team state to death, no one</a>
<a name="ln3140">			// can install a debugger anymore. We fetch the debugger's port to</a>
<a name="ln3141">			// send it a message at the bitter end.</a>
<a name="ln3142">			debuggerPort = team-&gt;debug_info.debugger_port;</a>
<a name="ln3143">		}</a>
<a name="ln3144"> </a>
<a name="ln3145">		debugInfoLocker.Unlock();</a>
<a name="ln3146"> </a>
<a name="ln3147">		if (!waitForDebugger)</a>
<a name="ln3148">			break;</a>
<a name="ln3149"> </a>
<a name="ln3150">		// wait for the debugger change to be finished</a>
<a name="ln3151">		teamLocker.Unlock();</a>
<a name="ln3152"> </a>
<a name="ln3153">		waitForDebuggerEntry.Wait();</a>
<a name="ln3154"> </a>
<a name="ln3155">		teamLocker.Lock();</a>
<a name="ln3156">	}</a>
<a name="ln3157"> </a>
<a name="ln3158">	// Mark the team as shutting down. That will prevent new threads from being</a>
<a name="ln3159">	// created and debugger changes from taking place.</a>
<a name="ln3160">	team-&gt;state = TEAM_STATE_SHUTDOWN;</a>
<a name="ln3161"> </a>
<a name="ln3162">	// delete all timers</a>
<a name="ln3163">	team-&gt;DeleteUserTimers(false);</a>
<a name="ln3164"> </a>
<a name="ln3165">	// deactivate CPU time user timers for the team</a>
<a name="ln3166">	InterruptsSpinLocker timeLocker(team-&gt;time_lock);</a>
<a name="ln3167"> </a>
<a name="ln3168">	if (team-&gt;HasActiveCPUTimeUserTimers())</a>
<a name="ln3169">		team-&gt;DeactivateCPUTimeUserTimers();</a>
<a name="ln3170"> </a>
<a name="ln3171">	timeLocker.Unlock();</a>
<a name="ln3172"> </a>
<a name="ln3173">	// kill all threads but the main thread</a>
<a name="ln3174">	team_death_entry deathEntry;</a>
<a name="ln3175">	deathEntry.condition.Init(team, &quot;team death&quot;);</a>
<a name="ln3176"> </a>
<a name="ln3177">	while (true) {</a>
<a name="ln3178">		team-&gt;death_entry = &amp;deathEntry;</a>
<a name="ln3179">		deathEntry.remaining_threads = 0;</a>
<a name="ln3180"> </a>
<a name="ln3181">		Thread* thread = team-&gt;thread_list;</a>
<a name="ln3182">		while (thread != NULL) {</a>
<a name="ln3183">			if (thread != team-&gt;main_thread) {</a>
<a name="ln3184">				Signal signal(SIGKILLTHR, SI_USER, B_OK, team-&gt;id);</a>
<a name="ln3185">				send_signal_to_thread(thread, signal, B_DO_NOT_RESCHEDULE);</a>
<a name="ln3186">				deathEntry.remaining_threads++;</a>
<a name="ln3187">			}</a>
<a name="ln3188"> </a>
<a name="ln3189">			thread = thread-&gt;team_next;</a>
<a name="ln3190">		}</a>
<a name="ln3191"> </a>
<a name="ln3192">		if (deathEntry.remaining_threads == 0)</a>
<a name="ln3193">			break;</a>
<a name="ln3194"> </a>
<a name="ln3195">		// there are threads to wait for</a>
<a name="ln3196">		ConditionVariableEntry entry;</a>
<a name="ln3197">		deathEntry.condition.Add(&amp;entry);</a>
<a name="ln3198"> </a>
<a name="ln3199">		teamLocker.Unlock();</a>
<a name="ln3200"> </a>
<a name="ln3201">		entry.Wait();</a>
<a name="ln3202"> </a>
<a name="ln3203">		teamLocker.Lock();</a>
<a name="ln3204">	}</a>
<a name="ln3205"> </a>
<a name="ln3206">	team-&gt;death_entry = NULL;</a>
<a name="ln3207"> </a>
<a name="ln3208">	return debuggerPort;</a>
<a name="ln3209">}</a>
<a name="ln3210"> </a>
<a name="ln3211"> </a>
<a name="ln3212">/*!	Called on team exit to notify threads waiting on the team and free most</a>
<a name="ln3213">	resources associated with it.</a>
<a name="ln3214">	The caller shouldn't hold any locks.</a>
<a name="ln3215">*/</a>
<a name="ln3216">void</a>
<a name="ln3217">team_delete_team(Team* team, port_id debuggerPort)</a>
<a name="ln3218">{</a>
<a name="ln3219">	// Not quite in our job description, but work that has been left by</a>
<a name="ln3220">	// team_remove_team() and that can be done now that we're not holding any</a>
<a name="ln3221">	// locks.</a>
<a name="ln3222">	orphaned_process_group_check();</a>
<a name="ln3223"> </a>
<a name="ln3224">	team_id teamID = team-&gt;id;</a>
<a name="ln3225"> </a>
<a name="ln3226">	ASSERT(team-&gt;num_threads == 0);</a>
<a name="ln3227"> </a>
<a name="ln3228">	// If someone is waiting for this team to be loaded, but it dies</a>
<a name="ln3229">	// unexpectedly before being done, we need to notify the waiting</a>
<a name="ln3230">	// thread now.</a>
<a name="ln3231"> </a>
<a name="ln3232">	TeamLocker teamLocker(team);</a>
<a name="ln3233"> </a>
<a name="ln3234">	if (team-&gt;loading_info) {</a>
<a name="ln3235">		// there's indeed someone waiting</a>
<a name="ln3236">		struct team_loading_info* loadingInfo = team-&gt;loading_info;</a>
<a name="ln3237">		team-&gt;loading_info = NULL;</a>
<a name="ln3238"> </a>
<a name="ln3239">		loadingInfo-&gt;result = B_ERROR;</a>
<a name="ln3240"> </a>
<a name="ln3241">		// wake up the waiting thread</a>
<a name="ln3242">		loadingInfo-&gt;condition.NotifyAll();</a>
<a name="ln3243">	}</a>
<a name="ln3244"> </a>
<a name="ln3245">	// notify team watchers</a>
<a name="ln3246"> </a>
<a name="ln3247">	{</a>
<a name="ln3248">		// we're not reachable from anyone anymore at this point, so we</a>
<a name="ln3249">		// can safely access the list without any locking</a>
<a name="ln3250">		struct team_watcher* watcher;</a>
<a name="ln3251">		while ((watcher = (struct team_watcher*)list_remove_head_item(</a>
<a name="ln3252">				&amp;team-&gt;watcher_list)) != NULL) {</a>
<a name="ln3253">			watcher-&gt;hook(teamID, watcher-&gt;data);</a>
<a name="ln3254">			free(watcher);</a>
<a name="ln3255">		}</a>
<a name="ln3256">	}</a>
<a name="ln3257"> </a>
<a name="ln3258">	teamLocker.Unlock();</a>
<a name="ln3259"> </a>
<a name="ln3260">	sNotificationService.Notify(TEAM_REMOVED, team);</a>
<a name="ln3261"> </a>
<a name="ln3262">	// free team resources</a>
<a name="ln3263"> </a>
<a name="ln3264">	delete_realtime_sem_context(team-&gt;realtime_sem_context);</a>
<a name="ln3265">	xsi_sem_undo(team);</a>
<a name="ln3266">	remove_images(team);</a>
<a name="ln3267">	team-&gt;address_space-&gt;RemoveAndPut();</a>
<a name="ln3268"> </a>
<a name="ln3269">	team-&gt;ReleaseReference();</a>
<a name="ln3270"> </a>
<a name="ln3271">	// notify the debugger, that the team is gone</a>
<a name="ln3272">	user_debug_team_deleted(teamID, debuggerPort);</a>
<a name="ln3273">}</a>
<a name="ln3274"> </a>
<a name="ln3275"> </a>
<a name="ln3276">Team*</a>
<a name="ln3277">team_get_kernel_team(void)</a>
<a name="ln3278">{</a>
<a name="ln3279">	return sKernelTeam;</a>
<a name="ln3280">}</a>
<a name="ln3281"> </a>
<a name="ln3282"> </a>
<a name="ln3283">team_id</a>
<a name="ln3284">team_get_kernel_team_id(void)</a>
<a name="ln3285">{</a>
<a name="ln3286">	if (!sKernelTeam)</a>
<a name="ln3287">		return 0;</a>
<a name="ln3288"> </a>
<a name="ln3289">	return sKernelTeam-&gt;id;</a>
<a name="ln3290">}</a>
<a name="ln3291"> </a>
<a name="ln3292"> </a>
<a name="ln3293">team_id</a>
<a name="ln3294">team_get_current_team_id(void)</a>
<a name="ln3295">{</a>
<a name="ln3296">	return thread_get_current_thread()-&gt;team-&gt;id;</a>
<a name="ln3297">}</a>
<a name="ln3298"> </a>
<a name="ln3299"> </a>
<a name="ln3300">status_t</a>
<a name="ln3301">team_get_address_space(team_id id, VMAddressSpace** _addressSpace)</a>
<a name="ln3302">{</a>
<a name="ln3303">	if (id == sKernelTeam-&gt;id) {</a>
<a name="ln3304">		// we're the kernel team, so we don't have to go through all</a>
<a name="ln3305">		// the hassle (locking and hash lookup)</a>
<a name="ln3306">		*_addressSpace = VMAddressSpace::GetKernel();</a>
<a name="ln3307">		return B_OK;</a>
<a name="ln3308">	}</a>
<a name="ln3309"> </a>
<a name="ln3310">	InterruptsReadSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln3311"> </a>
<a name="ln3312">	Team* team = team_get_team_struct_locked(id);</a>
<a name="ln3313">	if (team == NULL)</a>
<a name="ln3314">		return B_BAD_VALUE;</a>
<a name="ln3315"> </a>
<a name="ln3316">	team-&gt;address_space-&gt;Get();</a>
<a name="ln3317">	*_addressSpace = team-&gt;address_space;</a>
<a name="ln3318">	return B_OK;</a>
<a name="ln3319">}</a>
<a name="ln3320"> </a>
<a name="ln3321"> </a>
<a name="ln3322">/*!	Sets the team's job control state.</a>
<a name="ln3323">	The caller must hold the parent team's lock. Interrupts are allowed to be</a>
<a name="ln3324">	enabled or disabled.</a>
<a name="ln3325">	\a team The team whose job control state shall be set.</a>
<a name="ln3326">	\a newState The new state to be set.</a>
<a name="ln3327">	\a signal The signal the new state was caused by. Can \c NULL, if none. Then</a>
<a name="ln3328">		the caller is responsible for filling in the following fields of the</a>
<a name="ln3329">		entry before releasing the parent team's lock, unless the new state is</a>
<a name="ln3330">		\c JOB_CONTROL_STATE_NONE:</a>
<a name="ln3331">		- \c signal: The number of the signal causing the state change.</a>
<a name="ln3332">		- \c signaling_user: The real UID of the user sending the signal.</a>
<a name="ln3333">*/</a>
<a name="ln3334">void</a>
<a name="ln3335">team_set_job_control_state(Team* team, job_control_state newState,</a>
<a name="ln3336">	Signal* signal)</a>
<a name="ln3337">{</a>
<a name="ln3338">	if (team == NULL || team-&gt;job_control_entry == NULL)</a>
<a name="ln3339">		return;</a>
<a name="ln3340"> </a>
<a name="ln3341">	// don't touch anything, if the state stays the same or the team is already</a>
<a name="ln3342">	// dead</a>
<a name="ln3343">	job_control_entry* entry = team-&gt;job_control_entry;</a>
<a name="ln3344">	if (entry-&gt;state == newState || entry-&gt;state == JOB_CONTROL_STATE_DEAD)</a>
<a name="ln3345">		return;</a>
<a name="ln3346"> </a>
<a name="ln3347">	T(SetJobControlState(team-&gt;id, newState, signal));</a>
<a name="ln3348"> </a>
<a name="ln3349">	// remove from the old list</a>
<a name="ln3350">	switch (entry-&gt;state) {</a>
<a name="ln3351">		case JOB_CONTROL_STATE_NONE:</a>
<a name="ln3352">			// entry is in no list ATM</a>
<a name="ln3353">			break;</a>
<a name="ln3354">		case JOB_CONTROL_STATE_DEAD:</a>
<a name="ln3355">			// can't get here</a>
<a name="ln3356">			break;</a>
<a name="ln3357">		case JOB_CONTROL_STATE_STOPPED:</a>
<a name="ln3358">			team-&gt;parent-&gt;stopped_children.entries.Remove(entry);</a>
<a name="ln3359">			break;</a>
<a name="ln3360">		case JOB_CONTROL_STATE_CONTINUED:</a>
<a name="ln3361">			team-&gt;parent-&gt;continued_children.entries.Remove(entry);</a>
<a name="ln3362">			break;</a>
<a name="ln3363">	}</a>
<a name="ln3364"> </a>
<a name="ln3365">	entry-&gt;state = newState;</a>
<a name="ln3366"> </a>
<a name="ln3367">	if (signal != NULL) {</a>
<a name="ln3368">		entry-&gt;signal = signal-&gt;Number();</a>
<a name="ln3369">		entry-&gt;signaling_user = signal-&gt;SendingUser();</a>
<a name="ln3370">	}</a>
<a name="ln3371"> </a>
<a name="ln3372">	// add to new list</a>
<a name="ln3373">	team_job_control_children* childList = NULL;</a>
<a name="ln3374">	switch (entry-&gt;state) {</a>
<a name="ln3375">		case JOB_CONTROL_STATE_NONE:</a>
<a name="ln3376">			// entry doesn't get into any list</a>
<a name="ln3377">			break;</a>
<a name="ln3378">		case JOB_CONTROL_STATE_DEAD:</a>
<a name="ln3379">			childList = &amp;team-&gt;parent-&gt;dead_children;</a>
<a name="ln3380">			team-&gt;parent-&gt;dead_children.count++;</a>
<a name="ln3381">			break;</a>
<a name="ln3382">		case JOB_CONTROL_STATE_STOPPED:</a>
<a name="ln3383">			childList = &amp;team-&gt;parent-&gt;stopped_children;</a>
<a name="ln3384">			break;</a>
<a name="ln3385">		case JOB_CONTROL_STATE_CONTINUED:</a>
<a name="ln3386">			childList = &amp;team-&gt;parent-&gt;continued_children;</a>
<a name="ln3387">			break;</a>
<a name="ln3388">	}</a>
<a name="ln3389"> </a>
<a name="ln3390">	if (childList != NULL) {</a>
<a name="ln3391">		childList-&gt;entries.Add(entry);</a>
<a name="ln3392">		team-&gt;parent-&gt;dead_children.condition_variable.NotifyAll();</a>
<a name="ln3393">	}</a>
<a name="ln3394">}</a>
<a name="ln3395"> </a>
<a name="ln3396"> </a>
<a name="ln3397">/*!	Inits the given team's exit information, if not yet initialized, to some</a>
<a name="ln3398">	generic &quot;killed&quot; status.</a>
<a name="ln3399">	The caller must not hold the team's lock. Interrupts must be enabled.</a>
<a name="ln3400"> </a>
<a name="ln3401">	\param team The team whose exit info shall be initialized.</a>
<a name="ln3402">*/</a>
<a name="ln3403">void</a>
<a name="ln3404">team_init_exit_info_on_error(Team* team)</a>
<a name="ln3405">{</a>
<a name="ln3406">	TeamLocker teamLocker(team);</a>
<a name="ln3407"> </a>
<a name="ln3408">	if (!team-&gt;exit.initialized) {</a>
<a name="ln3409">		team-&gt;exit.reason = CLD_KILLED;</a>
<a name="ln3410">		team-&gt;exit.signal = SIGKILL;</a>
<a name="ln3411">		team-&gt;exit.signaling_user = geteuid();</a>
<a name="ln3412">		team-&gt;exit.status = 0;</a>
<a name="ln3413">		team-&gt;exit.initialized = true;</a>
<a name="ln3414">	}</a>
<a name="ln3415">}</a>
<a name="ln3416"> </a>
<a name="ln3417"> </a>
<a name="ln3418">/*! Adds a hook to the team that is called as soon as this team goes away.</a>
<a name="ln3419">	This call might get public in the future.</a>
<a name="ln3420">*/</a>
<a name="ln3421">status_t</a>
<a name="ln3422">start_watching_team(team_id teamID, void (*hook)(team_id, void*), void* data)</a>
<a name="ln3423">{</a>
<a name="ln3424">	if (hook == NULL || teamID &lt; B_OK)</a>
<a name="ln3425">		return B_BAD_VALUE;</a>
<a name="ln3426"> </a>
<a name="ln3427">	// create the watcher object</a>
<a name="ln3428">	team_watcher* watcher = (team_watcher*)malloc(sizeof(team_watcher));</a>
<a name="ln3429">	if (watcher == NULL)</a>
<a name="ln3430">		return B_NO_MEMORY;</a>
<a name="ln3431"> </a>
<a name="ln3432">	watcher-&gt;hook = hook;</a>
<a name="ln3433">	watcher-&gt;data = data;</a>
<a name="ln3434"> </a>
<a name="ln3435">	// add watcher, if the team isn't already dying</a>
<a name="ln3436">	// get the team</a>
<a name="ln3437">	Team* team = Team::GetAndLock(teamID);</a>
<a name="ln3438">	if (team == NULL) {</a>
<a name="ln3439">		free(watcher);</a>
<a name="ln3440">		return B_BAD_TEAM_ID;</a>
<a name="ln3441">	}</a>
<a name="ln3442"> </a>
<a name="ln3443">	list_add_item(&amp;team-&gt;watcher_list, watcher);</a>
<a name="ln3444"> </a>
<a name="ln3445">	team-&gt;UnlockAndReleaseReference();</a>
<a name="ln3446"> </a>
<a name="ln3447">	return B_OK;</a>
<a name="ln3448">}</a>
<a name="ln3449"> </a>
<a name="ln3450"> </a>
<a name="ln3451">status_t</a>
<a name="ln3452">stop_watching_team(team_id teamID, void (*hook)(team_id, void*), void* data)</a>
<a name="ln3453">{</a>
<a name="ln3454">	if (hook == NULL || teamID &lt; 0)</a>
<a name="ln3455">		return B_BAD_VALUE;</a>
<a name="ln3456"> </a>
<a name="ln3457">	// get team and remove watcher (if present)</a>
<a name="ln3458">	Team* team = Team::GetAndLock(teamID);</a>
<a name="ln3459">	if (team == NULL)</a>
<a name="ln3460">		return B_BAD_TEAM_ID;</a>
<a name="ln3461"> </a>
<a name="ln3462">	// search for watcher</a>
<a name="ln3463">	team_watcher* watcher = NULL;</a>
<a name="ln3464">	while ((watcher = (team_watcher*)list_get_next_item(</a>
<a name="ln3465">			&amp;team-&gt;watcher_list, watcher)) != NULL) {</a>
<a name="ln3466">		if (watcher-&gt;hook == hook &amp;&amp; watcher-&gt;data == data) {</a>
<a name="ln3467">			// got it!</a>
<a name="ln3468">			list_remove_item(&amp;team-&gt;watcher_list, watcher);</a>
<a name="ln3469">			break;</a>
<a name="ln3470">		}</a>
<a name="ln3471">	}</a>
<a name="ln3472"> </a>
<a name="ln3473">	team-&gt;UnlockAndReleaseReference();</a>
<a name="ln3474"> </a>
<a name="ln3475">	if (watcher == NULL)</a>
<a name="ln3476">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln3477"> </a>
<a name="ln3478">	free(watcher);</a>
<a name="ln3479">	return B_OK;</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482"> </a>
<a name="ln3483">/*!	Allocates a user_thread structure from the team.</a>
<a name="ln3484">	The team lock must be held, unless the function is called for the team's</a>
<a name="ln3485">	main thread. Interrupts must be enabled.</a>
<a name="ln3486">*/</a>
<a name="ln3487">struct user_thread*</a>
<a name="ln3488">team_allocate_user_thread(Team* team)</a>
<a name="ln3489">{</a>
<a name="ln3490">	if (team-&gt;user_data == 0)</a>
<a name="ln3491">		return NULL;</a>
<a name="ln3492"> </a>
<a name="ln3493">	// take an entry from the free list, if any</a>
<a name="ln3494">	if (struct free_user_thread* entry = team-&gt;free_user_threads) {</a>
<a name="ln3495">		user_thread* thread = entry-&gt;thread;</a>
<a name="ln3496">		team-&gt;free_user_threads = entry-&gt;next;</a>
<a name="ln3497">		free(entry);</a>
<a name="ln3498">		return thread;</a>
<a name="ln3499">	}</a>
<a name="ln3500"> </a>
<a name="ln3501">	while (true) {</a>
<a name="ln3502">		// enough space left?</a>
<a name="ln3503">		size_t needed = ROUNDUP(sizeof(user_thread), CACHE_LINE_SIZE);</a>
<a name="ln3504">		if (team-&gt;user_data_size - team-&gt;used_user_data &lt; needed) {</a>
<a name="ln3505">			// try to resize the area</a>
<a name="ln3506">			if (resize_area(team-&gt;user_data_area,</a>
<a name="ln3507">					team-&gt;user_data_size + B_PAGE_SIZE) != B_OK) {</a>
<a name="ln3508">				return NULL;</a>
<a name="ln3509">			}</a>
<a name="ln3510"> </a>
<a name="ln3511">			// resized user area successfully -- try to allocate the user_thread</a>
<a name="ln3512">			// again</a>
<a name="ln3513">			team-&gt;user_data_size += B_PAGE_SIZE;</a>
<a name="ln3514">			continue;</a>
<a name="ln3515">		}</a>
<a name="ln3516"> </a>
<a name="ln3517">		// allocate the user_thread</a>
<a name="ln3518">		user_thread* thread</a>
<a name="ln3519">			= (user_thread*)(team-&gt;user_data + team-&gt;used_user_data);</a>
<a name="ln3520">		team-&gt;used_user_data += needed;</a>
<a name="ln3521"> </a>
<a name="ln3522">		return thread;</a>
<a name="ln3523">	}</a>
<a name="ln3524">}</a>
<a name="ln3525"> </a>
<a name="ln3526"> </a>
<a name="ln3527">/*!	Frees the given user_thread structure.</a>
<a name="ln3528">	The team's lock must not be held. Interrupts must be enabled.</a>
<a name="ln3529">	\param team The team the user thread was allocated from.</a>
<a name="ln3530">	\param userThread The user thread to free.</a>
<a name="ln3531">*/</a>
<a name="ln3532">void</a>
<a name="ln3533">team_free_user_thread(Team* team, struct user_thread* userThread)</a>
<a name="ln3534">{</a>
<a name="ln3535">	if (userThread == NULL)</a>
<a name="ln3536">		return;</a>
<a name="ln3537"> </a>
<a name="ln3538">	// create a free list entry</a>
<a name="ln3539">	free_user_thread* entry</a>
<a name="ln3540">		= (free_user_thread*)malloc(sizeof(free_user_thread));</a>
<a name="ln3541">	if (entry == NULL) {</a>
<a name="ln3542">		// we have to leak the user thread :-/</a>
<a name="ln3543">		return;</a>
<a name="ln3544">	}</a>
<a name="ln3545"> </a>
<a name="ln3546">	// add to free list</a>
<a name="ln3547">	TeamLocker teamLocker(team);</a>
<a name="ln3548"> </a>
<a name="ln3549">	entry-&gt;thread = userThread;</a>
<a name="ln3550">	entry-&gt;next = team-&gt;free_user_threads;</a>
<a name="ln3551">	team-&gt;free_user_threads = entry;</a>
<a name="ln3552">}</a>
<a name="ln3553"> </a>
<a name="ln3554"> </a>
<a name="ln3555">//	#pragma mark - Associated data interface</a>
<a name="ln3556"> </a>
<a name="ln3557"> </a>
<a name="ln3558">AssociatedData::AssociatedData()</a>
<a name="ln3559">	:</a>
<a name="ln3560">	fOwner(NULL)</a>
<a name="ln3561">{</a>
<a name="ln3562">}</a>
<a name="ln3563"> </a>
<a name="ln3564"> </a>
<a name="ln3565">AssociatedData::~AssociatedData()</a>
<a name="ln3566">{</a>
<a name="ln3567">}</a>
<a name="ln3568"> </a>
<a name="ln3569"> </a>
<a name="ln3570">void</a>
<a name="ln3571">AssociatedData::OwnerDeleted(AssociatedDataOwner* owner)</a>
<a name="ln3572">{</a>
<a name="ln3573">}</a>
<a name="ln3574"> </a>
<a name="ln3575"> </a>
<a name="ln3576">AssociatedDataOwner::AssociatedDataOwner()</a>
<a name="ln3577">{</a>
<a name="ln3578">	mutex_init(&amp;fLock, &quot;associated data owner&quot;);</a>
<a name="ln3579">}</a>
<a name="ln3580"> </a>
<a name="ln3581"> </a>
<a name="ln3582">AssociatedDataOwner::~AssociatedDataOwner()</a>
<a name="ln3583">{</a>
<a name="ln3584">	mutex_destroy(&amp;fLock);</a>
<a name="ln3585">}</a>
<a name="ln3586"> </a>
<a name="ln3587"> </a>
<a name="ln3588">bool</a>
<a name="ln3589">AssociatedDataOwner::AddData(AssociatedData* data)</a>
<a name="ln3590">{</a>
<a name="ln3591">	MutexLocker locker(fLock);</a>
<a name="ln3592"> </a>
<a name="ln3593">	if (data-&gt;Owner() != NULL)</a>
<a name="ln3594">		return false;</a>
<a name="ln3595"> </a>
<a name="ln3596">	data-&gt;AcquireReference();</a>
<a name="ln3597">	fList.Add(data);</a>
<a name="ln3598">	data-&gt;SetOwner(this);</a>
<a name="ln3599"> </a>
<a name="ln3600">	return true;</a>
<a name="ln3601">}</a>
<a name="ln3602"> </a>
<a name="ln3603"> </a>
<a name="ln3604">bool</a>
<a name="ln3605">AssociatedDataOwner::RemoveData(AssociatedData* data)</a>
<a name="ln3606">{</a>
<a name="ln3607">	MutexLocker locker(fLock);</a>
<a name="ln3608"> </a>
<a name="ln3609">	if (data-&gt;Owner() != this)</a>
<a name="ln3610">		return false;</a>
<a name="ln3611"> </a>
<a name="ln3612">	data-&gt;SetOwner(NULL);</a>
<a name="ln3613">	fList.Remove(data);</a>
<a name="ln3614"> </a>
<a name="ln3615">	locker.Unlock();</a>
<a name="ln3616"> </a>
<a name="ln3617">	data-&gt;ReleaseReference();</a>
<a name="ln3618"> </a>
<a name="ln3619">	return true;</a>
<a name="ln3620">}</a>
<a name="ln3621"> </a>
<a name="ln3622"> </a>
<a name="ln3623">void</a>
<a name="ln3624">AssociatedDataOwner::PrepareForDeletion()</a>
<a name="ln3625">{</a>
<a name="ln3626">	MutexLocker locker(fLock);</a>
<a name="ln3627"> </a>
<a name="ln3628">	// move all data to a temporary list and unset the owner</a>
<a name="ln3629">	DataList list;</a>
<a name="ln3630">	list.MoveFrom(&amp;fList);</a>
<a name="ln3631"> </a>
<a name="ln3632">	for (DataList::Iterator it = list.GetIterator();</a>
<a name="ln3633">		AssociatedData* data = it.Next();) {</a>
<a name="ln3634">		data-&gt;SetOwner(NULL);</a>
<a name="ln3635">	}</a>
<a name="ln3636"> </a>
<a name="ln3637">	locker.Unlock();</a>
<a name="ln3638"> </a>
<a name="ln3639">	// call the notification hooks and release our references</a>
<a name="ln3640">	while (AssociatedData* data = list.RemoveHead()) {</a>
<a name="ln3641">		data-&gt;OwnerDeleted(this);</a>
<a name="ln3642">		data-&gt;ReleaseReference();</a>
<a name="ln3643">	}</a>
<a name="ln3644">}</a>
<a name="ln3645"> </a>
<a name="ln3646"> </a>
<a name="ln3647">/*!	Associates data with the current team.</a>
<a name="ln3648">	When the team is deleted, the data object is notified.</a>
<a name="ln3649">	The team acquires a reference to the object.</a>
<a name="ln3650"> </a>
<a name="ln3651">	\param data The data object.</a>
<a name="ln3652">	\return \c true on success, \c false otherwise. Fails only when the supplied</a>
<a name="ln3653">		data object is already associated with another owner.</a>
<a name="ln3654">*/</a>
<a name="ln3655">bool</a>
<a name="ln3656">team_associate_data(AssociatedData* data)</a>
<a name="ln3657">{</a>
<a name="ln3658">	return thread_get_current_thread()-&gt;team-&gt;AddData(data);</a>
<a name="ln3659">}</a>
<a name="ln3660"> </a>
<a name="ln3661"> </a>
<a name="ln3662">/*!	Dissociates data from the current team.</a>
<a name="ln3663">	Balances an earlier call to team_associate_data().</a>
<a name="ln3664"> </a>
<a name="ln3665">	\param data The data object.</a>
<a name="ln3666">	\return \c true on success, \c false otherwise. Fails only when the data</a>
<a name="ln3667">		object is not associated with the current team.</a>
<a name="ln3668">*/</a>
<a name="ln3669">bool</a>
<a name="ln3670">team_dissociate_data(AssociatedData* data)</a>
<a name="ln3671">{</a>
<a name="ln3672">	return thread_get_current_thread()-&gt;team-&gt;RemoveData(data);</a>
<a name="ln3673">}</a>
<a name="ln3674"> </a>
<a name="ln3675"> </a>
<a name="ln3676">//	#pragma mark - Public kernel API</a>
<a name="ln3677"> </a>
<a name="ln3678"> </a>
<a name="ln3679">thread_id</a>
<a name="ln3680">load_image(int32 argCount, const char** args, const char** env)</a>
<a name="ln3681">{</a>
<a name="ln3682">	return load_image_etc(argCount, args, env, B_NORMAL_PRIORITY,</a>
<a name="ln3683">		B_CURRENT_TEAM, B_WAIT_TILL_LOADED);</a>
<a name="ln3684">}</a>
<a name="ln3685"> </a>
<a name="ln3686"> </a>
<a name="ln3687">thread_id</a>
<a name="ln3688">load_image_etc(int32 argCount, const char* const* args,</a>
<a name="ln3689">	const char* const* env, int32 priority, team_id parentID, uint32 flags)</a>
<a name="ln3690">{</a>
<a name="ln3691">	// we need to flatten the args and environment</a>
<a name="ln3692"> </a>
<a name="ln3693">	if (args == NULL)</a>
<a name="ln3694">		return B_BAD_VALUE;</a>
<a name="ln3695"> </a>
<a name="ln3696">	// determine total needed size</a>
<a name="ln3697">	int32 argSize = 0;</a>
<a name="ln3698">	for (int32 i = 0; i &lt; argCount; i++)</a>
<a name="ln3699">		argSize += strlen(args[i]) + 1;</a>
<a name="ln3700"> </a>
<a name="ln3701">	int32 envCount = 0;</a>
<a name="ln3702">	int32 envSize = 0;</a>
<a name="ln3703">	while (env != NULL &amp;&amp; env[envCount] != NULL)</a>
<a name="ln3704">		envSize += strlen(env[envCount++]) + 1;</a>
<a name="ln3705"> </a>
<a name="ln3706">	int32 size = (argCount + envCount + 2) * sizeof(char*) + argSize + envSize;</a>
<a name="ln3707">	if (size &gt; MAX_PROCESS_ARGS_SIZE)</a>
<a name="ln3708">		return B_TOO_MANY_ARGS;</a>
<a name="ln3709"> </a>
<a name="ln3710">	// allocate space</a>
<a name="ln3711">	char** flatArgs = (char**)malloc(size);</a>
<a name="ln3712">	if (flatArgs == NULL)</a>
<a name="ln3713">		return B_NO_MEMORY;</a>
<a name="ln3714"> </a>
<a name="ln3715">	char** slot = flatArgs;</a>
<a name="ln3716">	char* stringSpace = (char*)(flatArgs + argCount + envCount + 2);</a>
<a name="ln3717"> </a>
<a name="ln3718">	// copy arguments and environment</a>
<a name="ln3719">	for (int32 i = 0; i &lt; argCount; i++) {</a>
<a name="ln3720">		int32 argSize = strlen(args[i]) + 1;</a>
<a name="ln3721">		memcpy(stringSpace, args[i], argSize);</a>
<a name="ln3722">		*slot++ = stringSpace;</a>
<a name="ln3723">		stringSpace += argSize;</a>
<a name="ln3724">	}</a>
<a name="ln3725"> </a>
<a name="ln3726">	*slot++ = NULL;</a>
<a name="ln3727"> </a>
<a name="ln3728">	for (int32 i = 0; i &lt; envCount; i++) {</a>
<a name="ln3729">		int32 envSize = strlen(env[i]) + 1;</a>
<a name="ln3730">		memcpy(stringSpace, env[i], envSize);</a>
<a name="ln3731">		*slot++ = stringSpace;</a>
<a name="ln3732">		stringSpace += envSize;</a>
<a name="ln3733">	}</a>
<a name="ln3734"> </a>
<a name="ln3735">	*slot++ = NULL;</a>
<a name="ln3736"> </a>
<a name="ln3737">	thread_id thread = load_image_internal(flatArgs, size, argCount, envCount,</a>
<a name="ln3738">		B_NORMAL_PRIORITY, parentID, B_WAIT_TILL_LOADED, -1, 0);</a>
<a name="ln3739"> </a>
<a name="ln3740">	free(flatArgs);</a>
<a name="ln3741">		// load_image_internal() unset our variable if it took over ownership</a>
<a name="ln3742"> </a>
<a name="ln3743">	return thread;</a>
<a name="ln3744">}</a>
<a name="ln3745"> </a>
<a name="ln3746"> </a>
<a name="ln3747">status_t</a>
<a name="ln3748">wait_for_team(team_id id, status_t* _returnCode)</a>
<a name="ln3749">{</a>
<a name="ln3750">	// check whether the team exists</a>
<a name="ln3751">	InterruptsReadSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln3752"> </a>
<a name="ln3753">	Team* team = team_get_team_struct_locked(id);</a>
<a name="ln3754">	if (team == NULL)</a>
<a name="ln3755">		return B_BAD_TEAM_ID;</a>
<a name="ln3756"> </a>
<a name="ln3757">	id = team-&gt;id;</a>
<a name="ln3758"> </a>
<a name="ln3759">	teamsLocker.Unlock();</a>
<a name="ln3760"> </a>
<a name="ln3761">	// wait for the main thread (it has the same ID as the team)</a>
<a name="ln3762">	return wait_for_thread(id, _returnCode);</a>
<a name="ln3763">}</a>
<a name="ln3764"> </a>
<a name="ln3765"> </a>
<a name="ln3766">status_t</a>
<a name="ln3767">kill_team(team_id id)</a>
<a name="ln3768">{</a>
<a name="ln3769">	InterruptsReadSpinLocker teamsLocker(sTeamHashLock);</a>
<a name="ln3770"> </a>
<a name="ln3771">	Team* team = team_get_team_struct_locked(id);</a>
<a name="ln3772">	if (team == NULL)</a>
<a name="ln3773">		return B_BAD_TEAM_ID;</a>
<a name="ln3774"> </a>
<a name="ln3775">	id = team-&gt;id;</a>
<a name="ln3776"> </a>
<a name="ln3777">	teamsLocker.Unlock();</a>
<a name="ln3778"> </a>
<a name="ln3779">	if (team == sKernelTeam)</a>
<a name="ln3780">		return B_NOT_ALLOWED;</a>
<a name="ln3781"> </a>
<a name="ln3782">	// Just kill the team's main thread (it has same ID as the team). The</a>
<a name="ln3783">	// cleanup code there will take care of the team.</a>
<a name="ln3784">	return kill_thread(id);</a>
<a name="ln3785">}</a>
<a name="ln3786"> </a>
<a name="ln3787"> </a>
<a name="ln3788">status_t</a>
<a name="ln3789">_get_team_info(team_id id, team_info* info, size_t size)</a>
<a name="ln3790">{</a>
<a name="ln3791">	// get the team</a>
<a name="ln3792">	Team* team = Team::Get(id);</a>
<a name="ln3793">	if (team == NULL)</a>
<a name="ln3794">		return B_BAD_TEAM_ID;</a>
<a name="ln3795">	BReference&lt;Team&gt; teamReference(team, true);</a>
<a name="ln3796"> </a>
<a name="ln3797">	// fill in the info</a>
<a name="ln3798">	return fill_team_info(team, info, size);</a>
<a name="ln3799">}</a>
<a name="ln3800"> </a>
<a name="ln3801"> </a>
<a name="ln3802">status_t</a>
<a name="ln3803">_get_next_team_info(int32* cookie, team_info* info, size_t size)</a>
<a name="ln3804">{</a>
<a name="ln3805">	int32 slot = *cookie;</a>
<a name="ln3806">	if (slot &lt; 1)</a>
<a name="ln3807">		slot = 1;</a>
<a name="ln3808"> </a>
<a name="ln3809">	InterruptsReadSpinLocker locker(sTeamHashLock);</a>
<a name="ln3810"> </a>
<a name="ln3811">	team_id lastTeamID = peek_next_thread_id();</a>
<a name="ln3812">		// TODO: This is broken, since the id can wrap around!</a>
<a name="ln3813"> </a>
<a name="ln3814">	// get next valid team</a>
<a name="ln3815">	Team* team = NULL;</a>
<a name="ln3816">	while (slot &lt; lastTeamID &amp;&amp; !(team = team_get_team_struct_locked(slot)))</a>
<a name="ln3817">		slot++;</a>
<a name="ln3818"> </a>
<a name="ln3819">	if (team == NULL)</a>
<a name="ln3820">		return B_BAD_TEAM_ID;</a>
<a name="ln3821"> </a>
<a name="ln3822">	// get a reference to the team and unlock</a>
<a name="ln3823">	BReference&lt;Team&gt; teamReference(team);</a>
<a name="ln3824">	locker.Unlock();</a>
<a name="ln3825"> </a>
<a name="ln3826">	// fill in the info</a>
<a name="ln3827">	*cookie = ++slot;</a>
<a name="ln3828">	return fill_team_info(team, info, size);</a>
<a name="ln3829">}</a>
<a name="ln3830"> </a>
<a name="ln3831"> </a>
<a name="ln3832">status_t</a>
<a name="ln3833">_get_team_usage_info(team_id id, int32 who, team_usage_info* info, size_t size)</a>
<a name="ln3834">{</a>
<a name="ln3835">	if (size != sizeof(team_usage_info))</a>
<a name="ln3836">		return B_BAD_VALUE;</a>
<a name="ln3837"> </a>
<a name="ln3838">	return common_get_team_usage_info(id, who, info, 0);</a>
<a name="ln3839">}</a>
<a name="ln3840"> </a>
<a name="ln3841"> </a>
<a name="ln3842">pid_t</a>
<a name="ln3843">getpid(void)</a>
<a name="ln3844">{</a>
<a name="ln3845">	return thread_get_current_thread()-&gt;team-&gt;id;</a>
<a name="ln3846">}</a>
<a name="ln3847"> </a>
<a name="ln3848"> </a>
<a name="ln3849">pid_t</a>
<a name="ln3850">getppid(void)</a>
<a name="ln3851">{</a>
<a name="ln3852">	Team* team = thread_get_current_thread()-&gt;team;</a>
<a name="ln3853"> </a>
<a name="ln3854">	TeamLocker teamLocker(team);</a>
<a name="ln3855"> </a>
<a name="ln3856">	return team-&gt;parent-&gt;id;</a>
<a name="ln3857">}</a>
<a name="ln3858"> </a>
<a name="ln3859"> </a>
<a name="ln3860">pid_t</a>
<a name="ln3861">getpgid(pid_t id)</a>
<a name="ln3862">{</a>
<a name="ln3863">	if (id &lt; 0) {</a>
<a name="ln3864">		errno = EINVAL;</a>
<a name="ln3865">		return -1;</a>
<a name="ln3866">	}</a>
<a name="ln3867"> </a>
<a name="ln3868">	if (id == 0) {</a>
<a name="ln3869">		// get process group of the calling process</a>
<a name="ln3870">		Team* team = thread_get_current_thread()-&gt;team;</a>
<a name="ln3871">		TeamLocker teamLocker(team);</a>
<a name="ln3872">		return team-&gt;group_id;</a>
<a name="ln3873">	}</a>
<a name="ln3874"> </a>
<a name="ln3875">	// get the team</a>
<a name="ln3876">	Team* team = Team::GetAndLock(id);</a>
<a name="ln3877">	if (team == NULL) {</a>
<a name="ln3878">		errno = ESRCH;</a>
<a name="ln3879">		return -1;</a>
<a name="ln3880">	}</a>
<a name="ln3881"> </a>
<a name="ln3882">	// get the team's process group ID</a>
<a name="ln3883">	pid_t groupID = team-&gt;group_id;</a>
<a name="ln3884"> </a>
<a name="ln3885">	team-&gt;UnlockAndReleaseReference();</a>
<a name="ln3886"> </a>
<a name="ln3887">	return groupID;</a>
<a name="ln3888">}</a>
<a name="ln3889"> </a>
<a name="ln3890"> </a>
<a name="ln3891">pid_t</a>
<a name="ln3892">getsid(pid_t id)</a>
<a name="ln3893">{</a>
<a name="ln3894">	if (id &lt; 0) {</a>
<a name="ln3895">		errno = EINVAL;</a>
<a name="ln3896">		return -1;</a>
<a name="ln3897">	}</a>
<a name="ln3898"> </a>
<a name="ln3899">	if (id == 0) {</a>
<a name="ln3900">		// get session of the calling process</a>
<a name="ln3901">		Team* team = thread_get_current_thread()-&gt;team;</a>
<a name="ln3902">		TeamLocker teamLocker(team);</a>
<a name="ln3903">		return team-&gt;session_id;</a>
<a name="ln3904">	}</a>
<a name="ln3905"> </a>
<a name="ln3906">	// get the team</a>
<a name="ln3907">	Team* team = Team::GetAndLock(id);</a>
<a name="ln3908">	if (team == NULL) {</a>
<a name="ln3909">		errno = ESRCH;</a>
<a name="ln3910">		return -1;</a>
<a name="ln3911">	}</a>
<a name="ln3912"> </a>
<a name="ln3913">	// get the team's session ID</a>
<a name="ln3914">	pid_t sessionID = team-&gt;session_id;</a>
<a name="ln3915"> </a>
<a name="ln3916">	team-&gt;UnlockAndReleaseReference();</a>
<a name="ln3917"> </a>
<a name="ln3918">	return sessionID;</a>
<a name="ln3919">}</a>
<a name="ln3920"> </a>
<a name="ln3921"> </a>
<a name="ln3922">//	#pragma mark - User syscalls</a>
<a name="ln3923"> </a>
<a name="ln3924"> </a>
<a name="ln3925">status_t</a>
<a name="ln3926">_user_exec(const char* userPath, const char* const* userFlatArgs,</a>
<a name="ln3927">	size_t flatArgsSize, int32 argCount, int32 envCount, mode_t umask)</a>
<a name="ln3928">{</a>
<a name="ln3929">	// NOTE: Since this function normally doesn't return, don't use automatic</a>
<a name="ln3930">	// variables that need destruction in the function scope.</a>
<a name="ln3931">	char path[B_PATH_NAME_LENGTH];</a>
<a name="ln3932"> </a>
<a name="ln3933">	if (!IS_USER_ADDRESS(userPath) || !IS_USER_ADDRESS(userFlatArgs)</a>
<a name="ln3934">		|| user_strlcpy(path, userPath, sizeof(path)) &lt; B_OK)</a>
<a name="ln3935">		return B_BAD_ADDRESS;</a>
<a name="ln3936"> </a>
<a name="ln3937">	// copy and relocate the flat arguments</a>
<a name="ln3938">	char** flatArgs;</a>
<a name="ln3939">	status_t error = copy_user_process_args(userFlatArgs, flatArgsSize,</a>
<a name="ln3940">		argCount, envCount, flatArgs);</a>
<a name="ln3941"> </a>
<a name="ln3942">	if (error == B_OK) {</a>
<a name="ln3943">		error = exec_team(path, flatArgs, _ALIGN(flatArgsSize), argCount,</a>
<a name="ln3944">			envCount, umask);</a>
<a name="ln3945">			// this one only returns in case of error</a>
<a name="ln3946">	}</a>
<a name="ln3947"> </a>
<a name="ln3948">	free(flatArgs);</a>
<a name="ln3949">	return error;</a>
<a name="ln3950">}</a>
<a name="ln3951"> </a>
<a name="ln3952"> </a>
<a name="ln3953">thread_id</a>
<a name="ln3954">_user_fork(void)</a>
<a name="ln3955">{</a>
<a name="ln3956">	return fork_team();</a>
<a name="ln3957">}</a>
<a name="ln3958"> </a>
<a name="ln3959"> </a>
<a name="ln3960">pid_t</a>
<a name="ln3961">_user_wait_for_child(thread_id child, uint32 flags, siginfo_t* userInfo,</a>
<a name="ln3962">	team_usage_info* usageInfo)</a>
<a name="ln3963">{</a>
<a name="ln3964">	if (userInfo != NULL &amp;&amp; !IS_USER_ADDRESS(userInfo))</a>
<a name="ln3965">		return B_BAD_ADDRESS;</a>
<a name="ln3966">	if (usageInfo != NULL &amp;&amp; !IS_USER_ADDRESS(usageInfo))</a>
<a name="ln3967">		return B_BAD_ADDRESS;</a>
<a name="ln3968"> </a>
<a name="ln3969">	siginfo_t info;</a>
<a name="ln3970">	team_usage_info usage_info;</a>
<a name="ln3971">	pid_t foundChild = wait_for_child(child, flags, info, usage_info);</a>
<a name="ln3972">	if (foundChild &lt; 0)</a>
<a name="ln3973">		return syscall_restart_handle_post(foundChild);</a>
<a name="ln3974"> </a>
<a name="ln3975">	// copy info back to userland</a>
<a name="ln3976">	if (userInfo != NULL &amp;&amp; user_memcpy(userInfo, &amp;info, sizeof(info)) != B_OK)</a>
<a name="ln3977">		return B_BAD_ADDRESS;</a>
<a name="ln3978">	// copy usage_info back to userland</a>
<a name="ln3979">	if (usageInfo != NULL &amp;&amp; user_memcpy(usageInfo, &amp;usage_info,</a>
<a name="ln3980">		sizeof(usage_info)) != B_OK) {</a>
<a name="ln3981">		return B_BAD_ADDRESS;</a>
<a name="ln3982">	}</a>
<a name="ln3983"> </a>
<a name="ln3984">	return foundChild;</a>
<a name="ln3985">}</a>
<a name="ln3986"> </a>
<a name="ln3987"> </a>
<a name="ln3988">pid_t</a>
<a name="ln3989">_user_process_info(pid_t process, int32 which)</a>
<a name="ln3990">{</a>
<a name="ln3991">	// we only allow to return the parent of the current process</a>
<a name="ln3992">	if (which == PARENT_ID</a>
<a name="ln3993">		&amp;&amp; process != 0 &amp;&amp; process != thread_get_current_thread()-&gt;team-&gt;id)</a>
<a name="ln3994">		return B_BAD_VALUE;</a>
<a name="ln3995"> </a>
<a name="ln3996">	pid_t result;</a>
<a name="ln3997">	switch (which) {</a>
<a name="ln3998">		case SESSION_ID:</a>
<a name="ln3999">			result = getsid(process);</a>
<a name="ln4000">			break;</a>
<a name="ln4001">		case GROUP_ID:</a>
<a name="ln4002">			result = getpgid(process);</a>
<a name="ln4003">			break;</a>
<a name="ln4004">		case PARENT_ID:</a>
<a name="ln4005">			result = getppid();</a>
<a name="ln4006">			break;</a>
<a name="ln4007">		default:</a>
<a name="ln4008">			return B_BAD_VALUE;</a>
<a name="ln4009">	}</a>
<a name="ln4010"> </a>
<a name="ln4011">	return result &gt;= 0 ? result : errno;</a>
<a name="ln4012">}</a>
<a name="ln4013"> </a>
<a name="ln4014"> </a>
<a name="ln4015">pid_t</a>
<a name="ln4016">_user_setpgid(pid_t processID, pid_t groupID)</a>
<a name="ln4017">{</a>
<a name="ln4018">	// setpgid() can be called either by the parent of the target process or</a>
<a name="ln4019">	// by the process itself to do one of two things:</a>
<a name="ln4020">	// * Create a new process group with the target process' ID and the target</a>
<a name="ln4021">	//   process as group leader.</a>
<a name="ln4022">	// * Set the target process' process group to an already existing one in the</a>
<a name="ln4023">	//   same session.</a>
<a name="ln4024"> </a>
<a name="ln4025">	if (groupID &lt; 0)</a>
<a name="ln4026">		return B_BAD_VALUE;</a>
<a name="ln4027"> </a>
<a name="ln4028">	Team* currentTeam = thread_get_current_thread()-&gt;team;</a>
<a name="ln4029">	if (processID == 0)</a>
<a name="ln4030">		processID = currentTeam-&gt;id;</a>
<a name="ln4031"> </a>
<a name="ln4032">	// if the group ID is not specified, use the target process' ID</a>
<a name="ln4033">	if (groupID == 0)</a>
<a name="ln4034">		groupID = processID;</a>
<a name="ln4035"> </a>
<a name="ln4036">	// We loop when running into the following race condition: We create a new</a>
<a name="ln4037">	// process group, because there isn't one with that ID yet, but later when</a>
<a name="ln4038">	// trying to publish it, we find that someone else created and published</a>
<a name="ln4039">	// a group with that ID in the meantime. In that case we just restart the</a>
<a name="ln4040">	// whole action.</a>
<a name="ln4041">	while (true) {</a>
<a name="ln4042">		// Look up the process group by ID. If it doesn't exist yet and we are</a>
<a name="ln4043">		// allowed to create a new one, do that.</a>
<a name="ln4044">		ProcessGroup* group = ProcessGroup::Get(groupID);</a>
<a name="ln4045">		bool newGroup = false;</a>
<a name="ln4046">		if (group == NULL) {</a>
<a name="ln4047">			if (groupID != processID)</a>
<a name="ln4048">				return B_NOT_ALLOWED;</a>
<a name="ln4049"> </a>
<a name="ln4050">			group = new(std::nothrow) ProcessGroup(groupID);</a>
<a name="ln4051">			if (group == NULL)</a>
<a name="ln4052">				return B_NO_MEMORY;</a>
<a name="ln4053"> </a>
<a name="ln4054">			newGroup = true;</a>
<a name="ln4055">		}</a>
<a name="ln4056">		BReference&lt;ProcessGroup&gt; groupReference(group, true);</a>
<a name="ln4057"> </a>
<a name="ln4058">		// get the target team</a>
<a name="ln4059">		Team* team = Team::Get(processID);</a>
<a name="ln4060">		if (team == NULL)</a>
<a name="ln4061">			return ESRCH;</a>
<a name="ln4062">		BReference&lt;Team&gt; teamReference(team, true);</a>
<a name="ln4063"> </a>
<a name="ln4064">		// lock the new process group and the team's current process group</a>
<a name="ln4065">		while (true) {</a>
<a name="ln4066">			// lock the team's current process group</a>
<a name="ln4067">			team-&gt;LockProcessGroup();</a>
<a name="ln4068"> </a>
<a name="ln4069">			ProcessGroup* oldGroup = team-&gt;group;</a>
<a name="ln4070">			if (oldGroup == group) {</a>
<a name="ln4071">				// it's the same as the target group, so just bail out</a>
<a name="ln4072">				oldGroup-&gt;Unlock();</a>
<a name="ln4073">				return group-&gt;id;</a>
<a name="ln4074">			}</a>
<a name="ln4075"> </a>
<a name="ln4076">			oldGroup-&gt;AcquireReference();</a>
<a name="ln4077"> </a>
<a name="ln4078">			// lock the target process group, if locking order allows it</a>
<a name="ln4079">			if (newGroup || group-&gt;id &gt; oldGroup-&gt;id) {</a>
<a name="ln4080">				group-&gt;Lock();</a>
<a name="ln4081">				break;</a>
<a name="ln4082">			}</a>
<a name="ln4083"> </a>
<a name="ln4084">			// try to lock</a>
<a name="ln4085">			if (group-&gt;TryLock())</a>
<a name="ln4086">				break;</a>
<a name="ln4087"> </a>
<a name="ln4088">			// no dice -- unlock the team's current process group and relock in</a>
<a name="ln4089">			// the correct order</a>
<a name="ln4090">			oldGroup-&gt;Unlock();</a>
<a name="ln4091"> </a>
<a name="ln4092">			group-&gt;Lock();</a>
<a name="ln4093">			oldGroup-&gt;Lock();</a>
<a name="ln4094"> </a>
<a name="ln4095">			// check whether things are still the same</a>
<a name="ln4096">			TeamLocker teamLocker(team);</a>
<a name="ln4097">			if (team-&gt;group == oldGroup)</a>
<a name="ln4098">				break;</a>
<a name="ln4099"> </a>
<a name="ln4100">			// something changed -- unlock everything and retry</a>
<a name="ln4101">			teamLocker.Unlock();</a>
<a name="ln4102">			oldGroup-&gt;Unlock();</a>
<a name="ln4103">			group-&gt;Unlock();</a>
<a name="ln4104">			oldGroup-&gt;ReleaseReference();</a>
<a name="ln4105">		}</a>
<a name="ln4106"> </a>
<a name="ln4107">		// we now have references and locks of both new and old process group</a>
<a name="ln4108">		BReference&lt;ProcessGroup&gt; oldGroupReference(team-&gt;group, true);</a>
<a name="ln4109">		AutoLocker&lt;ProcessGroup&gt; oldGroupLocker(team-&gt;group, true);</a>
<a name="ln4110">		AutoLocker&lt;ProcessGroup&gt; groupLocker(group, true);</a>
<a name="ln4111"> </a>
<a name="ln4112">		// also lock the target team and its parent</a>
<a name="ln4113">		team-&gt;LockTeamAndParent(false);</a>
<a name="ln4114">		TeamLocker parentLocker(team-&gt;parent, true);</a>
<a name="ln4115">		TeamLocker teamLocker(team, true);</a>
<a name="ln4116"> </a>
<a name="ln4117">		// perform the checks</a>
<a name="ln4118">		if (team == currentTeam) {</a>
<a name="ln4119">			// we set our own group</a>
<a name="ln4120"> </a>
<a name="ln4121">			// we must not change our process group ID if we're a session leader</a>
<a name="ln4122">			if (is_session_leader(currentTeam))</a>
<a name="ln4123">				return B_NOT_ALLOWED;</a>
<a name="ln4124">		} else {</a>
<a name="ln4125">			// Calling team != target team. The target team must be a child of</a>
<a name="ln4126">			// the calling team and in the same session. (If that's the case it</a>
<a name="ln4127">			// isn't a session leader either.)</a>
<a name="ln4128">			if (team-&gt;parent != currentTeam</a>
<a name="ln4129">				|| team-&gt;session_id != currentTeam-&gt;session_id) {</a>
<a name="ln4130">				return B_NOT_ALLOWED;</a>
<a name="ln4131">			}</a>
<a name="ln4132"> </a>
<a name="ln4133">			// The call is also supposed to fail on a child, when the child has</a>
<a name="ln4134">			// already executed exec*() [EACCES].</a>
<a name="ln4135">			if ((team-&gt;flags &amp; TEAM_FLAG_EXEC_DONE) != 0)</a>
<a name="ln4136">				return EACCES;</a>
<a name="ln4137">		}</a>
<a name="ln4138"> </a>
<a name="ln4139">		// If we created a new process group, publish it now.</a>
<a name="ln4140">		if (newGroup) {</a>
<a name="ln4141">			InterruptsSpinLocker groupHashLocker(sGroupHashLock);</a>
<a name="ln4142">			if (sGroupHash.Lookup(groupID)) {</a>
<a name="ln4143">				// A group with the group ID appeared since we first checked.</a>
<a name="ln4144">				// Back to square one.</a>
<a name="ln4145">				continue;</a>
<a name="ln4146">			}</a>
<a name="ln4147"> </a>
<a name="ln4148">			group-&gt;PublishLocked(team-&gt;group-&gt;Session());</a>
<a name="ln4149">		} else if (group-&gt;Session()-&gt;id != team-&gt;session_id) {</a>
<a name="ln4150">			// The existing target process group belongs to a different session.</a>
<a name="ln4151">			// That's not allowed.</a>
<a name="ln4152">			return B_NOT_ALLOWED;</a>
<a name="ln4153">		}</a>
<a name="ln4154"> </a>
<a name="ln4155">		// Everything is ready -- set the group.</a>
<a name="ln4156">		remove_team_from_group(team);</a>
<a name="ln4157">		insert_team_into_group(group, team);</a>
<a name="ln4158"> </a>
<a name="ln4159">		// Changing the process group might have changed the situation for a</a>
<a name="ln4160">		// parent waiting in wait_for_child(). Hence we notify it.</a>
<a name="ln4161">		team-&gt;parent-&gt;dead_children.condition_variable.NotifyAll();</a>
<a name="ln4162"> </a>
<a name="ln4163">		return group-&gt;id;</a>
<a name="ln4164">	}</a>
<a name="ln4165">}</a>
<a name="ln4166"> </a>
<a name="ln4167"> </a>
<a name="ln4168">pid_t</a>
<a name="ln4169">_user_setsid(void)</a>
<a name="ln4170">{</a>
<a name="ln4171">	Team* team = thread_get_current_thread()-&gt;team;</a>
<a name="ln4172"> </a>
<a name="ln4173">	// create a new process group and session</a>
<a name="ln4174">	ProcessGroup* group = new(std::nothrow) ProcessGroup(team-&gt;id);</a>
<a name="ln4175">	if (group == NULL)</a>
<a name="ln4176">		return B_NO_MEMORY;</a>
<a name="ln4177">	BReference&lt;ProcessGroup&gt; groupReference(group, true);</a>
<a name="ln4178">	AutoLocker&lt;ProcessGroup&gt; groupLocker(group);</a>
<a name="ln4179"> </a>
<a name="ln4180">	ProcessSession* session = new(std::nothrow) ProcessSession(group-&gt;id);</a>
<a name="ln4181">	if (session == NULL)</a>
<a name="ln4182">		return B_NO_MEMORY;</a>
<a name="ln4183">	BReference&lt;ProcessSession&gt; sessionReference(session, true);</a>
<a name="ln4184"> </a>
<a name="ln4185">	// lock the team's current process group, parent, and the team itself</a>
<a name="ln4186">	team-&gt;LockTeamParentAndProcessGroup();</a>
<a name="ln4187">	BReference&lt;ProcessGroup&gt; oldGroupReference(team-&gt;group);</a>
<a name="ln4188">	AutoLocker&lt;ProcessGroup&gt; oldGroupLocker(team-&gt;group, true);</a>
<a name="ln4189">	TeamLocker parentLocker(team-&gt;parent, true);</a>
<a name="ln4190">	TeamLocker teamLocker(team, true);</a>
<a name="ln4191"> </a>
<a name="ln4192">	// the team must not already be a process group leader</a>
<a name="ln4193">	if (is_process_group_leader(team))</a>
<a name="ln4194">		return B_NOT_ALLOWED;</a>
<a name="ln4195"> </a>
<a name="ln4196">	// remove the team from the old and add it to the new process group</a>
<a name="ln4197">	remove_team_from_group(team);</a>
<a name="ln4198">	group-&gt;Publish(session);</a>
<a name="ln4199">	insert_team_into_group(group, team);</a>
<a name="ln4200"> </a>
<a name="ln4201">	// Changing the process group might have changed the situation for a</a>
<a name="ln4202">	// parent waiting in wait_for_child(). Hence we notify it.</a>
<a name="ln4203">	team-&gt;parent-&gt;dead_children.condition_variable.NotifyAll();</a>
<a name="ln4204"> </a>
<a name="ln4205">	return group-&gt;id;</a>
<a name="ln4206">}</a>
<a name="ln4207"> </a>
<a name="ln4208"> </a>
<a name="ln4209">status_t</a>
<a name="ln4210">_user_wait_for_team(team_id id, status_t* _userReturnCode)</a>
<a name="ln4211">{</a>
<a name="ln4212">	status_t returnCode;</a>
<a name="ln4213">	status_t status;</a>
<a name="ln4214"> </a>
<a name="ln4215">	if (_userReturnCode != NULL &amp;&amp; !IS_USER_ADDRESS(_userReturnCode))</a>
<a name="ln4216">		return B_BAD_ADDRESS;</a>
<a name="ln4217"> </a>
<a name="ln4218">	status = wait_for_team(id, &amp;returnCode);</a>
<a name="ln4219">	if (status &gt;= B_OK &amp;&amp; _userReturnCode != NULL) {</a>
<a name="ln4220">		if (user_memcpy(_userReturnCode, &amp;returnCode, sizeof(returnCode))</a>
<a name="ln4221">				!= B_OK)</a>
<a name="ln4222">			return B_BAD_ADDRESS;</a>
<a name="ln4223">		return B_OK;</a>
<a name="ln4224">	}</a>
<a name="ln4225"> </a>
<a name="ln4226">	return syscall_restart_handle_post(status);</a>
<a name="ln4227">}</a>
<a name="ln4228"> </a>
<a name="ln4229"> </a>
<a name="ln4230">thread_id</a>
<a name="ln4231">_user_load_image(const char* const* userFlatArgs, size_t flatArgsSize,</a>
<a name="ln4232">	int32 argCount, int32 envCount, int32 priority, uint32 flags,</a>
<a name="ln4233">	port_id errorPort, uint32 errorToken)</a>
<a name="ln4234">{</a>
<a name="ln4235">	TRACE((&quot;_user_load_image: argc = %&quot; B_PRId32 &quot;\n&quot;, argCount));</a>
<a name="ln4236"> </a>
<a name="ln4237">	if (argCount &lt; 1)</a>
<a name="ln4238">		return B_BAD_VALUE;</a>
<a name="ln4239"> </a>
<a name="ln4240">	// copy and relocate the flat arguments</a>
<a name="ln4241">	char** flatArgs;</a>
<a name="ln4242">	status_t error = copy_user_process_args(userFlatArgs, flatArgsSize,</a>
<a name="ln4243">		argCount, envCount, flatArgs);</a>
<a name="ln4244">	if (error != B_OK)</a>
<a name="ln4245">		return error;</a>
<a name="ln4246"> </a>
<a name="ln4247">	thread_id thread = load_image_internal(flatArgs, _ALIGN(flatArgsSize),</a>
<a name="ln4248">		argCount, envCount, priority, B_CURRENT_TEAM, flags, errorPort,</a>
<a name="ln4249">		errorToken);</a>
<a name="ln4250"> </a>
<a name="ln4251">	free(flatArgs);</a>
<a name="ln4252">		// load_image_internal() unset our variable if it took over ownership</a>
<a name="ln4253"> </a>
<a name="ln4254">	return thread;</a>
<a name="ln4255">}</a>
<a name="ln4256"> </a>
<a name="ln4257"> </a>
<a name="ln4258">void</a>
<a name="ln4259">_user_exit_team(status_t returnValue)</a>
<a name="ln4260">{</a>
<a name="ln4261">	Thread* thread = thread_get_current_thread();</a>
<a name="ln4262">	Team* team = thread-&gt;team;</a>
<a name="ln4263"> </a>
<a name="ln4264">	// set this thread's exit status</a>
<a name="ln4265">	thread-&gt;exit.status = returnValue;</a>
<a name="ln4266"> </a>
<a name="ln4267">	// set the team exit status</a>
<a name="ln4268">	TeamLocker teamLocker(team);</a>
<a name="ln4269"> </a>
<a name="ln4270">	if (!team-&gt;exit.initialized) {</a>
<a name="ln4271">		team-&gt;exit.reason = CLD_EXITED;</a>
<a name="ln4272">		team-&gt;exit.signal = 0;</a>
<a name="ln4273">		team-&gt;exit.signaling_user = 0;</a>
<a name="ln4274">		team-&gt;exit.status = returnValue;</a>
<a name="ln4275">		team-&gt;exit.initialized = true;</a>
<a name="ln4276">	}</a>
<a name="ln4277"> </a>
<a name="ln4278">	teamLocker.Unlock();</a>
<a name="ln4279"> </a>
<a name="ln4280">	// Stop the thread, if the team is being debugged and that has been</a>
<a name="ln4281">	// requested.</a>
<a name="ln4282">	if ((atomic_get(&amp;team-&gt;debug_info.flags) &amp; B_TEAM_DEBUG_PREVENT_EXIT) != 0)</a>
<a name="ln4283">		user_debug_stop_thread();</a>
<a name="ln4284"> </a>
<a name="ln4285">	// Send this thread a SIGKILL. This makes sure the thread will not return to</a>
<a name="ln4286">	// userland. The signal handling code forwards the signal to the main</a>
<a name="ln4287">	// thread (if that's not already this one), which will take the team down.</a>
<a name="ln4288">	Signal signal(SIGKILL, SI_USER, B_OK, team-&gt;id);</a>
<a name="ln4289">	send_signal_to_thread(thread, signal, 0);</a>
<a name="ln4290">}</a>
<a name="ln4291"> </a>
<a name="ln4292"> </a>
<a name="ln4293">status_t</a>
<a name="ln4294">_user_kill_team(team_id team)</a>
<a name="ln4295">{</a>
<a name="ln4296">	return kill_team(team);</a>
<a name="ln4297">}</a>
<a name="ln4298"> </a>
<a name="ln4299"> </a>
<a name="ln4300">status_t</a>
<a name="ln4301">_user_get_team_info(team_id id, team_info* userInfo)</a>
<a name="ln4302">{</a>
<a name="ln4303">	status_t status;</a>
<a name="ln4304">	team_info info;</a>
<a name="ln4305"> </a>
<a name="ln4306">	if (!IS_USER_ADDRESS(userInfo))</a>
<a name="ln4307">		return B_BAD_ADDRESS;</a>
<a name="ln4308"> </a>
<a name="ln4309">	status = _get_team_info(id, &amp;info, sizeof(team_info));</a>
<a name="ln4310">	if (status == B_OK) {</a>
<a name="ln4311">		if (user_memcpy(userInfo, &amp;info, sizeof(team_info)) &lt; B_OK)</a>
<a name="ln4312">			return B_BAD_ADDRESS;</a>
<a name="ln4313">	}</a>
<a name="ln4314"> </a>
<a name="ln4315">	return status;</a>
<a name="ln4316">}</a>
<a name="ln4317"> </a>
<a name="ln4318"> </a>
<a name="ln4319">status_t</a>
<a name="ln4320">_user_get_next_team_info(int32* userCookie, team_info* userInfo)</a>
<a name="ln4321">{</a>
<a name="ln4322">	status_t status;</a>
<a name="ln4323">	team_info info;</a>
<a name="ln4324">	int32 cookie;</a>
<a name="ln4325"> </a>
<a name="ln4326">	if (!IS_USER_ADDRESS(userCookie)</a>
<a name="ln4327">		|| !IS_USER_ADDRESS(userInfo)</a>
<a name="ln4328">		|| user_memcpy(&amp;cookie, userCookie, sizeof(int32)) &lt; B_OK)</a>
<a name="ln4329">		return B_BAD_ADDRESS;</a>
<a name="ln4330"> </a>
<a name="ln4331">	status = _get_next_team_info(&amp;cookie, &amp;info, sizeof(team_info));</a>
<a name="ln4332">	if (status != B_OK)</a>
<a name="ln4333">		return status;</a>
<a name="ln4334"> </a>
<a name="ln4335">	if (user_memcpy(userCookie, &amp;cookie, sizeof(int32)) &lt; B_OK</a>
<a name="ln4336">		|| user_memcpy(userInfo, &amp;info, sizeof(team_info)) &lt; B_OK)</a>
<a name="ln4337">		return B_BAD_ADDRESS;</a>
<a name="ln4338"> </a>
<a name="ln4339">	return status;</a>
<a name="ln4340">}</a>
<a name="ln4341"> </a>
<a name="ln4342"> </a>
<a name="ln4343">team_id</a>
<a name="ln4344">_user_get_current_team(void)</a>
<a name="ln4345">{</a>
<a name="ln4346">	return team_get_current_team_id();</a>
<a name="ln4347">}</a>
<a name="ln4348"> </a>
<a name="ln4349"> </a>
<a name="ln4350">status_t</a>
<a name="ln4351">_user_get_team_usage_info(team_id team, int32 who, team_usage_info* userInfo,</a>
<a name="ln4352">	size_t size)</a>
<a name="ln4353">{</a>
<a name="ln4354">	if (size != sizeof(team_usage_info))</a>
<a name="ln4355">		return B_BAD_VALUE;</a>
<a name="ln4356"> </a>
<a name="ln4357">	team_usage_info info;</a>
<a name="ln4358">	status_t status = common_get_team_usage_info(team, who, &amp;info,</a>
<a name="ln4359">		B_CHECK_PERMISSION);</a>
<a name="ln4360"> </a>
<a name="ln4361">	if (userInfo == NULL || !IS_USER_ADDRESS(userInfo)</a>
<a name="ln4362">		|| user_memcpy(userInfo, &amp;info, size) != B_OK) {</a>
<a name="ln4363">		return B_BAD_ADDRESS;</a>
<a name="ln4364">	}</a>
<a name="ln4365"> </a>
<a name="ln4366">	return status;</a>
<a name="ln4367">}</a>
<a name="ln4368"> </a>
<a name="ln4369"> </a>
<a name="ln4370">status_t</a>
<a name="ln4371">_user_get_extended_team_info(team_id teamID, uint32 flags, void* buffer,</a>
<a name="ln4372">	size_t size, size_t* _sizeNeeded)</a>
<a name="ln4373">{</a>
<a name="ln4374">	// check parameters</a>
<a name="ln4375">	if ((buffer != NULL &amp;&amp; !IS_USER_ADDRESS(buffer))</a>
<a name="ln4376">		|| (buffer == NULL &amp;&amp; size &gt; 0)</a>
<a name="ln4377">		|| _sizeNeeded == NULL || !IS_USER_ADDRESS(_sizeNeeded)) {</a>
<a name="ln4378">		return B_BAD_ADDRESS;</a>
<a name="ln4379">	}</a>
<a name="ln4380"> </a>
<a name="ln4381">	KMessage info;</a>
<a name="ln4382"> </a>
<a name="ln4383">	if ((flags &amp; B_TEAM_INFO_BASIC) != 0) {</a>
<a name="ln4384">		// allocate memory for a copy of the needed team data</a>
<a name="ln4385">		struct ExtendedTeamData {</a>
<a name="ln4386">			team_id	id;</a>
<a name="ln4387">			pid_t	group_id;</a>
<a name="ln4388">			pid_t	session_id;</a>
<a name="ln4389">			uid_t	real_uid;</a>
<a name="ln4390">			gid_t	real_gid;</a>
<a name="ln4391">			uid_t	effective_uid;</a>
<a name="ln4392">			gid_t	effective_gid;</a>
<a name="ln4393">			char	name[B_OS_NAME_LENGTH];</a>
<a name="ln4394">		};</a>
<a name="ln4395"> </a>
<a name="ln4396">		ExtendedTeamData* teamClone</a>
<a name="ln4397">			= (ExtendedTeamData*)malloc(sizeof(ExtendedTeamData));</a>
<a name="ln4398">			// It would be nicer to use new, but then we'd have to use</a>
<a name="ln4399">			// ObjectDeleter and declare the structure outside of the function</a>
<a name="ln4400">			// due to template parameter restrictions.</a>
<a name="ln4401">		if (teamClone == NULL)</a>
<a name="ln4402">			return B_NO_MEMORY;</a>
<a name="ln4403">		MemoryDeleter teamCloneDeleter(teamClone);</a>
<a name="ln4404"> </a>
<a name="ln4405">		io_context* ioContext;</a>
<a name="ln4406">		{</a>
<a name="ln4407">			// get the team structure</a>
<a name="ln4408">			Team* team = Team::GetAndLock(teamID);</a>
<a name="ln4409">			if (team == NULL)</a>
<a name="ln4410">				return B_BAD_TEAM_ID;</a>
<a name="ln4411">			BReference&lt;Team&gt; teamReference(team, true);</a>
<a name="ln4412">			TeamLocker teamLocker(team, true);</a>
<a name="ln4413"> </a>
<a name="ln4414">			// copy the data</a>
<a name="ln4415">			teamClone-&gt;id = team-&gt;id;</a>
<a name="ln4416">			strlcpy(teamClone-&gt;name, team-&gt;Name(), sizeof(teamClone-&gt;name));</a>
<a name="ln4417">			teamClone-&gt;group_id = team-&gt;group_id;</a>
<a name="ln4418">			teamClone-&gt;session_id = team-&gt;session_id;</a>
<a name="ln4419">			teamClone-&gt;real_uid = team-&gt;real_uid;</a>
<a name="ln4420">			teamClone-&gt;real_gid = team-&gt;real_gid;</a>
<a name="ln4421">			teamClone-&gt;effective_uid = team-&gt;effective_uid;</a>
<a name="ln4422">			teamClone-&gt;effective_gid = team-&gt;effective_gid;</a>
<a name="ln4423"> </a>
<a name="ln4424">			// also fetch a reference to the I/O context</a>
<a name="ln4425">			ioContext = team-&gt;io_context;</a>
<a name="ln4426">			vfs_get_io_context(ioContext);</a>
<a name="ln4427">		}</a>
<a name="ln4428">		CObjectDeleter&lt;io_context&gt; ioContextPutter(ioContext,</a>
<a name="ln4429">			&amp;vfs_put_io_context);</a>
<a name="ln4430"> </a>
<a name="ln4431">		// add the basic data to the info message</a>
<a name="ln4432">		if (info.AddInt32(&quot;id&quot;, teamClone-&gt;id) != B_OK</a>
<a name="ln4433">			|| info.AddString(&quot;name&quot;, teamClone-&gt;name) != B_OK</a>
<a name="ln4434">			|| info.AddInt32(&quot;process group&quot;, teamClone-&gt;group_id) != B_OK</a>
<a name="ln4435">			|| info.AddInt32(&quot;session&quot;, teamClone-&gt;session_id) != B_OK</a>
<a name="ln4436">			|| info.AddInt32(&quot;uid&quot;, teamClone-&gt;real_uid) != B_OK</a>
<a name="ln4437">			|| info.AddInt32(&quot;gid&quot;, teamClone-&gt;real_gid) != B_OK</a>
<a name="ln4438">			|| info.AddInt32(&quot;euid&quot;, teamClone-&gt;effective_uid) != B_OK</a>
<a name="ln4439">			|| info.AddInt32(&quot;egid&quot;, teamClone-&gt;effective_gid) != B_OK) {</a>
<a name="ln4440">			return B_NO_MEMORY;</a>
<a name="ln4441">		}</a>
<a name="ln4442"> </a>
<a name="ln4443">		// get the current working directory from the I/O context</a>
<a name="ln4444">		dev_t cwdDevice;</a>
<a name="ln4445">		ino_t cwdDirectory;</a>
<a name="ln4446">		{</a>
<a name="ln4447">			MutexLocker ioContextLocker(ioContext-&gt;io_mutex);</a>
<a name="ln4448">			vfs_vnode_to_node_ref(ioContext-&gt;cwd, &amp;cwdDevice, &amp;cwdDirectory);</a>
<a name="ln4449">		}</a>
<a name="ln4450"> </a>
<a name="ln4451">		if (info.AddInt32(&quot;cwd device&quot;, cwdDevice) != B_OK</a>
<a name="ln4452">			|| info.AddInt64(&quot;cwd directory&quot;, cwdDirectory) != B_OK) {</a>
<a name="ln4453">			return B_NO_MEMORY;</a>
<a name="ln4454">		}</a>
<a name="ln4455">	}</a>
<a name="ln4456"> </a>
<a name="ln4457">	// TODO: Support the other flags!</a>
<a name="ln4458"> </a>
<a name="ln4459">	// copy the needed size and, if it fits, the message back to userland</a>
<a name="ln4460">	size_t sizeNeeded = info.ContentSize();</a>
<a name="ln4461">	if (user_memcpy(_sizeNeeded, &amp;sizeNeeded, sizeof(sizeNeeded)) != B_OK)</a>
<a name="ln4462">		return B_BAD_ADDRESS;</a>
<a name="ln4463"> </a>
<a name="ln4464">	if (sizeNeeded &gt; size)</a>
<a name="ln4465">		return B_BUFFER_OVERFLOW;</a>
<a name="ln4466"> </a>
<a name="ln4467">	if (user_memcpy(buffer, info.Buffer(), sizeNeeded) != B_OK)</a>
<a name="ln4468">		return B_BAD_ADDRESS;</a>
<a name="ln4469"> </a>
<a name="ln4470">	return B_OK;</a>
<a name="ln4471">}</a>

</code></pre>
<div class="balloon" rel="988"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: next.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
