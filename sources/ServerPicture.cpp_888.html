
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ServerPicture.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2019, Haiku.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Marc Flerackers (mflerackers@androme.be)</a>
<a name="ln7"> *		Stefano Ceccherini (stefano.ceccherini@gmail.com)</a>
<a name="ln8"> *		Marcus Overhagen &lt;marcus@overhagen.de&gt;</a>
<a name="ln9"> *		Julian Harnath &lt;julian.harnath@rwth-aachen.de&gt;</a>
<a name="ln10"> *		Stephan AÃŸmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln11"> */</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;ServerPicture.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;new&gt;</a>
<a name="ln16">#include &lt;stdio.h&gt;</a>
<a name="ln17">#include &lt;stack&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;AlphaMask.h&quot;</a>
<a name="ln20">#include &quot;DrawingEngine.h&quot;</a>
<a name="ln21">#include &quot;DrawState.h&quot;</a>
<a name="ln22">#include &quot;FontManager.h&quot;</a>
<a name="ln23">#include &quot;Layer.h&quot;</a>
<a name="ln24">#include &quot;ServerApp.h&quot;</a>
<a name="ln25">#include &quot;ServerBitmap.h&quot;</a>
<a name="ln26">#include &quot;ServerFont.h&quot;</a>
<a name="ln27">#include &quot;ServerTokenSpace.h&quot;</a>
<a name="ln28">#include &quot;View.h&quot;</a>
<a name="ln29">#include &quot;Window.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;LinkReceiver.h&gt;</a>
<a name="ln32">#include &lt;OffsetFile.h&gt;</a>
<a name="ln33">#include &lt;ObjectListPrivate.h&gt;</a>
<a name="ln34">#include &lt;PicturePlayer.h&gt;</a>
<a name="ln35">#include &lt;PictureProtocol.h&gt;</a>
<a name="ln36">#include &lt;PortLink.h&gt;</a>
<a name="ln37">#include &lt;ServerProtocol.h&gt;</a>
<a name="ln38">#include &lt;ShapePrivate.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;Bitmap.h&gt;</a>
<a name="ln41">#include &lt;Debug.h&gt;</a>
<a name="ln42">#include &lt;List.h&gt;</a>
<a name="ln43">#include &lt;Shape.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">using std::stack;</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">class ShapePainter : public BShapeIterator {</a>
<a name="ln50">public:</a>
<a name="ln51">	ShapePainter(Canvas* canvas);</a>
<a name="ln52">	virtual ~ShapePainter();</a>
<a name="ln53"> </a>
<a name="ln54">	status_t Iterate(const BShape* shape);</a>
<a name="ln55"> </a>
<a name="ln56">	virtual status_t IterateMoveTo(BPoint* point);</a>
<a name="ln57">	virtual status_t IterateLineTo(int32 lineCount, BPoint* linePts);</a>
<a name="ln58">	virtual status_t IterateBezierTo(int32 bezierCount, BPoint* bezierPts);</a>
<a name="ln59">	virtual status_t IterateClose();</a>
<a name="ln60">	virtual status_t IterateArcTo(float&amp; rx, float&amp; ry,</a>
<a name="ln61">		float&amp; angle, bool largeArc, bool counterClockWise, BPoint&amp; point);</a>
<a name="ln62"> </a>
<a name="ln63">	void Draw(BRect frame, bool filled);</a>
<a name="ln64"> </a>
<a name="ln65">private:</a>
<a name="ln66">	Canvas*	fCanvas;</a>
<a name="ln67">	stack&lt;uint32&gt;	fOpStack;</a>
<a name="ln68">	stack&lt;BPoint&gt;	fPtStack;</a>
<a name="ln69">};</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">ShapePainter::ShapePainter(Canvas* canvas)</a>
<a name="ln73">	:</a>
<a name="ln74">	fCanvas(canvas)</a>
<a name="ln75">{</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">ShapePainter::~ShapePainter()</a>
<a name="ln80">{</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">status_t</a>
<a name="ln85">ShapePainter::Iterate(const BShape* shape)</a>
<a name="ln86">{</a>
<a name="ln87">	// this class doesn't modify the shape data</a>
<a name="ln88">	return BShapeIterator::Iterate(const_cast&lt;BShape*&gt;(shape));</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">status_t</a>
<a name="ln93">ShapePainter::IterateMoveTo(BPoint* point)</a>
<a name="ln94">{</a>
<a name="ln95">	try {</a>
<a name="ln96">		fOpStack.push(OP_MOVETO);</a>
<a name="ln97">		fPtStack.push(*point);</a>
<a name="ln98">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln99">		return B_NO_MEMORY;</a>
<a name="ln100">	}</a>
<a name="ln101"> </a>
<a name="ln102">	return B_OK;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">status_t</a>
<a name="ln107">ShapePainter::IterateLineTo(int32 lineCount, BPoint* linePts)</a>
<a name="ln108">{</a>
<a name="ln109">	try {</a>
<a name="ln110">		fOpStack.push(OP_LINETO | lineCount);</a>
<a name="ln111">		for (int32 i = 0; i &lt; lineCount; i++)</a>
<a name="ln112">			fPtStack.push(linePts[i]);</a>
<a name="ln113">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln114">		return B_NO_MEMORY;</a>
<a name="ln115">	}</a>
<a name="ln116"> </a>
<a name="ln117">	return B_OK;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120"> </a>
<a name="ln121">status_t</a>
<a name="ln122">ShapePainter::IterateBezierTo(int32 bezierCount, BPoint* bezierPts)</a>
<a name="ln123">{</a>
<a name="ln124">	bezierCount *= 3;</a>
<a name="ln125">	try {</a>
<a name="ln126">		fOpStack.push(OP_BEZIERTO | bezierCount);</a>
<a name="ln127">		for (int32 i = 0; i &lt; bezierCount; i++)</a>
<a name="ln128">			fPtStack.push(bezierPts[i]);</a>
<a name="ln129">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln130">		return B_NO_MEMORY;</a>
<a name="ln131">	}</a>
<a name="ln132"> </a>
<a name="ln133">	return B_OK;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">status_t</a>
<a name="ln138">ShapePainter::IterateArcTo(float&amp; rx, float&amp; ry,</a>
<a name="ln139">	float&amp; angle, bool largeArc, bool counterClockWise, BPoint&amp; point)</a>
<a name="ln140">{</a>
<a name="ln141">	uint32 op;</a>
<a name="ln142">	if (largeArc) {</a>
<a name="ln143">		if (counterClockWise)</a>
<a name="ln144">			op = OP_LARGE_ARC_TO_CCW;</a>
<a name="ln145">		else</a>
<a name="ln146">			op = OP_LARGE_ARC_TO_CW;</a>
<a name="ln147">	} else {</a>
<a name="ln148">		if (counterClockWise)</a>
<a name="ln149">			op = OP_SMALL_ARC_TO_CCW;</a>
<a name="ln150">		else</a>
<a name="ln151">			op = OP_SMALL_ARC_TO_CW;</a>
<a name="ln152">	}</a>
<a name="ln153"> </a>
<a name="ln154">	try {</a>
<a name="ln155">		fOpStack.push(op | 3);</a>
<a name="ln156">		fPtStack.push(BPoint(rx, ry));</a>
<a name="ln157">		fPtStack.push(BPoint(angle, 0));</a>
<a name="ln158">		fPtStack.push(point);</a>
<a name="ln159">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln160">		return B_NO_MEMORY;</a>
<a name="ln161">	}</a>
<a name="ln162"> </a>
<a name="ln163">	return B_OK;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">status_t</a>
<a name="ln168">ShapePainter::IterateClose()</a>
<a name="ln169">{</a>
<a name="ln170">	try {</a>
<a name="ln171">		fOpStack.push(OP_CLOSE);</a>
<a name="ln172">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln173">		return B_NO_MEMORY;</a>
<a name="ln174">	}</a>
<a name="ln175"> </a>
<a name="ln176">	return B_OK;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179"> </a>
<a name="ln180">void</a>
<a name="ln181">ShapePainter::Draw(BRect frame, bool filled)</a>
<a name="ln182">{</a>
<a name="ln183">	// We're going to draw the currently iterated shape.</a>
<a name="ln184">	// TODO: This can be more efficient by skipping the conversion.</a>
<a name="ln185">	int32 opCount = fOpStack.size();</a>
<a name="ln186">	int32 ptCount = fPtStack.size();</a>
<a name="ln187"> </a>
<a name="ln188">	if (opCount &gt; 0 &amp;&amp; ptCount &gt; 0) {</a>
<a name="ln189">		int32 i;</a>
<a name="ln190">		uint32* opList = new(std::nothrow) uint32[opCount];</a>
<a name="ln191">		if (opList == NULL)</a>
<a name="ln192">			return;</a>
<a name="ln193"> </a>
<a name="ln194">		BPoint* ptList = new(std::nothrow) BPoint[ptCount];</a>
<a name="ln195">		if (ptList == NULL) {</a>
<a name="ln196">			delete[] opList;</a>
<a name="ln197">			return;</a>
<a name="ln198">		}</a>
<a name="ln199"> </a>
<a name="ln200">		for (i = opCount - 1; i &gt;= 0; i--) {</a>
<a name="ln201">			opList[i] = fOpStack.top();</a>
<a name="ln202">			fOpStack.pop();</a>
<a name="ln203">		}</a>
<a name="ln204"> </a>
<a name="ln205">		for (i = ptCount - 1; i &gt;= 0; i--) {</a>
<a name="ln206">			ptList[i] = fPtStack.top();</a>
<a name="ln207">			fPtStack.pop();</a>
<a name="ln208">		}</a>
<a name="ln209"> </a>
<a name="ln210">		BPoint offset(fCanvas-&gt;CurrentState()-&gt;PenLocation());</a>
<a name="ln211">		fCanvas-&gt;PenToScreenTransform().Apply(&amp;offset);</a>
<a name="ln212">		fCanvas-&gt;GetDrawingEngine()-&gt;DrawShape(frame, opCount, opList,</a>
<a name="ln213">			ptCount, ptList, filled, offset, fCanvas-&gt;Scale());</a>
<a name="ln214"> </a>
<a name="ln215">		delete[] opList;</a>
<a name="ln216">		delete[] ptList;</a>
<a name="ln217">	}</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220"> </a>
<a name="ln221">// #pragma mark - drawing functions</a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224">static void</a>
<a name="ln225">get_polygon_frame(const BPoint* points, uint32 numPoints, BRect* _frame)</a>
<a name="ln226">{</a>
<a name="ln227">	ASSERT(numPoints &gt; 0);</a>
<a name="ln228"> </a>
<a name="ln229">	float left = points-&gt;x;</a>
<a name="ln230">	float top = points-&gt;y;</a>
<a name="ln231">	float right = left;</a>
<a name="ln232">	float bottom = top;</a>
<a name="ln233"> </a>
<a name="ln234">	points++;</a>
<a name="ln235">	numPoints--;</a>
<a name="ln236"> </a>
<a name="ln237">	while (numPoints--) {</a>
<a name="ln238">		if (points-&gt;x &lt; left)</a>
<a name="ln239">			left = points-&gt;x;</a>
<a name="ln240">		if (points-&gt;x &gt; right)</a>
<a name="ln241">			right = points-&gt;x;</a>
<a name="ln242">		if (points-&gt;y &lt; top)</a>
<a name="ln243">			top = points-&gt;y;</a>
<a name="ln244">		if (points-&gt;y &gt; bottom)</a>
<a name="ln245">			bottom = points-&gt;y;</a>
<a name="ln246">		points++;</a>
<a name="ln247">	}</a>
<a name="ln248"> </a>
<a name="ln249">	_frame-&gt;Set(left, top, right, bottom);</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252"> </a>
<a name="ln253">static void</a>
<a name="ln254">move_pen_by(void* _canvas, const BPoint&amp; delta)</a>
<a name="ln255">{</a>
<a name="ln256">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln257">	canvas-&gt;CurrentState()-&gt;SetPenLocation(</a>
<a name="ln258">		canvas-&gt;CurrentState()-&gt;PenLocation() + delta);</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">static void</a>
<a name="ln263">stroke_line(void* _canvas, const BPoint&amp; _start, const BPoint&amp; _end)</a>
<a name="ln264">{</a>
<a name="ln265">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln266">	BPoint start = _start;</a>
<a name="ln267">	BPoint end = _end;</a>
<a name="ln268"> </a>
<a name="ln269">	const SimpleTransform transform = canvas-&gt;PenToScreenTransform();</a>
<a name="ln270">	transform.Apply(&amp;start);</a>
<a name="ln271">	transform.Apply(&amp;end);</a>
<a name="ln272">	canvas-&gt;GetDrawingEngine()-&gt;StrokeLine(start, end);</a>
<a name="ln273"> </a>
<a name="ln274">	canvas-&gt;CurrentState()-&gt;SetPenLocation(_end);</a>
<a name="ln275">	// the DrawingEngine/Painter does not need to be updated, since this</a>
<a name="ln276">	// effects only the view-&gt;screen coord conversion, which is handled</a>
<a name="ln277">	// by the view only</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280"> </a>
<a name="ln281">static void</a>
<a name="ln282">draw_rect(void* _canvas, const BRect&amp; _rect, bool fill)</a>
<a name="ln283">{</a>
<a name="ln284">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln285">	BRect rect = _rect;</a>
<a name="ln286"> </a>
<a name="ln287">	canvas-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln288">	if (fill)</a>
<a name="ln289">		canvas-&gt;GetDrawingEngine()-&gt;FillRect(rect);</a>
<a name="ln290">	else</a>
<a name="ln291">		canvas-&gt;GetDrawingEngine()-&gt;StrokeRect(rect);</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294"> </a>
<a name="ln295">static void</a>
<a name="ln296">draw_round_rect(void* _canvas, const BRect&amp; _rect, const BPoint&amp; radii,</a>
<a name="ln297">	bool fill)</a>
<a name="ln298">{</a>
<a name="ln299">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln300">	BRect rect = _rect;</a>
<a name="ln301"> </a>
<a name="ln302">	canvas-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln303">	float scale = canvas-&gt;CurrentState()-&gt;CombinedScale();</a>
<a name="ln304">	canvas-&gt;GetDrawingEngine()-&gt;DrawRoundRect(rect, radii.x * scale,</a>
<a name="ln305">		radii.y * scale, fill);</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308"> </a>
<a name="ln309">static void</a>
<a name="ln310">draw_bezier(void* _canvas, size_t numPoints, const BPoint viewPoints[],</a>
<a name="ln311">	bool fill)</a>
<a name="ln312">{</a>
<a name="ln313">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln314"> </a>
<a name="ln315">	const size_t kSupportedPoints = 4;</a>
<a name="ln316">	if (numPoints != kSupportedPoints)</a>
<a name="ln317">		return;</a>
<a name="ln318"> </a>
<a name="ln319">	BPoint points[kSupportedPoints];</a>
<a name="ln320">	canvas-&gt;PenToScreenTransform().Apply(points, viewPoints, kSupportedPoints);</a>
<a name="ln321">	canvas-&gt;GetDrawingEngine()-&gt;DrawBezier(points, fill);</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324"> </a>
<a name="ln325">static void</a>
<a name="ln326">draw_arc(void* _canvas, const BPoint&amp; center, const BPoint&amp; radii,</a>
<a name="ln327">	float startTheta, float arcTheta, bool fill)</a>
<a name="ln328">{</a>
<a name="ln329">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln330"> </a>
<a name="ln331">	BRect rect(center.x - radii.x, center.y - radii.y,</a>
<a name="ln332">		center.x + radii.x - 1, center.y + radii.y - 1);</a>
<a name="ln333">	canvas-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln334">	canvas-&gt;GetDrawingEngine()-&gt;DrawArc(rect, startTheta, arcTheta, fill);</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">static void</a>
<a name="ln339">draw_ellipse(void* _canvas, const BRect&amp; _rect, bool fill)</a>
<a name="ln340">{</a>
<a name="ln341">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln342"> </a>
<a name="ln343">	BRect rect = _rect;</a>
<a name="ln344">	canvas-&gt;PenToScreenTransform().Apply(&amp;rect);</a>
<a name="ln345">	canvas-&gt;GetDrawingEngine()-&gt;DrawEllipse(rect, fill);</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">static void</a>
<a name="ln350">draw_polygon(void* _canvas, size_t numPoints, const BPoint viewPoints[],</a>
<a name="ln351">	bool isClosed, bool fill)</a>
<a name="ln352">{</a>
<a name="ln353">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln354"> </a>
<a name="ln355">	if (numPoints == 0)</a>
<a name="ln356">		return;</a>
<a name="ln357"> </a>
<a name="ln358">	const size_t kMaxStackCount = 200;</a>
<a name="ln359">	char stackData[kMaxStackCount * sizeof(BPoint)];</a>
<a name="ln360">	BPoint* points = (BPoint*)stackData;</a>
<a name="ln361">	if (numPoints &gt; kMaxStackCount) {</a>
<a name="ln362">		points = (BPoint*)malloc(numPoints * sizeof(BPoint));</a>
<a name="ln363">		if (points == NULL)</a>
<a name="ln364">			return;</a>
<a name="ln365">	}</a>
<a name="ln366"> </a>
<a name="ln367">	canvas-&gt;PenToScreenTransform().Apply(points, viewPoints, numPoints);</a>
<a name="ln368"> </a>
<a name="ln369">	BRect polyFrame;</a>
<a name="ln370">	get_polygon_frame(points, numPoints, &amp;polyFrame);</a>
<a name="ln371"> </a>
<a name="ln372">	canvas-&gt;GetDrawingEngine()-&gt;DrawPolygon(points, numPoints, polyFrame,</a>
<a name="ln373">		fill, isClosed &amp;&amp; numPoints &gt; 2);</a>
<a name="ln374"> </a>
<a name="ln375">	if (numPoints &gt; kMaxStackCount)</a>
<a name="ln376">		free(points);</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379"> </a>
<a name="ln380">static void</a>
<a name="ln381">draw_shape(void* _canvas, const BShape&amp; shape, bool fill)</a>
<a name="ln382">{</a>
<a name="ln383">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln384">	ShapePainter drawShape(canvas);</a>
<a name="ln385"> </a>
<a name="ln386">	drawShape.Iterate(&amp;shape);</a>
<a name="ln387">	drawShape.Draw(shape.Bounds(), fill);</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">static void</a>
<a name="ln392">draw_string(void* _canvas, const char* string, size_t length, float deltaSpace,</a>
<a name="ln393">	float deltaNonSpace)</a>
<a name="ln394">{</a>
<a name="ln395">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln396"> </a>
<a name="ln397">	// NOTE: the picture data was recorded with a &quot;set pen location&quot;</a>
<a name="ln398">	// command inserted before the &quot;draw string&quot; command, so we can</a>
<a name="ln399">	// use PenLocation()</a>
<a name="ln400">	BPoint location = canvas-&gt;CurrentState()-&gt;PenLocation();</a>
<a name="ln401"> </a>
<a name="ln402">	escapement_delta delta = { deltaSpace, deltaNonSpace };</a>
<a name="ln403">	canvas-&gt;PenToScreenTransform().Apply(&amp;location);</a>
<a name="ln404">	location = canvas-&gt;GetDrawingEngine()-&gt;DrawString(string, length,</a>
<a name="ln405">		location, &amp;delta);</a>
<a name="ln406"> </a>
<a name="ln407">	canvas-&gt;PenToScreenTransform().Apply(&amp;location);</a>
<a name="ln408">	canvas-&gt;CurrentState()-&gt;SetPenLocation(location);</a>
<a name="ln409">	// the DrawingEngine/Painter does not need to be updated, since this</a>
<a name="ln410">	// effects only the view-&gt;screen coord conversion, which is handled</a>
<a name="ln411">	// by the view only</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">static void</a>
<a name="ln416">draw_string_locations(void* _canvas, const char* string, size_t length,</a>
<a name="ln417">	const BPoint* locations, size_t locationsCount)</a>
<a name="ln418">{</a>
<a name="ln419">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln420"> </a>
<a name="ln421">	BPoint location = canvas-&gt;GetDrawingEngine()-&gt;DrawString(string, length,</a>
<a name="ln422">		locations);</a>
<a name="ln423"> </a>
<a name="ln424">	canvas-&gt;PenToScreenTransform().Apply(&amp;location);</a>
<a name="ln425">	canvas-&gt;CurrentState()-&gt;SetPenLocation(location);</a>
<a name="ln426">	// the DrawingEngine/Painter does not need to be updated, since this</a>
<a name="ln427">	// effects only the view-&gt;screen coord conversion, which is handled</a>
<a name="ln428">	// by the view only</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431"> </a>
<a name="ln432">static void</a>
<a name="ln433">draw_pixels(void* _canvas, const BRect&amp; src, const BRect&amp; _dest, uint32 width,</a>
<a name="ln434">	uint32 height, size_t bytesPerRow, color_space pixelFormat, uint32 options,</a>
<a name="ln435">	const void* data, size_t length)</a>
<a name="ln436">{</a>
<a name="ln437">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln438"> </a>
<a name="ln439">	UtilityBitmap bitmap(BRect(0, 0, width - 1, height - 1),</a>
<a name="ln440">		(color_space)pixelFormat, 0, bytesPerRow);</a>
<a name="ln441"> </a>
<a name="ln442">	if (!bitmap.IsValid())</a>
<a name="ln443">		return;</a>
<a name="ln444"> </a>
<a name="ln445">	memcpy(bitmap.Bits(), data, std::min(height * bytesPerRow, length));</a>
<a name="ln446"> </a>
<a name="ln447">	BRect dest = _dest;</a>
<a name="ln448">	canvas-&gt;PenToScreenTransform().Apply(&amp;dest);</a>
<a name="ln449">	canvas-&gt;GetDrawingEngine()-&gt;DrawBitmap(&amp;bitmap, src, dest, options);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452"> </a>
<a name="ln453">static void</a>
<a name="ln454">draw_picture(void* _canvas, const BPoint&amp; where, int32 token)</a>
<a name="ln455">{</a>
<a name="ln456">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln457"> </a>
<a name="ln458">	ServerPicture* picture = canvas-&gt;GetPicture(token);</a>
<a name="ln459">	if (picture != NULL) {</a>
<a name="ln460">		canvas-&gt;PushState();</a>
<a name="ln461">		canvas-&gt;SetDrawingOrigin(where);</a>
<a name="ln462"> </a>
<a name="ln463">		canvas-&gt;PushState();</a>
<a name="ln464">		picture-&gt;Play(canvas);</a>
<a name="ln465">		canvas-&gt;PopState();</a>
<a name="ln466"> </a>
<a name="ln467">		canvas-&gt;PopState();</a>
<a name="ln468">		picture-&gt;ReleaseReference();</a>
<a name="ln469">	}</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472"> </a>
<a name="ln473">static void</a>
<a name="ln474">set_clipping_rects(void* _canvas, size_t numRects, const BRect rects[])</a>
<a name="ln475">{</a>
<a name="ln476">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln477"> </a>
<a name="ln478">	if (numRects == 0)</a>
<a name="ln479">		canvas-&gt;SetUserClipping(NULL);</a>
<a name="ln480">	else {</a>
<a name="ln481">		// TODO: This might be too slow, we should copy the rects</a>
<a name="ln482">		// directly to BRegion's internal data</a>
<a name="ln483">		BRegion region;</a>
<a name="ln484">		for (uint32 c = 0; c &lt; numRects; c++)</a>
<a name="ln485">			region.Include(rects[c]);</a>
<a name="ln486">		canvas-&gt;SetUserClipping(&amp;region);</a>
<a name="ln487">	}</a>
<a name="ln488">	canvas-&gt;UpdateCurrentDrawingRegion();</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491"> </a>
<a name="ln492">static void</a>
<a name="ln493">clip_to_picture(void* _canvas, int32 pictureToken, const BPoint&amp; where,</a>
<a name="ln494">	bool clipToInverse)</a>
<a name="ln495">{</a>
<a name="ln496">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln497"> </a>
<a name="ln498">	ServerPicture* picture = canvas-&gt;GetPicture(pictureToken);</a>
<a name="ln499">	if (picture == NULL)</a>
<a name="ln500">		return;</a>
<a name="ln501">	AlphaMask* mask = new(std::nothrow) PictureAlphaMask(canvas-&gt;GetAlphaMask(),</a>
<a name="ln502">		picture, *canvas-&gt;CurrentState(), where, clipToInverse);</a>
<a name="ln503">	canvas-&gt;SetAlphaMask(mask);</a>
<a name="ln504">	canvas-&gt;CurrentState()-&gt;GetAlphaMask()-&gt;SetCanvasGeometry(BPoint(0, 0),</a>
<a name="ln505">		canvas-&gt;Bounds());</a>
<a name="ln506">	canvas-&gt;ResyncDrawState();</a>
<a name="ln507">	if (mask != NULL)</a>
<a name="ln508">		mask-&gt;ReleaseReference();</a>
<a name="ln509"> </a>
<a name="ln510">	picture-&gt;ReleaseReference();</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513"> </a>
<a name="ln514">static void</a>
<a name="ln515">push_state(void* _canvas)</a>
<a name="ln516">{</a>
<a name="ln517">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln518">	canvas-&gt;PushState();</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">static void</a>
<a name="ln523">pop_state(void* _canvas)</a>
<a name="ln524">{</a>
<a name="ln525">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln526">	canvas-&gt;PopState();</a>
<a name="ln527"> </a>
<a name="ln528">	BPoint p(0, 0);</a>
<a name="ln529">	canvas-&gt;PenToScreenTransform().Apply(&amp;p);</a>
<a name="ln530">	canvas-&gt;GetDrawingEngine()-&gt;SetDrawState(canvas-&gt;CurrentState(),</a>
<a name="ln531">		(int32)p.x, (int32)p.y);</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534"> </a>
<a name="ln535">// TODO: Be smart and actually take advantage of these methods:</a>
<a name="ln536">// only apply state changes when they are called</a>
<a name="ln537">static void</a>
<a name="ln538">enter_state_change(void* _canvas)</a>
<a name="ln539">{</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">static void</a>
<a name="ln544">exit_state_change(void* _canvas)</a>
<a name="ln545">{</a>
<a name="ln546">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln547">	canvas-&gt;ResyncDrawState();</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551">static void</a>
<a name="ln552">enter_font_state(void* _canvas)</a>
<a name="ln553">{</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556"> </a>
<a name="ln557">static void</a>
<a name="ln558">exit_font_state(void* _canvas)</a>
<a name="ln559">{</a>
<a name="ln560">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln561">	canvas-&gt;GetDrawingEngine()-&gt;SetFont(canvas-&gt;CurrentState()-&gt;Font());</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">static void</a>
<a name="ln566">set_origin(void* _canvas, const BPoint&amp; pt)</a>
<a name="ln567">{</a>
<a name="ln568">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln569">	canvas-&gt;CurrentState()-&gt;SetOrigin(pt);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">static void</a>
<a name="ln574">set_pen_location(void* _canvas, const BPoint&amp; pt)</a>
<a name="ln575">{</a>
<a name="ln576">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln577">	canvas-&gt;CurrentState()-&gt;SetPenLocation(pt);</a>
<a name="ln578">	// the DrawingEngine/Painter does not need to be updated, since this</a>
<a name="ln579">	// effects only the view-&gt;screen coord conversion, which is handled</a>
<a name="ln580">	// by the view only</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">static void</a>
<a name="ln585">set_drawing_mode(void* _canvas, drawing_mode mode)</a>
<a name="ln586">{</a>
<a name="ln587">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln588">	if (canvas-&gt;CurrentState()-&gt;SetDrawingMode(mode))</a>
<a name="ln589">		canvas-&gt;GetDrawingEngine()-&gt;SetDrawingMode(mode);</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592"> </a>
<a name="ln593">static void</a>
<a name="ln594">set_line_mode(void* _canvas, cap_mode capMode, join_mode joinMode,</a>
<a name="ln595">	float miterLimit)</a>
<a name="ln596">{</a>
<a name="ln597">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln598">	DrawState* state = canvas-&gt;CurrentState();</a>
<a name="ln599">	state-&gt;SetLineCapMode(capMode);</a>
<a name="ln600">	state-&gt;SetLineJoinMode(joinMode);</a>
<a name="ln601">	state-&gt;SetMiterLimit(miterLimit);</a>
<a name="ln602">	canvas-&gt;GetDrawingEngine()-&gt;SetStrokeMode(capMode, joinMode, miterLimit);</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606">static void</a>
<a name="ln607">set_pen_size(void* _canvas, float size)</a>
<a name="ln608">{</a>
<a name="ln609">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln610">	canvas-&gt;CurrentState()-&gt;SetPenSize(size);</a>
<a name="ln611">	canvas-&gt;GetDrawingEngine()-&gt;SetPenSize(</a>
<a name="ln612">		canvas-&gt;CurrentState()-&gt;PenSize());</a>
<a name="ln613">		// DrawState::PenSize() returns the scaled pen size, so we</a>
<a name="ln614">		// need to use that value to set the drawing engine pen size.</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617"> </a>
<a name="ln618">static void</a>
<a name="ln619">set_fore_color(void* _canvas, const rgb_color&amp; color)</a>
<a name="ln620">{</a>
<a name="ln621">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln622">	canvas-&gt;CurrentState()-&gt;SetHighColor(color);</a>
<a name="ln623">	canvas-&gt;GetDrawingEngine()-&gt;SetHighColor(color);</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626"> </a>
<a name="ln627">static void</a>
<a name="ln628">set_back_color(void* _canvas, const rgb_color&amp; color)</a>
<a name="ln629">{</a>
<a name="ln630">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln631">	canvas-&gt;CurrentState()-&gt;SetLowColor(color);</a>
<a name="ln632">	canvas-&gt;GetDrawingEngine()-&gt;SetLowColor(color);</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635"> </a>
<a name="ln636">static void</a>
<a name="ln637">set_stipple_pattern(void* _canvas, const pattern&amp; pattern)</a>
<a name="ln638">{</a>
<a name="ln639">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln640">	canvas-&gt;CurrentState()-&gt;SetPattern(Pattern(pattern));</a>
<a name="ln641">	canvas-&gt;GetDrawingEngine()-&gt;SetPattern(pattern);</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644"> </a>
<a name="ln645">static void</a>
<a name="ln646">set_scale(void* _canvas, float scale)</a>
<a name="ln647">{</a>
<a name="ln648">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln649">	canvas-&gt;CurrentState()-&gt;SetScale(scale);</a>
<a name="ln650">	canvas-&gt;ResyncDrawState();</a>
<a name="ln651"> </a>
<a name="ln652">	// Update the drawing engine draw state, since some stuff</a>
<a name="ln653">	// (for example the pen size) needs to be recalculated.</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656"> </a>
<a name="ln657">static void</a>
<a name="ln658">set_font_family(void* _canvas, const char* _family, size_t length)</a>
<a name="ln659">{</a>
<a name="ln660">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln661">	BString family(_family, length);</a>
<a name="ln662"> </a>
<a name="ln663">	FontStyle* fontStyle = gFontManager-&gt;GetStyleByIndex(family, 0);</a>
<a name="ln664">	ServerFont font;</a>
<a name="ln665">	font.SetStyle(fontStyle);</a>
<a name="ln666">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_FAMILY_AND_STYLE);</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669"> </a>
<a name="ln670">static void</a>
<a name="ln671">set_font_style(void* _canvas, const char* _style, size_t length)</a>
<a name="ln672">{</a>
<a name="ln673">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln674">	BString style(_style, length);</a>
<a name="ln675"> </a>
<a name="ln676">	ServerFont font(canvas-&gt;CurrentState()-&gt;Font());</a>
<a name="ln677"> </a>
<a name="ln678">	FontStyle* fontStyle = gFontManager-&gt;GetStyle(font.Family(), style);</a>
<a name="ln679"> </a>
<a name="ln680">	font.SetStyle(fontStyle);</a>
<a name="ln681">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_FAMILY_AND_STYLE);</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684"> </a>
<a name="ln685">static void</a>
<a name="ln686">set_font_spacing(void* _canvas, uint8 spacing)</a>
<a name="ln687">{</a>
<a name="ln688">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln689">	ServerFont font;</a>
<a name="ln690">	font.SetSpacing(spacing);</a>
<a name="ln691">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_SPACING);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694"> </a>
<a name="ln695">static void</a>
<a name="ln696">set_font_size(void* _canvas, float size)</a>
<a name="ln697">{</a>
<a name="ln698">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln699">	ServerFont font;</a>
<a name="ln700">	font.SetSize(size);</a>
<a name="ln701">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_SIZE);</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">static void</a>
<a name="ln706">set_font_rotation(void* _canvas, float rotation)</a>
<a name="ln707">{</a>
<a name="ln708">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln709">	ServerFont font;</a>
<a name="ln710">	font.SetRotation(rotation);</a>
<a name="ln711">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_ROTATION);</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714"> </a>
<a name="ln715">static void</a>
<a name="ln716">set_font_encoding(void* _canvas, uint8 encoding)</a>
<a name="ln717">{</a>
<a name="ln718">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln719">	ServerFont font;</a>
<a name="ln720">	font.SetEncoding(encoding);</a>
<a name="ln721">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_ENCODING);</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724"> </a>
<a name="ln725">static void</a>
<a name="ln726">set_font_flags(void* _canvas, uint32 flags)</a>
<a name="ln727">{</a>
<a name="ln728">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln729">	ServerFont font;</a>
<a name="ln730">	font.SetFlags(flags);</a>
<a name="ln731">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_FLAGS);</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734"> </a>
<a name="ln735">static void</a>
<a name="ln736">set_font_shear(void* _canvas, float shear)</a>
<a name="ln737">{</a>
<a name="ln738">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln739">	ServerFont font;</a>
<a name="ln740">	font.SetShear(shear);</a>
<a name="ln741">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_SHEAR);</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744"> </a>
<a name="ln745">static void</a>
<a name="ln746">set_font_face(void* _canvas, uint16 face)</a>
<a name="ln747">{</a>
<a name="ln748">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln749">	ServerFont font;</a>
<a name="ln750">	font.SetFace(face);</a>
<a name="ln751">	canvas-&gt;CurrentState()-&gt;SetFont(font, B_FONT_FACE);</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">static void</a>
<a name="ln756">set_blending_mode(void* _canvas, source_alpha alphaSrcMode,</a>
<a name="ln757">	alpha_function alphaFncMode)</a>
<a name="ln758">{</a>
<a name="ln759">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln760">	canvas-&gt;CurrentState()-&gt;SetBlendingMode(alphaSrcMode, alphaFncMode);</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763"> </a>
<a name="ln764">static void</a>
<a name="ln765">set_transform(void* _canvas, const BAffineTransform&amp; transform)</a>
<a name="ln766">{</a>
<a name="ln767">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln768">	canvas-&gt;CurrentState()-&gt;SetTransform(transform);</a>
<a name="ln769">	canvas-&gt;GetDrawingEngine()-&gt;SetTransform(transform);</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773">static void</a>
<a name="ln774">translate_by(void* _canvas, double x, double y)</a>
<a name="ln775">{</a>
<a name="ln776">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln777">	BAffineTransform transform = canvas-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln778">	transform.PreTranslateBy(x, y);</a>
<a name="ln779">	canvas-&gt;CurrentState()-&gt;SetTransform(transform);</a>
<a name="ln780">	canvas-&gt;GetDrawingEngine()-&gt;SetTransform(transform);</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784">static void</a>
<a name="ln785">scale_by(void* _canvas, double x, double y)</a>
<a name="ln786">{</a>
<a name="ln787">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln788">	BAffineTransform transform = canvas-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln789">	transform.PreScaleBy(x, y);</a>
<a name="ln790">	canvas-&gt;CurrentState()-&gt;SetTransform(transform);</a>
<a name="ln791">	canvas-&gt;GetDrawingEngine()-&gt;SetTransform(transform);</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">static void</a>
<a name="ln796">rotate_by(void* _canvas, double angleRadians)</a>
<a name="ln797">{</a>
<a name="ln798">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln799">	BAffineTransform transform = canvas-&gt;CurrentState()-&gt;Transform();</a>
<a name="ln800">	transform.PreRotateBy(angleRadians);</a>
<a name="ln801">	canvas-&gt;CurrentState()-&gt;SetTransform(transform);</a>
<a name="ln802">	canvas-&gt;GetDrawingEngine()-&gt;SetTransform(transform);</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806">static void</a>
<a name="ln807">blend_layer(void* _canvas, Layer* layer)</a>
<a name="ln808">{</a>
<a name="ln809">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln810">	canvas-&gt;BlendLayer(layer);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">static void</a>
<a name="ln815">clip_to_rect(void* _canvas, const BRect&amp; rect, bool inverse)</a>
<a name="ln816">{</a>
<a name="ln817">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln818">	bool needDrawStateUpdate = canvas-&gt;ClipToRect(rect, inverse);</a>
<a name="ln819">	if (needDrawStateUpdate) {</a>
<a name="ln820">		canvas-&gt;CurrentState()-&gt;GetAlphaMask()-&gt;SetCanvasGeometry(BPoint(0, 0),</a>
<a name="ln821">			canvas-&gt;Bounds());</a>
<a name="ln822">		canvas-&gt;ResyncDrawState();</a>
<a name="ln823">	}</a>
<a name="ln824">	canvas-&gt;UpdateCurrentDrawingRegion();</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827"> </a>
<a name="ln828">static void</a>
<a name="ln829">clip_to_shape(void* _canvas, int32 opCount, const uint32 opList[],</a>
<a name="ln830">	int32 ptCount, const BPoint ptList[], bool inverse)</a>
<a name="ln831">{</a>
<a name="ln832">	Canvas* const canvas = reinterpret_cast&lt;Canvas*&gt;(_canvas);</a>
<a name="ln833">	shape_data shapeData;</a>
<a name="ln834"> </a>
<a name="ln835">	// TODO: avoid copies</a>
<a name="ln836">	shapeData.opList = (uint32*)malloc(opCount * sizeof(uint32));</a>
<a name="ln837">	memcpy(shapeData.opList, opList, opCount * sizeof(uint32));</a>
<a name="ln838">	shapeData.ptList = (BPoint*)malloc(ptCount * sizeof(BPoint));</a>
<a name="ln839">	memcpy((void*)shapeData.ptList, ptList, ptCount * sizeof(BPoint));</a>
<a name="ln840"> </a>
<a name="ln841">	shapeData.opCount = opCount;</a>
<a name="ln842">	shapeData.opSize = opCount * sizeof(uint32);</a>
<a name="ln843">	shapeData.ptCount = ptCount;</a>
<a name="ln844">	shapeData.ptSize = ptCount * sizeof(BPoint);</a>
<a name="ln845"> </a>
<a name="ln846">	canvas-&gt;ClipToShape(&amp;shapeData, inverse);</a>
<a name="ln847">	canvas-&gt;CurrentState()-&gt;GetAlphaMask()-&gt;SetCanvasGeometry(BPoint(0, 0),</a>
<a name="ln848">		canvas-&gt;Bounds());</a>
<a name="ln849">	canvas-&gt;ResyncDrawState();</a>
<a name="ln850"> </a>
<a name="ln851">	free(shapeData.opList);</a>
<a name="ln852">	free(shapeData.ptList);</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855"> </a>
<a name="ln856">static const BPrivate::picture_player_callbacks kPicturePlayerCallbacks = {</a>
<a name="ln857">	move_pen_by,</a>
<a name="ln858">	stroke_line,</a>
<a name="ln859">	draw_rect,</a>
<a name="ln860">	draw_round_rect,</a>
<a name="ln861">	draw_bezier,</a>
<a name="ln862">	draw_arc,</a>
<a name="ln863">	draw_ellipse,</a>
<a name="ln864">	draw_polygon,</a>
<a name="ln865">	draw_shape,</a>
<a name="ln866">	draw_string,</a>
<a name="ln867">	draw_pixels,</a>
<a name="ln868">	draw_picture,</a>
<a name="ln869">	set_clipping_rects,</a>
<a name="ln870">	clip_to_picture,</a>
<a name="ln871">	push_state,</a>
<a name="ln872">	pop_state,</a>
<a name="ln873">	enter_state_change,</a>
<a name="ln874">	exit_state_change,</a>
<a name="ln875">	enter_font_state,</a>
<a name="ln876">	exit_font_state,</a>
<a name="ln877">	set_origin,</a>
<a name="ln878">	set_pen_location,</a>
<a name="ln879">	set_drawing_mode,</a>
<a name="ln880">	set_line_mode,</a>
<a name="ln881">	set_pen_size,</a>
<a name="ln882">	set_fore_color,</a>
<a name="ln883">	set_back_color,</a>
<a name="ln884">	set_stipple_pattern,</a>
<a name="ln885">	set_scale,</a>
<a name="ln886">	set_font_family,</a>
<a name="ln887">	set_font_style,</a>
<a name="ln888">	set_font_spacing,</a>
<a name="ln889">	set_font_size,</a>
<a name="ln890">	set_font_rotation,</a>
<a name="ln891">	set_font_encoding,</a>
<a name="ln892">	set_font_flags,</a>
<a name="ln893">	set_font_shear,</a>
<a name="ln894">	set_font_face,</a>
<a name="ln895">	set_blending_mode,</a>
<a name="ln896">	set_transform,</a>
<a name="ln897">	translate_by,</a>
<a name="ln898">	scale_by,</a>
<a name="ln899">	rotate_by,</a>
<a name="ln900">	blend_layer,</a>
<a name="ln901">	clip_to_rect,</a>
<a name="ln902">	clip_to_shape,</a>
<a name="ln903">	draw_string_locations</a>
<a name="ln904">};</a>
<a name="ln905"> </a>
<a name="ln906"> </a>
<a name="ln907">// #pragma mark - ServerPicture</a>
<a name="ln908"> </a>
<a name="ln909"> </a>
<a name="ln910">ServerPicture::ServerPicture()</a>
<a name="ln911">	:</a>
<a name="ln912">	fFile(NULL),</a>
<a name="ln913">	fPictures(NULL),</a>
<a name="ln914">	fPushed(NULL),</a>
<a name="ln915">	fOwner(NULL)</a>
<a name="ln916">{</a>
<a name="ln917">	fToken = gTokenSpace.NewToken(kPictureToken, this);</a>
<a name="ln918">	fData = new(std::nothrow) BMallocIO();</a>
<a name="ln919"> </a>
<a name="ln920">	PictureDataWriter::SetTo(fData);</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923"> </a>
<a name="ln924">ServerPicture::ServerPicture(const ServerPicture&amp; picture)</a>
<a name="ln925">	:</a>
<a name="ln926">	fFile(NULL),</a>
<a name="ln927">	fData(NULL),</a>
<a name="ln928">	fPictures(NULL),</a>
<a name="ln929">	fPushed(NULL),</a>
<a name="ln930">	fOwner(NULL)</a>
<a name="ln931">{</a>
<a name="ln932">	fToken = gTokenSpace.NewToken(kPictureToken, this);</a>
<a name="ln933"> </a>
<a name="ln934">	BMallocIO* mallocIO = new(std::nothrow) BMallocIO();</a>
<a name="ln935">	if (mallocIO == NULL)</a>
<a name="ln936">		return;</a>
<a name="ln937"> </a>
<a name="ln938">	fData = mallocIO;</a>
<a name="ln939"> </a>
<a name="ln940">	const off_t size = picture.DataLength();</a>
<a name="ln941">	if (mallocIO-&gt;SetSize(size) &lt; B_OK)</a>
<a name="ln942">		return;</a>
<a name="ln943"> </a>
<a name="ln944">	picture.fData-&gt;ReadAt(0, const_cast&lt;void*&gt;(mallocIO-&gt;Buffer()),</a>
<a name="ln945">		size);</a>
<a name="ln946"> </a>
<a name="ln947">	PictureDataWriter::SetTo(fData);</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950"> </a>
<a name="ln951">ServerPicture::ServerPicture(const char* fileName, int32 offset)</a>
<a name="ln952">	:</a>
<a name="ln953">	fFile(NULL),</a>
<a name="ln954">	fData(NULL),</a>
<a name="ln955">	fPictures(NULL),</a>
<a name="ln956">	fPushed(NULL),</a>
<a name="ln957">	fOwner(NULL)</a>
<a name="ln958">{</a>
<a name="ln959">	fToken = gTokenSpace.NewToken(kPictureToken, this);</a>
<a name="ln960"> </a>
<a name="ln961">	fFile = new(std::nothrow) BFile(fileName, B_READ_WRITE);</a>
<a name="ln962">	if (fFile == NULL)</a>
<a name="ln963">		return;</a>
<a name="ln964"> </a>
<a name="ln965">	BPrivate::Storage::OffsetFile* offsetFile</a>
<a name="ln966">		= new(std::nothrow) BPrivate::Storage::OffsetFile(fFile, offset);</a>
<a name="ln967">	if (offsetFile == NULL || offsetFile-&gt;InitCheck() != B_OK) {</a>
<a name="ln968">		delete offsetFile;</a>
<a name="ln969">		return;</a>
<a name="ln970">	}</a>
<a name="ln971"> </a>
<a name="ln972">	fData = offsetFile;</a>
<a name="ln973"> </a>
<a name="ln974">	PictureDataWriter::SetTo(fData);</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977"> </a>
<a name="ln978">ServerPicture::~ServerPicture()</a>
<a name="ln979">{</a>
<a name="ln980">	ASSERT(fOwner == NULL);</a>
<a name="ln981"> </a>
<a name="ln982">	delete fData;</a>
<a name="ln983">	delete fFile;</a>
<a name="ln984">	gTokenSpace.RemoveToken(fToken);</a>
<a name="ln985"> </a>
<a name="ln986">	if (fPictures != NULL) {</a>
<a name="ln987">		for (int32 i = fPictures-&gt;CountItems(); i-- &gt; 0;) {</a>
<a name="ln988">			ServerPicture* picture = fPictures-&gt;ItemAt(i);</a>
<a name="ln989">			picture-&gt;SetOwner(NULL);</a>
<a name="ln990">			picture-&gt;ReleaseReference();</a>
<a name="ln991">		}</a>
<a name="ln992"> </a>
<a name="ln993">		delete fPictures;</a>
<a name="ln994">	}</a>
<a name="ln995"> </a>
<a name="ln996">	if (fPushed != NULL) {</a>
<a name="ln997">		fPushed-&gt;SetOwner(NULL);</a>
<a name="ln998">		fPushed-&gt;ReleaseReference();</a>
<a name="ln999">	}</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002"> </a>
<a name="ln1003">bool</a>
<a name="ln1004">ServerPicture::SetOwner(ServerApp* owner)</a>
<a name="ln1005">{</a>
<a name="ln1006">	if (owner == fOwner)</a>
<a name="ln1007">		return true;</a>
<a name="ln1008"> </a>
<a name="ln1009">	// Acquire an extra reference, since calling RemovePicture()</a>
<a name="ln1010">	// May remove the last reference and then we will self-destruct right then.</a>
<a name="ln1011">	// Setting fOwner to NULL would access free'd memory. If owner is another</a>
<a name="ln1012">	// ServerApp, it's expected to already have a reference of course.</a>
<a name="ln1013">	BReference&lt;ServerPicture&gt; _(this);</a>
<a name="ln1014"> </a>
<a name="ln1015">	if (fOwner != NULL)</a>
<a name="ln1016">		fOwner-&gt;RemovePicture(this);</a>
<a name="ln1017"> </a>
<a name="ln1018">	fOwner = NULL;</a>
<a name="ln1019">	if (owner == NULL)</a>
<a name="ln1020">		return true;</a>
<a name="ln1021"> </a>
<a name="ln1022">	if (!owner-&gt;AddPicture(this))</a>
<a name="ln1023">		return false;</a>
<a name="ln1024"> </a>
<a name="ln1025">	fOwner = owner;</a>
<a name="ln1026">	return true;</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029"> </a>
<a name="ln1030">void</a>
<a name="ln1031">ServerPicture::EnterStateChange()</a>
<a name="ln1032">{</a>
<a name="ln1033">	BeginOp(B_PIC_ENTER_STATE_CHANGE);</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">void</a>
<a name="ln1038">ServerPicture::ExitStateChange()</a>
<a name="ln1039">{</a>
<a name="ln1040">	EndOp();</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043"> </a>
<a name="ln1044">void</a>
<a name="ln1045">ServerPicture::SyncState(Canvas* canvas)</a>
<a name="ln1046">{</a>
<a name="ln1047">	// TODO: Finish this</a>
<a name="ln1048">	EnterStateChange();</a>
<a name="ln1049"> </a>
<a name="ln1050">	WriteSetOrigin(canvas-&gt;CurrentState()-&gt;Origin());</a>
<a name="ln1051">	WriteSetPenLocation(canvas-&gt;CurrentState()-&gt;PenLocation());</a>
<a name="ln1052">	WriteSetPenSize(canvas-&gt;CurrentState()-&gt;UnscaledPenSize());</a>
<a name="ln1053">	WriteSetScale(canvas-&gt;CurrentState()-&gt;Scale());</a>
<a name="ln1054">	WriteSetLineMode(canvas-&gt;CurrentState()-&gt;LineCapMode(),</a>
<a name="ln1055">		canvas-&gt;CurrentState()-&gt;LineJoinMode(),</a>
<a name="ln1056">		canvas-&gt;CurrentState()-&gt;MiterLimit());</a>
<a name="ln1057">	//WriteSetPattern(*canvas-&gt;CurrentState()-&gt;GetPattern().GetInt8());</a>
<a name="ln1058">	WriteSetDrawingMode(canvas-&gt;CurrentState()-&gt;GetDrawingMode());</a>
<a name="ln1059"> </a>
<a name="ln1060">	WriteSetHighColor(canvas-&gt;CurrentState()-&gt;HighColor());</a>
<a name="ln1061">	WriteSetLowColor(canvas-&gt;CurrentState()-&gt;LowColor());</a>
<a name="ln1062"> </a>
<a name="ln1063">	ExitStateChange();</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066"> </a>
<a name="ln1067">void</a>
<a name="ln1068">ServerPicture::WriteFontState(const ServerFont&amp; font, uint16 mask)</a>
<a name="ln1069">{</a>
<a name="ln1070">	BeginOp(B_PIC_ENTER_FONT_STATE);</a>
<a name="ln1071"> </a>
<a name="ln1072">	if (mask &amp; B_FONT_FAMILY_AND_STYLE) {</a>
<a name="ln1073">		WriteSetFontFamily(font.Family());</a>
<a name="ln1074">		WriteSetFontStyle(font.Style());</a>
<a name="ln1075">	}</a>
<a name="ln1076"> </a>
<a name="ln1077">	if (mask &amp; B_FONT_SIZE) {</a>
<a name="ln1078">		WriteSetFontSize(font.Size());</a>
<a name="ln1079">	}</a>
<a name="ln1080"> </a>
<a name="ln1081">	if (mask &amp; B_FONT_SHEAR) {</a>
<a name="ln1082">		WriteSetFontShear(font.Shear());</a>
<a name="ln1083">	}</a>
<a name="ln1084"> </a>
<a name="ln1085">	if (mask &amp; B_FONT_ROTATION) {</a>
<a name="ln1086">		WriteSetFontRotation(font.Rotation());</a>
<a name="ln1087">	}</a>
<a name="ln1088"> </a>
<a name="ln1089">	if (mask &amp; B_FONT_FALSE_BOLD_WIDTH) {</a>
<a name="ln1090">		// TODO: Implement</a>
<a name="ln1091">//		WriteSetFalseBoldWidth(font.FalseBoldWidth());</a>
<a name="ln1092">	}</a>
<a name="ln1093"> </a>
<a name="ln1094">	if (mask &amp; B_FONT_SPACING) {</a>
<a name="ln1095">		WriteSetFontSpacing(font.Spacing());</a>
<a name="ln1096">	}</a>
<a name="ln1097"> </a>
<a name="ln1098">	if (mask &amp; B_FONT_ENCODING) {</a>
<a name="ln1099">		WriteSetFontEncoding(font.Encoding());</a>
<a name="ln1100">	}</a>
<a name="ln1101"> </a>
<a name="ln1102">	if (mask &amp; B_FONT_FACE) {</a>
<a name="ln1103">		WriteSetFontFace(font.Face());</a>
<a name="ln1104">	}</a>
<a name="ln1105"> </a>
<a name="ln1106">	if (mask &amp; B_FONT_FLAGS) {</a>
<a name="ln1107">		WriteSetFontFlags(font.Flags());</a>
<a name="ln1108">	}</a>
<a name="ln1109"> </a>
<a name="ln1110">	EndOp();</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113"> </a>
<a name="ln1114">void</a>
<a name="ln1115">ServerPicture::Play(Canvas* target)</a>
<a name="ln1116">{</a>
<a name="ln1117">	// TODO: for now: then change PicturePlayer</a>
<a name="ln1118">	// to accept a BPositionIO object</a>
<a name="ln1119">	BMallocIO* mallocIO = dynamic_cast&lt;BMallocIO*&gt;(fData);</a>
<a name="ln1120">	if (mallocIO == NULL)</a>
<a name="ln1121">		return;</a>
<a name="ln1122"> </a>
<a name="ln1123">	BPrivate::PicturePlayer player(mallocIO-&gt;Buffer(),</a>
<a name="ln1124">		mallocIO-&gt;BufferLength(), PictureList::Private(fPictures).AsBList());</a>
<a name="ln1125">	player.Play(kPicturePlayerCallbacks, sizeof(kPicturePlayerCallbacks),</a>
<a name="ln1126">		target);</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129"> </a>
<a name="ln1130">/*!	Acquires a reference to the pushed picture.</a>
<a name="ln1131">*/</a>
<a name="ln1132">void</a>
<a name="ln1133">ServerPicture::PushPicture(ServerPicture* picture)</a>
<a name="ln1134">{</a>
<a name="ln1135">	if (fPushed != NULL)</a>
<a name="ln1136">		debugger(&quot;already pushed a picture&quot;);</a>
<a name="ln1137"> </a>
<a name="ln1138">	fPushed = picture;</a>
<a name="ln1139">	fPushed-&gt;AcquireReference();</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142"> </a>
<a name="ln1143">/*!	Returns a reference with the popped picture.</a>
<a name="ln1144">*/</a>
<a name="ln1145">ServerPicture*</a>
<a name="ln1146">ServerPicture::PopPicture()</a>
<a name="ln1147">{</a>
<a name="ln1148">	ServerPicture* old = fPushed;</a>
<a name="ln1149">	fPushed = NULL;</a>
<a name="ln1150">	return old;</a>
<a name="ln1151">}</a>
<a name="ln1152"> </a>
<a name="ln1153"> </a>
<a name="ln1154">void</a>
<a name="ln1155">ServerPicture::AppendPicture(ServerPicture* picture)</a>
<a name="ln1156">{</a>
<a name="ln1157">	// A pushed picture is the same as an appended one</a>
<a name="ln1158">	PushPicture(picture);</a>
<a name="ln1159">}</a>
<a name="ln1160"> </a>
<a name="ln1161"> </a>
<a name="ln1162">bool</a>
<a name="ln1163">ServerPicture::NestPicture(ServerPicture* picture)</a>
<a name="ln1164">{</a>
<a name="ln1165">	if (fPictures == NULL)</a>
<a name="ln1166">		fPictures = new(std::nothrow) PictureList;</a>
<a name="ln1167"> </a>
<a name="ln1168">	if (fPictures == NULL || !fPictures-&gt;AddItem(picture))</a>
<a name="ln1169">		return false;</a>
<a name="ln1170"> </a>
<a name="ln1171">	picture-&gt;AcquireReference();</a>
<a name="ln1172">	return true;</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176">off_t</a>
<a name="ln1177">ServerPicture::DataLength() const</a>
<a name="ln1178">{</a>
<a name="ln1179">	if (fData == NULL)</a>
<a name="ln1180">		return 0;</a>
<a name="ln1181">	off_t size;</a>
<a name="ln1182">	fData-&gt;GetSize(&amp;size);</a>
<a name="ln1183">	return size;</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186"> </a>
<a name="ln1187">status_t</a>
<a name="ln1188">ServerPicture::ImportData(BPrivate::LinkReceiver&amp; link)</a>
<a name="ln1189">{</a>
<a name="ln1190">	int32 size = 0;</a>
<a name="ln1191">	link.Read&lt;int32&gt;(&amp;size);</a>
<a name="ln1192"> </a>
<a name="ln1193">	off_t oldPosition = fData-&gt;Position();</a>
<a name="ln1194">	fData-&gt;Seek(0, SEEK_SET);</a>
<a name="ln1195"> </a>
<a name="ln1196">	status_t status = B_NO_MEMORY;</a>
<a name="ln1197">	char* buffer = new(std::nothrow) char[size];</a>
<a name="ln1198">	if (buffer) {</a>
<a name="ln1199">		status = B_OK;</a>
<a name="ln1200">		ssize_t read = link.Read(buffer, size);</a>
<a name="ln1201">		if (read &lt; B_OK || fData-&gt;Write(buffer, size) &lt; B_OK)</a>
<a name="ln1202">			status = B_ERROR;</a>
<a name="ln1203">		delete [] buffer;</a>
<a name="ln1204">	}</a>
<a name="ln1205"> </a>
<a name="ln1206">	fData-&gt;Seek(oldPosition, SEEK_SET);</a>
<a name="ln1207">	return status;</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210"> </a>
<a name="ln1211">status_t</a>
<a name="ln1212">ServerPicture::ExportData(BPrivate::PortLink&amp; link)</a>
<a name="ln1213">{</a>
<a name="ln1214">	link.StartMessage(B_OK);</a>
<a name="ln1215"> </a>
<a name="ln1216">	off_t oldPosition = fData-&gt;Position();</a>
<a name="ln1217">	fData-&gt;Seek(0, SEEK_SET);</a>
<a name="ln1218"> </a>
<a name="ln1219">	int32 subPicturesCount = 0;</a>
<a name="ln1220">	if (fPictures != NULL)</a>
<a name="ln1221">		subPicturesCount = fPictures-&gt;CountItems();</a>
<a name="ln1222">	link.Attach&lt;int32&gt;(subPicturesCount);</a>
<a name="ln1223">	if (subPicturesCount &gt; 0) {</a>
<a name="ln1224">		for (int32 i = 0; i &lt; subPicturesCount; i++) {</a>
<a name="ln1225">			ServerPicture* subPicture = fPictures-&gt;ItemAt(i);</a>
<a name="ln1226">			link.Attach&lt;int32&gt;(subPicture-&gt;Token());</a>
<a name="ln1227">		}</a>
<a name="ln1228">	}</a>
<a name="ln1229"> </a>
<a name="ln1230">	off_t size = 0;</a>
<a name="ln1231">	fData-&gt;GetSize(&amp;size);</a>
<a name="ln1232">	link.Attach&lt;int32&gt;((int32)size);</a>
<a name="ln1233"> </a>
<a name="ln1234">	status_t status = B_NO_MEMORY;</a>
<a name="ln1235">	char* buffer = new(std::nothrow) char[size];</a>
<a name="ln1236">	if (buffer) {</a>
<a name="ln1237">		status = B_OK;</a>
<a name="ln1238">		ssize_t read = fData-&gt;Read(buffer, size);</a>
<a name="ln1239">		if (read &lt; B_OK || link.Attach(buffer, read) &lt; B_OK)</a>
<a name="ln1240">			status = B_ERROR;</a>
<a name="ln1241">		delete [] buffer;</a>
<a name="ln1242">	}</a>
<a name="ln1243"> </a>
<a name="ln1244">	if (status != B_OK) {</a>
<a name="ln1245">		link.CancelMessage();</a>
<a name="ln1246">		link.StartMessage(B_ERROR);</a>
<a name="ln1247">	}</a>
<a name="ln1248"> </a>
<a name="ln1249">	fData-&gt;Seek(oldPosition, SEEK_SET);</a>
<a name="ln1250">	return status;</a>
<a name="ln1251">}</a>

</code></pre>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors.</p></div>
<div class="balloon" rel="838"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
