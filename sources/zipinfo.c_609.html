
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zipinfo.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  Copyright (c) 1990-2001 Info-ZIP.  All rights reserved.</a>
<a name="ln3"> </a>
<a name="ln4">  See the accompanying file LICENSE, version 2000-Apr-09 or later</a>
<a name="ln5">  (the contents of which are also included in unzip.h) for terms of use.</a>
<a name="ln6">  If, for some reason, all these files are missing, the Info-ZIP license</a>
<a name="ln7">  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html</a>
<a name="ln8">*/</a>
<a name="ln9">/*---------------------------------------------------------------------------</a>
<a name="ln10"> </a>
<a name="ln11">  zipinfo.c                                              Greg Roelofs et al.</a>
<a name="ln12"> </a>
<a name="ln13">  This file contains all of the ZipInfo-specific listing routines for UnZip.</a>
<a name="ln14"> </a>
<a name="ln15">  Contains:  zi_opts()</a>
<a name="ln16">             zi_end_central()</a>
<a name="ln17">             zipinfo()</a>
<a name="ln18">             zi_long()</a>
<a name="ln19">             zi_short()</a>
<a name="ln20">             zi_time()</a>
<a name="ln21"> </a>
<a name="ln22">  ---------------------------------------------------------------------------*/</a>
<a name="ln23"> </a>
<a name="ln24"> </a>
<a name="ln25">#define UNZIP_INTERNAL</a>
<a name="ln26">#include &quot;unzip.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">#ifndef NO_ZIPINFO  /* strings use up too much space in small-memory systems */</a>
<a name="ln30"> </a>
<a name="ln31">/* Define OS-specific attributes for use on ALL platforms--the S_xxxx</a>
<a name="ln32"> * versions of these are defined differently (or not defined) by different</a>
<a name="ln33"> * compilers and operating systems. */</a>
<a name="ln34"> </a>
<a name="ln35">#define UNX_IFMT       0170000     /* Unix file type mask */</a>
<a name="ln36">#define UNX_IFREG      0100000     /* Unix regular file */</a>
<a name="ln37">#define UNX_IFSOCK     0140000     /* Unix socket (BSD, not SysV or Amiga) */</a>
<a name="ln38">#define UNX_IFLNK      0120000     /* Unix symbolic link (not SysV, Amiga) */</a>
<a name="ln39">#define UNX_IFBLK      0060000     /* Unix block special       (not Amiga) */</a>
<a name="ln40">#define UNX_IFDIR      0040000     /* Unix directory */</a>
<a name="ln41">#define UNX_IFCHR      0020000     /* Unix character special   (not Amiga) */</a>
<a name="ln42">#define UNX_IFIFO      0010000     /* Unix fifo    (BCC, not MSC or Amiga) */</a>
<a name="ln43">#define UNX_ISUID      04000       /* Unix set user id on execution */</a>
<a name="ln44">#define UNX_ISGID      02000       /* Unix set group id on execution */</a>
<a name="ln45">#define UNX_ISVTX      01000       /* Unix directory permissions control */</a>
<a name="ln46">#define UNX_ENFMT      UNX_ISGID   /* Unix record locking enforcement flag */</a>
<a name="ln47">#define UNX_IRWXU      00700       /* Unix read, write, execute: owner */</a>
<a name="ln48">#define UNX_IRUSR      00400       /* Unix read permission: owner */</a>
<a name="ln49">#define UNX_IWUSR      00200       /* Unix write permission: owner */</a>
<a name="ln50">#define UNX_IXUSR      00100       /* Unix execute permission: owner */</a>
<a name="ln51">#define UNX_IRWXG      00070       /* Unix read, write, execute: group */</a>
<a name="ln52">#define UNX_IRGRP      00040       /* Unix read permission: group */</a>
<a name="ln53">#define UNX_IWGRP      00020       /* Unix write permission: group */</a>
<a name="ln54">#define UNX_IXGRP      00010       /* Unix execute permission: group */</a>
<a name="ln55">#define UNX_IRWXO      00007       /* Unix read, write, execute: other */</a>
<a name="ln56">#define UNX_IROTH      00004       /* Unix read permission: other */</a>
<a name="ln57">#define UNX_IWOTH      00002       /* Unix write permission: other */</a>
<a name="ln58">#define UNX_IXOTH      00001       /* Unix execute permission: other */</a>
<a name="ln59"> </a>
<a name="ln60">#define VMS_IRUSR      UNX_IRUSR   /* VMS read/owner */</a>
<a name="ln61">#define VMS_IWUSR      UNX_IWUSR   /* VMS write/owner */</a>
<a name="ln62">#define VMS_IXUSR      UNX_IXUSR   /* VMS execute/owner */</a>
<a name="ln63">#define VMS_IRGRP      UNX_IRGRP   /* VMS read/group */</a>
<a name="ln64">#define VMS_IWGRP      UNX_IWGRP   /* VMS write/group */</a>
<a name="ln65">#define VMS_IXGRP      UNX_IXGRP   /* VMS execute/group */</a>
<a name="ln66">#define VMS_IROTH      UNX_IROTH   /* VMS read/other */</a>
<a name="ln67">#define VMS_IWOTH      UNX_IWOTH   /* VMS write/other */</a>
<a name="ln68">#define VMS_IXOTH      UNX_IXOTH   /* VMS execute/other */</a>
<a name="ln69"> </a>
<a name="ln70">#define AMI_IFMT       06000       /* Amiga file type mask */</a>
<a name="ln71">#define AMI_IFDIR      04000       /* Amiga directory */</a>
<a name="ln72">#define AMI_IFREG      02000       /* Amiga regular file */</a>
<a name="ln73">#define AMI_IHIDDEN    00200       /* to be supported in AmigaDOS 3.x */</a>
<a name="ln74">#define AMI_ISCRIPT    00100       /* executable script (text command file) */</a>
<a name="ln75">#define AMI_IPURE      00040       /* allow loading into resident memory */</a>
<a name="ln76">#define AMI_IARCHIVE   00020       /* not modified since bit was last set */</a>
<a name="ln77">#define AMI_IREAD      00010       /* can be opened for reading */</a>
<a name="ln78">#define AMI_IWRITE     00004       /* can be opened for writing */</a>
<a name="ln79">#define AMI_IEXECUTE   00002       /* executable image, a loadable runfile */</a>
<a name="ln80">#define AMI_IDELETE    00001       /* can be deleted */</a>
<a name="ln81"> </a>
<a name="ln82">#define THS_IFMT    0xF000         /* Theos file type mask */</a>
<a name="ln83">#define THS_IFIFO   0x1000         /* pipe */</a>
<a name="ln84">#define THS_IFCHR   0x2000         /* char device */</a>
<a name="ln85">#define THS_IFSOCK  0x3000         /* socket */</a>
<a name="ln86">#define THS_IFDIR   0x4000         /* directory */</a>
<a name="ln87">#define THS_IFLIB   0x5000         /* library */</a>
<a name="ln88">#define THS_IFBLK   0x6000         /* block device */</a>
<a name="ln89">#define THS_IFREG   0x8000         /* regular file */</a>
<a name="ln90">#define THS_IFREL   0x9000         /* relative (direct) */</a>
<a name="ln91">#define THS_IFKEY   0xA000         /* keyed */</a>
<a name="ln92">#define THS_IFIND   0xB000         /* indexed */</a>
<a name="ln93">#define THS_IFRND   0xC000         /* ???? */</a>
<a name="ln94">#define THS_IFR16   0xD000         /* 16 bit real mode program */</a>
<a name="ln95">#define THS_IFP16   0xE000         /* 16 bit protected mode prog */</a>
<a name="ln96">#define THS_IFP32   0xF000         /* 32 bit protected mode prog */</a>
<a name="ln97">#define THS_IMODF   0x0800         /* modified */</a>
<a name="ln98">#define THS_INHID   0x0400         /* not hidden */</a>
<a name="ln99">#define THS_IEUSR   0x0200         /* erase permission: owner */</a>
<a name="ln100">#define THS_IRUSR   0x0100         /* read permission: owner */</a>
<a name="ln101">#define THS_IWUSR   0x0080         /* write permission: owner */</a>
<a name="ln102">#define THS_IXUSR   0x0040         /* execute permission: owner */</a>
<a name="ln103">#define THS_IROTH   0x0004         /* read permission: other */</a>
<a name="ln104">#define THS_IWOTH   0x0002         /* write permission: other */</a>
<a name="ln105">#define THS_IXOTH   0x0001         /* execute permission: other */</a>
<a name="ln106"> </a>
<a name="ln107">#ifdef OLD_THEOS_EXTRA</a>
<a name="ln108">#  include &quot;theos/oldstat.h&quot;</a>
<a name="ln109">#endif</a>
<a name="ln110"> </a>
<a name="ln111">#ifndef NSK_UNSTRUCTURED</a>
<a name="ln112"># define NSK_UNSTRUCTURED   0</a>
<a name="ln113">#endif</a>
<a name="ln114">#ifndef NSK_OBJECTFILECODE</a>
<a name="ln115"># define NSK_OBJECTFILECODE 100</a>
<a name="ln116">#endif</a>
<a name="ln117">#ifndef NSK_EDITFILECODE</a>
<a name="ln118"># define NSK_EDITFILECODE   101</a>
<a name="ln119">#endif</a>
<a name="ln120"> </a>
<a name="ln121">#define LFLAG  3   /* short &quot;ls -l&quot; type listing */</a>
<a name="ln122"> </a>
<a name="ln123">static int   zi_long   OF((__GPRO__ ulg *pEndprev));</a>
<a name="ln124">static int   zi_short  OF((__GPRO));</a>
<a name="ln125">static void  zi_showMacTypeCreator</a>
<a name="ln126">                       OF((__GPRO__ uch *ebfield));</a>
<a name="ln127">static char *zi_time   OF((__GPRO__ ZCONST ulg *datetimez,</a>
<a name="ln128">                           ZCONST time_t *modtimez, char *d_t_str));</a>
<a name="ln129"> </a>
<a name="ln130"> </a>
<a name="ln131">/**********************************************/</a>
<a name="ln132">/*  Strings used in zipinfo.c (ZipInfo half)  */</a>
<a name="ln133">/**********************************************/</a>
<a name="ln134"> </a>
<a name="ln135">static ZCONST char nullStr[] = &quot;&quot;;</a>
<a name="ln136">static ZCONST char PlurSufx[] = &quot;s&quot;;</a>
<a name="ln137"> </a>
<a name="ln138">static ZCONST char Far LongHeader[] = &quot;Archive:  %s   %ld bytes   %u file%s\n&quot;;</a>
<a name="ln139">static ZCONST char Far ShortHeader[] = &quot;Archive:  %s   %ld   %u\n&quot;;</a>
<a name="ln140">static ZCONST char Far EndCentDirRec[] = &quot;\nEnd-of-central-directory record:\n&quot;;</a>
<a name="ln141">static ZCONST char Far LineSeparators[] = &quot;-------------------------------\n\n&quot;;</a>
<a name="ln142">static ZCONST char Far ActOffsetCentDir[] = &quot;\</a>
<a name="ln143">  Actual offset of end-of-central-dir record:   %9ld (%.8lXh)\n\</a>
<a name="ln144">  Expected offset of end-of-central-dir record: %9ld (%.8lXh)\n\</a>
<a name="ln145">  (based on the length of the central directory and its expected offset)\n\n&quot;;</a>
<a name="ln146">static ZCONST char Far SinglePartArchive1[] = &quot;\</a>
<a name="ln147">  This zipfile constitutes the sole disk of a single-part archive; its\n\</a>
<a name="ln148">  central directory contains %u %s.  The central directory is %lu\n\</a>
<a name="ln149">  (%.8lXh) bytes long, and its (expected) offset in bytes from the\n&quot;;</a>
<a name="ln150">static ZCONST char Far SinglePartArchive2[] = &quot;\</a>
<a name="ln151">  beginning of the zipfile is %lu (%.8lXh).\n\n&quot;;</a>
<a name="ln152">static ZCONST char Far MultiPartArchive1[] = &quot;\</a>
<a name="ln153">  This zipfile constitutes disk %u of a multi-part archive.  The central\n\</a>
<a name="ln154">  directory starts on disk %u; %u of its entries %s contained within\n&quot;;</a>
<a name="ln155">static ZCONST char Far MultiPartArchive2[] = &quot;\</a>
<a name="ln156">  this zipfile, out of a total of %u %s.  The entire central\n\</a>
<a name="ln157">  directory is %lu (%.8lXh) bytes long, and its offset in bytes from\n&quot;;</a>
<a name="ln158">static ZCONST char Far MultiPartArchive3[] = &quot;\</a>
<a name="ln159">  the beginning of the zipfile in which it begins is %lu (%.8lXh).\n\n&quot;;</a>
<a name="ln160">static ZCONST char Far NoZipfileComment[] = &quot;  There is no zipfile comment.\n&quot;;</a>
<a name="ln161">static ZCONST char Far ZipfileCommentDesc[] =</a>
<a name="ln162">  &quot;  The zipfile comment is %u bytes long and contains the following text:\n\n&quot;;</a>
<a name="ln163">static ZCONST char Far ZipfileCommBegin[] =</a>
<a name="ln164"> &quot;======================== zipfile comment begins ==========================\n&quot;;</a>
<a name="ln165">static ZCONST char Far ZipfileCommEnd[] =</a>
<a name="ln166"> &quot;========================= zipfile comment ends ===========================\n&quot;;</a>
<a name="ln167">static ZCONST char Far ZipfileCommTrunc2[] =</a>
<a name="ln168">  &quot;\n  The zipfile comment is truncated.\n&quot;;</a>
<a name="ln169">static ZCONST char Far ZipfileCommTruncMsg[] =</a>
<a name="ln170">  &quot;\ncaution:  zipfile comment truncated\n&quot;;</a>
<a name="ln171"> </a>
<a name="ln172">static ZCONST char Far CentralDirEntry[] =</a>
<a name="ln173">  &quot;\nCentral directory entry #%lu:\n---------------------------\n\n&quot;;</a>
<a name="ln174">static ZCONST char Far ZipfileStats[] =</a>
<a name="ln175">  &quot;%lu file%s, %lu bytes uncompressed, %lu bytes compressed:  %s%d.%d%%\n&quot;;</a>
<a name="ln176"> </a>
<a name="ln177">/* zi_long() strings */</a>
<a name="ln178">static ZCONST char Far OS_FAT[] = &quot;MS-DOS, OS/2 or NT FAT&quot;;</a>
<a name="ln179">static ZCONST char Far OS_Amiga[] = &quot;Amiga&quot;;</a>
<a name="ln180">static ZCONST char Far OS_VMS[] = &quot;VMS&quot;;</a>
<a name="ln181">static ZCONST char Far OS_Unix[] = &quot;Unix&quot;;</a>
<a name="ln182">static ZCONST char Far OS_VMCMS[] = &quot;VM/CMS&quot;;</a>
<a name="ln183">static ZCONST char Far OS_AtariST[] = &quot;Atari ST&quot;;</a>
<a name="ln184">static ZCONST char Far OS_HPFS[] = &quot;OS/2 or NT HPFS&quot;;</a>
<a name="ln185">static ZCONST char Far OS_Macintosh[] = &quot;Macintosh HFS&quot;;</a>
<a name="ln186">static ZCONST char Far OS_ZSystem[] = &quot;Z-System&quot;;</a>
<a name="ln187">static ZCONST char Far OS_CPM[] = &quot;CP/M&quot;;</a>
<a name="ln188">static ZCONST char Far OS_TOPS20[] = &quot;TOPS-20&quot;;</a>
<a name="ln189">static ZCONST char Far OS_NTFS[] = &quot;NTFS&quot;;</a>
<a name="ln190">static ZCONST char Far OS_QDOS[] = &quot;SMS/QDOS&quot;;</a>
<a name="ln191">static ZCONST char Far OS_Acorn[] = &quot;Acorn RISC OS&quot;;</a>
<a name="ln192">static ZCONST char Far OS_MVS[] = &quot;MVS&quot;;</a>
<a name="ln193">static ZCONST char Far OS_VFAT[] = &quot;Win32 VFAT&quot;;</a>
<a name="ln194">static ZCONST char Far OS_BeOS[] = &quot;BeOS&quot;;</a>
<a name="ln195">static ZCONST char Far OS_Tandem[] = &quot;Tandem NSK&quot;;</a>
<a name="ln196">static ZCONST char Far OS_Theos[] = &quot;Theos&quot;;</a>
<a name="ln197">#ifdef OLD_THEOS_EXTRA</a>
<a name="ln198">  static ZCONST char Far OS_TheosOld[] = &quot;Theos (Old)&quot;;</a>
<a name="ln199">#endif /* OLD_THEOS_EXTRA */</a>
<a name="ln200"> </a>
<a name="ln201">static ZCONST char Far MthdNone[] = &quot;none (stored)&quot;;</a>
<a name="ln202">static ZCONST char Far MthdShrunk[] = &quot;shrunk&quot;;</a>
<a name="ln203">static ZCONST char Far MthdRedF1[] = &quot;reduced (factor 1)&quot;;</a>
<a name="ln204">static ZCONST char Far MthdRedF2[] = &quot;reduced (factor 2)&quot;;</a>
<a name="ln205">static ZCONST char Far MthdRedF3[] = &quot;reduced (factor 3)&quot;;</a>
<a name="ln206">static ZCONST char Far MthdRedF4[] = &quot;reduced (factor 4)&quot;;</a>
<a name="ln207">static ZCONST char Far MthdImplode[] = &quot;imploded&quot;;</a>
<a name="ln208">static ZCONST char Far MthdToken[] = &quot;tokenized&quot;;</a>
<a name="ln209">static ZCONST char Far MthdDeflate[] = &quot;deflated&quot;;</a>
<a name="ln210">static ZCONST char Far MthdDeflat64[] = &quot;deflated (enhanced-64k)&quot;;</a>
<a name="ln211">static ZCONST char Far MthdDCLImplode[] = &quot;imploded (PK DCL)&quot;;</a>
<a name="ln212"> </a>
<a name="ln213">static ZCONST char Far DeflNorm[] = &quot;normal&quot;;</a>
<a name="ln214">static ZCONST char Far DeflMax[] = &quot;maximum&quot;;</a>
<a name="ln215">static ZCONST char Far DeflFast[] = &quot;fast&quot;;</a>
<a name="ln216">static ZCONST char Far DeflSFast[] = &quot;superfast&quot;;</a>
<a name="ln217"> </a>
<a name="ln218">static ZCONST char Far ExtraBytesPreceding[] =</a>
<a name="ln219">  &quot;  There are an extra %ld bytes preceding this file.\n\n&quot;;</a>
<a name="ln220"> </a>
<a name="ln221">static ZCONST char Far UnknownNo[] = &quot;unknown (%d)&quot;;</a>
<a name="ln222"> </a>
<a name="ln223">static ZCONST char Far LocalHeaderOffset[] =</a>
<a name="ln224">  &quot;\n  offset of local header from start of archive:     %lu (%.8lXh) bytes\n&quot;;</a>
<a name="ln225">static ZCONST char Far HostOS[] =</a>
<a name="ln226">  &quot;  file system or operating system of origin:        %s\n&quot;;</a>
<a name="ln227">static ZCONST char Far EncodeSWVer[] =</a>
<a name="ln228">  &quot;  version of encoding software:                     %u.%u\n&quot;;</a>
<a name="ln229">static ZCONST char Far MinOSCompReq[] =</a>
<a name="ln230">  &quot;  minimum file system compatibility required:       %s\n&quot;;</a>
<a name="ln231">static ZCONST char Far MinSWVerReq[] =</a>
<a name="ln232">  &quot;  minimum software version required to extract:     %u.%u\n&quot;;</a>
<a name="ln233">static ZCONST char Far CompressMethod[] =</a>
<a name="ln234">  &quot;  compression method:                               %s\n&quot;;</a>
<a name="ln235">static ZCONST char Far SlideWindowSizeImplode[] =</a>
<a name="ln236">  &quot;  size of sliding dictionary (implosion):           %cK\n&quot;;</a>
<a name="ln237">static ZCONST char Far ShannonFanoTrees[] =</a>
<a name="ln238">  &quot;  number of Shannon-Fano trees (implosion):         %c\n&quot;;</a>
<a name="ln239">static ZCONST char Far CompressSubtype[] =</a>
<a name="ln240">  &quot;  compression sub-type (deflation):                 %s\n&quot;;</a>
<a name="ln241">static ZCONST char Far FileSecurity[] =</a>
<a name="ln242">  &quot;  file security status:                             %sencrypted\n&quot;;</a>
<a name="ln243">static ZCONST char Far ExtendedLocalHdr[] =</a>
<a name="ln244">  &quot;  extended local header:                            %s\n&quot;;</a>
<a name="ln245">static ZCONST char Far FileModDate[] =</a>
<a name="ln246">  &quot;  file last modified on (DOS date/time):            %s\n&quot;;</a>
<a name="ln247">#ifdef USE_EF_UT_TIME</a>
<a name="ln248">  static ZCONST char Far UT_FileModDate[] =</a>
<a name="ln249">    &quot;  file last modified on (UT extra field modtime):   %s %s\n&quot;;</a>
<a name="ln250">  static ZCONST char Far LocalTime[] = &quot;local&quot;;</a>
<a name="ln251">#ifndef NO_GMTIME</a>
<a name="ln252">  static ZCONST char Far GMTime[] = &quot;UTC&quot;;</a>
<a name="ln253">#endif</a>
<a name="ln254">#endif /* USE_EF_UT_TIME */</a>
<a name="ln255">static ZCONST char Far CRC32Value[] =</a>
<a name="ln256">  &quot;  32-bit CRC value (hex):                           %.8lx\n&quot;;</a>
<a name="ln257">static ZCONST char Far CompressedFileSize[] =</a>
<a name="ln258">  &quot;  compressed size:                                  %lu bytes\n&quot;;</a>
<a name="ln259">static ZCONST char Far UncompressedFileSize[] =</a>
<a name="ln260">  &quot;  uncompressed size:                                %lu bytes\n&quot;;</a>
<a name="ln261">static ZCONST char Far FilenameLength[] =</a>
<a name="ln262">  &quot;  length of filename:                               %u characters\n&quot;;</a>
<a name="ln263">static ZCONST char Far ExtraFieldLength[] =</a>
<a name="ln264">  &quot;  length of extra field:                            %u bytes\n&quot;;</a>
<a name="ln265">static ZCONST char Far FileCommentLength[] =</a>
<a name="ln266">  &quot;  length of file comment:                           %u characters\n&quot;;</a>
<a name="ln267">static ZCONST char Far FileDiskNum[] =</a>
<a name="ln268">  &quot;  disk number on which file begins:                 disk %u\n&quot;;</a>
<a name="ln269">static ZCONST char Far ApparentFileType[] =</a>
<a name="ln270">  &quot;  apparent file type:                               %s\n&quot;;</a>
<a name="ln271">static ZCONST char Far VMSFileAttributes[] =</a>
<a name="ln272">  &quot;  VMS file attributes (%06o octal):               %s\n&quot;;</a>
<a name="ln273">static ZCONST char Far AmigaFileAttributes[] =</a>
<a name="ln274">  &quot;  Amiga file attributes (%06o octal):             %s\n&quot;;</a>
<a name="ln275">static ZCONST char Far UnixFileAttributes[] =</a>
<a name="ln276">  &quot;  Unix file attributes (%06o octal):              %s\n&quot;;</a>
<a name="ln277">static ZCONST char Far NonMSDOSFileAttributes[] =</a>
<a name="ln278">  &quot;  non-MSDOS external file attributes:               %06lX hex\n&quot;;</a>
<a name="ln279">static ZCONST char Far MSDOSFileAttributes[] =</a>
<a name="ln280">  &quot;  MS-DOS file attributes (%02X hex):                  none\n&quot;;</a>
<a name="ln281">static ZCONST char Far MSDOSFileAttributesRO[] =</a>
<a name="ln282">  &quot;  MS-DOS file attributes (%02X hex):                  read-only\n&quot;;</a>
<a name="ln283">static ZCONST char Far MSDOSFileAttributesAlpha[] =</a>
<a name="ln284">  &quot;  MS-DOS file attributes (%02X hex):                  %s%s%s%s%s%s%s%s\n&quot;;</a>
<a name="ln285">static ZCONST char Far TheosFileAttributes[] =</a>
<a name="ln286">  &quot;  Theos file attributes (%04X hex):                 %s\n&quot;;</a>
<a name="ln287"> </a>
<a name="ln288">static ZCONST char Far TheosFTypLib[] = &quot;Library     &quot;;</a>
<a name="ln289">static ZCONST char Far TheosFTypDir[] = &quot;Directory   &quot;;</a>
<a name="ln290">static ZCONST char Far TheosFTypReg[] = &quot;Sequential  &quot;;</a>
<a name="ln291">static ZCONST char Far TheosFTypRel[] = &quot;Direct      &quot;;</a>
<a name="ln292">static ZCONST char Far TheosFTypKey[] = &quot;Keyed       &quot;;</a>
<a name="ln293">static ZCONST char Far TheosFTypInd[] = &quot;Indexed     &quot;;</a>
<a name="ln294">static ZCONST char Far TheosFTypR16[] = &quot; 86 program &quot;;</a>
<a name="ln295">static ZCONST char Far TheosFTypP16[] = &quot;286 program &quot;;</a>
<a name="ln296">static ZCONST char Far TheosFTypP32[] = &quot;386 program &quot;;</a>
<a name="ln297">static ZCONST char Far TheosFTypUkn[] = &quot;???         &quot;;</a>
<a name="ln298"> </a>
<a name="ln299">static ZCONST char Far ExtraFieldTrunc[] = &quot;\n\</a>
<a name="ln300">  error: EF data block (type 0x%04x) size %u exceeds remaining extra field\n\</a>
<a name="ln301">         space %u; block length has been truncated.\n&quot;;</a>
<a name="ln302">static ZCONST char Far ExtraFields[] = &quot;\n\</a>
<a name="ln303">  The central-directory extra field contains:&quot;;</a>
<a name="ln304">static ZCONST char Far ExtraFieldType[] = &quot;\n\</a>
<a name="ln305">  - A subfield with ID 0x%04x (%s) and %u data bytes&quot;;</a>
<a name="ln306">static ZCONST char Far efPKSZ64[] = &quot;PKWARE 64-bit sizes&quot;;</a>
<a name="ln307">static ZCONST char Far efAV[] = &quot;PKWARE AV&quot;;</a>
<a name="ln308">static ZCONST char Far efOS2[] = &quot;OS/2&quot;;</a>
<a name="ln309">static ZCONST char Far efPKVMS[] = &quot;PKWARE VMS&quot;;</a>
<a name="ln310">static ZCONST char Far efPKWin32[] = &quot;PKWARE Win32&quot;;</a>
<a name="ln311">static ZCONST char Far efPKUnix[] = &quot;PKWARE Unix&quot;;</a>
<a name="ln312">static ZCONST char Far efIZVMS[] = &quot;Info-ZIP VMS&quot;;</a>
<a name="ln313">static ZCONST char Far efIZUnix[] = &quot;old Info-ZIP Unix/OS2/NT&quot;;</a>
<a name="ln314">static ZCONST char Far efIZUnix2[] = &quot;Unix UID/GID&quot;;</a>
<a name="ln315">static ZCONST char Far efTime[] = &quot;universal time&quot;;</a>
<a name="ln316">static ZCONST char Far efJLMac[] = &quot;old Info-ZIP Macintosh&quot;;</a>
<a name="ln317">static ZCONST char Far efMac3[] = &quot;new Info-ZIP Macintosh&quot;;</a>
<a name="ln318">static ZCONST char Far efZipIt[] = &quot;ZipIt Macintosh&quot;;</a>
<a name="ln319">static ZCONST char Far efSmartZip[] = &quot;SmartZip Macintosh&quot;;</a>
<a name="ln320">static ZCONST char Far efZipIt2[] = &quot;ZipIt Macintosh (short)&quot;;</a>
<a name="ln321">static ZCONST char Far efVMCMS[] = &quot;VM/CMS&quot;;</a>
<a name="ln322">static ZCONST char Far efMVS[] = &quot;MVS&quot;;</a>
<a name="ln323">static ZCONST char Far efACL[] = &quot;OS/2 ACL&quot;;</a>
<a name="ln324">static ZCONST char Far efNTSD[] = &quot;Security Descriptor&quot;;</a>
<a name="ln325">static ZCONST char Far efBeOS[] = &quot;BeOS&quot;;</a>
<a name="ln326">static ZCONST char Far efQDOS[] = &quot;SMS/QDOS&quot;;</a>
<a name="ln327">static ZCONST char Far efAOSVS[] = &quot;AOS/VS&quot;;</a>
<a name="ln328">static ZCONST char Far efSpark[] = &quot;Acorn SparkFS&quot;;</a>
<a name="ln329">static ZCONST char Far efMD5[] = &quot;Fred Kantor MD5&quot;;</a>
<a name="ln330">static ZCONST char Far efASiUnix[] = &quot;ASi Unix&quot;;</a>
<a name="ln331">static ZCONST char Far efTandem[] = &quot;Tandem NSK&quot;;</a>
<a name="ln332">static ZCONST char Far efTheos[] = &quot;Theos&quot;;</a>
<a name="ln333">static ZCONST char Far efUnknown[] = &quot;unknown&quot;;</a>
<a name="ln334"> </a>
<a name="ln335">static ZCONST char Far OS2EAs[] = &quot;.\n\</a>
<a name="ln336">    The local extra field has %lu bytes of OS/2 extended attributes.\n\</a>
<a name="ln337">    (May not match OS/2 \&quot;dir\&quot; amount due to storage method)&quot;;</a>
<a name="ln338">static ZCONST char Far izVMSdata[] = &quot;.  The extra\n\</a>
<a name="ln339">    field is %s and has %u bytes of VMS %s information%s&quot;;</a>
<a name="ln340">static ZCONST char Far izVMSstored[] = &quot;stored&quot;;</a>
<a name="ln341">static ZCONST char Far izVMSrleenc[] = &quot;run-length encoded&quot;;</a>
<a name="ln342">static ZCONST char Far izVMSdeflat[] = &quot;deflated&quot;;</a>
<a name="ln343">static ZCONST char Far izVMScunknw[] = &quot;compressed(?)&quot;;</a>
<a name="ln344">static ZCONST char Far *izVMScomp[4] =</a>
<a name="ln345">  {izVMSstored, izVMSrleenc, izVMSdeflat, izVMScunknw};</a>
<a name="ln346">static ZCONST char Far ACLdata[] = &quot;.\n\</a>
<a name="ln347">    The local extra field has %lu bytes of access control list information&quot;;</a>
<a name="ln348">static ZCONST char Far NTSDData[] = &quot;.\n\</a>
<a name="ln349">    The local extra field has %lu bytes of NT security descriptor data&quot;;</a>
<a name="ln350">static ZCONST char Far UTdata[] = &quot;.\n\</a>
<a name="ln351">    The local extra field has UTC/GMT %s time%s&quot;;</a>
<a name="ln352">static ZCONST char Far UTmodification[] = &quot;modification&quot;;</a>
<a name="ln353">static ZCONST char Far UTaccess[] = &quot;access&quot;;</a>
<a name="ln354">static ZCONST char Far UTcreation[] = &quot;creation&quot;;</a>
<a name="ln355">static ZCONST char Far ZipItFname[] = &quot;.\n\</a>
<a name="ln356">    The Mac long filename is %s&quot;;</a>
<a name="ln357">static ZCONST char Far Mac3data[] = &quot;.\n\</a>
<a name="ln358">    The local extra field has %lu bytes of %scompressed Macintosh\n\</a>
<a name="ln359">    finder attributes&quot;;</a>
<a name="ln360"> /* MacOSdata[] is used by EF_MAC3, EF_ZIPIT, EF_ZIPIT2 and EF_JLEE e. f. */</a>
<a name="ln361">static ZCONST char Far MacOSdata[] = &quot;.\n\</a>
<a name="ln362">    The associated file has type code `%c%c%c%c' and creator code `%c%c%c%c'&quot;;</a>
<a name="ln363">static ZCONST char Far MacOSdata1[] = &quot;.\n\</a>
<a name="ln364">    The associated file has type code `0x%lx' and creator code `0x%lx'&quot;;</a>
<a name="ln365">static ZCONST char Far MacOSJLEEflags[] = &quot;.\n    File is marked as %s&quot;;</a>
<a name="ln366">static ZCONST char Far MacOS_RF[] = &quot;Resource-fork&quot;;</a>
<a name="ln367">static ZCONST char Far MacOS_DF[] = &quot;Data-fork&quot;;</a>
<a name="ln368">static ZCONST char Far MacOSMAC3flags[] = &quot;.\n\</a>
<a name="ln369">    File is marked as %s, File Dates are in %d Bit&quot;;</a>
<a name="ln370">static ZCONST char Far BeOSdata[] = &quot;.\n\</a>
<a name="ln371">    The local extra field has %lu bytes of %scompressed BeOS file attributes&quot;;</a>
<a name="ln372"> /* The associated file has type code `%c%c%c%c' and creator code `%c%c%c%c'&quot; */</a>
<a name="ln373">static ZCONST char Far QDOSdata[] = &quot;.\n\</a>
<a name="ln374">    The QDOS extra field subtype is `%c%c%c%c'&quot;;</a>
<a name="ln375">static ZCONST char Far AOSVSdata[] = &quot;.\n\</a>
<a name="ln376">    The AOS/VS extra field revision is %d.%d&quot;;</a>
<a name="ln377">static ZCONST char Far TandemUnstr[] = &quot;Unstructured&quot;;</a>
<a name="ln378">static ZCONST char Far TandemRel[]   = &quot;Relative&quot;;</a>
<a name="ln379">static ZCONST char Far TandemEntry[] = &quot;Entry Sequenced&quot;;</a>
<a name="ln380">static ZCONST char Far TandemKey[]   = &quot;Key Sequenced&quot;;</a>
<a name="ln381">static ZCONST char Far TandemEdit[]  = &quot;Edit&quot;;</a>
<a name="ln382">static ZCONST char Far TandemObj[]  = &quot;Object&quot;;</a>
<a name="ln383">static ZCONST char Far *TandemFileformat[6] =</a>
<a name="ln384">  {TandemUnstr, TandemRel, TandemEntry, TandemKey, TandemEdit, TandemObj};</a>
<a name="ln385">static ZCONST char Far Tandemdata[] = &quot;.\n\</a>
<a name="ln386">    The file was originally a Tandem %s file, with file code %u&quot;;</a>
<a name="ln387">static ZCONST char Far MD5data[] = &quot;.\n\</a>
<a name="ln388">    The 128-bit MD5 signature is %s&quot;;</a>
<a name="ln389">#ifdef CMS_MVS</a>
<a name="ln390">   static ZCONST char Far VmMvsExtraField[] = &quot;.\n\</a>
<a name="ln391">    The stored file open mode (FLDATA TYPE) is \&quot;%s\&quot;&quot;;</a>
<a name="ln392">   static ZCONST char Far VmMvsInvalid[] = &quot;[invalid]&quot;;</a>
<a name="ln393">#endif /* CMS_MVS */</a>
<a name="ln394"> </a>
<a name="ln395">static ZCONST char Far First20[] = &quot;.  The first\n    20 are:  &quot;;</a>
<a name="ln396">static ZCONST char Far ColonIndent[] = &quot;:\n   &quot;;</a>
<a name="ln397">static ZCONST char Far efFormat[] = &quot; %02x&quot;;</a>
<a name="ln398"> </a>
<a name="ln399">static ZCONST char Far lExtraFieldType[] = &quot;\n\</a>
<a name="ln400">  There %s a local extra field with ID 0x%04x (%s) and\n\</a>
<a name="ln401">  %u data bytes (%s).\n&quot;;</a>
<a name="ln402">static ZCONST char Far efIZuid[] =</a>
<a name="ln403">  &quot;GMT modification/access times and Unix UID/GID&quot;;</a>
<a name="ln404">static ZCONST char Far efIZnouid[] = &quot;GMT modification/access times only&quot;;</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">static ZCONST char Far NoFileComment[] = &quot;\n  There is no file comment.\n&quot;;</a>
<a name="ln408">static ZCONST char Far FileCommBegin[] = &quot;\n\</a>
<a name="ln409">------------------------- file comment begins ----------------------------\n&quot;;</a>
<a name="ln410">static ZCONST char Far FileCommEnd[] = &quot;\</a>
<a name="ln411">-------------------------- file comment ends -----------------------------\n&quot;;</a>
<a name="ln412"> </a>
<a name="ln413">/* zi_time() strings */</a>
<a name="ln414">static ZCONST char Far BogusFmt[] = &quot;%03d&quot;;</a>
<a name="ln415">static ZCONST char Far DMYHMTime[] = &quot;%2u-%s-%02u %02u:%02u&quot;;</a>
<a name="ln416">static ZCONST char Far YMDHMSTime[] = &quot;%u %s %u %02u:%02u:%02u&quot;;</a>
<a name="ln417">static ZCONST char Far DecimalTime[] = &quot;%04u%02u%02u.%02u%02u%02u&quot;;</a>
<a name="ln418">#ifdef USE_EF_UT_TIME</a>
<a name="ln419">  static ZCONST char Far YMDHMSTimeError[] = &quot;???? ??? ?? ??:??:??&quot;;</a>
<a name="ln420">#endif</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425"> </a>
<a name="ln426">#ifndef WINDLL</a>
<a name="ln427"> </a>
<a name="ln428">/************************/</a>
<a name="ln429">/*  Function zi_opts()  */</a>
<a name="ln430">/************************/</a>
<a name="ln431"> </a>
<a name="ln432">int zi_opts(__G__ pargc, pargv)</a>
<a name="ln433">    int *pargc;</a>
<a name="ln434">    char ***pargv;</a>
<a name="ln435">    __GDEF</a>
<a name="ln436">{</a>
<a name="ln437">    char   **argv, *s;</a>
<a name="ln438">    int    argc, c, error=FALSE, negative=0;</a>
<a name="ln439">    int    hflag_slmv=TRUE, hflag_2=FALSE;  /* diff options =&gt; diff defaults */</a>
<a name="ln440">    int    tflag_slm=TRUE, tflag_2v=FALSE;</a>
<a name="ln441">    int    explicit_h=FALSE, explicit_t=FALSE;</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">#ifdef MACOS</a>
<a name="ln445">    uO.lflag = LFLAG;         /* reset default on each call */</a>
<a name="ln446">#endif</a>
<a name="ln447">    G.extract_flag = FALSE;   /* zipinfo does not extract to disk */</a>
<a name="ln448">    argc = *pargc;</a>
<a name="ln449">    argv = *pargv;</a>
<a name="ln450"> </a>
<a name="ln451">    while (--argc &gt; 0 &amp;&amp; (*++argv)[0] == '-') {</a>
<a name="ln452">        s = argv[0] + 1;</a>
<a name="ln453">        while ((c = *s++) != 0) {    /* &quot;!= 0&quot;:  prevent Turbo C warning */</a>
<a name="ln454">            switch (c) {</a>
<a name="ln455">                case '-':</a>
<a name="ln456">                    ++negative;</a>
<a name="ln457">                    break;</a>
<a name="ln458">                case '1':      /* shortest listing:  JUST filenames */</a>
<a name="ln459">                    if (negative)</a>
<a name="ln460">                        uO.lflag = -2, negative = 0;</a>
<a name="ln461">                    else</a>
<a name="ln462">                        uO.lflag = 1;</a>
<a name="ln463">                    break;</a>
<a name="ln464">                case '2':      /* just filenames, plus headers if specified */</a>
<a name="ln465">                    if (negative)</a>
<a name="ln466">                        uO.lflag = -2, negative = 0;</a>
<a name="ln467">                    else</a>
<a name="ln468">                        uO.lflag = 2;</a>
<a name="ln469">                    break;</a>
<a name="ln470">#ifndef CMS_MVS</a>
<a name="ln471">                case ('C'):    /* -C:  match filenames case-insensitively */</a>
<a name="ln472">                    if (negative)</a>
<a name="ln473">                        uO.C_flag = FALSE, negative = 0;</a>
<a name="ln474">                    else</a>
<a name="ln475">                        uO.C_flag = TRUE;</a>
<a name="ln476">                    break;</a>
<a name="ln477">#endif /* !CMS_MVS */</a>
<a name="ln478">                case 'h':      /* header line */</a>
<a name="ln479">                    if (negative)</a>
<a name="ln480">                        hflag_2 = hflag_slmv = FALSE, negative = 0;</a>
<a name="ln481">                    else {</a>
<a name="ln482">                        hflag_2 = hflag_slmv = explicit_h = TRUE;</a>
<a name="ln483">                        if (uO.lflag == -1)</a>
<a name="ln484">                            uO.lflag = 0;</a>
<a name="ln485">                    }</a>
<a name="ln486">                    break;</a>
<a name="ln487">                case 'l':      /* longer form of &quot;ls -l&quot; type listing */</a>
<a name="ln488">                    if (negative)</a>
<a name="ln489">                        uO.lflag = -2, negative = 0;</a>
<a name="ln490">                    else</a>
<a name="ln491">                        uO.lflag = 5;</a>
<a name="ln492">                    break;</a>
<a name="ln493">                case 'm':      /* medium form of &quot;ls -l&quot; type listing */</a>
<a name="ln494">                    if (negative)</a>
<a name="ln495">                        uO.lflag = -2, negative = 0;</a>
<a name="ln496">                    else</a>
<a name="ln497">                        uO.lflag = 4;</a>
<a name="ln498">                    break;</a>
<a name="ln499">#ifdef MORE</a>
<a name="ln500">                case 'M':      /* send output through built-in &quot;more&quot; */</a>
<a name="ln501">                    if (negative)</a>
<a name="ln502">                        G.M_flag = FALSE, negative = 0;</a>
<a name="ln503">                    else</a>
<a name="ln504">                        G.M_flag = TRUE;</a>
<a name="ln505">                    break;</a>
<a name="ln506">#endif</a>
<a name="ln507">                case 's':      /* default:  shorter &quot;ls -l&quot; type listing */</a>
<a name="ln508">                    if (negative)</a>
<a name="ln509">                        uO.lflag = -2, negative = 0;</a>
<a name="ln510">                    else</a>
<a name="ln511">                        uO.lflag = 3;</a>
<a name="ln512">                    break;</a>
<a name="ln513">                case 't':      /* totals line */</a>
<a name="ln514">                    if (negative)</a>
<a name="ln515">                        tflag_2v = tflag_slm = FALSE, negative = 0;</a>
<a name="ln516">                    else {</a>
<a name="ln517">                        tflag_2v = tflag_slm = explicit_t = TRUE;</a>
<a name="ln518">                        if (uO.lflag == -1)</a>
<a name="ln519">                            uO.lflag = 0;</a>
<a name="ln520">                    }</a>
<a name="ln521">                    break;</a>
<a name="ln522">                case ('T'):    /* use (sortable) decimal time format */</a>
<a name="ln523">                    if (negative)</a>
<a name="ln524">                        uO.T_flag = FALSE, negative = 0;</a>
<a name="ln525">                    else</a>
<a name="ln526">                        uO.T_flag = TRUE;</a>
<a name="ln527">                    break;</a>
<a name="ln528">                case 'v':      /* turbo-verbose listing */</a>
<a name="ln529">                    if (negative)</a>
<a name="ln530">                        uO.lflag = -2, negative = 0;</a>
<a name="ln531">                    else</a>
<a name="ln532">                        uO.lflag = 10;</a>
<a name="ln533">                    break;</a>
<a name="ln534">                case 'z':      /* print zipfile comment */</a>
<a name="ln535">                    if (negative)</a>
<a name="ln536">                        uO.zflag = negative = 0;</a>
<a name="ln537">                    else</a>
<a name="ln538">                        uO.zflag = 1;</a>
<a name="ln539">                    break;</a>
<a name="ln540">                case 'Z':      /* ZipInfo mode:  ignore */</a>
<a name="ln541">                    break;</a>
<a name="ln542">                default:</a>
<a name="ln543">                    error = TRUE;</a>
<a name="ln544">                    break;</a>
<a name="ln545">            }</a>
<a name="ln546">        }</a>
<a name="ln547">    }</a>
<a name="ln548">    if ((argc-- == 0) || error) {</a>
<a name="ln549">        *pargc = argc;</a>
<a name="ln550">        *pargv = argv;</a>
<a name="ln551">        return USAGE(error);</a>
<a name="ln552">    }</a>
<a name="ln553"> </a>
<a name="ln554">#ifdef MORE</a>
<a name="ln555">    if (G.M_flag &amp;&amp; !isatty(1))  /* stdout redirected: &quot;more&quot; func useless */</a>
<a name="ln556">        G.M_flag = 0;</a>
<a name="ln557">#endif</a>
<a name="ln558"> </a>
<a name="ln559">    /* if no listing options given (or all negated), or if only -h/-t given</a>
<a name="ln560">     * with individual files specified, use default listing format */</a>
<a name="ln561">    if ((uO.lflag &lt; 0) || ((argc &gt; 0) &amp;&amp; (uO.lflag == 0)))</a>
<a name="ln562">        uO.lflag = LFLAG;</a>
<a name="ln563"> </a>
<a name="ln564">    /* set header and totals flags to default or specified values */</a>
<a name="ln565">    switch (uO.lflag) {</a>
<a name="ln566">        case 0:   /* 0:  can only occur if either -t or -h explicitly given; */</a>
<a name="ln567">        case 2:   /*  therefore set both flags equal to normally false value */</a>
<a name="ln568">            uO.hflag = hflag_2;</a>
<a name="ln569">            uO.tflag = tflag_2v;</a>
<a name="ln570">            break;</a>
<a name="ln571">        case 1:   /* only filenames, *always* */</a>
<a name="ln572">            uO.hflag = FALSE;</a>
<a name="ln573">            uO.tflag = FALSE;</a>
<a name="ln574">            uO.zflag = FALSE;</a>
<a name="ln575">            break;</a>
<a name="ln576">        case 3:</a>
<a name="ln577">        case 4:</a>
<a name="ln578">        case 5:</a>
<a name="ln579">            uO.hflag = ((argc &gt; 0) &amp;&amp; !explicit_h)? FALSE : hflag_slmv;</a>
<a name="ln580">            uO.tflag = ((argc &gt; 0) &amp;&amp; !explicit_t)? FALSE : tflag_slm;</a>
<a name="ln581">            break;</a>
<a name="ln582">        case 10:</a>
<a name="ln583">            uO.hflag = hflag_slmv;</a>
<a name="ln584">            uO.tflag = tflag_2v;</a>
<a name="ln585">            break;</a>
<a name="ln586">    }</a>
<a name="ln587"> </a>
<a name="ln588">    *pargc = argc;</a>
<a name="ln589">    *pargv = argv;</a>
<a name="ln590">    return 0;</a>
<a name="ln591"> </a>
<a name="ln592">} /* end function zi_opts() */</a>
<a name="ln593"> </a>
<a name="ln594">#endif /* !WINDLL */</a>
<a name="ln595"> </a>
<a name="ln596"> </a>
<a name="ln597"> </a>
<a name="ln598"> </a>
<a name="ln599"> </a>
<a name="ln600">/*******************************/</a>
<a name="ln601">/*  Function zi_end_central()  */</a>
<a name="ln602">/*******************************/</a>
<a name="ln603"> </a>
<a name="ln604">int zi_end_central(__G)   /* return PK-type error code */</a>
<a name="ln605">    __GDEF</a>
<a name="ln606">{</a>
<a name="ln607">    int  error = PK_COOL;</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">/*---------------------------------------------------------------------------</a>
<a name="ln611">    Print out various interesting things about the zipfile.</a>
<a name="ln612">  ---------------------------------------------------------------------------*/</a>
<a name="ln613"> </a>
<a name="ln614">    /* header fits on one line, for anything up to 10GB and 10000 files: */</a>
<a name="ln615">    if (uO.hflag)</a>
<a name="ln616">        Info(slide, 0, ((char *)slide, ((int)strlen(G.zipfn) &lt; 39)?</a>
<a name="ln617">          LoadFarString(LongHeader) : LoadFarString(ShortHeader), G.zipfn,</a>
<a name="ln618">          (long)G.ziplen, G.ecrec.total_entries_central_dir,</a>
<a name="ln619">          (G.ecrec.total_entries_central_dir==1)?</a>
<a name="ln620">          nullStr : PlurSufx));</a>
<a name="ln621"> </a>
<a name="ln622">    /* verbose format */</a>
<a name="ln623">    if (uO.lflag &gt; 9) {</a>
<a name="ln624">        Info(slide, 0, ((char *)slide, LoadFarString(EndCentDirRec)));</a>
<a name="ln625">        Info(slide, 0, ((char *)slide, LoadFarString(LineSeparators)));</a>
<a name="ln626"> </a>
<a name="ln627">        Info(slide, 0, ((char *)slide, LoadFarString(ActOffsetCentDir),</a>
<a name="ln628">          (long)G.real_ecrec_offset, (long)G.real_ecrec_offset,</a>
<a name="ln629">          (long)G.expect_ecrec_offset, (long)G.expect_ecrec_offset));</a>
<a name="ln630"> </a>
<a name="ln631">        if (G.ecrec.number_this_disk == 0) {</a>
<a name="ln632">            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive1),</a>
<a name="ln633">              G.ecrec.total_entries_central_dir,</a>
<a name="ln634">              (G.ecrec.total_entries_central_dir == 1)? &quot;entry&quot; : &quot;entries&quot;,</a>
<a name="ln635">              G.ecrec.size_central_directory,</a>
<a name="ln636">              G.ecrec.size_central_directory));</a>
<a name="ln637">            Info(slide, 0, ((char *)slide, LoadFarString(SinglePartArchive2),</a>
<a name="ln638">              G.ecrec.offset_start_central_directory,</a>
<a name="ln639">              G.ecrec.offset_start_central_directory));</a>
<a name="ln640">        } else {</a>
<a name="ln641">            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive1),</a>
<a name="ln642">              G.ecrec.number_this_disk + 1,</a>
<a name="ln643">              G.ecrec.num_disk_start_cdir + 1,</a>
<a name="ln644">              G.ecrec.num_entries_centrl_dir_ths_disk,</a>
<a name="ln645">              (G.ecrec.num_entries_centrl_dir_ths_disk == 1)? &quot;is&quot; : &quot;are&quot;));</a>
<a name="ln646">            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive2),</a>
<a name="ln647">              G.ecrec.total_entries_central_dir,</a>
<a name="ln648">              (G.ecrec.total_entries_central_dir == 1) ? &quot;entry&quot; : &quot;entries&quot;,</a>
<a name="ln649">              G.ecrec.size_central_directory,</a>
<a name="ln650">              G.ecrec.size_central_directory));</a>
<a name="ln651">            Info(slide, 0, ((char *)slide, LoadFarString(MultiPartArchive3),</a>
<a name="ln652">              G.ecrec.offset_start_central_directory,</a>
<a name="ln653">              G.ecrec.offset_start_central_directory));</a>
<a name="ln654">        }</a>
<a name="ln655"> </a>
<a name="ln656">    /*-----------------------------------------------------------------------</a>
<a name="ln657">        Get the zipfile comment, if any, and print it out.  (Comment may be</a>
<a name="ln658">        up to 64KB long.  May the fleas of a thousand camels infest the arm-</a>
<a name="ln659">        pits of anyone who actually takes advantage of this fact.)</a>
<a name="ln660">      -----------------------------------------------------------------------*/</a>
<a name="ln661"> </a>
<a name="ln662">        if (!G.ecrec.zipfile_comment_length)</a>
<a name="ln663">            Info(slide, 0, ((char *)slide, LoadFarString(NoZipfileComment)));</a>
<a name="ln664">        else {</a>
<a name="ln665">            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommentDesc),</a>
<a name="ln666">              G.ecrec.zipfile_comment_length));</a>
<a name="ln667">            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommBegin)));</a>
<a name="ln668">            if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY))</a>
<a name="ln669">                error = PK_WARN;</a>
<a name="ln670">            Info(slide, 0, ((char *)slide, LoadFarString(ZipfileCommEnd)));</a>
<a name="ln671">            if (error)</a>
<a name="ln672">                Info(slide, 0, ((char *)slide,</a>
<a name="ln673">                  LoadFarString(ZipfileCommTrunc2)));</a>
<a name="ln674">        } /* endif (comment exists) */</a>
<a name="ln675"> </a>
<a name="ln676">    /* non-verbose mode:  print zipfile comment only if requested */</a>
<a name="ln677">    } else if (uO.zflag &amp;&amp; G.ecrec.zipfile_comment_length) {</a>
<a name="ln678">        if (do_string(__G__ G.ecrec.zipfile_comment_length, DISPLAY)) {</a>
<a name="ln679">            Info(slide, 0x401, ((char *)slide,</a>
<a name="ln680">              LoadFarString(ZipfileCommTruncMsg)));</a>
<a name="ln681">            error = PK_WARN;</a>
<a name="ln682">        }</a>
<a name="ln683">    } /* endif (verbose) */</a>
<a name="ln684"> </a>
<a name="ln685">    return error;</a>
<a name="ln686"> </a>
<a name="ln687">} /* end function zi_end_central() */</a>
<a name="ln688"> </a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">/************************/</a>
<a name="ln694">/*  Function zipinfo()  */</a>
<a name="ln695">/************************/</a>
<a name="ln696"> </a>
<a name="ln697">int zipinfo(__G)   /* return PK-type error code */</a>
<a name="ln698">    __GDEF</a>
<a name="ln699">{</a>
<a name="ln700">    int do_this_file=FALSE, error, error_in_archive=PK_COOL;</a>
<a name="ln701">    int *fn_matched=NULL, *xn_matched=NULL;</a>
<a name="ln702">    ulg j, members=0L;</a>
<a name="ln703">    ulg tot_csize=0L, tot_ucsize=0L;</a>
<a name="ln704">    ulg endprev;   /* buffers end of previous entry for zi_long()'s check</a>
<a name="ln705">                    *  of extra bytes */</a>
<a name="ln706"> </a>
<a name="ln707"> </a>
<a name="ln708">/*---------------------------------------------------------------------------</a>
<a name="ln709">    Malloc space for check on unmatched filespecs (no big deal if one or both</a>
<a name="ln710">    are NULL).</a>
<a name="ln711">  ---------------------------------------------------------------------------*/</a>
<a name="ln712"> </a>
<a name="ln713">    if (G.filespecs &gt; 0  &amp;&amp;</a>
<a name="ln714">        (fn_matched=(int *)malloc(G.filespecs*sizeof(int))) != NULL)</a>
<a name="ln715">        for (j = 0;  j &lt; G.filespecs;  ++j)</a>
<a name="ln716">            fn_matched[j] = FALSE;</a>
<a name="ln717"> </a>
<a name="ln718">    if (G.xfilespecs &gt; 0  &amp;&amp;</a>
<a name="ln719">        (xn_matched=(int *)malloc(G.xfilespecs*sizeof(int))) != NULL)</a>
<a name="ln720">        for (j = 0;  j &lt; G.xfilespecs;  ++j)</a>
<a name="ln721">            xn_matched[j] = FALSE;</a>
<a name="ln722"> </a>
<a name="ln723">/*---------------------------------------------------------------------------</a>
<a name="ln724">    Set file pointer to start of central directory, then loop through cen-</a>
<a name="ln725">    tral directory entries.  Check that directory-entry signature bytes are</a>
<a name="ln726">    actually there (just a precaution), then process the entry.  We know</a>
<a name="ln727">    the entire central directory is on this disk:  we wouldn't have any of</a>
<a name="ln728">    this information unless the end-of-central-directory record was on this</a>
<a name="ln729">    disk, and we wouldn't have gotten to this routine unless this is also</a>
<a name="ln730">    the disk on which the central directory starts.  In practice, this had</a>
<a name="ln731">    better be the *only* disk in the archive, but maybe someday we'll add</a>
<a name="ln732">    multi-disk support.</a>
<a name="ln733">  ---------------------------------------------------------------------------*/</a>
<a name="ln734"> </a>
<a name="ln735">    uO.L_flag = FALSE;      /* zipinfo mode: never convert name to lowercase */</a>
<a name="ln736">    G.pInfo = G.info;       /* (re-)initialize, (just to make sure) */</a>
<a name="ln737">    G.pInfo-&gt;textmode = 0;  /* so one can read on screen (is this ever used?) */</a>
<a name="ln738"> </a>
<a name="ln739">    /* reset endprev for new zipfile; account for multi-part archives (?) */</a>
<a name="ln740">    endprev = (G.crec.relative_offset_local_header == 4L)? 4L : 0L;</a>
<a name="ln741"> </a>
<a name="ln742"> </a>
<a name="ln743">    for (j = 1L;; j++) {</a>
<a name="ln744">        if (readbuf(__G__ G.sig, 4) == 0)</a>
<a name="ln745">            return PK_EOF;</a>
<a name="ln746">        if (strncmp(G.sig, central_hdr_sig, 4)) {  /* is it a CentDir entry? */</a>
<a name="ln747">            if (((unsigned)(j - 1) &amp; (unsigned)0xFFFF) ==</a>
<a name="ln748">                (unsigned)G.ecrec.total_entries_central_dir) {</a>
<a name="ln749">                /* &quot;j modulus 64k&quot; matches the reported 16-bit-unsigned</a>
<a name="ln750">                 * number of directory entries -&gt; probably, the regular</a>
<a name="ln751">                 * end of the central directory has been reached</a>
<a name="ln752">                 */</a>
<a name="ln753">                break;</a>
<a name="ln754">            } else {</a>
<a name="ln755">                Info(slide, 0x401,</a>
<a name="ln756">                     ((char *)slide, LoadFarString(CentSigMsg), j));</a>
<a name="ln757">                Info(slide, 0x401,</a>
<a name="ln758">                     ((char *)slide, LoadFarString(ReportMsg)));</a>
<a name="ln759">                return PK_BADERR;   /* sig not found */</a>
<a name="ln760">            }</a>
<a name="ln761">        }</a>
<a name="ln762">        /* process_cdir_file_hdr() sets pInfo-&gt;hostnum, pInfo-&gt;lcflag, ...: */</a>
<a name="ln763">        if ((error = process_cdir_file_hdr(__G)) != PK_COOL)</a>
<a name="ln764">            return error;       /* only PK_EOF defined */</a>
<a name="ln765"> </a>
<a name="ln766">        if ((error = do_string(__G__ G.crec.filename_length, DS_FN)) !=</a>
<a name="ln767">             PK_COOL)</a>
<a name="ln768">        {</a>
<a name="ln769">          error_in_archive = error;   /* might be warning */</a>
<a name="ln770">          if (error &gt; PK_WARN)        /* fatal */</a>
<a name="ln771">              return error;</a>
<a name="ln772">        }</a>
<a name="ln773"> </a>
<a name="ln774">        if (!G.process_all_files) {   /* check if specified on command line */</a>
<a name="ln775">            unsigned i;</a>
<a name="ln776"> </a>
<a name="ln777">            do_this_file = FALSE;</a>
<a name="ln778">            for (i = 0; i &lt; G.filespecs; i++)</a>
<a name="ln779">                if (match(G.filename, G.pfnames[i], uO.C_flag)) {</a>
<a name="ln780">                    do_this_file = TRUE;</a>
<a name="ln781">                    if (fn_matched)</a>
<a name="ln782">                        fn_matched[i] = TRUE;</a>
<a name="ln783">                    break;       /* found match, so stop looping */</a>
<a name="ln784">                }</a>
<a name="ln785">            if (do_this_file) {  /* check if this is an excluded file */</a>
<a name="ln786">                for (i = 0; i &lt; G.xfilespecs; i++)</a>
<a name="ln787">                    if (match(G.filename, G.pxnames[i], uO.C_flag)) {</a>
<a name="ln788">                        do_this_file = FALSE;  /* ^-- ignore case in match */</a>
<a name="ln789">                        if (xn_matched)</a>
<a name="ln790">                            xn_matched[i] = TRUE;</a>
<a name="ln791">                        break;</a>
<a name="ln792">                    }</a>
<a name="ln793">            }</a>
<a name="ln794">        }</a>
<a name="ln795"> </a>
<a name="ln796">    /*-----------------------------------------------------------------------</a>
<a name="ln797">        If current file was specified on command line, or if no names were</a>
<a name="ln798">        specified, do the listing for this file.  Otherwise, get rid of the</a>
<a name="ln799">        file comment and go back for the next file.</a>
<a name="ln800">      -----------------------------------------------------------------------*/</a>
<a name="ln801"> </a>
<a name="ln802">        if (G.process_all_files || do_this_file) {</a>
<a name="ln803"> </a>
<a name="ln804">            switch (uO.lflag) {</a>
<a name="ln805">                case 1:</a>
<a name="ln806">                case 2:</a>
<a name="ln807">                    fnprint(__G);</a>
<a name="ln808">                    SKIP_(G.crec.extra_field_length)</a>
<a name="ln809">                    SKIP_(G.crec.file_comment_length)</a>
<a name="ln810">                    break;</a>
<a name="ln811"> </a>
<a name="ln812">                case 3:</a>
<a name="ln813">                case 4:</a>
<a name="ln814">                case 5:</a>
<a name="ln815">                    if ((error = zi_short(__G)) != PK_COOL) {</a>
<a name="ln816">                        error_in_archive = error;   /* might be warning */</a>
<a name="ln817">                        if (error &gt; PK_WARN)        /* fatal */</a>
<a name="ln818">                            return error;</a>
<a name="ln819">                    }</a>
<a name="ln820">                    break;</a>
<a name="ln821"> </a>
<a name="ln822">                case 10:</a>
<a name="ln823">                    Info(slide, 0, ((char *)slide,</a>
<a name="ln824">                      LoadFarString(CentralDirEntry), j));</a>
<a name="ln825">                    if ((error = zi_long(__G__ &amp;endprev)) != PK_COOL) {</a>
<a name="ln826">                        error_in_archive = error;   /* might be warning */</a>
<a name="ln827">                        if (error &gt; PK_WARN)        /* fatal */</a>
<a name="ln828">                            return error;</a>
<a name="ln829">                    }</a>
<a name="ln830">                    break;</a>
<a name="ln831"> </a>
<a name="ln832">                default:</a>
<a name="ln833">                    SKIP_(G.crec.extra_field_length)</a>
<a name="ln834">                    SKIP_(G.crec.file_comment_length)</a>
<a name="ln835">                    break;</a>
<a name="ln836"> </a>
<a name="ln837">            } /* end switch (lflag) */</a>
<a name="ln838"> </a>
<a name="ln839">            tot_csize += G.crec.csize;</a>
<a name="ln840">            tot_ucsize += G.crec.ucsize;</a>
<a name="ln841">            if (G.crec.general_purpose_bit_flag &amp; 1)</a>
<a name="ln842">                tot_csize -= 12;   /* don't count encryption header */</a>
<a name="ln843">            ++members;</a>
<a name="ln844"> </a>
<a name="ln845">#ifdef DLL</a>
<a name="ln846">            if ((G.statreportcb != NULL) &amp;&amp;</a>
<a name="ln847">                (*G.statreportcb)(__G__ UZ_ST_FINISH_MEMBER, G.zipfn,</a>
<a name="ln848">                                  G.filename, (zvoid *)&amp;G.crec.ucsize)) {</a>
<a name="ln849">                if (fn_matched)</a>
<a name="ln850">                    free((zvoid *)fn_matched);</a>
<a name="ln851">                if (xn_matched)</a>
<a name="ln852">                    free((zvoid *)xn_matched);</a>
<a name="ln853">                return IZ_CTRLC;        /* cancel operation by user request */</a>
<a name="ln854">            }</a>
<a name="ln855">#endif</a>
<a name="ln856">#ifdef MACOS  /* MacOS is no preemptive OS, thus call event-handling by hand */</a>
<a name="ln857">            UserStop();</a>
<a name="ln858">#endif</a>
<a name="ln859"> </a>
<a name="ln860">        } else {        /* not listing this file */</a>
<a name="ln861">            SKIP_(G.crec.extra_field_length)</a>
<a name="ln862">            SKIP_(G.crec.file_comment_length)</a>
<a name="ln863"> </a>
<a name="ln864">        } /* end if (list member?) */</a>
<a name="ln865"> </a>
<a name="ln866">    } /* end for-loop (j: member files) */</a>
<a name="ln867"> </a>
<a name="ln868">/*---------------------------------------------------------------------------</a>
<a name="ln869">    Check that we actually found requested files; if so, print totals.</a>
<a name="ln870">  ---------------------------------------------------------------------------*/</a>
<a name="ln871"> </a>
<a name="ln872">    if (uO.tflag) {</a>
<a name="ln873">        char *sgn = &quot;&quot;;</a>
<a name="ln874">        int cfactor = ratio(tot_ucsize, tot_csize);</a>
<a name="ln875"> </a>
<a name="ln876">        if (cfactor &lt; 0) {</a>
<a name="ln877">            sgn = &quot;-&quot;;</a>
<a name="ln878">            cfactor = -cfactor;</a>
<a name="ln879">        }</a>
<a name="ln880">        Info(slide, 0, ((char *)slide, LoadFarString(ZipfileStats),</a>
<a name="ln881">          members, (members==1L)? nullStr:PlurSufx, tot_ucsize,</a>
<a name="ln882">          tot_csize, sgn, cfactor/10, cfactor%10));</a>
<a name="ln883">    }</a>
<a name="ln884"> </a>
<a name="ln885">/*---------------------------------------------------------------------------</a>
<a name="ln886">    Check for unmatched filespecs on command line and print warning if any</a>
<a name="ln887">    found.</a>
<a name="ln888">  ---------------------------------------------------------------------------*/</a>
<a name="ln889"> </a>
<a name="ln890">    if (fn_matched) {</a>
<a name="ln891">        for (j = 0;  j &lt; G.filespecs;  ++j)</a>
<a name="ln892">            if (!fn_matched[j])</a>
<a name="ln893">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln894">                  LoadFarString(FilenameNotMatched), G.pfnames[j]));</a>
<a name="ln895">        free((zvoid *)fn_matched);</a>
<a name="ln896">    }</a>
<a name="ln897">    if (xn_matched) {</a>
<a name="ln898">        for (j = 0;  j &lt; G.xfilespecs;  ++j)</a>
<a name="ln899">            if (!xn_matched[j])</a>
<a name="ln900">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln901">                  LoadFarString(ExclFilenameNotMatched), G.pxnames[j]));</a>
<a name="ln902">        free((zvoid *)xn_matched);</a>
<a name="ln903">    }</a>
<a name="ln904"> </a>
<a name="ln905">/*---------------------------------------------------------------------------</a>
<a name="ln906">    Double check that we're back at the end-of-central-directory record.</a>
<a name="ln907">  ---------------------------------------------------------------------------*/</a>
<a name="ln908"> </a>
<a name="ln909">    if (strncmp(G.sig, end_central_sig, 4)) {   /* just to make sure again */</a>
<a name="ln910">        Info(slide, 0x401, ((char *)slide, LoadFarString(EndSigMsg)));</a>
<a name="ln911">        error_in_archive = PK_WARN;   /* didn't find sig */</a>
<a name="ln912">    }</a>
<a name="ln913">    if (members == 0 &amp;&amp; error_in_archive &lt;= PK_WARN)</a>
<a name="ln914">        error_in_archive = PK_FIND;</a>
<a name="ln915"> </a>
<a name="ln916">    if (uO.lflag &gt;= 10)</a>
<a name="ln917">        (*G.message)((zvoid *)&amp;G, (uch *)&quot;\n&quot;, 1L, 0);</a>
<a name="ln918"> </a>
<a name="ln919">    return error_in_archive;</a>
<a name="ln920"> </a>
<a name="ln921">} /* end function zipinfo() */</a>
<a name="ln922"> </a>
<a name="ln923"> </a>
<a name="ln924"> </a>
<a name="ln925"> </a>
<a name="ln926"> </a>
<a name="ln927">/************************/</a>
<a name="ln928">/*  Function zi_long()  */</a>
<a name="ln929">/************************/</a>
<a name="ln930"> </a>
<a name="ln931">static int zi_long(__G__ pEndprev)   /* return PK-type error code */</a>
<a name="ln932">    __GDEF</a>
<a name="ln933">    ulg *pEndprev;                   /* for zi_long() check of extra bytes */</a>
<a name="ln934">{</a>
<a name="ln935">#ifdef USE_EF_UT_TIME</a>
<a name="ln936">    iztimes z_utime;</a>
<a name="ln937">#endif</a>
<a name="ln938">    int  error, error_in_archive=PK_COOL;</a>
<a name="ln939">    unsigned  hostnum, hostver, extnum, extver, methnum, xattr;</a>
<a name="ln940">    char workspace[12], attribs[22];</a>
<a name="ln941">    ZCONST char *varmsg_str;</a>
<a name="ln942">    char unkn[16];</a>
<a name="ln943">    static ZCONST char Far *os[NUM_HOSTS] = {</a>
<a name="ln944">        OS_FAT, OS_Amiga, OS_VMS, OS_Unix, OS_VMCMS, OS_AtariST, OS_HPFS,</a>
<a name="ln945">        OS_Macintosh, OS_ZSystem, OS_CPM, OS_TOPS20, OS_NTFS, OS_QDOS,</a>
<a name="ln946">        OS_Acorn, OS_VFAT, OS_MVS, OS_BeOS, OS_Tandem, OS_Theos</a>
<a name="ln947">    };</a>
<a name="ln948">    static ZCONST char Far *method[NUM_METHODS] = {</a>
<a name="ln949">        MthdNone, MthdShrunk, MthdRedF1, MthdRedF2, MthdRedF3, MthdRedF4,</a>
<a name="ln950">        MthdImplode, MthdToken, MthdDeflate, MthdDeflat64, MthdDCLImplode</a>
<a name="ln951">    };</a>
<a name="ln952">    static ZCONST char Far *dtypelng[4] = {</a>
<a name="ln953">        DeflNorm, DeflMax, DeflFast, DeflSFast</a>
<a name="ln954">    };</a>
<a name="ln955"> </a>
<a name="ln956"> </a>
<a name="ln957">/*---------------------------------------------------------------------------</a>
<a name="ln958">    Check whether there's any extra space inside the zipfile.  If *pEndprev is</a>
<a name="ln959">    zero, it's probably a signal that OS/2 extra fields are involved (with</a>
<a name="ln960">    unknown compressed size).  We won't worry about prepended junk here...</a>
<a name="ln961">  ---------------------------------------------------------------------------*/</a>
<a name="ln962"> </a>
<a name="ln963">    if (G.crec.relative_offset_local_header != *pEndprev &amp;&amp; *pEndprev &gt; 0L) {</a>
<a name="ln964">        /*  GRR DEBUG</a>
<a name="ln965">        Info(slide, 0, ((char *)slide,</a>
<a name="ln966">          &quot;  [crec.relative_offset_local_header = %lu, endprev = %lu]\n&quot;,</a>
<a name="ln967">          G.crec.relative_offset_local_header, *pEndprev));</a>
<a name="ln968">         */</a>
<a name="ln969">        Info(slide, 0, ((char *)slide, LoadFarString(ExtraBytesPreceding),</a>
<a name="ln970">          (long)G.crec.relative_offset_local_header - (long)(*pEndprev)));</a>
<a name="ln971">    }</a>
<a name="ln972"> </a>
<a name="ln973">    /* calculate endprev for next time around (problem:  extra fields may</a>
<a name="ln974">     * differ in length between local and central-directory records) */</a>
<a name="ln975">    *pEndprev = G.crec.relative_offset_local_header + (4L + LREC_SIZE) +</a>
<a name="ln976">      G.crec.filename_length + G.crec.extra_field_length + G.crec.csize;</a>
<a name="ln977"> </a>
<a name="ln978">/*---------------------------------------------------------------------------</a>
<a name="ln979">    Read the extra field, if any. It may be used to get UNIX style modtime.</a>
<a name="ln980">  ---------------------------------------------------------------------------*/</a>
<a name="ln981"> </a>
<a name="ln982">    if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD)) != 0)</a>
<a name="ln983">    {</a>
<a name="ln984">        if (G.extra_field != NULL) {</a>
<a name="ln985">            free(G.extra_field);</a>
<a name="ln986">            G.extra_field = NULL;</a>
<a name="ln987">        }</a>
<a name="ln988">        error_in_archive = error;</a>
<a name="ln989">        /* The premature return in case of a &quot;fatal&quot; error (PK_EOF) is</a>
<a name="ln990">         * delayed until we analyze the extra field contents.</a>
<a name="ln991">         * This allows us to display all the other info that has been</a>
<a name="ln992">         * successfully read in.</a>
<a name="ln993">         */</a>
<a name="ln994">    }</a>
<a name="ln995"> </a>
<a name="ln996">/*---------------------------------------------------------------------------</a>
<a name="ln997">    Print out various interesting things about the compressed file.</a>
<a name="ln998">  ---------------------------------------------------------------------------*/</a>
<a name="ln999"> </a>
<a name="ln1000">    hostnum = (unsigned)(G.pInfo-&gt;hostnum);</a>
<a name="ln1001">    hostver = (unsigned)(G.pInfo-&gt;hostver);</a>
<a name="ln1002">    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);</a>
<a name="ln1003">    extver = (unsigned)G.crec.version_needed_to_extract[0];</a>
<a name="ln1004">    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);</a>
<a name="ln1005"> </a>
<a name="ln1006">    (*G.message)((zvoid *)&amp;G, (uch *)&quot;  &quot;, 2L, 0);  fnprint(__G);</a>
<a name="ln1007"> </a>
<a name="ln1008">    Info(slide, 0, ((char *)slide, LoadFarString(LocalHeaderOffset),</a>
<a name="ln1009">      G.crec.relative_offset_local_header,</a>
<a name="ln1010">      G.crec.relative_offset_local_header));</a>
<a name="ln1011"> </a>
<a name="ln1012">    if (hostnum &gt;= NUM_HOSTS) {</a>
<a name="ln1013">        sprintf(unkn, LoadFarString(UnknownNo),</a>
<a name="ln1014">                (int)G.crec.version_made_by[1]);</a>
<a name="ln1015">        varmsg_str = unkn;</a>
<a name="ln1016">    } else {</a>
<a name="ln1017">        varmsg_str = LoadFarStringSmall(os[hostnum]);</a>
<a name="ln1018">#ifdef OLD_THEOS_EXTRA</a>
<a name="ln1019">        if (hostnum == FS_VFAT_ &amp;&amp; hostver == 20) {</a>
<a name="ln1020">            /* entry made by old non-official THEOS port zip archive */</a>
<a name="ln1021">            varmsg_str = LoadFarStringSmall(OS_TheosOld);</a>
<a name="ln1022">        }</a>
<a name="ln1023">#endif /* OLD_THEOS_EXTRA */</a>
<a name="ln1024">    }</a>
<a name="ln1025">    Info(slide, 0, ((char *)slide, LoadFarString(HostOS), varmsg_str));</a>
<a name="ln1026">    Info(slide, 0, ((char *)slide, LoadFarString(EncodeSWVer), hostver/10,</a>
<a name="ln1027">      hostver%10));</a>
<a name="ln1028"> </a>
<a name="ln1029">    if (extnum &gt;= NUM_HOSTS) {</a>
<a name="ln1030">        sprintf(unkn, LoadFarString(UnknownNo),</a>
<a name="ln1031">                (int)G.crec.version_needed_to_extract[1]);</a>
<a name="ln1032">        varmsg_str = unkn;</a>
<a name="ln1033">    } else {</a>
<a name="ln1034">        varmsg_str = LoadFarStringSmall(os[extnum]);</a>
<a name="ln1035">    }</a>
<a name="ln1036">    Info(slide, 0, ((char *)slide, LoadFarString(MinOSCompReq), varmsg_str));</a>
<a name="ln1037">    Info(slide, 0, ((char *)slide, LoadFarString(MinSWVerReq), extver/10,</a>
<a name="ln1038">      extver%10));</a>
<a name="ln1039"> </a>
<a name="ln1040">    if (methnum &gt;= NUM_METHODS) {</a>
<a name="ln1041">        sprintf(unkn, LoadFarString(UnknownNo), G.crec.compression_method);</a>
<a name="ln1042">        varmsg_str = unkn;</a>
<a name="ln1043">    } else {</a>
<a name="ln1044">        varmsg_str = LoadFarStringSmall(method[methnum]);</a>
<a name="ln1045">    }</a>
<a name="ln1046">    Info(slide, 0, ((char *)slide, LoadFarString(CompressMethod), varmsg_str));</a>
<a name="ln1047">    if (methnum == IMPLODED) {</a>
<a name="ln1048">        Info(slide, 0, ((char *)slide, LoadFarString(SlideWindowSizeImplode),</a>
<a name="ln1049">          (G.crec.general_purpose_bit_flag &amp; 2)? '8' : '4'));</a>
<a name="ln1050">        Info(slide, 0, ((char *)slide, LoadFarString(ShannonFanoTrees),</a>
<a name="ln1051">          (G.crec.general_purpose_bit_flag &amp; 4)? '3' : '2'));</a>
<a name="ln1052">    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {</a>
<a name="ln1053">        ush  dnum=(ush)((G.crec.general_purpose_bit_flag&gt;&gt;1) &amp; 3);</a>
<a name="ln1054"> </a>
<a name="ln1055">        Info(slide, 0, ((char *)slide, LoadFarString(CompressSubtype),</a>
<a name="ln1056">          LoadFarStringSmall(dtypelng[dnum])));</a>
<a name="ln1057">    }</a>
<a name="ln1058"> </a>
<a name="ln1059">    Info(slide, 0, ((char *)slide, LoadFarString(FileSecurity),</a>
<a name="ln1060">      (G.crec.general_purpose_bit_flag &amp; 1) ? nullStr : &quot;not &quot;));</a>
<a name="ln1061">    Info(slide, 0, ((char *)slide, LoadFarString(ExtendedLocalHdr),</a>
<a name="ln1062">      (G.crec.general_purpose_bit_flag &amp; 8) ? &quot;yes&quot; : &quot;no&quot;));</a>
<a name="ln1063">    /* print upper 3 bits for amusement? */</a>
<a name="ln1064"> </a>
<a name="ln1065">    /* For printing of date &amp; time, a &quot;char d_t_buf[21]&quot; is required.</a>
<a name="ln1066">     * To save stack space, we reuse the &quot;char attribs[22]&quot; buffer which</a>
<a name="ln1067">     * is not used yet.</a>
<a name="ln1068">     */</a>
<a name="ln1069">#   define d_t_buf attribs</a>
<a name="ln1070"> </a>
<a name="ln1071">    zi_time(__G__ &amp;G.crec.last_mod_dos_datetime, NULL, d_t_buf);</a>
<a name="ln1072">    Info(slide, 0, ((char *)slide, LoadFarString(FileModDate), d_t_buf));</a>
<a name="ln1073">#ifdef USE_EF_UT_TIME</a>
<a name="ln1074">    if (G.extra_field &amp;&amp;</a>
<a name="ln1075">#ifdef IZ_CHECK_TZ</a>
<a name="ln1076">        G.tz_is_valid &amp;&amp;</a>
<a name="ln1077">#endif</a>
<a name="ln1078">        (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,</a>
<a name="ln1079">                          G.crec.last_mod_dos_datetime, &amp;z_utime, NULL)</a>
<a name="ln1080">         &amp; EB_UT_FL_MTIME))</a>
<a name="ln1081">    {</a>
<a name="ln1082">        TIMET_TO_NATIVE(z_utime.mtime)   /* NOP unless MSC 7.0 or Macintosh */</a>
<a name="ln1083">        d_t_buf[0] = (char)0;               /* signal &quot;show local time&quot; */</a>
<a name="ln1084">        zi_time(__G__ &amp;G.crec.last_mod_dos_datetime, &amp;(z_utime.mtime), d_t_buf);</a>
<a name="ln1085">        Info(slide, 0, ((char *)slide, LoadFarString(UT_FileModDate),</a>
<a name="ln1086">          d_t_buf, LoadFarStringSmall(LocalTime)));</a>
<a name="ln1087">#ifndef NO_GMTIME</a>
<a name="ln1088">        d_t_buf[0] = (char)1;           /* signal &quot;show UTC (GMT) time&quot; */</a>
<a name="ln1089">        zi_time(__G__ &amp;G.crec.last_mod_dos_datetime, &amp;(z_utime.mtime), d_t_buf);</a>
<a name="ln1090">        Info(slide, 0, ((char *)slide, LoadFarString(UT_FileModDate),</a>
<a name="ln1091">          d_t_buf, LoadFarStringSmall(GMTime)));</a>
<a name="ln1092">#endif /* !NO_GMTIME */</a>
<a name="ln1093">    }</a>
<a name="ln1094">#endif /* USE_EF_UT_TIME */</a>
<a name="ln1095"> </a>
<a name="ln1096">    Info(slide, 0, ((char *)slide, LoadFarString(CRC32Value), G.crec.crc32));</a>
<a name="ln1097">    Info(slide, 0, ((char *)slide, LoadFarString(CompressedFileSize),</a>
<a name="ln1098">      G.crec.csize));</a>
<a name="ln1099">    Info(slide, 0, ((char *)slide, LoadFarString(UncompressedFileSize),</a>
<a name="ln1100">      G.crec.ucsize));</a>
<a name="ln1101">    Info(slide, 0, ((char *)slide, LoadFarString(FilenameLength),</a>
<a name="ln1102">      G.crec.filename_length));</a>
<a name="ln1103">    Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldLength),</a>
<a name="ln1104">      G.crec.extra_field_length));</a>
<a name="ln1105">    Info(slide, 0, ((char *)slide, LoadFarString(FileCommentLength),</a>
<a name="ln1106">      G.crec.file_comment_length));</a>
<a name="ln1107">    Info(slide, 0, ((char *)slide, LoadFarString(FileDiskNum),</a>
<a name="ln1108">      G.crec.disk_number_start + 1));</a>
<a name="ln1109">    Info(slide, 0, ((char *)slide, LoadFarString(ApparentFileType),</a>
<a name="ln1110">      (G.crec.internal_file_attributes &amp; 1)? &quot;text&quot;</a>
<a name="ln1111">         : (G.crec.internal_file_attributes &amp; 2)? &quot;ebcdic&quot;</a>
<a name="ln1112">              : &quot;binary&quot;));             /* changed to accept EBCDIC */</a>
<a name="ln1113">#ifdef ATARI</a>
<a name="ln1114">    printf(&quot;  external file attributes (hex):                   %.8lx\n&quot;,</a>
<a name="ln1115">      G.crec.external_file_attributes);</a>
<a name="ln1116">#endif</a>
<a name="ln1117">    xattr = (unsigned)((G.crec.external_file_attributes &gt;&gt; 16) &amp; 0xFFFF);</a>
<a name="ln1118">    if (hostnum == VMS_) {</a>
<a name="ln1119">        char   *p=attribs, *q=attribs+1;</a>
<a name="ln1120">        int    i, j, k;</a>
<a name="ln1121"> </a>
<a name="ln1122">        for (k = 0;  k &lt; 12;  ++k)</a>
<a name="ln1123">            workspace[k] = 0;</a>
<a name="ln1124">        if (xattr &amp; VMS_IRUSR)</a>
<a name="ln1125">            workspace[0] = 'R';</a>
<a name="ln1126">        if (xattr &amp; VMS_IWUSR) {</a>
<a name="ln1127">            workspace[1] = 'W';</a>
<a name="ln1128">            workspace[3] = 'D';</a>
<a name="ln1129">        }</a>
<a name="ln1130">        if (xattr &amp; VMS_IXUSR)</a>
<a name="ln1131">            workspace[2] = 'E';</a>
<a name="ln1132">        if (xattr &amp; VMS_IRGRP)</a>
<a name="ln1133">            workspace[4] = 'R';</a>
<a name="ln1134">        if (xattr &amp; VMS_IWGRP) {</a>
<a name="ln1135">            workspace[5] = 'W';</a>
<a name="ln1136">            workspace[7] = 'D';</a>
<a name="ln1137">        }</a>
<a name="ln1138">        if (xattr &amp; VMS_IXGRP)</a>
<a name="ln1139">            workspace[6] = 'E';</a>
<a name="ln1140">        if (xattr &amp; VMS_IROTH)</a>
<a name="ln1141">            workspace[8] = 'R';</a>
<a name="ln1142">        if (xattr &amp; VMS_IWOTH) {</a>
<a name="ln1143">            workspace[9] = 'W';</a>
<a name="ln1144">            workspace[11] = 'D';</a>
<a name="ln1145">        }</a>
<a name="ln1146">        if (xattr &amp; VMS_IXOTH)</a>
<a name="ln1147">            workspace[10] = 'E';</a>
<a name="ln1148"> </a>
<a name="ln1149">        *p++ = '(';</a>
<a name="ln1150">        for (k = j = 0;  j &lt; 3;  ++j) {    /* loop over groups of permissions */</a>
<a name="ln1151">            for (i = 0;  i &lt; 4;  ++i, ++k)  /* loop over perms within a group */</a>
<a name="ln1152">                if (workspace[k])</a>
<a name="ln1153">                    *p++ = workspace[k];</a>
<a name="ln1154">            *p++ = ',';                       /* group separator */</a>
<a name="ln1155">            if (j == 0)</a>
<a name="ln1156">                while ((*p++ = *q++) != ',')</a>
<a name="ln1157">                    ;                         /* system, owner perms are same */</a>
<a name="ln1158">        }</a>
<a name="ln1159">        *p-- = '\0';</a>
<a name="ln1160">        *p = ')';   /* overwrite last comma */</a>
<a name="ln1161">        Info(slide, 0, ((char *)slide, LoadFarString(VMSFileAttributes), xattr,</a>
<a name="ln1162">          attribs));</a>
<a name="ln1163"> </a>
<a name="ln1164">    } else if (hostnum == AMIGA_) {</a>
<a name="ln1165">        switch (xattr &amp; AMI_IFMT) {</a>
<a name="ln1166">            case AMI_IFDIR:  attribs[0] = 'd';  break;</a>
<a name="ln1167">            case AMI_IFREG:  attribs[0] = '-';  break;</a>
<a name="ln1168">            default:         attribs[0] = '?';  break;</a>
<a name="ln1169">        }</a>
<a name="ln1170">        attribs[1] = (xattr &amp; AMI_IHIDDEN)?   'h' : '-';</a>
<a name="ln1171">        attribs[2] = (xattr &amp; AMI_ISCRIPT)?   's' : '-';</a>
<a name="ln1172">        attribs[3] = (xattr &amp; AMI_IPURE)?     'p' : '-';</a>
<a name="ln1173">        attribs[4] = (xattr &amp; AMI_IARCHIVE)?  'a' : '-';</a>
<a name="ln1174">        attribs[5] = (xattr &amp; AMI_IREAD)?     'r' : '-';</a>
<a name="ln1175">        attribs[6] = (xattr &amp; AMI_IWRITE)?    'w' : '-';</a>
<a name="ln1176">        attribs[7] = (xattr &amp; AMI_IEXECUTE)?  'e' : '-';</a>
<a name="ln1177">        attribs[8] = (xattr &amp; AMI_IDELETE)?   'd' : '-';</a>
<a name="ln1178">        attribs[9] = 0;   /* better dlm the string */</a>
<a name="ln1179">        Info(slide, 0, ((char *)slide, LoadFarString(AmigaFileAttributes),</a>
<a name="ln1180">          xattr, attribs));</a>
<a name="ln1181"> </a>
<a name="ln1182">    } else if (hostnum == THEOS_) {</a>
<a name="ln1183">        ZCONST char Far *fpFtyp;</a>
<a name="ln1184"> </a>
<a name="ln1185">        switch (xattr &amp; THS_IFMT) {</a>
<a name="ln1186">            case THS_IFLIB:  fpFtyp = TheosFTypLib;  break;</a>
<a name="ln1187">            case THS_IFDIR:  fpFtyp = TheosFTypDir;  break;</a>
<a name="ln1188">            case THS_IFREG:  fpFtyp = TheosFTypReg;  break;</a>
<a name="ln1189">            case THS_IFREL:  fpFtyp = TheosFTypRel;  break;</a>
<a name="ln1190">            case THS_IFKEY:  fpFtyp = TheosFTypKey;  break;</a>
<a name="ln1191">            case THS_IFIND:  fpFtyp = TheosFTypInd;  break;</a>
<a name="ln1192">            case THS_IFR16:  fpFtyp = TheosFTypR16;  break;</a>
<a name="ln1193">            case THS_IFP16:  fpFtyp = TheosFTypP16;  break;</a>
<a name="ln1194">            case THS_IFP32:  fpFtyp = TheosFTypP32;  break;</a>
<a name="ln1195">            default:         fpFtyp = TheosFTypUkn;  break;</a>
<a name="ln1196">        }</a>
<a name="ln1197">        strcpy(attribs, LoadFarStringSmall(fpFtyp));</a>
<a name="ln1198">        attribs[12] = (xattr &amp; THS_INHID) ? '.' : 'H';</a>
<a name="ln1199">        attribs[13] = (xattr &amp; THS_IMODF) ? '.' : 'M';</a>
<a name="ln1200">        attribs[14] = (xattr &amp; THS_IWOTH) ? '.' : 'W';</a>
<a name="ln1201">        attribs[15] = (xattr &amp; THS_IROTH) ? '.' : 'R';</a>
<a name="ln1202">        attribs[16] = (xattr &amp; THS_IEUSR) ? '.' : 'E';</a>
<a name="ln1203">        attribs[17] = (xattr &amp; THS_IXUSR) ? '.' : 'X';</a>
<a name="ln1204">        attribs[18] = (xattr &amp; THS_IWUSR) ? '.' : 'W';</a>
<a name="ln1205">        attribs[19] = (xattr &amp; THS_IRUSR) ? '.' : 'R';</a>
<a name="ln1206">        attribs[20] = 0;</a>
<a name="ln1207">        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),</a>
<a name="ln1208">          xattr, attribs));</a>
<a name="ln1209"> </a>
<a name="ln1210">#ifdef OLD_THEOS_EXTRA</a>
<a name="ln1211">    } else if (hostnum == FS_VFAT_ &amp;&amp; hostver == 20) {</a>
<a name="ln1212">        /* process old non-official THEOS port zip archive */</a>
<a name="ln1213">        ZCONST char Far *fpFtyp;</a>
<a name="ln1214"> </a>
<a name="ln1215">        switch (xattr &amp; _THS_IFMT) {</a>
<a name="ln1216">            case _THS_IFLIB:  fpFtyp = TheosFTypLib;  break;</a>
<a name="ln1217">            case _THS_IFDIR:  fpFtyp = TheosFTypDir;  break;</a>
<a name="ln1218">            case _THS_IFREG:  fpFtyp = TheosFTypReg;  break;</a>
<a name="ln1219">            case _THS_IODRC:  fpFtyp = TheosFTypRel;  break;</a>
<a name="ln1220">            case _THS_IOKEY:  fpFtyp = TheosFTypKey;  break;</a>
<a name="ln1221">            case _THS_IOIND:  fpFtyp = TheosFTypInd;  break;</a>
<a name="ln1222">            case _THS_IOPRG:  fpFtyp = TheosFTypR16;  break;</a>
<a name="ln1223">            case _THS_IO286:  fpFtyp = TheosFTypP16;  break;</a>
<a name="ln1224">            case _THS_IO386:  fpFtyp = TheosFTypP32;  break;</a>
<a name="ln1225">            default:         fpFtyp = TheosFTypUkn;  break;</a>
<a name="ln1226">        }</a>
<a name="ln1227">        strcpy(attribs, LoadFarStringSmall(fpFtyp));</a>
<a name="ln1228">        attribs[12] = (xattr &amp; _THS_HIDDN) ? 'H' : '.';</a>
<a name="ln1229">        attribs[13] = (xattr &amp; _THS_IXOTH) ? '.' : 'X';</a>
<a name="ln1230">        attribs[14] = (xattr &amp; _THS_IWOTH) ? '.' : 'W';</a>
<a name="ln1231">        attribs[15] = (xattr &amp; _THS_IROTH) ? '.' : 'R';</a>
<a name="ln1232">        attribs[16] = (xattr &amp; _THS_IEUSR) ? '.' : 'E';</a>
<a name="ln1233">        attribs[17] = (xattr &amp; _THS_IXUSR) ? '.' : 'X';</a>
<a name="ln1234">        attribs[18] = (xattr &amp; _THS_IWUSR) ? '.' : 'W';</a>
<a name="ln1235">        attribs[19] = (xattr &amp; _THS_IRUSR) ? '.' : 'R';</a>
<a name="ln1236">        attribs[20] = 0;</a>
<a name="ln1237">        Info(slide, 0, ((char *)slide, LoadFarString(TheosFileAttributes),</a>
<a name="ln1238">          xattr, attribs));</a>
<a name="ln1239">#endif /* OLD_THEOS_EXTRA */</a>
<a name="ln1240"> </a>
<a name="ln1241">    } else if ((hostnum != FS_FAT_) &amp;&amp; (hostnum != FS_HPFS_) &amp;&amp;</a>
<a name="ln1242">               (hostnum != FS_NTFS_) &amp;&amp; (hostnum != FS_VFAT_) &amp;&amp;</a>
<a name="ln1243">               (hostnum != ACORN_) &amp;&amp;</a>
<a name="ln1244">               (hostnum != VM_CMS_) &amp;&amp; (hostnum != MVS_))</a>
<a name="ln1245">    {                                 /* assume Unix-like */</a>
<a name="ln1246">        switch ((unsigned)(xattr &amp; UNX_IFMT)) {</a>
<a name="ln1247">            case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;</a>
<a name="ln1248">            case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;</a>
<a name="ln1249">            case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;</a>
<a name="ln1250">            case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;</a>
<a name="ln1251">            case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;</a>
<a name="ln1252">            case (unsigned)UNX_IFIFO:   attribs[0] = 'p';  break;</a>
<a name="ln1253">            case (unsigned)UNX_IFSOCK:  attribs[0] = 's';  break;</a>
<a name="ln1254">            default:          attribs[0] = '?';  break;</a>
<a name="ln1255">        }</a>
<a name="ln1256">        attribs[1] = (xattr &amp; UNX_IRUSR)? 'r' : '-';</a>
<a name="ln1257">        attribs[4] = (xattr &amp; UNX_IRGRP)? 'r' : '-';</a>
<a name="ln1258">        attribs[7] = (xattr &amp; UNX_IROTH)? 'r' : '-';</a>
<a name="ln1259"> </a>
<a name="ln1260">        attribs[2] = (xattr &amp; UNX_IWUSR)? 'w' : '-';</a>
<a name="ln1261">        attribs[5] = (xattr &amp; UNX_IWGRP)? 'w' : '-';</a>
<a name="ln1262">        attribs[8] = (xattr &amp; UNX_IWOTH)? 'w' : '-';</a>
<a name="ln1263"> </a>
<a name="ln1264">        if (xattr &amp; UNX_IXUSR)</a>
<a name="ln1265">            attribs[3] = (xattr &amp; UNX_ISUID)? 's' : 'x';</a>
<a name="ln1266">        else</a>
<a name="ln1267">            attribs[3] = (xattr &amp; UNX_ISUID)? 'S' : '-';   /* S = undefined */</a>
<a name="ln1268">        if (xattr &amp; UNX_IXGRP)</a>
<a name="ln1269">            attribs[6] = (xattr &amp; UNX_ISGID)? 's' : 'x';   /* == UNX_ENFMT */</a>
<a name="ln1270">        else</a>
<a name="ln1271">            attribs[6] = (xattr &amp; UNX_ISGID)? 'l' : '-';</a>
<a name="ln1272">        if (xattr &amp; UNX_IXOTH)</a>
<a name="ln1273">            attribs[9] = (xattr &amp; UNX_ISVTX)? 't' : 'x';   /* &quot;sticky bit&quot; */</a>
<a name="ln1274">        else</a>
<a name="ln1275">            attribs[9] = (xattr &amp; UNX_ISVTX)? 'T' : '-';   /* T = undefined */</a>
<a name="ln1276">        attribs[10] = 0;</a>
<a name="ln1277"> </a>
<a name="ln1278">        Info(slide, 0, ((char *)slide, LoadFarString(UnixFileAttributes), xattr,</a>
<a name="ln1279">          attribs));</a>
<a name="ln1280"> </a>
<a name="ln1281">    } else {</a>
<a name="ln1282">        Info(slide, 0, ((char *)slide, LoadFarString(NonMSDOSFileAttributes),</a>
<a name="ln1283">            G.crec.external_file_attributes &gt;&gt; 8));</a>
<a name="ln1284"> </a>
<a name="ln1285">    } /* endif (hostnum: external attributes format) */</a>
<a name="ln1286"> </a>
<a name="ln1287">    if ((xattr=(unsigned)(G.crec.external_file_attributes &amp; 0xFF)) == 0)</a>
<a name="ln1288">        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributes),</a>
<a name="ln1289">          xattr));</a>
<a name="ln1290">    else if (xattr == 1)</a>
<a name="ln1291">        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributesRO),</a>
<a name="ln1292">          xattr));</a>
<a name="ln1293">    else</a>
<a name="ln1294">        Info(slide, 0, ((char *)slide, LoadFarString(MSDOSFileAttributesAlpha),</a>
<a name="ln1295">          xattr, (xattr&amp;1)? &quot;rdo &quot; : nullStr,</a>
<a name="ln1296">          (xattr&amp;2)? &quot;hid &quot; : nullStr,</a>
<a name="ln1297">          (xattr&amp;4)? &quot;sys &quot; : nullStr,</a>
<a name="ln1298">          (xattr&amp;8)? &quot;lab &quot; : nullStr,</a>
<a name="ln1299">          (xattr&amp;16)? &quot;dir &quot; : nullStr,</a>
<a name="ln1300">          (xattr&amp;32)? &quot;arc &quot; : nullStr,</a>
<a name="ln1301">          (xattr&amp;64)? &quot;lnk &quot; : nullStr,</a>
<a name="ln1302">          (xattr&amp;128)? &quot;exe&quot; : nullStr));</a>
<a name="ln1303"> </a>
<a name="ln1304">/*---------------------------------------------------------------------------</a>
<a name="ln1305">    Analyze the extra field, if any, and print the file comment, if any (the</a>
<a name="ln1306">    filename has already been printed, above).  That finishes up this file</a>
<a name="ln1307">    entry...</a>
<a name="ln1308">  ---------------------------------------------------------------------------*/</a>
<a name="ln1309"> </a>
<a name="ln1310">    if (G.crec.extra_field_length &gt; 0) {</a>
<a name="ln1311">        uch *ef_ptr = G.extra_field;</a>
<a name="ln1312">        ush ef_len = G.crec.extra_field_length;</a>
<a name="ln1313">        ush eb_id, eb_datalen;</a>
<a name="ln1314">        ZCONST char Far *ef_fieldname;</a>
<a name="ln1315"> </a>
<a name="ln1316">        if (error_in_archive &gt; PK_WARN)   /* fatal:  can't continue */</a>
<a name="ln1317">            /* delayed &quot;fatal error&quot; return from extra field reading */</a>
<a name="ln1318">            return error;</a>
<a name="ln1319">        if (G.extra_field == (uch *)NULL)</a>
<a name="ln1320">            return PK_ERR;   /* not consistent with crec length */</a>
<a name="ln1321"> </a>
<a name="ln1322">        Info(slide, 0, ((char *)slide, LoadFarString(ExtraFields)));</a>
<a name="ln1323"> </a>
<a name="ln1324">        while (ef_len &gt;= EB_HEADSIZE) {</a>
<a name="ln1325">            eb_id = makeword(&amp;ef_ptr[EB_ID]);</a>
<a name="ln1326">            eb_datalen = makeword(&amp;ef_ptr[EB_LEN]);</a>
<a name="ln1327">            ef_ptr += EB_HEADSIZE;</a>
<a name="ln1328">            ef_len -= EB_HEADSIZE;</a>
<a name="ln1329"> </a>
<a name="ln1330">            if (eb_datalen &gt; (ush)ef_len) {</a>
<a name="ln1331">                Info(slide, 0x421, ((char *)slide,</a>
<a name="ln1332">                  LoadFarString(ExtraFieldTrunc), eb_id, eb_datalen, ef_len));</a>
<a name="ln1333">                eb_datalen = ef_len;</a>
<a name="ln1334">            }</a>
<a name="ln1335"> </a>
<a name="ln1336">            switch (eb_id) {</a>
<a name="ln1337">                case EF_PKSZ64:</a>
<a name="ln1338">                    ef_fieldname = efPKSZ64;</a>
<a name="ln1339">                    break;</a>
<a name="ln1340">                case EF_AV:</a>
<a name="ln1341">                    ef_fieldname = efAV;</a>
<a name="ln1342">                    break;</a>
<a name="ln1343">                case EF_OS2:</a>
<a name="ln1344">                    ef_fieldname = efOS2;</a>
<a name="ln1345">                    break;</a>
<a name="ln1346">                case EF_ACL:</a>
<a name="ln1347">                    ef_fieldname = efACL;</a>
<a name="ln1348">                    break;</a>
<a name="ln1349">                case EF_NTSD:</a>
<a name="ln1350">                    ef_fieldname = efNTSD;</a>
<a name="ln1351">                    break;</a>
<a name="ln1352">                case EF_PKVMS:</a>
<a name="ln1353">                    ef_fieldname = efPKVMS;</a>
<a name="ln1354">                    break;</a>
<a name="ln1355">                case EF_IZVMS:</a>
<a name="ln1356">                    ef_fieldname = efIZVMS;</a>
<a name="ln1357">                    break;</a>
<a name="ln1358">                case EF_PKW32:</a>
<a name="ln1359">                    ef_fieldname = efPKWin32;</a>
<a name="ln1360">                    break;</a>
<a name="ln1361">                case EF_PKUNIX:</a>
<a name="ln1362">                    ef_fieldname = efPKUnix;</a>
<a name="ln1363">                    break;</a>
<a name="ln1364">                case EF_IZUNIX:</a>
<a name="ln1365">                    ef_fieldname = efIZUnix;</a>
<a name="ln1366">                    if (hostnum == UNIX_ &amp;&amp; *pEndprev &gt; 0L)</a>
<a name="ln1367">                        *pEndprev += 4L;  /* also have UID/GID in local copy */</a>
<a name="ln1368">                    break;</a>
<a name="ln1369">                case EF_IZUNIX2:</a>
<a name="ln1370">                    ef_fieldname = efIZUnix2;</a>
<a name="ln1371">                    if (*pEndprev &gt; 0L)</a>
<a name="ln1372">                        *pEndprev += 4L;  /* 4 byte UID/GID in local copy */</a>
<a name="ln1373">                    break;</a>
<a name="ln1374">                case EF_TIME:</a>
<a name="ln1375">                    ef_fieldname = efTime;</a>
<a name="ln1376">                    break;</a>
<a name="ln1377">                case EF_MAC3:</a>
<a name="ln1378">                    ef_fieldname = efMac3;</a>
<a name="ln1379">                    break;</a>
<a name="ln1380">                case EF_JLMAC:</a>
<a name="ln1381">                    ef_fieldname = efJLMac;</a>
<a name="ln1382">                    break;</a>
<a name="ln1383">                case EF_ZIPIT:</a>
<a name="ln1384">                    ef_fieldname = efZipIt;</a>
<a name="ln1385">                    break;</a>
<a name="ln1386">                case EF_ZIPIT2:</a>
<a name="ln1387">                    ef_fieldname = efZipIt2;</a>
<a name="ln1388">                    break;</a>
<a name="ln1389">                case EF_VMCMS:</a>
<a name="ln1390">                    ef_fieldname = efVMCMS;</a>
<a name="ln1391">                    break;</a>
<a name="ln1392">                case EF_MVS:</a>
<a name="ln1393">                    ef_fieldname = efMVS;</a>
<a name="ln1394">                    break;</a>
<a name="ln1395">                case EF_BEOS:</a>
<a name="ln1396">                    ef_fieldname = efBeOS;</a>
<a name="ln1397">                    break;</a>
<a name="ln1398">                case EF_QDOS:</a>
<a name="ln1399">                    ef_fieldname = efQDOS;</a>
<a name="ln1400">                    break;</a>
<a name="ln1401">                case EF_AOSVS:</a>
<a name="ln1402">                    ef_fieldname = efAOSVS;</a>
<a name="ln1403">                    break;</a>
<a name="ln1404">                case EF_SPARK:   /* from RISC OS */</a>
<a name="ln1405">                    ef_fieldname = efSpark;</a>
<a name="ln1406">                    break;</a>
<a name="ln1407">                case EF_MD5:</a>
<a name="ln1408">                    ef_fieldname = efMD5;</a>
<a name="ln1409">                    break;</a>
<a name="ln1410">                case EF_ASIUNIX:</a>
<a name="ln1411">                    ef_fieldname = efASiUnix;</a>
<a name="ln1412">                    break;</a>
<a name="ln1413">                case EF_TANDEM:</a>
<a name="ln1414">                    ef_fieldname = efTandem;</a>
<a name="ln1415">                    break;</a>
<a name="ln1416">                case EF_SMARTZIP:</a>
<a name="ln1417">                    ef_fieldname = efSmartZip;</a>
<a name="ln1418">                    break;</a>
<a name="ln1419">                case EF_THEOS:</a>
<a name="ln1420">#ifdef OLD_THEOS_EXTRA</a>
<a name="ln1421">                case EF_THEOSO:</a>
<a name="ln1422">#endif</a>
<a name="ln1423">                    ef_fieldname = efTheos;</a>
<a name="ln1424">                    break;</a>
<a name="ln1425">                default:</a>
<a name="ln1426">                    ef_fieldname = efUnknown;</a>
<a name="ln1427">                    break;</a>
<a name="ln1428">            }</a>
<a name="ln1429">            Info(slide, 0, ((char *)slide, LoadFarString(ExtraFieldType),</a>
<a name="ln1430">                 eb_id, LoadFarStringSmall(ef_fieldname), eb_datalen));</a>
<a name="ln1431"> </a>
<a name="ln1432">            /* additional, field-specific information: */</a>
<a name="ln1433">            switch (eb_id) {</a>
<a name="ln1434">                case EF_OS2:</a>
<a name="ln1435">                case EF_ACL:</a>
<a name="ln1436">                    if (eb_datalen &gt;= EB_OS2_HLEN) {</a>
<a name="ln1437">                        if (eb_id == EF_OS2)</a>
<a name="ln1438">                            ef_fieldname = OS2EAs;</a>
<a name="ln1439">                        else</a>
<a name="ln1440">                            ef_fieldname = ACLdata;</a>
<a name="ln1441">                        Info(slide, 0, ((char *)slide,</a>
<a name="ln1442">                          LoadFarString(ef_fieldname), makelong(ef_ptr)));</a>
<a name="ln1443">                        *pEndprev = 0L;   /* no clue about csize of local */</a>
<a name="ln1444">                    }</a>
<a name="ln1445">                    break;</a>
<a name="ln1446">                case EF_NTSD:</a>
<a name="ln1447">                    if (eb_datalen &gt;= EB_NTSD_C_LEN) {</a>
<a name="ln1448">                        Info(slide, 0, ((char *)slide, LoadFarString(NTSDData),</a>
<a name="ln1449">                          makelong(ef_ptr)));</a>
<a name="ln1450">                        *pEndprev = 0L;   /* no clue about csize of local */</a>
<a name="ln1451">                    }</a>
<a name="ln1452">                    break;</a>
<a name="ln1453">                case EF_IZVMS:</a>
<a name="ln1454">                    if (eb_datalen &gt;= 8) {</a>
<a name="ln1455">                        char *p, q[8];</a>
<a name="ln1456">                        unsigned compr = makeword(ef_ptr+EB_IZVMS_FLGS)</a>
<a name="ln1457">                                        &amp; EB_IZVMS_BCMASK;</a>
<a name="ln1458"> </a>
<a name="ln1459">                        *q = '\0';</a>
<a name="ln1460">                        if (compr &gt; 3)</a>
<a name="ln1461">                            compr = 3;</a>
<a name="ln1462">                        if (strncmp((char *)ef_ptr, &quot;VFAB&quot;, 4) == 0)</a>
<a name="ln1463">                            p = &quot;FAB&quot;;</a>
<a name="ln1464">                        else if (strncmp((char *)ef_ptr, &quot;VALL&quot;, 4) == 0)</a>
<a name="ln1465">                            p = &quot;XABALL&quot;;</a>
<a name="ln1466">                        else if (strncmp((char *)ef_ptr, &quot;VFHC&quot;, 4) == 0)</a>
<a name="ln1467">                            p = &quot;XABFHC&quot;;</a>
<a name="ln1468">                        else if (strncmp((char *)ef_ptr, &quot;VDAT&quot;, 4) == 0)</a>
<a name="ln1469">                            p = &quot;XABDAT&quot;;</a>
<a name="ln1470">                        else if (strncmp((char *)ef_ptr, &quot;VRDT&quot;, 4) == 0)</a>
<a name="ln1471">                            p = &quot;XABRDT&quot;;</a>
<a name="ln1472">                        else if (strncmp((char *)ef_ptr, &quot;VPRO&quot;, 4) == 0)</a>
<a name="ln1473">                            p = &quot;XABPRO&quot;;</a>
<a name="ln1474">                        else if (strncmp((char *)ef_ptr, &quot;VKEY&quot;, 4) == 0)</a>
<a name="ln1475">                            p = &quot;XABKEY&quot;;</a>
<a name="ln1476">                        else if (strncmp((char *)ef_ptr, &quot;VMSV&quot;, 4) == 0) {</a>
<a name="ln1477">                            p = &quot;version&quot;;</a>
<a name="ln1478">                            if (eb_datalen &gt;= 16) {</a>
<a name="ln1479">                                q[0] = ' ';</a>
<a name="ln1480">                                q[1] = '(';</a>
<a name="ln1481">                                strncpy(q+2, (char *)ef_ptr+EB_IZVMS_HLEN, 4);</a>
<a name="ln1482">                                q[6] = ')';</a>
<a name="ln1483">                                q[7] = '\0';</a>
<a name="ln1484">                            }</a>
<a name="ln1485">                        } else</a>
<a name="ln1486">                            p = &quot;unknown&quot;;</a>
<a name="ln1487">                        Info(slide, 0, ((char *)slide,</a>
<a name="ln1488">                          LoadFarString(izVMSdata),</a>
<a name="ln1489">                          LoadFarStringSmall(izVMScomp[compr]),</a>
<a name="ln1490">                          makeword(ef_ptr+EB_IZVMS_UCSIZ), p, q));</a>
<a name="ln1491">                    }</a>
<a name="ln1492">                    break;</a>
<a name="ln1493">                case EF_TIME:</a>
<a name="ln1494">                    if (eb_datalen &gt;= 1) {</a>
<a name="ln1495">                        char types[80];</a>
<a name="ln1496">                        int num = 0, len;</a>
<a name="ln1497"> </a>
<a name="ln1498">                        *types = '\0';</a>
<a name="ln1499">                        if (*ef_ptr &amp; 1) {</a>
<a name="ln1500">                            strcpy(types, LoadFarString(UTmodification));</a>
<a name="ln1501">                            ++num;</a>
<a name="ln1502">                        }</a>
<a name="ln1503">                        if (*ef_ptr &amp; 2) {</a>
<a name="ln1504">                            len = strlen(types);</a>
<a name="ln1505">                            if (num)</a>
<a name="ln1506">                                types[len++] = '/';</a>
<a name="ln1507">                            strcpy(types+len, LoadFarString(UTaccess));</a>
<a name="ln1508">                            ++num;</a>
<a name="ln1509">                            if (*pEndprev &gt; 0L)</a>
<a name="ln1510">                                *pEndprev += 4L;</a>
<a name="ln1511">                        }</a>
<a name="ln1512">                        if (*ef_ptr &amp; 4) {</a>
<a name="ln1513">                            len = strlen(types);</a>
<a name="ln1514">                            if (num)</a>
<a name="ln1515">                                types[len++] = '/';</a>
<a name="ln1516">                            strcpy(types+len, LoadFarString(UTcreation));</a>
<a name="ln1517">                            ++num;</a>
<a name="ln1518">                            if (*pEndprev &gt; 0L)</a>
<a name="ln1519">                                *pEndprev += 4L;</a>
<a name="ln1520">                        }</a>
<a name="ln1521">                        if (num &gt; 0)</a>
<a name="ln1522">                            Info(slide, 0, ((char *)slide,</a>
<a name="ln1523">                              LoadFarString(UTdata), types,</a>
<a name="ln1524">                              num == 1? nullStr : PlurSufx));</a>
<a name="ln1525">                    }</a>
<a name="ln1526">                    break;</a>
<a name="ln1527">                case EF_MAC3:</a>
<a name="ln1528">                    if (eb_datalen &gt;= EB_MAC3_HLEN) {</a>
<a name="ln1529">                        ulg eb_uc = makelong(ef_ptr);</a>
<a name="ln1530">                        unsigned mac3_flgs = makeword(ef_ptr+EB_FLGS_OFFS);</a>
<a name="ln1531">                        unsigned eb_is_uc = mac3_flgs &amp; EB_M3_FL_UNCMPR;</a>
<a name="ln1532"> </a>
<a name="ln1533">                        Info(slide, 0, ((char *)slide, LoadFarString(Mac3data),</a>
<a name="ln1534">                          eb_uc, eb_is_uc ? &quot;un&quot; : nullStr));</a>
<a name="ln1535">                        if (eb_is_uc) {</a>
<a name="ln1536">                            if (*pEndprev &gt; 0L)</a>
<a name="ln1537">                                *pEndprev += makelong(ef_ptr);</a>
<a name="ln1538">                        } else {</a>
<a name="ln1539">                            *pEndprev = 0L; /* no clue about csize of local */</a>
<a name="ln1540">                        }</a>
<a name="ln1541"> </a>
<a name="ln1542">                        Info(slide, 0, ((char *)slide,</a>
<a name="ln1543">                          LoadFarString(MacOSMAC3flags),</a>
<a name="ln1544">                          LoadFarStringSmall(mac3_flgs &amp; EB_M3_FL_DATFRK ?</a>
<a name="ln1545">                                             MacOS_DF : MacOS_RF),</a>
<a name="ln1546">                          (mac3_flgs &amp; EB_M3_FL_TIME64 ? 64 : 32)));</a>
<a name="ln1547">                        zi_showMacTypeCreator(__G__ &amp;ef_ptr[6]);</a>
<a name="ln1548">                    }</a>
<a name="ln1549">                    break;</a>
<a name="ln1550">                case EF_ZIPIT2:</a>
<a name="ln1551">                    if (eb_datalen &gt;= 5 &amp;&amp;</a>
<a name="ln1552">                        strncmp((char *)ef_ptr, &quot;ZPIT&quot;, 4) == 0) {</a>
<a name="ln1553"> </a>
<a name="ln1554">                        if (eb_datalen &gt;= 12) {</a>
<a name="ln1555">                            zi_showMacTypeCreator(__G__ &amp;ef_ptr[4]);</a>
<a name="ln1556">                        }</a>
<a name="ln1557">                    }</a>
<a name="ln1558">                    break;</a>
<a name="ln1559">                case EF_ZIPIT:</a>
<a name="ln1560">                    if (eb_datalen &gt;= 5 &amp;&amp;</a>
<a name="ln1561">                        strncmp((char *)ef_ptr, &quot;ZPIT&quot;, 4) == 0) {</a>
<a name="ln1562">                        unsigned fnlen = ef_ptr[4];</a>
<a name="ln1563"> </a>
<a name="ln1564">                        if ((unsigned)eb_datalen &gt;= fnlen + (5 + 8)) {</a>
<a name="ln1565">                            uch nullchar = ef_ptr[fnlen+5];</a>
<a name="ln1566"> </a>
<a name="ln1567">                            ef_ptr[fnlen+5] = '\0'; /* terminate filename */</a>
<a name="ln1568">                            Info(slide, 0, ((char *)slide,</a>
<a name="ln1569">                              LoadFarString(ZipItFname), (char *)ef_ptr+5));</a>
<a name="ln1570">                            ef_ptr[fnlen+5] = nullchar;</a>
<a name="ln1571">                            zi_showMacTypeCreator(__G__ &amp;ef_ptr[fnlen+5]);</a>
<a name="ln1572">                        }</a>
<a name="ln1573">                    }</a>
<a name="ln1574">                    break;</a>
<a name="ln1575">                case EF_JLMAC:</a>
<a name="ln1576">                    if (eb_datalen &gt;= 40 &amp;&amp;</a>
<a name="ln1577">                        strncmp((char *)ef_ptr, &quot;JLEE&quot;, 4) == 0)</a>
<a name="ln1578">                    {</a>
<a name="ln1579">                        zi_showMacTypeCreator(__G__ &amp;ef_ptr[4]);</a>
<a name="ln1580"> </a>
<a name="ln1581">                        Info(slide, 0, ((char *)slide,</a>
<a name="ln1582">                          LoadFarString(MacOSJLEEflags),</a>
<a name="ln1583">                          LoadFarStringSmall(ef_ptr[31] &amp; 1 ?</a>
<a name="ln1584">                                             MacOS_DF : MacOS_RF)));</a>
<a name="ln1585">                    }</a>
<a name="ln1586">                    break;</a>
<a name="ln1587">                case EF_SMARTZIP:</a>
<a name="ln1588">                    if ((eb_datalen == EB_SMARTZIP_HLEN) &amp;&amp;</a>
<a name="ln1589">                        strncmp((char *)ef_ptr, &quot;dZip&quot;, 4) == 0) {</a>
<a name="ln1590">                        char filenameBuf[32];</a>
<a name="ln1591">                        zi_showMacTypeCreator(__G__ &amp;ef_ptr[4]);</a>
<a name="ln1592">                        memcpy(filenameBuf, &amp;ef_ptr[33], 31);</a>
<a name="ln1593">                        filenameBuf[ef_ptr[32]] = '\0';</a>
<a name="ln1594">                        Info(slide, 0, ((char *)slide,</a>
<a name="ln1595">                             LoadFarString(ZipItFname), filenameBuf));</a>
<a name="ln1596">                    }</a>
<a name="ln1597">                    break;</a>
<a name="ln1598">#ifdef CMS_MVS</a>
<a name="ln1599">                case EF_VMCMS:</a>
<a name="ln1600">                case EF_MVS:</a>
<a name="ln1601">                    {</a>
<a name="ln1602">                        char type[100];</a>
<a name="ln1603"> </a>
<a name="ln1604">                        Info(slide, 0, ((char *)slide,</a>
<a name="ln1605">                             LoadFarString(VmMvsExtraField),</a>
<a name="ln1606">                             (getVMMVSexfield(type, ef_ptr-EB_HEADSIZE,</a>
<a name="ln1607">                             (unsigned)eb_datalen) &gt; 0)?</a>
<a name="ln1608">                             type : LoadFarStringSmall(VmMvsInvalid)));</a>
<a name="ln1609">                    }</a>
<a name="ln1610">                    break;</a>
<a name="ln1611">#endif /* CMS_MVS */</a>
<a name="ln1612">                case EF_BEOS:</a>
<a name="ln1613">                    if (eb_datalen &gt;= EB_BEOS_HLEN) {</a>
<a name="ln1614">                        ulg eb_uc = makelong(ef_ptr);</a>
<a name="ln1615">                        unsigned eb_is_uc =</a>
<a name="ln1616">                          *(ef_ptr+EB_FLGS_OFFS) &amp; EB_BE_FL_UNCMPR;</a>
<a name="ln1617"> </a>
<a name="ln1618">                        Info(slide, 0, ((char *)slide, LoadFarString(BeOSdata),</a>
<a name="ln1619">                          eb_uc, eb_is_uc ? &quot;un&quot; : nullStr));</a>
<a name="ln1620">                        if (eb_is_uc) {</a>
<a name="ln1621">                            if (*pEndprev &gt; 0L)</a>
<a name="ln1622">                                *pEndprev += makelong(ef_ptr);</a>
<a name="ln1623">                        } else {</a>
<a name="ln1624">                            *pEndprev = 0L; /* no clue about csize of local */</a>
<a name="ln1625">                        }</a>
<a name="ln1626">                    }</a>
<a name="ln1627">                    break;</a>
<a name="ln1628">                case EF_QDOS:</a>
<a name="ln1629">                    if (eb_datalen &gt;= 4) {</a>
<a name="ln1630">                        Info(slide, 0, ((char *)slide, LoadFarString(QDOSdata),</a>
<a name="ln1631">                          ef_ptr[0], ef_ptr[1], ef_ptr[2], ef_ptr[3]));</a>
<a name="ln1632">                    }</a>
<a name="ln1633">                    break;</a>
<a name="ln1634">                case EF_AOSVS:</a>
<a name="ln1635">                    if (eb_datalen &gt;= 5) {</a>
<a name="ln1636">                        Info(slide, 0, ((char *)slide, LoadFarString(AOSVSdata),</a>
<a name="ln1637">                          ((int)(uch)ef_ptr[4])/10, ((int)(uch)ef_ptr[4])%10));</a>
<a name="ln1638">                    }</a>
<a name="ln1639">                    break;</a>
<a name="ln1640">                case EF_TANDEM:</a>
<a name="ln1641">                    if (eb_datalen == 20) {</a>
<a name="ln1642">                        unsigned type, code;</a>
<a name="ln1643"> </a>
<a name="ln1644">                        type = (ef_ptr[18] &amp; 0x60) &gt;&gt; 5;</a>
<a name="ln1645">                        code = makeword(ef_ptr);</a>
<a name="ln1646">                        /* Arrg..., Tandem e.f. uses BigEndian byte-order */</a>
<a name="ln1647">                        code = ((code &lt;&lt; 8) &amp; 0xff00) | ((code &gt;&gt; 8) &amp; 0x00ff);</a>
<a name="ln1648">                        if (type == NSK_UNSTRUCTURED) {</a>
<a name="ln1649">                            if (code == NSK_EDITFILECODE)</a>
<a name="ln1650">                                type = 4;</a>
<a name="ln1651">                            else if (code == NSK_OBJECTFILECODE)</a>
<a name="ln1652">                                type = 5;</a>
<a name="ln1653">                        }</a>
<a name="ln1654">                        Info(slide, 0, ((char *)slide,</a>
<a name="ln1655">                          LoadFarString(Tandemdata),</a>
<a name="ln1656">                          LoadFarStringSmall(TandemFileformat[type]),</a>
<a name="ln1657">                          code));</a>
<a name="ln1658">                    }</a>
<a name="ln1659">                    break;</a>
<a name="ln1660">                case EF_MD5:</a>
<a name="ln1661">                    if (eb_datalen &gt;= 19) {</a>
<a name="ln1662">                        char md5[33];</a>
<a name="ln1663">                        int i;</a>
<a name="ln1664"> </a>
<a name="ln1665">                        for (i = 0;  i &lt; 16;  ++i)</a>
<a name="ln1666">                            sprintf(&amp;md5[i&lt;&lt;1], &quot;%02x&quot;, ef_ptr[15-i]);</a>
<a name="ln1667">                        md5[32] = '\0';</a>
<a name="ln1668">                        Info(slide, 0, ((char *)slide, LoadFarString(MD5data),</a>
<a name="ln1669">                          md5));</a>
<a name="ln1670">                        break;</a>
<a name="ln1671">                    }   /* else: fall through !! */</a>
<a name="ln1672">                default:</a>
<a name="ln1673">                    if (eb_datalen &gt; 0) {</a>
<a name="ln1674">                        ush i, n;</a>
<a name="ln1675"> </a>
<a name="ln1676">                        if (eb_datalen &lt;= 24) {</a>
<a name="ln1677">                            Info(slide, 0, ((char *)slide,</a>
<a name="ln1678">                                 LoadFarString(ColonIndent)));</a>
<a name="ln1679">                            n = eb_datalen;</a>
<a name="ln1680">                        } else {</a>
<a name="ln1681">                            Info(slide, 0, ((char *)slide,</a>
<a name="ln1682">                                 LoadFarString(First20)));</a>
<a name="ln1683">                            n = 20;</a>
<a name="ln1684">                        }</a>
<a name="ln1685">                        for (i = 0;  i &lt; n;  ++i)</a>
<a name="ln1686">                            Info(slide, 0, ((char *)slide,</a>
<a name="ln1687">                                 LoadFarString(efFormat), ef_ptr[i]));</a>
<a name="ln1688">                    }</a>
<a name="ln1689">                    break;</a>
<a name="ln1690">            }</a>
<a name="ln1691">            (*G.message)((zvoid *)&amp;G, (uch *)&quot;.&quot;, 1L, 0);</a>
<a name="ln1692"> </a>
<a name="ln1693">            ef_ptr += eb_datalen;</a>
<a name="ln1694">            ef_len -= eb_datalen;</a>
<a name="ln1695">        }</a>
<a name="ln1696">        (*G.message)((zvoid *)&amp;G, (uch *)&quot;\n&quot;, 1L, 0);</a>
<a name="ln1697">    }</a>
<a name="ln1698"> </a>
<a name="ln1699">    /* high bit == Unix/OS2/NT GMT times (mtime, atime); next bit == UID/GID */</a>
<a name="ln1700">    if ((xattr = (unsigned)((G.crec.external_file_attributes &amp; 0xC000) &gt;&gt; 12))</a>
<a name="ln1701">        &amp; 8)</a>
<a name="ln1702">    {</a>
<a name="ln1703">        if (hostnum == UNIX_ || hostnum == FS_HPFS_ || hostnum == FS_NTFS_)</a>
<a name="ln1704">        {</a>
<a name="ln1705">            Info(slide, 0, ((char *)slide, LoadFarString(lExtraFieldType),</a>
<a name="ln1706">              &quot;is&quot;, EF_IZUNIX, LoadFarStringSmall(efIZUnix),</a>
<a name="ln1707">              (unsigned)(xattr&amp;12), (xattr&amp;4)? efIZuid : efIZnouid));</a>
<a name="ln1708">            if (*pEndprev &gt; 0L)</a>
<a name="ln1709">                *pEndprev += (ulg)(xattr&amp;12);</a>
<a name="ln1710">        }</a>
<a name="ln1711">        else if (hostnum == FS_FAT_ &amp;&amp; !(xattr&amp;4))</a>
<a name="ln1712">            Info(slide, 0, ((char *)slide, LoadFarString(lExtraFieldType),</a>
<a name="ln1713">              &quot;may be&quot;, EF_IZUNIX, LoadFarStringSmall(efIZUnix), 8,</a>
<a name="ln1714">              efIZnouid));</a>
<a name="ln1715">    }</a>
<a name="ln1716"> </a>
<a name="ln1717">    if (!G.crec.file_comment_length)</a>
<a name="ln1718">        Info(slide, 0, ((char *)slide, LoadFarString(NoFileComment)));</a>
<a name="ln1719">    else {</a>
<a name="ln1720">        Info(slide, 0, ((char *)slide, LoadFarString(FileCommBegin)));</a>
<a name="ln1721">        if ((error = do_string(__G__ G.crec.file_comment_length, DISPL_8)) !=</a>
<a name="ln1722">            PK_COOL)</a>
<a name="ln1723">        {</a>
<a name="ln1724">            error_in_archive = error;   /* might be warning */</a>
<a name="ln1725">            if (error &gt; PK_WARN)   /* fatal */</a>
<a name="ln1726">                return error;</a>
<a name="ln1727">        }</a>
<a name="ln1728">        Info(slide, 0, ((char *)slide, LoadFarString(FileCommEnd)));</a>
<a name="ln1729">    }</a>
<a name="ln1730"> </a>
<a name="ln1731">    return error_in_archive;</a>
<a name="ln1732"> </a>
<a name="ln1733">} /* end function zi_long() */</a>
<a name="ln1734"> </a>
<a name="ln1735"> </a>
<a name="ln1736"> </a>
<a name="ln1737"> </a>
<a name="ln1738"> </a>
<a name="ln1739">/*************************/</a>
<a name="ln1740">/*  Function zi_short()  */</a>
<a name="ln1741">/*************************/</a>
<a name="ln1742"> </a>
<a name="ln1743">static int zi_short(__G)   /* return PK-type error code */</a>
<a name="ln1744">    __GDEF</a>
<a name="ln1745">{</a>
<a name="ln1746">#ifdef USE_EF_UT_TIME</a>
<a name="ln1747">    iztimes     z_utime;</a>
<a name="ln1748">    time_t      *z_modtim;</a>
<a name="ln1749">#endif</a>
<a name="ln1750">    int         k, error, error_in_archive=PK_COOL;</a>
<a name="ln1751">    unsigned    hostnum, hostver, methnum, xattr;</a>
<a name="ln1752">    char        *p, workspace[12], attribs[16];</a>
<a name="ln1753">    char        methbuf[5];</a>
<a name="ln1754">    static ZCONST char dtype[5]=&quot;NXFS&quot;; /* normal, maximum, fast, superfast */</a>
<a name="ln1755">    static ZCONST char Far os[NUM_HOSTS+1][4] = {</a>
<a name="ln1756">        &quot;fat&quot;, &quot;ami&quot;, &quot;vms&quot;, &quot;unx&quot;, &quot;cms&quot;, &quot;atr&quot;, &quot;hpf&quot;, &quot;mac&quot;, &quot;zzz&quot;,</a>
<a name="ln1757">        &quot;cpm&quot;, &quot;t20&quot;, &quot;ntf&quot;, &quot;qds&quot;, &quot;aco&quot;, &quot;vft&quot;, &quot;mvs&quot;, &quot;be &quot;, &quot;nsk&quot;,</a>
<a name="ln1758">        &quot;ths&quot;, &quot;???&quot;</a>
<a name="ln1759">    };</a>
<a name="ln1760">#ifdef OLD_THEOS_EXTRA</a>
<a name="ln1761">    static ZCONST char Far os_TheosOld[] = &quot;tho&quot;;</a>
<a name="ln1762">#endif</a>
<a name="ln1763">    static ZCONST char Far method[NUM_METHODS+1][5] = {</a>
<a name="ln1764">        &quot;stor&quot;, &quot;shrk&quot;, &quot;re:1&quot;, &quot;re:2&quot;, &quot;re:3&quot;, &quot;re:4&quot;, &quot;i#:#&quot;, &quot;tokn&quot;,</a>
<a name="ln1765">        &quot;def#&quot;, &quot;d64#&quot;, &quot;dcli&quot;, &quot;u###&quot;</a>
<a name="ln1766">    };</a>
<a name="ln1767"> </a>
<a name="ln1768"> </a>
<a name="ln1769">/*---------------------------------------------------------------------------</a>
<a name="ln1770">    Print out various interesting things about the compressed file.</a>
<a name="ln1771">  ---------------------------------------------------------------------------*/</a>
<a name="ln1772"> </a>
<a name="ln1773">    methnum = (unsigned)MIN(G.crec.compression_method, NUM_METHODS);</a>
<a name="ln1774">    hostnum = (unsigned)(G.pInfo-&gt;hostnum);</a>
<a name="ln1775">    hostver = (unsigned)(G.pInfo-&gt;hostver);</a>
<a name="ln1776">/*</a>
<a name="ln1777">    extnum = (unsigned)MIN(G.crec.version_needed_to_extract[1], NUM_HOSTS);</a>
<a name="ln1778">    extver = (unsigned)G.crec.version_needed_to_extract[0];</a>
<a name="ln1779"> */</a>
<a name="ln1780"> </a>
<a name="ln1781">    zfstrcpy(methbuf, method[methnum]);</a>
<a name="ln1782">    if (methnum == IMPLODED) {</a>
<a name="ln1783">        methbuf[1] = (char)((G.crec.general_purpose_bit_flag &amp; 2)? '8' : '4');</a>
<a name="ln1784">        methbuf[3] = (char)((G.crec.general_purpose_bit_flag &amp; 4)? '3' : '2');</a>
<a name="ln1785">    } else if (methnum == DEFLATED || methnum == ENHDEFLATED) {</a>
<a name="ln1786">        ush  dnum=(ush)((G.crec.general_purpose_bit_flag&gt;&gt;1) &amp; 3);</a>
<a name="ln1787">        methbuf[3] = dtype[dnum];</a>
<a name="ln1788">    } else if (methnum &gt;= NUM_METHODS) {   /* unknown */</a>
<a name="ln1789">        sprintf(&amp;methbuf[1], &quot;%03u&quot;, G.crec.compression_method);</a>
<a name="ln1790">    }</a>
<a name="ln1791"> </a>
<a name="ln1792">    for (k = 0;  k &lt; 15;  ++k)</a>
<a name="ln1793">        attribs[k] = ' ';</a>
<a name="ln1794">    attribs[15] = 0;</a>
<a name="ln1795"> </a>
<a name="ln1796">    xattr = (unsigned)((G.crec.external_file_attributes &gt;&gt; 16) &amp; 0xFFFF);</a>
<a name="ln1797">    switch (hostnum) {</a>
<a name="ln1798">        case VMS_:</a>
<a name="ln1799">            {   int    i, j;</a>
<a name="ln1800"> </a>
<a name="ln1801">                for (k = 0;  k &lt; 12;  ++k)</a>
<a name="ln1802">                    workspace[k] = 0;</a>
<a name="ln1803">                if (xattr &amp; VMS_IRUSR)</a>
<a name="ln1804">                    workspace[0] = 'R';</a>
<a name="ln1805">                if (xattr &amp; VMS_IWUSR) {</a>
<a name="ln1806">                    workspace[1] = 'W';</a>
<a name="ln1807">                    workspace[3] = 'D';</a>
<a name="ln1808">                }</a>
<a name="ln1809">                if (xattr &amp; VMS_IXUSR)</a>
<a name="ln1810">                    workspace[2] = 'E';</a>
<a name="ln1811">                if (xattr &amp; VMS_IRGRP)</a>
<a name="ln1812">                    workspace[4] = 'R';</a>
<a name="ln1813">                if (xattr &amp; VMS_IWGRP) {</a>
<a name="ln1814">                    workspace[5] = 'W';</a>
<a name="ln1815">                    workspace[7] = 'D';</a>
<a name="ln1816">                }</a>
<a name="ln1817">                if (xattr &amp; VMS_IXGRP)</a>
<a name="ln1818">                  workspace[6] = 'E';</a>
<a name="ln1819">                if (xattr &amp; VMS_IROTH)</a>
<a name="ln1820">                    workspace[8] = 'R';</a>
<a name="ln1821">                if (xattr &amp; VMS_IWOTH) {</a>
<a name="ln1822">                    workspace[9] = 'W';</a>
<a name="ln1823">                    workspace[11] = 'D';</a>
<a name="ln1824">                }</a>
<a name="ln1825">                if (xattr &amp; VMS_IXOTH)</a>
<a name="ln1826">                    workspace[10] = 'E';</a>
<a name="ln1827"> </a>
<a name="ln1828">                p = attribs;</a>
<a name="ln1829">                for (k = j = 0;  j &lt; 3;  ++j) {     /* groups of permissions */</a>
<a name="ln1830">                    for (i = 0;  i &lt; 4;  ++i, ++k)  /* perms within a group */</a>
<a name="ln1831">                        if (workspace[k])</a>
<a name="ln1832">                            *p++ = workspace[k];</a>
<a name="ln1833">                    *p++ = ',';                     /* group separator */</a>
<a name="ln1834">                }</a>
<a name="ln1835">                *--p = ' ';   /* overwrite last comma */</a>
<a name="ln1836">                if ((p - attribs) &lt; 12)</a>
<a name="ln1837">                    sprintf(&amp;attribs[12], &quot;%u.%u&quot;, hostver/10, hostver%10);</a>
<a name="ln1838">            }</a>
<a name="ln1839">            break;</a>
<a name="ln1840"> </a>
<a name="ln1841">        case AMIGA_:</a>
<a name="ln1842">            switch (xattr &amp; AMI_IFMT) {</a>
<a name="ln1843">                case AMI_IFDIR:  attribs[0] = 'd';  break;</a>
<a name="ln1844">                case AMI_IFREG:  attribs[0] = '-';  break;</a>
<a name="ln1845">                default:         attribs[0] = '?';  break;</a>
<a name="ln1846">            }</a>
<a name="ln1847">            attribs[1] = (xattr &amp; AMI_IHIDDEN)?   'h' : '-';</a>
<a name="ln1848">            attribs[2] = (xattr &amp; AMI_ISCRIPT)?   's' : '-';</a>
<a name="ln1849">            attribs[3] = (xattr &amp; AMI_IPURE)?     'p' : '-';</a>
<a name="ln1850">            attribs[4] = (xattr &amp; AMI_IARCHIVE)?  'a' : '-';</a>
<a name="ln1851">            attribs[5] = (xattr &amp; AMI_IREAD)?     'r' : '-';</a>
<a name="ln1852">            attribs[6] = (xattr &amp; AMI_IWRITE)?    'w' : '-';</a>
<a name="ln1853">            attribs[7] = (xattr &amp; AMI_IEXECUTE)?  'e' : '-';</a>
<a name="ln1854">            attribs[8] = (xattr &amp; AMI_IDELETE)?   'd' : '-';</a>
<a name="ln1855">            sprintf(&amp;attribs[12], &quot;%u.%u&quot;, hostver/10, hostver%10);</a>
<a name="ln1856">            break;</a>
<a name="ln1857"> </a>
<a name="ln1858">        case THEOS_:</a>
<a name="ln1859">            switch (xattr &amp; THS_IFMT) {</a>
<a name="ln1860">                case THS_IFLIB: *attribs = 'L'; break;</a>
<a name="ln1861">                case THS_IFDIR: *attribs = 'D'; break;</a>
<a name="ln1862">                case THS_IFCHR: *attribs = 'C'; break;</a>
<a name="ln1863">                case THS_IFREG: *attribs = 'S'; break;</a>
<a name="ln1864">                case THS_IFREL: *attribs = 'R'; break;</a>
<a name="ln1865">                case THS_IFKEY: *attribs = 'K'; break;</a>
<a name="ln1866">                case THS_IFIND: *attribs = 'I'; break;</a>
<a name="ln1867">                case THS_IFR16: *attribs = 'P'; break;</a>
<a name="ln1868">                case THS_IFP16: *attribs = '2'; break;</a>
<a name="ln1869">                case THS_IFP32: *attribs = '3'; break;</a>
<a name="ln1870">                default:        *attribs = '?'; break;</a>
<a name="ln1871">            }</a>
<a name="ln1872">            attribs[1] = (xattr &amp; THS_INHID) ? '.' : 'H';</a>
<a name="ln1873">            attribs[2] = (xattr &amp; THS_IMODF) ? '.' : 'M';</a>
<a name="ln1874">            attribs[3] = (xattr &amp; THS_IWOTH) ? '.' : 'W';</a>
<a name="ln1875">            attribs[4] = (xattr &amp; THS_IROTH) ? '.' : 'R';</a>
<a name="ln1876">            attribs[5] = (xattr &amp; THS_IEUSR) ? '.' : 'E';</a>
<a name="ln1877">            attribs[6] = (xattr &amp; THS_IXUSR) ? '.' : 'X';</a>
<a name="ln1878">            attribs[7] = (xattr &amp; THS_IWUSR) ? '.' : 'W';</a>
<a name="ln1879">            attribs[8] = (xattr &amp; THS_IRUSR) ? '.' : 'R';</a>
<a name="ln1880">            sprintf(&amp;attribs[12], &quot;%u.%u&quot;, hostver/10, hostver%10);</a>
<a name="ln1881">            break;</a>
<a name="ln1882"> </a>
<a name="ln1883">        case FS_VFAT_:</a>
<a name="ln1884">#ifdef OLD_THEOS_EXTRA</a>
<a name="ln1885">            if (hostver == 20) {</a>
<a name="ln1886">                switch (xattr &amp; _THS_IFMT) {</a>
<a name="ln1887">                    case _THS_IFLIB: *attribs = 'L'; break;</a>
<a name="ln1888">                    case _THS_IFDIR: *attribs = 'd'; break;</a>
<a name="ln1889">                    case _THS_IFCHR: *attribs = 'c'; break;</a>
<a name="ln1890">                    case _THS_IFREG: *attribs = 'S'; break;</a>
<a name="ln1891">                    case _THS_IODRC: *attribs = 'D'; break;</a>
<a name="ln1892">                    case _THS_IOKEY: *attribs = 'K'; break;</a>
<a name="ln1893">                    case _THS_IOIND: *attribs = 'I'; break;</a>
<a name="ln1894">                    case _THS_IOPRG: *attribs = 'P'; break;</a>
<a name="ln1895">                    case _THS_IO286: *attribs = '2'; break;</a>
<a name="ln1896">                    case _THS_IO386: *attribs = '3'; break;</a>
<a name="ln1897">                    default:         *attribs = '?'; break;</a>
<a name="ln1898">                }</a>
<a name="ln1899">                attribs[1] = (xattr &amp; _THS_HIDDN) ? 'H' : '.';</a>
<a name="ln1900">                attribs[2] = (xattr &amp; _THS_IXOTH) ? '.' : 'X';</a>
<a name="ln1901">                attribs[3] = (xattr &amp; _THS_IWOTH) ? '.' : 'W';</a>
<a name="ln1902">                attribs[4] = (xattr &amp; _THS_IROTH) ? '.' : 'R';</a>
<a name="ln1903">                attribs[5] = (xattr &amp; _THS_IEUSR) ? '.' : 'E';</a>
<a name="ln1904">                attribs[6] = (xattr &amp; _THS_IXUSR) ? '.' : 'X';</a>
<a name="ln1905">                attribs[7] = (xattr &amp; _THS_IWUSR) ? '.' : 'W';</a>
<a name="ln1906">                attribs[8] = (xattr &amp; _THS_IRUSR) ? '.' : 'R';</a>
<a name="ln1907">                sprintf(&amp;attribs[12], &quot;%u.%u&quot;, hostver/10, hostver%10);</a>
<a name="ln1908">                break;</a>
<a name="ln1909">            } /* else: fall through! */</a>
<a name="ln1910">#endif /* OLD_THEOS_EXTRA */</a>
<a name="ln1911"> </a>
<a name="ln1912">        case FS_FAT_:</a>
<a name="ln1913">        case FS_HPFS_:</a>
<a name="ln1914">        case FS_NTFS_:</a>
<a name="ln1915">        case VM_CMS_:</a>
<a name="ln1916">        case MVS_:</a>
<a name="ln1917">        case ACORN_:</a>
<a name="ln1918">            if (hostnum != FS_FAT_ ||</a>
<a name="ln1919">                (unsigned)(xattr &amp; 0700) !=</a>
<a name="ln1920">                 ((unsigned)0400 |</a>
<a name="ln1921">                  ((unsigned)!(G.crec.external_file_attributes &amp; 1) &lt;&lt; 7) |</a>
<a name="ln1922">                  ((unsigned)(G.crec.external_file_attributes &amp; 0x10) &lt;&lt; 2))</a>
<a name="ln1923">               )</a>
<a name="ln1924">            {</a>
<a name="ln1925">                xattr = (unsigned)(G.crec.external_file_attributes &amp; 0xFF);</a>
<a name="ln1926">                sprintf(attribs, &quot;.r.-...     %u.%u&quot;, hostver/10, hostver%10);</a>
<a name="ln1927">                attribs[2] = (xattr &amp; 0x01)? '-' : 'w';</a>
<a name="ln1928">                attribs[5] = (xattr &amp; 0x02)? 'h' : '-';</a>
<a name="ln1929">                attribs[6] = (xattr &amp; 0x04)? 's' : '-';</a>
<a name="ln1930">                attribs[4] = (xattr &amp; 0x20)? 'a' : '-';</a>
<a name="ln1931">                if (xattr &amp; 0x10) {</a>
<a name="ln1932">                    attribs[0] = 'd';</a>
<a name="ln1933">                    attribs[3] = 'x';</a>
<a name="ln1934">                } else</a>
<a name="ln1935">                    attribs[0] = '-';</a>
<a name="ln1936">                if (IS_VOLID(xattr))</a>
<a name="ln1937">                    attribs[0] = 'V';</a>
<a name="ln1938">                else if ((p = MBSRCHR(G.filename, '.')) != (char *)NULL) {</a>
<a name="ln1939">                    ++p;</a>
<a name="ln1940">                    if (STRNICMP(p, &quot;com&quot;, 3) == 0 ||</a>
<a name="ln1941">                        STRNICMP(p, &quot;exe&quot;, 3) == 0 ||</a>
<a name="ln1942">                        STRNICMP(p, &quot;btm&quot;, 3) == 0 ||</a>
<a name="ln1943">                        STRNICMP(p, &quot;cmd&quot;, 3) == 0 ||</a>
<a name="ln1944">                        STRNICMP(p, &quot;bat&quot;, 3) == 0)</a>
<a name="ln1945">                        attribs[3] = 'x';</a>
<a name="ln1946">                }</a>
<a name="ln1947">                break;</a>
<a name="ln1948">            } /* else: fall through! */</a>
<a name="ln1949"> </a>
<a name="ln1950">        default:   /* assume Unix-like */</a>
<a name="ln1951">            switch ((unsigned)(xattr &amp; UNX_IFMT)) {</a>
<a name="ln1952">                case (unsigned)UNX_IFDIR:   attribs[0] = 'd';  break;</a>
<a name="ln1953">                case (unsigned)UNX_IFREG:   attribs[0] = '-';  break;</a>
<a name="ln1954">                case (unsigned)UNX_IFLNK:   attribs[0] = 'l';  break;</a>
<a name="ln1955">                case (unsigned)UNX_IFBLK:   attribs[0] = 'b';  break;</a>
<a name="ln1956">                case (unsigned)UNX_IFCHR:   attribs[0] = 'c';  break;</a>
<a name="ln1957">                case (unsigned)UNX_IFIFO:   attribs[0] = 'p';  break;</a>
<a name="ln1958">                case (unsigned)UNX_IFSOCK:  attribs[0] = 's';  break;</a>
<a name="ln1959">                default:          attribs[0] = '?';  break;</a>
<a name="ln1960">            }</a>
<a name="ln1961">            attribs[1] = (xattr &amp; UNX_IRUSR)? 'r' : '-';</a>
<a name="ln1962">            attribs[4] = (xattr &amp; UNX_IRGRP)? 'r' : '-';</a>
<a name="ln1963">            attribs[7] = (xattr &amp; UNX_IROTH)? 'r' : '-';</a>
<a name="ln1964">            attribs[2] = (xattr &amp; UNX_IWUSR)? 'w' : '-';</a>
<a name="ln1965">            attribs[5] = (xattr &amp; UNX_IWGRP)? 'w' : '-';</a>
<a name="ln1966">            attribs[8] = (xattr &amp; UNX_IWOTH)? 'w' : '-';</a>
<a name="ln1967"> </a>
<a name="ln1968">            if (xattr &amp; UNX_IXUSR)</a>
<a name="ln1969">                attribs[3] = (xattr &amp; UNX_ISUID)? 's' : 'x';</a>
<a name="ln1970">            else</a>
<a name="ln1971">                attribs[3] = (xattr &amp; UNX_ISUID)? 'S' : '-';  /* S==undefined */</a>
<a name="ln1972">            if (xattr &amp; UNX_IXGRP)</a>
<a name="ln1973">                attribs[6] = (xattr &amp; UNX_ISGID)? 's' : 'x';  /* == UNX_ENFMT */</a>
<a name="ln1974">            else</a>
<a name="ln1975">                /* attribs[6] = (xattr &amp; UNX_ISGID)? 'l' : '-';  real 4.3BSD */</a>
<a name="ln1976">                attribs[6] = (xattr &amp; UNX_ISGID)? 'S' : '-';  /* SunOS 4.1.x */</a>
<a name="ln1977">            if (xattr &amp; UNX_IXOTH)</a>
<a name="ln1978">                attribs[9] = (xattr &amp; UNX_ISVTX)? 't' : 'x';  /* &quot;sticky bit&quot; */</a>
<a name="ln1979">            else</a>
<a name="ln1980">                attribs[9] = (xattr &amp; UNX_ISVTX)? 'T' : '-';  /* T==undefined */</a>
<a name="ln1981"> </a>
<a name="ln1982">            sprintf(&amp;attribs[12], &quot;%u.%u&quot;, hostver/10, hostver%10);</a>
<a name="ln1983">            break;</a>
<a name="ln1984"> </a>
<a name="ln1985">    } /* end switch (hostnum: external attributes format) */</a>
<a name="ln1986"> </a>
<a name="ln1987">#ifdef OLD_THEOS_EXTRA</a>
<a name="ln1988">    Info(slide, 0, ((char *)slide, &quot;%s %s %8lu &quot;, attribs,</a>
<a name="ln1989">      LoadFarStringSmall(((hostnum == FS_VFAT_ &amp;&amp; hostver == 20) ?</a>
<a name="ln1990">                          os_TheosOld :</a>
<a name="ln1991">                          os[hostnum])),</a>
<a name="ln1992">      G.crec.ucsize));</a>
<a name="ln1993">#else</a>
<a name="ln1994">    Info(slide, 0, ((char *)slide, &quot;%s %s %8lu &quot;, attribs,</a>
<a name="ln1995">      LoadFarStringSmall(os[hostnum]),</a>
<a name="ln1996">      G.crec.ucsize));</a>
<a name="ln1997">#endif</a>
<a name="ln1998">    Info(slide, 0, ((char *)slide, &quot;%c&quot;,</a>
<a name="ln1999">      (G.crec.general_purpose_bit_flag &amp; 1)?</a>
<a name="ln2000">      ((G.crec.internal_file_attributes &amp; 1)? 'T' : 'B') :  /* encrypted */</a>
<a name="ln2001">      ((G.crec.internal_file_attributes &amp; 1)? 't' : 'b'))); /* plaintext */</a>
<a name="ln2002">    k = (G.crec.extra_field_length ||</a>
<a name="ln2003">         /* a local-only &quot;UX&quot; (old Unix/OS2/NT GMT times &quot;IZUNIX&quot;) e.f.? */</a>
<a name="ln2004">         ((G.crec.external_file_attributes &amp; 0x8000) &amp;&amp;</a>
<a name="ln2005">          (hostnum == UNIX_ || hostnum == FS_HPFS_ || hostnum == FS_NTFS_)));</a>
<a name="ln2006">    Info(slide, 0, ((char *)slide, &quot;%c&quot;, k?</a>
<a name="ln2007">      ((G.crec.general_purpose_bit_flag &amp; 8)? 'X' : 'x') :  /* extra field */</a>
<a name="ln2008">      ((G.crec.general_purpose_bit_flag &amp; 8)? 'l' : '-'))); /* no extra field */</a>
<a name="ln2009">      /* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ extended local header or not */</a>
<a name="ln2010"> </a>
<a name="ln2011">    if (uO.lflag == 4) {</a>
<a name="ln2012">        ulg csiz = G.crec.csize;</a>
<a name="ln2013"> </a>
<a name="ln2014">        if (G.crec.general_purpose_bit_flag &amp; 1)</a>
<a name="ln2015">            csiz -= 12;    /* if encrypted, don't count encryption header */</a>
<a name="ln2016">        Info(slide, 0, ((char *)slide, &quot;%3d%%&quot;,</a>
<a name="ln2017">          (ratio(G.crec.ucsize,csiz)+5)/10));</a>
<a name="ln2018">    } else if (uO.lflag == 5)</a>
<a name="ln2019">        Info(slide, 0, ((char *)slide, &quot; %8lu&quot;, G.crec.csize));</a>
<a name="ln2020"> </a>
<a name="ln2021">    /* Read the extra field, if any.  The extra field info may be used</a>
<a name="ln2022">     * in the file modification time section, below.</a>
<a name="ln2023">     */</a>
<a name="ln2024">    if ((error = do_string(__G__ G.crec.extra_field_length, EXTRA_FIELD)) != 0)</a>
<a name="ln2025">    {</a>
<a name="ln2026">        if (G.extra_field != NULL) {</a>
<a name="ln2027">            free(G.extra_field);</a>
<a name="ln2028">            G.extra_field = NULL;</a>
<a name="ln2029">        }</a>
<a name="ln2030">        error_in_archive = error;</a>
<a name="ln2031">        /* We do not return prematurely in case of a &quot;fatal&quot; error (PK_EOF).</a>
<a name="ln2032">         * This does not hurt here, because we do not need to read from the</a>
<a name="ln2033">         * zipfile again before the end of this function.</a>
<a name="ln2034">         */</a>
<a name="ln2035">    }</a>
<a name="ln2036"> </a>
<a name="ln2037">    /* For printing of date &amp; time, a &quot;char d_t_buf[16]&quot; is required.</a>
<a name="ln2038">     * To save stack space, we reuse the &quot;char attribs[16]&quot; buffer whose</a>
<a name="ln2039">     * content is no longer needed.</a>
<a name="ln2040">     */</a>
<a name="ln2041">#   define d_t_buf attribs</a>
<a name="ln2042">#ifdef USE_EF_UT_TIME</a>
<a name="ln2043">    z_modtim = G.extra_field &amp;&amp;</a>
<a name="ln2044">#ifdef IZ_CHECK_TZ</a>
<a name="ln2045">               G.tz_is_valid &amp;&amp;</a>
<a name="ln2046">#endif</a>
<a name="ln2047">               (ef_scan_for_izux(G.extra_field, G.crec.extra_field_length, 1,</a>
<a name="ln2048">                                 G.crec.last_mod_dos_datetime, &amp;z_utime, NULL)</a>
<a name="ln2049">                &amp; EB_UT_FL_MTIME)</a>
<a name="ln2050">              ? &amp;z_utime.mtime : NULL;</a>
<a name="ln2051">    TIMET_TO_NATIVE(z_utime.mtime)     /* NOP unless MSC 7.0 or Macintosh */</a>
<a name="ln2052">    d_t_buf[0] = (char)0;              /* signal &quot;show local time&quot; */</a>
<a name="ln2053">#else</a>
<a name="ln2054">#   define z_modtim NULL</a>
<a name="ln2055">#endif</a>
<a name="ln2056">    Info(slide, 0, ((char *)slide, &quot; %s %s &quot;, methbuf,</a>
<a name="ln2057">      zi_time(__G__ &amp;G.crec.last_mod_dos_datetime, z_modtim, d_t_buf)));</a>
<a name="ln2058">    fnprint(__G);</a>
<a name="ln2059"> </a>
<a name="ln2060">/*---------------------------------------------------------------------------</a>
<a name="ln2061">    Skip the file comment, if any (the filename has already been printed,</a>
<a name="ln2062">    above).  That finishes up this file entry...</a>
<a name="ln2063">  ---------------------------------------------------------------------------*/</a>
<a name="ln2064"> </a>
<a name="ln2065">    SKIP_(G.crec.file_comment_length)</a>
<a name="ln2066"> </a>
<a name="ln2067">    return error_in_archive;</a>
<a name="ln2068"> </a>
<a name="ln2069">} /* end function zi_short() */</a>
<a name="ln2070"> </a>
<a name="ln2071"> </a>
<a name="ln2072"> </a>
<a name="ln2073"> </a>
<a name="ln2074"> </a>
<a name="ln2075">/**************************************/</a>
<a name="ln2076">/*  Function zi_showMacTypeCreator()  */</a>
<a name="ln2077">/**************************************/</a>
<a name="ln2078"> </a>
<a name="ln2079">static void zi_showMacTypeCreator(__G__ ebfield)</a>
<a name="ln2080">    __GDEF</a>
<a name="ln2081">    uch *ebfield;</a>
<a name="ln2082">{</a>
<a name="ln2083">    /* not every Type / Creator character is printable */</a>
<a name="ln2084">    if (isprint(ebfield[0]) &amp;&amp; isprint(ebfield[1]) &amp;&amp;</a>
<a name="ln2085">        isprint(ebfield[2]) &amp;&amp; isprint(ebfield[3]) &amp;&amp;</a>
<a name="ln2086">        isprint(ebfield[4]) &amp;&amp; isprint(ebfield[5]) &amp;&amp;</a>
<a name="ln2087">        isprint(ebfield[6]) &amp;&amp; isprint(ebfield[7])) {</a>
<a name="ln2088">       Info(slide, 0, ((char *)slide, LoadFarString(MacOSdata),</a>
<a name="ln2089">            ebfield[0], ebfield[1], ebfield[2], ebfield[3],</a>
<a name="ln2090">            ebfield[4], ebfield[5], ebfield[6], ebfield[7]));</a>
<a name="ln2091">    } else {</a>
<a name="ln2092">       Info(slide, 0, ((char *)slide, LoadFarString(MacOSdata1),</a>
<a name="ln2093">            (((ulg)ebfield[0]) &lt;&lt; 24) +</a>
<a name="ln2094">            (((ulg)ebfield[1]) &lt;&lt; 16) +</a>
<a name="ln2095">            (((ulg)ebfield[2]) &lt;&lt; 8)  +</a>
<a name="ln2096">            ((ulg)ebfield[3]),</a>
<a name="ln2097">            (((ulg)ebfield[4]) &lt;&lt; 24) +</a>
<a name="ln2098">            (((ulg)ebfield[5]) &lt;&lt; 16) +</a>
<a name="ln2099">            (((ulg)ebfield[6]) &lt;&lt; 8)  +</a>
<a name="ln2100">            ((ulg)ebfield[7])));</a>
<a name="ln2101">    }</a>
<a name="ln2102">} /* end function zi_showMacTypeCreator() */</a>
<a name="ln2103"> </a>
<a name="ln2104"> </a>
<a name="ln2105"> </a>
<a name="ln2106"> </a>
<a name="ln2107"> </a>
<a name="ln2108">/************************/</a>
<a name="ln2109">/*  Function zi_time()  */</a>
<a name="ln2110">/************************/</a>
<a name="ln2111"> </a>
<a name="ln2112">static char *zi_time(__G__ datetimez, modtimez, d_t_str)</a>
<a name="ln2113">    __GDEF</a>
<a name="ln2114">    ZCONST ulg *datetimez;</a>
<a name="ln2115">    ZCONST time_t *modtimez;</a>
<a name="ln2116">    char *d_t_str;</a>
<a name="ln2117">{</a>
<a name="ln2118">    unsigned yr, mo, dy, hh, mm, ss;</a>
<a name="ln2119">    char monthbuf[4];</a>
<a name="ln2120">    ZCONST char *monthstr;</a>
<a name="ln2121">    static ZCONST char Far month[12][4] = {</a>
<a name="ln2122">        &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,</a>
<a name="ln2123">        &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;</a>
<a name="ln2124">    };</a>
<a name="ln2125">#ifdef USE_EF_UT_TIME</a>
<a name="ln2126">    struct tm *t;</a>
<a name="ln2127">#endif</a>
<a name="ln2128"> </a>
<a name="ln2129"> </a>
<a name="ln2130"> </a>
<a name="ln2131">/*---------------------------------------------------------------------------</a>
<a name="ln2132">    Convert the file-modification date and time info to a string of the form</a>
<a name="ln2133">    &quot;1991 Feb 23 17:15:00&quot;, &quot;23-Feb-91 17:15&quot; or &quot;19910223.171500&quot;, depending</a>
<a name="ln2134">    on values of lflag and T_flag.  If using Unix-time extra fields, convert</a>
<a name="ln2135">    to local time or not, depending on value of first character in d_t_str[].</a>
<a name="ln2136">  ---------------------------------------------------------------------------*/</a>
<a name="ln2137"> </a>
<a name="ln2138">#ifdef USE_EF_UT_TIME</a>
<a name="ln2139">    if (modtimez != NULL) {</a>
<a name="ln2140">#ifndef NO_GMTIME</a>
<a name="ln2141">        /* check for our secret message from above... */</a>
<a name="ln2142">        t = (d_t_str[0] == (char)1)? gmtime(modtimez) : localtime(modtimez);</a>
<a name="ln2143">#else</a>
<a name="ln2144">        t = localtime(modtimez);</a>
<a name="ln2145">#endif</a>
<a name="ln2146">        if (uO.lflag &gt; 9 &amp;&amp; t == (struct tm *)NULL)</a>
<a name="ln2147">            /* time conversion error in verbose listing format,</a>
<a name="ln2148">             * return string with '?' instead of data</a>
<a name="ln2149">             */</a>
<a name="ln2150">            return (strcpy(d_t_str, LoadFarString(YMDHMSTimeError)));</a>
<a name="ln2151">    } else</a>
<a name="ln2152">        t = (struct tm *)NULL;</a>
<a name="ln2153">    if (t != (struct tm *)NULL) {</a>
<a name="ln2154">        mo = (unsigned)(t-&gt;tm_mon + 1);</a>
<a name="ln2155">        dy = (unsigned)(t-&gt;tm_mday);</a>
<a name="ln2156">        yr = (unsigned)(t-&gt;tm_year);</a>
<a name="ln2157"> </a>
<a name="ln2158">        hh = (unsigned)(t-&gt;tm_hour);</a>
<a name="ln2159">        mm = (unsigned)(t-&gt;tm_min);</a>
<a name="ln2160">        ss = (unsigned)(t-&gt;tm_sec);</a>
<a name="ln2161">    } else</a>
<a name="ln2162">#endif /* USE_EF_UT_TIME */</a>
<a name="ln2163">    {</a>
<a name="ln2164">        yr = ((unsigned)(*datetimez &gt;&gt; 25) &amp; 0x7f) + 80;</a>
<a name="ln2165">        mo = ((unsigned)(*datetimez &gt;&gt; 21) &amp; 0x0f);</a>
<a name="ln2166">        dy = ((unsigned)(*datetimez &gt;&gt; 16) &amp; 0x1f);</a>
<a name="ln2167"> </a>
<a name="ln2168">        hh = (((unsigned)*datetimez &gt;&gt; 11) &amp; 0x1f);</a>
<a name="ln2169">        mm = (((unsigned)*datetimez &gt;&gt; 5) &amp; 0x3f);</a>
<a name="ln2170">        ss = (((unsigned)*datetimez &lt;&lt; 1) &amp; 0x3e);</a>
<a name="ln2171">    }</a>
<a name="ln2172"> </a>
<a name="ln2173">    if (mo == 0 || mo &gt; 12) {</a>
<a name="ln2174">        sprintf(monthbuf, LoadFarString(BogusFmt), mo);</a>
<a name="ln2175">        monthstr = monthbuf;</a>
<a name="ln2176">    } else</a>
<a name="ln2177">        monthstr = LoadFarStringSmall(month[mo-1]);</a>
<a name="ln2178"> </a>
<a name="ln2179">    if (uO.lflag &gt; 9)   /* verbose listing format */</a>
<a name="ln2180">        sprintf(d_t_str, LoadFarString(YMDHMSTime), yr+1900, monthstr, dy, hh,</a>
<a name="ln2181">          mm, ss);</a>
<a name="ln2182">    else if (uO.T_flag)</a>
<a name="ln2183">        sprintf(d_t_str, LoadFarString(DecimalTime), yr+1900, mo, dy, hh, mm,</a>
<a name="ln2184">          ss);</a>
<a name="ln2185">    else   /* was:  if ((uO.lflag &gt;= 3) &amp;&amp; (uO.lflag &lt;= 5)) */</a>
<a name="ln2186">        sprintf(d_t_str, LoadFarString(DMYHMTime), dy, monthstr, yr%100, hh,</a>
<a name="ln2187">          mm);</a>
<a name="ln2188"> </a>
<a name="ln2189">    return d_t_str;</a>
<a name="ln2190"> </a>
<a name="ln2191">} /* end function zi_time() */</a>
<a name="ln2192"> </a>
<a name="ln2193">#endif /* !NO_ZIPINFO */</a>

</code></pre>
<div class="balloon" rel="745"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'fn_matched' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="745"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'xn_matched' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
