
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_malohal.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2007 Marvell Semiconductor, Inc.</a>
<a name="ln5"> * Copyright (c) 2007 Sam Leffler, Errno Consulting</a>
<a name="ln6"> * Copyright (c) 2008 Weongyo Jeong &lt;weongyo@freebsd.org&gt;</a>
<a name="ln7"> * All rights reserved.</a>
<a name="ln8"> *</a>
<a name="ln9"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln10"> * modification, are permitted provided that the following conditions</a>
<a name="ln11"> * are met:</a>
<a name="ln12"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer,</a>
<a name="ln14"> *    without modification.</a>
<a name="ln15"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</a>
<a name="ln16"> *    similar to the &quot;NO WARRANTY&quot; disclaimer below (&quot;Disclaimer&quot;) and any</a>
<a name="ln17"> *    redistribution must be conditioned upon including a substantially</a>
<a name="ln18"> *    similar Disclaimer requirement for further binary redistribution.</a>
<a name="ln19"> *</a>
<a name="ln20"> * NO WARRANTY</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln22"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln23"> * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY</a>
<a name="ln24"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</a>
<a name="ln25"> * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,</a>
<a name="ln26"> * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln27"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln28"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER</a>
<a name="ln29"> * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln30"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln31"> * THE POSSIBILITY OF SUCH DAMAGES.</a>
<a name="ln32"> */</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln35">#ifdef __FreeBSD__</a>
<a name="ln36">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/malo/if_malohal.c 326255 2017-11-27 14:52:40Z pfg $&quot;);</a>
<a name="ln37">#endif</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;sys/param.h&gt;</a>
<a name="ln40">#include &lt;sys/systm.h&gt;</a>
<a name="ln41">#include &lt;sys/endian.h&gt;</a>
<a name="ln42">#include &lt;sys/kernel.h&gt;</a>
<a name="ln43">#include &lt;sys/malloc.h&gt;</a>
<a name="ln44">#include &lt;sys/firmware.h&gt;</a>
<a name="ln45">#include &lt;sys/socket.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;machine/bus.h&gt;</a>
<a name="ln48">#include &lt;sys/bus.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;net/if.h&gt;</a>
<a name="ln51">#include &lt;net/if_var.h&gt;</a>
<a name="ln52">#include &lt;net/if_dl.h&gt;</a>
<a name="ln53">#include &lt;net/if_media.h&gt;</a>
<a name="ln54">#include &lt;net/ethernet.h&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln57"> </a>
<a name="ln58">#include &lt;dev/malo/if_malo.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#define MALO_WAITOK				1</a>
<a name="ln61">#define MALO_NOWAIT				0</a>
<a name="ln62"> </a>
<a name="ln63">#define	_CMD_SETUP(pCmd, _type, _cmd) do {				\</a>
<a name="ln64">	pCmd = (_type *)&amp;mh-&gt;mh_cmdbuf[0];				\</a>
<a name="ln65">	memset(pCmd, 0, sizeof(_type));					\</a>
<a name="ln66">	pCmd-&gt;cmdhdr.cmd = htole16(_cmd);				\</a>
<a name="ln67">	pCmd-&gt;cmdhdr.length = htole16(sizeof(_type));			\</a>
<a name="ln68">} while (0)</a>
<a name="ln69"> </a>
<a name="ln70">static __inline uint32_t</a>
<a name="ln71">malo_hal_read4(struct malo_hal *mh, bus_size_t off)</a>
<a name="ln72">{</a>
<a name="ln73">	return bus_space_read_4(mh-&gt;mh_iot, mh-&gt;mh_ioh, off);</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">static __inline void</a>
<a name="ln77">malo_hal_write4(struct malo_hal *mh, bus_size_t off, uint32_t val)</a>
<a name="ln78">{</a>
<a name="ln79">	bus_space_write_4(mh-&gt;mh_iot, mh-&gt;mh_ioh, off, val);</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">static void</a>
<a name="ln83">malo_hal_load_cb(void *arg, bus_dma_segment_t *segs, int nsegs, int error)</a>
<a name="ln84">{</a>
<a name="ln85">	bus_addr_t *paddr = (bus_addr_t*) arg;</a>
<a name="ln86"> </a>
<a name="ln87">	KASSERT(error == 0, (&quot;error %u on bus_dma callback&quot;, error));</a>
<a name="ln88">	*paddr = segs-&gt;ds_addr;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">/*</a>
<a name="ln92"> * Setup for communication with the device.  We allocate</a>
<a name="ln93"> * a command buffer and map it for bus dma use.  The pci</a>
<a name="ln94"> * device id is used to identify whether the device has</a>
<a name="ln95"> * SRAM on it (in which case f/w download must include a</a>
<a name="ln96"> * memory controller reset).  All bus i/o operations happen</a>
<a name="ln97"> * in BAR 1; the driver passes in the tag and handle we need.</a>
<a name="ln98"> */</a>
<a name="ln99">struct malo_hal *</a>
<a name="ln100">malo_hal_attach(device_t dev, uint16_t devid,</a>
<a name="ln101">    bus_space_handle_t ioh, bus_space_tag_t iot, bus_dma_tag_t tag)</a>
<a name="ln102">{</a>
<a name="ln103">	int error;</a>
<a name="ln104">	struct malo_hal *mh;</a>
<a name="ln105"> </a>
<a name="ln106">	mh = malloc(sizeof(struct malo_hal), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln107">	if (mh == NULL)</a>
<a name="ln108">		return NULL;</a>
<a name="ln109"> </a>
<a name="ln110">	mh-&gt;mh_dev = dev;</a>
<a name="ln111">	mh-&gt;mh_ioh = ioh;</a>
<a name="ln112">	mh-&gt;mh_iot = iot;</a>
<a name="ln113"> </a>
<a name="ln114">	snprintf(mh-&gt;mh_mtxname, sizeof(mh-&gt;mh_mtxname),</a>
<a name="ln115">	    &quot;%s_hal&quot;, device_get_nameunit(dev));</a>
<a name="ln116">	mtx_init(&amp;mh-&gt;mh_mtx, mh-&gt;mh_mtxname, NULL, MTX_DEF);</a>
<a name="ln117"> </a>
<a name="ln118">	/*</a>
<a name="ln119">	 * Allocate the command buffer and map into the address</a>
<a name="ln120">	 * space of the h/w.  We request &quot;coherent&quot; memory which</a>
<a name="ln121">	 * will be uncached on some architectures.</a>
<a name="ln122">	 */</a>
<a name="ln123">	error = bus_dma_tag_create(tag,		/* parent */</a>
<a name="ln124">		       PAGE_SIZE, 0,		/* alignment, bounds */</a>
<a name="ln125">		       BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln126">		       BUS_SPACE_MAXADDR,	/* highaddr */</a>
<a name="ln127">		       NULL, NULL,		/* filter, filterarg */</a>
<a name="ln128">		       MALO_CMDBUF_SIZE,	/* maxsize */</a>
<a name="ln129">		       1,			/* nsegments */</a>
<a name="ln130">		       MALO_CMDBUF_SIZE,	/* maxsegsize */</a>
<a name="ln131">		       BUS_DMA_ALLOCNOW,	/* flags */</a>
<a name="ln132">		       NULL,			/* lockfunc */</a>
<a name="ln133">		       NULL,			/* lockarg */</a>
<a name="ln134">		       &amp;mh-&gt;mh_dmat);</a>
<a name="ln135">	if (error != 0) {</a>
<a name="ln136">		device_printf(dev, &quot;unable to allocate memory for cmd tag, &quot;</a>
<a name="ln137">			&quot;error %u\n&quot;, error);</a>
<a name="ln138">		goto fail;</a>
<a name="ln139">	}</a>
<a name="ln140"> </a>
<a name="ln141">	/* allocate descriptors */</a>
<a name="ln142">	error = bus_dmamem_alloc(mh-&gt;mh_dmat, (void**) &amp;mh-&gt;mh_cmdbuf,</a>
<a name="ln143">				 BUS_DMA_NOWAIT | BUS_DMA_COHERENT, </a>
<a name="ln144">				 &amp;mh-&gt;mh_dmamap);</a>
<a name="ln145">	if (error != 0) {</a>
<a name="ln146">		device_printf(dev, &quot;unable to allocate memory for cmd buffer, &quot;</a>
<a name="ln147">			&quot;error %u\n&quot;, error);</a>
<a name="ln148">		goto fail;</a>
<a name="ln149">	}</a>
<a name="ln150"> </a>
<a name="ln151">	error = bus_dmamap_load(mh-&gt;mh_dmat, mh-&gt;mh_dmamap,</a>
<a name="ln152">				mh-&gt;mh_cmdbuf, MALO_CMDBUF_SIZE,</a>
<a name="ln153">				malo_hal_load_cb, &amp;mh-&gt;mh_cmdaddr,</a>
<a name="ln154">				BUS_DMA_NOWAIT);</a>
<a name="ln155">	if (error != 0) {</a>
<a name="ln156">		device_printf(dev, &quot;unable to load cmd buffer, error %u\n&quot;,</a>
<a name="ln157">			error);</a>
<a name="ln158">		goto fail;</a>
<a name="ln159">	}</a>
<a name="ln160"> </a>
<a name="ln161">	return (mh);</a>
<a name="ln162"> </a>
<a name="ln163">fail:</a>
<a name="ln164">	if (mh-&gt;mh_cmdbuf != NULL)</a>
<a name="ln165">		bus_dmamem_free(mh-&gt;mh_dmat, mh-&gt;mh_cmdbuf,</a>
<a name="ln166">		    mh-&gt;mh_dmamap);</a>
<a name="ln167">	if (mh-&gt;mh_dmat)</a>
<a name="ln168">		bus_dma_tag_destroy(mh-&gt;mh_dmat);</a>
<a name="ln169">	free(mh, M_DEVBUF);</a>
<a name="ln170"> </a>
<a name="ln171">	return (NULL);</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">/*</a>
<a name="ln175"> * Low level firmware cmd block handshake support.</a>
<a name="ln176"> */</a>
<a name="ln177"> </a>
<a name="ln178">static void</a>
<a name="ln179">malo_hal_send_cmd(struct malo_hal *mh)</a>
<a name="ln180">{</a>
<a name="ln181">	uint32_t dummy;</a>
<a name="ln182"> </a>
<a name="ln183">	bus_dmamap_sync(mh-&gt;mh_dmat, mh-&gt;mh_dmamap,</a>
<a name="ln184">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln185"> </a>
<a name="ln186">	malo_hal_write4(mh, MALO_REG_GEN_PTR, mh-&gt;mh_cmdaddr);</a>
<a name="ln187">	dummy = malo_hal_read4(mh, MALO_REG_INT_CODE);</a>
<a name="ln188"> </a>
<a name="ln189">	malo_hal_write4(mh, MALO_REG_H2A_INTERRUPT_EVENTS,</a>
<a name="ln190">	    MALO_H2ARIC_BIT_DOOR_BELL);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">static int</a>
<a name="ln194">malo_hal_waitforcmd(struct malo_hal *mh, uint16_t cmd)</a>
<a name="ln195">{</a>
<a name="ln196">#define MAX_WAIT_FW_COMPLETE_ITERATIONS 10000</a>
<a name="ln197">	int i;</a>
<a name="ln198"> </a>
<a name="ln199">	for (i = 0; i &lt; MAX_WAIT_FW_COMPLETE_ITERATIONS; i++) {</a>
<a name="ln200">		if (mh-&gt;mh_cmdbuf[0] == le16toh(cmd))</a>
<a name="ln201">			return 1;</a>
<a name="ln202"> </a>
<a name="ln203">		DELAY(1 * 1000);</a>
<a name="ln204">	}</a>
<a name="ln205"> </a>
<a name="ln206">	return 0;</a>
<a name="ln207">#undef MAX_WAIT_FW_COMPLETE_ITERATIONS</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">static int</a>
<a name="ln211">malo_hal_execute_cmd(struct malo_hal *mh, unsigned short cmd)</a>
<a name="ln212">{</a>
<a name="ln213">	MALO_HAL_LOCK_ASSERT(mh);</a>
<a name="ln214"> </a>
<a name="ln215">	if ((mh-&gt;mh_flags &amp; MHF_FWHANG) &amp;&amp;</a>
<a name="ln216">	    (mh-&gt;mh_debug &amp; MALO_HAL_DEBUG_IGNHANG) == 0) {</a>
<a name="ln217">		device_printf(mh-&gt;mh_dev, &quot;firmware hung, skipping cmd 0x%x\n&quot;,</a>
<a name="ln218">			cmd);</a>
<a name="ln219">		return ENXIO;</a>
<a name="ln220">	}</a>
<a name="ln221"> </a>
<a name="ln222">	if (malo_hal_read4(mh, MALO_REG_INT_CODE) == 0xffffffff) {</a>
<a name="ln223">		device_printf(mh-&gt;mh_dev, &quot;%s: device not present!\n&quot;,</a>
<a name="ln224">		    __func__);</a>
<a name="ln225">		return EIO;</a>
<a name="ln226">	}</a>
<a name="ln227"> </a>
<a name="ln228">	malo_hal_send_cmd(mh);</a>
<a name="ln229">	if (!malo_hal_waitforcmd(mh, cmd | 0x8000)) {</a>
<a name="ln230">		device_printf(mh-&gt;mh_dev,</a>
<a name="ln231">		    &quot;timeout waiting for f/w cmd 0x%x\n&quot;, cmd);</a>
<a name="ln232">		mh-&gt;mh_flags |= MHF_FWHANG;</a>
<a name="ln233">		return ETIMEDOUT;</a>
<a name="ln234">	}</a>
<a name="ln235"> </a>
<a name="ln236">	bus_dmamap_sync(mh-&gt;mh_dmat, mh-&gt;mh_dmamap,</a>
<a name="ln237">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln238"> </a>
<a name="ln239">	return 0;</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">static int</a>
<a name="ln243">malo_hal_get_cal_table(struct malo_hal *mh, uint8_t annex, uint8_t index)</a>
<a name="ln244">{</a>
<a name="ln245">	struct malo_cmd_caltable *cmd;</a>
<a name="ln246">	int ret;</a>
<a name="ln247"> </a>
<a name="ln248">	MALO_HAL_LOCK_ASSERT(mh);</a>
<a name="ln249"> </a>
<a name="ln250">	_CMD_SETUP(cmd, struct malo_cmd_caltable, MALO_HOSTCMD_GET_CALTABLE);</a>
<a name="ln251">	cmd-&gt;annex = annex;</a>
<a name="ln252">	cmd-&gt;index = index;</a>
<a name="ln253"> </a>
<a name="ln254">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_GET_CALTABLE);</a>
<a name="ln255">	if (ret == 0 &amp;&amp; cmd-&gt;caltbl[0] != annex &amp;&amp; annex != 0 &amp;&amp; annex != 255)</a>
<a name="ln256">		ret = EIO;</a>
<a name="ln257">	return ret;</a>
<a name="ln258">}							  </a>
<a name="ln259"> </a>
<a name="ln260">static int</a>
<a name="ln261">malo_hal_get_pwrcal_table(struct malo_hal *mh, struct malo_hal_caldata *cal)</a>
<a name="ln262">{</a>
<a name="ln263">	const uint8_t *data;</a>
<a name="ln264">	int len;</a>
<a name="ln265"> </a>
<a name="ln266">	MALO_HAL_LOCK(mh);</a>
<a name="ln267">	/* NB: we hold the lock so it's ok to use cmdbuf */</a>
<a name="ln268">	data = ((const struct malo_cmd_caltable *) mh-&gt;mh_cmdbuf)-&gt;caltbl;</a>
<a name="ln269">	if (malo_hal_get_cal_table(mh, 33, 0) == 0) {</a>
<a name="ln270">		len = (data[2] | (data[3] &lt;&lt; 8)) - 12;</a>
<a name="ln271">		/* XXX validate len */</a>
<a name="ln272">		memcpy(cal-&gt;pt_ratetable_20m, &amp;data[12], len);	</a>
<a name="ln273">	}</a>
<a name="ln274">	mh-&gt;mh_flags |= MHF_CALDATA;</a>
<a name="ln275">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln276"> </a>
<a name="ln277">	return 0;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">/*</a>
<a name="ln281"> * Reset internal state after a firmware download.</a>
<a name="ln282"> */</a>
<a name="ln283">static int</a>
<a name="ln284">malo_hal_resetstate(struct malo_hal *mh)</a>
<a name="ln285">{</a>
<a name="ln286">	/*</a>
<a name="ln287">	 * Fetch cal data for later use.</a>
<a name="ln288">	 * XXX may want to fetch other stuff too.</a>
<a name="ln289">	 */</a>
<a name="ln290">	if ((mh-&gt;mh_flags &amp; MHF_CALDATA) == 0)</a>
<a name="ln291">		malo_hal_get_pwrcal_table(mh, &amp;mh-&gt;mh_caldata);</a>
<a name="ln292">	return 0;</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">static void</a>
<a name="ln296">malo_hal_fw_reset(struct malo_hal *mh)</a>
<a name="ln297">{</a>
<a name="ln298"> </a>
<a name="ln299">	if (malo_hal_read4(mh,  MALO_REG_INT_CODE) == 0xffffffff) {</a>
<a name="ln300">		device_printf(mh-&gt;mh_dev, &quot;%s: device not present!\n&quot;,</a>
<a name="ln301">		    __func__);</a>
<a name="ln302">		return;</a>
<a name="ln303">	}</a>
<a name="ln304"> </a>
<a name="ln305">	malo_hal_write4(mh, MALO_REG_H2A_INTERRUPT_EVENTS, MALO_ISR_RESET);</a>
<a name="ln306">	mh-&gt;mh_flags &amp;= ~MHF_FWHANG;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">static void</a>
<a name="ln310">malo_hal_trigger_pcicmd(struct malo_hal *mh)</a>
<a name="ln311">{</a>
<a name="ln312">	uint32_t dummy;</a>
<a name="ln313"> </a>
<a name="ln314">	bus_dmamap_sync(mh-&gt;mh_dmat, mh-&gt;mh_dmamap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln315"> </a>
<a name="ln316">	malo_hal_write4(mh, MALO_REG_GEN_PTR, mh-&gt;mh_cmdaddr);</a>
<a name="ln317">	dummy = malo_hal_read4(mh, MALO_REG_INT_CODE);</a>
<a name="ln318"> </a>
<a name="ln319">	malo_hal_write4(mh, MALO_REG_INT_CODE, 0x00);</a>
<a name="ln320">	dummy = malo_hal_read4(mh, MALO_REG_INT_CODE);</a>
<a name="ln321"> </a>
<a name="ln322">	malo_hal_write4(mh, MALO_REG_H2A_INTERRUPT_EVENTS,</a>
<a name="ln323">	    MALO_H2ARIC_BIT_DOOR_BELL);</a>
<a name="ln324">	dummy = malo_hal_read4(mh, MALO_REG_INT_CODE);</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">static int</a>
<a name="ln328">malo_hal_waitfor(struct malo_hal *mh, uint32_t val)</a>
<a name="ln329">{</a>
<a name="ln330">	int i;</a>
<a name="ln331"> </a>
<a name="ln332">	for (i = 0; i &lt; MALO_FW_MAX_NUM_CHECKS; i++) {</a>
<a name="ln333">		DELAY(MALO_FW_CHECK_USECS);</a>
<a name="ln334">		if (malo_hal_read4(mh, MALO_REG_INT_CODE) == val)</a>
<a name="ln335">			return 0;</a>
<a name="ln336">	}</a>
<a name="ln337"> </a>
<a name="ln338">	return -1;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">/*</a>
<a name="ln342"> * Firmware block xmit when talking to the boot-rom.</a>
<a name="ln343"> */</a>
<a name="ln344">static int</a>
<a name="ln345">malo_hal_send_helper(struct malo_hal *mh, int bsize,</a>
<a name="ln346">    const void *data, size_t dsize, int waitfor)</a>
<a name="ln347">{</a>
<a name="ln348">	mh-&gt;mh_cmdbuf[0] = htole16(MALO_HOSTCMD_CODE_DNLD);</a>
<a name="ln349">	mh-&gt;mh_cmdbuf[1] = htole16(bsize);</a>
<a name="ln350">	memcpy(&amp;mh-&gt;mh_cmdbuf[4], data , dsize);</a>
<a name="ln351"> </a>
<a name="ln352">	malo_hal_trigger_pcicmd(mh);</a>
<a name="ln353"> </a>
<a name="ln354">	if (waitfor == MALO_NOWAIT)</a>
<a name="ln355">		goto pass;</a>
<a name="ln356"> </a>
<a name="ln357">	/* XXX 2000 vs 200 */</a>
<a name="ln358">	if (malo_hal_waitfor(mh, MALO_INT_CODE_CMD_FINISHED) != 0) {</a>
<a name="ln359">		device_printf(mh-&gt;mh_dev,</a>
<a name="ln360">		    &quot;%s: timeout waiting for CMD_FINISHED, INT_CODE 0x%x\n&quot;,</a>
<a name="ln361">		    __func__, malo_hal_read4(mh, MALO_REG_INT_CODE));</a>
<a name="ln362">		</a>
<a name="ln363">		return ETIMEDOUT;</a>
<a name="ln364">	}</a>
<a name="ln365"> </a>
<a name="ln366">pass:</a>
<a name="ln367">	malo_hal_write4(mh, MALO_REG_INT_CODE, 0);</a>
<a name="ln368"> </a>
<a name="ln369">	return (0);</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">static int</a>
<a name="ln373">malo_hal_fwload_helper(struct malo_hal *mh, char *helper)</a>
<a name="ln374">{</a>
<a name="ln375">	const struct firmware *fw;</a>
<a name="ln376">	int error;</a>
<a name="ln377"> </a>
<a name="ln378">	fw = firmware_get(helper);</a>
<a name="ln379">	if (fw == NULL) {</a>
<a name="ln380">		device_printf(mh-&gt;mh_dev, &quot;could not read microcode %s!\n&quot;,</a>
<a name="ln381">		    helper);</a>
<a name="ln382">		return (EIO);</a>
<a name="ln383">	}</a>
<a name="ln384"> </a>
<a name="ln385">	device_printf(mh-&gt;mh_dev, &quot;load %s firmware image (%zu bytes)\n&quot;,</a>
<a name="ln386">	    helper, fw-&gt;datasize);</a>
<a name="ln387"> </a>
<a name="ln388">	error = malo_hal_send_helper(mh, fw-&gt;datasize, fw-&gt;data, fw-&gt;datasize,</a>
<a name="ln389">		MALO_WAITOK);</a>
<a name="ln390">	if (error != 0)</a>
<a name="ln391">		goto fail;</a>
<a name="ln392"> </a>
<a name="ln393">	/* tell the card we're done and... */</a>
<a name="ln394">	error = malo_hal_send_helper(mh, 0, NULL, 0, MALO_NOWAIT);</a>
<a name="ln395"> </a>
<a name="ln396">fail:</a>
<a name="ln397">	firmware_put(fw, FIRMWARE_UNLOAD);</a>
<a name="ln398"> </a>
<a name="ln399">	return (error);</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">/*</a>
<a name="ln403"> * Firmware block xmit when talking to the 1st-stage loader.</a>
<a name="ln404"> */</a>
<a name="ln405">static int</a>
<a name="ln406">malo_hal_send_main(struct malo_hal *mh, const void *data, size_t dsize,</a>
<a name="ln407">    uint16_t seqnum, int waitfor)</a>
<a name="ln408">{</a>
<a name="ln409">	mh-&gt;mh_cmdbuf[0] = htole16(MALO_HOSTCMD_CODE_DNLD);</a>
<a name="ln410">	mh-&gt;mh_cmdbuf[1] = htole16(dsize);</a>
<a name="ln411">	mh-&gt;mh_cmdbuf[2] = htole16(seqnum);</a>
<a name="ln412">	mh-&gt;mh_cmdbuf[3] = 0;</a>
<a name="ln413">	memcpy(&amp;mh-&gt;mh_cmdbuf[4], data, dsize);</a>
<a name="ln414"> </a>
<a name="ln415">	malo_hal_trigger_pcicmd(mh);</a>
<a name="ln416"> </a>
<a name="ln417">	if (waitfor == MALO_NOWAIT)</a>
<a name="ln418">		goto pass;</a>
<a name="ln419"> </a>
<a name="ln420">	if (malo_hal_waitfor(mh, MALO_INT_CODE_CMD_FINISHED) != 0) {</a>
<a name="ln421">		device_printf(mh-&gt;mh_dev,</a>
<a name="ln422">		    &quot;%s: timeout waiting for CMD_FINISHED, INT_CODE 0x%x\n&quot;,</a>
<a name="ln423">		    __func__, malo_hal_read4(mh, MALO_REG_INT_CODE));</a>
<a name="ln424"> </a>
<a name="ln425">		return ETIMEDOUT;</a>
<a name="ln426">	}</a>
<a name="ln427"> </a>
<a name="ln428">pass:</a>
<a name="ln429">	malo_hal_write4(mh, MALO_REG_INT_CODE, 0);</a>
<a name="ln430"> </a>
<a name="ln431">	return 0;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">static int</a>
<a name="ln435">malo_hal_fwload_main(struct malo_hal *mh, char *firmware)</a>
<a name="ln436">{</a>
<a name="ln437">	const struct firmware *fw;</a>
<a name="ln438">	const uint8_t *fp;</a>
<a name="ln439">	int error;</a>
<a name="ln440">	size_t count;</a>
<a name="ln441">	uint16_t seqnum;</a>
<a name="ln442">	uint32_t blocksize;</a>
<a name="ln443"> </a>
<a name="ln444">	error = 0;</a>
<a name="ln445"> </a>
<a name="ln446">	fw = firmware_get(firmware);</a>
<a name="ln447">	if (fw == NULL) {</a>
<a name="ln448">		device_printf(mh-&gt;mh_dev, &quot;could not read firmware %s!\n&quot;,</a>
<a name="ln449">		    firmware);</a>
<a name="ln450">		return (EIO);</a>
<a name="ln451">	}</a>
<a name="ln452"> </a>
<a name="ln453">	device_printf(mh-&gt;mh_dev, &quot;load %s firmware image (%zu bytes)\n&quot;,</a>
<a name="ln454">	    firmware, fw-&gt;datasize);</a>
<a name="ln455"> </a>
<a name="ln456">	seqnum = 1;</a>
<a name="ln457">	for (count = 0; count &lt; fw-&gt;datasize; count += blocksize) {</a>
<a name="ln458">		blocksize = MIN(256, fw-&gt;datasize - count);</a>
<a name="ln459">		fp = (const uint8_t *)fw-&gt;data + count;</a>
<a name="ln460"> </a>
<a name="ln461">		error = malo_hal_send_main(mh, fp, blocksize, seqnum++,</a>
<a name="ln462">		    MALO_NOWAIT);</a>
<a name="ln463">		if (error != 0)</a>
<a name="ln464">			goto fail;</a>
<a name="ln465">		DELAY(500);</a>
<a name="ln466">	}</a>
<a name="ln467">	</a>
<a name="ln468">	/*</a>
<a name="ln469">	 * send a command with size 0 to tell that the firmware has been</a>
<a name="ln470">	 * uploaded</a>
<a name="ln471">	 */</a>
<a name="ln472">	error = malo_hal_send_main(mh, NULL, 0, seqnum++, MALO_NOWAIT);</a>
<a name="ln473">	DELAY(100);</a>
<a name="ln474"> </a>
<a name="ln475">fail:</a>
<a name="ln476">	firmware_put(fw, FIRMWARE_UNLOAD);</a>
<a name="ln477"> </a>
<a name="ln478">	return (error);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">int</a>
<a name="ln482">malo_hal_fwload(struct malo_hal *mh, char *helper, char *firmware)</a>
<a name="ln483">{</a>
<a name="ln484">	int error, i;</a>
<a name="ln485">	uint32_t fwreadysig, opmode;</a>
<a name="ln486"> </a>
<a name="ln487">	/*</a>
<a name="ln488">	 * NB: now malo(4) supports only STA mode.  It will be better if it</a>
<a name="ln489">	 * supports AP mode.</a>
<a name="ln490">	 */</a>
<a name="ln491">	fwreadysig = MALO_HOSTCMD_STA_FWRDY_SIGNATURE;</a>
<a name="ln492">	opmode = MALO_HOSTCMD_STA_MODE;</a>
<a name="ln493"> </a>
<a name="ln494">	malo_hal_fw_reset(mh);</a>
<a name="ln495"> </a>
<a name="ln496">	malo_hal_write4(mh, MALO_REG_A2H_INTERRUPT_CLEAR_SEL,</a>
<a name="ln497">	    MALO_A2HRIC_BIT_MASK);</a>
<a name="ln498">	malo_hal_write4(mh, MALO_REG_A2H_INTERRUPT_CAUSE, 0x00);</a>
<a name="ln499">	malo_hal_write4(mh, MALO_REG_A2H_INTERRUPT_MASK, 0x00);</a>
<a name="ln500">	malo_hal_write4(mh, MALO_REG_A2H_INTERRUPT_STATUS_MASK,</a>
<a name="ln501">	    MALO_A2HRIC_BIT_MASK);</a>
<a name="ln502"> </a>
<a name="ln503">	error = malo_hal_fwload_helper(mh, helper);</a>
<a name="ln504">	if (error != 0) {</a>
<a name="ln505">		device_printf(mh-&gt;mh_dev, &quot;failed to load bootrom loader.\n&quot;);</a>
<a name="ln506">		goto fail;</a>
<a name="ln507">	}</a>
<a name="ln508"> </a>
<a name="ln509">	DELAY(200 * MALO_FW_CHECK_USECS);</a>
<a name="ln510"> </a>
<a name="ln511">	error = malo_hal_fwload_main(mh, firmware);</a>
<a name="ln512">	if (error != 0) {</a>
<a name="ln513">		device_printf(mh-&gt;mh_dev, &quot;failed to load firmware.\n&quot;);</a>
<a name="ln514">		goto fail;</a>
<a name="ln515">	}</a>
<a name="ln516"> </a>
<a name="ln517">	/*</a>
<a name="ln518">	 * Wait for firmware to startup; we monitor the INT_CODE register</a>
<a name="ln519">	 * waiting for a signature to written back indicating it's ready to go.</a>
<a name="ln520">	 */</a>
<a name="ln521">	mh-&gt;mh_cmdbuf[1] = 0;</a>
<a name="ln522"> </a>
<a name="ln523">	if (opmode != MALO_HOSTCMD_STA_MODE)</a>
<a name="ln524">		malo_hal_trigger_pcicmd(mh);</a>
<a name="ln525">	</a>
<a name="ln526">	for (i = 0; i &lt; MALO_FW_MAX_NUM_CHECKS; i++) {</a>
<a name="ln527">		malo_hal_write4(mh, MALO_REG_GEN_PTR, opmode);</a>
<a name="ln528">		DELAY(MALO_FW_CHECK_USECS);</a>
<a name="ln529">		if (malo_hal_read4(mh, MALO_REG_INT_CODE) == fwreadysig) {</a>
<a name="ln530">			malo_hal_write4(mh, MALO_REG_INT_CODE, 0x00);</a>
<a name="ln531">			return malo_hal_resetstate(mh);</a>
<a name="ln532">		}</a>
<a name="ln533">	}</a>
<a name="ln534"> </a>
<a name="ln535">	return ETIMEDOUT;</a>
<a name="ln536">fail:</a>
<a name="ln537">	malo_hal_fw_reset(mh);</a>
<a name="ln538"> </a>
<a name="ln539">	return (error);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">/*</a>
<a name="ln543"> * Return &quot;hw specs&quot;.  Note this must be the first cmd MUST be done after</a>
<a name="ln544"> * a firmware download or the f/w will lockup.</a>
<a name="ln545"> */</a>
<a name="ln546">int</a>
<a name="ln547">malo_hal_gethwspecs(struct malo_hal *mh, struct malo_hal_hwspec *hw)</a>
<a name="ln548">{</a>
<a name="ln549">	struct malo_cmd_get_hwspec *cmd;</a>
<a name="ln550">	int ret;</a>
<a name="ln551"> </a>
<a name="ln552">	MALO_HAL_LOCK(mh);</a>
<a name="ln553"> </a>
<a name="ln554">	_CMD_SETUP(cmd, struct malo_cmd_get_hwspec, MALO_HOSTCMD_GET_HW_SPEC);</a>
<a name="ln555">	memset(&amp;cmd-&gt;permaddr[0], 0xff, IEEE80211_ADDR_LEN);</a>
<a name="ln556">	cmd-&gt;ul_fw_awakecookie = htole32((unsigned int)mh-&gt;mh_cmdaddr + 2048);</a>
<a name="ln557"> </a>
<a name="ln558">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_GET_HW_SPEC);</a>
<a name="ln559">	if (ret == 0) {</a>
<a name="ln560">		IEEE80211_ADDR_COPY(hw-&gt;macaddr, cmd-&gt;permaddr);</a>
<a name="ln561">		hw-&gt;wcbbase[0] = le32toh(cmd-&gt;wcbbase0) &amp; 0x0000ffff;</a>
<a name="ln562">		hw-&gt;wcbbase[1] = le32toh(cmd-&gt;wcbbase1) &amp; 0x0000ffff;</a>
<a name="ln563">		hw-&gt;wcbbase[2] = le32toh(cmd-&gt;wcbbase2) &amp; 0x0000ffff;</a>
<a name="ln564">		hw-&gt;wcbbase[3] = le32toh(cmd-&gt;wcbbase3) &amp; 0x0000ffff;</a>
<a name="ln565">		hw-&gt;rxdesc_read = le32toh(cmd-&gt;rxpdrd_ptr)&amp; 0x0000ffff;</a>
<a name="ln566">		hw-&gt;rxdesc_write = le32toh(cmd-&gt;rxpdwr_ptr)&amp; 0x0000ffff;</a>
<a name="ln567">		hw-&gt;regioncode = le16toh(cmd-&gt;regioncode) &amp; 0x00ff;</a>
<a name="ln568">		hw-&gt;fw_releasenum = le32toh(cmd-&gt;fw_releasenum);</a>
<a name="ln569">		hw-&gt;maxnum_wcb = le16toh(cmd-&gt;num_wcb);</a>
<a name="ln570">		hw-&gt;maxnum_mcaddr = le16toh(cmd-&gt;num_mcastaddr);</a>
<a name="ln571">		hw-&gt;num_antenna = le16toh(cmd-&gt;num_antenna);</a>
<a name="ln572">		hw-&gt;hwversion = cmd-&gt;version;</a>
<a name="ln573">		hw-&gt;hostinterface = cmd-&gt;hostif;</a>
<a name="ln574">	}</a>
<a name="ln575"> </a>
<a name="ln576">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln577"> </a>
<a name="ln578">	return ret;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">void</a>
<a name="ln582">malo_hal_detach(struct malo_hal *mh)</a>
<a name="ln583">{</a>
<a name="ln584"> </a>
<a name="ln585">	bus_dmamem_free(mh-&gt;mh_dmat, mh-&gt;mh_cmdbuf, mh-&gt;mh_dmamap);</a>
<a name="ln586">	bus_dma_tag_destroy(mh-&gt;mh_dmat);</a>
<a name="ln587">	mtx_destroy(&amp;mh-&gt;mh_mtx);</a>
<a name="ln588">	free(mh, M_DEVBUF);</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">/*</a>
<a name="ln592"> * Configure antenna use.  Takes effect immediately.</a>
<a name="ln593"> *</a>
<a name="ln594"> * XXX tx antenna setting ignored</a>
<a name="ln595"> * XXX rx antenna setting should always be 3 (for now)</a>
<a name="ln596"> */</a>
<a name="ln597">int</a>
<a name="ln598">malo_hal_setantenna(struct malo_hal *mh, enum malo_hal_antenna dirset, int ant)</a>
<a name="ln599">{</a>
<a name="ln600">	struct malo_cmd_rf_antenna *cmd;</a>
<a name="ln601">	int ret;</a>
<a name="ln602"> </a>
<a name="ln603">	if (!(dirset == MHA_ANTENNATYPE_RX || dirset == MHA_ANTENNATYPE_TX))</a>
<a name="ln604">		return EINVAL;</a>
<a name="ln605"> </a>
<a name="ln606">	MALO_HAL_LOCK(mh);</a>
<a name="ln607"> </a>
<a name="ln608">	_CMD_SETUP(cmd, struct malo_cmd_rf_antenna,</a>
<a name="ln609">	    MALO_HOSTCMD_802_11_RF_ANTENNA);</a>
<a name="ln610">	cmd-&gt;action = htole16(dirset);</a>
<a name="ln611">	if (ant == 0) {			/* default to all/both antennae */</a>
<a name="ln612">		/* XXX never reach now.  */</a>
<a name="ln613">		ant = 3;</a>
<a name="ln614">	}</a>
<a name="ln615">	cmd-&gt;mode = htole16(ant);</a>
<a name="ln616"> </a>
<a name="ln617">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_802_11_RF_ANTENNA);</a>
<a name="ln618"> </a>
<a name="ln619">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln620"> </a>
<a name="ln621">	return ret;</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624">/*</a>
<a name="ln625"> * Configure radio.  Takes effect immediately.</a>
<a name="ln626"> *</a>
<a name="ln627"> * XXX preamble installed after set fixed rate cmd</a>
<a name="ln628"> */</a>
<a name="ln629">int</a>
<a name="ln630">malo_hal_setradio(struct malo_hal *mh, int onoff,</a>
<a name="ln631">    enum malo_hal_preamble preamble)</a>
<a name="ln632">{</a>
<a name="ln633">	struct malo_cmd_radio_control *cmd;</a>
<a name="ln634">	int ret;</a>
<a name="ln635"> </a>
<a name="ln636">	MALO_HAL_LOCK(mh);</a>
<a name="ln637"> </a>
<a name="ln638">	_CMD_SETUP(cmd, struct malo_cmd_radio_control,</a>
<a name="ln639">	    MALO_HOSTCMD_802_11_RADIO_CONTROL);</a>
<a name="ln640">	cmd-&gt;action = htole16(MALO_HOSTCMD_ACT_GEN_SET);</a>
<a name="ln641">	if (onoff == 0)</a>
<a name="ln642">		cmd-&gt;control = 0;</a>
<a name="ln643">	else</a>
<a name="ln644">		cmd-&gt;control = htole16(preamble);</a>
<a name="ln645">	cmd-&gt;radio_on = htole16(onoff);</a>
<a name="ln646"> </a>
<a name="ln647">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_802_11_RADIO_CONTROL);</a>
<a name="ln648"> </a>
<a name="ln649">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln650"> </a>
<a name="ln651">	return ret;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">/*</a>
<a name="ln655"> * Set the interrupt mask.</a>
<a name="ln656"> */</a>
<a name="ln657">void</a>
<a name="ln658">malo_hal_intrset(struct malo_hal *mh, uint32_t mask)</a>
<a name="ln659">{</a>
<a name="ln660"> </a>
<a name="ln661">	malo_hal_write4(mh, MALO_REG_A2H_INTERRUPT_MASK, 0);</a>
<a name="ln662">	(void)malo_hal_read4(mh, MALO_REG_INT_CODE);</a>
<a name="ln663"> </a>
<a name="ln664">	mh-&gt;mh_imask = mask;</a>
<a name="ln665">	malo_hal_write4(mh, MALO_REG_A2H_INTERRUPT_MASK, mask);</a>
<a name="ln666">	(void)malo_hal_read4(mh, MALO_REG_INT_CODE);</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">int</a>
<a name="ln670">malo_hal_setchannel(struct malo_hal *mh, const struct malo_hal_channel *chan)</a>
<a name="ln671">{</a>
<a name="ln672">	struct malo_cmd_fw_set_rf_channel *cmd;</a>
<a name="ln673">	int ret;</a>
<a name="ln674"> </a>
<a name="ln675">	MALO_HAL_LOCK(mh);</a>
<a name="ln676"> </a>
<a name="ln677">	_CMD_SETUP(cmd, struct malo_cmd_fw_set_rf_channel,</a>
<a name="ln678">	    MALO_HOSTCMD_SET_RF_CHANNEL);</a>
<a name="ln679">	cmd-&gt;action = htole16(MALO_HOSTCMD_ACT_GEN_SET);</a>
<a name="ln680">	cmd-&gt;cur_channel = chan-&gt;channel;</a>
<a name="ln681"> </a>
<a name="ln682">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_SET_RF_CHANNEL);</a>
<a name="ln683"> </a>
<a name="ln684">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln685"> </a>
<a name="ln686">	return ret;</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">int</a>
<a name="ln690">malo_hal_settxpower(struct malo_hal *mh, const struct malo_hal_channel *c)</a>
<a name="ln691">{</a>
<a name="ln692">	struct malo_cmd_rf_tx_power *cmd;</a>
<a name="ln693">	const struct malo_hal_caldata *cal = &amp;mh-&gt;mh_caldata;</a>
<a name="ln694">	uint8_t chan = c-&gt;channel;</a>
<a name="ln695">	uint16_t pow;</a>
<a name="ln696">	int i, idx, ret;</a>
<a name="ln697">	</a>
<a name="ln698">	MALO_HAL_LOCK(mh);</a>
<a name="ln699"> </a>
<a name="ln700">	_CMD_SETUP(cmd, struct malo_cmd_rf_tx_power,</a>
<a name="ln701">	    MALO_HOSTCMD_802_11_RF_TX_POWER);</a>
<a name="ln702">	cmd-&gt;action = htole16(MALO_HOSTCMD_ACT_GEN_SET_LIST);</a>
<a name="ln703">	for (i = 0; i &lt; 4; i++) {</a>
<a name="ln704">		idx = (chan - 1) * 4 + i;</a>
<a name="ln705">		pow = cal-&gt;pt_ratetable_20m[idx];</a>
<a name="ln706">		cmd-&gt;power_levellist[i] = htole16(pow);</a>
<a name="ln707">	}</a>
<a name="ln708">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_802_11_RF_TX_POWER);</a>
<a name="ln709"> </a>
<a name="ln710">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln711"> </a>
<a name="ln712">	return ret;</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">int</a>
<a name="ln716">malo_hal_setpromisc(struct malo_hal *mh, int enable)</a>
<a name="ln717">{</a>
<a name="ln718">	/* XXX need host cmd */</a>
<a name="ln719">	return 0;</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">int</a>
<a name="ln723">malo_hal_setassocid(struct malo_hal *mh,</a>
<a name="ln724">    const uint8_t bssid[IEEE80211_ADDR_LEN], uint16_t associd)</a>
<a name="ln725">{</a>
<a name="ln726">	struct malo_cmd_fw_set_aid *cmd;</a>
<a name="ln727">	int ret;</a>
<a name="ln728"> </a>
<a name="ln729">	MALO_HAL_LOCK(mh);</a>
<a name="ln730"> </a>
<a name="ln731">	_CMD_SETUP(cmd, struct malo_cmd_fw_set_aid,</a>
<a name="ln732">	    MALO_HOSTCMD_SET_AID);</a>
<a name="ln733">	cmd-&gt;cmdhdr.seqnum = 1;</a>
<a name="ln734">	cmd-&gt;associd = htole16(associd);</a>
<a name="ln735">	IEEE80211_ADDR_COPY(&amp;cmd-&gt;macaddr[0], bssid);</a>
<a name="ln736">	</a>
<a name="ln737">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_SET_AID);</a>
<a name="ln738">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln739">	return ret;</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">/*</a>
<a name="ln743"> * Kick the firmware to tell it there are new tx descriptors</a>
<a name="ln744"> * for processing.  The driver says what h/w q has work in</a>
<a name="ln745"> * case the f/w ever gets smarter.</a>
<a name="ln746"> */</a>
<a name="ln747">void</a>
<a name="ln748">malo_hal_txstart(struct malo_hal *mh, int qnum)</a>
<a name="ln749">{</a>
<a name="ln750">	bus_space_write_4(mh-&gt;mh_iot, mh-&gt;mh_ioh,</a>
<a name="ln751">	    MALO_REG_H2A_INTERRUPT_EVENTS, MALO_H2ARIC_BIT_PPA_READY);</a>
<a name="ln752">	(void) bus_space_read_4(mh-&gt;mh_iot, mh-&gt;mh_ioh, MALO_REG_INT_CODE);</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">/*</a>
<a name="ln756"> * Return the current ISR setting and clear the cause.</a>
<a name="ln757"> */</a>
<a name="ln758">void</a>
<a name="ln759">malo_hal_getisr(struct malo_hal *mh, uint32_t *status)</a>
<a name="ln760">{</a>
<a name="ln761">	uint32_t cause;</a>
<a name="ln762"> </a>
<a name="ln763">	cause = bus_space_read_4(mh-&gt;mh_iot, mh-&gt;mh_ioh,</a>
<a name="ln764">	    MALO_REG_A2H_INTERRUPT_CAUSE);</a>
<a name="ln765">	if (cause == 0xffffffff) {	/* card removed */</a>
<a name="ln766">		cause = 0;</a>
<a name="ln767">	} else if (cause != 0) {</a>
<a name="ln768">		/* clear cause bits */</a>
<a name="ln769">		bus_space_write_4(mh-&gt;mh_iot, mh-&gt;mh_ioh,</a>
<a name="ln770">		    MALO_REG_A2H_INTERRUPT_CAUSE, cause &amp;~ mh-&gt;mh_imask);</a>
<a name="ln771">		(void) bus_space_read_4(mh-&gt;mh_iot, mh-&gt;mh_ioh,</a>
<a name="ln772">		    MALO_REG_INT_CODE);</a>
<a name="ln773">		cause &amp;= mh-&gt;mh_imask;</a>
<a name="ln774">	}</a>
<a name="ln775"> </a>
<a name="ln776">	*status = cause;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">/*</a>
<a name="ln780"> * Callback from the driver on a cmd done interrupt.  Nothing to do right</a>
<a name="ln781"> * now as we spin waiting for cmd completion.</a>
<a name="ln782"> */</a>
<a name="ln783">void</a>
<a name="ln784">malo_hal_cmddone(struct malo_hal *mh)</a>
<a name="ln785">{</a>
<a name="ln786">	/* NB : do nothing.  */</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">int</a>
<a name="ln790">malo_hal_prescan(struct malo_hal *mh)</a>
<a name="ln791">{</a>
<a name="ln792">	struct malo_cmd_prescan *cmd;</a>
<a name="ln793">	int ret;</a>
<a name="ln794"> </a>
<a name="ln795">	MALO_HAL_LOCK(mh);</a>
<a name="ln796"> </a>
<a name="ln797">	_CMD_SETUP(cmd, struct malo_cmd_prescan, MALO_HOSTCMD_SET_PRE_SCAN);</a>
<a name="ln798">	cmd-&gt;cmdhdr.seqnum = 1;</a>
<a name="ln799">	</a>
<a name="ln800">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_SET_PRE_SCAN);</a>
<a name="ln801"> </a>
<a name="ln802">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln803"> </a>
<a name="ln804">	return ret;</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">int</a>
<a name="ln808">malo_hal_postscan(struct malo_hal *mh, uint8_t *macaddr, uint8_t ibsson)</a>
<a name="ln809">{</a>
<a name="ln810">	struct malo_cmd_postscan *cmd;</a>
<a name="ln811">	int ret;</a>
<a name="ln812"> </a>
<a name="ln813">	MALO_HAL_LOCK(mh);</a>
<a name="ln814"> </a>
<a name="ln815">	_CMD_SETUP(cmd, struct malo_cmd_postscan, MALO_HOSTCMD_SET_POST_SCAN);</a>
<a name="ln816">	cmd-&gt;cmdhdr.seqnum = 1;</a>
<a name="ln817">	cmd-&gt;isibss = htole32(ibsson);</a>
<a name="ln818">	IEEE80211_ADDR_COPY(&amp;cmd-&gt;bssid[0], macaddr);</a>
<a name="ln819"> </a>
<a name="ln820">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_SET_POST_SCAN);</a>
<a name="ln821"> </a>
<a name="ln822">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln823"> </a>
<a name="ln824">	return ret;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">int</a>
<a name="ln828">malo_hal_set_slot(struct malo_hal *mh, int is_short)</a>
<a name="ln829">{</a>
<a name="ln830">	int ret;</a>
<a name="ln831">	struct malo_cmd_fw_setslot *cmd;</a>
<a name="ln832"> </a>
<a name="ln833">	MALO_HAL_LOCK(mh);</a>
<a name="ln834"> </a>
<a name="ln835">	_CMD_SETUP(cmd, struct malo_cmd_fw_setslot, MALO_HOSTCMD_SET_SLOT);</a>
<a name="ln836">	cmd-&gt;action = htole16(MALO_HOSTCMD_ACT_GEN_SET);</a>
<a name="ln837">	cmd-&gt;slot = (is_short == 1 ? 1 : 0);</a>
<a name="ln838"> </a>
<a name="ln839">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_SET_SLOT);</a>
<a name="ln840"> </a>
<a name="ln841">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln842"> </a>
<a name="ln843">	return ret;</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">int</a>
<a name="ln847">malo_hal_set_rate(struct malo_hal *mh, uint16_t curmode, uint8_t rate)</a>
<a name="ln848">{</a>
<a name="ln849">	int i, ret;</a>
<a name="ln850">	struct malo_cmd_set_rate *cmd;</a>
<a name="ln851"> </a>
<a name="ln852">	MALO_HAL_LOCK(mh);</a>
<a name="ln853"> </a>
<a name="ln854">	_CMD_SETUP(cmd, struct malo_cmd_set_rate, MALO_HOSTCMD_SET_RATE);</a>
<a name="ln855">	cmd-&gt;aprates[0] = 2;</a>
<a name="ln856">	cmd-&gt;aprates[1] = 4;</a>
<a name="ln857">	cmd-&gt;aprates[2] = 11;</a>
<a name="ln858">	cmd-&gt;aprates[3] = 22;</a>
<a name="ln859">	if (curmode == IEEE80211_MODE_11G) {</a>
<a name="ln860">		cmd-&gt;aprates[4] = 0;		/* XXX reserved?  */</a>
<a name="ln861">		cmd-&gt;aprates[5] = 12;</a>
<a name="ln862">		cmd-&gt;aprates[6] = 18;</a>
<a name="ln863">		cmd-&gt;aprates[7] = 24;</a>
<a name="ln864">		cmd-&gt;aprates[8] = 36;</a>
<a name="ln865">		cmd-&gt;aprates[9] = 48;</a>
<a name="ln866">		cmd-&gt;aprates[10] = 72;</a>
<a name="ln867">		cmd-&gt;aprates[11] = 96;</a>
<a name="ln868">		cmd-&gt;aprates[12] = 108;</a>
<a name="ln869">	}</a>
<a name="ln870"> </a>
<a name="ln871">	if (rate != 0) {</a>
<a name="ln872">		/* fixed rate */</a>
<a name="ln873">		for (i = 0; i &lt; 13; i++) {</a>
<a name="ln874">			if (cmd-&gt;aprates[i] == rate) {</a>
<a name="ln875">				cmd-&gt;rateindex = i;</a>
<a name="ln876">				cmd-&gt;dataratetype = 1;</a>
<a name="ln877">				break;</a>
<a name="ln878">			}</a>
<a name="ln879">		}</a>
<a name="ln880">	}</a>
<a name="ln881"> </a>
<a name="ln882">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_SET_RATE);</a>
<a name="ln883"> </a>
<a name="ln884">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln885"> </a>
<a name="ln886">	return ret;</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">int</a>
<a name="ln890">malo_hal_setmcast(struct malo_hal *mh, int nmc, const uint8_t macs[])</a>
<a name="ln891">{</a>
<a name="ln892">	struct malo_cmd_mcast *cmd;</a>
<a name="ln893">	int ret;</a>
<a name="ln894"> </a>
<a name="ln895">	if (nmc &gt; MALO_HAL_MCAST_MAX)</a>
<a name="ln896">		return EINVAL;</a>
<a name="ln897"> </a>
<a name="ln898">	MALO_HAL_LOCK(mh);</a>
<a name="ln899"> </a>
<a name="ln900">	_CMD_SETUP(cmd, struct malo_cmd_mcast, MALO_HOSTCMD_MAC_MULTICAST_ADR);</a>
<a name="ln901">	memcpy(cmd-&gt;maclist, macs, nmc * IEEE80211_ADDR_LEN);</a>
<a name="ln902">	cmd-&gt;numaddr = htole16(nmc);</a>
<a name="ln903">	cmd-&gt;action = htole16(0xffff);</a>
<a name="ln904"> </a>
<a name="ln905">	ret = malo_hal_execute_cmd(mh, MALO_HOSTCMD_MAC_MULTICAST_ADR);</a>
<a name="ln906"> </a>
<a name="ln907">	MALO_HAL_UNLOCK(mh);</a>
<a name="ln908"> </a>
<a name="ln909">	return ret;</a>
<a name="ln910">}</a>

</code></pre>
<div class="balloon" rel="413"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'data' might take place. The null pointer is passed into 'malo_hal_send_main' function. Inspect the second argument. Check lines: 413, 472.</p></div>
<div class="balloon" rel="350"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> Dereferencing of the null pointer 'data' might take place. The null pointer is passed into 'malo_hal_send_helper' function. Inspect the third argument. Check lines: 350, 394.</p></div>
<div class="balloon" rel="523"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'opmode != 0x5A' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
