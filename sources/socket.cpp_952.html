
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>socket.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2010, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Copyright 2008, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Distributed under the terms of the MIT License.</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;sys/socket.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;errno.h&gt;</a>
<a name="ln12">#include &lt;limits.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;module.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;syscall_utils.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;fd.h&gt;</a>
<a name="ln21">#include &lt;kernel.h&gt;</a>
<a name="ln22">#include &lt;lock.h&gt;</a>
<a name="ln23">#include &lt;syscall_restart.h&gt;</a>
<a name="ln24">#include &lt;util/AutoLock.h&gt;</a>
<a name="ln25">#include &lt;vfs.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;net_stack_interface.h&gt;</a>
<a name="ln28">#include &lt;net_stat.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">#define MAX_SOCKET_ADDRESS_LENGTH	(sizeof(sockaddr_storage))</a>
<a name="ln32">#define MAX_SOCKET_OPTION_LENGTH	128</a>
<a name="ln33">#define MAX_ANCILLARY_DATA_LENGTH	1024</a>
<a name="ln34"> </a>
<a name="ln35">#define GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor)	\</a>
<a name="ln36">	do {												\</a>
<a name="ln37">		status_t getError = get_socket_descriptor(fd, kernel, descriptor); \</a>
<a name="ln38">		if (getError != B_OK)							\</a>
<a name="ln39">			return getError;							\</a>
<a name="ln40">	} while (false)</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">static net_stack_interface_module_info* sStackInterface = NULL;</a>
<a name="ln44">static vint32 sStackInterfaceInitialized = 0;</a>
<a name="ln45">static mutex sLock = MUTEX_INITIALIZER(&quot;stack interface&quot;);</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">struct FDPutter {</a>
<a name="ln49">	FDPutter(file_descriptor* descriptor)</a>
<a name="ln50">		: descriptor(descriptor)</a>
<a name="ln51">	{</a>
<a name="ln52">	}</a>
<a name="ln53"> </a>
<a name="ln54">	~FDPutter()</a>
<a name="ln55">	{</a>
<a name="ln56">		if (descriptor != NULL)</a>
<a name="ln57">			put_fd(descriptor);</a>
<a name="ln58">	}</a>
<a name="ln59"> </a>
<a name="ln60">	file_descriptor*	descriptor;</a>
<a name="ln61">};</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">static net_stack_interface_module_info*</a>
<a name="ln65">get_stack_interface_module()</a>
<a name="ln66">{</a>
<a name="ln67">	MutexLocker _(sLock);</a>
<a name="ln68"> </a>
<a name="ln69">	if (sStackInterfaceInitialized++ == 0) {</a>
<a name="ln70">		// load module</a>
<a name="ln71">		net_stack_interface_module_info* module;</a>
<a name="ln72">		// TODO: Add driver settings option to load the userland net stack.</a>
<a name="ln73">		status_t error = get_module(NET_STACK_INTERFACE_MODULE_NAME,</a>
<a name="ln74">			(module_info**)&amp;module);</a>
<a name="ln75">		if (error == B_OK)</a>
<a name="ln76">			sStackInterface = module;</a>
<a name="ln77">		else</a>
<a name="ln78">			sStackInterface = NULL;</a>
<a name="ln79">	}</a>
<a name="ln80"> </a>
<a name="ln81">	return sStackInterface;</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84"> </a>
<a name="ln85">static void</a>
<a name="ln86">put_stack_interface_module()</a>
<a name="ln87">{</a>
<a name="ln88">	MutexLocker _(sLock);</a>
<a name="ln89"> </a>
<a name="ln90">	if (sStackInterfaceInitialized-- == 1)</a>
<a name="ln91">		put_module(NET_STACK_INTERFACE_MODULE_NAME);</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">static status_t</a>
<a name="ln96">prepare_userland_address_result(struct sockaddr* userAddress,</a>
<a name="ln97">	socklen_t* _addressLength, socklen_t&amp; addressLength, bool addressRequired)</a>
<a name="ln98">{</a>
<a name="ln99">	// check parameters</a>
<a name="ln100">	if (_addressLength == NULL)</a>
<a name="ln101">		return B_BAD_VALUE;</a>
<a name="ln102">	if (userAddress == NULL) {</a>
<a name="ln103">		if (addressRequired)</a>
<a name="ln104">			return B_BAD_VALUE;</a>
<a name="ln105">	} else if (!IS_USER_ADDRESS(userAddress)</a>
<a name="ln106">			|| !IS_USER_ADDRESS(_addressLength)) {</a>
<a name="ln107">		return B_BAD_ADDRESS;</a>
<a name="ln108">	}</a>
<a name="ln109"> </a>
<a name="ln110">	// copy the buffer size from userland</a>
<a name="ln111">	addressLength = 0;</a>
<a name="ln112">	if (userAddress != NULL</a>
<a name="ln113">			&amp;&amp; user_memcpy(&amp;addressLength, _addressLength, sizeof(socklen_t))</a>
<a name="ln114">				!= B_OK) {</a>
<a name="ln115">		return B_BAD_ADDRESS;</a>
<a name="ln116">	}</a>
<a name="ln117"> </a>
<a name="ln118">	if (addressLength &gt; MAX_SOCKET_ADDRESS_LENGTH)</a>
<a name="ln119">		addressLength = MAX_SOCKET_ADDRESS_LENGTH;</a>
<a name="ln120"> </a>
<a name="ln121">	return B_OK;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">static status_t</a>
<a name="ln126">copy_address_to_userland(const void* address, socklen_t addressLength,</a>
<a name="ln127">	sockaddr* userAddress, socklen_t userAddressBufferSize,</a>
<a name="ln128">	socklen_t* userAddressLength)</a>
<a name="ln129">{</a>
<a name="ln130">	// copy address size and address back to userland</a>
<a name="ln131">	if (user_memcpy(userAddressLength, &amp;addressLength,</a>
<a name="ln132">			sizeof(socklen_t)) != B_OK</a>
<a name="ln133">		|| (userAddress != NULL</a>
<a name="ln134">			&amp;&amp; user_memcpy(userAddress, address,</a>
<a name="ln135">				min_c(addressLength, userAddressBufferSize)) != B_OK)) {</a>
<a name="ln136">		return B_BAD_ADDRESS;</a>
<a name="ln137">	}</a>
<a name="ln138"> </a>
<a name="ln139">	return B_OK;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">static status_t</a>
<a name="ln144">prepare_userland_msghdr(const msghdr* userMessage, msghdr&amp; message,</a>
<a name="ln145">	iovec*&amp; userVecs, MemoryDeleter&amp; vecsDeleter, void*&amp; userAddress,</a>
<a name="ln146">	char* address)</a>
<a name="ln147">{</a>
<a name="ln148">	if (userMessage == NULL)</a>
<a name="ln149">		return B_BAD_VALUE;</a>
<a name="ln150"> </a>
<a name="ln151">	// copy message from userland</a>
<a name="ln152">	if (!IS_USER_ADDRESS(userMessage)</a>
<a name="ln153">			|| user_memcpy(&amp;message, userMessage, sizeof(msghdr)) != B_OK) {</a>
<a name="ln154">		return B_BAD_ADDRESS;</a>
<a name="ln155">	}</a>
<a name="ln156"> </a>
<a name="ln157">	userVecs = message.msg_iov;</a>
<a name="ln158">	userAddress = message.msg_name;</a>
<a name="ln159"> </a>
<a name="ln160">	// copy iovecs from userland</a>
<a name="ln161">	if (message.msg_iovlen &lt; 0 || message.msg_iovlen &gt; IOV_MAX)</a>
<a name="ln162">		return EMSGSIZE;</a>
<a name="ln163">	if (userVecs != NULL &amp;&amp; message.msg_iovlen &gt; 0) {</a>
<a name="ln164">		iovec* vecs = (iovec*)malloc(sizeof(iovec) * message.msg_iovlen);</a>
<a name="ln165">		if (vecs == NULL)</a>
<a name="ln166">			return B_NO_MEMORY;</a>
<a name="ln167">		vecsDeleter.SetTo(vecs);</a>
<a name="ln168"> </a>
<a name="ln169">		if (!IS_USER_ADDRESS(message.msg_iov)</a>
<a name="ln170">			|| user_memcpy(vecs, message.msg_iov,</a>
<a name="ln171">					message.msg_iovlen * sizeof(iovec)) != B_OK) {</a>
<a name="ln172">			return B_BAD_ADDRESS;</a>
<a name="ln173">		}</a>
<a name="ln174"> </a>
<a name="ln175">		for (int i = 0; i &lt; message.msg_iovlen; i++) {</a>
<a name="ln176">			if (!IS_USER_ADDRESS(vecs[i].iov_base))</a>
<a name="ln177">				return B_BAD_ADDRESS;</a>
<a name="ln178">		}</a>
<a name="ln179"> </a>
<a name="ln180">		message.msg_iov = vecs;</a>
<a name="ln181">	} else {</a>
<a name="ln182">		message.msg_iov = NULL;</a>
<a name="ln183">		message.msg_iovlen = 0;</a>
<a name="ln184">	}</a>
<a name="ln185"> </a>
<a name="ln186">	// prepare the address field</a>
<a name="ln187">	userAddress = message.msg_name;</a>
<a name="ln188">	if (userAddress != NULL) {</a>
<a name="ln189">		if (!IS_USER_ADDRESS(message.msg_name))</a>
<a name="ln190">			return B_BAD_ADDRESS;</a>
<a name="ln191">		if (message.msg_namelen &gt; MAX_SOCKET_ADDRESS_LENGTH)</a>
<a name="ln192">			message.msg_namelen = MAX_SOCKET_ADDRESS_LENGTH;</a>
<a name="ln193"> </a>
<a name="ln194">		message.msg_name = address;</a>
<a name="ln195">	}</a>
<a name="ln196"> </a>
<a name="ln197">	return B_OK;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">static status_t</a>
<a name="ln202">get_socket_descriptor(int fd, bool kernel, file_descriptor*&amp; descriptor)</a>
<a name="ln203">{</a>
<a name="ln204">	if (fd &lt; 0)</a>
<a name="ln205">		return EBADF;</a>
<a name="ln206"> </a>
<a name="ln207">	descriptor = get_fd(get_current_io_context(kernel), fd);</a>
<a name="ln208">	if (descriptor == NULL)</a>
<a name="ln209">		return EBADF;</a>
<a name="ln210"> </a>
<a name="ln211">	if (descriptor-&gt;type != FDTYPE_SOCKET) {</a>
<a name="ln212">		put_fd(descriptor);</a>
<a name="ln213">		return ENOTSOCK;</a>
<a name="ln214">	}</a>
<a name="ln215"> </a>
<a name="ln216">	return B_OK;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">// #pragma mark - socket file descriptor</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">static status_t</a>
<a name="ln224">socket_read(struct file_descriptor *descriptor, off_t pos, void *buffer,</a>
<a name="ln225">	size_t *_length)</a>
<a name="ln226">{</a>
<a name="ln227">	ssize_t bytesRead = sStackInterface-&gt;recv(descriptor-&gt;u.socket, buffer,</a>
<a name="ln228">		*_length, 0);</a>
<a name="ln229">	*_length = bytesRead &gt;= 0 ? bytesRead : 0;</a>
<a name="ln230">	return bytesRead &gt;= 0 ? B_OK : bytesRead;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">static status_t</a>
<a name="ln235">socket_write(struct file_descriptor *descriptor, off_t pos, const void *buffer,</a>
<a name="ln236">	size_t *_length)</a>
<a name="ln237">{</a>
<a name="ln238">	ssize_t bytesWritten = sStackInterface-&gt;send(descriptor-&gt;u.socket, buffer,</a>
<a name="ln239">		*_length, 0);</a>
<a name="ln240">	*_length = bytesWritten &gt;= 0 ? bytesWritten : 0;</a>
<a name="ln241">	return bytesWritten &gt;= 0 ? B_OK : bytesWritten;</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244"> </a>
<a name="ln245">static status_t</a>
<a name="ln246">socket_ioctl(struct file_descriptor *descriptor, ulong op, void *buffer,</a>
<a name="ln247">	size_t length)</a>
<a name="ln248">{</a>
<a name="ln249">	return sStackInterface-&gt;ioctl(descriptor-&gt;u.socket, op, buffer, length);</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252"> </a>
<a name="ln253">static status_t</a>
<a name="ln254">socket_set_flags(struct file_descriptor *descriptor, int flags)</a>
<a name="ln255">{</a>
<a name="ln256">	// we ignore O_APPEND, but O_NONBLOCK we need to translate</a>
<a name="ln257">	uint32 op = (flags &amp; O_NONBLOCK) != 0</a>
<a name="ln258">		? B_SET_NONBLOCKING_IO : B_SET_BLOCKING_IO;</a>
<a name="ln259"> </a>
<a name="ln260">	return sStackInterface-&gt;ioctl(descriptor-&gt;u.socket, op, NULL, 0);</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264">static status_t</a>
<a name="ln265">socket_select(struct file_descriptor *descriptor, uint8 event,</a>
<a name="ln266">	struct selectsync *sync)</a>
<a name="ln267">{</a>
<a name="ln268">	return sStackInterface-&gt;select(descriptor-&gt;u.socket, event, sync);</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271"> </a>
<a name="ln272">static status_t</a>
<a name="ln273">socket_deselect(struct file_descriptor *descriptor, uint8 event,</a>
<a name="ln274">	struct selectsync *sync)</a>
<a name="ln275">{</a>
<a name="ln276">	return sStackInterface-&gt;deselect(descriptor-&gt;u.socket, event, sync);</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">static status_t</a>
<a name="ln281">socket_read_stat(struct file_descriptor *descriptor, struct stat *st)</a>
<a name="ln282">{</a>
<a name="ln283">	st-&gt;st_dev = 0;</a>
<a name="ln284">	st-&gt;st_ino = (addr_t)descriptor-&gt;u.socket;</a>
<a name="ln285">	st-&gt;st_mode = S_IFSOCK | 0666;</a>
<a name="ln286">	st-&gt;st_nlink = 1;</a>
<a name="ln287">	st-&gt;st_uid = 0;</a>
<a name="ln288">	st-&gt;st_gid = 0;</a>
<a name="ln289">	st-&gt;st_size = 0;</a>
<a name="ln290">	st-&gt;st_rdev = 0;</a>
<a name="ln291">	st-&gt;st_blksize = 1024;	// use MTU for datagram sockets?</a>
<a name="ln292">	st-&gt;st_type = 0;</a>
<a name="ln293"> </a>
<a name="ln294">	timespec now;</a>
<a name="ln295">	now.tv_sec = time(NULL);</a>
<a name="ln296">	now.tv_nsec = 0;</a>
<a name="ln297"> </a>
<a name="ln298">	st-&gt;st_atim = now;</a>
<a name="ln299">	st-&gt;st_mtim = now;</a>
<a name="ln300">	st-&gt;st_ctim = now;</a>
<a name="ln301">	st-&gt;st_crtim = now;</a>
<a name="ln302"> </a>
<a name="ln303">	return B_OK;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">static status_t</a>
<a name="ln308">socket_close(struct file_descriptor *descriptor)</a>
<a name="ln309">{</a>
<a name="ln310">	return sStackInterface-&gt;close(descriptor-&gt;u.socket);</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314">static void</a>
<a name="ln315">socket_free(struct file_descriptor *descriptor)</a>
<a name="ln316">{</a>
<a name="ln317">	sStackInterface-&gt;free(descriptor-&gt;u.socket);</a>
<a name="ln318">	put_stack_interface_module();</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321"> </a>
<a name="ln322">static struct fd_ops sSocketFDOps = {</a>
<a name="ln323">	&amp;socket_read,</a>
<a name="ln324">	&amp;socket_write,</a>
<a name="ln325">	NULL,	// fd_seek</a>
<a name="ln326">	&amp;socket_ioctl,</a>
<a name="ln327">	&amp;socket_set_flags,</a>
<a name="ln328">	&amp;socket_select,</a>
<a name="ln329">	&amp;socket_deselect,</a>
<a name="ln330">	NULL,	// fd_read_dir</a>
<a name="ln331">	NULL,	// fd_rewind_dir</a>
<a name="ln332">	&amp;socket_read_stat,</a>
<a name="ln333">	NULL,	// fd_write_stat</a>
<a name="ln334">	&amp;socket_close,</a>
<a name="ln335">	&amp;socket_free</a>
<a name="ln336">};</a>
<a name="ln337"> </a>
<a name="ln338"> </a>
<a name="ln339">static int</a>
<a name="ln340">create_socket_fd(net_socket* socket, bool kernel)</a>
<a name="ln341">{</a>
<a name="ln342">	// Get the socket's non-blocking flag, so we can set the respective</a>
<a name="ln343">	// open mode flag.</a>
<a name="ln344">	int32 nonBlock;</a>
<a name="ln345">	socklen_t nonBlockLen = sizeof(int32);</a>
<a name="ln346">	status_t error = sStackInterface-&gt;getsockopt(socket, SOL_SOCKET,</a>
<a name="ln347">		SO_NONBLOCK, &amp;nonBlock, &amp;nonBlockLen);</a>
<a name="ln348">	if (error != B_OK)</a>
<a name="ln349">		return error;</a>
<a name="ln350"> </a>
<a name="ln351">	// allocate a file descriptor</a>
<a name="ln352">	file_descriptor* descriptor = alloc_fd();</a>
<a name="ln353">	if (descriptor == NULL)</a>
<a name="ln354">		return B_NO_MEMORY;</a>
<a name="ln355"> </a>
<a name="ln356">	// init it</a>
<a name="ln357">	descriptor-&gt;type = FDTYPE_SOCKET;</a>
<a name="ln358">	descriptor-&gt;ops = &amp;sSocketFDOps;</a>
<a name="ln359">	descriptor-&gt;u.socket = socket;</a>
<a name="ln360">	descriptor-&gt;open_mode = O_RDWR | (nonBlock ? O_NONBLOCK : 0);</a>
<a name="ln361"> </a>
<a name="ln362">	// publish it</a>
<a name="ln363">	int fd = new_fd(get_current_io_context(kernel), descriptor);</a>
<a name="ln364">	if (fd &lt; 0)</a>
<a name="ln365">		free(descriptor);</a>
<a name="ln366"> </a>
<a name="ln367">	return fd;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">// #pragma mark - common sockets API implementation</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">static int</a>
<a name="ln375">common_socket(int family, int type, int protocol, bool kernel)</a>
<a name="ln376">{</a>
<a name="ln377">	if (!get_stack_interface_module())</a>
<a name="ln378">		return B_UNSUPPORTED;</a>
<a name="ln379"> </a>
<a name="ln380">	// create the socket</a>
<a name="ln381">	net_socket* socket;</a>
<a name="ln382">	status_t error = sStackInterface-&gt;open(family, type, protocol, &amp;socket);</a>
<a name="ln383">	if (error != B_OK) {</a>
<a name="ln384">		put_stack_interface_module();</a>
<a name="ln385">		return error;</a>
<a name="ln386">	}</a>
<a name="ln387"> </a>
<a name="ln388">	// allocate the FD</a>
<a name="ln389">	int fd = create_socket_fd(socket, kernel);</a>
<a name="ln390">	if (fd &lt; 0) {</a>
<a name="ln391">		sStackInterface-&gt;close(socket);</a>
<a name="ln392">		sStackInterface-&gt;free(socket);</a>
<a name="ln393">		put_stack_interface_module();</a>
<a name="ln394">	}</a>
<a name="ln395"> </a>
<a name="ln396">	return fd;</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">static status_t</a>
<a name="ln401">common_bind(int fd, const struct sockaddr *address, socklen_t addressLength,</a>
<a name="ln402">	bool kernel)</a>
<a name="ln403">{</a>
<a name="ln404">	file_descriptor* descriptor;</a>
<a name="ln405">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln406">	FDPutter _(descriptor);</a>
<a name="ln407"> </a>
<a name="ln408">	return sStackInterface-&gt;bind(descriptor-&gt;u.socket, address, addressLength);</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411"> </a>
<a name="ln412">static status_t</a>
<a name="ln413">common_shutdown(int fd, int how, bool kernel)</a>
<a name="ln414">{</a>
<a name="ln415">	file_descriptor* descriptor;</a>
<a name="ln416">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln417">	FDPutter _(descriptor);</a>
<a name="ln418"> </a>
<a name="ln419">	return sStackInterface-&gt;shutdown(descriptor-&gt;u.socket, how);</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">static status_t</a>
<a name="ln424">common_connect(int fd, const struct sockaddr *address,</a>
<a name="ln425">	socklen_t addressLength, bool kernel)</a>
<a name="ln426">{</a>
<a name="ln427">	file_descriptor* descriptor;</a>
<a name="ln428">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln429">	FDPutter _(descriptor);</a>
<a name="ln430"> </a>
<a name="ln431">	return sStackInterface-&gt;connect(descriptor-&gt;u.socket, address,</a>
<a name="ln432">		addressLength);</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435"> </a>
<a name="ln436">static status_t</a>
<a name="ln437">common_listen(int fd, int backlog, bool kernel)</a>
<a name="ln438">{</a>
<a name="ln439">	file_descriptor* descriptor;</a>
<a name="ln440">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln441">	FDPutter _(descriptor);</a>
<a name="ln442"> </a>
<a name="ln443">	return sStackInterface-&gt;listen(descriptor-&gt;u.socket, backlog);</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446"> </a>
<a name="ln447">static int</a>
<a name="ln448">common_accept(int fd, struct sockaddr *address, socklen_t *_addressLength,</a>
<a name="ln449">	bool kernel)</a>
<a name="ln450">{</a>
<a name="ln451">	file_descriptor* descriptor;</a>
<a name="ln452">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln453">	FDPutter _(descriptor);</a>
<a name="ln454"> </a>
<a name="ln455">	net_socket* acceptedSocket;</a>
<a name="ln456">	status_t error = sStackInterface-&gt;accept(descriptor-&gt;u.socket, address,</a>
<a name="ln457">		_addressLength, &amp;acceptedSocket);</a>
<a name="ln458">	if (error != B_OK)</a>
<a name="ln459">		return error;</a>
<a name="ln460"> </a>
<a name="ln461">	// allocate the FD</a>
<a name="ln462">	int acceptedFD = create_socket_fd(acceptedSocket, kernel);</a>
<a name="ln463">	if (acceptedFD &lt; 0) {</a>
<a name="ln464">		sStackInterface-&gt;close(acceptedSocket);</a>
<a name="ln465">		sStackInterface-&gt;free(acceptedSocket);</a>
<a name="ln466">	} else {</a>
<a name="ln467">		// we need a reference for the new FD</a>
<a name="ln468">		get_stack_interface_module();</a>
<a name="ln469">	}</a>
<a name="ln470"> </a>
<a name="ln471">	return acceptedFD;</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474"> </a>
<a name="ln475">static ssize_t</a>
<a name="ln476">common_recv(int fd, void *data, size_t length, int flags, bool kernel)</a>
<a name="ln477">{</a>
<a name="ln478">	file_descriptor* descriptor;</a>
<a name="ln479">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln480">	FDPutter _(descriptor);</a>
<a name="ln481"> </a>
<a name="ln482">	return sStackInterface-&gt;recv(descriptor-&gt;u.socket, data, length, flags);</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485"> </a>
<a name="ln486">static ssize_t</a>
<a name="ln487">common_recvfrom(int fd, void *data, size_t length, int flags,</a>
<a name="ln488">	struct sockaddr *address, socklen_t *_addressLength, bool kernel)</a>
<a name="ln489">{</a>
<a name="ln490">	file_descriptor* descriptor;</a>
<a name="ln491">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln492">	FDPutter _(descriptor);</a>
<a name="ln493"> </a>
<a name="ln494">	return sStackInterface-&gt;recvfrom(descriptor-&gt;u.socket, data, length,</a>
<a name="ln495">		flags, address, _addressLength);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498"> </a>
<a name="ln499">static ssize_t</a>
<a name="ln500">common_recvmsg(int fd, struct msghdr *message, int flags, bool kernel)</a>
<a name="ln501">{</a>
<a name="ln502">	file_descriptor* descriptor;</a>
<a name="ln503">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln504">	FDPutter _(descriptor);</a>
<a name="ln505"> </a>
<a name="ln506">	return sStackInterface-&gt;recvmsg(descriptor-&gt;u.socket, message, flags);</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">static ssize_t</a>
<a name="ln511">common_send(int fd, const void *data, size_t length, int flags, bool kernel)</a>
<a name="ln512">{</a>
<a name="ln513">	file_descriptor* descriptor;</a>
<a name="ln514">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln515">	FDPutter _(descriptor);</a>
<a name="ln516"> </a>
<a name="ln517">	return sStackInterface-&gt;send(descriptor-&gt;u.socket, data, length, flags);</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520"> </a>
<a name="ln521">static ssize_t</a>
<a name="ln522">common_sendto(int fd, const void *data, size_t length, int flags,</a>
<a name="ln523">	const struct sockaddr *address, socklen_t addressLength, bool kernel)</a>
<a name="ln524">{</a>
<a name="ln525">	file_descriptor* descriptor;</a>
<a name="ln526">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln527">	FDPutter _(descriptor);</a>
<a name="ln528"> </a>
<a name="ln529">	return sStackInterface-&gt;sendto(descriptor-&gt;u.socket, data, length, flags,</a>
<a name="ln530">		address, addressLength);</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">static ssize_t</a>
<a name="ln535">common_sendmsg(int fd, const struct msghdr *message, int flags, bool kernel)</a>
<a name="ln536">{</a>
<a name="ln537">	file_descriptor* descriptor;</a>
<a name="ln538">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln539">	FDPutter _(descriptor);</a>
<a name="ln540"> </a>
<a name="ln541">	return sStackInterface-&gt;sendmsg(descriptor-&gt;u.socket, message, flags);</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544"> </a>
<a name="ln545">static status_t</a>
<a name="ln546">common_getsockopt(int fd, int level, int option, void *value,</a>
<a name="ln547">	socklen_t *_length, bool kernel)</a>
<a name="ln548">{</a>
<a name="ln549">	file_descriptor* descriptor;</a>
<a name="ln550">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln551">	FDPutter _(descriptor);</a>
<a name="ln552"> </a>
<a name="ln553">	return sStackInterface-&gt;getsockopt(descriptor-&gt;u.socket, level, option,</a>
<a name="ln554">		value, _length);</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557"> </a>
<a name="ln558">static status_t</a>
<a name="ln559">common_setsockopt(int fd, int level, int option, const void *value,</a>
<a name="ln560">	socklen_t length, bool kernel)</a>
<a name="ln561">{</a>
<a name="ln562">	file_descriptor* descriptor;</a>
<a name="ln563">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln564">	FDPutter _(descriptor);</a>
<a name="ln565"> </a>
<a name="ln566">	return sStackInterface-&gt;setsockopt(descriptor-&gt;u.socket, level, option,</a>
<a name="ln567">		value, length);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570"> </a>
<a name="ln571">static status_t</a>
<a name="ln572">common_getpeername(int fd, struct sockaddr *address,</a>
<a name="ln573">	socklen_t *_addressLength, bool kernel)</a>
<a name="ln574">{</a>
<a name="ln575">	file_descriptor* descriptor;</a>
<a name="ln576">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln577">	FDPutter _(descriptor);</a>
<a name="ln578"> </a>
<a name="ln579">	return sStackInterface-&gt;getpeername(descriptor-&gt;u.socket, address,</a>
<a name="ln580">		_addressLength);</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">static status_t</a>
<a name="ln585">common_getsockname(int fd, struct sockaddr *address,</a>
<a name="ln586">	socklen_t *_addressLength, bool kernel)</a>
<a name="ln587">{</a>
<a name="ln588">	file_descriptor* descriptor;</a>
<a name="ln589">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln590">	FDPutter _(descriptor);</a>
<a name="ln591"> </a>
<a name="ln592">	return sStackInterface-&gt;getsockname(descriptor-&gt;u.socket, address,</a>
<a name="ln593">		_addressLength);</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596"> </a>
<a name="ln597">static int</a>
<a name="ln598">common_sockatmark(int fd, bool kernel)</a>
<a name="ln599">{</a>
<a name="ln600">	file_descriptor* descriptor;</a>
<a name="ln601">	GET_SOCKET_FD_OR_RETURN(fd, kernel, descriptor);</a>
<a name="ln602">	FDPutter _(descriptor);</a>
<a name="ln603"> </a>
<a name="ln604">	return sStackInterface-&gt;sockatmark(descriptor-&gt;u.socket);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607"> </a>
<a name="ln608">static status_t</a>
<a name="ln609">common_socketpair(int family, int type, int protocol, int fds[2], bool kernel)</a>
<a name="ln610">{</a>
<a name="ln611">	if (!get_stack_interface_module())</a>
<a name="ln612">		return B_UNSUPPORTED;</a>
<a name="ln613"> </a>
<a name="ln614">	net_socket* sockets[2];</a>
<a name="ln615">	status_t error = sStackInterface-&gt;socketpair(family, type, protocol,</a>
<a name="ln616">		sockets);</a>
<a name="ln617">	if (error != B_OK) {</a>
<a name="ln618">		put_stack_interface_module();</a>
<a name="ln619">		return error;</a>
<a name="ln620">	}</a>
<a name="ln621"> </a>
<a name="ln622">	// allocate the FDs</a>
<a name="ln623">	for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln624">		fds[i] = create_socket_fd(sockets[i], kernel);</a>
<a name="ln625">		if (fds[i] &lt; 0) {</a>
<a name="ln626">			sStackInterface-&gt;close(sockets[i]);</a>
<a name="ln627">			sStackInterface-&gt;free(sockets[i]);</a>
<a name="ln628">			put_stack_interface_module();</a>
<a name="ln629">			return fds[i];</a>
<a name="ln630">		}</a>
<a name="ln631">	}</a>
<a name="ln632"> </a>
<a name="ln633">	// We need another reference for the second socket</a>
<a name="ln634">	get_stack_interface_module();</a>
<a name="ln635">	return B_OK;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638"> </a>
<a name="ln639">static status_t</a>
<a name="ln640">common_get_next_socket_stat(int family, uint32 *cookie, struct net_stat *stat)</a>
<a name="ln641">{</a>
<a name="ln642">	if (!get_stack_interface_module())</a>
<a name="ln643">		return B_UNSUPPORTED;</a>
<a name="ln644"> </a>
<a name="ln645">	status_t status = sStackInterface-&gt;get_next_socket_stat(family, cookie,</a>
<a name="ln646">		stat);</a>
<a name="ln647"> </a>
<a name="ln648">	put_stack_interface_module();</a>
<a name="ln649">	return status;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652"> </a>
<a name="ln653">// #pragma mark - kernel sockets API</a>
<a name="ln654"> </a>
<a name="ln655"> </a>
<a name="ln656">int</a>
<a name="ln657">socket(int family, int type, int protocol)</a>
<a name="ln658">{</a>
<a name="ln659">	SyscallFlagUnsetter _;</a>
<a name="ln660">	RETURN_AND_SET_ERRNO(common_socket(family, type, protocol, true));</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663"> </a>
<a name="ln664">int</a>
<a name="ln665">bind(int socket, const struct sockaddr *address, socklen_t addressLength)</a>
<a name="ln666">{</a>
<a name="ln667">	SyscallFlagUnsetter _;</a>
<a name="ln668">	RETURN_AND_SET_ERRNO(common_bind(socket, address, addressLength, true));</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">int</a>
<a name="ln673">shutdown(int socket, int how)</a>
<a name="ln674">{</a>
<a name="ln675">	SyscallFlagUnsetter _;</a>
<a name="ln676">	RETURN_AND_SET_ERRNO(common_shutdown(socket, how, true));</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679"> </a>
<a name="ln680">int</a>
<a name="ln681">connect(int socket, const struct sockaddr *address, socklen_t addressLength)</a>
<a name="ln682">{</a>
<a name="ln683">	SyscallFlagUnsetter _;</a>
<a name="ln684">	RETURN_AND_SET_ERRNO(common_connect(socket, address, addressLength, true));</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687"> </a>
<a name="ln688">int</a>
<a name="ln689">listen(int socket, int backlog)</a>
<a name="ln690">{</a>
<a name="ln691">	SyscallFlagUnsetter _;</a>
<a name="ln692">	RETURN_AND_SET_ERRNO(common_listen(socket, backlog, true));</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">int</a>
<a name="ln697">accept(int socket, struct sockaddr *address, socklen_t *_addressLength)</a>
<a name="ln698">{</a>
<a name="ln699">	SyscallFlagUnsetter _;</a>
<a name="ln700">	RETURN_AND_SET_ERRNO(common_accept(socket, address, _addressLength, true));</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704">ssize_t</a>
<a name="ln705">recv(int socket, void *data, size_t length, int flags)</a>
<a name="ln706">{</a>
<a name="ln707">	SyscallFlagUnsetter _;</a>
<a name="ln708">	RETURN_AND_SET_ERRNO(common_recv(socket, data, length, flags, true));</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711"> </a>
<a name="ln712">ssize_t</a>
<a name="ln713">recvfrom(int socket, void *data, size_t length, int flags,</a>
<a name="ln714">	struct sockaddr *address, socklen_t *_addressLength)</a>
<a name="ln715">{</a>
<a name="ln716">	SyscallFlagUnsetter _;</a>
<a name="ln717">	RETURN_AND_SET_ERRNO(common_recvfrom(socket, data, length, flags, address,</a>
<a name="ln718">		_addressLength, true));</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">ssize_t</a>
<a name="ln723">recvmsg(int socket, struct msghdr *message, int flags)</a>
<a name="ln724">{</a>
<a name="ln725">	SyscallFlagUnsetter _;</a>
<a name="ln726">	RETURN_AND_SET_ERRNO(common_recvmsg(socket, message, flags, true));</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729"> </a>
<a name="ln730">ssize_t</a>
<a name="ln731">send(int socket, const void *data, size_t length, int flags)</a>
<a name="ln732">{</a>
<a name="ln733">	SyscallFlagUnsetter _;</a>
<a name="ln734">	RETURN_AND_SET_ERRNO(common_send(socket, data, length, flags, true));</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737"> </a>
<a name="ln738">ssize_t</a>
<a name="ln739">sendto(int socket, const void *data, size_t length, int flags,</a>
<a name="ln740">	const struct sockaddr *address, socklen_t addressLength)</a>
<a name="ln741">{</a>
<a name="ln742">	SyscallFlagUnsetter _;</a>
<a name="ln743">	RETURN_AND_SET_ERRNO(common_sendto(socket, data, length, flags, address,</a>
<a name="ln744">		addressLength, true));</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747"> </a>
<a name="ln748">ssize_t</a>
<a name="ln749">sendmsg(int socket, const struct msghdr *message, int flags)</a>
<a name="ln750">{</a>
<a name="ln751">	SyscallFlagUnsetter _;</a>
<a name="ln752">	RETURN_AND_SET_ERRNO(common_sendmsg(socket, message, flags, true));</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">int</a>
<a name="ln757">getsockopt(int socket, int level, int option, void *value, socklen_t *_length)</a>
<a name="ln758">{</a>
<a name="ln759">	SyscallFlagUnsetter _;</a>
<a name="ln760">	RETURN_AND_SET_ERRNO(common_getsockopt(socket, level, option, value,</a>
<a name="ln761">		_length, true));</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">int</a>
<a name="ln766">setsockopt(int socket, int level, int option, const void *value,</a>
<a name="ln767">	socklen_t length)</a>
<a name="ln768">{</a>
<a name="ln769">	SyscallFlagUnsetter _;</a>
<a name="ln770">	RETURN_AND_SET_ERRNO(common_setsockopt(socket, level, option, value,</a>
<a name="ln771">		length, true));</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774"> </a>
<a name="ln775">int</a>
<a name="ln776">getpeername(int socket, struct sockaddr *address, socklen_t *_addressLength)</a>
<a name="ln777">{</a>
<a name="ln778">	SyscallFlagUnsetter _;</a>
<a name="ln779">	RETURN_AND_SET_ERRNO(common_getpeername(socket, address, _addressLength,</a>
<a name="ln780">		true));</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784">int</a>
<a name="ln785">getsockname(int socket, struct sockaddr *address, socklen_t *_addressLength)</a>
<a name="ln786">{</a>
<a name="ln787">	SyscallFlagUnsetter _;</a>
<a name="ln788">	RETURN_AND_SET_ERRNO(common_getsockname(socket, address, _addressLength,</a>
<a name="ln789">		true));</a>
<a name="ln790">}</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">int</a>
<a name="ln794">sockatmark(int socket)</a>
<a name="ln795">{</a>
<a name="ln796">	SyscallFlagUnsetter _;</a>
<a name="ln797">	RETURN_AND_SET_ERRNO(common_sockatmark(socket, true));</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801">int</a>
<a name="ln802">socketpair(int family, int type, int protocol, int socketVector[2])</a>
<a name="ln803">{</a>
<a name="ln804">	SyscallFlagUnsetter _;</a>
<a name="ln805">	RETURN_AND_SET_ERRNO(common_socketpair(family, type, protocol,</a>
<a name="ln806">		socketVector, true));</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">// #pragma mark - syscalls</a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813">int</a>
<a name="ln814">_user_socket(int family, int type, int protocol)</a>
<a name="ln815">{</a>
<a name="ln816">	SyscallRestartWrapper&lt;int&gt; result;</a>
<a name="ln817">	return result = common_socket(family, type, protocol, false);</a>
<a name="ln818">}</a>
<a name="ln819"> </a>
<a name="ln820"> </a>
<a name="ln821">status_t</a>
<a name="ln822">_user_bind(int socket, const struct sockaddr *userAddress,</a>
<a name="ln823">	socklen_t addressLength)</a>
<a name="ln824">{</a>
<a name="ln825">	// check parameters and copy address from userland</a>
<a name="ln826">	if (userAddress == NULL || addressLength &gt; MAX_SOCKET_ADDRESS_LENGTH)</a>
<a name="ln827">		return B_BAD_VALUE;</a>
<a name="ln828"> </a>
<a name="ln829">	sockaddr_storage address;</a>
<a name="ln830">	memset(&amp;address, 0, sizeof(address));</a>
<a name="ln831">	if (!IS_USER_ADDRESS(userAddress)</a>
<a name="ln832">			|| user_memcpy(&amp;address, userAddress, addressLength) != B_OK) {</a>
<a name="ln833">		return B_BAD_ADDRESS;</a>
<a name="ln834">	}</a>
<a name="ln835"> </a>
<a name="ln836">	address.ss_len = addressLength;</a>
<a name="ln837">		// make sure the sa_len field is set correctly</a>
<a name="ln838"> </a>
<a name="ln839">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln840">	return error = common_bind(socket, (sockaddr*)&amp;address, addressLength,</a>
<a name="ln841">		false);</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">status_t</a>
<a name="ln846">_user_shutdown_socket(int socket, int how)</a>
<a name="ln847">{</a>
<a name="ln848">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln849">	return error = common_shutdown(socket, how, false);</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852"> </a>
<a name="ln853">status_t</a>
<a name="ln854">_user_connect(int socket, const struct sockaddr *userAddress,</a>
<a name="ln855">	socklen_t addressLength)</a>
<a name="ln856">{</a>
<a name="ln857">	// check parameters and copy address from userland</a>
<a name="ln858">	if (userAddress == NULL || addressLength &gt; MAX_SOCKET_ADDRESS_LENGTH)</a>
<a name="ln859">		return B_BAD_VALUE;</a>
<a name="ln860"> </a>
<a name="ln861">	sockaddr_storage address;</a>
<a name="ln862">	memset(&amp;address, 0, sizeof(address));</a>
<a name="ln863">	if (!IS_USER_ADDRESS(userAddress)</a>
<a name="ln864">			|| user_memcpy(&amp;address, userAddress, addressLength) != B_OK) {</a>
<a name="ln865">		return B_BAD_ADDRESS;</a>
<a name="ln866">	}</a>
<a name="ln867"> </a>
<a name="ln868">	address.ss_len = addressLength;</a>
<a name="ln869">		// make sure the sa_len field is set correctly</a>
<a name="ln870"> </a>
<a name="ln871">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln872"> </a>
<a name="ln873">	return error = common_connect(socket, (sockaddr*)&amp;address, addressLength,</a>
<a name="ln874">		false);</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877"> </a>
<a name="ln878">status_t</a>
<a name="ln879">_user_listen(int socket, int backlog)</a>
<a name="ln880">{</a>
<a name="ln881">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln882">	return error = common_listen(socket, backlog, false);</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885"> </a>
<a name="ln886">int</a>
<a name="ln887">_user_accept(int socket, struct sockaddr *userAddress,</a>
<a name="ln888">	socklen_t *_addressLength)</a>
<a name="ln889">{</a>
<a name="ln890">	// check parameters</a>
<a name="ln891">	socklen_t addressLength = 0;</a>
<a name="ln892">	status_t error = prepare_userland_address_result(userAddress,</a>
<a name="ln893">		_addressLength, addressLength, false);</a>
<a name="ln894">	if (error != B_OK)</a>
<a name="ln895">		return error;</a>
<a name="ln896"> </a>
<a name="ln897">	// accept()</a>
<a name="ln898">	SyscallRestartWrapper&lt;int&gt; result;</a>
<a name="ln899"> </a>
<a name="ln900">	char address[MAX_SOCKET_ADDRESS_LENGTH];</a>
<a name="ln901">	socklen_t userAddressBufferSize = addressLength;</a>
<a name="ln902">	result = common_accept(socket,</a>
<a name="ln903">		userAddress != NULL ? (sockaddr*)address : NULL, &amp;addressLength, false);</a>
<a name="ln904"> </a>
<a name="ln905">	// copy address size and address back to userland</a>
<a name="ln906">	if (copy_address_to_userland(address, addressLength, userAddress,</a>
<a name="ln907">			userAddressBufferSize, _addressLength) != B_OK) {</a>
<a name="ln908">		_user_close(result);</a>
<a name="ln909">		return B_BAD_ADDRESS;</a>
<a name="ln910">	}</a>
<a name="ln911"> </a>
<a name="ln912">	return result;</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915"> </a>
<a name="ln916">ssize_t</a>
<a name="ln917">_user_recv(int socket, void *data, size_t length, int flags)</a>
<a name="ln918">{</a>
<a name="ln919">	if (data == NULL || !IS_USER_ADDRESS(data))</a>
<a name="ln920">		return B_BAD_ADDRESS;</a>
<a name="ln921"> </a>
<a name="ln922">	SyscallRestartWrapper&lt;ssize_t&gt; result;</a>
<a name="ln923">	return result = common_recv(socket, data, length, flags, false);</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926"> </a>
<a name="ln927">ssize_t</a>
<a name="ln928">_user_recvfrom(int socket, void *data, size_t length, int flags,</a>
<a name="ln929">	struct sockaddr *userAddress, socklen_t *_addressLength)</a>
<a name="ln930">{</a>
<a name="ln931">	if (data == NULL || !IS_USER_ADDRESS(data))</a>
<a name="ln932">		return B_BAD_ADDRESS;</a>
<a name="ln933"> </a>
<a name="ln934">	// check parameters</a>
<a name="ln935">	socklen_t addressLength = 0;</a>
<a name="ln936">	status_t error = prepare_userland_address_result(userAddress,</a>
<a name="ln937">		_addressLength, addressLength, false);</a>
<a name="ln938">	if (error != B_OK)</a>
<a name="ln939">		return error;</a>
<a name="ln940"> </a>
<a name="ln941">	// recvfrom()</a>
<a name="ln942">	SyscallRestartWrapper&lt;ssize_t&gt; result;</a>
<a name="ln943"> </a>
<a name="ln944">	char address[MAX_SOCKET_ADDRESS_LENGTH];</a>
<a name="ln945">	socklen_t userAddressBufferSize = addressLength;</a>
<a name="ln946">	result = common_recvfrom(socket, data, length, flags,</a>
<a name="ln947">		userAddress != NULL ? (sockaddr*)address : NULL, &amp;addressLength, false);</a>
<a name="ln948">	if (result &lt; 0)</a>
<a name="ln949">		return result;</a>
<a name="ln950"> </a>
<a name="ln951">	// copy address size and address back to userland</a>
<a name="ln952">	if (copy_address_to_userland(address, addressLength, userAddress,</a>
<a name="ln953">			userAddressBufferSize, _addressLength) != B_OK) {</a>
<a name="ln954">		return B_BAD_ADDRESS;</a>
<a name="ln955">	}</a>
<a name="ln956"> </a>
<a name="ln957">	return result;</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960"> </a>
<a name="ln961">ssize_t</a>
<a name="ln962">_user_recvmsg(int socket, struct msghdr *userMessage, int flags)</a>
<a name="ln963">{</a>
<a name="ln964">	// copy message from userland</a>
<a name="ln965">	msghdr message;</a>
<a name="ln966">	iovec* userVecs;</a>
<a name="ln967">	MemoryDeleter vecsDeleter;</a>
<a name="ln968">	void* userAddress;</a>
<a name="ln969">	char address[MAX_SOCKET_ADDRESS_LENGTH];</a>
<a name="ln970"> </a>
<a name="ln971">	status_t error = prepare_userland_msghdr(userMessage, message, userVecs,</a>
<a name="ln972">		vecsDeleter, userAddress, address);</a>
<a name="ln973">	if (error != B_OK)</a>
<a name="ln974">		return error;</a>
<a name="ln975"> </a>
<a name="ln976">	// prepare a buffer for ancillary data</a>
<a name="ln977">	MemoryDeleter ancillaryDeleter;</a>
<a name="ln978">	void* ancillary = NULL;</a>
<a name="ln979">	void* userAncillary = message.msg_control;</a>
<a name="ln980">	if (userAncillary != NULL) {</a>
<a name="ln981">		if (!IS_USER_ADDRESS(userAncillary))</a>
<a name="ln982">			return B_BAD_ADDRESS;</a>
<a name="ln983">		if (message.msg_controllen &lt; 0)</a>
<a name="ln984">			return B_BAD_VALUE;</a>
<a name="ln985">		if (message.msg_controllen &gt; MAX_ANCILLARY_DATA_LENGTH)</a>
<a name="ln986">			message.msg_controllen = MAX_ANCILLARY_DATA_LENGTH;</a>
<a name="ln987"> </a>
<a name="ln988">		message.msg_control = ancillary = malloc(message.msg_controllen);</a>
<a name="ln989">		if (message.msg_control == NULL)</a>
<a name="ln990">			return B_NO_MEMORY;</a>
<a name="ln991"> </a>
<a name="ln992">		ancillaryDeleter.SetTo(ancillary);</a>
<a name="ln993">	}</a>
<a name="ln994"> </a>
<a name="ln995">	// recvmsg()</a>
<a name="ln996">	SyscallRestartWrapper&lt;ssize_t&gt; result;</a>
<a name="ln997"> </a>
<a name="ln998">	result = common_recvmsg(socket, &amp;message, flags, false);</a>
<a name="ln999">	if (result &lt; 0)</a>
<a name="ln1000">		return result;</a>
<a name="ln1001"> </a>
<a name="ln1002">	// copy the address, the ancillary data, and the message header back to</a>
<a name="ln1003">	// userland</a>
<a name="ln1004">	message.msg_name = userAddress;</a>
<a name="ln1005">	message.msg_iov = userVecs;</a>
<a name="ln1006">	message.msg_control = userAncillary;</a>
<a name="ln1007">	if ((userAddress != NULL &amp;&amp; user_memcpy(userAddress, address,</a>
<a name="ln1008">				message.msg_namelen) != B_OK)</a>
<a name="ln1009">		|| (userAncillary != NULL &amp;&amp; user_memcpy(userAncillary, ancillary,</a>
<a name="ln1010">				message.msg_controllen) != B_OK)</a>
<a name="ln1011">		|| user_memcpy(userMessage, &amp;message, sizeof(msghdr)) != B_OK) {</a>
<a name="ln1012">		return B_BAD_ADDRESS;</a>
<a name="ln1013">	}</a>
<a name="ln1014"> </a>
<a name="ln1015">	return result;</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018"> </a>
<a name="ln1019">ssize_t</a>
<a name="ln1020">_user_send(int socket, const void *data, size_t length, int flags)</a>
<a name="ln1021">{</a>
<a name="ln1022">	if (data == NULL || !IS_USER_ADDRESS(data))</a>
<a name="ln1023">		return B_BAD_ADDRESS;</a>
<a name="ln1024"> </a>
<a name="ln1025">	SyscallRestartWrapper&lt;ssize_t&gt; result;</a>
<a name="ln1026">	return result = common_send(socket, data, length, flags, false);</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029"> </a>
<a name="ln1030">ssize_t</a>
<a name="ln1031">_user_sendto(int socket, const void *data, size_t length, int flags,</a>
<a name="ln1032">	const struct sockaddr *userAddress, socklen_t addressLength)</a>
<a name="ln1033">{</a>
<a name="ln1034">	if (data == NULL || !IS_USER_ADDRESS(data))</a>
<a name="ln1035">		return B_BAD_ADDRESS;</a>
<a name="ln1036"> </a>
<a name="ln1037">	// TODO: If this is a connection-mode socket, the address parameter is</a>
<a name="ln1038">	// supposed to be ignored.</a>
<a name="ln1039">	if (userAddress == NULL || addressLength &lt;= 0</a>
<a name="ln1040">			|| addressLength &gt; MAX_SOCKET_ADDRESS_LENGTH) {</a>
<a name="ln1041">		return B_BAD_VALUE;</a>
<a name="ln1042">	}</a>
<a name="ln1043"> </a>
<a name="ln1044">	// copy address from userland</a>
<a name="ln1045">	char address[MAX_SOCKET_ADDRESS_LENGTH];</a>
<a name="ln1046">	if (!IS_USER_ADDRESS(userAddress)</a>
<a name="ln1047">			|| user_memcpy(address, userAddress, addressLength) != B_OK) {</a>
<a name="ln1048">		return B_BAD_ADDRESS;</a>
<a name="ln1049">	}</a>
<a name="ln1050"> </a>
<a name="ln1051">	// sendto()</a>
<a name="ln1052">	SyscallRestartWrapper&lt;ssize_t&gt; result;</a>
<a name="ln1053"> </a>
<a name="ln1054">	return result = common_sendto(socket, data, length, flags,</a>
<a name="ln1055">		(sockaddr*)address, addressLength, false);</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058"> </a>
<a name="ln1059">ssize_t</a>
<a name="ln1060">_user_sendmsg(int socket, const struct msghdr *userMessage, int flags)</a>
<a name="ln1061">{</a>
<a name="ln1062">	// copy message from userland</a>
<a name="ln1063">	msghdr message;</a>
<a name="ln1064">	iovec* userVecs;</a>
<a name="ln1065">	MemoryDeleter vecsDeleter;</a>
<a name="ln1066">	void* userAddress;</a>
<a name="ln1067">	char address[MAX_SOCKET_ADDRESS_LENGTH];</a>
<a name="ln1068"> </a>
<a name="ln1069">	status_t error = prepare_userland_msghdr(userMessage, message, userVecs,</a>
<a name="ln1070">		vecsDeleter, userAddress, address);</a>
<a name="ln1071">	if (error != B_OK)</a>
<a name="ln1072">		return error;</a>
<a name="ln1073"> </a>
<a name="ln1074">	// copy the address from userland</a>
<a name="ln1075">	if (userAddress != NULL</a>
<a name="ln1076">			&amp;&amp; user_memcpy(address, userAddress, message.msg_namelen) != B_OK) {</a>
<a name="ln1077">		return B_BAD_ADDRESS;</a>
<a name="ln1078">	}</a>
<a name="ln1079"> </a>
<a name="ln1080">	// copy ancillary data from userland</a>
<a name="ln1081">	MemoryDeleter ancillaryDeleter;</a>
<a name="ln1082">	void* userAncillary = message.msg_control;</a>
<a name="ln1083">	if (userAncillary != NULL) {</a>
<a name="ln1084">		if (!IS_USER_ADDRESS(userAncillary))</a>
<a name="ln1085">			return B_BAD_ADDRESS;</a>
<a name="ln1086">		if (message.msg_controllen &lt; 0</a>
<a name="ln1087">				|| message.msg_controllen &gt; MAX_ANCILLARY_DATA_LENGTH) {</a>
<a name="ln1088">			return B_BAD_VALUE;</a>
<a name="ln1089">		}</a>
<a name="ln1090"> </a>
<a name="ln1091">		message.msg_control = malloc(message.msg_controllen);</a>
<a name="ln1092">		if (message.msg_control == NULL)</a>
<a name="ln1093">			return B_NO_MEMORY;</a>
<a name="ln1094">		ancillaryDeleter.SetTo(message.msg_control);</a>
<a name="ln1095"> </a>
<a name="ln1096">		if (user_memcpy(message.msg_control, userAncillary,</a>
<a name="ln1097">				message.msg_controllen) != B_OK) {</a>
<a name="ln1098">			return B_BAD_ADDRESS;</a>
<a name="ln1099">		}</a>
<a name="ln1100">	}</a>
<a name="ln1101"> </a>
<a name="ln1102">	// sendmsg()</a>
<a name="ln1103">	SyscallRestartWrapper&lt;ssize_t&gt; result;</a>
<a name="ln1104"> </a>
<a name="ln1105">	return result = common_sendmsg(socket, &amp;message, flags, false);</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108"> </a>
<a name="ln1109">status_t</a>
<a name="ln1110">_user_getsockopt(int socket, int level, int option, void *userValue,</a>
<a name="ln1111">	socklen_t *_length)</a>
<a name="ln1112">{</a>
<a name="ln1113">	// check params</a>
<a name="ln1114">	if (userValue == NULL || _length == NULL)</a>
<a name="ln1115">		return B_BAD_VALUE;</a>
<a name="ln1116">	if (!IS_USER_ADDRESS(userValue) || !IS_USER_ADDRESS(_length))</a>
<a name="ln1117">		return B_BAD_ADDRESS;</a>
<a name="ln1118"> </a>
<a name="ln1119">	// copy length from userland</a>
<a name="ln1120">	socklen_t length;</a>
<a name="ln1121">	if (user_memcpy(&amp;length, _length, sizeof(socklen_t)) != B_OK)</a>
<a name="ln1122">		return B_BAD_ADDRESS;</a>
<a name="ln1123"> </a>
<a name="ln1124">	if (length &gt; MAX_SOCKET_OPTION_LENGTH)</a>
<a name="ln1125">		return B_BAD_VALUE;</a>
<a name="ln1126"> </a>
<a name="ln1127">	// getsockopt()</a>
<a name="ln1128">	char value[MAX_SOCKET_OPTION_LENGTH];</a>
<a name="ln1129">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln1130">	error = common_getsockopt(socket, level, option, value, &amp;length,</a>
<a name="ln1131">		false);</a>
<a name="ln1132">	if (error != B_OK)</a>
<a name="ln1133">		return error;</a>
<a name="ln1134"> </a>
<a name="ln1135">	// copy value back to userland</a>
<a name="ln1136">	if (user_memcpy(userValue, value, length) != B_OK)</a>
<a name="ln1137">		return B_BAD_ADDRESS;</a>
<a name="ln1138"> </a>
<a name="ln1139">	return B_OK;</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142"> </a>
<a name="ln1143">status_t</a>
<a name="ln1144">_user_setsockopt(int socket, int level, int option, const void *userValue,</a>
<a name="ln1145">	socklen_t length)</a>
<a name="ln1146">{</a>
<a name="ln1147">	// check params</a>
<a name="ln1148">	if (userValue == NULL || length &gt; MAX_SOCKET_OPTION_LENGTH)</a>
<a name="ln1149">		return B_BAD_VALUE;</a>
<a name="ln1150"> </a>
<a name="ln1151">	// copy value from userland</a>
<a name="ln1152">	char value[MAX_SOCKET_OPTION_LENGTH];</a>
<a name="ln1153">	if (!IS_USER_ADDRESS(userValue)</a>
<a name="ln1154">			|| user_memcpy(value, userValue, length) != B_OK) {</a>
<a name="ln1155">		return B_BAD_ADDRESS;</a>
<a name="ln1156">	}</a>
<a name="ln1157"> </a>
<a name="ln1158">	// setsockopt();</a>
<a name="ln1159">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln1160">	return error = common_setsockopt(socket, level, option, value, length,</a>
<a name="ln1161">		false);</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164"> </a>
<a name="ln1165">status_t</a>
<a name="ln1166">_user_getpeername(int socket, struct sockaddr *userAddress,</a>
<a name="ln1167">	socklen_t *_addressLength)</a>
<a name="ln1168">{</a>
<a name="ln1169">	// check parameters</a>
<a name="ln1170">	socklen_t addressLength = 0;</a>
<a name="ln1171">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln1172">	error = prepare_userland_address_result(userAddress, _addressLength,</a>
<a name="ln1173">		addressLength, true);</a>
<a name="ln1174">	if (error != B_OK)</a>
<a name="ln1175">		return error;</a>
<a name="ln1176"> </a>
<a name="ln1177">	// getpeername()</a>
<a name="ln1178">	char address[MAX_SOCKET_ADDRESS_LENGTH];</a>
<a name="ln1179">	socklen_t userAddressBufferSize = addressLength;</a>
<a name="ln1180">	error = common_getpeername(socket, (sockaddr*)address, &amp;addressLength,</a>
<a name="ln1181">		false);</a>
<a name="ln1182">	if (error != B_OK)</a>
<a name="ln1183">		return error;</a>
<a name="ln1184"> </a>
<a name="ln1185">	// copy address size and address back to userland</a>
<a name="ln1186">	if (copy_address_to_userland(address, addressLength, userAddress,</a>
<a name="ln1187">			userAddressBufferSize, _addressLength) != B_OK) {</a>
<a name="ln1188">		return B_BAD_ADDRESS;</a>
<a name="ln1189">	}</a>
<a name="ln1190"> </a>
<a name="ln1191">	return B_OK;</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194"> </a>
<a name="ln1195">status_t</a>
<a name="ln1196">_user_getsockname(int socket, struct sockaddr *userAddress,</a>
<a name="ln1197">	socklen_t *_addressLength)</a>
<a name="ln1198">{</a>
<a name="ln1199">	// check parameters</a>
<a name="ln1200">	socklen_t addressLength = 0;</a>
<a name="ln1201">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln1202">	error = prepare_userland_address_result(userAddress, _addressLength,</a>
<a name="ln1203">		addressLength, true);</a>
<a name="ln1204">	if (error != B_OK)</a>
<a name="ln1205">		return error;</a>
<a name="ln1206"> </a>
<a name="ln1207">	// getsockname()</a>
<a name="ln1208">	char address[MAX_SOCKET_ADDRESS_LENGTH];</a>
<a name="ln1209">	socklen_t userAddressBufferSize = addressLength;</a>
<a name="ln1210">	error = common_getsockname(socket, (sockaddr*)address, &amp;addressLength,</a>
<a name="ln1211">		false);</a>
<a name="ln1212">	if (error != B_OK)</a>
<a name="ln1213">		return error;</a>
<a name="ln1214"> </a>
<a name="ln1215">	// copy address size and address back to userland</a>
<a name="ln1216">	if (copy_address_to_userland(address, addressLength, userAddress,</a>
<a name="ln1217">			userAddressBufferSize, _addressLength) != B_OK) {</a>
<a name="ln1218">		return B_BAD_ADDRESS;</a>
<a name="ln1219">	}</a>
<a name="ln1220"> </a>
<a name="ln1221">	return B_OK;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224"> </a>
<a name="ln1225">int</a>
<a name="ln1226">_user_sockatmark(int socket)</a>
<a name="ln1227">{</a>
<a name="ln1228">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln1229">	return error = common_sockatmark(socket, false);</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232"> </a>
<a name="ln1233">status_t</a>
<a name="ln1234">_user_socketpair(int family, int type, int protocol, int *userSocketVector)</a>
<a name="ln1235">{</a>
<a name="ln1236">	// check parameters</a>
<a name="ln1237">	if (userSocketVector == NULL)</a>
<a name="ln1238">		return B_BAD_VALUE;</a>
<a name="ln1239">	if (!IS_USER_ADDRESS(userSocketVector))</a>
<a name="ln1240">		return B_BAD_ADDRESS;</a>
<a name="ln1241"> </a>
<a name="ln1242">	// socketpair()</a>
<a name="ln1243">	int socketVector[2];</a>
<a name="ln1244">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln1245">	error = common_socketpair(family, type, protocol, socketVector, false);</a>
<a name="ln1246">	if (error != B_OK)</a>
<a name="ln1247">		return error;</a>
<a name="ln1248"> </a>
<a name="ln1249">	// copy FDs back to userland</a>
<a name="ln1250">	if (user_memcpy(userSocketVector, socketVector,</a>
<a name="ln1251">			sizeof(socketVector)) != B_OK) {</a>
<a name="ln1252">		_user_close(socketVector[0]);</a>
<a name="ln1253">		_user_close(socketVector[1]);</a>
<a name="ln1254">		return B_BAD_ADDRESS;</a>
<a name="ln1255">	}</a>
<a name="ln1256"> </a>
<a name="ln1257">	return B_OK;</a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260"> </a>
<a name="ln1261">status_t</a>
<a name="ln1262">_user_get_next_socket_stat(int family, uint32 *_cookie, struct net_stat *_stat)</a>
<a name="ln1263">{</a>
<a name="ln1264">	// check parameters and copy cookie from userland</a>
<a name="ln1265">	if (_cookie == NULL || _stat == NULL)</a>
<a name="ln1266">		return B_BAD_VALUE;</a>
<a name="ln1267"> </a>
<a name="ln1268">	uint32 cookie;</a>
<a name="ln1269">	if (!IS_USER_ADDRESS(_stat) || !IS_USER_ADDRESS(_cookie)</a>
<a name="ln1270">		|| user_memcpy(&amp;cookie, _cookie, sizeof(cookie)) != B_OK) {</a>
<a name="ln1271">		return B_BAD_ADDRESS;</a>
<a name="ln1272">	}</a>
<a name="ln1273"> </a>
<a name="ln1274">	net_stat stat;</a>
<a name="ln1275">	SyscallRestartWrapper&lt;status_t&gt; error;</a>
<a name="ln1276">	error = common_get_next_socket_stat(family, &amp;cookie, &amp;stat);</a>
<a name="ln1277">	if (error != B_OK)</a>
<a name="ln1278">		return error;</a>
<a name="ln1279"> </a>
<a name="ln1280">	// copy cookie and data back to userland</a>
<a name="ln1281">	if (user_memcpy(_cookie, &amp;cookie, sizeof(cookie)) != B_OK</a>
<a name="ln1282">		|| user_memcpy(_stat, &amp;stat, sizeof(net_stat)) != B_OK) {</a>
<a name="ln1283">		return B_BAD_ADDRESS;</a>
<a name="ln1284">	}</a>
<a name="ln1285"> </a>
<a name="ln1286">	return B_OK;</a>
<a name="ln1287">}</a>

</code></pre>
<div class="balloon" rel="983"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'message.msg_controllen < 0' is always false. Unsigned type value is never < 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
