
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_malo.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2008 Weongyo Jeong &lt;weongyo@freebsd.org&gt;</a>
<a name="ln5"> * Copyright (c) 2007 Marvell Semiconductor, Inc.</a>
<a name="ln6"> * Copyright (c) 2007 Sam Leffler, Errno Consulting</a>
<a name="ln7"> * All rights reserved.</a>
<a name="ln8"> *</a>
<a name="ln9"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln10"> * modification, are permitted provided that the following conditions</a>
<a name="ln11"> * are met:</a>
<a name="ln12"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer,</a>
<a name="ln14"> *    without modification.</a>
<a name="ln15"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</a>
<a name="ln16"> *    similar to the &quot;NO WARRANTY&quot; disclaimer below (&quot;Disclaimer&quot;) and any</a>
<a name="ln17"> *    redistribution must be conditioned upon including a substantially</a>
<a name="ln18"> *    similar Disclaimer requirement for further binary redistribution.</a>
<a name="ln19"> *</a>
<a name="ln20"> * NO WARRANTY</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln22"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln23"> * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY</a>
<a name="ln24"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</a>
<a name="ln25"> * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,</a>
<a name="ln26"> * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln27"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln28"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER</a>
<a name="ln29"> * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln30"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln31"> * THE POSSIBILITY OF SUCH DAMAGES.</a>
<a name="ln32"> */</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln35">#ifdef __FreeBSD__</a>
<a name="ln36">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/malo/if_malo.c 333813 2018-05-18 20:13:34Z mmacy $&quot;);</a>
<a name="ln37">#endif</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;opt_malo.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;sys/param.h&gt;</a>
<a name="ln42">#include &lt;sys/endian.h&gt;</a>
<a name="ln43">#include &lt;sys/kernel.h&gt;</a>
<a name="ln44">#include &lt;sys/malloc.h&gt;</a>
<a name="ln45">#include &lt;sys/socket.h&gt;</a>
<a name="ln46">#include &lt;sys/sockio.h&gt;</a>
<a name="ln47">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln48">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;machine/bus.h&gt;</a>
<a name="ln51">#include &lt;sys/bus.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">#include &lt;net/if.h&gt;</a>
<a name="ln54">#include &lt;net/if_var.h&gt;</a>
<a name="ln55">#include &lt;net/if_dl.h&gt;</a>
<a name="ln56">#include &lt;net/if_media.h&gt;</a>
<a name="ln57">#include &lt;net/if_types.h&gt;</a>
<a name="ln58">#include &lt;net/ethernet.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln61">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#include &lt;net/bpf.h&gt;</a>
<a name="ln64"> </a>
<a name="ln65">#include &lt;dev/malo/if_malo.h&gt;</a>
<a name="ln66"> </a>
<a name="ln67">SYSCTL_NODE(_hw, OID_AUTO, malo, CTLFLAG_RD, 0,</a>
<a name="ln68">    &quot;Marvell 88w8335 driver parameters&quot;);</a>
<a name="ln69"> </a>
<a name="ln70">static	int malo_txcoalesce = 8;	/* # tx pkts to q before poking f/w*/</a>
<a name="ln71">SYSCTL_INT(_hw_malo, OID_AUTO, txcoalesce, CTLFLAG_RWTUN, &amp;malo_txcoalesce,</a>
<a name="ln72">	    0, &quot;tx buffers to send at once&quot;);</a>
<a name="ln73">static	int malo_rxbuf = MALO_RXBUF;		/* # rx buffers to allocate */</a>
<a name="ln74">SYSCTL_INT(_hw_malo, OID_AUTO, rxbuf, CTLFLAG_RWTUN, &amp;malo_rxbuf,</a>
<a name="ln75">	    0, &quot;rx buffers allocated&quot;);</a>
<a name="ln76">static	int malo_rxquota = MALO_RXBUF;		/* # max buffers to process */</a>
<a name="ln77">SYSCTL_INT(_hw_malo, OID_AUTO, rxquota, CTLFLAG_RWTUN, &amp;malo_rxquota,</a>
<a name="ln78">	    0, &quot;max rx buffers to process per interrupt&quot;);</a>
<a name="ln79">static	int malo_txbuf = MALO_TXBUF;		/* # tx buffers to allocate */</a>
<a name="ln80">SYSCTL_INT(_hw_malo, OID_AUTO, txbuf, CTLFLAG_RWTUN, &amp;malo_txbuf,</a>
<a name="ln81">	    0, &quot;tx buffers allocated&quot;);</a>
<a name="ln82"> </a>
<a name="ln83">#ifdef MALO_DEBUG</a>
<a name="ln84">static	int malo_debug = 0;</a>
<a name="ln85">SYSCTL_INT(_hw_malo, OID_AUTO, debug, CTLFLAG_RWTUN, &amp;malo_debug,</a>
<a name="ln86">	    0, &quot;control debugging printfs&quot;);</a>
<a name="ln87">enum {</a>
<a name="ln88">	MALO_DEBUG_XMIT		= 0x00000001,	/* basic xmit operation */</a>
<a name="ln89">	MALO_DEBUG_XMIT_DESC	= 0x00000002,	/* xmit descriptors */</a>
<a name="ln90">	MALO_DEBUG_RECV		= 0x00000004,	/* basic recv operation */</a>
<a name="ln91">	MALO_DEBUG_RECV_DESC	= 0x00000008,	/* recv descriptors */</a>
<a name="ln92">	MALO_DEBUG_RESET	= 0x00000010,	/* reset processing */</a>
<a name="ln93">	MALO_DEBUG_INTR		= 0x00000040,	/* ISR */</a>
<a name="ln94">	MALO_DEBUG_TX_PROC	= 0x00000080,	/* tx ISR proc */</a>
<a name="ln95">	MALO_DEBUG_RX_PROC	= 0x00000100,	/* rx ISR proc */</a>
<a name="ln96">	MALO_DEBUG_STATE	= 0x00000400,	/* 802.11 state transitions */</a>
<a name="ln97">	MALO_DEBUG_NODE		= 0x00000800,	/* node management */</a>
<a name="ln98">	MALO_DEBUG_RECV_ALL	= 0x00001000,	/* trace all frames (beacons) */</a>
<a name="ln99">	MALO_DEBUG_FW		= 0x00008000,	/* firmware */</a>
<a name="ln100">	MALO_DEBUG_ANY		= 0xffffffff</a>
<a name="ln101">};</a>
<a name="ln102">#define	IS_BEACON(wh)							\</a>
<a name="ln103">	((wh-&gt;i_fc[0] &amp; (IEEE80211_FC0_TYPE_MASK |			\</a>
<a name="ln104">		IEEE80211_FC0_SUBTYPE_MASK)) ==				\</a>
<a name="ln105">	 (IEEE80211_FC0_TYPE_MGT|IEEE80211_FC0_SUBTYPE_BEACON))</a>
<a name="ln106">#define	IFF_DUMPPKTS_RECV(sc, wh)					\</a>
<a name="ln107">	(((sc-&gt;malo_debug &amp; MALO_DEBUG_RECV) &amp;&amp;				\</a>
<a name="ln108">	  ((sc-&gt;malo_debug &amp; MALO_DEBUG_RECV_ALL) || !IS_BEACON(wh))))</a>
<a name="ln109">#define	IFF_DUMPPKTS_XMIT(sc)						\</a>
<a name="ln110">	(sc-&gt;malo_debug &amp; MALO_DEBUG_XMIT)</a>
<a name="ln111">#define	DPRINTF(sc, m, fmt, ...) do {				\</a>
<a name="ln112">	if (sc-&gt;malo_debug &amp; (m))				\</a>
<a name="ln113">		printf(fmt, __VA_ARGS__);			\</a>
<a name="ln114">} while (0)</a>
<a name="ln115">#else</a>
<a name="ln116">#define	DPRINTF(sc, m, fmt, ...) do {				\</a>
<a name="ln117">	(void) sc;						\</a>
<a name="ln118">} while (0)</a>
<a name="ln119">#endif</a>
<a name="ln120"> </a>
<a name="ln121">static MALLOC_DEFINE(M_MALODEV, &quot;malodev&quot;, &quot;malo driver dma buffers&quot;);</a>
<a name="ln122"> </a>
<a name="ln123">static struct ieee80211vap *malo_vap_create(struct ieee80211com *,</a>
<a name="ln124">		    const char [IFNAMSIZ], int, enum ieee80211_opmode, int,</a>
<a name="ln125">		    const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln126">		    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln127">static  void	malo_vap_delete(struct ieee80211vap *);</a>
<a name="ln128">static	int	malo_dma_setup(struct malo_softc *);</a>
<a name="ln129">static	int	malo_setup_hwdma(struct malo_softc *);</a>
<a name="ln130">static	void	malo_txq_init(struct malo_softc *, struct malo_txq *, int);</a>
<a name="ln131">static	void	malo_tx_cleanupq(struct malo_softc *, struct malo_txq *);</a>
<a name="ln132">static	void	malo_parent(struct ieee80211com *);</a>
<a name="ln133">static	int	malo_transmit(struct ieee80211com *, struct mbuf *);</a>
<a name="ln134">static	void	malo_start(struct malo_softc *);</a>
<a name="ln135">static	void	malo_watchdog(void *);</a>
<a name="ln136">static	void	malo_updateslot(struct ieee80211com *);</a>
<a name="ln137">static	int	malo_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln138">static	void	malo_scan_start(struct ieee80211com *);</a>
<a name="ln139">static	void	malo_scan_end(struct ieee80211com *);</a>
<a name="ln140">static	void	malo_set_channel(struct ieee80211com *);</a>
<a name="ln141">static	int	malo_raw_xmit(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln142">		    const struct ieee80211_bpf_params *);</a>
<a name="ln143">static	void	malo_sysctlattach(struct malo_softc *);</a>
<a name="ln144">static	void	malo_announce(struct malo_softc *);</a>
<a name="ln145">static	void	malo_dma_cleanup(struct malo_softc *);</a>
<a name="ln146">static	void	malo_stop(struct malo_softc *);</a>
<a name="ln147">static	int	malo_chan_set(struct malo_softc *, struct ieee80211_channel *);</a>
<a name="ln148">static	int	malo_mode_init(struct malo_softc *);</a>
<a name="ln149">static	void	malo_tx_proc(void *, int);</a>
<a name="ln150">static	void	malo_rx_proc(void *, int);</a>
<a name="ln151">static	void	malo_init(void *);</a>
<a name="ln152"> </a>
<a name="ln153">/*</a>
<a name="ln154"> * Read/Write shorthands for accesses to BAR 0.  Note that all BAR 1</a>
<a name="ln155"> * operations are done in the &quot;hal&quot; except getting H/W MAC address at</a>
<a name="ln156"> * malo_attach and there should be no reference to them here.</a>
<a name="ln157"> */</a>
<a name="ln158">static uint32_t</a>
<a name="ln159">malo_bar0_read4(struct malo_softc *sc, bus_size_t off)</a>
<a name="ln160">{</a>
<a name="ln161">	return bus_space_read_4(sc-&gt;malo_io0t, sc-&gt;malo_io0h, off);</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">static void</a>
<a name="ln165">malo_bar0_write4(struct malo_softc *sc, bus_size_t off, uint32_t val)</a>
<a name="ln166">{</a>
<a name="ln167">	DPRINTF(sc, MALO_DEBUG_FW, &quot;%s: off 0x%jx val 0x%x\n&quot;,</a>
<a name="ln168">	    __func__, (uintmax_t)off, val);</a>
<a name="ln169"> </a>
<a name="ln170">	bus_space_write_4(sc-&gt;malo_io0t, sc-&gt;malo_io0h, off, val);</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">int</a>
<a name="ln174">malo_attach(uint16_t devid, struct malo_softc *sc)</a>
<a name="ln175">{</a>
<a name="ln176">	struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln177">	struct malo_hal *mh;</a>
<a name="ln178">	int error;</a>
<a name="ln179">	uint8_t bands[IEEE80211_MODE_BYTES];</a>
<a name="ln180"> </a>
<a name="ln181">	MALO_LOCK_INIT(sc);</a>
<a name="ln182">	callout_init_mtx(&amp;sc-&gt;malo_watchdog_timer, &amp;sc-&gt;malo_mtx, 0);</a>
<a name="ln183">	mbufq_init(&amp;sc-&gt;malo_snd, ifqmaxlen);</a>
<a name="ln184"> </a>
<a name="ln185">	mh = malo_hal_attach(sc-&gt;malo_dev, devid,</a>
<a name="ln186">	    sc-&gt;malo_io1h, sc-&gt;malo_io1t, sc-&gt;malo_dmat);</a>
<a name="ln187">	if (mh == NULL) {</a>
<a name="ln188">		device_printf(sc-&gt;malo_dev, &quot;unable to attach HAL\n&quot;);</a>
<a name="ln189">		error = EIO;</a>
<a name="ln190">		goto bad;</a>
<a name="ln191">	}</a>
<a name="ln192">	sc-&gt;malo_mh = mh;</a>
<a name="ln193"> </a>
<a name="ln194">	/*</a>
<a name="ln195">	 * Load firmware so we can get setup.  We arbitrarily pick station</a>
<a name="ln196">	 * firmware; we'll re-load firmware as needed so setting up</a>
<a name="ln197">	 * the wrong mode isn't a big deal.</a>
<a name="ln198">	 */</a>
<a name="ln199">	error = malo_hal_fwload(mh, &quot;malo8335-h&quot;, &quot;malo8335-m&quot;);</a>
<a name="ln200">	if (error != 0) {</a>
<a name="ln201">		device_printf(sc-&gt;malo_dev, &quot;unable to setup firmware\n&quot;);</a>
<a name="ln202">		goto bad1;</a>
<a name="ln203">	}</a>
<a name="ln204">	/* XXX gethwspecs() extracts correct informations?  not maybe!  */</a>
<a name="ln205">	error = malo_hal_gethwspecs(mh, &amp;sc-&gt;malo_hwspecs);</a>
<a name="ln206">	if (error != 0) {</a>
<a name="ln207">		device_printf(sc-&gt;malo_dev, &quot;unable to fetch h/w specs\n&quot;);</a>
<a name="ln208">		goto bad1;</a>
<a name="ln209">	}</a>
<a name="ln210"> </a>
<a name="ln211">	DPRINTF(sc, MALO_DEBUG_FW,</a>
<a name="ln212">	    &quot;malo_hal_gethwspecs: hwversion 0x%x hostif 0x%x&quot;</a>
<a name="ln213">	    &quot;maxnum_wcb 0x%x maxnum_mcaddr 0x%x maxnum_tx_wcb 0x%x&quot;</a>
<a name="ln214">	    &quot;regioncode 0x%x num_antenna 0x%x fw_releasenum 0x%x&quot;</a>
<a name="ln215">	    &quot;wcbbase0 0x%x rxdesc_read 0x%x rxdesc_write 0x%x&quot;</a>
<a name="ln216">	    &quot;ul_fw_awakecookie 0x%x w[4] = %x %x %x %x&quot;,</a>
<a name="ln217">	    sc-&gt;malo_hwspecs.hwversion,</a>
<a name="ln218">	    sc-&gt;malo_hwspecs.hostinterface, sc-&gt;malo_hwspecs.maxnum_wcb,</a>
<a name="ln219">	    sc-&gt;malo_hwspecs.maxnum_mcaddr, sc-&gt;malo_hwspecs.maxnum_tx_wcb,</a>
<a name="ln220">	    sc-&gt;malo_hwspecs.regioncode, sc-&gt;malo_hwspecs.num_antenna,</a>
<a name="ln221">	    sc-&gt;malo_hwspecs.fw_releasenum, sc-&gt;malo_hwspecs.wcbbase0,</a>
<a name="ln222">	    sc-&gt;malo_hwspecs.rxdesc_read, sc-&gt;malo_hwspecs.rxdesc_write,</a>
<a name="ln223">	    sc-&gt;malo_hwspecs.ul_fw_awakecookie,</a>
<a name="ln224">	    sc-&gt;malo_hwspecs.wcbbase[0], sc-&gt;malo_hwspecs.wcbbase[1],</a>
<a name="ln225">	    sc-&gt;malo_hwspecs.wcbbase[2], sc-&gt;malo_hwspecs.wcbbase[3]);</a>
<a name="ln226"> </a>
<a name="ln227">	/* NB: firmware looks that it does not export regdomain info API.  */</a>
<a name="ln228">	memset(bands, 0, sizeof(bands));</a>
<a name="ln229">	setbit(bands, IEEE80211_MODE_11B);</a>
<a name="ln230">	setbit(bands, IEEE80211_MODE_11G);</a>
<a name="ln231">	ieee80211_init_channels(ic, NULL, bands);</a>
<a name="ln232"> </a>
<a name="ln233">	sc-&gt;malo_txantenna = 0x2;	/* h/w default */</a>
<a name="ln234">	sc-&gt;malo_rxantenna = 0xffff;	/* h/w default */</a>
<a name="ln235"> </a>
<a name="ln236">	/*</a>
<a name="ln237">	 * Allocate tx + rx descriptors and populate the lists.</a>
<a name="ln238">	 * We immediately push the information to the firmware</a>
<a name="ln239">	 * as otherwise it gets upset.</a>
<a name="ln240">	 */</a>
<a name="ln241">	error = malo_dma_setup(sc);</a>
<a name="ln242">	if (error != 0) {</a>
<a name="ln243">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln244">		    &quot;failed to setup descriptors: %d\n&quot;, error);</a>
<a name="ln245">		goto bad1;</a>
<a name="ln246">	}</a>
<a name="ln247">	error = malo_setup_hwdma(sc);	/* push to firmware */</a>
<a name="ln248">	if (error != 0)			/* NB: malo_setupdma prints msg */</a>
<a name="ln249">		goto bad2;</a>
<a name="ln250"> </a>
<a name="ln251">	sc-&gt;malo_tq = taskqueue_create_fast(&quot;malo_taskq&quot;, M_NOWAIT,</a>
<a name="ln252">		taskqueue_thread_enqueue, &amp;sc-&gt;malo_tq);</a>
<a name="ln253">	taskqueue_start_threads(&amp;sc-&gt;malo_tq, 1, PI_NET,</a>
<a name="ln254">		&quot;%s taskq&quot;, device_get_nameunit(sc-&gt;malo_dev));</a>
<a name="ln255"> </a>
<a name="ln256">	TASK_INIT(&amp;sc-&gt;malo_rxtask, 0, malo_rx_proc, sc);</a>
<a name="ln257">	TASK_INIT(&amp;sc-&gt;malo_txtask, 0, malo_tx_proc, sc);</a>
<a name="ln258"> </a>
<a name="ln259">	ic-&gt;ic_softc = sc;</a>
<a name="ln260">	ic-&gt;ic_name = device_get_nameunit(sc-&gt;malo_dev);</a>
<a name="ln261">	/* XXX not right but it's not used anywhere important */</a>
<a name="ln262">	ic-&gt;ic_phytype = IEEE80211_T_OFDM;</a>
<a name="ln263">	ic-&gt;ic_opmode = IEEE80211_M_STA;</a>
<a name="ln264">	ic-&gt;ic_caps =</a>
<a name="ln265">	      IEEE80211_C_STA			/* station mode supported */</a>
<a name="ln266">	    | IEEE80211_C_BGSCAN		/* capable of bg scanning */</a>
<a name="ln267">	    | IEEE80211_C_MONITOR		/* monitor mode */</a>
<a name="ln268">	    | IEEE80211_C_SHPREAMBLE		/* short preamble supported */</a>
<a name="ln269">	    | IEEE80211_C_SHSLOT		/* short slot time supported */</a>
<a name="ln270">	    | IEEE80211_C_TXPMGT		/* capable of txpow mgt */</a>
<a name="ln271">	    | IEEE80211_C_WPA			/* capable of WPA1+WPA2 */</a>
<a name="ln272">	    ;</a>
<a name="ln273">	IEEE80211_ADDR_COPY(ic-&gt;ic_macaddr, sc-&gt;malo_hwspecs.macaddr);</a>
<a name="ln274"> </a>
<a name="ln275">	/*</a>
<a name="ln276">	 * Transmit requires space in the packet for a special format transmit</a>
<a name="ln277">	 * record and optional padding between this record and the payload.</a>
<a name="ln278">	 * Ask the net80211 layer to arrange this when encapsulating</a>
<a name="ln279">	 * packets so we can add it efficiently. </a>
<a name="ln280">	 */</a>
<a name="ln281">	ic-&gt;ic_headroom = sizeof(struct malo_txrec) -</a>
<a name="ln282">		sizeof(struct ieee80211_frame);</a>
<a name="ln283"> </a>
<a name="ln284">	/* call MI attach routine. */</a>
<a name="ln285">	ieee80211_ifattach(ic);</a>
<a name="ln286">	/* override default methods */</a>
<a name="ln287">	ic-&gt;ic_vap_create = malo_vap_create;</a>
<a name="ln288">	ic-&gt;ic_vap_delete = malo_vap_delete;</a>
<a name="ln289">	ic-&gt;ic_raw_xmit = malo_raw_xmit;</a>
<a name="ln290">	ic-&gt;ic_updateslot = malo_updateslot;</a>
<a name="ln291">	ic-&gt;ic_scan_start = malo_scan_start;</a>
<a name="ln292">	ic-&gt;ic_scan_end = malo_scan_end;</a>
<a name="ln293">	ic-&gt;ic_set_channel = malo_set_channel;</a>
<a name="ln294">	ic-&gt;ic_parent = malo_parent;</a>
<a name="ln295">	ic-&gt;ic_transmit = malo_transmit;</a>
<a name="ln296"> </a>
<a name="ln297">	sc-&gt;malo_invalid = 0;		/* ready to go, enable int handling */</a>
<a name="ln298"> </a>
<a name="ln299">	ieee80211_radiotap_attach(ic,</a>
<a name="ln300">	    &amp;sc-&gt;malo_tx_th.wt_ihdr, sizeof(sc-&gt;malo_tx_th),</a>
<a name="ln301">		MALO_TX_RADIOTAP_PRESENT,</a>
<a name="ln302">	    &amp;sc-&gt;malo_rx_th.wr_ihdr, sizeof(sc-&gt;malo_rx_th),</a>
<a name="ln303">		MALO_RX_RADIOTAP_PRESENT);</a>
<a name="ln304"> </a>
<a name="ln305">	/*</a>
<a name="ln306">	 * Setup dynamic sysctl's.</a>
<a name="ln307">	 */</a>
<a name="ln308">	malo_sysctlattach(sc);</a>
<a name="ln309"> </a>
<a name="ln310">	if (bootverbose)</a>
<a name="ln311">		ieee80211_announce(ic);</a>
<a name="ln312">	malo_announce(sc);</a>
<a name="ln313"> </a>
<a name="ln314">	return 0;</a>
<a name="ln315">bad2:</a>
<a name="ln316">	malo_dma_cleanup(sc);</a>
<a name="ln317">bad1:</a>
<a name="ln318">	malo_hal_detach(mh);</a>
<a name="ln319">bad:</a>
<a name="ln320">	sc-&gt;malo_invalid = 1;</a>
<a name="ln321"> </a>
<a name="ln322">	return error;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">static struct ieee80211vap *</a>
<a name="ln326">malo_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln327">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln328">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln329">    const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln330">{</a>
<a name="ln331">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln332">	struct malo_vap *mvp;</a>
<a name="ln333">	struct ieee80211vap *vap;</a>
<a name="ln334"> </a>
<a name="ln335">	if (!TAILQ_EMPTY(&amp;ic-&gt;ic_vaps)) {</a>
<a name="ln336">		device_printf(sc-&gt;malo_dev, &quot;multiple vaps not supported\n&quot;);</a>
<a name="ln337">		return NULL;</a>
<a name="ln338">	}</a>
<a name="ln339">	switch (opmode) {</a>
<a name="ln340">	case IEEE80211_M_STA:</a>
<a name="ln341">		if (opmode == IEEE80211_M_STA)</a>
<a name="ln342">			flags |= IEEE80211_CLONE_NOBEACONS;</a>
<a name="ln343">		/* fall thru... */</a>
<a name="ln344">	case IEEE80211_M_MONITOR:</a>
<a name="ln345">		break;</a>
<a name="ln346">	default:</a>
<a name="ln347">		device_printf(sc-&gt;malo_dev, &quot;%s mode not supported\n&quot;,</a>
<a name="ln348">		    ieee80211_opmode_name[opmode]);</a>
<a name="ln349">		return NULL;		/* unsupported */</a>
<a name="ln350">	}</a>
<a name="ln351">	mvp = malloc(sizeof(struct malo_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln352">	vap = &amp;mvp-&gt;malo_vap;</a>
<a name="ln353">	ieee80211_vap_setup(ic, vap, name, unit, opmode, flags, bssid);</a>
<a name="ln354"> </a>
<a name="ln355">	/* override state transition machine */</a>
<a name="ln356">	mvp-&gt;malo_newstate = vap-&gt;iv_newstate;</a>
<a name="ln357">	vap-&gt;iv_newstate = malo_newstate;</a>
<a name="ln358"> </a>
<a name="ln359">	/* complete setup */</a>
<a name="ln360">	ieee80211_vap_attach(vap,</a>
<a name="ln361">	    ieee80211_media_change, ieee80211_media_status, mac);</a>
<a name="ln362">	ic-&gt;ic_opmode = opmode;</a>
<a name="ln363">	return vap;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">static void</a>
<a name="ln367">malo_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln368">{</a>
<a name="ln369">	struct malo_vap *mvp = MALO_VAP(vap);</a>
<a name="ln370"> </a>
<a name="ln371">	ieee80211_vap_detach(vap);</a>
<a name="ln372">	free(mvp, M_80211_VAP);</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">int</a>
<a name="ln376">malo_intr(void *arg)</a>
<a name="ln377">{</a>
<a name="ln378">	struct malo_softc *sc = arg;</a>
<a name="ln379">	struct malo_hal *mh = sc-&gt;malo_mh;</a>
<a name="ln380">	uint32_t status;</a>
<a name="ln381"> </a>
<a name="ln382">	if (sc-&gt;malo_invalid) {</a>
<a name="ln383">		/*</a>
<a name="ln384">		 * The hardware is not ready/present, don't touch anything.</a>
<a name="ln385">		 * Note this can happen early on if the IRQ is shared.</a>
<a name="ln386">		 */</a>
<a name="ln387">		DPRINTF(sc, MALO_DEBUG_ANY, &quot;%s: invalid; ignored\n&quot;, __func__);</a>
<a name="ln388">		return (FILTER_STRAY);</a>
<a name="ln389">	}</a>
<a name="ln390"> </a>
<a name="ln391">	/*</a>
<a name="ln392">	 * Figure out the reason(s) for the interrupt.</a>
<a name="ln393">	 */</a>
<a name="ln394">	malo_hal_getisr(mh, &amp;status);		/* NB: clears ISR too */</a>
<a name="ln395">	if (status == 0)			/* must be a shared irq */</a>
<a name="ln396">		return (FILTER_STRAY);</a>
<a name="ln397"> </a>
<a name="ln398">	DPRINTF(sc, MALO_DEBUG_INTR, &quot;%s: status 0x%x imask 0x%x\n&quot;,</a>
<a name="ln399">	    __func__, status, sc-&gt;malo_imask);</a>
<a name="ln400"> </a>
<a name="ln401">	if (status &amp; MALO_A2HRIC_BIT_RX_RDY)</a>
<a name="ln402">		taskqueue_enqueue(sc-&gt;malo_tq, &amp;sc-&gt;malo_rxtask);</a>
<a name="ln403">	if (status &amp; MALO_A2HRIC_BIT_TX_DONE)</a>
<a name="ln404">		taskqueue_enqueue(sc-&gt;malo_tq, &amp;sc-&gt;malo_txtask);</a>
<a name="ln405">	if (status &amp; MALO_A2HRIC_BIT_OPC_DONE)</a>
<a name="ln406">		malo_hal_cmddone(mh);</a>
<a name="ln407">	if (status &amp; MALO_A2HRIC_BIT_MAC_EVENT)</a>
<a name="ln408">		;</a>
<a name="ln409">	if (status &amp; MALO_A2HRIC_BIT_RX_PROBLEM)</a>
<a name="ln410">		;</a>
<a name="ln411">	if (status &amp; MALO_A2HRIC_BIT_ICV_ERROR) {</a>
<a name="ln412">		/* TKIP ICV error */</a>
<a name="ln413">		sc-&gt;malo_stats.mst_rx_badtkipicv++;</a>
<a name="ln414">	}</a>
<a name="ln415">#ifdef MALO_DEBUG</a>
<a name="ln416">	if (((status | sc-&gt;malo_imask) ^ sc-&gt;malo_imask) != 0)</a>
<a name="ln417">		DPRINTF(sc, MALO_DEBUG_INTR,</a>
<a name="ln418">		    &quot;%s: can't handle interrupt status 0x%x\n&quot;,</a>
<a name="ln419">		    __func__, status);</a>
<a name="ln420">#endif</a>
<a name="ln421">	return (FILTER_HANDLED);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">static void</a>
<a name="ln425">malo_load_cb(void *arg, bus_dma_segment_t *segs, int nsegs, int error)</a>
<a name="ln426">{</a>
<a name="ln427">	bus_addr_t *paddr = (bus_addr_t*) arg;</a>
<a name="ln428"> </a>
<a name="ln429">	KASSERT(error == 0, (&quot;error %u on bus_dma callback&quot;, error));</a>
<a name="ln430"> </a>
<a name="ln431">	*paddr = segs-&gt;ds_addr;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">static int</a>
<a name="ln435">malo_desc_setup(struct malo_softc *sc, const char *name,</a>
<a name="ln436">    struct malo_descdma *dd,</a>
<a name="ln437">    int nbuf, size_t bufsize, int ndesc, size_t descsize)</a>
<a name="ln438">{</a>
<a name="ln439">	int error;</a>
<a name="ln440">	uint8_t *ds;</a>
<a name="ln441"> </a>
<a name="ln442">	DPRINTF(sc, MALO_DEBUG_RESET,</a>
<a name="ln443">	    &quot;%s: %s DMA: %u bufs (%ju) %u desc/buf (%ju)\n&quot;,</a>
<a name="ln444">	    __func__, name, nbuf, (uintmax_t) bufsize,</a>
<a name="ln445">	    ndesc, (uintmax_t) descsize);</a>
<a name="ln446">	</a>
<a name="ln447">	dd-&gt;dd_name = name;</a>
<a name="ln448">	dd-&gt;dd_desc_len = nbuf * ndesc * descsize;</a>
<a name="ln449"> </a>
<a name="ln450">	/*</a>
<a name="ln451">	 * Setup DMA descriptor area.</a>
<a name="ln452">	 */</a>
<a name="ln453">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;malo_dev),/* parent */</a>
<a name="ln454">		       PAGE_SIZE, 0,		/* alignment, bounds */</a>
<a name="ln455">		       BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln456">		       BUS_SPACE_MAXADDR,	/* highaddr */</a>
<a name="ln457">		       NULL, NULL,		/* filter, filterarg */</a>
<a name="ln458">		       dd-&gt;dd_desc_len,		/* maxsize */</a>
<a name="ln459">		       1,			/* nsegments */</a>
<a name="ln460">		       dd-&gt;dd_desc_len,		/* maxsegsize */</a>
<a name="ln461">		       BUS_DMA_ALLOCNOW,	/* flags */</a>
<a name="ln462">		       NULL,			/* lockfunc */</a>
<a name="ln463">		       NULL,			/* lockarg */</a>
<a name="ln464">		       &amp;dd-&gt;dd_dmat);</a>
<a name="ln465">	if (error != 0) {</a>
<a name="ln466">		device_printf(sc-&gt;malo_dev, &quot;cannot allocate %s DMA tag\n&quot;,</a>
<a name="ln467">		    dd-&gt;dd_name);</a>
<a name="ln468">		return error;</a>
<a name="ln469">	}</a>
<a name="ln470">	</a>
<a name="ln471">	/* allocate descriptors */</a>
<a name="ln472">	error = bus_dmamem_alloc(dd-&gt;dd_dmat, (void**) &amp;dd-&gt;dd_desc,</a>
<a name="ln473">	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT, &amp;dd-&gt;dd_dmamap);</a>
<a name="ln474">	if (error != 0) {</a>
<a name="ln475">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln476">		    &quot;unable to alloc memory for %u %s descriptors, &quot;</a>
<a name="ln477">		    &quot;error %u\n&quot;, nbuf * ndesc, dd-&gt;dd_name, error);</a>
<a name="ln478">		goto fail1;</a>
<a name="ln479">	}</a>
<a name="ln480"> </a>
<a name="ln481">	error = bus_dmamap_load(dd-&gt;dd_dmat, dd-&gt;dd_dmamap,</a>
<a name="ln482">	    dd-&gt;dd_desc, dd-&gt;dd_desc_len,</a>
<a name="ln483">	    malo_load_cb, &amp;dd-&gt;dd_desc_paddr, BUS_DMA_NOWAIT);</a>
<a name="ln484">	if (error != 0) {</a>
<a name="ln485">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln486">		    &quot;unable to map %s descriptors, error %u\n&quot;,</a>
<a name="ln487">		    dd-&gt;dd_name, error);</a>
<a name="ln488">		goto fail2;</a>
<a name="ln489">	}</a>
<a name="ln490">	</a>
<a name="ln491">	ds = dd-&gt;dd_desc;</a>
<a name="ln492">	memset(ds, 0, dd-&gt;dd_desc_len);</a>
<a name="ln493">	DPRINTF(sc, MALO_DEBUG_RESET,</a>
<a name="ln494">	    &quot;%s: %s DMA map: %p (%lu) -&gt; 0x%jx (%lu)\n&quot;,</a>
<a name="ln495">	    __func__, dd-&gt;dd_name, ds, (u_long) dd-&gt;dd_desc_len,</a>
<a name="ln496">	    (uintmax_t) dd-&gt;dd_desc_paddr, /*XXX*/ (u_long) dd-&gt;dd_desc_len);</a>
<a name="ln497"> </a>
<a name="ln498">	return 0;</a>
<a name="ln499">fail2:</a>
<a name="ln500">	bus_dmamem_free(dd-&gt;dd_dmat, dd-&gt;dd_desc, dd-&gt;dd_dmamap);</a>
<a name="ln501">fail1:</a>
<a name="ln502">	bus_dma_tag_destroy(dd-&gt;dd_dmat);</a>
<a name="ln503">	memset(dd, 0, sizeof(*dd));</a>
<a name="ln504">	return error;</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">#define	DS2PHYS(_dd, _ds) \</a>
<a name="ln508">	((_dd)-&gt;dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)-&gt;dd_desc))</a>
<a name="ln509"> </a>
<a name="ln510">static int</a>
<a name="ln511">malo_rxdma_setup(struct malo_softc *sc)</a>
<a name="ln512">{</a>
<a name="ln513">	int error, bsize, i;</a>
<a name="ln514">	struct malo_rxbuf *bf;</a>
<a name="ln515">	struct malo_rxdesc *ds;</a>
<a name="ln516"> </a>
<a name="ln517">	error = malo_desc_setup(sc, &quot;rx&quot;, &amp;sc-&gt;malo_rxdma,</a>
<a name="ln518">	    malo_rxbuf, sizeof(struct malo_rxbuf),</a>
<a name="ln519">	    1, sizeof(struct malo_rxdesc));</a>
<a name="ln520">	if (error != 0)</a>
<a name="ln521">		return error;</a>
<a name="ln522"> </a>
<a name="ln523">	/*</a>
<a name="ln524">	 * Allocate rx buffers and set them up.</a>
<a name="ln525">	 */</a>
<a name="ln526">	bsize = malo_rxbuf * sizeof(struct malo_rxbuf);</a>
<a name="ln527">	bf = malloc(bsize, M_MALODEV, M_NOWAIT | M_ZERO);</a>
<a name="ln528">	if (bf == NULL) {</a>
<a name="ln529">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln530">		    &quot;malloc of %u rx buffers failed\n&quot;, bsize);</a>
<a name="ln531">		return error;</a>
<a name="ln532">	}</a>
<a name="ln533">	sc-&gt;malo_rxdma.dd_bufptr = bf;</a>
<a name="ln534">	</a>
<a name="ln535">	STAILQ_INIT(&amp;sc-&gt;malo_rxbuf);</a>
<a name="ln536">	ds = sc-&gt;malo_rxdma.dd_desc;</a>
<a name="ln537">	for (i = 0; i &lt; malo_rxbuf; i++, bf++, ds++) {</a>
<a name="ln538">		bf-&gt;bf_desc = ds;</a>
<a name="ln539">		bf-&gt;bf_daddr = DS2PHYS(&amp;sc-&gt;malo_rxdma, ds);</a>
<a name="ln540">		error = bus_dmamap_create(sc-&gt;malo_dmat, BUS_DMA_NOWAIT,</a>
<a name="ln541">		    &amp;bf-&gt;bf_dmamap);</a>
<a name="ln542">		if (error != 0) {</a>
<a name="ln543">			device_printf(sc-&gt;malo_dev,</a>
<a name="ln544">			    &quot;%s: unable to dmamap for rx buffer, error %d\n&quot;,</a>
<a name="ln545">			    __func__, error);</a>
<a name="ln546">			return error;</a>
<a name="ln547">		}</a>
<a name="ln548">		/* NB: tail is intentional to preserve descriptor order */</a>
<a name="ln549">		STAILQ_INSERT_TAIL(&amp;sc-&gt;malo_rxbuf, bf, bf_list);</a>
<a name="ln550">	}</a>
<a name="ln551">	return 0;</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">static int</a>
<a name="ln555">malo_txdma_setup(struct malo_softc *sc, struct malo_txq *txq)</a>
<a name="ln556">{</a>
<a name="ln557">	int error, bsize, i;</a>
<a name="ln558">	struct malo_txbuf *bf;</a>
<a name="ln559">	struct malo_txdesc *ds;</a>
<a name="ln560"> </a>
<a name="ln561">	error = malo_desc_setup(sc, &quot;tx&quot;, &amp;txq-&gt;dma,</a>
<a name="ln562">	    malo_txbuf, sizeof(struct malo_txbuf),</a>
<a name="ln563">	    MALO_TXDESC, sizeof(struct malo_txdesc));</a>
<a name="ln564">	if (error != 0)</a>
<a name="ln565">		return error;</a>
<a name="ln566">	</a>
<a name="ln567">	/* allocate and setup tx buffers */</a>
<a name="ln568">	bsize = malo_txbuf * sizeof(struct malo_txbuf);</a>
<a name="ln569">	bf = malloc(bsize, M_MALODEV, M_NOWAIT | M_ZERO);</a>
<a name="ln570">	if (bf == NULL) {</a>
<a name="ln571">		device_printf(sc-&gt;malo_dev, &quot;malloc of %u tx buffers failed\n&quot;,</a>
<a name="ln572">		    malo_txbuf);</a>
<a name="ln573">		return ENOMEM;</a>
<a name="ln574">	}</a>
<a name="ln575">	txq-&gt;dma.dd_bufptr = bf;</a>
<a name="ln576">	</a>
<a name="ln577">	STAILQ_INIT(&amp;txq-&gt;free);</a>
<a name="ln578">	txq-&gt;nfree = 0;</a>
<a name="ln579">	ds = txq-&gt;dma.dd_desc;</a>
<a name="ln580">	for (i = 0; i &lt; malo_txbuf; i++, bf++, ds += MALO_TXDESC) {</a>
<a name="ln581">		bf-&gt;bf_desc = ds;</a>
<a name="ln582">		bf-&gt;bf_daddr = DS2PHYS(&amp;txq-&gt;dma, ds);</a>
<a name="ln583">		error = bus_dmamap_create(sc-&gt;malo_dmat, BUS_DMA_NOWAIT,</a>
<a name="ln584">		    &amp;bf-&gt;bf_dmamap);</a>
<a name="ln585">		if (error != 0) {</a>
<a name="ln586">			device_printf(sc-&gt;malo_dev,</a>
<a name="ln587">			    &quot;unable to create dmamap for tx &quot;</a>
<a name="ln588">			    &quot;buffer %u, error %u\n&quot;, i, error);</a>
<a name="ln589">			return error;</a>
<a name="ln590">		}</a>
<a name="ln591">		STAILQ_INSERT_TAIL(&amp;txq-&gt;free, bf, bf_list);</a>
<a name="ln592">		txq-&gt;nfree++;</a>
<a name="ln593">	}</a>
<a name="ln594"> </a>
<a name="ln595">	return 0;</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">static void</a>
<a name="ln599">malo_desc_cleanup(struct malo_softc *sc, struct malo_descdma *dd)</a>
<a name="ln600">{</a>
<a name="ln601">	bus_dmamap_unload(dd-&gt;dd_dmat, dd-&gt;dd_dmamap);</a>
<a name="ln602">	bus_dmamem_free(dd-&gt;dd_dmat, dd-&gt;dd_desc, dd-&gt;dd_dmamap);</a>
<a name="ln603">	bus_dma_tag_destroy(dd-&gt;dd_dmat);</a>
<a name="ln604"> </a>
<a name="ln605">	memset(dd, 0, sizeof(*dd));</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">static void</a>
<a name="ln609">malo_rxdma_cleanup(struct malo_softc *sc)</a>
<a name="ln610">{</a>
<a name="ln611">	struct malo_rxbuf *bf;</a>
<a name="ln612"> </a>
<a name="ln613">	STAILQ_FOREACH(bf, &amp;sc-&gt;malo_rxbuf, bf_list) {</a>
<a name="ln614">		if (bf-&gt;bf_m != NULL) {</a>
<a name="ln615">			m_freem(bf-&gt;bf_m);</a>
<a name="ln616">			bf-&gt;bf_m = NULL;</a>
<a name="ln617">		}</a>
<a name="ln618">		if (bf-&gt;bf_dmamap != NULL) {</a>
<a name="ln619">			bus_dmamap_destroy(sc-&gt;malo_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln620">			bf-&gt;bf_dmamap = NULL;</a>
<a name="ln621">		}</a>
<a name="ln622">	}</a>
<a name="ln623">	STAILQ_INIT(&amp;sc-&gt;malo_rxbuf);</a>
<a name="ln624">	if (sc-&gt;malo_rxdma.dd_bufptr != NULL) {</a>
<a name="ln625">		free(sc-&gt;malo_rxdma.dd_bufptr, M_MALODEV);</a>
<a name="ln626">		sc-&gt;malo_rxdma.dd_bufptr = NULL;</a>
<a name="ln627">	}</a>
<a name="ln628">	if (sc-&gt;malo_rxdma.dd_desc_len != 0)</a>
<a name="ln629">		malo_desc_cleanup(sc, &amp;sc-&gt;malo_rxdma);</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">static void</a>
<a name="ln633">malo_txdma_cleanup(struct malo_softc *sc, struct malo_txq *txq)</a>
<a name="ln634">{</a>
<a name="ln635">	struct malo_txbuf *bf;</a>
<a name="ln636">	struct ieee80211_node *ni;</a>
<a name="ln637"> </a>
<a name="ln638">	STAILQ_FOREACH(bf, &amp;txq-&gt;free, bf_list) {</a>
<a name="ln639">		if (bf-&gt;bf_m != NULL) {</a>
<a name="ln640">			m_freem(bf-&gt;bf_m);</a>
<a name="ln641">			bf-&gt;bf_m = NULL;</a>
<a name="ln642">		}</a>
<a name="ln643">		ni = bf-&gt;bf_node;</a>
<a name="ln644">		bf-&gt;bf_node = NULL;</a>
<a name="ln645">		if (ni != NULL) {</a>
<a name="ln646">			/*</a>
<a name="ln647">			 * Reclaim node reference.</a>
<a name="ln648">			 */</a>
<a name="ln649">			ieee80211_free_node(ni);</a>
<a name="ln650">		}</a>
<a name="ln651">		if (bf-&gt;bf_dmamap != NULL) {</a>
<a name="ln652">			bus_dmamap_destroy(sc-&gt;malo_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln653">			bf-&gt;bf_dmamap = NULL;</a>
<a name="ln654">		}</a>
<a name="ln655">	}</a>
<a name="ln656">	STAILQ_INIT(&amp;txq-&gt;free);</a>
<a name="ln657">	txq-&gt;nfree = 0;</a>
<a name="ln658">	if (txq-&gt;dma.dd_bufptr != NULL) {</a>
<a name="ln659">		free(txq-&gt;dma.dd_bufptr, M_MALODEV);</a>
<a name="ln660">		txq-&gt;dma.dd_bufptr = NULL;</a>
<a name="ln661">	}</a>
<a name="ln662">	if (txq-&gt;dma.dd_desc_len != 0)</a>
<a name="ln663">		malo_desc_cleanup(sc, &amp;txq-&gt;dma);</a>
<a name="ln664">}</a>
<a name="ln665"> </a>
<a name="ln666">static void</a>
<a name="ln667">malo_dma_cleanup(struct malo_softc *sc)</a>
<a name="ln668">{</a>
<a name="ln669">	int i;</a>
<a name="ln670"> </a>
<a name="ln671">	for (i = 0; i &lt; MALO_NUM_TX_QUEUES; i++)</a>
<a name="ln672">		malo_txdma_cleanup(sc, &amp;sc-&gt;malo_txq[i]);</a>
<a name="ln673"> </a>
<a name="ln674">	malo_rxdma_cleanup(sc);</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">static int</a>
<a name="ln678">malo_dma_setup(struct malo_softc *sc)</a>
<a name="ln679">{</a>
<a name="ln680">	int error, i;</a>
<a name="ln681"> </a>
<a name="ln682">	/* rxdma initializing.  */</a>
<a name="ln683">	error = malo_rxdma_setup(sc);</a>
<a name="ln684">	if (error != 0)</a>
<a name="ln685">		return error;</a>
<a name="ln686"> </a>
<a name="ln687">	/* NB: we just have 1 tx queue now.  */</a>
<a name="ln688">	for (i = 0; i &lt; MALO_NUM_TX_QUEUES; i++) {</a>
<a name="ln689">		error = malo_txdma_setup(sc, &amp;sc-&gt;malo_txq[i]);</a>
<a name="ln690">		if (error != 0) {</a>
<a name="ln691">			malo_dma_cleanup(sc);</a>
<a name="ln692"> </a>
<a name="ln693">			return error;</a>
<a name="ln694">		}</a>
<a name="ln695"> </a>
<a name="ln696">		malo_txq_init(sc, &amp;sc-&gt;malo_txq[i], i);</a>
<a name="ln697">	}</a>
<a name="ln698"> </a>
<a name="ln699">	return 0;</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">static void</a>
<a name="ln703">malo_hal_set_rxtxdma(struct malo_softc *sc)</a>
<a name="ln704">{</a>
<a name="ln705">	int i;</a>
<a name="ln706"> </a>
<a name="ln707">	malo_bar0_write4(sc, sc-&gt;malo_hwspecs.rxdesc_read,</a>
<a name="ln708">	    sc-&gt;malo_hwdma.rxdesc_read);</a>
<a name="ln709">	malo_bar0_write4(sc, sc-&gt;malo_hwspecs.rxdesc_write,</a>
<a name="ln710">	    sc-&gt;malo_hwdma.rxdesc_read);</a>
<a name="ln711"> </a>
<a name="ln712">	for (i = 0; i &lt; MALO_NUM_TX_QUEUES; i++) {</a>
<a name="ln713">		malo_bar0_write4(sc,</a>
<a name="ln714">		    sc-&gt;malo_hwspecs.wcbbase[i], sc-&gt;malo_hwdma.wcbbase[i]);</a>
<a name="ln715">	}</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">/*</a>
<a name="ln719"> * Inform firmware of our tx/rx dma setup.  The BAR 0 writes below are</a>
<a name="ln720"> * for compatibility with older firmware.  For current firmware we send</a>
<a name="ln721"> * this information with a cmd block via malo_hal_sethwdma.</a>
<a name="ln722"> */</a>
<a name="ln723">static int</a>
<a name="ln724">malo_setup_hwdma(struct malo_softc *sc)</a>
<a name="ln725">{</a>
<a name="ln726">	int i;</a>
<a name="ln727">	struct malo_txq *txq;</a>
<a name="ln728"> </a>
<a name="ln729">	sc-&gt;malo_hwdma.rxdesc_read = sc-&gt;malo_rxdma.dd_desc_paddr;</a>
<a name="ln730"> </a>
<a name="ln731">	for (i = 0; i &lt; MALO_NUM_TX_QUEUES; i++) {</a>
<a name="ln732">		txq = &amp;sc-&gt;malo_txq[i];</a>
<a name="ln733">		sc-&gt;malo_hwdma.wcbbase[i] = txq-&gt;dma.dd_desc_paddr;</a>
<a name="ln734">	}</a>
<a name="ln735">	sc-&gt;malo_hwdma.maxnum_txwcb = malo_txbuf;</a>
<a name="ln736">	sc-&gt;malo_hwdma.maxnum_wcb = MALO_NUM_TX_QUEUES;</a>
<a name="ln737"> </a>
<a name="ln738">	malo_hal_set_rxtxdma(sc);</a>
<a name="ln739"> </a>
<a name="ln740">	return 0;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">static void</a>
<a name="ln744">malo_txq_init(struct malo_softc *sc, struct malo_txq *txq, int qnum)</a>
<a name="ln745">{</a>
<a name="ln746">	struct malo_txbuf *bf, *bn;</a>
<a name="ln747">	struct malo_txdesc *ds;</a>
<a name="ln748"> </a>
<a name="ln749">	MALO_TXQ_LOCK_INIT(sc, txq);</a>
<a name="ln750">	txq-&gt;qnum = qnum;</a>
<a name="ln751">	txq-&gt;txpri = 0;	/* XXX */</a>
<a name="ln752"> </a>
<a name="ln753">	STAILQ_FOREACH(bf, &amp;txq-&gt;free, bf_list) {</a>
<a name="ln754">		bf-&gt;bf_txq = txq;</a>
<a name="ln755"> </a>
<a name="ln756">		ds = bf-&gt;bf_desc;</a>
<a name="ln757">		bn = STAILQ_NEXT(bf, bf_list);</a>
<a name="ln758">		if (bn == NULL)</a>
<a name="ln759">			bn = STAILQ_FIRST(&amp;txq-&gt;free);</a>
<a name="ln760">		ds-&gt;physnext = htole32(bn-&gt;bf_daddr);</a>
<a name="ln761">	}</a>
<a name="ln762">	STAILQ_INIT(&amp;txq-&gt;active);</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">/*</a>
<a name="ln766"> * Reclaim resources for a setup queue.</a>
<a name="ln767"> */</a>
<a name="ln768">static void</a>
<a name="ln769">malo_tx_cleanupq(struct malo_softc *sc, struct malo_txq *txq)</a>
<a name="ln770">{</a>
<a name="ln771">	/* XXX hal work? */</a>
<a name="ln772">	MALO_TXQ_LOCK_DESTROY(txq);</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">/*</a>
<a name="ln776"> * Allocate a tx buffer for sending a frame.</a>
<a name="ln777"> */</a>
<a name="ln778">static struct malo_txbuf *</a>
<a name="ln779">malo_getbuf(struct malo_softc *sc, struct malo_txq *txq)</a>
<a name="ln780">{</a>
<a name="ln781">	struct malo_txbuf *bf;</a>
<a name="ln782"> </a>
<a name="ln783">	MALO_TXQ_LOCK(txq);</a>
<a name="ln784">	bf = STAILQ_FIRST(&amp;txq-&gt;free);</a>
<a name="ln785">	if (bf != NULL) {</a>
<a name="ln786">		STAILQ_REMOVE_HEAD(&amp;txq-&gt;free, bf_list);</a>
<a name="ln787">		txq-&gt;nfree--;</a>
<a name="ln788">	}</a>
<a name="ln789">	MALO_TXQ_UNLOCK(txq);</a>
<a name="ln790">	if (bf == NULL) {</a>
<a name="ln791">		DPRINTF(sc, MALO_DEBUG_XMIT,</a>
<a name="ln792">		    &quot;%s: out of xmit buffers on q %d\n&quot;, __func__, txq-&gt;qnum);</a>
<a name="ln793">		sc-&gt;malo_stats.mst_tx_qstop++;</a>
<a name="ln794">	}</a>
<a name="ln795">	return bf;</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">static int</a>
<a name="ln799">malo_tx_dmasetup(struct malo_softc *sc, struct malo_txbuf *bf, struct mbuf *m0)</a>
<a name="ln800">{</a>
<a name="ln801">	struct mbuf *m;</a>
<a name="ln802">	int error;</a>
<a name="ln803"> </a>
<a name="ln804">	/*</a>
<a name="ln805">	 * Load the DMA map so any coalescing is done.  This also calculates</a>
<a name="ln806">	 * the number of descriptors we need.</a>
<a name="ln807">	 */</a>
<a name="ln808">	error = bus_dmamap_load_mbuf_sg(sc-&gt;malo_dmat, bf-&gt;bf_dmamap, m0,</a>
<a name="ln809">				     bf-&gt;bf_segs, &amp;bf-&gt;bf_nseg,</a>
<a name="ln810">				     BUS_DMA_NOWAIT);</a>
<a name="ln811">	if (error == EFBIG) {</a>
<a name="ln812">		/* XXX packet requires too many descriptors */</a>
<a name="ln813">		bf-&gt;bf_nseg = MALO_TXDESC + 1;</a>
<a name="ln814">	} else if (error != 0) {</a>
<a name="ln815">		sc-&gt;malo_stats.mst_tx_busdma++;</a>
<a name="ln816">		m_freem(m0);</a>
<a name="ln817">		return error;</a>
<a name="ln818">	}</a>
<a name="ln819">	/*</a>
<a name="ln820">	 * Discard null packets and check for packets that require too many</a>
<a name="ln821">	 * TX descriptors.  We try to convert the latter to a cluster.</a>
<a name="ln822">	 */</a>
<a name="ln823">	if (error == EFBIG) {		/* too many desc's, linearize */</a>
<a name="ln824">		sc-&gt;malo_stats.mst_tx_linear++;</a>
<a name="ln825">		m = m_defrag(m0, M_NOWAIT);</a>
<a name="ln826">		if (m == NULL) {</a>
<a name="ln827">			m_freem(m0);</a>
<a name="ln828">			sc-&gt;malo_stats.mst_tx_nombuf++;</a>
<a name="ln829">			return ENOMEM;</a>
<a name="ln830">		}</a>
<a name="ln831">		m0 = m;</a>
<a name="ln832">		error = bus_dmamap_load_mbuf_sg(sc-&gt;malo_dmat, bf-&gt;bf_dmamap, m0,</a>
<a name="ln833">					     bf-&gt;bf_segs, &amp;bf-&gt;bf_nseg,</a>
<a name="ln834">					     BUS_DMA_NOWAIT);</a>
<a name="ln835">		if (error != 0) {</a>
<a name="ln836">			sc-&gt;malo_stats.mst_tx_busdma++;</a>
<a name="ln837">			m_freem(m0);</a>
<a name="ln838">			return error;</a>
<a name="ln839">		}</a>
<a name="ln840">		KASSERT(bf-&gt;bf_nseg &lt;= MALO_TXDESC,</a>
<a name="ln841">		    (&quot;too many segments after defrag; nseg %u&quot;, bf-&gt;bf_nseg));</a>
<a name="ln842">	} else if (bf-&gt;bf_nseg == 0) {		/* null packet, discard */</a>
<a name="ln843">		sc-&gt;malo_stats.mst_tx_nodata++;</a>
<a name="ln844">		m_freem(m0);</a>
<a name="ln845">		return EIO;</a>
<a name="ln846">	}</a>
<a name="ln847">	DPRINTF(sc, MALO_DEBUG_XMIT, &quot;%s: m %p len %u\n&quot;,</a>
<a name="ln848">		__func__, m0, m0-&gt;m_pkthdr.len);</a>
<a name="ln849">	bus_dmamap_sync(sc-&gt;malo_dmat, bf-&gt;bf_dmamap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln850">	bf-&gt;bf_m = m0;</a>
<a name="ln851"> </a>
<a name="ln852">	return 0;</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">#ifdef MALO_DEBUG</a>
<a name="ln856">static void</a>
<a name="ln857">malo_printrxbuf(const struct malo_rxbuf *bf, u_int ix)</a>
<a name="ln858">{</a>
<a name="ln859">	const struct malo_rxdesc *ds = bf-&gt;bf_desc;</a>
<a name="ln860">	uint32_t status = le32toh(ds-&gt;status);</a>
<a name="ln861">	</a>
<a name="ln862">	printf(&quot;R[%2u] (DS.V:%p DS.P:0x%jx) NEXT:%08x DATA:%08x RC:%02x%s\n&quot;</a>
<a name="ln863">	    &quot;      STAT:%02x LEN:%04x SNR:%02x NF:%02x CHAN:%02x&quot;</a>
<a name="ln864">	    &quot; RATE:%02x QOS:%04x\n&quot;, ix, ds, (uintmax_t)bf-&gt;bf_daddr,</a>
<a name="ln865">	    le32toh(ds-&gt;physnext), le32toh(ds-&gt;physbuffdata),</a>
<a name="ln866">	    ds-&gt;rxcontrol, </a>
<a name="ln867">	    ds-&gt;rxcontrol != MALO_RXD_CTRL_DRIVER_OWN ?</a>
<a name="ln868">	        &quot;&quot; : (status &amp; MALO_RXD_STATUS_OK) ? &quot; *&quot; : &quot; !&quot;,</a>
<a name="ln869">	    ds-&gt;status, le16toh(ds-&gt;pktlen), ds-&gt;snr, ds-&gt;nf, ds-&gt;channel,</a>
<a name="ln870">	    ds-&gt;rate, le16toh(ds-&gt;qosctrl));</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">static void</a>
<a name="ln874">malo_printtxbuf(const struct malo_txbuf *bf, u_int qnum, u_int ix)</a>
<a name="ln875">{</a>
<a name="ln876">	const struct malo_txdesc *ds = bf-&gt;bf_desc;</a>
<a name="ln877">	uint32_t status = le32toh(ds-&gt;status);</a>
<a name="ln878">	</a>
<a name="ln879">	printf(&quot;Q%u[%3u]&quot;, qnum, ix);</a>
<a name="ln880">	printf(&quot; (DS.V:%p DS.P:0x%jx)\n&quot;, ds, (uintmax_t)bf-&gt;bf_daddr);</a>
<a name="ln881">	printf(&quot;    NEXT:%08x DATA:%08x LEN:%04x STAT:%08x%s\n&quot;,</a>
<a name="ln882">	    le32toh(ds-&gt;physnext),</a>
<a name="ln883">	    le32toh(ds-&gt;pktptr), le16toh(ds-&gt;pktlen), status,</a>
<a name="ln884">	    status &amp; MALO_TXD_STATUS_USED ?</a>
<a name="ln885">	    &quot;&quot; : (status &amp; 3) != 0 ? &quot; *&quot; : &quot; !&quot;);</a>
<a name="ln886">	printf(&quot;    RATE:%02x PRI:%x QOS:%04x SAP:%08x FORMAT:%04x\n&quot;,</a>
<a name="ln887">	    ds-&gt;datarate, ds-&gt;txpriority, le16toh(ds-&gt;qosctrl),</a>
<a name="ln888">	    le32toh(ds-&gt;sap_pktinfo), le16toh(ds-&gt;format));</a>
<a name="ln889">#if 0</a>
<a name="ln890">	{</a>
<a name="ln891">		const uint8_t *cp = (const uint8_t *) ds;</a>
<a name="ln892">		int i;</a>
<a name="ln893">		for (i = 0; i &lt; sizeof(struct malo_txdesc); i++) {</a>
<a name="ln894">			printf(&quot;%02x &quot;, cp[i]);</a>
<a name="ln895">			if (((i+1) % 16) == 0)</a>
<a name="ln896">				printf(&quot;\n&quot;);</a>
<a name="ln897">		}</a>
<a name="ln898">		printf(&quot;\n&quot;);</a>
<a name="ln899">	}</a>
<a name="ln900">#endif</a>
<a name="ln901">}</a>
<a name="ln902">#endif /* MALO_DEBUG */</a>
<a name="ln903"> </a>
<a name="ln904">static __inline void</a>
<a name="ln905">malo_updatetxrate(struct ieee80211_node *ni, int rix)</a>
<a name="ln906">{</a>
<a name="ln907">	static const int ieeerates[] =</a>
<a name="ln908">	    { 2, 4, 11, 22, 44, 12, 18, 24, 36, 48, 96, 108 };</a>
<a name="ln909">	if (rix &lt; nitems(ieeerates))</a>
<a name="ln910">		ni-&gt;ni_txrate = ieeerates[rix];</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">static int</a>
<a name="ln914">malo_fix2rate(int fix_rate)</a>
<a name="ln915">{</a>
<a name="ln916">	static const int rates[] =</a>
<a name="ln917">	    { 2, 4, 11, 22, 12, 18, 24, 36, 48, 96, 108 };</a>
<a name="ln918">	return (fix_rate &lt; nitems(rates) ? rates[fix_rate] : 0);</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">/* idiomatic shorthands: MS = mask+shift, SM = shift+mask */</a>
<a name="ln922">#define	MS(v,x)			(((v) &amp; x) &gt;&gt; x##_S)</a>
<a name="ln923">#define	SM(v,x)			(((v) &lt;&lt; x##_S) &amp; x)</a>
<a name="ln924"> </a>
<a name="ln925">/*</a>
<a name="ln926"> * Process completed xmit descriptors from the specified queue.</a>
<a name="ln927"> */</a>
<a name="ln928">static int</a>
<a name="ln929">malo_tx_processq(struct malo_softc *sc, struct malo_txq *txq)</a>
<a name="ln930">{</a>
<a name="ln931">	struct malo_txbuf *bf;</a>
<a name="ln932">	struct malo_txdesc *ds;</a>
<a name="ln933">	struct ieee80211_node *ni;</a>
<a name="ln934">	int nreaped;</a>
<a name="ln935">	uint32_t status;</a>
<a name="ln936"> </a>
<a name="ln937">	DPRINTF(sc, MALO_DEBUG_TX_PROC, &quot;%s: tx queue %u\n&quot;,</a>
<a name="ln938">	    __func__, txq-&gt;qnum);</a>
<a name="ln939">	for (nreaped = 0;; nreaped++) {</a>
<a name="ln940">		MALO_TXQ_LOCK(txq);</a>
<a name="ln941">		bf = STAILQ_FIRST(&amp;txq-&gt;active);</a>
<a name="ln942">		if (bf == NULL) {</a>
<a name="ln943">			MALO_TXQ_UNLOCK(txq);</a>
<a name="ln944">			break;</a>
<a name="ln945">		}</a>
<a name="ln946">		ds = bf-&gt;bf_desc;</a>
<a name="ln947">		MALO_TXDESC_SYNC(txq, ds,</a>
<a name="ln948">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln949">		if (ds-&gt;status &amp; htole32(MALO_TXD_STATUS_FW_OWNED)) {</a>
<a name="ln950">			MALO_TXQ_UNLOCK(txq);</a>
<a name="ln951">			break;</a>
<a name="ln952">		}</a>
<a name="ln953">		STAILQ_REMOVE_HEAD(&amp;txq-&gt;active, bf_list);</a>
<a name="ln954">		MALO_TXQ_UNLOCK(txq);</a>
<a name="ln955"> </a>
<a name="ln956">#ifdef MALO_DEBUG</a>
<a name="ln957">		if (sc-&gt;malo_debug &amp; MALO_DEBUG_XMIT_DESC)</a>
<a name="ln958">			malo_printtxbuf(bf, txq-&gt;qnum, nreaped);</a>
<a name="ln959">#endif</a>
<a name="ln960">		ni = bf-&gt;bf_node;</a>
<a name="ln961">		if (ni != NULL) {</a>
<a name="ln962">			status = le32toh(ds-&gt;status);</a>
<a name="ln963">			if (status &amp; MALO_TXD_STATUS_OK) {</a>
<a name="ln964">				uint16_t format = le16toh(ds-&gt;format);</a>
<a name="ln965">				uint8_t txant = MS(format, MALO_TXD_ANTENNA);</a>
<a name="ln966"> </a>
<a name="ln967">				sc-&gt;malo_stats.mst_ant_tx[txant]++;</a>
<a name="ln968">				if (status &amp; MALO_TXD_STATUS_OK_RETRY)</a>
<a name="ln969">					sc-&gt;malo_stats.mst_tx_retries++;</a>
<a name="ln970">				if (status &amp; MALO_TXD_STATUS_OK_MORE_RETRY)</a>
<a name="ln971">					sc-&gt;malo_stats.mst_tx_mretries++;</a>
<a name="ln972">				malo_updatetxrate(ni, ds-&gt;datarate);</a>
<a name="ln973">				sc-&gt;malo_stats.mst_tx_rate = ds-&gt;datarate;</a>
<a name="ln974">			} else {</a>
<a name="ln975">				if (status &amp; MALO_TXD_STATUS_FAILED_LINK_ERROR)</a>
<a name="ln976">					sc-&gt;malo_stats.mst_tx_linkerror++;</a>
<a name="ln977">				if (status &amp; MALO_TXD_STATUS_FAILED_XRETRY)</a>
<a name="ln978">					sc-&gt;malo_stats.mst_tx_xretries++;</a>
<a name="ln979">				if (status &amp; MALO_TXD_STATUS_FAILED_AGING)</a>
<a name="ln980">					sc-&gt;malo_stats.mst_tx_aging++;</a>
<a name="ln981">			}</a>
<a name="ln982">			/* XXX strip fw len in case header inspected */</a>
<a name="ln983">			m_adj(bf-&gt;bf_m, sizeof(uint16_t));</a>
<a name="ln984">			ieee80211_tx_complete(ni, bf-&gt;bf_m, </a>
<a name="ln985">			    (status &amp; MALO_TXD_STATUS_OK) == 0);</a>
<a name="ln986">		} else</a>
<a name="ln987">			m_freem(bf-&gt;bf_m);</a>
<a name="ln988"> </a>
<a name="ln989">		ds-&gt;status = htole32(MALO_TXD_STATUS_IDLE);</a>
<a name="ln990">		ds-&gt;pktlen = htole32(0);</a>
<a name="ln991"> </a>
<a name="ln992">		bus_dmamap_sync(sc-&gt;malo_dmat, bf-&gt;bf_dmamap,</a>
<a name="ln993">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln994">		bus_dmamap_unload(sc-&gt;malo_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln995">		bf-&gt;bf_m = NULL;</a>
<a name="ln996">		bf-&gt;bf_node = NULL;</a>
<a name="ln997"> </a>
<a name="ln998">		MALO_TXQ_LOCK(txq);</a>
<a name="ln999">		STAILQ_INSERT_TAIL(&amp;txq-&gt;free, bf, bf_list);</a>
<a name="ln1000">		txq-&gt;nfree++;</a>
<a name="ln1001">		MALO_TXQ_UNLOCK(txq);</a>
<a name="ln1002">	}</a>
<a name="ln1003">	return nreaped;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">/*</a>
<a name="ln1007"> * Deferred processing of transmit interrupt.</a>
<a name="ln1008"> */</a>
<a name="ln1009">static void</a>
<a name="ln1010">malo_tx_proc(void *arg, int npending)</a>
<a name="ln1011">{</a>
<a name="ln1012">	struct malo_softc *sc = arg;</a>
<a name="ln1013">	int i, nreaped;</a>
<a name="ln1014"> </a>
<a name="ln1015">	/*</a>
<a name="ln1016">	 * Process each active queue.</a>
<a name="ln1017">	 */</a>
<a name="ln1018">	nreaped = 0;</a>
<a name="ln1019">	MALO_LOCK(sc);</a>
<a name="ln1020">	for (i = 0; i &lt; MALO_NUM_TX_QUEUES; i++) {</a>
<a name="ln1021">		if (!STAILQ_EMPTY(&amp;sc-&gt;malo_txq[i].active))</a>
<a name="ln1022">			nreaped += malo_tx_processq(sc, &amp;sc-&gt;malo_txq[i]);</a>
<a name="ln1023">	}</a>
<a name="ln1024"> </a>
<a name="ln1025">	if (nreaped != 0) {</a>
<a name="ln1026">		sc-&gt;malo_timer = 0;</a>
<a name="ln1027">		malo_start(sc);</a>
<a name="ln1028">	}</a>
<a name="ln1029">	MALO_UNLOCK(sc);</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">static int</a>
<a name="ln1033">malo_tx_start(struct malo_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln1034">    struct malo_txbuf *bf, struct mbuf *m0)</a>
<a name="ln1035">{</a>
<a name="ln1036">#define	IS_DATA_FRAME(wh)						\</a>
<a name="ln1037">	((wh-&gt;i_fc[0] &amp; (IEEE80211_FC0_TYPE_MASK)) == IEEE80211_FC0_TYPE_DATA)</a>
<a name="ln1038">	int error, ismcast, iswep;</a>
<a name="ln1039">	int copyhdrlen, hdrlen, pktlen;</a>
<a name="ln1040">	struct ieee80211_frame *wh;</a>
<a name="ln1041">	struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln1042">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1043">	struct malo_txdesc *ds;</a>
<a name="ln1044">	struct malo_txrec *tr;</a>
<a name="ln1045">	struct malo_txq *txq;</a>
<a name="ln1046">	uint16_t qos;</a>
<a name="ln1047"> </a>
<a name="ln1048">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1049">	iswep = wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED;</a>
<a name="ln1050">	ismcast = IEEE80211_IS_MULTICAST(wh-&gt;i_addr1);</a>
<a name="ln1051">	copyhdrlen = hdrlen = ieee80211_anyhdrsize(wh);</a>
<a name="ln1052">	pktlen = m0-&gt;m_pkthdr.len;</a>
<a name="ln1053">	if (IEEE80211_QOS_HAS_SEQ(wh)) {</a>
<a name="ln1054">		if (IEEE80211_IS_DSTODS(wh)) {</a>
<a name="ln1055">			qos = *(uint16_t *)</a>
<a name="ln1056">			    (((struct ieee80211_qosframe_addr4 *) wh)-&gt;i_qos);</a>
<a name="ln1057">			copyhdrlen -= sizeof(qos);</a>
<a name="ln1058">		} else</a>
<a name="ln1059">			qos = *(uint16_t *)</a>
<a name="ln1060">			    (((struct ieee80211_qosframe *) wh)-&gt;i_qos);</a>
<a name="ln1061">	} else</a>
<a name="ln1062">		qos = 0;</a>
<a name="ln1063"> </a>
<a name="ln1064">	if (iswep) {</a>
<a name="ln1065">		struct ieee80211_key *k;</a>
<a name="ln1066"> </a>
<a name="ln1067">		/*</a>
<a name="ln1068">		 * Construct the 802.11 header+trailer for an encrypted</a>
<a name="ln1069">		 * frame. The only reason this can fail is because of an</a>
<a name="ln1070">		 * unknown or unsupported cipher/key type.</a>
<a name="ln1071">		 *</a>
<a name="ln1072">		 * NB: we do this even though the firmware will ignore</a>
<a name="ln1073">		 *     what we've done for WEP and TKIP as we need the</a>
<a name="ln1074">		 *     ExtIV filled in for CCMP and this also adjusts</a>
<a name="ln1075">		 *     the headers which simplifies our work below.</a>
<a name="ln1076">		 */</a>
<a name="ln1077">		k = ieee80211_crypto_encap(ni, m0);</a>
<a name="ln1078">		if (k == NULL) {</a>
<a name="ln1079">			/*</a>
<a name="ln1080">			 * This can happen when the key is yanked after the</a>
<a name="ln1081">			 * frame was queued.  Just discard the frame; the</a>
<a name="ln1082">			 * 802.11 layer counts failures and provides</a>
<a name="ln1083">			 * debugging/diagnostics.</a>
<a name="ln1084">			 */</a>
<a name="ln1085">			m_freem(m0);</a>
<a name="ln1086">			return EIO;</a>
<a name="ln1087">		}</a>
<a name="ln1088"> </a>
<a name="ln1089">		/*</a>
<a name="ln1090">		 * Adjust the packet length for the crypto additions</a>
<a name="ln1091">		 * done during encap and any other bits that the f/w</a>
<a name="ln1092">		 * will add later on.</a>
<a name="ln1093">		 */</a>
<a name="ln1094">		pktlen = m0-&gt;m_pkthdr.len;</a>
<a name="ln1095"> </a>
<a name="ln1096">		/* packet header may have moved, reset our local pointer */</a>
<a name="ln1097">		wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1098">	}</a>
<a name="ln1099"> </a>
<a name="ln1100">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln1101">		sc-&gt;malo_tx_th.wt_flags = 0;	/* XXX */</a>
<a name="ln1102">		if (iswep)</a>
<a name="ln1103">			sc-&gt;malo_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln1104">		sc-&gt;malo_tx_th.wt_txpower = ni-&gt;ni_txpower;</a>
<a name="ln1105">		sc-&gt;malo_tx_th.wt_antenna = sc-&gt;malo_txantenna;</a>
<a name="ln1106"> </a>
<a name="ln1107">		ieee80211_radiotap_tx(vap, m0);</a>
<a name="ln1108">	}</a>
<a name="ln1109"> </a>
<a name="ln1110">	/*</a>
<a name="ln1111">	 * Copy up/down the 802.11 header; the firmware requires</a>
<a name="ln1112">	 * we present a 2-byte payload length followed by a</a>
<a name="ln1113">	 * 4-address header (w/o QoS), followed (optionally) by</a>
<a name="ln1114">	 * any WEP/ExtIV header (but only filled in for CCMP).</a>
<a name="ln1115">	 * We are assured the mbuf has sufficient headroom to</a>
<a name="ln1116">	 * prepend in-place by the setup of ic_headroom in</a>
<a name="ln1117">	 * malo_attach.</a>
<a name="ln1118">	 */</a>
<a name="ln1119">	if (hdrlen &lt; sizeof(struct malo_txrec)) {</a>
<a name="ln1120">		const int space = sizeof(struct malo_txrec) - hdrlen;</a>
<a name="ln1121">		if (M_LEADINGSPACE(m0) &lt; space) {</a>
<a name="ln1122">			/* NB: should never happen */</a>
<a name="ln1123">			device_printf(sc-&gt;malo_dev,</a>
<a name="ln1124">			    &quot;not enough headroom, need %d found %zd, &quot;</a>
<a name="ln1125">			    &quot;m_flags 0x%x m_len %d\n&quot;,</a>
<a name="ln1126">			    space, M_LEADINGSPACE(m0), m0-&gt;m_flags, m0-&gt;m_len);</a>
<a name="ln1127">			ieee80211_dump_pkt(ic,</a>
<a name="ln1128">			    mtod(m0, const uint8_t *), m0-&gt;m_len, 0, -1);</a>
<a name="ln1129">			m_freem(m0);</a>
<a name="ln1130">			/* XXX stat */</a>
<a name="ln1131">			return EIO;</a>
<a name="ln1132">		}</a>
<a name="ln1133">		M_PREPEND(m0, space, M_NOWAIT);</a>
<a name="ln1134">	}</a>
<a name="ln1135">	tr = mtod(m0, struct malo_txrec *);</a>
<a name="ln1136">	if (wh != (struct ieee80211_frame *) &amp;tr-&gt;wh)</a>
<a name="ln1137">		ovbcopy(wh, &amp;tr-&gt;wh, hdrlen);</a>
<a name="ln1138">	/*</a>
<a name="ln1139">	 * Note: the &quot;firmware length&quot; is actually the length of the fully</a>
<a name="ln1140">	 * formed &quot;802.11 payload&quot;.  That is, it's everything except for</a>
<a name="ln1141">	 * the 802.11 header.  In particular this includes all crypto</a>
<a name="ln1142">	 * material including the MIC!</a>
<a name="ln1143">	 */</a>
<a name="ln1144">	tr-&gt;fwlen = htole16(pktlen - hdrlen);</a>
<a name="ln1145"> </a>
<a name="ln1146">	/*</a>
<a name="ln1147">	 * Load the DMA map so any coalescing is done.  This</a>
<a name="ln1148">	 * also calculates the number of descriptors we need.</a>
<a name="ln1149">	 */</a>
<a name="ln1150">	error = malo_tx_dmasetup(sc, bf, m0);</a>
<a name="ln1151">	if (error != 0)</a>
<a name="ln1152">		return error;</a>
<a name="ln1153">	bf-&gt;bf_node = ni;			/* NB: held reference */</a>
<a name="ln1154">	m0 = bf-&gt;bf_m;				/* NB: may have changed */</a>
<a name="ln1155">	tr = mtod(m0, struct malo_txrec *);</a>
<a name="ln1156">	wh = (struct ieee80211_frame *)&amp;tr-&gt;wh;</a>
<a name="ln1157"> </a>
<a name="ln1158">	/*</a>
<a name="ln1159">	 * Formulate tx descriptor.</a>
<a name="ln1160">	 */</a>
<a name="ln1161">	ds = bf-&gt;bf_desc;</a>
<a name="ln1162">	txq = bf-&gt;bf_txq;</a>
<a name="ln1163"> </a>
<a name="ln1164">	ds-&gt;qosctrl = qos;			/* NB: already little-endian */</a>
<a name="ln1165">	ds-&gt;pktptr = htole32(bf-&gt;bf_segs[0].ds_addr);</a>
<a name="ln1166">	ds-&gt;pktlen = htole16(bf-&gt;bf_segs[0].ds_len);</a>
<a name="ln1167">	/* NB: pPhysNext setup once, don't touch */</a>
<a name="ln1168">	ds-&gt;datarate = IS_DATA_FRAME(wh) ? 1 : 0;</a>
<a name="ln1169">	ds-&gt;sap_pktinfo = 0;</a>
<a name="ln1170">	ds-&gt;format = 0;</a>
<a name="ln1171"> </a>
<a name="ln1172">	/*</a>
<a name="ln1173">	 * Select transmit rate.</a>
<a name="ln1174">	 */</a>
<a name="ln1175">	switch (wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK) {</a>
<a name="ln1176">	case IEEE80211_FC0_TYPE_MGT:</a>
<a name="ln1177">		sc-&gt;malo_stats.mst_tx_mgmt++;</a>
<a name="ln1178">		/* fall thru... */</a>
<a name="ln1179">	case IEEE80211_FC0_TYPE_CTL:</a>
<a name="ln1180">		ds-&gt;txpriority = 1;</a>
<a name="ln1181">		break;</a>
<a name="ln1182">	case IEEE80211_FC0_TYPE_DATA:</a>
<a name="ln1183">		ds-&gt;txpriority = txq-&gt;qnum;</a>
<a name="ln1184">		break;</a>
<a name="ln1185">	default:</a>
<a name="ln1186">		device_printf(sc-&gt;malo_dev, &quot;bogus frame type 0x%x (%s)\n&quot;,</a>
<a name="ln1187">			wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK, __func__);</a>
<a name="ln1188">		/* XXX statistic */</a>
<a name="ln1189">		m_freem(m0);</a>
<a name="ln1190">		return EIO;</a>
<a name="ln1191">	}</a>
<a name="ln1192"> </a>
<a name="ln1193">#ifdef MALO_DEBUG</a>
<a name="ln1194">	if (IFF_DUMPPKTS_XMIT(sc))</a>
<a name="ln1195">		ieee80211_dump_pkt(ic,</a>
<a name="ln1196">		    mtod(m0, const uint8_t *)+sizeof(uint16_t),</a>
<a name="ln1197">		    m0-&gt;m_len - sizeof(uint16_t), ds-&gt;datarate, -1);</a>
<a name="ln1198">#endif</a>
<a name="ln1199"> </a>
<a name="ln1200">	MALO_TXQ_LOCK(txq);</a>
<a name="ln1201">	if (!IS_DATA_FRAME(wh))</a>
<a name="ln1202">		ds-&gt;status |= htole32(1);</a>
<a name="ln1203">	ds-&gt;status |= htole32(MALO_TXD_STATUS_FW_OWNED);</a>
<a name="ln1204">	STAILQ_INSERT_TAIL(&amp;txq-&gt;active, bf, bf_list);</a>
<a name="ln1205">	MALO_TXDESC_SYNC(txq, ds, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln1206"> </a>
<a name="ln1207">	sc-&gt;malo_timer = 5;</a>
<a name="ln1208">	MALO_TXQ_UNLOCK(txq);</a>
<a name="ln1209">	return 0;</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212">static int</a>
<a name="ln1213">malo_transmit(struct ieee80211com *ic, struct mbuf *m)</a>
<a name="ln1214">{</a>
<a name="ln1215">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1216">	int error;</a>
<a name="ln1217"> </a>
<a name="ln1218">	MALO_LOCK(sc);</a>
<a name="ln1219">	if (!sc-&gt;malo_running) {</a>
<a name="ln1220">		MALO_UNLOCK(sc);</a>
<a name="ln1221">		return (ENXIO);</a>
<a name="ln1222">	}</a>
<a name="ln1223">	error = mbufq_enqueue(&amp;sc-&gt;malo_snd, m);</a>
<a name="ln1224">	if (error) {</a>
<a name="ln1225">		MALO_UNLOCK(sc);</a>
<a name="ln1226">		return (error);</a>
<a name="ln1227">	}</a>
<a name="ln1228">	malo_start(sc);</a>
<a name="ln1229">	MALO_UNLOCK(sc);</a>
<a name="ln1230">	return (0);</a>
<a name="ln1231">}</a>
<a name="ln1232"> </a>
<a name="ln1233">static void</a>
<a name="ln1234">malo_start(struct malo_softc *sc)</a>
<a name="ln1235">{</a>
<a name="ln1236">	struct ieee80211_node *ni;</a>
<a name="ln1237">	struct malo_txq *txq = &amp;sc-&gt;malo_txq[0];</a>
<a name="ln1238">	struct malo_txbuf *bf = NULL;</a>
<a name="ln1239">	struct mbuf *m;</a>
<a name="ln1240">	int nqueued = 0;</a>
<a name="ln1241"> </a>
<a name="ln1242">	MALO_LOCK_ASSERT(sc);</a>
<a name="ln1243"> </a>
<a name="ln1244">	if (!sc-&gt;malo_running || sc-&gt;malo_invalid)</a>
<a name="ln1245">		return;</a>
<a name="ln1246"> </a>
<a name="ln1247">	while ((m = mbufq_dequeue(&amp;sc-&gt;malo_snd)) != NULL) {</a>
<a name="ln1248">		ni = (struct ieee80211_node *) m-&gt;m_pkthdr.rcvif;</a>
<a name="ln1249">		bf = malo_getbuf(sc, txq);</a>
<a name="ln1250">		if (bf == NULL) {</a>
<a name="ln1251">			mbufq_prepend(&amp;sc-&gt;malo_snd, m);</a>
<a name="ln1252">			sc-&gt;malo_stats.mst_tx_qstop++;</a>
<a name="ln1253">			break;</a>
<a name="ln1254">		}</a>
<a name="ln1255">		/*</a>
<a name="ln1256">		 * Pass the frame to the h/w for transmission.</a>
<a name="ln1257">		 */</a>
<a name="ln1258">		if (malo_tx_start(sc, ni, bf, m)) {</a>
<a name="ln1259">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln1260">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln1261">			if (bf != NULL) {</a>
<a name="ln1262">				bf-&gt;bf_m = NULL;</a>
<a name="ln1263">				bf-&gt;bf_node = NULL;</a>
<a name="ln1264">				MALO_TXQ_LOCK(txq);</a>
<a name="ln1265">				STAILQ_INSERT_HEAD(&amp;txq-&gt;free, bf, bf_list);</a>
<a name="ln1266">				MALO_TXQ_UNLOCK(txq);</a>
<a name="ln1267">			}</a>
<a name="ln1268">			ieee80211_free_node(ni);</a>
<a name="ln1269">			continue;</a>
<a name="ln1270">		}</a>
<a name="ln1271">		nqueued++;</a>
<a name="ln1272"> </a>
<a name="ln1273">		if (nqueued &gt;= malo_txcoalesce) {</a>
<a name="ln1274">			/*</a>
<a name="ln1275">			 * Poke the firmware to process queued frames;</a>
<a name="ln1276">			 * see below about (lack of) locking.</a>
<a name="ln1277">			 */</a>
<a name="ln1278">			nqueued = 0;</a>
<a name="ln1279">			malo_hal_txstart(sc-&gt;malo_mh, 0/*XXX*/);</a>
<a name="ln1280">		}</a>
<a name="ln1281">	}</a>
<a name="ln1282"> </a>
<a name="ln1283">	if (nqueued) {</a>
<a name="ln1284">		/*</a>
<a name="ln1285">		 * NB: We don't need to lock against tx done because</a>
<a name="ln1286">		 * this just prods the firmware to check the transmit</a>
<a name="ln1287">		 * descriptors.  The firmware will also start fetching</a>
<a name="ln1288">		 * descriptors by itself if it notices new ones are</a>
<a name="ln1289">		 * present when it goes to deliver a tx done interrupt</a>
<a name="ln1290">		 * to the host. So if we race with tx done processing</a>
<a name="ln1291">		 * it's ok.  Delivering the kick here rather than in</a>
<a name="ln1292">		 * malo_tx_start is an optimization to avoid poking the</a>
<a name="ln1293">		 * firmware for each packet.</a>
<a name="ln1294">		 *</a>
<a name="ln1295">		 * NB: the queue id isn't used so 0 is ok.</a>
<a name="ln1296">		 */</a>
<a name="ln1297">		malo_hal_txstart(sc-&gt;malo_mh, 0/*XXX*/);</a>
<a name="ln1298">	}</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301">static void</a>
<a name="ln1302">malo_watchdog(void *arg)</a>
<a name="ln1303">{</a>
<a name="ln1304">	struct malo_softc *sc = arg;</a>
<a name="ln1305"> </a>
<a name="ln1306">	callout_reset(&amp;sc-&gt;malo_watchdog_timer, hz, malo_watchdog, sc);</a>
<a name="ln1307">	if (sc-&gt;malo_timer == 0 || --sc-&gt;malo_timer &gt; 0)</a>
<a name="ln1308">		return;</a>
<a name="ln1309"> </a>
<a name="ln1310">	if (sc-&gt;malo_running &amp;&amp; !sc-&gt;malo_invalid) {</a>
<a name="ln1311">		device_printf(sc-&gt;malo_dev, &quot;watchdog timeout\n&quot;);</a>
<a name="ln1312"> </a>
<a name="ln1313">		/* XXX no way to reset h/w. now  */</a>
<a name="ln1314"> </a>
<a name="ln1315">		counter_u64_add(sc-&gt;malo_ic.ic_oerrors, 1);</a>
<a name="ln1316">		sc-&gt;malo_stats.mst_watchdog++;</a>
<a name="ln1317">	}</a>
<a name="ln1318">}</a>
<a name="ln1319"> </a>
<a name="ln1320">static int</a>
<a name="ln1321">malo_hal_reset(struct malo_softc *sc)</a>
<a name="ln1322">{</a>
<a name="ln1323">	static int first = 0;</a>
<a name="ln1324">	struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln1325">	struct malo_hal *mh = sc-&gt;malo_mh;</a>
<a name="ln1326"> </a>
<a name="ln1327">	if (first == 0) {</a>
<a name="ln1328">		/*</a>
<a name="ln1329">		 * NB: when the device firstly is initialized, sometimes</a>
<a name="ln1330">		 * firmware could override rx/tx dma registers so we re-set</a>
<a name="ln1331">		 * these values once.</a>
<a name="ln1332">		 */</a>
<a name="ln1333">		malo_hal_set_rxtxdma(sc);</a>
<a name="ln1334">		first = 1;</a>
<a name="ln1335">	}</a>
<a name="ln1336"> </a>
<a name="ln1337">	malo_hal_setantenna(mh, MHA_ANTENNATYPE_RX, sc-&gt;malo_rxantenna);</a>
<a name="ln1338">	malo_hal_setantenna(mh, MHA_ANTENNATYPE_TX, sc-&gt;malo_txantenna);</a>
<a name="ln1339">	malo_hal_setradio(mh, 1, MHP_AUTO_PREAMBLE);</a>
<a name="ln1340">	malo_chan_set(sc, ic-&gt;ic_curchan);</a>
<a name="ln1341"> </a>
<a name="ln1342">	/* XXX needs other stuffs?  */</a>
<a name="ln1343"> </a>
<a name="ln1344">	return 1;</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">static __inline struct mbuf *</a>
<a name="ln1348">malo_getrxmbuf(struct malo_softc *sc, struct malo_rxbuf *bf)</a>
<a name="ln1349">{</a>
<a name="ln1350">	struct mbuf *m;</a>
<a name="ln1351">	bus_addr_t paddr;</a>
<a name="ln1352">	int error;</a>
<a name="ln1353"> </a>
<a name="ln1354">	/* XXX don't need mbuf, just dma buffer */</a>
<a name="ln1355">	m = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR, MJUMPAGESIZE);</a>
<a name="ln1356">	if (m == NULL) {</a>
<a name="ln1357">		sc-&gt;malo_stats.mst_rx_nombuf++;	/* XXX */</a>
<a name="ln1358">		return NULL;</a>
<a name="ln1359">	}</a>
<a name="ln1360">	error = bus_dmamap_load(sc-&gt;malo_dmat, bf-&gt;bf_dmamap,</a>
<a name="ln1361">	    mtod(m, caddr_t), MJUMPAGESIZE,</a>
<a name="ln1362">	    malo_load_cb, &amp;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln1363">	if (error != 0) {</a>
<a name="ln1364">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln1365">		    &quot;%s: bus_dmamap_load failed, error %d\n&quot;, __func__, error);</a>
<a name="ln1366">		m_freem(m);</a>
<a name="ln1367">		return NULL;</a>
<a name="ln1368">	}</a>
<a name="ln1369">	bf-&gt;bf_data = paddr;</a>
<a name="ln1370">	bus_dmamap_sync(sc-&gt;malo_dmat, bf-&gt;bf_dmamap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1371"> </a>
<a name="ln1372">	return m;</a>
<a name="ln1373">}</a>
<a name="ln1374"> </a>
<a name="ln1375">static int</a>
<a name="ln1376">malo_rxbuf_init(struct malo_softc *sc, struct malo_rxbuf *bf)</a>
<a name="ln1377">{</a>
<a name="ln1378">	struct malo_rxdesc *ds;</a>
<a name="ln1379"> </a>
<a name="ln1380">	ds = bf-&gt;bf_desc;</a>
<a name="ln1381">	if (bf-&gt;bf_m == NULL) {</a>
<a name="ln1382">		bf-&gt;bf_m = malo_getrxmbuf(sc, bf);</a>
<a name="ln1383">		if (bf-&gt;bf_m == NULL) {</a>
<a name="ln1384">			/* mark descriptor to be skipped */</a>
<a name="ln1385">			ds-&gt;rxcontrol = MALO_RXD_CTRL_OS_OWN;</a>
<a name="ln1386">			/* NB: don't need PREREAD */</a>
<a name="ln1387">			MALO_RXDESC_SYNC(sc, ds, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1388">			return ENOMEM;</a>
<a name="ln1389">		}</a>
<a name="ln1390">	}</a>
<a name="ln1391"> </a>
<a name="ln1392">	/*</a>
<a name="ln1393">	 * Setup descriptor.</a>
<a name="ln1394">	 */</a>
<a name="ln1395">	ds-&gt;qosctrl = 0;</a>
<a name="ln1396">	ds-&gt;snr = 0;</a>
<a name="ln1397">	ds-&gt;status = MALO_RXD_STATUS_IDLE;</a>
<a name="ln1398">	ds-&gt;channel = 0;</a>
<a name="ln1399">	ds-&gt;pktlen = htole16(MALO_RXSIZE);</a>
<a name="ln1400">	ds-&gt;nf = 0;</a>
<a name="ln1401">	ds-&gt;physbuffdata = htole32(bf-&gt;bf_data);</a>
<a name="ln1402">	/* NB: don't touch pPhysNext, set once */</a>
<a name="ln1403">	ds-&gt;rxcontrol = MALO_RXD_CTRL_DRIVER_OWN;</a>
<a name="ln1404">	MALO_RXDESC_SYNC(sc, ds, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln1405"> </a>
<a name="ln1406">	return 0;</a>
<a name="ln1407">}</a>
<a name="ln1408"> </a>
<a name="ln1409">/*</a>
<a name="ln1410"> * Setup the rx data structures.  This should only be done once or we may get</a>
<a name="ln1411"> * out of sync with the firmware.</a>
<a name="ln1412"> */</a>
<a name="ln1413">static int</a>
<a name="ln1414">malo_startrecv(struct malo_softc *sc)</a>
<a name="ln1415">{</a>
<a name="ln1416">	struct malo_rxbuf *bf, *prev;</a>
<a name="ln1417">	struct malo_rxdesc *ds;</a>
<a name="ln1418">	</a>
<a name="ln1419">	if (sc-&gt;malo_recvsetup == 1) {</a>
<a name="ln1420">		malo_mode_init(sc);		/* set filters, etc. */</a>
<a name="ln1421">		return 0;</a>
<a name="ln1422">	}</a>
<a name="ln1423">	</a>
<a name="ln1424">	prev = NULL;</a>
<a name="ln1425">	STAILQ_FOREACH(bf, &amp;sc-&gt;malo_rxbuf, bf_list) {</a>
<a name="ln1426">		int error = malo_rxbuf_init(sc, bf);</a>
<a name="ln1427">		if (error != 0) {</a>
<a name="ln1428">			DPRINTF(sc, MALO_DEBUG_RECV,</a>
<a name="ln1429">			    &quot;%s: malo_rxbuf_init failed %d\n&quot;,</a>
<a name="ln1430">			    __func__, error);</a>
<a name="ln1431">			return error;</a>
<a name="ln1432">		}</a>
<a name="ln1433">		if (prev != NULL) {</a>
<a name="ln1434">			ds = prev-&gt;bf_desc;</a>
<a name="ln1435">			ds-&gt;physnext = htole32(bf-&gt;bf_daddr);</a>
<a name="ln1436">		}</a>
<a name="ln1437">		prev = bf;</a>
<a name="ln1438">	}</a>
<a name="ln1439">	if (prev != NULL) {</a>
<a name="ln1440">		ds = prev-&gt;bf_desc;</a>
<a name="ln1441">		ds-&gt;physnext =</a>
<a name="ln1442">		    htole32(STAILQ_FIRST(&amp;sc-&gt;malo_rxbuf)-&gt;bf_daddr);</a>
<a name="ln1443">	}</a>
<a name="ln1444"> </a>
<a name="ln1445">	sc-&gt;malo_recvsetup = 1;</a>
<a name="ln1446"> </a>
<a name="ln1447">	malo_mode_init(sc);		/* set filters, etc. */</a>
<a name="ln1448">	</a>
<a name="ln1449">	return 0;</a>
<a name="ln1450">}</a>
<a name="ln1451"> </a>
<a name="ln1452">static void</a>
<a name="ln1453">malo_init_locked(struct malo_softc *sc)</a>
<a name="ln1454">{</a>
<a name="ln1455">	struct malo_hal *mh = sc-&gt;malo_mh;</a>
<a name="ln1456">	int error;</a>
<a name="ln1457">	</a>
<a name="ln1458">	MALO_LOCK_ASSERT(sc);</a>
<a name="ln1459">	</a>
<a name="ln1460">	/*</a>
<a name="ln1461">	 * Stop anything previously setup.  This is safe whether this is</a>
<a name="ln1462">	 * the first time through or not.</a>
<a name="ln1463">	 */</a>
<a name="ln1464">	malo_stop(sc);</a>
<a name="ln1465"> </a>
<a name="ln1466">	/*</a>
<a name="ln1467">	 * Push state to the firmware.</a>
<a name="ln1468">	 */</a>
<a name="ln1469">	if (!malo_hal_reset(sc)) {</a>
<a name="ln1470">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln1471">		    &quot;%s: unable to reset hardware\n&quot;, __func__);</a>
<a name="ln1472">		return;</a>
<a name="ln1473">	}</a>
<a name="ln1474"> </a>
<a name="ln1475">	/*</a>
<a name="ln1476">	 * Setup recv (once); transmit is already good to go.</a>
<a name="ln1477">	 */</a>
<a name="ln1478">	error = malo_startrecv(sc);</a>
<a name="ln1479">	if (error != 0) {</a>
<a name="ln1480">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln1481">		    &quot;%s: unable to start recv logic, error %d\n&quot;,</a>
<a name="ln1482">		    __func__, error);</a>
<a name="ln1483">		return;</a>
<a name="ln1484">	}</a>
<a name="ln1485"> </a>
<a name="ln1486">	/*</a>
<a name="ln1487">	 * Enable interrupts.</a>
<a name="ln1488">	 */</a>
<a name="ln1489">	sc-&gt;malo_imask = MALO_A2HRIC_BIT_RX_RDY</a>
<a name="ln1490">	    | MALO_A2HRIC_BIT_TX_DONE</a>
<a name="ln1491">	    | MALO_A2HRIC_BIT_OPC_DONE</a>
<a name="ln1492">	    | MALO_A2HRIC_BIT_MAC_EVENT</a>
<a name="ln1493">	    | MALO_A2HRIC_BIT_RX_PROBLEM</a>
<a name="ln1494">	    | MALO_A2HRIC_BIT_ICV_ERROR</a>
<a name="ln1495">	    | MALO_A2HRIC_BIT_RADAR_DETECT</a>
<a name="ln1496">	    | MALO_A2HRIC_BIT_CHAN_SWITCH;</a>
<a name="ln1497"> </a>
<a name="ln1498">	sc-&gt;malo_running = 1;</a>
<a name="ln1499">	malo_hal_intrset(mh, sc-&gt;malo_imask);</a>
<a name="ln1500">	callout_reset(&amp;sc-&gt;malo_watchdog_timer, hz, malo_watchdog, sc);</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503">static void</a>
<a name="ln1504">malo_init(void *arg)</a>
<a name="ln1505">{</a>
<a name="ln1506">	struct malo_softc *sc = (struct malo_softc *) arg;</a>
<a name="ln1507">	struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln1508">	</a>
<a name="ln1509">	MALO_LOCK(sc);</a>
<a name="ln1510">	malo_init_locked(sc);</a>
<a name="ln1511">	MALO_UNLOCK(sc);</a>
<a name="ln1512"> </a>
<a name="ln1513">	if (sc-&gt;malo_running)</a>
<a name="ln1514">		ieee80211_start_all(ic);	/* start all vap's */</a>
<a name="ln1515">}</a>
<a name="ln1516"> </a>
<a name="ln1517">/*</a>
<a name="ln1518"> * Set the multicast filter contents into the hardware.</a>
<a name="ln1519"> */</a>
<a name="ln1520">static void</a>
<a name="ln1521">malo_setmcastfilter(struct malo_softc *sc)</a>
<a name="ln1522">{</a>
<a name="ln1523">	struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln1524">	struct ieee80211vap *vap;</a>
<a name="ln1525">	uint8_t macs[IEEE80211_ADDR_LEN * MALO_HAL_MCAST_MAX];</a>
<a name="ln1526">	uint8_t *mp;</a>
<a name="ln1527">	int nmc;</a>
<a name="ln1528"> </a>
<a name="ln1529">	mp = macs;</a>
<a name="ln1530">	nmc = 0;</a>
<a name="ln1531"> </a>
<a name="ln1532">	if (ic-&gt;ic_opmode == IEEE80211_M_MONITOR || ic-&gt;ic_allmulti &gt; 0 ||</a>
<a name="ln1533">	    ic-&gt;ic_promisc &gt; 0)</a>
<a name="ln1534">		goto all;</a>
<a name="ln1535"> </a>
<a name="ln1536">	TAILQ_FOREACH(vap, &amp;ic-&gt;ic_vaps, iv_next) {</a>
<a name="ln1537">		struct ifnet *ifp;</a>
<a name="ln1538">		struct ifmultiaddr *ifma;</a>
<a name="ln1539"> </a>
<a name="ln1540">		ifp = vap-&gt;iv_ifp;</a>
<a name="ln1541">		if_maddr_rlock(ifp);</a>
<a name="ln1542">		TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1543">			if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1544">				continue;</a>
<a name="ln1545"> </a>
<a name="ln1546">			if (nmc == MALO_HAL_MCAST_MAX) {</a>
<a name="ln1547">				ifp-&gt;if_flags |= IFF_ALLMULTI;</a>
<a name="ln1548">				if_maddr_runlock(ifp);</a>
<a name="ln1549">				goto all;</a>
<a name="ln1550">			}</a>
<a name="ln1551">			IEEE80211_ADDR_COPY(mp,</a>
<a name="ln1552">			    LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr));</a>
<a name="ln1553"> </a>
<a name="ln1554">			mp += IEEE80211_ADDR_LEN, nmc++;</a>
<a name="ln1555">		}</a>
<a name="ln1556">		if_maddr_runlock(ifp);</a>
<a name="ln1557">	}</a>
<a name="ln1558"> </a>
<a name="ln1559">	malo_hal_setmcast(sc-&gt;malo_mh, nmc, macs);</a>
<a name="ln1560"> </a>
<a name="ln1561">all:</a>
<a name="ln1562">	/*</a>
<a name="ln1563">	 * XXX we don't know how to set the f/w for supporting</a>
<a name="ln1564">	 * IFF_ALLMULTI | IFF_PROMISC cases</a>
<a name="ln1565">	 */</a>
<a name="ln1566">	return;</a>
<a name="ln1567">}</a>
<a name="ln1568"> </a>
<a name="ln1569">static int</a>
<a name="ln1570">malo_mode_init(struct malo_softc *sc)</a>
<a name="ln1571">{</a>
<a name="ln1572">	struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln1573">	struct malo_hal *mh = sc-&gt;malo_mh;</a>
<a name="ln1574"> </a>
<a name="ln1575">	malo_hal_setpromisc(mh, ic-&gt;ic_promisc &gt; 0);</a>
<a name="ln1576">	malo_setmcastfilter(sc);</a>
<a name="ln1577"> </a>
<a name="ln1578">	return ENXIO;</a>
<a name="ln1579">}</a>
<a name="ln1580"> </a>
<a name="ln1581">static void</a>
<a name="ln1582">malo_tx_draintxq(struct malo_softc *sc, struct malo_txq *txq)</a>
<a name="ln1583">{</a>
<a name="ln1584">	struct ieee80211_node *ni;</a>
<a name="ln1585">	struct malo_txbuf *bf;</a>
<a name="ln1586">	u_int ix;</a>
<a name="ln1587">	</a>
<a name="ln1588">	/*</a>
<a name="ln1589">	 * NB: this assumes output has been stopped and</a>
<a name="ln1590">	 *     we do not need to block malo_tx_tasklet</a>
<a name="ln1591">	 */</a>
<a name="ln1592">	for (ix = 0;; ix++) {</a>
<a name="ln1593">		MALO_TXQ_LOCK(txq);</a>
<a name="ln1594">		bf = STAILQ_FIRST(&amp;txq-&gt;active);</a>
<a name="ln1595">		if (bf == NULL) {</a>
<a name="ln1596">			MALO_TXQ_UNLOCK(txq);</a>
<a name="ln1597">			break;</a>
<a name="ln1598">		}</a>
<a name="ln1599">		STAILQ_REMOVE_HEAD(&amp;txq-&gt;active, bf_list);</a>
<a name="ln1600">		MALO_TXQ_UNLOCK(txq);</a>
<a name="ln1601">#ifdef MALO_DEBUG</a>
<a name="ln1602">		if (sc-&gt;malo_debug &amp; MALO_DEBUG_RESET) {</a>
<a name="ln1603">			struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln1604">			const struct malo_txrec *tr =</a>
<a name="ln1605">			    mtod(bf-&gt;bf_m, const struct malo_txrec *);</a>
<a name="ln1606">			malo_printtxbuf(bf, txq-&gt;qnum, ix);</a>
<a name="ln1607">			ieee80211_dump_pkt(ic, (const uint8_t *)&amp;tr-&gt;wh,</a>
<a name="ln1608">			    bf-&gt;bf_m-&gt;m_len - sizeof(tr-&gt;fwlen), 0, -1);</a>
<a name="ln1609">		}</a>
<a name="ln1610">#endif /* MALO_DEBUG */</a>
<a name="ln1611">		bus_dmamap_unload(sc-&gt;malo_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln1612">		ni = bf-&gt;bf_node;</a>
<a name="ln1613">		bf-&gt;bf_node = NULL;</a>
<a name="ln1614">		if (ni != NULL) {</a>
<a name="ln1615">			/*</a>
<a name="ln1616">			 * Reclaim node reference.</a>
<a name="ln1617">			 */</a>
<a name="ln1618">			ieee80211_free_node(ni);</a>
<a name="ln1619">		}</a>
<a name="ln1620">		m_freem(bf-&gt;bf_m);</a>
<a name="ln1621">		bf-&gt;bf_m = NULL;</a>
<a name="ln1622">		</a>
<a name="ln1623">		MALO_TXQ_LOCK(txq);</a>
<a name="ln1624">		STAILQ_INSERT_TAIL(&amp;txq-&gt;free, bf, bf_list);</a>
<a name="ln1625">		txq-&gt;nfree++;</a>
<a name="ln1626">		MALO_TXQ_UNLOCK(txq);</a>
<a name="ln1627">	}</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">static void</a>
<a name="ln1631">malo_stop(struct malo_softc *sc)</a>
<a name="ln1632">{</a>
<a name="ln1633">	struct malo_hal *mh = sc-&gt;malo_mh;</a>
<a name="ln1634">	int i;</a>
<a name="ln1635"> </a>
<a name="ln1636">	DPRINTF(sc, MALO_DEBUG_ANY, &quot;%s: invalid %u running %u\n&quot;,</a>
<a name="ln1637">	    __func__, sc-&gt;malo_invalid, sc-&gt;malo_running);</a>
<a name="ln1638"> </a>
<a name="ln1639">	MALO_LOCK_ASSERT(sc);</a>
<a name="ln1640"> </a>
<a name="ln1641">	if (!sc-&gt;malo_running)</a>
<a name="ln1642">		return;</a>
<a name="ln1643"> </a>
<a name="ln1644">	/*</a>
<a name="ln1645">	 * Shutdown the hardware and driver:</a>
<a name="ln1646">	 *    disable interrupts</a>
<a name="ln1647">	 *    turn off the radio</a>
<a name="ln1648">	 *    drain and release tx queues</a>
<a name="ln1649">	 *</a>
<a name="ln1650">	 * Note that some of this work is not possible if the hardware</a>
<a name="ln1651">	 * is gone (invalid).</a>
<a name="ln1652">	 */</a>
<a name="ln1653">	sc-&gt;malo_running = 0;</a>
<a name="ln1654">	callout_stop(&amp;sc-&gt;malo_watchdog_timer);</a>
<a name="ln1655">	sc-&gt;malo_timer = 0;</a>
<a name="ln1656">	/* disable interrupt.  */</a>
<a name="ln1657">	malo_hal_intrset(mh, 0);</a>
<a name="ln1658">	/* turn off the radio.  */</a>
<a name="ln1659">	malo_hal_setradio(mh, 0, MHP_AUTO_PREAMBLE);</a>
<a name="ln1660"> </a>
<a name="ln1661">	/* drain and release tx queues.  */</a>
<a name="ln1662">	for (i = 0; i &lt; MALO_NUM_TX_QUEUES; i++)</a>
<a name="ln1663">		malo_tx_draintxq(sc, &amp;sc-&gt;malo_txq[i]);</a>
<a name="ln1664">}</a>
<a name="ln1665"> </a>
<a name="ln1666">static void</a>
<a name="ln1667">malo_parent(struct ieee80211com *ic)</a>
<a name="ln1668">{</a>
<a name="ln1669">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1670">	int startall = 0;</a>
<a name="ln1671"> </a>
<a name="ln1672">	MALO_LOCK(sc);</a>
<a name="ln1673">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln1674">		/*</a>
<a name="ln1675">		 * Beware of being called during attach/detach</a>
<a name="ln1676">		 * to reset promiscuous mode.  In that case we</a>
<a name="ln1677">		 * will still be marked UP but not RUNNING.</a>
<a name="ln1678">		 * However trying to re-init the interface</a>
<a name="ln1679">		 * is the wrong thing to do as we've already</a>
<a name="ln1680">		 * torn down much of our state.  There's</a>
<a name="ln1681">		 * probably a better way to deal with this.</a>
<a name="ln1682">		 */</a>
<a name="ln1683">		if (!sc-&gt;malo_running &amp;&amp; !sc-&gt;malo_invalid) {</a>
<a name="ln1684">			malo_init(sc);</a>
<a name="ln1685">			startall = 1;</a>
<a name="ln1686">		}</a>
<a name="ln1687">		/*</a>
<a name="ln1688">		 * To avoid rescanning another access point,</a>
<a name="ln1689">		 * do not call malo_init() here.  Instead,</a>
<a name="ln1690">		 * only reflect promisc mode settings.</a>
<a name="ln1691">		 */</a>
<a name="ln1692">		malo_mode_init(sc);</a>
<a name="ln1693">	} else if (sc-&gt;malo_running)</a>
<a name="ln1694">		malo_stop(sc);</a>
<a name="ln1695">	MALO_UNLOCK(sc);</a>
<a name="ln1696">	if (startall)</a>
<a name="ln1697">		ieee80211_start_all(ic);</a>
<a name="ln1698">}</a>
<a name="ln1699"> </a>
<a name="ln1700">/*</a>
<a name="ln1701"> * Callback from the 802.11 layer to update the slot time</a>
<a name="ln1702"> * based on the current setting.  We use it to notify the</a>
<a name="ln1703"> * firmware of ERP changes and the f/w takes care of things</a>
<a name="ln1704"> * like slot time and preamble.</a>
<a name="ln1705"> */</a>
<a name="ln1706">static void</a>
<a name="ln1707">malo_updateslot(struct ieee80211com *ic)</a>
<a name="ln1708">{</a>
<a name="ln1709">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1710">	struct malo_hal *mh = sc-&gt;malo_mh;</a>
<a name="ln1711">	int error;</a>
<a name="ln1712">	</a>
<a name="ln1713">	/* NB: can be called early; suppress needless cmds */</a>
<a name="ln1714">	if (!sc-&gt;malo_running)</a>
<a name="ln1715">		return;</a>
<a name="ln1716"> </a>
<a name="ln1717">	DPRINTF(sc, MALO_DEBUG_RESET,</a>
<a name="ln1718">	    &quot;%s: chan %u MHz/flags 0x%x %s slot, (ic_flags 0x%x)\n&quot;,</a>
<a name="ln1719">	    __func__, ic-&gt;ic_curchan-&gt;ic_freq, ic-&gt;ic_curchan-&gt;ic_flags,</a>
<a name="ln1720">	    ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT ? &quot;short&quot; : &quot;long&quot;, ic-&gt;ic_flags);</a>
<a name="ln1721"> </a>
<a name="ln1722">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT)</a>
<a name="ln1723">		error = malo_hal_set_slot(mh, 1);</a>
<a name="ln1724">	else</a>
<a name="ln1725">		error = malo_hal_set_slot(mh, 0);</a>
<a name="ln1726"> </a>
<a name="ln1727">	if (error != 0)</a>
<a name="ln1728">		device_printf(sc-&gt;malo_dev, &quot;setting %s slot failed\n&quot;,</a>
<a name="ln1729">			ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT ? &quot;short&quot; : &quot;long&quot;);</a>
<a name="ln1730">}</a>
<a name="ln1731"> </a>
<a name="ln1732">static int</a>
<a name="ln1733">malo_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln1734">{</a>
<a name="ln1735">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1736">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1737">	struct malo_hal *mh = sc-&gt;malo_mh;</a>
<a name="ln1738">	int error;</a>
<a name="ln1739"> </a>
<a name="ln1740">	DPRINTF(sc, MALO_DEBUG_STATE, &quot;%s: %s -&gt; %s\n&quot;, __func__,</a>
<a name="ln1741">	    ieee80211_state_name[vap-&gt;iv_state],</a>
<a name="ln1742">	    ieee80211_state_name[nstate]);</a>
<a name="ln1743"> </a>
<a name="ln1744">	/*</a>
<a name="ln1745">	 * Invoke the net80211 layer first so iv_bss is setup.</a>
<a name="ln1746">	 */</a>
<a name="ln1747">	error = MALO_VAP(vap)-&gt;malo_newstate(vap, nstate, arg);</a>
<a name="ln1748">	if (error != 0)</a>
<a name="ln1749">		return error;</a>
<a name="ln1750"> </a>
<a name="ln1751">	if (nstate == IEEE80211_S_RUN &amp;&amp; vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln1752">		struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln1753">		enum ieee80211_phymode mode = ieee80211_chan2mode(ni-&gt;ni_chan);</a>
<a name="ln1754">		const struct ieee80211_txparam *tp = &amp;vap-&gt;iv_txparms[mode];</a>
<a name="ln1755"> </a>
<a name="ln1756">		DPRINTF(sc, MALO_DEBUG_STATE,</a>
<a name="ln1757">		    &quot;%s: %s(RUN): iv_flags 0x%08x bintvl %d bssid %s &quot;</a>
<a name="ln1758">		    &quot;capinfo 0x%04x chan %d associd 0x%x mode %d rate %d\n&quot;,</a>
<a name="ln1759">		    vap-&gt;iv_ifp-&gt;if_xname, __func__, vap-&gt;iv_flags,</a>
<a name="ln1760">		    ni-&gt;ni_intval, ether_sprintf(ni-&gt;ni_bssid), ni-&gt;ni_capinfo,</a>
<a name="ln1761">		    ieee80211_chan2ieee(ic, ic-&gt;ic_curchan),</a>
<a name="ln1762">		    ni-&gt;ni_associd, mode, tp-&gt;ucastrate);</a>
<a name="ln1763"> </a>
<a name="ln1764">		malo_hal_setradio(mh, 1,</a>
<a name="ln1765">		    (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE) ?</a>
<a name="ln1766">			MHP_SHORT_PREAMBLE : MHP_LONG_PREAMBLE);</a>
<a name="ln1767">		malo_hal_setassocid(sc-&gt;malo_mh, ni-&gt;ni_bssid, ni-&gt;ni_associd);</a>
<a name="ln1768">		malo_hal_set_rate(mh, mode, </a>
<a name="ln1769">		   tp-&gt;ucastrate == IEEE80211_FIXED_RATE_NONE ?</a>
<a name="ln1770">		       0 : malo_fix2rate(tp-&gt;ucastrate));</a>
<a name="ln1771">	}</a>
<a name="ln1772">	return 0;</a>
<a name="ln1773">}</a>
<a name="ln1774"> </a>
<a name="ln1775">static int</a>
<a name="ln1776">malo_raw_xmit(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln1777">	const struct ieee80211_bpf_params *params)</a>
<a name="ln1778">{</a>
<a name="ln1779">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln1780">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1781">	struct malo_txbuf *bf;</a>
<a name="ln1782">	struct malo_txq *txq;</a>
<a name="ln1783"> </a>
<a name="ln1784">	if (!sc-&gt;malo_running || sc-&gt;malo_invalid) {</a>
<a name="ln1785">		m_freem(m);</a>
<a name="ln1786">		return ENETDOWN;</a>
<a name="ln1787">	}</a>
<a name="ln1788"> </a>
<a name="ln1789">	/*</a>
<a name="ln1790">	 * Grab a TX buffer and associated resources.  Note that we depend</a>
<a name="ln1791">	 * on the classification by the 802.11 layer to get to the right h/w</a>
<a name="ln1792">	 * queue.  Management frames must ALWAYS go on queue 1 but we</a>
<a name="ln1793">	 * cannot just force that here because we may receive non-mgt frames.</a>
<a name="ln1794">	 */</a>
<a name="ln1795">	txq = &amp;sc-&gt;malo_txq[0];</a>
<a name="ln1796">	bf = malo_getbuf(sc, txq);</a>
<a name="ln1797">	if (bf == NULL) {</a>
<a name="ln1798">		m_freem(m);</a>
<a name="ln1799">		return ENOBUFS;</a>
<a name="ln1800">	}</a>
<a name="ln1801"> </a>
<a name="ln1802">	/*</a>
<a name="ln1803">	 * Pass the frame to the h/w for transmission.</a>
<a name="ln1804">	 */</a>
<a name="ln1805">	if (malo_tx_start(sc, ni, bf, m) != 0) {</a>
<a name="ln1806">		bf-&gt;bf_m = NULL;</a>
<a name="ln1807">		bf-&gt;bf_node = NULL;</a>
<a name="ln1808">		MALO_TXQ_LOCK(txq);</a>
<a name="ln1809">		STAILQ_INSERT_HEAD(&amp;txq-&gt;free, bf, bf_list);</a>
<a name="ln1810">		txq-&gt;nfree++;</a>
<a name="ln1811">		MALO_TXQ_UNLOCK(txq);</a>
<a name="ln1812"> </a>
<a name="ln1813">		return EIO;		/* XXX */</a>
<a name="ln1814">	}</a>
<a name="ln1815"> </a>
<a name="ln1816">	/*</a>
<a name="ln1817">	 * NB: We don't need to lock against tx done because this just</a>
<a name="ln1818">	 * prods the firmware to check the transmit descriptors.  The firmware</a>
<a name="ln1819">	 * will also start fetching descriptors by itself if it notices</a>
<a name="ln1820">	 * new ones are present when it goes to deliver a tx done interrupt</a>
<a name="ln1821">	 * to the host. So if we race with tx done processing it's ok.</a>
<a name="ln1822">	 * Delivering the kick here rather than in malo_tx_start is</a>
<a name="ln1823">	 * an optimization to avoid poking the firmware for each packet.</a>
<a name="ln1824">	 *</a>
<a name="ln1825">	 * NB: the queue id isn't used so 0 is ok.</a>
<a name="ln1826">	 */</a>
<a name="ln1827">	malo_hal_txstart(sc-&gt;malo_mh, 0/*XXX*/);</a>
<a name="ln1828"> </a>
<a name="ln1829">	return 0;</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832">static void</a>
<a name="ln1833">malo_sysctlattach(struct malo_softc *sc)</a>
<a name="ln1834">{</a>
<a name="ln1835">#ifdef	MALO_DEBUG</a>
<a name="ln1836">	struct sysctl_ctx_list *ctx = device_get_sysctl_ctx(sc-&gt;malo_dev);</a>
<a name="ln1837">	struct sysctl_oid *tree = device_get_sysctl_tree(sc-&gt;malo_dev);</a>
<a name="ln1838"> </a>
<a name="ln1839">	sc-&gt;malo_debug = malo_debug;</a>
<a name="ln1840">	SYSCTL_ADD_INT(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln1841">		&quot;debug&quot;, CTLFLAG_RW, &amp;sc-&gt;malo_debug, 0,</a>
<a name="ln1842">		&quot;control debugging printfs&quot;);</a>
<a name="ln1843">#endif</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846">static void</a>
<a name="ln1847">malo_announce(struct malo_softc *sc)</a>
<a name="ln1848">{</a>
<a name="ln1849"> </a>
<a name="ln1850">	device_printf(sc-&gt;malo_dev,</a>
<a name="ln1851">		&quot;versions [hw %d fw %d.%d.%d.%d] (regioncode %d)\n&quot;,</a>
<a name="ln1852">		sc-&gt;malo_hwspecs.hwversion,</a>
<a name="ln1853">		(sc-&gt;malo_hwspecs.fw_releasenum &gt;&gt; 24) &amp; 0xff,</a>
<a name="ln1854">		(sc-&gt;malo_hwspecs.fw_releasenum &gt;&gt; 16) &amp; 0xff,</a>
<a name="ln1855">		(sc-&gt;malo_hwspecs.fw_releasenum &gt;&gt; 8) &amp; 0xff,</a>
<a name="ln1856">		(sc-&gt;malo_hwspecs.fw_releasenum &gt;&gt; 0) &amp; 0xff,</a>
<a name="ln1857">		sc-&gt;malo_hwspecs.regioncode);</a>
<a name="ln1858"> </a>
<a name="ln1859">	if (bootverbose || malo_rxbuf != MALO_RXBUF)</a>
<a name="ln1860">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln1861">		    &quot;using %u rx buffers\n&quot;, malo_rxbuf);</a>
<a name="ln1862">	if (bootverbose || malo_txbuf != MALO_TXBUF)</a>
<a name="ln1863">		device_printf(sc-&gt;malo_dev,</a>
<a name="ln1864">		    &quot;using %u tx buffers\n&quot;, malo_txbuf);</a>
<a name="ln1865">}</a>
<a name="ln1866"> </a>
<a name="ln1867">/*</a>
<a name="ln1868"> * Convert net80211 channel to a HAL channel.</a>
<a name="ln1869"> */</a>
<a name="ln1870">static void</a>
<a name="ln1871">malo_mapchan(struct malo_hal_channel *hc, const struct ieee80211_channel *chan)</a>
<a name="ln1872">{</a>
<a name="ln1873">	hc-&gt;channel = chan-&gt;ic_ieee;</a>
<a name="ln1874"> </a>
<a name="ln1875">	*(uint32_t *)&amp;hc-&gt;flags = 0;</a>
<a name="ln1876">	if (IEEE80211_IS_CHAN_2GHZ(chan))</a>
<a name="ln1877">		hc-&gt;flags.freqband = MALO_FREQ_BAND_2DOT4GHZ;</a>
<a name="ln1878">}</a>
<a name="ln1879"> </a>
<a name="ln1880">/*</a>
<a name="ln1881"> * Set/change channels.  If the channel is really being changed,</a>
<a name="ln1882"> * it's done by reseting the chip.  To accomplish this we must</a>
<a name="ln1883"> * first cleanup any pending DMA, then restart stuff after a la</a>
<a name="ln1884"> * malo_init.</a>
<a name="ln1885"> */</a>
<a name="ln1886">static int</a>
<a name="ln1887">malo_chan_set(struct malo_softc *sc, struct ieee80211_channel *chan)</a>
<a name="ln1888">{</a>
<a name="ln1889">	struct malo_hal *mh = sc-&gt;malo_mh;</a>
<a name="ln1890">	struct malo_hal_channel hchan;</a>
<a name="ln1891"> </a>
<a name="ln1892">	DPRINTF(sc, MALO_DEBUG_RESET, &quot;%s: chan %u MHz/flags 0x%x\n&quot;,</a>
<a name="ln1893">	    __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln1894"> </a>
<a name="ln1895">	/*</a>
<a name="ln1896">	 * Convert to a HAL channel description with the flags constrained</a>
<a name="ln1897">	 * to reflect the current operating mode.</a>
<a name="ln1898">	 */</a>
<a name="ln1899">	malo_mapchan(&amp;hchan, chan);</a>
<a name="ln1900">	malo_hal_intrset(mh, 0);		/* disable interrupts */</a>
<a name="ln1901">	malo_hal_setchannel(mh, &amp;hchan);</a>
<a name="ln1902">	malo_hal_settxpower(mh, &amp;hchan);</a>
<a name="ln1903"> </a>
<a name="ln1904">	/*</a>
<a name="ln1905">	 * Update internal state.</a>
<a name="ln1906">	 */</a>
<a name="ln1907">	sc-&gt;malo_tx_th.wt_chan_freq = htole16(chan-&gt;ic_freq);</a>
<a name="ln1908">	sc-&gt;malo_rx_th.wr_chan_freq = htole16(chan-&gt;ic_freq);</a>
<a name="ln1909">	if (IEEE80211_IS_CHAN_ANYG(chan)) {</a>
<a name="ln1910">		sc-&gt;malo_tx_th.wt_chan_flags = htole16(IEEE80211_CHAN_G);</a>
<a name="ln1911">		sc-&gt;malo_rx_th.wr_chan_flags = htole16(IEEE80211_CHAN_G);</a>
<a name="ln1912">	} else {</a>
<a name="ln1913">		sc-&gt;malo_tx_th.wt_chan_flags = htole16(IEEE80211_CHAN_B);</a>
<a name="ln1914">		sc-&gt;malo_rx_th.wr_chan_flags = htole16(IEEE80211_CHAN_B);</a>
<a name="ln1915">	}</a>
<a name="ln1916">	sc-&gt;malo_curchan = hchan;</a>
<a name="ln1917">	malo_hal_intrset(mh, sc-&gt;malo_imask);</a>
<a name="ln1918"> </a>
<a name="ln1919">	return 0;</a>
<a name="ln1920">}</a>
<a name="ln1921"> </a>
<a name="ln1922">static void</a>
<a name="ln1923">malo_scan_start(struct ieee80211com *ic)</a>
<a name="ln1924">{</a>
<a name="ln1925">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1926"> </a>
<a name="ln1927">	DPRINTF(sc, MALO_DEBUG_STATE, &quot;%s\n&quot;, __func__);</a>
<a name="ln1928">}</a>
<a name="ln1929"> </a>
<a name="ln1930">static void</a>
<a name="ln1931">malo_scan_end(struct ieee80211com *ic)</a>
<a name="ln1932">{</a>
<a name="ln1933">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1934"> </a>
<a name="ln1935">	DPRINTF(sc, MALO_DEBUG_STATE, &quot;%s\n&quot;, __func__);</a>
<a name="ln1936">}</a>
<a name="ln1937"> </a>
<a name="ln1938">static void</a>
<a name="ln1939">malo_set_channel(struct ieee80211com *ic)</a>
<a name="ln1940">{</a>
<a name="ln1941">	struct malo_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1942"> </a>
<a name="ln1943">	(void) malo_chan_set(sc, ic-&gt;ic_curchan);</a>
<a name="ln1944">}</a>
<a name="ln1945"> </a>
<a name="ln1946">static void</a>
<a name="ln1947">malo_rx_proc(void *arg, int npending)</a>
<a name="ln1948">{</a>
<a name="ln1949">	struct malo_softc *sc = arg;</a>
<a name="ln1950">	struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln1951">	struct malo_rxbuf *bf;</a>
<a name="ln1952">	struct malo_rxdesc *ds;</a>
<a name="ln1953">	struct mbuf *m, *mnew;</a>
<a name="ln1954">	struct ieee80211_qosframe *wh;</a>
<a name="ln1955">	struct ieee80211_qosframe_addr4 *wh4;</a>
<a name="ln1956">	struct ieee80211_node *ni;</a>
<a name="ln1957">	int off, len, hdrlen, pktlen, rssi, ntodo;</a>
<a name="ln1958">	uint8_t *data, status;</a>
<a name="ln1959">	uint32_t readptr, writeptr;</a>
<a name="ln1960"> </a>
<a name="ln1961">	DPRINTF(sc, MALO_DEBUG_RX_PROC,</a>
<a name="ln1962">	    &quot;%s: pending %u rdptr(0x%x) 0x%x wrptr(0x%x) 0x%x\n&quot;,</a>
<a name="ln1963">	    __func__, npending,</a>
<a name="ln1964">	    sc-&gt;malo_hwspecs.rxdesc_read,</a>
<a name="ln1965">	    malo_bar0_read4(sc, sc-&gt;malo_hwspecs.rxdesc_read),</a>
<a name="ln1966">	    sc-&gt;malo_hwspecs.rxdesc_write,</a>
<a name="ln1967">	    malo_bar0_read4(sc, sc-&gt;malo_hwspecs.rxdesc_write));</a>
<a name="ln1968"> </a>
<a name="ln1969">	readptr = malo_bar0_read4(sc, sc-&gt;malo_hwspecs.rxdesc_read);</a>
<a name="ln1970">	writeptr = malo_bar0_read4(sc, sc-&gt;malo_hwspecs.rxdesc_write);</a>
<a name="ln1971">	if (readptr == writeptr)</a>
<a name="ln1972">		return;</a>
<a name="ln1973"> </a>
<a name="ln1974">	bf = sc-&gt;malo_rxnext;</a>
<a name="ln1975">	for (ntodo = malo_rxquota; ntodo &gt; 0 &amp;&amp; readptr != writeptr; ntodo--) {</a>
<a name="ln1976">		if (bf == NULL) {</a>
<a name="ln1977">			bf = STAILQ_FIRST(&amp;sc-&gt;malo_rxbuf);</a>
<a name="ln1978">			break;</a>
<a name="ln1979">		}</a>
<a name="ln1980">		ds = bf-&gt;bf_desc;</a>
<a name="ln1981">		if (bf-&gt;bf_m == NULL) {</a>
<a name="ln1982">			/*</a>
<a name="ln1983">			 * If data allocation failed previously there</a>
<a name="ln1984">			 * will be no buffer; try again to re-populate it.</a>
<a name="ln1985">			 * Note the firmware will not advance to the next</a>
<a name="ln1986">			 * descriptor with a dma buffer so we must mimic</a>
<a name="ln1987">			 * this or we'll get out of sync.</a>
<a name="ln1988">			 */ </a>
<a name="ln1989">			DPRINTF(sc, MALO_DEBUG_ANY,</a>
<a name="ln1990">			    &quot;%s: rx buf w/o dma memory\n&quot;, __func__);</a>
<a name="ln1991">			(void)malo_rxbuf_init(sc, bf);</a>
<a name="ln1992">			break;</a>
<a name="ln1993">		}</a>
<a name="ln1994">		MALO_RXDESC_SYNC(sc, ds,</a>
<a name="ln1995">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1996">		if (ds-&gt;rxcontrol != MALO_RXD_CTRL_DMA_OWN)</a>
<a name="ln1997">			break;</a>
<a name="ln1998"> </a>
<a name="ln1999">		readptr = le32toh(ds-&gt;physnext);</a>
<a name="ln2000"> </a>
<a name="ln2001">#ifdef MALO_DEBUG</a>
<a name="ln2002">		if (sc-&gt;malo_debug &amp; MALO_DEBUG_RECV_DESC)</a>
<a name="ln2003">			malo_printrxbuf(bf, 0);</a>
<a name="ln2004">#endif</a>
<a name="ln2005">		status = ds-&gt;status;</a>
<a name="ln2006">		if (status &amp; MALO_RXD_STATUS_DECRYPT_ERR_MASK) {</a>
<a name="ln2007">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln2008">			goto rx_next;</a>
<a name="ln2009">		}</a>
<a name="ln2010">		/*</a>
<a name="ln2011">		 * Sync the data buffer.</a>
<a name="ln2012">		 */</a>
<a name="ln2013">		len = le16toh(ds-&gt;pktlen);</a>
<a name="ln2014">		bus_dmamap_sync(sc-&gt;malo_dmat, bf-&gt;bf_dmamap,</a>
<a name="ln2015">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln2016">		/*</a>
<a name="ln2017">		 * The 802.11 header is provided all or in part at the front;</a>
<a name="ln2018">		 * use it to calculate the true size of the header that we'll</a>
<a name="ln2019">		 * construct below.  We use this to figure out where to copy</a>
<a name="ln2020">		 * payload prior to constructing the header.</a>
<a name="ln2021">		 */</a>
<a name="ln2022">		m = bf-&gt;bf_m;</a>
<a name="ln2023">		data = mtod(m, uint8_t *);</a>
<a name="ln2024">		hdrlen = ieee80211_anyhdrsize(data + sizeof(uint16_t));</a>
<a name="ln2025">		off = sizeof(uint16_t) + sizeof(struct ieee80211_frame_addr4);</a>
<a name="ln2026"> </a>
<a name="ln2027">		/*</a>
<a name="ln2028">		 * Calculate RSSI. XXX wrong</a>
<a name="ln2029">		 */</a>
<a name="ln2030">		rssi = 2 * ((int) ds-&gt;snr - ds-&gt;nf);	/* NB: .5 dBm  */</a>
<a name="ln2031">		if (rssi &gt; 100)</a>
<a name="ln2032">			rssi = 100;</a>
<a name="ln2033"> </a>
<a name="ln2034">		pktlen = hdrlen + (len - off);</a>
<a name="ln2035">		/*</a>
<a name="ln2036">		 * NB: we know our frame is at least as large as</a>
<a name="ln2037">		 * IEEE80211_MIN_LEN because there is a 4-address frame at</a>
<a name="ln2038">		 * the front.  Hence there's no need to vet the packet length.</a>
<a name="ln2039">		 * If the frame in fact is too small it should be discarded</a>
<a name="ln2040">		 * at the net80211 layer.</a>
<a name="ln2041">		 */</a>
<a name="ln2042"> </a>
<a name="ln2043">		/* XXX don't need mbuf, just dma buffer */</a>
<a name="ln2044">		mnew = malo_getrxmbuf(sc, bf);</a>
<a name="ln2045">		if (mnew == NULL) {</a>
<a name="ln2046">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln2047">			goto rx_next;</a>
<a name="ln2048">		}</a>
<a name="ln2049">		/*</a>
<a name="ln2050">		 * Attach the dma buffer to the mbuf; malo_rxbuf_init will</a>
<a name="ln2051">		 * re-setup the rx descriptor using the replacement dma</a>
<a name="ln2052">		 * buffer we just installed above.</a>
<a name="ln2053">		 */</a>
<a name="ln2054">		bf-&gt;bf_m = mnew;</a>
<a name="ln2055">		m-&gt;m_data += off - hdrlen;</a>
<a name="ln2056">		m-&gt;m_pkthdr.len = m-&gt;m_len = pktlen;</a>
<a name="ln2057"> </a>
<a name="ln2058">		/*</a>
<a name="ln2059">		 * Piece 802.11 header together.</a>
<a name="ln2060">		 */</a>
<a name="ln2061">		wh = mtod(m, struct ieee80211_qosframe *);</a>
<a name="ln2062">		/* NB: don't need to do this sometimes but ... */</a>
<a name="ln2063">		/* XXX special case so we can memcpy after m_devget? */</a>
<a name="ln2064">		ovbcopy(data + sizeof(uint16_t), wh, hdrlen);</a>
<a name="ln2065">		if (IEEE80211_QOS_HAS_SEQ(wh)) {</a>
<a name="ln2066">			if (IEEE80211_IS_DSTODS(wh)) {</a>
<a name="ln2067">				wh4 = mtod(m,</a>
<a name="ln2068">				    struct ieee80211_qosframe_addr4*);</a>
<a name="ln2069">				*(uint16_t *)wh4-&gt;i_qos = ds-&gt;qosctrl;</a>
<a name="ln2070">			} else {</a>
<a name="ln2071">				*(uint16_t *)wh-&gt;i_qos = ds-&gt;qosctrl;</a>
<a name="ln2072">			}</a>
<a name="ln2073">		}</a>
<a name="ln2074">		if (ieee80211_radiotap_active(ic)) {</a>
<a name="ln2075">			sc-&gt;malo_rx_th.wr_flags = 0;</a>
<a name="ln2076">			sc-&gt;malo_rx_th.wr_rate = ds-&gt;rate;</a>
<a name="ln2077">			sc-&gt;malo_rx_th.wr_antsignal = rssi;</a>
<a name="ln2078">			sc-&gt;malo_rx_th.wr_antnoise = ds-&gt;nf;</a>
<a name="ln2079">		}</a>
<a name="ln2080">#ifdef MALO_DEBUG</a>
<a name="ln2081">		if (IFF_DUMPPKTS_RECV(sc, wh)) {</a>
<a name="ln2082">			ieee80211_dump_pkt(ic, mtod(m, caddr_t),</a>
<a name="ln2083">			    len, ds-&gt;rate, rssi);</a>
<a name="ln2084">		}</a>
<a name="ln2085">#endif</a>
<a name="ln2086">		/* dispatch */</a>
<a name="ln2087">		ni = ieee80211_find_rxnode(ic,</a>
<a name="ln2088">		    (struct ieee80211_frame_min *)wh);</a>
<a name="ln2089">		if (ni != NULL) {</a>
<a name="ln2090">			(void) ieee80211_input(ni, m, rssi, ds-&gt;nf);</a>
<a name="ln2091">			ieee80211_free_node(ni);</a>
<a name="ln2092">		} else</a>
<a name="ln2093">			(void) ieee80211_input_all(ic, m, rssi, ds-&gt;nf);</a>
<a name="ln2094">rx_next:</a>
<a name="ln2095">		/* NB: ignore ENOMEM so we process more descriptors */</a>
<a name="ln2096">		(void) malo_rxbuf_init(sc, bf);</a>
<a name="ln2097">		bf = STAILQ_NEXT(bf, bf_list);</a>
<a name="ln2098">	}</a>
<a name="ln2099">	</a>
<a name="ln2100">	malo_bar0_write4(sc, sc-&gt;malo_hwspecs.rxdesc_read, readptr);</a>
<a name="ln2101">	sc-&gt;malo_rxnext = bf;</a>
<a name="ln2102"> </a>
<a name="ln2103">	if (mbufq_first(&amp;sc-&gt;malo_snd) != NULL)</a>
<a name="ln2104">		malo_start(sc);</a>
<a name="ln2105">}</a>
<a name="ln2106"> </a>
<a name="ln2107">/*</a>
<a name="ln2108"> * Reclaim all tx queue resources.</a>
<a name="ln2109"> */</a>
<a name="ln2110">static void</a>
<a name="ln2111">malo_tx_cleanup(struct malo_softc *sc)</a>
<a name="ln2112">{</a>
<a name="ln2113">	int i;</a>
<a name="ln2114"> </a>
<a name="ln2115">	for (i = 0; i &lt; MALO_NUM_TX_QUEUES; i++)</a>
<a name="ln2116">		malo_tx_cleanupq(sc, &amp;sc-&gt;malo_txq[i]);</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119">int</a>
<a name="ln2120">malo_detach(struct malo_softc *sc)</a>
<a name="ln2121">{</a>
<a name="ln2122">	struct ieee80211com *ic = &amp;sc-&gt;malo_ic;</a>
<a name="ln2123"> </a>
<a name="ln2124">	malo_stop(sc);</a>
<a name="ln2125"> </a>
<a name="ln2126">	if (sc-&gt;malo_tq != NULL) {</a>
<a name="ln2127">		taskqueue_drain(sc-&gt;malo_tq, &amp;sc-&gt;malo_rxtask);</a>
<a name="ln2128">		taskqueue_drain(sc-&gt;malo_tq, &amp;sc-&gt;malo_txtask);</a>
<a name="ln2129">		taskqueue_free(sc-&gt;malo_tq);</a>
<a name="ln2130">		sc-&gt;malo_tq = NULL;</a>
<a name="ln2131">	}</a>
<a name="ln2132"> </a>
<a name="ln2133">	/*</a>
<a name="ln2134">	 * NB: the order of these is important:</a>
<a name="ln2135">	 * o call the 802.11 layer before detaching the hal to</a>
<a name="ln2136">	 *   insure callbacks into the driver to delete global</a>
<a name="ln2137">	 *   key cache entries can be handled</a>
<a name="ln2138">	 * o reclaim the tx queue data structures after calling</a>
<a name="ln2139">	 *   the 802.11 layer as we'll get called back to reclaim</a>
<a name="ln2140">	 *   node state and potentially want to use them</a>
<a name="ln2141">	 * o to cleanup the tx queues the hal is called, so detach</a>
<a name="ln2142">	 *   it last</a>
<a name="ln2143">	 * Other than that, it's straightforward...</a>
<a name="ln2144">	 */</a>
<a name="ln2145">	ieee80211_ifdetach(ic);</a>
<a name="ln2146">	callout_drain(&amp;sc-&gt;malo_watchdog_timer);</a>
<a name="ln2147">	malo_dma_cleanup(sc);</a>
<a name="ln2148">	malo_tx_cleanup(sc);</a>
<a name="ln2149">	malo_hal_detach(sc-&gt;malo_mh);</a>
<a name="ln2150">	mbufq_drain(&amp;sc-&gt;malo_snd);</a>
<a name="ln2151">	MALO_LOCK_DESTROY(sc);</a>
<a name="ln2152"> </a>
<a name="ln2153">	return 0;</a>
<a name="ln2154">}</a>
<a name="ln2155"> </a>
<a name="ln2156">void</a>
<a name="ln2157">malo_shutdown(struct malo_softc *sc)</a>
<a name="ln2158">{</a>
<a name="ln2159"> </a>
<a name="ln2160">	malo_stop(sc);</a>
<a name="ln2161">}</a>
<a name="ln2162"> </a>
<a name="ln2163">void</a>
<a name="ln2164">malo_suspend(struct malo_softc *sc)</a>
<a name="ln2165">{</a>
<a name="ln2166"> </a>
<a name="ln2167">	malo_stop(sc);</a>
<a name="ln2168">}</a>
<a name="ln2169"> </a>
<a name="ln2170">void</a>
<a name="ln2171">malo_resume(struct malo_softc *sc)</a>
<a name="ln2172">{</a>
<a name="ln2173"> </a>
<a name="ln2174">	if (sc-&gt;malo_ic.ic_nrunning &gt; 0)</a>
<a name="ln2175">		malo_init(sc);</a>
<a name="ln2176">}</a>

</code></pre>
<div class="balloon" rel="341"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'opmode == IEEE80211_M_STA' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
