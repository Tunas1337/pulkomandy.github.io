
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DwarfTypeFactory.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2012, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2013, Rene Gollent, rene@gollent.com.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;DwarfTypeFactory.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;new&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;AutoLocker.h&gt;</a>
<a name="ln14">#include &lt;Variant.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;ArrayIndexPath.h&quot;</a>
<a name="ln17">#include &quot;Architecture.h&quot;</a>
<a name="ln18">#include &quot;CompilationUnit.h&quot;</a>
<a name="ln19">#include &quot;DebugInfoEntries.h&quot;</a>
<a name="ln20">#include &quot;Dwarf.h&quot;</a>
<a name="ln21">#include &quot;DwarfFile.h&quot;</a>
<a name="ln22">#include &quot;DwarfTargetInterface.h&quot;</a>
<a name="ln23">#include &quot;DwarfUtils.h&quot;</a>
<a name="ln24">#include &quot;DwarfTypes.h&quot;</a>
<a name="ln25">#include &quot;GlobalTypeLookup.h&quot;</a>
<a name="ln26">#include &quot;Register.h&quot;</a>
<a name="ln27">#include &quot;RegisterMap.h&quot;</a>
<a name="ln28">#include &quot;SourceLanguageInfo.h&quot;</a>
<a name="ln29">#include &quot;StringUtils.h&quot;</a>
<a name="ln30">#include &quot;Tracing.h&quot;</a>
<a name="ln31">#include &quot;TypeLookupConstraints.h&quot;</a>
<a name="ln32">#include &quot;ValueLocation.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">namespace {</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">// #pragma mark - HasTypePredicate</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">template&lt;typename EntryType&gt;</a>
<a name="ln42">struct HasTypePredicate {</a>
<a name="ln43">	inline bool operator()(EntryType* entry) const</a>
<a name="ln44">	{</a>
<a name="ln45">		return entry-&gt;GetType() != NULL;</a>
<a name="ln46">	}</a>
<a name="ln47">};</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">// #pragma mark - HasReturnTypePredicate</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">template&lt;typename EntryType&gt;</a>
<a name="ln54">struct HasReturnTypePredicate {</a>
<a name="ln55">	inline bool operator()(EntryType* entry) const</a>
<a name="ln56">	{</a>
<a name="ln57">		return entry-&gt;ReturnType() != NULL;</a>
<a name="ln58">	}</a>
<a name="ln59">};</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">// #pragma mark - HasEnumeratorsPredicate</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">struct HasEnumeratorsPredicate {</a>
<a name="ln66">	inline bool operator()(DIEEnumerationType* entry) const</a>
<a name="ln67">	{</a>
<a name="ln68">		return !entry-&gt;Enumerators().IsEmpty();</a>
<a name="ln69">	}</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">// #pragma mark - HasDimensionsPredicate</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">struct HasDimensionsPredicate {</a>
<a name="ln77">	inline bool operator()(DIEArrayType* entry) const</a>
<a name="ln78">	{</a>
<a name="ln79">		return !entry-&gt;Dimensions().IsEmpty();</a>
<a name="ln80">	}</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">// #pragma mark - HasMembersPredicate</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">struct HasMembersPredicate {</a>
<a name="ln88">	inline bool operator()(DIECompoundType* entry) const</a>
<a name="ln89">	{</a>
<a name="ln90">		return !entry-&gt;DataMembers().IsEmpty();</a>
<a name="ln91">	}</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">// #pragma mark - HasBaseTypesPredicate</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">struct HasBaseTypesPredicate {</a>
<a name="ln99">	inline bool operator()(DIEClassBaseType* entry) const</a>
<a name="ln100">	{</a>
<a name="ln101">		return !entry-&gt;BaseTypes().IsEmpty();</a>
<a name="ln102">	}</a>
<a name="ln103">};</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">// #pragma mark - HasTemplateParametersPredicate</a>
<a name="ln107"> </a>
<a name="ln108"> </a>
<a name="ln109">struct HasTemplateParametersPredicate {</a>
<a name="ln110">	inline bool operator()(DIEClassBaseType* entry) const</a>
<a name="ln111">	{</a>
<a name="ln112">		return !entry-&gt;TemplateParameters().IsEmpty();</a>
<a name="ln113">	}</a>
<a name="ln114">};</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">// #pragma mark - HasParametersPredicate</a>
<a name="ln118"> </a>
<a name="ln119"> </a>
<a name="ln120">template&lt;typename EntryType&gt;</a>
<a name="ln121">struct HasParametersPredicate {</a>
<a name="ln122">	inline bool operator()(EntryType* entry) const</a>
<a name="ln123">	{</a>
<a name="ln124">		return !entry-&gt;Parameters().IsEmpty();</a>
<a name="ln125">	}</a>
<a name="ln126">};</a>
<a name="ln127"> </a>
<a name="ln128"> </a>
<a name="ln129">// #pragma mark - HasLowerBoundPredicate</a>
<a name="ln130"> </a>
<a name="ln131"> </a>
<a name="ln132">struct HasLowerBoundPredicate {</a>
<a name="ln133">	inline bool operator()(DIESubrangeType* entry) const</a>
<a name="ln134">	{</a>
<a name="ln135">		return entry-&gt;LowerBound()-&gt;IsValid();</a>
<a name="ln136">	}</a>
<a name="ln137">};</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">// #pragma mark - HasUpperBoundPredicate</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">struct HasUpperBoundPredicate {</a>
<a name="ln144">	inline bool operator()(DIESubrangeType* entry) const</a>
<a name="ln145">	{</a>
<a name="ln146">		return entry-&gt;UpperBound()-&gt;IsValid();</a>
<a name="ln147">	}</a>
<a name="ln148">};</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">// #pragma mark - HasCountPredicate</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">struct HasCountPredicate {</a>
<a name="ln155">	inline bool operator()(DIESubrangeType* entry) const</a>
<a name="ln156">	{</a>
<a name="ln157">		return entry-&gt;Count()-&gt;IsValid();</a>
<a name="ln158">	}</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">// #pragma mark - HasContainingTypePredicate</a>
<a name="ln163"> </a>
<a name="ln164"> </a>
<a name="ln165">struct HasContainingTypePredicate {</a>
<a name="ln166">	inline bool operator()(DIEPointerToMemberType* entry) const</a>
<a name="ln167">	{</a>
<a name="ln168">		return entry-&gt;ContainingType() != NULL;</a>
<a name="ln169">	}</a>
<a name="ln170">};</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">}	// unnamed namespace</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">// #pragma mark - ArtificialIntegerType</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">class DwarfTypeFactory::ArtificialIntegerType : public PrimitiveType {</a>
<a name="ln180">public:</a>
<a name="ln181">	ArtificialIntegerType(const BString&amp; id, const BString&amp; name,</a>
<a name="ln182">		target_size_t byteSize, uint32 typeConstant)</a>
<a name="ln183">		:</a>
<a name="ln184">		fID(id),</a>
<a name="ln185">		fName(name),</a>
<a name="ln186">		fByteSize(byteSize),</a>
<a name="ln187">		fTypeConstant(typeConstant)</a>
<a name="ln188">	{</a>
<a name="ln189">	}</a>
<a name="ln190"> </a>
<a name="ln191">	static status_t Create(target_size_t byteSize, bool isSigned, Type*&amp; _type)</a>
<a name="ln192">	{</a>
<a name="ln193">		// get the matching type constant</a>
<a name="ln194">		uint32 typeConstant;</a>
<a name="ln195">		switch (byteSize) {</a>
<a name="ln196">			case 1:</a>
<a name="ln197">				typeConstant = isSigned ? B_INT8_TYPE : B_UINT8_TYPE;</a>
<a name="ln198">				break;</a>
<a name="ln199">			case 2:</a>
<a name="ln200">				typeConstant = isSigned ? B_INT16_TYPE : B_UINT16_TYPE;</a>
<a name="ln201">				break;</a>
<a name="ln202">			case 4:</a>
<a name="ln203">				typeConstant = isSigned ? B_INT32_TYPE : B_UINT32_TYPE;</a>
<a name="ln204">				break;</a>
<a name="ln205">			case 8:</a>
<a name="ln206">				typeConstant = isSigned ? B_INT64_TYPE : B_UINT64_TYPE;</a>
<a name="ln207">				break;</a>
<a name="ln208">			default:</a>
<a name="ln209">				return B_BAD_VALUE;</a>
<a name="ln210">		}</a>
<a name="ln211"> </a>
<a name="ln212">		// name and ID</a>
<a name="ln213">		char buffer[16];</a>
<a name="ln214">		snprintf(buffer, sizeof(buffer), isSigned ? &quot;int%d&quot; : &quot;uint%d&quot;,</a>
<a name="ln215">			(int)byteSize * 8);</a>
<a name="ln216">		BString id(buffer);</a>
<a name="ln217">		if (id.Length() == 0)</a>
<a name="ln218">			return B_NO_MEMORY;</a>
<a name="ln219"> </a>
<a name="ln220">		// create the type</a>
<a name="ln221">		ArtificialIntegerType* type = new(std::nothrow) ArtificialIntegerType(</a>
<a name="ln222">			id, id, byteSize, typeConstant);</a>
<a name="ln223">		if (type == NULL)</a>
<a name="ln224">			return B_NO_MEMORY;</a>
<a name="ln225"> </a>
<a name="ln226">		_type = type;</a>
<a name="ln227">		return B_OK;</a>
<a name="ln228">	}</a>
<a name="ln229"> </a>
<a name="ln230">	virtual image_id ImageID() const</a>
<a name="ln231">	{</a>
<a name="ln232">		return -1;</a>
<a name="ln233">	}</a>
<a name="ln234"> </a>
<a name="ln235">	virtual const BString&amp; ID() const</a>
<a name="ln236">	{</a>
<a name="ln237">		return fID;</a>
<a name="ln238">	}</a>
<a name="ln239"> </a>
<a name="ln240">	virtual const BString&amp; Name() const</a>
<a name="ln241">	{</a>
<a name="ln242">		return fName;</a>
<a name="ln243">	}</a>
<a name="ln244"> </a>
<a name="ln245">	virtual target_size_t ByteSize() const</a>
<a name="ln246">	{</a>
<a name="ln247">		return fByteSize;</a>
<a name="ln248">	}</a>
<a name="ln249"> </a>
<a name="ln250">	virtual status_t ResolveObjectDataLocation(</a>
<a name="ln251">		const ValueLocation&amp; objectLocation, ValueLocation*&amp; _location)</a>
<a name="ln252">	{</a>
<a name="ln253">		// TODO: Implement!</a>
<a name="ln254">		return B_UNSUPPORTED;</a>
<a name="ln255">	}</a>
<a name="ln256"> </a>
<a name="ln257">	virtual status_t ResolveObjectDataLocation(target_addr_t objectAddress,</a>
<a name="ln258">		ValueLocation*&amp; _location)</a>
<a name="ln259">	{</a>
<a name="ln260">		// TODO: Implement!</a>
<a name="ln261">		return B_UNSUPPORTED;</a>
<a name="ln262">	}</a>
<a name="ln263"> </a>
<a name="ln264">	virtual uint32 TypeConstant() const</a>
<a name="ln265">	{</a>
<a name="ln266">		return fTypeConstant;</a>
<a name="ln267">	}</a>
<a name="ln268"> </a>
<a name="ln269">private:</a>
<a name="ln270">	BString	fID;</a>
<a name="ln271">	BString	fName;</a>
<a name="ln272">	uint32	fByteSize;</a>
<a name="ln273">	uint32	fTypeConstant;</a>
<a name="ln274">};</a>
<a name="ln275"> </a>
<a name="ln276"> </a>
<a name="ln277">// #pragma mark - DwarfTypeFactory</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">DwarfTypeFactory::DwarfTypeFactory(DwarfTypeContext* typeContext,</a>
<a name="ln281">	GlobalTypeLookup* typeLookup, GlobalTypeCache* typeCache)</a>
<a name="ln282">	:</a>
<a name="ln283">	fTypeContext(typeContext),</a>
<a name="ln284">	fTypeLookup(typeLookup),</a>
<a name="ln285">	fTypeCache(typeCache)</a>
<a name="ln286">{</a>
<a name="ln287">	fTypeContext-&gt;AcquireReference();</a>
<a name="ln288">	fTypeCache-&gt;AcquireReference();</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291"> </a>
<a name="ln292">DwarfTypeFactory::~DwarfTypeFactory()</a>
<a name="ln293">{</a>
<a name="ln294">	fTypeContext-&gt;ReleaseReference();</a>
<a name="ln295">	fTypeCache-&gt;ReleaseReference();</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298"> </a>
<a name="ln299">status_t</a>
<a name="ln300">DwarfTypeFactory::CreateType(DIEType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln301">{</a>
<a name="ln302">	// try the type cache first</a>
<a name="ln303">	BString name;</a>
<a name="ln304">	DwarfUtils::GetFullyQualifiedDIEName(typeEntry, name);</a>
<a name="ln305"> </a>
<a name="ln306">	TypeLookupConstraints constraints(</a>
<a name="ln307">		dwarf_tag_to_type_kind(typeEntry-&gt;Tag()));</a>
<a name="ln308">	int32 subtypeKind = dwarf_tag_to_subtype_kind(typeEntry-&gt;Tag());</a>
<a name="ln309">	if (subtypeKind &gt;= 0)</a>
<a name="ln310">		constraints.SetSubtypeKind(subtypeKind);</a>
<a name="ln311"> </a>
<a name="ln312">	AutoLocker&lt;GlobalTypeCache&gt; cacheLocker(fTypeCache);</a>
<a name="ln313">	Type* globalType = name.Length() &gt; 0</a>
<a name="ln314">		? fTypeCache-&gt;GetType(name, constraints) : NULL;</a>
<a name="ln315">	if (globalType == NULL) {</a>
<a name="ln316">		// lookup by name failed -- try lookup by ID</a>
<a name="ln317">		BString id;</a>
<a name="ln318">		if (DwarfType::GetTypeID(typeEntry, id))</a>
<a name="ln319">			globalType = fTypeCache-&gt;GetTypeByID(id);</a>
<a name="ln320">	}</a>
<a name="ln321"> </a>
<a name="ln322">	if (globalType != NULL) {</a>
<a name="ln323">		DwarfType* globalDwarfType = dynamic_cast&lt;DwarfType*&gt;(globalType);</a>
<a name="ln324">		if (globalDwarfType != NULL) {</a>
<a name="ln325">			globalDwarfType-&gt;AcquireReference();</a>
<a name="ln326">			_type = globalDwarfType;</a>
<a name="ln327">			return B_OK;</a>
<a name="ln328">		}</a>
<a name="ln329">	}</a>
<a name="ln330"> </a>
<a name="ln331">	cacheLocker.Unlock();</a>
<a name="ln332"> </a>
<a name="ln333">	// If the type entry indicates a declaration only, we try to look the</a>
<a name="ln334">	// type up globally first.</a>
<a name="ln335">	if (typeEntry-&gt;IsDeclaration() &amp;&amp; name.Length() &gt; 0</a>
<a name="ln336">		&amp;&amp; fTypeLookup-&gt;GetType(fTypeCache, name,</a>
<a name="ln337">			constraints, globalType)</a>
<a name="ln338">			== B_OK) {</a>
<a name="ln339">		DwarfType* globalDwarfType</a>
<a name="ln340">			= dynamic_cast&lt;DwarfType*&gt;(globalType);</a>
<a name="ln341">		if (globalDwarfType != NULL) {</a>
<a name="ln342">			_type = globalDwarfType;</a>
<a name="ln343">			return B_OK;</a>
<a name="ln344">		}</a>
<a name="ln345"> </a>
<a name="ln346">		globalType-&gt;ReleaseReference();</a>
<a name="ln347">	}</a>
<a name="ln348"> </a>
<a name="ln349">	// No luck yet -- create the type.</a>
<a name="ln350">	DwarfType* type;</a>
<a name="ln351">	status_t error = _CreateTypeInternal(name, typeEntry, type);</a>
<a name="ln352">	if (error != B_OK)</a>
<a name="ln353">		return error;</a>
<a name="ln354">	BReference&lt;DwarfType&gt; typeReference(type, true);</a>
<a name="ln355"> </a>
<a name="ln356">	// Insert the type into the cache. Re-check, as the type may already</a>
<a name="ln357">	// have been inserted (e.g. in the compound type case).</a>
<a name="ln358">	cacheLocker.Lock();</a>
<a name="ln359">	if (name.Length() &gt; 0</a>
<a name="ln360">			? fTypeCache-&gt;GetType(name, constraints) == NULL</a>
<a name="ln361">			: fTypeCache-&gt;GetTypeByID(type-&gt;ID()) == NULL) {</a>
<a name="ln362">		error = fTypeCache-&gt;AddType(type);</a>
<a name="ln363">		if (error != B_OK)</a>
<a name="ln364">			return error;</a>
<a name="ln365">	}</a>
<a name="ln366">	cacheLocker.Unlock();</a>
<a name="ln367"> </a>
<a name="ln368">	// try to get the type's size</a>
<a name="ln369">	uint64 size;</a>
<a name="ln370">	if (_ResolveTypeByteSize(typeEntry, size) == B_OK)</a>
<a name="ln371">		type-&gt;SetByteSize(size);</a>
<a name="ln372"> </a>
<a name="ln373">	_type = typeReference.Detach();</a>
<a name="ln374">	return B_OK;</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377"> </a>
<a name="ln378">status_t</a>
<a name="ln379">DwarfTypeFactory::_CreateTypeInternal(const BString&amp; name,</a>
<a name="ln380">	DIEType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln381">{</a>
<a name="ln382">	switch (typeEntry-&gt;Tag()) {</a>
<a name="ln383">		case DW_TAG_class_type:</a>
<a name="ln384">		case DW_TAG_structure_type:</a>
<a name="ln385">		case DW_TAG_union_type:</a>
<a name="ln386">		case DW_TAG_interface_type:</a>
<a name="ln387">			return _CreateCompoundType(name,</a>
<a name="ln388">				dynamic_cast&lt;DIECompoundType*&gt;(typeEntry),</a>
<a name="ln389">				(compound_type_kind)dwarf_tag_to_subtype_kind(</a>
<a name="ln390">					typeEntry-&gt;Tag()), _type);</a>
<a name="ln391"> </a>
<a name="ln392">		case DW_TAG_base_type:</a>
<a name="ln393">			return _CreatePrimitiveType(name,</a>
<a name="ln394">				dynamic_cast&lt;DIEBaseType*&gt;(typeEntry), _type);</a>
<a name="ln395"> </a>
<a name="ln396">		case DW_TAG_pointer_type:</a>
<a name="ln397">			return _CreateAddressType(name,</a>
<a name="ln398">				dynamic_cast&lt;DIEAddressingType*&gt;(typeEntry),</a>
<a name="ln399">				DERIVED_TYPE_POINTER, _type);</a>
<a name="ln400">		case DW_TAG_reference_type:</a>
<a name="ln401">			return _CreateAddressType(name,</a>
<a name="ln402">				dynamic_cast&lt;DIEAddressingType*&gt;(typeEntry),</a>
<a name="ln403">				DERIVED_TYPE_REFERENCE, _type);</a>
<a name="ln404"> </a>
<a name="ln405">		case DW_TAG_const_type:</a>
<a name="ln406">			return _CreateModifiedType(name,</a>
<a name="ln407">				dynamic_cast&lt;DIEModifiedType*&gt;(typeEntry),</a>
<a name="ln408">				TYPE_MODIFIER_CONST, _type);</a>
<a name="ln409">		case DW_TAG_packed_type:</a>
<a name="ln410">			return _CreateModifiedType(name,</a>
<a name="ln411">				dynamic_cast&lt;DIEModifiedType*&gt;(typeEntry),</a>
<a name="ln412">				TYPE_MODIFIER_PACKED, _type);</a>
<a name="ln413">		case DW_TAG_volatile_type:</a>
<a name="ln414">			return _CreateModifiedType(name,</a>
<a name="ln415">				dynamic_cast&lt;DIEModifiedType*&gt;(typeEntry),</a>
<a name="ln416">				TYPE_MODIFIER_VOLATILE, _type);</a>
<a name="ln417">		case DW_TAG_restrict_type:</a>
<a name="ln418">			return _CreateModifiedType(name,</a>
<a name="ln419">				dynamic_cast&lt;DIEModifiedType*&gt;(typeEntry),</a>
<a name="ln420">				TYPE_MODIFIER_RESTRICT, _type);</a>
<a name="ln421">		case DW_TAG_shared_type:</a>
<a name="ln422">			return _CreateModifiedType(name,</a>
<a name="ln423">				dynamic_cast&lt;DIEModifiedType*&gt;(typeEntry),</a>
<a name="ln424">				TYPE_MODIFIER_SHARED, _type);</a>
<a name="ln425"> </a>
<a name="ln426">		case DW_TAG_typedef:</a>
<a name="ln427">			return _CreateTypedefType(name,</a>
<a name="ln428">				dynamic_cast&lt;DIETypedef*&gt;(typeEntry), _type);</a>
<a name="ln429"> </a>
<a name="ln430">		case DW_TAG_array_type:</a>
<a name="ln431">			return _CreateArrayType(name,</a>
<a name="ln432">				dynamic_cast&lt;DIEArrayType*&gt;(typeEntry), _type);</a>
<a name="ln433"> </a>
<a name="ln434">		case DW_TAG_enumeration_type:</a>
<a name="ln435">			return _CreateEnumerationType(name,</a>
<a name="ln436">				dynamic_cast&lt;DIEEnumerationType*&gt;(typeEntry), _type);</a>
<a name="ln437"> </a>
<a name="ln438">		case DW_TAG_subrange_type:</a>
<a name="ln439">			return _CreateSubrangeType(name,</a>
<a name="ln440">				dynamic_cast&lt;DIESubrangeType*&gt;(typeEntry), _type);</a>
<a name="ln441"> </a>
<a name="ln442">		case DW_TAG_unspecified_type:</a>
<a name="ln443">			return _CreateUnspecifiedType(name,</a>
<a name="ln444">				dynamic_cast&lt;DIEUnspecifiedType*&gt;(typeEntry), _type);</a>
<a name="ln445"> </a>
<a name="ln446">		case DW_TAG_subroutine_type:</a>
<a name="ln447">			return _CreateFunctionType(name,</a>
<a name="ln448">				dynamic_cast&lt;DIESubroutineType*&gt;(typeEntry), _type);</a>
<a name="ln449"> </a>
<a name="ln450">		case DW_TAG_ptr_to_member_type:</a>
<a name="ln451">			return _CreatePointerToMemberType(name,</a>
<a name="ln452">				dynamic_cast&lt;DIEPointerToMemberType*&gt;(typeEntry), _type);</a>
<a name="ln453"> </a>
<a name="ln454">		case DW_TAG_string_type:</a>
<a name="ln455">		case DW_TAG_file_type:</a>
<a name="ln456">		case DW_TAG_set_type:</a>
<a name="ln457">			// TODO: Implement (not relevant for C++)!</a>
<a name="ln458">			return B_UNSUPPORTED;</a>
<a name="ln459">	}</a>
<a name="ln460"> </a>
<a name="ln461">	return B_UNSUPPORTED;</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464"> </a>
<a name="ln465">status_t</a>
<a name="ln466">DwarfTypeFactory::_CreateCompoundType(const BString&amp; name,</a>
<a name="ln467">	DIECompoundType* typeEntry, compound_type_kind compoundKind, DwarfType*&amp; _type)</a>
<a name="ln468">{</a>
<a name="ln469">	TRACE_LOCALS(&quot;DwarfTypeFactory::_CreateCompoundType(\&quot;%s\&quot;, %p, %d)\n&quot;,</a>
<a name="ln470">		name.String(), typeEntry, compoundKind);</a>
<a name="ln471"> </a>
<a name="ln472">	// create the type</a>
<a name="ln473">	DwarfCompoundType* type = new(std::nothrow) DwarfCompoundType(fTypeContext,</a>
<a name="ln474">		name, typeEntry, compoundKind);</a>
<a name="ln475">	if (type == NULL)</a>
<a name="ln476">		return B_NO_MEMORY;</a>
<a name="ln477">	BReference&lt;DwarfCompoundType&gt; typeReference(type, true);</a>
<a name="ln478"> </a>
<a name="ln479">	// Already add the type at this pointer to the cache, since otherwise</a>
<a name="ln480">	// we could run into an infinite recursion when trying to create the types</a>
<a name="ln481">	// for the data members.</a>
<a name="ln482">// TODO: Since access to the type lookup context is multi-threaded, the</a>
<a name="ln483">// incomplete type could become visible to other threads. Hence we keep the</a>
<a name="ln484">// context locked, but that essentially kills multi-threading for this context.</a>
<a name="ln485">	AutoLocker&lt;GlobalTypeCache&gt; cacheLocker(fTypeCache);</a>
<a name="ln486">	status_t error = fTypeCache-&gt;AddType(type);</a>
<a name="ln487">	if (error != B_OK)</a>
<a name="ln488">{</a>
<a name="ln489">printf(&quot;  -&gt; failed to add type to cache\n&quot;);</a>
<a name="ln490">		return error;</a>
<a name="ln491">}</a>
<a name="ln492">//	cacheLocker.Unlock();</a>
<a name="ln493"> </a>
<a name="ln494">	// find the abstract origin or specification that defines the data members</a>
<a name="ln495">	DIECompoundType* memberOwnerEntry = DwarfUtils::GetDIEByPredicate(typeEntry,</a>
<a name="ln496">		HasMembersPredicate());</a>
<a name="ln497"> </a>
<a name="ln498">	// create the data member objects</a>
<a name="ln499">	if (memberOwnerEntry != NULL) {</a>
<a name="ln500">		for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln501">					= memberOwnerEntry-&gt;DataMembers().GetIterator();</a>
<a name="ln502">				DebugInfoEntry* _memberEntry = it.Next();) {</a>
<a name="ln503">			DIEMember* memberEntry = dynamic_cast&lt;DIEMember*&gt;(_memberEntry);</a>
<a name="ln504"> </a>
<a name="ln505">			TRACE_LOCALS(&quot;  member %p\n&quot;, memberEntry);</a>
<a name="ln506"> </a>
<a name="ln507">			// get the type</a>
<a name="ln508">			DwarfType* memberType;</a>
<a name="ln509">			if (CreateType(memberEntry-&gt;GetType(), memberType) != B_OK)</a>
<a name="ln510">				continue;</a>
<a name="ln511">			BReference&lt;DwarfType&gt; memberTypeReference(memberType, true);</a>
<a name="ln512"> </a>
<a name="ln513">			// get the name</a>
<a name="ln514">			BString memberName;</a>
<a name="ln515">			DwarfUtils::GetDIEName(memberEntry, memberName);</a>
<a name="ln516"> </a>
<a name="ln517">			// create and add the member object</a>
<a name="ln518">			DwarfDataMember* member = new(std::nothrow) DwarfDataMember(</a>
<a name="ln519">				memberEntry, memberName, memberType);</a>
<a name="ln520">			BReference&lt;DwarfDataMember&gt; memberReference(member, true);</a>
<a name="ln521">			if (member == NULL || !type-&gt;AddDataMember(member)) {</a>
<a name="ln522">				cacheLocker.Lock();</a>
<a name="ln523">				fTypeCache-&gt;RemoveType(type);</a>
<a name="ln524">				return B_NO_MEMORY;</a>
<a name="ln525">			}</a>
<a name="ln526">		}</a>
<a name="ln527">	}</a>
<a name="ln528"> </a>
<a name="ln529">	// If the type is a class/struct/interface type, we also need to add its</a>
<a name="ln530">	// base types, and possibly template parameters.</a>
<a name="ln531">	if (DIEClassBaseType* classTypeEntry</a>
<a name="ln532">			= dynamic_cast&lt;DIEClassBaseType*&gt;(typeEntry)) {</a>
<a name="ln533">		// find the abstract origin or specification that defines the base types</a>
<a name="ln534">		classTypeEntry = DwarfUtils::GetDIEByPredicate(classTypeEntry,</a>
<a name="ln535">			HasBaseTypesPredicate());</a>
<a name="ln536"> </a>
<a name="ln537">		// create the inheritance objects for the base types</a>
<a name="ln538">		if (classTypeEntry != NULL) {</a>
<a name="ln539">			for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln540">						= classTypeEntry-&gt;BaseTypes().GetIterator();</a>
<a name="ln541">					DebugInfoEntry* _inheritanceEntry = it.Next();) {</a>
<a name="ln542">				DIEInheritance* inheritanceEntry</a>
<a name="ln543">					= dynamic_cast&lt;DIEInheritance*&gt;(_inheritanceEntry);</a>
<a name="ln544"> </a>
<a name="ln545">				// get the type</a>
<a name="ln546">				DwarfType* baseType;</a>
<a name="ln547">				if (CreateType(inheritanceEntry-&gt;GetType(), baseType) != B_OK)</a>
<a name="ln548">					continue;</a>
<a name="ln549">				BReference&lt;DwarfType&gt; baseTypeReference(baseType, true);</a>
<a name="ln550"> </a>
<a name="ln551">				// create and add the inheritance object</a>
<a name="ln552">				DwarfInheritance* inheritance = new(std::nothrow)</a>
<a name="ln553">					DwarfInheritance(inheritanceEntry, baseType);</a>
<a name="ln554">				BReference&lt;DwarfInheritance&gt; inheritanceReference(inheritance,</a>
<a name="ln555">					true);</a>
<a name="ln556">				if (inheritance == NULL || !type-&gt;AddInheritance(inheritance)) {</a>
<a name="ln557">					cacheLocker.Lock();</a>
<a name="ln558">					fTypeCache-&gt;RemoveType(type);</a>
<a name="ln559">					return B_NO_MEMORY;</a>
<a name="ln560">				}</a>
<a name="ln561">			}</a>
<a name="ln562">		}</a>
<a name="ln563"> </a>
<a name="ln564">		// find the abstract origin or specification that defines the template</a>
<a name="ln565">		// parameters</a>
<a name="ln566">		classTypeEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln567">			dynamic_cast&lt;DIEClassBaseType*&gt;(typeEntry),</a>
<a name="ln568">			HasTemplateParametersPredicate());</a>
<a name="ln569"> </a>
<a name="ln570">		if (classTypeEntry != NULL) {</a>
<a name="ln571">			for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln572">						= classTypeEntry-&gt;TemplateParameters()</a>
<a name="ln573">							.GetIterator();</a>
<a name="ln574">					DebugInfoEntry* _typeEntry = it.Next();) {</a>
<a name="ln575">				DIETemplateTypeParameter* templateTypeEntry</a>
<a name="ln576">					= dynamic_cast&lt;DIETemplateTypeParameter*&gt;(_typeEntry);</a>
<a name="ln577">				DwarfType* templateType;</a>
<a name="ln578">				if (templateTypeEntry != NULL) {</a>
<a name="ln579">					if (templateTypeEntry-&gt;GetType() == NULL</a>
<a name="ln580">						|| CreateType(templateTypeEntry-&gt;GetType(),</a>
<a name="ln581">							templateType) != B_OK) {</a>
<a name="ln582">						continue;</a>
<a name="ln583">					}</a>
<a name="ln584">				} else {</a>
<a name="ln585">					DIETemplateValueParameter* templateValueEntry</a>
<a name="ln586">						= dynamic_cast&lt;DIETemplateValueParameter*&gt;(_typeEntry);</a>
<a name="ln587">					if (CreateType(templateValueEntry-&gt;GetType(), templateType)</a>
<a name="ln588">						!= B_OK) {</a>
<a name="ln589">						continue;</a>
<a name="ln590">					}</a>
<a name="ln591">				}</a>
<a name="ln592">				BReference&lt;DwarfType&gt; templateTypeReference(templateType,</a>
<a name="ln593">					true);</a>
<a name="ln594">				DwarfTemplateParameter* parameter</a>
<a name="ln595">					= new(std::nothrow) DwarfTemplateParameter(_typeEntry,</a>
<a name="ln596">						templateType);</a>
<a name="ln597">				if (parameter == NULL) {</a>
<a name="ln598">					cacheLocker.Lock();</a>
<a name="ln599">					fTypeCache-&gt;RemoveType(type);</a>
<a name="ln600">					return B_NO_MEMORY;</a>
<a name="ln601">				}</a>
<a name="ln602"> </a>
<a name="ln603">				if (!type-&gt;AddTemplateParameter(parameter)) {</a>
<a name="ln604">					cacheLocker.Lock();</a>
<a name="ln605">					fTypeCache-&gt;RemoveType(type);</a>
<a name="ln606">					return B_NO_MEMORY;</a>
<a name="ln607">				}</a>
<a name="ln608">			}</a>
<a name="ln609">		}</a>
<a name="ln610">	}</a>
<a name="ln611"> </a>
<a name="ln612">	_type = typeReference.Detach();</a>
<a name="ln613">	return B_OK;;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616"> </a>
<a name="ln617">status_t</a>
<a name="ln618">DwarfTypeFactory::_CreatePrimitiveType(const BString&amp; name,</a>
<a name="ln619">	DIEBaseType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln620">{</a>
<a name="ln621">	const DynamicAttributeValue* byteSizeValue = typeEntry-&gt;ByteSize();</a>
<a name="ln622">//	const DynamicAttributeValue* bitOffsetValue = typeEntry-&gt;BitOffset();</a>
<a name="ln623">	const DynamicAttributeValue* bitSizeValue = typeEntry-&gt;BitSize();</a>
<a name="ln624"> </a>
<a name="ln625">	uint32 bitSize = 0;</a>
<a name="ln626">	if (byteSizeValue-&gt;IsValid()) {</a>
<a name="ln627">		BVariant value;</a>
<a name="ln628">		status_t error = fTypeContext-&gt;File()-&gt;EvaluateDynamicValue(</a>
<a name="ln629">			fTypeContext-&gt;GetCompilationUnit(), fTypeContext-&gt;AddressSize(),</a>
<a name="ln630">			fTypeContext-&gt;SubprogramEntry(), byteSizeValue,</a>
<a name="ln631">			fTypeContext-&gt;TargetInterface(),</a>
<a name="ln632">			fTypeContext-&gt;InstructionPointer(), fTypeContext-&gt;FramePointer(),</a>
<a name="ln633">			value);</a>
<a name="ln634">		if (error == B_OK &amp;&amp; value.IsInteger())</a>
<a name="ln635">			bitSize = value.ToUInt32() * 8;</a>
<a name="ln636">	} else if (bitSizeValue-&gt;IsValid()) {</a>
<a name="ln637">		BVariant value;</a>
<a name="ln638">		status_t error = fTypeContext-&gt;File()-&gt;EvaluateDynamicValue(</a>
<a name="ln639">			fTypeContext-&gt;GetCompilationUnit(), fTypeContext-&gt;AddressSize(),</a>
<a name="ln640">			fTypeContext-&gt;SubprogramEntry(), bitSizeValue,</a>
<a name="ln641">			fTypeContext-&gt;TargetInterface(),</a>
<a name="ln642">			fTypeContext-&gt;InstructionPointer(), fTypeContext-&gt;FramePointer(),</a>
<a name="ln643">			value);</a>
<a name="ln644">		if (error == B_OK &amp;&amp; value.IsInteger())</a>
<a name="ln645">			bitSize = value.ToUInt32();</a>
<a name="ln646">	}</a>
<a name="ln647"> </a>
<a name="ln648">	// determine type constant</a>
<a name="ln649">	uint32 typeConstant = 0;</a>
<a name="ln650">	switch (typeEntry-&gt;Encoding()) {</a>
<a name="ln651">		case DW_ATE_boolean:</a>
<a name="ln652">			typeConstant = B_BOOL_TYPE;</a>
<a name="ln653">			break;</a>
<a name="ln654"> </a>
<a name="ln655">		case DW_ATE_float:</a>
<a name="ln656">			switch (bitSize) {</a>
<a name="ln657">				case 32:</a>
<a name="ln658">					typeConstant = B_FLOAT_TYPE;</a>
<a name="ln659">					break;</a>
<a name="ln660">				case 64:</a>
<a name="ln661">					typeConstant = B_DOUBLE_TYPE;</a>
<a name="ln662">					break;</a>
<a name="ln663">			}</a>
<a name="ln664">			break;</a>
<a name="ln665"> </a>
<a name="ln666">		case DW_ATE_signed:</a>
<a name="ln667">		case DW_ATE_signed_char:</a>
<a name="ln668">			switch (bitSize) {</a>
<a name="ln669">				case 8:</a>
<a name="ln670">					typeConstant = B_INT8_TYPE;</a>
<a name="ln671">					break;</a>
<a name="ln672">				case 16:</a>
<a name="ln673">					typeConstant = B_INT16_TYPE;</a>
<a name="ln674">					break;</a>
<a name="ln675">				case 32:</a>
<a name="ln676">					typeConstant = B_INT32_TYPE;</a>
<a name="ln677">					break;</a>
<a name="ln678">				case 64:</a>
<a name="ln679">					typeConstant = B_INT64_TYPE;</a>
<a name="ln680">					break;</a>
<a name="ln681">			}</a>
<a name="ln682">			break;</a>
<a name="ln683"> </a>
<a name="ln684">		case DW_ATE_address:</a>
<a name="ln685">		case DW_ATE_unsigned:</a>
<a name="ln686">		case DW_ATE_unsigned_char:</a>
<a name="ln687">			switch (bitSize) {</a>
<a name="ln688">				case 8:</a>
<a name="ln689">					typeConstant = B_UINT8_TYPE;</a>
<a name="ln690">					break;</a>
<a name="ln691">				case 16:</a>
<a name="ln692">					typeConstant = B_UINT16_TYPE;</a>
<a name="ln693">					break;</a>
<a name="ln694">				case 32:</a>
<a name="ln695">					typeConstant = B_UINT32_TYPE;</a>
<a name="ln696">					break;</a>
<a name="ln697">				case 64:</a>
<a name="ln698">					typeConstant = B_UINT64_TYPE;</a>
<a name="ln699">					break;</a>
<a name="ln700">			}</a>
<a name="ln701">			break;</a>
<a name="ln702"> </a>
<a name="ln703">		case DW_ATE_complex_float:</a>
<a name="ln704">		case DW_ATE_imaginary_float:</a>
<a name="ln705">		case DW_ATE_packed_decimal:</a>
<a name="ln706">		case DW_ATE_numeric_string:</a>
<a name="ln707">		case DW_ATE_edited:</a>
<a name="ln708">		case DW_ATE_signed_fixed:</a>
<a name="ln709">		case DW_ATE_unsigned_fixed:</a>
<a name="ln710">		case DW_ATE_decimal_float:</a>
<a name="ln711">		default:</a>
<a name="ln712">			break;</a>
<a name="ln713">	}</a>
<a name="ln714"> </a>
<a name="ln715">	// create the type</a>
<a name="ln716">	DwarfPrimitiveType* type = new(std::nothrow) DwarfPrimitiveType(</a>
<a name="ln717">		fTypeContext, name, typeEntry, typeConstant);</a>
<a name="ln718">	if (type == NULL)</a>
<a name="ln719">		return B_NO_MEMORY;</a>
<a name="ln720"> </a>
<a name="ln721">	_type = type;</a>
<a name="ln722">	return B_OK;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725"> </a>
<a name="ln726">status_t</a>
<a name="ln727">DwarfTypeFactory::_CreateAddressType(const BString&amp; name,</a>
<a name="ln728">	DIEAddressingType* typeEntry, address_type_kind addressKind,</a>
<a name="ln729">	DwarfType*&amp; _type)</a>
<a name="ln730">{</a>
<a name="ln731">	// get the base type entry</a>
<a name="ln732">	DIEAddressingType* baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln733">		typeEntry, HasTypePredicate&lt;DIEAddressingType&gt;());</a>
<a name="ln734"> </a>
<a name="ln735">	// create the base type</a>
<a name="ln736">	DwarfType* baseType;</a>
<a name="ln737">	if (baseTypeOwnerEntry != NULL) {</a>
<a name="ln738">		status_t error = CreateType(baseTypeOwnerEntry-&gt;GetType(), baseType);</a>
<a name="ln739">		if (error != B_OK)</a>
<a name="ln740">			return error;</a>
<a name="ln741">	} else {</a>
<a name="ln742">		// According to the DWARF 3 specs a modified type *has* a base type.</a>
<a name="ln743">		// GCC 4 doesn't (always?) bother to add one for &quot;void&quot;.</a>
<a name="ln744">		// TODO: We should probably search for a respective type by name. ATM</a>
<a name="ln745">		// we just create a DwarfUnspecifiedType without DIE.</a>
<a name="ln746">		TRACE_LOCALS(&quot;no base type for address type entry -- creating &quot;</a>
<a name="ln747">			&quot;unspecified type\n&quot;);</a>
<a name="ln748">		baseType = new(std::nothrow) DwarfUnspecifiedType(fTypeContext, &quot;void&quot;,</a>
<a name="ln749">			NULL);</a>
<a name="ln750">		if (baseType == NULL)</a>
<a name="ln751">			return B_NO_MEMORY;</a>
<a name="ln752">	}</a>
<a name="ln753">	BReference&lt;Type&gt; baseTypeReference(baseType, true);</a>
<a name="ln754"> </a>
<a name="ln755">	DwarfAddressType* type = new(std::nothrow) DwarfAddressType(fTypeContext,</a>
<a name="ln756">		name, typeEntry, addressKind, baseType);</a>
<a name="ln757">	if (type == NULL)</a>
<a name="ln758">		return B_NO_MEMORY;</a>
<a name="ln759"> </a>
<a name="ln760">	_type = type;</a>
<a name="ln761">	return B_OK;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">status_t</a>
<a name="ln766">DwarfTypeFactory::_CreateModifiedType(const BString&amp; name,</a>
<a name="ln767">	DIEModifiedType* typeEntry, uint32 modifiers, DwarfType*&amp; _type)</a>
<a name="ln768">{</a>
<a name="ln769">	// Get the base type entry. If it is a modified type too or a typedef,</a>
<a name="ln770">	// collect all modifiers and iterate until hitting an actual base type.</a>
<a name="ln771">	DIEType* baseTypeEntry = NULL;</a>
<a name="ln772">	DwarfType* baseType = NULL;</a>
<a name="ln773">	while (true) {</a>
<a name="ln774">		DIEModifiedType* baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln775">			typeEntry, HasTypePredicate&lt;DIEModifiedType&gt;());</a>
<a name="ln776">		if (baseTypeOwnerEntry == NULL) {</a>
<a name="ln777">			if (typeEntry-&gt;GetType() == NULL) {</a>
<a name="ln778">				// in the case of a modified type that points to an</a>
<a name="ln779">				// unspecified type (i.e. const void* in C/C++),</a>
<a name="ln780">				// gcc appears to omit the base type attribute entirely.</a>
<a name="ln781">				status_t result = _CreateUnspecifiedType(name,</a>
<a name="ln782">					NULL, baseType);</a>
<a name="ln783">				if (result != B_OK)</a>
<a name="ln784">					return result;</a>
<a name="ln785">				break;</a>
<a name="ln786">			} else</a>
<a name="ln787">				return B_BAD_VALUE;</a>
<a name="ln788">		} else</a>
<a name="ln789">			baseTypeEntry = baseTypeOwnerEntry-&gt;GetType();</a>
<a name="ln790"> </a>
<a name="ln791">		// resolve a typedef</a>
<a name="ln792">		if (baseTypeEntry-&gt;Tag() == DW_TAG_typedef) {</a>
<a name="ln793">			status_t error = _ResolveTypedef(</a>
<a name="ln794">				dynamic_cast&lt;DIETypedef*&gt;(baseTypeEntry), baseTypeEntry);</a>
<a name="ln795">			if (error != B_OK)</a>
<a name="ln796">				return error;</a>
<a name="ln797">		}</a>
<a name="ln798"> </a>
<a name="ln799">		if (baseTypeEntry == NULL)</a>
<a name="ln800">			return B_BAD_VALUE;</a>
<a name="ln801"> </a>
<a name="ln802">		// If the base type is a modified type, too, resolve it.</a>
<a name="ln803">		switch (baseTypeEntry-&gt;Tag()) {</a>
<a name="ln804">			case DW_TAG_const_type:</a>
<a name="ln805">				modifiers |= TYPE_MODIFIER_CONST;</a>
<a name="ln806">				baseTypeOwnerEntry</a>
<a name="ln807">					= dynamic_cast&lt;DIEModifiedType*&gt;(baseTypeEntry);</a>
<a name="ln808">				continue;</a>
<a name="ln809">			case DW_TAG_packed_type:</a>
<a name="ln810">				modifiers |= TYPE_MODIFIER_PACKED;</a>
<a name="ln811">				baseTypeOwnerEntry</a>
<a name="ln812">					= dynamic_cast&lt;DIEModifiedType*&gt;(baseTypeEntry);</a>
<a name="ln813">				continue;</a>
<a name="ln814">			case DW_TAG_volatile_type:</a>
<a name="ln815">				modifiers |= TYPE_MODIFIER_VOLATILE;</a>
<a name="ln816">				baseTypeOwnerEntry</a>
<a name="ln817">					= dynamic_cast&lt;DIEModifiedType*&gt;(baseTypeEntry);</a>
<a name="ln818">				continue;</a>
<a name="ln819">			case DW_TAG_restrict_type:</a>
<a name="ln820">				modifiers |= TYPE_MODIFIER_RESTRICT;</a>
<a name="ln821">				baseTypeOwnerEntry</a>
<a name="ln822">					= dynamic_cast&lt;DIEModifiedType*&gt;(baseTypeEntry);</a>
<a name="ln823">				continue;</a>
<a name="ln824">			case DW_TAG_shared_type:</a>
<a name="ln825">				modifiers |= TYPE_MODIFIER_SHARED;</a>
<a name="ln826">				baseTypeOwnerEntry</a>
<a name="ln827">					= dynamic_cast&lt;DIEModifiedType*&gt;(baseTypeEntry);</a>
<a name="ln828">				continue;</a>
<a name="ln829"> </a>
<a name="ln830">			default:</a>
<a name="ln831">				break;</a>
<a name="ln832">		}</a>
<a name="ln833"> </a>
<a name="ln834">		// If we get here, we've found an actual base type.</a>
<a name="ln835">		break;</a>
<a name="ln836">	}</a>
<a name="ln837"> </a>
<a name="ln838">	if (baseType == NULL) {</a>
<a name="ln839">		// create the base type</a>
<a name="ln840">		status_t error = CreateType(baseTypeEntry, baseType);</a>
<a name="ln841">		if (error != B_OK)</a>
<a name="ln842">			return error;</a>
<a name="ln843">	}</a>
<a name="ln844"> </a>
<a name="ln845">	BReference&lt;Type&gt; baseTypeReference(baseType, true);</a>
<a name="ln846"> </a>
<a name="ln847">	DwarfModifiedType* type = new(std::nothrow) DwarfModifiedType(fTypeContext,</a>
<a name="ln848">		name, typeEntry, modifiers, baseType);</a>
<a name="ln849">	if (type == NULL)</a>
<a name="ln850">		return B_NO_MEMORY;</a>
<a name="ln851"> </a>
<a name="ln852">	_type = type;</a>
<a name="ln853">	return B_OK;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856"> </a>
<a name="ln857">status_t</a>
<a name="ln858">DwarfTypeFactory::_CreateTypedefType(const BString&amp; name,</a>
<a name="ln859">	DIETypedef* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln860">{</a>
<a name="ln861">	// resolve the base type</a>
<a name="ln862">	DIEType* baseTypeEntry;</a>
<a name="ln863">	status_t error = _ResolveTypedef(typeEntry, baseTypeEntry);</a>
<a name="ln864">	if (error != B_OK)</a>
<a name="ln865">		return error;</a>
<a name="ln866"> </a>
<a name="ln867">	// create the base type</a>
<a name="ln868">	DwarfType* baseType;</a>
<a name="ln869">	error = CreateType(baseTypeEntry, baseType);</a>
<a name="ln870">	if (error != B_OK)</a>
<a name="ln871">		return error;</a>
<a name="ln872">	BReference&lt;Type&gt; baseTypeReference(baseType, true);</a>
<a name="ln873"> </a>
<a name="ln874">	DwarfTypedefType* type = new(std::nothrow) DwarfTypedefType(fTypeContext,</a>
<a name="ln875">		name, typeEntry, baseType);</a>
<a name="ln876">	if (type == NULL)</a>
<a name="ln877">		return B_NO_MEMORY;</a>
<a name="ln878"> </a>
<a name="ln879">	_type = type;</a>
<a name="ln880">	return B_OK;</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883"> </a>
<a name="ln884">status_t</a>
<a name="ln885">DwarfTypeFactory::_CreateArrayType(const BString&amp; name,</a>
<a name="ln886">	DIEArrayType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln887">{</a>
<a name="ln888">	TRACE_LOCALS(&quot;DwarfTypeFactory::_CreateArrayType(\&quot;%s\&quot;, %p)\n&quot;,</a>
<a name="ln889">		name.String(), typeEntry);</a>
<a name="ln890"> </a>
<a name="ln891">	// create the base type</a>
<a name="ln892">	DIEArrayType* baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln893">		typeEntry, HasTypePredicate&lt;DIEArrayType&gt;());</a>
<a name="ln894">	if (baseTypeOwnerEntry == NULL) {</a>
<a name="ln895">		WARNING(&quot;Failed to get base type for array type \&quot;%s\&quot;\n&quot;,</a>
<a name="ln896">			name.String());</a>
<a name="ln897">		return B_BAD_VALUE;</a>
<a name="ln898">	}</a>
<a name="ln899"> </a>
<a name="ln900">	DwarfType* baseType = NULL;</a>
<a name="ln901">	status_t error = CreateType(baseTypeOwnerEntry-&gt;GetType(), baseType);</a>
<a name="ln902">	if (error != B_OK) {</a>
<a name="ln903">		WARNING(&quot;Failed to create base type for array type \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln904">			name.String(), strerror(error));</a>
<a name="ln905">		return error;</a>
<a name="ln906">	}</a>
<a name="ln907">	BReference&lt;Type&gt; baseTypeReference(baseType, true);</a>
<a name="ln908"> </a>
<a name="ln909">	// create the array type</a>
<a name="ln910">	DwarfArrayType* type = new(std::nothrow) DwarfArrayType(fTypeContext, name,</a>
<a name="ln911">		typeEntry, baseType);</a>
<a name="ln912">	if (type == NULL)</a>
<a name="ln913">		return B_NO_MEMORY;</a>
<a name="ln914">	BReference&lt;DwarfType&gt; typeReference(type, true);</a>
<a name="ln915"> </a>
<a name="ln916">	// add the array dimensions</a>
<a name="ln917">	DIEArrayType* dimensionOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln918">		typeEntry, HasDimensionsPredicate());</a>
<a name="ln919"> </a>
<a name="ln920">	if (dimensionOwnerEntry == NULL) {</a>
<a name="ln921">		WARNING(&quot;Failed to get dimensions for array type \&quot;%s\&quot;\n&quot;,</a>
<a name="ln922">			name.String());</a>
<a name="ln923">		return B_BAD_VALUE;</a>
<a name="ln924">	}</a>
<a name="ln925"> </a>
<a name="ln926">	for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln927">				= dimensionOwnerEntry-&gt;Dimensions().GetIterator();</a>
<a name="ln928">			DebugInfoEntry* _dimensionEntry = it.Next();) {</a>
<a name="ln929">		DIEType* dimensionEntry = dynamic_cast&lt;DIEType*&gt;(_dimensionEntry);</a>
<a name="ln930"> </a>
<a name="ln931">		// get/create the dimension type</a>
<a name="ln932">		DwarfType* dimensionType = NULL;</a>
<a name="ln933">		status_t error = CreateType(dimensionEntry, dimensionType);</a>
<a name="ln934">		if (error != B_OK) {</a>
<a name="ln935">			WARNING(&quot;Failed to create type for array dimension: %s\n&quot;,</a>
<a name="ln936">				strerror(error));</a>
<a name="ln937">			return error;</a>
<a name="ln938">		}</a>
<a name="ln939">		BReference&lt;Type&gt; dimensionTypeReference(dimensionType, true);</a>
<a name="ln940"> </a>
<a name="ln941">		// create and add the array dimension object</a>
<a name="ln942">		DwarfArrayDimension* dimension</a>
<a name="ln943">			= new(std::nothrow) DwarfArrayDimension(dimensionType);</a>
<a name="ln944">		BReference&lt;DwarfArrayDimension&gt; dimensionReference(dimension, true);</a>
<a name="ln945">		if (dimension == NULL || !type-&gt;AddDimension(dimension))</a>
<a name="ln946">			return B_NO_MEMORY;</a>
<a name="ln947">	}</a>
<a name="ln948"> </a>
<a name="ln949">	_type = typeReference.Detach();</a>
<a name="ln950">	return B_OK;</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">status_t</a>
<a name="ln955">DwarfTypeFactory::_CreateEnumerationType(const BString&amp; name,</a>
<a name="ln956">	DIEEnumerationType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln957">{</a>
<a name="ln958">	// create the base type (it's optional)</a>
<a name="ln959">	DIEEnumerationType* baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln960">		typeEntry, HasTypePredicate&lt;DIEEnumerationType&gt;());</a>
<a name="ln961"> </a>
<a name="ln962">	DwarfType* baseType = NULL;</a>
<a name="ln963">	if (baseTypeOwnerEntry != NULL) {</a>
<a name="ln964">		status_t error = CreateType(baseTypeOwnerEntry-&gt;GetType(), baseType);</a>
<a name="ln965">		if (error != B_OK)</a>
<a name="ln966">			return error;</a>
<a name="ln967">	}</a>
<a name="ln968">	BReference&lt;Type&gt; baseTypeReference(baseType, true);</a>
<a name="ln969"> </a>
<a name="ln970">	// create the enumeration type</a>
<a name="ln971">	DwarfEnumerationType* type = new(std::nothrow) DwarfEnumerationType(</a>
<a name="ln972">		fTypeContext, name, typeEntry, baseType);</a>
<a name="ln973">	if (type == NULL)</a>
<a name="ln974">		return B_NO_MEMORY;</a>
<a name="ln975">	BReference&lt;DwarfEnumerationType&gt; typeReference(type, true);</a>
<a name="ln976"> </a>
<a name="ln977">	// get the enumeration values</a>
<a name="ln978">	DIEEnumerationType* enumeratorOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln979">		typeEntry, HasEnumeratorsPredicate());</a>
<a name="ln980"> </a>
<a name="ln981">	if (enumeratorOwnerEntry != NULL) {</a>
<a name="ln982">		for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln983">					= enumeratorOwnerEntry-&gt;Enumerators().GetIterator();</a>
<a name="ln984">				DebugInfoEntry* _enumeratorEntry = it.Next();) {</a>
<a name="ln985">			DIEEnumerator* enumeratorEntry = dynamic_cast&lt;DIEEnumerator*&gt;(</a>
<a name="ln986">				_enumeratorEntry);</a>
<a name="ln987"> </a>
<a name="ln988">			// evaluate the value</a>
<a name="ln989">			BVariant value;</a>
<a name="ln990">			status_t error = fTypeContext-&gt;File()-&gt;EvaluateConstantValue(</a>
<a name="ln991">				fTypeContext-&gt;GetCompilationUnit(),</a>
<a name="ln992">				fTypeContext-&gt;AddressSize(),</a>
<a name="ln993">				fTypeContext-&gt;SubprogramEntry(), enumeratorEntry-&gt;ConstValue(),</a>
<a name="ln994">				fTypeContext-&gt;TargetInterface(),</a>
<a name="ln995">				fTypeContext-&gt;InstructionPointer(),</a>
<a name="ln996">				fTypeContext-&gt;FramePointer(), value);</a>
<a name="ln997">			if (error != B_OK) {</a>
<a name="ln998">				// The value is probably not stored -- just ignore the</a>
<a name="ln999">				// enumerator.</a>
<a name="ln1000">				TRACE_LOCALS(&quot;Failed to get value for enum type value %s::%s\n&quot;,</a>
<a name="ln1001">					name.String(), enumeratorEntry-&gt;Name());</a>
<a name="ln1002">				continue;</a>
<a name="ln1003">			}</a>
<a name="ln1004"> </a>
<a name="ln1005">			// create and add the enumeration value object</a>
<a name="ln1006">			DwarfEnumeratorValue* enumValue</a>
<a name="ln1007">				= new(std::nothrow) DwarfEnumeratorValue(enumeratorEntry,</a>
<a name="ln1008">					enumeratorEntry-&gt;Name(), value);</a>
<a name="ln1009">			BReference&lt;DwarfEnumeratorValue&gt; enumValueReference(enumValue,</a>
<a name="ln1010">				true);</a>
<a name="ln1011">			if (enumValue == NULL || !type-&gt;AddValue(enumValue))</a>
<a name="ln1012">				return B_NO_MEMORY;</a>
<a name="ln1013">		}</a>
<a name="ln1014">	}</a>
<a name="ln1015"> </a>
<a name="ln1016">	_type = typeReference.Detach();</a>
<a name="ln1017">	return B_OK;</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020"> </a>
<a name="ln1021">status_t</a>
<a name="ln1022">DwarfTypeFactory::_CreateSubrangeType(const BString&amp; name,</a>
<a name="ln1023">	DIESubrangeType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln1024">{</a>
<a name="ln1025">	// get the base type</a>
<a name="ln1026">	DIESubrangeType* baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1027">		typeEntry, HasTypePredicate&lt;DIESubrangeType&gt;());</a>
<a name="ln1028">	DIEType* baseTypeEntry = baseTypeOwnerEntry != NULL</a>
<a name="ln1029">		? baseTypeOwnerEntry-&gt;GetType() : NULL;</a>
<a name="ln1030"> </a>
<a name="ln1031">	// get the lower bound</a>
<a name="ln1032">	BVariant lowerBound;</a>
<a name="ln1033">	DIESubrangeType* lowerBoundOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1034">		typeEntry, HasLowerBoundPredicate());</a>
<a name="ln1035">	if (lowerBoundOwnerEntry != NULL) {</a>
<a name="ln1036">		// evaluate it</a>
<a name="ln1037">		DIEType* valueType;</a>
<a name="ln1038">		status_t error = fTypeContext-&gt;File()-&gt;EvaluateDynamicValue(</a>
<a name="ln1039">			fTypeContext-&gt;GetCompilationUnit(), fTypeContext-&gt;AddressSize(),</a>
<a name="ln1040">			fTypeContext-&gt;SubprogramEntry(),</a>
<a name="ln1041">			lowerBoundOwnerEntry-&gt;LowerBound(),</a>
<a name="ln1042">			fTypeContext-&gt;TargetInterface(),</a>
<a name="ln1043">			fTypeContext-&gt;InstructionPointer(),</a>
<a name="ln1044">			fTypeContext-&gt;FramePointer(), lowerBound, &amp;valueType);</a>
<a name="ln1045">		if (error != B_OK) {</a>
<a name="ln1046">			WARNING(&quot;  failed to evaluate lower bound: %s\n&quot;, strerror(error));</a>
<a name="ln1047">			return error;</a>
<a name="ln1048">		}</a>
<a name="ln1049"> </a>
<a name="ln1050">		// If we don't have a base type yet, and the lower bound attribute</a>
<a name="ln1051">		// refers to an object, the type of that object is our base type.</a>
<a name="ln1052">		if (baseTypeEntry == NULL)</a>
<a name="ln1053">			baseTypeEntry = valueType;</a>
<a name="ln1054">	} else {</a>
<a name="ln1055">		// that's ok -- use the language default</a>
<a name="ln1056">		lowerBound.SetTo(fTypeContext-&gt;GetCompilationUnit()-&gt;SourceLanguage()</a>
<a name="ln1057">			-&gt;subrangeLowerBound);</a>
<a name="ln1058">	}</a>
<a name="ln1059"> </a>
<a name="ln1060">	// get the upper bound</a>
<a name="ln1061">	BVariant upperBound;</a>
<a name="ln1062">	DIESubrangeType* upperBoundOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1063">		typeEntry, HasUpperBoundPredicate());</a>
<a name="ln1064">	if (upperBoundOwnerEntry != NULL) {</a>
<a name="ln1065">		// evaluate it</a>
<a name="ln1066">		DIEType* valueType;</a>
<a name="ln1067">		status_t error = fTypeContext-&gt;File()-&gt;EvaluateDynamicValue(</a>
<a name="ln1068">			fTypeContext-&gt;GetCompilationUnit(), fTypeContext-&gt;AddressSize(),</a>
<a name="ln1069">			fTypeContext-&gt;SubprogramEntry(),</a>
<a name="ln1070">			upperBoundOwnerEntry-&gt;UpperBound(),</a>
<a name="ln1071">			fTypeContext-&gt;TargetInterface(),</a>
<a name="ln1072">			fTypeContext-&gt;InstructionPointer(), fTypeContext-&gt;FramePointer(),</a>
<a name="ln1073">			upperBound, &amp;valueType);</a>
<a name="ln1074">		if (error != B_OK) {</a>
<a name="ln1075">			WARNING(&quot;  failed to evaluate upper bound: %s\n&quot;, strerror(error));</a>
<a name="ln1076">			return error;</a>
<a name="ln1077">		}</a>
<a name="ln1078"> </a>
<a name="ln1079">		// If we don't have a base type yet, and the upper bound attribute</a>
<a name="ln1080">		// refers to an object, the type of that object is our base type.</a>
<a name="ln1081">		if (baseTypeEntry == NULL)</a>
<a name="ln1082">			baseTypeEntry = valueType;</a>
<a name="ln1083">	} else {</a>
<a name="ln1084">		// get the count instead</a>
<a name="ln1085">		DIESubrangeType* countOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1086">			typeEntry, HasCountPredicate());</a>
<a name="ln1087">		if (countOwnerEntry != NULL) {</a>
<a name="ln1088">			// evaluate it</a>
<a name="ln1089">			BVariant count;</a>
<a name="ln1090">			DIEType* valueType;</a>
<a name="ln1091">			status_t error = fTypeContext-&gt;File()-&gt;EvaluateDynamicValue(</a>
<a name="ln1092">				fTypeContext-&gt;GetCompilationUnit(),</a>
<a name="ln1093">				fTypeContext-&gt;AddressSize(), fTypeContext-&gt;SubprogramEntry(),</a>
<a name="ln1094">				countOwnerEntry-&gt;Count(), fTypeContext-&gt;TargetInterface(),</a>
<a name="ln1095">				fTypeContext-&gt;InstructionPointer(),</a>
<a name="ln1096">				fTypeContext-&gt;FramePointer(), count, &amp;valueType);</a>
<a name="ln1097">			if (error != B_OK) {</a>
<a name="ln1098">				WARNING(&quot;  failed to evaluate count: %s\n&quot;, strerror(error));</a>
<a name="ln1099">				return error;</a>
<a name="ln1100">			}</a>
<a name="ln1101"> </a>
<a name="ln1102">			// If we don't have a base type yet, and the count attribute refers</a>
<a name="ln1103">			// to an object, the type of that object is our base type.</a>
<a name="ln1104">			if (baseTypeEntry == NULL)</a>
<a name="ln1105">				baseTypeEntry = valueType;</a>
<a name="ln1106"> </a>
<a name="ln1107">			// we only support integers</a>
<a name="ln1108">			bool isSigned;</a>
<a name="ln1109">			if (!lowerBound.IsInteger(&amp;isSigned) || !count.IsInteger()) {</a>
<a name="ln1110">				WARNING(&quot;  count given for subrange type, but lower bound or &quot;</a>
<a name="ln1111">					&quot;count is not integer\n&quot;);</a>
<a name="ln1112">				return B_BAD_VALUE;</a>
<a name="ln1113">			}</a>
<a name="ln1114"> </a>
<a name="ln1115">			if (isSigned)</a>
<a name="ln1116">				upperBound.SetTo(lowerBound.ToInt64() + count.ToInt64() - 1);</a>
<a name="ln1117">			else</a>
<a name="ln1118">				upperBound.SetTo(lowerBound.ToUInt64() + count.ToUInt64() - 1);</a>
<a name="ln1119">		}</a>
<a name="ln1120">	}</a>
<a name="ln1121"> </a>
<a name="ln1122">	// create the base type</a>
<a name="ln1123">	Type* baseType = NULL;</a>
<a name="ln1124">	status_t error;</a>
<a name="ln1125">	if (baseTypeEntry != NULL) {</a>
<a name="ln1126">		DwarfType* dwarfBaseType;</a>
<a name="ln1127">		error = CreateType(baseTypeEntry, dwarfBaseType);</a>
<a name="ln1128">		baseType = dwarfBaseType;</a>
<a name="ln1129">	} else {</a>
<a name="ln1130">		// We still don't have a base type yet. In this case the base type is</a>
<a name="ln1131">		// supposed to be a signed integer type with the same size as an address</a>
<a name="ln1132">		// for that compilation unit.</a>
<a name="ln1133">		error = ArtificialIntegerType::Create(</a>
<a name="ln1134">			fTypeContext-&gt;GetCompilationUnit()-&gt;AddressSize(), true, baseType);</a>
<a name="ln1135">	}</a>
<a name="ln1136">	if (error != B_OK)</a>
<a name="ln1137">		return error;</a>
<a name="ln1138">	BReference&lt;Type&gt; baseTypeReference(baseType, true);</a>
<a name="ln1139"> </a>
<a name="ln1140">	// TODO: Support the thread scaling attribute!</a>
<a name="ln1141"> </a>
<a name="ln1142">	// create the type</a>
<a name="ln1143">	DwarfSubrangeType* type = new(std::nothrow) DwarfSubrangeType(fTypeContext,</a>
<a name="ln1144">		name, typeEntry, baseType, lowerBound, upperBound);</a>
<a name="ln1145">	if (type == NULL)</a>
<a name="ln1146">		return B_NO_MEMORY;</a>
<a name="ln1147"> </a>
<a name="ln1148">	_type = type;</a>
<a name="ln1149">	return B_OK;</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152"> </a>
<a name="ln1153">status_t</a>
<a name="ln1154">DwarfTypeFactory::_CreateUnspecifiedType(const BString&amp; name,</a>
<a name="ln1155">	DIEUnspecifiedType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln1156">{</a>
<a name="ln1157">	DwarfUnspecifiedType* type = new(std::nothrow) DwarfUnspecifiedType(</a>
<a name="ln1158">		fTypeContext, name, typeEntry);</a>
<a name="ln1159">	if (type == NULL)</a>
<a name="ln1160">		return B_NO_MEMORY;</a>
<a name="ln1161"> </a>
<a name="ln1162">	_type = type;</a>
<a name="ln1163">	return B_OK;</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">status_t</a>
<a name="ln1167">DwarfTypeFactory::_CreateFunctionType(const BString&amp; name,</a>
<a name="ln1168">	DIESubroutineType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln1169">{</a>
<a name="ln1170">	// get the return type</a>
<a name="ln1171">	DIESubroutineType* returnTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1172">		typeEntry, HasReturnTypePredicate&lt;DIESubroutineType&gt;());</a>
<a name="ln1173"> </a>
<a name="ln1174">	// create the base type</a>
<a name="ln1175">	DwarfType* returnType = NULL;</a>
<a name="ln1176">	if (returnTypeOwnerEntry != NULL) {</a>
<a name="ln1177">		status_t error = CreateType(returnTypeOwnerEntry-&gt;ReturnType(),</a>
<a name="ln1178">			returnType);</a>
<a name="ln1179">		if (error != B_OK)</a>
<a name="ln1180">			return error;</a>
<a name="ln1181">	}</a>
<a name="ln1182">	BReference&lt;Type&gt; returnTypeReference(returnType, true);</a>
<a name="ln1183"> </a>
<a name="ln1184">	DwarfFunctionType* type = new(std::nothrow) DwarfFunctionType(fTypeContext,</a>
<a name="ln1185">		name, typeEntry, returnType);</a>
<a name="ln1186">	if (type == NULL)</a>
<a name="ln1187">		return B_NO_MEMORY;</a>
<a name="ln1188">	BReference&lt;DwarfType&gt; typeReference(type, true);</a>
<a name="ln1189"> </a>
<a name="ln1190">	// get the parameters</a>
<a name="ln1191">	DIESubroutineType* parameterOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1192">		typeEntry, HasParametersPredicate&lt;DIESubroutineType&gt;());</a>
<a name="ln1193"> </a>
<a name="ln1194">	if (parameterOwnerEntry != NULL) {</a>
<a name="ln1195">		for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln1196">					= parameterOwnerEntry-&gt;Parameters().GetIterator();</a>
<a name="ln1197">				DebugInfoEntry* _parameterEntry = it.Next();) {</a>
<a name="ln1198">			if (_parameterEntry-&gt;Tag() == DW_TAG_unspecified_parameters) {</a>
<a name="ln1199">				type-&gt;SetHasVariableArguments(true);</a>
<a name="ln1200">				continue;</a>
<a name="ln1201">			}</a>
<a name="ln1202"> </a>
<a name="ln1203">			DIEFormalParameter* parameterEntry</a>
<a name="ln1204">				= dynamic_cast&lt;DIEFormalParameter*&gt;(_parameterEntry);</a>
<a name="ln1205"> </a>
<a name="ln1206">			// get the type</a>
<a name="ln1207">			DIEFormalParameter* typeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1208">				parameterEntry, HasTypePredicate&lt;DIEFormalParameter&gt;());</a>
<a name="ln1209">			if (typeOwnerEntry == NULL)</a>
<a name="ln1210">				return B_BAD_VALUE;</a>
<a name="ln1211"> </a>
<a name="ln1212">			DwarfType* parameterType;</a>
<a name="ln1213">			status_t error = CreateType(typeOwnerEntry-&gt;GetType(),</a>
<a name="ln1214">				parameterType);</a>
<a name="ln1215">			if (error != B_OK)</a>
<a name="ln1216">				return error;</a>
<a name="ln1217">			BReference&lt;DwarfType&gt; parameterTypeReference(parameterType, true);</a>
<a name="ln1218"> </a>
<a name="ln1219">			// get the name</a>
<a name="ln1220">			BString parameterName;</a>
<a name="ln1221">			DwarfUtils::GetDIEName(parameterEntry, parameterName);</a>
<a name="ln1222"> </a>
<a name="ln1223">			// create and add the parameter object</a>
<a name="ln1224">			DwarfFunctionParameter* parameter</a>
<a name="ln1225">				= new(std::nothrow) DwarfFunctionParameter(parameterEntry,</a>
<a name="ln1226">					parameterName, parameterType);</a>
<a name="ln1227">			BReference&lt;DwarfFunctionParameter&gt; parameterReference(parameter,</a>
<a name="ln1228">				true);</a>
<a name="ln1229">			if (parameter == NULL || !type-&gt;AddParameter(parameter))</a>
<a name="ln1230">				return B_NO_MEMORY;</a>
<a name="ln1231">		}</a>
<a name="ln1232">	}</a>
<a name="ln1233"> </a>
<a name="ln1234"> </a>
<a name="ln1235">	_type = typeReference.Detach();</a>
<a name="ln1236">	return B_OK;</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239"> </a>
<a name="ln1240">status_t</a>
<a name="ln1241">DwarfTypeFactory::_CreatePointerToMemberType(const BString&amp; name,</a>
<a name="ln1242">	DIEPointerToMemberType* typeEntry, DwarfType*&amp; _type)</a>
<a name="ln1243">{</a>
<a name="ln1244">	// get the containing and base type entries</a>
<a name="ln1245">	DIEPointerToMemberType* containingTypeOwnerEntry</a>
<a name="ln1246">		= DwarfUtils::GetDIEByPredicate(typeEntry,</a>
<a name="ln1247">			HasContainingTypePredicate());</a>
<a name="ln1248">	DIEPointerToMemberType* baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1249">		typeEntry, HasTypePredicate&lt;DIEPointerToMemberType&gt;());</a>
<a name="ln1250"> </a>
<a name="ln1251">	if (containingTypeOwnerEntry == NULL || baseTypeOwnerEntry == NULL) {</a>
<a name="ln1252">		WARNING(&quot;Failed to get containing or base type for pointer to member &quot;</a>
<a name="ln1253">			&quot;type \&quot;%s\&quot;\n&quot;, name.String());</a>
<a name="ln1254">		return B_BAD_VALUE;</a>
<a name="ln1255">	}</a>
<a name="ln1256"> </a>
<a name="ln1257">	// create the containing type</a>
<a name="ln1258">	DwarfType* containingType;</a>
<a name="ln1259">	status_t error = CreateType(containingTypeOwnerEntry-&gt;ContainingType(),</a>
<a name="ln1260">		containingType);</a>
<a name="ln1261">	if (error != B_OK)</a>
<a name="ln1262">		return error;</a>
<a name="ln1263">	BReference&lt;Type&gt; containingTypeReference(containingType, true);</a>
<a name="ln1264"> </a>
<a name="ln1265">	DwarfCompoundType* compoundContainingType</a>
<a name="ln1266">		= dynamic_cast&lt;DwarfCompoundType*&gt;(containingType);</a>
<a name="ln1267">	if (compoundContainingType == NULL) {</a>
<a name="ln1268">		WARNING(&quot;Containing type for pointer to member type \&quot;%s\&quot; is not a &quot;</a>
<a name="ln1269">			&quot;compound type.\n&quot;, name.String());</a>
<a name="ln1270">		return B_BAD_VALUE;</a>
<a name="ln1271">	}</a>
<a name="ln1272"> </a>
<a name="ln1273">	// create the base type</a>
<a name="ln1274">	DwarfType* baseType;</a>
<a name="ln1275">	error = CreateType(baseTypeOwnerEntry-&gt;GetType(), baseType);</a>
<a name="ln1276">	if (error != B_OK)</a>
<a name="ln1277">		return error;</a>
<a name="ln1278">	BReference&lt;Type&gt; baseTypeReference(baseType, true);</a>
<a name="ln1279"> </a>
<a name="ln1280">	// create the type object</a>
<a name="ln1281">	DwarfPointerToMemberType* type = new(std::nothrow) DwarfPointerToMemberType(</a>
<a name="ln1282">		fTypeContext, name, typeEntry, compoundContainingType, baseType);</a>
<a name="ln1283">	if (type == NULL)</a>
<a name="ln1284">		return B_NO_MEMORY;</a>
<a name="ln1285"> </a>
<a name="ln1286">	_type = type;</a>
<a name="ln1287">	return B_OK;</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290"> </a>
<a name="ln1291">status_t</a>
<a name="ln1292">DwarfTypeFactory::_ResolveTypedef(DIETypedef* entry,</a>
<a name="ln1293">	DIEType*&amp; _baseTypeEntry)</a>
<a name="ln1294">{</a>
<a name="ln1295">	while (true) {</a>
<a name="ln1296">		// resolve the base type, possibly following abstract origin or</a>
<a name="ln1297">		// specification</a>
<a name="ln1298">		DIETypedef* baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1299">			entry, HasTypePredicate&lt;DIETypedef&gt;());</a>
<a name="ln1300">		if (baseTypeOwnerEntry == NULL)</a>
<a name="ln1301">			return B_BAD_VALUE;</a>
<a name="ln1302"> </a>
<a name="ln1303">		DIEType* baseTypeEntry = baseTypeOwnerEntry-&gt;GetType();</a>
<a name="ln1304">		if (baseTypeEntry-&gt;Tag() != DW_TAG_typedef) {</a>
<a name="ln1305">			_baseTypeEntry = baseTypeEntry;</a>
<a name="ln1306">			return B_OK;</a>
<a name="ln1307">		}</a>
<a name="ln1308"> </a>
<a name="ln1309">		entry = dynamic_cast&lt;DIETypedef*&gt;(baseTypeEntry);</a>
<a name="ln1310">	}</a>
<a name="ln1311">}</a>
<a name="ln1312"> </a>
<a name="ln1313"> </a>
<a name="ln1314">status_t</a>
<a name="ln1315">DwarfTypeFactory::_ResolveTypeByteSize(DIEType* typeEntry,</a>
<a name="ln1316">	uint64&amp; _size)</a>
<a name="ln1317">{</a>
<a name="ln1318">	TRACE_LOCALS(&quot;DwarfTypeFactory::_ResolveTypeByteSize(%p)\n&quot;,</a>
<a name="ln1319">		typeEntry);</a>
<a name="ln1320"> </a>
<a name="ln1321">	// get the size attribute</a>
<a name="ln1322">	const DynamicAttributeValue* sizeValue;</a>
<a name="ln1323"> </a>
<a name="ln1324">	while (true) {</a>
<a name="ln1325">		// resolve a typedef</a>
<a name="ln1326">		if (typeEntry-&gt;Tag() == DW_TAG_typedef) {</a>
<a name="ln1327">			TRACE_LOCALS(&quot;  resolving typedef...\n&quot;);</a>
<a name="ln1328"> </a>
<a name="ln1329">			status_t error = _ResolveTypedef(</a>
<a name="ln1330">				dynamic_cast&lt;DIETypedef*&gt;(typeEntry), typeEntry);</a>
<a name="ln1331">			if (error != B_OK)</a>
<a name="ln1332">				return error;</a>
<a name="ln1333">		}</a>
<a name="ln1334"> </a>
<a name="ln1335">		sizeValue = typeEntry-&gt;ByteSize();</a>
<a name="ln1336">		if (sizeValue != NULL &amp;&amp; sizeValue-&gt;IsValid())</a>
<a name="ln1337">			break;</a>
<a name="ln1338"> </a>
<a name="ln1339">		// resolve abstract origin</a>
<a name="ln1340">		if (DIEType* abstractOrigin = dynamic_cast&lt;DIEType*&gt;(</a>
<a name="ln1341">				typeEntry-&gt;AbstractOrigin())) {</a>
<a name="ln1342">			TRACE_LOCALS(&quot;  resolving abstract origin (%p)...\n&quot;,</a>
<a name="ln1343">				abstractOrigin);</a>
<a name="ln1344"> </a>
<a name="ln1345">			typeEntry = abstractOrigin;</a>
<a name="ln1346">			sizeValue = typeEntry-&gt;ByteSize();</a>
<a name="ln1347">			if (sizeValue != NULL &amp;&amp; sizeValue-&gt;IsValid())</a>
<a name="ln1348">				break;</a>
<a name="ln1349">		}</a>
<a name="ln1350"> </a>
<a name="ln1351">		// resolve specification</a>
<a name="ln1352">		if (DIEType* specification = dynamic_cast&lt;DIEType*&gt;(</a>
<a name="ln1353">				typeEntry-&gt;Specification())) {</a>
<a name="ln1354">			TRACE_LOCALS(&quot;  resolving specification (%p)...\n&quot;, specification);</a>
<a name="ln1355"> </a>
<a name="ln1356">			typeEntry = specification;</a>
<a name="ln1357">			sizeValue = typeEntry-&gt;ByteSize();</a>
<a name="ln1358">			if (sizeValue != NULL &amp;&amp; sizeValue-&gt;IsValid())</a>
<a name="ln1359">				break;</a>
<a name="ln1360">		}</a>
<a name="ln1361"> </a>
<a name="ln1362">		// For some types we have a special handling. For modified types we</a>
<a name="ln1363">		// follow the base type, for address types we know the size anyway.</a>
<a name="ln1364">		TRACE_LOCALS(&quot;  nothing yet, special type handling\n&quot;);</a>
<a name="ln1365"> </a>
<a name="ln1366">		switch (typeEntry-&gt;Tag()) {</a>
<a name="ln1367">			case DW_TAG_const_type:</a>
<a name="ln1368">			case DW_TAG_packed_type:</a>
<a name="ln1369">			case DW_TAG_volatile_type:</a>
<a name="ln1370">			case DW_TAG_restrict_type:</a>
<a name="ln1371">			case DW_TAG_shared_type:</a>
<a name="ln1372">				typeEntry = dynamic_cast&lt;DIEModifiedType*&gt;(typeEntry)</a>
<a name="ln1373">					-&gt;GetType();</a>
<a name="ln1374"> </a>
<a name="ln1375">				TRACE_LOCALS(&quot;  following modified type -&gt; %p\n&quot;, typeEntry);</a>
<a name="ln1376"> </a>
<a name="ln1377">				if (typeEntry == NULL)</a>
<a name="ln1378">					return B_ENTRY_NOT_FOUND;</a>
<a name="ln1379">				break;</a>
<a name="ln1380">			case DW_TAG_pointer_type:</a>
<a name="ln1381">			case DW_TAG_reference_type:</a>
<a name="ln1382">			case DW_TAG_ptr_to_member_type:</a>
<a name="ln1383">				_size = fTypeContext-&gt;GetCompilationUnit()-&gt;AddressSize();</a>
<a name="ln1384"> </a>
<a name="ln1385">				TRACE_LOCALS(&quot;  pointer/reference type: size: %&quot; B_PRIu64 &quot;\n&quot;,</a>
<a name="ln1386">					_size);</a>
<a name="ln1387"> </a>
<a name="ln1388">				return B_OK;</a>
<a name="ln1389">			default:</a>
<a name="ln1390">				return B_ENTRY_NOT_FOUND;</a>
<a name="ln1391">		}</a>
<a name="ln1392">	}</a>
<a name="ln1393"> </a>
<a name="ln1394">	TRACE_LOCALS(&quot;  found attribute\n&quot;);</a>
<a name="ln1395"> </a>
<a name="ln1396">	// get the actual value</a>
<a name="ln1397">	BVariant size;</a>
<a name="ln1398">	status_t error = fTypeContext-&gt;File()-&gt;EvaluateDynamicValue(</a>
<a name="ln1399">		fTypeContext-&gt;GetCompilationUnit(), fTypeContext-&gt;AddressSize(),</a>
<a name="ln1400">		fTypeContext-&gt;SubprogramEntry(), sizeValue,</a>
<a name="ln1401">		fTypeContext-&gt;TargetInterface(), fTypeContext-&gt;InstructionPointer(),</a>
<a name="ln1402">		fTypeContext-&gt;FramePointer(), size);</a>
<a name="ln1403">	if (error != B_OK) {</a>
<a name="ln1404">		TRACE_LOCALS(&quot;  failed to resolve attribute: %s\n&quot;, strerror(error));</a>
<a name="ln1405">		return error;</a>
<a name="ln1406">	}</a>
<a name="ln1407"> </a>
<a name="ln1408">	_size = size.ToUInt64();</a>
<a name="ln1409"> </a>
<a name="ln1410">	TRACE_LOCALS(&quot;  -&gt; size: %&quot; B_PRIu64 &quot;\n&quot;, _size);</a>
<a name="ln1411"> </a>
<a name="ln1412">	return B_OK;</a>
<a name="ln1413">}</a>

</code></pre>
<div class="balloon" rel="792"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'baseTypeEntry' pointer was utilized before it was verified against nullptr. Check lines: 792, 799.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
