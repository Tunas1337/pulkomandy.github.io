
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar9300_mci.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 2013 Qualcomm Atheros, Inc.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln5"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln6"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln7"> *</a>
<a name="ln8"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH</a>
<a name="ln9"> * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</a>
<a name="ln10"> * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,</a>
<a name="ln11"> * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM</a>
<a name="ln12"> * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR</a>
<a name="ln13"> * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</a>
<a name="ln14"> * PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln15"> */</a>
<a name="ln16"> </a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;opt_ah.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;ah.h&quot;</a>
<a name="ln21">#include &quot;ah_internal.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;ar9300/ar9300.h&quot;</a>
<a name="ln24">#include &quot;ar9300/ar9300reg.h&quot;</a>
<a name="ln25">#include &quot;ar9300/ar9300phy.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#if ATH_SUPPORT_MCI</a>
<a name="ln28"> </a>
<a name="ln29">#define AH_MCI_REMOTE_RESET_INTERVAL_US     500</a>
<a name="ln30">#define AH_MCI_DEBUG_PRINT_SCHED    0</a>
<a name="ln31"> </a>
<a name="ln32">static void ar9300_mci_print_msg(struct ath_hal *ah, HAL_BOOL send,u_int8_t hdr,</a>
<a name="ln33">                                 int len, u_int32_t *pl)</a>
<a name="ln34">{</a>
<a name="ln35">#if 0</a>
<a name="ln36">    char s[128];</a>
<a name="ln37">    char *p = s;</a>
<a name="ln38">    int i;</a>
<a name="ln39">    u_int8_t *p_data = (u_int8_t *) pl;</a>
<a name="ln40">    </a>
<a name="ln41">    if (send) {</a>
<a name="ln42">        p += snprintf(s, 60,</a>
<a name="ln43">                      &quot;(MCI) &gt;&gt;&gt;&gt;&gt; Hdr: %02X, Len: %d, Payload:&quot;, hdr, len);</a>
<a name="ln44">    }</a>
<a name="ln45">    else {</a>
<a name="ln46">        p += snprintf(s, 60,</a>
<a name="ln47">                      &quot;(MCI) &lt;&lt;&lt;&lt;&lt; Hdr: %02X, Len: %d, Payload:&quot;, hdr, len);</a>
<a name="ln48">    }</a>
<a name="ln49">    for ( i=0; i&lt;len; i++)</a>
<a name="ln50">    {</a>
<a name="ln51">        p += snprintf(p, 60, &quot; %02x&quot;, *(p_data + i));</a>
<a name="ln52">    }</a>
<a name="ln53">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s\n&quot;, s);</a>
<a name="ln54">/*</a>
<a name="ln55">    for ( i=0; i&lt;(len + 3)/4; i++)</a>
<a name="ln56">    {</a>
<a name="ln57">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI)   0x%08x\n&quot;, *(pl + i));</a>
<a name="ln58">    }</a>
<a name="ln59">*/</a>
<a name="ln60">#endif</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">static</a>
<a name="ln64">void ar9300_mci_osla_setup(struct ath_hal *ah, HAL_BOOL enable)</a>
<a name="ln65">{</a>
<a name="ln66">//    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln67">    u_int32_t thresh;</a>
<a name="ln68"> </a>
<a name="ln69">    if (enable) {</a>
<a name="ln70">        OS_REG_RMW_FIELD(ah, AR_MCI_SCHD_TABLE_2, AR_MCI_SCHD_TABLE_2_HW_BASED, 1);</a>
<a name="ln71">        OS_REG_RMW_FIELD(ah, AR_MCI_SCHD_TABLE_2, AR_MCI_SCHD_TABLE_2_MEM_BASED, 1);</a>
<a name="ln72"> </a>
<a name="ln73">        if (!(ah-&gt;ah_config.ath_hal_mci_config &amp;</a>
<a name="ln74">            ATH_MCI_CONFIG_DISABLE_AGGR_THRESH))</a>
<a name="ln75">        {</a>
<a name="ln76"> </a>
<a name="ln77">            if (AR_SREV_APHRODITE(ah))</a>
<a name="ln78">                OS_REG_RMW_FIELD(ah, AR_MCI_MISC, AR_MCI_MISC_HW_FIX_EN, 1);</a>
<a name="ln79"> </a>
<a name="ln80">            thresh = MS(ah-&gt;ah_config.ath_hal_mci_config,</a>
<a name="ln81">                        ATH_MCI_CONFIG_AGGR_THRESH);</a>
<a name="ln82">            OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL,</a>
<a name="ln83">                             AR_BTCOEX_CTRL_AGGR_THRESH, thresh);</a>
<a name="ln84">            OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL,</a>
<a name="ln85">                             AR_BTCOEX_CTRL_TIME_TO_NEXT_BT_THRESH_EN, 1);</a>
<a name="ln86">            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln87">                &quot;(MCI) SCHED aggr thresh: on, thresh=%d (%d.%d%%)\n&quot;,</a>
<a name="ln88">                thresh, (thresh + 1)*125/10, (thresh + 1)*125%10);</a>
<a name="ln89"> </a>
<a name="ln90">        }</a>
<a name="ln91">        else {</a>
<a name="ln92">            OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL,</a>
<a name="ln93">                             AR_BTCOEX_CTRL_TIME_TO_NEXT_BT_THRESH_EN, 0);</a>
<a name="ln94">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) SCHED aggr thresh: off\n&quot;);</a>
<a name="ln95">        }</a>
<a name="ln96">        OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL,</a>
<a name="ln97">                         AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN, 1);</a>
<a name="ln98">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) SCHED one step look ahead: on\n&quot;);</a>
<a name="ln99">    }</a>
<a name="ln100">    else {</a>
<a name="ln101">        OS_REG_CLR_BIT(ah, AR_BTCOEX_CTRL, </a>
<a name="ln102">            AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);</a>
<a name="ln103">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) SCHED one step look ahead: off\n&quot;);</a>
<a name="ln104">    }</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">static void ar9300_mci_reset_req_wakeup(struct ath_hal *ah)</a>
<a name="ln108">{</a>
<a name="ln109">    /* to be tested in emulation */</a>
<a name="ln110">    if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln111">        OS_REG_RMW_FIELD(ah, AR_MCI_COMMAND2,</a>
<a name="ln112">            AR_MCI_COMMAND2_RESET_REQ_WAKEUP, 1);</a>
<a name="ln113">        OS_DELAY(1);</a>
<a name="ln114">        OS_REG_RMW_FIELD(ah, AR_MCI_COMMAND2,</a>
<a name="ln115">            AR_MCI_COMMAND2_RESET_REQ_WAKEUP, 0);</a>
<a name="ln116">    }</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">static int32_t ar9300_mci_wait_for_interrupt(struct ath_hal *ah,</a>
<a name="ln120">                                             u_int32_t address, </a>
<a name="ln121">                                             u_int32_t bit_position,</a>
<a name="ln122">                                             int32_t time_out)</a>
<a name="ln123">{</a>
<a name="ln124">    int data; //, loop;</a>
<a name="ln125"> </a>
<a name="ln126">    while (time_out) {</a>
<a name="ln127">        data = OS_REG_READ(ah, address);</a>
<a name="ln128"> </a>
<a name="ln129">        if (data &amp; bit_position) {</a>
<a name="ln130">            OS_REG_WRITE(ah, address, bit_position);</a>
<a name="ln131">            if (address == AR_MCI_INTERRUPT_RX_MSG_RAW) {</a>
<a name="ln132">                if (bit_position &amp; AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE) {</a>
<a name="ln133">                    ar9300_mci_reset_req_wakeup(ah);</a>
<a name="ln134">                }</a>
<a name="ln135">                if (bit_position &amp; (AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING |</a>
<a name="ln136">                                    AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING))</a>
<a name="ln137">                {</a>
<a name="ln138">                    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RAW,</a>
<a name="ln139">                        AR_MCI_INTERRUPT_REMOTE_SLEEP_UPDATE);</a>
<a name="ln140">                }</a>
<a name="ln141">                OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RAW, AR_MCI_INTERRUPT_RX_MSG);</a>
<a name="ln142">            }</a>
<a name="ln143">            break;</a>
<a name="ln144">        }</a>
<a name="ln145"> </a>
<a name="ln146">        OS_DELAY(10);</a>
<a name="ln147">        time_out -= 10;</a>
<a name="ln148">        if (time_out &lt; 0) {</a>
<a name="ln149">            break;</a>
<a name="ln150">        }</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153">    if (time_out &lt;= 0) {</a>
<a name="ln154">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln155">            &quot;(MCI) %s: Wait for Reg0x%08x = 0x%08x timeout.\n&quot;,</a>
<a name="ln156">            __func__, address, bit_position);</a>
<a name="ln157">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln158">            &quot;(MCI) INT_RAW = 0x%08x, RX_MSG_RAW = 0x%08x\n&quot;,</a>
<a name="ln159">            OS_REG_READ(ah, AR_MCI_INTERRUPT_RAW),</a>
<a name="ln160">            OS_REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW));</a>
<a name="ln161">        time_out = 0;</a>
<a name="ln162">    }</a>
<a name="ln163">    return time_out;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">void ar9300_mci_remote_reset(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln167">{</a>
<a name="ln168">    u_int32_t payload[4] = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffff00};</a>
<a name="ln169"> </a>
<a name="ln170">    ar9300_mci_send_message(ah, MCI_REMOTE_RESET, 0, payload, 16, </a>
<a name="ln171">        wait_done, AH_FALSE);</a>
<a name="ln172"> </a>
<a name="ln173">    OS_DELAY(5);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">void ar9300_mci_send_lna_transfer(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln177">{</a>
<a name="ln178">    u_int32_t payload = 0x00000000;</a>
<a name="ln179"> </a>
<a name="ln180">    ar9300_mci_send_message(ah, MCI_LNA_TRANS, 0, &amp;payload, 1, </a>
<a name="ln181">        wait_done, AH_FALSE);</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">static void ar9300_mci_send_req_wake(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln185">{</a>
<a name="ln186">    ar9300_mci_send_message(ah, MCI_REQ_WAKE, </a>
<a name="ln187">        HAL_MCI_FLAG_DISABLE_TIMESTAMP, AH_NULL, 0, wait_done, AH_FALSE);</a>
<a name="ln188"> </a>
<a name="ln189">    OS_DELAY(5);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">void ar9300_mci_send_sys_waking(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln193">{</a>
<a name="ln194">    ar9300_mci_send_message(ah, MCI_SYS_WAKING, </a>
<a name="ln195">        HAL_MCI_FLAG_DISABLE_TIMESTAMP, AH_NULL, 0, wait_done, AH_FALSE);</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">static void ar9300_mci_send_lna_take(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln199">{</a>
<a name="ln200">    u_int32_t payload = 0x70000000;</a>
<a name="ln201"> </a>
<a name="ln202">    /* LNA gain index is set to 7. */</a>
<a name="ln203">    ar9300_mci_send_message(ah, MCI_LNA_TAKE, </a>
<a name="ln204">        HAL_MCI_FLAG_DISABLE_TIMESTAMP, &amp;payload, 1, wait_done, AH_FALSE);</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">static void ar9300_mci_send_sys_sleeping(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln208">{</a>
<a name="ln209">    ar9300_mci_send_message(ah, MCI_SYS_SLEEPING, </a>
<a name="ln210">        HAL_MCI_FLAG_DISABLE_TIMESTAMP, AH_NULL, 0, wait_done, AH_FALSE);</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static void</a>
<a name="ln214">ar9300_mci_send_coex_version_query(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln215">{</a>
<a name="ln216">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln217">    u_int32_t payload[4] = {0, 0, 0, 0};</a>
<a name="ln218"> </a>
<a name="ln219">    if ((ahp-&gt;ah_mci_coex_bt_version_known == AH_FALSE) &amp;&amp;</a>
<a name="ln220">        (ahp-&gt;ah_mci_bt_state != MCI_BT_SLEEP)) {</a>
<a name="ln221">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) Send Coex version query.\n&quot;);</a>
<a name="ln222">        MCI_GPM_SET_TYPE_OPCODE(payload,</a>
<a name="ln223">            MCI_GPM_COEX_AGENT, MCI_GPM_COEX_VERSION_QUERY);</a>
<a name="ln224">        ar9300_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, AH_TRUE);</a>
<a name="ln225">    }</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">static void</a>
<a name="ln229">ar9300_mci_send_coex_version_response(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln230">{</a>
<a name="ln231">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln232">    u_int32_t payload[4] = {0, 0, 0, 0};</a>
<a name="ln233"> </a>
<a name="ln234">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) Send Coex version response.\n&quot;);</a>
<a name="ln235">    MCI_GPM_SET_TYPE_OPCODE(payload,</a>
<a name="ln236">        MCI_GPM_COEX_AGENT, MCI_GPM_COEX_VERSION_RESPONSE);</a>
<a name="ln237">    *(((u_int8_t *)payload) + MCI_GPM_COEX_B_MAJOR_VERSION) =</a>
<a name="ln238">        ahp-&gt;ah_mci_coex_major_version_wlan;</a>
<a name="ln239">    *(((u_int8_t *)payload) + MCI_GPM_COEX_B_MINOR_VERSION) =</a>
<a name="ln240">        ahp-&gt;ah_mci_coex_minor_version_wlan;</a>
<a name="ln241">    ar9300_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, AH_TRUE);</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">static void</a>
<a name="ln245">ar9300_mci_send_coex_wlan_channels(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln246">{</a>
<a name="ln247">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln248">    u_int32_t *payload = &amp;ahp-&gt;ah_mci_coex_wlan_channels[0];</a>
<a name="ln249"> </a>
<a name="ln250">    if ((ahp-&gt;ah_mci_coex_wlan_channels_update == AH_TRUE) &amp;&amp;</a>
<a name="ln251">        (ahp-&gt;ah_mci_bt_state != MCI_BT_SLEEP))</a>
<a name="ln252">    {</a>
<a name="ln253">        MCI_GPM_SET_TYPE_OPCODE(payload,</a>
<a name="ln254">            MCI_GPM_COEX_AGENT, MCI_GPM_COEX_WLAN_CHANNELS);</a>
<a name="ln255">        ar9300_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, AH_TRUE);</a>
<a name="ln256">        MCI_GPM_SET_TYPE_OPCODE(payload, 0xff, 0xff);</a>
<a name="ln257">    }</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">static void ar9300_mci_send_coex_bt_status_query(struct ath_hal *ah,</a>
<a name="ln261">                                    HAL_BOOL wait_done, u_int8_t query_type)</a>
<a name="ln262">{</a>
<a name="ln263">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln264">    u_int32_t pld[4] = {0, 0, 0, 0};</a>
<a name="ln265">    HAL_BOOL query_btinfo = query_type &amp;</a>
<a name="ln266">            (MCI_GPM_COEX_QUERY_BT_ALL_INFO | MCI_GPM_COEX_QUERY_BT_TOPOLOGY);</a>
<a name="ln267"> </a>
<a name="ln268">    if (ahp-&gt;ah_mci_bt_state != MCI_BT_SLEEP) {</a>
<a name="ln269">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln270">            &quot;(MCI) Send Coex BT Status Query 0x%02X\n&quot;, query_type);</a>
<a name="ln271">        MCI_GPM_SET_TYPE_OPCODE(pld,</a>
<a name="ln272">            MCI_GPM_COEX_AGENT, MCI_GPM_COEX_STATUS_QUERY);</a>
<a name="ln273">        *(((u_int8_t *)pld) + MCI_GPM_COEX_B_BT_BITMAP) = query_type;</a>
<a name="ln274">        /*</a>
<a name="ln275">         * If bt_status_query message is thought not sent successfully,</a>
<a name="ln276">         * then ah_mci_need_flush_btinfo should be set again.</a>
<a name="ln277">         */</a>
<a name="ln278">        if (!ar9300_mci_send_message(ah, MCI_GPM, 0, pld, 16, wait_done, AH_TRUE))</a>
<a name="ln279">        {</a>
<a name="ln280">            if (query_btinfo) {</a>
<a name="ln281">                ahp-&gt;ah_mci_need_flush_btinfo = AH_TRUE;</a>
<a name="ln282">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln283">                    &quot;(MCI) send bt_status_query fail, set flush flag again\n&quot;);</a>
<a name="ln284">            }</a>
<a name="ln285">        }</a>
<a name="ln286">        if (query_btinfo) {</a>
<a name="ln287">            ahp-&gt;ah_mci_query_bt = AH_FALSE;</a>
<a name="ln288">        }</a>
<a name="ln289">    }</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">void ar9300_mci_send_coex_halt_bt_gpm(struct ath_hal *ah,</a>
<a name="ln293">                                      HAL_BOOL halt, HAL_BOOL wait_done)</a>
<a name="ln294">{</a>
<a name="ln295">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln296">    u_int32_t payload[4] = {0, 0, 0, 0};</a>
<a name="ln297"> </a>
<a name="ln298">    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln299">        &quot;(MCI) Send Coex %s BT GPM.\n&quot;, (halt == AH_TRUE)?&quot;HALT&quot;:&quot;UNHALT&quot;);</a>
<a name="ln300"> </a>
<a name="ln301">    MCI_GPM_SET_TYPE_OPCODE(payload,</a>
<a name="ln302">        MCI_GPM_COEX_AGENT, MCI_GPM_COEX_HALT_BT_GPM);</a>
<a name="ln303">    if (halt == AH_TRUE) {</a>
<a name="ln304">        ahp-&gt;ah_mci_query_bt = AH_TRUE;</a>
<a name="ln305">        /* Send next UNHALT no matter HALT sent or not */</a>
<a name="ln306">        ahp-&gt;ah_mci_unhalt_bt_gpm = AH_TRUE;</a>
<a name="ln307">        ahp-&gt;ah_mci_need_flush_btinfo = AH_TRUE;</a>
<a name="ln308">        *(((u_int8_t *)payload) + MCI_GPM_COEX_B_HALT_STATE) =</a>
<a name="ln309">            MCI_GPM_COEX_BT_GPM_HALT;</a>
<a name="ln310">    }</a>
<a name="ln311">    else {</a>
<a name="ln312">        *(((u_int8_t *)payload) + MCI_GPM_COEX_B_HALT_STATE) =</a>
<a name="ln313">            MCI_GPM_COEX_BT_GPM_UNHALT;</a>
<a name="ln314">    }</a>
<a name="ln315">    ar9300_mci_send_message(ah, MCI_GPM, 0, payload, 16, wait_done, AH_TRUE);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">static HAL_BOOL ar9300_mci_send_coex_bt_flags(struct ath_hal *ah, HAL_BOOL wait_done,</a>
<a name="ln319">                                          u_int8_t opcode, u_int32_t bt_flags)</a>
<a name="ln320">{</a>
<a name="ln321">//    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln322">    u_int32_t pld[4] = {0, 0, 0, 0};</a>
<a name="ln323"> </a>
<a name="ln324">    MCI_GPM_SET_TYPE_OPCODE(pld,</a>
<a name="ln325">        MCI_GPM_COEX_AGENT, MCI_GPM_COEX_BT_UPDATE_FLAGS);</a>
<a name="ln326"> </a>
<a name="ln327">    *(((u_int8_t *)pld) + MCI_GPM_COEX_B_BT_FLAGS_OP)  = opcode;</a>
<a name="ln328">    *(((u_int8_t *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 0) = bt_flags &amp; 0xFF;</a>
<a name="ln329">    *(((u_int8_t *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 1) =</a>
<a name="ln330">        (bt_flags &gt;&gt; 8) &amp; 0xFF;</a>
<a name="ln331">    *(((u_int8_t *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 2) =</a>
<a name="ln332">        (bt_flags &gt;&gt; 16) &amp; 0xFF;</a>
<a name="ln333">    *(((u_int8_t *)pld) + MCI_GPM_COEX_W_BT_FLAGS + 3) =</a>
<a name="ln334">        (bt_flags &gt;&gt; 24) &amp; 0xFF;</a>
<a name="ln335"> </a>
<a name="ln336">    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln337">        &quot;(MCI) BT_MCI_FLAGS: Send Coex BT Update Flags %s 0x%08x\n&quot;,</a>
<a name="ln338">            (opcode == MCI_GPM_COEX_BT_FLAGS_READ)?&quot;READ&quot;:</a>
<a name="ln339">            ((opcode == MCI_GPM_COEX_BT_FLAGS_SET)?&quot;SET&quot;:&quot;CLEAR&quot;),</a>
<a name="ln340">            bt_flags);</a>
<a name="ln341"> </a>
<a name="ln342">    return ar9300_mci_send_message(ah, MCI_GPM, 0, pld, 16, wait_done, AH_TRUE);</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">void ar9300_mci_2g5g_changed(struct ath_hal *ah, HAL_BOOL is_2g)</a>
<a name="ln346">{</a>
<a name="ln347">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln348"> </a>
<a name="ln349">    if (ahp-&gt;ah_mci_coex_2g5g_update == AH_FALSE) {</a>
<a name="ln350">        if (ahp-&gt;ah_mci_coex_is_2g == is_2g) {</a>
<a name="ln351">            //HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) BT_MCI_FLAGS: not changed\n&quot;);</a>
<a name="ln352">        } else {</a>
<a name="ln353">            ahp-&gt;ah_mci_coex_2g5g_update = AH_TRUE;</a>
<a name="ln354">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) BT_MCI_FLAGS: changed\n&quot;);</a>
<a name="ln355">        }</a>
<a name="ln356">    } else {</a>
<a name="ln357">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) BT_MCI_FLAGS: force send\n&quot;);</a>
<a name="ln358">    }</a>
<a name="ln359">    ahp-&gt;ah_mci_coex_is_2g = is_2g;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">static void ar9300_mci_send_2g5g_status(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln363">{</a>
<a name="ln364">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln365">    u_int32_t new_flags, to_set, to_clear;</a>
<a name="ln366"> </a>
<a name="ln367">    if ((AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) &amp;&amp;</a>
<a name="ln368">        (ahp-&gt;ah_mci_coex_2g5g_update == AH_TRUE) &amp;&amp;</a>
<a name="ln369">        (ahp-&gt;ah_mci_bt_state != MCI_BT_SLEEP))</a>
<a name="ln370">    {</a>
<a name="ln371">        if (ahp-&gt;ah_mci_coex_is_2g) {</a>
<a name="ln372">            new_flags = HAL_MCI_2G_FLAGS;</a>
<a name="ln373">            to_clear = HAL_MCI_2G_FLAGS_CLEAR_MASK;</a>
<a name="ln374">            to_set = HAL_MCI_2G_FLAGS_SET_MASK;</a>
<a name="ln375">        } else {</a>
<a name="ln376">            new_flags = HAL_MCI_5G_FLAGS;</a>
<a name="ln377">            to_clear = HAL_MCI_5G_FLAGS_CLEAR_MASK;</a>
<a name="ln378">            to_set = HAL_MCI_5G_FLAGS_SET_MASK;</a>
<a name="ln379">        }</a>
<a name="ln380">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln381">            &quot;(MCI) BT_MCI_FLAGS: %s (0x%08x) clr=0x%08x, set=0x%08x\n&quot;,</a>
<a name="ln382">            ahp-&gt;ah_mci_coex_is_2g?&quot;2G&quot;:&quot;5G&quot;, new_flags, to_clear, to_set);</a>
<a name="ln383">        if (to_clear) {</a>
<a name="ln384">            ar9300_mci_send_coex_bt_flags(ah, wait_done,</a>
<a name="ln385">                MCI_GPM_COEX_BT_FLAGS_CLEAR, to_clear);</a>
<a name="ln386">        }</a>
<a name="ln387">        if (to_set) {</a>
<a name="ln388">            ar9300_mci_send_coex_bt_flags(ah, wait_done,</a>
<a name="ln389">                MCI_GPM_COEX_BT_FLAGS_SET, to_set);</a>
<a name="ln390">        }</a>
<a name="ln391">    }</a>
<a name="ln392">    if (AR_SREV_JUPITER_10(ah) &amp;&amp; (ahp-&gt;ah_mci_bt_state != MCI_BT_SLEEP)) {</a>
<a name="ln393">        ahp-&gt;ah_mci_coex_2g5g_update = AH_FALSE;</a>
<a name="ln394">    }</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">void ar9300_mci_2g5g_switch(struct ath_hal *ah, HAL_BOOL wait_done)</a>
<a name="ln398">{</a>
<a name="ln399">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln400"> </a>
<a name="ln401">    if (ahp-&gt;ah_mci_coex_2g5g_update)</a>
<a name="ln402">    {</a>
<a name="ln403">        if (ahp-&gt;ah_mci_coex_is_2g) {</a>
<a name="ln404">            ar9300_mci_send_2g5g_status(ah, AH_TRUE);</a>
<a name="ln405"> </a>
<a name="ln406">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) Send LNA trans\n&quot;);</a>
<a name="ln407">            ar9300_mci_send_lna_transfer(ah, AH_TRUE);</a>
<a name="ln408">            OS_DELAY(5);</a>
<a name="ln409"> </a>
<a name="ln410">            OS_REG_CLR_BIT(ah, AR_MCI_TX_CTRL,</a>
<a name="ln411">                AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);</a>
<a name="ln412">            if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln413">                OS_REG_CLR_BIT(ah, AR_GLB_CONTROL,</a>
<a name="ln414">                    AR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);</a>
<a name="ln415">                if (!(ah-&gt;ah_config.ath_hal_mci_config &amp;</a>
<a name="ln416">                    ATH_MCI_CONFIG_DISABLE_OSLA))</a>
<a name="ln417">                {</a>
<a name="ln418">                    ar9300_mci_osla_setup(ah, AH_TRUE);</a>
<a name="ln419">                }</a>
<a name="ln420">            }</a>
<a name="ln421">        } else {</a>
<a name="ln422">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) Send LNA take\n&quot;);</a>
<a name="ln423">            ar9300_mci_send_lna_take(ah, AH_TRUE);</a>
<a name="ln424">            OS_DELAY(5);</a>
<a name="ln425"> </a>
<a name="ln426">            OS_REG_SET_BIT(ah, AR_MCI_TX_CTRL,</a>
<a name="ln427">                AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);</a>
<a name="ln428">            if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln429">                OS_REG_SET_BIT(ah, AR_GLB_CONTROL,</a>
<a name="ln430">                    AR_BTCOEX_CTRL_BT_OWN_SPDT_CTRL);</a>
<a name="ln431">                ar9300_mci_osla_setup(ah, AH_FALSE);</a>
<a name="ln432">            }</a>
<a name="ln433"> </a>
<a name="ln434">            ar9300_mci_send_2g5g_status(ah, AH_TRUE);</a>
<a name="ln435">        }</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">    /*</a>
<a name="ln439">     * Update self gen chain mask. Also set basic set for</a>
<a name="ln440">     * txbf.</a>
<a name="ln441">     */</a>
<a name="ln442">    if (AR_SREV_JUPITER(ah)) {</a>
<a name="ln443">        if (ahp-&gt;ah_mci_coex_is_2g) {</a>
<a name="ln444">            ahp-&gt;ah_reduced_self_gen_mask = AH_TRUE;</a>
<a name="ln445">            OS_REG_WRITE(ah, AR_SELFGEN_MASK, 0x02);</a>
<a name="ln446">            ar9300_txbf_set_basic_set(ah);</a>
<a name="ln447">        }</a>
<a name="ln448">        else {</a>
<a name="ln449">            ahp-&gt;ah_reduced_self_gen_mask = AH_FALSE;</a>
<a name="ln450">            ar9300_txbf_set_basic_set(ah);</a>
<a name="ln451">        }</a>
<a name="ln452">    }</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">void ar9300_mci_mute_bt(struct ath_hal *ah)</a>
<a name="ln456">{</a>
<a name="ln457"> </a>
<a name="ln458">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln459"> </a>
<a name="ln460">    /* disable all MCI messages */ </a>
<a name="ln461">    OS_REG_WRITE(ah, AR_MCI_MSG_ATTRIBUTES_TABLE, 0xFFFF0000);</a>
<a name="ln462">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS0, 0xFFFFFFFF);</a>
<a name="ln463">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS1, 0xFFFFFFFF);</a>
<a name="ln464">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS2, 0xFFFFFFFF);</a>
<a name="ln465">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS3, 0xFFFFFFFF);</a>
<a name="ln466">    OS_REG_SET_BIT(ah, AR_MCI_TX_CTRL, AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);</a>
<a name="ln467">    /* wait pending HW messages to flush out */</a>
<a name="ln468">    OS_DELAY(10);</a>
<a name="ln469"> </a>
<a name="ln470">    /*</a>
<a name="ln471">     * Send LNA_TAKE and SYS_SLEEPING when</a>
<a name="ln472">     * 1. reset not after resuming from full sleep</a>
<a name="ln473">     * 2. before reset MCI RX, to quiet BT and avoid MCI RX misalignment</a>
<a name="ln474">     */</a>
<a name="ln475">    if (MCI_ANT_ARCH_PA_LNA_SHARED(ah-&gt;ah_config.ath_hal_mci_config)) {</a>
<a name="ln476">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) Send LNA take\n&quot;);</a>
<a name="ln477">        ar9300_mci_send_lna_take(ah, AH_TRUE);</a>
<a name="ln478">        OS_DELAY(5);</a>
<a name="ln479">    }</a>
<a name="ln480">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) Send sys sleeping\n&quot;);</a>
<a name="ln481">    ar9300_mci_send_sys_sleeping(ah, AH_TRUE);</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">static void ar9300_mci_observation_set_up(struct ath_hal *ah)</a>
<a name="ln485">{</a>
<a name="ln486">    /*</a>
<a name="ln487">     * Set up the observation bus in order to monitor MCI bus</a>
<a name="ln488">     * through GPIOs (0, 1, 2, and 3).</a>
<a name="ln489">     */</a>
<a name="ln490">    /*</a>
<a name="ln491">    OS_REG_WRITE(ah, AR_GPIO_INTR_POL, 0x00420000);</a>
<a name="ln492">    OS_REG_WRITE(ah, AR_GPIO_OE_OUT, 0x000000ff); // 4050</a>
<a name="ln493">    OS_REG_WRITE(ah, AR_GPIO_OUTPUT_MUX1, 0x000bdab4); // 4068</a>
<a name="ln494">    OS_REG_WRITE(ah, AR_OBS, 0x0000004b); // 4088</a>
<a name="ln495">    OS_REG_WRITE(ah, AR_DIAG_SW, 0x080c0000);</a>
<a name="ln496">    OS_REG_WRITE(ah, AR_MACMISC, 0x0001a000);</a>
<a name="ln497">    OS_REG_WRITE(ah, AR_PHY_TEST, 0x00080000); // a360</a>
<a name="ln498">    OS_REG_WRITE(ah, AR_PHY_TEST_CTL_STATUS, 0xe0000000); // a364</a>
<a name="ln499">    */</a>
<a name="ln500">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: called; config=0x%08x\n&quot;,</a>
<a name="ln501">        __func__, ah-&gt;ah_config.ath_hal_mci_config);</a>
<a name="ln502"> </a>
<a name="ln503">    if (ah-&gt;ah_config.ath_hal_mci_config &amp;</a>
<a name="ln504">        ATH_MCI_CONFIG_MCI_OBS_MCI)</a>
<a name="ln505">    {</a>
<a name="ln506">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: CONFIG_MCI_OBS_MCI\n&quot;, __func__);</a>
<a name="ln507">        ar9300_gpio_cfg_output(ah, 3, HAL_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA);</a>
<a name="ln508">        ar9300_gpio_cfg_output(ah, 2, HAL_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK);</a>
<a name="ln509">        ar9300_gpio_cfg_output(ah, 1, HAL_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);</a>
<a name="ln510">        ar9300_gpio_cfg_output(ah, 0, HAL_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);</a>
<a name="ln511">    }</a>
<a name="ln512">    else if (ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln513">        ATH_MCI_CONFIG_MCI_OBS_TXRX)</a>
<a name="ln514">    {</a>
<a name="ln515">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: CONFIG_MCI_OBS_TXRX\n&quot;, __func__);</a>
<a name="ln516">        ar9300_gpio_cfg_output(ah, 3, HAL_GPIO_OUTPUT_MUX_AS_WL_IN_TX);</a>
<a name="ln517">        ar9300_gpio_cfg_output(ah, 2, HAL_GPIO_OUTPUT_MUX_AS_WL_IN_RX);</a>
<a name="ln518">        ar9300_gpio_cfg_output(ah, 1, HAL_GPIO_OUTPUT_MUX_AS_BT_IN_TX);</a>
<a name="ln519">        ar9300_gpio_cfg_output(ah, 0, HAL_GPIO_OUTPUT_MUX_AS_BT_IN_RX);</a>
<a name="ln520">        ar9300_gpio_cfg_output(ah, 5, HAL_GPIO_OUTPUT_MUX_AS_OUTPUT);</a>
<a name="ln521">    }</a>
<a name="ln522">    else if (ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln523">        ATH_MCI_CONFIG_MCI_OBS_BT)</a>
<a name="ln524">    {</a>
<a name="ln525">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: CONFIG_MCI_OBS_BT\n&quot;, __func__);</a>
<a name="ln526">        ar9300_gpio_cfg_output(ah, 3, HAL_GPIO_OUTPUT_MUX_AS_BT_IN_TX);</a>
<a name="ln527">        ar9300_gpio_cfg_output(ah, 2, HAL_GPIO_OUTPUT_MUX_AS_BT_IN_RX);</a>
<a name="ln528">        ar9300_gpio_cfg_output(ah, 1, HAL_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA);</a>
<a name="ln529">        ar9300_gpio_cfg_output(ah, 0, HAL_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK);</a>
<a name="ln530">    }</a>
<a name="ln531">    else {</a>
<a name="ln532">        return;</a>
<a name="ln533">    }</a>
<a name="ln534"> </a>
<a name="ln535">    OS_REG_SET_BIT(ah,</a>
<a name="ln536">        AR_HOSTIF_REG(ah, AR_GPIO_INPUT_EN_VAL), AR_GPIO_JTAG_DISABLE);</a>
<a name="ln537"> </a>
<a name="ln538">    if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln539">        OS_REG_RMW_FIELD(ah, AR_GLB_CONTROL, AR_GLB_DS_JTAG_DISABLE, 1);</a>
<a name="ln540">        OS_REG_RMW_FIELD(ah, AR_GLB_CONTROL, AR_GLB_WLAN_UART_INTF_EN, 0);</a>
<a name="ln541">        OS_REG_WRITE(ah, AR_GLB_GPIO_CONTROL, </a>
<a name="ln542">                     (OS_REG_READ(ah, AR_GLB_GPIO_CONTROL) | </a>
<a name="ln543">                      ATH_MCI_CONFIG_MCI_OBS_GPIO));</a>
<a name="ln544">    }</a>
<a name="ln545"> </a>
<a name="ln546">    OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_GPIO_OBS_SEL, 0);</a>
<a name="ln547">    OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_MAC_BB_OBS_SEL, 1);</a>
<a name="ln548">    OS_REG_WRITE(ah, AR_HOSTIF_REG(ah, AR_OBS), 0x4b);</a>
<a name="ln549">    OS_REG_RMW_FIELD(ah, AR_DIAG_SW, AR_DIAG_OBS_PT_SEL1, 0x03);</a>
<a name="ln550">    OS_REG_RMW_FIELD(ah, AR_DIAG_SW, AR_DIAG_OBS_PT_SEL2, 0x01);    </a>
<a name="ln551">    OS_REG_RMW_FIELD(ah, AR_MACMISC, AR_MACMISC_MISC_OBS_BUS_LSB, 0x02);</a>
<a name="ln552">    OS_REG_RMW_FIELD(ah, AR_MACMISC, AR_MACMISC_MISC_OBS_BUS_MSB, 0x03);</a>
<a name="ln553">    //OS_REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 0x01);</a>
<a name="ln554">    OS_REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS, </a>
<a name="ln555">        AR_PHY_TEST_CTL_DEBUGPORT_SEL, 0x07);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">static void ar9300_mci_process_gpm_extra(struct ath_hal *ah,</a>
<a name="ln559">                    u_int8_t gpm_type, u_int8_t gpm_opcode, u_int32_t *p_gpm)</a>
<a name="ln560">{</a>
<a name="ln561">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln562">    u_int8_t *p_data = (u_int8_t *) p_gpm;</a>
<a name="ln563"> </a>
<a name="ln564">    switch (gpm_type)</a>
<a name="ln565">    {</a>
<a name="ln566">        case MCI_GPM_COEX_AGENT:</a>
<a name="ln567">            switch (gpm_opcode)</a>
<a name="ln568">            {</a>
<a name="ln569">                case MCI_GPM_COEX_VERSION_QUERY:</a>
<a name="ln570">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln571">                        &quot;(MCI) Recv GPM COEX Version Query.\n&quot;);</a>
<a name="ln572">                    ar9300_mci_send_coex_version_response(ah, AH_TRUE);</a>
<a name="ln573">                    break;</a>
<a name="ln574"> </a>
<a name="ln575">                case MCI_GPM_COEX_VERSION_RESPONSE:</a>
<a name="ln576">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln577">                        &quot;(MCI) Recv GPM COEX Version Response.\n&quot;);</a>
<a name="ln578">                    ahp-&gt;ah_mci_coex_major_version_bt =</a>
<a name="ln579">                        *(p_data + MCI_GPM_COEX_B_MAJOR_VERSION);</a>
<a name="ln580">                    ahp-&gt;ah_mci_coex_minor_version_bt =</a>
<a name="ln581">                        *(p_data + MCI_GPM_COEX_B_MINOR_VERSION);</a>
<a name="ln582">                    ahp-&gt;ah_mci_coex_bt_version_known = AH_TRUE;</a>
<a name="ln583">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln584">                        &quot;(MCI) BT Coex version: %d.%d\n&quot;,</a>
<a name="ln585">                        ahp-&gt;ah_mci_coex_major_version_bt,</a>
<a name="ln586">                        ahp-&gt;ah_mci_coex_minor_version_bt);</a>
<a name="ln587">                    break;</a>
<a name="ln588"> </a>
<a name="ln589">                case MCI_GPM_COEX_STATUS_QUERY:</a>
<a name="ln590">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln591">                        &quot;(MCI) Recv GPM COEX Status Query = 0x%02X.\n&quot;,</a>
<a name="ln592">                        *(p_data + MCI_GPM_COEX_B_WLAN_BITMAP));</a>
<a name="ln593">                    //if ((*(p_data + MCI_GPM_COEX_B_WLAN_BITMAP)) &amp;</a>
<a name="ln594">                    //    MCI_GPM_COEX_QUERY_WLAN_ALL_INFO)</a>
<a name="ln595">                    {</a>
<a name="ln596">                        ahp-&gt;ah_mci_coex_wlan_channels_update = AH_TRUE;</a>
<a name="ln597">                        ar9300_mci_send_coex_wlan_channels(ah, AH_TRUE);</a>
<a name="ln598">                    }</a>
<a name="ln599">                    break;</a>
<a name="ln600"> </a>
<a name="ln601">                case MCI_GPM_COEX_BT_PROFILE_INFO:</a>
<a name="ln602">                    ahp-&gt;ah_mci_query_bt = AH_TRUE;</a>
<a name="ln603">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln604">                        &quot;(MCI) Recv GPM COEX BT_Profile_Info (drop&amp;query)\n&quot;);</a>
<a name="ln605">                    break;</a>
<a name="ln606"> </a>
<a name="ln607">                case MCI_GPM_COEX_BT_STATUS_UPDATE:</a>
<a name="ln608">                    ahp-&gt;ah_mci_query_bt = AH_TRUE;</a>
<a name="ln609">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln610">                        &quot;(MCI) Recv GPM COEX BT_Status_Update &quot;</a>
<a name="ln611">                        &quot;SEQ=%d (drop&amp;query)\n&quot;,</a>
<a name="ln612">                        *(p_gpm + 3));</a>
<a name="ln613">                    break;</a>
<a name="ln614"> </a>
<a name="ln615">                default:</a>
<a name="ln616">                    break;</a>
<a name="ln617">            }</a>
<a name="ln618">        default:</a>
<a name="ln619">            break;</a>
<a name="ln620">    }</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">u_int32_t ar9300_mci_wait_for_gpm(struct ath_hal *ah, u_int8_t gpm_type, </a>
<a name="ln624">                                  u_int8_t gpm_opcode, int32_t time_out)</a>
<a name="ln625">{</a>
<a name="ln626">    u_int32_t *p_gpm = NULL, mismatch = 0, more_data = HAL_MCI_GPM_NOMORE;</a>
<a name="ln627">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln628">    HAL_BOOL b_is_bt_cal_done = (gpm_type == MCI_GPM_BT_CAL_DONE);</a>
<a name="ln629">    u_int32_t offset;</a>
<a name="ln630">    u_int8_t recv_type = 0, recv_opcode = 0;</a>
<a name="ln631"> </a>
<a name="ln632">    if (time_out == 0) {</a>
<a name="ln633">        more_data = HAL_MCI_GPM_MORE;</a>
<a name="ln634">    }</a>
<a name="ln635"> </a>
<a name="ln636">    while (time_out &gt; 0)</a>
<a name="ln637">    {</a>
<a name="ln638">        if (p_gpm != NULL) {</a>
<a name="ln639">            MCI_GPM_RECYCLE(p_gpm);</a>
<a name="ln640">            p_gpm = NULL;</a>
<a name="ln641">        }</a>
<a name="ln642"> </a>
<a name="ln643">        if (more_data != HAL_MCI_GPM_MORE) {</a>
<a name="ln644">            time_out = ar9300_mci_wait_for_interrupt(ah, </a>
<a name="ln645">                AR_MCI_INTERRUPT_RX_MSG_RAW, </a>
<a name="ln646">                AR_MCI_INTERRUPT_RX_MSG_GPM,</a>
<a name="ln647">                time_out);</a>
<a name="ln648">        }</a>
<a name="ln649"> </a>
<a name="ln650">        if (time_out) {</a>
<a name="ln651">            offset = ar9300_mci_state(ah,</a>
<a name="ln652">                HAL_MCI_STATE_NEXT_GPM_OFFSET, &amp;more_data);</a>
<a name="ln653"> </a>
<a name="ln654">            if (offset == HAL_MCI_GPM_INVALID) {</a>
<a name="ln655">                continue;</a>
<a name="ln656">            }</a>
<a name="ln657">            p_gpm = (u_int32_t *) (ahp-&gt;ah_mci_gpm_buf + offset);</a>
<a name="ln658">            ar9300_mci_print_msg(ah, AH_FALSE, MCI_GPM, 16, p_gpm);</a>
<a name="ln659"> </a>
<a name="ln660">            recv_type = MCI_GPM_TYPE(p_gpm);</a>
<a name="ln661">            recv_opcode = MCI_GPM_OPCODE(p_gpm);</a>
<a name="ln662"> </a>
<a name="ln663">            if (MCI_GPM_IS_CAL_TYPE(recv_type)) {</a>
<a name="ln664">                if (recv_type == gpm_type) {</a>
<a name="ln665">                    if ((gpm_type == MCI_GPM_BT_CAL_DONE) &amp;&amp; !b_is_bt_cal_done)</a>
<a name="ln666">                    {</a>
<a name="ln667">                        gpm_type = MCI_GPM_BT_CAL_GRANT;</a>
<a name="ln668">                        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln669">                            &quot;(MCI) Rcv BT_CAL_DONE. Now Wait BT_CAL_GRANT\n&quot;);</a>
<a name="ln670">                        continue;</a>
<a name="ln671">                    }</a>
<a name="ln672">                    if (gpm_type == MCI_GPM_BT_CAL_GRANT) {</a>
<a name="ln673">                        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln674">                            &quot;(MCI) BT_CAL_GRANT seq=%d, req_count=%d\n&quot;,</a>
<a name="ln675">                            *(p_gpm + 2), *(p_gpm + 3));</a>
<a name="ln676">                    }</a>
<a name="ln677">                    break;</a>
<a name="ln678">                }</a>
<a name="ln679">            }</a>
<a name="ln680">            else {</a>
<a name="ln681">                if ((recv_type == gpm_type) &amp;&amp; (recv_opcode == gpm_opcode)) {</a>
<a name="ln682">                    break;</a>
<a name="ln683">                }</a>
<a name="ln684">            }</a>
<a name="ln685">            </a>
<a name="ln686">            /* not expected message */</a>
<a name="ln687">            </a>
<a name="ln688">            /*</a>
<a name="ln689">             * Check if it's cal_grant</a>
<a name="ln690">             *</a>
<a name="ln691">             * When we're waiting for cal_grant in reset routine, it's</a>
<a name="ln692">             * possible that BT sends out cal_request at the same time.</a>
<a name="ln693">             * Since BT's calibration doesn't happen that often, we'll</a>
<a name="ln694">             * let BT completes calibration then we continue to wait </a>
<a name="ln695">             * for cal_grant from BT.</a>
<a name="ln696">             * Orginal: Wait BT_CAL_GRANT.</a>
<a name="ln697">             * New: Receive BT_CAL_REQ -&gt; send WLAN_CAL_GRANT -&gt; wait</a>
<a name="ln698">             * BT_CAL_DONE -&gt; Wait BT_CAL_GRANT.</a>
<a name="ln699">             */</a>
<a name="ln700">            if ((gpm_type == MCI_GPM_BT_CAL_GRANT) &amp;&amp;</a>
<a name="ln701">                (recv_type == MCI_GPM_BT_CAL_REQ))</a>
<a name="ln702">            {</a>
<a name="ln703">                u_int32_t payload[4] = {0, 0, 0, 0};</a>
<a name="ln704"> </a>
<a name="ln705">                gpm_type = MCI_GPM_BT_CAL_DONE;</a>
<a name="ln706">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln707">                    &quot;(MCI) Rcv BT_CAL_REQ. Send WLAN_CAL_GRANT.\n&quot;);</a>
<a name="ln708"> </a>
<a name="ln709">                MCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_GRANT);</a>
<a name="ln710">                ar9300_mci_send_message(ah, MCI_GPM, 0, payload, 16, </a>
<a name="ln711">                    AH_FALSE, AH_FALSE);</a>
<a name="ln712"> </a>
<a name="ln713">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln714">                    &quot;(MCI) Now wait for BT_CAL_DONE.\n&quot;);</a>
<a name="ln715">                continue;</a>
<a name="ln716">            }</a>
<a name="ln717">            else {</a>
<a name="ln718">                HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln719">                    &quot;(MCI) GPM subtype not match 0x%x\n&quot;, *(p_gpm + 1));</a>
<a name="ln720">                mismatch++;</a>
<a name="ln721">                ar9300_mci_process_gpm_extra(ah, recv_type, recv_opcode, p_gpm);</a>
<a name="ln722">            }</a>
<a name="ln723">        }</a>
<a name="ln724">    }</a>
<a name="ln725">    if (p_gpm != NULL) {</a>
<a name="ln726">        MCI_GPM_RECYCLE(p_gpm);</a>
<a name="ln727">        p_gpm = NULL;</a>
<a name="ln728">    }</a>
<a name="ln729"> </a>
<a name="ln730">    if (time_out &lt;= 0) {</a>
<a name="ln731">        time_out = 0;</a>
<a name="ln732">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln733">            &quot;(MCI) GPM receiving timeout, mismatch = %d\n&quot;, mismatch);</a>
<a name="ln734">    } else {</a>
<a name="ln735">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln736">            &quot;(MCI) Receive GPM type=0x%x, code=0x%x\n&quot;, gpm_type, gpm_opcode);</a>
<a name="ln737">    }</a>
<a name="ln738"> </a>
<a name="ln739">    while (more_data == HAL_MCI_GPM_MORE) {</a>
<a name="ln740">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) discard remaining GPM\n&quot;);</a>
<a name="ln741">        offset = ar9300_mci_state(ah,</a>
<a name="ln742">            HAL_MCI_STATE_NEXT_GPM_OFFSET, &amp;more_data);</a>
<a name="ln743"> </a>
<a name="ln744">        if (offset == HAL_MCI_GPM_INVALID) {</a>
<a name="ln745">            break;</a>
<a name="ln746">        }</a>
<a name="ln747">        p_gpm = (u_int32_t *) (ahp-&gt;ah_mci_gpm_buf + offset);</a>
<a name="ln748">        ar9300_mci_print_msg(ah, AH_FALSE, MCI_GPM, 16, p_gpm);</a>
<a name="ln749">        recv_type = MCI_GPM_TYPE(p_gpm);</a>
<a name="ln750">        recv_opcode = MCI_GPM_OPCODE(p_gpm);</a>
<a name="ln751">        if (!MCI_GPM_IS_CAL_TYPE(recv_type)) {</a>
<a name="ln752">            ar9300_mci_process_gpm_extra(ah, recv_type, recv_opcode, p_gpm);</a>
<a name="ln753">        }</a>
<a name="ln754">        MCI_GPM_RECYCLE(p_gpm);</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757">    return time_out;</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">static void ar9300_mci_prep_interface(struct ath_hal *ah)</a>
<a name="ln761">{</a>
<a name="ln762">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln763">    u_int32_t saved_mci_int_en;</a>
<a name="ln764">    u_int32_t mci_timeout = 150;</a>
<a name="ln765"> </a>
<a name="ln766">    ahp-&gt;ah_mci_bt_state = MCI_BT_SLEEP;</a>
<a name="ln767"> </a>
<a name="ln768">    saved_mci_int_en = OS_REG_READ(ah, AR_MCI_INTERRUPT_EN);</a>
<a name="ln769">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);</a>
<a name="ln770"> </a>
<a name="ln771">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,</a>
<a name="ln772">        OS_REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW));</a>
<a name="ln773">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RAW,</a>
<a name="ln774">        OS_REG_READ(ah, AR_MCI_INTERRUPT_RAW));</a>
<a name="ln775"> </a>
<a name="ln776">    /* Remote Reset */</a>
<a name="ln777">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: Reset sequence start\n&quot;, __func__);</a>
<a name="ln778">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) send REMOTE_RESET\n&quot;);</a>
<a name="ln779">    ar9300_mci_remote_reset(ah, AH_TRUE);</a>
<a name="ln780"> </a>
<a name="ln781">    /*</a>
<a name="ln782">     * This delay is required for the reset delay worst case value 255 in </a>
<a name="ln783">     * MCI_COMMAND2 register </a>
<a name="ln784">     */</a>
<a name="ln785">    if (AR_SREV_JUPITER_10(ah)) {</a>
<a name="ln786">        OS_DELAY(252);</a>
<a name="ln787">    }</a>
<a name="ln788"> </a>
<a name="ln789">    /* Send REQ_WAKE to BT */</a>
<a name="ln790">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: Send REQ_WAKE to remote(BT)\n&quot;,</a>
<a name="ln791">        __func__);</a>
<a name="ln792"> </a>
<a name="ln793">    ar9300_mci_send_req_wake(ah, AH_TRUE);</a>
<a name="ln794"> </a>
<a name="ln795">    if (ar9300_mci_wait_for_interrupt(ah, AR_MCI_INTERRUPT_RX_MSG_RAW, </a>
<a name="ln796">        AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING, 500))</a>
<a name="ln797">    {</a>
<a name="ln798">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln799">            &quot;(MCI) %s: Saw SYS_WAKING from remote(BT)\n&quot;, __func__);</a>
<a name="ln800">        ahp-&gt;ah_mci_bt_state = MCI_BT_AWAKE;</a>
<a name="ln801"> </a>
<a name="ln802">        if (AR_SREV_JUPITER_10(ah)) {</a>
<a name="ln803">            OS_DELAY(10);</a>
<a name="ln804">        }</a>
<a name="ln805">        /*</a>
<a name="ln806">         * We don't need to send more remote_reset at this moment.</a>
<a name="ln807">         *</a>
<a name="ln808">         * If BT receive first remote_reset, then BT HW will be cleaned up and</a>
<a name="ln809">         * will be able to receive req_wake and BT HW will respond sys_waking.</a>
<a name="ln810">         * In this case, WLAN will receive BT's HW sys_waking.</a>
<a name="ln811">         *</a>
<a name="ln812">         * Otherwise, if BT SW missed initial remote_reset, that remote_reset</a>
<a name="ln813">         * will still clean up BT MCI RX, and the req_wake will wake BT up,</a>
<a name="ln814">         * and BT SW will respond this req_wake with a remote_reset and</a>
<a name="ln815">         * sys_waking. In this case, WLAN will receive BT's SW sys_waking.</a>
<a name="ln816">         *</a>
<a name="ln817">         * In either case, BT's RX is cleaned up. So we don't need to reply</a>
<a name="ln818">         * BT's remote_reset now, if any.</a>
<a name="ln819">         *</a>
<a name="ln820">         * Similarly, if in any case, WLAN can receive BT's sys_waking, that</a>
<a name="ln821">         * means WLAN's RX is also fine.</a>
<a name="ln822">         */</a>
<a name="ln823"> </a>
<a name="ln824">        /* Send SYS_WAKING to BT */</a>
<a name="ln825">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln826">            &quot;(MCI) %s: Send SW SYS_WAKING to remot(BT)\n&quot;, __func__);</a>
<a name="ln827">        ar9300_mci_send_sys_waking(ah, AH_TRUE);</a>
<a name="ln828"> </a>
<a name="ln829">        OS_DELAY(10);</a>
<a name="ln830"> </a>
<a name="ln831">        /*</a>
<a name="ln832">         * Set BT priority interrupt value to be 0xff to</a>
<a name="ln833">         * avoid having too many BT PRIORITY interrupts.</a>
<a name="ln834">         */</a>
<a name="ln835"> </a>
<a name="ln836">        OS_REG_WRITE(ah, AR_MCI_BT_PRI0, 0xFFFFFFFF);</a>
<a name="ln837">        OS_REG_WRITE(ah, AR_MCI_BT_PRI1, 0xFFFFFFFF);</a>
<a name="ln838">        OS_REG_WRITE(ah, AR_MCI_BT_PRI2, 0xFFFFFFFF);</a>
<a name="ln839">        OS_REG_WRITE(ah, AR_MCI_BT_PRI3, 0xFFFFFFFF);</a>
<a name="ln840">        OS_REG_WRITE(ah, AR_MCI_BT_PRI, 0X000000FF);</a>
<a name="ln841"> </a>
<a name="ln842">        /*</a>
<a name="ln843">         * A contention reset will be received after send out sys_waking.</a>
<a name="ln844">         * Also BT priority interrupt bits will be set. Clear those bits</a>
<a name="ln845">         * before the next step.</a>
<a name="ln846">         */</a>
<a name="ln847">        OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW, </a>
<a name="ln848">            AR_MCI_INTERRUPT_RX_MSG_CONT_RST);</a>
<a name="ln849">        OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RAW, AR_MCI_INTERRUPT_BT_PRI);</a>
<a name="ln850"> </a>
<a name="ln851">        if (AR_SREV_JUPITER_10(ah) ||</a>
<a name="ln852">           (ahp-&gt;ah_mci_coex_is_2g &amp;&amp;</a>
<a name="ln853">            MCI_ANT_ARCH_PA_LNA_SHARED(ah-&gt;ah_config.ath_hal_mci_config))) {</a>
<a name="ln854">            /* Send LNA_TRANS */</a>
<a name="ln855">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: Send LNA_TRANS to BT\n&quot;, </a>
<a name="ln856">                __func__);</a>
<a name="ln857">            ar9300_mci_send_lna_transfer(ah, AH_TRUE);</a>
<a name="ln858">    </a>
<a name="ln859">            OS_DELAY(5);</a>
<a name="ln860">        }</a>
<a name="ln861"> </a>
<a name="ln862">        if (AR_SREV_JUPITER_10(ah) ||</a>
<a name="ln863">            (ahp-&gt;ah_mci_coex_is_2g &amp;&amp; !ahp-&gt;ah_mci_coex_2g5g_update &amp;&amp;</a>
<a name="ln864">            MCI_ANT_ARCH_PA_LNA_SHARED(ah-&gt;ah_config.ath_hal_mci_config))) {</a>
<a name="ln865">            if (ar9300_mci_wait_for_interrupt(ah, AR_MCI_INTERRUPT_RX_MSG_RAW, </a>
<a name="ln866">                AR_MCI_INTERRUPT_RX_MSG_LNA_INFO, mci_timeout)) {</a>
<a name="ln867">                HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln868">                    &quot;(MCI) %s: WLAN has control over the LNA &amp; BT obeys it\n&quot;, </a>
<a name="ln869">                    __func__);</a>
<a name="ln870">            } else {</a>
<a name="ln871">                HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln872">                    &quot;(MCI) %s: BT did not respond to LNA_TRANS!\n&quot;, __func__);</a>
<a name="ln873">                //ahp-&gt;ah_mci_bt_state = MCI_BT_SLEEP;</a>
<a name="ln874">            }</a>
<a name="ln875">        }</a>
<a name="ln876"> </a>
<a name="ln877">        if (AR_SREV_JUPITER_10(ah)) {</a>
<a name="ln878">            /* Send another remote_reset to deassert BT clk_req. */</a>
<a name="ln879">            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln880">                &quot;(MCI) %s: Another remote_reset to deassert clk_req.\n&quot;, </a>
<a name="ln881">                __func__);</a>
<a name="ln882">            ar9300_mci_remote_reset(ah, AH_TRUE);</a>
<a name="ln883">            OS_DELAY(252);</a>
<a name="ln884">        }</a>
<a name="ln885">    }</a>
<a name="ln886"> </a>
<a name="ln887">    /* Clear the extra redundant SYS_WAKING from BT */</a>
<a name="ln888">    if ((ahp-&gt;ah_mci_bt_state == MCI_BT_AWAKE) &amp;&amp;</a>
<a name="ln889">        (OS_REG_READ_FIELD(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,</a>
<a name="ln890">            AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING)) &amp;&amp;</a>
<a name="ln891">        (OS_REG_READ_FIELD(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,</a>
<a name="ln892">            AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING) == 0))</a>
<a name="ln893">    {</a>
<a name="ln894">        OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,</a>
<a name="ln895">            AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING);</a>
<a name="ln896">        OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RAW,</a>
<a name="ln897">            AR_MCI_INTERRUPT_REMOTE_SLEEP_UPDATE);</a>
<a name="ln898">    }</a>
<a name="ln899"> </a>
<a name="ln900">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_EN, saved_mci_int_en);</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">void ar9300_mci_setup(struct ath_hal *ah, u_int32_t gpm_addr, </a>
<a name="ln904">                      void *gpm_buf, u_int16_t len,</a>
<a name="ln905">                      u_int32_t sched_addr)</a>
<a name="ln906">{</a>
<a name="ln907">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln908">    void *sched_buf = (void *)((char *) gpm_buf + (sched_addr - gpm_addr));</a>
<a name="ln909"> </a>
<a name="ln910">    ahp-&gt;ah_mci_gpm_addr = gpm_addr;</a>
<a name="ln911">    ahp-&gt;ah_mci_gpm_buf = gpm_buf;</a>
<a name="ln912">    ahp-&gt;ah_mci_gpm_len = len;</a>
<a name="ln913">    ahp-&gt;ah_mci_sched_addr = sched_addr;</a>
<a name="ln914">    ahp-&gt;ah_mci_sched_buf = sched_buf;</a>
<a name="ln915"> </a>
<a name="ln916">    ar9300_mci_reset(ah, AH_TRUE, AH_TRUE, AH_TRUE);</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">void ar9300_mci_disable_interrupt(struct ath_hal *ah)</a>
<a name="ln920">{</a>
<a name="ln921">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);</a>
<a name="ln922">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN, 0);</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">void ar9300_mci_enable_interrupt(struct ath_hal *ah)</a>
<a name="ln926">{</a>
<a name="ln927">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_EN, AR_MCI_INTERRUPT_DEFAULT);</a>
<a name="ln928">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN, </a>
<a name="ln929">        AR_MCI_INTERRUPT_RX_MSG_DEFAULT);</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">static void ar9300_mci_set_btcoex_ctrl_9565_1ANT(struct ath_hal *ah)</a>
<a name="ln933">{</a>
<a name="ln934">    uint32_t regval;</a>
<a name="ln935"> </a>
<a name="ln936">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln937">    regval = SM(1, AR_BTCOEX_CTRL_JUPITER_MODE) |</a>
<a name="ln938">      SM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |</a>
<a name="ln939">      SM(1, AR_BTCOEX_CTRL_PA_SHARED) |</a>
<a name="ln940">      SM(1, AR_BTCOEX_CTRL_LNA_SHARED) |</a>
<a name="ln941">      SM(1, AR_BTCOEX_CTRL_NUM_ANTENNAS) |</a>
<a name="ln942">      SM(1, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |</a>
<a name="ln943">      SM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |</a>
<a name="ln944">      SM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |</a>
<a name="ln945">      SM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);</a>
<a name="ln946"> </a>
<a name="ln947">    OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,</a>
<a name="ln948">      AR_BTCOEX_CTRL2_TX_CHAIN_MASK, 0x1);</a>
<a name="ln949">    OS_REG_WRITE(ah, AR_BTCOEX_CTRL, regval);</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">static void ar9300_mci_set_btcoex_ctrl_9565_2ANT(struct ath_hal *ah)</a>
<a name="ln953">{</a>
<a name="ln954">    uint32_t regval;</a>
<a name="ln955"> </a>
<a name="ln956">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln957">    regval = SM(1, AR_BTCOEX_CTRL_JUPITER_MODE) |</a>
<a name="ln958">      SM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |</a>
<a name="ln959">      SM(0, AR_BTCOEX_CTRL_PA_SHARED) |</a>
<a name="ln960">      SM(0, AR_BTCOEX_CTRL_LNA_SHARED) |</a>
<a name="ln961">      SM(2, AR_BTCOEX_CTRL_NUM_ANTENNAS) |</a>
<a name="ln962">      SM(1, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |</a>
<a name="ln963">      SM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |</a>
<a name="ln964">      SM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |</a>
<a name="ln965">      SM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);</a>
<a name="ln966"> </a>
<a name="ln967">    OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,</a>
<a name="ln968">      AR_BTCOEX_CTRL2_TX_CHAIN_MASK, 0x0);</a>
<a name="ln969">    OS_REG_WRITE(ah, AR_BTCOEX_CTRL, regval);</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972">static void ar9300_mci_set_btcoex_ctrl_9462(struct ath_hal *ah)</a>
<a name="ln973">{</a>
<a name="ln974">    uint32_t regval;</a>
<a name="ln975"> </a>
<a name="ln976">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln977">    regval = SM(1, AR_BTCOEX_CTRL_JUPITER_MODE) |</a>
<a name="ln978">      SM(1, AR_BTCOEX_CTRL_WBTIMER_EN) |</a>
<a name="ln979">      SM(1, AR_BTCOEX_CTRL_PA_SHARED) |</a>
<a name="ln980">      SM(1, AR_BTCOEX_CTRL_LNA_SHARED) |</a>
<a name="ln981">      SM(2, AR_BTCOEX_CTRL_NUM_ANTENNAS) |</a>
<a name="ln982">      SM(3, AR_BTCOEX_CTRL_RX_CHAIN_MASK) |</a>
<a name="ln983">      SM(0, AR_BTCOEX_CTRL_1_CHAIN_ACK) |</a>
<a name="ln984">      SM(0, AR_BTCOEX_CTRL_1_CHAIN_BCN) |</a>
<a name="ln985">      SM(0, AR_BTCOEX_CTRL_ONE_STEP_LOOK_AHEAD_EN);</a>
<a name="ln986"> </a>
<a name="ln987">    if (AR_SREV_JUPITER_10(ah)) {</a>
<a name="ln988">        regval |= SM(1, AR_BTCOEX_CTRL_SPDT_ENABLE_10);</a>
<a name="ln989">    }</a>
<a name="ln990"> </a>
<a name="ln991">    OS_REG_WRITE(ah, AR_BTCOEX_CTRL, regval);</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994">void ar9300_mci_reset(struct ath_hal *ah, HAL_BOOL en_int, HAL_BOOL is_2g,</a>
<a name="ln995">                      HAL_BOOL is_full_sleep)</a>
<a name="ln996">{</a>
<a name="ln997">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln998">//    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln999">    u_int32_t regval;</a>
<a name="ln1000"> </a>
<a name="ln1001">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: full_sleep = %d, is_2g = %d\n&quot;,</a>
<a name="ln1002">        __func__, is_full_sleep, is_2g);</a>
<a name="ln1003"> </a>
<a name="ln1004">    if (!ahp-&gt;ah_mci_gpm_addr &amp;&amp; !ahp-&gt;ah_mci_sched_addr) {</a>
<a name="ln1005">        /* GPM buffer and scheduling message buffer are not allocated */</a>
<a name="ln1006">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1007">            &quot;(MCI) GPM and SCHEDULE buffers not allocated\n&quot;);</a>
<a name="ln1008">        return;</a>
<a name="ln1009">    }</a>
<a name="ln1010"> </a>
<a name="ln1011">    if (OS_REG_READ(ah, AR_BTCOEX_CTRL) == 0xdeadbeef) {</a>
<a name="ln1012">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln1013">            &quot;(MCI) %s: ### It's deadbeef, quit mcireset()\n&quot;, __func__);</a>
<a name="ln1014">        return;</a>
<a name="ln1015">    }</a>
<a name="ln1016"> </a>
<a name="ln1017">    /* Program MCI DMA related registers */</a>
<a name="ln1018">    OS_REG_WRITE(ah, AR_MCI_GPM_0, ahp-&gt;ah_mci_gpm_addr);</a>
<a name="ln1019">    OS_REG_WRITE(ah, AR_MCI_GPM_1, ahp-&gt;ah_mci_gpm_len);</a>
<a name="ln1020">    OS_REG_WRITE(ah, AR_MCI_SCHD_TABLE_0, ahp-&gt;ah_mci_sched_addr);</a>
<a name="ln1021"> </a>
<a name="ln1022">    /*</a>
<a name="ln1023">     * To avoid MCI state machine be affected by incoming remote MCI messages,</a>
<a name="ln1024">     * MCI mode will be enabled later, right before reset the MCI TX and RX.</a>
<a name="ln1025">     */</a>
<a name="ln1026">    if (AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1027">        uint8_t ant = MS(ah-&gt;ah_config.ath_hal_mci_config,</a>
<a name="ln1028">          ATH_MCI_CONFIG_ANT_ARCH);</a>
<a name="ln1029">        if (ant == ATH_MCI_ANT_ARCH_1_ANT_PA_LNA_SHARED)</a>
<a name="ln1030">            ar9300_mci_set_btcoex_ctrl_9565_1ANT(ah);</a>
<a name="ln1031">        else</a>
<a name="ln1032">            ar9300_mci_set_btcoex_ctrl_9565_2ANT(ah);</a>
<a name="ln1033">    } else {</a>
<a name="ln1034">            ar9300_mci_set_btcoex_ctrl_9462(ah);</a>
<a name="ln1035">    }</a>
<a name="ln1036"> </a>
<a name="ln1037"> </a>
<a name="ln1038">    if (is_2g &amp;&amp; (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) &amp;&amp;</a>
<a name="ln1039">         !(ah-&gt;ah_config.ath_hal_mci_config &amp;</a>
<a name="ln1040">           ATH_MCI_CONFIG_DISABLE_OSLA))</a>
<a name="ln1041">    {</a>
<a name="ln1042">        ar9300_mci_osla_setup(ah, AH_TRUE);</a>
<a name="ln1043">    }</a>
<a name="ln1044">    else {</a>
<a name="ln1045">        ar9300_mci_osla_setup(ah, AH_FALSE);</a>
<a name="ln1046">    }</a>
<a name="ln1047"> </a>
<a name="ln1048">    if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1049">        OS_REG_SET_BIT(ah, AR_GLB_CONTROL, AR_BTCOEX_CTRL_SPDT_ENABLE);</a>
<a name="ln1050"> </a>
<a name="ln1051">        OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL3,</a>
<a name="ln1052">                         AR_BTCOEX_CTRL3_CONT_INFO_TIMEOUT, 20);</a>
<a name="ln1053">    }</a>
<a name="ln1054"> </a>
<a name="ln1055">    OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, AR_BTCOEX_CTRL2_RX_DEWEIGHT, 0);</a>
<a name="ln1056"> </a>
<a name="ln1057">    OS_REG_RMW_FIELD(ah, AR_PCU_MISC, AR_PCU_BT_ANT_PREVENT_RX, 0);</a>
<a name="ln1058"> </a>
<a name="ln1059">    /* Set the time out to 3.125ms (5 BT slots) */</a>
<a name="ln1060">    OS_REG_RMW_FIELD(ah, AR_BTCOEX_WL_LNA, AR_BTCOEX_WL_LNA_TIMEOUT, 0x3D090);</a>
<a name="ln1061"> </a>
<a name="ln1062">    if (ah-&gt;ah_config.ath_hal_mci_config &amp; ATH_MCI_CONFIG_CONCUR_TX) {</a>
<a name="ln1063">        u_int8_t i;</a>
<a name="ln1064">        u_int32_t const *pmax_tx_pwr;</a>
<a name="ln1065"> </a>
<a name="ln1066">        if ((ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln1067">             ATH_MCI_CONFIG_CONCUR_TX) == ATH_MCI_CONCUR_TX_SHARED_CHN)</a>
<a name="ln1068">        {</a>
<a name="ln1069">            ahp-&gt;ah_mci_concur_tx_en = (ahp-&gt;ah_bt_coex_flag &amp; </a>
<a name="ln1070">                HAL_BT_COEX_FLAG_MCI_MAX_TX_PWR) ? AH_TRUE : AH_FALSE;</a>
<a name="ln1071"> </a>
<a name="ln1072">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) concur_tx_en = %d\n&quot;, </a>
<a name="ln1073">                     ahp-&gt;ah_mci_concur_tx_en);</a>
<a name="ln1074">            /*</a>
<a name="ln1075">             * We're not relying on HW to reduce WLAN tx power.</a>
<a name="ln1076">             * Set the max tx power table to 0x7f for all.</a>
<a name="ln1077">             */</a>
<a name="ln1078">#if 0</a>
<a name="ln1079">            if (AH_PRIVATE(ah)-&gt;ah_curchan) {</a>
<a name="ln1080">                chan_flags = AH_PRIVATE(ah)-&gt;ah_curchan-&gt;channel_flags;</a>
<a name="ln1081">            }</a>
<a name="ln1082">            if (chan_flags == CHANNEL_G_HT20) {</a>
<a name="ln1083">                pmax_tx_pwr = &amp;mci_concur_tx_max_pwr[2][0];</a>
<a name="ln1084">            }</a>
<a name="ln1085">            else if (chan_flags == CHANNEL_G) {</a>
<a name="ln1086">                pmax_tx_pwr = &amp;mci_concur_tx_max_pwr[1][0];</a>
<a name="ln1087">            }</a>
<a name="ln1088">            else if ((chan_flags == CHANNEL_G_HT40PLUS) || </a>
<a name="ln1089">                     (chan_flags == CHANNEL_G_HT40MINUS))</a>
<a name="ln1090">            {</a>
<a name="ln1091">                pmax_tx_pwr = &amp;mci_concur_tx_max_pwr[3][0];</a>
<a name="ln1092">            }</a>
<a name="ln1093">            else {</a>
<a name="ln1094">                pmax_tx_pwr = &amp;mci_concur_tx_max_pwr[0][0];</a>
<a name="ln1095">            }</a>
<a name="ln1096"> </a>
<a name="ln1097">            if (ahp-&gt;ah_mci_concur_tx_en) {</a>
<a name="ln1098">                HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln1099">                        &quot;(MCI) chan flags = 0x%x, max_tx_pwr = %d dBm\n&quot;, </a>
<a name="ln1100">                        chan_flags, </a>
<a name="ln1101">                        (MS(pmax_tx_pwr[2],</a>
<a name="ln1102">                         ATH_MCI_CONCUR_TX_LOWEST_PWR_MASK) &gt;&gt; 1));</a>
<a name="ln1103">            }</a>
<a name="ln1104">#else</a>
<a name="ln1105">            pmax_tx_pwr = &amp;mci_concur_tx_max_pwr[0][0];</a>
<a name="ln1106">#endif</a>
<a name="ln1107">        }</a>
<a name="ln1108">        else if ((ah-&gt;ah_config.ath_hal_mci_config &amp;</a>
<a name="ln1109">                  ATH_MCI_CONFIG_CONCUR_TX) == ATH_MCI_CONCUR_TX_UNSHARED_CHN)</a>
<a name="ln1110">        {</a>
<a name="ln1111">            pmax_tx_pwr = &amp;mci_concur_tx_max_pwr[0][0];</a>
<a name="ln1112">            ahp-&gt;ah_mci_concur_tx_en = AH_TRUE;</a>
<a name="ln1113">        }</a>
<a name="ln1114">        else {</a>
<a name="ln1115">            pmax_tx_pwr = &amp;mci_concur_tx_max_pwr[0][0];</a>
<a name="ln1116">            ahp-&gt;ah_mci_concur_tx_en = AH_TRUE;</a>
<a name="ln1117">        }</a>
<a name="ln1118"> </a>
<a name="ln1119">    	/* Default is using rate based TPC. */</a>
<a name="ln1120">        OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL2, </a>
<a name="ln1121">                         AR_BTCOEX_CTRL2_DESC_BASED_TXPWR_ENABLE, 0);</a>
<a name="ln1122">        OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL2,</a>
<a name="ln1123">                         AR_BTCOEX_CTRL2_TXPWR_THRESH, 0x7f);</a>
<a name="ln1124">        OS_REG_RMW_FIELD(ah, AR_BTCOEX_CTRL, </a>
<a name="ln1125">                         AR_BTCOEX_CTRL_REDUCE_TXPWR, 0);</a>
<a name="ln1126">        for (i = 0; i &lt; 8; i++) {</a>
<a name="ln1127">            OS_REG_WRITE(ah, AR_BTCOEX_MAX_TXPWR(i), pmax_tx_pwr[i]);</a>
<a name="ln1128">        }</a>
<a name="ln1129">    }</a>
<a name="ln1130"> </a>
<a name="ln1131">    regval = MS(ah-&gt;ah_config.ath_hal_mci_config,</a>
<a name="ln1132">                ATH_MCI_CONFIG_CLK_DIV);</a>
<a name="ln1133">    OS_REG_RMW_FIELD(ah, AR_MCI_TX_CTRL, AR_MCI_TX_CTRL_CLK_DIV, regval);</a>
<a name="ln1134"> </a>
<a name="ln1135">    OS_REG_SET_BIT(ah, AR_BTCOEX_CTRL, AR_BTCOEX_CTRL_MCI_MODE_EN);</a>
<a name="ln1136"> </a>
<a name="ln1137">    /* Resetting the Rx and Tx paths of MCI */</a>
<a name="ln1138">    regval = OS_REG_READ(ah, AR_MCI_COMMAND2);</a>
<a name="ln1139">    regval |= SM(1, AR_MCI_COMMAND2_RESET_TX);</a>
<a name="ln1140">    OS_REG_WRITE(ah, AR_MCI_COMMAND2, regval);</a>
<a name="ln1141">    OS_DELAY(1);</a>
<a name="ln1142">    regval &amp;= ~SM(1, AR_MCI_COMMAND2_RESET_TX);</a>
<a name="ln1143">    OS_REG_WRITE(ah, AR_MCI_COMMAND2, regval);</a>
<a name="ln1144"> </a>
<a name="ln1145">    if (is_full_sleep) {</a>
<a name="ln1146">        ar9300_mci_mute_bt(ah);</a>
<a name="ln1147">        OS_DELAY(100);</a>
<a name="ln1148">    }</a>
<a name="ln1149"> </a>
<a name="ln1150">    regval |= SM(1, AR_MCI_COMMAND2_RESET_RX);</a>
<a name="ln1151">    OS_REG_WRITE(ah, AR_MCI_COMMAND2, regval);</a>
<a name="ln1152">    OS_DELAY(1);</a>
<a name="ln1153">    regval &amp;= ~SM(1, AR_MCI_COMMAND2_RESET_RX);</a>
<a name="ln1154">    OS_REG_WRITE(ah, AR_MCI_COMMAND2, regval);</a>
<a name="ln1155"> </a>
<a name="ln1156">    ar9300_mci_state(ah, HAL_MCI_STATE_INIT_GPM_OFFSET, NULL);</a>
<a name="ln1157">    OS_REG_WRITE(ah, AR_MCI_MSG_ATTRIBUTES_TABLE,</a>
<a name="ln1158">             (SM(0xe801, AR_MCI_MSG_ATTRIBUTES_TABLE_INVALID_HDR) |</a>
<a name="ln1159">              SM(0x0000, AR_MCI_MSG_ATTRIBUTES_TABLE_CHECKSUM)));</a>
<a name="ln1160">    if (MCI_ANT_ARCH_PA_LNA_SHARED(ah-&gt;ah_config.ath_hal_mci_config)) {</a>
<a name="ln1161">        OS_REG_CLR_BIT(ah, AR_MCI_TX_CTRL, AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);</a>
<a name="ln1162">    } else {</a>
<a name="ln1163">        OS_REG_SET_BIT(ah, AR_MCI_TX_CTRL, AR_MCI_TX_CTRL_DISABLE_LNA_UPDATE);</a>
<a name="ln1164">    }</a>
<a name="ln1165"> </a>
<a name="ln1166">    if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1167">        ar9300_mci_observation_set_up(ah);</a>
<a name="ln1168">    }</a>
<a name="ln1169">    </a>
<a name="ln1170">    ahp-&gt;ah_mci_ready = AH_TRUE;</a>
<a name="ln1171">    ar9300_mci_prep_interface(ah);</a>
<a name="ln1172"> </a>
<a name="ln1173">    if (en_int) {</a>
<a name="ln1174">        ar9300_mci_enable_interrupt(ah);</a>
<a name="ln1175">    }</a>
<a name="ln1176"> </a>
<a name="ln1177">#if ATH_SUPPORT_AIC</a>
<a name="ln1178">    if (ahp-&gt;ah_aic_enabled) {</a>
<a name="ln1179">        ar9300_aic_start_normal(ah);</a>
<a name="ln1180">    }</a>
<a name="ln1181">#endif</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">static void ar9300_mci_queue_unsent_gpm(struct ath_hal *ah, u_int8_t header,</a>
<a name="ln1185">                                        u_int32_t *payload, HAL_BOOL queue)</a>
<a name="ln1186">{</a>
<a name="ln1187">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1188">    u_int8_t type, opcode;</a>
<a name="ln1189"> </a>
<a name="ln1190">    if (queue == AH_TRUE) {</a>
<a name="ln1191">        if (payload != NULL) {</a>
<a name="ln1192">            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1193">                &quot;(MCI) ERROR: Send fail: %02x: %02x %02x %02x\n&quot;,</a>
<a name="ln1194">                header,</a>
<a name="ln1195">                *(((u_int8_t *)payload) + 4),</a>
<a name="ln1196">                *(((u_int8_t *)payload) + 5),</a>
<a name="ln1197">                *(((u_int8_t *)payload) + 6));</a>
<a name="ln1198">        } else {</a>
<a name="ln1199">            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1200">                &quot;(MCI) ERROR: Send fail: %02x\n&quot;, header);</a>
<a name="ln1201">        }</a>
<a name="ln1202">    }</a>
<a name="ln1203">    /* check if the message is to be queued */</a>
<a name="ln1204">    if (header == MCI_GPM) {</a>
<a name="ln1205">        type = MCI_GPM_TYPE(payload);</a>
<a name="ln1206">        opcode = MCI_GPM_OPCODE(payload);</a>
<a name="ln1207"> </a>
<a name="ln1208">        if (type == MCI_GPM_COEX_AGENT) {</a>
<a name="ln1209">            switch (opcode)</a>
<a name="ln1210">            {</a>
<a name="ln1211">                case MCI_GPM_COEX_BT_UPDATE_FLAGS:</a>
<a name="ln1212">                    if (AR_SREV_JUPITER_10(ah)) {</a>
<a name="ln1213">                        break;</a>
<a name="ln1214">                    }</a>
<a name="ln1215">                    if (*(((u_int8_t *)payload) + MCI_GPM_COEX_B_BT_FLAGS_OP) ==</a>
<a name="ln1216">                        MCI_GPM_COEX_BT_FLAGS_READ)</a>
<a name="ln1217">                    {</a>
<a name="ln1218">                        break;</a>
<a name="ln1219">                    }</a>
<a name="ln1220">                    ahp-&gt;ah_mci_coex_2g5g_update = queue;</a>
<a name="ln1221">                    if (queue == AH_TRUE) {</a>
<a name="ln1222">                        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1223">                            &quot;(MCI) BT_MCI_FLAGS: 2G5G status &lt;queued&gt; %s.\n&quot;,</a>
<a name="ln1224">                            ahp-&gt;ah_mci_coex_is_2g?&quot;2G&quot;:&quot;5G&quot;);</a>
<a name="ln1225">                    }</a>
<a name="ln1226">                    else {</a>
<a name="ln1227">                        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1228">                            &quot;(MCI) BT_MCI_FLAGS: 2G5G status &lt;sent&gt; %s.\n&quot;,</a>
<a name="ln1229">                            ahp-&gt;ah_mci_coex_is_2g?&quot;2G&quot;:&quot;5G&quot;);</a>
<a name="ln1230">                    }</a>
<a name="ln1231">                    break;</a>
<a name="ln1232"> </a>
<a name="ln1233">                case MCI_GPM_COEX_WLAN_CHANNELS:</a>
<a name="ln1234">                    ahp-&gt;ah_mci_coex_wlan_channels_update = queue;</a>
<a name="ln1235">                    if (queue == AH_TRUE) {</a>
<a name="ln1236">                        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1237">                            &quot;(MCI) WLAN channel map &lt;queued&gt;.\n&quot;);</a>
<a name="ln1238">                    }</a>
<a name="ln1239">                    else {</a>
<a name="ln1240">                        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1241">                            &quot;(MCI) WLAN channel map &lt;sent&gt;.\n&quot;);</a>
<a name="ln1242">                    }</a>
<a name="ln1243">                    break;</a>
<a name="ln1244"> </a>
<a name="ln1245">                case MCI_GPM_COEX_HALT_BT_GPM:</a>
<a name="ln1246">                    if (*(((u_int8_t *)payload) + MCI_GPM_COEX_B_HALT_STATE) ==</a>
<a name="ln1247">                        MCI_GPM_COEX_BT_GPM_UNHALT)</a>
<a name="ln1248">                    {</a>
<a name="ln1249">                        ahp-&gt;ah_mci_unhalt_bt_gpm = queue;</a>
<a name="ln1250">                        if (queue == AH_TRUE) {</a>
<a name="ln1251">                            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1252">                                &quot;(MCI) UNHALT BT GPM &lt;queued&gt;.\n&quot;);</a>
<a name="ln1253">                        }</a>
<a name="ln1254">                        else {</a>
<a name="ln1255">                            ahp-&gt;ah_mci_halted_bt_gpm = AH_FALSE;</a>
<a name="ln1256">                            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1257">                                &quot;(MCI) UNHALT BT GPM &lt;sent&gt;.\n&quot;);</a>
<a name="ln1258">                        }</a>
<a name="ln1259">                    }</a>
<a name="ln1260">                    if (*(((u_int8_t *)payload) + MCI_GPM_COEX_B_HALT_STATE) ==</a>
<a name="ln1261">                        MCI_GPM_COEX_BT_GPM_HALT)</a>
<a name="ln1262">                    {</a>
<a name="ln1263">                        ahp-&gt;ah_mci_halted_bt_gpm = !queue;</a>
<a name="ln1264">                        if (queue == AH_TRUE) {</a>
<a name="ln1265">                            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1266">                                &quot;(MCI) HALT BT GPM &lt;not sent&gt;.\n&quot;);</a>
<a name="ln1267">                        }</a>
<a name="ln1268">                        else {</a>
<a name="ln1269">                            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1270">                                &quot;(MCI) HALT BT GPM &lt;sent&gt;.\n&quot;);</a>
<a name="ln1271">                        }</a>
<a name="ln1272">                    }</a>
<a name="ln1273">                    break;</a>
<a name="ln1274"> </a>
<a name="ln1275">                default:</a>
<a name="ln1276">                    break;</a>
<a name="ln1277">            }</a>
<a name="ln1278">        }</a>
<a name="ln1279">    }</a>
<a name="ln1280">}</a>
<a name="ln1281"> </a>
<a name="ln1282">HAL_BOOL ar9300_mci_send_message(struct ath_hal *ah, u_int8_t header,</a>
<a name="ln1283">                              u_int32_t flag, u_int32_t *payload, </a>
<a name="ln1284">                              u_int8_t len, HAL_BOOL wait_done, HAL_BOOL check_bt)</a>
<a name="ln1285">{</a>
<a name="ln1286">    int i;</a>
<a name="ln1287">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1288">    HAL_BOOL msg_sent = AH_FALSE;</a>
<a name="ln1289">    u_int32_t regval;</a>
<a name="ln1290">    u_int32_t saved_mci_int_en = OS_REG_READ(ah, AR_MCI_INTERRUPT_EN);</a>
<a name="ln1291"> </a>
<a name="ln1292">    regval = OS_REG_READ(ah, AR_BTCOEX_CTRL);</a>
<a name="ln1293">    if ((regval == 0xdeadbeef) || !(regval &amp; AR_BTCOEX_CTRL_MCI_MODE_EN)) {</a>
<a name="ln1294">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1295">            &quot;(MCI) %s: Not send 0x%x. MCI is not enabled. full_sleep = %d\n&quot;, </a>
<a name="ln1296">            __func__, header, ahp-&gt;ah_chip_full_sleep);</a>
<a name="ln1297">        ar9300_mci_queue_unsent_gpm(ah, header, payload, AH_TRUE);</a>
<a name="ln1298">        return AH_FALSE;</a>
<a name="ln1299">    }</a>
<a name="ln1300">    else if (check_bt &amp;&amp; (ahp-&gt;ah_mci_bt_state == MCI_BT_SLEEP)) {</a>
<a name="ln1301">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln1302">            &quot;(MCI) %s: Don't send message(0x%x). BT is in sleep state\n&quot;, </a>
<a name="ln1303">            __func__, header);</a>
<a name="ln1304">        ar9300_mci_queue_unsent_gpm(ah, header, payload, AH_TRUE);</a>
<a name="ln1305">        return AH_FALSE;</a>
<a name="ln1306">    }</a>
<a name="ln1307"> </a>
<a name="ln1308">    if (wait_done) {</a>
<a name="ln1309">        OS_REG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);</a>
<a name="ln1310">    }</a>
<a name="ln1311"> </a>
<a name="ln1312">    /* Need to clear SW_MSG_DONE raw bit before wait */</a>
<a name="ln1313">    OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RAW,</a>
<a name="ln1314">        AR_MCI_INTERRUPT_SW_MSG_DONE | AR_MCI_INTERRUPT_MSG_FAIL_MASK);</a>
<a name="ln1315"> </a>
<a name="ln1316">    if (payload != AH_NULL) {</a>
<a name="ln1317">        for (i = 0; (i*4) &lt; len; i++) {</a>
<a name="ln1318">            OS_REG_WRITE(ah, (AR_MCI_TX_PAYLOAD0 + i*4), *(payload + i));</a>
<a name="ln1319">        }</a>
<a name="ln1320">    }</a>
<a name="ln1321">    ar9300_mci_print_msg(ah, AH_TRUE, header, len, payload);</a>
<a name="ln1322"> </a>
<a name="ln1323">    OS_REG_WRITE(ah, AR_MCI_COMMAND0,</a>
<a name="ln1324">                (SM((flag &amp; HAL_MCI_FLAG_DISABLE_TIMESTAMP), </a>
<a name="ln1325">                 AR_MCI_COMMAND0_DISABLE_TIMESTAMP) |</a>
<a name="ln1326">                 SM(len, AR_MCI_COMMAND0_LEN) |</a>
<a name="ln1327">                 SM(header, AR_MCI_COMMAND0_HEADER)));</a>
<a name="ln1328"> </a>
<a name="ln1329">    if (wait_done &amp;&amp;</a>
<a name="ln1330">        ar9300_mci_wait_for_interrupt(ah, AR_MCI_INTERRUPT_RAW, </a>
<a name="ln1331">                                    AR_MCI_INTERRUPT_SW_MSG_DONE, 500) == 0)</a>
<a name="ln1332">    {</a>
<a name="ln1333">        ar9300_mci_queue_unsent_gpm(ah, header, payload, AH_TRUE);</a>
<a name="ln1334">    }</a>
<a name="ln1335">    else {</a>
<a name="ln1336">        ar9300_mci_queue_unsent_gpm(ah, header, payload, AH_FALSE);</a>
<a name="ln1337">        msg_sent = AH_TRUE;</a>
<a name="ln1338">    }</a>
<a name="ln1339">    </a>
<a name="ln1340">    if (wait_done) {</a>
<a name="ln1341">        OS_REG_WRITE(ah, AR_MCI_INTERRUPT_EN, saved_mci_int_en);</a>
<a name="ln1342">    }</a>
<a name="ln1343"> </a>
<a name="ln1344">    return msg_sent;</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">u_int32_t ar9300_mci_get_interrupt(struct ath_hal *ah, u_int32_t *mci_int, </a>
<a name="ln1348">                                   u_int32_t *mci_int_rx_msg)</a>
<a name="ln1349">{</a>
<a name="ln1350">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1351"> </a>
<a name="ln1352">    *mci_int = ahp-&gt;ah_mci_int_raw;</a>
<a name="ln1353">    *mci_int_rx_msg = ahp-&gt;ah_mci_int_rx_msg;</a>
<a name="ln1354"> </a>
<a name="ln1355">    /* Clean int bits after the values are read. */</a>
<a name="ln1356">    ahp-&gt;ah_mci_int_raw = 0;</a>
<a name="ln1357">    ahp-&gt;ah_mci_int_rx_msg = 0;</a>
<a name="ln1358"> </a>
<a name="ln1359">    return 0;</a>
<a name="ln1360">}</a>
<a name="ln1361"> </a>
<a name="ln1362">u_int32_t ar9300_mci_check_int(struct ath_hal *ah, u_int32_t ints)</a>
<a name="ln1363">{</a>
<a name="ln1364">    u_int32_t reg;</a>
<a name="ln1365"> </a>
<a name="ln1366">    reg = OS_REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW);</a>
<a name="ln1367">    return ((reg &amp; ints) == ints);</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370">void ar9300_mci_sync_bt_state(struct ath_hal *ah)</a>
<a name="ln1371">{</a>
<a name="ln1372">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1373">    u_int32_t cur_bt_state;</a>
<a name="ln1374"> </a>
<a name="ln1375">    cur_bt_state = ar9300_mci_state(ah, HAL_MCI_STATE_REMOTE_SLEEP, NULL);</a>
<a name="ln1376">    if (ahp-&gt;ah_mci_bt_state != cur_bt_state) {</a>
<a name="ln1377">        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1378">            &quot;(MCI) %s: BT state mismatches. old: %d, new: %d\n&quot;,</a>
<a name="ln1379">            __func__, ahp-&gt;ah_mci_bt_state, cur_bt_state);</a>
<a name="ln1380">        ahp-&gt;ah_mci_bt_state = cur_bt_state;</a>
<a name="ln1381">    }</a>
<a name="ln1382">    if (ahp-&gt;ah_mci_bt_state != MCI_BT_SLEEP) {</a>
<a name="ln1383">#if MCI_QUERY_BT_VERSION_VERBOSE</a>
<a name="ln1384">        ar9300_mci_send_coex_version_query(ah, AH_TRUE);</a>
<a name="ln1385">#endif</a>
<a name="ln1386">        ar9300_mci_send_coex_wlan_channels(ah, AH_TRUE);</a>
<a name="ln1387">        if (ahp-&gt;ah_mci_unhalt_bt_gpm == AH_TRUE) {</a>
<a name="ln1388">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: UNHALT BT GPM\n&quot;, __func__);</a>
<a name="ln1389">            ar9300_mci_send_coex_halt_bt_gpm(ah, AH_FALSE, AH_TRUE);</a>
<a name="ln1390">        }</a>
<a name="ln1391">    }</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394">static HAL_BOOL ar9300_mci_is_gpm_valid(struct ath_hal *ah, u_int32_t msg_index)</a>
<a name="ln1395">{</a>
<a name="ln1396">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1397">    u_int32_t *payload;</a>
<a name="ln1398">    u_int32_t recv_type, offset = msg_index &lt;&lt; 4;</a>
<a name="ln1399"> </a>
<a name="ln1400">    if (msg_index == HAL_MCI_GPM_INVALID) {</a>
<a name="ln1401">        return AH_FALSE;</a>
<a name="ln1402">    }</a>
<a name="ln1403"> </a>
<a name="ln1404">    payload = (u_int32_t *) (ahp-&gt;ah_mci_gpm_buf + offset);</a>
<a name="ln1405">    recv_type = MCI_GPM_TYPE(payload);</a>
<a name="ln1406"> </a>
<a name="ln1407">    if (recv_type == MCI_GPM_RSVD_PATTERN) {</a>
<a name="ln1408">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) Skip RSVD GPM\n&quot;);</a>
<a name="ln1409">        return AH_FALSE;</a>
<a name="ln1410">    }</a>
<a name="ln1411"> </a>
<a name="ln1412">    return AH_TRUE;</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415">u_int32_t</a>
<a name="ln1416">ar9300_mci_state(struct ath_hal *ah, u_int32_t state_type, u_int32_t *p_data)</a>
<a name="ln1417">{</a>
<a name="ln1418">    u_int32_t   value = 0, more_gpm = 0, gpm_ptr;</a>
<a name="ln1419">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1420"> </a>
<a name="ln1421">    switch (state_type) {</a>
<a name="ln1422">        case HAL_MCI_STATE_ENABLE:</a>
<a name="ln1423">            if (AH_PRIVATE(ah)-&gt;ah_caps.halMciSupport &amp;&amp; ahp-&gt;ah_mci_ready) {</a>
<a name="ln1424">                value = OS_REG_READ(ah, AR_BTCOEX_CTRL);</a>
<a name="ln1425">                if ((value == 0xdeadbeef) || (value == 0xffffffff)) {</a>
<a name="ln1426">                        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1427">                            &quot;(MCI) BTCOEX_CTRL = 0xdeadbeef\n&quot;);</a>
<a name="ln1428">                    value = 0;</a>
<a name="ln1429">                }</a>
<a name="ln1430">            }</a>
<a name="ln1431">            value &amp;= AR_BTCOEX_CTRL_MCI_MODE_EN;</a>
<a name="ln1432">            break;</a>
<a name="ln1433"> </a>
<a name="ln1434">        case HAL_MCI_STATE_INIT_GPM_OFFSET:</a>
<a name="ln1435">            value = MS(OS_REG_READ(ah, AR_MCI_GPM_1), AR_MCI_GPM_WRITE_PTR);</a>
<a name="ln1436">            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1437">                    &quot;(MCI) %s: GPM initial WRITE_PTR=%d.\n&quot;, __func__, value);</a>
<a name="ln1438">            ahp-&gt;ah_mci_gpm_idx = value;</a>
<a name="ln1439">            break;</a>
<a name="ln1440"> </a>
<a name="ln1441">        case HAL_MCI_STATE_NEXT_GPM_OFFSET:</a>
<a name="ln1442">        case HAL_MCI_STATE_LAST_GPM_OFFSET:</a>
<a name="ln1443">            /*</a>
<a name="ln1444">             * This could be useful to avoid new GPM message interrupt which</a>
<a name="ln1445">             * may lead to spurious interrupt after power sleep, or multiple</a>
<a name="ln1446">             * entry of ath_coex_mci_intr().</a>
<a name="ln1447">             * Adding empty GPM check by returning HAL_MCI_GPM_INVALID can</a>
<a name="ln1448">             * alleviate this effect, but clearing GPM RX interrupt bit is</a>
<a name="ln1449">             * safe, because whether this is called from HAL or LMAC, there</a>
<a name="ln1450">             * must be an interrupt bit set/triggered initially.</a>
<a name="ln1451">             */</a>
<a name="ln1452">            OS_REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_RAW,</a>
<a name="ln1453">                         AR_MCI_INTERRUPT_RX_MSG_GPM);</a>
<a name="ln1454"> </a>
<a name="ln1455">            gpm_ptr = MS(OS_REG_READ(ah, AR_MCI_GPM_1), AR_MCI_GPM_WRITE_PTR);</a>
<a name="ln1456">            value = gpm_ptr;</a>
<a name="ln1457"> </a>
<a name="ln1458">            if (value == 0) {</a>
<a name="ln1459">                value = ahp-&gt;ah_mci_gpm_len - 1;</a>
<a name="ln1460">            }</a>
<a name="ln1461">            else if (value &gt;= ahp-&gt;ah_mci_gpm_len) {</a>
<a name="ln1462">                if (value != 0xFFFF) {</a>
<a name="ln1463">                    value = 0;</a>
<a name="ln1464">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1465">                        &quot;(MCI) %s: GPM offset out of range.\n&quot;, __func__);</a>
<a name="ln1466">                }</a>
<a name="ln1467">            }</a>
<a name="ln1468">            else {</a>
<a name="ln1469">                value--;</a>
<a name="ln1470">            }</a>
<a name="ln1471"> </a>
<a name="ln1472">            if (value == 0xFFFF) {</a>
<a name="ln1473">                value = HAL_MCI_GPM_INVALID;</a>
<a name="ln1474">                more_gpm = HAL_MCI_GPM_NOMORE;</a>
<a name="ln1475">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1476">                        &quot;(MCI) %s: GPM ptr invalid &quot;</a>
<a name="ln1477">                        &quot;@ptr=%d, @offset=%d, more=NOMORE.\n&quot;,</a>
<a name="ln1478">                        __func__, gpm_ptr, value);</a>
<a name="ln1479">            }</a>
<a name="ln1480">            else if (state_type == HAL_MCI_STATE_NEXT_GPM_OFFSET) {</a>
<a name="ln1481">                if (gpm_ptr == ahp-&gt;ah_mci_gpm_idx) {</a>
<a name="ln1482">                    value = HAL_MCI_GPM_INVALID;</a>
<a name="ln1483">                    more_gpm = HAL_MCI_GPM_NOMORE;</a>
<a name="ln1484">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1485">                            &quot;(MCI) %s: GPM message not available &quot;</a>
<a name="ln1486">                            &quot;@ptr=%d, @offset=%d, more=NOMORE.\n&quot;,</a>
<a name="ln1487">                            __func__, gpm_ptr, value);</a>
<a name="ln1488">                }</a>
<a name="ln1489">                else {</a>
<a name="ln1490">                    while (1) {</a>
<a name="ln1491">                        u_int32_t temp_index;</a>
<a name="ln1492"> </a>
<a name="ln1493">                        /* skip reserved GPM if any */</a>
<a name="ln1494">                        if (value != ahp-&gt;ah_mci_gpm_idx) {</a>
<a name="ln1495">                            more_gpm = HAL_MCI_GPM_MORE;</a>
<a name="ln1496">                        }</a>
<a name="ln1497">                        else {</a>
<a name="ln1498">                            more_gpm = HAL_MCI_GPM_NOMORE;</a>
<a name="ln1499">                        }</a>
<a name="ln1500">                        temp_index = ahp-&gt;ah_mci_gpm_idx;</a>
<a name="ln1501">                        ahp-&gt;ah_mci_gpm_idx++;</a>
<a name="ln1502">                        if (ahp-&gt;ah_mci_gpm_idx &gt;= ahp-&gt;ah_mci_gpm_len) {</a>
<a name="ln1503">                            ahp-&gt;ah_mci_gpm_idx = 0;</a>
<a name="ln1504">                        }</a>
<a name="ln1505">                        HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1506">                                &quot;(MCI) %s: GPM message got &quot;</a>
<a name="ln1507">                                &quot;@ptr=%d, @offset=%d, more=%s.\n&quot;,</a>
<a name="ln1508">                                __func__, gpm_ptr, temp_index,</a>
<a name="ln1509">                                (more_gpm == HAL_MCI_GPM_MORE)?&quot;MORE&quot;:&quot;NOMORE&quot;);</a>
<a name="ln1510">                        if (ar9300_mci_is_gpm_valid(ah, temp_index)) {</a>
<a name="ln1511">                            value = temp_index;</a>
<a name="ln1512">                            break;</a>
<a name="ln1513">                        }</a>
<a name="ln1514">                        if (more_gpm == HAL_MCI_GPM_NOMORE) {</a>
<a name="ln1515">                            value = HAL_MCI_GPM_INVALID;</a>
<a name="ln1516">                            break;</a>
<a name="ln1517">                        }</a>
<a name="ln1518">                    }</a>
<a name="ln1519">                }</a>
<a name="ln1520">                if (p_data != NULL) {</a>
<a name="ln1521">                    *p_data = more_gpm;</a>
<a name="ln1522">                }</a>
<a name="ln1523">            }</a>
<a name="ln1524">            if (value != HAL_MCI_GPM_INVALID) {</a>
<a name="ln1525">                value &lt;&lt;= 4;</a>
<a name="ln1526">            }</a>
<a name="ln1527">            break;</a>
<a name="ln1528"> </a>
<a name="ln1529">    case HAL_MCI_STATE_LAST_SCHD_MSG_OFFSET:</a>
<a name="ln1530">        value = MS(OS_REG_READ(ah, AR_MCI_RX_STATUS), </a>
<a name="ln1531">            AR_MCI_RX_LAST_SCHD_MSG_INDEX);</a>
<a name="ln1532"> </a>
<a name="ln1533">#if AH_MCI_DEBUG_PRINT_SCHED</a>
<a name="ln1534">        {</a>
<a name="ln1535">            u_int32_t index = value;</a>
<a name="ln1536">            u_int32_t prev_index, sched_idx;</a>
<a name="ln1537">            u_int32_t *pld;</a>
<a name="ln1538">            u_int8_t  *pld8;</a>
<a name="ln1539">            u_int32_t wbtimer = OS_REG_READ(ah, AR_BTCOEX_WBTIMER);</a>
<a name="ln1540">            u_int32_t schd_ctl = OS_REG_READ(ah, AR_MCI_HW_SCHD_TBL_CTL);</a>
<a name="ln1541"> </a>
<a name="ln1542">            if (index &gt; 0) {</a>
<a name="ln1543">                prev_index = index - 1;</a>
<a name="ln1544">            } else {</a>
<a name="ln1545">                prev_index = index;</a>
<a name="ln1546">            }</a>
<a name="ln1547"> </a>
<a name="ln1548">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) SCHED\n&quot;);</a>
<a name="ln1549">            HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1550">                &quot;(MCI) SCHED SCHD_TBL_CTRL=0x%08x, WBTIMER=0x%08x (%d)\n&quot;,</a>
<a name="ln1551">                schd_ctl, wbtimer, wbtimer);</a>
<a name="ln1552">            for (sched_idx = prev_index; sched_idx &lt;= index; sched_idx++) {</a>
<a name="ln1553">                pld = (u_int32_t *) (ahp-&gt;ah_mci_sched_buf + (sched_idx &lt;&lt; 4));</a>
<a name="ln1554">                pld8 = (u_int8_t *) pld;</a>
<a name="ln1555"> </a>
<a name="ln1556">                ar9300_mci_print_msg(ah, AH_FALSE, MCI_SCHD_INFO, 16, pld);</a>
<a name="ln1557">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1558">                    &quot;(MCI) SCHED    idx=%d, T1=0x%08x (%d), T2=0x%08x (%d)\n&quot;,</a>
<a name="ln1559">                    sched_idx,</a>
<a name="ln1560">                    pld[0], pld[0], pld[1], pld[1]);</a>
<a name="ln1561">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1562">                    &quot;(MCI) SCHED    addr=%d %s pwr=%d prio=%d %s link=%d\n&quot;,</a>
<a name="ln1563">                    pld8[11] &gt;&gt; 4,</a>
<a name="ln1564">                    (pld8[11] &amp; 0x08)?&quot;TX&quot;:&quot;RX&quot;,</a>
<a name="ln1565">                    (int8_t) (((pld8[11] &amp; 0x07) &lt;&lt; 5) | (pld8[10] &gt;&gt; 3)),</a>
<a name="ln1566">                    (((pld8[10] &amp; 0x07) &lt;&lt; 5) | (pld8[9] &gt;&gt; 3)),</a>
<a name="ln1567">                    (pld8[9] &amp; 0x04)?&quot;LE&quot;:&quot;BR/EDR&quot;,</a>
<a name="ln1568">                    (((pld8[9] &amp; 0x03) &lt;&lt; 2) | (pld8[8] &gt;&gt; 6)));</a>
<a name="ln1569">            }</a>
<a name="ln1570">        }</a>
<a name="ln1571">#endif /* AH_MCI_DEBUG_PRINT_SCHED */</a>
<a name="ln1572"> </a>
<a name="ln1573">        /* Make it in bytes */</a>
<a name="ln1574">        value &lt;&lt;= 4;</a>
<a name="ln1575">        break;</a>
<a name="ln1576"> </a>
<a name="ln1577">    case HAL_MCI_STATE_REMOTE_SLEEP:</a>
<a name="ln1578">        value = MS(OS_REG_READ(ah, AR_MCI_RX_STATUS), </a>
<a name="ln1579">            AR_MCI_RX_REMOTE_SLEEP) ? MCI_BT_SLEEP : MCI_BT_AWAKE;</a>
<a name="ln1580">        break;</a>
<a name="ln1581"> </a>
<a name="ln1582">        case HAL_MCI_STATE_CONT_RSSI_POWER:</a>
<a name="ln1583">            value = MS(ahp-&gt;ah_mci_cont_status,</a>
<a name="ln1584">                AR_MCI_CONT_RSSI_POWER);</a>
<a name="ln1585">            break;</a>
<a name="ln1586"> </a>
<a name="ln1587">        case HAL_MCI_STATE_CONT_PRIORITY:</a>
<a name="ln1588">            value = MS(ahp-&gt;ah_mci_cont_status,</a>
<a name="ln1589">                AR_MCI_CONT_RRIORITY);</a>
<a name="ln1590">            break;</a>
<a name="ln1591"> </a>
<a name="ln1592">        case HAL_MCI_STATE_CONT_TXRX:</a>
<a name="ln1593">            value = MS(ahp-&gt;ah_mci_cont_status,</a>
<a name="ln1594">                AR_MCI_CONT_TXRX);</a>
<a name="ln1595">            break;</a>
<a name="ln1596"> </a>
<a name="ln1597">        case HAL_MCI_STATE_BT:</a>
<a name="ln1598">            value = ahp-&gt;ah_mci_bt_state;</a>
<a name="ln1599">            break;</a>
<a name="ln1600"> </a>
<a name="ln1601">        case HAL_MCI_STATE_SET_BT_SLEEP:</a>
<a name="ln1602">            ahp-&gt;ah_mci_bt_state = MCI_BT_SLEEP;</a>
<a name="ln1603">            break;</a>
<a name="ln1604"> </a>
<a name="ln1605">        case HAL_MCI_STATE_SET_BT_AWAKE:</a>
<a name="ln1606">            ahp-&gt;ah_mci_bt_state = MCI_BT_AWAKE;</a>
<a name="ln1607">            ar9300_mci_send_coex_version_query(ah, AH_TRUE);</a>
<a name="ln1608">            ar9300_mci_send_coex_wlan_channels(ah, AH_TRUE);</a>
<a name="ln1609">            if (ahp-&gt;ah_mci_unhalt_bt_gpm == AH_TRUE) {</a>
<a name="ln1610">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1611">                    &quot;(MCI) %s: UNHALT BT GPM\n&quot;, __func__);</a>
<a name="ln1612">                ar9300_mci_send_coex_halt_bt_gpm(ah, AH_FALSE, AH_TRUE);</a>
<a name="ln1613">            }</a>
<a name="ln1614">            ar9300_mci_2g5g_switch(ah, AH_TRUE);</a>
<a name="ln1615">            break;</a>
<a name="ln1616"> </a>
<a name="ln1617">        case HAL_MCI_STATE_SET_BT_CAL_START:</a>
<a name="ln1618">            ahp-&gt;ah_mci_bt_state = MCI_BT_CAL_START;</a>
<a name="ln1619">            break;</a>
<a name="ln1620"> </a>
<a name="ln1621">        case HAL_MCI_STATE_SET_BT_CAL:</a>
<a name="ln1622">            ahp-&gt;ah_mci_bt_state = MCI_BT_CAL;</a>
<a name="ln1623">            break;</a>
<a name="ln1624"> </a>
<a name="ln1625">        case HAL_MCI_STATE_RESET_REQ_WAKE:</a>
<a name="ln1626">            ar9300_mci_reset_req_wakeup(ah);</a>
<a name="ln1627">            ahp-&gt;ah_mci_coex_2g5g_update = AH_TRUE;</a>
<a name="ln1628"> </a>
<a name="ln1629">            if ((AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) &amp;&amp; </a>
<a name="ln1630">                (ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln1631">                 ATH_MCI_CONFIG_MCI_OBS_MASK))</a>
<a name="ln1632">            {</a>
<a name="ln1633">                /* Check if we still have control of the GPIOs */</a>
<a name="ln1634">                if ((OS_REG_READ(ah, AR_GLB_GPIO_CONTROL) &amp; </a>
<a name="ln1635">                     ATH_MCI_CONFIG_MCI_OBS_GPIO) != </a>
<a name="ln1636">                     ATH_MCI_CONFIG_MCI_OBS_GPIO)</a>
<a name="ln1637">                 {</a>
<a name="ln1638">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1639">                        &quot;(MCI) Reconfigure observation\n&quot;);</a>
<a name="ln1640">                    ar9300_mci_observation_set_up(ah);</a>
<a name="ln1641">                 }</a>
<a name="ln1642">            }</a>
<a name="ln1643"> </a>
<a name="ln1644">            break;</a>
<a name="ln1645">            </a>
<a name="ln1646">        case HAL_MCI_STATE_SEND_WLAN_COEX_VERSION:</a>
<a name="ln1647">            ar9300_mci_send_coex_version_response(ah, AH_TRUE);</a>
<a name="ln1648">            break;</a>
<a name="ln1649"> </a>
<a name="ln1650">        case HAL_MCI_STATE_SET_BT_COEX_VERSION:</a>
<a name="ln1651">            if (p_data == NULL) {</a>
<a name="ln1652">                HALDEBUG(ah, HAL_DEBUG_BT_COEX,</a>
<a name="ln1653">                    &quot;(MCI) Error: Set BT Coex version with NULL data !!!\n&quot;);</a>
<a name="ln1654">            }</a>
<a name="ln1655">            else {</a>
<a name="ln1656">                ahp-&gt;ah_mci_coex_major_version_bt = (*p_data &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln1657">                ahp-&gt;ah_mci_coex_minor_version_bt = (*p_data) &amp; 0xff;</a>
<a name="ln1658">                ahp-&gt;ah_mci_coex_bt_version_known = AH_TRUE;</a>
<a name="ln1659">                HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) BT version set: %d.%d\n&quot;,</a>
<a name="ln1660">                        ahp-&gt;ah_mci_coex_major_version_bt,</a>
<a name="ln1661">                        ahp-&gt;ah_mci_coex_minor_version_bt);</a>
<a name="ln1662">            }</a>
<a name="ln1663">            break;</a>
<a name="ln1664"> </a>
<a name="ln1665">        case HAL_MCI_STATE_SEND_WLAN_CHANNELS:</a>
<a name="ln1666">            if (p_data != NULL)</a>
<a name="ln1667">            {</a>
<a name="ln1668">                if (((ahp-&gt;ah_mci_coex_wlan_channels[1] &amp; 0xffff0000) ==</a>
<a name="ln1669">                    (*(p_data + 1) &amp; 0xffff0000)) &amp;&amp;</a>
<a name="ln1670">                    (ahp-&gt;ah_mci_coex_wlan_channels[2] == *(p_data + 2)) &amp;&amp;</a>
<a name="ln1671">                    (ahp-&gt;ah_mci_coex_wlan_channels[3] == *(p_data + 3)))</a>
<a name="ln1672">                {</a>
<a name="ln1673">                    break;</a>
<a name="ln1674">                }</a>
<a name="ln1675">                ahp-&gt;ah_mci_coex_wlan_channels[0] = *p_data++;</a>
<a name="ln1676">                ahp-&gt;ah_mci_coex_wlan_channels[1] = *p_data++;</a>
<a name="ln1677">                ahp-&gt;ah_mci_coex_wlan_channels[2] = *p_data++;</a>
<a name="ln1678">                ahp-&gt;ah_mci_coex_wlan_channels[3] = *p_data++;</a>
<a name="ln1679">            }</a>
<a name="ln1680">            ahp-&gt;ah_mci_coex_wlan_channels_update = AH_TRUE;</a>
<a name="ln1681">            ar9300_mci_send_coex_wlan_channels(ah, AH_TRUE);</a>
<a name="ln1682">            break;</a>
<a name="ln1683"> </a>
<a name="ln1684">        case HAL_MCI_STATE_SEND_VERSION_QUERY:</a>
<a name="ln1685">            ar9300_mci_send_coex_version_query(ah, AH_TRUE);</a>
<a name="ln1686">            break;</a>
<a name="ln1687"> </a>
<a name="ln1688">        case HAL_MCI_STATE_SEND_STATUS_QUERY:</a>
<a name="ln1689">            if (AR_SREV_JUPITER_10(ah)) {</a>
<a name="ln1690">                ar9300_mci_send_coex_bt_status_query(ah, AH_TRUE,</a>
<a name="ln1691">                        MCI_GPM_COEX_QUERY_BT_ALL_INFO);</a>
<a name="ln1692">            } else {</a>
<a name="ln1693">                ar9300_mci_send_coex_bt_status_query(ah, AH_TRUE,</a>
<a name="ln1694">                        MCI_GPM_COEX_QUERY_BT_TOPOLOGY);</a>
<a name="ln1695">            }</a>
<a name="ln1696">            break;</a>
<a name="ln1697"> </a>
<a name="ln1698">        case HAL_MCI_STATE_NEED_FLUSH_BT_INFO:</a>
<a name="ln1699">            /*</a>
<a name="ln1700">             * ah_mci_unhalt_bt_gpm means whether it's needed to send</a>
<a name="ln1701">             * UNHALT message. It's set whenever there's a request to send HALT</a>
<a name="ln1702">             * message. ah_mci_halted_bt_gpm means whether HALT message is sent</a>
<a name="ln1703">             * out successfully.</a>
<a name="ln1704">             *</a>
<a name="ln1705">             * Checking (ah_mci_unhalt_bt_gpm == AH_FALSE) instead of checking</a>
<a name="ln1706">             * (ahp-&gt;ah_mci_halted_bt_gpm == AH_FALSE) will make sure currently is</a>
<a name="ln1707">             * in UNHALT-ed mode and BT can respond to status query.</a>
<a name="ln1708">             */</a>
<a name="ln1709">            if ((ahp-&gt;ah_mci_unhalt_bt_gpm == AH_FALSE) &amp;&amp;</a>
<a name="ln1710">                (ahp-&gt;ah_mci_need_flush_btinfo == AH_TRUE))</a>
<a name="ln1711">            {</a>
<a name="ln1712">                value = 1;</a>
<a name="ln1713">            }</a>
<a name="ln1714">            else {</a>
<a name="ln1715">                value = 0;</a>
<a name="ln1716">            }</a>
<a name="ln1717">            if (p_data != NULL) {</a>
<a name="ln1718">                ahp-&gt;ah_mci_need_flush_btinfo = (*p_data != 0)? AH_TRUE : AH_FALSE;</a>
<a name="ln1719">            }</a>
<a name="ln1720">            break;</a>
<a name="ln1721"> </a>
<a name="ln1722">        case HAL_MCI_STATE_SET_CONCUR_TX_PRI:</a>
<a name="ln1723">            if (p_data) {</a>
<a name="ln1724">                ahp-&gt;ah_mci_stomp_none_tx_pri = *p_data &amp; 0xff;</a>
<a name="ln1725">                ahp-&gt;ah_mci_stomp_low_tx_pri = (*p_data &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln1726">                ahp-&gt;ah_mci_stomp_all_tx_pri = (*p_data &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln1727">            }</a>
<a name="ln1728">            break;</a>
<a name="ln1729"> </a>
<a name="ln1730">        case HAL_MCI_STATE_RECOVER_RX:</a>
<a name="ln1731">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) hal RECOVER_RX\n&quot;);</a>
<a name="ln1732">            ar9300_mci_prep_interface(ah);</a>
<a name="ln1733">            ahp-&gt;ah_mci_query_bt = AH_TRUE;</a>
<a name="ln1734">            ahp-&gt;ah_mci_need_flush_btinfo = AH_TRUE;</a>
<a name="ln1735">            ar9300_mci_send_coex_wlan_channels(ah, AH_TRUE);</a>
<a name="ln1736">            ar9300_mci_2g5g_switch(ah, AH_TRUE);</a>
<a name="ln1737">            break;</a>
<a name="ln1738">            </a>
<a name="ln1739">        case HAL_MCI_STATE_DEBUG:</a>
<a name="ln1740">            if (p_data != NULL) {</a>
<a name="ln1741">                if (*p_data == HAL_MCI_STATE_DEBUG_REQ_BT_DEBUG) {</a>
<a name="ln1742">                    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) QUERY_BT_DEBUG\n&quot;);</a>
<a name="ln1743">                    ar9300_mci_send_coex_bt_status_query(ah, AH_TRUE,</a>
<a name="ln1744">                        MCI_GPM_COEX_QUERY_BT_DEBUG);</a>
<a name="ln1745">                    OS_DELAY(10);</a>
<a name="ln1746">                    if (AR_SREV_JUPITER_20_OR_LATER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln1747">                        ar9300_mci_send_coex_bt_flags(ah, AH_TRUE,</a>
<a name="ln1748">                            MCI_GPM_COEX_BT_FLAGS_READ, 0);</a>
<a name="ln1749">                    }</a>
<a name="ln1750">                }</a>
<a name="ln1751">            }</a>
<a name="ln1752">            break;</a>
<a name="ln1753"> </a>
<a name="ln1754">        case HAL_MCI_STATE_NEED_FTP_STOMP:</a>
<a name="ln1755">            value = (ah-&gt;ah_config.ath_hal_mci_config &amp;</a>
<a name="ln1756">                     ATH_MCI_CONFIG_DISABLE_FTP_STOMP) ? 0 : 1;</a>
<a name="ln1757">            break;</a>
<a name="ln1758"> </a>
<a name="ln1759">        case HAL_MCI_STATE_NEED_TUNING:</a>
<a name="ln1760">            value = (ah-&gt;ah_config.ath_hal_mci_config &amp;</a>
<a name="ln1761">                     ATH_MCI_CONFIG_DISABLE_TUNING) ? 0 : 1;</a>
<a name="ln1762">            break;</a>
<a name="ln1763"> </a>
<a name="ln1764">        case HAL_MCI_STATE_SHARED_CHAIN_CONCUR_TX:</a>
<a name="ln1765">            value = ((ah-&gt;ah_config.ath_hal_mci_config &amp;</a>
<a name="ln1766">                     ATH_MCI_CONFIG_CONCUR_TX) == </a>
<a name="ln1767">                     ATH_MCI_CONCUR_TX_SHARED_CHN)? 1 : 0;</a>
<a name="ln1768">            break;</a>
<a name="ln1769"> </a>
<a name="ln1770">        default:</a>
<a name="ln1771">            break;</a>
<a name="ln1772">    }</a>
<a name="ln1773">    return value;</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">void ar9300_mci_detach(struct ath_hal *ah)</a>
<a name="ln1777">{</a>
<a name="ln1778">    /* Turn off MCI and Jupiter mode. */</a>
<a name="ln1779">    OS_REG_WRITE(ah, AR_BTCOEX_CTRL, 0x00);</a>
<a name="ln1780">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) ar9300_mci_detach\n&quot;);</a>
<a name="ln1781">    ar9300_mci_disable_interrupt(ah);</a>
<a name="ln1782">}</a>
<a name="ln1783"> </a>
<a name="ln1784">/*</a>
<a name="ln1785"> * Low priority BT: 0 - 59(0x3b)</a>
<a name="ln1786"> * High priority BT: 60 - 125(0x7d)</a>
<a name="ln1787"> * Critical BT: 126 - 255</a>
<a name="ln1788"> </a>
<a name="ln1789">    BTCOEX_WL_WEIGHTS0_VALUE0 ; // wl_idle                       </a>
<a name="ln1790">    BTCOEX_WL_WEIGHTS0_VALUE1 ; // sw_ctrl[3] - all_stomp        </a>
<a name="ln1791">    BTCOEX_WL_WEIGHTS0_VALUE2 ; // sw_ctrl[2] - all_not_stomp    </a>
<a name="ln1792">    BTCOEX_WL_WEIGHTS0_VALUE3 ; // sw_ctrl[1] - pa_pre_distortion</a>
<a name="ln1793">    BTCOEX_WL_WEIGHTS1_VALUE0 ; // sw_ctrl[0] - general purpose  </a>
<a name="ln1794">    BTCOEX_WL_WEIGHTS1_VALUE1 ; // tm_wl_wait_beacon             </a>
<a name="ln1795">    BTCOEX_WL_WEIGHTS1_VALUE2 ; // ts_state_wait_ack_cts         </a>
<a name="ln1796">    BTCOEX_WL_WEIGHTS1_VALUE3 ; // self_gen                      </a>
<a name="ln1797">    BTCOEX_WL_WEIGHTS2_VALUE0 ; // idle                          </a>
<a name="ln1798">    BTCOEX_WL_WEIGHTS2_VALUE1 ; // rx                            </a>
<a name="ln1799">    BTCOEX_WL_WEIGHTS2_VALUE2 ; // tx                            </a>
<a name="ln1800">    BTCOEX_WL_WEIGHTS2_VALUE3 ; // rx + tx                       </a>
<a name="ln1801">    BTCOEX_WL_WEIGHTS3_VALUE0 ; // tx                            </a>
<a name="ln1802">    BTCOEX_WL_WEIGHTS3_VALUE1 ; // rx                            </a>
<a name="ln1803">    BTCOEX_WL_WEIGHTS3_VALUE2 ; // tx                            </a>
<a name="ln1804">    BTCOEX_WL_WEIGHTS3_VALUE3 ; // rx + tx                       </a>
<a name="ln1805"> </a>
<a name="ln1806">    Stomp all:</a>
<a name="ln1807">    ah_bt_coex_wlan_weight[0] = 0x00007d00</a>
<a name="ln1808">    ah_bt_coex_wlan_weight[1] = 0x7d7d7d00</a>
<a name="ln1809">    ah_bt_coex_wlan_weight[2] = 0x7d7d7d00</a>
<a name="ln1810">    ah_bt_coex_wlan_weight[3] = 0x7d7d7d7d</a>
<a name="ln1811">    Stomp low:</a>
<a name="ln1812">    ah_bt_coex_wlan_weight[0] = 0x00007d00</a>
<a name="ln1813">    ah_bt_coex_wlan_weight[1] = 0x7d3b3b00</a>
<a name="ln1814">    ah_bt_coex_wlan_weight[2] = 0x3b3b3b00</a>
<a name="ln1815">    ah_bt_coex_wlan_weight[3] = 0x3b3b3b3b</a>
<a name="ln1816">    Stomp none:</a>
<a name="ln1817">    ah_bt_coex_wlan_weight[0] = 0x00007d00</a>
<a name="ln1818">    ah_bt_coex_wlan_weight[1] = 0x7d000000</a>
<a name="ln1819">    ah_bt_coex_wlan_weight[2] = 0x00000000</a>
<a name="ln1820">    ah_bt_coex_wlan_weight[3] = 0x00000000</a>
<a name="ln1821">*/</a>
<a name="ln1822"> </a>
<a name="ln1823">void ar9300_mci_bt_coex_set_weights(struct ath_hal *ah, u_int32_t stomp_type)</a>
<a name="ln1824">{</a>
<a name="ln1825">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1826">//    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln1827">    u_int32_t tx_priority = 0;</a>
<a name="ln1828"> </a>
<a name="ln1829">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: stomp_type=%d\n&quot;, __func__, stomp_type);</a>
<a name="ln1830"> </a>
<a name="ln1831">    switch (stomp_type) {</a>
<a name="ln1832">    case HAL_BT_COEX_STOMP_ALL:</a>
<a name="ln1833">        ahp-&gt;ah_bt_coex_wlan_weight[0] = JUPITER_STOMP_ALL_WLAN_WGHT0;</a>
<a name="ln1834">        ahp-&gt;ah_bt_coex_wlan_weight[1] = JUPITER_STOMP_ALL_WLAN_WGHT1;</a>
<a name="ln1835">        ahp-&gt;ah_bt_coex_wlan_weight[2] = JUPITER_STOMP_ALL_WLAN_WGHT2;</a>
<a name="ln1836">        ahp-&gt;ah_bt_coex_wlan_weight[3] = JUPITER_STOMP_ALL_WLAN_WGHT3;</a>
<a name="ln1837">        if (ahp-&gt;ah_mci_concur_tx_en &amp;&amp; ahp-&gt;ah_mci_stomp_all_tx_pri) {</a>
<a name="ln1838">            tx_priority = ahp-&gt;ah_mci_stomp_all_tx_pri;</a>
<a name="ln1839">        }</a>
<a name="ln1840">        break;</a>
<a name="ln1841">    case HAL_BT_COEX_STOMP_LOW:</a>
<a name="ln1842">        if (ahp-&gt;ah_bt_coex_flag &amp; HAL_BT_COEX_FLAG_MCI_FTP_STOMP_RX) {</a>
<a name="ln1843">            ahp-&gt;ah_bt_coex_wlan_weight[0] = JUPITER_STOMP_LOW_FTP_WLAN_WGHT0;</a>
<a name="ln1844">            ahp-&gt;ah_bt_coex_wlan_weight[1] = JUPITER_STOMP_LOW_FTP_WLAN_WGHT1;</a>
<a name="ln1845">            ahp-&gt;ah_bt_coex_wlan_weight[2] = JUPITER_STOMP_LOW_FTP_WLAN_WGHT2;</a>
<a name="ln1846">            ahp-&gt;ah_bt_coex_wlan_weight[3] = JUPITER_STOMP_LOW_FTP_WLAN_WGHT3;</a>
<a name="ln1847">        }</a>
<a name="ln1848">        else {</a>
<a name="ln1849">            ahp-&gt;ah_bt_coex_wlan_weight[0] = JUPITER_STOMP_LOW_WLAN_WGHT0;</a>
<a name="ln1850">            ahp-&gt;ah_bt_coex_wlan_weight[1] = JUPITER_STOMP_LOW_WLAN_WGHT1;</a>
<a name="ln1851">            ahp-&gt;ah_bt_coex_wlan_weight[2] = JUPITER_STOMP_LOW_WLAN_WGHT2;</a>
<a name="ln1852">            ahp-&gt;ah_bt_coex_wlan_weight[3] = JUPITER_STOMP_LOW_WLAN_WGHT3;</a>
<a name="ln1853">        }</a>
<a name="ln1854">        if (ahp-&gt;ah_mci_concur_tx_en &amp;&amp; ahp-&gt;ah_mci_stomp_low_tx_pri) {</a>
<a name="ln1855">            tx_priority = ahp-&gt;ah_mci_stomp_low_tx_pri;</a>
<a name="ln1856">        }</a>
<a name="ln1857">        if (ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln1858">            ATH_MCI_CONFIG_MCI_OBS_TXRX)</a>
<a name="ln1859">        {</a>
<a name="ln1860">            ar9300_gpio_set(ah, 5, 1);</a>
<a name="ln1861">        }</a>
<a name="ln1862">        break;</a>
<a name="ln1863">    case HAL_BT_COEX_STOMP_ALL_FORCE:</a>
<a name="ln1864">        ahp-&gt;ah_bt_coex_wlan_weight[0] = JUPITER_STOMP_ALL_FORCE_WLAN_WGHT0;</a>
<a name="ln1865">        ahp-&gt;ah_bt_coex_wlan_weight[1] = JUPITER_STOMP_ALL_FORCE_WLAN_WGHT1;</a>
<a name="ln1866">        ahp-&gt;ah_bt_coex_wlan_weight[2] = JUPITER_STOMP_ALL_FORCE_WLAN_WGHT2;</a>
<a name="ln1867">        ahp-&gt;ah_bt_coex_wlan_weight[3] = JUPITER_STOMP_ALL_FORCE_WLAN_WGHT3;</a>
<a name="ln1868">        break;</a>
<a name="ln1869">    case HAL_BT_COEX_STOMP_LOW_FORCE:</a>
<a name="ln1870">        ahp-&gt;ah_bt_coex_wlan_weight[0] = JUPITER_STOMP_LOW_FORCE_WLAN_WGHT0;</a>
<a name="ln1871">        ahp-&gt;ah_bt_coex_wlan_weight[1] = JUPITER_STOMP_LOW_FORCE_WLAN_WGHT1;</a>
<a name="ln1872">        ahp-&gt;ah_bt_coex_wlan_weight[2] = JUPITER_STOMP_LOW_FORCE_WLAN_WGHT2;</a>
<a name="ln1873">        ahp-&gt;ah_bt_coex_wlan_weight[3] = JUPITER_STOMP_LOW_FORCE_WLAN_WGHT3;</a>
<a name="ln1874">        if (ahp-&gt;ah_mci_concur_tx_en &amp;&amp; ahp-&gt;ah_mci_stomp_low_tx_pri) {</a>
<a name="ln1875">            tx_priority = ahp-&gt;ah_mci_stomp_low_tx_pri;</a>
<a name="ln1876">        }</a>
<a name="ln1877">        break;</a>
<a name="ln1878">    case HAL_BT_COEX_STOMP_NONE:</a>
<a name="ln1879">    case HAL_BT_COEX_NO_STOMP:</a>
<a name="ln1880">        ahp-&gt;ah_bt_coex_wlan_weight[0] = JUPITER_STOMP_NONE_WLAN_WGHT0;</a>
<a name="ln1881">        ahp-&gt;ah_bt_coex_wlan_weight[1] = JUPITER_STOMP_NONE_WLAN_WGHT1;</a>
<a name="ln1882">        ahp-&gt;ah_bt_coex_wlan_weight[2] = JUPITER_STOMP_NONE_WLAN_WGHT2;</a>
<a name="ln1883">        ahp-&gt;ah_bt_coex_wlan_weight[3] = JUPITER_STOMP_NONE_WLAN_WGHT3;</a>
<a name="ln1884">        if (ahp-&gt;ah_mci_concur_tx_en &amp;&amp; ahp-&gt;ah_mci_stomp_none_tx_pri) {</a>
<a name="ln1885">            tx_priority = ahp-&gt;ah_mci_stomp_none_tx_pri;</a>
<a name="ln1886">        }</a>
<a name="ln1887">        if (ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln1888">            ATH_MCI_CONFIG_MCI_OBS_TXRX)</a>
<a name="ln1889">        {</a>
<a name="ln1890">            ar9300_gpio_set(ah, 5, 0);</a>
<a name="ln1891">        }</a>
<a name="ln1892">        break;</a>
<a name="ln1893">    case HAL_BT_COEX_STOMP_AUDIO:</a>
<a name="ln1894">        ahp-&gt;ah_bt_coex_wlan_weight[0] = 0xffffff01;</a>
<a name="ln1895">        ahp-&gt;ah_bt_coex_wlan_weight[1] = 0xffffffff;</a>
<a name="ln1896">        ahp-&gt;ah_bt_coex_wlan_weight[2] = 0xffffff01;</a>
<a name="ln1897">        ahp-&gt;ah_bt_coex_wlan_weight[3] = 0xffffffff;</a>
<a name="ln1898">        break;</a>
<a name="ln1899">    default:</a>
<a name="ln1900">        /* There is a forceWeight from registry */</a>
<a name="ln1901">        ahp-&gt;ah_bt_coex_wlan_weight[0] = stomp_type;</a>
<a name="ln1902">        ahp-&gt;ah_bt_coex_wlan_weight[1] = stomp_type;</a>
<a name="ln1903">        break;</a>
<a name="ln1904">    }</a>
<a name="ln1905"> </a>
<a name="ln1906">    if (ahp-&gt;ah_mci_concur_tx_en &amp;&amp; tx_priority) {</a>
<a name="ln1907">        ahp-&gt;ah_bt_coex_wlan_weight[1] &amp;= ~MCI_CONCUR_TX_WLAN_WGHT1_MASK;</a>
<a name="ln1908">        ahp-&gt;ah_bt_coex_wlan_weight[1] |= </a>
<a name="ln1909">            SM(tx_priority, MCI_CONCUR_TX_WLAN_WGHT1_MASK);</a>
<a name="ln1910">        ahp-&gt;ah_bt_coex_wlan_weight[2] &amp;= ~MCI_CONCUR_TX_WLAN_WGHT2_MASK;</a>
<a name="ln1911">        ahp-&gt;ah_bt_coex_wlan_weight[2] |= </a>
<a name="ln1912">            SM(tx_priority, MCI_CONCUR_TX_WLAN_WGHT2_MASK);</a>
<a name="ln1913">        ahp-&gt;ah_bt_coex_wlan_weight[3] &amp;= ~MCI_CONCUR_TX_WLAN_WGHT3_MASK;</a>
<a name="ln1914">        ahp-&gt;ah_bt_coex_wlan_weight[3] |= </a>
<a name="ln1915">            SM(tx_priority, MCI_CONCUR_TX_WLAN_WGHT3_MASK);</a>
<a name="ln1916">        ahp-&gt;ah_bt_coex_wlan_weight[3] &amp;= ~MCI_CONCUR_TX_WLAN_WGHT3_MASK2;</a>
<a name="ln1917">        ahp-&gt;ah_bt_coex_wlan_weight[3] |= </a>
<a name="ln1918">            SM(tx_priority, MCI_CONCUR_TX_WLAN_WGHT3_MASK2);</a>
<a name="ln1919">    }</a>
<a name="ln1920">//    if (ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln1921">//        ATH_MCI_CONFIG_MCI_WEIGHT_DBG)</a>
<a name="ln1922">//    {</a>
<a name="ln1923">        HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln1924">                &quot;(MCI) Set weights: 0x%08x 0x%08x 0x%08x 0x%08x\n&quot;,</a>
<a name="ln1925">                ahp-&gt;ah_bt_coex_wlan_weight[0],</a>
<a name="ln1926">                ahp-&gt;ah_bt_coex_wlan_weight[1],</a>
<a name="ln1927">                ahp-&gt;ah_bt_coex_wlan_weight[2],</a>
<a name="ln1928">                ahp-&gt;ah_bt_coex_wlan_weight[3]);</a>
<a name="ln1929">//    }</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932">void ar9300_mci_bt_coex_disable(struct ath_hal *ah)</a>
<a name="ln1933">{</a>
<a name="ln1934">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1935"> </a>
<a name="ln1936">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln1937">        &quot;(MCI) %s: Set weight to stomp none.\n&quot;, __func__);</a>
<a name="ln1938"> </a>
<a name="ln1939">    ar9300_mci_bt_coex_set_weights(ah, HAL_BT_COEX_STOMP_NONE);</a>
<a name="ln1940"> </a>
<a name="ln1941">    /* </a>
<a name="ln1942">     * In Jupiter, when coex is disabled, we just set weight</a>
<a name="ln1943">     * table to be in favor of WLAN.</a>
<a name="ln1944">     */</a>
<a name="ln1945">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS0, ahp-&gt;ah_bt_coex_wlan_weight[0]);</a>
<a name="ln1946">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS1, ahp-&gt;ah_bt_coex_wlan_weight[1]);</a>
<a name="ln1947">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS2, ahp-&gt;ah_bt_coex_wlan_weight[2]);</a>
<a name="ln1948">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS3, ahp-&gt;ah_bt_coex_wlan_weight[3]);</a>
<a name="ln1949"> </a>
<a name="ln1950">    ahp-&gt;ah_bt_coex_enabled = AH_FALSE;</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953">int ar9300_mci_bt_coex_enable(struct ath_hal *ah)</a>
<a name="ln1954">{</a>
<a name="ln1955">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1956"> </a>
<a name="ln1957">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) %s: called\n&quot;, __func__);</a>
<a name="ln1958"> </a>
<a name="ln1959">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, </a>
<a name="ln1960">        &quot;(MCI) Write weights: 0x%08x 0x%08x 0x%08x 0x%08x\n&quot;,</a>
<a name="ln1961">       ahp-&gt;ah_bt_coex_wlan_weight[0],</a>
<a name="ln1962">       ahp-&gt;ah_bt_coex_wlan_weight[1],</a>
<a name="ln1963">       ahp-&gt;ah_bt_coex_wlan_weight[2],</a>
<a name="ln1964">       ahp-&gt;ah_bt_coex_wlan_weight[3]);</a>
<a name="ln1965"> </a>
<a name="ln1966"> </a>
<a name="ln1967">    /* Mainly change the WLAN weight table */</a>
<a name="ln1968">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS0, ahp-&gt;ah_bt_coex_wlan_weight[0]);</a>
<a name="ln1969">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS1, ahp-&gt;ah_bt_coex_wlan_weight[1]);</a>
<a name="ln1970">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS2, ahp-&gt;ah_bt_coex_wlan_weight[2]);</a>
<a name="ln1971">    OS_REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS3, ahp-&gt;ah_bt_coex_wlan_weight[3]);</a>
<a name="ln1972"> </a>
<a name="ln1973">    /* Send ACK even when BT has higher priority. */</a>
<a name="ln1974">    OS_REG_RMW_FIELD(ah, AR_QUIET1, AR_QUIET1_QUIET_ACK_CTS_ENABLE, 1);</a>
<a name="ln1975"> </a>
<a name="ln1976">    if (ahp-&gt;ah_bt_coex_flag &amp; HAL_BT_COEX_FLAG_LOW_ACK_PWR) {</a>
<a name="ln1977">        OS_REG_WRITE(ah, AR_TPC, HAL_BT_COEX_LOW_ACK_POWER);</a>
<a name="ln1978">    }</a>
<a name="ln1979">    else {</a>
<a name="ln1980">        OS_REG_WRITE(ah, AR_TPC, HAL_BT_COEX_HIGH_ACK_POWER);</a>
<a name="ln1981">    }</a>
<a name="ln1982"> </a>
<a name="ln1983">    ahp-&gt;ah_bt_coex_enabled = AH_TRUE;</a>
<a name="ln1984"> </a>
<a name="ln1985">    return 0;</a>
<a name="ln1986">}</a>
<a name="ln1987"> </a>
<a name="ln1988">#endif /* ATH_SUPPORT_MCI */</a>

</code></pre>
<div class="balloon" rel="222"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The '(MCI_GPM_COEX_VERSION_QUERY)' named constant with the value of 0 is used in the bitwise operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
