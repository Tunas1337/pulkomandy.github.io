
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rt2860.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * Copyright (c) 2007-2010 Damien Bergamini &lt;damien.bergamini@free.fr&gt;</a>
<a name="ln3"> * Copyright (c) 2012 Bernhard Schmidt &lt;bschmidt@FreeBSD.org&gt;</a>
<a name="ln4"> *</a>
<a name="ln5"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln6"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln7"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln8"> *</a>
<a name="ln9"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln10"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln11"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln12"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln13"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln14"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln15"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln16"> *</a>
<a name="ln17"> * $OpenBSD: rt2860.c,v 1.65 2010/10/23 14:24:54 damien Exp $</a>
<a name="ln18"> */</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln21">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/ral/rt2860.c 327479 2018-01-02 00:07:28Z adrian $&quot;);</a>
<a name="ln22"> </a>
<a name="ln23">/*-</a>
<a name="ln24"> * Ralink Technology RT2860/RT3090/RT3390/RT3562/RT5390/RT5392 chipset driver</a>
<a name="ln25"> * http://www.ralinktech.com/</a>
<a name="ln26"> */</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;sys/param.h&gt;</a>
<a name="ln29">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln30">#include &lt;sys/sockio.h&gt;</a>
<a name="ln31">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln32">#include &lt;sys/kernel.h&gt;</a>
<a name="ln33">#include &lt;sys/socket.h&gt;</a>
<a name="ln34">#include &lt;sys/systm.h&gt;</a>
<a name="ln35">#include &lt;sys/malloc.h&gt;</a>
<a name="ln36">#include &lt;sys/lock.h&gt;</a>
<a name="ln37">#include &lt;sys/mutex.h&gt;</a>
<a name="ln38">#include &lt;sys/module.h&gt;</a>
<a name="ln39">#include &lt;sys/bus.h&gt;</a>
<a name="ln40">#include &lt;sys/endian.h&gt;</a>
<a name="ln41">#include &lt;sys/firmware.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;machine/bus.h&gt;</a>
<a name="ln44">#include &lt;machine/resource.h&gt;</a>
<a name="ln45">#include &lt;sys/rman.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;net/bpf.h&gt;</a>
<a name="ln48">#include &lt;net/if.h&gt;</a>
<a name="ln49">#include &lt;net/if_var.h&gt;</a>
<a name="ln50">#include &lt;net/if_arp.h&gt;</a>
<a name="ln51">#include &lt;net/ethernet.h&gt;</a>
<a name="ln52">#include &lt;net/if_dl.h&gt;</a>
<a name="ln53">#include &lt;net/if_media.h&gt;</a>
<a name="ln54">#include &lt;net/if_types.h&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln57">#include &lt;net80211/ieee80211_radiotap.h&gt;</a>
<a name="ln58">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln59">#include &lt;net80211/ieee80211_ratectl.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#include &lt;netinet/in.h&gt;</a>
<a name="ln62">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln63">#include &lt;netinet/in_var.h&gt;</a>
<a name="ln64">#include &lt;netinet/ip.h&gt;</a>
<a name="ln65">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln66"> </a>
<a name="ln67">#include &lt;dev/ral/rt2860reg.h&gt;</a>
<a name="ln68">#include &lt;dev/ral/rt2860var.h&gt;</a>
<a name="ln69"> </a>
<a name="ln70">#define RAL_DEBUG</a>
<a name="ln71">#ifdef RAL_DEBUG</a>
<a name="ln72">#define DPRINTF(x)	do { if (sc-&gt;sc_debug &gt; 0) printf x; } while (0)</a>
<a name="ln73">#define DPRINTFN(n, x)	do { if (sc-&gt;sc_debug &gt;= (n)) printf x; } while (0)</a>
<a name="ln74">#else</a>
<a name="ln75">#define DPRINTF(x)</a>
<a name="ln76">#define DPRINTFN(n, x)</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">static struct ieee80211vap *rt2860_vap_create(struct ieee80211com *,</a>
<a name="ln80">			    const char [IFNAMSIZ], int, enum ieee80211_opmode,</a>
<a name="ln81">			    int, const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln82">			    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln83">static void	rt2860_vap_delete(struct ieee80211vap *);</a>
<a name="ln84">static void	rt2860_dma_map_addr(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln85">static int	rt2860_alloc_tx_ring(struct rt2860_softc *,</a>
<a name="ln86">		    struct rt2860_tx_ring *);</a>
<a name="ln87">static void	rt2860_reset_tx_ring(struct rt2860_softc *,</a>
<a name="ln88">		    struct rt2860_tx_ring *);</a>
<a name="ln89">static void	rt2860_free_tx_ring(struct rt2860_softc *,</a>
<a name="ln90">		    struct rt2860_tx_ring *);</a>
<a name="ln91">static int	rt2860_alloc_tx_pool(struct rt2860_softc *);</a>
<a name="ln92">static void	rt2860_free_tx_pool(struct rt2860_softc *);</a>
<a name="ln93">static int	rt2860_alloc_rx_ring(struct rt2860_softc *,</a>
<a name="ln94">		    struct rt2860_rx_ring *);</a>
<a name="ln95">static void	rt2860_reset_rx_ring(struct rt2860_softc *,</a>
<a name="ln96">		    struct rt2860_rx_ring *);</a>
<a name="ln97">static void	rt2860_free_rx_ring(struct rt2860_softc *,</a>
<a name="ln98">		    struct rt2860_rx_ring *);</a>
<a name="ln99">static void	rt2860_updatestats(struct rt2860_softc *);</a>
<a name="ln100">static void	rt2860_newassoc(struct ieee80211_node *, int);</a>
<a name="ln101">static void	rt2860_node_free(struct ieee80211_node *);</a>
<a name="ln102">#ifdef IEEE80211_HT</a>
<a name="ln103">static int	rt2860_ampdu_rx_start(struct ieee80211com *,</a>
<a name="ln104">		    struct ieee80211_node *, uint8_t);</a>
<a name="ln105">static void	rt2860_ampdu_rx_stop(struct ieee80211com *,</a>
<a name="ln106">		    struct ieee80211_node *, uint8_t);</a>
<a name="ln107">#endif</a>
<a name="ln108">static int	rt2860_newstate(struct ieee80211vap *, enum ieee80211_state,</a>
<a name="ln109">		    int);</a>
<a name="ln110">static uint16_t	rt3090_efuse_read_2(struct rt2860_softc *, uint16_t);</a>
<a name="ln111">static uint16_t	rt2860_eeprom_read_2(struct rt2860_softc *, uint16_t);</a>
<a name="ln112">static void	rt2860_intr_coherent(struct rt2860_softc *);</a>
<a name="ln113">static void	rt2860_drain_stats_fifo(struct rt2860_softc *);</a>
<a name="ln114">static void	rt2860_tx_intr(struct rt2860_softc *, int);</a>
<a name="ln115">static void	rt2860_rx_intr(struct rt2860_softc *);</a>
<a name="ln116">static void	rt2860_tbtt_intr(struct rt2860_softc *);</a>
<a name="ln117">static void	rt2860_gp_intr(struct rt2860_softc *);</a>
<a name="ln118">static int	rt2860_tx(struct rt2860_softc *, struct mbuf *,</a>
<a name="ln119">		    struct ieee80211_node *);</a>
<a name="ln120">static int	rt2860_raw_xmit(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln121">		    const struct ieee80211_bpf_params *);</a>
<a name="ln122">static int	rt2860_tx_raw(struct rt2860_softc *, struct mbuf *,</a>
<a name="ln123">		    struct ieee80211_node *,</a>
<a name="ln124">		    const struct ieee80211_bpf_params *params);</a>
<a name="ln125">static int	rt2860_transmit(struct ieee80211com *, struct mbuf *);</a>
<a name="ln126">static void	rt2860_start(struct rt2860_softc *);</a>
<a name="ln127">static void	rt2860_watchdog(void *);</a>
<a name="ln128">static void	rt2860_parent(struct ieee80211com *);</a>
<a name="ln129">static void	rt2860_mcu_bbp_write(struct rt2860_softc *, uint8_t, uint8_t);</a>
<a name="ln130">static uint8_t	rt2860_mcu_bbp_read(struct rt2860_softc *, uint8_t);</a>
<a name="ln131">static void	rt2860_rf_write(struct rt2860_softc *, uint8_t, uint32_t);</a>
<a name="ln132">static uint8_t	rt3090_rf_read(struct rt2860_softc *, uint8_t);</a>
<a name="ln133">static void	rt3090_rf_write(struct rt2860_softc *, uint8_t, uint8_t);</a>
<a name="ln134">static int	rt2860_mcu_cmd(struct rt2860_softc *, uint8_t, uint16_t, int);</a>
<a name="ln135">static void	rt2860_enable_mrr(struct rt2860_softc *);</a>
<a name="ln136">static void	rt2860_set_txpreamble(struct rt2860_softc *);</a>
<a name="ln137">static void	rt2860_set_basicrates(struct rt2860_softc *,</a>
<a name="ln138">		    const struct ieee80211_rateset *);</a>
<a name="ln139">static void	rt2860_scan_start(struct ieee80211com *);</a>
<a name="ln140">static void	rt2860_scan_end(struct ieee80211com *);</a>
<a name="ln141">static void	rt2860_getradiocaps(struct ieee80211com *, int, int *,</a>
<a name="ln142">		    struct ieee80211_channel[]);</a>
<a name="ln143">static void	rt2860_set_channel(struct ieee80211com *);</a>
<a name="ln144">static void	rt2860_select_chan_group(struct rt2860_softc *, int);</a>
<a name="ln145">static void	rt2860_set_chan(struct rt2860_softc *, u_int);</a>
<a name="ln146">static void	rt3090_set_chan(struct rt2860_softc *, u_int);</a>
<a name="ln147">static void	rt5390_set_chan(struct rt2860_softc *, u_int);</a>
<a name="ln148">static int	rt3090_rf_init(struct rt2860_softc *);</a>
<a name="ln149">static void	rt5390_rf_init(struct rt2860_softc *);</a>
<a name="ln150">static void	rt3090_rf_wakeup(struct rt2860_softc *);</a>
<a name="ln151">static void	rt5390_rf_wakeup(struct rt2860_softc *);</a>
<a name="ln152">static int	rt3090_filter_calib(struct rt2860_softc *, uint8_t, uint8_t,</a>
<a name="ln153">		    uint8_t *);</a>
<a name="ln154">static void	rt3090_rf_setup(struct rt2860_softc *);</a>
<a name="ln155">static void	rt2860_set_leds(struct rt2860_softc *, uint16_t);</a>
<a name="ln156">static void	rt2860_set_gp_timer(struct rt2860_softc *, int);</a>
<a name="ln157">static void	rt2860_set_bssid(struct rt2860_softc *, const uint8_t *);</a>
<a name="ln158">static void	rt2860_set_macaddr(struct rt2860_softc *, const uint8_t *);</a>
<a name="ln159">static void	rt2860_update_promisc(struct ieee80211com *);</a>
<a name="ln160">static void	rt2860_updateslot(struct ieee80211com *);</a>
<a name="ln161">static void	rt2860_updateprot(struct rt2860_softc *);</a>
<a name="ln162">static int	rt2860_updateedca(struct ieee80211com *);</a>
<a name="ln163">#ifdef HW_CRYPTO</a>
<a name="ln164">static int	rt2860_set_key(struct ieee80211com *, struct ieee80211_node *,</a>
<a name="ln165">		    struct ieee80211_key *);</a>
<a name="ln166">static void	rt2860_delete_key(struct ieee80211com *,</a>
<a name="ln167">		    struct ieee80211_node *, struct ieee80211_key *);</a>
<a name="ln168">#endif</a>
<a name="ln169">static int8_t	rt2860_rssi2dbm(struct rt2860_softc *, uint8_t, uint8_t);</a>
<a name="ln170">static const char *rt2860_get_rf(uint16_t);</a>
<a name="ln171">static int	rt2860_read_eeprom(struct rt2860_softc *,</a>
<a name="ln172">		    uint8_t macaddr[IEEE80211_ADDR_LEN]);</a>
<a name="ln173">static int	rt2860_bbp_init(struct rt2860_softc *);</a>
<a name="ln174">static void	rt5390_bbp_init(struct rt2860_softc *);</a>
<a name="ln175">static int	rt2860_txrx_enable(struct rt2860_softc *);</a>
<a name="ln176">static void	rt2860_init(void *);</a>
<a name="ln177">static void	rt2860_init_locked(struct rt2860_softc *);</a>
<a name="ln178">static void	rt2860_stop(void *);</a>
<a name="ln179">static void	rt2860_stop_locked(struct rt2860_softc *);</a>
<a name="ln180">static int	rt2860_load_microcode(struct rt2860_softc *);</a>
<a name="ln181">#ifdef NOT_YET</a>
<a name="ln182">static void	rt2860_calib(struct rt2860_softc *);</a>
<a name="ln183">#endif</a>
<a name="ln184">static void	rt3090_set_rx_antenna(struct rt2860_softc *, int);</a>
<a name="ln185">static void	rt2860_switch_chan(struct rt2860_softc *,</a>
<a name="ln186">		    struct ieee80211_channel *);</a>
<a name="ln187">static int	rt2860_setup_beacon(struct rt2860_softc *,</a>
<a name="ln188">		    struct ieee80211vap *);</a>
<a name="ln189">static void	rt2860_enable_tsf_sync(struct rt2860_softc *);</a>
<a name="ln190"> </a>
<a name="ln191">static const struct {</a>
<a name="ln192">	uint32_t	reg;</a>
<a name="ln193">	uint32_t	val;</a>
<a name="ln194">} rt2860_def_mac[] = {</a>
<a name="ln195">	RT2860_DEF_MAC</a>
<a name="ln196">};</a>
<a name="ln197"> </a>
<a name="ln198">static const struct {</a>
<a name="ln199">	uint8_t	reg;</a>
<a name="ln200">	uint8_t	val;</a>
<a name="ln201">} rt2860_def_bbp[] = {</a>
<a name="ln202">	RT2860_DEF_BBP</a>
<a name="ln203">}, rt5390_def_bbp[] = {</a>
<a name="ln204">	RT5390_DEF_BBP</a>
<a name="ln205">};</a>
<a name="ln206"> </a>
<a name="ln207">static const struct rfprog {</a>
<a name="ln208">	uint8_t		chan;</a>
<a name="ln209">	uint32_t	r1, r2, r3, r4;</a>
<a name="ln210">} rt2860_rf2850[] = {</a>
<a name="ln211">	RT2860_RF2850</a>
<a name="ln212">};</a>
<a name="ln213"> </a>
<a name="ln214">struct {</a>
<a name="ln215">	uint8_t	n, r, k;</a>
<a name="ln216">} rt3090_freqs[] = {</a>
<a name="ln217">	RT3070_RF3052</a>
<a name="ln218">};</a>
<a name="ln219"> </a>
<a name="ln220">static const struct {</a>
<a name="ln221">	uint8_t	reg;</a>
<a name="ln222">	uint8_t	val;</a>
<a name="ln223">} rt3090_def_rf[] = {</a>
<a name="ln224">	RT3070_DEF_RF</a>
<a name="ln225">}, rt5390_def_rf[] = {</a>
<a name="ln226">	RT5390_DEF_RF</a>
<a name="ln227">}, rt5392_def_rf[] = {</a>
<a name="ln228">	RT5392_DEF_RF</a>
<a name="ln229">};</a>
<a name="ln230"> </a>
<a name="ln231">static const uint8_t rt2860_chan_2ghz[] =</a>
<a name="ln232">	{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };</a>
<a name="ln233">static const uint8_t rt2860_chan_5ghz[] =</a>
<a name="ln234">	{ 36, 38, 40, 44, 46, 48, 52, 54, 56, 60, 62, 64, 100, 102, 104,</a>
<a name="ln235">	  108, 110, 112, 116, 118, 120, 124, 126, 128, 132, 134, 136, 140,</a>
<a name="ln236">	  149, 151, 153, 157, 159, 161, 165, 167, 169, 171, 173 };</a>
<a name="ln237"> </a>
<a name="ln238">int</a>
<a name="ln239">rt2860_attach(device_t dev, int id)</a>
<a name="ln240">{</a>
<a name="ln241">	struct rt2860_softc *sc = device_get_softc(dev);</a>
<a name="ln242">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln243">	uint32_t tmp;</a>
<a name="ln244">	int error, ntries, qid;</a>
<a name="ln245"> </a>
<a name="ln246">	sc-&gt;sc_dev = dev;</a>
<a name="ln247">	sc-&gt;sc_debug = 0;</a>
<a name="ln248"> </a>
<a name="ln249">	mtx_init(&amp;sc-&gt;sc_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln250">	    MTX_DEF | MTX_RECURSE);</a>
<a name="ln251"> </a>
<a name="ln252">	callout_init_mtx(&amp;sc-&gt;watchdog_ch, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln253">	mbufq_init(&amp;sc-&gt;sc_snd, ifqmaxlen);</a>
<a name="ln254"> </a>
<a name="ln255">	/* wait for NIC to initialize */</a>
<a name="ln256">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln257">		tmp = RAL_READ(sc, RT2860_ASIC_VER_ID);</a>
<a name="ln258">		if (tmp != 0 &amp;&amp; tmp != 0xffffffff)</a>
<a name="ln259">			break;</a>
<a name="ln260">		DELAY(10);</a>
<a name="ln261">	}</a>
<a name="ln262">	if (ntries == 100) {</a>
<a name="ln263">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln264">		    &quot;timeout waiting for NIC to initialize\n&quot;);</a>
<a name="ln265">		error = EIO;</a>
<a name="ln266">		goto fail1;</a>
<a name="ln267">	}</a>
<a name="ln268">	sc-&gt;mac_ver = tmp &gt;&gt; 16;</a>
<a name="ln269">	sc-&gt;mac_rev = tmp &amp; 0xffff;</a>
<a name="ln270"> </a>
<a name="ln271">	if (sc-&gt;mac_ver != 0x2860 &amp;&amp;</a>
<a name="ln272">	    (id == 0x0681 || id == 0x0781 || id == 0x1059))</a>
<a name="ln273">		sc-&gt;sc_flags |= RT2860_ADVANCED_PS;</a>
<a name="ln274"> </a>
<a name="ln275">	/* retrieve RF rev. no and various other things from EEPROM */</a>
<a name="ln276">	rt2860_read_eeprom(sc, ic-&gt;ic_macaddr);</a>
<a name="ln277">	device_printf(sc-&gt;sc_dev, &quot;MAC/BBP RT%X (rev 0x%04X), &quot;</a>
<a name="ln278">	    &quot;RF %s (MIMO %dT%dR), address %6D\n&quot;,</a>
<a name="ln279">	    sc-&gt;mac_ver, sc-&gt;mac_rev, rt2860_get_rf(sc-&gt;rf_rev),</a>
<a name="ln280">	    sc-&gt;ntxchains, sc-&gt;nrxchains, ic-&gt;ic_macaddr, &quot;:&quot;);</a>
<a name="ln281"> </a>
<a name="ln282">	/*</a>
<a name="ln283">	 * Allocate Tx (4 EDCAs + HCCA + Mgt) and Rx rings.</a>
<a name="ln284">	 */</a>
<a name="ln285">	for (qid = 0; qid &lt; 6; qid++) {</a>
<a name="ln286">		if ((error = rt2860_alloc_tx_ring(sc, &amp;sc-&gt;txq[qid])) != 0) {</a>
<a name="ln287">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln288">			    &quot;could not allocate Tx ring %d\n&quot;, qid);</a>
<a name="ln289">			goto fail2;</a>
<a name="ln290">		}</a>
<a name="ln291">	}</a>
<a name="ln292"> </a>
<a name="ln293">	if ((error = rt2860_alloc_rx_ring(sc, &amp;sc-&gt;rxq)) != 0) {</a>
<a name="ln294">		device_printf(sc-&gt;sc_dev, &quot;could not allocate Rx ring\n&quot;);</a>
<a name="ln295">		goto fail2;</a>
<a name="ln296">	}</a>
<a name="ln297"> </a>
<a name="ln298">	if ((error = rt2860_alloc_tx_pool(sc)) != 0) {</a>
<a name="ln299">		device_printf(sc-&gt;sc_dev, &quot;could not allocate Tx pool\n&quot;);</a>
<a name="ln300">		goto fail3;</a>
<a name="ln301">	}</a>
<a name="ln302"> </a>
<a name="ln303">	/* mgmt ring is broken on RT2860C, use EDCA AC VO ring instead */</a>
<a name="ln304">	sc-&gt;mgtqid = (sc-&gt;mac_ver == 0x2860 &amp;&amp; sc-&gt;mac_rev == 0x0100) ?</a>
<a name="ln305">	    WME_AC_VO : 5;</a>
<a name="ln306"> </a>
<a name="ln307">	ic-&gt;ic_softc = sc;</a>
<a name="ln308">	ic-&gt;ic_name = device_get_nameunit(dev);</a>
<a name="ln309">	ic-&gt;ic_opmode = IEEE80211_M_STA;</a>
<a name="ln310">	ic-&gt;ic_phytype = IEEE80211_T_OFDM; /* not only, but not used */</a>
<a name="ln311"> </a>
<a name="ln312">	/* set device capabilities */</a>
<a name="ln313">	ic-&gt;ic_caps =</a>
<a name="ln314">		  IEEE80211_C_STA		/* station mode */</a>
<a name="ln315">		| IEEE80211_C_IBSS		/* ibss, nee adhoc, mode */</a>
<a name="ln316">		| IEEE80211_C_HOSTAP		/* hostap mode */</a>
<a name="ln317">		| IEEE80211_C_MONITOR		/* monitor mode */</a>
<a name="ln318">		| IEEE80211_C_AHDEMO		/* adhoc demo mode */</a>
<a name="ln319">		| IEEE80211_C_WDS		/* 4-address traffic works */</a>
<a name="ln320">		| IEEE80211_C_MBSS		/* mesh point link mode */</a>
<a name="ln321">		| IEEE80211_C_SHPREAMBLE	/* short preamble supported */</a>
<a name="ln322">		| IEEE80211_C_SHSLOT		/* short slot time supported */</a>
<a name="ln323">		| IEEE80211_C_WPA		/* capable of WPA1+WPA2 */</a>
<a name="ln324">#if 0</a>
<a name="ln325">		| IEEE80211_C_BGSCAN		/* capable of bg scanning */</a>
<a name="ln326">#endif</a>
<a name="ln327">		| IEEE80211_C_WME		/* 802.11e */</a>
<a name="ln328">		;</a>
<a name="ln329"> </a>
<a name="ln330">	rt2860_getradiocaps(ic, IEEE80211_CHAN_MAX, &amp;ic-&gt;ic_nchans,</a>
<a name="ln331">	    ic-&gt;ic_channels);</a>
<a name="ln332"> </a>
<a name="ln333">	ieee80211_ifattach(ic);</a>
<a name="ln334"> </a>
<a name="ln335">	ic-&gt;ic_wme.wme_update = rt2860_updateedca;</a>
<a name="ln336">	ic-&gt;ic_scan_start = rt2860_scan_start;</a>
<a name="ln337">	ic-&gt;ic_scan_end = rt2860_scan_end;</a>
<a name="ln338">	ic-&gt;ic_getradiocaps = rt2860_getradiocaps;</a>
<a name="ln339">	ic-&gt;ic_set_channel = rt2860_set_channel;</a>
<a name="ln340">	ic-&gt;ic_updateslot = rt2860_updateslot;</a>
<a name="ln341">	ic-&gt;ic_update_promisc = rt2860_update_promisc;</a>
<a name="ln342">	ic-&gt;ic_raw_xmit = rt2860_raw_xmit;</a>
<a name="ln343">	sc-&gt;sc_node_free = ic-&gt;ic_node_free;</a>
<a name="ln344">	ic-&gt;ic_node_free = rt2860_node_free;</a>
<a name="ln345">	ic-&gt;ic_newassoc = rt2860_newassoc;</a>
<a name="ln346">	ic-&gt;ic_transmit = rt2860_transmit;</a>
<a name="ln347">	ic-&gt;ic_parent = rt2860_parent;</a>
<a name="ln348">	ic-&gt;ic_vap_create = rt2860_vap_create;</a>
<a name="ln349">	ic-&gt;ic_vap_delete = rt2860_vap_delete;</a>
<a name="ln350"> </a>
<a name="ln351">	ieee80211_radiotap_attach(ic,</a>
<a name="ln352">	    &amp;sc-&gt;sc_txtap.wt_ihdr, sizeof(sc-&gt;sc_txtap),</a>
<a name="ln353">		RT2860_TX_RADIOTAP_PRESENT,</a>
<a name="ln354">	    &amp;sc-&gt;sc_rxtap.wr_ihdr, sizeof(sc-&gt;sc_rxtap),</a>
<a name="ln355">		RT2860_RX_RADIOTAP_PRESENT);</a>
<a name="ln356"> </a>
<a name="ln357">#ifdef RAL_DEBUG</a>
<a name="ln358">	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),</a>
<a name="ln359">	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO,</a>
<a name="ln360">	    &quot;debug&quot;, CTLFLAG_RW, &amp;sc-&gt;sc_debug, 0, &quot;debug msgs&quot;);</a>
<a name="ln361">#endif</a>
<a name="ln362">	if (bootverbose)</a>
<a name="ln363">		ieee80211_announce(ic);</a>
<a name="ln364"> </a>
<a name="ln365">	return 0;</a>
<a name="ln366"> </a>
<a name="ln367">fail3:	rt2860_free_rx_ring(sc, &amp;sc-&gt;rxq);</a>
<a name="ln368">fail2:	while (--qid &gt;= 0)</a>
<a name="ln369">		rt2860_free_tx_ring(sc, &amp;sc-&gt;txq[qid]);</a>
<a name="ln370">fail1:	mtx_destroy(&amp;sc-&gt;sc_mtx);</a>
<a name="ln371">	return error;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">int</a>
<a name="ln375">rt2860_detach(void *xsc)</a>
<a name="ln376">{</a>
<a name="ln377">	struct rt2860_softc *sc = xsc;</a>
<a name="ln378">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln379">	int qid;</a>
<a name="ln380"> </a>
<a name="ln381">	RAL_LOCK(sc);</a>
<a name="ln382">	rt2860_stop_locked(sc);</a>
<a name="ln383">	RAL_UNLOCK(sc);</a>
<a name="ln384"> </a>
<a name="ln385">	ieee80211_ifdetach(ic);</a>
<a name="ln386">	mbufq_drain(&amp;sc-&gt;sc_snd);</a>
<a name="ln387">	for (qid = 0; qid &lt; 6; qid++)</a>
<a name="ln388">		rt2860_free_tx_ring(sc, &amp;sc-&gt;txq[qid]);</a>
<a name="ln389">	rt2860_free_rx_ring(sc, &amp;sc-&gt;rxq);</a>
<a name="ln390">	rt2860_free_tx_pool(sc);</a>
<a name="ln391"> </a>
<a name="ln392">	mtx_destroy(&amp;sc-&gt;sc_mtx);</a>
<a name="ln393"> </a>
<a name="ln394">	return 0;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">void</a>
<a name="ln398">rt2860_shutdown(void *xsc)</a>
<a name="ln399">{</a>
<a name="ln400">	struct rt2860_softc *sc = xsc;</a>
<a name="ln401"> </a>
<a name="ln402">	rt2860_stop(sc);</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">void</a>
<a name="ln406">rt2860_suspend(void *xsc)</a>
<a name="ln407">{</a>
<a name="ln408">	struct rt2860_softc *sc = xsc;</a>
<a name="ln409"> </a>
<a name="ln410">	rt2860_stop(sc);</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">void</a>
<a name="ln414">rt2860_resume(void *xsc)</a>
<a name="ln415">{</a>
<a name="ln416">	struct rt2860_softc *sc = xsc;</a>
<a name="ln417"> </a>
<a name="ln418">	if (sc-&gt;sc_ic.ic_nrunning &gt; 0)</a>
<a name="ln419">		rt2860_init(sc);</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">static struct ieee80211vap *</a>
<a name="ln423">rt2860_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln424">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln425">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln426">    const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln427">{</a>
<a name="ln428">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln429">	struct rt2860_vap *rvp;</a>
<a name="ln430">	struct ieee80211vap *vap;</a>
<a name="ln431"> </a>
<a name="ln432">	switch (opmode) {</a>
<a name="ln433">	case IEEE80211_M_STA:</a>
<a name="ln434">	case IEEE80211_M_IBSS:</a>
<a name="ln435">	case IEEE80211_M_AHDEMO:</a>
<a name="ln436">	case IEEE80211_M_MONITOR:</a>
<a name="ln437">	case IEEE80211_M_HOSTAP:</a>
<a name="ln438">	case IEEE80211_M_MBSS:</a>
<a name="ln439">		/* XXXRP: TBD */</a>
<a name="ln440">		if (!TAILQ_EMPTY(&amp;ic-&gt;ic_vaps)) {</a>
<a name="ln441">			device_printf(sc-&gt;sc_dev, &quot;only 1 vap supported\n&quot;);</a>
<a name="ln442">			return NULL;</a>
<a name="ln443">		}</a>
<a name="ln444">		if (opmode == IEEE80211_M_STA)</a>
<a name="ln445">			flags |= IEEE80211_CLONE_NOBEACONS;</a>
<a name="ln446">		break;</a>
<a name="ln447">	case IEEE80211_M_WDS:</a>
<a name="ln448">		if (TAILQ_EMPTY(&amp;ic-&gt;ic_vaps) ||</a>
<a name="ln449">		    ic-&gt;ic_opmode != IEEE80211_M_HOSTAP) {</a>
<a name="ln450">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln451">			    &quot;wds only supported in ap mode\n&quot;);</a>
<a name="ln452">			return NULL;</a>
<a name="ln453">		}</a>
<a name="ln454">		/*</a>
<a name="ln455">		 * Silently remove any request for a unique</a>
<a name="ln456">		 * bssid; WDS vap's always share the local</a>
<a name="ln457">		 * mac address.</a>
<a name="ln458">		 */</a>
<a name="ln459">		flags &amp;= ~IEEE80211_CLONE_BSSID;</a>
<a name="ln460">		break;</a>
<a name="ln461">	default:</a>
<a name="ln462">		device_printf(sc-&gt;sc_dev, &quot;unknown opmode %d\n&quot;, opmode);</a>
<a name="ln463">		return NULL;</a>
<a name="ln464">	}</a>
<a name="ln465">	rvp = malloc(sizeof(struct rt2860_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln466">	vap = &amp;rvp-&gt;ral_vap;</a>
<a name="ln467">	ieee80211_vap_setup(ic, vap, name, unit, opmode, flags, bssid);</a>
<a name="ln468"> </a>
<a name="ln469">	/* override state transition machine */</a>
<a name="ln470">	rvp-&gt;ral_newstate = vap-&gt;iv_newstate;</a>
<a name="ln471">	vap-&gt;iv_newstate = rt2860_newstate;</a>
<a name="ln472">#if 0</a>
<a name="ln473">	vap-&gt;iv_update_beacon = rt2860_beacon_update;</a>
<a name="ln474">#endif</a>
<a name="ln475"> </a>
<a name="ln476">	/* HW supports up to 255 STAs (0-254) in HostAP and IBSS modes */</a>
<a name="ln477">	vap-&gt;iv_max_aid = min(IEEE80211_AID_MAX, RT2860_WCID_MAX);</a>
<a name="ln478"> </a>
<a name="ln479">	ieee80211_ratectl_init(vap);</a>
<a name="ln480">	/* complete setup */</a>
<a name="ln481">	ieee80211_vap_attach(vap, ieee80211_media_change,</a>
<a name="ln482">	    ieee80211_media_status, mac);</a>
<a name="ln483">	if (TAILQ_FIRST(&amp;ic-&gt;ic_vaps) == vap)</a>
<a name="ln484">		ic-&gt;ic_opmode = opmode;</a>
<a name="ln485">	return vap;</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">static void</a>
<a name="ln489">rt2860_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln490">{</a>
<a name="ln491">	struct rt2860_vap *rvp = RT2860_VAP(vap);</a>
<a name="ln492"> </a>
<a name="ln493">	ieee80211_ratectl_deinit(vap);</a>
<a name="ln494">	ieee80211_vap_detach(vap);</a>
<a name="ln495">	free(rvp, M_80211_VAP);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">static void</a>
<a name="ln499">rt2860_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)</a>
<a name="ln500">{</a>
<a name="ln501">	if (error != 0)</a>
<a name="ln502">		return;</a>
<a name="ln503"> </a>
<a name="ln504">	KASSERT(nseg == 1, (&quot;too many DMA segments, %d should be 1&quot;, nseg));</a>
<a name="ln505"> </a>
<a name="ln506">	*(bus_addr_t *)arg = segs[0].ds_addr;</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">static int</a>
<a name="ln511">rt2860_alloc_tx_ring(struct rt2860_softc *sc, struct rt2860_tx_ring *ring)</a>
<a name="ln512">{</a>
<a name="ln513">	int size, error;</a>
<a name="ln514"> </a>
<a name="ln515">	size = RT2860_TX_RING_COUNT * sizeof (struct rt2860_txd);</a>
<a name="ln516"> </a>
<a name="ln517">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev), 16, 0,</a>
<a name="ln518">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln519">	    size, 1, size, 0, NULL, NULL, &amp;ring-&gt;desc_dmat);</a>
<a name="ln520">	if (error != 0) {</a>
<a name="ln521">		device_printf(sc-&gt;sc_dev, &quot;could not create desc DMA tag\n&quot;);</a>
<a name="ln522">		goto fail;</a>
<a name="ln523">	}</a>
<a name="ln524"> </a>
<a name="ln525">	error = bus_dmamem_alloc(ring-&gt;desc_dmat, (void **)&amp;ring-&gt;txd,</a>
<a name="ln526">	    BUS_DMA_NOWAIT | BUS_DMA_ZERO, &amp;ring-&gt;desc_map);</a>
<a name="ln527">	if (error != 0) {</a>
<a name="ln528">		device_printf(sc-&gt;sc_dev, &quot;could not allocate DMA memory\n&quot;);</a>
<a name="ln529">		goto fail;</a>
<a name="ln530">	}</a>
<a name="ln531"> </a>
<a name="ln532">	error = bus_dmamap_load(ring-&gt;desc_dmat, ring-&gt;desc_map, ring-&gt;txd,</a>
<a name="ln533">	    size, rt2860_dma_map_addr, &amp;ring-&gt;paddr, 0);</a>
<a name="ln534">	if (error != 0) {</a>
<a name="ln535">		device_printf(sc-&gt;sc_dev, &quot;could not load desc DMA map\n&quot;);</a>
<a name="ln536">		goto fail;</a>
<a name="ln537">	}</a>
<a name="ln538"> </a>
<a name="ln539">	bus_dmamap_sync(ring-&gt;desc_dmat, ring-&gt;desc_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln540"> </a>
<a name="ln541">	return 0;</a>
<a name="ln542"> </a>
<a name="ln543">fail:	rt2860_free_tx_ring(sc, ring);</a>
<a name="ln544">	return error;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">void</a>
<a name="ln548">rt2860_reset_tx_ring(struct rt2860_softc *sc, struct rt2860_tx_ring *ring)</a>
<a name="ln549">{</a>
<a name="ln550">	struct rt2860_tx_data *data;</a>
<a name="ln551">	int i;</a>
<a name="ln552"> </a>
<a name="ln553">	for (i = 0; i &lt; RT2860_TX_RING_COUNT; i++) {</a>
<a name="ln554">		if ((data = ring-&gt;data[i]) == NULL)</a>
<a name="ln555">			continue;	/* nothing mapped in this slot */</a>
<a name="ln556"> </a>
<a name="ln557">		if (data-&gt;m != NULL) {</a>
<a name="ln558">			bus_dmamap_sync(sc-&gt;txwi_dmat, data-&gt;map,</a>
<a name="ln559">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln560">			bus_dmamap_unload(sc-&gt;txwi_dmat, data-&gt;map);</a>
<a name="ln561">			m_freem(data-&gt;m);</a>
<a name="ln562">			data-&gt;m = NULL;</a>
<a name="ln563">		}</a>
<a name="ln564">		if (data-&gt;ni != NULL) {</a>
<a name="ln565">			ieee80211_free_node(data-&gt;ni);</a>
<a name="ln566">			data-&gt;ni = NULL;</a>
<a name="ln567">		}</a>
<a name="ln568"> </a>
<a name="ln569">		SLIST_INSERT_HEAD(&amp;sc-&gt;data_pool, data, next);</a>
<a name="ln570">		ring-&gt;data[i] = NULL;</a>
<a name="ln571">	}</a>
<a name="ln572"> </a>
<a name="ln573">	ring-&gt;queued = 0;</a>
<a name="ln574">	ring-&gt;cur = ring-&gt;next = 0;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">void</a>
<a name="ln578">rt2860_free_tx_ring(struct rt2860_softc *sc, struct rt2860_tx_ring *ring)</a>
<a name="ln579">{</a>
<a name="ln580">	struct rt2860_tx_data *data;</a>
<a name="ln581">	int i;</a>
<a name="ln582"> </a>
<a name="ln583">	if (ring-&gt;txd != NULL) {</a>
<a name="ln584">		bus_dmamap_sync(ring-&gt;desc_dmat, ring-&gt;desc_map,</a>
<a name="ln585">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln586">		bus_dmamap_unload(ring-&gt;desc_dmat, ring-&gt;desc_map);</a>
<a name="ln587">		bus_dmamem_free(ring-&gt;desc_dmat, ring-&gt;txd, ring-&gt;desc_map);</a>
<a name="ln588">	}</a>
<a name="ln589">	if (ring-&gt;desc_dmat != NULL)</a>
<a name="ln590">		bus_dma_tag_destroy(ring-&gt;desc_dmat);</a>
<a name="ln591"> </a>
<a name="ln592">	for (i = 0; i &lt; RT2860_TX_RING_COUNT; i++) {</a>
<a name="ln593">		if ((data = ring-&gt;data[i]) == NULL)</a>
<a name="ln594">			continue;	/* nothing mapped in this slot */</a>
<a name="ln595"> </a>
<a name="ln596">		if (data-&gt;m != NULL) {</a>
<a name="ln597">			bus_dmamap_sync(sc-&gt;txwi_dmat, data-&gt;map,</a>
<a name="ln598">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln599">			bus_dmamap_unload(sc-&gt;txwi_dmat, data-&gt;map);</a>
<a name="ln600">			m_freem(data-&gt;m);</a>
<a name="ln601">		}</a>
<a name="ln602">		if (data-&gt;ni != NULL)</a>
<a name="ln603">			ieee80211_free_node(data-&gt;ni);</a>
<a name="ln604"> </a>
<a name="ln605">		SLIST_INSERT_HEAD(&amp;sc-&gt;data_pool, data, next);</a>
<a name="ln606">	}</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">/*</a>
<a name="ln610"> * Allocate a pool of TX Wireless Information blocks.</a>
<a name="ln611"> */</a>
<a name="ln612">int</a>
<a name="ln613">rt2860_alloc_tx_pool(struct rt2860_softc *sc)</a>
<a name="ln614">{</a>
<a name="ln615">	caddr_t vaddr;</a>
<a name="ln616">	bus_addr_t paddr;</a>
<a name="ln617">	int i, size, error;</a>
<a name="ln618"> </a>
<a name="ln619">	size = RT2860_TX_POOL_COUNT * RT2860_TXWI_DMASZ;</a>
<a name="ln620"> </a>
<a name="ln621">	/* init data_pool early in case of failure.. */</a>
<a name="ln622">	SLIST_INIT(&amp;sc-&gt;data_pool);</a>
<a name="ln623"> </a>
<a name="ln624">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev), 1, 0,</a>
<a name="ln625">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln626">	    size, 1, size, 0, NULL, NULL, &amp;sc-&gt;txwi_dmat);</a>
<a name="ln627">	if (error != 0) {</a>
<a name="ln628">		device_printf(sc-&gt;sc_dev, &quot;could not create txwi DMA tag\n&quot;);</a>
<a name="ln629">		goto fail;</a>
<a name="ln630">	}</a>
<a name="ln631"> </a>
<a name="ln632">	error = bus_dmamem_alloc(sc-&gt;txwi_dmat, (void **)&amp;sc-&gt;txwi_vaddr,</a>
<a name="ln633">	    BUS_DMA_NOWAIT | BUS_DMA_ZERO, &amp;sc-&gt;txwi_map);</a>
<a name="ln634">	if (error != 0) {</a>
<a name="ln635">		device_printf(sc-&gt;sc_dev, &quot;could not allocate DMA memory\n&quot;);</a>
<a name="ln636">		goto fail;</a>
<a name="ln637">	}</a>
<a name="ln638"> </a>
<a name="ln639">	error = bus_dmamap_load(sc-&gt;txwi_dmat, sc-&gt;txwi_map,</a>
<a name="ln640">	    sc-&gt;txwi_vaddr, size, rt2860_dma_map_addr, &amp;paddr, 0);</a>
<a name="ln641">	if (error != 0) {</a>
<a name="ln642">		device_printf(sc-&gt;sc_dev, &quot;could not load txwi DMA map\n&quot;);</a>
<a name="ln643">		goto fail;</a>
<a name="ln644">	}</a>
<a name="ln645"> </a>
<a name="ln646">	bus_dmamap_sync(sc-&gt;txwi_dmat, sc-&gt;txwi_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln647"> </a>
<a name="ln648">	vaddr = sc-&gt;txwi_vaddr;</a>
<a name="ln649">	for (i = 0; i &lt; RT2860_TX_POOL_COUNT; i++) {</a>
<a name="ln650">		struct rt2860_tx_data *data = &amp;sc-&gt;data[i];</a>
<a name="ln651"> </a>
<a name="ln652">		error = bus_dmamap_create(sc-&gt;txwi_dmat, 0, &amp;data-&gt;map);</a>
<a name="ln653">		if (error != 0) {</a>
<a name="ln654">			device_printf(sc-&gt;sc_dev, &quot;could not create DMA map\n&quot;);</a>
<a name="ln655">			goto fail;</a>
<a name="ln656">		}</a>
<a name="ln657">		data-&gt;txwi = (struct rt2860_txwi *)vaddr;</a>
<a name="ln658">		data-&gt;paddr = paddr;</a>
<a name="ln659">		vaddr += RT2860_TXWI_DMASZ;</a>
<a name="ln660">		paddr += RT2860_TXWI_DMASZ;</a>
<a name="ln661"> </a>
<a name="ln662">		SLIST_INSERT_HEAD(&amp;sc-&gt;data_pool, data, next);</a>
<a name="ln663">	}</a>
<a name="ln664"> </a>
<a name="ln665">	return 0;</a>
<a name="ln666"> </a>
<a name="ln667">fail:	rt2860_free_tx_pool(sc);</a>
<a name="ln668">	return error;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">void</a>
<a name="ln672">rt2860_free_tx_pool(struct rt2860_softc *sc)</a>
<a name="ln673">{</a>
<a name="ln674">	if (sc-&gt;txwi_vaddr != NULL) {</a>
<a name="ln675">		bus_dmamap_sync(sc-&gt;txwi_dmat, sc-&gt;txwi_map,</a>
<a name="ln676">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln677">		bus_dmamap_unload(sc-&gt;txwi_dmat, sc-&gt;txwi_map);</a>
<a name="ln678">		bus_dmamem_free(sc-&gt;txwi_dmat, sc-&gt;txwi_vaddr, sc-&gt;txwi_map);</a>
<a name="ln679">	}</a>
<a name="ln680">	if (sc-&gt;txwi_dmat != NULL)</a>
<a name="ln681">		bus_dma_tag_destroy(sc-&gt;txwi_dmat);</a>
<a name="ln682"> </a>
<a name="ln683">	while (!SLIST_EMPTY(&amp;sc-&gt;data_pool)) {</a>
<a name="ln684">		struct rt2860_tx_data *data;</a>
<a name="ln685">		data = SLIST_FIRST(&amp;sc-&gt;data_pool);</a>
<a name="ln686">		bus_dmamap_destroy(sc-&gt;txwi_dmat, data-&gt;map);</a>
<a name="ln687">		SLIST_REMOVE_HEAD(&amp;sc-&gt;data_pool, next);</a>
<a name="ln688">	}</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">int</a>
<a name="ln692">rt2860_alloc_rx_ring(struct rt2860_softc *sc, struct rt2860_rx_ring *ring)</a>
<a name="ln693">{</a>
<a name="ln694">	bus_addr_t physaddr;</a>
<a name="ln695">	int i, size, error;</a>
<a name="ln696"> </a>
<a name="ln697">	size = RT2860_RX_RING_COUNT * sizeof (struct rt2860_rxd);</a>
<a name="ln698"> </a>
<a name="ln699">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev), 16, 0,</a>
<a name="ln700">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln701">	    size, 1, size, 0, NULL, NULL, &amp;ring-&gt;desc_dmat);</a>
<a name="ln702">	if (error != 0) {</a>
<a name="ln703">		device_printf(sc-&gt;sc_dev, &quot;could not create desc DMA tag\n&quot;);</a>
<a name="ln704">		goto fail;</a>
<a name="ln705">	}</a>
<a name="ln706"> </a>
<a name="ln707">	error = bus_dmamem_alloc(ring-&gt;desc_dmat, (void **)&amp;ring-&gt;rxd,</a>
<a name="ln708">	    BUS_DMA_NOWAIT | BUS_DMA_ZERO, &amp;ring-&gt;desc_map);</a>
<a name="ln709">	if (error != 0) {</a>
<a name="ln710">		device_printf(sc-&gt;sc_dev, &quot;could not allocate DMA memory\n&quot;);</a>
<a name="ln711">		goto fail;</a>
<a name="ln712">	}</a>
<a name="ln713"> </a>
<a name="ln714">	error = bus_dmamap_load(ring-&gt;desc_dmat, ring-&gt;desc_map, ring-&gt;rxd,</a>
<a name="ln715">	    size, rt2860_dma_map_addr, &amp;ring-&gt;paddr, 0);</a>
<a name="ln716">	if (error != 0) {</a>
<a name="ln717">		device_printf(sc-&gt;sc_dev, &quot;could not load desc DMA map\n&quot;);</a>
<a name="ln718">		goto fail;</a>
<a name="ln719">	}</a>
<a name="ln720"> </a>
<a name="ln721">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev), 1, 0,</a>
<a name="ln722">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL, MCLBYTES,</a>
<a name="ln723">	    1, MCLBYTES, 0, NULL, NULL, &amp;ring-&gt;data_dmat);</a>
<a name="ln724">	if (error != 0) {</a>
<a name="ln725">		device_printf(sc-&gt;sc_dev, &quot;could not create data DMA tag\n&quot;);</a>
<a name="ln726">		goto fail;</a>
<a name="ln727">	}</a>
<a name="ln728"> </a>
<a name="ln729">	for (i = 0; i &lt; RT2860_RX_RING_COUNT; i++) {</a>
<a name="ln730">		struct rt2860_rx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln731">		struct rt2860_rxd *rxd = &amp;ring-&gt;rxd[i];</a>
<a name="ln732"> </a>
<a name="ln733">		error = bus_dmamap_create(ring-&gt;data_dmat, 0, &amp;data-&gt;map);</a>
<a name="ln734">		if (error != 0) {</a>
<a name="ln735">			device_printf(sc-&gt;sc_dev, &quot;could not create DMA map\n&quot;);</a>
<a name="ln736">			goto fail;</a>
<a name="ln737">		}</a>
<a name="ln738"> </a>
<a name="ln739">		data-&gt;m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln740">		if (data-&gt;m == NULL) {</a>
<a name="ln741">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln742">			    &quot;could not allocate rx mbuf\n&quot;);</a>
<a name="ln743">			error = ENOMEM;</a>
<a name="ln744">			goto fail;</a>
<a name="ln745">		}</a>
<a name="ln746"> </a>
<a name="ln747">		error = bus_dmamap_load(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln748">		    mtod(data-&gt;m, void *), MCLBYTES, rt2860_dma_map_addr,</a>
<a name="ln749">		    &amp;physaddr, 0);</a>
<a name="ln750">		if (error != 0) {</a>
<a name="ln751">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln752">			    &quot;could not load rx buf DMA map&quot;);</a>
<a name="ln753">			goto fail;</a>
<a name="ln754">		}</a>
<a name="ln755"> </a>
<a name="ln756">		rxd-&gt;sdp0 = htole32(physaddr);</a>
<a name="ln757">		rxd-&gt;sdl0 = htole16(MCLBYTES);</a>
<a name="ln758">	}</a>
<a name="ln759"> </a>
<a name="ln760">	bus_dmamap_sync(ring-&gt;desc_dmat, ring-&gt;desc_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln761"> </a>
<a name="ln762">	return 0;</a>
<a name="ln763"> </a>
<a name="ln764">fail:	rt2860_free_rx_ring(sc, ring);</a>
<a name="ln765">	return error;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">void</a>
<a name="ln769">rt2860_reset_rx_ring(struct rt2860_softc *sc, struct rt2860_rx_ring *ring)</a>
<a name="ln770">{</a>
<a name="ln771">	int i;</a>
<a name="ln772"> </a>
<a name="ln773">	for (i = 0; i &lt; RT2860_RX_RING_COUNT; i++)</a>
<a name="ln774">		ring-&gt;rxd[i].sdl0 &amp;= ~htole16(RT2860_RX_DDONE);</a>
<a name="ln775"> </a>
<a name="ln776">	bus_dmamap_sync(ring-&gt;desc_dmat, ring-&gt;desc_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln777"> </a>
<a name="ln778">	ring-&gt;cur = 0;</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">void</a>
<a name="ln782">rt2860_free_rx_ring(struct rt2860_softc *sc, struct rt2860_rx_ring *ring)</a>
<a name="ln783">{</a>
<a name="ln784">	int i;</a>
<a name="ln785"> </a>
<a name="ln786">	if (ring-&gt;rxd != NULL) {</a>
<a name="ln787">		bus_dmamap_sync(ring-&gt;desc_dmat, ring-&gt;desc_map,</a>
<a name="ln788">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln789">		bus_dmamap_unload(ring-&gt;desc_dmat, ring-&gt;desc_map);</a>
<a name="ln790">		bus_dmamem_free(ring-&gt;desc_dmat, ring-&gt;rxd, ring-&gt;desc_map);</a>
<a name="ln791">	}</a>
<a name="ln792">	if (ring-&gt;desc_dmat != NULL)</a>
<a name="ln793">		bus_dma_tag_destroy(ring-&gt;desc_dmat);</a>
<a name="ln794"> </a>
<a name="ln795">	for (i = 0; i &lt; RT2860_RX_RING_COUNT; i++) {</a>
<a name="ln796">		struct rt2860_rx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln797"> </a>
<a name="ln798">		if (data-&gt;m != NULL) {</a>
<a name="ln799">			bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln800">			    BUS_DMASYNC_POSTREAD);</a>
<a name="ln801">			bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln802">			m_freem(data-&gt;m);</a>
<a name="ln803">		}</a>
<a name="ln804">		if (data-&gt;map != NULL)</a>
<a name="ln805">			bus_dmamap_destroy(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln806">	}</a>
<a name="ln807">	if (ring-&gt;data_dmat != NULL)</a>
<a name="ln808">		bus_dma_tag_destroy(ring-&gt;data_dmat);</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">static void</a>
<a name="ln812">rt2860_updatestats(struct rt2860_softc *sc)</a>
<a name="ln813">{</a>
<a name="ln814">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln815"> </a>
<a name="ln816">	/*</a>
<a name="ln817">	 * In IBSS or HostAP modes (when the hardware sends beacons), the</a>
<a name="ln818">	 * MAC can run into a livelock and start sending CTS-to-self frames</a>
<a name="ln819">	 * like crazy if protection is enabled.  Fortunately, we can detect</a>
<a name="ln820">	 * when such a situation occurs and reset the MAC.</a>
<a name="ln821">	 */</a>
<a name="ln822">	if (ic-&gt;ic_curmode != IEEE80211_M_STA) {</a>
<a name="ln823">		/* check if we're in a livelock situation.. */</a>
<a name="ln824">		uint32_t tmp = RAL_READ(sc, RT2860_DEBUG);</a>
<a name="ln825">		if ((tmp &amp; (1 &lt;&lt; 29)) &amp;&amp; (tmp &amp; (1 &lt;&lt; 7 | 1 &lt;&lt; 5))) {</a>
<a name="ln826">			/* ..and reset MAC/BBP for a while.. */</a>
<a name="ln827">			DPRINTF((&quot;CTS-to-self livelock detected\n&quot;));</a>
<a name="ln828">			RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_MAC_SRST);</a>
<a name="ln829">			RAL_BARRIER_WRITE(sc);</a>
<a name="ln830">			DELAY(1);</a>
<a name="ln831">			RAL_WRITE(sc, RT2860_MAC_SYS_CTRL,</a>
<a name="ln832">			    RT2860_MAC_RX_EN | RT2860_MAC_TX_EN);</a>
<a name="ln833">		}</a>
<a name="ln834">	}</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">static void</a>
<a name="ln838">rt2860_newassoc(struct ieee80211_node *ni, int isnew)</a>
<a name="ln839">{</a>
<a name="ln840">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln841">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln842">	uint8_t wcid;</a>
<a name="ln843"> </a>
<a name="ln844">	wcid = IEEE80211_AID(ni-&gt;ni_associd);</a>
<a name="ln845">	if (isnew &amp;&amp; ni-&gt;ni_associd != 0) {</a>
<a name="ln846">		sc-&gt;wcid2ni[wcid] = ni;</a>
<a name="ln847"> </a>
<a name="ln848">		/* init WCID table entry */</a>
<a name="ln849">		RAL_WRITE_REGION_1(sc, RT2860_WCID_ENTRY(wcid),</a>
<a name="ln850">		    ni-&gt;ni_macaddr, IEEE80211_ADDR_LEN);</a>
<a name="ln851">	}</a>
<a name="ln852">	DPRINTF((&quot;new assoc isnew=%d addr=%s WCID=%d\n&quot;,</a>
<a name="ln853">	    isnew, ether_sprintf(ni-&gt;ni_macaddr), wcid));</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">static void</a>
<a name="ln857">rt2860_node_free(struct ieee80211_node *ni)</a>
<a name="ln858">{</a>
<a name="ln859">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln860">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln861">	uint8_t wcid;</a>
<a name="ln862"> </a>
<a name="ln863">	if (ni-&gt;ni_associd != 0) {</a>
<a name="ln864">		wcid = IEEE80211_AID(ni-&gt;ni_associd);</a>
<a name="ln865"> </a>
<a name="ln866">		/* clear Rx WCID search table entry */</a>
<a name="ln867">		RAL_SET_REGION_4(sc, RT2860_WCID_ENTRY(wcid), 0, 2);</a>
<a name="ln868">	}</a>
<a name="ln869">	sc-&gt;sc_node_free(ni);</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">#ifdef IEEE80211_HT</a>
<a name="ln873">static int</a>
<a name="ln874">rt2860_ampdu_rx_start(struct ieee80211com *ic, struct ieee80211_node *ni,</a>
<a name="ln875">    uint8_t tid)</a>
<a name="ln876">{</a>
<a name="ln877">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln878">	uint8_t wcid = ((struct rt2860_node *)ni)-&gt;wcid;</a>
<a name="ln879">	uint32_t tmp;</a>
<a name="ln880"> </a>
<a name="ln881">	/* update BA session mask */</a>
<a name="ln882">	tmp = RAL_READ(sc, RT2860_WCID_ENTRY(wcid) + 4);</a>
<a name="ln883">	tmp |= (1 &lt;&lt; tid) &lt;&lt; 16;</a>
<a name="ln884">	RAL_WRITE(sc, RT2860_WCID_ENTRY(wcid) + 4, tmp);</a>
<a name="ln885">	return 0;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">static void</a>
<a name="ln889">rt2860_ampdu_rx_stop(struct ieee80211com *ic, struct ieee80211_node *ni,</a>
<a name="ln890">    uint8_t tid)</a>
<a name="ln891">{</a>
<a name="ln892">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln893">	uint8_t wcid = ((struct rt2860_node *)ni)-&gt;wcid;</a>
<a name="ln894">	uint32_t tmp;</a>
<a name="ln895"> </a>
<a name="ln896">	/* update BA session mask */</a>
<a name="ln897">	tmp = RAL_READ(sc, RT2860_WCID_ENTRY(wcid) + 4);</a>
<a name="ln898">	tmp &amp;= ~((1 &lt;&lt; tid) &lt;&lt; 16);</a>
<a name="ln899">	RAL_WRITE(sc, RT2860_WCID_ENTRY(wcid) + 4, tmp);</a>
<a name="ln900">}</a>
<a name="ln901">#endif</a>
<a name="ln902"> </a>
<a name="ln903">static int</a>
<a name="ln904">rt2860_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln905">{</a>
<a name="ln906">	struct rt2860_vap *rvp = RT2860_VAP(vap);</a>
<a name="ln907">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln908">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln909">	uint32_t tmp;</a>
<a name="ln910">	int error;</a>
<a name="ln911"> </a>
<a name="ln912">	if (vap-&gt;iv_state == IEEE80211_S_RUN) {</a>
<a name="ln913">		/* turn link LED off */</a>
<a name="ln914">		rt2860_set_leds(sc, RT2860_LED_RADIO);</a>
<a name="ln915">	}</a>
<a name="ln916"> </a>
<a name="ln917">	if (nstate == IEEE80211_S_INIT &amp;&amp; vap-&gt;iv_state == IEEE80211_S_RUN) {</a>
<a name="ln918">		/* abort TSF synchronization */</a>
<a name="ln919">		tmp = RAL_READ(sc, RT2860_BCN_TIME_CFG);</a>
<a name="ln920">		RAL_WRITE(sc, RT2860_BCN_TIME_CFG,</a>
<a name="ln921">		    tmp &amp; ~(RT2860_BCN_TX_EN | RT2860_TSF_TIMER_EN |</a>
<a name="ln922">		    RT2860_TBTT_TIMER_EN));</a>
<a name="ln923">	}</a>
<a name="ln924"> </a>
<a name="ln925">	rt2860_set_gp_timer(sc, 0);</a>
<a name="ln926"> </a>
<a name="ln927">	error = rvp-&gt;ral_newstate(vap, nstate, arg);</a>
<a name="ln928">	if (error != 0)</a>
<a name="ln929">		return (error);</a>
<a name="ln930"> </a>
<a name="ln931">	if (nstate == IEEE80211_S_RUN) {</a>
<a name="ln932">		struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln933"> </a>
<a name="ln934">		if (ic-&gt;ic_opmode != IEEE80211_M_MONITOR) {</a>
<a name="ln935">			rt2860_enable_mrr(sc);</a>
<a name="ln936">			rt2860_set_txpreamble(sc);</a>
<a name="ln937">			rt2860_set_basicrates(sc, &amp;ni-&gt;ni_rates);</a>
<a name="ln938">			rt2860_set_bssid(sc, ni-&gt;ni_bssid);</a>
<a name="ln939">		}</a>
<a name="ln940"> </a>
<a name="ln941">		if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln942">		    vap-&gt;iv_opmode == IEEE80211_M_IBSS ||</a>
<a name="ln943">		    vap-&gt;iv_opmode == IEEE80211_M_MBSS) {</a>
<a name="ln944">			error = rt2860_setup_beacon(sc, vap);</a>
<a name="ln945">			if (error != 0)</a>
<a name="ln946">				return error;</a>
<a name="ln947">		}</a>
<a name="ln948"> </a>
<a name="ln949">		if (ic-&gt;ic_opmode != IEEE80211_M_MONITOR) {</a>
<a name="ln950">			rt2860_enable_tsf_sync(sc);</a>
<a name="ln951">			rt2860_set_gp_timer(sc, 500);</a>
<a name="ln952">		}</a>
<a name="ln953"> </a>
<a name="ln954">		/* turn link LED on */</a>
<a name="ln955">		rt2860_set_leds(sc, RT2860_LED_RADIO |</a>
<a name="ln956">		    (IEEE80211_IS_CHAN_2GHZ(ni-&gt;ni_chan) ?</a>
<a name="ln957">		     RT2860_LED_LINK_2GHZ : RT2860_LED_LINK_5GHZ));</a>
<a name="ln958">	}</a>
<a name="ln959">	return error;</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">/* Read 16-bit from eFUSE ROM (&gt;=RT3071 only.) */</a>
<a name="ln963">static uint16_t</a>
<a name="ln964">rt3090_efuse_read_2(struct rt2860_softc *sc, uint16_t addr)</a>
<a name="ln965">{</a>
<a name="ln966">	uint32_t tmp;</a>
<a name="ln967">	uint16_t reg;</a>
<a name="ln968">	int ntries;</a>
<a name="ln969"> </a>
<a name="ln970">	addr *= 2;</a>
<a name="ln971">	/*-</a>
<a name="ln972">	 * Read one 16-byte block into registers EFUSE_DATA[0-3]:</a>
<a name="ln973">	 * DATA0: F E D C</a>
<a name="ln974">	 * DATA1: B A 9 8</a>
<a name="ln975">	 * DATA2: 7 6 5 4</a>
<a name="ln976">	 * DATA3: 3 2 1 0</a>
<a name="ln977">	 */</a>
<a name="ln978">	tmp = RAL_READ(sc, RT3070_EFUSE_CTRL);</a>
<a name="ln979">	tmp &amp;= ~(RT3070_EFSROM_MODE_MASK | RT3070_EFSROM_AIN_MASK);</a>
<a name="ln980">	tmp |= (addr &amp; ~0xf) &lt;&lt; RT3070_EFSROM_AIN_SHIFT | RT3070_EFSROM_KICK;</a>
<a name="ln981">	RAL_WRITE(sc, RT3070_EFUSE_CTRL, tmp);</a>
<a name="ln982">	for (ntries = 0; ntries &lt; 500; ntries++) {</a>
<a name="ln983">		tmp = RAL_READ(sc, RT3070_EFUSE_CTRL);</a>
<a name="ln984">		if (!(tmp &amp; RT3070_EFSROM_KICK))</a>
<a name="ln985">			break;</a>
<a name="ln986">		DELAY(2);</a>
<a name="ln987">	}</a>
<a name="ln988">	if (ntries == 500)</a>
<a name="ln989">		return 0xffff;</a>
<a name="ln990"> </a>
<a name="ln991">	if ((tmp &amp; RT3070_EFUSE_AOUT_MASK) == RT3070_EFUSE_AOUT_MASK)</a>
<a name="ln992">		return 0xffff;	/* address not found */</a>
<a name="ln993"> </a>
<a name="ln994">	/* determine to which 32-bit register our 16-bit word belongs */</a>
<a name="ln995">	reg = RT3070_EFUSE_DATA3 - (addr &amp; 0xc);</a>
<a name="ln996">	tmp = RAL_READ(sc, reg);</a>
<a name="ln997"> </a>
<a name="ln998">	return (addr &amp; 2) ? tmp &gt;&gt; 16 : tmp &amp; 0xffff;</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001">/*</a>
<a name="ln1002"> * Read 16 bits at address 'addr' from the serial EEPROM (either 93C46,</a>
<a name="ln1003"> * 93C66 or 93C86).</a>
<a name="ln1004"> */</a>
<a name="ln1005">static uint16_t</a>
<a name="ln1006">rt2860_eeprom_read_2(struct rt2860_softc *sc, uint16_t addr)</a>
<a name="ln1007">{</a>
<a name="ln1008">	uint32_t tmp;</a>
<a name="ln1009">	uint16_t val;</a>
<a name="ln1010">	int n;</a>
<a name="ln1011"> </a>
<a name="ln1012">	/* clock C once before the first command */</a>
<a name="ln1013">	RT2860_EEPROM_CTL(sc, 0);</a>
<a name="ln1014"> </a>
<a name="ln1015">	RT2860_EEPROM_CTL(sc, RT2860_S);</a>
<a name="ln1016">	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_C);</a>
<a name="ln1017">	RT2860_EEPROM_CTL(sc, RT2860_S);</a>
<a name="ln1018"> </a>
<a name="ln1019">	/* write start bit (1) */</a>
<a name="ln1020">	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_D);</a>
<a name="ln1021">	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_D | RT2860_C);</a>
<a name="ln1022"> </a>
<a name="ln1023">	/* write READ opcode (10) */</a>
<a name="ln1024">	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_D);</a>
<a name="ln1025">	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_D | RT2860_C);</a>
<a name="ln1026">	RT2860_EEPROM_CTL(sc, RT2860_S);</a>
<a name="ln1027">	RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_C);</a>
<a name="ln1028"> </a>
<a name="ln1029">	/* write address (A5-A0 or A7-A0) */</a>
<a name="ln1030">	n = ((RAL_READ(sc, RT2860_PCI_EECTRL) &amp; 0x30) == 0) ? 5 : 7;</a>
<a name="ln1031">	for (; n &gt;= 0; n--) {</a>
<a name="ln1032">		RT2860_EEPROM_CTL(sc, RT2860_S |</a>
<a name="ln1033">		    (((addr &gt;&gt; n) &amp; 1) &lt;&lt; RT2860_SHIFT_D));</a>
<a name="ln1034">		RT2860_EEPROM_CTL(sc, RT2860_S |</a>
<a name="ln1035">		    (((addr &gt;&gt; n) &amp; 1) &lt;&lt; RT2860_SHIFT_D) | RT2860_C);</a>
<a name="ln1036">	}</a>
<a name="ln1037"> </a>
<a name="ln1038">	RT2860_EEPROM_CTL(sc, RT2860_S);</a>
<a name="ln1039"> </a>
<a name="ln1040">	/* read data Q15-Q0 */</a>
<a name="ln1041">	val = 0;</a>
<a name="ln1042">	for (n = 15; n &gt;= 0; n--) {</a>
<a name="ln1043">		RT2860_EEPROM_CTL(sc, RT2860_S | RT2860_C);</a>
<a name="ln1044">		tmp = RAL_READ(sc, RT2860_PCI_EECTRL);</a>
<a name="ln1045">		val |= ((tmp &amp; RT2860_Q) &gt;&gt; RT2860_SHIFT_Q) &lt;&lt; n;</a>
<a name="ln1046">		RT2860_EEPROM_CTL(sc, RT2860_S);</a>
<a name="ln1047">	}</a>
<a name="ln1048"> </a>
<a name="ln1049">	RT2860_EEPROM_CTL(sc, 0);</a>
<a name="ln1050"> </a>
<a name="ln1051">	/* clear Chip Select and clock C */</a>
<a name="ln1052">	RT2860_EEPROM_CTL(sc, RT2860_S);</a>
<a name="ln1053">	RT2860_EEPROM_CTL(sc, 0);</a>
<a name="ln1054">	RT2860_EEPROM_CTL(sc, RT2860_C);</a>
<a name="ln1055"> </a>
<a name="ln1056">	return val;</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">static __inline uint16_t</a>
<a name="ln1060">rt2860_srom_read(struct rt2860_softc *sc, uint8_t addr)</a>
<a name="ln1061">{</a>
<a name="ln1062">	/* either eFUSE ROM or EEPROM */</a>
<a name="ln1063">	return sc-&gt;sc_srom_read(sc, addr);</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066">static void</a>
<a name="ln1067">rt2860_intr_coherent(struct rt2860_softc *sc)</a>
<a name="ln1068">{</a>
<a name="ln1069">	uint32_t tmp;</a>
<a name="ln1070"> </a>
<a name="ln1071">	/* DMA finds data coherent event when checking the DDONE bit */</a>
<a name="ln1072"> </a>
<a name="ln1073">	DPRINTF((&quot;Tx/Rx Coherent interrupt\n&quot;));</a>
<a name="ln1074"> </a>
<a name="ln1075">	/* restart DMA engine */</a>
<a name="ln1076">	tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);</a>
<a name="ln1077">	tmp &amp;= ~(RT2860_TX_WB_DDONE | RT2860_RX_DMA_EN | RT2860_TX_DMA_EN);</a>
<a name="ln1078">	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);</a>
<a name="ln1079"> </a>
<a name="ln1080">	(void)rt2860_txrx_enable(sc);</a>
<a name="ln1081">}</a>
<a name="ln1082"> </a>
<a name="ln1083">static void</a>
<a name="ln1084">rt2860_drain_stats_fifo(struct rt2860_softc *sc)</a>
<a name="ln1085">{</a>
<a name="ln1086">	struct ieee80211_ratectl_tx_status *txs = &amp;sc-&gt;sc_txs;</a>
<a name="ln1087">	struct ieee80211_node *ni;</a>
<a name="ln1088">	uint32_t stat;</a>
<a name="ln1089">	uint8_t wcid, mcs, pid;</a>
<a name="ln1090"> </a>
<a name="ln1091">	/* drain Tx status FIFO (maxsize = 16) */</a>
<a name="ln1092">	txs-&gt;flags = IEEE80211_RATECTL_STATUS_LONG_RETRY;</a>
<a name="ln1093">	while ((stat = RAL_READ(sc, RT2860_TX_STAT_FIFO)) &amp; RT2860_TXQ_VLD) {</a>
<a name="ln1094">		DPRINTFN(4, (&quot;tx stat 0x%08x\n&quot;, stat));</a>
<a name="ln1095"> </a>
<a name="ln1096">		wcid = (stat &gt;&gt; RT2860_TXQ_WCID_SHIFT) &amp; 0xff;</a>
<a name="ln1097">		ni = sc-&gt;wcid2ni[wcid];</a>
<a name="ln1098"> </a>
<a name="ln1099">		/* if no ACK was requested, no feedback is available */</a>
<a name="ln1100">		if (!(stat &amp; RT2860_TXQ_ACKREQ) || wcid == 0xff || ni == NULL)</a>
<a name="ln1101">			continue;</a>
<a name="ln1102"> </a>
<a name="ln1103">		/* update per-STA AMRR stats */</a>
<a name="ln1104">		if (stat &amp; RT2860_TXQ_OK) {</a>
<a name="ln1105">			/*</a>
<a name="ln1106">			 * Check if there were retries, ie if the Tx success</a>
<a name="ln1107">			 * rate is different from the requested rate.  Note</a>
<a name="ln1108">			 * that it works only because we do not allow rate</a>
<a name="ln1109">			 * fallback from OFDM to CCK.</a>
<a name="ln1110">			 */</a>
<a name="ln1111">			mcs = (stat &gt;&gt; RT2860_TXQ_MCS_SHIFT) &amp; 0x7f;</a>
<a name="ln1112">			pid = (stat &gt;&gt; RT2860_TXQ_PID_SHIFT) &amp; 0xf;</a>
<a name="ln1113">			if (mcs + 1 != pid)</a>
<a name="ln1114">				txs-&gt;long_retries = 1;</a>
<a name="ln1115">			else</a>
<a name="ln1116">				txs-&gt;long_retries = 0;</a>
<a name="ln1117">			txs-&gt;status = IEEE80211_RATECTL_TX_SUCCESS;</a>
<a name="ln1118">			ieee80211_ratectl_tx_complete(ni, txs);</a>
<a name="ln1119">		} else {</a>
<a name="ln1120">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED;</a>
<a name="ln1121">			txs-&gt;long_retries = 1;	/* XXX */</a>
<a name="ln1122">			ieee80211_ratectl_tx_complete(ni, txs);</a>
<a name="ln1123">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln1124">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln1125">		}</a>
<a name="ln1126">	}</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">static void</a>
<a name="ln1130">rt2860_tx_intr(struct rt2860_softc *sc, int qid)</a>
<a name="ln1131">{</a>
<a name="ln1132">	struct rt2860_tx_ring *ring = &amp;sc-&gt;txq[qid];</a>
<a name="ln1133">	uint32_t hw;</a>
<a name="ln1134"> </a>
<a name="ln1135">	rt2860_drain_stats_fifo(sc);</a>
<a name="ln1136"> </a>
<a name="ln1137">	hw = RAL_READ(sc, RT2860_TX_DTX_IDX(qid));</a>
<a name="ln1138">	while (ring-&gt;next != hw) {</a>
<a name="ln1139">		struct rt2860_tx_data *data = ring-&gt;data[ring-&gt;next];</a>
<a name="ln1140"> </a>
<a name="ln1141">		if (data != NULL) {</a>
<a name="ln1142">			bus_dmamap_sync(sc-&gt;txwi_dmat, data-&gt;map,</a>
<a name="ln1143">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1144">			bus_dmamap_unload(sc-&gt;txwi_dmat, data-&gt;map);</a>
<a name="ln1145">			ieee80211_tx_complete(data-&gt;ni, data-&gt;m, 0);</a>
<a name="ln1146">			data-&gt;ni = NULL;</a>
<a name="ln1147">			data-&gt;m = NULL;</a>
<a name="ln1148">			SLIST_INSERT_HEAD(&amp;sc-&gt;data_pool, data, next);</a>
<a name="ln1149">			ring-&gt;data[ring-&gt;next] = NULL;</a>
<a name="ln1150">		}</a>
<a name="ln1151">		ring-&gt;queued--;</a>
<a name="ln1152">		ring-&gt;next = (ring-&gt;next + 1) % RT2860_TX_RING_COUNT;</a>
<a name="ln1153">	}</a>
<a name="ln1154"> </a>
<a name="ln1155">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln1156">	if (ring-&gt;queued &lt; RT2860_TX_RING_COUNT)</a>
<a name="ln1157">		sc-&gt;qfullmsk &amp;= ~(1 &lt;&lt; qid);</a>
<a name="ln1158">	rt2860_start(sc);</a>
<a name="ln1159">}</a>
<a name="ln1160"> </a>
<a name="ln1161">/*</a>
<a name="ln1162"> * Return the Rx chain with the highest RSSI for a given frame.</a>
<a name="ln1163"> */</a>
<a name="ln1164">static __inline uint8_t</a>
<a name="ln1165">rt2860_maxrssi_chain(struct rt2860_softc *sc, const struct rt2860_rxwi *rxwi)</a>
<a name="ln1166">{</a>
<a name="ln1167">	uint8_t rxchain = 0;</a>
<a name="ln1168"> </a>
<a name="ln1169">	if (sc-&gt;nrxchains &gt; 1) {</a>
<a name="ln1170">		if (rxwi-&gt;rssi[1] &gt; rxwi-&gt;rssi[rxchain])</a>
<a name="ln1171">			rxchain = 1;</a>
<a name="ln1172">		if (sc-&gt;nrxchains &gt; 2)</a>
<a name="ln1173">			if (rxwi-&gt;rssi[2] &gt; rxwi-&gt;rssi[rxchain])</a>
<a name="ln1174">				rxchain = 2;</a>
<a name="ln1175">	}</a>
<a name="ln1176">	return rxchain;</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179">static void</a>
<a name="ln1180">rt2860_rx_intr(struct rt2860_softc *sc)</a>
<a name="ln1181">{</a>
<a name="ln1182">	struct rt2860_rx_radiotap_header *tap;</a>
<a name="ln1183">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1184">	struct ieee80211_frame *wh;</a>
<a name="ln1185">	struct ieee80211_node *ni;</a>
<a name="ln1186">	struct mbuf *m, *m1;</a>
<a name="ln1187">	bus_addr_t physaddr;</a>
<a name="ln1188">	uint32_t hw;</a>
<a name="ln1189">	uint16_t phy;</a>
<a name="ln1190">	uint8_t ant;</a>
<a name="ln1191">	int8_t rssi, nf;</a>
<a name="ln1192">	int error;</a>
<a name="ln1193"> </a>
<a name="ln1194">	hw = RAL_READ(sc, RT2860_FS_DRX_IDX) &amp; 0xfff;</a>
<a name="ln1195">	while (sc-&gt;rxq.cur != hw) {</a>
<a name="ln1196">		struct rt2860_rx_data *data = &amp;sc-&gt;rxq.data[sc-&gt;rxq.cur];</a>
<a name="ln1197">		struct rt2860_rxd *rxd = &amp;sc-&gt;rxq.rxd[sc-&gt;rxq.cur];</a>
<a name="ln1198">		struct rt2860_rxwi *rxwi;</a>
<a name="ln1199"> </a>
<a name="ln1200">		bus_dmamap_sync(sc-&gt;rxq.desc_dmat, sc-&gt;rxq.desc_map,</a>
<a name="ln1201">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1202"> </a>
<a name="ln1203">		if (__predict_false(!(rxd-&gt;sdl0 &amp; htole16(RT2860_RX_DDONE)))) {</a>
<a name="ln1204">			DPRINTF((&quot;RXD DDONE bit not set!\n&quot;));</a>
<a name="ln1205">			break;	/* should not happen */</a>
<a name="ln1206">		}</a>
<a name="ln1207"> </a>
<a name="ln1208">		if (__predict_false(rxd-&gt;flags &amp;</a>
<a name="ln1209">		    htole32(RT2860_RX_CRCERR | RT2860_RX_ICVERR))) {</a>
<a name="ln1210">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln1211">			goto skip;</a>
<a name="ln1212">		}</a>
<a name="ln1213"> </a>
<a name="ln1214">#ifdef HW_CRYPTO</a>
<a name="ln1215">		if (__predict_false(rxd-&gt;flags &amp; htole32(RT2860_RX_MICERR))) {</a>
<a name="ln1216">			/* report MIC failures to net80211 for TKIP */</a>
<a name="ln1217">			ic-&gt;ic_stats.is_rx_locmicfail++;</a>
<a name="ln1218">			ieee80211_michael_mic_failure(ic, 0/* XXX */);</a>
<a name="ln1219">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln1220">			goto skip;</a>
<a name="ln1221">		}</a>
<a name="ln1222">#endif</a>
<a name="ln1223"> </a>
<a name="ln1224">		m1 = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln1225">		if (__predict_false(m1 == NULL)) {</a>
<a name="ln1226">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln1227">			goto skip;</a>
<a name="ln1228">		}</a>
<a name="ln1229"> </a>
<a name="ln1230">		bus_dmamap_sync(sc-&gt;rxq.data_dmat, data-&gt;map,</a>
<a name="ln1231">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1232">		bus_dmamap_unload(sc-&gt;rxq.data_dmat, data-&gt;map);</a>
<a name="ln1233"> </a>
<a name="ln1234">		error = bus_dmamap_load(sc-&gt;rxq.data_dmat, data-&gt;map,</a>
<a name="ln1235">		    mtod(m1, void *), MCLBYTES, rt2860_dma_map_addr,</a>
<a name="ln1236">		    &amp;physaddr, 0);</a>
<a name="ln1237">		if (__predict_false(error != 0)) {</a>
<a name="ln1238">			m_freem(m1);</a>
<a name="ln1239"> </a>
<a name="ln1240">			/* try to reload the old mbuf */</a>
<a name="ln1241">			error = bus_dmamap_load(sc-&gt;rxq.data_dmat, data-&gt;map,</a>
<a name="ln1242">			    mtod(data-&gt;m, void *), MCLBYTES,</a>
<a name="ln1243">			    rt2860_dma_map_addr, &amp;physaddr, 0);</a>
<a name="ln1244">			if (__predict_false(error != 0)) {</a>
<a name="ln1245">				panic(&quot;%s: could not load old rx mbuf&quot;,</a>
<a name="ln1246">				    device_get_name(sc-&gt;sc_dev));</a>
<a name="ln1247">			}</a>
<a name="ln1248">			/* physical address may have changed */</a>
<a name="ln1249">			rxd-&gt;sdp0 = htole32(physaddr);</a>
<a name="ln1250">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln1251">			goto skip;</a>
<a name="ln1252">		}</a>
<a name="ln1253"> </a>
<a name="ln1254">		/*</a>
<a name="ln1255">		 * New mbuf successfully loaded, update Rx ring and continue</a>
<a name="ln1256">		 * processing.</a>
<a name="ln1257">		 */</a>
<a name="ln1258">		m = data-&gt;m;</a>
<a name="ln1259">		data-&gt;m = m1;</a>
<a name="ln1260">		rxd-&gt;sdp0 = htole32(physaddr);</a>
<a name="ln1261"> </a>
<a name="ln1262">		rxwi = mtod(m, struct rt2860_rxwi *);</a>
<a name="ln1263"> </a>
<a name="ln1264">		/* finalize mbuf */</a>
<a name="ln1265">		m-&gt;m_data = (caddr_t)(rxwi + 1);</a>
<a name="ln1266">		m-&gt;m_pkthdr.len = m-&gt;m_len = le16toh(rxwi-&gt;len) &amp; 0xfff;</a>
<a name="ln1267"> </a>
<a name="ln1268">		wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1269">#ifdef HW_CRYPTO</a>
<a name="ln1270">		if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln1271">			/* frame is decrypted by hardware */</a>
<a name="ln1272">			wh-&gt;i_fc[1] &amp;= ~IEEE80211_FC1_PROTECTED;</a>
<a name="ln1273">		}</a>
<a name="ln1274">#endif</a>
<a name="ln1275"> </a>
<a name="ln1276">		/* HW may insert 2 padding bytes after 802.11 header */</a>
<a name="ln1277">		if (rxd-&gt;flags &amp; htole32(RT2860_RX_L2PAD)) {</a>
<a name="ln1278">			u_int hdrlen = ieee80211_hdrsize(wh);</a>
<a name="ln1279">			ovbcopy(wh, (caddr_t)wh + 2, hdrlen);</a>
<a name="ln1280">			m-&gt;m_data += 2;</a>
<a name="ln1281">			wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1282">		}</a>
<a name="ln1283"> </a>
<a name="ln1284">		ant = rt2860_maxrssi_chain(sc, rxwi);</a>
<a name="ln1285">		rssi = rt2860_rssi2dbm(sc, rxwi-&gt;rssi[ant], ant);</a>
<a name="ln1286">		nf = RT2860_NOISE_FLOOR;</a>
<a name="ln1287"> </a>
<a name="ln1288">		if (ieee80211_radiotap_active(ic)) {</a>
<a name="ln1289">			tap = &amp;sc-&gt;sc_rxtap;</a>
<a name="ln1290">			tap-&gt;wr_flags = 0;</a>
<a name="ln1291">			tap-&gt;wr_antenna = ant;</a>
<a name="ln1292">			tap-&gt;wr_antsignal = nf + rssi;</a>
<a name="ln1293">			tap-&gt;wr_antnoise = nf;</a>
<a name="ln1294">			/* in case it can't be found below */</a>
<a name="ln1295">			tap-&gt;wr_rate = 2;</a>
<a name="ln1296">			phy = le16toh(rxwi-&gt;phy);</a>
<a name="ln1297">			switch (phy &amp; RT2860_PHY_MODE) {</a>
<a name="ln1298">			case RT2860_PHY_CCK:</a>
<a name="ln1299">				switch ((phy &amp; RT2860_PHY_MCS) &amp; ~RT2860_PHY_SHPRE) {</a>
<a name="ln1300">				case 0:	tap-&gt;wr_rate =   2; break;</a>
<a name="ln1301">				case 1:	tap-&gt;wr_rate =   4; break;</a>
<a name="ln1302">				case 2:	tap-&gt;wr_rate =  11; break;</a>
<a name="ln1303">				case 3:	tap-&gt;wr_rate =  22; break;</a>
<a name="ln1304">				}</a>
<a name="ln1305">				if (phy &amp; RT2860_PHY_SHPRE)</a>
<a name="ln1306">					tap-&gt;wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln1307">				break;</a>
<a name="ln1308">			case RT2860_PHY_OFDM:</a>
<a name="ln1309">				switch (phy &amp; RT2860_PHY_MCS) {</a>
<a name="ln1310">				case 0:	tap-&gt;wr_rate =  12; break;</a>
<a name="ln1311">				case 1:	tap-&gt;wr_rate =  18; break;</a>
<a name="ln1312">				case 2:	tap-&gt;wr_rate =  24; break;</a>
<a name="ln1313">				case 3:	tap-&gt;wr_rate =  36; break;</a>
<a name="ln1314">				case 4:	tap-&gt;wr_rate =  48; break;</a>
<a name="ln1315">				case 5:	tap-&gt;wr_rate =  72; break;</a>
<a name="ln1316">				case 6:	tap-&gt;wr_rate =  96; break;</a>
<a name="ln1317">				case 7:	tap-&gt;wr_rate = 108; break;</a>
<a name="ln1318">				}</a>
<a name="ln1319">				break;</a>
<a name="ln1320">			}</a>
<a name="ln1321">		}</a>
<a name="ln1322"> </a>
<a name="ln1323">		RAL_UNLOCK(sc);</a>
<a name="ln1324">		wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1325"> </a>
<a name="ln1326">		/* send the frame to the 802.11 layer */</a>
<a name="ln1327">		ni = ieee80211_find_rxnode(ic,</a>
<a name="ln1328">		    (struct ieee80211_frame_min *)wh);</a>
<a name="ln1329">		if (ni != NULL) {</a>
<a name="ln1330">			(void)ieee80211_input(ni, m, rssi - nf, nf);</a>
<a name="ln1331">			ieee80211_free_node(ni);</a>
<a name="ln1332">		} else</a>
<a name="ln1333">			(void)ieee80211_input_all(ic, m, rssi - nf, nf);</a>
<a name="ln1334"> </a>
<a name="ln1335">		RAL_LOCK(sc);</a>
<a name="ln1336"> </a>
<a name="ln1337">skip:		rxd-&gt;sdl0 &amp;= ~htole16(RT2860_RX_DDONE);</a>
<a name="ln1338"> </a>
<a name="ln1339">		bus_dmamap_sync(sc-&gt;rxq.desc_dmat, sc-&gt;rxq.desc_map,</a>
<a name="ln1340">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln1341"> </a>
<a name="ln1342">		sc-&gt;rxq.cur = (sc-&gt;rxq.cur + 1) % RT2860_RX_RING_COUNT;</a>
<a name="ln1343">	}</a>
<a name="ln1344"> </a>
<a name="ln1345">	/* tell HW what we have processed */</a>
<a name="ln1346">	RAL_WRITE(sc, RT2860_RX_CALC_IDX,</a>
<a name="ln1347">	    (sc-&gt;rxq.cur - 1) % RT2860_RX_RING_COUNT);</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">static void</a>
<a name="ln1351">rt2860_tbtt_intr(struct rt2860_softc *sc)</a>
<a name="ln1352">{</a>
<a name="ln1353">#if 0</a>
<a name="ln1354">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1355"> </a>
<a name="ln1356">#ifndef IEEE80211_STA_ONLY</a>
<a name="ln1357">	if (ic-&gt;ic_opmode == IEEE80211_M_HOSTAP) {</a>
<a name="ln1358">		/* one less beacon until next DTIM */</a>
<a name="ln1359">		if (ic-&gt;ic_dtim_count == 0)</a>
<a name="ln1360">			ic-&gt;ic_dtim_count = ic-&gt;ic_dtim_period - 1;</a>
<a name="ln1361">		else</a>
<a name="ln1362">			ic-&gt;ic_dtim_count--;</a>
<a name="ln1363"> </a>
<a name="ln1364">		/* update dynamic parts of beacon */</a>
<a name="ln1365">		rt2860_setup_beacon(sc);</a>
<a name="ln1366"> </a>
<a name="ln1367">		/* flush buffered multicast frames */</a>
<a name="ln1368">		if (ic-&gt;ic_dtim_count == 0)</a>
<a name="ln1369">			ieee80211_notify_dtim(ic);</a>
<a name="ln1370">	}</a>
<a name="ln1371">#endif</a>
<a name="ln1372">	/* check if protection mode has changed */</a>
<a name="ln1373">	if ((sc-&gt;sc_ic_flags ^ ic-&gt;ic_flags) &amp; IEEE80211_F_USEPROT) {</a>
<a name="ln1374">		rt2860_updateprot(sc);</a>
<a name="ln1375">		sc-&gt;sc_ic_flags = ic-&gt;ic_flags;</a>
<a name="ln1376">	}</a>
<a name="ln1377">#endif</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">static void</a>
<a name="ln1381">rt2860_gp_intr(struct rt2860_softc *sc)</a>
<a name="ln1382">{</a>
<a name="ln1383">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1384">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln1385"> </a>
<a name="ln1386">	DPRINTFN(2, (&quot;GP timeout state=%d\n&quot;, vap-&gt;iv_state));</a>
<a name="ln1387"> </a>
<a name="ln1388">	if (vap-&gt;iv_state == IEEE80211_S_RUN)</a>
<a name="ln1389">		rt2860_updatestats(sc);</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">void</a>
<a name="ln1393">rt2860_intr(void *arg)</a>
<a name="ln1394">{</a>
<a name="ln1395">	struct rt2860_softc *sc = arg;</a>
<a name="ln1396">	uint32_t r;</a>
<a name="ln1397"> </a>
<a name="ln1398">	RAL_LOCK(sc);</a>
<a name="ln1399"> </a>
<a name="ln1400">#ifndef __HAIKU__</a>
<a name="ln1401">	r = RAL_READ(sc, RT2860_INT_STATUS);</a>
<a name="ln1402">	if (__predict_false(r == 0xffffffff)) {</a>
<a name="ln1403">		RAL_UNLOCK(sc);</a>
<a name="ln1404">		return;	/* device likely went away */</a>
<a name="ln1405">	}</a>
<a name="ln1406">	if (r == 0) {</a>
<a name="ln1407">		RAL_UNLOCK(sc);</a>
<a name="ln1408">		return;	/* not for us */</a>
<a name="ln1409">	}</a>
<a name="ln1410">#else</a>
<a name="ln1411">	r = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status);</a>
<a name="ln1412">#endif</a>
<a name="ln1413"> </a>
<a name="ln1414">	/* acknowledge interrupts */</a>
<a name="ln1415">	RAL_WRITE(sc, RT2860_INT_STATUS, r);</a>
<a name="ln1416"> </a>
<a name="ln1417">	if (r &amp; RT2860_TX_RX_COHERENT)</a>
<a name="ln1418">		rt2860_intr_coherent(sc);</a>
<a name="ln1419"> </a>
<a name="ln1420">	if (r &amp; RT2860_MAC_INT_2)	/* TX status */</a>
<a name="ln1421">		rt2860_drain_stats_fifo(sc);</a>
<a name="ln1422"> </a>
<a name="ln1423">	if (r &amp; RT2860_TX_DONE_INT5)</a>
<a name="ln1424">		rt2860_tx_intr(sc, 5);</a>
<a name="ln1425"> </a>
<a name="ln1426">	if (r &amp; RT2860_RX_DONE_INT)</a>
<a name="ln1427">		rt2860_rx_intr(sc);</a>
<a name="ln1428"> </a>
<a name="ln1429">	if (r &amp; RT2860_TX_DONE_INT4)</a>
<a name="ln1430">		rt2860_tx_intr(sc, 4);</a>
<a name="ln1431"> </a>
<a name="ln1432">	if (r &amp; RT2860_TX_DONE_INT3)</a>
<a name="ln1433">		rt2860_tx_intr(sc, 3);</a>
<a name="ln1434"> </a>
<a name="ln1435">	if (r &amp; RT2860_TX_DONE_INT2)</a>
<a name="ln1436">		rt2860_tx_intr(sc, 2);</a>
<a name="ln1437"> </a>
<a name="ln1438">	if (r &amp; RT2860_TX_DONE_INT1)</a>
<a name="ln1439">		rt2860_tx_intr(sc, 1);</a>
<a name="ln1440"> </a>
<a name="ln1441">	if (r &amp; RT2860_TX_DONE_INT0)</a>
<a name="ln1442">		rt2860_tx_intr(sc, 0);</a>
<a name="ln1443"> </a>
<a name="ln1444">	if (r &amp; RT2860_MAC_INT_0)	/* TBTT */</a>
<a name="ln1445">		rt2860_tbtt_intr(sc);</a>
<a name="ln1446"> </a>
<a name="ln1447">	if (r &amp; RT2860_MAC_INT_3)	/* Auto wakeup */</a>
<a name="ln1448">		/* TBD wakeup */;</a>
<a name="ln1449"> </a>
<a name="ln1450">	if (r &amp; RT2860_MAC_INT_4)	/* GP timer */</a>
<a name="ln1451">		rt2860_gp_intr(sc);</a>
<a name="ln1452"> </a>
<a name="ln1453">	RAL_UNLOCK(sc);</a>
<a name="ln1454">}</a>
<a name="ln1455"> </a>
<a name="ln1456">static int</a>
<a name="ln1457">rt2860_tx(struct rt2860_softc *sc, struct mbuf *m, struct ieee80211_node *ni)</a>
<a name="ln1458">{</a>
<a name="ln1459">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1460">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1461">	struct rt2860_tx_ring *ring;</a>
<a name="ln1462">	struct rt2860_tx_data *data;</a>
<a name="ln1463">	struct rt2860_txd *txd;</a>
<a name="ln1464">	struct rt2860_txwi *txwi;</a>
<a name="ln1465">	struct ieee80211_frame *wh;</a>
<a name="ln1466">	const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln1467">	struct ieee80211_key *k;</a>
<a name="ln1468">	struct mbuf *m1;</a>
<a name="ln1469">	bus_dma_segment_t segs[RT2860_MAX_SCATTER];</a>
<a name="ln1470">	bus_dma_segment_t *seg;</a>
<a name="ln1471">	u_int hdrlen;</a>
<a name="ln1472">	uint16_t qos, dur;</a>
<a name="ln1473">	uint8_t type, qsel, mcs, pid, tid, qid;</a>
<a name="ln1474">	int i, nsegs, ntxds, pad, rate, ridx, error;</a>
<a name="ln1475"> </a>
<a name="ln1476">	/* the data pool contains at least one element, pick the first */</a>
<a name="ln1477">	data = SLIST_FIRST(&amp;sc-&gt;data_pool);</a>
<a name="ln1478"> </a>
<a name="ln1479">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1480"> </a>
<a name="ln1481">	if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln1482">		k = ieee80211_crypto_encap(ni, m);</a>
<a name="ln1483">		if (k == NULL) {</a>
<a name="ln1484">			m_freem(m);</a>
<a name="ln1485">			return ENOBUFS;</a>
<a name="ln1486">		}</a>
<a name="ln1487"> </a>
<a name="ln1488">		/* packet header may have moved, reset our local pointer */</a>
<a name="ln1489">		wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1490">	}</a>
<a name="ln1491"> </a>
<a name="ln1492">	hdrlen = ieee80211_anyhdrsize(wh);</a>
<a name="ln1493">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln1494"> </a>
<a name="ln1495">	if (m-&gt;m_flags &amp; M_EAPOL) {</a>
<a name="ln1496">		rate = tp-&gt;mgmtrate;</a>
<a name="ln1497">	} else if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln1498">		rate = tp-&gt;mcastrate;</a>
<a name="ln1499">	} else if (tp-&gt;ucastrate != IEEE80211_FIXED_RATE_NONE) {</a>
<a name="ln1500">		rate = tp-&gt;ucastrate;</a>
<a name="ln1501">	} else {</a>
<a name="ln1502">		(void) ieee80211_ratectl_rate(ni, NULL, 0);</a>
<a name="ln1503">		rate = ni-&gt;ni_txrate;</a>
<a name="ln1504">	}</a>
<a name="ln1505">	rate &amp;= IEEE80211_RATE_VAL;</a>
<a name="ln1506"> </a>
<a name="ln1507">	qid = M_WME_GETAC(m);</a>
<a name="ln1508">	if (IEEE80211_QOS_HAS_SEQ(wh)) {</a>
<a name="ln1509">		qos = ((const struct ieee80211_qosframe *)wh)-&gt;i_qos[0];</a>
<a name="ln1510">		tid = qos &amp; IEEE80211_QOS_TID;</a>
<a name="ln1511">	} else {</a>
<a name="ln1512">		qos = 0;</a>
<a name="ln1513">		tid = 0;</a>
<a name="ln1514">	}</a>
<a name="ln1515">	ring = &amp;sc-&gt;txq[qid];</a>
<a name="ln1516">	ridx = ieee80211_legacy_rate_lookup(ic-&gt;ic_rt, rate);</a>
<a name="ln1517"> </a>
<a name="ln1518">	/* get MCS code from rate index */</a>
<a name="ln1519">	mcs = rt2860_rates[ridx].mcs;</a>
<a name="ln1520"> </a>
<a name="ln1521">	/* setup TX Wireless Information */</a>
<a name="ln1522">	txwi = data-&gt;txwi;</a>
<a name="ln1523">	txwi-&gt;flags = 0;</a>
<a name="ln1524">	/* let HW generate seq numbers for non-QoS frames */</a>
<a name="ln1525">	txwi-&gt;xflags = qos ? 0 : RT2860_TX_NSEQ;</a>
<a name="ln1526">	if (type == IEEE80211_FC0_TYPE_DATA)</a>
<a name="ln1527">		txwi-&gt;wcid = IEEE80211_AID(ni-&gt;ni_associd);</a>
<a name="ln1528">	else</a>
<a name="ln1529">		txwi-&gt;wcid = 0xff;</a>
<a name="ln1530">	txwi-&gt;len = htole16(m-&gt;m_pkthdr.len);</a>
<a name="ln1531">	if (rt2860_rates[ridx].phy == IEEE80211_T_DS) {</a>
<a name="ln1532">		txwi-&gt;phy = htole16(RT2860_PHY_CCK);</a>
<a name="ln1533">		if (ridx != RT2860_RIDX_CCK1 &amp;&amp;</a>
<a name="ln1534">		    (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE))</a>
<a name="ln1535">			mcs |= RT2860_PHY_SHPRE;</a>
<a name="ln1536">	} else</a>
<a name="ln1537">		txwi-&gt;phy = htole16(RT2860_PHY_OFDM);</a>
<a name="ln1538">	txwi-&gt;phy |= htole16(mcs);</a>
<a name="ln1539"> </a>
<a name="ln1540">	/*</a>
<a name="ln1541">	 * We store the MCS code into the driver-private PacketID field.</a>
<a name="ln1542">	 * The PacketID is latched into TX_STAT_FIFO when Tx completes so</a>
<a name="ln1543">	 * that we know at which initial rate the frame was transmitted.</a>
<a name="ln1544">	 * We add 1 to the MCS code because setting the PacketID field to</a>
<a name="ln1545">	 * 0 means that we don't want feedback in TX_STAT_FIFO.</a>
<a name="ln1546">	 */</a>
<a name="ln1547">	pid = (mcs + 1) &amp; 0xf;</a>
<a name="ln1548">	txwi-&gt;len |= htole16(pid &lt;&lt; RT2860_TX_PID_SHIFT);</a>
<a name="ln1549"> </a>
<a name="ln1550">	/* check if RTS/CTS or CTS-to-self protection is required */</a>
<a name="ln1551">	if (!IEEE80211_IS_MULTICAST(wh-&gt;i_addr1) &amp;&amp;</a>
<a name="ln1552">	    (m-&gt;m_pkthdr.len + IEEE80211_CRC_LEN &gt; vap-&gt;iv_rtsthreshold ||</a>
<a name="ln1553">	     ((ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT) &amp;&amp;</a>
<a name="ln1554">	      rt2860_rates[ridx].phy == IEEE80211_T_OFDM)))</a>
<a name="ln1555">		txwi-&gt;txop = RT2860_TX_TXOP_HT;</a>
<a name="ln1556">	else</a>
<a name="ln1557">		txwi-&gt;txop = RT2860_TX_TXOP_BACKOFF;</a>
<a name="ln1558"> </a>
<a name="ln1559">	if (!IEEE80211_IS_MULTICAST(wh-&gt;i_addr1) &amp;&amp;</a>
<a name="ln1560">	    (!qos || (qos &amp; IEEE80211_QOS_ACKPOLICY) !=</a>
<a name="ln1561">	     IEEE80211_QOS_ACKPOLICY_NOACK)) {</a>
<a name="ln1562">		txwi-&gt;xflags |= RT2860_TX_ACK;</a>
<a name="ln1563"> </a>
<a name="ln1564">		if (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE)</a>
<a name="ln1565">			dur = rt2860_rates[ridx].sp_ack_dur;</a>
<a name="ln1566">		else</a>
<a name="ln1567">			dur = rt2860_rates[ridx].lp_ack_dur;</a>
<a name="ln1568">		*(uint16_t *)wh-&gt;i_dur = htole16(dur);</a>
<a name="ln1569">	}</a>
<a name="ln1570">	/* ask MAC to insert timestamp into probe responses */</a>
<a name="ln1571">	if ((wh-&gt;i_fc[0] &amp;</a>
<a name="ln1572">	     (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==</a>
<a name="ln1573">	     (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))</a>
<a name="ln1574">	    /* NOTE: beacons do not pass through tx_data() */</a>
<a name="ln1575">		txwi-&gt;flags |= RT2860_TX_TS;</a>
<a name="ln1576"> </a>
<a name="ln1577">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln1578">		struct rt2860_tx_radiotap_header *tap = &amp;sc-&gt;sc_txtap;</a>
<a name="ln1579"> </a>
<a name="ln1580">		tap-&gt;wt_flags = 0;</a>
<a name="ln1581">		tap-&gt;wt_rate = rate;</a>
<a name="ln1582">		if (mcs &amp; RT2860_PHY_SHPRE)</a>
<a name="ln1583">			tap-&gt;wt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln1584"> </a>
<a name="ln1585">		ieee80211_radiotap_tx(vap, m);</a>
<a name="ln1586">	}</a>
<a name="ln1587"> </a>
<a name="ln1588">	pad = (hdrlen + 3) &amp; ~3;</a>
<a name="ln1589"> </a>
<a name="ln1590">	/* copy and trim 802.11 header */</a>
<a name="ln1591">	memcpy(txwi + 1, wh, hdrlen);</a>
<a name="ln1592">	m_adj(m, hdrlen);</a>
<a name="ln1593"> </a>
<a name="ln1594">	error = bus_dmamap_load_mbuf_sg(sc-&gt;txwi_dmat, data-&gt;map, m, segs,</a>
<a name="ln1595">	    &amp;nsegs, 0);</a>
<a name="ln1596">	if (__predict_false(error != 0 &amp;&amp; error != EFBIG)) {</a>
<a name="ln1597">		device_printf(sc-&gt;sc_dev, &quot;can't map mbuf (error %d)\n&quot;,</a>
<a name="ln1598">		    error);</a>
<a name="ln1599">		m_freem(m);</a>
<a name="ln1600">		return error;</a>
<a name="ln1601">	}</a>
<a name="ln1602">	if (__predict_true(error == 0)) {</a>
<a name="ln1603">		/* determine how many TXDs are required */</a>
<a name="ln1604">		ntxds = 1 + (nsegs / 2);</a>
<a name="ln1605"> </a>
<a name="ln1606">		if (ring-&gt;queued + ntxds &gt;= RT2860_TX_RING_COUNT) {</a>
<a name="ln1607">			/* not enough free TXDs, force mbuf defrag */</a>
<a name="ln1608">			bus_dmamap_unload(sc-&gt;txwi_dmat, data-&gt;map);</a>
<a name="ln1609">			error = EFBIG;</a>
<a name="ln1610">		}</a>
<a name="ln1611">	}</a>
<a name="ln1612">	if (__predict_false(error != 0)) {</a>
<a name="ln1613">		m1 = m_defrag(m, M_NOWAIT);</a>
<a name="ln1614">		if (m1 == NULL) {</a>
<a name="ln1615">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1616">			    &quot;could not defragment mbuf\n&quot;);</a>
<a name="ln1617">			m_freem(m);</a>
<a name="ln1618">			return ENOBUFS;</a>
<a name="ln1619">		}</a>
<a name="ln1620">		m = m1;</a>
<a name="ln1621"> </a>
<a name="ln1622">		error = bus_dmamap_load_mbuf_sg(sc-&gt;txwi_dmat, data-&gt;map, m,</a>
<a name="ln1623">		    segs, &amp;nsegs, 0);</a>
<a name="ln1624">		if (__predict_false(error != 0)) {</a>
<a name="ln1625">			device_printf(sc-&gt;sc_dev, &quot;can't map mbuf (error %d)\n&quot;,</a>
<a name="ln1626">			    error);</a>
<a name="ln1627">			m_freem(m);</a>
<a name="ln1628">			return error;</a>
<a name="ln1629">		}</a>
<a name="ln1630"> </a>
<a name="ln1631">		/* determine how many TXDs are now required */</a>
<a name="ln1632">		ntxds = 1 + (nsegs / 2);</a>
<a name="ln1633"> </a>
<a name="ln1634">		if (ring-&gt;queued + ntxds &gt;= RT2860_TX_RING_COUNT) {</a>
<a name="ln1635">			/* this is a hopeless case, drop the mbuf! */</a>
<a name="ln1636">			bus_dmamap_unload(sc-&gt;txwi_dmat, data-&gt;map);</a>
<a name="ln1637">			m_freem(m);</a>
<a name="ln1638">			return ENOBUFS;</a>
<a name="ln1639">		}</a>
<a name="ln1640">	}</a>
<a name="ln1641"> </a>
<a name="ln1642">	qsel = (qid &lt; WME_NUM_AC) ? RT2860_TX_QSEL_EDCA : RT2860_TX_QSEL_MGMT;</a>
<a name="ln1643"> </a>
<a name="ln1644">	/* first segment is TXWI + 802.11 header */</a>
<a name="ln1645">	txd = &amp;ring-&gt;txd[ring-&gt;cur];</a>
<a name="ln1646">	txd-&gt;sdp0 = htole32(data-&gt;paddr);</a>
<a name="ln1647">	txd-&gt;sdl0 = htole16(sizeof (struct rt2860_txwi) + pad);</a>
<a name="ln1648">	txd-&gt;flags = qsel;</a>
<a name="ln1649"> </a>
<a name="ln1650">	/* setup payload segments */</a>
<a name="ln1651">	seg = &amp;segs[0];</a>
<a name="ln1652">	for (i = nsegs; i &gt;= 2; i -= 2) {</a>
<a name="ln1653">		txd-&gt;sdp1 = htole32(seg-&gt;ds_addr);</a>
<a name="ln1654">		txd-&gt;sdl1 = htole16(seg-&gt;ds_len);</a>
<a name="ln1655">		seg++;</a>
<a name="ln1656">		ring-&gt;cur = (ring-&gt;cur + 1) % RT2860_TX_RING_COUNT;</a>
<a name="ln1657">		/* grab a new Tx descriptor */</a>
<a name="ln1658">		txd = &amp;ring-&gt;txd[ring-&gt;cur];</a>
<a name="ln1659">		txd-&gt;sdp0 = htole32(seg-&gt;ds_addr);</a>
<a name="ln1660">		txd-&gt;sdl0 = htole16(seg-&gt;ds_len);</a>
<a name="ln1661">		txd-&gt;flags = qsel;</a>
<a name="ln1662">		seg++;</a>
<a name="ln1663">	}</a>
<a name="ln1664">	/* finalize last segment */</a>
<a name="ln1665">	if (i &gt; 0) {</a>
<a name="ln1666">		txd-&gt;sdp1 = htole32(seg-&gt;ds_addr);</a>
<a name="ln1667">		txd-&gt;sdl1 = htole16(seg-&gt;ds_len | RT2860_TX_LS1);</a>
<a name="ln1668">	} else {</a>
<a name="ln1669">		txd-&gt;sdl0 |= htole16(RT2860_TX_LS0);</a>
<a name="ln1670">		txd-&gt;sdl1 = 0;</a>
<a name="ln1671">	}</a>
<a name="ln1672"> </a>
<a name="ln1673">	/* remove from the free pool and link it into the SW Tx slot */</a>
<a name="ln1674">	SLIST_REMOVE_HEAD(&amp;sc-&gt;data_pool, next);</a>
<a name="ln1675">	data-&gt;m = m;</a>
<a name="ln1676">	data-&gt;ni = ni;</a>
<a name="ln1677">	ring-&gt;data[ring-&gt;cur] = data;</a>
<a name="ln1678"> </a>
<a name="ln1679">	bus_dmamap_sync(sc-&gt;txwi_dmat, sc-&gt;txwi_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1680">	bus_dmamap_sync(sc-&gt;txwi_dmat, data-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1681">	bus_dmamap_sync(ring-&gt;desc_dmat, ring-&gt;desc_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1682"> </a>
<a name="ln1683">	DPRINTFN(4, (&quot;sending frame qid=%d wcid=%d nsegs=%d ridx=%d\n&quot;,</a>
<a name="ln1684">	    qid, txwi-&gt;wcid, nsegs, ridx));</a>
<a name="ln1685"> </a>
<a name="ln1686">	ring-&gt;cur = (ring-&gt;cur + 1) % RT2860_TX_RING_COUNT;</a>
<a name="ln1687">	ring-&gt;queued += ntxds;</a>
<a name="ln1688">	if (ring-&gt;queued &gt;= RT2860_TX_RING_COUNT)</a>
<a name="ln1689">		sc-&gt;qfullmsk |= 1 &lt;&lt; qid;</a>
<a name="ln1690"> </a>
<a name="ln1691">	/* kick Tx */</a>
<a name="ln1692">	RAL_WRITE(sc, RT2860_TX_CTX_IDX(qid), ring-&gt;cur);</a>
<a name="ln1693"> </a>
<a name="ln1694">	return 0;</a>
<a name="ln1695">}</a>
<a name="ln1696"> </a>
<a name="ln1697">static int</a>
<a name="ln1698">rt2860_raw_xmit(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln1699">    const struct ieee80211_bpf_params *params)</a>
<a name="ln1700">{</a>
<a name="ln1701">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln1702">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1703">	int error;</a>
<a name="ln1704"> </a>
<a name="ln1705">	RAL_LOCK(sc);</a>
<a name="ln1706"> </a>
<a name="ln1707">	/* prevent management frames from being sent if we're not ready */</a>
<a name="ln1708">	if (!(sc-&gt;sc_flags &amp; RT2860_RUNNING)) {</a>
<a name="ln1709">		RAL_UNLOCK(sc);</a>
<a name="ln1710">		m_freem(m);</a>
<a name="ln1711">		return ENETDOWN;</a>
<a name="ln1712">	}</a>
<a name="ln1713">	if (params == NULL) {</a>
<a name="ln1714">		/*</a>
<a name="ln1715">		 * Legacy path; interpret frame contents to decide</a>
<a name="ln1716">		 * precisely how to send the frame.</a>
<a name="ln1717">		 */</a>
<a name="ln1718">		error = rt2860_tx(sc, m, ni);</a>
<a name="ln1719">	} else {</a>
<a name="ln1720">		/*</a>
<a name="ln1721">		 * Caller supplied explicit parameters to use in</a>
<a name="ln1722">		 * sending the frame.</a>
<a name="ln1723">		 */</a>
<a name="ln1724">		error = rt2860_tx_raw(sc, m, ni, params);</a>
<a name="ln1725">	}</a>
<a name="ln1726">	sc-&gt;sc_tx_timer = 5;</a>
<a name="ln1727">	RAL_UNLOCK(sc);</a>
<a name="ln1728">	return error;</a>
<a name="ln1729">}</a>
<a name="ln1730"> </a>
<a name="ln1731">static int</a>
<a name="ln1732">rt2860_tx_raw(struct rt2860_softc *sc, struct mbuf *m,</a>
<a name="ln1733">    struct ieee80211_node *ni, const struct ieee80211_bpf_params *params)</a>
<a name="ln1734">{</a>
<a name="ln1735">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1736">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1737">	struct rt2860_tx_ring *ring;</a>
<a name="ln1738">	struct rt2860_tx_data *data;</a>
<a name="ln1739">	struct rt2860_txd *txd;</a>
<a name="ln1740">	struct rt2860_txwi *txwi;</a>
<a name="ln1741">	struct ieee80211_frame *wh;</a>
<a name="ln1742">	struct mbuf *m1;</a>
<a name="ln1743">	bus_dma_segment_t segs[RT2860_MAX_SCATTER];</a>
<a name="ln1744">	bus_dma_segment_t *seg;</a>
<a name="ln1745">	u_int hdrlen;</a>
<a name="ln1746">	uint16_t dur;</a>
<a name="ln1747">	uint8_t type, qsel, mcs, pid, tid, qid;</a>
<a name="ln1748">	int i, nsegs, ntxds, pad, rate, ridx, error;</a>
<a name="ln1749"> </a>
<a name="ln1750">	/* the data pool contains at least one element, pick the first */</a>
<a name="ln1751">	data = SLIST_FIRST(&amp;sc-&gt;data_pool);</a>
<a name="ln1752"> </a>
<a name="ln1753">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1754">	hdrlen = ieee80211_hdrsize(wh);</a>
<a name="ln1755">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln1756"> </a>
<a name="ln1757">	/* Choose a TX rate index. */</a>
<a name="ln1758">	rate = params-&gt;ibp_rate0;</a>
<a name="ln1759">	ridx = ieee80211_legacy_rate_lookup(ic-&gt;ic_rt,</a>
<a name="ln1760">	    rate &amp; IEEE80211_RATE_VAL);</a>
<a name="ln1761">	if (ridx == (uint8_t)-1) {</a>
<a name="ln1762">		/* XXX fall back to mcast/mgmt rate? */</a>
<a name="ln1763">		m_freem(m);</a>
<a name="ln1764">		return EINVAL;</a>
<a name="ln1765">	}</a>
<a name="ln1766"> </a>
<a name="ln1767">	qid = params-&gt;ibp_pri &amp; 3;</a>
<a name="ln1768">	tid = 0;</a>
<a name="ln1769">	ring = &amp;sc-&gt;txq[qid];</a>
<a name="ln1770"> </a>
<a name="ln1771">	/* get MCS code from rate index */</a>
<a name="ln1772">	mcs = rt2860_rates[ridx].mcs;</a>
<a name="ln1773"> </a>
<a name="ln1774">	/* setup TX Wireless Information */</a>
<a name="ln1775">	txwi = data-&gt;txwi;</a>
<a name="ln1776">	txwi-&gt;flags = 0;</a>
<a name="ln1777">	/* let HW generate seq numbers for non-QoS frames */</a>
<a name="ln1778">	txwi-&gt;xflags = params-&gt;ibp_pri &amp; 3 ? 0 : RT2860_TX_NSEQ;</a>
<a name="ln1779">	txwi-&gt;wcid = 0xff;</a>
<a name="ln1780">	txwi-&gt;len = htole16(m-&gt;m_pkthdr.len);</a>
<a name="ln1781">	if (rt2860_rates[ridx].phy == IEEE80211_T_DS) {</a>
<a name="ln1782">		txwi-&gt;phy = htole16(RT2860_PHY_CCK);</a>
<a name="ln1783">		if (ridx != RT2860_RIDX_CCK1 &amp;&amp;</a>
<a name="ln1784">		    (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE))</a>
<a name="ln1785">			mcs |= RT2860_PHY_SHPRE;</a>
<a name="ln1786">	} else</a>
<a name="ln1787">		txwi-&gt;phy = htole16(RT2860_PHY_OFDM);</a>
<a name="ln1788">	txwi-&gt;phy |= htole16(mcs);</a>
<a name="ln1789"> </a>
<a name="ln1790">	/*</a>
<a name="ln1791">	 * We store the MCS code into the driver-private PacketID field.</a>
<a name="ln1792">	 * The PacketID is latched into TX_STAT_FIFO when Tx completes so</a>
<a name="ln1793">	 * that we know at which initial rate the frame was transmitted.</a>
<a name="ln1794">	 * We add 1 to the MCS code because setting the PacketID field to</a>
<a name="ln1795">	 * 0 means that we don't want feedback in TX_STAT_FIFO.</a>
<a name="ln1796">	 */</a>
<a name="ln1797">	pid = (mcs + 1) &amp; 0xf;</a>
<a name="ln1798">	txwi-&gt;len |= htole16(pid &lt;&lt; RT2860_TX_PID_SHIFT);</a>
<a name="ln1799"> </a>
<a name="ln1800">	/* check if RTS/CTS or CTS-to-self protection is required */</a>
<a name="ln1801">	if (params-&gt;ibp_flags &amp; IEEE80211_BPF_RTS ||</a>
<a name="ln1802">	    params-&gt;ibp_flags &amp; IEEE80211_BPF_CTS)</a>
<a name="ln1803">		txwi-&gt;txop = RT2860_TX_TXOP_HT;</a>
<a name="ln1804">	else</a>
<a name="ln1805">		txwi-&gt;txop = RT2860_TX_TXOP_BACKOFF;</a>
<a name="ln1806">	if ((params-&gt;ibp_flags &amp; IEEE80211_BPF_NOACK) == 0) {</a>
<a name="ln1807">		txwi-&gt;xflags |= RT2860_TX_ACK;</a>
<a name="ln1808"> </a>
<a name="ln1809">		if (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE)</a>
<a name="ln1810">			dur = rt2860_rates[ridx].sp_ack_dur;</a>
<a name="ln1811">		else</a>
<a name="ln1812">			dur = rt2860_rates[ridx].lp_ack_dur;</a>
<a name="ln1813">		*(uint16_t *)wh-&gt;i_dur = htole16(dur);</a>
<a name="ln1814">	}</a>
<a name="ln1815">	/* ask MAC to insert timestamp into probe responses */</a>
<a name="ln1816">	if ((wh-&gt;i_fc[0] &amp;</a>
<a name="ln1817">	     (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==</a>
<a name="ln1818">	     (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))</a>
<a name="ln1819">	    /* NOTE: beacons do not pass through tx_data() */</a>
<a name="ln1820">		txwi-&gt;flags |= RT2860_TX_TS;</a>
<a name="ln1821"> </a>
<a name="ln1822">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln1823">		struct rt2860_tx_radiotap_header *tap = &amp;sc-&gt;sc_txtap;</a>
<a name="ln1824"> </a>
<a name="ln1825">		tap-&gt;wt_flags = 0;</a>
<a name="ln1826">		tap-&gt;wt_rate = rate;</a>
<a name="ln1827">		if (mcs &amp; RT2860_PHY_SHPRE)</a>
<a name="ln1828">			tap-&gt;wt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln1829"> </a>
<a name="ln1830">		ieee80211_radiotap_tx(vap, m);</a>
<a name="ln1831">	}</a>
<a name="ln1832"> </a>
<a name="ln1833">	pad = (hdrlen + 3) &amp; ~3;</a>
<a name="ln1834"> </a>
<a name="ln1835">	/* copy and trim 802.11 header */</a>
<a name="ln1836">	memcpy(txwi + 1, wh, hdrlen);</a>
<a name="ln1837">	m_adj(m, hdrlen);</a>
<a name="ln1838"> </a>
<a name="ln1839">	error = bus_dmamap_load_mbuf_sg(sc-&gt;txwi_dmat, data-&gt;map, m, segs,</a>
<a name="ln1840">	    &amp;nsegs, 0);</a>
<a name="ln1841">	if (__predict_false(error != 0 &amp;&amp; error != EFBIG)) {</a>
<a name="ln1842">		device_printf(sc-&gt;sc_dev, &quot;can't map mbuf (error %d)\n&quot;,</a>
<a name="ln1843">		    error);</a>
<a name="ln1844">		m_freem(m);</a>
<a name="ln1845">		return error;</a>
<a name="ln1846">	}</a>
<a name="ln1847">	if (__predict_true(error == 0)) {</a>
<a name="ln1848">		/* determine how many TXDs are required */</a>
<a name="ln1849">		ntxds = 1 + (nsegs / 2);</a>
<a name="ln1850"> </a>
<a name="ln1851">		if (ring-&gt;queued + ntxds &gt;= RT2860_TX_RING_COUNT) {</a>
<a name="ln1852">			/* not enough free TXDs, force mbuf defrag */</a>
<a name="ln1853">			bus_dmamap_unload(sc-&gt;txwi_dmat, data-&gt;map);</a>
<a name="ln1854">			error = EFBIG;</a>
<a name="ln1855">		}</a>
<a name="ln1856">	}</a>
<a name="ln1857">	if (__predict_false(error != 0)) {</a>
<a name="ln1858">		m1 = m_defrag(m, M_NOWAIT);</a>
<a name="ln1859">		if (m1 == NULL) {</a>
<a name="ln1860">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1861">			    &quot;could not defragment mbuf\n&quot;);</a>
<a name="ln1862">			m_freem(m);</a>
<a name="ln1863">			return ENOBUFS;</a>
<a name="ln1864">		}</a>
<a name="ln1865">		m = m1;</a>
<a name="ln1866"> </a>
<a name="ln1867">		error = bus_dmamap_load_mbuf_sg(sc-&gt;txwi_dmat, data-&gt;map, m,</a>
<a name="ln1868">		    segs, &amp;nsegs, 0);</a>
<a name="ln1869">		if (__predict_false(error != 0)) {</a>
<a name="ln1870">			device_printf(sc-&gt;sc_dev, &quot;can't map mbuf (error %d)\n&quot;,</a>
<a name="ln1871">			    error);</a>
<a name="ln1872">			m_freem(m);</a>
<a name="ln1873">			return error;</a>
<a name="ln1874">		}</a>
<a name="ln1875"> </a>
<a name="ln1876">		/* determine how many TXDs are now required */</a>
<a name="ln1877">		ntxds = 1 + (nsegs / 2);</a>
<a name="ln1878"> </a>
<a name="ln1879">		if (ring-&gt;queued + ntxds &gt;= RT2860_TX_RING_COUNT) {</a>
<a name="ln1880">			/* this is a hopeless case, drop the mbuf! */</a>
<a name="ln1881">			bus_dmamap_unload(sc-&gt;txwi_dmat, data-&gt;map);</a>
<a name="ln1882">			m_freem(m);</a>
<a name="ln1883">			return ENOBUFS;</a>
<a name="ln1884">		}</a>
<a name="ln1885">	}</a>
<a name="ln1886"> </a>
<a name="ln1887">	qsel = (qid &lt; WME_NUM_AC) ? RT2860_TX_QSEL_EDCA : RT2860_TX_QSEL_MGMT;</a>
<a name="ln1888"> </a>
<a name="ln1889">	/* first segment is TXWI + 802.11 header */</a>
<a name="ln1890">	txd = &amp;ring-&gt;txd[ring-&gt;cur];</a>
<a name="ln1891">	txd-&gt;sdp0 = htole32(data-&gt;paddr);</a>
<a name="ln1892">	txd-&gt;sdl0 = htole16(sizeof (struct rt2860_txwi) + pad);</a>
<a name="ln1893">	txd-&gt;flags = qsel;</a>
<a name="ln1894"> </a>
<a name="ln1895">	/* setup payload segments */</a>
<a name="ln1896">	seg = &amp;segs[0];</a>
<a name="ln1897">	for (i = nsegs; i &gt;= 2; i -= 2) {</a>
<a name="ln1898">		txd-&gt;sdp1 = htole32(seg-&gt;ds_addr);</a>
<a name="ln1899">		txd-&gt;sdl1 = htole16(seg-&gt;ds_len);</a>
<a name="ln1900">		seg++;</a>
<a name="ln1901">		ring-&gt;cur = (ring-&gt;cur + 1) % RT2860_TX_RING_COUNT;</a>
<a name="ln1902">		/* grab a new Tx descriptor */</a>
<a name="ln1903">		txd = &amp;ring-&gt;txd[ring-&gt;cur];</a>
<a name="ln1904">		txd-&gt;sdp0 = htole32(seg-&gt;ds_addr);</a>
<a name="ln1905">		txd-&gt;sdl0 = htole16(seg-&gt;ds_len);</a>
<a name="ln1906">		txd-&gt;flags = qsel;</a>
<a name="ln1907">		seg++;</a>
<a name="ln1908">	}</a>
<a name="ln1909">	/* finalize last segment */</a>
<a name="ln1910">	if (i &gt; 0) {</a>
<a name="ln1911">		txd-&gt;sdp1 = htole32(seg-&gt;ds_addr);</a>
<a name="ln1912">		txd-&gt;sdl1 = htole16(seg-&gt;ds_len | RT2860_TX_LS1);</a>
<a name="ln1913">	} else {</a>
<a name="ln1914">		txd-&gt;sdl0 |= htole16(RT2860_TX_LS0);</a>
<a name="ln1915">		txd-&gt;sdl1 = 0;</a>
<a name="ln1916">	}</a>
<a name="ln1917"> </a>
<a name="ln1918">	/* remove from the free pool and link it into the SW Tx slot */</a>
<a name="ln1919">	SLIST_REMOVE_HEAD(&amp;sc-&gt;data_pool, next);</a>
<a name="ln1920">	data-&gt;m = m;</a>
<a name="ln1921">	data-&gt;ni = ni;</a>
<a name="ln1922">	ring-&gt;data[ring-&gt;cur] = data;</a>
<a name="ln1923"> </a>
<a name="ln1924">	bus_dmamap_sync(sc-&gt;txwi_dmat, sc-&gt;txwi_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1925">	bus_dmamap_sync(sc-&gt;txwi_dmat, data-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1926">	bus_dmamap_sync(ring-&gt;desc_dmat, ring-&gt;desc_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1927"> </a>
<a name="ln1928">	DPRINTFN(4, (&quot;sending frame qid=%d wcid=%d nsegs=%d ridx=%d\n&quot;,</a>
<a name="ln1929">	    qid, txwi-&gt;wcid, nsegs, ridx));</a>
<a name="ln1930"> </a>
<a name="ln1931">	ring-&gt;cur = (ring-&gt;cur + 1) % RT2860_TX_RING_COUNT;</a>
<a name="ln1932">	ring-&gt;queued += ntxds;</a>
<a name="ln1933">	if (ring-&gt;queued &gt;= RT2860_TX_RING_COUNT)</a>
<a name="ln1934">		sc-&gt;qfullmsk |= 1 &lt;&lt; qid;</a>
<a name="ln1935"> </a>
<a name="ln1936">	/* kick Tx */</a>
<a name="ln1937">	RAL_WRITE(sc, RT2860_TX_CTX_IDX(qid), ring-&gt;cur);</a>
<a name="ln1938"> </a>
<a name="ln1939">	return 0;</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942">static int</a>
<a name="ln1943">rt2860_transmit(struct ieee80211com *ic, struct mbuf *m)   </a>
<a name="ln1944">{</a>
<a name="ln1945">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1946">	int error;</a>
<a name="ln1947"> </a>
<a name="ln1948">	RAL_LOCK(sc);</a>
<a name="ln1949">	if ((sc-&gt;sc_flags &amp; RT2860_RUNNING) == 0) {</a>
<a name="ln1950">		RAL_UNLOCK(sc);</a>
<a name="ln1951">		return (ENXIO);</a>
<a name="ln1952">	}</a>
<a name="ln1953">	error = mbufq_enqueue(&amp;sc-&gt;sc_snd, m);</a>
<a name="ln1954">	if (error) {</a>
<a name="ln1955">		RAL_UNLOCK(sc);</a>
<a name="ln1956">		return (error);</a>
<a name="ln1957">	}</a>
<a name="ln1958">	rt2860_start(sc);</a>
<a name="ln1959">	RAL_UNLOCK(sc);</a>
<a name="ln1960"> </a>
<a name="ln1961">	return (0);</a>
<a name="ln1962">}</a>
<a name="ln1963"> </a>
<a name="ln1964">static void</a>
<a name="ln1965">rt2860_start(struct rt2860_softc *sc)</a>
<a name="ln1966">{</a>
<a name="ln1967">	struct ieee80211_node *ni;</a>
<a name="ln1968">	struct mbuf *m;</a>
<a name="ln1969"> </a>
<a name="ln1970">	RAL_LOCK_ASSERT(sc);</a>
<a name="ln1971"> </a>
<a name="ln1972">	if ((sc-&gt;sc_flags &amp; RT2860_RUNNING) == 0)</a>
<a name="ln1973">		return;</a>
<a name="ln1974"> </a>
<a name="ln1975">	while (!SLIST_EMPTY(&amp;sc-&gt;data_pool) &amp;&amp; sc-&gt;qfullmsk == 0 &amp;&amp;</a>
<a name="ln1976">	    (m = mbufq_dequeue(&amp;sc-&gt;sc_snd)) != NULL) {</a>
<a name="ln1977">		ni = (struct ieee80211_node *)m-&gt;m_pkthdr.rcvif;</a>
<a name="ln1978">		if (rt2860_tx(sc, m, ni) != 0) {</a>
<a name="ln1979">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln1980">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln1981">			ieee80211_free_node(ni);</a>
<a name="ln1982">			continue;</a>
<a name="ln1983">		}</a>
<a name="ln1984">		sc-&gt;sc_tx_timer = 5;</a>
<a name="ln1985">	}</a>
<a name="ln1986">}</a>
<a name="ln1987"> </a>
<a name="ln1988">static void</a>
<a name="ln1989">rt2860_watchdog(void *arg)</a>
<a name="ln1990">{</a>
<a name="ln1991">	struct rt2860_softc *sc = arg;</a>
<a name="ln1992"> </a>
<a name="ln1993">	RAL_LOCK_ASSERT(sc);</a>
<a name="ln1994"> </a>
<a name="ln1995">	KASSERT(sc-&gt;sc_flags &amp; RT2860_RUNNING, (&quot;not running&quot;));</a>
<a name="ln1996"> </a>
<a name="ln1997">	if (sc-&gt;sc_invalid)		/* card ejected */</a>
<a name="ln1998">		return;</a>
<a name="ln1999"> </a>
<a name="ln2000">	if (sc-&gt;sc_tx_timer &gt; 0 &amp;&amp; --sc-&gt;sc_tx_timer == 0) {</a>
<a name="ln2001">		device_printf(sc-&gt;sc_dev, &quot;device timeout\n&quot;);</a>
<a name="ln2002">		rt2860_stop_locked(sc);</a>
<a name="ln2003">		rt2860_init_locked(sc);</a>
<a name="ln2004">		counter_u64_add(sc-&gt;sc_ic.ic_oerrors, 1);</a>
<a name="ln2005">		return;</a>
<a name="ln2006">	}</a>
<a name="ln2007">	callout_reset(&amp;sc-&gt;watchdog_ch, hz, rt2860_watchdog, sc);</a>
<a name="ln2008">}</a>
<a name="ln2009"> </a>
<a name="ln2010">static void</a>
<a name="ln2011">rt2860_parent(struct ieee80211com *ic)</a>
<a name="ln2012">{</a>
<a name="ln2013">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2014">	int startall = 0;</a>
<a name="ln2015"> </a>
<a name="ln2016">	RAL_LOCK(sc);</a>
<a name="ln2017">	if (ic-&gt;ic_nrunning&gt; 0) {</a>
<a name="ln2018">		if (!(sc-&gt;sc_flags &amp; RT2860_RUNNING)) {</a>
<a name="ln2019">			rt2860_init_locked(sc);</a>
<a name="ln2020">			startall = 1;</a>
<a name="ln2021">		} else</a>
<a name="ln2022">			rt2860_update_promisc(ic);</a>
<a name="ln2023">	} else if (sc-&gt;sc_flags &amp; RT2860_RUNNING)</a>
<a name="ln2024">		rt2860_stop_locked(sc);</a>
<a name="ln2025">	RAL_UNLOCK(sc);</a>
<a name="ln2026">	if (startall)</a>
<a name="ln2027">		ieee80211_start_all(ic);</a>
<a name="ln2028">}</a>
<a name="ln2029"> </a>
<a name="ln2030">/*</a>
<a name="ln2031"> * Reading and writing from/to the BBP is different from RT2560 and RT2661.</a>
<a name="ln2032"> * We access the BBP through the 8051 microcontroller unit which means that</a>
<a name="ln2033"> * the microcode must be loaded first.</a>
<a name="ln2034"> */</a>
<a name="ln2035">void</a>
<a name="ln2036">rt2860_mcu_bbp_write(struct rt2860_softc *sc, uint8_t reg, uint8_t val)</a>
<a name="ln2037">{</a>
<a name="ln2038">	int ntries;</a>
<a name="ln2039"> </a>
<a name="ln2040">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2041">		if (!(RAL_READ(sc, RT2860_H2M_BBPAGENT) &amp; RT2860_BBP_CSR_KICK))</a>
<a name="ln2042">			break;</a>
<a name="ln2043">		DELAY(1);</a>
<a name="ln2044">	}</a>
<a name="ln2045">	if (ntries == 100) {</a>
<a name="ln2046">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2047">			&quot;could not write to BBP through MCU\n&quot;);</a>
<a name="ln2048">		return;</a>
<a name="ln2049">	}</a>
<a name="ln2050"> </a>
<a name="ln2051">	RAL_WRITE(sc, RT2860_H2M_BBPAGENT, RT2860_BBP_RW_PARALLEL |</a>
<a name="ln2052">	    RT2860_BBP_CSR_KICK | reg &lt;&lt; 8 | val);</a>
<a name="ln2053">	RAL_BARRIER_WRITE(sc);</a>
<a name="ln2054"> </a>
<a name="ln2055">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BBP, 0, 0);</a>
<a name="ln2056">	DELAY(1000);</a>
<a name="ln2057">}</a>
<a name="ln2058"> </a>
<a name="ln2059">uint8_t</a>
<a name="ln2060">rt2860_mcu_bbp_read(struct rt2860_softc *sc, uint8_t reg)</a>
<a name="ln2061">{</a>
<a name="ln2062">	uint32_t val;</a>
<a name="ln2063">	int ntries;</a>
<a name="ln2064"> </a>
<a name="ln2065">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2066">		if (!(RAL_READ(sc, RT2860_H2M_BBPAGENT) &amp; RT2860_BBP_CSR_KICK))</a>
<a name="ln2067">			break;</a>
<a name="ln2068">		DELAY(1);</a>
<a name="ln2069">	}</a>
<a name="ln2070">	if (ntries == 100) {</a>
<a name="ln2071">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2072">		    &quot;could not read from BBP through MCU\n&quot;);</a>
<a name="ln2073">		return 0;</a>
<a name="ln2074">	}</a>
<a name="ln2075"> </a>
<a name="ln2076">	RAL_WRITE(sc, RT2860_H2M_BBPAGENT, RT2860_BBP_RW_PARALLEL |</a>
<a name="ln2077">	    RT2860_BBP_CSR_KICK | RT2860_BBP_CSR_READ | reg &lt;&lt; 8);</a>
<a name="ln2078">	RAL_BARRIER_WRITE(sc);</a>
<a name="ln2079"> </a>
<a name="ln2080">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_BBP, 0, 0);</a>
<a name="ln2081">	DELAY(1000);</a>
<a name="ln2082"> </a>
<a name="ln2083">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2084">		val = RAL_READ(sc, RT2860_H2M_BBPAGENT);</a>
<a name="ln2085">		if (!(val &amp; RT2860_BBP_CSR_KICK))</a>
<a name="ln2086">			return val &amp; 0xff;</a>
<a name="ln2087">		DELAY(1);</a>
<a name="ln2088">	}</a>
<a name="ln2089">	device_printf(sc-&gt;sc_dev, &quot;could not read from BBP through MCU\n&quot;);</a>
<a name="ln2090"> </a>
<a name="ln2091">	return 0;</a>
<a name="ln2092">}</a>
<a name="ln2093"> </a>
<a name="ln2094">/*</a>
<a name="ln2095"> * Write to one of the 4 programmable 24-bit RF registers.</a>
<a name="ln2096"> */</a>
<a name="ln2097">static void</a>
<a name="ln2098">rt2860_rf_write(struct rt2860_softc *sc, uint8_t reg, uint32_t val)</a>
<a name="ln2099">{</a>
<a name="ln2100">	uint32_t tmp;</a>
<a name="ln2101">	int ntries;</a>
<a name="ln2102"> </a>
<a name="ln2103">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2104">		if (!(RAL_READ(sc, RT2860_RF_CSR_CFG0) &amp; RT2860_RF_REG_CTRL))</a>
<a name="ln2105">			break;</a>
<a name="ln2106">		DELAY(1);</a>
<a name="ln2107">	}</a>
<a name="ln2108">	if (ntries == 100) {</a>
<a name="ln2109">		device_printf(sc-&gt;sc_dev, &quot;could not write to RF\n&quot;);</a>
<a name="ln2110">		return;</a>
<a name="ln2111">	}</a>
<a name="ln2112"> </a>
<a name="ln2113">	/* RF registers are 24-bit on the RT2860 */</a>
<a name="ln2114">	tmp = RT2860_RF_REG_CTRL | 24 &lt;&lt; RT2860_RF_REG_WIDTH_SHIFT |</a>
<a name="ln2115">	    (val &amp; 0x3fffff) &lt;&lt; 2 | (reg &amp; 3);</a>
<a name="ln2116">	RAL_WRITE(sc, RT2860_RF_CSR_CFG0, tmp);</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119">static uint8_t</a>
<a name="ln2120">rt3090_rf_read(struct rt2860_softc *sc, uint8_t reg)</a>
<a name="ln2121">{</a>
<a name="ln2122">	uint32_t tmp;</a>
<a name="ln2123">	int ntries;</a>
<a name="ln2124"> </a>
<a name="ln2125">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2126">		if (!(RAL_READ(sc, RT3070_RF_CSR_CFG) &amp; RT3070_RF_KICK))</a>
<a name="ln2127">			break;</a>
<a name="ln2128">		DELAY(1);</a>
<a name="ln2129">	}</a>
<a name="ln2130">	if (ntries == 100) {</a>
<a name="ln2131">		device_printf(sc-&gt;sc_dev, &quot;could not read RF register\n&quot;);</a>
<a name="ln2132">		return 0xff;</a>
<a name="ln2133">	}</a>
<a name="ln2134">	tmp = RT3070_RF_KICK | reg &lt;&lt; 8;</a>
<a name="ln2135">	RAL_WRITE(sc, RT3070_RF_CSR_CFG, tmp);</a>
<a name="ln2136"> </a>
<a name="ln2137">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2138">		tmp = RAL_READ(sc, RT3070_RF_CSR_CFG);</a>
<a name="ln2139">		if (!(tmp &amp; RT3070_RF_KICK))</a>
<a name="ln2140">			break;</a>
<a name="ln2141">		DELAY(1);</a>
<a name="ln2142">	}</a>
<a name="ln2143">	if (ntries == 100) {</a>
<a name="ln2144">		device_printf(sc-&gt;sc_dev, &quot;could not read RF register\n&quot;);</a>
<a name="ln2145">		return 0xff;</a>
<a name="ln2146">	}</a>
<a name="ln2147">	return tmp &amp; 0xff;</a>
<a name="ln2148">}</a>
<a name="ln2149"> </a>
<a name="ln2150">void</a>
<a name="ln2151">rt3090_rf_write(struct rt2860_softc *sc, uint8_t reg, uint8_t val)</a>
<a name="ln2152">{</a>
<a name="ln2153">	uint32_t tmp;</a>
<a name="ln2154">	int ntries;</a>
<a name="ln2155"> </a>
<a name="ln2156">	for (ntries = 0; ntries &lt; 10; ntries++) {</a>
<a name="ln2157">		if (!(RAL_READ(sc, RT3070_RF_CSR_CFG) &amp; RT3070_RF_KICK))</a>
<a name="ln2158">			break;</a>
<a name="ln2159">		DELAY(10);</a>
<a name="ln2160">	}</a>
<a name="ln2161">	if (ntries == 10) {</a>
<a name="ln2162">		device_printf(sc-&gt;sc_dev, &quot;could not write to RF\n&quot;);</a>
<a name="ln2163">		return;</a>
<a name="ln2164">	}</a>
<a name="ln2165"> </a>
<a name="ln2166">	tmp = RT3070_RF_WRITE | RT3070_RF_KICK | reg &lt;&lt; 8 | val;</a>
<a name="ln2167">	RAL_WRITE(sc, RT3070_RF_CSR_CFG, tmp);</a>
<a name="ln2168">}</a>
<a name="ln2169"> </a>
<a name="ln2170">/*</a>
<a name="ln2171"> * Send a command to the 8051 microcontroller unit.</a>
<a name="ln2172"> */</a>
<a name="ln2173">int</a>
<a name="ln2174">rt2860_mcu_cmd(struct rt2860_softc *sc, uint8_t cmd, uint16_t arg, int wait)</a>
<a name="ln2175">{</a>
<a name="ln2176">	int slot, ntries;</a>
<a name="ln2177">	uint32_t tmp;</a>
<a name="ln2178">	uint8_t cid;</a>
<a name="ln2179"> </a>
<a name="ln2180">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2181">		if (!(RAL_READ(sc, RT2860_H2M_MAILBOX) &amp; RT2860_H2M_BUSY))</a>
<a name="ln2182">			break;</a>
<a name="ln2183">		DELAY(2);</a>
<a name="ln2184">	}</a>
<a name="ln2185">	if (ntries == 100)</a>
<a name="ln2186">		return EIO;</a>
<a name="ln2187"> </a>
<a name="ln2188">	cid = wait ? cmd : RT2860_TOKEN_NO_INTR;</a>
<a name="ln2189">	RAL_WRITE(sc, RT2860_H2M_MAILBOX, RT2860_H2M_BUSY | cid &lt;&lt; 16 | arg);</a>
<a name="ln2190">	RAL_BARRIER_WRITE(sc);</a>
<a name="ln2191">	RAL_WRITE(sc, RT2860_HOST_CMD, cmd);</a>
<a name="ln2192"> </a>
<a name="ln2193">	if (!wait)</a>
<a name="ln2194">		return 0;</a>
<a name="ln2195">	/* wait for the command to complete */</a>
<a name="ln2196">	for (ntries = 0; ntries &lt; 200; ntries++) {</a>
<a name="ln2197">		tmp = RAL_READ(sc, RT2860_H2M_MAILBOX_CID);</a>
<a name="ln2198">		/* find the command slot */</a>
<a name="ln2199">		for (slot = 0; slot &lt; 4; slot++, tmp &gt;&gt;= 8)</a>
<a name="ln2200">			if ((tmp &amp; 0xff) == cid)</a>
<a name="ln2201">				break;</a>
<a name="ln2202">		if (slot &lt; 4)</a>
<a name="ln2203">			break;</a>
<a name="ln2204">		DELAY(100);</a>
<a name="ln2205">	}</a>
<a name="ln2206">	if (ntries == 200) {</a>
<a name="ln2207">		/* clear command and status */</a>
<a name="ln2208">		RAL_WRITE(sc, RT2860_H2M_MAILBOX_STATUS, 0xffffffff);</a>
<a name="ln2209">		RAL_WRITE(sc, RT2860_H2M_MAILBOX_CID, 0xffffffff);</a>
<a name="ln2210">		return ETIMEDOUT;</a>
<a name="ln2211">	}</a>
<a name="ln2212">	/* get command status (1 means success) */</a>
<a name="ln2213">	tmp = RAL_READ(sc, RT2860_H2M_MAILBOX_STATUS);</a>
<a name="ln2214">	tmp = (tmp &gt;&gt; (slot * 8)) &amp; 0xff;</a>
<a name="ln2215">	DPRINTF((&quot;MCU command=0x%02x slot=%d status=0x%02x\n&quot;,</a>
<a name="ln2216">	    cmd, slot, tmp));</a>
<a name="ln2217">	/* clear command and status */</a>
<a name="ln2218">	RAL_WRITE(sc, RT2860_H2M_MAILBOX_STATUS, 0xffffffff);</a>
<a name="ln2219">	RAL_WRITE(sc, RT2860_H2M_MAILBOX_CID, 0xffffffff);</a>
<a name="ln2220">	return (tmp == 1) ? 0 : EIO;</a>
<a name="ln2221">}</a>
<a name="ln2222"> </a>
<a name="ln2223">static void</a>
<a name="ln2224">rt2860_enable_mrr(struct rt2860_softc *sc)</a>
<a name="ln2225">{</a>
<a name="ln2226">#define CCK(mcs)	(mcs)</a>
<a name="ln2227">#define OFDM(mcs)	(1 &lt;&lt; 3 | (mcs))</a>
<a name="ln2228">	RAL_WRITE(sc, RT2860_LG_FBK_CFG0,</a>
<a name="ln2229">	    OFDM(6) &lt;&lt; 28 |	/* 54-&gt;48 */</a>
<a name="ln2230">	    OFDM(5) &lt;&lt; 24 |	/* 48-&gt;36 */</a>
<a name="ln2231">	    OFDM(4) &lt;&lt; 20 |	/* 36-&gt;24 */</a>
<a name="ln2232">	    OFDM(3) &lt;&lt; 16 |	/* 24-&gt;18 */</a>
<a name="ln2233">	    OFDM(2) &lt;&lt; 12 |	/* 18-&gt;12 */</a>
<a name="ln2234">	    OFDM(1) &lt;&lt;  8 |	/* 12-&gt; 9 */</a>
<a name="ln2235">	    OFDM(0) &lt;&lt;  4 |	/*  9-&gt; 6 */</a>
<a name="ln2236">	    OFDM(0));		/*  6-&gt; 6 */</a>
<a name="ln2237"> </a>
<a name="ln2238">	RAL_WRITE(sc, RT2860_LG_FBK_CFG1,</a>
<a name="ln2239">	    CCK(2) &lt;&lt; 12 |	/* 11-&gt;5.5 */</a>
<a name="ln2240">	    CCK(1) &lt;&lt;  8 |	/* 5.5-&gt; 2 */</a>
<a name="ln2241">	    CCK(0) &lt;&lt;  4 |	/*   2-&gt; 1 */</a>
<a name="ln2242">	    CCK(0));		/*   1-&gt; 1 */</a>
<a name="ln2243">#undef OFDM</a>
<a name="ln2244">#undef CCK</a>
<a name="ln2245">}</a>
<a name="ln2246"> </a>
<a name="ln2247">static void</a>
<a name="ln2248">rt2860_set_txpreamble(struct rt2860_softc *sc)</a>
<a name="ln2249">{</a>
<a name="ln2250">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2251">	uint32_t tmp;</a>
<a name="ln2252"> </a>
<a name="ln2253">	tmp = RAL_READ(sc, RT2860_AUTO_RSP_CFG);</a>
<a name="ln2254">	tmp &amp;= ~RT2860_CCK_SHORT_EN;</a>
<a name="ln2255">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE)</a>
<a name="ln2256">		tmp |= RT2860_CCK_SHORT_EN;</a>
<a name="ln2257">	RAL_WRITE(sc, RT2860_AUTO_RSP_CFG, tmp);</a>
<a name="ln2258">}</a>
<a name="ln2259"> </a>
<a name="ln2260">void</a>
<a name="ln2261">rt2860_set_basicrates(struct rt2860_softc *sc,</a>
<a name="ln2262">    const struct ieee80211_rateset *rs)</a>
<a name="ln2263">{</a>
<a name="ln2264">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2265">	uint32_t mask = 0;</a>
<a name="ln2266">	uint8_t rate;</a>
<a name="ln2267">	int i;</a>
<a name="ln2268"> </a>
<a name="ln2269">	for (i = 0; i &lt; rs-&gt;rs_nrates; i++) {</a>
<a name="ln2270">		rate = rs-&gt;rs_rates[i];</a>
<a name="ln2271"> </a>
<a name="ln2272">		if (!(rate &amp; IEEE80211_RATE_BASIC))</a>
<a name="ln2273">			continue;</a>
<a name="ln2274"> </a>
<a name="ln2275">		mask |= 1 &lt;&lt; ieee80211_legacy_rate_lookup(ic-&gt;ic_rt,</a>
<a name="ln2276">		    IEEE80211_RV(rate));</a>
<a name="ln2277">	}</a>
<a name="ln2278"> </a>
<a name="ln2279">	RAL_WRITE(sc, RT2860_LEGACY_BASIC_RATE, mask);</a>
<a name="ln2280">}</a>
<a name="ln2281"> </a>
<a name="ln2282">static void</a>
<a name="ln2283">rt2860_scan_start(struct ieee80211com *ic)</a>
<a name="ln2284">{</a>
<a name="ln2285">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2286">	uint32_t tmp;</a>
<a name="ln2287"> </a>
<a name="ln2288">	tmp = RAL_READ(sc, RT2860_BCN_TIME_CFG);</a>
<a name="ln2289">	RAL_WRITE(sc, RT2860_BCN_TIME_CFG,</a>
<a name="ln2290">	    tmp &amp; ~(RT2860_BCN_TX_EN | RT2860_TSF_TIMER_EN |</a>
<a name="ln2291">	    RT2860_TBTT_TIMER_EN));</a>
<a name="ln2292">	rt2860_set_gp_timer(sc, 0);</a>
<a name="ln2293">}</a>
<a name="ln2294"> </a>
<a name="ln2295">static void</a>
<a name="ln2296">rt2860_scan_end(struct ieee80211com *ic)</a>
<a name="ln2297">{</a>
<a name="ln2298">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2299">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln2300"> </a>
<a name="ln2301">	if (vap-&gt;iv_state == IEEE80211_S_RUN) {</a>
<a name="ln2302">		rt2860_enable_tsf_sync(sc);</a>
<a name="ln2303">		rt2860_set_gp_timer(sc, 500);</a>
<a name="ln2304">	}</a>
<a name="ln2305">}</a>
<a name="ln2306"> </a>
<a name="ln2307">static void</a>
<a name="ln2308">rt2860_getradiocaps(struct ieee80211com *ic, int maxchans, int *nchans,</a>
<a name="ln2309">    struct ieee80211_channel chans[])</a>
<a name="ln2310">{</a>
<a name="ln2311">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2312">	uint8_t bands[IEEE80211_MODE_BYTES];</a>
<a name="ln2313"> </a>
<a name="ln2314">	memset(bands, 0, sizeof(bands));</a>
<a name="ln2315">	setbit(bands, IEEE80211_MODE_11B);</a>
<a name="ln2316">	setbit(bands, IEEE80211_MODE_11G);</a>
<a name="ln2317">	ieee80211_add_channel_list_2ghz(chans, maxchans, nchans,</a>
<a name="ln2318">	    rt2860_chan_2ghz, nitems(rt2860_chan_2ghz), bands, 0);</a>
<a name="ln2319"> </a>
<a name="ln2320">	if (sc-&gt;rf_rev == RT2860_RF_2750 || sc-&gt;rf_rev == RT2860_RF_2850) {</a>
<a name="ln2321">		setbit(bands, IEEE80211_MODE_11A);</a>
<a name="ln2322">		ieee80211_add_channel_list_5ghz(chans, maxchans, nchans,</a>
<a name="ln2323">		    rt2860_chan_5ghz, nitems(rt2860_chan_5ghz), bands, 0);</a>
<a name="ln2324">	}</a>
<a name="ln2325">}</a>
<a name="ln2326"> </a>
<a name="ln2327">static void</a>
<a name="ln2328">rt2860_set_channel(struct ieee80211com *ic)</a>
<a name="ln2329">{</a>
<a name="ln2330">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2331"> </a>
<a name="ln2332">	RAL_LOCK(sc);</a>
<a name="ln2333">	rt2860_switch_chan(sc, ic-&gt;ic_curchan);</a>
<a name="ln2334">	RAL_UNLOCK(sc);</a>
<a name="ln2335">}</a>
<a name="ln2336"> </a>
<a name="ln2337">static void</a>
<a name="ln2338">rt2860_select_chan_group(struct rt2860_softc *sc, int group)</a>
<a name="ln2339">{</a>
<a name="ln2340">	uint32_t tmp;</a>
<a name="ln2341">	uint8_t agc;</a>
<a name="ln2342"> </a>
<a name="ln2343">	rt2860_mcu_bbp_write(sc, 62, 0x37 - sc-&gt;lna[group]);</a>
<a name="ln2344">	rt2860_mcu_bbp_write(sc, 63, 0x37 - sc-&gt;lna[group]);</a>
<a name="ln2345">	rt2860_mcu_bbp_write(sc, 64, 0x37 - sc-&gt;lna[group]);</a>
<a name="ln2346">	rt2860_mcu_bbp_write(sc, 86, 0x00);</a>
<a name="ln2347"> </a>
<a name="ln2348">	if (group == 0) {</a>
<a name="ln2349">		if (sc-&gt;ext_2ghz_lna) {</a>
<a name="ln2350">			rt2860_mcu_bbp_write(sc, 82, 0x62);</a>
<a name="ln2351">			rt2860_mcu_bbp_write(sc, 75, 0x46);</a>
<a name="ln2352">		} else {</a>
<a name="ln2353">			rt2860_mcu_bbp_write(sc, 82, 0x84);</a>
<a name="ln2354">			rt2860_mcu_bbp_write(sc, 75, 0x50);</a>
<a name="ln2355">		}</a>
<a name="ln2356">	} else {</a>
<a name="ln2357">		if (sc-&gt;ext_5ghz_lna) {</a>
<a name="ln2358">			rt2860_mcu_bbp_write(sc, 82, 0xf2);</a>
<a name="ln2359">			rt2860_mcu_bbp_write(sc, 75, 0x46);</a>
<a name="ln2360">		} else {</a>
<a name="ln2361">			rt2860_mcu_bbp_write(sc, 82, 0xf2);</a>
<a name="ln2362">			rt2860_mcu_bbp_write(sc, 75, 0x50);</a>
<a name="ln2363">		}</a>
<a name="ln2364">	}</a>
<a name="ln2365"> </a>
<a name="ln2366">	tmp = RAL_READ(sc, RT2860_TX_BAND_CFG);</a>
<a name="ln2367">	tmp &amp;= ~(RT2860_5G_BAND_SEL_N | RT2860_5G_BAND_SEL_P);</a>
<a name="ln2368">	tmp |= (group == 0) ? RT2860_5G_BAND_SEL_N : RT2860_5G_BAND_SEL_P;</a>
<a name="ln2369">	RAL_WRITE(sc, RT2860_TX_BAND_CFG, tmp);</a>
<a name="ln2370"> </a>
<a name="ln2371">	/* enable appropriate Power Amplifiers and Low Noise Amplifiers */</a>
<a name="ln2372">	tmp = RT2860_RFTR_EN | RT2860_TRSW_EN | RT2860_LNA_PE0_EN;</a>
<a name="ln2373">	if (sc-&gt;nrxchains &gt; 1)</a>
<a name="ln2374">		tmp |= RT2860_LNA_PE1_EN;</a>
<a name="ln2375">	if (sc-&gt;mac_ver == 0x3593 &amp;&amp; sc-&gt;nrxchains &gt; 2)</a>
<a name="ln2376">		tmp |= RT3593_LNA_PE2_EN;</a>
<a name="ln2377">	if (group == 0) {	/* 2GHz */</a>
<a name="ln2378">		tmp |= RT2860_PA_PE_G0_EN;</a>
<a name="ln2379">		if (sc-&gt;ntxchains &gt; 1)</a>
<a name="ln2380">			tmp |= RT2860_PA_PE_G1_EN;</a>
<a name="ln2381">		if (sc-&gt;mac_ver == 0x3593 &amp;&amp; sc-&gt;ntxchains &gt; 2)</a>
<a name="ln2382">			tmp |= RT3593_PA_PE_G2_EN;</a>
<a name="ln2383">	} else {		/* 5GHz */</a>
<a name="ln2384">		tmp |= RT2860_PA_PE_A0_EN;</a>
<a name="ln2385">		if (sc-&gt;ntxchains &gt; 1)</a>
<a name="ln2386">			tmp |= RT2860_PA_PE_A1_EN;</a>
<a name="ln2387">		if (sc-&gt;mac_ver == 0x3593 &amp;&amp; sc-&gt;ntxchains &gt; 2)</a>
<a name="ln2388">			tmp |= RT3593_PA_PE_A2_EN;</a>
<a name="ln2389">	}</a>
<a name="ln2390">	RAL_WRITE(sc, RT2860_TX_PIN_CFG, tmp);</a>
<a name="ln2391"> </a>
<a name="ln2392">	if (sc-&gt;mac_ver == 0x3593) {</a>
<a name="ln2393">		tmp = RAL_READ(sc, RT2860_GPIO_CTRL);</a>
<a name="ln2394">		if (sc-&gt;sc_flags &amp; RT2860_PCIE) {</a>
<a name="ln2395">			tmp &amp;= ~0x01010000;</a>
<a name="ln2396">			if (group == 0)</a>
<a name="ln2397">				tmp |= 0x00010000;</a>
<a name="ln2398">		} else {</a>
<a name="ln2399">			tmp &amp;= ~0x00008080;</a>
<a name="ln2400">			if (group == 0)</a>
<a name="ln2401">				tmp |= 0x00000080;</a>
<a name="ln2402">		}</a>
<a name="ln2403">		tmp = (tmp &amp; ~0x00001000) | 0x00000010;</a>
<a name="ln2404">		RAL_WRITE(sc, RT2860_GPIO_CTRL, tmp);</a>
<a name="ln2405">	}</a>
<a name="ln2406"> </a>
<a name="ln2407">	/* set initial AGC value */</a>
<a name="ln2408">	if (group == 0) {	/* 2GHz band */</a>
<a name="ln2409">		if (sc-&gt;mac_ver &gt;= 0x3071)</a>
<a name="ln2410">			agc = 0x1c + sc-&gt;lna[0] * 2;</a>
<a name="ln2411">		else</a>
<a name="ln2412">			agc = 0x2e + sc-&gt;lna[0];</a>
<a name="ln2413">	} else {		/* 5GHz band */</a>
<a name="ln2414">		agc = 0x32 + (sc-&gt;lna[group] * 5) / 3;</a>
<a name="ln2415">	}</a>
<a name="ln2416">	rt2860_mcu_bbp_write(sc, 66, agc);</a>
<a name="ln2417"> </a>
<a name="ln2418">	DELAY(1000);</a>
<a name="ln2419">}</a>
<a name="ln2420"> </a>
<a name="ln2421">static void</a>
<a name="ln2422">rt2860_set_chan(struct rt2860_softc *sc, u_int chan)</a>
<a name="ln2423">{</a>
<a name="ln2424">	const struct rfprog *rfprog = rt2860_rf2850;</a>
<a name="ln2425">	uint32_t r2, r3, r4;</a>
<a name="ln2426">	int8_t txpow1, txpow2;</a>
<a name="ln2427">	u_int i;</a>
<a name="ln2428"> </a>
<a name="ln2429">	/* find the settings for this channel (we know it exists) */</a>
<a name="ln2430">	for (i = 0; rfprog[i].chan != chan; i++);</a>
<a name="ln2431"> </a>
<a name="ln2432">	r2 = rfprog[i].r2;</a>
<a name="ln2433">	if (sc-&gt;ntxchains == 1)</a>
<a name="ln2434">		r2 |= 1 &lt;&lt; 12;		/* 1T: disable Tx chain 2 */</a>
<a name="ln2435">	if (sc-&gt;nrxchains == 1)</a>
<a name="ln2436">		r2 |= 1 &lt;&lt; 15 | 1 &lt;&lt; 4;	/* 1R: disable Rx chains 2 &amp; 3 */</a>
<a name="ln2437">	else if (sc-&gt;nrxchains == 2)</a>
<a name="ln2438">		r2 |= 1 &lt;&lt; 4;		/* 2R: disable Rx chain 3 */</a>
<a name="ln2439"> </a>
<a name="ln2440">	/* use Tx power values from EEPROM */</a>
<a name="ln2441">	txpow1 = sc-&gt;txpow1[i];</a>
<a name="ln2442">	txpow2 = sc-&gt;txpow2[i];</a>
<a name="ln2443">	if (chan &gt; 14) {</a>
<a name="ln2444">		if (txpow1 &gt;= 0)</a>
<a name="ln2445">			txpow1 = txpow1 &lt;&lt; 1 | 1;</a>
<a name="ln2446">		else</a>
<a name="ln2447">			txpow1 = (7 + txpow1) &lt;&lt; 1;</a>
<a name="ln2448">		if (txpow2 &gt;= 0)</a>
<a name="ln2449">			txpow2 = txpow2 &lt;&lt; 1 | 1;</a>
<a name="ln2450">		else</a>
<a name="ln2451">			txpow2 = (7 + txpow2) &lt;&lt; 1;</a>
<a name="ln2452">	}</a>
<a name="ln2453">	r3 = rfprog[i].r3 | txpow1 &lt;&lt; 7;</a>
<a name="ln2454">	r4 = rfprog[i].r4 | sc-&gt;freq &lt;&lt; 13 | txpow2 &lt;&lt; 4;</a>
<a name="ln2455"> </a>
<a name="ln2456">	rt2860_rf_write(sc, RT2860_RF1, rfprog[i].r1);</a>
<a name="ln2457">	rt2860_rf_write(sc, RT2860_RF2, r2);</a>
<a name="ln2458">	rt2860_rf_write(sc, RT2860_RF3, r3);</a>
<a name="ln2459">	rt2860_rf_write(sc, RT2860_RF4, r4);</a>
<a name="ln2460"> </a>
<a name="ln2461">	DELAY(200);</a>
<a name="ln2462"> </a>
<a name="ln2463">	rt2860_rf_write(sc, RT2860_RF1, rfprog[i].r1);</a>
<a name="ln2464">	rt2860_rf_write(sc, RT2860_RF2, r2);</a>
<a name="ln2465">	rt2860_rf_write(sc, RT2860_RF3, r3 | 1);</a>
<a name="ln2466">	rt2860_rf_write(sc, RT2860_RF4, r4);</a>
<a name="ln2467"> </a>
<a name="ln2468">	DELAY(200);</a>
<a name="ln2469"> </a>
<a name="ln2470">	rt2860_rf_write(sc, RT2860_RF1, rfprog[i].r1);</a>
<a name="ln2471">	rt2860_rf_write(sc, RT2860_RF2, r2);</a>
<a name="ln2472">	rt2860_rf_write(sc, RT2860_RF3, r3);</a>
<a name="ln2473">	rt2860_rf_write(sc, RT2860_RF4, r4);</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">static void</a>
<a name="ln2477">rt3090_set_chan(struct rt2860_softc *sc, u_int chan)</a>
<a name="ln2478">{</a>
<a name="ln2479">	int8_t txpow1, txpow2;</a>
<a name="ln2480">	uint8_t rf;</a>
<a name="ln2481">	int i;</a>
<a name="ln2482"> </a>
<a name="ln2483">	/* RT3090 is 2GHz only */</a>
<a name="ln2484">	KASSERT(chan &gt;= 1 &amp;&amp; chan &lt;= 14, (&quot;chan %d not support&quot;, chan));</a>
<a name="ln2485"> </a>
<a name="ln2486">	/* find the settings for this channel (we know it exists) */</a>
<a name="ln2487">	for (i = 0; rt2860_rf2850[i].chan != chan; i++);</a>
<a name="ln2488"> </a>
<a name="ln2489">	/* use Tx power values from EEPROM */</a>
<a name="ln2490">	txpow1 = sc-&gt;txpow1[i];</a>
<a name="ln2491">	txpow2 = sc-&gt;txpow2[i];</a>
<a name="ln2492"> </a>
<a name="ln2493">	rt3090_rf_write(sc, 2, rt3090_freqs[i].n);</a>
<a name="ln2494">	rf = rt3090_rf_read(sc, 3);</a>
<a name="ln2495">	rf = (rf &amp; ~0x0f) | rt3090_freqs[i].k;</a>
<a name="ln2496">	rt3090_rf_write(sc, 3, rf);</a>
<a name="ln2497">	rf = rt3090_rf_read(sc, 6);</a>
<a name="ln2498">	rf = (rf &amp; ~0x03) | rt3090_freqs[i].r;</a>
<a name="ln2499">	rt3090_rf_write(sc, 6, rf);</a>
<a name="ln2500"> </a>
<a name="ln2501">	/* set Tx0 power */</a>
<a name="ln2502">	rf = rt3090_rf_read(sc, 12);</a>
<a name="ln2503">	rf = (rf &amp; ~0x1f) | txpow1;</a>
<a name="ln2504">	rt3090_rf_write(sc, 12, rf);</a>
<a name="ln2505"> </a>
<a name="ln2506">	/* set Tx1 power */</a>
<a name="ln2507">	rf = rt3090_rf_read(sc, 13);</a>
<a name="ln2508">	rf = (rf &amp; ~0x1f) | txpow2;</a>
<a name="ln2509">	rt3090_rf_write(sc, 13, rf);</a>
<a name="ln2510"> </a>
<a name="ln2511">	rf = rt3090_rf_read(sc, 1);</a>
<a name="ln2512">	rf &amp;= ~0xfc;</a>
<a name="ln2513">	if (sc-&gt;ntxchains == 1)</a>
<a name="ln2514">		rf |= RT3070_TX1_PD | RT3070_TX2_PD;</a>
<a name="ln2515">	else if (sc-&gt;ntxchains == 2)</a>
<a name="ln2516">		rf |= RT3070_TX2_PD;</a>
<a name="ln2517">	if (sc-&gt;nrxchains == 1)</a>
<a name="ln2518">		rf |= RT3070_RX1_PD | RT3070_RX2_PD;</a>
<a name="ln2519">	else if (sc-&gt;nrxchains == 2)</a>
<a name="ln2520">		rf |= RT3070_RX2_PD;</a>
<a name="ln2521">	rt3090_rf_write(sc, 1, rf);</a>
<a name="ln2522"> </a>
<a name="ln2523">	/* set RF offset */</a>
<a name="ln2524">	rf = rt3090_rf_read(sc, 23);</a>
<a name="ln2525">	rf = (rf &amp; ~0x7f) | sc-&gt;freq;</a>
<a name="ln2526">	rt3090_rf_write(sc, 23, rf);</a>
<a name="ln2527"> </a>
<a name="ln2528">	/* program RF filter */</a>
<a name="ln2529">	rf = rt3090_rf_read(sc, 24);	/* Tx */</a>
<a name="ln2530">	rf = (rf &amp; ~0x3f) | sc-&gt;rf24_20mhz;</a>
<a name="ln2531">	rt3090_rf_write(sc, 24, rf);</a>
<a name="ln2532">	rf = rt3090_rf_read(sc, 31);	/* Rx */</a>
<a name="ln2533">	rf = (rf &amp; ~0x3f) | sc-&gt;rf24_20mhz;</a>
<a name="ln2534">	rt3090_rf_write(sc, 31, rf);</a>
<a name="ln2535"> </a>
<a name="ln2536">	/* enable RF tuning */</a>
<a name="ln2537">	rf = rt3090_rf_read(sc, 7);</a>
<a name="ln2538">	rt3090_rf_write(sc, 7, rf | RT3070_TUNE);</a>
<a name="ln2539">}</a>
<a name="ln2540"> </a>
<a name="ln2541">static void</a>
<a name="ln2542">rt5390_set_chan(struct rt2860_softc *sc, u_int chan)</a>
<a name="ln2543">{</a>
<a name="ln2544">	uint8_t h20mhz, rf, tmp;</a>
<a name="ln2545">	int8_t txpow1, txpow2;</a>
<a name="ln2546">	int i;</a>
<a name="ln2547"> </a>
<a name="ln2548">	/* RT5390 is 2GHz only */</a>
<a name="ln2549">	KASSERT(chan &gt;= 1 &amp;&amp; chan &lt;= 14, (&quot;chan %d not support&quot;, chan));</a>
<a name="ln2550"> </a>
<a name="ln2551">	/* find the settings for this channel (we know it exists) */</a>
<a name="ln2552">	for (i = 0; rt2860_rf2850[i].chan != chan; i++);</a>
<a name="ln2553"> </a>
<a name="ln2554">	/* use Tx power values from EEPROM */</a>
<a name="ln2555">	txpow1 = sc-&gt;txpow1[i];</a>
<a name="ln2556">	txpow2 = sc-&gt;txpow2[i];</a>
<a name="ln2557"> </a>
<a name="ln2558">	rt3090_rf_write(sc, 8, rt3090_freqs[i].n);</a>
<a name="ln2559">	rt3090_rf_write(sc, 9, rt3090_freqs[i].k &amp; 0x0f);</a>
<a name="ln2560">	rf = rt3090_rf_read(sc, 11);</a>
<a name="ln2561">	rf = (rf &amp; ~0x03) | (rt3090_freqs[i].r &amp; 0x03);</a>
<a name="ln2562">	rt3090_rf_write(sc, 11, rf);</a>
<a name="ln2563"> </a>
<a name="ln2564">	rf = rt3090_rf_read(sc, 49);</a>
<a name="ln2565">	rf = (rf &amp; ~0x3f) | (txpow1 &amp; 0x3f);</a>
<a name="ln2566">	/* the valid range of the RF R49 is 0x00~0x27 */</a>
<a name="ln2567">	if ((rf &amp; 0x3f) &gt; 0x27)</a>
<a name="ln2568">		rf = (rf &amp; ~0x3f) | 0x27;</a>
<a name="ln2569">	rt3090_rf_write(sc, 49, rf);</a>
<a name="ln2570">	if (sc-&gt;mac_ver == 0x5392) {</a>
<a name="ln2571">		rf = rt3090_rf_read(sc, 50);</a>
<a name="ln2572">		rf = (rf &amp; ~0x3f) | (txpow2 &amp; 0x3f);</a>
<a name="ln2573">		/* the valid range of the RF R50 is 0x00~0x27 */</a>
<a name="ln2574">		if ((rf &amp; 0x3f) &gt; 0x27)</a>
<a name="ln2575">			rf = (rf &amp; ~0x3f) | 0x27;</a>
<a name="ln2576">		rt3090_rf_write(sc, 50, rf);</a>
<a name="ln2577">	}</a>
<a name="ln2578"> </a>
<a name="ln2579">	rf = rt3090_rf_read(sc, 1);</a>
<a name="ln2580">	rf |= RT3070_RF_BLOCK | RT3070_PLL_PD | RT3070_RX0_PD | RT3070_TX0_PD;</a>
<a name="ln2581">	if (sc-&gt;mac_ver == 0x5392)</a>
<a name="ln2582">		rf |= RT3070_RX1_PD | RT3070_TX1_PD;</a>
<a name="ln2583">	rt3090_rf_write(sc, 1, rf);</a>
<a name="ln2584"> </a>
<a name="ln2585">	rf = rt3090_rf_read(sc, 2);</a>
<a name="ln2586">	rt3090_rf_write(sc, 2, rf | RT3593_RESCAL);</a>
<a name="ln2587">	DELAY(1000);</a>
<a name="ln2588">	rt3090_rf_write(sc, 2, rf &amp; ~RT3593_RESCAL);</a>
<a name="ln2589"> </a>
<a name="ln2590">	rf = rt3090_rf_read(sc, 17);</a>
<a name="ln2591">	tmp = rf;</a>
<a name="ln2592">	rf = (rf &amp; ~0x7f) | (sc-&gt;freq &amp; 0x7f);</a>
<a name="ln2593">	rf = MIN(rf, 0x5f);</a>
<a name="ln2594">	if (tmp != rf)</a>
<a name="ln2595">		rt2860_mcu_cmd(sc, 0x74, (tmp &lt;&lt; 8 ) | rf, 0);</a>
<a name="ln2596">	</a>
<a name="ln2597">	if (sc-&gt;mac_ver == 0x5390) {</a>
<a name="ln2598">		if (chan &lt;= 4)</a>
<a name="ln2599">			rf = 0x73;</a>
<a name="ln2600">		else if (chan &gt;= 5 &amp;&amp; chan &lt;= 6)</a>
<a name="ln2601">			rf = 0x63;</a>
<a name="ln2602">		else if (chan &gt;= 7 &amp;&amp; chan &lt;= 10)</a>
<a name="ln2603">			rf = 0x53;</a>
<a name="ln2604">		else</a>
<a name="ln2605">			rf = 43;</a>
<a name="ln2606">		rt3090_rf_write(sc, 55, rf);</a>
<a name="ln2607"> </a>
<a name="ln2608">		if (chan == 1)</a>
<a name="ln2609">			rf = 0x0c;</a>
<a name="ln2610">		else if (chan == 2)</a>
<a name="ln2611">			rf = 0x0b;</a>
<a name="ln2612">		else if (chan == 3)</a>
<a name="ln2613">			rf = 0x0a;</a>
<a name="ln2614">		else if (chan &gt;= 4 &amp;&amp; chan &lt;= 6)</a>
<a name="ln2615">			rf = 0x09;</a>
<a name="ln2616">		else if (chan &gt;= 7 &amp;&amp; chan &lt;= 12)</a>
<a name="ln2617">			rf = 0x08;</a>
<a name="ln2618">		else if (chan == 13)</a>
<a name="ln2619">			rf = 0x07;</a>
<a name="ln2620">		else</a>
<a name="ln2621">			rf = 0x06;</a>
<a name="ln2622">		rt3090_rf_write(sc, 59, rf);</a>
<a name="ln2623">	}</a>
<a name="ln2624"> </a>
<a name="ln2625">	/* Tx/Rx h20M */</a>
<a name="ln2626">	h20mhz = (sc-&gt;rf24_20mhz &amp; 0x20) &gt;&gt; 5;</a>
<a name="ln2627">	rf = rt3090_rf_read(sc, 30);</a>
<a name="ln2628">	rf = (rf &amp; ~0x06) | (h20mhz &lt;&lt; 1) | (h20mhz &lt;&lt; 2);</a>
<a name="ln2629">	rt3090_rf_write(sc, 30, rf);</a>
<a name="ln2630"> </a>
<a name="ln2631">	/* Rx BB filter VCM */</a>
<a name="ln2632">	rf = rt3090_rf_read(sc, 30);</a>
<a name="ln2633">	rf = (rf &amp; ~0x18) | 0x10;</a>
<a name="ln2634">	rt3090_rf_write(sc, 30, rf);</a>
<a name="ln2635"> </a>
<a name="ln2636">	/* Initiate VCO calibration. */</a>
<a name="ln2637">	rf = rt3090_rf_read(sc, 3);</a>
<a name="ln2638">	rf |= RT3593_VCOCAL;</a>
<a name="ln2639">	rt3090_rf_write(sc, 3, rf);</a>
<a name="ln2640">}</a>
<a name="ln2641"> </a>
<a name="ln2642">static int</a>
<a name="ln2643">rt3090_rf_init(struct rt2860_softc *sc)</a>
<a name="ln2644">{</a>
<a name="ln2645">	uint32_t tmp;</a>
<a name="ln2646">	uint8_t rf, bbp;</a>
<a name="ln2647">	int i;</a>
<a name="ln2648"> </a>
<a name="ln2649">	rf = rt3090_rf_read(sc, 30);</a>
<a name="ln2650">	/* toggle RF R30 bit 7 */</a>
<a name="ln2651">	rt3090_rf_write(sc, 30, rf | 0x80);</a>
<a name="ln2652">	DELAY(1000);</a>
<a name="ln2653">	rt3090_rf_write(sc, 30, rf &amp; ~0x80);</a>
<a name="ln2654"> </a>
<a name="ln2655">	tmp = RAL_READ(sc, RT3070_LDO_CFG0);</a>
<a name="ln2656">	tmp &amp;= ~0x1f000000;</a>
<a name="ln2657">	if (sc-&gt;patch_dac &amp;&amp; sc-&gt;mac_rev &lt; 0x0211)</a>
<a name="ln2658">		tmp |= 0x0d000000;	/* 1.35V */</a>
<a name="ln2659">	else</a>
<a name="ln2660">		tmp |= 0x01000000;	/* 1.2V */</a>
<a name="ln2661">	RAL_WRITE(sc, RT3070_LDO_CFG0, tmp);</a>
<a name="ln2662"> </a>
<a name="ln2663">	/* patch LNA_PE_G1 */</a>
<a name="ln2664">	tmp = RAL_READ(sc, RT3070_GPIO_SWITCH);</a>
<a name="ln2665">	RAL_WRITE(sc, RT3070_GPIO_SWITCH, tmp &amp; ~0x20);</a>
<a name="ln2666"> </a>
<a name="ln2667">	/* initialize RF registers to default value */</a>
<a name="ln2668">	for (i = 0; i &lt; nitems(rt3090_def_rf); i++) {</a>
<a name="ln2669">		rt3090_rf_write(sc, rt3090_def_rf[i].reg,</a>
<a name="ln2670">		    rt3090_def_rf[i].val);</a>
<a name="ln2671">	}</a>
<a name="ln2672"> </a>
<a name="ln2673">	/* select 20MHz bandwidth */</a>
<a name="ln2674">	rt3090_rf_write(sc, 31, 0x14);</a>
<a name="ln2675"> </a>
<a name="ln2676">	rf = rt3090_rf_read(sc, 6);</a>
<a name="ln2677">	rt3090_rf_write(sc, 6, rf | 0x40);</a>
<a name="ln2678"> </a>
<a name="ln2679">	if (sc-&gt;mac_ver != 0x3593) {</a>
<a name="ln2680">		/* calibrate filter for 20MHz bandwidth */</a>
<a name="ln2681">		sc-&gt;rf24_20mhz = 0x1f;	/* default value */</a>
<a name="ln2682">		rt3090_filter_calib(sc, 0x07, 0x16, &amp;sc-&gt;rf24_20mhz);</a>
<a name="ln2683"> </a>
<a name="ln2684">		/* select 40MHz bandwidth */</a>
<a name="ln2685">		bbp = rt2860_mcu_bbp_read(sc, 4);</a>
<a name="ln2686">		rt2860_mcu_bbp_write(sc, 4, (bbp &amp; ~0x08) | 0x10);</a>
<a name="ln2687">		rf = rt3090_rf_read(sc, 31);</a>
<a name="ln2688">		rt3090_rf_write(sc, 31, rf | 0x20);</a>
<a name="ln2689"> </a>
<a name="ln2690">		/* calibrate filter for 40MHz bandwidth */</a>
<a name="ln2691">		sc-&gt;rf24_40mhz = 0x2f;	/* default value */</a>
<a name="ln2692">		rt3090_filter_calib(sc, 0x27, 0x19, &amp;sc-&gt;rf24_40mhz);</a>
<a name="ln2693"> </a>
<a name="ln2694">		/* go back to 20MHz bandwidth */</a>
<a name="ln2695">		bbp = rt2860_mcu_bbp_read(sc, 4);</a>
<a name="ln2696">		rt2860_mcu_bbp_write(sc, 4, bbp &amp; ~0x18);</a>
<a name="ln2697">	}</a>
<a name="ln2698">	if (sc-&gt;mac_rev &lt; 0x0211)</a>
<a name="ln2699">		rt3090_rf_write(sc, 27, 0x03);</a>
<a name="ln2700"> </a>
<a name="ln2701">	tmp = RAL_READ(sc, RT3070_OPT_14);</a>
<a name="ln2702">	RAL_WRITE(sc, RT3070_OPT_14, tmp | 1);</a>
<a name="ln2703"> </a>
<a name="ln2704">	if (sc-&gt;rf_rev == RT3070_RF_3020)</a>
<a name="ln2705">		rt3090_set_rx_antenna(sc, 0);</a>
<a name="ln2706"> </a>
<a name="ln2707">	bbp = rt2860_mcu_bbp_read(sc, 138);</a>
<a name="ln2708">	if (sc-&gt;mac_ver == 0x3593) {</a>
<a name="ln2709">		if (sc-&gt;ntxchains == 1)</a>
<a name="ln2710">			bbp |= 0x60;	/* turn off DAC1 and DAC2 */</a>
<a name="ln2711">		else if (sc-&gt;ntxchains == 2)</a>
<a name="ln2712">			bbp |= 0x40;	/* turn off DAC2 */</a>
<a name="ln2713">		if (sc-&gt;nrxchains == 1)</a>
<a name="ln2714">			bbp &amp;= ~0x06;	/* turn off ADC1 and ADC2 */</a>
<a name="ln2715">		else if (sc-&gt;nrxchains == 2)</a>
<a name="ln2716">			bbp &amp;= ~0x04;	/* turn off ADC2 */</a>
<a name="ln2717">	} else {</a>
<a name="ln2718">		if (sc-&gt;ntxchains == 1)</a>
<a name="ln2719">			bbp |= 0x20;	/* turn off DAC1 */</a>
<a name="ln2720">		if (sc-&gt;nrxchains == 1)</a>
<a name="ln2721">			bbp &amp;= ~0x02;	/* turn off ADC1 */</a>
<a name="ln2722">	}</a>
<a name="ln2723">	rt2860_mcu_bbp_write(sc, 138, bbp);</a>
<a name="ln2724"> </a>
<a name="ln2725">	rf = rt3090_rf_read(sc, 1);</a>
<a name="ln2726">	rf &amp;= ~(RT3070_RX0_PD | RT3070_TX0_PD);</a>
<a name="ln2727">	rf |= RT3070_RF_BLOCK | RT3070_RX1_PD | RT3070_TX1_PD;</a>
<a name="ln2728">	rt3090_rf_write(sc, 1, rf);</a>
<a name="ln2729"> </a>
<a name="ln2730">	rf = rt3090_rf_read(sc, 15);</a>
<a name="ln2731">	rt3090_rf_write(sc, 15, rf &amp; ~RT3070_TX_LO2);</a>
<a name="ln2732"> </a>
<a name="ln2733">	rf = rt3090_rf_read(sc, 17);</a>
<a name="ln2734">	rf &amp;= ~RT3070_TX_LO1;</a>
<a name="ln2735">	if (sc-&gt;mac_rev &gt;= 0x0211 &amp;&amp; !sc-&gt;ext_2ghz_lna)</a>
<a name="ln2736">		rf |= 0x20;	/* fix for long range Rx issue */</a>
<a name="ln2737">	if (sc-&gt;txmixgain_2ghz &gt;= 2)</a>
<a name="ln2738">		rf = (rf &amp; ~0x7) | sc-&gt;txmixgain_2ghz;</a>
<a name="ln2739">	rt3090_rf_write(sc, 17, rf);</a>
<a name="ln2740"> </a>
<a name="ln2741">	rf = rt3090_rf_read(sc, 20);</a>
<a name="ln2742">	rt3090_rf_write(sc, 20, rf &amp; ~RT3070_RX_LO1);</a>
<a name="ln2743"> </a>
<a name="ln2744">	rf = rt3090_rf_read(sc, 21);</a>
<a name="ln2745">	rt3090_rf_write(sc, 21, rf &amp; ~RT3070_RX_LO2);</a>
<a name="ln2746"> </a>
<a name="ln2747">	return (0);</a>
<a name="ln2748">}</a>
<a name="ln2749"> </a>
<a name="ln2750">static void</a>
<a name="ln2751">rt5390_rf_init(struct rt2860_softc *sc)</a>
<a name="ln2752">{</a>
<a name="ln2753">	uint8_t rf, bbp;</a>
<a name="ln2754">	int i;</a>
<a name="ln2755"> </a>
<a name="ln2756">	rf = rt3090_rf_read(sc, 2);</a>
<a name="ln2757">	/* Toggle RF R2 bit 7. */</a>
<a name="ln2758">	rt3090_rf_write(sc, 2, rf | RT3593_RESCAL);</a>
<a name="ln2759">	DELAY(1000);</a>
<a name="ln2760">	rt3090_rf_write(sc, 2, rf &amp; ~RT3593_RESCAL);</a>
<a name="ln2761"> </a>
<a name="ln2762">	/* Initialize RF registers to default value. */</a>
<a name="ln2763">	if (sc-&gt;mac_ver == 0x5392) {</a>
<a name="ln2764">		for (i = 0; i &lt; nitems(rt5392_def_rf); i++) {</a>
<a name="ln2765">			rt3090_rf_write(sc, rt5392_def_rf[i].reg,</a>
<a name="ln2766">			    rt5392_def_rf[i].val);</a>
<a name="ln2767">		}</a>
<a name="ln2768">	} else {</a>
<a name="ln2769">		for (i = 0; i &lt; nitems(rt5390_def_rf); i++) {</a>
<a name="ln2770">			rt3090_rf_write(sc, rt5390_def_rf[i].reg,</a>
<a name="ln2771">			    rt5390_def_rf[i].val);</a>
<a name="ln2772">		}</a>
<a name="ln2773">	}</a>
<a name="ln2774"> </a>
<a name="ln2775">	sc-&gt;rf24_20mhz = 0x1f;</a>
<a name="ln2776">	sc-&gt;rf24_40mhz = 0x2f;</a>
<a name="ln2777"> </a>
<a name="ln2778">	if (sc-&gt;mac_rev &lt; 0x0211)</a>
<a name="ln2779">		rt3090_rf_write(sc, 27, 0x03);</a>
<a name="ln2780"> </a>
<a name="ln2781">	/* Set led open drain enable. */</a>
<a name="ln2782">	RAL_WRITE(sc, RT3070_OPT_14, RAL_READ(sc, RT3070_OPT_14) | 1);</a>
<a name="ln2783"> </a>
<a name="ln2784">	RAL_WRITE(sc, RT2860_TX_SW_CFG1, 0);</a>
<a name="ln2785">	RAL_WRITE(sc, RT2860_TX_SW_CFG2, 0);</a>
<a name="ln2786"> </a>
<a name="ln2787">	if (sc-&gt;mac_ver == 0x5390)</a>
<a name="ln2788">		rt3090_set_rx_antenna(sc, 0);</a>
<a name="ln2789"> </a>
<a name="ln2790">	/* Patch RSSI inaccurate issue. */</a>
<a name="ln2791">	rt2860_mcu_bbp_write(sc, 79, 0x13);</a>
<a name="ln2792">	rt2860_mcu_bbp_write(sc, 80, 0x05);</a>
<a name="ln2793">	rt2860_mcu_bbp_write(sc, 81, 0x33);</a>
<a name="ln2794"> </a>
<a name="ln2795">	/* Enable DC filter. */</a>
<a name="ln2796">	if (sc-&gt;mac_rev &gt;= 0x0211)</a>
<a name="ln2797">		rt2860_mcu_bbp_write(sc, 103, 0xc0);</a>
<a name="ln2798"> </a>
<a name="ln2799">	bbp = rt2860_mcu_bbp_read(sc, 138);</a>
<a name="ln2800">	if (sc-&gt;ntxchains == 1)</a>
<a name="ln2801">		bbp |= 0x20;	/* Turn off DAC1. */</a>
<a name="ln2802">	if (sc-&gt;nrxchains == 1)</a>
<a name="ln2803">		bbp &amp;= ~0x02;	/* Turn off ADC1. */</a>
<a name="ln2804">	rt2860_mcu_bbp_write(sc, 138, bbp);</a>
<a name="ln2805"> </a>
<a name="ln2806">	/* Enable RX LO1 and LO2. */</a>
<a name="ln2807">	rt3090_rf_write(sc, 38, rt3090_rf_read(sc, 38) &amp; ~RT5390_RX_LO1);</a>
<a name="ln2808">	rt3090_rf_write(sc, 39, rt3090_rf_read(sc, 39) &amp; ~RT5390_RX_LO2);</a>
<a name="ln2809"> </a>
<a name="ln2810">	/* Avoid data lost and CRC error. */</a>
<a name="ln2811">	rt2860_mcu_bbp_write(sc, 4,</a>
<a name="ln2812">	    rt2860_mcu_bbp_read(sc, 4) | RT5390_MAC_IF_CTRL);</a>
<a name="ln2813"> </a>
<a name="ln2814">	rf = rt3090_rf_read(sc, 30);</a>
<a name="ln2815">	rf = (rf &amp; ~0x18) | 0x10;</a>
<a name="ln2816">	rt3090_rf_write(sc, 30, rf);</a>
<a name="ln2817">}</a>
<a name="ln2818"> </a>
<a name="ln2819">static void</a>
<a name="ln2820">rt3090_rf_wakeup(struct rt2860_softc *sc)</a>
<a name="ln2821">{</a>
<a name="ln2822">	uint32_t tmp;</a>
<a name="ln2823">	uint8_t rf;</a>
<a name="ln2824"> </a>
<a name="ln2825">	if (sc-&gt;mac_ver == 0x3593) {</a>
<a name="ln2826">		/* enable VCO */</a>
<a name="ln2827">		rf = rt3090_rf_read(sc, 1);</a>
<a name="ln2828">		rt3090_rf_write(sc, 1, rf | RT3593_VCO);</a>
<a name="ln2829"> </a>
<a name="ln2830">		/* initiate VCO calibration */</a>
<a name="ln2831">		rf = rt3090_rf_read(sc, 3);</a>
<a name="ln2832">		rt3090_rf_write(sc, 3, rf | RT3593_VCOCAL);</a>
<a name="ln2833"> </a>
<a name="ln2834">		/* enable VCO bias current control */</a>
<a name="ln2835">		rf = rt3090_rf_read(sc, 6);</a>
<a name="ln2836">		rt3090_rf_write(sc, 6, rf | RT3593_VCO_IC);</a>
<a name="ln2837"> </a>
<a name="ln2838">		/* initiate res calibration */</a>
<a name="ln2839">		rf = rt3090_rf_read(sc, 2);</a>
<a name="ln2840">		rt3090_rf_write(sc, 2, rf | RT3593_RESCAL);</a>
<a name="ln2841"> </a>
<a name="ln2842">		/* set reference current control to 0.33 mA */</a>
<a name="ln2843">		rf = rt3090_rf_read(sc, 22);</a>
<a name="ln2844">		rf &amp;= ~RT3593_CP_IC_MASK;</a>
<a name="ln2845">		rf |= 1 &lt;&lt; RT3593_CP_IC_SHIFT;</a>
<a name="ln2846">		rt3090_rf_write(sc, 22, rf);</a>
<a name="ln2847"> </a>
<a name="ln2848">		/* enable RX CTB */</a>
<a name="ln2849">		rf = rt3090_rf_read(sc, 46);</a>
<a name="ln2850">		rt3090_rf_write(sc, 46, rf | RT3593_RX_CTB);</a>
<a name="ln2851"> </a>
<a name="ln2852">		rf = rt3090_rf_read(sc, 20);</a>
<a name="ln2853">		rf &amp;= ~(RT3593_LDO_RF_VC_MASK | RT3593_LDO_PLL_VC_MASK);</a>
<a name="ln2854">		rt3090_rf_write(sc, 20, rf);</a>
<a name="ln2855">	} else {</a>
<a name="ln2856">		/* enable RF block */</a>
<a name="ln2857">		rf = rt3090_rf_read(sc, 1);</a>
<a name="ln2858">		rt3090_rf_write(sc, 1, rf | RT3070_RF_BLOCK);</a>
<a name="ln2859"> </a>
<a name="ln2860">		/* enable VCO bias current control */</a>
<a name="ln2861">		rf = rt3090_rf_read(sc, 7);</a>
<a name="ln2862">		rt3090_rf_write(sc, 7, rf | 0x30);</a>
<a name="ln2863"> </a>
<a name="ln2864">		rf = rt3090_rf_read(sc, 9);</a>
<a name="ln2865">		rt3090_rf_write(sc, 9, rf | 0x0e);</a>
<a name="ln2866"> </a>
<a name="ln2867">		/* enable RX CTB */</a>
<a name="ln2868">		rf = rt3090_rf_read(sc, 21);</a>
<a name="ln2869">		rt3090_rf_write(sc, 21, rf | RT3070_RX_CTB);</a>
<a name="ln2870"> </a>
<a name="ln2871">		/* fix Tx to Rx IQ glitch by raising RF voltage */</a>
<a name="ln2872">		rf = rt3090_rf_read(sc, 27);</a>
<a name="ln2873">		rf &amp;= ~0x77;</a>
<a name="ln2874">		if (sc-&gt;mac_rev &lt; 0x0211)</a>
<a name="ln2875">			rf |= 0x03;</a>
<a name="ln2876">		rt3090_rf_write(sc, 27, rf);</a>
<a name="ln2877">	}</a>
<a name="ln2878">	if (sc-&gt;patch_dac &amp;&amp; sc-&gt;mac_rev &lt; 0x0211) {</a>
<a name="ln2879">		tmp = RAL_READ(sc, RT3070_LDO_CFG0);</a>
<a name="ln2880">		tmp = (tmp &amp; ~0x1f000000) | 0x0d000000;</a>
<a name="ln2881">		RAL_WRITE(sc, RT3070_LDO_CFG0, tmp);</a>
<a name="ln2882">	}</a>
<a name="ln2883">}</a>
<a name="ln2884"> </a>
<a name="ln2885">static void</a>
<a name="ln2886">rt5390_rf_wakeup(struct rt2860_softc *sc)</a>
<a name="ln2887">{</a>
<a name="ln2888">	uint32_t tmp;</a>
<a name="ln2889">	uint8_t rf;</a>
<a name="ln2890"> </a>
<a name="ln2891">	rf = rt3090_rf_read(sc, 1);</a>
<a name="ln2892">	rf |= RT3070_RF_BLOCK | RT3070_PLL_PD | RT3070_RX0_PD | </a>
<a name="ln2893">	    RT3070_TX0_PD;</a>
<a name="ln2894">	if (sc-&gt;mac_ver == 0x5392)</a>
<a name="ln2895">		rf |= RT3070_RX1_PD | RT3070_TX1_PD;</a>
<a name="ln2896">	rt3090_rf_write(sc, 1, rf);</a>
<a name="ln2897"> </a>
<a name="ln2898">	rf = rt3090_rf_read(sc, 6);</a>
<a name="ln2899">	rf |= RT3593_VCO_IC | RT3593_VCOCAL;</a>
<a name="ln2900">	if (sc-&gt;mac_ver == 0x5390)</a>
<a name="ln2901">		rf &amp;= ~RT3593_VCO_IC;</a>
<a name="ln2902">	rt3090_rf_write(sc, 6, rf);</a>
<a name="ln2903"> </a>
<a name="ln2904">	rt3090_rf_write(sc, 2, rt3090_rf_read(sc, 2) | RT3593_RESCAL);</a>
<a name="ln2905"> </a>
<a name="ln2906">	rf = rt3090_rf_read(sc, 22);</a>
<a name="ln2907">	rf = (rf &amp; ~0xe0) | 0x20;</a>
<a name="ln2908">	rt3090_rf_write(sc, 22, rf);</a>
<a name="ln2909"> </a>
<a name="ln2910">	rt3090_rf_write(sc, 42, rt3090_rf_read(sc, 42) | RT5390_RX_CTB);</a>
<a name="ln2911">	rt3090_rf_write(sc, 20, rt3090_rf_read(sc, 20) &amp; ~0x77);</a>
<a name="ln2912">	rt3090_rf_write(sc, 3, rt3090_rf_read(sc, 3) | RT3593_VCOCAL);</a>
<a name="ln2913"> </a>
<a name="ln2914">	if (sc-&gt;patch_dac &amp;&amp; sc-&gt;mac_rev &lt; 0x0211) {</a>
<a name="ln2915">		tmp = RAL_READ(sc, RT3070_LDO_CFG0);</a>
<a name="ln2916">		tmp = (tmp &amp; ~0x1f000000) | 0x0d000000;</a>
<a name="ln2917">		RAL_WRITE(sc, RT3070_LDO_CFG0, tmp);</a>
<a name="ln2918">	}</a>
<a name="ln2919">}</a>
<a name="ln2920"> </a>
<a name="ln2921">static int</a>
<a name="ln2922">rt3090_filter_calib(struct rt2860_softc *sc, uint8_t init, uint8_t target,</a>
<a name="ln2923">    uint8_t *val)</a>
<a name="ln2924">{</a>
<a name="ln2925">	uint8_t rf22, rf24;</a>
<a name="ln2926">	uint8_t bbp55_pb, bbp55_sb, delta;</a>
<a name="ln2927">	int ntries;</a>
<a name="ln2928"> </a>
<a name="ln2929">	/* program filter */</a>
<a name="ln2930">	rf24 = rt3090_rf_read(sc, 24);</a>
<a name="ln2931">	rf24 = (rf24 &amp; 0xc0) | init;	/* initial filter value */</a>
<a name="ln2932">	rt3090_rf_write(sc, 24, rf24);</a>
<a name="ln2933"> </a>
<a name="ln2934">	/* enable baseband loopback mode */</a>
<a name="ln2935">	rf22 = rt3090_rf_read(sc, 22);</a>
<a name="ln2936">	rt3090_rf_write(sc, 22, rf22 | RT3070_BB_LOOPBACK);</a>
<a name="ln2937"> </a>
<a name="ln2938">	/* set power and frequency of passband test tone */</a>
<a name="ln2939">	rt2860_mcu_bbp_write(sc, 24, 0x00);</a>
<a name="ln2940">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2941">		/* transmit test tone */</a>
<a name="ln2942">		rt2860_mcu_bbp_write(sc, 25, 0x90);</a>
<a name="ln2943">		DELAY(1000);</a>
<a name="ln2944">		/* read received power */</a>
<a name="ln2945">		bbp55_pb = rt2860_mcu_bbp_read(sc, 55);</a>
<a name="ln2946">		if (bbp55_pb != 0)</a>
<a name="ln2947">			break;</a>
<a name="ln2948">	}</a>
<a name="ln2949">	if (ntries == 100)</a>
<a name="ln2950">		return (ETIMEDOUT);</a>
<a name="ln2951"> </a>
<a name="ln2952">	/* set power and frequency of stopband test tone */</a>
<a name="ln2953">	rt2860_mcu_bbp_write(sc, 24, 0x06);</a>
<a name="ln2954">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln2955">		/* transmit test tone */</a>
<a name="ln2956">		rt2860_mcu_bbp_write(sc, 25, 0x90);</a>
<a name="ln2957">		DELAY(1000);</a>
<a name="ln2958">		/* read received power */</a>
<a name="ln2959">		bbp55_sb = rt2860_mcu_bbp_read(sc, 55);</a>
<a name="ln2960"> </a>
<a name="ln2961">		delta = bbp55_pb - bbp55_sb;</a>
<a name="ln2962">		if (delta &gt; target)</a>
<a name="ln2963">			break;</a>
<a name="ln2964"> </a>
<a name="ln2965">		/* reprogram filter */</a>
<a name="ln2966">		rf24++;</a>
<a name="ln2967">		rt3090_rf_write(sc, 24, rf24);</a>
<a name="ln2968">	}</a>
<a name="ln2969">	if (ntries &lt; 100) {</a>
<a name="ln2970">		if (rf24 != init)</a>
<a name="ln2971">			rf24--;	/* backtrack */</a>
<a name="ln2972">		*val = rf24;</a>
<a name="ln2973">		rt3090_rf_write(sc, 24, rf24);</a>
<a name="ln2974">	}</a>
<a name="ln2975"> </a>
<a name="ln2976">	/* restore initial state */</a>
<a name="ln2977">	rt2860_mcu_bbp_write(sc, 24, 0x00);</a>
<a name="ln2978"> </a>
<a name="ln2979">	/* disable baseband loopback mode */</a>
<a name="ln2980">	rf22 = rt3090_rf_read(sc, 22);</a>
<a name="ln2981">	rt3090_rf_write(sc, 22, rf22 &amp; ~RT3070_BB_LOOPBACK);</a>
<a name="ln2982"> </a>
<a name="ln2983">	return (0);</a>
<a name="ln2984">}</a>
<a name="ln2985"> </a>
<a name="ln2986">static void</a>
<a name="ln2987">rt3090_rf_setup(struct rt2860_softc *sc)</a>
<a name="ln2988">{</a>
<a name="ln2989">	uint8_t bbp;</a>
<a name="ln2990">	int i;</a>
<a name="ln2991"> </a>
<a name="ln2992">	if (sc-&gt;mac_rev &gt;= 0x0211) {</a>
<a name="ln2993">		/* enable DC filter */</a>
<a name="ln2994">		rt2860_mcu_bbp_write(sc, 103, 0xc0);</a>
<a name="ln2995"> </a>
<a name="ln2996">		/* improve power consumption */</a>
<a name="ln2997">		bbp = rt2860_mcu_bbp_read(sc, 31);</a>
<a name="ln2998">		rt2860_mcu_bbp_write(sc, 31, bbp &amp; ~0x03);</a>
<a name="ln2999">	}</a>
<a name="ln3000"> </a>
<a name="ln3001">	RAL_WRITE(sc, RT2860_TX_SW_CFG1, 0);</a>
<a name="ln3002">	if (sc-&gt;mac_rev &lt; 0x0211) {</a>
<a name="ln3003">		RAL_WRITE(sc, RT2860_TX_SW_CFG2,</a>
<a name="ln3004">		    sc-&gt;patch_dac ? 0x2c : 0x0f);</a>
<a name="ln3005">	} else</a>
<a name="ln3006">		RAL_WRITE(sc, RT2860_TX_SW_CFG2, 0);</a>
<a name="ln3007"> </a>
<a name="ln3008">	/* initialize RF registers from ROM */</a>
<a name="ln3009">	if (sc-&gt;mac_ver &lt; 0x5390) {</a>
<a name="ln3010">		for (i = 0; i &lt; 10; i++) {</a>
<a name="ln3011">			if (sc-&gt;rf[i].reg == 0 || sc-&gt;rf[i].reg == 0xff)</a>
<a name="ln3012">				continue;</a>
<a name="ln3013">			rt3090_rf_write(sc, sc-&gt;rf[i].reg, sc-&gt;rf[i].val);</a>
<a name="ln3014">		}</a>
<a name="ln3015">	}</a>
<a name="ln3016">}</a>
<a name="ln3017"> </a>
<a name="ln3018">static void</a>
<a name="ln3019">rt2860_set_leds(struct rt2860_softc *sc, uint16_t which)</a>
<a name="ln3020">{</a>
<a name="ln3021">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LEDS,</a>
<a name="ln3022">	    which | (sc-&gt;leds &amp; 0x7f), 0);</a>
<a name="ln3023">}</a>
<a name="ln3024"> </a>
<a name="ln3025">/*</a>
<a name="ln3026"> * Hardware has a general-purpose programmable timer interrupt that can</a>
<a name="ln3027"> * periodically raise MAC_INT_4.</a>
<a name="ln3028"> */</a>
<a name="ln3029">static void</a>
<a name="ln3030">rt2860_set_gp_timer(struct rt2860_softc *sc, int ms)</a>
<a name="ln3031">{</a>
<a name="ln3032">	uint32_t tmp;</a>
<a name="ln3033"> </a>
<a name="ln3034">	/* disable GP timer before reprogramming it */</a>
<a name="ln3035">	tmp = RAL_READ(sc, RT2860_INT_TIMER_EN);</a>
<a name="ln3036">	RAL_WRITE(sc, RT2860_INT_TIMER_EN, tmp &amp; ~RT2860_GP_TIMER_EN);</a>
<a name="ln3037"> </a>
<a name="ln3038">	if (ms == 0)</a>
<a name="ln3039">		return;</a>
<a name="ln3040"> </a>
<a name="ln3041">	tmp = RAL_READ(sc, RT2860_INT_TIMER_CFG);</a>
<a name="ln3042">	ms *= 16;	/* Unit: 64us */</a>
<a name="ln3043">	tmp = (tmp &amp; 0xffff) | ms &lt;&lt; RT2860_GP_TIMER_SHIFT;</a>
<a name="ln3044">	RAL_WRITE(sc, RT2860_INT_TIMER_CFG, tmp);</a>
<a name="ln3045"> </a>
<a name="ln3046">	/* enable GP timer */</a>
<a name="ln3047">	tmp = RAL_READ(sc, RT2860_INT_TIMER_EN);</a>
<a name="ln3048">	RAL_WRITE(sc, RT2860_INT_TIMER_EN, tmp | RT2860_GP_TIMER_EN);</a>
<a name="ln3049">}</a>
<a name="ln3050"> </a>
<a name="ln3051">static void</a>
<a name="ln3052">rt2860_set_bssid(struct rt2860_softc *sc, const uint8_t *bssid)</a>
<a name="ln3053">{</a>
<a name="ln3054">	RAL_WRITE(sc, RT2860_MAC_BSSID_DW0,</a>
<a name="ln3055">	    bssid[0] | bssid[1] &lt;&lt; 8 | bssid[2] &lt;&lt; 16 | bssid[3] &lt;&lt; 24);</a>
<a name="ln3056">	RAL_WRITE(sc, RT2860_MAC_BSSID_DW1,</a>
<a name="ln3057">	    bssid[4] | bssid[5] &lt;&lt; 8);</a>
<a name="ln3058">}</a>
<a name="ln3059"> </a>
<a name="ln3060">static void</a>
<a name="ln3061">rt2860_set_macaddr(struct rt2860_softc *sc, const uint8_t *addr)</a>
<a name="ln3062">{</a>
<a name="ln3063">	RAL_WRITE(sc, RT2860_MAC_ADDR_DW0,</a>
<a name="ln3064">	    addr[0] | addr[1] &lt;&lt; 8 | addr[2] &lt;&lt; 16 | addr[3] &lt;&lt; 24);</a>
<a name="ln3065">	RAL_WRITE(sc, RT2860_MAC_ADDR_DW1,</a>
<a name="ln3066">	    addr[4] | addr[5] &lt;&lt; 8 | 0xff &lt;&lt; 16);</a>
<a name="ln3067">}</a>
<a name="ln3068"> </a>
<a name="ln3069">static void</a>
<a name="ln3070">rt2860_updateslot(struct ieee80211com *ic)</a>
<a name="ln3071">{</a>
<a name="ln3072">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3073">	uint32_t tmp;</a>
<a name="ln3074"> </a>
<a name="ln3075">	tmp = RAL_READ(sc, RT2860_BKOFF_SLOT_CFG);</a>
<a name="ln3076">	tmp &amp;= ~0xff;</a>
<a name="ln3077">	tmp |= IEEE80211_GET_SLOTTIME(ic);</a>
<a name="ln3078">	RAL_WRITE(sc, RT2860_BKOFF_SLOT_CFG, tmp);</a>
<a name="ln3079">}</a>
<a name="ln3080"> </a>
<a name="ln3081">static void</a>
<a name="ln3082">rt2860_updateprot(struct rt2860_softc *sc)</a>
<a name="ln3083">{</a>
<a name="ln3084">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3085">	uint32_t tmp;</a>
<a name="ln3086"> </a>
<a name="ln3087">	tmp = RT2860_RTSTH_EN | RT2860_PROT_NAV_SHORT | RT2860_TXOP_ALLOW_ALL;</a>
<a name="ln3088">	/* setup protection frame rate (MCS code) */</a>
<a name="ln3089">	tmp |= IEEE80211_IS_CHAN_5GHZ(ic-&gt;ic_curchan) ?</a>
<a name="ln3090">	    rt2860_rates[RT2860_RIDX_OFDM6].mcs :</a>
<a name="ln3091">	    rt2860_rates[RT2860_RIDX_CCK11].mcs;</a>
<a name="ln3092"> </a>
<a name="ln3093">	/* CCK frames don't require protection */</a>
<a name="ln3094">	RAL_WRITE(sc, RT2860_CCK_PROT_CFG, tmp);</a>
<a name="ln3095"> </a>
<a name="ln3096">	if (ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT) {</a>
<a name="ln3097">		if (ic-&gt;ic_protmode == IEEE80211_PROT_RTSCTS)</a>
<a name="ln3098">			tmp |= RT2860_PROT_CTRL_RTS_CTS;</a>
<a name="ln3099">		else if (ic-&gt;ic_protmode == IEEE80211_PROT_CTSONLY)</a>
<a name="ln3100">			tmp |= RT2860_PROT_CTRL_CTS;</a>
<a name="ln3101">	}</a>
<a name="ln3102">	RAL_WRITE(sc, RT2860_OFDM_PROT_CFG, tmp);</a>
<a name="ln3103">}</a>
<a name="ln3104"> </a>
<a name="ln3105">static void</a>
<a name="ln3106">rt2860_update_promisc(struct ieee80211com *ic)</a>
<a name="ln3107">{</a>
<a name="ln3108">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3109">	uint32_t tmp;</a>
<a name="ln3110"> </a>
<a name="ln3111">	tmp = RAL_READ(sc, RT2860_RX_FILTR_CFG);</a>
<a name="ln3112">	tmp &amp;= ~RT2860_DROP_NOT_MYBSS;</a>
<a name="ln3113">	if (ic-&gt;ic_promisc == 0)</a>
<a name="ln3114">		tmp |= RT2860_DROP_NOT_MYBSS;</a>
<a name="ln3115">	RAL_WRITE(sc, RT2860_RX_FILTR_CFG, tmp);</a>
<a name="ln3116">}</a>
<a name="ln3117"> </a>
<a name="ln3118">static int</a>
<a name="ln3119">rt2860_updateedca(struct ieee80211com *ic)</a>
<a name="ln3120">{</a>
<a name="ln3121">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3122">	struct chanAccParams chp;</a>
<a name="ln3123">	const struct wmeParams *wmep;</a>
<a name="ln3124">	int aci;</a>
<a name="ln3125"> </a>
<a name="ln3126">	ieee80211_wme_ic_getparams(ic, &amp;chp);</a>
<a name="ln3127"> </a>
<a name="ln3128">	wmep = chp.cap_wmeParams;</a>
<a name="ln3129"> </a>
<a name="ln3130">	/* update MAC TX configuration registers */</a>
<a name="ln3131">	for (aci = 0; aci &lt; WME_NUM_AC; aci++) {</a>
<a name="ln3132">		RAL_WRITE(sc, RT2860_EDCA_AC_CFG(aci),</a>
<a name="ln3133">		    wmep[aci].wmep_logcwmax &lt;&lt; 16 |</a>
<a name="ln3134">		    wmep[aci].wmep_logcwmin &lt;&lt; 12 |</a>
<a name="ln3135">		    wmep[aci].wmep_aifsn  &lt;&lt;  8 |</a>
<a name="ln3136">		    wmep[aci].wmep_txopLimit);</a>
<a name="ln3137">	}</a>
<a name="ln3138"> </a>
<a name="ln3139">	/* update SCH/DMA registers too */</a>
<a name="ln3140">	RAL_WRITE(sc, RT2860_WMM_AIFSN_CFG,</a>
<a name="ln3141">	    wmep[WME_AC_VO].wmep_aifsn  &lt;&lt; 12 |</a>
<a name="ln3142">	    wmep[WME_AC_VI].wmep_aifsn  &lt;&lt;  8 |</a>
<a name="ln3143">	    wmep[WME_AC_BK].wmep_aifsn  &lt;&lt;  4 |</a>
<a name="ln3144">	    wmep[WME_AC_BE].wmep_aifsn);</a>
<a name="ln3145">	RAL_WRITE(sc, RT2860_WMM_CWMIN_CFG,</a>
<a name="ln3146">	    wmep[WME_AC_VO].wmep_logcwmin &lt;&lt; 12 |</a>
<a name="ln3147">	    wmep[WME_AC_VI].wmep_logcwmin &lt;&lt;  8 |</a>
<a name="ln3148">	    wmep[WME_AC_BK].wmep_logcwmin &lt;&lt;  4 |</a>
<a name="ln3149">	    wmep[WME_AC_BE].wmep_logcwmin);</a>
<a name="ln3150">	RAL_WRITE(sc, RT2860_WMM_CWMAX_CFG,</a>
<a name="ln3151">	    wmep[WME_AC_VO].wmep_logcwmax &lt;&lt; 12 |</a>
<a name="ln3152">	    wmep[WME_AC_VI].wmep_logcwmax &lt;&lt;  8 |</a>
<a name="ln3153">	    wmep[WME_AC_BK].wmep_logcwmax &lt;&lt;  4 |</a>
<a name="ln3154">	    wmep[WME_AC_BE].wmep_logcwmax);</a>
<a name="ln3155">	RAL_WRITE(sc, RT2860_WMM_TXOP0_CFG,</a>
<a name="ln3156">	    wmep[WME_AC_BK].wmep_txopLimit &lt;&lt; 16 |</a>
<a name="ln3157">	    wmep[WME_AC_BE].wmep_txopLimit);</a>
<a name="ln3158">	RAL_WRITE(sc, RT2860_WMM_TXOP1_CFG,</a>
<a name="ln3159">	    wmep[WME_AC_VO].wmep_txopLimit &lt;&lt; 16 |</a>
<a name="ln3160">	    wmep[WME_AC_VI].wmep_txopLimit);</a>
<a name="ln3161"> </a>
<a name="ln3162">	return 0;</a>
<a name="ln3163">}</a>
<a name="ln3164"> </a>
<a name="ln3165">#ifdef HW_CRYPTO</a>
<a name="ln3166">static int</a>
<a name="ln3167">rt2860_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,</a>
<a name="ln3168">    struct ieee80211_key *k)</a>
<a name="ln3169">{</a>
<a name="ln3170">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3171">	bus_size_t base;</a>
<a name="ln3172">	uint32_t attr;</a>
<a name="ln3173">	uint8_t mode, wcid, iv[8];</a>
<a name="ln3174"> </a>
<a name="ln3175">	/* defer setting of WEP keys until interface is brought up */</a>
<a name="ln3176">	if ((ic-&gt;ic_if.if_flags &amp; (IFF_UP | IFF_RUNNING)) !=</a>
<a name="ln3177">	    (IFF_UP | IFF_RUNNING))</a>
<a name="ln3178">		return 0;</a>
<a name="ln3179"> </a>
<a name="ln3180">	/* map net80211 cipher to RT2860 security mode */</a>
<a name="ln3181">	switch (k-&gt;k_cipher) {</a>
<a name="ln3182">	case IEEE80211_CIPHER_WEP40:</a>
<a name="ln3183">		mode = RT2860_MODE_WEP40;</a>
<a name="ln3184">		break;</a>
<a name="ln3185">	case IEEE80211_CIPHER_WEP104:</a>
<a name="ln3186">		mode = RT2860_MODE_WEP104;</a>
<a name="ln3187">		break;</a>
<a name="ln3188">	case IEEE80211_CIPHER_TKIP:</a>
<a name="ln3189">		mode = RT2860_MODE_TKIP;</a>
<a name="ln3190">		break;</a>
<a name="ln3191">	case IEEE80211_CIPHER_CCMP:</a>
<a name="ln3192">		mode = RT2860_MODE_AES_CCMP;</a>
<a name="ln3193">		break;</a>
<a name="ln3194">	default:</a>
<a name="ln3195">		return EINVAL;</a>
<a name="ln3196">	}</a>
<a name="ln3197"> </a>
<a name="ln3198">	if (k-&gt;k_flags &amp; IEEE80211_KEY_GROUP) {</a>
<a name="ln3199">		wcid = 0;	/* NB: update WCID0 for group keys */</a>
<a name="ln3200">		base = RT2860_SKEY(0, k-&gt;k_id);</a>
<a name="ln3201">	} else {</a>
<a name="ln3202">		wcid = ((struct rt2860_node *)ni)-&gt;wcid;</a>
<a name="ln3203">		base = RT2860_PKEY(wcid);</a>
<a name="ln3204">	}</a>
<a name="ln3205"> </a>
<a name="ln3206">	if (k-&gt;k_cipher == IEEE80211_CIPHER_TKIP) {</a>
<a name="ln3207">		RAL_WRITE_REGION_1(sc, base, k-&gt;k_key, 16);</a>
<a name="ln3208">#ifndef IEEE80211_STA_ONLY</a>
<a name="ln3209">		if (ic-&gt;ic_opmode == IEEE80211_M_HOSTAP) {</a>
<a name="ln3210">			RAL_WRITE_REGION_1(sc, base + 16, &amp;k-&gt;k_key[16], 8);</a>
<a name="ln3211">			RAL_WRITE_REGION_1(sc, base + 24, &amp;k-&gt;k_key[24], 8);</a>
<a name="ln3212">		} else</a>
<a name="ln3213">#endif</a>
<a name="ln3214">		{</a>
<a name="ln3215">			RAL_WRITE_REGION_1(sc, base + 16, &amp;k-&gt;k_key[24], 8);</a>
<a name="ln3216">			RAL_WRITE_REGION_1(sc, base + 24, &amp;k-&gt;k_key[16], 8);</a>
<a name="ln3217">		}</a>
<a name="ln3218">	} else</a>
<a name="ln3219">		RAL_WRITE_REGION_1(sc, base, k-&gt;k_key, k-&gt;k_len);</a>
<a name="ln3220"> </a>
<a name="ln3221">	if (!(k-&gt;k_flags &amp; IEEE80211_KEY_GROUP) ||</a>
<a name="ln3222">	    (k-&gt;k_flags &amp; IEEE80211_KEY_TX)) {</a>
<a name="ln3223">		/* set initial packet number in IV+EIV */</a>
<a name="ln3224">		if (k-&gt;k_cipher == IEEE80211_CIPHER_WEP40 ||</a>
<a name="ln3225">		    k-&gt;k_cipher == IEEE80211_CIPHER_WEP104) {</a>
<a name="ln3226">			uint32_t val = arc4random();</a>
<a name="ln3227">			/* skip weak IVs from Fluhrer/Mantin/Shamir */</a>
<a name="ln3228">			if (val &gt;= 0x03ff00 &amp;&amp; (val &amp; 0xf8ff00) == 0x00ff00)</a>
<a name="ln3229">				val += 0x000100;</a>
<a name="ln3230">			iv[0] = val;</a>
<a name="ln3231">			iv[1] = val &gt;&gt; 8;</a>
<a name="ln3232">			iv[2] = val &gt;&gt; 16;</a>
<a name="ln3233">			iv[3] = k-&gt;k_id &lt;&lt; 6;</a>
<a name="ln3234">			iv[4] = iv[5] = iv[6] = iv[7] = 0;</a>
<a name="ln3235">		} else {</a>
<a name="ln3236">			if (k-&gt;k_cipher == IEEE80211_CIPHER_TKIP) {</a>
<a name="ln3237">				iv[0] = k-&gt;k_tsc &gt;&gt; 8;</a>
<a name="ln3238">				iv[1] = (iv[0] | 0x20) &amp; 0x7f;</a>
<a name="ln3239">				iv[2] = k-&gt;k_tsc;</a>
<a name="ln3240">			} else /* CCMP */ {</a>
<a name="ln3241">				iv[0] = k-&gt;k_tsc;</a>
<a name="ln3242">				iv[1] = k-&gt;k_tsc &gt;&gt; 8;</a>
<a name="ln3243">				iv[2] = 0;</a>
<a name="ln3244">			}</a>
<a name="ln3245">			iv[3] = k-&gt;k_id &lt;&lt; 6 | IEEE80211_WEP_EXTIV;</a>
<a name="ln3246">			iv[4] = k-&gt;k_tsc &gt;&gt; 16;</a>
<a name="ln3247">			iv[5] = k-&gt;k_tsc &gt;&gt; 24;</a>
<a name="ln3248">			iv[6] = k-&gt;k_tsc &gt;&gt; 32;</a>
<a name="ln3249">			iv[7] = k-&gt;k_tsc &gt;&gt; 40;</a>
<a name="ln3250">		}</a>
<a name="ln3251">		RAL_WRITE_REGION_1(sc, RT2860_IVEIV(wcid), iv, 8);</a>
<a name="ln3252">	}</a>
<a name="ln3253"> </a>
<a name="ln3254">	if (k-&gt;k_flags &amp; IEEE80211_KEY_GROUP) {</a>
<a name="ln3255">		/* install group key */</a>
<a name="ln3256">		attr = RAL_READ(sc, RT2860_SKEY_MODE_0_7);</a>
<a name="ln3257">		attr &amp;= ~(0xf &lt;&lt; (k-&gt;k_id * 4));</a>
<a name="ln3258">		attr |= mode &lt;&lt; (k-&gt;k_id * 4);</a>
<a name="ln3259">		RAL_WRITE(sc, RT2860_SKEY_MODE_0_7, attr);</a>
<a name="ln3260">	} else {</a>
<a name="ln3261">		/* install pairwise key */</a>
<a name="ln3262">		attr = RAL_READ(sc, RT2860_WCID_ATTR(wcid));</a>
<a name="ln3263">		attr = (attr &amp; ~0xf) | (mode &lt;&lt; 1) | RT2860_RX_PKEY_EN;</a>
<a name="ln3264">		RAL_WRITE(sc, RT2860_WCID_ATTR(wcid), attr);</a>
<a name="ln3265">	}</a>
<a name="ln3266">	return 0;</a>
<a name="ln3267">}</a>
<a name="ln3268"> </a>
<a name="ln3269">static void</a>
<a name="ln3270">rt2860_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni,</a>
<a name="ln3271">    struct ieee80211_key *k)</a>
<a name="ln3272">{</a>
<a name="ln3273">	struct rt2860_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3274">	uint32_t attr;</a>
<a name="ln3275">	uint8_t wcid;</a>
<a name="ln3276"> </a>
<a name="ln3277">	if (k-&gt;k_flags &amp; IEEE80211_KEY_GROUP) {</a>
<a name="ln3278">		/* remove group key */</a>
<a name="ln3279">		attr = RAL_READ(sc, RT2860_SKEY_MODE_0_7);</a>
<a name="ln3280">		attr &amp;= ~(0xf &lt;&lt; (k-&gt;k_id * 4));</a>
<a name="ln3281">		RAL_WRITE(sc, RT2860_SKEY_MODE_0_7, attr);</a>
<a name="ln3282"> </a>
<a name="ln3283">	} else {</a>
<a name="ln3284">		/* remove pairwise key */</a>
<a name="ln3285">		wcid = ((struct rt2860_node *)ni)-&gt;wcid;</a>
<a name="ln3286">		attr = RAL_READ(sc, RT2860_WCID_ATTR(wcid));</a>
<a name="ln3287">		attr &amp;= ~0xf;</a>
<a name="ln3288">		RAL_WRITE(sc, RT2860_WCID_ATTR(wcid), attr);</a>
<a name="ln3289">	}</a>
<a name="ln3290">}</a>
<a name="ln3291">#endif</a>
<a name="ln3292"> </a>
<a name="ln3293">static int8_t</a>
<a name="ln3294">rt2860_rssi2dbm(struct rt2860_softc *sc, uint8_t rssi, uint8_t rxchain)</a>
<a name="ln3295">{</a>
<a name="ln3296">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3297">	struct ieee80211_channel *c = ic-&gt;ic_curchan;</a>
<a name="ln3298">	int delta;</a>
<a name="ln3299"> </a>
<a name="ln3300">	if (IEEE80211_IS_CHAN_5GHZ(c)) {</a>
<a name="ln3301">		u_int chan = ieee80211_chan2ieee(ic, c);</a>
<a name="ln3302">		delta = sc-&gt;rssi_5ghz[rxchain];</a>
<a name="ln3303"> </a>
<a name="ln3304">		/* determine channel group */</a>
<a name="ln3305">		if (chan &lt;= 64)</a>
<a name="ln3306">			delta -= sc-&gt;lna[1];</a>
<a name="ln3307">		else if (chan &lt;= 128)</a>
<a name="ln3308">			delta -= sc-&gt;lna[2];</a>
<a name="ln3309">		else</a>
<a name="ln3310">			delta -= sc-&gt;lna[3];</a>
<a name="ln3311">	} else</a>
<a name="ln3312">		delta = sc-&gt;rssi_2ghz[rxchain] - sc-&gt;lna[0];</a>
<a name="ln3313"> </a>
<a name="ln3314">	return -12 - delta - rssi;</a>
<a name="ln3315">}</a>
<a name="ln3316"> </a>
<a name="ln3317">/*</a>
<a name="ln3318"> * Add `delta' (signed) to each 4-bit sub-word of a 32-bit word.</a>
<a name="ln3319"> * Used to adjust per-rate Tx power registers.</a>
<a name="ln3320"> */</a>
<a name="ln3321">static __inline uint32_t</a>
<a name="ln3322">b4inc(uint32_t b32, int8_t delta)</a>
<a name="ln3323">{</a>
<a name="ln3324">	int8_t i, b4;</a>
<a name="ln3325"> </a>
<a name="ln3326">	for (i = 0; i &lt; 8; i++) {</a>
<a name="ln3327">		b4 = b32 &amp; 0xf;</a>
<a name="ln3328">		b4 += delta;</a>
<a name="ln3329">		if (b4 &lt; 0)</a>
<a name="ln3330">			b4 = 0;</a>
<a name="ln3331">		else if (b4 &gt; 0xf)</a>
<a name="ln3332">			b4 = 0xf;</a>
<a name="ln3333">		b32 = b32 &gt;&gt; 4 | b4 &lt;&lt; 28;</a>
<a name="ln3334">	}</a>
<a name="ln3335">	return b32;</a>
<a name="ln3336">}</a>
<a name="ln3337"> </a>
<a name="ln3338">static const char *</a>
<a name="ln3339">rt2860_get_rf(uint16_t rev)</a>
<a name="ln3340">{</a>
<a name="ln3341">	switch (rev) {</a>
<a name="ln3342">	case RT2860_RF_2820:	return &quot;RT2820&quot;;</a>
<a name="ln3343">	case RT2860_RF_2850:	return &quot;RT2850&quot;;</a>
<a name="ln3344">	case RT2860_RF_2720:	return &quot;RT2720&quot;;</a>
<a name="ln3345">	case RT2860_RF_2750:	return &quot;RT2750&quot;;</a>
<a name="ln3346">	case RT3070_RF_3020:	return &quot;RT3020&quot;;</a>
<a name="ln3347">	case RT3070_RF_2020:	return &quot;RT2020&quot;;</a>
<a name="ln3348">	case RT3070_RF_3021:	return &quot;RT3021&quot;;</a>
<a name="ln3349">	case RT3070_RF_3022:	return &quot;RT3022&quot;;</a>
<a name="ln3350">	case RT3070_RF_3052:	return &quot;RT3052&quot;;</a>
<a name="ln3351">	case RT3070_RF_3320:	return &quot;RT3320&quot;;</a>
<a name="ln3352">	case RT3070_RF_3053:	return &quot;RT3053&quot;;</a>
<a name="ln3353">	case RT5390_RF_5360:	return &quot;RT5360&quot;;</a>
<a name="ln3354">	case RT5390_RF_5390:	return &quot;RT5390&quot;;</a>
<a name="ln3355">	default:		return &quot;unknown&quot;;</a>
<a name="ln3356">	}</a>
<a name="ln3357">}</a>
<a name="ln3358"> </a>
<a name="ln3359">static int</a>
<a name="ln3360">rt2860_read_eeprom(struct rt2860_softc *sc, uint8_t macaddr[IEEE80211_ADDR_LEN])</a>
<a name="ln3361">{</a>
<a name="ln3362">	int8_t delta_2ghz, delta_5ghz;</a>
<a name="ln3363">	uint32_t tmp;</a>
<a name="ln3364">	uint16_t val;</a>
<a name="ln3365">	int ridx, ant, i;</a>
<a name="ln3366"> </a>
<a name="ln3367">	/* check whether the ROM is eFUSE ROM or EEPROM */</a>
<a name="ln3368">	sc-&gt;sc_srom_read = rt2860_eeprom_read_2;</a>
<a name="ln3369">	if (sc-&gt;mac_ver &gt;= 0x3071) {</a>
<a name="ln3370">		tmp = RAL_READ(sc, RT3070_EFUSE_CTRL);</a>
<a name="ln3371">		DPRINTF((&quot;EFUSE_CTRL=0x%08x\n&quot;, tmp));</a>
<a name="ln3372">		if (tmp &amp; RT3070_SEL_EFUSE)</a>
<a name="ln3373">			sc-&gt;sc_srom_read = rt3090_efuse_read_2;</a>
<a name="ln3374">	}</a>
<a name="ln3375"> </a>
<a name="ln3376">#ifdef RAL_DEBUG</a>
<a name="ln3377">	/* read EEPROM version */</a>
<a name="ln3378">	val = rt2860_srom_read(sc, RT2860_EEPROM_VERSION);</a>
<a name="ln3379">	DPRINTF((&quot;EEPROM rev=%d, FAE=%d\n&quot;, val &gt;&gt; 8, val &amp; 0xff));</a>
<a name="ln3380">#endif</a>
<a name="ln3381"> </a>
<a name="ln3382">	/* read MAC address */</a>
<a name="ln3383">	val = rt2860_srom_read(sc, RT2860_EEPROM_MAC01);</a>
<a name="ln3384">	macaddr[0] = val &amp; 0xff;</a>
<a name="ln3385">	macaddr[1] = val &gt;&gt; 8;</a>
<a name="ln3386">	val = rt2860_srom_read(sc, RT2860_EEPROM_MAC23);</a>
<a name="ln3387">	macaddr[2] = val &amp; 0xff;</a>
<a name="ln3388">	macaddr[3] = val &gt;&gt; 8;</a>
<a name="ln3389">	val = rt2860_srom_read(sc, RT2860_EEPROM_MAC45);</a>
<a name="ln3390">	macaddr[4] = val &amp; 0xff;</a>
<a name="ln3391">	macaddr[5] = val &gt;&gt; 8;</a>
<a name="ln3392"> </a>
<a name="ln3393">#ifdef RAL_DEBUG</a>
<a name="ln3394">	/* read country code */</a>
<a name="ln3395">	val = rt2860_srom_read(sc, RT2860_EEPROM_COUNTRY);</a>
<a name="ln3396">	DPRINTF((&quot;EEPROM region code=0x%04x\n&quot;, val));</a>
<a name="ln3397">#endif</a>
<a name="ln3398"> </a>
<a name="ln3399">	/* read vendor BBP settings */</a>
<a name="ln3400">	for (i = 0; i &lt; 8; i++) {</a>
<a name="ln3401">		val = rt2860_srom_read(sc, RT2860_EEPROM_BBP_BASE + i);</a>
<a name="ln3402">		sc-&gt;bbp[i].val = val &amp; 0xff;</a>
<a name="ln3403">		sc-&gt;bbp[i].reg = val &gt;&gt; 8;</a>
<a name="ln3404">		DPRINTF((&quot;BBP%d=0x%02x\n&quot;, sc-&gt;bbp[i].reg, sc-&gt;bbp[i].val));</a>
<a name="ln3405">	}</a>
<a name="ln3406">	if (sc-&gt;mac_ver &gt;= 0x3071) {</a>
<a name="ln3407">		/* read vendor RF settings */</a>
<a name="ln3408">		for (i = 0; i &lt; 10; i++) {</a>
<a name="ln3409">			val = rt2860_srom_read(sc, RT3071_EEPROM_RF_BASE + i);</a>
<a name="ln3410">			sc-&gt;rf[i].val = val &amp; 0xff;</a>
<a name="ln3411">			sc-&gt;rf[i].reg = val &gt;&gt; 8;</a>
<a name="ln3412">			DPRINTF((&quot;RF%d=0x%02x\n&quot;, sc-&gt;rf[i].reg,</a>
<a name="ln3413">			    sc-&gt;rf[i].val));</a>
<a name="ln3414">		}</a>
<a name="ln3415">	}</a>
<a name="ln3416"> </a>
<a name="ln3417">	/* read RF frequency offset from EEPROM */</a>
<a name="ln3418">	val = rt2860_srom_read(sc, RT2860_EEPROM_FREQ_LEDS);</a>
<a name="ln3419">	sc-&gt;freq = ((val &amp; 0xff) != 0xff) ? val &amp; 0xff : 0;</a>
<a name="ln3420">	DPRINTF((&quot;EEPROM freq offset %d\n&quot;, sc-&gt;freq &amp; 0xff));</a>
<a name="ln3421">	if ((val &gt;&gt; 8) != 0xff) {</a>
<a name="ln3422">		/* read LEDs operating mode */</a>
<a name="ln3423">		sc-&gt;leds = val &gt;&gt; 8;</a>
<a name="ln3424">		sc-&gt;led[0] = rt2860_srom_read(sc, RT2860_EEPROM_LED1);</a>
<a name="ln3425">		sc-&gt;led[1] = rt2860_srom_read(sc, RT2860_EEPROM_LED2);</a>
<a name="ln3426">		sc-&gt;led[2] = rt2860_srom_read(sc, RT2860_EEPROM_LED3);</a>
<a name="ln3427">	} else {</a>
<a name="ln3428">		/* broken EEPROM, use default settings */</a>
<a name="ln3429">		sc-&gt;leds = 0x01;</a>
<a name="ln3430">		sc-&gt;led[0] = 0x5555;</a>
<a name="ln3431">		sc-&gt;led[1] = 0x2221;</a>
<a name="ln3432">		sc-&gt;led[2] = 0xa9f8;</a>
<a name="ln3433">	}</a>
<a name="ln3434">	DPRINTF((&quot;EEPROM LED mode=0x%02x, LEDs=0x%04x/0x%04x/0x%04x\n&quot;,</a>
<a name="ln3435">	    sc-&gt;leds, sc-&gt;led[0], sc-&gt;led[1], sc-&gt;led[2]));</a>
<a name="ln3436"> </a>
<a name="ln3437">	/* read RF information */</a>
<a name="ln3438">	val = rt2860_srom_read(sc, RT2860_EEPROM_ANTENNA);</a>
<a name="ln3439">	if (sc-&gt;mac_ver &gt;= 0x5390)</a>
<a name="ln3440">		sc-&gt;rf_rev = rt2860_srom_read(sc, RT2860_EEPROM_CHIPID);</a>
<a name="ln3441">	else</a>
<a name="ln3442">		sc-&gt;rf_rev = (val &gt;&gt; 8) &amp; 0xf;</a>
<a name="ln3443">	sc-&gt;ntxchains = (val &gt;&gt; 4) &amp; 0xf;</a>
<a name="ln3444">	sc-&gt;nrxchains = val &amp; 0xf;</a>
<a name="ln3445">	DPRINTF((&quot;EEPROM RF rev=0x%02x chains=%dT%dR\n&quot;,</a>
<a name="ln3446">	    sc-&gt;rf_rev, sc-&gt;ntxchains, sc-&gt;nrxchains));</a>
<a name="ln3447"> </a>
<a name="ln3448">	/* check if RF supports automatic Tx access gain control */</a>
<a name="ln3449">	val = rt2860_srom_read(sc, RT2860_EEPROM_CONFIG);</a>
<a name="ln3450">	DPRINTF((&quot;EEPROM CFG 0x%04x\n&quot;, val));</a>
<a name="ln3451">	/* check if driver should patch the DAC issue */</a>
<a name="ln3452">	if ((val &gt;&gt; 8) != 0xff)</a>
<a name="ln3453">		sc-&gt;patch_dac = (val &gt;&gt; 15) &amp; 1;</a>
<a name="ln3454">	if ((val &amp; 0xff) != 0xff) {</a>
<a name="ln3455">		sc-&gt;ext_5ghz_lna = (val &gt;&gt; 3) &amp; 1;</a>
<a name="ln3456">		sc-&gt;ext_2ghz_lna = (val &gt;&gt; 2) &amp; 1;</a>
<a name="ln3457">		/* check if RF supports automatic Tx access gain control */</a>
<a name="ln3458">		sc-&gt;calib_2ghz = sc-&gt;calib_5ghz = 0; /* XXX (val &gt;&gt; 1) &amp; 1 */</a>
<a name="ln3459">		/* check if we have a hardware radio switch */</a>
<a name="ln3460">		sc-&gt;rfswitch = val &amp; 1;</a>
<a name="ln3461">	}</a>
<a name="ln3462">	if (sc-&gt;sc_flags &amp; RT2860_ADVANCED_PS) {</a>
<a name="ln3463">		/* read PCIe power save level */</a>
<a name="ln3464">		val = rt2860_srom_read(sc, RT2860_EEPROM_PCIE_PSLEVEL);</a>
<a name="ln3465">		if ((val &amp; 0xff) != 0xff) {</a>
<a name="ln3466">			sc-&gt;pslevel = val &amp; 0x3;</a>
<a name="ln3467">			val = rt2860_srom_read(sc, RT2860_EEPROM_REV);</a>
<a name="ln3468">			if ((val &amp; 0xff80) != 0x9280)</a>
<a name="ln3469">				sc-&gt;pslevel = MIN(sc-&gt;pslevel, 1);</a>
<a name="ln3470">			DPRINTF((&quot;EEPROM PCIe PS Level=%d\n&quot;, sc-&gt;pslevel));</a>
<a name="ln3471">		}</a>
<a name="ln3472">	}</a>
<a name="ln3473"> </a>
<a name="ln3474">	/* read power settings for 2GHz channels */</a>
<a name="ln3475">	for (i = 0; i &lt; 14; i += 2) {</a>
<a name="ln3476">		val = rt2860_srom_read(sc,</a>
<a name="ln3477">		    RT2860_EEPROM_PWR2GHZ_BASE1 + i / 2);</a>
<a name="ln3478">		sc-&gt;txpow1[i + 0] = (int8_t)(val &amp; 0xff);</a>
<a name="ln3479">		sc-&gt;txpow1[i + 1] = (int8_t)(val &gt;&gt; 8);</a>
<a name="ln3480"> </a>
<a name="ln3481">		if (sc-&gt;mac_ver != 0x5390) {</a>
<a name="ln3482">			val = rt2860_srom_read(sc,</a>
<a name="ln3483">			    RT2860_EEPROM_PWR2GHZ_BASE2 + i / 2);</a>
<a name="ln3484">			sc-&gt;txpow2[i + 0] = (int8_t)(val &amp; 0xff);</a>
<a name="ln3485">			sc-&gt;txpow2[i + 1] = (int8_t)(val &gt;&gt; 8);</a>
<a name="ln3486">		}</a>
<a name="ln3487">	}</a>
<a name="ln3488">	/* fix broken Tx power entries */</a>
<a name="ln3489">	for (i = 0; i &lt; 14; i++) {</a>
<a name="ln3490">		if (sc-&gt;txpow1[i] &lt; 0 ||</a>
<a name="ln3491">		    sc-&gt;txpow1[i] &gt; ((sc-&gt;mac_ver &gt;= 0x5390) ? 39 : 31))</a>
<a name="ln3492">			sc-&gt;txpow1[i] = 5;</a>
<a name="ln3493">		if (sc-&gt;mac_ver != 0x5390) {</a>
<a name="ln3494">			if (sc-&gt;txpow2[i] &lt; 0 ||</a>
<a name="ln3495">			    sc-&gt;txpow2[i] &gt; ((sc-&gt;mac_ver == 0x5392) ? 39 : 31))</a>
<a name="ln3496">				sc-&gt;txpow2[i] = 5;</a>
<a name="ln3497">		}</a>
<a name="ln3498">		DPRINTF((&quot;chan %d: power1=%d, power2=%d\n&quot;,</a>
<a name="ln3499">		    rt2860_rf2850[i].chan, sc-&gt;txpow1[i], sc-&gt;txpow2[i]));</a>
<a name="ln3500">	}</a>
<a name="ln3501">	/* read power settings for 5GHz channels */</a>
<a name="ln3502">	for (i = 0; i &lt; 40; i += 2) {</a>
<a name="ln3503">		val = rt2860_srom_read(sc,</a>
<a name="ln3504">		    RT2860_EEPROM_PWR5GHZ_BASE1 + i / 2);</a>
<a name="ln3505">		sc-&gt;txpow1[i + 14] = (int8_t)(val &amp; 0xff);</a>
<a name="ln3506">		sc-&gt;txpow1[i + 15] = (int8_t)(val &gt;&gt; 8);</a>
<a name="ln3507"> </a>
<a name="ln3508">		val = rt2860_srom_read(sc,</a>
<a name="ln3509">		    RT2860_EEPROM_PWR5GHZ_BASE2 + i / 2);</a>
<a name="ln3510">		sc-&gt;txpow2[i + 14] = (int8_t)(val &amp; 0xff);</a>
<a name="ln3511">		sc-&gt;txpow2[i + 15] = (int8_t)(val &gt;&gt; 8);</a>
<a name="ln3512">	}</a>
<a name="ln3513">	/* fix broken Tx power entries */</a>
<a name="ln3514">	for (i = 0; i &lt; 40; i++) {</a>
<a name="ln3515">		if (sc-&gt;txpow1[14 + i] &lt; -7 || sc-&gt;txpow1[14 + i] &gt; 15)</a>
<a name="ln3516">			sc-&gt;txpow1[14 + i] = 5;</a>
<a name="ln3517">		if (sc-&gt;txpow2[14 + i] &lt; -7 || sc-&gt;txpow2[14 + i] &gt; 15)</a>
<a name="ln3518">			sc-&gt;txpow2[14 + i] = 5;</a>
<a name="ln3519">		DPRINTF((&quot;chan %d: power1=%d, power2=%d\n&quot;,</a>
<a name="ln3520">		    rt2860_rf2850[14 + i].chan, sc-&gt;txpow1[14 + i],</a>
<a name="ln3521">		    sc-&gt;txpow2[14 + i]));</a>
<a name="ln3522">	}</a>
<a name="ln3523"> </a>
<a name="ln3524">	/* read Tx power compensation for each Tx rate */</a>
<a name="ln3525">	val = rt2860_srom_read(sc, RT2860_EEPROM_DELTAPWR);</a>
<a name="ln3526">	delta_2ghz = delta_5ghz = 0;</a>
<a name="ln3527">	if ((val &amp; 0xff) != 0xff &amp;&amp; (val &amp; 0x80)) {</a>
<a name="ln3528">		delta_2ghz = val &amp; 0xf;</a>
<a name="ln3529">		if (!(val &amp; 0x40))	/* negative number */</a>
<a name="ln3530">			delta_2ghz = -delta_2ghz;</a>
<a name="ln3531">	}</a>
<a name="ln3532">	val &gt;&gt;= 8;</a>
<a name="ln3533">	if ((val &amp; 0xff) != 0xff &amp;&amp; (val &amp; 0x80)) {</a>
<a name="ln3534">		delta_5ghz = val &amp; 0xf;</a>
<a name="ln3535">		if (!(val &amp; 0x40))	/* negative number */</a>
<a name="ln3536">			delta_5ghz = -delta_5ghz;</a>
<a name="ln3537">	}</a>
<a name="ln3538">	DPRINTF((&quot;power compensation=%d (2GHz), %d (5GHz)\n&quot;,</a>
<a name="ln3539">	    delta_2ghz, delta_5ghz));</a>
<a name="ln3540"> </a>
<a name="ln3541">	for (ridx = 0; ridx &lt; 5; ridx++) {</a>
<a name="ln3542">		uint32_t reg;</a>
<a name="ln3543"> </a>
<a name="ln3544">		val = rt2860_srom_read(sc, RT2860_EEPROM_RPWR + ridx * 2);</a>
<a name="ln3545">		reg = val;</a>
<a name="ln3546">		val = rt2860_srom_read(sc, RT2860_EEPROM_RPWR + ridx * 2 + 1);</a>
<a name="ln3547">		reg |= (uint32_t)val &lt;&lt; 16;</a>
<a name="ln3548"> </a>
<a name="ln3549">		sc-&gt;txpow20mhz[ridx] = reg;</a>
<a name="ln3550">		sc-&gt;txpow40mhz_2ghz[ridx] = b4inc(reg, delta_2ghz);</a>
<a name="ln3551">		sc-&gt;txpow40mhz_5ghz[ridx] = b4inc(reg, delta_5ghz);</a>
<a name="ln3552"> </a>
<a name="ln3553">		DPRINTF((&quot;ridx %d: power 20MHz=0x%08x, 40MHz/2GHz=0x%08x, &quot;</a>
<a name="ln3554">		    &quot;40MHz/5GHz=0x%08x\n&quot;, ridx, sc-&gt;txpow20mhz[ridx],</a>
<a name="ln3555">		    sc-&gt;txpow40mhz_2ghz[ridx], sc-&gt;txpow40mhz_5ghz[ridx]));</a>
<a name="ln3556">	}</a>
<a name="ln3557"> </a>
<a name="ln3558">	/* read factory-calibrated samples for temperature compensation */</a>
<a name="ln3559">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI1_2GHZ);</a>
<a name="ln3560">	sc-&gt;tssi_2ghz[0] = val &amp; 0xff;	/* [-4] */</a>
<a name="ln3561">	sc-&gt;tssi_2ghz[1] = val &gt;&gt; 8;	/* [-3] */</a>
<a name="ln3562">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI2_2GHZ);</a>
<a name="ln3563">	sc-&gt;tssi_2ghz[2] = val &amp; 0xff;	/* [-2] */</a>
<a name="ln3564">	sc-&gt;tssi_2ghz[3] = val &gt;&gt; 8;	/* [-1] */</a>
<a name="ln3565">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI3_2GHZ);</a>
<a name="ln3566">	sc-&gt;tssi_2ghz[4] = val &amp; 0xff;	/* [+0] */</a>
<a name="ln3567">	sc-&gt;tssi_2ghz[5] = val &gt;&gt; 8;	/* [+1] */</a>
<a name="ln3568">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI4_2GHZ);</a>
<a name="ln3569">	sc-&gt;tssi_2ghz[6] = val &amp; 0xff;	/* [+2] */</a>
<a name="ln3570">	sc-&gt;tssi_2ghz[7] = val &gt;&gt; 8;	/* [+3] */</a>
<a name="ln3571">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI5_2GHZ);</a>
<a name="ln3572">	sc-&gt;tssi_2ghz[8] = val &amp; 0xff;	/* [+4] */</a>
<a name="ln3573">	sc-&gt;step_2ghz = val &gt;&gt; 8;</a>
<a name="ln3574">	DPRINTF((&quot;TSSI 2GHz: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x &quot;</a>
<a name="ln3575">	    &quot;0x%02x 0x%02x step=%d\n&quot;, sc-&gt;tssi_2ghz[0], sc-&gt;tssi_2ghz[1],</a>
<a name="ln3576">	    sc-&gt;tssi_2ghz[2], sc-&gt;tssi_2ghz[3], sc-&gt;tssi_2ghz[4],</a>
<a name="ln3577">	    sc-&gt;tssi_2ghz[5], sc-&gt;tssi_2ghz[6], sc-&gt;tssi_2ghz[7],</a>
<a name="ln3578">	    sc-&gt;tssi_2ghz[8], sc-&gt;step_2ghz));</a>
<a name="ln3579">	/* check that ref value is correct, otherwise disable calibration */</a>
<a name="ln3580">	if (sc-&gt;tssi_2ghz[4] == 0xff)</a>
<a name="ln3581">		sc-&gt;calib_2ghz = 0;</a>
<a name="ln3582"> </a>
<a name="ln3583">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI1_5GHZ);</a>
<a name="ln3584">	sc-&gt;tssi_5ghz[0] = val &amp; 0xff;	/* [-4] */</a>
<a name="ln3585">	sc-&gt;tssi_5ghz[1] = val &gt;&gt; 8;	/* [-3] */</a>
<a name="ln3586">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI2_5GHZ);</a>
<a name="ln3587">	sc-&gt;tssi_5ghz[2] = val &amp; 0xff;	/* [-2] */</a>
<a name="ln3588">	sc-&gt;tssi_5ghz[3] = val &gt;&gt; 8;	/* [-1] */</a>
<a name="ln3589">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI3_5GHZ);</a>
<a name="ln3590">	sc-&gt;tssi_5ghz[4] = val &amp; 0xff;	/* [+0] */</a>
<a name="ln3591">	sc-&gt;tssi_5ghz[5] = val &gt;&gt; 8;	/* [+1] */</a>
<a name="ln3592">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI4_5GHZ);</a>
<a name="ln3593">	sc-&gt;tssi_5ghz[6] = val &amp; 0xff;	/* [+2] */</a>
<a name="ln3594">	sc-&gt;tssi_5ghz[7] = val &gt;&gt; 8;	/* [+3] */</a>
<a name="ln3595">	val = rt2860_srom_read(sc, RT2860_EEPROM_TSSI5_5GHZ);</a>
<a name="ln3596">	sc-&gt;tssi_5ghz[8] = val &amp; 0xff;	/* [+4] */</a>
<a name="ln3597">	sc-&gt;step_5ghz = val &gt;&gt; 8;</a>
<a name="ln3598">	DPRINTF((&quot;TSSI 5GHz: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x &quot;</a>
<a name="ln3599">	    &quot;0x%02x 0x%02x step=%d\n&quot;, sc-&gt;tssi_5ghz[0], sc-&gt;tssi_5ghz[1],</a>
<a name="ln3600">	    sc-&gt;tssi_5ghz[2], sc-&gt;tssi_5ghz[3], sc-&gt;tssi_5ghz[4],</a>
<a name="ln3601">	    sc-&gt;tssi_5ghz[5], sc-&gt;tssi_5ghz[6], sc-&gt;tssi_5ghz[7],</a>
<a name="ln3602">	    sc-&gt;tssi_5ghz[8], sc-&gt;step_5ghz));</a>
<a name="ln3603">	/* check that ref value is correct, otherwise disable calibration */</a>
<a name="ln3604">	if (sc-&gt;tssi_5ghz[4] == 0xff)</a>
<a name="ln3605">		sc-&gt;calib_5ghz = 0;</a>
<a name="ln3606"> </a>
<a name="ln3607">	/* read RSSI offsets and LNA gains from EEPROM */</a>
<a name="ln3608">	val = rt2860_srom_read(sc, RT2860_EEPROM_RSSI1_2GHZ);</a>
<a name="ln3609">	sc-&gt;rssi_2ghz[0] = val &amp; 0xff;	/* Ant A */</a>
<a name="ln3610">	sc-&gt;rssi_2ghz[1] = val &gt;&gt; 8;	/* Ant B */</a>
<a name="ln3611">	val = rt2860_srom_read(sc, RT2860_EEPROM_RSSI2_2GHZ);</a>
<a name="ln3612">	if (sc-&gt;mac_ver &gt;= 0x3071) {</a>
<a name="ln3613">		/*</a>
<a name="ln3614">		 * On RT3090 chips (limited to 2 Rx chains), this ROM</a>
<a name="ln3615">		 * field contains the Tx mixer gain for the 2GHz band.</a>
<a name="ln3616">		 */</a>
<a name="ln3617">		if ((val &amp; 0xff) != 0xff)</a>
<a name="ln3618">			sc-&gt;txmixgain_2ghz = val &amp; 0x7;</a>
<a name="ln3619">		DPRINTF((&quot;tx mixer gain=%u (2GHz)\n&quot;, sc-&gt;txmixgain_2ghz));</a>
<a name="ln3620">	} else</a>
<a name="ln3621">		sc-&gt;rssi_2ghz[2] = val &amp; 0xff;	/* Ant C */</a>
<a name="ln3622">	sc-&gt;lna[2] = val &gt;&gt; 8;		/* channel group 2 */</a>
<a name="ln3623"> </a>
<a name="ln3624">	val = rt2860_srom_read(sc, RT2860_EEPROM_RSSI1_5GHZ);</a>
<a name="ln3625">	sc-&gt;rssi_5ghz[0] = val &amp; 0xff;	/* Ant A */</a>
<a name="ln3626">	sc-&gt;rssi_5ghz[1] = val &gt;&gt; 8;	/* Ant B */</a>
<a name="ln3627">	val = rt2860_srom_read(sc, RT2860_EEPROM_RSSI2_5GHZ);</a>
<a name="ln3628">	sc-&gt;rssi_5ghz[2] = val &amp; 0xff;	/* Ant C */</a>
<a name="ln3629">	sc-&gt;lna[3] = val &gt;&gt; 8;		/* channel group 3 */</a>
<a name="ln3630"> </a>
<a name="ln3631">	val = rt2860_srom_read(sc, RT2860_EEPROM_LNA);</a>
<a name="ln3632">	if (sc-&gt;mac_ver &gt;= 0x3071)</a>
<a name="ln3633">		sc-&gt;lna[0] = RT3090_DEF_LNA;</a>
<a name="ln3634">	else				/* channel group 0 */</a>
<a name="ln3635">		sc-&gt;lna[0] = val &amp; 0xff;</a>
<a name="ln3636">	sc-&gt;lna[1] = val &gt;&gt; 8;		/* channel group 1 */</a>
<a name="ln3637"> </a>
<a name="ln3638">	/* fix broken 5GHz LNA entries */</a>
<a name="ln3639">	if (sc-&gt;lna[2] == 0 || sc-&gt;lna[2] == 0xff) {</a>
<a name="ln3640">		DPRINTF((&quot;invalid LNA for channel group %d\n&quot;, 2));</a>
<a name="ln3641">		sc-&gt;lna[2] = sc-&gt;lna[1];</a>
<a name="ln3642">	}</a>
<a name="ln3643">	if (sc-&gt;lna[3] == 0 || sc-&gt;lna[3] == 0xff) {</a>
<a name="ln3644">		DPRINTF((&quot;invalid LNA for channel group %d\n&quot;, 3));</a>
<a name="ln3645">		sc-&gt;lna[3] = sc-&gt;lna[1];</a>
<a name="ln3646">	}</a>
<a name="ln3647"> </a>
<a name="ln3648">	/* fix broken RSSI offset entries */</a>
<a name="ln3649">	for (ant = 0; ant &lt; 3; ant++) {</a>
<a name="ln3650">		if (sc-&gt;rssi_2ghz[ant] &lt; -10 || sc-&gt;rssi_2ghz[ant] &gt; 10) {</a>
<a name="ln3651">			DPRINTF((&quot;invalid RSSI%d offset: %d (2GHz)\n&quot;,</a>
<a name="ln3652">			    ant + 1, sc-&gt;rssi_2ghz[ant]));</a>
<a name="ln3653">			sc-&gt;rssi_2ghz[ant] = 0;</a>
<a name="ln3654">		}</a>
<a name="ln3655">		if (sc-&gt;rssi_5ghz[ant] &lt; -10 || sc-&gt;rssi_5ghz[ant] &gt; 10) {</a>
<a name="ln3656">			DPRINTF((&quot;invalid RSSI%d offset: %d (5GHz)\n&quot;,</a>
<a name="ln3657">			    ant + 1, sc-&gt;rssi_5ghz[ant]));</a>
<a name="ln3658">			sc-&gt;rssi_5ghz[ant] = 0;</a>
<a name="ln3659">		}</a>
<a name="ln3660">	}</a>
<a name="ln3661"> </a>
<a name="ln3662">	return 0;</a>
<a name="ln3663">}</a>
<a name="ln3664"> </a>
<a name="ln3665">static int</a>
<a name="ln3666">rt2860_bbp_init(struct rt2860_softc *sc)</a>
<a name="ln3667">{</a>
<a name="ln3668">	int i, ntries;</a>
<a name="ln3669"> </a>
<a name="ln3670">	/* wait for BBP to wake up */</a>
<a name="ln3671">	for (ntries = 0; ntries &lt; 20; ntries++) {</a>
<a name="ln3672">		uint8_t bbp0 = rt2860_mcu_bbp_read(sc, 0);</a>
<a name="ln3673">		if (bbp0 != 0 &amp;&amp; bbp0 != 0xff)</a>
<a name="ln3674">			break;</a>
<a name="ln3675">	}</a>
<a name="ln3676">	if (ntries == 20) {</a>
<a name="ln3677">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3678">		    &quot;timeout waiting for BBP to wake up\n&quot;);</a>
<a name="ln3679">		return (ETIMEDOUT);</a>
<a name="ln3680">	}</a>
<a name="ln3681"> </a>
<a name="ln3682">	/* initialize BBP registers to default values */</a>
<a name="ln3683">	if (sc-&gt;mac_ver &gt;= 0x5390)</a>
<a name="ln3684">		rt5390_bbp_init(sc);</a>
<a name="ln3685">	else {</a>
<a name="ln3686">		for (i = 0; i &lt; nitems(rt2860_def_bbp); i++) {</a>
<a name="ln3687">			rt2860_mcu_bbp_write(sc, rt2860_def_bbp[i].reg,</a>
<a name="ln3688">			    rt2860_def_bbp[i].val);</a>
<a name="ln3689">		}</a>
<a name="ln3690">	}</a>
<a name="ln3691"> </a>
<a name="ln3692">	/* fix BBP84 for RT2860E */</a>
<a name="ln3693">	if (sc-&gt;mac_ver == 0x2860 &amp;&amp; sc-&gt;mac_rev != 0x0101)</a>
<a name="ln3694">		rt2860_mcu_bbp_write(sc, 84, 0x19);</a>
<a name="ln3695"> </a>
<a name="ln3696">	if (sc-&gt;mac_ver &gt;= 0x3071) {</a>
<a name="ln3697">		rt2860_mcu_bbp_write(sc, 79, 0x13);</a>
<a name="ln3698">		rt2860_mcu_bbp_write(sc, 80, 0x05);</a>
<a name="ln3699">		rt2860_mcu_bbp_write(sc, 81, 0x33);</a>
<a name="ln3700">	} else if (sc-&gt;mac_ver == 0x2860 &amp;&amp; sc-&gt;mac_rev == 0x0100) {</a>
<a name="ln3701">		rt2860_mcu_bbp_write(sc, 69, 0x16);</a>
<a name="ln3702">		rt2860_mcu_bbp_write(sc, 73, 0x12);</a>
<a name="ln3703">	}</a>
<a name="ln3704"> </a>
<a name="ln3705">	return 0;</a>
<a name="ln3706">}</a>
<a name="ln3707"> </a>
<a name="ln3708">static void</a>
<a name="ln3709">rt5390_bbp_init(struct rt2860_softc *sc)</a>
<a name="ln3710">{</a>
<a name="ln3711">	uint8_t bbp;</a>
<a name="ln3712">	int i;</a>
<a name="ln3713"> </a>
<a name="ln3714">	/* Apply maximum likelihood detection for 2 stream case. */</a>
<a name="ln3715">	if (sc-&gt;nrxchains &gt; 1) {</a>
<a name="ln3716">		bbp = rt2860_mcu_bbp_read(sc, 105);</a>
<a name="ln3717">		rt2860_mcu_bbp_write(sc, 105, bbp | RT5390_MLD);</a>
<a name="ln3718">	}</a>
<a name="ln3719"> </a>
<a name="ln3720">	/* Avoid data lost and CRC error. */</a>
<a name="ln3721">	bbp = rt2860_mcu_bbp_read(sc, 4);</a>
<a name="ln3722">	rt2860_mcu_bbp_write(sc, 4, bbp | RT5390_MAC_IF_CTRL);</a>
<a name="ln3723"> </a>
<a name="ln3724">	for (i = 0; i &lt; nitems(rt5390_def_bbp); i++) {</a>
<a name="ln3725">		rt2860_mcu_bbp_write(sc, rt5390_def_bbp[i].reg,</a>
<a name="ln3726">		    rt5390_def_bbp[i].val);</a>
<a name="ln3727">	}</a>
<a name="ln3728"> </a>
<a name="ln3729">	if (sc-&gt;mac_ver == 0x5392) {</a>
<a name="ln3730">		rt2860_mcu_bbp_write(sc, 84, 0x9a);</a>
<a name="ln3731">		rt2860_mcu_bbp_write(sc, 95, 0x9a);</a>
<a name="ln3732">		rt2860_mcu_bbp_write(sc, 98, 0x12);</a>
<a name="ln3733">		rt2860_mcu_bbp_write(sc, 106, 0x05);</a>
<a name="ln3734">		rt2860_mcu_bbp_write(sc, 134, 0xd0);</a>
<a name="ln3735">		rt2860_mcu_bbp_write(sc, 135, 0xf6);</a>
<a name="ln3736">	}</a>
<a name="ln3737"> </a>
<a name="ln3738">	bbp = rt2860_mcu_bbp_read(sc, 152);</a>
<a name="ln3739">	rt2860_mcu_bbp_write(sc, 152, bbp | 0x80);</a>
<a name="ln3740"> </a>
<a name="ln3741">	/* Disable hardware antenna diversity. */</a>
<a name="ln3742">	if (sc-&gt;mac_ver == 0x5390)</a>
<a name="ln3743">		rt2860_mcu_bbp_write(sc, 154, 0);</a>
<a name="ln3744">}</a>
<a name="ln3745"> </a>
<a name="ln3746">static int</a>
<a name="ln3747">rt2860_txrx_enable(struct rt2860_softc *sc)</a>
<a name="ln3748">{</a>
<a name="ln3749">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3750">	uint32_t tmp;</a>
<a name="ln3751">	int ntries;</a>
<a name="ln3752"> </a>
<a name="ln3753">	/* enable Tx/Rx DMA engine */</a>
<a name="ln3754">	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_MAC_TX_EN);</a>
<a name="ln3755">	RAL_BARRIER_READ_WRITE(sc);</a>
<a name="ln3756">	for (ntries = 0; ntries &lt; 200; ntries++) {</a>
<a name="ln3757">		tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);</a>
<a name="ln3758">		if ((tmp &amp; (RT2860_TX_DMA_BUSY | RT2860_RX_DMA_BUSY)) == 0)</a>
<a name="ln3759">			break;</a>
<a name="ln3760">		DELAY(1000);</a>
<a name="ln3761">	}</a>
<a name="ln3762">	if (ntries == 200) {</a>
<a name="ln3763">		device_printf(sc-&gt;sc_dev, &quot;timeout waiting for DMA engine\n&quot;);</a>
<a name="ln3764">		return ETIMEDOUT;</a>
<a name="ln3765">	}</a>
<a name="ln3766"> </a>
<a name="ln3767">	DELAY(50);</a>
<a name="ln3768"> </a>
<a name="ln3769">	tmp |= RT2860_RX_DMA_EN | RT2860_TX_DMA_EN |</a>
<a name="ln3770">	    RT2860_WPDMA_BT_SIZE64 &lt;&lt; RT2860_WPDMA_BT_SIZE_SHIFT;</a>
<a name="ln3771">	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);</a>
<a name="ln3772"> </a>
<a name="ln3773">	/* set Rx filter */</a>
<a name="ln3774">	tmp = RT2860_DROP_CRC_ERR | RT2860_DROP_PHY_ERR;</a>
<a name="ln3775">	if (ic-&gt;ic_opmode != IEEE80211_M_MONITOR) {</a>
<a name="ln3776">		tmp |= RT2860_DROP_UC_NOME | RT2860_DROP_DUPL |</a>
<a name="ln3777">		    RT2860_DROP_CTS | RT2860_DROP_BA | RT2860_DROP_ACK |</a>
<a name="ln3778">		    RT2860_DROP_VER_ERR | RT2860_DROP_CTRL_RSV |</a>
<a name="ln3779">		    RT2860_DROP_CFACK | RT2860_DROP_CFEND;</a>
<a name="ln3780">		if (ic-&gt;ic_opmode == IEEE80211_M_STA)</a>
<a name="ln3781">			tmp |= RT2860_DROP_RTS | RT2860_DROP_PSPOLL;</a>
<a name="ln3782">	}</a>
<a name="ln3783">	RAL_WRITE(sc, RT2860_RX_FILTR_CFG, tmp);</a>
<a name="ln3784"> </a>
<a name="ln3785">	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL,</a>
<a name="ln3786">	    RT2860_MAC_RX_EN | RT2860_MAC_TX_EN);</a>
<a name="ln3787"> </a>
<a name="ln3788">	return 0;</a>
<a name="ln3789">}</a>
<a name="ln3790"> </a>
<a name="ln3791">static void</a>
<a name="ln3792">rt2860_init(void *arg)</a>
<a name="ln3793">{</a>
<a name="ln3794">	struct rt2860_softc *sc = arg;</a>
<a name="ln3795">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3796"> </a>
<a name="ln3797">	RAL_LOCK(sc);</a>
<a name="ln3798">	rt2860_init_locked(sc);</a>
<a name="ln3799">	RAL_UNLOCK(sc);</a>
<a name="ln3800"> </a>
<a name="ln3801">	if (sc-&gt;sc_flags &amp; RT2860_RUNNING)</a>
<a name="ln3802">		ieee80211_start_all(ic);</a>
<a name="ln3803">}</a>
<a name="ln3804"> </a>
<a name="ln3805">static void</a>
<a name="ln3806">rt2860_init_locked(struct rt2860_softc *sc)</a>
<a name="ln3807">{</a>
<a name="ln3808">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3809">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln3810">	uint32_t tmp;</a>
<a name="ln3811">	uint8_t bbp1, bbp3;</a>
<a name="ln3812">	int i, qid, ridx, ntries, error;</a>
<a name="ln3813"> </a>
<a name="ln3814">	RAL_LOCK_ASSERT(sc);</a>
<a name="ln3815"> </a>
<a name="ln3816">	if (sc-&gt;rfswitch) {</a>
<a name="ln3817">		/* hardware has a radio switch on GPIO pin 2 */</a>
<a name="ln3818">		if (!(RAL_READ(sc, RT2860_GPIO_CTRL) &amp; (1 &lt;&lt; 2))) {</a>
<a name="ln3819">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3820">			    &quot;radio is disabled by hardware switch\n&quot;);</a>
<a name="ln3821">#ifdef notyet</a>
<a name="ln3822">			rt2860_stop_locked(sc);</a>
<a name="ln3823">			return;</a>
<a name="ln3824">#endif</a>
<a name="ln3825">		}</a>
<a name="ln3826">	}</a>
<a name="ln3827">	RAL_WRITE(sc, RT2860_PWR_PIN_CFG, RT2860_IO_RA_PE);</a>
<a name="ln3828"> </a>
<a name="ln3829">	/* disable DMA */</a>
<a name="ln3830">	tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);</a>
<a name="ln3831">	tmp &amp;= ~(RT2860_RX_DMA_BUSY | RT2860_RX_DMA_EN | RT2860_TX_DMA_BUSY |</a>
<a name="ln3832">	    RT2860_TX_DMA_EN);</a>
<a name="ln3833">	tmp |= RT2860_TX_WB_DDONE;</a>
<a name="ln3834">	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);</a>
<a name="ln3835"> </a>
<a name="ln3836">	/* reset DMA indexes */</a>
<a name="ln3837">	RAL_WRITE(sc, RT2860_WPDMA_RST_IDX, RT2860_RST_DRX_IDX0 |</a>
<a name="ln3838">	    RT2860_RST_DTX_IDX5 | RT2860_RST_DTX_IDX4 | RT2860_RST_DTX_IDX3 |</a>
<a name="ln3839">	    RT2860_RST_DTX_IDX2 | RT2860_RST_DTX_IDX1 | RT2860_RST_DTX_IDX0);</a>
<a name="ln3840"> </a>
<a name="ln3841">	/* PBF hardware reset */</a>
<a name="ln3842">	RAL_WRITE(sc, RT2860_SYS_CTRL, 0xe1f);</a>
<a name="ln3843">	RAL_BARRIER_WRITE(sc);</a>
<a name="ln3844">	RAL_WRITE(sc, RT2860_SYS_CTRL, 0xe00);</a>
<a name="ln3845"> </a>
<a name="ln3846">	if ((error = rt2860_load_microcode(sc)) != 0) {</a>
<a name="ln3847">		device_printf(sc-&gt;sc_dev, &quot;could not load 8051 microcode\n&quot;);</a>
<a name="ln3848">		rt2860_stop_locked(sc);</a>
<a name="ln3849">		return;</a>
<a name="ln3850">	}</a>
<a name="ln3851"> </a>
<a name="ln3852">	rt2860_set_macaddr(sc, vap ? vap-&gt;iv_myaddr : ic-&gt;ic_macaddr);</a>
<a name="ln3853"> </a>
<a name="ln3854">	/* init Tx power for all Tx rates (from EEPROM) */</a>
<a name="ln3855">	for (ridx = 0; ridx &lt; 5; ridx++) {</a>
<a name="ln3856">		if (sc-&gt;txpow20mhz[ridx] == 0xffffffff)</a>
<a name="ln3857">			continue;</a>
<a name="ln3858">		RAL_WRITE(sc, RT2860_TX_PWR_CFG(ridx), sc-&gt;txpow20mhz[ridx]);</a>
<a name="ln3859">	}</a>
<a name="ln3860"> </a>
<a name="ln3861">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln3862">		tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);</a>
<a name="ln3863">		if ((tmp &amp; (RT2860_TX_DMA_BUSY | RT2860_RX_DMA_BUSY)) == 0)</a>
<a name="ln3864">			break;</a>
<a name="ln3865">		DELAY(1000);</a>
<a name="ln3866">	}</a>
<a name="ln3867">	if (ntries == 100) {</a>
<a name="ln3868">		device_printf(sc-&gt;sc_dev, &quot;timeout waiting for DMA engine\n&quot;);</a>
<a name="ln3869">		rt2860_stop_locked(sc);</a>
<a name="ln3870">		return;</a>
<a name="ln3871">	}</a>
<a name="ln3872">	tmp &amp;= ~(RT2860_RX_DMA_BUSY | RT2860_RX_DMA_EN | RT2860_TX_DMA_BUSY |</a>
<a name="ln3873">	    RT2860_TX_DMA_EN);</a>
<a name="ln3874">	tmp |= RT2860_TX_WB_DDONE;</a>
<a name="ln3875">	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);</a>
<a name="ln3876"> </a>
<a name="ln3877">	/* reset Rx ring and all 6 Tx rings */</a>
<a name="ln3878">	RAL_WRITE(sc, RT2860_WPDMA_RST_IDX, 0x1003f);</a>
<a name="ln3879"> </a>
<a name="ln3880">	/* PBF hardware reset */</a>
<a name="ln3881">	RAL_WRITE(sc, RT2860_SYS_CTRL, 0xe1f);</a>
<a name="ln3882">	RAL_BARRIER_WRITE(sc);</a>
<a name="ln3883">	RAL_WRITE(sc, RT2860_SYS_CTRL, 0xe00);</a>
<a name="ln3884"> </a>
<a name="ln3885">	RAL_WRITE(sc, RT2860_PWR_PIN_CFG, RT2860_IO_RA_PE | RT2860_IO_RF_PE);</a>
<a name="ln3886"> </a>
<a name="ln3887">	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_BBP_HRST | RT2860_MAC_SRST);</a>
<a name="ln3888">	RAL_BARRIER_WRITE(sc);</a>
<a name="ln3889">	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, 0);</a>
<a name="ln3890"> </a>
<a name="ln3891">	for (i = 0; i &lt; nitems(rt2860_def_mac); i++)</a>
<a name="ln3892">		RAL_WRITE(sc, rt2860_def_mac[i].reg, rt2860_def_mac[i].val);</a>
<a name="ln3893">	if (sc-&gt;mac_ver &gt;= 0x5390)</a>
<a name="ln3894">		RAL_WRITE(sc, RT2860_TX_SW_CFG0, 0x00000404);</a>
<a name="ln3895">	else if (sc-&gt;mac_ver &gt;= 0x3071) {</a>
<a name="ln3896">		/* set delay of PA_PE assertion to 1us (unit of 0.25us) */</a>
<a name="ln3897">		RAL_WRITE(sc, RT2860_TX_SW_CFG0,</a>
<a name="ln3898">		    4 &lt;&lt; RT2860_DLY_PAPE_EN_SHIFT);</a>
<a name="ln3899">	}</a>
<a name="ln3900"> </a>
<a name="ln3901">	if (!(RAL_READ(sc, RT2860_PCI_CFG) &amp; RT2860_PCI_CFG_PCI)) {</a>
<a name="ln3902">		sc-&gt;sc_flags |= RT2860_PCIE;</a>
<a name="ln3903">		/* PCIe has different clock cycle count than PCI */</a>
<a name="ln3904">		tmp = RAL_READ(sc, RT2860_US_CYC_CNT);</a>
<a name="ln3905">		tmp = (tmp &amp; ~0xff) | 0x7d;</a>
<a name="ln3906">		RAL_WRITE(sc, RT2860_US_CYC_CNT, tmp);</a>
<a name="ln3907">	}</a>
<a name="ln3908"> </a>
<a name="ln3909">	/* wait while MAC is busy */</a>
<a name="ln3910">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln3911">		if (!(RAL_READ(sc, RT2860_MAC_STATUS_REG) &amp;</a>
<a name="ln3912">		    (RT2860_RX_STATUS_BUSY | RT2860_TX_STATUS_BUSY)))</a>
<a name="ln3913">			break;</a>
<a name="ln3914">		DELAY(1000);</a>
<a name="ln3915">	}</a>
<a name="ln3916">	if (ntries == 100) {</a>
<a name="ln3917">		device_printf(sc-&gt;sc_dev, &quot;timeout waiting for MAC\n&quot;);</a>
<a name="ln3918">		rt2860_stop_locked(sc);</a>
<a name="ln3919">		return;</a>
<a name="ln3920">	}</a>
<a name="ln3921"> </a>
<a name="ln3922">	/* clear Host to MCU mailbox */</a>
<a name="ln3923">	RAL_WRITE(sc, RT2860_H2M_BBPAGENT, 0);</a>
<a name="ln3924">	RAL_WRITE(sc, RT2860_H2M_MAILBOX, 0);</a>
<a name="ln3925"> </a>
<a name="ln3926">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_RFRESET, 0, 0);</a>
<a name="ln3927">	DELAY(1000);</a>
<a name="ln3928"> </a>
<a name="ln3929">	if ((error = rt2860_bbp_init(sc)) != 0) {</a>
<a name="ln3930">		rt2860_stop_locked(sc);</a>
<a name="ln3931">		return;</a>
<a name="ln3932">	}</a>
<a name="ln3933"> </a>
<a name="ln3934">	/* clear RX WCID search table */</a>
<a name="ln3935">	RAL_SET_REGION_4(sc, RT2860_WCID_ENTRY(0), 0, 512);</a>
<a name="ln3936">	/* clear pairwise key table */</a>
<a name="ln3937">	RAL_SET_REGION_4(sc, RT2860_PKEY(0), 0, 2048);</a>
<a name="ln3938">	/* clear IV/EIV table */</a>
<a name="ln3939">	RAL_SET_REGION_4(sc, RT2860_IVEIV(0), 0, 512);</a>
<a name="ln3940">	/* clear WCID attribute table */</a>
<a name="ln3941">	RAL_SET_REGION_4(sc, RT2860_WCID_ATTR(0), 0, 256);</a>
<a name="ln3942">	/* clear shared key table */</a>
<a name="ln3943">	RAL_SET_REGION_4(sc, RT2860_SKEY(0, 0), 0, 8 * 32);</a>
<a name="ln3944">	/* clear shared key mode */</a>
<a name="ln3945">	RAL_SET_REGION_4(sc, RT2860_SKEY_MODE_0_7, 0, 4);</a>
<a name="ln3946"> </a>
<a name="ln3947">	/* init Tx rings (4 EDCAs + HCCA + Mgt) */</a>
<a name="ln3948">	for (qid = 0; qid &lt; 6; qid++) {</a>
<a name="ln3949">		RAL_WRITE(sc, RT2860_TX_BASE_PTR(qid), sc-&gt;txq[qid].paddr);</a>
<a name="ln3950">		RAL_WRITE(sc, RT2860_TX_MAX_CNT(qid), RT2860_TX_RING_COUNT);</a>
<a name="ln3951">		RAL_WRITE(sc, RT2860_TX_CTX_IDX(qid), 0);</a>
<a name="ln3952">	}</a>
<a name="ln3953"> </a>
<a name="ln3954">	/* init Rx ring */</a>
<a name="ln3955">	RAL_WRITE(sc, RT2860_RX_BASE_PTR, sc-&gt;rxq.paddr);</a>
<a name="ln3956">	RAL_WRITE(sc, RT2860_RX_MAX_CNT, RT2860_RX_RING_COUNT);</a>
<a name="ln3957">	RAL_WRITE(sc, RT2860_RX_CALC_IDX, RT2860_RX_RING_COUNT - 1);</a>
<a name="ln3958"> </a>
<a name="ln3959">	/* setup maximum buffer sizes */</a>
<a name="ln3960">	RAL_WRITE(sc, RT2860_MAX_LEN_CFG, 1 &lt;&lt; 12 |</a>
<a name="ln3961">	    (MCLBYTES - sizeof (struct rt2860_rxwi) - 2));</a>
<a name="ln3962"> </a>
<a name="ln3963">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln3964">		tmp = RAL_READ(sc, RT2860_WPDMA_GLO_CFG);</a>
<a name="ln3965">		if ((tmp &amp; (RT2860_TX_DMA_BUSY | RT2860_RX_DMA_BUSY)) == 0)</a>
<a name="ln3966">			break;</a>
<a name="ln3967">		DELAY(1000);</a>
<a name="ln3968">	}</a>
<a name="ln3969">	if (ntries == 100) {</a>
<a name="ln3970">		device_printf(sc-&gt;sc_dev, &quot;timeout waiting for DMA engine\n&quot;);</a>
<a name="ln3971">		rt2860_stop_locked(sc);</a>
<a name="ln3972">		return;</a>
<a name="ln3973">	}</a>
<a name="ln3974">	tmp &amp;= ~(RT2860_RX_DMA_BUSY | RT2860_RX_DMA_EN | RT2860_TX_DMA_BUSY |</a>
<a name="ln3975">	    RT2860_TX_DMA_EN);</a>
<a name="ln3976">	tmp |= RT2860_TX_WB_DDONE;</a>
<a name="ln3977">	RAL_WRITE(sc, RT2860_WPDMA_GLO_CFG, tmp);</a>
<a name="ln3978"> </a>
<a name="ln3979">	/* disable interrupts mitigation */</a>
<a name="ln3980">	RAL_WRITE(sc, RT2860_DELAY_INT_CFG, 0);</a>
<a name="ln3981"> </a>
<a name="ln3982">	/* write vendor-specific BBP values (from EEPROM) */</a>
<a name="ln3983">	for (i = 0; i &lt; 8; i++) {</a>
<a name="ln3984">		if (sc-&gt;bbp[i].reg == 0 || sc-&gt;bbp[i].reg == 0xff)</a>
<a name="ln3985">			continue;</a>
<a name="ln3986">		rt2860_mcu_bbp_write(sc, sc-&gt;bbp[i].reg, sc-&gt;bbp[i].val);</a>
<a name="ln3987">	}</a>
<a name="ln3988"> </a>
<a name="ln3989">	/* select Main antenna for 1T1R devices */</a>
<a name="ln3990">	if (sc-&gt;rf_rev == RT3070_RF_2020 ||</a>
<a name="ln3991">	    sc-&gt;rf_rev == RT3070_RF_3020 ||</a>
<a name="ln3992">	    sc-&gt;rf_rev == RT3070_RF_3320 ||</a>
<a name="ln3993">	    sc-&gt;mac_ver == 0x5390)</a>
<a name="ln3994">		rt3090_set_rx_antenna(sc, 0);</a>
<a name="ln3995"> </a>
<a name="ln3996">	/* send LEDs operating mode to microcontroller */</a>
<a name="ln3997">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED1, sc-&gt;led[0], 0);</a>
<a name="ln3998">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED2, sc-&gt;led[1], 0);</a>
<a name="ln3999">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_LED3, sc-&gt;led[2], 0);</a>
<a name="ln4000"> </a>
<a name="ln4001">	if (sc-&gt;mac_ver &gt;= 0x5390)</a>
<a name="ln4002">		rt5390_rf_init(sc);</a>
<a name="ln4003">	else if (sc-&gt;mac_ver &gt;= 0x3071) {</a>
<a name="ln4004">		if ((error = rt3090_rf_init(sc)) != 0) {</a>
<a name="ln4005">			rt2860_stop_locked(sc);</a>
<a name="ln4006">			return;</a>
<a name="ln4007">		}</a>
<a name="ln4008">	}</a>
<a name="ln4009"> </a>
<a name="ln4010">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_SLEEP, 0x02ff, 1);</a>
<a name="ln4011">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_WAKEUP, 0, 1);</a>
<a name="ln4012"> </a>
<a name="ln4013">	if (sc-&gt;mac_ver &gt;= 0x5390)</a>
<a name="ln4014">		rt5390_rf_wakeup(sc);</a>
<a name="ln4015">	else if (sc-&gt;mac_ver &gt;= 0x3071)</a>
<a name="ln4016">		rt3090_rf_wakeup(sc);</a>
<a name="ln4017"> </a>
<a name="ln4018">	/* disable non-existing Rx chains */</a>
<a name="ln4019">	bbp3 = rt2860_mcu_bbp_read(sc, 3);</a>
<a name="ln4020">	bbp3 &amp;= ~(1 &lt;&lt; 3 | 1 &lt;&lt; 4);</a>
<a name="ln4021">	if (sc-&gt;nrxchains == 2)</a>
<a name="ln4022">		bbp3 |= 1 &lt;&lt; 3;</a>
<a name="ln4023">	else if (sc-&gt;nrxchains == 3)</a>
<a name="ln4024">		bbp3 |= 1 &lt;&lt; 4;</a>
<a name="ln4025">	rt2860_mcu_bbp_write(sc, 3, bbp3);</a>
<a name="ln4026"> </a>
<a name="ln4027">	/* disable non-existing Tx chains */</a>
<a name="ln4028">	bbp1 = rt2860_mcu_bbp_read(sc, 1);</a>
<a name="ln4029">	if (sc-&gt;ntxchains == 1)</a>
<a name="ln4030">		bbp1 = (bbp1 &amp; ~(1 &lt;&lt; 3 | 1 &lt;&lt; 4));</a>
<a name="ln4031">	else if (sc-&gt;mac_ver == 0x3593 &amp;&amp; sc-&gt;ntxchains == 2)</a>
<a name="ln4032">		bbp1 = (bbp1 &amp; ~(1 &lt;&lt; 4)) | 1 &lt;&lt; 3;</a>
<a name="ln4033">	else if (sc-&gt;mac_ver == 0x3593 &amp;&amp; sc-&gt;ntxchains == 3)</a>
<a name="ln4034">		bbp1 = (bbp1 &amp; ~(1 &lt;&lt; 3)) | 1 &lt;&lt; 4;</a>
<a name="ln4035">	rt2860_mcu_bbp_write(sc, 1, bbp1);</a>
<a name="ln4036"> </a>
<a name="ln4037">	if (sc-&gt;mac_ver &gt;= 0x3071)</a>
<a name="ln4038">		rt3090_rf_setup(sc);</a>
<a name="ln4039"> </a>
<a name="ln4040">	/* select default channel */</a>
<a name="ln4041">	rt2860_switch_chan(sc, ic-&gt;ic_curchan);</a>
<a name="ln4042"> </a>
<a name="ln4043">	/* reset RF from MCU */</a>
<a name="ln4044">	rt2860_mcu_cmd(sc, RT2860_MCU_CMD_RFRESET, 0, 0);</a>
<a name="ln4045"> </a>
<a name="ln4046">	/* set RTS threshold */</a>
<a name="ln4047">	tmp = RAL_READ(sc, RT2860_TX_RTS_CFG);</a>
<a name="ln4048">	tmp &amp;= ~0xffff00;</a>
<a name="ln4049">	tmp |= IEEE80211_RTS_DEFAULT &lt;&lt; 8;</a>
<a name="ln4050">	RAL_WRITE(sc, RT2860_TX_RTS_CFG, tmp);</a>
<a name="ln4051"> </a>
<a name="ln4052">	/* setup initial protection mode */</a>
<a name="ln4053">	rt2860_updateprot(sc);</a>
<a name="ln4054"> </a>
<a name="ln4055">	/* turn radio LED on */</a>
<a name="ln4056">	rt2860_set_leds(sc, RT2860_LED_RADIO);</a>
<a name="ln4057"> </a>
<a name="ln4058">	/* enable Tx/Rx DMA engine */</a>
<a name="ln4059">	if ((error = rt2860_txrx_enable(sc)) != 0) {</a>
<a name="ln4060">		rt2860_stop_locked(sc);</a>
<a name="ln4061">		return;</a>
<a name="ln4062">	}</a>
<a name="ln4063"> </a>
<a name="ln4064">	/* clear pending interrupts */</a>
<a name="ln4065">	RAL_WRITE(sc, RT2860_INT_STATUS, 0xffffffff);</a>
<a name="ln4066">	/* enable interrupts */</a>
<a name="ln4067">	RAL_WRITE(sc, RT2860_INT_MASK, 0x3fffc);</a>
<a name="ln4068"> </a>
<a name="ln4069">	if (sc-&gt;sc_flags &amp; RT2860_ADVANCED_PS)</a>
<a name="ln4070">		rt2860_mcu_cmd(sc, RT2860_MCU_CMD_PSLEVEL, sc-&gt;pslevel, 0);</a>
<a name="ln4071"> </a>
<a name="ln4072">	sc-&gt;sc_flags |= RT2860_RUNNING;</a>
<a name="ln4073"> </a>
<a name="ln4074">	callout_reset(&amp;sc-&gt;watchdog_ch, hz, rt2860_watchdog, sc);</a>
<a name="ln4075">}</a>
<a name="ln4076"> </a>
<a name="ln4077">static void</a>
<a name="ln4078">rt2860_stop(void *arg)</a>
<a name="ln4079">{</a>
<a name="ln4080">	struct rt2860_softc *sc = arg;</a>
<a name="ln4081"> </a>
<a name="ln4082">	RAL_LOCK(sc);</a>
<a name="ln4083">	rt2860_stop_locked(sc);</a>
<a name="ln4084">	RAL_UNLOCK(sc);</a>
<a name="ln4085">}</a>
<a name="ln4086"> </a>
<a name="ln4087">static void</a>
<a name="ln4088">rt2860_stop_locked(struct rt2860_softc *sc)</a>
<a name="ln4089">{</a>
<a name="ln4090">	uint32_t tmp;</a>
<a name="ln4091">	int qid;</a>
<a name="ln4092"> </a>
<a name="ln4093">	if (sc-&gt;sc_flags &amp; RT2860_RUNNING)</a>
<a name="ln4094">		rt2860_set_leds(sc, 0);	/* turn all LEDs off */</a>
<a name="ln4095"> </a>
<a name="ln4096">	callout_stop(&amp;sc-&gt;watchdog_ch);</a>
<a name="ln4097">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln4098">	sc-&gt;sc_flags &amp;= ~RT2860_RUNNING;</a>
<a name="ln4099"> </a>
<a name="ln4100">	/* disable interrupts */</a>
<a name="ln4101">	RAL_WRITE(sc, RT2860_INT_MASK, 0);</a>
<a name="ln4102"> </a>
<a name="ln4103">	/* disable GP timer */</a>
<a name="ln4104">	rt2860_set_gp_timer(sc, 0);</a>
<a name="ln4105"> </a>
<a name="ln4106">	/* disable Rx */</a>
<a name="ln4107">	tmp = RAL_READ(sc, RT2860_MAC_SYS_CTRL);</a>
<a name="ln4108">	tmp &amp;= ~(RT2860_MAC_RX_EN | RT2860_MAC_TX_EN);</a>
<a name="ln4109">	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, tmp);</a>
<a name="ln4110"> </a>
<a name="ln4111">	/* reset adapter */</a>
<a name="ln4112">	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, RT2860_BBP_HRST | RT2860_MAC_SRST);</a>
<a name="ln4113">	RAL_BARRIER_WRITE(sc);</a>
<a name="ln4114">	RAL_WRITE(sc, RT2860_MAC_SYS_CTRL, 0);</a>
<a name="ln4115"> </a>
<a name="ln4116">	/* reset Tx and Rx rings (and reclaim TXWIs) */</a>
<a name="ln4117">	sc-&gt;qfullmsk = 0;</a>
<a name="ln4118">	for (qid = 0; qid &lt; 6; qid++)</a>
<a name="ln4119">		rt2860_reset_tx_ring(sc, &amp;sc-&gt;txq[qid]);</a>
<a name="ln4120">	rt2860_reset_rx_ring(sc, &amp;sc-&gt;rxq);</a>
<a name="ln4121">}</a>
<a name="ln4122"> </a>
<a name="ln4123">int</a>
<a name="ln4124">rt2860_load_microcode(struct rt2860_softc *sc)</a>
<a name="ln4125">{</a>
<a name="ln4126">	const struct firmware *fp;</a>
<a name="ln4127">	int ntries, error;</a>
<a name="ln4128"> </a>
<a name="ln4129">	RAL_LOCK_ASSERT(sc);</a>
<a name="ln4130"> </a>
<a name="ln4131">	RAL_UNLOCK(sc);</a>
<a name="ln4132">	fp = firmware_get(&quot;rt2860fw&quot;);</a>
<a name="ln4133">	RAL_LOCK(sc);</a>
<a name="ln4134">	if (fp == NULL) {</a>
<a name="ln4135">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4136">		    &quot;unable to receive rt2860fw firmware image\n&quot;);</a>
<a name="ln4137">		return EINVAL;</a>
<a name="ln4138">	}</a>
<a name="ln4139"> </a>
<a name="ln4140">	/* set &quot;host program ram write selection&quot; bit */</a>
<a name="ln4141">	RAL_WRITE(sc, RT2860_SYS_CTRL, RT2860_HST_PM_SEL);</a>
<a name="ln4142">	/* write microcode image */</a>
<a name="ln4143">	RAL_WRITE_REGION_1(sc, RT2860_FW_BASE, fp-&gt;data, fp-&gt;datasize);</a>
<a name="ln4144">	/* kick microcontroller unit */</a>
<a name="ln4145">	RAL_WRITE(sc, RT2860_SYS_CTRL, 0);</a>
<a name="ln4146">	RAL_BARRIER_WRITE(sc);</a>
<a name="ln4147">	RAL_WRITE(sc, RT2860_SYS_CTRL, RT2860_MCU_RESET);</a>
<a name="ln4148"> </a>
<a name="ln4149">	RAL_WRITE(sc, RT2860_H2M_BBPAGENT, 0);</a>
<a name="ln4150">	RAL_WRITE(sc, RT2860_H2M_MAILBOX, 0);</a>
<a name="ln4151"> </a>
<a name="ln4152">	/* wait until microcontroller is ready */</a>
<a name="ln4153">	RAL_BARRIER_READ_WRITE(sc);</a>
<a name="ln4154">	for (ntries = 0; ntries &lt; 1000; ntries++) {</a>
<a name="ln4155">		if (RAL_READ(sc, RT2860_SYS_CTRL) &amp; RT2860_MCU_READY)</a>
<a name="ln4156">			break;</a>
<a name="ln4157">		DELAY(1000);</a>
<a name="ln4158">	}</a>
<a name="ln4159">	if (ntries == 1000) {</a>
<a name="ln4160">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4161">		    &quot;timeout waiting for MCU to initialize\n&quot;);</a>
<a name="ln4162">		error = ETIMEDOUT;</a>
<a name="ln4163">	} else</a>
<a name="ln4164">		error = 0;</a>
<a name="ln4165"> </a>
<a name="ln4166">	firmware_put(fp, FIRMWARE_UNLOAD);</a>
<a name="ln4167">	return error;</a>
<a name="ln4168">}</a>
<a name="ln4169"> </a>
<a name="ln4170">/*</a>
<a name="ln4171"> * This function is called periodically to adjust Tx power based on</a>
<a name="ln4172"> * temperature variation.</a>
<a name="ln4173"> */</a>
<a name="ln4174">#ifdef NOT_YET</a>
<a name="ln4175">static void</a>
<a name="ln4176">rt2860_calib(struct rt2860_softc *sc)</a>
<a name="ln4177">{</a>
<a name="ln4178">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4179">	const uint8_t *tssi;</a>
<a name="ln4180">	uint8_t step, bbp49;</a>
<a name="ln4181">	int8_t ridx, d;</a>
<a name="ln4182"> </a>
<a name="ln4183">	/* read current temperature */</a>
<a name="ln4184">	bbp49 = rt2860_mcu_bbp_read(sc, 49);</a>
<a name="ln4185"> </a>
<a name="ln4186">	if (IEEE80211_IS_CHAN_2GHZ(ic-&gt;ic_bss-&gt;ni_chan)) {</a>
<a name="ln4187">		tssi = &amp;sc-&gt;tssi_2ghz[4];</a>
<a name="ln4188">		step = sc-&gt;step_2ghz;</a>
<a name="ln4189">	} else {</a>
<a name="ln4190">		tssi = &amp;sc-&gt;tssi_5ghz[4];</a>
<a name="ln4191">		step = sc-&gt;step_5ghz;</a>
<a name="ln4192">	}</a>
<a name="ln4193"> </a>
<a name="ln4194">	if (bbp49 &lt; tssi[0]) {		/* lower than reference */</a>
<a name="ln4195">		/* use higher Tx power than default */</a>
<a name="ln4196">		for (d = 0; d &gt; -4 &amp;&amp; bbp49 &lt;= tssi[d - 1]; d--);</a>
<a name="ln4197">	} else if (bbp49 &gt; tssi[0]) {	/* greater than reference */</a>
<a name="ln4198">		/* use lower Tx power than default */</a>
<a name="ln4199">		for (d = 0; d &lt; +4 &amp;&amp; bbp49 &gt;= tssi[d + 1]; d++);</a>
<a name="ln4200">	} else {</a>
<a name="ln4201">		/* use default Tx power */</a>
<a name="ln4202">		d = 0;</a>
<a name="ln4203">	}</a>
<a name="ln4204">	d *= step;</a>
<a name="ln4205"> </a>
<a name="ln4206">	DPRINTF((&quot;BBP49=0x%02x, adjusting Tx power by %d\n&quot;, bbp49, d));</a>
<a name="ln4207"> </a>
<a name="ln4208">	/* write adjusted Tx power values for each Tx rate */</a>
<a name="ln4209">	for (ridx = 0; ridx &lt; 5; ridx++) {</a>
<a name="ln4210">		if (sc-&gt;txpow20mhz[ridx] == 0xffffffff)</a>
<a name="ln4211">			continue;</a>
<a name="ln4212">		RAL_WRITE(sc, RT2860_TX_PWR_CFG(ridx),</a>
<a name="ln4213">		    b4inc(sc-&gt;txpow20mhz[ridx], d));</a>
<a name="ln4214">	}</a>
<a name="ln4215">}</a>
<a name="ln4216">#endif</a>
<a name="ln4217"> </a>
<a name="ln4218">static void</a>
<a name="ln4219">rt3090_set_rx_antenna(struct rt2860_softc *sc, int aux)</a>
<a name="ln4220">{</a>
<a name="ln4221">	uint32_t tmp;</a>
<a name="ln4222"> </a>
<a name="ln4223">	if (aux) {</a>
<a name="ln4224">		if (sc-&gt;mac_ver == 0x5390) {</a>
<a name="ln4225">			rt2860_mcu_bbp_write(sc, 152, </a>
<a name="ln4226">			    rt2860_mcu_bbp_read(sc, 152) &amp; ~0x80);</a>
<a name="ln4227">		} else {</a>
<a name="ln4228">			tmp = RAL_READ(sc, RT2860_PCI_EECTRL);</a>
<a name="ln4229">			RAL_WRITE(sc, RT2860_PCI_EECTRL, tmp &amp; ~RT2860_C);</a>
<a name="ln4230">			tmp = RAL_READ(sc, RT2860_GPIO_CTRL);</a>
<a name="ln4231">			RAL_WRITE(sc, RT2860_GPIO_CTRL, (tmp &amp; ~0x0808) | 0x08);</a>
<a name="ln4232">		}</a>
<a name="ln4233">	} else {</a>
<a name="ln4234">		if (sc-&gt;mac_ver == 0x5390) {</a>
<a name="ln4235">			rt2860_mcu_bbp_write(sc, 152, </a>
<a name="ln4236">			    rt2860_mcu_bbp_read(sc, 152) | 0x80);</a>
<a name="ln4237">		} else {</a>
<a name="ln4238">			tmp = RAL_READ(sc, RT2860_PCI_EECTRL);</a>
<a name="ln4239">			RAL_WRITE(sc, RT2860_PCI_EECTRL, tmp | RT2860_C);</a>
<a name="ln4240">			tmp = RAL_READ(sc, RT2860_GPIO_CTRL);</a>
<a name="ln4241">			RAL_WRITE(sc, RT2860_GPIO_CTRL, tmp &amp; ~0x0808);</a>
<a name="ln4242">		}</a>
<a name="ln4243">	}</a>
<a name="ln4244">}</a>
<a name="ln4245"> </a>
<a name="ln4246">static void</a>
<a name="ln4247">rt2860_switch_chan(struct rt2860_softc *sc, struct ieee80211_channel *c)</a>
<a name="ln4248">{</a>
<a name="ln4249">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4250">	u_int chan, group;</a>
<a name="ln4251"> </a>
<a name="ln4252">	chan = ieee80211_chan2ieee(ic, c);</a>
<a name="ln4253">	if (chan == 0 || chan == IEEE80211_CHAN_ANY)</a>
<a name="ln4254">		return;</a>
<a name="ln4255"> </a>
<a name="ln4256">	if (sc-&gt;mac_ver &gt;= 0x5390)</a>
<a name="ln4257">		rt5390_set_chan(sc, chan);</a>
<a name="ln4258">	else if (sc-&gt;mac_ver &gt;= 0x3071)</a>
<a name="ln4259">		rt3090_set_chan(sc, chan);</a>
<a name="ln4260">	else</a>
<a name="ln4261">		rt2860_set_chan(sc, chan);</a>
<a name="ln4262"> </a>
<a name="ln4263">	/* determine channel group */</a>
<a name="ln4264">	if (chan &lt;= 14)</a>
<a name="ln4265">		group = 0;</a>
<a name="ln4266">	else if (chan &lt;= 64)</a>
<a name="ln4267">		group = 1;</a>
<a name="ln4268">	else if (chan &lt;= 128)</a>
<a name="ln4269">		group = 2;</a>
<a name="ln4270">	else</a>
<a name="ln4271">		group = 3;</a>
<a name="ln4272"> </a>
<a name="ln4273">	/* XXX necessary only when group has changed! */</a>
<a name="ln4274">	if (sc-&gt;mac_ver &lt; 0x5390)</a>
<a name="ln4275">		rt2860_select_chan_group(sc, group);</a>
<a name="ln4276"> </a>
<a name="ln4277">	DELAY(1000);</a>
<a name="ln4278">}</a>
<a name="ln4279"> </a>
<a name="ln4280">static int</a>
<a name="ln4281">rt2860_setup_beacon(struct rt2860_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln4282">{</a>
<a name="ln4283">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln4284">	struct rt2860_txwi txwi;</a>
<a name="ln4285">	struct mbuf *m;</a>
<a name="ln4286">	int ridx;</a>
<a name="ln4287"> </a>
<a name="ln4288">	if ((m = ieee80211_beacon_alloc(vap-&gt;iv_bss)) == NULL)</a>
<a name="ln4289">		return ENOBUFS;</a>
<a name="ln4290"> </a>
<a name="ln4291">	memset(&amp;txwi, 0, sizeof txwi);</a>
<a name="ln4292">	txwi.wcid = 0xff;</a>
<a name="ln4293">	txwi.len = htole16(m-&gt;m_pkthdr.len);</a>
<a name="ln4294">	/* send beacons at the lowest available rate */</a>
<a name="ln4295">	ridx = IEEE80211_IS_CHAN_5GHZ(ic-&gt;ic_bsschan) ?</a>
<a name="ln4296">	    RT2860_RIDX_OFDM6 : RT2860_RIDX_CCK1;</a>
<a name="ln4297">	txwi.phy = htole16(rt2860_rates[ridx].mcs);</a>
<a name="ln4298">	if (rt2860_rates[ridx].phy == IEEE80211_T_OFDM)</a>
<a name="ln4299">		txwi.phy |= htole16(RT2860_PHY_OFDM);</a>
<a name="ln4300">	txwi.txop = RT2860_TX_TXOP_HT;</a>
<a name="ln4301">	txwi.flags = RT2860_TX_TS;</a>
<a name="ln4302">	txwi.xflags = RT2860_TX_NSEQ;</a>
<a name="ln4303"> </a>
<a name="ln4304">	RAL_WRITE_REGION_1(sc, RT2860_BCN_BASE(0),</a>
<a name="ln4305">	    (uint8_t *)&amp;txwi, sizeof txwi);</a>
<a name="ln4306">	RAL_WRITE_REGION_1(sc, RT2860_BCN_BASE(0) + sizeof txwi,</a>
<a name="ln4307">	    mtod(m, uint8_t *), m-&gt;m_pkthdr.len);</a>
<a name="ln4308"> </a>
<a name="ln4309">	m_freem(m);</a>
<a name="ln4310"> </a>
<a name="ln4311">	return 0;</a>
<a name="ln4312">}</a>
<a name="ln4313"> </a>
<a name="ln4314">static void</a>
<a name="ln4315">rt2860_enable_tsf_sync(struct rt2860_softc *sc)</a>
<a name="ln4316">{</a>
<a name="ln4317">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4318">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln4319">	uint32_t tmp;</a>
<a name="ln4320"> </a>
<a name="ln4321">	tmp = RAL_READ(sc, RT2860_BCN_TIME_CFG);</a>
<a name="ln4322"> </a>
<a name="ln4323">	tmp &amp;= ~0x1fffff;</a>
<a name="ln4324">	tmp |= vap-&gt;iv_bss-&gt;ni_intval * 16;</a>
<a name="ln4325">	tmp |= RT2860_TSF_TIMER_EN | RT2860_TBTT_TIMER_EN;</a>
<a name="ln4326">	if (vap-&gt;iv_opmode == IEEE80211_M_STA) {</a>
<a name="ln4327">		/*</a>
<a name="ln4328">		 * Local TSF is always updated with remote TSF on beacon</a>
<a name="ln4329">		 * reception.</a>
<a name="ln4330">		 */</a>
<a name="ln4331">		tmp |= 1 &lt;&lt; RT2860_TSF_SYNC_MODE_SHIFT;</a>
<a name="ln4332">	}</a>
<a name="ln4333">	else if (vap-&gt;iv_opmode == IEEE80211_M_IBSS ||</a>
<a name="ln4334">	    vap-&gt;iv_opmode == IEEE80211_M_MBSS) {</a>
<a name="ln4335">		tmp |= RT2860_BCN_TX_EN;</a>
<a name="ln4336">		/*</a>
<a name="ln4337">		 * Local TSF is updated with remote TSF on beacon reception</a>
<a name="ln4338">		 * only if the remote TSF is greater than local TSF.</a>
<a name="ln4339">		 */</a>
<a name="ln4340">		tmp |= 2 &lt;&lt; RT2860_TSF_SYNC_MODE_SHIFT;</a>
<a name="ln4341">	} else if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP) {</a>
<a name="ln4342">		tmp |= RT2860_BCN_TX_EN;</a>
<a name="ln4343">		/* SYNC with nobody */</a>
<a name="ln4344">		tmp |= 3 &lt;&lt; RT2860_TSF_SYNC_MODE_SHIFT;</a>
<a name="ln4345">	}</a>
<a name="ln4346"> </a>
<a name="ln4347">	RAL_WRITE(sc, RT2860_BCN_TIME_CFG, tmp);</a>
<a name="ln4348">}</a>

</code></pre>
<div class="balloon" rel="1097"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'wcid' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 1097, 1100.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
