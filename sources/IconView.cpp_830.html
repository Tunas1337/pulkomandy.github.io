
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>IconView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2007, Axel DÃ¶rfler, axeld@pinc-software.de. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;IconView.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;new&gt;</a>
<a name="ln10">#include &lt;stdlib.h&gt;</a>
<a name="ln11">#include &lt;strings.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;Application.h&gt;</a>
<a name="ln14">#include &lt;AppFileInfo.h&gt;</a>
<a name="ln15">#include &lt;Attributes.h&gt;</a>
<a name="ln16">#include &lt;Bitmap.h&gt;</a>
<a name="ln17">#include &lt;Catalog.h&gt;</a>
<a name="ln18">#include &lt;IconEditorProtocol.h&gt;</a>
<a name="ln19">#include &lt;IconUtils.h&gt;</a>
<a name="ln20">#include &lt;Locale.h&gt;</a>
<a name="ln21">#include &lt;MenuItem.h&gt;</a>
<a name="ln22">#include &lt;Mime.h&gt;</a>
<a name="ln23">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln24">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln25">#include &lt;Resources.h&gt;</a>
<a name="ln26">#include &lt;Roster.h&gt;</a>
<a name="ln27">#include &lt;Size.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;FileTypes.h&quot;</a>
<a name="ln30">#include &quot;MimeTypeListView.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln34">#define B_TRANSLATION_CONTEXT &quot;Icon View&quot;</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">using namespace std;</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">status_t</a>
<a name="ln41">icon_for_type(const BMimeType&amp; type, uint8** _data, size_t* _size,</a>
<a name="ln42">	icon_source* _source)</a>
<a name="ln43">{</a>
<a name="ln44">	if (_data == NULL || _size == NULL)</a>
<a name="ln45">		return B_BAD_VALUE;</a>
<a name="ln46"> </a>
<a name="ln47">	icon_source source = kNoIcon;</a>
<a name="ln48">	uint8* data;</a>
<a name="ln49">	size_t size;</a>
<a name="ln50"> </a>
<a name="ln51">	if (type.GetIcon(&amp;data, &amp;size) == B_OK)</a>
<a name="ln52">		source = kOwnIcon;</a>
<a name="ln53"> </a>
<a name="ln54">	if (source == kNoIcon) {</a>
<a name="ln55">		// check for icon from preferred app</a>
<a name="ln56"> </a>
<a name="ln57">		char preferred[B_MIME_TYPE_LENGTH];</a>
<a name="ln58">		if (type.GetPreferredApp(preferred) == B_OK) {</a>
<a name="ln59">			BMimeType preferredApp(preferred);</a>
<a name="ln60"> </a>
<a name="ln61">			if (preferredApp.GetIconForType(type.Type(), &amp;data, &amp;size) == B_OK)</a>
<a name="ln62">				source = kApplicationIcon;</a>
<a name="ln63">		}</a>
<a name="ln64">	}</a>
<a name="ln65"> </a>
<a name="ln66">	if (source == kNoIcon) {</a>
<a name="ln67">		// check super type for an icon</a>
<a name="ln68"> </a>
<a name="ln69">		BMimeType superType;</a>
<a name="ln70">		if (type.GetSupertype(&amp;superType) == B_OK) {</a>
<a name="ln71">			if (superType.GetIcon(&amp;data, &amp;size) == B_OK)</a>
<a name="ln72">				source = kSupertypeIcon;</a>
<a name="ln73">			else {</a>
<a name="ln74">				// check the super type's preferred app</a>
<a name="ln75">				char preferred[B_MIME_TYPE_LENGTH];</a>
<a name="ln76">				if (superType.GetPreferredApp(preferred) == B_OK) {</a>
<a name="ln77">					BMimeType preferredApp(preferred);</a>
<a name="ln78"> </a>
<a name="ln79">					if (preferredApp.GetIconForType(superType.Type(),</a>
<a name="ln80">							&amp;data, &amp;size) == B_OK)</a>
<a name="ln81">						source = kSupertypeIcon;</a>
<a name="ln82">				}</a>
<a name="ln83">			}</a>
<a name="ln84">		}</a>
<a name="ln85">	}</a>
<a name="ln86"> </a>
<a name="ln87">	if (source != kNoIcon) {</a>
<a name="ln88">		*_data = data;</a>
<a name="ln89">		*_size = size;</a>
<a name="ln90">	} // NOTE: else there is no data, so nothing is leaked.</a>
<a name="ln91">	if (_source)</a>
<a name="ln92">		*_source = source;</a>
<a name="ln93"> </a>
<a name="ln94">	return source != kNoIcon ? B_OK : B_ERROR;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">status_t</a>
<a name="ln99">icon_for_type(const BMimeType&amp; type, BBitmap&amp; bitmap, icon_size size,</a>
<a name="ln100">	icon_source* _source)</a>
<a name="ln101">{</a>
<a name="ln102">	icon_source source = kNoIcon;</a>
<a name="ln103"> </a>
<a name="ln104">	if (type.GetIcon(&amp;bitmap, size) == B_OK)</a>
<a name="ln105">		source = kOwnIcon;</a>
<a name="ln106"> </a>
<a name="ln107">	if (source == kNoIcon) {</a>
<a name="ln108">		// check for icon from preferred app</a>
<a name="ln109"> </a>
<a name="ln110">		char preferred[B_MIME_TYPE_LENGTH];</a>
<a name="ln111">		if (type.GetPreferredApp(preferred) == B_OK) {</a>
<a name="ln112">			BMimeType preferredApp(preferred);</a>
<a name="ln113"> </a>
<a name="ln114">			if (preferredApp.GetIconForType(type.Type(), &amp;bitmap, size) == B_OK)</a>
<a name="ln115">				source = kApplicationIcon;</a>
<a name="ln116">		}</a>
<a name="ln117">	}</a>
<a name="ln118"> </a>
<a name="ln119">	if (source == kNoIcon) {</a>
<a name="ln120">		// check super type for an icon</a>
<a name="ln121"> </a>
<a name="ln122">		BMimeType superType;</a>
<a name="ln123">		if (type.GetSupertype(&amp;superType) == B_OK) {</a>
<a name="ln124">			if (superType.GetIcon(&amp;bitmap, size) == B_OK)</a>
<a name="ln125">				source = kSupertypeIcon;</a>
<a name="ln126">			else {</a>
<a name="ln127">				// check the super type's preferred app</a>
<a name="ln128">				char preferred[B_MIME_TYPE_LENGTH];</a>
<a name="ln129">				if (superType.GetPreferredApp(preferred) == B_OK) {</a>
<a name="ln130">					BMimeType preferredApp(preferred);</a>
<a name="ln131"> </a>
<a name="ln132">					if (preferredApp.GetIconForType(superType.Type(),</a>
<a name="ln133">							&amp;bitmap, size) == B_OK)</a>
<a name="ln134">						source = kSupertypeIcon;</a>
<a name="ln135">				}</a>
<a name="ln136">			}</a>
<a name="ln137">		}</a>
<a name="ln138">	}</a>
<a name="ln139"> </a>
<a name="ln140">	if (_source)</a>
<a name="ln141">		*_source = source;</a>
<a name="ln142"> </a>
<a name="ln143">	return source != kNoIcon ? B_OK : B_ERROR;</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146"> </a>
<a name="ln147">//	#pragma mark -</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150">Icon::Icon()</a>
<a name="ln151">	:</a>
<a name="ln152">	fLarge(NULL),</a>
<a name="ln153">	fMini(NULL),</a>
<a name="ln154">	fData(NULL),</a>
<a name="ln155">	fSize(0)</a>
<a name="ln156">{</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">Icon::Icon(const Icon&amp; source)</a>
<a name="ln161">	:</a>
<a name="ln162">	fLarge(NULL),</a>
<a name="ln163">	fMini(NULL),</a>
<a name="ln164">	fData(NULL),</a>
<a name="ln165">	fSize(0)</a>
<a name="ln166">{</a>
<a name="ln167">	*this = source;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">Icon::~Icon()</a>
<a name="ln172">{</a>
<a name="ln173">	delete fLarge;</a>
<a name="ln174">	delete fMini;</a>
<a name="ln175">	free(fData);</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">void</a>
<a name="ln180">Icon::SetTo(const BAppFileInfo&amp; info, const char* type)</a>
<a name="ln181">{</a>
<a name="ln182">	Unset();</a>
<a name="ln183"> </a>
<a name="ln184">	uint8* data;</a>
<a name="ln185">	size_t size;</a>
<a name="ln186"> </a>
<a name="ln187">	if (info.GetIconForType(type, &amp;data, &amp;size) == B_OK) {</a>
<a name="ln188">		// we have the vector icon, no need to get the rest</a>
<a name="ln189">		AdoptData(data, size);</a>
<a name="ln190">		return;</a>
<a name="ln191">	}</a>
<a name="ln192"> </a>
<a name="ln193">	BBitmap* icon = AllocateBitmap(B_LARGE_ICON, B_CMAP8);</a>
<a name="ln194">	if (icon &amp;&amp; info.GetIconForType(type, icon, B_LARGE_ICON) == B_OK)</a>
<a name="ln195">		AdoptLarge(icon);</a>
<a name="ln196">	else</a>
<a name="ln197">		delete icon;</a>
<a name="ln198"> </a>
<a name="ln199">	icon = AllocateBitmap(B_MINI_ICON, B_CMAP8);</a>
<a name="ln200">	if (icon &amp;&amp; info.GetIconForType(type, icon, B_MINI_ICON) == B_OK)</a>
<a name="ln201">		AdoptMini(icon);</a>
<a name="ln202">	else</a>
<a name="ln203">		delete icon;</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206"> </a>
<a name="ln207">void</a>
<a name="ln208">Icon::SetTo(const entry_ref&amp; ref, const char* type)</a>
<a name="ln209">{</a>
<a name="ln210">	Unset();</a>
<a name="ln211"> </a>
<a name="ln212">	BFile file(&amp;ref, B_READ_ONLY);</a>
<a name="ln213">	BAppFileInfo info(&amp;file);</a>
<a name="ln214">	if (file.InitCheck() == B_OK</a>
<a name="ln215">		&amp;&amp; info.InitCheck() == B_OK)</a>
<a name="ln216">		SetTo(info, type);</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219"> </a>
<a name="ln220">void</a>
<a name="ln221">Icon::SetTo(const BMimeType&amp; type, icon_source* _source)</a>
<a name="ln222">{</a>
<a name="ln223">	Unset();</a>
<a name="ln224"> </a>
<a name="ln225">	uint8* data;</a>
<a name="ln226">	size_t size;</a>
<a name="ln227">	if (icon_for_type(type, &amp;data, &amp;size, _source) == B_OK) {</a>
<a name="ln228">		// we have the vector icon, no need to get the rest</a>
<a name="ln229">		AdoptData(data, size);</a>
<a name="ln230">		return;</a>
<a name="ln231">	}</a>
<a name="ln232"> </a>
<a name="ln233">	BBitmap* icon = AllocateBitmap(B_LARGE_ICON, B_CMAP8);</a>
<a name="ln234">	if (icon &amp;&amp; icon_for_type(type, *icon, B_LARGE_ICON, _source) == B_OK)</a>
<a name="ln235">		AdoptLarge(icon);</a>
<a name="ln236">	else</a>
<a name="ln237">		delete icon;</a>
<a name="ln238"> </a>
<a name="ln239">	icon = AllocateBitmap(B_MINI_ICON, B_CMAP8);</a>
<a name="ln240">	if (icon &amp;&amp; icon_for_type(type, *icon, B_MINI_ICON) == B_OK)</a>
<a name="ln241">		AdoptMini(icon);</a>
<a name="ln242">	else</a>
<a name="ln243">		delete icon;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246"> </a>
<a name="ln247">status_t</a>
<a name="ln248">Icon::CopyTo(BAppFileInfo&amp; info, const char* type, bool force) const</a>
<a name="ln249">{</a>
<a name="ln250">	status_t status = B_OK;</a>
<a name="ln251"> </a>
<a name="ln252">	if (fLarge != NULL || force)</a>
<a name="ln253">		status = info.SetIconForType(type, fLarge, B_LARGE_ICON);</a>
<a name="ln254">	if (fMini != NULL || force)</a>
<a name="ln255">		status = info.SetIconForType(type, fMini, B_MINI_ICON);</a>
<a name="ln256">	if (fData != NULL || force)</a>
<a name="ln257">		status = info.SetIconForType(type, fData, fSize);</a>
<a name="ln258"> </a>
<a name="ln259">	return status;</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">status_t</a>
<a name="ln264">Icon::CopyTo(const entry_ref&amp; ref, const char* type, bool force) const</a>
<a name="ln265">{</a>
<a name="ln266">	BFile file;</a>
<a name="ln267">	status_t status = file.SetTo(&amp;ref, B_READ_ONLY);</a>
<a name="ln268">	if (status &lt; B_OK)</a>
<a name="ln269">		return status;</a>
<a name="ln270"> </a>
<a name="ln271">	BAppFileInfo info(&amp;file);</a>
<a name="ln272">	status = info.InitCheck();</a>
<a name="ln273">	if (status &lt; B_OK)</a>
<a name="ln274">		return status;</a>
<a name="ln275"> </a>
<a name="ln276">	return CopyTo(info, type, force);</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">status_t</a>
<a name="ln281">Icon::CopyTo(BMimeType&amp; type, bool force) const</a>
<a name="ln282">{</a>
<a name="ln283">	status_t status = B_OK;</a>
<a name="ln284"> </a>
<a name="ln285">	if (fLarge != NULL || force)</a>
<a name="ln286">		status = type.SetIcon(fLarge, B_LARGE_ICON);</a>
<a name="ln287">	if (fMini != NULL || force)</a>
<a name="ln288">		status = type.SetIcon(fMini, B_MINI_ICON);</a>
<a name="ln289">	if (fData != NULL || force)</a>
<a name="ln290">		status = type.SetIcon(fData, fSize);</a>
<a name="ln291"> </a>
<a name="ln292">	return status;</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">status_t</a>
<a name="ln297">Icon::CopyTo(BMessage&amp; message) const</a>
<a name="ln298">{</a>
<a name="ln299">	status_t status = B_OK;</a>
<a name="ln300"> </a>
<a name="ln301">	if (status == B_OK &amp;&amp; fLarge != NULL) {</a>
<a name="ln302">		BMessage archive;</a>
<a name="ln303">		status = fLarge-&gt;Archive(&amp;archive);</a>
<a name="ln304">		if (status == B_OK)</a>
<a name="ln305">			status = message.AddMessage(&quot;icon/large&quot;, &amp;archive);</a>
<a name="ln306">	}</a>
<a name="ln307">	if (status == B_OK &amp;&amp; fMini != NULL) {</a>
<a name="ln308">		BMessage archive;</a>
<a name="ln309">		status = fMini-&gt;Archive(&amp;archive);</a>
<a name="ln310">		if (status == B_OK)</a>
<a name="ln311">			status = message.AddMessage(&quot;icon/mini&quot;, &amp;archive);</a>
<a name="ln312">	}</a>
<a name="ln313">	if (status == B_OK &amp;&amp; fData != NULL)</a>
<a name="ln314">		status = message.AddData(&quot;icon&quot;, B_VECTOR_ICON_TYPE, fData, fSize);</a>
<a name="ln315"> </a>
<a name="ln316">	return B_OK;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">void</a>
<a name="ln321">Icon::SetLarge(const BBitmap* large)</a>
<a name="ln322">{</a>
<a name="ln323">	if (large != NULL) {</a>
<a name="ln324">		if (fLarge == NULL)</a>
<a name="ln325">			fLarge = new BBitmap(BRect(0, 0, 31, 31), B_CMAP8);</a>
<a name="ln326"> </a>
<a name="ln327">		memcpy(fLarge-&gt;Bits(), large-&gt;Bits(), min_c(large-&gt;BitsLength(),</a>
<a name="ln328">			fLarge-&gt;BitsLength()));</a>
<a name="ln329">	} else {</a>
<a name="ln330">		delete fLarge;</a>
<a name="ln331">		fLarge = NULL;</a>
<a name="ln332">	}</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335"> </a>
<a name="ln336">void</a>
<a name="ln337">Icon::SetMini(const BBitmap* mini)</a>
<a name="ln338">{</a>
<a name="ln339">	if (mini != NULL) {</a>
<a name="ln340">		if (fMini == NULL)</a>
<a name="ln341">			fMini = new BBitmap(BRect(0, 0, 15, 15), B_CMAP8);</a>
<a name="ln342"> </a>
<a name="ln343">		memcpy(fMini-&gt;Bits(), mini-&gt;Bits(), min_c(mini-&gt;BitsLength(),</a>
<a name="ln344">			fMini-&gt;BitsLength()));</a>
<a name="ln345">	} else {</a>
<a name="ln346">		delete fMini;</a>
<a name="ln347">		fMini = NULL;</a>
<a name="ln348">	}</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351"> </a>
<a name="ln352">void</a>
<a name="ln353">Icon::SetData(const uint8* data, size_t size)</a>
<a name="ln354">{</a>
<a name="ln355">	free(fData);</a>
<a name="ln356">	fData = NULL;</a>
<a name="ln357"> </a>
<a name="ln358">	if (data != NULL) {</a>
<a name="ln359">		fData = (uint8*)malloc(size);</a>
<a name="ln360">		if (fData != NULL) {</a>
<a name="ln361">			fSize = size;</a>
<a name="ln362">			//fType = B_VECTOR_ICON_TYPE;</a>
<a name="ln363">			memcpy(fData, data, size);</a>
<a name="ln364">		}</a>
<a name="ln365">	}</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368"> </a>
<a name="ln369">void</a>
<a name="ln370">Icon::Unset()</a>
<a name="ln371">{</a>
<a name="ln372">	delete fLarge;</a>
<a name="ln373">	delete fMini;</a>
<a name="ln374">	free(fData);</a>
<a name="ln375"> </a>
<a name="ln376">	fLarge = fMini = NULL;</a>
<a name="ln377">	fData = NULL;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">bool</a>
<a name="ln382">Icon::HasData() const</a>
<a name="ln383">{</a>
<a name="ln384">	return fData != NULL || fLarge != NULL || fMini != NULL;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387"> </a>
<a name="ln388">status_t</a>
<a name="ln389">Icon::GetData(icon_size which, BBitmap** _bitmap) const</a>
<a name="ln390">{</a>
<a name="ln391">	BBitmap* source;</a>
<a name="ln392">	switch (which) {</a>
<a name="ln393">		case B_LARGE_ICON:</a>
<a name="ln394">			source = fLarge;</a>
<a name="ln395">			break;</a>
<a name="ln396">		case B_MINI_ICON:</a>
<a name="ln397">			source = fMini;</a>
<a name="ln398">			break;</a>
<a name="ln399">		default:</a>
<a name="ln400">			return B_BAD_VALUE;</a>
<a name="ln401">	}</a>
<a name="ln402"> </a>
<a name="ln403">	if (source == NULL)</a>
<a name="ln404">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln405"> </a>
<a name="ln406">	BBitmap* bitmap = new (nothrow) BBitmap(source);</a>
<a name="ln407">	if (bitmap == NULL || bitmap-&gt;InitCheck() != B_OK) {</a>
<a name="ln408">		delete bitmap;</a>
<a name="ln409">		return B_NO_MEMORY;</a>
<a name="ln410">	}</a>
<a name="ln411"> </a>
<a name="ln412">	*_bitmap = bitmap;</a>
<a name="ln413">	return B_OK;</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416"> </a>
<a name="ln417">status_t</a>
<a name="ln418">Icon::GetData(uint8** _data, size_t* _size) const</a>
<a name="ln419">{</a>
<a name="ln420">	if (fData == NULL)</a>
<a name="ln421">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln422"> </a>
<a name="ln423">	uint8* data = (uint8*)malloc(fSize);</a>
<a name="ln424">	if (data == NULL)</a>
<a name="ln425">		return B_NO_MEMORY;</a>
<a name="ln426"> </a>
<a name="ln427">	memcpy(data, fData, fSize);</a>
<a name="ln428">	*_data = data;</a>
<a name="ln429">	*_size = fSize;</a>
<a name="ln430">	return B_OK;</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433"> </a>
<a name="ln434">status_t</a>
<a name="ln435">Icon::GetIcon(BBitmap* bitmap) const</a>
<a name="ln436">{</a>
<a name="ln437">	if (bitmap == NULL)</a>
<a name="ln438">		return B_BAD_VALUE;</a>
<a name="ln439"> </a>
<a name="ln440">	if (fData != NULL</a>
<a name="ln441">		&amp;&amp; BIconUtils::GetVectorIcon(fData, fSize, bitmap) == B_OK)</a>
<a name="ln442">		return B_OK;</a>
<a name="ln443"> </a>
<a name="ln444">	int32 width = bitmap-&gt;Bounds().IntegerWidth() + 1;</a>
<a name="ln445"> </a>
<a name="ln446">	if (width == B_LARGE_ICON &amp;&amp; fLarge != NULL) {</a>
<a name="ln447">		bitmap-&gt;SetBits(fLarge-&gt;Bits(), fLarge-&gt;BitsLength(), 0,</a>
<a name="ln448">			fLarge-&gt;ColorSpace());</a>
<a name="ln449">		return B_OK;</a>
<a name="ln450">	}</a>
<a name="ln451">	if (width == B_MINI_ICON &amp;&amp; fMini != NULL) {</a>
<a name="ln452">		bitmap-&gt;SetBits(fMini-&gt;Bits(), fMini-&gt;BitsLength(), 0,</a>
<a name="ln453">			fMini-&gt;ColorSpace());</a>
<a name="ln454">		return B_OK;</a>
<a name="ln455">	}</a>
<a name="ln456"> </a>
<a name="ln457">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460"> </a>
<a name="ln461">Icon&amp;</a>
<a name="ln462">Icon::operator=(const Icon&amp; source)</a>
<a name="ln463">{</a>
<a name="ln464">	Unset();</a>
<a name="ln465"> </a>
<a name="ln466">	SetData(source.fData, source.fSize);</a>
<a name="ln467">	SetLarge(source.fLarge);</a>
<a name="ln468">	SetMini(source.fMini);</a>
<a name="ln469"> </a>
<a name="ln470">	return *this;</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473"> </a>
<a name="ln474">void</a>
<a name="ln475">Icon::AdoptLarge(BBitmap *large)</a>
<a name="ln476">{</a>
<a name="ln477">	delete fLarge;</a>
<a name="ln478">	fLarge = large;</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481"> </a>
<a name="ln482">void</a>
<a name="ln483">Icon::AdoptMini(BBitmap *mini)</a>
<a name="ln484">{</a>
<a name="ln485">	delete fMini;</a>
<a name="ln486">	fMini = mini;</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489"> </a>
<a name="ln490">void</a>
<a name="ln491">Icon::AdoptData(uint8* data, size_t size)</a>
<a name="ln492">{</a>
<a name="ln493">	free(fData);</a>
<a name="ln494">	fData = data;</a>
<a name="ln495">	fSize = size;</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498"> </a>
<a name="ln499">/*static*/ BBitmap*</a>
<a name="ln500">Icon::AllocateBitmap(int32 size, int32 space)</a>
<a name="ln501">{</a>
<a name="ln502">	int32 kSpace = B_RGBA32;</a>
<a name="ln503">	if (space == -1)</a>
<a name="ln504">		space = kSpace;</a>
<a name="ln505"> </a>
<a name="ln506">	BBitmap* bitmap = new (nothrow) BBitmap(BRect(0, 0, size - 1, size - 1),</a>
<a name="ln507">		(color_space)space);</a>
<a name="ln508">	if (bitmap == NULL || bitmap-&gt;InitCheck() != B_OK) {</a>
<a name="ln509">		delete bitmap;</a>
<a name="ln510">		return NULL;</a>
<a name="ln511">	}</a>
<a name="ln512"> </a>
<a name="ln513">	return bitmap;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516"> </a>
<a name="ln517">//	#pragma mark -</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">IconView::IconView(const char* name, uint32 flags)</a>
<a name="ln521">	: BControl(name, NULL, NULL, B_WILL_DRAW | flags),</a>
<a name="ln522">	fModificationMessage(NULL),</a>
<a name="ln523">	fIconSize(B_LARGE_ICON),</a>
<a name="ln524">	fIcon(NULL),</a>
<a name="ln525">	fHeapIcon(NULL),</a>
<a name="ln526">	fHasRef(false),</a>
<a name="ln527">	fHasType(false),</a>
<a name="ln528">	fIconData(NULL),</a>
<a name="ln529">	fTracking(false),</a>
<a name="ln530">	fDragging(false),</a>
<a name="ln531">	fDropTarget(false),</a>
<a name="ln532">	fShowEmptyFrame(true)</a>
<a name="ln533">{</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536"> </a>
<a name="ln537">IconView::~IconView()</a>
<a name="ln538">{</a>
<a name="ln539">	delete fIcon;</a>
<a name="ln540">	delete fModificationMessage;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543"> </a>
<a name="ln544">void</a>
<a name="ln545">IconView::AttachedToWindow()</a>
<a name="ln546">{</a>
<a name="ln547">	AdoptParentColors();</a>
<a name="ln548"> </a>
<a name="ln549">	fTarget = this;</a>
<a name="ln550"> </a>
<a name="ln551">	// SetTo() was already called before we were a valid messenger</a>
<a name="ln552">	if (fHasRef || fHasType)</a>
<a name="ln553">		_StartWatching();</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556"> </a>
<a name="ln557">void</a>
<a name="ln558">IconView::DetachedFromWindow()</a>
<a name="ln559">{</a>
<a name="ln560">	_StopWatching();</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563"> </a>
<a name="ln564">void</a>
<a name="ln565">IconView::MessageReceived(BMessage* message)</a>
<a name="ln566">{</a>
<a name="ln567">	if (message-&gt;WasDropped() &amp;&amp; message-&gt;ReturnAddress() != BMessenger(this)</a>
<a name="ln568">		&amp;&amp; AcceptsDrag(message)) {</a>
<a name="ln569">		// set icon from message</a>
<a name="ln570">		BBitmap* mini = NULL;</a>
<a name="ln571">		BBitmap* large = NULL;</a>
<a name="ln572">		const uint8* data = NULL;</a>
<a name="ln573">		ssize_t size = 0;</a>
<a name="ln574"> </a>
<a name="ln575">		message-&gt;FindData(&quot;icon&quot;, B_VECTOR_ICON_TYPE, (const void**)&amp;data,</a>
<a name="ln576">			&amp;size);</a>
<a name="ln577"> </a>
<a name="ln578">		BMessage archive;</a>
<a name="ln579">		if (message-&gt;FindMessage(&quot;icon/large&quot;, &amp;archive) == B_OK)</a>
<a name="ln580">			large = (BBitmap*)BBitmap::Instantiate(&amp;archive);</a>
<a name="ln581">		if (message-&gt;FindMessage(&quot;icon/mini&quot;, &amp;archive) == B_OK)</a>
<a name="ln582">			mini = (BBitmap*)BBitmap::Instantiate(&amp;archive);</a>
<a name="ln583"> </a>
<a name="ln584">		if (large != NULL || mini != NULL || (data != NULL &amp;&amp; size &gt; 0))</a>
<a name="ln585">			_SetIcon(large, mini, data, size);</a>
<a name="ln586">		else {</a>
<a name="ln587">			entry_ref ref;</a>
<a name="ln588">			if (message-&gt;FindRef(&quot;refs&quot;, &amp;ref) == B_OK)</a>
<a name="ln589">				_SetIcon(&amp;ref);</a>
<a name="ln590">		}</a>
<a name="ln591"> </a>
<a name="ln592">		delete large;</a>
<a name="ln593">		delete mini;</a>
<a name="ln594"> </a>
<a name="ln595">		return;</a>
<a name="ln596">	}</a>
<a name="ln597"> </a>
<a name="ln598">	switch (message-&gt;what) {</a>
<a name="ln599">		case kMsgIconInvoked:</a>
<a name="ln600">		case kMsgEditIcon:</a>
<a name="ln601">		case kMsgAddIcon:</a>
<a name="ln602">			_AddOrEditIcon();</a>
<a name="ln603">			break;</a>
<a name="ln604">		case kMsgRemoveIcon:</a>
<a name="ln605">			_RemoveIcon();</a>
<a name="ln606">			break;</a>
<a name="ln607"> </a>
<a name="ln608">		case B_NODE_MONITOR:</a>
<a name="ln609">		{</a>
<a name="ln610">			if (!fHasRef)</a>
<a name="ln611">				break;</a>
<a name="ln612"> </a>
<a name="ln613">			int32 opcode;</a>
<a name="ln614">			if (message-&gt;FindInt32(&quot;opcode&quot;, &amp;opcode) != B_OK</a>
<a name="ln615">				|| opcode != B_ATTR_CHANGED)</a>
<a name="ln616">				break;</a>
<a name="ln617"> </a>
<a name="ln618">			const char* name;</a>
<a name="ln619">			if (message-&gt;FindString(&quot;attr&quot;, &amp;name) != B_OK)</a>
<a name="ln620">				break;</a>
<a name="ln621"> </a>
<a name="ln622">			if (!strcmp(name, kAttrMiniIcon)</a>
<a name="ln623">				|| !strcmp(name, kAttrLargeIcon)</a>
<a name="ln624">				|| !strcmp(name, kAttrIcon))</a>
<a name="ln625">				Update();</a>
<a name="ln626">			break;</a>
<a name="ln627">		}</a>
<a name="ln628"> </a>
<a name="ln629">		case B_META_MIME_CHANGED:</a>
<a name="ln630">		{</a>
<a name="ln631">			if (!fHasType)</a>
<a name="ln632">				break;</a>
<a name="ln633"> </a>
<a name="ln634">			const char* type;</a>
<a name="ln635">			int32 which;</a>
<a name="ln636">			if (message-&gt;FindString(&quot;be:type&quot;, &amp;type) != B_OK</a>
<a name="ln637">				|| message-&gt;FindInt32(&quot;be:which&quot;, &amp;which) != B_OK)</a>
<a name="ln638">				break;</a>
<a name="ln639"> </a>
<a name="ln640">			if (!strcasecmp(type, fType.Type())) {</a>
<a name="ln641">				switch (which) {</a>
<a name="ln642">					case B_MIME_TYPE_DELETED:</a>
<a name="ln643">						Unset();</a>
<a name="ln644">						break;</a>
<a name="ln645"> </a>
<a name="ln646">					case B_ICON_CHANGED:</a>
<a name="ln647">						Update();</a>
<a name="ln648">						break;</a>
<a name="ln649"> </a>
<a name="ln650">					default:</a>
<a name="ln651">						break;</a>
<a name="ln652">				}</a>
<a name="ln653">			} else if (fSource != kOwnIcon</a>
<a name="ln654">				&amp;&amp; message-&gt;FindString(&quot;be:extra_type&quot;, &amp;type) == B_OK</a>
<a name="ln655">				&amp;&amp; !strcasecmp(type, fType.Type())) {</a>
<a name="ln656">				// this change could still affect our current icon</a>
<a name="ln657"> </a>
<a name="ln658">				if (which == B_MIME_TYPE_DELETED</a>
<a name="ln659">					|| which == B_PREFERRED_APP_CHANGED</a>
<a name="ln660">					|| which == B_SUPPORTED_TYPES_CHANGED</a>
<a name="ln661">					|| which == B_ICON_FOR_TYPE_CHANGED)</a>
<a name="ln662">					Update();</a>
<a name="ln663">			}</a>
<a name="ln664">			break;</a>
<a name="ln665">		}</a>
<a name="ln666"> </a>
<a name="ln667">		case B_ICON_DATA_EDITED:</a>
<a name="ln668">		{</a>
<a name="ln669">			const uint8* data;</a>
<a name="ln670">			ssize_t size;</a>
<a name="ln671">			if (message-&gt;FindData(&quot;icon data&quot;, B_VECTOR_ICON_TYPE,</a>
<a name="ln672">					(const void**)&amp;data, &amp;size) &lt; B_OK)</a>
<a name="ln673">				break;</a>
<a name="ln674"> </a>
<a name="ln675">			_SetIcon(NULL, NULL, data, size);</a>
<a name="ln676">			break;</a>
<a name="ln677">		}</a>
<a name="ln678"> </a>
<a name="ln679">		default:</a>
<a name="ln680">			BControl::MessageReceived(message);</a>
<a name="ln681">			break;</a>
<a name="ln682">	}</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">bool</a>
<a name="ln687">IconView::AcceptsDrag(const BMessage* message)</a>
<a name="ln688">{</a>
<a name="ln689">	if (!IsEnabled())</a>
<a name="ln690">		return false;</a>
<a name="ln691"> </a>
<a name="ln692">	type_code type;</a>
<a name="ln693">	int32 count;</a>
<a name="ln694">	if (message-&gt;GetInfo(&quot;refs&quot;, &amp;type, &amp;count) == B_OK &amp;&amp; count == 1</a>
<a name="ln695">		&amp;&amp; type == B_REF_TYPE) {</a>
<a name="ln696">		// if we're bound to an entry, check that no one drops this to us</a>
<a name="ln697">		entry_ref ref;</a>
<a name="ln698">		if (fHasRef &amp;&amp; message-&gt;FindRef(&quot;refs&quot;, &amp;ref) == B_OK &amp;&amp; fRef == ref)</a>
<a name="ln699">			return false;</a>
<a name="ln700"> </a>
<a name="ln701">		return true;</a>
<a name="ln702">	}</a>
<a name="ln703"> </a>
<a name="ln704">	if ((message-&gt;GetInfo(&quot;icon/large&quot;, &amp;type) == B_OK</a>
<a name="ln705">			&amp;&amp; type == B_MESSAGE_TYPE)</a>
<a name="ln706">		|| (message-&gt;GetInfo(&quot;icon&quot;, &amp;type) == B_OK</a>
<a name="ln707">			&amp;&amp; type == B_VECTOR_ICON_TYPE)</a>
<a name="ln708">		|| (message-&gt;GetInfo(&quot;icon/mini&quot;, &amp;type) == B_OK</a>
<a name="ln709">			&amp;&amp; type == B_MESSAGE_TYPE))</a>
<a name="ln710">		return true;</a>
<a name="ln711"> </a>
<a name="ln712">	return false;</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715"> </a>
<a name="ln716">BRect</a>
<a name="ln717">IconView::BitmapRect() const</a>
<a name="ln718">{</a>
<a name="ln719">	return BRect(0, 0, fIconSize - 1, fIconSize - 1);</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">void</a>
<a name="ln724">IconView::Draw(BRect updateRect)</a>
<a name="ln725">{</a>
<a name="ln726">	SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln727"> </a>
<a name="ln728">	if (fHeapIcon != NULL)</a>
<a name="ln729">		DrawBitmap(fHeapIcon, BitmapRect().LeftTop());</a>
<a name="ln730">	else if (fIcon != NULL)</a>
<a name="ln731">		DrawBitmap(fIcon, BitmapRect().LeftTop());</a>
<a name="ln732">	else if (!fDropTarget &amp;&amp; fShowEmptyFrame) {</a>
<a name="ln733">		// draw frame so that the user knows here is something he</a>
<a name="ln734">		// might be able to click on</a>
<a name="ln735">		SetHighColor(tint_color(ViewColor(), B_DARKEN_1_TINT));</a>
<a name="ln736">		StrokeRect(BitmapRect());</a>
<a name="ln737">	}</a>
<a name="ln738"> </a>
<a name="ln739">	if (IsFocus()) {</a>
<a name="ln740">		// mark this view as a having focus</a>
<a name="ln741">		SetHighColor(ui_color(B_KEYBOARD_NAVIGATION_COLOR));</a>
<a name="ln742">		StrokeRect(BitmapRect());</a>
<a name="ln743">	}</a>
<a name="ln744">	if (fDropTarget) {</a>
<a name="ln745">		// mark this view as a drop target</a>
<a name="ln746">		SetHighColor(0, 0, 0);</a>
<a name="ln747">		SetPenSize(2);</a>
<a name="ln748">		BRect rect = BitmapRect();</a>
<a name="ln749">// TODO: this is an incompatibility between R5 and Haiku and should be fixed!</a>
<a name="ln750">// (Necessary adjustment differs.)</a>
<a name="ln751">		rect.left++;</a>
<a name="ln752">		rect.top++;</a>
<a name="ln753"> </a>
<a name="ln754">		StrokeRect(rect);</a>
<a name="ln755">		SetPenSize(1);</a>
<a name="ln756">	}</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759"> </a>
<a name="ln760">void</a>
<a name="ln761">IconView::GetPreferredSize(float* _width, float* _height)</a>
<a name="ln762">{</a>
<a name="ln763">	if (_width)</a>
<a name="ln764">		*_width = fIconSize;</a>
<a name="ln765"> </a>
<a name="ln766">	if (_height)</a>
<a name="ln767">		*_height = fIconSize;</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770"> </a>
<a name="ln771">BSize</a>
<a name="ln772">IconView::MinSize()</a>
<a name="ln773">{</a>
<a name="ln774">	float width, height;</a>
<a name="ln775">	GetPreferredSize(&amp;width, &amp;height);</a>
<a name="ln776">	return BSize(width, height);</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779"> </a>
<a name="ln780">BSize</a>
<a name="ln781">IconView::PreferredSize()</a>
<a name="ln782">{</a>
<a name="ln783">	return MinSize();</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786"> </a>
<a name="ln787">BSize</a>
<a name="ln788">IconView::MaxSize()</a>
<a name="ln789">{</a>
<a name="ln790">	return MinSize();</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793"> </a>
<a name="ln794">void</a>
<a name="ln795">IconView::MouseDown(BPoint where)</a>
<a name="ln796">{</a>
<a name="ln797">	if (!IsEnabled())</a>
<a name="ln798">		return;</a>
<a name="ln799"> </a>
<a name="ln800">	int32 buttons = B_PRIMARY_MOUSE_BUTTON;</a>
<a name="ln801">	int32 clicks = 1;</a>
<a name="ln802">	if (Looper() != NULL &amp;&amp; Looper()-&gt;CurrentMessage() != NULL) {</a>
<a name="ln803">		if (Looper()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons) != B_OK)</a>
<a name="ln804">			buttons = B_PRIMARY_MOUSE_BUTTON;</a>
<a name="ln805">		if (Looper()-&gt;CurrentMessage()-&gt;FindInt32(&quot;clicks&quot;, &amp;clicks) != B_OK)</a>
<a name="ln806">			clicks = 1;</a>
<a name="ln807">	}</a>
<a name="ln808"> </a>
<a name="ln809">	if ((buttons &amp; B_PRIMARY_MOUSE_BUTTON) != 0</a>
<a name="ln810">		&amp;&amp; BitmapRect().Contains(where)) {</a>
<a name="ln811">		if (clicks == 2) {</a>
<a name="ln812">			// double click - open Icon-O-Matic</a>
<a name="ln813">			Invoke();</a>
<a name="ln814">		} else if (fIcon != NULL) {</a>
<a name="ln815">			// start tracking - this icon might be dragged around</a>
<a name="ln816">			fDragPoint = where;</a>
<a name="ln817">			fTracking = true;</a>
<a name="ln818">			SetMouseEventMask(B_POINTER_EVENTS, B_NO_POINTER_HISTORY);</a>
<a name="ln819">		}</a>
<a name="ln820">	}</a>
<a name="ln821"> </a>
<a name="ln822">	if ((buttons &amp; B_SECONDARY_MOUSE_BUTTON) != 0) {</a>
<a name="ln823">		// show context menu</a>
<a name="ln824"> </a>
<a name="ln825">		ConvertToScreen(&amp;where);</a>
<a name="ln826"> </a>
<a name="ln827">		BPopUpMenu* menu = new BPopUpMenu(&quot;context&quot;);</a>
<a name="ln828">		menu-&gt;SetFont(be_plain_font);</a>
<a name="ln829"> </a>
<a name="ln830">		bool hasIcon = fHasType ? fSource == kOwnIcon : fIcon != NULL;</a>
<a name="ln831">		if (hasIcon) {</a>
<a name="ln832">			menu-&gt;AddItem(new BMenuItem(</a>
<a name="ln833">				B_TRANSLATE(&quot;Edit icon&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln834">				new BMessage(kMsgEditIcon)));</a>
<a name="ln835">		} else {</a>
<a name="ln836">			menu-&gt;AddItem(new BMenuItem(</a>
<a name="ln837">				B_TRANSLATE(&quot;Add icon&quot; B_UTF8_ELLIPSIS),</a>
<a name="ln838">				new BMessage(kMsgAddIcon)));</a>
<a name="ln839">		}</a>
<a name="ln840"> </a>
<a name="ln841">		BMenuItem* item = new BMenuItem(</a>
<a name="ln842">			B_TRANSLATE(&quot;Remove icon&quot;), new BMessage(kMsgRemoveIcon));</a>
<a name="ln843">		if (!hasIcon)</a>
<a name="ln844">			item-&gt;SetEnabled(false);</a>
<a name="ln845"> </a>
<a name="ln846">		menu-&gt;AddItem(item);</a>
<a name="ln847">		menu-&gt;SetTargetForItems(fTarget);</a>
<a name="ln848"> </a>
<a name="ln849">		menu-&gt;Go(where, true, false, true);</a>
<a name="ln850">	}</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853"> </a>
<a name="ln854">void</a>
<a name="ln855">IconView::MouseUp(BPoint where)</a>
<a name="ln856">{</a>
<a name="ln857">	fTracking = false;</a>
<a name="ln858">	fDragging = false;</a>
<a name="ln859"> </a>
<a name="ln860">	if (fDropTarget) {</a>
<a name="ln861">		fDropTarget = false;</a>
<a name="ln862">		Invalidate();</a>
<a name="ln863">	}</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866"> </a>
<a name="ln867">void</a>
<a name="ln868">IconView::MouseMoved(BPoint where, uint32 transit, const BMessage* dragMessage)</a>
<a name="ln869">{</a>
<a name="ln870">	if (fTracking &amp;&amp; !fDragging &amp;&amp; fIcon != NULL</a>
<a name="ln871">		&amp;&amp; (abs((int32)(where.x - fDragPoint.x)) &gt; 3</a>
<a name="ln872">			|| abs((int32)(where.y - fDragPoint.y)) &gt; 3)) {</a>
<a name="ln873">		// Start drag</a>
<a name="ln874">		BMessage message(B_SIMPLE_DATA);</a>
<a name="ln875"> </a>
<a name="ln876">		::Icon* icon = fIconData;</a>
<a name="ln877">		if (fHasRef || fHasType) {</a>
<a name="ln878">			icon = new ::Icon;</a>
<a name="ln879">			if (fHasRef)</a>
<a name="ln880">				icon-&gt;SetTo(fRef, fType.Type());</a>
<a name="ln881">			else if (fHasType)</a>
<a name="ln882">				icon-&gt;SetTo(fType);</a>
<a name="ln883">		}</a>
<a name="ln884"> </a>
<a name="ln885">		icon-&gt;CopyTo(message);</a>
<a name="ln886"> </a>
<a name="ln887">		if (icon != fIconData)</a>
<a name="ln888">			delete icon;</a>
<a name="ln889"> </a>
<a name="ln890">		BBitmap *dragBitmap = new BBitmap(fIcon-&gt;Bounds(), B_RGBA32, true);</a>
<a name="ln891">		dragBitmap-&gt;Lock();</a>
<a name="ln892">		BView *view</a>
<a name="ln893">			= new BView(dragBitmap-&gt;Bounds(), B_EMPTY_STRING, B_FOLLOW_NONE, 0);</a>
<a name="ln894">		dragBitmap-&gt;AddChild(view);</a>
<a name="ln895"> </a>
<a name="ln896">		view-&gt;SetHighColor(B_TRANSPARENT_COLOR);</a>
<a name="ln897">		view-&gt;FillRect(dragBitmap-&gt;Bounds());</a>
<a name="ln898">		view-&gt;SetBlendingMode(B_CONSTANT_ALPHA, B_ALPHA_COMPOSITE);</a>
<a name="ln899">		view-&gt;SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln900">		view-&gt;SetHighColor(0, 0, 0, 160);</a>
<a name="ln901">		view-&gt;DrawBitmap(fIcon);</a>
<a name="ln902"> </a>
<a name="ln903">		view-&gt;Sync();</a>
<a name="ln904">		dragBitmap-&gt;Unlock();</a>
<a name="ln905"> </a>
<a name="ln906">		DragMessage(&amp;message, dragBitmap, B_OP_ALPHA,</a>
<a name="ln907">			fDragPoint - BitmapRect().LeftTop(), this);</a>
<a name="ln908">		fDragging = true;</a>
<a name="ln909">	}</a>
<a name="ln910"> </a>
<a name="ln911">	if (dragMessage != NULL &amp;&amp; !fDragging &amp;&amp; AcceptsDrag(dragMessage)) {</a>
<a name="ln912">		bool dropTarget = transit == B_ENTERED_VIEW || transit == B_INSIDE_VIEW;</a>
<a name="ln913">		if (dropTarget != fDropTarget) {</a>
<a name="ln914">			fDropTarget = dropTarget;</a>
<a name="ln915">			Invalidate();</a>
<a name="ln916">		}</a>
<a name="ln917">	} else if (fDropTarget) {</a>
<a name="ln918">		fDropTarget = false;</a>
<a name="ln919">		Invalidate();</a>
<a name="ln920">	}</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923"> </a>
<a name="ln924">void</a>
<a name="ln925">IconView::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln926">{</a>
<a name="ln927">	if (numBytes == 1) {</a>
<a name="ln928">		switch (bytes[0]) {</a>
<a name="ln929">			case B_DELETE:</a>
<a name="ln930">			case B_BACKSPACE:</a>
<a name="ln931">				_RemoveIcon();</a>
<a name="ln932">				return;</a>
<a name="ln933">			case B_ENTER:</a>
<a name="ln934">			case B_SPACE:</a>
<a name="ln935">				Invoke();</a>
<a name="ln936">				return;</a>
<a name="ln937">		}</a>
<a name="ln938">	}</a>
<a name="ln939"> </a>
<a name="ln940">	BControl::KeyDown(bytes, numBytes);</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943"> </a>
<a name="ln944">void</a>
<a name="ln945">IconView::MakeFocus(bool focus)</a>
<a name="ln946">{</a>
<a name="ln947">	if (focus != IsFocus())</a>
<a name="ln948">		Invalidate();</a>
<a name="ln949"> </a>
<a name="ln950">	BControl::MakeFocus(focus);</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">void</a>
<a name="ln955">IconView::SetTo(const entry_ref&amp; ref, const char* fileType)</a>
<a name="ln956">{</a>
<a name="ln957">	Unset();</a>
<a name="ln958"> </a>
<a name="ln959">	fHasRef = true;</a>
<a name="ln960">	fRef = ref;</a>
<a name="ln961">	if (fileType != NULL)</a>
<a name="ln962">		fType.SetTo(fileType);</a>
<a name="ln963">	else</a>
<a name="ln964">		fType.Unset();</a>
<a name="ln965"> </a>
<a name="ln966">	_StartWatching();</a>
<a name="ln967">	Update();</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">void</a>
<a name="ln972">IconView::SetTo(const BMimeType&amp; type)</a>
<a name="ln973">{</a>
<a name="ln974">	Unset();</a>
<a name="ln975"> </a>
<a name="ln976">	if (type.Type() == NULL)</a>
<a name="ln977">		return;</a>
<a name="ln978"> </a>
<a name="ln979">	fHasType = true;</a>
<a name="ln980">	fType.SetTo(type.Type());</a>
<a name="ln981"> </a>
<a name="ln982">	_StartWatching();</a>
<a name="ln983">	Update();</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986"> </a>
<a name="ln987">void</a>
<a name="ln988">IconView::SetTo(::Icon* icon)</a>
<a name="ln989">{</a>
<a name="ln990">	if (fIconData == icon)</a>
<a name="ln991">		return;</a>
<a name="ln992"> </a>
<a name="ln993">	Unset();</a>
<a name="ln994"> </a>
<a name="ln995">	fIconData = icon;</a>
<a name="ln996"> </a>
<a name="ln997">	Update();</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000"> </a>
<a name="ln1001">void</a>
<a name="ln1002">IconView::Unset()</a>
<a name="ln1003">{</a>
<a name="ln1004">	if (fHasRef || fHasType)</a>
<a name="ln1005">		_StopWatching();</a>
<a name="ln1006"> </a>
<a name="ln1007">	fHasRef = false;</a>
<a name="ln1008">	fHasType = false;</a>
<a name="ln1009"> </a>
<a name="ln1010">	fType.Unset();</a>
<a name="ln1011">	fIconData = NULL;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014"> </a>
<a name="ln1015">void</a>
<a name="ln1016">IconView::Update()</a>
<a name="ln1017">{</a>
<a name="ln1018">	delete fIcon;</a>
<a name="ln1019">	fIcon = NULL;</a>
<a name="ln1020"> </a>
<a name="ln1021">	Invalidate();</a>
<a name="ln1022">		// this will actually trigger a redraw *after* we updated the icon below</a>
<a name="ln1023"> </a>
<a name="ln1024">	BBitmap* icon = NULL;</a>
<a name="ln1025"> </a>
<a name="ln1026">	if (fHasRef) {</a>
<a name="ln1027">		BFile file(&amp;fRef, B_READ_ONLY);</a>
<a name="ln1028">		if (file.InitCheck() != B_OK)</a>
<a name="ln1029">			return;</a>
<a name="ln1030"> </a>
<a name="ln1031">		BNodeInfo info;</a>
<a name="ln1032">		if (info.SetTo(&amp;file) != B_OK)</a>
<a name="ln1033">			return;</a>
<a name="ln1034"> </a>
<a name="ln1035">		icon = Icon::AllocateBitmap(fIconSize);</a>
<a name="ln1036">		if (icon != NULL &amp;&amp; info.GetTrackerIcon(icon,</a>
<a name="ln1037">				(icon_size)fIconSize) != B_OK) {</a>
<a name="ln1038">			delete icon;</a>
<a name="ln1039">			return;</a>
<a name="ln1040">		}</a>
<a name="ln1041">	} else if (fHasType) {</a>
<a name="ln1042">		icon = Icon::AllocateBitmap(fIconSize);</a>
<a name="ln1043">		if (icon != NULL &amp;&amp; icon_for_type(fType, *icon, (icon_size)fIconSize,</a>
<a name="ln1044">				&amp;fSource) != B_OK) {</a>
<a name="ln1045">			delete icon;</a>
<a name="ln1046">			return;</a>
<a name="ln1047">		}</a>
<a name="ln1048">	} else if (fIconData) {</a>
<a name="ln1049">		icon = Icon::AllocateBitmap(fIconSize);</a>
<a name="ln1050">		if (fIconData-&gt;GetIcon(icon) != B_OK) {</a>
<a name="ln1051">			delete icon;</a>
<a name="ln1052">			icon = NULL;</a>
<a name="ln1053">		}</a>
<a name="ln1054">	}</a>
<a name="ln1055"> </a>
<a name="ln1056">	fIcon = icon;</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059"> </a>
<a name="ln1060">void</a>
<a name="ln1061">IconView::SetIconSize(int32 size)</a>
<a name="ln1062">{</a>
<a name="ln1063">	if (size &lt; B_MINI_ICON)</a>
<a name="ln1064">		size = B_MINI_ICON;</a>
<a name="ln1065">	if (size &gt; 256)</a>
<a name="ln1066">		size = 256;</a>
<a name="ln1067">	if (size == fIconSize)</a>
<a name="ln1068">		return;</a>
<a name="ln1069"> </a>
<a name="ln1070">	fIconSize = size;</a>
<a name="ln1071">	Update();</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074"> </a>
<a name="ln1075">void</a>
<a name="ln1076">IconView::ShowIconHeap(bool show)</a>
<a name="ln1077">{</a>
<a name="ln1078">	if (show == (fHeapIcon != NULL))</a>
<a name="ln1079">		return;</a>
<a name="ln1080"> </a>
<a name="ln1081">	if (show) {</a>
<a name="ln1082">		BResources* resources = be_app-&gt;AppResources();</a>
<a name="ln1083">		if (resources != NULL) {</a>
<a name="ln1084">			const void* data = NULL;</a>
<a name="ln1085">			size_t size;</a>
<a name="ln1086">			data = resources-&gt;LoadResource('VICN', &quot;icon heap&quot;, &amp;size);</a>
<a name="ln1087">			if (data != NULL) {</a>
<a name="ln1088">				// got vector icon data</a>
<a name="ln1089">				fHeapIcon = Icon::AllocateBitmap(B_LARGE_ICON, B_RGBA32);</a>
<a name="ln1090">				if (BIconUtils::GetVectorIcon((const uint8*)data,</a>
<a name="ln1091">						size, fHeapIcon) != B_OK) {</a>
<a name="ln1092">					// bad data</a>
<a name="ln1093">					delete fHeapIcon;</a>
<a name="ln1094">					fHeapIcon = NULL;</a>
<a name="ln1095">					data = NULL;</a>
<a name="ln1096">				}</a>
<a name="ln1097">			}</a>
<a name="ln1098">			if (data == NULL) {</a>
<a name="ln1099">				// no vector icon or failed to get bitmap</a>
<a name="ln1100">				// try bitmap icon</a>
<a name="ln1101">				data = resources-&gt;LoadResource(B_LARGE_ICON_TYPE, &quot;icon heap&quot;,</a>
<a name="ln1102">					NULL);</a>
<a name="ln1103">				if (data != NULL) {</a>
<a name="ln1104">					fHeapIcon = Icon::AllocateBitmap(B_LARGE_ICON, B_CMAP8);</a>
<a name="ln1105">					if (fHeapIcon != NULL) {</a>
<a name="ln1106">						memcpy(fHeapIcon-&gt;Bits(), data,</a>
<a name="ln1107">							fHeapIcon-&gt;BitsLength());</a>
<a name="ln1108">					}</a>
<a name="ln1109">				}</a>
<a name="ln1110">			}</a>
<a name="ln1111">		}</a>
<a name="ln1112">	} else {</a>
<a name="ln1113">		delete fHeapIcon;</a>
<a name="ln1114">		fHeapIcon = NULL;</a>
<a name="ln1115">	}</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118"> </a>
<a name="ln1119">void</a>
<a name="ln1120">IconView::ShowEmptyFrame(bool show)</a>
<a name="ln1121">{</a>
<a name="ln1122">	if (show == fShowEmptyFrame)</a>
<a name="ln1123">		return;</a>
<a name="ln1124"> </a>
<a name="ln1125">	fShowEmptyFrame = show;</a>
<a name="ln1126">	if (fIcon == NULL)</a>
<a name="ln1127">		Invalidate();</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130"> </a>
<a name="ln1131">status_t</a>
<a name="ln1132">IconView::SetTarget(const BMessenger&amp; target)</a>
<a name="ln1133">{</a>
<a name="ln1134">	fTarget = target;</a>
<a name="ln1135">	return B_OK;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138"> </a>
<a name="ln1139">void</a>
<a name="ln1140">IconView::SetModificationMessage(BMessage* message)</a>
<a name="ln1141">{</a>
<a name="ln1142">	delete fModificationMessage;</a>
<a name="ln1143">	fModificationMessage = message;</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146"> </a>
<a name="ln1147">status_t</a>
<a name="ln1148">IconView::Invoke(BMessage* message)</a>
<a name="ln1149">{</a>
<a name="ln1150">	if (message == NULL)</a>
<a name="ln1151">		fTarget.SendMessage(kMsgIconInvoked);</a>
<a name="ln1152">	else</a>
<a name="ln1153">		fTarget.SendMessage(message);</a>
<a name="ln1154">	return B_OK;</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157"> </a>
<a name="ln1158">Icon*</a>
<a name="ln1159">IconView::Icon()</a>
<a name="ln1160">{</a>
<a name="ln1161">	return fIconData;</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164"> </a>
<a name="ln1165">status_t</a>
<a name="ln1166">IconView::GetRef(entry_ref&amp; ref) const</a>
<a name="ln1167">{</a>
<a name="ln1168">	if (!fHasRef)</a>
<a name="ln1169">		return B_BAD_TYPE;</a>
<a name="ln1170"> </a>
<a name="ln1171">	ref = fRef;</a>
<a name="ln1172">	return B_OK;</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176">status_t</a>
<a name="ln1177">IconView::GetMimeType(BMimeType&amp; type) const</a>
<a name="ln1178">{</a>
<a name="ln1179">	if (!fHasType)</a>
<a name="ln1180">		return B_BAD_TYPE;</a>
<a name="ln1181"> </a>
<a name="ln1182">	type.SetTo(fType.Type());</a>
<a name="ln1183">	return B_OK;</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186"> </a>
<a name="ln1187">void</a>
<a name="ln1188">IconView::_AddOrEditIcon()</a>
<a name="ln1189">{</a>
<a name="ln1190">	BMessage message;</a>
<a name="ln1191">	if (fHasRef &amp;&amp; fType.Type() == NULL) {</a>
<a name="ln1192">		// in ref mode, Icon-O-Matic can change the icon directly, and</a>
<a name="ln1193">		// we'll pick it up via node monitoring</a>
<a name="ln1194">		message.what = B_REFS_RECEIVED;</a>
<a name="ln1195">		message.AddRef(&quot;refs&quot;, &amp;fRef);</a>
<a name="ln1196">	} else {</a>
<a name="ln1197">		// in static or MIME type mode, Icon-O-Matic needs to return the</a>
<a name="ln1198">		// buffer it changed once its done</a>
<a name="ln1199">		message.what = B_EDIT_ICON_DATA;</a>
<a name="ln1200">		message.AddMessenger(&quot;reply to&quot;, BMessenger(this));</a>
<a name="ln1201"> </a>
<a name="ln1202">		::Icon* icon = fIconData;</a>
<a name="ln1203">		if (icon == NULL) {</a>
<a name="ln1204">			icon = new ::Icon();</a>
<a name="ln1205">			if (fHasRef)</a>
<a name="ln1206">				icon-&gt;SetTo(fRef, fType.Type());</a>
<a name="ln1207">			else</a>
<a name="ln1208">				icon-&gt;SetTo(fType);</a>
<a name="ln1209">		}</a>
<a name="ln1210"> </a>
<a name="ln1211">		if (icon-&gt;HasData()) {</a>
<a name="ln1212">			uint8* data;</a>
<a name="ln1213">			size_t size;</a>
<a name="ln1214">			if (icon-&gt;GetData(&amp;data, &amp;size) == B_OK) {</a>
<a name="ln1215">				message.AddData(&quot;icon data&quot;, B_VECTOR_ICON_TYPE, data, size);</a>
<a name="ln1216">				free(data);</a>
<a name="ln1217">			}</a>
<a name="ln1218"> </a>
<a name="ln1219">			// TODO: somehow figure out how names of objects in the icon</a>
<a name="ln1220">			// can be preserved. Maybe in a second (optional) attribute</a>
<a name="ln1221">			// where ever a vector icon attribute is present?</a>
<a name="ln1222">		}</a>
<a name="ln1223"> </a>
<a name="ln1224">		if (icon != fIconData)</a>
<a name="ln1225">			delete icon;</a>
<a name="ln1226">	}</a>
<a name="ln1227"> </a>
<a name="ln1228">	be_roster-&gt;Launch(&quot;application/x-vnd.haiku-icon_o_matic&quot;, &amp;message);</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231"> </a>
<a name="ln1232">void</a>
<a name="ln1233">IconView::_SetIcon(BBitmap* large, BBitmap* mini, const uint8* data,</a>
<a name="ln1234">	size_t size, bool force)</a>
<a name="ln1235">{</a>
<a name="ln1236">	if (fHasRef) {</a>
<a name="ln1237">		BFile file(&amp;fRef, B_READ_WRITE);</a>
<a name="ln1238"> </a>
<a name="ln1239">		if (is_application(file)) {</a>
<a name="ln1240">			BAppFileInfo info(&amp;file);</a>
<a name="ln1241">			if (info.InitCheck() == B_OK) {</a>
<a name="ln1242">				if (large != NULL || force)</a>
<a name="ln1243">					info.SetIconForType(fType.Type(), large, B_LARGE_ICON);</a>
<a name="ln1244">				if (mini != NULL || force)</a>
<a name="ln1245">					info.SetIconForType(fType.Type(), mini, B_MINI_ICON);</a>
<a name="ln1246">				if (data != NULL || force)</a>
<a name="ln1247">					info.SetIconForType(fType.Type(), data, size);</a>
<a name="ln1248">			}</a>
<a name="ln1249">		} else {</a>
<a name="ln1250">			BNodeInfo info(&amp;file);</a>
<a name="ln1251">			if (info.InitCheck() == B_OK) {</a>
<a name="ln1252">				if (large != NULL || force)</a>
<a name="ln1253">					info.SetIcon(large, B_LARGE_ICON);</a>
<a name="ln1254">				if (mini != NULL || force)</a>
<a name="ln1255">					info.SetIcon(mini, B_MINI_ICON);</a>
<a name="ln1256">				if (data != NULL || force)</a>
<a name="ln1257">					info.SetIcon(data, size);</a>
<a name="ln1258">			}</a>
<a name="ln1259">		}</a>
<a name="ln1260">		// the icon shown will be updated using node monitoring</a>
<a name="ln1261">	} else if (fHasType) {</a>
<a name="ln1262">		if (large != NULL || force)</a>
<a name="ln1263">			fType.SetIcon(large, B_LARGE_ICON);</a>
<a name="ln1264">		if (mini != NULL || force)</a>
<a name="ln1265">			fType.SetIcon(mini, B_MINI_ICON);</a>
<a name="ln1266">		if (data != NULL || force)</a>
<a name="ln1267">			fType.SetIcon(data, size);</a>
<a name="ln1268"> </a>
<a name="ln1269">		// the icon shown will be updated automatically - we're watching</a>
<a name="ln1270">		// any changes to the MIME database</a>
<a name="ln1271">	} else if (fIconData != NULL) {</a>
<a name="ln1272">		if (large != NULL || force)</a>
<a name="ln1273">			fIconData-&gt;SetLarge(large);</a>
<a name="ln1274">		if (mini != NULL || force)</a>
<a name="ln1275">			fIconData-&gt;SetMini(mini);</a>
<a name="ln1276">		if (data != NULL || force)</a>
<a name="ln1277">			fIconData-&gt;SetData(data, size);</a>
<a name="ln1278"> </a>
<a name="ln1279">		// replace visible icon</a>
<a name="ln1280">		if (fIcon == NULL &amp;&amp; fIconData-&gt;HasData())</a>
<a name="ln1281">			fIcon = Icon::AllocateBitmap(fIconSize);</a>
<a name="ln1282"> </a>
<a name="ln1283">		if (fIconData-&gt;GetIcon(fIcon) != B_OK) {</a>
<a name="ln1284">			delete fIcon;</a>
<a name="ln1285">			fIcon = NULL;</a>
<a name="ln1286">		}</a>
<a name="ln1287">		Invalidate();</a>
<a name="ln1288">	}</a>
<a name="ln1289"> </a>
<a name="ln1290">	if (fModificationMessage)</a>
<a name="ln1291">		Invoke(fModificationMessage);</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294"> </a>
<a name="ln1295">void</a>
<a name="ln1296">IconView::_SetIcon(entry_ref* ref)</a>
<a name="ln1297">{</a>
<a name="ln1298">	// retrieve icons from file</a>
<a name="ln1299">	BFile file(ref, B_READ_ONLY);</a>
<a name="ln1300">	BAppFileInfo info(&amp;file);</a>
<a name="ln1301">	if (file.InitCheck() != B_OK || info.InitCheck() != B_OK)</a>
<a name="ln1302">		return;</a>
<a name="ln1303"> </a>
<a name="ln1304">	// try vector/PNG icon first</a>
<a name="ln1305">	uint8* data = NULL;</a>
<a name="ln1306">	size_t size = 0;</a>
<a name="ln1307">	if (info.GetIcon(&amp;data, &amp;size) == B_OK) {</a>
<a name="ln1308">		_SetIcon(NULL, NULL, data, size);</a>
<a name="ln1309">		free(data);</a>
<a name="ln1310">		return;</a>
<a name="ln1311">	}</a>
<a name="ln1312"> </a>
<a name="ln1313">	// try large/mini icons</a>
<a name="ln1314">	bool hasMini = false;</a>
<a name="ln1315">	bool hasLarge = false;</a>
<a name="ln1316"> </a>
<a name="ln1317">	BBitmap* large = new BBitmap(BRect(0, 0, 31, 31), B_CMAP8);</a>
<a name="ln1318">	if (large-&gt;InitCheck() != B_OK) {</a>
<a name="ln1319">		delete large;</a>
<a name="ln1320">		large = NULL;</a>
<a name="ln1321">	}</a>
<a name="ln1322">	BBitmap* mini = new BBitmap(BRect(0, 0, 15, 15), B_CMAP8);</a>
<a name="ln1323">	if (mini-&gt;InitCheck() != B_OK) {</a>
<a name="ln1324">		delete mini;</a>
<a name="ln1325">		mini = NULL;</a>
<a name="ln1326">	}</a>
<a name="ln1327"> </a>
<a name="ln1328">	if (large != NULL &amp;&amp; info.GetIcon(large, B_LARGE_ICON) == B_OK)</a>
<a name="ln1329">		hasLarge = true;</a>
<a name="ln1330">	if (mini != NULL &amp;&amp; info.GetIcon(mini, B_MINI_ICON) == B_OK)</a>
<a name="ln1331">		hasMini = true;</a>
<a name="ln1332"> </a>
<a name="ln1333">	if (!hasMini &amp;&amp; !hasLarge) {</a>
<a name="ln1334">		// TODO: don't forget device icons!</a>
<a name="ln1335"> </a>
<a name="ln1336">		// try MIME type icon</a>
<a name="ln1337">		char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln1338">		if (info.GetType(type) != B_OK)</a>
<a name="ln1339">			return;</a>
<a name="ln1340"> </a>
<a name="ln1341">		BMimeType mimeType(type);</a>
<a name="ln1342">		if (icon_for_type(mimeType, &amp;data, &amp;size) != B_OK) {</a>
<a name="ln1343">			// only try large/mini icons when there is no vector icon</a>
<a name="ln1344">			if (large != NULL</a>
<a name="ln1345">				&amp;&amp; icon_for_type(mimeType, *large, B_LARGE_ICON) == B_OK)</a>
<a name="ln1346">				hasLarge = true;</a>
<a name="ln1347">			if (mini != NULL</a>
<a name="ln1348">				&amp;&amp; icon_for_type(mimeType, *mini, B_MINI_ICON) == B_OK)</a>
<a name="ln1349">				hasMini = true;</a>
<a name="ln1350">		}</a>
<a name="ln1351">	}</a>
<a name="ln1352"> </a>
<a name="ln1353">	if (data != NULL) {</a>
<a name="ln1354">		_SetIcon(NULL, NULL, data, size);</a>
<a name="ln1355">		free(data);</a>
<a name="ln1356">	} else if (hasLarge || hasMini)</a>
<a name="ln1357">		_SetIcon(large, mini, NULL, 0);</a>
<a name="ln1358"> </a>
<a name="ln1359">	delete large;</a>
<a name="ln1360">	delete mini;</a>
<a name="ln1361">}</a>
<a name="ln1362"> </a>
<a name="ln1363"> </a>
<a name="ln1364">void</a>
<a name="ln1365">IconView::_RemoveIcon()</a>
<a name="ln1366">{</a>
<a name="ln1367">	_SetIcon(NULL, NULL, NULL, 0, true);</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370"> </a>
<a name="ln1371">void</a>
<a name="ln1372">IconView::_StartWatching()</a>
<a name="ln1373">{</a>
<a name="ln1374">	if (Looper() == NULL) {</a>
<a name="ln1375">		// we are not a valid messenger yet</a>
<a name="ln1376">		return;</a>
<a name="ln1377">	}</a>
<a name="ln1378"> </a>
<a name="ln1379">	if (fHasRef) {</a>
<a name="ln1380">		BNode node(&amp;fRef);</a>
<a name="ln1381">		node_ref nodeRef;</a>
<a name="ln1382">		if (node.InitCheck() == B_OK</a>
<a name="ln1383">			&amp;&amp; node.GetNodeRef(&amp;nodeRef) == B_OK)</a>
<a name="ln1384">			watch_node(&amp;nodeRef, B_WATCH_ATTR, this);</a>
<a name="ln1385">	} else if (fHasType)</a>
<a name="ln1386">		BMimeType::StartWatching(this);</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389"> </a>
<a name="ln1390">void</a>
<a name="ln1391">IconView::_StopWatching()</a>
<a name="ln1392">{</a>
<a name="ln1393">	if (fHasRef)</a>
<a name="ln1394">		stop_watching(this);</a>
<a name="ln1395">	else if (fHasType)</a>
<a name="ln1396">		BMimeType::StopWatching(this);</a>
<a name="ln1397">}</a>
<a name="ln1398"> </a>
<a name="ln1399"> </a>
<a name="ln1400">#if __GNUC__ == 2</a>
<a name="ln1401"> </a>
<a name="ln1402">status_t</a>
<a name="ln1403">IconView::SetTarget(BMessenger target)</a>
<a name="ln1404">{</a>
<a name="ln1405">	return BControl::SetTarget(target);</a>
<a name="ln1406">}</a>
<a name="ln1407"> </a>
<a name="ln1408"> </a>
<a name="ln1409">status_t</a>
<a name="ln1410">IconView::SetTarget(const BHandler* handler, const BLooper* looper = NULL)</a>
<a name="ln1411">{</a>
<a name="ln1412">	return BControl::SetTarget(handler,</a>
<a name="ln1413">		looper);</a>
<a name="ln1414">}</a>
<a name="ln1415"> </a>
<a name="ln1416">#endif</a>
<a name="ln1417"> </a>

</code></pre>
<div class="balloon" rel="520"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fSource.</p></div>
<div class="balloon" rel="1226"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'icon' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="909"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'icon' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="850"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'menu' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
