
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>AppFileInfo.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2014, Haiku, Inc.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Ingo Weinhold, ingo_weinhold@gmx.de</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;new&gt;</a>
<a name="ln11">#include &lt;set&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;AppFileInfo.h&gt;</a>
<a name="ln16">#include &lt;Bitmap.h&gt;</a>
<a name="ln17">#include &lt;File.h&gt;</a>
<a name="ln18">#include &lt;fs_attr.h&gt;</a>
<a name="ln19">#include &lt;IconUtils.h&gt;</a>
<a name="ln20">#include &lt;MimeType.h&gt;</a>
<a name="ln21">#include &lt;RegistrarDefs.h&gt;</a>
<a name="ln22">#include &lt;Resources.h&gt;</a>
<a name="ln23">#include &lt;Roster.h&gt;</a>
<a name="ln24">#include &lt;String.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26"> </a>
<a name="ln27">// debugging</a>
<a name="ln28">//#define DBG(x) x</a>
<a name="ln29">#define DBG(x)</a>
<a name="ln30">#define OUT	printf</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">// type codes</a>
<a name="ln34">enum {</a>
<a name="ln35">	B_APP_FLAGS_TYPE	= 'APPF',</a>
<a name="ln36">	B_VERSION_INFO_TYPE	= 'APPV',</a>
<a name="ln37">};</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">// attributes</a>
<a name="ln41">static const char* kTypeAttribute				= &quot;BEOS:TYPE&quot;;</a>
<a name="ln42">static const char* kSignatureAttribute			= &quot;BEOS:APP_SIG&quot;;</a>
<a name="ln43">static const char* kAppFlagsAttribute			= &quot;BEOS:APP_FLAGS&quot;;</a>
<a name="ln44">static const char* kSupportedTypesAttribute		= &quot;BEOS:FILE_TYPES&quot;;</a>
<a name="ln45">static const char* kVersionInfoAttribute		= &quot;BEOS:APP_VERSION&quot;;</a>
<a name="ln46">static const char* kMiniIconAttribute			= &quot;BEOS:M:&quot;;</a>
<a name="ln47">static const char* kLargeIconAttribute			= &quot;BEOS:L:&quot;;</a>
<a name="ln48">static const char* kIconAttribute				= &quot;BEOS:&quot;;</a>
<a name="ln49">static const char* kStandardIconType			= &quot;STD_ICON&quot;;</a>
<a name="ln50">static const char* kIconType					= &quot;ICON&quot;;</a>
<a name="ln51">static const char* kCatalogEntryAttribute		= &quot;SYS:NAME&quot;;</a>
<a name="ln52"> </a>
<a name="ln53">// resource IDs</a>
<a name="ln54">static const int32 kTypeResourceID				= 2;</a>
<a name="ln55">static const int32 kSignatureResourceID			= 1;</a>
<a name="ln56">static const int32 kAppFlagsResourceID			= 1;</a>
<a name="ln57">static const int32 kSupportedTypesResourceID	= 1;</a>
<a name="ln58">static const int32 kMiniIconResourceID			= 101;</a>
<a name="ln59">static const int32 kLargeIconResourceID			= 101;</a>
<a name="ln60">static const int32 kIconResourceID				= 101;</a>
<a name="ln61">static const int32 kVersionInfoResourceID		= 1;</a>
<a name="ln62">static const int32 kMiniIconForTypeResourceID	= 0;</a>
<a name="ln63">static const int32 kLargeIconForTypeResourceID	= 0;</a>
<a name="ln64">static const int32 kIconForTypeResourceID		= 0;</a>
<a name="ln65">static const int32 kCatalogEntryResourceID		= 1;</a>
<a name="ln66"> </a>
<a name="ln67">// R5 also exports these (Tracker is using them):</a>
<a name="ln68">// (maybe we better want to drop them silently and declare </a>
<a name="ln69">// the above in a public Haiku header - and use that one in</a>
<a name="ln70">// Tracker when compiled for Haiku)</a>
<a name="ln71">extern const uint32 MINI_ICON_TYPE, LARGE_ICON_TYPE;</a>
<a name="ln72">const uint32 MINI_ICON_TYPE = 'MICN';</a>
<a name="ln73">const uint32 LARGE_ICON_TYPE = 'ICON';</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">BAppFileInfo::BAppFileInfo()</a>
<a name="ln77">	:</a>
<a name="ln78">	fResources(NULL),</a>
<a name="ln79">	fWhere(B_USE_BOTH_LOCATIONS)</a>
<a name="ln80">{</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">BAppFileInfo::BAppFileInfo(BFile* file)</a>
<a name="ln85">	:</a>
<a name="ln86">	fResources(NULL),</a>
<a name="ln87">	fWhere(B_USE_BOTH_LOCATIONS)</a>
<a name="ln88">{</a>
<a name="ln89">	SetTo(file);</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">BAppFileInfo::~BAppFileInfo()</a>
<a name="ln94">{</a>
<a name="ln95">	delete fResources;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">status_t</a>
<a name="ln100">BAppFileInfo::SetTo(BFile* file)</a>
<a name="ln101">{</a>
<a name="ln102">	// unset the old file</a>
<a name="ln103">	BNodeInfo::SetTo(NULL);</a>
<a name="ln104">	if (fResources) {</a>
<a name="ln105">		delete fResources;</a>
<a name="ln106">		fResources = NULL;</a>
<a name="ln107">	}</a>
<a name="ln108"> </a>
<a name="ln109">	// check param</a>
<a name="ln110">	status_t error</a>
<a name="ln111">		= file != NULL &amp;&amp; file-&gt;InitCheck() == B_OK ? B_OK : B_BAD_VALUE;</a>
<a name="ln112"> </a>
<a name="ln113">	info_location where = B_USE_BOTH_LOCATIONS;</a>
<a name="ln114"> </a>
<a name="ln115">	// create resources</a>
<a name="ln116">	if (error == B_OK) {</a>
<a name="ln117">		fResources = new(std::nothrow) BResources();</a>
<a name="ln118">		if (fResources) {</a>
<a name="ln119">			error = fResources-&gt;SetTo(file);</a>
<a name="ln120">			if (error != B_OK) {</a>
<a name="ln121">				// no resources - this is no critical error, we'll just use</a>
<a name="ln122">				// attributes only, then</a>
<a name="ln123">				where = B_USE_ATTRIBUTES;</a>
<a name="ln124">				error = B_OK;</a>
<a name="ln125">			}</a>
<a name="ln126">		} else</a>
<a name="ln127">			error = B_NO_MEMORY;</a>
<a name="ln128">	}</a>
<a name="ln129"> </a>
<a name="ln130">	// set node info</a>
<a name="ln131">	if (error == B_OK)</a>
<a name="ln132">		error = BNodeInfo::SetTo(file);</a>
<a name="ln133"> </a>
<a name="ln134">	if (error != B_OK || (where &amp; B_USE_RESOURCES) == 0) {</a>
<a name="ln135">		delete fResources;</a>
<a name="ln136">		fResources = NULL;</a>
<a name="ln137">	}</a>
<a name="ln138"> </a>
<a name="ln139">	// clean up on error</a>
<a name="ln140">	if (error != B_OK) {</a>
<a name="ln141">		if (InitCheck() == B_OK)</a>
<a name="ln142">			BNodeInfo::SetTo(NULL);</a>
<a name="ln143">	}</a>
<a name="ln144"> </a>
<a name="ln145">	// set data location</a>
<a name="ln146">	if (error == B_OK)</a>
<a name="ln147">		SetInfoLocation(where);</a>
<a name="ln148"> </a>
<a name="ln149">	// set error</a>
<a name="ln150">	fCStatus = error;</a>
<a name="ln151">	return error;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">status_t</a>
<a name="ln156">BAppFileInfo::GetType(char* type) const</a>
<a name="ln157">{</a>
<a name="ln158">	// check param and initialization</a>
<a name="ln159">	status_t error = type != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln160">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln161">		error = B_NO_INIT;</a>
<a name="ln162">	// read the data</a>
<a name="ln163">	size_t read = 0;</a>
<a name="ln164">	if (error == B_OK) {</a>
<a name="ln165">		error = _ReadData(kTypeAttribute, kTypeResourceID, B_MIME_STRING_TYPE,</a>
<a name="ln166">			type, B_MIME_TYPE_LENGTH, read);</a>
<a name="ln167">	}</a>
<a name="ln168">	// check the read data -- null terminate the string</a>
<a name="ln169">	if (error == B_OK &amp;&amp; type[read - 1] != '\0') {</a>
<a name="ln170">		if (read == B_MIME_TYPE_LENGTH)</a>
<a name="ln171">			error = B_ERROR;</a>
<a name="ln172">		else</a>
<a name="ln173">			type[read] = '\0';</a>
<a name="ln174">	}</a>
<a name="ln175">	return error;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">status_t</a>
<a name="ln180">BAppFileInfo::SetType(const char* type)</a>
<a name="ln181">{</a>
<a name="ln182">	// check initialization</a>
<a name="ln183">	status_t error = B_OK;</a>
<a name="ln184">	if (InitCheck() != B_OK)</a>
<a name="ln185">		error = B_NO_INIT;</a>
<a name="ln186">	if (error == B_OK) {</a>
<a name="ln187">		if (type != NULL) {</a>
<a name="ln188">			// check param</a>
<a name="ln189">			size_t typeLen = strlen(type);</a>
<a name="ln190">			if (typeLen &gt;= B_MIME_TYPE_LENGTH)</a>
<a name="ln191">				error = B_BAD_VALUE;</a>
<a name="ln192">			// write the data</a>
<a name="ln193">			if (error == B_OK) {</a>
<a name="ln194">				error = _WriteData(kTypeAttribute, kTypeResourceID,</a>
<a name="ln195">					B_MIME_STRING_TYPE, type, typeLen + 1);</a>
<a name="ln196">			}</a>
<a name="ln197">		} else</a>
<a name="ln198">			error = _RemoveData(kTypeAttribute, B_MIME_STRING_TYPE);</a>
<a name="ln199">	}</a>
<a name="ln200">	return error;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203"> </a>
<a name="ln204">status_t</a>
<a name="ln205">BAppFileInfo::GetSignature(char* signature) const</a>
<a name="ln206">{</a>
<a name="ln207">	// check param and initialization</a>
<a name="ln208">	status_t error = (signature ? B_OK : B_BAD_VALUE);</a>
<a name="ln209">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln210">		error = B_NO_INIT;</a>
<a name="ln211">	// read the data</a>
<a name="ln212">	size_t read = 0;</a>
<a name="ln213">	if (error == B_OK) {</a>
<a name="ln214">		error = _ReadData(kSignatureAttribute, kSignatureResourceID,</a>
<a name="ln215">			B_MIME_STRING_TYPE, signature, B_MIME_TYPE_LENGTH, read);</a>
<a name="ln216">	}</a>
<a name="ln217">	// check the read data -- null terminate the string</a>
<a name="ln218">	if (error == B_OK &amp;&amp; signature[read - 1] != '\0') {</a>
<a name="ln219">		if (read == B_MIME_TYPE_LENGTH)</a>
<a name="ln220">			error = B_ERROR;</a>
<a name="ln221">		else</a>
<a name="ln222">			signature[read] = '\0';</a>
<a name="ln223">	}</a>
<a name="ln224">	return error;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">status_t</a>
<a name="ln229">BAppFileInfo::SetSignature(const char* signature)</a>
<a name="ln230">{</a>
<a name="ln231">	// check initialization</a>
<a name="ln232">	status_t error = B_OK;</a>
<a name="ln233">	if (InitCheck() != B_OK)</a>
<a name="ln234">		error = B_NO_INIT;</a>
<a name="ln235">	if (error == B_OK) {</a>
<a name="ln236">		if (signature) {</a>
<a name="ln237">			// check param</a>
<a name="ln238">			size_t signatureLen = strlen(signature);</a>
<a name="ln239">			if (signatureLen &gt;= B_MIME_TYPE_LENGTH)</a>
<a name="ln240">				error = B_BAD_VALUE;</a>
<a name="ln241">			// write the data</a>
<a name="ln242">			if (error == B_OK) {</a>
<a name="ln243">				error = _WriteData(kSignatureAttribute, kSignatureResourceID,</a>
<a name="ln244">					B_MIME_STRING_TYPE, signature, signatureLen + 1);</a>
<a name="ln245">			}</a>
<a name="ln246">		} else</a>
<a name="ln247">			error = _RemoveData(kSignatureAttribute, B_MIME_STRING_TYPE);</a>
<a name="ln248">	}</a>
<a name="ln249">	return error;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252"> </a>
<a name="ln253">status_t</a>
<a name="ln254">BAppFileInfo::GetCatalogEntry(char* catalogEntry) const</a>
<a name="ln255">{</a>
<a name="ln256">	if (catalogEntry == NULL)</a>
<a name="ln257">		return B_BAD_VALUE;</a>
<a name="ln258"> </a>
<a name="ln259">	if (InitCheck() != B_OK)</a>
<a name="ln260">		return B_NO_INIT;</a>
<a name="ln261"> </a>
<a name="ln262">	size_t read = 0;</a>
<a name="ln263">	status_t error = _ReadData(kCatalogEntryAttribute, kCatalogEntryResourceID,</a>
<a name="ln264">		B_STRING_TYPE, catalogEntry, B_MIME_TYPE_LENGTH * 3, read);</a>
<a name="ln265"> </a>
<a name="ln266">	if (error != B_OK)</a>
<a name="ln267">		return error;</a>
<a name="ln268"> </a>
<a name="ln269">	if (read &gt;= B_MIME_TYPE_LENGTH * 3)</a>
<a name="ln270">		return B_ERROR;</a>
<a name="ln271"> </a>
<a name="ln272">	catalogEntry[read] = '\0';</a>
<a name="ln273"> </a>
<a name="ln274">	return B_OK;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277"> </a>
<a name="ln278">status_t</a>
<a name="ln279">BAppFileInfo::SetCatalogEntry(const char* catalogEntry)</a>
<a name="ln280">{</a>
<a name="ln281">	if (InitCheck() != B_OK)</a>
<a name="ln282">		return B_NO_INIT;</a>
<a name="ln283"> </a>
<a name="ln284">	if (catalogEntry == NULL)</a>
<a name="ln285">		return _RemoveData(kCatalogEntryAttribute, B_STRING_TYPE);</a>
<a name="ln286"> </a>
<a name="ln287">	size_t nameLength = strlen(catalogEntry);</a>
<a name="ln288">	if (nameLength &gt; B_MIME_TYPE_LENGTH * 3)</a>
<a name="ln289">		return B_BAD_VALUE;</a>
<a name="ln290"> </a>
<a name="ln291">	return _WriteData(kCatalogEntryAttribute, kCatalogEntryResourceID,</a>
<a name="ln292">		B_STRING_TYPE, catalogEntry, nameLength + 1);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">status_t</a>
<a name="ln297">BAppFileInfo::GetAppFlags(uint32* flags) const</a>
<a name="ln298">{</a>
<a name="ln299">	// check param and initialization</a>
<a name="ln300">	status_t error = flags != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln301">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln302">		error = B_NO_INIT;</a>
<a name="ln303">	// read the data</a>
<a name="ln304">	size_t read = 0;</a>
<a name="ln305">	if (error == B_OK) {</a>
<a name="ln306">		error = _ReadData(kAppFlagsAttribute, kAppFlagsResourceID,</a>
<a name="ln307">			B_APP_FLAGS_TYPE, flags, sizeof(uint32), read);</a>
<a name="ln308">	}</a>
<a name="ln309">	// check the read data</a>
<a name="ln310">	if (error == B_OK &amp;&amp; read != sizeof(uint32))</a>
<a name="ln311">		error = B_ERROR;</a>
<a name="ln312">	return error;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">status_t</a>
<a name="ln317">BAppFileInfo::SetAppFlags(uint32 flags)</a>
<a name="ln318">{</a>
<a name="ln319">	// check initialization</a>
<a name="ln320">	status_t error = B_OK;</a>
<a name="ln321">	if (InitCheck() != B_OK)</a>
<a name="ln322">		error = B_NO_INIT;</a>
<a name="ln323">	if (error == B_OK) {</a>
<a name="ln324">		// write the data</a>
<a name="ln325">		error = _WriteData(kAppFlagsAttribute, kAppFlagsResourceID,</a>
<a name="ln326">			B_APP_FLAGS_TYPE, &amp;flags, sizeof(uint32));</a>
<a name="ln327">	}</a>
<a name="ln328">	return error;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331"> </a>
<a name="ln332">status_t</a>
<a name="ln333">BAppFileInfo::RemoveAppFlags()</a>
<a name="ln334">{</a>
<a name="ln335">	// check initialization</a>
<a name="ln336">	status_t error = B_OK;</a>
<a name="ln337">	if (InitCheck() != B_OK)</a>
<a name="ln338">		error = B_NO_INIT;</a>
<a name="ln339">	if (error == B_OK) {</a>
<a name="ln340">		// remove the data</a>
<a name="ln341">		error = _RemoveData(kAppFlagsAttribute, B_APP_FLAGS_TYPE);</a>
<a name="ln342">	}</a>
<a name="ln343">	return error;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346"> </a>
<a name="ln347">status_t</a>
<a name="ln348">BAppFileInfo::GetSupportedTypes(BMessage* types) const</a>
<a name="ln349">{</a>
<a name="ln350">	// check param and initialization</a>
<a name="ln351">	status_t error = types != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln352">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln353">		error = B_NO_INIT;</a>
<a name="ln354">	// read the data</a>
<a name="ln355">	size_t read = 0;</a>
<a name="ln356">	void* buffer = NULL;</a>
<a name="ln357">	if (error == B_OK) {</a>
<a name="ln358">		error = _ReadData(kSupportedTypesAttribute, kSupportedTypesResourceID,</a>
<a name="ln359">			B_MESSAGE_TYPE, NULL, 0, read, &amp;buffer);</a>
<a name="ln360">	}</a>
<a name="ln361">	// unflatten the buffer</a>
<a name="ln362">	if (error == B_OK)</a>
<a name="ln363">		error = types-&gt;Unflatten((const char*)buffer);</a>
<a name="ln364">	// clean up</a>
<a name="ln365">	free(buffer);</a>
<a name="ln366">	return error;</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369"> </a>
<a name="ln370">status_t</a>
<a name="ln371">BAppFileInfo::SetSupportedTypes(const BMessage* types, bool updateMimeDB,</a>
<a name="ln372">	bool syncAll)</a>
<a name="ln373">{</a>
<a name="ln374">	// check initialization</a>
<a name="ln375">	status_t error = B_OK;</a>
<a name="ln376">	if (InitCheck() != B_OK)</a>
<a name="ln377">		error = B_NO_INIT;</a>
<a name="ln378"> </a>
<a name="ln379">	BMimeType mimeType;</a>
<a name="ln380">	if (error == B_OK)</a>
<a name="ln381">		error = GetMetaMime(&amp;mimeType);</a>
<a name="ln382"> </a>
<a name="ln383">	if (error == B_OK || error == B_ENTRY_NOT_FOUND) {</a>
<a name="ln384">		error = B_OK;</a>
<a name="ln385">		if (types) {</a>
<a name="ln386">			// check param -- supported types must be valid</a>
<a name="ln387">			const char* type;</a>
<a name="ln388">			for (int32 i = 0;</a>
<a name="ln389">				 error == B_OK &amp;&amp; types-&gt;FindString(&quot;types&quot;, i, &amp;type) == B_OK;</a>
<a name="ln390">				 i++) {</a>
<a name="ln391">				if (!BMimeType::IsValid(type))</a>
<a name="ln392">					error = B_BAD_VALUE;</a>
<a name="ln393">			}</a>
<a name="ln394"> </a>
<a name="ln395">			// get flattened size</a>
<a name="ln396">			ssize_t size = 0;</a>
<a name="ln397">			if (error == B_OK) {</a>
<a name="ln398">				size = types-&gt;FlattenedSize();</a>
<a name="ln399">				if (size &lt; 0)</a>
<a name="ln400">					error = size;</a>
<a name="ln401">			}</a>
<a name="ln402"> </a>
<a name="ln403">			// allocate a buffer for the flattened data</a>
<a name="ln404">			char* buffer = NULL;</a>
<a name="ln405">			if (error == B_OK) {</a>
<a name="ln406">				buffer = new(std::nothrow) char[size];</a>
<a name="ln407">				if (!buffer)</a>
<a name="ln408">					error = B_NO_MEMORY;</a>
<a name="ln409">			}</a>
<a name="ln410"> </a>
<a name="ln411">			// flatten the message</a>
<a name="ln412">			if (error == B_OK)</a>
<a name="ln413">				error = types-&gt;Flatten(buffer, size);</a>
<a name="ln414"> </a>
<a name="ln415">			// write the data</a>
<a name="ln416">			if (error == B_OK) {</a>
<a name="ln417">				error = _WriteData(kSupportedTypesAttribute,</a>
<a name="ln418">					kSupportedTypesResourceID, B_MESSAGE_TYPE, buffer, size);</a>
<a name="ln419">			}</a>
<a name="ln420"> </a>
<a name="ln421">			delete[] buffer;</a>
<a name="ln422">		} else</a>
<a name="ln423">			error = _RemoveData(kSupportedTypesAttribute, B_MESSAGE_TYPE);</a>
<a name="ln424"> </a>
<a name="ln425">		// update the MIME database, if the app signature is installed</a>
<a name="ln426">		if (updateMimeDB &amp;&amp; error == B_OK &amp;&amp; mimeType.IsInstalled())</a>
<a name="ln427">			error = mimeType.SetSupportedTypes(types, syncAll);</a>
<a name="ln428">	}</a>
<a name="ln429">	return error;</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432"> </a>
<a name="ln433">status_t</a>
<a name="ln434">BAppFileInfo::SetSupportedTypes(const BMessage* types, bool syncAll)</a>
<a name="ln435">{</a>
<a name="ln436">	return SetSupportedTypes(types, true, syncAll);</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439"> </a>
<a name="ln440">status_t</a>
<a name="ln441">BAppFileInfo::SetSupportedTypes(const BMessage* types)</a>
<a name="ln442">{</a>
<a name="ln443">	return SetSupportedTypes(types, true, false);</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446"> </a>
<a name="ln447">bool</a>
<a name="ln448">BAppFileInfo::IsSupportedType(const char* type) const</a>
<a name="ln449">{</a>
<a name="ln450">	status_t error = type != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln451">	// get the supported types</a>
<a name="ln452">	BMessage types;</a>
<a name="ln453">	if (error == B_OK)</a>
<a name="ln454">		error = GetSupportedTypes(&amp;types);</a>
<a name="ln455">	// turn type into a BMimeType</a>
<a name="ln456">	BMimeType mimeType;</a>
<a name="ln457">	if (error == B_OK)</a>
<a name="ln458">		error = mimeType.SetTo(type);</a>
<a name="ln459">	// iterate through the supported types</a>
<a name="ln460">	bool found = false;</a>
<a name="ln461">	if (error == B_OK) {</a>
<a name="ln462">		const char* supportedType;</a>
<a name="ln463">		for (int32 i = 0;</a>
<a name="ln464">			 !found &amp;&amp; types.FindString(&quot;types&quot;, i, &amp;supportedType) == B_OK;</a>
<a name="ln465">			 i++) {</a>
<a name="ln466">			found = strcmp(supportedType, &quot;application/octet-stream&quot;) == 0</a>
<a name="ln467">				|| BMimeType(supportedType).Contains(&amp;mimeType);</a>
<a name="ln468">		}</a>
<a name="ln469">	}</a>
<a name="ln470">	return found;</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473"> </a>
<a name="ln474">bool</a>
<a name="ln475">BAppFileInfo::Supports(BMimeType* type) const</a>
<a name="ln476">{</a>
<a name="ln477">	status_t error</a>
<a name="ln478">		= type != NULL &amp;&amp; type-&gt;InitCheck() == B_OK ? B_OK : B_BAD_VALUE;</a>
<a name="ln479">	// get the supported types</a>
<a name="ln480">	BMessage types;</a>
<a name="ln481">	if (error == B_OK)</a>
<a name="ln482">		error = GetSupportedTypes(&amp;types);</a>
<a name="ln483">	// iterate through the supported types</a>
<a name="ln484">	bool found = false;</a>
<a name="ln485">	if (error == B_OK) {</a>
<a name="ln486">		const char* supportedType;</a>
<a name="ln487">		for (int32 i = 0;</a>
<a name="ln488">			 !found &amp;&amp; types.FindString(&quot;types&quot;, i, &amp;supportedType) == B_OK;</a>
<a name="ln489">			 i++) {</a>
<a name="ln490">			found = BMimeType(supportedType).Contains(type);</a>
<a name="ln491">		}</a>
<a name="ln492">	}</a>
<a name="ln493">	return found;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496"> </a>
<a name="ln497">status_t</a>
<a name="ln498">BAppFileInfo::GetIcon(BBitmap* icon, icon_size which) const</a>
<a name="ln499">{</a>
<a name="ln500">	return GetIconForType(NULL, icon, which);</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503"> </a>
<a name="ln504">status_t</a>
<a name="ln505">BAppFileInfo::GetIcon(uint8** data, size_t* size) const</a>
<a name="ln506">{</a>
<a name="ln507">	return GetIconForType(NULL, data, size);</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510"> </a>
<a name="ln511">status_t</a>
<a name="ln512">BAppFileInfo::SetIcon(const BBitmap* icon, icon_size which, bool updateMimeDB)</a>
<a name="ln513">{</a>
<a name="ln514">	return SetIconForType(NULL, icon, which, updateMimeDB);</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517"> </a>
<a name="ln518">status_t</a>
<a name="ln519">BAppFileInfo::SetIcon(const BBitmap* icon, icon_size which)</a>
<a name="ln520">{</a>
<a name="ln521">	return SetIconForType(NULL, icon, which, true);</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524"> </a>
<a name="ln525">status_t</a>
<a name="ln526">BAppFileInfo::SetIcon(const uint8* data, size_t size, bool updateMimeDB)</a>
<a name="ln527">{</a>
<a name="ln528">	return SetIconForType(NULL, data, size, updateMimeDB);</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531"> </a>
<a name="ln532">status_t</a>
<a name="ln533">BAppFileInfo::SetIcon(const uint8* data, size_t size)</a>
<a name="ln534">{</a>
<a name="ln535">	return SetIconForType(NULL, data, size, true);</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">status_t</a>
<a name="ln540">BAppFileInfo::GetVersionInfo(version_info* info, version_kind kind) const</a>
<a name="ln541">{</a>
<a name="ln542">	// check params and initialization</a>
<a name="ln543">	if (info == NULL)</a>
<a name="ln544">		return B_BAD_VALUE;</a>
<a name="ln545"> </a>
<a name="ln546">	int32 index = 0;</a>
<a name="ln547">	switch (kind) {</a>
<a name="ln548">		case B_APP_VERSION_KIND:</a>
<a name="ln549">			index = 0;</a>
<a name="ln550">			break;</a>
<a name="ln551">		case B_SYSTEM_VERSION_KIND:</a>
<a name="ln552">			index = 1;</a>
<a name="ln553">			break;</a>
<a name="ln554">		default:</a>
<a name="ln555">			return B_BAD_VALUE;</a>
<a name="ln556">	}</a>
<a name="ln557"> </a>
<a name="ln558">	if (InitCheck() != B_OK)</a>
<a name="ln559">		return B_NO_INIT;</a>
<a name="ln560"> </a>
<a name="ln561">	// read the data</a>
<a name="ln562">	size_t read = 0;</a>
<a name="ln563">	version_info infos[2];</a>
<a name="ln564">	status_t error = _ReadData(kVersionInfoAttribute, kVersionInfoResourceID,</a>
<a name="ln565">		B_VERSION_INFO_TYPE, infos, 2 * sizeof(version_info), read);</a>
<a name="ln566">	if (error != B_OK)</a>
<a name="ln567">		return error;</a>
<a name="ln568"> </a>
<a name="ln569">	// check the read data</a>
<a name="ln570">	if (read == sizeof(version_info)) {</a>
<a name="ln571">		// only the app version info is there -- return a cleared system info</a>
<a name="ln572">		if (index == 0)</a>
<a name="ln573">			*info = infos[index];</a>
<a name="ln574">		else if (index == 1)</a>
<a name="ln575">			memset(info, 0, sizeof(version_info));</a>
<a name="ln576">	} else if (read == 2 * sizeof(version_info)) {</a>
<a name="ln577">		*info = infos[index];</a>
<a name="ln578">	} else</a>
<a name="ln579">		return B_ERROR;</a>
<a name="ln580"> </a>
<a name="ln581">	// return result	</a>
<a name="ln582">	return B_OK;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585"> </a>
<a name="ln586">status_t</a>
<a name="ln587">BAppFileInfo::SetVersionInfo(const version_info* info, version_kind kind)</a>
<a name="ln588">{</a>
<a name="ln589">	// check initialization</a>
<a name="ln590">	status_t error = B_OK;</a>
<a name="ln591">	if (InitCheck() != B_OK)</a>
<a name="ln592">		error = B_NO_INIT;</a>
<a name="ln593">	if (error == B_OK) {</a>
<a name="ln594">		if (info != NULL) {</a>
<a name="ln595">			// check param</a>
<a name="ln596">			int32 index = 0;</a>
<a name="ln597">			if (error == B_OK) {</a>
<a name="ln598">				switch (kind) {</a>
<a name="ln599">					case B_APP_VERSION_KIND:</a>
<a name="ln600">						index = 0;</a>
<a name="ln601">						break;</a>
<a name="ln602">					case B_SYSTEM_VERSION_KIND:</a>
<a name="ln603">						index = 1;</a>
<a name="ln604">						break;</a>
<a name="ln605">					default:</a>
<a name="ln606">						error = B_BAD_VALUE;</a>
<a name="ln607">						break;</a>
<a name="ln608">				}</a>
<a name="ln609">			}</a>
<a name="ln610">			// read both infos</a>
<a name="ln611">			version_info infos[2];</a>
<a name="ln612">			if (error == B_OK) {</a>
<a name="ln613">				size_t read;</a>
<a name="ln614">				if (_ReadData(kVersionInfoAttribute, kVersionInfoResourceID,</a>
<a name="ln615">						B_VERSION_INFO_TYPE, infos, 2 * sizeof(version_info),</a>
<a name="ln616">						read) == B_OK) {</a>
<a name="ln617">					// clear the part that hasn't been read</a>
<a name="ln618">					if (read &lt; sizeof(infos))</a>
<a name="ln619">						memset((char*)infos + read, 0, sizeof(infos) - read);</a>
<a name="ln620">				} else {</a>
<a name="ln621">					// failed to read -- clear</a>
<a name="ln622">					memset(infos, 0, sizeof(infos));</a>
<a name="ln623">				}</a>
<a name="ln624">			}</a>
<a name="ln625">			infos[index] = *info;</a>
<a name="ln626">			// write the data</a>
<a name="ln627">			if (error == B_OK) {</a>
<a name="ln628">				error = _WriteData(kVersionInfoAttribute,</a>
<a name="ln629">					kVersionInfoResourceID, B_VERSION_INFO_TYPE, infos,</a>
<a name="ln630">					2 * sizeof(version_info));</a>
<a name="ln631">			}</a>
<a name="ln632">		} else</a>
<a name="ln633">			error = _RemoveData(kVersionInfoAttribute, B_VERSION_INFO_TYPE);</a>
<a name="ln634">	}</a>
<a name="ln635">	return error;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638"> </a>
<a name="ln639">status_t</a>
<a name="ln640">BAppFileInfo::GetIconForType(const char* type, BBitmap* icon, icon_size size)</a>
<a name="ln641">	const</a>
<a name="ln642">{</a>
<a name="ln643">	if (InitCheck() != B_OK)</a>
<a name="ln644">		return B_NO_INIT;</a>
<a name="ln645"> </a>
<a name="ln646">	if (icon == NULL || icon-&gt;InitCheck() != B_OK)</a>
<a name="ln647">		return B_BAD_VALUE;</a>
<a name="ln648"> </a>
<a name="ln649">	// TODO: for consistency with attribute based icon reading, we</a>
<a name="ln650">	// could also prefer B_CMAP8 icons here if the provided bitmap</a>
<a name="ln651">	// is in that format. Right now, an existing B_CMAP8 icon resource</a>
<a name="ln652">	// would be ignored as soon as a vector icon is present. On the other</a>
<a name="ln653">	// hand, maybe this still results in a more consistent user interface,</a>
<a name="ln654">	// since Tracker/Deskbar would surely show the vector icon.</a>
<a name="ln655"> </a>
<a name="ln656">	// try vector icon first</a>
<a name="ln657">	BString vectorAttributeName(kIconAttribute);</a>
<a name="ln658"> </a>
<a name="ln659">	// check type param</a>
<a name="ln660">	if (type != NULL) {</a>
<a name="ln661">		if (BMimeType::IsValid(type))</a>
<a name="ln662">			vectorAttributeName += type;</a>
<a name="ln663">		else</a>
<a name="ln664">			return B_BAD_VALUE;</a>
<a name="ln665">	} else {</a>
<a name="ln666">		vectorAttributeName += kIconType;</a>
<a name="ln667">	}</a>
<a name="ln668">	const char* attribute = vectorAttributeName.String();</a>
<a name="ln669"> </a>
<a name="ln670">	size_t bytesRead;</a>
<a name="ln671">	void* allocatedBuffer;</a>
<a name="ln672">	status_t error = _ReadData(attribute, -1, B_VECTOR_ICON_TYPE, NULL, 0,</a>
<a name="ln673">		bytesRead, &amp;allocatedBuffer);</a>
<a name="ln674">	if (error == B_OK) {</a>
<a name="ln675">		error = BIconUtils::GetVectorIcon((uint8*)allocatedBuffer,</a>
<a name="ln676">										  bytesRead, icon);</a>
<a name="ln677">		free(allocatedBuffer);</a>
<a name="ln678">		return error;</a>
<a name="ln679">	}</a>
<a name="ln680"> </a>
<a name="ln681">	// no vector icon if we got this far,</a>
<a name="ln682">	// align size argument just in case</a>
<a name="ln683">	if (size &lt; B_LARGE_ICON)</a>
<a name="ln684">		size = B_MINI_ICON;</a>
<a name="ln685">	else</a>
<a name="ln686">		size = B_LARGE_ICON;</a>
<a name="ln687"> </a>
<a name="ln688">	error = B_OK;</a>
<a name="ln689">	// set some icon size related variables</a>
<a name="ln690">	BString attributeString;</a>
<a name="ln691">	BRect bounds;</a>
<a name="ln692">	uint32 attrType = 0;</a>
<a name="ln693">	size_t attrSize = 0;</a>
<a name="ln694">	switch (size) {</a>
<a name="ln695">		case B_MINI_ICON:</a>
<a name="ln696">			attributeString = kMiniIconAttribute;</a>
<a name="ln697">			bounds.Set(0, 0, 15, 15);</a>
<a name="ln698">			attrType = B_MINI_ICON_TYPE;</a>
<a name="ln699">			attrSize = 16 * 16;</a>
<a name="ln700">			break;</a>
<a name="ln701">		case B_LARGE_ICON:</a>
<a name="ln702">			attributeString = kLargeIconAttribute;</a>
<a name="ln703">			bounds.Set(0, 0, 31, 31);</a>
<a name="ln704">			attrType = B_LARGE_ICON_TYPE;</a>
<a name="ln705">			attrSize = 32 * 32;</a>
<a name="ln706">			break;</a>
<a name="ln707">		default:</a>
<a name="ln708">			return B_BAD_VALUE;</a>
<a name="ln709">	}</a>
<a name="ln710"> </a>
<a name="ln711">	// compose attribute name</a>
<a name="ln712">	attributeString += type != NULL ? type : kStandardIconType;</a>
<a name="ln713">	attribute = attributeString.String();</a>
<a name="ln714"> </a>
<a name="ln715">	// check parameters</a>
<a name="ln716">	// currently, scaling B_CMAP8 icons is not supported</a>
<a name="ln717">	if (icon-&gt;ColorSpace() == B_CMAP8 &amp;&amp; icon-&gt;Bounds() != bounds)</a>
<a name="ln718">		return B_BAD_VALUE;</a>
<a name="ln719"> </a>
<a name="ln720">	// read the data</a>
<a name="ln721">	if (error == B_OK) {</a>
<a name="ln722">		bool tempBuffer</a>
<a name="ln723">			= icon-&gt;ColorSpace() != B_CMAP8 || icon-&gt;Bounds() != bounds;</a>
<a name="ln724">		uint8* buffer = NULL;</a>
<a name="ln725">		size_t read;</a>
<a name="ln726">		if (tempBuffer) {</a>
<a name="ln727">			// other color space or bitmap size than stored in attribute</a>
<a name="ln728">			buffer = new(std::nothrow) uint8[attrSize];</a>
<a name="ln729">			if (!buffer) {</a>
<a name="ln730">				error = B_NO_MEMORY;</a>
<a name="ln731">			} else {</a>
<a name="ln732">				error = _ReadData(attribute, -1, attrType, buffer, attrSize,</a>
<a name="ln733">					read);</a>
<a name="ln734">			}</a>
<a name="ln735">		} else {</a>
<a name="ln736">			error = _ReadData(attribute, -1, attrType, icon-&gt;Bits(), attrSize,</a>
<a name="ln737">				read);</a>
<a name="ln738">		}</a>
<a name="ln739">		if (error == B_OK &amp;&amp; read != attrSize)</a>
<a name="ln740">			error = B_ERROR;</a>
<a name="ln741">		if (tempBuffer) {</a>
<a name="ln742">			// other color space than stored in attribute</a>
<a name="ln743">			if (error == B_OK) {</a>
<a name="ln744">				error = BIconUtils::ConvertFromCMAP8(buffer, (uint32)size,</a>
<a name="ln745">					(uint32)size, (uint32)size, icon);</a>
<a name="ln746">			}</a>
<a name="ln747">			delete[] buffer;</a>
<a name="ln748">		}</a>
<a name="ln749">	}</a>
<a name="ln750">	return error;</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753"> </a>
<a name="ln754">status_t</a>
<a name="ln755">BAppFileInfo::GetIconForType(const char* type, uint8** data, size_t* size) const</a>
<a name="ln756">{</a>
<a name="ln757">	if (InitCheck() != B_OK)</a>
<a name="ln758">		return B_NO_INIT;</a>
<a name="ln759"> </a>
<a name="ln760">	if (data == NULL || size == NULL)</a>
<a name="ln761">		return B_BAD_VALUE;</a>
<a name="ln762"> </a>
<a name="ln763">	// get vector icon</a>
<a name="ln764">	BString attributeName(kIconAttribute);</a>
<a name="ln765"> </a>
<a name="ln766">	// check type param</a>
<a name="ln767">	if (type != NULL) {</a>
<a name="ln768">		if (BMimeType::IsValid(type))</a>
<a name="ln769">			attributeName += type;</a>
<a name="ln770">		else</a>
<a name="ln771">			return B_BAD_VALUE;</a>
<a name="ln772">	} else</a>
<a name="ln773">		attributeName += kIconType;</a>
<a name="ln774"> </a>
<a name="ln775">	void* allocatedBuffer = NULL;</a>
<a name="ln776">	status_t ret = _ReadData(attributeName.String(), -1, B_VECTOR_ICON_TYPE,</a>
<a name="ln777">		NULL, 0, *size, &amp;allocatedBuffer);</a>
<a name="ln778"> </a>
<a name="ln779">	if (ret &lt; B_OK)</a>
<a name="ln780">		return ret;</a>
<a name="ln781"> </a>
<a name="ln782">	*data = (uint8*)allocatedBuffer;</a>
<a name="ln783">	return B_OK;</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786"> </a>
<a name="ln787">status_t</a>
<a name="ln788">BAppFileInfo::SetIconForType(const char* type, const BBitmap* icon,</a>
<a name="ln789">	icon_size which, bool updateMimeDB)</a>
<a name="ln790">{</a>
<a name="ln791">	status_t error = B_OK;</a>
<a name="ln792"> </a>
<a name="ln793">	// set some icon size related variables</a>
<a name="ln794">	BString attributeString;</a>
<a name="ln795">	BRect bounds;</a>
<a name="ln796">	uint32 attrType = 0;</a>
<a name="ln797">	size_t attrSize = 0;</a>
<a name="ln798">	int32 resourceID = 0;</a>
<a name="ln799">	switch (which) {</a>
<a name="ln800">		case B_MINI_ICON:</a>
<a name="ln801">			attributeString = kMiniIconAttribute;</a>
<a name="ln802">			bounds.Set(0, 0, 15, 15);</a>
<a name="ln803">			attrType = B_MINI_ICON_TYPE;</a>
<a name="ln804">			attrSize = 16 * 16;</a>
<a name="ln805">			resourceID = type != NULL</a>
<a name="ln806">				? kMiniIconForTypeResourceID : kMiniIconResourceID;</a>
<a name="ln807">			break;</a>
<a name="ln808">		case B_LARGE_ICON:</a>
<a name="ln809">			attributeString = kLargeIconAttribute;</a>
<a name="ln810">			bounds.Set(0, 0, 31, 31);</a>
<a name="ln811">			attrType = B_LARGE_ICON_TYPE;</a>
<a name="ln812">			attrSize = 32 * 32;</a>
<a name="ln813">			resourceID = type != NULL</a>
<a name="ln814">				? kLargeIconForTypeResourceID : kLargeIconResourceID;</a>
<a name="ln815">			break;</a>
<a name="ln816">		default:</a>
<a name="ln817">			error = B_BAD_VALUE;</a>
<a name="ln818">			break;</a>
<a name="ln819">	}</a>
<a name="ln820"> </a>
<a name="ln821">	// check type param</a>
<a name="ln822">	if (error == B_OK) {</a>
<a name="ln823">		if (type != NULL) {</a>
<a name="ln824">			if (BMimeType::IsValid(type))</a>
<a name="ln825">				attributeString += type;</a>
<a name="ln826">			else</a>
<a name="ln827">				error = B_BAD_VALUE;</a>
<a name="ln828">		} else</a>
<a name="ln829">			attributeString += kStandardIconType;</a>
<a name="ln830">	}</a>
<a name="ln831">	const char* attribute = attributeString.String();</a>
<a name="ln832"> </a>
<a name="ln833">	// check parameter and initialization</a>
<a name="ln834">	if (error == B_OK &amp;&amp; icon != NULL</a>
<a name="ln835">		&amp;&amp; (icon-&gt;InitCheck() != B_OK || icon-&gt;Bounds() != bounds)) {</a>
<a name="ln836">		error = B_BAD_VALUE;</a>
<a name="ln837">	}</a>
<a name="ln838">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln839">		error = B_NO_INIT;</a>
<a name="ln840"> </a>
<a name="ln841">	// write/remove the attribute</a>
<a name="ln842">	if (error == B_OK) {</a>
<a name="ln843">		if (icon != NULL) {</a>
<a name="ln844">			bool otherColorSpace = (icon-&gt;ColorSpace() != B_CMAP8);</a>
<a name="ln845">			if (otherColorSpace) {</a>
<a name="ln846">				BBitmap bitmap(bounds, B_BITMAP_NO_SERVER_LINK, B_CMAP8);</a>
<a name="ln847">				error = bitmap.InitCheck();</a>
<a name="ln848">				if (error == B_OK)</a>
<a name="ln849">					error = bitmap.ImportBits(icon);</a>
<a name="ln850">				if (error == B_OK) {</a>
<a name="ln851">					error = _WriteData(attribute, resourceID, attrType,</a>
<a name="ln852">						bitmap.Bits(), attrSize, true);</a>
<a name="ln853">				}</a>
<a name="ln854">			} else {</a>
<a name="ln855">				error = _WriteData(attribute, resourceID, attrType,</a>
<a name="ln856">					icon-&gt;Bits(), attrSize, true);</a>
<a name="ln857">			}</a>
<a name="ln858">		} else	// no icon given =&gt; remove</a>
<a name="ln859">			error = _RemoveData(attribute, attrType);</a>
<a name="ln860">	}</a>
<a name="ln861"> </a>
<a name="ln862">	// set the attribute on the MIME type, if the file has a signature</a>
<a name="ln863">	BMimeType mimeType;</a>
<a name="ln864">	if (updateMimeDB &amp;&amp; error == B_OK &amp;&amp; GetMetaMime(&amp;mimeType) == B_OK) {</a>
<a name="ln865">		if (!mimeType.IsInstalled())</a>
<a name="ln866">			error = mimeType.Install();</a>
<a name="ln867">		if (error == B_OK)</a>
<a name="ln868">			error = mimeType.SetIconForType(type, icon, which);</a>
<a name="ln869">	}</a>
<a name="ln870">	return error;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873"> </a>
<a name="ln874">status_t</a>
<a name="ln875">BAppFileInfo::SetIconForType(const char* type, const BBitmap* icon,</a>
<a name="ln876">	icon_size which)</a>
<a name="ln877">{</a>
<a name="ln878">	return SetIconForType(type, icon, which, true);</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881"> </a>
<a name="ln882">status_t</a>
<a name="ln883">BAppFileInfo::SetIconForType(const char* type, const uint8* data, size_t size,</a>
<a name="ln884">	bool updateMimeDB)</a>
<a name="ln885">{</a>
<a name="ln886">	if (InitCheck() != B_OK)</a>
<a name="ln887">		return B_NO_INIT;</a>
<a name="ln888"> </a>
<a name="ln889">	// set some icon related variables</a>
<a name="ln890">	BString attributeString = kIconAttribute;</a>
<a name="ln891">	int32 resourceID = type ? kIconForTypeResourceID : kIconResourceID;</a>
<a name="ln892">	uint32 attrType = B_VECTOR_ICON_TYPE;</a>
<a name="ln893"> </a>
<a name="ln894">	// check type param</a>
<a name="ln895">	if (type != NULL) {</a>
<a name="ln896">		if (BMimeType::IsValid(type))</a>
<a name="ln897">			attributeString += type;</a>
<a name="ln898">		else</a>
<a name="ln899">			return B_BAD_VALUE;</a>
<a name="ln900">	} else</a>
<a name="ln901">		attributeString += kIconType;</a>
<a name="ln902"> </a>
<a name="ln903">	const char* attribute = attributeString.String();</a>
<a name="ln904"> </a>
<a name="ln905">	status_t error;</a>
<a name="ln906">	// write/remove the attribute</a>
<a name="ln907">	if (data != NULL)</a>
<a name="ln908">		error = _WriteData(attribute, resourceID, attrType, data, size, true);</a>
<a name="ln909">	else	// no icon given =&gt; remove</a>
<a name="ln910">		error = _RemoveData(attribute, attrType);</a>
<a name="ln911"> </a>
<a name="ln912">	// set the attribute on the MIME type, if the file has a signature</a>
<a name="ln913">	BMimeType mimeType;</a>
<a name="ln914">	if (updateMimeDB &amp;&amp; error == B_OK &amp;&amp; GetMetaMime(&amp;mimeType) == B_OK) {</a>
<a name="ln915">		if (!mimeType.IsInstalled())</a>
<a name="ln916">			error = mimeType.Install();</a>
<a name="ln917">		if (error == B_OK)</a>
<a name="ln918">			error = mimeType.SetIconForType(type, data, size);</a>
<a name="ln919">	}</a>
<a name="ln920">	return error;</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923"> </a>
<a name="ln924">status_t</a>
<a name="ln925">BAppFileInfo::SetIconForType(const char* type, const uint8* data, size_t size)</a>
<a name="ln926">{</a>
<a name="ln927">	return SetIconForType(type, data, size, true);</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930"> </a>
<a name="ln931">void</a>
<a name="ln932">BAppFileInfo::SetInfoLocation(info_location location)</a>
<a name="ln933">{</a>
<a name="ln934">	// if the resources failed to initialize, we must not use them</a>
<a name="ln935">	if (fResources == NULL)</a>
<a name="ln936">		location = info_location(location &amp; ~B_USE_RESOURCES);</a>
<a name="ln937"> </a>
<a name="ln938">	fWhere = location;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">bool</a>
<a name="ln942">BAppFileInfo::IsUsingAttributes() const</a>
<a name="ln943">{</a>
<a name="ln944">	return (fWhere &amp; B_USE_ATTRIBUTES) != 0;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947"> </a>
<a name="ln948">bool</a>
<a name="ln949">BAppFileInfo::IsUsingResources() const</a>
<a name="ln950">{</a>
<a name="ln951">	return (fWhere &amp; B_USE_RESOURCES) != 0;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954"> </a>
<a name="ln955">// FBC</a>
<a name="ln956">void BAppFileInfo::_ReservedAppFileInfo1() {}</a>
<a name="ln957">void BAppFileInfo::_ReservedAppFileInfo2() {}</a>
<a name="ln958">void BAppFileInfo::_ReservedAppFileInfo3() {}</a>
<a name="ln959"> </a>
<a name="ln960"> </a>
<a name="ln961">//!	Privatized assignment operator to prevent usage.</a>
<a name="ln962">BAppFileInfo&amp;</a>
<a name="ln963">BAppFileInfo::operator=(const BAppFileInfo&amp;)</a>
<a name="ln964">{</a>
<a name="ln965">	return *this;</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968"> </a>
<a name="ln969">//! Privatized copy constructor to prevent usage.</a>
<a name="ln970">BAppFileInfo::BAppFileInfo(const BAppFileInfo&amp;)</a>
<a name="ln971">{</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">/*!	Initializes a BMimeType to the signature of the associated file.</a>
<a name="ln976"> </a>
<a name="ln977">	\warning The parameter \a meta is not checked.</a>
<a name="ln978"> </a>
<a name="ln979">	\param meta A pointer to a pre-allocated BMimeType that shall be</a>
<a name="ln980">		   initialized to the signature of the associated file.</a>
<a name="ln981"> </a>
<a name="ln982">	\returns A status code.</a>
<a name="ln983">	\retval B_OK Everything went fine.</a>
<a name="ln984">	\retval B_BAD_VALUE \c NULL \a meta</a>
<a name="ln985">	\retval B_ENTRY_NOT_FOUND The file has not signature or the signature is</a>
<a name="ln986">	        (not installed in the MIME database.) no valid MIME string.</a>
<a name="ln987">*/</a>
<a name="ln988">status_t</a>
<a name="ln989">BAppFileInfo::GetMetaMime(BMimeType* meta) const</a>
<a name="ln990">{</a>
<a name="ln991">	char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln992">	status_t error = GetSignature(signature);</a>
<a name="ln993">	if (error == B_OK)</a>
<a name="ln994">		error = meta-&gt;SetTo(signature);</a>
<a name="ln995">	else if (error == B_BAD_VALUE)</a>
<a name="ln996">		error = B_ENTRY_NOT_FOUND;</a>
<a name="ln997">	if (error == B_OK &amp;&amp; !meta-&gt;IsValid())</a>
<a name="ln998">		error = B_BAD_VALUE;</a>
<a name="ln999">	return error;</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002"> </a>
<a name="ln1003">/*!	Reads data from an attribute or resource.</a>
<a name="ln1004"> </a>
<a name="ln1005">	\note The data is read from the location specified by \a fWhere.</a>
<a name="ln1006"> </a>
<a name="ln1007">	\warning The object must be properly initialized. The parameters are</a>
<a name="ln1008">		\b NOT checked.</a>
<a name="ln1009"> </a>
<a name="ln1010">	\param name The name of the attribute/resource to be read.</a>
<a name="ln1011">	\param id The resource ID of the resource to be read. It is ignored</a>
<a name="ln1012">		   when &lt; 0.</a>
<a name="ln1013">	\param type The type of the attribute/resource to be read.</a>
<a name="ln1014">	\param buffer A pre-allocated buffer for the data to be read.</a>
<a name="ln1015">	\param bufferSize The size of the supplied buffer.</a>
<a name="ln1016">	\param bytesRead A reference parameter, set to the number of bytes</a>
<a name="ln1017">		   actually read.</a>
<a name="ln1018">	\param allocatedBuffer If not \c NULL, the method allocates a buffer</a>
<a name="ln1019">		   large enough too store the whole data and writes a pointer to it</a>
<a name="ln1020">		   into this variable. If \c NULL, the supplied buffer is used.</a>
<a name="ln1021"> </a>
<a name="ln1022">	\returns A status code.</a>
<a name="ln1023">	\retval B_OK Everything went fine.</a>
<a name="ln1024">	\retval B_ENTRY_NOT_FOUND The entry was not found.</a>
<a name="ln1025">	\retval B_NO_MEMORY Ran out of memory allocating the buffer.</a>
<a name="ln1026">	\retval B_BAD_VALUE \a type did not match.</a>
<a name="ln1027">*/</a>
<a name="ln1028">status_t</a>
<a name="ln1029">BAppFileInfo::_ReadData(const char* name, int32 id, type_code type,</a>
<a name="ln1030">	void* buffer, size_t bufferSize, size_t&amp; bytesRead, void** allocatedBuffer)</a>
<a name="ln1031">	const</a>
<a name="ln1032">{</a>
<a name="ln1033">	status_t error = B_OK;</a>
<a name="ln1034"> </a>
<a name="ln1035">	if (allocatedBuffer)</a>
<a name="ln1036">		buffer = NULL;</a>
<a name="ln1037"> </a>
<a name="ln1038">	bool foundData = false;</a>
<a name="ln1039"> </a>
<a name="ln1040">	if (IsUsingAttributes()) {</a>
<a name="ln1041">		// get an attribute info</a>
<a name="ln1042">		attr_info info;</a>
<a name="ln1043">		if (error == B_OK)</a>
<a name="ln1044">			error = fNode-&gt;GetAttrInfo(name, &amp;info);</a>
<a name="ln1045"> </a>
<a name="ln1046">		// check type and size, allocate a buffer, if required</a>
<a name="ln1047">		if (error == B_OK &amp;&amp; info.type != type)</a>
<a name="ln1048">			error = B_BAD_VALUE;</a>
<a name="ln1049">		if (error == B_OK &amp;&amp; allocatedBuffer != NULL) {</a>
<a name="ln1050">			buffer = malloc(info.size);</a>
<a name="ln1051">			if (buffer == NULL)</a>
<a name="ln1052">				error = B_NO_MEMORY;</a>
<a name="ln1053">			bufferSize = info.size;</a>
<a name="ln1054">		}</a>
<a name="ln1055">		if (error == B_OK &amp;&amp; (off_t)bufferSize &lt; info.size)</a>
<a name="ln1056">			error = B_BAD_VALUE;</a>
<a name="ln1057"> </a>
<a name="ln1058">		// read the data</a>
<a name="ln1059">		if (error == B_OK) {</a>
<a name="ln1060">			ssize_t read = fNode-&gt;ReadAttr(name, type, 0, buffer, info.size);</a>
<a name="ln1061">			if (read &lt; 0)</a>
<a name="ln1062">				error = read;</a>
<a name="ln1063">			else if (read != info.size)</a>
<a name="ln1064">				error = B_ERROR;</a>
<a name="ln1065">			else</a>
<a name="ln1066">				bytesRead = read;</a>
<a name="ln1067">		}</a>
<a name="ln1068"> </a>
<a name="ln1069">		foundData = error == B_OK;</a>
<a name="ln1070"> </a>
<a name="ln1071">		// free the allocated buffer on error</a>
<a name="ln1072">		if (!foundData &amp;&amp; allocatedBuffer != NULL &amp;&amp; buffer != NULL) {</a>
<a name="ln1073">			free(buffer);</a>
<a name="ln1074">			buffer = NULL;</a>
<a name="ln1075">		}</a>
<a name="ln1076">	}</a>
<a name="ln1077"> </a>
<a name="ln1078">	if (!foundData &amp;&amp; IsUsingResources()) {</a>
<a name="ln1079">		// get a resource info</a>
<a name="ln1080">		error = B_OK;</a>
<a name="ln1081">		int32 idFound;</a>
<a name="ln1082">		size_t sizeFound;</a>
<a name="ln1083">		if (error == B_OK) {</a>
<a name="ln1084">			if (!fResources-&gt;GetResourceInfo(type, name, &amp;idFound, &amp;sizeFound))</a>
<a name="ln1085">				error = B_ENTRY_NOT_FOUND;</a>
<a name="ln1086">		}</a>
<a name="ln1087"> </a>
<a name="ln1088">		// check id and size, allocate a buffer, if required</a>
<a name="ln1089">		if (error == B_OK &amp;&amp; id &gt;= 0 &amp;&amp; idFound != id)</a>
<a name="ln1090">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln1091">		if (error == B_OK &amp;&amp; allocatedBuffer) {</a>
<a name="ln1092">			buffer = malloc(sizeFound);</a>
<a name="ln1093">			if (!buffer)</a>
<a name="ln1094">				error = B_NO_MEMORY;</a>
<a name="ln1095">			bufferSize = sizeFound;</a>
<a name="ln1096">		}</a>
<a name="ln1097">		if (error == B_OK &amp;&amp; bufferSize &lt; sizeFound)</a>
<a name="ln1098">			error = B_BAD_VALUE;</a>
<a name="ln1099"> </a>
<a name="ln1100">		// load resource</a>
<a name="ln1101">		const void* resourceData = NULL;</a>
<a name="ln1102">		if (error == B_OK) {</a>
<a name="ln1103">			resourceData = fResources-&gt;LoadResource(type, name, &amp;bytesRead);</a>
<a name="ln1104">			if (resourceData != NULL &amp;&amp; sizeFound == bytesRead)</a>
<a name="ln1105">				memcpy(buffer, resourceData, bytesRead);</a>
<a name="ln1106">			else</a>
<a name="ln1107">				error = B_ERROR;</a>
<a name="ln1108">		}</a>
<a name="ln1109">	} else if (!foundData)</a>
<a name="ln1110">		error = B_BAD_VALUE;</a>
<a name="ln1111"> </a>
<a name="ln1112">	// return the allocated buffer, or free it on error</a>
<a name="ln1113">	if (allocatedBuffer != NULL) {</a>
<a name="ln1114">		if (error == B_OK)</a>
<a name="ln1115">			*allocatedBuffer = buffer;</a>
<a name="ln1116">		else</a>
<a name="ln1117">			free(buffer);</a>
<a name="ln1118">	}</a>
<a name="ln1119"> </a>
<a name="ln1120">	return error;</a>
<a name="ln1121">}</a>
<a name="ln1122"> </a>
<a name="ln1123"> </a>
<a name="ln1124">/*!	Writes data to an attribute or resource.</a>
<a name="ln1125"> </a>
<a name="ln1126">	\note The data is written to the location(s) specified by \a fWhere.</a>
<a name="ln1127"> </a>
<a name="ln1128">	\warning The object must be properly initialized. The parameters are</a>
<a name="ln1129">		\b NOT checked.</a>
<a name="ln1130"> </a>
<a name="ln1131">	\param name The name of the attribute/resource to be written.</a>
<a name="ln1132">	\param id The resource ID of the resource to be written.</a>
<a name="ln1133">	\param type The type of the attribute/resource to be written.</a>
<a name="ln1134">	\param buffer A buffer containing the data to be written.</a>
<a name="ln1135">	\param bufferSize The size of the supplied buffer.</a>
<a name="ln1136">	\param findID If set to \c true use the ID that is already assigned to the</a>
<a name="ln1137">		   \a name / \a type pair or take the first unused ID &gt;= \a id.</a>
<a name="ln1138">		   If \c false, \a id is used.</a>
<a name="ln1139"> </a>
<a name="ln1140">	\returns A status code.</a>
<a name="ln1141">	\retval B_OK Everything went fine.</a>
<a name="ln1142">	\retval B_ERROR An error occurred while trying to write the data.</a>
<a name="ln1143">*/</a>
<a name="ln1144">status_t</a>
<a name="ln1145">BAppFileInfo::_WriteData(const char* name, int32 id, type_code type,</a>
<a name="ln1146">	const void* buffer, size_t bufferSize, bool findID)</a>
<a name="ln1147">{</a>
<a name="ln1148">	if (!IsUsingAttributes() &amp;&amp; !IsUsingResources())</a>
<a name="ln1149">		return B_NO_INIT;</a>
<a name="ln1150"> </a>
<a name="ln1151">	status_t error = B_OK;</a>
<a name="ln1152"> </a>
<a name="ln1153">	// write to attribute</a>
<a name="ln1154">	if (IsUsingAttributes()) {</a>
<a name="ln1155">		ssize_t written = fNode-&gt;WriteAttr(name, type, 0, buffer, bufferSize);</a>
<a name="ln1156">		if (written &lt; 0)</a>
<a name="ln1157">			error = written;</a>
<a name="ln1158">		else if (written != (ssize_t)bufferSize)</a>
<a name="ln1159">			error = B_ERROR;</a>
<a name="ln1160">	}</a>
<a name="ln1161">	// write to resource</a>
<a name="ln1162">	if (IsUsingResources() &amp;&amp; error == B_OK) {</a>
<a name="ln1163">		if (findID) {</a>
<a name="ln1164">			// get the resource info</a>
<a name="ln1165">			int32 idFound;</a>
<a name="ln1166">			size_t sizeFound;</a>
<a name="ln1167">			if (fResources-&gt;GetResourceInfo(type, name, &amp;idFound, &amp;sizeFound))</a>
<a name="ln1168">				id = idFound;</a>
<a name="ln1169">			else {</a>
<a name="ln1170">				// type-name pair doesn't exist yet -- find unused ID</a>
<a name="ln1171">				while (fResources-&gt;HasResource(type, id))</a>
<a name="ln1172">					id++;</a>
<a name="ln1173">			}</a>
<a name="ln1174">		}</a>
<a name="ln1175">		error = fResources-&gt;AddResource(type, id, buffer, bufferSize, name);</a>
<a name="ln1176">	}</a>
<a name="ln1177">	return error;</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180"> </a>
<a name="ln1181">/*!	Removes an attribute or resource.</a>
<a name="ln1182"> </a>
<a name="ln1183">	\note The removal location is specified by \a fWhere.</a>
<a name="ln1184"> </a>
<a name="ln1185">	\warning The object must be properly initialized. The parameters are</a>
<a name="ln1186">		\b NOT checked.</a>
<a name="ln1187"> </a>
<a name="ln1188">	\param name The name of the attribute/resource to be remove.</a>
<a name="ln1189">	\param type The type of the attribute/resource to be removed.</a>
<a name="ln1190"> </a>
<a name="ln1191">	\returns A status code.</a>
<a name="ln1192">	\retval B_OK Everything went fine.</a>
<a name="ln1193">	\retval B_NO_INIT Not using attributes and not using resources.</a>
<a name="ln1194">	\retval B_ENTRY_NOT_FOUND The attribute or resource was not found.</a>
<a name="ln1195">*/</a>
<a name="ln1196">status_t</a>
<a name="ln1197">BAppFileInfo::_RemoveData(const char* name, type_code type)</a>
<a name="ln1198">{</a>
<a name="ln1199">	if (!IsUsingAttributes() &amp;&amp; !IsUsingResources())</a>
<a name="ln1200">		return B_NO_INIT;</a>
<a name="ln1201"> </a>
<a name="ln1202">	status_t error = B_OK;</a>
<a name="ln1203"> </a>
<a name="ln1204">	// remove the attribute</a>
<a name="ln1205">	if (IsUsingAttributes()) {</a>
<a name="ln1206">		error = fNode-&gt;RemoveAttr(name);</a>
<a name="ln1207">		// It's no error, if there has been no attribute.</a>
<a name="ln1208">		if (error == B_ENTRY_NOT_FOUND)</a>
<a name="ln1209">			error = B_OK;</a>
<a name="ln1210">	}</a>
<a name="ln1211">	// remove the resource</a>
<a name="ln1212">	if (IsUsingResources() &amp;&amp; error == B_OK) {</a>
<a name="ln1213">		// get a resource info</a>
<a name="ln1214">		int32 idFound;</a>
<a name="ln1215">		size_t sizeFound;</a>
<a name="ln1216">		if (fResources-&gt;GetResourceInfo(type, name, &amp;idFound, &amp;sizeFound))</a>
<a name="ln1217">			error = fResources-&gt;RemoveResource(type, idFound);</a>
<a name="ln1218">	}</a>
<a name="ln1219">	return error;</a>
<a name="ln1220">}</a>

</code></pre>
<div class="balloon" rel="1083"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="1043"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="597"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="721"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
