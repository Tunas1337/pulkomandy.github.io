
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ShowImageView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2003-2011, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Copyright 2004-2005 yellowTAB GmbH. All Rights Reserverd.</a>
<a name="ln4"> * Copyright 2006 Bernd Korz. All Rights Reserved</a>
<a name="ln5"> * Distributed under the terms of the MIT License.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Authors:</a>
<a name="ln8"> *		Fernando Francisco de Oliveira</a>
<a name="ln9"> *		Michael Wilber</a>
<a name="ln10"> *		Michael Pfeiffer</a>
<a name="ln11"> *		Ryan Leavengood</a>
<a name="ln12"> *		yellowTAB GmbH</a>
<a name="ln13"> *		Bernd Korz</a>
<a name="ln14"> *		Stephan Aßmus &lt;superstippi@gmx.de&gt;</a>
<a name="ln15"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln16"> */</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;ShowImageView.h&quot;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;math.h&gt;</a>
<a name="ln22">#include &lt;new&gt;</a>
<a name="ln23">#include &lt;stdio.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;Alert.h&gt;</a>
<a name="ln26">#include &lt;Application.h&gt;</a>
<a name="ln27">#include &lt;Bitmap.h&gt;</a>
<a name="ln28">#include &lt;BitmapStream.h&gt;</a>
<a name="ln29">#include &lt;Catalog.h&gt;</a>
<a name="ln30">#include &lt;Clipboard.h&gt;</a>
<a name="ln31">#include &lt;Cursor.h&gt;</a>
<a name="ln32">#include &lt;Debug.h&gt;</a>
<a name="ln33">#include &lt;Directory.h&gt;</a>
<a name="ln34">#include &lt;Entry.h&gt;</a>
<a name="ln35">#include &lt;File.h&gt;</a>
<a name="ln36">#include &lt;Locale.h&gt;</a>
<a name="ln37">#include &lt;MenuBar.h&gt;</a>
<a name="ln38">#include &lt;MenuItem.h&gt;</a>
<a name="ln39">#include &lt;Message.h&gt;</a>
<a name="ln40">#include &lt;NodeInfo.h&gt;</a>
<a name="ln41">#include &lt;Path.h&gt;</a>
<a name="ln42">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln43">#include &lt;Rect.h&gt;</a>
<a name="ln44">#include &lt;Region.h&gt;</a>
<a name="ln45">#include &lt;Roster.h&gt;</a>
<a name="ln46">#include &lt;Screen.h&gt;</a>
<a name="ln47">#include &lt;ScrollBar.h&gt;</a>
<a name="ln48">#include &lt;StopWatch.h&gt;</a>
<a name="ln49">#include &lt;SupportDefs.h&gt;</a>
<a name="ln50">#include &lt;TranslatorRoster.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;tracker_private.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;ImageCache.h&quot;</a>
<a name="ln55">#include &quot;ShowImageApp.h&quot;</a>
<a name="ln56">#include &quot;ShowImageWindow.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58"> </a>
<a name="ln59">using std::nothrow;</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">class PopUpMenu : public BPopUpMenu {</a>
<a name="ln63">	public:</a>
<a name="ln64">		PopUpMenu(const char* name, BMessenger target);</a>
<a name="ln65">		virtual ~PopUpMenu();</a>
<a name="ln66"> </a>
<a name="ln67">	private:</a>
<a name="ln68">		BMessenger fTarget;</a>
<a name="ln69">};</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">// the delay time for hiding the cursor in 1/10 seconds (the pulse rate)</a>
<a name="ln73">#define HIDE_CURSOR_DELAY_TIME 20</a>
<a name="ln74">#define STICKY_ZOOM_DELAY_TIME 5</a>
<a name="ln75">#define SHOW_IMAGE_ORIENTATION_ATTRIBUTE &quot;ShowImage:orientation&quot;</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">const rgb_color kBorderColor = { 0, 0, 0, 255 };</a>
<a name="ln79"> </a>
<a name="ln80">enum ShowImageView::image_orientation</a>
<a name="ln81">ShowImageView::fTransformation[ImageProcessor::kNumberOfAffineTransformations]</a>
<a name="ln82">		[kNumberOfOrientations] = {</a>
<a name="ln83">	// rotate 90°</a>
<a name="ln84">	{k90, k180, k270, k0, k270V, k0V, k90V, k0H},</a>
<a name="ln85">	// rotate -90°</a>
<a name="ln86">	{k270, k0, k90, k180, k90V, k0H, k270V, k0V},</a>
<a name="ln87">	// mirror vertical</a>
<a name="ln88">	{k0H, k270V, k0V, k90V, k180, k270, k0, k90},</a>
<a name="ln89">	// mirror horizontal</a>
<a name="ln90">	{k0V, k90V, k0H, k270V, k0, k90, k180, k270}</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93">const rgb_color kAlphaLow = (rgb_color) { 0xbb, 0xbb, 0xbb, 0xff };</a>
<a name="ln94">const rgb_color kAlphaHigh = (rgb_color) { 0xe0, 0xe0, 0xe0, 0xff };</a>
<a name="ln95"> </a>
<a name="ln96">const uint32 kMsgPopUpMenuClosed = 'pmcl';</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">inline void</a>
<a name="ln100">blend_colors(uint8* d, uint8 r, uint8 g, uint8 b, uint8 a)</a>
<a name="ln101">{</a>
<a name="ln102">	d[0] = ((b - d[0]) * a + (d[0] &lt;&lt; 8)) &gt;&gt; 8;</a>
<a name="ln103">	d[1] = ((g - d[1]) * a + (d[1] &lt;&lt; 8)) &gt;&gt; 8;</a>
<a name="ln104">	d[2] = ((r - d[2]) * a + (d[2] &lt;&lt; 8)) &gt;&gt; 8;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">BBitmap*</a>
<a name="ln109">compose_checker_background(const BBitmap* bitmap)</a>
<a name="ln110">{</a>
<a name="ln111">	BBitmap* result = new (nothrow) BBitmap(bitmap);</a>
<a name="ln112">	if (result &amp;&amp; !result-&gt;IsValid()) {</a>
<a name="ln113">		delete result;</a>
<a name="ln114">		result = NULL;</a>
<a name="ln115">	}</a>
<a name="ln116">	if (!result)</a>
<a name="ln117">		return NULL;</a>
<a name="ln118"> </a>
<a name="ln119">	uint8* bits = (uint8*)result-&gt;Bits();</a>
<a name="ln120">	uint32 bpr = result-&gt;BytesPerRow();</a>
<a name="ln121">	uint32 width = result-&gt;Bounds().IntegerWidth() + 1;</a>
<a name="ln122">	uint32 height = result-&gt;Bounds().IntegerHeight() + 1;</a>
<a name="ln123"> </a>
<a name="ln124">	for (uint32 i = 0; i &lt; height; i++) {</a>
<a name="ln125">		uint8* p = bits;</a>
<a name="ln126">		for (uint32 x = 0; x &lt; width; x++) {</a>
<a name="ln127">			uint8 alpha = p[3];</a>
<a name="ln128">			if (alpha &lt; 255) {</a>
<a name="ln129">				p[3] = 255;</a>
<a name="ln130">				alpha = 255 - alpha;</a>
<a name="ln131">				if (x % 10 &gt;= 5) {</a>
<a name="ln132">					if (i % 10 &gt;= 5)</a>
<a name="ln133">						blend_colors(p, kAlphaLow.red, kAlphaLow.green, kAlphaLow.blue, alpha);</a>
<a name="ln134">					else</a>
<a name="ln135">						blend_colors(p, kAlphaHigh.red, kAlphaHigh.green, kAlphaHigh.blue, alpha);</a>
<a name="ln136">					</a>
<a name="ln137">				} else {</a>
<a name="ln138">					if (i % 10 &gt;= 5)</a>
<a name="ln139">						blend_colors(p, kAlphaHigh.red, kAlphaHigh.green, kAlphaHigh.blue, alpha);</a>
<a name="ln140">					else</a>
<a name="ln141">						blend_colors(p, kAlphaLow.red, kAlphaLow.green, kAlphaLow.blue, alpha);</a>
<a name="ln142">				}</a>
<a name="ln143">			}</a>
<a name="ln144">			p += 4;</a>
<a name="ln145">		}</a>
<a name="ln146">		bits += bpr;</a>
<a name="ln147">	}</a>
<a name="ln148">	return result;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">//	#pragma mark -</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">PopUpMenu::PopUpMenu(const char* name, BMessenger target)</a>
<a name="ln156">	:</a>
<a name="ln157">	BPopUpMenu(name, false, false),</a>
<a name="ln158">	fTarget(target)</a>
<a name="ln159">{</a>
<a name="ln160">	SetAsyncAutoDestruct(true);</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163"> </a>
<a name="ln164">PopUpMenu::~PopUpMenu()</a>
<a name="ln165">{</a>
<a name="ln166">	fTarget.SendMessage(kMsgPopUpMenuClosed);</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169"> </a>
<a name="ln170">//	#pragma mark -</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">ShowImageView::ShowImageView(BRect rect, const char* name, uint32 resizingMode,</a>
<a name="ln174">		uint32 flags)</a>
<a name="ln175">	:</a>
<a name="ln176">	BView(rect, name, resizingMode, flags),</a>
<a name="ln177">	fBitmapOwner(NULL),</a>
<a name="ln178">	fBitmap(NULL),</a>
<a name="ln179">	fDisplayBitmap(NULL),</a>
<a name="ln180">	fSelectionBitmap(NULL),</a>
<a name="ln181"> </a>
<a name="ln182">	fZoom(1.0),</a>
<a name="ln183"> </a>
<a name="ln184">	fScaleBilinear(true),</a>
<a name="ln185"> </a>
<a name="ln186">	fBitmapLocationInView(0.0, 0.0),</a>
<a name="ln187"> </a>
<a name="ln188">	fStretchToBounds(false),</a>
<a name="ln189">	fForceOriginalSize(false),</a>
<a name="ln190">	fHideCursor(false),</a>
<a name="ln191">	fScrollingBitmap(false),</a>
<a name="ln192">	fCreatingSelection(false),</a>
<a name="ln193">	fFirstPoint(0.0, 0.0),</a>
<a name="ln194">	fSelectionMode(false),</a>
<a name="ln195">	fAnimateSelection(true),</a>
<a name="ln196">	fHasSelection(false),</a>
<a name="ln197">	fShowCaption(false),</a>
<a name="ln198">	fShowingPopUpMenu(false),</a>
<a name="ln199">	fHideCursorCountDown(HIDE_CURSOR_DELAY_TIME),</a>
<a name="ln200">	fStickyZoomCountDown(0),</a>
<a name="ln201">	fIsActiveWin(true),</a>
<a name="ln202">	fDefaultCursor(NULL),</a>
<a name="ln203">	fGrabCursor(NULL)</a>
<a name="ln204">{</a>
<a name="ln205">	ShowImageSettings* settings = my_app-&gt;Settings();</a>
<a name="ln206">	if (settings-&gt;Lock()) {</a>
<a name="ln207">		fStretchToBounds = settings-&gt;GetBool(&quot;StretchToBounds&quot;,</a>
<a name="ln208">			fStretchToBounds);</a>
<a name="ln209">		fScaleBilinear = settings-&gt;GetBool(&quot;ScaleBilinear&quot;, fScaleBilinear);</a>
<a name="ln210">		settings-&gt;Unlock();</a>
<a name="ln211">	}</a>
<a name="ln212"> </a>
<a name="ln213">	fDefaultCursor = new BCursor(B_CURSOR_ID_SYSTEM_DEFAULT);</a>
<a name="ln214">	fGrabCursor = new BCursor(B_CURSOR_ID_GRABBING);</a>
<a name="ln215"> </a>
<a name="ln216">	SetViewColor(B_TRANSPARENT_COLOR);</a>
<a name="ln217">	SetHighColor(kBorderColor);</a>
<a name="ln218">	SetLowColor(0, 0, 0);</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221"> </a>
<a name="ln222">ShowImageView::~ShowImageView()</a>
<a name="ln223">{</a>
<a name="ln224">	_DeleteBitmap();</a>
<a name="ln225"> </a>
<a name="ln226">	delete fDefaultCursor;</a>
<a name="ln227">	delete fGrabCursor;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">void</a>
<a name="ln232">ShowImageView::_AnimateSelection(bool enabled)</a>
<a name="ln233">{</a>
<a name="ln234">	fAnimateSelection = enabled;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">void</a>
<a name="ln239">ShowImageView::Pulse()</a>
<a name="ln240">{</a>
<a name="ln241">	// animate marching ants</a>
<a name="ln242">	if (fHasSelection &amp;&amp; fAnimateSelection &amp;&amp; fIsActiveWin) {</a>
<a name="ln243">		fSelectionBox.Animate();</a>
<a name="ln244">		fSelectionBox.Draw(this, Bounds());</a>
<a name="ln245">	}</a>
<a name="ln246"> </a>
<a name="ln247">	if (fHideCursor &amp;&amp; !fHasSelection &amp;&amp; !fShowingPopUpMenu &amp;&amp; fIsActiveWin) {</a>
<a name="ln248">		if (fHideCursorCountDown == 0) {</a>
<a name="ln249">			// Go negative so this isn't triggered again</a>
<a name="ln250">			fHideCursorCountDown--;</a>
<a name="ln251"> </a>
<a name="ln252">			BPoint mousePos;</a>
<a name="ln253">			uint32 buttons;</a>
<a name="ln254">			GetMouse(&amp;mousePos, &amp;buttons, false);</a>
<a name="ln255">			if (Bounds().Contains(mousePos))</a>
<a name="ln256">				be_app-&gt;ObscureCursor();</a>
<a name="ln257">		} else if (fHideCursorCountDown &gt; 0)</a>
<a name="ln258">			fHideCursorCountDown--;</a>
<a name="ln259">	}</a>
<a name="ln260"> </a>
<a name="ln261">	if (fStickyZoomCountDown &gt; 0)</a>
<a name="ln262">		fStickyZoomCountDown--;</a>
<a name="ln263"> </a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">void</a>
<a name="ln268">ShowImageView::_SendMessageToWindow(BMessage* message)</a>
<a name="ln269">{</a>
<a name="ln270">	BMessenger target(Window());</a>
<a name="ln271">	target.SendMessage(message);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274"> </a>
<a name="ln275">void</a>
<a name="ln276">ShowImageView::_SendMessageToWindow(uint32 code)</a>
<a name="ln277">{</a>
<a name="ln278">	BMessage message(code);</a>
<a name="ln279">	_SendMessageToWindow(&amp;message);</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282"> </a>
<a name="ln283">//! send message to parent about new image</a>
<a name="ln284">void</a>
<a name="ln285">ShowImageView::_Notify()</a>
<a name="ln286">{</a>
<a name="ln287">	BMessage msg(MSG_UPDATE_STATUS);</a>
<a name="ln288"> </a>
<a name="ln289">	msg.AddInt32(&quot;width&quot;, fBitmap-&gt;Bounds().IntegerWidth() + 1);</a>
<a name="ln290">	msg.AddInt32(&quot;height&quot;, fBitmap-&gt;Bounds().IntegerHeight() + 1);</a>
<a name="ln291"> </a>
<a name="ln292">	msg.AddInt32(&quot;colors&quot;, fBitmap-&gt;ColorSpace());</a>
<a name="ln293">	_SendMessageToWindow(&amp;msg);</a>
<a name="ln294"> </a>
<a name="ln295">	FixupScrollBars();</a>
<a name="ln296">	Invalidate();</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299"> </a>
<a name="ln300">void</a>
<a name="ln301">ShowImageView::_UpdateStatusText()</a>
<a name="ln302">{</a>
<a name="ln303">	BMessage msg(MSG_UPDATE_STATUS_TEXT);</a>
<a name="ln304"> </a>
<a name="ln305">	if (fHasSelection) {</a>
<a name="ln306">		char size[50];</a>
<a name="ln307">		snprintf(size, sizeof(size), &quot;(%.0fx%.0f)&quot;,</a>
<a name="ln308">			fSelectionBox.Bounds().Width() + 1.0,</a>
<a name="ln309">			fSelectionBox.Bounds().Height() + 1.0);</a>
<a name="ln310"> </a>
<a name="ln311">		msg.AddString(&quot;status&quot;, size);</a>
<a name="ln312">	}</a>
<a name="ln313"> </a>
<a name="ln314">	_SendMessageToWindow(&amp;msg);</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">void</a>
<a name="ln319">ShowImageView::_DeleteBitmap()</a>
<a name="ln320">{</a>
<a name="ln321">	_DeleteSelectionBitmap();</a>
<a name="ln322"> </a>
<a name="ln323">	if (fDisplayBitmap != fBitmap)</a>
<a name="ln324">		delete fDisplayBitmap;</a>
<a name="ln325">	fDisplayBitmap = NULL;</a>
<a name="ln326"> </a>
<a name="ln327">	if (fBitmapOwner != NULL)</a>
<a name="ln328">		fBitmapOwner-&gt;ReleaseReference();</a>
<a name="ln329">	else</a>
<a name="ln330">		delete fBitmap;</a>
<a name="ln331"> </a>
<a name="ln332">	fBitmapOwner = NULL;</a>
<a name="ln333">	fBitmap = NULL;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336"> </a>
<a name="ln337">void</a>
<a name="ln338">ShowImageView::_DeleteSelectionBitmap()</a>
<a name="ln339">{</a>
<a name="ln340">	delete fSelectionBitmap;</a>
<a name="ln341">	fSelectionBitmap = NULL;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344"> </a>
<a name="ln345">status_t</a>
<a name="ln346">ShowImageView::SetImage(const BMessage* message)</a>
<a name="ln347">{</a>
<a name="ln348">	BBitmap* bitmap;</a>
<a name="ln349">	entry_ref ref;</a>
<a name="ln350">	if (message-&gt;FindPointer(&quot;bitmap&quot;, (void**)&amp;bitmap) != B_OK</a>
<a name="ln351">		|| message-&gt;FindRef(&quot;ref&quot;, &amp;ref) != B_OK || bitmap == NULL)</a>
<a name="ln352">		return B_ERROR;</a>
<a name="ln353"> </a>
<a name="ln354">	BitmapOwner* bitmapOwner;</a>
<a name="ln355">	message-&gt;FindPointer(&quot;bitmapOwner&quot;, (void**)&amp;bitmapOwner);</a>
<a name="ln356"> </a>
<a name="ln357">	status_t status = SetImage(&amp;ref, bitmap, bitmapOwner);</a>
<a name="ln358">	if (status == B_OK) {</a>
<a name="ln359">		fFormatDescription = message-&gt;FindString(&quot;type&quot;);</a>
<a name="ln360">		fMimeType = message-&gt;FindString(&quot;mime&quot;);</a>
<a name="ln361">	}</a>
<a name="ln362"> </a>
<a name="ln363">	return status;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367">status_t</a>
<a name="ln368">ShowImageView::SetImage(const entry_ref* ref, BBitmap* bitmap,</a>
<a name="ln369">		BitmapOwner* bitmapOwner)</a>
<a name="ln370">{</a>
<a name="ln371">	// Delete the old one, and clear everything</a>
<a name="ln372">	_SetHasSelection(false);</a>
<a name="ln373">	fCreatingSelection = false;</a>
<a name="ln374">	_DeleteBitmap();</a>
<a name="ln375"> </a>
<a name="ln376">	fBitmap = bitmap;</a>
<a name="ln377">	fBitmapOwner = bitmapOwner;</a>
<a name="ln378">	if (ref == NULL)</a>
<a name="ln379">		fCurrentRef.device = -1;</a>
<a name="ln380">	else</a>
<a name="ln381">		fCurrentRef = *ref;</a>
<a name="ln382"> </a>
<a name="ln383">	if (fBitmap != NULL) {</a>
<a name="ln384">		// prepare the display bitmap</a>
<a name="ln385">		if (fBitmap-&gt;ColorSpace() == B_RGBA32)</a>
<a name="ln386">			fDisplayBitmap = compose_checker_background(fBitmap);</a>
<a name="ln387">		if (fDisplayBitmap == NULL)</a>
<a name="ln388">			fDisplayBitmap = fBitmap;</a>
<a name="ln389"> </a>
<a name="ln390">		BNode node(ref);</a>
<a name="ln391"> </a>
<a name="ln392">		// restore orientation</a>
<a name="ln393">		int32 orientation;</a>
<a name="ln394">		fImageOrientation = k0;</a>
<a name="ln395">		if (node.ReadAttr(SHOW_IMAGE_ORIENTATION_ATTRIBUTE, B_INT32_TYPE, 0,</a>
<a name="ln396">				&amp;orientation, sizeof(orientation)) == sizeof(orientation)) {</a>
<a name="ln397">			orientation &amp;= 255;</a>
<a name="ln398">			switch (orientation) {</a>
<a name="ln399">				case k0:</a>
<a name="ln400">					break;</a>
<a name="ln401">				case k90:</a>
<a name="ln402">					_DoImageOperation(ImageProcessor::kRotateClockwise, true);</a>
<a name="ln403">					break;</a>
<a name="ln404">				case k180:</a>
<a name="ln405">					_DoImageOperation(ImageProcessor::kRotateClockwise, true);</a>
<a name="ln406">					_DoImageOperation(ImageProcessor::kRotateClockwise, true);</a>
<a name="ln407">					break;</a>
<a name="ln408">				case k270:</a>
<a name="ln409">					_DoImageOperation(ImageProcessor::kRotateCounterClockwise, true);</a>
<a name="ln410">					break;</a>
<a name="ln411">				case k0V:</a>
<a name="ln412">					_DoImageOperation(ImageProcessor::ImageProcessor::kFlipTopToBottom, true);</a>
<a name="ln413">					break;</a>
<a name="ln414">				case k90V:</a>
<a name="ln415">					_DoImageOperation(ImageProcessor::kRotateClockwise, true);</a>
<a name="ln416">					_DoImageOperation(ImageProcessor::ImageProcessor::kFlipTopToBottom, true);</a>
<a name="ln417">					break;</a>
<a name="ln418">				case k0H:</a>
<a name="ln419">					_DoImageOperation(ImageProcessor::ImageProcessor::kFlipLeftToRight, true);</a>
<a name="ln420">					break;</a>
<a name="ln421">				case k270V:</a>
<a name="ln422">					_DoImageOperation(ImageProcessor::kRotateCounterClockwise, true);</a>
<a name="ln423">					_DoImageOperation(ImageProcessor::ImageProcessor::kFlipTopToBottom, true);</a>
<a name="ln424">					break;</a>
<a name="ln425">			}</a>
<a name="ln426">		}</a>
<a name="ln427">	}</a>
<a name="ln428"> </a>
<a name="ln429">	BPath path(ref);</a>
<a name="ln430">	fCaption = path.Path();</a>
<a name="ln431">	fFormatDescription = &quot;Bitmap&quot;;</a>
<a name="ln432">	fMimeType = &quot;image/x-be-bitmap&quot;;</a>
<a name="ln433"> </a>
<a name="ln434">	be_roster-&gt;AddToRecentDocuments(ref, kApplicationSignature);</a>
<a name="ln435"> </a>
<a name="ln436">	FitToBounds();</a>
<a name="ln437">	_Notify();</a>
<a name="ln438">	return B_OK;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441"> </a>
<a name="ln442">BPoint</a>
<a name="ln443">ShowImageView::ImageToView(BPoint p) const</a>
<a name="ln444">{</a>
<a name="ln445">	p.x = floorf(fZoom * p.x + fBitmapLocationInView.x);</a>
<a name="ln446">	p.y = floorf(fZoom * p.y + fBitmapLocationInView.y);</a>
<a name="ln447">	return p;</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450"> </a>
<a name="ln451">BPoint</a>
<a name="ln452">ShowImageView::ViewToImage(BPoint p) const</a>
<a name="ln453">{</a>
<a name="ln454">	p.x = floorf((p.x - fBitmapLocationInView.x) / fZoom);</a>
<a name="ln455">	p.y = floorf((p.y - fBitmapLocationInView.y) / fZoom);</a>
<a name="ln456">	return p;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">BRect</a>
<a name="ln461">ShowImageView::ImageToView(BRect r) const</a>
<a name="ln462">{</a>
<a name="ln463">	BPoint leftTop(ImageToView(BPoint(r.left, r.top)));</a>
<a name="ln464">	BPoint rightBottom(r.right, r.bottom);</a>
<a name="ln465">	rightBottom += BPoint(1, 1);</a>
<a name="ln466">	rightBottom = ImageToView(rightBottom);</a>
<a name="ln467">	rightBottom -= BPoint(1, 1);</a>
<a name="ln468">	return BRect(leftTop.x, leftTop.y, rightBottom.x, rightBottom.y);</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">void</a>
<a name="ln473">ShowImageView::ConstrainToImage(BPoint&amp; point) const</a>
<a name="ln474">{</a>
<a name="ln475">	point.ConstrainTo(fBitmap-&gt;Bounds());</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478"> </a>
<a name="ln479">void</a>
<a name="ln480">ShowImageView::ConstrainToImage(BRect&amp; rect) const</a>
<a name="ln481">{</a>
<a name="ln482">	rect = rect &amp; fBitmap-&gt;Bounds();</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485"> </a>
<a name="ln486">void</a>
<a name="ln487">ShowImageView::SetShowCaption(bool show)</a>
<a name="ln488">{</a>
<a name="ln489">	if (fShowCaption != show) {</a>
<a name="ln490">		fShowCaption = show;</a>
<a name="ln491">		_UpdateCaption();</a>
<a name="ln492">	}</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495"> </a>
<a name="ln496">void</a>
<a name="ln497">ShowImageView::SetStretchToBounds(bool enable)</a>
<a name="ln498">{</a>
<a name="ln499">	if (fStretchToBounds != enable) {</a>
<a name="ln500">		_SettingsSetBool(&quot;StretchToBounds&quot;, enable);</a>
<a name="ln501">		fStretchToBounds = enable;</a>
<a name="ln502">		if (enable || fZoom &gt; 1.0)</a>
<a name="ln503">			FitToBounds();</a>
<a name="ln504">	}</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507"> </a>
<a name="ln508">void</a>
<a name="ln509">ShowImageView::SetHideIdlingCursor(bool hide)</a>
<a name="ln510">{</a>
<a name="ln511">	fHideCursor = hide;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514"> </a>
<a name="ln515">BBitmap*</a>
<a name="ln516">ShowImageView::Bitmap()</a>
<a name="ln517">{</a>
<a name="ln518">	return fBitmap;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">void</a>
<a name="ln523">ShowImageView::SetScaleBilinear(bool enabled)</a>
<a name="ln524">{</a>
<a name="ln525">	if (fScaleBilinear != enabled) {</a>
<a name="ln526">		_SettingsSetBool(&quot;ScaleBilinear&quot;, enabled);</a>
<a name="ln527">		fScaleBilinear = enabled;</a>
<a name="ln528">		Invalidate();</a>
<a name="ln529">	}</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532"> </a>
<a name="ln533">void</a>
<a name="ln534">ShowImageView::AttachedToWindow()</a>
<a name="ln535">{</a>
<a name="ln536">	FitToBounds();</a>
<a name="ln537">	FixupScrollBars();</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540"> </a>
<a name="ln541">void</a>
<a name="ln542">ShowImageView::FrameResized(float width, float height)</a>
<a name="ln543">{</a>
<a name="ln544">	FixupScrollBars();</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547"> </a>
<a name="ln548">float</a>
<a name="ln549">ShowImageView::_FitToBoundsZoom() const</a>
<a name="ln550">{</a>
<a name="ln551">	if (fBitmap == NULL)</a>
<a name="ln552">		return 1.0f;</a>
<a name="ln553"> </a>
<a name="ln554">	// the width/height of the bitmap (in pixels)</a>
<a name="ln555">	float bitmapWidth = fBitmap-&gt;Bounds().Width() + 1;</a>
<a name="ln556">	float bitmapHeight = fBitmap-&gt;Bounds().Height() + 1;</a>
<a name="ln557"> </a>
<a name="ln558">	// the available width/height for layouting the bitmap (in pixels)</a>
<a name="ln559">	float width = Bounds().Width() + 1;</a>
<a name="ln560">	float height = Bounds().Height() + 1;</a>
<a name="ln561"> </a>
<a name="ln562">	float zoom = width / bitmapWidth;</a>
<a name="ln563"> </a>
<a name="ln564">	if (zoom * bitmapHeight &lt;= height)</a>
<a name="ln565">		return zoom;</a>
<a name="ln566"> </a>
<a name="ln567">	return height / bitmapHeight;</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570"> </a>
<a name="ln571">BRect</a>
<a name="ln572">ShowImageView::_AlignBitmap()</a>
<a name="ln573">{</a>
<a name="ln574">	BRect rect(fBitmap-&gt;Bounds());</a>
<a name="ln575"> </a>
<a name="ln576">	// the width/height of the bitmap (in pixels)</a>
<a name="ln577">	float bitmapWidth = rect.Width() + 1;</a>
<a name="ln578">	float bitmapHeight = rect.Height() + 1;</a>
<a name="ln579"> </a>
<a name="ln580">	// the available width/height for layouting the bitmap (in pixels)</a>
<a name="ln581">	float width = Bounds().Width() + 1;</a>
<a name="ln582">	float height = Bounds().Height() + 1;</a>
<a name="ln583"> </a>
<a name="ln584">	if (width == 0 || height == 0)</a>
<a name="ln585">		return rect;</a>
<a name="ln586"> </a>
<a name="ln587">	// zoom image</a>
<a name="ln588">	rect.right = floorf(bitmapWidth * fZoom) - 1;</a>
<a name="ln589">	rect.bottom = floorf(bitmapHeight * fZoom) - 1;</a>
<a name="ln590"> </a>
<a name="ln591">	// update the bitmap size after the zoom</a>
<a name="ln592">	bitmapWidth = rect.Width() + 1.0;</a>
<a name="ln593">	bitmapHeight = rect.Height() + 1.0;</a>
<a name="ln594"> </a>
<a name="ln595">	// always align in the center if the bitmap is smaller than the window</a>
<a name="ln596">	if (width &gt; bitmapWidth)</a>
<a name="ln597">		rect.OffsetBy(floorf((width - bitmapWidth) / 2.0), 0);</a>
<a name="ln598"> </a>
<a name="ln599">	if (height &gt; bitmapHeight)</a>
<a name="ln600">		rect.OffsetBy(0, floorf((height - bitmapHeight) / 2.0));</a>
<a name="ln601"> </a>
<a name="ln602">	return rect;</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606">void</a>
<a name="ln607">ShowImageView::_DrawBackground(BRect border)</a>
<a name="ln608">{</a>
<a name="ln609">	BRect bounds(Bounds());</a>
<a name="ln610">	// top</a>
<a name="ln611">	FillRect(BRect(0, 0, bounds.right, border.top - 1), B_SOLID_LOW);</a>
<a name="ln612">	// left</a>
<a name="ln613">	FillRect(BRect(0, border.top, border.left - 1, border.bottom), B_SOLID_LOW);</a>
<a name="ln614">	// right</a>
<a name="ln615">	FillRect(BRect(border.right + 1, border.top, bounds.right, border.bottom), B_SOLID_LOW);</a>
<a name="ln616">	// bottom</a>
<a name="ln617">	FillRect(BRect(0, border.bottom + 1, bounds.right, bounds.bottom), B_SOLID_LOW);</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">void</a>
<a name="ln622">ShowImageView::_LayoutCaption(BFont&amp; font, BPoint&amp; pos, BRect&amp; rect)</a>
<a name="ln623">{</a>
<a name="ln624">	font_height fontHeight;</a>
<a name="ln625">	float width, height;</a>
<a name="ln626">	BRect bounds(Bounds());</a>
<a name="ln627">	font = be_plain_font;</a>
<a name="ln628">	width = font.StringWidth(fCaption.String());</a>
<a name="ln629">	font.GetHeight(&amp;fontHeight);</a>
<a name="ln630">	height = fontHeight.ascent + fontHeight.descent;</a>
<a name="ln631">	// center text horizontally</a>
<a name="ln632">	pos.x = (bounds.left + bounds.right - width) / 2;</a>
<a name="ln633">	// flush bottom</a>
<a name="ln634">	pos.y = bounds.bottom - fontHeight.descent - 7;</a>
<a name="ln635"> </a>
<a name="ln636">	// background rectangle</a>
<a name="ln637">	rect.Set(0, 0, width + 4, height + 4);</a>
<a name="ln638">	rect.OffsetTo(pos);</a>
<a name="ln639">	rect.OffsetBy(-2, -2 - fontHeight.ascent); // -2 for border</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642"> </a>
<a name="ln643">void</a>
<a name="ln644">ShowImageView::_DrawCaption()</a>
<a name="ln645">{</a>
<a name="ln646">	BFont font;</a>
<a name="ln647">	BPoint position;</a>
<a name="ln648">	BRect rect;</a>
<a name="ln649">	_LayoutCaption(font, position, rect);</a>
<a name="ln650"> </a>
<a name="ln651">	PushState();</a>
<a name="ln652"> </a>
<a name="ln653">	// draw background</a>
<a name="ln654">	SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln655">	SetHighColor(255, 255, 255, 160);</a>
<a name="ln656">	FillRect(rect);</a>
<a name="ln657"> </a>
<a name="ln658">	// draw text</a>
<a name="ln659">	SetDrawingMode(B_OP_OVER);</a>
<a name="ln660">	SetFont(&amp;font);</a>
<a name="ln661">	SetLowColor(B_TRANSPARENT_COLOR);</a>
<a name="ln662">	SetHighColor(0, 0, 0);</a>
<a name="ln663">	DrawString(fCaption.String(), position);</a>
<a name="ln664"> </a>
<a name="ln665">	PopState();</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668"> </a>
<a name="ln669">void</a>
<a name="ln670">ShowImageView::_UpdateCaption()</a>
<a name="ln671">{</a>
<a name="ln672">	BFont font;</a>
<a name="ln673">	BPoint pos;</a>
<a name="ln674">	BRect rect;</a>
<a name="ln675">	_LayoutCaption(font, pos, rect);</a>
<a name="ln676"> </a>
<a name="ln677">	// draw over portion of image where caption is located</a>
<a name="ln678">	BRegion clip(rect);</a>
<a name="ln679">	PushState();</a>
<a name="ln680">	ConstrainClippingRegion(&amp;clip);</a>
<a name="ln681">	Draw(rect);</a>
<a name="ln682">	PopState();</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">void</a>
<a name="ln687">ShowImageView::_DrawImage(BRect rect)</a>
<a name="ln688">{</a>
<a name="ln689">	// TODO: fix composing of fBitmap with other bitmaps</a>
<a name="ln690">	// with regard to alpha channel</a>
<a name="ln691">	if (!fDisplayBitmap)</a>
<a name="ln692">		fDisplayBitmap = fBitmap;</a>
<a name="ln693"> </a>
<a name="ln694">	uint32 options = fScaleBilinear ? B_FILTER_BITMAP_BILINEAR : 0;</a>
<a name="ln695">	DrawBitmap(fDisplayBitmap, fDisplayBitmap-&gt;Bounds(), rect, options);</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698"> </a>
<a name="ln699">void</a>
<a name="ln700">ShowImageView::Draw(BRect updateRect)</a>
<a name="ln701">{</a>
<a name="ln702">	if (fBitmap == NULL)</a>
<a name="ln703">		return;</a>
<a name="ln704"> </a>
<a name="ln705">	if (IsPrinting()) {</a>
<a name="ln706">		DrawBitmap(fBitmap);</a>
<a name="ln707">		return;</a>
<a name="ln708">	}</a>
<a name="ln709"> </a>
<a name="ln710">	BRect rect = _AlignBitmap();</a>
<a name="ln711">	fBitmapLocationInView.x = floorf(rect.left);</a>
<a name="ln712">	fBitmapLocationInView.y = floorf(rect.top);</a>
<a name="ln713"> </a>
<a name="ln714">	_DrawBackground(rect);</a>
<a name="ln715">	_DrawImage(rect);</a>
<a name="ln716"> </a>
<a name="ln717">	if (fShowCaption)</a>
<a name="ln718">		_DrawCaption();</a>
<a name="ln719"> </a>
<a name="ln720">	if (fHasSelection) {</a>
<a name="ln721">		if (fSelectionBitmap != NULL) {</a>
<a name="ln722">			BRect srcRect;</a>
<a name="ln723">			BRect dstRect;</a>
<a name="ln724">			_GetSelectionMergeRects(srcRect, dstRect);</a>
<a name="ln725">			dstRect = ImageToView(dstRect);</a>
<a name="ln726">			DrawBitmap(fSelectionBitmap, srcRect, dstRect);</a>
<a name="ln727">		}</a>
<a name="ln728">		fSelectionBox.Draw(this, updateRect);</a>
<a name="ln729">	}</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732"> </a>
<a name="ln733">BBitmap*</a>
<a name="ln734">ShowImageView::_CopySelection(uchar alpha, bool imageSize)</a>
<a name="ln735">{</a>
<a name="ln736">	bool hasAlpha = alpha != 255;</a>
<a name="ln737"> </a>
<a name="ln738">	if (!fHasSelection)</a>
<a name="ln739">		return NULL;</a>
<a name="ln740"> </a>
<a name="ln741">	BRect rect = fSelectionBox.Bounds().OffsetToCopy(B_ORIGIN);</a>
<a name="ln742">	if (!imageSize) {</a>
<a name="ln743">		// scale image to view size</a>
<a name="ln744">		rect.right = floorf((rect.right + 1.0) * fZoom - 1.0);</a>
<a name="ln745">		rect.bottom = floorf((rect.bottom + 1.0) * fZoom - 1.0);</a>
<a name="ln746">	}</a>
<a name="ln747">	BView view(rect, NULL, B_FOLLOW_NONE, B_WILL_DRAW);</a>
<a name="ln748">	BBitmap* bitmap = new(nothrow) BBitmap(rect, hasAlpha ? B_RGBA32</a>
<a name="ln749">		: fBitmap-&gt;ColorSpace(), true);</a>
<a name="ln750">	if (bitmap == NULL || !bitmap-&gt;IsValid()) {</a>
<a name="ln751">		delete bitmap;</a>
<a name="ln752">		return NULL;</a>
<a name="ln753">	}</a>
<a name="ln754"> </a>
<a name="ln755">	if (bitmap-&gt;Lock()) {</a>
<a name="ln756">		bitmap-&gt;AddChild(&amp;view);</a>
<a name="ln757">#ifdef __HAIKU__</a>
<a name="ln758">		// On Haiku, B_OP_SUBSTRACT does not affect alpha like it did on BeOS.</a>
<a name="ln759">		// Don't know if it's better to fix it or not (stippi).</a>
<a name="ln760">		if (hasAlpha) {</a>
<a name="ln761">			view.SetHighColor(0, 0, 0, 0);</a>
<a name="ln762">			view.FillRect(view.Bounds());</a>
<a name="ln763">			view.SetDrawingMode(B_OP_ALPHA);</a>
<a name="ln764">			view.SetBlendingMode(B_CONSTANT_ALPHA, B_ALPHA_COMPOSITE);</a>
<a name="ln765">			view.SetHighColor(0, 0, 0, alpha);</a>
<a name="ln766">		}</a>
<a name="ln767">		if (fSelectionBitmap) {</a>
<a name="ln768">			view.DrawBitmap(fSelectionBitmap,</a>
<a name="ln769">				fSelectionBitmap-&gt;Bounds().OffsetToCopy(B_ORIGIN), rect);</a>
<a name="ln770">		} else</a>
<a name="ln771">			view.DrawBitmap(fBitmap, fCopyFromRect, rect);</a>
<a name="ln772">#else</a>
<a name="ln773">		if (fSelectionBitmap) {</a>
<a name="ln774">			view.DrawBitmap(fSelectionBitmap,</a>
<a name="ln775">				fSelectionBitmap-&gt;Bounds().OffsetToCopy(B_ORIGIN), rect);</a>
<a name="ln776">		} else</a>
<a name="ln777">			view.DrawBitmap(fBitmap, fCopyFromRect, rect);</a>
<a name="ln778">		if (hasAlpha) {</a>
<a name="ln779">			view.SetDrawingMode(B_OP_SUBTRACT);</a>
<a name="ln780">			view.SetHighColor(0, 0, 0, 255 - alpha);</a>
<a name="ln781">			view.FillRect(rect, B_SOLID_HIGH);</a>
<a name="ln782">		}</a>
<a name="ln783">#endif</a>
<a name="ln784">		view.Sync();</a>
<a name="ln785">		bitmap-&gt;RemoveChild(&amp;view);</a>
<a name="ln786">		bitmap-&gt;Unlock();</a>
<a name="ln787">	}</a>
<a name="ln788"> </a>
<a name="ln789">	return bitmap;</a>
<a name="ln790">}</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">bool</a>
<a name="ln794">ShowImageView::_AddSupportedTypes(BMessage* msg, BBitmap* bitmap)</a>
<a name="ln795">{</a>
<a name="ln796">	BTranslatorRoster* roster = BTranslatorRoster::Default();</a>
<a name="ln797">	if (roster == NULL)</a>
<a name="ln798">		return false;</a>
<a name="ln799"> </a>
<a name="ln800">	// add the current image mime first, will make it the preferred format on</a>
<a name="ln801">	// left mouse drag</a>
<a name="ln802">	msg-&gt;AddString(&quot;be:types&quot;, fMimeType);</a>
<a name="ln803">	msg-&gt;AddString(&quot;be:filetypes&quot;, fMimeType);</a>
<a name="ln804">	msg-&gt;AddString(&quot;be:type_descriptions&quot;, fFormatDescription);</a>
<a name="ln805"> </a>
<a name="ln806">	bool foundOther = false;</a>
<a name="ln807">	bool foundCurrent = false;</a>
<a name="ln808"> </a>
<a name="ln809">	int32 infoCount;</a>
<a name="ln810">	translator_info* info;</a>
<a name="ln811">	BBitmapStream stream(bitmap);</a>
<a name="ln812">	if (roster-&gt;GetTranslators(&amp;stream, NULL, &amp;info, &amp;infoCount) == B_OK) {</a>
<a name="ln813">		for (int32 i = 0; i &lt; infoCount; i++) {</a>
<a name="ln814">			const translation_format* formats;</a>
<a name="ln815">			int32 count;</a>
<a name="ln816">			roster-&gt;GetOutputFormats(info[i].translator, &amp;formats, &amp;count);</a>
<a name="ln817">			for (int32 j = 0; j &lt; count; j++) {</a>
<a name="ln818">				if (fMimeType == formats[j].MIME)</a>
<a name="ln819">					foundCurrent = true;</a>
<a name="ln820">				else if (strcmp(formats[j].MIME, &quot;image/x-be-bitmap&quot;) != 0) {</a>
<a name="ln821">					foundOther = true;</a>
<a name="ln822">					// needed to send data in message</a>
<a name="ln823">					msg-&gt;AddString(&quot;be:types&quot;, formats[j].MIME);</a>
<a name="ln824">					// needed to pass data via file</a>
<a name="ln825">					msg-&gt;AddString(&quot;be:filetypes&quot;, formats[j].MIME);</a>
<a name="ln826">					msg-&gt;AddString(&quot;be:type_descriptions&quot;, formats[j].name);</a>
<a name="ln827">				}</a>
<a name="ln828">			}</a>
<a name="ln829">		}</a>
<a name="ln830">	}</a>
<a name="ln831">	stream.DetachBitmap(&amp;bitmap);</a>
<a name="ln832"> </a>
<a name="ln833">	if (!foundCurrent) {</a>
<a name="ln834">		msg-&gt;RemoveData(&quot;be:types&quot;, 0);</a>
<a name="ln835">		msg-&gt;RemoveData(&quot;be:filetypes&quot;, 0);</a>
<a name="ln836">		msg-&gt;RemoveData(&quot;be:type_descriptions&quot;, 0);</a>
<a name="ln837">	}</a>
<a name="ln838"> </a>
<a name="ln839">	return foundOther || foundCurrent;</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842"> </a>
<a name="ln843">void</a>
<a name="ln844">ShowImageView::_BeginDrag(BPoint sourcePoint)</a>
<a name="ln845">{</a>
<a name="ln846">	BBitmap* bitmap = _CopySelection(128, false);</a>
<a name="ln847">	if (bitmap == NULL)</a>
<a name="ln848">		return;</a>
<a name="ln849"> </a>
<a name="ln850">	SetMouseEventMask(B_POINTER_EVENTS);</a>
<a name="ln851"> </a>
<a name="ln852">	// fill the drag message</a>
<a name="ln853">	BMessage drag(B_SIMPLE_DATA);</a>
<a name="ln854">	drag.AddInt32(&quot;be:actions&quot;, B_COPY_TARGET);</a>
<a name="ln855">	drag.AddString(&quot;be:clip_name&quot;, &quot;Bitmap Clip&quot;);</a>
<a name="ln856">	// ShowImage specific fields</a>
<a name="ln857">	drag.AddPoint(&quot;be:_source_point&quot;, sourcePoint);</a>
<a name="ln858">	drag.AddRect(&quot;be:_frame&quot;, fSelectionBox.Bounds());</a>
<a name="ln859">	if (_AddSupportedTypes(&amp;drag, bitmap)) {</a>
<a name="ln860">		// we also support &quot;Passing Data via File&quot; protocol</a>
<a name="ln861">		drag.AddString(&quot;be:types&quot;, B_FILE_MIME_TYPE);</a>
<a name="ln862">		// avoid flickering of dragged bitmap caused by drawing into the window</a>
<a name="ln863">		_AnimateSelection(false);</a>
<a name="ln864">		// only use a transparent bitmap on selections less than 400x400</a>
<a name="ln865">		// (taking into account zooming)</a>
<a name="ln866">		BRect selectionRect = fSelectionBox.Bounds();</a>
<a name="ln867">		if (selectionRect.Width() * fZoom &lt; 400.0</a>
<a name="ln868">			&amp;&amp; selectionRect.Height() * fZoom &lt; 400.0) {</a>
<a name="ln869">			sourcePoint -= selectionRect.LeftTop();</a>
<a name="ln870">			sourcePoint.x *= fZoom;</a>
<a name="ln871">			sourcePoint.y *= fZoom;</a>
<a name="ln872">			// DragMessage takes ownership of bitmap</a>
<a name="ln873">			DragMessage(&amp;drag, bitmap, B_OP_ALPHA, sourcePoint);</a>
<a name="ln874">			bitmap = NULL;</a>
<a name="ln875">		} else {</a>
<a name="ln876">			delete bitmap;</a>
<a name="ln877">			// Offset and scale the rect</a>
<a name="ln878">			BRect rect(selectionRect);</a>
<a name="ln879">			rect = ImageToView(rect);</a>
<a name="ln880">			rect.InsetBy(-1, -1);</a>
<a name="ln881">			DragMessage(&amp;drag, rect);</a>
<a name="ln882">		}</a>
<a name="ln883">	}</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886"> </a>
<a name="ln887">bool</a>
<a name="ln888">ShowImageView::_OutputFormatForType(BBitmap* bitmap, const char* type,</a>
<a name="ln889">	translation_format* format)</a>
<a name="ln890">{</a>
<a name="ln891">	bool found = false;</a>
<a name="ln892"> </a>
<a name="ln893">	BTranslatorRoster* roster = BTranslatorRoster::Default();</a>
<a name="ln894">	if (roster == NULL)</a>
<a name="ln895">		return false;</a>
<a name="ln896"> </a>
<a name="ln897">	BBitmapStream stream(bitmap);</a>
<a name="ln898"> </a>
<a name="ln899">	translator_info* outInfo;</a>
<a name="ln900">	int32 outNumInfo;</a>
<a name="ln901">	if (roster-&gt;GetTranslators(&amp;stream, NULL, &amp;outInfo, &amp;outNumInfo) == B_OK) {</a>
<a name="ln902">		for (int32 i = 0; i &lt; outNumInfo; i++) {</a>
<a name="ln903">			const translation_format* formats;</a>
<a name="ln904">			int32 formatCount;</a>
<a name="ln905">			roster-&gt;GetOutputFormats(outInfo[i].translator, &amp;formats,</a>
<a name="ln906">				&amp;formatCount);</a>
<a name="ln907">			for (int32 j = 0; j &lt; formatCount; j++) {</a>
<a name="ln908">				if (strcmp(formats[j].MIME, type) == 0) {</a>
<a name="ln909">					*format = formats[j];</a>
<a name="ln910">					found = true;</a>
<a name="ln911">					break;</a>
<a name="ln912">				}</a>
<a name="ln913">			}</a>
<a name="ln914">		}</a>
<a name="ln915">	}</a>
<a name="ln916">	stream.DetachBitmap(&amp;bitmap);</a>
<a name="ln917">	return found;</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920"> </a>
<a name="ln921">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln922">#define B_TRANSLATION_CONTEXT &quot;SaveToFile&quot;</a>
<a name="ln923"> </a>
<a name="ln924"> </a>
<a name="ln925">void</a>
<a name="ln926">ShowImageView::SaveToFile(BDirectory* dir, const char* name, BBitmap* bitmap,</a>
<a name="ln927">	const translation_format* format)</a>
<a name="ln928">{</a>
<a name="ln929">	if (bitmap == NULL) {</a>
<a name="ln930">		// If no bitmap is supplied, write out the whole image</a>
<a name="ln931">		bitmap = fBitmap;</a>
<a name="ln932">	}</a>
<a name="ln933"> </a>
<a name="ln934">	BBitmapStream stream(bitmap);</a>
<a name="ln935"> </a>
<a name="ln936">	bool loop = true;</a>
<a name="ln937">	while (loop) {</a>
<a name="ln938">		BTranslatorRoster* roster = BTranslatorRoster::Default();</a>
<a name="ln939">		if (!roster)</a>
<a name="ln940">			break;</a>
<a name="ln941">		// write data</a>
<a name="ln942">		BFile file(dir, name, B_WRITE_ONLY | B_CREATE_FILE | B_ERASE_FILE);</a>
<a name="ln943">		if (file.InitCheck() != B_OK)</a>
<a name="ln944">			break;</a>
<a name="ln945">		if (roster-&gt;Translate(&amp;stream, NULL, NULL, &amp;file, format-&gt;type) &lt; B_OK)</a>
<a name="ln946">			break;</a>
<a name="ln947">		// set mime type</a>
<a name="ln948">		BNodeInfo info(&amp;file);</a>
<a name="ln949">		if (info.InitCheck() == B_OK)</a>
<a name="ln950">			info.SetType(format-&gt;MIME);</a>
<a name="ln951"> </a>
<a name="ln952">		loop = false;</a>
<a name="ln953">			// break out of loop gracefully (indicates no errors)</a>
<a name="ln954">	}</a>
<a name="ln955">	if (loop) {</a>
<a name="ln956">		// If loop terminated because of a break, there was an error</a>
<a name="ln957">		char buffer[512];</a>
<a name="ln958">		snprintf(buffer, sizeof(buffer), B_TRANSLATE(&quot;The file '%s' could not &quot;</a>
<a name="ln959">			&quot;be written.&quot;), name);</a>
<a name="ln960">		BAlert* palert = new BAlert(&quot;&quot;, buffer, B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln961">		palert-&gt;SetFlags(palert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln962">		palert-&gt;Go();</a>
<a name="ln963">	}</a>
<a name="ln964"> </a>
<a name="ln965">	stream.DetachBitmap(&amp;bitmap);</a>
<a name="ln966">		// Don't allow the bitmap to be deleted, this is</a>
<a name="ln967">		// especially important when using fBitmap as the bitmap</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">void</a>
<a name="ln972">ShowImageView::_SendInMessage(BMessage* msg, BBitmap* bitmap,</a>
<a name="ln973">	translation_format* format)</a>
<a name="ln974">{</a>
<a name="ln975">	BMessage reply(B_MIME_DATA);</a>
<a name="ln976">	BBitmapStream stream(bitmap); // destructor deletes bitmap</a>
<a name="ln977">	BTranslatorRoster* roster = BTranslatorRoster::Default();</a>
<a name="ln978">	BMallocIO memStream;</a>
<a name="ln979">	if (roster-&gt;Translate(&amp;stream, NULL, NULL, &amp;memStream, format-&gt;type) == B_OK) {</a>
<a name="ln980">		reply.AddData(format-&gt;MIME, B_MIME_TYPE, memStream.Buffer(),</a>
<a name="ln981">			memStream.BufferLength());</a>
<a name="ln982">		msg-&gt;SendReply(&amp;reply);</a>
<a name="ln983">	}</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986"> </a>
<a name="ln987">void</a>
<a name="ln988">ShowImageView::_HandleDrop(BMessage* msg)</a>
<a name="ln989">{</a>
<a name="ln990">	entry_ref dirRef;</a>
<a name="ln991">	BString name, type;</a>
<a name="ln992">	bool saveToFile = msg-&gt;FindString(&quot;be:filetypes&quot;, &amp;type) == B_OK</a>
<a name="ln993">		&amp;&amp; msg-&gt;FindRef(&quot;directory&quot;, &amp;dirRef) == B_OK</a>
<a name="ln994">		&amp;&amp; msg-&gt;FindString(&quot;name&quot;, &amp;name) == B_OK;</a>
<a name="ln995"> </a>
<a name="ln996">	bool sendInMessage = !saveToFile</a>
<a name="ln997">		&amp;&amp; msg-&gt;FindString(&quot;be:types&quot;, &amp;type) == B_OK;</a>
<a name="ln998"> </a>
<a name="ln999">	BBitmap* bitmap = _CopySelection();</a>
<a name="ln1000">	if (bitmap == NULL)</a>
<a name="ln1001">		return;</a>
<a name="ln1002"> </a>
<a name="ln1003">	translation_format format;</a>
<a name="ln1004">	if (!_OutputFormatForType(bitmap, type.String(), &amp;format)) {</a>
<a name="ln1005">		delete bitmap;</a>
<a name="ln1006">		return;</a>
<a name="ln1007">	}</a>
<a name="ln1008"> </a>
<a name="ln1009">	if (saveToFile) {</a>
<a name="ln1010">		BDirectory dir(&amp;dirRef);</a>
<a name="ln1011">		SaveToFile(&amp;dir, name.String(), bitmap, &amp;format);</a>
<a name="ln1012">		delete bitmap;</a>
<a name="ln1013">	} else if (sendInMessage) {</a>
<a name="ln1014">		_SendInMessage(msg, bitmap, &amp;format);</a>
<a name="ln1015">	} else {</a>
<a name="ln1016">		delete bitmap;</a>
<a name="ln1017">	}</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020"> </a>
<a name="ln1021">void</a>
<a name="ln1022">ShowImageView::_ScrollBitmap(BPoint point)</a>
<a name="ln1023">{</a>
<a name="ln1024">	point = ConvertToScreen(point);</a>
<a name="ln1025">	BPoint delta = fFirstPoint - point;</a>
<a name="ln1026">	fFirstPoint = point;</a>
<a name="ln1027">	_ScrollRestrictedBy(delta.x, delta.y);</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030"> </a>
<a name="ln1031">void</a>
<a name="ln1032">ShowImageView::_GetMergeRects(BBitmap* merge, BRect selection, BRect&amp; srcRect,</a>
<a name="ln1033">	BRect&amp; dstRect)</a>
<a name="ln1034">{</a>
<a name="ln1035">	// Constrain dstRect to target image size and apply the same edge offsets</a>
<a name="ln1036">	// to the srcRect.</a>
<a name="ln1037"> </a>
<a name="ln1038">	dstRect = selection;</a>
<a name="ln1039"> </a>
<a name="ln1040">	BRect clippedDstRect(dstRect);</a>
<a name="ln1041">	ConstrainToImage(clippedDstRect);</a>
<a name="ln1042"> </a>
<a name="ln1043">	srcRect = merge-&gt;Bounds().OffsetToCopy(B_ORIGIN);</a>
<a name="ln1044"> </a>
<a name="ln1045">	srcRect.left += clippedDstRect.left - dstRect.left;</a>
<a name="ln1046">	srcRect.top += clippedDstRect.top - dstRect.top;</a>
<a name="ln1047">	srcRect.right += clippedDstRect.right - dstRect.right;</a>
<a name="ln1048">	srcRect.bottom += clippedDstRect.bottom - dstRect.bottom;</a>
<a name="ln1049"> </a>
<a name="ln1050">	dstRect = clippedDstRect;</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053"> </a>
<a name="ln1054">void</a>
<a name="ln1055">ShowImageView::_GetSelectionMergeRects(BRect&amp; srcRect, BRect&amp; dstRect)</a>
<a name="ln1056">{</a>
<a name="ln1057">	_GetMergeRects(fSelectionBitmap, fSelectionBox.Bounds(), srcRect, dstRect);</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060"> </a>
<a name="ln1061">void</a>
<a name="ln1062">ShowImageView::_MergeWithBitmap(BBitmap* merge, BRect selection)</a>
<a name="ln1063">{</a>
<a name="ln1064">	BView view(fBitmap-&gt;Bounds(), NULL, B_FOLLOW_NONE, B_WILL_DRAW);</a>
<a name="ln1065">	BBitmap* bitmap = new(nothrow) BBitmap(fBitmap-&gt;Bounds(),</a>
<a name="ln1066">		fBitmap-&gt;ColorSpace(), true);</a>
<a name="ln1067">	if (bitmap == NULL || !bitmap-&gt;IsValid()) {</a>
<a name="ln1068">		delete bitmap;</a>
<a name="ln1069">		return;</a>
<a name="ln1070">	}</a>
<a name="ln1071"> </a>
<a name="ln1072">	if (bitmap-&gt;Lock()) {</a>
<a name="ln1073">		bitmap-&gt;AddChild(&amp;view);</a>
<a name="ln1074">		view.DrawBitmap(fBitmap, fBitmap-&gt;Bounds());</a>
<a name="ln1075">		BRect srcRect;</a>
<a name="ln1076">		BRect dstRect;</a>
<a name="ln1077">		_GetMergeRects(merge, selection, srcRect, dstRect);</a>
<a name="ln1078">		view.DrawBitmap(merge, srcRect, dstRect);</a>
<a name="ln1079"> </a>
<a name="ln1080">		view.Sync();</a>
<a name="ln1081">		bitmap-&gt;RemoveChild(&amp;view);</a>
<a name="ln1082">		bitmap-&gt;Unlock();</a>
<a name="ln1083"> </a>
<a name="ln1084">		_DeleteBitmap();</a>
<a name="ln1085">		fBitmap = bitmap;</a>
<a name="ln1086"> </a>
<a name="ln1087">		_SendMessageToWindow(MSG_MODIFIED);</a>
<a name="ln1088">	} else</a>
<a name="ln1089">		delete bitmap;</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092"> </a>
<a name="ln1093">void</a>
<a name="ln1094">ShowImageView::MouseDown(BPoint position)</a>
<a name="ln1095">{</a>
<a name="ln1096">	MakeFocus(true);</a>
<a name="ln1097"> </a>
<a name="ln1098">	BPoint point = ViewToImage(position);</a>
<a name="ln1099">	int32 clickCount = 0;</a>
<a name="ln1100">	uint32 buttons = 0;</a>
<a name="ln1101">	if (Window() != NULL &amp;&amp; Window()-&gt;CurrentMessage() != NULL) {</a>
<a name="ln1102">		clickCount = Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;clicks&quot;);</a>
<a name="ln1103">		buttons = Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;);</a>
<a name="ln1104">	}</a>
<a name="ln1105"> </a>
<a name="ln1106">	// Using clickCount &gt;= 2 and the modulo 2 accounts for quickly repeated</a>
<a name="ln1107">	// double-clicks</a>
<a name="ln1108">	if (buttons == B_PRIMARY_MOUSE_BUTTON &amp;&amp; clickCount &gt;= 2 &amp;&amp; </a>
<a name="ln1109">			clickCount % 2 == 0) {</a>
<a name="ln1110">		Window()-&gt;PostMessage(MSG_FULL_SCREEN);</a>
<a name="ln1111">		return;</a>
<a name="ln1112">	}</a>
<a name="ln1113"> </a>
<a name="ln1114">	if (fHasSelection &amp;&amp; fSelectionBox.Bounds().Contains(point)</a>
<a name="ln1115">		&amp;&amp; (buttons</a>
<a name="ln1116">				&amp; (B_PRIMARY_MOUSE_BUTTON | B_SECONDARY_MOUSE_BUTTON)) != 0) {</a>
<a name="ln1117">		if (!fSelectionBitmap)</a>
<a name="ln1118">			fSelectionBitmap = _CopySelection();</a>
<a name="ln1119"> </a>
<a name="ln1120">		_BeginDrag(point);</a>
<a name="ln1121">	} else if (buttons == B_PRIMARY_MOUSE_BUTTON</a>
<a name="ln1122">			&amp;&amp; (fSelectionMode</a>
<a name="ln1123">				|| (modifiers() &amp; (B_COMMAND_KEY | B_CONTROL_KEY)) != 0)) {</a>
<a name="ln1124">		// begin new selection</a>
<a name="ln1125">		_SetHasSelection(true);</a>
<a name="ln1126">		fCreatingSelection = true;</a>
<a name="ln1127">		SetMouseEventMask(B_POINTER_EVENTS, B_NO_POINTER_HISTORY);</a>
<a name="ln1128">		ConstrainToImage(point);</a>
<a name="ln1129">		fFirstPoint = point;</a>
<a name="ln1130">		fCopyFromRect.Set(point.x, point.y, point.x, point.y);</a>
<a name="ln1131">		fSelectionBox.SetBounds(this, fCopyFromRect);</a>
<a name="ln1132">		Invalidate();</a>
<a name="ln1133">	} else if (buttons == B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln1134">		_ShowPopUpMenu(ConvertToScreen(position));</a>
<a name="ln1135">	} else if (buttons == B_PRIMARY_MOUSE_BUTTON</a>
<a name="ln1136">		|| buttons == B_TERTIARY_MOUSE_BUTTON) {</a>
<a name="ln1137">		// move image in window</a>
<a name="ln1138">		SetMouseEventMask(B_POINTER_EVENTS, B_NO_POINTER_HISTORY);</a>
<a name="ln1139">		fScrollingBitmap = true;</a>
<a name="ln1140">		fFirstPoint = ConvertToScreen(position);</a>
<a name="ln1141">		be_app-&gt;SetCursor(fGrabCursor);</a>
<a name="ln1142">	}</a>
<a name="ln1143">}</a>
<a name="ln1144"> </a>
<a name="ln1145"> </a>
<a name="ln1146">void</a>
<a name="ln1147">ShowImageView::_UpdateSelectionRect(BPoint point, bool final)</a>
<a name="ln1148">{</a>
<a name="ln1149">	BRect oldSelection = fCopyFromRect;</a>
<a name="ln1150">	point = ViewToImage(point);</a>
<a name="ln1151">	ConstrainToImage(point);</a>
<a name="ln1152">	fCopyFromRect.left = min_c(fFirstPoint.x, point.x);</a>
<a name="ln1153">	fCopyFromRect.right = max_c(fFirstPoint.x, point.x);</a>
<a name="ln1154">	fCopyFromRect.top = min_c(fFirstPoint.y, point.y);</a>
<a name="ln1155">	fCopyFromRect.bottom = max_c(fFirstPoint.y, point.y);</a>
<a name="ln1156">	fSelectionBox.SetBounds(this, fCopyFromRect);</a>
<a name="ln1157"> </a>
<a name="ln1158">	if (final) {</a>
<a name="ln1159">		// selection must be at least 2 pixels wide or 2 pixels tall</a>
<a name="ln1160">		if (fCopyFromRect.Width() &lt; 1.0 &amp;&amp; fCopyFromRect.Height() &lt; 1.0)</a>
<a name="ln1161">			_SetHasSelection(false);</a>
<a name="ln1162">	} else</a>
<a name="ln1163">		_UpdateStatusText();</a>
<a name="ln1164"> </a>
<a name="ln1165">	if (oldSelection != fCopyFromRect || !fHasSelection) {</a>
<a name="ln1166">		BRect updateRect;</a>
<a name="ln1167">		updateRect = oldSelection | fCopyFromRect;</a>
<a name="ln1168">		updateRect = ImageToView(updateRect);</a>
<a name="ln1169">		updateRect.InsetBy(-1, -1);</a>
<a name="ln1170">		Invalidate(updateRect);</a>
<a name="ln1171">	}</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174"> </a>
<a name="ln1175">void</a>
<a name="ln1176">ShowImageView::MouseMoved(BPoint point, uint32 state, const BMessage* message)</a>
<a name="ln1177">{</a>
<a name="ln1178">	fHideCursorCountDown = HIDE_CURSOR_DELAY_TIME;</a>
<a name="ln1179">	if (fHideCursor) {</a>
<a name="ln1180">		// Show toolbar when mouse hits top 15 pixels, hide otherwise</a>
<a name="ln1181">		_ShowToolBarIfEnabled(ConvertToScreen(point).y &lt;= 15);</a>
<a name="ln1182">	}</a>
<a name="ln1183">	if (fCreatingSelection)</a>
<a name="ln1184">		_UpdateSelectionRect(point, false);</a>
<a name="ln1185">	else if (fScrollingBitmap)</a>
<a name="ln1186">		_ScrollBitmap(point);</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189"> </a>
<a name="ln1190">void</a>
<a name="ln1191">ShowImageView::MouseUp(BPoint point)</a>
<a name="ln1192">{</a>
<a name="ln1193">	if (fCreatingSelection) {</a>
<a name="ln1194">		_UpdateSelectionRect(point, true);</a>
<a name="ln1195">		fCreatingSelection = false;</a>
<a name="ln1196">	} else if (fScrollingBitmap) {</a>
<a name="ln1197">		_ScrollBitmap(point);</a>
<a name="ln1198">		fScrollingBitmap = false;</a>
<a name="ln1199">		be_app-&gt;SetCursor(fDefaultCursor);</a>
<a name="ln1200">	}</a>
<a name="ln1201">	_AnimateSelection(true);</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204"> </a>
<a name="ln1205">float</a>
<a name="ln1206">ShowImageView::_LimitToRange(float v, orientation o, bool absolute)</a>
<a name="ln1207">{</a>
<a name="ln1208">	BScrollBar* psb = ScrollBar(o);</a>
<a name="ln1209">	if (psb) {</a>
<a name="ln1210">		float min, max, pos;</a>
<a name="ln1211">		pos = v;</a>
<a name="ln1212">		if (!absolute)</a>
<a name="ln1213">			pos += psb-&gt;Value();</a>
<a name="ln1214"> </a>
<a name="ln1215">		psb-&gt;GetRange(&amp;min, &amp;max);</a>
<a name="ln1216">		if (pos &lt; min)</a>
<a name="ln1217">			pos = min;</a>
<a name="ln1218">		else if (pos &gt; max)</a>
<a name="ln1219">			pos = max;</a>
<a name="ln1220"> </a>
<a name="ln1221">		v = pos;</a>
<a name="ln1222">		if (!absolute)</a>
<a name="ln1223">			v -= psb-&gt;Value();</a>
<a name="ln1224">	}</a>
<a name="ln1225">	return v;</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228"> </a>
<a name="ln1229">void</a>
<a name="ln1230">ShowImageView::_ScrollRestricted(float x, float y, bool absolute)</a>
<a name="ln1231">{</a>
<a name="ln1232">	if (x != 0)</a>
<a name="ln1233">		x = _LimitToRange(x, B_HORIZONTAL, absolute);</a>
<a name="ln1234"> </a>
<a name="ln1235">	if (y != 0)</a>
<a name="ln1236">		y = _LimitToRange(y, B_VERTICAL, absolute);</a>
<a name="ln1237"> </a>
<a name="ln1238">	// We invalidate before we scroll to avoid the caption messing up the</a>
<a name="ln1239">	// image, and to prevent it from flickering</a>
<a name="ln1240">	if (fShowCaption)</a>
<a name="ln1241">		Invalidate();</a>
<a name="ln1242"> </a>
<a name="ln1243">	ScrollBy(x, y);</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246"> </a>
<a name="ln1247">// XXX method is not unused</a>
<a name="ln1248">void</a>
<a name="ln1249">ShowImageView::_ScrollRestrictedTo(float x, float y)</a>
<a name="ln1250">{</a>
<a name="ln1251">	_ScrollRestricted(x, y, true);</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254"> </a>
<a name="ln1255">void</a>
<a name="ln1256">ShowImageView::_ScrollRestrictedBy(float x, float y)</a>
<a name="ln1257">{</a>
<a name="ln1258">	_ScrollRestricted(x, y, false);</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261"> </a>
<a name="ln1262">void</a>
<a name="ln1263">ShowImageView::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln1264">{</a>
<a name="ln1265">	if (numBytes != 1) {</a>
<a name="ln1266">		BView::KeyDown(bytes, numBytes);</a>
<a name="ln1267">		return;</a>
<a name="ln1268">	}</a>
<a name="ln1269"> </a>
<a name="ln1270">	bool shiftKeyDown = (modifiers() &amp; B_SHIFT_KEY) != 0;</a>
<a name="ln1271"> </a>
<a name="ln1272">	switch (*bytes) {</a>
<a name="ln1273">		case B_DOWN_ARROW:</a>
<a name="ln1274">			if (shiftKeyDown)</a>
<a name="ln1275">				_ScrollRestrictedBy(0, 10);</a>
<a name="ln1276">			else</a>
<a name="ln1277">				_SendMessageToWindow(MSG_FILE_NEXT);</a>
<a name="ln1278">			break;</a>
<a name="ln1279">		case B_RIGHT_ARROW:</a>
<a name="ln1280">			if (shiftKeyDown)</a>
<a name="ln1281">				_ScrollRestrictedBy(10, 0);</a>
<a name="ln1282">			else</a>
<a name="ln1283">				_SendMessageToWindow(MSG_FILE_NEXT);</a>
<a name="ln1284">			break;</a>
<a name="ln1285">		case B_UP_ARROW:</a>
<a name="ln1286">			if (shiftKeyDown)</a>
<a name="ln1287">				_ScrollRestrictedBy(0, -10);</a>
<a name="ln1288">			else</a>
<a name="ln1289">				_SendMessageToWindow(MSG_FILE_PREV);</a>
<a name="ln1290">			break;</a>
<a name="ln1291">		case B_LEFT_ARROW:</a>
<a name="ln1292">			if (shiftKeyDown)</a>
<a name="ln1293">				_ScrollRestrictedBy(-10, 0);</a>
<a name="ln1294">			else</a>
<a name="ln1295">				_SendMessageToWindow(MSG_FILE_PREV);</a>
<a name="ln1296">			break;</a>
<a name="ln1297">		case B_BACKSPACE:</a>
<a name="ln1298">			_SendMessageToWindow(MSG_FILE_PREV);</a>
<a name="ln1299">			break;</a>
<a name="ln1300">		case B_HOME:</a>
<a name="ln1301">			break;</a>
<a name="ln1302">		case B_END:</a>
<a name="ln1303">			break;</a>
<a name="ln1304">		case B_SPACE:</a>
<a name="ln1305">			_ToggleSlideShow();</a>
<a name="ln1306">			break;</a>
<a name="ln1307">		case B_ESCAPE:</a>
<a name="ln1308">			// stop slide show</a>
<a name="ln1309">			_StopSlideShow();</a>
<a name="ln1310">			_ExitFullScreen();</a>
<a name="ln1311"> </a>
<a name="ln1312">			ClearSelection();</a>
<a name="ln1313">			break;</a>
<a name="ln1314">		case B_DELETE:</a>
<a name="ln1315">			if (fHasSelection)</a>
<a name="ln1316">				ClearSelection();</a>
<a name="ln1317">			else</a>
<a name="ln1318">				_SendMessageToWindow(kMsgDeleteCurrentFile);</a>
<a name="ln1319">			break;</a>
<a name="ln1320">		case '0':</a>
<a name="ln1321">			FitToBounds();</a>
<a name="ln1322">			break;</a>
<a name="ln1323">		case '1':</a>
<a name="ln1324">			SetZoom(1.0f);</a>
<a name="ln1325">			break;</a>
<a name="ln1326">		case '+':</a>
<a name="ln1327">		case '=':</a>
<a name="ln1328">			ZoomIn();</a>
<a name="ln1329">			break;</a>
<a name="ln1330">		case '-':</a>
<a name="ln1331">			ZoomOut();</a>
<a name="ln1332">			break;</a>
<a name="ln1333">		case '[':</a>
<a name="ln1334">			Rotate(270);</a>
<a name="ln1335">			break;</a>
<a name="ln1336">		case ']':</a>
<a name="ln1337">			Rotate(90);</a>
<a name="ln1338">			break;</a>
<a name="ln1339">	}</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342"> </a>
<a name="ln1343">void</a>
<a name="ln1344">ShowImageView::_MouseWheelChanged(BMessage* message)</a>
<a name="ln1345">{</a>
<a name="ln1346">	// The BeOS driver does not currently support</a>
<a name="ln1347">	// X wheel scrolling, therefore, deltaX is zero.</a>
<a name="ln1348">	// |deltaY| is the number of notches scrolled up or down.</a>
<a name="ln1349">	// When the wheel is scrolled down (towards the user) deltaY &gt; 0</a>
<a name="ln1350">	// When the wheel is scrolled up (away from the user) deltaY &lt; 0</a>
<a name="ln1351">	const float kscrollBy = 40;</a>
<a name="ln1352">	float deltaY;</a>
<a name="ln1353">	float deltaX;</a>
<a name="ln1354">	float x = 0;</a>
<a name="ln1355">	float y = 0;</a>
<a name="ln1356"> </a>
<a name="ln1357">	if (message-&gt;FindFloat(&quot;be:wheel_delta_x&quot;, &amp;deltaX) == B_OK)</a>
<a name="ln1358">		x = deltaX * kscrollBy;</a>
<a name="ln1359"> </a>
<a name="ln1360">	if (message-&gt;FindFloat(&quot;be:wheel_delta_y&quot;, &amp;deltaY) == B_OK)</a>
<a name="ln1361">		y = deltaY * kscrollBy;</a>
<a name="ln1362"> </a>
<a name="ln1363">	if ((modifiers() &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln1364">		// scroll up and down</a>
<a name="ln1365">		_ScrollRestrictedBy(x, y);</a>
<a name="ln1366">	} else if ((modifiers() &amp; B_CONTROL_KEY) != 0) {</a>
<a name="ln1367">		// scroll left and right</a>
<a name="ln1368">		_ScrollRestrictedBy(y, x);</a>
<a name="ln1369">	} else {</a>
<a name="ln1370">		// zoom at location</a>
<a name="ln1371">		BPoint where;</a>
<a name="ln1372">		uint32 buttons;</a>
<a name="ln1373">		GetMouse(&amp;where, &amp;buttons);</a>
<a name="ln1374"> </a>
<a name="ln1375">		if (fStickyZoomCountDown &lt;= 0) {</a>
<a name="ln1376">			if (deltaY &lt; 0)</a>
<a name="ln1377">				ZoomIn(where);</a>
<a name="ln1378">			else if (deltaY &gt; 0)</a>
<a name="ln1379">				ZoomOut(where);</a>
<a name="ln1380"> </a>
<a name="ln1381">			if (fZoom == 1.0)</a>
<a name="ln1382">				fStickyZoomCountDown = STICKY_ZOOM_DELAY_TIME;</a>
<a name="ln1383">		}</a>
<a name="ln1384"> </a>
<a name="ln1385">	}</a>
<a name="ln1386">}</a>
<a name="ln1387"> </a>
<a name="ln1388"> </a>
<a name="ln1389">void</a>
<a name="ln1390">ShowImageView::_ShowPopUpMenu(BPoint screen)</a>
<a name="ln1391">{</a>
<a name="ln1392">	if (!fShowingPopUpMenu) {</a>
<a name="ln1393">		PopUpMenu* menu = new PopUpMenu(&quot;PopUpMenu&quot;, this);</a>
<a name="ln1394"> </a>
<a name="ln1395">		ShowImageWindow* window = dynamic_cast&lt;ShowImageWindow*&gt;(Window());</a>
<a name="ln1396">		if (window != NULL)</a>
<a name="ln1397">			window-&gt;BuildContextMenu(menu);</a>
<a name="ln1398"> </a>
<a name="ln1399">		menu-&gt;Go(screen, true, true, true);</a>
<a name="ln1400">		fShowingPopUpMenu = true;</a>
<a name="ln1401">	}</a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>
<a name="ln1404"> </a>
<a name="ln1405">void</a>
<a name="ln1406">ShowImageView::_SettingsSetBool(const char* name, bool value)</a>
<a name="ln1407">{</a>
<a name="ln1408">	ShowImageSettings* settings;</a>
<a name="ln1409">	settings = my_app-&gt;Settings();</a>
<a name="ln1410">	if (settings-&gt;Lock()) {</a>
<a name="ln1411">		settings-&gt;SetBool(name, value);</a>
<a name="ln1412">		settings-&gt;Unlock();</a>
<a name="ln1413">	}</a>
<a name="ln1414">}</a>
<a name="ln1415"> </a>
<a name="ln1416"> </a>
<a name="ln1417">void</a>
<a name="ln1418">ShowImageView::MessageReceived(BMessage* message)</a>
<a name="ln1419">{</a>
<a name="ln1420">	switch (message-&gt;what) {</a>
<a name="ln1421">		case B_COPY_TARGET:</a>
<a name="ln1422">			_HandleDrop(message);</a>
<a name="ln1423">			break;</a>
<a name="ln1424"> </a>
<a name="ln1425">		case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln1426">			_MouseWheelChanged(message);</a>
<a name="ln1427">			break;</a>
<a name="ln1428"> </a>
<a name="ln1429">		case kMsgPopUpMenuClosed:</a>
<a name="ln1430">			fShowingPopUpMenu = false;</a>
<a name="ln1431">			break;</a>
<a name="ln1432"> </a>
<a name="ln1433">		default:</a>
<a name="ln1434">			BView::MessageReceived(message);</a>
<a name="ln1435">			break;</a>
<a name="ln1436">	}</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439"> </a>
<a name="ln1440">void</a>
<a name="ln1441">ShowImageView::FixupScrollBar(orientation o, float bitmapLength,</a>
<a name="ln1442">	float viewLength)</a>
<a name="ln1443">{</a>
<a name="ln1444">	float prop, range;</a>
<a name="ln1445">	BScrollBar* psb;</a>
<a name="ln1446"> </a>
<a name="ln1447">	psb = ScrollBar(o);</a>
<a name="ln1448">	if (psb) {</a>
<a name="ln1449">		range = bitmapLength - viewLength;</a>
<a name="ln1450">		if (range &lt; 0.0)</a>
<a name="ln1451">			range = 0.0;</a>
<a name="ln1452"> </a>
<a name="ln1453">		prop = viewLength / bitmapLength;</a>
<a name="ln1454">		if (prop &gt; 1.0)</a>
<a name="ln1455">			prop = 1.0;</a>
<a name="ln1456"> </a>
<a name="ln1457">		psb-&gt;SetRange(0, range);</a>
<a name="ln1458">		psb-&gt;SetProportion(prop);</a>
<a name="ln1459">		psb-&gt;SetSteps(10, 100);</a>
<a name="ln1460">	}</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463"> </a>
<a name="ln1464">void</a>
<a name="ln1465">ShowImageView::FixupScrollBars()</a>
<a name="ln1466">{</a>
<a name="ln1467">	BRect viewRect = Bounds();</a>
<a name="ln1468">	BRect bitmapRect;</a>
<a name="ln1469">	if (fBitmap != NULL) {</a>
<a name="ln1470">		bitmapRect = _AlignBitmap();</a>
<a name="ln1471">		bitmapRect.OffsetTo(0, 0);</a>
<a name="ln1472">	}</a>
<a name="ln1473"> </a>
<a name="ln1474">	FixupScrollBar(B_HORIZONTAL, bitmapRect.Width(), viewRect.Width());</a>
<a name="ln1475">	FixupScrollBar(B_VERTICAL, bitmapRect.Height(), viewRect.Height());</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478"> </a>
<a name="ln1479">void</a>
<a name="ln1480">ShowImageView::SetSelectionMode(bool selectionMode)</a>
<a name="ln1481">{</a>
<a name="ln1482">	// The mode only has an effect in MouseDown()</a>
<a name="ln1483">	fSelectionMode = selectionMode;</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486"> </a>
<a name="ln1487">void</a>
<a name="ln1488">ShowImageView::SelectAll()</a>
<a name="ln1489">{</a>
<a name="ln1490">	fCopyFromRect.Set(0, 0, fBitmap-&gt;Bounds().Width(),</a>
<a name="ln1491">		fBitmap-&gt;Bounds().Height());</a>
<a name="ln1492">	fSelectionBox.SetBounds(this, fCopyFromRect);</a>
<a name="ln1493">	_SetHasSelection(true);</a>
<a name="ln1494">	Invalidate();</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497"> </a>
<a name="ln1498">void</a>
<a name="ln1499">ShowImageView::ClearSelection()</a>
<a name="ln1500">{</a>
<a name="ln1501">	if (!fHasSelection)</a>
<a name="ln1502">		return;</a>
<a name="ln1503"> </a>
<a name="ln1504">	_SetHasSelection(false);</a>
<a name="ln1505">	Invalidate();</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508"> </a>
<a name="ln1509">void</a>
<a name="ln1510">ShowImageView::_SetHasSelection(bool hasSelection)</a>
<a name="ln1511">{</a>
<a name="ln1512">	_DeleteSelectionBitmap();</a>
<a name="ln1513">	fHasSelection = hasSelection;</a>
<a name="ln1514"> </a>
<a name="ln1515">	_UpdateStatusText();</a>
<a name="ln1516"> </a>
<a name="ln1517">	BMessage msg(MSG_SELECTION);</a>
<a name="ln1518">	msg.AddBool(&quot;has_selection&quot;, fHasSelection);</a>
<a name="ln1519">	_SendMessageToWindow(&amp;msg);</a>
<a name="ln1520">}</a>
<a name="ln1521"> </a>
<a name="ln1522"> </a>
<a name="ln1523">void</a>
<a name="ln1524">ShowImageView::CopySelectionToClipboard()</a>
<a name="ln1525">{</a>
<a name="ln1526">	if (!fHasSelection || !be_clipboard-&gt;Lock())</a>
<a name="ln1527">		return;</a>
<a name="ln1528"> </a>
<a name="ln1529">	be_clipboard-&gt;Clear();</a>
<a name="ln1530"> </a>
<a name="ln1531">	BMessage* data = be_clipboard-&gt;Data();</a>
<a name="ln1532">	if (data != NULL) {</a>
<a name="ln1533">		BBitmap* bitmap = _CopySelection();</a>
<a name="ln1534">		if (bitmap != NULL) {</a>
<a name="ln1535">			BMessage bitmapArchive;</a>
<a name="ln1536">			bitmap-&gt;Archive(&amp;bitmapArchive);</a>
<a name="ln1537">			// NOTE: Possibly &quot;image/x-be-bitmap&quot; is more correct.</a>
<a name="ln1538">			// This works with WonderBrush, though, which in turn had been</a>
<a name="ln1539">			// tested with other apps.</a>
<a name="ln1540">			data-&gt;AddMessage(&quot;image/bitmap&quot;, &amp;bitmapArchive);</a>
<a name="ln1541">			data-&gt;AddPoint(&quot;be:location&quot;, fSelectionBox.Bounds().LeftTop());</a>
<a name="ln1542"> </a>
<a name="ln1543">			delete bitmap;</a>
<a name="ln1544"> </a>
<a name="ln1545">			be_clipboard-&gt;Commit();</a>
<a name="ln1546">		}</a>
<a name="ln1547">	}</a>
<a name="ln1548">	be_clipboard-&gt;Unlock();</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551"> </a>
<a name="ln1552">void</a>
<a name="ln1553">ShowImageView::SetZoom(float zoom, BPoint where)</a>
<a name="ln1554">{</a>
<a name="ln1555">	float fitToBoundsZoom = _FitToBoundsZoom();</a>
<a name="ln1556">	if (zoom &gt; 32)</a>
<a name="ln1557">		zoom = 32;</a>
<a name="ln1558">	if (zoom &lt; fitToBoundsZoom / 2 &amp;&amp; zoom &lt; 0.25)</a>
<a name="ln1559">		zoom = min_c(fitToBoundsZoom / 2, 0.25);</a>
<a name="ln1560"> </a>
<a name="ln1561">	if (zoom == fZoom) {</a>
<a name="ln1562">		// window size might have changed</a>
<a name="ln1563">		FixupScrollBars();</a>
<a name="ln1564">		return;</a>
<a name="ln1565">	}</a>
<a name="ln1566"> </a>
<a name="ln1567">	// Invalidate before scrolling, as that prevents the app_server</a>
<a name="ln1568">	// to do the scrolling server side</a>
<a name="ln1569">	Invalidate();</a>
<a name="ln1570"> </a>
<a name="ln1571">	// zoom to center if not otherwise specified</a>
<a name="ln1572">	BPoint offset;</a>
<a name="ln1573">	if (where.x == -1) {</a>
<a name="ln1574">		where.Set(Bounds().Width() / 2, Bounds().Height() / 2);</a>
<a name="ln1575">		offset = where;</a>
<a name="ln1576">		where += Bounds().LeftTop();</a>
<a name="ln1577">	} else</a>
<a name="ln1578">		offset = where - Bounds().LeftTop();</a>
<a name="ln1579"> </a>
<a name="ln1580">	float oldZoom = fZoom;</a>
<a name="ln1581">	fZoom = zoom;</a>
<a name="ln1582"> </a>
<a name="ln1583">	FixupScrollBars();</a>
<a name="ln1584"> </a>
<a name="ln1585">	if (fBitmap != NULL) {</a>
<a name="ln1586">		offset.x = (int)(where.x * fZoom / oldZoom + 0.5) - offset.x;</a>
<a name="ln1587">		offset.y = (int)(where.y * fZoom / oldZoom + 0.5) - offset.y;</a>
<a name="ln1588">		ScrollTo(offset);</a>
<a name="ln1589">	}</a>
<a name="ln1590"> </a>
<a name="ln1591">	BMessage message(MSG_UPDATE_STATUS_ZOOM);</a>
<a name="ln1592">	message.AddFloat(&quot;zoom&quot;, fZoom);</a>
<a name="ln1593">	_SendMessageToWindow(&amp;message);</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596"> </a>
<a name="ln1597">void</a>
<a name="ln1598">ShowImageView::ZoomIn(BPoint where)</a>
<a name="ln1599">{</a>
<a name="ln1600">	// snap zoom to &quot;fit to bounds&quot;, and &quot;original size&quot;</a>
<a name="ln1601">	float zoom = fZoom * 1.2;</a>
<a name="ln1602">	float zoomSnap = fZoom * 1.25;</a>
<a name="ln1603">	float fitToBoundsZoom = _FitToBoundsZoom();</a>
<a name="ln1604">	if (fZoom &lt; fitToBoundsZoom - 0.001 &amp;&amp; zoomSnap &gt; fitToBoundsZoom)</a>
<a name="ln1605">		zoom = fitToBoundsZoom;</a>
<a name="ln1606">	if (fZoom &lt; 1.0 &amp;&amp; zoomSnap &gt; 1.0)</a>
<a name="ln1607">		zoom = 1.0;</a>
<a name="ln1608"> </a>
<a name="ln1609">	SetZoom(zoom, where);</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612"> </a>
<a name="ln1613">void</a>
<a name="ln1614">ShowImageView::ZoomOut(BPoint where)</a>
<a name="ln1615">{</a>
<a name="ln1616">	// snap zoom to &quot;fit to bounds&quot;, and &quot;original size&quot;</a>
<a name="ln1617">	float zoom = fZoom / 1.2;</a>
<a name="ln1618">	float zoomSnap = fZoom / 1.25;</a>
<a name="ln1619">	float fitToBoundsZoom = _FitToBoundsZoom();</a>
<a name="ln1620">	if (fZoom &gt; fitToBoundsZoom + 0.001 &amp;&amp; zoomSnap &lt; fitToBoundsZoom)</a>
<a name="ln1621">		zoom = fitToBoundsZoom;</a>
<a name="ln1622">	if (fZoom &gt; 1.0 &amp;&amp; zoomSnap &lt; 1.0)</a>
<a name="ln1623">		zoom = 1.0;</a>
<a name="ln1624"> </a>
<a name="ln1625">	SetZoom(zoom, where);</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628"> </a>
<a name="ln1629">/*!	Fits the image to the view bounds.</a>
<a name="ln1630">*/</a>
<a name="ln1631">void</a>
<a name="ln1632">ShowImageView::FitToBounds()</a>
<a name="ln1633">{</a>
<a name="ln1634">	if (fBitmap == NULL)</a>
<a name="ln1635">		return;</a>
<a name="ln1636"> </a>
<a name="ln1637">	float fitToBoundsZoom = _FitToBoundsZoom();</a>
<a name="ln1638">	if ((!fStretchToBounds &amp;&amp; fitToBoundsZoom &gt; 1.0f) || fForceOriginalSize)</a>
<a name="ln1639">		SetZoom(1.0f);</a>
<a name="ln1640">	else</a>
<a name="ln1641">		SetZoom(fitToBoundsZoom);</a>
<a name="ln1642"> </a>
<a name="ln1643">	FixupScrollBars();</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646"> </a>
<a name="ln1647">void</a>
<a name="ln1648">ShowImageView::_DoImageOperation(ImageProcessor::operation op, bool quiet)</a>
<a name="ln1649">{</a>
<a name="ln1650">	BMessenger msgr;</a>
<a name="ln1651">	ImageProcessor imageProcessor(op, fBitmap, msgr, 0);</a>
<a name="ln1652">	imageProcessor.Start(false);</a>
<a name="ln1653">	BBitmap* bm = imageProcessor.DetachBitmap();</a>
<a name="ln1654">	if (bm == NULL) {</a>
<a name="ln1655">		// operation failed</a>
<a name="ln1656">		return;</a>
<a name="ln1657">	}</a>
<a name="ln1658"> </a>
<a name="ln1659">	// update orientation state</a>
<a name="ln1660">	if (op != ImageProcessor::kInvert) {</a>
<a name="ln1661">		// Note: If one of these fails, check its definition in class ImageProcessor.</a>
<a name="ln1662">//		ASSERT(ImageProcessor::kRotateClockwise &lt;</a>
<a name="ln1663">//			ImageProcessor::kNumberOfAffineTransformations);</a>
<a name="ln1664">//		ASSERT(ImageProcessor::kRotateCounterClockwise &lt;</a>
<a name="ln1665">//			ImageProcessor::kNumberOfAffineTransformations);</a>
<a name="ln1666">//		ASSERT(ImageProcessor::kFlipLeftToRight &lt;</a>
<a name="ln1667">//			ImageProcessor::kNumberOfAffineTransformations);</a>
<a name="ln1668">//		ASSERT(ImageProcessor::kFlipTopToBottom &lt;</a>
<a name="ln1669">//			ImageProcessor::kNumberOfAffineTransformations);</a>
<a name="ln1670">		fImageOrientation = fTransformation[op][fImageOrientation];</a>
<a name="ln1671">	}</a>
<a name="ln1672"> </a>
<a name="ln1673">	if (!quiet) {</a>
<a name="ln1674">		// write orientation state</a>
<a name="ln1675">		BNode node(&amp;fCurrentRef);</a>
<a name="ln1676">		int32 orientation = fImageOrientation;</a>
<a name="ln1677">		if (orientation != k0) {</a>
<a name="ln1678">			node.WriteAttr(SHOW_IMAGE_ORIENTATION_ATTRIBUTE, B_INT32_TYPE, 0,</a>
<a name="ln1679">				&amp;orientation, sizeof(orientation));</a>
<a name="ln1680">		} else</a>
<a name="ln1681">			node.RemoveAttr(SHOW_IMAGE_ORIENTATION_ATTRIBUTE);</a>
<a name="ln1682">	}</a>
<a name="ln1683"> </a>
<a name="ln1684">	// set new bitmap</a>
<a name="ln1685">	_DeleteBitmap();</a>
<a name="ln1686">	fBitmap = bm;</a>
<a name="ln1687"> </a>
<a name="ln1688">	if (fBitmap-&gt;ColorSpace() == B_RGBA32)</a>
<a name="ln1689">		fDisplayBitmap = compose_checker_background(fBitmap);</a>
<a name="ln1690"> </a>
<a name="ln1691">	if (!quiet) {</a>
<a name="ln1692">		// remove selection</a>
<a name="ln1693">		_SetHasSelection(false);</a>
<a name="ln1694">		_Notify();</a>
<a name="ln1695">	}</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698"> </a>
<a name="ln1699">//! Image operation initiated by user</a>
<a name="ln1700">void</a>
<a name="ln1701">ShowImageView::_UserDoImageOperation(ImageProcessor::operation op, bool quiet)</a>
<a name="ln1702">{</a>
<a name="ln1703">	_DoImageOperation(op, quiet);</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706"> </a>
<a name="ln1707">void</a>
<a name="ln1708">ShowImageView::Rotate(int degree)</a>
<a name="ln1709">{</a>
<a name="ln1710">	_UserDoImageOperation(degree == 90 ? ImageProcessor::kRotateClockwise</a>
<a name="ln1711">		: ImageProcessor::kRotateCounterClockwise);</a>
<a name="ln1712"> </a>
<a name="ln1713">	FitToBounds();</a>
<a name="ln1714">}</a>
<a name="ln1715"> </a>
<a name="ln1716"> </a>
<a name="ln1717">void</a>
<a name="ln1718">ShowImageView::Flip(bool vertical)</a>
<a name="ln1719">{</a>
<a name="ln1720">	if (vertical)</a>
<a name="ln1721">		_UserDoImageOperation(ImageProcessor::kFlipLeftToRight);</a>
<a name="ln1722">	else</a>
<a name="ln1723">		_UserDoImageOperation(ImageProcessor::kFlipTopToBottom);</a>
<a name="ln1724">}</a>
<a name="ln1725"> </a>
<a name="ln1726"> </a>
<a name="ln1727">void</a>
<a name="ln1728">ShowImageView::ResizeImage(int w, int h)</a>
<a name="ln1729">{</a>
<a name="ln1730">	if (fBitmap == NULL || w &lt; 1 || h &lt; 1)</a>
<a name="ln1731">		return;</a>
<a name="ln1732"> </a>
<a name="ln1733">	Scaler scaler(fBitmap, BRect(0, 0, w - 1, h - 1), BMessenger(), 0, false);</a>
<a name="ln1734">	scaler.Start(false);</a>
<a name="ln1735">	BBitmap* scaled = scaler.DetachBitmap();</a>
<a name="ln1736">	if (scaled == NULL) {</a>
<a name="ln1737">		// operation failed</a>
<a name="ln1738">		return;</a>
<a name="ln1739">	}</a>
<a name="ln1740"> </a>
<a name="ln1741">	// remove selection</a>
<a name="ln1742">	_SetHasSelection(false);</a>
<a name="ln1743">	_DeleteBitmap();</a>
<a name="ln1744">	fBitmap = scaled;</a>
<a name="ln1745"> </a>
<a name="ln1746">	_SendMessageToWindow(MSG_MODIFIED);</a>
<a name="ln1747"> </a>
<a name="ln1748">	_Notify();</a>
<a name="ln1749">}</a>
<a name="ln1750"> </a>
<a name="ln1751"> </a>
<a name="ln1752">void</a>
<a name="ln1753">ShowImageView::_SetIcon(bool clear, icon_size which)</a>
<a name="ln1754">{</a>
<a name="ln1755">	int32 size;</a>
<a name="ln1756">	switch (which) {</a>
<a name="ln1757">		case B_MINI_ICON: size = 16;</a>
<a name="ln1758">			break;</a>
<a name="ln1759">		case B_LARGE_ICON: size = 32;</a>
<a name="ln1760">			break;</a>
<a name="ln1761">		default:</a>
<a name="ln1762">			return;</a>
<a name="ln1763">	}</a>
<a name="ln1764"> </a>
<a name="ln1765">	BRect rect(fBitmap-&gt;Bounds());</a>
<a name="ln1766">	float s;</a>
<a name="ln1767">	s = size / (rect.Width() + 1.0);</a>
<a name="ln1768"> </a>
<a name="ln1769">	if (s * (rect.Height() + 1.0) &lt;= size) {</a>
<a name="ln1770">		rect.right = size - 1;</a>
<a name="ln1771">		rect.bottom = static_cast&lt;int&gt;(s * (rect.Height() + 1.0)) - 1;</a>
<a name="ln1772">		// center vertically</a>
<a name="ln1773">		rect.OffsetBy(0, (size - rect.IntegerHeight()) / 2);</a>
<a name="ln1774">	} else {</a>
<a name="ln1775">		s = size / (rect.Height() + 1.0);</a>
<a name="ln1776">		rect.right = static_cast&lt;int&gt;(s * (rect.Width() + 1.0)) - 1;</a>
<a name="ln1777">		rect.bottom = size - 1;</a>
<a name="ln1778">		// center horizontally</a>
<a name="ln1779">		rect.OffsetBy((size - rect.IntegerWidth()) / 2, 0);</a>
<a name="ln1780">	}</a>
<a name="ln1781"> </a>
<a name="ln1782">	// scale bitmap to thumbnail size</a>
<a name="ln1783">	BMessenger msgr;</a>
<a name="ln1784">	Scaler scaler(fBitmap, rect, msgr, 0, true);</a>
<a name="ln1785">	BBitmap* thumbnail = scaler.GetBitmap();</a>
<a name="ln1786">	scaler.Start(false);</a>
<a name="ln1787">	ASSERT(thumbnail-&gt;ColorSpace() == B_CMAP8);</a>
<a name="ln1788">	// create icon from thumbnail</a>
<a name="ln1789">	BBitmap icon(BRect(0, 0, size - 1, size - 1), B_CMAP8);</a>
<a name="ln1790">	memset(icon.Bits(), B_TRANSPARENT_MAGIC_CMAP8, icon.BitsLength());</a>
<a name="ln1791">	BScreen screen;</a>
<a name="ln1792">	const uchar* src = (uchar*)thumbnail-&gt;Bits();</a>
<a name="ln1793">	uchar* dest = (uchar*)icon.Bits();</a>
<a name="ln1794">	const int32 srcBPR = thumbnail-&gt;BytesPerRow();</a>
<a name="ln1795">	const int32 destBPR = icon.BytesPerRow();</a>
<a name="ln1796">	const int32 deltaX = (int32)rect.left;</a>
<a name="ln1797">	const int32 deltaY = (int32)rect.top;</a>
<a name="ln1798"> </a>
<a name="ln1799">	for (int32 y = 0; y &lt;= rect.IntegerHeight(); y++) {</a>
<a name="ln1800">		for (int32 x = 0; x &lt;= rect.IntegerWidth(); x++) {</a>
<a name="ln1801">			const uchar* s = src + y * srcBPR + x;</a>
<a name="ln1802">			uchar* d = dest + (y + deltaY) * destBPR + (x + deltaX);</a>
<a name="ln1803">			*d = *s;</a>
<a name="ln1804">		}</a>
<a name="ln1805">	}</a>
<a name="ln1806"> </a>
<a name="ln1807">	// set icon</a>
<a name="ln1808">	BNode node(&amp;fCurrentRef);</a>
<a name="ln1809">	BNodeInfo info(&amp;node);</a>
<a name="ln1810">	info.SetIcon(clear ? NULL : &amp;icon, which);</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813"> </a>
<a name="ln1814">void</a>
<a name="ln1815">ShowImageView::SetIcon(bool clear)</a>
<a name="ln1816">{</a>
<a name="ln1817">	_SetIcon(clear, B_MINI_ICON);</a>
<a name="ln1818">	_SetIcon(clear, B_LARGE_ICON);</a>
<a name="ln1819">}</a>
<a name="ln1820"> </a>
<a name="ln1821"> </a>
<a name="ln1822">void</a>
<a name="ln1823">ShowImageView::_ToggleSlideShow()</a>
<a name="ln1824">{</a>
<a name="ln1825">	_SendMessageToWindow(MSG_SLIDE_SHOW);</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828"> </a>
<a name="ln1829">void</a>
<a name="ln1830">ShowImageView::_StopSlideShow()</a>
<a name="ln1831">{</a>
<a name="ln1832">	_SendMessageToWindow(kMsgStopSlideShow);</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835"> </a>
<a name="ln1836">void</a>
<a name="ln1837">ShowImageView::_ExitFullScreen()</a>
<a name="ln1838">{</a>
<a name="ln1839">	be_app-&gt;ShowCursor();</a>
<a name="ln1840">	_SendMessageToWindow(MSG_EXIT_FULL_SCREEN);</a>
<a name="ln1841">}</a>
<a name="ln1842"> </a>
<a name="ln1843"> </a>
<a name="ln1844">void</a>
<a name="ln1845">ShowImageView::_ShowToolBarIfEnabled(bool show)</a>
<a name="ln1846">{</a>
<a name="ln1847">	BMessage message(kShowToolBarIfEnabled);</a>
<a name="ln1848">	message.AddBool(&quot;show&quot;, show);</a>
<a name="ln1849">	Window()-&gt;PostMessage(&amp;message);</a>
<a name="ln1850">}</a>
<a name="ln1851"> </a>
<a name="ln1852"> </a>
<a name="ln1853">void</a>
<a name="ln1854">ShowImageView::WindowActivated(bool active)</a>
<a name="ln1855">{</a>
<a name="ln1856">	fIsActiveWin = active;</a>
<a name="ln1857">	fHideCursorCountDown = HIDE_CURSOR_DELAY_TIME;</a>
<a name="ln1858">}</a>
<a name="ln1859"> </a>

</code></pre>
<div class="balloon" rel="173"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fImageOrientation.</p></div>
<div class="balloon" rel="963"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'palert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
